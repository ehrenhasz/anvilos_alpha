{
  "module_name": "sta_info.h",
  "hash_id": "11d0aa29d6c7b7d3bce8b81ca101dd6e43e497ac80e4152d930e794ef1cae0b7",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/sta_info.h",
  "human_readable_source": " \n \n\n#ifndef STA_INFO_H\n#define STA_INFO_H\n\n#include <linux/list.h>\n#include <linux/types.h>\n#include <linux/if_ether.h>\n#include <linux/workqueue.h>\n#include <linux/average.h>\n#include <linux/bitfield.h>\n#include <linux/etherdevice.h>\n#include <linux/rhashtable.h>\n#include <linux/u64_stats_sync.h>\n#include \"key.h\"\n\n \nenum ieee80211_sta_info_flags {\n\tWLAN_STA_AUTH,\n\tWLAN_STA_ASSOC,\n\tWLAN_STA_PS_STA,\n\tWLAN_STA_AUTHORIZED,\n\tWLAN_STA_SHORT_PREAMBLE,\n\tWLAN_STA_WDS,\n\tWLAN_STA_CLEAR_PS_FILT,\n\tWLAN_STA_MFP,\n\tWLAN_STA_BLOCK_BA,\n\tWLAN_STA_PS_DRIVER,\n\tWLAN_STA_PSPOLL,\n\tWLAN_STA_TDLS_PEER,\n\tWLAN_STA_TDLS_PEER_AUTH,\n\tWLAN_STA_TDLS_INITIATOR,\n\tWLAN_STA_TDLS_CHAN_SWITCH,\n\tWLAN_STA_TDLS_OFF_CHANNEL,\n\tWLAN_STA_TDLS_WIDER_BW,\n\tWLAN_STA_UAPSD,\n\tWLAN_STA_SP,\n\tWLAN_STA_4ADDR_EVENT,\n\tWLAN_STA_INSERTED,\n\tWLAN_STA_RATE_CONTROL,\n\tWLAN_STA_TOFFSET_KNOWN,\n\tWLAN_STA_MPSP_OWNER,\n\tWLAN_STA_MPSP_RECIPIENT,\n\tWLAN_STA_PS_DELIVER,\n\tWLAN_STA_USES_ENCRYPTION,\n\tWLAN_STA_DECAP_OFFLOAD,\n\n\tNUM_WLAN_STA_FLAGS,\n};\n\n#define ADDBA_RESP_INTERVAL HZ\n#define HT_AGG_MAX_RETRIES\t\t15\n#define HT_AGG_BURST_RETRIES\t\t3\n#define HT_AGG_RETRIES_PERIOD\t\t(15 * HZ)\n\n#define HT_AGG_STATE_DRV_READY\t\t0\n#define HT_AGG_STATE_RESPONSE_RECEIVED\t1\n#define HT_AGG_STATE_OPERATIONAL\t2\n#define HT_AGG_STATE_STOPPING\t\t3\n#define HT_AGG_STATE_WANT_START\t\t4\n#define HT_AGG_STATE_WANT_STOP\t\t5\n#define HT_AGG_STATE_START_CB\t\t6\n#define HT_AGG_STATE_STOP_CB\t\t7\n#define HT_AGG_STATE_SENT_ADDBA\t\t8\n\nDECLARE_EWMA(avg_signal, 10, 8)\nenum ieee80211_agg_stop_reason {\n\tAGG_STOP_DECLINED,\n\tAGG_STOP_LOCAL_REQUEST,\n\tAGG_STOP_PEER_REQUEST,\n\tAGG_STOP_DESTROY_STA,\n};\n\n \n#define AIRTIME_USE_TX\t\tBIT(0)\n#define AIRTIME_USE_RX\t\tBIT(1)\n\nstruct airtime_info {\n\tu64 rx_airtime;\n\tu64 tx_airtime;\n\tu32 last_active;\n\ts32 deficit;\n\tatomic_t aql_tx_pending;  \n\tu32 aql_limit_low;\n\tu32 aql_limit_high;\n};\n\nvoid ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,\n\t\t\t\t\t  struct sta_info *sta, u8 ac,\n\t\t\t\t\t  u16 tx_airtime, bool tx_completed);\n\nstruct sta_info;\n\n \nstruct tid_ampdu_tx {\n\tstruct rcu_head rcu_head;\n\tstruct timer_list session_timer;\n\tstruct timer_list addba_resp_timer;\n\tstruct sk_buff_head pending;\n\tstruct sta_info *sta;\n\tunsigned long state;\n\tunsigned long last_tx;\n\tu16 timeout;\n\tu8 dialog_token;\n\tu8 stop_initiator;\n\tbool tx_stop;\n\tu16 buf_size;\n\tu16 ssn;\n\n\tu16 failed_bar_ssn;\n\tbool bar_pending;\n\tbool amsdu;\n\tu8 tid;\n};\n\n \nstruct tid_ampdu_rx {\n\tstruct rcu_head rcu_head;\n\tspinlock_t reorder_lock;\n\tu64 reorder_buf_filtered;\n\tstruct sk_buff_head *reorder_buf;\n\tunsigned long *reorder_time;\n\tstruct sta_info *sta;\n\tstruct timer_list session_timer;\n\tstruct timer_list reorder_timer;\n\tunsigned long last_rx;\n\tu16 head_seq_num;\n\tu16 stored_mpdu_num;\n\tu16 ssn;\n\tu16 buf_size;\n\tu16 timeout;\n\tu8 tid;\n\tu8 auto_seq:1,\n\t   removed:1,\n\t   started:1;\n};\n\n \nstruct sta_ampdu_mlme {\n\tstruct mutex mtx;\n\t \n\tstruct tid_ampdu_rx __rcu *tid_rx[IEEE80211_NUM_TIDS];\n\tu8 tid_rx_token[IEEE80211_NUM_TIDS];\n\tunsigned long tid_rx_timer_expired[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];\n\tunsigned long tid_rx_stop_requested[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];\n\tunsigned long tid_rx_manage_offl[BITS_TO_LONGS(2 * IEEE80211_NUM_TIDS)];\n\tunsigned long agg_session_valid[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];\n\tunsigned long unexpected_agg[BITS_TO_LONGS(IEEE80211_NUM_TIDS)];\n\t \n\tstruct work_struct work;\n\tstruct tid_ampdu_tx __rcu *tid_tx[IEEE80211_NUM_TIDS];\n\tstruct tid_ampdu_tx *tid_start_tx[IEEE80211_NUM_TIDS];\n\tunsigned long last_addba_req_time[IEEE80211_NUM_TIDS];\n\tu8 addba_req_num[IEEE80211_NUM_TIDS];\n\tu8 dialog_token_allocator;\n};\n\n\n \n#define IEEE80211_TID_UNRESERVED\t0xff\n\n#define IEEE80211_FAST_XMIT_MAX_IV\t18\n\n \nstruct ieee80211_fast_tx {\n\tstruct ieee80211_key *key;\n\tu8 hdr_len;\n\tu8 sa_offs, da_offs, pn_offs;\n\tu8 band;\n\tu8 hdr[30 + 2 + IEEE80211_FAST_XMIT_MAX_IV +\n\t       sizeof(rfc1042_header)] __aligned(2);\n\n\tstruct rcu_head rcu_head;\n};\n\n \nstruct ieee80211_fast_rx {\n\tstruct net_device *dev;\n\tenum nl80211_iftype vif_type;\n\tu8 vif_addr[ETH_ALEN] __aligned(2);\n\tu8 rfc1042_hdr[6] __aligned(2);\n\t__be16 control_port_protocol;\n\t__le16 expected_ds_bits;\n\tu8 icv_len;\n\tu8 key:1,\n\t   internal_forward:1,\n\t   uses_rss:1;\n\tu8 da_offs, sa_offs;\n\n\tstruct rcu_head rcu_head;\n};\n\n \nDECLARE_EWMA(mesh_fail_avg, 20, 8)\nDECLARE_EWMA(mesh_tx_rate_avg, 8, 16)\n\n \nstruct mesh_sta {\n\tstruct timer_list plink_timer;\n\tstruct sta_info *plink_sta;\n\n\ts64 t_offset;\n\ts64 t_offset_setpoint;\n\n\tspinlock_t plink_lock;\n\tu16 llid;\n\tu16 plid;\n\tu16 aid;\n\tu16 reason;\n\tu8 plink_retries;\n\n\tbool processed_beacon;\n\tbool connected_to_gate;\n\tbool connected_to_as;\n\n\tenum nl80211_plink_state plink_state;\n\tu32 plink_timeout;\n\n\t \n\tenum nl80211_mesh_power_mode local_pm;\n\tenum nl80211_mesh_power_mode peer_pm;\n\tenum nl80211_mesh_power_mode nonpeer_pm;\n\n\t \n\tstruct ewma_mesh_fail_avg fail_avg;\n\t \n\tstruct ewma_mesh_tx_rate_avg tx_rate_avg;\n};\n\nDECLARE_EWMA(signal, 10, 8)\n\nstruct ieee80211_sta_rx_stats {\n\tunsigned long packets;\n\tunsigned long last_rx;\n\tunsigned long num_duplicates;\n\tunsigned long fragments;\n\tunsigned long dropped;\n\tint last_signal;\n\tu8 chains;\n\ts8 chain_signal_last[IEEE80211_MAX_CHAINS];\n\tu32 last_rate;\n\tstruct u64_stats_sync syncp;\n\tu64 bytes;\n\tu64 msdu[IEEE80211_NUM_TIDS + 1];\n};\n\n \n#define IEEE80211_FRAGMENT_MAX 4\n\nstruct ieee80211_fragment_entry {\n\tstruct sk_buff_head skb_list;\n\tunsigned long first_frag_time;\n\tu16 seq;\n\tu16 extra_len;\n\tu16 last_frag;\n\tu8 rx_queue;\n\tu8 check_sequential_pn:1,  \n\t   is_protected:1;\n\tu8 last_pn[6];  \n\tunsigned int key_color;\n};\n\nstruct ieee80211_fragment_cache {\n\tstruct ieee80211_fragment_entry\tentries[IEEE80211_FRAGMENT_MAX];\n\tunsigned int next;\n};\n\n \n#define STA_SLOW_THRESHOLD 6000  \n\n \nstruct link_sta_info {\n\tu8 addr[ETH_ALEN];\n\tu8 link_id;\n\n\tstruct rhlist_head link_hash_node;\n\n\tstruct sta_info *sta;\n\tstruct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS +\n\t\t\t\t\tNUM_DEFAULT_MGMT_KEYS +\n\t\t\t\t\tNUM_DEFAULT_BEACON_KEYS];\n\tstruct ieee80211_sta_rx_stats __percpu *pcpu_rx_stats;\n\n\t \n\tstruct ieee80211_sta_rx_stats rx_stats;\n\tstruct {\n\t\tstruct ewma_signal signal;\n\t\tstruct ewma_signal chain_signal[IEEE80211_MAX_CHAINS];\n\t} rx_stats_avg;\n\n\t \n\tstruct {\n\t\tunsigned long filtered;\n\t\tunsigned long retry_failed, retry_count;\n\t\tunsigned int lost_packets;\n\t\tunsigned long last_pkt_time;\n\t\tu64 msdu_retries[IEEE80211_NUM_TIDS + 1];\n\t\tu64 msdu_failed[IEEE80211_NUM_TIDS + 1];\n\t\tunsigned long last_ack;\n\t\ts8 last_ack_signal;\n\t\tbool ack_signal_filled;\n\t\tstruct ewma_avg_signal avg_ack_signal;\n\t} status_stats;\n\n\t \n\tstruct {\n\t\tu64 packets[IEEE80211_NUM_ACS];\n\t\tu64 bytes[IEEE80211_NUM_ACS];\n\t\tstruct ieee80211_tx_rate last_rate;\n\t\tstruct rate_info last_rate_info;\n\t\tu64 msdu[IEEE80211_NUM_TIDS + 1];\n\t} tx_stats;\n\n\tenum ieee80211_sta_rx_bandwidth cur_max_bandwidth;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct dentry *debugfs_dir;\n#endif\n\n\tstruct ieee80211_link_sta *pub;\n};\n\n \nstruct sta_info {\n\t \n\tstruct list_head list, free_list;\n\tstruct rcu_head rcu_head;\n\tstruct rhlist_head hash_node;\n\tu8 addr[ETH_ALEN];\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_key __rcu *ptk[NUM_DEFAULT_KEYS];\n\tu8 ptk_idx;\n\tstruct rate_control_ref *rate_ctrl;\n\tvoid *rate_ctrl_priv;\n\tspinlock_t rate_ctrl_lock;\n\tspinlock_t lock;\n\n\tstruct ieee80211_fast_tx __rcu *fast_tx;\n\tstruct ieee80211_fast_rx __rcu *fast_rx;\n\n#ifdef CONFIG_MAC80211_MESH\n\tstruct mesh_sta *mesh;\n#endif\n\n\tstruct work_struct drv_deliver_wk;\n\n\tu16 listen_interval;\n\n\tbool dead;\n\tbool removed;\n\n\tbool uploaded;\n\n\tenum ieee80211_sta_state sta_state;\n\n\t \n\tunsigned long _flags;\n\n\t \n\tspinlock_t ps_lock;\n\tstruct sk_buff_head ps_tx_buf[IEEE80211_NUM_ACS];\n\tstruct sk_buff_head tx_filtered[IEEE80211_NUM_ACS];\n\tunsigned long driver_buffered_tids;\n\tunsigned long txq_buffered_tids;\n\n\tu64 assoc_at;\n\tlong last_connected;\n\n\t \n\t__le16 last_seq_ctrl[IEEE80211_NUM_TIDS + 1];\n\n\tu16 tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1];\n\n\tstruct airtime_info airtime[IEEE80211_NUM_ACS];\n\tu16 airtime_weight;\n\n\t \n\tstruct sta_ampdu_mlme ampdu_mlme;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct dentry *debugfs_dir;\n#endif\n\n\tstruct codel_params cparams;\n\n\tu8 reserved_tid;\n\ts8 amsdu_mesh_control;\n\n\tstruct cfg80211_chan_def tdls_chandef;\n\n\tstruct ieee80211_fragment_cache frags;\n\n\tstruct ieee80211_sta_aggregates cur;\n\tstruct link_sta_info deflink;\n\tstruct link_sta_info __rcu *link[IEEE80211_MLD_MAX_NUM_LINKS];\n\n\t \n\tstruct ieee80211_sta sta;\n};\n\nstatic inline enum nl80211_plink_state sta_plink_state(struct sta_info *sta)\n{\n#ifdef CONFIG_MAC80211_MESH\n\treturn sta->mesh->plink_state;\n#endif\n\treturn NL80211_PLINK_LISTEN;\n}\n\nstatic inline void set_sta_flag(struct sta_info *sta,\n\t\t\t\tenum ieee80211_sta_info_flags flag)\n{\n\tWARN_ON(flag == WLAN_STA_AUTH ||\n\t\tflag == WLAN_STA_ASSOC ||\n\t\tflag == WLAN_STA_AUTHORIZED);\n\tset_bit(flag, &sta->_flags);\n}\n\nstatic inline void clear_sta_flag(struct sta_info *sta,\n\t\t\t\t  enum ieee80211_sta_info_flags flag)\n{\n\tWARN_ON(flag == WLAN_STA_AUTH ||\n\t\tflag == WLAN_STA_ASSOC ||\n\t\tflag == WLAN_STA_AUTHORIZED);\n\tclear_bit(flag, &sta->_flags);\n}\n\nstatic inline int test_sta_flag(struct sta_info *sta,\n\t\t\t\tenum ieee80211_sta_info_flags flag)\n{\n\treturn test_bit(flag, &sta->_flags);\n}\n\nstatic inline int test_and_clear_sta_flag(struct sta_info *sta,\n\t\t\t\t\t  enum ieee80211_sta_info_flags flag)\n{\n\tWARN_ON(flag == WLAN_STA_AUTH ||\n\t\tflag == WLAN_STA_ASSOC ||\n\t\tflag == WLAN_STA_AUTHORIZED);\n\treturn test_and_clear_bit(flag, &sta->_flags);\n}\n\nstatic inline int test_and_set_sta_flag(struct sta_info *sta,\n\t\t\t\t\tenum ieee80211_sta_info_flags flag)\n{\n\tWARN_ON(flag == WLAN_STA_AUTH ||\n\t\tflag == WLAN_STA_ASSOC ||\n\t\tflag == WLAN_STA_AUTHORIZED);\n\treturn test_and_set_bit(flag, &sta->_flags);\n}\n\nint sta_info_move_state(struct sta_info *sta,\n\t\t\tenum ieee80211_sta_state new_state);\n\nstatic inline void sta_info_pre_move_state(struct sta_info *sta,\n\t\t\t\t\t   enum ieee80211_sta_state new_state)\n{\n\tint ret;\n\n\tWARN_ON_ONCE(test_sta_flag(sta, WLAN_STA_INSERTED));\n\n\tret = sta_info_move_state(sta, new_state);\n\tWARN_ON_ONCE(ret);\n}\n\n\nvoid ieee80211_assign_tid_tx(struct sta_info *sta, int tid,\n\t\t\t     struct tid_ampdu_tx *tid_tx);\n\nstatic inline struct tid_ampdu_tx *\nrcu_dereference_protected_tid_tx(struct sta_info *sta, int tid)\n{\n\treturn rcu_dereference_protected(sta->ampdu_mlme.tid_tx[tid],\n\t\t\t\t\t lockdep_is_held(&sta->lock) ||\n\t\t\t\t\t lockdep_is_held(&sta->ampdu_mlme.mtx));\n}\n\n \n#define STA_MAX_TX_BUFFER\t64\n\n \n#define STA_TX_BUFFER_EXPIRE (10 * HZ)\n\n \n#define STA_INFO_CLEANUP_INTERVAL (10 * HZ)\n\nstruct rhlist_head *sta_info_hash_lookup(struct ieee80211_local *local,\n\t\t\t\t\t const u8 *addr);\n\n \nstruct sta_info *sta_info_get(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *addr);\n\nstruct sta_info *sta_info_get_bss(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  const u8 *addr);\n\n \nstruct sta_info *sta_info_get_by_addrs(struct ieee80211_local *local,\n\t\t\t\t       const u8 *sta_addr, const u8 *vif_addr);\n\n#define for_each_sta_info(local, _addr, _sta, _tmp)\t\t\t\\\n\trhl_for_each_entry_rcu(_sta, _tmp,\t\t\t\t\\\n\t\t\t       sta_info_hash_lookup(local, _addr), hash_node)\n\nstruct rhlist_head *link_sta_info_hash_lookup(struct ieee80211_local *local,\n\t\t\t\t\t      const u8 *addr);\n\n#define for_each_link_sta_info(local, _addr, _sta, _tmp)\t\t\\\n\trhl_for_each_entry_rcu(_sta, _tmp,\t\t\t\t\\\n\t\t\t       link_sta_info_hash_lookup(local, _addr),\t\\\n\t\t\t       link_hash_node)\n\nstruct link_sta_info *\nlink_sta_info_get_bss(struct ieee80211_sub_if_data *sdata, const u8 *addr);\n\n \nstruct sta_info *sta_info_get_by_idx(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     int idx);\n \nstruct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *addr, gfp_t gfp);\nstruct sta_info *sta_info_alloc_with_link(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  const u8 *mld_addr,\n\t\t\t\t\t  unsigned int link_id,\n\t\t\t\t\t  const u8 *link_addr,\n\t\t\t\t\t  gfp_t gfp);\n\nvoid sta_info_free(struct ieee80211_local *local, struct sta_info *sta);\n\n \nint sta_info_insert(struct sta_info *sta);\nint sta_info_insert_rcu(struct sta_info *sta) __acquires(RCU);\n\nint __must_check __sta_info_destroy(struct sta_info *sta);\nint sta_info_destroy_addr(struct ieee80211_sub_if_data *sdata,\n\t\t\t  const u8 *addr);\nint sta_info_destroy_addr_bss(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *addr);\n\nvoid sta_info_recalc_tim(struct sta_info *sta);\n\nint sta_info_init(struct ieee80211_local *local);\nvoid sta_info_stop(struct ieee80211_local *local);\n\n \nint __sta_info_flush(struct ieee80211_sub_if_data *sdata, bool vlans);\n\n \nstatic inline int sta_info_flush(struct ieee80211_sub_if_data *sdata)\n{\n\treturn __sta_info_flush(sdata, false);\n}\n\nvoid sta_set_rate_info_tx(struct sta_info *sta,\n\t\t\t  const struct ieee80211_tx_rate *rate,\n\t\t\t  struct rate_info *rinfo);\nvoid sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo,\n\t\t   bool tidstats);\n\nu32 sta_get_expected_throughput(struct sta_info *sta);\n\nvoid ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,\n\t\t\t  unsigned long exp_time);\n\nint ieee80211_sta_allocate_link(struct sta_info *sta, unsigned int link_id);\nvoid ieee80211_sta_free_link(struct sta_info *sta, unsigned int link_id);\nint ieee80211_sta_activate_link(struct sta_info *sta, unsigned int link_id);\nvoid ieee80211_sta_remove_link(struct sta_info *sta, unsigned int link_id);\n\nvoid ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta);\nvoid ieee80211_sta_ps_deliver_poll_response(struct sta_info *sta);\nvoid ieee80211_sta_ps_deliver_uapsd(struct sta_info *sta);\n\nunsigned long ieee80211_sta_last_active(struct sta_info *sta);\n\nvoid ieee80211_sta_set_max_amsdu_subframes(struct sta_info *sta,\n\t\t\t\t\t   const u8 *ext_capab,\n\t\t\t\t\t   unsigned int ext_capab_len);\n\nvoid __ieee80211_sta_recalc_aggregates(struct sta_info *sta, u16 active_links);\n\nenum sta_stats_type {\n\tSTA_STATS_RATE_TYPE_INVALID = 0,\n\tSTA_STATS_RATE_TYPE_LEGACY,\n\tSTA_STATS_RATE_TYPE_HT,\n\tSTA_STATS_RATE_TYPE_VHT,\n\tSTA_STATS_RATE_TYPE_HE,\n\tSTA_STATS_RATE_TYPE_S1G,\n\tSTA_STATS_RATE_TYPE_EHT,\n};\n\n#define STA_STATS_FIELD_HT_MCS\t\tGENMASK( 7,  0)\n#define STA_STATS_FIELD_LEGACY_IDX\tGENMASK( 3,  0)\n#define STA_STATS_FIELD_LEGACY_BAND\tGENMASK( 7,  4)\n#define STA_STATS_FIELD_VHT_MCS\t\tGENMASK( 3,  0)\n#define STA_STATS_FIELD_VHT_NSS\t\tGENMASK( 7,  4)\n#define STA_STATS_FIELD_HE_MCS\t\tGENMASK( 3,  0)\n#define STA_STATS_FIELD_HE_NSS\t\tGENMASK( 7,  4)\n#define STA_STATS_FIELD_EHT_MCS\t\tGENMASK( 3,  0)\n#define STA_STATS_FIELD_EHT_NSS\t\tGENMASK( 7,  4)\n#define STA_STATS_FIELD_BW\t\tGENMASK(12,  8)\n#define STA_STATS_FIELD_SGI\t\tGENMASK(13, 13)\n#define STA_STATS_FIELD_TYPE\t\tGENMASK(16, 14)\n#define STA_STATS_FIELD_HE_RU\t\tGENMASK(19, 17)\n#define STA_STATS_FIELD_HE_GI\t\tGENMASK(21, 20)\n#define STA_STATS_FIELD_HE_DCM\t\tGENMASK(22, 22)\n#define STA_STATS_FIELD_EHT_RU\t\tGENMASK(20, 17)\n#define STA_STATS_FIELD_EHT_GI\t\tGENMASK(22, 21)\n\n#define STA_STATS_FIELD(_n, _v)\t\tFIELD_PREP(STA_STATS_FIELD_ ## _n, _v)\n#define STA_STATS_GET(_n, _v)\t\tFIELD_GET(STA_STATS_FIELD_ ## _n, _v)\n\n#define STA_STATS_RATE_INVALID\t\t0\n\nstatic inline u32 sta_stats_encode_rate(struct ieee80211_rx_status *s)\n{\n\tu32 r;\n\n\tr = STA_STATS_FIELD(BW, s->bw);\n\n\tif (s->enc_flags & RX_ENC_FLAG_SHORT_GI)\n\t\tr |= STA_STATS_FIELD(SGI, 1);\n\n\tswitch (s->encoding) {\n\tcase RX_ENC_VHT:\n\t\tr |= STA_STATS_FIELD(TYPE, STA_STATS_RATE_TYPE_VHT);\n\t\tr |= STA_STATS_FIELD(VHT_NSS, s->nss);\n\t\tr |= STA_STATS_FIELD(VHT_MCS, s->rate_idx);\n\t\tbreak;\n\tcase RX_ENC_HT:\n\t\tr |= STA_STATS_FIELD(TYPE, STA_STATS_RATE_TYPE_HT);\n\t\tr |= STA_STATS_FIELD(HT_MCS, s->rate_idx);\n\t\tbreak;\n\tcase RX_ENC_LEGACY:\n\t\tr |= STA_STATS_FIELD(TYPE, STA_STATS_RATE_TYPE_LEGACY);\n\t\tr |= STA_STATS_FIELD(LEGACY_BAND, s->band);\n\t\tr |= STA_STATS_FIELD(LEGACY_IDX, s->rate_idx);\n\t\tbreak;\n\tcase RX_ENC_HE:\n\t\tr |= STA_STATS_FIELD(TYPE, STA_STATS_RATE_TYPE_HE);\n\t\tr |= STA_STATS_FIELD(HE_NSS, s->nss);\n\t\tr |= STA_STATS_FIELD(HE_MCS, s->rate_idx);\n\t\tr |= STA_STATS_FIELD(HE_GI, s->he_gi);\n\t\tr |= STA_STATS_FIELD(HE_RU, s->he_ru);\n\t\tr |= STA_STATS_FIELD(HE_DCM, s->he_dcm);\n\t\tbreak;\n\tcase RX_ENC_EHT:\n\t\tr |= STA_STATS_FIELD(TYPE, STA_STATS_RATE_TYPE_EHT);\n\t\tr |= STA_STATS_FIELD(EHT_NSS, s->nss);\n\t\tr |= STA_STATS_FIELD(EHT_MCS, s->rate_idx);\n\t\tr |= STA_STATS_FIELD(EHT_GI, s->eht.gi);\n\t\tr |= STA_STATS_FIELD(EHT_RU, s->eht.ru);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn STA_STATS_RATE_INVALID;\n\t}\n\n\treturn r;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}