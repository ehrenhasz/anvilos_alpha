{
  "module_name": "tdls.c",
  "hash_id": "b5101ee1dcc10d35f4681b6b29ae817a232dee69211c8de6077a83afee7c6a07",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/tdls.c",
  "human_readable_source": "\n \n\n#include <linux/ieee80211.h>\n#include <linux/log2.h>\n#include <net/cfg80211.h>\n#include <linux/rtnetlink.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"rate.h\"\n#include \"wme.h\"\n\n \n#define TDLS_PEER_SETUP_TIMEOUT\t(15 * HZ)\n\nvoid ieee80211_tdls_peer_del_work(struct work_struct *wk)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_local *local;\n\n\tsdata = container_of(wk, struct ieee80211_sub_if_data,\n\t\t\t     u.mgd.tdls_peer_del_work.work);\n\tlocal = sdata->local;\n\n\tmutex_lock(&local->mtx);\n\tif (!is_zero_ether_addr(sdata->u.mgd.tdls_peer)) {\n\t\ttdls_dbg(sdata, \"TDLS del peer %pM\\n\", sdata->u.mgd.tdls_peer);\n\t\tsta_info_destroy_addr(sdata, sdata->u.mgd.tdls_peer);\n\t\teth_zero_addr(sdata->u.mgd.tdls_peer);\n\t}\n\tmutex_unlock(&local->mtx);\n}\n\nstatic void ieee80211_tdls_add_ext_capab(struct ieee80211_link_data *link,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tbool chan_switch = local->hw.wiphy->features &\n\t\t\t   NL80211_FEATURE_TDLS_CHANNEL_SWITCH;\n\tbool wider_band = ieee80211_hw_check(&local->hw, TDLS_WIDER_BW) &&\n\t\t\t  !ifmgd->tdls_wider_bw_prohibited;\n\tbool buffer_sta = ieee80211_hw_check(&local->hw,\n\t\t\t\t\t     SUPPORTS_TDLS_BUFFER_STA);\n\tstruct ieee80211_supported_band *sband = ieee80211_get_link_sband(link);\n\tbool vht = sband && sband->vht_cap.vht_supported;\n\tu8 *pos = skb_put(skb, 10);\n\n\t*pos++ = WLAN_EID_EXT_CAPABILITY;\n\t*pos++ = 8;  \n\t*pos++ = 0x0;\n\t*pos++ = 0x0;\n\t*pos++ = 0x0;\n\t*pos++ = (chan_switch ? WLAN_EXT_CAPA4_TDLS_CHAN_SWITCH : 0) |\n\t\t (buffer_sta ? WLAN_EXT_CAPA4_TDLS_BUFFER_STA : 0);\n\t*pos++ = WLAN_EXT_CAPA5_TDLS_ENABLED;\n\t*pos++ = 0;\n\t*pos++ = 0;\n\t*pos++ = (vht && wider_band) ? WLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED : 0;\n}\n\nstatic u8\nieee80211_tdls_add_subband(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct sk_buff *skb, u16 start, u16 end,\n\t\t\t   u16 spacing)\n{\n\tu8 subband_cnt = 0, ch_cnt = 0;\n\tstruct ieee80211_channel *ch;\n\tstruct cfg80211_chan_def chandef;\n\tint i, subband_start;\n\tstruct wiphy *wiphy = sdata->local->hw.wiphy;\n\n\tfor (i = start; i <= end; i += spacing) {\n\t\tif (!ch_cnt)\n\t\t\tsubband_start = i;\n\n\t\tch = ieee80211_get_channel(sdata->local->hw.wiphy, i);\n\t\tif (ch) {\n\t\t\t \n\t\t\tcfg80211_chandef_create(&chandef, ch,\n\t\t\t\t\t\tNL80211_CHAN_NO_HT);\n\t\t\tif (cfg80211_reg_can_beacon_relax(wiphy, &chandef,\n\t\t\t\t\t\t\t  sdata->wdev.iftype)) {\n\t\t\t\tch_cnt++;\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (ch_cnt) {\n\t\t\tu8 *pos = skb_put(skb, 2);\n\t\t\t*pos++ = ieee80211_frequency_to_channel(subband_start);\n\t\t\t*pos++ = ch_cnt;\n\n\t\t\tsubband_cnt++;\n\t\t\tch_cnt = 0;\n\t\t}\n\t}\n\n\t \n\tif (ch_cnt) {\n\t\tu8 *pos = skb_put(skb, 2);\n\t\t*pos++ = ieee80211_frequency_to_channel(subband_start);\n\t\t*pos++ = ch_cnt;\n\n\t\tsubband_cnt++;\n\t}\n\n\treturn subband_cnt;\n}\n\nstatic void\nieee80211_tdls_add_supp_channels(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb)\n{\n\t \n\tu8 subband_cnt;\n\tu8 *pos = skb_put(skb, 2);\n\n\t*pos++ = WLAN_EID_SUPPORTED_CHANNELS;\n\n\t \n\n\t \n\tsubband_cnt = ieee80211_tdls_add_subband(sdata, skb, 2412, 2472, 5);\n\n\t \n\tsubband_cnt += ieee80211_tdls_add_subband(sdata, skb, 5000, 5825, 20);\n\n\t \n\t*pos = 2 * subband_cnt;\n}\n\nstatic void ieee80211_tdls_add_oper_classes(struct ieee80211_link_data *link,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tu8 *pos;\n\tu8 op_class;\n\n\tif (!ieee80211_chandef_to_operating_class(&link->conf->chandef,\n\t\t\t\t\t\t  &op_class))\n\t\treturn;\n\n\tpos = skb_put(skb, 4);\n\t*pos++ = WLAN_EID_SUPPORTED_REGULATORY_CLASSES;\n\t*pos++ = 2;  \n\n\t*pos++ = op_class;\n\t*pos++ = op_class;  \n}\n\nstatic void ieee80211_tdls_add_bss_coex_ie(struct sk_buff *skb)\n{\n\tu8 *pos = skb_put(skb, 3);\n\n\t*pos++ = WLAN_EID_BSS_COEX_2040;\n\t*pos++ = 1;  \n\n\t*pos++ = WLAN_BSS_COEX_INFORMATION_REQUEST;\n}\n\nstatic u16 ieee80211_get_tdls_sta_capab(struct ieee80211_link_data *link,\n\t\t\t\t\tu16 status_code)\n{\n\tstruct ieee80211_supported_band *sband;\n\n\t \n\tif (status_code != 0)\n\t\treturn 0;\n\n\tsband = ieee80211_get_link_sband(link);\n\n\tif (sband && sband->band == NL80211_BAND_2GHZ) {\n\t\treturn WLAN_CAPABILITY_SHORT_SLOT_TIME |\n\t\t       WLAN_CAPABILITY_SHORT_PREAMBLE;\n\t}\n\n\treturn 0;\n}\n\nstatic void ieee80211_tdls_add_link_ie(struct ieee80211_link_data *link,\n\t\t\t\t       struct sk_buff *skb, const u8 *peer,\n\t\t\t\t       bool initiator)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_tdls_lnkie *lnkid;\n\tconst u8 *init_addr, *rsp_addr;\n\n\tif (initiator) {\n\t\tinit_addr = sdata->vif.addr;\n\t\trsp_addr = peer;\n\t} else {\n\t\tinit_addr = peer;\n\t\trsp_addr = sdata->vif.addr;\n\t}\n\n\tlnkid = skb_put(skb, sizeof(struct ieee80211_tdls_lnkie));\n\n\tlnkid->ie_type = WLAN_EID_LINK_ID;\n\tlnkid->ie_len = sizeof(struct ieee80211_tdls_lnkie) - 2;\n\n\tmemcpy(lnkid->bssid, link->u.mgd.bssid, ETH_ALEN);\n\tmemcpy(lnkid->init_sta, init_addr, ETH_ALEN);\n\tmemcpy(lnkid->resp_sta, rsp_addr, ETH_ALEN);\n}\n\nstatic void\nieee80211_tdls_add_aid(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb)\n{\n\tu8 *pos = skb_put(skb, 4);\n\n\t*pos++ = WLAN_EID_AID;\n\t*pos++ = 2;  \n\tput_unaligned_le16(sdata->vif.cfg.aid, pos);\n}\n\n \nstatic enum ieee80211_ac_numbers ieee80211_ac_from_wmm(int ac)\n{\n\tswitch (ac) {\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tfallthrough;\n\tcase 0:\n\t\treturn IEEE80211_AC_BE;\n\tcase 1:\n\t\treturn IEEE80211_AC_BK;\n\tcase 2:\n\t\treturn IEEE80211_AC_VI;\n\tcase 3:\n\t\treturn IEEE80211_AC_VO;\n\t}\n}\n\nstatic u8 ieee80211_wmm_aci_aifsn(int aifsn, bool acm, int aci)\n{\n\tu8 ret;\n\n\tret = aifsn & 0x0f;\n\tif (acm)\n\t\tret |= 0x10;\n\tret |= (aci << 5) & 0x60;\n\treturn ret;\n}\n\nstatic u8 ieee80211_wmm_ecw(u16 cw_min, u16 cw_max)\n{\n\treturn ((ilog2(cw_min + 1) << 0x0) & 0x0f) |\n\t       ((ilog2(cw_max + 1) << 0x4) & 0xf0);\n}\n\nstatic void ieee80211_tdls_add_wmm_param_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct ieee80211_wmm_param_ie *wmm;\n\tstruct ieee80211_tx_queue_params *txq;\n\tint i;\n\n\twmm = skb_put_zero(skb, sizeof(*wmm));\n\n\twmm->element_id = WLAN_EID_VENDOR_SPECIFIC;\n\twmm->len = sizeof(*wmm) - 2;\n\n\twmm->oui[0] = 0x00;  \n\twmm->oui[1] = 0x50;\n\twmm->oui[2] = 0xf2;\n\twmm->oui_type = 2;  \n\twmm->oui_subtype = 1;  \n\twmm->version = 1;  \n\twmm->qos_info = 0;  \n\n\t \n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\ttxq = &sdata->deflink.tx_conf[ieee80211_ac_from_wmm(i)];\n\t\twmm->ac[i].aci_aifsn = ieee80211_wmm_aci_aifsn(txq->aifs,\n\t\t\t\t\t\t\t       txq->acm, i);\n\t\twmm->ac[i].cw = ieee80211_wmm_ecw(txq->cw_min, txq->cw_max);\n\t\twmm->ac[i].txop_limit = cpu_to_le16(txq->txop);\n\t}\n}\n\nstatic void\nieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct sta_info *sta)\n{\n\t \n\tu16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n\tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n\tenum nl80211_chan_width max_width =\n\t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n\tint i;\n\n\t \n\tif (max_width == NL80211_CHAN_WIDTH_5 ||\n\t    max_width == NL80211_CHAN_WIDTH_10)\n\t\treturn;\n\n\tif (max_width > NL80211_CHAN_WIDTH_80)\n\t\tmax_width = NL80211_CHAN_WIDTH_80;\n\n\tif (uc.width >= max_width)\n\t\treturn;\n\t \n\tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n\t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n\t\t\tuc.center_freq1 = centers_80mhz[i];\n\t\t\tuc.center_freq2 = 0;\n\t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n\t\t\tbreak;\n\t\t}\n\n\tif (!uc.center_freq1)\n\t\treturn;\n\n\t \n\twhile (uc.width > max_width ||\n\t       (uc.width > sta->tdls_chandef.width &&\n\t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n\t\t\t\t\t       sdata->wdev.iftype)))\n\t\tieee80211_chandef_downgrade(&uc);\n\n\tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n\t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n\t\t\t sta->tdls_chandef.width, uc.width);\n\n\t\t \n\t\tsta->tdls_chandef = uc;\n\t}\n}\n\nstatic void\nieee80211_tdls_add_setup_start_ies(struct ieee80211_link_data *link,\n\t\t\t\t   struct sk_buff *skb, const u8 *peer,\n\t\t\t\t   u8 action_code, bool initiator,\n\t\t\t\t   const u8 *extra_ies, size_t extra_ies_len)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tconst struct ieee80211_sta_eht_cap *eht_cap;\n\tstruct sta_info *sta = NULL;\n\tsize_t offset = 0, noffset;\n\tu8 *pos;\n\n\tsband = ieee80211_get_link_sband(link);\n\tif (WARN_ON_ONCE(!sband))\n\t\treturn;\n\n\tieee80211_add_srates_ie(sdata, skb, false, sband->band);\n\tieee80211_add_ext_srates_ie(sdata, skb, false, sband->band);\n\tieee80211_tdls_add_supp_channels(sdata, skb);\n\n\t \n\tif (extra_ies_len) {\n\t\tstatic const u8 before_ext_cap[] = {\n\t\t\tWLAN_EID_SUPP_RATES,\n\t\t\tWLAN_EID_COUNTRY,\n\t\t\tWLAN_EID_EXT_SUPP_RATES,\n\t\t\tWLAN_EID_SUPPORTED_CHANNELS,\n\t\t\tWLAN_EID_RSN,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_ext_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_ext_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\tieee80211_tdls_add_ext_capab(link, skb);\n\n\t \n\tif (local->hw.queues >= IEEE80211_NUM_ACS &&\n\t    action_code != WLAN_PUB_ACTION_TDLS_DISCOVER_RES)\n\t\tieee80211_add_wmm_info_ie(skb_put(skb, 9), 0);  \n\n\t \n\tif (extra_ies_len) {\n\t\tstatic const u8 before_ht_cap[] = {\n\t\t\tWLAN_EID_SUPP_RATES,\n\t\t\tWLAN_EID_COUNTRY,\n\t\t\tWLAN_EID_EXT_SUPP_RATES,\n\t\t\tWLAN_EID_SUPPORTED_CHANNELS,\n\t\t\tWLAN_EID_RSN,\n\t\t\tWLAN_EID_EXT_CAPABILITY,\n\t\t\tWLAN_EID_QOS_CAPA,\n\t\t\tWLAN_EID_FAST_BSS_TRANSITION,\n\t\t\tWLAN_EID_TIMEOUT_INTERVAL,\n\t\t\tWLAN_EID_SUPPORTED_REGULATORY_CLASSES,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_ht_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_ht_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t \n\tif (action_code == WLAN_TDLS_SETUP_RESPONSE) {\n\t\tsta = sta_info_get(sdata, peer);\n\t\tif (WARN_ON_ONCE(!sta))\n\t\t\treturn;\n\n\t\tsta->tdls_chandef = link->conf->chandef;\n\t}\n\n\tieee80211_tdls_add_oper_classes(link, skb);\n\n\t \n\tmemcpy(&ht_cap, &sband->ht_cap, sizeof(ht_cap));\n\n\tif ((action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t     action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES) &&\n\t    ht_cap.ht_supported) {\n\t\tieee80211_apply_htcap_overrides(sdata, &ht_cap);\n\n\t\t \n\t\tht_cap.cap |= WLAN_HT_CAP_SM_PS_DISABLED\n\t\t\t\t<< IEEE80211_HT_CAP_SM_PS_SHIFT;\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\n\t\tieee80211_ie_build_ht_cap(pos, &ht_cap, ht_cap.cap);\n\t} else if (action_code == WLAN_TDLS_SETUP_RESPONSE &&\n\t\t   ht_cap.ht_supported && sta->sta.deflink.ht_cap.ht_supported) {\n\t\t \n\t\tmemcpy(&ht_cap, &sta->sta.deflink.ht_cap, sizeof(ht_cap));\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\n\t\tieee80211_ie_build_ht_cap(pos, &ht_cap, ht_cap.cap);\n\t}\n\n\tif (ht_cap.ht_supported &&\n\t    (ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40))\n\t\tieee80211_tdls_add_bss_coex_ie(skb);\n\n\tieee80211_tdls_add_link_ie(link, skb, peer, initiator);\n\n\t \n\tif (extra_ies_len) {\n\t\tstatic const u8 before_vht_cap[] = {\n\t\t\tWLAN_EID_SUPP_RATES,\n\t\t\tWLAN_EID_COUNTRY,\n\t\t\tWLAN_EID_EXT_SUPP_RATES,\n\t\t\tWLAN_EID_SUPPORTED_CHANNELS,\n\t\t\tWLAN_EID_RSN,\n\t\t\tWLAN_EID_EXT_CAPABILITY,\n\t\t\tWLAN_EID_QOS_CAPA,\n\t\t\tWLAN_EID_FAST_BSS_TRANSITION,\n\t\t\tWLAN_EID_TIMEOUT_INTERVAL,\n\t\t\tWLAN_EID_SUPPORTED_REGULATORY_CLASSES,\n\t\t\tWLAN_EID_MULTI_BAND,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_vht_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_vht_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t \n\tmemcpy(&vht_cap, &sband->vht_cap, sizeof(vht_cap));\n\the_cap = ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);\n\teht_cap = ieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif);\n\tif ((vht_cap.vht_supported || he_cap || eht_cap) &&\n\t    (action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t     action_code == WLAN_TDLS_SETUP_RESPONSE))\n\t\tieee80211_tdls_add_aid(sdata, skb);\n\n\t \n\tif ((action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t     action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES) &&\n\t    vht_cap.vht_supported) {\n\t\tieee80211_apply_vhtcap_overrides(sdata, &vht_cap);\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_vht_cap) + 2);\n\t\tieee80211_ie_build_vht_cap(pos, &vht_cap, vht_cap.cap);\n\t} else if (action_code == WLAN_TDLS_SETUP_RESPONSE &&\n\t\t   vht_cap.vht_supported && sta->sta.deflink.vht_cap.vht_supported) {\n\t\t \n\t\tmemcpy(&vht_cap, &sta->sta.deflink.vht_cap, sizeof(vht_cap));\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_vht_cap) + 2);\n\t\tieee80211_ie_build_vht_cap(pos, &vht_cap, vht_cap.cap);\n\n\t\t \n\t\tif (test_sta_flag(sta, WLAN_STA_TDLS_WIDER_BW))\n\t\t\tieee80211_tdls_chandef_vht_upgrade(sdata, sta);\n\t}\n\n\t \n\tif (extra_ies_len) {\n\t\tstatic const u8 before_he_cap[] = {\n\t\t\tWLAN_EID_EXTENSION,\n\t\t\tWLAN_EID_EXT_FILS_REQ_PARAMS,\n\t\t\tWLAN_EID_AP_CSN,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_he_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_he_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t \n\tif (he_cap &&\n\t    (action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t     action_code == WLAN_TDLS_SETUP_RESPONSE ||\n\t     action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES)) {\n\t\t__le16 he_6ghz_capa;\n\t\tu8 cap_size;\n\n\t\tcap_size =\n\t\t\t2 + 1 + sizeof(he_cap->he_cap_elem) +\n\t\t\tieee80211_he_mcs_nss_size(&he_cap->he_cap_elem) +\n\t\t\tieee80211_he_ppe_size(he_cap->ppe_thres[0],\n\t\t\t\t\t      he_cap->he_cap_elem.phy_cap_info);\n\t\tpos = skb_put(skb, cap_size);\n\t\tpos = ieee80211_ie_build_he_cap(0, pos, he_cap, pos + cap_size);\n\n\t\t \n\t\tif (sband->band == NL80211_BAND_6GHZ) {\n\t\t\tcap_size = 2 + 1 + sizeof(struct ieee80211_he_6ghz_capa);\n\t\t\tpos = skb_put(skb, cap_size);\n\t\t\the_6ghz_capa =\n\t\t\t\tieee80211_get_he_6ghz_capa_vif(sband, &sdata->vif);\n\t\t\tpos = ieee80211_write_he_6ghz_cap(pos, he_6ghz_capa,\n\t\t\t\t\t\t\t  pos + cap_size);\n\t\t}\n\t}\n\n\t \n\tif (extra_ies_len) {\n\t\tstatic const u8 before_he_cap[] = {\n\t\t\tWLAN_EID_EXTENSION,\n\t\t\tWLAN_EID_EXT_FILS_REQ_PARAMS,\n\t\t\tWLAN_EID_AP_CSN,\n\t\t};\n\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_he_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_he_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t \n\tif (he_cap && eht_cap &&\n\t    (action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t     action_code == WLAN_TDLS_SETUP_RESPONSE ||\n\t     action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES)) {\n\t\tu8 cap_size;\n\n\t\tcap_size =\n\t\t\t2 + 1 + sizeof(eht_cap->eht_cap_elem) +\n\t\t\tieee80211_eht_mcs_nss_size(&he_cap->he_cap_elem,\n\t\t\t\t\t\t   &eht_cap->eht_cap_elem, false) +\n\t\t\tieee80211_eht_ppe_size(eht_cap->eht_ppe_thres[0],\n\t\t\t\t\t       eht_cap->eht_cap_elem.phy_cap_info);\n\t\tpos = skb_put(skb, cap_size);\n\t\tieee80211_ie_build_eht_cap(pos, he_cap, eht_cap, pos + cap_size, false);\n\t}\n\n\t \n\tif (extra_ies_len) {\n\t\tnoffset = extra_ies_len;\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t}\n\n}\n\nstatic void\nieee80211_tdls_add_setup_cfm_ies(struct ieee80211_link_data *link,\n\t\t\t\t struct sk_buff *skb, const u8 *peer,\n\t\t\t\t bool initiator, const u8 *extra_ies,\n\t\t\t\t size_t extra_ies_len)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tsize_t offset = 0, noffset;\n\tstruct sta_info *sta, *ap_sta;\n\tstruct ieee80211_supported_band *sband;\n\tu8 *pos;\n\n\tsband = ieee80211_get_link_sband(link);\n\tif (WARN_ON_ONCE(!sband))\n\t\treturn;\n\n\tsta = sta_info_get(sdata, peer);\n\tap_sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);\n\n\tif (WARN_ON_ONCE(!sta || !ap_sta))\n\t\treturn;\n\n\tsta->tdls_chandef = link->conf->chandef;\n\n\t \n\tif (extra_ies_len) {\n\t\tstatic const u8 before_qos[] = {\n\t\t\tWLAN_EID_RSN,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_qos,\n\t\t\t\t\t     ARRAY_SIZE(before_qos),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t \n\tif (local->hw.queues >= IEEE80211_NUM_ACS && sta->sta.wme)\n\t\tieee80211_tdls_add_wmm_param_ie(sdata, skb);\n\n\t \n\tif (extra_ies_len) {\n\t\tstatic const u8 before_ht_op[] = {\n\t\t\tWLAN_EID_RSN,\n\t\t\tWLAN_EID_QOS_CAPA,\n\t\t\tWLAN_EID_FAST_BSS_TRANSITION,\n\t\t\tWLAN_EID_TIMEOUT_INTERVAL,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_ht_op,\n\t\t\t\t\t     ARRAY_SIZE(before_ht_op),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t \n\tif (!ap_sta->sta.deflink.ht_cap.ht_supported && sta->sta.deflink.ht_cap.ht_supported) {\n\t\tu16 prot = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED |\n\t\t\t   IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT |\n\t\t\t   IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\n\n\t\tpos = skb_put(skb, 2 + sizeof(struct ieee80211_ht_operation));\n\t\tieee80211_ie_build_ht_oper(pos, &sta->sta.deflink.ht_cap,\n\t\t\t\t\t   &link->conf->chandef, prot,\n\t\t\t\t\t   true);\n\t}\n\n\tieee80211_tdls_add_link_ie(link, skb, peer, initiator);\n\n\t \n\tif (sband->band != NL80211_BAND_2GHZ &&\n\t    sta->sta.deflink.vht_cap.vht_supported) {\n\t\t \n\t\tif (test_sta_flag(sta, WLAN_STA_TDLS_WIDER_BW))\n\t\t\tieee80211_tdls_chandef_vht_upgrade(sdata, sta);\n\n\t\tpos = skb_put(skb, 2 + sizeof(struct ieee80211_vht_operation));\n\t\tieee80211_ie_build_vht_oper(pos, &sta->sta.deflink.vht_cap,\n\t\t\t\t\t    &sta->tdls_chandef);\n\t}\n\n\t \n\tif (extra_ies_len) {\n\t\tnoffset = extra_ies_len;\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t}\n}\n\nstatic void\nieee80211_tdls_add_chan_switch_req_ies(struct ieee80211_link_data *link,\n\t\t\t\t       struct sk_buff *skb, const u8 *peer,\n\t\t\t\t       bool initiator, const u8 *extra_ies,\n\t\t\t\t       size_t extra_ies_len, u8 oper_class,\n\t\t\t\t       struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_tdls_data *tf;\n\tsize_t offset = 0, noffset;\n\n\tif (WARN_ON_ONCE(!chandef))\n\t\treturn;\n\n\ttf = (void *)skb->data;\n\ttf->u.chan_switch_req.target_channel =\n\t\tieee80211_frequency_to_channel(chandef->chan->center_freq);\n\ttf->u.chan_switch_req.oper_class = oper_class;\n\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_lnkie[] = {\n\t\t\tWLAN_EID_SECONDARY_CHANNEL_OFFSET,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_lnkie,\n\t\t\t\t\t     ARRAY_SIZE(before_lnkie),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\tieee80211_tdls_add_link_ie(link, skb, peer, initiator);\n\n\t \n\tif (extra_ies_len) {\n\t\tnoffset = extra_ies_len;\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t}\n}\n\nstatic void\nieee80211_tdls_add_chan_switch_resp_ies(struct ieee80211_link_data *link,\n\t\t\t\t\tstruct sk_buff *skb, const u8 *peer,\n\t\t\t\t\tu16 status_code, bool initiator,\n\t\t\t\t\tconst u8 *extra_ies,\n\t\t\t\t\tsize_t extra_ies_len)\n{\n\tif (status_code == 0)\n\t\tieee80211_tdls_add_link_ie(link, skb, peer, initiator);\n\n\tif (extra_ies_len)\n\t\tskb_put_data(skb, extra_ies, extra_ies_len);\n}\n\nstatic void ieee80211_tdls_add_ies(struct ieee80211_link_data *link,\n\t\t\t\t   struct sk_buff *skb, const u8 *peer,\n\t\t\t\t   u8 action_code, u16 status_code,\n\t\t\t\t   bool initiator, const u8 *extra_ies,\n\t\t\t\t   size_t extra_ies_len, u8 oper_class,\n\t\t\t\t   struct cfg80211_chan_def *chandef)\n{\n\tswitch (action_code) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\tcase WLAN_PUB_ACTION_TDLS_DISCOVER_RES:\n\t\tif (status_code == 0)\n\t\t\tieee80211_tdls_add_setup_start_ies(link,\n\t\t\t\t\t\t\t   skb, peer,\n\t\t\t\t\t\t\t   action_code,\n\t\t\t\t\t\t\t   initiator,\n\t\t\t\t\t\t\t   extra_ies,\n\t\t\t\t\t\t\t   extra_ies_len);\n\t\tbreak;\n\tcase WLAN_TDLS_SETUP_CONFIRM:\n\t\tif (status_code == 0)\n\t\t\tieee80211_tdls_add_setup_cfm_ies(link, skb, peer,\n\t\t\t\t\t\t\t initiator, extra_ies,\n\t\t\t\t\t\t\t extra_ies_len);\n\t\tbreak;\n\tcase WLAN_TDLS_TEARDOWN:\n\tcase WLAN_TDLS_DISCOVERY_REQUEST:\n\t\tif (extra_ies_len)\n\t\t\tskb_put_data(skb, extra_ies, extra_ies_len);\n\t\tif (status_code == 0 || action_code == WLAN_TDLS_TEARDOWN)\n\t\t\tieee80211_tdls_add_link_ie(link, skb,\n\t\t\t\t\t\t   peer, initiator);\n\t\tbreak;\n\tcase WLAN_TDLS_CHANNEL_SWITCH_REQUEST:\n\t\tieee80211_tdls_add_chan_switch_req_ies(link, skb, peer,\n\t\t\t\t\t\t       initiator, extra_ies,\n\t\t\t\t\t\t       extra_ies_len,\n\t\t\t\t\t\t       oper_class, chandef);\n\t\tbreak;\n\tcase WLAN_TDLS_CHANNEL_SWITCH_RESPONSE:\n\t\tieee80211_tdls_add_chan_switch_resp_ies(link, skb, peer,\n\t\t\t\t\t\t\tstatus_code,\n\t\t\t\t\t\t\tinitiator, extra_ies,\n\t\t\t\t\t\t\textra_ies_len);\n\t\tbreak;\n\t}\n\n}\n\nstatic int\nieee80211_prep_tdls_encap_data(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       struct ieee80211_link_data *link,\n\t\t\t       const u8 *peer, u8 action_code, u8 dialog_token,\n\t\t\t       u16 status_code, struct sk_buff *skb)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_tdls_data *tf;\n\n\ttf = skb_put(skb, offsetof(struct ieee80211_tdls_data, u));\n\n\tmemcpy(tf->da, peer, ETH_ALEN);\n\tmemcpy(tf->sa, sdata->vif.addr, ETH_ALEN);\n\ttf->ether_type = cpu_to_be16(ETH_P_TDLS);\n\ttf->payload_type = WLAN_TDLS_SNAP_RFTYPE;\n\n\t \n\tskb_set_network_header(skb, ETH_HLEN);\n\n\tswitch (action_code) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\t\ttf->category = WLAN_CATEGORY_TDLS;\n\t\ttf->action_code = WLAN_TDLS_SETUP_REQUEST;\n\n\t\tskb_put(skb, sizeof(tf->u.setup_req));\n\t\ttf->u.setup_req.dialog_token = dialog_token;\n\t\ttf->u.setup_req.capability =\n\t\t\tcpu_to_le16(ieee80211_get_tdls_sta_capab(link,\n\t\t\t\t\t\t\t\t status_code));\n\t\tbreak;\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\t\ttf->category = WLAN_CATEGORY_TDLS;\n\t\ttf->action_code = WLAN_TDLS_SETUP_RESPONSE;\n\n\t\tskb_put(skb, sizeof(tf->u.setup_resp));\n\t\ttf->u.setup_resp.status_code = cpu_to_le16(status_code);\n\t\ttf->u.setup_resp.dialog_token = dialog_token;\n\t\ttf->u.setup_resp.capability =\n\t\t\tcpu_to_le16(ieee80211_get_tdls_sta_capab(link,\n\t\t\t\t\t\t\t\t status_code));\n\t\tbreak;\n\tcase WLAN_TDLS_SETUP_CONFIRM:\n\t\ttf->category = WLAN_CATEGORY_TDLS;\n\t\ttf->action_code = WLAN_TDLS_SETUP_CONFIRM;\n\n\t\tskb_put(skb, sizeof(tf->u.setup_cfm));\n\t\ttf->u.setup_cfm.status_code = cpu_to_le16(status_code);\n\t\ttf->u.setup_cfm.dialog_token = dialog_token;\n\t\tbreak;\n\tcase WLAN_TDLS_TEARDOWN:\n\t\ttf->category = WLAN_CATEGORY_TDLS;\n\t\ttf->action_code = WLAN_TDLS_TEARDOWN;\n\n\t\tskb_put(skb, sizeof(tf->u.teardown));\n\t\ttf->u.teardown.reason_code = cpu_to_le16(status_code);\n\t\tbreak;\n\tcase WLAN_TDLS_DISCOVERY_REQUEST:\n\t\ttf->category = WLAN_CATEGORY_TDLS;\n\t\ttf->action_code = WLAN_TDLS_DISCOVERY_REQUEST;\n\n\t\tskb_put(skb, sizeof(tf->u.discover_req));\n\t\ttf->u.discover_req.dialog_token = dialog_token;\n\t\tbreak;\n\tcase WLAN_TDLS_CHANNEL_SWITCH_REQUEST:\n\t\ttf->category = WLAN_CATEGORY_TDLS;\n\t\ttf->action_code = WLAN_TDLS_CHANNEL_SWITCH_REQUEST;\n\n\t\tskb_put(skb, sizeof(tf->u.chan_switch_req));\n\t\tbreak;\n\tcase WLAN_TDLS_CHANNEL_SWITCH_RESPONSE:\n\t\ttf->category = WLAN_CATEGORY_TDLS;\n\t\ttf->action_code = WLAN_TDLS_CHANNEL_SWITCH_RESPONSE;\n\n\t\tskb_put(skb, sizeof(tf->u.chan_switch_resp));\n\t\ttf->u.chan_switch_resp.status_code = cpu_to_le16(status_code);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nieee80211_prep_tdls_direct(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   const u8 *peer, struct ieee80211_link_data *link,\n\t\t\t   u8 action_code, u8 dialog_token,\n\t\t\t   u16 status_code, struct sk_buff *skb)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_mgmt *mgmt;\n\n\tmgmt = skb_put_zero(skb, 24);\n\tmemcpy(mgmt->da, peer, ETH_ALEN);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, link->u.mgd.bssid, ETH_ALEN);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\n\tswitch (action_code) {\n\tcase WLAN_PUB_ACTION_TDLS_DISCOVER_RES:\n\t\tskb_put(skb, 1 + sizeof(mgmt->u.action.u.tdls_discover_resp));\n\t\tmgmt->u.action.category = WLAN_CATEGORY_PUBLIC;\n\t\tmgmt->u.action.u.tdls_discover_resp.action_code =\n\t\t\tWLAN_PUB_ACTION_TDLS_DISCOVER_RES;\n\t\tmgmt->u.action.u.tdls_discover_resp.dialog_token =\n\t\t\tdialog_token;\n\t\tmgmt->u.action.u.tdls_discover_resp.capability =\n\t\t\tcpu_to_le16(ieee80211_get_tdls_sta_capab(link,\n\t\t\t\t\t\t\t\t status_code));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff *\nieee80211_tdls_build_mgmt_packet_data(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      const u8 *peer, int link_id,\n\t\t\t\t      u8 action_code, u8 dialog_token,\n\t\t\t\t      u16 status_code, bool initiator,\n\t\t\t\t      const u8 *extra_ies, size_t extra_ies_len,\n\t\t\t\t      u8 oper_class,\n\t\t\t\t      struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tint ret;\n\tstruct ieee80211_link_data *link;\n\n\tlink_id = link_id >= 0 ? link_id : 0;\n\trcu_read_lock();\n\tlink = rcu_dereference(sdata->link[link_id]);\n\tif (WARN_ON(!link))\n\t\tgoto unlock;\n\n\tskb = netdev_alloc_skb(sdata->dev,\n\t\t\t       local->hw.extra_tx_headroom +\n\t\t\t       max(sizeof(struct ieee80211_mgmt),\n\t\t\t\t   sizeof(struct ieee80211_tdls_data)) +\n\t\t\t       50 +  \n\t\t\t       10 +  \n\t\t\t       26 +  \n\t\t\t       2 + max(sizeof(struct ieee80211_ht_cap),\n\t\t\t\t       sizeof(struct ieee80211_ht_operation)) +\n\t\t\t       2 + max(sizeof(struct ieee80211_vht_cap),\n\t\t\t\t       sizeof(struct ieee80211_vht_operation)) +\n\t\t\t       2 + 1 + sizeof(struct ieee80211_he_cap_elem) +\n\t\t\t\t       sizeof(struct ieee80211_he_mcs_nss_supp) +\n\t\t\t\t       IEEE80211_HE_PPE_THRES_MAX_LEN +\n\t\t\t       2 + 1 + sizeof(struct ieee80211_he_6ghz_capa) +\n\t\t\t       2 + 1 + sizeof(struct ieee80211_eht_cap_elem) +\n\t\t\t\t       sizeof(struct ieee80211_eht_mcs_nss_supp) +\n\t\t\t\t       IEEE80211_EHT_PPE_THRES_MAX_LEN +\n\t\t\t       50 +  \n\t\t\t       3 +  \n\t\t\t       4 +  \n\t\t\t       4 +  \n\t\t\t       extra_ies_len +\n\t\t\t       sizeof(struct ieee80211_tdls_lnkie));\n\tif (!skb)\n\t\tgoto unlock;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tswitch (action_code) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\tcase WLAN_TDLS_SETUP_CONFIRM:\n\tcase WLAN_TDLS_TEARDOWN:\n\tcase WLAN_TDLS_DISCOVERY_REQUEST:\n\tcase WLAN_TDLS_CHANNEL_SWITCH_REQUEST:\n\tcase WLAN_TDLS_CHANNEL_SWITCH_RESPONSE:\n\t\tret = ieee80211_prep_tdls_encap_data(local->hw.wiphy,\n\t\t\t\t\t\t     sdata->dev, link, peer,\n\t\t\t\t\t\t     action_code, dialog_token,\n\t\t\t\t\t\t     status_code, skb);\n\t\tbreak;\n\tcase WLAN_PUB_ACTION_TDLS_DISCOVER_RES:\n\t\tret = ieee80211_prep_tdls_direct(local->hw.wiphy, sdata->dev,\n\t\t\t\t\t\t peer, link, action_code,\n\t\t\t\t\t\t dialog_token, status_code,\n\t\t\t\t\t\t skb);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tieee80211_tdls_add_ies(link, skb, peer, action_code, status_code,\n\t\t\t       initiator, extra_ies, extra_ies_len, oper_class,\n\t\t\t       chandef);\n\trcu_read_unlock();\n\treturn skb;\n\nfail:\n\tdev_kfree_skb(skb);\nunlock:\n\trcu_read_unlock();\n\treturn NULL;\n}\n\nstatic int\nieee80211_tdls_prep_mgmt_packet(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tconst u8 *peer, int link_id,\n\t\t\t\tu8 action_code, u8 dialog_token,\n\t\t\t\tu16 status_code, u32 peer_capability,\n\t\t\t\tbool initiator, const u8 *extra_ies,\n\t\t\t\tsize_t extra_ies_len, u8 oper_class,\n\t\t\t\tstruct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct sk_buff *skb = NULL;\n\tstruct sta_info *sta;\n\tu32 flags = 0;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tsta = sta_info_get(sdata, peer);\n\n\t \n\tswitch (action_code) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\t\tif (sta) {\n\t\t\tset_sta_flag(sta, WLAN_STA_TDLS_INITIATOR);\n\t\t\tsta->sta.tdls_initiator = false;\n\t\t}\n\t\tfallthrough;\n\tcase WLAN_TDLS_SETUP_CONFIRM:\n\tcase WLAN_TDLS_DISCOVERY_REQUEST:\n\t\tinitiator = true;\n\t\tbreak;\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\t\t \n\t\tif (sta) {\n\t\t\tclear_sta_flag(sta, WLAN_STA_TDLS_INITIATOR);\n\t\t\tsta->sta.tdls_initiator = true;\n\t\t}\n\t\tfallthrough;\n\tcase WLAN_PUB_ACTION_TDLS_DISCOVER_RES:\n\t\tinitiator = false;\n\t\tbreak;\n\tcase WLAN_TDLS_TEARDOWN:\n\tcase WLAN_TDLS_CHANNEL_SWITCH_REQUEST:\n\tcase WLAN_TDLS_CHANNEL_SWITCH_RESPONSE:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (sta && test_sta_flag(sta, WLAN_STA_TDLS_INITIATOR))\n\t\tinitiator = true;\n\n\trcu_read_unlock();\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tskb = ieee80211_tdls_build_mgmt_packet_data(sdata, peer,\n\t\t\t\t\t\t    link_id, action_code,\n\t\t\t\t\t\t    dialog_token, status_code,\n\t\t\t\t\t\t    initiator, extra_ies,\n\t\t\t\t\t\t    extra_ies_len, oper_class,\n\t\t\t\t\t\t    chandef);\n\tif (!skb) {\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES) {\n\t\tieee80211_tx_skb_tid(sdata, skb, 7, link_id);\n\t\treturn 0;\n\t}\n\n\t \n\tswitch (action_code) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\t\tskb->priority = 256 + 2;\n\t\tbreak;\n\tdefault:\n\t\tskb->priority = 256 + 5;\n\t\tbreak;\n\t}\n\n\t \n\tif ((action_code == WLAN_TDLS_TEARDOWN) &&\n\t    ieee80211_hw_check(&sdata->local->hw, REPORTS_TX_ACK_STATUS)) {\n\t\tbool try_resend;  \n\n\t\t \n\t\trcu_read_lock();\n\t\tsta = sta_info_get(sdata, peer);\n\t\ttry_resend = sta && test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH);\n\t\trcu_read_unlock();\n\n\t\tspin_lock_bh(&sdata->u.mgd.teardown_lock);\n\t\tif (try_resend && !sdata->u.mgd.teardown_skb) {\n\t\t\t \n\t\t\tflags |= IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t\t\t IEEE80211_TX_INTFL_MLME_CONN_TX;\n\n\t\t\t \n\t\t\tsdata->u.mgd.teardown_skb = skb_copy(skb, GFP_ATOMIC);\n\t\t\tsdata->u.mgd.orig_teardown_skb = skb;\n\t\t}\n\t\tspin_unlock_bh(&sdata->u.mgd.teardown_lock);\n\t}\n\n\t \n\tlocal_bh_disable();\n\t__ieee80211_subif_start_xmit(skb, dev, flags,\n\t\t\t\t     IEEE80211_TX_CTRL_MLO_LINK_UNSPEC, NULL);\n\tlocal_bh_enable();\n\n\treturn ret;\n\nfail:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int\nieee80211_tdls_mgmt_setup(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  const u8 *peer, int link_id,\n\t\t\t  u8 action_code, u8 dialog_token,\n\t\t\t  u16 status_code, u32 peer_capability, bool initiator,\n\t\t\t  const u8 *extra_ies, size_t extra_ies_len)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tenum ieee80211_smps_mode smps_mode =\n\t\tsdata->deflink.u.mgd.driver_smps_mode;\n\tint ret;\n\n\t \n\tif (smps_mode != IEEE80211_SMPS_AUTOMATIC &&\n\t    smps_mode != IEEE80211_SMPS_OFF) {\n\t\ttdls_dbg(sdata, \"Aborting TDLS setup due to SMPS mode %d\\n\",\n\t\t\t smps_mode);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tmutex_lock(&local->mtx);\n\n\t \n\tif (!is_zero_ether_addr(sdata->u.mgd.tdls_peer) &&\n\t    !ether_addr_equal(sdata->u.mgd.tdls_peer, peer)) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (status_code == 0) {\n\t\trcu_read_lock();\n\t\tif (!sta_info_get(sdata, peer)) {\n\t\t\trcu_read_unlock();\n\t\t\tret = -ENOLINK;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tieee80211_flush_queues(local, sdata, false);\n\tmemcpy(sdata->u.mgd.tdls_peer, peer, ETH_ALEN);\n\tmutex_unlock(&local->mtx);\n\n\t \n\tret = ieee80211_tdls_prep_mgmt_packet(wiphy, dev, peer,\n\t\t\t\t\t      link_id, action_code,\n\t\t\t\t\t      dialog_token, status_code,\n\t\t\t\t\t      peer_capability, initiator,\n\t\t\t\t\t      extra_ies, extra_ies_len, 0,\n\t\t\t\t\t      NULL);\n\tif (ret < 0) {\n\t\tmutex_lock(&local->mtx);\n\t\teth_zero_addr(sdata->u.mgd.tdls_peer);\n\t\tmutex_unlock(&local->mtx);\n\t\treturn ret;\n\t}\n\n\tieee80211_queue_delayed_work(&sdata->local->hw,\n\t\t\t\t     &sdata->u.mgd.tdls_peer_del_work,\n\t\t\t\t     TDLS_PEER_SETUP_TIMEOUT);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&local->mtx);\n\treturn ret;\n}\n\nstatic int\nieee80211_tdls_mgmt_teardown(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     const u8 *peer, int link_id,\n\t\t\t     u8 action_code, u8 dialog_token,\n\t\t\t     u16 status_code, u32 peer_capability,\n\t\t\t     bool initiator, const u8 *extra_ies,\n\t\t\t     size_t extra_ies_len)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tint ret;\n\n\t \n\tieee80211_stop_vif_queues(local, sdata,\n\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_TDLS_TEARDOWN);\n\tieee80211_flush_queues(local, sdata, false);\n\n\tret = ieee80211_tdls_prep_mgmt_packet(wiphy, dev, peer,\n\t\t\t\t\t      link_id, action_code,\n\t\t\t\t\t      dialog_token, status_code,\n\t\t\t\t\t      peer_capability, initiator,\n\t\t\t\t\t      extra_ies, extra_ies_len, 0,\n\t\t\t\t\t      NULL);\n\tif (ret < 0)\n\t\tsdata_err(sdata, \"Failed sending TDLS teardown packet %d\\n\",\n\t\t\t  ret);\n\n\t \n\trcu_read_lock();\n\tsta = sta_info_get(sdata, peer);\n\tif (sta)\n\t\tclear_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH);\n\trcu_read_unlock();\n\n\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_TDLS_TEARDOWN);\n\n\treturn 0;\n}\n\nint ieee80211_tdls_mgmt(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tconst u8 *peer, int link_id,\n\t\t\tu8 action_code, u8 dialog_token, u16 status_code,\n\t\t\tu32 peer_capability, bool initiator,\n\t\t\tconst u8 *extra_ies, size_t extra_ies_len)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tint ret;\n\n\tif (!(wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS))\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (sdata->vif.type != NL80211_IFTYPE_STATION ||\n\t    !sdata->u.mgd.associated)\n\t\treturn -EINVAL;\n\n\tswitch (action_code) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\t\tret = ieee80211_tdls_mgmt_setup(wiphy, dev, peer,\n\t\t\t\t\t\tlink_id, action_code,\n\t\t\t\t\t\tdialog_token, status_code,\n\t\t\t\t\t\tpeer_capability, initiator,\n\t\t\t\t\t\textra_ies, extra_ies_len);\n\t\tbreak;\n\tcase WLAN_TDLS_TEARDOWN:\n\t\tret = ieee80211_tdls_mgmt_teardown(wiphy, dev, peer, link_id,\n\t\t\t\t\t\t   action_code, dialog_token,\n\t\t\t\t\t\t   status_code,\n\t\t\t\t\t\t   peer_capability, initiator,\n\t\t\t\t\t\t   extra_ies, extra_ies_len);\n\t\tbreak;\n\tcase WLAN_TDLS_DISCOVERY_REQUEST:\n\t\t \n\t\tdrv_mgd_protect_tdls_discover(sdata->local, sdata);\n\t\tfallthrough;\n\tcase WLAN_TDLS_SETUP_CONFIRM:\n\tcase WLAN_PUB_ACTION_TDLS_DISCOVER_RES:\n\t\t \n\t\tret = ieee80211_tdls_prep_mgmt_packet(wiphy, dev, peer,\n\t\t\t\t\t\t      link_id, action_code,\n\t\t\t\t\t\t      dialog_token,\n\t\t\t\t\t\t      status_code,\n\t\t\t\t\t\t      peer_capability,\n\t\t\t\t\t\t      initiator, extra_ies,\n\t\t\t\t\t\t      extra_ies_len, 0, NULL);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\ttdls_dbg(sdata, \"TDLS mgmt action %d peer %pM link_id %d status %d\\n\",\n\t\t action_code, peer, link_id, ret);\n\treturn ret;\n}\n\nstatic void iee80211_tdls_recalc_chanctx(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct sta_info *sta)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *conf;\n\tstruct ieee80211_chanctx *ctx;\n\tenum nl80211_chan_width width;\n\tstruct ieee80211_supported_band *sband;\n\n\tmutex_lock(&local->chanctx_mtx);\n\tconf = rcu_dereference_protected(sdata->vif.bss_conf.chanctx_conf,\n\t\t\t\t\t lockdep_is_held(&local->chanctx_mtx));\n\tif (conf) {\n\t\twidth = conf->def.width;\n\t\tsband = local->hw.wiphy->bands[conf->def.chan->band];\n\t\tctx = container_of(conf, struct ieee80211_chanctx, conf);\n\t\tieee80211_recalc_chanctx_chantype(local, ctx);\n\n\t\t \n\t\tif (width != conf->def.width && sta &&\n\t\t    test_sta_flag(sta, WLAN_STA_TDLS_WIDER_BW)) {\n\t\t\tenum ieee80211_sta_rx_bandwidth bw;\n\n\t\t\tbw = ieee80211_chan_width_to_rx_bw(conf->def.width);\n\t\t\tbw = min(bw, ieee80211_sta_cap_rx_bw(&sta->deflink));\n\t\t\tif (bw != sta->sta.deflink.bandwidth) {\n\t\t\t\tsta->sta.deflink.bandwidth = bw;\n\t\t\t\trate_control_rate_update(local, sband, sta, 0,\n\t\t\t\t\t\t\t IEEE80211_RC_BW_CHANGED);\n\t\t\t\t \n\t\t\t\tieee80211_recalc_chanctx_chantype(local, ctx);\n\t\t\t}\n\t\t}\n\n\t}\n\tmutex_unlock(&local->chanctx_mtx);\n}\n\nstatic int iee80211_tdls_have_ht_peers(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct sta_info *sta;\n\tbool result = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &sdata->local->sta_list, list) {\n\t\tif (!sta->sta.tdls || sta->sdata != sdata || !sta->uploaded ||\n\t\t    !test_sta_flag(sta, WLAN_STA_AUTHORIZED) ||\n\t\t    !test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH) ||\n\t\t    !sta->sta.deflink.ht_cap.ht_supported)\n\t\t\tcontinue;\n\t\tresult = true;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn result;\n}\n\nstatic void\niee80211_tdls_recalc_ht_protection(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct sta_info *sta)\n{\n\tbool tdls_ht;\n\tu16 protection = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED |\n\t\t\t IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT |\n\t\t\t IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\n\tu16 opmode;\n\n\t \n\tif (!(sdata->deflink.u.mgd.conn_flags & IEEE80211_CONN_DISABLE_HT))\n\t\treturn;\n\n\ttdls_ht = (sta && sta->sta.deflink.ht_cap.ht_supported) ||\n\t\t  iee80211_tdls_have_ht_peers(sdata);\n\n\topmode = sdata->vif.bss_conf.ht_operation_mode;\n\n\tif (tdls_ht)\n\t\topmode |= protection;\n\telse\n\t\topmode &= ~protection;\n\n\tif (opmode == sdata->vif.bss_conf.ht_operation_mode)\n\t\treturn;\n\n\tsdata->vif.bss_conf.ht_operation_mode = opmode;\n\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t  BSS_CHANGED_HT);\n}\n\nint ieee80211_tdls_oper(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tconst u8 *peer, enum nl80211_tdls_operation oper)\n{\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret;\n\n\tif (!(wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS))\n\t\treturn -ENOTSUPP;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn -EINVAL;\n\n\tswitch (oper) {\n\tcase NL80211_TDLS_ENABLE_LINK:\n\tcase NL80211_TDLS_DISABLE_LINK:\n\t\tbreak;\n\tcase NL80211_TDLS_TEARDOWN:\n\tcase NL80211_TDLS_SETUP:\n\tcase NL80211_TDLS_DISCOVERY_REQ:\n\t\t \n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\tsdata_lock(sdata);\n\tmutex_lock(&local->mtx);\n\ttdls_dbg(sdata, \"TDLS oper %d peer %pM\\n\", oper, peer);\n\n\tswitch (oper) {\n\tcase NL80211_TDLS_ENABLE_LINK:\n\t\tif (sdata->vif.bss_conf.csa_active) {\n\t\t\ttdls_dbg(sdata, \"TDLS: disallow link during CSA\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&local->sta_mtx);\n\t\tsta = sta_info_get(sdata, peer);\n\t\tif (!sta) {\n\t\t\tmutex_unlock(&local->sta_mtx);\n\t\t\tret = -ENOLINK;\n\t\t\tbreak;\n\t\t}\n\n\t\tiee80211_tdls_recalc_chanctx(sdata, sta);\n\t\tiee80211_tdls_recalc_ht_protection(sdata, sta);\n\n\t\tset_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH);\n\t\tmutex_unlock(&local->sta_mtx);\n\n\t\tWARN_ON_ONCE(is_zero_ether_addr(sdata->u.mgd.tdls_peer) ||\n\t\t\t     !ether_addr_equal(sdata->u.mgd.tdls_peer, peer));\n\t\tret = 0;\n\t\tbreak;\n\tcase NL80211_TDLS_DISABLE_LINK:\n\t\t \n\t\ttasklet_kill(&local->tx_pending_tasklet);\n\t\t \n\t\tieee80211_flush_queues(local, sdata, false);\n\n\t\tret = sta_info_destroy_addr(sdata, peer);\n\n\t\tmutex_lock(&local->sta_mtx);\n\t\tiee80211_tdls_recalc_ht_protection(sdata, NULL);\n\t\tmutex_unlock(&local->sta_mtx);\n\n\t\tiee80211_tdls_recalc_chanctx(sdata, NULL);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (ret == 0 && ether_addr_equal(sdata->u.mgd.tdls_peer, peer)) {\n\t\tcancel_delayed_work(&sdata->u.mgd.tdls_peer_del_work);\n\t\teth_zero_addr(sdata->u.mgd.tdls_peer);\n\t}\n\n\tif (ret == 0)\n\t\twiphy_work_queue(sdata->local->hw.wiphy,\n\t\t\t\t &sdata->deflink.u.mgd.request_smps_work);\n\n\tmutex_unlock(&local->mtx);\n\tsdata_unlock(sdata);\n\treturn ret;\n}\n\nvoid ieee80211_tdls_oper_request(struct ieee80211_vif *vif, const u8 *peer,\n\t\t\t\t enum nl80211_tdls_operation oper,\n\t\t\t\t u16 reason_code, gfp_t gfp)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (vif->type != NL80211_IFTYPE_STATION || !vif->cfg.assoc) {\n\t\tsdata_err(sdata, \"Discarding TDLS oper %d - not STA or disconnected\\n\",\n\t\t\t  oper);\n\t\treturn;\n\t}\n\n\tcfg80211_tdls_oper_request(sdata->dev, peer, oper, reason_code, gfp);\n}\nEXPORT_SYMBOL(ieee80211_tdls_oper_request);\n\nstatic void\niee80211_tdls_add_ch_switch_timing(u8 *buf, u16 switch_time, u16 switch_timeout)\n{\n\tstruct ieee80211_ch_switch_timing *ch_sw;\n\n\t*buf++ = WLAN_EID_CHAN_SWITCH_TIMING;\n\t*buf++ = sizeof(struct ieee80211_ch_switch_timing);\n\n\tch_sw = (void *)buf;\n\tch_sw->switch_time = cpu_to_le16(switch_time);\n\tch_sw->switch_timeout = cpu_to_le16(switch_timeout);\n}\n\n \nstatic const u8 *ieee80211_tdls_find_sw_timing_ie(struct sk_buff *skb)\n{\n\tstruct ieee80211_tdls_data *tf;\n\tconst u8 *ie_start;\n\n\t \n\ttf = container_of(skb->data + skb_network_offset(skb),\n\t\t\t  struct ieee80211_tdls_data, payload_type);\n\tie_start = tf->u.chan_switch_req.variable;\n\treturn cfg80211_find_ie(WLAN_EID_CHAN_SWITCH_TIMING, ie_start,\n\t\t\t\tskb->len - (ie_start - skb->data));\n}\n\nstatic struct sk_buff *\nieee80211_tdls_ch_sw_tmpl_get(struct sta_info *sta, u8 oper_class,\n\t\t\t      struct cfg80211_chan_def *chandef,\n\t\t\t      u32 *ch_sw_tm_ie_offset)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tu8 extra_ies[2 + sizeof(struct ieee80211_sec_chan_offs_ie) +\n\t\t     2 + sizeof(struct ieee80211_ch_switch_timing)];\n\tint extra_ies_len = 2 + sizeof(struct ieee80211_ch_switch_timing);\n\tu8 *pos = extra_ies;\n\tstruct sk_buff *skb;\n\tint link_id = sta->sta.valid_links ? ffs(sta->sta.valid_links) - 1 : 0;\n\n\t \n\tif (chandef->width == NL80211_CHAN_WIDTH_40) {\n\t\tstruct ieee80211_sec_chan_offs_ie *sec_chan_ie;\n\t\tbool ht40plus;\n\n\t\t*pos++ = WLAN_EID_SECONDARY_CHANNEL_OFFSET;\n\t\t*pos++ = sizeof(*sec_chan_ie);\n\t\tsec_chan_ie = (void *)pos;\n\n\t\tht40plus = cfg80211_get_chandef_type(chandef) ==\n\t\t\t\t\t\t\tNL80211_CHAN_HT40PLUS;\n\t\tsec_chan_ie->sec_chan_offs = ht40plus ?\n\t\t\t\t\t     IEEE80211_HT_PARAM_CHA_SEC_ABOVE :\n\t\t\t\t\t     IEEE80211_HT_PARAM_CHA_SEC_BELOW;\n\t\tpos += sizeof(*sec_chan_ie);\n\n\t\textra_ies_len += 2 + sizeof(struct ieee80211_sec_chan_offs_ie);\n\t}\n\n\t \n\tiee80211_tdls_add_ch_switch_timing(pos, 0, 0);\n\n\tskb = ieee80211_tdls_build_mgmt_packet_data(sdata, sta->sta.addr,\n\t\t\t\t\t      link_id,\n\t\t\t\t\t      WLAN_TDLS_CHANNEL_SWITCH_REQUEST,\n\t\t\t\t\t      0, 0, !sta->sta.tdls_initiator,\n\t\t\t\t\t      extra_ies, extra_ies_len,\n\t\t\t\t\t      oper_class, chandef);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb = ieee80211_build_data_template(sdata, skb, 0);\n\tif (IS_ERR(skb)) {\n\t\ttdls_dbg(sdata, \"Failed building TDLS channel switch frame\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (ch_sw_tm_ie_offset) {\n\t\tconst u8 *tm_ie = ieee80211_tdls_find_sw_timing_ie(skb);\n\n\t\tif (!tm_ie) {\n\t\t\ttdls_dbg(sdata, \"No switch timing IE in TDLS switch\\n\");\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t*ch_sw_tm_ie_offset = tm_ie - skb->data;\n\t}\n\n\ttdls_dbg(sdata,\n\t\t \"TDLS channel switch request template for %pM ch %d width %d\\n\",\n\t\t sta->sta.addr, chandef->chan->center_freq, chandef->width);\n\treturn skb;\n}\n\nint\nieee80211_tdls_channel_switch(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *addr, u8 oper_class,\n\t\t\t      struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct sk_buff *skb = NULL;\n\tu32 ch_sw_tm_ie;\n\tint ret;\n\n\tif (chandef->chan->freq_offset)\n\t\t \n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&local->sta_mtx);\n\tsta = sta_info_get(sdata, addr);\n\tif (!sta) {\n\t\ttdls_dbg(sdata,\n\t\t\t \"Invalid TDLS peer %pM for channel switch request\\n\",\n\t\t\t addr);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!test_sta_flag(sta, WLAN_STA_TDLS_CHAN_SWITCH)) {\n\t\ttdls_dbg(sdata, \"TDLS channel switch unsupported by %pM\\n\",\n\t\t\t addr);\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tskb = ieee80211_tdls_ch_sw_tmpl_get(sta, oper_class, chandef,\n\t\t\t\t\t    &ch_sw_tm_ie);\n\tif (!skb) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = drv_tdls_channel_switch(local, sdata, &sta->sta, oper_class,\n\t\t\t\t      chandef, skb, ch_sw_tm_ie);\n\tif (!ret)\n\t\tset_sta_flag(sta, WLAN_STA_TDLS_OFF_CHANNEL);\n\nout:\n\tmutex_unlock(&local->sta_mtx);\n\tdev_kfree_skb_any(skb);\n\treturn ret;\n}\n\nvoid\nieee80211_tdls_cancel_channel_switch(struct wiphy *wiphy,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     const u8 *addr)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\tmutex_lock(&local->sta_mtx);\n\tsta = sta_info_get(sdata, addr);\n\tif (!sta) {\n\t\ttdls_dbg(sdata,\n\t\t\t \"Invalid TDLS peer %pM for channel switch cancel\\n\",\n\t\t\t addr);\n\t\tgoto out;\n\t}\n\n\tif (!test_sta_flag(sta, WLAN_STA_TDLS_OFF_CHANNEL)) {\n\t\ttdls_dbg(sdata, \"TDLS channel switch not initiated by %pM\\n\",\n\t\t\t addr);\n\t\tgoto out;\n\t}\n\n\tdrv_tdls_cancel_channel_switch(local, sdata, &sta->sta);\n\tclear_sta_flag(sta, WLAN_STA_TDLS_OFF_CHANNEL);\n\nout:\n\tmutex_unlock(&local->sta_mtx);\n}\n\nstatic struct sk_buff *\nieee80211_tdls_ch_sw_resp_tmpl_get(struct sta_info *sta,\n\t\t\t\t   u32 *ch_sw_tm_ie_offset)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct sk_buff *skb;\n\tu8 extra_ies[2 + sizeof(struct ieee80211_ch_switch_timing)];\n\tint link_id = sta->sta.valid_links ? ffs(sta->sta.valid_links) - 1 : 0;\n\n\t \n\tiee80211_tdls_add_ch_switch_timing(extra_ies, 0, 0);\n\n\tskb = ieee80211_tdls_build_mgmt_packet_data(sdata, sta->sta.addr,\n\t\t\t\t\tlink_id,\n\t\t\t\t\tWLAN_TDLS_CHANNEL_SWITCH_RESPONSE,\n\t\t\t\t\t0, 0, !sta->sta.tdls_initiator,\n\t\t\t\t\textra_ies, sizeof(extra_ies), 0, NULL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb = ieee80211_build_data_template(sdata, skb, 0);\n\tif (IS_ERR(skb)) {\n\t\ttdls_dbg(sdata,\n\t\t\t \"Failed building TDLS channel switch resp frame\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (ch_sw_tm_ie_offset) {\n\t\tconst u8 *tm_ie = ieee80211_tdls_find_sw_timing_ie(skb);\n\n\t\tif (!tm_ie) {\n\t\t\ttdls_dbg(sdata,\n\t\t\t\t \"No switch timing IE in TDLS switch resp\\n\");\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t*ch_sw_tm_ie_offset = tm_ie - skb->data;\n\t}\n\n\ttdls_dbg(sdata, \"TDLS get channel switch response template for %pM\\n\",\n\t\t sta->sta.addr);\n\treturn skb;\n}\n\nstatic int\nieee80211_process_tdls_channel_switch_resp(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee802_11_elems *elems = NULL;\n\tstruct sta_info *sta;\n\tstruct ieee80211_tdls_data *tf = (void *)skb->data;\n\tbool local_initiator;\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tint baselen = offsetof(typeof(*tf), u.chan_switch_resp.variable);\n\tstruct ieee80211_tdls_ch_sw_params params = {};\n\tint ret;\n\n\tparams.action_code = WLAN_TDLS_CHANNEL_SWITCH_RESPONSE;\n\tparams.timestamp = rx_status->device_timestamp;\n\n\tif (skb->len < baselen) {\n\t\ttdls_dbg(sdata, \"TDLS channel switch resp too short: %d\\n\",\n\t\t\t skb->len);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&local->sta_mtx);\n\tsta = sta_info_get(sdata, tf->sa);\n\tif (!sta || !test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH)) {\n\t\ttdls_dbg(sdata, \"TDLS chan switch from non-peer sta %pM\\n\",\n\t\t\t tf->sa);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.sta = &sta->sta;\n\tparams.status = le16_to_cpu(tf->u.chan_switch_resp.status_code);\n\tif (params.status != 0) {\n\t\tret = 0;\n\t\tgoto call_drv;\n\t}\n\n\telems = ieee802_11_parse_elems(tf->u.chan_switch_resp.variable,\n\t\t\t\t       skb->len - baselen, false, NULL);\n\tif (!elems) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (elems->parse_error) {\n\t\ttdls_dbg(sdata, \"Invalid IEs in TDLS channel switch resp\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!elems->ch_sw_timing || !elems->lnk_id) {\n\t\ttdls_dbg(sdata, \"TDLS channel switch resp - missing IEs\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tlocal_initiator =\n\t\t!memcmp(elems->lnk_id->init_sta, sdata->vif.addr, ETH_ALEN);\n\tif (local_initiator == sta->sta.tdls_initiator) {\n\t\ttdls_dbg(sdata, \"TDLS chan switch invalid lnk-id initiator\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.switch_time = le16_to_cpu(elems->ch_sw_timing->switch_time);\n\tparams.switch_timeout = le16_to_cpu(elems->ch_sw_timing->switch_timeout);\n\n\tparams.tmpl_skb =\n\t\tieee80211_tdls_ch_sw_resp_tmpl_get(sta, &params.ch_sw_tm_ie);\n\tif (!params.tmpl_skb) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = 0;\ncall_drv:\n\tdrv_tdls_recv_channel_switch(sdata->local, sdata, &params);\n\n\ttdls_dbg(sdata,\n\t\t \"TDLS channel switch response received from %pM status %d\\n\",\n\t\t tf->sa, params.status);\n\nout:\n\tmutex_unlock(&local->sta_mtx);\n\tdev_kfree_skb_any(params.tmpl_skb);\n\tkfree(elems);\n\treturn ret;\n}\n\nstatic int\nieee80211_process_tdls_channel_switch_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee802_11_elems *elems;\n\tstruct cfg80211_chan_def chandef;\n\tstruct ieee80211_channel *chan;\n\tenum nl80211_channel_type chan_type;\n\tint freq;\n\tu8 target_channel, oper_class;\n\tbool local_initiator;\n\tstruct sta_info *sta;\n\tenum nl80211_band band;\n\tstruct ieee80211_tdls_data *tf = (void *)skb->data;\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tint baselen = offsetof(typeof(*tf), u.chan_switch_req.variable);\n\tstruct ieee80211_tdls_ch_sw_params params = {};\n\tint ret = 0;\n\n\tparams.action_code = WLAN_TDLS_CHANNEL_SWITCH_REQUEST;\n\tparams.timestamp = rx_status->device_timestamp;\n\n\tif (skb->len < baselen) {\n\t\ttdls_dbg(sdata, \"TDLS channel switch req too short: %d\\n\",\n\t\t\t skb->len);\n\t\treturn -EINVAL;\n\t}\n\n\ttarget_channel = tf->u.chan_switch_req.target_channel;\n\toper_class = tf->u.chan_switch_req.oper_class;\n\n\t \n\tif ((oper_class == 112 || oper_class == 2 || oper_class == 3 ||\n\t     oper_class == 4 || oper_class == 5 || oper_class == 6) &&\n\t     target_channel < 14)\n\t\tband = NL80211_BAND_5GHZ;\n\telse\n\t\tband = target_channel < 14 ? NL80211_BAND_2GHZ :\n\t\t\t\t\t     NL80211_BAND_5GHZ;\n\n\tfreq = ieee80211_channel_to_frequency(target_channel, band);\n\tif (freq == 0) {\n\t\ttdls_dbg(sdata, \"Invalid channel in TDLS chan switch: %d\\n\",\n\t\t\t target_channel);\n\t\treturn -EINVAL;\n\t}\n\n\tchan = ieee80211_get_channel(sdata->local->hw.wiphy, freq);\n\tif (!chan) {\n\t\ttdls_dbg(sdata,\n\t\t\t \"Unsupported channel for TDLS chan switch: %d\\n\",\n\t\t\t target_channel);\n\t\treturn -EINVAL;\n\t}\n\n\telems = ieee802_11_parse_elems(tf->u.chan_switch_req.variable,\n\t\t\t\t       skb->len - baselen, false, NULL);\n\tif (!elems)\n\t\treturn -ENOMEM;\n\n\tif (elems->parse_error) {\n\t\ttdls_dbg(sdata, \"Invalid IEs in TDLS channel switch req\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!elems->ch_sw_timing || !elems->lnk_id) {\n\t\ttdls_dbg(sdata, \"TDLS channel switch req - missing IEs\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!elems->sec_chan_offs) {\n\t\tchan_type = NL80211_CHAN_HT20;\n\t} else {\n\t\tswitch (elems->sec_chan_offs->sec_chan_offs) {\n\t\tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n\t\t\tchan_type = NL80211_CHAN_HT40PLUS;\n\t\t\tbreak;\n\t\tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n\t\t\tchan_type = NL80211_CHAN_HT40MINUS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tchan_type = NL80211_CHAN_HT20;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcfg80211_chandef_create(&chandef, chan, chan_type);\n\n\t \n\tif (!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &chandef,\n\t\t\t\t\t   sdata->wdev.iftype)) {\n\t\ttdls_dbg(sdata, \"TDLS chan switch to forbidden channel\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tmutex_lock(&local->sta_mtx);\n\tsta = sta_info_get(sdata, tf->sa);\n\tif (!sta || !test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH)) {\n\t\ttdls_dbg(sdata, \"TDLS chan switch from non-peer sta %pM\\n\",\n\t\t\t tf->sa);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.sta = &sta->sta;\n\n\t \n\tlocal_initiator =\n\t\t!memcmp(elems->lnk_id->init_sta, sdata->vif.addr, ETH_ALEN);\n\tif (local_initiator == sta->sta.tdls_initiator) {\n\t\ttdls_dbg(sdata, \"TDLS chan switch invalid lnk-id initiator\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!sta->sta.deflink.ht_cap.ht_supported && elems->sec_chan_offs &&\n\t    elems->sec_chan_offs->sec_chan_offs) {\n\t\ttdls_dbg(sdata, \"TDLS chan switch - wide chan unsupported\\n\");\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tparams.chandef = &chandef;\n\tparams.switch_time = le16_to_cpu(elems->ch_sw_timing->switch_time);\n\tparams.switch_timeout = le16_to_cpu(elems->ch_sw_timing->switch_timeout);\n\n\tparams.tmpl_skb =\n\t\tieee80211_tdls_ch_sw_resp_tmpl_get(sta,\n\t\t\t\t\t\t   &params.ch_sw_tm_ie);\n\tif (!params.tmpl_skb) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tdrv_tdls_recv_channel_switch(sdata->local, sdata, &params);\n\n\ttdls_dbg(sdata,\n\t\t \"TDLS ch switch request received from %pM ch %d width %d\\n\",\n\t\t tf->sa, params.chandef->chan->center_freq,\n\t\t params.chandef->width);\nout:\n\tmutex_unlock(&local->sta_mtx);\n\tdev_kfree_skb_any(params.tmpl_skb);\nfree:\n\tkfree(elems);\n\treturn ret;\n}\n\nvoid\nieee80211_process_tdls_channel_switch(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_tdls_data *tf = (void *)skb->data;\n\tstruct wiphy *wiphy = sdata->local->hw.wiphy;\n\n\tlockdep_assert_wiphy(wiphy);\n\n\t \n\tif (!(wiphy->features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH))\n\t\treturn;\n\n\t \n\tif (skb_linearize(skb))\n\t\treturn;\n\t \n\tswitch (tf->action_code) {\n\tcase WLAN_TDLS_CHANNEL_SWITCH_REQUEST:\n\t\tieee80211_process_tdls_channel_switch_req(sdata, skb);\n\t\tbreak;\n\tcase WLAN_TDLS_CHANNEL_SWITCH_RESPONSE:\n\t\tieee80211_process_tdls_channel_switch_resp(sdata, skb);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n}\n\nvoid ieee80211_teardown_tdls_peers(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct sta_info *sta;\n\tu16 reason = WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &sdata->local->sta_list, list) {\n\t\tif (!sta->sta.tdls || sta->sdata != sdata || !sta->uploaded ||\n\t\t    !test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tcontinue;\n\n\t\tieee80211_tdls_oper_request(&sdata->vif, sta->sta.addr,\n\t\t\t\t\t    NL80211_TDLS_TEARDOWN, reason,\n\t\t\t\t\t    GFP_ATOMIC);\n\t}\n\trcu_read_unlock();\n}\n\nvoid ieee80211_tdls_handle_disconnect(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      const u8 *peer, u16 reason)\n{\n\tstruct ieee80211_sta *sta;\n\n\trcu_read_lock();\n\tsta = ieee80211_find_sta(&sdata->vif, peer);\n\tif (!sta || !sta->tdls) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\n\ttdls_dbg(sdata, \"disconnected from TDLS peer %pM (Reason: %u=%s)\\n\",\n\t\t peer, reason,\n\t\t ieee80211_get_reason_code_string(reason));\n\n\tieee80211_tdls_oper_request(&sdata->vif, peer,\n\t\t\t\t    NL80211_TDLS_TEARDOWN,\n\t\t\t\t    WLAN_REASON_TDLS_TEARDOWN_UNREACHABLE,\n\t\t\t\t    GFP_ATOMIC);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}