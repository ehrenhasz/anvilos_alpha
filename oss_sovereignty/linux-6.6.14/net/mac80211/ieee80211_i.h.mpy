{
  "module_name": "ieee80211_i.h",
  "hash_id": "4273708604194c30beddaaa63a371a4b2a9bad21e516fb99fd429a8b5d2f028b",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/ieee80211_i.h",
  "human_readable_source": " \n \n\n#ifndef IEEE80211_I_H\n#define IEEE80211_I_H\n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/if_ether.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/workqueue.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/etherdevice.h>\n#include <linux/leds.h>\n#include <linux/idr.h>\n#include <linux/rhashtable.h>\n#include <linux/rbtree.h>\n#include <net/ieee80211_radiotap.h>\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include <net/fq.h>\n#include \"key.h\"\n#include \"sta_info.h\"\n#include \"debug.h\"\n#include \"drop.h\"\n\nextern const struct cfg80211_ops mac80211_config_ops;\n\nstruct ieee80211_local;\nstruct ieee80211_mesh_fast_tx;\n\n \n#define AP_MAX_BC_BUFFER 128\n\n \n#define TOTAL_MAX_TX_BUFFER 512\n\n \n#define IEEE80211_ENCRYPT_HEADROOM 8\n#define IEEE80211_ENCRYPT_TAILROOM 18\n\n \n#define IEEE80211_UNSET_POWER_LEVEL\tINT_MIN\n\n \n#define IEEE80211_DEFAULT_UAPSD_QUEUES 0\n\n#define IEEE80211_DEFAULT_MAX_SP_LEN\t\t\\\n\tIEEE80211_WMM_IE_STA_QOSINFO_SP_ALL\n\nextern const u8 ieee80211_ac_to_qos_mask[IEEE80211_NUM_ACS];\n\n#define IEEE80211_DEAUTH_FRAME_LEN\t(24   + 2  )\n\n#define IEEE80211_MAX_NAN_INSTANCE_ID 255\n\n\n \n#define AIRTIME_ACTIVE_DURATION (HZ / 10)\n\nstruct ieee80211_bss {\n\tu32 device_ts_beacon, device_ts_presp;\n\n\tbool wmm_used;\n\tbool uapsd_supported;\n\n#define IEEE80211_MAX_SUPP_RATES 32\n\tu8 supp_rates[IEEE80211_MAX_SUPP_RATES];\n\tsize_t supp_rates_len;\n\tstruct ieee80211_rate *beacon_rate;\n\n\tu32 vht_cap_info;\n\n\t \n\tbool has_erp_value;\n\tu8 erp_value;\n\n\t \n\tu8 corrupt_data;\n\n\t \n\tu8 valid_data;\n};\n\n \nenum ieee80211_bss_corrupt_data_flags {\n\tIEEE80211_BSS_CORRUPT_BEACON\t\t= BIT(0),\n\tIEEE80211_BSS_CORRUPT_PROBE_RESP\t= BIT(1)\n};\n\n \nenum ieee80211_bss_valid_data_flags {\n\tIEEE80211_BSS_VALID_WMM\t\t\t= BIT(1),\n\tIEEE80211_BSS_VALID_RATES\t\t= BIT(2),\n\tIEEE80211_BSS_VALID_ERP\t\t\t= BIT(3)\n};\n\ntypedef unsigned __bitwise ieee80211_tx_result;\n#define TX_CONTINUE\t((__force ieee80211_tx_result) 0u)\n#define TX_DROP\t\t((__force ieee80211_tx_result) 1u)\n#define TX_QUEUED\t((__force ieee80211_tx_result) 2u)\n\n#define IEEE80211_TX_UNICAST\t\tBIT(1)\n#define IEEE80211_TX_PS_BUFFERED\tBIT(2)\n\nstruct ieee80211_tx_data {\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head skbs;\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\tstruct ieee80211_key *key;\n\tstruct ieee80211_tx_rate rate;\n\n\tunsigned int flags;\n};\n\n \nenum ieee80211_packet_rx_flags {\n\tIEEE80211_RX_AMSDU\t\t\t= BIT(3),\n\tIEEE80211_RX_MALFORMED_ACTION_FRM\t= BIT(4),\n\tIEEE80211_RX_DEFERRED_RELEASE\t\t= BIT(5),\n};\n\n \nenum ieee80211_rx_flags {\n\tIEEE80211_RX_CMNTR\t\t= BIT(0),\n\tIEEE80211_RX_BEACON_REPORTED\t= BIT(1),\n};\n\nstruct ieee80211_rx_data {\n\tstruct list_head *list;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_link_data *link;\n\tstruct sta_info *sta;\n\tstruct link_sta_info *link_sta;\n\tstruct ieee80211_key *key;\n\n\tunsigned int flags;\n\n\t \n\tint seqno_idx;\n\n\t \n\tint security_idx;\n\n\tint link_id;\n\n\tunion {\n\t\tstruct {\n\t\t\tu32 iv32;\n\t\t\tu16 iv16;\n\t\t} tkip;\n\t\tstruct {\n\t\t\tu8 pn[IEEE80211_CCMP_PN_LEN];\n\t\t} ccm_gcm;\n\t};\n};\n\nstruct ieee80211_csa_settings {\n\tconst u16 *counter_offsets_beacon;\n\tconst u16 *counter_offsets_presp;\n\n\tint n_counter_offsets_beacon;\n\tint n_counter_offsets_presp;\n\n\tu8 count;\n};\n\nstruct ieee80211_color_change_settings {\n\tu16 counter_offset_beacon;\n\tu16 counter_offset_presp;\n\tu8 count;\n};\n\nstruct beacon_data {\n\tu8 *head, *tail;\n\tint head_len, tail_len;\n\tstruct ieee80211_meshconf_ie *meshconf;\n\tu16 cntdwn_counter_offsets[IEEE80211_MAX_CNTDWN_COUNTERS_NUM];\n\tu8 cntdwn_current_counter;\n\tstruct cfg80211_mbssid_elems *mbssid_ies;\n\tstruct cfg80211_rnr_elems *rnr_ies;\n\tstruct rcu_head rcu_head;\n};\n\nstruct probe_resp {\n\tstruct rcu_head rcu_head;\n\tint len;\n\tu16 cntdwn_counter_offsets[IEEE80211_MAX_CNTDWN_COUNTERS_NUM];\n\tu8 data[];\n};\n\nstruct fils_discovery_data {\n\tstruct rcu_head rcu_head;\n\tint len;\n\tu8 data[];\n};\n\nstruct unsol_bcast_probe_resp_data {\n\tstruct rcu_head rcu_head;\n\tint len;\n\tu8 data[];\n};\n\nstruct ps_data {\n\t \n\tu8 tim[sizeof(unsigned long) * BITS_TO_LONGS(IEEE80211_MAX_AID + 1)]\n\t\t\t__aligned(__alignof__(unsigned long));\n\tstruct sk_buff_head bc_buf;\n\tatomic_t num_sta_ps;  \n\tint dtim_count;\n\tbool dtim_bc_mc;\n};\n\nstruct ieee80211_if_ap {\n\tstruct list_head vlans;  \n\n\tstruct ps_data ps;\n\tatomic_t num_mcast_sta;  \n\n\tbool multicast_to_unicast;\n\tbool active;\n};\n\nstruct ieee80211_if_vlan {\n\tstruct list_head list;  \n\n\t \n\tstruct sta_info __rcu *sta;\n\tatomic_t num_mcast_sta;  \n};\n\nstruct mesh_stats {\n\t__u32 fwded_mcast;\t\t \n\t__u32 fwded_unicast;\t\t \n\t__u32 fwded_frames;\t\t \n\t__u32 dropped_frames_ttl;\t \n\t__u32 dropped_frames_no_route;\t \n};\n\n#define PREQ_Q_F_START\t\t0x1\n#define PREQ_Q_F_REFRESH\t0x2\nstruct mesh_preq_queue {\n\tstruct list_head list;\n\tu8 dst[ETH_ALEN];\n\tu8 flags;\n};\n\nstruct ieee80211_roc_work {\n\tstruct list_head list;\n\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tstruct ieee80211_channel *chan;\n\n\tbool started, abort, hw_begun, notified;\n\tbool on_channel;\n\n\tunsigned long start_time;\n\n\tu32 duration, req_duration;\n\tstruct sk_buff *frame;\n\tu64 cookie, mgmt_tx_cookie;\n\tenum ieee80211_roc_type type;\n};\n\n \nenum ieee80211_sta_flags {\n\tIEEE80211_STA_CONNECTION_POLL\t= BIT(1),\n\tIEEE80211_STA_CONTROL_PORT\t= BIT(2),\n\tIEEE80211_STA_MFP_ENABLED\t= BIT(6),\n\tIEEE80211_STA_UAPSD_ENABLED\t= BIT(7),\n\tIEEE80211_STA_NULLFUNC_ACKED\t= BIT(8),\n\tIEEE80211_STA_ENABLE_RRM\t= BIT(15),\n};\n\ntypedef u32 __bitwise ieee80211_conn_flags_t;\n\nenum ieee80211_conn_flags {\n\tIEEE80211_CONN_DISABLE_HT\t= (__force ieee80211_conn_flags_t)BIT(0),\n\tIEEE80211_CONN_DISABLE_40MHZ\t= (__force ieee80211_conn_flags_t)BIT(1),\n\tIEEE80211_CONN_DISABLE_VHT\t= (__force ieee80211_conn_flags_t)BIT(2),\n\tIEEE80211_CONN_DISABLE_80P80MHZ\t= (__force ieee80211_conn_flags_t)BIT(3),\n\tIEEE80211_CONN_DISABLE_160MHZ\t= (__force ieee80211_conn_flags_t)BIT(4),\n\tIEEE80211_CONN_DISABLE_HE\t= (__force ieee80211_conn_flags_t)BIT(5),\n\tIEEE80211_CONN_DISABLE_EHT\t= (__force ieee80211_conn_flags_t)BIT(6),\n\tIEEE80211_CONN_DISABLE_320MHZ\t= (__force ieee80211_conn_flags_t)BIT(7),\n};\n\nstruct ieee80211_mgd_auth_data {\n\tstruct cfg80211_bss *bss;\n\tunsigned long timeout;\n\tint tries;\n\tu16 algorithm, expected_transaction;\n\n\tu8 key[WLAN_KEY_LEN_WEP104];\n\tu8 key_len, key_idx;\n\tbool done, waiting;\n\tbool peer_confirmed;\n\tbool timeout_started;\n\tint link_id;\n\n\tu8 ap_addr[ETH_ALEN] __aligned(2);\n\n\tu16 sae_trans, sae_status;\n\tsize_t data_len;\n\tu8 data[];\n};\n\nstruct ieee80211_mgd_assoc_data {\n\tstruct {\n\t\tstruct cfg80211_bss *bss;\n\n\t\tu8 addr[ETH_ALEN] __aligned(2);\n\n\t\tu8 ap_ht_param;\n\n\t\tstruct ieee80211_vht_cap ap_vht_cap;\n\n\t\tsize_t elems_len;\n\t\tu8 *elems;  \n\n\t\tieee80211_conn_flags_t conn_flags;\n\n\t\tu16 status;\n\n\t\tbool disabled;\n\t} link[IEEE80211_MLD_MAX_NUM_LINKS];\n\n\tu8 ap_addr[ETH_ALEN] __aligned(2);\n\n\t \n\tconst u8 *supp_rates;\n\tu8 supp_rates_len;\n\n\tunsigned long timeout;\n\tint tries;\n\n\tu8 prev_ap_addr[ETH_ALEN];\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tu8 ssid_len;\n\tbool wmm, uapsd;\n\tbool need_beacon;\n\tbool synced;\n\tbool timeout_started;\n\tbool s1g;\n\n\tunsigned int assoc_link_id;\n\n\tu8 fils_nonces[2 * FILS_NONCE_LEN];\n\tu8 fils_kek[FILS_MAX_KEK_LEN];\n\tsize_t fils_kek_len;\n\n\tsize_t ie_len;\n\tu8 *ie_pos;  \n\tu8 ie[];\n};\n\nstruct ieee80211_sta_tx_tspec {\n\t \n\tunsigned long time_slice_start;\n\n\tu32 admitted_time;  \n\tu8 tsid;\n\ts8 up;  \n\n\t \n\tu32 consumed_tx_time;\n\tenum {\n\t\tTX_TSPEC_ACTION_NONE = 0,\n\t\tTX_TSPEC_ACTION_DOWNGRADE,\n\t\tTX_TSPEC_ACTION_STOP_DOWNGRADE,\n\t} action;\n\tbool downgraded;\n};\n\nDECLARE_EWMA(beacon_signal, 4, 4)\n\nstruct ieee80211_if_managed {\n\tstruct timer_list timer;\n\tstruct timer_list conn_mon_timer;\n\tstruct timer_list bcn_mon_timer;\n\tstruct work_struct monitor_work;\n\tstruct wiphy_work beacon_connection_loss_work;\n\tstruct wiphy_work csa_connection_drop_work;\n\n\tunsigned long beacon_timeout;\n\tunsigned long probe_timeout;\n\tint probe_send_count;\n\tbool nullfunc_failed;\n\tu8 connection_loss:1,\n\t   driver_disconnect:1,\n\t   reconnect:1,\n\t   associated:1;\n\n\tstruct ieee80211_mgd_auth_data *auth_data;\n\tstruct ieee80211_mgd_assoc_data *assoc_data;\n\n\tbool powersave;  \n\tbool broken_ap;  \n\n\tunsigned int flags;\n\n\tbool status_acked;\n\tbool status_received;\n\t__le16 status_fc;\n\n\tenum {\n\t\tIEEE80211_MFP_DISABLED,\n\t\tIEEE80211_MFP_OPTIONAL,\n\t\tIEEE80211_MFP_REQUIRED\n\t} mfp;  \n\n\t \n\tunsigned int uapsd_queues;\n\n\t \n\tunsigned int uapsd_max_sp_len;\n\n\tu8 use_4addr;\n\n\t \n\tint rssi_min_thold, rssi_max_thold;\n\n\tstruct ieee80211_ht_cap ht_capa;  \n\tstruct ieee80211_ht_cap ht_capa_mask;  \n\tstruct ieee80211_vht_cap vht_capa;  \n\tstruct ieee80211_vht_cap vht_capa_mask;  \n\tstruct ieee80211_s1g_cap s1g_capa;  \n\tstruct ieee80211_s1g_cap s1g_capa_mask;  \n\n\t \n\tu8 tdls_peer[ETH_ALEN] __aligned(2);\n\tstruct delayed_work tdls_peer_del_work;\n\tstruct sk_buff *orig_teardown_skb;  \n\tstruct sk_buff *teardown_skb;  \n\tspinlock_t teardown_lock;  \n\tbool tdls_wider_bw_prohibited;\n\n\t \n\tstruct ieee80211_sta_tx_tspec tx_tspec[IEEE80211_NUM_ACS];\n\t \n\tstruct delayed_work tx_tspec_wk;\n\n\t \n\tu8 *assoc_req_ies;\n\tsize_t assoc_req_ies_len;\n\n\tstruct wiphy_delayed_work ml_reconf_work;\n\tu16 removed_links;\n};\n\nstruct ieee80211_if_ibss {\n\tstruct timer_list timer;\n\tstruct wiphy_work csa_connection_drop_work;\n\n\tunsigned long last_scan_completed;\n\n\tu32 basic_rates;\n\n\tbool fixed_bssid;\n\tbool fixed_channel;\n\tbool privacy;\n\n\tbool control_port;\n\tbool userspace_handles_dfs;\n\n\tu8 bssid[ETH_ALEN] __aligned(2);\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tu8 ssid_len, ie_len;\n\tu8 *ie;\n\tstruct cfg80211_chan_def chandef;\n\n\tunsigned long ibss_join_req;\n\t \n\tstruct beacon_data __rcu *presp;\n\n\tstruct ieee80211_ht_cap ht_capa;  \n\tstruct ieee80211_ht_cap ht_capa_mask;  \n\n\tspinlock_t incomplete_lock;\n\tstruct list_head incomplete_stations;\n\n\tenum {\n\t\tIEEE80211_IBSS_MLME_SEARCH,\n\t\tIEEE80211_IBSS_MLME_JOINED,\n\t} state;\n};\n\n \nstruct ieee80211_if_ocb {\n\tstruct timer_list housekeeping_timer;\n\tunsigned long wrkq_flags;\n\n\tspinlock_t incomplete_lock;\n\tstruct list_head incomplete_stations;\n\n\tbool joined;\n};\n\n \nstruct ieee802_11_elems;\nstruct ieee80211_mesh_sync_ops {\n\tvoid (*rx_bcn_presp)(struct ieee80211_sub_if_data *sdata, u16 stype,\n\t\t\t     struct ieee80211_mgmt *mgmt, unsigned int len,\n\t\t\t     const struct ieee80211_meshconf_ie *mesh_cfg,\n\t\t\t     struct ieee80211_rx_status *rx_status);\n\n\t \n\tvoid (*adjust_tsf)(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct beacon_data *beacon);\n\t \n};\n\nstruct mesh_csa_settings {\n\tstruct rcu_head rcu_head;\n\tstruct cfg80211_csa_settings settings;\n};\n\n \nstruct mesh_table {\n\tstruct hlist_head known_gates;\n\tspinlock_t gates_lock;\n\tstruct rhashtable rhead;\n\tstruct hlist_head walk_head;\n\tspinlock_t walk_lock;\n\tatomic_t entries;\t\t \n};\n\n \nstruct mesh_tx_cache {\n\tstruct rhashtable rht;\n\tstruct hlist_head walk_head;\n\tspinlock_t walk_lock;\n};\n\nstruct ieee80211_if_mesh {\n\tstruct timer_list housekeeping_timer;\n\tstruct timer_list mesh_path_timer;\n\tstruct timer_list mesh_path_root_timer;\n\n\tunsigned long wrkq_flags;\n\tunsigned long mbss_changed[64 / BITS_PER_LONG];\n\n\tbool userspace_handles_dfs;\n\n\tu8 mesh_id[IEEE80211_MAX_MESH_ID_LEN];\n\tsize_t mesh_id_len;\n\t \n\tu8 mesh_pp_id;\n\t \n\tu8 mesh_pm_id;\n\t \n\tu8 mesh_cc_id;\n\t \n\tu8 mesh_sp_id;\n\t \n\tu8 mesh_auth_id;\n\t \n\tu32 sn;\n\t \n\tu32 preq_id;\n\tatomic_t mpaths;\n\t \n\tunsigned long last_sn_update;\n\t \n\tunsigned long next_perr;\n\t \n\tunsigned long last_preq;\n\tstruct mesh_rmc *rmc;\n\tspinlock_t mesh_preq_queue_lock;\n\tstruct mesh_preq_queue preq_queue;\n\tint preq_queue_len;\n\tstruct mesh_stats mshstats;\n\tstruct mesh_config mshcfg;\n\tatomic_t estab_plinks;\n\tatomic_t mesh_seqnum;\n\tbool accepting_plinks;\n\tint num_gates;\n\tstruct beacon_data __rcu *beacon;\n\tconst u8 *ie;\n\tu8 ie_len;\n\tenum {\n\t\tIEEE80211_MESH_SEC_NONE = 0x0,\n\t\tIEEE80211_MESH_SEC_AUTHED = 0x1,\n\t\tIEEE80211_MESH_SEC_SECURED = 0x2,\n\t} security;\n\tbool user_mpm;\n\t \n\tconst struct ieee80211_mesh_sync_ops *sync_ops;\n\ts64 sync_offset_clockdrift_max;\n\tspinlock_t sync_offset_lock;\n\t \n\tenum nl80211_mesh_power_mode nonpeer_pm;\n\tint ps_peers_light_sleep;\n\tint ps_peers_deep_sleep;\n\tstruct ps_data ps;\n\t \n\tstruct mesh_csa_settings __rcu *csa;\n\tenum {\n\t\tIEEE80211_MESH_CSA_ROLE_NONE,\n\t\tIEEE80211_MESH_CSA_ROLE_INIT,\n\t\tIEEE80211_MESH_CSA_ROLE_REPEATER,\n\t} csa_role;\n\tu8 chsw_ttl;\n\tu16 pre_value;\n\n\t \n\tint meshconf_offset;\n\n\tstruct mesh_table mesh_paths;\n\tstruct mesh_table mpp_paths;  \n\tint mesh_paths_generation;\n\tint mpp_paths_generation;\n\tstruct mesh_tx_cache tx_cache;\n};\n\n#ifdef CONFIG_MAC80211_MESH\n#define IEEE80211_IFSTA_MESH_CTR_INC(msh, name)\t\\\n\tdo { (msh)->mshstats.name++; } while (0)\n#else\n#define IEEE80211_IFSTA_MESH_CTR_INC(msh, name) \\\n\tdo { } while (0)\n#endif\n\n \nenum ieee80211_sub_if_data_flags {\n\tIEEE80211_SDATA_ALLMULTI\t\t= BIT(0),\n\tIEEE80211_SDATA_DONT_BRIDGE_PACKETS\t= BIT(3),\n\tIEEE80211_SDATA_DISCONNECT_RESUME\t= BIT(4),\n\tIEEE80211_SDATA_IN_DRIVER\t\t= BIT(5),\n\tIEEE80211_SDATA_DISCONNECT_HW_RESTART\t= BIT(6),\n};\n\n \nenum ieee80211_sdata_state_bits {\n\tSDATA_STATE_RUNNING,\n\tSDATA_STATE_OFFCHANNEL,\n\tSDATA_STATE_OFFCHANNEL_BEACON_STOPPED,\n};\n\n \nenum ieee80211_chanctx_mode {\n\tIEEE80211_CHANCTX_SHARED,\n\tIEEE80211_CHANCTX_EXCLUSIVE\n};\n\n \nenum ieee80211_chanctx_replace_state {\n\tIEEE80211_CHANCTX_REPLACE_NONE,\n\tIEEE80211_CHANCTX_WILL_BE_REPLACED,\n\tIEEE80211_CHANCTX_REPLACES_OTHER,\n};\n\nstruct ieee80211_chanctx {\n\tstruct list_head list;\n\tstruct rcu_head rcu_head;\n\n\tstruct list_head assigned_links;\n\tstruct list_head reserved_links;\n\n\tenum ieee80211_chanctx_replace_state replace_state;\n\tstruct ieee80211_chanctx *replace_ctx;\n\n\tenum ieee80211_chanctx_mode mode;\n\tbool driver_present;\n\n\tstruct ieee80211_chanctx_conf conf;\n};\n\nstruct mac80211_qos_map {\n\tstruct cfg80211_qos_map qos_map;\n\tstruct rcu_head rcu_head;\n};\n\nenum txq_info_flags {\n\tIEEE80211_TXQ_STOP,\n\tIEEE80211_TXQ_AMPDU,\n\tIEEE80211_TXQ_NO_AMSDU,\n\tIEEE80211_TXQ_DIRTY,\n};\n\n \nstruct txq_info {\n\tstruct fq_tin tin;\n\tstruct codel_vars def_cvars;\n\tstruct codel_stats cstats;\n\n\tu16 schedule_round;\n\tstruct list_head schedule_order;\n\n\tstruct sk_buff_head frags;\n\n\tunsigned long flags;\n\n\t \n\tstruct ieee80211_txq txq;\n};\n\nstruct ieee80211_if_mntr {\n\tu32 flags;\n\tu8 mu_follow_addr[ETH_ALEN] __aligned(2);\n\n\tstruct list_head list;\n};\n\n \nstruct ieee80211_if_nan {\n\tstruct cfg80211_nan_conf conf;\n\n\t \n\tspinlock_t func_lock;\n\tstruct idr function_inst_ids;\n};\n\nstruct ieee80211_link_data_managed {\n\tu8 bssid[ETH_ALEN] __aligned(2);\n\n\tu8 dtim_period;\n\tenum ieee80211_smps_mode req_smps,  \n\t\t\t\t driver_smps_mode;  \n\n\tieee80211_conn_flags_t conn_flags;\n\n\ts16 p2p_noa_index;\n\n\tbool tdls_chan_switch_prohibited;\n\n\tbool have_beacon;\n\tbool tracking_signal_avg;\n\tbool disable_wmm_tracking;\n\tbool operating_11g_mode;\n\n\tbool csa_waiting_bcn;\n\tbool csa_ignored_same_chan;\n\tstruct wiphy_delayed_work chswitch_work;\n\n\tstruct wiphy_work request_smps_work;\n\tbool beacon_crc_valid;\n\tu32 beacon_crc;\n\tstruct ewma_beacon_signal ave_beacon_signal;\n\tint last_ave_beacon_signal;\n\n\t \n\tunsigned int count_beacon_signal;\n\n\t \n\tunsigned int beacon_loss_count;\n\n\t \n\tint last_cqm_event_signal;\n\n\tint wmm_last_param_set;\n\tint mu_edca_last_param_set;\n\n\tu8 bss_param_ch_cnt;\n\n\tstruct cfg80211_bss *bss;\n};\n\nstruct ieee80211_link_data_ap {\n\tstruct beacon_data __rcu *beacon;\n\tstruct probe_resp __rcu *probe_resp;\n\tstruct fils_discovery_data __rcu *fils_discovery;\n\tstruct unsol_bcast_probe_resp_data __rcu *unsol_bcast_probe_resp;\n\n\t \n\tstruct cfg80211_beacon_data *next_beacon;\n};\n\nstruct ieee80211_link_data {\n\tstruct ieee80211_sub_if_data *sdata;\n\tunsigned int link_id;\n\n\tstruct list_head assigned_chanctx_list;  \n\tstruct list_head reserved_chanctx_list;  \n\n\t \n\tstruct ieee80211_key __rcu *gtk[NUM_DEFAULT_KEYS +\n\t\t\t\t\tNUM_DEFAULT_MGMT_KEYS +\n\t\t\t\t\tNUM_DEFAULT_BEACON_KEYS];\n\tstruct ieee80211_key __rcu *default_multicast_key;\n\tstruct ieee80211_key __rcu *default_mgmt_key;\n\tstruct ieee80211_key __rcu *default_beacon_key;\n\n\tstruct work_struct csa_finalize_work;\n\tbool csa_block_tx;  \n\n\tbool operating_11g_mode;\n\n\tstruct cfg80211_chan_def csa_chandef;\n\n\tstruct work_struct color_change_finalize_work;\n\tstruct delayed_work color_collision_detect_work;\n\tu64 color_bitmap;\n\n\t \n\tstruct ieee80211_chanctx *reserved_chanctx;\n\tstruct cfg80211_chan_def reserved_chandef;\n\tbool reserved_radar_required;\n\tbool reserved_ready;\n\n\tu8 needed_rx_chains;\n\tenum ieee80211_smps_mode smps_mode;\n\n\tint user_power_level;  \n\tint ap_power_level;  \n\n\tbool radar_required;\n\tstruct delayed_work dfs_cac_timer_work;\n\n\tunion {\n\t\tstruct ieee80211_link_data_managed mgd;\n\t\tstruct ieee80211_link_data_ap ap;\n\t} u;\n\n\tstruct ieee80211_tx_queue_params tx_conf[IEEE80211_NUM_ACS];\n\n\tstruct ieee80211_bss_conf *conf;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct dentry *debugfs_dir;\n#endif\n};\n\nstruct ieee80211_sub_if_data {\n\tstruct list_head list;\n\n\tstruct wireless_dev wdev;\n\n\t \n\tstruct list_head key_list;\n\n\t \n\tint crypto_tx_tailroom_needed_cnt;\n\tint crypto_tx_tailroom_pending_dec;\n\tstruct delayed_work dec_tailroom_needed_wk;\n\n\tstruct net_device *dev;\n\tstruct ieee80211_local *local;\n\n\tunsigned int flags;\n\n\tunsigned long state;\n\n\tchar name[IFNAMSIZ];\n\n\tstruct ieee80211_fragment_cache frags;\n\n\t \n\tu16 noack_map;\n\n\t \n\tu8 wmm_acm;\n\n\tstruct ieee80211_key __rcu *keys[NUM_DEFAULT_KEYS];\n\tstruct ieee80211_key __rcu *default_unicast_key;\n\n\tu16 sequence_number;\n\tu16 mld_mcast_seq;\n\t__be16 control_port_protocol;\n\tbool control_port_no_encrypt;\n\tbool control_port_no_preauth;\n\tbool control_port_over_nl80211;\n\n\tatomic_t num_tx_queued;\n\tstruct mac80211_qos_map __rcu *qos_map;\n\n\t \n\tstruct work_struct recalc_smps;\n\n\tstruct wiphy_work work;\n\tstruct sk_buff_head skb_queue;\n\tstruct sk_buff_head status_queue;\n\n\t \n\tstruct ieee80211_if_ap *bss;\n\n\t \n\tu32 rc_rateidx_mask[NUM_NL80211_BANDS];\n\n\tbool rc_has_mcs_mask[NUM_NL80211_BANDS];\n\tu8  rc_rateidx_mcs_mask[NUM_NL80211_BANDS][IEEE80211_HT_MCS_MASK_LEN];\n\n\tbool rc_has_vht_mcs_mask[NUM_NL80211_BANDS];\n\tu16 rc_rateidx_vht_mcs_mask[NUM_NL80211_BANDS][NL80211_VHT_NSS_MAX];\n\n\t \n\tu32 beacon_rateidx_mask[NUM_NL80211_BANDS];\n\tbool beacon_rate_set;\n\n\tunion {\n\t\tstruct ieee80211_if_ap ap;\n\t\tstruct ieee80211_if_vlan vlan;\n\t\tstruct ieee80211_if_managed mgd;\n\t\tstruct ieee80211_if_ibss ibss;\n\t\tstruct ieee80211_if_mesh mesh;\n\t\tstruct ieee80211_if_ocb ocb;\n\t\tstruct ieee80211_if_mntr mntr;\n\t\tstruct ieee80211_if_nan nan;\n\t} u;\n\n\tstruct ieee80211_link_data deflink;\n\tstruct ieee80211_link_data __rcu *link[IEEE80211_MLD_MAX_NUM_LINKS];\n\n\t \n\tstruct work_struct activate_links_work;\n\tu16 desired_active_links;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct {\n\t\tstruct dentry *subdir_stations;\n\t\tstruct dentry *default_unicast_key;\n\t\tstruct dentry *default_multicast_key;\n\t\tstruct dentry *default_mgmt_key;\n\t\tstruct dentry *default_beacon_key;\n\t} debugfs;\n#endif\n\n\t \n\tstruct ieee80211_vif vif;\n};\n\nstatic inline\nstruct ieee80211_sub_if_data *vif_to_sdata(struct ieee80211_vif *p)\n{\n\treturn container_of(p, struct ieee80211_sub_if_data, vif);\n}\n\nstatic inline void sdata_lock(struct ieee80211_sub_if_data *sdata)\n\t__acquires(&sdata->wdev.mtx)\n{\n\tmutex_lock(&sdata->wdev.mtx);\n\t__acquire(&sdata->wdev.mtx);\n}\n\nstatic inline void sdata_unlock(struct ieee80211_sub_if_data *sdata)\n\t__releases(&sdata->wdev.mtx)\n{\n\tmutex_unlock(&sdata->wdev.mtx);\n\t__release(&sdata->wdev.mtx);\n}\n\n#define sdata_dereference(p, sdata) \\\n\trcu_dereference_protected(p, lockdep_is_held(&sdata->wdev.mtx))\n\nstatic inline void\nsdata_assert_lock(struct ieee80211_sub_if_data *sdata)\n{\n\tlockdep_assert_held(&sdata->wdev.mtx);\n}\n\nstatic inline int\nieee80211_chanwidth_get_shift(enum nl80211_chan_width width)\n{\n\tswitch (width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\t\treturn 2;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline int\nieee80211_chandef_get_shift(struct cfg80211_chan_def *chandef)\n{\n\treturn ieee80211_chanwidth_get_shift(chandef->width);\n}\n\nstatic inline int\nieee80211_vif_get_shift(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tint shift = 0;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(vif->bss_conf.chanctx_conf);\n\tif (chanctx_conf)\n\t\tshift = ieee80211_chandef_get_shift(&chanctx_conf->def);\n\trcu_read_unlock();\n\n\treturn shift;\n}\n\nstatic inline int\nieee80211_get_mbssid_beacon_len(struct cfg80211_mbssid_elems *elems,\n\t\t\t\tstruct cfg80211_rnr_elems *rnr_elems,\n\t\t\t\tu8 i)\n{\n\tint len = 0;\n\n\tif (!elems || !elems->cnt || i > elems->cnt)\n\t\treturn 0;\n\n\tif (i < elems->cnt) {\n\t\tlen = elems->elem[i].len;\n\t\tif (rnr_elems) {\n\t\t\tlen += rnr_elems->elem[i].len;\n\t\t\tfor (i = elems->cnt; i < rnr_elems->cnt; i++)\n\t\t\t\tlen += rnr_elems->elem[i].len;\n\t\t}\n\t\treturn len;\n\t}\n\n\t \n\tfor (i = 0; i < elems->cnt; i++)\n\t\tlen += elems->elem[i].len;\n\n\tif (rnr_elems) {\n\t\tfor (i = 0; i < rnr_elems->cnt; i++)\n\t\t\tlen += rnr_elems->elem[i].len;\n\t}\n\n\treturn len;\n}\n\nenum {\n\tIEEE80211_RX_MSG\t= 1,\n\tIEEE80211_TX_STATUS_MSG\t= 2,\n};\n\nenum queue_stop_reason {\n\tIEEE80211_QUEUE_STOP_REASON_DRIVER,\n\tIEEE80211_QUEUE_STOP_REASON_PS,\n\tIEEE80211_QUEUE_STOP_REASON_CSA,\n\tIEEE80211_QUEUE_STOP_REASON_AGGREGATION,\n\tIEEE80211_QUEUE_STOP_REASON_SUSPEND,\n\tIEEE80211_QUEUE_STOP_REASON_SKB_ADD,\n\tIEEE80211_QUEUE_STOP_REASON_OFFCHANNEL,\n\tIEEE80211_QUEUE_STOP_REASON_FLUSH,\n\tIEEE80211_QUEUE_STOP_REASON_TDLS_TEARDOWN,\n\tIEEE80211_QUEUE_STOP_REASON_RESERVE_TID,\n\tIEEE80211_QUEUE_STOP_REASON_IFTYPE_CHANGE,\n\n\tIEEE80211_QUEUE_STOP_REASONS,\n};\n\n#ifdef CONFIG_MAC80211_LEDS\nstruct tpt_led_trigger {\n\tchar name[32];\n\tconst struct ieee80211_tpt_blink *blink_table;\n\tunsigned int blink_table_len;\n\tstruct timer_list timer;\n\tstruct ieee80211_local *local;\n\tunsigned long prev_traffic;\n\tunsigned long tx_bytes, rx_bytes;\n\tunsigned int active, want;\n\tbool running;\n};\n#endif\n\n \nenum {\n\tSCAN_SW_SCANNING,\n\tSCAN_HW_SCANNING,\n\tSCAN_ONCHANNEL_SCANNING,\n\tSCAN_COMPLETED,\n\tSCAN_ABORTED,\n\tSCAN_HW_CANCELLED,\n\tSCAN_BEACON_WAIT,\n\tSCAN_BEACON_DONE,\n};\n\n \nenum mac80211_scan_state {\n\tSCAN_DECISION,\n\tSCAN_SET_CHANNEL,\n\tSCAN_SEND_PROBE,\n\tSCAN_SUSPEND,\n\tSCAN_RESUME,\n\tSCAN_ABORT,\n};\n\nDECLARE_STATIC_KEY_FALSE(aql_disable);\n\nstruct ieee80211_local {\n\t \n\tstruct ieee80211_hw hw;\n\n\tstruct fq fq;\n\tstruct codel_vars *cvars;\n\tstruct codel_params cparams;\n\n\t \n\tspinlock_t active_txq_lock[IEEE80211_NUM_ACS];\n\tstruct list_head active_txqs[IEEE80211_NUM_ACS];\n\tu16 schedule_round[IEEE80211_NUM_ACS];\n\n\t \n\tspinlock_t handle_wake_tx_queue_lock;\n\n\tu16 airtime_flags;\n\tu32 aql_txq_limit_low[IEEE80211_NUM_ACS];\n\tu32 aql_txq_limit_high[IEEE80211_NUM_ACS];\n\tu32 aql_threshold;\n\tatomic_t aql_total_pending_airtime;\n\tatomic_t aql_ac_pending_airtime[IEEE80211_NUM_ACS];\n\n\tconst struct ieee80211_ops *ops;\n\n\t \n\tstruct workqueue_struct *workqueue;\n\n\tunsigned long queue_stop_reasons[IEEE80211_MAX_QUEUES];\n\tint q_stop_reasons[IEEE80211_MAX_QUEUES][IEEE80211_QUEUE_STOP_REASONS];\n\t \n\tspinlock_t queue_stop_reason_lock;\n\n\tint open_count;\n\tint monitors, cooked_mntrs;\n\t \n\tint fif_fcsfail, fif_plcpfail, fif_control, fif_other_bss, fif_pspoll,\n\t    fif_probe_req;\n\tbool probe_req_reg;\n\tbool rx_mcast_action_reg;\n\tunsigned int filter_flags;  \n\n\tbool wiphy_ciphers_allocated;\n\n\tbool use_chanctx;\n\n\t \n\tspinlock_t filter_lock;\n\n\t \n\tstruct work_struct reconfig_filter;\n\n\t \n\tstruct netdev_hw_addr_list mc_list;\n\n\tbool tim_in_locked_section;  \n\n\t \n\tbool suspended;\n\n\t \n\tbool suspending;\n\n\t \n\tbool resuming;\n\n\t \n\tbool quiescing;\n\n\t \n\tbool started;\n\n\t \n\tbool in_reconfig;\n\n\t \n\tbool reconfig_failure;\n\n\t \n\tbool wowlan;\n\n\tstruct wiphy_work radar_detected_work;\n\n\t \n\tu8 rx_chains;\n\n\t \n\tu8 sband_allocated;\n\n\tint tx_headroom;  \n\n\t \n#define IEEE80211_IRQSAFE_QUEUE_LIMIT 128\n\tstruct tasklet_struct tasklet;\n\tstruct sk_buff_head skb_queue;\n\tstruct sk_buff_head skb_queue_unreliable;\n\n\tspinlock_t rx_path_lock;\n\n\t \n\t \n\tstruct mutex sta_mtx;\n\tspinlock_t tim_lock;\n\tunsigned long num_sta;\n\tstruct list_head sta_list;\n\tstruct rhltable sta_hash;\n\tstruct rhltable link_sta_hash;\n\tstruct timer_list sta_cleanup;\n\tint sta_generation;\n\n\tstruct sk_buff_head pending[IEEE80211_MAX_QUEUES];\n\tstruct tasklet_struct tx_pending_tasklet;\n\tstruct tasklet_struct wake_txqs_tasklet;\n\n\tatomic_t agg_queue_stop[IEEE80211_MAX_QUEUES];\n\n\t \n\tatomic_t iff_allmultis;\n\n\tstruct rate_control_ref *rate_ctrl;\n\n\tstruct arc4_ctx wep_tx_ctx;\n\tstruct arc4_ctx wep_rx_ctx;\n\tu32 wep_iv;\n\n\t \n\tstruct list_head interfaces;\n\tstruct list_head mon_list;  \n\tstruct mutex iflist_mtx;\n\n\t \n\tstruct mutex key_mtx;\n\n\t \n\tstruct mutex mtx;\n\n\t \n\tunsigned long scanning;\n\tstruct cfg80211_ssid scan_ssid;\n\tstruct cfg80211_scan_request *int_scan_req;\n\tstruct cfg80211_scan_request __rcu *scan_req;\n\tstruct ieee80211_scan_request *hw_scan_req;\n\tstruct cfg80211_chan_def scan_chandef;\n\tenum nl80211_band hw_scan_band;\n\tint scan_channel_idx;\n\tint scan_ies_len;\n\tint hw_scan_ies_bufsize;\n\tstruct cfg80211_scan_info scan_info;\n\n\tstruct wiphy_work sched_scan_stopped_work;\n\tstruct ieee80211_sub_if_data __rcu *sched_scan_sdata;\n\tstruct cfg80211_sched_scan_request __rcu *sched_scan_req;\n\tu8 scan_addr[ETH_ALEN];\n\n\tunsigned long leave_oper_channel_time;\n\tenum mac80211_scan_state next_scan_state;\n\tstruct wiphy_delayed_work scan_work;\n\tstruct ieee80211_sub_if_data __rcu *scan_sdata;\n\t \n\tstruct cfg80211_chan_def _oper_chandef;\n\n\t \n\tstruct ieee80211_channel *tmp_channel;\n\n\t \n\tstruct list_head chanctx_list;\n\tstruct mutex chanctx_mtx;\n\n#ifdef CONFIG_MAC80211_LEDS\n\tstruct led_trigger tx_led, rx_led, assoc_led, radio_led;\n\tstruct led_trigger tpt_led;\n\tatomic_t tx_led_active, rx_led_active, assoc_led_active;\n\tatomic_t radio_led_active, tpt_led_active;\n\tstruct tpt_led_trigger *tpt_led_trigger;\n#endif\n\n#ifdef CONFIG_MAC80211_DEBUG_COUNTERS\n\t \n\t \n\tu32 dot11TransmittedFragmentCount;\n\tu32 dot11MulticastTransmittedFrameCount;\n\tu32 dot11FailedCount;\n\tu32 dot11RetryCount;\n\tu32 dot11MultipleRetryCount;\n\tu32 dot11FrameDuplicateCount;\n\tu32 dot11ReceivedFragmentCount;\n\tu32 dot11MulticastReceivedFrameCount;\n\tu32 dot11TransmittedFrameCount;\n\n\t \n\tunsigned int tx_handlers_drop;\n\tunsigned int tx_handlers_queued;\n\tunsigned int tx_handlers_drop_wep;\n\tunsigned int tx_handlers_drop_not_assoc;\n\tunsigned int tx_handlers_drop_unauth_port;\n\tunsigned int rx_handlers_drop;\n\tunsigned int rx_handlers_queued;\n\tunsigned int rx_handlers_drop_nullfunc;\n\tunsigned int rx_handlers_drop_defrag;\n\tunsigned int tx_expand_skb_head;\n\tunsigned int tx_expand_skb_head_cloned;\n\tunsigned int rx_expand_skb_head_defrag;\n\tunsigned int rx_handlers_fragments;\n\tunsigned int tx_status_drop;\n#define I802_DEBUG_INC(c) (c)++\n#else  \n#define I802_DEBUG_INC(c) do { } while (0)\n#endif  \n\n\n\tint total_ps_buffered;  \n\n\tbool pspolling;\n\t \n\tstruct ieee80211_sub_if_data *ps_sdata;\n\tstruct work_struct dynamic_ps_enable_work;\n\tstruct work_struct dynamic_ps_disable_work;\n\tstruct timer_list dynamic_ps_timer;\n\tstruct notifier_block ifa_notifier;\n\tstruct notifier_block ifa6_notifier;\n\n\t \n\tint dynamic_ps_forced_timeout;\n\n\tint user_power_level;  \n\n\tenum ieee80211_smps_mode smps_mode;\n\n\tstruct work_struct restart_work;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tstruct local_debugfsdentries {\n\t\tstruct dentry *rcdir;\n\t\tstruct dentry *keys;\n\t} debugfs;\n\tbool force_tx_status;\n#endif\n\n\t \n\tstruct wiphy_delayed_work roc_work;\n\tstruct list_head roc_list;\n\tstruct wiphy_work hw_roc_start, hw_roc_done;\n\tunsigned long hw_roc_start_time;\n\tu64 roc_cookie_counter;\n\n\tstruct idr ack_status_frames;\n\tspinlock_t ack_status_lock;\n\n\tstruct ieee80211_sub_if_data __rcu *p2p_sdata;\n\n\t \n\tstruct ieee80211_sub_if_data __rcu *monitor_sdata;\n\tstruct cfg80211_chan_def monitor_chandef;\n\n\t \n\tu8 ext_capa[8];\n};\n\nstatic inline struct ieee80211_sub_if_data *\nIEEE80211_DEV_TO_SUB_IF(const struct net_device *dev)\n{\n\treturn netdev_priv(dev);\n}\n\nstatic inline struct ieee80211_sub_if_data *\nIEEE80211_WDEV_TO_SUB_IF(struct wireless_dev *wdev)\n{\n\treturn container_of(wdev, struct ieee80211_sub_if_data, wdev);\n}\n\nstatic inline struct ieee80211_supported_band *\nieee80211_get_sband(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tenum nl80211_band band;\n\n\tWARN_ON(ieee80211_vif_is_mld(&sdata->vif));\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\n\tif (!chanctx_conf) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\n\tband = chanctx_conf->def.chan->band;\n\trcu_read_unlock();\n\n\treturn local->hw.wiphy->bands[band];\n}\n\nstatic inline struct ieee80211_supported_band *\nieee80211_get_link_sband(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_local *local = link->sdata->local;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tenum nl80211_band band;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(link->conf->chanctx_conf);\n\tif (!chanctx_conf) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\n\tband = chanctx_conf->def.chan->band;\n\trcu_read_unlock();\n\n\treturn local->hw.wiphy->bands[band];\n}\n\n \nstruct ieee80211_csa_ie {\n\tstruct cfg80211_chan_def chandef;\n\tu8 mode;\n\tu8 count;\n\tu8 ttl;\n\tu16 pre_value;\n\tu16 reason_code;\n\tu32 max_switch_time;\n};\n\n \nstruct ieee802_11_elems {\n\tconst u8 *ie_start;\n\tsize_t total_len;\n\tu32 crc;\n\n\t \n\tconst struct ieee80211_tdls_lnkie *lnk_id;\n\tconst struct ieee80211_ch_switch_timing *ch_sw_timing;\n\tconst u8 *ext_capab;\n\tconst u8 *ssid;\n\tconst u8 *supp_rates;\n\tconst u8 *ds_params;\n\tconst struct ieee80211_tim_ie *tim;\n\tconst u8 *rsn;\n\tconst u8 *rsnx;\n\tconst u8 *erp_info;\n\tconst u8 *ext_supp_rates;\n\tconst u8 *wmm_info;\n\tconst u8 *wmm_param;\n\tconst struct ieee80211_ht_cap *ht_cap_elem;\n\tconst struct ieee80211_ht_operation *ht_operation;\n\tconst struct ieee80211_vht_cap *vht_cap_elem;\n\tconst struct ieee80211_vht_operation *vht_operation;\n\tconst struct ieee80211_meshconf_ie *mesh_config;\n\tconst u8 *he_cap;\n\tconst struct ieee80211_he_operation *he_operation;\n\tconst struct ieee80211_he_spr *he_spr;\n\tconst struct ieee80211_mu_edca_param_set *mu_edca_param_set;\n\tconst struct ieee80211_he_6ghz_capa *he_6ghz_capa;\n\tconst struct ieee80211_tx_pwr_env *tx_pwr_env[IEEE80211_TPE_MAX_IE_COUNT];\n\tconst u8 *uora_element;\n\tconst u8 *mesh_id;\n\tconst u8 *peering;\n\tconst __le16 *awake_window;\n\tconst u8 *preq;\n\tconst u8 *prep;\n\tconst u8 *perr;\n\tconst struct ieee80211_rann_ie *rann;\n\tconst struct ieee80211_channel_sw_ie *ch_switch_ie;\n\tconst struct ieee80211_ext_chansw_ie *ext_chansw_ie;\n\tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n\tconst u8 *max_channel_switch_time;\n\tconst u8 *country_elem;\n\tconst u8 *pwr_constr_elem;\n\tconst u8 *cisco_dtpc_elem;\n\tconst struct ieee80211_timeout_interval_ie *timeout_int;\n\tconst u8 *opmode_notif;\n\tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n\tstruct ieee80211_mesh_chansw_params_ie *mesh_chansw_params_ie;\n\tconst struct ieee80211_bss_max_idle_period_ie *max_idle_period_ie;\n\tconst struct ieee80211_multiple_bssid_configuration *mbssid_config_ie;\n\tconst struct ieee80211_bssid_index *bssid_index;\n\tu8 max_bssid_indicator;\n\tu8 dtim_count;\n\tu8 dtim_period;\n\tconst struct ieee80211_addba_ext_ie *addba_ext_ie;\n\tconst struct ieee80211_s1g_cap *s1g_capab;\n\tconst struct ieee80211_s1g_oper_ie *s1g_oper;\n\tconst struct ieee80211_s1g_bcn_compat_ie *s1g_bcn_compat;\n\tconst struct ieee80211_aid_response_ie *aid_resp;\n\tconst struct ieee80211_eht_cap_elem *eht_cap;\n\tconst struct ieee80211_eht_operation *eht_operation;\n\tconst struct ieee80211_multi_link_elem *ml_basic;\n\tconst struct ieee80211_multi_link_elem *ml_reconf;\n\n\t \n\tu8 ext_capab_len;\n\tu8 ssid_len;\n\tu8 supp_rates_len;\n\tu8 tim_len;\n\tu8 rsn_len;\n\tu8 rsnx_len;\n\tu8 ext_supp_rates_len;\n\tu8 wmm_info_len;\n\tu8 wmm_param_len;\n\tu8 he_cap_len;\n\tu8 mesh_id_len;\n\tu8 peering_len;\n\tu8 preq_len;\n\tu8 prep_len;\n\tu8 perr_len;\n\tu8 country_elem_len;\n\tu8 bssid_index_len;\n\tu8 tx_pwr_env_len[IEEE80211_TPE_MAX_IE_COUNT];\n\tu8 tx_pwr_env_num;\n\tu8 eht_cap_len;\n\n\t \n\tsize_t ml_basic_len;\n\tsize_t ml_reconf_len;\n\n\t \n\tconst struct element *ml_basic_elem;\n\n\t \n\tconst struct element *ml_reconf_elem;\n\n\t \n\tstruct ieee80211_mle_per_sta_profile *prof;\n\tsize_t sta_prof_len;\n\n\t \n\tbool parse_error;\n\n\t \n\tsize_t scratch_len;\n\tu8 *scratch_pos;\n\tu8 scratch[];\n};\n\nstatic inline struct ieee80211_local *hw_to_local(\n\tstruct ieee80211_hw *hw)\n{\n\treturn container_of(hw, struct ieee80211_local, hw);\n}\n\nstatic inline struct txq_info *to_txq_info(struct ieee80211_txq *txq)\n{\n\treturn container_of(txq, struct txq_info, txq);\n}\n\nstatic inline bool txq_has_queue(struct ieee80211_txq *txq)\n{\n\tstruct txq_info *txqi = to_txq_info(txq);\n\n\treturn !(skb_queue_empty(&txqi->frags) && !txqi->tin.backlog_packets);\n}\n\nstatic inline bool\nieee80211_have_rx_timestamp(struct ieee80211_rx_status *status)\n{\n\tWARN_ON_ONCE(status->flag & RX_FLAG_MACTIME_START &&\n\t\t     status->flag & RX_FLAG_MACTIME_END);\n\treturn !!(status->flag & (RX_FLAG_MACTIME_START | RX_FLAG_MACTIME_END |\n\t\t\t\t  RX_FLAG_MACTIME_PLCP_START));\n}\n\nvoid ieee80211_vif_inc_num_mcast(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_vif_dec_num_mcast(struct ieee80211_sub_if_data *sdata);\n\n \nstatic inline int\nieee80211_vif_get_num_mcast_if(struct ieee80211_sub_if_data *sdata)\n{\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\treturn atomic_read(&sdata->u.ap.num_mcast_sta);\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN && !sdata->u.vlan.sta)\n\t\treturn atomic_read(&sdata->u.vlan.num_mcast_sta);\n\treturn -1;\n}\n\nu64 ieee80211_calculate_rx_timestamp(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_rx_status *status,\n\t\t\t\t     unsigned int mpdu_len,\n\t\t\t\t     unsigned int mpdu_offset);\nint ieee80211_hw_config(struct ieee80211_local *local, u32 changed);\nvoid ieee80211_tx_set_protected(struct ieee80211_tx_data *tx);\nvoid ieee80211_bss_info_change_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      u64 changed);\nvoid ieee80211_vif_cfg_change_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     u64 changed);\nvoid ieee80211_link_info_change_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_link_data *link,\n\t\t\t\t       u64 changed);\nvoid ieee80211_configure_filter(struct ieee80211_local *local);\nu64 ieee80211_reset_erp_info(struct ieee80211_sub_if_data *sdata);\n\nu64 ieee80211_mgmt_tx_cookie(struct ieee80211_local *local);\nint ieee80211_attach_ack_skb(struct ieee80211_local *local, struct sk_buff *skb,\n\t\t\t     u64 *cookie, gfp_t gfp);\n\nvoid ieee80211_check_fast_rx(struct sta_info *sta);\nvoid __ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_clear_fast_rx(struct sta_info *sta);\n\nbool ieee80211_is_our_addr(struct ieee80211_sub_if_data *sdata,\n\t\t\t   const u8 *addr, int *out_link_id);\n\n \nvoid ieee80211_sta_setup_sdata(struct ieee80211_sub_if_data *sdata);\nint ieee80211_mgd_auth(struct ieee80211_sub_if_data *sdata,\n\t\t       struct cfg80211_auth_request *req);\nint ieee80211_mgd_assoc(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct cfg80211_assoc_request *req);\nint ieee80211_mgd_deauth(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct cfg80211_deauth_request *req);\nint ieee80211_mgd_disassoc(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct cfg80211_disassoc_request *req);\nvoid ieee80211_send_pspoll(struct ieee80211_local *local,\n\t\t\t   struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_recalc_ps(struct ieee80211_local *local);\nvoid ieee80211_recalc_ps_vif(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_sta_work(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_sta_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct sk_buff *skb);\nvoid ieee80211_sta_rx_queued_ext(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb);\nvoid ieee80211_sta_reset_beacon_monitor(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_sta_reset_conn_monitor(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_mgd_stop(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_mgd_conn_tx_status(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  __le16 fc, bool acked);\nvoid ieee80211_mgd_quiesce(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_sta_restart(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_sta_handle_tspec_ac_params(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_sta_connection_lost(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   u8 reason, bool tx);\nvoid ieee80211_mgd_setup_link(struct ieee80211_link_data *link);\nvoid ieee80211_mgd_stop_link(struct ieee80211_link_data *link);\nvoid ieee80211_mgd_set_link_qos_params(struct ieee80211_link_data *link);\n\n \nvoid ieee80211_ibss_notify_scan_completed(struct ieee80211_local *local);\nvoid ieee80211_ibss_setup_sdata(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_ibss_rx_no_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *bssid, const u8 *addr, u32 supp_rates);\nint ieee80211_ibss_join(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct cfg80211_ibss_params *params);\nint ieee80211_ibss_leave(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_ibss_work(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_ibss_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct sk_buff *skb);\nint ieee80211_ibss_csa_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct cfg80211_csa_settings *csa_settings,\n\t\t\t      u64 *changed);\nint ieee80211_ibss_finish_csa(struct ieee80211_sub_if_data *sdata,\n\t\t\t      u64 *changed);\nvoid ieee80211_ibss_stop(struct ieee80211_sub_if_data *sdata);\n\n \nvoid ieee80211_ocb_work(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_ocb_rx_no_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t     const u8 *bssid, const u8 *addr, u32 supp_rates);\nvoid ieee80211_ocb_setup_sdata(struct ieee80211_sub_if_data *sdata);\nint ieee80211_ocb_join(struct ieee80211_sub_if_data *sdata,\n\t\t       struct ocb_setup *setup);\nint ieee80211_ocb_leave(struct ieee80211_sub_if_data *sdata);\n\n \nvoid ieee80211_mesh_work(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_mesh_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct sk_buff *skb);\nint ieee80211_mesh_csa_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct cfg80211_csa_settings *csa_settings,\n\t\t\t      u64 *changed);\nint ieee80211_mesh_finish_csa(struct ieee80211_sub_if_data *sdata,\n\t\t\t      u64 *changed);\n\n \nvoid ieee80211_scan_work(struct wiphy *wiphy, struct wiphy_work *work);\nint ieee80211_request_ibss_scan(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *ssid, u8 ssid_len,\n\t\t\t\tstruct ieee80211_channel **channels,\n\t\t\t\tunsigned int n_channels,\n\t\t\t\tenum nl80211_bss_scan_width scan_width);\nint ieee80211_request_scan(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct cfg80211_scan_request *req);\nvoid ieee80211_scan_cancel(struct ieee80211_local *local);\nvoid ieee80211_run_deferred_scan(struct ieee80211_local *local);\nvoid ieee80211_scan_rx(struct ieee80211_local *local, struct sk_buff *skb);\n\nvoid ieee80211_inform_bss(struct wiphy *wiphy, struct cfg80211_bss *bss,\n\t\t\t  const struct cfg80211_bss_ies *ies, void *data);\n\nvoid ieee80211_mlme_notify_scan_completed(struct ieee80211_local *local);\nstruct ieee80211_bss *\nieee80211_bss_info_update(struct ieee80211_local *local,\n\t\t\t  struct ieee80211_rx_status *rx_status,\n\t\t\t  struct ieee80211_mgmt *mgmt,\n\t\t\t  size_t len,\n\t\t\t  struct ieee80211_channel *channel);\nvoid ieee80211_rx_bss_put(struct ieee80211_local *local,\n\t\t\t  struct ieee80211_bss *bss);\n\n \nint\n__ieee80211_request_sched_scan_start(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct cfg80211_sched_scan_request *req);\nint ieee80211_request_sched_scan_start(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct cfg80211_sched_scan_request *req);\nint ieee80211_request_sched_scan_stop(struct ieee80211_local *local);\nvoid ieee80211_sched_scan_end(struct ieee80211_local *local);\nvoid ieee80211_sched_scan_stopped_work(struct wiphy *wiphy,\n\t\t\t\t       struct wiphy_work *work);\n\n \nvoid ieee80211_offchannel_stop_vifs(struct ieee80211_local *local);\nvoid ieee80211_offchannel_return(struct ieee80211_local *local);\nvoid ieee80211_roc_setup(struct ieee80211_local *local);\nvoid ieee80211_start_next_roc(struct ieee80211_local *local);\nvoid ieee80211_roc_purge(struct ieee80211_local *local,\n\t\t\t struct ieee80211_sub_if_data *sdata);\nint ieee80211_remain_on_channel(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\tunsigned int duration, u64 *cookie);\nint ieee80211_cancel_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t       struct wireless_dev *wdev, u64 cookie);\nint ieee80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t      struct cfg80211_mgmt_tx_params *params, u64 *cookie);\nint ieee80211_mgmt_tx_cancel_wait(struct wiphy *wiphy,\n\t\t\t\t  struct wireless_dev *wdev, u64 cookie);\n\n \nvoid ieee80211_csa_finalize_work(struct work_struct *work);\nint ieee80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     struct cfg80211_csa_settings *params);\n\n \nvoid ieee80211_color_change_finalize_work(struct work_struct *work);\nvoid ieee80211_color_collision_detection_work(struct work_struct *work);\n\n \n#define MAC80211_SUPPORTED_FEATURES_TX\t(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | \\\n\t\t\t\t\t NETIF_F_HW_CSUM | NETIF_F_SG | \\\n\t\t\t\t\t NETIF_F_HIGHDMA | NETIF_F_GSO_SOFTWARE | \\\n\t\t\t\t\t NETIF_F_HW_TC)\n#define MAC80211_SUPPORTED_FEATURES_RX\t(NETIF_F_RXCSUM)\n#define MAC80211_SUPPORTED_FEATURES\t(MAC80211_SUPPORTED_FEATURES_TX | \\\n\t\t\t\t\t MAC80211_SUPPORTED_FEATURES_RX)\n\nint ieee80211_iface_init(void);\nvoid ieee80211_iface_exit(void);\nint ieee80211_if_add(struct ieee80211_local *local, const char *name,\n\t\t     unsigned char name_assign_type,\n\t\t     struct wireless_dev **new_wdev, enum nl80211_iftype type,\n\t\t     struct vif_params *params);\nint ieee80211_if_change_type(struct ieee80211_sub_if_data *sdata,\n\t\t\t     enum nl80211_iftype type);\nvoid ieee80211_if_remove(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_remove_interfaces(struct ieee80211_local *local);\nu32 ieee80211_idle_off(struct ieee80211_local *local);\nvoid ieee80211_recalc_idle(struct ieee80211_local *local);\nvoid ieee80211_adjust_monitor_flags(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    const int offset);\nint ieee80211_do_open(struct wireless_dev *wdev, bool coming_up);\nvoid ieee80211_sdata_stop(struct ieee80211_sub_if_data *sdata);\nint ieee80211_add_virtual_monitor(struct ieee80211_local *local);\nvoid ieee80211_del_virtual_monitor(struct ieee80211_local *local);\n\nbool __ieee80211_recalc_txpower(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_recalc_txpower(struct ieee80211_sub_if_data *sdata,\n\t\t\t      bool update_bss);\nvoid ieee80211_recalc_offload(struct ieee80211_local *local);\n\nstatic inline bool ieee80211_sdata_running(struct ieee80211_sub_if_data *sdata)\n{\n\treturn test_bit(SDATA_STATE_RUNNING, &sdata->state);\n}\n\n \nvoid ieee80211_link_setup(struct ieee80211_link_data *link);\nvoid ieee80211_link_init(struct ieee80211_sub_if_data *sdata,\n\t\t\t int link_id,\n\t\t\t struct ieee80211_link_data *link,\n\t\t\t struct ieee80211_bss_conf *link_conf);\nvoid ieee80211_link_stop(struct ieee80211_link_data *link);\nint ieee80211_vif_set_links(struct ieee80211_sub_if_data *sdata,\n\t\t\t    u16 new_links, u16 dormant_links);\nvoid ieee80211_vif_clear_links(struct ieee80211_sub_if_data *sdata);\nint __ieee80211_set_active_links(struct ieee80211_vif *vif, u16 active_links);\n\n \nvoid ieee80211_clear_tx_pending(struct ieee80211_local *local);\nvoid ieee80211_tx_pending(struct tasklet_struct *t);\nnetdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev);\nnetdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev);\nnetdev_tx_t ieee80211_subif_start_xmit_8023(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev);\nvoid __ieee80211_subif_start_xmit(struct sk_buff *skb,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  u32 info_flags,\n\t\t\t\t  u32 ctrl_flags,\n\t\t\t\t  u64 *cookie);\nvoid ieee80211_purge_tx_queue(struct ieee80211_hw *hw,\n\t\t\t      struct sk_buff_head *skbs);\nstruct sk_buff *\nieee80211_build_data_template(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct sk_buff *skb, u32 info_flags);\nvoid ieee80211_tx_monitor(struct ieee80211_local *local, struct sk_buff *skb,\n\t\t\t  int retry_count, int shift, bool send_to_cooked,\n\t\t\t  struct ieee80211_tx_status *status);\n\nvoid ieee80211_check_fast_xmit(struct sta_info *sta);\nvoid ieee80211_check_fast_xmit_all(struct ieee80211_local *local);\nvoid ieee80211_check_fast_xmit_iface(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_clear_fast_xmit(struct sta_info *sta);\nint ieee80211_tx_control_port(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *buf, size_t len,\n\t\t\t      const u8 *dest, __be16 proto, bool unencrypted,\n\t\t\t      int link_id, u64 *cookie);\nint ieee80211_probe_mesh_link(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *buf, size_t len);\nvoid __ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct sta_info *sta,\n\t\t\t   struct ieee80211_fast_tx *fast_tx,\n\t\t\t   struct sk_buff *skb, bool ampdu,\n\t\t\t   const u8 *da, const u8 *sa);\nvoid ieee80211_aggr_check(struct ieee80211_sub_if_data *sdata,\n\t\t\t  struct sta_info *sta, struct sk_buff *skb);\n\n \nvoid ieee80211_apply_htcap_overrides(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct ieee80211_sta_ht_cap *ht_cap);\nbool ieee80211_ht_cap_ie_to_sta_ht_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_supported_band *sband,\n\t\t\t\t       const struct ieee80211_ht_cap *ht_cap_ie,\n\t\t\t\t       struct link_sta_info *link_sta);\nvoid ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,\n\t\t\t  const u8 *da, u16 tid,\n\t\t\t  u16 initiator, u16 reason_code);\nint ieee80211_send_smps_action(struct ieee80211_sub_if_data *sdata,\n\t\t\t       enum ieee80211_smps_mode smps, const u8 *da,\n\t\t\t       const u8 *bssid);\nbool ieee80211_smps_is_restrictive(enum ieee80211_smps_mode smps_mode_old,\n\t\t\t\t   enum ieee80211_smps_mode smps_mode_new);\n\nvoid ___ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,\n\t\t\t\t     u16 initiator, u16 reason, bool stop);\nvoid __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,\n\t\t\t\t    u16 initiator, u16 reason, bool stop);\nvoid ___ieee80211_start_rx_ba_session(struct sta_info *sta,\n\t\t\t\t      u8 dialog_token, u16 timeout,\n\t\t\t\t      u16 start_seq_num, u16 ba_policy, u16 tid,\n\t\t\t\t      u16 buf_size, bool tx, bool auto_seq,\n\t\t\t\t      const struct ieee80211_addba_ext_ie *addbaext);\nvoid ieee80211_sta_tear_down_BA_sessions(struct sta_info *sta,\n\t\t\t\t\t enum ieee80211_agg_stop_reason reason);\nvoid ieee80211_process_delba(struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct sta_info *sta,\n\t\t\t     struct ieee80211_mgmt *mgmt, size_t len);\nvoid ieee80211_process_addba_resp(struct ieee80211_local *local,\n\t\t\t\t  struct sta_info *sta,\n\t\t\t\t  struct ieee80211_mgmt *mgmt,\n\t\t\t\t  size_t len);\nvoid ieee80211_process_addba_request(struct ieee80211_local *local,\n\t\t\t\t     struct sta_info *sta,\n\t\t\t\t     struct ieee80211_mgmt *mgmt,\n\t\t\t\t     size_t len);\n\nint __ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,\n\t\t\t\t   enum ieee80211_agg_stop_reason reason);\nint ___ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,\n\t\t\t\t    enum ieee80211_agg_stop_reason reason);\nvoid ieee80211_start_tx_ba_cb(struct sta_info *sta, int tid,\n\t\t\t      struct tid_ampdu_tx *tid_tx);\nvoid ieee80211_stop_tx_ba_cb(struct sta_info *sta, int tid,\n\t\t\t     struct tid_ampdu_tx *tid_tx);\nvoid ieee80211_ba_session_work(struct work_struct *work);\nvoid ieee80211_tx_ba_session_handle_start(struct sta_info *sta, int tid);\nvoid ieee80211_release_reorder_timeout(struct sta_info *sta, int tid);\n\nu8 ieee80211_mcs_to_chains(const struct ieee80211_mcs_info *mcs);\nenum nl80211_smps_mode\nieee80211_smps_mode_to_smps_mode(enum ieee80211_smps_mode smps);\n\n \nvoid\nieee80211_vht_cap_ie_to_sta_vht_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t\t    const struct ieee80211_vht_cap *vht_cap_ie,\n\t\t\t\t    const struct ieee80211_vht_cap *vht_cap_ie2,\n\t\t\t\t    struct link_sta_info *link_sta);\nenum ieee80211_sta_rx_bandwidth\nieee80211_sta_cap_rx_bw(struct link_sta_info *link_sta);\nenum ieee80211_sta_rx_bandwidth\nieee80211_sta_cur_vht_bw(struct link_sta_info *link_sta);\nvoid ieee80211_sta_set_rx_nss(struct link_sta_info *link_sta);\nenum ieee80211_sta_rx_bandwidth\nieee80211_chan_width_to_rx_bw(enum nl80211_chan_width width);\nenum nl80211_chan_width\nieee80211_sta_cap_chan_bw(struct link_sta_info *link_sta);\nvoid ieee80211_process_mu_groups(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct ieee80211_link_data *link,\n\t\t\t\t struct ieee80211_mgmt *mgmt);\nu32 __ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct link_sta_info *sta,\n\t\t\t\t  u8 opmode, enum nl80211_band band);\nvoid ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct link_sta_info *sta,\n\t\t\t\t u8 opmode, enum nl80211_band band);\nvoid ieee80211_apply_vhtcap_overrides(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct ieee80211_sta_vht_cap *vht_cap);\nvoid ieee80211_get_vht_mask_from_cap(__le16 vht_cap,\n\t\t\t\t     u16 vht_mask[NL80211_VHT_NSS_MAX]);\nenum nl80211_chan_width\nieee80211_sta_rx_bw_to_chan_width(struct link_sta_info *sta);\n\n \nvoid\nieee80211_he_cap_ie_to_sta_he_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct ieee80211_supported_band *sband,\n\t\t\t\t  const u8 *he_cap_ie, u8 he_cap_len,\n\t\t\t\t  const struct ieee80211_he_6ghz_capa *he_6ghz_capa,\n\t\t\t\t  struct link_sta_info *link_sta);\nvoid\nieee80211_he_spr_ie_to_bss_conf(struct ieee80211_vif *vif,\n\t\t\t\tconst struct ieee80211_he_spr *he_spr_ie_elem);\n\nvoid\nieee80211_he_op_ie_to_bss_conf(struct ieee80211_vif *vif,\n\t\t\tconst struct ieee80211_he_operation *he_op_ie_elem);\n\n \nvoid ieee80211_s1g_sta_rate_init(struct sta_info *sta);\nbool ieee80211_s1g_is_twt_setup(struct sk_buff *skb);\nvoid ieee80211_s1g_rx_twt_action(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb);\nvoid ieee80211_s1g_status_twt_action(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct sk_buff *skb);\n\n \nvoid ieee80211_process_measurement_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_mgmt *mgmt,\n\t\t\t\t       size_t len);\n \nint ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct ieee802_11_elems *elems,\n\t\t\t\t enum nl80211_band current_band,\n\t\t\t\t u32 vht_cap_info,\n\t\t\t\t ieee80211_conn_flags_t conn_flags, u8 *bssid,\n\t\t\t\t struct ieee80211_csa_ie *csa_ie);\n\n \nint ieee80211_reconfig(struct ieee80211_local *local);\nvoid ieee80211_stop_device(struct ieee80211_local *local);\n\nint __ieee80211_suspend(struct ieee80211_hw *hw,\n\t\t\tstruct cfg80211_wowlan *wowlan);\n\nstatic inline int __ieee80211_resume(struct ieee80211_hw *hw)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tWARN(test_bit(SCAN_HW_SCANNING, &local->scanning) &&\n\t     !test_bit(SCAN_COMPLETED, &local->scanning),\n\t\t\"%s: resume with hardware scan still in progress\\n\",\n\t\twiphy_name(hw->wiphy));\n\n\treturn ieee80211_reconfig(hw_to_local(hw));\n}\n\n \nextern const void *const mac80211_wiphy_privid;  \nint ieee80211_frame_duration(enum nl80211_band band, size_t len,\n\t\t\t     int rate, int erp, int short_preamble,\n\t\t\t     int shift);\nvoid ieee80211_regulatory_limit_wmm_params(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct ieee80211_tx_queue_params *qparam,\n\t\t\t\t\t   int ac);\nvoid ieee80211_set_wmm_default(struct ieee80211_link_data *link,\n\t\t\t       bool bss_notify, bool enable_qos);\nvoid ieee80211_xmit(struct ieee80211_sub_if_data *sdata,\n\t\t    struct sta_info *sta, struct sk_buff *skb);\n\nvoid __ieee80211_tx_skb_tid_band(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb, int tid, int link_id,\n\t\t\t\t enum nl80211_band band);\n\n \nint ieee80211_lookup_ra_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct sta_info **sta_out);\n\nstatic inline void\nieee80211_tx_skb_tid_band(struct ieee80211_sub_if_data *sdata,\n\t\t\t  struct sk_buff *skb, int tid,\n\t\t\t  enum nl80211_band band)\n{\n\trcu_read_lock();\n\t__ieee80211_tx_skb_tid_band(sdata, skb, tid, -1, band);\n\trcu_read_unlock();\n}\n\nvoid ieee80211_tx_skb_tid(struct ieee80211_sub_if_data *sdata,\n\t\t\t  struct sk_buff *skb, int tid, int link_id);\n\nstatic inline void ieee80211_tx_skb(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct sk_buff *skb)\n{\n\t \n\tieee80211_tx_skb_tid(sdata, skb, 7, -1);\n}\n\n \nstruct ieee80211_elems_parse_params {\n\tconst u8 *start;\n\tsize_t len;\n\tbool action;\n\tu64 filter;\n\tu32 crc;\n\tstruct cfg80211_bss *bss;\n\tint link_id;\n\tbool from_ap;\n};\n\nstruct ieee802_11_elems *\nieee802_11_parse_elems_full(struct ieee80211_elems_parse_params *params);\n\nstatic inline struct ieee802_11_elems *\nieee802_11_parse_elems_crc(const u8 *start, size_t len, bool action,\n\t\t\t   u64 filter, u32 crc,\n\t\t\t   struct cfg80211_bss *bss)\n{\n\tstruct ieee80211_elems_parse_params params = {\n\t\t.start = start,\n\t\t.len = len,\n\t\t.action = action,\n\t\t.filter = filter,\n\t\t.crc = crc,\n\t\t.bss = bss,\n\t\t.link_id = -1,\n\t};\n\n\treturn ieee802_11_parse_elems_full(&params);\n}\n\nstatic inline struct ieee802_11_elems *\nieee802_11_parse_elems(const u8 *start, size_t len, bool action,\n\t\t       struct cfg80211_bss *bss)\n{\n\treturn ieee802_11_parse_elems_crc(start, len, action, 0, 0, bss);\n}\n\nvoid ieee80211_fragment_element(struct sk_buff *skb, u8 *len_pos, u8 frag_id);\n\nextern const int ieee802_1d_to_ac[8];\n\nstatic inline int ieee80211_ac_from_tid(int tid)\n{\n\treturn ieee802_1d_to_ac[tid & 7];\n}\n\nvoid ieee80211_dynamic_ps_enable_work(struct work_struct *work);\nvoid ieee80211_dynamic_ps_disable_work(struct work_struct *work);\nvoid ieee80211_dynamic_ps_timer(struct timer_list *t);\nvoid ieee80211_send_nullfunc(struct ieee80211_local *local,\n\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t     bool powersave);\nvoid ieee80211_send_4addr_nullfunc(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_sta_tx_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct ieee80211_hdr *hdr, bool ack, u16 tx_time);\n\nvoid ieee80211_wake_queues_by_reason(struct ieee80211_hw *hw,\n\t\t\t\t     unsigned long queues,\n\t\t\t\t     enum queue_stop_reason reason,\n\t\t\t\t     bool refcounted);\nvoid ieee80211_stop_vif_queues(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t       enum queue_stop_reason reason);\nvoid ieee80211_wake_vif_queues(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t       enum queue_stop_reason reason);\nvoid ieee80211_stop_queues_by_reason(struct ieee80211_hw *hw,\n\t\t\t\t     unsigned long queues,\n\t\t\t\t     enum queue_stop_reason reason,\n\t\t\t\t     bool refcounted);\nvoid ieee80211_wake_queue_by_reason(struct ieee80211_hw *hw, int queue,\n\t\t\t\t    enum queue_stop_reason reason,\n\t\t\t\t    bool refcounted);\nvoid ieee80211_stop_queue_by_reason(struct ieee80211_hw *hw, int queue,\n\t\t\t\t    enum queue_stop_reason reason,\n\t\t\t\t    bool refcounted);\nvoid ieee80211_add_pending_skb(struct ieee80211_local *local,\n\t\t\t       struct sk_buff *skb);\nvoid ieee80211_add_pending_skbs(struct ieee80211_local *local,\n\t\t\t\tstruct sk_buff_head *skbs);\nvoid ieee80211_flush_queues(struct ieee80211_local *local,\n\t\t\t    struct ieee80211_sub_if_data *sdata, bool drop);\nvoid __ieee80211_flush_queues(struct ieee80211_local *local,\n\t\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t\t      unsigned int queues, bool drop);\n\nstatic inline bool ieee80211_can_run_worker(struct ieee80211_local *local)\n{\n\t \n\tif (local->in_reconfig)\n\t\treturn false;\n\n\t \n\tif (local->quiescing)\n\t\treturn false;\n\n\t \n\tif (local->suspended)\n\t\treturn false;\n\n\treturn true;\n}\n\nint ieee80211_txq_setup_flows(struct ieee80211_local *local);\nvoid ieee80211_txq_set_params(struct ieee80211_local *local);\nvoid ieee80211_txq_teardown_flows(struct ieee80211_local *local);\nvoid ieee80211_txq_init(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sta_info *sta,\n\t\t\tstruct txq_info *txq, int tid);\nvoid ieee80211_txq_purge(struct ieee80211_local *local,\n\t\t\t struct txq_info *txqi);\nvoid ieee80211_txq_remove_vlan(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_fill_txq_stats(struct cfg80211_txq_stats *txqstats,\n\t\t\t      struct txq_info *txqi);\nvoid ieee80211_wake_txqs(struct tasklet_struct *t);\nvoid ieee80211_send_auth(struct ieee80211_sub_if_data *sdata,\n\t\t\t u16 transaction, u16 auth_alg, u16 status,\n\t\t\t const u8 *extra, size_t extra_len, const u8 *bssid,\n\t\t\t const u8 *da, const u8 *key, u8 key_len, u8 key_idx,\n\t\t\t u32 tx_flags);\nvoid ieee80211_send_deauth_disassoc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    const u8 *da, const u8 *bssid,\n\t\t\t\t    u16 stype, u16 reason,\n\t\t\t\t    bool send_frame, u8 *frame_buf);\nu8 *ieee80211_write_he_6ghz_cap(u8 *pos, __le16 cap, u8 *end);\n\nenum {\n\tIEEE80211_PROBE_FLAG_DIRECTED\t\t= BIT(0),\n\tIEEE80211_PROBE_FLAG_MIN_CONTENT\t= BIT(1),\n\tIEEE80211_PROBE_FLAG_RANDOM_SN\t\t= BIT(2),\n};\n\nint ieee80211_build_preq_ies(struct ieee80211_sub_if_data *sdata, u8 *buffer,\n\t\t\t     size_t buffer_len,\n\t\t\t     struct ieee80211_scan_ies *ie_desc,\n\t\t\t     const u8 *ie, size_t ie_len,\n\t\t\t     u8 bands_used, u32 *rate_masks,\n\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t     u32 flags);\nstruct sk_buff *ieee80211_build_probe_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  const u8 *src, const u8 *dst,\n\t\t\t\t\t  u32 ratemask,\n\t\t\t\t\t  struct ieee80211_channel *chan,\n\t\t\t\t\t  const u8 *ssid, size_t ssid_len,\n\t\t\t\t\t  const u8 *ie, size_t ie_len,\n\t\t\t\t\t  u32 flags);\nu32 ieee80211_sta_get_rates(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct ieee802_11_elems *elems,\n\t\t\t    enum nl80211_band band, u32 *basic_rates);\nint __ieee80211_request_smps_mgd(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct ieee80211_link_data *link,\n\t\t\t\t enum ieee80211_smps_mode smps_mode);\nvoid ieee80211_recalc_smps(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct ieee80211_link_data *link);\nvoid ieee80211_recalc_min_chandef(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  int link_id);\n\nsize_t ieee80211_ie_split_vendor(const u8 *ies, size_t ielen, size_t offset);\nu8 *ieee80211_ie_build_ht_cap(u8 *pos, struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t      u16 cap);\nu8 *ieee80211_ie_build_ht_oper(u8 *pos, struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t       const struct cfg80211_chan_def *chandef,\n\t\t\t       u16 prot_mode, bool rifs_mode);\nvoid ieee80211_ie_build_wide_bw_cs(u8 *pos,\n\t\t\t\t   const struct cfg80211_chan_def *chandef);\nu8 *ieee80211_ie_build_vht_cap(u8 *pos, struct ieee80211_sta_vht_cap *vht_cap,\n\t\t\t       u32 cap);\nu8 *ieee80211_ie_build_vht_oper(u8 *pos, struct ieee80211_sta_vht_cap *vht_cap,\n\t\t\t\tconst struct cfg80211_chan_def *chandef);\nu8 ieee80211_ie_len_he_cap(struct ieee80211_sub_if_data *sdata, u8 iftype);\nu8 *ieee80211_ie_build_he_cap(ieee80211_conn_flags_t disable_flags, u8 *pos,\n\t\t\t      const struct ieee80211_sta_he_cap *he_cap,\n\t\t\t      u8 *end);\nvoid ieee80211_ie_build_he_6ghz_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    enum ieee80211_smps_mode smps_mode,\n\t\t\t\t    struct sk_buff *skb);\nu8 *ieee80211_ie_build_he_oper(u8 *pos, struct cfg80211_chan_def *chandef);\nu8 *ieee80211_ie_build_eht_oper(u8 *pos, struct cfg80211_chan_def *chandef,\n\t\t\t\tconst struct ieee80211_sta_eht_cap *eht_cap);\nint ieee80211_parse_bitrates(enum nl80211_chan_width width,\n\t\t\t     const struct ieee80211_supported_band *sband,\n\t\t\t     const u8 *srates, int srates_len, u32 *rates);\nint ieee80211_add_srates_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct sk_buff *skb, bool need_basic,\n\t\t\t    enum nl80211_band band);\nint ieee80211_add_ext_srates_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sk_buff *skb, bool need_basic,\n\t\t\t\tenum nl80211_band band);\nu8 *ieee80211_add_wmm_info_ie(u8 *buf, u8 qosinfo);\nvoid ieee80211_add_s1g_capab_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct ieee80211_sta_s1g_cap *caps,\n\t\t\t\tstruct sk_buff *skb);\nvoid ieee80211_add_aid_request_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct sk_buff *skb);\nu8 *ieee80211_ie_build_s1g_cap(u8 *pos, struct ieee80211_sta_s1g_cap *s1g_cap);\n\n \nbool ieee80211_chandef_ht_oper(const struct ieee80211_ht_operation *ht_oper,\n\t\t\t       struct cfg80211_chan_def *chandef);\nbool ieee80211_chandef_vht_oper(struct ieee80211_hw *hw, u32 vht_cap_info,\n\t\t\t\tconst struct ieee80211_vht_operation *oper,\n\t\t\t\tconst struct ieee80211_ht_operation *htop,\n\t\t\t\tstruct cfg80211_chan_def *chandef);\nvoid ieee80211_chandef_eht_oper(const struct ieee80211_eht_operation *eht_oper,\n\t\t\t\tbool support_160, bool support_320,\n\t\t\t\tstruct cfg80211_chan_def *chandef);\nbool ieee80211_chandef_he_6ghz_oper(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    const struct ieee80211_he_operation *he_oper,\n\t\t\t\t    const struct ieee80211_eht_operation *eht_oper,\n\t\t\t\t    struct cfg80211_chan_def *chandef);\nbool ieee80211_chandef_s1g_oper(const struct ieee80211_s1g_oper_ie *oper,\n\t\t\t\tstruct cfg80211_chan_def *chandef);\nieee80211_conn_flags_t ieee80211_chandef_downgrade(struct cfg80211_chan_def *c);\n\nint __must_check\nieee80211_link_use_channel(struct ieee80211_link_data *link,\n\t\t\t   const struct cfg80211_chan_def *chandef,\n\t\t\t   enum ieee80211_chanctx_mode mode);\nint __must_check\nieee80211_link_reserve_chanctx(struct ieee80211_link_data *link,\n\t\t\t       const struct cfg80211_chan_def *chandef,\n\t\t\t       enum ieee80211_chanctx_mode mode,\n\t\t\t       bool radar_required);\nint __must_check\nieee80211_link_use_reserved_context(struct ieee80211_link_data *link);\nint ieee80211_link_unreserve_chanctx(struct ieee80211_link_data *link);\n\nint __must_check\nieee80211_link_change_bandwidth(struct ieee80211_link_data *link,\n\t\t\t\tconst struct cfg80211_chan_def *chandef,\n\t\t\t\tu64 *changed);\nvoid ieee80211_link_release_channel(struct ieee80211_link_data *link);\nvoid ieee80211_link_vlan_copy_chanctx(struct ieee80211_link_data *link);\nvoid ieee80211_link_copy_chanctx_to_vlans(struct ieee80211_link_data *link,\n\t\t\t\t\t  bool clear);\nint ieee80211_chanctx_refcount(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_chanctx *ctx);\n\nvoid ieee80211_recalc_smps_chanctx(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_chanctx *chanctx);\nvoid ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_chanctx *ctx,\n\t\t\t\t      struct ieee80211_link_data *rsvd_for);\nbool ieee80211_is_radar_required(struct ieee80211_local *local);\n\nvoid ieee80211_dfs_cac_timer_work(struct work_struct *work);\nvoid ieee80211_dfs_cac_cancel(struct ieee80211_local *local);\nvoid ieee80211_dfs_radar_detected_work(struct wiphy *wiphy,\n\t\t\t\t       struct wiphy_work *work);\nint ieee80211_send_action_csa(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct cfg80211_csa_settings *csa_settings);\n\nvoid ieee80211_recalc_dtim(struct ieee80211_local *local,\n\t\t\t   struct ieee80211_sub_if_data *sdata);\nint ieee80211_check_combinations(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t const struct cfg80211_chan_def *chandef,\n\t\t\t\t enum ieee80211_chanctx_mode chanmode,\n\t\t\t\t u8 radar_detect);\nint ieee80211_max_num_channels(struct ieee80211_local *local);\nvoid ieee80211_recalc_chanctx_chantype(struct ieee80211_local *local,\n\t\t\t\t       struct ieee80211_chanctx *ctx);\n\n \nint ieee80211_tdls_mgmt(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tconst u8 *peer, int link_id,\n\t\t\tu8 action_code, u8 dialog_token, u16 status_code,\n\t\t\tu32 peer_capability, bool initiator,\n\t\t\tconst u8 *extra_ies, size_t extra_ies_len);\nint ieee80211_tdls_oper(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tconst u8 *peer, enum nl80211_tdls_operation oper);\nvoid ieee80211_tdls_peer_del_work(struct work_struct *wk);\nint ieee80211_tdls_channel_switch(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const u8 *addr, u8 oper_class,\n\t\t\t\t  struct cfg80211_chan_def *chandef);\nvoid ieee80211_tdls_cancel_channel_switch(struct wiphy *wiphy,\n\t\t\t\t\t  struct net_device *dev,\n\t\t\t\t\t  const u8 *addr);\nvoid ieee80211_teardown_tdls_peers(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_tdls_handle_disconnect(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      const u8 *peer, u16 reason);\nvoid\nieee80211_process_tdls_channel_switch(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct sk_buff *skb);\n\n\nconst char *ieee80211_get_reason_code_string(u16 reason_code);\nu16 ieee80211_encode_usf(int val);\nu8 *ieee80211_get_bssid(struct ieee80211_hdr *hdr, size_t len,\n\t\t\tenum nl80211_iftype type);\n\nextern const struct ethtool_ops ieee80211_ethtool_ops;\n\nu32 ieee80211_calc_expected_tx_airtime(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_sta *pubsta,\n\t\t\t\t       int len, bool ampdu);\n#ifdef CONFIG_MAC80211_NOINLINE\n#define debug_noinline noinline\n#else\n#define debug_noinline\n#endif\n\nvoid ieee80211_init_frag_cache(struct ieee80211_fragment_cache *cache);\nvoid ieee80211_destroy_frag_cache(struct ieee80211_fragment_cache *cache);\n\nu8 ieee80211_ie_len_eht_cap(struct ieee80211_sub_if_data *sdata, u8 iftype);\nu8 *ieee80211_ie_build_eht_cap(u8 *pos,\n\t\t\t       const struct ieee80211_sta_he_cap *he_cap,\n\t\t\t       const struct ieee80211_sta_eht_cap *eht_cap,\n\t\t\t       u8 *end,\n\t\t\t       bool for_ap);\n\nvoid\nieee80211_eht_cap_ie_to_sta_eht_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t\t    const u8 *he_cap_ie, u8 he_cap_len,\n\t\t\t\t    const struct ieee80211_eht_cap_elem *eht_cap_ie_elem,\n\t\t\t\t    u8 eht_cap_len,\n\t\t\t\t    struct link_sta_info *link_sta);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}