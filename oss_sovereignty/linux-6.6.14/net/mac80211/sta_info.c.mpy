{
  "module_name": "sta_info.c",
  "hash_id": "49e10124ff94922ab397d367384b7b8deebdfa0eded9c8b9b5c7d3fc10bb721f",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/sta_info.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/timer.h>\n#include <linux/rtnetlink.h>\n\n#include <net/codel.h>\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"rate.h\"\n#include \"sta_info.h\"\n#include \"debugfs_sta.h\"\n#include \"mesh.h\"\n#include \"wme.h\"\n\n \n\nstruct sta_link_alloc {\n\tstruct link_sta_info info;\n\tstruct ieee80211_link_sta sta;\n\tstruct rcu_head rcu_head;\n};\n\nstatic const struct rhashtable_params sta_rht_params = {\n\t.nelem_hint = 3,  \n\t.automatic_shrinking = true,\n\t.head_offset = offsetof(struct sta_info, hash_node),\n\t.key_offset = offsetof(struct sta_info, addr),\n\t.key_len = ETH_ALEN,\n\t.max_size = CONFIG_MAC80211_STA_HASH_MAX_SIZE,\n};\n\nstatic const struct rhashtable_params link_sta_rht_params = {\n\t.nelem_hint = 3,  \n\t.automatic_shrinking = true,\n\t.head_offset = offsetof(struct link_sta_info, link_hash_node),\n\t.key_offset = offsetof(struct link_sta_info, addr),\n\t.key_len = ETH_ALEN,\n\t.max_size = CONFIG_MAC80211_STA_HASH_MAX_SIZE,\n};\n\n \nstatic int sta_info_hash_del(struct ieee80211_local *local,\n\t\t\t     struct sta_info *sta)\n{\n\treturn rhltable_remove(&local->sta_hash, &sta->hash_node,\n\t\t\t       sta_rht_params);\n}\n\nstatic int link_sta_info_hash_add(struct ieee80211_local *local,\n\t\t\t\t  struct link_sta_info *link_sta)\n{\n\tlockdep_assert_held(&local->sta_mtx);\n\treturn rhltable_insert(&local->link_sta_hash,\n\t\t\t       &link_sta->link_hash_node,\n\t\t\t       link_sta_rht_params);\n}\n\nstatic int link_sta_info_hash_del(struct ieee80211_local *local,\n\t\t\t\t  struct link_sta_info *link_sta)\n{\n\tlockdep_assert_held(&local->sta_mtx);\n\treturn rhltable_remove(&local->link_sta_hash,\n\t\t\t       &link_sta->link_hash_node,\n\t\t\t       link_sta_rht_params);\n}\n\nstatic void __cleanup_single_sta(struct sta_info *sta)\n{\n\tint ac, i;\n\tstruct tid_ampdu_tx *tid_tx;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ps_data *ps;\n\n\tif (test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t    test_sta_flag(sta, WLAN_STA_PS_DRIVER) ||\n\t    test_sta_flag(sta, WLAN_STA_PS_DELIVER)) {\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t    sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tps = &sdata->bss->ps;\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tps = &sdata->u.mesh.ps;\n\t\telse\n\t\t\treturn;\n\n\t\tclear_sta_flag(sta, WLAN_STA_PS_STA);\n\t\tclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\t\tclear_sta_flag(sta, WLAN_STA_PS_DELIVER);\n\n\t\tatomic_dec(&ps->num_sta_ps);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {\n\t\tstruct txq_info *txqi;\n\n\t\tif (!sta->sta.txq[i])\n\t\t\tcontinue;\n\n\t\ttxqi = to_txq_info(sta->sta.txq[i]);\n\n\t\tieee80211_txq_purge(local, txqi);\n\t}\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tlocal->total_ps_buffered -= skb_queue_len(&sta->ps_tx_buf[ac]);\n\t\tieee80211_purge_tx_queue(&local->hw, &sta->ps_tx_buf[ac]);\n\t\tieee80211_purge_tx_queue(&local->hw, &sta->tx_filtered[ac]);\n\t}\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tmesh_sta_cleanup(sta);\n\n\tcancel_work_sync(&sta->drv_deliver_wk);\n\n\t \n\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\n\t\tkfree(sta->ampdu_mlme.tid_start_tx[i]);\n\t\ttid_tx = rcu_dereference_raw(sta->ampdu_mlme.tid_tx[i]);\n\t\tif (!tid_tx)\n\t\t\tcontinue;\n\t\tieee80211_purge_tx_queue(&local->hw, &tid_tx->pending);\n\t\tkfree(tid_tx);\n\t}\n}\n\nstatic void cleanup_single_sta(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\n\t__cleanup_single_sta(sta);\n\tsta_info_free(local, sta);\n}\n\nstruct rhlist_head *sta_info_hash_lookup(struct ieee80211_local *local,\n\t\t\t\t\t const u8 *addr)\n{\n\treturn rhltable_lookup(&local->sta_hash, addr, sta_rht_params);\n}\n\n \nstruct sta_info *sta_info_get(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *addr)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct rhlist_head *tmp;\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\tfor_each_sta_info(local, addr, sta, tmp) {\n\t\tif (sta->sdata == sdata) {\n\t\t\trcu_read_unlock();\n\t\t\t \n\t\t\treturn sta;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\n\n \nstruct sta_info *sta_info_get_bss(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  const u8 *addr)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct rhlist_head *tmp;\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\tfor_each_sta_info(local, addr, sta, tmp) {\n\t\tif (sta->sdata == sdata ||\n\t\t    (sta->sdata->bss && sta->sdata->bss == sdata->bss)) {\n\t\t\trcu_read_unlock();\n\t\t\t \n\t\t\treturn sta;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\n\nstruct rhlist_head *link_sta_info_hash_lookup(struct ieee80211_local *local,\n\t\t\t\t\t      const u8 *addr)\n{\n\treturn rhltable_lookup(&local->link_sta_hash, addr,\n\t\t\t       link_sta_rht_params);\n}\n\nstruct link_sta_info *\nlink_sta_info_get_bss(struct ieee80211_sub_if_data *sdata, const u8 *addr)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct rhlist_head *tmp;\n\tstruct link_sta_info *link_sta;\n\n\trcu_read_lock();\n\tfor_each_link_sta_info(local, addr, link_sta, tmp) {\n\t\tstruct sta_info *sta = link_sta->sta;\n\n\t\tif (sta->sdata == sdata ||\n\t\t    (sta->sdata->bss && sta->sdata->bss == sdata->bss)) {\n\t\t\trcu_read_unlock();\n\t\t\t \n\t\t\treturn link_sta;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\n\nstruct ieee80211_sta *\nieee80211_find_sta_by_link_addrs(struct ieee80211_hw *hw,\n\t\t\t\t const u8 *addr,\n\t\t\t\t const u8 *localaddr,\n\t\t\t\t unsigned int *link_id)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct link_sta_info *link_sta;\n\tstruct rhlist_head *tmp;\n\n\tfor_each_link_sta_info(local, addr, link_sta, tmp) {\n\t\tstruct sta_info *sta = link_sta->sta;\n\t\tstruct ieee80211_link_data *link;\n\t\tu8 _link_id = link_sta->link_id;\n\n\t\tif (!localaddr) {\n\t\t\tif (link_id)\n\t\t\t\t*link_id = _link_id;\n\t\t\treturn &sta->sta;\n\t\t}\n\n\t\tlink = rcu_dereference(sta->sdata->link[_link_id]);\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\tif (memcmp(link->conf->addr, localaddr, ETH_ALEN))\n\t\t\tcontinue;\n\n\t\tif (link_id)\n\t\t\t*link_id = _link_id;\n\t\treturn &sta->sta;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ieee80211_find_sta_by_link_addrs);\n\nstruct sta_info *sta_info_get_by_addrs(struct ieee80211_local *local,\n\t\t\t\t       const u8 *sta_addr, const u8 *vif_addr)\n{\n\tstruct rhlist_head *tmp;\n\tstruct sta_info *sta;\n\n\tfor_each_sta_info(local, sta_addr, sta, tmp) {\n\t\tif (ether_addr_equal(vif_addr, sta->sdata->vif.addr))\n\t\t\treturn sta;\n\t}\n\n\treturn NULL;\n}\n\nstruct sta_info *sta_info_get_by_idx(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     int idx)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tint i = 0;\n\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list,\n\t\t\t\tlockdep_is_held(&local->sta_mtx)) {\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\t\tif (i < idx) {\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\t\treturn sta;\n\t}\n\n\treturn NULL;\n}\n\nstatic void sta_info_free_link(struct link_sta_info *link_sta)\n{\n\tfree_percpu(link_sta->pcpu_rx_stats);\n}\n\nstatic void sta_remove_link(struct sta_info *sta, unsigned int link_id,\n\t\t\t    bool unhash)\n{\n\tstruct sta_link_alloc *alloc = NULL;\n\tstruct link_sta_info *link_sta;\n\n\tlink_sta = rcu_access_pointer(sta->link[link_id]);\n\tif (link_sta != &sta->deflink)\n\t\tlockdep_assert_held(&sta->local->sta_mtx);\n\n\tif (WARN_ON(!link_sta))\n\t\treturn;\n\n\tif (unhash)\n\t\tlink_sta_info_hash_del(sta->local, link_sta);\n\n\tif (test_sta_flag(sta, WLAN_STA_INSERTED))\n\t\tieee80211_link_sta_debugfs_remove(link_sta);\n\n\tif (link_sta != &sta->deflink)\n\t\talloc = container_of(link_sta, typeof(*alloc), info);\n\n\tsta->sta.valid_links &= ~BIT(link_id);\n\tRCU_INIT_POINTER(sta->link[link_id], NULL);\n\tRCU_INIT_POINTER(sta->sta.link[link_id], NULL);\n\tif (alloc) {\n\t\tsta_info_free_link(&alloc->info);\n\t\tkfree_rcu(alloc, rcu_head);\n\t}\n\n\tieee80211_sta_recalc_aggregates(&sta->sta);\n}\n\n \nvoid sta_info_free(struct ieee80211_local *local, struct sta_info *sta)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sta->link); i++) {\n\t\tif (!(sta->sta.valid_links & BIT(i)))\n\t\t\tcontinue;\n\n\t\tsta_remove_link(sta, i, false);\n\t}\n\n\t \n\twhile (sta->sta_state > IEEE80211_STA_NONE) {\n\t\tint ret;\n\n\t\tWARN_ON_ONCE(test_sta_flag(sta, WLAN_STA_INSERTED));\n\n\t\tret = sta_info_move_state(sta, sta->sta_state - 1);\n\t\tif (WARN_ONCE(ret, \"sta_info_move_state() returned %d\\n\", ret))\n\t\t\tbreak;\n\t}\n\n\tif (sta->rate_ctrl)\n\t\trate_control_free_sta(sta);\n\n\tsta_dbg(sta->sdata, \"Destroyed STA %pM\\n\", sta->sta.addr);\n\n\tkfree(to_txq_info(sta->sta.txq[0]));\n\tkfree(rcu_dereference_raw(sta->sta.rates));\n#ifdef CONFIG_MAC80211_MESH\n\tkfree(sta->mesh);\n#endif\n\n\tsta_info_free_link(&sta->deflink);\n\tkfree(sta);\n}\n\n \nstatic int sta_info_hash_add(struct ieee80211_local *local,\n\t\t\t     struct sta_info *sta)\n{\n\treturn rhltable_insert(&local->sta_hash, &sta->hash_node,\n\t\t\t       sta_rht_params);\n}\n\nstatic void sta_deliver_ps_frames(struct work_struct *wk)\n{\n\tstruct sta_info *sta;\n\n\tsta = container_of(wk, struct sta_info, drv_deliver_wk);\n\n\tif (sta->dead)\n\t\treturn;\n\n\tlocal_bh_disable();\n\tif (!test_sta_flag(sta, WLAN_STA_PS_STA))\n\t\tieee80211_sta_ps_deliver_wakeup(sta);\n\telse if (test_and_clear_sta_flag(sta, WLAN_STA_PSPOLL))\n\t\tieee80211_sta_ps_deliver_poll_response(sta);\n\telse if (test_and_clear_sta_flag(sta, WLAN_STA_UAPSD))\n\t\tieee80211_sta_ps_deliver_uapsd(sta);\n\tlocal_bh_enable();\n}\n\nstatic int sta_prepare_rate_control(struct ieee80211_local *local,\n\t\t\t\t    struct sta_info *sta, gfp_t gfp)\n{\n\tif (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL))\n\t\treturn 0;\n\n\tsta->rate_ctrl = local->rate_ctrl;\n\tsta->rate_ctrl_priv = rate_control_alloc_sta(sta->rate_ctrl,\n\t\t\t\t\t\t     sta, gfp);\n\tif (!sta->rate_ctrl_priv)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sta_info_alloc_link(struct ieee80211_local *local,\n\t\t\t       struct link_sta_info *link_info,\n\t\t\t       gfp_t gfp)\n{\n\tstruct ieee80211_hw *hw = &local->hw;\n\tint i;\n\n\tif (ieee80211_hw_check(hw, USES_RSS)) {\n\t\tlink_info->pcpu_rx_stats =\n\t\t\talloc_percpu_gfp(struct ieee80211_sta_rx_stats, gfp);\n\t\tif (!link_info->pcpu_rx_stats)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tlink_info->rx_stats.last_rx = jiffies;\n\tu64_stats_init(&link_info->rx_stats.syncp);\n\n\tewma_signal_init(&link_info->rx_stats_avg.signal);\n\tewma_avg_signal_init(&link_info->status_stats.avg_ack_signal);\n\tfor (i = 0; i < ARRAY_SIZE(link_info->rx_stats_avg.chain_signal); i++)\n\t\tewma_signal_init(&link_info->rx_stats_avg.chain_signal[i]);\n\n\treturn 0;\n}\n\nstatic void sta_info_add_link(struct sta_info *sta,\n\t\t\t      unsigned int link_id,\n\t\t\t      struct link_sta_info *link_info,\n\t\t\t      struct ieee80211_link_sta *link_sta)\n{\n\tlink_info->sta = sta;\n\tlink_info->link_id = link_id;\n\tlink_info->pub = link_sta;\n\tlink_info->pub->sta = &sta->sta;\n\tlink_sta->link_id = link_id;\n\trcu_assign_pointer(sta->link[link_id], link_info);\n\trcu_assign_pointer(sta->sta.link[link_id], link_sta);\n\n\tlink_sta->smps_mode = IEEE80211_SMPS_OFF;\n\tlink_sta->agg.max_rc_amsdu_len = IEEE80211_MAX_MPDU_LEN_HT_BA;\n}\n\nstatic struct sta_info *\n__sta_info_alloc(struct ieee80211_sub_if_data *sdata,\n\t\t const u8 *addr, int link_id, const u8 *link_addr,\n\t\t gfp_t gfp)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_hw *hw = &local->hw;\n\tstruct sta_info *sta;\n\tvoid *txq_data;\n\tint size;\n\tint i;\n\n\tsta = kzalloc(sizeof(*sta) + hw->sta_data_size, gfp);\n\tif (!sta)\n\t\treturn NULL;\n\n\tsta->local = local;\n\tsta->sdata = sdata;\n\n\tif (sta_info_alloc_link(local, &sta->deflink, gfp))\n\t\tgoto free;\n\n\tif (link_id >= 0) {\n\t\tsta_info_add_link(sta, link_id, &sta->deflink,\n\t\t\t\t  &sta->sta.deflink);\n\t\tsta->sta.valid_links = BIT(link_id);\n\t} else {\n\t\tsta_info_add_link(sta, 0, &sta->deflink, &sta->sta.deflink);\n\t}\n\n\tsta->sta.cur = &sta->sta.deflink.agg;\n\n\tspin_lock_init(&sta->lock);\n\tspin_lock_init(&sta->ps_lock);\n\tINIT_WORK(&sta->drv_deliver_wk, sta_deliver_ps_frames);\n\tINIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);\n\tmutex_init(&sta->ampdu_mlme.mtx);\n#ifdef CONFIG_MAC80211_MESH\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tsta->mesh = kzalloc(sizeof(*sta->mesh), gfp);\n\t\tif (!sta->mesh)\n\t\t\tgoto free;\n\t\tsta->mesh->plink_sta = sta;\n\t\tspin_lock_init(&sta->mesh->plink_lock);\n\t\tif (!sdata->u.mesh.user_mpm)\n\t\t\ttimer_setup(&sta->mesh->plink_timer, mesh_plink_timer,\n\t\t\t\t    0);\n\t\tsta->mesh->nonpeer_pm = NL80211_MESH_POWER_ACTIVE;\n\t}\n#endif\n\n\tmemcpy(sta->addr, addr, ETH_ALEN);\n\tmemcpy(sta->sta.addr, addr, ETH_ALEN);\n\tmemcpy(sta->deflink.addr, link_addr, ETH_ALEN);\n\tmemcpy(sta->sta.deflink.addr, link_addr, ETH_ALEN);\n\tsta->sta.max_rx_aggregation_subframes =\n\t\tlocal->hw.max_rx_aggregation_subframes;\n\n\t \n\n\t \n\tBUILD_BUG_ON(ARRAY_SIZE(sta->ptk) <= INVALID_PTK_KEYIDX);\n\tsta->ptk_idx = INVALID_PTK_KEYIDX;\n\n\n\tieee80211_init_frag_cache(&sta->frags);\n\n\tsta->sta_state = IEEE80211_STA_NONE;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\tsta->amsdu_mesh_control = -1;\n\n\t \n\tsta->reserved_tid = IEEE80211_TID_UNRESERVED;\n\n\tsta->last_connected = ktime_get_seconds();\n\n\tsize = sizeof(struct txq_info) +\n\t       ALIGN(hw->txq_data_size, sizeof(void *));\n\n\ttxq_data = kcalloc(ARRAY_SIZE(sta->sta.txq), size, gfp);\n\tif (!txq_data)\n\t\tgoto free;\n\n\tfor (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {\n\t\tstruct txq_info *txq = txq_data + i * size;\n\n\t\t \n\t\tieee80211_txq_init(sdata, sta, txq, i);\n\t}\n\n\tif (sta_prepare_rate_control(local, sta, gfp))\n\t\tgoto free_txq;\n\n\tsta->airtime_weight = IEEE80211_DEFAULT_AIRTIME_WEIGHT;\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tskb_queue_head_init(&sta->ps_tx_buf[i]);\n\t\tskb_queue_head_init(&sta->tx_filtered[i]);\n\t\tsta->airtime[i].deficit = sta->airtime_weight;\n\t\tatomic_set(&sta->airtime[i].aql_tx_pending, 0);\n\t\tsta->airtime[i].aql_limit_low = local->aql_txq_limit_low[i];\n\t\tsta->airtime[i].aql_limit_high = local->aql_txq_limit_high[i];\n\t}\n\n\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\n\t\tsta->last_seq_ctrl[i] = cpu_to_le16(USHRT_MAX);\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tu32 mandatory = 0;\n\t\tint r;\n\n\t\tif (!hw->wiphy->bands[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NL80211_BAND_2GHZ:\n\t\tcase NL80211_BAND_LC:\n\t\t\t \n\t\t\tmandatory = IEEE80211_RATE_MANDATORY_B |\n\t\t\t\t    IEEE80211_RATE_MANDATORY_G;\n\t\t\tbreak;\n\t\tcase NL80211_BAND_5GHZ:\n\t\t\tmandatory = IEEE80211_RATE_MANDATORY_A;\n\t\t\tbreak;\n\t\tcase NL80211_BAND_60GHZ:\n\t\t\tWARN_ON(1);\n\t\t\tmandatory = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (r = 0; r < hw->wiphy->bands[i]->n_bitrates; r++) {\n\t\t\tstruct ieee80211_rate *rate;\n\n\t\t\trate = &hw->wiphy->bands[i]->bitrates[r];\n\n\t\t\tif (!(rate->flags & mandatory))\n\t\t\t\tcontinue;\n\t\t\tsta->sta.deflink.supp_rates[i] |= BIT(r);\n\t\t}\n\t}\n\n\tsta->cparams.ce_threshold = CODEL_DISABLED_THRESHOLD;\n\tsta->cparams.target = MS2TIME(20);\n\tsta->cparams.interval = MS2TIME(100);\n\tsta->cparams.ecn = true;\n\tsta->cparams.ce_threshold_selector = 0;\n\tsta->cparams.ce_threshold_mask = 0;\n\n\tsta_dbg(sdata, \"Allocated STA %pM\\n\", sta->sta.addr);\n\n\treturn sta;\n\nfree_txq:\n\tkfree(to_txq_info(sta->sta.txq[0]));\nfree:\n\tsta_info_free_link(&sta->deflink);\n#ifdef CONFIG_MAC80211_MESH\n\tkfree(sta->mesh);\n#endif\n\tkfree(sta);\n\treturn NULL;\n}\n\nstruct sta_info *sta_info_alloc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\treturn __sta_info_alloc(sdata, addr, -1, addr, gfp);\n}\n\nstruct sta_info *sta_info_alloc_with_link(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  const u8 *mld_addr,\n\t\t\t\t\t  unsigned int link_id,\n\t\t\t\t\t  const u8 *link_addr,\n\t\t\t\t\t  gfp_t gfp)\n{\n\treturn __sta_info_alloc(sdata, mld_addr, link_id, link_addr, gfp);\n}\n\nstatic int sta_info_insert_check(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\n\t \n\tif (unlikely(!ieee80211_sdata_running(sdata)))\n\t\treturn -ENETDOWN;\n\n\tif (WARN_ON(ether_addr_equal(sta->sta.addr, sdata->vif.addr) ||\n\t\t    !is_valid_ether_addr(sta->sta.addr)))\n\t\treturn -EINVAL;\n\n\t \n\trcu_read_lock();\n\tlockdep_assert_held(&sdata->local->sta_mtx);\n\tif (ieee80211_hw_check(&sdata->local->hw, NEEDS_UNIQUE_STA_ADDR) &&\n\t    ieee80211_find_sta_by_ifaddr(&sdata->local->hw, sta->addr, NULL)) {\n\t\trcu_read_unlock();\n\t\treturn -ENOTUNIQ;\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int sta_info_insert_drv_state(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct sta_info *sta)\n{\n\tenum ieee80211_sta_state state;\n\tint err = 0;\n\n\tfor (state = IEEE80211_STA_NOTEXIST; state < sta->sta_state; state++) {\n\t\terr = drv_sta_state(local, sdata, sta, state, state + 1);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (!err) {\n\t\t \n\t\tif (!local->ops->sta_add)\n\t\t\tsta->uploaded = true;\n\t\treturn 0;\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tsdata_info(sdata,\n\t\t\t   \"failed to move IBSS STA %pM to state %d (%d) - keeping it anyway\\n\",\n\t\t\t   sta->sta.addr, state + 1, err);\n\t\terr = 0;\n\t}\n\n\t \n\tfor (; state > IEEE80211_STA_NOTEXIST; state--)\n\t\tWARN_ON(drv_sta_state(local, sdata, sta, state, state - 1));\n\n\treturn err;\n}\n\nstatic void\nieee80211_recalc_p2p_go_ps_allowed(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tbool allow_p2p_go_ps = sdata->vif.p2p;\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata ||\n\t\t    !test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\t\tcontinue;\n\t\tif (!sta->sta.support_p2p_ps) {\n\t\t\tallow_p2p_go_ps = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (allow_p2p_go_ps != sdata->vif.bss_conf.allow_p2p_go_ps) {\n\t\tsdata->vif.bss_conf.allow_p2p_go_ps = allow_p2p_go_ps;\n\t\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t\t  BSS_CHANGED_P2P_PS);\n\t}\n}\n\n \nstatic int sta_info_insert_finish(struct sta_info *sta) __acquires(RCU)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct station_info *sinfo = NULL;\n\tint err = 0;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t \n\tif (sta_info_get_bss(sdata, sta->sta.addr)) {\n\t\terr = -EEXIST;\n\t\tgoto out_cleanup;\n\t}\n\n\tsinfo = kzalloc(sizeof(struct station_info), GFP_KERNEL);\n\tif (!sinfo) {\n\t\terr = -ENOMEM;\n\t\tgoto out_cleanup;\n\t}\n\n\tlocal->num_sta++;\n\tlocal->sta_generation++;\n\tsmp_mb();\n\n\t \n\tset_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\n\t \n\terr = sta_info_hash_add(local, sta);\n\tif (err)\n\t\tgoto out_drop_sta;\n\n\tif (sta->sta.valid_links) {\n\t\terr = link_sta_info_hash_add(local, &sta->deflink);\n\t\tif (err) {\n\t\t\tsta_info_hash_del(local, sta);\n\t\t\tgoto out_drop_sta;\n\t\t}\n\t}\n\n\tlist_add_tail_rcu(&sta->list, &local->sta_list);\n\n\t \n\tif (sta->sta_state >= IEEE80211_STA_ASSOC) {\n\t\tieee80211_recalc_min_chandef(sta->sdata, -1);\n\t\tif (!sta->sta.support_p2p_ps)\n\t\t\tieee80211_recalc_p2p_go_ps_allowed(sta->sdata);\n\t}\n\n\t \n\terr = sta_info_insert_drv_state(local, sdata, sta);\n\tif (err)\n\t\tgoto out_remove;\n\n\tset_sta_flag(sta, WLAN_STA_INSERTED);\n\n\t \n\tclear_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\n\tieee80211_sta_debugfs_add(sta);\n\trate_control_add_sta_debugfs(sta);\n\tif (sta->sta.valid_links) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sta->link); i++) {\n\t\t\tstruct link_sta_info *link_sta;\n\n\t\t\tlink_sta = rcu_dereference_protected(sta->link[i],\n\t\t\t\t\t\t\t     lockdep_is_held(&local->sta_mtx));\n\n\t\t\tif (!link_sta)\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_link_sta_debugfs_add(link_sta);\n\t\t\tif (sdata->vif.active_links & BIT(i))\n\t\t\t\tieee80211_link_sta_debugfs_drv_add(link_sta);\n\t\t}\n\t} else {\n\t\tieee80211_link_sta_debugfs_add(&sta->deflink);\n\t\tieee80211_link_sta_debugfs_drv_add(&sta->deflink);\n\t}\n\n\tsinfo->generation = local->sta_generation;\n\tcfg80211_new_sta(sdata->dev, sta->sta.addr, sinfo, GFP_KERNEL);\n\tkfree(sinfo);\n\n\tsta_dbg(sdata, \"Inserted STA %pM\\n\", sta->sta.addr);\n\n\t \n\trcu_read_lock();\n\tmutex_unlock(&local->sta_mtx);\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tmesh_accept_plinks_update(sdata);\n\n\treturn 0;\n out_remove:\n\tif (sta->sta.valid_links)\n\t\tlink_sta_info_hash_del(local, &sta->deflink);\n\tsta_info_hash_del(local, sta);\n\tlist_del_rcu(&sta->list);\n out_drop_sta:\n\tlocal->num_sta--;\n\tsynchronize_net();\n out_cleanup:\n\tcleanup_single_sta(sta);\n\tmutex_unlock(&local->sta_mtx);\n\tkfree(sinfo);\n\trcu_read_lock();\n\treturn err;\n}\n\nint sta_info_insert_rcu(struct sta_info *sta) __acquires(RCU)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tint err;\n\n\tmight_sleep();\n\n\tmutex_lock(&local->sta_mtx);\n\n\terr = sta_info_insert_check(sta);\n\tif (err) {\n\t\tsta_info_free(local, sta);\n\t\tmutex_unlock(&local->sta_mtx);\n\t\trcu_read_lock();\n\t\treturn err;\n\t}\n\n\treturn sta_info_insert_finish(sta);\n}\n\nint sta_info_insert(struct sta_info *sta)\n{\n\tint err = sta_info_insert_rcu(sta);\n\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic inline void __bss_tim_set(u8 *tim, u16 id)\n{\n\t \n\ttim[id / 8] |= (1 << (id % 8));\n}\n\nstatic inline void __bss_tim_clear(u8 *tim, u16 id)\n{\n\t \n\ttim[id / 8] &= ~(1 << (id % 8));\n}\n\nstatic inline bool __bss_tim_get(u8 *tim, u16 id)\n{\n\t \n\treturn tim[id / 8] & (1 << (id % 8));\n}\n\nstatic unsigned long ieee80211_tids_for_ac(int ac)\n{\n\t \n\tswitch (ac) {\n\tcase IEEE80211_AC_VO:\n\t\treturn BIT(6) | BIT(7);\n\tcase IEEE80211_AC_VI:\n\t\treturn BIT(4) | BIT(5);\n\tcase IEEE80211_AC_BE:\n\t\treturn BIT(0) | BIT(3);\n\tcase IEEE80211_AC_BK:\n\t\treturn BIT(1) | BIT(2);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n}\n\nstatic void __sta_info_recalc_tim(struct sta_info *sta, bool ignore_pending)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ps_data *ps;\n\tbool indicate_tim = false;\n\tu8 ignore_for_tim = sta->sta.uapsd_queues;\n\tint ac;\n\tu16 id = sta->sta.aid;\n\n\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (WARN_ON_ONCE(!sta->sdata->bss))\n\t\t\treturn;\n\n\t\tps = &sta->sdata->bss->ps;\n#ifdef CONFIG_MAC80211_MESH\n\t} else if (ieee80211_vif_is_mesh(&sta->sdata->vif)) {\n\t\tps = &sta->sdata->u.mesh.ps;\n#endif\n\t} else {\n\t\treturn;\n\t}\n\n\t \n\tif (ieee80211_hw_check(&local->hw, AP_LINK_PS) && !local->ops->set_tim)\n\t\treturn;\n\n\tif (sta->dead)\n\t\tgoto done;\n\n\t \n\tif (ignore_for_tim == BIT(IEEE80211_NUM_ACS) - 1)\n\t\tignore_for_tim = 0;\n\n\tif (ignore_pending)\n\t\tignore_for_tim = BIT(IEEE80211_NUM_ACS) - 1;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tunsigned long tids;\n\n\t\tif (ignore_for_tim & ieee80211_ac_to_qos_mask[ac])\n\t\t\tcontinue;\n\n\t\tindicate_tim |= !skb_queue_empty(&sta->tx_filtered[ac]) ||\n\t\t\t\t!skb_queue_empty(&sta->ps_tx_buf[ac]);\n\t\tif (indicate_tim)\n\t\t\tbreak;\n\n\t\ttids = ieee80211_tids_for_ac(ac);\n\n\t\tindicate_tim |=\n\t\t\tsta->driver_buffered_tids & tids;\n\t\tindicate_tim |=\n\t\t\tsta->txq_buffered_tids & tids;\n\t}\n\n done:\n\tspin_lock_bh(&local->tim_lock);\n\n\tif (indicate_tim == __bss_tim_get(ps->tim, id))\n\t\tgoto out_unlock;\n\n\tif (indicate_tim)\n\t\t__bss_tim_set(ps->tim, id);\n\telse\n\t\t__bss_tim_clear(ps->tim, id);\n\n\tif (local->ops->set_tim && !WARN_ON(sta->dead)) {\n\t\tlocal->tim_in_locked_section = true;\n\t\tdrv_set_tim(local, &sta->sta, indicate_tim);\n\t\tlocal->tim_in_locked_section = false;\n\t}\n\nout_unlock:\n\tspin_unlock_bh(&local->tim_lock);\n}\n\nvoid sta_info_recalc_tim(struct sta_info *sta)\n{\n\t__sta_info_recalc_tim(sta, false);\n}\n\nstatic bool sta_info_buffer_expired(struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info;\n\tint timeout;\n\n\tif (!skb)\n\t\treturn false;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\t \n\ttimeout = (sta->listen_interval *\n\t\t   sta->sdata->vif.bss_conf.beacon_int *\n\t\t   32 / 15625) * HZ;\n\tif (timeout < STA_TX_BUFFER_EXPIRE)\n\t\ttimeout = STA_TX_BUFFER_EXPIRE;\n\treturn time_after(jiffies, info->control.jiffies + timeout);\n}\n\n\nstatic bool sta_info_cleanup_expire_buffered_ac(struct ieee80211_local *local,\n\t\t\t\t\t\tstruct sta_info *sta, int ac)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\n\t \n\tfor (;;) {\n\t\tspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\n\t\tskb = skb_peek(&sta->tx_filtered[ac]);\n\t\tif (sta_info_buffer_expired(sta, skb))\n\t\t\tskb = __skb_dequeue(&sta->tx_filtered[ac]);\n\t\telse\n\t\t\tskb = NULL;\n\t\tspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\n\n\t\t \n\t\tif (!skb)\n\t\t\tbreak;\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t}\n\n\t \n\tfor (;;) {\n\t\tspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\n\t\tskb = skb_peek(&sta->ps_tx_buf[ac]);\n\t\tif (sta_info_buffer_expired(sta, skb))\n\t\t\tskb = __skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\telse\n\t\t\tskb = NULL;\n\t\tspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\n\n\t\t \n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tlocal->total_ps_buffered--;\n\t\tps_dbg(sta->sdata, \"Buffered frame expired (STA %pM)\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t}\n\n\t \n\tsta_info_recalc_tim(sta);\n\n\t \n\treturn !(skb_queue_empty(&sta->ps_tx_buf[ac]) &&\n\t\t skb_queue_empty(&sta->tx_filtered[ac]));\n}\n\nstatic bool sta_info_cleanup_expire_buffered(struct ieee80211_local *local,\n\t\t\t\t\t     struct sta_info *sta)\n{\n\tbool have_buffered = false;\n\tint ac;\n\n\t \n\tif (!sta->sdata->bss &&\n\t    !ieee80211_vif_is_mesh(&sta->sdata->vif))\n\t\treturn false;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\thave_buffered |=\n\t\t\tsta_info_cleanup_expire_buffered_ac(local, sta, ac);\n\n\treturn have_buffered;\n}\n\nstatic int __must_check __sta_info_destroy_part1(struct sta_info *sta)\n{\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tint ret, i;\n\n\tmight_sleep();\n\n\tif (!sta)\n\t\treturn -ENOENT;\n\n\tlocal = sta->local;\n\tsdata = sta->sdata;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t \n\tset_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\tieee80211_sta_tear_down_BA_sessions(sta, AGG_STOP_DESTROY_STA);\n\n\t \n\tdrv_sync_rx_queues(local, sta);\n\n\tfor (i = 0; i < ARRAY_SIZE(sta->link); i++) {\n\t\tstruct link_sta_info *link_sta;\n\n\t\tif (!(sta->sta.valid_links & BIT(i)))\n\t\t\tcontinue;\n\n\t\tlink_sta = rcu_dereference_protected(sta->link[i],\n\t\t\t\t\t\t     lockdep_is_held(&local->sta_mtx));\n\n\t\tlink_sta_info_hash_del(local, link_sta);\n\t}\n\n\tret = sta_info_hash_del(local, sta);\n\tif (WARN_ON(ret))\n\t\treturn ret;\n\n\t \n\tif (test_sta_flag(sta, WLAN_STA_TDLS_OFF_CHANNEL)) {\n\t\tdrv_tdls_cancel_channel_switch(local, sdata, &sta->sta);\n\t\tclear_sta_flag(sta, WLAN_STA_TDLS_OFF_CHANNEL);\n\t}\n\n\tlist_del_rcu(&sta->list);\n\tsta->removed = true;\n\n\tif (sta->uploaded)\n\t\tdrv_sta_pre_rcu_remove(local, sta->sdata, sta);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t    rcu_access_pointer(sdata->u.vlan.sta) == sta)\n\t\tRCU_INIT_POINTER(sdata->u.vlan.sta, NULL);\n\n\treturn 0;\n}\n\nstatic int _sta_info_move_state(struct sta_info *sta,\n\t\t\t\tenum ieee80211_sta_state new_state,\n\t\t\t\tbool recalc)\n{\n\tmight_sleep();\n\n\tif (sta->sta_state == new_state)\n\t\treturn 0;\n\n\t \n\n\tswitch (new_state) {\n\tcase IEEE80211_STA_NONE:\n\t\tif (sta->sta_state != IEEE80211_STA_AUTH)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_AUTH:\n\t\tif (sta->sta_state != IEEE80211_STA_NONE &&\n\t\t    sta->sta_state != IEEE80211_STA_ASSOC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_ASSOC:\n\t\tif (sta->sta_state != IEEE80211_STA_AUTH &&\n\t\t    sta->sta_state != IEEE80211_STA_AUTHORIZED)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_AUTHORIZED:\n\t\tif (sta->sta_state != IEEE80211_STA_ASSOC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"invalid state %d\", new_state);\n\t\treturn -EINVAL;\n\t}\n\n\tsta_dbg(sta->sdata, \"moving STA %pM to state %d\\n\",\n\t\tsta->sta.addr, new_state);\n\n\t \n\tif (test_sta_flag(sta, WLAN_STA_INSERTED)) {\n\t\tint err = drv_sta_state(sta->local, sta->sdata, sta,\n\t\t\t\t\tsta->sta_state, new_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\n\tswitch (new_state) {\n\tcase IEEE80211_STA_NONE:\n\t\tif (sta->sta_state == IEEE80211_STA_AUTH)\n\t\t\tclear_bit(WLAN_STA_AUTH, &sta->_flags);\n\t\tbreak;\n\tcase IEEE80211_STA_AUTH:\n\t\tif (sta->sta_state == IEEE80211_STA_NONE) {\n\t\t\tset_bit(WLAN_STA_AUTH, &sta->_flags);\n\t\t} else if (sta->sta_state == IEEE80211_STA_ASSOC) {\n\t\t\tclear_bit(WLAN_STA_ASSOC, &sta->_flags);\n\t\t\tif (recalc) {\n\t\t\t\tieee80211_recalc_min_chandef(sta->sdata, -1);\n\t\t\t\tif (!sta->sta.support_p2p_ps)\n\t\t\t\t\tieee80211_recalc_p2p_go_ps_allowed(sta->sdata);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STA_ASSOC:\n\t\tif (sta->sta_state == IEEE80211_STA_AUTH) {\n\t\t\tset_bit(WLAN_STA_ASSOC, &sta->_flags);\n\t\t\tsta->assoc_at = ktime_get_boottime_ns();\n\t\t\tif (recalc) {\n\t\t\t\tieee80211_recalc_min_chandef(sta->sdata, -1);\n\t\t\t\tif (!sta->sta.support_p2p_ps)\n\t\t\t\t\tieee80211_recalc_p2p_go_ps_allowed(sta->sdata);\n\t\t\t}\n\t\t} else if (sta->sta_state == IEEE80211_STA_AUTHORIZED) {\n\t\t\tieee80211_vif_dec_num_mcast(sta->sdata);\n\t\t\tclear_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\n\t\t\tieee80211_clear_fast_xmit(sta);\n\t\t\tieee80211_clear_fast_rx(sta);\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STA_AUTHORIZED:\n\t\tif (sta->sta_state == IEEE80211_STA_ASSOC) {\n\t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n\t\t\tset_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\n\t\t\tieee80211_check_fast_xmit(sta);\n\t\t\tieee80211_check_fast_rx(sta);\n\t\t}\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n\t\t    sta->sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tcfg80211_send_layer2_update(sta->sdata->dev,\n\t\t\t\t\t\t    sta->sta.addr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsta->sta_state = new_state;\n\n\treturn 0;\n}\n\nint sta_info_move_state(struct sta_info *sta,\n\t\t\tenum ieee80211_sta_state new_state)\n{\n\treturn _sta_info_move_state(sta, new_state, true);\n}\n\nstatic void __sta_info_destroy_part2(struct sta_info *sta, bool recalc)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct station_info *sinfo;\n\tint ret;\n\n\t \n\n\tmight_sleep();\n\tlockdep_assert_held(&local->sta_mtx);\n\n\tif (sta->sta_state == IEEE80211_STA_AUTHORIZED) {\n\t\tret = _sta_info_move_state(sta, IEEE80211_STA_ASSOC, recalc);\n\t\tWARN_ON_ONCE(ret);\n\t}\n\n\t \n\tif (local->ops->set_key) {\n\t\tif (local->ops->flush_sta)\n\t\t\tdrv_flush_sta(local, sta->sdata, sta);\n\t\telse\n\t\t\tieee80211_flush_queues(local, sta->sdata, false);\n\t}\n\n\t \n\tieee80211_free_sta_keys(local, sta);\n\n\t \n\t__sta_info_recalc_tim(sta, true);\n\n\tsta->dead = true;\n\n\tlocal->num_sta--;\n\tlocal->sta_generation++;\n\n\twhile (sta->sta_state > IEEE80211_STA_NONE) {\n\t\tret = _sta_info_move_state(sta, sta->sta_state - 1, recalc);\n\t\tif (ret) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sta->uploaded) {\n\t\tret = drv_sta_state(local, sdata, sta, IEEE80211_STA_NONE,\n\t\t\t\t    IEEE80211_STA_NOTEXIST);\n\t\tWARN_ON_ONCE(ret != 0);\n\t}\n\n\tsta_dbg(sdata, \"Removed STA %pM\\n\", sta->sta.addr);\n\n\tsinfo = kzalloc(sizeof(*sinfo), GFP_KERNEL);\n\tif (sinfo)\n\t\tsta_set_sinfo(sta, sinfo, true);\n\tcfg80211_del_sta_sinfo(sdata->dev, sta->sta.addr, sinfo, GFP_KERNEL);\n\tkfree(sinfo);\n\n\tieee80211_sta_debugfs_remove(sta);\n\n\tieee80211_destroy_frag_cache(&sta->frags);\n\n\tcleanup_single_sta(sta);\n}\n\nint __must_check __sta_info_destroy(struct sta_info *sta)\n{\n\tint err = __sta_info_destroy_part1(sta);\n\n\tif (err)\n\t\treturn err;\n\n\tsynchronize_net();\n\n\t__sta_info_destroy_part2(sta, true);\n\n\treturn 0;\n}\n\nint sta_info_destroy_addr(struct ieee80211_sub_if_data *sdata, const u8 *addr)\n{\n\tstruct sta_info *sta;\n\tint ret;\n\n\tmutex_lock(&sdata->local->sta_mtx);\n\tsta = sta_info_get(sdata, addr);\n\tret = __sta_info_destroy(sta);\n\tmutex_unlock(&sdata->local->sta_mtx);\n\n\treturn ret;\n}\n\nint sta_info_destroy_addr_bss(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *addr)\n{\n\tstruct sta_info *sta;\n\tint ret;\n\n\tmutex_lock(&sdata->local->sta_mtx);\n\tsta = sta_info_get_bss(sdata, addr);\n\tret = __sta_info_destroy(sta);\n\tmutex_unlock(&sdata->local->sta_mtx);\n\n\treturn ret;\n}\n\nstatic void sta_info_cleanup(struct timer_list *t)\n{\n\tstruct ieee80211_local *local = from_timer(local, t, sta_cleanup);\n\tstruct sta_info *sta;\n\tbool timer_needed = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list)\n\t\tif (sta_info_cleanup_expire_buffered(local, sta))\n\t\t\ttimer_needed = true;\n\trcu_read_unlock();\n\n\tif (local->quiescing)\n\t\treturn;\n\n\tif (!timer_needed)\n\t\treturn;\n\n\tmod_timer(&local->sta_cleanup,\n\t\t  round_jiffies(jiffies + STA_INFO_CLEANUP_INTERVAL));\n}\n\nint sta_info_init(struct ieee80211_local *local)\n{\n\tint err;\n\n\terr = rhltable_init(&local->sta_hash, &sta_rht_params);\n\tif (err)\n\t\treturn err;\n\n\terr = rhltable_init(&local->link_sta_hash, &link_sta_rht_params);\n\tif (err) {\n\t\trhltable_destroy(&local->sta_hash);\n\t\treturn err;\n\t}\n\n\tspin_lock_init(&local->tim_lock);\n\tmutex_init(&local->sta_mtx);\n\tINIT_LIST_HEAD(&local->sta_list);\n\n\ttimer_setup(&local->sta_cleanup, sta_info_cleanup, 0);\n\treturn 0;\n}\n\nvoid sta_info_stop(struct ieee80211_local *local)\n{\n\tdel_timer_sync(&local->sta_cleanup);\n\trhltable_destroy(&local->sta_hash);\n\trhltable_destroy(&local->link_sta_hash);\n}\n\n\nint __sta_info_flush(struct ieee80211_sub_if_data *sdata, bool vlans)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta, *tmp;\n\tLIST_HEAD(free_list);\n\tint ret = 0;\n\n\tmight_sleep();\n\n\tWARN_ON(vlans && sdata->vif.type != NL80211_IFTYPE_AP);\n\tWARN_ON(vlans && !sdata->bss);\n\n\tmutex_lock(&local->sta_mtx);\n\tlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\n\t\tif (sdata == sta->sdata ||\n\t\t    (vlans && sdata->bss == sta->sdata->bss)) {\n\t\t\tif (!WARN_ON(__sta_info_destroy_part1(sta)))\n\t\t\t\tlist_add(&sta->free_list, &free_list);\n\t\t\tret++;\n\t\t}\n\t}\n\n\tif (!list_empty(&free_list)) {\n\t\tbool support_p2p_ps = true;\n\n\t\tsynchronize_net();\n\t\tlist_for_each_entry_safe(sta, tmp, &free_list, free_list) {\n\t\t\tif (!sta->sta.support_p2p_ps)\n\t\t\t\tsupport_p2p_ps = false;\n\t\t\t__sta_info_destroy_part2(sta, false);\n\t\t}\n\n\t\tieee80211_recalc_min_chandef(sdata, -1);\n\t\tif (!support_p2p_ps)\n\t\t\tieee80211_recalc_p2p_go_ps_allowed(sdata);\n\t}\n\tmutex_unlock(&local->sta_mtx);\n\n\treturn ret;\n}\n\nvoid ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,\n\t\t\t  unsigned long exp_time)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta, *tmp;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\n\t\tunsigned long last_active = ieee80211_sta_last_active(sta);\n\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\n\t\tif (time_is_before_jiffies(last_active + exp_time)) {\n\t\t\tsta_dbg(sta->sdata, \"expiring inactive STA %pM\\n\",\n\t\t\t\tsta->sta.addr);\n\n\t\t\tif (ieee80211_vif_is_mesh(&sdata->vif) &&\n\t\t\t    test_sta_flag(sta, WLAN_STA_PS_STA))\n\t\t\t\tatomic_dec(&sdata->u.mesh.ps.num_sta_ps);\n\n\t\t\tWARN_ON(__sta_info_destroy(sta));\n\t\t}\n\t}\n\n\tmutex_unlock(&local->sta_mtx);\n}\n\nstruct ieee80211_sta *ieee80211_find_sta_by_ifaddr(struct ieee80211_hw *hw,\n\t\t\t\t\t\t   const u8 *addr,\n\t\t\t\t\t\t   const u8 *localaddr)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct rhlist_head *tmp;\n\tstruct sta_info *sta;\n\n\t \n\tfor_each_sta_info(local, addr, sta, tmp) {\n\t\tif (localaddr &&\n\t\t    !ether_addr_equal(sta->sdata->vif.addr, localaddr))\n\t\t\tcontinue;\n\t\tif (!sta->uploaded)\n\t\t\treturn NULL;\n\t\treturn &sta->sta;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ieee80211_find_sta_by_ifaddr);\n\nstruct ieee80211_sta *ieee80211_find_sta(struct ieee80211_vif *vif,\n\t\t\t\t\t const u8 *addr)\n{\n\tstruct sta_info *sta;\n\n\tif (!vif)\n\t\treturn NULL;\n\n\tsta = sta_info_get_bss(vif_to_sdata(vif), addr);\n\tif (!sta)\n\t\treturn NULL;\n\n\tif (!sta->uploaded)\n\t\treturn NULL;\n\n\treturn &sta->sta;\n}\nEXPORT_SYMBOL(ieee80211_find_sta);\n\n \nvoid ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff_head pending;\n\tint filtered = 0, buffered = 0, ac, i;\n\tunsigned long flags;\n\tstruct ps_data *ps;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tsdata = container_of(sdata->bss, struct ieee80211_sub_if_data,\n\t\t\t\t     u.ap);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tps = &sdata->bss->ps;\n\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tps = &sdata->u.mesh.ps;\n\telse\n\t\treturn;\n\n\tclear_sta_flag(sta, WLAN_STA_SP);\n\n\tBUILD_BUG_ON(BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1);\n\tsta->driver_buffered_tids = 0;\n\tsta->txq_buffered_tids = 0;\n\n\tif (!ieee80211_hw_check(&local->hw, AP_LINK_PS))\n\t\tdrv_sta_notify(local, sdata, STA_NOTIFY_AWAKE, &sta->sta);\n\n\tfor (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {\n\t\tif (!sta->sta.txq[i] || !txq_has_queue(sta->sta.txq[i]))\n\t\t\tcontinue;\n\n\t\tschedule_and_wake_txq(local, to_txq_info(sta->sta.txq[i]));\n\t}\n\n\tskb_queue_head_init(&pending);\n\n\t \n\tspin_lock(&sta->ps_lock);\n\t \n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tint count = skb_queue_len(&pending), tmp;\n\n\t\tspin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tfiltered += tmp - count;\n\t\tcount = tmp;\n\n\t\tspin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);\n\t\tskb_queue_splice_tail_init(&sta->ps_tx_buf[ac], &pending);\n\t\tspin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);\n\t\ttmp = skb_queue_len(&pending);\n\t\tbuffered += tmp - count;\n\t}\n\n\tieee80211_add_pending_skbs(local, &pending);\n\n\t \n\tclear_sta_flag(sta, WLAN_STA_PS_DELIVER);\n\n\t \n\tclear_sta_flag(sta, WLAN_STA_PSPOLL);\n\tclear_sta_flag(sta, WLAN_STA_UAPSD);\n\tspin_unlock(&sta->ps_lock);\n\n\tatomic_dec(&ps->num_sta_ps);\n\n\tlocal->total_ps_buffered -= buffered;\n\n\tsta_info_recalc_tim(sta);\n\n\tps_dbg(sdata,\n\t       \"STA %pM aid %d sending %d filtered/%d PS frames since STA woke up\\n\",\n\t       sta->sta.addr, sta->sta.aid, filtered, buffered);\n\n\tieee80211_check_fast_xmit(sta);\n}\n\nstatic void ieee80211_send_null_response(struct sta_info *sta, int tid,\n\t\t\t\t\t enum ieee80211_frame_release_type reason,\n\t\t\t\t\t bool call_driver, bool more_data)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_qos_hdr *nullfunc;\n\tstruct sk_buff *skb;\n\tint size = sizeof(*nullfunc);\n\t__le16 fc;\n\tbool qos = sta->sta.wme;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tif (qos) {\n\t\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t IEEE80211_STYPE_QOS_NULLFUNC |\n\t\t\t\t IEEE80211_FCTL_FROMDS);\n\t} else {\n\t\tsize -= 2;\n\t\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t IEEE80211_FCTL_FROMDS);\n\t}\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + size);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tnullfunc = skb_put(skb, size);\n\tnullfunc->frame_control = fc;\n\tnullfunc->duration_id = 0;\n\tmemcpy(nullfunc->addr1, sta->sta.addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr2, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr3, sdata->vif.addr, ETH_ALEN);\n\tnullfunc->seq_ctrl = 0;\n\n\tskb->priority = tid;\n\tskb_set_queue_mapping(skb, ieee802_1d_to_ac[tid]);\n\tif (qos) {\n\t\tnullfunc->qos_ctrl = cpu_to_le16(tid);\n\n\t\tif (reason == IEEE80211_FRAME_RELEASE_UAPSD) {\n\t\t\tnullfunc->qos_ctrl |=\n\t\t\t\tcpu_to_le16(IEEE80211_QOS_CTL_EOSP);\n\t\t\tif (more_data)\n\t\t\t\tnullfunc->frame_control |=\n\t\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t}\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\t \n\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER |\n\t\t       IEEE80211_TX_STATUS_EOSP |\n\t\t       IEEE80211_TX_CTL_REQ_TX_STATUS;\n\n\tinfo->control.flags |= IEEE80211_TX_CTRL_PS_RESPONSE;\n\n\tif (call_driver)\n\t\tdrv_allow_buffered_frames(local, sta, BIT(tid), 1,\n\t\t\t\t\t  reason, false);\n\n\tskb->dev = sdata->dev;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tif (WARN_ON(!chanctx_conf)) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tinfo->band = chanctx_conf->def.chan->band;\n\tieee80211_xmit(sdata, sta, skb);\n\trcu_read_unlock();\n}\n\nstatic int find_highest_prio_tid(unsigned long tids)\n{\n\t \n\tif (tids & 0xF8)\n\t\treturn fls(tids) - 1;\n\t \n\tif (tids & BIT(0))\n\t\treturn 0;\n\treturn fls(tids) - 1;\n}\n\n \nstatic bool\nieee80211_sta_ps_more_data(struct sta_info *sta, u8 ignored_acs,\n\t\t\t   enum ieee80211_frame_release_type reason,\n\t\t\t   unsigned long driver_release_tids)\n{\n\tint ac;\n\n\t \n\tif (reason == IEEE80211_FRAME_RELEASE_PSPOLL &&\n\t    hweight16(driver_release_tids) > 1)\n\t\treturn true;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tif (ignored_acs & ieee80211_ac_to_qos_mask[ac])\n\t\t\tcontinue;\n\n\t\tif (!skb_queue_empty(&sta->tx_filtered[ac]) ||\n\t\t    !skb_queue_empty(&sta->ps_tx_buf[ac]))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void\nieee80211_sta_ps_get_frames(struct sta_info *sta, int n_frames, u8 ignored_acs,\n\t\t\t    enum ieee80211_frame_release_type reason,\n\t\t\t    struct sk_buff_head *frames,\n\t\t\t    unsigned long *driver_release_tids)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tint ac;\n\n\t \n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tunsigned long tids;\n\n\t\tif (ignored_acs & ieee80211_ac_to_qos_mask[ac])\n\t\t\tcontinue;\n\n\t\ttids = ieee80211_tids_for_ac(ac);\n\n\t\t \n\t\tif (skb_queue_empty(frames)) {\n\t\t\t*driver_release_tids |=\n\t\t\t\tsta->driver_buffered_tids & tids;\n\t\t\t*driver_release_tids |= sta->txq_buffered_tids & tids;\n\t\t}\n\n\t\tif (!*driver_release_tids) {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\twhile (n_frames > 0) {\n\t\t\t\tskb = skb_dequeue(&sta->tx_filtered[ac]);\n\t\t\t\tif (!skb) {\n\t\t\t\t\tskb = skb_dequeue(\n\t\t\t\t\t\t&sta->ps_tx_buf[ac]);\n\t\t\t\t\tif (skb)\n\t\t\t\t\t\tlocal->total_ps_buffered--;\n\t\t\t\t}\n\t\t\t\tif (!skb)\n\t\t\t\t\tbreak;\n\t\t\t\tn_frames--;\n\t\t\t\t__skb_queue_tail(frames, skb);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!skb_queue_empty(&sta->tx_filtered[ac]) ||\n\t\t    !skb_queue_empty(&sta->ps_tx_buf[ac]))\n\t\t\tbreak;\n\t}\n}\n\nstatic void\nieee80211_sta_ps_deliver_response(struct sta_info *sta,\n\t\t\t\t  int n_frames, u8 ignored_acs,\n\t\t\t\t  enum ieee80211_frame_release_type reason)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tunsigned long driver_release_tids = 0;\n\tstruct sk_buff_head frames;\n\tbool more_data;\n\n\t \n\tset_sta_flag(sta, WLAN_STA_SP);\n\n\t__skb_queue_head_init(&frames);\n\n\tieee80211_sta_ps_get_frames(sta, n_frames, ignored_acs, reason,\n\t\t\t\t    &frames, &driver_release_tids);\n\n\tmore_data = ieee80211_sta_ps_more_data(sta, ignored_acs, reason, driver_release_tids);\n\n\tif (driver_release_tids && reason == IEEE80211_FRAME_RELEASE_PSPOLL)\n\t\tdriver_release_tids =\n\t\t\tBIT(find_highest_prio_tid(driver_release_tids));\n\n\tif (skb_queue_empty(&frames) && !driver_release_tids) {\n\t\tint tid, ac;\n\n\t\t \n\n\t\t \n\t\tfor (ac = IEEE80211_AC_VO; ac < IEEE80211_NUM_ACS; ac++)\n\t\t\tif (!(ignored_acs & ieee80211_ac_to_qos_mask[ac]))\n\t\t\t\tbreak;\n\t\ttid = 7 - 2 * ac;\n\n\t\tieee80211_send_null_response(sta, tid, reason, true, false);\n\t} else if (!driver_release_tids) {\n\t\tstruct sk_buff_head pending;\n\t\tstruct sk_buff *skb;\n\t\tint num = 0;\n\t\tu16 tids = 0;\n\t\tbool need_null = false;\n\n\t\tskb_queue_head_init(&pending);\n\n\t\twhile ((skb = __skb_dequeue(&frames))) {\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\t\tstruct ieee80211_hdr *hdr = (void *) skb->data;\n\t\t\tu8 *qoshdr = NULL;\n\n\t\t\tnum++;\n\n\t\t\t \n\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER;\n\t\t\tinfo->control.flags |= IEEE80211_TX_CTRL_PS_RESPONSE;\n\n\t\t\t \n\t\t\tif (more_data || !skb_queue_empty(&frames))\n\t\t\t\thdr->frame_control |=\n\t\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t\telse\n\t\t\t\thdr->frame_control &=\n\t\t\t\t\tcpu_to_le16(~IEEE80211_FCTL_MOREDATA);\n\n\t\t\tif (ieee80211_is_data_qos(hdr->frame_control) ||\n\t\t\t    ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\t\t\tqoshdr = ieee80211_get_qos_ctl(hdr);\n\n\t\t\ttids |= BIT(skb->priority);\n\n\t\t\t__skb_queue_tail(&pending, skb);\n\n\t\t\t \n\t\t\tif (!skb_queue_empty(&frames))\n\t\t\t\tcontinue;\n\n\t\t\tif (reason != IEEE80211_FRAME_RELEASE_UAPSD) {\n\t\t\t\t \n\t\t\t\tinfo->flags |= IEEE80211_TX_STATUS_EOSP |\n\t\t\t\t\t       IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (qoshdr) {\n\t\t\t\t*qoshdr |= IEEE80211_QOS_CTL_EOSP;\n\n\t\t\t\tinfo->flags |= IEEE80211_TX_STATUS_EOSP |\n\t\t\t\t\t       IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\thdr->frame_control |=\n\t\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t\t\tneed_null = true;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdrv_allow_buffered_frames(local, sta, tids, num,\n\t\t\t\t\t  reason, more_data);\n\n\t\tieee80211_add_pending_skbs(local, &pending);\n\n\t\tif (need_null)\n\t\t\tieee80211_send_null_response(\n\t\t\t\tsta, find_highest_prio_tid(tids),\n\t\t\t\treason, false, false);\n\n\t\tsta_info_recalc_tim(sta);\n\t} else {\n\t\tint tid;\n\n\t\t \n\t\tdrv_release_buffered_frames(local, sta, driver_release_tids,\n\t\t\t\t\t    n_frames, reason, more_data);\n\n\t\t \n\n\t\tfor (tid = 0; tid < ARRAY_SIZE(sta->sta.txq); tid++) {\n\t\t\tif (!sta->sta.txq[tid] ||\n\t\t\t    !(driver_release_tids & BIT(tid)) ||\n\t\t\t    txq_has_queue(sta->sta.txq[tid]))\n\t\t\t\tcontinue;\n\n\t\t\tsta_info_recalc_tim(sta);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid ieee80211_sta_ps_deliver_poll_response(struct sta_info *sta)\n{\n\tu8 ignore_for_response = sta->sta.uapsd_queues;\n\n\t \n\tif (ignore_for_response == BIT(IEEE80211_NUM_ACS) - 1)\n\t\tignore_for_response = 0;\n\n\tieee80211_sta_ps_deliver_response(sta, 1, ignore_for_response,\n\t\t\t\t\t  IEEE80211_FRAME_RELEASE_PSPOLL);\n}\n\nvoid ieee80211_sta_ps_deliver_uapsd(struct sta_info *sta)\n{\n\tint n_frames = sta->sta.max_sp;\n\tu8 delivery_enabled = sta->sta.uapsd_queues;\n\n\t \n\tif (!delivery_enabled)\n\t\treturn;\n\n\tswitch (sta->sta.max_sp) {\n\tcase 1:\n\t\tn_frames = 2;\n\t\tbreak;\n\tcase 2:\n\t\tn_frames = 4;\n\t\tbreak;\n\tcase 3:\n\t\tn_frames = 6;\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tn_frames = 128;\n\t\tbreak;\n\t}\n\n\tieee80211_sta_ps_deliver_response(sta, n_frames, ~delivery_enabled,\n\t\t\t\t\t  IEEE80211_FRAME_RELEASE_UAPSD);\n}\n\nvoid ieee80211_sta_block_awake(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_sta *pubsta, bool block)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\ttrace_api_sta_block_awake(sta->local, pubsta, block);\n\n\tif (block) {\n\t\tset_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\t\tieee80211_clear_fast_xmit(sta);\n\t\treturn;\n\t}\n\n\tif (!test_sta_flag(sta, WLAN_STA_PS_DRIVER))\n\t\treturn;\n\n\tif (!test_sta_flag(sta, WLAN_STA_PS_STA)) {\n\t\tset_sta_flag(sta, WLAN_STA_PS_DELIVER);\n\t\tclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\t\tieee80211_queue_work(hw, &sta->drv_deliver_wk);\n\t} else if (test_sta_flag(sta, WLAN_STA_PSPOLL) ||\n\t\t   test_sta_flag(sta, WLAN_STA_UAPSD)) {\n\t\t \n\t\tclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\t\tieee80211_queue_work(hw, &sta->drv_deliver_wk);\n\t} else {\n\t\tclear_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\t\tieee80211_check_fast_xmit(sta);\n\t}\n}\nEXPORT_SYMBOL(ieee80211_sta_block_awake);\n\nvoid ieee80211_sta_eosp(struct ieee80211_sta *pubsta)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_local *local = sta->local;\n\n\ttrace_api_eosp(local, pubsta);\n\n\tclear_sta_flag(sta, WLAN_STA_SP);\n}\nEXPORT_SYMBOL(ieee80211_sta_eosp);\n\nvoid ieee80211_send_eosp_nullfunc(struct ieee80211_sta *pubsta, int tid)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tenum ieee80211_frame_release_type reason;\n\tbool more_data;\n\n\ttrace_api_send_eosp_nullfunc(sta->local, pubsta, tid);\n\n\treason = IEEE80211_FRAME_RELEASE_UAPSD;\n\tmore_data = ieee80211_sta_ps_more_data(sta, ~sta->sta.uapsd_queues,\n\t\t\t\t\t       reason, 0);\n\n\tieee80211_send_null_response(sta, tid, reason, false, more_data);\n}\nEXPORT_SYMBOL(ieee80211_send_eosp_nullfunc);\n\nvoid ieee80211_sta_set_buffered(struct ieee80211_sta *pubsta,\n\t\t\t\tu8 tid, bool buffered)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\tif (WARN_ON(tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\n\ttrace_api_sta_set_buffered(sta->local, pubsta, tid, buffered);\n\n\tif (buffered)\n\t\tset_bit(tid, &sta->driver_buffered_tids);\n\telse\n\t\tclear_bit(tid, &sta->driver_buffered_tids);\n\n\tsta_info_recalc_tim(sta);\n}\nEXPORT_SYMBOL(ieee80211_sta_set_buffered);\n\nvoid ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,\n\t\t\t\t    u32 tx_airtime, u32 rx_airtime)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_local *local = sta->sdata->local;\n\tu8 ac = ieee80211_ac_from_tid(tid);\n\tu32 airtime = 0;\n\tu32 diff;\n\n\tif (sta->local->airtime_flags & AIRTIME_USE_TX)\n\t\tairtime += tx_airtime;\n\tif (sta->local->airtime_flags & AIRTIME_USE_RX)\n\t\tairtime += rx_airtime;\n\n\tspin_lock_bh(&local->active_txq_lock[ac]);\n\tsta->airtime[ac].tx_airtime += tx_airtime;\n\tsta->airtime[ac].rx_airtime += rx_airtime;\n\n\tdiff = (u32)jiffies - sta->airtime[ac].last_active;\n\tif (diff <= AIRTIME_ACTIVE_DURATION)\n\t\tsta->airtime[ac].deficit -= airtime;\n\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n}\nEXPORT_SYMBOL(ieee80211_sta_register_airtime);\n\nvoid __ieee80211_sta_recalc_aggregates(struct sta_info *sta, u16 active_links)\n{\n\tbool first = true;\n\tint link_id;\n\n\tif (!sta->sta.valid_links || !sta->sta.mlo) {\n\t\tsta->sta.cur = &sta->sta.deflink.agg;\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tfor (link_id = 0; link_id < ARRAY_SIZE((sta)->link); link_id++) {\n\t\tstruct ieee80211_link_sta *link_sta;\n\t\tint i;\n\n\t\tif (!(active_links & BIT(link_id)))\n\t\t\tcontinue;\n\n\t\tlink_sta = rcu_dereference(sta->sta.link[link_id]);\n\t\tif (!link_sta)\n\t\t\tcontinue;\n\n\t\tif (first) {\n\t\t\tsta->cur = sta->sta.deflink.agg;\n\t\t\tfirst = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsta->cur.max_amsdu_len =\n\t\t\tmin(sta->cur.max_amsdu_len,\n\t\t\t    link_sta->agg.max_amsdu_len);\n\t\tsta->cur.max_rc_amsdu_len =\n\t\t\tmin(sta->cur.max_rc_amsdu_len,\n\t\t\t    link_sta->agg.max_rc_amsdu_len);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sta->cur.max_tid_amsdu_len); i++)\n\t\t\tsta->cur.max_tid_amsdu_len[i] =\n\t\t\t\tmin(sta->cur.max_tid_amsdu_len[i],\n\t\t\t\t    link_sta->agg.max_tid_amsdu_len[i]);\n\t}\n\trcu_read_unlock();\n\n\tsta->sta.cur = &sta->cur;\n}\n\nvoid ieee80211_sta_recalc_aggregates(struct ieee80211_sta *pubsta)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\t__ieee80211_sta_recalc_aggregates(sta, sta->sdata->vif.active_links);\n}\nEXPORT_SYMBOL(ieee80211_sta_recalc_aggregates);\n\nvoid ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,\n\t\t\t\t\t  struct sta_info *sta, u8 ac,\n\t\t\t\t\t  u16 tx_airtime, bool tx_completed)\n{\n\tint tx_pending;\n\n\tif (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))\n\t\treturn;\n\n\tif (!tx_completed) {\n\t\tif (sta)\n\t\t\tatomic_add(tx_airtime,\n\t\t\t\t   &sta->airtime[ac].aql_tx_pending);\n\n\t\tatomic_add(tx_airtime, &local->aql_total_pending_airtime);\n\t\tatomic_add(tx_airtime, &local->aql_ac_pending_airtime[ac]);\n\t\treturn;\n\t}\n\n\tif (sta) {\n\t\ttx_pending = atomic_sub_return(tx_airtime,\n\t\t\t\t\t       &sta->airtime[ac].aql_tx_pending);\n\t\tif (tx_pending < 0)\n\t\t\tatomic_cmpxchg(&sta->airtime[ac].aql_tx_pending,\n\t\t\t\t       tx_pending, 0);\n\t}\n\n\tatomic_sub(tx_airtime, &local->aql_total_pending_airtime);\n\ttx_pending = atomic_sub_return(tx_airtime,\n\t\t\t\t       &local->aql_ac_pending_airtime[ac]);\n\tif (WARN_ONCE(tx_pending < 0,\n\t\t      \"Device %s AC %d pending airtime underflow: %u, %u\",\n\t\t      wiphy_name(local->hw.wiphy), ac, tx_pending,\n\t\t      tx_airtime)) {\n\t\tatomic_cmpxchg(&local->aql_ac_pending_airtime[ac],\n\t\t\t       tx_pending, 0);\n\t\tatomic_sub(tx_pending, &local->aql_total_pending_airtime);\n\t}\n}\n\nstatic struct ieee80211_sta_rx_stats *\nsta_get_last_rx_stats(struct sta_info *sta)\n{\n\tstruct ieee80211_sta_rx_stats *stats = &sta->deflink.rx_stats;\n\tint cpu;\n\n\tif (!sta->deflink.pcpu_rx_stats)\n\t\treturn stats;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct ieee80211_sta_rx_stats *cpustats;\n\n\t\tcpustats = per_cpu_ptr(sta->deflink.pcpu_rx_stats, cpu);\n\n\t\tif (time_after(cpustats->last_rx, stats->last_rx))\n\t\t\tstats = cpustats;\n\t}\n\n\treturn stats;\n}\n\nstatic void sta_stats_decode_rate(struct ieee80211_local *local, u32 rate,\n\t\t\t\t  struct rate_info *rinfo)\n{\n\trinfo->bw = STA_STATS_GET(BW, rate);\n\n\tswitch (STA_STATS_GET(TYPE, rate)) {\n\tcase STA_STATS_RATE_TYPE_VHT:\n\t\trinfo->flags = RATE_INFO_FLAGS_VHT_MCS;\n\t\trinfo->mcs = STA_STATS_GET(VHT_MCS, rate);\n\t\trinfo->nss = STA_STATS_GET(VHT_NSS, rate);\n\t\tif (STA_STATS_GET(SGI, rate))\n\t\t\trinfo->flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\tbreak;\n\tcase STA_STATS_RATE_TYPE_HT:\n\t\trinfo->flags = RATE_INFO_FLAGS_MCS;\n\t\trinfo->mcs = STA_STATS_GET(HT_MCS, rate);\n\t\tif (STA_STATS_GET(SGI, rate))\n\t\t\trinfo->flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\tbreak;\n\tcase STA_STATS_RATE_TYPE_LEGACY: {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tu16 brate;\n\t\tunsigned int shift;\n\t\tint band = STA_STATS_GET(LEGACY_BAND, rate);\n\t\tint rate_idx = STA_STATS_GET(LEGACY_IDX, rate);\n\n\t\tsband = local->hw.wiphy->bands[band];\n\n\t\tif (WARN_ON_ONCE(!sband->bitrates))\n\t\t\tbreak;\n\n\t\tbrate = sband->bitrates[rate_idx].bitrate;\n\t\tif (rinfo->bw == RATE_INFO_BW_5)\n\t\t\tshift = 2;\n\t\telse if (rinfo->bw == RATE_INFO_BW_10)\n\t\t\tshift = 1;\n\t\telse\n\t\t\tshift = 0;\n\t\trinfo->legacy = DIV_ROUND_UP(brate, 1 << shift);\n\t\tbreak;\n\t\t}\n\tcase STA_STATS_RATE_TYPE_HE:\n\t\trinfo->flags = RATE_INFO_FLAGS_HE_MCS;\n\t\trinfo->mcs = STA_STATS_GET(HE_MCS, rate);\n\t\trinfo->nss = STA_STATS_GET(HE_NSS, rate);\n\t\trinfo->he_gi = STA_STATS_GET(HE_GI, rate);\n\t\trinfo->he_ru_alloc = STA_STATS_GET(HE_RU, rate);\n\t\trinfo->he_dcm = STA_STATS_GET(HE_DCM, rate);\n\t\tbreak;\n\tcase STA_STATS_RATE_TYPE_EHT:\n\t\trinfo->flags = RATE_INFO_FLAGS_EHT_MCS;\n\t\trinfo->mcs = STA_STATS_GET(EHT_MCS, rate);\n\t\trinfo->nss = STA_STATS_GET(EHT_NSS, rate);\n\t\trinfo->eht_gi = STA_STATS_GET(EHT_GI, rate);\n\t\trinfo->eht_ru_alloc = STA_STATS_GET(EHT_RU, rate);\n\t\tbreak;\n\t}\n}\n\nstatic int sta_set_rate_info_rx(struct sta_info *sta, struct rate_info *rinfo)\n{\n\tu32 rate = READ_ONCE(sta_get_last_rx_stats(sta)->last_rate);\n\n\tif (rate == STA_STATS_RATE_INVALID)\n\t\treturn -EINVAL;\n\n\tsta_stats_decode_rate(sta->local, rate, rinfo);\n\treturn 0;\n}\n\nstatic inline u64 sta_get_tidstats_msdu(struct ieee80211_sta_rx_stats *rxstats,\n\t\t\t\t\tint tid)\n{\n\tunsigned int start;\n\tu64 value;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&rxstats->syncp);\n\t\tvalue = rxstats->msdu[tid];\n\t} while (u64_stats_fetch_retry(&rxstats->syncp, start));\n\n\treturn value;\n}\n\nstatic void sta_set_tidstats(struct sta_info *sta,\n\t\t\t     struct cfg80211_tid_stats *tidstats,\n\t\t\t     int tid)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tint cpu;\n\n\tif (!(tidstats->filled & BIT(NL80211_TID_STATS_RX_MSDU))) {\n\t\ttidstats->rx_msdu += sta_get_tidstats_msdu(&sta->deflink.rx_stats,\n\t\t\t\t\t\t\t   tid);\n\n\t\tif (sta->deflink.pcpu_rx_stats) {\n\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\tstruct ieee80211_sta_rx_stats *cpurxs;\n\n\t\t\t\tcpurxs = per_cpu_ptr(sta->deflink.pcpu_rx_stats,\n\t\t\t\t\t\t     cpu);\n\t\t\t\ttidstats->rx_msdu +=\n\t\t\t\t\tsta_get_tidstats_msdu(cpurxs, tid);\n\t\t\t}\n\t\t}\n\n\t\ttidstats->filled |= BIT(NL80211_TID_STATS_RX_MSDU);\n\t}\n\n\tif (!(tidstats->filled & BIT(NL80211_TID_STATS_TX_MSDU))) {\n\t\ttidstats->filled |= BIT(NL80211_TID_STATS_TX_MSDU);\n\t\ttidstats->tx_msdu = sta->deflink.tx_stats.msdu[tid];\n\t}\n\n\tif (!(tidstats->filled & BIT(NL80211_TID_STATS_TX_MSDU_RETRIES)) &&\n\t    ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {\n\t\ttidstats->filled |= BIT(NL80211_TID_STATS_TX_MSDU_RETRIES);\n\t\ttidstats->tx_msdu_retries = sta->deflink.status_stats.msdu_retries[tid];\n\t}\n\n\tif (!(tidstats->filled & BIT(NL80211_TID_STATS_TX_MSDU_FAILED)) &&\n\t    ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {\n\t\ttidstats->filled |= BIT(NL80211_TID_STATS_TX_MSDU_FAILED);\n\t\ttidstats->tx_msdu_failed = sta->deflink.status_stats.msdu_failed[tid];\n\t}\n\n\tif (tid < IEEE80211_NUM_TIDS) {\n\t\tspin_lock_bh(&local->fq.lock);\n\t\trcu_read_lock();\n\n\t\ttidstats->filled |= BIT(NL80211_TID_STATS_TXQ_STATS);\n\t\tieee80211_fill_txq_stats(&tidstats->txq_stats,\n\t\t\t\t\t to_txq_info(sta->sta.txq[tid]));\n\n\t\trcu_read_unlock();\n\t\tspin_unlock_bh(&local->fq.lock);\n\t}\n}\n\nstatic inline u64 sta_get_stats_bytes(struct ieee80211_sta_rx_stats *rxstats)\n{\n\tunsigned int start;\n\tu64 value;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&rxstats->syncp);\n\t\tvalue = rxstats->bytes;\n\t} while (u64_stats_fetch_retry(&rxstats->syncp, start));\n\n\treturn value;\n}\n\nvoid sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo,\n\t\t   bool tidstats)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tu32 thr = 0;\n\tint i, ac, cpu;\n\tstruct ieee80211_sta_rx_stats *last_rxstats;\n\n\tlast_rxstats = sta_get_last_rx_stats(sta);\n\n\tsinfo->generation = sdata->local->sta_generation;\n\n\t \n\tif (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\tsinfo->rx_beacon = sdata->deflink.u.mgd.count_beacon_signal;\n\n\tdrv_sta_statistics(local, sdata, &sta->sta, sinfo);\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_INACTIVE_TIME) |\n\t\t\t BIT_ULL(NL80211_STA_INFO_STA_FLAGS) |\n\t\t\t BIT_ULL(NL80211_STA_INFO_BSS_PARAM) |\n\t\t\t BIT_ULL(NL80211_STA_INFO_CONNECTED_TIME) |\n\t\t\t BIT_ULL(NL80211_STA_INFO_ASSOC_AT_BOOTTIME) |\n\t\t\t BIT_ULL(NL80211_STA_INFO_RX_DROP_MISC);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION) {\n\t\tsinfo->beacon_loss_count =\n\t\t\tsdata->deflink.u.mgd.beacon_loss_count;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_BEACON_LOSS);\n\t}\n\n\tsinfo->connected_time = ktime_get_seconds() - sta->last_connected;\n\tsinfo->assoc_at = sta->assoc_at;\n\tsinfo->inactive_time =\n\t\tjiffies_to_msecs(jiffies - ieee80211_sta_last_active(sta));\n\n\tif (!(sinfo->filled & (BIT_ULL(NL80211_STA_INFO_TX_BYTES64) |\n\t\t\t       BIT_ULL(NL80211_STA_INFO_TX_BYTES)))) {\n\t\tsinfo->tx_bytes = 0;\n\t\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\t\tsinfo->tx_bytes += sta->deflink.tx_stats.bytes[ac];\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);\n\t}\n\n\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_PACKETS))) {\n\t\tsinfo->tx_packets = 0;\n\t\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\t\tsinfo->tx_packets += sta->deflink.tx_stats.packets[ac];\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);\n\t}\n\n\tif (!(sinfo->filled & (BIT_ULL(NL80211_STA_INFO_RX_BYTES64) |\n\t\t\t       BIT_ULL(NL80211_STA_INFO_RX_BYTES)))) {\n\t\tsinfo->rx_bytes += sta_get_stats_bytes(&sta->deflink.rx_stats);\n\n\t\tif (sta->deflink.pcpu_rx_stats) {\n\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\tstruct ieee80211_sta_rx_stats *cpurxs;\n\n\t\t\t\tcpurxs = per_cpu_ptr(sta->deflink.pcpu_rx_stats,\n\t\t\t\t\t\t     cpu);\n\t\t\t\tsinfo->rx_bytes += sta_get_stats_bytes(cpurxs);\n\t\t\t}\n\t\t}\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);\n\t}\n\n\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_RX_PACKETS))) {\n\t\tsinfo->rx_packets = sta->deflink.rx_stats.packets;\n\t\tif (sta->deflink.pcpu_rx_stats) {\n\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\tstruct ieee80211_sta_rx_stats *cpurxs;\n\n\t\t\t\tcpurxs = per_cpu_ptr(sta->deflink.pcpu_rx_stats,\n\t\t\t\t\t\t     cpu);\n\t\t\t\tsinfo->rx_packets += cpurxs->packets;\n\t\t\t}\n\t\t}\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS);\n\t}\n\n\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_RETRIES))) {\n\t\tsinfo->tx_retries = sta->deflink.status_stats.retry_count;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_RETRIES);\n\t}\n\n\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_FAILED))) {\n\t\tsinfo->tx_failed = sta->deflink.status_stats.retry_failed;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);\n\t}\n\n\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_RX_DURATION))) {\n\t\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\t\tsinfo->rx_duration += sta->airtime[ac].rx_airtime;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DURATION);\n\t}\n\n\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_DURATION))) {\n\t\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\t\tsinfo->tx_duration += sta->airtime[ac].tx_airtime;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_DURATION);\n\t}\n\n\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_AIRTIME_WEIGHT))) {\n\t\tsinfo->airtime_weight = sta->airtime_weight;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_AIRTIME_WEIGHT);\n\t}\n\n\tsinfo->rx_dropped_misc = sta->deflink.rx_stats.dropped;\n\tif (sta->deflink.pcpu_rx_stats) {\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct ieee80211_sta_rx_stats *cpurxs;\n\n\t\t\tcpurxs = per_cpu_ptr(sta->deflink.pcpu_rx_stats, cpu);\n\t\t\tsinfo->rx_dropped_misc += cpurxs->dropped;\n\t\t}\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    !(sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_BEACON_RX) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_BEACON_SIGNAL_AVG);\n\t\tsinfo->rx_beacon_signal_avg = ieee80211_ave_rssi(&sdata->vif);\n\t}\n\n\tif (ieee80211_hw_check(&sta->local->hw, SIGNAL_DBM) ||\n\t    ieee80211_hw_check(&sta->local->hw, SIGNAL_UNSPEC)) {\n\t\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_SIGNAL))) {\n\t\t\tsinfo->signal = (s8)last_rxstats->last_signal;\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\t\t}\n\n\t\tif (!sta->deflink.pcpu_rx_stats &&\n\t\t    !(sinfo->filled & BIT_ULL(NL80211_STA_INFO_SIGNAL_AVG))) {\n\t\t\tsinfo->signal_avg =\n\t\t\t\t-ewma_signal_read(&sta->deflink.rx_stats_avg.signal);\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL_AVG);\n\t\t}\n\t}\n\n\t \n\tif (last_rxstats->chains &&\n\t    !(sinfo->filled & (BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL) |\n\t\t\t       BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL_AVG)))) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL);\n\t\tif (!sta->deflink.pcpu_rx_stats)\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL_AVG);\n\n\t\tsinfo->chains = last_rxstats->chains;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sinfo->chain_signal); i++) {\n\t\t\tsinfo->chain_signal[i] =\n\t\t\t\tlast_rxstats->chain_signal_last[i];\n\t\t\tsinfo->chain_signal_avg[i] =\n\t\t\t\t-ewma_signal_read(&sta->deflink.rx_stats_avg.chain_signal[i]);\n\t\t}\n\t}\n\n\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_BITRATE)) &&\n\t    !sta->sta.valid_links) {\n\t\tsta_set_rate_info_tx(sta, &sta->deflink.tx_stats.last_rate,\n\t\t\t\t     &sinfo->txrate);\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t}\n\n\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_RX_BITRATE)) &&\n\t    !sta->sta.valid_links) {\n\t\tif (sta_set_rate_info_rx(sta, &sinfo->rxrate) == 0)\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BITRATE);\n\t}\n\n\tif (tidstats && !cfg80211_sinfo_alloc_tid_stats(sinfo, GFP_KERNEL)) {\n\t\tfor (i = 0; i < IEEE80211_NUM_TIDS + 1; i++)\n\t\t\tsta_set_tidstats(sta, &sinfo->pertid[i], i);\n\t}\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n#ifdef CONFIG_MAC80211_MESH\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_LLID) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_PLID) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_PLINK_STATE) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_LOCAL_PM) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_PEER_PM) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_NONPEER_PM) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_CONNECTED_TO_GATE) |\n\t\t\t\t BIT_ULL(NL80211_STA_INFO_CONNECTED_TO_AS);\n\n\t\tsinfo->llid = sta->mesh->llid;\n\t\tsinfo->plid = sta->mesh->plid;\n\t\tsinfo->plink_state = sta->mesh->plink_state;\n\t\tif (test_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN)) {\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_T_OFFSET);\n\t\t\tsinfo->t_offset = sta->mesh->t_offset;\n\t\t}\n\t\tsinfo->local_pm = sta->mesh->local_pm;\n\t\tsinfo->peer_pm = sta->mesh->peer_pm;\n\t\tsinfo->nonpeer_pm = sta->mesh->nonpeer_pm;\n\t\tsinfo->connected_to_gate = sta->mesh->connected_to_gate;\n\t\tsinfo->connected_to_as = sta->mesh->connected_to_as;\n#endif\n\t}\n\n\tsinfo->bss_param.flags = 0;\n\tif (sdata->vif.bss_conf.use_cts_prot)\n\t\tsinfo->bss_param.flags |= BSS_PARAM_FLAGS_CTS_PROT;\n\tif (sdata->vif.bss_conf.use_short_preamble)\n\t\tsinfo->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_PREAMBLE;\n\tif (sdata->vif.bss_conf.use_short_slot)\n\t\tsinfo->bss_param.flags |= BSS_PARAM_FLAGS_SHORT_SLOT_TIME;\n\tsinfo->bss_param.dtim_period = sdata->vif.bss_conf.dtim_period;\n\tsinfo->bss_param.beacon_interval = sdata->vif.bss_conf.beacon_int;\n\n\tsinfo->sta_flags.set = 0;\n\tsinfo->sta_flags.mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\tBIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |\n\t\t\t\tBIT(NL80211_STA_FLAG_WME) |\n\t\t\t\tBIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\tBIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\tBIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t\t\tBIT(NL80211_STA_FLAG_TDLS_PEER);\n\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\tsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_AUTHORIZED);\n\tif (test_sta_flag(sta, WLAN_STA_SHORT_PREAMBLE))\n\t\tsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_SHORT_PREAMBLE);\n\tif (sta->sta.wme)\n\t\tsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_WME);\n\tif (test_sta_flag(sta, WLAN_STA_MFP))\n\t\tsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_MFP);\n\tif (test_sta_flag(sta, WLAN_STA_AUTH))\n\t\tsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_AUTHENTICATED);\n\tif (test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\tsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_ASSOCIATED);\n\tif (test_sta_flag(sta, WLAN_STA_TDLS_PEER))\n\t\tsinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_TDLS_PEER);\n\n\tthr = sta_get_expected_throughput(sta);\n\n\tif (thr != 0) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_EXPECTED_THROUGHPUT);\n\t\tsinfo->expected_throughput = thr;\n\t}\n\n\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL)) &&\n\t    sta->deflink.status_stats.ack_signal_filled) {\n\t\tsinfo->ack_signal = sta->deflink.status_stats.last_ack_signal;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL);\n\t}\n\n\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG)) &&\n\t    sta->deflink.status_stats.ack_signal_filled) {\n\t\tsinfo->avg_ack_signal =\n\t\t\t-(s8)ewma_avg_signal_read(\n\t\t\t\t&sta->deflink.status_stats.avg_ack_signal);\n\t\tsinfo->filled |=\n\t\t\tBIT_ULL(NL80211_STA_INFO_ACK_SIGNAL_AVG);\n\t}\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_AIRTIME_LINK_METRIC);\n\t\tsinfo->airtime_link_metric =\n\t\t\tairtime_link_metric_get(local, sta);\n\t}\n}\n\nu32 sta_get_expected_throughput(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct rate_control_ref *ref = NULL;\n\tu32 thr = 0;\n\n\tif (test_sta_flag(sta, WLAN_STA_RATE_CONTROL))\n\t\tref = local->rate_ctrl;\n\n\t \n\tif (ref && ref->ops->get_expected_throughput)\n\t\tthr = ref->ops->get_expected_throughput(sta->rate_ctrl_priv);\n\telse\n\t\tthr = drv_get_expected_throughput(local, sta);\n\n\treturn thr;\n}\n\nunsigned long ieee80211_sta_last_active(struct sta_info *sta)\n{\n\tstruct ieee80211_sta_rx_stats *stats = sta_get_last_rx_stats(sta);\n\n\tif (!sta->deflink.status_stats.last_ack ||\n\t    time_after(stats->last_rx, sta->deflink.status_stats.last_ack))\n\t\treturn stats->last_rx;\n\treturn sta->deflink.status_stats.last_ack;\n}\n\nstatic void sta_update_codel_params(struct sta_info *sta, u32 thr)\n{\n\tif (thr && thr < STA_SLOW_THRESHOLD * sta->local->num_sta) {\n\t\tsta->cparams.target = MS2TIME(50);\n\t\tsta->cparams.interval = MS2TIME(300);\n\t\tsta->cparams.ecn = false;\n\t} else {\n\t\tsta->cparams.target = MS2TIME(20);\n\t\tsta->cparams.interval = MS2TIME(100);\n\t\tsta->cparams.ecn = true;\n\t}\n}\n\nvoid ieee80211_sta_set_expected_throughput(struct ieee80211_sta *pubsta,\n\t\t\t\t\t   u32 thr)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\tsta_update_codel_params(sta, thr);\n}\n\nint ieee80211_sta_allocate_link(struct sta_info *sta, unsigned int link_id)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct sta_link_alloc *alloc;\n\tint ret;\n\n\tlockdep_assert_held(&sdata->local->sta_mtx);\n\n\t \n\tif (WARN_ON(!sta->sta.valid_links))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(sta->sta.valid_links & BIT(link_id) ||\n\t\t    sta->link[link_id]))\n\t\treturn -EBUSY;\n\n\talloc = kzalloc(sizeof(*alloc), GFP_KERNEL);\n\tif (!alloc)\n\t\treturn -ENOMEM;\n\n\tret = sta_info_alloc_link(sdata->local, &alloc->info, GFP_KERNEL);\n\tif (ret) {\n\t\tkfree(alloc);\n\t\treturn ret;\n\t}\n\n\tsta_info_add_link(sta, link_id, &alloc->info, &alloc->sta);\n\n\tieee80211_link_sta_debugfs_add(&alloc->info);\n\n\treturn 0;\n}\n\nvoid ieee80211_sta_free_link(struct sta_info *sta, unsigned int link_id)\n{\n\tlockdep_assert_held(&sta->sdata->local->sta_mtx);\n\n\tsta_remove_link(sta, link_id, false);\n}\n\nint ieee80211_sta_activate_link(struct sta_info *sta, unsigned int link_id)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct link_sta_info *link_sta;\n\tu16 old_links = sta->sta.valid_links;\n\tu16 new_links = old_links | BIT(link_id);\n\tint ret;\n\n\tlink_sta = rcu_dereference_protected(sta->link[link_id],\n\t\t\t\t\t     lockdep_is_held(&sdata->local->sta_mtx));\n\n\tif (WARN_ON(old_links == new_links || !link_sta))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tif (link_sta_info_hash_lookup(sdata->local, link_sta->addr)) {\n\t\trcu_read_unlock();\n\t\treturn -EALREADY;\n\t}\n\t \n\trcu_read_unlock();\n\n\tsta->sta.valid_links = new_links;\n\n\tif (!test_sta_flag(sta, WLAN_STA_INSERTED))\n\t\tgoto hash;\n\n\tieee80211_recalc_min_chandef(sdata, link_id);\n\n\t \n\tieee80211_sta_recalc_aggregates(&sta->sta);\n\n\tret = drv_change_sta_links(sdata->local, sdata, &sta->sta,\n\t\t\t\t   old_links, new_links);\n\tif (ret) {\n\t\tsta->sta.valid_links = old_links;\n\t\tsta_remove_link(sta, link_id, false);\n\t\treturn ret;\n\t}\n\nhash:\n\tret = link_sta_info_hash_add(sdata->local, link_sta);\n\tWARN_ON(ret);\n\treturn 0;\n}\n\nvoid ieee80211_sta_remove_link(struct sta_info *sta, unsigned int link_id)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tu16 old_links = sta->sta.valid_links;\n\n\tlockdep_assert_held(&sdata->local->sta_mtx);\n\n\tsta->sta.valid_links &= ~BIT(link_id);\n\n\tif (test_sta_flag(sta, WLAN_STA_INSERTED))\n\t\tdrv_change_sta_links(sdata->local, sdata, &sta->sta,\n\t\t\t\t     old_links, sta->sta.valid_links);\n\n\tsta_remove_link(sta, link_id, true);\n}\n\nvoid ieee80211_sta_set_max_amsdu_subframes(struct sta_info *sta,\n\t\t\t\t\t   const u8 *ext_capab,\n\t\t\t\t\t   unsigned int ext_capab_len)\n{\n\tu8 val;\n\n\tsta->sta.max_amsdu_subframes = 0;\n\n\tif (ext_capab_len < 8)\n\t\treturn;\n\n\t \n\tval = u8_get_bits(ext_capab[7], WLAN_EXT_CAPA8_MAX_MSDU_IN_AMSDU_LSB);\n\n\t \n\tif (ext_capab_len >= 9)\n\t\tval |= u8_get_bits(ext_capab[8],\n\t\t\t\t   WLAN_EXT_CAPA9_MAX_MSDU_IN_AMSDU_MSB) << 1;\n\n\tif (val)\n\t\tsta->sta.max_amsdu_subframes = 4 << (4 - val);\n}\n\n#ifdef CONFIG_LOCKDEP\nbool lockdep_sta_mutex_held(struct ieee80211_sta *pubsta)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\treturn lockdep_is_held(&sta->local->sta_mtx);\n}\nEXPORT_SYMBOL(lockdep_sta_mutex_held);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}