{
  "module_name": "rc80211_minstrel_ht.c",
  "hash_id": "12f00bf38a915e4836ee36d356c34e724312bca8f11f40954dbcaa50693b2ef6",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/rc80211_minstrel_ht.c",
  "human_readable_source": "\n \n#include <linux/netdevice.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/debugfs.h>\n#include <linux/random.h>\n#include <linux/moduleparam.h>\n#include <linux/ieee80211.h>\n#include <linux/minmax.h>\n#include <net/mac80211.h>\n#include \"rate.h\"\n#include \"sta_info.h\"\n#include \"rc80211_minstrel_ht.h\"\n\n#define AVG_AMPDU_SIZE\t16\n#define AVG_PKT_SIZE\t1200\n\n \n#define MCS_NBITS ((AVG_PKT_SIZE * AVG_AMPDU_SIZE) << 3)\n\n \n#define MCS_NSYMS(bps) DIV_ROUND_UP(MCS_NBITS, (bps))\n\n \n#define MCS_SYMBOL_TIME(sgi, syms)\t\t\t\t\t\\\n\t(sgi ?\t\t\t\t\t\t\t\t\\\n\t  ((syms) * 18000 + 4000) / 5 :\t \t\t\\\n\t  ((syms) * 1000) << 2\t\t \t\t\\\n\t)\n\n \n#define MCS_DURATION(streams, sgi, bps) \\\n\t(MCS_SYMBOL_TIME(sgi, MCS_NSYMS((streams) * (bps))) / AVG_AMPDU_SIZE)\n\n#define BW_20\t\t\t0\n#define BW_40\t\t\t1\n#define BW_80\t\t\t2\n\n \n#define GROUP_IDX(_streams, _sgi, _ht40)\t\\\n\tMINSTREL_HT_GROUP_0 +\t\t\t\\\n\tMINSTREL_MAX_STREAMS * 2 * _ht40 +\t\\\n\tMINSTREL_MAX_STREAMS * _sgi +\t\\\n\t_streams - 1\n\n#define _MAX(a, b) (((a)>(b))?(a):(b))\n\n#define GROUP_SHIFT(duration)\t\t\t\t\t\t\\\n\t_MAX(0, 16 - __builtin_clz(duration))\n\n \n#define __MCS_GROUP(_streams, _sgi, _ht40, _s)\t\t\t\t\\\n\t[GROUP_IDX(_streams, _sgi, _ht40)] = {\t\t\t\t\\\n\t.streams = _streams,\t\t\t\t\t\t\\\n\t.shift = _s,\t\t\t\t\t\t\t\\\n\t.bw = _ht40,\t\t\t\t\t\t\t\\\n\t.flags =\t\t\t\t\t\t\t\\\n\t\tIEEE80211_TX_RC_MCS |\t\t\t\t\t\\\n\t\t(_sgi ? IEEE80211_TX_RC_SHORT_GI : 0) |\t\t\t\\\n\t\t(_ht40 ? IEEE80211_TX_RC_40_MHZ_WIDTH : 0),\t\t\\\n\t.duration = {\t\t\t\t\t\t\t\\\n\t\tMCS_DURATION(_streams, _sgi, _ht40 ? 54 : 26) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi, _ht40 ? 108 : 52) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi, _ht40 ? 162 : 78) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi, _ht40 ? 216 : 104) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi, _ht40 ? 324 : 156) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi, _ht40 ? 432 : 208) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi, _ht40 ? 486 : 234) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi, _ht40 ? 540 : 260) >> _s\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n#define MCS_GROUP_SHIFT(_streams, _sgi, _ht40)\t\t\t\t\\\n\tGROUP_SHIFT(MCS_DURATION(_streams, _sgi, _ht40 ? 54 : 26))\n\n#define MCS_GROUP(_streams, _sgi, _ht40)\t\t\t\t\\\n\t__MCS_GROUP(_streams, _sgi, _ht40,\t\t\t\t\\\n\t\t    MCS_GROUP_SHIFT(_streams, _sgi, _ht40))\n\n#define VHT_GROUP_IDX(_streams, _sgi, _bw)\t\t\t\t\\\n\t(MINSTREL_VHT_GROUP_0 +\t\t\t\t\t\t\\\n\t MINSTREL_MAX_STREAMS * 2 * (_bw) +\t\t\t\t\\\n\t MINSTREL_MAX_STREAMS * (_sgi) +\t\t\t\t\\\n\t (_streams) - 1)\n\n#define BW2VBPS(_bw, r3, r2, r1)\t\t\t\t\t\\\n\t(_bw == BW_80 ? r3 : _bw == BW_40 ? r2 : r1)\n\n#define __VHT_GROUP(_streams, _sgi, _bw, _s)\t\t\t\t\\\n\t[VHT_GROUP_IDX(_streams, _sgi, _bw)] = {\t\t\t\\\n\t.streams = _streams,\t\t\t\t\t\t\\\n\t.shift = _s,\t\t\t\t\t\t\t\\\n\t.bw = _bw,\t\t\t\t\t\t\t\\\n\t.flags =\t\t\t\t\t\t\t\\\n\t\tIEEE80211_TX_RC_VHT_MCS |\t\t\t\t\\\n\t\t(_sgi ? IEEE80211_TX_RC_SHORT_GI : 0) |\t\t\t\\\n\t\t(_bw == BW_80 ? IEEE80211_TX_RC_80_MHZ_WIDTH :\t\t\\\n\t\t _bw == BW_40 ? IEEE80211_TX_RC_40_MHZ_WIDTH : 0),\t\\\n\t.duration = {\t\t\t\t\t\t\t\\\n\t\tMCS_DURATION(_streams, _sgi,\t\t\t\t\\\n\t\t\t     BW2VBPS(_bw,  117,  54,  26)) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi,\t\t\t\t\\\n\t\t\t     BW2VBPS(_bw,  234, 108,  52)) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi,\t\t\t\t\\\n\t\t\t     BW2VBPS(_bw,  351, 162,  78)) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi,\t\t\t\t\\\n\t\t\t     BW2VBPS(_bw,  468, 216, 104)) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi,\t\t\t\t\\\n\t\t\t     BW2VBPS(_bw,  702, 324, 156)) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi,\t\t\t\t\\\n\t\t\t     BW2VBPS(_bw,  936, 432, 208)) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi,\t\t\t\t\\\n\t\t\t     BW2VBPS(_bw, 1053, 486, 234)) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi,\t\t\t\t\\\n\t\t\t     BW2VBPS(_bw, 1170, 540, 260)) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi,\t\t\t\t\\\n\t\t\t     BW2VBPS(_bw, 1404, 648, 312)) >> _s,\t\\\n\t\tMCS_DURATION(_streams, _sgi,\t\t\t\t\\\n\t\t\t     BW2VBPS(_bw, 1560, 720, 346)) >> _s\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\n#define VHT_GROUP_SHIFT(_streams, _sgi, _bw)\t\t\t\t\\\n\tGROUP_SHIFT(MCS_DURATION(_streams, _sgi,\t\t\t\\\n\t\t\t\t BW2VBPS(_bw,  117,  54,  26)))\n\n#define VHT_GROUP(_streams, _sgi, _bw)\t\t\t\t\t\\\n\t__VHT_GROUP(_streams, _sgi, _bw,\t\t\t\t\\\n\t\t    VHT_GROUP_SHIFT(_streams, _sgi, _bw))\n\n#define CCK_DURATION(_bitrate, _short)\t\t\t\\\n\t(1000 * (10   +\t\t\t\\\n\t (_short ? 72 + 24 : 144 + 48) +\t\t\\\n\t (8 * (AVG_PKT_SIZE + 4) * 10) / (_bitrate)))\n\n#define CCK_DURATION_LIST(_short, _s)\t\t\t\\\n\tCCK_DURATION(10, _short) >> _s,\t\t\t\\\n\tCCK_DURATION(20, _short) >> _s,\t\t\t\\\n\tCCK_DURATION(55, _short) >> _s,\t\t\t\\\n\tCCK_DURATION(110, _short) >> _s\n\n#define __CCK_GROUP(_s)\t\t\t\t\t\\\n\t[MINSTREL_CCK_GROUP] = {\t\t\t\\\n\t\t.streams = 1,\t\t\t\t\\\n\t\t.flags = 0,\t\t\t\t\\\n\t\t.shift = _s,\t\t\t\t\\\n\t\t.duration = {\t\t\t\t\\\n\t\t\tCCK_DURATION_LIST(false, _s),\t\\\n\t\t\tCCK_DURATION_LIST(true, _s)\t\\\n\t\t}\t\t\t\t\t\\\n\t}\n\n#define CCK_GROUP_SHIFT\t\t\t\t\t\\\n\tGROUP_SHIFT(CCK_DURATION(10, false))\n\n#define CCK_GROUP __CCK_GROUP(CCK_GROUP_SHIFT)\n\n#define OFDM_DURATION(_bitrate)\t\t\t\t\\\n\t(1000 * (16   +\t\t\\\n\t 16   +\t\t\t\t\\\n\t 4   +\t\t\t\t\\\n\t 4 * (((16 + 80 * (AVG_PKT_SIZE + 4) + 6) /\t\\\n\t      ((_bitrate) * 4)))))\n\n#define OFDM_DURATION_LIST(_s)\t\t\t\t\\\n\tOFDM_DURATION(60) >> _s,\t\t\t\\\n\tOFDM_DURATION(90) >> _s,\t\t\t\\\n\tOFDM_DURATION(120) >> _s,\t\t\t\\\n\tOFDM_DURATION(180) >> _s,\t\t\t\\\n\tOFDM_DURATION(240) >> _s,\t\t\t\\\n\tOFDM_DURATION(360) >> _s,\t\t\t\\\n\tOFDM_DURATION(480) >> _s,\t\t\t\\\n\tOFDM_DURATION(540) >> _s\n\n#define __OFDM_GROUP(_s)\t\t\t\t\\\n\t[MINSTREL_OFDM_GROUP] = {\t\t\t\\\n\t\t.streams = 1,\t\t\t\t\\\n\t\t.flags = 0,\t\t\t\t\\\n\t\t.shift = _s,\t\t\t\t\\\n\t\t.duration = {\t\t\t\t\\\n\t\t\tOFDM_DURATION_LIST(_s),\t\t\\\n\t\t}\t\t\t\t\t\\\n\t}\n\n#define OFDM_GROUP_SHIFT\t\t\t\t\\\n\tGROUP_SHIFT(OFDM_DURATION(60))\n\n#define OFDM_GROUP __OFDM_GROUP(OFDM_GROUP_SHIFT)\n\n\nstatic bool minstrel_vht_only = true;\nmodule_param(minstrel_vht_only, bool, 0644);\nMODULE_PARM_DESC(minstrel_vht_only,\n\t\t \"Use only VHT rates when VHT is supported by sta.\");\n\n \nconst struct mcs_group minstrel_mcs_groups[] = {\n\tMCS_GROUP(1, 0, BW_20),\n\tMCS_GROUP(2, 0, BW_20),\n\tMCS_GROUP(3, 0, BW_20),\n\tMCS_GROUP(4, 0, BW_20),\n\n\tMCS_GROUP(1, 1, BW_20),\n\tMCS_GROUP(2, 1, BW_20),\n\tMCS_GROUP(3, 1, BW_20),\n\tMCS_GROUP(4, 1, BW_20),\n\n\tMCS_GROUP(1, 0, BW_40),\n\tMCS_GROUP(2, 0, BW_40),\n\tMCS_GROUP(3, 0, BW_40),\n\tMCS_GROUP(4, 0, BW_40),\n\n\tMCS_GROUP(1, 1, BW_40),\n\tMCS_GROUP(2, 1, BW_40),\n\tMCS_GROUP(3, 1, BW_40),\n\tMCS_GROUP(4, 1, BW_40),\n\n\tCCK_GROUP,\n\tOFDM_GROUP,\n\n\tVHT_GROUP(1, 0, BW_20),\n\tVHT_GROUP(2, 0, BW_20),\n\tVHT_GROUP(3, 0, BW_20),\n\tVHT_GROUP(4, 0, BW_20),\n\n\tVHT_GROUP(1, 1, BW_20),\n\tVHT_GROUP(2, 1, BW_20),\n\tVHT_GROUP(3, 1, BW_20),\n\tVHT_GROUP(4, 1, BW_20),\n\n\tVHT_GROUP(1, 0, BW_40),\n\tVHT_GROUP(2, 0, BW_40),\n\tVHT_GROUP(3, 0, BW_40),\n\tVHT_GROUP(4, 0, BW_40),\n\n\tVHT_GROUP(1, 1, BW_40),\n\tVHT_GROUP(2, 1, BW_40),\n\tVHT_GROUP(3, 1, BW_40),\n\tVHT_GROUP(4, 1, BW_40),\n\n\tVHT_GROUP(1, 0, BW_80),\n\tVHT_GROUP(2, 0, BW_80),\n\tVHT_GROUP(3, 0, BW_80),\n\tVHT_GROUP(4, 0, BW_80),\n\n\tVHT_GROUP(1, 1, BW_80),\n\tVHT_GROUP(2, 1, BW_80),\n\tVHT_GROUP(3, 1, BW_80),\n\tVHT_GROUP(4, 1, BW_80),\n};\n\nconst s16 minstrel_cck_bitrates[4] = { 10, 20, 55, 110 };\nconst s16 minstrel_ofdm_bitrates[8] = { 60, 90, 120, 180, 240, 360, 480, 540 };\nstatic u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;\nstatic const u8 minstrel_sample_seq[] = {\n\tMINSTREL_SAMPLE_TYPE_INC,\n\tMINSTREL_SAMPLE_TYPE_JUMP,\n\tMINSTREL_SAMPLE_TYPE_INC,\n\tMINSTREL_SAMPLE_TYPE_JUMP,\n\tMINSTREL_SAMPLE_TYPE_INC,\n\tMINSTREL_SAMPLE_TYPE_SLOW,\n};\n\nstatic void\nminstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);\n\n \nstatic u16\nminstrel_get_valid_vht_rates(int bw, int nss, __le16 mcs_map)\n{\n\tu16 mask = 0;\n\n\tif (bw == BW_20) {\n\t\tif (nss != 3 && nss != 6)\n\t\t\tmask = BIT(9);\n\t} else if (bw == BW_80) {\n\t\tif (nss == 3 || nss == 7)\n\t\t\tmask = BIT(6);\n\t\telse if (nss == 6)\n\t\t\tmask = BIT(9);\n\t} else {\n\t\tWARN_ON(bw != BW_40);\n\t}\n\n\tswitch ((le16_to_cpu(mcs_map) >> (2 * (nss - 1))) & 3) {\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_7:\n\t\tmask |= 0x300;\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_8:\n\t\tmask |= 0x200;\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_9:\n\t\tbreak;\n\tdefault:\n\t\tmask = 0x3ff;\n\t}\n\n\treturn 0x3ff & ~mask;\n}\n\nstatic bool\nminstrel_ht_is_legacy_group(int group)\n{\n\treturn group == MINSTREL_CCK_GROUP ||\n\t       group == MINSTREL_OFDM_GROUP;\n}\n\n \nstatic int\nminstrel_ht_get_group_idx(struct ieee80211_tx_rate *rate)\n{\n\treturn GROUP_IDX((rate->idx / 8) + 1,\n\t\t\t !!(rate->flags & IEEE80211_TX_RC_SHORT_GI),\n\t\t\t !!(rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH));\n}\n\n \nstatic int\nminstrel_ht_ri_get_group_idx(struct rate_info *rate)\n{\n\treturn GROUP_IDX((rate->mcs / 8) + 1,\n\t\t\t !!(rate->flags & RATE_INFO_FLAGS_SHORT_GI),\n\t\t\t !!(rate->bw & RATE_INFO_BW_40));\n}\n\nstatic int\nminstrel_vht_get_group_idx(struct ieee80211_tx_rate *rate)\n{\n\treturn VHT_GROUP_IDX(ieee80211_rate_get_vht_nss(rate),\n\t\t\t     !!(rate->flags & IEEE80211_TX_RC_SHORT_GI),\n\t\t\t     !!(rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH) +\n\t\t\t     2*!!(rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH));\n}\n\n \nstatic int\nminstrel_vht_ri_get_group_idx(struct rate_info *rate)\n{\n\treturn VHT_GROUP_IDX(rate->nss,\n\t\t\t     !!(rate->flags & RATE_INFO_FLAGS_SHORT_GI),\n\t\t\t     !!(rate->bw & RATE_INFO_BW_40) +\n\t\t\t     2*!!(rate->bw & RATE_INFO_BW_80));\n}\n\nstatic struct minstrel_rate_stats *\nminstrel_ht_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\n\t\t      struct ieee80211_tx_rate *rate)\n{\n\tint group, idx;\n\n\tif (rate->flags & IEEE80211_TX_RC_MCS) {\n\t\tgroup = minstrel_ht_get_group_idx(rate);\n\t\tidx = rate->idx % 8;\n\t\tgoto out;\n\t}\n\n\tif (rate->flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\tgroup = minstrel_vht_get_group_idx(rate);\n\t\tidx = ieee80211_rate_get_vht_mcs(rate);\n\t\tgoto out;\n\t}\n\n\tgroup = MINSTREL_CCK_GROUP;\n\tfor (idx = 0; idx < ARRAY_SIZE(mp->cck_rates); idx++) {\n\t\tif (!(mi->supported[group] & BIT(idx)))\n\t\t\tcontinue;\n\n\t\tif (rate->idx != mp->cck_rates[idx])\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((mi->supported[group] & BIT(idx + 4)) &&\n\t\t    (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE))\n\t\t\tidx += 4;\n\t\tgoto out;\n\t}\n\n\tgroup = MINSTREL_OFDM_GROUP;\n\tfor (idx = 0; idx < ARRAY_SIZE(mp->ofdm_rates[0]); idx++)\n\t\tif (rate->idx == mp->ofdm_rates[mi->band][idx])\n\t\t\tgoto out;\n\n\tidx = 0;\nout:\n\treturn &mi->groups[group].rates[idx];\n}\n\n \nstatic struct minstrel_rate_stats *\nminstrel_ht_ri_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\n\t\t\t  struct ieee80211_rate_status *rate_status)\n{\n\tint group, idx;\n\tstruct rate_info *rate = &rate_status->rate_idx;\n\n\tif (rate->flags & RATE_INFO_FLAGS_MCS) {\n\t\tgroup = minstrel_ht_ri_get_group_idx(rate);\n\t\tidx = rate->mcs % 8;\n\t\tgoto out;\n\t}\n\n\tif (rate->flags & RATE_INFO_FLAGS_VHT_MCS) {\n\t\tgroup = minstrel_vht_ri_get_group_idx(rate);\n\t\tidx = rate->mcs;\n\t\tgoto out;\n\t}\n\n\tgroup = MINSTREL_CCK_GROUP;\n\tfor (idx = 0; idx < ARRAY_SIZE(mp->cck_rates); idx++) {\n\t\tif (rate->legacy != minstrel_cck_bitrates[ mp->cck_rates[idx] ])\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((mi->supported[group] & BIT(idx + 4)) &&\n\t\t\t\t\t\t\tmi->use_short_preamble)\n\t\t\tidx += 4;\n\t\tgoto out;\n\t}\n\n\tgroup = MINSTREL_OFDM_GROUP;\n\tfor (idx = 0; idx < ARRAY_SIZE(mp->ofdm_rates[0]); idx++)\n\t\tif (rate->legacy == minstrel_ofdm_bitrates[ mp->ofdm_rates[mi->band][idx] ])\n\t\t\tgoto out;\n\n\tidx = 0;\nout:\n\treturn &mi->groups[group].rates[idx];\n}\n\nstatic inline struct minstrel_rate_stats *\nminstrel_get_ratestats(struct minstrel_ht_sta *mi, int index)\n{\n\treturn &mi->groups[MI_RATE_GROUP(index)].rates[MI_RATE_IDX(index)];\n}\n\nstatic inline int minstrel_get_duration(int index)\n{\n\tconst struct mcs_group *group = &minstrel_mcs_groups[MI_RATE_GROUP(index)];\n\tunsigned int duration = group->duration[MI_RATE_IDX(index)];\n\n\treturn duration << group->shift;\n}\n\nstatic unsigned int\nminstrel_ht_avg_ampdu_len(struct minstrel_ht_sta *mi)\n{\n\tint duration;\n\n\tif (mi->avg_ampdu_len)\n\t\treturn MINSTREL_TRUNC(mi->avg_ampdu_len);\n\n\tif (minstrel_ht_is_legacy_group(MI_RATE_GROUP(mi->max_tp_rate[0])))\n\t\treturn 1;\n\n\tduration = minstrel_get_duration(mi->max_tp_rate[0]);\n\n\tif (duration > 400 * 1000)\n\t\treturn 2;\n\n\tif (duration > 250 * 1000)\n\t\treturn 4;\n\n\tif (duration > 150 * 1000)\n\t\treturn 8;\n\n\treturn 16;\n}\n\n \nint\nminstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,\n\t\t       int prob_avg)\n{\n\tunsigned int nsecs = 0, overhead = mi->overhead;\n\tunsigned int ampdu_len = 1;\n\n\t \n\tif (prob_avg < MINSTREL_FRAC(10, 100))\n\t\treturn 0;\n\n\tif (minstrel_ht_is_legacy_group(group))\n\t\toverhead = mi->overhead_legacy;\n\telse\n\t\tampdu_len = minstrel_ht_avg_ampdu_len(mi);\n\n\tnsecs = 1000 * overhead / ampdu_len;\n\tnsecs += minstrel_mcs_groups[group].duration[rate] <<\n\t\t minstrel_mcs_groups[group].shift;\n\n\t \n\tif (prob_avg > MINSTREL_FRAC(90, 100))\n\t\tprob_avg = MINSTREL_FRAC(90, 100);\n\n\treturn MINSTREL_TRUNC(100 * ((prob_avg * 1000000) / nsecs));\n}\n\n \nstatic void\nminstrel_ht_sort_best_tp_rates(struct minstrel_ht_sta *mi, u16 index,\n\t\t\t       u16 *tp_list)\n{\n\tint cur_group, cur_idx, cur_tp_avg, cur_prob;\n\tint tmp_group, tmp_idx, tmp_tp_avg, tmp_prob;\n\tint j = MAX_THR_RATES;\n\n\tcur_group = MI_RATE_GROUP(index);\n\tcur_idx = MI_RATE_IDX(index);\n\tcur_prob = mi->groups[cur_group].rates[cur_idx].prob_avg;\n\tcur_tp_avg = minstrel_ht_get_tp_avg(mi, cur_group, cur_idx, cur_prob);\n\n\tdo {\n\t\ttmp_group = MI_RATE_GROUP(tp_list[j - 1]);\n\t\ttmp_idx = MI_RATE_IDX(tp_list[j - 1]);\n\t\ttmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;\n\t\ttmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx,\n\t\t\t\t\t\t    tmp_prob);\n\t\tif (cur_tp_avg < tmp_tp_avg ||\n\t\t    (cur_tp_avg == tmp_tp_avg && cur_prob <= tmp_prob))\n\t\t\tbreak;\n\t\tj--;\n\t} while (j > 0);\n\n\tif (j < MAX_THR_RATES - 1) {\n\t\tmemmove(&tp_list[j + 1], &tp_list[j], (sizeof(*tp_list) *\n\t\t       (MAX_THR_RATES - (j + 1))));\n\t}\n\tif (j < MAX_THR_RATES)\n\t\ttp_list[j] = index;\n}\n\n \nstatic void\nminstrel_ht_set_best_prob_rate(struct minstrel_ht_sta *mi, u16 *dest, u16 index)\n{\n\tstruct minstrel_mcs_group_data *mg;\n\tstruct minstrel_rate_stats *mrs;\n\tint tmp_group, tmp_idx, tmp_tp_avg, tmp_prob;\n\tint max_tp_group, max_tp_idx, max_tp_prob;\n\tint cur_tp_avg, cur_group, cur_idx;\n\tint max_gpr_group, max_gpr_idx;\n\tint max_gpr_tp_avg, max_gpr_prob;\n\n\tcur_group = MI_RATE_GROUP(index);\n\tcur_idx = MI_RATE_IDX(index);\n\tmg = &mi->groups[cur_group];\n\tmrs = &mg->rates[cur_idx];\n\n\ttmp_group = MI_RATE_GROUP(*dest);\n\ttmp_idx = MI_RATE_IDX(*dest);\n\ttmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;\n\ttmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);\n\n\t \n\tmax_tp_group = MI_RATE_GROUP(mi->max_tp_rate[0]);\n\tmax_tp_idx = MI_RATE_IDX(mi->max_tp_rate[0]);\n\tmax_tp_prob = mi->groups[max_tp_group].rates[max_tp_idx].prob_avg;\n\n\tif (minstrel_ht_is_legacy_group(MI_RATE_GROUP(index)) &&\n\t    !minstrel_ht_is_legacy_group(max_tp_group))\n\t\treturn;\n\n\t \n\tif (minstrel_get_duration(mi->max_tp_rate[0]) > minstrel_get_duration(index) &&\n\t    mrs->prob_avg < max_tp_prob)\n\t\treturn;\n\n\tmax_gpr_group = MI_RATE_GROUP(mg->max_group_prob_rate);\n\tmax_gpr_idx = MI_RATE_IDX(mg->max_group_prob_rate);\n\tmax_gpr_prob = mi->groups[max_gpr_group].rates[max_gpr_idx].prob_avg;\n\n\tif (mrs->prob_avg > MINSTREL_FRAC(75, 100)) {\n\t\tcur_tp_avg = minstrel_ht_get_tp_avg(mi, cur_group, cur_idx,\n\t\t\t\t\t\t    mrs->prob_avg);\n\t\tif (cur_tp_avg > tmp_tp_avg)\n\t\t\t*dest = index;\n\n\t\tmax_gpr_tp_avg = minstrel_ht_get_tp_avg(mi, max_gpr_group,\n\t\t\t\t\t\t\tmax_gpr_idx,\n\t\t\t\t\t\t\tmax_gpr_prob);\n\t\tif (cur_tp_avg > max_gpr_tp_avg)\n\t\t\tmg->max_group_prob_rate = index;\n\t} else {\n\t\tif (mrs->prob_avg > tmp_prob)\n\t\t\t*dest = index;\n\t\tif (mrs->prob_avg > max_gpr_prob)\n\t\t\tmg->max_group_prob_rate = index;\n\t}\n}\n\n\n \nstatic void\nminstrel_ht_assign_best_tp_rates(struct minstrel_ht_sta *mi,\n\t\t\t\t u16 tmp_mcs_tp_rate[MAX_THR_RATES],\n\t\t\t\t u16 tmp_legacy_tp_rate[MAX_THR_RATES])\n{\n\tunsigned int tmp_group, tmp_idx, tmp_cck_tp, tmp_mcs_tp, tmp_prob;\n\tint i;\n\n\ttmp_group = MI_RATE_GROUP(tmp_legacy_tp_rate[0]);\n\ttmp_idx = MI_RATE_IDX(tmp_legacy_tp_rate[0]);\n\ttmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;\n\ttmp_cck_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);\n\n\ttmp_group = MI_RATE_GROUP(tmp_mcs_tp_rate[0]);\n\ttmp_idx = MI_RATE_IDX(tmp_mcs_tp_rate[0]);\n\ttmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;\n\ttmp_mcs_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);\n\n\tif (tmp_cck_tp > tmp_mcs_tp) {\n\t\tfor(i = 0; i < MAX_THR_RATES; i++) {\n\t\t\tminstrel_ht_sort_best_tp_rates(mi, tmp_legacy_tp_rate[i],\n\t\t\t\t\t\t       tmp_mcs_tp_rate);\n\t\t}\n\t}\n\n}\n\n \nstatic inline void\nminstrel_ht_prob_rate_reduce_streams(struct minstrel_ht_sta *mi)\n{\n\tstruct minstrel_mcs_group_data *mg;\n\tint tmp_max_streams, group, tmp_idx, tmp_prob;\n\tint tmp_tp = 0;\n\n\tif (!mi->sta->deflink.ht_cap.ht_supported)\n\t\treturn;\n\n\tgroup = MI_RATE_GROUP(mi->max_tp_rate[0]);\n\ttmp_max_streams = minstrel_mcs_groups[group].streams;\n\tfor (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {\n\t\tmg = &mi->groups[group];\n\t\tif (!mi->supported[group] || group == MINSTREL_CCK_GROUP)\n\t\t\tcontinue;\n\n\t\ttmp_idx = MI_RATE_IDX(mg->max_group_prob_rate);\n\t\ttmp_prob = mi->groups[group].rates[tmp_idx].prob_avg;\n\n\t\tif (tmp_tp < minstrel_ht_get_tp_avg(mi, group, tmp_idx, tmp_prob) &&\n\t\t   (minstrel_mcs_groups[group].streams < tmp_max_streams)) {\n\t\t\t\tmi->max_prob_rate = mg->max_group_prob_rate;\n\t\t\t\ttmp_tp = minstrel_ht_get_tp_avg(mi, group,\n\t\t\t\t\t\t\t\ttmp_idx,\n\t\t\t\t\t\t\t\ttmp_prob);\n\t\t}\n\t}\n}\n\nstatic u16\n__minstrel_ht_get_sample_rate(struct minstrel_ht_sta *mi,\n\t\t\t      enum minstrel_sample_type type)\n{\n\tu16 *rates = mi->sample[type].sample_rates;\n\tu16 cur;\n\tint i;\n\n\tfor (i = 0; i < MINSTREL_SAMPLE_RATES; i++) {\n\t\tif (!rates[i])\n\t\t\tcontinue;\n\n\t\tcur = rates[i];\n\t\trates[i] = 0;\n\t\treturn cur;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int\nminstrel_ewma(int old, int new, int weight)\n{\n\tint diff, incr;\n\n\tdiff = new - old;\n\tincr = (EWMA_DIV - weight) * diff / EWMA_DIV;\n\n\treturn old + incr;\n}\n\nstatic inline int minstrel_filter_avg_add(u16 *prev_1, u16 *prev_2, s32 in)\n{\n\ts32 out_1 = *prev_1;\n\ts32 out_2 = *prev_2;\n\ts32 val;\n\n\tif (!in)\n\t\tin += 1;\n\n\tif (!out_1) {\n\t\tval = out_1 = in;\n\t\tgoto out;\n\t}\n\n\tval = MINSTREL_AVG_COEFF1 * in;\n\tval += MINSTREL_AVG_COEFF2 * out_1;\n\tval += MINSTREL_AVG_COEFF3 * out_2;\n\tval >>= MINSTREL_SCALE;\n\n\tif (val > 1 << MINSTREL_SCALE)\n\t\tval = 1 << MINSTREL_SCALE;\n\tif (val < 0)\n\t\tval = 1;\n\nout:\n\t*prev_2 = out_1;\n\t*prev_1 = val;\n\n\treturn val;\n}\n\n \nstatic void\nminstrel_ht_calc_rate_stats(struct minstrel_priv *mp,\n\t\t\t    struct minstrel_rate_stats *mrs)\n{\n\tunsigned int cur_prob;\n\n\tif (unlikely(mrs->attempts > 0)) {\n\t\tcur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);\n\t\tminstrel_filter_avg_add(&mrs->prob_avg,\n\t\t\t\t\t&mrs->prob_avg_1, cur_prob);\n\t\tmrs->att_hist += mrs->attempts;\n\t\tmrs->succ_hist += mrs->success;\n\t}\n\n\tmrs->last_success = mrs->success;\n\tmrs->last_attempts = mrs->attempts;\n\tmrs->success = 0;\n\tmrs->attempts = 0;\n}\n\nstatic bool\nminstrel_ht_find_sample_rate(struct minstrel_ht_sta *mi, int type, int idx)\n{\n\tint i;\n\n\tfor (i = 0; i < MINSTREL_SAMPLE_RATES; i++) {\n\t\tu16 cur = mi->sample[type].sample_rates[i];\n\n\t\tif (cur == idx)\n\t\t\treturn true;\n\n\t\tif (!cur)\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic int\nminstrel_ht_move_sample_rates(struct minstrel_ht_sta *mi, int type,\n\t\t\t      u32 fast_rate_dur, u32 slow_rate_dur)\n{\n\tu16 *rates = mi->sample[type].sample_rates;\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < MINSTREL_SAMPLE_RATES; i++) {\n\t\tu32 duration;\n\t\tbool valid = false;\n\t\tu16 cur;\n\n\t\tcur = rates[i];\n\t\tif (!cur)\n\t\t\tcontinue;\n\n\t\tduration = minstrel_get_duration(cur);\n\t\tswitch (type) {\n\t\tcase MINSTREL_SAMPLE_TYPE_SLOW:\n\t\t\tvalid = duration > fast_rate_dur &&\n\t\t\t\tduration < slow_rate_dur;\n\t\t\tbreak;\n\t\tcase MINSTREL_SAMPLE_TYPE_INC:\n\t\tcase MINSTREL_SAMPLE_TYPE_JUMP:\n\t\t\tvalid = duration < fast_rate_dur;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvalid = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!valid) {\n\t\t\trates[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i == j)\n\t\t\tcontinue;\n\n\t\trates[j++] = cur;\n\t\trates[i] = 0;\n\t}\n\n\treturn j;\n}\n\nstatic int\nminstrel_ht_group_min_rate_offset(struct minstrel_ht_sta *mi, int group,\n\t\t\t\t  u32 max_duration)\n{\n\tu16 supported = mi->supported[group];\n\tint i;\n\n\tfor (i = 0; i < MCS_GROUP_RATES && supported; i++, supported >>= 1) {\n\t\tif (!(supported & BIT(0)))\n\t\t\tcontinue;\n\n\t\tif (minstrel_get_duration(MI_RATE(group, i)) >= max_duration)\n\t\t\tcontinue;\n\n\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\n \nstatic u16\nminstrel_ht_next_inc_rate(struct minstrel_ht_sta *mi, u32 fast_rate_dur)\n{\n\tu8 type = MINSTREL_SAMPLE_TYPE_INC;\n\tint i, index = 0;\n\tu8 group;\n\n\tgroup = mi->sample[type].sample_group;\n\tfor (i = 0; i < ARRAY_SIZE(minstrel_mcs_groups); i++) {\n\t\tgroup = (group + 1) % ARRAY_SIZE(minstrel_mcs_groups);\n\n\t\tindex = minstrel_ht_group_min_rate_offset(mi, group,\n\t\t\t\t\t\t\t  fast_rate_dur);\n\t\tif (index < 0)\n\t\t\tcontinue;\n\n\t\tindex = MI_RATE(group, index & 0xf);\n\t\tif (!minstrel_ht_find_sample_rate(mi, type, index))\n\t\t\tgoto out;\n\t}\n\tindex = 0;\n\nout:\n\tmi->sample[type].sample_group = group;\n\n\treturn index;\n}\n\nstatic int\nminstrel_ht_next_group_sample_rate(struct minstrel_ht_sta *mi, int group,\n\t\t\t\t   u16 supported, int offset)\n{\n\tstruct minstrel_mcs_group_data *mg = &mi->groups[group];\n\tu16 idx;\n\tint i;\n\n\tfor (i = 0; i < MCS_GROUP_RATES; i++) {\n\t\tidx = sample_table[mg->column][mg->index];\n\t\tif (++mg->index >= MCS_GROUP_RATES) {\n\t\t\tmg->index = 0;\n\t\t\tif (++mg->column >= ARRAY_SIZE(sample_table))\n\t\t\t\tmg->column = 0;\n\t\t}\n\n\t\tif (idx < offset)\n\t\t\tcontinue;\n\n\t\tif (!(supported & BIT(idx)))\n\t\t\tcontinue;\n\n\t\treturn MI_RATE(group, idx);\n\t}\n\n\treturn -1;\n}\n\n \nstatic u16\nminstrel_ht_next_jump_rate(struct minstrel_ht_sta *mi, u32 fast_rate_dur,\n\t\t\t   u32 slow_rate_dur, int *slow_rate_ofs)\n{\n\tstruct minstrel_rate_stats *mrs;\n\tu32 max_duration = slow_rate_dur;\n\tint i, index, offset;\n\tu16 *slow_rates;\n\tu16 supported;\n\tu32 duration;\n\tu8 group;\n\n\tif (*slow_rate_ofs >= MINSTREL_SAMPLE_RATES)\n\t\tmax_duration = fast_rate_dur;\n\n\tslow_rates = mi->sample[MINSTREL_SAMPLE_TYPE_SLOW].sample_rates;\n\tgroup = mi->sample[MINSTREL_SAMPLE_TYPE_JUMP].sample_group;\n\tfor (i = 0; i < ARRAY_SIZE(minstrel_mcs_groups); i++) {\n\t\tu8 type;\n\n\t\tgroup = (group + 1) % ARRAY_SIZE(minstrel_mcs_groups);\n\n\t\tsupported = mi->supported[group];\n\t\tif (!supported)\n\t\t\tcontinue;\n\n\t\toffset = minstrel_ht_group_min_rate_offset(mi, group,\n\t\t\t\t\t\t\t   max_duration);\n\t\tif (offset < 0)\n\t\t\tcontinue;\n\n\t\tindex = minstrel_ht_next_group_sample_rate(mi, group, supported,\n\t\t\t\t\t\t\t   offset);\n\t\tif (index < 0)\n\t\t\tcontinue;\n\n\t\tduration = minstrel_get_duration(index);\n\t\tif (duration < fast_rate_dur)\n\t\t\ttype = MINSTREL_SAMPLE_TYPE_JUMP;\n\t\telse\n\t\t\ttype = MINSTREL_SAMPLE_TYPE_SLOW;\n\n\t\tif (minstrel_ht_find_sample_rate(mi, type, index))\n\t\t\tcontinue;\n\n\t\tif (type == MINSTREL_SAMPLE_TYPE_JUMP)\n\t\t\tgoto found;\n\n\t\tif (*slow_rate_ofs >= MINSTREL_SAMPLE_RATES)\n\t\t\tcontinue;\n\n\t\tif (duration >= slow_rate_dur)\n\t\t\tcontinue;\n\n\t\t \n\t\tmrs = minstrel_get_ratestats(mi, index);\n\t\tif (mrs->prob_avg > MINSTREL_FRAC(95, 100))\n\t\t\tcontinue;\n\n\t\tslow_rates[(*slow_rate_ofs)++] = index;\n\t\tif (*slow_rate_ofs >= MINSTREL_SAMPLE_RATES)\n\t\t\tmax_duration = fast_rate_dur;\n\t}\n\tindex = 0;\n\nfound:\n\tmi->sample[MINSTREL_SAMPLE_TYPE_JUMP].sample_group = group;\n\n\treturn index;\n}\n\nstatic void\nminstrel_ht_refill_sample_rates(struct minstrel_ht_sta *mi)\n{\n\tu32 prob_dur = minstrel_get_duration(mi->max_prob_rate);\n\tu32 tp_dur = minstrel_get_duration(mi->max_tp_rate[0]);\n\tu32 tp2_dur = minstrel_get_duration(mi->max_tp_rate[1]);\n\tu32 fast_rate_dur = min(min(tp_dur, tp2_dur), prob_dur);\n\tu32 slow_rate_dur = max(max(tp_dur, tp2_dur), prob_dur);\n\tu16 *rates;\n\tint i, j;\n\n\trates = mi->sample[MINSTREL_SAMPLE_TYPE_INC].sample_rates;\n\ti = minstrel_ht_move_sample_rates(mi, MINSTREL_SAMPLE_TYPE_INC,\n\t\t\t\t\t  fast_rate_dur, slow_rate_dur);\n\twhile (i < MINSTREL_SAMPLE_RATES) {\n\t\trates[i] = minstrel_ht_next_inc_rate(mi, tp_dur);\n\t\tif (!rates[i])\n\t\t\tbreak;\n\n\t\ti++;\n\t}\n\n\trates = mi->sample[MINSTREL_SAMPLE_TYPE_JUMP].sample_rates;\n\ti = minstrel_ht_move_sample_rates(mi, MINSTREL_SAMPLE_TYPE_JUMP,\n\t\t\t\t\t  fast_rate_dur, slow_rate_dur);\n\tj = minstrel_ht_move_sample_rates(mi, MINSTREL_SAMPLE_TYPE_SLOW,\n\t\t\t\t\t  fast_rate_dur, slow_rate_dur);\n\twhile (i < MINSTREL_SAMPLE_RATES) {\n\t\trates[i] = minstrel_ht_next_jump_rate(mi, fast_rate_dur,\n\t\t\t\t\t\t      slow_rate_dur, &j);\n\t\tif (!rates[i])\n\t\t\tbreak;\n\n\t\ti++;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mi->sample); i++)\n\t\tmemcpy(mi->sample[i].cur_sample_rates, mi->sample[i].sample_rates,\n\t\t       sizeof(mi->sample[i].cur_sample_rates));\n}\n\n\n \nstatic void\nminstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)\n{\n\tstruct minstrel_mcs_group_data *mg;\n\tstruct minstrel_rate_stats *mrs;\n\tint group, i, j, cur_prob;\n\tu16 tmp_mcs_tp_rate[MAX_THR_RATES], tmp_group_tp_rate[MAX_THR_RATES];\n\tu16 tmp_legacy_tp_rate[MAX_THR_RATES], tmp_max_prob_rate;\n\tu16 index;\n\tbool ht_supported = mi->sta->deflink.ht_cap.ht_supported;\n\n\tif (mi->ampdu_packets > 0) {\n\t\tif (!ieee80211_hw_check(mp->hw, TX_STATUS_NO_AMPDU_LEN))\n\t\t\tmi->avg_ampdu_len = minstrel_ewma(mi->avg_ampdu_len,\n\t\t\t\tMINSTREL_FRAC(mi->ampdu_len, mi->ampdu_packets),\n\t\t\t\t\t      EWMA_LEVEL);\n\t\telse\n\t\t\tmi->avg_ampdu_len = 0;\n\t\tmi->ampdu_len = 0;\n\t\tmi->ampdu_packets = 0;\n\t}\n\n\tif (mi->supported[MINSTREL_CCK_GROUP])\n\t\tgroup = MINSTREL_CCK_GROUP;\n\telse if (mi->supported[MINSTREL_OFDM_GROUP])\n\t\tgroup = MINSTREL_OFDM_GROUP;\n\telse\n\t\tgroup = 0;\n\n\tindex = MI_RATE(group, 0);\n\tfor (j = 0; j < ARRAY_SIZE(tmp_legacy_tp_rate); j++)\n\t\ttmp_legacy_tp_rate[j] = index;\n\n\tif (mi->supported[MINSTREL_VHT_GROUP_0])\n\t\tgroup = MINSTREL_VHT_GROUP_0;\n\telse if (ht_supported)\n\t\tgroup = MINSTREL_HT_GROUP_0;\n\telse if (mi->supported[MINSTREL_CCK_GROUP])\n\t\tgroup = MINSTREL_CCK_GROUP;\n\telse\n\t\tgroup = MINSTREL_OFDM_GROUP;\n\n\tindex = MI_RATE(group, 0);\n\ttmp_max_prob_rate = index;\n\tfor (j = 0; j < ARRAY_SIZE(tmp_mcs_tp_rate); j++)\n\t\ttmp_mcs_tp_rate[j] = index;\n\n\t \n\tfor (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {\n\t\tu16 *tp_rate = tmp_mcs_tp_rate;\n\t\tu16 last_prob = 0;\n\n\t\tmg = &mi->groups[group];\n\t\tif (!mi->supported[group])\n\t\t\tcontinue;\n\n\t\t \n\t\tfor(j = 0; j < MAX_THR_RATES; j++)\n\t\t\ttmp_group_tp_rate[j] = MI_RATE(group, 0);\n\n\t\tif (group == MINSTREL_CCK_GROUP && ht_supported)\n\t\t\ttp_rate = tmp_legacy_tp_rate;\n\n\t\tfor (i = MCS_GROUP_RATES - 1; i >= 0; i--) {\n\t\t\tif (!(mi->supported[group] & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\tindex = MI_RATE(group, i);\n\n\t\t\tmrs = &mg->rates[i];\n\t\t\tmrs->retry_updated = false;\n\t\t\tminstrel_ht_calc_rate_stats(mp, mrs);\n\n\t\t\tif (mrs->att_hist)\n\t\t\t\tlast_prob = max(last_prob, mrs->prob_avg);\n\t\t\telse\n\t\t\t\tmrs->prob_avg = max(last_prob, mrs->prob_avg);\n\t\t\tcur_prob = mrs->prob_avg;\n\n\t\t\tif (minstrel_ht_get_tp_avg(mi, group, i, cur_prob) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tminstrel_ht_sort_best_tp_rates(mi, index, tp_rate);\n\n\t\t\t \n\t\t\tminstrel_ht_sort_best_tp_rates(mi, index,\n\t\t\t\t\t\t       tmp_group_tp_rate);\n\t\t}\n\n\t\tmemcpy(mg->max_group_tp_rate, tmp_group_tp_rate,\n\t\t       sizeof(mg->max_group_tp_rate));\n\t}\n\n\t \n\tminstrel_ht_assign_best_tp_rates(mi, tmp_mcs_tp_rate,\n\t\t\t\t\t tmp_legacy_tp_rate);\n\tmemcpy(mi->max_tp_rate, tmp_mcs_tp_rate, sizeof(mi->max_tp_rate));\n\n\tfor (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {\n\t\tif (!mi->supported[group])\n\t\t\tcontinue;\n\n\t\tmg = &mi->groups[group];\n\t\tmg->max_group_prob_rate = MI_RATE(group, 0);\n\n\t\tfor (i = 0; i < MCS_GROUP_RATES; i++) {\n\t\t\tif (!(mi->supported[group] & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\tindex = MI_RATE(group, i);\n\n\t\t\t \n\t\t\tminstrel_ht_set_best_prob_rate(mi, &tmp_max_prob_rate,\n\t\t\t\t\t\t       index);\n\t\t}\n\t}\n\n\tmi->max_prob_rate = tmp_max_prob_rate;\n\n\t \n\tminstrel_ht_prob_rate_reduce_streams(mi);\n\tminstrel_ht_refill_sample_rates(mi);\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t \n\tif (mp->fixed_rate_idx != -1) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tmi->max_tp_rate[i] = mp->fixed_rate_idx;\n\t\tmi->max_prob_rate = mp->fixed_rate_idx;\n\t}\n#endif\n\n\t \n\tmi->last_stats_update = jiffies;\n\tmi->sample_time = jiffies;\n}\n\nstatic bool\nminstrel_ht_txstat_valid(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\n\t\t\t struct ieee80211_tx_rate *rate)\n{\n\tint i;\n\n\tif (rate->idx < 0)\n\t\treturn false;\n\n\tif (!rate->count)\n\t\treturn false;\n\n\tif (rate->flags & IEEE80211_TX_RC_MCS ||\n\t    rate->flags & IEEE80211_TX_RC_VHT_MCS)\n\t\treturn true;\n\n\tfor (i = 0; i < ARRAY_SIZE(mp->cck_rates); i++)\n\t\tif (rate->idx == mp->cck_rates[i])\n\t\t\treturn true;\n\n\tfor (i = 0; i < ARRAY_SIZE(mp->ofdm_rates[0]); i++)\n\t\tif (rate->idx == mp->ofdm_rates[mi->band][i])\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool\nminstrel_ht_ri_txstat_valid(struct minstrel_priv *mp,\n\t\t\t    struct minstrel_ht_sta *mi,\n\t\t\t    struct ieee80211_rate_status *rate_status)\n{\n\tint i;\n\n\tif (!rate_status)\n\t\treturn false;\n\tif (!rate_status->try_count)\n\t\treturn false;\n\n\tif (rate_status->rate_idx.flags & RATE_INFO_FLAGS_MCS ||\n\t    rate_status->rate_idx.flags & RATE_INFO_FLAGS_VHT_MCS)\n\t\treturn true;\n\n\tfor (i = 0; i < ARRAY_SIZE(mp->cck_rates); i++) {\n\t\tif (rate_status->rate_idx.legacy ==\n\t\t    minstrel_cck_bitrates[ mp->cck_rates[i] ])\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mp->ofdm_rates); i++) {\n\t\tif (rate_status->rate_idx.legacy ==\n\t\t    minstrel_ofdm_bitrates[ mp->ofdm_rates[mi->band][i] ])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void\nminstrel_downgrade_rate(struct minstrel_ht_sta *mi, u16 *idx, bool primary)\n{\n\tint group, orig_group;\n\n\torig_group = group = MI_RATE_GROUP(*idx);\n\twhile (group > 0) {\n\t\tgroup--;\n\n\t\tif (!mi->supported[group])\n\t\t\tcontinue;\n\n\t\tif (minstrel_mcs_groups[group].streams >\n\t\t    minstrel_mcs_groups[orig_group].streams)\n\t\t\tcontinue;\n\n\t\tif (primary)\n\t\t\t*idx = mi->groups[group].max_group_tp_rate[0];\n\t\telse\n\t\t\t*idx = mi->groups[group].max_group_tp_rate[1];\n\t\tbreak;\n\t}\n}\n\nstatic void\nminstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,\n                      void *priv_sta, struct ieee80211_tx_status *st)\n{\n\tstruct ieee80211_tx_info *info = st->info;\n\tstruct minstrel_ht_sta *mi = priv_sta;\n\tstruct ieee80211_tx_rate *ar = info->status.rates;\n\tstruct minstrel_rate_stats *rate, *rate2;\n\tstruct minstrel_priv *mp = priv;\n\tu32 update_interval = mp->update_interval;\n\tbool last, update = false;\n\tint i;\n\n\t \n\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\treturn;\n\n\t \n\tif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\n\t    !(info->flags & IEEE80211_TX_STAT_AMPDU))\n\t\treturn;\n\n\tif (!(info->flags & IEEE80211_TX_STAT_AMPDU)) {\n\t\tinfo->status.ampdu_ack_len =\n\t\t\t(info->flags & IEEE80211_TX_STAT_ACK ? 1 : 0);\n\t\tinfo->status.ampdu_len = 1;\n\t}\n\n\t \n\tif (mi->total_packets >= ~0 - info->status.ampdu_len) {\n\t\tmi->total_packets = 0;\n\t\tmi->sample_packets = 0;\n\t}\n\n\tmi->total_packets += info->status.ampdu_len;\n\tif (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)\n\t\tmi->sample_packets += info->status.ampdu_len;\n\n\tmi->ampdu_packets++;\n\tmi->ampdu_len += info->status.ampdu_len;\n\n\tif (st->rates && st->n_rates) {\n\t\tlast = !minstrel_ht_ri_txstat_valid(mp, mi, &(st->rates[0]));\n\t\tfor (i = 0; !last; i++) {\n\t\t\tlast = (i == st->n_rates - 1) ||\n\t\t\t\t!minstrel_ht_ri_txstat_valid(mp, mi,\n\t\t\t\t\t\t\t&(st->rates[i + 1]));\n\n\t\t\trate = minstrel_ht_ri_get_stats(mp, mi,\n\t\t\t\t\t\t\t&(st->rates[i]));\n\n\t\t\tif (last)\n\t\t\t\trate->success += info->status.ampdu_ack_len;\n\n\t\t\trate->attempts += st->rates[i].try_count *\n\t\t\t\t\t  info->status.ampdu_len;\n\t\t}\n\t} else {\n\t\tlast = !minstrel_ht_txstat_valid(mp, mi, &ar[0]);\n\t\tfor (i = 0; !last; i++) {\n\t\t\tlast = (i == IEEE80211_TX_MAX_RATES - 1) ||\n\t\t\t\t!minstrel_ht_txstat_valid(mp, mi, &ar[i + 1]);\n\n\t\t\trate = minstrel_ht_get_stats(mp, mi, &ar[i]);\n\t\t\tif (last)\n\t\t\t\trate->success += info->status.ampdu_ack_len;\n\n\t\t\trate->attempts += ar[i].count * info->status.ampdu_len;\n\t\t}\n\t}\n\n\tif (mp->hw->max_rates > 1) {\n\t\t \n\t\trate = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);\n\t\tif (rate->attempts > 30 &&\n\t\t    rate->success < rate->attempts / 4) {\n\t\t\tminstrel_downgrade_rate(mi, &mi->max_tp_rate[0], true);\n\t\t\tupdate = true;\n\t\t}\n\n\t\trate2 = minstrel_get_ratestats(mi, mi->max_tp_rate[1]);\n\t\tif (rate2->attempts > 30 &&\n\t\t    rate2->success < rate2->attempts / 4) {\n\t\t\tminstrel_downgrade_rate(mi, &mi->max_tp_rate[1], false);\n\t\t\tupdate = true;\n\t\t}\n\t}\n\n\tif (time_after(jiffies, mi->last_stats_update + update_interval)) {\n\t\tupdate = true;\n\t\tminstrel_ht_update_stats(mp, mi);\n\t}\n\n\tif (update)\n\t\tminstrel_ht_update_rates(mp, mi);\n}\n\nstatic void\nminstrel_calc_retransmit(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\n                         int index)\n{\n\tstruct minstrel_rate_stats *mrs;\n\tunsigned int tx_time, tx_time_rtscts, tx_time_data;\n\tunsigned int cw = mp->cw_min;\n\tunsigned int ctime = 0;\n\tunsigned int t_slot = 9;  \n\tunsigned int ampdu_len = minstrel_ht_avg_ampdu_len(mi);\n\tunsigned int overhead = 0, overhead_rtscts = 0;\n\n\tmrs = minstrel_get_ratestats(mi, index);\n\tif (mrs->prob_avg < MINSTREL_FRAC(1, 10)) {\n\t\tmrs->retry_count = 1;\n\t\tmrs->retry_count_rtscts = 1;\n\t\treturn;\n\t}\n\n\tmrs->retry_count = 2;\n\tmrs->retry_count_rtscts = 2;\n\tmrs->retry_updated = true;\n\n\ttx_time_data = minstrel_get_duration(index) * ampdu_len / 1000;\n\n\t \n\tctime = (t_slot * cw) >> 1;\n\tcw = min((cw << 1) | 1, mp->cw_max);\n\tctime += (t_slot * cw) >> 1;\n\tcw = min((cw << 1) | 1, mp->cw_max);\n\n\tif (minstrel_ht_is_legacy_group(MI_RATE_GROUP(index))) {\n\t\toverhead = mi->overhead_legacy;\n\t\toverhead_rtscts = mi->overhead_legacy_rtscts;\n\t} else {\n\t\toverhead = mi->overhead;\n\t\toverhead_rtscts = mi->overhead_rtscts;\n\t}\n\n\t \n\ttx_time = ctime + 2 * (overhead + tx_time_data);\n\ttx_time_rtscts = ctime + 2 * (overhead_rtscts + tx_time_data);\n\n\t \n\tdo {\n\t\t \n\t\tctime = (t_slot * cw) >> 1;\n\t\tcw = min((cw << 1) | 1, mp->cw_max);\n\n\t\t \n\t\ttx_time += ctime + overhead + tx_time_data;\n\t\ttx_time_rtscts += ctime + overhead_rtscts + tx_time_data;\n\n\t\tif (tx_time_rtscts < mp->segment_size)\n\t\t\tmrs->retry_count_rtscts++;\n\t} while ((tx_time < mp->segment_size) &&\n\t         (++mrs->retry_count < mp->max_retry));\n}\n\n\nstatic void\nminstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\n                     struct ieee80211_sta_rates *ratetbl, int offset, int index)\n{\n\tint group_idx = MI_RATE_GROUP(index);\n\tconst struct mcs_group *group = &minstrel_mcs_groups[group_idx];\n\tstruct minstrel_rate_stats *mrs;\n\tu8 idx;\n\tu16 flags = group->flags;\n\n\tmrs = minstrel_get_ratestats(mi, index);\n\tif (!mrs->retry_updated)\n\t\tminstrel_calc_retransmit(mp, mi, index);\n\n\tif (mrs->prob_avg < MINSTREL_FRAC(20, 100) || !mrs->retry_count) {\n\t\tratetbl->rate[offset].count = 2;\n\t\tratetbl->rate[offset].count_rts = 2;\n\t\tratetbl->rate[offset].count_cts = 2;\n\t} else {\n\t\tratetbl->rate[offset].count = mrs->retry_count;\n\t\tratetbl->rate[offset].count_cts = mrs->retry_count;\n\t\tratetbl->rate[offset].count_rts = mrs->retry_count_rtscts;\n\t}\n\n\tindex = MI_RATE_IDX(index);\n\tif (group_idx == MINSTREL_CCK_GROUP)\n\t\tidx = mp->cck_rates[index % ARRAY_SIZE(mp->cck_rates)];\n\telse if (group_idx == MINSTREL_OFDM_GROUP)\n\t\tidx = mp->ofdm_rates[mi->band][index %\n\t\t\t\t\t       ARRAY_SIZE(mp->ofdm_rates[0])];\n\telse if (flags & IEEE80211_TX_RC_VHT_MCS)\n\t\tidx = ((group->streams - 1) << 4) |\n\t\t      (index & 0xF);\n\telse\n\t\tidx = index + (group->streams - 1) * 8;\n\n\t \n\tif (offset > 0 ||\n\t    (mi->sta->deflink.smps_mode == IEEE80211_SMPS_DYNAMIC &&\n\t     group->streams > 1)) {\n\t\tratetbl->rate[offset].count = ratetbl->rate[offset].count_rts;\n\t\tflags |= IEEE80211_TX_RC_USE_RTS_CTS;\n\t}\n\n\tratetbl->rate[offset].idx = idx;\n\tratetbl->rate[offset].flags = flags;\n}\n\nstatic inline int\nminstrel_ht_get_prob_avg(struct minstrel_ht_sta *mi, int rate)\n{\n\tint group = MI_RATE_GROUP(rate);\n\trate = MI_RATE_IDX(rate);\n\treturn mi->groups[group].rates[rate].prob_avg;\n}\n\nstatic int\nminstrel_ht_get_max_amsdu_len(struct minstrel_ht_sta *mi)\n{\n\tint group = MI_RATE_GROUP(mi->max_prob_rate);\n\tconst struct mcs_group *g = &minstrel_mcs_groups[group];\n\tint rate = MI_RATE_IDX(mi->max_prob_rate);\n\tunsigned int duration;\n\n\t \n\tif (mi->groups[group].rates[rate].prob_avg < MINSTREL_FRAC(50, 100))\n\t\treturn 1;\n\n\tduration = g->duration[rate];\n\tduration <<= g->shift;\n\n\t \n\tif (duration > MCS_DURATION(1, 0, 52))\n\t\treturn 500;\n\n\t \n\tif (duration > MCS_DURATION(1, 0, 104))\n\t\treturn 1600;\n\n\t \n\tif (duration > MCS_DURATION(1, 0, 260) ||\n\t    (minstrel_ht_get_prob_avg(mi, mi->max_tp_rate[0]) <\n\t     MINSTREL_FRAC(75, 100)))\n\t\treturn 3200;\n\n\t \n\tif (!mi->sta->deflink.vht_cap.vht_supported)\n\t\treturn IEEE80211_MAX_MPDU_LEN_HT_BA;\n\n\t \n\treturn 0;\n}\n\nstatic void\nminstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)\n{\n\tstruct ieee80211_sta_rates *rates;\n\tint i = 0;\n\tint max_rates = min_t(int, mp->hw->max_rates, IEEE80211_TX_RATE_TABLE_SIZE);\n\n\trates = kzalloc(sizeof(*rates), GFP_ATOMIC);\n\tif (!rates)\n\t\treturn;\n\n\t \n\tminstrel_ht_set_rate(mp, mi, rates, i++, mi->max_tp_rate[0]);\n\n\t \n\tfor (; i < (max_rates - 1); i++)\n\t\tminstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[i]);\n\n\tif (i < max_rates)\n\t\tminstrel_ht_set_rate(mp, mi, rates, i++, mi->max_prob_rate);\n\n\tif (i < IEEE80211_TX_RATE_TABLE_SIZE)\n\t\trates->rate[i].idx = -1;\n\n\tmi->sta->deflink.agg.max_rc_amsdu_len = minstrel_ht_get_max_amsdu_len(mi);\n\tieee80211_sta_recalc_aggregates(mi->sta);\n\trate_control_set_rates(mp->hw, mi->sta, rates);\n}\n\nstatic u16\nminstrel_ht_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)\n{\n\tu8 seq;\n\n\tif (mp->hw->max_rates > 1) {\n\t\tseq = mi->sample_seq;\n\t\tmi->sample_seq = (seq + 1) % ARRAY_SIZE(minstrel_sample_seq);\n\t\tseq = minstrel_sample_seq[seq];\n\t} else {\n\t\tseq = MINSTREL_SAMPLE_TYPE_INC;\n\t}\n\n\treturn __minstrel_ht_get_sample_rate(mi, seq);\n}\n\nstatic void\nminstrel_ht_get_rate(void *priv, struct ieee80211_sta *sta, void *priv_sta,\n                     struct ieee80211_tx_rate_control *txrc)\n{\n\tconst struct mcs_group *sample_group;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);\n\tstruct ieee80211_tx_rate *rate = &info->status.rates[0];\n\tstruct minstrel_ht_sta *mi = priv_sta;\n\tstruct minstrel_priv *mp = priv;\n\tu16 sample_idx;\n\n\tinfo->flags |= mi->tx_flags;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tif (mp->fixed_rate_idx != -1)\n\t\treturn;\n#endif\n\n\t \n\tif (mp->hw->max_rates == 1 &&\n\t    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))\n\t\treturn;\n\n\tif (time_is_after_jiffies(mi->sample_time))\n\t\treturn;\n\n\tmi->sample_time = jiffies + MINSTREL_SAMPLE_INTERVAL;\n\tsample_idx = minstrel_ht_get_sample_rate(mp, mi);\n\tif (!sample_idx)\n\t\treturn;\n\n\tsample_group = &minstrel_mcs_groups[MI_RATE_GROUP(sample_idx)];\n\tsample_idx = MI_RATE_IDX(sample_idx);\n\n\tif (sample_group == &minstrel_mcs_groups[MINSTREL_CCK_GROUP] &&\n\t    (sample_idx >= 4) != txrc->short_preamble)\n\t\treturn;\n\n\tinfo->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;\n\trate->count = 1;\n\n\tif (sample_group == &minstrel_mcs_groups[MINSTREL_CCK_GROUP]) {\n\t\tint idx = sample_idx % ARRAY_SIZE(mp->cck_rates);\n\t\trate->idx = mp->cck_rates[idx];\n\t} else if (sample_group == &minstrel_mcs_groups[MINSTREL_OFDM_GROUP]) {\n\t\tint idx = sample_idx % ARRAY_SIZE(mp->ofdm_rates[0]);\n\t\trate->idx = mp->ofdm_rates[mi->band][idx];\n\t} else if (sample_group->flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\tieee80211_rate_set_vht(rate, MI_RATE_IDX(sample_idx),\n\t\t\t\t       sample_group->streams);\n\t} else {\n\t\trate->idx = sample_idx + (sample_group->streams - 1) * 8;\n\t}\n\n\trate->flags = sample_group->flags;\n}\n\nstatic void\nminstrel_ht_update_cck(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\n\t\t       struct ieee80211_supported_band *sband,\n\t\t       struct ieee80211_sta *sta)\n{\n\tint i;\n\n\tif (sband->band != NL80211_BAND_2GHZ)\n\t\treturn;\n\n\tif (sta->deflink.ht_cap.ht_supported &&\n\t    !ieee80211_hw_check(mp->hw, SUPPORTS_HT_CCK_RATES))\n\t\treturn;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (mp->cck_rates[i] == 0xff ||\n\t\t    !rate_supported(sta, sband->band, mp->cck_rates[i]))\n\t\t\tcontinue;\n\n\t\tmi->supported[MINSTREL_CCK_GROUP] |= BIT(i);\n\t\tif (sband->bitrates[i].flags & IEEE80211_RATE_SHORT_PREAMBLE)\n\t\t\tmi->supported[MINSTREL_CCK_GROUP] |= BIT(i + 4);\n\t}\n}\n\nstatic void\nminstrel_ht_update_ofdm(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,\n\t\t\tstruct ieee80211_supported_band *sband,\n\t\t\tstruct ieee80211_sta *sta)\n{\n\tconst u8 *rates;\n\tint i;\n\n\tif (sta->deflink.ht_cap.ht_supported)\n\t\treturn;\n\n\trates = mp->ofdm_rates[sband->band];\n\tfor (i = 0; i < ARRAY_SIZE(mp->ofdm_rates[0]); i++) {\n\t\tif (rates[i] == 0xff ||\n\t\t    !rate_supported(sta, sband->band, rates[i]))\n\t\t\tcontinue;\n\n\t\tmi->supported[MINSTREL_OFDM_GROUP] |= BIT(i);\n\t}\n}\n\nstatic void\nminstrel_ht_update_caps(void *priv, struct ieee80211_supported_band *sband,\n\t\t\tstruct cfg80211_chan_def *chandef,\n\t\t\tstruct ieee80211_sta *sta, void *priv_sta)\n{\n\tstruct minstrel_priv *mp = priv;\n\tstruct minstrel_ht_sta *mi = priv_sta;\n\tstruct ieee80211_mcs_info *mcs = &sta->deflink.ht_cap.mcs;\n\tu16 ht_cap = sta->deflink.ht_cap.cap;\n\tstruct ieee80211_sta_vht_cap *vht_cap = &sta->deflink.vht_cap;\n\tconst struct ieee80211_rate *ctl_rate;\n\tstruct sta_info *sta_info;\n\tbool ldpc, erp;\n\tint use_vht;\n\tint ack_dur;\n\tint stbc;\n\tint i;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(minstrel_mcs_groups) != MINSTREL_GROUPS_NB);\n\n\tif (vht_cap->vht_supported)\n\t\tuse_vht = vht_cap->vht_mcs.tx_mcs_map != cpu_to_le16(~0);\n\telse\n\t\tuse_vht = 0;\n\n\tmemset(mi, 0, sizeof(*mi));\n\n\tmi->sta = sta;\n\tmi->band = sband->band;\n\tmi->last_stats_update = jiffies;\n\n\tack_dur = ieee80211_frame_duration(sband->band, 10, 60, 1, 1, 0);\n\tmi->overhead = ieee80211_frame_duration(sband->band, 0, 60, 1, 1, 0);\n\tmi->overhead += ack_dur;\n\tmi->overhead_rtscts = mi->overhead + 2 * ack_dur;\n\n\tctl_rate = &sband->bitrates[rate_lowest_index(sband, sta)];\n\terp = ctl_rate->flags & IEEE80211_RATE_ERP_G;\n\tack_dur = ieee80211_frame_duration(sband->band, 10,\n\t\t\t\t\t   ctl_rate->bitrate, erp, 1,\n\t\t\t\t\t   ieee80211_chandef_get_shift(chandef));\n\tmi->overhead_legacy = ack_dur;\n\tmi->overhead_legacy_rtscts = mi->overhead_legacy + 2 * ack_dur;\n\n\tmi->avg_ampdu_len = MINSTREL_FRAC(1, 1);\n\n\tif (!use_vht) {\n\t\tstbc = (ht_cap & IEEE80211_HT_CAP_RX_STBC) >>\n\t\t\tIEEE80211_HT_CAP_RX_STBC_SHIFT;\n\n\t\tldpc = ht_cap & IEEE80211_HT_CAP_LDPC_CODING;\n\t} else {\n\t\tstbc = (vht_cap->cap & IEEE80211_VHT_CAP_RXSTBC_MASK) >>\n\t\t\tIEEE80211_VHT_CAP_RXSTBC_SHIFT;\n\n\t\tldpc = vht_cap->cap & IEEE80211_VHT_CAP_RXLDPC;\n\t}\n\n\tmi->tx_flags |= stbc << IEEE80211_TX_CTL_STBC_SHIFT;\n\tif (ldpc)\n\t\tmi->tx_flags |= IEEE80211_TX_CTL_LDPC;\n\n\tfor (i = 0; i < ARRAY_SIZE(mi->groups); i++) {\n\t\tu32 gflags = minstrel_mcs_groups[i].flags;\n\t\tint bw, nss;\n\n\t\tmi->supported[i] = 0;\n\t\tif (minstrel_ht_is_legacy_group(i))\n\t\t\tcontinue;\n\n\t\tif (gflags & IEEE80211_TX_RC_SHORT_GI) {\n\t\t\tif (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH) {\n\t\t\t\tif (!(ht_cap & IEEE80211_HT_CAP_SGI_40))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!(ht_cap & IEEE80211_HT_CAP_SGI_20))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH &&\n\t\t    sta->deflink.bandwidth < IEEE80211_STA_RX_BW_40)\n\t\t\tcontinue;\n\n\t\tnss = minstrel_mcs_groups[i].streams;\n\n\t\t \n\t\tif (sta->deflink.smps_mode == IEEE80211_SMPS_STATIC && nss > 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (gflags & IEEE80211_TX_RC_MCS) {\n\t\t\tif (use_vht && minstrel_vht_only)\n\t\t\t\tcontinue;\n\n\t\t\tmi->supported[i] = mcs->rx_mask[nss - 1];\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!vht_cap->vht_supported ||\n\t\t    WARN_ON(!(gflags & IEEE80211_TX_RC_VHT_MCS)) ||\n\t\t    WARN_ON(gflags & IEEE80211_TX_RC_160_MHZ_WIDTH))\n\t\t\tcontinue;\n\n\t\tif (gflags & IEEE80211_TX_RC_80_MHZ_WIDTH) {\n\t\t\tif (sta->deflink.bandwidth < IEEE80211_STA_RX_BW_80 ||\n\t\t\t    ((gflags & IEEE80211_TX_RC_SHORT_GI) &&\n\t\t\t     !(vht_cap->cap & IEEE80211_VHT_CAP_SHORT_GI_80))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\tbw = BW_40;\n\t\telse if (gflags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\t\tbw = BW_80;\n\t\telse\n\t\t\tbw = BW_20;\n\n\t\tmi->supported[i] = minstrel_get_valid_vht_rates(bw, nss,\n\t\t\t\tvht_cap->vht_mcs.tx_mcs_map);\n\t}\n\n\tsta_info = container_of(sta, struct sta_info, sta);\n\tmi->use_short_preamble = test_sta_flag(sta_info, WLAN_STA_SHORT_PREAMBLE) &&\n\t\t\t\t sta_info->sdata->vif.bss_conf.use_short_preamble;\n\n\tminstrel_ht_update_cck(mp, mi, sband, sta);\n\tminstrel_ht_update_ofdm(mp, mi, sband, sta);\n\n\t \n\tminstrel_ht_update_stats(mp, mi);\n\tminstrel_ht_update_rates(mp, mi);\n}\n\nstatic void\nminstrel_ht_rate_init(void *priv, struct ieee80211_supported_band *sband,\n\t\t      struct cfg80211_chan_def *chandef,\n                      struct ieee80211_sta *sta, void *priv_sta)\n{\n\tminstrel_ht_update_caps(priv, sband, chandef, sta, priv_sta);\n}\n\nstatic void\nminstrel_ht_rate_update(void *priv, struct ieee80211_supported_band *sband,\n\t\t\tstruct cfg80211_chan_def *chandef,\n                        struct ieee80211_sta *sta, void *priv_sta,\n                        u32 changed)\n{\n\tminstrel_ht_update_caps(priv, sband, chandef, sta, priv_sta);\n}\n\nstatic void *\nminstrel_ht_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)\n{\n\tstruct ieee80211_supported_band *sband;\n\tstruct minstrel_ht_sta *mi;\n\tstruct minstrel_priv *mp = priv;\n\tstruct ieee80211_hw *hw = mp->hw;\n\tint max_rates = 0;\n\tint i;\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tsband = hw->wiphy->bands[i];\n\t\tif (sband && sband->n_bitrates > max_rates)\n\t\t\tmax_rates = sband->n_bitrates;\n\t}\n\n\treturn kzalloc(sizeof(*mi), gfp);\n}\n\nstatic void\nminstrel_ht_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)\n{\n\tkfree(priv_sta);\n}\n\nstatic void\nminstrel_ht_fill_rate_array(u8 *dest, struct ieee80211_supported_band *sband,\n\t\t\t    const s16 *bitrates, int n_rates, u32 rate_flags)\n{\n\tint i, j;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tstruct ieee80211_rate *rate = &sband->bitrates[i];\n\n\t\tif ((rate_flags & sband->bitrates[i].flags) != rate_flags)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < n_rates; j++) {\n\t\t\tif (rate->bitrate != bitrates[j])\n\t\t\t\tcontinue;\n\n\t\t\tdest[j] = i;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\nminstrel_ht_init_cck_rates(struct minstrel_priv *mp)\n{\n\tstatic const s16 bitrates[4] = { 10, 20, 55, 110 };\n\tstruct ieee80211_supported_band *sband;\n\tu32 rate_flags = ieee80211_chandef_rate_flags(&mp->hw->conf.chandef);\n\n\tmemset(mp->cck_rates, 0xff, sizeof(mp->cck_rates));\n\tsband = mp->hw->wiphy->bands[NL80211_BAND_2GHZ];\n\tif (!sband)\n\t\treturn;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(mp->cck_rates) != ARRAY_SIZE(bitrates));\n\tminstrel_ht_fill_rate_array(mp->cck_rates, sband,\n\t\t\t\t    minstrel_cck_bitrates,\n\t\t\t\t    ARRAY_SIZE(minstrel_cck_bitrates),\n\t\t\t\t    rate_flags);\n}\n\nstatic void\nminstrel_ht_init_ofdm_rates(struct minstrel_priv *mp, enum nl80211_band band)\n{\n\tstatic const s16 bitrates[8] = { 60, 90, 120, 180, 240, 360, 480, 540 };\n\tstruct ieee80211_supported_band *sband;\n\tu32 rate_flags = ieee80211_chandef_rate_flags(&mp->hw->conf.chandef);\n\n\tmemset(mp->ofdm_rates[band], 0xff, sizeof(mp->ofdm_rates[band]));\n\tsband = mp->hw->wiphy->bands[band];\n\tif (!sband)\n\t\treturn;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(mp->ofdm_rates[band]) != ARRAY_SIZE(bitrates));\n\tminstrel_ht_fill_rate_array(mp->ofdm_rates[band], sband,\n\t\t\t\t    minstrel_ofdm_bitrates,\n\t\t\t\t    ARRAY_SIZE(minstrel_ofdm_bitrates),\n\t\t\t\t    rate_flags);\n}\n\nstatic void *\nminstrel_ht_alloc(struct ieee80211_hw *hw)\n{\n\tstruct minstrel_priv *mp;\n\tint i;\n\n\tmp = kzalloc(sizeof(struct minstrel_priv), GFP_ATOMIC);\n\tif (!mp)\n\t\treturn NULL;\n\n\t \n\tmp->cw_min = 15;\n\tmp->cw_max = 1023;\n\n\t \n\tmp->segment_size = 6000;\n\n\tif (hw->max_rate_tries > 0)\n\t\tmp->max_retry = hw->max_rate_tries;\n\telse\n\t\t \n\t\tmp->max_retry = 7;\n\n\tmp->hw = hw;\n\tmp->update_interval = HZ / 20;\n\n\tminstrel_ht_init_cck_rates(mp);\n\tfor (i = 0; i < ARRAY_SIZE(mp->hw->wiphy->bands); i++)\n\t    minstrel_ht_init_ofdm_rates(mp, i);\n\n\treturn mp;\n}\n\n#ifdef CONFIG_MAC80211_DEBUGFS\nstatic void minstrel_ht_add_debugfs(struct ieee80211_hw *hw, void *priv,\n\t\t\t\t    struct dentry *debugfsdir)\n{\n\tstruct minstrel_priv *mp = priv;\n\n\tmp->fixed_rate_idx = (u32) -1;\n\tdebugfs_create_u32(\"fixed_rate_idx\", S_IRUGO | S_IWUGO, debugfsdir,\n\t\t\t   &mp->fixed_rate_idx);\n}\n#endif\n\nstatic void\nminstrel_ht_free(void *priv)\n{\n\tkfree(priv);\n}\n\nstatic u32 minstrel_ht_get_expected_throughput(void *priv_sta)\n{\n\tstruct minstrel_ht_sta *mi = priv_sta;\n\tint i, j, prob, tp_avg;\n\n\ti = MI_RATE_GROUP(mi->max_tp_rate[0]);\n\tj = MI_RATE_IDX(mi->max_tp_rate[0]);\n\tprob = mi->groups[i].rates[j].prob_avg;\n\n\t \n\ttp_avg = minstrel_ht_get_tp_avg(mi, i, j, prob) * 10;\n\ttp_avg = tp_avg * AVG_PKT_SIZE * 8 / 1024;\n\n\treturn tp_avg;\n}\n\nstatic const struct rate_control_ops mac80211_minstrel_ht = {\n\t.name = \"minstrel_ht\",\n\t.capa = RATE_CTRL_CAPA_AMPDU_TRIGGER,\n\t.tx_status_ext = minstrel_ht_tx_status,\n\t.get_rate = minstrel_ht_get_rate,\n\t.rate_init = minstrel_ht_rate_init,\n\t.rate_update = minstrel_ht_rate_update,\n\t.alloc_sta = minstrel_ht_alloc_sta,\n\t.free_sta = minstrel_ht_free_sta,\n\t.alloc = minstrel_ht_alloc,\n\t.free = minstrel_ht_free,\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t.add_debugfs = minstrel_ht_add_debugfs,\n\t.add_sta_debugfs = minstrel_ht_add_sta_debugfs,\n#endif\n\t.get_expected_throughput = minstrel_ht_get_expected_throughput,\n};\n\n\nstatic void __init init_sample_table(void)\n{\n\tint col, i, new_idx;\n\tu8 rnd[MCS_GROUP_RATES];\n\n\tmemset(sample_table, 0xff, sizeof(sample_table));\n\tfor (col = 0; col < SAMPLE_COLUMNS; col++) {\n\t\tget_random_bytes(rnd, sizeof(rnd));\n\t\tfor (i = 0; i < MCS_GROUP_RATES; i++) {\n\t\t\tnew_idx = (i + rnd[i]) % MCS_GROUP_RATES;\n\t\t\twhile (sample_table[col][new_idx] != 0xff)\n\t\t\t\tnew_idx = (new_idx + 1) % MCS_GROUP_RATES;\n\n\t\t\tsample_table[col][new_idx] = i;\n\t\t}\n\t}\n}\n\nint __init\nrc80211_minstrel_init(void)\n{\n\tinit_sample_table();\n\treturn ieee80211_rate_control_register(&mac80211_minstrel_ht);\n}\n\nvoid\nrc80211_minstrel_exit(void)\n{\n\tieee80211_rate_control_unregister(&mac80211_minstrel_ht);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}