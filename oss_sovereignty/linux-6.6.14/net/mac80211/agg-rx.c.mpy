{
  "module_name": "agg-rx.c",
  "hash_id": "47ce287288a67bceeea7ca069224633fdee713bb5fb39f29973ec61fe07825e7",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/agg-rx.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/ieee80211.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n\nstatic void ieee80211_free_tid_rx(struct rcu_head *h)\n{\n\tstruct tid_ampdu_rx *tid_rx =\n\t\tcontainer_of(h, struct tid_ampdu_rx, rcu_head);\n\tint i;\n\n\tfor (i = 0; i < tid_rx->buf_size; i++)\n\t\t__skb_queue_purge(&tid_rx->reorder_buf[i]);\n\tkfree(tid_rx->reorder_buf);\n\tkfree(tid_rx->reorder_time);\n\tkfree(tid_rx);\n}\n\nvoid ___ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,\n\t\t\t\t     u16 initiator, u16 reason, bool tx)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct tid_ampdu_rx *tid_rx;\n\tstruct ieee80211_ampdu_params params = {\n\t\t.sta = &sta->sta,\n\t\t.action = IEEE80211_AMPDU_RX_STOP,\n\t\t.tid = tid,\n\t\t.amsdu = false,\n\t\t.timeout = 0,\n\t\t.ssn = 0,\n\t};\n\n\tlockdep_assert_held(&sta->ampdu_mlme.mtx);\n\n\ttid_rx = rcu_dereference_protected(sta->ampdu_mlme.tid_rx[tid],\n\t\t\t\t\tlockdep_is_held(&sta->ampdu_mlme.mtx));\n\n\tif (!test_bit(tid, sta->ampdu_mlme.agg_session_valid))\n\t\treturn;\n\n\tRCU_INIT_POINTER(sta->ampdu_mlme.tid_rx[tid], NULL);\n\t__clear_bit(tid, sta->ampdu_mlme.agg_session_valid);\n\n\tht_dbg(sta->sdata,\n\t       \"Rx BA session stop requested for %pM tid %u %s reason: %d\\n\",\n\t       sta->sta.addr, tid,\n\t       initiator == WLAN_BACK_RECIPIENT ? \"recipient\" : \"initiator\",\n\t       (int)reason);\n\n\tif (drv_ampdu_action(local, sta->sdata, &params))\n\t\tsdata_info(sta->sdata,\n\t\t\t   \"HW problem - can not stop rx aggregation for %pM tid %d\\n\",\n\t\t\t   sta->sta.addr, tid);\n\n\t \n\tif (initiator == WLAN_BACK_RECIPIENT && tx)\n\t\tieee80211_send_delba(sta->sdata, sta->sta.addr,\n\t\t\t\t     tid, WLAN_BACK_RECIPIENT, reason);\n\n\t \n\tif (!tid_rx)\n\t\treturn;\n\n\tdel_timer_sync(&tid_rx->session_timer);\n\n\t \n\tspin_lock_bh(&tid_rx->reorder_lock);\n\ttid_rx->removed = true;\n\tspin_unlock_bh(&tid_rx->reorder_lock);\n\tdel_timer_sync(&tid_rx->reorder_timer);\n\n\tcall_rcu(&tid_rx->rcu_head, ieee80211_free_tid_rx);\n}\n\nvoid __ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,\n\t\t\t\t    u16 initiator, u16 reason, bool tx)\n{\n\tmutex_lock(&sta->ampdu_mlme.mtx);\n\t___ieee80211_stop_rx_ba_session(sta, tid, initiator, reason, tx);\n\tmutex_unlock(&sta->ampdu_mlme.mtx);\n}\n\nvoid ieee80211_stop_rx_ba_session(struct ieee80211_vif *vif, u16 ba_rx_bitmap,\n\t\t\t\t  const u8 *addr)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct sta_info *sta;\n\tint i;\n\n\trcu_read_lock();\n\tsta = sta_info_get_bss(sdata, addr);\n\tif (!sta) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\n\t\tif (ba_rx_bitmap & BIT(i))\n\t\t\tset_bit(i, sta->ampdu_mlme.tid_rx_stop_requested);\n\n\tieee80211_queue_work(&sta->local->hw, &sta->ampdu_mlme.work);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ieee80211_stop_rx_ba_session);\n\n \nstatic void sta_rx_agg_session_timer_expired(struct timer_list *t)\n{\n\tstruct tid_ampdu_rx *tid_rx = from_timer(tid_rx, t, session_timer);\n\tstruct sta_info *sta = tid_rx->sta;\n\tu8 tid = tid_rx->tid;\n\tunsigned long timeout;\n\n\ttimeout = tid_rx->last_rx + TU_TO_JIFFIES(tid_rx->timeout);\n\tif (time_is_after_jiffies(timeout)) {\n\t\tmod_timer(&tid_rx->session_timer, timeout);\n\t\treturn;\n\t}\n\n\tht_dbg(sta->sdata, \"RX session timer expired on %pM tid %d\\n\",\n\t       sta->sta.addr, tid);\n\n\tset_bit(tid, sta->ampdu_mlme.tid_rx_timer_expired);\n\tieee80211_queue_work(&sta->local->hw, &sta->ampdu_mlme.work);\n}\n\nstatic void sta_rx_agg_reorder_timer_expired(struct timer_list *t)\n{\n\tstruct tid_ampdu_rx *tid_rx = from_timer(tid_rx, t, reorder_timer);\n\n\trcu_read_lock();\n\tieee80211_release_reorder_timeout(tid_rx->sta, tid_rx->tid);\n\trcu_read_unlock();\n}\n\nstatic void ieee80211_add_addbaext(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   const struct ieee80211_addba_ext_ie *req,\n\t\t\t\t   u16 buf_size)\n{\n\tstruct ieee80211_addba_ext_ie *resp;\n\tu8 *pos;\n\n\tpos = skb_put_zero(skb, 2 + sizeof(struct ieee80211_addba_ext_ie));\n\t*pos++ = WLAN_EID_ADDBA_EXT;\n\t*pos++ = sizeof(struct ieee80211_addba_ext_ie);\n\tresp = (struct ieee80211_addba_ext_ie *)pos;\n\tresp->data = req->data & IEEE80211_ADDBA_EXT_NO_FRAG;\n\n\tresp->data |= u8_encode_bits(buf_size >> IEEE80211_ADDBA_EXT_BUF_SIZE_SHIFT,\n\t\t\t\t     IEEE80211_ADDBA_EXT_BUF_SIZE_MASK);\n}\n\nstatic void ieee80211_send_addba_resp(struct sta_info *sta, u8 *da, u16 tid,\n\t\t\t\t      u8 dialog_token, u16 status, u16 policy,\n\t\t\t\t      u16 buf_size, u16 timeout,\n\t\t\t\t      const struct ieee80211_addba_ext_ie *addbaext)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *mgmt;\n\tbool amsdu = ieee80211_hw_check(&local->hw, SUPPORTS_AMSDU_IN_AMPDU);\n\tu16 capab;\n\n\tskb = dev_alloc_skb(sizeof(*mgmt) +\n\t\t    2 + sizeof(struct ieee80211_addba_ext_ie) +\n\t\t    local->hw.extra_tx_headroom);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\tmgmt = skb_put_zero(skb, 24);\n\tmemcpy(mgmt->da, da, ETH_ALEN);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tif (sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n\t    sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\tmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\n\telse if (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\tmemcpy(mgmt->bssid, sdata->vif.cfg.ap_addr, ETH_ALEN);\n\telse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\tmemcpy(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN);\n\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\n\tskb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_resp));\n\tmgmt->u.action.category = WLAN_CATEGORY_BACK;\n\tmgmt->u.action.u.addba_resp.action_code = WLAN_ACTION_ADDBA_RESP;\n\tmgmt->u.action.u.addba_resp.dialog_token = dialog_token;\n\n\tcapab = u16_encode_bits(amsdu, IEEE80211_ADDBA_PARAM_AMSDU_MASK);\n\tcapab |= u16_encode_bits(policy, IEEE80211_ADDBA_PARAM_POLICY_MASK);\n\tcapab |= u16_encode_bits(tid, IEEE80211_ADDBA_PARAM_TID_MASK);\n\tcapab |= u16_encode_bits(buf_size, IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK);\n\n\tmgmt->u.action.u.addba_resp.capab = cpu_to_le16(capab);\n\tmgmt->u.action.u.addba_resp.timeout = cpu_to_le16(timeout);\n\tmgmt->u.action.u.addba_resp.status = cpu_to_le16(status);\n\n\tif (sta->sta.deflink.he_cap.has_he && addbaext)\n\t\tieee80211_add_addbaext(sdata, skb, addbaext, buf_size);\n\n\tieee80211_tx_skb(sdata, skb);\n}\n\nvoid ___ieee80211_start_rx_ba_session(struct sta_info *sta,\n\t\t\t\t      u8 dialog_token, u16 timeout,\n\t\t\t\t      u16 start_seq_num, u16 ba_policy, u16 tid,\n\t\t\t\t      u16 buf_size, bool tx, bool auto_seq,\n\t\t\t\t      const struct ieee80211_addba_ext_ie *addbaext)\n{\n\tstruct ieee80211_local *local = sta->sdata->local;\n\tstruct tid_ampdu_rx *tid_agg_rx;\n\tstruct ieee80211_ampdu_params params = {\n\t\t.sta = &sta->sta,\n\t\t.action = IEEE80211_AMPDU_RX_START,\n\t\t.tid = tid,\n\t\t.amsdu = false,\n\t\t.timeout = timeout,\n\t\t.ssn = start_seq_num,\n\t};\n\tint i, ret = -EOPNOTSUPP;\n\tu16 status = WLAN_STATUS_REQUEST_DECLINED;\n\tu16 max_buf_size;\n\n\tif (tid >= IEEE80211_FIRST_TSPEC_TSID) {\n\t\tht_dbg(sta->sdata,\n\t\t       \"STA %pM requests BA session on unsupported tid %d\\n\",\n\t\t       sta->sta.addr, tid);\n\t\tgoto end;\n\t}\n\n\tif (!sta->sta.deflink.ht_cap.ht_supported &&\n\t    !sta->sta.deflink.he_cap.has_he) {\n\t\tht_dbg(sta->sdata,\n\t\t       \"STA %pM erroneously requests BA session on tid %d w/o HT\\n\",\n\t\t       sta->sta.addr, tid);\n\t\t \n\t\tgoto end;\n\t}\n\n\tif (test_sta_flag(sta, WLAN_STA_BLOCK_BA)) {\n\t\tht_dbg(sta->sdata,\n\t\t       \"Suspend in progress - Denying ADDBA request (%pM tid %d)\\n\",\n\t\t       sta->sta.addr, tid);\n\t\tgoto end;\n\t}\n\n\tif (sta->sta.deflink.eht_cap.has_eht)\n\t\tmax_buf_size = IEEE80211_MAX_AMPDU_BUF_EHT;\n\telse if (sta->sta.deflink.he_cap.has_he)\n\t\tmax_buf_size = IEEE80211_MAX_AMPDU_BUF_HE;\n\telse\n\t\tmax_buf_size = IEEE80211_MAX_AMPDU_BUF_HT;\n\n\t \n\t \n\tif (((ba_policy != 1) &&\n\t     (!(sta->sta.deflink.ht_cap.cap & IEEE80211_HT_CAP_DELAY_BA))) ||\n\t    (buf_size > max_buf_size)) {\n\t\tstatus = WLAN_STATUS_INVALID_QOS_PARAM;\n\t\tht_dbg_ratelimited(sta->sdata,\n\t\t\t\t   \"AddBA Req with bad params from %pM on tid %u. policy %d, buffer size %d\\n\",\n\t\t\t\t   sta->sta.addr, tid, ba_policy, buf_size);\n\t\tgoto end;\n\t}\n\t \n\tif (buf_size == 0)\n\t\tbuf_size = max_buf_size;\n\n\t \n\tif (buf_size > sta->sta.max_rx_aggregation_subframes)\n\t\tbuf_size = sta->sta.max_rx_aggregation_subframes;\n\tparams.buf_size = buf_size;\n\n\tht_dbg(sta->sdata, \"AddBA Req buf_size=%d for %pM\\n\",\n\t       buf_size, sta->sta.addr);\n\n\t \n\tlockdep_assert_held(&sta->ampdu_mlme.mtx);\n\n\tif (test_bit(tid, sta->ampdu_mlme.agg_session_valid)) {\n\t\tif (sta->ampdu_mlme.tid_rx_token[tid] == dialog_token) {\n\t\t\tstruct tid_ampdu_rx *tid_rx;\n\n\t\t\tht_dbg_ratelimited(sta->sdata,\n\t\t\t\t\t   \"updated AddBA Req from %pM on tid %u\\n\",\n\t\t\t\t\t   sta->sta.addr, tid);\n\t\t\t \n\t\t\trcu_read_lock();\n\t\t\ttid_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[tid]);\n\t\t\tif (tid_rx && tid_rx->timeout == timeout)\n\t\t\t\tstatus = WLAN_STATUS_SUCCESS;\n\t\t\telse\n\t\t\t\tstatus = WLAN_STATUS_REQUEST_DECLINED;\n\t\t\trcu_read_unlock();\n\t\t\tgoto end;\n\t\t}\n\n\t\tht_dbg_ratelimited(sta->sdata,\n\t\t\t\t   \"unexpected AddBA Req from %pM on tid %u\\n\",\n\t\t\t\t   sta->sta.addr, tid);\n\n\t\t \n\t\t___ieee80211_stop_rx_ba_session(sta, tid, WLAN_BACK_RECIPIENT,\n\t\t\t\t\t\tWLAN_STATUS_UNSPECIFIED_QOS,\n\t\t\t\t\t\tfalse);\n\t}\n\n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_REORDERING_BUFFER)) {\n\t\tret = drv_ampdu_action(local, sta->sdata, &params);\n\t\tht_dbg(sta->sdata,\n\t\t       \"Rx A-MPDU request on %pM tid %d result %d\\n\",\n\t\t       sta->sta.addr, tid, ret);\n\t\tif (!ret)\n\t\t\tstatus = WLAN_STATUS_SUCCESS;\n\t\tgoto end;\n\t}\n\n\t \n\ttid_agg_rx = kzalloc(sizeof(*tid_agg_rx), GFP_KERNEL);\n\tif (!tid_agg_rx)\n\t\tgoto end;\n\n\tspin_lock_init(&tid_agg_rx->reorder_lock);\n\n\t \n\ttimer_setup(&tid_agg_rx->session_timer,\n\t\t    sta_rx_agg_session_timer_expired, TIMER_DEFERRABLE);\n\n\t \n\ttimer_setup(&tid_agg_rx->reorder_timer,\n\t\t    sta_rx_agg_reorder_timer_expired, 0);\n\n\t \n\ttid_agg_rx->reorder_buf =\n\t\tkcalloc(buf_size, sizeof(struct sk_buff_head), GFP_KERNEL);\n\ttid_agg_rx->reorder_time =\n\t\tkcalloc(buf_size, sizeof(unsigned long), GFP_KERNEL);\n\tif (!tid_agg_rx->reorder_buf || !tid_agg_rx->reorder_time) {\n\t\tkfree(tid_agg_rx->reorder_buf);\n\t\tkfree(tid_agg_rx->reorder_time);\n\t\tkfree(tid_agg_rx);\n\t\tgoto end;\n\t}\n\n\tfor (i = 0; i < buf_size; i++)\n\t\t__skb_queue_head_init(&tid_agg_rx->reorder_buf[i]);\n\n\tret = drv_ampdu_action(local, sta->sdata, &params);\n\tht_dbg(sta->sdata, \"Rx A-MPDU request on %pM tid %d result %d\\n\",\n\t       sta->sta.addr, tid, ret);\n\tif (ret) {\n\t\tkfree(tid_agg_rx->reorder_buf);\n\t\tkfree(tid_agg_rx->reorder_time);\n\t\tkfree(tid_agg_rx);\n\t\tgoto end;\n\t}\n\n\t \n\ttid_agg_rx->ssn = start_seq_num;\n\ttid_agg_rx->head_seq_num = start_seq_num;\n\ttid_agg_rx->buf_size = buf_size;\n\ttid_agg_rx->timeout = timeout;\n\ttid_agg_rx->stored_mpdu_num = 0;\n\ttid_agg_rx->auto_seq = auto_seq;\n\ttid_agg_rx->started = false;\n\ttid_agg_rx->reorder_buf_filtered = 0;\n\ttid_agg_rx->tid = tid;\n\ttid_agg_rx->sta = sta;\n\tstatus = WLAN_STATUS_SUCCESS;\n\n\t \n\trcu_assign_pointer(sta->ampdu_mlme.tid_rx[tid], tid_agg_rx);\n\n\tif (timeout) {\n\t\tmod_timer(&tid_agg_rx->session_timer, TU_TO_EXP_TIME(timeout));\n\t\ttid_agg_rx->last_rx = jiffies;\n\t}\n\nend:\n\tif (status == WLAN_STATUS_SUCCESS) {\n\t\t__set_bit(tid, sta->ampdu_mlme.agg_session_valid);\n\t\t__clear_bit(tid, sta->ampdu_mlme.unexpected_agg);\n\t\tsta->ampdu_mlme.tid_rx_token[tid] = dialog_token;\n\t}\n\n\tif (tx)\n\t\tieee80211_send_addba_resp(sta, sta->sta.addr, tid,\n\t\t\t\t\t  dialog_token, status, 1, buf_size,\n\t\t\t\t\t  timeout, addbaext);\n}\n\nstatic void __ieee80211_start_rx_ba_session(struct sta_info *sta,\n\t\t\t\t\t    u8 dialog_token, u16 timeout,\n\t\t\t\t\t    u16 start_seq_num, u16 ba_policy,\n\t\t\t\t\t    u16 tid, u16 buf_size, bool tx,\n\t\t\t\t\t    bool auto_seq,\n\t\t\t\t\t    const struct ieee80211_addba_ext_ie *addbaext)\n{\n\tmutex_lock(&sta->ampdu_mlme.mtx);\n\t___ieee80211_start_rx_ba_session(sta, dialog_token, timeout,\n\t\t\t\t\t start_seq_num, ba_policy, tid,\n\t\t\t\t\t buf_size, tx, auto_seq, addbaext);\n\tmutex_unlock(&sta->ampdu_mlme.mtx);\n}\n\nvoid ieee80211_process_addba_request(struct ieee80211_local *local,\n\t\t\t\t     struct sta_info *sta,\n\t\t\t\t     struct ieee80211_mgmt *mgmt,\n\t\t\t\t     size_t len)\n{\n\tu16 capab, tid, timeout, ba_policy, buf_size, start_seq_num;\n\tstruct ieee802_11_elems *elems = NULL;\n\tu8 dialog_token;\n\tint ies_len;\n\n\t \n\tdialog_token = mgmt->u.action.u.addba_req.dialog_token;\n\ttimeout = le16_to_cpu(mgmt->u.action.u.addba_req.timeout);\n\tstart_seq_num =\n\t\tle16_to_cpu(mgmt->u.action.u.addba_req.start_seq_num) >> 4;\n\n\tcapab = le16_to_cpu(mgmt->u.action.u.addba_req.capab);\n\tba_policy = (capab & IEEE80211_ADDBA_PARAM_POLICY_MASK) >> 1;\n\ttid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;\n\tbuf_size = (capab & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6;\n\n\ties_len = len - offsetof(struct ieee80211_mgmt,\n\t\t\t\t u.action.u.addba_req.variable);\n\tif (ies_len) {\n\t\telems = ieee802_11_parse_elems(mgmt->u.action.u.addba_req.variable,\n\t\t\t\t\t       ies_len, true, NULL);\n\t\tif (!elems || elems->parse_error)\n\t\t\tgoto free;\n\t}\n\n\tif (sta->sta.deflink.eht_cap.has_eht && elems && elems->addba_ext_ie) {\n\t\tu8 buf_size_1k = u8_get_bits(elems->addba_ext_ie->data,\n\t\t\t\t\t     IEEE80211_ADDBA_EXT_BUF_SIZE_MASK);\n\n\t\tbuf_size |= buf_size_1k << IEEE80211_ADDBA_EXT_BUF_SIZE_SHIFT;\n\t}\n\n\t__ieee80211_start_rx_ba_session(sta, dialog_token, timeout,\n\t\t\t\t\tstart_seq_num, ba_policy, tid,\n\t\t\t\t\tbuf_size, true, false,\n\t\t\t\t\telems ? elems->addba_ext_ie : NULL);\nfree:\n\tkfree(elems);\n}\n\nvoid ieee80211_manage_rx_ba_offl(struct ieee80211_vif *vif,\n\t\t\t\t const u8 *addr, unsigned int tid)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\tsta = sta_info_get_bss(sdata, addr);\n\tif (!sta)\n\t\tgoto unlock;\n\n\tset_bit(tid, sta->ampdu_mlme.tid_rx_manage_offl);\n\tieee80211_queue_work(&local->hw, &sta->ampdu_mlme.work);\n unlock:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ieee80211_manage_rx_ba_offl);\n\nvoid ieee80211_rx_ba_timer_expired(struct ieee80211_vif *vif,\n\t\t\t\t   const u8 *addr, unsigned int tid)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\tsta = sta_info_get_bss(sdata, addr);\n\tif (!sta)\n\t\tgoto unlock;\n\n\tset_bit(tid, sta->ampdu_mlme.tid_rx_timer_expired);\n\tieee80211_queue_work(&local->hw, &sta->ampdu_mlme.work);\n\n unlock:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ieee80211_rx_ba_timer_expired);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}