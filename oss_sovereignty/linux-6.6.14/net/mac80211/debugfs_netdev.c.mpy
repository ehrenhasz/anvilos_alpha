{
  "module_name": "debugfs_netdev.c",
  "hash_id": "77857ce17d1620df1d6d0c7a62655240c11166873e3394a04fb6a96b79b33007",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/debugfs_netdev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <linux/notifier.h>\n#include <net/mac80211.h>\n#include <net/cfg80211.h>\n#include \"ieee80211_i.h\"\n#include \"rate.h\"\n#include \"debugfs.h\"\n#include \"debugfs_netdev.h\"\n#include \"driver-ops.h\"\n\nstatic ssize_t ieee80211_if_read(\n\tvoid *data,\n\tchar __user *userbuf,\n\tsize_t count, loff_t *ppos,\n\tssize_t (*format)(const void *, char *, int))\n{\n\tchar buf[200];\n\tssize_t ret = -EINVAL;\n\n\tread_lock(&dev_base_lock);\n\tret = (*format)(data, buf, sizeof(buf));\n\tread_unlock(&dev_base_lock);\n\n\tif (ret >= 0)\n\t\tret = simple_read_from_buffer(userbuf, count, ppos, buf, ret);\n\n\treturn ret;\n}\n\nstatic ssize_t ieee80211_if_write(\n\tvoid *data,\n\tconst char __user *userbuf,\n\tsize_t count, loff_t *ppos,\n\tssize_t (*write)(void *, const char *, int))\n{\n\tchar buf[64];\n\tssize_t ret;\n\n\tif (count >= sizeof(buf))\n\t\treturn -E2BIG;\n\n\tif (copy_from_user(buf, userbuf, count))\n\t\treturn -EFAULT;\n\tbuf[count] = '\\0';\n\n\trtnl_lock();\n\tret = (*write)(data, buf, count);\n\trtnl_unlock();\n\n\treturn ret;\n}\n\n#define IEEE80211_IF_FMT(name, type, field, format_string)\t\t\\\nstatic ssize_t ieee80211_if_fmt_##name(\t\t\t\t\t\\\n\tconst type *data, char *buf,\t\t\t\t\t\\\n\tint buflen)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn scnprintf(buf, buflen, format_string, data->field);\t\\\n}\n#define IEEE80211_IF_FMT_DEC(name, type, field)\t\t\t\t\\\n\t\tIEEE80211_IF_FMT(name, type, field, \"%d\\n\")\n#define IEEE80211_IF_FMT_HEX(name, type, field)\t\t\t\t\\\n\t\tIEEE80211_IF_FMT(name, type, field, \"%#x\\n\")\n#define IEEE80211_IF_FMT_LHEX(name, type, field)\t\t\t\\\n\t\tIEEE80211_IF_FMT(name, type, field, \"%#lx\\n\")\n\n#define IEEE80211_IF_FMT_HEXARRAY(name, type, field)\t\t\t\\\nstatic ssize_t ieee80211_if_fmt_##name(\t\t\t\t\t\\\n\tconst type *data,\t\t\t\t\t\t\\\n\tchar *buf, int buflen)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tchar *p = buf;\t\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < sizeof(data->field); i++) {\t\t\t\\\n\t\tp += scnprintf(p, buflen + buf - p, \"%.2x \",\t\t\\\n\t\t\t\t data->field[i]);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tp += scnprintf(p, buflen + buf - p, \"\\n\");\t\t\t\\\n\treturn p - buf;\t\t\t\t\t\t\t\\\n}\n\n#define IEEE80211_IF_FMT_ATOMIC(name, type, field)\t\t\t\\\nstatic ssize_t ieee80211_if_fmt_##name(\t\t\t\t\t\\\n\tconst type *data,\t\t\t\t\t\t\\\n\tchar *buf, int buflen)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn scnprintf(buf, buflen, \"%d\\n\", atomic_read(&data->field));\\\n}\n\n#define IEEE80211_IF_FMT_MAC(name, type, field)\t\t\t\t\\\nstatic ssize_t ieee80211_if_fmt_##name(\t\t\t\t\t\\\n\tconst type *data, char *buf,\t\t\t\t\t\\\n\tint buflen)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn scnprintf(buf, buflen, \"%pM\\n\", data->field);\t\t\\\n}\n\n#define IEEE80211_IF_FMT_JIFFIES_TO_MS(name, type, field)\t\t\\\nstatic ssize_t ieee80211_if_fmt_##name(\t\t\t\t\t\\\n\tconst type *data,\t\t\t\t\t\t\\\n\tchar *buf, int buflen)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn scnprintf(buf, buflen, \"%d\\n\",\t\t\t\t\\\n\t\t\t jiffies_to_msecs(data->field));\t\t\\\n}\n\n#define _IEEE80211_IF_FILE_OPS(name, _read, _write)\t\t\t\\\nstatic const struct file_operations name##_ops = {\t\t\t\\\n\t.read = (_read),\t\t\t\t\t\t\\\n\t.write = (_write),\t\t\t\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n}\n\n#define _IEEE80211_IF_FILE_R_FN(name, type)\t\t\t\t\\\nstatic ssize_t ieee80211_if_read_##name(struct file *file,\t\t\\\n\t\t\t\t\tchar __user *userbuf,\t\t\\\n\t\t\t\t\tsize_t count, loff_t *ppos)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tssize_t (*fn)(const void *, char *, int) = (void *)\t\t\\\n\t\t((ssize_t (*)(const type, char *, int))\t\t\t\\\n\t\t ieee80211_if_fmt_##name);\t\t\t\t\\\n\treturn ieee80211_if_read(file->private_data,\t\t\t\\\n\t\t\t\t userbuf, count, ppos, fn);\t\t\\\n}\n\n#define _IEEE80211_IF_FILE_W_FN(name, type)\t\t\t\t\\\nstatic ssize_t ieee80211_if_write_##name(struct file *file,\t\t\\\n\t\t\t\t\t const char __user *userbuf,\t\\\n\t\t\t\t\t size_t count, loff_t *ppos)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tssize_t (*fn)(void *, const char *, int) = (void *)\t\t\\\n\t\t((ssize_t (*)(type, const char *, int))\t\t\t\\\n\t\t ieee80211_if_parse_##name);\t\t\t\t\\\n\treturn ieee80211_if_write(file->private_data, userbuf, count,\t\\\n\t\t\t\t  ppos, fn);\t\t\t\t\\\n}\n\n#define IEEE80211_IF_FILE_R(name)\t\t\t\t\t\\\n\t_IEEE80211_IF_FILE_R_FN(name, struct ieee80211_sub_if_data *)\t\\\n\t_IEEE80211_IF_FILE_OPS(name, ieee80211_if_read_##name, NULL)\n\n#define IEEE80211_IF_FILE_W(name)\t\t\t\t\t\\\n\t_IEEE80211_IF_FILE_W_FN(name, struct ieee80211_sub_if_data *)\t\\\n\t_IEEE80211_IF_FILE_OPS(name, NULL, ieee80211_if_write_##name)\n\n#define IEEE80211_IF_FILE_RW(name)\t\t\t\t\t\\\n\t_IEEE80211_IF_FILE_R_FN(name, struct ieee80211_sub_if_data *)\t\\\n\t_IEEE80211_IF_FILE_W_FN(name, struct ieee80211_sub_if_data *)\t\\\n\t_IEEE80211_IF_FILE_OPS(name, ieee80211_if_read_##name,\t\t\\\n\t\t\t       ieee80211_if_write_##name)\n\n#define IEEE80211_IF_FILE(name, field, format)\t\t\t\t\\\n\tIEEE80211_IF_FMT_##format(name, struct ieee80211_sub_if_data, field) \\\n\tIEEE80211_IF_FILE_R(name)\n\n \n#define IEEE80211_IF_LINK_FILE_R(name)\t\t\t\t\t\\\n\t_IEEE80211_IF_FILE_R_FN(name, struct ieee80211_link_data *)\t\\\n\t_IEEE80211_IF_FILE_OPS(link_##name, ieee80211_if_read_##name, NULL)\n\n#define IEEE80211_IF_LINK_FILE_W(name)\t\t\t\t\t\\\n\t_IEEE80211_IF_FILE_W_FN(name)\t\t\t\t\t\\\n\t_IEEE80211_IF_FILE_OPS(link_##name, NULL, ieee80211_if_write_##name)\n\n#define IEEE80211_IF_LINK_FILE_RW(name)\t\t\t\t\t\\\n\t_IEEE80211_IF_FILE_R_FN(name, struct ieee80211_link_data *)\t\\\n\t_IEEE80211_IF_FILE_W_FN(name, struct ieee80211_link_data *)\t\\\n\t_IEEE80211_IF_FILE_OPS(link_##name, ieee80211_if_read_##name,\t\\\n\t\t\t       ieee80211_if_write_##name)\n\n#define IEEE80211_IF_LINK_FILE(name, field, format)\t\t\t\t\\\n\tIEEE80211_IF_FMT_##format(name, struct ieee80211_link_data, field) \\\n\tIEEE80211_IF_LINK_FILE_R(name)\n\n \nIEEE80211_IF_FILE(rc_rateidx_mask_2ghz, rc_rateidx_mask[NL80211_BAND_2GHZ],\n\t\t  HEX);\nIEEE80211_IF_FILE(rc_rateidx_mask_5ghz, rc_rateidx_mask[NL80211_BAND_5GHZ],\n\t\t  HEX);\nIEEE80211_IF_FILE(rc_rateidx_mcs_mask_2ghz,\n\t\t  rc_rateidx_mcs_mask[NL80211_BAND_2GHZ], HEXARRAY);\nIEEE80211_IF_FILE(rc_rateidx_mcs_mask_5ghz,\n\t\t  rc_rateidx_mcs_mask[NL80211_BAND_5GHZ], HEXARRAY);\n\nstatic ssize_t ieee80211_if_fmt_rc_rateidx_vht_mcs_mask_2ghz(\n\t\t\t\tconst struct ieee80211_sub_if_data *sdata,\n\t\t\t\tchar *buf, int buflen)\n{\n\tint i, len = 0;\n\tconst u16 *mask = sdata->rc_rateidx_vht_mcs_mask[NL80211_BAND_2GHZ];\n\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++)\n\t\tlen += scnprintf(buf + len, buflen - len, \"%04x \", mask[i]);\n\tlen += scnprintf(buf + len, buflen - len, \"\\n\");\n\n\treturn len;\n}\n\nIEEE80211_IF_FILE_R(rc_rateidx_vht_mcs_mask_2ghz);\n\nstatic ssize_t ieee80211_if_fmt_rc_rateidx_vht_mcs_mask_5ghz(\n\t\t\t\tconst struct ieee80211_sub_if_data *sdata,\n\t\t\t\tchar *buf, int buflen)\n{\n\tint i, len = 0;\n\tconst u16 *mask = sdata->rc_rateidx_vht_mcs_mask[NL80211_BAND_5GHZ];\n\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++)\n\t\tlen += scnprintf(buf + len, buflen - len, \"%04x \", mask[i]);\n\tlen += scnprintf(buf + len, buflen - len, \"\\n\");\n\n\treturn len;\n}\n\nIEEE80211_IF_FILE_R(rc_rateidx_vht_mcs_mask_5ghz);\n\nIEEE80211_IF_FILE(flags, flags, HEX);\nIEEE80211_IF_FILE(state, state, LHEX);\nIEEE80211_IF_LINK_FILE(txpower, conf->txpower, DEC);\nIEEE80211_IF_LINK_FILE(ap_power_level, ap_power_level, DEC);\nIEEE80211_IF_LINK_FILE(user_power_level, user_power_level, DEC);\n\nstatic ssize_t\nieee80211_if_fmt_hw_queues(const struct ieee80211_sub_if_data *sdata,\n\t\t\t   char *buf, int buflen)\n{\n\tint len;\n\n\tlen = scnprintf(buf, buflen, \"AC queues: VO:%d VI:%d BE:%d BK:%d\\n\",\n\t\t\tsdata->vif.hw_queue[IEEE80211_AC_VO],\n\t\t\tsdata->vif.hw_queue[IEEE80211_AC_VI],\n\t\t\tsdata->vif.hw_queue[IEEE80211_AC_BE],\n\t\t\tsdata->vif.hw_queue[IEEE80211_AC_BK]);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tlen += scnprintf(buf + len, buflen - len, \"cab queue: %d\\n\",\n\t\t\t\t sdata->vif.cab_queue);\n\n\treturn len;\n}\nIEEE80211_IF_FILE_R(hw_queues);\n\n \nIEEE80211_IF_FILE(bssid, deflink.u.mgd.bssid, MAC);\nIEEE80211_IF_FILE(aid, vif.cfg.aid, DEC);\nIEEE80211_IF_FILE(beacon_timeout, u.mgd.beacon_timeout, JIFFIES_TO_MS);\n\nstatic int ieee80211_set_smps(struct ieee80211_link_data *link,\n\t\t\t      enum ieee80211_smps_mode smps_mode)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tint err;\n\n\tif (sdata->vif.driver_flags & IEEE80211_VIF_DISABLE_SMPS_OVERRIDE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(local->hw.wiphy->features & NL80211_FEATURE_STATIC_SMPS) &&\n\t    smps_mode == IEEE80211_SMPS_STATIC)\n\t\treturn -EINVAL;\n\n\t \n\tif (!(local->hw.wiphy->features & NL80211_FEATURE_DYNAMIC_SMPS) &&\n\t    (smps_mode == IEEE80211_SMPS_DYNAMIC ||\n\t     smps_mode == IEEE80211_SMPS_AUTOMATIC))\n\t\treturn -EINVAL;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\tsdata_lock(sdata);\n\terr = __ieee80211_request_smps_mgd(link->sdata, link, smps_mode);\n\tsdata_unlock(sdata);\n\n\treturn err;\n}\n\nstatic const char *smps_modes[IEEE80211_SMPS_NUM_MODES] = {\n\t[IEEE80211_SMPS_AUTOMATIC] = \"auto\",\n\t[IEEE80211_SMPS_OFF] = \"off\",\n\t[IEEE80211_SMPS_STATIC] = \"static\",\n\t[IEEE80211_SMPS_DYNAMIC] = \"dynamic\",\n};\n\nstatic ssize_t ieee80211_if_fmt_smps(const struct ieee80211_link_data *link,\n\t\t\t\t     char *buf, int buflen)\n{\n\tif (link->sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\treturn snprintf(buf, buflen, \"request: %s\\nused: %s\\n\",\n\t\t\t\tsmps_modes[link->u.mgd.req_smps],\n\t\t\t\tsmps_modes[link->smps_mode]);\n\treturn -EINVAL;\n}\n\nstatic ssize_t ieee80211_if_parse_smps(struct ieee80211_link_data *link,\n\t\t\t\t       const char *buf, int buflen)\n{\n\tenum ieee80211_smps_mode mode;\n\n\tfor (mode = 0; mode < IEEE80211_SMPS_NUM_MODES; mode++) {\n\t\tif (strncmp(buf, smps_modes[mode], buflen) == 0) {\n\t\t\tint err = ieee80211_set_smps(link, mode);\n\t\t\tif (!err)\n\t\t\t\treturn buflen;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\nIEEE80211_IF_LINK_FILE_RW(smps);\n\nstatic ssize_t ieee80211_if_parse_tkip_mic_test(\n\tstruct ieee80211_sub_if_data *sdata, const char *buf, int buflen)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu8 addr[ETH_ALEN];\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\t__le16 fc;\n\n\tif (!mac_pton(buf, addr))\n\t\treturn -EINVAL;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn -ENOTCONN;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + 24 + 100);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\thdr = skb_put_zero(skb, 24);\n\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t \n\t\tmemcpy(hdr->addr1, addr, ETH_ALEN);\n\t\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\tmemcpy(hdr->addr3, sdata->vif.addr, ETH_ALEN);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_TODS);\n\t\t \n\t\tsdata_lock(sdata);\n\t\tif (!sdata->u.mgd.associated) {\n\t\t\tsdata_unlock(sdata);\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tmemcpy(hdr->addr1, sdata->deflink.u.mgd.bssid, ETH_ALEN);\n\t\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\tmemcpy(hdr->addr3, addr, ETH_ALEN);\n\t\tsdata_unlock(sdata);\n\t\tbreak;\n\tdefault:\n\t\tdev_kfree_skb(skb);\n\t\treturn -EOPNOTSUPP;\n\t}\n\thdr->frame_control = fc;\n\n\t \n\tskb_put_zero(skb, 50);\n\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_TKIP_MIC_FAILURE;\n\n\tieee80211_tx_skb(sdata, skb);\n\n\treturn buflen;\n}\nIEEE80211_IF_FILE_W(tkip_mic_test);\n\nstatic ssize_t ieee80211_if_parse_beacon_loss(\n\tstruct ieee80211_sub_if_data *sdata, const char *buf, int buflen)\n{\n\tif (!ieee80211_sdata_running(sdata) || !sdata->vif.cfg.assoc)\n\t\treturn -ENOTCONN;\n\n\tieee80211_beacon_loss(&sdata->vif);\n\n\treturn buflen;\n}\nIEEE80211_IF_FILE_W(beacon_loss);\n\nstatic ssize_t ieee80211_if_fmt_uapsd_queues(\n\tconst struct ieee80211_sub_if_data *sdata, char *buf, int buflen)\n{\n\tconst struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\n\treturn snprintf(buf, buflen, \"0x%x\\n\", ifmgd->uapsd_queues);\n}\n\nstatic ssize_t ieee80211_if_parse_uapsd_queues(\n\tstruct ieee80211_sub_if_data *sdata, const char *buf, int buflen)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tu8 val;\n\tint ret;\n\n\tret = kstrtou8(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & ~IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)\n\t\treturn -ERANGE;\n\n\tifmgd->uapsd_queues = val;\n\n\treturn buflen;\n}\nIEEE80211_IF_FILE_RW(uapsd_queues);\n\nstatic ssize_t ieee80211_if_fmt_uapsd_max_sp_len(\n\tconst struct ieee80211_sub_if_data *sdata, char *buf, int buflen)\n{\n\tconst struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\n\treturn snprintf(buf, buflen, \"0x%x\\n\", ifmgd->uapsd_max_sp_len);\n}\n\nstatic ssize_t ieee80211_if_parse_uapsd_max_sp_len(\n\tstruct ieee80211_sub_if_data *sdata, const char *buf, int buflen)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (val & ~IEEE80211_WMM_IE_STA_QOSINFO_SP_MASK)\n\t\treturn -ERANGE;\n\n\tifmgd->uapsd_max_sp_len = val;\n\n\treturn buflen;\n}\nIEEE80211_IF_FILE_RW(uapsd_max_sp_len);\n\nstatic ssize_t ieee80211_if_fmt_tdls_wider_bw(\n\tconst struct ieee80211_sub_if_data *sdata, char *buf, int buflen)\n{\n\tconst struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tbool tdls_wider_bw;\n\n\ttdls_wider_bw = ieee80211_hw_check(&sdata->local->hw, TDLS_WIDER_BW) &&\n\t\t\t!ifmgd->tdls_wider_bw_prohibited;\n\n\treturn snprintf(buf, buflen, \"%d\\n\", tdls_wider_bw);\n}\n\nstatic ssize_t ieee80211_if_parse_tdls_wider_bw(\n\tstruct ieee80211_sub_if_data *sdata, const char *buf, int buflen)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tu8 val;\n\tint ret;\n\n\tret = kstrtou8(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tifmgd->tdls_wider_bw_prohibited = !val;\n\treturn buflen;\n}\nIEEE80211_IF_FILE_RW(tdls_wider_bw);\n\n \nIEEE80211_IF_FILE(num_mcast_sta, u.ap.num_mcast_sta, ATOMIC);\nIEEE80211_IF_FILE(num_sta_ps, u.ap.ps.num_sta_ps, ATOMIC);\nIEEE80211_IF_FILE(dtim_count, u.ap.ps.dtim_count, DEC);\nIEEE80211_IF_FILE(num_mcast_sta_vlan, u.vlan.num_mcast_sta, ATOMIC);\n\nstatic ssize_t ieee80211_if_fmt_num_buffered_multicast(\n\tconst struct ieee80211_sub_if_data *sdata, char *buf, int buflen)\n{\n\treturn scnprintf(buf, buflen, \"%u\\n\",\n\t\t\t skb_queue_len(&sdata->u.ap.ps.bc_buf));\n}\nIEEE80211_IF_FILE_R(num_buffered_multicast);\n\nstatic ssize_t ieee80211_if_fmt_aqm(\n\tconst struct ieee80211_sub_if_data *sdata, char *buf, int buflen)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct txq_info *txqi;\n\tint len;\n\n\tif (!sdata->vif.txq)\n\t\treturn 0;\n\n\ttxqi = to_txq_info(sdata->vif.txq);\n\n\tspin_lock_bh(&local->fq.lock);\n\trcu_read_lock();\n\n\tlen = scnprintf(buf,\n\t\t\tbuflen,\n\t\t\t\"ac backlog-bytes backlog-packets new-flows drops marks overlimit collisions tx-bytes tx-packets\\n\"\n\t\t\t\"%u %u %u %u %u %u %u %u %u %u\\n\",\n\t\t\ttxqi->txq.ac,\n\t\t\ttxqi->tin.backlog_bytes,\n\t\t\ttxqi->tin.backlog_packets,\n\t\t\ttxqi->tin.flows,\n\t\t\ttxqi->cstats.drop_count,\n\t\t\ttxqi->cstats.ecn_mark,\n\t\t\ttxqi->tin.overlimit,\n\t\t\ttxqi->tin.collisions,\n\t\t\ttxqi->tin.tx_bytes,\n\t\t\ttxqi->tin.tx_packets);\n\n\trcu_read_unlock();\n\tspin_unlock_bh(&local->fq.lock);\n\n\treturn len;\n}\nIEEE80211_IF_FILE_R(aqm);\n\nIEEE80211_IF_FILE(multicast_to_unicast, u.ap.multicast_to_unicast, HEX);\n\n \nstatic ssize_t ieee80211_if_fmt_tsf(\n\tconst struct ieee80211_sub_if_data *sdata, char *buf, int buflen)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu64 tsf;\n\n\ttsf = drv_get_tsf(local, (struct ieee80211_sub_if_data *)sdata);\n\n\treturn scnprintf(buf, buflen, \"0x%016llx\\n\", (unsigned long long) tsf);\n}\n\nstatic ssize_t ieee80211_if_parse_tsf(\n\tstruct ieee80211_sub_if_data *sdata, const char *buf, int buflen)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tunsigned long long tsf;\n\tint ret;\n\tint tsf_is_delta = 0;\n\n\tif (strncmp(buf, \"reset\", 5) == 0) {\n\t\tif (local->ops->reset_tsf) {\n\t\t\tdrv_reset_tsf(local, sdata);\n\t\t\twiphy_info(local->hw.wiphy, \"debugfs reset TSF\\n\");\n\t\t}\n\t} else {\n\t\tif (buflen > 10 && buf[1] == '=') {\n\t\t\tif (buf[0] == '+')\n\t\t\t\ttsf_is_delta = 1;\n\t\t\telse if (buf[0] == '-')\n\t\t\t\ttsf_is_delta = -1;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbuf += 2;\n\t\t}\n\t\tret = kstrtoull(buf, 10, &tsf);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (tsf_is_delta && local->ops->offset_tsf) {\n\t\t\tdrv_offset_tsf(local, sdata, tsf_is_delta * tsf);\n\t\t\twiphy_info(local->hw.wiphy,\n\t\t\t\t   \"debugfs offset TSF by %018lld\\n\",\n\t\t\t\t   tsf_is_delta * tsf);\n\t\t} else if (local->ops->set_tsf) {\n\t\t\tif (tsf_is_delta)\n\t\t\t\ttsf = drv_get_tsf(local, sdata) +\n\t\t\t\t      tsf_is_delta * tsf;\n\t\t\tdrv_set_tsf(local, sdata, tsf);\n\t\t\twiphy_info(local->hw.wiphy,\n\t\t\t\t   \"debugfs set TSF to %#018llx\\n\", tsf);\n\t\t}\n\t}\n\n\tieee80211_recalc_dtim(local, sdata);\n\treturn buflen;\n}\nIEEE80211_IF_FILE_RW(tsf);\n\nstatic ssize_t ieee80211_if_fmt_valid_links(const struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    char *buf, int buflen)\n{\n\treturn snprintf(buf, buflen, \"0x%x\\n\", sdata->vif.valid_links);\n}\nIEEE80211_IF_FILE_R(valid_links);\n\nstatic ssize_t ieee80211_if_fmt_active_links(const struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t     char *buf, int buflen)\n{\n\treturn snprintf(buf, buflen, \"0x%x\\n\", sdata->vif.active_links);\n}\n\nstatic ssize_t ieee80211_if_parse_active_links(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t       const char *buf, int buflen)\n{\n\tu16 active_links;\n\n\tif (kstrtou16(buf, 0, &active_links))\n\t\treturn -EINVAL;\n\n\treturn ieee80211_set_active_links(&sdata->vif, active_links) ?: buflen;\n}\nIEEE80211_IF_FILE_RW(active_links);\n\nIEEE80211_IF_LINK_FILE(addr, conf->addr, MAC);\n\n#ifdef CONFIG_MAC80211_MESH\nIEEE80211_IF_FILE(estab_plinks, u.mesh.estab_plinks, ATOMIC);\n\n \nIEEE80211_IF_FILE(fwded_mcast, u.mesh.mshstats.fwded_mcast, DEC);\nIEEE80211_IF_FILE(fwded_unicast, u.mesh.mshstats.fwded_unicast, DEC);\nIEEE80211_IF_FILE(fwded_frames, u.mesh.mshstats.fwded_frames, DEC);\nIEEE80211_IF_FILE(dropped_frames_ttl, u.mesh.mshstats.dropped_frames_ttl, DEC);\nIEEE80211_IF_FILE(dropped_frames_no_route,\n\t\t  u.mesh.mshstats.dropped_frames_no_route, DEC);\n\n \nIEEE80211_IF_FILE(dot11MeshMaxRetries,\n\t\t  u.mesh.mshcfg.dot11MeshMaxRetries, DEC);\nIEEE80211_IF_FILE(dot11MeshRetryTimeout,\n\t\t  u.mesh.mshcfg.dot11MeshRetryTimeout, DEC);\nIEEE80211_IF_FILE(dot11MeshConfirmTimeout,\n\t\t  u.mesh.mshcfg.dot11MeshConfirmTimeout, DEC);\nIEEE80211_IF_FILE(dot11MeshHoldingTimeout,\n\t\t  u.mesh.mshcfg.dot11MeshHoldingTimeout, DEC);\nIEEE80211_IF_FILE(dot11MeshTTL, u.mesh.mshcfg.dot11MeshTTL, DEC);\nIEEE80211_IF_FILE(element_ttl, u.mesh.mshcfg.element_ttl, DEC);\nIEEE80211_IF_FILE(auto_open_plinks, u.mesh.mshcfg.auto_open_plinks, DEC);\nIEEE80211_IF_FILE(dot11MeshMaxPeerLinks,\n\t\t  u.mesh.mshcfg.dot11MeshMaxPeerLinks, DEC);\nIEEE80211_IF_FILE(dot11MeshHWMPactivePathTimeout,\n\t\t  u.mesh.mshcfg.dot11MeshHWMPactivePathTimeout, DEC);\nIEEE80211_IF_FILE(dot11MeshHWMPpreqMinInterval,\n\t\t  u.mesh.mshcfg.dot11MeshHWMPpreqMinInterval, DEC);\nIEEE80211_IF_FILE(dot11MeshHWMPperrMinInterval,\n\t\t  u.mesh.mshcfg.dot11MeshHWMPperrMinInterval, DEC);\nIEEE80211_IF_FILE(dot11MeshHWMPnetDiameterTraversalTime,\n\t\t  u.mesh.mshcfg.dot11MeshHWMPnetDiameterTraversalTime, DEC);\nIEEE80211_IF_FILE(dot11MeshHWMPmaxPREQretries,\n\t\t  u.mesh.mshcfg.dot11MeshHWMPmaxPREQretries, DEC);\nIEEE80211_IF_FILE(path_refresh_time,\n\t\t  u.mesh.mshcfg.path_refresh_time, DEC);\nIEEE80211_IF_FILE(min_discovery_timeout,\n\t\t  u.mesh.mshcfg.min_discovery_timeout, DEC);\nIEEE80211_IF_FILE(dot11MeshHWMPRootMode,\n\t\t  u.mesh.mshcfg.dot11MeshHWMPRootMode, DEC);\nIEEE80211_IF_FILE(dot11MeshGateAnnouncementProtocol,\n\t\t  u.mesh.mshcfg.dot11MeshGateAnnouncementProtocol, DEC);\nIEEE80211_IF_FILE(dot11MeshHWMPRannInterval,\n\t\t  u.mesh.mshcfg.dot11MeshHWMPRannInterval, DEC);\nIEEE80211_IF_FILE(dot11MeshForwarding, u.mesh.mshcfg.dot11MeshForwarding, DEC);\nIEEE80211_IF_FILE(rssi_threshold, u.mesh.mshcfg.rssi_threshold, DEC);\nIEEE80211_IF_FILE(ht_opmode, u.mesh.mshcfg.ht_opmode, DEC);\nIEEE80211_IF_FILE(dot11MeshHWMPactivePathToRootTimeout,\n\t\t  u.mesh.mshcfg.dot11MeshHWMPactivePathToRootTimeout, DEC);\nIEEE80211_IF_FILE(dot11MeshHWMProotInterval,\n\t\t  u.mesh.mshcfg.dot11MeshHWMProotInterval, DEC);\nIEEE80211_IF_FILE(dot11MeshHWMPconfirmationInterval,\n\t\t  u.mesh.mshcfg.dot11MeshHWMPconfirmationInterval, DEC);\nIEEE80211_IF_FILE(power_mode, u.mesh.mshcfg.power_mode, DEC);\nIEEE80211_IF_FILE(dot11MeshAwakeWindowDuration,\n\t\t  u.mesh.mshcfg.dot11MeshAwakeWindowDuration, DEC);\nIEEE80211_IF_FILE(dot11MeshConnectedToMeshGate,\n\t\t  u.mesh.mshcfg.dot11MeshConnectedToMeshGate, DEC);\nIEEE80211_IF_FILE(dot11MeshNolearn, u.mesh.mshcfg.dot11MeshNolearn, DEC);\nIEEE80211_IF_FILE(dot11MeshConnectedToAuthServer,\n\t\t  u.mesh.mshcfg.dot11MeshConnectedToAuthServer, DEC);\n#endif\n\n#define DEBUGFS_ADD_MODE(name, mode) \\\n\tdebugfs_create_file(#name, mode, sdata->vif.debugfs_dir, \\\n\t\t\t    sdata, &name##_ops)\n\n#define DEBUGFS_ADD_X(_bits, _name, _mode) \\\n\tdebugfs_create_x##_bits(#_name, _mode, sdata->vif.debugfs_dir, \\\n\t\t\t\t&sdata->vif._name)\n\n#define DEBUGFS_ADD_X8(_name, _mode) \\\n\tDEBUGFS_ADD_X(8, _name, _mode)\n\n#define DEBUGFS_ADD_X16(_name, _mode) \\\n\tDEBUGFS_ADD_X(16, _name, _mode)\n\n#define DEBUGFS_ADD_X32(_name, _mode) \\\n\tDEBUGFS_ADD_X(32, _name, _mode)\n\n#define DEBUGFS_ADD(name) DEBUGFS_ADD_MODE(name, 0400)\n\nstatic void add_common_files(struct ieee80211_sub_if_data *sdata)\n{\n\tDEBUGFS_ADD(rc_rateidx_mask_2ghz);\n\tDEBUGFS_ADD(rc_rateidx_mask_5ghz);\n\tDEBUGFS_ADD(rc_rateidx_mcs_mask_2ghz);\n\tDEBUGFS_ADD(rc_rateidx_mcs_mask_5ghz);\n\tDEBUGFS_ADD(rc_rateidx_vht_mcs_mask_2ghz);\n\tDEBUGFS_ADD(rc_rateidx_vht_mcs_mask_5ghz);\n\tDEBUGFS_ADD(hw_queues);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE &&\n\t    sdata->vif.type != NL80211_IFTYPE_NAN)\n\t\tDEBUGFS_ADD(aqm);\n}\n\nstatic void add_sta_files(struct ieee80211_sub_if_data *sdata)\n{\n\tDEBUGFS_ADD(bssid);\n\tDEBUGFS_ADD(aid);\n\tDEBUGFS_ADD(beacon_timeout);\n\tDEBUGFS_ADD_MODE(tkip_mic_test, 0200);\n\tDEBUGFS_ADD_MODE(beacon_loss, 0200);\n\tDEBUGFS_ADD_MODE(uapsd_queues, 0600);\n\tDEBUGFS_ADD_MODE(uapsd_max_sp_len, 0600);\n\tDEBUGFS_ADD_MODE(tdls_wider_bw, 0600);\n\tDEBUGFS_ADD_MODE(valid_links, 0400);\n\tDEBUGFS_ADD_MODE(active_links, 0600);\n\tDEBUGFS_ADD_X16(dormant_links, 0400);\n}\n\nstatic void add_ap_files(struct ieee80211_sub_if_data *sdata)\n{\n\tDEBUGFS_ADD(num_mcast_sta);\n\tDEBUGFS_ADD(num_sta_ps);\n\tDEBUGFS_ADD(dtim_count);\n\tDEBUGFS_ADD(num_buffered_multicast);\n\tDEBUGFS_ADD_MODE(tkip_mic_test, 0200);\n\tDEBUGFS_ADD_MODE(multicast_to_unicast, 0600);\n}\n\nstatic void add_vlan_files(struct ieee80211_sub_if_data *sdata)\n{\n\t \n\tdebugfs_create_file(\"num_mcast_sta\", 0400, sdata->vif.debugfs_dir,\n\t\t\t    sdata, &num_mcast_sta_vlan_ops);\n}\n\nstatic void add_ibss_files(struct ieee80211_sub_if_data *sdata)\n{\n\tDEBUGFS_ADD_MODE(tsf, 0600);\n}\n\n#ifdef CONFIG_MAC80211_MESH\n\nstatic void add_mesh_files(struct ieee80211_sub_if_data *sdata)\n{\n\tDEBUGFS_ADD_MODE(tsf, 0600);\n\tDEBUGFS_ADD_MODE(estab_plinks, 0400);\n}\n\nstatic void add_mesh_stats(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct dentry *dir = debugfs_create_dir(\"mesh_stats\",\n\t\t\t\t\t\tsdata->vif.debugfs_dir);\n#define MESHSTATS_ADD(name)\\\n\tdebugfs_create_file(#name, 0400, dir, sdata, &name##_ops)\n\n\tMESHSTATS_ADD(fwded_mcast);\n\tMESHSTATS_ADD(fwded_unicast);\n\tMESHSTATS_ADD(fwded_frames);\n\tMESHSTATS_ADD(dropped_frames_ttl);\n\tMESHSTATS_ADD(dropped_frames_no_route);\n#undef MESHSTATS_ADD\n}\n\nstatic void add_mesh_config(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct dentry *dir = debugfs_create_dir(\"mesh_config\",\n\t\t\t\t\t\tsdata->vif.debugfs_dir);\n\n#define MESHPARAMS_ADD(name) \\\n\tdebugfs_create_file(#name, 0600, dir, sdata, &name##_ops)\n\n\tMESHPARAMS_ADD(dot11MeshMaxRetries);\n\tMESHPARAMS_ADD(dot11MeshRetryTimeout);\n\tMESHPARAMS_ADD(dot11MeshConfirmTimeout);\n\tMESHPARAMS_ADD(dot11MeshHoldingTimeout);\n\tMESHPARAMS_ADD(dot11MeshTTL);\n\tMESHPARAMS_ADD(element_ttl);\n\tMESHPARAMS_ADD(auto_open_plinks);\n\tMESHPARAMS_ADD(dot11MeshMaxPeerLinks);\n\tMESHPARAMS_ADD(dot11MeshHWMPactivePathTimeout);\n\tMESHPARAMS_ADD(dot11MeshHWMPpreqMinInterval);\n\tMESHPARAMS_ADD(dot11MeshHWMPperrMinInterval);\n\tMESHPARAMS_ADD(dot11MeshHWMPnetDiameterTraversalTime);\n\tMESHPARAMS_ADD(dot11MeshHWMPmaxPREQretries);\n\tMESHPARAMS_ADD(path_refresh_time);\n\tMESHPARAMS_ADD(min_discovery_timeout);\n\tMESHPARAMS_ADD(dot11MeshHWMPRootMode);\n\tMESHPARAMS_ADD(dot11MeshHWMPRannInterval);\n\tMESHPARAMS_ADD(dot11MeshForwarding);\n\tMESHPARAMS_ADD(dot11MeshGateAnnouncementProtocol);\n\tMESHPARAMS_ADD(rssi_threshold);\n\tMESHPARAMS_ADD(ht_opmode);\n\tMESHPARAMS_ADD(dot11MeshHWMPactivePathToRootTimeout);\n\tMESHPARAMS_ADD(dot11MeshHWMProotInterval);\n\tMESHPARAMS_ADD(dot11MeshHWMPconfirmationInterval);\n\tMESHPARAMS_ADD(power_mode);\n\tMESHPARAMS_ADD(dot11MeshAwakeWindowDuration);\n\tMESHPARAMS_ADD(dot11MeshConnectedToMeshGate);\n\tMESHPARAMS_ADD(dot11MeshNolearn);\n\tMESHPARAMS_ADD(dot11MeshConnectedToAuthServer);\n#undef MESHPARAMS_ADD\n}\n#endif\n\nstatic void add_files(struct ieee80211_sub_if_data *sdata)\n{\n\tif (!sdata->vif.debugfs_dir)\n\t\treturn;\n\n\tDEBUGFS_ADD(flags);\n\tDEBUGFS_ADD(state);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_MONITOR)\n\t\tadd_common_files(sdata);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n#ifdef CONFIG_MAC80211_MESH\n\t\tadd_mesh_files(sdata);\n\t\tadd_mesh_stats(sdata);\n\t\tadd_mesh_config(sdata);\n#endif\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tadd_sta_files(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tadd_ibss_files(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tadd_ap_files(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tadd_vlan_files(sdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#undef DEBUGFS_ADD_MODE\n#undef DEBUGFS_ADD\n\n#define DEBUGFS_ADD_MODE(dentry, name, mode) \\\n\tdebugfs_create_file(#name, mode, dentry, \\\n\t\t\t    link, &link_##name##_ops)\n\n#define DEBUGFS_ADD(dentry, name) DEBUGFS_ADD_MODE(dentry, name, 0400)\n\nstatic void add_link_files(struct ieee80211_link_data *link,\n\t\t\t   struct dentry *dentry)\n{\n\tDEBUGFS_ADD(dentry, txpower);\n\tDEBUGFS_ADD(dentry, user_power_level);\n\tDEBUGFS_ADD(dentry, ap_power_level);\n\n\tswitch (link->sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tDEBUGFS_ADD_MODE(dentry, smps, 0600);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid ieee80211_debugfs_add_netdev(struct ieee80211_sub_if_data *sdata)\n{\n\tchar buf[10+IFNAMSIZ];\n\n\tsprintf(buf, \"netdev:%s\", sdata->name);\n\tsdata->vif.debugfs_dir = debugfs_create_dir(buf,\n\t\tsdata->local->hw.wiphy->debugfsdir);\n\tsdata->debugfs.subdir_stations = debugfs_create_dir(\"stations\",\n\t\t\t\t\t\t\tsdata->vif.debugfs_dir);\n\tadd_files(sdata);\n\n\tif (!(sdata->local->hw.wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO))\n\t\tadd_link_files(&sdata->deflink, sdata->vif.debugfs_dir);\n}\n\nvoid ieee80211_debugfs_remove_netdev(struct ieee80211_sub_if_data *sdata)\n{\n\tif (!sdata->vif.debugfs_dir)\n\t\treturn;\n\n\tdebugfs_remove_recursive(sdata->vif.debugfs_dir);\n\tsdata->vif.debugfs_dir = NULL;\n\tsdata->debugfs.subdir_stations = NULL;\n}\n\nvoid ieee80211_debugfs_rename_netdev(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct dentry *dir;\n\tchar buf[10 + IFNAMSIZ];\n\n\tdir = sdata->vif.debugfs_dir;\n\n\tif (IS_ERR_OR_NULL(dir))\n\t\treturn;\n\n\tsprintf(buf, \"netdev:%s\", sdata->name);\n\tdebugfs_rename(dir->d_parent, dir, dir->d_parent, buf);\n}\n\nvoid ieee80211_link_debugfs_add(struct ieee80211_link_data *link)\n{\n\tchar link_dir_name[10];\n\n\tif (WARN_ON(!link->sdata->vif.debugfs_dir))\n\t\treturn;\n\n\t \n\tif (WARN_ON(!(link->sdata->local->hw.wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO)))\n\t\treturn;\n\n\tsnprintf(link_dir_name, sizeof(link_dir_name),\n\t\t \"link-%d\", link->link_id);\n\n\tlink->debugfs_dir =\n\t\tdebugfs_create_dir(link_dir_name,\n\t\t\t\t   link->sdata->vif.debugfs_dir);\n\n\tDEBUGFS_ADD(link->debugfs_dir, addr);\n\tadd_link_files(link, link->debugfs_dir);\n}\n\nvoid ieee80211_link_debugfs_remove(struct ieee80211_link_data *link)\n{\n\tif (!link->sdata->vif.debugfs_dir || !link->debugfs_dir) {\n\t\tlink->debugfs_dir = NULL;\n\t\treturn;\n\t}\n\n\tif (link->debugfs_dir == link->sdata->vif.debugfs_dir) {\n\t\tWARN_ON(link != &link->sdata->deflink);\n\t\tlink->debugfs_dir = NULL;\n\t\treturn;\n\t}\n\n\tdebugfs_remove_recursive(link->debugfs_dir);\n\tlink->debugfs_dir = NULL;\n}\n\nvoid ieee80211_link_debugfs_drv_add(struct ieee80211_link_data *link)\n{\n\tif (WARN_ON(!link->debugfs_dir))\n\t\treturn;\n\n\tdrv_link_add_debugfs(link->sdata->local, link->sdata,\n\t\t\t     link->conf, link->debugfs_dir);\n}\n\nvoid ieee80211_link_debugfs_drv_remove(struct ieee80211_link_data *link)\n{\n\tif (!link || !link->debugfs_dir)\n\t\treturn;\n\n\tif (WARN_ON(link->debugfs_dir == link->sdata->vif.debugfs_dir))\n\t\treturn;\n\n\t \n\tdebugfs_remove_recursive(link->debugfs_dir);\n\tlink->debugfs_dir = NULL;\n\n\tieee80211_link_debugfs_add(link);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}