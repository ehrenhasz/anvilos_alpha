{
  "module_name": "main.c",
  "hash_id": "ff2636b4cb2d12785ae0974e8e57b6dc3f2ff8c67d8df75f36d911bd8319c52c",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/main.c",
  "human_readable_source": "\n \n\n#include <net/mac80211.h>\n#include <linux/module.h>\n#include <linux/fips.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/rtnetlink.h>\n#include <linux/bitmap.h>\n#include <linux/inetdevice.h>\n#include <net/net_namespace.h>\n#include <net/dropreason.h>\n#include <net/cfg80211.h>\n#include <net/addrconf.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"rate.h\"\n#include \"mesh.h\"\n#include \"wep.h\"\n#include \"led.h\"\n#include \"debugfs.h\"\n\nvoid ieee80211_configure_filter(struct ieee80211_local *local)\n{\n\tu64 mc;\n\tunsigned int changed_flags;\n\tunsigned int new_flags = 0;\n\n\tif (atomic_read(&local->iff_allmultis))\n\t\tnew_flags |= FIF_ALLMULTI;\n\n\tif (local->monitors || test_bit(SCAN_SW_SCANNING, &local->scanning) ||\n\t    test_bit(SCAN_ONCHANNEL_SCANNING, &local->scanning))\n\t\tnew_flags |= FIF_BCN_PRBRESP_PROMISC;\n\n\tif (local->fif_probe_req || local->probe_req_reg)\n\t\tnew_flags |= FIF_PROBE_REQ;\n\n\tif (local->fif_fcsfail)\n\t\tnew_flags |= FIF_FCSFAIL;\n\n\tif (local->fif_plcpfail)\n\t\tnew_flags |= FIF_PLCPFAIL;\n\n\tif (local->fif_control)\n\t\tnew_flags |= FIF_CONTROL;\n\n\tif (local->fif_other_bss)\n\t\tnew_flags |= FIF_OTHER_BSS;\n\n\tif (local->fif_pspoll)\n\t\tnew_flags |= FIF_PSPOLL;\n\n\tif (local->rx_mcast_action_reg)\n\t\tnew_flags |= FIF_MCAST_ACTION;\n\n\tspin_lock_bh(&local->filter_lock);\n\tchanged_flags = local->filter_flags ^ new_flags;\n\n\tmc = drv_prepare_multicast(local, &local->mc_list);\n\tspin_unlock_bh(&local->filter_lock);\n\n\t \n\tnew_flags |= (1<<31);\n\n\tdrv_configure_filter(local, changed_flags, &new_flags, mc);\n\n\tWARN_ON(new_flags & (1<<31));\n\n\tlocal->filter_flags = new_flags & ~(1<<31);\n}\n\nstatic void ieee80211_reconfig_filter(struct work_struct *work)\n{\n\tstruct ieee80211_local *local =\n\t\tcontainer_of(work, struct ieee80211_local, reconfig_filter);\n\n\tieee80211_configure_filter(local);\n}\n\nstatic u32 ieee80211_hw_conf_chan(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct cfg80211_chan_def chandef = {};\n\tu32 changed = 0;\n\tint power;\n\tu32 offchannel_flag;\n\n\toffchannel_flag = local->hw.conf.flags & IEEE80211_CONF_OFFCHANNEL;\n\n\tif (local->scan_chandef.chan) {\n\t\tchandef = local->scan_chandef;\n\t} else if (local->tmp_channel) {\n\t\tchandef.chan = local->tmp_channel;\n\t\tchandef.width = NL80211_CHAN_WIDTH_20_NOHT;\n\t\tchandef.center_freq1 = chandef.chan->center_freq;\n\t\tchandef.freq1_offset = chandef.chan->freq_offset;\n\t} else\n\t\tchandef = local->_oper_chandef;\n\n\tWARN(!cfg80211_chandef_valid(&chandef),\n\t     \"control:%d.%03d MHz width:%d center: %d.%03d/%d MHz\",\n\t     chandef.chan->center_freq, chandef.chan->freq_offset,\n\t     chandef.width, chandef.center_freq1, chandef.freq1_offset,\n\t     chandef.center_freq2);\n\n\tif (!cfg80211_chandef_identical(&chandef, &local->_oper_chandef))\n\t\tlocal->hw.conf.flags |= IEEE80211_CONF_OFFCHANNEL;\n\telse\n\t\tlocal->hw.conf.flags &= ~IEEE80211_CONF_OFFCHANNEL;\n\n\toffchannel_flag ^= local->hw.conf.flags & IEEE80211_CONF_OFFCHANNEL;\n\n\tif (offchannel_flag ||\n\t    !cfg80211_chandef_identical(&local->hw.conf.chandef,\n\t\t\t\t\t&local->_oper_chandef)) {\n\t\tlocal->hw.conf.chandef = chandef;\n\t\tchanged |= IEEE80211_CONF_CHANGE_CHANNEL;\n\t}\n\n\tif (!conf_is_ht(&local->hw.conf)) {\n\t\t \n\t\tlocal->hw.conf.smps_mode = IEEE80211_SMPS_STATIC;\n\t} else if (local->hw.conf.smps_mode != local->smps_mode) {\n\t\tlocal->hw.conf.smps_mode = local->smps_mode;\n\t\tchanged |= IEEE80211_CONF_CHANGE_SMPS;\n\t}\n\n\tpower = ieee80211_chandef_max_power(&chandef);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (!rcu_access_pointer(sdata->vif.bss_conf.chanctx_conf))\n\t\t\tcontinue;\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\t\tif (sdata->vif.bss_conf.txpower == INT_MIN)\n\t\t\tcontinue;\n\t\tpower = min(power, sdata->vif.bss_conf.txpower);\n\t}\n\trcu_read_unlock();\n\n\tif (local->hw.conf.power_level != power) {\n\t\tchanged |= IEEE80211_CONF_CHANGE_POWER;\n\t\tlocal->hw.conf.power_level = power;\n\t}\n\n\treturn changed;\n}\n\nint ieee80211_hw_config(struct ieee80211_local *local, u32 changed)\n{\n\tint ret = 0;\n\n\tmight_sleep();\n\n\tif (!local->use_chanctx)\n\t\tchanged |= ieee80211_hw_conf_chan(local);\n\telse\n\t\tchanged &= ~(IEEE80211_CONF_CHANGE_CHANNEL |\n\t\t\t     IEEE80211_CONF_CHANGE_POWER |\n\t\t\t     IEEE80211_CONF_CHANGE_SMPS);\n\n\tif (changed && local->open_count) {\n\t\tret = drv_config(local, changed);\n\t\t \n\t\t \n\t}\n\n\treturn ret;\n}\n\n#define BSS_CHANGED_VIF_CFG_FLAGS (BSS_CHANGED_ASSOC |\\\n\t\t\t\t   BSS_CHANGED_IDLE |\\\n\t\t\t\t   BSS_CHANGED_PS |\\\n\t\t\t\t   BSS_CHANGED_IBSS |\\\n\t\t\t\t   BSS_CHANGED_ARP_FILTER |\\\n\t\t\t\t   BSS_CHANGED_SSID)\n\nvoid ieee80211_bss_info_change_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      u64 changed)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\tmight_sleep();\n\n\tif (!changed || sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\treturn;\n\n\tif (WARN_ON_ONCE(changed & (BSS_CHANGED_BEACON |\n\t\t\t\t    BSS_CHANGED_BEACON_ENABLED) &&\n\t\t\t sdata->vif.type != NL80211_IFTYPE_AP &&\n\t\t\t sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t\t sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&\n\t\t\t sdata->vif.type != NL80211_IFTYPE_OCB))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE ||\n\t\t\t sdata->vif.type == NL80211_IFTYPE_NAN ||\n\t\t\t (sdata->vif.type == NL80211_IFTYPE_MONITOR &&\n\t\t\t  !sdata->vif.bss_conf.mu_mimo_owner &&\n\t\t\t  !(changed & BSS_CHANGED_TXPOWER))))\n\t\treturn;\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\tif (changed & BSS_CHANGED_VIF_CFG_FLAGS) {\n\t\tu64 ch = changed & BSS_CHANGED_VIF_CFG_FLAGS;\n\n\t\ttrace_drv_vif_cfg_changed(local, sdata, changed);\n\t\tif (local->ops->vif_cfg_changed)\n\t\t\tlocal->ops->vif_cfg_changed(&local->hw, &sdata->vif, ch);\n\t}\n\n\tif (changed & ~BSS_CHANGED_VIF_CFG_FLAGS) {\n\t\tu64 ch = changed & ~BSS_CHANGED_VIF_CFG_FLAGS;\n\n\t\t \n\t\ttrace_drv_link_info_changed(local, sdata, &sdata->vif.bss_conf,\n\t\t\t\t\t    changed);\n\t\tif (local->ops->link_info_changed)\n\t\t\tlocal->ops->link_info_changed(&local->hw, &sdata->vif,\n\t\t\t\t\t\t      &sdata->vif.bss_conf, ch);\n\t}\n\n\tif (local->ops->bss_info_changed)\n\t\tlocal->ops->bss_info_changed(&local->hw, &sdata->vif,\n\t\t\t\t\t     &sdata->vif.bss_conf, changed);\n\ttrace_drv_return_void(local);\n}\n\nvoid ieee80211_vif_cfg_change_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     u64 changed)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\tWARN_ON_ONCE(changed & ~BSS_CHANGED_VIF_CFG_FLAGS);\n\n\tif (!changed || sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\treturn;\n\n\tdrv_vif_cfg_changed(local, sdata, changed);\n}\n\nvoid ieee80211_link_info_change_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_link_data *link,\n\t\t\t\t       u64 changed)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\tWARN_ON_ONCE(changed & BSS_CHANGED_VIF_CFG_FLAGS);\n\n\tif (!changed || sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\treturn;\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\tdrv_link_info_changed(local, sdata, link->conf, link->link_id, changed);\n}\n\nu64 ieee80211_reset_erp_info(struct ieee80211_sub_if_data *sdata)\n{\n\tsdata->vif.bss_conf.use_cts_prot = false;\n\tsdata->vif.bss_conf.use_short_preamble = false;\n\tsdata->vif.bss_conf.use_short_slot = false;\n\treturn BSS_CHANGED_ERP_CTS_PROT |\n\t       BSS_CHANGED_ERP_PREAMBLE |\n\t       BSS_CHANGED_ERP_SLOT;\n}\n\nstatic void ieee80211_tasklet_handler(struct tasklet_struct *t)\n{\n\tstruct ieee80211_local *local = from_tasklet(local, t, tasklet);\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&local->skb_queue)) ||\n\t       (skb = skb_dequeue(&local->skb_queue_unreliable))) {\n\t\tswitch (skb->pkt_type) {\n\t\tcase IEEE80211_RX_MSG:\n\t\t\t \n\t\t\tskb->pkt_type = 0;\n\t\t\tieee80211_rx(&local->hw, skb);\n\t\t\tbreak;\n\t\tcase IEEE80211_TX_STATUS_MSG:\n\t\t\tskb->pkt_type = 0;\n\t\t\tieee80211_tx_status(&local->hw, skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"mac80211: Packet is of unknown type %d\\n\",\n\t\t\t     skb->pkt_type);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ieee80211_restart_work(struct work_struct *work)\n{\n\tstruct ieee80211_local *local =\n\t\tcontainer_of(work, struct ieee80211_local, restart_work);\n\tstruct ieee80211_sub_if_data *sdata;\n\tint ret;\n\n\tflush_workqueue(local->workqueue);\n\n\trtnl_lock();\n\t \n\twiphy_lock(local->hw.wiphy);\n\n\tWARN(test_bit(SCAN_HW_SCANNING, &local->scanning),\n\t     \"%s called with hardware scan in progress\\n\", __func__);\n\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t \n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION) {\n\t\t\t \n\t\t\twiphy_work_cancel(local->hw.wiphy,\n\t\t\t\t\t  &sdata->u.mgd.csa_connection_drop_work);\n\t\t\tif (sdata->vif.bss_conf.csa_active) {\n\t\t\t\tsdata_lock(sdata);\n\t\t\t\tieee80211_sta_connection_lost(sdata,\n\t\t\t\t\t\t\t      WLAN_REASON_UNSPECIFIED,\n\t\t\t\t\t\t\t      false);\n\t\t\t\tsdata_unlock(sdata);\n\t\t\t}\n\t\t}\n\t\tflush_delayed_work(&sdata->dec_tailroom_needed_wk);\n\t}\n\tieee80211_scan_cancel(local);\n\n\t \n\twiphy_delayed_work_flush(local->hw.wiphy, &local->roc_work);\n\twiphy_work_flush(local->hw.wiphy, &local->hw_roc_done);\n\n\t \n\tsynchronize_net();\n\n\tret = ieee80211_reconfig(local);\n\twiphy_unlock(local->hw.wiphy);\n\n\tif (ret)\n\t\tcfg80211_shutdown_all_interfaces(local->hw.wiphy);\n\n\trtnl_unlock();\n}\n\nvoid ieee80211_restart_hw(struct ieee80211_hw *hw)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\ttrace_api_restart_hw(local);\n\n\twiphy_info(hw->wiphy,\n\t\t   \"Hardware restart was requested\\n\");\n\n\t \n\tieee80211_stop_queues_by_reason(hw, IEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_SUSPEND,\n\t\t\t\t\tfalse);\n\n\t \n\tlocal->in_reconfig = true;\n\tbarrier();\n\n\tqueue_work(system_freezable_wq, &local->restart_work);\n}\nEXPORT_SYMBOL(ieee80211_restart_hw);\n\n#ifdef CONFIG_INET\nstatic int ieee80211_ifa_changed(struct notifier_block *nb,\n\t\t\t\t unsigned long data, void *arg)\n{\n\tstruct in_ifaddr *ifa = arg;\n\tstruct ieee80211_local *local =\n\t\tcontainer_of(nb, struct ieee80211_local,\n\t\t\t     ifa_notifier);\n\tstruct net_device *ndev = ifa->ifa_dev->dev;\n\tstruct wireless_dev *wdev = ndev->ieee80211_ptr;\n\tstruct in_device *idev;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_vif_cfg *vif_cfg;\n\tstruct ieee80211_if_managed *ifmgd;\n\tint c = 0;\n\n\t \n\tif (!wdev)\n\t\treturn NOTIFY_DONE;\n\n\tif (wdev->wiphy != local->hw.wiphy)\n\t\treturn NOTIFY_DONE;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(ndev);\n\tvif_cfg = &sdata->vif.cfg;\n\n\t \n\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn NOTIFY_DONE;\n\n\tidev = __in_dev_get_rtnl(sdata->dev);\n\tif (!idev)\n\t\treturn NOTIFY_DONE;\n\n\tifmgd = &sdata->u.mgd;\n\tsdata_lock(sdata);\n\n\t \n\tifa = rtnl_dereference(idev->ifa_list);\n\twhile (ifa) {\n\t\tif (c < IEEE80211_BSS_ARP_ADDR_LIST_LEN)\n\t\t\tvif_cfg->arp_addr_list[c] = ifa->ifa_address;\n\t\tifa = rtnl_dereference(ifa->ifa_next);\n\t\tc++;\n\t}\n\n\tvif_cfg->arp_addr_cnt = c;\n\n\t \n\tif (ifmgd->associated)\n\t\tieee80211_vif_cfg_change_notify(sdata, BSS_CHANGED_ARP_FILTER);\n\n\tsdata_unlock(sdata);\n\n\treturn NOTIFY_OK;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int ieee80211_ifa6_changed(struct notifier_block *nb,\n\t\t\t\t  unsigned long data, void *arg)\n{\n\tstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)arg;\n\tstruct inet6_dev *idev = ifa->idev;\n\tstruct net_device *ndev = ifa->idev->dev;\n\tstruct ieee80211_local *local =\n\t\tcontainer_of(nb, struct ieee80211_local, ifa6_notifier);\n\tstruct wireless_dev *wdev = ndev->ieee80211_ptr;\n\tstruct ieee80211_sub_if_data *sdata;\n\n\t \n\tif (!wdev || wdev->wiphy != local->hw.wiphy)\n\t\treturn NOTIFY_DONE;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(ndev);\n\n\t \n\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn NOTIFY_DONE;\n\n\tdrv_ipv6_addr_change(local, sdata, idev);\n\n\treturn NOTIFY_OK;\n}\n#endif\n\n \nstatic const struct ieee80211_txrx_stypes\nieee80211_default_mgmt_stypes[NUM_NL80211_IFTYPES] = {\n\t[NL80211_IFTYPE_ADHOC] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4),\n\t},\n\t[NL80211_IFTYPE_STATION] = {\n\t\t.tx = 0xffff,\n\t\t \n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4),\n\t},\n\t[NL80211_IFTYPE_AP] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_ACTION >> 4),\n\t},\n\t[NL80211_IFTYPE_AP_VLAN] = {\n\t\t \n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_ACTION >> 4),\n\t},\n\t[NL80211_IFTYPE_P2P_CLIENT] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4),\n\t},\n\t[NL80211_IFTYPE_P2P_GO] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_ACTION >> 4),\n\t},\n\t[NL80211_IFTYPE_MESH_POINT] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4),\n\t},\n\t[NL80211_IFTYPE_P2P_DEVICE] = {\n\t\t.tx = 0xffff,\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4),\n\t},\n};\n\nstatic const struct ieee80211_ht_cap mac80211_ht_capa_mod_mask = {\n\t.ampdu_params_info = IEEE80211_HT_AMPDU_PARM_FACTOR |\n\t\t\t     IEEE80211_HT_AMPDU_PARM_DENSITY,\n\n\t.cap_info = cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t\t\tIEEE80211_HT_CAP_MAX_AMSDU |\n\t\t\t\tIEEE80211_HT_CAP_SGI_20 |\n\t\t\t\tIEEE80211_HT_CAP_SGI_40 |\n\t\t\t\tIEEE80211_HT_CAP_TX_STBC |\n\t\t\t\tIEEE80211_HT_CAP_RX_STBC |\n\t\t\t\tIEEE80211_HT_CAP_LDPC_CODING |\n\t\t\t\tIEEE80211_HT_CAP_40MHZ_INTOLERANT),\n\t.mcs = {\n\t\t.rx_mask = { 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t     0xff, 0xff, 0xff, 0xff, 0xff, },\n\t},\n};\n\nstatic const struct ieee80211_vht_cap mac80211_vht_capa_mod_mask = {\n\t.vht_cap_info =\n\t\tcpu_to_le32(IEEE80211_VHT_CAP_RXLDPC |\n\t\t\t    IEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t\t    IEEE80211_VHT_CAP_SHORT_GI_160 |\n\t\t\t    IEEE80211_VHT_CAP_RXSTBC_MASK |\n\t\t\t    IEEE80211_VHT_CAP_TXSTBC |\n\t\t\t    IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t\t\t    IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\t\t    IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN |\n\t\t\t    IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN |\n\t\t\t    IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK),\n\t.supp_mcs = {\n\t\t.rx_mcs_map = cpu_to_le16(~0),\n\t\t.tx_mcs_map = cpu_to_le16(~0),\n\t},\n};\n\nstruct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,\n\t\t\t\t\t   const struct ieee80211_ops *ops,\n\t\t\t\t\t   const char *requested_name)\n{\n\tstruct ieee80211_local *local;\n\tint priv_size, i;\n\tstruct wiphy *wiphy;\n\tbool use_chanctx;\n\n\tif (WARN_ON(!ops->tx || !ops->start || !ops->stop || !ops->config ||\n\t\t    !ops->add_interface || !ops->remove_interface ||\n\t\t    !ops->configure_filter || !ops->wake_tx_queue))\n\t\treturn NULL;\n\n\tif (WARN_ON(ops->sta_state && (ops->sta_add || ops->sta_remove)))\n\t\treturn NULL;\n\n\tif (WARN_ON(!!ops->link_info_changed != !!ops->vif_cfg_changed ||\n\t\t    (ops->link_info_changed && ops->bss_info_changed)))\n\t\treturn NULL;\n\n\t \n\ti = !!ops->add_chanctx + !!ops->remove_chanctx +\n\t    !!ops->change_chanctx + !!ops->assign_vif_chanctx +\n\t    !!ops->unassign_vif_chanctx;\n\tif (WARN_ON(i != 0 && i != 5))\n\t\treturn NULL;\n\tuse_chanctx = i == 5;\n\n\t \n\tpriv_size = ALIGN(sizeof(*local), NETDEV_ALIGN) + priv_data_len;\n\n\twiphy = wiphy_new_nm(&mac80211_config_ops, priv_size, requested_name);\n\n\tif (!wiphy)\n\t\treturn NULL;\n\n\twiphy->mgmt_stypes = ieee80211_default_mgmt_stypes;\n\n\twiphy->privid = mac80211_wiphy_privid;\n\n\twiphy->flags |= WIPHY_FLAG_NETNS_OK |\n\t\t\tWIPHY_FLAG_4ADDR_AP |\n\t\t\tWIPHY_FLAG_4ADDR_STATION |\n\t\t\tWIPHY_FLAG_REPORTS_OBSS |\n\t\t\tWIPHY_FLAG_OFFCHAN_TX;\n\n\tif (!use_chanctx || ops->remain_on_channel)\n\t\twiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\n\twiphy->features |= NL80211_FEATURE_SK_TX_STATUS |\n\t\t\t   NL80211_FEATURE_SAE |\n\t\t\t   NL80211_FEATURE_HT_IBSS |\n\t\t\t   NL80211_FEATURE_VIF_TXPOWER |\n\t\t\t   NL80211_FEATURE_MAC_ON_CREATE |\n\t\t\t   NL80211_FEATURE_USERSPACE_MPM |\n\t\t\t   NL80211_FEATURE_FULL_AP_CLIENT_STATE;\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_FILS_STA);\n\twiphy_ext_feature_set(wiphy,\n\t\t\t      NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211);\n\twiphy_ext_feature_set(wiphy,\n\t\t\t      NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH);\n\twiphy_ext_feature_set(wiphy,\n\t\t\t      NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS);\n\twiphy_ext_feature_set(wiphy,\n\t\t\t      NL80211_EXT_FEATURE_SCAN_FREQ_KHZ);\n\twiphy_ext_feature_set(wiphy,\n\t\t\t      NL80211_EXT_FEATURE_POWERED_ADDR_CHANGE);\n\n\tif (!ops->hw_scan) {\n\t\twiphy->features |= NL80211_FEATURE_LOW_PRIORITY_SCAN |\n\t\t\t\t   NL80211_FEATURE_AP_SCAN;\n\t\t \n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_SCAN_RANDOM_SN);\n\t\twiphy_ext_feature_set(wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT);\n\t}\n\n\tif (!ops->set_key)\n\t\twiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_TXQS);\n\twiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_RRM);\n\n\twiphy->bss_priv_size = sizeof(struct ieee80211_bss);\n\n\tlocal = wiphy_priv(wiphy);\n\n\tif (sta_info_init(local))\n\t\tgoto err_free;\n\n\tlocal->hw.wiphy = wiphy;\n\n\tlocal->hw.priv = (char *)local + ALIGN(sizeof(*local), NETDEV_ALIGN);\n\n\tlocal->ops = ops;\n\tlocal->use_chanctx = use_chanctx;\n\n\t \n\tlocal->hw.tx_sk_pacing_shift = 7;\n\n\t \n\tlocal->hw.queues = 1;\n\tlocal->hw.max_rates = 1;\n\tlocal->hw.max_report_rates = 0;\n\tlocal->hw.max_rx_aggregation_subframes = IEEE80211_MAX_AMPDU_BUF_HT;\n\tlocal->hw.max_tx_aggregation_subframes = IEEE80211_MAX_AMPDU_BUF_HT;\n\tlocal->hw.offchannel_tx_hw_queue = IEEE80211_INVAL_HW_QUEUE;\n\tlocal->hw.conf.long_frame_max_tx_count = wiphy->retry_long;\n\tlocal->hw.conf.short_frame_max_tx_count = wiphy->retry_short;\n\tlocal->hw.radiotap_mcs_details = IEEE80211_RADIOTAP_MCS_HAVE_MCS |\n\t\t\t\t\t IEEE80211_RADIOTAP_MCS_HAVE_GI |\n\t\t\t\t\t IEEE80211_RADIOTAP_MCS_HAVE_BW;\n\tlocal->hw.radiotap_vht_details = IEEE80211_RADIOTAP_VHT_KNOWN_GI |\n\t\t\t\t\t IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH;\n\tlocal->hw.uapsd_queues = IEEE80211_DEFAULT_UAPSD_QUEUES;\n\tlocal->hw.uapsd_max_sp_len = IEEE80211_DEFAULT_MAX_SP_LEN;\n\tlocal->hw.max_mtu = IEEE80211_MAX_DATA_LEN;\n\tlocal->user_power_level = IEEE80211_UNSET_POWER_LEVEL;\n\twiphy->ht_capa_mod_mask = &mac80211_ht_capa_mod_mask;\n\twiphy->vht_capa_mod_mask = &mac80211_vht_capa_mod_mask;\n\n\tlocal->ext_capa[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF;\n\n\twiphy->extended_capabilities = local->ext_capa;\n\twiphy->extended_capabilities_mask = local->ext_capa;\n\twiphy->extended_capabilities_len =\n\t\tARRAY_SIZE(local->ext_capa);\n\n\tINIT_LIST_HEAD(&local->interfaces);\n\tINIT_LIST_HEAD(&local->mon_list);\n\n\t__hw_addr_init(&local->mc_list);\n\n\tmutex_init(&local->iflist_mtx);\n\tmutex_init(&local->mtx);\n\n\tmutex_init(&local->key_mtx);\n\tspin_lock_init(&local->filter_lock);\n\tspin_lock_init(&local->rx_path_lock);\n\tspin_lock_init(&local->queue_stop_reason_lock);\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tINIT_LIST_HEAD(&local->active_txqs[i]);\n\t\tspin_lock_init(&local->active_txq_lock[i]);\n\t\tlocal->aql_txq_limit_low[i] = IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L;\n\t\tlocal->aql_txq_limit_high[i] =\n\t\t\tIEEE80211_DEFAULT_AQL_TXQ_LIMIT_H;\n\t\tatomic_set(&local->aql_ac_pending_airtime[i], 0);\n\t}\n\n\tlocal->airtime_flags = AIRTIME_USE_TX | AIRTIME_USE_RX;\n\tlocal->aql_threshold = IEEE80211_AQL_THRESHOLD;\n\tatomic_set(&local->aql_total_pending_airtime, 0);\n\n\tspin_lock_init(&local->handle_wake_tx_queue_lock);\n\n\tINIT_LIST_HEAD(&local->chanctx_list);\n\tmutex_init(&local->chanctx_mtx);\n\n\twiphy_delayed_work_init(&local->scan_work, ieee80211_scan_work);\n\n\tINIT_WORK(&local->restart_work, ieee80211_restart_work);\n\n\twiphy_work_init(&local->radar_detected_work,\n\t\t\tieee80211_dfs_radar_detected_work);\n\n\tINIT_WORK(&local->reconfig_filter, ieee80211_reconfig_filter);\n\tlocal->smps_mode = IEEE80211_SMPS_OFF;\n\n\tINIT_WORK(&local->dynamic_ps_enable_work,\n\t\t  ieee80211_dynamic_ps_enable_work);\n\tINIT_WORK(&local->dynamic_ps_disable_work,\n\t\t  ieee80211_dynamic_ps_disable_work);\n\ttimer_setup(&local->dynamic_ps_timer, ieee80211_dynamic_ps_timer, 0);\n\n\twiphy_work_init(&local->sched_scan_stopped_work,\n\t\t\tieee80211_sched_scan_stopped_work);\n\n\tspin_lock_init(&local->ack_status_lock);\n\tidr_init(&local->ack_status_frames);\n\n\tfor (i = 0; i < IEEE80211_MAX_QUEUES; i++) {\n\t\tskb_queue_head_init(&local->pending[i]);\n\t\tatomic_set(&local->agg_queue_stop[i], 0);\n\t}\n\ttasklet_setup(&local->tx_pending_tasklet, ieee80211_tx_pending);\n\ttasklet_setup(&local->wake_txqs_tasklet, ieee80211_wake_txqs);\n\ttasklet_setup(&local->tasklet, ieee80211_tasklet_handler);\n\n\tskb_queue_head_init(&local->skb_queue);\n\tskb_queue_head_init(&local->skb_queue_unreliable);\n\n\tieee80211_alloc_led_names(local);\n\n\tieee80211_roc_setup(local);\n\n\tlocal->hw.radiotap_timestamp.units_pos = -1;\n\tlocal->hw.radiotap_timestamp.accuracy = -1;\n\n\treturn &local->hw;\n err_free:\n\twiphy_free(wiphy);\n\treturn NULL;\n}\nEXPORT_SYMBOL(ieee80211_alloc_hw_nm);\n\nstatic int ieee80211_init_cipher_suites(struct ieee80211_local *local)\n{\n\tbool have_wep = !fips_enabled;  \n\tbool have_mfp = ieee80211_hw_check(&local->hw, MFP_CAPABLE);\n\tint r = 0, w = 0;\n\tu32 *suites;\n\tstatic const u32 cipher_suites[] = {\n\t\t \n\t\tWLAN_CIPHER_SUITE_WEP40,\n\t\tWLAN_CIPHER_SUITE_WEP104,\n\t\tWLAN_CIPHER_SUITE_TKIP,\n\t\tWLAN_CIPHER_SUITE_CCMP,\n\t\tWLAN_CIPHER_SUITE_CCMP_256,\n\t\tWLAN_CIPHER_SUITE_GCMP,\n\t\tWLAN_CIPHER_SUITE_GCMP_256,\n\n\t\t \n\t\tWLAN_CIPHER_SUITE_AES_CMAC,\n\t\tWLAN_CIPHER_SUITE_BIP_CMAC_256,\n\t\tWLAN_CIPHER_SUITE_BIP_GMAC_128,\n\t\tWLAN_CIPHER_SUITE_BIP_GMAC_256,\n\t};\n\n\tif (ieee80211_hw_check(&local->hw, SW_CRYPTO_CONTROL) ||\n\t    local->hw.wiphy->cipher_suites) {\n\t\t \n\t\tif (have_wep)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!local->hw.wiphy->n_cipher_suites)\n\t\t\treturn 0;\n\n\t\t \n\t\tsuites = kmemdup(local->hw.wiphy->cipher_suites,\n\t\t\t\t sizeof(u32) * local->hw.wiphy->n_cipher_suites,\n\t\t\t\t GFP_KERNEL);\n\t\tif (!suites)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (r = 0; r < local->hw.wiphy->n_cipher_suites; r++) {\n\t\t\tu32 suite = local->hw.wiphy->cipher_suites[r];\n\n\t\t\tif (suite == WLAN_CIPHER_SUITE_WEP40 ||\n\t\t\t    suite == WLAN_CIPHER_SUITE_WEP104)\n\t\t\t\tcontinue;\n\t\t\tsuites[w++] = suite;\n\t\t}\n\t} else {\n\t\t \n\t\tlocal->hw.wiphy->cipher_suites = cipher_suites;\n\t\tlocal->hw.wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);\n\n\t\tif (!have_mfp)\n\t\t\tlocal->hw.wiphy->n_cipher_suites -= 4;\n\n\t\tif (!have_wep) {\n\t\t\tlocal->hw.wiphy->cipher_suites += 2;\n\t\t\tlocal->hw.wiphy->n_cipher_suites -= 2;\n\t\t}\n\n\t\t \n\t\treturn 0;\n\t}\n\n\tlocal->hw.wiphy->cipher_suites = suites;\n\tlocal->hw.wiphy->n_cipher_suites = w;\n\tlocal->wiphy_ciphers_allocated = true;\n\n\treturn 0;\n}\n\nint ieee80211_register_hw(struct ieee80211_hw *hw)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tint result, i;\n\tenum nl80211_band band;\n\tint channels, max_bitrates;\n\tbool supp_ht, supp_vht, supp_he, supp_eht;\n\tstruct cfg80211_chan_def dflt_chandef = {};\n\n\tif (ieee80211_hw_check(hw, QUEUE_CONTROL) &&\n\t    (local->hw.offchannel_tx_hw_queue == IEEE80211_INVAL_HW_QUEUE ||\n\t     local->hw.offchannel_tx_hw_queue >= local->hw.queues))\n\t\treturn -EINVAL;\n\n\tif ((hw->wiphy->features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH) &&\n\t    (!local->ops->tdls_channel_switch ||\n\t     !local->ops->tdls_cancel_channel_switch ||\n\t     !local->ops->tdls_recv_channel_switch))\n\t\treturn -EOPNOTSUPP;\n\n\tif (WARN_ON(ieee80211_hw_check(hw, SUPPORTS_TX_FRAG) &&\n\t\t    !local->ops->set_frag_threshold))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(local->hw.wiphy->interface_modes &\n\t\t\tBIT(NL80211_IFTYPE_NAN) &&\n\t\t    (!local->ops->start_nan || !local->ops->stop_nan)))\n\t\treturn -EINVAL;\n\n\tif (hw->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO) {\n\t\t \n\t\tif (WARN_ON(!local->use_chanctx))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(!local->ops->link_info_changed))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(!ieee80211_hw_check(hw, HAS_RATE_CONTROL)))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(!ieee80211_hw_check(hw, AMPDU_AGGREGATION)))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(ieee80211_hw_check(hw, HOST_BROADCAST_PS_BUFFERING)))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(ieee80211_hw_check(hw, SUPPORTS_PS) &&\n\t\t\t    (!ieee80211_hw_check(hw, SUPPORTS_DYNAMIC_PS) ||\n\t\t\t     ieee80211_hw_check(hw, PS_NULLFUNC_STACK))))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(!ieee80211_hw_check(hw, MFP_CAPABLE)))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(!ieee80211_hw_check(hw, CONNECTION_MONITOR)))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(ieee80211_hw_check(hw, NEED_DTIM_BEFORE_ASSOC)))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(ieee80211_hw_check(hw, TIMING_BEACON_ONLY)))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(!ieee80211_hw_check(hw, AP_LINK_PS)))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(ieee80211_hw_check(hw, DEAUTH_NEED_MGD_TX_PREP)))\n\t\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_PM\n\tif (hw->wiphy->wowlan && (!local->ops->suspend || !local->ops->resume))\n\t\treturn -EINVAL;\n#endif\n\n\tif (!local->use_chanctx) {\n\t\tfor (i = 0; i < local->hw.wiphy->n_iface_combinations; i++) {\n\t\t\tconst struct ieee80211_iface_combination *comb;\n\n\t\t\tcomb = &local->hw.wiphy->iface_combinations[i];\n\n\t\t\tif (comb->num_different_channels > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < local->hw.wiphy->n_iface_combinations; i++) {\n\t\t\tconst struct ieee80211_iface_combination *comb;\n\n\t\t\tcomb = &local->hw.wiphy->iface_combinations[i];\n\n\t\t\tif (comb->radar_detect_widths &&\n\t\t\t    comb->num_different_channels > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (WARN_ON(hw->netdev_features & ~MAC80211_SUPPORTED_FEATURES))\n\t\treturn -EINVAL;\n\n\tif (hw->max_report_rates == 0)\n\t\thw->max_report_rates = hw->max_rates;\n\n\tlocal->rx_chains = 1;\n\n\t \n\tchannels = 0;\n\tmax_bitrates = 0;\n\tsupp_ht = false;\n\tsupp_vht = false;\n\tsupp_he = false;\n\tsupp_eht = false;\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = local->hw.wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tif (!dflt_chandef.chan) {\n\t\t\t \n\t\t\tfor (i = 0; i < sband->n_channels; i++)\n\t\t\t\tif (!(sband->channels[i].flags &\n\t\t\t\t\t\tIEEE80211_CHAN_DISABLED))\n\t\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (i == sband->n_channels)\n\t\t\t\ti = 0;\n\t\t\tcfg80211_chandef_create(&dflt_chandef,\n\t\t\t\t\t\t&sband->channels[i],\n\t\t\t\t\t\tNL80211_CHAN_NO_HT);\n\t\t\t \n\t\t\tif (!local->use_chanctx && !local->_oper_chandef.chan) {\n\t\t\t\tlocal->hw.conf.chandef = dflt_chandef;\n\t\t\t\tlocal->_oper_chandef = dflt_chandef;\n\t\t\t}\n\t\t\tlocal->monitor_chandef = dflt_chandef;\n\t\t}\n\n\t\tchannels += sband->n_channels;\n\n\t\t \n\t\tif (WARN_ON(sband->ht_cap.ht_supported &&\n\t\t\t    (sband->ht_cap.cap & IEEE80211_HT_CAP_DELAY_BA) &&\n\t\t\t    hw->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO))\n\t\t\treturn -EINVAL;\n\n\t\tif (max_bitrates < sband->n_bitrates)\n\t\t\tmax_bitrates = sband->n_bitrates;\n\t\tsupp_ht = supp_ht || sband->ht_cap.ht_supported;\n\t\tsupp_vht = supp_vht || sband->vht_cap.vht_supported;\n\n\t\tfor (i = 0; i < sband->n_iftype_data; i++) {\n\t\t\tconst struct ieee80211_sband_iftype_data *iftd;\n\n\t\t\tiftd = &sband->iftype_data[i];\n\n\t\t\tsupp_he = supp_he || iftd->he_cap.has_he;\n\t\t\tsupp_eht = supp_eht || iftd->eht_cap.has_eht;\n\t\t}\n\n\t\t \n\t\tif (WARN_ON(local->hw.queues < IEEE80211_NUM_ACS &&\n\t\t\t    (supp_ht || supp_vht || supp_he)))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (WARN_ON(supp_eht && !supp_he))\n\t\t\treturn -EINVAL;\n\n\t\tif (!sband->ht_cap.ht_supported)\n\t\t\tcontinue;\n\n\t\t \n\t\tlocal->rx_chains =\n\t\t\tmax(ieee80211_mcs_to_chains(&sband->ht_cap.mcs),\n\t\t\t    local->rx_chains);\n\n\t\t \n\t\tsband->ht_cap.cap |= WLAN_HT_CAP_SM_PS_DISABLED <<\n\t\t\t             IEEE80211_HT_CAP_SM_PS_SHIFT;\n\t}\n\n\t \n\tif (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_AP) &&\n\t    !ieee80211_hw_check(&local->hw, SW_CRYPTO_CONTROL)) {\n\t\thw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_AP_VLAN);\n\t\thw->wiphy->software_iftypes |= BIT(NL80211_IFTYPE_AP_VLAN);\n\t}\n\n\t \n\thw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_MONITOR);\n\thw->wiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);\n\n\t \n\tfor (i = 0; i < hw->wiphy->n_iface_combinations; i++) {\n\t\tconst struct ieee80211_iface_combination *c;\n\t\tint j;\n\n\t\tc = &hw->wiphy->iface_combinations[i];\n\n\t\tfor (j = 0; j < c->n_limits; j++)\n\t\t\tif ((c->limits[j].types & BIT(NL80211_IFTYPE_ADHOC)) &&\n\t\t\t    c->limits[j].max > 1)\n\t\t\t\treturn -EINVAL;\n\t}\n\n\tlocal->int_scan_req = kzalloc(sizeof(*local->int_scan_req) +\n\t\t\t\t      sizeof(void *) * channels, GFP_KERNEL);\n\tif (!local->int_scan_req)\n\t\treturn -ENOMEM;\n\n\teth_broadcast_addr(local->int_scan_req->bssid);\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!local->hw.wiphy->bands[band])\n\t\t\tcontinue;\n\t\tlocal->int_scan_req->rates[band] = (u32) -1;\n\t}\n\n#ifndef CONFIG_MAC80211_MESH\n\t \n\tlocal->hw.wiphy->interface_modes &= ~BIT(NL80211_IFTYPE_MESH_POINT);\n#endif\n\n\t \n\tif (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_MESH_POINT))\n\t\tlocal->hw.wiphy->flags |= WIPHY_FLAG_MESH_AUTH;\n\n\t \n\tlocal->hw.wiphy->flags |= WIPHY_FLAG_CONTROL_PORT_PROTOCOL;\n\n\tif (ieee80211_hw_check(&local->hw, SIGNAL_DBM)) {\n\t\tlocal->hw.wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\t} else if (ieee80211_hw_check(&local->hw, SIGNAL_UNSPEC)) {\n\t\tlocal->hw.wiphy->signal_type = CFG80211_SIGNAL_TYPE_UNSPEC;\n\t\tif (hw->max_signal <= 0) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto fail_workqueue;\n\t\t}\n\t}\n\n\t \n\tif (!local->ops->set_key) {\n\t\twiphy_ext_feature_set(local->hw.wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);\n\t\twiphy_ext_feature_set(local->hw.wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_EXT_KEY_ID);\n\t}\n\n\tif (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_ADHOC))\n\t\twiphy_ext_feature_set(local->hw.wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_DEL_IBSS_STA);\n\n\t \n\tlocal->scan_ies_len = 4 + max_bitrates   +\n\t\t3  ;\n\tif (supp_ht)\n\t\tlocal->scan_ies_len += 2 + sizeof(struct ieee80211_ht_cap);\n\n\tif (supp_vht)\n\t\tlocal->scan_ies_len +=\n\t\t\t2 + sizeof(struct ieee80211_vht_cap);\n\n\t \n\tif (supp_he) {\n\t\tlocal->scan_ies_len +=\n\t\t\t3 + sizeof(struct ieee80211_he_cap_elem) +\n\t\t\tsizeof(struct ieee80211_he_mcs_nss_supp) +\n\t\t\tIEEE80211_HE_PPE_THRES_MAX_LEN;\n\n\t\tif (supp_eht)\n\t\t\tlocal->scan_ies_len +=\n\t\t\t\t3 + sizeof(struct ieee80211_eht_cap_elem) +\n\t\t\t\tsizeof(struct ieee80211_eht_mcs_nss_supp) +\n\t\t\t\tIEEE80211_EHT_PPE_THRES_MAX_LEN;\n\t}\n\n\tif (!local->ops->hw_scan) {\n\t\t \n\t\tlocal->hw.wiphy->max_scan_ssids = 4;\n\t\tlocal->hw.wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\n\t}\n\n\t \n\tif (local->hw.wiphy->max_scan_ie_len)\n\t\tlocal->hw.wiphy->max_scan_ie_len -= local->scan_ies_len;\n\n\tresult = ieee80211_init_cipher_suites(local);\n\tif (result < 0)\n\t\tgoto fail_workqueue;\n\n\tif (!local->ops->remain_on_channel)\n\t\tlocal->hw.wiphy->max_remain_on_channel_duration = 5000;\n\n\t \n\tif (local->hw.wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS)\n\t\tlocal->hw.wiphy->flags |= WIPHY_FLAG_TDLS_EXTERNAL_SETUP;\n\n\t \n\tif (ieee80211_hw_check(&local->hw, CHANCTX_STA_CSA))\n\t\tlocal->ext_capa[0] |= WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING;\n\n\t \n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_MULTI_BSSID)) {\n\t\tlocal->hw.wiphy->support_mbssid = true;\n\t\tif (ieee80211_hw_check(&local->hw,\n\t\t\t\t       SUPPORTS_ONLY_HE_MULTI_BSSID))\n\t\t\tlocal->hw.wiphy->support_only_he_mbssid = true;\n\t\telse\n\t\t\tlocal->ext_capa[2] |=\n\t\t\t\tWLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT;\n\t}\n\n\tlocal->hw.wiphy->max_num_csa_counters = IEEE80211_MAX_CNTDWN_COUNTERS_NUM;\n\n\t \n\tif (hw->queues > IEEE80211_MAX_QUEUES)\n\t\thw->queues = IEEE80211_MAX_QUEUES;\n\n\tlocal->workqueue =\n\t\talloc_ordered_workqueue(\"%s\", 0, wiphy_name(local->hw.wiphy));\n\tif (!local->workqueue) {\n\t\tresult = -ENOMEM;\n\t\tgoto fail_workqueue;\n\t}\n\n\t \n\tlocal->tx_headroom = max_t(unsigned int , local->hw.extra_tx_headroom,\n\t\t\t\t   IEEE80211_TX_STATUS_HEADROOM);\n\n\t \n\tif (local->hw.max_listen_interval == 0)\n\t\tlocal->hw.max_listen_interval = 5;\n\n\tlocal->hw.conf.listen_interval = local->hw.max_listen_interval;\n\n\tlocal->dynamic_ps_forced_timeout = -1;\n\n\tif (!local->hw.max_nan_de_entries)\n\t\tlocal->hw.max_nan_de_entries = IEEE80211_MAX_NAN_INSTANCE_ID;\n\n\tif (!local->hw.weight_multiplier)\n\t\tlocal->hw.weight_multiplier = 1;\n\n\tieee80211_wep_init(local);\n\n\tlocal->hw.conf.flags = IEEE80211_CONF_IDLE;\n\n\tieee80211_led_init(local);\n\n\tresult = ieee80211_txq_setup_flows(local);\n\tif (result)\n\t\tgoto fail_flows;\n\n\trtnl_lock();\n\tresult = ieee80211_init_rate_ctrl_alg(local,\n\t\t\t\t\t      hw->rate_control_algorithm);\n\trtnl_unlock();\n\tif (result < 0) {\n\t\twiphy_debug(local->hw.wiphy,\n\t\t\t    \"Failed to initialize rate control algorithm\\n\");\n\t\tgoto fail_rate;\n\t}\n\n\tif (local->rate_ctrl) {\n\t\tclear_bit(IEEE80211_HW_SUPPORTS_VHT_EXT_NSS_BW, hw->flags);\n\t\tif (local->rate_ctrl->ops->capa & RATE_CTRL_CAPA_VHT_EXT_NSS_BW)\n\t\t\tieee80211_hw_set(hw, SUPPORTS_VHT_EXT_NSS_BW);\n\t}\n\n\t \n\tBUILD_BUG_ON(NUM_NL80211_BANDS > 8 * sizeof(local->sband_allocated));\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tbool local_cap, ie_cap;\n\n\t\tlocal_cap = ieee80211_hw_check(hw, SUPPORTS_VHT_EXT_NSS_BW);\n\n\t\tsband = local->hw.wiphy->bands[band];\n\t\tif (!sband || !sband->vht_cap.vht_supported)\n\t\t\tcontinue;\n\n\t\tie_cap = !!(sband->vht_cap.vht_mcs.tx_highest &\n\t\t\t    cpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE));\n\n\t\tif (local_cap == ie_cap)\n\t\t\tcontinue;\n\n\t\tsband = kmemdup(sband, sizeof(*sband), GFP_KERNEL);\n\t\tif (!sband) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto fail_rate;\n\t\t}\n\n\t\twiphy_dbg(hw->wiphy, \"copying sband (band %d) due to VHT EXT NSS BW flag\\n\",\n\t\t\t  band);\n\n\t\tsband->vht_cap.vht_mcs.tx_highest ^=\n\t\t\tcpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE);\n\n\t\tlocal->hw.wiphy->bands[band] = sband;\n\t\tlocal->sband_allocated |= BIT(band);\n\t}\n\n\tresult = wiphy_register(local->hw.wiphy);\n\tif (result < 0)\n\t\tgoto fail_wiphy_register;\n\n\tdebugfs_hw_add(local);\n\trate_control_add_debugfs(local);\n\n\trtnl_lock();\n\twiphy_lock(hw->wiphy);\n\n\t \n\tif (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_STATION) &&\n\t    !ieee80211_hw_check(hw, NO_AUTO_VIF)) {\n\t\tstruct vif_params params = {0};\n\n\t\tresult = ieee80211_if_add(local, \"wlan%d\", NET_NAME_ENUM, NULL,\n\t\t\t\t\t  NL80211_IFTYPE_STATION, &params);\n\t\tif (result)\n\t\t\twiphy_warn(local->hw.wiphy,\n\t\t\t\t   \"Failed to add default virtual iface\\n\");\n\t}\n\n\twiphy_unlock(hw->wiphy);\n\trtnl_unlock();\n\n#ifdef CONFIG_INET\n\tlocal->ifa_notifier.notifier_call = ieee80211_ifa_changed;\n\tresult = register_inetaddr_notifier(&local->ifa_notifier);\n\tif (result)\n\t\tgoto fail_ifa;\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tlocal->ifa6_notifier.notifier_call = ieee80211_ifa6_changed;\n\tresult = register_inet6addr_notifier(&local->ifa6_notifier);\n\tif (result)\n\t\tgoto fail_ifa6;\n#endif\n\n\treturn 0;\n\n#if IS_ENABLED(CONFIG_IPV6)\n fail_ifa6:\n#ifdef CONFIG_INET\n\tunregister_inetaddr_notifier(&local->ifa_notifier);\n#endif\n#endif\n#if defined(CONFIG_INET) || defined(CONFIG_IPV6)\n fail_ifa:\n#endif\n\twiphy_unregister(local->hw.wiphy);\n fail_wiphy_register:\n\trtnl_lock();\n\trate_control_deinitialize(local);\n\tieee80211_remove_interfaces(local);\n\trtnl_unlock();\n fail_rate:\n fail_flows:\n\tieee80211_led_exit(local);\n\tdestroy_workqueue(local->workqueue);\n fail_workqueue:\n\tif (local->wiphy_ciphers_allocated) {\n\t\tkfree(local->hw.wiphy->cipher_suites);\n\t\tlocal->wiphy_ciphers_allocated = false;\n\t}\n\tkfree(local->int_scan_req);\n\treturn result;\n}\nEXPORT_SYMBOL(ieee80211_register_hw);\n\nvoid ieee80211_unregister_hw(struct ieee80211_hw *hw)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\ttasklet_kill(&local->tx_pending_tasklet);\n\ttasklet_kill(&local->tasklet);\n\n#ifdef CONFIG_INET\n\tunregister_inetaddr_notifier(&local->ifa_notifier);\n#endif\n#if IS_ENABLED(CONFIG_IPV6)\n\tunregister_inet6addr_notifier(&local->ifa6_notifier);\n#endif\n\n\trtnl_lock();\n\n\t \n\tieee80211_remove_interfaces(local);\n\n\twiphy_lock(local->hw.wiphy);\n\twiphy_delayed_work_cancel(local->hw.wiphy, &local->roc_work);\n\twiphy_work_cancel(local->hw.wiphy, &local->sched_scan_stopped_work);\n\twiphy_work_cancel(local->hw.wiphy, &local->radar_detected_work);\n\twiphy_unlock(local->hw.wiphy);\n\trtnl_unlock();\n\n\tcancel_work_sync(&local->restart_work);\n\tcancel_work_sync(&local->reconfig_filter);\n\n\tieee80211_clear_tx_pending(local);\n\trate_control_deinitialize(local);\n\n\tif (skb_queue_len(&local->skb_queue) ||\n\t    skb_queue_len(&local->skb_queue_unreliable))\n\t\twiphy_warn(local->hw.wiphy, \"skb_queue not empty\\n\");\n\tskb_queue_purge(&local->skb_queue);\n\tskb_queue_purge(&local->skb_queue_unreliable);\n\n\twiphy_unregister(local->hw.wiphy);\n\tdestroy_workqueue(local->workqueue);\n\tieee80211_led_exit(local);\n\tkfree(local->int_scan_req);\n}\nEXPORT_SYMBOL(ieee80211_unregister_hw);\n\nstatic int ieee80211_free_ack_frame(int id, void *p, void *data)\n{\n\tWARN_ONCE(1, \"Have pending ack frames!\\n\");\n\tkfree_skb(p);\n\treturn 0;\n}\n\nvoid ieee80211_free_hw(struct ieee80211_hw *hw)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tenum nl80211_band band;\n\n\tmutex_destroy(&local->iflist_mtx);\n\tmutex_destroy(&local->mtx);\n\n\tif (local->wiphy_ciphers_allocated) {\n\t\tkfree(local->hw.wiphy->cipher_suites);\n\t\tlocal->wiphy_ciphers_allocated = false;\n\t}\n\n\tidr_for_each(&local->ack_status_frames,\n\t\t     ieee80211_free_ack_frame, NULL);\n\tidr_destroy(&local->ack_status_frames);\n\n\tsta_info_stop(local);\n\n\tieee80211_free_led_names(local);\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!(local->sband_allocated & BIT(band)))\n\t\t\tcontinue;\n\t\tkfree(local->hw.wiphy->bands[band]);\n\t}\n\n\twiphy_free(local->hw.wiphy);\n}\nEXPORT_SYMBOL(ieee80211_free_hw);\n\nstatic const char * const drop_reasons_monitor[] = {\n#define V(x)\t#x,\n\t[0] = \"RX_DROP_MONITOR\",\n\tMAC80211_DROP_REASONS_MONITOR(V)\n};\n\nstatic struct drop_reason_list drop_reason_list_monitor = {\n\t.reasons = drop_reasons_monitor,\n\t.n_reasons = ARRAY_SIZE(drop_reasons_monitor),\n};\n\nstatic const char * const drop_reasons_unusable[] = {\n\t[0] = \"RX_DROP_UNUSABLE\",\n\tMAC80211_DROP_REASONS_UNUSABLE(V)\n#undef V\n};\n\nstatic struct drop_reason_list drop_reason_list_unusable = {\n\t.reasons = drop_reasons_unusable,\n\t.n_reasons = ARRAY_SIZE(drop_reasons_unusable),\n};\n\nstatic int __init ieee80211_init(void)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct ieee80211_tx_info) > sizeof(skb->cb));\n\tBUILD_BUG_ON(offsetof(struct ieee80211_tx_info, driver_data) +\n\t\t     IEEE80211_TX_INFO_DRIVER_DATA_SIZE > sizeof(skb->cb));\n\n\tret = rc80211_minstrel_init();\n\tif (ret)\n\t\treturn ret;\n\n\tret = ieee80211_iface_init();\n\tif (ret)\n\t\tgoto err_netdev;\n\n\tdrop_reasons_register_subsys(SKB_DROP_REASON_SUBSYS_MAC80211_MONITOR,\n\t\t\t\t     &drop_reason_list_monitor);\n\tdrop_reasons_register_subsys(SKB_DROP_REASON_SUBSYS_MAC80211_UNUSABLE,\n\t\t\t\t     &drop_reason_list_unusable);\n\n\treturn 0;\n err_netdev:\n\trc80211_minstrel_exit();\n\n\treturn ret;\n}\n\nstatic void __exit ieee80211_exit(void)\n{\n\trc80211_minstrel_exit();\n\n\tieee80211s_stop();\n\n\tieee80211_iface_exit();\n\n\tdrop_reasons_unregister_subsys(SKB_DROP_REASON_SUBSYS_MAC80211_MONITOR);\n\tdrop_reasons_unregister_subsys(SKB_DROP_REASON_SUBSYS_MAC80211_UNUSABLE);\n\n\trcu_barrier();\n}\n\n\nsubsys_initcall(ieee80211_init);\nmodule_exit(ieee80211_exit);\n\nMODULE_DESCRIPTION(\"IEEE 802.11 subsystem\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}