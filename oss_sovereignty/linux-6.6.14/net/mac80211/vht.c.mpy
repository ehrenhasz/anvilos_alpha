{
  "module_name": "vht.c",
  "hash_id": "fd2187eb3e9acbd23a4c62282611891acc47f059374586d05c6df221b67f4630",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/vht.c",
  "human_readable_source": "\n \n\n#include <linux/ieee80211.h>\n#include <linux/export.h>\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"rate.h\"\n\n\nstatic void __check_vhtcap_disable(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct ieee80211_sta_vht_cap *vht_cap,\n\t\t\t\t   u32 flag)\n{\n\t__le32 le_flag = cpu_to_le32(flag);\n\n\tif (sdata->u.mgd.vht_capa_mask.vht_cap_info & le_flag &&\n\t    !(sdata->u.mgd.vht_capa.vht_cap_info & le_flag))\n\t\tvht_cap->cap &= ~flag;\n}\n\nvoid ieee80211_apply_vhtcap_overrides(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct ieee80211_sta_vht_cap *vht_cap)\n{\n\tint i;\n\tu16 rxmcs_mask, rxmcs_cap, rxmcs_n, txmcs_mask, txmcs_cap, txmcs_n;\n\n\tif (!vht_cap->vht_supported)\n\t\treturn;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\t__check_vhtcap_disable(sdata, vht_cap,\n\t\t\t       IEEE80211_VHT_CAP_RXLDPC);\n\t__check_vhtcap_disable(sdata, vht_cap,\n\t\t\t       IEEE80211_VHT_CAP_SHORT_GI_80);\n\t__check_vhtcap_disable(sdata, vht_cap,\n\t\t\t       IEEE80211_VHT_CAP_SHORT_GI_160);\n\t__check_vhtcap_disable(sdata, vht_cap,\n\t\t\t       IEEE80211_VHT_CAP_TXSTBC);\n\t__check_vhtcap_disable(sdata, vht_cap,\n\t\t\t       IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE);\n\t__check_vhtcap_disable(sdata, vht_cap,\n\t\t\t       IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE);\n\t__check_vhtcap_disable(sdata, vht_cap,\n\t\t\t       IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN);\n\t__check_vhtcap_disable(sdata, vht_cap,\n\t\t\t       IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN);\n\n\t \n\tif (sdata->u.mgd.vht_capa_mask.vht_cap_info &\n\t    cpu_to_le32(IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK)) {\n\t\tu32 cap, n;\n\n\t\tn = le32_to_cpu(sdata->u.mgd.vht_capa.vht_cap_info) &\n\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\n\t\tn >>= IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;\n\t\tcap = vht_cap->cap & IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\n\t\tcap >>= IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;\n\n\t\tif (n < cap) {\n\t\t\tvht_cap->cap &=\n\t\t\t\t~IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;\n\t\t\tvht_cap->cap |=\n\t\t\t\tn << IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;\n\t\t}\n\t}\n\n\t \n\trxmcs_mask =\n\t\tle16_to_cpu(sdata->u.mgd.vht_capa_mask.supp_mcs.rx_mcs_map);\n\trxmcs_n = le16_to_cpu(sdata->u.mgd.vht_capa.supp_mcs.rx_mcs_map);\n\trxmcs_n &= rxmcs_mask;\n\trxmcs_cap = le16_to_cpu(vht_cap->vht_mcs.rx_mcs_map);\n\n\ttxmcs_mask =\n\t\tle16_to_cpu(sdata->u.mgd.vht_capa_mask.supp_mcs.tx_mcs_map);\n\ttxmcs_n = le16_to_cpu(sdata->u.mgd.vht_capa.supp_mcs.tx_mcs_map);\n\ttxmcs_n &= txmcs_mask;\n\ttxmcs_cap = le16_to_cpu(vht_cap->vht_mcs.tx_mcs_map);\n\tfor (i = 0; i < 8; i++) {\n\t\tu8 m, n, c;\n\n\t\tm = (rxmcs_mask >> 2*i) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\t\tn = (rxmcs_n >> 2*i) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\t\tc = (rxmcs_cap >> 2*i) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\n\t\tif (m && ((c != IEEE80211_VHT_MCS_NOT_SUPPORTED && n < c) ||\n\t\t\t  n == IEEE80211_VHT_MCS_NOT_SUPPORTED)) {\n\t\t\trxmcs_cap &= ~(3 << 2*i);\n\t\t\trxmcs_cap |= (rxmcs_n & (3 << 2*i));\n\t\t}\n\n\t\tm = (txmcs_mask >> 2*i) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\t\tn = (txmcs_n >> 2*i) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\t\tc = (txmcs_cap >> 2*i) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\n\t\tif (m && ((c != IEEE80211_VHT_MCS_NOT_SUPPORTED && n < c) ||\n\t\t\t  n == IEEE80211_VHT_MCS_NOT_SUPPORTED)) {\n\t\t\ttxmcs_cap &= ~(3 << 2*i);\n\t\t\ttxmcs_cap |= (txmcs_n & (3 << 2*i));\n\t\t}\n\t}\n\tvht_cap->vht_mcs.rx_mcs_map = cpu_to_le16(rxmcs_cap);\n\tvht_cap->vht_mcs.tx_mcs_map = cpu_to_le16(txmcs_cap);\n}\n\nvoid\nieee80211_vht_cap_ie_to_sta_vht_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t\t    const struct ieee80211_vht_cap *vht_cap_ie,\n\t\t\t\t    const struct ieee80211_vht_cap *vht_cap_ie2,\n\t\t\t\t    struct link_sta_info *link_sta)\n{\n\tstruct ieee80211_sta_vht_cap *vht_cap = &link_sta->pub->vht_cap;\n\tstruct ieee80211_sta_vht_cap own_cap;\n\tu32 cap_info, i;\n\tbool have_80mhz;\n\tu32 mpdu_len;\n\n\tmemset(vht_cap, 0, sizeof(*vht_cap));\n\n\tif (!link_sta->pub->ht_cap.ht_supported)\n\t\treturn;\n\n\tif (!vht_cap_ie || !sband->vht_cap.vht_supported)\n\t\treturn;\n\n\t \n\thave_80mhz = false;\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tif (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |\n\t\t\t\t\t\tIEEE80211_CHAN_NO_80MHZ))\n\t\t\tcontinue;\n\n\t\thave_80mhz = true;\n\t\tbreak;\n\t}\n\n\tif (!have_80mhz)\n\t\treturn;\n\n\t \n\n\tvht_cap->vht_supported = true;\n\n\town_cap = sband->vht_cap;\n\t \n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    !test_sta_flag(link_sta->sta, WLAN_STA_TDLS_PEER))\n\t\tieee80211_apply_vhtcap_overrides(sdata, &own_cap);\n\n\t \n\tcap_info = le32_to_cpu(vht_cap_ie->vht_cap_info);\n\tvht_cap->cap = cap_info;\n\tvht_cap->cap &= IEEE80211_VHT_CAP_RXLDPC |\n\t\t\tIEEE80211_VHT_CAP_VHT_TXOP_PS |\n\t\t\tIEEE80211_VHT_CAP_HTC_VHT |\n\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK |\n\t\t\tIEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_UNSOL_MFB |\n\t\t\tIEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB |\n\t\t\tIEEE80211_VHT_CAP_RX_ANTENNA_PATTERN |\n\t\t\tIEEE80211_VHT_CAP_TX_ANTENNA_PATTERN;\n\n\tvht_cap->cap |= min_t(u32, cap_info & IEEE80211_VHT_CAP_MAX_MPDU_MASK,\n\t\t\t      own_cap.cap & IEEE80211_VHT_CAP_MAX_MPDU_MASK);\n\n\t \n\tswitch (own_cap.cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {\n\tcase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ:\n\t\tvht_cap->cap |= cap_info &\n\t\t\t\tIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;\n\t\tbreak;\n\tcase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ:\n\t\tvht_cap->cap |= cap_info &\n\t\t\t\tIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tvht_cap->cap |= cap_info & own_cap.cap &\n\t\t\t(IEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t\t IEEE80211_VHT_CAP_SHORT_GI_160);\n\n\t \n\tif (own_cap.cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE)\n\t\tvht_cap->cap |= cap_info &\n\t\t\t\t(IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t\t\t\t IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK);\n\n\tif (own_cap.cap & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)\n\t\tvht_cap->cap |= cap_info &\n\t\t\t\t(IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\t\t\t IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK);\n\n\tif (own_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)\n\t\tvht_cap->cap |= cap_info &\n\t\t\t\tIEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;\n\n\tif (own_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE)\n\t\tvht_cap->cap |= cap_info &\n\t\t\t\tIEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE;\n\n\tif (own_cap.cap & IEEE80211_VHT_CAP_TXSTBC)\n\t\tvht_cap->cap |= cap_info & IEEE80211_VHT_CAP_RXSTBC_MASK;\n\n\tif (own_cap.cap & IEEE80211_VHT_CAP_RXSTBC_MASK)\n\t\tvht_cap->cap |= cap_info & IEEE80211_VHT_CAP_TXSTBC;\n\n\t \n\tmemcpy(&vht_cap->vht_mcs, &vht_cap_ie->supp_mcs,\n\t       sizeof(struct ieee80211_vht_mcs_info));\n\n\t \n\tif (ieee80211_hw_check(&sdata->local->hw, SUPPORTS_VHT_EXT_NSS_BW))\n\t\tvht_cap->cap |= (cap_info & IEEE80211_VHT_CAP_EXT_NSS_BW_MASK);\n\telse\n\t\tvht_cap->vht_mcs.tx_highest &=\n\t\t\t~cpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE);\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tu16 own_rx, own_tx, peer_rx, peer_tx;\n\n\t\town_rx = le16_to_cpu(own_cap.vht_mcs.rx_mcs_map);\n\t\town_rx = (own_rx >> i * 2) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\n\t\town_tx = le16_to_cpu(own_cap.vht_mcs.tx_mcs_map);\n\t\town_tx = (own_tx >> i * 2) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\n\t\tpeer_rx = le16_to_cpu(vht_cap->vht_mcs.rx_mcs_map);\n\t\tpeer_rx = (peer_rx >> i * 2) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\n\t\tpeer_tx = le16_to_cpu(vht_cap->vht_mcs.tx_mcs_map);\n\t\tpeer_tx = (peer_tx >> i * 2) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\n\t\tif (peer_tx != IEEE80211_VHT_MCS_NOT_SUPPORTED) {\n\t\t\tif (own_rx == IEEE80211_VHT_MCS_NOT_SUPPORTED)\n\t\t\t\tpeer_tx = IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\t\t\telse if (own_rx < peer_tx)\n\t\t\t\tpeer_tx = own_rx;\n\t\t}\n\n\t\tif (peer_rx != IEEE80211_VHT_MCS_NOT_SUPPORTED) {\n\t\t\tif (own_tx == IEEE80211_VHT_MCS_NOT_SUPPORTED)\n\t\t\t\tpeer_rx = IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\t\t\telse if (own_tx < peer_rx)\n\t\t\t\tpeer_rx = own_tx;\n\t\t}\n\n\t\tvht_cap->vht_mcs.rx_mcs_map &=\n\t\t\t~cpu_to_le16(IEEE80211_VHT_MCS_NOT_SUPPORTED << i * 2);\n\t\tvht_cap->vht_mcs.rx_mcs_map |= cpu_to_le16(peer_rx << i * 2);\n\n\t\tvht_cap->vht_mcs.tx_mcs_map &=\n\t\t\t~cpu_to_le16(IEEE80211_VHT_MCS_NOT_SUPPORTED << i * 2);\n\t\tvht_cap->vht_mcs.tx_mcs_map |= cpu_to_le16(peer_tx << i * 2);\n\t}\n\n\t \n\tif (vht_cap->vht_mcs.rx_mcs_map == cpu_to_le16(0xFFFF)) {\n\t\tvht_cap->vht_supported = false;\n\t\tsdata_info(sdata,\n\t\t\t   \"Ignoring VHT IE from %pM (link:%pM) due to invalid rx_mcs_map\\n\",\n\t\t\t   link_sta->sta->addr, link_sta->addr);\n\t\treturn;\n\t}\n\n\t \n\tswitch (vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {\n\tcase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ:\n\tcase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ:\n\t\tlink_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;\n\t\tbreak;\n\tdefault:\n\t\tlink_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_80;\n\n\t\tif (!(vht_cap->vht_mcs.tx_highest &\n\t\t\t\tcpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE)))\n\t\t\tbreak;\n\n\t\t \n\t\tif (cap_info & IEEE80211_VHT_CAP_EXT_NSS_BW_MASK)\n\t\t\tlink_sta->cur_max_bandwidth =\n\t\t\t\tIEEE80211_STA_RX_BW_160;\n\t}\n\n\tlink_sta->pub->bandwidth = ieee80211_sta_cur_vht_bw(link_sta);\n\n\t \n\tmpdu_len = vht_cap->cap & IEEE80211_VHT_CAP_MAX_MPDU_MASK;\n\tif (vht_cap_ie2)\n\t\tmpdu_len = min_t(u32, mpdu_len,\n\t\t\t\t le32_get_bits(vht_cap_ie2->vht_cap_info,\n\t\t\t\t\t       IEEE80211_VHT_CAP_MAX_MPDU_MASK));\n\n\t \n\tswitch (mpdu_len) {\n\tcase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454:\n\t\tlink_sta->pub->agg.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_VHT_11454;\n\t\tbreak;\n\tcase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991:\n\t\tlink_sta->pub->agg.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_VHT_7991;\n\t\tbreak;\n\tcase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895:\n\tdefault:\n\t\tlink_sta->pub->agg.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_VHT_3895;\n\t\tbreak;\n\t}\n\n\tieee80211_sta_recalc_aggregates(&link_sta->sta->sta);\n}\n\n \nenum ieee80211_sta_rx_bandwidth\nieee80211_sta_cap_rx_bw(struct link_sta_info *link_sta)\n{\n\tunsigned int link_id = link_sta->link_id;\n\tstruct ieee80211_sub_if_data *sdata = link_sta->sta->sdata;\n\tstruct ieee80211_sta_vht_cap *vht_cap = &link_sta->pub->vht_cap;\n\tstruct ieee80211_sta_he_cap *he_cap = &link_sta->pub->he_cap;\n\tstruct ieee80211_sta_eht_cap *eht_cap = &link_sta->pub->eht_cap;\n\tu32 cap_width;\n\n\tif (he_cap->has_he) {\n\t\tstruct ieee80211_bss_conf *link_conf;\n\t\tenum ieee80211_sta_rx_bandwidth ret;\n\t\tu8 info;\n\n\t\trcu_read_lock();\n\t\tlink_conf = rcu_dereference(sdata->vif.link_conf[link_id]);\n\n\t\tif (eht_cap->has_eht &&\n\t\t    link_conf->chandef.chan->band == NL80211_BAND_6GHZ) {\n\t\t\tinfo = eht_cap->eht_cap_elem.phy_cap_info[0];\n\n\t\t\tif (info & IEEE80211_EHT_PHY_CAP0_320MHZ_IN_6GHZ) {\n\t\t\t\tret = IEEE80211_STA_RX_BW_320;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tinfo = he_cap->he_cap_elem.phy_cap_info[0];\n\n\t\tif (link_conf->chandef.chan->band == NL80211_BAND_2GHZ) {\n\t\t\tif (info & IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G)\n\t\t\t\tret = IEEE80211_STA_RX_BW_40;\n\t\t\telse\n\t\t\t\tret = IEEE80211_STA_RX_BW_20;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (info & IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G ||\n\t\t    info & IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)\n\t\t\tret = IEEE80211_STA_RX_BW_160;\n\t\telse if (info & IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G)\n\t\t\tret = IEEE80211_STA_RX_BW_80;\n\t\telse\n\t\t\tret = IEEE80211_STA_RX_BW_20;\nout:\n\t\trcu_read_unlock();\n\n\t\treturn ret;\n\t}\n\n\tif (!vht_cap->vht_supported)\n\t\treturn link_sta->pub->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?\n\t\t\t\tIEEE80211_STA_RX_BW_40 :\n\t\t\t\tIEEE80211_STA_RX_BW_20;\n\n\tcap_width = vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;\n\n\tif (cap_width == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ ||\n\t    cap_width == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ)\n\t\treturn IEEE80211_STA_RX_BW_160;\n\n\t \n\tif (vht_cap->cap & IEEE80211_VHT_CAP_EXT_NSS_BW_MASK)\n\t\treturn IEEE80211_STA_RX_BW_160;\n\n\treturn IEEE80211_STA_RX_BW_80;\n}\n\nenum nl80211_chan_width\nieee80211_sta_cap_chan_bw(struct link_sta_info *link_sta)\n{\n\tstruct ieee80211_sta_vht_cap *vht_cap = &link_sta->pub->vht_cap;\n\tu32 cap_width;\n\n\tif (!vht_cap->vht_supported) {\n\t\tif (!link_sta->pub->ht_cap.ht_supported)\n\t\t\treturn NL80211_CHAN_WIDTH_20_NOHT;\n\n\t\treturn link_sta->pub->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?\n\t\t\t\tNL80211_CHAN_WIDTH_40 : NL80211_CHAN_WIDTH_20;\n\t}\n\n\tcap_width = vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;\n\n\tif (cap_width == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ)\n\t\treturn NL80211_CHAN_WIDTH_160;\n\telse if (cap_width == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ)\n\t\treturn NL80211_CHAN_WIDTH_80P80;\n\n\treturn NL80211_CHAN_WIDTH_80;\n}\n\nenum nl80211_chan_width\nieee80211_sta_rx_bw_to_chan_width(struct link_sta_info *link_sta)\n{\n\tenum ieee80211_sta_rx_bandwidth cur_bw =\n\t\tlink_sta->pub->bandwidth;\n\tstruct ieee80211_sta_vht_cap *vht_cap =\n\t\t&link_sta->pub->vht_cap;\n\tu32 cap_width;\n\n\tswitch (cur_bw) {\n\tcase IEEE80211_STA_RX_BW_20:\n\t\tif (!link_sta->pub->ht_cap.ht_supported)\n\t\t\treturn NL80211_CHAN_WIDTH_20_NOHT;\n\t\telse\n\t\t\treturn NL80211_CHAN_WIDTH_20;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\treturn NL80211_CHAN_WIDTH_40;\n\tcase IEEE80211_STA_RX_BW_80:\n\t\treturn NL80211_CHAN_WIDTH_80;\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tcap_width =\n\t\t\tvht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;\n\n\t\tif (cap_width == IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ)\n\t\t\treturn NL80211_CHAN_WIDTH_160;\n\n\t\treturn NL80211_CHAN_WIDTH_80P80;\n\tdefault:\n\t\treturn NL80211_CHAN_WIDTH_20;\n\t}\n}\n\nenum ieee80211_sta_rx_bandwidth\nieee80211_chan_width_to_rx_bw(enum nl80211_chan_width width)\n{\n\tswitch (width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\t\treturn IEEE80211_STA_RX_BW_20;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\treturn IEEE80211_STA_RX_BW_40;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\treturn IEEE80211_STA_RX_BW_80;\n\tcase NL80211_CHAN_WIDTH_160:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\treturn IEEE80211_STA_RX_BW_160;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\treturn IEEE80211_STA_RX_BW_320;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn IEEE80211_STA_RX_BW_20;\n\t}\n}\n\n \nenum ieee80211_sta_rx_bandwidth\nieee80211_sta_cur_vht_bw(struct link_sta_info *link_sta)\n{\n\tstruct sta_info *sta = link_sta->sta;\n\tstruct ieee80211_bss_conf *link_conf;\n\tenum nl80211_chan_width bss_width;\n\tenum ieee80211_sta_rx_bandwidth bw;\n\n\trcu_read_lock();\n\tlink_conf = rcu_dereference(sta->sdata->vif.link_conf[link_sta->link_id]);\n\tif (WARN_ON(!link_conf))\n\t\tbss_width = NL80211_CHAN_WIDTH_20_NOHT;\n\telse\n\t\tbss_width = link_conf->chandef.width;\n\trcu_read_unlock();\n\n\tbw = ieee80211_sta_cap_rx_bw(link_sta);\n\tbw = min(bw, link_sta->cur_max_bandwidth);\n\n\t \n\tif (test_sta_flag(sta, WLAN_STA_TDLS_PEER) &&\n\t    test_sta_flag(sta, WLAN_STA_TDLS_WIDER_BW) &&\n\t    test_sta_flag(sta, WLAN_STA_AUTHORIZED) &&\n\t    sta->tdls_chandef.chan)\n\t\tbw = min(bw, ieee80211_chan_width_to_rx_bw(sta->tdls_chandef.width));\n\telse\n\t\tbw = min(bw, ieee80211_chan_width_to_rx_bw(bss_width));\n\n\treturn bw;\n}\n\nvoid ieee80211_sta_set_rx_nss(struct link_sta_info *link_sta)\n{\n\tu8 ht_rx_nss = 0, vht_rx_nss = 0, he_rx_nss = 0, eht_rx_nss = 0, rx_nss;\n\tbool support_160;\n\n\t \n\tif (link_sta->pub->rx_nss)\n\t\treturn;\n\n\tif (link_sta->pub->eht_cap.has_eht) {\n\t\tint i;\n\t\tconst u8 *rx_nss_mcs = (void *)&link_sta->pub->eht_cap.eht_mcs_nss_supp;\n\n\t\t \n\t\tfor (i = 0; i < sizeof(struct ieee80211_eht_mcs_nss_supp); i++)\n\t\t\teht_rx_nss = max_t(u8, eht_rx_nss,\n\t\t\t\t\t   u8_get_bits(rx_nss_mcs[i],\n\t\t\t\t\t\t       IEEE80211_EHT_MCS_NSS_RX));\n\t}\n\n\tif (link_sta->pub->he_cap.has_he) {\n\t\tint i;\n\t\tu8 rx_mcs_80 = 0, rx_mcs_160 = 0;\n\t\tconst struct ieee80211_sta_he_cap *he_cap = &link_sta->pub->he_cap;\n\t\tu16 mcs_160_map =\n\t\t\tle16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_160);\n\t\tu16 mcs_80_map = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_80);\n\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tu8 mcs_160 = (mcs_160_map >> (2 * i)) & 3;\n\n\t\t\tif (mcs_160 != IEEE80211_HE_MCS_NOT_SUPPORTED) {\n\t\t\t\trx_mcs_160 = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tu8 mcs_80 = (mcs_80_map >> (2 * i)) & 3;\n\n\t\t\tif (mcs_80 != IEEE80211_HE_MCS_NOT_SUPPORTED) {\n\t\t\t\trx_mcs_80 = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tsupport_160 = he_cap->he_cap_elem.phy_cap_info[0] &\n\t\t\t      IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;\n\n\t\tif (support_160)\n\t\t\the_rx_nss = min(rx_mcs_80, rx_mcs_160);\n\t\telse\n\t\t\the_rx_nss = rx_mcs_80;\n\t}\n\n\tif (link_sta->pub->ht_cap.ht_supported) {\n\t\tif (link_sta->pub->ht_cap.mcs.rx_mask[0])\n\t\t\tht_rx_nss++;\n\t\tif (link_sta->pub->ht_cap.mcs.rx_mask[1])\n\t\t\tht_rx_nss++;\n\t\tif (link_sta->pub->ht_cap.mcs.rx_mask[2])\n\t\t\tht_rx_nss++;\n\t\tif (link_sta->pub->ht_cap.mcs.rx_mask[3])\n\t\t\tht_rx_nss++;\n\t\t \n\t}\n\n\tif (link_sta->pub->vht_cap.vht_supported) {\n\t\tint i;\n\t\tu16 rx_mcs_map;\n\n\t\trx_mcs_map = le16_to_cpu(link_sta->pub->vht_cap.vht_mcs.rx_mcs_map);\n\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tu8 mcs = (rx_mcs_map >> (2 * i)) & 3;\n\n\t\t\tif (mcs != IEEE80211_VHT_MCS_NOT_SUPPORTED) {\n\t\t\t\tvht_rx_nss = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t}\n\n\trx_nss = max(vht_rx_nss, ht_rx_nss);\n\trx_nss = max(he_rx_nss, rx_nss);\n\trx_nss = max(eht_rx_nss, rx_nss);\n\tlink_sta->pub->rx_nss = max_t(u8, 1, rx_nss);\n}\n\nu32 __ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct link_sta_info *link_sta,\n\t\t\t\t  u8 opmode, enum nl80211_band band)\n{\n\tenum ieee80211_sta_rx_bandwidth new_bw;\n\tstruct sta_opmode_info sta_opmode = {};\n\tu32 changed = 0;\n\tu8 nss, cur_nss;\n\n\t \n\tif (opmode & IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF)\n\t\treturn 0;\n\n\tnss = opmode & IEEE80211_OPMODE_NOTIF_RX_NSS_MASK;\n\tnss >>= IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;\n\tnss += 1;\n\n\tif (link_sta->pub->rx_nss != nss) {\n\t\tcur_nss = link_sta->pub->rx_nss;\n\t\t \n\t\tlink_sta->pub->rx_nss = 0;\n\t\tieee80211_sta_set_rx_nss(link_sta);\n\t\t \n\t\tif (nss <= link_sta->pub->rx_nss) {\n\t\t\tlink_sta->pub->rx_nss = nss;\n\t\t\tsta_opmode.rx_nss = nss;\n\t\t\tchanged |= IEEE80211_RC_NSS_CHANGED;\n\t\t\tsta_opmode.changed |= STA_OPMODE_N_SS_CHANGED;\n\t\t} else {\n\t\t\tlink_sta->pub->rx_nss = cur_nss;\n\t\t\tpr_warn_ratelimited(\"Ignoring NSS change in VHT Operating Mode Notification from %pM with invalid nss %d\",\n\t\t\t\t\t    link_sta->pub->addr, nss);\n\t\t}\n\t}\n\n\tswitch (opmode & IEEE80211_OPMODE_NOTIF_CHANWIDTH_MASK) {\n\tcase IEEE80211_OPMODE_NOTIF_CHANWIDTH_20MHZ:\n\t\t \n\t\tlink_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_20;\n\t\tbreak;\n\tcase IEEE80211_OPMODE_NOTIF_CHANWIDTH_40MHZ:\n\t\t \n\t\tlink_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_40;\n\t\tbreak;\n\tcase IEEE80211_OPMODE_NOTIF_CHANWIDTH_80MHZ:\n\t\tif (opmode & IEEE80211_OPMODE_NOTIF_BW_160_80P80)\n\t\t\tlink_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;\n\t\telse\n\t\t\tlink_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_80;\n\t\tbreak;\n\tcase IEEE80211_OPMODE_NOTIF_CHANWIDTH_160MHZ:\n\t\t \n\t\tlink_sta->cur_max_bandwidth = IEEE80211_STA_RX_BW_160;\n\t\tbreak;\n\t}\n\n\tnew_bw = ieee80211_sta_cur_vht_bw(link_sta);\n\tif (new_bw != link_sta->pub->bandwidth) {\n\t\tlink_sta->pub->bandwidth = new_bw;\n\t\tsta_opmode.bw = ieee80211_sta_rx_bw_to_chan_width(link_sta);\n\t\tchanged |= IEEE80211_RC_BW_CHANGED;\n\t\tsta_opmode.changed |= STA_OPMODE_MAX_BW_CHANGED;\n\t}\n\n\tif (sta_opmode.changed)\n\t\tcfg80211_sta_opmode_change_notify(sdata->dev, link_sta->addr,\n\t\t\t\t\t\t  &sta_opmode, GFP_KERNEL);\n\n\treturn changed;\n}\n\nvoid ieee80211_process_mu_groups(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct ieee80211_link_data *link,\n\t\t\t\t struct ieee80211_mgmt *mgmt)\n{\n\tstruct ieee80211_bss_conf *link_conf = link->conf;\n\n\tif (!link_conf->mu_mimo_owner)\n\t\treturn;\n\n\tif (!memcmp(mgmt->u.action.u.vht_group_notif.position,\n\t\t    link_conf->mu_group.position, WLAN_USER_POSITION_LEN) &&\n\t    !memcmp(mgmt->u.action.u.vht_group_notif.membership,\n\t\t    link_conf->mu_group.membership, WLAN_MEMBERSHIP_LEN))\n\t\treturn;\n\n\tmemcpy(link_conf->mu_group.membership,\n\t       mgmt->u.action.u.vht_group_notif.membership,\n\t       WLAN_MEMBERSHIP_LEN);\n\tmemcpy(link_conf->mu_group.position,\n\t       mgmt->u.action.u.vht_group_notif.position,\n\t       WLAN_USER_POSITION_LEN);\n\n\tieee80211_link_info_change_notify(sdata, link,\n\t\t\t\t\t  BSS_CHANGED_MU_GROUPS);\n}\n\nvoid ieee80211_update_mu_groups(struct ieee80211_vif *vif, unsigned int link_id,\n\t\t\t\tconst u8 *membership, const u8 *position)\n{\n\tstruct ieee80211_bss_conf *link_conf;\n\n\trcu_read_lock();\n\tlink_conf = rcu_dereference(vif->link_conf[link_id]);\n\n\tif (!WARN_ON_ONCE(!link_conf || !link_conf->mu_mimo_owner)) {\n\t\tmemcpy(link_conf->mu_group.membership, membership,\n\t\t       WLAN_MEMBERSHIP_LEN);\n\t\tmemcpy(link_conf->mu_group.position, position,\n\t\t       WLAN_USER_POSITION_LEN);\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(ieee80211_update_mu_groups);\n\nvoid ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct link_sta_info *link_sta,\n\t\t\t\t u8 opmode, enum nl80211_band band)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_supported_band *sband = local->hw.wiphy->bands[band];\n\n\tu32 changed = __ieee80211_vht_handle_opmode(sdata, link_sta,\n\t\t\t\t\t\t    opmode, band);\n\n\tif (changed > 0) {\n\t\tieee80211_recalc_min_chandef(sdata, link_sta->link_id);\n\t\trate_control_rate_update(local, sband, link_sta->sta,\n\t\t\t\t\t link_sta->link_id, changed);\n\t}\n}\n\nvoid ieee80211_get_vht_mask_from_cap(__le16 vht_cap,\n\t\t\t\t     u16 vht_mask[NL80211_VHT_NSS_MAX])\n{\n\tint i;\n\tu16 mask, cap = le16_to_cpu(vht_cap);\n\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tmask = (cap >> i * 2) & IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\t\tswitch (mask) {\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_7:\n\t\t\tvht_mask[i] = 0x00FF;\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_8:\n\t\t\tvht_mask[i] = 0x01FF;\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_9:\n\t\t\tvht_mask[i] = 0x03FF;\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_MCS_NOT_SUPPORTED:\n\t\tdefault:\n\t\t\tvht_mask[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}