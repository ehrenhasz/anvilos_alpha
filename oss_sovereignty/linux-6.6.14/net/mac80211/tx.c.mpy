{
  "module_name": "tx.c",
  "hash_id": "0f13f518cbc9a0989b51227d9345d51b923500b8b1ff3c7b17f290a1068c9e80",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/tx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/if_vlan.h>\n#include <linux/etherdevice.h>\n#include <linux/bitmap.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <net/net_namespace.h>\n#include <net/ieee80211_radiotap.h>\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include <net/codel.h>\n#include <net/codel_impl.h>\n#include <asm/unaligned.h>\n#include <net/fq_impl.h>\n#include <net/gso.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"led.h\"\n#include \"mesh.h\"\n#include \"wep.h\"\n#include \"wpa.h\"\n#include \"wme.h\"\n#include \"rate.h\"\n\n \n\nstatic __le16 ieee80211_duration(struct ieee80211_tx_data *tx,\n\t\t\t\t struct sk_buff *skb, int group_addr,\n\t\t\t\t int next_frag_len)\n{\n\tint rate, mrate, erp, dur, i, shift = 0;\n\tstruct ieee80211_rate *txrate;\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tu32 rate_flags = 0;\n\n\t \n\tif (tx->rate.flags & (IEEE80211_TX_RC_MCS | IEEE80211_TX_RC_VHT_MCS))\n\t\treturn 0;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(tx->sdata->vif.bss_conf.chanctx_conf);\n\tif (chanctx_conf) {\n\t\tshift = ieee80211_chandef_get_shift(&chanctx_conf->def);\n\t\trate_flags = ieee80211_chandef_rate_flags(&chanctx_conf->def);\n\t}\n\trcu_read_unlock();\n\n\t \n\tif (WARN_ON_ONCE(tx->rate.idx < 0))\n\t\treturn 0;\n\n\tsband = local->hw.wiphy->bands[info->band];\n\ttxrate = &sband->bitrates[tx->rate.idx];\n\n\terp = txrate->flags & IEEE80211_RATE_ERP_G;\n\n\t \n\tif (sband->band == NL80211_BAND_S1GHZ)\n\t\treturn 0;\n\n\t \n\thdr = (struct ieee80211_hdr *)skb->data;\n\tif (ieee80211_is_ctl(hdr->frame_control)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (0  )\n\t\treturn cpu_to_le16(32768);\n\n\tif (group_addr)  \n\t\treturn 0;\n\n\t \n\trate = -1;\n\t \n\tmrate = sband->bitrates[0].bitrate;\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tstruct ieee80211_rate *r = &sband->bitrates[i];\n\n\t\tif (r->bitrate > txrate->bitrate)\n\t\t\tbreak;\n\n\t\tif ((rate_flags & r->flags) != rate_flags)\n\t\t\tcontinue;\n\n\t\tif (tx->sdata->vif.bss_conf.basic_rates & BIT(i))\n\t\t\trate = DIV_ROUND_UP(r->bitrate, 1 << shift);\n\n\t\tswitch (sband->band) {\n\t\tcase NL80211_BAND_2GHZ:\n\t\tcase NL80211_BAND_LC: {\n\t\t\tu32 flag;\n\t\t\tif (tx->sdata->deflink.operating_11g_mode)\n\t\t\t\tflag = IEEE80211_RATE_MANDATORY_G;\n\t\t\telse\n\t\t\t\tflag = IEEE80211_RATE_MANDATORY_B;\n\t\t\tif (r->flags & flag)\n\t\t\t\tmrate = r->bitrate;\n\t\t\tbreak;\n\t\t}\n\t\tcase NL80211_BAND_5GHZ:\n\t\tcase NL80211_BAND_6GHZ:\n\t\t\tif (r->flags & IEEE80211_RATE_MANDATORY_A)\n\t\t\t\tmrate = r->bitrate;\n\t\t\tbreak;\n\t\tcase NL80211_BAND_S1GHZ:\n\t\tcase NL80211_BAND_60GHZ:\n\t\t\t \n\t\tcase NUM_NL80211_BANDS:\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rate == -1) {\n\t\t \n\t\trate = DIV_ROUND_UP(mrate, 1 << shift);\n\t}\n\n\t \n\tif (ieee80211_is_data_qos(hdr->frame_control) &&\n\t    *(ieee80211_get_qos_ctl(hdr)) & IEEE80211_QOS_CTL_ACK_POLICY_NOACK)\n\t\tdur = 0;\n\telse\n\t\t \n\t\tdur = ieee80211_frame_duration(sband->band, 10, rate, erp,\n\t\t\t\ttx->sdata->vif.bss_conf.use_short_preamble,\n\t\t\t\tshift);\n\n\tif (next_frag_len) {\n\t\t \n\t\tdur *= 2;  \n\t\t \n\t\tdur += ieee80211_frame_duration(sband->band, next_frag_len,\n\t\t\t\ttxrate->bitrate, erp,\n\t\t\t\ttx->sdata->vif.bss_conf.use_short_preamble,\n\t\t\t\tshift);\n\t}\n\n\treturn cpu_to_le16(dur);\n}\n\n \nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_dynamic_ps(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_if_managed *ifmgd;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\n\t \n\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_PS))\n\t\treturn TX_CONTINUE;\n\n\t \n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS))\n\t\treturn TX_CONTINUE;\n\n\t \n\tif (local->hw.conf.dynamic_ps_timeout <= 0)\n\t\treturn TX_CONTINUE;\n\n\t \n\tif (local->scanning)\n\t\treturn TX_CONTINUE;\n\n\tif (!local->ps_sdata)\n\t\treturn TX_CONTINUE;\n\n\t \n\tif (local->quiescing)\n\t\treturn TX_CONTINUE;\n\n\t \n\tif (tx->sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_OFFCHAN_TX_OK))\n\t\treturn TX_CONTINUE;\n\n\tifmgd = &tx->sdata->u.mgd;\n\n\t \n\tif ((ifmgd->flags & IEEE80211_STA_UAPSD_ENABLED) &&\n\t    (ifmgd->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO) &&\n\t    skb_get_queue_mapping(tx->skb) == IEEE80211_AC_VO)\n\t\treturn TX_CONTINUE;\n\n\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\tieee80211_stop_queues_by_reason(&local->hw,\n\t\t\t\t\t\tIEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_PS,\n\t\t\t\t\t\tfalse);\n\t\tifmgd->flags &= ~IEEE80211_STA_NULLFUNC_ACKED;\n\t\tieee80211_queue_work(&local->hw,\n\t\t\t\t     &local->dynamic_ps_disable_work);\n\t}\n\n\t \n\tif (!ifmgd->associated)\n\t\treturn TX_CONTINUE;\n\n\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t  msecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)\n{\n\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tbool assoc = false;\n\n\tif (unlikely(info->flags & IEEE80211_TX_CTL_INJECTED))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(test_bit(SCAN_SW_SCANNING, &tx->local->scanning)) &&\n\t    test_bit(SDATA_STATE_OFFCHANNEL, &tx->sdata->state) &&\n\t    !ieee80211_is_probe_req(hdr->frame_control) &&\n\t    !ieee80211_is_any_nullfunc(hdr->frame_control))\n\t\t \n\t\treturn TX_DROP;\n\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_OCB)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->flags & IEEE80211_TX_PS_BUFFERED)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\n\tif (likely(tx->flags & IEEE80211_TX_UNICAST)) {\n\t\tif (unlikely(!assoc &&\n\t\t\t     ieee80211_is_data(hdr->frame_control))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\t\tsdata_info(tx->sdata,\n\t\t\t\t   \"dropped data frame to not associated station %pM\\n\",\n\t\t\t\t   hdr->addr1);\n#endif\n\t\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop_not_assoc);\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else if (unlikely(ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    ieee80211_vif_get_num_mcast_if(tx->sdata) == 0)) {\n\t\t \n\t\treturn TX_DROP;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\n \nstatic void purge_old_ps_buffers(struct ieee80211_local *local)\n{\n\tint total = 0, purged = 0;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tstruct ps_data *ps;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tps = &sdata->u.ap.ps;\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tps = &sdata->u.mesh.ps;\n\t\telse\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (skb) {\n\t\t\tpurged++;\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t}\n\t\ttotal += skb_queue_len(&ps->bc_buf);\n\t}\n\n\t \n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tint ac;\n\n\t\tfor (ac = IEEE80211_AC_BK; ac >= IEEE80211_AC_VO; ac--) {\n\t\t\tskb = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\ttotal += skb_queue_len(&sta->ps_tx_buf[ac]);\n\t\t\tif (skb) {\n\t\t\t\tpurged++;\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlocal->total_ps_buffered = total;\n\tps_dbg_hw(&local->hw, \"PS buffers full - purged %d frames\\n\", purged);\n}\n\nstatic ieee80211_tx_result\nieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ps_data *ps;\n\n\t \n\n\t \n\tif (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    tx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (!tx->sdata->bss)\n\t\t\treturn TX_CONTINUE;\n\n\t\tps = &tx->sdata->bss->ps;\n\t} else if (ieee80211_vif_is_mesh(&tx->sdata->vif)) {\n\t\tps = &tx->sdata->u.mesh.ps;\n\t} else {\n\t\treturn TX_CONTINUE;\n\t}\n\n\n\t \n\tif (ieee80211_has_order(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_is_probe_req(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_hw_check(&tx->local->hw, QUEUE_CONTROL))\n\t\tinfo->hw_queue = tx->sdata->vif.cab_queue;\n\n\t \n\tif (!atomic_read(&ps->num_sta_ps) && skb_queue_empty(&ps->bc_buf))\n\t\treturn TX_CONTINUE;\n\n\tinfo->flags |= IEEE80211_TX_CTL_SEND_AFTER_DTIM;\n\n\t \n\tif (!ieee80211_hw_check(&tx->local->hw, HOST_BROADCAST_PS_BUFFERING))\n\t\treturn TX_CONTINUE;\n\n\t \n\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\tpurge_old_ps_buffers(tx->local);\n\n\tif (skb_queue_len(&ps->bc_buf) >= AP_MAX_BC_BUFFER) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"BC TX buffer full - dropping the oldest frame\\n\");\n\t\tieee80211_free_txskb(&tx->local->hw, skb_dequeue(&ps->bc_buf));\n\t} else\n\t\ttx->local->total_ps_buffered++;\n\n\tskb_queue_tail(&ps->bc_buf, tx->skb);\n\n\treturn TX_QUEUED;\n}\n\nstatic int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,\n\t\t\t     struct sk_buff *skb)\n{\n\tif (!ieee80211_is_mgmt(fc))\n\t\treturn 0;\n\n\tif (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))\n\t\treturn 0;\n\n\tif (!ieee80211_is_robust_mgmt_frame(skb))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic ieee80211_tx_result\nieee80211_tx_h_unicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct sta_info *sta = tx->sta;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_local *local = tx->local;\n\n\tif (unlikely(!sta))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t\t      test_sta_flag(sta, WLAN_STA_PS_DRIVER) ||\n\t\t      test_sta_flag(sta, WLAN_STA_PS_DELIVER)) &&\n\t\t     !(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER))) {\n\t\tint ac = skb_get_queue_mapping(tx->skb);\n\n\t\tif (ieee80211_is_mgmt(hdr->frame_control) &&\n\t\t    !ieee80211_is_bufferable_mmpdu(tx->skb)) {\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER;\n\t\t\treturn TX_CONTINUE;\n\t\t}\n\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d: PS buffer for AC %d\\n\",\n\t\t       sta->sta.addr, sta->sta.aid, ac);\n\t\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\t\tpurge_old_ps_buffers(tx->local);\n\n\t\t \n\t\tspin_lock(&sta->ps_lock);\n\t\t \n\t\tif (!test_sta_flag(sta, WLAN_STA_PS_STA) &&\n\t\t    !test_sta_flag(sta, WLAN_STA_PS_DRIVER) &&\n\t\t    !test_sta_flag(sta, WLAN_STA_PS_DELIVER)) {\n\t\t\tspin_unlock(&sta->ps_lock);\n\t\t\treturn TX_CONTINUE;\n\t\t}\n\n\t\tif (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {\n\t\t\tstruct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);\n\t\t\tps_dbg(tx->sdata,\n\t\t\t       \"STA %pM TX buffer for AC %d full - dropping oldest frame\\n\",\n\t\t\t       sta->sta.addr, ac);\n\t\t\tieee80211_free_txskb(&local->hw, old);\n\t\t} else\n\t\t\ttx->local->total_ps_buffered++;\n\n\t\tinfo->control.jiffies = jiffies;\n\t\tinfo->control.vif = &tx->sdata->vif;\n\t\tinfo->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\t\tskb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);\n\t\tspin_unlock(&sta->ps_lock);\n\n\t\tif (!timer_pending(&local->sta_cleanup))\n\t\t\tmod_timer(&local->sta_cleanup,\n\t\t\t\t  round_jiffies(jiffies +\n\t\t\t\t\t\tSTA_INFO_CLEANUP_INTERVAL));\n\n\t\t \n\t\tsta_info_recalc_tim(sta);\n\n\t\treturn TX_QUEUED;\n\t} else if (unlikely(test_sta_flag(sta, WLAN_STA_PS_STA))) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"STA %pM in PS mode, but polling/in SP -> send frame\\n\",\n\t\t       sta->sta.addr);\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tif (unlikely(tx->flags & IEEE80211_TX_PS_BUFFERED))\n\t\treturn TX_CONTINUE;\n\n\tif (tx->flags & IEEE80211_TX_UNICAST)\n\t\treturn ieee80211_tx_h_unicast_ps_buf(tx);\n\telse\n\t\treturn ieee80211_tx_h_multicast_ps_buf(tx);\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_check_control_port_protocol(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\n\tif (unlikely(tx->sdata->control_port_protocol == tx->skb->protocol)) {\n\t\tif (tx->sdata->control_port_no_encrypt)\n\t\t\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\tinfo->control.flags |= IEEE80211_TX_CTRL_PORT_CTRL_PROTO;\n\t\tinfo->flags |= IEEE80211_TX_CTL_USE_MINRATE;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic struct ieee80211_key *\nieee80211_select_link_key(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_link_data *link;\n\tunsigned int link_id;\n\n\tlink_id = u32_get_bits(info->control.flags, IEEE80211_TX_CTRL_MLO_LINK);\n\tif (link_id == IEEE80211_LINK_UNSPECIFIED) {\n\t\tlink = &tx->sdata->deflink;\n\t} else {\n\t\tlink = rcu_dereference(tx->sdata->link[link_id]);\n\t\tif (!link)\n\t\t\treturn NULL;\n\t}\n\n\tif (ieee80211_is_group_privacy_action(tx->skb))\n\t\treturn rcu_dereference(link->default_multicast_key);\n\telse if (ieee80211_is_mgmt(hdr->frame_control) &&\n\t\t is_multicast_ether_addr(hdr->addr1) &&\n\t\t ieee80211_is_robust_mgmt_frame(tx->skb))\n\t\treturn rcu_dereference(link->default_mgmt_key);\n\telse if (is_multicast_ether_addr(hdr->addr1))\n\t\treturn rcu_dereference(link->default_multicast_key);\n\n\treturn NULL;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_select_key(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_key *key;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)) {\n\t\ttx->key = NULL;\n\t\treturn TX_CONTINUE;\n\t}\n\n\tif (tx->sta &&\n\t    (key = rcu_dereference(tx->sta->ptk[tx->sta->ptk_idx])))\n\t\ttx->key = key;\n\telse if ((key = ieee80211_select_link_key(tx)))\n\t\ttx->key = key;\n\telse if (!is_multicast_ether_addr(hdr->addr1) &&\n\t\t (key = rcu_dereference(tx->sdata->default_unicast_key)))\n\t\ttx->key = key;\n\telse\n\t\ttx->key = NULL;\n\n\tif (tx->key) {\n\t\tbool skip_hw = false;\n\n\t\t \n\n\t\tswitch (tx->key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tif (!ieee80211_is_data_present(hdr->frame_control))\n\t\t\t\ttx->key = NULL;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tif (!ieee80211_is_data_present(hdr->frame_control) &&\n\t\t\t    !ieee80211_use_mfp(hdr->frame_control, tx->sta,\n\t\t\t\t\t       tx->skb) &&\n\t\t\t    !ieee80211_is_group_privacy_action(tx->skb))\n\t\t\t\ttx->key = NULL;\n\t\t\telse\n\t\t\t\tskip_hw = (tx->key->conf.flags &\n\t\t\t\t\t   IEEE80211_KEY_FLAG_SW_MGMT_TX) &&\n\t\t\t\t\tieee80211_is_mgmt(hdr->frame_control);\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\t\tif (!ieee80211_is_mgmt(hdr->frame_control))\n\t\t\t\ttx->key = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(tx->key && tx->key->flags & KEY_FLAG_TAINTED &&\n\t\t\t     !ieee80211_is_deauth(hdr->frame_control)) &&\n\t\t\t     tx->skb->protocol != tx->sdata->control_port_protocol)\n\t\t\treturn TX_DROP;\n\n\t\tif (!skip_hw && tx->key &&\n\t\t    tx->key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE)\n\t\t\tinfo->control.hw_key = &tx->key->conf;\n\t} else if (ieee80211_is_data_present(hdr->frame_control) && tx->sta &&\n\t\t   test_sta_flag(tx->sta, WLAN_STA_USES_ENCRYPTION)) {\n\t\treturn TX_DROP;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_rate_ctrl(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (void *)tx->skb->data;\n\tstruct ieee80211_supported_band *sband;\n\tu32 len;\n\tstruct ieee80211_tx_rate_control txrc;\n\tstruct ieee80211_sta_rates *ratetbl = NULL;\n\tbool encap = info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP;\n\tbool assoc = false;\n\n\tmemset(&txrc, 0, sizeof(txrc));\n\n\tsband = tx->local->hw.wiphy->bands[info->band];\n\n\tlen = min_t(u32, tx->skb->len + FCS_LEN,\n\t\t\t tx->local->hw.wiphy->frag_threshold);\n\n\t \n\ttxrc.hw = &tx->local->hw;\n\ttxrc.sband = sband;\n\ttxrc.bss_conf = &tx->sdata->vif.bss_conf;\n\ttxrc.skb = tx->skb;\n\ttxrc.reported_rate.idx = -1;\n\ttxrc.rate_idx_mask = tx->sdata->rc_rateidx_mask[info->band];\n\n\tif (tx->sdata->rc_has_mcs_mask[info->band])\n\t\ttxrc.rate_idx_mcs_mask =\n\t\t\ttx->sdata->rc_rateidx_mcs_mask[info->band];\n\n\ttxrc.bss = (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_ADHOC ||\n\t\t    tx->sdata->vif.type == NL80211_IFTYPE_OCB);\n\n\t \n\tif (len > tx->local->hw.wiphy->rts_threshold) {\n\t\ttxrc.rts = true;\n\t}\n\n\tinfo->control.use_rts = txrc.rts;\n\tinfo->control.use_cts_prot = tx->sdata->vif.bss_conf.use_cts_prot;\n\n\t \n\tif (tx->sdata->vif.bss_conf.use_short_preamble &&\n\t    (ieee80211_is_tx_data(tx->skb) ||\n\t     (tx->sta && test_sta_flag(tx->sta, WLAN_STA_SHORT_PREAMBLE))))\n\t\ttxrc.short_preamble = true;\n\n\tinfo->control.short_preamble = txrc.short_preamble;\n\n\t \n\tif (info->control.flags & IEEE80211_TX_CTRL_RATE_INJECT)\n\t\treturn TX_CONTINUE;\n\n\tif (tx->sta)\n\t\tassoc = test_sta_flag(tx->sta, WLAN_STA_ASSOC);\n\n\t \n\tif (WARN(test_bit(SCAN_SW_SCANNING, &tx->local->scanning) && assoc &&\n\t\t !rate_usable_index_exists(sband, &tx->sta->sta),\n\t\t \"%s: Dropped data frame as no usable bitrate found while \"\n\t\t \"scanning and associated. Target station: \"\n\t\t \"%pM on %d GHz band\\n\",\n\t\t tx->sdata->name,\n\t\t encap ? ((struct ethhdr *)hdr)->h_dest : hdr->addr1,\n\t\t info->band ? 5 : 2))\n\t\treturn TX_DROP;\n\n\t \n\trate_control_get_rate(tx->sdata, tx->sta, &txrc);\n\n\tif (tx->sta && !info->control.skip_table)\n\t\tratetbl = rcu_dereference(tx->sta->sta.rates);\n\n\tif (unlikely(info->control.rates[0].idx < 0)) {\n\t\tif (ratetbl) {\n\t\t\tstruct ieee80211_tx_rate rate = {\n\t\t\t\t.idx = ratetbl->rate[0].idx,\n\t\t\t\t.flags = ratetbl->rate[0].flags,\n\t\t\t\t.count = ratetbl->rate[0].count\n\t\t\t};\n\n\t\t\tif (ratetbl->rate[0].idx < 0)\n\t\t\t\treturn TX_DROP;\n\n\t\t\ttx->rate = rate;\n\t\t} else {\n\t\t\treturn TX_DROP;\n\t\t}\n\t} else {\n\t\ttx->rate = info->control.rates[0];\n\t}\n\n\tif (txrc.reported_rate.idx < 0) {\n\t\ttxrc.reported_rate = tx->rate;\n\t\tif (tx->sta && ieee80211_is_tx_data(tx->skb))\n\t\t\ttx->sta->deflink.tx_stats.last_rate = txrc.reported_rate;\n\t} else if (tx->sta)\n\t\ttx->sta->deflink.tx_stats.last_rate = txrc.reported_rate;\n\n\tif (ratetbl)\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(!info->control.rates[0].count))\n\t\tinfo->control.rates[0].count = 1;\n\n\tif (WARN_ON_ONCE((info->control.rates[0].count > 1) &&\n\t\t\t (info->flags & IEEE80211_TX_CTL_NO_ACK)))\n\t\tinfo->control.rates[0].count = 1;\n\n\treturn TX_CONTINUE;\n}\n\nstatic __le16 ieee80211_tx_next_seq(struct sta_info *sta, int tid)\n{\n\tu16 *seq = &sta->tid_seq[tid];\n\t__le16 ret = cpu_to_le16(*seq);\n\n\t \n\t*seq = (*seq + 0x10) & IEEE80211_SCTL_SEQ;\n\n\treturn ret;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_sequence(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tint tid;\n\n\t \n\tif (unlikely(info->control.vif->type == NL80211_IFTYPE_MONITOR))\n\t\treturn TX_CONTINUE;\n\n\tif (unlikely(ieee80211_is_ctl(hdr->frame_control)))\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_hdrlen(hdr->frame_control) < 24)\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\tif (info->control.flags & IEEE80211_TX_CTRL_NO_SEQNO)\n\t\treturn TX_CONTINUE;\n\n\t \n\tif (unlikely(is_multicast_ether_addr(hdr->addr1) &&\n\t\t     ieee80211_vif_is_mld(info->control.vif) &&\n\t\t     info->control.vif->type == NL80211_IFTYPE_AP)) {\n\t\tif (info->control.flags & IEEE80211_TX_CTRL_MCAST_MLO_FIRST_TX)\n\t\t\ttx->sdata->mld_mcast_seq += 0x10;\n\t\thdr->seq_ctrl = cpu_to_le16(tx->sdata->mld_mcast_seq);\n\t\treturn TX_CONTINUE;\n\t}\n\n\t \n\tif (!ieee80211_is_data_qos(hdr->frame_control) ||\n\t    is_multicast_ether_addr(hdr->addr1)) {\n\t\t \n\t\tinfo->flags |= IEEE80211_TX_CTL_ASSIGN_SEQ;\n\t\t \n\t\thdr->seq_ctrl = cpu_to_le16(tx->sdata->sequence_number);\n\t\ttx->sdata->sequence_number += 0x10;\n\t\tif (tx->sta)\n\t\t\ttx->sta->deflink.tx_stats.msdu[IEEE80211_NUM_TIDS]++;\n\t\treturn TX_CONTINUE;\n\t}\n\n\t \n\tif (!tx->sta)\n\t\treturn TX_CONTINUE;\n\n\t \n\ttid = ieee80211_get_tid(hdr);\n\ttx->sta->deflink.tx_stats.msdu[tid]++;\n\n\thdr->seq_ctrl = ieee80211_tx_next_seq(tx->sta, tid);\n\n\treturn TX_CONTINUE;\n}\n\nstatic int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\n\t \n\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    IEEE80211_ENCRYPT_HEADROOM +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + IEEE80211_ENCRYPT_HEADROOM);\n\n\t\t \n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\n\t\t \n\t\tskb_put_data(tmp, skb->data, hdrlen);\n\t\tskb_put_data(tmp, skb->data + pos, fraglen);\n\n\t\tpos += fraglen;\n\t}\n\n\t \n\tskb_trim(skb, hdrlen + per_fragm);\n\treturn 0;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_fragment(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb = tx->skb;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tint frag_threshold = tx->local->hw.wiphy->frag_threshold;\n\tint hdrlen;\n\tint fragnum;\n\n\t \n\t__skb_queue_tail(&tx->skbs, skb);\n\ttx->skb = NULL;\n\n\tif (info->flags & IEEE80211_TX_CTL_DONTFRAG)\n\t\treturn TX_CONTINUE;\n\n\tif (ieee80211_hw_check(&tx->local->hw, SUPPORTS_TX_FRAG))\n\t\treturn TX_CONTINUE;\n\n\t \n\tif (WARN_ON(info->flags & IEEE80211_TX_CTL_AMPDU))\n\t\treturn TX_DROP;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\t \n\tif (WARN_ON(skb->len + FCS_LEN <= frag_threshold))\n\t\treturn TX_DROP;\n\n\t \n\tif (ieee80211_fragment(tx, skb, hdrlen, frag_threshold))\n\t\treturn TX_DROP;\n\n\t \n\tfragnum = 0;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tconst __le16 morefrags = cpu_to_le16(IEEE80211_FCTL_MOREFRAGS);\n\n\t\thdr = (void *)skb->data;\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\n\t\tif (!skb_queue_is_last(&tx->skbs, skb)) {\n\t\t\thdr->frame_control |= morefrags;\n\t\t\t \n\t\t\tinfo->control.rates[1].idx = -1;\n\t\t\tinfo->control.rates[2].idx = -1;\n\t\t\tinfo->control.rates[3].idx = -1;\n\t\t\tBUILD_BUG_ON(IEEE80211_TX_MAX_RATES != 4);\n\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_RATE_CTRL_PROBE;\n\t\t} else {\n\t\t\thdr->frame_control &= ~morefrags;\n\t\t}\n\t\thdr->seq_ctrl |= cpu_to_le16(fragnum & IEEE80211_SCTL_FRAG);\n\t\tfragnum++;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_stats(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tint ac = -1;\n\n\tif (!tx->sta)\n\t\treturn TX_CONTINUE;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tac = skb_get_queue_mapping(skb);\n\t\ttx->sta->deflink.tx_stats.bytes[ac] += skb->len;\n\t}\n\tif (ac >= 0)\n\t\ttx->sta->deflink.tx_stats.packets[ac]++;\n\n\treturn TX_CONTINUE;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_encrypt(struct ieee80211_tx_data *tx)\n{\n\tif (!tx->key)\n\t\treturn TX_CONTINUE;\n\n\tswitch (tx->key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn ieee80211_crypto_wep_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn ieee80211_crypto_tkip_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn ieee80211_crypto_ccmp_encrypt(\n\t\t\ttx, IEEE80211_CCMP_MIC_LEN);\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\treturn ieee80211_crypto_ccmp_encrypt(\n\t\t\ttx, IEEE80211_CCMP_256_MIC_LEN);\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\treturn ieee80211_crypto_aes_cmac_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\treturn ieee80211_crypto_aes_cmac_256_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\treturn ieee80211_crypto_aes_gmac_encrypt(tx);\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\treturn ieee80211_crypto_gcmp_encrypt(tx);\n\t}\n\n\treturn TX_DROP;\n}\n\nstatic ieee80211_tx_result debug_noinline\nieee80211_tx_h_calculate_duration(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tint next_len;\n\tbool group_addr;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\thdr = (void *) skb->data;\n\t\tif (unlikely(ieee80211_is_pspoll(hdr->frame_control)))\n\t\t\tbreak;  \n\t\tif (!skb_queue_is_last(&tx->skbs, skb)) {\n\t\t\tstruct sk_buff *next = skb_queue_next(&tx->skbs, skb);\n\t\t\tnext_len = next->len;\n\t\t} else\n\t\t\tnext_len = 0;\n\t\tgroup_addr = is_multicast_ether_addr(hdr->addr1);\n\n\t\thdr->duration_id =\n\t\t\tieee80211_duration(tx, skb, group_addr, next_len);\n\t}\n\n\treturn TX_CONTINUE;\n}\n\n \n\nstatic bool ieee80211_tx_prep_agg(struct ieee80211_tx_data *tx,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t\t  struct tid_ampdu_tx *tid_tx,\n\t\t\t\t  int tid)\n{\n\tbool queued = false;\n\tbool reset_agg_timer = false;\n\tstruct sk_buff *purge_skb = NULL;\n\n\tif (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\treset_agg_timer = true;\n\t} else if (test_bit(HT_AGG_STATE_WANT_START, &tid_tx->state)) {\n\t\t \n\t} else if (!tx->sta->sta.txq[tid]) {\n\t\tspin_lock(&tx->sta->lock);\n\t\t \n\t\ttid_tx = rcu_dereference_protected_tid_tx(tx->sta, tid);\n\n\t\tif (!tid_tx) {\n\t\t\t \n\t\t} else if (test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\t\treset_agg_timer = true;\n\t\t} else {\n\t\t\tqueued = true;\n\t\t\tif (info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER) {\n\t\t\t\tclear_sta_flag(tx->sta, WLAN_STA_SP);\n\t\t\t\tps_dbg(tx->sta->sdata,\n\t\t\t\t       \"STA %pM aid %d: SP frame queued, close the SP w/o telling the peer\\n\",\n\t\t\t\t       tx->sta->sta.addr, tx->sta->sta.aid);\n\t\t\t}\n\t\t\tinfo->control.vif = &tx->sdata->vif;\n\t\t\tinfo->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\t\t\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\t\t\t__skb_queue_tail(&tid_tx->pending, skb);\n\t\t\tif (skb_queue_len(&tid_tx->pending) > STA_MAX_TX_BUFFER)\n\t\t\t\tpurge_skb = __skb_dequeue(&tid_tx->pending);\n\t\t}\n\t\tspin_unlock(&tx->sta->lock);\n\n\t\tif (purge_skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, purge_skb);\n\t}\n\n\t \n\tif (reset_agg_timer)\n\t\ttid_tx->last_tx = jiffies;\n\n\treturn queued;\n}\n\nvoid ieee80211_aggr_check(struct ieee80211_sub_if_data *sdata,\n\t\t\t  struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct rate_control_ref *ref = sdata->local->rate_ctrl;\n\tu16 tid;\n\n\tif (!ref || !(ref->ops->capa & RATE_CTRL_CAPA_AMPDU_TRIGGER))\n\t\treturn;\n\n\tif (!sta || !sta->sta.deflink.ht_cap.ht_supported ||\n\t    !sta->sta.wme || skb_get_queue_mapping(skb) == IEEE80211_AC_VO ||\n\t    skb->protocol == sdata->control_port_protocol)\n\t\treturn;\n\n\ttid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n\tif (likely(sta->ampdu_mlme.tid_tx[tid]))\n\t\treturn;\n\n\tieee80211_start_tx_ba_session(&sta->sta, tid, 0);\n}\n\n \nstatic ieee80211_tx_result\nieee80211_tx_prepare(struct ieee80211_sub_if_data *sdata,\n\t\t     struct ieee80211_tx_data *tx,\n\t\t     struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tbool aggr_check = false;\n\tint tid;\n\n\tmemset(tx, 0, sizeof(*tx));\n\ttx->skb = skb;\n\ttx->local = local;\n\ttx->sdata = sdata;\n\t__skb_queue_head_init(&tx->skbs);\n\n\t \n\tinfo->control.flags &= ~IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (likely(sta)) {\n\t\tif (!IS_ERR(sta))\n\t\t\ttx->sta = sta;\n\t} else {\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\t\ttx->sta = rcu_dereference(sdata->u.vlan.sta);\n\t\t\tif (!tx->sta && sdata->wdev.use_4addr)\n\t\t\t\treturn TX_DROP;\n\t\t} else if (tx->sdata->control_port_protocol == tx->skb->protocol) {\n\t\t\ttx->sta = sta_info_get_bss(sdata, hdr->addr1);\n\t\t}\n\t\tif (!tx->sta && !is_multicast_ether_addr(hdr->addr1)) {\n\t\t\ttx->sta = sta_info_get(sdata, hdr->addr1);\n\t\t\taggr_check = true;\n\t\t}\n\t}\n\n\tif (tx->sta && ieee80211_is_data_qos(hdr->frame_control) &&\n\t    !ieee80211_is_qos_nullfunc(hdr->frame_control) &&\n\t    ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION) &&\n\t    !ieee80211_hw_check(&local->hw, TX_AMPDU_SETUP_IN_HW)) {\n\t\tstruct tid_ampdu_tx *tid_tx;\n\n\t\ttid = ieee80211_get_tid(hdr);\n\t\ttid_tx = rcu_dereference(tx->sta->ampdu_mlme.tid_tx[tid]);\n\t\tif (!tid_tx && aggr_check) {\n\t\t\tieee80211_aggr_check(sdata, tx->sta, skb);\n\t\t\ttid_tx = rcu_dereference(tx->sta->ampdu_mlme.tid_tx[tid]);\n\t\t}\n\n\t\tif (tid_tx) {\n\t\t\tbool queued;\n\n\t\t\tqueued = ieee80211_tx_prep_agg(tx, skb, info,\n\t\t\t\t\t\t       tid_tx, tid);\n\n\t\t\tif (unlikely(queued))\n\t\t\t\treturn TX_QUEUED;\n\t\t}\n\t}\n\n\tif (is_multicast_ether_addr(hdr->addr1)) {\n\t\ttx->flags &= ~IEEE80211_TX_UNICAST;\n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t} else\n\t\ttx->flags |= IEEE80211_TX_UNICAST;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_DONTFRAG)) {\n\t\tif (!(tx->flags & IEEE80211_TX_UNICAST) ||\n\t\t    skb->len + FCS_LEN <= local->hw.wiphy->frag_threshold ||\n\t\t    info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_DONTFRAG;\n\t}\n\n\tif (!tx->sta)\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\telse if (test_and_clear_sta_flag(tx->sta, WLAN_STA_CLEAR_PS_FILT)) {\n\t\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT;\n\t\tieee80211_check_fast_xmit(tx->sta);\n\t}\n\n\tinfo->flags |= IEEE80211_TX_CTL_FIRST_FRAGMENT;\n\n\treturn TX_CONTINUE;\n}\n\nstatic struct txq_info *ieee80211_get_txq(struct ieee80211_local *local,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct sta_info *sta,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_txq *txq = NULL;\n\n\tif ((info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) ||\n\t    (info->control.flags & IEEE80211_TX_CTRL_PS_RESPONSE))\n\t\treturn NULL;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) &&\n\t    unlikely(!ieee80211_is_data_present(hdr->frame_control))) {\n\t\tif ((!ieee80211_is_mgmt(hdr->frame_control) ||\n\t\t     ieee80211_is_bufferable_mmpdu(skb) ||\n\t\t     vif->type == NL80211_IFTYPE_STATION) &&\n\t\t    sta && sta->uploaded) {\n\t\t\t \n\t\t\ttxq = sta->sta.txq[IEEE80211_NUM_TIDS];\n\t\t}\n\t} else if (sta) {\n\t\tu8 tid = skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n\n\t\tif (!sta->uploaded)\n\t\t\treturn NULL;\n\n\t\ttxq = sta->sta.txq[tid];\n\t} else {\n\t\ttxq = vif->txq;\n\t}\n\n\tif (!txq)\n\t\treturn NULL;\n\n\treturn to_txq_info(txq);\n}\n\nstatic void ieee80211_set_skb_enqueue_time(struct sk_buff *skb)\n{\n\tstruct sk_buff *next;\n\tcodel_time_t now = codel_get_time();\n\n\tskb_list_walk_safe(skb, skb, next)\n\t\tIEEE80211_SKB_CB(skb)->control.enqueue_time = now;\n}\n\nstatic u32 codel_skb_len_func(const struct sk_buff *skb)\n{\n\treturn skb->len;\n}\n\nstatic codel_time_t codel_skb_time_func(const struct sk_buff *skb)\n{\n\tconst struct ieee80211_tx_info *info;\n\n\tinfo = (const struct ieee80211_tx_info *)skb->cb;\n\treturn info->control.enqueue_time;\n}\n\nstatic struct sk_buff *codel_dequeue_func(struct codel_vars *cvars,\n\t\t\t\t\t  void *ctx)\n{\n\tstruct ieee80211_local *local;\n\tstruct txq_info *txqi;\n\tstruct fq *fq;\n\tstruct fq_flow *flow;\n\n\ttxqi = ctx;\n\tlocal = vif_to_sdata(txqi->txq.vif)->local;\n\tfq = &local->fq;\n\n\tif (cvars == &txqi->def_cvars)\n\t\tflow = &txqi->tin.default_flow;\n\telse\n\t\tflow = &fq->flows[cvars - local->cvars];\n\n\treturn fq_flow_dequeue(fq, flow);\n}\n\nstatic void codel_drop_func(struct sk_buff *skb,\n\t\t\t    void *ctx)\n{\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_hw *hw;\n\tstruct txq_info *txqi;\n\n\ttxqi = ctx;\n\tlocal = vif_to_sdata(txqi->txq.vif)->local;\n\thw = &local->hw;\n\n\tieee80211_free_txskb(hw, skb);\n}\n\nstatic struct sk_buff *fq_tin_dequeue_func(struct fq *fq,\n\t\t\t\t\t   struct fq_tin *tin,\n\t\t\t\t\t   struct fq_flow *flow)\n{\n\tstruct ieee80211_local *local;\n\tstruct txq_info *txqi;\n\tstruct codel_vars *cvars;\n\tstruct codel_params *cparams;\n\tstruct codel_stats *cstats;\n\n\tlocal = container_of(fq, struct ieee80211_local, fq);\n\ttxqi = container_of(tin, struct txq_info, tin);\n\tcstats = &txqi->cstats;\n\n\tif (txqi->txq.sta) {\n\t\tstruct sta_info *sta = container_of(txqi->txq.sta,\n\t\t\t\t\t\t    struct sta_info, sta);\n\t\tcparams = &sta->cparams;\n\t} else {\n\t\tcparams = &local->cparams;\n\t}\n\n\tif (flow == &tin->default_flow)\n\t\tcvars = &txqi->def_cvars;\n\telse\n\t\tcvars = &local->cvars[flow - fq->flows];\n\n\treturn codel_dequeue(txqi,\n\t\t\t     &flow->backlog,\n\t\t\t     cparams,\n\t\t\t     cvars,\n\t\t\t     cstats,\n\t\t\t     codel_skb_len_func,\n\t\t\t     codel_skb_time_func,\n\t\t\t     codel_drop_func,\n\t\t\t     codel_dequeue_func);\n}\n\nstatic void fq_skb_free_func(struct fq *fq,\n\t\t\t     struct fq_tin *tin,\n\t\t\t     struct fq_flow *flow,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local;\n\n\tlocal = container_of(fq, struct ieee80211_local, fq);\n\tieee80211_free_txskb(&local->hw, skb);\n}\n\nstatic void ieee80211_txq_enqueue(struct ieee80211_local *local,\n\t\t\t\t  struct txq_info *txqi,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct fq *fq = &local->fq;\n\tstruct fq_tin *tin = &txqi->tin;\n\tu32 flow_idx = fq_flow_idx(fq, skb);\n\n\tieee80211_set_skb_enqueue_time(skb);\n\n\tspin_lock_bh(&fq->lock);\n\t \n\tif (unlikely(txqi->txq.tid == IEEE80211_NUM_TIDS)) {\n\t\tIEEE80211_SKB_CB(skb)->control.flags |=\n\t\t\tIEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\t\t__skb_queue_tail(&txqi->frags, skb);\n\t} else {\n\t\tfq_tin_enqueue(fq, tin, flow_idx, skb,\n\t\t\t       fq_skb_free_func);\n\t}\n\tspin_unlock_bh(&fq->lock);\n}\n\nstatic bool fq_vlan_filter_func(struct fq *fq, struct fq_tin *tin,\n\t\t\t\tstruct fq_flow *flow, struct sk_buff *skb,\n\t\t\t\tvoid *data)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\treturn info->control.vif == data;\n}\n\nvoid ieee80211_txq_remove_vlan(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata)\n{\n\tstruct fq *fq = &local->fq;\n\tstruct txq_info *txqi;\n\tstruct fq_tin *tin;\n\tstruct ieee80211_sub_if_data *ap;\n\n\tif (WARN_ON(sdata->vif.type != NL80211_IFTYPE_AP_VLAN))\n\t\treturn;\n\n\tap = container_of(sdata->bss, struct ieee80211_sub_if_data, u.ap);\n\n\tif (!ap->vif.txq)\n\t\treturn;\n\n\ttxqi = to_txq_info(ap->vif.txq);\n\ttin = &txqi->tin;\n\n\tspin_lock_bh(&fq->lock);\n\tfq_tin_filter(fq, tin, fq_vlan_filter_func, &sdata->vif,\n\t\t      fq_skb_free_func);\n\tspin_unlock_bh(&fq->lock);\n}\n\nvoid ieee80211_txq_init(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sta_info *sta,\n\t\t\tstruct txq_info *txqi, int tid)\n{\n\tfq_tin_init(&txqi->tin);\n\tcodel_vars_init(&txqi->def_cvars);\n\tcodel_stats_init(&txqi->cstats);\n\t__skb_queue_head_init(&txqi->frags);\n\tINIT_LIST_HEAD(&txqi->schedule_order);\n\n\ttxqi->txq.vif = &sdata->vif;\n\n\tif (!sta) {\n\t\tsdata->vif.txq = &txqi->txq;\n\t\ttxqi->txq.tid = 0;\n\t\ttxqi->txq.ac = IEEE80211_AC_BE;\n\n\t\treturn;\n\t}\n\n\tif (tid == IEEE80211_NUM_TIDS) {\n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION) {\n\t\t\t \n\t\t\tif (!ieee80211_hw_check(&sdata->local->hw,\n\t\t\t\t\t\tSTA_MMPDU_TXQ))\n\t\t\t\treturn;\n\t\t} else if (!ieee80211_hw_check(&sdata->local->hw,\n\t\t\t\t\t       BUFF_MMPDU_TXQ)) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\ttxqi->txq.ac = IEEE80211_AC_VO;\n\t} else {\n\t\ttxqi->txq.ac = ieee80211_ac_from_tid(tid);\n\t}\n\n\ttxqi->txq.sta = &sta->sta;\n\ttxqi->txq.tid = tid;\n\tsta->sta.txq[tid] = &txqi->txq;\n}\n\nvoid ieee80211_txq_purge(struct ieee80211_local *local,\n\t\t\t struct txq_info *txqi)\n{\n\tstruct fq *fq = &local->fq;\n\tstruct fq_tin *tin = &txqi->tin;\n\n\tspin_lock_bh(&fq->lock);\n\tfq_tin_reset(fq, tin, fq_skb_free_func);\n\tieee80211_purge_tx_queue(&local->hw, &txqi->frags);\n\tspin_unlock_bh(&fq->lock);\n\n\tspin_lock_bh(&local->active_txq_lock[txqi->txq.ac]);\n\tlist_del_init(&txqi->schedule_order);\n\tspin_unlock_bh(&local->active_txq_lock[txqi->txq.ac]);\n}\n\nvoid ieee80211_txq_set_params(struct ieee80211_local *local)\n{\n\tif (local->hw.wiphy->txq_limit)\n\t\tlocal->fq.limit = local->hw.wiphy->txq_limit;\n\telse\n\t\tlocal->hw.wiphy->txq_limit = local->fq.limit;\n\n\tif (local->hw.wiphy->txq_memory_limit)\n\t\tlocal->fq.memory_limit = local->hw.wiphy->txq_memory_limit;\n\telse\n\t\tlocal->hw.wiphy->txq_memory_limit = local->fq.memory_limit;\n\n\tif (local->hw.wiphy->txq_quantum)\n\t\tlocal->fq.quantum = local->hw.wiphy->txq_quantum;\n\telse\n\t\tlocal->hw.wiphy->txq_quantum = local->fq.quantum;\n}\n\nint ieee80211_txq_setup_flows(struct ieee80211_local *local)\n{\n\tstruct fq *fq = &local->fq;\n\tint ret;\n\tint i;\n\tbool supp_vht = false;\n\tenum nl80211_band band;\n\n\tret = fq_init(fq, 4096);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = local->hw.wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tsupp_vht = supp_vht || sband->vht_cap.vht_supported;\n\t}\n\n\tif (!supp_vht)\n\t\tfq->memory_limit = 4 << 20;  \n\n\tcodel_params_init(&local->cparams);\n\tlocal->cparams.interval = MS2TIME(100);\n\tlocal->cparams.target = MS2TIME(20);\n\tlocal->cparams.ecn = true;\n\n\tlocal->cvars = kcalloc(fq->flows_cnt, sizeof(local->cvars[0]),\n\t\t\t       GFP_KERNEL);\n\tif (!local->cvars) {\n\t\tspin_lock_bh(&fq->lock);\n\t\tfq_reset(fq, fq_skb_free_func);\n\t\tspin_unlock_bh(&fq->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < fq->flows_cnt; i++)\n\t\tcodel_vars_init(&local->cvars[i]);\n\n\tieee80211_txq_set_params(local);\n\n\treturn 0;\n}\n\nvoid ieee80211_txq_teardown_flows(struct ieee80211_local *local)\n{\n\tstruct fq *fq = &local->fq;\n\n\tkfree(local->cvars);\n\tlocal->cvars = NULL;\n\n\tspin_lock_bh(&fq->lock);\n\tfq_reset(fq, fq_skb_free_func);\n\tspin_unlock_bh(&fq->lock);\n}\n\nstatic bool ieee80211_queue_skb(struct ieee80211_local *local,\n\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sta_info *sta,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_vif *vif;\n\tstruct txq_info *txqi;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR)\n\t\treturn false;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\n\tvif = &sdata->vif;\n\ttxqi = ieee80211_get_txq(local, vif, sta, skb);\n\n\tif (!txqi)\n\t\treturn false;\n\n\tieee80211_txq_enqueue(local, txqi, skb);\n\n\tschedule_and_wake_txq(local, txqi);\n\n\treturn true;\n}\n\nstatic bool ieee80211_tx_frags(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct sta_info *sta,\n\t\t\t       struct sk_buff_head *skbs,\n\t\t\t       bool txpending)\n{\n\tstruct ieee80211_tx_control control = {};\n\tstruct sk_buff *skb, *tmp;\n\tunsigned long flags;\n\n\tskb_queue_walk_safe(skbs, skb, tmp) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\tint q = info->hw_queue;\n\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\tif (WARN_ON_ONCE(q >= local->hw.queues)) {\n\t\t\t__skb_unlink(skb, skbs);\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\t\tif (local->queue_stop_reasons[q] ||\n\t\t    (!txpending && !skb_queue_empty(&local->pending[q]))) {\n\t\t\tif (unlikely(info->flags &\n\t\t\t\t     IEEE80211_TX_INTFL_OFFCHAN_TX_OK)) {\n\t\t\t\tif (local->queue_stop_reasons[q] &\n\t\t\t\t    ~BIT(IEEE80211_QUEUE_STOP_REASON_OFFCHANNEL)) {\n\t\t\t\t\t \n\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\t&local->queue_stop_reason_lock,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tieee80211_purge_tx_queue(&local->hw,\n\t\t\t\t\t\t\t\t skbs);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t \n\t\t\t\tif (txpending)\n\t\t\t\t\tskb_queue_splice_init(skbs,\n\t\t\t\t\t\t\t      &local->pending[q]);\n\t\t\t\telse\n\t\t\t\t\tskb_queue_splice_tail_init(skbs,\n\t\t\t\t\t\t\t\t   &local->pending[q]);\n\n\t\t\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\t\tinfo->control.vif = vif;\n\t\tcontrol.sta = sta ? &sta->sta : NULL;\n\n\t\t__skb_unlink(skb, skbs);\n\t\tdrv_tx(local, &control, skb);\n\t}\n\n\treturn true;\n}\n\n \nstatic bool __ieee80211_tx(struct ieee80211_local *local,\n\t\t\t   struct sk_buff_head *skbs, struct sta_info *sta,\n\t\t\t   bool txpending)\n{\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_vif *vif;\n\tstruct sk_buff *skb;\n\tbool result;\n\n\tif (WARN_ON(skb_queue_empty(skbs)))\n\t\treturn true;\n\n\tskb = skb_peek(skbs);\n\tinfo = IEEE80211_SKB_CB(skb);\n\tsdata = vif_to_sdata(info->control.vif);\n\tif (sta && !sta->uploaded)\n\t\tsta = NULL;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) {\n\t\t\tvif = &sdata->vif;\n\t\t\tbreak;\n\t\t}\n\t\tsdata = rcu_dereference(local->monitor_sdata);\n\t\tif (sdata) {\n\t\t\tvif = &sdata->vif;\n\t\t\tinfo->hw_queue =\n\t\t\t\tvif->hw_queue[skb_get_queue_mapping(skb)];\n\t\t} else if (ieee80211_hw_check(&local->hw, QUEUE_CONTROL)) {\n\t\t\tieee80211_purge_tx_queue(&local->hw, skbs);\n\t\t\treturn true;\n\t\t} else\n\t\t\tvif = NULL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\t\tfallthrough;\n\tdefault:\n\t\tvif = &sdata->vif;\n\t\tbreak;\n\t}\n\n\tresult = ieee80211_tx_frags(local, vif, sta, skbs, txpending);\n\n\tWARN_ON_ONCE(!skb_queue_empty(skbs));\n\n\treturn result;\n}\n\n \nstatic int invoke_tx_handlers_early(struct ieee80211_tx_data *tx)\n{\n\tieee80211_tx_result res = TX_DROP;\n\n#define CALL_TXH(txh) \\\n\tdo {\t\t\t\t\\\n\t\tres = txh(tx);\t\t\\\n\t\tif (res != TX_CONTINUE)\t\\\n\t\t\tgoto txh_done;\t\\\n\t} while (0)\n\n\tCALL_TXH(ieee80211_tx_h_dynamic_ps);\n\tCALL_TXH(ieee80211_tx_h_check_assoc);\n\tCALL_TXH(ieee80211_tx_h_ps_buf);\n\tCALL_TXH(ieee80211_tx_h_check_control_port_protocol);\n\tCALL_TXH(ieee80211_tx_h_select_key);\n\n txh_done:\n\tif (unlikely(res == TX_DROP)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop);\n\t\tif (tx->skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, tx->skb);\n\t\telse\n\t\t\tieee80211_purge_tx_queue(&tx->local->hw, &tx->skbs);\n\t\treturn -1;\n\t} else if (unlikely(res == TX_QUEUED)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_queued);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int invoke_tx_handlers_late(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tieee80211_tx_result res = TX_CONTINUE;\n\n\tif (!ieee80211_hw_check(&tx->local->hw, HAS_RATE_CONTROL))\n\t\tCALL_TXH(ieee80211_tx_h_rate_ctrl);\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_RETRANSMISSION)) {\n\t\t__skb_queue_tail(&tx->skbs, tx->skb);\n\t\ttx->skb = NULL;\n\t\tgoto txh_done;\n\t}\n\n\tCALL_TXH(ieee80211_tx_h_michael_mic_add);\n\tCALL_TXH(ieee80211_tx_h_sequence);\n\tCALL_TXH(ieee80211_tx_h_fragment);\n\t \n\tCALL_TXH(ieee80211_tx_h_stats);\n\tCALL_TXH(ieee80211_tx_h_encrypt);\n\tif (!ieee80211_hw_check(&tx->local->hw, HAS_RATE_CONTROL))\n\t\tCALL_TXH(ieee80211_tx_h_calculate_duration);\n#undef CALL_TXH\n\n txh_done:\n\tif (unlikely(res == TX_DROP)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop);\n\t\tif (tx->skb)\n\t\t\tieee80211_free_txskb(&tx->local->hw, tx->skb);\n\t\telse\n\t\t\tieee80211_purge_tx_queue(&tx->local->hw, &tx->skbs);\n\t\treturn -1;\n\t} else if (unlikely(res == TX_QUEUED)) {\n\t\tI802_DEBUG_INC(tx->local->tx_handlers_queued);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int invoke_tx_handlers(struct ieee80211_tx_data *tx)\n{\n\tint r = invoke_tx_handlers_early(tx);\n\n\tif (r)\n\t\treturn r;\n\treturn invoke_tx_handlers_late(tx);\n}\n\nbool ieee80211_tx_prepare_skb(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, struct sk_buff *skb,\n\t\t\t      int band, struct ieee80211_sta **sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_data tx;\n\tstruct sk_buff *skb2;\n\n\tif (ieee80211_tx_prepare(sdata, &tx, NULL, skb) == TX_DROP)\n\t\treturn false;\n\n\tinfo->band = band;\n\tinfo->control.vif = vif;\n\tinfo->hw_queue = vif->hw_queue[skb_get_queue_mapping(skb)];\n\n\tif (invoke_tx_handlers(&tx))\n\t\treturn false;\n\n\tif (sta) {\n\t\tif (tx.sta)\n\t\t\t*sta = &tx.sta->sta;\n\t\telse\n\t\t\t*sta = NULL;\n\t}\n\n\t \n\tskb2 = __skb_dequeue(&tx.skbs);\n\tif (WARN_ON(skb2 != skb || !skb_queue_empty(&tx.skbs))) {\n\t\tieee80211_free_txskb(hw, skb2);\n\t\tieee80211_purge_tx_queue(hw, &tx.skbs);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(ieee80211_tx_prepare_skb);\n\n \nstatic bool ieee80211_tx(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sta_info *sta, struct sk_buff *skb,\n\t\t\t bool txpending)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_data tx;\n\tieee80211_tx_result res_prepare;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tbool result = true;\n\n\tif (unlikely(skb->len < 10)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn true;\n\t}\n\n\t \n\tres_prepare = ieee80211_tx_prepare(sdata, &tx, sta, skb);\n\n\tif (unlikely(res_prepare == TX_DROP)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn true;\n\t} else if (unlikely(res_prepare == TX_QUEUED)) {\n\t\treturn true;\n\t}\n\n\t \n\tif (!(info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) ||\n\t    !ieee80211_hw_check(&local->hw, QUEUE_CONTROL))\n\t\tinfo->hw_queue =\n\t\t\tsdata->vif.hw_queue[skb_get_queue_mapping(skb)];\n\n\tif (invoke_tx_handlers_early(&tx))\n\t\treturn true;\n\n\tif (ieee80211_queue_skb(local, sdata, tx.sta, tx.skb))\n\t\treturn true;\n\n\tif (!invoke_tx_handlers_late(&tx))\n\t\tresult = __ieee80211_tx(local, &tx.skbs, tx.sta, txpending);\n\n\treturn result;\n}\n\n \n\nenum ieee80211_encrypt {\n\tENCRYPT_NO,\n\tENCRYPT_MGMT,\n\tENCRYPT_DATA,\n};\n\nstatic int ieee80211_skb_resize(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tint head_need,\n\t\t\t\tenum ieee80211_encrypt encrypt)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tbool enc_tailroom;\n\tint tail_need = 0;\n\n\tenc_tailroom = encrypt == ENCRYPT_MGMT ||\n\t\t       (encrypt == ENCRYPT_DATA &&\n\t\t\tsdata->crypto_tx_tailroom_needed_cnt);\n\n\tif (enc_tailroom) {\n\t\ttail_need = IEEE80211_ENCRYPT_TAILROOM;\n\t\ttail_need -= skb_tailroom(skb);\n\t\ttail_need = max_t(int, tail_need, 0);\n\t}\n\n\tif (skb_cloned(skb) &&\n\t    (!ieee80211_hw_check(&local->hw, SUPPORTS_CLONED_SKBS) ||\n\t     !skb_clone_writable(skb, ETH_HLEN) || enc_tailroom))\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head_cloned);\n\telse if (head_need || tail_need)\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head);\n\telse\n\t\treturn 0;\n\n\tif (pskb_expand_head(skb, head_need, tail_need, GFP_ATOMIC)) {\n\t\twiphy_debug(local->hw.wiphy,\n\t\t\t    \"failed to reallocate TX buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid ieee80211_xmit(struct ieee80211_sub_if_data *sdata,\n\t\t    struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tint headroom;\n\tenum ieee80211_encrypt encrypt;\n\n\tif (info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)\n\t\tencrypt = ENCRYPT_NO;\n\telse if (ieee80211_is_mgmt(hdr->frame_control))\n\t\tencrypt = ENCRYPT_MGMT;\n\telse\n\t\tencrypt = ENCRYPT_DATA;\n\n\theadroom = local->tx_headroom;\n\tif (encrypt != ENCRYPT_NO)\n\t\theadroom += IEEE80211_ENCRYPT_HEADROOM;\n\theadroom -= skb_headroom(skb);\n\theadroom = max_t(int, 0, headroom);\n\n\tif (ieee80211_skb_resize(sdata, skb, headroom, encrypt)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn;\n\t}\n\n\t \n\thdr = (struct ieee80211_hdr *) skb->data;\n\tinfo->control.vif = &sdata->vif;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t    is_unicast_ether_addr(hdr->addr1)) {\n\t\t\tif (mesh_nexthop_resolve(sdata, skb))\n\t\t\t\treturn;  \n\t\t} else {\n\t\t\tieee80211_mps_set_frame_flags(sdata, NULL, hdr);\n\t\t}\n\t}\n\n\tieee80211_set_qos_hdr(sdata, skb);\n\tieee80211_tx(sdata, sta, skb, false);\n}\n\nstatic bool ieee80211_validate_radiotap_len(struct sk_buff *skb)\n{\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *)skb->data;\n\n\t \n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\treturn false;  \n\n\t \n\tif (unlikely(rthdr->it_version))\n\t\treturn false;  \n\n\t \n\tif (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))\n\t\treturn false;  \n\n\treturn true;\n}\n\nbool ieee80211_parse_tx_radiotap(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_radiotap_iterator iterator;\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,\n\t\t\t\t\t\t   NULL);\n\tu16 txflags;\n\tu16 rate = 0;\n\tbool rate_found = false;\n\tu8 rate_retries = 0;\n\tu16 rate_flags = 0;\n\tu8 mcs_known, mcs_flags, mcs_bw;\n\tu16 vht_known;\n\tu8 vht_mcs = 0, vht_nss = 0;\n\tint i;\n\n\tif (!ieee80211_validate_radiotap_len(skb))\n\t\treturn false;\n\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t       IEEE80211_TX_CTL_DONTFRAG;\n\n\t \n\n\twhile (!ret) {\n\t\tret = ieee80211_radiotap_iterator_next(&iterator);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (iterator.this_arg_index) {\n\t\t \n\t\tcase IEEE80211_RADIOTAP_FLAGS:\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {\n\t\t\t\t \n\t\t\t\tif (skb->len < (iterator._max_length + FCS_LEN))\n\t\t\t\t\treturn false;\n\n\t\t\t\tskb_trim(skb, skb->len - FCS_LEN);\n\t\t\t}\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\t\t\tif (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)\n\t\t\t\tinfo->flags &= ~IEEE80211_TX_CTL_DONTFRAG;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_TX_FLAGS:\n\t\t\ttxflags = get_unaligned_le16(iterator.this_arg);\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_NOSEQNO)\n\t\t\t\tinfo->control.flags |= IEEE80211_TX_CTRL_NO_SEQNO;\n\t\t\tif (txflags & IEEE80211_RADIOTAP_F_TX_ORDER)\n\t\t\t\tinfo->control.flags |=\n\t\t\t\t\tIEEE80211_TX_CTRL_DONT_REORDER;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_RATE:\n\t\t\trate = *iterator.this_arg;\n\t\t\trate_flags = 0;\n\t\t\trate_found = true;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_DATA_RETRIES:\n\t\t\trate_retries = *iterator.this_arg;\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_MCS:\n\t\t\tmcs_known = iterator.this_arg[0];\n\t\t\tmcs_flags = iterator.this_arg[1];\n\t\t\tif (!(mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS))\n\t\t\t\tbreak;\n\n\t\t\trate_found = true;\n\t\t\trate = iterator.this_arg[2];\n\t\t\trate_flags = IEEE80211_TX_RC_MCS;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_SGI)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\n\t\t\tmcs_bw = mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK;\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW &&\n\t\t\t    mcs_bw == IEEE80211_RADIOTAP_MCS_BW_40)\n\t\t\t\trate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC &&\n\t\t\t    mcs_flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC)\n\t\t\t\tinfo->flags |= IEEE80211_TX_CTL_LDPC;\n\n\t\t\tif (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {\n\t\t\t\tu8 stbc = u8_get_bits(mcs_flags,\n\t\t\t\t\t\t      IEEE80211_RADIOTAP_MCS_STBC_MASK);\n\n\t\t\t\tinfo->flags |=\n\t\t\t\t\tu32_encode_bits(stbc,\n\t\t\t\t\t\t\tIEEE80211_TX_CTL_STBC);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IEEE80211_RADIOTAP_VHT:\n\t\t\tvht_known = get_unaligned_le16(iterator.this_arg);\n\t\t\trate_found = true;\n\n\t\t\trate_flags = IEEE80211_TX_RC_VHT_MCS;\n\t\t\tif ((vht_known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) &&\n\t\t\t    (iterator.this_arg[2] &\n\t\t\t     IEEE80211_RADIOTAP_VHT_FLAG_SGI))\n\t\t\t\trate_flags |= IEEE80211_TX_RC_SHORT_GI;\n\t\t\tif (vht_known &\n\t\t\t    IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH) {\n\t\t\t\tif (iterator.this_arg[3] == 1)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 4)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_80_MHZ_WIDTH;\n\t\t\t\telse if (iterator.this_arg[3] == 11)\n\t\t\t\t\trate_flags |=\n\t\t\t\t\t\tIEEE80211_TX_RC_160_MHZ_WIDTH;\n\t\t\t}\n\n\t\t\tvht_mcs = iterator.this_arg[4] >> 4;\n\t\t\tif (vht_mcs > 11)\n\t\t\t\tvht_mcs = 0;\n\t\t\tvht_nss = iterator.this_arg[4] & 0xF;\n\t\t\tif (!vht_nss || vht_nss > 8)\n\t\t\t\tvht_nss = 1;\n\t\t\tbreak;\n\n\t\t \n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != -ENOENT)  \n\t\treturn false;\n\n\tif (rate_found) {\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\tlocal->hw.wiphy->bands[info->band];\n\n\t\tinfo->control.flags |= IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\t\tinfo->control.rates[i].idx = -1;\n\t\t\tinfo->control.rates[i].flags = 0;\n\t\t\tinfo->control.rates[i].count = 0;\n\t\t}\n\n\t\tif (rate_flags & IEEE80211_TX_RC_MCS) {\n\t\t\tinfo->control.rates[0].idx = rate;\n\t\t} else if (rate_flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\t\tieee80211_rate_set_vht(info->control.rates, vht_mcs,\n\t\t\t\t\t       vht_nss);\n\t\t} else if (sband) {\n\t\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\t\tif (rate * 5 != sband->bitrates[i].bitrate)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tinfo->control.rates[0].idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (info->control.rates[0].idx < 0)\n\t\t\tinfo->control.flags &= ~IEEE80211_TX_CTRL_RATE_INJECT;\n\n\t\tinfo->control.rates[0].flags = rate_flags;\n\t\tinfo->control.rates[0].count = min_t(u8, rate_retries + 1,\n\t\t\t\t\t\t     local->hw.max_rate_tries);\n\t}\n\n\treturn true;\n}\n\nnetdev_tx_t ieee80211_monitor_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *tmp_sdata, *sdata;\n\tstruct cfg80211_chan_def *chandef;\n\tu16 len_rthdr;\n\tint hdrlen;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tif (unlikely(!ieee80211_sdata_running(sdata)))\n\t\tgoto fail;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->flags = IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t      IEEE80211_TX_CTL_INJECTED;\n\n\t \n\tif (!ieee80211_validate_radiotap_len(skb))\n\t\tgoto fail;\n\n\t \n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\n\t \n\tskb_set_mac_header(skb, len_rthdr);\n\t \n\tskb_set_network_header(skb, len_rthdr);\n\tskb_set_transport_header(skb, len_rthdr);\n\n\tif (skb->len < len_rthdr + 2)\n\t\tgoto fail;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (skb->len < len_rthdr + hdrlen)\n\t\tgoto fail;\n\n\t \n\tif (ieee80211_is_data(hdr->frame_control) &&\n\t    skb->len >= len_rthdr + hdrlen + sizeof(rfc1042_header) + 2) {\n\t\tu8 *payload = (u8 *)hdr + hdrlen;\n\n\t\tif (ether_addr_equal(payload, rfc1042_header))\n\t\t\tskb->protocol = cpu_to_be16((payload[6] << 8) |\n\t\t\t\t\t\t    payload[7]);\n\t}\n\n\trcu_read_lock();\n\n\t \n\tlist_for_each_entry_rcu(tmp_sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(tmp_sdata))\n\t\t\tcontinue;\n\t\tif (tmp_sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    tmp_sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(tmp_sdata->vif.addr, hdr->addr2)) {\n\t\t\tsdata = tmp_sdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\ttmp_sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tmp_sdata)\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(tmp_sdata->vif.bss_conf.chanctx_conf);\n\t}\n\n\tif (chanctx_conf)\n\t\tchandef = &chanctx_conf->def;\n\telse if (!local->use_chanctx)\n\t\tchandef = &local->_oper_chandef;\n\telse\n\t\tgoto fail_rcu;\n\n\t \n\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, chandef,\n\t\t\t\t     sdata->vif.type))\n\t\tgoto fail_rcu;\n\n\tinfo->band = chandef->chan->band;\n\n\t \n\tieee80211_select_queue_80211(sdata, skb, hdr);\n\tskb_set_queue_mapping(skb, ieee80211_ac_from_tid(skb->priority));\n\n\t \n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\tgoto fail_rcu;\n\n\t \n\tskb_pull(skb, len_rthdr);\n\n\tieee80211_xmit(sdata, NULL, skb);\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n\nfail_rcu:\n\trcu_read_unlock();\nfail:\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;  \n}\n\nstatic inline bool ieee80211_is_tdls_setup(struct sk_buff *skb)\n{\n\tu16 ethertype = (skb->data[12] << 8) | skb->data[13];\n\n\treturn ethertype == ETH_P_TDLS &&\n\t       skb->len > 14 &&\n\t       skb->data[14] == WLAN_TDLS_SNAP_RFTYPE;\n}\n\nint ieee80211_lookup_ra_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct sta_info **sta_out)\n{\n\tstruct sta_info *sta;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tsta = rcu_dereference(sdata->u.vlan.sta);\n\t\tif (sta) {\n\t\t\t*sta_out = sta;\n\t\t\treturn 0;\n\t\t} else if (sdata->wdev.use_4addr) {\n\t\t\treturn -ENOLINK;\n\t\t}\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (is_multicast_ether_addr(skb->data)) {\n\t\t\t*sta_out = ERR_PTR(-ENOENT);\n\t\t\treturn 0;\n\t\t}\n\t\tsta = sta_info_get_bss(sdata, skb->data);\n\t\tbreak;\n#ifdef CONFIG_MAC80211_MESH\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t \n\t\t*sta_out = NULL;\n\t\treturn 0;\n#endif\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (sdata->wdev.wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS) {\n\t\t\tsta = sta_info_get(sdata, skb->data);\n\t\t\tif (sta && test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\t\tif (test_sta_flag(sta,\n\t\t\t\t\t\t  WLAN_STA_TDLS_PEER_AUTH)) {\n\t\t\t\t\t*sta_out = sta;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (!ieee80211_is_tdls_setup(skb))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t}\n\n\t\tsta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);\n\t\tif (!sta)\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*sta_out = sta ?: ERR_PTR(-ENOENT);\n\treturn 0;\n}\n\nstatic u16 ieee80211_store_ack_skb(struct ieee80211_local *local,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   u32 *info_flags,\n\t\t\t\t   u64 *cookie)\n{\n\tstruct sk_buff *ack_skb;\n\tu16 info_id = 0;\n\n\tif (skb->sk)\n\t\tack_skb = skb_clone_sk(skb);\n\telse\n\t\tack_skb = skb_clone(skb, GFP_ATOMIC);\n\n\tif (ack_skb) {\n\t\tunsigned long flags;\n\t\tint id;\n\n\t\tspin_lock_irqsave(&local->ack_status_lock, flags);\n\t\tid = idr_alloc(&local->ack_status_frames, ack_skb,\n\t\t\t       1, 0x2000, GFP_ATOMIC);\n\t\tspin_unlock_irqrestore(&local->ack_status_lock, flags);\n\n\t\tif (id >= 0) {\n\t\t\tinfo_id = id;\n\t\t\t*info_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t\tif (cookie) {\n\t\t\t\t*cookie = ieee80211_mgmt_tx_cookie(local);\n\t\t\t\tIEEE80211_SKB_CB(ack_skb)->ack.cookie = *cookie;\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(ack_skb);\n\t\t}\n\t}\n\n\treturn info_id;\n}\n\n \nstatic struct sk_buff *ieee80211_build_hdr(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct sk_buff *skb, u32 info_flags,\n\t\t\t\t\t   struct sta_info *sta, u32 ctrl_flags,\n\t\t\t\t\t   u64 *cookie)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info;\n\tint head_need;\n\tu16 ethertype, hdrlen,  meshhdrlen = 0;\n\t__le16 fc;\n\tstruct ieee80211_hdr hdr;\n\tstruct ieee80211s_hdr mesh_hdr __maybe_unused;\n\tstruct mesh_path __maybe_unused *mppath = NULL, *mpath = NULL;\n\tconst u8 *encaps_data;\n\tint encaps_len, skip_header_bytes;\n\tbool wme_sta = false, authorized = false;\n\tbool tdls_peer;\n\tbool multicast;\n\tu16 info_id = 0;\n\tstruct ieee80211_chanctx_conf *chanctx_conf = NULL;\n\tenum nl80211_band band;\n\tint ret;\n\tu8 link_id = u32_get_bits(ctrl_flags, IEEE80211_TX_CTRL_MLO_LINK);\n\n\tif (IS_ERR(sta))\n\t\tsta = NULL;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tif (local->force_tx_status)\n\t\tinfo_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n#endif\n\n\t \n\tethertype = (skb->data[12] << 8) | skb->data[13];\n\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);\n\n\tif (!ieee80211_vif_is_mld(&sdata->vif))\n\t\tchanctx_conf =\n\t\t\trcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (sdata->wdev.use_4addr) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);\n\t\t\t \n\t\t\tmemcpy(hdr.addr1, sta->sta.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\thdrlen = 30;\n\t\t\tauthorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);\n\t\t\twme_sta = sta->sta.wme;\n\t\t}\n\t\tif (!ieee80211_vif_is_mld(&sdata->vif)) {\n\t\t\tstruct ieee80211_sub_if_data *ap_sdata;\n\n\t\t\t \n\t\t\tap_sdata = container_of(sdata->bss,\n\t\t\t\t\t\tstruct ieee80211_sub_if_data,\n\t\t\t\t\t\tu.ap);\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(ap_sdata->vif.bss_conf.chanctx_conf);\n\t\t}\n\t\tif (sdata->wdev.use_4addr)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t \n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\n\t\tif (ieee80211_vif_is_mld(&sdata->vif) && sta && !sta->sta.mlo) {\n\t\t\tstruct ieee80211_link_data *link;\n\n\t\t\tlink_id = sta->deflink.link_id;\n\t\t\tlink = rcu_dereference(sdata->link[link_id]);\n\t\t\tif (WARN_ON(!link)) {\n\t\t\t\tret = -ENOLINK;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\tmemcpy(hdr.addr2, link->conf->addr, ETH_ALEN);\n\t\t} else if (link_id == IEEE80211_LINK_UNSPECIFIED ||\n\t\t\t   (sta && sta->sta.mlo)) {\n\t\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\t} else {\n\t\t\tstruct ieee80211_bss_conf *conf;\n\n\t\t\tconf = rcu_dereference(sdata->vif.link_conf[link_id]);\n\t\t\tif (unlikely(!conf)) {\n\t\t\t\tret = -ENOLINK;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tmemcpy(hdr.addr2, conf->addr, ETH_ALEN);\n\t\t}\n\n\t\tmemcpy(hdr.addr3, skb->data + ETH_ALEN, ETH_ALEN);\n\t\thdrlen = 24;\n\t\tbreak;\n#ifdef CONFIG_MAC80211_MESH\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!is_multicast_ether_addr(skb->data)) {\n\t\t\tstruct sta_info *next_hop;\n\t\t\tbool mpp_lookup = true;\n\n\t\t\tmpath = mesh_path_lookup(sdata, skb->data);\n\t\t\tif (mpath) {\n\t\t\t\tmpp_lookup = false;\n\t\t\t\tnext_hop = rcu_dereference(mpath->next_hop);\n\t\t\t\tif (!next_hop ||\n\t\t\t\t    !(mpath->flags & (MESH_PATH_ACTIVE |\n\t\t\t\t\t\t      MESH_PATH_RESOLVING)))\n\t\t\t\t\tmpp_lookup = true;\n\t\t\t}\n\n\t\t\tif (mpp_lookup) {\n\t\t\t\tmppath = mpp_path_lookup(sdata, skb->data);\n\t\t\t\tif (mppath)\n\t\t\t\t\tmppath->exp_time = jiffies;\n\t\t\t}\n\n\t\t\tif (mppath && mpath)\n\t\t\t\tmesh_path_del(sdata, mpath->dst);\n\t\t}\n\n\t\t \n\t\tif (ether_addr_equal(sdata->vif.addr, skb->data + ETH_ALEN) &&\n\t\t    !(mppath && !ether_addr_equal(mppath->mpp, skb->data))) {\n\t\t\thdrlen = ieee80211_fill_mesh_addresses(&hdr, &fc,\n\t\t\t\t\tskb->data, skb->data + ETH_ALEN);\n\t\t\tmeshhdrlen = ieee80211_new_mesh_header(sdata, &mesh_hdr,\n\t\t\t\t\t\t\t       NULL, NULL);\n\t\t} else {\n\t\t\t \n\t\t\tconst u8 *mesh_da = skb->data;\n\n\t\t\tif (mppath)\n\t\t\t\tmesh_da = mppath->mpp;\n\t\t\telse if (mpath)\n\t\t\t\tmesh_da = mpath->dst;\n\n\t\t\thdrlen = ieee80211_fill_mesh_addresses(&hdr, &fc,\n\t\t\t\t\tmesh_da, sdata->vif.addr);\n\t\t\tif (is_multicast_ether_addr(mesh_da))\n\t\t\t\t \n\t\t\t\tmeshhdrlen = ieee80211_new_mesh_header(\n\t\t\t\t\t\tsdata, &mesh_hdr,\n\t\t\t\t\t\tskb->data + ETH_ALEN, NULL);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tmeshhdrlen = ieee80211_new_mesh_header(\n\t\t\t\t\t\tsdata, &mesh_hdr, skb->data,\n\t\t\t\t\t\tskb->data + ETH_ALEN);\n\n\t\t}\n\n\t\t \n\t\tif ((ctrl_flags & IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP) &&\n\t\t    is_zero_ether_addr(hdr.addr1))\n\t\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tbreak;\n#endif\n\tcase NL80211_IFTYPE_STATION:\n\t\t \n\t\ttdls_peer = test_sta_flag(sta, WLAN_STA_TDLS_PEER);\n\n\t\tif (tdls_peer) {\n\t\t\t \n\t\t\tint tdls_link_id = sta->sta.valid_links ?\n\t\t\t\t\t   __ffs(sta->sta.valid_links) : 0;\n\t\t\tstruct ieee80211_link_data *link;\n\n\t\t\t \n\t\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\tlink = rcu_dereference(sdata->link[tdls_link_id]);\n\t\t\tif (WARN_ON_ONCE(!link)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\tmemcpy(hdr.addr3, link->u.mgd.bssid, ETH_ALEN);\n\t\t\thdrlen = 24;\n\t\t}  else if (sdata->u.mgd.use_4addr &&\n\t\t\t    cpu_to_be16(ethertype) != sdata->control_port_protocol) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t  IEEE80211_FCTL_TODS);\n\t\t\t \n\t\t\tmemcpy(hdr.addr1, sdata->deflink.u.mgd.bssid, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr4, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\thdrlen = 30;\n\t\t} else {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_TODS);\n\t\t\t \n\t\t\tmemcpy(hdr.addr1, sdata->vif.cfg.ap_addr, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\t\tmemcpy(hdr.addr3, skb->data, ETH_ALEN);\n\t\t\thdrlen = 24;\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_OCB:\n\t\t \n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\teth_broadcast_addr(hdr.addr3);\n\t\thdrlen = 24;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t \n\t\tmemcpy(hdr.addr1, skb->data, ETH_ALEN);\n\t\tmemcpy(hdr.addr2, skb->data + ETH_ALEN, ETH_ALEN);\n\t\tmemcpy(hdr.addr3, sdata->u.ibss.bssid, ETH_ALEN);\n\t\thdrlen = 24;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!chanctx_conf) {\n\t\tif (!ieee80211_vif_is_mld(&sdata->vif)) {\n\t\t\tret = -ENOTCONN;\n\t\t\tgoto free;\n\t\t}\n\t\t \n\t\tband = 0;\n\t} else {\n\t\tband = chanctx_conf->def.chan->band;\n\t}\n\n\tmulticast = is_multicast_ether_addr(hdr.addr1);\n\n\t \n\tif (sta) {\n\t\tauthorized = test_sta_flag(sta, WLAN_STA_AUTHORIZED);\n\t\twme_sta = sta->sta.wme;\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\t \n\t\twme_sta = true;\n\t}\n\n\t \n\tif (wme_sta) {\n\t\tfc |= cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n\t\thdrlen += 2;\n\t}\n\n\t \n\tif (unlikely(!ieee80211_vif_is_mesh(&sdata->vif) &&\n\t\t     (sdata->vif.type != NL80211_IFTYPE_OCB) &&\n\t\t     !multicast && !authorized &&\n\t\t     (cpu_to_be16(ethertype) != sdata->control_port_protocol ||\n\t\t      !ieee80211_is_our_addr(sdata, skb->data + ETH_ALEN, NULL)))) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\tnet_info_ratelimited(\"%s: dropped frame to %pM (unauthorized port)\\n\",\n\t\t\t\t    sdata->name, hdr.addr1);\n#endif\n\n\t\tI802_DEBUG_INC(local->tx_handlers_drop_unauth_port);\n\n\t\tret = -EPERM;\n\t\tgoto free;\n\t}\n\n\tif (unlikely(!multicast && ((skb->sk &&\n\t\t     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS) ||\n\t\t     ctrl_flags & IEEE80211_TX_CTL_REQ_TX_STATUS)))\n\t\tinfo_id = ieee80211_store_ack_skb(local, skb, &info_flags,\n\t\t\t\t\t\t  cookie);\n\n\t \n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (unlikely(!skb)) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\thdr.frame_control = fc;\n\thdr.duration_id = 0;\n\thdr.seq_ctrl = 0;\n\n\tskip_header_bytes = ETH_HLEN;\n\tif (ethertype == ETH_P_AARP || ethertype == ETH_P_IPX) {\n\t\tencaps_data = bridge_tunnel_header;\n\t\tencaps_len = sizeof(bridge_tunnel_header);\n\t\tskip_header_bytes -= 2;\n\t} else if (ethertype >= ETH_P_802_3_MIN) {\n\t\tencaps_data = rfc1042_header;\n\t\tencaps_len = sizeof(rfc1042_header);\n\t\tskip_header_bytes -= 2;\n\t} else {\n\t\tencaps_data = NULL;\n\t\tencaps_len = 0;\n\t}\n\n\tskb_pull(skb, skip_header_bytes);\n\thead_need = hdrlen + encaps_len + meshhdrlen - skb_headroom(skb);\n\n\t \n\n\tif (head_need > 0 || skb_cloned(skb)) {\n\t\thead_need += IEEE80211_ENCRYPT_HEADROOM;\n\t\thead_need += local->tx_headroom;\n\t\thead_need = max_t(int, 0, head_need);\n\t\tif (ieee80211_skb_resize(sdata, skb, head_need, ENCRYPT_DATA)) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tskb = NULL;\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tif (encaps_data)\n\t\tmemcpy(skb_push(skb, encaps_len), encaps_data, encaps_len);\n\n#ifdef CONFIG_MAC80211_MESH\n\tif (meshhdrlen > 0)\n\t\tmemcpy(skb_push(skb, meshhdrlen), &mesh_hdr, meshhdrlen);\n#endif\n\n\tif (ieee80211_is_data_qos(fc)) {\n\t\t__le16 *qos_control;\n\n\t\tqos_control = skb_push(skb, 2);\n\t\tmemcpy(skb_push(skb, hdrlen - 2), &hdr, hdrlen - 2);\n\t\t \n\t\t*qos_control = 0;\n\t} else\n\t\tmemcpy(skb_push(skb, hdrlen), &hdr, hdrlen);\n\n\tskb_reset_mac_header(skb);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tmemset(info, 0, sizeof(*info));\n\n\tinfo->flags = info_flags;\n\tinfo->ack_frame_id = info_id;\n\tinfo->band = band;\n\n\tif (likely(!cookie)) {\n\t\tctrl_flags |= u32_encode_bits(link_id,\n\t\t\t\t\t      IEEE80211_TX_CTRL_MLO_LINK);\n\t} else {\n\t\tunsigned int pre_conf_link_id;\n\n\t\t \n\n\t\tpre_conf_link_id = u32_get_bits(ctrl_flags,\n\t\t\t\t\t\tIEEE80211_TX_CTRL_MLO_LINK);\n\n\t\tif (pre_conf_link_id != link_id &&\n\t\t    link_id != IEEE80211_LINK_UNSPECIFIED) {\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\t\t\tnet_info_ratelimited(\"%s: dropped frame to %pM with bad link ID request (%d vs. %d)\\n\",\n\t\t\t\t\t     sdata->name, hdr.addr1,\n\t\t\t\t\t     pre_conf_link_id, link_id);\n#endif\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tinfo->control.flags = ctrl_flags;\n\n\treturn skb;\n free:\n\tkfree_skb(skb);\n\treturn ERR_PTR(ret);\n}\n\n \n\nvoid ieee80211_check_fast_xmit(struct sta_info *sta)\n{\n\tstruct ieee80211_fast_tx build = {}, *fast_tx = NULL, *old;\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_hdr *hdr = (void *)build.hdr;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\t__le16 fc;\n\n\tif (!ieee80211_hw_check(&local->hw, SUPPORT_FAST_XMIT))\n\t\treturn;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tmesh_fast_tx_flush_sta(sdata, sta);\n\n\t \n\tspin_lock_bh(&sta->lock);\n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_PS) &&\n\t    !ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS) &&\n\t    sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\tgoto out;\n\n\tif (!test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\tgoto out;\n\n\tif (test_sta_flag(sta, WLAN_STA_PS_STA) ||\n\t    test_sta_flag(sta, WLAN_STA_PS_DRIVER) ||\n\t    test_sta_flag(sta, WLAN_STA_PS_DELIVER) ||\n\t    test_sta_flag(sta, WLAN_STA_CLEAR_PS_FILT))\n\t\tgoto out;\n\n\tif (sdata->noack_map)\n\t\tgoto out;\n\n\t \n\tif (local->hw.wiphy->frag_threshold != (u32)-1 &&\n\t    !ieee80211_hw_check(&local->hw, SUPPORTS_TX_FRAG))\n\t\tgoto out;\n\n\tif (!ieee80211_vif_is_mld(&sdata->vif)) {\n\t\trcu_read_lock();\n\t\tchanctx_conf =\n\t\t\trcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\t\tif (!chanctx_conf) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out;\n\t\t}\n\t\tbuild.band = chanctx_conf->def.chan->band;\n\t\trcu_read_unlock();\n\t} else {\n\t\t \n\t\tbuild.band = 0;\n\t}\n\n\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_DATA);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t \n\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\tmemcpy(hdr->addr3, sdata->u.ibss.bssid, ETH_ALEN);\n\t\tbuild.hdr_len = 24;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\t \n\t\t\tint tdls_link_id = sta->sta.valid_links ?\n\t\t\t\t\t   __ffs(sta->sta.valid_links) : 0;\n\t\t\tstruct ieee80211_link_data *link;\n\n\t\t\t \n\t\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\t\tlink = rcu_dereference(sdata->link[tdls_link_id]);\n\t\t\tif (WARN_ON_ONCE(!link))\n\t\t\t\tbreak;\n\t\t\tmemcpy(hdr->addr3, link->u.mgd.bssid, ETH_ALEN);\n\t\t\tbuild.hdr_len = 24;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdata->u.mgd.use_4addr) {\n\t\t\t \n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t  IEEE80211_FCTL_TODS);\n\t\t\t \n\t\t\tmemcpy(hdr->addr1, sdata->deflink.u.mgd.bssid, ETH_ALEN);\n\t\t\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr4);\n\t\t\tbuild.hdr_len = 30;\n\t\t\tbreak;\n\t\t}\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_TODS);\n\t\t \n\t\tmemcpy(hdr->addr1, sdata->vif.cfg.ap_addr, ETH_ALEN);\n\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\tbuild.hdr_len = 24;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (sdata->wdev.use_4addr) {\n\t\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t  IEEE80211_FCTL_TODS);\n\t\t\t \n\t\t\tmemcpy(hdr->addr1, sta->sta.addr, ETH_ALEN);\n\t\t\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr4);\n\t\t\tbuild.hdr_len = 30;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t \n\t\tbuild.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\tif (sta->sta.mlo || !ieee80211_vif_is_mld(&sdata->vif)) {\n\t\t\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\t} else {\n\t\t\tunsigned int link_id = sta->deflink.link_id;\n\t\t\tstruct ieee80211_link_data *link;\n\n\t\t\trcu_read_lock();\n\t\t\tlink = rcu_dereference(sdata->link[link_id]);\n\t\t\tif (WARN_ON(!link)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(hdr->addr2, link->conf->addr, ETH_ALEN);\n\t\t\trcu_read_unlock();\n\t\t}\n\t\tbuild.sa_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\tbuild.hdr_len = 24;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (sta->sta.wme) {\n\t\tbuild.hdr_len += 2;\n\t\tfc |= cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n\t}\n\n\t \n\tbuild.key = rcu_access_pointer(sta->ptk[sta->ptk_idx]);\n\tif (!build.key)\n\t\tbuild.key = rcu_access_pointer(sdata->default_unicast_key);\n\tif (build.key) {\n\t\tbool gen_iv, iv_spc, mmic;\n\n\t\tgen_iv = build.key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\tiv_spc = build.key->conf.flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE;\n\t\tmmic = build.key->conf.flags &\n\t\t\t(IEEE80211_KEY_FLAG_GENERATE_MMIC |\n\t\t\t IEEE80211_KEY_FLAG_PUT_MIC_SPACE);\n\n\t\t \n\t\tif (!(build.key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE))\n\t\t\tgoto out;\n\n\t\t \n\t\tif (build.key->flags & KEY_FLAG_TAINTED)\n\t\t\tgoto out;\n\n\t\tswitch (build.key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\t\tif (gen_iv)\n\t\t\t\tbuild.pn_offs = build.hdr_len;\n\t\t\tif (gen_iv || iv_spc)\n\t\t\t\tbuild.hdr_len += IEEE80211_CCMP_HDR_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tif (gen_iv)\n\t\t\t\tbuild.pn_offs = build.hdr_len;\n\t\t\tif (gen_iv || iv_spc)\n\t\t\t\tbuild.hdr_len += IEEE80211_GCMP_HDR_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\t \n\t\t\tif (mmic || gen_iv)\n\t\t\t\tgoto out;\n\t\t\tif (iv_spc)\n\t\t\t\tbuild.hdr_len += IEEE80211_TKIP_IV_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\t \n\t\t\tif (gen_iv)\n\t\t\t\tgoto out;\n\t\t\tif (iv_spc)\n\t\t\t\tbuild.hdr_len += IEEE80211_WEP_IV_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\t\tWARN(1,\n\t\t\t     \"management cipher suite 0x%x enabled for data\\n\",\n\t\t\t     build.key->conf.cipher);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\t \n\t\t\tif (WARN_ON(gen_iv))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tfc |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t}\n\n\thdr->frame_control = fc;\n\n\tmemcpy(build.hdr + build.hdr_len,\n\t       rfc1042_header,  sizeof(rfc1042_header));\n\tbuild.hdr_len += sizeof(rfc1042_header);\n\n\tfast_tx = kmemdup(&build, sizeof(build), GFP_ATOMIC);\n\t \n\n out:\n\t \n\told = rcu_dereference_protected(sta->fast_tx,\n\t\t\t\t\tlockdep_is_held(&sta->lock));\n\trcu_assign_pointer(sta->fast_tx, fast_tx);\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n\tspin_unlock_bh(&sta->lock);\n}\n\nvoid ieee80211_check_fast_xmit_all(struct ieee80211_local *local)\n{\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list)\n\t\tieee80211_check_fast_xmit(sta);\n\trcu_read_unlock();\n}\n\nvoid ieee80211_check_fast_xmit_iface(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata &&\n\t\t    (!sta->sdata->bss || sta->sdata->bss != sdata->bss))\n\t\t\tcontinue;\n\t\tieee80211_check_fast_xmit(sta);\n\t}\n\n\trcu_read_unlock();\n}\n\nvoid ieee80211_clear_fast_xmit(struct sta_info *sta)\n{\n\tstruct ieee80211_fast_tx *fast_tx;\n\n\tspin_lock_bh(&sta->lock);\n\tfast_tx = rcu_dereference_protected(sta->fast_tx,\n\t\t\t\t\t    lockdep_is_held(&sta->lock));\n\tRCU_INIT_POINTER(sta->fast_tx, NULL);\n\tspin_unlock_bh(&sta->lock);\n\n\tif (fast_tx)\n\t\tkfree_rcu(fast_tx, rcu_head);\n}\n\nstatic bool ieee80211_amsdu_realloc_pad(struct ieee80211_local *local,\n\t\t\t\t\tstruct sk_buff *skb, int headroom)\n{\n\tif (skb_headroom(skb) < headroom) {\n\t\tI802_DEBUG_INC(local->tx_expand_skb_head);\n\n\t\tif (pskb_expand_head(skb, headroom, 0, GFP_ATOMIC)) {\n\t\t\twiphy_debug(local->hw.wiphy,\n\t\t\t\t    \"failed to reallocate TX buffer\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool ieee80211_amsdu_prepare_head(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct ieee80211_fast_tx *fast_tx,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ethhdr *amsdu_hdr;\n\tint hdr_len = fast_tx->hdr_len - sizeof(rfc1042_header);\n\tint subframe_len = skb->len - hdr_len;\n\tvoid *data;\n\tu8 *qc, *h_80211_src, *h_80211_dst;\n\tconst u8 *bssid;\n\n\tif (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)\n\t\treturn false;\n\n\tif (info->control.flags & IEEE80211_TX_CTRL_AMSDU)\n\t\treturn true;\n\n\tif (!ieee80211_amsdu_realloc_pad(local, skb,\n\t\t\t\t\t sizeof(*amsdu_hdr) +\n\t\t\t\t\t local->hw.extra_tx_headroom))\n\t\treturn false;\n\n\tdata = skb_push(skb, sizeof(*amsdu_hdr));\n\tmemmove(data, data + sizeof(*amsdu_hdr), hdr_len);\n\thdr = data;\n\tamsdu_hdr = data + hdr_len;\n\t \n\th_80211_src = data + fast_tx->sa_offs;\n\th_80211_dst = data + fast_tx->da_offs;\n\n\tamsdu_hdr->h_proto = cpu_to_be16(subframe_len);\n\tether_addr_copy(amsdu_hdr->h_source, h_80211_src);\n\tether_addr_copy(amsdu_hdr->h_dest, h_80211_dst);\n\n\t \n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tbssid = sdata->vif.cfg.ap_addr;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbssid = sdata->vif.addr;\n\t\tbreak;\n\tdefault:\n\t\tbssid = NULL;\n\t}\n\n\tif (bssid && ieee80211_has_fromds(hdr->frame_control))\n\t\tether_addr_copy(h_80211_src, bssid);\n\n\tif (bssid && ieee80211_has_tods(hdr->frame_control))\n\t\tether_addr_copy(h_80211_dst, bssid);\n\n\tqc = ieee80211_get_qos_ctl(hdr);\n\t*qc |= IEEE80211_QOS_CTL_A_MSDU_PRESENT;\n\n\tinfo->control.flags |= IEEE80211_TX_CTRL_AMSDU;\n\n\treturn true;\n}\n\nstatic bool ieee80211_amsdu_aggregate(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct sta_info *sta,\n\t\t\t\t      struct ieee80211_fast_tx *fast_tx,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const u8 *da, const u8 *sa)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct fq *fq = &local->fq;\n\tstruct fq_tin *tin;\n\tstruct fq_flow *flow;\n\tu8 tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\tstruct ieee80211_txq *txq = sta->sta.txq[tid];\n\tstruct txq_info *txqi;\n\tstruct sk_buff **frag_tail, *head;\n\tint subframe_len = skb->len - ETH_ALEN;\n\tu8 max_subframes = sta->sta.max_amsdu_subframes;\n\tint max_frags = local->hw.max_tx_fragments;\n\tint max_amsdu_len = sta->sta.cur->max_amsdu_len;\n\tint orig_truesize;\n\tu32 flow_idx;\n\t__be16 len;\n\tvoid *data;\n\tbool ret = false;\n\tunsigned int orig_len;\n\tint n = 2, nfrags, pad = 0;\n\tu16 hdrlen;\n\n\tif (!ieee80211_hw_check(&local->hw, TX_AMSDU))\n\t\treturn false;\n\n\tif (sdata->vif.offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED)\n\t\treturn false;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\treturn false;\n\n\tif (skb_is_gso(skb))\n\t\treturn false;\n\n\tif (!txq)\n\t\treturn false;\n\n\ttxqi = to_txq_info(txq);\n\tif (test_bit(IEEE80211_TXQ_NO_AMSDU, &txqi->flags))\n\t\treturn false;\n\n\tif (sta->sta.cur->max_rc_amsdu_len)\n\t\tmax_amsdu_len = min_t(int, max_amsdu_len,\n\t\t\t\t      sta->sta.cur->max_rc_amsdu_len);\n\n\tif (sta->sta.cur->max_tid_amsdu_len[tid])\n\t\tmax_amsdu_len = min_t(int, max_amsdu_len,\n\t\t\t\t      sta->sta.cur->max_tid_amsdu_len[tid]);\n\n\tflow_idx = fq_flow_idx(fq, skb);\n\n\tspin_lock_bh(&fq->lock);\n\n\t \n\n\ttin = &txqi->tin;\n\tflow = fq_flow_classify(fq, tin, flow_idx, skb);\n\thead = skb_peek_tail(&flow->queue);\n\tif (!head || skb_is_gso(head))\n\t\tgoto out;\n\n\torig_truesize = head->truesize;\n\torig_len = head->len;\n\n\tif (skb->len + head->len > max_amsdu_len)\n\t\tgoto out;\n\n\tnfrags = 1 + skb_shinfo(skb)->nr_frags;\n\tnfrags += 1 + skb_shinfo(head)->nr_frags;\n\tfrag_tail = &skb_shinfo(head)->frag_list;\n\twhile (*frag_tail) {\n\t\tnfrags += 1 + skb_shinfo(*frag_tail)->nr_frags;\n\t\tfrag_tail = &(*frag_tail)->next;\n\t\tn++;\n\t}\n\n\tif (max_subframes && n > max_subframes)\n\t\tgoto out;\n\n\tif (max_frags && nfrags > max_frags)\n\t\tgoto out;\n\n\tif (!drv_can_aggregate_in_amsdu(local, head, skb))\n\t\tgoto out;\n\n\tif (!ieee80211_amsdu_prepare_head(sdata, fast_tx, head))\n\t\tgoto out;\n\n\t \n\tif (n == 2)\n\t\tfrag_tail = &skb_shinfo(head)->frag_list;\n\n\t \n\thdrlen = fast_tx->hdr_len - sizeof(rfc1042_header);\n\tif ((head->len - hdrlen) & 3)\n\t\tpad = 4 - ((head->len - hdrlen) & 3);\n\n\tif (!ieee80211_amsdu_realloc_pad(local, skb, sizeof(rfc1042_header) +\n\t\t\t\t\t\t     2 + pad))\n\t\tgoto out_recalc;\n\n\tret = true;\n\tdata = skb_push(skb, ETH_ALEN + 2);\n\tether_addr_copy(data, da);\n\tether_addr_copy(data + ETH_ALEN, sa);\n\n\tdata += 2 * ETH_ALEN;\n\tlen = cpu_to_be16(subframe_len);\n\tmemcpy(data, &len, 2);\n\tmemcpy(data + 2, rfc1042_header, sizeof(rfc1042_header));\n\n\tmemset(skb_push(skb, pad), 0, pad);\n\n\thead->len += skb->len;\n\thead->data_len += skb->len;\n\t*frag_tail = skb;\n\nout_recalc:\n\tfq->memory_usage += head->truesize - orig_truesize;\n\tif (head->len != orig_len) {\n\t\tflow->backlog += head->len - orig_len;\n\t\ttin->backlog_bytes += head->len - orig_len;\n\t}\nout:\n\tspin_unlock_bh(&fq->lock);\n\n\treturn ret;\n}\n\n \nstatic ieee80211_tx_result\nieee80211_xmit_fast_finish(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct sta_info *sta, u8 pn_offs,\n\t\t\t   struct ieee80211_key *key,\n\t\t\t   struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb = tx->skb;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tu8 tid = IEEE80211_NUM_TIDS;\n\n\tif (!ieee80211_hw_check(&tx->local->hw, HAS_RATE_CONTROL) &&\n\t    ieee80211_tx_h_rate_ctrl(tx) != TX_CONTINUE)\n\t\treturn TX_DROP;\n\n\tif (key)\n\t\tinfo->control.hw_key = &key->conf;\n\n\tdev_sw_netstats_tx_add(skb->dev, 1, skb->len);\n\n\tif (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {\n\t\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\t\thdr->seq_ctrl = ieee80211_tx_next_seq(sta, tid);\n\t} else {\n\t\tinfo->flags |= IEEE80211_TX_CTL_ASSIGN_SEQ;\n\t\thdr->seq_ctrl = cpu_to_le16(sdata->sequence_number);\n\t\tsdata->sequence_number += 0x10;\n\t}\n\n\tif (skb_shinfo(skb)->gso_size)\n\t\tsta->deflink.tx_stats.msdu[tid] +=\n\t\t\tDIV_ROUND_UP(skb->len, skb_shinfo(skb)->gso_size);\n\telse\n\t\tsta->deflink.tx_stats.msdu[tid]++;\n\n\tinfo->hw_queue = sdata->vif.hw_queue[skb_get_queue_mapping(skb)];\n\n\t \n\tsta->deflink.tx_stats.bytes[skb_get_queue_mapping(skb)] += skb->len;\n\tsta->deflink.tx_stats.packets[skb_get_queue_mapping(skb)]++;\n\n\tif (pn_offs) {\n\t\tu64 pn;\n\t\tu8 *crypto_hdr = skb->data + pn_offs;\n\n\t\tswitch (key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tpn = atomic64_inc_return(&key->conf.tx_pn);\n\t\t\tcrypto_hdr[0] = pn;\n\t\t\tcrypto_hdr[1] = pn >> 8;\n\t\t\tcrypto_hdr[3] = 0x20 | (key->conf.keyidx << 6);\n\t\t\tcrypto_hdr[4] = pn >> 16;\n\t\t\tcrypto_hdr[5] = pn >> 24;\n\t\t\tcrypto_hdr[6] = pn >> 32;\n\t\t\tcrypto_hdr[7] = pn >> 40;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nstatic netdev_features_t\nieee80211_sdata_netdev_features(struct ieee80211_sub_if_data *sdata)\n{\n\tif (sdata->vif.type != NL80211_IFTYPE_AP_VLAN)\n\t\treturn sdata->vif.netdev_features;\n\n\tif (!sdata->bss)\n\t\treturn 0;\n\n\tsdata = container_of(sdata->bss, struct ieee80211_sub_if_data, u.ap);\n\treturn sdata->vif.netdev_features;\n}\n\nstatic struct sk_buff *\nieee80211_tx_skb_fixup(struct sk_buff *skb, netdev_features_t features)\n{\n\tif (skb_is_gso(skb)) {\n\t\tstruct sk_buff *segs;\n\n\t\tsegs = skb_gso_segment(skb, features);\n\t\tif (!segs)\n\t\t\treturn skb;\n\t\tif (IS_ERR(segs))\n\t\t\tgoto free;\n\n\t\tconsume_skb(skb);\n\t\treturn segs;\n\t}\n\n\tif (skb_needs_linearize(skb, features) && __skb_linearize(skb))\n\t\tgoto free;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tint ofs = skb_checksum_start_offset(skb);\n\n\t\tif (skb->encapsulation)\n\t\t\tskb_set_inner_transport_header(skb, ofs);\n\t\telse\n\t\t\tskb_set_transport_header(skb, ofs);\n\n\t\tif (skb_csum_hwoffload_help(skb, features))\n\t\t\tgoto free;\n\t}\n\n\tskb_mark_not_on_list(skb);\n\treturn skb;\n\nfree:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nvoid __ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct sta_info *sta,\n\t\t\t   struct ieee80211_fast_tx *fast_tx,\n\t\t\t   struct sk_buff *skb, bool ampdu,\n\t\t\t   const u8 *da, const u8 *sa)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_hdr *hdr = (void *)fast_tx->hdr;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_tx_data tx;\n\tieee80211_tx_result r;\n\tint hw_headroom = sdata->local->hw.extra_tx_headroom;\n\tint extra_head = fast_tx->hdr_len - (ETH_HLEN - 2);\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn;\n\n\tif ((hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) &&\n\t    ieee80211_amsdu_aggregate(sdata, sta, fast_tx, skb, da, sa))\n\t\treturn;\n\n\t \n\tif (unlikely(ieee80211_skb_resize(sdata, skb,\n\t\t\t\t\t  max_t(int, extra_head + hw_headroom -\n\t\t\t\t\t\t     skb_headroom(skb), 0),\n\t\t\t\t\t  ENCRYPT_NO)))\n\t\tgoto free;\n\n\thdr = skb_push(skb, extra_head);\n\tmemcpy(skb->data, fast_tx->hdr, fast_tx->hdr_len);\n\tmemcpy(skb->data + fast_tx->da_offs, da, ETH_ALEN);\n\tmemcpy(skb->data + fast_tx->sa_offs, sa, ETH_ALEN);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tmemset(info, 0, sizeof(*info));\n\tinfo->band = fast_tx->band;\n\tinfo->control.vif = &sdata->vif;\n\tinfo->flags = IEEE80211_TX_CTL_FIRST_FRAGMENT |\n\t\t      IEEE80211_TX_CTL_DONTFRAG;\n\tinfo->control.flags = IEEE80211_TX_CTRL_FAST_XMIT |\n\t\t\t      u32_encode_bits(IEEE80211_LINK_UNSPECIFIED,\n\t\t\t\t\t      IEEE80211_TX_CTRL_MLO_LINK);\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tif (local->force_tx_status)\n\t\tinfo->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n#endif\n\n\tif (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {\n\t\tu8 tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\n\t\t*ieee80211_get_qos_ctl(hdr) = tid;\n\t}\n\n\t__skb_queue_head_init(&tx.skbs);\n\n\ttx.flags = IEEE80211_TX_UNICAST;\n\ttx.local = local;\n\ttx.sdata = sdata;\n\ttx.sta = sta;\n\ttx.key = fast_tx->key;\n\n\tif (ieee80211_queue_skb(local, sdata, sta, skb))\n\t\treturn;\n\n\ttx.skb = skb;\n\tr = ieee80211_xmit_fast_finish(sdata, sta, fast_tx->pn_offs,\n\t\t\t\t       fast_tx->key, &tx);\n\ttx.skb = NULL;\n\tif (r == TX_DROP)\n\t\tgoto free;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\n\t__skb_queue_tail(&tx.skbs, skb);\n\tieee80211_tx_frags(local, &sdata->vif, sta, &tx.skbs, false);\n\treturn;\n\nfree:\n\tkfree_skb(skb);\n}\n\nstatic bool ieee80211_xmit_fast(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sta_info *sta,\n\t\t\t\tstruct ieee80211_fast_tx *fast_tx,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tu16 ethertype = (skb->data[12] << 8) | skb->data[13];\n\tstruct ieee80211_hdr *hdr = (void *)fast_tx->hdr;\n\tstruct tid_ampdu_tx *tid_tx = NULL;\n\tstruct sk_buff *next;\n\tstruct ethhdr eth;\n\tu8 tid = IEEE80211_NUM_TIDS;\n\n\t \n\tif (cpu_to_be16(ethertype) == sdata->control_port_protocol)\n\t\treturn false;\n\n\t \n\tif (ethertype < ETH_P_802_3_MIN)\n\t\treturn false;\n\n\t \n\tif (skb->sk && skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS)\n\t\treturn false;\n\n\tif (hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {\n\t\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\t\ttid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\n\t\tif (tid_tx) {\n\t\t\tif (!test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state))\n\t\t\t\treturn false;\n\t\t\tif (tid_tx->timeout)\n\t\t\t\ttid_tx->last_tx = jiffies;\n\t\t}\n\t}\n\n\tmemcpy(&eth, skb->data, ETH_HLEN - 2);\n\n\t \n\tskb = ieee80211_tx_skb_fixup(skb, ieee80211_sdata_netdev_features(sdata));\n\tif (!skb)\n\t\treturn true;\n\n\tskb_list_walk_safe(skb, skb, next) {\n\t\tskb_mark_not_on_list(skb);\n\t\t__ieee80211_xmit_fast(sdata, sta, fast_tx, skb, tid_tx,\n\t\t\t\t      eth.h_dest, eth.h_source);\n\t}\n\n\treturn true;\n}\n\nstruct sk_buff *ieee80211_tx_dequeue(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_txq *txq)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct txq_info *txqi = container_of(txq, struct txq_info, txq);\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb = NULL;\n\tstruct fq *fq = &local->fq;\n\tstruct fq_tin *tin = &txqi->tin;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_tx_data tx;\n\tieee80211_tx_result r;\n\tstruct ieee80211_vif *vif = txq->vif;\n\tint q = vif->hw_queue[txq->ac];\n\tunsigned long flags;\n\tbool q_stopped;\n\n\tWARN_ON_ONCE(softirq_count() == 0);\n\n\tif (!ieee80211_txq_airtime_check(hw, txq))\n\t\treturn NULL;\n\nbegin:\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\tq_stopped = local->queue_stop_reasons[q];\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\tif (unlikely(q_stopped)) {\n\t\t \n\t\tset_bit(IEEE80211_TXQ_DIRTY, &txqi->flags);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_bh(&fq->lock);\n\n\t \n\tskb = __skb_dequeue(&txqi->frags);\n\tif (unlikely(skb)) {\n\t\tif (!(IEEE80211_SKB_CB(skb)->control.flags &\n\t\t\t\tIEEE80211_TX_INTCFL_NEED_TXPROCESSING))\n\t\t\tgoto out;\n\t\tIEEE80211_SKB_CB(skb)->control.flags &=\n\t\t\t~IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\t} else {\n\t\tif (unlikely(test_bit(IEEE80211_TXQ_STOP, &txqi->flags)))\n\t\t\tgoto out;\n\n\t\tskb = fq_tin_dequeue(fq, tin, fq_tin_dequeue_func);\n\t}\n\n\tif (!skb)\n\t\tgoto out;\n\n\tspin_unlock_bh(&fq->lock);\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tmemset(&tx, 0, sizeof(tx));\n\t__skb_queue_head_init(&tx.skbs);\n\ttx.local = local;\n\ttx.skb = skb;\n\ttx.sdata = vif_to_sdata(info->control.vif);\n\n\tif (txq->sta) {\n\t\ttx.sta = container_of(txq->sta, struct sta_info, sta);\n\t\t \n\t\tif (unlikely(!(info->flags & IEEE80211_TX_CTL_INJECTED) &&\n\t\t\t     ieee80211_is_data(hdr->frame_control) &&\n\t\t\t     !ieee80211_vif_is_mesh(&tx.sdata->vif) &&\n\t\t\t     tx.sdata->vif.type != NL80211_IFTYPE_OCB &&\n\t\t\t     !is_multicast_ether_addr(hdr->addr1) &&\n\t\t\t     !test_sta_flag(tx.sta, WLAN_STA_AUTHORIZED) &&\n\t\t\t     (!(info->control.flags &\n\t\t\t\tIEEE80211_TX_CTRL_PORT_CTRL_PROTO) ||\n\t\t\t      !ieee80211_is_our_addr(tx.sdata, hdr->addr2,\n\t\t\t\t\t\t     NULL)))) {\n\t\t\tI802_DEBUG_INC(local->tx_handlers_drop_unauth_port);\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\n\t \n\tr = ieee80211_tx_h_select_key(&tx);\n\tif (r != TX_CONTINUE) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\tgoto begin;\n\t}\n\n\tif (test_bit(IEEE80211_TXQ_AMPDU, &txqi->flags))\n\t\tinfo->flags |= (IEEE80211_TX_CTL_AMPDU |\n\t\t\t\tIEEE80211_TX_CTL_DONTFRAG);\n\n\tif (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) {\n\t\tif (!ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL)) {\n\t\t\tr = ieee80211_tx_h_rate_ctrl(&tx);\n\t\t\tif (r != TX_CONTINUE) {\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tgoto begin;\n\t\t\t}\n\t\t}\n\t\tgoto encap_out;\n\t}\n\n\tif (info->control.flags & IEEE80211_TX_CTRL_FAST_XMIT) {\n\t\tstruct sta_info *sta = container_of(txq->sta, struct sta_info,\n\t\t\t\t\t\t    sta);\n\t\tu8 pn_offs = 0;\n\n\t\tif (tx.key &&\n\t\t    (tx.key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV))\n\t\t\tpn_offs = ieee80211_hdrlen(hdr->frame_control);\n\n\t\tr = ieee80211_xmit_fast_finish(sta->sdata, sta, pn_offs,\n\t\t\t\t\t       tx.key, &tx);\n\t\tif (r != TX_CONTINUE) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tgoto begin;\n\t\t}\n\t} else {\n\t\tif (invoke_tx_handlers_late(&tx))\n\t\t\tgoto begin;\n\n\t\tskb = __skb_dequeue(&tx.skbs);\n\n\t\tif (!skb_queue_empty(&tx.skbs)) {\n\t\t\tspin_lock_bh(&fq->lock);\n\t\t\tskb_queue_splice_tail(&tx.skbs, &txqi->frags);\n\t\t\tspin_unlock_bh(&fq->lock);\n\t\t}\n\t}\n\n\tif (skb_has_frag_list(skb) &&\n\t    !ieee80211_hw_check(&local->hw, TX_FRAG_LIST)) {\n\t\tif (skb_linearize(skb)) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\n\tswitch (tx.sdata->vif.type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (tx.sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) {\n\t\t\tvif = &tx.sdata->vif;\n\t\t\tbreak;\n\t\t}\n\t\ttx.sdata = rcu_dereference(local->monitor_sdata);\n\t\tif (tx.sdata) {\n\t\t\tvif = &tx.sdata->vif;\n\t\t\tinfo->hw_queue =\n\t\t\t\tvif->hw_queue[skb_get_queue_mapping(skb)];\n\t\t} else if (ieee80211_hw_check(&local->hw, QUEUE_CONTROL)) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tgoto begin;\n\t\t} else {\n\t\t\tvif = NULL;\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\ttx.sdata = container_of(tx.sdata->bss,\n\t\t\t\t\tstruct ieee80211_sub_if_data, u.ap);\n\t\tfallthrough;\n\tdefault:\n\t\tvif = &tx.sdata->vif;\n\t\tbreak;\n\t}\n\nencap_out:\n\tIEEE80211_SKB_CB(skb)->control.vif = vif;\n\n\tif (tx.sta &&\n\t    wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL)) {\n\t\tbool ampdu = txq->ac != IEEE80211_AC_VO;\n\t\tu32 airtime;\n\n\t\tairtime = ieee80211_calc_expected_tx_airtime(hw, vif, txq->sta,\n\t\t\t\t\t\t\t     skb->len, ampdu);\n\t\tif (airtime) {\n\t\t\tairtime = ieee80211_info_set_tx_time_est(info, airtime);\n\t\t\tieee80211_sta_update_pending_airtime(local, tx.sta,\n\t\t\t\t\t\t\t     txq->ac,\n\t\t\t\t\t\t\t     airtime,\n\t\t\t\t\t\t\t     false);\n\t\t}\n\t}\n\n\treturn skb;\n\nout:\n\tspin_unlock_bh(&fq->lock);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_tx_dequeue);\n\nstatic inline s32 ieee80211_sta_deficit(struct sta_info *sta, u8 ac)\n{\n\tstruct airtime_info *air_info = &sta->airtime[ac];\n\n\treturn air_info->deficit - atomic_read(&air_info->aql_tx_pending);\n}\n\nstatic void\nieee80211_txq_set_active(struct txq_info *txqi)\n{\n\tstruct sta_info *sta;\n\n\tif (!txqi->txq.sta)\n\t\treturn;\n\n\tsta = container_of(txqi->txq.sta, struct sta_info, sta);\n\tsta->airtime[txqi->txq.ac].last_active = (u32)jiffies;\n}\n\nstatic bool\nieee80211_txq_keep_active(struct txq_info *txqi)\n{\n\tstruct sta_info *sta;\n\tu32 diff;\n\n\tif (!txqi->txq.sta)\n\t\treturn false;\n\n\tsta = container_of(txqi->txq.sta, struct sta_info, sta);\n\tif (ieee80211_sta_deficit(sta, txqi->txq.ac) >= 0)\n\t\treturn false;\n\n\tdiff = (u32)jiffies - sta->airtime[txqi->txq.ac].last_active;\n\n\treturn diff <= AIRTIME_ACTIVE_DURATION;\n}\n\nstruct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_txq *ret = NULL;\n\tstruct txq_info *txqi = NULL, *head = NULL;\n\tbool found_eligible_txq = false;\n\n\tspin_lock_bh(&local->active_txq_lock[ac]);\n\n\tif (!local->schedule_round[ac])\n\t\tgoto out;\n\n begin:\n\ttxqi = list_first_entry_or_null(&local->active_txqs[ac],\n\t\t\t\t\tstruct txq_info,\n\t\t\t\t\tschedule_order);\n\tif (!txqi)\n\t\tgoto out;\n\n\tif (txqi == head) {\n\t\tif (!found_eligible_txq)\n\t\t\tgoto out;\n\t\telse\n\t\t\tfound_eligible_txq = false;\n\t}\n\n\tif (!head)\n\t\thead = txqi;\n\n\tif (txqi->txq.sta) {\n\t\tstruct sta_info *sta = container_of(txqi->txq.sta,\n\t\t\t\t\t\t    struct sta_info, sta);\n\t\tbool aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);\n\t\ts32 deficit = ieee80211_sta_deficit(sta, txqi->txq.ac);\n\n\t\tif (aql_check)\n\t\t\tfound_eligible_txq = true;\n\n\t\tif (deficit < 0)\n\t\t\tsta->airtime[txqi->txq.ac].deficit +=\n\t\t\t\tsta->airtime_weight;\n\n\t\tif (deficit < 0 || !aql_check) {\n\t\t\tlist_move_tail(&txqi->schedule_order,\n\t\t\t\t       &local->active_txqs[txqi->txq.ac]);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\n\tif (txqi->schedule_round == local->schedule_round[ac])\n\t\tgoto out;\n\n\tlist_del_init(&txqi->schedule_order);\n\ttxqi->schedule_round = local->schedule_round[ac];\n\tret = &txqi->txq;\n\nout:\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_next_txq);\n\nvoid __ieee80211_schedule_txq(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_txq *txq,\n\t\t\t      bool force)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct txq_info *txqi = to_txq_info(txq);\n\tbool has_queue;\n\n\tspin_lock_bh(&local->active_txq_lock[txq->ac]);\n\n\thas_queue = force || txq_has_queue(txq);\n\tif (list_empty(&txqi->schedule_order) &&\n\t    (has_queue || ieee80211_txq_keep_active(txqi))) {\n\t\t \n\t\tif (txqi->txq.sta && local->airtime_flags && has_queue &&\n\t\t    wiphy_ext_feature_isset(local->hw.wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\t\tlist_add(&txqi->schedule_order,\n\t\t\t\t &local->active_txqs[txq->ac]);\n\t\telse\n\t\t\tlist_add_tail(&txqi->schedule_order,\n\t\t\t\t      &local->active_txqs[txq->ac]);\n\t\tif (has_queue)\n\t\t\tieee80211_txq_set_active(txqi);\n\t}\n\n\tspin_unlock_bh(&local->active_txq_lock[txq->ac]);\n}\nEXPORT_SYMBOL(__ieee80211_schedule_txq);\n\nDEFINE_STATIC_KEY_FALSE(aql_disable);\n\nbool ieee80211_txq_airtime_check(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_txq *txq)\n{\n\tstruct sta_info *sta;\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tif (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))\n\t\treturn true;\n\n\tif (static_branch_unlikely(&aql_disable))\n\t\treturn true;\n\n\tif (!txq->sta)\n\t\treturn true;\n\n\tif (unlikely(txq->tid == IEEE80211_NUM_TIDS))\n\t\treturn true;\n\n\tsta = container_of(txq->sta, struct sta_info, sta);\n\tif (atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <\n\t    sta->airtime[txq->ac].aql_limit_low)\n\t\treturn true;\n\n\tif (atomic_read(&local->aql_total_pending_airtime) <\n\t    local->aql_threshold &&\n\t    atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <\n\t    sta->airtime[txq->ac].aql_limit_high)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(ieee80211_txq_airtime_check);\n\nstatic bool\nieee80211_txq_schedule_airtime_check(struct ieee80211_local *local, u8 ac)\n{\n\tunsigned int num_txq = 0;\n\tstruct txq_info *txq;\n\tu32 aql_limit;\n\n\tif (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))\n\t\treturn true;\n\n\tlist_for_each_entry(txq, &local->active_txqs[ac], schedule_order)\n\t\tnum_txq++;\n\n\taql_limit = (num_txq - 1) * local->aql_txq_limit_low[ac] / 2 +\n\t\t    local->aql_txq_limit_high[ac];\n\n\treturn atomic_read(&local->aql_ac_pending_airtime[ac]) < aql_limit;\n}\n\nbool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_txq *txq)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct txq_info *iter, *tmp, *txqi = to_txq_info(txq);\n\tstruct sta_info *sta;\n\tu8 ac = txq->ac;\n\n\tspin_lock_bh(&local->active_txq_lock[ac]);\n\n\tif (!txqi->txq.sta)\n\t\tgoto out;\n\n\tif (list_empty(&txqi->schedule_order))\n\t\tgoto out;\n\n\tif (!ieee80211_txq_schedule_airtime_check(local, ac))\n\t\tgoto out;\n\n\tlist_for_each_entry_safe(iter, tmp, &local->active_txqs[ac],\n\t\t\t\t schedule_order) {\n\t\tif (iter == txqi)\n\t\t\tbreak;\n\n\t\tif (!iter->txq.sta) {\n\t\t\tlist_move_tail(&iter->schedule_order,\n\t\t\t\t       &local->active_txqs[ac]);\n\t\t\tcontinue;\n\t\t}\n\t\tsta = container_of(iter->txq.sta, struct sta_info, sta);\n\t\tif (ieee80211_sta_deficit(sta, ac) < 0)\n\t\t\tsta->airtime[ac].deficit += sta->airtime_weight;\n\t\tlist_move_tail(&iter->schedule_order, &local->active_txqs[ac]);\n\t}\n\n\tsta = container_of(txqi->txq.sta, struct sta_info, sta);\n\tif (sta->airtime[ac].deficit >= 0)\n\t\tgoto out;\n\n\tsta->airtime[ac].deficit += sta->airtime_weight;\n\tlist_move_tail(&txqi->schedule_order, &local->active_txqs[ac]);\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n\n\treturn false;\nout:\n\tif (!list_empty(&txqi->schedule_order))\n\t\tlist_del_init(&txqi->schedule_order);\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n\n\treturn true;\n}\nEXPORT_SYMBOL(ieee80211_txq_may_transmit);\n\nvoid ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tspin_lock_bh(&local->active_txq_lock[ac]);\n\n\tif (ieee80211_txq_schedule_airtime_check(local, ac)) {\n\t\tlocal->schedule_round[ac]++;\n\t\tif (!local->schedule_round[ac])\n\t\t\tlocal->schedule_round[ac]++;\n\t} else {\n\t\tlocal->schedule_round[ac] = 0;\n\t}\n\n\tspin_unlock_bh(&local->active_txq_lock[ac]);\n}\nEXPORT_SYMBOL(ieee80211_txq_schedule_start);\n\nvoid __ieee80211_subif_start_xmit(struct sk_buff *skb,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  u32 info_flags,\n\t\t\t\t  u32 ctrl_flags,\n\t\t\t\t  u64 *cookie)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct sk_buff *next;\n\tint len = skb->len;\n\n\tif (unlikely(!ieee80211_sdata_running(sdata) || skb->len < ETH_HLEN)) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tsk_pacing_shift_update(skb->sk, sdata->local->hw.tx_sk_pacing_shift);\n\n\trcu_read_lock();\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif) &&\n\t    ieee80211_hw_check(&local->hw, SUPPORT_FAST_XMIT) &&\n\t    ieee80211_mesh_xmit_fast(sdata, skb, ctrl_flags))\n\t\tgoto out;\n\n\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta))\n\t\tgoto out_free;\n\n\tif (IS_ERR(sta))\n\t\tsta = NULL;\n\n\tskb_set_queue_mapping(skb, ieee80211_select_queue(sdata, sta, skb));\n\tieee80211_aggr_check(sdata, sta, skb);\n\n\tif (sta) {\n\t\tstruct ieee80211_fast_tx *fast_tx;\n\n\t\tfast_tx = rcu_dereference(sta->fast_tx);\n\n\t\tif (fast_tx &&\n\t\t    ieee80211_xmit_fast(sdata, sta, fast_tx, skb))\n\t\t\tgoto out;\n\t}\n\n\t \n\tskb = ieee80211_tx_skb_fixup(skb, 0);\n\tif (!skb) {\n\t\tlen = 0;\n\t\tgoto out;\n\t}\n\n\tskb_list_walk_safe(skb, skb, next) {\n\t\tskb_mark_not_on_list(skb);\n\n\t\tif (skb->protocol == sdata->control_port_protocol)\n\t\t\tctrl_flags |= IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP;\n\n\t\tskb = ieee80211_build_hdr(sdata, skb, info_flags,\n\t\t\t\t\t  sta, ctrl_flags, cookie);\n\t\tif (IS_ERR(skb)) {\n\t\t\tkfree_skb_list(next);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdev_sw_netstats_tx_add(dev, 1, skb->len);\n\n\t\tieee80211_xmit(sdata, sta, skb);\n\t}\n\tgoto out;\n out_free:\n\tkfree_skb(skb);\n\tlen = 0;\n out:\n\tif (len)\n\t\tieee80211_tpt_led_trig_tx(local, len);\n\trcu_read_unlock();\n}\n\nstatic int ieee80211_change_da(struct sk_buff *skb, struct sta_info *sta)\n{\n\tstruct ethhdr *eth;\n\tint err;\n\n\terr = skb_ensure_writable(skb, ETH_HLEN);\n\tif (unlikely(err))\n\t\treturn err;\n\n\teth = (void *)skb->data;\n\tether_addr_copy(eth->h_dest, sta->sta.addr);\n\n\treturn 0;\n}\n\nstatic bool ieee80211_multicast_to_unicast(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tconst struct ethhdr *eth = (void *)skb->data;\n\tconst struct vlan_ethhdr *ethvlan = (void *)skb->data;\n\t__be16 ethertype;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (sdata->u.vlan.sta)\n\t\t\treturn false;\n\t\tif (sdata->wdev.use_4addr)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\t \n\t\tif (!sdata->bss->multicast_to_unicast)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t \n\tethertype = eth->h_proto;\n\tif (ethertype == htons(ETH_P_8021Q) && skb->len >= VLAN_ETH_HLEN)\n\t\tethertype = ethvlan->h_vlan_encapsulated_proto;\n\tswitch (ethertype) {\n\tcase htons(ETH_P_ARP):\n\tcase htons(ETH_P_IP):\n\tcase htons(ETH_P_IPV6):\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void\nieee80211_convert_to_unicast(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     struct sk_buff_head *queue)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tconst struct ethhdr *eth = (struct ethhdr *)skb->data;\n\tstruct sta_info *sta, *first = NULL;\n\tstruct sk_buff *cloned_skb;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\t \n\t\t\tcontinue;\n\t\tif (unlikely(ether_addr_equal(eth->h_source, sta->sta.addr)))\n\t\t\t \n\t\t\tcontinue;\n\t\tif (!first) {\n\t\t\tfirst = sta;\n\t\t\tcontinue;\n\t\t}\n\t\tcloned_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!cloned_skb)\n\t\t\tgoto multicast;\n\t\tif (unlikely(ieee80211_change_da(cloned_skb, sta))) {\n\t\t\tdev_kfree_skb(cloned_skb);\n\t\t\tgoto multicast;\n\t\t}\n\t\t__skb_queue_tail(queue, cloned_skb);\n\t}\n\n\tif (likely(first)) {\n\t\tif (unlikely(ieee80211_change_da(skb, first)))\n\t\t\tgoto multicast;\n\t\t__skb_queue_tail(queue, skb);\n\t} else {\n\t\t \n\t\tkfree_skb(skb);\n\t\tskb = NULL;\n\t}\n\n\tgoto out;\nmulticast:\n\t__skb_queue_purge(queue);\n\t__skb_queue_tail(queue, skb);\nout:\n\trcu_read_unlock();\n}\n\nstatic void ieee80211_mlo_multicast_tx_one(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct sk_buff *skb, u32 ctrl_flags,\n\t\t\t\t\t   unsigned int link_id)\n{\n\tstruct sk_buff *out;\n\n\tout = skb_copy(skb, GFP_ATOMIC);\n\tif (!out)\n\t\treturn;\n\n\tctrl_flags |= u32_encode_bits(link_id, IEEE80211_TX_CTRL_MLO_LINK);\n\t__ieee80211_subif_start_xmit(out, sdata->dev, 0, ctrl_flags, NULL);\n}\n\nstatic void ieee80211_mlo_multicast_tx(struct net_device *dev,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tunsigned long links = sdata->vif.active_links;\n\tunsigned int link;\n\tu32 ctrl_flags = IEEE80211_TX_CTRL_MCAST_MLO_FIRST_TX;\n\n\tif (hweight16(links) == 1) {\n\t\tctrl_flags |= u32_encode_bits(__ffs(links),\n\t\t\t\t\t      IEEE80211_TX_CTRL_MLO_LINK);\n\n\t\t__ieee80211_subif_start_xmit(skb, sdata->dev, 0, ctrl_flags,\n\t\t\t\t\t     NULL);\n\t\treturn;\n\t}\n\n\tfor_each_set_bit(link, &links, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tieee80211_mlo_multicast_tx_one(sdata, skb, ctrl_flags, link);\n\t\tctrl_flags = 0;\n\t}\n\tkfree_skb(skb);\n}\n\n \nnetdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tconst struct ethhdr *eth = (void *)skb->data;\n\n\tif (likely(!is_multicast_ether_addr(eth->h_dest)))\n\t\tgoto normal;\n\n\tif (unlikely(!ieee80211_sdata_running(sdata))) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (unlikely(ieee80211_multicast_to_unicast(skb, dev))) {\n\t\tstruct sk_buff_head queue;\n\n\t\t__skb_queue_head_init(&queue);\n\t\tieee80211_convert_to_unicast(skb, dev, &queue);\n\t\twhile ((skb = __skb_dequeue(&queue)))\n\t\t\t__ieee80211_subif_start_xmit(skb, dev, 0,\n\t\t\t\t\t\t     IEEE80211_TX_CTRL_MLO_LINK_UNSPEC,\n\t\t\t\t\t\t     NULL);\n\t} else if (ieee80211_vif_is_mld(&sdata->vif) &&\n\t\t   sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t   !ieee80211_hw_check(&sdata->local->hw, MLO_MCAST_MULTI_LINK_TX)) {\n\t\tieee80211_mlo_multicast_tx(dev, skb);\n\t} else {\nnormal:\n\t\t__ieee80211_subif_start_xmit(skb, dev, 0,\n\t\t\t\t\t     IEEE80211_TX_CTRL_MLO_LINK_UNSPEC,\n\t\t\t\t\t     NULL);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n\n\nstatic bool __ieee80211_tx_8023(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sk_buff *skb, struct sta_info *sta,\n\t\t\t\tbool txpending)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_control control = {};\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sta *pubsta = NULL;\n\tunsigned long flags;\n\tint q = info->hw_queue;\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\n\tif (local->queue_stop_reasons[q] ||\n\t    (!txpending && !skb_queue_empty(&local->pending[q]))) {\n\t\tif (txpending)\n\t\t\tskb_queue_head(&local->pending[q], skb);\n\t\telse\n\t\t\tskb_queue_tail(&local->pending[q], skb);\n\n\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\t\treturn false;\n\t}\n\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\tif (sta && sta->uploaded)\n\t\tpubsta = &sta->sta;\n\n\tcontrol.sta = pubsta;\n\n\tdrv_tx(local, &control, skb);\n\n\treturn true;\n}\n\nstatic bool ieee80211_tx_8023(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct sk_buff *skb, struct sta_info *sta,\n\t\t\t      bool txpending)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *next;\n\tbool ret = true;\n\n\tif (ieee80211_queue_skb(local, sdata, sta, skb))\n\t\treturn true;\n\n\tskb_list_walk_safe(skb, skb, next) {\n\t\tskb_mark_not_on_list(skb);\n\t\tif (!__ieee80211_tx_8023(sdata, skb, sta, txpending))\n\t\t\tret = false;\n\t}\n\n\treturn ret;\n}\n\nstatic void ieee80211_8023_xmit(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct net_device *dev, struct sta_info *sta,\n\t\t\t\tstruct ieee80211_key *key, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct tid_ampdu_tx *tid_tx;\n\tstruct sk_buff *seg, *next;\n\tunsigned int skbs = 0, len = 0;\n\tu16 queue;\n\tu8 tid;\n\n\tqueue = ieee80211_select_queue(sdata, sta, skb);\n\tskb_set_queue_mapping(skb, queue);\n\n\tif (unlikely(test_bit(SCAN_SW_SCANNING, &local->scanning)) &&\n\t    test_bit(SDATA_STATE_OFFCHANNEL, &sdata->state))\n\t\tgoto out_free;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn;\n\n\tieee80211_aggr_check(sdata, sta, skb);\n\n\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\ttid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\n\tif (tid_tx) {\n\t\tif (!test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state)) {\n\t\t\t \n\t\t\t__ieee80211_subif_start_xmit(skb, dev, 0,\n\t\t\t\t\t\t     IEEE80211_TX_CTRL_MLO_LINK_UNSPEC,\n\t\t\t\t\t\t     NULL);\n\t\t\treturn;\n\t\t}\n\n\t\tif (tid_tx->timeout)\n\t\t\ttid_tx->last_tx = jiffies;\n\t}\n\n\tskb = ieee80211_tx_skb_fixup(skb, ieee80211_sdata_netdev_features(sdata));\n\tif (!skb)\n\t\treturn;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tmemset(info, 0, sizeof(*info));\n\n\tinfo->hw_queue = sdata->vif.hw_queue[queue];\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tsdata = container_of(sdata->bss,\n\t\t\t\t     struct ieee80211_sub_if_data, u.ap);\n\n\tinfo->flags |= IEEE80211_TX_CTL_HW_80211_ENCAP;\n\tinfo->control.vif = &sdata->vif;\n\n\tif (key)\n\t\tinfo->control.hw_key = &key->conf;\n\n\tskb_list_walk_safe(skb, seg, next) {\n\t\tskbs++;\n\t\tlen += seg->len;\n\t\tif (seg != skb)\n\t\t\tmemcpy(IEEE80211_SKB_CB(seg), info, sizeof(*info));\n\t}\n\n\tif (unlikely(skb->sk &&\n\t\t     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS))\n\t\tinfo->ack_frame_id = ieee80211_store_ack_skb(local, skb,\n\t\t\t\t\t\t\t     &info->flags, NULL);\n\n\tdev_sw_netstats_tx_add(dev, skbs, len);\n\tsta->deflink.tx_stats.packets[queue] += skbs;\n\tsta->deflink.tx_stats.bytes[queue] += len;\n\n\tieee80211_tpt_led_trig_tx(local, len);\n\n\tieee80211_tx_8023(sdata, skb, sta, false);\n\n\treturn;\n\nout_free:\n\tkfree_skb(skb);\n}\n\nnetdev_tx_t ieee80211_subif_start_xmit_8023(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ethhdr *ehdr = (struct ethhdr *)skb->data;\n\tstruct ieee80211_key *key;\n\tstruct sta_info *sta;\n\n\tif (unlikely(!ieee80211_sdata_running(sdata) || skb->len < ETH_HLEN)) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\trcu_read_lock();\n\n\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(IS_ERR_OR_NULL(sta) || !sta->uploaded ||\n\t    !test_sta_flag(sta, WLAN_STA_AUTHORIZED) ||\n\t    sdata->control_port_protocol == ehdr->h_proto))\n\t\tgoto skip_offload;\n\n\tkey = rcu_dereference(sta->ptk[sta->ptk_idx]);\n\tif (!key)\n\t\tkey = rcu_dereference(sdata->default_unicast_key);\n\n\tif (key && (!(key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE) ||\n\t\t    key->conf.cipher == WLAN_CIPHER_SUITE_TKIP))\n\t\tgoto skip_offload;\n\n\tsk_pacing_shift_update(skb->sk, sdata->local->hw.tx_sk_pacing_shift);\n\tieee80211_8023_xmit(sdata, dev, sta, key, skb);\n\tgoto out;\n\nskip_offload:\n\tieee80211_subif_start_xmit(skb, dev);\nout:\n\trcu_read_unlock();\n\n\treturn NETDEV_TX_OK;\n}\n\nstruct sk_buff *\nieee80211_build_data_template(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct sk_buff *skb, u32 info_flags)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_tx_data tx = {\n\t\t.local = sdata->local,\n\t\t.sdata = sdata,\n\t};\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\n\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta)) {\n\t\tkfree_skb(skb);\n\t\tskb = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tskb = ieee80211_build_hdr(sdata, skb, info_flags, sta,\n\t\t\t\t  IEEE80211_TX_CTRL_MLO_LINK_UNSPEC, NULL);\n\tif (IS_ERR(skb))\n\t\tgoto out;\n\n\thdr = (void *)skb->data;\n\ttx.sta = sta_info_get(sdata, hdr->addr1);\n\ttx.skb = skb;\n\n\tif (ieee80211_tx_h_select_key(&tx) != TX_CONTINUE) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn skb;\n}\n\n \nvoid ieee80211_clear_tx_pending(struct ieee80211_local *local)\n{\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < local->hw.queues; i++) {\n\t\twhile ((skb = skb_dequeue(&local->pending[i])) != NULL)\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t}\n}\n\n \nstatic bool ieee80211_tx_pending_skb(struct ieee80211_local *local,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\tstruct ieee80211_hdr *hdr;\n\tbool result;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tsdata = vif_to_sdata(info->control.vif);\n\n\tif (info->control.flags & IEEE80211_TX_INTCFL_NEED_TXPROCESSING) {\n\t\t \n\t\tif (!ieee80211_vif_is_mld(&sdata->vif)) {\n\t\t\tchanctx_conf =\n\t\t\t\trcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\t\t\tif (unlikely(!chanctx_conf)) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tinfo->band = chanctx_conf->def.chan->band;\n\t\t}\n\t\tresult = ieee80211_tx(sdata, NULL, skb, true);\n\t} else if (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) {\n\t\tif (ieee80211_lookup_ra_sta(sdata, skb, &sta)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (IS_ERR(sta) || (sta && !sta->uploaded))\n\t\t\tsta = NULL;\n\n\t\tresult = ieee80211_tx_8023(sdata, skb, sta, true);\n\t} else {\n\t\tstruct sk_buff_head skbs;\n\n\t\t__skb_queue_head_init(&skbs);\n\t\t__skb_queue_tail(&skbs, skb);\n\n\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\tsta = sta_info_get(sdata, hdr->addr1);\n\n\t\tresult = __ieee80211_tx(local, &skbs, sta, true);\n\t}\n\n\treturn result;\n}\n\n \nvoid ieee80211_tx_pending(struct tasklet_struct *t)\n{\n\tstruct ieee80211_local *local = from_tasklet(local, t,\n\t\t\t\t\t\t     tx_pending_tasklet);\n\tunsigned long flags;\n\tint i;\n\tbool txok;\n\n\trcu_read_lock();\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\tfor (i = 0; i < local->hw.queues; i++) {\n\t\t \n\t\tif (local->queue_stop_reasons[i] ||\n\t\t    skb_queue_empty(&local->pending[i]))\n\t\t\tcontinue;\n\n\t\twhile (!skb_queue_empty(&local->pending[i])) {\n\t\t\tstruct sk_buff *skb = __skb_dequeue(&local->pending[i]);\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\t\tif (WARN_ON(!info->control.vif)) {\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock,\n\t\t\t\t\t\tflags);\n\n\t\t\ttxok = ieee80211_tx_pending_skb(local, skb);\n\t\t\tspin_lock_irqsave(&local->queue_stop_reason_lock,\n\t\t\t\t\t  flags);\n\t\t\tif (!txok)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\trcu_read_unlock();\n}\n\n \n\nstatic void __ieee80211_beacon_add_tim(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_link_data *link,\n\t\t\t\t       struct ps_data *ps, struct sk_buff *skb,\n\t\t\t\t       bool is_template)\n{\n\tu8 *pos, *tim;\n\tint aid0 = 0;\n\tint i, have_bits = 0, n1, n2;\n\tstruct ieee80211_bss_conf *link_conf = link->conf;\n\n\t \n\tif (atomic_read(&ps->num_sta_ps) > 0)\n\t\t \n\t\thave_bits = !bitmap_empty((unsigned long *)ps->tim,\n\t\t\t\t\t  IEEE80211_MAX_AID+1);\n\tif (!is_template) {\n\t\tif (ps->dtim_count == 0)\n\t\t\tps->dtim_count = link_conf->dtim_period - 1;\n\t\telse\n\t\t\tps->dtim_count--;\n\t}\n\n\ttim = pos = skb_put(skb, 5);\n\t*pos++ = WLAN_EID_TIM;\n\t*pos++ = 3;\n\t*pos++ = ps->dtim_count;\n\t*pos++ = link_conf->dtim_period;\n\n\tif (ps->dtim_count == 0 && !skb_queue_empty(&ps->bc_buf))\n\t\taid0 = 1;\n\n\tps->dtim_bc_mc = aid0 == 1;\n\n\tif (have_bits) {\n\t\t \n\t\tn1 = 0;\n\t\tfor (i = 0; i < IEEE80211_MAX_TIM_LEN; i++) {\n\t\t\tif (ps->tim[i]) {\n\t\t\t\tn1 = i & 0xfe;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tn2 = n1;\n\t\tfor (i = IEEE80211_MAX_TIM_LEN - 1; i >= n1; i--) {\n\t\t\tif (ps->tim[i]) {\n\t\t\t\tn2 = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\t*pos++ = n1 | aid0;\n\t\t \n\t\tskb_put_data(skb, ps->tim + n1, n2 - n1 + 1);\n\n\t\ttim[1] = n2 - n1 + 4;\n\t} else {\n\t\t*pos++ = aid0;  \n\n\t\tif (ieee80211_get_link_sband(link)->band != NL80211_BAND_S1GHZ) {\n\t\t\ttim[1] = 4;\n\t\t\t \n\t\t\tskb_put_u8(skb, 0);\n\t\t}\n\t}\n}\n\nstatic int ieee80211_beacon_add_tim(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_link_data *link,\n\t\t\t\t    struct ps_data *ps, struct sk_buff *skb,\n\t\t\t\t    bool is_template)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\t \n\tif (local->tim_in_locked_section) {\n\t\t__ieee80211_beacon_add_tim(sdata, link, ps, skb, is_template);\n\t} else {\n\t\tspin_lock_bh(&local->tim_lock);\n\t\t__ieee80211_beacon_add_tim(sdata, link, ps, skb, is_template);\n\t\tspin_unlock_bh(&local->tim_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic void ieee80211_set_beacon_cntdwn(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct beacon_data *beacon,\n\t\t\t\t\tstruct ieee80211_link_data *link)\n{\n\tu8 *beacon_data, count, max_count = 1;\n\tstruct probe_resp *resp;\n\tsize_t beacon_data_len;\n\tu16 *bcn_offsets;\n\tint i;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tbeacon_data = beacon->tail;\n\t\tbeacon_data_len = beacon->tail_len;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tresp = rcu_dereference(link->u.ap.probe_resp);\n\n\tbcn_offsets = beacon->cntdwn_counter_offsets;\n\tcount = beacon->cntdwn_current_counter;\n\tif (link->conf->csa_active)\n\t\tmax_count = IEEE80211_MAX_CNTDWN_COUNTERS_NUM;\n\n\tfor (i = 0; i < max_count; ++i) {\n\t\tif (bcn_offsets[i]) {\n\t\t\tif (WARN_ON_ONCE(bcn_offsets[i] >= beacon_data_len))\n\t\t\t\treturn;\n\t\t\tbeacon_data[bcn_offsets[i]] = count;\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP && resp) {\n\t\t\tu16 *resp_offsets = resp->cntdwn_counter_offsets;\n\n\t\t\tresp->data[resp_offsets[i]] = count;\n\t\t}\n\t}\n}\n\nstatic u8 __ieee80211_beacon_update_cntdwn(struct beacon_data *beacon)\n{\n\tbeacon->cntdwn_current_counter--;\n\n\t \n\tWARN_ON_ONCE(!beacon->cntdwn_current_counter);\n\n\treturn beacon->cntdwn_current_counter;\n}\n\nu8 ieee80211_beacon_update_cntdwn(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct beacon_data *beacon = NULL;\n\tu8 count = 0;\n\n\trcu_read_lock();\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tbeacon = rcu_dereference(sdata->deflink.u.ap.beacon);\n\telse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\tbeacon = rcu_dereference(sdata->u.ibss.presp);\n\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tbeacon = rcu_dereference(sdata->u.mesh.beacon);\n\n\tif (!beacon)\n\t\tgoto unlock;\n\n\tcount = __ieee80211_beacon_update_cntdwn(beacon);\n\nunlock:\n\trcu_read_unlock();\n\treturn count;\n}\nEXPORT_SYMBOL(ieee80211_beacon_update_cntdwn);\n\nvoid ieee80211_beacon_set_cntdwn(struct ieee80211_vif *vif, u8 counter)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct beacon_data *beacon = NULL;\n\n\trcu_read_lock();\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tbeacon = rcu_dereference(sdata->deflink.u.ap.beacon);\n\telse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\tbeacon = rcu_dereference(sdata->u.ibss.presp);\n\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tbeacon = rcu_dereference(sdata->u.mesh.beacon);\n\n\tif (!beacon)\n\t\tgoto unlock;\n\n\tif (counter < beacon->cntdwn_current_counter)\n\t\tbeacon->cntdwn_current_counter = counter;\n\nunlock:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ieee80211_beacon_set_cntdwn);\n\nbool ieee80211_beacon_cntdwn_is_complete(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct beacon_data *beacon = NULL;\n\tu8 *beacon_data;\n\tsize_t beacon_data_len;\n\tint ret = false;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\tbeacon = rcu_dereference(sdata->deflink.u.ap.beacon);\n\t\tif (WARN_ON(!beacon || !beacon->tail))\n\t\t\tgoto out;\n\t\tbeacon_data = beacon->tail;\n\t\tbeacon_data_len = beacon->tail_len;\n\t} else if (vif->type == NL80211_IFTYPE_ADHOC) {\n\t\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\n\t\tbeacon = rcu_dereference(ifibss->presp);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t} else if (vif->type == NL80211_IFTYPE_MESH_POINT) {\n\t\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\t\tbeacon = rcu_dereference(ifmsh->beacon);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tbeacon_data = beacon->head;\n\t\tbeacon_data_len = beacon->head_len;\n\t} else {\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t}\n\n\tif (!beacon->cntdwn_counter_offsets[0])\n\t\tgoto out;\n\n\tif (WARN_ON_ONCE(beacon->cntdwn_counter_offsets[0] > beacon_data_len))\n\t\tgoto out;\n\n\tif (beacon_data[beacon->cntdwn_counter_offsets[0]] == 1)\n\t\tret = true;\n\n out:\n\trcu_read_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_beacon_cntdwn_is_complete);\n\nstatic int ieee80211_beacon_protect(struct sk_buff *skb,\n\t\t\t\t    struct ieee80211_local *local,\n\t\t\t\t    struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_link_data *link)\n{\n\tieee80211_tx_result res;\n\tstruct ieee80211_tx_data tx;\n\tstruct sk_buff *check_skb;\n\n\tmemset(&tx, 0, sizeof(tx));\n\ttx.key = rcu_dereference(link->default_beacon_key);\n\tif (!tx.key)\n\t\treturn 0;\n\n\tif (unlikely(tx.key->flags & KEY_FLAG_TAINTED)) {\n\t\ttx.key = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(tx.key->conf.flags & IEEE80211_KEY_FLAG_SW_MGMT_TX) &&\n\t    tx.key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE)\n\t\tIEEE80211_SKB_CB(skb)->control.hw_key = &tx.key->conf;\n\n\ttx.local = local;\n\ttx.sdata = sdata;\n\t__skb_queue_head_init(&tx.skbs);\n\t__skb_queue_tail(&tx.skbs, skb);\n\tres = ieee80211_tx_h_encrypt(&tx);\n\tcheck_skb = __skb_dequeue(&tx.skbs);\n\t \n\tWARN_ON(check_skb != skb);\n\tif (WARN_ON_ONCE(res != TX_CONTINUE))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void\nieee80211_beacon_get_finish(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_link_data *link,\n\t\t\t    struct ieee80211_mutable_offsets *offs,\n\t\t\t    struct beacon_data *beacon,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct ieee80211_chanctx_conf *chanctx_conf,\n\t\t\t    u16 csa_off_base)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_tx_info *info;\n\tenum nl80211_band band;\n\tstruct ieee80211_tx_rate_control txrc;\n\n\t \n\tif (offs && beacon) {\n\t\tu16 i;\n\n\t\tfor (i = 0; i < IEEE80211_MAX_CNTDWN_COUNTERS_NUM; i++) {\n\t\t\tu16 csa_off = beacon->cntdwn_counter_offsets[i];\n\n\t\t\tif (!csa_off)\n\t\t\t\tcontinue;\n\n\t\t\toffs->cntdwn_counter_offs[i] = csa_off_base + csa_off;\n\t\t}\n\t}\n\n\tband = chanctx_conf->def.chan->band;\n\tinfo = IEEE80211_SKB_CB(skb);\n\tinfo->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\tinfo->band = band;\n\n\tmemset(&txrc, 0, sizeof(txrc));\n\ttxrc.hw = hw;\n\ttxrc.sband = local->hw.wiphy->bands[band];\n\ttxrc.bss_conf = link->conf;\n\ttxrc.skb = skb;\n\ttxrc.reported_rate.idx = -1;\n\tif (sdata->beacon_rate_set && sdata->beacon_rateidx_mask[band])\n\t\ttxrc.rate_idx_mask = sdata->beacon_rateidx_mask[band];\n\telse\n\t\ttxrc.rate_idx_mask = sdata->rc_rateidx_mask[band];\n\ttxrc.bss = true;\n\trate_control_get_rate(sdata, NULL, &txrc);\n\n\tinfo->control.vif = vif;\n\tinfo->control.flags |= u32_encode_bits(link->link_id,\n\t\t\t\t\t       IEEE80211_TX_CTRL_MLO_LINK);\n\tinfo->flags |= IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t       IEEE80211_TX_CTL_ASSIGN_SEQ |\n\t\t       IEEE80211_TX_CTL_FIRST_FRAGMENT;\n}\n\nstatic void\nieee80211_beacon_add_mbssid(struct sk_buff *skb, struct beacon_data *beacon,\n\t\t\t    u8 i)\n{\n\tif (!beacon->mbssid_ies || !beacon->mbssid_ies->cnt ||\n\t    i > beacon->mbssid_ies->cnt)\n\t\treturn;\n\n\tif (i < beacon->mbssid_ies->cnt) {\n\t\tskb_put_data(skb, beacon->mbssid_ies->elem[i].data,\n\t\t\t     beacon->mbssid_ies->elem[i].len);\n\n\t\tif (beacon->rnr_ies && beacon->rnr_ies->cnt) {\n\t\t\tskb_put_data(skb, beacon->rnr_ies->elem[i].data,\n\t\t\t\t     beacon->rnr_ies->elem[i].len);\n\n\t\t\tfor (i = beacon->mbssid_ies->cnt; i < beacon->rnr_ies->cnt; i++)\n\t\t\t\tskb_put_data(skb, beacon->rnr_ies->elem[i].data,\n\t\t\t\t\t     beacon->rnr_ies->elem[i].len);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < beacon->mbssid_ies->cnt; i++)\n\t\tskb_put_data(skb, beacon->mbssid_ies->elem[i].data,\n\t\t\t     beacon->mbssid_ies->elem[i].len);\n}\n\nstatic struct sk_buff *\nieee80211_beacon_get_ap(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_link_data *link,\n\t\t\tstruct ieee80211_mutable_offsets *offs,\n\t\t\tbool is_template,\n\t\t\tstruct beacon_data *beacon,\n\t\t\tstruct ieee80211_chanctx_conf *chanctx_conf,\n\t\t\tu8 ema_index)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_if_ap *ap = &sdata->u.ap;\n\tstruct sk_buff *skb = NULL;\n\tu16 csa_off_base = 0;\n\tint mbssid_len;\n\n\tif (beacon->cntdwn_counter_offsets[0]) {\n\t\tif (!is_template)\n\t\t\tieee80211_beacon_update_cntdwn(vif);\n\n\t\tieee80211_set_beacon_cntdwn(sdata, beacon, link);\n\t}\n\n\t \n\tmbssid_len = ieee80211_get_mbssid_beacon_len(beacon->mbssid_ies,\n\t\t\t\t\t\t     beacon->rnr_ies,\n\t\t\t\t\t\t     ema_index);\n\n\tskb = dev_alloc_skb(local->tx_headroom + beacon->head_len +\n\t\t\t    beacon->tail_len + 256 +\n\t\t\t    local->hw.extra_beacon_tailroom + mbssid_len);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->tx_headroom);\n\tskb_put_data(skb, beacon->head, beacon->head_len);\n\n\tieee80211_beacon_add_tim(sdata, link, &ap->ps, skb, is_template);\n\n\tif (offs) {\n\t\toffs->tim_offset = beacon->head_len;\n\t\toffs->tim_length = skb->len - beacon->head_len;\n\t\toffs->cntdwn_counter_offs[0] = beacon->cntdwn_counter_offsets[0];\n\n\t\tif (mbssid_len) {\n\t\t\tieee80211_beacon_add_mbssid(skb, beacon, ema_index);\n\t\t\toffs->mbssid_off = skb->len - mbssid_len;\n\t\t}\n\n\t\t \n\t\tcsa_off_base = skb->len;\n\t}\n\n\tif (beacon->tail)\n\t\tskb_put_data(skb, beacon->tail, beacon->tail_len);\n\n\tif (ieee80211_beacon_protect(skb, local, sdata, link) < 0)\n\t\treturn NULL;\n\n\tieee80211_beacon_get_finish(hw, vif, link, offs, beacon, skb,\n\t\t\t\t    chanctx_conf, csa_off_base);\n\treturn skb;\n}\n\nstatic struct ieee80211_ema_beacons *\nieee80211_beacon_get_ap_ema_list(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_link_data *link,\n\t\t\t\t struct ieee80211_mutable_offsets *offs,\n\t\t\t\t bool is_template, struct beacon_data *beacon,\n\t\t\t\t struct ieee80211_chanctx_conf *chanctx_conf)\n{\n\tstruct ieee80211_ema_beacons *ema = NULL;\n\n\tif (!beacon->mbssid_ies || !beacon->mbssid_ies->cnt)\n\t\treturn NULL;\n\n\tema = kzalloc(struct_size(ema, bcn, beacon->mbssid_ies->cnt),\n\t\t      GFP_ATOMIC);\n\tif (!ema)\n\t\treturn NULL;\n\n\tfor (ema->cnt = 0; ema->cnt < beacon->mbssid_ies->cnt; ema->cnt++) {\n\t\tema->bcn[ema->cnt].skb =\n\t\t\tieee80211_beacon_get_ap(hw, vif, link,\n\t\t\t\t\t\t&ema->bcn[ema->cnt].offs,\n\t\t\t\t\t\tis_template, beacon,\n\t\t\t\t\t\tchanctx_conf, ema->cnt);\n\t\tif (!ema->bcn[ema->cnt].skb)\n\t\t\tbreak;\n\t}\n\n\tif (ema->cnt == beacon->mbssid_ies->cnt)\n\t\treturn ema;\n\n\tieee80211_beacon_free_ema_list(ema);\n\treturn NULL;\n}\n\n#define IEEE80211_INCLUDE_ALL_MBSSID_ELEMS -1\n\nstatic struct sk_buff *\n__ieee80211_beacon_get(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_vif *vif,\n\t\t       struct ieee80211_mutable_offsets *offs,\n\t\t       bool is_template,\n\t\t       unsigned int link_id,\n\t\t       int ema_index,\n\t\t       struct ieee80211_ema_beacons **ema_beacons)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct beacon_data *beacon = NULL;\n\tstruct sk_buff *skb = NULL;\n\tstruct ieee80211_sub_if_data *sdata = NULL;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_link_data *link;\n\n\trcu_read_lock();\n\n\tsdata = vif_to_sdata(vif);\n\tlink = rcu_dereference(sdata->link[link_id]);\n\tif (!link)\n\t\tgoto out;\n\tchanctx_conf =\n\t\trcu_dereference(link->conf->chanctx_conf);\n\n\tif (!ieee80211_sdata_running(sdata) || !chanctx_conf)\n\t\tgoto out;\n\n\tif (offs)\n\t\tmemset(offs, 0, sizeof(*offs));\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tbeacon = rcu_dereference(link->u.ap.beacon);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tif (ema_beacons) {\n\t\t\t*ema_beacons =\n\t\t\t\tieee80211_beacon_get_ap_ema_list(hw, vif, link,\n\t\t\t\t\t\t\t\t offs,\n\t\t\t\t\t\t\t\t is_template,\n\t\t\t\t\t\t\t\t beacon,\n\t\t\t\t\t\t\t\t chanctx_conf);\n\t\t} else {\n\t\t\tif (beacon->mbssid_ies && beacon->mbssid_ies->cnt) {\n\t\t\t\tif (ema_index >= beacon->mbssid_ies->cnt)\n\t\t\t\t\tgoto out;  \n\n\t\t\t\tif (ema_index <= IEEE80211_INCLUDE_ALL_MBSSID_ELEMS)\n\t\t\t\t\tema_index = beacon->mbssid_ies->cnt;\n\t\t\t} else {\n\t\t\t\tema_index = 0;\n\t\t\t}\n\n\t\t\tskb = ieee80211_beacon_get_ap(hw, vif, link, offs,\n\t\t\t\t\t\t      is_template, beacon,\n\t\t\t\t\t\t      chanctx_conf,\n\t\t\t\t\t\t      ema_index);\n\t\t}\n\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\t\tstruct ieee80211_hdr *hdr;\n\n\t\tbeacon = rcu_dereference(ifibss->presp);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tif (beacon->cntdwn_counter_offsets[0]) {\n\t\t\tif (!is_template)\n\t\t\t\t__ieee80211_beacon_update_cntdwn(beacon);\n\n\t\t\tieee80211_set_beacon_cntdwn(sdata, beacon, link);\n\t\t}\n\n\t\tskb = dev_alloc_skb(local->tx_headroom + beacon->head_len +\n\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tskb_reserve(skb, local->tx_headroom);\n\t\tskb_put_data(skb, beacon->head, beacon->head_len);\n\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t\t IEEE80211_STYPE_BEACON);\n\n\t\tieee80211_beacon_get_finish(hw, vif, link, offs, beacon, skb,\n\t\t\t\t\t    chanctx_conf, 0);\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\t\tbeacon = rcu_dereference(ifmsh->beacon);\n\t\tif (!beacon)\n\t\t\tgoto out;\n\n\t\tif (beacon->cntdwn_counter_offsets[0]) {\n\t\t\tif (!is_template)\n\t\t\t\t \n\t\t\t\t__ieee80211_beacon_update_cntdwn(beacon);\n\n\t\t\tieee80211_set_beacon_cntdwn(sdata, beacon, link);\n\t\t}\n\n\t\tif (ifmsh->sync_ops)\n\t\t\tifmsh->sync_ops->adjust_tsf(sdata, beacon);\n\n\t\tskb = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    beacon->head_len +\n\t\t\t\t    256 +  \n\t\t\t\t    beacon->tail_len +\n\t\t\t\t    local->hw.extra_beacon_tailroom);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tskb_reserve(skb, local->tx_headroom);\n\t\tskb_put_data(skb, beacon->head, beacon->head_len);\n\t\tieee80211_beacon_add_tim(sdata, link, &ifmsh->ps, skb,\n\t\t\t\t\t is_template);\n\n\t\tif (offs) {\n\t\t\toffs->tim_offset = beacon->head_len;\n\t\t\toffs->tim_length = skb->len - beacon->head_len;\n\t\t}\n\n\t\tskb_put_data(skb, beacon->tail, beacon->tail_len);\n\t\tieee80211_beacon_get_finish(hw, vif, link, offs, beacon, skb,\n\t\t\t\t\t    chanctx_conf, 0);\n\t} else {\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t}\n\n out:\n\trcu_read_unlock();\n\treturn skb;\n\n}\n\nstruct sk_buff *\nieee80211_beacon_get_template(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_mutable_offsets *offs,\n\t\t\t      unsigned int link_id)\n{\n\treturn __ieee80211_beacon_get(hw, vif, offs, true, link_id,\n\t\t\t\t      IEEE80211_INCLUDE_ALL_MBSSID_ELEMS, NULL);\n}\nEXPORT_SYMBOL(ieee80211_beacon_get_template);\n\nstruct sk_buff *\nieee80211_beacon_get_template_ema_index(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_mutable_offsets *offs,\n\t\t\t\t\tunsigned int link_id, u8 ema_index)\n{\n\treturn __ieee80211_beacon_get(hw, vif, offs, true, link_id, ema_index,\n\t\t\t\t      NULL);\n}\nEXPORT_SYMBOL(ieee80211_beacon_get_template_ema_index);\n\nvoid ieee80211_beacon_free_ema_list(struct ieee80211_ema_beacons *ema_beacons)\n{\n\tu8 i;\n\n\tif (!ema_beacons)\n\t\treturn;\n\n\tfor (i = 0; i < ema_beacons->cnt; i++)\n\t\tkfree_skb(ema_beacons->bcn[i].skb);\n\n\tkfree(ema_beacons);\n}\nEXPORT_SYMBOL(ieee80211_beacon_free_ema_list);\n\nstruct ieee80211_ema_beacons *\nieee80211_beacon_get_template_ema_list(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       unsigned int link_id)\n{\n\tstruct ieee80211_ema_beacons *ema_beacons = NULL;\n\n\tWARN_ON(__ieee80211_beacon_get(hw, vif, NULL, true, link_id, 0,\n\t\t\t\t       &ema_beacons));\n\n\treturn ema_beacons;\n}\nEXPORT_SYMBOL(ieee80211_beacon_get_template_ema_list);\n\nstruct sk_buff *ieee80211_beacon_get_tim(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t u16 *tim_offset, u16 *tim_length,\n\t\t\t\t\t unsigned int link_id)\n{\n\tstruct ieee80211_mutable_offsets offs = {};\n\tstruct sk_buff *bcn = __ieee80211_beacon_get(hw, vif, &offs, false,\n\t\t\t\t\t\t     link_id,\n\t\t\t\t\t\t     IEEE80211_INCLUDE_ALL_MBSSID_ELEMS,\n\t\t\t\t\t\t     NULL);\n\tstruct sk_buff *copy;\n\tint shift;\n\n\tif (!bcn)\n\t\treturn bcn;\n\n\tif (tim_offset)\n\t\t*tim_offset = offs.tim_offset;\n\n\tif (tim_length)\n\t\t*tim_length = offs.tim_length;\n\n\tif (ieee80211_hw_check(hw, BEACON_TX_STATUS) ||\n\t    !hw_to_local(hw)->monitors)\n\t\treturn bcn;\n\n\t \n\tcopy = skb_copy(bcn, GFP_ATOMIC);\n\tif (!copy)\n\t\treturn bcn;\n\n\tshift = ieee80211_vif_get_shift(vif);\n\tieee80211_tx_monitor(hw_to_local(hw), copy, 1, shift, false, NULL);\n\n\treturn bcn;\n}\nEXPORT_SYMBOL(ieee80211_beacon_get_tim);\n\nstruct sk_buff *ieee80211_proberesp_get(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct probe_resp *presp = NULL;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tpresp = rcu_dereference(sdata->deflink.u.ap.probe_resp);\n\tif (!presp)\n\t\tgoto out;\n\n\tskb = dev_alloc_skb(presp->len);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb_put_data(skb, presp->data, presp->len);\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\tmemset(hdr->addr1, 0, sizeof(hdr->addr1));\n\nout:\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_proberesp_get);\n\nstruct sk_buff *ieee80211_get_fils_discovery_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct fils_discovery_data *tmpl = NULL;\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttmpl = rcu_dereference(sdata->deflink.u.ap.fils_discovery);\n\tif (!tmpl) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\n\tskb = dev_alloc_skb(sdata->local->hw.extra_tx_headroom + tmpl->len);\n\tif (skb) {\n\t\tskb_reserve(skb, sdata->local->hw.extra_tx_headroom);\n\t\tskb_put_data(skb, tmpl->data, tmpl->len);\n\t}\n\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_get_fils_discovery_tmpl);\n\nstruct sk_buff *\nieee80211_get_unsol_bcast_probe_resp_tmpl(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct unsol_bcast_probe_resp_data *tmpl = NULL;\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttmpl = rcu_dereference(sdata->deflink.u.ap.unsol_bcast_probe_resp);\n\tif (!tmpl) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\n\tskb = dev_alloc_skb(sdata->local->hw.extra_tx_headroom + tmpl->len);\n\tif (skb) {\n\t\tskb_reserve(skb, sdata->local->hw.extra_tx_headroom);\n\t\tskb_put_data(skb, tmpl->data, tmpl->len);\n\t}\n\n\trcu_read_unlock();\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_get_unsol_bcast_probe_resp_tmpl);\n\nstruct sk_buff *ieee80211_pspoll_get(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_pspoll *pspoll;\n\tstruct ieee80211_local *local;\n\tstruct sk_buff *skb;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn NULL;\n\n\tsdata = vif_to_sdata(vif);\n\tlocal = sdata->local;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*pspoll));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tpspoll = skb_put_zero(skb, sizeof(*pspoll));\n\tpspoll->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t    IEEE80211_STYPE_PSPOLL);\n\tpspoll->aid = cpu_to_le16(sdata->vif.cfg.aid);\n\n\t \n\tpspoll->aid |= cpu_to_le16(1 << 15 | 1 << 14);\n\n\tmemcpy(pspoll->bssid, sdata->deflink.u.mgd.bssid, ETH_ALEN);\n\tmemcpy(pspoll->ta, vif->addr, ETH_ALEN);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_pspoll_get);\n\nstruct sk_buff *ieee80211_nullfunc_get(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       int link_id, bool qos_ok)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_link_data *link = NULL;\n\tstruct ieee80211_hdr_3addr *nullfunc;\n\tstruct sk_buff *skb;\n\tbool qos = false;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn NULL;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom +\n\t\t\t    sizeof(*nullfunc) + 2);\n\tif (!skb)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tif (qos_ok) {\n\t\tstruct sta_info *sta;\n\n\t\tsta = sta_info_get(sdata, vif->cfg.ap_addr);\n\t\tqos = sta && sta->sta.wme;\n\t}\n\n\tif (link_id >= 0) {\n\t\tlink = rcu_dereference(sdata->link[link_id]);\n\t\tif (WARN_ON_ONCE(!link)) {\n\t\t\trcu_read_unlock();\n\t\t\tkfree_skb(skb);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tnullfunc = skb_put_zero(skb, sizeof(*nullfunc));\n\tnullfunc->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t\t      IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t\t      IEEE80211_FCTL_TODS);\n\tif (qos) {\n\t\t__le16 qoshdr = cpu_to_le16(7);\n\n\t\tBUILD_BUG_ON((IEEE80211_STYPE_QOS_NULLFUNC |\n\t\t\t      IEEE80211_STYPE_NULLFUNC) !=\n\t\t\t     IEEE80211_STYPE_QOS_NULLFUNC);\n\t\tnullfunc->frame_control |=\n\t\t\tcpu_to_le16(IEEE80211_STYPE_QOS_NULLFUNC);\n\t\tskb->priority = 7;\n\t\tskb_set_queue_mapping(skb, IEEE80211_AC_VO);\n\t\tskb_put_data(skb, &qoshdr, sizeof(qoshdr));\n\t}\n\n\tif (link) {\n\t\tmemcpy(nullfunc->addr1, link->conf->bssid, ETH_ALEN);\n\t\tmemcpy(nullfunc->addr2, link->conf->addr, ETH_ALEN);\n\t\tmemcpy(nullfunc->addr3, link->conf->bssid, ETH_ALEN);\n\t} else {\n\t\tmemcpy(nullfunc->addr1, vif->cfg.ap_addr, ETH_ALEN);\n\t\tmemcpy(nullfunc->addr2, vif->addr, ETH_ALEN);\n\t\tmemcpy(nullfunc->addr3, vif->cfg.ap_addr, ETH_ALEN);\n\t}\n\trcu_read_unlock();\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_nullfunc_get);\n\nstruct sk_buff *ieee80211_probereq_get(struct ieee80211_hw *hw,\n\t\t\t\t       const u8 *src_addr,\n\t\t\t\t       const u8 *ssid, size_t ssid_len,\n\t\t\t\t       size_t tailroom)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_hdr_3addr *hdr;\n\tstruct sk_buff *skb;\n\tsize_t ie_ssid_len;\n\tu8 *pos;\n\n\tie_ssid_len = 2 + ssid_len;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + sizeof(*hdr) +\n\t\t\t    ie_ssid_len + tailroom);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\thdr = skb_put_zero(skb, sizeof(*hdr));\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t IEEE80211_STYPE_PROBE_REQ);\n\teth_broadcast_addr(hdr->addr1);\n\tmemcpy(hdr->addr2, src_addr, ETH_ALEN);\n\teth_broadcast_addr(hdr->addr3);\n\n\tpos = skb_put(skb, ie_ssid_len);\n\t*pos++ = WLAN_EID_SSID;\n\t*pos++ = ssid_len;\n\tif (ssid_len)\n\t\tmemcpy(pos, ssid, ssid_len);\n\tpos += ssid_len;\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_probereq_get);\n\nvoid ieee80211_rts_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       const void *frame, size_t frame_len,\n\t\t       const struct ieee80211_tx_info *frame_txctl,\n\t\t       struct ieee80211_rts *rts)\n{\n\tconst struct ieee80211_hdr *hdr = frame;\n\n\trts->frame_control =\n\t    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_RTS);\n\trts->duration = ieee80211_rts_duration(hw, vif, frame_len,\n\t\t\t\t\t       frame_txctl);\n\tmemcpy(rts->ra, hdr->addr1, sizeof(rts->ra));\n\tmemcpy(rts->ta, hdr->addr2, sizeof(rts->ta));\n}\nEXPORT_SYMBOL(ieee80211_rts_get);\n\nvoid ieee80211_ctstoself_get(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t     const void *frame, size_t frame_len,\n\t\t\t     const struct ieee80211_tx_info *frame_txctl,\n\t\t\t     struct ieee80211_cts *cts)\n{\n\tconst struct ieee80211_hdr *hdr = frame;\n\n\tcts->frame_control =\n\t    cpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_CTS);\n\tcts->duration = ieee80211_ctstoself_duration(hw, vif,\n\t\t\t\t\t\t     frame_len, frame_txctl);\n\tmemcpy(cts->ra, hdr->addr1, sizeof(cts->ra));\n}\nEXPORT_SYMBOL(ieee80211_ctstoself_get);\n\nstruct sk_buff *\nieee80211_get_buffered_bc(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct sk_buff *skb = NULL;\n\tstruct ieee80211_tx_data tx;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ps_data *ps;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tsdata = vif_to_sdata(vif);\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\n\tif (!chanctx_conf)\n\t\tgoto out;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct beacon_data *beacon =\n\t\t\t\trcu_dereference(sdata->deflink.u.ap.beacon);\n\n\t\tif (!beacon || !beacon->head)\n\t\t\tgoto out;\n\n\t\tps = &sdata->u.ap.ps;\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tps = &sdata->u.mesh.ps;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tif (ps->dtim_count != 0 || !ps->dtim_bc_mc)\n\t\tgoto out;  \n\n\twhile (1) {\n\t\tskb = skb_dequeue(&ps->bc_buf);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tlocal->total_ps_buffered--;\n\n\t\tif (!skb_queue_empty(&ps->bc_buf) && skb->len >= 2) {\n\t\t\tstruct ieee80211_hdr *hdr =\n\t\t\t\t(struct ieee80211_hdr *) skb->data;\n\t\t\t \n\t\t\thdr->frame_control |=\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tsdata = IEEE80211_DEV_TO_SUB_IF(skb->dev);\n\t\tif (!ieee80211_tx_prepare(sdata, &tx, NULL, skb))\n\t\t\tbreak;\n\t\tieee80211_free_txskb(hw, skb);\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\ttx.flags |= IEEE80211_TX_PS_BUFFERED;\n\tinfo->band = chanctx_conf->def.chan->band;\n\n\tif (invoke_tx_handlers(&tx))\n\t\tskb = NULL;\n out:\n\trcu_read_unlock();\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ieee80211_get_buffered_bc);\n\nint ieee80211_reserve_tid(struct ieee80211_sta *pubsta, u8 tid)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret;\n\tu32 queues;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\t \n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (WARN_ON(tid >= IEEE80211_NUM_UPS))\n\t\treturn -EINVAL;\n\n\tif (sta->reserved_tid == tid) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (sta->reserved_tid != IEEE80211_TID_UNRESERVED) {\n\t\tsdata_err(sdata, \"TID reservation already active\\n\");\n\t\tret = -EALREADY;\n\t\tgoto out;\n\t}\n\n\tieee80211_stop_vif_queues(sdata->local, sdata,\n\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_RESERVE_TID);\n\n\tsynchronize_net();\n\n\t \n\tif (ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION)) {\n\t\tset_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\t\t__ieee80211_stop_tx_ba_session(sta, tid,\n\t\t\t\t\t       AGG_STOP_LOCAL_REQUEST);\n\t}\n\n\tqueues = BIT(sdata->vif.hw_queue[ieee802_1d_to_ac[tid]]);\n\t__ieee80211_flush_queues(local, sdata, queues, false);\n\n\tsta->reserved_tid = tid;\n\n\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_RESERVE_TID);\n\n\tif (ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION))\n\t\tclear_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\n\tret = 0;\n out:\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_reserve_tid);\n\nvoid ieee80211_unreserve_tid(struct ieee80211_sta *pubsta, u8 tid)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\n\tlockdep_assert_held(&sdata->local->sta_mtx);\n\n\t \n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (tid != sta->reserved_tid) {\n\t\tsdata_err(sdata, \"TID to unreserve (%d) isn't reserved\\n\", tid);\n\t\treturn;\n\t}\n\n\tsta->reserved_tid = IEEE80211_TID_UNRESERVED;\n}\nEXPORT_SYMBOL(ieee80211_unreserve_tid);\n\nvoid __ieee80211_tx_skb_tid_band(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb, int tid, int link_id,\n\t\t\t\t enum nl80211_band band)\n{\n\tconst struct ieee80211_hdr *hdr = (void *)skb->data;\n\tint ac = ieee80211_ac_from_tid(tid);\n\tunsigned int link;\n\n\tskb_reset_mac_header(skb);\n\tskb_set_queue_mapping(skb, ac);\n\tskb->priority = tid;\n\n\tskb->dev = sdata->dev;\n\n\tBUILD_BUG_ON(IEEE80211_LINK_UNSPECIFIED < IEEE80211_MLD_MAX_NUM_LINKS);\n\tBUILD_BUG_ON(!FIELD_FIT(IEEE80211_TX_CTRL_MLO_LINK,\n\t\t\t\tIEEE80211_LINK_UNSPECIFIED));\n\n\tif (!ieee80211_vif_is_mld(&sdata->vif)) {\n\t\tlink = 0;\n\t} else if (link_id >= 0) {\n\t\tlink = link_id;\n\t} else if (memcmp(sdata->vif.addr, hdr->addr2, ETH_ALEN) == 0) {\n\t\t \n\t\tlink = IEEE80211_LINK_UNSPECIFIED;\n\t} else {\n\t\t \n\t\trcu_read_lock();\n\t\tfor (link = 0; link < ARRAY_SIZE(sdata->vif.link_conf); link++) {\n\t\t\tstruct ieee80211_bss_conf *link_conf;\n\n\t\t\tlink_conf = rcu_dereference(sdata->vif.link_conf[link]);\n\t\t\tif (!link_conf)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(link_conf->addr, hdr->addr2, ETH_ALEN) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (WARN_ON_ONCE(link == ARRAY_SIZE(sdata->vif.link_conf)))\n\t\t\tlink = ffs(sdata->vif.active_links) - 1;\n\t}\n\n\tIEEE80211_SKB_CB(skb)->control.flags |=\n\t\tu32_encode_bits(link, IEEE80211_TX_CTRL_MLO_LINK);\n\n\t \n\tlocal_bh_disable();\n\tIEEE80211_SKB_CB(skb)->band = band;\n\tieee80211_xmit(sdata, NULL, skb);\n\tlocal_bh_enable();\n}\n\nvoid ieee80211_tx_skb_tid(struct ieee80211_sub_if_data *sdata,\n\t\t\t  struct sk_buff *skb, int tid, int link_id)\n{\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tenum nl80211_band band;\n\n\trcu_read_lock();\n\tif (!ieee80211_vif_is_mld(&sdata->vif)) {\n\t\tWARN_ON(link_id >= 0);\n\t\tchanctx_conf =\n\t\t\trcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\t\tif (WARN_ON(!chanctx_conf)) {\n\t\t\trcu_read_unlock();\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tband = chanctx_conf->def.chan->band;\n\t} else {\n\t\tWARN_ON(link_id >= 0 &&\n\t\t\t!(sdata->vif.active_links & BIT(link_id)));\n\t\t \n\t\tband = 0;\n\t}\n\n\t__ieee80211_tx_skb_tid_band(sdata, skb, tid, link_id, band);\n\trcu_read_unlock();\n}\n\nint ieee80211_tx_control_port(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *buf, size_t len,\n\t\t\t      const u8 *dest, __be16 proto, bool unencrypted,\n\t\t\t      int link_id, u64 *cookie)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct sk_buff *skb;\n\tstruct ethhdr *ehdr;\n\tu32 ctrl_flags = 0;\n\tu32 flags = 0;\n\tint err;\n\n\t \n\tif (proto != sdata->control_port_protocol &&\n\t    proto != cpu_to_be16(ETH_P_PREAUTH))\n\t\treturn -EINVAL;\n\n\tif (proto == sdata->control_port_protocol)\n\t\tctrl_flags |= IEEE80211_TX_CTRL_PORT_CTRL_PROTO |\n\t\t\t      IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP;\n\n\tif (unencrypted)\n\t\tflags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\n\tif (cookie)\n\t\tctrl_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\n\tflags |= IEEE80211_TX_INTFL_NL80211_FRAME_TX;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom +\n\t\t\t    sizeof(struct ethhdr) + len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom + sizeof(struct ethhdr));\n\n\tskb_put_data(skb, buf, len);\n\n\tehdr = skb_push(skb, sizeof(struct ethhdr));\n\tmemcpy(ehdr->h_dest, dest, ETH_ALEN);\n\n\t \n\tif (link_id < 0) {\n\t\tctrl_flags |= u32_encode_bits(IEEE80211_LINK_UNSPECIFIED,\n\t\t\t\t\t      IEEE80211_TX_CTRL_MLO_LINK);\n\t\tmemcpy(ehdr->h_source, sdata->vif.addr, ETH_ALEN);\n\t} else {\n\t\tstruct ieee80211_bss_conf *link_conf;\n\n\t\tctrl_flags |= u32_encode_bits(link_id,\n\t\t\t\t\t      IEEE80211_TX_CTRL_MLO_LINK);\n\n\t\trcu_read_lock();\n\t\tlink_conf = rcu_dereference(sdata->vif.link_conf[link_id]);\n\t\tif (!link_conf) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOLINK;\n\t\t}\n\t\tmemcpy(ehdr->h_source, link_conf->addr, ETH_ALEN);\n\t\trcu_read_unlock();\n\t}\n\n\tehdr->h_proto = proto;\n\n\tskb->dev = dev;\n\tskb->protocol = proto;\n\tskb_reset_network_header(skb);\n\tskb_reset_mac_header(skb);\n\n\tif (local->hw.queues < IEEE80211_NUM_ACS)\n\t\tgoto start_xmit;\n\n\t \n\trcu_read_lock();\n\terr = ieee80211_lookup_ra_sta(sdata, skb, &sta);\n\tif (err) {\n\t\tdev_kfree_skb(skb);\n\t\trcu_read_unlock();\n\t\treturn err;\n\t}\n\n\tif (!IS_ERR(sta)) {\n\t\tu16 queue = ieee80211_select_queue(sdata, sta, skb);\n\n\t\tskb_set_queue_mapping(skb, queue);\n\n\t\t \n\t\tif (sta && sta->sta.mlo)\n\t\t\tmemcpy(ehdr->h_source, sdata->vif.addr, ETH_ALEN);\n\t}\n\trcu_read_unlock();\n\nstart_xmit:\n\t \n\tmutex_lock(&local->mtx);\n\n\tlocal_bh_disable();\n\t__ieee80211_subif_start_xmit(skb, skb->dev, flags, ctrl_flags, cookie);\n\tlocal_bh_enable();\n\n\tmutex_unlock(&local->mtx);\n\n\treturn 0;\n}\n\nint ieee80211_probe_mesh_link(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *buf, size_t len)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + len +\n\t\t\t    30 +  \n\t\t\t    18);  \n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\tskb_put_data(skb, buf, len);\n\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_802_3);\n\tskb_reset_network_header(skb);\n\tskb_reset_mac_header(skb);\n\n\tlocal_bh_disable();\n\t__ieee80211_subif_start_xmit(skb, skb->dev, 0,\n\t\t\t\t     IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP,\n\t\t\t\t     NULL);\n\tlocal_bh_enable();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}