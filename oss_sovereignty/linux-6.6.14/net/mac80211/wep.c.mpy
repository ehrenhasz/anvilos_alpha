{
  "module_name": "wep.c",
  "hash_id": "4303ae34e39c6d37b9e94dbdd5fed6762644d6ce67f01b7784883a6760651e89",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/wep.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/types.h>\n#include <linux/random.h>\n#include <linux/compiler.h>\n#include <linux/crc32.h>\n#include <linux/crypto.h>\n#include <linux/err.h>\n#include <linux/mm.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"wep.h\"\n\n\nvoid ieee80211_wep_init(struct ieee80211_local *local)\n{\n\t \n\tget_random_bytes(&local->wep_iv, IEEE80211_WEP_IV_LEN);\n}\n\nstatic inline bool ieee80211_wep_weak_iv(u32 iv, int keylen)\n{\n\t \n\tif ((iv & 0xff00) == 0xff00) {\n\t\tu8 B = (iv >> 16) & 0xff;\n\t\tif (B >= 3 && B < 3 + keylen)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n\nstatic void ieee80211_wep_get_iv(struct ieee80211_local *local,\n\t\t\t\t int keylen, int keyidx, u8 *iv)\n{\n\tlocal->wep_iv++;\n\tif (ieee80211_wep_weak_iv(local->wep_iv, keylen))\n\t\tlocal->wep_iv += 0x0100;\n\n\tif (!iv)\n\t\treturn;\n\n\t*iv++ = (local->wep_iv >> 16) & 0xff;\n\t*iv++ = (local->wep_iv >> 8) & 0xff;\n\t*iv++ = local->wep_iv & 0xff;\n\t*iv++ = keyidx << 6;\n}\n\n\nstatic u8 *ieee80211_wep_add_iv(struct ieee80211_local *local,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tint keylen, int keyidx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tunsigned int hdrlen;\n\tu8 *newhdr;\n\n\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\n\tif (WARN_ON(skb_headroom(skb) < IEEE80211_WEP_IV_LEN))\n\t\treturn NULL;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tnewhdr = skb_push(skb, IEEE80211_WEP_IV_LEN);\n\tmemmove(newhdr, newhdr + IEEE80211_WEP_IV_LEN, hdrlen);\n\n\t \n\tif (info->control.hw_key &&\n\t    (info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE))\n\t\treturn newhdr + hdrlen;\n\n\tieee80211_wep_get_iv(local, keylen, keyidx, newhdr + hdrlen);\n\treturn newhdr + hdrlen;\n}\n\n\nstatic void ieee80211_wep_remove_iv(struct ieee80211_local *local,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct ieee80211_key *key)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tunsigned int hdrlen;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tmemmove(skb->data + IEEE80211_WEP_IV_LEN, skb->data, hdrlen);\n\tskb_pull(skb, IEEE80211_WEP_IV_LEN);\n}\n\n\n \nint ieee80211_wep_encrypt_data(struct arc4_ctx *ctx, u8 *rc4key,\n\t\t\t       size_t klen, u8 *data, size_t data_len)\n{\n\t__le32 icv;\n\n\ticv = cpu_to_le32(~crc32_le(~0, data, data_len));\n\tput_unaligned(icv, (__le32 *)(data + data_len));\n\n\tarc4_setkey(ctx, rc4key, klen);\n\tarc4_crypt(ctx, data, data, data_len + IEEE80211_WEP_ICV_LEN);\n\tmemzero_explicit(ctx, sizeof(*ctx));\n\n\treturn 0;\n}\n\n\n \nint ieee80211_wep_encrypt(struct ieee80211_local *local,\n\t\t\t  struct sk_buff *skb,\n\t\t\t  const u8 *key, int keylen, int keyidx)\n{\n\tu8 *iv;\n\tsize_t len;\n\tu8 rc4key[3 + WLAN_KEY_LEN_WEP104];\n\n\tif (WARN_ON(skb_tailroom(skb) < IEEE80211_WEP_ICV_LEN))\n\t\treturn -1;\n\n\tiv = ieee80211_wep_add_iv(local, skb, keylen, keyidx);\n\tif (!iv)\n\t\treturn -1;\n\n\tlen = skb->len - (iv + IEEE80211_WEP_IV_LEN - skb->data);\n\n\t \n\tmemcpy(rc4key, iv, 3);\n\n\t \n\tmemcpy(rc4key + 3, key, keylen);\n\n\t \n\tskb_put(skb, IEEE80211_WEP_ICV_LEN);\n\n\treturn ieee80211_wep_encrypt_data(&local->wep_tx_ctx, rc4key, keylen + 3,\n\t\t\t\t\t  iv + IEEE80211_WEP_IV_LEN, len);\n}\n\n\n \nint ieee80211_wep_decrypt_data(struct arc4_ctx *ctx, u8 *rc4key,\n\t\t\t       size_t klen, u8 *data, size_t data_len)\n{\n\t__le32 crc;\n\n\tarc4_setkey(ctx, rc4key, klen);\n\tarc4_crypt(ctx, data, data, data_len + IEEE80211_WEP_ICV_LEN);\n\tmemzero_explicit(ctx, sizeof(*ctx));\n\n\tcrc = cpu_to_le32(~crc32_le(~0, data, data_len));\n\tif (memcmp(&crc, data + data_len, IEEE80211_WEP_ICV_LEN) != 0)\n\t\t \n\t\treturn -1;\n\n\treturn 0;\n}\n\n\n \nstatic int ieee80211_wep_decrypt(struct ieee80211_local *local,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t struct ieee80211_key *key)\n{\n\tu32 klen;\n\tu8 rc4key[3 + WLAN_KEY_LEN_WEP104];\n\tu8 keyidx;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tunsigned int hdrlen;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!ieee80211_has_protected(hdr->frame_control))\n\t\treturn -1;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tif (skb->len < hdrlen + IEEE80211_WEP_IV_LEN + IEEE80211_WEP_ICV_LEN)\n\t\treturn -1;\n\n\tlen = skb->len - hdrlen - IEEE80211_WEP_IV_LEN - IEEE80211_WEP_ICV_LEN;\n\n\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\n\tif (!key || keyidx != key->conf.keyidx)\n\t\treturn -1;\n\n\tklen = 3 + key->conf.keylen;\n\n\t \n\tmemcpy(rc4key, skb->data + hdrlen, 3);\n\n\t \n\tmemcpy(rc4key + 3, key->conf.key, key->conf.keylen);\n\n\tif (ieee80211_wep_decrypt_data(&local->wep_rx_ctx, rc4key, klen,\n\t\t\t\t       skb->data + hdrlen +\n\t\t\t\t       IEEE80211_WEP_IV_LEN, len))\n\t\tret = -1;\n\n\t \n\tskb_trim(skb, skb->len - IEEE80211_WEP_ICV_LEN);\n\n\t \n\tmemmove(skb->data + IEEE80211_WEP_IV_LEN, skb->data, hdrlen);\n\tskb_pull(skb, IEEE80211_WEP_IV_LEN);\n\n\treturn ret;\n}\n\nieee80211_rx_result\nieee80211_crypto_wep_decrypt(struct ieee80211_rx_data *rx)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\n\tif (!ieee80211_is_data(fc) && !ieee80211_is_auth(fc))\n\t\treturn RX_CONTINUE;\n\n\tif (!(status->flag & RX_FLAG_DECRYPTED)) {\n\t\tif (skb_linearize(rx->skb))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\tif (ieee80211_wep_decrypt(rx->local, rx->skb, rx->key))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t} else if (!(status->flag & RX_FLAG_IV_STRIPPED)) {\n\t\tif (!pskb_may_pull(rx->skb, ieee80211_hdrlen(fc) +\n\t\t\t\t\t    IEEE80211_WEP_IV_LEN))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\tieee80211_wep_remove_iv(rx->local, rx->skb, rx->key);\n\t\t \n\t\tif (!(status->flag & RX_FLAG_ICV_STRIPPED) &&\n\t\t    pskb_trim(rx->skb, rx->skb->len - IEEE80211_WEP_ICV_LEN))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t}\n\n\treturn RX_CONTINUE;\n}\n\nstatic int wep_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_key_conf *hw_key = info->control.hw_key;\n\n\tif (!hw_key) {\n\t\tif (ieee80211_wep_encrypt(tx->local, skb, tx->key->conf.key,\n\t\t\t\t\t  tx->key->conf.keylen,\n\t\t\t\t\t  tx->key->conf.keyidx))\n\t\t\treturn -1;\n\t} else if ((hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) ||\n\t\t   (hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE)) {\n\t\tif (!ieee80211_wep_add_iv(tx->local, skb,\n\t\t\t\t\t  tx->key->conf.keylen,\n\t\t\t\t\t  tx->key->conf.keyidx))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nieee80211_tx_result\nieee80211_crypto_wep_encrypt(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\n\tieee80211_tx_set_protected(tx);\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tif (wep_encrypt_skb(tx, skb) < 0) {\n\t\t\tI802_DEBUG_INC(tx->local->tx_handlers_drop_wep);\n\t\t\treturn TX_DROP;\n\t\t}\n\t}\n\n\treturn TX_CONTINUE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}