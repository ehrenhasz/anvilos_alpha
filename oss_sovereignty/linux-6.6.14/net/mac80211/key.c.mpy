{
  "module_name": "key.c",
  "hash_id": "485c0a84cf1b71fa98b1cafe80c1cc9381d6b6acb0c1b09454058a826897bcf9",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/key.c",
  "human_readable_source": "\n \n\n#include <crypto/utils.h>\n#include <linux/if_ether.h>\n#include <linux/etherdevice.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <net/mac80211.h>\n#include <asm/unaligned.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"debugfs_key.h\"\n#include \"aes_ccm.h\"\n#include \"aes_cmac.h\"\n#include \"aes_gmac.h\"\n#include \"aes_gcm.h\"\n\n\n \n\nstatic const u8 bcast_addr[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\nstatic void assert_key_lock(struct ieee80211_local *local)\n{\n\tlockdep_assert_held(&local->key_mtx);\n}\n\nstatic void\nupdate_vlan_tailroom_need_count(struct ieee80211_sub_if_data *sdata, int delta)\n{\n\tstruct ieee80211_sub_if_data *vlan;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn;\n\n\t \n\tassert_key_lock(sdata->local);\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(vlan, &sdata->u.ap.vlans, u.vlan.list)\n\t\tvlan->crypto_tx_tailroom_needed_cnt += delta;\n\n\trcu_read_unlock();\n}\n\nstatic void increment_tailroom_need_count(struct ieee80211_sub_if_data *sdata)\n{\n\t \n\n\tassert_key_lock(sdata->local);\n\n\tupdate_vlan_tailroom_need_count(sdata, 1);\n\n\tif (!sdata->crypto_tx_tailroom_needed_cnt++) {\n\t\t \n\t\tsynchronize_net();\n\t}\n}\n\nstatic void decrease_tailroom_need_count(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t int delta)\n{\n\tassert_key_lock(sdata->local);\n\n\tWARN_ON_ONCE(sdata->crypto_tx_tailroom_needed_cnt < delta);\n\n\tupdate_vlan_tailroom_need_count(sdata, -delta);\n\tsdata->crypto_tx_tailroom_needed_cnt -= delta;\n}\n\nstatic int ieee80211_key_enable_hw_accel(struct ieee80211_key *key)\n{\n\tstruct ieee80211_sub_if_data *sdata = key->sdata;\n\tstruct sta_info *sta;\n\tint ret = -EOPNOTSUPP;\n\n\tmight_sleep();\n\n\tif (key->flags & KEY_FLAG_TAINTED) {\n\t\t \n\t\tif (key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE &&\n\t\t    !(key->conf.flags & (IEEE80211_KEY_FLAG_GENERATE_MMIC |\n\t\t\t\t\t IEEE80211_KEY_FLAG_PUT_MIC_SPACE |\n\t\t\t\t\t IEEE80211_KEY_FLAG_RESERVE_TAILROOM)))\n\t\t\tincrement_tailroom_need_count(sdata);\n\n\t\tkey->flags &= ~KEY_FLAG_UPLOADED_TO_HARDWARE;\n\t\treturn -EINVAL;\n\t}\n\n\tif (!key->local->ops->set_key)\n\t\tgoto out_unsupported;\n\n\tassert_key_lock(key->local);\n\n\tsta = key->sta;\n\n\t \n\tif (sta && !(key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE) &&\n\t    !ieee80211_hw_check(&key->local->hw, SUPPORTS_PER_STA_GTK))\n\t\tgoto out_unsupported;\n\n\tif (sta && !sta->uploaded)\n\t\tgoto out_unsupported;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\t \n\t\tif (!(key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\t\tret = 1;\n\t\t\tgoto out_unsupported;\n\t\t}\n\t}\n\n\tif (key->conf.link_id >= 0 && sdata->vif.active_links &&\n\t    !(sdata->vif.active_links & BIT(key->conf.link_id)))\n\t\treturn 0;\n\n\tret = drv_set_key(key->local, SET_KEY, sdata,\n\t\t\t  sta ? &sta->sta : NULL, &key->conf);\n\n\tif (!ret) {\n\t\tkey->flags |= KEY_FLAG_UPLOADED_TO_HARDWARE;\n\n\t\tif (!(key->conf.flags & (IEEE80211_KEY_FLAG_GENERATE_MMIC |\n\t\t\t\t\t IEEE80211_KEY_FLAG_PUT_MIC_SPACE |\n\t\t\t\t\t IEEE80211_KEY_FLAG_RESERVE_TAILROOM)))\n\t\t\tdecrease_tailroom_need_count(sdata, 1);\n\n\t\tWARN_ON((key->conf.flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE) &&\n\t\t\t(key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV));\n\n\t\tWARN_ON((key->conf.flags & IEEE80211_KEY_FLAG_PUT_MIC_SPACE) &&\n\t\t\t(key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_MMIC));\n\n\t\treturn 0;\n\t}\n\n\tif (ret != -ENOSPC && ret != -EOPNOTSUPP && ret != 1)\n\t\tsdata_err(sdata,\n\t\t\t  \"failed to set key (%d, %pM) to hardware (%d)\\n\",\n\t\t\t  key->conf.keyidx,\n\t\t\t  sta ? sta->sta.addr : bcast_addr, ret);\n\n out_unsupported:\n\tswitch (key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\t \n\t\tif (ret == 1)\n\t\t\treturn 0;\n\t\tif (ieee80211_hw_check(&key->local->hw, SW_CRYPTO_CONTROL))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void ieee80211_key_disable_hw_accel(struct ieee80211_key *key)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info *sta;\n\tint ret;\n\n\tmight_sleep();\n\n\tif (!key || !key->local->ops->set_key)\n\t\treturn;\n\n\tassert_key_lock(key->local);\n\n\tif (!(key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE))\n\t\treturn;\n\n\tsta = key->sta;\n\tsdata = key->sdata;\n\n\tif (key->conf.link_id >= 0 && sdata->vif.active_links &&\n\t    !(sdata->vif.active_links & BIT(key->conf.link_id)))\n\t\treturn;\n\n\tif (!(key->conf.flags & (IEEE80211_KEY_FLAG_GENERATE_MMIC |\n\t\t\t\t IEEE80211_KEY_FLAG_PUT_MIC_SPACE |\n\t\t\t\t IEEE80211_KEY_FLAG_RESERVE_TAILROOM)))\n\t\tincrement_tailroom_need_count(sdata);\n\n\tkey->flags &= ~KEY_FLAG_UPLOADED_TO_HARDWARE;\n\tret = drv_set_key(key->local, DISABLE_KEY, sdata,\n\t\t\t  sta ? &sta->sta : NULL, &key->conf);\n\n\tif (ret)\n\t\tsdata_err(sdata,\n\t\t\t  \"failed to remove key (%d, %pM) from hardware (%d)\\n\",\n\t\t\t  key->conf.keyidx,\n\t\t\t  sta ? sta->sta.addr : bcast_addr, ret);\n}\n\nstatic int _ieee80211_set_tx_key(struct ieee80211_key *key, bool force)\n{\n\tstruct sta_info *sta = key->sta;\n\tstruct ieee80211_local *local = key->local;\n\n\tassert_key_lock(local);\n\n\tset_sta_flag(sta, WLAN_STA_USES_ENCRYPTION);\n\n\tsta->ptk_idx = key->conf.keyidx;\n\n\tif (force || !ieee80211_hw_check(&local->hw, AMPDU_KEYBORDER_SUPPORT))\n\t\tclear_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\tieee80211_check_fast_xmit(sta);\n\n\treturn 0;\n}\n\nint ieee80211_set_tx_key(struct ieee80211_key *key)\n{\n\treturn _ieee80211_set_tx_key(key, false);\n}\n\nstatic void ieee80211_pairwise_rekey(struct ieee80211_key *old,\n\t\t\t\t     struct ieee80211_key *new)\n{\n\tstruct ieee80211_local *local = new->local;\n\tstruct sta_info *sta = new->sta;\n\tint i;\n\n\tassert_key_lock(local);\n\n\tif (new->conf.flags & IEEE80211_KEY_FLAG_NO_AUTO_TX) {\n\t\t \n\n\t\tif (sta->ptk_idx != INVALID_PTK_KEYIDX &&\n\t\t    !ieee80211_hw_check(&local->hw, AMPDU_KEYBORDER_SUPPORT)) {\n\t\t\t \n\t\t\tset_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\t\t\tmutex_lock(&sta->ampdu_mlme.mtx);\n\t\t\tfor (i = 0; i <  IEEE80211_NUM_TIDS; i++)\n\t\t\t\t___ieee80211_stop_tx_ba_session(sta, i,\n\t\t\t\t\t\t\t\tAGG_STOP_LOCAL_REQUEST);\n\t\t\tmutex_unlock(&sta->ampdu_mlme.mtx);\n\t\t}\n\t} else if (old) {\n\t\t \n\t\tif (!(old->flags & KEY_FLAG_UPLOADED_TO_HARDWARE))\n\t\t\treturn;\n\n\t\t \n\t\told->flags |= KEY_FLAG_TAINTED;\n\t\tieee80211_clear_fast_xmit(sta);\n\t\tif (ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION)) {\n\t\t\tset_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\t\t\tieee80211_sta_tear_down_BA_sessions(sta,\n\t\t\t\t\t\t\t    AGG_STOP_LOCAL_REQUEST);\n\t\t}\n\t\tif (!wiphy_ext_feature_isset(local->hw.wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_CAN_REPLACE_PTK0)) {\n\t\t\tpr_warn_ratelimited(\"Rekeying PTK for STA %pM but driver can't safely do that.\",\n\t\t\t\t\t    sta->sta.addr);\n\t\t\t \n\t\t\tieee80211_flush_queues(local, old->sdata, false);\n\t\t}\n\t}\n}\n\nstatic void __ieee80211_set_default_key(struct ieee80211_link_data *link,\n\t\t\t\t\tint idx, bool uni, bool multi)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_key *key = NULL;\n\n\tassert_key_lock(sdata->local);\n\n\tif (idx >= 0 && idx < NUM_DEFAULT_KEYS) {\n\t\tkey = key_mtx_dereference(sdata->local, sdata->keys[idx]);\n\t\tif (!key)\n\t\t\tkey = key_mtx_dereference(sdata->local, link->gtk[idx]);\n\t}\n\n\tif (uni) {\n\t\trcu_assign_pointer(sdata->default_unicast_key, key);\n\t\tieee80211_check_fast_xmit_iface(sdata);\n\t\tif (sdata->vif.type != NL80211_IFTYPE_AP_VLAN)\n\t\t\tdrv_set_default_unicast_key(sdata->local, sdata, idx);\n\t}\n\n\tif (multi)\n\t\trcu_assign_pointer(link->default_multicast_key, key);\n\n\tieee80211_debugfs_key_update_default(sdata);\n}\n\nvoid ieee80211_set_default_key(struct ieee80211_link_data *link, int idx,\n\t\t\t       bool uni, bool multi)\n{\n\tmutex_lock(&link->sdata->local->key_mtx);\n\t__ieee80211_set_default_key(link, idx, uni, multi);\n\tmutex_unlock(&link->sdata->local->key_mtx);\n}\n\nstatic void\n__ieee80211_set_default_mgmt_key(struct ieee80211_link_data *link, int idx)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_key *key = NULL;\n\n\tassert_key_lock(sdata->local);\n\n\tif (idx >= NUM_DEFAULT_KEYS &&\n\t    idx < NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS)\n\t\tkey = key_mtx_dereference(sdata->local, link->gtk[idx]);\n\n\trcu_assign_pointer(link->default_mgmt_key, key);\n\n\tieee80211_debugfs_key_update_default(sdata);\n}\n\nvoid ieee80211_set_default_mgmt_key(struct ieee80211_link_data *link,\n\t\t\t\t    int idx)\n{\n\tmutex_lock(&link->sdata->local->key_mtx);\n\t__ieee80211_set_default_mgmt_key(link, idx);\n\tmutex_unlock(&link->sdata->local->key_mtx);\n}\n\nstatic void\n__ieee80211_set_default_beacon_key(struct ieee80211_link_data *link, int idx)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_key *key = NULL;\n\n\tassert_key_lock(sdata->local);\n\n\tif (idx >= NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS &&\n\t    idx < NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS +\n\t    NUM_DEFAULT_BEACON_KEYS)\n\t\tkey = key_mtx_dereference(sdata->local, link->gtk[idx]);\n\n\trcu_assign_pointer(link->default_beacon_key, key);\n\n\tieee80211_debugfs_key_update_default(sdata);\n}\n\nvoid ieee80211_set_default_beacon_key(struct ieee80211_link_data *link,\n\t\t\t\t      int idx)\n{\n\tmutex_lock(&link->sdata->local->key_mtx);\n\t__ieee80211_set_default_beacon_key(link, idx);\n\tmutex_unlock(&link->sdata->local->key_mtx);\n}\n\nstatic int ieee80211_key_replace(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct ieee80211_link_data *link,\n\t\t\t\t struct sta_info *sta,\n\t\t\t\t bool pairwise,\n\t\t\t\t struct ieee80211_key *old,\n\t\t\t\t struct ieee80211_key *new)\n{\n\tstruct link_sta_info *link_sta = sta ? &sta->deflink : NULL;\n\tint link_id;\n\tint idx;\n\tint ret = 0;\n\tbool defunikey, defmultikey, defmgmtkey, defbeaconkey;\n\tbool is_wep;\n\n\t \n\tif (WARN_ON(!new && !old))\n\t\treturn 0;\n\n\tif (new) {\n\t\tidx = new->conf.keyidx;\n\t\tis_wep = new->conf.cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t\t\t new->conf.cipher == WLAN_CIPHER_SUITE_WEP104;\n\t\tlink_id = new->conf.link_id;\n\t} else {\n\t\tidx = old->conf.keyidx;\n\t\tis_wep = old->conf.cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t\t\t old->conf.cipher == WLAN_CIPHER_SUITE_WEP104;\n\t\tlink_id = old->conf.link_id;\n\t}\n\n\tif (WARN(old && old->conf.link_id != link_id,\n\t\t \"old link ID %d doesn't match new link ID %d\\n\",\n\t\t old->conf.link_id, link_id))\n\t\treturn -EINVAL;\n\n\tif (link_id >= 0) {\n\t\tif (!link) {\n\t\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\t\t\tif (!link)\n\t\t\t\treturn -ENOLINK;\n\t\t}\n\n\t\tif (sta) {\n\t\t\tlink_sta = rcu_dereference_protected(sta->link[link_id],\n\t\t\t\t\t\t\t     lockdep_is_held(&sta->local->sta_mtx));\n\t\t\tif (!link_sta)\n\t\t\t\treturn -ENOLINK;\n\t\t}\n\t} else {\n\t\tlink = &sdata->deflink;\n\t}\n\n\tif ((is_wep || pairwise) && idx >= NUM_DEFAULT_KEYS)\n\t\treturn -EINVAL;\n\n\tWARN_ON(new && old && new->conf.keyidx != old->conf.keyidx);\n\n\tif (new && sta && pairwise) {\n\t\t \n\t\tieee80211_pairwise_rekey(old, new);\n\t}\n\n\tif (old) {\n\t\tif (old->flags & KEY_FLAG_UPLOADED_TO_HARDWARE) {\n\t\t\tieee80211_key_disable_hw_accel(old);\n\n\t\t\tif (new)\n\t\t\t\tret = ieee80211_key_enable_hw_accel(new);\n\t\t}\n\t} else {\n\t\tif (!new->local->wowlan) {\n\t\t\tret = ieee80211_key_enable_hw_accel(new);\n\t\t} else {\n\t\t\tassert_key_lock(new->local);\n\t\t\tnew->flags |= KEY_FLAG_UPLOADED_TO_HARDWARE;\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (new)\n\t\tlist_add_tail_rcu(&new->list, &sdata->key_list);\n\n\tif (sta) {\n\t\tif (pairwise) {\n\t\t\trcu_assign_pointer(sta->ptk[idx], new);\n\t\t\tif (new &&\n\t\t\t    !(new->conf.flags & IEEE80211_KEY_FLAG_NO_AUTO_TX))\n\t\t\t\t_ieee80211_set_tx_key(new, true);\n\t\t} else {\n\t\t\trcu_assign_pointer(link_sta->gtk[idx], new);\n\t\t}\n\t\t \n\t\tif (new && !old)\n\t\t\tieee80211_check_fast_rx(sta);\n\t} else {\n\t\tdefunikey = old &&\n\t\t\told == key_mtx_dereference(sdata->local,\n\t\t\t\t\t\tsdata->default_unicast_key);\n\t\tdefmultikey = old &&\n\t\t\told == key_mtx_dereference(sdata->local,\n\t\t\t\t\t\t   link->default_multicast_key);\n\t\tdefmgmtkey = old &&\n\t\t\told == key_mtx_dereference(sdata->local,\n\t\t\t\t\t\t   link->default_mgmt_key);\n\t\tdefbeaconkey = old &&\n\t\t\told == key_mtx_dereference(sdata->local,\n\t\t\t\t\t\t   link->default_beacon_key);\n\n\t\tif (defunikey && !new)\n\t\t\t__ieee80211_set_default_key(link, -1, true, false);\n\t\tif (defmultikey && !new)\n\t\t\t__ieee80211_set_default_key(link, -1, false, true);\n\t\tif (defmgmtkey && !new)\n\t\t\t__ieee80211_set_default_mgmt_key(link, -1);\n\t\tif (defbeaconkey && !new)\n\t\t\t__ieee80211_set_default_beacon_key(link, -1);\n\n\t\tif (is_wep || pairwise)\n\t\t\trcu_assign_pointer(sdata->keys[idx], new);\n\t\telse\n\t\t\trcu_assign_pointer(link->gtk[idx], new);\n\n\t\tif (defunikey && new)\n\t\t\t__ieee80211_set_default_key(link, new->conf.keyidx,\n\t\t\t\t\t\t    true, false);\n\t\tif (defmultikey && new)\n\t\t\t__ieee80211_set_default_key(link, new->conf.keyidx,\n\t\t\t\t\t\t    false, true);\n\t\tif (defmgmtkey && new)\n\t\t\t__ieee80211_set_default_mgmt_key(link,\n\t\t\t\t\t\t\t new->conf.keyidx);\n\t\tif (defbeaconkey && new)\n\t\t\t__ieee80211_set_default_beacon_key(link,\n\t\t\t\t\t\t\t   new->conf.keyidx);\n\t}\n\n\tif (old)\n\t\tlist_del_rcu(&old->list);\n\n\treturn 0;\n}\n\nstruct ieee80211_key *\nieee80211_key_alloc(u32 cipher, int idx, size_t key_len,\n\t\t    const u8 *key_data,\n\t\t    size_t seq_len, const u8 *seq)\n{\n\tstruct ieee80211_key *key;\n\tint i, j, err;\n\n\tif (WARN_ON(idx < 0 ||\n\t\t    idx >= NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS +\n\t\t    NUM_DEFAULT_BEACON_KEYS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tkey = kzalloc(sizeof(struct ieee80211_key) + key_len, GFP_KERNEL);\n\tif (!key)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tkey->conf.flags = 0;\n\tkey->flags = 0;\n\n\tkey->conf.link_id = -1;\n\tkey->conf.cipher = cipher;\n\tkey->conf.keyidx = idx;\n\tkey->conf.keylen = key_len;\n\tswitch (cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tkey->conf.iv_len = IEEE80211_WEP_IV_LEN;\n\t\tkey->conf.icv_len = IEEE80211_WEP_ICV_LEN;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tkey->conf.iv_len = IEEE80211_TKIP_IV_LEN;\n\t\tkey->conf.icv_len = IEEE80211_TKIP_ICV_LEN;\n\t\tif (seq) {\n\t\t\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\n\t\t\t\tkey->u.tkip.rx[i].iv32 =\n\t\t\t\t\tget_unaligned_le32(&seq[2]);\n\t\t\t\tkey->u.tkip.rx[i].iv16 =\n\t\t\t\t\tget_unaligned_le16(seq);\n\t\t\t}\n\t\t}\n\t\tspin_lock_init(&key->u.tkip.txlock);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey->conf.iv_len = IEEE80211_CCMP_HDR_LEN;\n\t\tkey->conf.icv_len = IEEE80211_CCMP_MIC_LEN;\n\t\tif (seq) {\n\t\t\tfor (i = 0; i < IEEE80211_NUM_TIDS + 1; i++)\n\t\t\t\tfor (j = 0; j < IEEE80211_CCMP_PN_LEN; j++)\n\t\t\t\t\tkey->u.ccmp.rx_pn[i][j] =\n\t\t\t\t\t\tseq[IEEE80211_CCMP_PN_LEN - j - 1];\n\t\t}\n\t\t \n\t\tkey->u.ccmp.tfm = ieee80211_aes_key_setup_encrypt(\n\t\t\tkey_data, key_len, IEEE80211_CCMP_MIC_LEN);\n\t\tif (IS_ERR(key->u.ccmp.tfm)) {\n\t\t\terr = PTR_ERR(key->u.ccmp.tfm);\n\t\t\tkfree(key);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tkey->conf.iv_len = IEEE80211_CCMP_256_HDR_LEN;\n\t\tkey->conf.icv_len = IEEE80211_CCMP_256_MIC_LEN;\n\t\tfor (i = 0; seq && i < IEEE80211_NUM_TIDS + 1; i++)\n\t\t\tfor (j = 0; j < IEEE80211_CCMP_256_PN_LEN; j++)\n\t\t\t\tkey->u.ccmp.rx_pn[i][j] =\n\t\t\t\t\tseq[IEEE80211_CCMP_256_PN_LEN - j - 1];\n\t\t \n\t\tkey->u.ccmp.tfm = ieee80211_aes_key_setup_encrypt(\n\t\t\tkey_data, key_len, IEEE80211_CCMP_256_MIC_LEN);\n\t\tif (IS_ERR(key->u.ccmp.tfm)) {\n\t\t\terr = PTR_ERR(key->u.ccmp.tfm);\n\t\t\tkfree(key);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tkey->conf.iv_len = 0;\n\t\tif (cipher == WLAN_CIPHER_SUITE_AES_CMAC)\n\t\t\tkey->conf.icv_len = sizeof(struct ieee80211_mmie);\n\t\telse\n\t\t\tkey->conf.icv_len = sizeof(struct ieee80211_mmie_16);\n\t\tif (seq)\n\t\t\tfor (j = 0; j < IEEE80211_CMAC_PN_LEN; j++)\n\t\t\t\tkey->u.aes_cmac.rx_pn[j] =\n\t\t\t\t\tseq[IEEE80211_CMAC_PN_LEN - j - 1];\n\t\t \n\t\tkey->u.aes_cmac.tfm =\n\t\t\tieee80211_aes_cmac_key_setup(key_data, key_len);\n\t\tif (IS_ERR(key->u.aes_cmac.tfm)) {\n\t\t\terr = PTR_ERR(key->u.aes_cmac.tfm);\n\t\t\tkfree(key);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tkey->conf.iv_len = 0;\n\t\tkey->conf.icv_len = sizeof(struct ieee80211_mmie_16);\n\t\tif (seq)\n\t\t\tfor (j = 0; j < IEEE80211_GMAC_PN_LEN; j++)\n\t\t\t\tkey->u.aes_gmac.rx_pn[j] =\n\t\t\t\t\tseq[IEEE80211_GMAC_PN_LEN - j - 1];\n\t\t \n\t\tkey->u.aes_gmac.tfm =\n\t\t\tieee80211_aes_gmac_key_setup(key_data, key_len);\n\t\tif (IS_ERR(key->u.aes_gmac.tfm)) {\n\t\t\terr = PTR_ERR(key->u.aes_gmac.tfm);\n\t\t\tkfree(key);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tkey->conf.iv_len = IEEE80211_GCMP_HDR_LEN;\n\t\tkey->conf.icv_len = IEEE80211_GCMP_MIC_LEN;\n\t\tfor (i = 0; seq && i < IEEE80211_NUM_TIDS + 1; i++)\n\t\t\tfor (j = 0; j < IEEE80211_GCMP_PN_LEN; j++)\n\t\t\t\tkey->u.gcmp.rx_pn[i][j] =\n\t\t\t\t\tseq[IEEE80211_GCMP_PN_LEN - j - 1];\n\t\t \n\t\tkey->u.gcmp.tfm = ieee80211_aes_gcm_key_setup_encrypt(key_data,\n\t\t\t\t\t\t\t\t      key_len);\n\t\tif (IS_ERR(key->u.gcmp.tfm)) {\n\t\t\terr = PTR_ERR(key->u.gcmp.tfm);\n\t\t\tkfree(key);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t\tbreak;\n\t}\n\tmemcpy(key->conf.key, key_data, key_len);\n\tINIT_LIST_HEAD(&key->list);\n\n\treturn key;\n}\n\nstatic void ieee80211_key_free_common(struct ieee80211_key *key)\n{\n\tswitch (key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tieee80211_aes_key_free(key->u.ccmp.tfm);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tieee80211_aes_cmac_key_free(key->u.aes_cmac.tfm);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tieee80211_aes_gmac_key_free(key->u.aes_gmac.tfm);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tieee80211_aes_gcm_key_free(key->u.gcmp.tfm);\n\t\tbreak;\n\t}\n\tkfree_sensitive(key);\n}\n\nstatic void __ieee80211_key_destroy(struct ieee80211_key *key,\n\t\t\t\t    bool delay_tailroom)\n{\n\tif (key->local) {\n\t\tstruct ieee80211_sub_if_data *sdata = key->sdata;\n\n\t\tieee80211_debugfs_key_remove(key);\n\n\t\tif (delay_tailroom) {\n\t\t\t \n\t\t\tsdata->crypto_tx_tailroom_pending_dec++;\n\t\t\tschedule_delayed_work(&sdata->dec_tailroom_needed_wk,\n\t\t\t\t\t      HZ/2);\n\t\t} else {\n\t\t\tdecrease_tailroom_need_count(sdata, 1);\n\t\t}\n\t}\n\n\tieee80211_key_free_common(key);\n}\n\nstatic void ieee80211_key_destroy(struct ieee80211_key *key,\n\t\t\t\t  bool delay_tailroom)\n{\n\tif (!key)\n\t\treturn;\n\n\t \n\tsynchronize_net();\n\n\t__ieee80211_key_destroy(key, delay_tailroom);\n}\n\nvoid ieee80211_key_free_unused(struct ieee80211_key *key)\n{\n\tif (!key)\n\t\treturn;\n\n\tWARN_ON(key->sdata || key->local);\n\tieee80211_key_free_common(key);\n}\n\nstatic bool ieee80211_key_identical(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_key *old,\n\t\t\t\t    struct ieee80211_key *new)\n{\n\tu8 tkip_old[WLAN_KEY_LEN_TKIP], tkip_new[WLAN_KEY_LEN_TKIP];\n\tu8 *tk_old, *tk_new;\n\n\tif (!old || new->conf.keylen != old->conf.keylen)\n\t\treturn false;\n\n\ttk_old = old->conf.key;\n\ttk_new = new->conf.key;\n\n\t \n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    new->conf.cipher == WLAN_CIPHER_SUITE_TKIP &&\n\t    new->conf.keylen == WLAN_KEY_LEN_TKIP &&\n\t    !(new->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\tmemcpy(tkip_old, tk_old, WLAN_KEY_LEN_TKIP);\n\t\tmemcpy(tkip_new, tk_new, WLAN_KEY_LEN_TKIP);\n\t\tmemset(tkip_old + NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY, 0, 8);\n\t\tmemset(tkip_new + NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY, 0, 8);\n\t\ttk_old = tkip_old;\n\t\ttk_new = tkip_new;\n\t}\n\n\treturn !crypto_memneq(tk_old, tk_new, new->conf.keylen);\n}\n\nint ieee80211_key_link(struct ieee80211_key *key,\n\t\t       struct ieee80211_link_data *link,\n\t\t       struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstatic atomic_t key_color = ATOMIC_INIT(0);\n\tstruct ieee80211_key *old_key = NULL;\n\tint idx = key->conf.keyidx;\n\tbool pairwise = key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE;\n\t \n\tbool delay_tailroom = sdata->vif.type == NL80211_IFTYPE_STATION;\n\tint ret;\n\n\tmutex_lock(&sdata->local->key_mtx);\n\n\tif (sta && pairwise) {\n\t\tstruct ieee80211_key *alt_key;\n\n\t\told_key = key_mtx_dereference(sdata->local, sta->ptk[idx]);\n\t\talt_key = key_mtx_dereference(sdata->local, sta->ptk[idx ^ 1]);\n\n\t\t \n\t\tif ((alt_key && alt_key->conf.cipher != key->conf.cipher) ||\n\t\t    (old_key && old_key->conf.cipher != key->conf.cipher)) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t} else if (sta) {\n\t\tstruct link_sta_info *link_sta = &sta->deflink;\n\t\tint link_id = key->conf.link_id;\n\n\t\tif (link_id >= 0) {\n\t\t\tlink_sta = rcu_dereference_protected(sta->link[link_id],\n\t\t\t\t\t\t\t     lockdep_is_held(&sta->local->sta_mtx));\n\t\t\tif (!link_sta) {\n\t\t\t\tret = -ENOLINK;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\told_key = key_mtx_dereference(sdata->local, link_sta->gtk[idx]);\n\t} else {\n\t\tif (idx < NUM_DEFAULT_KEYS)\n\t\t\told_key = key_mtx_dereference(sdata->local,\n\t\t\t\t\t\t      sdata->keys[idx]);\n\t\tif (!old_key)\n\t\t\told_key = key_mtx_dereference(sdata->local,\n\t\t\t\t\t\t      link->gtk[idx]);\n\t}\n\n\t \n\tif (!pairwise) {\n\t\tif (old_key && old_key->conf.cipher != key->conf.cipher) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (ieee80211_key_identical(sdata, old_key, key)) {\n\t\tret = -EALREADY;\n\t\tgoto out;\n\t}\n\n\tkey->local = sdata->local;\n\tkey->sdata = sdata;\n\tkey->sta = sta;\n\n\t \n\tkey->color = atomic_inc_return(&key_color);\n\n\tincrement_tailroom_need_count(sdata);\n\n\tret = ieee80211_key_replace(sdata, link, sta, pairwise, old_key, key);\n\n\tif (!ret) {\n\t\tieee80211_debugfs_key_add(key);\n\t\tieee80211_key_destroy(old_key, delay_tailroom);\n\t} else {\n\t\tieee80211_key_free(key, delay_tailroom);\n\t}\n\n\tkey = NULL;\n\n out:\n\tieee80211_key_free_unused(key);\n\tmutex_unlock(&sdata->local->key_mtx);\n\n\treturn ret;\n}\n\nvoid ieee80211_key_free(struct ieee80211_key *key, bool delay_tailroom)\n{\n\tif (!key)\n\t\treturn;\n\n\t \n\tif (key->sdata)\n\t\tieee80211_key_replace(key->sdata, NULL, key->sta,\n\t\t\t\t      key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE,\n\t\t\t\t      key, NULL);\n\tieee80211_key_destroy(key, delay_tailroom);\n}\n\nvoid ieee80211_reenable_keys(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_key *key;\n\tstruct ieee80211_sub_if_data *vlan;\n\n\tlockdep_assert_wiphy(sdata->local->hw.wiphy);\n\n\tmutex_lock(&sdata->local->key_mtx);\n\n\tsdata->crypto_tx_tailroom_needed_cnt = 0;\n\tsdata->crypto_tx_tailroom_pending_dec = 0;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tlist_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list) {\n\t\t\tvlan->crypto_tx_tailroom_needed_cnt = 0;\n\t\t\tvlan->crypto_tx_tailroom_pending_dec = 0;\n\t\t}\n\t}\n\n\tif (ieee80211_sdata_running(sdata)) {\n\t\tlist_for_each_entry(key, &sdata->key_list, list) {\n\t\t\tincrement_tailroom_need_count(sdata);\n\t\t\tieee80211_key_enable_hw_accel(key);\n\t\t}\n\t}\n\n\tmutex_unlock(&sdata->local->key_mtx);\n}\n\nvoid ieee80211_iter_keys(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t void (*iter)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct ieee80211_key_conf *key,\n\t\t\t\t      void *data),\n\t\t\t void *iter_data)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_key *key, *tmp;\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tlockdep_assert_wiphy(hw->wiphy);\n\n\tmutex_lock(&local->key_mtx);\n\tif (vif) {\n\t\tsdata = vif_to_sdata(vif);\n\t\tlist_for_each_entry_safe(key, tmp, &sdata->key_list, list)\n\t\t\titer(hw, &sdata->vif,\n\t\t\t     key->sta ? &key->sta->sta : NULL,\n\t\t\t     &key->conf, iter_data);\n\t} else {\n\t\tlist_for_each_entry(sdata, &local->interfaces, list)\n\t\t\tlist_for_each_entry_safe(key, tmp,\n\t\t\t\t\t\t &sdata->key_list, list)\n\t\t\t\titer(hw, &sdata->vif,\n\t\t\t\t     key->sta ? &key->sta->sta : NULL,\n\t\t\t\t     &key->conf, iter_data);\n\t}\n\tmutex_unlock(&local->key_mtx);\n}\nEXPORT_SYMBOL(ieee80211_iter_keys);\n\nstatic void\n_ieee80211_iter_keys_rcu(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_sub_if_data *sdata,\n\t\t\t void (*iter)(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct ieee80211_key_conf *key,\n\t\t\t\t      void *data),\n\t\t\t void *iter_data)\n{\n\tstruct ieee80211_key *key;\n\n\tlist_for_each_entry_rcu(key, &sdata->key_list, list) {\n\t\t \n\t\tif (key->sta && key->sta->removed)\n\t\t\tcontinue;\n\t\tif (!(key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE))\n\t\t\tcontinue;\n\n\t\titer(hw, &sdata->vif,\n\t\t     key->sta ? &key->sta->sta : NULL,\n\t\t     &key->conf, iter_data);\n\t}\n}\n\nvoid ieee80211_iter_keys_rcu(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     void (*iter)(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t\t  struct ieee80211_key_conf *key,\n\t\t\t\t\t  void *data),\n\t\t\t     void *iter_data)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tif (vif) {\n\t\tsdata = vif_to_sdata(vif);\n\t\t_ieee80211_iter_keys_rcu(hw, sdata, iter, iter_data);\n\t} else {\n\t\tlist_for_each_entry_rcu(sdata, &local->interfaces, list)\n\t\t\t_ieee80211_iter_keys_rcu(hw, sdata, iter, iter_data);\n\t}\n}\nEXPORT_SYMBOL(ieee80211_iter_keys_rcu);\n\nstatic void ieee80211_free_keys_iface(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct list_head *keys)\n{\n\tstruct ieee80211_key *key, *tmp;\n\n\tdecrease_tailroom_need_count(sdata,\n\t\t\t\t     sdata->crypto_tx_tailroom_pending_dec);\n\tsdata->crypto_tx_tailroom_pending_dec = 0;\n\n\tieee80211_debugfs_key_remove_mgmt_default(sdata);\n\tieee80211_debugfs_key_remove_beacon_default(sdata);\n\n\tlist_for_each_entry_safe(key, tmp, &sdata->key_list, list) {\n\t\tieee80211_key_replace(key->sdata, NULL, key->sta,\n\t\t\t\t      key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE,\n\t\t\t\t      key, NULL);\n\t\tlist_add_tail(&key->list, keys);\n\t}\n\n\tieee80211_debugfs_key_update_default(sdata);\n}\n\nvoid ieee80211_remove_link_keys(struct ieee80211_link_data *link,\n\t\t\t\tstruct list_head *keys)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_key *key, *tmp;\n\n\tmutex_lock(&local->key_mtx);\n\tlist_for_each_entry_safe(key, tmp, &sdata->key_list, list) {\n\t\tif (key->conf.link_id != link->link_id)\n\t\t\tcontinue;\n\t\tieee80211_key_replace(key->sdata, link, key->sta,\n\t\t\t\t      key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE,\n\t\t\t\t      key, NULL);\n\t\tlist_add_tail(&key->list, keys);\n\t}\n\tmutex_unlock(&local->key_mtx);\n}\n\nvoid ieee80211_free_key_list(struct ieee80211_local *local,\n\t\t\t     struct list_head *keys)\n{\n\tstruct ieee80211_key *key, *tmp;\n\n\tmutex_lock(&local->key_mtx);\n\tlist_for_each_entry_safe(key, tmp, keys, list)\n\t\t__ieee80211_key_destroy(key, false);\n\tmutex_unlock(&local->key_mtx);\n}\n\nvoid ieee80211_free_keys(struct ieee80211_sub_if_data *sdata,\n\t\t\t bool force_synchronize)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *vlan;\n\tstruct ieee80211_sub_if_data *master;\n\tstruct ieee80211_key *key, *tmp;\n\tLIST_HEAD(keys);\n\n\tcancel_delayed_work_sync(&sdata->dec_tailroom_needed_wk);\n\n\tmutex_lock(&local->key_mtx);\n\n\tieee80211_free_keys_iface(sdata, &keys);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tlist_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)\n\t\t\tieee80211_free_keys_iface(vlan, &keys);\n\t}\n\n\tif (!list_empty(&keys) || force_synchronize)\n\t\tsynchronize_net();\n\tlist_for_each_entry_safe(key, tmp, &keys, list)\n\t\t__ieee80211_key_destroy(key, false);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (sdata->bss) {\n\t\t\tmaster = container_of(sdata->bss,\n\t\t\t\t\t      struct ieee80211_sub_if_data,\n\t\t\t\t\t      u.ap);\n\n\t\t\tWARN_ON_ONCE(sdata->crypto_tx_tailroom_needed_cnt !=\n\t\t\t\t     master->crypto_tx_tailroom_needed_cnt);\n\t\t}\n\t} else {\n\t\tWARN_ON_ONCE(sdata->crypto_tx_tailroom_needed_cnt ||\n\t\t\t     sdata->crypto_tx_tailroom_pending_dec);\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tlist_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)\n\t\t\tWARN_ON_ONCE(vlan->crypto_tx_tailroom_needed_cnt ||\n\t\t\t\t     vlan->crypto_tx_tailroom_pending_dec);\n\t}\n\n\tmutex_unlock(&local->key_mtx);\n}\n\nvoid ieee80211_free_sta_keys(struct ieee80211_local *local,\n\t\t\t     struct sta_info *sta)\n{\n\tstruct ieee80211_key *key;\n\tint i;\n\n\tmutex_lock(&local->key_mtx);\n\tfor (i = 0; i < ARRAY_SIZE(sta->deflink.gtk); i++) {\n\t\tkey = key_mtx_dereference(local, sta->deflink.gtk[i]);\n\t\tif (!key)\n\t\t\tcontinue;\n\t\tieee80211_key_replace(key->sdata, NULL, key->sta,\n\t\t\t\t      key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE,\n\t\t\t\t      key, NULL);\n\t\t__ieee80211_key_destroy(key, key->sdata->vif.type ==\n\t\t\t\t\tNL80211_IFTYPE_STATION);\n\t}\n\n\tfor (i = 0; i < NUM_DEFAULT_KEYS; i++) {\n\t\tkey = key_mtx_dereference(local, sta->ptk[i]);\n\t\tif (!key)\n\t\t\tcontinue;\n\t\tieee80211_key_replace(key->sdata, NULL, key->sta,\n\t\t\t\t      key->conf.flags & IEEE80211_KEY_FLAG_PAIRWISE,\n\t\t\t\t      key, NULL);\n\t\t__ieee80211_key_destroy(key, key->sdata->vif.type ==\n\t\t\t\t\tNL80211_IFTYPE_STATION);\n\t}\n\n\tmutex_unlock(&local->key_mtx);\n}\n\nvoid ieee80211_delayed_tailroom_dec(struct work_struct *wk)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tsdata = container_of(wk, struct ieee80211_sub_if_data,\n\t\t\t     dec_tailroom_needed_wk.work);\n\n\t \n\n\tmutex_lock(&sdata->local->key_mtx);\n\tdecrease_tailroom_need_count(sdata,\n\t\t\t\t     sdata->crypto_tx_tailroom_pending_dec);\n\tsdata->crypto_tx_tailroom_pending_dec = 0;\n\tmutex_unlock(&sdata->local->key_mtx);\n}\n\nvoid ieee80211_gtk_rekey_notify(struct ieee80211_vif *vif, const u8 *bssid,\n\t\t\t\tconst u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\ttrace_api_gtk_rekey_notify(sdata, bssid, replay_ctr);\n\n\tcfg80211_gtk_rekey_notify(sdata->dev, bssid, replay_ctr, gfp);\n}\nEXPORT_SYMBOL_GPL(ieee80211_gtk_rekey_notify);\n\nvoid ieee80211_get_key_rx_seq(struct ieee80211_key_conf *keyconf,\n\t\t\t      int tid, struct ieee80211_key_seq *seq)\n{\n\tstruct ieee80211_key *key;\n\tconst u8 *pn;\n\n\tkey = container_of(keyconf, struct ieee80211_key, conf);\n\n\tswitch (key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (WARN_ON(tid < 0 || tid >= IEEE80211_NUM_TIDS))\n\t\t\treturn;\n\t\tseq->tkip.iv32 = key->u.tkip.rx[tid].iv32;\n\t\tseq->tkip.iv16 = key->u.tkip.rx[tid].iv16;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tif (WARN_ON(tid < -1 || tid >= IEEE80211_NUM_TIDS))\n\t\t\treturn;\n\t\tif (tid < 0)\n\t\t\tpn = key->u.ccmp.rx_pn[IEEE80211_NUM_TIDS];\n\t\telse\n\t\t\tpn = key->u.ccmp.rx_pn[tid];\n\t\tmemcpy(seq->ccmp.pn, pn, IEEE80211_CCMP_PN_LEN);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tif (WARN_ON(tid != 0))\n\t\t\treturn;\n\t\tpn = key->u.aes_cmac.rx_pn;\n\t\tmemcpy(seq->aes_cmac.pn, pn, IEEE80211_CMAC_PN_LEN);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tif (WARN_ON(tid != 0))\n\t\t\treturn;\n\t\tpn = key->u.aes_gmac.rx_pn;\n\t\tmemcpy(seq->aes_gmac.pn, pn, IEEE80211_GMAC_PN_LEN);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tif (WARN_ON(tid < -1 || tid >= IEEE80211_NUM_TIDS))\n\t\t\treturn;\n\t\tif (tid < 0)\n\t\t\tpn = key->u.gcmp.rx_pn[IEEE80211_NUM_TIDS];\n\t\telse\n\t\t\tpn = key->u.gcmp.rx_pn[tid];\n\t\tmemcpy(seq->gcmp.pn, pn, IEEE80211_GCMP_PN_LEN);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(ieee80211_get_key_rx_seq);\n\nvoid ieee80211_set_key_rx_seq(struct ieee80211_key_conf *keyconf,\n\t\t\t      int tid, struct ieee80211_key_seq *seq)\n{\n\tstruct ieee80211_key *key;\n\tu8 *pn;\n\n\tkey = container_of(keyconf, struct ieee80211_key, conf);\n\n\tswitch (key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (WARN_ON(tid < 0 || tid >= IEEE80211_NUM_TIDS))\n\t\t\treturn;\n\t\tkey->u.tkip.rx[tid].iv32 = seq->tkip.iv32;\n\t\tkey->u.tkip.rx[tid].iv16 = seq->tkip.iv16;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tif (WARN_ON(tid < -1 || tid >= IEEE80211_NUM_TIDS))\n\t\t\treturn;\n\t\tif (tid < 0)\n\t\t\tpn = key->u.ccmp.rx_pn[IEEE80211_NUM_TIDS];\n\t\telse\n\t\t\tpn = key->u.ccmp.rx_pn[tid];\n\t\tmemcpy(pn, seq->ccmp.pn, IEEE80211_CCMP_PN_LEN);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tif (WARN_ON(tid != 0))\n\t\t\treturn;\n\t\tpn = key->u.aes_cmac.rx_pn;\n\t\tmemcpy(pn, seq->aes_cmac.pn, IEEE80211_CMAC_PN_LEN);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tif (WARN_ON(tid != 0))\n\t\t\treturn;\n\t\tpn = key->u.aes_gmac.rx_pn;\n\t\tmemcpy(pn, seq->aes_gmac.pn, IEEE80211_GMAC_PN_LEN);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tif (WARN_ON(tid < -1 || tid >= IEEE80211_NUM_TIDS))\n\t\t\treturn;\n\t\tif (tid < 0)\n\t\t\tpn = key->u.gcmp.rx_pn[IEEE80211_NUM_TIDS];\n\t\telse\n\t\t\tpn = key->u.gcmp.rx_pn[tid];\n\t\tmemcpy(pn, seq->gcmp.pn, IEEE80211_GCMP_PN_LEN);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(ieee80211_set_key_rx_seq);\n\nvoid ieee80211_remove_key(struct ieee80211_key_conf *keyconf)\n{\n\tstruct ieee80211_key *key;\n\n\tkey = container_of(keyconf, struct ieee80211_key, conf);\n\n\tassert_key_lock(key->local);\n\n\t \n\tif (key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE) {\n\t\tkey->flags &= ~KEY_FLAG_UPLOADED_TO_HARDWARE;\n\n\t\tif (!(key->conf.flags & (IEEE80211_KEY_FLAG_GENERATE_MMIC |\n\t\t\t\t\t IEEE80211_KEY_FLAG_PUT_MIC_SPACE |\n\t\t\t\t\t IEEE80211_KEY_FLAG_RESERVE_TAILROOM)))\n\t\t\tincrement_tailroom_need_count(key->sdata);\n\t}\n\n\tieee80211_key_free(key, false);\n}\nEXPORT_SYMBOL_GPL(ieee80211_remove_key);\n\nstruct ieee80211_key_conf *\nieee80211_gtk_rekey_add(struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_key_conf *keyconf)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_key *key;\n\tint err;\n\n\tif (WARN_ON(!local->wowlan))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tkey = ieee80211_key_alloc(keyconf->cipher, keyconf->keyidx,\n\t\t\t\t  keyconf->keylen, keyconf->key,\n\t\t\t\t  0, NULL);\n\tif (IS_ERR(key))\n\t\treturn ERR_CAST(key);\n\n\tif (sdata->u.mgd.mfp != IEEE80211_MFP_DISABLED)\n\t\tkey->conf.flags |= IEEE80211_KEY_FLAG_RX_MGMT;\n\n\t \n\terr = ieee80211_key_link(key, &sdata->deflink, NULL);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn &key->conf;\n}\nEXPORT_SYMBOL_GPL(ieee80211_gtk_rekey_add);\n\nvoid ieee80211_key_mic_failure(struct ieee80211_key_conf *keyconf)\n{\n\tstruct ieee80211_key *key;\n\n\tkey = container_of(keyconf, struct ieee80211_key, conf);\n\n\tswitch (key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tkey->u.aes_cmac.icverrors++;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tkey->u.aes_gmac.icverrors++;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(ieee80211_key_mic_failure);\n\nvoid ieee80211_key_replay(struct ieee80211_key_conf *keyconf)\n{\n\tstruct ieee80211_key *key;\n\n\tkey = container_of(keyconf, struct ieee80211_key, conf);\n\n\tswitch (key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tkey->u.ccmp.replays++;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tkey->u.aes_cmac.replays++;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tkey->u.aes_gmac.replays++;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tkey->u.gcmp.replays++;\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(ieee80211_key_replay);\n\nint ieee80211_key_switch_links(struct ieee80211_sub_if_data *sdata,\n\t\t\t       unsigned long del_links_mask,\n\t\t\t       unsigned long add_links_mask)\n{\n\tstruct ieee80211_key *key;\n\tint ret;\n\n\tlist_for_each_entry(key, &sdata->key_list, list) {\n\t\tif (key->conf.link_id < 0 ||\n\t\t    !(del_links_mask & BIT(key->conf.link_id)))\n\t\t\tcontinue;\n\n\t\t \n\t\tWARN_ON(key->sta);\n\n\t\tieee80211_key_disable_hw_accel(key);\n\t}\n\n\tlist_for_each_entry(key, &sdata->key_list, list) {\n\t\tif (key->conf.link_id < 0 ||\n\t\t    !(add_links_mask & BIT(key->conf.link_id)))\n\t\t\tcontinue;\n\n\t\t \n\t\tWARN_ON(key->sta);\n\n\t\tret = ieee80211_key_enable_hw_accel(key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}