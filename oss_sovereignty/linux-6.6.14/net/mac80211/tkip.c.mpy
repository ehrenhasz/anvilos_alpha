{
  "module_name": "tkip.c",
  "hash_id": "bea49f54feed9982961c1949a66298c8da36dd47e9a3ffd7061eb0f66241f361",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/tkip.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/bitops.h>\n#include <linux/types.h>\n#include <linux/netdevice.h>\n#include <linux/export.h>\n#include <asm/unaligned.h>\n\n#include <net/mac80211.h>\n#include \"driver-ops.h\"\n#include \"key.h\"\n#include \"tkip.h\"\n#include \"wep.h\"\n\n#define PHASE1_LOOP_COUNT 8\n\n \nstatic const u16 tkip_sbox[256] =\n{\n\t0xC6A5, 0xF884, 0xEE99, 0xF68D, 0xFF0D, 0xD6BD, 0xDEB1, 0x9154,\n\t0x6050, 0x0203, 0xCEA9, 0x567D, 0xE719, 0xB562, 0x4DE6, 0xEC9A,\n\t0x8F45, 0x1F9D, 0x8940, 0xFA87, 0xEF15, 0xB2EB, 0x8EC9, 0xFB0B,\n\t0x41EC, 0xB367, 0x5FFD, 0x45EA, 0x23BF, 0x53F7, 0xE496, 0x9B5B,\n\t0x75C2, 0xE11C, 0x3DAE, 0x4C6A, 0x6C5A, 0x7E41, 0xF502, 0x834F,\n\t0x685C, 0x51F4, 0xD134, 0xF908, 0xE293, 0xAB73, 0x6253, 0x2A3F,\n\t0x080C, 0x9552, 0x4665, 0x9D5E, 0x3028, 0x37A1, 0x0A0F, 0x2FB5,\n\t0x0E09, 0x2436, 0x1B9B, 0xDF3D, 0xCD26, 0x4E69, 0x7FCD, 0xEA9F,\n\t0x121B, 0x1D9E, 0x5874, 0x342E, 0x362D, 0xDCB2, 0xB4EE, 0x5BFB,\n\t0xA4F6, 0x764D, 0xB761, 0x7DCE, 0x527B, 0xDD3E, 0x5E71, 0x1397,\n\t0xA6F5, 0xB968, 0x0000, 0xC12C, 0x4060, 0xE31F, 0x79C8, 0xB6ED,\n\t0xD4BE, 0x8D46, 0x67D9, 0x724B, 0x94DE, 0x98D4, 0xB0E8, 0x854A,\n\t0xBB6B, 0xC52A, 0x4FE5, 0xED16, 0x86C5, 0x9AD7, 0x6655, 0x1194,\n\t0x8ACF, 0xE910, 0x0406, 0xFE81, 0xA0F0, 0x7844, 0x25BA, 0x4BE3,\n\t0xA2F3, 0x5DFE, 0x80C0, 0x058A, 0x3FAD, 0x21BC, 0x7048, 0xF104,\n\t0x63DF, 0x77C1, 0xAF75, 0x4263, 0x2030, 0xE51A, 0xFD0E, 0xBF6D,\n\t0x814C, 0x1814, 0x2635, 0xC32F, 0xBEE1, 0x35A2, 0x88CC, 0x2E39,\n\t0x9357, 0x55F2, 0xFC82, 0x7A47, 0xC8AC, 0xBAE7, 0x322B, 0xE695,\n\t0xC0A0, 0x1998, 0x9ED1, 0xA37F, 0x4466, 0x547E, 0x3BAB, 0x0B83,\n\t0x8CCA, 0xC729, 0x6BD3, 0x283C, 0xA779, 0xBCE2, 0x161D, 0xAD76,\n\t0xDB3B, 0x6456, 0x744E, 0x141E, 0x92DB, 0x0C0A, 0x486C, 0xB8E4,\n\t0x9F5D, 0xBD6E, 0x43EF, 0xC4A6, 0x39A8, 0x31A4, 0xD337, 0xF28B,\n\t0xD532, 0x8B43, 0x6E59, 0xDAB7, 0x018C, 0xB164, 0x9CD2, 0x49E0,\n\t0xD8B4, 0xACFA, 0xF307, 0xCF25, 0xCAAF, 0xF48E, 0x47E9, 0x1018,\n\t0x6FD5, 0xF088, 0x4A6F, 0x5C72, 0x3824, 0x57F1, 0x73C7, 0x9751,\n\t0xCB23, 0xA17C, 0xE89C, 0x3E21, 0x96DD, 0x61DC, 0x0D86, 0x0F85,\n\t0xE090, 0x7C42, 0x71C4, 0xCCAA, 0x90D8, 0x0605, 0xF701, 0x1C12,\n\t0xC2A3, 0x6A5F, 0xAEF9, 0x69D0, 0x1791, 0x9958, 0x3A27, 0x27B9,\n\t0xD938, 0xEB13, 0x2BB3, 0x2233, 0xD2BB, 0xA970, 0x0789, 0x33A7,\n\t0x2DB6, 0x3C22, 0x1592, 0xC920, 0x8749, 0xAAFF, 0x5078, 0xA57A,\n\t0x038F, 0x59F8, 0x0980, 0x1A17, 0x65DA, 0xD731, 0x84C6, 0xD0B8,\n\t0x82C3, 0x29B0, 0x5A77, 0x1E11, 0x7BCB, 0xA8FC, 0x6DD6, 0x2C3A,\n};\n\nstatic u16 tkipS(u16 val)\n{\n\treturn tkip_sbox[val & 0xff] ^ swab16(tkip_sbox[val >> 8]);\n}\n\nstatic u8 *write_tkip_iv(u8 *pos, u16 iv16)\n{\n\t*pos++ = iv16 >> 8;\n\t*pos++ = ((iv16 >> 8) | 0x20) & 0x7f;\n\t*pos++ = iv16 & 0xFF;\n\treturn pos;\n}\n\n \nstatic void tkip_mixing_phase1(const u8 *tk, struct tkip_ctx *ctx,\n\t\t\t       const u8 *ta, u32 tsc_IV32)\n{\n\tint i, j;\n\tu16 *p1k = ctx->p1k;\n\n\tp1k[0] = tsc_IV32 & 0xFFFF;\n\tp1k[1] = tsc_IV32 >> 16;\n\tp1k[2] = get_unaligned_le16(ta + 0);\n\tp1k[3] = get_unaligned_le16(ta + 2);\n\tp1k[4] = get_unaligned_le16(ta + 4);\n\n\tfor (i = 0; i < PHASE1_LOOP_COUNT; i++) {\n\t\tj = 2 * (i & 1);\n\t\tp1k[0] += tkipS(p1k[4] ^ get_unaligned_le16(tk + 0 + j));\n\t\tp1k[1] += tkipS(p1k[0] ^ get_unaligned_le16(tk + 4 + j));\n\t\tp1k[2] += tkipS(p1k[1] ^ get_unaligned_le16(tk + 8 + j));\n\t\tp1k[3] += tkipS(p1k[2] ^ get_unaligned_le16(tk + 12 + j));\n\t\tp1k[4] += tkipS(p1k[3] ^ get_unaligned_le16(tk + 0 + j)) + i;\n\t}\n\tctx->state = TKIP_STATE_PHASE1_DONE;\n\tctx->p1k_iv32 = tsc_IV32;\n}\n\nstatic void tkip_mixing_phase2(const u8 *tk, struct tkip_ctx *ctx,\n\t\t\t       u16 tsc_IV16, u8 *rc4key)\n{\n\tu16 ppk[6];\n\tconst u16 *p1k = ctx->p1k;\n\tint i;\n\n\tppk[0] = p1k[0];\n\tppk[1] = p1k[1];\n\tppk[2] = p1k[2];\n\tppk[3] = p1k[3];\n\tppk[4] = p1k[4];\n\tppk[5] = p1k[4] + tsc_IV16;\n\n\tppk[0] += tkipS(ppk[5] ^ get_unaligned_le16(tk + 0));\n\tppk[1] += tkipS(ppk[0] ^ get_unaligned_le16(tk + 2));\n\tppk[2] += tkipS(ppk[1] ^ get_unaligned_le16(tk + 4));\n\tppk[3] += tkipS(ppk[2] ^ get_unaligned_le16(tk + 6));\n\tppk[4] += tkipS(ppk[3] ^ get_unaligned_le16(tk + 8));\n\tppk[5] += tkipS(ppk[4] ^ get_unaligned_le16(tk + 10));\n\tppk[0] += ror16(ppk[5] ^ get_unaligned_le16(tk + 12), 1);\n\tppk[1] += ror16(ppk[0] ^ get_unaligned_le16(tk + 14), 1);\n\tppk[2] += ror16(ppk[1], 1);\n\tppk[3] += ror16(ppk[2], 1);\n\tppk[4] += ror16(ppk[3], 1);\n\tppk[5] += ror16(ppk[4], 1);\n\n\trc4key = write_tkip_iv(rc4key, tsc_IV16);\n\t*rc4key++ = ((ppk[5] ^ get_unaligned_le16(tk)) >> 1) & 0xFF;\n\n\tfor (i = 0; i < 6; i++)\n\t\tput_unaligned_le16(ppk[i], rc4key + 2 * i);\n}\n\n \nu8 *ieee80211_tkip_add_iv(u8 *pos, struct ieee80211_key_conf *keyconf, u64 pn)\n{\n\tpos = write_tkip_iv(pos, TKIP_PN_TO_IV16(pn));\n\t*pos++ = (keyconf->keyidx << 6) | (1 << 5)  ;\n\tput_unaligned_le32(TKIP_PN_TO_IV32(pn), pos);\n\treturn pos + 4;\n}\nEXPORT_SYMBOL_GPL(ieee80211_tkip_add_iv);\n\nstatic void ieee80211_compute_tkip_p1k(struct ieee80211_key *key, u32 iv32)\n{\n\tstruct ieee80211_sub_if_data *sdata = key->sdata;\n\tstruct tkip_ctx *ctx = &key->u.tkip.tx;\n\tconst u8 *tk = &key->conf.key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];\n\n\tlockdep_assert_held(&key->u.tkip.txlock);\n\n\t \n\tif (ctx->p1k_iv32 != iv32 || ctx->state == TKIP_STATE_NOT_INIT)\n\t\ttkip_mixing_phase1(tk, ctx, sdata->vif.addr, iv32);\n}\n\nvoid ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,\n\t\t\t       u32 iv32, u16 *p1k)\n{\n\tstruct ieee80211_key *key = (struct ieee80211_key *)\n\t\t\tcontainer_of(keyconf, struct ieee80211_key, conf);\n\tstruct tkip_ctx *ctx = &key->u.tkip.tx;\n\n\tspin_lock_bh(&key->u.tkip.txlock);\n\tieee80211_compute_tkip_p1k(key, iv32);\n\tmemcpy(p1k, ctx->p1k, sizeof(ctx->p1k));\n\tspin_unlock_bh(&key->u.tkip.txlock);\n}\nEXPORT_SYMBOL(ieee80211_get_tkip_p1k_iv);\n\nvoid ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,\n\t\t\t       const u8 *ta, u32 iv32, u16 *p1k)\n{\n\tconst u8 *tk = &keyconf->key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];\n\tstruct tkip_ctx ctx;\n\n\ttkip_mixing_phase1(tk, &ctx, ta, iv32);\n\tmemcpy(p1k, ctx.p1k, sizeof(ctx.p1k));\n}\nEXPORT_SYMBOL(ieee80211_get_tkip_rx_p1k);\n\nvoid ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,\n\t\t\t    struct sk_buff *skb, u8 *p2k)\n{\n\tstruct ieee80211_key *key = (struct ieee80211_key *)\n\t\t\tcontainer_of(keyconf, struct ieee80211_key, conf);\n\tconst u8 *tk = &key->conf.key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];\n\tstruct tkip_ctx *ctx = &key->u.tkip.tx;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tconst u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);\n\tu32 iv32 = get_unaligned_le32(&data[4]);\n\tu16 iv16 = data[2] | (data[0] << 8);\n\n\tspin_lock(&key->u.tkip.txlock);\n\tieee80211_compute_tkip_p1k(key, iv32);\n\ttkip_mixing_phase2(tk, ctx, iv16, p2k);\n\tspin_unlock(&key->u.tkip.txlock);\n}\nEXPORT_SYMBOL(ieee80211_get_tkip_p2k);\n\n \nint ieee80211_tkip_encrypt_data(struct arc4_ctx *ctx,\n\t\t\t\tstruct ieee80211_key *key,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tu8 *payload, size_t payload_len)\n{\n\tu8 rc4key[16];\n\n\tieee80211_get_tkip_p2k(&key->conf, skb, rc4key);\n\n\treturn ieee80211_wep_encrypt_data(ctx, rc4key, 16,\n\t\t\t\t\t  payload, payload_len);\n}\n\n \nint ieee80211_tkip_decrypt_data(struct arc4_ctx *ctx,\n\t\t\t\tstruct ieee80211_key *key,\n\t\t\t\tu8 *payload, size_t payload_len, u8 *ta,\n\t\t\t\tu8 *ra, int only_iv, int queue,\n\t\t\t\tu32 *out_iv32, u16 *out_iv16)\n{\n\tu32 iv32;\n\tu32 iv16;\n\tu8 rc4key[16], keyid, *pos = payload;\n\tint res;\n\tconst u8 *tk = &key->conf.key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];\n\tstruct tkip_ctx_rx *rx_ctx = &key->u.tkip.rx[queue];\n\n\tif (payload_len < 12)\n\t\treturn -1;\n\n\tiv16 = (pos[0] << 8) | pos[2];\n\tkeyid = pos[3];\n\tiv32 = get_unaligned_le32(pos + 4);\n\tpos += 8;\n\n\tif (!(keyid & (1 << 5)))\n\t\treturn TKIP_DECRYPT_NO_EXT_IV;\n\n\tif ((keyid >> 6) != key->conf.keyidx)\n\t\treturn TKIP_DECRYPT_INVALID_KEYIDX;\n\n\t \n\tif (iv32 < rx_ctx->iv32 ||\n\t    (iv32 == rx_ctx->iv32 &&\n\t     (iv16 < rx_ctx->iv16 ||\n\t      (iv16 == rx_ctx->iv16 &&\n\t       (rx_ctx->iv32 || rx_ctx->iv16 ||\n\t\trx_ctx->ctx.state != TKIP_STATE_NOT_INIT)))))\n\t\treturn TKIP_DECRYPT_REPLAY;\n\n\tif (only_iv) {\n\t\tres = TKIP_DECRYPT_OK;\n\t\trx_ctx->ctx.state = TKIP_STATE_PHASE1_HW_UPLOADED;\n\t\tgoto done;\n\t}\n\n\tif (rx_ctx->ctx.state == TKIP_STATE_NOT_INIT ||\n\t    rx_ctx->iv32 != iv32) {\n\t\t \n\t\ttkip_mixing_phase1(tk, &rx_ctx->ctx, ta, iv32);\n\t}\n\tif (key->local->ops->update_tkip_key &&\n\t    key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE &&\n\t    rx_ctx->ctx.state != TKIP_STATE_PHASE1_HW_UPLOADED) {\n\t\tstruct ieee80211_sub_if_data *sdata = key->sdata;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tsdata = container_of(key->sdata->bss,\n\t\t\t\t\tstruct ieee80211_sub_if_data, u.ap);\n\t\tdrv_update_tkip_key(key->local, sdata, &key->conf, key->sta,\n\t\t\t\tiv32, rx_ctx->ctx.p1k);\n\t\trx_ctx->ctx.state = TKIP_STATE_PHASE1_HW_UPLOADED;\n\t}\n\n\ttkip_mixing_phase2(tk, &rx_ctx->ctx, iv16, rc4key);\n\n\tres = ieee80211_wep_decrypt_data(ctx, rc4key, 16, pos, payload_len - 12);\n done:\n\tif (res == TKIP_DECRYPT_OK) {\n\t\t \n\t\t*out_iv32 = iv32;\n\t\t*out_iv16 = iv16;\n\t}\n\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}