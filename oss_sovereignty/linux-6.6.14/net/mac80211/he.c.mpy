{
  "module_name": "he.c",
  "hash_id": "702afcec04d7d03945baeee65ce146c197ed0e9152b8cf69d2d33183519bb2a7",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/he.c",
  "human_readable_source": "\n \n\n#include \"ieee80211_i.h\"\n\nstatic void\nieee80211_update_from_he_6ghz_capa(const struct ieee80211_he_6ghz_capa *he_6ghz_capa,\n\t\t\t\t   struct link_sta_info *link_sta)\n{\n\tstruct sta_info *sta = link_sta->sta;\n\tenum ieee80211_smps_mode smps_mode;\n\n\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tswitch (le16_get_bits(he_6ghz_capa->capa,\n\t\t\t\t      IEEE80211_HE_6GHZ_CAP_SM_PS)) {\n\t\tcase WLAN_HT_CAP_SM_PS_INVALID:\n\t\tcase WLAN_HT_CAP_SM_PS_STATIC:\n\t\t\tsmps_mode = IEEE80211_SMPS_STATIC;\n\t\t\tbreak;\n\t\tcase WLAN_HT_CAP_SM_PS_DYNAMIC:\n\t\t\tsmps_mode = IEEE80211_SMPS_DYNAMIC;\n\t\t\tbreak;\n\t\tcase WLAN_HT_CAP_SM_PS_DISABLED:\n\t\t\tsmps_mode = IEEE80211_SMPS_OFF;\n\t\t\tbreak;\n\t\t}\n\n\t\tlink_sta->pub->smps_mode = smps_mode;\n\t} else {\n\t\tlink_sta->pub->smps_mode = IEEE80211_SMPS_OFF;\n\t}\n\n\tswitch (le16_get_bits(he_6ghz_capa->capa,\n\t\t\t      IEEE80211_HE_6GHZ_CAP_MAX_MPDU_LEN)) {\n\tcase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454:\n\t\tlink_sta->pub->agg.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_VHT_11454;\n\t\tbreak;\n\tcase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991:\n\t\tlink_sta->pub->agg.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_VHT_7991;\n\t\tbreak;\n\tcase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895:\n\tdefault:\n\t\tlink_sta->pub->agg.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_VHT_3895;\n\t\tbreak;\n\t}\n\n\tieee80211_sta_recalc_aggregates(&sta->sta);\n\n\tlink_sta->pub->he_6ghz_capa = *he_6ghz_capa;\n}\n\nstatic void ieee80211_he_mcs_disable(__le16 *he_mcs)\n{\n\tu32 i;\n\n\tfor (i = 0; i < 8; i++)\n\t\t*he_mcs |= cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << i * 2);\n}\n\nstatic void ieee80211_he_mcs_intersection(__le16 *he_own_rx, __le16 *he_peer_rx,\n\t\t\t\t\t  __le16 *he_own_tx, __le16 *he_peer_tx)\n{\n\tu32 i;\n\tu16 own_rx, own_tx, peer_rx, peer_tx;\n\n\tfor (i = 0; i < 8; i++) {\n\t\town_rx = le16_to_cpu(*he_own_rx);\n\t\town_rx = (own_rx >> i * 2) & IEEE80211_HE_MCS_NOT_SUPPORTED;\n\n\t\town_tx = le16_to_cpu(*he_own_tx);\n\t\town_tx = (own_tx >> i * 2) & IEEE80211_HE_MCS_NOT_SUPPORTED;\n\n\t\tpeer_rx = le16_to_cpu(*he_peer_rx);\n\t\tpeer_rx = (peer_rx >> i * 2) & IEEE80211_HE_MCS_NOT_SUPPORTED;\n\n\t\tpeer_tx = le16_to_cpu(*he_peer_tx);\n\t\tpeer_tx = (peer_tx >> i * 2) & IEEE80211_HE_MCS_NOT_SUPPORTED;\n\n\t\tif (peer_tx != IEEE80211_HE_MCS_NOT_SUPPORTED) {\n\t\t\tif (own_rx == IEEE80211_HE_MCS_NOT_SUPPORTED)\n\t\t\t\tpeer_tx = IEEE80211_HE_MCS_NOT_SUPPORTED;\n\t\t\telse if (own_rx < peer_tx)\n\t\t\t\tpeer_tx = own_rx;\n\t\t}\n\n\t\tif (peer_rx != IEEE80211_HE_MCS_NOT_SUPPORTED) {\n\t\t\tif (own_tx == IEEE80211_HE_MCS_NOT_SUPPORTED)\n\t\t\t\tpeer_rx = IEEE80211_HE_MCS_NOT_SUPPORTED;\n\t\t\telse if (own_tx < peer_rx)\n\t\t\t\tpeer_rx = own_tx;\n\t\t}\n\n\t\t*he_peer_rx &=\n\t\t\t~cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << i * 2);\n\t\t*he_peer_rx |= cpu_to_le16(peer_rx << i * 2);\n\n\t\t*he_peer_tx &=\n\t\t\t~cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << i * 2);\n\t\t*he_peer_tx |= cpu_to_le16(peer_tx << i * 2);\n\t}\n}\n\nvoid\nieee80211_he_cap_ie_to_sta_he_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct ieee80211_supported_band *sband,\n\t\t\t\t  const u8 *he_cap_ie, u8 he_cap_len,\n\t\t\t\t  const struct ieee80211_he_6ghz_capa *he_6ghz_capa,\n\t\t\t\t  struct link_sta_info *link_sta)\n{\n\tstruct ieee80211_sta_he_cap *he_cap = &link_sta->pub->he_cap;\n\tconst struct ieee80211_sta_he_cap *own_he_cap_ptr;\n\tstruct ieee80211_sta_he_cap own_he_cap;\n\tstruct ieee80211_he_cap_elem *he_cap_ie_elem = (void *)he_cap_ie;\n\tu8 he_ppe_size;\n\tu8 mcs_nss_size;\n\tu8 he_total_size;\n\tbool own_160, peer_160, own_80p80, peer_80p80;\n\n\tmemset(he_cap, 0, sizeof(*he_cap));\n\n\tif (!he_cap_ie)\n\t\treturn;\n\n\town_he_cap_ptr =\n\t\tieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);\n\tif (!own_he_cap_ptr)\n\t\treturn;\n\n\town_he_cap = *own_he_cap_ptr;\n\n\t \n\tmcs_nss_size = ieee80211_he_mcs_nss_size(he_cap_ie_elem);\n\the_ppe_size =\n\t\tieee80211_he_ppe_size(he_cap_ie[sizeof(he_cap->he_cap_elem) +\n\t\t\t\t\t\tmcs_nss_size],\n\t\t\t\t      he_cap_ie_elem->phy_cap_info);\n\the_total_size = sizeof(he_cap->he_cap_elem) + mcs_nss_size +\n\t\t\the_ppe_size;\n\tif (he_cap_len < he_total_size)\n\t\treturn;\n\n\tmemcpy(&he_cap->he_cap_elem, he_cap_ie, sizeof(he_cap->he_cap_elem));\n\n\t \n\tmemcpy(&he_cap->he_mcs_nss_supp,\n\t       &he_cap_ie[sizeof(he_cap->he_cap_elem)], mcs_nss_size);\n\n\t \n\tif (he_cap->he_cap_elem.phy_cap_info[6] &\n\t    IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT)\n\t\tmemcpy(he_cap->ppe_thres,\n\t\t       &he_cap_ie[sizeof(he_cap->he_cap_elem) + mcs_nss_size],\n\t\t       he_ppe_size);\n\n\the_cap->has_he = true;\n\n\tlink_sta->cur_max_bandwidth = ieee80211_sta_cap_rx_bw(link_sta);\n\tlink_sta->pub->bandwidth = ieee80211_sta_cur_vht_bw(link_sta);\n\n\tif (sband->band == NL80211_BAND_6GHZ && he_6ghz_capa)\n\t\tieee80211_update_from_he_6ghz_capa(he_6ghz_capa, link_sta);\n\n\tieee80211_he_mcs_intersection(&own_he_cap.he_mcs_nss_supp.rx_mcs_80,\n\t\t\t\t      &he_cap->he_mcs_nss_supp.rx_mcs_80,\n\t\t\t\t      &own_he_cap.he_mcs_nss_supp.tx_mcs_80,\n\t\t\t\t      &he_cap->he_mcs_nss_supp.tx_mcs_80);\n\n\town_160 = own_he_cap.he_cap_elem.phy_cap_info[0] &\n\t\t  IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;\n\tpeer_160 = he_cap->he_cap_elem.phy_cap_info[0] &\n\t\t   IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;\n\n\tif (peer_160 && own_160) {\n\t\tieee80211_he_mcs_intersection(&own_he_cap.he_mcs_nss_supp.rx_mcs_160,\n\t\t\t\t\t      &he_cap->he_mcs_nss_supp.rx_mcs_160,\n\t\t\t\t\t      &own_he_cap.he_mcs_nss_supp.tx_mcs_160,\n\t\t\t\t\t      &he_cap->he_mcs_nss_supp.tx_mcs_160);\n\t} else if (peer_160 && !own_160) {\n\t\tieee80211_he_mcs_disable(&he_cap->he_mcs_nss_supp.rx_mcs_160);\n\t\tieee80211_he_mcs_disable(&he_cap->he_mcs_nss_supp.tx_mcs_160);\n\t\the_cap->he_cap_elem.phy_cap_info[0] &=\n\t\t\t~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;\n\t}\n\n\town_80p80 = own_he_cap.he_cap_elem.phy_cap_info[0] &\n\t\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G;\n\tpeer_80p80 = he_cap->he_cap_elem.phy_cap_info[0] &\n\t\t     IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G;\n\n\tif (peer_80p80 && own_80p80) {\n\t\tieee80211_he_mcs_intersection(&own_he_cap.he_mcs_nss_supp.rx_mcs_80p80,\n\t\t\t\t\t      &he_cap->he_mcs_nss_supp.rx_mcs_80p80,\n\t\t\t\t\t      &own_he_cap.he_mcs_nss_supp.tx_mcs_80p80,\n\t\t\t\t\t      &he_cap->he_mcs_nss_supp.tx_mcs_80p80);\n\t} else if (peer_80p80 && !own_80p80) {\n\t\tieee80211_he_mcs_disable(&he_cap->he_mcs_nss_supp.rx_mcs_80p80);\n\t\tieee80211_he_mcs_disable(&he_cap->he_mcs_nss_supp.tx_mcs_80p80);\n\t\the_cap->he_cap_elem.phy_cap_info[0] &=\n\t\t\t~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G;\n\t}\n}\n\nvoid\nieee80211_he_op_ie_to_bss_conf(struct ieee80211_vif *vif,\n\t\t\tconst struct ieee80211_he_operation *he_op_ie)\n{\n\tmemset(&vif->bss_conf.he_oper, 0, sizeof(vif->bss_conf.he_oper));\n\tif (!he_op_ie)\n\t\treturn;\n\n\tvif->bss_conf.he_oper.params = __le32_to_cpu(he_op_ie->he_oper_params);\n\tvif->bss_conf.he_oper.nss_set = __le16_to_cpu(he_op_ie->he_mcs_nss_set);\n}\n\nvoid\nieee80211_he_spr_ie_to_bss_conf(struct ieee80211_vif *vif,\n\t\t\t\tconst struct ieee80211_he_spr *he_spr_ie_elem)\n{\n\tstruct ieee80211_he_obss_pd *he_obss_pd =\n\t\t\t\t\t&vif->bss_conf.he_obss_pd;\n\tconst u8 *data;\n\n\tmemset(he_obss_pd, 0, sizeof(*he_obss_pd));\n\n\tif (!he_spr_ie_elem)\n\t\treturn;\n\tdata = he_spr_ie_elem->optional;\n\n\tif (he_spr_ie_elem->he_sr_control &\n\t    IEEE80211_HE_SPR_NON_SRG_OFFSET_PRESENT)\n\t\tdata++;\n\tif (he_spr_ie_elem->he_sr_control &\n\t    IEEE80211_HE_SPR_SRG_INFORMATION_PRESENT) {\n\t\the_obss_pd->max_offset = *data++;\n\t\the_obss_pd->min_offset = *data++;\n\t\the_obss_pd->enable = true;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}