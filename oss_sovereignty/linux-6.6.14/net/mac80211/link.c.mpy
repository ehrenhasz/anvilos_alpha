{
  "module_name": "link.c",
  "hash_id": "b8311c734723f1f36a3fe2a009edf416fb81ca955b3ddd4eed3036f607744f69",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/link.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"key.h\"\n#include \"debugfs_netdev.h\"\n\nvoid ieee80211_link_setup(struct ieee80211_link_data *link)\n{\n\tif (link->sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\tieee80211_mgd_setup_link(link);\n}\n\nvoid ieee80211_link_init(struct ieee80211_sub_if_data *sdata,\n\t\t\t int link_id,\n\t\t\t struct ieee80211_link_data *link,\n\t\t\t struct ieee80211_bss_conf *link_conf)\n{\n\tbool deflink = link_id < 0;\n\n\tif (link_id < 0)\n\t\tlink_id = 0;\n\n\trcu_assign_pointer(sdata->vif.link_conf[link_id], link_conf);\n\trcu_assign_pointer(sdata->link[link_id], link);\n\n\tlink->sdata = sdata;\n\tlink->link_id = link_id;\n\tlink->conf = link_conf;\n\tlink_conf->link_id = link_id;\n\tlink_conf->vif = &sdata->vif;\n\n\tINIT_WORK(&link->csa_finalize_work,\n\t\t  ieee80211_csa_finalize_work);\n\tINIT_WORK(&link->color_change_finalize_work,\n\t\t  ieee80211_color_change_finalize_work);\n\tINIT_DELAYED_WORK(&link->color_collision_detect_work,\n\t\t\t  ieee80211_color_collision_detection_work);\n\tINIT_LIST_HEAD(&link->assigned_chanctx_list);\n\tINIT_LIST_HEAD(&link->reserved_chanctx_list);\n\tINIT_DELAYED_WORK(&link->dfs_cac_timer_work,\n\t\t\t  ieee80211_dfs_cac_timer_work);\n\n\tif (!deflink) {\n\t\tswitch (sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\tether_addr_copy(link_conf->addr,\n\t\t\t\t\tsdata->wdev.links[link_id].addr);\n\t\t\tlink_conf->bssid = link_conf->addr;\n\t\t\tWARN_ON(!(sdata->wdev.valid_links & BIT(link_id)));\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tieee80211_link_debugfs_add(link);\n\t}\n}\n\nvoid ieee80211_link_stop(struct ieee80211_link_data *link)\n{\n\tif (link->sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\tieee80211_mgd_stop_link(link);\n\n\tcancel_delayed_work_sync(&link->color_collision_detect_work);\n\tieee80211_link_release_channel(link);\n}\n\nstruct link_container {\n\tstruct ieee80211_link_data data;\n\tstruct ieee80211_bss_conf conf;\n};\n\nstatic void ieee80211_tear_down_links(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct link_container **links, u16 mask)\n{\n\tstruct ieee80211_link_data *link;\n\tLIST_HEAD(keys);\n\tunsigned int link_id;\n\n\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {\n\t\tif (!(mask & BIT(link_id)))\n\t\t\tcontinue;\n\t\tlink = &links[link_id]->data;\n\t\tif (link_id == 0 && !link)\n\t\t\tlink = &sdata->deflink;\n\t\tif (WARN_ON(!link))\n\t\t\tcontinue;\n\t\tieee80211_remove_link_keys(link, &keys);\n\t\tieee80211_link_debugfs_remove(link);\n\t\tieee80211_link_stop(link);\n\t}\n\n\tsynchronize_rcu();\n\n\tieee80211_free_key_list(sdata->local, &keys);\n}\n\nstatic void ieee80211_free_links(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct link_container **links)\n{\n\tunsigned int link_id;\n\n\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++)\n\t\tkfree(links[link_id]);\n}\n\nstatic int ieee80211_check_dup_link_addrs(struct ieee80211_sub_if_data *sdata)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++) {\n\t\tstruct ieee80211_link_data *link1;\n\n\t\tlink1 = sdata_dereference(sdata->link[i], sdata);\n\t\tif (!link1)\n\t\t\tcontinue;\n\t\tfor (j = i + 1; j < IEEE80211_MLD_MAX_NUM_LINKS; j++) {\n\t\t\tstruct ieee80211_link_data *link2;\n\n\t\t\tlink2 = sdata_dereference(sdata->link[j], sdata);\n\t\t\tif (!link2)\n\t\t\t\tcontinue;\n\n\t\t\tif (ether_addr_equal(link1->conf->addr,\n\t\t\t\t\t     link2->conf->addr))\n\t\t\t\treturn -EALREADY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ieee80211_set_vif_links_bitmaps(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    u16 valid_links, u16 dormant_links)\n{\n\tsdata->vif.valid_links = valid_links;\n\tsdata->vif.dormant_links = dormant_links;\n\n\tif (!valid_links ||\n\t    WARN((~valid_links & dormant_links) ||\n\t\t !(valid_links & ~dormant_links),\n\t\t \"Invalid links: valid=0x%x, dormant=0x%x\",\n\t\t valid_links, dormant_links)) {\n\t\tsdata->vif.active_links = 0;\n\t\tsdata->vif.dormant_links = 0;\n\t\treturn;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\t\t \n\t\tsdata->vif.active_links = valid_links;\n\n\t\t \n\t\tWARN_ON(dormant_links);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (sdata->vif.active_links)\n\t\t\tbreak;\n\t\tsdata->vif.active_links = valid_links & ~dormant_links;\n\t\tWARN_ON(hweight16(sdata->vif.active_links) > 1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n\nstatic int ieee80211_vif_update_links(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct link_container **to_free,\n\t\t\t\t      u16 new_links, u16 dormant_links)\n{\n\tu16 old_links = sdata->vif.valid_links;\n\tu16 old_active = sdata->vif.active_links;\n\tunsigned long add = new_links & ~old_links;\n\tunsigned long rem = old_links & ~new_links;\n\tunsigned int link_id;\n\tint ret;\n\tstruct link_container *links[IEEE80211_MLD_MAX_NUM_LINKS] = {}, *link;\n\tstruct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS];\n\tstruct ieee80211_link_data *old_data[IEEE80211_MLD_MAX_NUM_LINKS];\n\tbool use_deflink = old_links == 0;  \n\n\tsdata_assert_lock(sdata);\n\n\tmemset(to_free, 0, sizeof(links));\n\n\tif (old_links == new_links && dormant_links == sdata->vif.dormant_links)\n\t\treturn 0;\n\n\t \n\tif (!old_links)\n\t\trem |= BIT(0);\n\n\t \n\tfor_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tlink = kzalloc(sizeof(*link), GFP_KERNEL);\n\t\tif (!link) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t\tlinks[link_id] = link;\n\t}\n\n\t \n\tBUILD_BUG_ON(sizeof(old) != sizeof(sdata->vif.link_conf));\n\tmemcpy(old, sdata->vif.link_conf, sizeof(old));\n\t \n\tBUILD_BUG_ON(sizeof(old_data) != sizeof(sdata->link));\n\tmemcpy(old_data, sdata->link, sizeof(old_data));\n\n\t \n\tfor_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tif (rcu_access_pointer(sdata->link[link_id]) != &sdata->deflink) {\n\t\t\t \n\t\t\tto_free[link_id] = container_of(rcu_access_pointer(sdata->link[link_id]),\n\t\t\t\t\t\t\ttypeof(*links[link_id]),\n\t\t\t\t\t\t\tdata);\n\t\t}\n\n\t\tRCU_INIT_POINTER(sdata->link[link_id], NULL);\n\t\tRCU_INIT_POINTER(sdata->vif.link_conf[link_id], NULL);\n\t}\n\n\t \n\tfor_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tWARN_ON(!use_deflink &&\n\t\t\trcu_access_pointer(sdata->link[link_id]) == &sdata->deflink);\n\n\t\tlink = links[link_id];\n\t\tieee80211_link_init(sdata, link_id, &link->data, &link->conf);\n\t\tieee80211_link_setup(&link->data);\n\t}\n\n\tif (new_links == 0)\n\t\tieee80211_link_init(sdata, -1, &sdata->deflink,\n\t\t\t\t    &sdata->vif.bss_conf);\n\n\tret = ieee80211_check_dup_link_addrs(sdata);\n\tif (!ret) {\n\t\t \n\t\tieee80211_tear_down_links(sdata, to_free, rem);\n\n\t\tieee80211_set_vif_links_bitmaps(sdata, new_links, dormant_links);\n\n\t\t \n\t\tret = drv_change_vif_links(sdata->local, sdata,\n\t\t\t\t\t   old_links & old_active,\n\t\t\t\t\t   new_links & sdata->vif.active_links,\n\t\t\t\t\t   old);\n\t}\n\n\tif (ret) {\n\t\t \n\t\tmemcpy(sdata->link, old_data, sizeof(old_data));\n\t\tmemcpy(sdata->vif.link_conf, old, sizeof(old));\n\t\tieee80211_set_vif_links_bitmaps(sdata, old_links, dormant_links);\n\t\t \n\t\tmemset(to_free, 0, sizeof(links));\n\t\tgoto free;\n\t}\n\n\t \n\tuse_deflink = new_links == 0;\n\n\tgoto deinit;\nfree:\n\t \n\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {\n\t\tkfree(links[link_id]);\n\t\tlinks[link_id] = NULL;\n\t}\ndeinit:\n\tif (use_deflink)\n\t\tieee80211_link_init(sdata, -1, &sdata->deflink,\n\t\t\t\t    &sdata->vif.bss_conf);\n\treturn ret;\n}\n\nint ieee80211_vif_set_links(struct ieee80211_sub_if_data *sdata,\n\t\t\t    u16 new_links, u16 dormant_links)\n{\n\tstruct link_container *links[IEEE80211_MLD_MAX_NUM_LINKS];\n\tint ret;\n\n\tret = ieee80211_vif_update_links(sdata, links, new_links,\n\t\t\t\t\t dormant_links);\n\tieee80211_free_links(sdata, links);\n\n\treturn ret;\n}\n\nvoid ieee80211_vif_clear_links(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct link_container *links[IEEE80211_MLD_MAX_NUM_LINKS];\n\n\t \n\n\tsdata_lock(sdata);\n\tieee80211_vif_update_links(sdata, links, 0, 0);\n\tsdata_unlock(sdata);\n\n\tieee80211_free_links(sdata, links);\n}\n\nstatic int _ieee80211_set_active_links(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       u16 active_links)\n{\n\tstruct ieee80211_bss_conf *link_confs[IEEE80211_MLD_MAX_NUM_LINKS];\n\tstruct ieee80211_local *local = sdata->local;\n\tu16 old_active = sdata->vif.active_links;\n\tunsigned long rem = old_active & ~active_links;\n\tunsigned long add = active_links & ~old_active;\n\tstruct sta_info *sta;\n\tunsigned int link_id;\n\tint ret, i;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn -ENETDOWN;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn -EINVAL;\n\n\tif (active_links & ~ieee80211_vif_usable_links(&sdata->vif))\n\t\treturn -EINVAL;\n\n\t \n\tif (old_active == active_links)\n\t\treturn 0;\n\n\tfor (i = 0; i < IEEE80211_MLD_MAX_NUM_LINKS; i++)\n\t\tlink_confs[i] = sdata_dereference(sdata->vif.link_conf[i],\n\t\t\t\t\t\t  sdata);\n\n\tif (add) {\n\t\tsdata->vif.active_links |= active_links;\n\t\tret = drv_change_vif_links(local, sdata,\n\t\t\t\t\t   old_active,\n\t\t\t\t\t   sdata->vif.active_links,\n\t\t\t\t\t   link_confs);\n\t\tif (ret) {\n\t\t\tsdata->vif.active_links = old_active;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tstruct ieee80211_link_data *link;\n\n\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\n\t\t \n\n\t\tieee80211_link_release_channel(link);\n\t}\n\n\tlist_for_each_entry(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\n\t\t \n\t\t__ieee80211_sta_recalc_aggregates(sta,\n\t\t\t\t\t\t  old_active | active_links);\n\n\t\tret = drv_change_sta_links(local, sdata, &sta->sta,\n\t\t\t\t\t   old_active,\n\t\t\t\t\t   old_active | active_links);\n\t\tWARN_ON_ONCE(ret);\n\t}\n\n\tret = ieee80211_key_switch_links(sdata, rem, add);\n\tWARN_ON_ONCE(ret);\n\n\tlist_for_each_entry(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\n\t\t__ieee80211_sta_recalc_aggregates(sta, active_links);\n\n\t\tret = drv_change_sta_links(local, sdata, &sta->sta,\n\t\t\t\t\t   old_active | active_links,\n\t\t\t\t\t   active_links);\n\t\tWARN_ON_ONCE(ret);\n\n\t\t \n\t\t__ieee80211_sta_recalc_aggregates(sta, active_links);\n\t}\n\n\tfor_each_set_bit(link_id, &add, IEEE80211_MLD_MAX_NUM_LINKS) {\n\t\tstruct ieee80211_link_data *link;\n\n\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\n\t\tret = ieee80211_link_use_channel(link, &link->conf->chandef,\n\t\t\t\t\t\t IEEE80211_CHANCTX_SHARED);\n\t\tWARN_ON_ONCE(ret);\n\n\t\tieee80211_mgd_set_link_qos_params(link);\n\t\tieee80211_link_info_change_notify(sdata, link,\n\t\t\t\t\t\t  BSS_CHANGED_ERP_CTS_PROT |\n\t\t\t\t\t\t  BSS_CHANGED_ERP_PREAMBLE |\n\t\t\t\t\t\t  BSS_CHANGED_ERP_SLOT |\n\t\t\t\t\t\t  BSS_CHANGED_HT |\n\t\t\t\t\t\t  BSS_CHANGED_BASIC_RATES |\n\t\t\t\t\t\t  BSS_CHANGED_BSSID |\n\t\t\t\t\t\t  BSS_CHANGED_CQM |\n\t\t\t\t\t\t  BSS_CHANGED_QOS |\n\t\t\t\t\t\t  BSS_CHANGED_TXPOWER |\n\t\t\t\t\t\t  BSS_CHANGED_BANDWIDTH |\n\t\t\t\t\t\t  BSS_CHANGED_TWT |\n\t\t\t\t\t\t  BSS_CHANGED_HE_OBSS_PD |\n\t\t\t\t\t\t  BSS_CHANGED_HE_BSS_COLOR);\n\t}\n\n\told_active = sdata->vif.active_links;\n\tsdata->vif.active_links = active_links;\n\n\tif (rem) {\n\t\tret = drv_change_vif_links(local, sdata, old_active,\n\t\t\t\t\t   active_links, link_confs);\n\t\tWARN_ON_ONCE(ret);\n\t}\n\n\treturn 0;\n}\n\nint __ieee80211_set_active_links(struct ieee80211_vif *vif, u16 active_links)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_local *local = sdata->local;\n\tu16 old_active;\n\tint ret;\n\n\tsdata_assert_lock(sdata);\n\tmutex_lock(&local->sta_mtx);\n\tmutex_lock(&local->mtx);\n\tmutex_lock(&local->key_mtx);\n\told_active = sdata->vif.active_links;\n\tif (old_active & active_links) {\n\t\t \n\t\tret = _ieee80211_set_active_links(sdata,\n\t\t\t\t\t\t  old_active & active_links);\n\t\tif (!ret)\n\t\t\tret = _ieee80211_set_active_links(sdata, active_links);\n\t} else {\n\t\t \n\t\tret = _ieee80211_set_active_links(sdata, active_links);\n\t}\n\tmutex_unlock(&local->key_mtx);\n\tmutex_unlock(&local->mtx);\n\tmutex_unlock(&local->sta_mtx);\n\n\treturn ret;\n}\n\nint ieee80211_set_active_links(struct ieee80211_vif *vif, u16 active_links)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tint ret;\n\n\tsdata_lock(sdata);\n\tret = __ieee80211_set_active_links(vif, active_links);\n\tsdata_unlock(sdata);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ieee80211_set_active_links);\n\nvoid ieee80211_set_active_links_async(struct ieee80211_vif *vif,\n\t\t\t\t      u16 active_links)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (active_links & ~ieee80211_vif_usable_links(&sdata->vif))\n\t\treturn;\n\n\t \n\tif (sdata->vif.active_links == active_links)\n\t\treturn;\n\n\tsdata->desired_active_links = active_links;\n\tschedule_work(&sdata->activate_links_work);\n}\nEXPORT_SYMBOL_GPL(ieee80211_set_active_links_async);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}