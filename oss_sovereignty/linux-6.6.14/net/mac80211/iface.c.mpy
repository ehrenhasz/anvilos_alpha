{
  "module_name": "iface.c",
  "hash_id": "7272d374d363584737f294f342ed1ad57353f181b766ca1500931baad7a825eb",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/iface.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/kcov.h>\n#include <net/mac80211.h>\n#include <net/ieee80211_radiotap.h>\n#include \"ieee80211_i.h\"\n#include \"sta_info.h\"\n#include \"debugfs_netdev.h\"\n#include \"mesh.h\"\n#include \"led.h\"\n#include \"driver-ops.h\"\n#include \"wme.h\"\n#include \"rate.h\"\n\n \n\nstatic void ieee80211_iface_work(struct wiphy *wiphy, struct wiphy_work *work);\n\nbool __ieee80211_recalc_txpower(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tint power;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tif (!chanctx_conf) {\n\t\trcu_read_unlock();\n\t\treturn false;\n\t}\n\n\tpower = ieee80211_chandef_max_power(&chanctx_conf->def);\n\trcu_read_unlock();\n\n\tif (sdata->deflink.user_power_level != IEEE80211_UNSET_POWER_LEVEL)\n\t\tpower = min(power, sdata->deflink.user_power_level);\n\n\tif (sdata->deflink.ap_power_level != IEEE80211_UNSET_POWER_LEVEL)\n\t\tpower = min(power, sdata->deflink.ap_power_level);\n\n\tif (power != sdata->vif.bss_conf.txpower) {\n\t\tsdata->vif.bss_conf.txpower = power;\n\t\tieee80211_hw_config(sdata->local, 0);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid ieee80211_recalc_txpower(struct ieee80211_sub_if_data *sdata,\n\t\t\t      bool update_bss)\n{\n\tif (__ieee80211_recalc_txpower(sdata) ||\n\t    (update_bss && ieee80211_sdata_running(sdata)))\n\t\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t\t  BSS_CHANGED_TXPOWER);\n}\n\nstatic u32 __ieee80211_idle_off(struct ieee80211_local *local)\n{\n\tif (!(local->hw.conf.flags & IEEE80211_CONF_IDLE))\n\t\treturn 0;\n\n\tlocal->hw.conf.flags &= ~IEEE80211_CONF_IDLE;\n\treturn IEEE80211_CONF_CHANGE_IDLE;\n}\n\nstatic u32 __ieee80211_idle_on(struct ieee80211_local *local)\n{\n\tif (local->hw.conf.flags & IEEE80211_CONF_IDLE)\n\t\treturn 0;\n\n\tieee80211_flush_queues(local, NULL, false);\n\n\tlocal->hw.conf.flags |= IEEE80211_CONF_IDLE;\n\treturn IEEE80211_CONF_CHANGE_IDLE;\n}\n\nstatic u32 __ieee80211_recalc_idle(struct ieee80211_local *local,\n\t\t\t\t   bool force_active)\n{\n\tbool working, scanning, active;\n\tunsigned int led_trig_start = 0, led_trig_stop = 0;\n\n\tlockdep_assert_held(&local->mtx);\n\n\tactive = force_active ||\n\t\t !list_empty(&local->chanctx_list) ||\n\t\t local->monitors;\n\n\tworking = !local->ops->remain_on_channel &&\n\t\t  !list_empty(&local->roc_list);\n\n\tscanning = test_bit(SCAN_SW_SCANNING, &local->scanning) ||\n\t\t   test_bit(SCAN_ONCHANNEL_SCANNING, &local->scanning);\n\n\tif (working || scanning)\n\t\tled_trig_start |= IEEE80211_TPT_LEDTRIG_FL_WORK;\n\telse\n\t\tled_trig_stop |= IEEE80211_TPT_LEDTRIG_FL_WORK;\n\n\tif (active)\n\t\tled_trig_start |= IEEE80211_TPT_LEDTRIG_FL_CONNECTED;\n\telse\n\t\tled_trig_stop |= IEEE80211_TPT_LEDTRIG_FL_CONNECTED;\n\n\tieee80211_mod_tpt_led_trig(local, led_trig_start, led_trig_stop);\n\n\tif (working || scanning || active)\n\t\treturn __ieee80211_idle_off(local);\n\treturn __ieee80211_idle_on(local);\n}\n\nu32 ieee80211_idle_off(struct ieee80211_local *local)\n{\n\treturn __ieee80211_recalc_idle(local, true);\n}\n\nvoid ieee80211_recalc_idle(struct ieee80211_local *local)\n{\n\tu32 change = __ieee80211_recalc_idle(local, false);\n\tif (change)\n\t\tieee80211_hw_config(local, change);\n}\n\nstatic int ieee80211_verify_mac(struct ieee80211_sub_if_data *sdata, u8 *addr,\n\t\t\t\tbool check_dup)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *iter;\n\tu64 new, mask, tmp;\n\tu8 *m;\n\tint ret = 0;\n\n\tif (is_zero_ether_addr(local->hw.wiphy->addr_mask))\n\t\treturn 0;\n\n\tm = addr;\n\tnew =\t((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\tm = local->hw.wiphy->addr_mask;\n\tmask =\t((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\tif (!check_dup)\n\t\treturn ret;\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_for_each_entry(iter, &local->interfaces, list) {\n\t\tif (iter == sdata)\n\t\t\tcontinue;\n\n\t\tif (iter->vif.type == NL80211_IFTYPE_MONITOR &&\n\t\t    !(iter->u.mntr.flags & MONITOR_FLAG_ACTIVE))\n\t\t\tcontinue;\n\n\t\tm = iter->vif.addr;\n\t\ttmp =\t((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\t\tif ((new & ~mask) != (tmp & ~mask)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&local->iflist_mtx);\n\n\treturn ret;\n}\n\nstatic int ieee80211_can_powered_addr_change(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_roc_work *roc;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *scan_sdata;\n\tint ret = 0;\n\n\t \n\tif (netif_carrier_ok(sdata->dev))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&local->mtx);\n\n\t \n\tlist_for_each_entry(roc, &local->roc_list, list) {\n\t\tif (roc->sdata != sdata)\n\t\t\tcontinue;\n\n\t\tif (roc->started) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t \n\tif (local->scanning) {\n\t\tscan_sdata = rcu_dereference_protected(local->scan_sdata,\n\t\t\t\t\t\t       lockdep_is_held(&local->mtx));\n\t\tif (sdata == scan_sdata)\n\t\t\tret = -EBUSY;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\nunlock:\n\tmutex_unlock(&local->mtx);\n\treturn ret;\n}\n\nstatic int ieee80211_change_mac(struct net_device *dev, void *addr)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sockaddr *sa = addr;\n\tbool check_dup = true;\n\tbool live = false;\n\tint ret;\n\n\tif (ieee80211_sdata_running(sdata)) {\n\t\tret = ieee80211_can_powered_addr_change(sdata);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlive = true;\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR &&\n\t    !(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE))\n\t\tcheck_dup = false;\n\n\tret = ieee80211_verify_mac(sdata, sa->sa_data, check_dup);\n\tif (ret)\n\t\treturn ret;\n\n\tif (live)\n\t\tdrv_remove_interface(local, sdata);\n\tret = eth_mac_addr(dev, sa);\n\n\tif (ret == 0) {\n\t\tmemcpy(sdata->vif.addr, sa->sa_data, ETH_ALEN);\n\t\tether_addr_copy(sdata->vif.bss_conf.addr, sdata->vif.addr);\n\t}\n\n\t \n\tif (live)\n\t\tWARN_ON(drv_add_interface(local, sdata));\n\n\treturn ret;\n}\n\nstatic inline int identical_mac_addr_allowed(int type1, int type2)\n{\n\treturn type1 == NL80211_IFTYPE_MONITOR ||\n\t\ttype2 == NL80211_IFTYPE_MONITOR ||\n\t\ttype1 == NL80211_IFTYPE_P2P_DEVICE ||\n\t\ttype2 == NL80211_IFTYPE_P2P_DEVICE ||\n\t\t(type1 == NL80211_IFTYPE_AP && type2 == NL80211_IFTYPE_AP_VLAN) ||\n\t\t(type1 == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t(type2 == NL80211_IFTYPE_AP ||\n\t\t\t type2 == NL80211_IFTYPE_AP_VLAN));\n}\n\nstatic int ieee80211_check_concurrent_iface(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    enum nl80211_iftype iftype)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *nsdata;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\t \n\tlist_for_each_entry(nsdata, &local->interfaces, list) {\n\t\tif (nsdata != sdata && ieee80211_sdata_running(nsdata)) {\n\t\t\t \n\t\t\tif ((sdata->vif.type == NL80211_IFTYPE_OCB &&\n\t\t\t     nsdata->vif.type != NL80211_IFTYPE_MONITOR) ||\n\t\t\t    (sdata->vif.type != NL80211_IFTYPE_MONITOR &&\n\t\t\t     nsdata->vif.type == NL80211_IFTYPE_OCB))\n\t\t\t\treturn -EBUSY;\n\n\t\t\t \n\t\t\tif (iftype == NL80211_IFTYPE_ADHOC &&\n\t\t\t    nsdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\t\t\treturn -EBUSY;\n\t\t\t \n\t\t\tif (nsdata->vif.bss_conf.csa_active)\n\t\t\t\treturn -EBUSY;\n\n\t\t\t \n\t\t\tif (!ether_addr_equal(sdata->vif.addr,\n\t\t\t\t\t      nsdata->vif.addr))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!identical_mac_addr_allowed(iftype,\n\t\t\t\t\t\t\tnsdata->vif.type))\n\t\t\t\treturn -ENOTUNIQ;\n\n\t\t\t \n\t\t\tif (iftype == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t    sdata->wdev.use_4addr &&\n\t\t\t    nsdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t\t    nsdata->vif.valid_links)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\t \n\t\t\tif (iftype == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t    nsdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\t\tsdata->bss = &nsdata->u.ap;\n\t\t}\n\t}\n\n\tmutex_lock(&local->chanctx_mtx);\n\tret = ieee80211_check_combinations(sdata, NULL, 0, 0);\n\tmutex_unlock(&local->chanctx_mtx);\n\treturn ret;\n}\n\nstatic int ieee80211_check_queues(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  enum nl80211_iftype iftype)\n{\n\tint n_queues = sdata->local->hw.queues;\n\tint i;\n\n\tif (iftype == NL80211_IFTYPE_NAN)\n\t\treturn 0;\n\n\tif (iftype != NL80211_IFTYPE_P2P_DEVICE) {\n\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\t\tif (WARN_ON_ONCE(sdata->vif.hw_queue[i] ==\n\t\t\t\t\t IEEE80211_INVAL_HW_QUEUE))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (WARN_ON_ONCE(sdata->vif.hw_queue[i] >=\n\t\t\t\t\t n_queues))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif ((iftype != NL80211_IFTYPE_AP &&\n\t     iftype != NL80211_IFTYPE_P2P_GO &&\n\t     iftype != NL80211_IFTYPE_MESH_POINT) ||\n\t    !ieee80211_hw_check(&sdata->local->hw, QUEUE_CONTROL)) {\n\t\tsdata->vif.cab_queue = IEEE80211_INVAL_HW_QUEUE;\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON_ONCE(sdata->vif.cab_queue == IEEE80211_INVAL_HW_QUEUE))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(sdata->vif.cab_queue >= n_queues))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ieee80211_open(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tint err;\n\n\t \n\tif (!is_valid_ether_addr(dev->dev_addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = ieee80211_check_concurrent_iface(sdata, sdata->vif.type);\n\tif (err)\n\t\treturn err;\n\n\twiphy_lock(sdata->local->hw.wiphy);\n\terr = ieee80211_do_open(&sdata->wdev, true);\n\twiphy_unlock(sdata->local->hw.wiphy);\n\n\treturn err;\n}\n\nstatic void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata, bool going_down)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tunsigned long flags;\n\tstruct sk_buff *skb, *tmp;\n\tu32 hw_reconf_flags = 0;\n\tint i, flushed;\n\tstruct ps_data *ps;\n\tstruct cfg80211_chan_def chandef;\n\tbool cancel_scan;\n\tstruct cfg80211_nan_func *func;\n\n\tclear_bit(SDATA_STATE_RUNNING, &sdata->state);\n\tsynchronize_rcu();  \n\n\tcancel_scan = rcu_access_pointer(local->scan_sdata) == sdata;\n\tif (cancel_scan)\n\t\tieee80211_scan_cancel(local);\n\n\tieee80211_roc_purge(local, sdata);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tieee80211_mgd_stop(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tieee80211_ibss_stop(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES)\n\t\t\tbreak;\n\t\tlist_del_rcu(&sdata->u.mntr.list);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tflushed = sta_info_flush(sdata);\n\tWARN_ON_ONCE(sdata->vif.type != NL80211_IFTYPE_AP_VLAN && flushed > 0);\n\n\t \n\tif (sdata->flags & IEEE80211_SDATA_ALLMULTI)\n\t\tatomic_dec(&local->iff_allmultis);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tlocal->fif_pspoll--;\n\t\tlocal->fif_probe_req--;\n\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tlocal->fif_probe_req--;\n\t}\n\n\tif (sdata->dev) {\n\t\tnetif_addr_lock_bh(sdata->dev);\n\t\tspin_lock_bh(&local->filter_lock);\n\t\t__hw_addr_unsync(&local->mc_list, &sdata->dev->mc,\n\t\t\t\t sdata->dev->addr_len);\n\t\tspin_unlock_bh(&local->filter_lock);\n\t\tnetif_addr_unlock_bh(sdata->dev);\n\t}\n\n\tdel_timer_sync(&local->dynamic_ps_timer);\n\tcancel_work_sync(&local->dynamic_ps_enable_work);\n\n\tcancel_work_sync(&sdata->recalc_smps);\n\n\tsdata_lock(sdata);\n\tWARN(ieee80211_vif_is_mld(&sdata->vif),\n\t     \"destroying interface with valid links 0x%04x\\n\",\n\t     sdata->vif.valid_links);\n\n\tmutex_lock(&local->mtx);\n\tsdata->vif.bss_conf.csa_active = false;\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\tsdata->deflink.u.mgd.csa_waiting_bcn = false;\n\tif (sdata->deflink.csa_block_tx) {\n\t\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_CSA);\n\t\tsdata->deflink.csa_block_tx = false;\n\t}\n\tmutex_unlock(&local->mtx);\n\tsdata_unlock(sdata);\n\n\tcancel_work_sync(&sdata->deflink.csa_finalize_work);\n\tcancel_work_sync(&sdata->deflink.color_change_finalize_work);\n\n\tcancel_delayed_work_sync(&sdata->deflink.dfs_cac_timer_work);\n\n\tif (sdata->wdev.cac_started) {\n\t\tchandef = sdata->vif.bss_conf.chandef;\n\t\tWARN_ON(local->suspended);\n\t\tmutex_lock(&local->mtx);\n\t\tieee80211_link_release_channel(&sdata->deflink);\n\t\tmutex_unlock(&local->mtx);\n\t\tcfg80211_cac_event(sdata->dev, &chandef,\n\t\t\t\t   NL80211_RADAR_CAC_ABORTED,\n\t\t\t\t   GFP_KERNEL);\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tWARN_ON(!list_empty(&sdata->u.ap.vlans));\n\t} else if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\t \n\t\tps = &sdata->bss->ps;\n\n\t\tspin_lock_irqsave(&ps->bc_buf.lock, flags);\n\t\tskb_queue_walk_safe(&ps->bc_buf, skb, tmp) {\n\t\t\tif (skb->dev == sdata->dev) {\n\t\t\t\t__skb_unlink(skb, &ps->bc_buf);\n\t\t\t\tlocal->total_ps_buffered--;\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&ps->bc_buf.lock, flags);\n\t}\n\n\tif (going_down)\n\t\tlocal->open_count--;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tmutex_lock(&local->mtx);\n\t\tlist_del(&sdata->u.vlan.list);\n\t\tmutex_unlock(&local->mtx);\n\t\tRCU_INIT_POINTER(sdata->vif.bss_conf.chanctx_conf, NULL);\n\t\t \n\t\tieee80211_free_keys(sdata, true);\n\t\t \n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES) {\n\t\t\tlocal->cooked_mntrs--;\n\t\t\tbreak;\n\t\t}\n\n\t\tlocal->monitors--;\n\t\tif (local->monitors == 0) {\n\t\t\tlocal->hw.conf.flags &= ~IEEE80211_CONF_MONITOR;\n\t\t\thw_reconf_flags |= IEEE80211_CONF_CHANGE_MONITOR;\n\t\t}\n\n\t\tieee80211_adjust_monitor_flags(sdata, -1);\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\t\t \n\t\tspin_lock_bh(&sdata->u.nan.func_lock);\n\n\t\tidr_for_each_entry(&sdata->u.nan.function_inst_ids, func, i) {\n\t\t\tidr_remove(&sdata->u.nan.function_inst_ids, i);\n\t\t\tcfg80211_free_nan_func(func);\n\t\t}\n\t\tidr_destroy(&sdata->u.nan.function_inst_ids);\n\n\t\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t \n\t\tRCU_INIT_POINTER(local->p2p_sdata, NULL);\n\t\tfallthrough;\n\tdefault:\n\t\twiphy_work_cancel(sdata->local->hw.wiphy, &sdata->work);\n\t\t \n\t\tieee80211_free_keys(sdata, true);\n\t\tskb_queue_purge(&sdata->skb_queue);\n\t\tskb_queue_purge(&sdata->status_queue);\n\t}\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\tfor (i = 0; i < IEEE80211_MAX_QUEUES; i++) {\n\t\tskb_queue_walk_safe(&local->pending[i], skb, tmp) {\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\t\tif (info->control.vif == &sdata->vif) {\n\t\t\t\t__skb_unlink(skb, &local->pending[i]);\n\t\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tieee80211_txq_remove_vlan(local, sdata);\n\n\tsdata->bss = NULL;\n\n\tif (local->open_count == 0)\n\t\tieee80211_clear_tx_pending(local);\n\n\tsdata->vif.bss_conf.beacon_int = 0;\n\n\t \n\tif (local->suspended) {\n\t\tWARN_ON(local->wowlan);\n\t\tWARN_ON(rcu_access_pointer(local->monitor_sdata));\n\t\treturn;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (local->monitors == 0)\n\t\t\tieee80211_del_virtual_monitor(local);\n\n\t\tmutex_lock(&local->mtx);\n\t\tieee80211_recalc_idle(local);\n\t\tmutex_unlock(&local->mtx);\n\n\t\tif (!(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE))\n\t\t\tbreak;\n\n\t\tfallthrough;\n\tdefault:\n\t\tif (going_down)\n\t\t\tdrv_remove_interface(local, sdata);\n\t}\n\n\tieee80211_recalc_ps(local);\n\n\tif (cancel_scan)\n\t\twiphy_delayed_work_flush(local->hw.wiphy, &local->scan_work);\n\n\tif (local->open_count == 0) {\n\t\tieee80211_stop_device(local);\n\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tieee80211_configure_filter(local);\n\tieee80211_hw_config(local, hw_reconf_flags);\n\n\tif (local->monitors == local->open_count)\n\t\tieee80211_add_virtual_monitor(local);\n}\n\nstatic void ieee80211_stop_mbssid(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_sub_if_data *tx_sdata, *non_tx_sdata, *tmp_sdata;\n\tstruct ieee80211_vif *tx_vif = sdata->vif.mbssid_tx_vif;\n\n\tif (!tx_vif)\n\t\treturn;\n\n\ttx_sdata = vif_to_sdata(tx_vif);\n\tsdata->vif.mbssid_tx_vif = NULL;\n\n\tlist_for_each_entry_safe(non_tx_sdata, tmp_sdata,\n\t\t\t\t &tx_sdata->local->interfaces, list) {\n\t\tif (non_tx_sdata != sdata && non_tx_sdata != tx_sdata &&\n\t\t    non_tx_sdata->vif.mbssid_tx_vif == tx_vif &&\n\t\t    ieee80211_sdata_running(non_tx_sdata)) {\n\t\t\tnon_tx_sdata->vif.mbssid_tx_vif = NULL;\n\t\t\tdev_close(non_tx_sdata->wdev.netdev);\n\t\t}\n\t}\n\n\tif (sdata != tx_sdata && ieee80211_sdata_running(tx_sdata)) {\n\t\ttx_sdata->vif.mbssid_tx_vif = NULL;\n\t\tdev_close(tx_sdata->wdev.netdev);\n\t}\n}\n\nstatic int ieee80211_stop(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\t \n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct ieee80211_sub_if_data *vlan, *tmpsdata;\n\n\t\tlist_for_each_entry_safe(vlan, tmpsdata, &sdata->u.ap.vlans,\n\t\t\t\t\t u.vlan.list)\n\t\t\tdev_close(vlan->dev);\n\n\t\tieee80211_stop_mbssid(sdata);\n\t}\n\n\tcancel_work_sync(&sdata->activate_links_work);\n\n\twiphy_lock(sdata->local->hw.wiphy);\n\tieee80211_do_stop(sdata, true);\n\twiphy_unlock(sdata->local->hw.wiphy);\n\n\treturn 0;\n}\n\nstatic void ieee80211_set_multicast_list(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tint allmulti, sdata_allmulti;\n\n\tallmulti = !!(dev->flags & IFF_ALLMULTI);\n\tsdata_allmulti = !!(sdata->flags & IEEE80211_SDATA_ALLMULTI);\n\n\tif (allmulti != sdata_allmulti) {\n\t\tif (dev->flags & IFF_ALLMULTI)\n\t\t\tatomic_inc(&local->iff_allmultis);\n\t\telse\n\t\t\tatomic_dec(&local->iff_allmultis);\n\t\tsdata->flags ^= IEEE80211_SDATA_ALLMULTI;\n\t}\n\n\tspin_lock_bh(&local->filter_lock);\n\t__hw_addr_sync(&local->mc_list, &dev->mc, dev->addr_len);\n\tspin_unlock_bh(&local->filter_lock);\n\tieee80211_queue_work(&local->hw, &local->reconfig_filter);\n}\n\n \nstatic void ieee80211_teardown_sdata(struct ieee80211_sub_if_data *sdata)\n{\n\t \n\tieee80211_free_keys(sdata, false);\n\n\tieee80211_debugfs_remove_netdev(sdata);\n\n\tieee80211_destroy_frag_cache(&sdata->frags);\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tieee80211_mesh_teardown_sdata(sdata);\n\n\tieee80211_vif_clear_links(sdata);\n\tieee80211_link_stop(&sdata->deflink);\n}\n\nstatic void ieee80211_uninit(struct net_device *dev)\n{\n\tieee80211_teardown_sdata(IEEE80211_DEV_TO_SUB_IF(dev));\n}\n\nstatic void\nieee80211_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tdev_fetch_sw_netstats(stats, dev->tstats);\n}\n\nstatic int ieee80211_netdev_setup_tc(struct net_device *dev,\n\t\t\t\t     enum tc_setup_type type, void *type_data)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\n\treturn drv_net_setup_tc(local, sdata, dev, type, type_data);\n}\n\nstatic const struct net_device_ops ieee80211_dataif_ops = {\n\t.ndo_open\t\t= ieee80211_open,\n\t.ndo_stop\t\t= ieee80211_stop,\n\t.ndo_uninit\t\t= ieee80211_uninit,\n\t.ndo_start_xmit\t\t= ieee80211_subif_start_xmit,\n\t.ndo_set_rx_mode\t= ieee80211_set_multicast_list,\n\t.ndo_set_mac_address \t= ieee80211_change_mac,\n\t.ndo_get_stats64\t= ieee80211_get_stats64,\n\t.ndo_setup_tc\t\t= ieee80211_netdev_setup_tc,\n};\n\nstatic u16 ieee80211_monitor_select_queue(struct net_device *dev,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *sb_dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tint len_rthdr;\n\n\tif (local->hw.queues < IEEE80211_NUM_ACS)\n\t\treturn 0;\n\n\t \n\tmemset(info, 0, sizeof(*info));\n\n\tif (!ieee80211_parse_tx_radiotap(skb, dev))\n\t\treturn 0;  \n\n\tlen_rthdr = ieee80211_get_radiotap_len(skb->data);\n\thdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);\n\tif (skb->len < len_rthdr + 2 ||\n\t    skb->len < len_rthdr + ieee80211_hdrlen(hdr->frame_control))\n\t\treturn 0;  \n\n\treturn ieee80211_select_queue_80211(sdata, skb, hdr);\n}\n\nstatic const struct net_device_ops ieee80211_monitorif_ops = {\n\t.ndo_open\t\t= ieee80211_open,\n\t.ndo_stop\t\t= ieee80211_stop,\n\t.ndo_uninit\t\t= ieee80211_uninit,\n\t.ndo_start_xmit\t\t= ieee80211_monitor_start_xmit,\n\t.ndo_set_rx_mode\t= ieee80211_set_multicast_list,\n\t.ndo_set_mac_address \t= ieee80211_change_mac,\n\t.ndo_select_queue\t= ieee80211_monitor_select_queue,\n\t.ndo_get_stats64\t= ieee80211_get_stats64,\n};\n\nstatic int ieee80211_netdev_fill_forward_path(struct net_device_path_ctx *ctx,\n\t\t\t\t\t      struct net_device_path *path)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_local *local;\n\tstruct sta_info *sta;\n\tint ret = -ENOENT;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(ctx->dev);\n\tlocal = sdata->local;\n\n\tif (!local->ops->net_fill_forward_path)\n\t\treturn -EOPNOTSUPP;\n\n\trcu_read_lock();\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tsta = rcu_dereference(sdata->u.vlan.sta);\n\t\tif (sta)\n\t\t\tbreak;\n\t\tif (sdata->wdev.use_4addr)\n\t\t\tgoto out;\n\t\tif (is_multicast_ether_addr(ctx->daddr))\n\t\t\tgoto out;\n\t\tsta = sta_info_get_bss(sdata, ctx->daddr);\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tif (is_multicast_ether_addr(ctx->daddr))\n\t\t\tgoto out;\n\t\tsta = sta_info_get(sdata, ctx->daddr);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (sdata->wdev.wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS) {\n\t\t\tsta = sta_info_get(sdata, ctx->daddr);\n\t\t\tif (sta && test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\t\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH))\n\t\t\t\t\tgoto out;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tsta = sta_info_get(sdata, sdata->deflink.u.mgd.bssid);\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif (!sta)\n\t\tgoto out;\n\n\tret = drv_net_fill_forward_path(local, sdata, &sta->sta, ctx, path);\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic const struct net_device_ops ieee80211_dataif_8023_ops = {\n\t.ndo_open\t\t= ieee80211_open,\n\t.ndo_stop\t\t= ieee80211_stop,\n\t.ndo_uninit\t\t= ieee80211_uninit,\n\t.ndo_start_xmit\t\t= ieee80211_subif_start_xmit_8023,\n\t.ndo_set_rx_mode\t= ieee80211_set_multicast_list,\n\t.ndo_set_mac_address\t= ieee80211_change_mac,\n\t.ndo_get_stats64\t= ieee80211_get_stats64,\n\t.ndo_fill_forward_path\t= ieee80211_netdev_fill_forward_path,\n\t.ndo_setup_tc\t\t= ieee80211_netdev_setup_tc,\n};\n\nstatic bool ieee80211_iftype_supports_hdr_offload(enum nl80211_iftype iftype)\n{\n\tswitch (iftype) {\n\t \n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_STATION:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool ieee80211_set_sdata_offload_flags(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu32 flags;\n\n\tflags = sdata->vif.offload_flags;\n\n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_TX_ENCAP_OFFLOAD) &&\n\t    ieee80211_iftype_supports_hdr_offload(sdata->vif.type)) {\n\t\tflags |= IEEE80211_OFFLOAD_ENCAP_ENABLED;\n\n\t\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_TX_FRAG) &&\n\t\t    local->hw.wiphy->frag_threshold != (u32)-1)\n\t\t\tflags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;\n\n\t\tif (local->monitors)\n\t\t\tflags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;\n\t} else {\n\t\tflags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;\n\t}\n\n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_RX_DECAP_OFFLOAD) &&\n\t    ieee80211_iftype_supports_hdr_offload(sdata->vif.type)) {\n\t\tflags |= IEEE80211_OFFLOAD_DECAP_ENABLED;\n\n\t\tif (local->monitors &&\n\t\t    !ieee80211_hw_check(&local->hw, SUPPORTS_CONC_MON_RX_DECAP))\n\t\t\tflags &= ~IEEE80211_OFFLOAD_DECAP_ENABLED;\n\t} else {\n\t\tflags &= ~IEEE80211_OFFLOAD_DECAP_ENABLED;\n\t}\n\n\tif (sdata->vif.offload_flags == flags)\n\t\treturn false;\n\n\tsdata->vif.offload_flags = flags;\n\tieee80211_check_fast_rx_iface(sdata);\n\treturn true;\n}\n\nstatic void ieee80211_set_vif_encap_ops(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *bss = sdata;\n\tbool enabled;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (!sdata->bss)\n\t\t\treturn;\n\n\t\tbss = container_of(sdata->bss, struct ieee80211_sub_if_data, u.ap);\n\t}\n\n\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_TX_ENCAP_OFFLOAD) ||\n\t    !ieee80211_iftype_supports_hdr_offload(bss->vif.type))\n\t\treturn;\n\n\tenabled = bss->vif.offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED;\n\tif (sdata->wdev.use_4addr &&\n\t    !(bss->vif.offload_flags & IEEE80211_OFFLOAD_ENCAP_4ADDR))\n\t\tenabled = false;\n\n\tsdata->dev->netdev_ops = enabled ? &ieee80211_dataif_8023_ops :\n\t\t\t\t\t   &ieee80211_dataif_ops;\n}\n\nstatic void ieee80211_recalc_sdata_offload(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *vsdata;\n\n\tif (ieee80211_set_sdata_offload_flags(sdata)) {\n\t\tdrv_update_vif_offload(local, sdata);\n\t\tieee80211_set_vif_encap_ops(sdata);\n\t}\n\n\tlist_for_each_entry(vsdata, &local->interfaces, list) {\n\t\tif (vsdata->vif.type != NL80211_IFTYPE_AP_VLAN ||\n\t\t    vsdata->bss != &sdata->u.ap)\n\t\t\tcontinue;\n\n\t\tieee80211_set_vif_encap_ops(vsdata);\n\t}\n}\n\nvoid ieee80211_recalc_offload(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_TX_ENCAP_OFFLOAD))\n\t\treturn;\n\n\tmutex_lock(&local->iflist_mtx);\n\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tieee80211_recalc_sdata_offload(sdata);\n\t}\n\n\tmutex_unlock(&local->iflist_mtx);\n}\n\nvoid ieee80211_adjust_monitor_flags(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    const int offset)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu32 flags = sdata->u.mntr.flags;\n\n#define ADJUST(_f, _s)\tdo {\t\t\t\t\t\\\n\tif (flags & MONITOR_FLAG_##_f)\t\t\t\t\\\n\t\tlocal->fif_##_s += offset;\t\t\t\\\n\t} while (0)\n\n\tADJUST(FCSFAIL, fcsfail);\n\tADJUST(PLCPFAIL, plcpfail);\n\tADJUST(CONTROL, control);\n\tADJUST(CONTROL, pspoll);\n\tADJUST(OTHER_BSS, other_bss);\n\n#undef ADJUST\n}\n\nstatic void ieee80211_set_default_queues(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint i;\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tif (ieee80211_hw_check(&local->hw, QUEUE_CONTROL))\n\t\t\tsdata->vif.hw_queue[i] = IEEE80211_INVAL_HW_QUEUE;\n\t\telse if (local->hw.queues >= IEEE80211_NUM_ACS)\n\t\t\tsdata->vif.hw_queue[i] = i;\n\t\telse\n\t\t\tsdata->vif.hw_queue[i] = 0;\n\t}\n\tsdata->vif.cab_queue = IEEE80211_INVAL_HW_QUEUE;\n}\n\nstatic void ieee80211_sdata_init(struct ieee80211_local *local,\n\t\t\t\t struct ieee80211_sub_if_data *sdata)\n{\n\tsdata->local = local;\n\n\t \n\tieee80211_link_init(sdata, -1, &sdata->deflink, &sdata->vif.bss_conf);\n}\n\nint ieee80211_add_virtual_monitor(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tint ret;\n\n\tif (!ieee80211_hw_check(&local->hw, WANT_MONITOR_VIF))\n\t\treturn 0;\n\n\tASSERT_RTNL();\n\tlockdep_assert_wiphy(local->hw.wiphy);\n\n\tif (local->monitor_sdata)\n\t\treturn 0;\n\n\tsdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size, GFP_KERNEL);\n\tif (!sdata)\n\t\treturn -ENOMEM;\n\n\t \n\tsdata->vif.type = NL80211_IFTYPE_MONITOR;\n\tsnprintf(sdata->name, IFNAMSIZ, \"%s-monitor\",\n\t\t wiphy_name(local->hw.wiphy));\n\tsdata->wdev.iftype = NL80211_IFTYPE_MONITOR;\n\tmutex_init(&sdata->wdev.mtx);\n\n\tieee80211_sdata_init(local, sdata);\n\n\tieee80211_set_default_queues(sdata);\n\n\tret = drv_add_interface(local, sdata);\n\tif (WARN_ON(ret)) {\n\t\t \n\t\tkfree(sdata);\n\t\treturn ret;\n\t}\n\n\tset_bit(SDATA_STATE_RUNNING, &sdata->state);\n\n\tret = ieee80211_check_queues(sdata, NL80211_IFTYPE_MONITOR);\n\tif (ret) {\n\t\tkfree(sdata);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&local->iflist_mtx);\n\trcu_assign_pointer(local->monitor_sdata, sdata);\n\tmutex_unlock(&local->iflist_mtx);\n\n\tsdata_lock(sdata);\n\tmutex_lock(&local->mtx);\n\tret = ieee80211_link_use_channel(&sdata->deflink, &local->monitor_chandef,\n\t\t\t\t\t IEEE80211_CHANCTX_EXCLUSIVE);\n\tmutex_unlock(&local->mtx);\n\tsdata_unlock(sdata);\n\tif (ret) {\n\t\tmutex_lock(&local->iflist_mtx);\n\t\tRCU_INIT_POINTER(local->monitor_sdata, NULL);\n\t\tmutex_unlock(&local->iflist_mtx);\n\t\tsynchronize_net();\n\t\tdrv_remove_interface(local, sdata);\n\t\tmutex_destroy(&sdata->wdev.mtx);\n\t\tkfree(sdata);\n\t\treturn ret;\n\t}\n\n\tskb_queue_head_init(&sdata->skb_queue);\n\tskb_queue_head_init(&sdata->status_queue);\n\twiphy_work_init(&sdata->work, ieee80211_iface_work);\n\n\treturn 0;\n}\n\nvoid ieee80211_del_virtual_monitor(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tif (!ieee80211_hw_check(&local->hw, WANT_MONITOR_VIF))\n\t\treturn;\n\n\tASSERT_RTNL();\n\tlockdep_assert_wiphy(local->hw.wiphy);\n\n\tmutex_lock(&local->iflist_mtx);\n\n\tsdata = rcu_dereference_protected(local->monitor_sdata,\n\t\t\t\t\t  lockdep_is_held(&local->iflist_mtx));\n\tif (!sdata) {\n\t\tmutex_unlock(&local->iflist_mtx);\n\t\treturn;\n\t}\n\n\tRCU_INIT_POINTER(local->monitor_sdata, NULL);\n\tmutex_unlock(&local->iflist_mtx);\n\n\tsynchronize_net();\n\n\tsdata_lock(sdata);\n\tmutex_lock(&local->mtx);\n\tieee80211_link_release_channel(&sdata->deflink);\n\tmutex_unlock(&local->mtx);\n\tsdata_unlock(sdata);\n\n\tdrv_remove_interface(local, sdata);\n\n\tmutex_destroy(&sdata->wdev.mtx);\n\tkfree(sdata);\n}\n\n \nint ieee80211_do_open(struct wireless_dev *wdev, bool coming_up)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tstruct net_device *dev = wdev->netdev;\n\tstruct ieee80211_local *local = sdata->local;\n\tu64 changed = 0;\n\tint res;\n\tu32 hw_reconf_flags = 0;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN: {\n\t\tstruct ieee80211_sub_if_data *master;\n\n\t\tif (!sdata->bss)\n\t\t\treturn -ENOLINK;\n\n\t\tmutex_lock(&local->mtx);\n\t\tlist_add(&sdata->u.vlan.list, &sdata->bss->vlans);\n\t\tmutex_unlock(&local->mtx);\n\n\t\tmaster = container_of(sdata->bss,\n\t\t\t\t      struct ieee80211_sub_if_data, u.ap);\n\t\tsdata->control_port_protocol =\n\t\t\tmaster->control_port_protocol;\n\t\tsdata->control_port_no_encrypt =\n\t\t\tmaster->control_port_no_encrypt;\n\t\tsdata->control_port_over_nl80211 =\n\t\t\tmaster->control_port_over_nl80211;\n\t\tsdata->control_port_no_preauth =\n\t\t\tmaster->control_port_no_preauth;\n\t\tsdata->vif.cab_queue = master->vif.cab_queue;\n\t\tmemcpy(sdata->vif.hw_queue, master->vif.hw_queue,\n\t\t       sizeof(sdata->vif.hw_queue));\n\t\tsdata->vif.bss_conf.chandef = master->vif.bss_conf.chandef;\n\n\t\tmutex_lock(&local->key_mtx);\n\t\tsdata->crypto_tx_tailroom_needed_cnt +=\n\t\t\tmaster->crypto_tx_tailroom_needed_cnt;\n\t\tmutex_unlock(&local->key_mtx);\n\n\t\tbreak;\n\t\t}\n\tcase NL80211_IFTYPE_AP:\n\t\tsdata->bss = &sdata->u.ap;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_NAN:\n\t\t \n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NUM_NL80211_IFTYPES:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_WDS:\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif (local->open_count == 0) {\n\t\t \n\t\tlocal->reconfig_failure = false;\n\n\t\tres = drv_start(local);\n\t\tif (res)\n\t\t\tgoto err_del_bss;\n\t\t \n\t\thw_reconf_flags = ~0;\n\t\tieee80211_led_radio(local, true);\n\t\tieee80211_mod_tpt_led_trig(local,\n\t\t\t\t\t   IEEE80211_TPT_LEDTRIG_FL_RADIO, 0);\n\t}\n\n\t \n\tif (dev && is_zero_ether_addr(dev->dev_addr)) {\n\t\teth_hw_addr_set(dev, local->hw.wiphy->perm_addr);\n\t\tmemcpy(dev->perm_addr, dev->dev_addr, ETH_ALEN);\n\n\t\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\t\tres = -EADDRNOTAVAIL;\n\t\t\tgoto err_stop;\n\t\t}\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t \n\t\tif (sdata->bss->active) {\n\t\t\tieee80211_link_vlan_copy_chanctx(&sdata->deflink);\n\t\t\tnetif_carrier_on(dev);\n\t\t\tieee80211_set_vif_encap_ops(sdata);\n\t\t} else {\n\t\t\tnetif_carrier_off(dev);\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES) {\n\t\t\tlocal->cooked_mntrs++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) {\n\t\t\tres = drv_add_interface(local, sdata);\n\t\t\tif (res)\n\t\t\t\tgoto err_stop;\n\t\t} else if (local->monitors == 0 && local->open_count == 0) {\n\t\t\tres = ieee80211_add_virtual_monitor(local);\n\t\t\tif (res)\n\t\t\t\tgoto err_stop;\n\t\t}\n\n\t\t \n\t\tlocal->monitors++;\n\t\tif (local->monitors == 1) {\n\t\t\tlocal->hw.conf.flags |= IEEE80211_CONF_MONITOR;\n\t\t\thw_reconf_flags |= IEEE80211_CONF_CHANGE_MONITOR;\n\t\t}\n\n\t\tieee80211_adjust_monitor_flags(sdata, 1);\n\t\tieee80211_configure_filter(local);\n\t\tieee80211_recalc_offload(local);\n\t\tmutex_lock(&local->mtx);\n\t\tieee80211_recalc_idle(local);\n\t\tmutex_unlock(&local->mtx);\n\n\t\tnetif_carrier_on(dev);\n\t\tbreak;\n\tdefault:\n\t\tif (coming_up) {\n\t\t\tieee80211_del_virtual_monitor(local);\n\t\t\tieee80211_set_sdata_offload_flags(sdata);\n\n\t\t\tres = drv_add_interface(local, sdata);\n\t\t\tif (res)\n\t\t\t\tgoto err_stop;\n\n\t\t\tieee80211_set_vif_encap_ops(sdata);\n\t\t\tres = ieee80211_check_queues(sdata,\n\t\t\t\tieee80211_vif_type_p2p(&sdata->vif));\n\t\t\tif (res)\n\t\t\t\tgoto err_del_interface;\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\t\tlocal->fif_pspoll++;\n\t\t\tlocal->fif_probe_req++;\n\n\t\t\tieee80211_configure_filter(local);\n\t\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\t\tlocal->fif_probe_req++;\n\t\t}\n\n\t\tif (sdata->vif.probe_req_reg)\n\t\t\tdrv_config_iface_filter(local, sdata,\n\t\t\t\t\t\tFIF_PROBE_REQ,\n\t\t\t\t\t\tFIF_PROBE_REQ);\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_NAN)\n\t\t\tchanged |= ieee80211_reset_erp_info(sdata);\n\t\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t\t  changed);\n\n\t\tswitch (sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tcase NL80211_IFTYPE_OCB:\n\t\t\tnetif_carrier_off(dev);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tcase NL80211_IFTYPE_NAN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t \n\t\tieee80211_set_wmm_default(&sdata->deflink, true,\n\t\t\tsdata->vif.type != NL80211_IFTYPE_STATION);\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\trcu_assign_pointer(local->p2p_sdata, sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES)\n\t\t\tbreak;\n\t\tlist_add_tail_rcu(&sdata->u.mntr.list, &local->mon_list);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (sdata->flags & IEEE80211_SDATA_ALLMULTI)\n\t\tatomic_inc(&local->iff_allmultis);\n\n\tif (coming_up)\n\t\tlocal->open_count++;\n\n\tif (hw_reconf_flags)\n\t\tieee80211_hw_config(local, hw_reconf_flags);\n\n\tieee80211_recalc_ps(local);\n\n\tset_bit(SDATA_STATE_RUNNING, &sdata->state);\n\n\treturn 0;\n err_del_interface:\n\tdrv_remove_interface(local, sdata);\n err_stop:\n\tif (!local->open_count)\n\t\tdrv_stop(local);\n err_del_bss:\n\tsdata->bss = NULL;\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tmutex_lock(&local->mtx);\n\t\tlist_del(&sdata->u.vlan.list);\n\t\tmutex_unlock(&local->mtx);\n\t}\n\t \n\tclear_bit(SDATA_STATE_RUNNING, &sdata->state);\n\treturn res;\n}\n\nstatic void ieee80211_if_free(struct net_device *dev)\n{\n\tfree_percpu(dev->tstats);\n}\n\nstatic void ieee80211_if_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\tdev->netdev_ops = &ieee80211_dataif_ops;\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = ieee80211_if_free;\n}\n\nstatic void ieee80211_iface_process_skb(struct ieee80211_local *local,\n\t\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\n\tif (ieee80211_is_action(mgmt->frame_control) &&\n\t    mgmt->u.action.category == WLAN_CATEGORY_BACK) {\n\t\tstruct sta_info *sta;\n\t\tint len = skb->len;\n\n\t\tmutex_lock(&local->sta_mtx);\n\t\tsta = sta_info_get_bss(sdata, mgmt->sa);\n\t\tif (sta) {\n\t\t\tswitch (mgmt->u.action.u.addba_req.action_code) {\n\t\t\tcase WLAN_ACTION_ADDBA_REQ:\n\t\t\t\tieee80211_process_addba_request(local, sta,\n\t\t\t\t\t\t\t\tmgmt, len);\n\t\t\t\tbreak;\n\t\t\tcase WLAN_ACTION_ADDBA_RESP:\n\t\t\t\tieee80211_process_addba_resp(local, sta,\n\t\t\t\t\t\t\t     mgmt, len);\n\t\t\t\tbreak;\n\t\t\tcase WLAN_ACTION_DELBA:\n\t\t\t\tieee80211_process_delba(sdata, sta,\n\t\t\t\t\t\t\tmgmt, len);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&local->sta_mtx);\n\t} else if (ieee80211_is_action(mgmt->frame_control) &&\n\t\t   mgmt->u.action.category == WLAN_CATEGORY_VHT) {\n\t\tswitch (mgmt->u.action.u.vht_group_notif.action_code) {\n\t\tcase WLAN_VHT_ACTION_OPMODE_NOTIF: {\n\t\t\tstruct ieee80211_rx_status *status;\n\t\t\tenum nl80211_band band;\n\t\t\tstruct sta_info *sta;\n\t\t\tu8 opmode;\n\n\t\t\tstatus = IEEE80211_SKB_RXCB(skb);\n\t\t\tband = status->band;\n\t\t\topmode = mgmt->u.action.u.vht_opmode_notif.operating_mode;\n\n\t\t\tmutex_lock(&local->sta_mtx);\n\t\t\tsta = sta_info_get_bss(sdata, mgmt->sa);\n\n\t\t\tif (sta)\n\t\t\t\tieee80211_vht_handle_opmode(sdata,\n\t\t\t\t\t\t\t    &sta->deflink,\n\t\t\t\t\t\t\t    opmode, band);\n\n\t\t\tmutex_unlock(&local->sta_mtx);\n\t\t\tbreak;\n\t\t}\n\t\tcase WLAN_VHT_ACTION_GROUPID_MGMT:\n\t\t\tieee80211_process_mu_groups(sdata, &sdata->deflink,\n\t\t\t\t\t\t    mgmt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t} else if (ieee80211_is_action(mgmt->frame_control) &&\n\t\t   mgmt->u.action.category == WLAN_CATEGORY_S1G) {\n\t\tswitch (mgmt->u.action.u.s1g.action_code) {\n\t\tcase WLAN_S1G_TWT_TEARDOWN:\n\t\tcase WLAN_S1G_TWT_SETUP:\n\t\t\tieee80211_s1g_rx_twt_action(sdata, skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (ieee80211_is_ext(mgmt->frame_control)) {\n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\t\tieee80211_sta_rx_queued_ext(sdata, skb);\n\t\telse\n\t\t\tWARN_ON(1);\n\t} else if (ieee80211_is_data_qos(mgmt->frame_control)) {\n\t\tstruct ieee80211_hdr *hdr = (void *)mgmt;\n\t\tstruct sta_info *sta;\n\n\t\t \n\t\tWARN_ON(hdr->frame_control &\n\t\t\t\tcpu_to_le16(IEEE80211_STYPE_NULLFUNC));\n\t\tWARN_ON(!(hdr->seq_ctrl &\n\t\t\t\tcpu_to_le16(IEEE80211_SCTL_FRAG)));\n\t\t \n\t\tmutex_lock(&local->sta_mtx);\n\t\tsta = sta_info_get_bss(sdata, mgmt->sa);\n\t\tif (sta) {\n\t\t\tu16 tid = ieee80211_get_tid(hdr);\n\n\t\t\t__ieee80211_stop_rx_ba_session(\n\t\t\t\tsta, tid, WLAN_BACK_RECIPIENT,\n\t\t\t\tWLAN_REASON_QSTA_REQUIRE_SETUP,\n\t\t\t\ttrue);\n\t\t}\n\t\tmutex_unlock(&local->sta_mtx);\n\t} else switch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tieee80211_sta_rx_queued_mgmt(sdata, skb);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tieee80211_ibss_rx_queued_mgmt(sdata, skb);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tbreak;\n\t\tieee80211_mesh_rx_queued_mgmt(sdata, skb);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"frame for unexpected interface type\");\n\t\tbreak;\n\t}\n}\n\nstatic void ieee80211_iface_process_status(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\n\tif (ieee80211_is_action(mgmt->frame_control) &&\n\t    mgmt->u.action.category == WLAN_CATEGORY_S1G) {\n\t\tswitch (mgmt->u.action.u.s1g.action_code) {\n\t\tcase WLAN_S1G_TWT_TEARDOWN:\n\t\tcase WLAN_S1G_TWT_SETUP:\n\t\t\tieee80211_s1g_status_twt_action(sdata, skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ieee80211_iface_work(struct wiphy *wiphy, struct wiphy_work *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data, work);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn;\n\n\tif (test_bit(SCAN_SW_SCANNING, &local->scanning))\n\t\treturn;\n\n\tif (!ieee80211_can_run_worker(local))\n\t\treturn;\n\n\t \n\twhile ((skb = skb_dequeue(&sdata->skb_queue))) {\n\t\tkcov_remote_start_common(skb_get_kcov_handle(skb));\n\n\t\tif (skb->protocol == cpu_to_be16(ETH_P_TDLS))\n\t\t\tieee80211_process_tdls_channel_switch(sdata, skb);\n\t\telse\n\t\t\tieee80211_iface_process_skb(local, sdata, skb);\n\n\t\tkfree_skb(skb);\n\t\tkcov_remote_stop();\n\t}\n\n\t \n\twhile ((skb = skb_dequeue(&sdata->status_queue))) {\n\t\tkcov_remote_start_common(skb_get_kcov_handle(skb));\n\n\t\tieee80211_iface_process_status(sdata, skb);\n\t\tkfree_skb(skb);\n\n\t\tkcov_remote_stop();\n\t}\n\n\t \n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tieee80211_sta_work(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tieee80211_ibss_work(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tbreak;\n\t\tieee80211_mesh_work(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_OCB:\n\t\tieee80211_ocb_work(sdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ieee80211_recalc_smps_work(struct work_struct *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data, recalc_smps);\n\n\tieee80211_recalc_smps(sdata, &sdata->deflink);\n}\n\nstatic void ieee80211_activate_links_work(struct work_struct *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data,\n\t\t\t     activate_links_work);\n\n\tieee80211_set_active_links(&sdata->vif, sdata->desired_active_links);\n}\n\n \nstatic void ieee80211_setup_sdata(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  enum nl80211_iftype type)\n{\n\tstatic const u8 bssid_wildcard[ETH_ALEN] = {0xff, 0xff, 0xff,\n\t\t\t\t\t\t    0xff, 0xff, 0xff};\n\n\t \n\tmemset(&sdata->u, 0, sizeof(sdata->u));\n\tmemset(&sdata->deflink.u, 0, sizeof(sdata->deflink.u));\n\n\t \n\tsdata->vif.type = type;\n\tsdata->vif.p2p = false;\n\tsdata->wdev.iftype = type;\n\n\tsdata->control_port_protocol = cpu_to_be16(ETH_P_PAE);\n\tsdata->control_port_no_encrypt = false;\n\tsdata->control_port_over_nl80211 = false;\n\tsdata->control_port_no_preauth = false;\n\tsdata->vif.cfg.idle = true;\n\tsdata->vif.bss_conf.txpower = INT_MIN;  \n\n\tsdata->noack_map = 0;\n\n\t \n\tif (sdata->dev) {\n\t\tsdata->dev->netdev_ops = &ieee80211_dataif_ops;\n\t\tsdata->dev->type = ARPHRD_ETHER;\n\t}\n\n\tskb_queue_head_init(&sdata->skb_queue);\n\tskb_queue_head_init(&sdata->status_queue);\n\twiphy_work_init(&sdata->work, ieee80211_iface_work);\n\tINIT_WORK(&sdata->recalc_smps, ieee80211_recalc_smps_work);\n\tINIT_WORK(&sdata->activate_links_work, ieee80211_activate_links_work);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\ttype = NL80211_IFTYPE_AP;\n\t\tsdata->vif.type = type;\n\t\tsdata->vif.p2p = true;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\tskb_queue_head_init(&sdata->u.ap.ps.bc_buf);\n\t\tINIT_LIST_HEAD(&sdata->u.ap.vlans);\n\t\tsdata->vif.bss_conf.bssid = sdata->vif.addr;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\ttype = NL80211_IFTYPE_STATION;\n\t\tsdata->vif.type = type;\n\t\tsdata->vif.p2p = true;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_STATION:\n\t\tsdata->vif.bss_conf.bssid = sdata->deflink.u.mgd.bssid;\n\t\tieee80211_sta_setup_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_OCB:\n\t\tsdata->vif.bss_conf.bssid = bssid_wildcard;\n\t\tieee80211_ocb_setup_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tsdata->vif.bss_conf.bssid = sdata->u.ibss.bssid;\n\t\tieee80211_ibss_setup_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tieee80211_mesh_init_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tsdata->dev->type = ARPHRD_IEEE80211_RADIOTAP;\n\t\tsdata->dev->netdev_ops = &ieee80211_monitorif_ops;\n\t\tsdata->u.mntr.flags = MONITOR_FLAG_CONTROL |\n\t\t\t\t      MONITOR_FLAG_OTHER_BSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\t\tidr_init(&sdata->u.nan.function_inst_ids);\n\t\tspin_lock_init(&sdata->u.nan.func_lock);\n\t\tsdata->vif.bss_conf.bssid = sdata->vif.addr;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tsdata->vif.bss_conf.bssid = sdata->vif.addr;\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NUM_NL80211_IFTYPES:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\t \n\tieee80211_link_setup(&sdata->deflink);\n\n\tieee80211_debugfs_add_netdev(sdata);\n}\n\nstatic int ieee80211_runtime_change_iftype(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   enum nl80211_iftype type)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret, err;\n\tenum nl80211_iftype internal_type = type;\n\tbool p2p = false;\n\n\tASSERT_RTNL();\n\n\tif (!local->ops->change_interface)\n\t\treturn -EBUSY;\n\n\t \n\tif (ieee80211_vif_is_mld(&sdata->vif))\n\t\treturn -EBUSY;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tif (!list_empty(&sdata->u.ap.vlans))\n\t\t\treturn -EBUSY;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_OCB:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_OCB:\n\t\t \n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tp2p = true;\n\t\tinternal_type = NL80211_IFTYPE_STATION;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tp2p = true;\n\t\tinternal_type = NL80211_IFTYPE_AP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\n\tret = ieee80211_check_concurrent_iface(sdata, internal_type);\n\tif (ret)\n\t\treturn ret;\n\n\tieee80211_stop_vif_queues(local, sdata,\n\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_IFTYPE_CHANGE);\n\t \n\tieee80211_do_stop(sdata, false);\n\n\tieee80211_teardown_sdata(sdata);\n\n\tieee80211_set_sdata_offload_flags(sdata);\n\tret = drv_change_interface(local, sdata, internal_type, p2p);\n\tif (ret)\n\t\ttype = ieee80211_vif_type_p2p(&sdata->vif);\n\n\t \n\tieee80211_check_queues(sdata, type);\n\n\tieee80211_setup_sdata(sdata, type);\n\tieee80211_set_vif_encap_ops(sdata);\n\n\terr = ieee80211_do_open(&sdata->wdev, false);\n\tWARN(err, \"type change: do_open returned %d\", err);\n\n\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_IFTYPE_CHANGE);\n\treturn ret;\n}\n\nint ieee80211_if_change_type(struct ieee80211_sub_if_data *sdata,\n\t\t\t     enum nl80211_iftype type)\n{\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tif (type == ieee80211_vif_type_p2p(&sdata->vif))\n\t\treturn 0;\n\n\tif (ieee80211_sdata_running(sdata)) {\n\t\tret = ieee80211_runtime_change_iftype(sdata, type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tieee80211_teardown_sdata(sdata);\n\t\tieee80211_setup_sdata(sdata, type);\n\t}\n\n\t \n\tif (type == NL80211_IFTYPE_STATION)\n\t\tsdata->u.mgd.use_4addr = false;\n\n\treturn 0;\n}\n\nstatic void ieee80211_assign_perm_addr(struct ieee80211_local *local,\n\t\t\t\t       u8 *perm_addr, enum nl80211_iftype type)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tu64 mask, start, addr, val, inc;\n\tu8 *m;\n\tu8 tmp_addr[ETH_ALEN];\n\tint i;\n\n\t \n\tmemcpy(perm_addr, local->hw.wiphy->perm_addr, ETH_ALEN);\n\n\tif (is_zero_ether_addr(local->hw.wiphy->addr_mask) &&\n\t    local->hw.wiphy->n_addresses <= 1)\n\t\treturn;\n\n\tmutex_lock(&local->iflist_mtx);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\t \n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t \n\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(perm_addr, sdata->vif.addr, ETH_ALEN);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (ieee80211_hw_check(&local->hw, P2P_DEV_ADDR_FOR_INTF)) {\n\t\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\t\tif (sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\t\t\tcontinue;\n\t\t\t\tmemcpy(perm_addr, sdata->vif.addr, ETH_ALEN);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tfor (i = 0; i < local->hw.wiphy->n_addresses; i++) {\n\t\t\tbool used = false;\n\n\t\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\t\tif (ether_addr_equal(local->hw.wiphy->addresses[i].addr,\n\t\t\t\t\t\t     sdata->vif.addr)) {\n\t\t\t\t\tused = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!used) {\n\t\t\t\tmemcpy(perm_addr,\n\t\t\t\t       local->hw.wiphy->addresses[i].addr,\n\t\t\t\t       ETH_ALEN);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (is_zero_ether_addr(local->hw.wiphy->addr_mask))\n\t\t\tbreak;\n\n\t\tm = local->hw.wiphy->addr_mask;\n\t\tmask =\t((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\t\tif (__ffs64(mask) + hweight64(mask) != fls64(mask)) {\n\t\t\t \n\t\t\tpr_info(\"not contiguous\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tm = local->hw.wiphy->perm_addr;\n\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR)\n\t\t\t\tcontinue;\n\t\t\tm = sdata->vif.addr;\n\t\t\tbreak;\n\t\t}\n\t\tstart = ((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\t\tinc = 1ULL<<__ffs64(mask);\n\t\tval = (start & mask);\n\t\taddr = (start & ~mask) | (val & mask);\n\t\tdo {\n\t\t\tbool used = false;\n\n\t\t\ttmp_addr[5] = addr >> 0*8;\n\t\t\ttmp_addr[4] = addr >> 1*8;\n\t\t\ttmp_addr[3] = addr >> 2*8;\n\t\t\ttmp_addr[2] = addr >> 3*8;\n\t\t\ttmp_addr[1] = addr >> 4*8;\n\t\t\ttmp_addr[0] = addr >> 5*8;\n\n\t\t\tval += inc;\n\n\t\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\t\tif (ether_addr_equal(tmp_addr, sdata->vif.addr)) {\n\t\t\t\t\tused = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!used) {\n\t\t\t\tmemcpy(perm_addr, tmp_addr, ETH_ALEN);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taddr = (start & ~mask) | (val & mask);\n\t\t} while (addr != start);\n\n\t\tbreak;\n\t}\n\n out_unlock:\n\tmutex_unlock(&local->iflist_mtx);\n}\n\nint ieee80211_if_add(struct ieee80211_local *local, const char *name,\n\t\t     unsigned char name_assign_type,\n\t\t     struct wireless_dev **new_wdev, enum nl80211_iftype type,\n\t\t     struct vif_params *params)\n{\n\tstruct net_device *ndev = NULL;\n\tstruct ieee80211_sub_if_data *sdata = NULL;\n\tstruct txq_info *txqi;\n\tint ret, i;\n\n\tASSERT_RTNL();\n\n\tif (type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN) {\n\t\tstruct wireless_dev *wdev;\n\n\t\tsdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sdata)\n\t\t\treturn -ENOMEM;\n\t\twdev = &sdata->wdev;\n\n\t\tsdata->dev = NULL;\n\t\tstrscpy(sdata->name, name, IFNAMSIZ);\n\t\tieee80211_assign_perm_addr(local, wdev->address, type);\n\t\tmemcpy(sdata->vif.addr, wdev->address, ETH_ALEN);\n\t\tether_addr_copy(sdata->vif.bss_conf.addr, sdata->vif.addr);\n\t} else {\n\t\tint size = ALIGN(sizeof(*sdata) + local->hw.vif_data_size,\n\t\t\t\t sizeof(void *));\n\t\tint txq_size = 0;\n\n\t\tif (type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    (type != NL80211_IFTYPE_MONITOR ||\n\t\t     (params->flags & MONITOR_FLAG_ACTIVE)))\n\t\t\ttxq_size += sizeof(struct txq_info) +\n\t\t\t\t    local->hw.txq_data_size;\n\n\t\tndev = alloc_netdev_mqs(size + txq_size,\n\t\t\t\t\tname, name_assign_type,\n\t\t\t\t\tieee80211_if_setup, 1, 1);\n\t\tif (!ndev)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_net_set(ndev, wiphy_net(local->hw.wiphy));\n\n\t\tndev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\t\tif (!ndev->tstats) {\n\t\t\tfree_netdev(ndev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tndev->needed_headroom = local->tx_headroom +\n\t\t\t\t\t4*6  \n\t\t\t\t\t+ 2 + 2 + 2 + 2  \n\t\t\t\t\t+ 6  \n\t\t\t\t\t+ 8  \n\t\t\t\t\t- ETH_HLEN  \n\t\t\t\t\t+ IEEE80211_ENCRYPT_HEADROOM;\n\t\tndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;\n\n\t\tret = dev_alloc_name(ndev, ndev->name);\n\t\tif (ret < 0) {\n\t\t\tieee80211_if_free(ndev);\n\t\t\tfree_netdev(ndev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tieee80211_assign_perm_addr(local, ndev->perm_addr, type);\n\t\tif (is_valid_ether_addr(params->macaddr))\n\t\t\teth_hw_addr_set(ndev, params->macaddr);\n\t\telse\n\t\t\teth_hw_addr_set(ndev, ndev->perm_addr);\n\t\tSET_NETDEV_DEV(ndev, wiphy_dev(local->hw.wiphy));\n\n\t\t \n\t\tsdata = netdev_priv(ndev);\n\t\tndev->ieee80211_ptr = &sdata->wdev;\n\t\tmemcpy(sdata->vif.addr, ndev->dev_addr, ETH_ALEN);\n\t\tether_addr_copy(sdata->vif.bss_conf.addr, sdata->vif.addr);\n\t\tmemcpy(sdata->name, ndev->name, IFNAMSIZ);\n\n\t\tif (txq_size) {\n\t\t\ttxqi = netdev_priv(ndev) + size;\n\t\t\tieee80211_txq_init(sdata, NULL, txqi, 0);\n\t\t}\n\n\t\tsdata->dev = ndev;\n\t}\n\n\t \n\tsdata->wdev.wiphy = local->hw.wiphy;\n\n\tieee80211_sdata_init(local, sdata);\n\n\tieee80211_init_frag_cache(&sdata->frags);\n\n\tINIT_LIST_HEAD(&sdata->key_list);\n\n\tINIT_DELAYED_WORK(&sdata->dec_tailroom_needed_wk,\n\t\t\t  ieee80211_delayed_tailroom_dec);\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tsband = local->hw.wiphy->bands[i];\n\t\tsdata->rc_rateidx_mask[i] =\n\t\t\tsband ? (1 << sband->n_bitrates) - 1 : 0;\n\t\tif (sband) {\n\t\t\t__le16 cap;\n\t\t\tu16 *vht_rate_mask;\n\n\t\t\tmemcpy(sdata->rc_rateidx_mcs_mask[i],\n\t\t\t       sband->ht_cap.mcs.rx_mask,\n\t\t\t       sizeof(sdata->rc_rateidx_mcs_mask[i]));\n\n\t\t\tcap = sband->vht_cap.vht_mcs.rx_mcs_map;\n\t\t\tvht_rate_mask = sdata->rc_rateidx_vht_mcs_mask[i];\n\t\t\tieee80211_get_vht_mask_from_cap(cap, vht_rate_mask);\n\t\t} else {\n\t\t\tmemset(sdata->rc_rateidx_mcs_mask[i], 0,\n\t\t\t       sizeof(sdata->rc_rateidx_mcs_mask[i]));\n\t\t\tmemset(sdata->rc_rateidx_vht_mcs_mask[i], 0,\n\t\t\t       sizeof(sdata->rc_rateidx_vht_mcs_mask[i]));\n\t\t}\n\t}\n\n\tieee80211_set_default_queues(sdata);\n\n\tsdata->deflink.ap_power_level = IEEE80211_UNSET_POWER_LEVEL;\n\tsdata->deflink.user_power_level = local->user_power_level;\n\n\t \n\tieee80211_setup_sdata(sdata, type);\n\n\tif (ndev) {\n\t\tndev->ieee80211_ptr->use_4addr = params->use_4addr;\n\t\tif (type == NL80211_IFTYPE_STATION)\n\t\t\tsdata->u.mgd.use_4addr = params->use_4addr;\n\n\t\tndev->features |= local->hw.netdev_features;\n\t\tndev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\t\tndev->hw_features |= ndev->features &\n\t\t\t\t\tMAC80211_SUPPORTED_FEATURES_TX;\n\t\tsdata->vif.netdev_features = local->hw.netdev_features;\n\n\t\tnetdev_set_default_ethtool_ops(ndev, &ieee80211_ethtool_ops);\n\n\t\t \n\t\tndev->min_mtu = 256;\n\t\tif (type == NL80211_IFTYPE_MONITOR)\n\t\t\tndev->max_mtu = 0;\n\t\telse\n\t\t\tndev->max_mtu = local->hw.max_mtu;\n\n\t\tret = cfg80211_register_netdevice(ndev);\n\t\tif (ret) {\n\t\t\tfree_netdev(ndev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_add_tail_rcu(&sdata->list, &local->interfaces);\n\tmutex_unlock(&local->iflist_mtx);\n\n\tif (new_wdev)\n\t\t*new_wdev = &sdata->wdev;\n\n\treturn 0;\n}\n\nvoid ieee80211_if_remove(struct ieee80211_sub_if_data *sdata)\n{\n\tASSERT_RTNL();\n\n\tmutex_lock(&sdata->local->iflist_mtx);\n\tlist_del_rcu(&sdata->list);\n\tmutex_unlock(&sdata->local->iflist_mtx);\n\n\tif (sdata->vif.txq)\n\t\tieee80211_txq_purge(sdata->local, to_txq_info(sdata->vif.txq));\n\n\tsynchronize_rcu();\n\n\tcfg80211_unregister_wdev(&sdata->wdev);\n\n\tif (!sdata->dev) {\n\t\tieee80211_teardown_sdata(sdata);\n\t\tkfree(sdata);\n\t}\n}\n\nvoid ieee80211_sdata_stop(struct ieee80211_sub_if_data *sdata)\n{\n\tif (WARN_ON_ONCE(!test_bit(SDATA_STATE_RUNNING, &sdata->state)))\n\t\treturn;\n\tieee80211_do_stop(sdata, true);\n}\n\nvoid ieee80211_remove_interfaces(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata, *tmp;\n\tLIST_HEAD(unreg_list);\n\n\tASSERT_RTNL();\n\n\t \n\tcfg80211_shutdown_all_interfaces(local->hw.wiphy);\n\n\tWARN(local->open_count, \"%s: open count remains %d\\n\",\n\t     wiphy_name(local->hw.wiphy), local->open_count);\n\n\tieee80211_txq_teardown_flows(local);\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_splice_init(&local->interfaces, &unreg_list);\n\tmutex_unlock(&local->iflist_mtx);\n\n\twiphy_lock(local->hw.wiphy);\n\tlist_for_each_entry_safe(sdata, tmp, &unreg_list, list) {\n\t\tbool netdev = sdata->dev;\n\n\t\tlist_del(&sdata->list);\n\t\tcfg80211_unregister_wdev(&sdata->wdev);\n\n\t\tif (!netdev)\n\t\t\tkfree(sdata);\n\t}\n\twiphy_unlock(local->hw.wiphy);\n}\n\nstatic int netdev_notify(struct notifier_block *nb,\n\t\t\t unsigned long state, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tif (state != NETDEV_CHANGENAME)\n\t\treturn NOTIFY_DONE;\n\n\tif (!dev->ieee80211_ptr || !dev->ieee80211_ptr->wiphy)\n\t\treturn NOTIFY_DONE;\n\n\tif (dev->ieee80211_ptr->wiphy->privid != mac80211_wiphy_privid)\n\t\treturn NOTIFY_DONE;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tmemcpy(sdata->name, dev->name, IFNAMSIZ);\n\tieee80211_debugfs_rename_netdev(sdata);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block mac80211_netdev_notifier = {\n\t.notifier_call = netdev_notify,\n};\n\nint ieee80211_iface_init(void)\n{\n\treturn register_netdevice_notifier(&mac80211_netdev_notifier);\n}\n\nvoid ieee80211_iface_exit(void)\n{\n\tunregister_netdevice_notifier(&mac80211_netdev_notifier);\n}\n\nvoid ieee80211_vif_inc_num_mcast(struct ieee80211_sub_if_data *sdata)\n{\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tatomic_inc(&sdata->u.ap.num_mcast_sta);\n\telse if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tatomic_inc(&sdata->u.vlan.num_mcast_sta);\n}\n\nvoid ieee80211_vif_dec_num_mcast(struct ieee80211_sub_if_data *sdata)\n{\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tatomic_dec(&sdata->u.ap.num_mcast_sta);\n\telse if (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tatomic_dec(&sdata->u.vlan.num_mcast_sta);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}