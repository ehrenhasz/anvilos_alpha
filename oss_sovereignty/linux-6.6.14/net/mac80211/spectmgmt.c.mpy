{
  "module_name": "spectmgmt.c",
  "hash_id": "72edc803ea363bed1475b8215ce2649b39a93d62b57b9796ebf93ec11cf477bf",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/spectmgmt.c",
  "human_readable_source": "\n \n\n#include <linux/ieee80211.h>\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"sta_info.h\"\n#include \"wme.h\"\n\nint ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct ieee802_11_elems *elems,\n\t\t\t\t enum nl80211_band current_band,\n\t\t\t\t u32 vht_cap_info,\n\t\t\t\t ieee80211_conn_flags_t conn_flags, u8 *bssid,\n\t\t\t\t struct ieee80211_csa_ie *csa_ie)\n{\n\tenum nl80211_band new_band = current_band;\n\tint new_freq;\n\tu8 new_chan_no;\n\tstruct ieee80211_channel *new_chan;\n\tstruct cfg80211_chan_def new_vht_chandef = {};\n\tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n\tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n\tint secondary_channel_offset = -1;\n\n\tmemset(csa_ie, 0, sizeof(*csa_ie));\n\n\tsec_chan_offs = elems->sec_chan_offs;\n\twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n\n\tif (conn_flags & (IEEE80211_CONN_DISABLE_HT |\n\t\t\t  IEEE80211_CONN_DISABLE_40MHZ)) {\n\t\tsec_chan_offs = NULL;\n\t\twide_bw_chansw_ie = NULL;\n\t}\n\n\tif (conn_flags & IEEE80211_CONN_DISABLE_VHT)\n\t\twide_bw_chansw_ie = NULL;\n\n\tif (elems->ext_chansw_ie) {\n\t\tif (!ieee80211_operating_class_to_band(\n\t\t\t\telems->ext_chansw_ie->new_operating_class,\n\t\t\t\t&new_band)) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n\t\t\t\t   elems->ext_chansw_ie->new_operating_class);\n\t\t}\n\t\tnew_chan_no = elems->ext_chansw_ie->new_ch_num;\n\t\tcsa_ie->count = elems->ext_chansw_ie->count;\n\t\tcsa_ie->mode = elems->ext_chansw_ie->mode;\n\t} else if (elems->ch_switch_ie) {\n\t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n\t\tcsa_ie->count = elems->ch_switch_ie->count;\n\t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n\t} else {\n\t\t \n\t\treturn 1;\n\t}\n\n\t \n\tif (elems->mesh_chansw_params_ie) {\n\t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n\t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n\t\tcsa_ie->pre_value = le16_to_cpu(\n\t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n\n\t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n\t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n\t\t\tcsa_ie->reason_code = le16_to_cpu(\n\t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n\t}\n\n\tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n\tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n\tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n\t\tsdata_info(sdata,\n\t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n\t\t\t   bssid, new_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sec_chan_offs) {\n\t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n\t} else if (!(conn_flags & IEEE80211_CONN_DISABLE_HT)) {\n\t\t \n\t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n\t}\n\n\tswitch (secondary_channel_offset) {\n\tdefault:\n\t\t \n\tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n\t\tcfg80211_chandef_create(&csa_ie->chandef, new_chan,\n\t\t\t\t\tNL80211_CHAN_HT20);\n\t\tbreak;\n\tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n\t\tcfg80211_chandef_create(&csa_ie->chandef, new_chan,\n\t\t\t\t\tNL80211_CHAN_HT40PLUS);\n\t\tbreak;\n\tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n\t\tcfg80211_chandef_create(&csa_ie->chandef, new_chan,\n\t\t\t\t\tNL80211_CHAN_HT40MINUS);\n\t\tbreak;\n\tcase -1:\n\t\tcfg80211_chandef_create(&csa_ie->chandef, new_chan,\n\t\t\t\t\tNL80211_CHAN_NO_HT);\n\t\t \n\t\tswitch (sdata->vif.bss_conf.chandef.width) {\n\t\tcase NL80211_CHAN_WIDTH_5:\n\t\tcase NL80211_CHAN_WIDTH_10:\n\t\t\tcsa_ie->chandef.width =\n\t\t\t\tsdata->vif.bss_conf.chandef.width;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (wide_bw_chansw_ie) {\n\t\tu8 new_seg1 = wide_bw_chansw_ie->new_center_freq_seg1;\n\t\tstruct ieee80211_vht_operation vht_oper = {\n\t\t\t.chan_width =\n\t\t\t\twide_bw_chansw_ie->new_channel_width,\n\t\t\t.center_freq_seg0_idx =\n\t\t\t\twide_bw_chansw_ie->new_center_freq_seg0,\n\t\t\t.center_freq_seg1_idx = new_seg1,\n\t\t\t \n\t\t};\n\t\tstruct ieee80211_ht_operation ht_oper = {\n\t\t\t.operation_mode =\n\t\t\t\tcpu_to_le16(new_seg1 <<\n\t\t\t\t\t    IEEE80211_HT_OP_MODE_CCFS2_SHIFT),\n\t\t};\n\n\t\t \n\t\tnew_vht_chandef = csa_ie->chandef;\n\n\t\t \n\t\tif (!ieee80211_chandef_vht_oper(&sdata->local->hw,\n\t\t\t\t\t\tvht_cap_info,\n\t\t\t\t\t\t&vht_oper, &ht_oper,\n\t\t\t\t\t\t&new_vht_chandef))\n\t\t\tnew_vht_chandef.chan = NULL;\n\n\t\tif (conn_flags & IEEE80211_CONN_DISABLE_80P80MHZ &&\n\t\t    new_vht_chandef.width == NL80211_CHAN_WIDTH_80P80)\n\t\t\tieee80211_chandef_downgrade(&new_vht_chandef);\n\t\tif (conn_flags & IEEE80211_CONN_DISABLE_160MHZ &&\n\t\t    new_vht_chandef.width == NL80211_CHAN_WIDTH_160)\n\t\t\tieee80211_chandef_downgrade(&new_vht_chandef);\n\t}\n\n\t \n\tif (new_vht_chandef.chan) {\n\t\tif (!cfg80211_chandef_compatible(&new_vht_chandef,\n\t\t\t\t\t\t &csa_ie->chandef)) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n\t\t\t\t   bssid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcsa_ie->chandef = new_vht_chandef;\n\t}\n\n\tif (elems->max_channel_switch_time)\n\t\tcsa_ie->max_switch_time =\n\t\t\t(elems->max_channel_switch_time[0] << 0) |\n\t\t\t(elems->max_channel_switch_time[1] <<  8) |\n\t\t\t(elems->max_channel_switch_time[2] << 16);\n\n\treturn 0;\n}\n\nstatic void ieee80211_send_refuse_measurement_request(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct ieee80211_msrment_ie *request_ie,\n\t\t\t\t\tconst u8 *da, const u8 *bssid,\n\t\t\t\t\tu8 dialog_token)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *msr_report;\n\n\tskb = dev_alloc_skb(sizeof(*msr_report) + local->hw.extra_tx_headroom +\n\t\t\t\tsizeof(struct ieee80211_msrment_ie));\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\tmsr_report = skb_put_zero(skb, 24);\n\tmemcpy(msr_report->da, da, ETH_ALEN);\n\tmemcpy(msr_report->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(msr_report->bssid, bssid, ETH_ALEN);\n\tmsr_report->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t\tIEEE80211_STYPE_ACTION);\n\n\tskb_put(skb, 1 + sizeof(msr_report->u.action.u.measurement));\n\tmsr_report->u.action.category = WLAN_CATEGORY_SPECTRUM_MGMT;\n\tmsr_report->u.action.u.measurement.action_code =\n\t\t\t\tWLAN_ACTION_SPCT_MSR_RPRT;\n\tmsr_report->u.action.u.measurement.dialog_token = dialog_token;\n\n\tmsr_report->u.action.u.measurement.element_id = WLAN_EID_MEASURE_REPORT;\n\tmsr_report->u.action.u.measurement.length =\n\t\t\tsizeof(struct ieee80211_msrment_ie);\n\n\tmemset(&msr_report->u.action.u.measurement.msr_elem, 0,\n\t\tsizeof(struct ieee80211_msrment_ie));\n\tmsr_report->u.action.u.measurement.msr_elem.token = request_ie->token;\n\tmsr_report->u.action.u.measurement.msr_elem.mode |=\n\t\t\tIEEE80211_SPCT_MSR_RPRT_MODE_REFUSED;\n\tmsr_report->u.action.u.measurement.msr_elem.type = request_ie->type;\n\n\tieee80211_tx_skb(sdata, skb);\n}\n\nvoid ieee80211_process_measurement_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_mgmt *mgmt,\n\t\t\t\t       size_t len)\n{\n\t \n\tieee80211_send_refuse_measurement_request(sdata,\n\t\t\t&mgmt->u.action.u.measurement.msr_elem,\n\t\t\tmgmt->sa, mgmt->bssid,\n\t\t\tmgmt->u.action.u.measurement.dialog_token);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}