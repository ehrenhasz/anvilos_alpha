{
  "module_name": "fils_aead.c",
  "hash_id": "255f93c19a27a8c0538e838801f0bee2dcfb8793741ec0580ffbf00e619aae5e",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/fils_aead.c",
  "human_readable_source": "\n \n\n#include <crypto/aes.h>\n#include <crypto/hash.h>\n#include <crypto/skcipher.h>\n#include <crypto/utils.h>\n\n#include \"ieee80211_i.h\"\n#include \"aes_cmac.h\"\n#include \"fils_aead.h\"\n\nstatic void gf_mulx(u8 *pad)\n{\n\tu64 a = get_unaligned_be64(pad);\n\tu64 b = get_unaligned_be64(pad + 8);\n\n\tput_unaligned_be64((a << 1) | (b >> 63), pad);\n\tput_unaligned_be64((b << 1) ^ ((a >> 63) ? 0x87 : 0), pad + 8);\n}\n\nstatic int aes_s2v(struct crypto_shash *tfm,\n\t\t   size_t num_elem, const u8 *addr[], size_t len[], u8 *v)\n{\n\tu8 d[AES_BLOCK_SIZE], tmp[AES_BLOCK_SIZE] = {};\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tsize_t i;\n\n\tdesc->tfm = tfm;\n\n\t \n\tcrypto_shash_digest(desc, tmp, AES_BLOCK_SIZE, d);\n\n\tfor (i = 0; i < num_elem - 1; i++) {\n\t\t \n\t\tgf_mulx(d);  \n\t\tcrypto_shash_digest(desc, addr[i], len[i], tmp);\n\t\tcrypto_xor(d, tmp, AES_BLOCK_SIZE);\n\t}\n\n\tcrypto_shash_init(desc);\n\n\tif (len[i] >= AES_BLOCK_SIZE) {\n\t\t \n\t\t \n\t\tcrypto_shash_update(desc, addr[i], len[i] - AES_BLOCK_SIZE);\n\t\tcrypto_xor(d, addr[i] + len[i] - AES_BLOCK_SIZE,\n\t\t\t   AES_BLOCK_SIZE);\n\t} else {\n\t\t \n\t\t \n\t\tgf_mulx(d);  \n\t\tcrypto_xor(d, addr[i], len[i]);\n\t\td[len[i]] ^= 0x80;\n\t}\n\t \n\tcrypto_shash_finup(desc, d, AES_BLOCK_SIZE, v);\n\n\treturn 0;\n}\n\n \nstatic int aes_siv_encrypt(const u8 *key, size_t key_len,\n\t\t\t   const u8 *plain, size_t plain_len,\n\t\t\t   size_t num_elem, const u8 *addr[],\n\t\t\t   size_t len[], u8 *out)\n{\n\tu8 v[AES_BLOCK_SIZE];\n\tstruct crypto_shash *tfm;\n\tstruct crypto_skcipher *tfm2;\n\tstruct skcipher_request *req;\n\tint res;\n\tstruct scatterlist src[1], dst[1];\n\tu8 *tmp;\n\n\tkey_len /= 2;  \n\n\taddr[num_elem] = plain;\n\tlen[num_elem] = plain_len;\n\tnum_elem++;\n\n\t \n\n\ttfm = crypto_alloc_shash(\"cmac(aes)\", 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\t \n\tres = crypto_shash_setkey(tfm, key, key_len);\n\tif (!res)\n\t\tres = aes_s2v(tfm, num_elem, addr, len, v);\n\tcrypto_free_shash(tfm);\n\tif (res)\n\t\treturn res;\n\n\t \n\ttmp = kmemdup(plain, plain_len, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(out, v, AES_BLOCK_SIZE);\n\n\t \n\tv[8] &= 0x7f;\n\tv[12] &= 0x7f;\n\n\t \n\n\ttfm2 = crypto_alloc_skcipher(\"ctr(aes)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm2)) {\n\t\tkfree(tmp);\n\t\treturn PTR_ERR(tfm2);\n\t}\n\t \n\tres = crypto_skcipher_setkey(tfm2, key + key_len, key_len);\n\tif (res)\n\t\tgoto fail;\n\n\treq = skcipher_request_alloc(tfm2, GFP_KERNEL);\n\tif (!req) {\n\t\tres = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tsg_init_one(src, tmp, plain_len);\n\tsg_init_one(dst, out + AES_BLOCK_SIZE, plain_len);\n\tskcipher_request_set_crypt(req, src, dst, plain_len, v);\n\tres = crypto_skcipher_encrypt(req);\n\tskcipher_request_free(req);\nfail:\n\tkfree(tmp);\n\tcrypto_free_skcipher(tfm2);\n\treturn res;\n}\n\n \nstatic int aes_siv_decrypt(const u8 *key, size_t key_len,\n\t\t\t   const u8 *iv_crypt, size_t iv_c_len,\n\t\t\t   size_t num_elem, const u8 *addr[], size_t len[],\n\t\t\t   u8 *out)\n{\n\tstruct crypto_shash *tfm;\n\tstruct crypto_skcipher *tfm2;\n\tstruct skcipher_request *req;\n\tstruct scatterlist src[1], dst[1];\n\tsize_t crypt_len;\n\tint res;\n\tu8 frame_iv[AES_BLOCK_SIZE], iv[AES_BLOCK_SIZE];\n\tu8 check[AES_BLOCK_SIZE];\n\n\tcrypt_len = iv_c_len - AES_BLOCK_SIZE;\n\tkey_len /= 2;  \n\taddr[num_elem] = out;\n\tlen[num_elem] = crypt_len;\n\tnum_elem++;\n\n\tmemcpy(iv, iv_crypt, AES_BLOCK_SIZE);\n\tmemcpy(frame_iv, iv_crypt, AES_BLOCK_SIZE);\n\n\t \n\tiv[8] &= 0x7f;\n\tiv[12] &= 0x7f;\n\n\t \n\n\ttfm2 = crypto_alloc_skcipher(\"ctr(aes)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm2))\n\t\treturn PTR_ERR(tfm2);\n\t \n\tres = crypto_skcipher_setkey(tfm2, key + key_len, key_len);\n\tif (res) {\n\t\tcrypto_free_skcipher(tfm2);\n\t\treturn res;\n\t}\n\n\treq = skcipher_request_alloc(tfm2, GFP_KERNEL);\n\tif (!req) {\n\t\tcrypto_free_skcipher(tfm2);\n\t\treturn -ENOMEM;\n\t}\n\n\tsg_init_one(src, iv_crypt + AES_BLOCK_SIZE, crypt_len);\n\tsg_init_one(dst, out, crypt_len);\n\tskcipher_request_set_crypt(req, src, dst, crypt_len, iv);\n\tres = crypto_skcipher_decrypt(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm2);\n\tif (res)\n\t\treturn res;\n\n\t \n\n\ttfm = crypto_alloc_shash(\"cmac(aes)\", 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\t \n\tres = crypto_shash_setkey(tfm, key, key_len);\n\tif (!res)\n\t\tres = aes_s2v(tfm, num_elem, addr, len, check);\n\tcrypto_free_shash(tfm);\n\tif (res)\n\t\treturn res;\n\tif (memcmp(check, frame_iv, AES_BLOCK_SIZE) != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nint fils_encrypt_assoc_req(struct sk_buff *skb,\n\t\t\t   struct ieee80211_mgd_assoc_data *assoc_data)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\tu8 *capab, *ies, *encr;\n\tconst u8 *addr[5 + 1];\n\tconst struct element *session;\n\tsize_t len[5 + 1];\n\tsize_t crypt_len;\n\n\tif (ieee80211_is_reassoc_req(mgmt->frame_control)) {\n\t\tcapab = (u8 *)&mgmt->u.reassoc_req.capab_info;\n\t\ties = mgmt->u.reassoc_req.variable;\n\t} else {\n\t\tcapab = (u8 *)&mgmt->u.assoc_req.capab_info;\n\t\ties = mgmt->u.assoc_req.variable;\n\t}\n\n\tsession = cfg80211_find_ext_elem(WLAN_EID_EXT_FILS_SESSION,\n\t\t\t\t\t ies, skb->data + skb->len - ies);\n\tif (!session || session->datalen != 1 + 8)\n\t\treturn -EINVAL;\n\t \n\tencr = (u8 *)session->data + 1 + 8;\n\n\t \n\n\t \n\taddr[0] = mgmt->sa;\n\tlen[0] = ETH_ALEN;\n\t \n\taddr[1] = mgmt->da;\n\tlen[1] = ETH_ALEN;\n\t \n\taddr[2] = assoc_data->fils_nonces;\n\tlen[2] = FILS_NONCE_LEN;\n\t \n\taddr[3] = &assoc_data->fils_nonces[FILS_NONCE_LEN];\n\tlen[3] = FILS_NONCE_LEN;\n\t \n\taddr[4] = capab;\n\tlen[4] = encr - capab;\n\n\tcrypt_len = skb->data + skb->len - encr;\n\tskb_put(skb, AES_BLOCK_SIZE);\n\treturn aes_siv_encrypt(assoc_data->fils_kek, assoc_data->fils_kek_len,\n\t\t\t       encr, crypt_len, 5, addr, len, encr);\n}\n\nint fils_decrypt_assoc_resp(struct ieee80211_sub_if_data *sdata,\n\t\t\t    u8 *frame, size_t *frame_len,\n\t\t\t    struct ieee80211_mgd_assoc_data *assoc_data)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)frame;\n\tu8 *capab, *ies, *encr;\n\tconst u8 *addr[5 + 1];\n\tconst struct element *session;\n\tsize_t len[5 + 1];\n\tint res;\n\tsize_t crypt_len;\n\n\tif (*frame_len < 24 + 6)\n\t\treturn -EINVAL;\n\n\tcapab = (u8 *)&mgmt->u.assoc_resp.capab_info;\n\ties = mgmt->u.assoc_resp.variable;\n\tsession = cfg80211_find_ext_elem(WLAN_EID_EXT_FILS_SESSION,\n\t\t\t\t\t ies, frame + *frame_len - ies);\n\tif (!session || session->datalen != 1 + 8) {\n\t\tmlme_dbg(sdata,\n\t\t\t \"No (valid) FILS Session element in (Re)Association Response frame from %pM\",\n\t\t\t mgmt->sa);\n\t\treturn -EINVAL;\n\t}\n\t \n\tencr = (u8 *)session->data + 1 + 8;\n\n\t \n\n\t \n\taddr[0] = mgmt->sa;\n\tlen[0] = ETH_ALEN;\n\t \n\taddr[1] = mgmt->da;\n\tlen[1] = ETH_ALEN;\n\t \n\taddr[2] = &assoc_data->fils_nonces[FILS_NONCE_LEN];\n\tlen[2] = FILS_NONCE_LEN;\n\t \n\taddr[3] = assoc_data->fils_nonces;\n\tlen[3] = FILS_NONCE_LEN;\n\t \n\taddr[4] = capab;\n\tlen[4] = encr - capab;\n\n\tcrypt_len = frame + *frame_len - encr;\n\tif (crypt_len < AES_BLOCK_SIZE) {\n\t\tmlme_dbg(sdata,\n\t\t\t \"Not enough room for AES-SIV data after FILS Session element in (Re)Association Response frame from %pM\",\n\t\t\t mgmt->sa);\n\t\treturn -EINVAL;\n\t}\n\tres = aes_siv_decrypt(assoc_data->fils_kek, assoc_data->fils_kek_len,\n\t\t\t      encr, crypt_len, 5, addr, len, encr);\n\tif (res != 0) {\n\t\tmlme_dbg(sdata,\n\t\t\t \"AES-SIV decryption of (Re)Association Response frame from %pM failed\",\n\t\t\t mgmt->sa);\n\t\treturn res;\n\t}\n\t*frame_len -= AES_BLOCK_SIZE;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}