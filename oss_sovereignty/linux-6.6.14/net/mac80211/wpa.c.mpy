{
  "module_name": "wpa.c",
  "hash_id": "7c3147319811929def516d4dbef776de2658e385f0bbcfa3c49e0487649a999c",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/wpa.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/compiler.h>\n#include <linux/ieee80211.h>\n#include <linux/gfp.h>\n#include <asm/unaligned.h>\n#include <net/mac80211.h>\n#include <crypto/aes.h>\n#include <crypto/utils.h>\n\n#include \"ieee80211_i.h\"\n#include \"michael.h\"\n#include \"tkip.h\"\n#include \"aes_ccm.h\"\n#include \"aes_cmac.h\"\n#include \"aes_gmac.h\"\n#include \"aes_gcm.h\"\n#include \"wpa.h\"\n\nieee80211_tx_result\nieee80211_tx_h_michael_mic_add(struct ieee80211_tx_data *tx)\n{\n\tu8 *data, *key, *mic;\n\tsize_t data_len;\n\tunsigned int hdrlen;\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb = tx->skb;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint tail;\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tif (!tx->key || tx->key->conf.cipher != WLAN_CIPHER_SUITE_TKIP ||\n\t    skb->len < 24 || !ieee80211_is_data_present(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tif (skb->len < hdrlen)\n\t\treturn TX_DROP;\n\n\tdata = skb->data + hdrlen;\n\tdata_len = skb->len - hdrlen;\n\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_TKIP_MIC_FAILURE)) {\n\t\t \n\t\tinfo->control.hw_key = NULL;\n\t}\n\n\tif (info->control.hw_key &&\n\t    (info->flags & IEEE80211_TX_CTL_DONTFRAG ||\n\t     ieee80211_hw_check(&tx->local->hw, SUPPORTS_TX_FRAG)) &&\n\t    !(tx->key->conf.flags & (IEEE80211_KEY_FLAG_GENERATE_MMIC |\n\t\t\t\t     IEEE80211_KEY_FLAG_PUT_MIC_SPACE))) {\n\t\t \n\t\treturn TX_CONTINUE;\n\t}\n\n\ttail = MICHAEL_MIC_LEN;\n\tif (!info->control.hw_key)\n\t\ttail += IEEE80211_TKIP_ICV_LEN;\n\n\tif (WARN(skb_tailroom(skb) < tail ||\n\t\t skb_headroom(skb) < IEEE80211_TKIP_IV_LEN,\n\t\t \"mmic: not enough head/tail (%d/%d,%d/%d)\\n\",\n\t\t skb_headroom(skb), IEEE80211_TKIP_IV_LEN,\n\t\t skb_tailroom(skb), tail))\n\t\treturn TX_DROP;\n\n\tmic = skb_put(skb, MICHAEL_MIC_LEN);\n\n\tif (tx->key->conf.flags & IEEE80211_KEY_FLAG_PUT_MIC_SPACE) {\n\t\t \n\t\tmemset(mic, 0, MICHAEL_MIC_LEN);\n\t\treturn TX_CONTINUE;\n\t}\n\n\tkey = &tx->key->conf.key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY];\n\tmichael_mic(key, hdr, data, data_len, mic);\n\tif (unlikely(info->flags & IEEE80211_TX_INTFL_TKIP_MIC_FAILURE))\n\t\tmic[0]++;\n\n\treturn TX_CONTINUE;\n}\n\n\nieee80211_rx_result\nieee80211_rx_h_michael_mic_verify(struct ieee80211_rx_data *rx)\n{\n\tu8 *data, *key = NULL;\n\tsize_t data_len;\n\tunsigned int hdrlen;\n\tu8 mic[MICHAEL_MIC_LEN];\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\n\t \n\tif (!ieee80211_is_data_present(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t \n\tif (status->flag & (RX_FLAG_MMIC_STRIPPED | RX_FLAG_IV_STRIPPED)) {\n\t\tif (status->flag & RX_FLAG_MMIC_ERROR)\n\t\t\tgoto mic_fail_no_key;\n\n\t\tif (!(status->flag & RX_FLAG_IV_STRIPPED) && rx->key &&\n\t\t    rx->key->conf.cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\tgoto update_iv;\n\n\t\treturn RX_CONTINUE;\n\t}\n\n\t \n\tif (!rx->key || rx->key->conf.cipher != WLAN_CIPHER_SUITE_TKIP ||\n\t    !(status->flag & RX_FLAG_DECRYPTED))\n\t\treturn RX_CONTINUE;\n\n\tif (rx->sdata->vif.type == NL80211_IFTYPE_AP && rx->key->conf.keyidx) {\n\t\t \n\t\treturn RX_DROP_UNUSABLE;\n\t}\n\n\tif (status->flag & RX_FLAG_MMIC_ERROR)\n\t\tgoto mic_fail;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tif (skb->len < hdrlen + MICHAEL_MIC_LEN)\n\t\treturn RX_DROP_UNUSABLE;\n\n\tif (skb_linearize(rx->skb))\n\t\treturn RX_DROP_UNUSABLE;\n\thdr = (void *)skb->data;\n\n\tdata = skb->data + hdrlen;\n\tdata_len = skb->len - hdrlen - MICHAEL_MIC_LEN;\n\tkey = &rx->key->conf.key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY];\n\tmichael_mic(key, hdr, data, data_len, mic);\n\tif (crypto_memneq(mic, data + data_len, MICHAEL_MIC_LEN))\n\t\tgoto mic_fail;\n\n\t \n\tskb_trim(skb, skb->len - MICHAEL_MIC_LEN);\n\nupdate_iv:\n\t \n\trx->key->u.tkip.rx[rx->security_idx].iv32 = rx->tkip.iv32;\n\trx->key->u.tkip.rx[rx->security_idx].iv16 = rx->tkip.iv16;\n\n\treturn RX_CONTINUE;\n\nmic_fail:\n\trx->key->u.tkip.mic_failures++;\n\nmic_fail_no_key:\n\t \n\tcfg80211_michael_mic_failure(rx->sdata->dev, hdr->addr2,\n\t\t\t\t     is_multicast_ether_addr(hdr->addr1) ?\n\t\t\t\t     NL80211_KEYTYPE_GROUP :\n\t\t\t\t     NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t     rx->key ? rx->key->conf.keyidx : -1,\n\t\t\t\t     NULL, GFP_ATOMIC);\n\treturn RX_DROP_UNUSABLE;\n}\n\nstatic int tkip_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_key *key = tx->key;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tunsigned int hdrlen;\n\tint len, tail;\n\tu64 pn;\n\tu8 *pos;\n\n\tif (info->control.hw_key &&\n\t    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) &&\n\t    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tlen = skb->len - hdrlen;\n\n\tif (info->control.hw_key)\n\t\ttail = 0;\n\telse\n\t\ttail = IEEE80211_TKIP_ICV_LEN;\n\n\tif (WARN_ON(skb_tailroom(skb) < tail ||\n\t\t    skb_headroom(skb) < IEEE80211_TKIP_IV_LEN))\n\t\treturn -1;\n\n\tpos = skb_push(skb, IEEE80211_TKIP_IV_LEN);\n\tmemmove(pos, pos + IEEE80211_TKIP_IV_LEN, hdrlen);\n\tpos += hdrlen;\n\n\t \n\tif (info->control.hw_key &&\n\t    (info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE))\n\t\treturn 0;\n\n\t \n\tpn = atomic64_inc_return(&key->conf.tx_pn);\n\tpos = ieee80211_tkip_add_iv(pos, &key->conf, pn);\n\n\t \n\tif (info->control.hw_key)\n\t\treturn 0;\n\n\t \n\tskb_put(skb, IEEE80211_TKIP_ICV_LEN);\n\n\treturn ieee80211_tkip_encrypt_data(&tx->local->wep_tx_ctx,\n\t\t\t\t\t   key, skb, pos, len);\n}\n\n\nieee80211_tx_result\nieee80211_crypto_tkip_encrypt(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\n\tieee80211_tx_set_protected(tx);\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tif (tkip_encrypt_skb(tx, skb) < 0)\n\t\t\treturn TX_DROP;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\n\nieee80211_rx_result\nieee80211_crypto_tkip_decrypt(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) rx->skb->data;\n\tint hdrlen, res, hwaccel = 0;\n\tstruct ieee80211_key *key = rx->key;\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (!ieee80211_is_data(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\tif (!rx->sta || skb->len - hdrlen < 12)\n\t\treturn RX_DROP_UNUSABLE;\n\n\t \n\tif (skb_linearize(rx->skb))\n\t\treturn RX_DROP_UNUSABLE;\n\thdr = (void *)skb->data;\n\n\t \n\tif (status->flag & RX_FLAG_DECRYPTED)\n\t\thwaccel = 1;\n\n\tres = ieee80211_tkip_decrypt_data(&rx->local->wep_rx_ctx,\n\t\t\t\t\t  key, skb->data + hdrlen,\n\t\t\t\t\t  skb->len - hdrlen, rx->sta->sta.addr,\n\t\t\t\t\t  hdr->addr1, hwaccel, rx->security_idx,\n\t\t\t\t\t  &rx->tkip.iv32,\n\t\t\t\t\t  &rx->tkip.iv16);\n\tif (res != TKIP_DECRYPT_OK)\n\t\treturn RX_DROP_UNUSABLE;\n\n\t \n\tif (!(status->flag & RX_FLAG_ICV_STRIPPED))\n\t\tskb_trim(skb, skb->len - IEEE80211_TKIP_ICV_LEN);\n\n\t \n\tmemmove(skb->data + IEEE80211_TKIP_IV_LEN, skb->data, hdrlen);\n\tskb_pull(skb, IEEE80211_TKIP_IV_LEN);\n\n\treturn RX_CONTINUE;\n}\n\n \nstatic u8 ccmp_gcmp_aad(struct sk_buff *skb, u8 *aad)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t__le16 mask_fc;\n\tint a4_included, mgmt;\n\tu8 qos_tid;\n\tu16 len_a = 22;\n\n\t \n\tmgmt = ieee80211_is_mgmt(hdr->frame_control);\n\tmask_fc = hdr->frame_control;\n\tmask_fc &= ~cpu_to_le16(IEEE80211_FCTL_RETRY |\n\t\t\t\tIEEE80211_FCTL_PM | IEEE80211_FCTL_MOREDATA);\n\tif (!mgmt)\n\t\tmask_fc &= ~cpu_to_le16(0x0070);\n\tmask_fc |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\n\ta4_included = ieee80211_has_a4(hdr->frame_control);\n\tif (a4_included)\n\t\tlen_a += 6;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tqos_tid = ieee80211_get_tid(hdr);\n\t\tmask_fc &= ~cpu_to_le16(IEEE80211_FCTL_ORDER);\n\t\tlen_a += 2;\n\t} else {\n\t\tqos_tid = 0;\n\t}\n\n\t \n\tput_unaligned_be16(len_a, &aad[0]);\n\tput_unaligned(mask_fc, (__le16 *)&aad[2]);\n\tmemcpy(&aad[4], &hdr->addrs, 3 * ETH_ALEN);\n\n\t \n\taad[22] = *((u8 *) &hdr->seq_ctrl) & 0x0f;\n\taad[23] = 0;\n\n\tif (a4_included) {\n\t\tmemcpy(&aad[24], hdr->addr4, ETH_ALEN);\n\t\taad[30] = qos_tid;\n\t\taad[31] = 0;\n\t} else {\n\t\tmemset(&aad[24], 0, ETH_ALEN + IEEE80211_QOS_CTL_LEN);\n\t\taad[24] = qos_tid;\n\t}\n\n\treturn qos_tid;\n}\n\nstatic void ccmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *b_0, u8 *aad)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tu8 qos_tid = ccmp_gcmp_aad(skb, aad);\n\n\t \n\tb_0[0] = 0x1;\n\n\t \n\tb_0[1] = qos_tid | (ieee80211_is_mgmt(hdr->frame_control) << 4);\n\tmemcpy(&b_0[2], hdr->addr2, ETH_ALEN);\n\tmemcpy(&b_0[8], pn, IEEE80211_CCMP_PN_LEN);\n}\n\nstatic inline void ccmp_pn2hdr(u8 *hdr, u8 *pn, int key_id)\n{\n\thdr[0] = pn[5];\n\thdr[1] = pn[4];\n\thdr[2] = 0;\n\thdr[3] = 0x20 | (key_id << 6);\n\thdr[4] = pn[3];\n\thdr[5] = pn[2];\n\thdr[6] = pn[1];\n\thdr[7] = pn[0];\n}\n\n\nstatic inline void ccmp_hdr2pn(u8 *pn, u8 *hdr)\n{\n\tpn[0] = hdr[7];\n\tpn[1] = hdr[6];\n\tpn[2] = hdr[5];\n\tpn[3] = hdr[4];\n\tpn[4] = hdr[1];\n\tpn[5] = hdr[0];\n}\n\n\nstatic int ccmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb,\n\t\t\t    unsigned int mic_len)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_key *key = tx->key;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint hdrlen, len, tail;\n\tu8 *pos;\n\tu8 pn[6];\n\tu64 pn64;\n\tu8 aad[CCM_AAD_LEN];\n\tu8 b_0[AES_BLOCK_SIZE];\n\n\tif (info->control.hw_key &&\n\t    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) &&\n\t    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE) &&\n\t    !((info->control.hw_key->flags &\n\t       IEEE80211_KEY_FLAG_GENERATE_IV_MGMT) &&\n\t      ieee80211_is_mgmt(hdr->frame_control))) {\n\t\t \n\t\treturn 0;\n\t}\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tlen = skb->len - hdrlen;\n\n\tif (info->control.hw_key)\n\t\ttail = 0;\n\telse\n\t\ttail = mic_len;\n\n\tif (WARN_ON(skb_tailroom(skb) < tail ||\n\t\t    skb_headroom(skb) < IEEE80211_CCMP_HDR_LEN))\n\t\treturn -1;\n\n\tpos = skb_push(skb, IEEE80211_CCMP_HDR_LEN);\n\tmemmove(pos, pos + IEEE80211_CCMP_HDR_LEN, hdrlen);\n\n\t \n\tif (info->control.hw_key &&\n\t    (info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE))\n\t\treturn 0;\n\n\tpos += hdrlen;\n\n\tpn64 = atomic64_inc_return(&key->conf.tx_pn);\n\n\tpn[5] = pn64;\n\tpn[4] = pn64 >> 8;\n\tpn[3] = pn64 >> 16;\n\tpn[2] = pn64 >> 24;\n\tpn[1] = pn64 >> 32;\n\tpn[0] = pn64 >> 40;\n\n\tccmp_pn2hdr(pos, pn, key->conf.keyidx);\n\n\t \n\tif (info->control.hw_key)\n\t\treturn 0;\n\n\tpos += IEEE80211_CCMP_HDR_LEN;\n\tccmp_special_blocks(skb, pn, b_0, aad);\n\treturn ieee80211_aes_ccm_encrypt(key->u.ccmp.tfm, b_0, aad, pos, len,\n\t\t\t\t\t skb_put(skb, mic_len));\n}\n\n\nieee80211_tx_result\nieee80211_crypto_ccmp_encrypt(struct ieee80211_tx_data *tx,\n\t\t\t      unsigned int mic_len)\n{\n\tstruct sk_buff *skb;\n\n\tieee80211_tx_set_protected(tx);\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tif (ccmp_encrypt_skb(tx, skb, mic_len) < 0)\n\t\t\treturn TX_DROP;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\n\nieee80211_rx_result\nieee80211_crypto_ccmp_decrypt(struct ieee80211_rx_data *rx,\n\t\t\t      unsigned int mic_len)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tint hdrlen;\n\tstruct ieee80211_key *key = rx->key;\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tu8 pn[IEEE80211_CCMP_PN_LEN];\n\tint data_len;\n\tint queue;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (!ieee80211_is_data(hdr->frame_control) &&\n\t    !ieee80211_is_robust_mgmt_frame(skb))\n\t\treturn RX_CONTINUE;\n\n\tif (status->flag & RX_FLAG_DECRYPTED) {\n\t\tif (!pskb_may_pull(rx->skb, hdrlen + IEEE80211_CCMP_HDR_LEN))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\tif (status->flag & RX_FLAG_MIC_STRIPPED)\n\t\t\tmic_len = 0;\n\t} else {\n\t\tif (skb_linearize(rx->skb))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t}\n\n\t \n\thdr = (void *)rx->skb->data;\n\n\tdata_len = skb->len - hdrlen - IEEE80211_CCMP_HDR_LEN - mic_len;\n\tif (!rx->sta || data_len < 0)\n\t\treturn RX_DROP_UNUSABLE;\n\n\tif (!(status->flag & RX_FLAG_PN_VALIDATED)) {\n\t\tint res;\n\n\t\tccmp_hdr2pn(pn, skb->data + hdrlen);\n\n\t\tqueue = rx->security_idx;\n\n\t\tres = memcmp(pn, key->u.ccmp.rx_pn[queue],\n\t\t\t     IEEE80211_CCMP_PN_LEN);\n\t\tif (res < 0 ||\n\t\t    (!res && !(status->flag & RX_FLAG_ALLOW_SAME_PN))) {\n\t\t\tkey->u.ccmp.replays++;\n\t\t\treturn RX_DROP_U_REPLAY;\n\t\t}\n\n\t\tif (!(status->flag & RX_FLAG_DECRYPTED)) {\n\t\t\tu8 aad[2 * AES_BLOCK_SIZE];\n\t\t\tu8 b_0[AES_BLOCK_SIZE];\n\t\t\t \n\t\t\tccmp_special_blocks(skb, pn, b_0, aad);\n\n\t\t\tif (ieee80211_aes_ccm_decrypt(\n\t\t\t\t    key->u.ccmp.tfm, b_0, aad,\n\t\t\t\t    skb->data + hdrlen + IEEE80211_CCMP_HDR_LEN,\n\t\t\t\t    data_len,\n\t\t\t\t    skb->data + skb->len - mic_len))\n\t\t\t\treturn RX_DROP_U_MIC_FAIL;\n\t\t}\n\n\t\tmemcpy(key->u.ccmp.rx_pn[queue], pn, IEEE80211_CCMP_PN_LEN);\n\t\tif (unlikely(ieee80211_is_frag(hdr)))\n\t\t\tmemcpy(rx->ccm_gcm.pn, pn, IEEE80211_CCMP_PN_LEN);\n\t}\n\n\t \n\tif (pskb_trim(skb, skb->len - mic_len))\n\t\treturn RX_DROP_UNUSABLE;\n\tmemmove(skb->data + IEEE80211_CCMP_HDR_LEN, skb->data, hdrlen);\n\tskb_pull(skb, IEEE80211_CCMP_HDR_LEN);\n\n\treturn RX_CONTINUE;\n}\n\nstatic void gcmp_special_blocks(struct sk_buff *skb, u8 *pn, u8 *j_0, u8 *aad)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\n\tmemcpy(j_0, hdr->addr2, ETH_ALEN);\n\tmemcpy(&j_0[ETH_ALEN], pn, IEEE80211_GCMP_PN_LEN);\n\tj_0[13] = 0;\n\tj_0[14] = 0;\n\tj_0[AES_BLOCK_SIZE - 1] = 0x01;\n\n\tccmp_gcmp_aad(skb, aad);\n}\n\nstatic inline void gcmp_pn2hdr(u8 *hdr, const u8 *pn, int key_id)\n{\n\thdr[0] = pn[5];\n\thdr[1] = pn[4];\n\thdr[2] = 0;\n\thdr[3] = 0x20 | (key_id << 6);\n\thdr[4] = pn[3];\n\thdr[5] = pn[2];\n\thdr[6] = pn[1];\n\thdr[7] = pn[0];\n}\n\nstatic inline void gcmp_hdr2pn(u8 *pn, const u8 *hdr)\n{\n\tpn[0] = hdr[7];\n\tpn[1] = hdr[6];\n\tpn[2] = hdr[5];\n\tpn[3] = hdr[4];\n\tpn[4] = hdr[1];\n\tpn[5] = hdr[0];\n}\n\nstatic int gcmp_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_key *key = tx->key;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint hdrlen, len, tail;\n\tu8 *pos;\n\tu8 pn[6];\n\tu64 pn64;\n\tu8 aad[GCM_AAD_LEN];\n\tu8 j_0[AES_BLOCK_SIZE];\n\n\tif (info->control.hw_key &&\n\t    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) &&\n\t    !(info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE) &&\n\t    !((info->control.hw_key->flags &\n\t       IEEE80211_KEY_FLAG_GENERATE_IV_MGMT) &&\n\t      ieee80211_is_mgmt(hdr->frame_control))) {\n\t\t \n\t\treturn 0;\n\t}\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tlen = skb->len - hdrlen;\n\n\tif (info->control.hw_key)\n\t\ttail = 0;\n\telse\n\t\ttail = IEEE80211_GCMP_MIC_LEN;\n\n\tif (WARN_ON(skb_tailroom(skb) < tail ||\n\t\t    skb_headroom(skb) < IEEE80211_GCMP_HDR_LEN))\n\t\treturn -1;\n\n\tpos = skb_push(skb, IEEE80211_GCMP_HDR_LEN);\n\tmemmove(pos, pos + IEEE80211_GCMP_HDR_LEN, hdrlen);\n\tskb_set_network_header(skb, skb_network_offset(skb) +\n\t\t\t\t    IEEE80211_GCMP_HDR_LEN);\n\n\t \n\tif (info->control.hw_key &&\n\t    (info->control.hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE))\n\t\treturn 0;\n\n\tpos += hdrlen;\n\n\tpn64 = atomic64_inc_return(&key->conf.tx_pn);\n\n\tpn[5] = pn64;\n\tpn[4] = pn64 >> 8;\n\tpn[3] = pn64 >> 16;\n\tpn[2] = pn64 >> 24;\n\tpn[1] = pn64 >> 32;\n\tpn[0] = pn64 >> 40;\n\n\tgcmp_pn2hdr(pos, pn, key->conf.keyidx);\n\n\t \n\tif (info->control.hw_key)\n\t\treturn 0;\n\n\tpos += IEEE80211_GCMP_HDR_LEN;\n\tgcmp_special_blocks(skb, pn, j_0, aad);\n\treturn ieee80211_aes_gcm_encrypt(key->u.gcmp.tfm, j_0, aad, pos, len,\n\t\t\t\t\t skb_put(skb, IEEE80211_GCMP_MIC_LEN));\n}\n\nieee80211_tx_result\nieee80211_crypto_gcmp_encrypt(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\n\tieee80211_tx_set_protected(tx);\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\tif (gcmp_encrypt_skb(tx, skb) < 0)\n\t\t\treturn TX_DROP;\n\t}\n\n\treturn TX_CONTINUE;\n}\n\nieee80211_rx_result\nieee80211_crypto_gcmp_decrypt(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tint hdrlen;\n\tstruct ieee80211_key *key = rx->key;\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tu8 pn[IEEE80211_GCMP_PN_LEN];\n\tint data_len, queue, mic_len = IEEE80211_GCMP_MIC_LEN;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\tif (!ieee80211_is_data(hdr->frame_control) &&\n\t    !ieee80211_is_robust_mgmt_frame(skb))\n\t\treturn RX_CONTINUE;\n\n\tif (status->flag & RX_FLAG_DECRYPTED) {\n\t\tif (!pskb_may_pull(rx->skb, hdrlen + IEEE80211_GCMP_HDR_LEN))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\tif (status->flag & RX_FLAG_MIC_STRIPPED)\n\t\t\tmic_len = 0;\n\t} else {\n\t\tif (skb_linearize(rx->skb))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t}\n\n\t \n\thdr = (void *)rx->skb->data;\n\n\tdata_len = skb->len - hdrlen - IEEE80211_GCMP_HDR_LEN - mic_len;\n\tif (!rx->sta || data_len < 0)\n\t\treturn RX_DROP_UNUSABLE;\n\n\tif (!(status->flag & RX_FLAG_PN_VALIDATED)) {\n\t\tint res;\n\n\t\tgcmp_hdr2pn(pn, skb->data + hdrlen);\n\n\t\tqueue = rx->security_idx;\n\n\t\tres = memcmp(pn, key->u.gcmp.rx_pn[queue],\n\t\t\t     IEEE80211_GCMP_PN_LEN);\n\t\tif (res < 0 ||\n\t\t    (!res && !(status->flag & RX_FLAG_ALLOW_SAME_PN))) {\n\t\t\tkey->u.gcmp.replays++;\n\t\t\treturn RX_DROP_U_REPLAY;\n\t\t}\n\n\t\tif (!(status->flag & RX_FLAG_DECRYPTED)) {\n\t\t\tu8 aad[2 * AES_BLOCK_SIZE];\n\t\t\tu8 j_0[AES_BLOCK_SIZE];\n\t\t\t \n\t\t\tgcmp_special_blocks(skb, pn, j_0, aad);\n\n\t\t\tif (ieee80211_aes_gcm_decrypt(\n\t\t\t\t    key->u.gcmp.tfm, j_0, aad,\n\t\t\t\t    skb->data + hdrlen + IEEE80211_GCMP_HDR_LEN,\n\t\t\t\t    data_len,\n\t\t\t\t    skb->data + skb->len -\n\t\t\t\t    IEEE80211_GCMP_MIC_LEN))\n\t\t\t\treturn RX_DROP_U_MIC_FAIL;\n\t\t}\n\n\t\tmemcpy(key->u.gcmp.rx_pn[queue], pn, IEEE80211_GCMP_PN_LEN);\n\t\tif (unlikely(ieee80211_is_frag(hdr)))\n\t\t\tmemcpy(rx->ccm_gcm.pn, pn, IEEE80211_CCMP_PN_LEN);\n\t}\n\n\t \n\tif (pskb_trim(skb, skb->len - mic_len))\n\t\treturn RX_DROP_UNUSABLE;\n\tmemmove(skb->data + IEEE80211_GCMP_HDR_LEN, skb->data, hdrlen);\n\tskb_pull(skb, IEEE80211_GCMP_HDR_LEN);\n\n\treturn RX_CONTINUE;\n}\n\nstatic void bip_aad(struct sk_buff *skb, u8 *aad)\n{\n\t__le16 mask_fc;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\n\t \n\n\t \n\t \n\tmask_fc = hdr->frame_control;\n\tmask_fc &= ~cpu_to_le16(IEEE80211_FCTL_RETRY | IEEE80211_FCTL_PM |\n\t\t\t\tIEEE80211_FCTL_MOREDATA);\n\tput_unaligned(mask_fc, (__le16 *) &aad[0]);\n\t \n\tmemcpy(aad + 2, &hdr->addrs, 3 * ETH_ALEN);\n}\n\n\nstatic inline void bip_ipn_set64(u8 *d, u64 pn)\n{\n\t*d++ = pn;\n\t*d++ = pn >> 8;\n\t*d++ = pn >> 16;\n\t*d++ = pn >> 24;\n\t*d++ = pn >> 32;\n\t*d = pn >> 40;\n}\n\nstatic inline void bip_ipn_swap(u8 *d, const u8 *s)\n{\n\t*d++ = s[5];\n\t*d++ = s[4];\n\t*d++ = s[3];\n\t*d++ = s[2];\n\t*d++ = s[1];\n\t*d = s[0];\n}\n\n\nieee80211_tx_result\nieee80211_crypto_aes_cmac_encrypt(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_key *key = tx->key;\n\tstruct ieee80211_mmie *mmie;\n\tu8 aad[20];\n\tu64 pn64;\n\n\tif (WARN_ON(skb_queue_len(&tx->skbs) != 1))\n\t\treturn TX_DROP;\n\n\tskb = skb_peek(&tx->skbs);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tif (info->control.hw_key &&\n\t    !(key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_MMIE))\n\t\treturn TX_CONTINUE;\n\n\tif (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))\n\t\treturn TX_DROP;\n\n\tmmie = skb_put(skb, sizeof(*mmie));\n\tmmie->element_id = WLAN_EID_MMIE;\n\tmmie->length = sizeof(*mmie) - 2;\n\tmmie->key_id = cpu_to_le16(key->conf.keyidx);\n\n\t \n\tpn64 = atomic64_inc_return(&key->conf.tx_pn);\n\n\tbip_ipn_set64(mmie->sequence_number, pn64);\n\n\tif (info->control.hw_key)\n\t\treturn TX_CONTINUE;\n\n\tbip_aad(skb, aad);\n\n\t \n\tieee80211_aes_cmac(key->u.aes_cmac.tfm, aad,\n\t\t\t   skb->data + 24, skb->len - 24, mmie->mic);\n\n\treturn TX_CONTINUE;\n}\n\nieee80211_tx_result\nieee80211_crypto_aes_cmac_256_encrypt(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_key *key = tx->key;\n\tstruct ieee80211_mmie_16 *mmie;\n\tu8 aad[20];\n\tu64 pn64;\n\n\tif (WARN_ON(skb_queue_len(&tx->skbs) != 1))\n\t\treturn TX_DROP;\n\n\tskb = skb_peek(&tx->skbs);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tif (info->control.hw_key)\n\t\treturn TX_CONTINUE;\n\n\tif (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))\n\t\treturn TX_DROP;\n\n\tmmie = skb_put(skb, sizeof(*mmie));\n\tmmie->element_id = WLAN_EID_MMIE;\n\tmmie->length = sizeof(*mmie) - 2;\n\tmmie->key_id = cpu_to_le16(key->conf.keyidx);\n\n\t \n\tpn64 = atomic64_inc_return(&key->conf.tx_pn);\n\n\tbip_ipn_set64(mmie->sequence_number, pn64);\n\n\tbip_aad(skb, aad);\n\n\t \n\tieee80211_aes_cmac_256(key->u.aes_cmac.tfm, aad,\n\t\t\t       skb->data + 24, skb->len - 24, mmie->mic);\n\n\treturn TX_CONTINUE;\n}\n\nieee80211_rx_result\nieee80211_crypto_aes_cmac_decrypt(struct ieee80211_rx_data *rx)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_key *key = rx->key;\n\tstruct ieee80211_mmie *mmie;\n\tu8 aad[20], mic[8], ipn[6];\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (!ieee80211_is_mgmt(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t \n\n\tif (skb->len < 24 + sizeof(*mmie))\n\t\treturn RX_DROP_UNUSABLE;\n\n\tmmie = (struct ieee80211_mmie *)\n\t\t(skb->data + skb->len - sizeof(*mmie));\n\tif (mmie->element_id != WLAN_EID_MMIE ||\n\t    mmie->length != sizeof(*mmie) - 2)\n\t\treturn RX_DROP_U_BAD_MMIE;  \n\n\tbip_ipn_swap(ipn, mmie->sequence_number);\n\n\tif (memcmp(ipn, key->u.aes_cmac.rx_pn, 6) <= 0) {\n\t\tkey->u.aes_cmac.replays++;\n\t\treturn RX_DROP_U_REPLAY;\n\t}\n\n\tif (!(status->flag & RX_FLAG_DECRYPTED)) {\n\t\t \n\t\tbip_aad(skb, aad);\n\t\tieee80211_aes_cmac(key->u.aes_cmac.tfm, aad,\n\t\t\t\t   skb->data + 24, skb->len - 24, mic);\n\t\tif (crypto_memneq(mic, mmie->mic, sizeof(mmie->mic))) {\n\t\t\tkey->u.aes_cmac.icverrors++;\n\t\t\treturn RX_DROP_U_MIC_FAIL;\n\t\t}\n\t}\n\n\tmemcpy(key->u.aes_cmac.rx_pn, ipn, 6);\n\n\t \n\tskb_trim(skb, skb->len - sizeof(*mmie));\n\n\treturn RX_CONTINUE;\n}\n\nieee80211_rx_result\nieee80211_crypto_aes_cmac_256_decrypt(struct ieee80211_rx_data *rx)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_key *key = rx->key;\n\tstruct ieee80211_mmie_16 *mmie;\n\tu8 aad[20], mic[16], ipn[6];\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\n\tif (!ieee80211_is_mgmt(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t \n\n\tif (skb->len < 24 + sizeof(*mmie))\n\t\treturn RX_DROP_UNUSABLE;\n\n\tmmie = (struct ieee80211_mmie_16 *)\n\t\t(skb->data + skb->len - sizeof(*mmie));\n\tif (mmie->element_id != WLAN_EID_MMIE ||\n\t    mmie->length != sizeof(*mmie) - 2)\n\t\treturn RX_DROP_UNUSABLE;  \n\n\tbip_ipn_swap(ipn, mmie->sequence_number);\n\n\tif (memcmp(ipn, key->u.aes_cmac.rx_pn, 6) <= 0) {\n\t\tkey->u.aes_cmac.replays++;\n\t\treturn RX_DROP_U_REPLAY;\n\t}\n\n\tif (!(status->flag & RX_FLAG_DECRYPTED)) {\n\t\t \n\t\tbip_aad(skb, aad);\n\t\tieee80211_aes_cmac_256(key->u.aes_cmac.tfm, aad,\n\t\t\t\t       skb->data + 24, skb->len - 24, mic);\n\t\tif (crypto_memneq(mic, mmie->mic, sizeof(mmie->mic))) {\n\t\t\tkey->u.aes_cmac.icverrors++;\n\t\t\treturn RX_DROP_U_MIC_FAIL;\n\t\t}\n\t}\n\n\tmemcpy(key->u.aes_cmac.rx_pn, ipn, 6);\n\n\t \n\tskb_trim(skb, skb->len - sizeof(*mmie));\n\n\treturn RX_CONTINUE;\n}\n\nieee80211_tx_result\nieee80211_crypto_aes_gmac_encrypt(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_key *key = tx->key;\n\tstruct ieee80211_mmie_16 *mmie;\n\tstruct ieee80211_hdr *hdr;\n\tu8 aad[GMAC_AAD_LEN];\n\tu64 pn64;\n\tu8 nonce[GMAC_NONCE_LEN];\n\n\tif (WARN_ON(skb_queue_len(&tx->skbs) != 1))\n\t\treturn TX_DROP;\n\n\tskb = skb_peek(&tx->skbs);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tif (info->control.hw_key)\n\t\treturn TX_CONTINUE;\n\n\tif (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))\n\t\treturn TX_DROP;\n\n\tmmie = skb_put(skb, sizeof(*mmie));\n\tmmie->element_id = WLAN_EID_MMIE;\n\tmmie->length = sizeof(*mmie) - 2;\n\tmmie->key_id = cpu_to_le16(key->conf.keyidx);\n\n\t \n\tpn64 = atomic64_inc_return(&key->conf.tx_pn);\n\n\tbip_ipn_set64(mmie->sequence_number, pn64);\n\n\tbip_aad(skb, aad);\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tmemcpy(nonce, hdr->addr2, ETH_ALEN);\n\tbip_ipn_swap(nonce + ETH_ALEN, mmie->sequence_number);\n\n\t \n\tif (ieee80211_aes_gmac(key->u.aes_gmac.tfm, aad, nonce,\n\t\t\t       skb->data + 24, skb->len - 24, mmie->mic) < 0)\n\t\treturn TX_DROP;\n\n\treturn TX_CONTINUE;\n}\n\nieee80211_rx_result\nieee80211_crypto_aes_gmac_decrypt(struct ieee80211_rx_data *rx)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_key *key = rx->key;\n\tstruct ieee80211_mmie_16 *mmie;\n\tu8 aad[GMAC_AAD_LEN], *mic, ipn[6], nonce[GMAC_NONCE_LEN];\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\n\tif (!ieee80211_is_mgmt(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t \n\n\tif (skb->len < 24 + sizeof(*mmie))\n\t\treturn RX_DROP_UNUSABLE;\n\n\tmmie = (struct ieee80211_mmie_16 *)\n\t\t(skb->data + skb->len - sizeof(*mmie));\n\tif (mmie->element_id != WLAN_EID_MMIE ||\n\t    mmie->length != sizeof(*mmie) - 2)\n\t\treturn RX_DROP_U_BAD_MMIE;  \n\n\tbip_ipn_swap(ipn, mmie->sequence_number);\n\n\tif (memcmp(ipn, key->u.aes_gmac.rx_pn, 6) <= 0) {\n\t\tkey->u.aes_gmac.replays++;\n\t\treturn RX_DROP_U_REPLAY;\n\t}\n\n\tif (!(status->flag & RX_FLAG_DECRYPTED)) {\n\t\t \n\t\tbip_aad(skb, aad);\n\n\t\tmemcpy(nonce, hdr->addr2, ETH_ALEN);\n\t\tmemcpy(nonce + ETH_ALEN, ipn, 6);\n\n\t\tmic = kmalloc(GMAC_MIC_LEN, GFP_ATOMIC);\n\t\tif (!mic)\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\tif (ieee80211_aes_gmac(key->u.aes_gmac.tfm, aad, nonce,\n\t\t\t\t       skb->data + 24, skb->len - 24,\n\t\t\t\t       mic) < 0 ||\n\t\t    crypto_memneq(mic, mmie->mic, sizeof(mmie->mic))) {\n\t\t\tkey->u.aes_gmac.icverrors++;\n\t\t\tkfree(mic);\n\t\t\treturn RX_DROP_U_MIC_FAIL;\n\t\t}\n\t\tkfree(mic);\n\t}\n\n\tmemcpy(key->u.aes_gmac.rx_pn, ipn, 6);\n\n\t \n\tskb_trim(skb, skb->len - sizeof(*mmie));\n\n\treturn RX_CONTINUE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}