{
  "module_name": "mesh.c",
  "hash_id": "4b4cabdf828c9ae3716a881903e68c6ddd510c1ebebcfdcc7a9d5c02f7e9750a",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/mesh.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include \"ieee80211_i.h\"\n#include \"mesh.h\"\n#include \"wme.h\"\n#include \"driver-ops.h\"\n\nstatic int mesh_allocated;\nstatic struct kmem_cache *rm_cache;\n\nbool mesh_action_is_path_sel(struct ieee80211_mgmt *mgmt)\n{\n\treturn (mgmt->u.action.u.mesh_action.action_code ==\n\t\t\tWLAN_MESH_ACTION_HWMP_PATH_SELECTION);\n}\n\nvoid ieee80211s_init(void)\n{\n\tmesh_allocated = 1;\n\trm_cache = kmem_cache_create(\"mesh_rmc\", sizeof(struct rmc_entry),\n\t\t\t\t     0, 0, NULL);\n}\n\nvoid ieee80211s_stop(void)\n{\n\tif (!mesh_allocated)\n\t\treturn;\n\tkmem_cache_destroy(rm_cache);\n}\n\nstatic void ieee80211_mesh_housekeeping_timer(struct timer_list *t)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tfrom_timer(sdata, t, u.mesh.housekeeping_timer);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\tset_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags);\n\n\twiphy_work_queue(local->hw.wiphy, &sdata->work);\n}\n\n \nbool mesh_matches_local(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct ieee802_11_elems *ie)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tu32 basic_rates = 0;\n\tstruct cfg80211_chan_def sta_chan_def;\n\tstruct ieee80211_supported_band *sband;\n\tu32 vht_cap_info = 0;\n\n\t \n\tif (!(ifmsh->mesh_id_len == ie->mesh_id_len &&\n\t     memcmp(ifmsh->mesh_id, ie->mesh_id, ie->mesh_id_len) == 0 &&\n\t     (ifmsh->mesh_pp_id == ie->mesh_config->meshconf_psel) &&\n\t     (ifmsh->mesh_pm_id == ie->mesh_config->meshconf_pmetric) &&\n\t     (ifmsh->mesh_cc_id == ie->mesh_config->meshconf_congest) &&\n\t     (ifmsh->mesh_sp_id == ie->mesh_config->meshconf_synch) &&\n\t     (ifmsh->mesh_auth_id == ie->mesh_config->meshconf_auth)))\n\t\treturn false;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn false;\n\n\tieee80211_sta_get_rates(sdata, ie, sband->band,\n\t\t\t\t&basic_rates);\n\n\tif (sdata->vif.bss_conf.basic_rates != basic_rates)\n\t\treturn false;\n\n\tcfg80211_chandef_create(&sta_chan_def, sdata->vif.bss_conf.chandef.chan,\n\t\t\t\tNL80211_CHAN_NO_HT);\n\tieee80211_chandef_ht_oper(ie->ht_operation, &sta_chan_def);\n\n\tif (ie->vht_cap_elem)\n\t\tvht_cap_info = le32_to_cpu(ie->vht_cap_elem->vht_cap_info);\n\n\tieee80211_chandef_vht_oper(&sdata->local->hw, vht_cap_info,\n\t\t\t\t   ie->vht_operation, ie->ht_operation,\n\t\t\t\t   &sta_chan_def);\n\tieee80211_chandef_he_6ghz_oper(sdata, ie->he_operation, ie->eht_operation,\n\t\t\t\t       &sta_chan_def);\n\n\tif (!cfg80211_chandef_compatible(&sdata->vif.bss_conf.chandef,\n\t\t\t\t\t &sta_chan_def))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nbool mesh_peer_accepts_plinks(struct ieee802_11_elems *ie)\n{\n\treturn (ie->mesh_config->meshconf_cap &\n\t\t\tIEEE80211_MESHCONF_CAPAB_ACCEPT_PLINKS) != 0;\n}\n\n \nu64 mesh_accept_plinks_update(struct ieee80211_sub_if_data *sdata)\n{\n\tbool free_plinks;\n\tu64 changed = 0;\n\n\t \n\tfree_plinks = mesh_plink_availables(sdata);\n\n\tif (free_plinks != sdata->u.mesh.accepting_plinks) {\n\t\tsdata->u.mesh.accepting_plinks = free_plinks;\n\t\tchanged = BSS_CHANGED_BEACON;\n\t}\n\n\treturn changed;\n}\n\n \nvoid mesh_sta_cleanup(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tu64 changed = mesh_plink_deactivate(sta);\n\n\tif (changed)\n\t\tieee80211_mbss_info_change_notify(sdata, changed);\n}\n\nint mesh_rmc_init(struct ieee80211_sub_if_data *sdata)\n{\n\tint i;\n\n\tsdata->u.mesh.rmc = kmalloc(sizeof(struct mesh_rmc), GFP_KERNEL);\n\tif (!sdata->u.mesh.rmc)\n\t\treturn -ENOMEM;\n\tsdata->u.mesh.rmc->idx_mask = RMC_BUCKETS - 1;\n\tfor (i = 0; i < RMC_BUCKETS; i++)\n\t\tINIT_HLIST_HEAD(&sdata->u.mesh.rmc->bucket[i]);\n\treturn 0;\n}\n\nvoid mesh_rmc_free(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct mesh_rmc *rmc = sdata->u.mesh.rmc;\n\tstruct rmc_entry *p;\n\tstruct hlist_node *n;\n\tint i;\n\n\tif (!sdata->u.mesh.rmc)\n\t\treturn;\n\n\tfor (i = 0; i < RMC_BUCKETS; i++) {\n\t\thlist_for_each_entry_safe(p, n, &rmc->bucket[i], list) {\n\t\t\thlist_del(&p->list);\n\t\t\tkmem_cache_free(rm_cache, p);\n\t\t}\n\t}\n\n\tkfree(rmc);\n\tsdata->u.mesh.rmc = NULL;\n}\n\n \nint mesh_rmc_check(struct ieee80211_sub_if_data *sdata,\n\t\t   const u8 *sa, struct ieee80211s_hdr *mesh_hdr)\n{\n\tstruct mesh_rmc *rmc = sdata->u.mesh.rmc;\n\tu32 seqnum = 0;\n\tint entries = 0;\n\tu8 idx;\n\tstruct rmc_entry *p;\n\tstruct hlist_node *n;\n\n\tif (!rmc)\n\t\treturn -1;\n\n\t \n\tmemcpy(&seqnum, &mesh_hdr->seqnum, sizeof(mesh_hdr->seqnum));\n\tidx = le32_to_cpu(mesh_hdr->seqnum) & rmc->idx_mask;\n\thlist_for_each_entry_safe(p, n, &rmc->bucket[idx], list) {\n\t\t++entries;\n\t\tif (time_after(jiffies, p->exp_time) ||\n\t\t    entries == RMC_QUEUE_MAX_LEN) {\n\t\t\thlist_del(&p->list);\n\t\t\tkmem_cache_free(rm_cache, p);\n\t\t\t--entries;\n\t\t} else if ((seqnum == p->seqnum) && ether_addr_equal(sa, p->sa))\n\t\t\treturn -1;\n\t}\n\n\tp = kmem_cache_alloc(rm_cache, GFP_ATOMIC);\n\tif (!p)\n\t\treturn 0;\n\n\tp->seqnum = seqnum;\n\tp->exp_time = jiffies + RMC_TIMEOUT;\n\tmemcpy(p->sa, sa, ETH_ALEN);\n\thlist_add_head(&p->list, &rmc->bucket[idx]);\n\treturn 0;\n}\n\nint mesh_add_meshconf_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tu8 *pos, neighbors;\n\tu8 meshconf_len = sizeof(struct ieee80211_meshconf_ie);\n\tbool is_connected_to_gate = ifmsh->num_gates > 0 ||\n\t\tifmsh->mshcfg.dot11MeshGateAnnouncementProtocol ||\n\t\tifmsh->mshcfg.dot11MeshConnectedToMeshGate;\n\tbool is_connected_to_as = ifmsh->mshcfg.dot11MeshConnectedToAuthServer;\n\n\tif (skb_tailroom(skb) < 2 + meshconf_len)\n\t\treturn -ENOMEM;\n\n\tpos = skb_put(skb, 2 + meshconf_len);\n\t*pos++ = WLAN_EID_MESH_CONFIG;\n\t*pos++ = meshconf_len;\n\n\t \n\tifmsh->meshconf_offset = pos - skb->data;\n\n\t \n\t*pos++ = ifmsh->mesh_pp_id;\n\t \n\t*pos++ = ifmsh->mesh_pm_id;\n\t \n\t*pos++ = ifmsh->mesh_cc_id;\n\t \n\t*pos++ = ifmsh->mesh_sp_id;\n\t \n\t*pos++ = ifmsh->mesh_auth_id;\n\t \n\tneighbors = atomic_read(&ifmsh->estab_plinks);\n\tneighbors = min_t(int, neighbors, IEEE80211_MAX_MESH_PEERINGS);\n\t*pos++ = (is_connected_to_as << 7) |\n\t\t (neighbors << 1) |\n\t\t is_connected_to_gate;\n\t \n\t*pos = 0x00;\n\t*pos |= ifmsh->mshcfg.dot11MeshForwarding ?\n\t\t\tIEEE80211_MESHCONF_CAPAB_FORWARDING : 0x00;\n\t*pos |= ifmsh->accepting_plinks ?\n\t\t\tIEEE80211_MESHCONF_CAPAB_ACCEPT_PLINKS : 0x00;\n\t \n\t*pos |= ifmsh->ps_peers_deep_sleep ?\n\t\t\tIEEE80211_MESHCONF_CAPAB_POWER_SAVE_LEVEL : 0x00;\n\treturn 0;\n}\n\nint mesh_add_meshid_ie(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tu8 *pos;\n\n\tif (skb_tailroom(skb) < 2 + ifmsh->mesh_id_len)\n\t\treturn -ENOMEM;\n\n\tpos = skb_put(skb, 2 + ifmsh->mesh_id_len);\n\t*pos++ = WLAN_EID_MESH_ID;\n\t*pos++ = ifmsh->mesh_id_len;\n\tif (ifmsh->mesh_id_len)\n\t\tmemcpy(pos, ifmsh->mesh_id, ifmsh->mesh_id_len);\n\n\treturn 0;\n}\n\nstatic int mesh_add_awake_window_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tu8 *pos;\n\n\t \n\tif (ifmsh->ps_peers_light_sleep == 0 &&\n\t    ifmsh->ps_peers_deep_sleep == 0 &&\n\t    ifmsh->nonpeer_pm == NL80211_MESH_POWER_ACTIVE)\n\t\treturn 0;\n\n\tif (skb_tailroom(skb) < 4)\n\t\treturn -ENOMEM;\n\n\tpos = skb_put(skb, 2 + 2);\n\t*pos++ = WLAN_EID_MESH_AWAKE_WINDOW;\n\t*pos++ = 2;\n\tput_unaligned_le16(ifmsh->mshcfg.dot11MeshAwakeWindowDuration, pos);\n\n\treturn 0;\n}\n\nint mesh_add_vendor_ies(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tu8 offset, len;\n\tconst u8 *data;\n\n\tif (!ifmsh->ie || !ifmsh->ie_len)\n\t\treturn 0;\n\n\t \n\toffset = ieee80211_ie_split_vendor(ifmsh->ie, ifmsh->ie_len, 0);\n\n\tif (offset < ifmsh->ie_len) {\n\t\tlen = ifmsh->ie_len - offset;\n\t\tdata = ifmsh->ie + offset;\n\t\tif (skb_tailroom(skb) < len)\n\t\t\treturn -ENOMEM;\n\t\tskb_put_data(skb, data, len);\n\t}\n\n\treturn 0;\n}\n\nint mesh_add_rsn_ie(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tu8 len = 0;\n\tconst u8 *data;\n\n\tif (!ifmsh->ie || !ifmsh->ie_len)\n\t\treturn 0;\n\n\t \n\tdata = cfg80211_find_ie(WLAN_EID_RSN, ifmsh->ie, ifmsh->ie_len);\n\tif (!data)\n\t\treturn 0;\n\n\tlen = data[1] + 2;\n\n\tif (skb_tailroom(skb) < len)\n\t\treturn -ENOMEM;\n\tskb_put_data(skb, data, len);\n\n\treturn 0;\n}\n\nstatic int mesh_add_ds_params_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_channel *chan;\n\tu8 *pos;\n\n\tif (skb_tailroom(skb) < 3)\n\t\treturn -ENOMEM;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tif (WARN_ON(!chanctx_conf)) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\tchan = chanctx_conf->def.chan;\n\trcu_read_unlock();\n\n\tpos = skb_put(skb, 2 + 1);\n\t*pos++ = WLAN_EID_DS_PARAMS;\n\t*pos++ = 1;\n\t*pos++ = ieee80211_frequency_to_channel(chan->center_freq);\n\n\treturn 0;\n}\n\nint mesh_add_ht_cap_ie(struct ieee80211_sub_if_data *sdata,\n\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_supported_band *sband;\n\tu8 *pos;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn -EINVAL;\n\n\t \n\tif (sband->band == NL80211_BAND_6GHZ)\n\t\treturn 0;\n\n\tif (!sband->ht_cap.ht_supported ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\n\t\treturn 0;\n\n\tif (skb_tailroom(skb) < 2 + sizeof(struct ieee80211_ht_cap))\n\t\treturn -ENOMEM;\n\n\tpos = skb_put(skb, 2 + sizeof(struct ieee80211_ht_cap));\n\tieee80211_ie_build_ht_cap(pos, &sband->ht_cap, sband->ht_cap.cap);\n\n\treturn 0;\n}\n\nint mesh_add_ht_oper_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_channel *channel;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_sta_ht_cap *ht_cap;\n\tu8 *pos;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tif (WARN_ON(!chanctx_conf)) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\tchannel = chanctx_conf->def.chan;\n\trcu_read_unlock();\n\n\tsband = local->hw.wiphy->bands[channel->band];\n\tht_cap = &sband->ht_cap;\n\n\t \n\tif (sband->band == NL80211_BAND_6GHZ)\n\t\treturn 0;\n\n\tif (!ht_cap->ht_supported ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\n\t\treturn 0;\n\n\tif (skb_tailroom(skb) < 2 + sizeof(struct ieee80211_ht_operation))\n\t\treturn -ENOMEM;\n\n\tpos = skb_put(skb, 2 + sizeof(struct ieee80211_ht_operation));\n\tieee80211_ie_build_ht_oper(pos, ht_cap, &sdata->vif.bss_conf.chandef,\n\t\t\t\t   sdata->vif.bss_conf.ht_operation_mode,\n\t\t\t\t   false);\n\n\treturn 0;\n}\n\nint mesh_add_vht_cap_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_supported_band *sband;\n\tu8 *pos;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn -EINVAL;\n\n\t \n\tif (sband->band == NL80211_BAND_6GHZ)\n\t\treturn 0;\n\n\tif (!sband->vht_cap.vht_supported ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\n\t\treturn 0;\n\n\tif (skb_tailroom(skb) < 2 + sizeof(struct ieee80211_vht_cap))\n\t\treturn -ENOMEM;\n\n\tpos = skb_put(skb, 2 + sizeof(struct ieee80211_vht_cap));\n\tieee80211_ie_build_vht_cap(pos, &sband->vht_cap, sband->vht_cap.cap);\n\n\treturn 0;\n}\n\nint mesh_add_vht_oper_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_channel *channel;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_sta_vht_cap *vht_cap;\n\tu8 *pos;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tif (WARN_ON(!chanctx_conf)) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\tchannel = chanctx_conf->def.chan;\n\trcu_read_unlock();\n\n\tsband = local->hw.wiphy->bands[channel->band];\n\tvht_cap = &sband->vht_cap;\n\n\t \n\tif (sband->band == NL80211_BAND_6GHZ)\n\t\treturn 0;\n\n\tif (!vht_cap->vht_supported ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\n\t\treturn 0;\n\n\tif (skb_tailroom(skb) < 2 + sizeof(struct ieee80211_vht_operation))\n\t\treturn -ENOMEM;\n\n\tpos = skb_put(skb, 2 + sizeof(struct ieee80211_vht_operation));\n\tieee80211_ie_build_vht_oper(pos, vht_cap,\n\t\t\t\t    &sdata->vif.bss_conf.chandef);\n\n\treturn 0;\n}\n\nint mesh_add_he_cap_ie(struct ieee80211_sub_if_data *sdata,\n\t\t       struct sk_buff *skb, u8 ie_len)\n{\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tstruct ieee80211_supported_band *sband;\n\tu8 *pos;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn -EINVAL;\n\n\the_cap = ieee80211_get_he_iftype_cap(sband, NL80211_IFTYPE_MESH_POINT);\n\n\tif (!he_cap ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\n\t\treturn 0;\n\n\tif (skb_tailroom(skb) < ie_len)\n\t\treturn -ENOMEM;\n\n\tpos = skb_put(skb, ie_len);\n\tieee80211_ie_build_he_cap(0, pos, he_cap, pos + ie_len);\n\n\treturn 0;\n}\n\nint mesh_add_he_oper_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb)\n{\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tstruct ieee80211_supported_band *sband;\n\tu32 len;\n\tu8 *pos;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn -EINVAL;\n\n\the_cap = ieee80211_get_he_iftype_cap(sband, NL80211_IFTYPE_MESH_POINT);\n\tif (!he_cap ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\n\t\treturn 0;\n\n\tlen = 2 + 1 + sizeof(struct ieee80211_he_operation);\n\tif (sdata->vif.bss_conf.chandef.chan->band == NL80211_BAND_6GHZ)\n\t\tlen += sizeof(struct ieee80211_he_6ghz_oper);\n\n\tif (skb_tailroom(skb) < len)\n\t\treturn -ENOMEM;\n\n\tpos = skb_put(skb, len);\n\tieee80211_ie_build_he_oper(pos, &sdata->vif.bss_conf.chandef);\n\n\treturn 0;\n}\n\nint mesh_add_he_6ghz_cap_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct ieee80211_supported_band *sband;\n\tconst struct ieee80211_sband_iftype_data *iftd;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn -EINVAL;\n\n\tiftd = ieee80211_get_sband_iftype_data(sband,\n\t\t\t\t\t       NL80211_IFTYPE_MESH_POINT);\n\t \n\tif (!iftd)\n\t\treturn 0;\n\n\tieee80211_ie_build_he_6ghz_cap(sdata, sdata->deflink.smps_mode, skb);\n\treturn 0;\n}\n\nint mesh_add_eht_cap_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb, u8 ie_len)\n{\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tconst struct ieee80211_sta_eht_cap *eht_cap;\n\tstruct ieee80211_supported_band *sband;\n\tu8 *pos;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn -EINVAL;\n\n\the_cap = ieee80211_get_he_iftype_cap(sband, NL80211_IFTYPE_MESH_POINT);\n\teht_cap = ieee80211_get_eht_iftype_cap(sband, NL80211_IFTYPE_MESH_POINT);\n\tif (!he_cap || !eht_cap ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\n\t\treturn 0;\n\n\tif (skb_tailroom(skb) < ie_len)\n\t\treturn -ENOMEM;\n\n\tpos = skb_put(skb, ie_len);\n\tieee80211_ie_build_eht_cap(pos, he_cap, eht_cap, pos + ie_len, false);\n\n\treturn 0;\n}\n\nint mesh_add_eht_oper_ie(struct ieee80211_sub_if_data *sdata, struct sk_buff *skb)\n{\n\tconst struct ieee80211_sta_eht_cap *eht_cap;\n\tstruct ieee80211_supported_band *sband;\n\tu32 len;\n\tu8 *pos;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn -EINVAL;\n\n\teht_cap = ieee80211_get_eht_iftype_cap(sband, NL80211_IFTYPE_MESH_POINT);\n\tif (!eht_cap ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\n\t\treturn 0;\n\n\tlen = 2 + 1 + offsetof(struct ieee80211_eht_operation, optional) +\n\t\t      offsetof(struct ieee80211_eht_operation_info, optional);\n\n\tif (skb_tailroom(skb) < len)\n\t\treturn -ENOMEM;\n\n\tpos = skb_put(skb, len);\n\tieee80211_ie_build_eht_oper(pos, &sdata->vif.bss_conf.chandef, eht_cap);\n\n\treturn 0;\n}\n\nstatic void ieee80211_mesh_path_timer(struct timer_list *t)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tfrom_timer(sdata, t, u.mesh.mesh_path_timer);\n\n\twiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);\n}\n\nstatic void ieee80211_mesh_path_root_timer(struct timer_list *t)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tfrom_timer(sdata, t, u.mesh.mesh_path_root_timer);\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\tset_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);\n\n\twiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);\n}\n\nvoid ieee80211_mesh_root_setup(struct ieee80211_if_mesh *ifmsh)\n{\n\tif (ifmsh->mshcfg.dot11MeshHWMPRootMode > IEEE80211_ROOTMODE_ROOT)\n\t\tset_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);\n\telse {\n\t\tclear_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags);\n\t\t \n\t\tdel_timer_sync(&ifmsh->mesh_path_root_timer);\n\t}\n}\n\nstatic void\nieee80211_mesh_update_bss_params(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t u8 *ie, u8 ie_len)\n{\n\tstruct ieee80211_supported_band *sband;\n\tconst struct element *cap;\n\tconst struct ieee80211_he_operation *he_oper = NULL;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn;\n\n\tif (!ieee80211_get_he_iftype_cap(sband, NL80211_IFTYPE_MESH_POINT) ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_5 ||\n\t    sdata->vif.bss_conf.chandef.width == NL80211_CHAN_WIDTH_10)\n\t\treturn;\n\n\tsdata->vif.bss_conf.he_support = true;\n\n\tcap = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_OPERATION, ie, ie_len);\n\tif (cap && cap->datalen >= 1 + sizeof(*he_oper) &&\n\t    cap->datalen >= 1 + ieee80211_he_oper_size(cap->data + 1))\n\t\the_oper = (void *)(cap->data + 1);\n\n\tif (he_oper)\n\t\tsdata->vif.bss_conf.he_oper.params =\n\t\t\t__le32_to_cpu(he_oper->he_oper_params);\n\n\tsdata->vif.bss_conf.eht_support =\n\t\t!!ieee80211_get_eht_iftype_cap(sband, NL80211_IFTYPE_MESH_POINT);\n}\n\nbool ieee80211_mesh_xmit_fast(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct sk_buff *skb, u32 ctrl_flags)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct ieee80211_mesh_fast_tx *entry;\n\tstruct ieee80211s_hdr *meshhdr;\n\tu8 sa[ETH_ALEN] __aligned(2);\n\tstruct tid_ampdu_tx *tid_tx;\n\tstruct sta_info *sta;\n\tbool copy_sa = false;\n\tu16 ethertype;\n\tu8 tid;\n\n\tif (ctrl_flags & IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP)\n\t\treturn false;\n\n\tif (ifmsh->mshcfg.dot11MeshNolearn)\n\t\treturn false;\n\n\t \n\tif (ifmsh->ps_peers_light_sleep || ifmsh->ps_peers_deep_sleep)\n\t\treturn false;\n\n\tif (is_multicast_ether_addr(skb->data))\n\t\treturn false;\n\n\tethertype = (skb->data[12] << 8) | skb->data[13];\n\tif (ethertype < ETH_P_802_3_MIN)\n\t\treturn false;\n\n\tif (skb->sk && skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS)\n\t\treturn false;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tskb_set_transport_header(skb, skb_checksum_start_offset(skb));\n\t\tif (skb_checksum_help(skb))\n\t\t\treturn false;\n\t}\n\n\tentry = mesh_fast_tx_get(sdata, skb->data);\n\tif (!entry)\n\t\treturn false;\n\n\tif (skb_headroom(skb) < entry->hdrlen + entry->fast_tx.hdr_len)\n\t\treturn false;\n\n\tsta = rcu_dereference(entry->mpath->next_hop);\n\tif (!sta)\n\t\treturn false;\n\n\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\ttid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\n\tif (tid_tx) {\n\t\tif (!test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state))\n\t\t\treturn false;\n\t\tif (tid_tx->timeout)\n\t\t\ttid_tx->last_tx = jiffies;\n\t}\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn true;\n\n\tskb_set_queue_mapping(skb, ieee80211_select_queue(sdata, sta, skb));\n\n\tmeshhdr = (struct ieee80211s_hdr *)entry->hdr;\n\tif ((meshhdr->flags & MESH_FLAGS_AE) == MESH_FLAGS_AE_A5_A6) {\n\t\t \n\t\tether_addr_copy(sa, skb->data + ETH_ALEN);\n\t\tcopy_sa = true;\n\t}\n\n\tmemcpy(skb_push(skb, entry->hdrlen - 2 * ETH_ALEN), entry->hdr,\n\t       entry->hdrlen);\n\n\tmeshhdr = (struct ieee80211s_hdr *)skb->data;\n\tput_unaligned_le32(atomic_inc_return(&sdata->u.mesh.mesh_seqnum),\n\t\t\t   &meshhdr->seqnum);\n\tmeshhdr->ttl = sdata->u.mesh.mshcfg.dot11MeshTTL;\n\tif (copy_sa)\n\t    ether_addr_copy(meshhdr->eaddr2, sa);\n\n\tskb_push(skb, 2 * ETH_ALEN);\n\t__ieee80211_xmit_fast(sdata, sta, &entry->fast_tx, skb, tid_tx,\n\t\t\t      entry->mpath->dst, sdata->vif.addr);\n\n\treturn true;\n}\n\n \nint ieee80211_fill_mesh_addresses(struct ieee80211_hdr *hdr, __le16 *fc,\n\t\t\t\t  const u8 *meshda, const u8 *meshsa)\n{\n\tif (is_multicast_ether_addr(meshda)) {\n\t\t*fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t \n\t\tmemcpy(hdr->addr1, meshda, ETH_ALEN);\n\t\tmemcpy(hdr->addr2, meshsa, ETH_ALEN);\n\t\tmemcpy(hdr->addr3, meshsa, ETH_ALEN);\n\t\treturn 24;\n\t} else {\n\t\t*fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS);\n\t\t \n\t\teth_zero_addr(hdr->addr1);    \n\t\tmemcpy(hdr->addr2, meshsa, ETH_ALEN);\n\t\tmemcpy(hdr->addr3, meshda, ETH_ALEN);\n\t\tmemcpy(hdr->addr4, meshsa, ETH_ALEN);\n\t\treturn 30;\n\t}\n}\n\n \nunsigned int ieee80211_new_mesh_header(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211s_hdr *meshhdr,\n\t\t\t\t       const char *addr4or5, const char *addr6)\n{\n\tif (WARN_ON(!addr4or5 && addr6))\n\t\treturn 0;\n\n\tmemset(meshhdr, 0, sizeof(*meshhdr));\n\n\tmeshhdr->ttl = sdata->u.mesh.mshcfg.dot11MeshTTL;\n\n\tput_unaligned_le32(atomic_inc_return(&sdata->u.mesh.mesh_seqnum),\n\t\t\t   &meshhdr->seqnum);\n\tif (addr4or5 && !addr6) {\n\t\tmeshhdr->flags |= MESH_FLAGS_AE_A4;\n\t\tmemcpy(meshhdr->eaddr1, addr4or5, ETH_ALEN);\n\t\treturn 2 * ETH_ALEN;\n\t} else if (addr4or5 && addr6) {\n\t\tmeshhdr->flags |= MESH_FLAGS_AE_A5_A6;\n\t\tmemcpy(meshhdr->eaddr1, addr4or5, ETH_ALEN);\n\t\tmemcpy(meshhdr->eaddr2, addr6, ETH_ALEN);\n\t\treturn 3 * ETH_ALEN;\n\t}\n\n\treturn ETH_ALEN;\n}\n\nstatic void ieee80211_mesh_housekeeping(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tu64 changed;\n\n\tif (ifmsh->mshcfg.plink_timeout > 0)\n\t\tieee80211_sta_expire(sdata, ifmsh->mshcfg.plink_timeout * HZ);\n\tmesh_path_expire(sdata);\n\n\tchanged = mesh_accept_plinks_update(sdata);\n\tieee80211_mbss_info_change_notify(sdata, changed);\n\n\tmesh_fast_tx_gc(sdata);\n\n\tmod_timer(&ifmsh->housekeeping_timer,\n\t\t  round_jiffies(jiffies +\n\t\t\t\tIEEE80211_MESH_HOUSEKEEPING_INTERVAL));\n}\n\nstatic void ieee80211_mesh_rootpath(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tu32 interval;\n\n\tmesh_path_tx_root_frame(sdata);\n\n\tif (ifmsh->mshcfg.dot11MeshHWMPRootMode == IEEE80211_PROACTIVE_RANN)\n\t\tinterval = ifmsh->mshcfg.dot11MeshHWMPRannInterval;\n\telse\n\t\tinterval = ifmsh->mshcfg.dot11MeshHWMProotInterval;\n\n\tmod_timer(&ifmsh->mesh_path_root_timer,\n\t\t  round_jiffies(TU_TO_EXP_TIME(interval)));\n}\n\nstatic int\nieee80211_mesh_build_beacon(struct ieee80211_if_mesh *ifmsh)\n{\n\tstruct beacon_data *bcn;\n\tint head_len, tail_len;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct mesh_csa_settings *csa;\n\tenum nl80211_band band;\n\tu8 ie_len_he_cap, ie_len_eht_cap;\n\tu8 *pos;\n\tstruct ieee80211_sub_if_data *sdata;\n\tint hdr_len = offsetofend(struct ieee80211_mgmt, u.beacon);\n\n\tsdata = container_of(ifmsh, struct ieee80211_sub_if_data, u.mesh);\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tband = chanctx_conf->def.chan->band;\n\trcu_read_unlock();\n\n\tie_len_he_cap = ieee80211_ie_len_he_cap(sdata,\n\t\t\t\t\t\tNL80211_IFTYPE_MESH_POINT);\n\tie_len_eht_cap = ieee80211_ie_len_eht_cap(sdata,\n\t\t\t\t\t\t  NL80211_IFTYPE_MESH_POINT);\n\thead_len = hdr_len +\n\t\t   2 +  \n\t\t    \n\t\t   2 + sizeof(struct ieee80211_channel_sw_ie) +\n\t\t    \n\t\t   2 + sizeof(struct ieee80211_mesh_chansw_params_ie) +\n\t\t    \n\t\t   2 + 2 + sizeof(struct ieee80211_wide_bw_chansw_ie) +\n\t\t   2 + sizeof(struct ieee80211_sec_chan_offs_ie) +\n\t\t   2 + 8 +  \n\t\t   2 + 3;  \n\ttail_len = 2 + (IEEE80211_MAX_SUPP_RATES - 8) +\n\t\t   2 + sizeof(struct ieee80211_ht_cap) +\n\t\t   2 + sizeof(struct ieee80211_ht_operation) +\n\t\t   2 + ifmsh->mesh_id_len +\n\t\t   2 + sizeof(struct ieee80211_meshconf_ie) +\n\t\t   2 + sizeof(__le16) +  \n\t\t   2 + sizeof(struct ieee80211_vht_cap) +\n\t\t   2 + sizeof(struct ieee80211_vht_operation) +\n\t\t   ie_len_he_cap +\n\t\t   2 + 1 + sizeof(struct ieee80211_he_operation) +\n\t\t\t   sizeof(struct ieee80211_he_6ghz_oper) +\n\t\t   2 + 1 + sizeof(struct ieee80211_he_6ghz_capa) +\n\t\t   ie_len_eht_cap +\n\t\t   2 + 1 + offsetof(struct ieee80211_eht_operation, optional) +\n\t\t\t   offsetof(struct ieee80211_eht_operation_info, optional) +\n\t\t   ifmsh->ie_len;\n\n\tbcn = kzalloc(sizeof(*bcn) + head_len + tail_len, GFP_KERNEL);\n\t \n\tskb = __dev_alloc_skb(max(head_len, tail_len), GFP_KERNEL);\n\n\tif (!bcn || !skb)\n\t\tgoto out_free;\n\n\t \n\tbcn->head = ((u8 *) bcn) + sizeof(*bcn);\n\n\t \n\tmgmt = skb_put_zero(skb, hdr_len);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_BEACON);\n\teth_broadcast_addr(mgmt->da);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\n\tieee80211_mps_set_frame_flags(sdata, NULL, (void *) mgmt);\n\tmgmt->u.beacon.beacon_int =\n\t\tcpu_to_le16(sdata->vif.bss_conf.beacon_int);\n\tmgmt->u.beacon.capab_info |= cpu_to_le16(\n\t\tsdata->u.mesh.security ? WLAN_CAPABILITY_PRIVACY : 0);\n\n\tpos = skb_put(skb, 2);\n\t*pos++ = WLAN_EID_SSID;\n\t*pos++ = 0x0;\n\n\trcu_read_lock();\n\tcsa = rcu_dereference(ifmsh->csa);\n\tif (csa) {\n\t\tenum nl80211_channel_type ct;\n\t\tstruct cfg80211_chan_def *chandef;\n\t\tint ie_len = 2 + sizeof(struct ieee80211_channel_sw_ie) +\n\t\t\t     2 + sizeof(struct ieee80211_mesh_chansw_params_ie);\n\n\t\tpos = skb_put_zero(skb, ie_len);\n\t\t*pos++ = WLAN_EID_CHANNEL_SWITCH;\n\t\t*pos++ = 3;\n\t\t*pos++ = 0x0;\n\t\t*pos++ = ieee80211_frequency_to_channel(\n\t\t\t\tcsa->settings.chandef.chan->center_freq);\n\t\tbcn->cntdwn_current_counter = csa->settings.count;\n\t\tbcn->cntdwn_counter_offsets[0] = hdr_len + 6;\n\t\t*pos++ = csa->settings.count;\n\t\t*pos++ = WLAN_EID_CHAN_SWITCH_PARAM;\n\t\t*pos++ = 6;\n\t\tif (ifmsh->csa_role == IEEE80211_MESH_CSA_ROLE_INIT) {\n\t\t\t*pos++ = ifmsh->mshcfg.dot11MeshTTL;\n\t\t\t*pos |= WLAN_EID_CHAN_SWITCH_PARAM_INITIATOR;\n\t\t} else {\n\t\t\t*pos++ = ifmsh->chsw_ttl;\n\t\t}\n\t\t*pos++ |= csa->settings.block_tx ?\n\t\t\t  WLAN_EID_CHAN_SWITCH_PARAM_TX_RESTRICT : 0x00;\n\t\tput_unaligned_le16(WLAN_REASON_MESH_CHAN, pos);\n\t\tpos += 2;\n\t\tput_unaligned_le16(ifmsh->pre_value, pos);\n\t\tpos += 2;\n\n\t\tswitch (csa->settings.chandef.width) {\n\t\tcase NL80211_CHAN_WIDTH_40:\n\t\t\tie_len = 2 + sizeof(struct ieee80211_sec_chan_offs_ie);\n\t\t\tpos = skb_put_zero(skb, ie_len);\n\n\t\t\t*pos++ = WLAN_EID_SECONDARY_CHANNEL_OFFSET;  \n\t\t\t*pos++ = 1;\t\t\t\t     \n\t\t\tct = cfg80211_get_chandef_type(&csa->settings.chandef);\n\t\t\tif (ct == NL80211_CHAN_HT40PLUS)\n\t\t\t\t*pos++ = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\n\t\t\telse\n\t\t\t\t*pos++ = IEEE80211_HT_PARAM_CHA_SEC_BELOW;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_80:\n\t\tcase NL80211_CHAN_WIDTH_80P80:\n\t\tcase NL80211_CHAN_WIDTH_160:\n\t\t\t \n\t\t\tie_len = 2 + 2 +\n\t\t\t\t sizeof(struct ieee80211_wide_bw_chansw_ie);\n\t\t\tpos = skb_put_zero(skb, ie_len);\n\n\t\t\t*pos++ = WLAN_EID_CHANNEL_SWITCH_WRAPPER;  \n\t\t\t*pos++ = 5;\t\t\t\t   \n\t\t\t \n\t\t\tchandef = &csa->settings.chandef;\n\t\t\tieee80211_ie_build_wide_bw_cs(pos, chandef);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (ieee80211_add_srates_ie(sdata, skb, true, band) ||\n\t    mesh_add_ds_params_ie(sdata, skb))\n\t\tgoto out_free;\n\n\tbcn->head_len = skb->len;\n\tmemcpy(bcn->head, skb->data, bcn->head_len);\n\n\t \n\tskb_trim(skb, 0);\n\tbcn->tail = bcn->head + bcn->head_len;\n\n\tif (ieee80211_add_ext_srates_ie(sdata, skb, true, band) ||\n\t    mesh_add_rsn_ie(sdata, skb) ||\n\t    mesh_add_ht_cap_ie(sdata, skb) ||\n\t    mesh_add_ht_oper_ie(sdata, skb) ||\n\t    mesh_add_meshid_ie(sdata, skb) ||\n\t    mesh_add_meshconf_ie(sdata, skb) ||\n\t    mesh_add_awake_window_ie(sdata, skb) ||\n\t    mesh_add_vht_cap_ie(sdata, skb) ||\n\t    mesh_add_vht_oper_ie(sdata, skb) ||\n\t    mesh_add_he_cap_ie(sdata, skb, ie_len_he_cap) ||\n\t    mesh_add_he_oper_ie(sdata, skb) ||\n\t    mesh_add_he_6ghz_cap_ie(sdata, skb) ||\n\t    mesh_add_eht_cap_ie(sdata, skb, ie_len_eht_cap) ||\n\t    mesh_add_eht_oper_ie(sdata, skb) ||\n\t    mesh_add_vendor_ies(sdata, skb))\n\t\tgoto out_free;\n\n\tbcn->tail_len = skb->len;\n\tmemcpy(bcn->tail, skb->data, bcn->tail_len);\n\tieee80211_mesh_update_bss_params(sdata, bcn->tail, bcn->tail_len);\n\tbcn->meshconf = (struct ieee80211_meshconf_ie *)\n\t\t\t\t\t(bcn->tail + ifmsh->meshconf_offset);\n\n\tdev_kfree_skb(skb);\n\trcu_assign_pointer(ifmsh->beacon, bcn);\n\treturn 0;\nout_free:\n\tkfree(bcn);\n\tdev_kfree_skb(skb);\n\treturn -ENOMEM;\n}\n\nstatic int\nieee80211_mesh_rebuild_beacon(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct beacon_data *old_bcn;\n\tint ret;\n\n\told_bcn = sdata_dereference(sdata->u.mesh.beacon, sdata);\n\tret = ieee80211_mesh_build_beacon(&sdata->u.mesh);\n\tif (ret)\n\t\t \n\t\treturn ret;\n\n\tif (old_bcn)\n\t\tkfree_rcu(old_bcn, rcu_head);\n\treturn 0;\n}\n\nvoid ieee80211_mbss_info_change_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       u64 changed)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tunsigned long bits = changed;\n\tu32 bit;\n\n\tif (!bits)\n\t\treturn;\n\n\t \n\tfor_each_set_bit(bit, &bits, sizeof(changed) * BITS_PER_BYTE)\n\t\tset_bit(bit, ifmsh->mbss_changed);\n\tset_bit(MESH_WORK_MBSS_CHANGED, &ifmsh->wrkq_flags);\n\twiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);\n}\n\nint ieee80211_start_mesh(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct ieee80211_local *local = sdata->local;\n\tu64 changed = BSS_CHANGED_BEACON |\n\t\t      BSS_CHANGED_BEACON_ENABLED |\n\t\t      BSS_CHANGED_HT |\n\t\t      BSS_CHANGED_BASIC_RATES |\n\t\t      BSS_CHANGED_BEACON_INT |\n\t\t      BSS_CHANGED_MCAST_RATE;\n\n\tlocal->fif_other_bss++;\n\t \n\tatomic_inc(&local->iff_allmultis);\n\tieee80211_configure_filter(local);\n\n\tifmsh->mesh_cc_id = 0;\t \n\t \n\tifmsh->sync_ops = ieee80211_mesh_sync_ops_get(ifmsh->mesh_sp_id);\n\tifmsh->sync_offset_clockdrift_max = 0;\n\tset_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags);\n\tieee80211_mesh_root_setup(ifmsh);\n\twiphy_work_queue(local->hw.wiphy, &sdata->work);\n\tsdata->vif.bss_conf.ht_operation_mode =\n\t\t\t\tifmsh->mshcfg.ht_opmode;\n\tsdata->vif.bss_conf.enable_beacon = true;\n\n\tchanged |= ieee80211_mps_local_status_update(sdata);\n\n\tif (ieee80211_mesh_build_beacon(ifmsh)) {\n\t\tieee80211_stop_mesh(sdata);\n\t\treturn -ENOMEM;\n\t}\n\n\tieee80211_recalc_dtim(local, sdata);\n\tieee80211_link_info_change_notify(sdata, &sdata->deflink, changed);\n\n\tnetif_carrier_on(sdata->dev);\n\treturn 0;\n}\n\nvoid ieee80211_stop_mesh(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct beacon_data *bcn;\n\n\tnetif_carrier_off(sdata->dev);\n\n\t \n\tsta_info_flush(sdata);\n\tieee80211_free_keys(sdata, true);\n\tmesh_path_flush_by_iface(sdata);\n\n\t \n\tifmsh->mesh_id_len = 0;\n\tsdata->vif.bss_conf.enable_beacon = false;\n\tsdata->beacon_rate_set = false;\n\tclear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED, &sdata->state);\n\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t  BSS_CHANGED_BEACON_ENABLED);\n\n\t \n\tbcn = sdata_dereference(ifmsh->beacon, sdata);\n\tRCU_INIT_POINTER(ifmsh->beacon, NULL);\n\tkfree_rcu(bcn, rcu_head);\n\n\t \n\tlocal->total_ps_buffered -= skb_queue_len(&ifmsh->ps.bc_buf);\n\tskb_queue_purge(&ifmsh->ps.bc_buf);\n\n\tdel_timer_sync(&sdata->u.mesh.housekeeping_timer);\n\tdel_timer_sync(&sdata->u.mesh.mesh_path_root_timer);\n\tdel_timer_sync(&sdata->u.mesh.mesh_path_timer);\n\n\t \n\tifmsh->wrkq_flags = 0;\n\tmemset(ifmsh->mbss_changed, 0, sizeof(ifmsh->mbss_changed));\n\n\tlocal->fif_other_bss--;\n\tatomic_dec(&local->iff_allmultis);\n\tieee80211_configure_filter(local);\n}\n\nstatic void ieee80211_mesh_csa_mark_radar(struct ieee80211_sub_if_data *sdata)\n{\n\tint err;\n\n\t \n\terr = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,\n\t\t\t\t\t    &sdata->vif.bss_conf.chandef,\n\t\t\t\t\t    NL80211_IFTYPE_MESH_POINT);\n\tif (err > 0)\n\t\tcfg80211_radar_event(sdata->local->hw.wiphy,\n\t\t\t\t     &sdata->vif.bss_conf.chandef, GFP_ATOMIC);\n}\n\nstatic bool\nieee80211_mesh_process_chnswitch(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct ieee802_11_elems *elems, bool beacon)\n{\n\tstruct cfg80211_csa_settings params;\n\tstruct ieee80211_csa_ie csa_ie;\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct ieee80211_supported_band *sband;\n\tint err;\n\tieee80211_conn_flags_t conn_flags = 0;\n\tu32 vht_cap_info = 0;\n\n\tsdata_assert_lock(sdata);\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn false;\n\n\tswitch (sdata->vif.bss_conf.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_HT;\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_40MHZ;\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_VHT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (elems->vht_cap_elem)\n\t\tvht_cap_info =\n\t\t\tle32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n\n\tmemset(&params, 0, sizeof(params));\n\terr = ieee80211_parse_ch_switch_ie(sdata, elems, sband->band,\n\t\t\t\t\t   vht_cap_info,\n\t\t\t\t\t   conn_flags, sdata->vif.addr,\n\t\t\t\t\t   &csa_ie);\n\tif (err < 0)\n\t\treturn false;\n\tif (err)\n\t\treturn false;\n\n\t \n\tif (csa_ie.reason_code == WLAN_REASON_MESH_CHAN_REGULATORY)\n\t\tieee80211_mesh_csa_mark_radar(sdata);\n\n\tparams.chandef = csa_ie.chandef;\n\tparams.count = csa_ie.count;\n\n\tif (!cfg80211_chandef_usable(sdata->local->hw.wiphy, &params.chandef,\n\t\t\t\t     IEEE80211_CHAN_DISABLED) ||\n\t    !cfg80211_reg_can_beacon(sdata->local->hw.wiphy, &params.chandef,\n\t\t\t\t     NL80211_IFTYPE_MESH_POINT)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"mesh STA %pM switches to unsupported channel (%d MHz, width:%d, CF1/2: %d/%d MHz), aborting\\n\",\n\t\t\t   sdata->vif.addr,\n\t\t\t   params.chandef.chan->center_freq,\n\t\t\t   params.chandef.width,\n\t\t\t   params.chandef.center_freq1,\n\t\t\t   params.chandef.center_freq2);\n\t\treturn false;\n\t}\n\n\terr = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,\n\t\t\t\t\t    &params.chandef,\n\t\t\t\t\t    NL80211_IFTYPE_MESH_POINT);\n\tif (err < 0)\n\t\treturn false;\n\tif (err > 0 && !ifmsh->userspace_handles_dfs) {\n\t\tsdata_info(sdata,\n\t\t\t   \"mesh STA %pM switches to channel requiring DFS (%d MHz, width:%d, CF1/2: %d/%d MHz), aborting\\n\",\n\t\t\t   sdata->vif.addr,\n\t\t\t   params.chandef.chan->center_freq,\n\t\t\t   params.chandef.width,\n\t\t\t   params.chandef.center_freq1,\n\t\t\t   params.chandef.center_freq2);\n\t\treturn false;\n\t}\n\n\tparams.radar_required = err;\n\n\tif (cfg80211_chandef_identical(&params.chandef,\n\t\t\t\t       &sdata->vif.bss_conf.chandef)) {\n\t\tmcsa_dbg(sdata,\n\t\t\t \"received csa with an identical chandef, ignoring\\n\");\n\t\treturn true;\n\t}\n\n\tmcsa_dbg(sdata,\n\t\t \"received channel switch announcement to go to channel %d MHz\\n\",\n\t\t params.chandef.chan->center_freq);\n\n\tparams.block_tx = csa_ie.mode & WLAN_EID_CHAN_SWITCH_PARAM_TX_RESTRICT;\n\tif (beacon) {\n\t\tifmsh->chsw_ttl = csa_ie.ttl - 1;\n\t\tif (ifmsh->pre_value >= csa_ie.pre_value)\n\t\t\treturn false;\n\t\tifmsh->pre_value = csa_ie.pre_value;\n\t}\n\n\tif (ifmsh->chsw_ttl >= ifmsh->mshcfg.dot11MeshTTL)\n\t\treturn false;\n\n\tifmsh->csa_role = IEEE80211_MESH_CSA_ROLE_REPEATER;\n\n\tif (ieee80211_channel_switch(sdata->local->hw.wiphy, sdata->dev,\n\t\t\t\t     &params) < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void\nieee80211_mesh_rx_probe_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct sk_buff *presp;\n\tstruct beacon_data *bcn;\n\tstruct ieee80211_mgmt *hdr;\n\tstruct ieee802_11_elems *elems;\n\tsize_t baselen;\n\tu8 *pos;\n\n\tpos = mgmt->u.probe_req.variable;\n\tbaselen = (u8 *) pos - (u8 *) mgmt;\n\tif (baselen > len)\n\t\treturn;\n\n\telems = ieee802_11_parse_elems(pos, len - baselen, false, NULL);\n\tif (!elems)\n\t\treturn;\n\n\tif (!elems->mesh_id)\n\t\tgoto free;\n\n\t \n\tif ((!ether_addr_equal(mgmt->da, sdata->vif.addr) &&\n\t     !is_broadcast_ether_addr(mgmt->da)) ||\n\t    elems->ssid_len != 0)\n\t\tgoto free;\n\n\tif (elems->mesh_id_len != 0 &&\n\t    (elems->mesh_id_len != ifmsh->mesh_id_len ||\n\t     memcmp(elems->mesh_id, ifmsh->mesh_id, ifmsh->mesh_id_len)))\n\t\tgoto free;\n\n\trcu_read_lock();\n\tbcn = rcu_dereference(ifmsh->beacon);\n\n\tif (!bcn)\n\t\tgoto out;\n\n\tpresp = dev_alloc_skb(local->tx_headroom +\n\t\t\t      bcn->head_len + bcn->tail_len);\n\tif (!presp)\n\t\tgoto out;\n\n\tskb_reserve(presp, local->tx_headroom);\n\tskb_put_data(presp, bcn->head, bcn->head_len);\n\tskb_put_data(presp, bcn->tail, bcn->tail_len);\n\thdr = (struct ieee80211_mgmt *) presp->data;\n\thdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t IEEE80211_STYPE_PROBE_RESP);\n\tmemcpy(hdr->da, mgmt->sa, ETH_ALEN);\n\tIEEE80211_SKB_CB(presp)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\tieee80211_tx_skb(sdata, presp);\nout:\n\trcu_read_unlock();\nfree:\n\tkfree(elems);\n}\n\nstatic void ieee80211_mesh_rx_bcn_presp(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tu16 stype,\n\t\t\t\t\tstruct ieee80211_mgmt *mgmt,\n\t\t\t\t\tsize_t len,\n\t\t\t\t\tstruct ieee80211_rx_status *rx_status)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct ieee802_11_elems *elems;\n\tstruct ieee80211_channel *channel;\n\tsize_t baselen;\n\tint freq;\n\tenum nl80211_band band = rx_status->band;\n\n\t \n\tif (stype == IEEE80211_STYPE_PROBE_RESP &&\n\t    !ether_addr_equal(mgmt->da, sdata->vif.addr))\n\t\treturn;\n\n\tbaselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;\n\tif (baselen > len)\n\t\treturn;\n\n\telems = ieee802_11_parse_elems(mgmt->u.probe_resp.variable,\n\t\t\t\t       len - baselen,\n\t\t\t\t       false, NULL);\n\tif (!elems)\n\t\treturn;\n\n\t \n\tif ((!elems->mesh_id || !elems->mesh_config) ||\n\t    (elems->rsn && sdata->u.mesh.security == IEEE80211_MESH_SEC_NONE) ||\n\t    (!elems->rsn && sdata->u.mesh.security != IEEE80211_MESH_SEC_NONE))\n\t\tgoto free;\n\n\tif (elems->ds_params)\n\t\tfreq = ieee80211_channel_to_frequency(elems->ds_params[0], band);\n\telse\n\t\tfreq = rx_status->freq;\n\n\tchannel = ieee80211_get_channel(local->hw.wiphy, freq);\n\n\tif (!channel || channel->flags & IEEE80211_CHAN_DISABLED)\n\t\tgoto free;\n\n\tif (mesh_matches_local(sdata, elems)) {\n\t\tmpl_dbg(sdata, \"rssi_threshold=%d,rx_status->signal=%d\\n\",\n\t\t\tsdata->u.mesh.mshcfg.rssi_threshold, rx_status->signal);\n\t\tif (!sdata->u.mesh.user_mpm ||\n\t\t    sdata->u.mesh.mshcfg.rssi_threshold == 0 ||\n\t\t    sdata->u.mesh.mshcfg.rssi_threshold < rx_status->signal)\n\t\t\tmesh_neighbour_update(sdata, mgmt->sa, elems,\n\t\t\t\t\t      rx_status);\n\n\t\tif (ifmsh->csa_role != IEEE80211_MESH_CSA_ROLE_INIT &&\n\t\t    !sdata->vif.bss_conf.csa_active)\n\t\t\tieee80211_mesh_process_chnswitch(sdata, elems, true);\n\t}\n\n\tif (ifmsh->sync_ops)\n\t\tifmsh->sync_ops->rx_bcn_presp(sdata, stype, mgmt, len,\n\t\t\t\t\t      elems->mesh_config, rx_status);\nfree:\n\tkfree(elems);\n}\n\nint ieee80211_mesh_finish_csa(struct ieee80211_sub_if_data *sdata, u64 *changed)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct mesh_csa_settings *tmp_csa_settings;\n\tint ret = 0;\n\n\t \n\tifmsh->csa_role = IEEE80211_MESH_CSA_ROLE_NONE;\n\tifmsh->chsw_ttl = 0;\n\n\t \n\ttmp_csa_settings = sdata_dereference(ifmsh->csa, sdata);\n\tRCU_INIT_POINTER(ifmsh->csa, NULL);\n\tif (tmp_csa_settings)\n\t\tkfree_rcu(tmp_csa_settings, rcu_head);\n\tret = ieee80211_mesh_rebuild_beacon(sdata);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t*changed |= BSS_CHANGED_BEACON;\n\n\tmcsa_dbg(sdata, \"complete switching to center freq %d MHz\",\n\t\t sdata->vif.bss_conf.chandef.chan->center_freq);\n\treturn 0;\n}\n\nint ieee80211_mesh_csa_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct cfg80211_csa_settings *csa_settings,\n\t\t\t      u64 *changed)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct mesh_csa_settings *tmp_csa_settings;\n\tint ret = 0;\n\n\tlockdep_assert_held(&sdata->wdev.mtx);\n\n\ttmp_csa_settings = kmalloc(sizeof(*tmp_csa_settings),\n\t\t\t\t   GFP_ATOMIC);\n\tif (!tmp_csa_settings)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&tmp_csa_settings->settings, csa_settings,\n\t       sizeof(struct cfg80211_csa_settings));\n\n\trcu_assign_pointer(ifmsh->csa, tmp_csa_settings);\n\n\tret = ieee80211_mesh_rebuild_beacon(sdata);\n\tif (ret) {\n\t\ttmp_csa_settings = rcu_dereference(ifmsh->csa);\n\t\tRCU_INIT_POINTER(ifmsh->csa, NULL);\n\t\tkfree_rcu(tmp_csa_settings, rcu_head);\n\t\treturn ret;\n\t}\n\n\t*changed |= BSS_CHANGED_BEACON;\n\treturn 0;\n}\n\nstatic int mesh_fwd_csa_frame(struct ieee80211_sub_if_data *sdata,\n\t\t\t       struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t       struct ieee802_11_elems *elems)\n{\n\tstruct ieee80211_mgmt *mgmt_fwd;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_local *local = sdata->local;\n\n\tskb = dev_alloc_skb(local->tx_headroom + len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, local->tx_headroom);\n\tmgmt_fwd = skb_put(skb, len);\n\n\telems->mesh_chansw_params_ie->mesh_ttl--;\n\telems->mesh_chansw_params_ie->mesh_flags &=\n\t\t~WLAN_EID_CHAN_SWITCH_PARAM_INITIATOR;\n\n\tmemcpy(mgmt_fwd, mgmt, len);\n\teth_broadcast_addr(mgmt_fwd->da);\n\tmemcpy(mgmt_fwd->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(mgmt_fwd->bssid, sdata->vif.addr, ETH_ALEN);\n\n\tieee80211_tx_skb(sdata, skb);\n\treturn 0;\n}\n\nstatic void mesh_rx_csa_frame(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct ieee802_11_elems *elems;\n\tu16 pre_value;\n\tbool fwd_csa = true;\n\tsize_t baselen;\n\tu8 *pos;\n\n\tif (mgmt->u.action.u.measurement.action_code !=\n\t    WLAN_ACTION_SPCT_CHL_SWITCH)\n\t\treturn;\n\n\tpos = mgmt->u.action.u.chan_switch.variable;\n\tbaselen = offsetof(struct ieee80211_mgmt,\n\t\t\t   u.action.u.chan_switch.variable);\n\telems = ieee802_11_parse_elems(pos, len - baselen, true, NULL);\n\tif (!elems)\n\t\treturn;\n\n\tif (!mesh_matches_local(sdata, elems))\n\t\tgoto free;\n\n\tifmsh->chsw_ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n\tif (!--ifmsh->chsw_ttl)\n\t\tfwd_csa = false;\n\n\tpre_value = le16_to_cpu(elems->mesh_chansw_params_ie->mesh_pre_value);\n\tif (ifmsh->pre_value >= pre_value)\n\t\tgoto free;\n\n\tifmsh->pre_value = pre_value;\n\n\tif (!sdata->vif.bss_conf.csa_active &&\n\t    !ieee80211_mesh_process_chnswitch(sdata, elems, false)) {\n\t\tmcsa_dbg(sdata, \"Failed to process CSA action frame\");\n\t\tgoto free;\n\t}\n\n\t \n\tif (fwd_csa) {\n\t\tif (mesh_fwd_csa_frame(sdata, mgmt, len, elems) < 0)\n\t\t\tmcsa_dbg(sdata, \"Failed to forward the CSA frame\");\n\t}\nfree:\n\tkfree(elems);\n}\n\nstatic void ieee80211_mesh_rx_mgmt_action(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  struct ieee80211_mgmt *mgmt,\n\t\t\t\t\t  size_t len,\n\t\t\t\t\t  struct ieee80211_rx_status *rx_status)\n{\n\tswitch (mgmt->u.action.category) {\n\tcase WLAN_CATEGORY_SELF_PROTECTED:\n\t\tswitch (mgmt->u.action.u.self_prot.action_code) {\n\t\tcase WLAN_SP_MESH_PEERING_OPEN:\n\t\tcase WLAN_SP_MESH_PEERING_CLOSE:\n\t\tcase WLAN_SP_MESH_PEERING_CONFIRM:\n\t\t\tmesh_rx_plink_frame(sdata, mgmt, len, rx_status);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase WLAN_CATEGORY_MESH_ACTION:\n\t\tif (mesh_action_is_path_sel(mgmt))\n\t\t\tmesh_rx_path_sel_frame(sdata, mgmt, len);\n\t\tbreak;\n\tcase WLAN_CATEGORY_SPECTRUM_MGMT:\n\t\tmesh_rx_csa_frame(sdata, mgmt, len);\n\t\tbreak;\n\t}\n}\n\nvoid ieee80211_mesh_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct ieee80211_mgmt *mgmt;\n\tu16 stype;\n\n\tsdata_lock(sdata);\n\n\t \n\tif (!sdata->u.mesh.mesh_id_len)\n\t\tgoto out;\n\n\trx_status = IEEE80211_SKB_RXCB(skb);\n\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\tstype = le16_to_cpu(mgmt->frame_control) & IEEE80211_FCTL_STYPE;\n\n\tswitch (stype) {\n\tcase IEEE80211_STYPE_PROBE_RESP:\n\tcase IEEE80211_STYPE_BEACON:\n\t\tieee80211_mesh_rx_bcn_presp(sdata, stype, mgmt, skb->len,\n\t\t\t\t\t    rx_status);\n\t\tbreak;\n\tcase IEEE80211_STYPE_PROBE_REQ:\n\t\tieee80211_mesh_rx_probe_req(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_ACTION:\n\t\tieee80211_mesh_rx_mgmt_action(sdata, mgmt, skb->len, rx_status);\n\t\tbreak;\n\t}\nout:\n\tsdata_unlock(sdata);\n}\n\nstatic void mesh_bss_info_changed(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tu32 bit;\n\tu64 changed = 0;\n\n\tfor_each_set_bit(bit, ifmsh->mbss_changed,\n\t\t\t sizeof(changed) * BITS_PER_BYTE) {\n\t\tclear_bit(bit, ifmsh->mbss_changed);\n\t\tchanged |= BIT(bit);\n\t}\n\n\tif (sdata->vif.bss_conf.enable_beacon &&\n\t    (changed & (BSS_CHANGED_BEACON |\n\t\t\tBSS_CHANGED_HT |\n\t\t\tBSS_CHANGED_BASIC_RATES |\n\t\t\tBSS_CHANGED_BEACON_INT)))\n\t\tif (ieee80211_mesh_rebuild_beacon(sdata))\n\t\t\treturn;\n\n\tieee80211_link_info_change_notify(sdata, &sdata->deflink, changed);\n}\n\nvoid ieee80211_mesh_work(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\tsdata_lock(sdata);\n\n\t \n\tif (!sdata->u.mesh.mesh_id_len)\n\t\tgoto out;\n\n\tif (ifmsh->preq_queue_len &&\n\t    time_after(jiffies,\n\t\t       ifmsh->last_preq + msecs_to_jiffies(ifmsh->mshcfg.dot11MeshHWMPpreqMinInterval)))\n\t\tmesh_path_start_discovery(sdata);\n\n\tif (test_and_clear_bit(MESH_WORK_HOUSEKEEPING, &ifmsh->wrkq_flags))\n\t\tieee80211_mesh_housekeeping(sdata);\n\n\tif (test_and_clear_bit(MESH_WORK_ROOT, &ifmsh->wrkq_flags))\n\t\tieee80211_mesh_rootpath(sdata);\n\n\tif (test_and_clear_bit(MESH_WORK_DRIFT_ADJUST, &ifmsh->wrkq_flags))\n\t\tmesh_sync_adjust_tsf(sdata);\n\n\tif (test_and_clear_bit(MESH_WORK_MBSS_CHANGED, &ifmsh->wrkq_flags))\n\t\tmesh_bss_info_changed(sdata);\nout:\n\tsdata_unlock(sdata);\n}\n\n\nvoid ieee80211_mesh_init_sdata(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstatic u8 zero_addr[ETH_ALEN] = {};\n\n\ttimer_setup(&ifmsh->housekeeping_timer,\n\t\t    ieee80211_mesh_housekeeping_timer, 0);\n\n\tifmsh->accepting_plinks = true;\n\tatomic_set(&ifmsh->mpaths, 0);\n\tmesh_rmc_init(sdata);\n\tifmsh->last_preq = jiffies;\n\tifmsh->next_perr = jiffies;\n\tifmsh->csa_role = IEEE80211_MESH_CSA_ROLE_NONE;\n\t \n\tif (!mesh_allocated)\n\t\tieee80211s_init();\n\n\tmesh_pathtbl_init(sdata);\n\n\ttimer_setup(&ifmsh->mesh_path_timer, ieee80211_mesh_path_timer, 0);\n\ttimer_setup(&ifmsh->mesh_path_root_timer,\n\t\t    ieee80211_mesh_path_root_timer, 0);\n\tINIT_LIST_HEAD(&ifmsh->preq_queue.list);\n\tskb_queue_head_init(&ifmsh->ps.bc_buf);\n\tspin_lock_init(&ifmsh->mesh_preq_queue_lock);\n\tspin_lock_init(&ifmsh->sync_offset_lock);\n\tRCU_INIT_POINTER(ifmsh->beacon, NULL);\n\n\tsdata->vif.bss_conf.bssid = zero_addr;\n}\n\nvoid ieee80211_mesh_teardown_sdata(struct ieee80211_sub_if_data *sdata)\n{\n\tmesh_rmc_free(sdata);\n\tmesh_pathtbl_unregister(sdata);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}