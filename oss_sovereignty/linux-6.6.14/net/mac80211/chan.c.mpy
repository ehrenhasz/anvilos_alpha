{
  "module_name": "chan.c",
  "hash_id": "7d89478c38046b62c1950fa1485741a0d698ae62b7dbeea82be5caae4521cad3",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/chan.c",
  "human_readable_source": "\n \n\n#include <linux/nl80211.h>\n#include <linux/export.h>\n#include <linux/rtnetlink.h>\n#include <net/cfg80211.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"rate.h\"\n\nstatic int ieee80211_chanctx_num_assigned(struct ieee80211_local *local,\n\t\t\t\t\t  struct ieee80211_chanctx *ctx)\n{\n\tstruct ieee80211_link_data *link;\n\tint num = 0;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tlist_for_each_entry(link, &ctx->assigned_links, assigned_chanctx_list)\n\t\tnum++;\n\n\treturn num;\n}\n\nstatic int ieee80211_chanctx_num_reserved(struct ieee80211_local *local,\n\t\t\t\t\t  struct ieee80211_chanctx *ctx)\n{\n\tstruct ieee80211_link_data *link;\n\tint num = 0;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tlist_for_each_entry(link, &ctx->reserved_links, reserved_chanctx_list)\n\t\tnum++;\n\n\treturn num;\n}\n\nint ieee80211_chanctx_refcount(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_chanctx *ctx)\n{\n\treturn ieee80211_chanctx_num_assigned(local, ctx) +\n\t       ieee80211_chanctx_num_reserved(local, ctx);\n}\n\nstatic int ieee80211_num_chanctx(struct ieee80211_local *local)\n{\n\tstruct ieee80211_chanctx *ctx;\n\tint num = 0;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tlist_for_each_entry(ctx, &local->chanctx_list, list)\n\t\tnum++;\n\n\treturn num;\n}\n\nstatic bool ieee80211_can_create_new_chanctx(struct ieee80211_local *local)\n{\n\tlockdep_assert_held(&local->chanctx_mtx);\n\treturn ieee80211_num_chanctx(local) < ieee80211_max_num_channels(local);\n}\n\nstatic struct ieee80211_chanctx *\nieee80211_link_get_chanctx(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_local *local __maybe_unused = link->sdata->local;\n\tstruct ieee80211_chanctx_conf *conf;\n\n\tconf = rcu_dereference_protected(link->conf->chanctx_conf,\n\t\t\t\t\t lockdep_is_held(&local->chanctx_mtx));\n\tif (!conf)\n\t\treturn NULL;\n\n\treturn container_of(conf, struct ieee80211_chanctx, conf);\n}\n\nstatic const struct cfg80211_chan_def *\nieee80211_chanctx_reserved_chandef(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_chanctx *ctx,\n\t\t\t\t   const struct cfg80211_chan_def *compat)\n{\n\tstruct ieee80211_link_data *link;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tlist_for_each_entry(link, &ctx->reserved_links,\n\t\t\t    reserved_chanctx_list) {\n\t\tif (!compat)\n\t\t\tcompat = &link->reserved_chandef;\n\n\t\tcompat = cfg80211_chandef_compatible(&link->reserved_chandef,\n\t\t\t\t\t\t     compat);\n\t\tif (!compat)\n\t\t\tbreak;\n\t}\n\n\treturn compat;\n}\n\nstatic const struct cfg80211_chan_def *\nieee80211_chanctx_non_reserved_chandef(struct ieee80211_local *local,\n\t\t\t\t       struct ieee80211_chanctx *ctx,\n\t\t\t\t       const struct cfg80211_chan_def *compat)\n{\n\tstruct ieee80211_link_data *link;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tlist_for_each_entry(link, &ctx->assigned_links,\n\t\t\t    assigned_chanctx_list) {\n\t\tstruct ieee80211_bss_conf *link_conf = link->conf;\n\n\t\tif (link->reserved_chanctx)\n\t\t\tcontinue;\n\n\t\tif (!compat)\n\t\t\tcompat = &link_conf->chandef;\n\n\t\tcompat = cfg80211_chandef_compatible(\n\t\t\t\t&link_conf->chandef, compat);\n\t\tif (!compat)\n\t\t\tbreak;\n\t}\n\n\treturn compat;\n}\n\nstatic const struct cfg80211_chan_def *\nieee80211_chanctx_combined_chandef(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_chanctx *ctx,\n\t\t\t\t   const struct cfg80211_chan_def *compat)\n{\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tcompat = ieee80211_chanctx_reserved_chandef(local, ctx, compat);\n\tif (!compat)\n\t\treturn NULL;\n\n\tcompat = ieee80211_chanctx_non_reserved_chandef(local, ctx, compat);\n\tif (!compat)\n\t\treturn NULL;\n\n\treturn compat;\n}\n\nstatic bool\nieee80211_chanctx_can_reserve_chandef(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_chanctx *ctx,\n\t\t\t\t      const struct cfg80211_chan_def *def)\n{\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tif (ieee80211_chanctx_combined_chandef(local, ctx, def))\n\t\treturn true;\n\n\tif (!list_empty(&ctx->reserved_links) &&\n\t    ieee80211_chanctx_reserved_chandef(local, ctx, def))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct ieee80211_chanctx *\nieee80211_find_reservation_chanctx(struct ieee80211_local *local,\n\t\t\t\t   const struct cfg80211_chan_def *chandef,\n\t\t\t\t   enum ieee80211_chanctx_mode mode)\n{\n\tstruct ieee80211_chanctx *ctx;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tif (mode == IEEE80211_CHANCTX_EXCLUSIVE)\n\t\treturn NULL;\n\n\tlist_for_each_entry(ctx, &local->chanctx_list, list) {\n\t\tif (ctx->replace_state == IEEE80211_CHANCTX_WILL_BE_REPLACED)\n\t\t\tcontinue;\n\n\t\tif (ctx->mode == IEEE80211_CHANCTX_EXCLUSIVE)\n\t\t\tcontinue;\n\n\t\tif (!ieee80211_chanctx_can_reserve_chandef(local, ctx,\n\t\t\t\t\t\t\t   chandef))\n\t\t\tcontinue;\n\n\t\treturn ctx;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum nl80211_chan_width ieee80211_get_sta_bw(struct sta_info *sta,\n\t\t\t\t\t\t    unsigned int link_id)\n{\n\tenum ieee80211_sta_rx_bandwidth width;\n\tstruct link_sta_info *link_sta;\n\n\tlink_sta = rcu_dereference(sta->link[link_id]);\n\n\t \n\tif (!link_sta)\n\t\treturn NL80211_CHAN_WIDTH_20_NOHT;\n\n\twidth = ieee80211_sta_cap_rx_bw(link_sta);\n\n\tswitch (width) {\n\tcase IEEE80211_STA_RX_BW_20:\n\t\tif (link_sta->pub->ht_cap.ht_supported)\n\t\t\treturn NL80211_CHAN_WIDTH_20;\n\t\telse\n\t\t\treturn NL80211_CHAN_WIDTH_20_NOHT;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\treturn NL80211_CHAN_WIDTH_40;\n\tcase IEEE80211_STA_RX_BW_80:\n\t\treturn NL80211_CHAN_WIDTH_80;\n\tcase IEEE80211_STA_RX_BW_160:\n\t\t \n\t\treturn NL80211_CHAN_WIDTH_160;\n\tcase IEEE80211_STA_RX_BW_320:\n\t\treturn NL80211_CHAN_WIDTH_320;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn NL80211_CHAN_WIDTH_20;\n\t}\n}\n\nstatic enum nl80211_chan_width\nieee80211_get_max_required_bw(struct ieee80211_sub_if_data *sdata,\n\t\t\t      unsigned int link_id)\n{\n\tenum nl80211_chan_width max_bw = NL80211_CHAN_WIDTH_20_NOHT;\n\tstruct sta_info *sta;\n\n\tlist_for_each_entry_rcu(sta, &sdata->local->sta_list, list) {\n\t\tif (sdata != sta->sdata &&\n\t\t    !(sta->sdata->bss && sta->sdata->bss == sdata->bss))\n\t\t\tcontinue;\n\n\t\tmax_bw = max(max_bw, ieee80211_get_sta_bw(sta, link_id));\n\t}\n\n\treturn max_bw;\n}\n\nstatic enum nl80211_chan_width\nieee80211_get_chanctx_vif_max_required_bw(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  struct ieee80211_chanctx *ctx,\n\t\t\t\t\t  struct ieee80211_link_data *rsvd_for)\n{\n\tenum nl80211_chan_width max_bw = NL80211_CHAN_WIDTH_20_NOHT;\n\tstruct ieee80211_vif *vif = &sdata->vif;\n\tint link_id;\n\n\trcu_read_lock();\n\tfor (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {\n\t\tenum nl80211_chan_width width = NL80211_CHAN_WIDTH_20_NOHT;\n\t\tstruct ieee80211_link_data *link =\n\t\t\trcu_dereference(sdata->link[link_id]);\n\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\tif (link != rsvd_for &&\n\t\t    rcu_access_pointer(link->conf->chanctx_conf) != &ctx->conf)\n\t\t\tcontinue;\n\n\t\tswitch (vif->type) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t\twidth = ieee80211_get_max_required_bw(sdata, link_id);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\t \n\t\t\twidth = max(link->conf->chandef.width,\n\t\t\t\t    ieee80211_get_max_required_bw(sdata, link_id));\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tcase NL80211_IFTYPE_NAN:\n\t\t\tcontinue;\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tcase NL80211_IFTYPE_OCB:\n\t\t\twidth = link->conf->chandef.width;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_WDS:\n\t\tcase NL80211_IFTYPE_UNSPECIFIED:\n\t\tcase NUM_NL80211_IFTYPES:\n\t\tcase NL80211_IFTYPE_MONITOR:\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\n\t\tmax_bw = max(max_bw, width);\n\t}\n\trcu_read_unlock();\n\n\treturn max_bw;\n}\n\nstatic enum nl80211_chan_width\nieee80211_get_chanctx_max_required_bw(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_chanctx *ctx,\n\t\t\t\t      struct ieee80211_link_data *rsvd_for)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tenum nl80211_chan_width max_bw = NL80211_CHAN_WIDTH_20_NOHT;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tenum nl80211_chan_width width;\n\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\twidth = ieee80211_get_chanctx_vif_max_required_bw(sdata, ctx,\n\t\t\t\t\t\t\t\t  rsvd_for);\n\n\t\tmax_bw = max(max_bw, width);\n\t}\n\n\t \n\tsdata = rcu_dereference(local->monitor_sdata);\n\tif (sdata &&\n\t    rcu_access_pointer(sdata->vif.bss_conf.chanctx_conf) == &ctx->conf)\n\t\tmax_bw = max(max_bw, ctx->conf.def.width);\n\n\trcu_read_unlock();\n\n\treturn max_bw;\n}\n\n \nstatic u32\n_ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n\t\t\t\t  struct ieee80211_chanctx *ctx,\n\t\t\t\t  struct ieee80211_link_data *rsvd_for)\n{\n\tenum nl80211_chan_width max_bw;\n\tstruct cfg80211_chan_def min_def;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\t \n\tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n\t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n\t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n\t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n\t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n\t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n\t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n\t    ctx->conf.radar_enabled) {\n\t\tctx->conf.min_def = ctx->conf.def;\n\t\treturn 0;\n\t}\n\n\tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n\n\t \n\tmin_def = ctx->conf.def;\n\twhile (min_def.width > max_bw)\n\t\tieee80211_chandef_downgrade(&min_def);\n\n\tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n\t\treturn 0;\n\n\tctx->conf.min_def = min_def;\n\tif (!ctx->driver_present)\n\t\treturn 0;\n\n\treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n}\n\n \nstatic void ieee80211_chan_bw_change(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_chanctx *ctx,\n\t\t\t\t     bool narrowed)\n{\n\tstruct sta_info *sta;\n\tstruct ieee80211_supported_band *sband =\n\t\tlocal->hw.wiphy->bands[ctx->conf.def.chan->band];\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &local->sta_list,\n\t\t\t\tlist) {\n\t\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\t\tenum ieee80211_sta_rx_bandwidth new_sta_bw;\n\t\tunsigned int link_id;\n\n\t\tif (!ieee80211_sdata_running(sta->sdata))\n\t\t\tcontinue;\n\n\t\tfor (link_id = 0; link_id < ARRAY_SIZE(sta->sdata->link); link_id++) {\n\t\t\tstruct ieee80211_bss_conf *link_conf =\n\t\t\t\trcu_dereference(sdata->vif.link_conf[link_id]);\n\t\t\tstruct link_sta_info *link_sta;\n\n\t\t\tif (!link_conf)\n\t\t\t\tcontinue;\n\n\t\t\tif (rcu_access_pointer(link_conf->chanctx_conf) != &ctx->conf)\n\t\t\t\tcontinue;\n\n\t\t\tlink_sta = rcu_dereference(sta->link[link_id]);\n\t\t\tif (!link_sta)\n\t\t\t\tcontinue;\n\n\t\t\tnew_sta_bw = ieee80211_sta_cur_vht_bw(link_sta);\n\n\t\t\t \n\t\t\tif (new_sta_bw == link_sta->pub->bandwidth)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif ((new_sta_bw < link_sta->pub->bandwidth) == !narrowed)\n\t\t\t\tcontinue;\n\n\t\t\tlink_sta->pub->bandwidth = new_sta_bw;\n\t\t\trate_control_rate_update(local, sband, sta, link_id,\n\t\t\t\t\t\t IEEE80211_RC_BW_CHANGED);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n \nvoid ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_chanctx *ctx,\n\t\t\t\t      struct ieee80211_link_data *rsvd_for)\n{\n\tu32 changed = _ieee80211_recalc_chanctx_min_def(local, ctx, rsvd_for);\n\n\tif (!changed)\n\t\treturn;\n\n\t \n\tieee80211_chan_bw_change(local, ctx, true);\n\n\tdrv_change_chanctx(local, ctx, changed);\n\n\t \n\tieee80211_chan_bw_change(local, ctx, false);\n}\n\nstatic void _ieee80211_change_chanctx(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_chanctx *ctx,\n\t\t\t\t      struct ieee80211_chanctx *old_ctx,\n\t\t\t\t      const struct cfg80211_chan_def *chandef,\n\t\t\t\t      struct ieee80211_link_data *rsvd_for)\n{\n\tu32 changed;\n\n\t \n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\tcase NL80211_CHAN_WIDTH_320:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\t \n\tieee80211_chan_bw_change(local, old_ctx, true);\n\n\tif (cfg80211_chandef_identical(&ctx->conf.def, chandef)) {\n\t\tieee80211_recalc_chanctx_min_def(local, ctx, rsvd_for);\n\t\treturn;\n\t}\n\n\tWARN_ON(!cfg80211_chandef_compatible(&ctx->conf.def, chandef));\n\n\tctx->conf.def = *chandef;\n\n\t \n\tchanged = IEEE80211_CHANCTX_CHANGE_WIDTH |\n\t\t  _ieee80211_recalc_chanctx_min_def(local, ctx, rsvd_for);\n\tdrv_change_chanctx(local, ctx, changed);\n\n\tif (!local->use_chanctx) {\n\t\tlocal->_oper_chandef = *chandef;\n\t\tieee80211_hw_config(local, 0);\n\t}\n\n\t \n\tieee80211_chan_bw_change(local, old_ctx, false);\n}\n\nstatic void ieee80211_change_chanctx(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_chanctx *ctx,\n\t\t\t\t     struct ieee80211_chanctx *old_ctx,\n\t\t\t\t     const struct cfg80211_chan_def *chandef)\n{\n\t_ieee80211_change_chanctx(local, ctx, old_ctx, chandef, NULL);\n}\n\nstatic struct ieee80211_chanctx *\nieee80211_find_chanctx(struct ieee80211_local *local,\n\t\t       const struct cfg80211_chan_def *chandef,\n\t\t       enum ieee80211_chanctx_mode mode)\n{\n\tstruct ieee80211_chanctx *ctx;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tif (mode == IEEE80211_CHANCTX_EXCLUSIVE)\n\t\treturn NULL;\n\n\tlist_for_each_entry(ctx, &local->chanctx_list, list) {\n\t\tconst struct cfg80211_chan_def *compat;\n\n\t\tif (ctx->replace_state != IEEE80211_CHANCTX_REPLACE_NONE)\n\t\t\tcontinue;\n\n\t\tif (ctx->mode == IEEE80211_CHANCTX_EXCLUSIVE)\n\t\t\tcontinue;\n\n\t\tcompat = cfg80211_chandef_compatible(&ctx->conf.def, chandef);\n\t\tif (!compat)\n\t\t\tcontinue;\n\n\t\tcompat = ieee80211_chanctx_reserved_chandef(local, ctx,\n\t\t\t\t\t\t\t    compat);\n\t\tif (!compat)\n\t\t\tcontinue;\n\n\t\tieee80211_change_chanctx(local, ctx, ctx, compat);\n\n\t\treturn ctx;\n\t}\n\n\treturn NULL;\n}\n\nbool ieee80211_is_radar_required(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tlockdep_assert_held(&local->mtx);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tunsigned int link_id;\n\n\t\tfor (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {\n\t\t\tstruct ieee80211_link_data *link;\n\n\t\t\tlink = rcu_dereference(sdata->link[link_id]);\n\n\t\t\tif (link && link->radar_required) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}\n\nstatic bool\nieee80211_chanctx_radar_required(struct ieee80211_local *local,\n\t\t\t\t struct ieee80211_chanctx *ctx)\n{\n\tstruct ieee80211_chanctx_conf *conf = &ctx->conf;\n\tstruct ieee80211_sub_if_data *sdata;\n\tbool required = false;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\tlockdep_assert_held(&local->mtx);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tunsigned int link_id;\n\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\t\tfor (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {\n\t\t\tstruct ieee80211_link_data *link;\n\n\t\t\tlink = rcu_dereference(sdata->link[link_id]);\n\t\t\tif (!link)\n\t\t\t\tcontinue;\n\n\t\t\tif (rcu_access_pointer(link->conf->chanctx_conf) != conf)\n\t\t\t\tcontinue;\n\t\t\tif (!link->radar_required)\n\t\t\t\tcontinue;\n\t\t\trequired = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (required)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn required;\n}\n\nstatic struct ieee80211_chanctx *\nieee80211_alloc_chanctx(struct ieee80211_local *local,\n\t\t\tconst struct cfg80211_chan_def *chandef,\n\t\t\tenum ieee80211_chanctx_mode mode)\n{\n\tstruct ieee80211_chanctx *ctx;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tctx = kzalloc(sizeof(*ctx) + local->hw.chanctx_data_size, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&ctx->assigned_links);\n\tINIT_LIST_HEAD(&ctx->reserved_links);\n\tctx->conf.def = *chandef;\n\tctx->conf.rx_chains_static = 1;\n\tctx->conf.rx_chains_dynamic = 1;\n\tctx->mode = mode;\n\tctx->conf.radar_enabled = false;\n\t_ieee80211_recalc_chanctx_min_def(local, ctx, NULL);\n\n\treturn ctx;\n}\n\nstatic int ieee80211_add_chanctx(struct ieee80211_local *local,\n\t\t\t\t struct ieee80211_chanctx *ctx)\n{\n\tu32 changed;\n\tint err;\n\n\tlockdep_assert_held(&local->mtx);\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tif (!local->use_chanctx)\n\t\tlocal->hw.conf.radar_enabled = ctx->conf.radar_enabled;\n\n\t \n\tchanged = ieee80211_idle_off(local);\n\tif (changed)\n\t\tieee80211_hw_config(local, changed);\n\n\tif (!local->use_chanctx) {\n\t\tlocal->_oper_chandef = ctx->conf.def;\n\t\tieee80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL);\n\t} else {\n\t\terr = drv_add_chanctx(local, ctx);\n\t\tif (err) {\n\t\t\tieee80211_recalc_idle(local);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct ieee80211_chanctx *\nieee80211_new_chanctx(struct ieee80211_local *local,\n\t\t      const struct cfg80211_chan_def *chandef,\n\t\t      enum ieee80211_chanctx_mode mode)\n{\n\tstruct ieee80211_chanctx *ctx;\n\tint err;\n\n\tlockdep_assert_held(&local->mtx);\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tctx = ieee80211_alloc_chanctx(local, chandef, mode);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = ieee80211_add_chanctx(local, ctx);\n\tif (err) {\n\t\tkfree(ctx);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlist_add_rcu(&ctx->list, &local->chanctx_list);\n\treturn ctx;\n}\n\nstatic void ieee80211_del_chanctx(struct ieee80211_local *local,\n\t\t\t\t  struct ieee80211_chanctx *ctx)\n{\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tif (!local->use_chanctx) {\n\t\tstruct cfg80211_chan_def *chandef = &local->_oper_chandef;\n\t\t \n\t\tif (chandef->chan->band == NL80211_BAND_S1GHZ)\n\t\t\tchandef->width =\n\t\t\t\tieee80211_s1g_channel_width(chandef->chan);\n\t\telse\n\t\t\tchandef->width = NL80211_CHAN_WIDTH_20_NOHT;\n\t\tchandef->center_freq1 = chandef->chan->center_freq;\n\t\tchandef->freq1_offset = chandef->chan->freq_offset;\n\t\tchandef->center_freq2 = 0;\n\n\t\t \n\t\tWARN_ON(local->hw.conf.radar_enabled &&\n\t\t\t!list_empty(&local->chanctx_list));\n\n\t\tlocal->hw.conf.radar_enabled = false;\n\n\t\tieee80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL);\n\t} else {\n\t\tdrv_remove_chanctx(local, ctx);\n\t}\n\n\tieee80211_recalc_idle(local);\n}\n\nstatic void ieee80211_free_chanctx(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_chanctx *ctx)\n{\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tWARN_ON_ONCE(ieee80211_chanctx_refcount(local, ctx) != 0);\n\n\tlist_del_rcu(&ctx->list);\n\tieee80211_del_chanctx(local, ctx);\n\tkfree_rcu(ctx, rcu_head);\n}\n\nvoid ieee80211_recalc_chanctx_chantype(struct ieee80211_local *local,\n\t\t\t\t       struct ieee80211_chanctx *ctx)\n{\n\tstruct ieee80211_chanctx_conf *conf = &ctx->conf;\n\tstruct ieee80211_sub_if_data *sdata;\n\tconst struct cfg80211_chan_def *compat = NULL;\n\tstruct sta_info *sta;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tint link_id;\n\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\n\t\tfor (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {\n\t\t\tstruct ieee80211_bss_conf *link_conf =\n\t\t\t\trcu_dereference(sdata->vif.link_conf[link_id]);\n\n\t\t\tif (!link_conf)\n\t\t\t\tcontinue;\n\n\t\t\tif (rcu_access_pointer(link_conf->chanctx_conf) != conf)\n\t\t\t\tcontinue;\n\n\t\t\tif (!compat)\n\t\t\t\tcompat = &link_conf->chandef;\n\n\t\t\tcompat = cfg80211_chandef_compatible(&link_conf->chandef,\n\t\t\t\t\t\t\t     compat);\n\t\t\tif (WARN_ON_ONCE(!compat))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(!compat)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t \n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (!sta->uploaded ||\n\t\t    !test_sta_flag(sta, WLAN_STA_TDLS_WIDER_BW) ||\n\t\t    !test_sta_flag(sta, WLAN_STA_AUTHORIZED) ||\n\t\t    !sta->tdls_chandef.chan)\n\t\t\tcontinue;\n\n\t\tcompat = cfg80211_chandef_compatible(&sta->tdls_chandef,\n\t\t\t\t\t\t     compat);\n\t\tif (WARN_ON_ONCE(!compat))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (!compat)\n\t\treturn;\n\n\tieee80211_change_chanctx(local, ctx, ctx, compat);\n}\n\nstatic void ieee80211_recalc_radar_chanctx(struct ieee80211_local *local,\n\t\t\t\t\t   struct ieee80211_chanctx *chanctx)\n{\n\tbool radar_enabled;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\t \n\tlockdep_assert_held(&local->mtx);\n\n\tradar_enabled = ieee80211_chanctx_radar_required(local, chanctx);\n\n\tif (radar_enabled == chanctx->conf.radar_enabled)\n\t\treturn;\n\n\tchanctx->conf.radar_enabled = radar_enabled;\n\n\tif (!local->use_chanctx) {\n\t\tlocal->hw.conf.radar_enabled = chanctx->conf.radar_enabled;\n\t\tieee80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL);\n\t}\n\n\tdrv_change_chanctx(local, chanctx, IEEE80211_CHANCTX_CHANGE_RADAR);\n}\n\nstatic int ieee80211_assign_link_chanctx(struct ieee80211_link_data *link,\n\t\t\t\t\t struct ieee80211_chanctx *new_ctx)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *conf;\n\tstruct ieee80211_chanctx *curr_ctx = NULL;\n\tint ret = 0;\n\n\tif (WARN_ON(sdata->vif.type == NL80211_IFTYPE_NAN))\n\t\treturn -ENOTSUPP;\n\n\tconf = rcu_dereference_protected(link->conf->chanctx_conf,\n\t\t\t\t\t lockdep_is_held(&local->chanctx_mtx));\n\n\tif (conf) {\n\t\tcurr_ctx = container_of(conf, struct ieee80211_chanctx, conf);\n\n\t\tdrv_unassign_vif_chanctx(local, sdata, link->conf, curr_ctx);\n\t\tconf = NULL;\n\t\tlist_del(&link->assigned_chanctx_list);\n\t}\n\n\tif (new_ctx) {\n\t\t \n\t\tieee80211_recalc_chanctx_min_def(local, new_ctx, link);\n\n\t\tret = drv_assign_vif_chanctx(local, sdata, link->conf, new_ctx);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tconf = &new_ctx->conf;\n\t\tlist_add(&link->assigned_chanctx_list,\n\t\t\t &new_ctx->assigned_links);\n\t}\n\nout:\n\trcu_assign_pointer(link->conf->chanctx_conf, conf);\n\n\tsdata->vif.cfg.idle = !conf;\n\n\tif (curr_ctx && ieee80211_chanctx_num_assigned(local, curr_ctx) > 0) {\n\t\tieee80211_recalc_chanctx_chantype(local, curr_ctx);\n\t\tieee80211_recalc_smps_chanctx(local, curr_ctx);\n\t\tieee80211_recalc_radar_chanctx(local, curr_ctx);\n\t\tieee80211_recalc_chanctx_min_def(local, curr_ctx, NULL);\n\t}\n\n\tif (new_ctx && ieee80211_chanctx_num_assigned(local, new_ctx) > 0) {\n\t\tieee80211_recalc_txpower(sdata, false);\n\t\tieee80211_recalc_chanctx_min_def(local, new_ctx, NULL);\n\t}\n\n\tif (sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE &&\n\t    sdata->vif.type != NL80211_IFTYPE_MONITOR)\n\t\tieee80211_vif_cfg_change_notify(sdata, BSS_CHANGED_IDLE);\n\n\tieee80211_check_fast_xmit_iface(sdata);\n\n\treturn ret;\n}\n\nvoid ieee80211_recalc_smps_chanctx(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_chanctx *chanctx)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tu8 rx_chains_static, rx_chains_dynamic;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\trx_chains_static = 1;\n\trx_chains_dynamic = 1;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tu8 needed_static, needed_dynamic;\n\t\tunsigned int link_id;\n\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tswitch (sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tif (!sdata->u.mgd.associated)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tcase NL80211_IFTYPE_OCB:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {\n\t\t\tstruct ieee80211_link_data *link;\n\n\t\t\tlink = rcu_dereference(sdata->link[link_id]);\n\n\t\t\tif (!link)\n\t\t\t\tcontinue;\n\n\t\t\tif (rcu_access_pointer(link->conf->chanctx_conf) != &chanctx->conf)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (link->smps_mode) {\n\t\t\tdefault:\n\t\t\t\tWARN_ONCE(1, \"Invalid SMPS mode %d\\n\",\n\t\t\t\t\t  link->smps_mode);\n\t\t\t\tfallthrough;\n\t\t\tcase IEEE80211_SMPS_OFF:\n\t\t\t\tneeded_static = link->needed_rx_chains;\n\t\t\t\tneeded_dynamic = link->needed_rx_chains;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_SMPS_DYNAMIC:\n\t\t\t\tneeded_static = 1;\n\t\t\t\tneeded_dynamic = link->needed_rx_chains;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_SMPS_STATIC:\n\t\t\t\tneeded_static = 1;\n\t\t\t\tneeded_dynamic = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trx_chains_static = max(rx_chains_static, needed_static);\n\t\t\trx_chains_dynamic = max(rx_chains_dynamic, needed_dynamic);\n\t\t}\n\t}\n\n\t \n\tsdata = rcu_dereference(local->monitor_sdata);\n\tif (sdata &&\n\t    rcu_access_pointer(sdata->vif.bss_conf.chanctx_conf) == &chanctx->conf)\n\t\trx_chains_dynamic = rx_chains_static = local->rx_chains;\n\n\trcu_read_unlock();\n\n\tif (!local->use_chanctx) {\n\t\tif (rx_chains_static > 1)\n\t\t\tlocal->smps_mode = IEEE80211_SMPS_OFF;\n\t\telse if (rx_chains_dynamic > 1)\n\t\t\tlocal->smps_mode = IEEE80211_SMPS_DYNAMIC;\n\t\telse\n\t\t\tlocal->smps_mode = IEEE80211_SMPS_STATIC;\n\t\tieee80211_hw_config(local, 0);\n\t}\n\n\tif (rx_chains_static == chanctx->conf.rx_chains_static &&\n\t    rx_chains_dynamic == chanctx->conf.rx_chains_dynamic)\n\t\treturn;\n\n\tchanctx->conf.rx_chains_static = rx_chains_static;\n\tchanctx->conf.rx_chains_dynamic = rx_chains_dynamic;\n\tdrv_change_chanctx(local, chanctx, IEEE80211_CHANCTX_CHANGE_RX_CHAINS);\n}\n\nstatic void\n__ieee80211_link_copy_chanctx_to_vlans(struct ieee80211_link_data *link,\n\t\t\t\t       bool clear)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tunsigned int link_id = link->link_id;\n\tstruct ieee80211_bss_conf *link_conf = link->conf;\n\tstruct ieee80211_local *local __maybe_unused = sdata->local;\n\tstruct ieee80211_sub_if_data *vlan;\n\tstruct ieee80211_chanctx_conf *conf;\n\n\tif (WARN_ON(sdata->vif.type != NL80211_IFTYPE_AP))\n\t\treturn;\n\n\tlockdep_assert_held(&local->mtx);\n\n\t \n\tconf = rcu_dereference_protected(link_conf->chanctx_conf,\n\t\t\t\t\t lockdep_is_held(&local->chanctx_mtx));\n\tWARN_ON(!conf);\n\n\tif (clear)\n\t\tconf = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list) {\n\t\tstruct ieee80211_bss_conf *vlan_conf;\n\n\t\tvlan_conf = rcu_dereference(vlan->vif.link_conf[link_id]);\n\t\tif (WARN_ON(!vlan_conf))\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(vlan_conf->chanctx_conf, conf);\n\t}\n\trcu_read_unlock();\n}\n\nvoid ieee80211_link_copy_chanctx_to_vlans(struct ieee80211_link_data *link,\n\t\t\t\t\t  bool clear)\n{\n\tstruct ieee80211_local *local = link->sdata->local;\n\n\tmutex_lock(&local->chanctx_mtx);\n\n\t__ieee80211_link_copy_chanctx_to_vlans(link, clear);\n\n\tmutex_unlock(&local->chanctx_mtx);\n}\n\nint ieee80211_link_unreserve_chanctx(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_chanctx *ctx = link->reserved_chanctx;\n\n\tlockdep_assert_held(&sdata->local->chanctx_mtx);\n\n\tif (WARN_ON(!ctx))\n\t\treturn -EINVAL;\n\n\tlist_del(&link->reserved_chanctx_list);\n\tlink->reserved_chanctx = NULL;\n\n\tif (ieee80211_chanctx_refcount(sdata->local, ctx) == 0) {\n\t\tif (ctx->replace_state == IEEE80211_CHANCTX_REPLACES_OTHER) {\n\t\t\tif (WARN_ON(!ctx->replace_ctx))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tWARN_ON(ctx->replace_ctx->replace_state !=\n\t\t\t        IEEE80211_CHANCTX_WILL_BE_REPLACED);\n\t\t\tWARN_ON(ctx->replace_ctx->replace_ctx != ctx);\n\n\t\t\tctx->replace_ctx->replace_ctx = NULL;\n\t\t\tctx->replace_ctx->replace_state =\n\t\t\t\t\tIEEE80211_CHANCTX_REPLACE_NONE;\n\n\t\t\tlist_del_rcu(&ctx->list);\n\t\t\tkfree_rcu(ctx, rcu_head);\n\t\t} else {\n\t\t\tieee80211_free_chanctx(sdata->local, ctx);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint ieee80211_link_reserve_chanctx(struct ieee80211_link_data *link,\n\t\t\t\t   const struct cfg80211_chan_def *chandef,\n\t\t\t\t   enum ieee80211_chanctx_mode mode,\n\t\t\t\t   bool radar_required)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx *new_ctx, *curr_ctx, *ctx;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tcurr_ctx = ieee80211_link_get_chanctx(link);\n\tif (curr_ctx && local->use_chanctx && !local->ops->switch_vif_chanctx)\n\t\treturn -ENOTSUPP;\n\n\tnew_ctx = ieee80211_find_reservation_chanctx(local, chandef, mode);\n\tif (!new_ctx) {\n\t\tif (ieee80211_can_create_new_chanctx(local)) {\n\t\t\tnew_ctx = ieee80211_new_chanctx(local, chandef, mode);\n\t\t\tif (IS_ERR(new_ctx))\n\t\t\t\treturn PTR_ERR(new_ctx);\n\t\t} else {\n\t\t\tif (!curr_ctx ||\n\t\t\t    (curr_ctx->replace_state ==\n\t\t\t     IEEE80211_CHANCTX_WILL_BE_REPLACED) ||\n\t\t\t    !list_empty(&curr_ctx->reserved_links)) {\n\t\t\t\t \n\t\t\t\tlist_for_each_entry(ctx, &local->chanctx_list,\n\t\t\t\t\t\t    list) {\n\t\t\t\t\tif (ctx->replace_state !=\n\t\t\t\t\t    IEEE80211_CHANCTX_REPLACE_NONE)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (!list_empty(&ctx->reserved_links))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcurr_ctx = ctx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!curr_ctx ||\n\t\t\t    (curr_ctx->replace_state ==\n\t\t\t     IEEE80211_CHANCTX_WILL_BE_REPLACED) ||\n\t\t\t    !list_empty(&curr_ctx->reserved_links))\n\t\t\t\treturn -EBUSY;\n\n\t\t\tnew_ctx = ieee80211_alloc_chanctx(local, chandef, mode);\n\t\t\tif (!new_ctx)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnew_ctx->replace_ctx = curr_ctx;\n\t\t\tnew_ctx->replace_state =\n\t\t\t\t\tIEEE80211_CHANCTX_REPLACES_OTHER;\n\n\t\t\tcurr_ctx->replace_ctx = new_ctx;\n\t\t\tcurr_ctx->replace_state =\n\t\t\t\t\tIEEE80211_CHANCTX_WILL_BE_REPLACED;\n\n\t\t\tlist_add_rcu(&new_ctx->list, &local->chanctx_list);\n\t\t}\n\t}\n\n\tlist_add(&link->reserved_chanctx_list, &new_ctx->reserved_links);\n\tlink->reserved_chanctx = new_ctx;\n\tlink->reserved_chandef = *chandef;\n\tlink->reserved_radar_required = radar_required;\n\tlink->reserved_ready = false;\n\n\treturn 0;\n}\n\nstatic void\nieee80211_link_chanctx_reservation_complete(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_OCB:\n\t\tieee80211_queue_work(&sdata->local->hw,\n\t\t\t\t     &link->csa_finalize_work);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\twiphy_delayed_work_queue(sdata->local->hw.wiphy,\n\t\t\t\t\t &link->u.mgd.chswitch_work, 0);\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\tcase NL80211_IFTYPE_NAN:\n\tcase NUM_NL80211_IFTYPES:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nstatic void\nieee80211_link_update_chandef(struct ieee80211_link_data *link,\n\t\t\t      const struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tunsigned int link_id = link->link_id;\n\tstruct ieee80211_sub_if_data *vlan;\n\n\tlink->conf->chandef = *chandef;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list) {\n\t\tstruct ieee80211_bss_conf *vlan_conf;\n\n\t\tvlan_conf = rcu_dereference(vlan->vif.link_conf[link_id]);\n\t\tif (WARN_ON(!vlan_conf))\n\t\t\tcontinue;\n\n\t\tvlan_conf->chandef = *chandef;\n\t}\n\trcu_read_unlock();\n}\n\nstatic int\nieee80211_link_use_reserved_reassign(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_bss_conf *link_conf = link->conf;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_vif_chanctx_switch vif_chsw[1] = {};\n\tstruct ieee80211_chanctx *old_ctx, *new_ctx;\n\tconst struct cfg80211_chan_def *chandef;\n\tu64 changed = 0;\n\tint err;\n\n\tlockdep_assert_held(&local->mtx);\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tnew_ctx = link->reserved_chanctx;\n\told_ctx = ieee80211_link_get_chanctx(link);\n\n\tif (WARN_ON(!link->reserved_ready))\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(!new_ctx))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!old_ctx))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(new_ctx->replace_state ==\n\t\t    IEEE80211_CHANCTX_REPLACES_OTHER))\n\t\treturn -EINVAL;\n\n\tchandef = ieee80211_chanctx_non_reserved_chandef(local, new_ctx,\n\t\t\t\t&link->reserved_chandef);\n\tif (WARN_ON(!chandef))\n\t\treturn -EINVAL;\n\n\tif (link_conf->chandef.width != link->reserved_chandef.width)\n\t\tchanged = BSS_CHANGED_BANDWIDTH;\n\n\tieee80211_link_update_chandef(link, &link->reserved_chandef);\n\n\t_ieee80211_change_chanctx(local, new_ctx, old_ctx, chandef, link);\n\n\tvif_chsw[0].vif = &sdata->vif;\n\tvif_chsw[0].old_ctx = &old_ctx->conf;\n\tvif_chsw[0].new_ctx = &new_ctx->conf;\n\tvif_chsw[0].link_conf = link->conf;\n\n\tlist_del(&link->reserved_chanctx_list);\n\tlink->reserved_chanctx = NULL;\n\n\terr = drv_switch_vif_chanctx(local, vif_chsw, 1,\n\t\t\t\t     CHANCTX_SWMODE_REASSIGN_VIF);\n\tif (err) {\n\t\tif (ieee80211_chanctx_refcount(local, new_ctx) == 0)\n\t\t\tieee80211_free_chanctx(local, new_ctx);\n\n\t\tgoto out;\n\t}\n\n\tlist_move(&link->assigned_chanctx_list, &new_ctx->assigned_links);\n\trcu_assign_pointer(link_conf->chanctx_conf, &new_ctx->conf);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t__ieee80211_link_copy_chanctx_to_vlans(link, false);\n\n\tieee80211_check_fast_xmit_iface(sdata);\n\n\tif (ieee80211_chanctx_refcount(local, old_ctx) == 0)\n\t\tieee80211_free_chanctx(local, old_ctx);\n\n\tieee80211_recalc_chanctx_min_def(local, new_ctx, NULL);\n\tieee80211_recalc_smps_chanctx(local, new_ctx);\n\tieee80211_recalc_radar_chanctx(local, new_ctx);\n\n\tif (changed)\n\t\tieee80211_link_info_change_notify(sdata, link, changed);\n\nout:\n\tieee80211_link_chanctx_reservation_complete(link);\n\treturn err;\n}\n\nstatic int\nieee80211_link_use_reserved_assign(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx *old_ctx, *new_ctx;\n\tconst struct cfg80211_chan_def *chandef;\n\tint err;\n\n\told_ctx = ieee80211_link_get_chanctx(link);\n\tnew_ctx = link->reserved_chanctx;\n\n\tif (WARN_ON(!link->reserved_ready))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(old_ctx))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!new_ctx))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(new_ctx->replace_state ==\n\t\t    IEEE80211_CHANCTX_REPLACES_OTHER))\n\t\treturn -EINVAL;\n\n\tchandef = ieee80211_chanctx_non_reserved_chandef(local, new_ctx,\n\t\t\t\t&link->reserved_chandef);\n\tif (WARN_ON(!chandef))\n\t\treturn -EINVAL;\n\n\tieee80211_change_chanctx(local, new_ctx, new_ctx, chandef);\n\n\tlist_del(&link->reserved_chanctx_list);\n\tlink->reserved_chanctx = NULL;\n\n\terr = ieee80211_assign_link_chanctx(link, new_ctx);\n\tif (err) {\n\t\tif (ieee80211_chanctx_refcount(local, new_ctx) == 0)\n\t\t\tieee80211_free_chanctx(local, new_ctx);\n\n\t\tgoto out;\n\t}\n\nout:\n\tieee80211_link_chanctx_reservation_complete(link);\n\treturn err;\n}\n\nstatic bool\nieee80211_link_has_in_place_reservation(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_chanctx *old_ctx, *new_ctx;\n\n\tlockdep_assert_held(&sdata->local->chanctx_mtx);\n\n\tnew_ctx = link->reserved_chanctx;\n\told_ctx = ieee80211_link_get_chanctx(link);\n\n\tif (!old_ctx)\n\t\treturn false;\n\n\tif (WARN_ON(!new_ctx))\n\t\treturn false;\n\n\tif (old_ctx->replace_state != IEEE80211_CHANCTX_WILL_BE_REPLACED)\n\t\treturn false;\n\n\tif (new_ctx->replace_state != IEEE80211_CHANCTX_REPLACES_OTHER)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int ieee80211_chsw_switch_hwconf(struct ieee80211_local *local,\n\t\t\t\t\tstruct ieee80211_chanctx *new_ctx)\n{\n\tconst struct cfg80211_chan_def *chandef;\n\n\tlockdep_assert_held(&local->mtx);\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tchandef = ieee80211_chanctx_reserved_chandef(local, new_ctx, NULL);\n\tif (WARN_ON(!chandef))\n\t\treturn -EINVAL;\n\n\tlocal->hw.conf.radar_enabled = new_ctx->conf.radar_enabled;\n\tlocal->_oper_chandef = *chandef;\n\tieee80211_hw_config(local, 0);\n\n\treturn 0;\n}\n\nstatic int ieee80211_chsw_switch_vifs(struct ieee80211_local *local,\n\t\t\t\t      int n_vifs)\n{\n\tstruct ieee80211_vif_chanctx_switch *vif_chsw;\n\tstruct ieee80211_link_data *link;\n\tstruct ieee80211_chanctx *ctx, *old_ctx;\n\tint i, err;\n\n\tlockdep_assert_held(&local->mtx);\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tvif_chsw = kcalloc(n_vifs, sizeof(vif_chsw[0]), GFP_KERNEL);\n\tif (!vif_chsw)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tlist_for_each_entry(ctx, &local->chanctx_list, list) {\n\t\tif (ctx->replace_state != IEEE80211_CHANCTX_REPLACES_OTHER)\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(!ctx->replace_ctx)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_for_each_entry(link, &ctx->reserved_links,\n\t\t\t\t    reserved_chanctx_list) {\n\t\t\tif (!ieee80211_link_has_in_place_reservation(link))\n\t\t\t\tcontinue;\n\n\t\t\told_ctx = ieee80211_link_get_chanctx(link);\n\t\t\tvif_chsw[i].vif = &link->sdata->vif;\n\t\t\tvif_chsw[i].old_ctx = &old_ctx->conf;\n\t\t\tvif_chsw[i].new_ctx = &ctx->conf;\n\t\t\tvif_chsw[i].link_conf = link->conf;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\terr = drv_switch_vif_chanctx(local, vif_chsw, n_vifs,\n\t\t\t\t     CHANCTX_SWMODE_SWAP_CONTEXTS);\n\nout:\n\tkfree(vif_chsw);\n\treturn err;\n}\n\nstatic int ieee80211_chsw_switch_ctxs(struct ieee80211_local *local)\n{\n\tstruct ieee80211_chanctx *ctx;\n\tint err;\n\n\tlockdep_assert_held(&local->mtx);\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tlist_for_each_entry(ctx, &local->chanctx_list, list) {\n\t\tif (ctx->replace_state != IEEE80211_CHANCTX_REPLACES_OTHER)\n\t\t\tcontinue;\n\n\t\tif (!list_empty(&ctx->replace_ctx->assigned_links))\n\t\t\tcontinue;\n\n\t\tieee80211_del_chanctx(local, ctx->replace_ctx);\n\t\terr = ieee80211_add_chanctx(local, ctx);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tWARN_ON(ieee80211_add_chanctx(local, ctx));\n\tlist_for_each_entry_continue_reverse(ctx, &local->chanctx_list, list) {\n\t\tif (ctx->replace_state != IEEE80211_CHANCTX_REPLACES_OTHER)\n\t\t\tcontinue;\n\n\t\tif (!list_empty(&ctx->replace_ctx->assigned_links))\n\t\t\tcontinue;\n\n\t\tieee80211_del_chanctx(local, ctx);\n\t\tWARN_ON(ieee80211_add_chanctx(local, ctx->replace_ctx));\n\t}\n\n\treturn err;\n}\n\nstatic int ieee80211_vif_use_reserved_switch(struct ieee80211_local *local)\n{\n\tstruct ieee80211_chanctx *ctx, *ctx_tmp, *old_ctx;\n\tstruct ieee80211_chanctx *new_ctx = NULL;\n\tint err, n_assigned, n_reserved, n_ready;\n\tint n_ctx = 0, n_vifs_switch = 0, n_vifs_assign = 0, n_vifs_ctxless = 0;\n\n\tlockdep_assert_held(&local->mtx);\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\t \n\n\t \n\n\tlist_for_each_entry(ctx, &local->chanctx_list, list) {\n\t\tstruct ieee80211_link_data *link;\n\n\t\tif (ctx->replace_state != IEEE80211_CHANCTX_REPLACES_OTHER)\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(!ctx->replace_ctx)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!local->use_chanctx)\n\t\t\tnew_ctx = ctx;\n\n\t\tn_ctx++;\n\n\t\tn_assigned = 0;\n\t\tn_reserved = 0;\n\t\tn_ready = 0;\n\n\t\tlist_for_each_entry(link, &ctx->replace_ctx->assigned_links,\n\t\t\t\t    assigned_chanctx_list) {\n\t\t\tn_assigned++;\n\t\t\tif (link->reserved_chanctx) {\n\t\t\t\tn_reserved++;\n\t\t\t\tif (link->reserved_ready)\n\t\t\t\t\tn_ready++;\n\t\t\t}\n\t\t}\n\n\t\tif (n_assigned != n_reserved) {\n\t\t\tif (n_ready == n_reserved) {\n\t\t\t\twiphy_info(local->hw.wiphy,\n\t\t\t\t\t   \"channel context reservation cannot be finalized because some interfaces aren't switching\\n\");\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tctx->conf.radar_enabled = false;\n\t\tlist_for_each_entry(link, &ctx->reserved_links,\n\t\t\t\t    reserved_chanctx_list) {\n\t\t\tif (ieee80211_link_has_in_place_reservation(link) &&\n\t\t\t    !link->reserved_ready)\n\t\t\t\treturn -EAGAIN;\n\n\t\t\told_ctx = ieee80211_link_get_chanctx(link);\n\t\t\tif (old_ctx) {\n\t\t\t\tif (old_ctx->replace_state ==\n\t\t\t\t    IEEE80211_CHANCTX_WILL_BE_REPLACED)\n\t\t\t\t\tn_vifs_switch++;\n\t\t\t\telse\n\t\t\t\t\tn_vifs_assign++;\n\t\t\t} else {\n\t\t\t\tn_vifs_ctxless++;\n\t\t\t}\n\n\t\t\tif (link->reserved_radar_required)\n\t\t\t\tctx->conf.radar_enabled = true;\n\t\t}\n\t}\n\n\tif (WARN_ON(n_ctx == 0) ||\n\t    WARN_ON(n_vifs_switch == 0 &&\n\t\t    n_vifs_assign == 0 &&\n\t\t    n_vifs_ctxless == 0) ||\n\t    WARN_ON(n_ctx > 1 && !local->use_chanctx) ||\n\t    WARN_ON(!new_ctx && !local->use_chanctx)) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\n\tif (local->use_chanctx) {\n\t\tif (n_vifs_switch > 0) {\n\t\t\terr = ieee80211_chsw_switch_vifs(local, n_vifs_switch);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tif (n_vifs_assign > 0 || n_vifs_ctxless > 0) {\n\t\t\terr = ieee80211_chsw_switch_ctxs(local);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\terr = ieee80211_chsw_switch_hwconf(local, new_ctx);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\t \n\tlist_for_each_entry(ctx, &local->chanctx_list, list) {\n\t\tstruct ieee80211_link_data *link, *link_tmp;\n\n\t\tif (ctx->replace_state != IEEE80211_CHANCTX_REPLACES_OTHER)\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(!ctx->replace_ctx)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tlist_for_each_entry(link, &ctx->reserved_links,\n\t\t\t\t    reserved_chanctx_list) {\n\t\t\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\t\t\tstruct ieee80211_bss_conf *link_conf = link->conf;\n\t\t\tu64 changed = 0;\n\n\t\t\tif (!ieee80211_link_has_in_place_reservation(link))\n\t\t\t\tcontinue;\n\n\t\t\trcu_assign_pointer(link_conf->chanctx_conf,\n\t\t\t\t\t   &ctx->conf);\n\n\t\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\t\t__ieee80211_link_copy_chanctx_to_vlans(link,\n\t\t\t\t\t\t\t\t       false);\n\n\t\t\tieee80211_check_fast_xmit_iface(sdata);\n\n\t\t\tlink->radar_required = link->reserved_radar_required;\n\n\t\t\tif (link_conf->chandef.width != link->reserved_chandef.width)\n\t\t\t\tchanged = BSS_CHANGED_BANDWIDTH;\n\n\t\t\tieee80211_link_update_chandef(link, &link->reserved_chandef);\n\t\t\tif (changed)\n\t\t\t\tieee80211_link_info_change_notify(sdata,\n\t\t\t\t\t\t\t\t  link,\n\t\t\t\t\t\t\t\t  changed);\n\n\t\t\tieee80211_recalc_txpower(sdata, false);\n\t\t}\n\n\t\tieee80211_recalc_chanctx_chantype(local, ctx);\n\t\tieee80211_recalc_smps_chanctx(local, ctx);\n\t\tieee80211_recalc_radar_chanctx(local, ctx);\n\t\tieee80211_recalc_chanctx_min_def(local, ctx, NULL);\n\n\t\tlist_for_each_entry_safe(link, link_tmp, &ctx->reserved_links,\n\t\t\t\t\t reserved_chanctx_list) {\n\t\t\tif (ieee80211_link_get_chanctx(link) != ctx)\n\t\t\t\tcontinue;\n\n\t\t\tlist_del(&link->reserved_chanctx_list);\n\t\t\tlist_move(&link->assigned_chanctx_list,\n\t\t\t\t  &ctx->assigned_links);\n\t\t\tlink->reserved_chanctx = NULL;\n\n\t\t\tieee80211_link_chanctx_reservation_complete(link);\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry_safe(link, link_tmp, &ctx->reserved_links,\n\t\t\t\t\t reserved_chanctx_list) {\n\t\t\tif (WARN_ON(ieee80211_link_has_in_place_reservation(link)))\n\t\t\t\tcontinue;\n\n\t\t\tif (WARN_ON(link->reserved_chanctx != ctx))\n\t\t\t\tcontinue;\n\n\t\t\tif (!link->reserved_ready)\n\t\t\t\tcontinue;\n\n\t\t\tif (ieee80211_link_get_chanctx(link))\n\t\t\t\terr = ieee80211_link_use_reserved_reassign(link);\n\t\t\telse\n\t\t\t\terr = ieee80211_link_use_reserved_assign(link);\n\n\t\t\tif (err) {\n\t\t\t\tlink_info(link,\n\t\t\t\t\t  \"failed to finalize (re-)assign reservation (err=%d)\\n\",\n\t\t\t\t\t  err);\n\t\t\t\tieee80211_link_unreserve_chanctx(link);\n\t\t\t\tcfg80211_stop_iface(local->hw.wiphy,\n\t\t\t\t\t\t    &link->sdata->wdev,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tlist_for_each_entry_safe(ctx, ctx_tmp, &local->chanctx_list, list) {\n\t\tif (ctx->replace_state != IEEE80211_CHANCTX_WILL_BE_REPLACED)\n\t\t\tcontinue;\n\n\t\tctx->replace_ctx->replace_ctx = NULL;\n\t\tctx->replace_ctx->replace_state =\n\t\t\t\tIEEE80211_CHANCTX_REPLACE_NONE;\n\n\t\tlist_del_rcu(&ctx->list);\n\t\tkfree_rcu(ctx, rcu_head);\n\t}\n\n\treturn 0;\n\nerr:\n\tlist_for_each_entry(ctx, &local->chanctx_list, list) {\n\t\tstruct ieee80211_link_data *link, *link_tmp;\n\n\t\tif (ctx->replace_state != IEEE80211_CHANCTX_REPLACES_OTHER)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_safe(link, link_tmp, &ctx->reserved_links,\n\t\t\t\t\t reserved_chanctx_list) {\n\t\t\tieee80211_link_unreserve_chanctx(link);\n\t\t\tieee80211_link_chanctx_reservation_complete(link);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic void __ieee80211_link_release_channel(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_bss_conf *link_conf = link->conf;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *conf;\n\tstruct ieee80211_chanctx *ctx;\n\tbool use_reserved_switch = false;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tconf = rcu_dereference_protected(link_conf->chanctx_conf,\n\t\t\t\t\t lockdep_is_held(&local->chanctx_mtx));\n\tif (!conf)\n\t\treturn;\n\n\tctx = container_of(conf, struct ieee80211_chanctx, conf);\n\n\tif (link->reserved_chanctx) {\n\t\tif (link->reserved_chanctx->replace_state == IEEE80211_CHANCTX_REPLACES_OTHER &&\n\t\t    ieee80211_chanctx_num_reserved(local, link->reserved_chanctx) > 1)\n\t\t\tuse_reserved_switch = true;\n\n\t\tieee80211_link_unreserve_chanctx(link);\n\t}\n\n\tieee80211_assign_link_chanctx(link, NULL);\n\tif (ieee80211_chanctx_refcount(local, ctx) == 0)\n\t\tieee80211_free_chanctx(local, ctx);\n\n\tlink->radar_required = false;\n\n\t \n\tif (use_reserved_switch)\n\t\tieee80211_vif_use_reserved_switch(local);\n}\n\nint ieee80211_link_use_channel(struct ieee80211_link_data *link,\n\t\t\t       const struct cfg80211_chan_def *chandef,\n\t\t\t       enum ieee80211_chanctx_mode mode)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx *ctx;\n\tu8 radar_detect_width = 0;\n\tint ret;\n\n\tlockdep_assert_held(&local->mtx);\n\n\tif (sdata->vif.active_links &&\n\t    !(sdata->vif.active_links & BIT(link->link_id))) {\n\t\tieee80211_link_update_chandef(link, chandef);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&local->chanctx_mtx);\n\n\tret = cfg80211_chandef_dfs_required(local->hw.wiphy,\n\t\t\t\t\t    chandef,\n\t\t\t\t\t    sdata->wdev.iftype);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0)\n\t\tradar_detect_width = BIT(chandef->width);\n\n\tlink->radar_required = ret;\n\n\tret = ieee80211_check_combinations(sdata, chandef, mode,\n\t\t\t\t\t   radar_detect_width);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t__ieee80211_link_release_channel(link);\n\n\tctx = ieee80211_find_chanctx(local, chandef, mode);\n\tif (!ctx)\n\t\tctx = ieee80211_new_chanctx(local, chandef, mode);\n\tif (IS_ERR(ctx)) {\n\t\tret = PTR_ERR(ctx);\n\t\tgoto out;\n\t}\n\n\tieee80211_link_update_chandef(link, chandef);\n\n\tret = ieee80211_assign_link_chanctx(link, ctx);\n\tif (ret) {\n\t\t \n\t\tif (ieee80211_chanctx_refcount(local, ctx) == 0)\n\t\t\tieee80211_free_chanctx(local, ctx);\n\t\tgoto out;\n\t}\n\n\tieee80211_recalc_smps_chanctx(local, ctx);\n\tieee80211_recalc_radar_chanctx(local, ctx);\n out:\n\tif (ret)\n\t\tlink->radar_required = false;\n\n\tmutex_unlock(&local->chanctx_mtx);\n\treturn ret;\n}\n\nint ieee80211_link_use_reserved_context(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx *new_ctx;\n\tstruct ieee80211_chanctx *old_ctx;\n\tint err;\n\n\tlockdep_assert_held(&local->mtx);\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tnew_ctx = link->reserved_chanctx;\n\told_ctx = ieee80211_link_get_chanctx(link);\n\n\tif (WARN_ON(!new_ctx))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(new_ctx->replace_state ==\n\t\t    IEEE80211_CHANCTX_WILL_BE_REPLACED))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(link->reserved_ready))\n\t\treturn -EINVAL;\n\n\tlink->reserved_ready = true;\n\n\tif (new_ctx->replace_state == IEEE80211_CHANCTX_REPLACE_NONE) {\n\t\tif (old_ctx)\n\t\t\treturn ieee80211_link_use_reserved_reassign(link);\n\n\t\treturn ieee80211_link_use_reserved_assign(link);\n\t}\n\n\t \n\tif ((old_ctx &&\n\t     old_ctx->replace_state == IEEE80211_CHANCTX_WILL_BE_REPLACED) ||\n\t    new_ctx->replace_state == IEEE80211_CHANCTX_REPLACES_OTHER) {\n\t\terr = ieee80211_vif_use_reserved_switch(local);\n\t\tif (err && err != -EAGAIN) {\n\t\t\tif (new_ctx->replace_state ==\n\t\t\t    IEEE80211_CHANCTX_REPLACES_OTHER)\n\t\t\t\treturn err;\n\n\t\t\twiphy_info(local->hw.wiphy,\n\t\t\t\t   \"depending in-place reservation failed (err=%d)\\n\",\n\t\t\t\t   err);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint ieee80211_link_change_bandwidth(struct ieee80211_link_data *link,\n\t\t\t\t    const struct cfg80211_chan_def *chandef,\n\t\t\t\t    u64 *changed)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_bss_conf *link_conf = link->conf;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *conf;\n\tstruct ieee80211_chanctx *ctx;\n\tconst struct cfg80211_chan_def *compat;\n\tint ret;\n\n\tif (!cfg80211_chandef_usable(sdata->local->hw.wiphy, chandef,\n\t\t\t\t     IEEE80211_CHAN_DISABLED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&local->chanctx_mtx);\n\tif (cfg80211_chandef_identical(chandef, &link_conf->chandef)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t    link_conf->chandef.width == NL80211_CHAN_WIDTH_20_NOHT) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tconf = rcu_dereference_protected(link_conf->chanctx_conf,\n\t\t\t\t\t lockdep_is_held(&local->chanctx_mtx));\n\tif (!conf) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tctx = container_of(conf, struct ieee80211_chanctx, conf);\n\n\tcompat = cfg80211_chandef_compatible(&conf->def, chandef);\n\tif (!compat) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (ctx->replace_state) {\n\tcase IEEE80211_CHANCTX_REPLACE_NONE:\n\t\tif (!ieee80211_chanctx_reserved_chandef(local, ctx, compat)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_CHANCTX_WILL_BE_REPLACED:\n\t\t \n\t\tret = -EBUSY;\n\t\tgoto out;\n\tcase IEEE80211_CHANCTX_REPLACES_OTHER:\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tieee80211_link_update_chandef(link, chandef);\n\n\tieee80211_recalc_chanctx_chantype(local, ctx);\n\n\t*changed |= BSS_CHANGED_BANDWIDTH;\n\tret = 0;\n out:\n\tmutex_unlock(&local->chanctx_mtx);\n\treturn ret;\n}\n\nvoid ieee80211_link_release_channel(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\n\tmutex_lock(&sdata->local->chanctx_mtx);\n\tif (rcu_access_pointer(link->conf->chanctx_conf)) {\n\t\tlockdep_assert_held(&sdata->local->mtx);\n\t\t__ieee80211_link_release_channel(link);\n\t}\n\tmutex_unlock(&sdata->local->chanctx_mtx);\n}\n\nvoid ieee80211_link_vlan_copy_chanctx(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tunsigned int link_id = link->link_id;\n\tstruct ieee80211_bss_conf *link_conf = link->conf;\n\tstruct ieee80211_bss_conf *ap_conf;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *ap;\n\tstruct ieee80211_chanctx_conf *conf;\n\n\tif (WARN_ON(sdata->vif.type != NL80211_IFTYPE_AP_VLAN || !sdata->bss))\n\t\treturn;\n\n\tap = container_of(sdata->bss, struct ieee80211_sub_if_data, u.ap);\n\n\tmutex_lock(&local->chanctx_mtx);\n\n\trcu_read_lock();\n\tap_conf = rcu_dereference(ap->vif.link_conf[link_id]);\n\tconf = rcu_dereference_protected(ap_conf->chanctx_conf,\n\t\t\t\t\t lockdep_is_held(&local->chanctx_mtx));\n\trcu_assign_pointer(link_conf->chanctx_conf, conf);\n\trcu_read_unlock();\n\tmutex_unlock(&local->chanctx_mtx);\n}\n\nvoid ieee80211_iter_chan_contexts_atomic(\n\tstruct ieee80211_hw *hw,\n\tvoid (*iter)(struct ieee80211_hw *hw,\n\t\t     struct ieee80211_chanctx_conf *chanctx_conf,\n\t\t     void *data),\n\tvoid *iter_data)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_chanctx *ctx;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ctx, &local->chanctx_list, list)\n\t\tif (ctx->driver_present)\n\t\t\titer(hw, &ctx->conf, iter_data);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(ieee80211_iter_chan_contexts_atomic);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}