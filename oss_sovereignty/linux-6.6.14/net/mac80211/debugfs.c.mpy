{
  "module_name": "debugfs.c",
  "hash_id": "bac6b02729575c82585a486136492f7d64b3cf382b33e9183736d361d8da1a22",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/rtnetlink.h>\n#include <linux/vmalloc.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"rate.h\"\n#include \"debugfs.h\"\n\n#define DEBUGFS_FORMAT_BUFFER_SIZE 100\n\nint mac80211_format_buffer(char __user *userbuf, size_t count,\n\t\t\t\t  loff_t *ppos, char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[DEBUGFS_FORMAT_BUFFER_SIZE];\n\tint res;\n\n\tva_start(args, fmt);\n\tres = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, res);\n}\n\n#define DEBUGFS_READONLY_FILE_FN(name, fmt, value...)\t\t\t\\\nstatic ssize_t name## _read(struct file *file, char __user *userbuf,\t\\\n\t\t\t    size_t count, loff_t *ppos)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ieee80211_local *local = file->private_data;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn mac80211_format_buffer(userbuf, count, ppos, \t\t\\\n\t\t\t\t      fmt \"\\n\", ##value);\t\t\\\n}\n\n#define DEBUGFS_READONLY_FILE_OPS(name)\t\t\t\\\nstatic const struct file_operations name## _ops = {\t\t\t\\\n\t.read = name## _read,\t\t\t\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n};\n\n#define DEBUGFS_READONLY_FILE(name, fmt, value...)\t\t\\\n\tDEBUGFS_READONLY_FILE_FN(name, fmt, value)\t\t\\\n\tDEBUGFS_READONLY_FILE_OPS(name)\n\n#define DEBUGFS_ADD(name)\t\t\t\t\t\t\\\n\tdebugfs_create_file(#name, 0400, phyd, local, &name## _ops)\n\n#define DEBUGFS_ADD_MODE(name, mode)\t\t\t\t\t\\\n\tdebugfs_create_file(#name, mode, phyd, local, &name## _ops);\n\n\nDEBUGFS_READONLY_FILE(hw_conf, \"%x\",\n\t\t      local->hw.conf.flags);\nDEBUGFS_READONLY_FILE(user_power, \"%d\",\n\t\t      local->user_power_level);\nDEBUGFS_READONLY_FILE(power, \"%d\",\n\t\t      local->hw.conf.power_level);\nDEBUGFS_READONLY_FILE(total_ps_buffered, \"%d\",\n\t\t      local->total_ps_buffered);\nDEBUGFS_READONLY_FILE(wep_iv, \"%#08x\",\n\t\t      local->wep_iv & 0xffffff);\nDEBUGFS_READONLY_FILE(rate_ctrl_alg, \"%s\",\n\tlocal->rate_ctrl ? local->rate_ctrl->ops->name : \"hw/driver\");\n\nstatic ssize_t aqm_read(struct file *file,\n\t\t\tchar __user *user_buf,\n\t\t\tsize_t count,\n\t\t\tloff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\tstruct fq *fq = &local->fq;\n\tchar buf[200];\n\tint len = 0;\n\n\tspin_lock_bh(&local->fq.lock);\n\trcu_read_lock();\n\n\tlen = scnprintf(buf, sizeof(buf),\n\t\t\t\"access name value\\n\"\n\t\t\t\"R fq_flows_cnt %u\\n\"\n\t\t\t\"R fq_backlog %u\\n\"\n\t\t\t\"R fq_overlimit %u\\n\"\n\t\t\t\"R fq_overmemory %u\\n\"\n\t\t\t\"R fq_collisions %u\\n\"\n\t\t\t\"R fq_memory_usage %u\\n\"\n\t\t\t\"RW fq_memory_limit %u\\n\"\n\t\t\t\"RW fq_limit %u\\n\"\n\t\t\t\"RW fq_quantum %u\\n\",\n\t\t\tfq->flows_cnt,\n\t\t\tfq->backlog,\n\t\t\tfq->overmemory,\n\t\t\tfq->overlimit,\n\t\t\tfq->collisions,\n\t\t\tfq->memory_usage,\n\t\t\tfq->memory_limit,\n\t\t\tfq->limit,\n\t\t\tfq->quantum);\n\n\trcu_read_unlock();\n\tspin_unlock_bh(&local->fq.lock);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t       buf, len);\n}\n\nstatic ssize_t aqm_write(struct file *file,\n\t\t\t const char __user *user_buf,\n\t\t\t size_t count,\n\t\t\t loff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\tchar buf[100];\n\n\tif (count >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, user_buf, count))\n\t\treturn -EFAULT;\n\n\tif (count && buf[count - 1] == '\\n')\n\t\tbuf[count - 1] = '\\0';\n\telse\n\t\tbuf[count] = '\\0';\n\n\tif (sscanf(buf, \"fq_limit %u\", &local->fq.limit) == 1)\n\t\treturn count;\n\telse if (sscanf(buf, \"fq_memory_limit %u\", &local->fq.memory_limit) == 1)\n\t\treturn count;\n\telse if (sscanf(buf, \"fq_quantum %u\", &local->fq.quantum) == 1)\n\t\treturn count;\n\n\treturn -EINVAL;\n}\n\nstatic const struct file_operations aqm_ops = {\n\t.write = aqm_write,\n\t.read = aqm_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t airtime_flags_read(struct file *file,\n\t\t\t\t  char __user *user_buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\tchar buf[128] = {}, *pos, *end;\n\n\tpos = buf;\n\tend = pos + sizeof(buf) - 1;\n\n\tif (local->airtime_flags & AIRTIME_USE_TX)\n\t\tpos += scnprintf(pos, end - pos, \"AIRTIME_TX\\t(%lx)\\n\",\n\t\t\t\t AIRTIME_USE_TX);\n\tif (local->airtime_flags & AIRTIME_USE_RX)\n\t\tpos += scnprintf(pos, end - pos, \"AIRTIME_RX\\t(%lx)\\n\",\n\t\t\t\t AIRTIME_USE_RX);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf,\n\t\t\t\t       strlen(buf));\n}\n\nstatic ssize_t airtime_flags_write(struct file *file,\n\t\t\t\t   const char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\tchar buf[16];\n\n\tif (count >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, user_buf, count))\n\t\treturn -EFAULT;\n\n\tif (count && buf[count - 1] == '\\n')\n\t\tbuf[count - 1] = '\\0';\n\telse\n\t\tbuf[count] = '\\0';\n\n\tif (kstrtou16(buf, 0, &local->airtime_flags))\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic const struct file_operations airtime_flags_ops = {\n\t.write = airtime_flags_write,\n\t.read = airtime_flags_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t aql_pending_read(struct file *file,\n\t\t\t\tchar __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\tchar buf[400];\n\tint len = 0;\n\n\tlen = scnprintf(buf, sizeof(buf),\n\t\t\t\"AC     AQL pending\\n\"\n\t\t\t\"VO     %u us\\n\"\n\t\t\t\"VI     %u us\\n\"\n\t\t\t\"BE     %u us\\n\"\n\t\t\t\"BK     %u us\\n\"\n\t\t\t\"total  %u us\\n\",\n\t\t\tatomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_VO]),\n\t\t\tatomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_VI]),\n\t\t\tatomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_BE]),\n\t\t\tatomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_BK]),\n\t\t\tatomic_read(&local->aql_total_pending_airtime));\n\treturn simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t       buf, len);\n}\n\nstatic const struct file_operations aql_pending_ops = {\n\t.read = aql_pending_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t aql_txq_limit_read(struct file *file,\n\t\t\t\t  char __user *user_buf,\n\t\t\t\t  size_t count,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\tchar buf[400];\n\tint len = 0;\n\n\tlen = scnprintf(buf, sizeof(buf),\n\t\t\t\"AC\tAQL limit low\tAQL limit high\\n\"\n\t\t\t\"VO\t%u\t\t%u\\n\"\n\t\t\t\"VI\t%u\t\t%u\\n\"\n\t\t\t\"BE\t%u\t\t%u\\n\"\n\t\t\t\"BK\t%u\t\t%u\\n\",\n\t\t\tlocal->aql_txq_limit_low[IEEE80211_AC_VO],\n\t\t\tlocal->aql_txq_limit_high[IEEE80211_AC_VO],\n\t\t\tlocal->aql_txq_limit_low[IEEE80211_AC_VI],\n\t\t\tlocal->aql_txq_limit_high[IEEE80211_AC_VI],\n\t\t\tlocal->aql_txq_limit_low[IEEE80211_AC_BE],\n\t\t\tlocal->aql_txq_limit_high[IEEE80211_AC_BE],\n\t\t\tlocal->aql_txq_limit_low[IEEE80211_AC_BK],\n\t\t\tlocal->aql_txq_limit_high[IEEE80211_AC_BK]);\n\treturn simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t       buf, len);\n}\n\nstatic ssize_t aql_txq_limit_write(struct file *file,\n\t\t\t\t   const char __user *user_buf,\n\t\t\t\t   size_t count,\n\t\t\t\t   loff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\tchar buf[100];\n\tu32 ac, q_limit_low, q_limit_high, q_limit_low_old, q_limit_high_old;\n\tstruct sta_info *sta;\n\n\tif (count >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, user_buf, count))\n\t\treturn -EFAULT;\n\n\tif (count && buf[count - 1] == '\\n')\n\t\tbuf[count - 1] = '\\0';\n\telse\n\t\tbuf[count] = '\\0';\n\n\tif (sscanf(buf, \"%u %u %u\", &ac, &q_limit_low, &q_limit_high) != 3)\n\t\treturn -EINVAL;\n\n\tif (ac >= IEEE80211_NUM_ACS)\n\t\treturn -EINVAL;\n\n\tq_limit_low_old = local->aql_txq_limit_low[ac];\n\tq_limit_high_old = local->aql_txq_limit_high[ac];\n\n\tlocal->aql_txq_limit_low[ac] = q_limit_low;\n\tlocal->aql_txq_limit_high[ac] = q_limit_high;\n\n\tmutex_lock(&local->sta_mtx);\n\tlist_for_each_entry(sta, &local->sta_list, list) {\n\t\t \n\t\tif (sta->airtime[ac].aql_limit_low == q_limit_low_old &&\n\t\t    sta->airtime[ac].aql_limit_high == q_limit_high_old) {\n\t\t\tsta->airtime[ac].aql_limit_low = q_limit_low;\n\t\t\tsta->airtime[ac].aql_limit_high = q_limit_high;\n\t\t}\n\t}\n\tmutex_unlock(&local->sta_mtx);\n\treturn count;\n}\n\nstatic const struct file_operations aql_txq_limit_ops = {\n\t.write = aql_txq_limit_write,\n\t.read = aql_txq_limit_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t aql_enable_read(struct file *file, char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar buf[3];\n\tint len;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%d\\n\",\n\t\t\t!static_key_false(&aql_disable.key));\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t aql_enable_write(struct file *file, const char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tbool aql_disabled = static_key_false(&aql_disable.key);\n\tchar buf[3];\n\tsize_t len;\n\n\tif (count > sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, user_buf, count))\n\t\treturn -EFAULT;\n\n\tbuf[sizeof(buf) - 1] = '\\0';\n\tlen = strlen(buf);\n\tif (len > 0 && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = 0;\n\n\tif (buf[0] == '0' && buf[1] == '\\0') {\n\t\tif (!aql_disabled)\n\t\t\tstatic_branch_inc(&aql_disable);\n\t} else if (buf[0] == '1' && buf[1] == '\\0') {\n\t\tif (aql_disabled)\n\t\t\tstatic_branch_dec(&aql_disable);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations aql_enable_ops = {\n\t.write = aql_enable_write,\n\t.read = aql_enable_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t force_tx_status_read(struct file *file,\n\t\t\t\t    char __user *user_buf,\n\t\t\t\t    size_t count,\n\t\t\t\t    loff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\tchar buf[3];\n\tint len = 0;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%d\\n\", (int)local->force_tx_status);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t       buf, len);\n}\n\nstatic ssize_t force_tx_status_write(struct file *file,\n\t\t\t\t     const char __user *user_buf,\n\t\t\t\t     size_t count,\n\t\t\t\t     loff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\tchar buf[3];\n\n\tif (count >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, user_buf, count))\n\t\treturn -EFAULT;\n\n\tif (count && buf[count - 1] == '\\n')\n\t\tbuf[count - 1] = '\\0';\n\telse\n\t\tbuf[count] = '\\0';\n\n\tif (buf[0] == '0' && buf[1] == '\\0')\n\t\tlocal->force_tx_status = 0;\n\telse if (buf[0] == '1' && buf[1] == '\\0')\n\t\tlocal->force_tx_status = 1;\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic const struct file_operations force_tx_status_ops = {\n\t.write = force_tx_status_write,\n\t.read = force_tx_status_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\n#ifdef CONFIG_PM\nstatic ssize_t reset_write(struct file *file, const char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\tint ret;\n\n\trtnl_lock();\n\twiphy_lock(local->hw.wiphy);\n\t__ieee80211_suspend(&local->hw, NULL);\n\tret = __ieee80211_resume(&local->hw);\n\twiphy_unlock(local->hw.wiphy);\n\n\tif (ret)\n\t\tcfg80211_shutdown_all_interfaces(local->hw.wiphy);\n\n\trtnl_unlock();\n\n\treturn count;\n}\n\nstatic const struct file_operations reset_ops = {\n\t.write = reset_write,\n\t.open = simple_open,\n\t.llseek = noop_llseek,\n};\n#endif\n\nstatic const char *hw_flag_names[] = {\n#define FLAG(F)\t[IEEE80211_HW_##F] = #F\n\tFLAG(HAS_RATE_CONTROL),\n\tFLAG(RX_INCLUDES_FCS),\n\tFLAG(HOST_BROADCAST_PS_BUFFERING),\n\tFLAG(SIGNAL_UNSPEC),\n\tFLAG(SIGNAL_DBM),\n\tFLAG(NEED_DTIM_BEFORE_ASSOC),\n\tFLAG(SPECTRUM_MGMT),\n\tFLAG(AMPDU_AGGREGATION),\n\tFLAG(SUPPORTS_PS),\n\tFLAG(PS_NULLFUNC_STACK),\n\tFLAG(SUPPORTS_DYNAMIC_PS),\n\tFLAG(MFP_CAPABLE),\n\tFLAG(WANT_MONITOR_VIF),\n\tFLAG(NO_AUTO_VIF),\n\tFLAG(SW_CRYPTO_CONTROL),\n\tFLAG(SUPPORT_FAST_XMIT),\n\tFLAG(REPORTS_TX_ACK_STATUS),\n\tFLAG(CONNECTION_MONITOR),\n\tFLAG(QUEUE_CONTROL),\n\tFLAG(SUPPORTS_PER_STA_GTK),\n\tFLAG(AP_LINK_PS),\n\tFLAG(TX_AMPDU_SETUP_IN_HW),\n\tFLAG(SUPPORTS_RC_TABLE),\n\tFLAG(P2P_DEV_ADDR_FOR_INTF),\n\tFLAG(TIMING_BEACON_ONLY),\n\tFLAG(SUPPORTS_HT_CCK_RATES),\n\tFLAG(CHANCTX_STA_CSA),\n\tFLAG(SUPPORTS_CLONED_SKBS),\n\tFLAG(SINGLE_SCAN_ON_ALL_BANDS),\n\tFLAG(TDLS_WIDER_BW),\n\tFLAG(SUPPORTS_AMSDU_IN_AMPDU),\n\tFLAG(BEACON_TX_STATUS),\n\tFLAG(NEEDS_UNIQUE_STA_ADDR),\n\tFLAG(SUPPORTS_REORDERING_BUFFER),\n\tFLAG(USES_RSS),\n\tFLAG(TX_AMSDU),\n\tFLAG(TX_FRAG_LIST),\n\tFLAG(REPORTS_LOW_ACK),\n\tFLAG(SUPPORTS_TX_FRAG),\n\tFLAG(SUPPORTS_TDLS_BUFFER_STA),\n\tFLAG(DEAUTH_NEED_MGD_TX_PREP),\n\tFLAG(DOESNT_SUPPORT_QOS_NDP),\n\tFLAG(BUFF_MMPDU_TXQ),\n\tFLAG(SUPPORTS_VHT_EXT_NSS_BW),\n\tFLAG(STA_MMPDU_TXQ),\n\tFLAG(TX_STATUS_NO_AMPDU_LEN),\n\tFLAG(SUPPORTS_MULTI_BSSID),\n\tFLAG(SUPPORTS_ONLY_HE_MULTI_BSSID),\n\tFLAG(AMPDU_KEYBORDER_SUPPORT),\n\tFLAG(SUPPORTS_TX_ENCAP_OFFLOAD),\n\tFLAG(SUPPORTS_RX_DECAP_OFFLOAD),\n\tFLAG(SUPPORTS_CONC_MON_RX_DECAP),\n\tFLAG(DETECTS_COLOR_COLLISION),\n\tFLAG(MLO_MCAST_MULTI_LINK_TX),\n#undef FLAG\n};\n\nstatic ssize_t hwflags_read(struct file *file, char __user *user_buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\tsize_t bufsz = 30 * NUM_IEEE80211_HW_FLAGS;\n\tchar *buf = kzalloc(bufsz, GFP_KERNEL);\n\tchar *pos = buf, *end = buf + bufsz - 1;\n\tssize_t rv;\n\tint i;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tBUILD_BUG_ON(ARRAY_SIZE(hw_flag_names) != NUM_IEEE80211_HW_FLAGS);\n\n\tfor (i = 0; i < NUM_IEEE80211_HW_FLAGS; i++) {\n\t\tif (test_bit(i, local->hw.flags))\n\t\t\tpos += scnprintf(pos, end - pos, \"%s\\n\",\n\t\t\t\t\t hw_flag_names[i]);\n\t}\n\n\trv = simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));\n\tkfree(buf);\n\treturn rv;\n}\n\nstatic ssize_t misc_read(struct file *file, char __user *user_buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\t \n\tsize_t bufsz = IEEE80211_MAX_QUEUES * 16 + 9;\n\tchar *buf;\n\tchar *pos, *end;\n\tssize_t rv;\n\tint i;\n\tint ln;\n\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpos = buf;\n\tend = buf + bufsz - 1;\n\n\tpos += scnprintf(pos, end - pos, \"pending:\\n\");\n\n\tfor (i = 0; i < IEEE80211_MAX_QUEUES; i++) {\n\t\tln = skb_queue_len(&local->pending[i]);\n\t\tpos += scnprintf(pos, end - pos, \"[%i] %d\\n\",\n\t\t\t\t i, ln);\n\t}\n\n\trv = simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));\n\tkfree(buf);\n\treturn rv;\n}\n\nstatic ssize_t queues_read(struct file *file, char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_local *local = file->private_data;\n\tunsigned long flags;\n\tchar buf[IEEE80211_MAX_QUEUES * 20];\n\tint q, res = 0;\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\tfor (q = 0; q < local->hw.queues; q++)\n\t\tres += sprintf(buf + res, \"%02d: %#.8lx/%d\\n\", q,\n\t\t\t\tlocal->queue_stop_reasons[q],\n\t\t\t\tskb_queue_len(&local->pending[q]));\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, res);\n}\n\nDEBUGFS_READONLY_FILE_OPS(hwflags);\nDEBUGFS_READONLY_FILE_OPS(queues);\nDEBUGFS_READONLY_FILE_OPS(misc);\n\n \n\nstatic ssize_t format_devstat_counter(struct ieee80211_local *local,\n\tchar __user *userbuf,\n\tsize_t count, loff_t *ppos,\n\tint (*printvalue)(struct ieee80211_low_level_stats *stats, char *buf,\n\t\t\t  int buflen))\n{\n\tstruct ieee80211_low_level_stats stats;\n\tchar buf[20];\n\tint res;\n\n\trtnl_lock();\n\tres = drv_get_stats(local, &stats);\n\trtnl_unlock();\n\tif (res)\n\t\treturn res;\n\tres = printvalue(&stats, buf, sizeof(buf));\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, res);\n}\n\n#define DEBUGFS_DEVSTATS_FILE(name)\t\t\t\t\t\\\nstatic int print_devstats_##name(struct ieee80211_low_level_stats *stats,\\\n\t\t\t\t char *buf, int buflen)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn scnprintf(buf, buflen, \"%u\\n\", stats->name);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t stats_ ##name## _read(struct file *file,\t\t\t\\\n\t\t\t\t     char __user *userbuf,\t\t\\\n\t\t\t\t     size_t count, loff_t *ppos)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn format_devstat_counter(file->private_data,\t\t\\\n\t\t\t\t      userbuf,\t\t\t\t\\\n\t\t\t\t      count,\t\t\t\t\\\n\t\t\t\t      ppos,\t\t\t\t\\\n\t\t\t\t      print_devstats_##name);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic const struct file_operations stats_ ##name## _ops = {\t\t\\\n\t.read = stats_ ##name## _read,\t\t\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n};\n\n#ifdef CONFIG_MAC80211_DEBUG_COUNTERS\n#define DEBUGFS_STATS_ADD(name)\t\t\t\t\t\\\n\tdebugfs_create_u32(#name, 0400, statsd, &local->name);\n#endif\n#define DEBUGFS_DEVSTATS_ADD(name)\t\t\t\t\t\\\n\tdebugfs_create_file(#name, 0400, statsd, local, &stats_ ##name## _ops);\n\nDEBUGFS_DEVSTATS_FILE(dot11ACKFailureCount);\nDEBUGFS_DEVSTATS_FILE(dot11RTSFailureCount);\nDEBUGFS_DEVSTATS_FILE(dot11FCSErrorCount);\nDEBUGFS_DEVSTATS_FILE(dot11RTSSuccessCount);\n\nvoid debugfs_hw_add(struct ieee80211_local *local)\n{\n\tstruct dentry *phyd = local->hw.wiphy->debugfsdir;\n\tstruct dentry *statsd;\n\n\tif (!phyd)\n\t\treturn;\n\n\tlocal->debugfs.keys = debugfs_create_dir(\"keys\", phyd);\n\n\tDEBUGFS_ADD(total_ps_buffered);\n\tDEBUGFS_ADD(wep_iv);\n\tDEBUGFS_ADD(rate_ctrl_alg);\n\tDEBUGFS_ADD(queues);\n\tDEBUGFS_ADD(misc);\n#ifdef CONFIG_PM\n\tDEBUGFS_ADD_MODE(reset, 0200);\n#endif\n\tDEBUGFS_ADD(hwflags);\n\tDEBUGFS_ADD(user_power);\n\tDEBUGFS_ADD(power);\n\tDEBUGFS_ADD(hw_conf);\n\tDEBUGFS_ADD_MODE(force_tx_status, 0600);\n\tDEBUGFS_ADD_MODE(aql_enable, 0600);\n\tDEBUGFS_ADD(aql_pending);\n\tDEBUGFS_ADD_MODE(aqm, 0600);\n\n\tDEBUGFS_ADD_MODE(airtime_flags, 0600);\n\n\tDEBUGFS_ADD(aql_txq_limit);\n\tdebugfs_create_u32(\"aql_threshold\", 0600,\n\t\t\t   phyd, &local->aql_threshold);\n\n\tstatsd = debugfs_create_dir(\"statistics\", phyd);\n\n#ifdef CONFIG_MAC80211_DEBUG_COUNTERS\n\tDEBUGFS_STATS_ADD(dot11TransmittedFragmentCount);\n\tDEBUGFS_STATS_ADD(dot11MulticastTransmittedFrameCount);\n\tDEBUGFS_STATS_ADD(dot11FailedCount);\n\tDEBUGFS_STATS_ADD(dot11RetryCount);\n\tDEBUGFS_STATS_ADD(dot11MultipleRetryCount);\n\tDEBUGFS_STATS_ADD(dot11FrameDuplicateCount);\n\tDEBUGFS_STATS_ADD(dot11ReceivedFragmentCount);\n\tDEBUGFS_STATS_ADD(dot11MulticastReceivedFrameCount);\n\tDEBUGFS_STATS_ADD(dot11TransmittedFrameCount);\n\tDEBUGFS_STATS_ADD(tx_handlers_drop);\n\tDEBUGFS_STATS_ADD(tx_handlers_queued);\n\tDEBUGFS_STATS_ADD(tx_handlers_drop_wep);\n\tDEBUGFS_STATS_ADD(tx_handlers_drop_not_assoc);\n\tDEBUGFS_STATS_ADD(tx_handlers_drop_unauth_port);\n\tDEBUGFS_STATS_ADD(rx_handlers_drop);\n\tDEBUGFS_STATS_ADD(rx_handlers_queued);\n\tDEBUGFS_STATS_ADD(rx_handlers_drop_nullfunc);\n\tDEBUGFS_STATS_ADD(rx_handlers_drop_defrag);\n\tDEBUGFS_STATS_ADD(tx_expand_skb_head);\n\tDEBUGFS_STATS_ADD(tx_expand_skb_head_cloned);\n\tDEBUGFS_STATS_ADD(rx_expand_skb_head_defrag);\n\tDEBUGFS_STATS_ADD(rx_handlers_fragments);\n\tDEBUGFS_STATS_ADD(tx_status_drop);\n#endif\n\tDEBUGFS_DEVSTATS_ADD(dot11ACKFailureCount);\n\tDEBUGFS_DEVSTATS_ADD(dot11RTSFailureCount);\n\tDEBUGFS_DEVSTATS_ADD(dot11FCSErrorCount);\n\tDEBUGFS_DEVSTATS_ADD(dot11RTSSuccessCount);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}