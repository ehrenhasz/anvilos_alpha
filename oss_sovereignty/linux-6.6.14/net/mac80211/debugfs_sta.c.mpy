{
  "module_name": "debugfs_sta.c",
  "hash_id": "3acb9eae065a7db1abfe01a181dd3eec4fa8f35711a26bc2130ae7183b8b10e0",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/debugfs_sta.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/ieee80211.h>\n#include \"ieee80211_i.h\"\n#include \"debugfs.h\"\n#include \"debugfs_sta.h\"\n#include \"sta_info.h\"\n#include \"driver-ops.h\"\n\n \n\n#define STA_READ(name, field, format_string)\t\t\t\t\\\nstatic ssize_t sta_ ##name## _read(struct file *file,\t\t\t\\\n\t\t\t\t   char __user *userbuf,\t\t\\\n\t\t\t\t   size_t count, loff_t *ppos)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sta_info *sta = file->private_data;\t\t\t\\\n\treturn mac80211_format_buffer(userbuf, count, ppos, \t\t\\\n\t\t\t\t      format_string, sta->field);\t\\\n}\n#define STA_READ_D(name, field) STA_READ(name, field, \"%d\\n\")\n\n#define STA_OPS(name)\t\t\t\t\t\t\t\\\nstatic const struct file_operations sta_ ##name## _ops = {\t\t\\\n\t.read = sta_##name##_read,\t\t\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n}\n\n#define STA_OPS_RW(name)\t\t\t\t\t\t\\\nstatic const struct file_operations sta_ ##name## _ops = {\t\t\\\n\t.read = sta_##name##_read,\t\t\t\t\t\\\n\t.write = sta_##name##_write,\t\t\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n}\n\n#define STA_FILE(name, field, format)\t\t\t\t\t\\\n\t\tSTA_READ_##format(name, field)\t\t\t\t\\\n\t\tSTA_OPS(name)\n\nSTA_FILE(aid, sta.aid, D);\n\nstatic const char * const sta_flag_names[] = {\n#define FLAG(F) [WLAN_STA_##F] = #F\n\tFLAG(AUTH),\n\tFLAG(ASSOC),\n\tFLAG(PS_STA),\n\tFLAG(AUTHORIZED),\n\tFLAG(SHORT_PREAMBLE),\n\tFLAG(WDS),\n\tFLAG(CLEAR_PS_FILT),\n\tFLAG(MFP),\n\tFLAG(BLOCK_BA),\n\tFLAG(PS_DRIVER),\n\tFLAG(PSPOLL),\n\tFLAG(TDLS_PEER),\n\tFLAG(TDLS_PEER_AUTH),\n\tFLAG(TDLS_INITIATOR),\n\tFLAG(TDLS_CHAN_SWITCH),\n\tFLAG(TDLS_OFF_CHANNEL),\n\tFLAG(TDLS_WIDER_BW),\n\tFLAG(UAPSD),\n\tFLAG(SP),\n\tFLAG(4ADDR_EVENT),\n\tFLAG(INSERTED),\n\tFLAG(RATE_CONTROL),\n\tFLAG(TOFFSET_KNOWN),\n\tFLAG(MPSP_OWNER),\n\tFLAG(MPSP_RECIPIENT),\n\tFLAG(PS_DELIVER),\n\tFLAG(USES_ENCRYPTION),\n\tFLAG(DECAP_OFFLOAD),\n#undef FLAG\n};\n\nstatic ssize_t sta_flags_read(struct file *file, char __user *userbuf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar buf[16 * NUM_WLAN_STA_FLAGS], *pos = buf;\n\tchar *end = buf + sizeof(buf) - 1;\n\tstruct sta_info *sta = file->private_data;\n\tunsigned int flg;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(sta_flag_names) != NUM_WLAN_STA_FLAGS);\n\n\tfor (flg = 0; flg < NUM_WLAN_STA_FLAGS; flg++) {\n\t\tif (test_sta_flag(sta, flg))\n\t\t\tpos += scnprintf(pos, end - pos, \"%s\\n\",\n\t\t\t\t\t sta_flag_names[flg]);\n\t}\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, strlen(buf));\n}\nSTA_OPS(flags);\n\nstatic ssize_t sta_num_ps_buf_frames_read(struct file *file,\n\t\t\t\t\t  char __user *userbuf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct sta_info *sta = file->private_data;\n\tchar buf[17*IEEE80211_NUM_ACS], *p = buf;\n\tint ac;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\tp += scnprintf(p, sizeof(buf)+buf-p, \"AC%d: %d\\n\", ac,\n\t\t\t       skb_queue_len(&sta->ps_tx_buf[ac]) +\n\t\t\t       skb_queue_len(&sta->tx_filtered[ac]));\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\n}\nSTA_OPS(num_ps_buf_frames);\n\nstatic ssize_t sta_last_seq_ctrl_read(struct file *file, char __user *userbuf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar buf[15*IEEE80211_NUM_TIDS], *p = buf;\n\tint i;\n\tstruct sta_info *sta = file->private_data;\n\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\n\t\tp += scnprintf(p, sizeof(buf)+buf-p, \"%x \",\n\t\t\t       le16_to_cpu(sta->last_seq_ctrl[i]));\n\tp += scnprintf(p, sizeof(buf)+buf-p, \"\\n\");\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\n}\nSTA_OPS(last_seq_ctrl);\n\n#define AQM_TXQ_ENTRY_LEN 130\n\nstatic ssize_t sta_aqm_read(struct file *file, char __user *userbuf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct sta_info *sta = file->private_data;\n\tstruct ieee80211_local *local = sta->local;\n\tsize_t bufsz = AQM_TXQ_ENTRY_LEN * (IEEE80211_NUM_TIDS + 2);\n\tchar *buf = kzalloc(bufsz, GFP_KERNEL), *p = buf;\n\tstruct txq_info *txqi;\n\tssize_t rv;\n\tint i;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_bh(&local->fq.lock);\n\trcu_read_lock();\n\n\tp += scnprintf(p,\n\t\t       bufsz + buf - p,\n\t\t       \"target %uus interval %uus ecn %s\\n\",\n\t\t       codel_time_to_us(sta->cparams.target),\n\t\t       codel_time_to_us(sta->cparams.interval),\n\t\t       sta->cparams.ecn ? \"yes\" : \"no\");\n\tp += scnprintf(p,\n\t\t       bufsz + buf - p,\n\t\t       \"tid ac backlog-bytes backlog-packets new-flows drops marks overlimit collisions tx-bytes tx-packets flags\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {\n\t\tif (!sta->sta.txq[i])\n\t\t\tcontinue;\n\t\ttxqi = to_txq_info(sta->sta.txq[i]);\n\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t       \"%d %d %u %u %u %u %u %u %u %u %u 0x%lx(%s%s%s%s)\\n\",\n\t\t\t       txqi->txq.tid,\n\t\t\t       txqi->txq.ac,\n\t\t\t       txqi->tin.backlog_bytes,\n\t\t\t       txqi->tin.backlog_packets,\n\t\t\t       txqi->tin.flows,\n\t\t\t       txqi->cstats.drop_count,\n\t\t\t       txqi->cstats.ecn_mark,\n\t\t\t       txqi->tin.overlimit,\n\t\t\t       txqi->tin.collisions,\n\t\t\t       txqi->tin.tx_bytes,\n\t\t\t       txqi->tin.tx_packets,\n\t\t\t       txqi->flags,\n\t\t\t       test_bit(IEEE80211_TXQ_STOP, &txqi->flags) ? \"STOP\" : \"RUN\",\n\t\t\t       test_bit(IEEE80211_TXQ_AMPDU, &txqi->flags) ? \" AMPDU\" : \"\",\n\t\t\t       test_bit(IEEE80211_TXQ_NO_AMSDU, &txqi->flags) ? \" NO-AMSDU\" : \"\",\n\t\t\t       test_bit(IEEE80211_TXQ_DIRTY, &txqi->flags) ? \" DIRTY\" : \"\");\n\t}\n\n\trcu_read_unlock();\n\tspin_unlock_bh(&local->fq.lock);\n\n\trv = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\n\tkfree(buf);\n\treturn rv;\n}\nSTA_OPS(aqm);\n\nstatic ssize_t sta_airtime_read(struct file *file, char __user *userbuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct sta_info *sta = file->private_data;\n\tstruct ieee80211_local *local = sta->sdata->local;\n\tsize_t bufsz = 400;\n\tchar *buf = kzalloc(bufsz, GFP_KERNEL), *p = buf;\n\tu64 rx_airtime = 0, tx_airtime = 0;\n\ts32 deficit[IEEE80211_NUM_ACS];\n\tssize_t rv;\n\tint ac;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tspin_lock_bh(&local->active_txq_lock[ac]);\n\t\trx_airtime += sta->airtime[ac].rx_airtime;\n\t\ttx_airtime += sta->airtime[ac].tx_airtime;\n\t\tdeficit[ac] = sta->airtime[ac].deficit;\n\t\tspin_unlock_bh(&local->active_txq_lock[ac]);\n\t}\n\n\tp += scnprintf(p, bufsz + buf - p,\n\t\t\"RX: %llu us\\nTX: %llu us\\nWeight: %u\\n\"\n\t\t\"Deficit: VO: %d us VI: %d us BE: %d us BK: %d us\\n\",\n\t\trx_airtime, tx_airtime, sta->airtime_weight,\n\t\tdeficit[0], deficit[1], deficit[2], deficit[3]);\n\n\trv = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\n\tkfree(buf);\n\treturn rv;\n}\n\nstatic ssize_t sta_airtime_write(struct file *file, const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct sta_info *sta = file->private_data;\n\tstruct ieee80211_local *local = sta->sdata->local;\n\tint ac;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tspin_lock_bh(&local->active_txq_lock[ac]);\n\t\tsta->airtime[ac].rx_airtime = 0;\n\t\tsta->airtime[ac].tx_airtime = 0;\n\t\tsta->airtime[ac].deficit = sta->airtime_weight;\n\t\tspin_unlock_bh(&local->active_txq_lock[ac]);\n\t}\n\n\treturn count;\n}\nSTA_OPS_RW(airtime);\n\nstatic ssize_t sta_aql_read(struct file *file, char __user *userbuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct sta_info *sta = file->private_data;\n\tstruct ieee80211_local *local = sta->sdata->local;\n\tsize_t bufsz = 400;\n\tchar *buf = kzalloc(bufsz, GFP_KERNEL), *p = buf;\n\tu32 q_depth[IEEE80211_NUM_ACS];\n\tu32 q_limit_l[IEEE80211_NUM_ACS], q_limit_h[IEEE80211_NUM_ACS];\n\tssize_t rv;\n\tint ac;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tspin_lock_bh(&local->active_txq_lock[ac]);\n\t\tq_limit_l[ac] = sta->airtime[ac].aql_limit_low;\n\t\tq_limit_h[ac] = sta->airtime[ac].aql_limit_high;\n\t\tspin_unlock_bh(&local->active_txq_lock[ac]);\n\t\tq_depth[ac] = atomic_read(&sta->airtime[ac].aql_tx_pending);\n\t}\n\n\tp += scnprintf(p, bufsz + buf - p,\n\t\t\"Q depth: VO: %u us VI: %u us BE: %u us BK: %u us\\n\"\n\t\t\"Q limit[low/high]: VO: %u/%u VI: %u/%u BE: %u/%u BK: %u/%u\\n\",\n\t\tq_depth[0], q_depth[1], q_depth[2], q_depth[3],\n\t\tq_limit_l[0], q_limit_h[0], q_limit_l[1], q_limit_h[1],\n\t\tq_limit_l[2], q_limit_h[2], q_limit_l[3], q_limit_h[3]);\n\n\trv = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\n\tkfree(buf);\n\treturn rv;\n}\n\nstatic ssize_t sta_aql_write(struct file *file, const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct sta_info *sta = file->private_data;\n\tu32 ac, q_limit_l, q_limit_h;\n\tchar _buf[100] = {}, *buf = _buf;\n\n\tif (count > sizeof(_buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, userbuf, count))\n\t\treturn -EFAULT;\n\n\tbuf[sizeof(_buf) - 1] = '\\0';\n\tif (sscanf(buf, \"limit %u %u %u\", &ac, &q_limit_l, &q_limit_h)\n\t    != 3)\n\t\treturn -EINVAL;\n\n\tif (ac >= IEEE80211_NUM_ACS)\n\t\treturn -EINVAL;\n\n\tsta->airtime[ac].aql_limit_low = q_limit_l;\n\tsta->airtime[ac].aql_limit_high = q_limit_h;\n\n\treturn count;\n}\nSTA_OPS_RW(aql);\n\n\nstatic ssize_t sta_agg_status_read(struct file *file, char __user *userbuf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *buf, *p;\n\tssize_t bufsz = 71 + IEEE80211_NUM_TIDS * 40;\n\tint i;\n\tstruct sta_info *sta = file->private_data;\n\tstruct tid_ampdu_rx *tid_rx;\n\tstruct tid_ampdu_tx *tid_tx;\n\tssize_t ret;\n\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tp = buf;\n\n\trcu_read_lock();\n\n\tp += scnprintf(p, bufsz + buf - p, \"next dialog_token: %#02x\\n\",\n\t\t\tsta->ampdu_mlme.dialog_token_allocator + 1);\n\tp += scnprintf(p, bufsz + buf - p,\n\t\t       \"TID\\t\\tRX\\tDTKN\\tSSN\\t\\tTX\\tDTKN\\tpending\\n\");\n\n\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\n\t\tbool tid_rx_valid;\n\n\t\ttid_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[i]);\n\t\ttid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[i]);\n\t\ttid_rx_valid = test_bit(i, sta->ampdu_mlme.agg_session_valid);\n\n\t\tp += scnprintf(p, bufsz + buf - p, \"%02d\", i);\n\t\tp += scnprintf(p, bufsz + buf - p, \"\\t\\t%x\",\n\t\t\t       tid_rx_valid);\n\t\tp += scnprintf(p, bufsz + buf - p, \"\\t%#.2x\",\n\t\t\t       tid_rx_valid ?\n\t\t\t\t\tsta->ampdu_mlme.tid_rx_token[i] : 0);\n\t\tp += scnprintf(p, bufsz + buf - p, \"\\t%#.3x\",\n\t\t\t\ttid_rx ? tid_rx->ssn : 0);\n\n\t\tp += scnprintf(p, bufsz + buf - p, \"\\t\\t%x\", !!tid_tx);\n\t\tp += scnprintf(p, bufsz + buf - p, \"\\t%#.2x\",\n\t\t\t\ttid_tx ? tid_tx->dialog_token : 0);\n\t\tp += scnprintf(p, bufsz + buf - p, \"\\t%03d\",\n\t\t\t\ttid_tx ? skb_queue_len(&tid_tx->pending) : 0);\n\t\tp += scnprintf(p, bufsz + buf - p, \"\\n\");\n\t}\n\trcu_read_unlock();\n\n\tret = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t sta_agg_status_write(struct file *file, const char __user *userbuf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar _buf[25] = {}, *buf = _buf;\n\tstruct sta_info *sta = file->private_data;\n\tbool start, tx;\n\tunsigned long tid;\n\tchar *pos;\n\tint ret, timeout = 5000;\n\n\tif (count > sizeof(_buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, userbuf, count))\n\t\treturn -EFAULT;\n\n\tbuf[sizeof(_buf) - 1] = '\\0';\n\tpos = buf;\n\tbuf = strsep(&pos, \" \");\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(buf, \"tx\"))\n\t\ttx = true;\n\telse if (!strcmp(buf, \"rx\"))\n\t\ttx = false;\n\telse\n\t\treturn -EINVAL;\n\n\tbuf = strsep(&pos, \" \");\n\tif (!buf)\n\t\treturn -EINVAL;\n\tif (!strcmp(buf, \"start\")) {\n\t\tstart = true;\n\t\tif (!tx)\n\t\t\treturn -EINVAL;\n\t} else if (!strcmp(buf, \"stop\")) {\n\t\tstart = false;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tbuf = strsep(&pos, \" \");\n\tif (!buf)\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"timeout=%d\", &timeout) == 1) {\n\t\tbuf = strsep(&pos, \" \");\n\t\tif (!buf || !tx || !start)\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = kstrtoul(buf, 0, &tid);\n\tif (ret || tid >= IEEE80211_NUM_TIDS)\n\t\treturn -EINVAL;\n\n\tif (tx) {\n\t\tif (start)\n\t\t\tret = ieee80211_start_tx_ba_session(&sta->sta, tid,\n\t\t\t\t\t\t\t    timeout);\n\t\telse\n\t\t\tret = ieee80211_stop_tx_ba_session(&sta->sta, tid);\n\t} else {\n\t\t__ieee80211_stop_rx_ba_session(sta, tid, WLAN_BACK_RECIPIENT,\n\t\t\t\t\t       3, true);\n\t\tret = 0;\n\t}\n\n\treturn ret ?: count;\n}\nSTA_OPS_RW(agg_status);\n\n \n#define LINK_STA_OPS(name)\t\t\t\t\t\t\\\nstatic const struct file_operations link_sta_ ##name## _ops = {\t\t\\\n\t.read = link_sta_##name##_read,\t\t\t\t\t\\\n\t.open = simple_open,\t\t\t\t\t\t\\\n\t.llseek = generic_file_llseek,\t\t\t\t\t\\\n}\n\nstatic ssize_t link_sta_addr_read(struct file *file, char __user *userbuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct link_sta_info *link_sta = file->private_data;\n\tu8 mac[3 * ETH_ALEN + 1];\n\n\tsnprintf(mac, sizeof(mac), \"%pM\\n\", link_sta->pub->addr);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, mac, 3 * ETH_ALEN);\n}\n\nLINK_STA_OPS(addr);\n\nstatic ssize_t link_sta_ht_capa_read(struct file *file, char __user *userbuf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n#define PRINT_HT_CAP(_cond, _str) \\\n\tdo { \\\n\tif (_cond) \\\n\t\t\tp += scnprintf(p, bufsz + buf - p, \"\\t\" _str \"\\n\"); \\\n\t} while (0)\n\tchar *buf, *p;\n\tint i;\n\tssize_t bufsz = 512;\n\tstruct link_sta_info *link_sta = file->private_data;\n\tstruct ieee80211_sta_ht_cap *htc = &link_sta->pub->ht_cap;\n\tssize_t ret;\n\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tp = buf;\n\n\tp += scnprintf(p, bufsz + buf - p, \"ht %ssupported\\n\",\n\t\t\thtc->ht_supported ? \"\" : \"not \");\n\tif (htc->ht_supported) {\n\t\tp += scnprintf(p, bufsz + buf - p, \"cap: %#.4x\\n\", htc->cap);\n\n\t\tPRINT_HT_CAP((htc->cap & BIT(0)), \"RX LDPC\");\n\t\tPRINT_HT_CAP((htc->cap & BIT(1)), \"HT20/HT40\");\n\t\tPRINT_HT_CAP(!(htc->cap & BIT(1)), \"HT20\");\n\n\t\tPRINT_HT_CAP(((htc->cap >> 2) & 0x3) == 0, \"Static SM Power Save\");\n\t\tPRINT_HT_CAP(((htc->cap >> 2) & 0x3) == 1, \"Dynamic SM Power Save\");\n\t\tPRINT_HT_CAP(((htc->cap >> 2) & 0x3) == 3, \"SM Power Save disabled\");\n\n\t\tPRINT_HT_CAP((htc->cap & BIT(4)), \"RX Greenfield\");\n\t\tPRINT_HT_CAP((htc->cap & BIT(5)), \"RX HT20 SGI\");\n\t\tPRINT_HT_CAP((htc->cap & BIT(6)), \"RX HT40 SGI\");\n\t\tPRINT_HT_CAP((htc->cap & BIT(7)), \"TX STBC\");\n\n\t\tPRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 0, \"No RX STBC\");\n\t\tPRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 1, \"RX STBC 1-stream\");\n\t\tPRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 2, \"RX STBC 2-streams\");\n\t\tPRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 3, \"RX STBC 3-streams\");\n\n\t\tPRINT_HT_CAP((htc->cap & BIT(10)), \"HT Delayed Block Ack\");\n\n\t\tPRINT_HT_CAP(!(htc->cap & BIT(11)), \"Max AMSDU length: \"\n\t\t\t     \"3839 bytes\");\n\t\tPRINT_HT_CAP((htc->cap & BIT(11)), \"Max AMSDU length: \"\n\t\t\t     \"7935 bytes\");\n\n\t\t \n\t\tPRINT_HT_CAP((htc->cap & BIT(12)), \"DSSS/CCK HT40\");\n\t\tPRINT_HT_CAP(!(htc->cap & BIT(12)), \"No DSSS/CCK HT40\");\n\n\t\t \n\n\t\tPRINT_HT_CAP((htc->cap & BIT(14)), \"40 MHz Intolerant\");\n\n\t\tPRINT_HT_CAP((htc->cap & BIT(15)), \"L-SIG TXOP protection\");\n\n\t\tp += scnprintf(p, bufsz + buf - p, \"ampdu factor/density: %d/%d\\n\",\n\t\t\t\thtc->ampdu_factor, htc->ampdu_density);\n\t\tp += scnprintf(p, bufsz + buf - p, \"MCS mask:\");\n\n\t\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)\n\t\t\tp += scnprintf(p, bufsz + buf - p, \" %.2x\",\n\t\t\t\t\thtc->mcs.rx_mask[i]);\n\t\tp += scnprintf(p, bufsz + buf - p, \"\\n\");\n\n\t\t \n\t\tif (le16_to_cpu(htc->mcs.rx_highest)) {\n\t\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\t       \"MCS rx highest: %d Mbps\\n\",\n\t\t\t\t       le16_to_cpu(htc->mcs.rx_highest));\n\t\t}\n\n\t\tp += scnprintf(p, bufsz + buf - p, \"MCS tx params: %x\\n\",\n\t\t\t\thtc->mcs.tx_params);\n\t}\n\n\tret = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\n\tkfree(buf);\n\treturn ret;\n}\nLINK_STA_OPS(ht_capa);\n\nstatic ssize_t link_sta_vht_capa_read(struct file *file, char __user *userbuf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *buf, *p;\n\tstruct link_sta_info *link_sta = file->private_data;\n\tstruct ieee80211_sta_vht_cap *vhtc = &link_sta->pub->vht_cap;\n\tssize_t ret;\n\tssize_t bufsz = 512;\n\n\tbuf = kzalloc(bufsz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tp = buf;\n\n\tp += scnprintf(p, bufsz + buf - p, \"VHT %ssupported\\n\",\n\t\t\tvhtc->vht_supported ? \"\" : \"not \");\n\tif (vhtc->vht_supported) {\n\t\tp += scnprintf(p, bufsz + buf - p, \"cap: %#.8x\\n\",\n\t\t\t       vhtc->cap);\n#define PFLAG(a, b)\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\\\n\t\t\tif (vhtc->cap & IEEE80211_VHT_CAP_ ## a)\t\\\n\t\t\t\tp += scnprintf(p, bufsz + buf - p, \\\n\t\t\t\t\t       \"\\t\\t%s\\n\", b);\t\t\\\n\t\t} while (0)\n\n\t\tswitch (vhtc->cap & 0x3) {\n\t\tcase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895:\n\t\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\t       \"\\t\\tMAX-MPDU-3895\\n\");\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991:\n\t\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\t       \"\\t\\tMAX-MPDU-7991\\n\");\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454:\n\t\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\t       \"\\t\\tMAX-MPDU-11454\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\t       \"\\t\\tMAX-MPDU-UNKNOWN\\n\");\n\t\t}\n\t\tswitch (vhtc->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {\n\t\tcase 0:\n\t\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\t       \"\\t\\t80Mhz\\n\");\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ:\n\t\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\t       \"\\t\\t160Mhz\\n\");\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ:\n\t\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\t       \"\\t\\t80+80Mhz\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\t       \"\\t\\tUNKNOWN-MHZ: 0x%x\\n\",\n\t\t\t\t       (vhtc->cap >> 2) & 0x3);\n\t\t}\n\t\tPFLAG(RXLDPC, \"RXLDPC\");\n\t\tPFLAG(SHORT_GI_80, \"SHORT-GI-80\");\n\t\tPFLAG(SHORT_GI_160, \"SHORT-GI-160\");\n\t\tPFLAG(TXSTBC, \"TXSTBC\");\n\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t       \"\\t\\tRXSTBC_%d\\n\", (vhtc->cap >> 8) & 0x7);\n\t\tPFLAG(SU_BEAMFORMER_CAPABLE, \"SU-BEAMFORMER-CAPABLE\");\n\t\tPFLAG(SU_BEAMFORMEE_CAPABLE, \"SU-BEAMFORMEE-CAPABLE\");\n\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\"\\t\\tBEAMFORMEE-STS: 0x%x\\n\",\n\t\t\t(vhtc->cap & IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK) >>\n\t\t\tIEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT);\n\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\"\\t\\tSOUNDING-DIMENSIONS: 0x%x\\n\",\n\t\t\t(vhtc->cap & IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK)\n\t\t\t>> IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT);\n\t\tPFLAG(MU_BEAMFORMER_CAPABLE, \"MU-BEAMFORMER-CAPABLE\");\n\t\tPFLAG(MU_BEAMFORMEE_CAPABLE, \"MU-BEAMFORMEE-CAPABLE\");\n\t\tPFLAG(VHT_TXOP_PS, \"TXOP-PS\");\n\t\tPFLAG(HTC_VHT, \"HTC-VHT\");\n\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\"\\t\\tMPDU-LENGTH-EXPONENT: 0x%x\\n\",\n\t\t\t(vhtc->cap & IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK) >>\n\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT);\n\t\tPFLAG(VHT_LINK_ADAPTATION_VHT_UNSOL_MFB,\n\t\t      \"LINK-ADAPTATION-VHT-UNSOL-MFB\");\n\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\"\\t\\tLINK-ADAPTATION-VHT-MRQ-MFB: 0x%x\\n\",\n\t\t\t(vhtc->cap & IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB) >> 26);\n\t\tPFLAG(RX_ANTENNA_PATTERN, \"RX-ANTENNA-PATTERN\");\n\t\tPFLAG(TX_ANTENNA_PATTERN, \"TX-ANTENNA-PATTERN\");\n\n\t\tp += scnprintf(p, bufsz + buf - p, \"RX MCS: %.4x\\n\",\n\t\t\t       le16_to_cpu(vhtc->vht_mcs.rx_mcs_map));\n\t\tif (vhtc->vht_mcs.rx_highest)\n\t\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\t       \"MCS RX highest: %d Mbps\\n\",\n\t\t\t\t       le16_to_cpu(vhtc->vht_mcs.rx_highest));\n\t\tp += scnprintf(p, bufsz + buf - p, \"TX MCS: %.4x\\n\",\n\t\t\t       le16_to_cpu(vhtc->vht_mcs.tx_mcs_map));\n\t\tif (vhtc->vht_mcs.tx_highest)\n\t\t\tp += scnprintf(p, bufsz + buf - p,\n\t\t\t\t       \"MCS TX highest: %d Mbps\\n\",\n\t\t\t\t       le16_to_cpu(vhtc->vht_mcs.tx_highest));\n#undef PFLAG\n\t}\n\n\tret = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\n\tkfree(buf);\n\treturn ret;\n}\nLINK_STA_OPS(vht_capa);\n\nstatic ssize_t link_sta_he_capa_read(struct file *file, char __user *userbuf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar *buf, *p;\n\tsize_t buf_sz = PAGE_SIZE;\n\tstruct link_sta_info *link_sta = file->private_data;\n\tstruct ieee80211_sta_he_cap *hec = &link_sta->pub->he_cap;\n\tstruct ieee80211_he_mcs_nss_supp *nss = &hec->he_mcs_nss_supp;\n\tu8 ppe_size;\n\tu8 *cap;\n\tint i;\n\tssize_t ret;\n\n\tbuf = kmalloc(buf_sz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tp = buf;\n\n\tp += scnprintf(p, buf_sz + buf - p, \"HE %ssupported\\n\",\n\t\t       hec->has_he ? \"\" : \"not \");\n\tif (!hec->has_he)\n\t\tgoto out;\n\n\tcap = hec->he_cap_elem.mac_cap_info;\n\tp += scnprintf(p, buf_sz + buf - p,\n\t\t       \"MAC-CAP: %#.2x %#.2x %#.2x %#.2x %#.2x %#.2x\\n\",\n\t\t       cap[0], cap[1], cap[2], cap[3], cap[4], cap[5]);\n\n#define PRINT(fmt, ...)\t\t\t\t\t\t\t\\\n\tp += scnprintf(p, buf_sz + buf - p, \"\\t\\t\" fmt \"\\n\",\t\t\\\n\t\t       ##__VA_ARGS__)\n\n#define PFLAG(t, n, a, b)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (cap[n] & IEEE80211_HE_##t##_CAP##n##_##a)\t\t\\\n\t\t\tPRINT(\"%s\", b);\t\t\t\t\t\\\n\t} while (0)\n\n#define PFLAG_RANGE(t, i, n, s, m, off, fmt)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tu8 msk = IEEE80211_HE_##t##_CAP##i##_##n##_MASK;\t\\\n\t\tu8 idx = ((cap[i] & msk) >> (ffs(msk) - 1)) + off;\t\\\n\t\tPRINT(fmt, (s << idx) + (m * idx));\t\t\t\\\n\t} while (0)\n\n#define PFLAG_RANGE_DEFAULT(t, i, n, s, m, off, fmt, a, b)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (cap[i] == IEEE80211_HE_##t ##_CAP##i##_##n##_##a) {\t\\\n\t\t\tPRINT(\"%s\", b);\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tPFLAG_RANGE(t, i, n, s, m, off, fmt);\t\t\t\\\n\t} while (0)\n\n\tPFLAG(MAC, 0, HTC_HE, \"HTC-HE\");\n\tPFLAG(MAC, 0, TWT_REQ, \"TWT-REQ\");\n\tPFLAG(MAC, 0, TWT_RES, \"TWT-RES\");\n\tPFLAG_RANGE_DEFAULT(MAC, 0, DYNAMIC_FRAG, 0, 1, 0,\n\t\t\t    \"DYNAMIC-FRAG-LEVEL-%d\", NOT_SUPP, \"NOT-SUPP\");\n\tPFLAG_RANGE_DEFAULT(MAC, 0, MAX_NUM_FRAG_MSDU, 1, 0, 0,\n\t\t\t    \"MAX-NUM-FRAG-MSDU-%d\", UNLIMITED, \"UNLIMITED\");\n\n\tPFLAG_RANGE_DEFAULT(MAC, 1, MIN_FRAG_SIZE, 128, 0, -1,\n\t\t\t    \"MIN-FRAG-SIZE-%d\", UNLIMITED, \"UNLIMITED\");\n\tPFLAG_RANGE_DEFAULT(MAC, 1, TF_MAC_PAD_DUR, 0, 8, 0,\n\t\t\t    \"TF-MAC-PAD-DUR-%dUS\", MASK, \"UNKNOWN\");\n\tPFLAG_RANGE(MAC, 1, MULTI_TID_AGG_RX_QOS, 0, 1, 1,\n\t\t    \"MULTI-TID-AGG-RX-QOS-%d\");\n\n\tif (cap[0] & IEEE80211_HE_MAC_CAP0_HTC_HE) {\n\t\tswitch (((cap[2] << 1) | (cap[1] >> 7)) & 0x3) {\n\t\tcase 0:\n\t\t\tPRINT(\"LINK-ADAPTATION-NO-FEEDBACK\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tPRINT(\"LINK-ADAPTATION-RESERVED\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tPRINT(\"LINK-ADAPTATION-UNSOLICITED-FEEDBACK\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tPRINT(\"LINK-ADAPTATION-BOTH\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tPFLAG(MAC, 2, ALL_ACK, \"ALL-ACK\");\n\tPFLAG(MAC, 2, TRS, \"TRS\");\n\tPFLAG(MAC, 2, BSR, \"BSR\");\n\tPFLAG(MAC, 2, BCAST_TWT, \"BCAST-TWT\");\n\tPFLAG(MAC, 2, 32BIT_BA_BITMAP, \"32BIT-BA-BITMAP\");\n\tPFLAG(MAC, 2, MU_CASCADING, \"MU-CASCADING\");\n\tPFLAG(MAC, 2, ACK_EN, \"ACK-EN\");\n\n\tPFLAG(MAC, 3, OMI_CONTROL, \"OMI-CONTROL\");\n\tPFLAG(MAC, 3, OFDMA_RA, \"OFDMA-RA\");\n\n\tswitch (cap[3] & IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_MASK) {\n\tcase IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_0:\n\t\tPRINT(\"MAX-AMPDU-LEN-EXP-USE-EXT-0\");\n\t\tbreak;\n\tcase IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_1:\n\t\tPRINT(\"MAX-AMPDU-LEN-EXP-VHT-EXT-1\");\n\t\tbreak;\n\tcase IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_2:\n\t\tPRINT(\"MAX-AMPDU-LEN-EXP-VHT-EXT-2\");\n\t\tbreak;\n\tcase IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_3:\n\t\tPRINT(\"MAX-AMPDU-LEN-EXP-VHT-EXT-3\");\n\t\tbreak;\n\t}\n\n\tPFLAG(MAC, 3, AMSDU_FRAG, \"AMSDU-FRAG\");\n\tPFLAG(MAC, 3, FLEX_TWT_SCHED, \"FLEX-TWT-SCHED\");\n\tPFLAG(MAC, 3, RX_CTRL_FRAME_TO_MULTIBSS, \"RX-CTRL-FRAME-TO-MULTIBSS\");\n\n\tPFLAG(MAC, 4, BSRP_BQRP_A_MPDU_AGG, \"BSRP-BQRP-A-MPDU-AGG\");\n\tPFLAG(MAC, 4, QTP, \"QTP\");\n\tPFLAG(MAC, 4, BQR, \"BQR\");\n\tPFLAG(MAC, 4, PSR_RESP, \"PSR-RESP\");\n\tPFLAG(MAC, 4, NDP_FB_REP, \"NDP-FB-REP\");\n\tPFLAG(MAC, 4, OPS, \"OPS\");\n\tPFLAG(MAC, 4, AMSDU_IN_AMPDU, \"AMSDU-IN-AMPDU\");\n\n\tPRINT(\"MULTI-TID-AGG-TX-QOS-%d\", ((cap[5] << 1) | (cap[4] >> 7)) & 0x7);\n\n\tPFLAG(MAC, 5, SUBCHAN_SELECTIVE_TRANSMISSION,\n\t      \"SUBCHAN-SELECTIVE-TRANSMISSION\");\n\tPFLAG(MAC, 5, UL_2x996_TONE_RU, \"UL-2x996-TONE-RU\");\n\tPFLAG(MAC, 5, OM_CTRL_UL_MU_DATA_DIS_RX, \"OM-CTRL-UL-MU-DATA-DIS-RX\");\n\tPFLAG(MAC, 5, HE_DYNAMIC_SM_PS, \"HE-DYNAMIC-SM-PS\");\n\tPFLAG(MAC, 5, PUNCTURED_SOUNDING, \"PUNCTURED-SOUNDING\");\n\tPFLAG(MAC, 5, HT_VHT_TRIG_FRAME_RX, \"HT-VHT-TRIG-FRAME-RX\");\n\n\tcap = hec->he_cap_elem.phy_cap_info;\n\tp += scnprintf(p, buf_sz + buf - p,\n\t\t       \"PHY CAP: %#.2x %#.2x %#.2x %#.2x %#.2x %#.2x %#.2x %#.2x %#.2x %#.2x %#.2x\\n\",\n\t\t       cap[0], cap[1], cap[2], cap[3], cap[4], cap[5], cap[6],\n\t\t       cap[7], cap[8], cap[9], cap[10]);\n\n\tPFLAG(PHY, 0, CHANNEL_WIDTH_SET_40MHZ_IN_2G,\n\t      \"CHANNEL-WIDTH-SET-40MHZ-IN-2G\");\n\tPFLAG(PHY, 0, CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G,\n\t      \"CHANNEL-WIDTH-SET-40MHZ-80MHZ-IN-5G\");\n\tPFLAG(PHY, 0, CHANNEL_WIDTH_SET_160MHZ_IN_5G,\n\t      \"CHANNEL-WIDTH-SET-160MHZ-IN-5G\");\n\tPFLAG(PHY, 0, CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G,\n\t      \"CHANNEL-WIDTH-SET-80PLUS80-MHZ-IN-5G\");\n\tPFLAG(PHY, 0, CHANNEL_WIDTH_SET_RU_MAPPING_IN_2G,\n\t      \"CHANNEL-WIDTH-SET-RU-MAPPING-IN-2G\");\n\tPFLAG(PHY, 0, CHANNEL_WIDTH_SET_RU_MAPPING_IN_5G,\n\t      \"CHANNEL-WIDTH-SET-RU-MAPPING-IN-5G\");\n\n\tswitch (cap[1] & IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_MASK) {\n\tcase IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_80MHZ_ONLY_SECOND_20MHZ:\n\t\tPRINT(\"PREAMBLE-PUNC-RX-80MHZ-ONLY-SECOND-20MHZ\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_80MHZ_ONLY_SECOND_40MHZ:\n\t\tPRINT(\"PREAMBLE-PUNC-RX-80MHZ-ONLY-SECOND-40MHZ\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_160MHZ_ONLY_SECOND_20MHZ:\n\t\tPRINT(\"PREAMBLE-PUNC-RX-160MHZ-ONLY-SECOND-20MHZ\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP1_PREAMBLE_PUNC_RX_160MHZ_ONLY_SECOND_40MHZ:\n\t\tPRINT(\"PREAMBLE-PUNC-RX-160MHZ-ONLY-SECOND-40MHZ\");\n\t\tbreak;\n\t}\n\n\tPFLAG(PHY, 1, DEVICE_CLASS_A,\n\t      \"IEEE80211-HE-PHY-CAP1-DEVICE-CLASS-A\");\n\tPFLAG(PHY, 1, LDPC_CODING_IN_PAYLOAD,\n\t      \"LDPC-CODING-IN-PAYLOAD\");\n\tPFLAG(PHY, 1, HE_LTF_AND_GI_FOR_HE_PPDUS_0_8US,\n\t      \"HY-CAP1-HE-LTF-AND-GI-FOR-HE-PPDUS-0-8US\");\n\tPRINT(\"MIDAMBLE-RX-MAX-NSTS-%d\", ((cap[2] << 1) | (cap[1] >> 7)) & 0x3);\n\n\tPFLAG(PHY, 2, NDP_4x_LTF_AND_3_2US, \"NDP-4X-LTF-AND-3-2US\");\n\tPFLAG(PHY, 2, STBC_TX_UNDER_80MHZ, \"STBC-TX-UNDER-80MHZ\");\n\tPFLAG(PHY, 2, STBC_RX_UNDER_80MHZ, \"STBC-RX-UNDER-80MHZ\");\n\tPFLAG(PHY, 2, DOPPLER_TX, \"DOPPLER-TX\");\n\tPFLAG(PHY, 2, DOPPLER_RX, \"DOPPLER-RX\");\n\tPFLAG(PHY, 2, UL_MU_FULL_MU_MIMO, \"UL-MU-FULL-MU-MIMO\");\n\tPFLAG(PHY, 2, UL_MU_PARTIAL_MU_MIMO, \"UL-MU-PARTIAL-MU-MIMO\");\n\n\tswitch (cap[3] & IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_MASK) {\n\tcase IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_NO_DCM:\n\t\tPRINT(\"DCM-MAX-CONST-TX-NO-DCM\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_BPSK:\n\t\tPRINT(\"DCM-MAX-CONST-TX-BPSK\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_QPSK:\n\t\tPRINT(\"DCM-MAX-CONST-TX-QPSK\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_16_QAM:\n\t\tPRINT(\"DCM-MAX-CONST-TX-16-QAM\");\n\t\tbreak;\n\t}\n\n\tPFLAG(PHY, 3, DCM_MAX_TX_NSS_1, \"DCM-MAX-TX-NSS-1\");\n\tPFLAG(PHY, 3, DCM_MAX_TX_NSS_2, \"DCM-MAX-TX-NSS-2\");\n\n\tswitch (cap[3] & IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_MASK) {\n\tcase IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_NO_DCM:\n\t\tPRINT(\"DCM-MAX-CONST-RX-NO-DCM\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_BPSK:\n\t\tPRINT(\"DCM-MAX-CONST-RX-BPSK\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_QPSK:\n\t\tPRINT(\"DCM-MAX-CONST-RX-QPSK\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_16_QAM:\n\t\tPRINT(\"DCM-MAX-CONST-RX-16-QAM\");\n\t\tbreak;\n\t}\n\n\tPFLAG(PHY, 3, DCM_MAX_RX_NSS_1, \"DCM-MAX-RX-NSS-1\");\n\tPFLAG(PHY, 3, DCM_MAX_RX_NSS_2, \"DCM-MAX-RX-NSS-2\");\n\tPFLAG(PHY, 3, RX_PARTIAL_BW_SU_IN_20MHZ_MU,\n\t      \"RX-PARTIAL-BW-SU-IN-20MHZ-MU\");\n\tPFLAG(PHY, 3, SU_BEAMFORMER, \"SU-BEAMFORMER\");\n\n\tPFLAG(PHY, 4, SU_BEAMFORMEE, \"SU-BEAMFORMEE\");\n\tPFLAG(PHY, 4, MU_BEAMFORMER, \"MU-BEAMFORMER\");\n\n\tPFLAG_RANGE(PHY, 4, BEAMFORMEE_MAX_STS_UNDER_80MHZ, 0, 1, 4,\n\t\t    \"BEAMFORMEE-MAX-STS-UNDER-%d\");\n\tPFLAG_RANGE(PHY, 4, BEAMFORMEE_MAX_STS_ABOVE_80MHZ, 0, 1, 4,\n\t\t    \"BEAMFORMEE-MAX-STS-ABOVE-%d\");\n\n\tPFLAG_RANGE(PHY, 5, BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ, 0, 1, 1,\n\t\t    \"NUM-SND-DIM-UNDER-80MHZ-%d\");\n\tPFLAG_RANGE(PHY, 5, BEAMFORMEE_NUM_SND_DIM_ABOVE_80MHZ, 0, 1, 1,\n\t\t    \"NUM-SND-DIM-ABOVE-80MHZ-%d\");\n\tPFLAG(PHY, 5, NG16_SU_FEEDBACK, \"NG16-SU-FEEDBACK\");\n\tPFLAG(PHY, 5, NG16_MU_FEEDBACK, \"NG16-MU-FEEDBACK\");\n\n\tPFLAG(PHY, 6, CODEBOOK_SIZE_42_SU, \"CODEBOOK-SIZE-42-SU\");\n\tPFLAG(PHY, 6, CODEBOOK_SIZE_75_MU, \"CODEBOOK-SIZE-75-MU\");\n\tPFLAG(PHY, 6, TRIG_SU_BEAMFORMING_FB, \"TRIG-SU-BEAMFORMING-FB\");\n\tPFLAG(PHY, 6, TRIG_MU_BEAMFORMING_PARTIAL_BW_FB,\n\t      \"MU-BEAMFORMING-PARTIAL-BW-FB\");\n\tPFLAG(PHY, 6, TRIG_CQI_FB, \"TRIG-CQI-FB\");\n\tPFLAG(PHY, 6, PARTIAL_BW_EXT_RANGE, \"PARTIAL-BW-EXT-RANGE\");\n\tPFLAG(PHY, 6, PARTIAL_BANDWIDTH_DL_MUMIMO,\n\t      \"PARTIAL-BANDWIDTH-DL-MUMIMO\");\n\tPFLAG(PHY, 6, PPE_THRESHOLD_PRESENT, \"PPE-THRESHOLD-PRESENT\");\n\n\tPFLAG(PHY, 7, PSR_BASED_SR, \"PSR-BASED-SR\");\n\tPFLAG(PHY, 7, POWER_BOOST_FACTOR_SUPP, \"POWER-BOOST-FACTOR-SUPP\");\n\tPFLAG(PHY, 7, HE_SU_MU_PPDU_4XLTF_AND_08_US_GI,\n\t      \"HE-SU-MU-PPDU-4XLTF-AND-08-US-GI\");\n\tPFLAG_RANGE(PHY, 7, MAX_NC, 0, 1, 1, \"MAX-NC-%d\");\n\tPFLAG(PHY, 7, STBC_TX_ABOVE_80MHZ, \"STBC-TX-ABOVE-80MHZ\");\n\tPFLAG(PHY, 7, STBC_RX_ABOVE_80MHZ, \"STBC-RX-ABOVE-80MHZ\");\n\n\tPFLAG(PHY, 8, HE_ER_SU_PPDU_4XLTF_AND_08_US_GI,\n\t      \"HE-ER-SU-PPDU-4XLTF-AND-08-US-GI\");\n\tPFLAG(PHY, 8, 20MHZ_IN_40MHZ_HE_PPDU_IN_2G,\n\t      \"20MHZ-IN-40MHZ-HE-PPDU-IN-2G\");\n\tPFLAG(PHY, 8, 20MHZ_IN_160MHZ_HE_PPDU, \"20MHZ-IN-160MHZ-HE-PPDU\");\n\tPFLAG(PHY, 8, 80MHZ_IN_160MHZ_HE_PPDU, \"80MHZ-IN-160MHZ-HE-PPDU\");\n\tPFLAG(PHY, 8, HE_ER_SU_1XLTF_AND_08_US_GI,\n\t      \"HE-ER-SU-1XLTF-AND-08-US-GI\");\n\tPFLAG(PHY, 8, MIDAMBLE_RX_TX_2X_AND_1XLTF,\n\t      \"MIDAMBLE-RX-TX-2X-AND-1XLTF\");\n\n\tswitch (cap[8] & IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_MASK) {\n\tcase IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_242:\n\t\tPRINT(\"DCM-MAX-RU-242\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_484:\n\t\tPRINT(\"DCM-MAX-RU-484\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_996:\n\t\tPRINT(\"DCM-MAX-RU-996\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_2x996:\n\t\tPRINT(\"DCM-MAX-RU-2x996\");\n\t\tbreak;\n\t}\n\n\tPFLAG(PHY, 9, LONGER_THAN_16_SIGB_OFDM_SYM,\n\t      \"LONGER-THAN-16-SIGB-OFDM-SYM\");\n\tPFLAG(PHY, 9, NON_TRIGGERED_CQI_FEEDBACK,\n\t      \"NON-TRIGGERED-CQI-FEEDBACK\");\n\tPFLAG(PHY, 9, TX_1024_QAM_LESS_THAN_242_TONE_RU,\n\t      \"TX-1024-QAM-LESS-THAN-242-TONE-RU\");\n\tPFLAG(PHY, 9, RX_1024_QAM_LESS_THAN_242_TONE_RU,\n\t      \"RX-1024-QAM-LESS-THAN-242-TONE-RU\");\n\tPFLAG(PHY, 9, RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB,\n\t      \"RX-FULL-BW-SU-USING-MU-WITH-COMP-SIGB\");\n\tPFLAG(PHY, 9, RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB,\n\t      \"RX-FULL-BW-SU-USING-MU-WITH-NON-COMP-SIGB\");\n\n\tswitch (u8_get_bits(cap[9],\n\t\t\t    IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_MASK)) {\n\tcase IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_0US:\n\t\tPRINT(\"NOMINAL-PACKET-PADDING-0US\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_8US:\n\t\tPRINT(\"NOMINAL-PACKET-PADDING-8US\");\n\t\tbreak;\n\tcase IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_16US:\n\t\tPRINT(\"NOMINAL-PACKET-PADDING-16US\");\n\t\tbreak;\n\t}\n\n#undef PFLAG_RANGE_DEFAULT\n#undef PFLAG_RANGE\n#undef PFLAG\n\n#define PRINT_NSS_SUPP(f, n)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint _i;\t\t\t\t\t\t\t\\\n\t\tu16 v = le16_to_cpu(nss->f);\t\t\t\t\\\n\t\tp += scnprintf(p, buf_sz + buf - p, n \": %#.4x\\n\", v);\t\\\n\t\tfor (_i = 0; _i < 8; _i += 2) {\t\t\t\t\\\n\t\t\tswitch ((v >> _i) & 0x3) {\t\t\t\\\n\t\t\tcase 0:\t\t\t\t\t\t\\\n\t\t\t\tPRINT(n \"-%d-SUPPORT-0-7\", _i / 2);\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tcase 1:\t\t\t\t\t\t\\\n\t\t\t\tPRINT(n \"-%d-SUPPORT-0-9\", _i / 2);\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tcase 2:\t\t\t\t\t\t\\\n\t\t\t\tPRINT(n \"-%d-SUPPORT-0-11\", _i / 2);\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\tcase 3:\t\t\t\t\t\t\\\n\t\t\t\tPRINT(n \"-%d-NOT-SUPPORTED\", _i / 2);\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\tPRINT_NSS_SUPP(rx_mcs_80, \"RX-MCS-80\");\n\tPRINT_NSS_SUPP(tx_mcs_80, \"TX-MCS-80\");\n\n\tif (cap[0] & IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G) {\n\t\tPRINT_NSS_SUPP(rx_mcs_160, \"RX-MCS-160\");\n\t\tPRINT_NSS_SUPP(tx_mcs_160, \"TX-MCS-160\");\n\t}\n\n\tif (cap[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G) {\n\t\tPRINT_NSS_SUPP(rx_mcs_80p80, \"RX-MCS-80P80\");\n\t\tPRINT_NSS_SUPP(tx_mcs_80p80, \"TX-MCS-80P80\");\n\t}\n\n#undef PRINT_NSS_SUPP\n#undef PRINT\n\n\tif (!(cap[6] & IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT))\n\t\tgoto out;\n\n\tp += scnprintf(p, buf_sz + buf - p, \"PPE-THRESHOLDS: %#.2x\",\n\t\t       hec->ppe_thres[0]);\n\n\tppe_size = ieee80211_he_ppe_size(hec->ppe_thres[0], cap);\n\tfor (i = 1; i < ppe_size; i++) {\n\t\tp += scnprintf(p, buf_sz + buf - p, \" %#.2x\",\n\t\t\t       hec->ppe_thres[i]);\n\t}\n\tp += scnprintf(p, buf_sz + buf - p, \"\\n\");\n\nout:\n\tret = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\n\tkfree(buf);\n\treturn ret;\n}\nLINK_STA_OPS(he_capa);\n\nstatic ssize_t link_sta_eht_capa_read(struct file *file, char __user *userbuf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *buf, *p;\n\tsize_t buf_sz = PAGE_SIZE;\n\tstruct link_sta_info *link_sta = file->private_data;\n\tstruct ieee80211_sta_eht_cap *bec = &link_sta->pub->eht_cap;\n\tstruct ieee80211_eht_cap_elem_fixed *fixed = &bec->eht_cap_elem;\n\tstruct ieee80211_eht_mcs_nss_supp *nss = &bec->eht_mcs_nss_supp;\n\tu8 *cap;\n\tint i;\n\tssize_t ret;\n\tstatic const char *mcs_desc[] = { \"0-7\", \"8-9\", \"10-11\", \"12-13\"};\n\n\tbuf = kmalloc(buf_sz, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tp = buf;\n\n\tp += scnprintf(p, buf_sz + buf - p, \"EHT %ssupported\\n\",\n\t\t       bec->has_eht ? \"\" : \"not \");\n\tif (!bec->has_eht)\n\t\tgoto out;\n\n\tp += scnprintf(p, buf_sz + buf - p,\n\t\t       \"MAC-CAP: %#.2x %#.2x\\n\",\n\t\t       fixed->mac_cap_info[0], fixed->mac_cap_info[1]);\n\tp += scnprintf(p, buf_sz + buf - p,\n\t\t       \"PHY-CAP: %#.2x %#.2x %#.2x %#.2x %#.2x %#.2x %#.2x %#.2x %#.2x\\n\",\n\t\t       fixed->phy_cap_info[0], fixed->phy_cap_info[1],\n\t\t       fixed->phy_cap_info[2], fixed->phy_cap_info[3],\n\t\t       fixed->phy_cap_info[4], fixed->phy_cap_info[5],\n\t\t       fixed->phy_cap_info[6], fixed->phy_cap_info[7],\n\t\t       fixed->phy_cap_info[8]);\n\n#define PRINT(fmt, ...)\t\t\t\t\t\t\t\\\n\tp += scnprintf(p, buf_sz + buf - p, \"\\t\\t\" fmt \"\\n\",\t\t\\\n\t\t       ##__VA_ARGS__)\n\n#define PFLAG(t, n, a, b)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (cap[n] & IEEE80211_EHT_##t##_CAP##n##_##a)\t\t\\\n\t\t\tPRINT(\"%s\", b);\t\t\t\t\t\\\n\t} while (0)\n\n\tcap = fixed->mac_cap_info;\n\tPFLAG(MAC, 0, EPCS_PRIO_ACCESS, \"EPCS-PRIO-ACCESS\");\n\tPFLAG(MAC, 0, OM_CONTROL, \"OM-CONTROL\");\n\tPFLAG(MAC, 0, TRIG_TXOP_SHARING_MODE1, \"TRIG-TXOP-SHARING-MODE1\");\n\tPFLAG(MAC, 0, TRIG_TXOP_SHARING_MODE2, \"TRIG-TXOP-SHARING-MODE2\");\n\tPFLAG(MAC, 0, RESTRICTED_TWT, \"RESTRICTED-TWT\");\n\tPFLAG(MAC, 0, SCS_TRAFFIC_DESC, \"SCS-TRAFFIC-DESC\");\n\tswitch ((cap[0] & 0xc0) >> 6) {\n\tcase IEEE80211_EHT_MAC_CAP0_MAX_MPDU_LEN_3895:\n\t\tPRINT(\"MAX-MPDU-LEN: 3985\");\n\t\tbreak;\n\tcase IEEE80211_EHT_MAC_CAP0_MAX_MPDU_LEN_7991:\n\t\tPRINT(\"MAX-MPDU-LEN: 7991\");\n\t\tbreak;\n\tcase IEEE80211_EHT_MAC_CAP0_MAX_MPDU_LEN_11454:\n\t\tPRINT(\"MAX-MPDU-LEN: 11454\");\n\t\tbreak;\n\t}\n\n\tcap = fixed->phy_cap_info;\n\tPFLAG(PHY, 0, 320MHZ_IN_6GHZ, \"320MHZ-IN-6GHZ\");\n\tPFLAG(PHY, 0, 242_TONE_RU_GT20MHZ, \"242-TONE-RU-GT20MHZ\");\n\tPFLAG(PHY, 0, NDP_4_EHT_LFT_32_GI, \"NDP-4-EHT-LFT-32-GI\");\n\tPFLAG(PHY, 0, PARTIAL_BW_UL_MU_MIMO, \"PARTIAL-BW-UL-MU-MIMO\");\n\tPFLAG(PHY, 0, SU_BEAMFORMER, \"SU-BEAMFORMER\");\n\tPFLAG(PHY, 0, SU_BEAMFORMEE, \"SU-BEAMFORMEE\");\n\ti = cap[0] >> 7;\n\ti |= (cap[1] & 0x3) << 1;\n\tPRINT(\"BEAMFORMEE-80-NSS: %i\", i);\n\tPRINT(\"BEAMFORMEE-160-NSS: %i\", (cap[1] >> 2) & 0x7);\n\tPRINT(\"BEAMFORMEE-320-NSS: %i\", (cap[1] >> 5) & 0x7);\n\tPRINT(\"SOUNDING-DIM-80-NSS: %i\", (cap[2] & 0x7));\n\tPRINT(\"SOUNDING-DIM-160-NSS: %i\", (cap[2] >> 3) & 0x7);\n\ti = cap[2] >> 6;\n\ti |= (cap[3] & 0x1) << 3;\n\tPRINT(\"SOUNDING-DIM-320-NSS: %i\", i);\n\n\tPFLAG(PHY, 3, NG_16_SU_FEEDBACK, \"NG-16-SU-FEEDBACK\");\n\tPFLAG(PHY, 3, NG_16_MU_FEEDBACK, \"NG-16-MU-FEEDBACK\");\n\tPFLAG(PHY, 3, CODEBOOK_4_2_SU_FDBK, \"CODEBOOK-4-2-SU-FDBK\");\n\tPFLAG(PHY, 3, CODEBOOK_7_5_MU_FDBK, \"CODEBOOK-7-5-MU-FDBK\");\n\tPFLAG(PHY, 3, TRIG_SU_BF_FDBK, \"TRIG-SU-BF-FDBK\");\n\tPFLAG(PHY, 3, TRIG_MU_BF_PART_BW_FDBK, \"TRIG-MU-BF-PART-BW-FDBK\");\n\tPFLAG(PHY, 3, TRIG_CQI_FDBK, \"TRIG-CQI-FDBK\");\n\n\tPFLAG(PHY, 4, PART_BW_DL_MU_MIMO, \"PART-BW-DL-MU-MIMO\");\n\tPFLAG(PHY, 4, PSR_SR_SUPP, \"PSR-SR-SUPP\");\n\tPFLAG(PHY, 4, POWER_BOOST_FACT_SUPP, \"POWER-BOOST-FACT-SUPP\");\n\tPFLAG(PHY, 4, EHT_MU_PPDU_4_EHT_LTF_08_GI, \"EHT-MU-PPDU-4-EHT-LTF-08-GI\");\n\tPRINT(\"MAX_NC: %i\", cap[4] >> 4);\n\n\tPFLAG(PHY, 5, NON_TRIG_CQI_FEEDBACK, \"NON-TRIG-CQI-FEEDBACK\");\n\tPFLAG(PHY, 5, TX_LESS_242_TONE_RU_SUPP, \"TX-LESS-242-TONE-RU-SUPP\");\n\tPFLAG(PHY, 5, RX_LESS_242_TONE_RU_SUPP, \"RX-LESS-242-TONE-RU-SUPP\");\n\tPFLAG(PHY, 5, PPE_THRESHOLD_PRESENT, \"PPE_THRESHOLD_PRESENT\");\n\tswitch (cap[5] >> 4 & 0x3) {\n\tcase IEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_0US:\n\t\tPRINT(\"NOMINAL_PKT_PAD: 0us\");\n\t\tbreak;\n\tcase IEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_8US:\n\t\tPRINT(\"NOMINAL_PKT_PAD: 8us\");\n\t\tbreak;\n\tcase IEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_16US:\n\t\tPRINT(\"NOMINAL_PKT_PAD: 16us\");\n\t\tbreak;\n\tcase IEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_20US:\n\t\tPRINT(\"NOMINAL_PKT_PAD: 20us\");\n\t\tbreak;\n\t}\n\ti = cap[5] >> 6;\n\ti |= cap[6] & 0x7;\n\tPRINT(\"MAX-NUM-SUPP-EHT-LTF: %i\", i);\n\tPFLAG(PHY, 5, SUPP_EXTRA_EHT_LTF, \"SUPP-EXTRA-EHT-LTF\");\n\n\ti = (cap[6] >> 3) & 0xf;\n\tPRINT(\"MCS15-SUPP-MASK: %i\", i);\n\tPFLAG(PHY, 6, EHT_DUP_6GHZ_SUPP, \"EHT-DUP-6GHZ-SUPP\");\n\n\tPFLAG(PHY, 7, 20MHZ_STA_RX_NDP_WIDER_BW, \"20MHZ-STA-RX-NDP-WIDER-BW\");\n\tPFLAG(PHY, 7, NON_OFDMA_UL_MU_MIMO_80MHZ, \"NON-OFDMA-UL-MU-MIMO-80MHZ\");\n\tPFLAG(PHY, 7, NON_OFDMA_UL_MU_MIMO_160MHZ, \"NON-OFDMA-UL-MU-MIMO-160MHZ\");\n\tPFLAG(PHY, 7, NON_OFDMA_UL_MU_MIMO_320MHZ, \"NON-OFDMA-UL-MU-MIMO-320MHZ\");\n\tPFLAG(PHY, 7, MU_BEAMFORMER_80MHZ, \"MU-BEAMFORMER-80MHZ\");\n\tPFLAG(PHY, 7, MU_BEAMFORMER_160MHZ, \"MU-BEAMFORMER-160MHZ\");\n\tPFLAG(PHY, 7, MU_BEAMFORMER_320MHZ, \"MU-BEAMFORMER-320MHZ\");\n\tPFLAG(PHY, 7, TB_SOUNDING_FDBK_RATE_LIMIT, \"TB-SOUNDING-FDBK-RATE-LIMIT\");\n\n\tPFLAG(PHY, 8, RX_1024QAM_WIDER_BW_DL_OFDMA, \"RX-1024QAM-WIDER-BW-DL-OFDMA\");\n\tPFLAG(PHY, 8, RX_4096QAM_WIDER_BW_DL_OFDMA, \"RX-4096QAM-WIDER-BW-DL-OFDMA\");\n\n#undef PFLAG\n\n\tPRINT(\"\");  \n\tif (!(link_sta->pub->he_cap.he_cap_elem.phy_cap_info[0] &\n\t      IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_MASK_ALL)) {\n\t\tu8 *mcs_vals = (u8 *)(&nss->only_20mhz);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tPRINT(\"EHT bw=20 MHz, max NSS for MCS %s: Rx=%u, Tx=%u\",\n\t\t\t      mcs_desc[i],\n\t\t\t      mcs_vals[i] & 0xf, mcs_vals[i] >> 4);\n\t} else {\n\t\tu8 *mcs_vals = (u8 *)(&nss->bw._80);\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tPRINT(\"EHT bw <= 80 MHz, max NSS for MCS %s: Rx=%u, Tx=%u\",\n\t\t\t      mcs_desc[i + 1],\n\t\t\t      mcs_vals[i] & 0xf, mcs_vals[i] >> 4);\n\n\t\tmcs_vals = (u8 *)(&nss->bw._160);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tPRINT(\"EHT bw <= 160 MHz, max NSS for MCS %s: Rx=%u, Tx=%u\",\n\t\t\t      mcs_desc[i + 1],\n\t\t\t      mcs_vals[i] & 0xf, mcs_vals[i] >> 4);\n\n\t\tmcs_vals = (u8 *)(&nss->bw._320);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tPRINT(\"EHT bw <= 320 MHz, max NSS for MCS %s: Rx=%u, Tx=%u\",\n\t\t\t      mcs_desc[i + 1],\n\t\t\t      mcs_vals[i] & 0xf, mcs_vals[i] >> 4);\n\t}\n\n\tif (cap[5] & IEEE80211_EHT_PHY_CAP5_PPE_THRESHOLD_PRESENT) {\n\t\tu8 ppe_size = ieee80211_eht_ppe_size(bec->eht_ppe_thres[0], cap);\n\n\t\tp += scnprintf(p, buf_sz + buf - p, \"EHT PPE Thresholds: \");\n\t\tfor (i = 0; i < ppe_size; i++)\n\t\t\tp += scnprintf(p, buf_sz + buf - p, \"0x%02x \",\n\t\t\t\t       bec->eht_ppe_thres[i]);\n\t\tPRINT(\"\");  \n\t}\n\nout:\n\tret = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\n\tkfree(buf);\n\treturn ret;\n}\nLINK_STA_OPS(eht_capa);\n\n#define DEBUGFS_ADD(name) \\\n\tdebugfs_create_file(#name, 0400, \\\n\t\tsta->debugfs_dir, sta, &sta_ ##name## _ops)\n\n#define DEBUGFS_ADD_COUNTER(name, field)\t\t\t\t\\\n\tdebugfs_create_ulong(#name, 0400, sta->debugfs_dir, &sta->field);\n\nvoid ieee80211_sta_debugfs_add(struct sta_info *sta)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct dentry *stations_dir = sta->sdata->debugfs.subdir_stations;\n\tu8 mac[3*ETH_ALEN];\n\n\tif (!stations_dir)\n\t\treturn;\n\n\tsnprintf(mac, sizeof(mac), \"%pM\", sta->sta.addr);\n\n\t \n\tsta->debugfs_dir = debugfs_create_dir(mac, stations_dir);\n\n\tDEBUGFS_ADD(flags);\n\tDEBUGFS_ADD(aid);\n\tDEBUGFS_ADD(num_ps_buf_frames);\n\tDEBUGFS_ADD(last_seq_ctrl);\n\tDEBUGFS_ADD(agg_status);\n\t \n\tDEBUGFS_ADD_COUNTER(tx_filtered, deflink.status_stats.filtered);\n\n\tDEBUGFS_ADD(aqm);\n\tDEBUGFS_ADD(airtime);\n\n\tif (wiphy_ext_feature_isset(local->hw.wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_AQL))\n\t\tDEBUGFS_ADD(aql);\n\n\tdebugfs_create_xul(\"driver_buffered_tids\", 0400, sta->debugfs_dir,\n\t\t\t   &sta->driver_buffered_tids);\n\n\tdrv_sta_add_debugfs(local, sdata, &sta->sta, sta->debugfs_dir);\n}\n\nvoid ieee80211_sta_debugfs_remove(struct sta_info *sta)\n{\n\tdebugfs_remove_recursive(sta->debugfs_dir);\n\tsta->debugfs_dir = NULL;\n}\n\n#undef DEBUGFS_ADD\n#undef DEBUGFS_ADD_COUNTER\n\n#define DEBUGFS_ADD(name) \\\n\tdebugfs_create_file(#name, 0400, \\\n\t\tlink_sta->debugfs_dir, link_sta, &link_sta_ ##name## _ops)\n#define DEBUGFS_ADD_COUNTER(name, field)\t\t\t\t\\\n\tdebugfs_create_ulong(#name, 0400, link_sta->debugfs_dir, &link_sta->field)\n\nvoid ieee80211_link_sta_debugfs_add(struct link_sta_info *link_sta)\n{\n\tif (WARN_ON(!link_sta->sta->debugfs_dir))\n\t\treturn;\n\n\t \n\tif (link_sta->sta->sta.valid_links) {\n\t\tchar link_dir_name[10];\n\n\t\tsnprintf(link_dir_name, sizeof(link_dir_name),\n\t\t\t \"link-%d\", link_sta->link_id);\n\n\t\tlink_sta->debugfs_dir =\n\t\t\tdebugfs_create_dir(link_dir_name,\n\t\t\t\t\t   link_sta->sta->debugfs_dir);\n\n\t\tDEBUGFS_ADD(addr);\n\t} else {\n\t\tif (WARN_ON(link_sta != &link_sta->sta->deflink))\n\t\t\treturn;\n\n\t\tlink_sta->debugfs_dir = link_sta->sta->debugfs_dir;\n\t}\n\n\tDEBUGFS_ADD(ht_capa);\n\tDEBUGFS_ADD(vht_capa);\n\tDEBUGFS_ADD(he_capa);\n\tDEBUGFS_ADD(eht_capa);\n\n\tDEBUGFS_ADD_COUNTER(rx_duplicates, rx_stats.num_duplicates);\n\tDEBUGFS_ADD_COUNTER(rx_fragments, rx_stats.fragments);\n}\n\nvoid ieee80211_link_sta_debugfs_remove(struct link_sta_info *link_sta)\n{\n\tif (!link_sta->debugfs_dir || !link_sta->sta->debugfs_dir) {\n\t\tlink_sta->debugfs_dir = NULL;\n\t\treturn;\n\t}\n\n\tif (link_sta->debugfs_dir == link_sta->sta->debugfs_dir) {\n\t\tWARN_ON(link_sta != &link_sta->sta->deflink);\n\t\tlink_sta->sta->debugfs_dir = NULL;\n\t\treturn;\n\t}\n\n\tdebugfs_remove_recursive(link_sta->debugfs_dir);\n\tlink_sta->debugfs_dir = NULL;\n}\n\nvoid ieee80211_link_sta_debugfs_drv_add(struct link_sta_info *link_sta)\n{\n\tif (WARN_ON(!link_sta->debugfs_dir))\n\t\treturn;\n\n\tdrv_link_sta_add_debugfs(link_sta->sta->local, link_sta->sta->sdata,\n\t\t\t\t link_sta->pub, link_sta->debugfs_dir);\n}\n\nvoid ieee80211_link_sta_debugfs_drv_remove(struct link_sta_info *link_sta)\n{\n\tif (!link_sta->debugfs_dir)\n\t\treturn;\n\n\tif (WARN_ON(link_sta->debugfs_dir == link_sta->sta->debugfs_dir))\n\t\treturn;\n\n\t \n\tdebugfs_remove_recursive(link_sta->debugfs_dir);\n\tlink_sta->debugfs_dir = NULL;\n\n\tieee80211_link_sta_debugfs_add(link_sta);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}