{
  "module_name": "aes_gmac.c",
  "hash_id": "869c9aa599a8e72ab827ee598a1dc94ffd7ee9923483665c74fa8254b1059b7d",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/aes_gmac.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/err.h>\n#include <crypto/aead.h>\n#include <crypto/aes.h>\n\n#include <net/mac80211.h>\n#include \"key.h\"\n#include \"aes_gmac.h\"\n\nint ieee80211_aes_gmac(struct crypto_aead *tfm, const u8 *aad, u8 *nonce,\n\t\t       const u8 *data, size_t data_len, u8 *mic)\n{\n\tstruct scatterlist sg[5];\n\tu8 *zero, *__aad, iv[AES_BLOCK_SIZE];\n\tstruct aead_request *aead_req;\n\tint reqsize = sizeof(*aead_req) + crypto_aead_reqsize(tfm);\n\tconst __le16 *fc;\n\tint ret;\n\n\tif (data_len < GMAC_MIC_LEN)\n\t\treturn -EINVAL;\n\n\taead_req = kzalloc(reqsize + GMAC_MIC_LEN + GMAC_AAD_LEN, GFP_ATOMIC);\n\tif (!aead_req)\n\t\treturn -ENOMEM;\n\n\tzero = (u8 *)aead_req + reqsize;\n\t__aad = zero + GMAC_MIC_LEN;\n\tmemcpy(__aad, aad, GMAC_AAD_LEN);\n\n\tfc = (const __le16 *)aad;\n\tif (ieee80211_is_beacon(*fc)) {\n\t\t \n\t\tsg_init_table(sg, 5);\n\t\tsg_set_buf(&sg[0], __aad, GMAC_AAD_LEN);\n\t\tsg_set_buf(&sg[1], zero, 8);\n\t\tsg_set_buf(&sg[2], data + 8, data_len - 8 - GMAC_MIC_LEN);\n\t\tsg_set_buf(&sg[3], zero, GMAC_MIC_LEN);\n\t\tsg_set_buf(&sg[4], mic, GMAC_MIC_LEN);\n\t} else {\n\t\tsg_init_table(sg, 4);\n\t\tsg_set_buf(&sg[0], __aad, GMAC_AAD_LEN);\n\t\tsg_set_buf(&sg[1], data, data_len - GMAC_MIC_LEN);\n\t\tsg_set_buf(&sg[2], zero, GMAC_MIC_LEN);\n\t\tsg_set_buf(&sg[3], mic, GMAC_MIC_LEN);\n\t}\n\n\tmemcpy(iv, nonce, GMAC_NONCE_LEN);\n\tmemset(iv + GMAC_NONCE_LEN, 0, sizeof(iv) - GMAC_NONCE_LEN);\n\tiv[AES_BLOCK_SIZE - 1] = 0x01;\n\n\taead_request_set_tfm(aead_req, tfm);\n\taead_request_set_crypt(aead_req, sg, sg, 0, iv);\n\taead_request_set_ad(aead_req, GMAC_AAD_LEN + data_len);\n\n\tret = crypto_aead_encrypt(aead_req);\n\tkfree_sensitive(aead_req);\n\n\treturn ret;\n}\n\nstruct crypto_aead *ieee80211_aes_gmac_key_setup(const u8 key[],\n\t\t\t\t\t\t size_t key_len)\n{\n\tstruct crypto_aead *tfm;\n\tint err;\n\n\ttfm = crypto_alloc_aead(\"gcm(aes)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm))\n\t\treturn tfm;\n\n\terr = crypto_aead_setkey(tfm, key, key_len);\n\tif (!err)\n\t\terr = crypto_aead_setauthsize(tfm, GMAC_MIC_LEN);\n\tif (!err)\n\t\treturn tfm;\n\n\tcrypto_free_aead(tfm);\n\treturn ERR_PTR(err);\n}\n\nvoid ieee80211_aes_gmac_key_free(struct crypto_aead *tfm)\n{\n\tcrypto_free_aead(tfm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}