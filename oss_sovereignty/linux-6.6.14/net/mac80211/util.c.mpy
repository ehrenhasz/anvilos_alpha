{
  "module_name": "util.c",
  "hash_id": "451fc043ea65e77e6ea5483a9964da72618906b54b580bc68f7f80c268c2c0ec",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/util.c",
  "human_readable_source": "\n \n\n#include <net/mac80211.h>\n#include <linux/netdevice.h>\n#include <linux/export.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/bitmap.h>\n#include <linux/crc32.h>\n#include <net/net_namespace.h>\n#include <net/cfg80211.h>\n#include <net/rtnetlink.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"rate.h\"\n#include \"mesh.h\"\n#include \"wme.h\"\n#include \"led.h\"\n#include \"wep.h\"\n\n \nconst void *const mac80211_wiphy_privid = &mac80211_wiphy_privid;\n\nstruct ieee80211_hw *wiphy_to_ieee80211_hw(struct wiphy *wiphy)\n{\n\tstruct ieee80211_local *local;\n\n\tlocal = wiphy_priv(wiphy);\n\treturn &local->hw;\n}\nEXPORT_SYMBOL(wiphy_to_ieee80211_hw);\n\nu8 *ieee80211_get_bssid(struct ieee80211_hdr *hdr, size_t len,\n\t\t\tenum nl80211_iftype type)\n{\n\t__le16 fc = hdr->frame_control;\n\n\tif (ieee80211_is_data(fc)) {\n\t\tif (len < 24)  \n\t\t\treturn NULL;\n\n\t\tif (ieee80211_has_a4(fc))\n\t\t\treturn NULL;\n\t\tif (ieee80211_has_tods(fc))\n\t\t\treturn hdr->addr1;\n\t\tif (ieee80211_has_fromds(fc))\n\t\t\treturn hdr->addr2;\n\n\t\treturn hdr->addr3;\n\t}\n\n\tif (ieee80211_is_s1g_beacon(fc)) {\n\t\tstruct ieee80211_ext *ext = (void *) hdr;\n\n\t\treturn ext->u.s1g_beacon.sa;\n\t}\n\n\tif (ieee80211_is_mgmt(fc)) {\n\t\tif (len < 24)  \n\t\t\treturn NULL;\n\t\treturn hdr->addr3;\n\t}\n\n\tif (ieee80211_is_ctl(fc)) {\n\t\tif (ieee80211_is_pspoll(fc))\n\t\t\treturn hdr->addr1;\n\n\t\tif (ieee80211_is_back_req(fc)) {\n\t\t\tswitch (type) {\n\t\t\tcase NL80211_IFTYPE_STATION:\n\t\t\t\treturn hdr->addr2;\n\t\t\tcase NL80211_IFTYPE_AP:\n\t\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t\t\treturn hdr->addr1;\n\t\t\tdefault:\n\t\t\t\tbreak;  \n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(ieee80211_get_bssid);\n\nvoid ieee80211_tx_set_protected(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t}\n}\n\nint ieee80211_frame_duration(enum nl80211_band band, size_t len,\n\t\t\t     int rate, int erp, int short_preamble,\n\t\t\t     int shift)\n{\n\tint dur;\n\n\t \n\n\tif (band == NL80211_BAND_5GHZ || erp) {\n\t\t \n\t\tdur = 16;  \n\t\tdur += 16;  \n\t\tdur += 4;  \n\n\t\t \n\t\tdur *= 1 << shift;\n\n\t\t \n\t\tdur += 4 * DIV_ROUND_UP((16 + 8 * (len + 4) + 6) * 10,\n\t\t\t\t\t4 * rate);  \n\t} else {\n\t\t \n\t\tdur = 10;  \n\t\tdur += short_preamble ? (72 + 24) : (144 + 48);\n\n\t\tdur += DIV_ROUND_UP(8 * (len + 4) * 10, rate);\n\t}\n\n\treturn dur;\n}\n\n \n__le16 ieee80211_generic_frame_duration(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tenum nl80211_band band,\n\t\t\t\t\tsize_t frame_len,\n\t\t\t\t\tstruct ieee80211_rate *rate)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tu16 dur;\n\tint erp, shift = 0;\n\tbool short_preamble = false;\n\n\terp = 0;\n\tif (vif) {\n\t\tsdata = vif_to_sdata(vif);\n\t\tshort_preamble = sdata->vif.bss_conf.use_short_preamble;\n\t\tif (sdata->deflink.operating_11g_mode)\n\t\t\terp = rate->flags & IEEE80211_RATE_ERP_G;\n\t\tshift = ieee80211_vif_get_shift(vif);\n\t}\n\n\tdur = ieee80211_frame_duration(band, frame_len, rate->bitrate, erp,\n\t\t\t\t       short_preamble, shift);\n\n\treturn cpu_to_le16(dur);\n}\nEXPORT_SYMBOL(ieee80211_generic_frame_duration);\n\n__le16 ieee80211_rts_duration(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, size_t frame_len,\n\t\t\t      const struct ieee80211_tx_info *frame_txctl)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_rate *rate;\n\tstruct ieee80211_sub_if_data *sdata;\n\tbool short_preamble;\n\tint erp, shift = 0, bitrate;\n\tu16 dur;\n\tstruct ieee80211_supported_band *sband;\n\n\tsband = local->hw.wiphy->bands[frame_txctl->band];\n\n\tshort_preamble = false;\n\n\trate = &sband->bitrates[frame_txctl->control.rts_cts_rate_idx];\n\n\terp = 0;\n\tif (vif) {\n\t\tsdata = vif_to_sdata(vif);\n\t\tshort_preamble = sdata->vif.bss_conf.use_short_preamble;\n\t\tif (sdata->deflink.operating_11g_mode)\n\t\t\terp = rate->flags & IEEE80211_RATE_ERP_G;\n\t\tshift = ieee80211_vif_get_shift(vif);\n\t}\n\n\tbitrate = DIV_ROUND_UP(rate->bitrate, 1 << shift);\n\n\t \n\tdur = ieee80211_frame_duration(sband->band, 10, bitrate,\n\t\t\t\t       erp, short_preamble, shift);\n\t \n\tdur += ieee80211_frame_duration(sband->band, frame_len, bitrate,\n\t\t\t\t\terp, short_preamble, shift);\n\t \n\tdur += ieee80211_frame_duration(sband->band, 10, bitrate,\n\t\t\t\t\terp, short_preamble, shift);\n\n\treturn cpu_to_le16(dur);\n}\nEXPORT_SYMBOL(ieee80211_rts_duration);\n\n__le16 ieee80211_ctstoself_duration(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    size_t frame_len,\n\t\t\t\t    const struct ieee80211_tx_info *frame_txctl)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_rate *rate;\n\tstruct ieee80211_sub_if_data *sdata;\n\tbool short_preamble;\n\tint erp, shift = 0, bitrate;\n\tu16 dur;\n\tstruct ieee80211_supported_band *sband;\n\n\tsband = local->hw.wiphy->bands[frame_txctl->band];\n\n\tshort_preamble = false;\n\n\trate = &sband->bitrates[frame_txctl->control.rts_cts_rate_idx];\n\terp = 0;\n\tif (vif) {\n\t\tsdata = vif_to_sdata(vif);\n\t\tshort_preamble = sdata->vif.bss_conf.use_short_preamble;\n\t\tif (sdata->deflink.operating_11g_mode)\n\t\t\terp = rate->flags & IEEE80211_RATE_ERP_G;\n\t\tshift = ieee80211_vif_get_shift(vif);\n\t}\n\n\tbitrate = DIV_ROUND_UP(rate->bitrate, 1 << shift);\n\n\t \n\tdur = ieee80211_frame_duration(sband->band, frame_len, bitrate,\n\t\t\t\t       erp, short_preamble, shift);\n\tif (!(frame_txctl->flags & IEEE80211_TX_CTL_NO_ACK)) {\n\t\t \n\t\tdur += ieee80211_frame_duration(sband->band, 10, bitrate,\n\t\t\t\t\t\terp, short_preamble, shift);\n\t}\n\n\treturn cpu_to_le16(dur);\n}\nEXPORT_SYMBOL(ieee80211_ctstoself_duration);\n\nstatic void wake_tx_push_queue(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t       struct ieee80211_txq *queue)\n{\n\tstruct ieee80211_tx_control control = {\n\t\t.sta = queue->sta,\n\t};\n\tstruct sk_buff *skb;\n\n\twhile (1) {\n\t\tskb = ieee80211_tx_dequeue(&local->hw, queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tdrv_tx(local, &control, skb);\n\t}\n}\n\n \nvoid ieee80211_handle_wake_tx_queue(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_txq *txq)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(txq->vif);\n\tstruct ieee80211_txq *queue;\n\n\tspin_lock(&local->handle_wake_tx_queue_lock);\n\n\t \n\tieee80211_txq_schedule_start(hw, txq->ac);\n\twhile ((queue = ieee80211_next_txq(hw, txq->ac))) {\n\t\twake_tx_push_queue(local, sdata, queue);\n\t\tieee80211_return_txq(hw, queue, false);\n\t}\n\tieee80211_txq_schedule_end(hw, txq->ac);\n\tspin_unlock(&local->handle_wake_tx_queue_lock);\n}\nEXPORT_SYMBOL(ieee80211_handle_wake_tx_queue);\n\nstatic void __ieee80211_wake_txqs(struct ieee80211_sub_if_data *sdata, int ac)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_vif *vif = &sdata->vif;\n\tstruct fq *fq = &local->fq;\n\tstruct ps_data *ps = NULL;\n\tstruct txq_info *txqi;\n\tstruct sta_info *sta;\n\tint i;\n\n\tlocal_bh_disable();\n\tspin_lock(&fq->lock);\n\n\tif (!test_bit(SDATA_STATE_RUNNING, &sdata->state))\n\t\tgoto out;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\tps = &sdata->bss->ps;\n\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {\n\t\t\tstruct ieee80211_txq *txq = sta->sta.txq[i];\n\n\t\t\tif (!txq)\n\t\t\t\tcontinue;\n\n\t\t\ttxqi = to_txq_info(txq);\n\n\t\t\tif (ac != txq->ac)\n\t\t\t\tcontinue;\n\n\t\t\tif (!test_and_clear_bit(IEEE80211_TXQ_DIRTY,\n\t\t\t\t\t\t&txqi->flags))\n\t\t\t\tcontinue;\n\n\t\t\tspin_unlock(&fq->lock);\n\t\t\tdrv_wake_tx_queue(local, txqi);\n\t\t\tspin_lock(&fq->lock);\n\t\t}\n\t}\n\n\tif (!vif->txq)\n\t\tgoto out;\n\n\ttxqi = to_txq_info(vif->txq);\n\n\tif (!test_and_clear_bit(IEEE80211_TXQ_DIRTY, &txqi->flags) ||\n\t    (ps && atomic_read(&ps->num_sta_ps)) || ac != vif->txq->ac)\n\t\tgoto out;\n\n\tspin_unlock(&fq->lock);\n\n\tdrv_wake_tx_queue(local, txqi);\n\tlocal_bh_enable();\n\treturn;\nout:\n\tspin_unlock(&fq->lock);\n\tlocal_bh_enable();\n}\n\nstatic void\n__releases(&local->queue_stop_reason_lock)\n__acquires(&local->queue_stop_reason_lock)\n_ieee80211_wake_txqs(struct ieee80211_local *local, unsigned long *flags)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tint n_acs = IEEE80211_NUM_ACS;\n\tint i;\n\n\trcu_read_lock();\n\n\tif (local->hw.queues < IEEE80211_NUM_ACS)\n\t\tn_acs = 1;\n\n\tfor (i = 0; i < local->hw.queues; i++) {\n\t\tif (local->queue_stop_reasons[i])\n\t\t\tcontinue;\n\n\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, *flags);\n\t\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\t\tint ac;\n\n\t\t\tfor (ac = 0; ac < n_acs; ac++) {\n\t\t\t\tint ac_queue = sdata->vif.hw_queue[ac];\n\n\t\t\t\tif (ac_queue == i ||\n\t\t\t\t    sdata->vif.cab_queue == i)\n\t\t\t\t\t__ieee80211_wake_txqs(sdata, ac);\n\t\t\t}\n\t\t}\n\t\tspin_lock_irqsave(&local->queue_stop_reason_lock, *flags);\n\t}\n\n\trcu_read_unlock();\n}\n\nvoid ieee80211_wake_txqs(struct tasklet_struct *t)\n{\n\tstruct ieee80211_local *local = from_tasklet(local, t,\n\t\t\t\t\t\t     wake_txqs_tasklet);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\t_ieee80211_wake_txqs(local, &flags);\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n}\n\nstatic void __ieee80211_wake_queue(struct ieee80211_hw *hw, int queue,\n\t\t\t\t   enum queue_stop_reason reason,\n\t\t\t\t   bool refcounted,\n\t\t\t\t   unsigned long *flags)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\ttrace_wake_queue(local, queue, reason);\n\n\tif (WARN_ON(queue >= hw->queues))\n\t\treturn;\n\n\tif (!test_bit(reason, &local->queue_stop_reasons[queue]))\n\t\treturn;\n\n\tif (!refcounted) {\n\t\tlocal->q_stop_reasons[queue][reason] = 0;\n\t} else {\n\t\tlocal->q_stop_reasons[queue][reason]--;\n\t\tif (WARN_ON(local->q_stop_reasons[queue][reason] < 0))\n\t\t\tlocal->q_stop_reasons[queue][reason] = 0;\n\t}\n\n\tif (local->q_stop_reasons[queue][reason] == 0)\n\t\t__clear_bit(reason, &local->queue_stop_reasons[queue]);\n\n\tif (local->queue_stop_reasons[queue] != 0)\n\t\t \n\t\treturn;\n\n\tif (!skb_queue_empty(&local->pending[queue]))\n\t\ttasklet_schedule(&local->tx_pending_tasklet);\n\n\t \n\tif (reason == IEEE80211_QUEUE_STOP_REASON_DRIVER)\n\t\ttasklet_schedule(&local->wake_txqs_tasklet);\n\telse\n\t\t_ieee80211_wake_txqs(local, flags);\n}\n\nvoid ieee80211_wake_queue_by_reason(struct ieee80211_hw *hw, int queue,\n\t\t\t\t    enum queue_stop_reason reason,\n\t\t\t\t    bool refcounted)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\t__ieee80211_wake_queue(hw, queue, reason, refcounted, &flags);\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n}\n\nvoid ieee80211_wake_queue(struct ieee80211_hw *hw, int queue)\n{\n\tieee80211_wake_queue_by_reason(hw, queue,\n\t\t\t\t       IEEE80211_QUEUE_STOP_REASON_DRIVER,\n\t\t\t\t       false);\n}\nEXPORT_SYMBOL(ieee80211_wake_queue);\n\nstatic void __ieee80211_stop_queue(struct ieee80211_hw *hw, int queue,\n\t\t\t\t   enum queue_stop_reason reason,\n\t\t\t\t   bool refcounted)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\ttrace_stop_queue(local, queue, reason);\n\n\tif (WARN_ON(queue >= hw->queues))\n\t\treturn;\n\n\tif (!refcounted)\n\t\tlocal->q_stop_reasons[queue][reason] = 1;\n\telse\n\t\tlocal->q_stop_reasons[queue][reason]++;\n\n\tset_bit(reason, &local->queue_stop_reasons[queue]);\n}\n\nvoid ieee80211_stop_queue_by_reason(struct ieee80211_hw *hw, int queue,\n\t\t\t\t    enum queue_stop_reason reason,\n\t\t\t\t    bool refcounted)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\t__ieee80211_stop_queue(hw, queue, reason, refcounted);\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n}\n\nvoid ieee80211_stop_queue(struct ieee80211_hw *hw, int queue)\n{\n\tieee80211_stop_queue_by_reason(hw, queue,\n\t\t\t\t       IEEE80211_QUEUE_STOP_REASON_DRIVER,\n\t\t\t\t       false);\n}\nEXPORT_SYMBOL(ieee80211_stop_queue);\n\nvoid ieee80211_add_pending_skb(struct ieee80211_local *local,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_hw *hw = &local->hw;\n\tunsigned long flags;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint queue = info->hw_queue;\n\n\tif (WARN_ON(!info->control.vif)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\t__ieee80211_stop_queue(hw, queue, IEEE80211_QUEUE_STOP_REASON_SKB_ADD,\n\t\t\t       false);\n\t__skb_queue_tail(&local->pending[queue], skb);\n\t__ieee80211_wake_queue(hw, queue, IEEE80211_QUEUE_STOP_REASON_SKB_ADD,\n\t\t\t       false, &flags);\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n}\n\nvoid ieee80211_add_pending_skbs(struct ieee80211_local *local,\n\t\t\t\tstruct sk_buff_head *skbs)\n{\n\tstruct ieee80211_hw *hw = &local->hw;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tint queue, i;\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\twhile ((skb = skb_dequeue(skbs))) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\tif (WARN_ON(!info->control.vif)) {\n\t\t\tieee80211_free_txskb(&local->hw, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqueue = info->hw_queue;\n\n\t\t__ieee80211_stop_queue(hw, queue,\n\t\t\t\tIEEE80211_QUEUE_STOP_REASON_SKB_ADD,\n\t\t\t\tfalse);\n\n\t\t__skb_queue_tail(&local->pending[queue], skb);\n\t}\n\n\tfor (i = 0; i < hw->queues; i++)\n\t\t__ieee80211_wake_queue(hw, i,\n\t\t\tIEEE80211_QUEUE_STOP_REASON_SKB_ADD,\n\t\t\tfalse, &flags);\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n}\n\nvoid ieee80211_stop_queues_by_reason(struct ieee80211_hw *hw,\n\t\t\t\t     unsigned long queues,\n\t\t\t\t     enum queue_stop_reason reason,\n\t\t\t\t     bool refcounted)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\n\tfor_each_set_bit(i, &queues, hw->queues)\n\t\t__ieee80211_stop_queue(hw, i, reason, refcounted);\n\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n}\n\nvoid ieee80211_stop_queues(struct ieee80211_hw *hw)\n{\n\tieee80211_stop_queues_by_reason(hw, IEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_DRIVER,\n\t\t\t\t\tfalse);\n}\nEXPORT_SYMBOL(ieee80211_stop_queues);\n\nint ieee80211_queue_stopped(struct ieee80211_hw *hw, int queue)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tunsigned long flags;\n\tint ret;\n\n\tif (WARN_ON(queue >= hw->queues))\n\t\treturn true;\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\tret = test_bit(IEEE80211_QUEUE_STOP_REASON_DRIVER,\n\t\t       &local->queue_stop_reasons[queue]);\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_queue_stopped);\n\nvoid ieee80211_wake_queues_by_reason(struct ieee80211_hw *hw,\n\t\t\t\t     unsigned long queues,\n\t\t\t\t     enum queue_stop_reason reason,\n\t\t\t\t     bool refcounted)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\n\tfor_each_set_bit(i, &queues, hw->queues)\n\t\t__ieee80211_wake_queue(hw, i, reason, refcounted, &flags);\n\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n}\n\nvoid ieee80211_wake_queues(struct ieee80211_hw *hw)\n{\n\tieee80211_wake_queues_by_reason(hw, IEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_DRIVER,\n\t\t\t\t\tfalse);\n}\nEXPORT_SYMBOL(ieee80211_wake_queues);\n\nstatic unsigned int\nieee80211_get_vif_queues(struct ieee80211_local *local,\n\t\t\t struct ieee80211_sub_if_data *sdata)\n{\n\tunsigned int queues;\n\n\tif (sdata && ieee80211_hw_check(&local->hw, QUEUE_CONTROL)) {\n\t\tint ac;\n\n\t\tqueues = 0;\n\n\t\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\t\tqueues |= BIT(sdata->vif.hw_queue[ac]);\n\t\tif (sdata->vif.cab_queue != IEEE80211_INVAL_HW_QUEUE)\n\t\t\tqueues |= BIT(sdata->vif.cab_queue);\n\t} else {\n\t\t \n\t\tqueues = BIT(local->hw.queues) - 1;\n\t}\n\n\treturn queues;\n}\n\nvoid __ieee80211_flush_queues(struct ieee80211_local *local,\n\t\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t\t      unsigned int queues, bool drop)\n{\n\tif (!local->ops->flush)\n\t\treturn;\n\n\t \n\tif (!queues || !ieee80211_hw_check(&local->hw, QUEUE_CONTROL))\n\t\tqueues = ieee80211_get_vif_queues(local, sdata);\n\n\tieee80211_stop_queues_by_reason(&local->hw, queues,\n\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_FLUSH,\n\t\t\t\t\tfalse);\n\n\tdrv_flush(local, sdata, queues, drop);\n\n\tieee80211_wake_queues_by_reason(&local->hw, queues,\n\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_FLUSH,\n\t\t\t\t\tfalse);\n}\n\nvoid ieee80211_flush_queues(struct ieee80211_local *local,\n\t\t\t    struct ieee80211_sub_if_data *sdata, bool drop)\n{\n\t__ieee80211_flush_queues(local, sdata, 0, drop);\n}\n\nvoid ieee80211_stop_vif_queues(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t       enum queue_stop_reason reason)\n{\n\tieee80211_stop_queues_by_reason(&local->hw,\n\t\t\t\t\tieee80211_get_vif_queues(local, sdata),\n\t\t\t\t\treason, true);\n}\n\nvoid ieee80211_wake_vif_queues(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t       enum queue_stop_reason reason)\n{\n\tieee80211_wake_queues_by_reason(&local->hw,\n\t\t\t\t\tieee80211_get_vif_queues(local, sdata),\n\t\t\t\t\treason, true);\n}\n\nstatic void __iterate_interfaces(struct ieee80211_local *local,\n\t\t\t\t u32 iter_flags,\n\t\t\t\t void (*iterator)(void *data, u8 *mac,\n\t\t\t\t\t\t  struct ieee80211_vif *vif),\n\t\t\t\t void *data)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tbool active_only = iter_flags & IEEE80211_IFACE_ITER_ACTIVE;\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tswitch (sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_MONITOR:\n\t\t\tif (!(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (!(iter_flags & IEEE80211_IFACE_ITER_RESUME_ALL) &&\n\t\t    active_only && !(sdata->flags & IEEE80211_SDATA_IN_DRIVER))\n\t\t\tcontinue;\n\t\tif ((iter_flags & IEEE80211_IFACE_SKIP_SDATA_NOT_IN_DRIVER) &&\n\t\t    !(sdata->flags & IEEE80211_SDATA_IN_DRIVER))\n\t\t\tcontinue;\n\t\tif (ieee80211_sdata_running(sdata) || !active_only)\n\t\t\titerator(data, sdata->vif.addr,\n\t\t\t\t &sdata->vif);\n\t}\n\n\tsdata = rcu_dereference_check(local->monitor_sdata,\n\t\t\t\t      lockdep_is_held(&local->iflist_mtx) ||\n\t\t\t\t      lockdep_is_held(&local->hw.wiphy->mtx));\n\tif (sdata &&\n\t    (iter_flags & IEEE80211_IFACE_ITER_RESUME_ALL || !active_only ||\n\t     sdata->flags & IEEE80211_SDATA_IN_DRIVER))\n\t\titerator(data, sdata->vif.addr, &sdata->vif);\n}\n\nvoid ieee80211_iterate_interfaces(\n\tstruct ieee80211_hw *hw, u32 iter_flags,\n\tvoid (*iterator)(void *data, u8 *mac,\n\t\t\t struct ieee80211_vif *vif),\n\tvoid *data)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tmutex_lock(&local->iflist_mtx);\n\t__iterate_interfaces(local, iter_flags, iterator, data);\n\tmutex_unlock(&local->iflist_mtx);\n}\nEXPORT_SYMBOL_GPL(ieee80211_iterate_interfaces);\n\nvoid ieee80211_iterate_active_interfaces_atomic(\n\tstruct ieee80211_hw *hw, u32 iter_flags,\n\tvoid (*iterator)(void *data, u8 *mac,\n\t\t\t struct ieee80211_vif *vif),\n\tvoid *data)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\trcu_read_lock();\n\t__iterate_interfaces(local, iter_flags | IEEE80211_IFACE_ITER_ACTIVE,\n\t\t\t     iterator, data);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(ieee80211_iterate_active_interfaces_atomic);\n\nvoid ieee80211_iterate_active_interfaces_mtx(\n\tstruct ieee80211_hw *hw, u32 iter_flags,\n\tvoid (*iterator)(void *data, u8 *mac,\n\t\t\t struct ieee80211_vif *vif),\n\tvoid *data)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tlockdep_assert_wiphy(hw->wiphy);\n\n\t__iterate_interfaces(local, iter_flags | IEEE80211_IFACE_ITER_ACTIVE,\n\t\t\t     iterator, data);\n}\nEXPORT_SYMBOL_GPL(ieee80211_iterate_active_interfaces_mtx);\n\nstatic void __iterate_stations(struct ieee80211_local *local,\n\t\t\t       void (*iterator)(void *data,\n\t\t\t\t\t\tstruct ieee80211_sta *sta),\n\t\t\t       void *data)\n{\n\tstruct sta_info *sta;\n\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (!sta->uploaded)\n\t\t\tcontinue;\n\n\t\titerator(data, &sta->sta);\n\t}\n}\n\nvoid ieee80211_iterate_stations_atomic(struct ieee80211_hw *hw,\n\t\t\tvoid (*iterator)(void *data,\n\t\t\t\t\t struct ieee80211_sta *sta),\n\t\t\tvoid *data)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\trcu_read_lock();\n\t__iterate_stations(local, iterator, data);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(ieee80211_iterate_stations_atomic);\n\nstruct ieee80211_vif *wdev_to_ieee80211_vif(struct wireless_dev *wdev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\n\tif (!ieee80211_sdata_running(sdata) ||\n\t    !(sdata->flags & IEEE80211_SDATA_IN_DRIVER))\n\t\treturn NULL;\n\treturn &sdata->vif;\n}\nEXPORT_SYMBOL_GPL(wdev_to_ieee80211_vif);\n\nstruct wireless_dev *ieee80211_vif_to_wdev(struct ieee80211_vif *vif)\n{\n\tif (!vif)\n\t\treturn NULL;\n\n\treturn &vif_to_sdata(vif)->wdev;\n}\nEXPORT_SYMBOL_GPL(ieee80211_vif_to_wdev);\n\n \nstatic bool ieee80211_can_queue_work(struct ieee80211_local *local)\n{\n\tif (local->quiescing || (local->suspended && !local->resuming)) {\n\t\tpr_warn(\"queueing ieee80211 work while going to suspend\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid ieee80211_queue_work(struct ieee80211_hw *hw, struct work_struct *work)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tif (!ieee80211_can_queue_work(local))\n\t\treturn;\n\n\tqueue_work(local->workqueue, work);\n}\nEXPORT_SYMBOL(ieee80211_queue_work);\n\nvoid ieee80211_queue_delayed_work(struct ieee80211_hw *hw,\n\t\t\t\t  struct delayed_work *dwork,\n\t\t\t\t  unsigned long delay)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tif (!ieee80211_can_queue_work(local))\n\t\treturn;\n\n\tqueue_delayed_work(local->workqueue, dwork, delay);\n}\nEXPORT_SYMBOL(ieee80211_queue_delayed_work);\n\nstatic void\nieee80211_parse_extension_element(u32 *crc,\n\t\t\t\t  const struct element *elem,\n\t\t\t\t  struct ieee802_11_elems *elems,\n\t\t\t\t  struct ieee80211_elems_parse_params *params)\n{\n\tconst void *data = elem->data + 1;\n\tbool calc_crc = false;\n\tu8 len;\n\n\tif (!elem->datalen)\n\t\treturn;\n\n\tlen = elem->datalen - 1;\n\n\tswitch (elem->data[0]) {\n\tcase WLAN_EID_EXT_HE_MU_EDCA:\n\t\tcalc_crc = true;\n\t\tif (len >= sizeof(*elems->mu_edca_param_set))\n\t\t\telems->mu_edca_param_set = data;\n\t\tbreak;\n\tcase WLAN_EID_EXT_HE_CAPABILITY:\n\t\tif (ieee80211_he_capa_size_ok(data, len)) {\n\t\t\telems->he_cap = data;\n\t\t\telems->he_cap_len = len;\n\t\t}\n\t\tbreak;\n\tcase WLAN_EID_EXT_HE_OPERATION:\n\t\tcalc_crc = true;\n\t\tif (len >= sizeof(*elems->he_operation) &&\n\t\t    len >= ieee80211_he_oper_size(data) - 1)\n\t\t\telems->he_operation = data;\n\t\tbreak;\n\tcase WLAN_EID_EXT_UORA:\n\t\tif (len >= 1)\n\t\t\telems->uora_element = data;\n\t\tbreak;\n\tcase WLAN_EID_EXT_MAX_CHANNEL_SWITCH_TIME:\n\t\tif (len == 3)\n\t\t\telems->max_channel_switch_time = data;\n\t\tbreak;\n\tcase WLAN_EID_EXT_MULTIPLE_BSSID_CONFIGURATION:\n\t\tif (len >= sizeof(*elems->mbssid_config_ie))\n\t\t\telems->mbssid_config_ie = data;\n\t\tbreak;\n\tcase WLAN_EID_EXT_HE_SPR:\n\t\tif (len >= sizeof(*elems->he_spr) &&\n\t\t    len >= ieee80211_he_spr_size(data))\n\t\t\telems->he_spr = data;\n\t\tbreak;\n\tcase WLAN_EID_EXT_HE_6GHZ_CAPA:\n\t\tif (len >= sizeof(*elems->he_6ghz_capa))\n\t\t\telems->he_6ghz_capa = data;\n\t\tbreak;\n\tcase WLAN_EID_EXT_EHT_CAPABILITY:\n\t\tif (ieee80211_eht_capa_size_ok(elems->he_cap,\n\t\t\t\t\t       data, len,\n\t\t\t\t\t       params->from_ap)) {\n\t\t\telems->eht_cap = data;\n\t\t\telems->eht_cap_len = len;\n\t\t}\n\t\tbreak;\n\tcase WLAN_EID_EXT_EHT_OPERATION:\n\t\tif (ieee80211_eht_oper_size_ok(data, len))\n\t\t\telems->eht_operation = data;\n\t\tcalc_crc = true;\n\t\tbreak;\n\tcase WLAN_EID_EXT_EHT_MULTI_LINK:\n\t\tcalc_crc = true;\n\n\t\tif (ieee80211_mle_size_ok(data, len)) {\n\t\t\tconst struct ieee80211_multi_link_elem *mle =\n\t\t\t\t(void *)data;\n\n\t\t\tswitch (le16_get_bits(mle->control,\n\t\t\t\t\t      IEEE80211_ML_CONTROL_TYPE)) {\n\t\t\tcase IEEE80211_ML_CONTROL_TYPE_BASIC:\n\t\t\t\telems->ml_basic_elem = (void *)elem;\n\t\t\t\telems->ml_basic = data;\n\t\t\t\telems->ml_basic_len = len;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_ML_CONTROL_TYPE_RECONF:\n\t\t\t\telems->ml_reconf_elem = (void *)elem;\n\t\t\t\telems->ml_reconf = data;\n\t\t\t\telems->ml_reconf_len = len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (crc && calc_crc)\n\t\t*crc = crc32_be(*crc, (void *)elem, elem->datalen + 2);\n}\n\nstatic u32\n_ieee802_11_parse_elems_full(struct ieee80211_elems_parse_params *params,\n\t\t\t     struct ieee802_11_elems *elems,\n\t\t\t     const struct element *check_inherit)\n{\n\tconst struct element *elem;\n\tbool calc_crc = params->filter != 0;\n\tDECLARE_BITMAP(seen_elems, 256);\n\tu32 crc = params->crc;\n\tconst u8 *ie;\n\n\tbitmap_zero(seen_elems, 256);\n\n\tfor_each_element(elem, params->start, params->len) {\n\t\tbool elem_parse_failed;\n\t\tu8 id = elem->id;\n\t\tu8 elen = elem->datalen;\n\t\tconst u8 *pos = elem->data;\n\n\t\tif (check_inherit &&\n\t\t    !cfg80211_is_element_inherited(elem,\n\t\t\t\t\t\t   check_inherit))\n\t\t\tcontinue;\n\n\t\tswitch (id) {\n\t\tcase WLAN_EID_SSID:\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\tcase WLAN_EID_FH_PARAMS:\n\t\tcase WLAN_EID_DS_PARAMS:\n\t\tcase WLAN_EID_CF_PARAMS:\n\t\tcase WLAN_EID_TIM:\n\t\tcase WLAN_EID_IBSS_PARAMS:\n\t\tcase WLAN_EID_CHALLENGE:\n\t\tcase WLAN_EID_RSN:\n\t\tcase WLAN_EID_ERP_INFO:\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\tcase WLAN_EID_HT_OPERATION:\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\tcase WLAN_EID_VHT_OPERATION:\n\t\tcase WLAN_EID_MESH_ID:\n\t\tcase WLAN_EID_MESH_CONFIG:\n\t\tcase WLAN_EID_PEER_MGMT:\n\t\tcase WLAN_EID_PREQ:\n\t\tcase WLAN_EID_PREP:\n\t\tcase WLAN_EID_PERR:\n\t\tcase WLAN_EID_RANN:\n\t\tcase WLAN_EID_CHANNEL_SWITCH:\n\t\tcase WLAN_EID_EXT_CHANSWITCH_ANN:\n\t\tcase WLAN_EID_COUNTRY:\n\t\tcase WLAN_EID_PWR_CONSTRAINT:\n\t\tcase WLAN_EID_TIMEOUT_INTERVAL:\n\t\tcase WLAN_EID_SECONDARY_CHANNEL_OFFSET:\n\t\tcase WLAN_EID_WIDE_BW_CHANNEL_SWITCH:\n\t\tcase WLAN_EID_CHAN_SWITCH_PARAM:\n\t\tcase WLAN_EID_EXT_CAPABILITY:\n\t\tcase WLAN_EID_CHAN_SWITCH_TIMING:\n\t\tcase WLAN_EID_LINK_ID:\n\t\tcase WLAN_EID_BSS_MAX_IDLE_PERIOD:\n\t\tcase WLAN_EID_RSNX:\n\t\tcase WLAN_EID_S1G_BCN_COMPAT:\n\t\tcase WLAN_EID_S1G_CAPABILITIES:\n\t\tcase WLAN_EID_S1G_OPERATION:\n\t\tcase WLAN_EID_AID_RESPONSE:\n\t\tcase WLAN_EID_S1G_SHORT_BCN_INTERVAL:\n\t\t \n\t\t\tif (test_bit(id, seen_elems)) {\n\t\t\t\telems->parse_error = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (calc_crc && id < 64 && (params->filter & (1ULL << id)))\n\t\t\tcrc = crc32_be(crc, pos - 2, elen + 2);\n\n\t\telem_parse_failed = false;\n\n\t\tswitch (id) {\n\t\tcase WLAN_EID_LINK_ID:\n\t\t\tif (elen + 2 < sizeof(struct ieee80211_tdls_lnkie)) {\n\t\t\t\telem_parse_failed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telems->lnk_id = (void *)(pos - 2);\n\t\t\tbreak;\n\t\tcase WLAN_EID_CHAN_SWITCH_TIMING:\n\t\t\tif (elen < sizeof(struct ieee80211_ch_switch_timing)) {\n\t\t\t\telem_parse_failed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telems->ch_sw_timing = (void *)pos;\n\t\t\tbreak;\n\t\tcase WLAN_EID_EXT_CAPABILITY:\n\t\t\telems->ext_capab = pos;\n\t\t\telems->ext_capab_len = elen;\n\t\t\tbreak;\n\t\tcase WLAN_EID_SSID:\n\t\t\telems->ssid = pos;\n\t\t\telems->ssid_len = elen;\n\t\t\tbreak;\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\t\telems->supp_rates = pos;\n\t\t\telems->supp_rates_len = elen;\n\t\t\tbreak;\n\t\tcase WLAN_EID_DS_PARAMS:\n\t\t\tif (elen >= 1)\n\t\t\t\telems->ds_params = pos;\n\t\t\telse\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_TIM:\n\t\t\tif (elen >= sizeof(struct ieee80211_tim_ie)) {\n\t\t\t\telems->tim = (void *)pos;\n\t\t\t\telems->tim_len = elen;\n\t\t\t} else\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tif (elen >= 4 && pos[0] == 0x00 && pos[1] == 0x50 &&\n\t\t\t    pos[2] == 0xf2) {\n\t\t\t\t \n\n\t\t\t\tif (calc_crc)\n\t\t\t\t\tcrc = crc32_be(crc, pos - 2, elen + 2);\n\n\t\t\t\tif (elen >= 5 && pos[3] == 2) {\n\t\t\t\t\t \n\t\t\t\t\tif (pos[4] == 0) {\n\t\t\t\t\t\telems->wmm_info = pos;\n\t\t\t\t\t\telems->wmm_info_len = elen;\n\t\t\t\t\t} else if (pos[4] == 1) {\n\t\t\t\t\t\telems->wmm_param = pos;\n\t\t\t\t\t\telems->wmm_param_len = elen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_EID_RSN:\n\t\t\telems->rsn = pos;\n\t\t\telems->rsn_len = elen;\n\t\t\tbreak;\n\t\tcase WLAN_EID_ERP_INFO:\n\t\t\tif (elen >= 1)\n\t\t\t\telems->erp_info = pos;\n\t\t\telse\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\t\telems->ext_supp_rates = pos;\n\t\t\telems->ext_supp_rates_len = elen;\n\t\t\tbreak;\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\t\tif (elen >= sizeof(struct ieee80211_ht_cap))\n\t\t\t\telems->ht_cap_elem = (void *)pos;\n\t\t\telse\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_HT_OPERATION:\n\t\t\tif (elen >= sizeof(struct ieee80211_ht_operation))\n\t\t\t\telems->ht_operation = (void *)pos;\n\t\t\telse\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\t\tif (elen >= sizeof(struct ieee80211_vht_cap))\n\t\t\t\telems->vht_cap_elem = (void *)pos;\n\t\t\telse\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_VHT_OPERATION:\n\t\t\tif (elen >= sizeof(struct ieee80211_vht_operation)) {\n\t\t\t\telems->vht_operation = (void *)pos;\n\t\t\t\tif (calc_crc)\n\t\t\t\t\tcrc = crc32_be(crc, pos - 2, elen + 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_OPMODE_NOTIF:\n\t\t\tif (elen > 0) {\n\t\t\t\telems->opmode_notif = pos;\n\t\t\t\tif (calc_crc)\n\t\t\t\t\tcrc = crc32_be(crc, pos - 2, elen + 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_MESH_ID:\n\t\t\telems->mesh_id = pos;\n\t\t\telems->mesh_id_len = elen;\n\t\t\tbreak;\n\t\tcase WLAN_EID_MESH_CONFIG:\n\t\t\tif (elen >= sizeof(struct ieee80211_meshconf_ie))\n\t\t\t\telems->mesh_config = (void *)pos;\n\t\t\telse\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_PEER_MGMT:\n\t\t\telems->peering = pos;\n\t\t\telems->peering_len = elen;\n\t\t\tbreak;\n\t\tcase WLAN_EID_MESH_AWAKE_WINDOW:\n\t\t\tif (elen >= 2)\n\t\t\t\telems->awake_window = (void *)pos;\n\t\t\tbreak;\n\t\tcase WLAN_EID_PREQ:\n\t\t\telems->preq = pos;\n\t\t\telems->preq_len = elen;\n\t\t\tbreak;\n\t\tcase WLAN_EID_PREP:\n\t\t\telems->prep = pos;\n\t\t\telems->prep_len = elen;\n\t\t\tbreak;\n\t\tcase WLAN_EID_PERR:\n\t\t\telems->perr = pos;\n\t\t\telems->perr_len = elen;\n\t\t\tbreak;\n\t\tcase WLAN_EID_RANN:\n\t\t\tif (elen >= sizeof(struct ieee80211_rann_ie))\n\t\t\t\telems->rann = (void *)pos;\n\t\t\telse\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_CHANNEL_SWITCH:\n\t\t\tif (elen != sizeof(struct ieee80211_channel_sw_ie)) {\n\t\t\t\telem_parse_failed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telems->ch_switch_ie = (void *)pos;\n\t\t\tbreak;\n\t\tcase WLAN_EID_EXT_CHANSWITCH_ANN:\n\t\t\tif (elen != sizeof(struct ieee80211_ext_chansw_ie)) {\n\t\t\t\telem_parse_failed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telems->ext_chansw_ie = (void *)pos;\n\t\t\tbreak;\n\t\tcase WLAN_EID_SECONDARY_CHANNEL_OFFSET:\n\t\t\tif (elen != sizeof(struct ieee80211_sec_chan_offs_ie)) {\n\t\t\t\telem_parse_failed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telems->sec_chan_offs = (void *)pos;\n\t\t\tbreak;\n\t\tcase WLAN_EID_CHAN_SWITCH_PARAM:\n\t\t\tif (elen <\n\t\t\t    sizeof(*elems->mesh_chansw_params_ie)) {\n\t\t\t\telem_parse_failed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telems->mesh_chansw_params_ie = (void *)pos;\n\t\t\tbreak;\n\t\tcase WLAN_EID_WIDE_BW_CHANNEL_SWITCH:\n\t\t\tif (!params->action ||\n\t\t\t    elen < sizeof(*elems->wide_bw_chansw_ie)) {\n\t\t\t\telem_parse_failed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telems->wide_bw_chansw_ie = (void *)pos;\n\t\t\tbreak;\n\t\tcase WLAN_EID_CHANNEL_SWITCH_WRAPPER:\n\t\t\tif (params->action) {\n\t\t\t\telem_parse_failed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tie = cfg80211_find_ie(WLAN_EID_WIDE_BW_CHANNEL_SWITCH,\n\t\t\t\t\t      pos, elen);\n\t\t\tif (ie) {\n\t\t\t\tif (ie[1] >= sizeof(*elems->wide_bw_chansw_ie))\n\t\t\t\t\telems->wide_bw_chansw_ie =\n\t\t\t\t\t\t(void *)(ie + 2);\n\t\t\t\telse\n\t\t\t\t\telem_parse_failed = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_EID_COUNTRY:\n\t\t\telems->country_elem = pos;\n\t\t\telems->country_elem_len = elen;\n\t\t\tbreak;\n\t\tcase WLAN_EID_PWR_CONSTRAINT:\n\t\t\tif (elen != 1) {\n\t\t\t\telem_parse_failed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telems->pwr_constr_elem = pos;\n\t\t\tbreak;\n\t\tcase WLAN_EID_CISCO_VENDOR_SPECIFIC:\n\t\t\t \n\t\t\tif (elen < 4) {\n\t\t\t\telem_parse_failed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (pos[0] != 0x00 || pos[1] != 0x40 ||\n\t\t\t    pos[2] != 0x96 || pos[3] != 0x00)\n\t\t\t\tbreak;\n\n\t\t\tif (elen != 6) {\n\t\t\t\telem_parse_failed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (calc_crc)\n\t\t\t\tcrc = crc32_be(crc, pos - 2, elen + 2);\n\n\t\t\telems->cisco_dtpc_elem = pos;\n\t\t\tbreak;\n\t\tcase WLAN_EID_ADDBA_EXT:\n\t\t\tif (elen < sizeof(struct ieee80211_addba_ext_ie)) {\n\t\t\t\telem_parse_failed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telems->addba_ext_ie = (void *)pos;\n\t\t\tbreak;\n\t\tcase WLAN_EID_TIMEOUT_INTERVAL:\n\t\t\tif (elen >= sizeof(struct ieee80211_timeout_interval_ie))\n\t\t\t\telems->timeout_int = (void *)pos;\n\t\t\telse\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_BSS_MAX_IDLE_PERIOD:\n\t\t\tif (elen >= sizeof(*elems->max_idle_period_ie))\n\t\t\t\telems->max_idle_period_ie = (void *)pos;\n\t\t\tbreak;\n\t\tcase WLAN_EID_RSNX:\n\t\t\telems->rsnx = pos;\n\t\t\telems->rsnx_len = elen;\n\t\t\tbreak;\n\t\tcase WLAN_EID_TX_POWER_ENVELOPE:\n\t\t\tif (elen < 1 ||\n\t\t\t    elen > sizeof(struct ieee80211_tx_pwr_env))\n\t\t\t\tbreak;\n\n\t\t\tif (elems->tx_pwr_env_num >= ARRAY_SIZE(elems->tx_pwr_env))\n\t\t\t\tbreak;\n\n\t\t\telems->tx_pwr_env[elems->tx_pwr_env_num] = (void *)pos;\n\t\t\telems->tx_pwr_env_len[elems->tx_pwr_env_num] = elen;\n\t\t\telems->tx_pwr_env_num++;\n\t\t\tbreak;\n\t\tcase WLAN_EID_EXTENSION:\n\t\t\tieee80211_parse_extension_element(calc_crc ?\n\t\t\t\t\t\t\t\t&crc : NULL,\n\t\t\t\t\t\t\t  elem, elems, params);\n\t\t\tbreak;\n\t\tcase WLAN_EID_S1G_CAPABILITIES:\n\t\t\tif (elen >= sizeof(*elems->s1g_capab))\n\t\t\t\telems->s1g_capab = (void *)pos;\n\t\t\telse\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_S1G_OPERATION:\n\t\t\tif (elen == sizeof(*elems->s1g_oper))\n\t\t\t\telems->s1g_oper = (void *)pos;\n\t\t\telse\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_S1G_BCN_COMPAT:\n\t\t\tif (elen == sizeof(*elems->s1g_bcn_compat))\n\t\t\t\telems->s1g_bcn_compat = (void *)pos;\n\t\t\telse\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tcase WLAN_EID_AID_RESPONSE:\n\t\t\tif (elen == sizeof(struct ieee80211_aid_response_ie))\n\t\t\t\telems->aid_resp = (void *)pos;\n\t\t\telse\n\t\t\t\telem_parse_failed = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (elem_parse_failed)\n\t\t\telems->parse_error = true;\n\t\telse\n\t\t\t__set_bit(id, seen_elems);\n\t}\n\n\tif (!for_each_element_completed(elem, params->start, params->len))\n\t\telems->parse_error = true;\n\n\treturn crc;\n}\n\nstatic size_t ieee802_11_find_bssid_profile(const u8 *start, size_t len,\n\t\t\t\t\t    struct ieee802_11_elems *elems,\n\t\t\t\t\t    struct cfg80211_bss *bss,\n\t\t\t\t\t    u8 *nontransmitted_profile)\n{\n\tconst struct element *elem, *sub;\n\tsize_t profile_len = 0;\n\tbool found = false;\n\n\tif (!bss || !bss->transmitted_bss)\n\t\treturn profile_len;\n\n\tfor_each_element_id(elem, WLAN_EID_MULTIPLE_BSSID, start, len) {\n\t\tif (elem->datalen < 2)\n\t\t\tcontinue;\n\t\tif (elem->data[0] < 1 || elem->data[0] > 8)\n\t\t\tcontinue;\n\n\t\tfor_each_element(sub, elem->data + 1, elem->datalen - 1) {\n\t\t\tu8 new_bssid[ETH_ALEN];\n\t\t\tconst u8 *index;\n\n\t\t\tif (sub->id != 0 || sub->datalen < 4) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sub->data[0] != WLAN_EID_NON_TX_BSSID_CAP ||\n\t\t\t    sub->data[1] != 2) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemset(nontransmitted_profile, 0, len);\n\t\t\tprofile_len = cfg80211_merge_profile(start, len,\n\t\t\t\t\t\t\t     elem,\n\t\t\t\t\t\t\t     sub,\n\t\t\t\t\t\t\t     nontransmitted_profile,\n\t\t\t\t\t\t\t     len);\n\n\t\t\t \n\t\t\tindex = cfg80211_find_ie(WLAN_EID_MULTI_BSSID_IDX,\n\t\t\t\t\t\t nontransmitted_profile,\n\t\t\t\t\t\t profile_len);\n\t\t\tif (!index || index[1] < 1 || index[2] == 0) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcfg80211_gen_new_bssid(bss->transmitted_bss->bssid,\n\t\t\t\t\t       elem->data[0],\n\t\t\t\t\t       index[2],\n\t\t\t\t\t       new_bssid);\n\t\t\tif (ether_addr_equal(new_bssid, bss->bssid)) {\n\t\t\t\tfound = true;\n\t\t\t\telems->bssid_index_len = index[1];\n\t\t\t\telems->bssid_index = (void *)&index[2];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found ? profile_len : 0;\n}\n\nstatic void ieee80211_mle_get_sta_prof(struct ieee802_11_elems *elems,\n\t\t\t\t       u8 link_id)\n{\n\tconst struct ieee80211_multi_link_elem *ml = elems->ml_basic;\n\tssize_t ml_len = elems->ml_basic_len;\n\tconst struct element *sub;\n\n\tif (!ml || !ml_len)\n\t\treturn;\n\n\tif (le16_get_bits(ml->control, IEEE80211_ML_CONTROL_TYPE) !=\n\t    IEEE80211_ML_CONTROL_TYPE_BASIC)\n\t\treturn;\n\n\tfor_each_mle_subelement(sub, (u8 *)ml, ml_len) {\n\t\tstruct ieee80211_mle_per_sta_profile *prof = (void *)sub->data;\n\t\tssize_t sta_prof_len;\n\t\tu16 control;\n\n\t\tif (sub->id != IEEE80211_MLE_SUBELEM_PER_STA_PROFILE)\n\t\t\tcontinue;\n\n\t\tif (!ieee80211_mle_basic_sta_prof_size_ok(sub->data,\n\t\t\t\t\t\t\t  sub->datalen))\n\t\t\treturn;\n\n\t\tcontrol = le16_to_cpu(prof->control);\n\n\t\tif (link_id != u16_get_bits(control,\n\t\t\t\t\t    IEEE80211_MLE_STA_CONTROL_LINK_ID))\n\t\t\tcontinue;\n\n\t\tif (!(control & IEEE80211_MLE_STA_CONTROL_COMPLETE_PROFILE))\n\t\t\treturn;\n\n\t\t \n\t\tsta_prof_len =\n\t\t\tcfg80211_defragment_element(sub,\n\t\t\t\t\t\t    (u8 *)ml, ml_len,\n\t\t\t\t\t\t    elems->scratch_pos,\n\t\t\t\t\t\t    elems->scratch +\n\t\t\t\t\t\t\telems->scratch_len -\n\t\t\t\t\t\t\telems->scratch_pos,\n\t\t\t\t\t\t    IEEE80211_MLE_SUBELEM_FRAGMENT);\n\n\t\tif (sta_prof_len < 0)\n\t\t\treturn;\n\n\t\telems->prof = (void *)elems->scratch_pos;\n\t\telems->sta_prof_len = sta_prof_len;\n\t\telems->scratch_pos += sta_prof_len;\n\n\t\treturn;\n\t}\n}\n\nstatic void ieee80211_mle_parse_link(struct ieee802_11_elems *elems,\n\t\t\t\t     struct ieee80211_elems_parse_params *params)\n{\n\tstruct ieee80211_mle_per_sta_profile *prof;\n\tstruct ieee80211_elems_parse_params sub = {\n\t\t.action = params->action,\n\t\t.from_ap = params->from_ap,\n\t\t.link_id = -1,\n\t};\n\tssize_t ml_len = elems->ml_basic_len;\n\tconst struct element *non_inherit = NULL;\n\tconst u8 *end;\n\n\tif (params->link_id == -1)\n\t\treturn;\n\n\tml_len = cfg80211_defragment_element(elems->ml_basic_elem,\n\t\t\t\t\t     elems->ie_start,\n\t\t\t\t\t     elems->total_len,\n\t\t\t\t\t     elems->scratch_pos,\n\t\t\t\t\t     elems->scratch +\n\t\t\t\t\t\telems->scratch_len -\n\t\t\t\t\t\telems->scratch_pos,\n\t\t\t\t\t     WLAN_EID_FRAGMENT);\n\n\tif (ml_len < 0)\n\t\treturn;\n\n\telems->ml_basic = (const void *)elems->scratch_pos;\n\telems->ml_basic_len = ml_len;\n\n\tieee80211_mle_get_sta_prof(elems, params->link_id);\n\tprof = elems->prof;\n\n\tif (!prof)\n\t\treturn;\n\n\t \n\tif (elems->sta_prof_len < sizeof(*prof) + prof->sta_info_len - 1 + 4) {\n\t\telems->prof = NULL;\n\t\telems->sta_prof_len = 0;\n\t\treturn;\n\t}\n\n\t \n\tsub.start = prof->variable + prof->sta_info_len - 1 + 4;\n\tend = (const u8 *)prof + elems->sta_prof_len;\n\tsub.len = end - sub.start;\n\n\tnon_inherit = cfg80211_find_ext_elem(WLAN_EID_EXT_NON_INHERITANCE,\n\t\t\t\t\t     sub.start, sub.len);\n\t_ieee802_11_parse_elems_full(&sub, elems, non_inherit);\n}\n\nstruct ieee802_11_elems *\nieee802_11_parse_elems_full(struct ieee80211_elems_parse_params *params)\n{\n\tstruct ieee802_11_elems *elems;\n\tconst struct element *non_inherit = NULL;\n\tu8 *nontransmitted_profile;\n\tint nontransmitted_profile_len = 0;\n\tsize_t scratch_len = 3 * params->len;\n\n\telems = kzalloc(sizeof(*elems) + scratch_len, GFP_ATOMIC);\n\tif (!elems)\n\t\treturn NULL;\n\telems->ie_start = params->start;\n\telems->total_len = params->len;\n\telems->scratch_len = scratch_len;\n\telems->scratch_pos = elems->scratch;\n\n\tnontransmitted_profile = elems->scratch_pos;\n\tnontransmitted_profile_len =\n\t\tieee802_11_find_bssid_profile(params->start, params->len,\n\t\t\t\t\t      elems, params->bss,\n\t\t\t\t\t      nontransmitted_profile);\n\telems->scratch_pos += nontransmitted_profile_len;\n\telems->scratch_len -= nontransmitted_profile_len;\n\tnon_inherit = cfg80211_find_ext_elem(WLAN_EID_EXT_NON_INHERITANCE,\n\t\t\t\t\t     nontransmitted_profile,\n\t\t\t\t\t     nontransmitted_profile_len);\n\n\telems->crc = _ieee802_11_parse_elems_full(params, elems, non_inherit);\n\n\t \n\tif (nontransmitted_profile_len) {\n\t\tstruct ieee80211_elems_parse_params sub = {\n\t\t\t.start = nontransmitted_profile,\n\t\t\t.len = nontransmitted_profile_len,\n\t\t\t.action = params->action,\n\t\t\t.link_id = params->link_id,\n\t\t};\n\n\t\t_ieee802_11_parse_elems_full(&sub, elems, NULL);\n\t}\n\n\tieee80211_mle_parse_link(elems, params);\n\n\tif (elems->tim && !elems->parse_error) {\n\t\tconst struct ieee80211_tim_ie *tim_ie = elems->tim;\n\n\t\telems->dtim_period = tim_ie->dtim_period;\n\t\telems->dtim_count = tim_ie->dtim_count;\n\t}\n\n\t \n\tif (elems->bssid_index &&\n\t    elems->bssid_index_len >=\n\t    offsetofend(struct ieee80211_bssid_index, dtim_period))\n\t\telems->dtim_period = elems->bssid_index->dtim_period;\n\n\tif (elems->bssid_index &&\n\t    elems->bssid_index_len >=\n\t    offsetofend(struct ieee80211_bssid_index, dtim_count))\n\t\telems->dtim_count = elems->bssid_index->dtim_count;\n\n\treturn elems;\n}\n\nvoid ieee80211_regulatory_limit_wmm_params(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct ieee80211_tx_queue_params\n\t\t\t\t\t   *qparam, int ac)\n{\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tconst struct ieee80211_reg_rule *rrule;\n\tconst struct ieee80211_wmm_ac *wmm_ac;\n\tu16 center_freq = 0;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP &&\n\t    sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tif (chanctx_conf)\n\t\tcenter_freq = chanctx_conf->def.chan->center_freq;\n\n\tif (!center_freq) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\trrule = freq_reg_info(sdata->wdev.wiphy, MHZ_TO_KHZ(center_freq));\n\n\tif (IS_ERR_OR_NULL(rrule) || !rrule->has_wmm) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\twmm_ac = &rrule->wmm_rule.ap[ac];\n\telse\n\t\twmm_ac = &rrule->wmm_rule.client[ac];\n\tqparam->cw_min = max_t(u16, qparam->cw_min, wmm_ac->cw_min);\n\tqparam->cw_max = max_t(u16, qparam->cw_max, wmm_ac->cw_max);\n\tqparam->aifs = max_t(u8, qparam->aifs, wmm_ac->aifsn);\n\tqparam->txop = min_t(u16, qparam->txop, wmm_ac->cot / 32);\n\trcu_read_unlock();\n}\n\nvoid ieee80211_set_wmm_default(struct ieee80211_link_data *link,\n\t\t\t       bool bss_notify, bool enable_qos)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_queue_params qparam;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tint ac;\n\tbool use_11b;\n\tbool is_ocb;  \n\tint aCWmin, aCWmax;\n\n\tif (!local->ops->conf_tx)\n\t\treturn;\n\n\tif (local->hw.queues < IEEE80211_NUM_ACS)\n\t\treturn;\n\n\tmemset(&qparam, 0, sizeof(qparam));\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(link->conf->chanctx_conf);\n\tuse_11b = (chanctx_conf &&\n\t\t   chanctx_conf->def.chan->band == NL80211_BAND_2GHZ) &&\n\t\t !link->operating_11g_mode;\n\trcu_read_unlock();\n\n\tis_ocb = (sdata->vif.type == NL80211_IFTYPE_OCB);\n\n\t \n\taCWmax = 1023;\n\tif (use_11b)\n\t\taCWmin = 31;\n\telse\n\t\taCWmin = 15;\n\n\t \n\tqparam.cw_max = aCWmax;\n\tqparam.cw_min = aCWmin;\n\tqparam.txop = 0;\n\tqparam.aifs = 2;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\t \n\t\tif (enable_qos) {\n\t\t\tswitch (ac) {\n\t\t\tcase IEEE80211_AC_BK:\n\t\t\t\tqparam.cw_max = aCWmax;\n\t\t\t\tqparam.cw_min = aCWmin;\n\t\t\t\tqparam.txop = 0;\n\t\t\t\tif (is_ocb)\n\t\t\t\t\tqparam.aifs = 9;\n\t\t\t\telse\n\t\t\t\t\tqparam.aifs = 7;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tdefault:\n\t\t\tcase IEEE80211_AC_BE:\n\t\t\t\tqparam.cw_max = aCWmax;\n\t\t\t\tqparam.cw_min = aCWmin;\n\t\t\t\tqparam.txop = 0;\n\t\t\t\tif (is_ocb)\n\t\t\t\t\tqparam.aifs = 6;\n\t\t\t\telse\n\t\t\t\t\tqparam.aifs = 3;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_AC_VI:\n\t\t\t\tqparam.cw_max = aCWmin;\n\t\t\t\tqparam.cw_min = (aCWmin + 1) / 2 - 1;\n\t\t\t\tif (is_ocb)\n\t\t\t\t\tqparam.txop = 0;\n\t\t\t\telse if (use_11b)\n\t\t\t\t\tqparam.txop = 6016/32;\n\t\t\t\telse\n\t\t\t\t\tqparam.txop = 3008/32;\n\n\t\t\t\tif (is_ocb)\n\t\t\t\t\tqparam.aifs = 3;\n\t\t\t\telse\n\t\t\t\t\tqparam.aifs = 2;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_AC_VO:\n\t\t\t\tqparam.cw_max = (aCWmin + 1) / 2 - 1;\n\t\t\t\tqparam.cw_min = (aCWmin + 1) / 4 - 1;\n\t\t\t\tif (is_ocb)\n\t\t\t\t\tqparam.txop = 0;\n\t\t\t\telse if (use_11b)\n\t\t\t\t\tqparam.txop = 3264/32;\n\t\t\t\telse\n\t\t\t\t\tqparam.txop = 1504/32;\n\t\t\t\tqparam.aifs = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tieee80211_regulatory_limit_wmm_params(sdata, &qparam, ac);\n\n\t\tqparam.uapsd = false;\n\n\t\tlink->tx_conf[ac] = qparam;\n\t\tdrv_conf_tx(local, link, ac, &qparam);\n\t}\n\n\tif (sdata->vif.type != NL80211_IFTYPE_MONITOR &&\n\t    sdata->vif.type != NL80211_IFTYPE_P2P_DEVICE &&\n\t    sdata->vif.type != NL80211_IFTYPE_NAN) {\n\t\tlink->conf->qos = enable_qos;\n\t\tif (bss_notify)\n\t\t\tieee80211_link_info_change_notify(sdata, link,\n\t\t\t\t\t\t\t  BSS_CHANGED_QOS);\n\t}\n}\n\nvoid ieee80211_send_auth(struct ieee80211_sub_if_data *sdata,\n\t\t\t u16 transaction, u16 auth_alg, u16 status,\n\t\t\t const u8 *extra, size_t extra_len, const u8 *da,\n\t\t\t const u8 *bssid, const u8 *key, u8 key_len, u8 key_idx,\n\t\t\t u32 tx_flags)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *mgmt;\n\tbool multi_link = ieee80211_vif_is_mld(&sdata->vif);\n\tstruct {\n\t\tu8 id;\n\t\tu8 len;\n\t\tu8 ext_id;\n\t\tstruct ieee80211_multi_link_elem ml;\n\t\tstruct ieee80211_mle_basic_common_info basic;\n\t} __packed mle = {\n\t\t.id = WLAN_EID_EXTENSION,\n\t\t.len = sizeof(mle) - 2,\n\t\t.ext_id = WLAN_EID_EXT_EHT_MULTI_LINK,\n\t\t.ml.control = cpu_to_le16(IEEE80211_ML_CONTROL_TYPE_BASIC),\n\t\t.basic.len = sizeof(mle.basic),\n\t};\n\tint err;\n\n\tmemcpy(mle.basic.mld_mac_addr, sdata->vif.addr, ETH_ALEN);\n\n\t \n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + IEEE80211_WEP_IV_LEN +\n\t\t\t    24 + 6 + extra_len + IEEE80211_WEP_ICV_LEN +\n\t\t\t    multi_link * sizeof(mle));\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom + IEEE80211_WEP_IV_LEN);\n\n\tmgmt = skb_put_zero(skb, 24 + 6);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_AUTH);\n\tmemcpy(mgmt->da, da, ETH_ALEN);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, bssid, ETH_ALEN);\n\tmgmt->u.auth.auth_alg = cpu_to_le16(auth_alg);\n\tmgmt->u.auth.auth_transaction = cpu_to_le16(transaction);\n\tmgmt->u.auth.status_code = cpu_to_le16(status);\n\tif (extra)\n\t\tskb_put_data(skb, extra, extra_len);\n\tif (multi_link)\n\t\tskb_put_data(skb, &mle, sizeof(mle));\n\n\tif (auth_alg == WLAN_AUTH_SHARED_KEY && transaction == 3) {\n\t\tmgmt->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t\terr = ieee80211_wep_encrypt(local, skb, key, key_len, key_idx);\n\t\tif (WARN_ON(err)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t\t\t\ttx_flags;\n\tieee80211_tx_skb(sdata, skb);\n}\n\nvoid ieee80211_send_deauth_disassoc(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    const u8 *da, const u8 *bssid,\n\t\t\t\t    u16 stype, u16 reason,\n\t\t\t\t    bool send_frame, u8 *frame_buf)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *mgmt = (void *)frame_buf;\n\n\t \n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | stype);\n\tmgmt->duration = 0;  \n\tmgmt->seq_ctrl = 0;  \n\tmemcpy(mgmt->da, da, ETH_ALEN);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, bssid, ETH_ALEN);\n\t \n\tmgmt->u.deauth.reason_code = cpu_to_le16(reason);\n\n\tif (send_frame) {\n\t\tskb = dev_alloc_skb(local->hw.extra_tx_headroom +\n\t\t\t\t    IEEE80211_DEAUTH_FRAME_LEN);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\t\t \n\t\tskb_put_data(skb, mgmt, IEEE80211_DEAUTH_FRAME_LEN);\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION ||\n\t\t    !(sdata->u.mgd.flags & IEEE80211_STA_MFP_ENABLED))\n\t\t\tIEEE80211_SKB_CB(skb)->flags |=\n\t\t\t\tIEEE80211_TX_INTFL_DONT_ENCRYPT;\n\n\t\tieee80211_tx_skb(sdata, skb);\n\t}\n}\n\nu8 *ieee80211_write_he_6ghz_cap(u8 *pos, __le16 cap, u8 *end)\n{\n\tif ((end - pos) < 5)\n\t\treturn pos;\n\n\t*pos++ = WLAN_EID_EXTENSION;\n\t*pos++ = 1 + sizeof(cap);\n\t*pos++ = WLAN_EID_EXT_HE_6GHZ_CAPA;\n\tmemcpy(pos, &cap, sizeof(cap));\n\n\treturn pos + 2;\n}\n\nstatic int ieee80211_build_preq_ies_band(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t u8 *buffer, size_t buffer_len,\n\t\t\t\t\t const u8 *ie, size_t ie_len,\n\t\t\t\t\t enum nl80211_band band,\n\t\t\t\t\t u32 rate_mask,\n\t\t\t\t\t struct cfg80211_chan_def *chandef,\n\t\t\t\t\t size_t *offset, u32 flags)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_supported_band *sband;\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tconst struct ieee80211_sta_eht_cap *eht_cap;\n\tu8 *pos = buffer, *end = buffer + buffer_len;\n\tsize_t noffset;\n\tint supp_rates_len, i;\n\tu8 rates[32];\n\tint num_rates;\n\tint ext_rates_len;\n\tint shift;\n\tu32 rate_flags;\n\tbool have_80mhz = false;\n\n\t*offset = 0;\n\n\tsband = local->hw.wiphy->bands[band];\n\tif (WARN_ON_ONCE(!sband))\n\t\treturn 0;\n\n\trate_flags = ieee80211_chandef_rate_flags(chandef);\n\tshift = ieee80211_chandef_get_shift(chandef);\n\n\t \n\tif (band == NL80211_BAND_S1GHZ) {\n\t\tif (end - pos < 2 + sizeof(struct ieee80211_s1g_cap))\n\t\t\tgoto out_err;\n\t\tpos = ieee80211_ie_build_s1g_cap(pos, &sband->s1g_cap);\n\t\tgoto done;\n\t}\n\n\tnum_rates = 0;\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tif ((BIT(i) & rate_mask) == 0)\n\t\t\tcontinue;  \n\t\tif ((rate_flags & sband->bitrates[i].flags) != rate_flags)\n\t\t\tcontinue;\n\n\t\trates[num_rates++] =\n\t\t\t(u8) DIV_ROUND_UP(sband->bitrates[i].bitrate,\n\t\t\t\t\t  (1 << shift) * 5);\n\t}\n\n\tsupp_rates_len = min_t(int, num_rates, 8);\n\n\tif (end - pos < 2 + supp_rates_len)\n\t\tgoto out_err;\n\t*pos++ = WLAN_EID_SUPP_RATES;\n\t*pos++ = supp_rates_len;\n\tmemcpy(pos, rates, supp_rates_len);\n\tpos += supp_rates_len;\n\n\t \n\tif (ie && ie_len) {\n\t\tstatic const u8 before_extrates[] = {\n\t\t\tWLAN_EID_SSID,\n\t\t\tWLAN_EID_SUPP_RATES,\n\t\t\tWLAN_EID_REQUEST,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(ie, ie_len,\n\t\t\t\t\t     before_extrates,\n\t\t\t\t\t     ARRAY_SIZE(before_extrates),\n\t\t\t\t\t     *offset);\n\t\tif (end - pos < noffset - *offset)\n\t\t\tgoto out_err;\n\t\tmemcpy(pos, ie + *offset, noffset - *offset);\n\t\tpos += noffset - *offset;\n\t\t*offset = noffset;\n\t}\n\n\text_rates_len = num_rates - supp_rates_len;\n\tif (ext_rates_len > 0) {\n\t\tif (end - pos < 2 + ext_rates_len)\n\t\t\tgoto out_err;\n\t\t*pos++ = WLAN_EID_EXT_SUPP_RATES;\n\t\t*pos++ = ext_rates_len;\n\t\tmemcpy(pos, rates + supp_rates_len, ext_rates_len);\n\t\tpos += ext_rates_len;\n\t}\n\n\tif (chandef->chan && sband->band == NL80211_BAND_2GHZ) {\n\t\tif (end - pos < 3)\n\t\t\tgoto out_err;\n\t\t*pos++ = WLAN_EID_DS_PARAMS;\n\t\t*pos++ = 1;\n\t\t*pos++ = ieee80211_frequency_to_channel(\n\t\t\t\tchandef->chan->center_freq);\n\t}\n\n\tif (flags & IEEE80211_PROBE_FLAG_MIN_CONTENT)\n\t\tgoto done;\n\n\t \n\tif (ie && ie_len) {\n\t\tstatic const u8 before_ht[] = {\n\t\t\t \n\t\t\tWLAN_EID_DS_PARAMS,\n\t\t\tWLAN_EID_SUPPORTED_REGULATORY_CLASSES,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(ie, ie_len,\n\t\t\t\t\t     before_ht, ARRAY_SIZE(before_ht),\n\t\t\t\t\t     *offset);\n\t\tif (end - pos < noffset - *offset)\n\t\t\tgoto out_err;\n\t\tmemcpy(pos, ie + *offset, noffset - *offset);\n\t\tpos += noffset - *offset;\n\t\t*offset = noffset;\n\t}\n\n\tif (sband->ht_cap.ht_supported) {\n\t\tif (end - pos < 2 + sizeof(struct ieee80211_ht_cap))\n\t\t\tgoto out_err;\n\t\tpos = ieee80211_ie_build_ht_cap(pos, &sband->ht_cap,\n\t\t\t\t\t\tsband->ht_cap.cap);\n\t}\n\n\t \n\tif (ie && ie_len) {\n\t\tstatic const u8 before_vht[] = {\n\t\t\t \n\t\t\tWLAN_EID_BSS_COEX_2040,\n\t\t\tWLAN_EID_EXT_CAPABILITY,\n\t\t\tWLAN_EID_SSID_LIST,\n\t\t\tWLAN_EID_CHANNEL_USAGE,\n\t\t\tWLAN_EID_INTERWORKING,\n\t\t\tWLAN_EID_MESH_ID,\n\t\t\t \n\t\t};\n\t\tnoffset = ieee80211_ie_split(ie, ie_len,\n\t\t\t\t\t     before_vht, ARRAY_SIZE(before_vht),\n\t\t\t\t\t     *offset);\n\t\tif (end - pos < noffset - *offset)\n\t\t\tgoto out_err;\n\t\tmemcpy(pos, ie + *offset, noffset - *offset);\n\t\tpos += noffset - *offset;\n\t\t*offset = noffset;\n\t}\n\n\t \n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tif (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |\n\t\t\t\t\t\tIEEE80211_CHAN_NO_80MHZ))\n\t\t\tcontinue;\n\n\t\thave_80mhz = true;\n\t\tbreak;\n\t}\n\n\tif (sband->vht_cap.vht_supported && have_80mhz) {\n\t\tif (end - pos < 2 + sizeof(struct ieee80211_vht_cap))\n\t\t\tgoto out_err;\n\t\tpos = ieee80211_ie_build_vht_cap(pos, &sband->vht_cap,\n\t\t\t\t\t\t sband->vht_cap.cap);\n\t}\n\n\t \n\tif (ie && ie_len) {\n\t\tstatic const u8 before_he[] = {\n\t\t\t \n\t\t\tWLAN_EID_EXTENSION, WLAN_EID_EXT_FILS_REQ_PARAMS,\n\t\t\tWLAN_EID_AP_CSN,\n\t\t\t \n\t\t};\n\t\tnoffset = ieee80211_ie_split(ie, ie_len,\n\t\t\t\t\t     before_he, ARRAY_SIZE(before_he),\n\t\t\t\t\t     *offset);\n\t\tif (end - pos < noffset - *offset)\n\t\t\tgoto out_err;\n\t\tmemcpy(pos, ie + *offset, noffset - *offset);\n\t\tpos += noffset - *offset;\n\t\t*offset = noffset;\n\t}\n\n\the_cap = ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);\n\tif (he_cap &&\n\t    cfg80211_any_usable_channels(local->hw.wiphy, BIT(sband->band),\n\t\t\t\t\t IEEE80211_CHAN_NO_HE)) {\n\t\tpos = ieee80211_ie_build_he_cap(0, pos, he_cap, end);\n\t\tif (!pos)\n\t\t\tgoto out_err;\n\t}\n\n\teht_cap = ieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif);\n\n\tif (eht_cap &&\n\t    cfg80211_any_usable_channels(local->hw.wiphy, BIT(sband->band),\n\t\t\t\t\t IEEE80211_CHAN_NO_HE |\n\t\t\t\t\t IEEE80211_CHAN_NO_EHT)) {\n\t\tpos = ieee80211_ie_build_eht_cap(pos, he_cap, eht_cap, end,\n\t\t\t\t\t\t sdata->vif.type == NL80211_IFTYPE_AP);\n\t\tif (!pos)\n\t\t\tgoto out_err;\n\t}\n\n\tif (cfg80211_any_usable_channels(local->hw.wiphy,\n\t\t\t\t\t BIT(NL80211_BAND_6GHZ),\n\t\t\t\t\t IEEE80211_CHAN_NO_HE)) {\n\t\tstruct ieee80211_supported_band *sband6;\n\n\t\tsband6 = local->hw.wiphy->bands[NL80211_BAND_6GHZ];\n\t\the_cap = ieee80211_get_he_iftype_cap_vif(sband6, &sdata->vif);\n\n\t\tif (he_cap) {\n\t\t\tenum nl80211_iftype iftype =\n\t\t\t\tieee80211_vif_type_p2p(&sdata->vif);\n\t\t\t__le16 cap = ieee80211_get_he_6ghz_capa(sband6, iftype);\n\n\t\t\tpos = ieee80211_write_he_6ghz_cap(pos, cap, end);\n\t\t}\n\t}\n\n\t \n\n\treturn pos - buffer;\n out_err:\n\tWARN_ONCE(1, \"not enough space for preq IEs\\n\");\n done:\n\treturn pos - buffer;\n}\n\nint ieee80211_build_preq_ies(struct ieee80211_sub_if_data *sdata, u8 *buffer,\n\t\t\t     size_t buffer_len,\n\t\t\t     struct ieee80211_scan_ies *ie_desc,\n\t\t\t     const u8 *ie, size_t ie_len,\n\t\t\t     u8 bands_used, u32 *rate_masks,\n\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t     u32 flags)\n{\n\tsize_t pos = 0, old_pos = 0, custom_ie_offset = 0;\n\tint i;\n\n\tmemset(ie_desc, 0, sizeof(*ie_desc));\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tif (bands_used & BIT(i)) {\n\t\t\tpos += ieee80211_build_preq_ies_band(sdata,\n\t\t\t\t\t\t\t     buffer + pos,\n\t\t\t\t\t\t\t     buffer_len - pos,\n\t\t\t\t\t\t\t     ie, ie_len, i,\n\t\t\t\t\t\t\t     rate_masks[i],\n\t\t\t\t\t\t\t     chandef,\n\t\t\t\t\t\t\t     &custom_ie_offset,\n\t\t\t\t\t\t\t     flags);\n\t\t\tie_desc->ies[i] = buffer + old_pos;\n\t\t\tie_desc->len[i] = pos - old_pos;\n\t\t\told_pos = pos;\n\t\t}\n\t}\n\n\t \n\tif (ie && ie_len) {\n\t\tif (WARN_ONCE(buffer_len - pos < ie_len - custom_ie_offset,\n\t\t\t      \"not enough space for preq custom IEs\\n\"))\n\t\t\treturn pos;\n\t\tmemcpy(buffer + pos, ie + custom_ie_offset,\n\t\t       ie_len - custom_ie_offset);\n\t\tie_desc->common_ies = buffer + pos;\n\t\tie_desc->common_ie_len = ie_len - custom_ie_offset;\n\t\tpos += ie_len - custom_ie_offset;\n\t}\n\n\treturn pos;\n};\n\nstruct sk_buff *ieee80211_build_probe_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  const u8 *src, const u8 *dst,\n\t\t\t\t\t  u32 ratemask,\n\t\t\t\t\t  struct ieee80211_channel *chan,\n\t\t\t\t\t  const u8 *ssid, size_t ssid_len,\n\t\t\t\t\t  const u8 *ie, size_t ie_len,\n\t\t\t\t\t  u32 flags)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct cfg80211_chan_def chandef;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *mgmt;\n\tint ies_len;\n\tu32 rate_masks[NUM_NL80211_BANDS] = {};\n\tstruct ieee80211_scan_ies dummy_ie_desc;\n\n\t \n\tchandef.width = sdata->vif.bss_conf.chandef.width;\n\tif (flags & IEEE80211_PROBE_FLAG_DIRECTED)\n\t\tchandef.chan = NULL;\n\telse\n\t\tchandef.chan = chan;\n\n\tskb = ieee80211_probereq_get(&local->hw, src, ssid, ssid_len,\n\t\t\t\t     local->scan_ies_len + ie_len);\n\tif (!skb)\n\t\treturn NULL;\n\n\trate_masks[chan->band] = ratemask;\n\ties_len = ieee80211_build_preq_ies(sdata, skb_tail_pointer(skb),\n\t\t\t\t\t   skb_tailroom(skb), &dummy_ie_desc,\n\t\t\t\t\t   ie, ie_len, BIT(chan->band),\n\t\t\t\t\t   rate_masks, &chandef, flags);\n\tskb_put(skb, ies_len);\n\n\tif (dst) {\n\t\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\t\tmemcpy(mgmt->da, dst, ETH_ALEN);\n\t\tmemcpy(mgmt->bssid, dst, ETH_ALEN);\n\t}\n\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\n\treturn skb;\n}\n\nu32 ieee80211_sta_get_rates(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct ieee802_11_elems *elems,\n\t\t\t    enum nl80211_band band, u32 *basic_rates)\n{\n\tstruct ieee80211_supported_band *sband;\n\tsize_t num_rates;\n\tu32 supp_rates, rate_flags;\n\tint i, j, shift;\n\n\tsband = sdata->local->hw.wiphy->bands[band];\n\tif (WARN_ON(!sband))\n\t\treturn 1;\n\n\trate_flags = ieee80211_chandef_rate_flags(&sdata->vif.bss_conf.chandef);\n\tshift = ieee80211_vif_get_shift(&sdata->vif);\n\n\tnum_rates = sband->n_bitrates;\n\tsupp_rates = 0;\n\tfor (i = 0; i < elems->supp_rates_len +\n\t\t     elems->ext_supp_rates_len; i++) {\n\t\tu8 rate = 0;\n\t\tint own_rate;\n\t\tbool is_basic;\n\t\tif (i < elems->supp_rates_len)\n\t\t\trate = elems->supp_rates[i];\n\t\telse if (elems->ext_supp_rates)\n\t\t\trate = elems->ext_supp_rates\n\t\t\t\t[i - elems->supp_rates_len];\n\t\town_rate = 5 * (rate & 0x7f);\n\t\tis_basic = !!(rate & 0x80);\n\n\t\tif (is_basic && (rate & 0x7f) == BSS_MEMBERSHIP_SELECTOR_HT_PHY)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < num_rates; j++) {\n\t\t\tint brate;\n\t\t\tif ((rate_flags & sband->bitrates[j].flags)\n\t\t\t    != rate_flags)\n\t\t\t\tcontinue;\n\n\t\t\tbrate = DIV_ROUND_UP(sband->bitrates[j].bitrate,\n\t\t\t\t\t     1 << shift);\n\n\t\t\tif (brate == own_rate) {\n\t\t\t\tsupp_rates |= BIT(j);\n\t\t\t\tif (basic_rates && is_basic)\n\t\t\t\t\t*basic_rates |= BIT(j);\n\t\t\t}\n\t\t}\n\t}\n\treturn supp_rates;\n}\n\nvoid ieee80211_stop_device(struct ieee80211_local *local)\n{\n\tieee80211_led_radio(local, false);\n\tieee80211_mod_tpt_led_trig(local, 0, IEEE80211_TPT_LEDTRIG_FL_RADIO);\n\n\tcancel_work_sync(&local->reconfig_filter);\n\n\tflush_workqueue(local->workqueue);\n\tdrv_stop(local);\n}\n\nstatic void ieee80211_flush_completed_scan(struct ieee80211_local *local,\n\t\t\t\t\t   bool aborted)\n{\n\t \n\tif (test_bit(SCAN_COMPLETED, &local->scanning)) {\n\t\t \n\t\tif (aborted)\n\t\t\tset_bit(SCAN_ABORTED, &local->scanning);\n\t\twiphy_delayed_work_queue(local->hw.wiphy, &local->scan_work, 0);\n\t\twiphy_delayed_work_flush(local->hw.wiphy, &local->scan_work);\n\t}\n}\n\nstatic void ieee80211_handle_reconfig_failure(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_chanctx *ctx;\n\n\t \n\n\tlocal->resuming = false;\n\tlocal->suspended = false;\n\tlocal->in_reconfig = false;\n\tlocal->reconfig_failure = true;\n\n\tieee80211_flush_completed_scan(local, true);\n\n\t \n\tieee80211_sched_scan_end(local);\n\n\tlist_for_each_entry(sdata, &local->interfaces, list)\n\t\tsdata->flags &= ~IEEE80211_SDATA_IN_DRIVER;\n\n\t \n\tmutex_lock(&local->chanctx_mtx);\n\tlist_for_each_entry(ctx, &local->chanctx_list, list)\n\t\tctx->driver_present = false;\n\tmutex_unlock(&local->chanctx_mtx);\n}\n\nstatic void ieee80211_assign_chanctx(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_chanctx_conf *conf;\n\tstruct ieee80211_chanctx *ctx;\n\n\tif (!local->use_chanctx)\n\t\treturn;\n\n\tmutex_lock(&local->chanctx_mtx);\n\tconf = rcu_dereference_protected(link->conf->chanctx_conf,\n\t\t\t\t\t lockdep_is_held(&local->chanctx_mtx));\n\tif (conf) {\n\t\tctx = container_of(conf, struct ieee80211_chanctx, conf);\n\t\tdrv_assign_vif_chanctx(local, sdata, link->conf, ctx);\n\t}\n\tmutex_unlock(&local->chanctx_mtx);\n}\n\nstatic void ieee80211_reconfig_stations(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\t \n\tmutex_lock(&local->sta_mtx);\n\tlist_for_each_entry(sta, &local->sta_list, list) {\n\t\tenum ieee80211_sta_state state;\n\n\t\tif (!sta->uploaded || sta->sdata != sdata)\n\t\t\tcontinue;\n\n\t\tfor (state = IEEE80211_STA_NOTEXIST;\n\t\t     state < sta->sta_state; state++)\n\t\t\tWARN_ON(drv_sta_state(local, sta->sdata, sta, state,\n\t\t\t\t\t      state + 1));\n\t}\n\tmutex_unlock(&local->sta_mtx);\n}\n\nstatic int ieee80211_reconfig_nan(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct cfg80211_nan_func *func, **funcs;\n\tint res, id, i = 0;\n\n\tres = drv_start_nan(sdata->local, sdata,\n\t\t\t    &sdata->u.nan.conf);\n\tif (WARN_ON(res))\n\t\treturn res;\n\n\tfuncs = kcalloc(sdata->local->hw.max_nan_de_entries + 1,\n\t\t\tsizeof(*funcs),\n\t\t\tGFP_KERNEL);\n\tif (!funcs)\n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock_bh(&sdata->u.nan.func_lock);\n\n\tidr_for_each_entry(&sdata->u.nan.function_inst_ids, func, id)\n\t\tfuncs[i++] = func;\n\n\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\n\tfor (i = 0; funcs[i]; i++) {\n\t\tres = drv_add_nan_func(sdata->local, sdata, funcs[i]);\n\t\tif (WARN_ON(res))\n\t\t\tieee80211_nan_func_terminated(&sdata->vif,\n\t\t\t\t\t\t      funcs[i]->instance_id,\n\t\t\t\t\t\t      NL80211_NAN_FUNC_TERM_REASON_ERROR,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t}\n\n\tkfree(funcs);\n\n\treturn 0;\n}\n\nstatic void ieee80211_reconfig_ap_links(struct ieee80211_local *local,\n\t\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tu64 changed)\n{\n\tint link_id;\n\n\tfor (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {\n\t\tstruct ieee80211_link_data *link;\n\n\t\tif (!(sdata->vif.active_links & BIT(link_id)))\n\t\t\tcontinue;\n\n\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\tif (rcu_access_pointer(link->u.ap.beacon))\n\t\t\tdrv_start_ap(local, sdata, link->conf);\n\n\t\tif (!link->conf->enable_beacon)\n\t\t\tcontinue;\n\n\t\tchanged |= BSS_CHANGED_BEACON |\n\t\t\t   BSS_CHANGED_BEACON_ENABLED;\n\n\t\tieee80211_link_info_change_notify(sdata, link, changed);\n\t}\n}\n\nint ieee80211_reconfig(struct ieee80211_local *local)\n{\n\tstruct ieee80211_hw *hw = &local->hw;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_chanctx *ctx;\n\tstruct sta_info *sta;\n\tint res, i;\n\tbool reconfig_due_to_wowlan = false;\n\tstruct ieee80211_sub_if_data *sched_scan_sdata;\n\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\tbool sched_scan_stopped = false;\n\tbool suspended = local->suspended;\n\tbool in_reconfig = false;\n\n\t \n\tif (!local->open_count)\n\t\tgoto wake_up;\n\n#ifdef CONFIG_PM\n\tif (suspended)\n\t\tlocal->resuming = true;\n\n\tif (local->wowlan) {\n\t\t \n\t\tlocal->suspended = false;\n\t\tres = drv_resume(local);\n\t\tlocal->wowlan = false;\n\t\tif (res < 0) {\n\t\t\tlocal->resuming = false;\n\t\t\treturn res;\n\t\t}\n\t\tif (res == 0)\n\t\t\tgoto wake_up;\n\t\tWARN_ON(res > 1);\n\t\t \n\t\treconfig_due_to_wowlan = true;\n\t\tlocal->suspended = true;\n\t}\n#endif\n\n\t \n\tif (suspended && local->in_reconfig && !reconfig_due_to_wowlan)\n\t\tcancel_work_sync(&local->restart_work);\n\n\tlocal->started = false;\n\n\t \n\tres = drv_start(local);\n\tif (res) {\n\t\tif (suspended)\n\t\t\tWARN(1, \"Hardware became unavailable upon resume. This could be a software issue prior to suspend or a hardware issue.\\n\");\n\t\telse\n\t\t\tWARN(1, \"Hardware became unavailable during restart.\\n\");\n\t\tieee80211_handle_reconfig_failure(local);\n\t\treturn res;\n\t}\n\n\t \n\tdrv_set_frag_threshold(local, hw->wiphy->frag_threshold);\n\n\t \n\tdrv_set_rts_threshold(local, hw->wiphy->rts_threshold);\n\n\t \n\tdrv_set_coverage_class(local, hw->wiphy->coverage_class);\n\n\tieee80211_led_radio(local, true);\n\tieee80211_mod_tpt_led_trig(local,\n\t\t\t\t   IEEE80211_TPT_LEDTRIG_FL_RADIO, 0);\n\n\t \n\tsdata = wiphy_dereference(local->hw.wiphy, local->monitor_sdata);\n\tif (sdata) {\n\t\t \n\t\tWARN_ON(local->resuming);\n\t\tres = drv_add_interface(local, sdata);\n\t\tif (WARN_ON(res)) {\n\t\t\tRCU_INIT_POINTER(local->monitor_sdata, NULL);\n\t\t\tsynchronize_net();\n\t\t\tkfree(sdata);\n\t\t}\n\t}\n\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_MONITOR &&\n\t\t    ieee80211_sdata_running(sdata)) {\n\t\t\tres = drv_add_interface(local, sdata);\n\t\t\tif (WARN_ON(res))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (res) {\n\t\tlist_for_each_entry_continue_reverse(sdata, &local->interfaces,\n\t\t\t\t\t\t     list)\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t\t\t    sdata->vif.type != NL80211_IFTYPE_MONITOR &&\n\t\t\t    ieee80211_sdata_running(sdata))\n\t\t\t\tdrv_remove_interface(local, sdata);\n\t\tieee80211_handle_reconfig_failure(local);\n\t\treturn res;\n\t}\n\n\t \n\tif (local->use_chanctx) {\n\t\tmutex_lock(&local->chanctx_mtx);\n\t\tlist_for_each_entry(ctx, &local->chanctx_list, list)\n\t\t\tif (ctx->replace_state !=\n\t\t\t    IEEE80211_CHANCTX_REPLACES_OTHER)\n\t\t\t\tWARN_ON(drv_add_chanctx(local, ctx));\n\t\tmutex_unlock(&local->chanctx_mtx);\n\n\t\tsdata = wiphy_dereference(local->hw.wiphy,\n\t\t\t\t\t  local->monitor_sdata);\n\t\tif (sdata && ieee80211_sdata_running(sdata))\n\t\t\tieee80211_assign_chanctx(local, sdata, &sdata->deflink);\n\t}\n\n\t \n\tieee80211_hw_config(local, ~0);\n\n\tieee80211_configure_filter(local);\n\n\t \n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t \n\t\tu64 changed = BSS_CHANGED_ERP_CTS_PROT |\n\t\t\t      BSS_CHANGED_ERP_PREAMBLE |\n\t\t\t      BSS_CHANGED_ERP_SLOT |\n\t\t\t      BSS_CHANGED_HT |\n\t\t\t      BSS_CHANGED_BASIC_RATES |\n\t\t\t      BSS_CHANGED_BEACON_INT |\n\t\t\t      BSS_CHANGED_BSSID |\n\t\t\t      BSS_CHANGED_CQM |\n\t\t\t      BSS_CHANGED_QOS |\n\t\t\t      BSS_CHANGED_TXPOWER |\n\t\t\t      BSS_CHANGED_MCAST_RATE;\n\t\tstruct ieee80211_link_data *link = NULL;\n\t\tunsigned int link_id;\n\t\tu32 active_links = 0;\n\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tsdata_lock(sdata);\n\t\tif (ieee80211_vif_is_mld(&sdata->vif)) {\n\t\t\tstruct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS] = {\n\t\t\t\t[0] = &sdata->vif.bss_conf,\n\t\t\t};\n\n\t\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION) {\n\t\t\t\t \n\t\t\t\tactive_links = sdata->vif.active_links;\n\t\t\t\tlink_id = ffs(active_links) - 1;\n\t\t\t\tsdata->vif.active_links = BIT(link_id);\n\t\t\t}\n\n\t\t\tdrv_change_vif_links(local, sdata, 0,\n\t\t\t\t\t     sdata->vif.active_links,\n\t\t\t\t\t     old);\n\t\t}\n\n\t\tfor (link_id = 0;\n\t\t     link_id < ARRAY_SIZE(sdata->vif.link_conf);\n\t\t     link_id++) {\n\t\t\tif (ieee80211_vif_is_mld(&sdata->vif) &&\n\t\t\t    !(sdata->vif.active_links & BIT(link_id)))\n\t\t\t\tcontinue;\n\n\t\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\t\t\tif (!link)\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_assign_chanctx(local, sdata, link);\n\t\t}\n\n\t\tswitch (sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tcase NL80211_IFTYPE_MONITOR:\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tif (sdata->vif.cfg.ibss_joined)\n\t\t\t\tWARN_ON(drv_join_ibss(local, sdata));\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tieee80211_reconfig_stations(sdata);\n\t\t\tfallthrough;\n\t\tcase NL80211_IFTYPE_AP:  \n\t\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++)\n\t\t\t\tdrv_conf_tx(local, &sdata->deflink, i,\n\t\t\t\t\t    &sdata->deflink.tx_conf[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdata->vif.bss_conf.mu_mimo_owner)\n\t\t\tchanged |= BSS_CHANGED_MU_GROUPS;\n\n\t\tif (!ieee80211_vif_is_mld(&sdata->vif))\n\t\t\tchanged |= BSS_CHANGED_IDLE;\n\n\t\tswitch (sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tif (!ieee80211_vif_is_mld(&sdata->vif)) {\n\t\t\t\tchanged |= BSS_CHANGED_ASSOC |\n\t\t\t\t\t   BSS_CHANGED_ARP_FILTER |\n\t\t\t\t\t   BSS_CHANGED_PS;\n\n\t\t\t\t \n\t\t\t\tif (sdata->deflink.u.mgd.have_beacon)\n\t\t\t\t\tchanged |= BSS_CHANGED_BEACON_INFO;\n\n\t\t\t\tif (sdata->vif.bss_conf.max_idle_period ||\n\t\t\t\t    sdata->vif.bss_conf.protected_keep_alive)\n\t\t\t\t\tchanged |= BSS_CHANGED_KEEP_ALIVE;\n\n\t\t\t\tif (sdata->vif.bss_conf.eht_puncturing)\n\t\t\t\t\tchanged |= BSS_CHANGED_EHT_PUNCTURING;\n\n\t\t\t\tieee80211_bss_info_change_notify(sdata,\n\t\t\t\t\t\t\t\t changed);\n\t\t\t} else if (!WARN_ON(!link)) {\n\t\t\t\tieee80211_link_info_change_notify(sdata, link,\n\t\t\t\t\t\t\t\t  changed);\n\t\t\t\tchanged = BSS_CHANGED_ASSOC |\n\t\t\t\t\t  BSS_CHANGED_IDLE |\n\t\t\t\t\t  BSS_CHANGED_PS |\n\t\t\t\t\t  BSS_CHANGED_ARP_FILTER;\n\t\t\t\tieee80211_vif_cfg_change_notify(sdata, changed);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_OCB:\n\t\t\tchanged |= BSS_CHANGED_OCB;\n\t\t\tieee80211_bss_info_change_notify(sdata, changed);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tchanged |= BSS_CHANGED_IBSS;\n\t\t\tfallthrough;\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\tchanged |= BSS_CHANGED_P2P_PS;\n\n\t\t\tif (ieee80211_vif_is_mld(&sdata->vif))\n\t\t\t\tieee80211_vif_cfg_change_notify(sdata,\n\t\t\t\t\t\t\t\tBSS_CHANGED_SSID);\n\t\t\telse\n\t\t\t\tchanged |= BSS_CHANGED_SSID;\n\n\t\t\tif (sdata->vif.bss_conf.ftm_responder == 1 &&\n\t\t\t    wiphy_ext_feature_isset(sdata->local->hw.wiphy,\n\t\t\t\t\tNL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER))\n\t\t\t\tchanged |= BSS_CHANGED_FTM_RESPONDER;\n\n\t\t\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\t\t\tchanged |= BSS_CHANGED_AP_PROBE_RESP;\n\n\t\t\t\tif (ieee80211_vif_is_mld(&sdata->vif)) {\n\t\t\t\t\tieee80211_reconfig_ap_links(local,\n\t\t\t\t\t\t\t\t    sdata,\n\t\t\t\t\t\t\t\t    changed);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (rcu_access_pointer(sdata->deflink.u.ap.beacon))\n\t\t\t\t\tdrv_start_ap(local, sdata,\n\t\t\t\t\t\t     sdata->deflink.conf);\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tif (sdata->vif.bss_conf.enable_beacon) {\n\t\t\t\tchanged |= BSS_CHANGED_BEACON |\n\t\t\t\t\t   BSS_CHANGED_BEACON_ENABLED;\n\t\t\t\tieee80211_bss_info_change_notify(sdata, changed);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_NAN:\n\t\t\tres = ieee80211_reconfig_nan(sdata);\n\t\t\tif (res < 0) {\n\t\t\t\tsdata_unlock(sdata);\n\t\t\t\tieee80211_handle_reconfig_failure(local);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tcase NL80211_IFTYPE_MONITOR:\n\t\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t\t \n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_UNSPECIFIED:\n\t\tcase NUM_NL80211_IFTYPES:\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\tcase NL80211_IFTYPE_WDS:\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tsdata_unlock(sdata);\n\n\t\tif (active_links)\n\t\t\tieee80211_set_active_links(&sdata->vif, active_links);\n\t}\n\n\tieee80211_recalc_ps(local);\n\n\t \n\tif (!(local->hw.conf.flags & IEEE80211_CONF_PS)) {\n\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\t\t\tcontinue;\n\t\t\tif (!sdata->u.mgd.associated)\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_send_nullfunc(local, sdata, false);\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tsdata_lock(sdata);\n\t\tswitch (sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\tieee80211_reconfig_stations(sdata);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tsdata_unlock(sdata);\n\t}\n\n\t \n\tlist_for_each_entry(sdata, &local->interfaces, list)\n\t\tieee80211_reenable_keys(sdata);\n\n\t \n\tmutex_lock(&local->mtx);\n\tsched_scan_sdata = rcu_dereference_protected(local->sched_scan_sdata,\n\t\t\t\t\t\tlockdep_is_held(&local->mtx));\n\tsched_scan_req = rcu_dereference_protected(local->sched_scan_req,\n\t\t\t\t\t\tlockdep_is_held(&local->mtx));\n\tif (sched_scan_sdata && sched_scan_req)\n\t\t \n\t\tif (sched_scan_req->n_scan_plans > 1 ||\n\t\t    __ieee80211_request_sched_scan_start(sched_scan_sdata,\n\t\t\t\t\t\t\t sched_scan_req)) {\n\t\t\tRCU_INIT_POINTER(local->sched_scan_sdata, NULL);\n\t\t\tRCU_INIT_POINTER(local->sched_scan_req, NULL);\n\t\t\tsched_scan_stopped = true;\n\t\t}\n\tmutex_unlock(&local->mtx);\n\n\tif (sched_scan_stopped)\n\t\tcfg80211_sched_scan_stopped_locked(local->hw.wiphy, 0);\n\n wake_up:\n\n\tif (local->monitors == local->open_count && local->monitors > 0)\n\t\tieee80211_add_virtual_monitor(local);\n\n\t \n\tif (ieee80211_hw_check(hw, AMPDU_AGGREGATION)) {\n\t\tmutex_lock(&local->sta_mtx);\n\n\t\tlist_for_each_entry(sta, &local->sta_list, list) {\n\t\t\tif (!local->resuming)\n\t\t\t\tieee80211_sta_tear_down_BA_sessions(\n\t\t\t\t\t\tsta, AGG_STOP_LOCAL_REQUEST);\n\t\t\tclear_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\t\t}\n\n\t\tmutex_unlock(&local->sta_mtx);\n\t}\n\n\t \n\tif (local->open_count && (!suspended || reconfig_due_to_wowlan))\n\t\tdrv_reconfig_complete(local, IEEE80211_RECONFIG_TYPE_RESTART);\n\n\tif (local->in_reconfig) {\n\t\tin_reconfig = local->in_reconfig;\n\t\tlocal->in_reconfig = false;\n\t\tbarrier();\n\n\t\t \n\t\tmutex_lock(&local->mtx);\n\t\tieee80211_start_next_roc(local);\n\t\tmutex_unlock(&local->mtx);\n\n\t\t \n\t\tlist_for_each_entry(sdata, &local->interfaces, list)\n\t\t\twiphy_work_queue(local->hw.wiphy, &sdata->work);\n\t}\n\n\tieee80211_wake_queues_by_reason(hw, IEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_SUSPEND,\n\t\t\t\t\tfalse);\n\n\tif (in_reconfig) {\n\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\t\tcontinue;\n\t\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\t\t\tieee80211_sta_restart(sdata);\n\t\t}\n\t}\n\n\tif (!suspended)\n\t\treturn 0;\n\n#ifdef CONFIG_PM\n\t \n\tlocal->suspended = false;\n\tmb();\n\tlocal->resuming = false;\n\n\tieee80211_flush_completed_scan(local, false);\n\n\tif (local->open_count && !reconfig_due_to_wowlan)\n\t\tdrv_reconfig_complete(local, IEEE80211_RECONFIG_TYPE_SUSPEND);\n\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\t\tieee80211_sta_restart(sdata);\n\t}\n\n\tmod_timer(&local->sta_cleanup, jiffies + 1);\n#else\n\tWARN_ON(1);\n#endif\n\n\treturn 0;\n}\n\nstatic void ieee80211_reconfig_disconnect(struct ieee80211_vif *vif, u8 flag)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_key *key;\n\n\tif (WARN_ON(!vif))\n\t\treturn;\n\n\tsdata = vif_to_sdata(vif);\n\tlocal = sdata->local;\n\n\tif (WARN_ON(flag & IEEE80211_SDATA_DISCONNECT_RESUME &&\n\t\t    !local->resuming))\n\t\treturn;\n\n\tif (WARN_ON(flag & IEEE80211_SDATA_DISCONNECT_HW_RESTART &&\n\t\t    !local->in_reconfig))\n\t\treturn;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn;\n\n\tsdata->flags |= flag;\n\n\tmutex_lock(&local->key_mtx);\n\tlist_for_each_entry(key, &sdata->key_list, list)\n\t\tkey->flags |= KEY_FLAG_TAINTED;\n\tmutex_unlock(&local->key_mtx);\n}\n\nvoid ieee80211_hw_restart_disconnect(struct ieee80211_vif *vif)\n{\n\tieee80211_reconfig_disconnect(vif, IEEE80211_SDATA_DISCONNECT_HW_RESTART);\n}\nEXPORT_SYMBOL_GPL(ieee80211_hw_restart_disconnect);\n\nvoid ieee80211_resume_disconnect(struct ieee80211_vif *vif)\n{\n\tieee80211_reconfig_disconnect(vif, IEEE80211_SDATA_DISCONNECT_RESUME);\n}\nEXPORT_SYMBOL_GPL(ieee80211_resume_disconnect);\n\nvoid ieee80211_recalc_smps(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_chanctx *chanctx;\n\n\tmutex_lock(&local->chanctx_mtx);\n\n\tchanctx_conf = rcu_dereference_protected(link->conf->chanctx_conf,\n\t\t\t\t\t\t lockdep_is_held(&local->chanctx_mtx));\n\n\t \n\tif (!chanctx_conf)\n\t\tgoto unlock;\n\n\tchanctx = container_of(chanctx_conf, struct ieee80211_chanctx, conf);\n\tieee80211_recalc_smps_chanctx(local, chanctx);\n unlock:\n\tmutex_unlock(&local->chanctx_mtx);\n}\n\nvoid ieee80211_recalc_min_chandef(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  int link_id)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_chanctx *chanctx;\n\tint i;\n\n\tmutex_lock(&local->chanctx_mtx);\n\n\tfor (i = 0; i < ARRAY_SIZE(sdata->vif.link_conf); i++) {\n\t\tstruct ieee80211_bss_conf *bss_conf;\n\n\t\tif (link_id >= 0 && link_id != i)\n\t\t\tcontinue;\n\n\t\trcu_read_lock();\n\t\tbss_conf = rcu_dereference(sdata->vif.link_conf[i]);\n\t\tif (!bss_conf) {\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\n\t\tchanctx_conf = rcu_dereference_protected(bss_conf->chanctx_conf,\n\t\t\t\t\t\t\t lockdep_is_held(&local->chanctx_mtx));\n\t\t \n\t\trcu_read_unlock();\n\n\t\tif (!chanctx_conf)\n\t\t\tgoto unlock;\n\n\t\tchanctx = container_of(chanctx_conf, struct ieee80211_chanctx,\n\t\t\t\t       conf);\n\t\tieee80211_recalc_chanctx_min_def(local, chanctx, NULL);\n\t}\n unlock:\n\tmutex_unlock(&local->chanctx_mtx);\n}\n\nsize_t ieee80211_ie_split_vendor(const u8 *ies, size_t ielen, size_t offset)\n{\n\tsize_t pos = offset;\n\n\twhile (pos < ielen && ies[pos] != WLAN_EID_VENDOR_SPECIFIC)\n\t\tpos += 2 + ies[pos + 1];\n\n\treturn pos;\n}\n\nu8 *ieee80211_ie_build_s1g_cap(u8 *pos, struct ieee80211_sta_s1g_cap *s1g_cap)\n{\n\t*pos++ = WLAN_EID_S1G_CAPABILITIES;\n\t*pos++ = sizeof(struct ieee80211_s1g_cap);\n\tmemset(pos, 0, sizeof(struct ieee80211_s1g_cap));\n\n\tmemcpy(pos, &s1g_cap->cap, sizeof(s1g_cap->cap));\n\tpos += sizeof(s1g_cap->cap);\n\n\tmemcpy(pos, &s1g_cap->nss_mcs, sizeof(s1g_cap->nss_mcs));\n\tpos += sizeof(s1g_cap->nss_mcs);\n\n\treturn pos;\n}\n\nu8 *ieee80211_ie_build_ht_cap(u8 *pos, struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t      u16 cap)\n{\n\t__le16 tmp;\n\n\t*pos++ = WLAN_EID_HT_CAPABILITY;\n\t*pos++ = sizeof(struct ieee80211_ht_cap);\n\tmemset(pos, 0, sizeof(struct ieee80211_ht_cap));\n\n\t \n\ttmp = cpu_to_le16(cap);\n\tmemcpy(pos, &tmp, sizeof(u16));\n\tpos += sizeof(u16);\n\n\t \n\t*pos++ = ht_cap->ampdu_factor |\n\t\t (ht_cap->ampdu_density <<\n\t\t\tIEEE80211_HT_AMPDU_PARM_DENSITY_SHIFT);\n\n\t \n\tmemcpy(pos, &ht_cap->mcs, sizeof(ht_cap->mcs));\n\tpos += sizeof(ht_cap->mcs);\n\n\t \n\tpos += sizeof(__le16);\n\n\t \n\tpos += sizeof(__le32);\n\n\t \n\tpos += sizeof(u8);\n\n\treturn pos;\n}\n\nu8 *ieee80211_ie_build_vht_cap(u8 *pos, struct ieee80211_sta_vht_cap *vht_cap,\n\t\t\t       u32 cap)\n{\n\t__le32 tmp;\n\n\t*pos++ = WLAN_EID_VHT_CAPABILITY;\n\t*pos++ = sizeof(struct ieee80211_vht_cap);\n\tmemset(pos, 0, sizeof(struct ieee80211_vht_cap));\n\n\t \n\ttmp = cpu_to_le32(cap);\n\tmemcpy(pos, &tmp, sizeof(u32));\n\tpos += sizeof(u32);\n\n\t \n\tmemcpy(pos, &vht_cap->vht_mcs, sizeof(vht_cap->vht_mcs));\n\tpos += sizeof(vht_cap->vht_mcs);\n\n\treturn pos;\n}\n\nu8 ieee80211_ie_len_he_cap(struct ieee80211_sub_if_data *sdata, u8 iftype)\n{\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tstruct ieee80211_supported_band *sband;\n\tu8 n;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn 0;\n\n\the_cap = ieee80211_get_he_iftype_cap(sband, iftype);\n\tif (!he_cap)\n\t\treturn 0;\n\n\tn = ieee80211_he_mcs_nss_size(&he_cap->he_cap_elem);\n\treturn 2 + 1 +\n\t       sizeof(he_cap->he_cap_elem) + n +\n\t       ieee80211_he_ppe_size(he_cap->ppe_thres[0],\n\t\t\t\t     he_cap->he_cap_elem.phy_cap_info);\n}\n\nu8 *ieee80211_ie_build_he_cap(ieee80211_conn_flags_t disable_flags, u8 *pos,\n\t\t\t      const struct ieee80211_sta_he_cap *he_cap,\n\t\t\t      u8 *end)\n{\n\tstruct ieee80211_he_cap_elem elem;\n\tu8 n;\n\tu8 ie_len;\n\tu8 *orig_pos = pos;\n\n\t \n\t \n\tif (!he_cap)\n\t\treturn orig_pos;\n\n\t \n\telem = he_cap->he_cap_elem;\n\n\tif (disable_flags & IEEE80211_CONN_DISABLE_40MHZ)\n\t\telem.phy_cap_info[0] &=\n\t\t\t~(IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G |\n\t\t\t  IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G);\n\n\tif (disable_flags & IEEE80211_CONN_DISABLE_160MHZ)\n\t\telem.phy_cap_info[0] &=\n\t\t\t~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;\n\n\tif (disable_flags & IEEE80211_CONN_DISABLE_80P80MHZ)\n\t\telem.phy_cap_info[0] &=\n\t\t\t~IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G;\n\n\tn = ieee80211_he_mcs_nss_size(&elem);\n\tie_len = 2 + 1 +\n\t\t sizeof(he_cap->he_cap_elem) + n +\n\t\t ieee80211_he_ppe_size(he_cap->ppe_thres[0],\n\t\t\t\t       he_cap->he_cap_elem.phy_cap_info);\n\n\tif ((end - pos) < ie_len)\n\t\treturn orig_pos;\n\n\t*pos++ = WLAN_EID_EXTENSION;\n\tpos++;  \n\t*pos++ = WLAN_EID_EXT_HE_CAPABILITY;\n\n\t \n\tmemcpy(pos, &elem, sizeof(elem));\n\tpos += sizeof(elem);\n\n\tmemcpy(pos, &he_cap->he_mcs_nss_supp, n);\n\tpos += n;\n\n\t \n\tif ((he_cap->he_cap_elem.phy_cap_info[6] &\n\t     IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT) == 0)\n\t\tgoto end;\n\n\t \n\tn = hweight8(he_cap->ppe_thres[0] &\n\t\t     IEEE80211_PPE_THRES_RU_INDEX_BITMASK_MASK);\n\tn *= (1 + ((he_cap->ppe_thres[0] & IEEE80211_PPE_THRES_NSS_MASK) >>\n\t\t   IEEE80211_PPE_THRES_NSS_POS));\n\n\t \n\tn = (n * IEEE80211_PPE_THRES_INFO_PPET_SIZE * 2) + 7;\n\tn = DIV_ROUND_UP(n, 8);\n\n\t \n\tmemcpy(pos, &he_cap->ppe_thres, n);\n\tpos += n;\n\nend:\n\torig_pos[1] = (pos - orig_pos) - 2;\n\treturn pos;\n}\n\nvoid ieee80211_ie_build_he_6ghz_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    enum ieee80211_smps_mode smps_mode,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct ieee80211_supported_band *sband;\n\tconst struct ieee80211_sband_iftype_data *iftd;\n\tenum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);\n\tu8 *pos;\n\tu16 cap;\n\n\tif (!cfg80211_any_usable_channels(sdata->local->hw.wiphy,\n\t\t\t\t\t  BIT(NL80211_BAND_6GHZ),\n\t\t\t\t\t  IEEE80211_CHAN_NO_HE))\n\t\treturn;\n\n\tsband = sdata->local->hw.wiphy->bands[NL80211_BAND_6GHZ];\n\n\tiftd = ieee80211_get_sband_iftype_data(sband, iftype);\n\tif (!iftd)\n\t\treturn;\n\n\t \n\tif (!iftd->he_6ghz_capa.capa)\n\t\treturn;\n\n\tcap = le16_to_cpu(iftd->he_6ghz_capa.capa);\n\tcap &= ~IEEE80211_HE_6GHZ_CAP_SM_PS;\n\n\tswitch (smps_mode) {\n\tcase IEEE80211_SMPS_AUTOMATIC:\n\tcase IEEE80211_SMPS_NUM_MODES:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase IEEE80211_SMPS_OFF:\n\t\tcap |= u16_encode_bits(WLAN_HT_CAP_SM_PS_DISABLED,\n\t\t\t\t       IEEE80211_HE_6GHZ_CAP_SM_PS);\n\t\tbreak;\n\tcase IEEE80211_SMPS_STATIC:\n\t\tcap |= u16_encode_bits(WLAN_HT_CAP_SM_PS_STATIC,\n\t\t\t\t       IEEE80211_HE_6GHZ_CAP_SM_PS);\n\t\tbreak;\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\tcap |= u16_encode_bits(WLAN_HT_CAP_SM_PS_DYNAMIC,\n\t\t\t\t       IEEE80211_HE_6GHZ_CAP_SM_PS);\n\t\tbreak;\n\t}\n\n\tpos = skb_put(skb, 2 + 1 + sizeof(cap));\n\tieee80211_write_he_6ghz_cap(pos, cpu_to_le16(cap),\n\t\t\t\t    pos + 2 + 1 + sizeof(cap));\n}\n\nu8 *ieee80211_ie_build_ht_oper(u8 *pos, struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t       const struct cfg80211_chan_def *chandef,\n\t\t\t       u16 prot_mode, bool rifs_mode)\n{\n\tstruct ieee80211_ht_operation *ht_oper;\n\t \n\t*pos++ = WLAN_EID_HT_OPERATION;\n\t*pos++ = sizeof(struct ieee80211_ht_operation);\n\tht_oper = (struct ieee80211_ht_operation *)pos;\n\tht_oper->primary_chan = ieee80211_frequency_to_channel(\n\t\t\t\t\tchandef->chan->center_freq);\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_160:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (chandef->center_freq1 > chandef->chan->center_freq)\n\t\t\tht_oper->ht_param = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\n\t\telse\n\t\t\tht_oper->ht_param = IEEE80211_HT_PARAM_CHA_SEC_BELOW;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\t \n\t\tWARN_ON(1);\n\t\treturn pos;\n\tdefault:\n\t\tht_oper->ht_param = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n\t\tbreak;\n\t}\n\tif (ht_cap->cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 &&\n\t    chandef->width != NL80211_CHAN_WIDTH_20_NOHT &&\n\t    chandef->width != NL80211_CHAN_WIDTH_20)\n\t\tht_oper->ht_param |= IEEE80211_HT_PARAM_CHAN_WIDTH_ANY;\n\n\tif (rifs_mode)\n\t\tht_oper->ht_param |= IEEE80211_HT_PARAM_RIFS_MODE;\n\n\tht_oper->operation_mode = cpu_to_le16(prot_mode);\n\tht_oper->stbc_param = 0x0000;\n\n\t \n\tmemset(&ht_oper->basic_set, 0, 16);\n\tmemcpy(&ht_oper->basic_set, &ht_cap->mcs, 10);\n\n\treturn pos + sizeof(struct ieee80211_ht_operation);\n}\n\nvoid ieee80211_ie_build_wide_bw_cs(u8 *pos,\n\t\t\t\t   const struct cfg80211_chan_def *chandef)\n{\n\t*pos++ = WLAN_EID_WIDE_BW_CHANNEL_SWITCH;\t \n\t*pos++ = 3;\t\t\t\t\t \n\t \n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_80:\n\t\t*pos++ = IEEE80211_VHT_CHANWIDTH_80MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\t*pos++ = IEEE80211_VHT_CHANWIDTH_160MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\t*pos++ = IEEE80211_VHT_CHANWIDTH_80P80MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\t \n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tdefault:\n\t\t*pos++ = IEEE80211_VHT_CHANWIDTH_USE_HT;\n\t}\n\n\t \n\t*pos++ = ieee80211_frequency_to_channel(chandef->center_freq1);\n\t \n\tif (chandef->center_freq2)\n\t\t*pos++ = ieee80211_frequency_to_channel(chandef->center_freq2);\n\telse\n\t\t*pos++ = 0;\n}\n\nu8 *ieee80211_ie_build_vht_oper(u8 *pos, struct ieee80211_sta_vht_cap *vht_cap,\n\t\t\t\tconst struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_vht_operation *vht_oper;\n\n\t*pos++ = WLAN_EID_VHT_OPERATION;\n\t*pos++ = sizeof(struct ieee80211_vht_operation);\n\tvht_oper = (struct ieee80211_vht_operation *)pos;\n\tvht_oper->center_freq_seg0_idx = ieee80211_frequency_to_channel(\n\t\t\t\t\t\t\tchandef->center_freq1);\n\tif (chandef->center_freq2)\n\t\tvht_oper->center_freq_seg1_idx =\n\t\t\tieee80211_frequency_to_channel(chandef->center_freq2);\n\telse\n\t\tvht_oper->center_freq_seg1_idx = 0x00;\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_160:\n\t\t \n\t\tvht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_80MHZ;\n\t\tvht_oper->center_freq_seg1_idx = vht_oper->center_freq_seg0_idx;\n\t\tif (chandef->chan->center_freq < chandef->center_freq1)\n\t\t\tvht_oper->center_freq_seg0_idx -= 8;\n\t\telse\n\t\t\tvht_oper->center_freq_seg0_idx += 8;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\t \n\t\tvht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_80MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tvht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_80MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\t \n\t\tWARN_ON(1);\n\t\treturn pos;\n\tdefault:\n\t\tvht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_USE_HT;\n\t\tbreak;\n\t}\n\n\t \n\tvht_oper->basic_mcs_set = cpu_to_le16(0xffff);\n\n\treturn pos + sizeof(struct ieee80211_vht_operation);\n}\n\nu8 *ieee80211_ie_build_he_oper(u8 *pos, struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_he_operation *he_oper;\n\tstruct ieee80211_he_6ghz_oper *he_6ghz_op;\n\tu32 he_oper_params;\n\tu8 ie_len = 1 + sizeof(struct ieee80211_he_operation);\n\n\tif (chandef->chan->band == NL80211_BAND_6GHZ)\n\t\tie_len += sizeof(struct ieee80211_he_6ghz_oper);\n\n\t*pos++ = WLAN_EID_EXTENSION;\n\t*pos++ = ie_len;\n\t*pos++ = WLAN_EID_EXT_HE_OPERATION;\n\n\the_oper_params = 0;\n\the_oper_params |= u32_encode_bits(1023,  \n\t\t\t\tIEEE80211_HE_OPERATION_RTS_THRESHOLD_MASK);\n\the_oper_params |= u32_encode_bits(1,\n\t\t\t\tIEEE80211_HE_OPERATION_ER_SU_DISABLE);\n\the_oper_params |= u32_encode_bits(1,\n\t\t\t\tIEEE80211_HE_OPERATION_BSS_COLOR_DISABLED);\n\tif (chandef->chan->band == NL80211_BAND_6GHZ)\n\t\the_oper_params |= u32_encode_bits(1,\n\t\t\t\tIEEE80211_HE_OPERATION_6GHZ_OP_INFO);\n\n\the_oper = (struct ieee80211_he_operation *)pos;\n\the_oper->he_oper_params = cpu_to_le32(he_oper_params);\n\n\t \n\the_oper->he_mcs_nss_set = cpu_to_le16(0xffff);\n\tpos += sizeof(struct ieee80211_he_operation);\n\n\tif (chandef->chan->band != NL80211_BAND_6GHZ)\n\t\tgoto out;\n\n\t \n\the_6ghz_op = (struct ieee80211_he_6ghz_oper *)pos;\n\the_6ghz_op->minrate = 6;  \n\the_6ghz_op->primary =\n\t\tieee80211_frequency_to_channel(chandef->chan->center_freq);\n\the_6ghz_op->ccfs0 =\n\t\tieee80211_frequency_to_channel(chandef->center_freq1);\n\tif (chandef->center_freq2)\n\t\the_6ghz_op->ccfs1 =\n\t\t\tieee80211_frequency_to_channel(chandef->center_freq2);\n\telse\n\t\the_6ghz_op->ccfs1 = 0;\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_320:\n\t\t \n\t\tWARN_ON(1);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\t \n\t\the_6ghz_op->control =\n\t\t\tIEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_160MHZ;\n\t\the_6ghz_op->ccfs1 = he_6ghz_op->ccfs0;\n\t\tif (chandef->chan->center_freq < chandef->center_freq1)\n\t\t\the_6ghz_op->ccfs0 -= 8;\n\t\telse\n\t\t\the_6ghz_op->ccfs0 += 8;\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\the_6ghz_op->control =\n\t\t\tIEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_160MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\the_6ghz_op->control =\n\t\t\tIEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_80MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\the_6ghz_op->control =\n\t\t\tIEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_40MHZ;\n\t\tbreak;\n\tdefault:\n\t\the_6ghz_op->control =\n\t\t\tIEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_20MHZ;\n\t\tbreak;\n\t}\n\n\tpos += sizeof(struct ieee80211_he_6ghz_oper);\n\nout:\n\treturn pos;\n}\n\nu8 *ieee80211_ie_build_eht_oper(u8 *pos, struct cfg80211_chan_def *chandef,\n\t\t\t\tconst struct ieee80211_sta_eht_cap *eht_cap)\n\n{\n\tconst struct ieee80211_eht_mcs_nss_supp_20mhz_only *eht_mcs_nss =\n\t\t\t\t\t&eht_cap->eht_mcs_nss_supp.only_20mhz;\n\tstruct ieee80211_eht_operation *eht_oper;\n\tstruct ieee80211_eht_operation_info *eht_oper_info;\n\tu8 eht_oper_len = offsetof(struct ieee80211_eht_operation, optional);\n\tu8 eht_oper_info_len =\n\t\toffsetof(struct ieee80211_eht_operation_info, optional);\n\tu8 chan_width = 0;\n\n\t*pos++ = WLAN_EID_EXTENSION;\n\t*pos++ = 1 + eht_oper_len + eht_oper_info_len;\n\t*pos++ = WLAN_EID_EXT_EHT_OPERATION;\n\n\teht_oper = (struct ieee80211_eht_operation *)pos;\n\n\tmemcpy(&eht_oper->basic_mcs_nss, eht_mcs_nss, sizeof(*eht_mcs_nss));\n\teht_oper->params |= IEEE80211_EHT_OPER_INFO_PRESENT;\n\tpos += eht_oper_len;\n\n\teht_oper_info =\n\t\t(struct ieee80211_eht_operation_info *)eht_oper->optional;\n\n\teht_oper_info->ccfs0 =\n\t\tieee80211_frequency_to_channel(chandef->center_freq1);\n\tif (chandef->center_freq2)\n\t\teht_oper_info->ccfs1 =\n\t\t\tieee80211_frequency_to_channel(chandef->center_freq2);\n\telse\n\t\teht_oper_info->ccfs1 = 0;\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_320:\n\t\tchan_width = IEEE80211_EHT_OPER_CHAN_WIDTH_320MHZ;\n\t\teht_oper_info->ccfs1 = eht_oper_info->ccfs0;\n\t\tif (chandef->chan->center_freq < chandef->center_freq1)\n\t\t\teht_oper_info->ccfs0 -= 16;\n\t\telse\n\t\t\teht_oper_info->ccfs0 += 16;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\teht_oper_info->ccfs1 = eht_oper_info->ccfs0;\n\t\tif (chandef->chan->center_freq < chandef->center_freq1)\n\t\t\teht_oper_info->ccfs0 -= 8;\n\t\telse\n\t\t\teht_oper_info->ccfs0 += 8;\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\tchan_width = IEEE80211_EHT_OPER_CHAN_WIDTH_160MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tchan_width = IEEE80211_EHT_OPER_CHAN_WIDTH_80MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tchan_width = IEEE80211_EHT_OPER_CHAN_WIDTH_40MHZ;\n\t\tbreak;\n\tdefault:\n\t\tchan_width = IEEE80211_EHT_OPER_CHAN_WIDTH_20MHZ;\n\t\tbreak;\n\t}\n\teht_oper_info->control = chan_width;\n\tpos += eht_oper_info_len;\n\n\t \n\n\treturn pos;\n}\n\nbool ieee80211_chandef_ht_oper(const struct ieee80211_ht_operation *ht_oper,\n\t\t\t       struct cfg80211_chan_def *chandef)\n{\n\tenum nl80211_channel_type channel_type;\n\n\tif (!ht_oper)\n\t\treturn false;\n\n\tswitch (ht_oper->ht_param & IEEE80211_HT_PARAM_CHA_SEC_OFFSET) {\n\tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n\t\tchannel_type = NL80211_CHAN_HT20;\n\t\tbreak;\n\tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n\t\tchannel_type = NL80211_CHAN_HT40PLUS;\n\t\tbreak;\n\tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n\t\tchannel_type = NL80211_CHAN_HT40MINUS;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tcfg80211_chandef_create(chandef, chandef->chan, channel_type);\n\treturn true;\n}\n\nbool ieee80211_chandef_vht_oper(struct ieee80211_hw *hw, u32 vht_cap_info,\n\t\t\t\tconst struct ieee80211_vht_operation *oper,\n\t\t\t\tconst struct ieee80211_ht_operation *htop,\n\t\t\t\tstruct cfg80211_chan_def *chandef)\n{\n\tstruct cfg80211_chan_def new = *chandef;\n\tint cf0, cf1;\n\tint ccfs0, ccfs1, ccfs2;\n\tint ccf0, ccf1;\n\tu32 vht_cap;\n\tbool support_80_80 = false;\n\tbool support_160 = false;\n\tu8 ext_nss_bw_supp = u32_get_bits(vht_cap_info,\n\t\t\t\t\t  IEEE80211_VHT_CAP_EXT_NSS_BW_MASK);\n\tu8 supp_chwidth = u32_get_bits(vht_cap_info,\n\t\t\t\t       IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK);\n\n\tif (!oper || !htop)\n\t\treturn false;\n\n\tvht_cap = hw->wiphy->bands[chandef->chan->band]->vht_cap.cap;\n\tsupport_160 = (vht_cap & (IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK |\n\t\t\t\t  IEEE80211_VHT_CAP_EXT_NSS_BW_MASK));\n\tsupport_80_80 = ((vht_cap &\n\t\t\t IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ) ||\n\t\t\t(vht_cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ &&\n\t\t\t vht_cap & IEEE80211_VHT_CAP_EXT_NSS_BW_MASK) ||\n\t\t\t((vht_cap & IEEE80211_VHT_CAP_EXT_NSS_BW_MASK) >>\n\t\t\t\t    IEEE80211_VHT_CAP_EXT_NSS_BW_SHIFT > 1));\n\tccfs0 = oper->center_freq_seg0_idx;\n\tccfs1 = oper->center_freq_seg1_idx;\n\tccfs2 = (le16_to_cpu(htop->operation_mode) &\n\t\t\t\tIEEE80211_HT_OP_MODE_CCFS2_MASK)\n\t\t\t>> IEEE80211_HT_OP_MODE_CCFS2_SHIFT;\n\n\tccf0 = ccfs0;\n\n\t \n\tif (!ieee80211_hw_check(hw, SUPPORTS_VHT_EXT_NSS_BW))\n\t\text_nss_bw_supp = 0;\n\n\t \n\tswitch ((supp_chwidth << 4) | ext_nss_bw_supp) {\n\tdefault:\n\tcase 0x00:\n\t\tccf1 = 0;\n\t\tsupport_160 = false;\n\t\tsupport_80_80 = false;\n\t\tbreak;\n\tcase 0x01:\n\t\tsupport_80_80 = false;\n\t\tfallthrough;\n\tcase 0x02:\n\tcase 0x03:\n\t\tccf1 = ccfs2;\n\t\tbreak;\n\tcase 0x10:\n\t\tccf1 = ccfs1;\n\t\tbreak;\n\tcase 0x11:\n\tcase 0x12:\n\t\tif (!ccfs1)\n\t\t\tccf1 = ccfs2;\n\t\telse\n\t\t\tccf1 = ccfs1;\n\t\tbreak;\n\tcase 0x13:\n\tcase 0x20:\n\tcase 0x23:\n\t\tccf1 = ccfs1;\n\t\tbreak;\n\t}\n\n\tcf0 = ieee80211_channel_to_frequency(ccf0, chandef->chan->band);\n\tcf1 = ieee80211_channel_to_frequency(ccf1, chandef->chan->band);\n\n\tswitch (oper->chan_width) {\n\tcase IEEE80211_VHT_CHANWIDTH_USE_HT:\n\t\t \n\t\tbreak;\n\tcase IEEE80211_VHT_CHANWIDTH_80MHZ:\n\t\tnew.width = NL80211_CHAN_WIDTH_80;\n\t\tnew.center_freq1 = cf0;\n\t\t \n\t\tif (ccf1) {\n\t\t\tunsigned int diff;\n\n\t\t\tdiff = abs(ccf1 - ccf0);\n\t\t\tif ((diff == 8) && support_160) {\n\t\t\t\tnew.width = NL80211_CHAN_WIDTH_160;\n\t\t\t\tnew.center_freq1 = cf1;\n\t\t\t} else if ((diff > 8) && support_80_80) {\n\t\t\t\tnew.width = NL80211_CHAN_WIDTH_80P80;\n\t\t\t\tnew.center_freq2 = cf1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_VHT_CHANWIDTH_160MHZ:\n\t\t \n\t\tnew.width = NL80211_CHAN_WIDTH_160;\n\t\tnew.center_freq1 = cf0;\n\t\tbreak;\n\tcase IEEE80211_VHT_CHANWIDTH_80P80MHZ:\n\t\t \n\t\tnew.width = NL80211_CHAN_WIDTH_80P80;\n\t\tnew.center_freq1 = cf0;\n\t\tnew.center_freq2 = cf1;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (!cfg80211_chandef_valid(&new))\n\t\treturn false;\n\n\t*chandef = new;\n\treturn true;\n}\n\nvoid ieee80211_chandef_eht_oper(const struct ieee80211_eht_operation *eht_oper,\n\t\t\t\tbool support_160, bool support_320,\n\t\t\t\tstruct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_eht_operation_info *info = (void *)eht_oper->optional;\n\n\tchandef->center_freq1 =\n\t\tieee80211_channel_to_frequency(info->ccfs0,\n\t\t\t\t\t       chandef->chan->band);\n\n\tswitch (u8_get_bits(info->control,\n\t\t\t    IEEE80211_EHT_OPER_CHAN_WIDTH)) {\n\tcase IEEE80211_EHT_OPER_CHAN_WIDTH_20MHZ:\n\t\tchandef->width = NL80211_CHAN_WIDTH_20;\n\t\tbreak;\n\tcase IEEE80211_EHT_OPER_CHAN_WIDTH_40MHZ:\n\t\tchandef->width = NL80211_CHAN_WIDTH_40;\n\t\tbreak;\n\tcase IEEE80211_EHT_OPER_CHAN_WIDTH_80MHZ:\n\t\tchandef->width = NL80211_CHAN_WIDTH_80;\n\t\tbreak;\n\tcase IEEE80211_EHT_OPER_CHAN_WIDTH_160MHZ:\n\t\tif (support_160) {\n\t\t\tchandef->width = NL80211_CHAN_WIDTH_160;\n\t\t\tchandef->center_freq1 =\n\t\t\t\tieee80211_channel_to_frequency(info->ccfs1,\n\t\t\t\t\t\t\t       chandef->chan->band);\n\t\t} else {\n\t\t\tchandef->width = NL80211_CHAN_WIDTH_80;\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_EHT_OPER_CHAN_WIDTH_320MHZ:\n\t\tif (support_320) {\n\t\t\tchandef->width = NL80211_CHAN_WIDTH_320;\n\t\t\tchandef->center_freq1 =\n\t\t\t\tieee80211_channel_to_frequency(info->ccfs1,\n\t\t\t\t\t\t\t       chandef->chan->band);\n\t\t} else if (support_160) {\n\t\t\tchandef->width = NL80211_CHAN_WIDTH_160;\n\t\t} else {\n\t\t\tchandef->width = NL80211_CHAN_WIDTH_80;\n\n\t\t\tif (chandef->center_freq1 > chandef->chan->center_freq)\n\t\t\t\tchandef->center_freq1 -= 40;\n\t\t\telse\n\t\t\t\tchandef->center_freq1 += 40;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nbool ieee80211_chandef_he_6ghz_oper(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    const struct ieee80211_he_operation *he_oper,\n\t\t\t\t    const struct ieee80211_eht_operation *eht_oper,\n\t\t\t\t    struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_supported_band *sband;\n\tenum nl80211_iftype iftype = ieee80211_vif_type_p2p(&sdata->vif);\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tconst struct ieee80211_sta_eht_cap *eht_cap;\n\tstruct cfg80211_chan_def he_chandef = *chandef;\n\tconst struct ieee80211_he_6ghz_oper *he_6ghz_oper;\n\tstruct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;\n\tbool support_80_80, support_160, support_320;\n\tu8 he_phy_cap, eht_phy_cap;\n\tu32 freq;\n\n\tif (chandef->chan->band != NL80211_BAND_6GHZ)\n\t\treturn true;\n\n\tsband = local->hw.wiphy->bands[NL80211_BAND_6GHZ];\n\n\the_cap = ieee80211_get_he_iftype_cap(sband, iftype);\n\tif (!he_cap) {\n\t\tsdata_info(sdata, \"Missing iftype sband data/HE cap\");\n\t\treturn false;\n\t}\n\n\the_phy_cap = he_cap->he_cap_elem.phy_cap_info[0];\n\tsupport_160 =\n\t\the_phy_cap &\n\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;\n\tsupport_80_80 =\n\t\the_phy_cap &\n\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G;\n\n\tif (!he_oper) {\n\t\tsdata_info(sdata,\n\t\t\t   \"HE is not advertised on (on %d MHz), expect issues\\n\",\n\t\t\t   chandef->chan->center_freq);\n\t\treturn false;\n\t}\n\n\teht_cap = ieee80211_get_eht_iftype_cap(sband, iftype);\n\tif (!eht_cap)\n\t\teht_oper = NULL;\n\n\the_6ghz_oper = ieee80211_he_6ghz_oper(he_oper);\n\n\tif (!he_6ghz_oper) {\n\t\tsdata_info(sdata,\n\t\t\t   \"HE 6GHz operation missing (on %d MHz), expect issues\\n\",\n\t\t\t   chandef->chan->center_freq);\n\t\treturn false;\n\t}\n\n\t \n\tfreq = ieee80211_channel_to_frequency(he_6ghz_oper->primary,\n\t\t\t\t\t      NL80211_BAND_6GHZ);\n\the_chandef.chan = ieee80211_get_channel(sdata->local->hw.wiphy, freq);\n\n\tswitch (u8_get_bits(he_6ghz_oper->control,\n\t\t\t    IEEE80211_HE_6GHZ_OPER_CTRL_REG_INFO)) {\n\tcase IEEE80211_6GHZ_CTRL_REG_LPI_AP:\n\t\tbss_conf->power_type = IEEE80211_REG_LPI_AP;\n\t\tbreak;\n\tcase IEEE80211_6GHZ_CTRL_REG_SP_AP:\n\t\tbss_conf->power_type = IEEE80211_REG_SP_AP;\n\t\tbreak;\n\tdefault:\n\t\tbss_conf->power_type = IEEE80211_REG_UNSET_AP;\n\t\tbreak;\n\t}\n\n\tif (!eht_oper ||\n\t    !(eht_oper->params & IEEE80211_EHT_OPER_INFO_PRESENT)) {\n\t\tswitch (u8_get_bits(he_6ghz_oper->control,\n\t\t\t\t    IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH)) {\n\t\tcase IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_20MHZ:\n\t\t\the_chandef.width = NL80211_CHAN_WIDTH_20;\n\t\t\tbreak;\n\t\tcase IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_40MHZ:\n\t\t\the_chandef.width = NL80211_CHAN_WIDTH_40;\n\t\t\tbreak;\n\t\tcase IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_80MHZ:\n\t\t\the_chandef.width = NL80211_CHAN_WIDTH_80;\n\t\t\tbreak;\n\t\tcase IEEE80211_HE_6GHZ_OPER_CTRL_CHANWIDTH_160MHZ:\n\t\t\the_chandef.width = NL80211_CHAN_WIDTH_80;\n\t\t\tif (!he_6ghz_oper->ccfs1)\n\t\t\t\tbreak;\n\t\t\tif (abs(he_6ghz_oper->ccfs1 - he_6ghz_oper->ccfs0) == 8) {\n\t\t\t\tif (support_160)\n\t\t\t\t\the_chandef.width = NL80211_CHAN_WIDTH_160;\n\t\t\t} else {\n\t\t\t\tif (support_80_80)\n\t\t\t\t\the_chandef.width = NL80211_CHAN_WIDTH_80P80;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (he_chandef.width == NL80211_CHAN_WIDTH_160) {\n\t\t\the_chandef.center_freq1 =\n\t\t\t\tieee80211_channel_to_frequency(he_6ghz_oper->ccfs1,\n\t\t\t\t\t\t\t       NL80211_BAND_6GHZ);\n\t\t} else {\n\t\t\the_chandef.center_freq1 =\n\t\t\t\tieee80211_channel_to_frequency(he_6ghz_oper->ccfs0,\n\t\t\t\t\t\t\t       NL80211_BAND_6GHZ);\n\t\t\tif (support_80_80 || support_160)\n\t\t\t\the_chandef.center_freq2 =\n\t\t\t\t\tieee80211_channel_to_frequency(he_6ghz_oper->ccfs1,\n\t\t\t\t\t\t\t\t       NL80211_BAND_6GHZ);\n\t\t}\n\t} else {\n\t\teht_phy_cap = eht_cap->eht_cap_elem.phy_cap_info[0];\n\t\tsupport_320 =\n\t\t\teht_phy_cap & IEEE80211_EHT_PHY_CAP0_320MHZ_IN_6GHZ;\n\n\t\tieee80211_chandef_eht_oper(eht_oper, support_160,\n\t\t\t\t\t   support_320, &he_chandef);\n\t}\n\n\tif (!cfg80211_chandef_valid(&he_chandef)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"HE 6GHz operation resulted in invalid chandef: %d MHz/%d/%d MHz/%d MHz\\n\",\n\t\t\t   he_chandef.chan ? he_chandef.chan->center_freq : 0,\n\t\t\t   he_chandef.width,\n\t\t\t   he_chandef.center_freq1,\n\t\t\t   he_chandef.center_freq2);\n\t\treturn false;\n\t}\n\n\t*chandef = he_chandef;\n\n\treturn true;\n}\n\nbool ieee80211_chandef_s1g_oper(const struct ieee80211_s1g_oper_ie *oper,\n\t\t\t\tstruct cfg80211_chan_def *chandef)\n{\n\tu32 oper_freq;\n\n\tif (!oper)\n\t\treturn false;\n\n\tswitch (FIELD_GET(S1G_OPER_CH_WIDTH_OPER, oper->ch_width)) {\n\tcase IEEE80211_S1G_CHANWIDTH_1MHZ:\n\t\tchandef->width = NL80211_CHAN_WIDTH_1;\n\t\tbreak;\n\tcase IEEE80211_S1G_CHANWIDTH_2MHZ:\n\t\tchandef->width = NL80211_CHAN_WIDTH_2;\n\t\tbreak;\n\tcase IEEE80211_S1G_CHANWIDTH_4MHZ:\n\t\tchandef->width = NL80211_CHAN_WIDTH_4;\n\t\tbreak;\n\tcase IEEE80211_S1G_CHANWIDTH_8MHZ:\n\t\tchandef->width = NL80211_CHAN_WIDTH_8;\n\t\tbreak;\n\tcase IEEE80211_S1G_CHANWIDTH_16MHZ:\n\t\tchandef->width = NL80211_CHAN_WIDTH_16;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\toper_freq = ieee80211_channel_to_freq_khz(oper->oper_ch,\n\t\t\t\t\t\t  NL80211_BAND_S1GHZ);\n\tchandef->center_freq1 = KHZ_TO_MHZ(oper_freq);\n\tchandef->freq1_offset = oper_freq % 1000;\n\n\treturn true;\n}\n\nint ieee80211_parse_bitrates(enum nl80211_chan_width width,\n\t\t\t     const struct ieee80211_supported_band *sband,\n\t\t\t     const u8 *srates, int srates_len, u32 *rates)\n{\n\tu32 rate_flags = ieee80211_chanwidth_rate_flags(width);\n\tint shift = ieee80211_chanwidth_get_shift(width);\n\tstruct ieee80211_rate *br;\n\tint brate, rate, i, j, count = 0;\n\n\t*rates = 0;\n\n\tfor (i = 0; i < srates_len; i++) {\n\t\trate = srates[i] & 0x7f;\n\n\t\tfor (j = 0; j < sband->n_bitrates; j++) {\n\t\t\tbr = &sband->bitrates[j];\n\t\t\tif ((rate_flags & br->flags) != rate_flags)\n\t\t\t\tcontinue;\n\n\t\t\tbrate = DIV_ROUND_UP(br->bitrate, (1 << shift) * 5);\n\t\t\tif (brate == rate) {\n\t\t\t\t*rates |= BIT(j);\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\nint ieee80211_add_srates_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct sk_buff *skb, bool need_basic,\n\t\t\t    enum nl80211_band band)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_supported_band *sband;\n\tint rate, shift;\n\tu8 i, rates, *pos;\n\tu32 basic_rates = sdata->vif.bss_conf.basic_rates;\n\tu32 rate_flags;\n\n\tshift = ieee80211_vif_get_shift(&sdata->vif);\n\trate_flags = ieee80211_chandef_rate_flags(&sdata->vif.bss_conf.chandef);\n\tsband = local->hw.wiphy->bands[band];\n\trates = 0;\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tif ((rate_flags & sband->bitrates[i].flags) != rate_flags)\n\t\t\tcontinue;\n\t\trates++;\n\t}\n\tif (rates > 8)\n\t\trates = 8;\n\n\tif (skb_tailroom(skb) < rates + 2)\n\t\treturn -ENOMEM;\n\n\tpos = skb_put(skb, rates + 2);\n\t*pos++ = WLAN_EID_SUPP_RATES;\n\t*pos++ = rates;\n\tfor (i = 0; i < rates; i++) {\n\t\tu8 basic = 0;\n\t\tif ((rate_flags & sband->bitrates[i].flags) != rate_flags)\n\t\t\tcontinue;\n\n\t\tif (need_basic && basic_rates & BIT(i))\n\t\t\tbasic = 0x80;\n\t\trate = DIV_ROUND_UP(sband->bitrates[i].bitrate,\n\t\t\t\t    5 * (1 << shift));\n\t\t*pos++ = basic | (u8) rate;\n\t}\n\n\treturn 0;\n}\n\nint ieee80211_add_ext_srates_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sk_buff *skb, bool need_basic,\n\t\t\t\tenum nl80211_band band)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_supported_band *sband;\n\tint rate, shift;\n\tu8 i, exrates, *pos;\n\tu32 basic_rates = sdata->vif.bss_conf.basic_rates;\n\tu32 rate_flags;\n\n\trate_flags = ieee80211_chandef_rate_flags(&sdata->vif.bss_conf.chandef);\n\tshift = ieee80211_vif_get_shift(&sdata->vif);\n\n\tsband = local->hw.wiphy->bands[band];\n\texrates = 0;\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tif ((rate_flags & sband->bitrates[i].flags) != rate_flags)\n\t\t\tcontinue;\n\t\texrates++;\n\t}\n\n\tif (exrates > 8)\n\t\texrates -= 8;\n\telse\n\t\texrates = 0;\n\n\tif (skb_tailroom(skb) < exrates + 2)\n\t\treturn -ENOMEM;\n\n\tif (exrates) {\n\t\tpos = skb_put(skb, exrates + 2);\n\t\t*pos++ = WLAN_EID_EXT_SUPP_RATES;\n\t\t*pos++ = exrates;\n\t\tfor (i = 8; i < sband->n_bitrates; i++) {\n\t\t\tu8 basic = 0;\n\t\t\tif ((rate_flags & sband->bitrates[i].flags)\n\t\t\t    != rate_flags)\n\t\t\t\tcontinue;\n\t\t\tif (need_basic && basic_rates & BIT(i))\n\t\t\t\tbasic = 0x80;\n\t\t\trate = DIV_ROUND_UP(sband->bitrates[i].bitrate,\n\t\t\t\t\t    5 * (1 << shift));\n\t\t\t*pos++ = basic | (u8) rate;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint ieee80211_ave_rssi(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tif (WARN_ON_ONCE(sdata->vif.type != NL80211_IFTYPE_STATION))\n\t\treturn 0;\n\n\treturn -ewma_beacon_signal_read(&sdata->deflink.u.mgd.ave_beacon_signal);\n}\nEXPORT_SYMBOL_GPL(ieee80211_ave_rssi);\n\nu8 ieee80211_mcs_to_chains(const struct ieee80211_mcs_info *mcs)\n{\n\tif (!mcs)\n\t\treturn 1;\n\n\t \n\n\tif (mcs->rx_mask[3])\n\t\treturn 4;\n\tif (mcs->rx_mask[2])\n\t\treturn 3;\n\tif (mcs->rx_mask[1])\n\t\treturn 2;\n\treturn 1;\n}\n\n \nu64 ieee80211_calculate_rx_timestamp(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_rx_status *status,\n\t\t\t\t     unsigned int mpdu_len,\n\t\t\t\t     unsigned int mpdu_offset)\n{\n\tu64 ts = status->mactime;\n\tstruct rate_info ri;\n\tu16 rate;\n\tu8 n_ltf;\n\n\tif (WARN_ON(!ieee80211_have_rx_timestamp(status)))\n\t\treturn 0;\n\n\tmemset(&ri, 0, sizeof(ri));\n\n\tri.bw = status->bw;\n\n\t \n\tswitch (status->encoding) {\n\tcase RX_ENC_EHT:\n\t\tri.flags |= RATE_INFO_FLAGS_EHT_MCS;\n\t\tri.mcs = status->rate_idx;\n\t\tri.nss = status->nss;\n\t\tri.eht_ru_alloc = status->eht.ru;\n\t\tif (status->enc_flags & RX_ENC_FLAG_SHORT_GI)\n\t\t\tri.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\t \n\t\tif (status->flag & RX_FLAG_MACTIME_PLCP_START) {\n\t\t\tmpdu_offset += 2;\n\t\t\tts += 36;\n\t\t}\n\t\tbreak;\n\tcase RX_ENC_HE:\n\t\tri.flags |= RATE_INFO_FLAGS_HE_MCS;\n\t\tri.mcs = status->rate_idx;\n\t\tri.nss = status->nss;\n\t\tri.he_ru_alloc = status->he_ru;\n\t\tif (status->enc_flags & RX_ENC_FLAG_SHORT_GI)\n\t\t\tri.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\n\t\t \n\t\tif (status->flag & RX_FLAG_MACTIME_PLCP_START) {\n\t\t\tmpdu_offset += 2;\n\t\t\tts += 36;\n\n\t\t\t \n\t\t}\n\n\t\tbreak;\n\tcase RX_ENC_HT:\n\t\tri.mcs = status->rate_idx;\n\t\tri.flags |= RATE_INFO_FLAGS_MCS;\n\t\tif (status->enc_flags & RX_ENC_FLAG_SHORT_GI)\n\t\t\tri.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\n\t\t \n\t\tif (status->flag & RX_FLAG_MACTIME_PLCP_START) {\n\t\t\tmpdu_offset += 2;\n\t\t\tif (status->enc_flags & RX_ENC_FLAG_HT_GF)\n\t\t\t\tts += 24;\n\t\t\telse\n\t\t\t\tts += 32;\n\n\t\t\t \n\t\t\tn_ltf = ((ri.mcs >> 3) & 3) + 1;\n\t\t\tn_ltf = n_ltf == 3 ? 4 : n_ltf;\n\t\t\tts += n_ltf * 4;\n\t\t}\n\n\t\tbreak;\n\tcase RX_ENC_VHT:\n\t\tri.flags |= RATE_INFO_FLAGS_VHT_MCS;\n\t\tri.mcs = status->rate_idx;\n\t\tri.nss = status->nss;\n\t\tif (status->enc_flags & RX_ENC_FLAG_SHORT_GI)\n\t\t\tri.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\n\t\t \n\t\tif (status->flag & RX_FLAG_MACTIME_PLCP_START) {\n\t\t\tmpdu_offset += 2;\n\t\t\tts += 36;\n\n\t\t\t \n\t\t\tn_ltf = (ri.nss != 1) && (ri.nss % 2) ?\n\t\t\t\tri.nss + 1 : ri.nss;\n\t\t\tts += 4 * n_ltf;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase RX_ENC_LEGACY: {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tint shift = 0;\n\t\tint bitrate;\n\n\t\tswitch (status->bw) {\n\t\tcase RATE_INFO_BW_10:\n\t\t\tshift = 1;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_5:\n\t\t\tshift = 2;\n\t\t\tbreak;\n\t\t}\n\n\t\tsband = local->hw.wiphy->bands[status->band];\n\t\tbitrate = sband->bitrates[status->rate_idx].bitrate;\n\t\tri.legacy = DIV_ROUND_UP(bitrate, (1 << shift));\n\n\t\tif (status->flag & RX_FLAG_MACTIME_PLCP_START) {\n\t\t\tif (status->band == NL80211_BAND_5GHZ) {\n\t\t\t\tts += 20 << shift;\n\t\t\t\tmpdu_offset += 2;\n\t\t\t} else if (status->enc_flags & RX_ENC_FLAG_SHORTPRE) {\n\t\t\t\tts += 96;\n\t\t\t} else {\n\t\t\t\tts += 192;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\n\trate = cfg80211_calculate_bitrate(&ri);\n\tif (WARN_ONCE(!rate,\n\t\t      \"Invalid bitrate: flags=0x%llx, idx=%d, vht_nss=%d\\n\",\n\t\t      (unsigned long long)status->flag, status->rate_idx,\n\t\t      status->nss))\n\t\treturn 0;\n\n\t \n\tif (status->flag & RX_FLAG_MACTIME_END)\n\t\tts -= mpdu_len * 8 * 10 / rate;\n\n\tts += mpdu_offset * 8 * 10 / rate;\n\n\treturn ts;\n}\n\nvoid ieee80211_dfs_cac_cancel(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct cfg80211_chan_def chandef;\n\n\t \n\tlockdep_assert_wiphy(local->hw.wiphy);\n\n\tmutex_lock(&local->mtx);\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t \n\t\tcancel_delayed_work(&sdata->deflink.dfs_cac_timer_work);\n\n\t\tif (sdata->wdev.cac_started) {\n\t\t\tchandef = sdata->vif.bss_conf.chandef;\n\t\t\tieee80211_link_release_channel(&sdata->deflink);\n\t\t\tcfg80211_cac_event(sdata->dev,\n\t\t\t\t\t   &chandef,\n\t\t\t\t\t   NL80211_RADAR_CAC_ABORTED,\n\t\t\t\t\t   GFP_KERNEL);\n\t\t}\n\t}\n\tmutex_unlock(&local->mtx);\n}\n\nvoid ieee80211_dfs_radar_detected_work(struct wiphy *wiphy,\n\t\t\t\t       struct wiphy_work *work)\n{\n\tstruct ieee80211_local *local =\n\t\tcontainer_of(work, struct ieee80211_local, radar_detected_work);\n\tstruct cfg80211_chan_def chandef = local->hw.conf.chandef;\n\tstruct ieee80211_chanctx *ctx;\n\tint num_chanctx = 0;\n\n\tmutex_lock(&local->chanctx_mtx);\n\tlist_for_each_entry(ctx, &local->chanctx_list, list) {\n\t\tif (ctx->replace_state == IEEE80211_CHANCTX_REPLACES_OTHER)\n\t\t\tcontinue;\n\n\t\tnum_chanctx++;\n\t\tchandef = ctx->conf.def;\n\t}\n\tmutex_unlock(&local->chanctx_mtx);\n\n\tieee80211_dfs_cac_cancel(local);\n\n\tif (num_chanctx > 1)\n\t\t \n\t\tWARN_ON(1);\n\telse\n\t\tcfg80211_radar_event(local->hw.wiphy, &chandef, GFP_KERNEL);\n}\n\nvoid ieee80211_radar_detected(struct ieee80211_hw *hw)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\ttrace_api_radar_detected(local);\n\n\twiphy_work_queue(hw->wiphy, &local->radar_detected_work);\n}\nEXPORT_SYMBOL(ieee80211_radar_detected);\n\nieee80211_conn_flags_t ieee80211_chandef_downgrade(struct cfg80211_chan_def *c)\n{\n\tieee80211_conn_flags_t ret;\n\tint tmp;\n\n\tswitch (c->width) {\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n\t\tret = IEEE80211_CONN_DISABLE_HT | IEEE80211_CONN_DISABLE_VHT;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tc->width = NL80211_CHAN_WIDTH_20;\n\t\tc->center_freq1 = c->chan->center_freq;\n\t\tret = IEEE80211_CONN_DISABLE_40MHZ |\n\t\t      IEEE80211_CONN_DISABLE_VHT;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\ttmp = (30 + c->chan->center_freq - c->center_freq1)/20;\n\t\t \n\t\ttmp /= 2;\n\t\t \n\t\tc->center_freq1 = c->center_freq1 - 20 + 40 * tmp;\n\t\tc->width = NL80211_CHAN_WIDTH_40;\n\t\tret = IEEE80211_CONN_DISABLE_VHT;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\tc->center_freq2 = 0;\n\t\tc->width = NL80211_CHAN_WIDTH_80;\n\t\tret = IEEE80211_CONN_DISABLE_80P80MHZ |\n\t\t      IEEE80211_CONN_DISABLE_160MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\t \n\t\ttmp = (70 + c->chan->center_freq - c->center_freq1)/20;\n\t\t \n\t\ttmp /= 4;\n\t\tc->center_freq1 = c->center_freq1 - 40 + 80 * tmp;\n\t\tc->width = NL80211_CHAN_WIDTH_80;\n\t\tret = IEEE80211_CONN_DISABLE_80P80MHZ |\n\t\t      IEEE80211_CONN_DISABLE_160MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\t \n\t\ttmp = (150 + c->chan->center_freq - c->center_freq1) / 20;\n\t\t \n\t\ttmp /= 8;\n\t\tc->center_freq1 = c->center_freq1 - 80 + 160 * tmp;\n\t\tc->width = NL80211_CHAN_WIDTH_160;\n\t\tret = IEEE80211_CONN_DISABLE_320MHZ;\n\t\tbreak;\n\tdefault:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tWARN_ON_ONCE(1);\n\t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n\t\tret = IEEE80211_CONN_DISABLE_HT | IEEE80211_CONN_DISABLE_VHT;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_1:\n\tcase NL80211_CHAN_WIDTH_2:\n\tcase NL80211_CHAN_WIDTH_4:\n\tcase NL80211_CHAN_WIDTH_8:\n\tcase NL80211_CHAN_WIDTH_16:\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\t\tWARN_ON_ONCE(1);\n\t\t \n\t\tret = IEEE80211_CONN_DISABLE_HT | IEEE80211_CONN_DISABLE_VHT;\n\t\tbreak;\n\t}\n\n\tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n\n\treturn ret;\n}\n\n \nbool ieee80211_smps_is_restrictive(enum ieee80211_smps_mode smps_mode_old,\n\t\t\t\t   enum ieee80211_smps_mode smps_mode_new)\n{\n\tif (WARN_ON_ONCE(smps_mode_old == IEEE80211_SMPS_AUTOMATIC ||\n\t\t\t smps_mode_new == IEEE80211_SMPS_AUTOMATIC))\n\t\treturn false;\n\n\tswitch (smps_mode_old) {\n\tcase IEEE80211_SMPS_STATIC:\n\t\treturn false;\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\treturn smps_mode_new == IEEE80211_SMPS_STATIC;\n\tcase IEEE80211_SMPS_OFF:\n\t\treturn smps_mode_new != IEEE80211_SMPS_OFF;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\treturn false;\n}\n\nint ieee80211_send_action_csa(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct cfg80211_csa_settings *csa_settings)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct ieee80211_local *local = sdata->local;\n\tint freq;\n\tint hdr_len = offsetofend(struct ieee80211_mgmt,\n\t\t\t\t  u.action.u.chan_switch);\n\tu8 *pos;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tskb = dev_alloc_skb(local->tx_headroom + hdr_len +\n\t\t\t    5 +  \n\t\t\t    3 +  \n\t\t\t    5 +  \n\t\t\t    8);  \n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, local->tx_headroom);\n\tmgmt = skb_put_zero(skb, hdr_len);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\n\teth_broadcast_addr(mgmt->da);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\n\t} else {\n\t\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\t\tmemcpy(mgmt->bssid, ifibss->bssid, ETH_ALEN);\n\t}\n\tmgmt->u.action.category = WLAN_CATEGORY_SPECTRUM_MGMT;\n\tmgmt->u.action.u.chan_switch.action_code = WLAN_ACTION_SPCT_CHL_SWITCH;\n\tpos = skb_put(skb, 5);\n\t*pos++ = WLAN_EID_CHANNEL_SWITCH;\t\t\t \n\t*pos++ = 3;\t\t\t\t\t\t \n\t*pos++ = csa_settings->block_tx ? 1 : 0;\t\t \n\tfreq = csa_settings->chandef.chan->center_freq;\n\t*pos++ = ieee80211_frequency_to_channel(freq);\t\t \n\t*pos++ = csa_settings->count;\t\t\t\t \n\n\tif (csa_settings->chandef.width == NL80211_CHAN_WIDTH_40) {\n\t\tenum nl80211_channel_type ch_type;\n\n\t\tskb_put(skb, 3);\n\t\t*pos++ = WLAN_EID_SECONDARY_CHANNEL_OFFSET;\t \n\t\t*pos++ = 1;\t\t\t\t\t \n\t\tch_type = cfg80211_get_chandef_type(&csa_settings->chandef);\n\t\tif (ch_type == NL80211_CHAN_HT40PLUS)\n\t\t\t*pos++ = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\n\t\telse\n\t\t\t*pos++ = IEEE80211_HT_PARAM_CHA_SEC_BELOW;\n\t}\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\t\tskb_put(skb, 8);\n\t\t*pos++ = WLAN_EID_CHAN_SWITCH_PARAM;\t\t \n\t\t*pos++ = 6;\t\t\t\t\t \n\t\t*pos++ = sdata->u.mesh.mshcfg.dot11MeshTTL;\t \n\t\t*pos = 0x00;\t \n\t\t*pos |= WLAN_EID_CHAN_SWITCH_PARAM_INITIATOR;\n\t\t*pos++ |= csa_settings->block_tx ?\n\t\t\t  WLAN_EID_CHAN_SWITCH_PARAM_TX_RESTRICT : 0x00;\n\t\tput_unaligned_le16(WLAN_REASON_MESH_CHAN, pos);  \n\t\tpos += 2;\n\t\tput_unaligned_le16(ifmsh->pre_value, pos); \n\t\tpos += 2;\n\t}\n\n\tif (csa_settings->chandef.width == NL80211_CHAN_WIDTH_80 ||\n\t    csa_settings->chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n\t    csa_settings->chandef.width == NL80211_CHAN_WIDTH_160) {\n\t\tskb_put(skb, 5);\n\t\tieee80211_ie_build_wide_bw_cs(pos, &csa_settings->chandef);\n\t}\n\n\tieee80211_tx_skb(sdata, skb);\n\treturn 0;\n}\n\nstatic bool\nieee80211_extend_noa_desc(struct ieee80211_noa_data *data, u32 tsf, int i)\n{\n\ts32 end = data->desc[i].start + data->desc[i].duration - (tsf + 1);\n\tint skip;\n\n\tif (end > 0)\n\t\treturn false;\n\n\t \n\tif (data->count[i] == 1)\n\t\treturn false;\n\n\tif (data->desc[i].interval == 0)\n\t\treturn false;\n\n\t \n\tskip = DIV_ROUND_UP(-end, data->desc[i].interval);\n\tif (data->count[i] < 255) {\n\t\tif (data->count[i] <= skip) {\n\t\t\tdata->count[i] = 0;\n\t\t\treturn false;\n\t\t}\n\n\t\tdata->count[i] -= skip;\n\t}\n\n\tdata->desc[i].start += skip * data->desc[i].interval;\n\n\treturn true;\n}\n\nstatic bool\nieee80211_extend_absent_time(struct ieee80211_noa_data *data, u32 tsf,\n\t\t\t     s32 *offset)\n{\n\tbool ret = false;\n\tint i;\n\n\tfor (i = 0; i < IEEE80211_P2P_NOA_DESC_MAX; i++) {\n\t\ts32 cur;\n\n\t\tif (!data->count[i])\n\t\t\tcontinue;\n\n\t\tif (ieee80211_extend_noa_desc(data, tsf + *offset, i))\n\t\t\tret = true;\n\n\t\tcur = data->desc[i].start - tsf;\n\t\tif (cur > *offset)\n\t\t\tcontinue;\n\n\t\tcur = data->desc[i].start + data->desc[i].duration - tsf;\n\t\tif (cur > *offset)\n\t\t\t*offset = cur;\n\t}\n\n\treturn ret;\n}\n\nstatic u32\nieee80211_get_noa_absent_time(struct ieee80211_noa_data *data, u32 tsf)\n{\n\ts32 offset = 0;\n\tint tries = 0;\n\t \n\tint max_tries = 5;\n\n\tieee80211_extend_absent_time(data, tsf, &offset);\n\tdo {\n\t\tif (!ieee80211_extend_absent_time(data, tsf, &offset))\n\t\t\tbreak;\n\n\t\ttries++;\n\t} while (tries < max_tries);\n\n\treturn offset;\n}\n\nvoid ieee80211_update_p2p_noa(struct ieee80211_noa_data *data, u32 tsf)\n{\n\tu32 next_offset = BIT(31) - 1;\n\tint i;\n\n\tdata->absent = 0;\n\tdata->has_next_tsf = false;\n\tfor (i = 0; i < IEEE80211_P2P_NOA_DESC_MAX; i++) {\n\t\ts32 start;\n\n\t\tif (!data->count[i])\n\t\t\tcontinue;\n\n\t\tieee80211_extend_noa_desc(data, tsf, i);\n\t\tstart = data->desc[i].start - tsf;\n\t\tif (start <= 0)\n\t\t\tdata->absent |= BIT(i);\n\n\t\tif (next_offset > start)\n\t\t\tnext_offset = start;\n\n\t\tdata->has_next_tsf = true;\n\t}\n\n\tif (data->absent)\n\t\tnext_offset = ieee80211_get_noa_absent_time(data, tsf);\n\n\tdata->next_tsf = tsf + next_offset;\n}\nEXPORT_SYMBOL(ieee80211_update_p2p_noa);\n\nint ieee80211_parse_p2p_noa(const struct ieee80211_p2p_noa_attr *attr,\n\t\t\t    struct ieee80211_noa_data *data, u32 tsf)\n{\n\tint ret = 0;\n\tint i;\n\n\tmemset(data, 0, sizeof(*data));\n\n\tfor (i = 0; i < IEEE80211_P2P_NOA_DESC_MAX; i++) {\n\t\tconst struct ieee80211_p2p_noa_desc *desc = &attr->desc[i];\n\n\t\tif (!desc->count || !desc->duration)\n\t\t\tcontinue;\n\n\t\tdata->count[i] = desc->count;\n\t\tdata->desc[i].start = le32_to_cpu(desc->start_time);\n\t\tdata->desc[i].duration = le32_to_cpu(desc->duration);\n\t\tdata->desc[i].interval = le32_to_cpu(desc->interval);\n\n\t\tif (data->count[i] > 1 &&\n\t\t    data->desc[i].interval < data->desc[i].duration)\n\t\t\tcontinue;\n\n\t\tieee80211_extend_noa_desc(data, tsf, i);\n\t\tret++;\n\t}\n\n\tif (ret)\n\t\tieee80211_update_p2p_noa(data, tsf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_parse_p2p_noa);\n\nvoid ieee80211_recalc_dtim(struct ieee80211_local *local,\n\t\t\t   struct ieee80211_sub_if_data *sdata)\n{\n\tu64 tsf = drv_get_tsf(local, sdata);\n\tu64 dtim_count = 0;\n\tu16 beacon_int = sdata->vif.bss_conf.beacon_int * 1024;\n\tu8 dtim_period = sdata->vif.bss_conf.dtim_period;\n\tstruct ps_data *ps;\n\tu8 bcns_from_dtim;\n\n\tif (tsf == -1ULL || !beacon_int || !dtim_period)\n\t\treturn;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (!sdata->bss)\n\t\t\treturn;\n\n\t\tps = &sdata->bss->ps;\n\t} else if (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\tps = &sdata->u.mesh.ps;\n\t} else {\n\t\treturn;\n\t}\n\n\t \n\tdo_div(tsf, beacon_int);\n\tbcns_from_dtim = do_div(tsf, dtim_period);\n\t \n\tif (!bcns_from_dtim)\n\t\tdtim_count = 0;\n\telse\n\t\tdtim_count = dtim_period - bcns_from_dtim;\n\n\tps->dtim_count = dtim_count;\n}\n\nstatic u8 ieee80211_chanctx_radar_detect(struct ieee80211_local *local,\n\t\t\t\t\t struct ieee80211_chanctx *ctx)\n{\n\tstruct ieee80211_link_data *link;\n\tu8 radar_detect = 0;\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tif (WARN_ON(ctx->replace_state == IEEE80211_CHANCTX_WILL_BE_REPLACED))\n\t\treturn 0;\n\n\tlist_for_each_entry(link, &ctx->reserved_links, reserved_chanctx_list)\n\t\tif (link->reserved_radar_required)\n\t\t\tradar_detect |= BIT(link->reserved_chandef.width);\n\n\t \n\tWARN_ON(ctx->replace_state == IEEE80211_CHANCTX_REPLACES_OTHER &&\n\t\t!list_empty(&ctx->assigned_links));\n\n\tlist_for_each_entry(link, &ctx->assigned_links, assigned_chanctx_list) {\n\t\tif (!link->radar_required)\n\t\t\tcontinue;\n\n\t\tradar_detect |=\n\t\t\tBIT(link->conf->chandef.width);\n\t}\n\n\treturn radar_detect;\n}\n\nint ieee80211_check_combinations(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t const struct cfg80211_chan_def *chandef,\n\t\t\t\t enum ieee80211_chanctx_mode chanmode,\n\t\t\t\t u8 radar_detect)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *sdata_iter;\n\tenum nl80211_iftype iftype = sdata->wdev.iftype;\n\tstruct ieee80211_chanctx *ctx;\n\tint total = 1;\n\tstruct iface_combination_params params = {\n\t\t.radar_detect = radar_detect,\n\t};\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tif (WARN_ON(hweight32(radar_detect) > 1))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(chandef && chanmode == IEEE80211_CHANCTX_SHARED &&\n\t\t    !chandef->chan))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(iftype >= NUM_NL80211_IFTYPES))\n\t\treturn -EINVAL;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sdata->vif.type == NL80211_IFTYPE_MESH_POINT) {\n\t\t \n\t\tparams.new_beacon_int = sdata->vif.bss_conf.beacon_int;\n\t}\n\n\t \n\tif (cfg80211_iftype_allowed(local->hw.wiphy, iftype, 0, 1)) {\n\t\tif (radar_detect)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tif (chandef)\n\t\tparams.num_different_channels = 1;\n\n\tif (iftype != NL80211_IFTYPE_UNSPECIFIED)\n\t\tparams.iftype_num[iftype] = 1;\n\n\tlist_for_each_entry(ctx, &local->chanctx_list, list) {\n\t\tif (ctx->replace_state == IEEE80211_CHANCTX_WILL_BE_REPLACED)\n\t\t\tcontinue;\n\t\tparams.radar_detect |=\n\t\t\tieee80211_chanctx_radar_detect(local, ctx);\n\t\tif (ctx->mode == IEEE80211_CHANCTX_EXCLUSIVE) {\n\t\t\tparams.num_different_channels++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (chandef && chanmode == IEEE80211_CHANCTX_SHARED &&\n\t\t    cfg80211_chandef_compatible(chandef,\n\t\t\t\t\t\t&ctx->conf.def))\n\t\t\tcontinue;\n\t\tparams.num_different_channels++;\n\t}\n\n\tlist_for_each_entry_rcu(sdata_iter, &local->interfaces, list) {\n\t\tstruct wireless_dev *wdev_iter;\n\n\t\twdev_iter = &sdata_iter->wdev;\n\n\t\tif (sdata_iter == sdata ||\n\t\t    !ieee80211_sdata_running(sdata_iter) ||\n\t\t    cfg80211_iftype_allowed(local->hw.wiphy,\n\t\t\t\t\t    wdev_iter->iftype, 0, 1))\n\t\t\tcontinue;\n\n\t\tparams.iftype_num[wdev_iter->iftype]++;\n\t\ttotal++;\n\t}\n\n\tif (total == 1 && !params.radar_detect)\n\t\treturn 0;\n\n\treturn cfg80211_check_combinations(local->hw.wiphy, &params);\n}\n\nstatic void\nieee80211_iter_max_chans(const struct ieee80211_iface_combination *c,\n\t\t\t void *data)\n{\n\tu32 *max_num_different_channels = data;\n\n\t*max_num_different_channels = max(*max_num_different_channels,\n\t\t\t\t\t  c->num_different_channels);\n}\n\nint ieee80211_max_num_channels(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_chanctx *ctx;\n\tu32 max_num_different_channels = 1;\n\tint err;\n\tstruct iface_combination_params params = {0};\n\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\tlist_for_each_entry(ctx, &local->chanctx_list, list) {\n\t\tif (ctx->replace_state == IEEE80211_CHANCTX_WILL_BE_REPLACED)\n\t\t\tcontinue;\n\n\t\tparams.num_different_channels++;\n\n\t\tparams.radar_detect |=\n\t\t\tieee80211_chanctx_radar_detect(local, ctx);\n\t}\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list)\n\t\tparams.iftype_num[sdata->wdev.iftype]++;\n\n\terr = cfg80211_iter_combinations(local->hw.wiphy, &params,\n\t\t\t\t\t ieee80211_iter_max_chans,\n\t\t\t\t\t &max_num_different_channels);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn max_num_different_channels;\n}\n\nvoid ieee80211_add_s1g_capab_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct ieee80211_sta_s1g_cap *caps,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_s1g_cap s1g_capab;\n\tu8 *pos;\n\tint i;\n\n\tif (WARN_ON(sdata->vif.type != NL80211_IFTYPE_STATION))\n\t\treturn;\n\n\tif (!caps->s1g)\n\t\treturn;\n\n\tmemcpy(s1g_capab.capab_info, caps->cap, sizeof(caps->cap));\n\tmemcpy(s1g_capab.supp_mcs_nss, caps->nss_mcs, sizeof(caps->nss_mcs));\n\n\t \n\tfor (i = 0; i < sizeof(ifmgd->s1g_capa.capab_info); i++) {\n\t\tu8 mask = ifmgd->s1g_capa_mask.capab_info[i];\n\n\t\ts1g_capab.capab_info[i] &= ~mask;\n\t\ts1g_capab.capab_info[i] |= ifmgd->s1g_capa.capab_info[i] & mask;\n\t}\n\n\t \n\tfor (i = 0; i < sizeof(ifmgd->s1g_capa.supp_mcs_nss); i++) {\n\t\tu8 mask = ifmgd->s1g_capa_mask.supp_mcs_nss[i];\n\n\t\ts1g_capab.supp_mcs_nss[i] &= ~mask;\n\t\ts1g_capab.supp_mcs_nss[i] |=\n\t\t\tifmgd->s1g_capa.supp_mcs_nss[i] & mask;\n\t}\n\n\tpos = skb_put(skb, 2 + sizeof(s1g_capab));\n\t*pos++ = WLAN_EID_S1G_CAPABILITIES;\n\t*pos++ = sizeof(s1g_capab);\n\n\tmemcpy(pos, &s1g_capab, sizeof(s1g_capab));\n}\n\nvoid ieee80211_add_aid_request_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tu8 *pos = skb_put(skb, 3);\n\n\t*pos++ = WLAN_EID_AID_REQUEST;\n\t*pos++ = 1;\n\t*pos++ = 0;\n}\n\nu8 *ieee80211_add_wmm_info_ie(u8 *buf, u8 qosinfo)\n{\n\t*buf++ = WLAN_EID_VENDOR_SPECIFIC;\n\t*buf++ = 7;  \n\t*buf++ = 0x00;  \n\t*buf++ = 0x50;\n\t*buf++ = 0xf2;\n\t*buf++ = 2;  \n\t*buf++ = 0;  \n\t*buf++ = 1;  \n\t*buf++ = qosinfo;  \n\n\treturn buf;\n}\n\nvoid ieee80211_txq_get_depth(struct ieee80211_txq *txq,\n\t\t\t     unsigned long *frame_cnt,\n\t\t\t     unsigned long *byte_cnt)\n{\n\tstruct txq_info *txqi = to_txq_info(txq);\n\tu32 frag_cnt = 0, frag_bytes = 0;\n\tstruct sk_buff *skb;\n\n\tskb_queue_walk(&txqi->frags, skb) {\n\t\tfrag_cnt++;\n\t\tfrag_bytes += skb->len;\n\t}\n\n\tif (frame_cnt)\n\t\t*frame_cnt = txqi->tin.backlog_packets + frag_cnt;\n\n\tif (byte_cnt)\n\t\t*byte_cnt = txqi->tin.backlog_bytes + frag_bytes;\n}\nEXPORT_SYMBOL(ieee80211_txq_get_depth);\n\nconst u8 ieee80211_ac_to_qos_mask[IEEE80211_NUM_ACS] = {\n\tIEEE80211_WMM_IE_STA_QOSINFO_AC_VO,\n\tIEEE80211_WMM_IE_STA_QOSINFO_AC_VI,\n\tIEEE80211_WMM_IE_STA_QOSINFO_AC_BE,\n\tIEEE80211_WMM_IE_STA_QOSINFO_AC_BK\n};\n\nu16 ieee80211_encode_usf(int listen_interval)\n{\n\tstatic const int listen_int_usf[] = { 1, 10, 1000, 10000 };\n\tu16 ui, usf = 0;\n\n\t \n\twhile (usf < IEEE80211_MAX_USF) {\n\t\tif (listen_interval % listen_int_usf[usf + 1])\n\t\t\tbreak;\n\t\tusf += 1;\n\t}\n\tui = listen_interval / listen_int_usf[usf];\n\n\t \n\tWARN_ON_ONCE(ui > IEEE80211_MAX_UI);\n\tlisten_interval = FIELD_PREP(LISTEN_INT_USF, usf) |\n\t\t\t  FIELD_PREP(LISTEN_INT_UI, ui);\n\n\treturn (u16) listen_interval;\n}\n\nu8 ieee80211_ie_len_eht_cap(struct ieee80211_sub_if_data *sdata, u8 iftype)\n{\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tconst struct ieee80211_sta_eht_cap *eht_cap;\n\tstruct ieee80211_supported_band *sband;\n\tbool is_ap;\n\tu8 n;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn 0;\n\n\the_cap = ieee80211_get_he_iftype_cap(sband, iftype);\n\teht_cap = ieee80211_get_eht_iftype_cap(sband, iftype);\n\tif (!he_cap || !eht_cap)\n\t\treturn 0;\n\n\tis_ap = iftype == NL80211_IFTYPE_AP ||\n\t\tiftype == NL80211_IFTYPE_P2P_GO;\n\n\tn = ieee80211_eht_mcs_nss_size(&he_cap->he_cap_elem,\n\t\t\t\t       &eht_cap->eht_cap_elem,\n\t\t\t\t       is_ap);\n\treturn 2 + 1 +\n\t       sizeof(eht_cap->eht_cap_elem) + n +\n\t       ieee80211_eht_ppe_size(eht_cap->eht_ppe_thres[0],\n\t\t\t\t      eht_cap->eht_cap_elem.phy_cap_info);\n\treturn 0;\n}\n\nu8 *ieee80211_ie_build_eht_cap(u8 *pos,\n\t\t\t       const struct ieee80211_sta_he_cap *he_cap,\n\t\t\t       const struct ieee80211_sta_eht_cap *eht_cap,\n\t\t\t       u8 *end,\n\t\t\t       bool for_ap)\n{\n\tu8 mcs_nss_len, ppet_len;\n\tu8 ie_len;\n\tu8 *orig_pos = pos;\n\n\t \n\tif (!he_cap || !eht_cap)\n\t\treturn orig_pos;\n\n\tmcs_nss_len = ieee80211_eht_mcs_nss_size(&he_cap->he_cap_elem,\n\t\t\t\t\t\t &eht_cap->eht_cap_elem,\n\t\t\t\t\t\t for_ap);\n\tppet_len = ieee80211_eht_ppe_size(eht_cap->eht_ppe_thres[0],\n\t\t\t\t\t  eht_cap->eht_cap_elem.phy_cap_info);\n\n\tie_len = 2 + 1 + sizeof(eht_cap->eht_cap_elem) + mcs_nss_len + ppet_len;\n\tif ((end - pos) < ie_len)\n\t\treturn orig_pos;\n\n\t*pos++ = WLAN_EID_EXTENSION;\n\t*pos++ = ie_len - 2;\n\t*pos++ = WLAN_EID_EXT_EHT_CAPABILITY;\n\n\t \n\tmemcpy(pos, &eht_cap->eht_cap_elem, sizeof(eht_cap->eht_cap_elem));\n\tpos += sizeof(eht_cap->eht_cap_elem);\n\n\tmemcpy(pos, &eht_cap->eht_mcs_nss_supp, mcs_nss_len);\n\tpos += mcs_nss_len;\n\n\tif (ppet_len) {\n\t\tmemcpy(pos, &eht_cap->eht_ppe_thres, ppet_len);\n\t\tpos += ppet_len;\n\t}\n\n\treturn pos;\n}\n\nvoid ieee80211_fragment_element(struct sk_buff *skb, u8 *len_pos, u8 frag_id)\n{\n\tunsigned int elem_len;\n\n\tif (!len_pos)\n\t\treturn;\n\n\telem_len = skb->data + skb->len - len_pos - 1;\n\n\twhile (elem_len > 255) {\n\t\t \n\t\t*len_pos = 255;\n\t\t \n\t\telem_len -= 255;\n\t\t \n\t\tskb_put(skb, 2);\n\t\t \n\t\tmemmove(len_pos + 255 + 3, len_pos + 255 + 1, elem_len);\n\t\t \n\t\tlen_pos += 255 + 1;\n\t\t*len_pos = frag_id;\n\t\t \n\t\tlen_pos++;\n\t}\n\n\t*len_pos = elem_len;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}