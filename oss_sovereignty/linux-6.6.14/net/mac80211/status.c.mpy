{
  "module_name": "status.c",
  "hash_id": "c7e1b676d15456cac7989e1ae3dca970f7c571fc2d75d96039d969fcbc5ac627",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/status.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/etherdevice.h>\n#include <net/mac80211.h>\n#include <asm/unaligned.h>\n#include \"ieee80211_i.h\"\n#include \"rate.h\"\n#include \"mesh.h\"\n#include \"led.h\"\n#include \"wme.h\"\n\n\nvoid ieee80211_tx_status_irqsafe(struct ieee80211_hw *hw,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tint tmp;\n\n\tskb->pkt_type = IEEE80211_TX_STATUS_MSG;\n\tskb_queue_tail(info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS ?\n\t\t       &local->skb_queue : &local->skb_queue_unreliable, skb);\n\ttmp = skb_queue_len(&local->skb_queue) +\n\t\tskb_queue_len(&local->skb_queue_unreliable);\n\twhile (tmp > IEEE80211_IRQSAFE_QUEUE_LIMIT &&\n\t       (skb = skb_dequeue(&local->skb_queue_unreliable))) {\n\t\tieee80211_free_txskb(hw, skb);\n\t\ttmp--;\n\t\tI802_DEBUG_INC(local->tx_status_drop);\n\t}\n\ttasklet_schedule(&local->tasklet);\n}\nEXPORT_SYMBOL(ieee80211_tx_status_irqsafe);\n\nstatic void ieee80211_handle_filtered_frame(struct ieee80211_local *local,\n\t\t\t\t\t    struct sta_info *sta,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tint ac;\n\n\tif (info->flags & (IEEE80211_TX_CTL_NO_PS_BUFFER |\n\t\t\t   IEEE80211_TX_CTL_AMPDU |\n\t\t\t   IEEE80211_TX_CTL_HW_80211_ENCAP)) {\n\t\tieee80211_free_txskb(&local->hw, skb);\n\t\treturn;\n\t}\n\n\t \n\tmemset(&info->control, 0, sizeof(info->control));\n\n\tinfo->control.jiffies = jiffies;\n\tinfo->control.vif = &sta->sdata->vif;\n\tinfo->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\tinfo->flags |= IEEE80211_TX_INTFL_RETRANSMISSION;\n\tinfo->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;\n\n\tsta->deflink.status_stats.filtered++;\n\n\t \n\tif (hdr->frame_control & cpu_to_le16(IEEE80211_FCTL_MOREDATA))\n\t\thdr->frame_control &= ~cpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tu8 *p = ieee80211_get_qos_ctl(hdr);\n\t\tint tid = *p & IEEE80211_QOS_CTL_TID_MASK;\n\n\t\t \n\t\tif (*p & IEEE80211_QOS_CTL_EOSP)\n\t\t\t*p &= ~IEEE80211_QOS_CTL_EOSP;\n\t\tac = ieee80211_ac_from_tid(tid);\n\t} else {\n\t\tac = IEEE80211_AC_BE;\n\t}\n\n\t \n\tset_sta_flag(sta, WLAN_STA_CLEAR_PS_FILT);\n\tieee80211_clear_fast_xmit(sta);\n\n\t \n\tif (test_sta_flag(sta, WLAN_STA_PS_STA) &&\n\t    skb_queue_len(&sta->tx_filtered[ac]) < STA_MAX_TX_BUFFER) {\n\t\tskb_queue_tail(&sta->tx_filtered[ac], skb);\n\t\tsta_info_recalc_tim(sta);\n\n\t\tif (!timer_pending(&local->sta_cleanup))\n\t\t\tmod_timer(&local->sta_cleanup,\n\t\t\t\t  round_jiffies(jiffies +\n\t\t\t\t\t\tSTA_INFO_CLEANUP_INTERVAL));\n\t\treturn;\n\t}\n\n\tif (!test_sta_flag(sta, WLAN_STA_PS_STA) &&\n\t    !(info->flags & IEEE80211_TX_INTFL_RETRIED)) {\n\t\t \n\t\tinfo->flags |= IEEE80211_TX_INTFL_RETRIED;\n\t\tieee80211_add_pending_skb(local, skb);\n\t\treturn;\n\t}\n\n\tps_dbg_ratelimited(sta->sdata,\n\t\t\t   \"dropped TX filtered frame, queue_len=%d PS=%d @%lu\\n\",\n\t\t\t   skb_queue_len(&sta->tx_filtered[ac]),\n\t\t\t   !!test_sta_flag(sta, WLAN_STA_PS_STA), jiffies);\n\tieee80211_free_txskb(&local->hw, skb);\n}\n\nstatic void ieee80211_check_pending_bar(struct sta_info *sta, u8 *addr, u8 tid)\n{\n\tstruct tid_ampdu_tx *tid_tx;\n\n\ttid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\n\tif (!tid_tx || !tid_tx->bar_pending)\n\t\treturn;\n\n\ttid_tx->bar_pending = false;\n\tieee80211_send_bar(&sta->sdata->vif, addr, tid, tid_tx->failed_bar_ssn);\n}\n\nstatic void ieee80211_frame_acked(struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *) skb->data;\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\n\tif (ieee80211_is_data_qos(mgmt->frame_control)) {\n\t\tstruct ieee80211_hdr *hdr = (void *) skb->data;\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\tu16 tid = qc[0] & 0xf;\n\n\t\tieee80211_check_pending_bar(sta, hdr->addr1, tid);\n\t}\n\n\tif (ieee80211_is_action(mgmt->frame_control) &&\n\t    !ieee80211_has_protected(mgmt->frame_control) &&\n\t    mgmt->u.action.category == WLAN_CATEGORY_HT &&\n\t    mgmt->u.action.u.ht_smps.action == WLAN_HT_ACTION_SMPS &&\n\t    ieee80211_sdata_running(sdata)) {\n\t\tenum ieee80211_smps_mode smps_mode;\n\n\t\tswitch (mgmt->u.action.u.ht_smps.smps_control) {\n\t\tcase WLAN_HT_SMPS_CONTROL_DYNAMIC:\n\t\t\tsmps_mode = IEEE80211_SMPS_DYNAMIC;\n\t\t\tbreak;\n\t\tcase WLAN_HT_SMPS_CONTROL_STATIC:\n\t\t\tsmps_mode = IEEE80211_SMPS_STATIC;\n\t\t\tbreak;\n\t\tcase WLAN_HT_SMPS_CONTROL_DISABLED:\n\t\tdefault:  \n\t\t\tsmps_mode = IEEE80211_SMPS_OFF;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION) {\n\t\t\t \n\t\t\tsdata->deflink.smps_mode = smps_mode;\n\t\t\tieee80211_queue_work(&local->hw, &sdata->recalc_smps);\n\t\t}\n\t}\n}\n\nstatic void ieee80211_set_bar_pending(struct sta_info *sta, u8 tid, u16 ssn)\n{\n\tstruct tid_ampdu_tx *tid_tx;\n\n\ttid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\n\tif (!tid_tx)\n\t\treturn;\n\n\ttid_tx->failed_bar_ssn = ssn;\n\ttid_tx->bar_pending = true;\n}\n\nstatic int ieee80211_tx_radiotap_len(struct ieee80211_tx_info *info,\n\t\t\t\t     struct ieee80211_tx_status *status)\n{\n\tstruct ieee80211_rate_status *status_rate = NULL;\n\tint len = sizeof(struct ieee80211_radiotap_header);\n\n\tif (status && status->n_rates)\n\t\tstatus_rate = &status->rates[status->n_rates - 1];\n\n\t \n\tif (status_rate && !(status_rate->rate_idx.flags &\n\t\t\t\t\t\t(RATE_INFO_FLAGS_MCS |\n\t\t\t\t\t\t RATE_INFO_FLAGS_DMG |\n\t\t\t\t\t\t RATE_INFO_FLAGS_EDMG |\n\t\t\t\t\t\t RATE_INFO_FLAGS_VHT_MCS |\n\t\t\t\t\t\t RATE_INFO_FLAGS_HE_MCS)))\n\t\tlen += 2;\n\telse if (info->status.rates[0].idx >= 0 &&\n\t\t !(info->status.rates[0].flags &\n\t\t   (IEEE80211_TX_RC_MCS | IEEE80211_TX_RC_VHT_MCS)))\n\t\tlen += 2;\n\n\t \n\tlen += 2;\n\n\t \n\tlen += 1;\n\n\t \n\tif (status_rate) {\n\t\tif (status_rate->rate_idx.flags & RATE_INFO_FLAGS_MCS)\n\t\t\tlen += 3;\n\t\telse if (status_rate->rate_idx.flags & RATE_INFO_FLAGS_VHT_MCS)\n\t\t\tlen = ALIGN(len, 2) + 12;\n\t\telse if (status_rate->rate_idx.flags & RATE_INFO_FLAGS_HE_MCS)\n\t\t\tlen = ALIGN(len, 2) + 12;\n\t} else if (info->status.rates[0].idx >= 0) {\n\t\tif (info->status.rates[0].flags & IEEE80211_TX_RC_MCS)\n\t\t\tlen += 3;\n\t\telse if (info->status.rates[0].flags & IEEE80211_TX_RC_VHT_MCS)\n\t\t\tlen = ALIGN(len, 2) + 12;\n\t}\n\n\treturn len;\n}\n\nstatic void\nieee80211_add_tx_radiotap_header(struct ieee80211_local *local,\n\t\t\t\t struct sk_buff *skb, int retry_count,\n\t\t\t\t int rtap_len, int shift,\n\t\t\t\t struct ieee80211_tx_status *status)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_radiotap_header *rthdr;\n\tstruct ieee80211_rate_status *status_rate = NULL;\n\tunsigned char *pos;\n\tu16 legacy_rate = 0;\n\tu16 txflags;\n\n\tif (status && status->n_rates)\n\t\tstatus_rate = &status->rates[status->n_rates - 1];\n\n\trthdr = skb_push(skb, rtap_len);\n\n\tmemset(rthdr, 0, rtap_len);\n\trthdr->it_len = cpu_to_le16(rtap_len);\n\trthdr->it_present =\n\t\tcpu_to_le32(BIT(IEEE80211_RADIOTAP_TX_FLAGS) |\n\t\t\t    BIT(IEEE80211_RADIOTAP_DATA_RETRIES));\n\tpos = (unsigned char *)(rthdr + 1);\n\n\t \n\n\t \n\n\tif (status_rate) {\n\t\tif (!(status_rate->rate_idx.flags &\n\t\t\t\t\t\t(RATE_INFO_FLAGS_MCS |\n\t\t\t\t\t\t RATE_INFO_FLAGS_DMG |\n\t\t\t\t\t\t RATE_INFO_FLAGS_EDMG |\n\t\t\t\t\t\t RATE_INFO_FLAGS_VHT_MCS |\n\t\t\t\t\t\t RATE_INFO_FLAGS_HE_MCS)))\n\t\t\tlegacy_rate = status_rate->rate_idx.legacy;\n\t} else if (info->status.rates[0].idx >= 0 &&\n\t\t !(info->status.rates[0].flags & (IEEE80211_TX_RC_MCS |\n\t\t\t\t\t\t  IEEE80211_TX_RC_VHT_MCS))) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = local->hw.wiphy->bands[info->band];\n\t\tlegacy_rate =\n\t\t\tsband->bitrates[info->status.rates[0].idx].bitrate;\n\t}\n\n\tif (legacy_rate) {\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_RATE));\n\t\t*pos = DIV_ROUND_UP(legacy_rate, 5 * (1 << shift));\n\t\t \n\t\tpos += 2;\n\t}\n\n\t \n\ttxflags = 0;\n\tif (!(info->flags & IEEE80211_TX_STAT_ACK) &&\n\t    !is_multicast_ether_addr(hdr->addr1))\n\t\ttxflags |= IEEE80211_RADIOTAP_F_TX_FAIL;\n\n\tif (info->status.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT)\n\t\ttxflags |= IEEE80211_RADIOTAP_F_TX_CTS;\n\tif (info->status.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS)\n\t\ttxflags |= IEEE80211_RADIOTAP_F_TX_RTS;\n\n\tput_unaligned_le16(txflags, pos);\n\tpos += 2;\n\n\t \n\t \n\t*pos = retry_count;\n\tpos++;\n\n\tif (status_rate && (status_rate->rate_idx.flags & RATE_INFO_FLAGS_MCS))\n\t{\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_MCS));\n\t\tpos[0] = IEEE80211_RADIOTAP_MCS_HAVE_MCS |\n\t\t\t IEEE80211_RADIOTAP_MCS_HAVE_GI |\n\t\t\t IEEE80211_RADIOTAP_MCS_HAVE_BW;\n\t\tif (status_rate->rate_idx.flags & RATE_INFO_FLAGS_SHORT_GI)\n\t\t\tpos[1] |= IEEE80211_RADIOTAP_MCS_SGI;\n\t\tif (status_rate->rate_idx.bw == RATE_INFO_BW_40)\n\t\t\tpos[1] |= IEEE80211_RADIOTAP_MCS_BW_40;\n\t\tpos[2] = status_rate->rate_idx.mcs;\n\t\tpos += 3;\n\t} else if (status_rate && (status_rate->rate_idx.flags &\n\t\t\t\t\tRATE_INFO_FLAGS_VHT_MCS))\n\t{\n\t\tu16 known = local->hw.radiotap_vht_details &\n\t\t\t(IEEE80211_RADIOTAP_VHT_KNOWN_GI |\n\t\t\t IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH);\n\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_VHT));\n\n\t\t \n\t\tpos = (u8 *)rthdr + ALIGN(pos - (u8 *)rthdr, 2);\n\n\t\t \n\t\tput_unaligned_le16(known, pos);\n\t\tpos += 2;\n\n\t\t \n\t\tif (status_rate->rate_idx.flags & RATE_INFO_FLAGS_SHORT_GI)\n\t\t\t*pos |= IEEE80211_RADIOTAP_VHT_FLAG_SGI;\n\t\tpos++;\n\n\t\t \n\t\tswitch (status_rate->rate_idx.bw) {\n\t\tcase RATE_INFO_BW_160:\n\t\t\t*pos = 11;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_80:\n\t\t\t*pos = 4;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_40:\n\t\t\t*pos = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*pos = 0;\n\t\t\tbreak;\n\t\t}\n\t\tpos++;\n\n\t\t \n\t\t*pos = (status_rate->rate_idx.mcs << 4) |\n\t\t\t\tstatus_rate->rate_idx.nss;\n\t\tpos += 4;\n\n\t\t \n\t\tpos++;\n\t\t \n\t\tpos++;\n\t\t \n\t\tpos += 2;\n\t} else if (status_rate && (status_rate->rate_idx.flags &\n\t\t\t\t\tRATE_INFO_FLAGS_HE_MCS))\n\t{\n\t\tstruct ieee80211_radiotap_he *he;\n\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_HE));\n\n\t\t \n\t\tpos = (u8 *)rthdr + ALIGN(pos - (u8 *)rthdr, 2);\n\t\the = (struct ieee80211_radiotap_he *)pos;\n\n\t\the->data1 = cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA1_FORMAT_SU |\n\t\t\t\t\tIEEE80211_RADIOTAP_HE_DATA1_DATA_MCS_KNOWN |\n\t\t\t\t\tIEEE80211_RADIOTAP_HE_DATA1_DATA_DCM_KNOWN |\n\t\t\t\t\tIEEE80211_RADIOTAP_HE_DATA1_BW_RU_ALLOC_KNOWN);\n\n\t\the->data2 = cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA2_GI_KNOWN);\n\n#define HE_PREP(f, val) le16_encode_bits(val, IEEE80211_RADIOTAP_HE_##f)\n\n\t\the->data6 |= HE_PREP(DATA6_NSTS, status_rate->rate_idx.nss);\n\n#define CHECK_GI(s) \\\n\tBUILD_BUG_ON(IEEE80211_RADIOTAP_HE_DATA5_GI_##s != \\\n\t(int)NL80211_RATE_INFO_HE_GI_##s)\n\n\t\tCHECK_GI(0_8);\n\t\tCHECK_GI(1_6);\n\t\tCHECK_GI(3_2);\n\n\t\the->data3 |= HE_PREP(DATA3_DATA_MCS, status_rate->rate_idx.mcs);\n\t\the->data3 |= HE_PREP(DATA3_DATA_DCM, status_rate->rate_idx.he_dcm);\n\n\t\the->data5 |= HE_PREP(DATA5_GI, status_rate->rate_idx.he_gi);\n\n\t\tswitch (status_rate->rate_idx.bw) {\n\t\tcase RATE_INFO_BW_20:\n\t\t\the->data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t     IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_20MHZ);\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_40:\n\t\t\the->data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t     IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_40MHZ);\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_80:\n\t\t\the->data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t     IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_80MHZ);\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_160:\n\t\t\the->data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t     IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_160MHZ);\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_HE_RU:\n#define CHECK_RU_ALLOC(s) \\\n\tBUILD_BUG_ON(IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_##s##T != \\\n\tNL80211_RATE_INFO_HE_RU_ALLOC_##s + 4)\n\n\t\t\tCHECK_RU_ALLOC(26);\n\t\t\tCHECK_RU_ALLOC(52);\n\t\t\tCHECK_RU_ALLOC(106);\n\t\t\tCHECK_RU_ALLOC(242);\n\t\t\tCHECK_RU_ALLOC(484);\n\t\t\tCHECK_RU_ALLOC(996);\n\t\t\tCHECK_RU_ALLOC(2x996);\n\n\t\t\the->data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t     status_rate->rate_idx.he_ru_alloc + 4);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ONCE(1, \"Invalid SU BW %d\\n\", status_rate->rate_idx.bw);\n\t\t}\n\n\t\tpos += sizeof(struct ieee80211_radiotap_he);\n\t}\n\n\tif (status_rate || info->status.rates[0].idx < 0)\n\t\treturn;\n\n\t \n\tif (info->status.rates[0].flags & IEEE80211_TX_RC_MCS) {\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_MCS));\n\t\tpos[0] = IEEE80211_RADIOTAP_MCS_HAVE_MCS |\n\t\t\t IEEE80211_RADIOTAP_MCS_HAVE_GI |\n\t\t\t IEEE80211_RADIOTAP_MCS_HAVE_BW;\n\t\tif (info->status.rates[0].flags & IEEE80211_TX_RC_SHORT_GI)\n\t\t\tpos[1] |= IEEE80211_RADIOTAP_MCS_SGI;\n\t\tif (info->status.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\tpos[1] |= IEEE80211_RADIOTAP_MCS_BW_40;\n\t\tif (info->status.rates[0].flags & IEEE80211_TX_RC_GREEN_FIELD)\n\t\t\tpos[1] |= IEEE80211_RADIOTAP_MCS_FMT_GF;\n\t\tpos[2] = info->status.rates[0].idx;\n\t\tpos += 3;\n\t} else if (info->status.rates[0].flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\tu16 known = local->hw.radiotap_vht_details &\n\t\t\t(IEEE80211_RADIOTAP_VHT_KNOWN_GI |\n\t\t\t IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH);\n\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_VHT));\n\n\t\t \n\t\tpos = (u8 *)rthdr + ALIGN(pos - (u8 *)rthdr, 2);\n\n\t\t \n\t\tput_unaligned_le16(known, pos);\n\t\tpos += 2;\n\n\t\t \n\t\tif (info->status.rates[0].flags & IEEE80211_TX_RC_SHORT_GI)\n\t\t\t*pos |= IEEE80211_RADIOTAP_VHT_FLAG_SGI;\n\t\tpos++;\n\n\t\t \n\t\tif (info->status.rates[0].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\t\t*pos = 1;\n\t\telse if (info->status.rates[0].flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\t\t*pos = 4;\n\t\telse if (info->status.rates[0].flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\t\t*pos = 11;\n\t\telse  \n\t\t\t*pos = 0;\n\t\tpos++;\n\n\t\t \n\t\t*pos = (ieee80211_rate_get_vht_mcs(&info->status.rates[0]) << 4) |\n\t\t\tieee80211_rate_get_vht_nss(&info->status.rates[0]);\n\t\tpos += 4;\n\n\t\t \n\t\tpos++;\n\t\t \n\t\tpos++;\n\t\t \n\t\tpos += 2;\n\t}\n}\n\n \nstatic void ieee80211_tdls_td_tx_handle(struct ieee80211_local *local,\n\t\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct sk_buff *skb, u32 flags)\n{\n\tstruct sk_buff *teardown_skb;\n\tstruct sk_buff *orig_teardown_skb;\n\tbool is_teardown = false;\n\n\t \n\tspin_lock(&sdata->u.mgd.teardown_lock);\n\tteardown_skb = sdata->u.mgd.teardown_skb;\n\torig_teardown_skb = sdata->u.mgd.orig_teardown_skb;\n\tif ((skb == orig_teardown_skb) && teardown_skb) {\n\t\tsdata->u.mgd.teardown_skb = NULL;\n\t\tsdata->u.mgd.orig_teardown_skb = NULL;\n\t\tis_teardown = true;\n\t}\n\tspin_unlock(&sdata->u.mgd.teardown_lock);\n\n\tif (is_teardown) {\n\t\t \n\t\tWARN_ON(!ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS));\n\n\t\t \n\t\tif (flags & IEEE80211_TX_STAT_ACK) {\n\t\t\tdev_kfree_skb_any(teardown_skb);\n\t\t} else {\n\t\t\ttdls_dbg(sdata,\n\t\t\t\t \"TDLS Resending teardown through AP\\n\");\n\n\t\t\tieee80211_subif_start_xmit(teardown_skb, skb->dev);\n\t\t}\n\t}\n}\n\nstatic struct ieee80211_sub_if_data *\nieee80211_sdata_from_skb(struct ieee80211_local *local, struct sk_buff *skb)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tif (skb->dev) {\n\t\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\t\tif (!sdata->dev)\n\t\t\t\tcontinue;\n\n\t\t\tif (skb->dev == sdata->dev)\n\t\t\t\treturn sdata;\n\t\t}\n\n\t\treturn NULL;\n\t}\n\n\treturn rcu_dereference(local->p2p_sdata);\n}\n\nstatic void ieee80211_report_ack_skb(struct ieee80211_local *local,\n\t\t\t\t     struct sk_buff *orig_skb,\n\t\t\t\t     bool acked, bool dropped,\n\t\t\t\t     ktime_t ack_hwtstamp)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(orig_skb);\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&local->ack_status_lock, flags);\n\tskb = idr_remove(&local->ack_status_frames, info->ack_frame_id);\n\tspin_unlock_irqrestore(&local->ack_status_lock, flags);\n\n\tif (!skb)\n\t\treturn;\n\n\tif (info->flags & IEEE80211_TX_INTFL_NL80211_FRAME_TX) {\n\t\tu64 cookie = IEEE80211_SKB_CB(skb)->ack.cookie;\n\t\tstruct ieee80211_sub_if_data *sdata;\n\t\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t\tbool is_valid_ack_signal =\n\t\t\t!!(info->status.flags & IEEE80211_TX_STATUS_ACK_SIGNAL_VALID);\n\t\tstruct cfg80211_tx_status status = {\n\t\t\t.cookie = cookie,\n\t\t\t.buf = skb->data,\n\t\t\t.len = skb->len,\n\t\t\t.ack = acked,\n\t\t};\n\n\t\tif (ieee80211_is_timing_measurement(orig_skb) ||\n\t\t    ieee80211_is_ftm(orig_skb)) {\n\t\t\tstatus.tx_tstamp =\n\t\t\t\tktime_to_ns(skb_hwtstamps(orig_skb)->hwtstamp);\n\t\t\tstatus.ack_tstamp = ktime_to_ns(ack_hwtstamp);\n\t\t}\n\n\t\trcu_read_lock();\n\t\tsdata = ieee80211_sdata_from_skb(local, skb);\n\t\tif (sdata) {\n\t\t\tif (skb->protocol == sdata->control_port_protocol ||\n\t\t\t    skb->protocol == cpu_to_be16(ETH_P_PREAUTH))\n\t\t\t\tcfg80211_control_port_tx_status(&sdata->wdev,\n\t\t\t\t\t\t\t\tcookie,\n\t\t\t\t\t\t\t\tskb->data,\n\t\t\t\t\t\t\t\tskb->len,\n\t\t\t\t\t\t\t\tacked,\n\t\t\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\telse if (ieee80211_is_any_nullfunc(hdr->frame_control))\n\t\t\t\tcfg80211_probe_status(sdata->dev, hdr->addr1,\n\t\t\t\t\t\t      cookie, acked,\n\t\t\t\t\t\t      info->status.ack_signal,\n\t\t\t\t\t\t      is_valid_ack_signal,\n\t\t\t\t\t\t      GFP_ATOMIC);\n\t\t\telse if (ieee80211_is_mgmt(hdr->frame_control))\n\t\t\t\tcfg80211_mgmt_tx_status_ext(&sdata->wdev,\n\t\t\t\t\t\t\t    &status,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\t\telse\n\t\t\t\tpr_warn(\"Unknown status report in ack skb\\n\");\n\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tdev_kfree_skb_any(skb);\n\t} else if (dropped) {\n\t\tdev_kfree_skb_any(skb);\n\t} else {\n\t\t \n\t\tskb_complete_wifi_ack(skb, acked);\n\t}\n}\n\nstatic void ieee80211_report_used_skb(struct ieee80211_local *local,\n\t\t\t\t      struct sk_buff *skb, bool dropped,\n\t\t\t\t      ktime_t ack_hwtstamp)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tu16 tx_time_est = ieee80211_info_get_tx_time_est(info);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tbool acked = info->flags & IEEE80211_TX_STAT_ACK;\n\n\tif (dropped)\n\t\tacked = false;\n\n\tif (tx_time_est) {\n\t\tstruct sta_info *sta;\n\n\t\trcu_read_lock();\n\n\t\tsta = sta_info_get_by_addrs(local, hdr->addr1, hdr->addr2);\n\t\tieee80211_sta_update_pending_airtime(local, sta,\n\t\t\t\t\t\t     skb_get_queue_mapping(skb),\n\t\t\t\t\t\t     tx_time_est,\n\t\t\t\t\t\t     true);\n\t\trcu_read_unlock();\n\t}\n\n\tif (info->flags & IEEE80211_TX_INTFL_MLME_CONN_TX) {\n\t\tstruct ieee80211_sub_if_data *sdata;\n\n\t\trcu_read_lock();\n\n\t\tsdata = ieee80211_sdata_from_skb(local, skb);\n\n\t\tif (!sdata) {\n\t\t\tskb->dev = NULL;\n\t\t} else if (!dropped) {\n\t\t\tunsigned int hdr_size =\n\t\t\t\tieee80211_hdrlen(hdr->frame_control);\n\n\t\t\t \n\t\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    (ieee80211_get_tdls_action(skb, hdr_size) ==\n\t\t\t     WLAN_TDLS_TEARDOWN)) {\n\t\t\t\tieee80211_tdls_td_tx_handle(local, sdata, skb,\n\t\t\t\t\t\t\t    info->flags);\n\t\t\t} else if (ieee80211_s1g_is_twt_setup(skb)) {\n\t\t\t\tif (!acked) {\n\t\t\t\t\tstruct sk_buff *qskb;\n\n\t\t\t\t\tqskb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t\tif (qskb) {\n\t\t\t\t\t\tskb_queue_tail(&sdata->status_queue,\n\t\t\t\t\t\t\t       qskb);\n\t\t\t\t\t\twiphy_work_queue(local->hw.wiphy,\n\t\t\t\t\t\t\t\t &sdata->work);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tieee80211_mgd_conn_tx_status(sdata,\n\t\t\t\t\t\t\t     hdr->frame_control,\n\t\t\t\t\t\t\t     acked);\n\t\t\t}\n\t\t}\n\n\t\trcu_read_unlock();\n\t} else if (info->ack_frame_id) {\n\t\tieee80211_report_ack_skb(local, skb, acked, dropped,\n\t\t\t\t\t ack_hwtstamp);\n\t}\n\n\tif (!dropped && skb->destructor) {\n\t\tskb->wifi_acked_valid = 1;\n\t\tskb->wifi_acked = acked;\n\t}\n\n\tieee80211_led_tx(local);\n\n\tif (skb_has_frag_list(skb)) {\n\t\tkfree_skb_list(skb_shinfo(skb)->frag_list);\n\t\tskb_shinfo(skb)->frag_list = NULL;\n\t}\n}\n\n \n#define STA_LOST_PKT_THRESHOLD\t50\n#define STA_LOST_PKT_TIME\tHZ\t\t \n#define STA_LOST_TDLS_PKT_TIME\t\t(10*HZ)  \n\nstatic void ieee80211_lost_packet(struct sta_info *sta,\n\t\t\t\t  struct ieee80211_tx_info *info)\n{\n\tunsigned long pkt_time = STA_LOST_PKT_TIME;\n\tunsigned int pkt_thr = STA_LOST_PKT_THRESHOLD;\n\n\t \n\tif (ieee80211_hw_check(&sta->local->hw, REPORTS_LOW_ACK))\n\t\treturn;\n\n\t \n\tif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\n\t    !(info->flags & IEEE80211_TX_STAT_AMPDU))\n\t\treturn;\n\n\tsta->deflink.status_stats.lost_packets++;\n\tif (sta->sta.tdls) {\n\t\tpkt_time = STA_LOST_TDLS_PKT_TIME;\n\t\tpkt_thr = STA_LOST_PKT_THRESHOLD;\n\t}\n\n\t \n\tif (sta->deflink.status_stats.lost_packets < pkt_thr ||\n\t    !time_after(jiffies, sta->deflink.status_stats.last_pkt_time + pkt_time))\n\t\treturn;\n\n\tcfg80211_cqm_pktloss_notify(sta->sdata->dev, sta->sta.addr,\n\t\t\t\t    sta->deflink.status_stats.lost_packets,\n\t\t\t\t    GFP_ATOMIC);\n\tsta->deflink.status_stats.lost_packets = 0;\n}\n\nstatic int ieee80211_tx_get_rates(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t\t  int *retry_count)\n{\n\tint count = -1;\n\tint i;\n\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\tif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\n\t\t    !(info->flags & IEEE80211_TX_STAT_AMPDU)) {\n\t\t\t \n\t\t\tinfo->status.rates[i].idx = -1;\n\t\t\tinfo->status.rates[i].count = 0;\n\t\t\tbreak;\n\t\t} else if (info->status.rates[i].idx < 0) {\n\t\t\tbreak;\n\t\t} else if (i >= hw->max_report_rates) {\n\t\t\t \n\t\t\tinfo->status.rates[i].idx = -1;\n\t\t\tinfo->status.rates[i].count = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount += info->status.rates[i].count;\n\t}\n\n\tif (count < 0)\n\t\tcount = 0;\n\n\t*retry_count = count;\n\treturn i - 1;\n}\n\nvoid ieee80211_tx_monitor(struct ieee80211_local *local, struct sk_buff *skb,\n\t\t\t  int retry_count, int shift, bool send_to_cooked,\n\t\t\t  struct ieee80211_tx_status *status)\n{\n\tstruct sk_buff *skb2;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct net_device *prev_dev = NULL;\n\tint rtap_len;\n\n\t \n\trtap_len = ieee80211_tx_radiotap_len(info, status);\n\tif (WARN_ON_ONCE(skb_headroom(skb) < rtap_len)) {\n\t\tpr_err(\"ieee80211_tx_status: headroom too small\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tieee80211_add_tx_radiotap_header(local, skb, retry_count,\n\t\t\t\t\t rtap_len, shift, status);\n\n\t \n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR) {\n\t\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\t\tcontinue;\n\n\t\t\tif ((sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES) &&\n\t\t\t    !send_to_cooked)\n\t\t\t\tcontinue;\n\n\t\t\tif (prev_dev) {\n\t\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (skb2) {\n\t\t\t\t\tskb2->dev = prev_dev;\n\t\t\t\t\tnetif_rx(skb2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprev_dev = sdata->dev;\n\t\t}\n\t}\n\tif (prev_dev) {\n\t\tskb->dev = prev_dev;\n\t\tnetif_rx(skb);\n\t\tskb = NULL;\n\t}\n\trcu_read_unlock();\n\tdev_kfree_skb(skb);\n}\n\nstatic void __ieee80211_tx_status(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_tx_status *status,\n\t\t\t\t  int rates_idx, int retry_count)\n{\n\tstruct sk_buff *skb = status->skb;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_tx_info *info = status->info;\n\tstruct sta_info *sta;\n\t__le16 fc;\n\tbool send_to_cooked;\n\tbool acked;\n\tbool noack_success;\n\tstruct ieee80211_bar *bar;\n\tint shift = 0;\n\tint tid = IEEE80211_NUM_TIDS;\n\n\tfc = hdr->frame_control;\n\n\tif (status->sta) {\n\t\tsta = container_of(status->sta, struct sta_info, sta);\n\t\tshift = ieee80211_vif_get_shift(&sta->sdata->vif);\n\n\t\tif (info->flags & IEEE80211_TX_STATUS_EOSP)\n\t\t\tclear_sta_flag(sta, WLAN_STA_SP);\n\n\t\tacked = !!(info->flags & IEEE80211_TX_STAT_ACK);\n\t\tnoack_success = !!(info->flags &\n\t\t\t\t   IEEE80211_TX_STAT_NOACK_TRANSMITTED);\n\n\t\t \n\t\tif (ieee80211_vif_is_mesh(&sta->sdata->vif) &&\n\t\t    ieee80211_is_data_qos(fc))\n\t\t\tieee80211_mpsp_trigger_process(\n\t\t\t\tieee80211_get_qos_ctl(hdr), sta, true, acked);\n\n\t\tif (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL) &&\n\t\t    (ieee80211_is_data(hdr->frame_control)) &&\n\t\t    (rates_idx != -1))\n\t\t\tsta->deflink.tx_stats.last_rate =\n\t\t\t\tinfo->status.rates[rates_idx];\n\n\t\tif ((info->flags & IEEE80211_TX_STAT_AMPDU_NO_BACK) &&\n\t\t    (ieee80211_is_data_qos(fc))) {\n\t\t\tu16 ssn;\n\t\t\tu8 *qc;\n\n\t\t\tqc = ieee80211_get_qos_ctl(hdr);\n\t\t\ttid = qc[0] & 0xf;\n\t\t\tssn = ((le16_to_cpu(hdr->seq_ctrl) + 0x10)\n\t\t\t\t\t\t& IEEE80211_SCTL_SEQ);\n\t\t\tieee80211_send_bar(&sta->sdata->vif, hdr->addr1,\n\t\t\t\t\t   tid, ssn);\n\t\t} else if (ieee80211_is_data_qos(fc)) {\n\t\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\n\t\t\ttid = qc[0] & 0xf;\n\t\t}\n\n\t\tif (!acked && ieee80211_is_back_req(fc)) {\n\t\t\tu16 control;\n\n\t\t\t \n\t\t\tbar = (struct ieee80211_bar *) skb->data;\n\t\t\tcontrol = le16_to_cpu(bar->control);\n\t\t\tif (!(control & IEEE80211_BAR_CTRL_MULTI_TID)) {\n\t\t\t\tu16 ssn = le16_to_cpu(bar->start_seq_num);\n\n\t\t\t\ttid = (control &\n\t\t\t\t       IEEE80211_BAR_CTRL_TID_INFO_MASK) >>\n\t\t\t\t      IEEE80211_BAR_CTRL_TID_INFO_SHIFT;\n\n\t\t\t\tieee80211_set_bar_pending(sta, tid, ssn);\n\t\t\t}\n\t\t}\n\n\t\tif (info->flags & IEEE80211_TX_STAT_TX_FILTERED) {\n\t\t\tieee80211_handle_filtered_frame(local, sta, skb);\n\t\t\treturn;\n\t\t} else if (ieee80211_is_data_present(fc)) {\n\t\t\tif (!acked && !noack_success)\n\t\t\t\tsta->deflink.status_stats.msdu_failed[tid]++;\n\n\t\t\tsta->deflink.status_stats.msdu_retries[tid] +=\n\t\t\t\tretry_count;\n\t\t}\n\n\t\tif (!(info->flags & IEEE80211_TX_CTL_INJECTED) && acked)\n\t\t\tieee80211_frame_acked(sta, skb);\n\n\t}\n\n\t \n\tif ((info->flags & IEEE80211_TX_STAT_ACK) ||\n\t    (info->flags & IEEE80211_TX_STAT_NOACK_TRANSMITTED)) {\n\t\tif (ieee80211_is_first_frag(hdr->seq_ctrl)) {\n\t\t\tI802_DEBUG_INC(local->dot11TransmittedFrameCount);\n\t\t\tif (is_multicast_ether_addr(ieee80211_get_DA(hdr)))\n\t\t\t\tI802_DEBUG_INC(local->dot11MulticastTransmittedFrameCount);\n\t\t\tif (retry_count > 0)\n\t\t\t\tI802_DEBUG_INC(local->dot11RetryCount);\n\t\t\tif (retry_count > 1)\n\t\t\t\tI802_DEBUG_INC(local->dot11MultipleRetryCount);\n\t\t}\n\n\t\t \n\t\tif (!is_multicast_ether_addr(hdr->addr1) ||\n\t\t    ieee80211_is_data(fc) ||\n\t\t    ieee80211_is_mgmt(fc))\n\t\t\tI802_DEBUG_INC(local->dot11TransmittedFragmentCount);\n\t} else {\n\t\tif (ieee80211_is_first_frag(hdr->seq_ctrl))\n\t\t\tI802_DEBUG_INC(local->dot11FailedCount);\n\t}\n\n\tif (ieee80211_is_any_nullfunc(fc) &&\n\t    ieee80211_has_pm(fc) &&\n\t    ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS) &&\n\t    !(info->flags & IEEE80211_TX_CTL_INJECTED) &&\n\t    local->ps_sdata && !(local->scanning)) {\n\t\tif (info->flags & IEEE80211_TX_STAT_ACK)\n\t\t\tlocal->ps_sdata->u.mgd.flags |=\n\t\t\t\t\tIEEE80211_STA_NULLFUNC_ACKED;\n\t\tmod_timer(&local->dynamic_ps_timer,\n\t\t\t  jiffies + msecs_to_jiffies(10));\n\t}\n\n\tieee80211_report_used_skb(local, skb, false, status->ack_hwtstamp);\n\n\t \n\tskb_orphan(skb);\n\n\t \n\tsend_to_cooked = !!(info->flags & IEEE80211_TX_CTL_INJECTED) ||\n\t\t\t !(ieee80211_is_data(fc));\n\n\t \n\tif (!local->monitors && (!send_to_cooked || !local->cooked_mntrs)) {\n\t\tif (status->free_list)\n\t\t\tlist_add_tail(&skb->list, status->free_list);\n\t\telse\n\t\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tieee80211_tx_monitor(local, skb, retry_count, shift,\n\t\t\t     send_to_cooked, status);\n}\n\nvoid ieee80211_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_tx_status status = {\n\t\t.skb = skb,\n\t\t.info = IEEE80211_SKB_CB(skb),\n\t};\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\n\tsta = sta_info_get_by_addrs(local, hdr->addr1, hdr->addr2);\n\tif (sta)\n\t\tstatus.sta = &sta->sta;\n\n\tieee80211_tx_status_ext(hw, &status);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ieee80211_tx_status);\n\nvoid ieee80211_tx_status_ext(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_tx_status *status)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_tx_info *info = status->info;\n\tstruct ieee80211_sta *pubsta = status->sta;\n\tstruct sk_buff *skb = status->skb;\n\tstruct sta_info *sta = NULL;\n\tint rates_idx, retry_count;\n\tbool acked, noack_success, ack_signal_valid;\n\tu16 tx_time_est;\n\n\tif (pubsta) {\n\t\tsta = container_of(pubsta, struct sta_info, sta);\n\n\t\tif (status->n_rates)\n\t\t\tsta->deflink.tx_stats.last_rate_info =\n\t\t\t\tstatus->rates[status->n_rates - 1].rate_idx;\n\t}\n\n\tif (skb && (tx_time_est =\n\t\t    ieee80211_info_get_tx_time_est(IEEE80211_SKB_CB(skb))) > 0) {\n\t\t \n\t\tieee80211_sta_update_pending_airtime(local, sta,\n\t\t\t\t\t\t     skb_get_queue_mapping(skb),\n\t\t\t\t\t\t     tx_time_est,\n\t\t\t\t\t\t     true);\n\t\tieee80211_info_set_tx_time_est(IEEE80211_SKB_CB(skb), 0);\n\t}\n\n\tif (!status->info)\n\t\tgoto free;\n\n\trates_idx = ieee80211_tx_get_rates(hw, info, &retry_count);\n\n\tacked = !!(info->flags & IEEE80211_TX_STAT_ACK);\n\tnoack_success = !!(info->flags & IEEE80211_TX_STAT_NOACK_TRANSMITTED);\n\tack_signal_valid =\n\t\t!!(info->status.flags & IEEE80211_TX_STATUS_ACK_SIGNAL_VALID);\n\n\tif (pubsta) {\n\t\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\n\t\tif (!acked && !noack_success)\n\t\t\tsta->deflink.status_stats.retry_failed++;\n\t\tsta->deflink.status_stats.retry_count += retry_count;\n\n\t\tif (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {\n\t\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t\t    skb && !(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP))\n\t\t\t\tieee80211_sta_tx_notify(sdata, (void *) skb->data,\n\t\t\t\t\t\t\tacked, info->status.tx_time);\n\n\t\t\tif (acked) {\n\t\t\t\tsta->deflink.status_stats.last_ack = jiffies;\n\n\t\t\t\tif (sta->deflink.status_stats.lost_packets)\n\t\t\t\t\tsta->deflink.status_stats.lost_packets = 0;\n\n\t\t\t\t \n\t\t\t\tsta->deflink.status_stats.last_pkt_time = jiffies;\n\n\t\t\t\t \n\t\t\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t\t\t    unlikely(sdata->u.mgd.probe_send_count > 0))\n\t\t\t\t\tsdata->u.mgd.probe_send_count = 0;\n\n\t\t\t\tif (ack_signal_valid) {\n\t\t\t\t\tsta->deflink.status_stats.last_ack_signal =\n\t\t\t\t\t\t\t (s8)info->status.ack_signal;\n\t\t\t\t\tsta->deflink.status_stats.ack_signal_filled = true;\n\t\t\t\t\tewma_avg_signal_add(&sta->deflink.status_stats.avg_ack_signal,\n\t\t\t\t\t\t\t    -info->status.ack_signal);\n\t\t\t\t}\n\t\t\t} else if (test_sta_flag(sta, WLAN_STA_PS_STA)) {\n\t\t\t\t \n\t\t\t\tif (skb)\n\t\t\t\t\tieee80211_handle_filtered_frame(local, sta, skb);\n\t\t\t\treturn;\n\t\t\t} else if (noack_success) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\tieee80211_lost_packet(sta, info);\n\t\t\t}\n\t\t}\n\n\t\trate_control_tx_status(local, status);\n\t\tif (ieee80211_vif_is_mesh(&sta->sdata->vif))\n\t\t\tieee80211s_update_metric(local, sta, status);\n\t}\n\n\tif (skb && !(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP))\n\t\treturn __ieee80211_tx_status(hw, status, rates_idx,\n\t\t\t\t\t     retry_count);\n\n\tif (acked || noack_success) {\n\t\tI802_DEBUG_INC(local->dot11TransmittedFrameCount);\n\t\tif (!pubsta)\n\t\t\tI802_DEBUG_INC(local->dot11MulticastTransmittedFrameCount);\n\t\tif (retry_count > 0)\n\t\t\tI802_DEBUG_INC(local->dot11RetryCount);\n\t\tif (retry_count > 1)\n\t\t\tI802_DEBUG_INC(local->dot11MultipleRetryCount);\n\t} else {\n\t\tI802_DEBUG_INC(local->dot11FailedCount);\n\t}\n\nfree:\n\tif (!skb)\n\t\treturn;\n\n\tieee80211_report_used_skb(local, skb, false, status->ack_hwtstamp);\n\tif (status->free_list)\n\t\tlist_add_tail(&skb->list, status->free_list);\n\telse\n\t\tdev_kfree_skb(skb);\n}\nEXPORT_SYMBOL(ieee80211_tx_status_ext);\n\nvoid ieee80211_tx_rate_update(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_sta *pubsta,\n\t\t\t      struct ieee80211_tx_info *info)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_tx_status status = {\n\t\t.info = info,\n\t\t.sta = pubsta,\n\t};\n\n\trate_control_tx_status(local, &status);\n\n\tif (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL))\n\t\tsta->deflink.tx_stats.last_rate = info->status.rates[0];\n}\nEXPORT_SYMBOL(ieee80211_tx_rate_update);\n\nvoid ieee80211_report_low_ack(struct ieee80211_sta *pubsta, u32 num_packets)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tcfg80211_cqm_pktloss_notify(sta->sdata->dev, sta->sta.addr,\n\t\t\t\t    num_packets, GFP_ATOMIC);\n}\nEXPORT_SYMBOL(ieee80211_report_low_ack);\n\nvoid ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tktime_t kt = ktime_set(0, 0);\n\n\tieee80211_report_used_skb(local, skb, true, kt);\n\tdev_kfree_skb_any(skb);\n}\nEXPORT_SYMBOL(ieee80211_free_txskb);\n\nvoid ieee80211_purge_tx_queue(struct ieee80211_hw *hw,\n\t\t\t      struct sk_buff_head *skbs)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(skbs)))\n\t\tieee80211_free_txskb(hw, skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}