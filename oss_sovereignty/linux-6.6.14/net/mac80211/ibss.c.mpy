{
  "module_name": "ibss.c",
  "hash_id": "b70dc318a14bd46a11ce363b793679e0113792f481b72350f61fe56599f3d8a4",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/ibss.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/if_ether.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <net/mac80211.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"rate.h\"\n\n#define IEEE80211_SCAN_INTERVAL (2 * HZ)\n#define IEEE80211_IBSS_JOIN_TIMEOUT (7 * HZ)\n\n#define IEEE80211_IBSS_MERGE_INTERVAL (30 * HZ)\n#define IEEE80211_IBSS_INACTIVITY_LIMIT (60 * HZ)\n#define IEEE80211_IBSS_RSN_INACTIVITY_LIMIT (10 * HZ)\n\n#define IEEE80211_IBSS_MAX_STA_ENTRIES 128\n\nstatic struct beacon_data *\nieee80211_ibss_build_presp(struct ieee80211_sub_if_data *sdata,\n\t\t\t   const int beacon_int, const u32 basic_rates,\n\t\t\t   const u16 capability, u64 tsf,\n\t\t\t   struct cfg80211_chan_def *chandef,\n\t\t\t   bool *have_higher_than_11mbit,\n\t\t\t   struct cfg80211_csa_settings *csa_settings)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tstruct ieee80211_local *local = sdata->local;\n\tint rates_n = 0, i, ri;\n\tstruct ieee80211_mgmt *mgmt;\n\tu8 *pos;\n\tstruct ieee80211_supported_band *sband;\n\tu32 rate_flags, rates = 0, rates_added = 0;\n\tstruct beacon_data *presp;\n\tint frame_len;\n\tint shift;\n\n\t \n\tframe_len = sizeof(struct ieee80211_hdr_3addr) +\n\t\t    12   +\n\t\t    2 + IEEE80211_MAX_SSID_LEN   +\n\t\t    2 + 8   +\n\t\t    3   +\n\t\t    4   +\n\t\t    5   +\n\t\t    2 + (IEEE80211_MAX_SUPP_RATES - 8) +\n\t\t    2 + sizeof(struct ieee80211_ht_cap) +\n\t\t    2 + sizeof(struct ieee80211_ht_operation) +\n\t\t    2 + sizeof(struct ieee80211_vht_cap) +\n\t\t    2 + sizeof(struct ieee80211_vht_operation) +\n\t\t    ifibss->ie_len;\n\tpresp = kzalloc(sizeof(*presp) + frame_len, GFP_KERNEL);\n\tif (!presp)\n\t\treturn NULL;\n\n\tpresp->head = (void *)(presp + 1);\n\n\tmgmt = (void *) presp->head;\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_PROBE_RESP);\n\teth_broadcast_addr(mgmt->da);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, ifibss->bssid, ETH_ALEN);\n\tmgmt->u.beacon.beacon_int = cpu_to_le16(beacon_int);\n\tmgmt->u.beacon.timestamp = cpu_to_le64(tsf);\n\tmgmt->u.beacon.capab_info = cpu_to_le16(capability);\n\n\tpos = (u8 *)mgmt + offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\n\t*pos++ = WLAN_EID_SSID;\n\t*pos++ = ifibss->ssid_len;\n\tmemcpy(pos, ifibss->ssid, ifibss->ssid_len);\n\tpos += ifibss->ssid_len;\n\n\tsband = local->hw.wiphy->bands[chandef->chan->band];\n\trate_flags = ieee80211_chandef_rate_flags(chandef);\n\tshift = ieee80211_chandef_get_shift(chandef);\n\trates_n = 0;\n\tif (have_higher_than_11mbit)\n\t\t*have_higher_than_11mbit = false;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tif ((rate_flags & sband->bitrates[i].flags) != rate_flags)\n\t\t\tcontinue;\n\t\tif (sband->bitrates[i].bitrate > 110 &&\n\t\t    have_higher_than_11mbit)\n\t\t\t*have_higher_than_11mbit = true;\n\n\t\trates |= BIT(i);\n\t\trates_n++;\n\t}\n\n\t*pos++ = WLAN_EID_SUPP_RATES;\n\t*pos++ = min_t(int, 8, rates_n);\n\tfor (ri = 0; ri < sband->n_bitrates; ri++) {\n\t\tint rate = DIV_ROUND_UP(sband->bitrates[ri].bitrate,\n\t\t\t\t\t5 * (1 << shift));\n\t\tu8 basic = 0;\n\t\tif (!(rates & BIT(ri)))\n\t\t\tcontinue;\n\n\t\tif (basic_rates & BIT(ri))\n\t\t\tbasic = 0x80;\n\t\t*pos++ = basic | (u8) rate;\n\t\tif (++rates_added == 8) {\n\t\t\tri++;  \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sband->band == NL80211_BAND_2GHZ) {\n\t\t*pos++ = WLAN_EID_DS_PARAMS;\n\t\t*pos++ = 1;\n\t\t*pos++ = ieee80211_frequency_to_channel(\n\t\t\t\tchandef->chan->center_freq);\n\t}\n\n\t*pos++ = WLAN_EID_IBSS_PARAMS;\n\t*pos++ = 2;\n\t \n\t*pos++ = 0;\n\t*pos++ = 0;\n\n\tif (csa_settings) {\n\t\t*pos++ = WLAN_EID_CHANNEL_SWITCH;\n\t\t*pos++ = 3;\n\t\t*pos++ = csa_settings->block_tx ? 1 : 0;\n\t\t*pos++ = ieee80211_frequency_to_channel(\n\t\t\t\tcsa_settings->chandef.chan->center_freq);\n\t\tpresp->cntdwn_counter_offsets[0] = (pos - presp->head);\n\t\t*pos++ = csa_settings->count;\n\t\tpresp->cntdwn_current_counter = csa_settings->count;\n\t}\n\n\t \n\tif (rates_n > 8) {\n\t\t*pos++ = WLAN_EID_EXT_SUPP_RATES;\n\t\t*pos++ = rates_n - 8;\n\t\tfor (; ri < sband->n_bitrates; ri++) {\n\t\t\tint rate = DIV_ROUND_UP(sband->bitrates[ri].bitrate,\n\t\t\t\t\t\t5 * (1 << shift));\n\t\t\tu8 basic = 0;\n\t\t\tif (!(rates & BIT(ri)))\n\t\t\t\tcontinue;\n\n\t\t\tif (basic_rates & BIT(ri))\n\t\t\t\tbasic = 0x80;\n\t\t\t*pos++ = basic | (u8) rate;\n\t\t}\n\t}\n\n\tif (ifibss->ie_len) {\n\t\tmemcpy(pos, ifibss->ie, ifibss->ie_len);\n\t\tpos += ifibss->ie_len;\n\t}\n\n\t \n\tif (chandef->width != NL80211_CHAN_WIDTH_20_NOHT &&\n\t    chandef->width != NL80211_CHAN_WIDTH_5 &&\n\t    chandef->width != NL80211_CHAN_WIDTH_10 &&\n\t    sband->ht_cap.ht_supported) {\n\t\tstruct ieee80211_sta_ht_cap ht_cap;\n\n\t\tmemcpy(&ht_cap, &sband->ht_cap, sizeof(ht_cap));\n\t\tieee80211_apply_htcap_overrides(sdata, &ht_cap);\n\n\t\tpos = ieee80211_ie_build_ht_cap(pos, &ht_cap, ht_cap.cap);\n\t\t \n\t\tpos = ieee80211_ie_build_ht_oper(pos, &sband->ht_cap,\n\t\t\t\t\t\t chandef, 0, false);\n\n\t\t \n\t\tif (chandef->width != NL80211_CHAN_WIDTH_20 &&\n\t\t    chandef->width != NL80211_CHAN_WIDTH_40 &&\n\t\t    sband->vht_cap.vht_supported) {\n\t\t\tpos = ieee80211_ie_build_vht_cap(pos, &sband->vht_cap,\n\t\t\t\t\t\t\t sband->vht_cap.cap);\n\t\t\tpos = ieee80211_ie_build_vht_oper(pos, &sband->vht_cap,\n\t\t\t\t\t\t\t  chandef);\n\t\t}\n\t}\n\n\tif (local->hw.queues >= IEEE80211_NUM_ACS)\n\t\tpos = ieee80211_add_wmm_info_ie(pos, 0);  \n\n\tpresp->head_len = pos - presp->head;\n\tif (WARN_ON(presp->head_len > frame_len))\n\t\tgoto error;\n\n\treturn presp;\nerror:\n\tkfree(presp);\n\treturn NULL;\n}\n\nstatic void __ieee80211_sta_join_ibss(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      const u8 *bssid, const int beacon_int,\n\t\t\t\t      struct cfg80211_chan_def *req_chandef,\n\t\t\t\t      const u32 basic_rates,\n\t\t\t\t      const u16 capability, u64 tsf,\n\t\t\t\t      bool creator)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct cfg80211_bss *bss;\n\tu64 bss_change;\n\tstruct cfg80211_chan_def chandef;\n\tstruct ieee80211_channel *chan;\n\tstruct beacon_data *presp;\n\tstruct cfg80211_inform_bss bss_meta = {};\n\tbool have_higher_than_11mbit;\n\tbool radar_required;\n\tint err;\n\n\tsdata_assert_lock(sdata);\n\n\t \n\tdrv_reset_tsf(local, sdata);\n\n\tif (!ether_addr_equal(ifibss->bssid, bssid))\n\t\tsta_info_flush(sdata);\n\n\t \n\tif (sdata->vif.cfg.ibss_joined) {\n\t\tsdata->vif.cfg.ibss_joined = false;\n\t\tsdata->vif.cfg.ibss_creator = false;\n\t\tsdata->vif.bss_conf.enable_beacon = false;\n\t\tnetif_carrier_off(sdata->dev);\n\t\tieee80211_bss_info_change_notify(sdata,\n\t\t\t\t\t\t BSS_CHANGED_IBSS |\n\t\t\t\t\t\t BSS_CHANGED_BEACON_ENABLED);\n\t\tdrv_leave_ibss(local, sdata);\n\t}\n\n\tpresp = sdata_dereference(ifibss->presp, sdata);\n\tRCU_INIT_POINTER(ifibss->presp, NULL);\n\tif (presp)\n\t\tkfree_rcu(presp, rcu_head);\n\n\t \n\tchandef = *req_chandef;\n\tchan = chandef.chan;\n\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, &chandef,\n\t\t\t\t     NL80211_IFTYPE_ADHOC)) {\n\t\tif (chandef.width == NL80211_CHAN_WIDTH_5 ||\n\t\t    chandef.width == NL80211_CHAN_WIDTH_10 ||\n\t\t    chandef.width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t\t    chandef.width == NL80211_CHAN_WIDTH_20) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"Failed to join IBSS, beacons forbidden\\n\");\n\t\t\treturn;\n\t\t}\n\t\tchandef.width = NL80211_CHAN_WIDTH_20;\n\t\tchandef.center_freq1 = chan->center_freq;\n\t\t \n\t\tif (!cfg80211_reg_can_beacon(local->hw.wiphy, &chandef,\n\t\t\t\t\t     NL80211_IFTYPE_ADHOC)) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"Failed to join IBSS, beacons forbidden\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\terr = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,\n\t\t\t\t\t    &chandef, NL80211_IFTYPE_ADHOC);\n\tif (err < 0) {\n\t\tsdata_info(sdata,\n\t\t\t   \"Failed to join IBSS, invalid chandef\\n\");\n\t\treturn;\n\t}\n\tif (err > 0 && !ifibss->userspace_handles_dfs) {\n\t\tsdata_info(sdata,\n\t\t\t   \"Failed to join IBSS, DFS channel without control program\\n\");\n\t\treturn;\n\t}\n\n\tradar_required = err;\n\n\tmutex_lock(&local->mtx);\n\tif (ieee80211_link_use_channel(&sdata->deflink, &chandef,\n\t\t\t\t       ifibss->fixed_channel ?\n\t\t\t\t\tIEEE80211_CHANCTX_SHARED :\n\t\t\t\t\tIEEE80211_CHANCTX_EXCLUSIVE)) {\n\t\tsdata_info(sdata, \"Failed to join IBSS, no channel context\\n\");\n\t\tmutex_unlock(&local->mtx);\n\t\treturn;\n\t}\n\tsdata->deflink.radar_required = radar_required;\n\tmutex_unlock(&local->mtx);\n\n\tmemcpy(ifibss->bssid, bssid, ETH_ALEN);\n\n\tpresp = ieee80211_ibss_build_presp(sdata, beacon_int, basic_rates,\n\t\t\t\t\t   capability, tsf, &chandef,\n\t\t\t\t\t   &have_higher_than_11mbit, NULL);\n\tif (!presp)\n\t\treturn;\n\n\trcu_assign_pointer(ifibss->presp, presp);\n\tmgmt = (void *)presp->head;\n\n\tsdata->vif.bss_conf.enable_beacon = true;\n\tsdata->vif.bss_conf.beacon_int = beacon_int;\n\tsdata->vif.bss_conf.basic_rates = basic_rates;\n\tsdata->vif.cfg.ssid_len = ifibss->ssid_len;\n\tmemcpy(sdata->vif.cfg.ssid, ifibss->ssid, ifibss->ssid_len);\n\tbss_change = BSS_CHANGED_BEACON_INT;\n\tbss_change |= ieee80211_reset_erp_info(sdata);\n\tbss_change |= BSS_CHANGED_BSSID;\n\tbss_change |= BSS_CHANGED_BEACON;\n\tbss_change |= BSS_CHANGED_BEACON_ENABLED;\n\tbss_change |= BSS_CHANGED_BASIC_RATES;\n\tbss_change |= BSS_CHANGED_HT;\n\tbss_change |= BSS_CHANGED_IBSS;\n\tbss_change |= BSS_CHANGED_SSID;\n\n\t \n\tsdata->vif.bss_conf.use_short_slot = chan->band == NL80211_BAND_5GHZ;\n\tbss_change |= BSS_CHANGED_ERP_SLOT;\n\n\t \n\tsdata->deflink.operating_11g_mode =\n\t\tchan->band == NL80211_BAND_2GHZ && have_higher_than_11mbit;\n\n\tieee80211_set_wmm_default(&sdata->deflink, true, false);\n\n\tsdata->vif.cfg.ibss_joined = true;\n\tsdata->vif.cfg.ibss_creator = creator;\n\n\terr = drv_join_ibss(local, sdata);\n\tif (err) {\n\t\tsdata->vif.cfg.ibss_joined = false;\n\t\tsdata->vif.cfg.ibss_creator = false;\n\t\tsdata->vif.bss_conf.enable_beacon = false;\n\t\tsdata->vif.cfg.ssid_len = 0;\n\t\tRCU_INIT_POINTER(ifibss->presp, NULL);\n\t\tkfree_rcu(presp, rcu_head);\n\t\tmutex_lock(&local->mtx);\n\t\tieee80211_link_release_channel(&sdata->deflink);\n\t\tmutex_unlock(&local->mtx);\n\t\tsdata_info(sdata, \"Failed to join IBSS, driver failure: %d\\n\",\n\t\t\t   err);\n\t\treturn;\n\t}\n\n\tieee80211_bss_info_change_notify(sdata, bss_change);\n\n\tifibss->state = IEEE80211_IBSS_MLME_JOINED;\n\tmod_timer(&ifibss->timer,\n\t\t  round_jiffies(jiffies + IEEE80211_IBSS_MERGE_INTERVAL));\n\n\tbss_meta.chan = chan;\n\tbss_meta.scan_width = cfg80211_chandef_to_scan_width(&chandef);\n\tbss = cfg80211_inform_bss_frame_data(local->hw.wiphy, &bss_meta, mgmt,\n\t\t\t\t\t     presp->head_len, GFP_KERNEL);\n\n\tcfg80211_put_bss(local->hw.wiphy, bss);\n\tnetif_carrier_on(sdata->dev);\n\tcfg80211_ibss_joined(sdata->dev, ifibss->bssid, chan, GFP_KERNEL);\n}\n\nstatic void ieee80211_sta_join_ibss(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_bss *bss)\n{\n\tstruct cfg80211_bss *cbss =\n\t\tcontainer_of((void *)bss, struct cfg80211_bss, priv);\n\tstruct ieee80211_supported_band *sband;\n\tstruct cfg80211_chan_def chandef;\n\tu32 basic_rates;\n\tint i, j;\n\tu16 beacon_int = cbss->beacon_interval;\n\tconst struct cfg80211_bss_ies *ies;\n\tenum nl80211_channel_type chan_type;\n\tu64 tsf;\n\tu32 rate_flags;\n\tint shift;\n\n\tsdata_assert_lock(sdata);\n\n\tif (beacon_int < 10)\n\t\tbeacon_int = 10;\n\n\tswitch (sdata->u.ibss.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tchan_type = cfg80211_get_chandef_type(&sdata->u.ibss.chandef);\n\t\tcfg80211_chandef_create(&chandef, cbss->channel, chan_type);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\t\tcfg80211_chandef_create(&chandef, cbss->channel,\n\t\t\t\t\tNL80211_CHAN_NO_HT);\n\t\tchandef.width = sdata->u.ibss.chandef.width;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tchandef = sdata->u.ibss.chandef;\n\t\tchandef.chan = cbss->channel;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tcfg80211_chandef_create(&chandef, cbss->channel,\n\t\t\t\t\tNL80211_CHAN_NO_HT);\n\t\tbreak;\n\t}\n\n\tsband = sdata->local->hw.wiphy->bands[cbss->channel->band];\n\trate_flags = ieee80211_chandef_rate_flags(&sdata->u.ibss.chandef);\n\tshift = ieee80211_vif_get_shift(&sdata->vif);\n\n\tbasic_rates = 0;\n\n\tfor (i = 0; i < bss->supp_rates_len; i++) {\n\t\tint rate = bss->supp_rates[i] & 0x7f;\n\t\tbool is_basic = !!(bss->supp_rates[i] & 0x80);\n\n\t\tfor (j = 0; j < sband->n_bitrates; j++) {\n\t\t\tint brate;\n\t\t\tif ((rate_flags & sband->bitrates[j].flags)\n\t\t\t    != rate_flags)\n\t\t\t\tcontinue;\n\n\t\t\tbrate = DIV_ROUND_UP(sband->bitrates[j].bitrate,\n\t\t\t\t\t     5 * (1 << shift));\n\t\t\tif (brate == rate) {\n\t\t\t\tif (is_basic)\n\t\t\t\t\tbasic_rates |= BIT(j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\trcu_read_lock();\n\ties = rcu_dereference(cbss->ies);\n\ttsf = ies->tsf;\n\trcu_read_unlock();\n\n\t__ieee80211_sta_join_ibss(sdata, cbss->bssid,\n\t\t\t\t  beacon_int,\n\t\t\t\t  &chandef,\n\t\t\t\t  basic_rates,\n\t\t\t\t  cbss->capability,\n\t\t\t\t  tsf, false);\n}\n\nint ieee80211_ibss_csa_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct cfg80211_csa_settings *csa_settings,\n\t\t\t      u64 *changed)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tstruct beacon_data *presp, *old_presp;\n\tstruct cfg80211_bss *cbss;\n\tconst struct cfg80211_bss_ies *ies;\n\tu16 capability = WLAN_CAPABILITY_IBSS;\n\tu64 tsf;\n\n\tsdata_assert_lock(sdata);\n\n\tif (ifibss->privacy)\n\t\tcapability |= WLAN_CAPABILITY_PRIVACY;\n\n\tcbss = cfg80211_get_bss(sdata->local->hw.wiphy, ifibss->chandef.chan,\n\t\t\t\tifibss->bssid, ifibss->ssid,\n\t\t\t\tifibss->ssid_len, IEEE80211_BSS_TYPE_IBSS,\n\t\t\t\tIEEE80211_PRIVACY(ifibss->privacy));\n\n\tif (WARN_ON(!cbss))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\ties = rcu_dereference(cbss->ies);\n\ttsf = ies->tsf;\n\trcu_read_unlock();\n\tcfg80211_put_bss(sdata->local->hw.wiphy, cbss);\n\n\told_presp = sdata_dereference(ifibss->presp, sdata);\n\n\tpresp = ieee80211_ibss_build_presp(sdata,\n\t\t\t\t\t   sdata->vif.bss_conf.beacon_int,\n\t\t\t\t\t   sdata->vif.bss_conf.basic_rates,\n\t\t\t\t\t   capability, tsf, &ifibss->chandef,\n\t\t\t\t\t   NULL, csa_settings);\n\tif (!presp)\n\t\treturn -ENOMEM;\n\n\trcu_assign_pointer(ifibss->presp, presp);\n\tif (old_presp)\n\t\tkfree_rcu(old_presp, rcu_head);\n\n\t*changed |= BSS_CHANGED_BEACON;\n\treturn 0;\n}\n\nint ieee80211_ibss_finish_csa(struct ieee80211_sub_if_data *sdata, u64 *changed)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tstruct cfg80211_bss *cbss;\n\n\tsdata_assert_lock(sdata);\n\n\t \n\tif (ifibss->state != IEEE80211_IBSS_MLME_JOINED)\n\t\treturn -ENOLINK;\n\n\t \n\tif (!is_zero_ether_addr(ifibss->bssid)) {\n\t\tcbss = cfg80211_get_bss(sdata->local->hw.wiphy,\n\t\t\t\t\tifibss->chandef.chan,\n\t\t\t\t\tifibss->bssid, ifibss->ssid,\n\t\t\t\t\tifibss->ssid_len,\n\t\t\t\t\tIEEE80211_BSS_TYPE_IBSS,\n\t\t\t\t\tIEEE80211_PRIVACY(ifibss->privacy));\n\t\t \n\t\tif (cbss) {\n\t\t\tcbss->channel = sdata->deflink.csa_chandef.chan;\n\t\t\tcfg80211_put_bss(sdata->local->hw.wiphy, cbss);\n\t\t}\n\t}\n\n\tifibss->chandef = sdata->deflink.csa_chandef;\n\n\t \n\treturn ieee80211_ibss_csa_beacon(sdata, NULL, changed);\n}\n\nvoid ieee80211_ibss_stop(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\n\twiphy_work_cancel(sdata->local->hw.wiphy,\n\t\t\t  &ifibss->csa_connection_drop_work);\n}\n\nstatic struct sta_info *ieee80211_ibss_finish_sta(struct sta_info *sta)\n\t__acquires(RCU)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tu8 addr[ETH_ALEN];\n\n\tmemcpy(addr, sta->sta.addr, ETH_ALEN);\n\n\tibss_dbg(sdata, \"Adding new IBSS station %pM\\n\", addr);\n\n\tsta_info_pre_move_state(sta, IEEE80211_STA_AUTH);\n\tsta_info_pre_move_state(sta, IEEE80211_STA_ASSOC);\n\t \n\tif (!sta->sdata->u.ibss.control_port)\n\t\tsta_info_pre_move_state(sta, IEEE80211_STA_AUTHORIZED);\n\n\trate_control_rate_init(sta);\n\n\t \n\tif (sta_info_insert_rcu(sta))\n\t\treturn sta_info_get(sdata, addr);\n\treturn sta;\n}\n\nstatic struct sta_info *\nieee80211_ibss_add_sta(struct ieee80211_sub_if_data *sdata, const u8 *bssid,\n\t\t       const u8 *addr, u32 supp_rates)\n\t__acquires(RCU)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_supported_band *sband;\n\tenum nl80211_bss_scan_width scan_width;\n\tint band;\n\n\t \n\tif (local->num_sta >= IEEE80211_IBSS_MAX_STA_ENTRIES) {\n\t\tnet_info_ratelimited(\"%s: No room for a new IBSS STA entry %pM\\n\",\n\t\t\t\t    sdata->name, addr);\n\t\trcu_read_lock();\n\t\treturn NULL;\n\t}\n\n\tif (ifibss->state == IEEE80211_IBSS_MLME_SEARCH) {\n\t\trcu_read_lock();\n\t\treturn NULL;\n\t}\n\n\tif (!ether_addr_equal(bssid, sdata->u.ibss.bssid)) {\n\t\trcu_read_lock();\n\t\treturn NULL;\n\t}\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tif (WARN_ON_ONCE(!chanctx_conf))\n\t\treturn NULL;\n\tband = chanctx_conf->def.chan->band;\n\tscan_width = cfg80211_chandef_to_scan_width(&chanctx_conf->def);\n\trcu_read_unlock();\n\n\tsta = sta_info_alloc(sdata, addr, GFP_KERNEL);\n\tif (!sta) {\n\t\trcu_read_lock();\n\t\treturn NULL;\n\t}\n\n\t \n\tsband = local->hw.wiphy->bands[band];\n\tsta->sta.deflink.supp_rates[band] = supp_rates |\n\t\t\tieee80211_mandatory_rates(sband, scan_width);\n\n\treturn ieee80211_ibss_finish_sta(sta);\n}\n\nstatic int ieee80211_sta_active_ibss(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint active = 0;\n\tstruct sta_info *sta;\n\n\tsdata_assert_lock(sdata);\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tunsigned long last_active = ieee80211_sta_last_active(sta);\n\n\t\tif (sta->sdata == sdata &&\n\t\t    time_is_after_jiffies(last_active +\n\t\t\t\t\t  IEEE80211_IBSS_MERGE_INTERVAL)) {\n\t\t\tactive++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\treturn active;\n}\n\nstatic void ieee80211_ibss_disconnect(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct cfg80211_bss *cbss;\n\tstruct beacon_data *presp;\n\tstruct sta_info *sta;\n\n\tif (!is_zero_ether_addr(ifibss->bssid)) {\n\t\tcbss = cfg80211_get_bss(local->hw.wiphy, ifibss->chandef.chan,\n\t\t\t\t\tifibss->bssid, ifibss->ssid,\n\t\t\t\t\tifibss->ssid_len,\n\t\t\t\t\tIEEE80211_BSS_TYPE_IBSS,\n\t\t\t\t\tIEEE80211_PRIVACY(ifibss->privacy));\n\n\t\tif (cbss) {\n\t\t\tcfg80211_unlink_bss(local->hw.wiphy, cbss);\n\t\t\tcfg80211_put_bss(sdata->local->hw.wiphy, cbss);\n\t\t}\n\t}\n\n\tifibss->state = IEEE80211_IBSS_MLME_SEARCH;\n\n\tsta_info_flush(sdata);\n\n\tspin_lock_bh(&ifibss->incomplete_lock);\n\twhile (!list_empty(&ifibss->incomplete_stations)) {\n\t\tsta = list_first_entry(&ifibss->incomplete_stations,\n\t\t\t\t       struct sta_info, list);\n\t\tlist_del(&sta->list);\n\t\tspin_unlock_bh(&ifibss->incomplete_lock);\n\n\t\tsta_info_free(local, sta);\n\t\tspin_lock_bh(&ifibss->incomplete_lock);\n\t}\n\tspin_unlock_bh(&ifibss->incomplete_lock);\n\n\tnetif_carrier_off(sdata->dev);\n\n\tsdata->vif.cfg.ibss_joined = false;\n\tsdata->vif.cfg.ibss_creator = false;\n\tsdata->vif.bss_conf.enable_beacon = false;\n\tsdata->vif.cfg.ssid_len = 0;\n\n\t \n\tpresp = sdata_dereference(ifibss->presp, sdata);\n\tRCU_INIT_POINTER(sdata->u.ibss.presp, NULL);\n\tif (presp)\n\t\tkfree_rcu(presp, rcu_head);\n\n\tclear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED, &sdata->state);\n\tieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED |\n\t\t\t\t\t\tBSS_CHANGED_IBSS);\n\tdrv_leave_ibss(local, sdata);\n\tmutex_lock(&local->mtx);\n\tieee80211_link_release_channel(&sdata->deflink);\n\tmutex_unlock(&local->mtx);\n}\n\nstatic void ieee80211_csa_connection_drop_work(struct wiphy *wiphy,\n\t\t\t\t\t       struct wiphy_work *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data,\n\t\t\t     u.ibss.csa_connection_drop_work);\n\n\tsdata_lock(sdata);\n\n\tieee80211_ibss_disconnect(sdata);\n\tsynchronize_rcu();\n\tskb_queue_purge(&sdata->skb_queue);\n\n\t \n\twiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);\n\n\tsdata_unlock(sdata);\n}\n\nstatic void ieee80211_ibss_csa_mark_radar(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tint err;\n\n\t \n\terr = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,\n\t\t\t\t\t    &ifibss->chandef,\n\t\t\t\t\t    NL80211_IFTYPE_ADHOC);\n\tif (err > 0)\n\t\tcfg80211_radar_event(sdata->local->hw.wiphy, &ifibss->chandef,\n\t\t\t\t     GFP_ATOMIC);\n}\n\nstatic bool\nieee80211_ibss_process_chanswitch(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct ieee802_11_elems *elems,\n\t\t\t\t  bool beacon)\n{\n\tstruct cfg80211_csa_settings params;\n\tstruct ieee80211_csa_ie csa_ie;\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tenum nl80211_channel_type ch_type;\n\tint err;\n\tieee80211_conn_flags_t conn_flags;\n\tu32 vht_cap_info = 0;\n\n\tsdata_assert_lock(sdata);\n\n\tconn_flags = IEEE80211_CONN_DISABLE_VHT;\n\n\tswitch (ifibss->chandef.width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_HT;\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tconn_flags |= IEEE80211_CONN_DISABLE_40MHZ;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (elems->vht_cap_elem)\n\t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n\n\tmemset(&params, 0, sizeof(params));\n\terr = ieee80211_parse_ch_switch_ie(sdata, elems,\n\t\t\t\t\t   ifibss->chandef.chan->band,\n\t\t\t\t\t   vht_cap_info,\n\t\t\t\t\t   conn_flags, ifibss->bssid, &csa_ie);\n\t \n\tif (err < 0)\n\t\tgoto disconnect;\n\n\t \n\tif (err)\n\t\treturn false;\n\n\t \n\tif (!(sdata->local->hw.wiphy->flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH))\n\t\tgoto disconnect;\n\n\tparams.count = csa_ie.count;\n\tparams.chandef = csa_ie.chandef;\n\n\tswitch (ifibss->chandef.width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\t \n\t\tch_type = cfg80211_get_chandef_type(&ifibss->chandef);\n\t\tcfg80211_chandef_create(&params.chandef, params.chandef.chan,\n\t\t\t\t\tch_type);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\t\tif (params.chandef.width != ifibss->chandef.width) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"IBSS %pM received channel switch from incompatible channel width (%d MHz, width:%d, CF1/2: %d/%d MHz), disconnecting\\n\",\n\t\t\t\t   ifibss->bssid,\n\t\t\t\t   params.chandef.chan->center_freq,\n\t\t\t\t   params.chandef.width,\n\t\t\t\t   params.chandef.center_freq1,\n\t\t\t\t   params.chandef.center_freq2);\n\t\t\tgoto disconnect;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\tgoto disconnect;\n\t}\n\n\tif (!cfg80211_reg_can_beacon(sdata->local->hw.wiphy, &params.chandef,\n\t\t\t\t     NL80211_IFTYPE_ADHOC)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"IBSS %pM switches to unsupported channel (%d MHz, width:%d, CF1/2: %d/%d MHz), disconnecting\\n\",\n\t\t\t   ifibss->bssid,\n\t\t\t   params.chandef.chan->center_freq,\n\t\t\t   params.chandef.width,\n\t\t\t   params.chandef.center_freq1,\n\t\t\t   params.chandef.center_freq2);\n\t\tgoto disconnect;\n\t}\n\n\terr = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,\n\t\t\t\t\t    &params.chandef,\n\t\t\t\t\t    NL80211_IFTYPE_ADHOC);\n\tif (err < 0)\n\t\tgoto disconnect;\n\tif (err > 0 && !ifibss->userspace_handles_dfs) {\n\t\t \n\t\tgoto disconnect;\n\t}\n\n\tparams.radar_required = err;\n\n\tif (cfg80211_chandef_identical(&params.chandef,\n\t\t\t\t       &sdata->vif.bss_conf.chandef)) {\n\t\tibss_dbg(sdata,\n\t\t\t \"received csa with an identical chandef, ignoring\\n\");\n\t\treturn true;\n\t}\n\n\t \n\tibss_dbg(sdata,\n\t\t \"received channel switch announcement to go to channel %d MHz\\n\",\n\t\t params.chandef.chan->center_freq);\n\n\tparams.block_tx = !!csa_ie.mode;\n\n\tif (ieee80211_channel_switch(sdata->local->hw.wiphy, sdata->dev,\n\t\t\t\t     &params))\n\t\tgoto disconnect;\n\n\tieee80211_ibss_csa_mark_radar(sdata);\n\n\treturn true;\ndisconnect:\n\tibss_dbg(sdata, \"Can't handle channel switch, disconnect\\n\");\n\twiphy_work_queue(sdata->local->hw.wiphy,\n\t\t\t &ifibss->csa_connection_drop_work);\n\n\tieee80211_ibss_csa_mark_radar(sdata);\n\n\treturn true;\n}\n\nstatic void\nieee80211_rx_mgmt_spectrum_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t\tstruct ieee80211_rx_status *rx_status,\n\t\t\t\tstruct ieee802_11_elems *elems)\n{\n\tint required_len;\n\n\tif (len < IEEE80211_MIN_ACTION_SIZE + 1)\n\t\treturn;\n\n\t \n\tif (mgmt->u.action.u.measurement.action_code !=\n\t    WLAN_ACTION_SPCT_CHL_SWITCH)\n\t\treturn;\n\n\trequired_len = IEEE80211_MIN_ACTION_SIZE +\n\t\t       sizeof(mgmt->u.action.u.chan_switch);\n\tif (len < required_len)\n\t\treturn;\n\n\tif (!sdata->vif.bss_conf.csa_active)\n\t\tieee80211_ibss_process_chanswitch(sdata, elems, false);\n}\n\nstatic void ieee80211_rx_mgmt_deauth_ibss(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  struct ieee80211_mgmt *mgmt,\n\t\t\t\t\t  size_t len)\n{\n\tu16 reason = le16_to_cpu(mgmt->u.deauth.reason_code);\n\n\tif (len < IEEE80211_DEAUTH_FRAME_LEN)\n\t\treturn;\n\n\tibss_dbg(sdata, \"RX DeAuth SA=%pM DA=%pM\\n\", mgmt->sa, mgmt->da);\n\tibss_dbg(sdata, \"\\tBSSID=%pM (reason: %d)\\n\", mgmt->bssid, reason);\n\tsta_info_destroy_addr(sdata, mgmt->sa);\n}\n\nstatic void ieee80211_rx_mgmt_auth_ibss(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct ieee80211_mgmt *mgmt,\n\t\t\t\t\tsize_t len)\n{\n\tu16 auth_alg, auth_transaction;\n\n\tsdata_assert_lock(sdata);\n\n\tif (len < 24 + 6)\n\t\treturn;\n\n\tauth_alg = le16_to_cpu(mgmt->u.auth.auth_alg);\n\tauth_transaction = le16_to_cpu(mgmt->u.auth.auth_transaction);\n\n\tibss_dbg(sdata, \"RX Auth SA=%pM DA=%pM\\n\", mgmt->sa, mgmt->da);\n\tibss_dbg(sdata, \"\\tBSSID=%pM (auth_transaction=%d)\\n\",\n\t\t mgmt->bssid, auth_transaction);\n\n\tif (auth_alg != WLAN_AUTH_OPEN || auth_transaction != 1)\n\t\treturn;\n\n\t \n\tieee80211_send_auth(sdata, 2, WLAN_AUTH_OPEN, 0, NULL, 0,\n\t\t\t    mgmt->sa, sdata->u.ibss.bssid, NULL, 0, 0, 0);\n}\n\nstatic void ieee80211_update_sta_info(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t\t      struct ieee80211_rx_status *rx_status,\n\t\t\t\t      struct ieee802_11_elems *elems,\n\t\t\t\t      struct ieee80211_channel *channel)\n{\n\tstruct sta_info *sta;\n\tenum nl80211_band band = rx_status->band;\n\tenum nl80211_bss_scan_width scan_width;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_supported_band *sband;\n\tbool rates_updated = false;\n\tu32 supp_rates = 0;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\treturn;\n\n\tif (!ether_addr_equal(mgmt->bssid, sdata->u.ibss.bssid))\n\t\treturn;\n\n\tsband = local->hw.wiphy->bands[band];\n\tif (WARN_ON(!sband))\n\t\treturn;\n\n\trcu_read_lock();\n\tsta = sta_info_get(sdata, mgmt->sa);\n\n\tif (elems->supp_rates) {\n\t\tsupp_rates = ieee80211_sta_get_rates(sdata, elems,\n\t\t\t\t\t\t     band, NULL);\n\t\tif (sta) {\n\t\t\tu32 prev_rates;\n\n\t\t\tprev_rates = sta->sta.deflink.supp_rates[band];\n\t\t\t \n\t\t\tscan_width = NL80211_BSS_CHAN_WIDTH_20;\n\t\t\tif (rx_status->bw == RATE_INFO_BW_5)\n\t\t\t\tscan_width = NL80211_BSS_CHAN_WIDTH_5;\n\t\t\telse if (rx_status->bw == RATE_INFO_BW_10)\n\t\t\t\tscan_width = NL80211_BSS_CHAN_WIDTH_10;\n\n\t\t\tsta->sta.deflink.supp_rates[band] = supp_rates |\n\t\t\t\tieee80211_mandatory_rates(sband, scan_width);\n\t\t\tif (sta->sta.deflink.supp_rates[band] != prev_rates) {\n\t\t\t\tibss_dbg(sdata,\n\t\t\t\t\t \"updated supp_rates set for %pM based on beacon/probe_resp (0x%x -> 0x%x)\\n\",\n\t\t\t\t\t sta->sta.addr, prev_rates,\n\t\t\t\t\t sta->sta.deflink.supp_rates[band]);\n\t\t\t\trates_updated = true;\n\t\t\t}\n\t\t} else {\n\t\t\trcu_read_unlock();\n\t\t\tsta = ieee80211_ibss_add_sta(sdata, mgmt->bssid,\n\t\t\t\t\t\t     mgmt->sa, supp_rates);\n\t\t}\n\t}\n\n\tif (sta && !sta->sta.wme &&\n\t    (elems->wmm_info || elems->s1g_capab) &&\n\t    local->hw.queues >= IEEE80211_NUM_ACS) {\n\t\tsta->sta.wme = true;\n\t\tieee80211_check_fast_xmit(sta);\n\t}\n\n\tif (sta && elems->ht_operation && elems->ht_cap_elem &&\n\t    sdata->u.ibss.chandef.width != NL80211_CHAN_WIDTH_20_NOHT &&\n\t    sdata->u.ibss.chandef.width != NL80211_CHAN_WIDTH_5 &&\n\t    sdata->u.ibss.chandef.width != NL80211_CHAN_WIDTH_10) {\n\t\t \n\t\tstruct ieee80211_ht_cap htcap_ie;\n\t\tstruct cfg80211_chan_def chandef;\n\t\tenum ieee80211_sta_rx_bandwidth bw = sta->sta.deflink.bandwidth;\n\n\t\tcfg80211_chandef_create(&chandef, channel, NL80211_CHAN_NO_HT);\n\t\tieee80211_chandef_ht_oper(elems->ht_operation, &chandef);\n\n\t\tmemcpy(&htcap_ie, elems->ht_cap_elem, sizeof(htcap_ie));\n\t\trates_updated |= ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,\n\t\t\t\t\t\t\t\t   &htcap_ie,\n\t\t\t\t\t\t\t\t   &sta->deflink);\n\n\t\tif (elems->vht_operation && elems->vht_cap_elem &&\n\t\t    sdata->u.ibss.chandef.width != NL80211_CHAN_WIDTH_20 &&\n\t\t    sdata->u.ibss.chandef.width != NL80211_CHAN_WIDTH_40) {\n\t\t\t \n\t\t\tstruct ieee80211_vht_cap cap_ie;\n\t\t\tstruct ieee80211_sta_vht_cap cap = sta->sta.deflink.vht_cap;\n\t\t\tu32 vht_cap_info =\n\t\t\t\tle32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n\n\t\t\tieee80211_chandef_vht_oper(&local->hw, vht_cap_info,\n\t\t\t\t\t\t   elems->vht_operation,\n\t\t\t\t\t\t   elems->ht_operation,\n\t\t\t\t\t\t   &chandef);\n\t\t\tmemcpy(&cap_ie, elems->vht_cap_elem, sizeof(cap_ie));\n\t\t\tieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,\n\t\t\t\t\t\t\t    &cap_ie, NULL,\n\t\t\t\t\t\t\t    &sta->deflink);\n\t\t\tif (memcmp(&cap, &sta->sta.deflink.vht_cap, sizeof(cap)))\n\t\t\t\trates_updated |= true;\n\t\t}\n\n\t\tif (bw != sta->sta.deflink.bandwidth)\n\t\t\trates_updated |= true;\n\n\t\tif (!cfg80211_chandef_compatible(&sdata->u.ibss.chandef,\n\t\t\t\t\t\t &chandef))\n\t\t\tWARN_ON_ONCE(1);\n\t}\n\n\tif (sta && rates_updated) {\n\t\tu32 changed = IEEE80211_RC_SUPP_RATES_CHANGED;\n\t\tu8 rx_nss = sta->sta.deflink.rx_nss;\n\n\t\t \n\t\tsta->sta.deflink.rx_nss = 0;\n\t\trate_control_rate_init(sta);\n\t\tif (sta->sta.deflink.rx_nss != rx_nss)\n\t\t\tchanged |= IEEE80211_RC_NSS_CHANGED;\n\n\t\tdrv_sta_rc_update(local, sdata, &sta->sta, changed);\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic void ieee80211_rx_bss_info(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t\t  struct ieee80211_rx_status *rx_status,\n\t\t\t\t  struct ieee802_11_elems *elems)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct cfg80211_bss *cbss;\n\tstruct ieee80211_bss *bss;\n\tstruct ieee80211_channel *channel;\n\tu64 beacon_timestamp, rx_timestamp;\n\tu32 supp_rates = 0;\n\tenum nl80211_band band = rx_status->band;\n\n\tchannel = ieee80211_get_channel(local->hw.wiphy, rx_status->freq);\n\tif (!channel)\n\t\treturn;\n\n\tieee80211_update_sta_info(sdata, mgmt, len, rx_status, elems, channel);\n\n\tbss = ieee80211_bss_info_update(local, rx_status, mgmt, len, channel);\n\tif (!bss)\n\t\treturn;\n\n\tcbss = container_of((void *)bss, struct cfg80211_bss, priv);\n\n\t \n\tbeacon_timestamp = le64_to_cpu(mgmt->u.beacon.timestamp);\n\n\t \n\n\t \n\tif (!(cbss->capability & WLAN_CAPABILITY_IBSS))\n\t\tgoto put_bss;\n\n\t \n\tif (sdata->u.ibss.fixed_channel &&\n\t    sdata->u.ibss.chandef.chan != cbss->channel)\n\t\tgoto put_bss;\n\n\t \n\tif (elems->ssid_len != sdata->u.ibss.ssid_len ||\n\t    memcmp(elems->ssid, sdata->u.ibss.ssid,\n\t\t\t\tsdata->u.ibss.ssid_len))\n\t\tgoto put_bss;\n\n\t \n\tif (sdata->vif.bss_conf.csa_active ||\n\t    ieee80211_ibss_process_chanswitch(sdata, elems, true))\n\t\tgoto put_bss;\n\n\t \n\tif (ether_addr_equal(cbss->bssid, sdata->u.ibss.bssid))\n\t\tgoto put_bss;\n\n\t \n\tif (sdata->u.ibss.fixed_bssid)\n\t\tgoto put_bss;\n\n\tif (ieee80211_have_rx_timestamp(rx_status)) {\n\t\t \n\t\trx_timestamp =\n\t\t\tieee80211_calculate_rx_timestamp(local, rx_status,\n\t\t\t\t\t\t\t len + FCS_LEN, 24);\n\t} else {\n\t\t \n\t\trx_timestamp = drv_get_tsf(local, sdata);\n\t}\n\n\tibss_dbg(sdata, \"RX beacon SA=%pM BSSID=%pM TSF=0x%llx\\n\",\n\t\t mgmt->sa, mgmt->bssid,\n\t\t (unsigned long long)rx_timestamp);\n\tibss_dbg(sdata, \"\\tBCN=0x%llx diff=%lld @%lu\\n\",\n\t\t (unsigned long long)beacon_timestamp,\n\t\t (unsigned long long)(rx_timestamp - beacon_timestamp),\n\t\t jiffies);\n\n\tif (beacon_timestamp > rx_timestamp) {\n\t\tibss_dbg(sdata,\n\t\t\t \"beacon TSF higher than local TSF - IBSS merge with BSSID %pM\\n\",\n\t\t\t mgmt->bssid);\n\t\tieee80211_sta_join_ibss(sdata, bss);\n\t\tsupp_rates = ieee80211_sta_get_rates(sdata, elems, band, NULL);\n\t\tieee80211_ibss_add_sta(sdata, mgmt->bssid, mgmt->sa,\n\t\t\t\t       supp_rates);\n\t\trcu_read_unlock();\n\t}\n\n put_bss:\n\tieee80211_rx_bss_put(local, bss);\n}\n\nvoid ieee80211_ibss_rx_no_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t      const u8 *bssid, const u8 *addr,\n\t\t\t      u32 supp_rates)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_supported_band *sband;\n\tenum nl80211_bss_scan_width scan_width;\n\tint band;\n\n\t \n\tif (local->num_sta >= IEEE80211_IBSS_MAX_STA_ENTRIES) {\n\t\tnet_info_ratelimited(\"%s: No room for a new IBSS STA entry %pM\\n\",\n\t\t\t\t    sdata->name, addr);\n\t\treturn;\n\t}\n\n\tif (ifibss->state == IEEE80211_IBSS_MLME_SEARCH)\n\t\treturn;\n\n\tif (!ether_addr_equal(bssid, sdata->u.ibss.bssid))\n\t\treturn;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tif (WARN_ON_ONCE(!chanctx_conf)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tband = chanctx_conf->def.chan->band;\n\tscan_width = cfg80211_chandef_to_scan_width(&chanctx_conf->def);\n\trcu_read_unlock();\n\n\tsta = sta_info_alloc(sdata, addr, GFP_ATOMIC);\n\tif (!sta)\n\t\treturn;\n\n\t \n\tsband = local->hw.wiphy->bands[band];\n\tsta->sta.deflink.supp_rates[band] = supp_rates |\n\t\t\tieee80211_mandatory_rates(sband, scan_width);\n\n\tspin_lock(&ifibss->incomplete_lock);\n\tlist_add(&sta->list, &ifibss->incomplete_stations);\n\tspin_unlock(&ifibss->incomplete_lock);\n\twiphy_work_queue(local->hw.wiphy, &sdata->work);\n}\n\nstatic void ieee80211_ibss_sta_expire(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta, *tmp;\n\tunsigned long exp_time = IEEE80211_IBSS_INACTIVITY_LIMIT;\n\tunsigned long exp_rsn = IEEE80211_IBSS_RSN_INACTIVITY_LIMIT;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tlist_for_each_entry_safe(sta, tmp, &local->sta_list, list) {\n\t\tunsigned long last_active = ieee80211_sta_last_active(sta);\n\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\n\t\tif (time_is_before_jiffies(last_active + exp_time) ||\n\t\t    (time_is_before_jiffies(last_active + exp_rsn) &&\n\t\t     sta->sta_state != IEEE80211_STA_AUTHORIZED)) {\n\t\t\tu8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];\n\n\t\t\tsta_dbg(sta->sdata, \"expiring inactive %sSTA %pM\\n\",\n\t\t\t\tsta->sta_state != IEEE80211_STA_AUTHORIZED ?\n\t\t\t\t\"not authorized \" : \"\", sta->sta.addr);\n\n\t\t\tieee80211_send_deauth_disassoc(sdata, sta->sta.addr,\n\t\t\t\t\t\t       ifibss->bssid,\n\t\t\t\t\t\t       IEEE80211_STYPE_DEAUTH,\n\t\t\t\t\t\t       WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t\t\t       true, frame_buf);\n\t\t\tWARN_ON(__sta_info_destroy(sta));\n\t\t}\n\t}\n\n\tmutex_unlock(&local->sta_mtx);\n}\n\n \n\nstatic void ieee80211_sta_merge_ibss(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tenum nl80211_bss_scan_width scan_width;\n\n\tsdata_assert_lock(sdata);\n\n\tmod_timer(&ifibss->timer,\n\t\t  round_jiffies(jiffies + IEEE80211_IBSS_MERGE_INTERVAL));\n\n\tieee80211_ibss_sta_expire(sdata);\n\n\tif (time_before(jiffies, ifibss->last_scan_completed +\n\t\t       IEEE80211_IBSS_MERGE_INTERVAL))\n\t\treturn;\n\n\tif (ieee80211_sta_active_ibss(sdata))\n\t\treturn;\n\n\tif (ifibss->fixed_channel)\n\t\treturn;\n\n\tsdata_info(sdata,\n\t\t   \"No active IBSS STAs - trying to scan for other IBSS networks with same SSID (merge)\\n\");\n\n\tscan_width = cfg80211_chandef_to_scan_width(&ifibss->chandef);\n\tieee80211_request_ibss_scan(sdata, ifibss->ssid, ifibss->ssid_len,\n\t\t\t\t    NULL, 0, scan_width);\n}\n\nstatic void ieee80211_sta_create_ibss(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tu8 bssid[ETH_ALEN];\n\tu16 capability;\n\tint i;\n\n\tsdata_assert_lock(sdata);\n\n\tif (ifibss->fixed_bssid) {\n\t\tmemcpy(bssid, ifibss->bssid, ETH_ALEN);\n\t} else {\n\t\t \n\t\tget_random_bytes(bssid, ETH_ALEN);\n\t\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t\tbssid[i] ^= sdata->vif.addr[i];\n\t\tbssid[0] &= ~0x01;\n\t\tbssid[0] |= 0x02;\n\t}\n\n\tsdata_info(sdata, \"Creating new IBSS network, BSSID %pM\\n\", bssid);\n\n\tcapability = WLAN_CAPABILITY_IBSS;\n\n\tif (ifibss->privacy)\n\t\tcapability |= WLAN_CAPABILITY_PRIVACY;\n\n\t__ieee80211_sta_join_ibss(sdata, bssid, sdata->vif.bss_conf.beacon_int,\n\t\t\t\t  &ifibss->chandef, ifibss->basic_rates,\n\t\t\t\t  capability, 0, true);\n}\n\nstatic unsigned int ibss_setup_channels(struct wiphy *wiphy,\n\t\t\t\t\tstruct ieee80211_channel **channels,\n\t\t\t\t\tunsigned int channels_max,\n\t\t\t\t\tu32 center_freq, u32 width)\n{\n\tstruct ieee80211_channel *chan = NULL;\n\tunsigned int n_chan = 0;\n\tu32 start_freq, end_freq, freq;\n\n\tif (width <= 20) {\n\t\tstart_freq = center_freq;\n\t\tend_freq = center_freq;\n\t} else {\n\t\tstart_freq = center_freq - width / 2 + 10;\n\t\tend_freq = center_freq + width / 2 - 10;\n\t}\n\n\tfor (freq = start_freq; freq <= end_freq; freq += 20) {\n\t\tchan = ieee80211_get_channel(wiphy, freq);\n\t\tif (!chan)\n\t\t\tcontinue;\n\t\tif (n_chan >= channels_max)\n\t\t\treturn n_chan;\n\n\t\tchannels[n_chan] = chan;\n\t\tn_chan++;\n\t}\n\n\treturn n_chan;\n}\n\nstatic unsigned int\nieee80211_ibss_setup_scan_channels(struct wiphy *wiphy,\n\t\t\t\t   const struct cfg80211_chan_def *chandef,\n\t\t\t\t   struct ieee80211_channel **channels,\n\t\t\t\t   unsigned int channels_max)\n{\n\tunsigned int n_chan = 0;\n\tu32 width, cf1, cf2 = 0;\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_40:\n\t\twidth = 40;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\tcf2 = chandef->center_freq2;\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\twidth = 80;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\twidth = 160;\n\t\tbreak;\n\tdefault:\n\t\twidth = 20;\n\t\tbreak;\n\t}\n\n\tcf1 = chandef->center_freq1;\n\n\tn_chan = ibss_setup_channels(wiphy, channels, channels_max, cf1, width);\n\n\tif (cf2)\n\t\tn_chan += ibss_setup_channels(wiphy, &channels[n_chan],\n\t\t\t\t\t      channels_max - n_chan, cf2,\n\t\t\t\t\t      width);\n\n\treturn n_chan;\n}\n\n \n\nstatic void ieee80211_sta_find_ibss(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct cfg80211_bss *cbss;\n\tstruct ieee80211_channel *chan = NULL;\n\tconst u8 *bssid = NULL;\n\tenum nl80211_bss_scan_width scan_width;\n\tint active_ibss;\n\n\tsdata_assert_lock(sdata);\n\n\tactive_ibss = ieee80211_sta_active_ibss(sdata);\n\tibss_dbg(sdata, \"sta_find_ibss (active_ibss=%d)\\n\", active_ibss);\n\n\tif (active_ibss)\n\t\treturn;\n\n\tif (ifibss->fixed_bssid)\n\t\tbssid = ifibss->bssid;\n\tif (ifibss->fixed_channel)\n\t\tchan = ifibss->chandef.chan;\n\tif (!is_zero_ether_addr(ifibss->bssid))\n\t\tbssid = ifibss->bssid;\n\tcbss = cfg80211_get_bss(local->hw.wiphy, chan, bssid,\n\t\t\t\tifibss->ssid, ifibss->ssid_len,\n\t\t\t\tIEEE80211_BSS_TYPE_IBSS,\n\t\t\t\tIEEE80211_PRIVACY(ifibss->privacy));\n\n\tif (cbss) {\n\t\tstruct ieee80211_bss *bss;\n\n\t\tbss = (void *)cbss->priv;\n\t\tibss_dbg(sdata,\n\t\t\t \"sta_find_ibss: selected %pM current %pM\\n\",\n\t\t\t cbss->bssid, ifibss->bssid);\n\t\tsdata_info(sdata,\n\t\t\t   \"Selected IBSS BSSID %pM based on configured SSID\\n\",\n\t\t\t   cbss->bssid);\n\n\t\tieee80211_sta_join_ibss(sdata, bss);\n\t\tieee80211_rx_bss_put(local, bss);\n\t\treturn;\n\t}\n\n\t \n\tif (ifibss->fixed_bssid && ifibss->fixed_channel) {\n\t\tsdata_info(sdata, \"Created IBSS using preconfigured BSSID %pM\\n\",\n\t\t\t   bssid);\n\t\tieee80211_sta_create_ibss(sdata);\n\t\treturn;\n\t}\n\n\n\tibss_dbg(sdata, \"sta_find_ibss: did not try to join ibss\\n\");\n\n\t \n\tif (time_after(jiffies, ifibss->last_scan_completed +\n\t\t\t\t\tIEEE80211_SCAN_INTERVAL)) {\n\t\tstruct ieee80211_channel *channels[8];\n\t\tunsigned int num;\n\n\t\tsdata_info(sdata, \"Trigger new scan to find an IBSS to join\\n\");\n\n\t\tscan_width = cfg80211_chandef_to_scan_width(&ifibss->chandef);\n\n\t\tif (ifibss->fixed_channel) {\n\t\t\tnum = ieee80211_ibss_setup_scan_channels(local->hw.wiphy,\n\t\t\t\t\t\t\t\t &ifibss->chandef,\n\t\t\t\t\t\t\t\t channels,\n\t\t\t\t\t\t\t\t ARRAY_SIZE(channels));\n\t\t\tieee80211_request_ibss_scan(sdata, ifibss->ssid,\n\t\t\t\t\t\t    ifibss->ssid_len, channels,\n\t\t\t\t\t\t    num, scan_width);\n\t\t} else {\n\t\t\tieee80211_request_ibss_scan(sdata, ifibss->ssid,\n\t\t\t\t\t\t    ifibss->ssid_len, NULL,\n\t\t\t\t\t\t    0, scan_width);\n\t\t}\n\t} else {\n\t\tint interval = IEEE80211_SCAN_INTERVAL;\n\n\t\tif (time_after(jiffies, ifibss->ibss_join_req +\n\t\t\t       IEEE80211_IBSS_JOIN_TIMEOUT))\n\t\t\tieee80211_sta_create_ibss(sdata);\n\n\t\tmod_timer(&ifibss->timer,\n\t\t\t  round_jiffies(jiffies + interval));\n\t}\n}\n\nstatic void ieee80211_rx_mgmt_probe_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct sk_buff *req)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)req->data;\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tstruct ieee80211_local *local = sdata->local;\n\tint tx_last_beacon, len = req->len;\n\tstruct sk_buff *skb;\n\tstruct beacon_data *presp;\n\tu8 *pos, *end;\n\n\tsdata_assert_lock(sdata);\n\n\tpresp = sdata_dereference(ifibss->presp, sdata);\n\n\tif (ifibss->state != IEEE80211_IBSS_MLME_JOINED ||\n\t    len < 24 + 2 || !presp)\n\t\treturn;\n\n\ttx_last_beacon = drv_tx_last_beacon(local);\n\n\tibss_dbg(sdata, \"RX ProbeReq SA=%pM DA=%pM\\n\", mgmt->sa, mgmt->da);\n\tibss_dbg(sdata, \"\\tBSSID=%pM (tx_last_beacon=%d)\\n\",\n\t\t mgmt->bssid, tx_last_beacon);\n\n\tif (!tx_last_beacon && is_multicast_ether_addr(mgmt->da))\n\t\treturn;\n\n\tif (!ether_addr_equal(mgmt->bssid, ifibss->bssid) &&\n\t    !is_broadcast_ether_addr(mgmt->bssid))\n\t\treturn;\n\n\tend = ((u8 *) mgmt) + len;\n\tpos = mgmt->u.probe_req.variable;\n\tif (pos[0] != WLAN_EID_SSID ||\n\t    pos + 2 + pos[1] > end) {\n\t\tibss_dbg(sdata, \"Invalid SSID IE in ProbeReq from %pM\\n\",\n\t\t\t mgmt->sa);\n\t\treturn;\n\t}\n\tif (pos[1] != 0 &&\n\t    (pos[1] != ifibss->ssid_len ||\n\t     memcmp(pos + 2, ifibss->ssid, ifibss->ssid_len))) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tskb = dev_alloc_skb(local->tx_headroom + presp->head_len);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->tx_headroom);\n\tskb_put_data(skb, presp->head, presp->head_len);\n\n\tmemcpy(((struct ieee80211_mgmt *) skb->data)->da, mgmt->sa, ETH_ALEN);\n\tibss_dbg(sdata, \"Sending ProbeResp to %pM\\n\", mgmt->sa);\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;\n\n\t \n\tif (pos[1] == 0)\n\t\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_NO_ACK;\n\n\tieee80211_tx_skb(sdata, skb);\n}\n\nstatic\nvoid ieee80211_rx_mgmt_probe_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t\t    struct ieee80211_rx_status *rx_status)\n{\n\tsize_t baselen;\n\tstruct ieee802_11_elems *elems;\n\n\tBUILD_BUG_ON(offsetof(typeof(mgmt->u.probe_resp), variable) !=\n\t\t     offsetof(typeof(mgmt->u.beacon), variable));\n\n\t \n\tbaselen = (u8 *) mgmt->u.probe_resp.variable - (u8 *) mgmt;\n\tif (baselen > len)\n\t\treturn;\n\n\telems = ieee802_11_parse_elems(mgmt->u.probe_resp.variable,\n\t\t\t\t       len - baselen, false, NULL);\n\n\tif (elems) {\n\t\tieee80211_rx_bss_info(sdata, mgmt, len, rx_status, elems);\n\t\tkfree(elems);\n\t}\n}\n\nvoid ieee80211_ibss_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct ieee80211_mgmt *mgmt;\n\tu16 fc;\n\tstruct ieee802_11_elems *elems;\n\tint ies_len;\n\n\trx_status = IEEE80211_SKB_RXCB(skb);\n\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\tfc = le16_to_cpu(mgmt->frame_control);\n\n\tsdata_lock(sdata);\n\n\tif (!sdata->u.ibss.ssid_len)\n\t\tgoto mgmt_out;  \n\n\tswitch (fc & IEEE80211_FCTL_STYPE) {\n\tcase IEEE80211_STYPE_PROBE_REQ:\n\t\tieee80211_rx_mgmt_probe_req(sdata, skb);\n\t\tbreak;\n\tcase IEEE80211_STYPE_PROBE_RESP:\n\tcase IEEE80211_STYPE_BEACON:\n\t\tieee80211_rx_mgmt_probe_beacon(sdata, mgmt, skb->len,\n\t\t\t\t\t       rx_status);\n\t\tbreak;\n\tcase IEEE80211_STYPE_AUTH:\n\t\tieee80211_rx_mgmt_auth_ibss(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_DEAUTH:\n\t\tieee80211_rx_mgmt_deauth_ibss(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_ACTION:\n\t\tswitch (mgmt->u.action.category) {\n\t\tcase WLAN_CATEGORY_SPECTRUM_MGMT:\n\t\t\ties_len = skb->len -\n\t\t\t\t  offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t   u.action.u.chan_switch.variable);\n\n\t\t\tif (ies_len < 0)\n\t\t\t\tbreak;\n\n\t\t\telems = ieee802_11_parse_elems(\n\t\t\t\tmgmt->u.action.u.chan_switch.variable,\n\t\t\t\ties_len, true, NULL);\n\n\t\t\tif (elems && !elems->parse_error)\n\t\t\t\tieee80211_rx_mgmt_spectrum_mgmt(sdata, mgmt,\n\t\t\t\t\t\t\t\tskb->len,\n\t\t\t\t\t\t\t\trx_status,\n\t\t\t\t\t\t\t\telems);\n\t\t\tkfree(elems);\n\t\t\tbreak;\n\t\t}\n\t}\n\n mgmt_out:\n\tsdata_unlock(sdata);\n}\n\nvoid ieee80211_ibss_work(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\tstruct sta_info *sta;\n\n\tsdata_lock(sdata);\n\n\t \n\tif (!ifibss->ssid_len)\n\t\tgoto out;\n\n\tspin_lock_bh(&ifibss->incomplete_lock);\n\twhile (!list_empty(&ifibss->incomplete_stations)) {\n\t\tsta = list_first_entry(&ifibss->incomplete_stations,\n\t\t\t\t       struct sta_info, list);\n\t\tlist_del(&sta->list);\n\t\tspin_unlock_bh(&ifibss->incomplete_lock);\n\n\t\tieee80211_ibss_finish_sta(sta);\n\t\trcu_read_unlock();\n\t\tspin_lock_bh(&ifibss->incomplete_lock);\n\t}\n\tspin_unlock_bh(&ifibss->incomplete_lock);\n\n\tswitch (ifibss->state) {\n\tcase IEEE80211_IBSS_MLME_SEARCH:\n\t\tieee80211_sta_find_ibss(sdata);\n\t\tbreak;\n\tcase IEEE80211_IBSS_MLME_JOINED:\n\t\tieee80211_sta_merge_ibss(sdata);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n out:\n\tsdata_unlock(sdata);\n}\n\nstatic void ieee80211_ibss_timer(struct timer_list *t)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tfrom_timer(sdata, t, u.ibss.timer);\n\n\twiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);\n}\n\nvoid ieee80211_ibss_setup_sdata(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\n\ttimer_setup(&ifibss->timer, ieee80211_ibss_timer, 0);\n\tINIT_LIST_HEAD(&ifibss->incomplete_stations);\n\tspin_lock_init(&ifibss->incomplete_lock);\n\twiphy_work_init(&ifibss->csa_connection_drop_work,\n\t\t\tieee80211_csa_connection_drop_work);\n}\n\n \nvoid ieee80211_ibss_notify_scan_completed(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\t\tif (sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\t\tcontinue;\n\t\tsdata->u.ibss.last_scan_completed = jiffies;\n\t}\n\tmutex_unlock(&local->iflist_mtx);\n}\n\nint ieee80211_ibss_join(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct cfg80211_ibss_params *params)\n{\n\tu64 changed = 0;\n\tu32 rate_flags;\n\tstruct ieee80211_supported_band *sband;\n\tenum ieee80211_chanctx_mode chanmode;\n\tstruct ieee80211_local *local = sdata->local;\n\tint radar_detect_width = 0;\n\tint i;\n\tint ret;\n\n\tif (params->chandef.chan->freq_offset) {\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = cfg80211_chandef_dfs_required(local->hw.wiphy,\n\t\t\t\t\t    &params->chandef,\n\t\t\t\t\t    sdata->wdev.iftype);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret > 0) {\n\t\tif (!params->userspace_handles_dfs)\n\t\t\treturn -EINVAL;\n\t\tradar_detect_width = BIT(params->chandef.width);\n\t}\n\n\tchanmode = (params->channel_fixed && !ret) ?\n\t\tIEEE80211_CHANCTX_SHARED : IEEE80211_CHANCTX_EXCLUSIVE;\n\n\tmutex_lock(&local->chanctx_mtx);\n\tret = ieee80211_check_combinations(sdata, &params->chandef, chanmode,\n\t\t\t\t\t   radar_detect_width);\n\tmutex_unlock(&local->chanctx_mtx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (params->bssid) {\n\t\tmemcpy(sdata->u.ibss.bssid, params->bssid, ETH_ALEN);\n\t\tsdata->u.ibss.fixed_bssid = true;\n\t} else\n\t\tsdata->u.ibss.fixed_bssid = false;\n\n\tsdata->u.ibss.privacy = params->privacy;\n\tsdata->u.ibss.control_port = params->control_port;\n\tsdata->u.ibss.userspace_handles_dfs = params->userspace_handles_dfs;\n\tsdata->u.ibss.basic_rates = params->basic_rates;\n\tsdata->u.ibss.last_scan_completed = jiffies;\n\n\t \n\trate_flags = ieee80211_chandef_rate_flags(&params->chandef);\n\tsband = local->hw.wiphy->bands[params->chandef.chan->band];\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tif ((rate_flags & sband->bitrates[i].flags) != rate_flags)\n\t\t\tsdata->u.ibss.basic_rates &= ~BIT(i);\n\t}\n\tmemcpy(sdata->vif.bss_conf.mcast_rate, params->mcast_rate,\n\t       sizeof(params->mcast_rate));\n\n\tsdata->vif.bss_conf.beacon_int = params->beacon_interval;\n\n\tsdata->u.ibss.chandef = params->chandef;\n\tsdata->u.ibss.fixed_channel = params->channel_fixed;\n\n\tif (params->ie) {\n\t\tsdata->u.ibss.ie = kmemdup(params->ie, params->ie_len,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (sdata->u.ibss.ie)\n\t\t\tsdata->u.ibss.ie_len = params->ie_len;\n\t}\n\n\tsdata->u.ibss.state = IEEE80211_IBSS_MLME_SEARCH;\n\tsdata->u.ibss.ibss_join_req = jiffies;\n\n\tmemcpy(sdata->u.ibss.ssid, params->ssid, params->ssid_len);\n\tsdata->u.ibss.ssid_len = params->ssid_len;\n\n\tmemcpy(&sdata->u.ibss.ht_capa, &params->ht_capa,\n\t       sizeof(sdata->u.ibss.ht_capa));\n\tmemcpy(&sdata->u.ibss.ht_capa_mask, &params->ht_capa_mask,\n\t       sizeof(sdata->u.ibss.ht_capa_mask));\n\n\t \n\n\tsdata->vif.bss_conf.ht_operation_mode |=\n\t\t  IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED\n\t\t| IEEE80211_HT_PARAM_RIFS_MODE;\n\n\tchanged |= BSS_CHANGED_HT | BSS_CHANGED_MCAST_RATE;\n\tieee80211_link_info_change_notify(sdata, &sdata->deflink, changed);\n\n\tsdata->deflink.smps_mode = IEEE80211_SMPS_OFF;\n\tsdata->deflink.needed_rx_chains = local->rx_chains;\n\tsdata->control_port_over_nl80211 = params->control_port_over_nl80211;\n\n\twiphy_work_queue(local->hw.wiphy, &sdata->work);\n\n\treturn 0;\n}\n\nint ieee80211_ibss_leave(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ibss *ifibss = &sdata->u.ibss;\n\n\tieee80211_ibss_disconnect(sdata);\n\tifibss->ssid_len = 0;\n\teth_zero_addr(ifibss->bssid);\n\n\t \n\tkfree(sdata->u.ibss.ie);\n\tsdata->u.ibss.ie = NULL;\n\tsdata->u.ibss.ie_len = 0;\n\n\t \n\tmemset(&ifibss->ht_capa, 0, sizeof(ifibss->ht_capa));\n\tmemset(&ifibss->ht_capa_mask, 0, sizeof(ifibss->ht_capa_mask));\n\n\tsynchronize_rcu();\n\n\tskb_queue_purge(&sdata->skb_queue);\n\n\tdel_timer_sync(&sdata->u.ibss.timer);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}