{
  "module_name": "cfg.c",
  "hash_id": "ad4c2c01747330918351226571579b971651a68c1ef9c60bc5870e6663e973db",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/cfg.c",
  "human_readable_source": "\n \n\n#include <linux/ieee80211.h>\n#include <linux/nl80211.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/fips.h>\n#include <linux/if_ether.h>\n#include <net/cfg80211.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"rate.h\"\n#include \"mesh.h\"\n#include \"wme.h\"\n\nstatic struct ieee80211_link_data *\nieee80211_link_or_deflink(struct ieee80211_sub_if_data *sdata, int link_id,\n\t\t\t  bool require_valid)\n{\n\tstruct ieee80211_link_data *link;\n\n\tif (link_id < 0) {\n\t\t \n\t\tif (require_valid && ieee80211_vif_is_mld(&sdata->vif))\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\treturn &sdata->deflink;\n\t}\n\n\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\tif (!link)\n\t\treturn ERR_PTR(-ENOLINK);\n\treturn link;\n}\n\nstatic void ieee80211_set_mu_mimo_follow(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct vif_params *params)\n{\n\tbool mu_mimo_groups = false;\n\tbool mu_mimo_follow = false;\n\n\tif (params->vht_mumimo_groups) {\n\t\tu64 membership;\n\n\t\tBUILD_BUG_ON(sizeof(membership) != WLAN_MEMBERSHIP_LEN);\n\n\t\tmemcpy(sdata->vif.bss_conf.mu_group.membership,\n\t\t       params->vht_mumimo_groups, WLAN_MEMBERSHIP_LEN);\n\t\tmemcpy(sdata->vif.bss_conf.mu_group.position,\n\t\t       params->vht_mumimo_groups + WLAN_MEMBERSHIP_LEN,\n\t\t       WLAN_USER_POSITION_LEN);\n\t\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t\t  BSS_CHANGED_MU_GROUPS);\n\t\t \n\t\tmemcpy(&membership, params->vht_mumimo_groups,\n\t\t       WLAN_MEMBERSHIP_LEN);\n\t\tmu_mimo_groups = membership != 0;\n\t}\n\n\tif (params->vht_mumimo_follow_addr) {\n\t\tmu_mimo_follow =\n\t\t\tis_valid_ether_addr(params->vht_mumimo_follow_addr);\n\t\tether_addr_copy(sdata->u.mntr.mu_follow_addr,\n\t\t\t\tparams->vht_mumimo_follow_addr);\n\t}\n\n\tsdata->vif.bss_conf.mu_mimo_owner = mu_mimo_groups || mu_mimo_follow;\n}\n\nstatic int ieee80211_set_mon_options(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct vif_params *params)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *monitor_sdata;\n\n\t \n\tif (params->flags && ieee80211_sdata_running(sdata)) {\n\t\tu32 mask = MONITOR_FLAG_COOK_FRAMES | MONITOR_FLAG_ACTIVE;\n\n\t\t \n\t\tif ((params->flags & mask) != (sdata->u.mntr.flags & mask))\n\t\t\treturn -EBUSY;\n\t}\n\n\t \n\tmonitor_sdata = wiphy_dereference(local->hw.wiphy,\n\t\t\t\t\t  local->monitor_sdata);\n\n\tif (!monitor_sdata &&\n\t    (params->vht_mumimo_groups || params->vht_mumimo_follow_addr))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\n\tif (monitor_sdata)\n\t\tieee80211_set_mu_mimo_follow(monitor_sdata, params);\n\n\tif (params->flags) {\n\t\tif (ieee80211_sdata_running(sdata)) {\n\t\t\tieee80211_adjust_monitor_flags(sdata, -1);\n\t\t\tsdata->u.mntr.flags = params->flags;\n\t\t\tieee80211_adjust_monitor_flags(sdata, 1);\n\n\t\t\tieee80211_configure_filter(local);\n\t\t} else {\n\t\t\t \n\t\t\tsdata->u.mntr.flags = params->flags;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ieee80211_set_ap_mbssid_options(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct cfg80211_mbssid_config params,\n\t\t\t\t\t   struct ieee80211_bss_conf *link_conf)\n{\n\tstruct ieee80211_sub_if_data *tx_sdata;\n\n\tsdata->vif.mbssid_tx_vif = NULL;\n\tlink_conf->bssid_index = 0;\n\tlink_conf->nontransmitted = false;\n\tlink_conf->ema_ap = false;\n\tlink_conf->bssid_indicator = 0;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP || !params.tx_wdev)\n\t\treturn -EINVAL;\n\n\ttx_sdata = IEEE80211_WDEV_TO_SUB_IF(params.tx_wdev);\n\tif (!tx_sdata)\n\t\treturn -EINVAL;\n\n\tif (tx_sdata == sdata) {\n\t\tsdata->vif.mbssid_tx_vif = &sdata->vif;\n\t} else {\n\t\tsdata->vif.mbssid_tx_vif = &tx_sdata->vif;\n\t\tlink_conf->nontransmitted = true;\n\t\tlink_conf->bssid_index = params.index;\n\t}\n\tif (params.ema)\n\t\tlink_conf->ema_ap = true;\n\n\treturn 0;\n}\n\nstatic struct wireless_dev *ieee80211_add_iface(struct wiphy *wiphy,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned char name_assign_type,\n\t\t\t\t\t\tenum nl80211_iftype type,\n\t\t\t\t\t\tstruct vif_params *params)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct wireless_dev *wdev;\n\tstruct ieee80211_sub_if_data *sdata;\n\tint err;\n\n\terr = ieee80211_if_add(local, name, name_assign_type, &wdev, type, params);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tsdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\n\tif (type == NL80211_IFTYPE_MONITOR) {\n\t\terr = ieee80211_set_mon_options(sdata, params);\n\t\tif (err) {\n\t\t\tieee80211_if_remove(sdata);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn wdev;\n}\n\nstatic int ieee80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tieee80211_if_remove(IEEE80211_WDEV_TO_SUB_IF(wdev));\n\n\treturn 0;\n}\n\nstatic int ieee80211_change_iface(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  enum nl80211_iftype type,\n\t\t\t\t  struct vif_params *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tint ret;\n\n\tret = ieee80211_if_change_type(sdata, type);\n\tif (ret)\n\t\treturn ret;\n\n\tif (type == NL80211_IFTYPE_AP_VLAN && params->use_4addr == 0) {\n\t\tRCU_INIT_POINTER(sdata->u.vlan.sta, NULL);\n\t\tieee80211_check_fast_rx_iface(sdata);\n\t} else if (type == NL80211_IFTYPE_STATION && params->use_4addr >= 0) {\n\t\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\n\t\tif (params->use_4addr == ifmgd->use_4addr)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (ieee80211_vif_is_mld(&sdata->vif))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tsdata->u.mgd.use_4addr = params->use_4addr;\n\t\tif (!ifmgd->associated)\n\t\t\treturn 0;\n\n\t\tmutex_lock(&local->sta_mtx);\n\t\tsta = sta_info_get(sdata, sdata->deflink.u.mgd.bssid);\n\t\tif (sta)\n\t\t\tdrv_sta_set_4addr(local, sdata, &sta->sta,\n\t\t\t\t\t  params->use_4addr);\n\t\tmutex_unlock(&local->sta_mtx);\n\n\t\tif (params->use_4addr)\n\t\t\tieee80211_send_4addr_nullfunc(local, sdata);\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR) {\n\t\tret = ieee80211_set_mon_options(sdata, params);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ieee80211_start_p2p_device(struct wiphy *wiphy,\n\t\t\t\t      struct wireless_dev *wdev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tint ret;\n\n\tmutex_lock(&sdata->local->chanctx_mtx);\n\tret = ieee80211_check_combinations(sdata, NULL, 0, 0);\n\tmutex_unlock(&sdata->local->chanctx_mtx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ieee80211_do_open(wdev, true);\n}\n\nstatic void ieee80211_stop_p2p_device(struct wiphy *wiphy,\n\t\t\t\t      struct wireless_dev *wdev)\n{\n\tieee80211_sdata_stop(IEEE80211_WDEV_TO_SUB_IF(wdev));\n}\n\nstatic int ieee80211_start_nan(struct wiphy *wiphy,\n\t\t\t       struct wireless_dev *wdev,\n\t\t\t       struct cfg80211_nan_conf *conf)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tint ret;\n\n\tmutex_lock(&sdata->local->chanctx_mtx);\n\tret = ieee80211_check_combinations(sdata, NULL, 0, 0);\n\tmutex_unlock(&sdata->local->chanctx_mtx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ieee80211_do_open(wdev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drv_start_nan(sdata->local, sdata, conf);\n\tif (ret)\n\t\tieee80211_sdata_stop(sdata);\n\n\tsdata->u.nan.conf = *conf;\n\n\treturn ret;\n}\n\nstatic void ieee80211_stop_nan(struct wiphy *wiphy,\n\t\t\t       struct wireless_dev *wdev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\n\tdrv_stop_nan(sdata->local, sdata);\n\tieee80211_sdata_stop(sdata);\n}\n\nstatic int ieee80211_nan_change_conf(struct wiphy *wiphy,\n\t\t\t\t     struct wireless_dev *wdev,\n\t\t\t\t     struct cfg80211_nan_conf *conf,\n\t\t\t\t     u32 changes)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tstruct cfg80211_nan_conf new_conf;\n\tint ret = 0;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn -ENETDOWN;\n\n\tnew_conf = sdata->u.nan.conf;\n\n\tif (changes & CFG80211_NAN_CONF_CHANGED_PREF)\n\t\tnew_conf.master_pref = conf->master_pref;\n\n\tif (changes & CFG80211_NAN_CONF_CHANGED_BANDS)\n\t\tnew_conf.bands = conf->bands;\n\n\tret = drv_nan_change_conf(sdata->local, sdata, &new_conf, changes);\n\tif (!ret)\n\t\tsdata->u.nan.conf = new_conf;\n\n\treturn ret;\n}\n\nstatic int ieee80211_add_nan_func(struct wiphy *wiphy,\n\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t  struct cfg80211_nan_func *nan_func)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tint ret;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn -ENETDOWN;\n\n\tspin_lock_bh(&sdata->u.nan.func_lock);\n\n\tret = idr_alloc(&sdata->u.nan.function_inst_ids,\n\t\t\tnan_func, 1, sdata->local->hw.max_nan_de_entries + 1,\n\t\t\tGFP_ATOMIC);\n\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnan_func->instance_id = ret;\n\n\tWARN_ON(nan_func->instance_id == 0);\n\n\tret = drv_add_nan_func(sdata->local, sdata, nan_func);\n\tif (ret) {\n\t\tspin_lock_bh(&sdata->u.nan.func_lock);\n\t\tidr_remove(&sdata->u.nan.function_inst_ids,\n\t\t\t   nan_func->instance_id);\n\t\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\t}\n\n\treturn ret;\n}\n\nstatic struct cfg80211_nan_func *\nieee80211_find_nan_func_by_cookie(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  u64 cookie)\n{\n\tstruct cfg80211_nan_func *func;\n\tint id;\n\n\tlockdep_assert_held(&sdata->u.nan.func_lock);\n\n\tidr_for_each_entry(&sdata->u.nan.function_inst_ids, func, id) {\n\t\tif (func->cookie == cookie)\n\t\t\treturn func;\n\t}\n\n\treturn NULL;\n}\n\nstatic void ieee80211_del_nan_func(struct wiphy *wiphy,\n\t\t\t\t  struct wireless_dev *wdev, u64 cookie)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tstruct cfg80211_nan_func *func;\n\tu8 instance_id = 0;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_NAN ||\n\t    !ieee80211_sdata_running(sdata))\n\t\treturn;\n\n\tspin_lock_bh(&sdata->u.nan.func_lock);\n\n\tfunc = ieee80211_find_nan_func_by_cookie(sdata, cookie);\n\tif (func)\n\t\tinstance_id = func->instance_id;\n\n\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\n\tif (instance_id)\n\t\tdrv_del_nan_func(sdata->local, sdata, instance_id);\n}\n\nstatic int ieee80211_set_noack_map(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  u16 noack_map)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tsdata->noack_map = noack_map;\n\n\tieee80211_check_fast_xmit_iface(sdata);\n\n\treturn 0;\n}\n\nstatic int ieee80211_set_tx(struct ieee80211_sub_if_data *sdata,\n\t\t\t    const u8 *mac_addr, u8 key_idx)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_key *key;\n\tstruct sta_info *sta;\n\tint ret = -EINVAL;\n\n\tif (!wiphy_ext_feature_isset(local->hw.wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_EXT_KEY_ID))\n\t\treturn -EINVAL;\n\n\tsta = sta_info_get_bss(sdata, mac_addr);\n\n\tif (!sta)\n\t\treturn -EINVAL;\n\n\tif (sta->ptk_idx == key_idx)\n\t\treturn 0;\n\n\tmutex_lock(&local->key_mtx);\n\tkey = key_mtx_dereference(local, sta->ptk[key_idx]);\n\n\tif (key && key->conf.flags & IEEE80211_KEY_FLAG_NO_AUTO_TX)\n\t\tret = ieee80211_set_tx_key(key);\n\n\tmutex_unlock(&local->key_mtx);\n\treturn ret;\n}\n\nstatic int ieee80211_add_key(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     int link_id, u8 key_idx, bool pairwise,\n\t\t\t     const u8 *mac_addr, struct key_params *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_link_data *link =\n\t\tieee80211_link_or_deflink(sdata, link_id, false);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta = NULL;\n\tstruct ieee80211_key *key;\n\tint err;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn -ENETDOWN;\n\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tif (pairwise && params->mode == NL80211_KEY_SET_TX)\n\t\treturn ieee80211_set_tx(sdata, mac_addr, key_idx);\n\n\t \n\tswitch (params->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tif (link_id >= 0)\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON_ONCE(fips_enabled))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkey = ieee80211_key_alloc(params->cipher, key_idx, params->key_len,\n\t\t\t\t  params->key, params->seq_len, params->seq);\n\tif (IS_ERR(key))\n\t\treturn PTR_ERR(key);\n\n\tkey->conf.link_id = link_id;\n\n\tif (pairwise)\n\t\tkey->conf.flags |= IEEE80211_KEY_FLAG_PAIRWISE;\n\n\tif (params->mode == NL80211_KEY_NO_TX)\n\t\tkey->conf.flags |= IEEE80211_KEY_FLAG_NO_AUTO_TX;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tif (mac_addr) {\n\t\tsta = sta_info_get_bss(sdata, mac_addr);\n\t\t \n\t\tif (!sta || !test_sta_flag(sta, WLAN_STA_ASSOC)) {\n\t\t\tieee80211_key_free_unused(key);\n\t\t\terr = -ENOENT;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (sdata->u.mgd.mfp != IEEE80211_MFP_DISABLED)\n\t\t\tkey->conf.flags |= IEEE80211_KEY_FLAG_RX_MGMT;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t \n\t\tif (sta && test_sta_flag(sta, WLAN_STA_MFP))\n\t\t\tkey->conf.flags |= IEEE80211_KEY_FLAG_RX_MGMT;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t \n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n#ifdef CONFIG_MAC80211_MESH\n\t\tif (sdata->u.mesh.security != IEEE80211_MESH_SEC_NONE)\n\t\t\tkey->conf.flags |= IEEE80211_KEY_FLAG_RX_MGMT;\n\t\tbreak;\n#endif\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\tcase NL80211_IFTYPE_NAN:\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NUM_NL80211_IFTYPES:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_OCB:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\terr = ieee80211_key_link(key, link, sta);\n\t \n\tif (err == -EALREADY)\n\t\terr = 0;\n\n out_unlock:\n\tmutex_unlock(&local->sta_mtx);\n\n\treturn err;\n}\n\nstatic struct ieee80211_key *\nieee80211_lookup_key(struct ieee80211_sub_if_data *sdata, int link_id,\n\t\t     u8 key_idx, bool pairwise, const u8 *mac_addr)\n{\n\tstruct ieee80211_local *local __maybe_unused = sdata->local;\n\tstruct ieee80211_link_data *link = &sdata->deflink;\n\tstruct ieee80211_key *key;\n\n\tif (link_id >= 0) {\n\t\tlink = rcu_dereference_check(sdata->link[link_id],\n\t\t\t\t\t     lockdep_is_held(&sdata->wdev.mtx));\n\t\tif (!link)\n\t\t\treturn NULL;\n\t}\n\n\tif (mac_addr) {\n\t\tstruct sta_info *sta;\n\t\tstruct link_sta_info *link_sta;\n\n\t\tsta = sta_info_get_bss(sdata, mac_addr);\n\t\tif (!sta)\n\t\t\treturn NULL;\n\n\t\tif (link_id >= 0) {\n\t\t\tlink_sta = rcu_dereference_check(sta->link[link_id],\n\t\t\t\t\t\t\t lockdep_is_held(&local->sta_mtx));\n\t\t\tif (!link_sta)\n\t\t\t\treturn NULL;\n\t\t} else {\n\t\t\tlink_sta = &sta->deflink;\n\t\t}\n\n\t\tif (pairwise && key_idx < NUM_DEFAULT_KEYS)\n\t\t\treturn rcu_dereference_check_key_mtx(local,\n\t\t\t\t\t\t\t     sta->ptk[key_idx]);\n\n\t\tif (!pairwise &&\n\t\t    key_idx < NUM_DEFAULT_KEYS +\n\t\t\t      NUM_DEFAULT_MGMT_KEYS +\n\t\t\t      NUM_DEFAULT_BEACON_KEYS)\n\t\t\treturn rcu_dereference_check_key_mtx(local,\n\t\t\t\t\t\t\t     link_sta->gtk[key_idx]);\n\n\t\treturn NULL;\n\t}\n\n\tif (pairwise && key_idx < NUM_DEFAULT_KEYS)\n\t\treturn rcu_dereference_check_key_mtx(local,\n\t\t\t\t\t\t     sdata->keys[key_idx]);\n\n\tkey = rcu_dereference_check_key_mtx(local, link->gtk[key_idx]);\n\tif (key)\n\t\treturn key;\n\n\t \n\tif (key_idx < NUM_DEFAULT_KEYS)\n\t\treturn rcu_dereference_check_key_mtx(local, sdata->keys[key_idx]);\n\n\treturn NULL;\n}\n\nstatic int ieee80211_del_key(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     int link_id, u8 key_idx, bool pairwise,\n\t\t\t     const u8 *mac_addr)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_key *key;\n\tint ret;\n\n\tmutex_lock(&local->sta_mtx);\n\tmutex_lock(&local->key_mtx);\n\n\tkey = ieee80211_lookup_key(sdata, link_id, key_idx, pairwise, mac_addr);\n\tif (!key) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\tieee80211_key_free(key, sdata->vif.type == NL80211_IFTYPE_STATION);\n\n\tret = 0;\n out_unlock:\n\tmutex_unlock(&local->key_mtx);\n\tmutex_unlock(&local->sta_mtx);\n\n\treturn ret;\n}\n\nstatic int ieee80211_get_key(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     int link_id, u8 key_idx, bool pairwise,\n\t\t\t     const u8 *mac_addr, void *cookie,\n\t\t\t     void (*callback)(void *cookie,\n\t\t\t\t\t      struct key_params *params))\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tu8 seq[6] = {0};\n\tstruct key_params params;\n\tstruct ieee80211_key *key;\n\tu64 pn64;\n\tu32 iv32;\n\tu16 iv16;\n\tint err = -ENOENT;\n\tstruct ieee80211_key_seq kseq = {};\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\trcu_read_lock();\n\n\tkey = ieee80211_lookup_key(sdata, link_id, key_idx, pairwise, mac_addr);\n\tif (!key)\n\t\tgoto out;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tparams.cipher = key->conf.cipher;\n\n\tswitch (key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tpn64 = atomic64_read(&key->conf.tx_pn);\n\t\tiv32 = TKIP_PN_TO_IV32(pn64);\n\t\tiv16 = TKIP_PN_TO_IV16(pn64);\n\n\t\tif (key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE &&\n\t\t    !(key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV)) {\n\t\t\tdrv_get_key_seq(sdata->local, key, &kseq);\n\t\t\tiv32 = kseq.tkip.iv32;\n\t\t\tiv16 = kseq.tkip.iv16;\n\t\t}\n\n\t\tseq[0] = iv16 & 0xff;\n\t\tseq[1] = (iv16 >> 8) & 0xff;\n\t\tseq[2] = iv32 & 0xff;\n\t\tseq[3] = (iv32 >> 8) & 0xff;\n\t\tseq[4] = (iv32 >> 16) & 0xff;\n\t\tseq[5] = (iv32 >> 24) & 0xff;\n\t\tparams.seq = seq;\n\t\tparams.seq_len = 6;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tBUILD_BUG_ON(offsetof(typeof(kseq), ccmp) !=\n\t\t\t     offsetof(typeof(kseq), aes_cmac));\n\t\tfallthrough;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tBUILD_BUG_ON(offsetof(typeof(kseq), ccmp) !=\n\t\t\t     offsetof(typeof(kseq), aes_gmac));\n\t\tfallthrough;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tBUILD_BUG_ON(offsetof(typeof(kseq), ccmp) !=\n\t\t\t     offsetof(typeof(kseq), gcmp));\n\n\t\tif (key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE &&\n\t\t    !(key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV)) {\n\t\t\tdrv_get_key_seq(sdata->local, key, &kseq);\n\t\t\tmemcpy(seq, kseq.ccmp.pn, 6);\n\t\t} else {\n\t\t\tpn64 = atomic64_read(&key->conf.tx_pn);\n\t\t\tseq[0] = pn64;\n\t\t\tseq[1] = pn64 >> 8;\n\t\t\tseq[2] = pn64 >> 16;\n\t\t\tseq[3] = pn64 >> 24;\n\t\t\tseq[4] = pn64 >> 32;\n\t\t\tseq[5] = pn64 >> 40;\n\t\t}\n\t\tparams.seq = seq;\n\t\tparams.seq_len = 6;\n\t\tbreak;\n\tdefault:\n\t\tif (!(key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE))\n\t\t\tbreak;\n\t\tif (WARN_ON(key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV))\n\t\t\tbreak;\n\t\tdrv_get_key_seq(sdata->local, key, &kseq);\n\t\tparams.seq = kseq.hw.seq;\n\t\tparams.seq_len = kseq.hw.seq_len;\n\t\tbreak;\n\t}\n\n\tparams.key = key->conf.key;\n\tparams.key_len = key->conf.keylen;\n\n\tcallback(cookie, &params);\n\terr = 0;\n\n out:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic int ieee80211_config_default_key(struct wiphy *wiphy,\n\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\tint link_id, u8 key_idx, bool uni,\n\t\t\t\t\tbool multi)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_link_data *link =\n\t\tieee80211_link_or_deflink(sdata, link_id, false);\n\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tieee80211_set_default_key(link, key_idx, uni, multi);\n\n\treturn 0;\n}\n\nstatic int ieee80211_config_default_mgmt_key(struct wiphy *wiphy,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     int link_id, u8 key_idx)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_link_data *link =\n\t\tieee80211_link_or_deflink(sdata, link_id, true);\n\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tieee80211_set_default_mgmt_key(link, key_idx);\n\n\treturn 0;\n}\n\nstatic int ieee80211_config_default_beacon_key(struct wiphy *wiphy,\n\t\t\t\t\t       struct net_device *dev,\n\t\t\t\t\t       int link_id, u8 key_idx)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_link_data *link =\n\t\tieee80211_link_or_deflink(sdata, link_id, true);\n\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tieee80211_set_default_beacon_key(link, key_idx);\n\n\treturn 0;\n}\n\nvoid sta_set_rate_info_tx(struct sta_info *sta,\n\t\t\t  const struct ieee80211_tx_rate *rate,\n\t\t\t  struct rate_info *rinfo)\n{\n\trinfo->flags = 0;\n\tif (rate->flags & IEEE80211_TX_RC_MCS) {\n\t\trinfo->flags |= RATE_INFO_FLAGS_MCS;\n\t\trinfo->mcs = rate->idx;\n\t} else if (rate->flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\trinfo->flags |= RATE_INFO_FLAGS_VHT_MCS;\n\t\trinfo->mcs = ieee80211_rate_get_vht_mcs(rate);\n\t\trinfo->nss = ieee80211_rate_get_vht_nss(rate);\n\t} else {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tint shift = ieee80211_vif_get_shift(&sta->sdata->vif);\n\t\tu16 brate;\n\n\t\tsband = ieee80211_get_sband(sta->sdata);\n\t\tWARN_ON_ONCE(sband && !sband->bitrates);\n\t\tif (sband && sband->bitrates) {\n\t\t\tbrate = sband->bitrates[rate->idx].bitrate;\n\t\t\trinfo->legacy = DIV_ROUND_UP(brate, 1 << shift);\n\t\t}\n\t}\n\tif (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\trinfo->bw = RATE_INFO_BW_40;\n\telse if (rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH)\n\t\trinfo->bw = RATE_INFO_BW_80;\n\telse if (rate->flags & IEEE80211_TX_RC_160_MHZ_WIDTH)\n\t\trinfo->bw = RATE_INFO_BW_160;\n\telse\n\t\trinfo->bw = RATE_INFO_BW_20;\n\tif (rate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\trinfo->flags |= RATE_INFO_FLAGS_SHORT_GI;\n}\n\nstatic int ieee80211_dump_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  int idx, u8 *mac, struct station_info *sinfo)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_by_idx(sdata, idx);\n\tif (sta) {\n\t\tret = 0;\n\t\tmemcpy(mac, sta->sta.addr, ETH_ALEN);\n\t\tsta_set_sinfo(sta, sinfo, true);\n\t}\n\n\tmutex_unlock(&local->sta_mtx);\n\n\treturn ret;\n}\n\nstatic int ieee80211_dump_survey(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t int idx, struct survey_info *survey)\n{\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\n\treturn drv_get_survey(local, idx, survey);\n}\n\nstatic int ieee80211_get_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t const u8 *mac, struct station_info *sinfo)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_bss(sdata, mac);\n\tif (sta) {\n\t\tret = 0;\n\t\tsta_set_sinfo(sta, sinfo, true);\n\t}\n\n\tmutex_unlock(&local->sta_mtx);\n\n\treturn ret;\n}\n\nstatic int ieee80211_set_monitor_channel(struct wiphy *wiphy,\n\t\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct ieee80211_sub_if_data *sdata;\n\tint ret = 0;\n\n\tif (cfg80211_chandef_identical(&local->monitor_chandef, chandef))\n\t\treturn 0;\n\n\tif (local->use_chanctx) {\n\t\tsdata = wiphy_dereference(local->hw.wiphy,\n\t\t\t\t\t  local->monitor_sdata);\n\t\tif (sdata) {\n\t\t\tsdata_lock(sdata);\n\t\t\tmutex_lock(&local->mtx);\n\t\t\tieee80211_link_release_channel(&sdata->deflink);\n\t\t\tret = ieee80211_link_use_channel(&sdata->deflink,\n\t\t\t\t\t\t\t chandef,\n\t\t\t\t\t\t\t IEEE80211_CHANCTX_EXCLUSIVE);\n\t\t\tmutex_unlock(&local->mtx);\n\t\t\tsdata_unlock(sdata);\n\t\t}\n\t} else {\n\t\tmutex_lock(&local->mtx);\n\t\tif (local->open_count == local->monitors) {\n\t\t\tlocal->_oper_chandef = *chandef;\n\t\t\tieee80211_hw_config(local, 0);\n\t\t}\n\t\tmutex_unlock(&local->mtx);\n\t}\n\n\tif (ret == 0)\n\t\tlocal->monitor_chandef = *chandef;\n\n\treturn ret;\n}\n\nstatic int\nieee80211_set_probe_resp(struct ieee80211_sub_if_data *sdata,\n\t\t\t const u8 *resp, size_t resp_len,\n\t\t\t const struct ieee80211_csa_settings *csa,\n\t\t\t const struct ieee80211_color_change_settings *cca,\n\t\t\t struct ieee80211_link_data *link)\n{\n\tstruct probe_resp *new, *old;\n\n\tif (!resp || !resp_len)\n\t\treturn 1;\n\n\told = sdata_dereference(link->u.ap.probe_resp, sdata);\n\n\tnew = kzalloc(sizeof(struct probe_resp) + resp_len, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->len = resp_len;\n\tmemcpy(new->data, resp, resp_len);\n\n\tif (csa)\n\t\tmemcpy(new->cntdwn_counter_offsets, csa->counter_offsets_presp,\n\t\t       csa->n_counter_offsets_presp *\n\t\t       sizeof(new->cntdwn_counter_offsets[0]));\n\telse if (cca)\n\t\tnew->cntdwn_counter_offsets[0] = cca->counter_offset_presp;\n\n\trcu_assign_pointer(link->u.ap.probe_resp, new);\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n\n\treturn 0;\n}\n\nstatic int ieee80211_set_fils_discovery(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct cfg80211_fils_discovery *params,\n\t\t\t\t\tstruct ieee80211_link_data *link,\n\t\t\t\t\tstruct ieee80211_bss_conf *link_conf)\n{\n\tstruct fils_discovery_data *new, *old = NULL;\n\tstruct ieee80211_fils_discovery *fd;\n\n\tif (!params->tmpl || !params->tmpl_len)\n\t\treturn -EINVAL;\n\n\tfd = &link_conf->fils_discovery;\n\tfd->min_interval = params->min_interval;\n\tfd->max_interval = params->max_interval;\n\n\told = sdata_dereference(link->u.ap.fils_discovery, sdata);\n\tnew = kzalloc(sizeof(*new) + params->tmpl_len, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\tnew->len = params->tmpl_len;\n\tmemcpy(new->data, params->tmpl, params->tmpl_len);\n\trcu_assign_pointer(link->u.ap.fils_discovery, new);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n\n\treturn 0;\n}\n\nstatic int\nieee80211_set_unsol_bcast_probe_resp(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct cfg80211_unsol_bcast_probe_resp *params,\n\t\t\t\t     struct ieee80211_link_data *link,\n\t\t\t\t     struct ieee80211_bss_conf *link_conf)\n{\n\tstruct unsol_bcast_probe_resp_data *new, *old = NULL;\n\n\tif (!params->tmpl || !params->tmpl_len)\n\t\treturn -EINVAL;\n\n\told = sdata_dereference(link->u.ap.unsol_bcast_probe_resp, sdata);\n\tnew = kzalloc(sizeof(*new) + params->tmpl_len, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\tnew->len = params->tmpl_len;\n\tmemcpy(new->data, params->tmpl, params->tmpl_len);\n\trcu_assign_pointer(link->u.ap.unsol_bcast_probe_resp, new);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n\n\tlink_conf->unsol_bcast_probe_resp_interval = params->interval;\n\n\treturn 0;\n}\n\nstatic int ieee80211_set_ftm_responder_params(\n\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *lci, size_t lci_len,\n\t\t\t\tconst u8 *civicloc, size_t civicloc_len,\n\t\t\t\tstruct ieee80211_bss_conf *link_conf)\n{\n\tstruct ieee80211_ftm_responder_params *new, *old;\n\tu8 *pos;\n\tint len;\n\n\tif (!lci_len && !civicloc_len)\n\t\treturn 0;\n\n\told = link_conf->ftmr_params;\n\tlen = lci_len + civicloc_len;\n\n\tnew = kzalloc(sizeof(*new) + len, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tpos = (u8 *)(new + 1);\n\tif (lci_len) {\n\t\tnew->lci_len = lci_len;\n\t\tnew->lci = pos;\n\t\tmemcpy(pos, lci, lci_len);\n\t\tpos += lci_len;\n\t}\n\n\tif (civicloc_len) {\n\t\tnew->civicloc_len = civicloc_len;\n\t\tnew->civicloc = pos;\n\t\tmemcpy(pos, civicloc, civicloc_len);\n\t\tpos += civicloc_len;\n\t}\n\n\tlink_conf->ftmr_params = new;\n\tkfree(old);\n\n\treturn 0;\n}\n\nstatic int\nieee80211_copy_mbssid_beacon(u8 *pos, struct cfg80211_mbssid_elems *dst,\n\t\t\t     struct cfg80211_mbssid_elems *src)\n{\n\tint i, offset = 0;\n\n\tfor (i = 0; i < src->cnt; i++) {\n\t\tmemcpy(pos + offset, src->elem[i].data, src->elem[i].len);\n\t\tdst->elem[i].len = src->elem[i].len;\n\t\tdst->elem[i].data = pos + offset;\n\t\toffset += dst->elem[i].len;\n\t}\n\tdst->cnt = src->cnt;\n\n\treturn offset;\n}\n\nstatic int\nieee80211_copy_rnr_beacon(u8 *pos, struct cfg80211_rnr_elems *dst,\n\t\t\t  struct cfg80211_rnr_elems *src)\n{\n\tint i, offset = 0;\n\n\tfor (i = 0; i < src->cnt; i++) {\n\t\tmemcpy(pos + offset, src->elem[i].data, src->elem[i].len);\n\t\tdst->elem[i].len = src->elem[i].len;\n\t\tdst->elem[i].data = pos + offset;\n\t\toffset += dst->elem[i].len;\n\t}\n\tdst->cnt = src->cnt;\n\n\treturn offset;\n}\n\nstatic int\nieee80211_assign_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct ieee80211_link_data *link,\n\t\t\tstruct cfg80211_beacon_data *params,\n\t\t\tconst struct ieee80211_csa_settings *csa,\n\t\t\tconst struct ieee80211_color_change_settings *cca,\n\t\t\tu64 *changed)\n{\n\tstruct cfg80211_mbssid_elems *mbssid = NULL;\n\tstruct cfg80211_rnr_elems *rnr = NULL;\n\tstruct beacon_data *new, *old;\n\tint new_head_len, new_tail_len;\n\tint size, err;\n\tu64 _changed = BSS_CHANGED_BEACON;\n\tstruct ieee80211_bss_conf *link_conf = link->conf;\n\n\told = sdata_dereference(link->u.ap.beacon, sdata);\n\n\t \n\tif (!params->head && !old)\n\t\treturn -EINVAL;\n\n\t \n\tif (params->head)\n\t\tnew_head_len = params->head_len;\n\telse\n\t\tnew_head_len = old->head_len;\n\n\t \n\tif (params->tail || !old)\n\t\t \n\t\tnew_tail_len = params->tail_len;\n\telse\n\t\tnew_tail_len = old->tail_len;\n\n\tsize = sizeof(*new) + new_head_len + new_tail_len;\n\n\t \n\tif (params->mbssid_ies) {\n\t\tmbssid = params->mbssid_ies;\n\t\tsize += struct_size(new->mbssid_ies, elem, mbssid->cnt);\n\t\tif (params->rnr_ies) {\n\t\t\trnr = params->rnr_ies;\n\t\t\tsize += struct_size(new->rnr_ies, elem, rnr->cnt);\n\t\t}\n\t\tsize += ieee80211_get_mbssid_beacon_len(mbssid, rnr,\n\t\t\t\t\t\t\tmbssid->cnt);\n\t} else if (old && old->mbssid_ies) {\n\t\tmbssid = old->mbssid_ies;\n\t\tsize += struct_size(new->mbssid_ies, elem, mbssid->cnt);\n\t\tif (old && old->rnr_ies) {\n\t\t\trnr = old->rnr_ies;\n\t\t\tsize += struct_size(new->rnr_ies, elem, rnr->cnt);\n\t\t}\n\t\tsize += ieee80211_get_mbssid_beacon_len(mbssid, rnr,\n\t\t\t\t\t\t\tmbssid->cnt);\n\t}\n\n\tnew = kzalloc(size, GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t \n\n\t \n\tnew->head = ((u8 *) new) + sizeof(*new);\n\tnew->tail = new->head + new_head_len;\n\tnew->head_len = new_head_len;\n\tnew->tail_len = new_tail_len;\n\t \n\tif (mbssid) {\n\t\tu8 *pos = new->tail + new->tail_len;\n\n\t\tnew->mbssid_ies = (void *)pos;\n\t\tpos += struct_size(new->mbssid_ies, elem, mbssid->cnt);\n\t\tpos += ieee80211_copy_mbssid_beacon(pos, new->mbssid_ies,\n\t\t\t\t\t\t    mbssid);\n\t\tif (rnr) {\n\t\t\tnew->rnr_ies = (void *)pos;\n\t\t\tpos += struct_size(new->rnr_ies, elem, rnr->cnt);\n\t\t\tieee80211_copy_rnr_beacon(pos, new->rnr_ies, rnr);\n\t\t}\n\t\t \n\t\tlink_conf->bssid_indicator =\n\t\t\tilog2(__roundup_pow_of_two(mbssid->cnt + 1));\n\t}\n\n\tif (csa) {\n\t\tnew->cntdwn_current_counter = csa->count;\n\t\tmemcpy(new->cntdwn_counter_offsets, csa->counter_offsets_beacon,\n\t\t       csa->n_counter_offsets_beacon *\n\t\t       sizeof(new->cntdwn_counter_offsets[0]));\n\t} else if (cca) {\n\t\tnew->cntdwn_current_counter = cca->count;\n\t\tnew->cntdwn_counter_offsets[0] = cca->counter_offset_beacon;\n\t}\n\n\t \n\tif (params->head)\n\t\tmemcpy(new->head, params->head, new_head_len);\n\telse\n\t\tmemcpy(new->head, old->head, new_head_len);\n\n\t \n\tif (params->tail)\n\t\tmemcpy(new->tail, params->tail, new_tail_len);\n\telse\n\t\tif (old)\n\t\t\tmemcpy(new->tail, old->tail, new_tail_len);\n\n\terr = ieee80211_set_probe_resp(sdata, params->probe_resp,\n\t\t\t\t       params->probe_resp_len, csa, cca, link);\n\tif (err < 0) {\n\t\tkfree(new);\n\t\treturn err;\n\t}\n\tif (err == 0)\n\t\t_changed |= BSS_CHANGED_AP_PROBE_RESP;\n\n\tif (params->ftm_responder != -1) {\n\t\tlink_conf->ftm_responder = params->ftm_responder;\n\t\terr = ieee80211_set_ftm_responder_params(sdata,\n\t\t\t\t\t\t\t params->lci,\n\t\t\t\t\t\t\t params->lci_len,\n\t\t\t\t\t\t\t params->civicloc,\n\t\t\t\t\t\t\t params->civicloc_len,\n\t\t\t\t\t\t\t link_conf);\n\n\t\tif (err < 0) {\n\t\t\tkfree(new);\n\t\t\treturn err;\n\t\t}\n\n\t\t_changed |= BSS_CHANGED_FTM_RESPONDER;\n\t}\n\n\trcu_assign_pointer(link->u.ap.beacon, new);\n\tsdata->u.ap.active = true;\n\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n\n\t*changed |= _changed;\n\treturn 0;\n}\n\nstatic int ieee80211_start_ap(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct beacon_data *old;\n\tstruct ieee80211_sub_if_data *vlan;\n\tu64 changed = BSS_CHANGED_BEACON_INT |\n\t\t      BSS_CHANGED_BEACON_ENABLED |\n\t\t      BSS_CHANGED_BEACON |\n\t\t      BSS_CHANGED_P2P_PS |\n\t\t      BSS_CHANGED_TXPOWER |\n\t\t      BSS_CHANGED_TWT;\n\tint i, err;\n\tint prev_beacon_int;\n\tunsigned int link_id = params->beacon.link_id;\n\tstruct ieee80211_link_data *link;\n\tstruct ieee80211_bss_conf *link_conf;\n\n\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\tif (!link)\n\t\treturn -ENOLINK;\n\n\tlink_conf = link->conf;\n\n\told = sdata_dereference(link->u.ap.beacon, sdata);\n\tif (old)\n\t\treturn -EALREADY;\n\n\tif (params->smps_mode != NL80211_SMPS_OFF)\n\t\treturn -ENOTSUPP;\n\n\tlink->smps_mode = IEEE80211_SMPS_OFF;\n\n\tlink->needed_rx_chains = sdata->local->rx_chains;\n\n\tprev_beacon_int = link_conf->beacon_int;\n\tlink_conf->beacon_int = params->beacon_interval;\n\n\tif (params->ht_cap)\n\t\tlink_conf->ht_ldpc =\n\t\t\tparams->ht_cap->cap_info &\n\t\t\t\tcpu_to_le16(IEEE80211_HT_CAP_LDPC_CODING);\n\n\tif (params->vht_cap) {\n\t\tlink_conf->vht_ldpc =\n\t\t\tparams->vht_cap->vht_cap_info &\n\t\t\t\tcpu_to_le32(IEEE80211_VHT_CAP_RXLDPC);\n\t\tlink_conf->vht_su_beamformer =\n\t\t\tparams->vht_cap->vht_cap_info &\n\t\t\t\tcpu_to_le32(IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE);\n\t\tlink_conf->vht_su_beamformee =\n\t\t\tparams->vht_cap->vht_cap_info &\n\t\t\t\tcpu_to_le32(IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE);\n\t\tlink_conf->vht_mu_beamformer =\n\t\t\tparams->vht_cap->vht_cap_info &\n\t\t\t\tcpu_to_le32(IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE);\n\t\tlink_conf->vht_mu_beamformee =\n\t\t\tparams->vht_cap->vht_cap_info &\n\t\t\t\tcpu_to_le32(IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE);\n\t}\n\n\tif (params->he_cap && params->he_oper) {\n\t\tlink_conf->he_support = true;\n\t\tlink_conf->htc_trig_based_pkt_ext =\n\t\t\tle32_get_bits(params->he_oper->he_oper_params,\n\t\t\t      IEEE80211_HE_OPERATION_DFLT_PE_DURATION_MASK);\n\t\tlink_conf->frame_time_rts_th =\n\t\t\tle32_get_bits(params->he_oper->he_oper_params,\n\t\t\t      IEEE80211_HE_OPERATION_RTS_THRESHOLD_MASK);\n\t\tchanged |= BSS_CHANGED_HE_OBSS_PD;\n\n\t\tif (params->beacon.he_bss_color.enabled)\n\t\t\tchanged |= BSS_CHANGED_HE_BSS_COLOR;\n\t}\n\n\tif (params->he_cap) {\n\t\tlink_conf->he_ldpc =\n\t\t\tparams->he_cap->phy_cap_info[1] &\n\t\t\t\tIEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD;\n\t\tlink_conf->he_su_beamformer =\n\t\t\tparams->he_cap->phy_cap_info[3] &\n\t\t\t\tIEEE80211_HE_PHY_CAP3_SU_BEAMFORMER;\n\t\tlink_conf->he_su_beamformee =\n\t\t\tparams->he_cap->phy_cap_info[4] &\n\t\t\t\tIEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE;\n\t\tlink_conf->he_mu_beamformer =\n\t\t\tparams->he_cap->phy_cap_info[4] &\n\t\t\t\tIEEE80211_HE_PHY_CAP4_MU_BEAMFORMER;\n\t\tlink_conf->he_full_ul_mumimo =\n\t\t\tparams->he_cap->phy_cap_info[2] &\n\t\t\t\tIEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO;\n\t}\n\n\tif (params->eht_cap) {\n\t\tif (!link_conf->he_support)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tlink_conf->eht_support = true;\n\t\tlink_conf->eht_puncturing = params->punct_bitmap;\n\t\tchanged |= BSS_CHANGED_EHT_PUNCTURING;\n\n\t\tlink_conf->eht_su_beamformer =\n\t\t\tparams->eht_cap->fixed.phy_cap_info[0] &\n\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMER;\n\t\tlink_conf->eht_su_beamformee =\n\t\t\tparams->eht_cap->fixed.phy_cap_info[0] &\n\t\t\t\tIEEE80211_EHT_PHY_CAP0_SU_BEAMFORMEE;\n\t\tlink_conf->eht_mu_beamformer =\n\t\t\tparams->eht_cap->fixed.phy_cap_info[7] &\n\t\t\t\t(IEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_80MHZ |\n\t\t\t\t IEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_160MHZ |\n\t\t\t\t IEEE80211_EHT_PHY_CAP7_MU_BEAMFORMER_320MHZ);\n\t} else {\n\t\tlink_conf->eht_su_beamformer = false;\n\t\tlink_conf->eht_su_beamformee = false;\n\t\tlink_conf->eht_mu_beamformer = false;\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP &&\n\t    params->mbssid_config.tx_wdev) {\n\t\terr = ieee80211_set_ap_mbssid_options(sdata,\n\t\t\t\t\t\t      params->mbssid_config,\n\t\t\t\t\t\t      link_conf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmutex_lock(&local->mtx);\n\terr = ieee80211_link_use_channel(link, &params->chandef,\n\t\t\t\t\t IEEE80211_CHANCTX_SHARED);\n\tif (!err)\n\t\tieee80211_link_copy_chanctx_to_vlans(link, false);\n\tmutex_unlock(&local->mtx);\n\tif (err) {\n\t\tlink_conf->beacon_int = prev_beacon_int;\n\t\treturn err;\n\t}\n\n\t \n\tsdata->control_port_protocol = params->crypto.control_port_ethertype;\n\tsdata->control_port_no_encrypt = params->crypto.control_port_no_encrypt;\n\tsdata->control_port_over_nl80211 =\n\t\t\t\tparams->crypto.control_port_over_nl80211;\n\tsdata->control_port_no_preauth =\n\t\t\t\tparams->crypto.control_port_no_preauth;\n\n\tlist_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list) {\n\t\tvlan->control_port_protocol =\n\t\t\tparams->crypto.control_port_ethertype;\n\t\tvlan->control_port_no_encrypt =\n\t\t\tparams->crypto.control_port_no_encrypt;\n\t\tvlan->control_port_over_nl80211 =\n\t\t\tparams->crypto.control_port_over_nl80211;\n\t\tvlan->control_port_no_preauth =\n\t\t\tparams->crypto.control_port_no_preauth;\n\t}\n\n\tlink_conf->dtim_period = params->dtim_period;\n\tlink_conf->enable_beacon = true;\n\tlink_conf->allow_p2p_go_ps = sdata->vif.p2p;\n\tlink_conf->twt_responder = params->twt_responder;\n\tlink_conf->he_obss_pd = params->he_obss_pd;\n\tlink_conf->he_bss_color = params->beacon.he_bss_color;\n\tsdata->vif.cfg.s1g = params->chandef.chan->band ==\n\t\t\t\t  NL80211_BAND_S1GHZ;\n\n\tsdata->vif.cfg.ssid_len = params->ssid_len;\n\tif (params->ssid_len)\n\t\tmemcpy(sdata->vif.cfg.ssid, params->ssid,\n\t\t       params->ssid_len);\n\tlink_conf->hidden_ssid =\n\t\t(params->hidden_ssid != NL80211_HIDDEN_SSID_NOT_IN_USE);\n\n\tmemset(&link_conf->p2p_noa_attr, 0,\n\t       sizeof(link_conf->p2p_noa_attr));\n\tlink_conf->p2p_noa_attr.oppps_ctwindow =\n\t\tparams->p2p_ctwindow & IEEE80211_P2P_OPPPS_CTWINDOW_MASK;\n\tif (params->p2p_opp_ps)\n\t\tlink_conf->p2p_noa_attr.oppps_ctwindow |=\n\t\t\t\t\tIEEE80211_P2P_OPPPS_ENABLE_BIT;\n\n\tsdata->beacon_rate_set = false;\n\tif (wiphy_ext_feature_isset(local->hw.wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_BEACON_RATE_LEGACY)) {\n\t\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\t\tsdata->beacon_rateidx_mask[i] =\n\t\t\t\tparams->beacon_rate.control[i].legacy;\n\t\t\tif (sdata->beacon_rateidx_mask[i])\n\t\t\t\tsdata->beacon_rate_set = true;\n\t\t}\n\t}\n\n\tif (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL))\n\t\tlink_conf->beacon_tx_rate = params->beacon_rate;\n\n\terr = ieee80211_assign_beacon(sdata, link, &params->beacon, NULL, NULL,\n\t\t\t\t      &changed);\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (params->fils_discovery.max_interval) {\n\t\terr = ieee80211_set_fils_discovery(sdata,\n\t\t\t\t\t\t   &params->fils_discovery,\n\t\t\t\t\t\t   link, link_conf);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\tchanged |= BSS_CHANGED_FILS_DISCOVERY;\n\t}\n\n\tif (params->unsol_bcast_probe_resp.interval) {\n\t\terr = ieee80211_set_unsol_bcast_probe_resp(sdata,\n\t\t\t\t\t\t\t   &params->unsol_bcast_probe_resp,\n\t\t\t\t\t\t\t   link, link_conf);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\tchanged |= BSS_CHANGED_UNSOL_BCAST_PROBE_RESP;\n\t}\n\n\terr = drv_start_ap(sdata->local, sdata, link_conf);\n\tif (err) {\n\t\told = sdata_dereference(link->u.ap.beacon, sdata);\n\n\t\tif (old)\n\t\t\tkfree_rcu(old, rcu_head);\n\t\tRCU_INIT_POINTER(link->u.ap.beacon, NULL);\n\t\tsdata->u.ap.active = false;\n\t\tgoto error;\n\t}\n\n\tieee80211_recalc_dtim(local, sdata);\n\tieee80211_vif_cfg_change_notify(sdata, BSS_CHANGED_SSID);\n\tieee80211_link_info_change_notify(sdata, link, changed);\n\n\tnetif_carrier_on(dev);\n\tlist_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)\n\t\tnetif_carrier_on(vlan->dev);\n\n\treturn 0;\n\nerror:\n\tmutex_lock(&local->mtx);\n\tieee80211_link_release_channel(link);\n\tmutex_unlock(&local->mtx);\n\n\treturn err;\n}\n\nstatic int ieee80211_change_beacon(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t   struct cfg80211_beacon_data *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_link_data *link;\n\tstruct beacon_data *old;\n\tint err;\n\tstruct ieee80211_bss_conf *link_conf;\n\tu64 changed = 0;\n\n\tsdata_assert_lock(sdata);\n\n\tlink = sdata_dereference(sdata->link[params->link_id], sdata);\n\tif (!link)\n\t\treturn -ENOLINK;\n\n\tlink_conf = link->conf;\n\n\t \n\tif (link_conf->csa_active || link_conf->color_change_active)\n\t\treturn -EBUSY;\n\n\told = sdata_dereference(link->u.ap.beacon, sdata);\n\tif (!old)\n\t\treturn -ENOENT;\n\n\terr = ieee80211_assign_beacon(sdata, link, params, NULL, NULL,\n\t\t\t\t      &changed);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (params->he_bss_color_valid &&\n\t    params->he_bss_color.enabled != link_conf->he_bss_color.enabled) {\n\t\tlink_conf->he_bss_color.enabled = params->he_bss_color.enabled;\n\t\tchanged |= BSS_CHANGED_HE_BSS_COLOR;\n\t}\n\n\tieee80211_link_info_change_notify(sdata, link, changed);\n\treturn 0;\n}\n\nstatic void ieee80211_free_next_beacon(struct ieee80211_link_data *link)\n{\n\tif (!link->u.ap.next_beacon)\n\t\treturn;\n\n\tkfree(link->u.ap.next_beacon->mbssid_ies);\n\tkfree(link->u.ap.next_beacon->rnr_ies);\n\tkfree(link->u.ap.next_beacon);\n\tlink->u.ap.next_beacon = NULL;\n}\n\nstatic int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     unsigned int link_id)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_sub_if_data *vlan;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct beacon_data *old_beacon;\n\tstruct probe_resp *old_probe_resp;\n\tstruct fils_discovery_data *old_fils_discovery;\n\tstruct unsol_bcast_probe_resp_data *old_unsol_bcast_probe_resp;\n\tstruct cfg80211_chan_def chandef;\n\tstruct ieee80211_link_data *link =\n\t\tsdata_dereference(sdata->link[link_id], sdata);\n\tstruct ieee80211_bss_conf *link_conf = link->conf;\n\n\tsdata_assert_lock(sdata);\n\n\told_beacon = sdata_dereference(link->u.ap.beacon, sdata);\n\tif (!old_beacon)\n\t\treturn -ENOENT;\n\told_probe_resp = sdata_dereference(link->u.ap.probe_resp,\n\t\t\t\t\t   sdata);\n\told_fils_discovery = sdata_dereference(link->u.ap.fils_discovery,\n\t\t\t\t\t       sdata);\n\told_unsol_bcast_probe_resp =\n\t\tsdata_dereference(link->u.ap.unsol_bcast_probe_resp,\n\t\t\t\t  sdata);\n\n\t \n\tmutex_lock(&local->mtx);\n\tlink_conf->csa_active = false;\n\tlink_conf->color_change_active = false;\n\tif (link->csa_block_tx) {\n\t\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_CSA);\n\t\tlink->csa_block_tx = false;\n\t}\n\n\tmutex_unlock(&local->mtx);\n\n\tieee80211_free_next_beacon(link);\n\n\t \n\tlist_for_each_entry(vlan, &sdata->u.ap.vlans, u.vlan.list)\n\t\tnetif_carrier_off(vlan->dev);\n\tnetif_carrier_off(dev);\n\n\t \n\tsdata->u.ap.active = false;\n\tRCU_INIT_POINTER(link->u.ap.beacon, NULL);\n\tRCU_INIT_POINTER(link->u.ap.probe_resp, NULL);\n\tRCU_INIT_POINTER(link->u.ap.fils_discovery, NULL);\n\tRCU_INIT_POINTER(link->u.ap.unsol_bcast_probe_resp, NULL);\n\tkfree_rcu(old_beacon, rcu_head);\n\tif (old_probe_resp)\n\t\tkfree_rcu(old_probe_resp, rcu_head);\n\tif (old_fils_discovery)\n\t\tkfree_rcu(old_fils_discovery, rcu_head);\n\tif (old_unsol_bcast_probe_resp)\n\t\tkfree_rcu(old_unsol_bcast_probe_resp, rcu_head);\n\n\tkfree(link_conf->ftmr_params);\n\tlink_conf->ftmr_params = NULL;\n\n\tsdata->vif.mbssid_tx_vif = NULL;\n\tlink_conf->bssid_index = 0;\n\tlink_conf->nontransmitted = false;\n\tlink_conf->ema_ap = false;\n\tlink_conf->bssid_indicator = 0;\n\n\t__sta_info_flush(sdata, true);\n\tieee80211_free_keys(sdata, true);\n\n\tlink_conf->enable_beacon = false;\n\tsdata->beacon_rate_set = false;\n\tsdata->vif.cfg.ssid_len = 0;\n\tclear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED, &sdata->state);\n\tieee80211_link_info_change_notify(sdata, link,\n\t\t\t\t\t  BSS_CHANGED_BEACON_ENABLED);\n\n\tif (sdata->wdev.cac_started) {\n\t\tchandef = link_conf->chandef;\n\t\tcancel_delayed_work_sync(&link->dfs_cac_timer_work);\n\t\tcfg80211_cac_event(sdata->dev, &chandef,\n\t\t\t\t   NL80211_RADAR_CAC_ABORTED,\n\t\t\t\t   GFP_KERNEL);\n\t}\n\n\tdrv_stop_ap(sdata->local, sdata, link_conf);\n\n\t \n\tlocal->total_ps_buffered -= skb_queue_len(&sdata->u.ap.ps.bc_buf);\n\tieee80211_purge_tx_queue(&local->hw, &sdata->u.ap.ps.bc_buf);\n\n\tmutex_lock(&local->mtx);\n\tieee80211_link_copy_chanctx_to_vlans(link, true);\n\tieee80211_link_release_channel(link);\n\tmutex_unlock(&local->mtx);\n\n\treturn 0;\n}\n\nstatic int sta_apply_auth_flags(struct ieee80211_local *local,\n\t\t\t\tstruct sta_info *sta,\n\t\t\t\tu32 mask, u32 set)\n{\n\tint ret;\n\n\tif (mask & BIT(NL80211_STA_FLAG_AUTHENTICATED) &&\n\t    set & BIT(NL80211_STA_FLAG_AUTHENTICATED) &&\n\t    !test_sta_flag(sta, WLAN_STA_AUTH)) {\n\t\tret = sta_info_move_state(sta, IEEE80211_STA_AUTH);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (mask & BIT(NL80211_STA_FLAG_ASSOCIATED) &&\n\t    set & BIT(NL80211_STA_FLAG_ASSOCIATED) &&\n\t    !test_sta_flag(sta, WLAN_STA_ASSOC)) {\n\t\t \n\t\tif (!test_sta_flag(sta, WLAN_STA_RATE_CONTROL))\n\t\t\trate_control_rate_init(sta);\n\n\t\tret = sta_info_move_state(sta, IEEE80211_STA_ASSOC);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (mask & BIT(NL80211_STA_FLAG_AUTHORIZED)) {\n\t\tif (set & BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\t\tret = sta_info_move_state(sta, IEEE80211_STA_AUTHORIZED);\n\t\telse if (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tret = sta_info_move_state(sta, IEEE80211_STA_ASSOC);\n\t\telse\n\t\t\tret = 0;\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (mask & BIT(NL80211_STA_FLAG_ASSOCIATED) &&\n\t    !(set & BIT(NL80211_STA_FLAG_ASSOCIATED)) &&\n\t    test_sta_flag(sta, WLAN_STA_ASSOC)) {\n\t\tret = sta_info_move_state(sta, IEEE80211_STA_AUTH);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (mask & BIT(NL80211_STA_FLAG_AUTHENTICATED) &&\n\t    !(set & BIT(NL80211_STA_FLAG_AUTHENTICATED)) &&\n\t    test_sta_flag(sta, WLAN_STA_AUTH)) {\n\t\tret = sta_info_move_state(sta, IEEE80211_STA_NONE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void sta_apply_mesh_params(struct ieee80211_local *local,\n\t\t\t\t  struct sta_info *sta,\n\t\t\t\t  struct station_parameters *params)\n{\n#ifdef CONFIG_MAC80211_MESH\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tu64 changed = 0;\n\n\tif (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE) {\n\t\tswitch (params->plink_state) {\n\t\tcase NL80211_PLINK_ESTAB:\n\t\t\tif (sta->mesh->plink_state != NL80211_PLINK_ESTAB)\n\t\t\t\tchanged = mesh_plink_inc_estab_count(sdata);\n\t\t\tsta->mesh->plink_state = params->plink_state;\n\t\t\tsta->mesh->aid = params->peer_aid;\n\n\t\t\tieee80211_mps_sta_status_update(sta);\n\t\t\tchanged |= ieee80211_mps_set_sta_local_pm(sta,\n\t\t\t\t      sdata->u.mesh.mshcfg.power_mode);\n\n\t\t\tewma_mesh_tx_rate_avg_init(&sta->mesh->tx_rate_avg);\n\t\t\t \n\t\t\tewma_mesh_tx_rate_avg_add(&sta->mesh->tx_rate_avg, 10);\n\n\t\t\tbreak;\n\t\tcase NL80211_PLINK_LISTEN:\n\t\tcase NL80211_PLINK_BLOCKED:\n\t\tcase NL80211_PLINK_OPN_SNT:\n\t\tcase NL80211_PLINK_OPN_RCVD:\n\t\tcase NL80211_PLINK_CNF_RCVD:\n\t\tcase NL80211_PLINK_HOLDING:\n\t\t\tif (sta->mesh->plink_state == NL80211_PLINK_ESTAB)\n\t\t\t\tchanged = mesh_plink_dec_estab_count(sdata);\n\t\t\tsta->mesh->plink_state = params->plink_state;\n\n\t\t\tieee80211_mps_sta_status_update(sta);\n\t\t\tchanged |= ieee80211_mps_set_sta_local_pm(sta,\n\t\t\t\t\tNL80211_MESH_POWER_UNKNOWN);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (params->plink_action) {\n\tcase NL80211_PLINK_ACTION_NO_ACTION:\n\t\t \n\t\tbreak;\n\tcase NL80211_PLINK_ACTION_OPEN:\n\t\tchanged |= mesh_plink_open(sta);\n\t\tbreak;\n\tcase NL80211_PLINK_ACTION_BLOCK:\n\t\tchanged |= mesh_plink_block(sta);\n\t\tbreak;\n\t}\n\n\tif (params->local_pm)\n\t\tchanged |= ieee80211_mps_set_sta_local_pm(sta,\n\t\t\t\t\t\t\t  params->local_pm);\n\n\tieee80211_mbss_info_change_notify(sdata, changed);\n#endif\n}\n\nstatic int sta_link_apply_parameters(struct ieee80211_local *local,\n\t\t\t\t     struct sta_info *sta, bool new_link,\n\t\t\t\t     struct link_station_parameters *params)\n{\n\tint ret = 0;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tu32 link_id = params->link_id < 0 ? 0 : params->link_id;\n\tstruct ieee80211_link_data *link =\n\t\tsdata_dereference(sdata->link[link_id], sdata);\n\tstruct link_sta_info *link_sta =\n\t\trcu_dereference_protected(sta->link[link_id],\n\t\t\t\t\t  lockdep_is_held(&local->sta_mtx));\n\n\t \n\tif (params->link_id >= 0 && !new_link &&\n\t    !params->link_mac && !params->txpwr_set &&\n\t    !params->supported_rates_len &&\n\t    !params->ht_capa && !params->vht_capa &&\n\t    !params->he_capa && !params->eht_capa &&\n\t    !params->opmode_notif_used)\n\t\treturn 0;\n\n\tif (!link || !link_sta)\n\t\treturn -EINVAL;\n\n\tsband = ieee80211_get_link_sband(link);\n\tif (!sband)\n\t\treturn -EINVAL;\n\n\tif (params->link_mac) {\n\t\tif (new_link) {\n\t\t\tmemcpy(link_sta->addr, params->link_mac, ETH_ALEN);\n\t\t\tmemcpy(link_sta->pub->addr, params->link_mac, ETH_ALEN);\n\t\t} else if (!ether_addr_equal(link_sta->addr,\n\t\t\t\t\t     params->link_mac)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (new_link) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (params->txpwr_set) {\n\t\tlink_sta->pub->txpwr.type = params->txpwr.type;\n\t\tif (params->txpwr.type == NL80211_TX_POWER_LIMITED)\n\t\t\tlink_sta->pub->txpwr.power = params->txpwr.power;\n\t\tret = drv_sta_set_txpwr(local, sdata, sta);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (params->supported_rates &&\n\t    params->supported_rates_len) {\n\t\tieee80211_parse_bitrates(link->conf->chandef.width,\n\t\t\t\t\t sband, params->supported_rates,\n\t\t\t\t\t params->supported_rates_len,\n\t\t\t\t\t &link_sta->pub->supp_rates[sband->band]);\n\t}\n\n\tif (params->ht_capa)\n\t\tieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,\n\t\t\t\t\t\t  params->ht_capa, link_sta);\n\n\t \n\tif (params->vht_capa)\n\t\tieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,\n\t\t\t\t\t\t    params->vht_capa, NULL,\n\t\t\t\t\t\t    link_sta);\n\n\tif (params->he_capa)\n\t\tieee80211_he_cap_ie_to_sta_he_cap(sdata, sband,\n\t\t\t\t\t\t  (void *)params->he_capa,\n\t\t\t\t\t\t  params->he_capa_len,\n\t\t\t\t\t\t  (void *)params->he_6ghz_capa,\n\t\t\t\t\t\t  link_sta);\n\n\tif (params->he_capa && params->eht_capa)\n\t\tieee80211_eht_cap_ie_to_sta_eht_cap(sdata, sband,\n\t\t\t\t\t\t    (u8 *)params->he_capa,\n\t\t\t\t\t\t    params->he_capa_len,\n\t\t\t\t\t\t    params->eht_capa,\n\t\t\t\t\t\t    params->eht_capa_len,\n\t\t\t\t\t\t    link_sta);\n\n\tif (params->opmode_notif_used) {\n\t\t \n\t\t__ieee80211_vht_handle_opmode(sdata, link_sta,\n\t\t\t\t\t      params->opmode_notif,\n\t\t\t\t\t      sband->band);\n\t}\n\n\treturn ret;\n}\n\nstatic int sta_apply_parameters(struct ieee80211_local *local,\n\t\t\t\tstruct sta_info *sta,\n\t\t\t\tstruct station_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tu32 mask, set;\n\tint ret = 0;\n\n\tmask = params->sta_flags_mask;\n\tset = params->sta_flags_set;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\t \n\t\tif (mask & BIT(NL80211_STA_FLAG_AUTHENTICATED))\n\t\t\tmask |= BIT(NL80211_STA_FLAG_ASSOCIATED);\n\t\tif (set & BIT(NL80211_STA_FLAG_AUTHENTICATED))\n\t\t\tset |= BIT(NL80211_STA_FLAG_ASSOCIATED);\n\t} else if (test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t \n\t\tif (set & BIT(NL80211_STA_FLAG_AUTHORIZED)) {\n\t\t\tset |= BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t       BIT(NL80211_STA_FLAG_ASSOCIATED);\n\t\t\tmask |= BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\tBIT(NL80211_STA_FLAG_ASSOCIATED);\n\t\t}\n\t}\n\n\tif (mask & BIT(NL80211_STA_FLAG_WME) &&\n\t    local->hw.queues >= IEEE80211_NUM_ACS)\n\t\tsta->sta.wme = set & BIT(NL80211_STA_FLAG_WME);\n\n\t \n\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER) &&\n\t    !((mask & BIT(NL80211_STA_FLAG_ASSOCIATED)) &&\n\t      (set & BIT(NL80211_STA_FLAG_ASSOCIATED)))) {\n\t\tret = sta_apply_auth_flags(local, sta, mask, set);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (mask & BIT(NL80211_STA_FLAG_SHORT_PREAMBLE)) {\n\t\tif (set & BIT(NL80211_STA_FLAG_SHORT_PREAMBLE))\n\t\t\tset_sta_flag(sta, WLAN_STA_SHORT_PREAMBLE);\n\t\telse\n\t\t\tclear_sta_flag(sta, WLAN_STA_SHORT_PREAMBLE);\n\t}\n\n\tif (mask & BIT(NL80211_STA_FLAG_MFP)) {\n\t\tsta->sta.mfp = !!(set & BIT(NL80211_STA_FLAG_MFP));\n\t\tif (set & BIT(NL80211_STA_FLAG_MFP))\n\t\t\tset_sta_flag(sta, WLAN_STA_MFP);\n\t\telse\n\t\t\tclear_sta_flag(sta, WLAN_STA_MFP);\n\t}\n\n\tif (mask & BIT(NL80211_STA_FLAG_TDLS_PEER)) {\n\t\tif (set & BIT(NL80211_STA_FLAG_TDLS_PEER))\n\t\t\tset_sta_flag(sta, WLAN_STA_TDLS_PEER);\n\t\telse\n\t\t\tclear_sta_flag(sta, WLAN_STA_TDLS_PEER);\n\t}\n\n\t \n\tif (test_sta_flag(sta, WLAN_STA_TDLS_PEER) &&\n\t    !sdata->deflink.u.mgd.tdls_chan_switch_prohibited &&\n\t    params->ext_capab_len >= 4 &&\n\t    params->ext_capab[3] & WLAN_EXT_CAPA4_TDLS_CHAN_SWITCH)\n\t\tset_sta_flag(sta, WLAN_STA_TDLS_CHAN_SWITCH);\n\n\tif (test_sta_flag(sta, WLAN_STA_TDLS_PEER) &&\n\t    !sdata->u.mgd.tdls_wider_bw_prohibited &&\n\t    ieee80211_hw_check(&local->hw, TDLS_WIDER_BW) &&\n\t    params->ext_capab_len >= 8 &&\n\t    params->ext_capab[7] & WLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED)\n\t\tset_sta_flag(sta, WLAN_STA_TDLS_WIDER_BW);\n\n\tif (params->sta_modify_mask & STATION_PARAM_APPLY_UAPSD) {\n\t\tsta->sta.uapsd_queues = params->uapsd_queues;\n\t\tsta->sta.max_sp = params->max_sp;\n\t}\n\n\tieee80211_sta_set_max_amsdu_subframes(sta, params->ext_capab,\n\t\t\t\t\t      params->ext_capab_len);\n\n\t \n\tif (params->aid)\n\t\tsta->sta.aid = params->aid;\n\n\t \n\n\tif (params->listen_interval >= 0)\n\t\tsta->listen_interval = params->listen_interval;\n\n\tret = sta_link_apply_parameters(local, sta, false,\n\t\t\t\t\t&params->link_sta_params);\n\tif (ret)\n\t\treturn ret;\n\n\tif (params->support_p2p_ps >= 0)\n\t\tsta->sta.support_p2p_ps = params->support_p2p_ps;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tsta_apply_mesh_params(local, sta, params);\n\n\tif (params->airtime_weight)\n\t\tsta->airtime_weight = params->airtime_weight;\n\n\t \n\tif (test_sta_flag(sta, WLAN_STA_TDLS_PEER) ||\n\t    set & BIT(NL80211_STA_FLAG_ASSOCIATED)) {\n\t\tret = sta_apply_auth_flags(local, sta, mask, set);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (params->link_sta_params.mld_mac)\n\t\tsta->sta.mlo = true;\n\n\treturn 0;\n}\n\nstatic int ieee80211_add_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t const u8 *mac,\n\t\t\t\t struct station_parameters *params)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *sdata;\n\tint err;\n\n\tif (params->vlan) {\n\t\tsdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tif (ether_addr_equal(mac, sdata->vif.addr))\n\t\treturn -EINVAL;\n\n\tif (!is_valid_ether_addr(mac))\n\t\treturn -EINVAL;\n\n\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER) &&\n\t    sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    !sdata->u.mgd.associated)\n\t\treturn -EINVAL;\n\n\t \n\tif (params->link_sta_params.link_id >= 0)\n\t\tsta = sta_info_alloc_with_link(sdata, mac,\n\t\t\t\t\t       params->link_sta_params.link_id,\n\t\t\t\t\t       params->link_sta_params.link_mac ?: mac,\n\t\t\t\t\t       GFP_KERNEL);\n\telse\n\t\tsta = sta_info_alloc(sdata, mac, GFP_KERNEL);\n\n\tif (!sta)\n\t\treturn -ENOMEM;\n\n\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))\n\t\tsta->sta.tdls = true;\n\n\t \n\tmutex_lock(&local->sta_mtx);\n\terr = sta_apply_parameters(local, sta, params);\n\tmutex_unlock(&local->sta_mtx);\n\tif (err) {\n\t\tsta_info_free(local, sta);\n\t\treturn err;\n\t}\n\n\t \n\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER) &&\n\t    test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\trate_control_rate_init(sta);\n\n\treturn sta_info_insert(sta);\n}\n\nstatic int ieee80211_del_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t struct station_del_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tif (params->mac)\n\t\treturn sta_info_destroy_addr_bss(sdata, params->mac);\n\n\tsta_info_flush(sdata);\n\treturn 0;\n}\n\nstatic int ieee80211_change_station(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev, const u8 *mac,\n\t\t\t\t    struct station_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *vlansdata;\n\tenum cfg80211_station_type statype;\n\tint err;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_bss(sdata, mac);\n\tif (!sta) {\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (sdata->u.mesh.user_mpm)\n\t\t\tstatype = CFG80211_STA_MESH_PEER_USER;\n\t\telse\n\t\t\tstatype = CFG80211_STA_MESH_PEER_KERNEL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tstatype = CFG80211_STA_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\tstatype = CFG80211_STA_AP_STA;\n\t\t\tbreak;\n\t\t}\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_ACTIVE;\n\t\telse\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_SETUP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\t\tstatype = CFG80211_STA_AP_CLIENT;\n\t\telse\n\t\t\tstatype = CFG80211_STA_AP_CLIENT_UNASSOC;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\terr = cfg80211_check_station_change(wiphy, params, statype);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (params->vlan && params->vlan != sta->sdata->dev) {\n\t\tvlansdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n\n\t\tif (params->vlan->ieee80211_ptr->use_4addr) {\n\t\t\tif (vlansdata->u.vlan.sta) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\trcu_assign_pointer(vlansdata->u.vlan.sta, sta);\n\t\t\t__ieee80211_check_fast_rx_iface(vlansdata);\n\t\t\tdrv_sta_set_4addr(local, sta->sdata, &sta->sta, true);\n\t\t}\n\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t    sta->sdata->u.vlan.sta) {\n\t\t\tieee80211_clear_fast_rx(sta);\n\t\t\tRCU_INIT_POINTER(sta->sdata->u.vlan.sta, NULL);\n\t\t}\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tieee80211_vif_dec_num_mcast(sta->sdata);\n\n\t\tsta->sdata = vlansdata;\n\t\tieee80211_check_fast_xmit(sta);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {\n\t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n\t\t\tcfg80211_send_layer2_update(sta->sdata->dev,\n\t\t\t\t\t\t    sta->sta.addr);\n\t\t}\n\t}\n\n\t \n\tif (sdata != sta->sdata) {\n\t\tmutex_lock_nested(&sta->sdata->wdev.mtx, 1);\n\t\terr = sta_apply_parameters(local, sta, params);\n\t\tmutex_unlock(&sta->sdata->wdev.mtx);\n\t} else {\n\t\terr = sta_apply_parameters(local, sta, params);\n\t}\n\tif (err)\n\t\tgoto out_err;\n\n\tmutex_unlock(&local->sta_mtx);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)) {\n\t\tieee80211_recalc_ps(local);\n\t\tieee80211_recalc_ps_vif(sdata);\n\t}\n\n\treturn 0;\nout_err:\n\tmutex_unlock(&local->sta_mtx);\n\treturn err;\n}\n\n#ifdef CONFIG_MAC80211_MESH\nstatic int ieee80211_add_mpath(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const u8 *dst, const u8 *next_hop)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct mesh_path *mpath;\n\tstruct sta_info *sta;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\trcu_read_lock();\n\tsta = sta_info_get(sdata, next_hop);\n\tif (!sta) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\tmpath = mesh_path_add(sdata, dst);\n\tif (IS_ERR(mpath)) {\n\t\trcu_read_unlock();\n\t\treturn PTR_ERR(mpath);\n\t}\n\n\tmesh_path_fix_nexthop(mpath, sta);\n\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic int ieee80211_del_mpath(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const u8 *dst)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tif (dst)\n\t\treturn mesh_path_del(sdata, dst);\n\n\tmesh_path_flush_by_iface(sdata);\n\treturn 0;\n}\n\nstatic int ieee80211_change_mpath(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const u8 *dst, const u8 *next_hop)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct mesh_path *mpath;\n\tstruct sta_info *sta;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\trcu_read_lock();\n\n\tsta = sta_info_get(sdata, next_hop);\n\tif (!sta) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\tmpath = mesh_path_lookup(sdata, dst);\n\tif (!mpath) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\tmesh_path_fix_nexthop(mpath, sta);\n\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic void mpath_set_pinfo(struct mesh_path *mpath, u8 *next_hop,\n\t\t\t    struct mpath_info *pinfo)\n{\n\tstruct sta_info *next_hop_sta = rcu_dereference(mpath->next_hop);\n\n\tif (next_hop_sta)\n\t\tmemcpy(next_hop, next_hop_sta->sta.addr, ETH_ALEN);\n\telse\n\t\teth_zero_addr(next_hop);\n\n\tmemset(pinfo, 0, sizeof(*pinfo));\n\n\tpinfo->generation = mpath->sdata->u.mesh.mesh_paths_generation;\n\n\tpinfo->filled = MPATH_INFO_FRAME_QLEN |\n\t\t\tMPATH_INFO_SN |\n\t\t\tMPATH_INFO_METRIC |\n\t\t\tMPATH_INFO_EXPTIME |\n\t\t\tMPATH_INFO_DISCOVERY_TIMEOUT |\n\t\t\tMPATH_INFO_DISCOVERY_RETRIES |\n\t\t\tMPATH_INFO_FLAGS |\n\t\t\tMPATH_INFO_HOP_COUNT |\n\t\t\tMPATH_INFO_PATH_CHANGE;\n\n\tpinfo->frame_qlen = mpath->frame_queue.qlen;\n\tpinfo->sn = mpath->sn;\n\tpinfo->metric = mpath->metric;\n\tif (time_before(jiffies, mpath->exp_time))\n\t\tpinfo->exptime = jiffies_to_msecs(mpath->exp_time - jiffies);\n\tpinfo->discovery_timeout =\n\t\t\tjiffies_to_msecs(mpath->discovery_timeout);\n\tpinfo->discovery_retries = mpath->discovery_retries;\n\tif (mpath->flags & MESH_PATH_ACTIVE)\n\t\tpinfo->flags |= NL80211_MPATH_FLAG_ACTIVE;\n\tif (mpath->flags & MESH_PATH_RESOLVING)\n\t\tpinfo->flags |= NL80211_MPATH_FLAG_RESOLVING;\n\tif (mpath->flags & MESH_PATH_SN_VALID)\n\t\tpinfo->flags |= NL80211_MPATH_FLAG_SN_VALID;\n\tif (mpath->flags & MESH_PATH_FIXED)\n\t\tpinfo->flags |= NL80211_MPATH_FLAG_FIXED;\n\tif (mpath->flags & MESH_PATH_RESOLVED)\n\t\tpinfo->flags |= NL80211_MPATH_FLAG_RESOLVED;\n\tpinfo->hop_count = mpath->hop_count;\n\tpinfo->path_change_count = mpath->path_change_count;\n}\n\nstatic int ieee80211_get_mpath(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       u8 *dst, u8 *next_hop, struct mpath_info *pinfo)\n\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct mesh_path *mpath;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\trcu_read_lock();\n\tmpath = mesh_path_lookup(sdata, dst);\n\tif (!mpath) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\tmemcpy(dst, mpath->dst, ETH_ALEN);\n\tmpath_set_pinfo(mpath, next_hop, pinfo);\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic int ieee80211_dump_mpath(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tint idx, u8 *dst, u8 *next_hop,\n\t\t\t\tstruct mpath_info *pinfo)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct mesh_path *mpath;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\trcu_read_lock();\n\tmpath = mesh_path_lookup_by_idx(sdata, idx);\n\tif (!mpath) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\tmemcpy(dst, mpath->dst, ETH_ALEN);\n\tmpath_set_pinfo(mpath, next_hop, pinfo);\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic void mpp_set_pinfo(struct mesh_path *mpath, u8 *mpp,\n\t\t\t  struct mpath_info *pinfo)\n{\n\tmemset(pinfo, 0, sizeof(*pinfo));\n\tmemcpy(mpp, mpath->mpp, ETH_ALEN);\n\n\tpinfo->generation = mpath->sdata->u.mesh.mpp_paths_generation;\n}\n\nstatic int ieee80211_get_mpp(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     u8 *dst, u8 *mpp, struct mpath_info *pinfo)\n\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct mesh_path *mpath;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\trcu_read_lock();\n\tmpath = mpp_path_lookup(sdata, dst);\n\tif (!mpath) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\tmemcpy(dst, mpath->dst, ETH_ALEN);\n\tmpp_set_pinfo(mpath, mpp, pinfo);\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic int ieee80211_dump_mpp(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      int idx, u8 *dst, u8 *mpp,\n\t\t\t      struct mpath_info *pinfo)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct mesh_path *mpath;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\trcu_read_lock();\n\tmpath = mpp_path_lookup_by_idx(sdata, idx);\n\tif (!mpath) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\tmemcpy(dst, mpath->dst, ETH_ALEN);\n\tmpp_set_pinfo(mpath, mpp, pinfo);\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic int ieee80211_get_mesh_config(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tstruct mesh_config *conf)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tmemcpy(conf, &(sdata->u.mesh.mshcfg), sizeof(struct mesh_config));\n\treturn 0;\n}\n\nstatic inline bool _chg_mesh_attr(enum nl80211_meshconf_params parm, u32 mask)\n{\n\treturn (mask >> (parm-1)) & 0x1;\n}\n\nstatic int copy_mesh_setup(struct ieee80211_if_mesh *ifmsh,\n\t\tconst struct mesh_setup *setup)\n{\n\tu8 *new_ie;\n\tstruct ieee80211_sub_if_data *sdata = container_of(ifmsh,\n\t\t\t\t\tstruct ieee80211_sub_if_data, u.mesh);\n\tint i;\n\n\t \n\tnew_ie = NULL;\n\n\tif (setup->ie_len) {\n\t\tnew_ie = kmemdup(setup->ie, setup->ie_len,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!new_ie)\n\t\t\treturn -ENOMEM;\n\t}\n\tifmsh->ie_len = setup->ie_len;\n\tifmsh->ie = new_ie;\n\n\t \n\tifmsh->mesh_id_len = setup->mesh_id_len;\n\tmemcpy(ifmsh->mesh_id, setup->mesh_id, ifmsh->mesh_id_len);\n\tifmsh->mesh_sp_id = setup->sync_method;\n\tifmsh->mesh_pp_id = setup->path_sel_proto;\n\tifmsh->mesh_pm_id = setup->path_metric;\n\tifmsh->user_mpm = setup->user_mpm;\n\tifmsh->mesh_auth_id = setup->auth_id;\n\tifmsh->security = IEEE80211_MESH_SEC_NONE;\n\tifmsh->userspace_handles_dfs = setup->userspace_handles_dfs;\n\tif (setup->is_authenticated)\n\t\tifmsh->security |= IEEE80211_MESH_SEC_AUTHED;\n\tif (setup->is_secure)\n\t\tifmsh->security |= IEEE80211_MESH_SEC_SECURED;\n\n\t \n\tmemcpy(sdata->vif.bss_conf.mcast_rate, setup->mcast_rate,\n\t\t\t\t\t\tsizeof(setup->mcast_rate));\n\tsdata->vif.bss_conf.basic_rates = setup->basic_rates;\n\n\tsdata->vif.bss_conf.beacon_int = setup->beacon_interval;\n\tsdata->vif.bss_conf.dtim_period = setup->dtim_period;\n\n\tsdata->beacon_rate_set = false;\n\tif (wiphy_ext_feature_isset(sdata->local->hw.wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_BEACON_RATE_LEGACY)) {\n\t\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\t\tsdata->beacon_rateidx_mask[i] =\n\t\t\t\tsetup->beacon_rate.control[i].legacy;\n\t\t\tif (sdata->beacon_rateidx_mask[i])\n\t\t\t\tsdata->beacon_rate_set = true;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ieee80211_update_mesh_config(struct wiphy *wiphy,\n\t\t\t\t\tstruct net_device *dev, u32 mask,\n\t\t\t\t\tconst struct mesh_config *nconf)\n{\n\tstruct mesh_config *conf;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_if_mesh *ifmsh;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tifmsh = &sdata->u.mesh;\n\n\t \n\tconf = &(sdata->u.mesh.mshcfg);\n\tif (_chg_mesh_attr(NL80211_MESHCONF_RETRY_TIMEOUT, mask))\n\t\tconf->dot11MeshRetryTimeout = nconf->dot11MeshRetryTimeout;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_CONFIRM_TIMEOUT, mask))\n\t\tconf->dot11MeshConfirmTimeout = nconf->dot11MeshConfirmTimeout;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_HOLDING_TIMEOUT, mask))\n\t\tconf->dot11MeshHoldingTimeout = nconf->dot11MeshHoldingTimeout;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_MAX_PEER_LINKS, mask))\n\t\tconf->dot11MeshMaxPeerLinks = nconf->dot11MeshMaxPeerLinks;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_MAX_RETRIES, mask))\n\t\tconf->dot11MeshMaxRetries = nconf->dot11MeshMaxRetries;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_TTL, mask))\n\t\tconf->dot11MeshTTL = nconf->dot11MeshTTL;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_ELEMENT_TTL, mask))\n\t\tconf->element_ttl = nconf->element_ttl;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_AUTO_OPEN_PLINKS, mask)) {\n\t\tif (ifmsh->user_mpm)\n\t\t\treturn -EBUSY;\n\t\tconf->auto_open_plinks = nconf->auto_open_plinks;\n\t}\n\tif (_chg_mesh_attr(NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR, mask))\n\t\tconf->dot11MeshNbrOffsetMaxNeighbor =\n\t\t\tnconf->dot11MeshNbrOffsetMaxNeighbor;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES, mask))\n\t\tconf->dot11MeshHWMPmaxPREQretries =\n\t\t\tnconf->dot11MeshHWMPmaxPREQretries;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_PATH_REFRESH_TIME, mask))\n\t\tconf->path_refresh_time = nconf->path_refresh_time;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT, mask))\n\t\tconf->min_discovery_timeout = nconf->min_discovery_timeout;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT, mask))\n\t\tconf->dot11MeshHWMPactivePathTimeout =\n\t\t\tnconf->dot11MeshHWMPactivePathTimeout;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL, mask))\n\t\tconf->dot11MeshHWMPpreqMinInterval =\n\t\t\tnconf->dot11MeshHWMPpreqMinInterval;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL, mask))\n\t\tconf->dot11MeshHWMPperrMinInterval =\n\t\t\tnconf->dot11MeshHWMPperrMinInterval;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\t   mask))\n\t\tconf->dot11MeshHWMPnetDiameterTraversalTime =\n\t\t\tnconf->dot11MeshHWMPnetDiameterTraversalTime;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_HWMP_ROOTMODE, mask)) {\n\t\tconf->dot11MeshHWMPRootMode = nconf->dot11MeshHWMPRootMode;\n\t\tieee80211_mesh_root_setup(ifmsh);\n\t}\n\tif (_chg_mesh_attr(NL80211_MESHCONF_GATE_ANNOUNCEMENTS, mask)) {\n\t\t \n\t\tif (nconf->dot11MeshGateAnnouncementProtocol &&\n\t\t    !(conf->dot11MeshHWMPRootMode > IEEE80211_ROOTMODE_ROOT)) {\n\t\t\tconf->dot11MeshHWMPRootMode = IEEE80211_PROACTIVE_RANN;\n\t\t\tieee80211_mesh_root_setup(ifmsh);\n\t\t}\n\t\tconf->dot11MeshGateAnnouncementProtocol =\n\t\t\tnconf->dot11MeshGateAnnouncementProtocol;\n\t}\n\tif (_chg_mesh_attr(NL80211_MESHCONF_HWMP_RANN_INTERVAL, mask))\n\t\tconf->dot11MeshHWMPRannInterval =\n\t\t\tnconf->dot11MeshHWMPRannInterval;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_FORWARDING, mask))\n\t\tconf->dot11MeshForwarding = nconf->dot11MeshForwarding;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_RSSI_THRESHOLD, mask)) {\n\t\t \n\t\tif (!ieee80211_hw_check(&sdata->local->hw, SIGNAL_DBM))\n\t\t\treturn -ENOTSUPP;\n\t\tconf->rssi_threshold = nconf->rssi_threshold;\n\t}\n\tif (_chg_mesh_attr(NL80211_MESHCONF_HT_OPMODE, mask)) {\n\t\tconf->ht_opmode = nconf->ht_opmode;\n\t\tsdata->vif.bss_conf.ht_operation_mode = nconf->ht_opmode;\n\t\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t\t  BSS_CHANGED_HT);\n\t}\n\tif (_chg_mesh_attr(NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT, mask))\n\t\tconf->dot11MeshHWMPactivePathToRootTimeout =\n\t\t\tnconf->dot11MeshHWMPactivePathToRootTimeout;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_HWMP_ROOT_INTERVAL, mask))\n\t\tconf->dot11MeshHWMProotInterval =\n\t\t\tnconf->dot11MeshHWMProotInterval;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL, mask))\n\t\tconf->dot11MeshHWMPconfirmationInterval =\n\t\t\tnconf->dot11MeshHWMPconfirmationInterval;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_POWER_MODE, mask)) {\n\t\tconf->power_mode = nconf->power_mode;\n\t\tieee80211_mps_local_status_update(sdata);\n\t}\n\tif (_chg_mesh_attr(NL80211_MESHCONF_AWAKE_WINDOW, mask))\n\t\tconf->dot11MeshAwakeWindowDuration =\n\t\t\tnconf->dot11MeshAwakeWindowDuration;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_PLINK_TIMEOUT, mask))\n\t\tconf->plink_timeout = nconf->plink_timeout;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_CONNECTED_TO_GATE, mask))\n\t\tconf->dot11MeshConnectedToMeshGate =\n\t\t\tnconf->dot11MeshConnectedToMeshGate;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_NOLEARN, mask))\n\t\tconf->dot11MeshNolearn = nconf->dot11MeshNolearn;\n\tif (_chg_mesh_attr(NL80211_MESHCONF_CONNECTED_TO_AS, mask))\n\t\tconf->dot11MeshConnectedToAuthServer =\n\t\t\tnconf->dot11MeshConnectedToAuthServer;\n\tieee80211_mbss_info_change_notify(sdata, BSS_CHANGED_BEACON);\n\treturn 0;\n}\n\nstatic int ieee80211_join_mesh(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const struct mesh_config *conf,\n\t\t\t       const struct mesh_setup *setup)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tint err;\n\n\tmemcpy(&ifmsh->mshcfg, conf, sizeof(struct mesh_config));\n\terr = copy_mesh_setup(ifmsh, setup);\n\tif (err)\n\t\treturn err;\n\n\tsdata->control_port_over_nl80211 = setup->control_port_over_nl80211;\n\n\t \n\tsdata->deflink.smps_mode = IEEE80211_SMPS_OFF;\n\tsdata->deflink.needed_rx_chains = sdata->local->rx_chains;\n\n\tmutex_lock(&sdata->local->mtx);\n\terr = ieee80211_link_use_channel(&sdata->deflink, &setup->chandef,\n\t\t\t\t\t IEEE80211_CHANCTX_SHARED);\n\tmutex_unlock(&sdata->local->mtx);\n\tif (err)\n\t\treturn err;\n\n\treturn ieee80211_start_mesh(sdata);\n}\n\nstatic int ieee80211_leave_mesh(struct wiphy *wiphy, struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tieee80211_stop_mesh(sdata);\n\tmutex_lock(&sdata->local->mtx);\n\tieee80211_link_release_channel(&sdata->deflink);\n\tkfree(sdata->u.mesh.ie);\n\tmutex_unlock(&sdata->local->mtx);\n\n\treturn 0;\n}\n#endif\n\nstatic int ieee80211_change_bss(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tstruct bss_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_link_data *link;\n\tstruct ieee80211_supported_band *sband;\n\tu64 changed = 0;\n\n\tlink = ieee80211_link_or_deflink(sdata, params->link_id, true);\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tif (!sdata_dereference(link->u.ap.beacon, sdata))\n\t\treturn -ENOENT;\n\n\tsband = ieee80211_get_link_sband(link);\n\tif (!sband)\n\t\treturn -EINVAL;\n\n\tif (params->basic_rates) {\n\t\tif (!ieee80211_parse_bitrates(link->conf->chandef.width,\n\t\t\t\t\t      wiphy->bands[sband->band],\n\t\t\t\t\t      params->basic_rates,\n\t\t\t\t\t      params->basic_rates_len,\n\t\t\t\t\t      &link->conf->basic_rates))\n\t\t\treturn -EINVAL;\n\t\tchanged |= BSS_CHANGED_BASIC_RATES;\n\t\tieee80211_check_rate_mask(link);\n\t}\n\n\tif (params->use_cts_prot >= 0) {\n\t\tlink->conf->use_cts_prot = params->use_cts_prot;\n\t\tchanged |= BSS_CHANGED_ERP_CTS_PROT;\n\t}\n\tif (params->use_short_preamble >= 0) {\n\t\tlink->conf->use_short_preamble = params->use_short_preamble;\n\t\tchanged |= BSS_CHANGED_ERP_PREAMBLE;\n\t}\n\n\tif (!link->conf->use_short_slot &&\n\t    (sband->band == NL80211_BAND_5GHZ ||\n\t     sband->band == NL80211_BAND_6GHZ)) {\n\t\tlink->conf->use_short_slot = true;\n\t\tchanged |= BSS_CHANGED_ERP_SLOT;\n\t}\n\n\tif (params->use_short_slot_time >= 0) {\n\t\tlink->conf->use_short_slot = params->use_short_slot_time;\n\t\tchanged |= BSS_CHANGED_ERP_SLOT;\n\t}\n\n\tif (params->ap_isolate >= 0) {\n\t\tif (params->ap_isolate)\n\t\t\tsdata->flags |= IEEE80211_SDATA_DONT_BRIDGE_PACKETS;\n\t\telse\n\t\t\tsdata->flags &= ~IEEE80211_SDATA_DONT_BRIDGE_PACKETS;\n\t\tieee80211_check_fast_rx_iface(sdata);\n\t}\n\n\tif (params->ht_opmode >= 0) {\n\t\tlink->conf->ht_operation_mode = (u16)params->ht_opmode;\n\t\tchanged |= BSS_CHANGED_HT;\n\t}\n\n\tif (params->p2p_ctwindow >= 0) {\n\t\tlink->conf->p2p_noa_attr.oppps_ctwindow &=\n\t\t\t\t\t~IEEE80211_P2P_OPPPS_CTWINDOW_MASK;\n\t\tlink->conf->p2p_noa_attr.oppps_ctwindow |=\n\t\t\tparams->p2p_ctwindow & IEEE80211_P2P_OPPPS_CTWINDOW_MASK;\n\t\tchanged |= BSS_CHANGED_P2P_PS;\n\t}\n\n\tif (params->p2p_opp_ps > 0) {\n\t\tlink->conf->p2p_noa_attr.oppps_ctwindow |=\n\t\t\t\t\tIEEE80211_P2P_OPPPS_ENABLE_BIT;\n\t\tchanged |= BSS_CHANGED_P2P_PS;\n\t} else if (params->p2p_opp_ps == 0) {\n\t\tlink->conf->p2p_noa_attr.oppps_ctwindow &=\n\t\t\t\t\t~IEEE80211_P2P_OPPPS_ENABLE_BIT;\n\t\tchanged |= BSS_CHANGED_P2P_PS;\n\t}\n\n\tieee80211_link_info_change_notify(sdata, link, changed);\n\n\treturn 0;\n}\n\nstatic int ieee80211_set_txq_params(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    struct ieee80211_txq_params *params)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_link_data *link =\n\t\tieee80211_link_or_deflink(sdata, params->link_id, true);\n\tstruct ieee80211_tx_queue_params p;\n\n\tif (!local->ops->conf_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tif (local->hw.queues < IEEE80211_NUM_ACS)\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ERR(link))\n\t\treturn PTR_ERR(link);\n\n\tmemset(&p, 0, sizeof(p));\n\tp.aifs = params->aifs;\n\tp.cw_max = params->cwmax;\n\tp.cw_min = params->cwmin;\n\tp.txop = params->txop;\n\n\t \n\tp.uapsd = false;\n\n\tieee80211_regulatory_limit_wmm_params(sdata, &p, params->ac);\n\n\tlink->tx_conf[params->ac] = p;\n\tif (drv_conf_tx(local, link, params->ac, &p)) {\n\t\twiphy_debug(local->hw.wiphy,\n\t\t\t    \"failed to set TX queue parameters for AC %d\\n\",\n\t\t\t    params->ac);\n\t\treturn -EINVAL;\n\t}\n\n\tieee80211_link_info_change_notify(sdata, link,\n\t\t\t\t\t  BSS_CHANGED_QOS);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int ieee80211_suspend(struct wiphy *wiphy,\n\t\t\t     struct cfg80211_wowlan *wowlan)\n{\n\treturn __ieee80211_suspend(wiphy_priv(wiphy), wowlan);\n}\n\nstatic int ieee80211_resume(struct wiphy *wiphy)\n{\n\treturn __ieee80211_resume(wiphy_priv(wiphy));\n}\n#else\n#define ieee80211_suspend NULL\n#define ieee80211_resume NULL\n#endif\n\nstatic int ieee80211_scan(struct wiphy *wiphy,\n\t\t\t  struct cfg80211_scan_request *req)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tsdata = IEEE80211_WDEV_TO_SUB_IF(req->wdev);\n\n\tswitch (ieee80211_vif_type_p2p(&sdata->vif)) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (sdata->local->ops->hw_scan)\n\t\t\tbreak;\n\t\t \n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\t \n\t\tif (sdata->deflink.u.ap.beacon &&\n\t\t    (!(wiphy->features & NL80211_FEATURE_AP_SCAN) ||\n\t\t     !(req->flags & NL80211_SCAN_FLAG_AP)))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ieee80211_request_scan(sdata, req);\n}\n\nstatic void ieee80211_abort_scan(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tieee80211_scan_cancel(wiphy_priv(wiphy));\n}\n\nstatic int\nieee80211_sched_scan_start(struct wiphy *wiphy,\n\t\t\t   struct net_device *dev,\n\t\t\t   struct cfg80211_sched_scan_request *req)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tif (!sdata->local->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ieee80211_request_sched_scan_start(sdata, req);\n}\n\nstatic int\nieee80211_sched_scan_stop(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  u64 reqid)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\n\tif (!local->ops->sched_scan_stop)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ieee80211_request_sched_scan_stop(local);\n}\n\nstatic int ieee80211_auth(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  struct cfg80211_auth_request *req)\n{\n\treturn ieee80211_mgd_auth(IEEE80211_DEV_TO_SUB_IF(dev), req);\n}\n\nstatic int ieee80211_assoc(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   struct cfg80211_assoc_request *req)\n{\n\treturn ieee80211_mgd_assoc(IEEE80211_DEV_TO_SUB_IF(dev), req);\n}\n\nstatic int ieee80211_deauth(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t    struct cfg80211_deauth_request *req)\n{\n\treturn ieee80211_mgd_deauth(IEEE80211_DEV_TO_SUB_IF(dev), req);\n}\n\nstatic int ieee80211_disassoc(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      struct cfg80211_disassoc_request *req)\n{\n\treturn ieee80211_mgd_disassoc(IEEE80211_DEV_TO_SUB_IF(dev), req);\n}\n\nstatic int ieee80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       struct cfg80211_ibss_params *params)\n{\n\treturn ieee80211_ibss_join(IEEE80211_DEV_TO_SUB_IF(dev), params);\n}\n\nstatic int ieee80211_leave_ibss(struct wiphy *wiphy, struct net_device *dev)\n{\n\treturn ieee80211_ibss_leave(IEEE80211_DEV_TO_SUB_IF(dev));\n}\n\nstatic int ieee80211_join_ocb(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      struct ocb_setup *setup)\n{\n\treturn ieee80211_ocb_join(IEEE80211_DEV_TO_SUB_IF(dev), setup);\n}\n\nstatic int ieee80211_leave_ocb(struct wiphy *wiphy, struct net_device *dev)\n{\n\treturn ieee80211_ocb_leave(IEEE80211_DEV_TO_SUB_IF(dev));\n}\n\nstatic int ieee80211_set_mcast_rate(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t    int rate[NUM_NL80211_BANDS])\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tmemcpy(sdata->vif.bss_conf.mcast_rate, rate,\n\t       sizeof(int) * NUM_NL80211_BANDS);\n\n\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t  BSS_CHANGED_MCAST_RATE);\n\n\treturn 0;\n}\n\nstatic int ieee80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tint err;\n\n\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD) {\n\t\tieee80211_check_fast_xmit_all(local);\n\n\t\terr = drv_set_frag_threshold(local, wiphy->frag_threshold);\n\n\t\tif (err) {\n\t\t\tieee80211_check_fast_xmit_all(local);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif ((changed & WIPHY_PARAM_COVERAGE_CLASS) ||\n\t    (changed & WIPHY_PARAM_DYN_ACK)) {\n\t\ts16 coverage_class;\n\n\t\tcoverage_class = changed & WIPHY_PARAM_COVERAGE_CLASS ?\n\t\t\t\t\twiphy->coverage_class : -1;\n\t\terr = drv_set_coverage_class(local, coverage_class);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (changed & WIPHY_PARAM_RTS_THRESHOLD) {\n\t\terr = drv_set_rts_threshold(local, wiphy->rts_threshold);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (changed & WIPHY_PARAM_RETRY_SHORT) {\n\t\tif (wiphy->retry_short > IEEE80211_MAX_TX_RETRY)\n\t\t\treturn -EINVAL;\n\t\tlocal->hw.conf.short_frame_max_tx_count = wiphy->retry_short;\n\t}\n\tif (changed & WIPHY_PARAM_RETRY_LONG) {\n\t\tif (wiphy->retry_long > IEEE80211_MAX_TX_RETRY)\n\t\t\treturn -EINVAL;\n\t\tlocal->hw.conf.long_frame_max_tx_count = wiphy->retry_long;\n\t}\n\tif (changed &\n\t    (WIPHY_PARAM_RETRY_SHORT | WIPHY_PARAM_RETRY_LONG))\n\t\tieee80211_hw_config(local, IEEE80211_CONF_CHANGE_RETRY_LIMITS);\n\n\tif (changed & (WIPHY_PARAM_TXQ_LIMIT |\n\t\t       WIPHY_PARAM_TXQ_MEMORY_LIMIT |\n\t\t       WIPHY_PARAM_TXQ_QUANTUM))\n\t\tieee80211_txq_set_params(local);\n\n\treturn 0;\n}\n\nstatic int ieee80211_set_tx_power(struct wiphy *wiphy,\n\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t  enum nl80211_tx_power_setting type, int mbm)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct ieee80211_sub_if_data *sdata;\n\tenum nl80211_tx_power_setting txp_type = type;\n\tbool update_txp_type = false;\n\tbool has_monitor = false;\n\n\tif (wdev) {\n\t\tsdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR) {\n\t\t\tsdata = wiphy_dereference(local->hw.wiphy,\n\t\t\t\t\t\t  local->monitor_sdata);\n\t\t\tif (!sdata)\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase NL80211_TX_POWER_AUTOMATIC:\n\t\t\tsdata->deflink.user_power_level =\n\t\t\t\tIEEE80211_UNSET_POWER_LEVEL;\n\t\t\ttxp_type = NL80211_TX_POWER_LIMITED;\n\t\t\tbreak;\n\t\tcase NL80211_TX_POWER_LIMITED:\n\t\tcase NL80211_TX_POWER_FIXED:\n\t\t\tif (mbm < 0 || (mbm % 100))\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tsdata->deflink.user_power_level = MBM_TO_DBM(mbm);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (txp_type != sdata->vif.bss_conf.txpower_type) {\n\t\t\tupdate_txp_type = true;\n\t\t\tsdata->vif.bss_conf.txpower_type = txp_type;\n\t\t}\n\n\t\tieee80211_recalc_txpower(sdata, update_txp_type);\n\n\t\treturn 0;\n\t}\n\n\tswitch (type) {\n\tcase NL80211_TX_POWER_AUTOMATIC:\n\t\tlocal->user_power_level = IEEE80211_UNSET_POWER_LEVEL;\n\t\ttxp_type = NL80211_TX_POWER_LIMITED;\n\t\tbreak;\n\tcase NL80211_TX_POWER_LIMITED:\n\tcase NL80211_TX_POWER_FIXED:\n\t\tif (mbm < 0 || (mbm % 100))\n\t\t\treturn -EOPNOTSUPP;\n\t\tlocal->user_power_level = MBM_TO_DBM(mbm);\n\t\tbreak;\n\t}\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR) {\n\t\t\thas_monitor = true;\n\t\t\tcontinue;\n\t\t}\n\t\tsdata->deflink.user_power_level = local->user_power_level;\n\t\tif (txp_type != sdata->vif.bss_conf.txpower_type)\n\t\t\tupdate_txp_type = true;\n\t\tsdata->vif.bss_conf.txpower_type = txp_type;\n\t}\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR)\n\t\t\tcontinue;\n\t\tieee80211_recalc_txpower(sdata, update_txp_type);\n\t}\n\tmutex_unlock(&local->iflist_mtx);\n\n\tif (has_monitor) {\n\t\tsdata = wiphy_dereference(local->hw.wiphy,\n\t\t\t\t\t  local->monitor_sdata);\n\t\tif (sdata) {\n\t\t\tsdata->deflink.user_power_level = local->user_power_level;\n\t\t\tif (txp_type != sdata->vif.bss_conf.txpower_type)\n\t\t\t\tupdate_txp_type = true;\n\t\t\tsdata->vif.bss_conf.txpower_type = txp_type;\n\n\t\t\tieee80211_recalc_txpower(sdata, update_txp_type);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ieee80211_get_tx_power(struct wiphy *wiphy,\n\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t  int *dbm)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\n\tif (local->ops->get_txpower)\n\t\treturn drv_get_txpower(local, sdata, dbm);\n\n\tif (!local->use_chanctx)\n\t\t*dbm = local->hw.conf.power_level;\n\telse\n\t\t*dbm = sdata->vif.bss_conf.txpower;\n\n\t \n\tif (*dbm == INT_MIN)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void ieee80211_rfkill_poll(struct wiphy *wiphy)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\n\tdrv_rfkill_poll(local);\n}\n\n#ifdef CONFIG_NL80211_TESTMODE\nstatic int ieee80211_testmode_cmd(struct wiphy *wiphy,\n\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t  void *data, int len)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct ieee80211_vif *vif = NULL;\n\n\tif (!local->ops->testmode_cmd)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev) {\n\t\tstruct ieee80211_sub_if_data *sdata;\n\n\t\tsdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\t\tif (sdata->flags & IEEE80211_SDATA_IN_DRIVER)\n\t\t\tvif = &sdata->vif;\n\t}\n\n\treturn local->ops->testmode_cmd(&local->hw, vif, data, len);\n}\n\nstatic int ieee80211_testmode_dump(struct wiphy *wiphy,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb,\n\t\t\t\t   void *data, int len)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\n\tif (!local->ops->testmode_dump)\n\t\treturn -EOPNOTSUPP;\n\n\treturn local->ops->testmode_dump(&local->hw, skb, cb, data, len);\n}\n#endif\n\nint __ieee80211_request_smps_mgd(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct ieee80211_link_data *link,\n\t\t\t\t enum ieee80211_smps_mode smps_mode)\n{\n\tconst u8 *ap;\n\tenum ieee80211_smps_mode old_req;\n\tint err;\n\tstruct sta_info *sta;\n\tbool tdls_peer_found = false;\n\n\tlockdep_assert_held(&sdata->wdev.mtx);\n\n\tif (WARN_ON_ONCE(sdata->vif.type != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\n\told_req = link->u.mgd.req_smps;\n\tlink->u.mgd.req_smps = smps_mode;\n\n\tif (old_req == smps_mode &&\n\t    smps_mode != IEEE80211_SMPS_AUTOMATIC)\n\t\treturn 0;\n\n\t \n\tif (!sdata->u.mgd.associated ||\n\t    link->conf->chandef.width == NL80211_CHAN_WIDTH_20_NOHT)\n\t\treturn 0;\n\n\tap = link->u.mgd.bssid;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &sdata->local->sta_list, list) {\n\t\tif (!sta->sta.tdls || sta->sdata != sdata || !sta->uploaded ||\n\t\t    !test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tcontinue;\n\n\t\ttdls_peer_found = true;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (smps_mode == IEEE80211_SMPS_AUTOMATIC) {\n\t\tif (tdls_peer_found || !sdata->u.mgd.powersave)\n\t\t\tsmps_mode = IEEE80211_SMPS_OFF;\n\t\telse\n\t\t\tsmps_mode = IEEE80211_SMPS_DYNAMIC;\n\t}\n\n\t \n\terr = ieee80211_send_smps_action(sdata, smps_mode,\n\t\t\t\t\t ap, ap);\n\tif (err)\n\t\tlink->u.mgd.req_smps = old_req;\n\telse if (smps_mode != IEEE80211_SMPS_OFF && tdls_peer_found)\n\t\tieee80211_teardown_tdls_peers(sdata);\n\n\treturn err;\n}\n\nstatic int ieee80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t    bool enabled, int timeout)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tunsigned int link_id;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_PS))\n\t\treturn -EOPNOTSUPP;\n\n\tif (enabled == sdata->u.mgd.powersave &&\n\t    timeout == local->dynamic_ps_forced_timeout)\n\t\treturn 0;\n\n\tsdata->u.mgd.powersave = enabled;\n\tlocal->dynamic_ps_forced_timeout = timeout;\n\n\t \n\tsdata_lock(sdata);\n\tfor (link_id = 0; link_id < ARRAY_SIZE(sdata->link); link_id++) {\n\t\tstruct ieee80211_link_data *link;\n\n\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\n\t\tif (!link)\n\t\t\tcontinue;\n\t\t__ieee80211_request_smps_mgd(sdata, link,\n\t\t\t\t\t     link->u.mgd.req_smps);\n\t}\n\tsdata_unlock(sdata);\n\n\tif (ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS))\n\t\tieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\n\n\tieee80211_recalc_ps(local);\n\tieee80211_recalc_ps_vif(sdata);\n\tieee80211_check_fast_rx_iface(sdata);\n\n\treturn 0;\n}\n\nstatic int ieee80211_set_cqm_rssi_config(struct wiphy *wiphy,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t s32 rssi_thold, u32 rssi_hyst)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_vif *vif = &sdata->vif;\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\n\tif (rssi_thold == bss_conf->cqm_rssi_thold &&\n\t    rssi_hyst == bss_conf->cqm_rssi_hyst)\n\t\treturn 0;\n\n\tif (sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER &&\n\t    !(sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI))\n\t\treturn -EOPNOTSUPP;\n\n\tbss_conf->cqm_rssi_thold = rssi_thold;\n\tbss_conf->cqm_rssi_hyst = rssi_hyst;\n\tbss_conf->cqm_rssi_low = 0;\n\tbss_conf->cqm_rssi_high = 0;\n\tsdata->deflink.u.mgd.last_cqm_event_signal = 0;\n\n\t \n\tif (sdata->u.mgd.associated &&\n\t    sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)\n\t\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t\t  BSS_CHANGED_CQM);\n\n\treturn 0;\n}\n\nstatic int ieee80211_set_cqm_rssi_range_config(struct wiphy *wiphy,\n\t\t\t\t\t       struct net_device *dev,\n\t\t\t\t\t       s32 rssi_low, s32 rssi_high)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_vif *vif = &sdata->vif;\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\n\tif (sdata->vif.driver_flags & IEEE80211_VIF_BEACON_FILTER)\n\t\treturn -EOPNOTSUPP;\n\n\tbss_conf->cqm_rssi_low = rssi_low;\n\tbss_conf->cqm_rssi_high = rssi_high;\n\tbss_conf->cqm_rssi_thold = 0;\n\tbss_conf->cqm_rssi_hyst = 0;\n\tsdata->deflink.u.mgd.last_cqm_event_signal = 0;\n\n\t \n\tif (sdata->u.mgd.associated &&\n\t    sdata->vif.driver_flags & IEEE80211_VIF_SUPPORTS_CQM_RSSI)\n\t\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t\t  BSS_CHANGED_CQM);\n\n\treturn 0;\n}\n\nstatic int ieee80211_set_bitrate_mask(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      unsigned int link_id,\n\t\t\t\t      const u8 *addr,\n\t\t\t\t      const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);\n\tint i, ret;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn -ENETDOWN;\n\n\t \n\tif (rcu_access_pointer(sdata->vif.bss_conf.chanctx_conf) &&\n\t    sdata->vif.bss_conf.chandef.chan) {\n\t\tu32 basic_rates = sdata->vif.bss_conf.basic_rates;\n\t\tenum nl80211_band band = sdata->vif.bss_conf.chandef.chan->band;\n\n\t\tif (!(mask->control[band].legacy & basic_rates))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL)) {\n\t\tret = drv_set_bitrate_mask(local, sdata, mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tstruct ieee80211_supported_band *sband = wiphy->bands[i];\n\t\tint j;\n\n\t\tsdata->rc_rateidx_mask[i] = mask->control[i].legacy;\n\t\tmemcpy(sdata->rc_rateidx_mcs_mask[i], mask->control[i].ht_mcs,\n\t\t       sizeof(mask->control[i].ht_mcs));\n\t\tmemcpy(sdata->rc_rateidx_vht_mcs_mask[i],\n\t\t       mask->control[i].vht_mcs,\n\t\t       sizeof(mask->control[i].vht_mcs));\n\n\t\tsdata->rc_has_mcs_mask[i] = false;\n\t\tsdata->rc_has_vht_mcs_mask[i] = false;\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < IEEE80211_HT_MCS_MASK_LEN; j++) {\n\t\t\tif (sdata->rc_rateidx_mcs_mask[i][j] != 0xff) {\n\t\t\t\tsdata->rc_has_mcs_mask[i] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = 0; j < NL80211_VHT_NSS_MAX; j++) {\n\t\t\tif (sdata->rc_rateidx_vht_mcs_mask[i][j] != 0xffff) {\n\t\t\t\tsdata->rc_has_vht_mcs_mask[i] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ieee80211_start_radar_detection(struct wiphy *wiphy,\n\t\t\t\t\t   struct net_device *dev,\n\t\t\t\t\t   struct cfg80211_chan_def *chandef,\n\t\t\t\t\t   u32 cac_time_ms)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tint err;\n\n\tmutex_lock(&local->mtx);\n\tif (!list_empty(&local->roc_list) || local->scanning) {\n\t\terr = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tsdata->deflink.smps_mode = IEEE80211_SMPS_OFF;\n\tsdata->deflink.needed_rx_chains = local->rx_chains;\n\n\terr = ieee80211_link_use_channel(&sdata->deflink, chandef,\n\t\t\t\t\t IEEE80211_CHANCTX_SHARED);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tieee80211_queue_delayed_work(&sdata->local->hw,\n\t\t\t\t     &sdata->deflink.dfs_cac_timer_work,\n\t\t\t\t     msecs_to_jiffies(cac_time_ms));\n\n out_unlock:\n\tmutex_unlock(&local->mtx);\n\treturn err;\n}\n\nstatic void ieee80211_end_cac(struct wiphy *wiphy,\n\t\t\t      struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\n\tmutex_lock(&local->mtx);\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t \n\t\tcancel_delayed_work(&sdata->deflink.dfs_cac_timer_work);\n\n\t\tif (sdata->wdev.cac_started) {\n\t\t\tieee80211_link_release_channel(&sdata->deflink);\n\t\t\tsdata->wdev.cac_started = false;\n\t\t}\n\t}\n\tmutex_unlock(&local->mtx);\n}\n\nstatic struct cfg80211_beacon_data *\ncfg80211_beacon_dup(struct cfg80211_beacon_data *beacon)\n{\n\tstruct cfg80211_beacon_data *new_beacon;\n\tu8 *pos;\n\tint len;\n\n\tlen = beacon->head_len + beacon->tail_len + beacon->beacon_ies_len +\n\t      beacon->proberesp_ies_len + beacon->assocresp_ies_len +\n\t      beacon->probe_resp_len + beacon->lci_len + beacon->civicloc_len;\n\n\tif (beacon->mbssid_ies)\n\t\tlen += ieee80211_get_mbssid_beacon_len(beacon->mbssid_ies,\n\t\t\t\t\t\t       beacon->rnr_ies,\n\t\t\t\t\t\t       beacon->mbssid_ies->cnt);\n\n\tnew_beacon = kzalloc(sizeof(*new_beacon) + len, GFP_KERNEL);\n\tif (!new_beacon)\n\t\treturn NULL;\n\n\tif (beacon->mbssid_ies && beacon->mbssid_ies->cnt) {\n\t\tnew_beacon->mbssid_ies =\n\t\t\tkzalloc(struct_size(new_beacon->mbssid_ies,\n\t\t\t\t\t    elem, beacon->mbssid_ies->cnt),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!new_beacon->mbssid_ies) {\n\t\t\tkfree(new_beacon);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (beacon->rnr_ies && beacon->rnr_ies->cnt) {\n\t\t\tnew_beacon->rnr_ies =\n\t\t\t\tkzalloc(struct_size(new_beacon->rnr_ies,\n\t\t\t\t\t\t    elem, beacon->rnr_ies->cnt),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!new_beacon->rnr_ies) {\n\t\t\t\tkfree(new_beacon->mbssid_ies);\n\t\t\t\tkfree(new_beacon);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tpos = (u8 *)(new_beacon + 1);\n\tif (beacon->head_len) {\n\t\tnew_beacon->head_len = beacon->head_len;\n\t\tnew_beacon->head = pos;\n\t\tmemcpy(pos, beacon->head, beacon->head_len);\n\t\tpos += beacon->head_len;\n\t}\n\tif (beacon->tail_len) {\n\t\tnew_beacon->tail_len = beacon->tail_len;\n\t\tnew_beacon->tail = pos;\n\t\tmemcpy(pos, beacon->tail, beacon->tail_len);\n\t\tpos += beacon->tail_len;\n\t}\n\tif (beacon->beacon_ies_len) {\n\t\tnew_beacon->beacon_ies_len = beacon->beacon_ies_len;\n\t\tnew_beacon->beacon_ies = pos;\n\t\tmemcpy(pos, beacon->beacon_ies, beacon->beacon_ies_len);\n\t\tpos += beacon->beacon_ies_len;\n\t}\n\tif (beacon->proberesp_ies_len) {\n\t\tnew_beacon->proberesp_ies_len = beacon->proberesp_ies_len;\n\t\tnew_beacon->proberesp_ies = pos;\n\t\tmemcpy(pos, beacon->proberesp_ies, beacon->proberesp_ies_len);\n\t\tpos += beacon->proberesp_ies_len;\n\t}\n\tif (beacon->assocresp_ies_len) {\n\t\tnew_beacon->assocresp_ies_len = beacon->assocresp_ies_len;\n\t\tnew_beacon->assocresp_ies = pos;\n\t\tmemcpy(pos, beacon->assocresp_ies, beacon->assocresp_ies_len);\n\t\tpos += beacon->assocresp_ies_len;\n\t}\n\tif (beacon->probe_resp_len) {\n\t\tnew_beacon->probe_resp_len = beacon->probe_resp_len;\n\t\tnew_beacon->probe_resp = pos;\n\t\tmemcpy(pos, beacon->probe_resp, beacon->probe_resp_len);\n\t\tpos += beacon->probe_resp_len;\n\t}\n\tif (beacon->mbssid_ies && beacon->mbssid_ies->cnt) {\n\t\tpos += ieee80211_copy_mbssid_beacon(pos,\n\t\t\t\t\t\t    new_beacon->mbssid_ies,\n\t\t\t\t\t\t    beacon->mbssid_ies);\n\t\tif (beacon->rnr_ies && beacon->rnr_ies->cnt)\n\t\t\tpos += ieee80211_copy_rnr_beacon(pos,\n\t\t\t\t\t\t\t new_beacon->rnr_ies,\n\t\t\t\t\t\t\t beacon->rnr_ies);\n\t}\n\n\t \n\tnew_beacon->ftm_responder = beacon->ftm_responder;\n\tif (beacon->lci) {\n\t\tnew_beacon->lci_len = beacon->lci_len;\n\t\tnew_beacon->lci = pos;\n\t\tmemcpy(pos, beacon->lci, beacon->lci_len);\n\t\tpos += beacon->lci_len;\n\t}\n\tif (beacon->civicloc) {\n\t\tnew_beacon->civicloc_len = beacon->civicloc_len;\n\t\tnew_beacon->civicloc = pos;\n\t\tmemcpy(pos, beacon->civicloc, beacon->civicloc_len);\n\t\tpos += beacon->civicloc_len;\n\t}\n\n\treturn new_beacon;\n}\n\nvoid ieee80211_csa_finish(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_local *local = sdata->local;\n\n\trcu_read_lock();\n\n\tif (vif->mbssid_tx_vif == vif) {\n\t\t \n\t\tstruct ieee80211_sub_if_data *iter;\n\n\t\tlist_for_each_entry_rcu(iter, &local->interfaces, list) {\n\t\t\tif (!ieee80211_sdata_running(iter))\n\t\t\t\tcontinue;\n\n\t\t\tif (iter == sdata || iter->vif.mbssid_tx_vif != vif)\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_queue_work(&iter->local->hw,\n\t\t\t\t\t     &iter->deflink.csa_finalize_work);\n\t\t}\n\t}\n\tieee80211_queue_work(&local->hw, &sdata->deflink.csa_finalize_work);\n\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ieee80211_csa_finish);\n\nvoid ieee80211_channel_switch_disconnect(struct ieee80211_vif *vif, bool block_tx)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_local *local = sdata->local;\n\n\tsdata->deflink.csa_block_tx = block_tx;\n\tsdata_info(sdata, \"channel switch failed, disconnecting\\n\");\n\twiphy_work_queue(local->hw.wiphy, &ifmgd->csa_connection_drop_work);\n}\nEXPORT_SYMBOL(ieee80211_channel_switch_disconnect);\n\nstatic int ieee80211_set_after_csa_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  u64 *changed)\n{\n\tint err;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tif (!sdata->deflink.u.ap.next_beacon)\n\t\t\treturn -EINVAL;\n\n\t\terr = ieee80211_assign_beacon(sdata, &sdata->deflink,\n\t\t\t\t\t      sdata->deflink.u.ap.next_beacon,\n\t\t\t\t\t      NULL, NULL, changed);\n\t\tieee80211_free_next_beacon(&sdata->deflink);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\terr = ieee80211_ibss_finish_csa(sdata, changed);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n#ifdef CONFIG_MAC80211_MESH\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\terr = ieee80211_mesh_finish_csa(sdata, changed);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __ieee80211_csa_finalize(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu64 changed = 0;\n\tint err;\n\n\tsdata_assert_lock(sdata);\n\tlockdep_assert_held(&local->mtx);\n\tlockdep_assert_held(&local->chanctx_mtx);\n\n\t \n\n\tif (sdata->deflink.reserved_chanctx) {\n\t\t \n\t\tif (sdata->deflink.reserved_ready)\n\t\t\treturn 0;\n\n\t\treturn ieee80211_link_use_reserved_context(&sdata->deflink);\n\t}\n\n\tif (!cfg80211_chandef_identical(&sdata->vif.bss_conf.chandef,\n\t\t\t\t\t&sdata->deflink.csa_chandef))\n\t\treturn -EINVAL;\n\n\tsdata->vif.bss_conf.csa_active = false;\n\n\terr = ieee80211_set_after_csa_beacon(sdata, &changed);\n\tif (err)\n\t\treturn err;\n\n\tif (sdata->vif.bss_conf.eht_puncturing != sdata->vif.bss_conf.csa_punct_bitmap) {\n\t\tsdata->vif.bss_conf.eht_puncturing =\n\t\t\t\t\tsdata->vif.bss_conf.csa_punct_bitmap;\n\t\tchanged |= BSS_CHANGED_EHT_PUNCTURING;\n\t}\n\n\tieee80211_link_info_change_notify(sdata, &sdata->deflink, changed);\n\n\tif (sdata->deflink.csa_block_tx) {\n\t\tieee80211_wake_vif_queues(local, sdata,\n\t\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_CSA);\n\t\tsdata->deflink.csa_block_tx = false;\n\t}\n\n\terr = drv_post_channel_switch(sdata);\n\tif (err)\n\t\treturn err;\n\n\tcfg80211_ch_switch_notify(sdata->dev, &sdata->deflink.csa_chandef, 0,\n\t\t\t\t  sdata->vif.bss_conf.eht_puncturing);\n\n\treturn 0;\n}\n\nstatic void ieee80211_csa_finalize(struct ieee80211_sub_if_data *sdata)\n{\n\tif (__ieee80211_csa_finalize(sdata)) {\n\t\tsdata_info(sdata, \"failed to finalize CSA, disconnecting\\n\");\n\t\tcfg80211_stop_iface(sdata->local->hw.wiphy, &sdata->wdev,\n\t\t\t\t    GFP_KERNEL);\n\t}\n}\n\nvoid ieee80211_csa_finalize_work(struct work_struct *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data,\n\t\t\t     deflink.csa_finalize_work);\n\tstruct ieee80211_local *local = sdata->local;\n\n\tsdata_lock(sdata);\n\tmutex_lock(&local->mtx);\n\tmutex_lock(&local->chanctx_mtx);\n\n\t \n\tif (!sdata->vif.bss_conf.csa_active)\n\t\tgoto unlock;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\tgoto unlock;\n\n\tieee80211_csa_finalize(sdata);\n\nunlock:\n\tmutex_unlock(&local->chanctx_mtx);\n\tmutex_unlock(&local->mtx);\n\tsdata_unlock(sdata);\n}\n\nstatic int ieee80211_set_csa_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct cfg80211_csa_settings *params,\n\t\t\t\t    u64 *changed)\n{\n\tstruct ieee80211_csa_settings csa = {};\n\tint err;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tsdata->deflink.u.ap.next_beacon =\n\t\t\tcfg80211_beacon_dup(&params->beacon_after);\n\t\tif (!sdata->deflink.u.ap.next_beacon)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tif (params->count <= 1)\n\t\t\tbreak;\n\n\t\tif ((params->n_counter_offsets_beacon >\n\t\t     IEEE80211_MAX_CNTDWN_COUNTERS_NUM) ||\n\t\t    (params->n_counter_offsets_presp >\n\t\t     IEEE80211_MAX_CNTDWN_COUNTERS_NUM)) {\n\t\t\tieee80211_free_next_beacon(&sdata->deflink);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcsa.counter_offsets_beacon = params->counter_offsets_beacon;\n\t\tcsa.counter_offsets_presp = params->counter_offsets_presp;\n\t\tcsa.n_counter_offsets_beacon = params->n_counter_offsets_beacon;\n\t\tcsa.n_counter_offsets_presp = params->n_counter_offsets_presp;\n\t\tcsa.count = params->count;\n\n\t\terr = ieee80211_assign_beacon(sdata, &sdata->deflink,\n\t\t\t\t\t      &params->beacon_csa, &csa,\n\t\t\t\t\t      NULL, changed);\n\t\tif (err < 0) {\n\t\t\tieee80211_free_next_beacon(&sdata->deflink);\n\t\t\treturn err;\n\t\t}\n\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (!sdata->vif.cfg.ibss_joined)\n\t\t\treturn -EINVAL;\n\n\t\tif (params->chandef.width != sdata->u.ibss.chandef.width)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (params->chandef.width) {\n\t\tcase NL80211_CHAN_WIDTH_40:\n\t\t\tif (cfg80211_get_chandef_type(&params->chandef) !=\n\t\t\t    cfg80211_get_chandef_type(&sdata->u.ibss.chandef))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_5:\n\t\tcase NL80211_CHAN_WIDTH_10:\n\t\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tcase NL80211_CHAN_WIDTH_20:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (sdata->u.ibss.chandef.chan->band !=\n\t\t    params->chandef.chan->band)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (params->count > 1) {\n\t\t\terr = ieee80211_ibss_csa_beacon(sdata, params, changed);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tieee80211_send_action_csa(sdata, params);\n\n\t\tbreak;\n#ifdef CONFIG_MAC80211_MESH\n\tcase NL80211_IFTYPE_MESH_POINT: {\n\t\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\t\t \n\t\tif (sdata->vif.bss_conf.chandef.chan->band !=\n\t\t    params->chandef.chan->band)\n\t\t\treturn -EINVAL;\n\n\t\tif (ifmsh->csa_role == IEEE80211_MESH_CSA_ROLE_NONE) {\n\t\t\tifmsh->csa_role = IEEE80211_MESH_CSA_ROLE_INIT;\n\t\t\tif (!ifmsh->pre_value)\n\t\t\t\tifmsh->pre_value = 1;\n\t\t\telse\n\t\t\t\tifmsh->pre_value++;\n\t\t}\n\n\t\t \n\t\tif (params->count > 1) {\n\t\t\terr = ieee80211_mesh_csa_beacon(sdata, params, changed);\n\t\t\tif (err < 0) {\n\t\t\t\tifmsh->csa_role = IEEE80211_MESH_CSA_ROLE_NONE;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tif (ifmsh->csa_role == IEEE80211_MESH_CSA_ROLE_INIT)\n\t\t\tieee80211_send_action_csa(sdata, params);\n\n\t\tbreak;\n\t\t}\n#endif\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void ieee80211_color_change_abort(struct ieee80211_sub_if_data  *sdata)\n{\n\tsdata->vif.bss_conf.color_change_active = false;\n\n\tieee80211_free_next_beacon(&sdata->deflink);\n\n\tcfg80211_color_change_aborted_notify(sdata->dev);\n}\n\nstatic int\n__ieee80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   struct cfg80211_csa_settings *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_channel_switch ch_switch;\n\tstruct ieee80211_chanctx_conf *conf;\n\tstruct ieee80211_chanctx *chanctx;\n\tu64 changed = 0;\n\tint err;\n\n\tsdata_assert_lock(sdata);\n\tlockdep_assert_held(&local->mtx);\n\n\tif (!list_empty(&local->roc_list) || local->scanning)\n\t\treturn -EBUSY;\n\n\tif (sdata->wdev.cac_started)\n\t\treturn -EBUSY;\n\n\tif (cfg80211_chandef_identical(&params->chandef,\n\t\t\t\t       &sdata->vif.bss_conf.chandef))\n\t\treturn -EINVAL;\n\n\t \n\tif (sdata->vif.bss_conf.csa_active)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&local->chanctx_mtx);\n\tconf = rcu_dereference_protected(sdata->vif.bss_conf.chanctx_conf,\n\t\t\t\t\t lockdep_is_held(&local->chanctx_mtx));\n\tif (!conf) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (params->chandef.chan->freq_offset) {\n\t\t \n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tchanctx = container_of(conf, struct ieee80211_chanctx, conf);\n\n\tch_switch.timestamp = 0;\n\tch_switch.device_timestamp = 0;\n\tch_switch.block_tx = params->block_tx;\n\tch_switch.chandef = params->chandef;\n\tch_switch.count = params->count;\n\n\terr = drv_pre_channel_switch(sdata, &ch_switch);\n\tif (err)\n\t\tgoto out;\n\n\terr = ieee80211_link_reserve_chanctx(&sdata->deflink, &params->chandef,\n\t\t\t\t\t     chanctx->mode,\n\t\t\t\t\t     params->radar_required);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = ieee80211_check_combinations(sdata, NULL, chanctx->mode, 0);\n\tif (err) {\n\t\tieee80211_link_unreserve_chanctx(&sdata->deflink);\n\t\tgoto out;\n\t}\n\n\t \n\tif (sdata->vif.bss_conf.color_change_active)\n\t\tieee80211_color_change_abort(sdata);\n\n\terr = ieee80211_set_csa_beacon(sdata, params, &changed);\n\tif (err) {\n\t\tieee80211_link_unreserve_chanctx(&sdata->deflink);\n\t\tgoto out;\n\t}\n\n\tif (params->punct_bitmap && !sdata->vif.bss_conf.eht_support)\n\t\tgoto out;\n\n\tsdata->deflink.csa_chandef = params->chandef;\n\tsdata->deflink.csa_block_tx = params->block_tx;\n\tsdata->vif.bss_conf.csa_active = true;\n\tsdata->vif.bss_conf.csa_punct_bitmap = params->punct_bitmap;\n\n\tif (sdata->deflink.csa_block_tx)\n\t\tieee80211_stop_vif_queues(local, sdata,\n\t\t\t\t\t  IEEE80211_QUEUE_STOP_REASON_CSA);\n\n\tcfg80211_ch_switch_started_notify(sdata->dev,\n\t\t\t\t\t  &sdata->deflink.csa_chandef, 0,\n\t\t\t\t\t  params->count, params->block_tx,\n\t\t\t\t\t  sdata->vif.bss_conf.csa_punct_bitmap);\n\n\tif (changed) {\n\t\tieee80211_link_info_change_notify(sdata, &sdata->deflink,\n\t\t\t\t\t\t  changed);\n\t\tdrv_channel_switch_beacon(sdata, &params->chandef);\n\t} else {\n\t\t \n\t\tieee80211_csa_finalize(sdata);\n\t}\n\nout:\n\tmutex_unlock(&local->chanctx_mtx);\n\treturn err;\n}\n\nint ieee80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     struct cfg80211_csa_settings *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tint err;\n\n\tmutex_lock(&local->mtx);\n\terr = __ieee80211_channel_switch(wiphy, dev, params);\n\tmutex_unlock(&local->mtx);\n\n\treturn err;\n}\n\nu64 ieee80211_mgmt_tx_cookie(struct ieee80211_local *local)\n{\n\tlockdep_assert_held(&local->mtx);\n\n\tlocal->roc_cookie_counter++;\n\n\t \n\tif (WARN_ON(local->roc_cookie_counter == 0))\n\t\tlocal->roc_cookie_counter++;\n\n\treturn local->roc_cookie_counter;\n}\n\nint ieee80211_attach_ack_skb(struct ieee80211_local *local, struct sk_buff *skb,\n\t\t\t     u64 *cookie, gfp_t gfp)\n{\n\tunsigned long spin_flags;\n\tstruct sk_buff *ack_skb;\n\tint id;\n\n\tack_skb = skb_copy(skb, gfp);\n\tif (!ack_skb)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&local->ack_status_lock, spin_flags);\n\tid = idr_alloc(&local->ack_status_frames, ack_skb,\n\t\t       1, 0x2000, GFP_ATOMIC);\n\tspin_unlock_irqrestore(&local->ack_status_lock, spin_flags);\n\n\tif (id < 0) {\n\t\tkfree_skb(ack_skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tIEEE80211_SKB_CB(skb)->ack_frame_id = id;\n\n\t*cookie = ieee80211_mgmt_tx_cookie(local);\n\tIEEE80211_SKB_CB(ack_skb)->ack.cookie = *cookie;\n\n\treturn 0;\n}\n\nstatic void\nieee80211_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t\t  struct mgmt_frame_regs *upd)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tu32 preq_mask = BIT(IEEE80211_STYPE_PROBE_REQ >> 4);\n\tu32 action_mask = BIT(IEEE80211_STYPE_ACTION >> 4);\n\tbool global_change, intf_change;\n\n\tglobal_change =\n\t\t(local->probe_req_reg != !!(upd->global_stypes & preq_mask)) ||\n\t\t(local->rx_mcast_action_reg !=\n\t\t !!(upd->global_mcast_stypes & action_mask));\n\tlocal->probe_req_reg = upd->global_stypes & preq_mask;\n\tlocal->rx_mcast_action_reg = upd->global_mcast_stypes & action_mask;\n\n\tintf_change = (sdata->vif.probe_req_reg !=\n\t\t       !!(upd->interface_stypes & preq_mask)) ||\n\t\t(sdata->vif.rx_mcast_action_reg !=\n\t\t !!(upd->interface_mcast_stypes & action_mask));\n\tsdata->vif.probe_req_reg = upd->interface_stypes & preq_mask;\n\tsdata->vif.rx_mcast_action_reg =\n\t\tupd->interface_mcast_stypes & action_mask;\n\n\tif (!local->open_count)\n\t\treturn;\n\n\tif (intf_change && ieee80211_sdata_running(sdata))\n\t\tdrv_config_iface_filter(local, sdata,\n\t\t\t\t\tsdata->vif.probe_req_reg ?\n\t\t\t\t\t\tFIF_PROBE_REQ : 0,\n\t\t\t\t\tFIF_PROBE_REQ);\n\n\tif (global_change)\n\t\tieee80211_configure_filter(local);\n}\n\nstatic int ieee80211_set_antenna(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\n\tif (local->started)\n\t\treturn -EOPNOTSUPP;\n\n\treturn drv_set_antenna(local, tx_ant, rx_ant);\n}\n\nstatic int ieee80211_get_antenna(struct wiphy *wiphy, u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\n\treturn drv_get_antenna(local, tx_ant, rx_ant);\n}\n\nstatic int ieee80211_set_rekey_data(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    struct cfg80211_gtk_rekey_data *data)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tif (!local->ops->set_rekey_data)\n\t\treturn -EOPNOTSUPP;\n\n\tdrv_set_rekey_data(local, sdata, data);\n\n\treturn 0;\n}\n\nstatic int ieee80211_probe_client(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t  const u8 *peer, u64 *cookie)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_qos_hdr *nullfunc;\n\tstruct sk_buff *skb;\n\tint size = sizeof(*nullfunc);\n\t__le16 fc;\n\tbool qos;\n\tstruct ieee80211_tx_info *info;\n\tstruct sta_info *sta;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tenum nl80211_band band;\n\tint ret;\n\n\t \n\tmutex_lock(&local->mtx);\n\n\trcu_read_lock();\n\tsta = sta_info_get_bss(sdata, peer);\n\tif (!sta) {\n\t\tret = -ENOLINK;\n\t\tgoto unlock;\n\t}\n\n\tqos = sta->sta.wme;\n\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tif (WARN_ON(!chanctx_conf)) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tband = chanctx_conf->def.chan->band;\n\n\tif (qos) {\n\t\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t IEEE80211_STYPE_QOS_NULLFUNC |\n\t\t\t\t IEEE80211_FCTL_FROMDS);\n\t} else {\n\t\tsize -= 2;\n\t\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA |\n\t\t\t\t IEEE80211_STYPE_NULLFUNC |\n\t\t\t\t IEEE80211_FCTL_FROMDS);\n\t}\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + size);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tskb->dev = dev;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tnullfunc = skb_put(skb, size);\n\tnullfunc->frame_control = fc;\n\tnullfunc->duration_id = 0;\n\tmemcpy(nullfunc->addr1, sta->sta.addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr2, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(nullfunc->addr3, sdata->vif.addr, ETH_ALEN);\n\tnullfunc->seq_ctrl = 0;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tinfo->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t       IEEE80211_TX_INTFL_NL80211_FRAME_TX;\n\tinfo->band = band;\n\n\tskb_set_queue_mapping(skb, IEEE80211_AC_VO);\n\tskb->priority = 7;\n\tif (qos)\n\t\tnullfunc->qos_ctrl = cpu_to_le16(7);\n\n\tret = ieee80211_attach_ack_skb(local, skb, cookie, GFP_ATOMIC);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\tgoto unlock;\n\t}\n\n\tlocal_bh_disable();\n\tieee80211_xmit(sdata, sta, skb);\n\tlocal_bh_enable();\n\n\tret = 0;\nunlock:\n\trcu_read_unlock();\n\tmutex_unlock(&local->mtx);\n\n\treturn ret;\n}\n\nstatic int ieee80211_cfg_get_channel(struct wiphy *wiphy,\n\t\t\t\t     struct wireless_dev *wdev,\n\t\t\t\t     unsigned int link_id,\n\t\t\t\t     struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_link_data *link;\n\tint ret = -ENODATA;\n\n\trcu_read_lock();\n\tlink = rcu_dereference(sdata->link[link_id]);\n\tif (!link) {\n\t\tret = -ENOLINK;\n\t\tgoto out;\n\t}\n\n\tchanctx_conf = rcu_dereference(link->conf->chanctx_conf);\n\tif (chanctx_conf) {\n\t\t*chandef = link->conf->chandef;\n\t\tret = 0;\n\t} else if (local->open_count > 0 &&\n\t\t   local->open_count == local->monitors &&\n\t\t   sdata->vif.type == NL80211_IFTYPE_MONITOR) {\n\t\tif (local->use_chanctx)\n\t\t\t*chandef = local->monitor_chandef;\n\t\telse\n\t\t\t*chandef = local->_oper_chandef;\n\t\tret = 0;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic void ieee80211_set_wakeup(struct wiphy *wiphy, bool enabled)\n{\n\tdrv_set_wakeup(wiphy_priv(wiphy), enabled);\n}\n#endif\n\nstatic int ieee80211_set_qos_map(struct wiphy *wiphy,\n\t\t\t\t struct net_device *dev,\n\t\t\t\t struct cfg80211_qos_map *qos_map)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct mac80211_qos_map *new_qos_map, *old_qos_map;\n\n\tif (qos_map) {\n\t\tnew_qos_map = kzalloc(sizeof(*new_qos_map), GFP_KERNEL);\n\t\tif (!new_qos_map)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(&new_qos_map->qos_map, qos_map, sizeof(*qos_map));\n\t} else {\n\t\t \n\t\tnew_qos_map = NULL;\n\t}\n\n\told_qos_map = sdata_dereference(sdata->qos_map, sdata);\n\trcu_assign_pointer(sdata->qos_map, new_qos_map);\n\tif (old_qos_map)\n\t\tkfree_rcu(old_qos_map, rcu_head);\n\n\treturn 0;\n}\n\nstatic int ieee80211_set_ap_chanwidth(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      unsigned int link_id,\n\t\t\t\t      struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_link_data *link;\n\tint ret;\n\tu64 changed = 0;\n\n\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\n\tret = ieee80211_link_change_bandwidth(link, chandef, &changed);\n\tif (ret == 0)\n\t\tieee80211_link_info_change_notify(sdata, link, changed);\n\n\treturn ret;\n}\n\nstatic int ieee80211_add_tx_ts(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       u8 tsid, const u8 *peer, u8 up,\n\t\t\t       u16 admitted_time)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tint ac = ieee802_1d_to_ac[up];\n\n\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(sdata->wmm_acm & BIT(up)))\n\t\treturn -EINVAL;\n\n\tif (ifmgd->tx_tspec[ac].admitted_time)\n\t\treturn -EBUSY;\n\n\tif (admitted_time) {\n\t\tifmgd->tx_tspec[ac].admitted_time = 32 * admitted_time;\n\t\tifmgd->tx_tspec[ac].tsid = tsid;\n\t\tifmgd->tx_tspec[ac].up = up;\n\t}\n\n\treturn 0;\n}\n\nstatic int ieee80211_del_tx_ts(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       u8 tsid, const u8 *peer)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tint ac;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tstruct ieee80211_sta_tx_tspec *tx_tspec = &ifmgd->tx_tspec[ac];\n\n\t\t \n\t\tif (!tx_tspec->admitted_time)\n\t\t\tcontinue;\n\n\t\tif (tx_tspec->tsid != tsid)\n\t\t\tcontinue;\n\n\t\t \n\t\ttx_tspec->up = -1;\n\n\t\t \n\t\tsynchronize_net();\n\t\tieee80211_flush_queues(local, sdata, false);\n\n\t\t \n\t\ttx_tspec->action = TX_TSPEC_ACTION_STOP_DOWNGRADE;\n\t\ttx_tspec->downgraded = false;\n\t\tieee80211_sta_handle_tspec_ac_params(sdata);\n\n\t\t \n\t\tmemset(tx_tspec, 0, sizeof(*tx_tspec));\n\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nvoid ieee80211_nan_func_terminated(struct ieee80211_vif *vif,\n\t\t\t\t   u8 inst_id,\n\t\t\t\t   enum nl80211_nan_func_term_reason reason,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct cfg80211_nan_func *func;\n\tu64 cookie;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_NAN))\n\t\treturn;\n\n\tspin_lock_bh(&sdata->u.nan.func_lock);\n\n\tfunc = idr_find(&sdata->u.nan.function_inst_ids, inst_id);\n\tif (WARN_ON(!func)) {\n\t\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\t\treturn;\n\t}\n\n\tcookie = func->cookie;\n\tidr_remove(&sdata->u.nan.function_inst_ids, inst_id);\n\n\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\n\tcfg80211_free_nan_func(func);\n\n\tcfg80211_nan_func_terminated(ieee80211_vif_to_wdev(vif), inst_id,\n\t\t\t\t     reason, cookie, gfp);\n}\nEXPORT_SYMBOL(ieee80211_nan_func_terminated);\n\nvoid ieee80211_nan_func_match(struct ieee80211_vif *vif,\n\t\t\t      struct cfg80211_nan_match_params *match,\n\t\t\t      gfp_t gfp)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct cfg80211_nan_func *func;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_NAN))\n\t\treturn;\n\n\tspin_lock_bh(&sdata->u.nan.func_lock);\n\n\tfunc = idr_find(&sdata->u.nan.function_inst_ids,  match->inst_id);\n\tif (WARN_ON(!func)) {\n\t\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\t\treturn;\n\t}\n\tmatch->cookie = func->cookie;\n\n\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\n\tcfg80211_nan_match(ieee80211_vif_to_wdev(vif), match, gfp);\n}\nEXPORT_SYMBOL(ieee80211_nan_func_match);\n\nstatic int ieee80211_set_multicast_to_unicast(struct wiphy *wiphy,\n\t\t\t\t\t      struct net_device *dev,\n\t\t\t\t\t      const bool enabled)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tsdata->u.ap.multicast_to_unicast = enabled;\n\n\treturn 0;\n}\n\nvoid ieee80211_fill_txq_stats(struct cfg80211_txq_stats *txqstats,\n\t\t\t      struct txq_info *txqi)\n{\n\tif (!(txqstats->filled & BIT(NL80211_TXQ_STATS_BACKLOG_BYTES))) {\n\t\ttxqstats->filled |= BIT(NL80211_TXQ_STATS_BACKLOG_BYTES);\n\t\ttxqstats->backlog_bytes = txqi->tin.backlog_bytes;\n\t}\n\n\tif (!(txqstats->filled & BIT(NL80211_TXQ_STATS_BACKLOG_PACKETS))) {\n\t\ttxqstats->filled |= BIT(NL80211_TXQ_STATS_BACKLOG_PACKETS);\n\t\ttxqstats->backlog_packets = txqi->tin.backlog_packets;\n\t}\n\n\tif (!(txqstats->filled & BIT(NL80211_TXQ_STATS_FLOWS))) {\n\t\ttxqstats->filled |= BIT(NL80211_TXQ_STATS_FLOWS);\n\t\ttxqstats->flows = txqi->tin.flows;\n\t}\n\n\tif (!(txqstats->filled & BIT(NL80211_TXQ_STATS_DROPS))) {\n\t\ttxqstats->filled |= BIT(NL80211_TXQ_STATS_DROPS);\n\t\ttxqstats->drops = txqi->cstats.drop_count;\n\t}\n\n\tif (!(txqstats->filled & BIT(NL80211_TXQ_STATS_ECN_MARKS))) {\n\t\ttxqstats->filled |= BIT(NL80211_TXQ_STATS_ECN_MARKS);\n\t\ttxqstats->ecn_marks = txqi->cstats.ecn_mark;\n\t}\n\n\tif (!(txqstats->filled & BIT(NL80211_TXQ_STATS_OVERLIMIT))) {\n\t\ttxqstats->filled |= BIT(NL80211_TXQ_STATS_OVERLIMIT);\n\t\ttxqstats->overlimit = txqi->tin.overlimit;\n\t}\n\n\tif (!(txqstats->filled & BIT(NL80211_TXQ_STATS_COLLISIONS))) {\n\t\ttxqstats->filled |= BIT(NL80211_TXQ_STATS_COLLISIONS);\n\t\ttxqstats->collisions = txqi->tin.collisions;\n\t}\n\n\tif (!(txqstats->filled & BIT(NL80211_TXQ_STATS_TX_BYTES))) {\n\t\ttxqstats->filled |= BIT(NL80211_TXQ_STATS_TX_BYTES);\n\t\ttxqstats->tx_bytes = txqi->tin.tx_bytes;\n\t}\n\n\tif (!(txqstats->filled & BIT(NL80211_TXQ_STATS_TX_PACKETS))) {\n\t\ttxqstats->filled |= BIT(NL80211_TXQ_STATS_TX_PACKETS);\n\t\ttxqstats->tx_packets = txqi->tin.tx_packets;\n\t}\n}\n\nstatic int ieee80211_get_txq_stats(struct wiphy *wiphy,\n\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t   struct cfg80211_txq_stats *txqstats)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct ieee80211_sub_if_data *sdata;\n\tint ret = 0;\n\n\tspin_lock_bh(&local->fq.lock);\n\trcu_read_lock();\n\n\tif (wdev) {\n\t\tsdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\t\tif (!sdata->vif.txq) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tieee80211_fill_txq_stats(txqstats, to_txq_info(sdata->vif.txq));\n\t} else {\n\t\t \n\t\ttxqstats->filled |= BIT(NL80211_TXQ_STATS_BACKLOG_PACKETS) |\n\t\t\t\t    BIT(NL80211_TXQ_STATS_BACKLOG_BYTES) |\n\t\t\t\t    BIT(NL80211_TXQ_STATS_OVERLIMIT) |\n\t\t\t\t    BIT(NL80211_TXQ_STATS_OVERMEMORY) |\n\t\t\t\t    BIT(NL80211_TXQ_STATS_COLLISIONS) |\n\t\t\t\t    BIT(NL80211_TXQ_STATS_MAX_FLOWS);\n\t\ttxqstats->backlog_packets = local->fq.backlog;\n\t\ttxqstats->backlog_bytes = local->fq.memory_usage;\n\t\ttxqstats->overlimit = local->fq.overlimit;\n\t\ttxqstats->overmemory = local->fq.overmemory;\n\t\ttxqstats->collisions = local->fq.collisions;\n\t\ttxqstats->max_flows = local->fq.flows_cnt;\n\t}\n\nout:\n\trcu_read_unlock();\n\tspin_unlock_bh(&local->fq.lock);\n\n\treturn ret;\n}\n\nstatic int\nieee80211_get_ftm_responder_stats(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  struct cfg80211_ftm_responder_stats *ftm_stats)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\treturn drv_get_ftm_responder_stats(local, sdata, ftm_stats);\n}\n\nstatic int\nieee80211_start_pmsr(struct wiphy *wiphy, struct wireless_dev *dev,\n\t\t     struct cfg80211_pmsr_request *request)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(dev);\n\n\treturn drv_start_pmsr(local, sdata, request);\n}\n\nstatic void\nieee80211_abort_pmsr(struct wiphy *wiphy, struct wireless_dev *dev,\n\t\t     struct cfg80211_pmsr_request *request)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(dev);\n\n\treturn drv_abort_pmsr(local, sdata, request);\n}\n\nstatic int ieee80211_set_tid_config(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    struct cfg80211_tid_config *tid_conf)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct sta_info *sta;\n\tint ret;\n\n\tif (!sdata->local->ops->set_tid_config)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!tid_conf->peer)\n\t\treturn drv_set_tid_config(sdata->local, sdata, NULL, tid_conf);\n\n\tmutex_lock(&sdata->local->sta_mtx);\n\tsta = sta_info_get_bss(sdata, tid_conf->peer);\n\tif (!sta) {\n\t\tmutex_unlock(&sdata->local->sta_mtx);\n\t\treturn -ENOENT;\n\t}\n\n\tret = drv_set_tid_config(sdata->local, sdata, &sta->sta, tid_conf);\n\tmutex_unlock(&sdata->local->sta_mtx);\n\n\treturn ret;\n}\n\nstatic int ieee80211_reset_tid_config(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      const u8 *peer, u8 tids)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct sta_info *sta;\n\tint ret;\n\n\tif (!sdata->local->ops->reset_tid_config)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!peer)\n\t\treturn drv_reset_tid_config(sdata->local, sdata, NULL, tids);\n\n\tmutex_lock(&sdata->local->sta_mtx);\n\tsta = sta_info_get_bss(sdata, peer);\n\tif (!sta) {\n\t\tmutex_unlock(&sdata->local->sta_mtx);\n\t\treturn -ENOENT;\n\t}\n\n\tret = drv_reset_tid_config(sdata->local, sdata, &sta->sta, tids);\n\tmutex_unlock(&sdata->local->sta_mtx);\n\n\treturn ret;\n}\n\nstatic int ieee80211_set_sar_specs(struct wiphy *wiphy,\n\t\t\t\t   struct cfg80211_sar_specs *sar)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\n\tif (!local->ops->set_sar_specs)\n\t\treturn -EOPNOTSUPP;\n\n\treturn local->ops->set_sar_specs(&local->hw, sar);\n}\n\nstatic int\nieee80211_set_after_color_change_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tu64 *changed)\n{\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP: {\n\t\tint ret;\n\n\t\tif (!sdata->deflink.u.ap.next_beacon)\n\t\t\treturn -EINVAL;\n\n\t\tret = ieee80211_assign_beacon(sdata, &sdata->deflink,\n\t\t\t\t\t      sdata->deflink.u.ap.next_beacon,\n\t\t\t\t\t      NULL, NULL, changed);\n\t\tieee80211_free_next_beacon(&sdata->deflink);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nieee80211_set_color_change_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct cfg80211_color_change_settings *params,\n\t\t\t\t  u64 *changed)\n{\n\tstruct ieee80211_color_change_settings color_change = {};\n\tint err;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tsdata->deflink.u.ap.next_beacon =\n\t\t\tcfg80211_beacon_dup(&params->beacon_next);\n\t\tif (!sdata->deflink.u.ap.next_beacon)\n\t\t\treturn -ENOMEM;\n\n\t\tif (params->count <= 1)\n\t\t\tbreak;\n\n\t\tcolor_change.counter_offset_beacon =\n\t\t\tparams->counter_offset_beacon;\n\t\tcolor_change.counter_offset_presp =\n\t\t\tparams->counter_offset_presp;\n\t\tcolor_change.count = params->count;\n\n\t\terr = ieee80211_assign_beacon(sdata, &sdata->deflink,\n\t\t\t\t\t      &params->beacon_color_change,\n\t\t\t\t\t      NULL, &color_change, changed);\n\t\tif (err < 0) {\n\t\t\tieee80211_free_next_beacon(&sdata->deflink);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nieee80211_color_change_bss_config_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t u8 color, int enable, u64 changed)\n{\n\tsdata->vif.bss_conf.he_bss_color.color = color;\n\tsdata->vif.bss_conf.he_bss_color.enabled = enable;\n\tchanged |= BSS_CHANGED_HE_BSS_COLOR;\n\n\tieee80211_link_info_change_notify(sdata, &sdata->deflink, changed);\n\n\tif (!sdata->vif.bss_conf.nontransmitted && sdata->vif.mbssid_tx_vif) {\n\t\tstruct ieee80211_sub_if_data *child;\n\n\t\tmutex_lock(&sdata->local->iflist_mtx);\n\t\tlist_for_each_entry(child, &sdata->local->interfaces, list) {\n\t\t\tif (child != sdata && child->vif.mbssid_tx_vif == &sdata->vif) {\n\t\t\t\tchild->vif.bss_conf.he_bss_color.color = color;\n\t\t\t\tchild->vif.bss_conf.he_bss_color.enabled = enable;\n\t\t\t\tieee80211_link_info_change_notify(child,\n\t\t\t\t\t\t\t\t  &child->deflink,\n\t\t\t\t\t\t\t\t  BSS_CHANGED_HE_BSS_COLOR);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&sdata->local->iflist_mtx);\n\t}\n}\n\nstatic int ieee80211_color_change_finalize(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu64 changed = 0;\n\tint err;\n\n\tsdata_assert_lock(sdata);\n\tlockdep_assert_held(&local->mtx);\n\n\tsdata->vif.bss_conf.color_change_active = false;\n\n\terr = ieee80211_set_after_color_change_beacon(sdata, &changed);\n\tif (err) {\n\t\tcfg80211_color_change_aborted_notify(sdata->dev);\n\t\treturn err;\n\t}\n\n\tieee80211_color_change_bss_config_notify(sdata,\n\t\t\t\t\t\t sdata->vif.bss_conf.color_change_color,\n\t\t\t\t\t\t 1, changed);\n\tcfg80211_color_change_notify(sdata->dev);\n\n\treturn 0;\n}\n\nvoid ieee80211_color_change_finalize_work(struct work_struct *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data,\n\t\t\t     deflink.color_change_finalize_work);\n\tstruct ieee80211_local *local = sdata->local;\n\n\tsdata_lock(sdata);\n\tmutex_lock(&local->mtx);\n\n\t \n\tif (!sdata->vif.bss_conf.color_change_active)\n\t\tgoto unlock;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\tgoto unlock;\n\n\tieee80211_color_change_finalize(sdata);\n\nunlock:\n\tmutex_unlock(&local->mtx);\n\tsdata_unlock(sdata);\n}\n\nvoid ieee80211_color_collision_detection_work(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct ieee80211_link_data *link =\n\t\tcontainer_of(delayed_work, struct ieee80211_link_data,\n\t\t\t     color_collision_detect_work);\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\n\tsdata_lock(sdata);\n\tcfg80211_obss_color_collision_notify(sdata->dev, link->color_bitmap);\n\tsdata_unlock(sdata);\n}\n\nvoid ieee80211_color_change_finish(struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\n\tieee80211_queue_work(&sdata->local->hw,\n\t\t\t     &sdata->deflink.color_change_finalize_work);\n}\nEXPORT_SYMBOL_GPL(ieee80211_color_change_finish);\n\nvoid\nieee80211_obss_color_collision_notify(struct ieee80211_vif *vif,\n\t\t\t\t       u64 color_bitmap, gfp_t gfp)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_link_data *link = &sdata->deflink;\n\n\tif (sdata->vif.bss_conf.color_change_active || sdata->vif.bss_conf.csa_active)\n\t\treturn;\n\n\tif (delayed_work_pending(&link->color_collision_detect_work))\n\t\treturn;\n\n\tlink->color_bitmap = color_bitmap;\n\t \n\tieee80211_queue_delayed_work(&sdata->local->hw,\n\t\t\t\t     &link->color_collision_detect_work,\n\t\t\t\t     msecs_to_jiffies(500));\n}\nEXPORT_SYMBOL_GPL(ieee80211_obss_color_collision_notify);\n\nstatic int\nieee80211_color_change(struct wiphy *wiphy, struct net_device *dev,\n\t\t       struct cfg80211_color_change_settings *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tu64 changed = 0;\n\tint err;\n\n\tsdata_assert_lock(sdata);\n\n\tif (sdata->vif.bss_conf.nontransmitted)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&local->mtx);\n\n\t \n\tif (sdata->vif.bss_conf.color_change_active || sdata->vif.bss_conf.csa_active) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\terr = ieee80211_set_color_change_beacon(sdata, params, &changed);\n\tif (err)\n\t\tgoto out;\n\n\tsdata->vif.bss_conf.color_change_active = true;\n\tsdata->vif.bss_conf.color_change_color = params->color;\n\n\tcfg80211_color_change_started_notify(sdata->dev, params->count);\n\n\tif (changed)\n\t\tieee80211_color_change_bss_config_notify(sdata, 0, 0, changed);\n\telse\n\t\t \n\t\tieee80211_color_change_finalize(sdata);\n\nout:\n\tmutex_unlock(&local->mtx);\n\n\treturn err;\n}\n\nstatic int\nieee80211_set_radar_background(struct wiphy *wiphy,\n\t\t\t       struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\n\tif (!local->ops->set_radar_background)\n\t\treturn -EOPNOTSUPP;\n\n\treturn local->ops->set_radar_background(&local->hw, chandef);\n}\n\nstatic int ieee80211_add_intf_link(struct wiphy *wiphy,\n\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t   unsigned int link_id)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tint res;\n\n\tif (wdev->use_4addr)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&sdata->local->mtx);\n\tres = ieee80211_vif_set_links(sdata, wdev->valid_links, 0);\n\tmutex_unlock(&sdata->local->mtx);\n\n\treturn res;\n}\n\nstatic void ieee80211_del_intf_link(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev,\n\t\t\t\t    unsigned int link_id)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\n\tmutex_lock(&sdata->local->mtx);\n\tieee80211_vif_set_links(sdata, wdev->valid_links, 0);\n\tmutex_unlock(&sdata->local->mtx);\n}\n\nstatic int sta_add_link_station(struct ieee80211_local *local,\n\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct link_station_parameters *params)\n{\n\tstruct sta_info *sta;\n\tint ret;\n\n\tsta = sta_info_get_bss(sdata, params->mld_mac);\n\tif (!sta)\n\t\treturn -ENOENT;\n\n\tif (!sta->sta.valid_links)\n\t\treturn -EINVAL;\n\n\tif (sta->sta.valid_links & BIT(params->link_id))\n\t\treturn -EALREADY;\n\n\tret = ieee80211_sta_allocate_link(sta, params->link_id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sta_link_apply_parameters(local, sta, true, params);\n\tif (ret) {\n\t\tieee80211_sta_free_link(sta, params->link_id);\n\t\treturn ret;\n\t}\n\n\t \n\treturn ieee80211_sta_activate_link(sta, params->link_id);\n}\n\nstatic int\nieee80211_add_link_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   struct link_station_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tint ret;\n\n\tmutex_lock(&sdata->local->sta_mtx);\n\tret = sta_add_link_station(local, sdata, params);\n\tmutex_unlock(&sdata->local->sta_mtx);\n\n\treturn ret;\n}\n\nstatic int sta_mod_link_station(struct ieee80211_local *local,\n\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct link_station_parameters *params)\n{\n\tstruct sta_info *sta;\n\n\tsta = sta_info_get_bss(sdata, params->mld_mac);\n\tif (!sta)\n\t\treturn -ENOENT;\n\n\tif (!(sta->sta.valid_links & BIT(params->link_id)))\n\t\treturn -EINVAL;\n\n\treturn sta_link_apply_parameters(local, sta, false, params);\n}\n\nstatic int\nieee80211_mod_link_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   struct link_station_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tint ret;\n\n\tmutex_lock(&sdata->local->sta_mtx);\n\tret = sta_mod_link_station(local, sdata, params);\n\tmutex_unlock(&sdata->local->sta_mtx);\n\n\treturn ret;\n}\n\nstatic int sta_del_link_station(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct link_station_del_parameters *params)\n{\n\tstruct sta_info *sta;\n\n\tsta = sta_info_get_bss(sdata, params->mld_mac);\n\tif (!sta)\n\t\treturn -ENOENT;\n\n\tif (!(sta->sta.valid_links & BIT(params->link_id)))\n\t\treturn -EINVAL;\n\n\t \n\tif (sta->sta.valid_links == BIT(params->link_id))\n\t\treturn -EINVAL;\n\n\tieee80211_sta_remove_link(sta, params->link_id);\n\n\treturn 0;\n}\n\nstatic int\nieee80211_del_link_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   struct link_station_del_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tint ret;\n\n\tmutex_lock(&sdata->local->sta_mtx);\n\tret = sta_del_link_station(sdata, params);\n\tmutex_unlock(&sdata->local->sta_mtx);\n\n\treturn ret;\n}\n\nstatic int ieee80211_set_hw_timestamp(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      struct cfg80211_set_hw_timestamp *hwts)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\n\tif (!local->ops->set_hw_timestamp)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\treturn local->ops->set_hw_timestamp(&local->hw, &sdata->vif, hwts);\n}\n\nconst struct cfg80211_ops mac80211_config_ops = {\n\t.add_virtual_intf = ieee80211_add_iface,\n\t.del_virtual_intf = ieee80211_del_iface,\n\t.change_virtual_intf = ieee80211_change_iface,\n\t.start_p2p_device = ieee80211_start_p2p_device,\n\t.stop_p2p_device = ieee80211_stop_p2p_device,\n\t.add_key = ieee80211_add_key,\n\t.del_key = ieee80211_del_key,\n\t.get_key = ieee80211_get_key,\n\t.set_default_key = ieee80211_config_default_key,\n\t.set_default_mgmt_key = ieee80211_config_default_mgmt_key,\n\t.set_default_beacon_key = ieee80211_config_default_beacon_key,\n\t.start_ap = ieee80211_start_ap,\n\t.change_beacon = ieee80211_change_beacon,\n\t.stop_ap = ieee80211_stop_ap,\n\t.add_station = ieee80211_add_station,\n\t.del_station = ieee80211_del_station,\n\t.change_station = ieee80211_change_station,\n\t.get_station = ieee80211_get_station,\n\t.dump_station = ieee80211_dump_station,\n\t.dump_survey = ieee80211_dump_survey,\n#ifdef CONFIG_MAC80211_MESH\n\t.add_mpath = ieee80211_add_mpath,\n\t.del_mpath = ieee80211_del_mpath,\n\t.change_mpath = ieee80211_change_mpath,\n\t.get_mpath = ieee80211_get_mpath,\n\t.dump_mpath = ieee80211_dump_mpath,\n\t.get_mpp = ieee80211_get_mpp,\n\t.dump_mpp = ieee80211_dump_mpp,\n\t.update_mesh_config = ieee80211_update_mesh_config,\n\t.get_mesh_config = ieee80211_get_mesh_config,\n\t.join_mesh = ieee80211_join_mesh,\n\t.leave_mesh = ieee80211_leave_mesh,\n#endif\n\t.join_ocb = ieee80211_join_ocb,\n\t.leave_ocb = ieee80211_leave_ocb,\n\t.change_bss = ieee80211_change_bss,\n\t.inform_bss = ieee80211_inform_bss,\n\t.set_txq_params = ieee80211_set_txq_params,\n\t.set_monitor_channel = ieee80211_set_monitor_channel,\n\t.suspend = ieee80211_suspend,\n\t.resume = ieee80211_resume,\n\t.scan = ieee80211_scan,\n\t.abort_scan = ieee80211_abort_scan,\n\t.sched_scan_start = ieee80211_sched_scan_start,\n\t.sched_scan_stop = ieee80211_sched_scan_stop,\n\t.auth = ieee80211_auth,\n\t.assoc = ieee80211_assoc,\n\t.deauth = ieee80211_deauth,\n\t.disassoc = ieee80211_disassoc,\n\t.join_ibss = ieee80211_join_ibss,\n\t.leave_ibss = ieee80211_leave_ibss,\n\t.set_mcast_rate = ieee80211_set_mcast_rate,\n\t.set_wiphy_params = ieee80211_set_wiphy_params,\n\t.set_tx_power = ieee80211_set_tx_power,\n\t.get_tx_power = ieee80211_get_tx_power,\n\t.rfkill_poll = ieee80211_rfkill_poll,\n\tCFG80211_TESTMODE_CMD(ieee80211_testmode_cmd)\n\tCFG80211_TESTMODE_DUMP(ieee80211_testmode_dump)\n\t.set_power_mgmt = ieee80211_set_power_mgmt,\n\t.set_bitrate_mask = ieee80211_set_bitrate_mask,\n\t.remain_on_channel = ieee80211_remain_on_channel,\n\t.cancel_remain_on_channel = ieee80211_cancel_remain_on_channel,\n\t.mgmt_tx = ieee80211_mgmt_tx,\n\t.mgmt_tx_cancel_wait = ieee80211_mgmt_tx_cancel_wait,\n\t.set_cqm_rssi_config = ieee80211_set_cqm_rssi_config,\n\t.set_cqm_rssi_range_config = ieee80211_set_cqm_rssi_range_config,\n\t.update_mgmt_frame_registrations =\n\t\tieee80211_update_mgmt_frame_registrations,\n\t.set_antenna = ieee80211_set_antenna,\n\t.get_antenna = ieee80211_get_antenna,\n\t.set_rekey_data = ieee80211_set_rekey_data,\n\t.tdls_oper = ieee80211_tdls_oper,\n\t.tdls_mgmt = ieee80211_tdls_mgmt,\n\t.tdls_channel_switch = ieee80211_tdls_channel_switch,\n\t.tdls_cancel_channel_switch = ieee80211_tdls_cancel_channel_switch,\n\t.probe_client = ieee80211_probe_client,\n\t.set_noack_map = ieee80211_set_noack_map,\n#ifdef CONFIG_PM\n\t.set_wakeup = ieee80211_set_wakeup,\n#endif\n\t.get_channel = ieee80211_cfg_get_channel,\n\t.start_radar_detection = ieee80211_start_radar_detection,\n\t.end_cac = ieee80211_end_cac,\n\t.channel_switch = ieee80211_channel_switch,\n\t.set_qos_map = ieee80211_set_qos_map,\n\t.set_ap_chanwidth = ieee80211_set_ap_chanwidth,\n\t.add_tx_ts = ieee80211_add_tx_ts,\n\t.del_tx_ts = ieee80211_del_tx_ts,\n\t.start_nan = ieee80211_start_nan,\n\t.stop_nan = ieee80211_stop_nan,\n\t.nan_change_conf = ieee80211_nan_change_conf,\n\t.add_nan_func = ieee80211_add_nan_func,\n\t.del_nan_func = ieee80211_del_nan_func,\n\t.set_multicast_to_unicast = ieee80211_set_multicast_to_unicast,\n\t.tx_control_port = ieee80211_tx_control_port,\n\t.get_txq_stats = ieee80211_get_txq_stats,\n\t.get_ftm_responder_stats = ieee80211_get_ftm_responder_stats,\n\t.start_pmsr = ieee80211_start_pmsr,\n\t.abort_pmsr = ieee80211_abort_pmsr,\n\t.probe_mesh_link = ieee80211_probe_mesh_link,\n\t.set_tid_config = ieee80211_set_tid_config,\n\t.reset_tid_config = ieee80211_reset_tid_config,\n\t.set_sar_specs = ieee80211_set_sar_specs,\n\t.color_change = ieee80211_color_change,\n\t.set_radar_background = ieee80211_set_radar_background,\n\t.add_intf_link = ieee80211_add_intf_link,\n\t.del_intf_link = ieee80211_del_intf_link,\n\t.add_link_station = ieee80211_add_link_station,\n\t.mod_link_station = ieee80211_mod_link_station,\n\t.del_link_station = ieee80211_del_link_station,\n\t.set_hw_timestamp = ieee80211_set_hw_timestamp,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}