{
  "module_name": "agg-tx.c",
  "hash_id": "ebe8441571263562abc334cf77f80f8acff602166c17ed9a2f5940b4929a572d",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/agg-tx.c",
  "human_readable_source": "\n \n\n#include <linux/ieee80211.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"wme.h\"\n\n \n\nstatic void ieee80211_send_addba_request(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t const u8 *da, u16 tid,\n\t\t\t\t\t u8 dialog_token, u16 start_seq_num,\n\t\t\t\t\t u16 agg_size, u16 timeout)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *mgmt;\n\tu16 capab;\n\n\tskb = dev_alloc_skb(sizeof(*mgmt) + local->hw.extra_tx_headroom);\n\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\tmgmt = skb_put_zero(skb, 24);\n\tmemcpy(mgmt->da, da, ETH_ALEN);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tif (sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n\t    sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\tmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\n\telse if (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\tmemcpy(mgmt->bssid, sdata->vif.cfg.ap_addr, ETH_ALEN);\n\telse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\tmemcpy(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN);\n\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\n\tskb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_req));\n\n\tmgmt->u.action.category = WLAN_CATEGORY_BACK;\n\tmgmt->u.action.u.addba_req.action_code = WLAN_ACTION_ADDBA_REQ;\n\n\tmgmt->u.action.u.addba_req.dialog_token = dialog_token;\n\tcapab = IEEE80211_ADDBA_PARAM_AMSDU_MASK;\n\tcapab |= IEEE80211_ADDBA_PARAM_POLICY_MASK;\n\tcapab |= u16_encode_bits(tid, IEEE80211_ADDBA_PARAM_TID_MASK);\n\tcapab |= u16_encode_bits(agg_size, IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK);\n\n\tmgmt->u.action.u.addba_req.capab = cpu_to_le16(capab);\n\n\tmgmt->u.action.u.addba_req.timeout = cpu_to_le16(timeout);\n\tmgmt->u.action.u.addba_req.start_seq_num =\n\t\t\t\t\tcpu_to_le16(start_seq_num << 4);\n\n\tieee80211_tx_skb_tid(sdata, skb, tid, -1);\n}\n\nvoid ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_bar *bar;\n\tu16 bar_control = 0;\n\n\tskb = dev_alloc_skb(sizeof(*bar) + local->hw.extra_tx_headroom);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\tbar = skb_put_zero(skb, sizeof(*bar));\n\tbar->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\n\t\t\t\t\t IEEE80211_STYPE_BACK_REQ);\n\tmemcpy(bar->ra, ra, ETH_ALEN);\n\tmemcpy(bar->ta, sdata->vif.addr, ETH_ALEN);\n\tbar_control |= (u16)IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL;\n\tbar_control |= (u16)IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA;\n\tbar_control |= (u16)(tid << IEEE80211_BAR_CTRL_TID_INFO_SHIFT);\n\tbar->control = cpu_to_le16(bar_control);\n\tbar->start_seq_num = cpu_to_le16(ssn);\n\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t\t\t\tIEEE80211_TX_CTL_REQ_TX_STATUS;\n\tieee80211_tx_skb_tid(sdata, skb, tid, -1);\n}\nEXPORT_SYMBOL(ieee80211_send_bar);\n\nvoid ieee80211_assign_tid_tx(struct sta_info *sta, int tid,\n\t\t\t     struct tid_ampdu_tx *tid_tx)\n{\n\tlockdep_assert_held(&sta->ampdu_mlme.mtx);\n\tlockdep_assert_held(&sta->lock);\n\trcu_assign_pointer(sta->ampdu_mlme.tid_tx[tid], tid_tx);\n}\n\n \nstatic void __acquires(agg_queue)\nieee80211_stop_queue_agg(struct ieee80211_sub_if_data *sdata, int tid)\n{\n\tint queue = sdata->vif.hw_queue[ieee80211_ac_from_tid(tid)];\n\n\t \n\n\tif (atomic_inc_return(&sdata->local->agg_queue_stop[queue]) == 1)\n\t\tieee80211_stop_queue_by_reason(\n\t\t\t&sdata->local->hw, queue,\n\t\t\tIEEE80211_QUEUE_STOP_REASON_AGGREGATION,\n\t\t\tfalse);\n\t__acquire(agg_queue);\n}\n\nstatic void __releases(agg_queue)\nieee80211_wake_queue_agg(struct ieee80211_sub_if_data *sdata, int tid)\n{\n\tint queue = sdata->vif.hw_queue[ieee80211_ac_from_tid(tid)];\n\n\tif (atomic_dec_return(&sdata->local->agg_queue_stop[queue]) == 0)\n\t\tieee80211_wake_queue_by_reason(\n\t\t\t&sdata->local->hw, queue,\n\t\t\tIEEE80211_QUEUE_STOP_REASON_AGGREGATION,\n\t\t\tfalse);\n\t__release(agg_queue);\n}\n\nstatic void\nieee80211_agg_stop_txq(struct sta_info *sta, int tid)\n{\n\tstruct ieee80211_txq *txq = sta->sta.txq[tid];\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct fq *fq;\n\tstruct txq_info *txqi;\n\n\tif (!txq)\n\t\treturn;\n\n\ttxqi = to_txq_info(txq);\n\tsdata = vif_to_sdata(txq->vif);\n\tfq = &sdata->local->fq;\n\n\t \n\tspin_lock_bh(&fq->lock);\n\tset_bit(IEEE80211_TXQ_STOP, &txqi->flags);\n\tspin_unlock_bh(&fq->lock);\n}\n\nstatic void\nieee80211_agg_start_txq(struct sta_info *sta, int tid, bool enable)\n{\n\tstruct ieee80211_txq *txq = sta->sta.txq[tid];\n\tstruct txq_info *txqi;\n\n\tlockdep_assert_held(&sta->ampdu_mlme.mtx);\n\n\tif (!txq)\n\t\treturn;\n\n\ttxqi = to_txq_info(txq);\n\n\tif (enable)\n\t\tset_bit(IEEE80211_TXQ_AMPDU, &txqi->flags);\n\telse\n\t\tclear_bit(IEEE80211_TXQ_AMPDU, &txqi->flags);\n\n\tclear_bit(IEEE80211_TXQ_STOP, &txqi->flags);\n\tlocal_bh_disable();\n\trcu_read_lock();\n\tschedule_and_wake_txq(sta->sdata->local, txqi);\n\trcu_read_unlock();\n\tlocal_bh_enable();\n}\n\n \nstatic void __acquires(agg_queue)\nieee80211_agg_splice_packets(struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct tid_ampdu_tx *tid_tx, u16 tid)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint queue = sdata->vif.hw_queue[ieee80211_ac_from_tid(tid)];\n\tunsigned long flags;\n\n\tieee80211_stop_queue_agg(sdata, tid);\n\n\tif (WARN(!tid_tx,\n\t\t \"TID %d gone but expected when splicing aggregates from the pending queue\\n\",\n\t\t tid))\n\t\treturn;\n\n\tif (!skb_queue_empty(&tid_tx->pending)) {\n\t\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\t\t \n\t\tskb_queue_splice_tail_init(&tid_tx->pending,\n\t\t\t\t\t   &local->pending[queue]);\n\t\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n\t}\n}\n\nstatic void __releases(agg_queue)\nieee80211_agg_splice_finish(struct ieee80211_sub_if_data *sdata, u16 tid)\n{\n\tieee80211_wake_queue_agg(sdata, tid);\n}\n\nstatic void ieee80211_remove_tid_tx(struct sta_info *sta, int tid)\n{\n\tstruct tid_ampdu_tx *tid_tx;\n\n\tlockdep_assert_held(&sta->ampdu_mlme.mtx);\n\tlockdep_assert_held(&sta->lock);\n\n\ttid_tx = rcu_dereference_protected_tid_tx(sta, tid);\n\n\t \n\n\tieee80211_agg_splice_packets(sta->sdata, tid_tx, tid);\n\n\t \n\tieee80211_assign_tid_tx(sta, tid, NULL);\n\n\tieee80211_agg_splice_finish(sta->sdata, tid);\n\n\tkfree_rcu(tid_tx, rcu_head);\n}\n\nint ___ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,\n\t\t\t\t    enum ieee80211_agg_stop_reason reason)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct tid_ampdu_tx *tid_tx;\n\tstruct ieee80211_ampdu_params params = {\n\t\t.sta = &sta->sta,\n\t\t.tid = tid,\n\t\t.buf_size = 0,\n\t\t.amsdu = false,\n\t\t.timeout = 0,\n\t\t.ssn = 0,\n\t};\n\tint ret;\n\n\tlockdep_assert_held(&sta->ampdu_mlme.mtx);\n\n\tswitch (reason) {\n\tcase AGG_STOP_DECLINED:\n\tcase AGG_STOP_LOCAL_REQUEST:\n\tcase AGG_STOP_PEER_REQUEST:\n\t\tparams.action = IEEE80211_AMPDU_TX_STOP_CONT;\n\t\tbreak;\n\tcase AGG_STOP_DESTROY_STA:\n\t\tparams.action = IEEE80211_AMPDU_TX_STOP_FLUSH;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&sta->lock);\n\n\t \n\ttid_tx = sta->ampdu_mlme.tid_start_tx[tid];\n\tkfree(tid_tx);\n\tsta->ampdu_mlme.tid_start_tx[tid] = NULL;\n\n\ttid_tx = rcu_dereference_protected_tid_tx(sta, tid);\n\tif (!tid_tx) {\n\t\tspin_unlock_bh(&sta->lock);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {\n\t\tspin_unlock_bh(&sta->lock);\n\t\tif (reason != AGG_STOP_DESTROY_STA)\n\t\t\treturn -EALREADY;\n\t\tparams.action = IEEE80211_AMPDU_TX_STOP_FLUSH_CONT;\n\t\tret = drv_ampdu_action(local, sta->sdata, &params);\n\t\tWARN_ON_ONCE(ret);\n\t\treturn 0;\n\t}\n\n\tif (test_bit(HT_AGG_STATE_WANT_START, &tid_tx->state)) {\n\t\t \n\t\tieee80211_assign_tid_tx(sta, tid, NULL);\n\t\tspin_unlock_bh(&sta->lock);\n\t\tkfree_rcu(tid_tx, rcu_head);\n\t\treturn 0;\n\t}\n\n\tset_bit(HT_AGG_STATE_STOPPING, &tid_tx->state);\n\n\tieee80211_agg_stop_txq(sta, tid);\n\n\tspin_unlock_bh(&sta->lock);\n\n\tht_dbg(sta->sdata, \"Tx BA session stop requested for %pM tid %u\\n\",\n\t       sta->sta.addr, tid);\n\n\tdel_timer_sync(&tid_tx->addba_resp_timer);\n\tdel_timer_sync(&tid_tx->session_timer);\n\n\t \n\tclear_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state);\n\n\t \n\tif (!local->in_reconfig)\n\t\tsynchronize_net();\n\n\ttid_tx->stop_initiator = reason == AGG_STOP_PEER_REQUEST ?\n\t\t\t\t\tWLAN_BACK_RECIPIENT :\n\t\t\t\t\tWLAN_BACK_INITIATOR;\n\ttid_tx->tx_stop = reason == AGG_STOP_LOCAL_REQUEST;\n\n\tret = drv_ampdu_action(local, sta->sdata, &params);\n\n\t \n\tif (WARN_ON(ret)) {\n\t\t \n\t}\n\n\t \n\n\treturn 0;\n}\n\n \nstatic void sta_addba_resp_timer_expired(struct timer_list *t)\n{\n\tstruct tid_ampdu_tx *tid_tx = from_timer(tid_tx, t, addba_resp_timer);\n\tstruct sta_info *sta = tid_tx->sta;\n\tu8 tid = tid_tx->tid;\n\n\t \n\tif (test_bit(HT_AGG_STATE_RESPONSE_RECEIVED, &tid_tx->state)) {\n\t\tht_dbg(sta->sdata,\n\t\t       \"timer expired on %pM tid %d not expecting addBA response\\n\",\n\t\t       sta->sta.addr, tid);\n\t\treturn;\n\t}\n\n\tht_dbg(sta->sdata, \"addBA response timer expired on %pM tid %d\\n\",\n\t       sta->sta.addr, tid);\n\n\tieee80211_stop_tx_ba_session(&sta->sta, tid);\n}\n\nstatic void ieee80211_send_addba_with_timeout(struct sta_info *sta,\n\t\t\t\t\t      struct tid_ampdu_tx *tid_tx)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sta->local;\n\tu8 tid = tid_tx->tid;\n\tu16 buf_size;\n\n\tif (WARN_ON_ONCE(test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state) ||\n\t\t\t test_bit(HT_AGG_STATE_WANT_STOP, &tid_tx->state)))\n\t\treturn;\n\n\tlockdep_assert_held(&sta->ampdu_mlme.mtx);\n\n\t \n\tmod_timer(&tid_tx->addba_resp_timer, jiffies + ADDBA_RESP_INTERVAL);\n\tht_dbg(sdata, \"activated addBA response timer on %pM tid %d\\n\",\n\t       sta->sta.addr, tid);\n\n\tspin_lock_bh(&sta->lock);\n\tsta->ampdu_mlme.last_addba_req_time[tid] = jiffies;\n\tsta->ampdu_mlme.addba_req_num[tid]++;\n\tspin_unlock_bh(&sta->lock);\n\n\tif (sta->sta.deflink.he_cap.has_he) {\n\t\tbuf_size = local->hw.max_tx_aggregation_subframes;\n\t} else {\n\t\t \n\t\tbuf_size = IEEE80211_MAX_AMPDU_BUF_HT;\n\t}\n\n\t \n\tieee80211_send_addba_request(sdata, sta->sta.addr, tid,\n\t\t\t\t     tid_tx->dialog_token, tid_tx->ssn,\n\t\t\t\t     buf_size, tid_tx->timeout);\n\n\tWARN_ON(test_and_set_bit(HT_AGG_STATE_SENT_ADDBA, &tid_tx->state));\n}\n\nvoid ieee80211_tx_ba_session_handle_start(struct sta_info *sta, int tid)\n{\n\tstruct tid_ampdu_tx *tid_tx;\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_ampdu_params params = {\n\t\t.sta = &sta->sta,\n\t\t.action = IEEE80211_AMPDU_TX_START,\n\t\t.tid = tid,\n\t\t.buf_size = 0,\n\t\t.amsdu = false,\n\t\t.timeout = 0,\n\t};\n\tint ret;\n\n\ttid_tx = rcu_dereference_protected_tid_tx(sta, tid);\n\n\t \n\tclear_bit(HT_AGG_STATE_WANT_START, &tid_tx->state);\n\n\t \n\tsynchronize_net();\n\n\tsdata = sta->sdata;\n\tparams.ssn = sta->tid_seq[tid] >> 4;\n\tret = drv_ampdu_action(local, sdata, &params);\n\ttid_tx->ssn = params.ssn;\n\tif (ret == IEEE80211_AMPDU_TX_START_DELAY_ADDBA) {\n\t\treturn;\n\t} else if (ret == IEEE80211_AMPDU_TX_START_IMMEDIATE) {\n\t\t \n\t\tset_bit(HT_AGG_STATE_DRV_READY, &tid_tx->state);\n\t} else if (ret) {\n\t\tif (!sdata)\n\t\t\treturn;\n\n\t\tht_dbg(sdata,\n\t\t       \"BA request denied - HW unavailable for %pM tid %d\\n\",\n\t\t       sta->sta.addr, tid);\n\t\tspin_lock_bh(&sta->lock);\n\t\tieee80211_agg_splice_packets(sdata, tid_tx, tid);\n\t\tieee80211_assign_tid_tx(sta, tid, NULL);\n\t\tieee80211_agg_splice_finish(sdata, tid);\n\t\tspin_unlock_bh(&sta->lock);\n\n\t\tieee80211_agg_start_txq(sta, tid, false);\n\n\t\tkfree_rcu(tid_tx, rcu_head);\n\t\treturn;\n\t}\n\n\tieee80211_send_addba_with_timeout(sta, tid_tx);\n}\n\nvoid ieee80211_refresh_tx_agg_session_timer(struct ieee80211_sta *pubsta,\n\t\t\t\t\t    u16 tid)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct tid_ampdu_tx *tid_tx;\n\n\tif (WARN_ON_ONCE(tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\n\ttid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\n\tif (!tid_tx)\n\t\treturn;\n\n\ttid_tx->last_tx = jiffies;\n}\nEXPORT_SYMBOL(ieee80211_refresh_tx_agg_session_timer);\n\n \nstatic void sta_tx_agg_session_timer_expired(struct timer_list *t)\n{\n\tstruct tid_ampdu_tx *tid_tx = from_timer(tid_tx, t, session_timer);\n\tstruct sta_info *sta = tid_tx->sta;\n\tu8 tid = tid_tx->tid;\n\tunsigned long timeout;\n\n\tif (test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {\n\t\treturn;\n\t}\n\n\ttimeout = tid_tx->last_tx + TU_TO_JIFFIES(tid_tx->timeout);\n\tif (time_is_after_jiffies(timeout)) {\n\t\tmod_timer(&tid_tx->session_timer, timeout);\n\t\treturn;\n\t}\n\n\tht_dbg(sta->sdata, \"tx session timer expired on %pM tid %d\\n\",\n\t       sta->sta.addr, tid);\n\n\tieee80211_stop_tx_ba_session(&sta->sta, tid);\n}\n\nint ieee80211_start_tx_ba_session(struct ieee80211_sta *pubsta, u16 tid,\n\t\t\t\t  u16 timeout)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct tid_ampdu_tx *tid_tx;\n\tint ret = 0;\n\n\ttrace_api_start_tx_ba_session(pubsta, tid);\n\n\tif (WARN(sta->reserved_tid == tid,\n\t\t \"Requested to start BA session on reserved tid=%d\", tid))\n\t\treturn -EINVAL;\n\n\tif (!pubsta->deflink.ht_cap.ht_supported &&\n\t    sta->sdata->vif.bss_conf.chandef.chan->band != NL80211_BAND_6GHZ)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON_ONCE(!local->ops->ampdu_action))\n\t\treturn -EINVAL;\n\n\tif ((tid >= IEEE80211_NUM_TIDS) ||\n\t    !ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION) ||\n\t    ieee80211_hw_check(&local->hw, TX_AMPDU_SETUP_IN_HW))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(tid >= IEEE80211_FIRST_TSPEC_TSID))\n\t\treturn -EINVAL;\n\n\tht_dbg(sdata, \"Open BA session requested for %pM tid %u\\n\",\n\t       pubsta->addr, tid);\n\n\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&\n\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t    sdata->vif.type != NL80211_IFTYPE_AP &&\n\t    sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\treturn -EINVAL;\n\n\tif (test_sta_flag(sta, WLAN_STA_BLOCK_BA)) {\n\t\tht_dbg(sdata,\n\t\t       \"BA sessions blocked - Denying BA session request %pM tid %d\\n\",\n\t\t       sta->sta.addr, tid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (test_sta_flag(sta, WLAN_STA_MFP) &&\n\t    !test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {\n\t\tht_dbg(sdata,\n\t\t       \"MFP STA not authorized - deny BA session request %pM tid %d\\n\",\n\t\t       sta->sta.addr, tid);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (sta->sdata->vif.type == NL80211_IFTYPE_ADHOC &&\n\t    !sta->sta.deflink.ht_cap.ht_supported) {\n\t\tht_dbg(sdata,\n\t\t       \"BA request denied - IBSS STA %pM does not advertise HT support\\n\",\n\t\t       pubsta->addr);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&sta->lock);\n\n\t \n\tif (sta->ampdu_mlme.addba_req_num[tid] > HT_AGG_MAX_RETRIES) {\n\t\tret = -EBUSY;\n\t\tgoto err_unlock_sta;\n\t}\n\n\t \n\tif (sta->ampdu_mlme.addba_req_num[tid] > HT_AGG_BURST_RETRIES &&\n\t    time_before(jiffies, sta->ampdu_mlme.last_addba_req_time[tid] +\n\t\t\tHT_AGG_RETRIES_PERIOD)) {\n\t\tht_dbg(sdata,\n\t\t       \"BA request denied - %d failed requests on %pM tid %u\\n\",\n\t\t       sta->ampdu_mlme.addba_req_num[tid], sta->sta.addr, tid);\n\t\tret = -EBUSY;\n\t\tgoto err_unlock_sta;\n\t}\n\n\ttid_tx = rcu_dereference_protected_tid_tx(sta, tid);\n\t \n\tif (tid_tx || sta->ampdu_mlme.tid_start_tx[tid]) {\n\t\tht_dbg(sdata,\n\t\t       \"BA request denied - session is not idle on %pM tid %u\\n\",\n\t\t       sta->sta.addr, tid);\n\t\tret = -EAGAIN;\n\t\tgoto err_unlock_sta;\n\t}\n\n\t \n\ttid_tx = kzalloc(sizeof(struct tid_ampdu_tx), GFP_ATOMIC);\n\tif (!tid_tx) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock_sta;\n\t}\n\n\tskb_queue_head_init(&tid_tx->pending);\n\t__set_bit(HT_AGG_STATE_WANT_START, &tid_tx->state);\n\n\ttid_tx->timeout = timeout;\n\ttid_tx->sta = sta;\n\ttid_tx->tid = tid;\n\n\t \n\ttimer_setup(&tid_tx->addba_resp_timer, sta_addba_resp_timer_expired, 0);\n\n\t \n\ttimer_setup(&tid_tx->session_timer,\n\t\t    sta_tx_agg_session_timer_expired, TIMER_DEFERRABLE);\n\n\t \n\tsta->ampdu_mlme.dialog_token_allocator++;\n\ttid_tx->dialog_token = sta->ampdu_mlme.dialog_token_allocator;\n\n\t \n\tsta->ampdu_mlme.tid_start_tx[tid] = tid_tx;\n\n\tieee80211_queue_work(&local->hw, &sta->ampdu_mlme.work);\n\n\t \n err_unlock_sta:\n\tspin_unlock_bh(&sta->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_start_tx_ba_session);\n\nstatic void ieee80211_agg_tx_operational(struct ieee80211_local *local,\n\t\t\t\t\t struct sta_info *sta, u16 tid)\n{\n\tstruct tid_ampdu_tx *tid_tx;\n\tstruct ieee80211_ampdu_params params = {\n\t\t.sta = &sta->sta,\n\t\t.action = IEEE80211_AMPDU_TX_OPERATIONAL,\n\t\t.tid = tid,\n\t\t.timeout = 0,\n\t\t.ssn = 0,\n\t};\n\n\tlockdep_assert_held(&sta->ampdu_mlme.mtx);\n\n\ttid_tx = rcu_dereference_protected_tid_tx(sta, tid);\n\tparams.buf_size = tid_tx->buf_size;\n\tparams.amsdu = tid_tx->amsdu;\n\n\tht_dbg(sta->sdata, \"Aggregation is on for %pM tid %d\\n\",\n\t       sta->sta.addr, tid);\n\n\tdrv_ampdu_action(local, sta->sdata, &params);\n\n\t \n\tspin_lock_bh(&sta->lock);\n\n\tieee80211_agg_splice_packets(sta->sdata, tid_tx, tid);\n\t \n\tset_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state);\n\tieee80211_agg_splice_finish(sta->sdata, tid);\n\n\tspin_unlock_bh(&sta->lock);\n\n\tieee80211_agg_start_txq(sta, tid, true);\n}\n\nvoid ieee80211_start_tx_ba_cb(struct sta_info *sta, int tid,\n\t\t\t      struct tid_ampdu_tx *tid_tx)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\n\tlockdep_assert_held(&sta->ampdu_mlme.mtx);\n\n\tif (WARN_ON(test_and_set_bit(HT_AGG_STATE_DRV_READY, &tid_tx->state)))\n\t\treturn;\n\n\tif (test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state) ||\n\t    test_bit(HT_AGG_STATE_WANT_STOP, &tid_tx->state))\n\t\treturn;\n\n\tif (!test_bit(HT_AGG_STATE_SENT_ADDBA, &tid_tx->state)) {\n\t\tieee80211_send_addba_with_timeout(sta, tid_tx);\n\t\t \n\t\treturn;\n\t}\n\n\tif (test_bit(HT_AGG_STATE_RESPONSE_RECEIVED, &tid_tx->state))\n\t\tieee80211_agg_tx_operational(local, sta, tid);\n}\n\nstatic struct tid_ampdu_tx *\nieee80211_lookup_tid_tx(struct ieee80211_sub_if_data *sdata,\n\t\t\tconst u8 *ra, u16 tid, struct sta_info **sta)\n{\n\tstruct tid_ampdu_tx *tid_tx;\n\n\tif (tid >= IEEE80211_NUM_TIDS) {\n\t\tht_dbg(sdata, \"Bad TID value: tid = %d (>= %d)\\n\",\n\t\t       tid, IEEE80211_NUM_TIDS);\n\t\treturn NULL;\n\t}\n\n\t*sta = sta_info_get_bss(sdata, ra);\n\tif (!*sta) {\n\t\tht_dbg(sdata, \"Could not find station: %pM\\n\", ra);\n\t\treturn NULL;\n\t}\n\n\ttid_tx = rcu_dereference((*sta)->ampdu_mlme.tid_tx[tid]);\n\n\tif (WARN_ON(!tid_tx))\n\t\tht_dbg(sdata, \"addBA was not requested!\\n\");\n\n\treturn tid_tx;\n}\n\nvoid ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif,\n\t\t\t\t      const u8 *ra, u16 tid)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct tid_ampdu_tx *tid_tx;\n\n\ttrace_api_start_tx_ba_cb(sdata, ra, tid);\n\n\trcu_read_lock();\n\ttid_tx = ieee80211_lookup_tid_tx(sdata, ra, tid, &sta);\n\tif (!tid_tx)\n\t\tgoto out;\n\n\tset_bit(HT_AGG_STATE_START_CB, &tid_tx->state);\n\tieee80211_queue_work(&local->hw, &sta->ampdu_mlme.work);\n out:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ieee80211_start_tx_ba_cb_irqsafe);\n\nint __ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,\n\t\t\t\t   enum ieee80211_agg_stop_reason reason)\n{\n\tint ret;\n\n\tmutex_lock(&sta->ampdu_mlme.mtx);\n\n\tret = ___ieee80211_stop_tx_ba_session(sta, tid, reason);\n\n\tmutex_unlock(&sta->ampdu_mlme.mtx);\n\n\treturn ret;\n}\n\nint ieee80211_stop_tx_ba_session(struct ieee80211_sta *pubsta, u16 tid)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct tid_ampdu_tx *tid_tx;\n\tint ret = 0;\n\n\ttrace_api_stop_tx_ba_session(pubsta, tid);\n\n\tif (!local->ops->ampdu_action)\n\t\treturn -EINVAL;\n\n\tif (tid >= IEEE80211_NUM_TIDS)\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&sta->lock);\n\ttid_tx = rcu_dereference_protected_tid_tx(sta, tid);\n\n\tif (!tid_tx) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\tWARN(sta->reserved_tid == tid,\n\t     \"Requested to stop BA session on reserved tid=%d\", tid);\n\n\tif (test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {\n\t\t \n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\tset_bit(HT_AGG_STATE_WANT_STOP, &tid_tx->state);\n\tieee80211_queue_work(&local->hw, &sta->ampdu_mlme.work);\n\n unlock:\n\tspin_unlock_bh(&sta->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(ieee80211_stop_tx_ba_session);\n\nvoid ieee80211_stop_tx_ba_cb(struct sta_info *sta, int tid,\n\t\t\t     struct tid_ampdu_tx *tid_tx)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tbool send_delba = false;\n\tbool start_txq = false;\n\n\tht_dbg(sdata, \"Stopping Tx BA session for %pM tid %d\\n\",\n\t       sta->sta.addr, tid);\n\n\tspin_lock_bh(&sta->lock);\n\n\tif (!test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {\n\t\tht_dbg(sdata,\n\t\t       \"unexpected callback to A-MPDU stop for %pM tid %d\\n\",\n\t\t       sta->sta.addr, tid);\n\t\tgoto unlock_sta;\n\t}\n\n\tif (tid_tx->stop_initiator == WLAN_BACK_INITIATOR && tid_tx->tx_stop)\n\t\tsend_delba = true;\n\n\tieee80211_remove_tid_tx(sta, tid);\n\tstart_txq = true;\n\n unlock_sta:\n\tspin_unlock_bh(&sta->lock);\n\n\tif (start_txq)\n\t\tieee80211_agg_start_txq(sta, tid, false);\n\n\tif (send_delba)\n\t\tieee80211_send_delba(sdata, sta->sta.addr, tid,\n\t\t\tWLAN_BACK_INITIATOR, WLAN_REASON_QSTA_NOT_USE);\n}\n\nvoid ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif,\n\t\t\t\t     const u8 *ra, u16 tid)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct tid_ampdu_tx *tid_tx;\n\n\ttrace_api_stop_tx_ba_cb(sdata, ra, tid);\n\n\trcu_read_lock();\n\ttid_tx = ieee80211_lookup_tid_tx(sdata, ra, tid, &sta);\n\tif (!tid_tx)\n\t\tgoto out;\n\n\tset_bit(HT_AGG_STATE_STOP_CB, &tid_tx->state);\n\tieee80211_queue_work(&local->hw, &sta->ampdu_mlme.work);\n out:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ieee80211_stop_tx_ba_cb_irqsafe);\n\n\nvoid ieee80211_process_addba_resp(struct ieee80211_local *local,\n\t\t\t\t  struct sta_info *sta,\n\t\t\t\t  struct ieee80211_mgmt *mgmt,\n\t\t\t\t  size_t len)\n{\n\tstruct tid_ampdu_tx *tid_tx;\n\tstruct ieee80211_txq *txq;\n\tu16 capab, tid, buf_size;\n\tbool amsdu;\n\n\tcapab = le16_to_cpu(mgmt->u.action.u.addba_resp.capab);\n\tamsdu = capab & IEEE80211_ADDBA_PARAM_AMSDU_MASK;\n\ttid = u16_get_bits(capab, IEEE80211_ADDBA_PARAM_TID_MASK);\n\tbuf_size = u16_get_bits(capab, IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK);\n\tbuf_size = min(buf_size, local->hw.max_tx_aggregation_subframes);\n\n\ttxq = sta->sta.txq[tid];\n\tif (!amsdu && txq)\n\t\tset_bit(IEEE80211_TXQ_NO_AMSDU, &to_txq_info(txq)->flags);\n\n\tmutex_lock(&sta->ampdu_mlme.mtx);\n\n\ttid_tx = rcu_dereference_protected_tid_tx(sta, tid);\n\tif (!tid_tx)\n\t\tgoto out;\n\n\tif (mgmt->u.action.u.addba_resp.dialog_token != tid_tx->dialog_token) {\n\t\tht_dbg(sta->sdata, \"wrong addBA response token, %pM tid %d\\n\",\n\t\t       sta->sta.addr, tid);\n\t\tgoto out;\n\t}\n\n\tdel_timer_sync(&tid_tx->addba_resp_timer);\n\n\tht_dbg(sta->sdata, \"switched off addBA timer for %pM tid %d\\n\",\n\t       sta->sta.addr, tid);\n\n\t \n\tif (test_bit(HT_AGG_STATE_WANT_STOP, &tid_tx->state) ||\n\t    test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {\n\t\tht_dbg(sta->sdata,\n\t\t       \"got addBA resp for %pM tid %d but we already gave up\\n\",\n\t\t       sta->sta.addr, tid);\n\t\tgoto out;\n\t}\n\n\t \n\tif (le16_to_cpu(mgmt->u.action.u.addba_resp.status)\n\t\t\t== WLAN_STATUS_SUCCESS && buf_size) {\n\t\tif (test_and_set_bit(HT_AGG_STATE_RESPONSE_RECEIVED,\n\t\t\t\t     &tid_tx->state)) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\ttid_tx->buf_size = buf_size;\n\t\ttid_tx->amsdu = amsdu;\n\n\t\tif (test_bit(HT_AGG_STATE_DRV_READY, &tid_tx->state))\n\t\t\tieee80211_agg_tx_operational(local, sta, tid);\n\n\t\tsta->ampdu_mlme.addba_req_num[tid] = 0;\n\n\t\ttid_tx->timeout =\n\t\t\tle16_to_cpu(mgmt->u.action.u.addba_resp.timeout);\n\n\t\tif (tid_tx->timeout) {\n\t\t\tmod_timer(&tid_tx->session_timer,\n\t\t\t\t  TU_TO_EXP_TIME(tid_tx->timeout));\n\t\t\ttid_tx->last_tx = jiffies;\n\t\t}\n\n\t} else {\n\t\t___ieee80211_stop_tx_ba_session(sta, tid, AGG_STOP_DECLINED);\n\t}\n\n out:\n\tmutex_unlock(&sta->ampdu_mlme.mtx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}