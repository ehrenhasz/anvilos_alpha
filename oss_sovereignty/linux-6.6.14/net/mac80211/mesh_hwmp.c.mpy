{
  "module_name": "mesh_hwmp.c",
  "hash_id": "c0e18f60d57f8b1f30a36994e4ee42506573629dba319d3f9309be5308d9d541",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/mesh_hwmp.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/etherdevice.h>\n#include <asm/unaligned.h>\n#include \"wme.h\"\n#include \"mesh.h\"\n\n#define TEST_FRAME_LEN\t8192\n#define MAX_METRIC\t0xffffffff\n#define ARITH_SHIFT\t8\n#define LINK_FAIL_THRESH 95\n\n#define MAX_PREQ_QUEUE_LEN\t64\n\nstatic void mesh_queue_preq(struct mesh_path *, u8);\n\nstatic inline u32 u32_field_get(const u8 *preq_elem, int offset, bool ae)\n{\n\tif (ae)\n\t\toffset += 6;\n\treturn get_unaligned_le32(preq_elem + offset);\n}\n\nstatic inline u16 u16_field_get(const u8 *preq_elem, int offset, bool ae)\n{\n\tif (ae)\n\t\toffset += 6;\n\treturn get_unaligned_le16(preq_elem + offset);\n}\n\n \n#define AE_F\t\t\t(1<<6)\n#define AE_F_SET(x)\t\t(*x & AE_F)\n#define PREQ_IE_FLAGS(x)\t(*(x))\n#define PREQ_IE_HOPCOUNT(x)\t(*(x + 1))\n#define PREQ_IE_TTL(x)\t\t(*(x + 2))\n#define PREQ_IE_PREQ_ID(x)\tu32_field_get(x, 3, 0)\n#define PREQ_IE_ORIG_ADDR(x)\t(x + 7)\n#define PREQ_IE_ORIG_SN(x)\tu32_field_get(x, 13, 0)\n#define PREQ_IE_LIFETIME(x)\tu32_field_get(x, 17, AE_F_SET(x))\n#define PREQ_IE_METRIC(x) \tu32_field_get(x, 21, AE_F_SET(x))\n#define PREQ_IE_TARGET_F(x)\t(*(AE_F_SET(x) ? x + 32 : x + 26))\n#define PREQ_IE_TARGET_ADDR(x) \t(AE_F_SET(x) ? x + 33 : x + 27)\n#define PREQ_IE_TARGET_SN(x) \tu32_field_get(x, 33, AE_F_SET(x))\n\n\n#define PREP_IE_FLAGS(x)\tPREQ_IE_FLAGS(x)\n#define PREP_IE_HOPCOUNT(x)\tPREQ_IE_HOPCOUNT(x)\n#define PREP_IE_TTL(x)\t\tPREQ_IE_TTL(x)\n#define PREP_IE_ORIG_ADDR(x)\t(AE_F_SET(x) ? x + 27 : x + 21)\n#define PREP_IE_ORIG_SN(x)\tu32_field_get(x, 27, AE_F_SET(x))\n#define PREP_IE_LIFETIME(x)\tu32_field_get(x, 13, AE_F_SET(x))\n#define PREP_IE_METRIC(x)\tu32_field_get(x, 17, AE_F_SET(x))\n#define PREP_IE_TARGET_ADDR(x)\t(x + 3)\n#define PREP_IE_TARGET_SN(x)\tu32_field_get(x, 9, 0)\n\n#define PERR_IE_TTL(x)\t\t(*(x))\n#define PERR_IE_TARGET_FLAGS(x)\t(*(x + 2))\n#define PERR_IE_TARGET_ADDR(x)\t(x + 3)\n#define PERR_IE_TARGET_SN(x)\tu32_field_get(x, 9, 0)\n#define PERR_IE_TARGET_RCODE(x)\tu16_field_get(x, 13, 0)\n\n#define MSEC_TO_TU(x) (x*1000/1024)\n#define SN_GT(x, y) ((s32)(y - x) < 0)\n#define SN_LT(x, y) ((s32)(x - y) < 0)\n#define MAX_SANE_SN_DELTA 32\n\nstatic inline u32 SN_DELTA(u32 x, u32 y)\n{\n\treturn x >= y ? x - y : y - x;\n}\n\n#define net_traversal_jiffies(s) \\\n\tmsecs_to_jiffies(s->u.mesh.mshcfg.dot11MeshHWMPnetDiameterTraversalTime)\n#define default_lifetime(s) \\\n\tMSEC_TO_TU(s->u.mesh.mshcfg.dot11MeshHWMPactivePathTimeout)\n#define min_preq_int_jiff(s) \\\n\t(msecs_to_jiffies(s->u.mesh.mshcfg.dot11MeshHWMPpreqMinInterval))\n#define max_preq_retries(s) (s->u.mesh.mshcfg.dot11MeshHWMPmaxPREQretries)\n#define disc_timeout_jiff(s) \\\n\tmsecs_to_jiffies(sdata->u.mesh.mshcfg.min_discovery_timeout)\n#define root_path_confirmation_jiffies(s) \\\n\tmsecs_to_jiffies(sdata->u.mesh.mshcfg.dot11MeshHWMPconfirmationInterval)\n\nenum mpath_frame_type {\n\tMPATH_PREQ = 0,\n\tMPATH_PREP,\n\tMPATH_PERR,\n\tMPATH_RANN\n};\n\nstatic const u8 broadcast_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\nstatic int mesh_path_sel_frame_tx(enum mpath_frame_type action, u8 flags,\n\t\t\t\t  const u8 *orig_addr, u32 orig_sn,\n\t\t\t\t  u8 target_flags, const u8 *target,\n\t\t\t\t  u32 target_sn, const u8 *da,\n\t\t\t\t  u8 hop_count, u8 ttl,\n\t\t\t\t  u32 lifetime, u32 metric, u32 preq_id,\n\t\t\t\t  struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *mgmt;\n\tu8 *pos, ie_len;\n\tint hdr_len = offsetofend(struct ieee80211_mgmt,\n\t\t\t\t  u.action.u.mesh_action);\n\n\tskb = dev_alloc_skb(local->tx_headroom +\n\t\t\t    hdr_len +\n\t\t\t    2 + 37);  \n\tif (!skb)\n\t\treturn -1;\n\tskb_reserve(skb, local->tx_headroom);\n\tmgmt = skb_put_zero(skb, hdr_len);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\n\tmemcpy(mgmt->da, da, ETH_ALEN);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\t \n\tmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\n\tmgmt->u.action.category = WLAN_CATEGORY_MESH_ACTION;\n\tmgmt->u.action.u.mesh_action.action_code =\n\t\t\t\t\tWLAN_MESH_ACTION_HWMP_PATH_SELECTION;\n\n\tswitch (action) {\n\tcase MPATH_PREQ:\n\t\tmhwmp_dbg(sdata, \"sending PREQ to %pM\\n\", target);\n\t\tie_len = 37;\n\t\tpos = skb_put(skb, 2 + ie_len);\n\t\t*pos++ = WLAN_EID_PREQ;\n\t\tbreak;\n\tcase MPATH_PREP:\n\t\tmhwmp_dbg(sdata, \"sending PREP to %pM\\n\", orig_addr);\n\t\tie_len = 31;\n\t\tpos = skb_put(skb, 2 + ie_len);\n\t\t*pos++ = WLAN_EID_PREP;\n\t\tbreak;\n\tcase MPATH_RANN:\n\t\tmhwmp_dbg(sdata, \"sending RANN from %pM\\n\", orig_addr);\n\t\tie_len = sizeof(struct ieee80211_rann_ie);\n\t\tpos = skb_put(skb, 2 + ie_len);\n\t\t*pos++ = WLAN_EID_RANN;\n\t\tbreak;\n\tdefault:\n\t\tkfree_skb(skb);\n\t\treturn -ENOTSUPP;\n\t}\n\t*pos++ = ie_len;\n\t*pos++ = flags;\n\t*pos++ = hop_count;\n\t*pos++ = ttl;\n\tif (action == MPATH_PREP) {\n\t\tmemcpy(pos, target, ETH_ALEN);\n\t\tpos += ETH_ALEN;\n\t\tput_unaligned_le32(target_sn, pos);\n\t\tpos += 4;\n\t} else {\n\t\tif (action == MPATH_PREQ) {\n\t\t\tput_unaligned_le32(preq_id, pos);\n\t\t\tpos += 4;\n\t\t}\n\t\tmemcpy(pos, orig_addr, ETH_ALEN);\n\t\tpos += ETH_ALEN;\n\t\tput_unaligned_le32(orig_sn, pos);\n\t\tpos += 4;\n\t}\n\tput_unaligned_le32(lifetime, pos);  \n\tpos += 4;\n\tput_unaligned_le32(metric, pos);\n\tpos += 4;\n\tif (action == MPATH_PREQ) {\n\t\t*pos++ = 1;  \n\t\t*pos++ = target_flags;\n\t\tmemcpy(pos, target, ETH_ALEN);\n\t\tpos += ETH_ALEN;\n\t\tput_unaligned_le32(target_sn, pos);\n\t\tpos += 4;\n\t} else if (action == MPATH_PREP) {\n\t\tmemcpy(pos, orig_addr, ETH_ALEN);\n\t\tpos += ETH_ALEN;\n\t\tput_unaligned_le32(orig_sn, pos);\n\t\tpos += 4;\n\t}\n\n\tieee80211_tx_skb(sdata, skb);\n\treturn 0;\n}\n\n\n \nstatic void prepare_frame_for_deferred_tx(struct ieee80211_sub_if_data *sdata,\n\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tskb_reset_transport_header(skb);\n\n\t \n\tskb_set_queue_mapping(skb, IEEE80211_AC_VO);\n\tskb->priority = 7;\n\n\tinfo->control.vif = &sdata->vif;\n\tinfo->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\tieee80211_set_qos_hdr(sdata, skb);\n\tieee80211_mps_set_frame_flags(sdata, NULL, hdr);\n}\n\n \nint mesh_path_error_tx(struct ieee80211_sub_if_data *sdata,\n\t\t       u8 ttl, const u8 *target, u32 target_sn,\n\t\t       u16 target_rcode, const u8 *ra)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct ieee80211_mgmt *mgmt;\n\tu8 *pos, ie_len;\n\tint hdr_len = offsetofend(struct ieee80211_mgmt,\n\t\t\t\t  u.action.u.mesh_action);\n\n\tif (time_before(jiffies, ifmsh->next_perr))\n\t\treturn -EAGAIN;\n\n\tskb = dev_alloc_skb(local->tx_headroom +\n\t\t\t    IEEE80211_ENCRYPT_HEADROOM +\n\t\t\t    IEEE80211_ENCRYPT_TAILROOM +\n\t\t\t    hdr_len +\n\t\t\t    2 + 15  );\n\tif (!skb)\n\t\treturn -1;\n\tskb_reserve(skb, local->tx_headroom + IEEE80211_ENCRYPT_HEADROOM);\n\tmgmt = skb_put_zero(skb, hdr_len);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\n\tmemcpy(mgmt->da, ra, ETH_ALEN);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\t \n\tmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\n\tmgmt->u.action.category = WLAN_CATEGORY_MESH_ACTION;\n\tmgmt->u.action.u.mesh_action.action_code =\n\t\t\t\t\tWLAN_MESH_ACTION_HWMP_PATH_SELECTION;\n\tie_len = 15;\n\tpos = skb_put(skb, 2 + ie_len);\n\t*pos++ = WLAN_EID_PERR;\n\t*pos++ = ie_len;\n\t \n\t*pos++ = ttl;\n\t \n\t*pos++ = 1;\n\t \n\t*pos = 0;\n\tpos++;\n\tmemcpy(pos, target, ETH_ALEN);\n\tpos += ETH_ALEN;\n\tput_unaligned_le32(target_sn, pos);\n\tpos += 4;\n\tput_unaligned_le16(target_rcode, pos);\n\n\t \n\tprepare_frame_for_deferred_tx(sdata, skb);\n\tifmsh->next_perr = TU_TO_EXP_TIME(\n\t\t\t\t   ifmsh->mshcfg.dot11MeshHWMPperrMinInterval);\n\tieee80211_add_pending_skb(local, skb);\n\treturn 0;\n}\n\nvoid ieee80211s_update_metric(struct ieee80211_local *local,\n\t\t\t      struct sta_info *sta,\n\t\t\t      struct ieee80211_tx_status *st)\n{\n\tstruct ieee80211_tx_info *txinfo = st->info;\n\tint failed;\n\tstruct rate_info rinfo;\n\n\tfailed = !(txinfo->flags & IEEE80211_TX_STAT_ACK);\n\n\t \n\tewma_mesh_fail_avg_add(&sta->mesh->fail_avg, failed * 100);\n\tif (ewma_mesh_fail_avg_read(&sta->mesh->fail_avg) >\n\t\t\tLINK_FAIL_THRESH)\n\t\tmesh_plink_broken(sta);\n\n\t \n\tif (st->n_rates)\n\t\trinfo = sta->deflink.tx_stats.last_rate_info;\n\telse\n\t\tsta_set_rate_info_tx(sta, &sta->deflink.tx_stats.last_rate, &rinfo);\n\n\tewma_mesh_tx_rate_avg_add(&sta->mesh->tx_rate_avg,\n\t\t\t\t  cfg80211_calculate_bitrate(&rinfo));\n}\n\nu32 airtime_link_metric_get(struct ieee80211_local *local,\n\t\t\t    struct sta_info *sta)\n{\n\t \n\tint device_constant = 1 << ARITH_SHIFT;\n\tint test_frame_len = TEST_FRAME_LEN << ARITH_SHIFT;\n\tint s_unit = 1 << ARITH_SHIFT;\n\tint rate, err;\n\tu32 tx_time, estimated_retx;\n\tu64 result;\n\tunsigned long fail_avg =\n\t\tewma_mesh_fail_avg_read(&sta->mesh->fail_avg);\n\n\tif (sta->mesh->plink_state != NL80211_PLINK_ESTAB)\n\t\treturn MAX_METRIC;\n\n\t \n\trate = DIV_ROUND_UP(sta_get_expected_throughput(sta), 100);\n\n\tif (rate) {\n\t\terr = 0;\n\t} else {\n\t\tif (fail_avg > LINK_FAIL_THRESH)\n\t\t\treturn MAX_METRIC;\n\n\t\trate = ewma_mesh_tx_rate_avg_read(&sta->mesh->tx_rate_avg);\n\t\tif (WARN_ON(!rate))\n\t\t\treturn MAX_METRIC;\n\n\t\terr = (fail_avg << ARITH_SHIFT) / 100;\n\t}\n\n\t \n\ttx_time = (device_constant + 10 * test_frame_len / rate);\n\testimated_retx = ((1 << (2 * ARITH_SHIFT)) / (s_unit - err));\n\tresult = ((u64)tx_time * estimated_retx) >> (2 * ARITH_SHIFT);\n\treturn (u32)result;\n}\n\n \nstatic u32 hwmp_route_info_get(struct ieee80211_sub_if_data *sdata,\n\t\t\t       struct ieee80211_mgmt *mgmt,\n\t\t\t       const u8 *hwmp_ie, enum mpath_frame_type action)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct mesh_path *mpath;\n\tstruct sta_info *sta;\n\tbool fresh_info;\n\tconst u8 *orig_addr, *ta;\n\tu32 orig_sn, orig_metric;\n\tunsigned long orig_lifetime, exp_time;\n\tu32 last_hop_metric, new_metric;\n\tbool flush_mpath = false;\n\tbool process = true;\n\tu8 hopcount;\n\n\trcu_read_lock();\n\tsta = sta_info_get(sdata, mgmt->sa);\n\tif (!sta) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tlast_hop_metric = airtime_link_metric_get(local, sta);\n\t \n\tfresh_info = true;\n\n\tswitch (action) {\n\tcase MPATH_PREQ:\n\t\torig_addr = PREQ_IE_ORIG_ADDR(hwmp_ie);\n\t\torig_sn = PREQ_IE_ORIG_SN(hwmp_ie);\n\t\torig_lifetime = PREQ_IE_LIFETIME(hwmp_ie);\n\t\torig_metric = PREQ_IE_METRIC(hwmp_ie);\n\t\thopcount = PREQ_IE_HOPCOUNT(hwmp_ie) + 1;\n\t\tbreak;\n\tcase MPATH_PREP:\n\t\t \n\t\torig_addr = PREP_IE_TARGET_ADDR(hwmp_ie);\n\t\torig_sn = PREP_IE_TARGET_SN(hwmp_ie);\n\t\torig_lifetime = PREP_IE_LIFETIME(hwmp_ie);\n\t\torig_metric = PREP_IE_METRIC(hwmp_ie);\n\t\thopcount = PREP_IE_HOPCOUNT(hwmp_ie) + 1;\n\t\tbreak;\n\tdefault:\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\tnew_metric = orig_metric + last_hop_metric;\n\tif (new_metric < orig_metric)\n\t\tnew_metric = MAX_METRIC;\n\texp_time = TU_TO_EXP_TIME(orig_lifetime);\n\n\tif (ether_addr_equal(orig_addr, sdata->vif.addr)) {\n\t\t \n\t\tprocess = false;\n\t\tfresh_info = false;\n\t} else {\n\t\tmpath = mesh_path_lookup(sdata, orig_addr);\n\t\tif (mpath) {\n\t\t\tspin_lock_bh(&mpath->state_lock);\n\t\t\tif (mpath->flags & MESH_PATH_FIXED)\n\t\t\t\tfresh_info = false;\n\t\t\telse if ((mpath->flags & MESH_PATH_ACTIVE) &&\n\t\t\t    (mpath->flags & MESH_PATH_SN_VALID)) {\n\t\t\t\tif (SN_GT(mpath->sn, orig_sn) ||\n\t\t\t\t    (mpath->sn == orig_sn &&\n\t\t\t\t     (rcu_access_pointer(mpath->next_hop) !=\n\t\t\t\t\t\t      sta ?\n\t\t\t\t\t      mult_frac(new_metric, 10, 9) :\n\t\t\t\t\t      new_metric) >= mpath->metric)) {\n\t\t\t\t\tprocess = false;\n\t\t\t\t\tfresh_info = false;\n\t\t\t\t}\n\t\t\t} else if (!(mpath->flags & MESH_PATH_ACTIVE)) {\n\t\t\t\tbool have_sn, newer_sn, bounced;\n\n\t\t\t\thave_sn = mpath->flags & MESH_PATH_SN_VALID;\n\t\t\t\tnewer_sn = have_sn && SN_GT(orig_sn, mpath->sn);\n\t\t\t\tbounced = have_sn &&\n\t\t\t\t\t  (SN_DELTA(orig_sn, mpath->sn) >\n\t\t\t\t\t\t\tMAX_SANE_SN_DELTA);\n\n\t\t\t\tif (!have_sn || newer_sn) {\n\t\t\t\t\t ;\n\t\t\t\t} else if (bounced) {\n\t\t\t\t\t ;\n\t\t\t\t} else {\n\t\t\t\t\tprocess = false;\n\t\t\t\t\tfresh_info = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmpath = mesh_path_add(sdata, orig_addr);\n\t\t\tif (IS_ERR(mpath)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tspin_lock_bh(&mpath->state_lock);\n\t\t}\n\n\t\tif (fresh_info) {\n\t\t\tif (rcu_access_pointer(mpath->next_hop) != sta) {\n\t\t\t\tmpath->path_change_count++;\n\t\t\t\tflush_mpath = true;\n\t\t\t}\n\t\t\tmesh_path_assign_nexthop(mpath, sta);\n\t\t\tmpath->flags |= MESH_PATH_SN_VALID;\n\t\t\tmpath->metric = new_metric;\n\t\t\tmpath->sn = orig_sn;\n\t\t\tmpath->exp_time = time_after(mpath->exp_time, exp_time)\n\t\t\t\t\t  ?  mpath->exp_time : exp_time;\n\t\t\tmpath->hop_count = hopcount;\n\t\t\tmesh_path_activate(mpath);\n\t\t\tspin_unlock_bh(&mpath->state_lock);\n\t\t\tif (flush_mpath)\n\t\t\t\tmesh_fast_tx_flush_mpath(mpath);\n\t\t\tewma_mesh_fail_avg_init(&sta->mesh->fail_avg);\n\t\t\t \n\t\t\tewma_mesh_fail_avg_add(&sta->mesh->fail_avg, 1);\n\t\t\tmesh_path_tx_pending(mpath);\n\t\t\t \n\t\t} else\n\t\t\tspin_unlock_bh(&mpath->state_lock);\n\t}\n\n\t \n\tta = mgmt->sa;\n\tif (ether_addr_equal(orig_addr, ta))\n\t\tfresh_info = false;\n\telse {\n\t\tfresh_info = true;\n\n\t\tmpath = mesh_path_lookup(sdata, ta);\n\t\tif (mpath) {\n\t\t\tspin_lock_bh(&mpath->state_lock);\n\t\t\tif ((mpath->flags & MESH_PATH_FIXED) ||\n\t\t\t    ((mpath->flags & MESH_PATH_ACTIVE) &&\n\t\t\t     ((rcu_access_pointer(mpath->next_hop) != sta ?\n\t\t\t\t       mult_frac(last_hop_metric, 10, 9) :\n\t\t\t\t       last_hop_metric) > mpath->metric)))\n\t\t\t\tfresh_info = false;\n\t\t} else {\n\t\t\tmpath = mesh_path_add(sdata, ta);\n\t\t\tif (IS_ERR(mpath)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tspin_lock_bh(&mpath->state_lock);\n\t\t}\n\n\t\tif (fresh_info) {\n\t\t\tif (rcu_access_pointer(mpath->next_hop) != sta) {\n\t\t\t\tmpath->path_change_count++;\n\t\t\t\tflush_mpath = true;\n\t\t\t}\n\t\t\tmesh_path_assign_nexthop(mpath, sta);\n\t\t\tmpath->metric = last_hop_metric;\n\t\t\tmpath->exp_time = time_after(mpath->exp_time, exp_time)\n\t\t\t\t\t  ?  mpath->exp_time : exp_time;\n\t\t\tmpath->hop_count = 1;\n\t\t\tmesh_path_activate(mpath);\n\t\t\tspin_unlock_bh(&mpath->state_lock);\n\t\t\tif (flush_mpath)\n\t\t\t\tmesh_fast_tx_flush_mpath(mpath);\n\t\t\tewma_mesh_fail_avg_init(&sta->mesh->fail_avg);\n\t\t\t \n\t\t\tewma_mesh_fail_avg_add(&sta->mesh->fail_avg, 1);\n\t\t\tmesh_path_tx_pending(mpath);\n\t\t} else\n\t\t\tspin_unlock_bh(&mpath->state_lock);\n\t}\n\n\trcu_read_unlock();\n\n\treturn process ? new_metric : 0;\n}\n\nstatic void hwmp_preq_frame_process(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_mgmt *mgmt,\n\t\t\t\t    const u8 *preq_elem, u32 orig_metric)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct mesh_path *mpath = NULL;\n\tconst u8 *target_addr, *orig_addr;\n\tconst u8 *da;\n\tu8 target_flags, ttl, flags;\n\tu32 orig_sn, target_sn, lifetime, target_metric = 0;\n\tbool reply = false;\n\tbool forward = true;\n\tbool root_is_gate;\n\n\t \n\ttarget_addr = PREQ_IE_TARGET_ADDR(preq_elem);\n\torig_addr = PREQ_IE_ORIG_ADDR(preq_elem);\n\ttarget_sn = PREQ_IE_TARGET_SN(preq_elem);\n\torig_sn = PREQ_IE_ORIG_SN(preq_elem);\n\ttarget_flags = PREQ_IE_TARGET_F(preq_elem);\n\t \n\tflags = PREQ_IE_FLAGS(preq_elem);\n\troot_is_gate = !!(flags & RANN_FLAG_IS_GATE);\n\n\tmhwmp_dbg(sdata, \"received PREQ from %pM\\n\", orig_addr);\n\n\tif (ether_addr_equal(target_addr, sdata->vif.addr)) {\n\t\tmhwmp_dbg(sdata, \"PREQ is for us\\n\");\n\t\tforward = false;\n\t\treply = true;\n\t\ttarget_metric = 0;\n\n\t\tif (SN_GT(target_sn, ifmsh->sn))\n\t\t\tifmsh->sn = target_sn;\n\n\t\tif (time_after(jiffies, ifmsh->last_sn_update +\n\t\t\t\t\tnet_traversal_jiffies(sdata)) ||\n\t\t    time_before(jiffies, ifmsh->last_sn_update)) {\n\t\t\t++ifmsh->sn;\n\t\t\tifmsh->last_sn_update = jiffies;\n\t\t}\n\t\ttarget_sn = ifmsh->sn;\n\t} else if (is_broadcast_ether_addr(target_addr) &&\n\t\t   (target_flags & IEEE80211_PREQ_TO_FLAG)) {\n\t\trcu_read_lock();\n\t\tmpath = mesh_path_lookup(sdata, orig_addr);\n\t\tif (mpath) {\n\t\t\tif (flags & IEEE80211_PREQ_PROACTIVE_PREP_FLAG) {\n\t\t\t\treply = true;\n\t\t\t\ttarget_addr = sdata->vif.addr;\n\t\t\t\ttarget_sn = ++ifmsh->sn;\n\t\t\t\ttarget_metric = 0;\n\t\t\t\tifmsh->last_sn_update = jiffies;\n\t\t\t}\n\t\t\tif (root_is_gate)\n\t\t\t\tmesh_path_add_gate(mpath);\n\t\t}\n\t\trcu_read_unlock();\n\t} else {\n\t\trcu_read_lock();\n\t\tmpath = mesh_path_lookup(sdata, target_addr);\n\t\tif (mpath) {\n\t\t\tif ((!(mpath->flags & MESH_PATH_SN_VALID)) ||\n\t\t\t\t\tSN_LT(mpath->sn, target_sn)) {\n\t\t\t\tmpath->sn = target_sn;\n\t\t\t\tmpath->flags |= MESH_PATH_SN_VALID;\n\t\t\t} else if ((!(target_flags & IEEE80211_PREQ_TO_FLAG)) &&\n\t\t\t\t\t(mpath->flags & MESH_PATH_ACTIVE)) {\n\t\t\t\treply = true;\n\t\t\t\ttarget_metric = mpath->metric;\n\t\t\t\ttarget_sn = mpath->sn;\n\t\t\t\t \n\t\t\t\ttarget_flags |= IEEE80211_PREQ_TO_FLAG;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (reply) {\n\t\tlifetime = PREQ_IE_LIFETIME(preq_elem);\n\t\tttl = ifmsh->mshcfg.element_ttl;\n\t\tif (ttl != 0) {\n\t\t\tmhwmp_dbg(sdata, \"replying to the PREQ\\n\");\n\t\t\tmesh_path_sel_frame_tx(MPATH_PREP, 0, orig_addr,\n\t\t\t\t\t       orig_sn, 0, target_addr,\n\t\t\t\t\t       target_sn, mgmt->sa, 0, ttl,\n\t\t\t\t\t       lifetime, target_metric, 0,\n\t\t\t\t\t       sdata);\n\t\t} else {\n\t\t\tifmsh->mshstats.dropped_frames_ttl++;\n\t\t}\n\t}\n\n\tif (forward && ifmsh->mshcfg.dot11MeshForwarding) {\n\t\tu32 preq_id;\n\t\tu8 hopcount;\n\n\t\tttl = PREQ_IE_TTL(preq_elem);\n\t\tlifetime = PREQ_IE_LIFETIME(preq_elem);\n\t\tif (ttl <= 1) {\n\t\t\tifmsh->mshstats.dropped_frames_ttl++;\n\t\t\treturn;\n\t\t}\n\t\tmhwmp_dbg(sdata, \"forwarding the PREQ from %pM\\n\", orig_addr);\n\t\t--ttl;\n\t\tpreq_id = PREQ_IE_PREQ_ID(preq_elem);\n\t\thopcount = PREQ_IE_HOPCOUNT(preq_elem) + 1;\n\t\tda = (mpath && mpath->is_root) ?\n\t\t\tmpath->rann_snd_addr : broadcast_addr;\n\n\t\tif (flags & IEEE80211_PREQ_PROACTIVE_PREP_FLAG) {\n\t\t\ttarget_addr = PREQ_IE_TARGET_ADDR(preq_elem);\n\t\t\ttarget_sn = PREQ_IE_TARGET_SN(preq_elem);\n\t\t}\n\n\t\tmesh_path_sel_frame_tx(MPATH_PREQ, flags, orig_addr,\n\t\t\t\t       orig_sn, target_flags, target_addr,\n\t\t\t\t       target_sn, da, hopcount, ttl, lifetime,\n\t\t\t\t       orig_metric, preq_id, sdata);\n\t\tif (!is_multicast_ether_addr(da))\n\t\t\tifmsh->mshstats.fwded_unicast++;\n\t\telse\n\t\t\tifmsh->mshstats.fwded_mcast++;\n\t\tifmsh->mshstats.fwded_frames++;\n\t}\n}\n\n\nstatic inline struct sta_info *\nnext_hop_deref_protected(struct mesh_path *mpath)\n{\n\treturn rcu_dereference_protected(mpath->next_hop,\n\t\t\t\t\t lockdep_is_held(&mpath->state_lock));\n}\n\n\nstatic void hwmp_prep_frame_process(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_mgmt *mgmt,\n\t\t\t\t    const u8 *prep_elem, u32 metric)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct mesh_path *mpath;\n\tconst u8 *target_addr, *orig_addr;\n\tu8 ttl, hopcount, flags;\n\tu8 next_hop[ETH_ALEN];\n\tu32 target_sn, orig_sn, lifetime;\n\n\tmhwmp_dbg(sdata, \"received PREP from %pM\\n\",\n\t\t  PREP_IE_TARGET_ADDR(prep_elem));\n\n\torig_addr = PREP_IE_ORIG_ADDR(prep_elem);\n\tif (ether_addr_equal(orig_addr, sdata->vif.addr))\n\t\t \n\t\treturn;\n\n\tif (!ifmsh->mshcfg.dot11MeshForwarding)\n\t\treturn;\n\n\tttl = PREP_IE_TTL(prep_elem);\n\tif (ttl <= 1) {\n\t\tsdata->u.mesh.mshstats.dropped_frames_ttl++;\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tmpath = mesh_path_lookup(sdata, orig_addr);\n\tif (mpath)\n\t\tspin_lock_bh(&mpath->state_lock);\n\telse\n\t\tgoto fail;\n\tif (!(mpath->flags & MESH_PATH_ACTIVE)) {\n\t\tspin_unlock_bh(&mpath->state_lock);\n\t\tgoto fail;\n\t}\n\tmemcpy(next_hop, next_hop_deref_protected(mpath)->sta.addr, ETH_ALEN);\n\tspin_unlock_bh(&mpath->state_lock);\n\t--ttl;\n\tflags = PREP_IE_FLAGS(prep_elem);\n\tlifetime = PREP_IE_LIFETIME(prep_elem);\n\thopcount = PREP_IE_HOPCOUNT(prep_elem) + 1;\n\ttarget_addr = PREP_IE_TARGET_ADDR(prep_elem);\n\ttarget_sn = PREP_IE_TARGET_SN(prep_elem);\n\torig_sn = PREP_IE_ORIG_SN(prep_elem);\n\n\tmesh_path_sel_frame_tx(MPATH_PREP, flags, orig_addr, orig_sn, 0,\n\t\t\t       target_addr, target_sn, next_hop, hopcount,\n\t\t\t       ttl, lifetime, metric, 0, sdata);\n\trcu_read_unlock();\n\n\tsdata->u.mesh.mshstats.fwded_unicast++;\n\tsdata->u.mesh.mshstats.fwded_frames++;\n\treturn;\n\nfail:\n\trcu_read_unlock();\n\tsdata->u.mesh.mshstats.dropped_frames_no_route++;\n}\n\nstatic void hwmp_perr_frame_process(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_mgmt *mgmt,\n\t\t\t\t    const u8 *perr_elem)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct mesh_path *mpath;\n\tu8 ttl;\n\tconst u8 *ta, *target_addr;\n\tu32 target_sn;\n\tu16 target_rcode;\n\n\tta = mgmt->sa;\n\tttl = PERR_IE_TTL(perr_elem);\n\tif (ttl <= 1) {\n\t\tifmsh->mshstats.dropped_frames_ttl++;\n\t\treturn;\n\t}\n\tttl--;\n\ttarget_addr = PERR_IE_TARGET_ADDR(perr_elem);\n\ttarget_sn = PERR_IE_TARGET_SN(perr_elem);\n\ttarget_rcode = PERR_IE_TARGET_RCODE(perr_elem);\n\n\trcu_read_lock();\n\tmpath = mesh_path_lookup(sdata, target_addr);\n\tif (mpath) {\n\t\tstruct sta_info *sta;\n\n\t\tspin_lock_bh(&mpath->state_lock);\n\t\tsta = next_hop_deref_protected(mpath);\n\t\tif (mpath->flags & MESH_PATH_ACTIVE &&\n\t\t    ether_addr_equal(ta, sta->sta.addr) &&\n\t\t    !(mpath->flags & MESH_PATH_FIXED) &&\n\t\t    (!(mpath->flags & MESH_PATH_SN_VALID) ||\n\t\t    SN_GT(target_sn, mpath->sn)  || target_sn == 0)) {\n\t\t\tmpath->flags &= ~MESH_PATH_ACTIVE;\n\t\t\tif (target_sn != 0)\n\t\t\t\tmpath->sn = target_sn;\n\t\t\telse\n\t\t\t\tmpath->sn += 1;\n\t\t\tspin_unlock_bh(&mpath->state_lock);\n\t\t\tif (!ifmsh->mshcfg.dot11MeshForwarding)\n\t\t\t\tgoto endperr;\n\t\t\tmesh_path_error_tx(sdata, ttl, target_addr,\n\t\t\t\t\t   target_sn, target_rcode,\n\t\t\t\t\t   broadcast_addr);\n\t\t} else\n\t\t\tspin_unlock_bh(&mpath->state_lock);\n\t}\nendperr:\n\trcu_read_unlock();\n}\n\nstatic void hwmp_rann_frame_process(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_mgmt *mgmt,\n\t\t\t\t    const struct ieee80211_rann_ie *rann)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct mesh_path *mpath;\n\tu8 ttl, flags, hopcount;\n\tconst u8 *orig_addr;\n\tu32 orig_sn, new_metric, orig_metric, last_hop_metric, interval;\n\tbool root_is_gate;\n\n\tttl = rann->rann_ttl;\n\tflags = rann->rann_flags;\n\troot_is_gate = !!(flags & RANN_FLAG_IS_GATE);\n\torig_addr = rann->rann_addr;\n\torig_sn = le32_to_cpu(rann->rann_seq);\n\tinterval = le32_to_cpu(rann->rann_interval);\n\thopcount = rann->rann_hopcount;\n\thopcount++;\n\torig_metric = le32_to_cpu(rann->rann_metric);\n\n\t \n\tif (ether_addr_equal(orig_addr, sdata->vif.addr))\n\t\treturn;\n\n\tmhwmp_dbg(sdata,\n\t\t  \"received RANN from %pM via neighbour %pM (is_gate=%d)\\n\",\n\t\t  orig_addr, mgmt->sa, root_is_gate);\n\n\trcu_read_lock();\n\tsta = sta_info_get(sdata, mgmt->sa);\n\tif (!sta) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tlast_hop_metric = airtime_link_metric_get(local, sta);\n\tnew_metric = orig_metric + last_hop_metric;\n\tif (new_metric < orig_metric)\n\t\tnew_metric = MAX_METRIC;\n\n\tmpath = mesh_path_lookup(sdata, orig_addr);\n\tif (!mpath) {\n\t\tmpath = mesh_path_add(sdata, orig_addr);\n\t\tif (IS_ERR(mpath)) {\n\t\t\trcu_read_unlock();\n\t\t\tsdata->u.mesh.mshstats.dropped_frames_no_route++;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!(SN_LT(mpath->sn, orig_sn)) &&\n\t    !(mpath->sn == orig_sn && new_metric < mpath->rann_metric)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif ((!(mpath->flags & (MESH_PATH_ACTIVE | MESH_PATH_RESOLVING)) ||\n\t     (time_after(jiffies, mpath->last_preq_to_root +\n\t\t\t\t  root_path_confirmation_jiffies(sdata)) ||\n\t     time_before(jiffies, mpath->last_preq_to_root))) &&\n\t     !(mpath->flags & MESH_PATH_FIXED) && (ttl != 0)) {\n\t\tmhwmp_dbg(sdata,\n\t\t\t  \"time to refresh root mpath %pM\\n\",\n\t\t\t  orig_addr);\n\t\tmesh_queue_preq(mpath, PREQ_Q_F_START | PREQ_Q_F_REFRESH);\n\t\tmpath->last_preq_to_root = jiffies;\n\t}\n\n\tmpath->sn = orig_sn;\n\tmpath->rann_metric = new_metric;\n\tmpath->is_root = true;\n\t \n\tmemcpy(mpath->rann_snd_addr, mgmt->sa, ETH_ALEN);\n\n\tif (root_is_gate)\n\t\tmesh_path_add_gate(mpath);\n\n\tif (ttl <= 1) {\n\t\tifmsh->mshstats.dropped_frames_ttl++;\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tttl--;\n\n\tif (ifmsh->mshcfg.dot11MeshForwarding) {\n\t\tmesh_path_sel_frame_tx(MPATH_RANN, flags, orig_addr,\n\t\t\t\t       orig_sn, 0, NULL, 0, broadcast_addr,\n\t\t\t\t       hopcount, ttl, interval,\n\t\t\t\t       new_metric, 0, sdata);\n\t}\n\n\trcu_read_unlock();\n}\n\n\nvoid mesh_rx_path_sel_frame(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tstruct ieee802_11_elems *elems;\n\tsize_t baselen;\n\tu32 path_metric;\n\tstruct sta_info *sta;\n\n\t \n\tif (len < IEEE80211_MIN_ACTION_SIZE + 1)\n\t\treturn;\n\n\trcu_read_lock();\n\tsta = sta_info_get(sdata, mgmt->sa);\n\tif (!sta || sta->mesh->plink_state != NL80211_PLINK_ESTAB) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\n\tbaselen = (u8 *) mgmt->u.action.u.mesh_action.variable - (u8 *) mgmt;\n\telems = ieee802_11_parse_elems(mgmt->u.action.u.mesh_action.variable,\n\t\t\t\t       len - baselen, false, NULL);\n\tif (!elems)\n\t\treturn;\n\n\tif (elems->preq) {\n\t\tif (elems->preq_len != 37)\n\t\t\t \n\t\t\tgoto free;\n\t\tpath_metric = hwmp_route_info_get(sdata, mgmt, elems->preq,\n\t\t\t\t\t\t  MPATH_PREQ);\n\t\tif (path_metric)\n\t\t\thwmp_preq_frame_process(sdata, mgmt, elems->preq,\n\t\t\t\t\t\tpath_metric);\n\t}\n\tif (elems->prep) {\n\t\tif (elems->prep_len != 31)\n\t\t\t \n\t\t\tgoto free;\n\t\tpath_metric = hwmp_route_info_get(sdata, mgmt, elems->prep,\n\t\t\t\t\t\t  MPATH_PREP);\n\t\tif (path_metric)\n\t\t\thwmp_prep_frame_process(sdata, mgmt, elems->prep,\n\t\t\t\t\t\tpath_metric);\n\t}\n\tif (elems->perr) {\n\t\tif (elems->perr_len != 15)\n\t\t\t \n\t\t\tgoto free;\n\t\thwmp_perr_frame_process(sdata, mgmt, elems->perr);\n\t}\n\tif (elems->rann)\n\t\thwmp_rann_frame_process(sdata, mgmt, elems->rann);\nfree:\n\tkfree(elems);\n}\n\n \nstatic void mesh_queue_preq(struct mesh_path *mpath, u8 flags)\n{\n\tstruct ieee80211_sub_if_data *sdata = mpath->sdata;\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct mesh_preq_queue *preq_node;\n\n\tpreq_node = kmalloc(sizeof(struct mesh_preq_queue), GFP_ATOMIC);\n\tif (!preq_node) {\n\t\tmhwmp_dbg(sdata, \"could not allocate PREQ node\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ifmsh->mesh_preq_queue_lock);\n\tif (ifmsh->preq_queue_len == MAX_PREQ_QUEUE_LEN) {\n\t\tspin_unlock_bh(&ifmsh->mesh_preq_queue_lock);\n\t\tkfree(preq_node);\n\t\tif (printk_ratelimit())\n\t\t\tmhwmp_dbg(sdata, \"PREQ node queue full\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock(&mpath->state_lock);\n\tif (mpath->flags & MESH_PATH_REQ_QUEUED) {\n\t\tspin_unlock(&mpath->state_lock);\n\t\tspin_unlock_bh(&ifmsh->mesh_preq_queue_lock);\n\t\tkfree(preq_node);\n\t\treturn;\n\t}\n\n\tmemcpy(preq_node->dst, mpath->dst, ETH_ALEN);\n\tpreq_node->flags = flags;\n\n\tmpath->flags |= MESH_PATH_REQ_QUEUED;\n\tspin_unlock(&mpath->state_lock);\n\n\tlist_add_tail(&preq_node->list, &ifmsh->preq_queue.list);\n\t++ifmsh->preq_queue_len;\n\tspin_unlock_bh(&ifmsh->mesh_preq_queue_lock);\n\n\tif (time_after(jiffies, ifmsh->last_preq + min_preq_int_jiff(sdata)))\n\t\twiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);\n\n\telse if (time_before(jiffies, ifmsh->last_preq)) {\n\t\t \n\t\tifmsh->last_preq = jiffies - min_preq_int_jiff(sdata) - 1;\n\t\twiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);\n\t} else\n\t\tmod_timer(&ifmsh->mesh_path_timer, ifmsh->last_preq +\n\t\t\t\t\t\tmin_preq_int_jiff(sdata));\n}\n\n \nvoid mesh_path_start_discovery(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct mesh_preq_queue *preq_node;\n\tstruct mesh_path *mpath;\n\tu8 ttl, target_flags = 0;\n\tconst u8 *da;\n\tu32 lifetime;\n\n\tspin_lock_bh(&ifmsh->mesh_preq_queue_lock);\n\tif (!ifmsh->preq_queue_len ||\n\t\ttime_before(jiffies, ifmsh->last_preq +\n\t\t\t\tmin_preq_int_jiff(sdata))) {\n\t\tspin_unlock_bh(&ifmsh->mesh_preq_queue_lock);\n\t\treturn;\n\t}\n\n\tpreq_node = list_first_entry(&ifmsh->preq_queue.list,\n\t\t\tstruct mesh_preq_queue, list);\n\tlist_del(&preq_node->list);\n\t--ifmsh->preq_queue_len;\n\tspin_unlock_bh(&ifmsh->mesh_preq_queue_lock);\n\n\trcu_read_lock();\n\tmpath = mesh_path_lookup(sdata, preq_node->dst);\n\tif (!mpath)\n\t\tgoto enddiscovery;\n\n\tspin_lock_bh(&mpath->state_lock);\n\tif (mpath->flags & (MESH_PATH_DELETED | MESH_PATH_FIXED)) {\n\t\tspin_unlock_bh(&mpath->state_lock);\n\t\tgoto enddiscovery;\n\t}\n\tmpath->flags &= ~MESH_PATH_REQ_QUEUED;\n\tif (preq_node->flags & PREQ_Q_F_START) {\n\t\tif (mpath->flags & MESH_PATH_RESOLVING) {\n\t\t\tspin_unlock_bh(&mpath->state_lock);\n\t\t\tgoto enddiscovery;\n\t\t} else {\n\t\t\tmpath->flags &= ~MESH_PATH_RESOLVED;\n\t\t\tmpath->flags |= MESH_PATH_RESOLVING;\n\t\t\tmpath->discovery_retries = 0;\n\t\t\tmpath->discovery_timeout = disc_timeout_jiff(sdata);\n\t\t}\n\t} else if (!(mpath->flags & MESH_PATH_RESOLVING) ||\n\t\t\tmpath->flags & MESH_PATH_RESOLVED) {\n\t\tmpath->flags &= ~MESH_PATH_RESOLVING;\n\t\tspin_unlock_bh(&mpath->state_lock);\n\t\tgoto enddiscovery;\n\t}\n\n\tifmsh->last_preq = jiffies;\n\n\tif (time_after(jiffies, ifmsh->last_sn_update +\n\t\t\t\tnet_traversal_jiffies(sdata)) ||\n\t    time_before(jiffies, ifmsh->last_sn_update)) {\n\t\t++ifmsh->sn;\n\t\tsdata->u.mesh.last_sn_update = jiffies;\n\t}\n\tlifetime = default_lifetime(sdata);\n\tttl = sdata->u.mesh.mshcfg.element_ttl;\n\tif (ttl == 0) {\n\t\tsdata->u.mesh.mshstats.dropped_frames_ttl++;\n\t\tspin_unlock_bh(&mpath->state_lock);\n\t\tgoto enddiscovery;\n\t}\n\n\tif (preq_node->flags & PREQ_Q_F_REFRESH)\n\t\ttarget_flags |= IEEE80211_PREQ_TO_FLAG;\n\telse\n\t\ttarget_flags &= ~IEEE80211_PREQ_TO_FLAG;\n\n\tspin_unlock_bh(&mpath->state_lock);\n\tda = (mpath->is_root) ? mpath->rann_snd_addr : broadcast_addr;\n\tmesh_path_sel_frame_tx(MPATH_PREQ, 0, sdata->vif.addr, ifmsh->sn,\n\t\t\t       target_flags, mpath->dst, mpath->sn, da, 0,\n\t\t\t       ttl, lifetime, 0, ifmsh->preq_id++, sdata);\n\n\tspin_lock_bh(&mpath->state_lock);\n\tif (!(mpath->flags & MESH_PATH_DELETED))\n\t\tmod_timer(&mpath->timer, jiffies + mpath->discovery_timeout);\n\tspin_unlock_bh(&mpath->state_lock);\n\nenddiscovery:\n\trcu_read_unlock();\n\tkfree(preq_node);\n}\n\n \nint mesh_nexthop_resolve(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct mesh_path *mpath;\n\tstruct sk_buff *skb_to_free = NULL;\n\tu8 *target_addr = hdr->addr3;\n\n\t \n\tif (ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\treturn 0;\n\n\t \n\tif (info->control.flags & IEEE80211_TX_CTRL_SKIP_MPATH_LOOKUP)\n\t\treturn 0;\n\n\tif (!mesh_nexthop_lookup(sdata, skb))\n\t\treturn 0;\n\n\t \n\tmpath = mesh_path_lookup(sdata, target_addr);\n\tif (!mpath) {\n\t\tmpath = mesh_path_add(sdata, target_addr);\n\t\tif (IS_ERR(mpath)) {\n\t\t\tmesh_path_discard_frame(sdata, skb);\n\t\t\treturn PTR_ERR(mpath);\n\t\t}\n\t}\n\n\tif (!(mpath->flags & MESH_PATH_RESOLVING) &&\n\t    mesh_path_sel_is_hwmp(sdata))\n\t\tmesh_queue_preq(mpath, PREQ_Q_F_START);\n\n\tif (skb_queue_len(&mpath->frame_queue) >= MESH_FRAME_QUEUE_LEN)\n\t\tskb_to_free = skb_dequeue(&mpath->frame_queue);\n\n\tinfo->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\tieee80211_set_qos_hdr(sdata, skb);\n\tskb_queue_tail(&mpath->frame_queue, skb);\n\tif (skb_to_free)\n\t\tmesh_path_discard_frame(sdata, skb_to_free);\n\n\treturn -ENOENT;\n}\n\n \nstatic int mesh_nexthop_lookup_nolearn(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct sta_info *sta;\n\n\tif (is_multicast_ether_addr(hdr->addr1))\n\t\treturn -ENOENT;\n\n\trcu_read_lock();\n\tsta = sta_info_get(sdata, hdr->addr3);\n\n\tif (!sta || sta->mesh->plink_state != NL80211_PLINK_ESTAB) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\trcu_read_unlock();\n\n\tmemcpy(hdr->addr1, hdr->addr3, ETH_ALEN);\n\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\treturn 0;\n}\n\nvoid mesh_path_refresh(struct ieee80211_sub_if_data *sdata,\n\t\t       struct mesh_path *mpath, const u8 *addr)\n{\n\tif (mpath->flags & (MESH_PATH_REQ_QUEUED | MESH_PATH_FIXED |\n\t\t\t    MESH_PATH_RESOLVING))\n\t\treturn;\n\n\tif (time_after(jiffies,\n\t\t       mpath->exp_time -\n\t\t       msecs_to_jiffies(sdata->u.mesh.mshcfg.path_refresh_time)) &&\n\t    (!addr || ether_addr_equal(sdata->vif.addr, addr)))\n\t\tmesh_queue_preq(mpath, PREQ_Q_F_START | PREQ_Q_F_REFRESH);\n}\n\n \nint mesh_nexthop_lookup(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct mesh_path *mpath;\n\tstruct sta_info *next_hop;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tu8 *target_addr = hdr->addr3;\n\n\tif (ifmsh->mshcfg.dot11MeshNolearn &&\n\t    !mesh_nexthop_lookup_nolearn(sdata, skb))\n\t\treturn 0;\n\n\tmpath = mesh_path_lookup(sdata, target_addr);\n\tif (!mpath || !(mpath->flags & MESH_PATH_ACTIVE))\n\t\treturn -ENOENT;\n\n\tmesh_path_refresh(sdata, mpath, hdr->addr4);\n\n\tnext_hop = rcu_dereference(mpath->next_hop);\n\tif (next_hop) {\n\t\tmemcpy(hdr->addr1, next_hop->sta.addr, ETH_ALEN);\n\t\tmemcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\tieee80211_mps_set_frame_flags(sdata, next_hop, hdr);\n\t\tif (ieee80211_hw_check(&sdata->local->hw, SUPPORT_FAST_XMIT))\n\t\t\tmesh_fast_tx_cache(sdata, skb, mpath);\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nvoid mesh_path_timer(struct timer_list *t)\n{\n\tstruct mesh_path *mpath = from_timer(mpath, t, timer);\n\tstruct ieee80211_sub_if_data *sdata = mpath->sdata;\n\tint ret;\n\n\tif (sdata->local->quiescing)\n\t\treturn;\n\n\tspin_lock_bh(&mpath->state_lock);\n\tif (mpath->flags & MESH_PATH_RESOLVED ||\n\t\t\t(!(mpath->flags & MESH_PATH_RESOLVING))) {\n\t\tmpath->flags &= ~(MESH_PATH_RESOLVING | MESH_PATH_RESOLVED);\n\t\tspin_unlock_bh(&mpath->state_lock);\n\t} else if (mpath->discovery_retries < max_preq_retries(sdata)) {\n\t\t++mpath->discovery_retries;\n\t\tmpath->discovery_timeout *= 2;\n\t\tmpath->flags &= ~MESH_PATH_REQ_QUEUED;\n\t\tspin_unlock_bh(&mpath->state_lock);\n\t\tmesh_queue_preq(mpath, 0);\n\t} else {\n\t\tmpath->flags &= ~(MESH_PATH_RESOLVING |\n\t\t\t\t  MESH_PATH_RESOLVED |\n\t\t\t\t  MESH_PATH_REQ_QUEUED);\n\t\tmpath->exp_time = jiffies;\n\t\tspin_unlock_bh(&mpath->state_lock);\n\t\tif (!mpath->is_gate && mesh_gate_num(sdata) > 0) {\n\t\t\tret = mesh_path_send_to_gates(mpath);\n\t\t\tif (ret)\n\t\t\t\tmhwmp_dbg(sdata, \"no gate was reachable\\n\");\n\t\t} else\n\t\t\tmesh_path_flush_pending(mpath);\n\t}\n}\n\nvoid mesh_path_tx_root_frame(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tu32 interval = ifmsh->mshcfg.dot11MeshHWMPRannInterval;\n\tu8 flags, target_flags = 0;\n\n\tflags = (ifmsh->mshcfg.dot11MeshGateAnnouncementProtocol)\n\t\t\t? RANN_FLAG_IS_GATE : 0;\n\n\tswitch (ifmsh->mshcfg.dot11MeshHWMPRootMode) {\n\tcase IEEE80211_PROACTIVE_RANN:\n\t\tmesh_path_sel_frame_tx(MPATH_RANN, flags, sdata->vif.addr,\n\t\t\t\t       ++ifmsh->sn, 0, NULL, 0, broadcast_addr,\n\t\t\t\t       0, ifmsh->mshcfg.element_ttl,\n\t\t\t\t       interval, 0, 0, sdata);\n\t\tbreak;\n\tcase IEEE80211_PROACTIVE_PREQ_WITH_PREP:\n\t\tflags |= IEEE80211_PREQ_PROACTIVE_PREP_FLAG;\n\t\tfallthrough;\n\tcase IEEE80211_PROACTIVE_PREQ_NO_PREP:\n\t\tinterval = ifmsh->mshcfg.dot11MeshHWMPactivePathToRootTimeout;\n\t\ttarget_flags |= IEEE80211_PREQ_TO_FLAG |\n\t\t\t\tIEEE80211_PREQ_USN_FLAG;\n\t\tmesh_path_sel_frame_tx(MPATH_PREQ, flags, sdata->vif.addr,\n\t\t\t\t       ++ifmsh->sn, target_flags,\n\t\t\t\t       (u8 *) broadcast_addr, 0, broadcast_addr,\n\t\t\t\t       0, ifmsh->mshcfg.element_ttl, interval,\n\t\t\t\t       0, ifmsh->preq_id++, sdata);\n\t\tbreak;\n\tdefault:\n\t\tmhwmp_dbg(sdata, \"Proactive mechanism not supported\\n\");\n\t\treturn;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}