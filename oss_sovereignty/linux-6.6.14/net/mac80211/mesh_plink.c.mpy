{
  "module_name": "mesh_plink.c",
  "hash_id": "25d0671cda288163b7e6c45144f73bdc6de1b76c41f7a6d637f065efef208444",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/mesh_plink.c",
  "human_readable_source": "\n \n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/random.h>\n#include <linux/rculist.h>\n\n#include \"ieee80211_i.h\"\n#include \"rate.h\"\n#include \"mesh.h\"\n\n#define PLINK_CNF_AID(mgmt) ((mgmt)->u.action.u.self_prot.variable + 2)\n#define PLINK_GET_LLID(p) (p + 2)\n#define PLINK_GET_PLID(p) (p + 4)\n\n#define mod_plink_timer(s, t) (mod_timer(&s->mesh->plink_timer, \\\n\t\t\t\tjiffies + msecs_to_jiffies(t)))\n\nenum plink_event {\n\tPLINK_UNDEFINED,\n\tOPN_ACPT,\n\tOPN_RJCT,\n\tOPN_IGNR,\n\tCNF_ACPT,\n\tCNF_RJCT,\n\tCNF_IGNR,\n\tCLS_ACPT,\n\tCLS_IGNR\n};\n\nstatic const char * const mplstates[] = {\n\t[NL80211_PLINK_LISTEN] = \"LISTEN\",\n\t[NL80211_PLINK_OPN_SNT] = \"OPN-SNT\",\n\t[NL80211_PLINK_OPN_RCVD] = \"OPN-RCVD\",\n\t[NL80211_PLINK_CNF_RCVD] = \"CNF_RCVD\",\n\t[NL80211_PLINK_ESTAB] = \"ESTAB\",\n\t[NL80211_PLINK_HOLDING] = \"HOLDING\",\n\t[NL80211_PLINK_BLOCKED] = \"BLOCKED\"\n};\n\nstatic const char * const mplevents[] = {\n\t[PLINK_UNDEFINED] = \"NONE\",\n\t[OPN_ACPT] = \"OPN_ACPT\",\n\t[OPN_RJCT] = \"OPN_RJCT\",\n\t[OPN_IGNR] = \"OPN_IGNR\",\n\t[CNF_ACPT] = \"CNF_ACPT\",\n\t[CNF_RJCT] = \"CNF_RJCT\",\n\t[CNF_IGNR] = \"CNF_IGNR\",\n\t[CLS_ACPT] = \"CLS_ACPT\",\n\t[CLS_IGNR] = \"CLS_IGNR\"\n};\n\n \nstatic bool rssi_threshold_check(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sta_info *sta)\n{\n\ts32 rssi_threshold = sdata->u.mesh.mshcfg.rssi_threshold;\n\treturn rssi_threshold == 0 ||\n\t       (sta &&\n\t\t(s8)-ewma_signal_read(&sta->deflink.rx_stats_avg.signal) >\n\t\trssi_threshold);\n}\n\n \nstatic inline void mesh_plink_fsm_restart(struct sta_info *sta)\n{\n\tlockdep_assert_held(&sta->mesh->plink_lock);\n\tsta->mesh->plink_state = NL80211_PLINK_LISTEN;\n\tsta->mesh->llid = sta->mesh->plid = sta->mesh->reason = 0;\n\tsta->mesh->plink_retries = 0;\n}\n\n \nstatic u64 mesh_set_short_slot_time(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_supported_band *sband;\n\tstruct sta_info *sta;\n\tu32 erp_rates = 0;\n\tu64 changed = 0;\n\tint i;\n\tbool short_slot = false;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn changed;\n\n\tif (sband->band == NL80211_BAND_5GHZ) {\n\t\t \n\t\tshort_slot = true;\n\t\tgoto out;\n\t} else if (sband->band != NL80211_BAND_2GHZ) {\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (sband->bitrates[i].flags & IEEE80211_RATE_ERP_G)\n\t\t\terp_rates |= BIT(i);\n\n\tif (!erp_rates)\n\t\tgoto out;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata ||\n\t\t    sta->mesh->plink_state != NL80211_PLINK_ESTAB)\n\t\t\tcontinue;\n\n\t\tshort_slot = false;\n\t\tif (erp_rates & sta->sta.deflink.supp_rates[sband->band])\n\t\t\tshort_slot = true;\n\t\t else\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\nout:\n\tif (sdata->vif.bss_conf.use_short_slot != short_slot) {\n\t\tsdata->vif.bss_conf.use_short_slot = short_slot;\n\t\tchanged = BSS_CHANGED_ERP_SLOT;\n\t\tmpl_dbg(sdata, \"mesh_plink %pM: ERP short slot time %d\\n\",\n\t\t\tsdata->vif.addr, short_slot);\n\t}\n\treturn changed;\n}\n\n \nstatic u64 mesh_set_ht_prot_mode(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tu16 ht_opmode;\n\tbool non_ht_sta = false, ht20_sta = false;\n\n\tswitch (sdata->vif.bss_conf.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata ||\n\t\t    sta->mesh->plink_state != NL80211_PLINK_ESTAB)\n\t\t\tcontinue;\n\n\t\tif (sta->sta.deflink.bandwidth > IEEE80211_STA_RX_BW_20)\n\t\t\tcontinue;\n\n\t\tif (!sta->sta.deflink.ht_cap.ht_supported) {\n\t\t\tmpl_dbg(sdata, \"nonHT sta (%pM) is present\\n\",\n\t\t\t\t       sta->sta.addr);\n\t\t\tnon_ht_sta = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tmpl_dbg(sdata, \"HT20 sta (%pM) is present\\n\", sta->sta.addr);\n\t\tht20_sta = true;\n\t}\n\trcu_read_unlock();\n\n\tif (non_ht_sta)\n\t\tht_opmode = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED;\n\telse if (ht20_sta &&\n\t\t sdata->vif.bss_conf.chandef.width > NL80211_CHAN_WIDTH_20)\n\t\tht_opmode = IEEE80211_HT_OP_MODE_PROTECTION_20MHZ;\n\telse\n\t\tht_opmode = IEEE80211_HT_OP_MODE_PROTECTION_NONE;\n\n\tif (sdata->vif.bss_conf.ht_operation_mode == ht_opmode)\n\t\treturn 0;\n\n\tsdata->vif.bss_conf.ht_operation_mode = ht_opmode;\n\tsdata->u.mesh.mshcfg.ht_opmode = ht_opmode;\n\tmpl_dbg(sdata, \"selected new HT protection mode %d\\n\", ht_opmode);\n\treturn BSS_CHANGED_HT;\n}\n\nstatic int mesh_plink_frame_tx(struct ieee80211_sub_if_data *sdata,\n\t\t\t       struct sta_info *sta,\n\t\t\t       enum ieee80211_self_protected_actioncode action,\n\t\t\t       u8 *da, u16 llid, u16 plid, u16 reason)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_mgmt *mgmt;\n\tbool include_plid = false;\n\tu16 peering_proto = 0;\n\tu8 *pos, ie_len = 4;\n\tu8 ie_len_he_cap, ie_len_eht_cap;\n\tint hdr_len = offsetofend(struct ieee80211_mgmt, u.action.u.self_prot);\n\tint err = -ENOMEM;\n\n\tie_len_he_cap = ieee80211_ie_len_he_cap(sdata,\n\t\t\t\t\t\tNL80211_IFTYPE_MESH_POINT);\n\tie_len_eht_cap = ieee80211_ie_len_eht_cap(sdata,\n\t\t\t\t\t\t  NL80211_IFTYPE_MESH_POINT);\n\tskb = dev_alloc_skb(local->tx_headroom +\n\t\t\t    hdr_len +\n\t\t\t    2 +  \n\t\t\t    2 +  \n\t\t\t    2 + 8 +  \n\t\t\t    2 + (IEEE80211_MAX_SUPP_RATES - 8) +\n\t\t\t    2 + sdata->u.mesh.mesh_id_len +\n\t\t\t    2 + sizeof(struct ieee80211_meshconf_ie) +\n\t\t\t    2 + sizeof(struct ieee80211_ht_cap) +\n\t\t\t    2 + sizeof(struct ieee80211_ht_operation) +\n\t\t\t    2 + sizeof(struct ieee80211_vht_cap) +\n\t\t\t    2 + sizeof(struct ieee80211_vht_operation) +\n\t\t\t    ie_len_he_cap +\n\t\t\t    2 + 1 + sizeof(struct ieee80211_he_operation) +\n\t\t\t\t    sizeof(struct ieee80211_he_6ghz_oper) +\n\t\t\t    2 + 1 + sizeof(struct ieee80211_he_6ghz_capa) +\n\t\t\t    ie_len_eht_cap +\n\t\t\t    2 + 1 + offsetof(struct ieee80211_eht_operation, optional) +\n\t\t\t\t    offsetof(struct ieee80211_eht_operation_info, optional) +\n\t\t\t    2 + 8 +  \n\t\t\t    sdata->u.mesh.ie_len);\n\tif (!skb)\n\t\treturn err;\n\tinfo = IEEE80211_SKB_CB(skb);\n\tskb_reserve(skb, local->tx_headroom);\n\tmgmt = skb_put_zero(skb, hdr_len);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\tmemcpy(mgmt->da, da, ETH_ALEN);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\n\tmgmt->u.action.category = WLAN_CATEGORY_SELF_PROTECTED;\n\tmgmt->u.action.u.self_prot.action_code = action;\n\n\tif (action != WLAN_SP_MESH_PEERING_CLOSE) {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tenum nl80211_band band;\n\n\t\tsband = ieee80211_get_sband(sdata);\n\t\tif (!sband) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t\tband = sband->band;\n\n\t\t \n\t\tpos = skb_put_zero(skb, 2);\n\t\tif (action == WLAN_SP_MESH_PEERING_CONFIRM) {\n\t\t\t \n\t\t\tpos = skb_put(skb, 2);\n\t\t\tput_unaligned_le16(sta->sta.aid, pos);\n\t\t}\n\t\tif (ieee80211_add_srates_ie(sdata, skb, true, band) ||\n\t\t    ieee80211_add_ext_srates_ie(sdata, skb, true, band) ||\n\t\t    mesh_add_rsn_ie(sdata, skb) ||\n\t\t    mesh_add_meshid_ie(sdata, skb) ||\n\t\t    mesh_add_meshconf_ie(sdata, skb))\n\t\t\tgoto free;\n\t} else {\t \n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t\tif (mesh_add_meshid_ie(sdata, skb))\n\t\t\tgoto free;\n\t}\n\n\t \n\tswitch (action) {\n\tcase WLAN_SP_MESH_PEERING_OPEN:\n\t\tbreak;\n\tcase WLAN_SP_MESH_PEERING_CONFIRM:\n\t\tie_len += 2;\n\t\tinclude_plid = true;\n\t\tbreak;\n\tcase WLAN_SP_MESH_PEERING_CLOSE:\n\t\tif (plid) {\n\t\t\tie_len += 2;\n\t\t\tinclude_plid = true;\n\t\t}\n\t\tie_len += 2;\t \n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (WARN_ON(skb_tailroom(skb) < 2 + ie_len))\n\t\tgoto free;\n\n\tpos = skb_put(skb, 2 + ie_len);\n\t*pos++ = WLAN_EID_PEER_MGMT;\n\t*pos++ = ie_len;\n\tmemcpy(pos, &peering_proto, 2);\n\tpos += 2;\n\tput_unaligned_le16(llid, pos);\n\tpos += 2;\n\tif (include_plid) {\n\t\tput_unaligned_le16(plid, pos);\n\t\tpos += 2;\n\t}\n\tif (action == WLAN_SP_MESH_PEERING_CLOSE) {\n\t\tput_unaligned_le16(reason, pos);\n\t\tpos += 2;\n\t}\n\n\tif (action != WLAN_SP_MESH_PEERING_CLOSE) {\n\t\tif (mesh_add_ht_cap_ie(sdata, skb) ||\n\t\t    mesh_add_ht_oper_ie(sdata, skb) ||\n\t\t    mesh_add_vht_cap_ie(sdata, skb) ||\n\t\t    mesh_add_vht_oper_ie(sdata, skb) ||\n\t\t    mesh_add_he_cap_ie(sdata, skb, ie_len_he_cap) ||\n\t\t    mesh_add_he_oper_ie(sdata, skb) ||\n\t\t    mesh_add_he_6ghz_cap_ie(sdata, skb) ||\n\t\t    mesh_add_eht_cap_ie(sdata, skb, ie_len_eht_cap) ||\n\t\t    mesh_add_eht_oper_ie(sdata, skb))\n\t\t\tgoto free;\n\t}\n\n\tif (mesh_add_vendor_ies(sdata, skb))\n\t\tgoto free;\n\n\tieee80211_tx_skb(sdata, skb);\n\treturn 0;\nfree:\n\tkfree_skb(skb);\n\treturn err;\n}\n\n \nstatic u64 __mesh_plink_deactivate(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tu64 changed = 0;\n\n\tlockdep_assert_held(&sta->mesh->plink_lock);\n\n\tif (sta->mesh->plink_state == NL80211_PLINK_ESTAB)\n\t\tchanged = mesh_plink_dec_estab_count(sdata);\n\tsta->mesh->plink_state = NL80211_PLINK_BLOCKED;\n\n\tieee80211_mps_sta_status_update(sta);\n\tchanged |= ieee80211_mps_set_sta_local_pm(sta,\n\t\t\tNL80211_MESH_POWER_UNKNOWN);\n\n\treturn changed;\n}\n\n \nu64 mesh_plink_deactivate(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tu64 changed;\n\n\tspin_lock_bh(&sta->mesh->plink_lock);\n\tchanged = __mesh_plink_deactivate(sta);\n\n\tif (!sdata->u.mesh.user_mpm) {\n\t\tsta->mesh->reason = WLAN_REASON_MESH_PEER_CANCELED;\n\t\tmesh_plink_frame_tx(sdata, sta, WLAN_SP_MESH_PEERING_CLOSE,\n\t\t\t\t    sta->sta.addr, sta->mesh->llid,\n\t\t\t\t    sta->mesh->plid, sta->mesh->reason);\n\t}\n\tspin_unlock_bh(&sta->mesh->plink_lock);\n\tif (!sdata->u.mesh.user_mpm)\n\t\tdel_timer_sync(&sta->mesh->plink_timer);\n\tmesh_path_flush_by_nexthop(sta);\n\n\t \n\tsynchronize_net();\n\n\treturn changed;\n}\n\nstatic void mesh_sta_info_init(struct ieee80211_sub_if_data *sdata,\n\t\t\t       struct sta_info *sta,\n\t\t\t       struct ieee802_11_elems *elems)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_supported_band *sband;\n\tu32 rates, basic_rates = 0, changed = 0;\n\tenum ieee80211_sta_rx_bandwidth bw = sta->sta.deflink.bandwidth;\n\n\tsband = ieee80211_get_sband(sdata);\n\tif (!sband)\n\t\treturn;\n\n\trates = ieee80211_sta_get_rates(sdata, elems, sband->band,\n\t\t\t\t\t&basic_rates);\n\n\tspin_lock_bh(&sta->mesh->plink_lock);\n\tsta->deflink.rx_stats.last_rx = jiffies;\n\n\t \n\tif (sta->mesh->plink_state == NL80211_PLINK_ESTAB &&\n\t    sta->mesh->processed_beacon)\n\t\tgoto out;\n\tsta->mesh->processed_beacon = true;\n\n\tif (sta->sta.deflink.supp_rates[sband->band] != rates)\n\t\tchanged |= IEEE80211_RC_SUPP_RATES_CHANGED;\n\tsta->sta.deflink.supp_rates[sband->band] = rates;\n\n\tif (ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,\n\t\t\t\t\t      elems->ht_cap_elem,\n\t\t\t\t\t      &sta->deflink))\n\t\tchanged |= IEEE80211_RC_BW_CHANGED;\n\n\tieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,\n\t\t\t\t\t    elems->vht_cap_elem, NULL,\n\t\t\t\t\t    &sta->deflink);\n\n\tieee80211_he_cap_ie_to_sta_he_cap(sdata, sband, elems->he_cap,\n\t\t\t\t\t  elems->he_cap_len,\n\t\t\t\t\t  elems->he_6ghz_capa,\n\t\t\t\t\t  &sta->deflink);\n\n\tieee80211_eht_cap_ie_to_sta_eht_cap(sdata, sband, elems->he_cap,\n\t\t\t\t\t    elems->he_cap_len,\n\t\t\t\t\t    elems->eht_cap, elems->eht_cap_len,\n\t\t\t\t\t    &sta->deflink);\n\n\tif (bw != sta->sta.deflink.bandwidth)\n\t\tchanged |= IEEE80211_RC_BW_CHANGED;\n\n\t \n\tif (elems->ht_operation &&\n\t    !(elems->ht_operation->ht_param &\n\t      IEEE80211_HT_PARAM_CHAN_WIDTH_ANY)) {\n\t\tif (sta->sta.deflink.bandwidth != IEEE80211_STA_RX_BW_20)\n\t\t\tchanged |= IEEE80211_RC_BW_CHANGED;\n\t\tsta->sta.deflink.bandwidth = IEEE80211_STA_RX_BW_20;\n\t}\n\n\tif (!test_sta_flag(sta, WLAN_STA_RATE_CONTROL))\n\t\trate_control_rate_init(sta);\n\telse\n\t\trate_control_rate_update(local, sband, sta, 0, changed);\nout:\n\tspin_unlock_bh(&sta->mesh->plink_lock);\n}\n\nstatic int mesh_allocate_aid(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct sta_info *sta;\n\tunsigned long *aid_map;\n\tint aid;\n\n\taid_map = bitmap_zalloc(IEEE80211_MAX_AID + 1, GFP_KERNEL);\n\tif (!aid_map)\n\t\treturn -ENOMEM;\n\n\t \n\t__set_bit(0, aid_map);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &sdata->local->sta_list, list)\n\t\t__set_bit(sta->sta.aid, aid_map);\n\trcu_read_unlock();\n\n\taid = find_first_zero_bit(aid_map, IEEE80211_MAX_AID + 1);\n\tbitmap_free(aid_map);\n\n\tif (aid > IEEE80211_MAX_AID)\n\t\treturn -ENOBUFS;\n\n\treturn aid;\n}\n\nstatic struct sta_info *\n__mesh_sta_info_alloc(struct ieee80211_sub_if_data *sdata, u8 *hw_addr)\n{\n\tstruct sta_info *sta;\n\tint aid;\n\n\tif (sdata->local->num_sta >= MESH_MAX_PLINKS)\n\t\treturn NULL;\n\n\taid = mesh_allocate_aid(sdata);\n\tif (aid < 0)\n\t\treturn NULL;\n\n\tsta = sta_info_alloc(sdata, hw_addr, GFP_KERNEL);\n\tif (!sta)\n\t\treturn NULL;\n\n\tsta->mesh->plink_state = NL80211_PLINK_LISTEN;\n\tsta->sta.wme = true;\n\tsta->sta.aid = aid;\n\n\tsta_info_pre_move_state(sta, IEEE80211_STA_AUTH);\n\tsta_info_pre_move_state(sta, IEEE80211_STA_ASSOC);\n\tsta_info_pre_move_state(sta, IEEE80211_STA_AUTHORIZED);\n\n\treturn sta;\n}\n\nstatic struct sta_info *\nmesh_sta_info_alloc(struct ieee80211_sub_if_data *sdata, u8 *addr,\n\t\t    struct ieee802_11_elems *elems,\n\t\t    struct ieee80211_rx_status *rx_status)\n{\n\tstruct sta_info *sta = NULL;\n\n\t \n\tif (sdata->u.mesh.user_mpm ||\n\t    sdata->u.mesh.security & IEEE80211_MESH_SEC_AUTHED) {\n\t\tif (mesh_peer_accepts_plinks(elems) &&\n\t\t    mesh_plink_availables(sdata)) {\n\t\t\tint sig = 0;\n\n\t\t\tif (ieee80211_hw_check(&sdata->local->hw, SIGNAL_DBM))\n\t\t\t\tsig = rx_status->signal;\n\n\t\t\tcfg80211_notify_new_peer_candidate(sdata->dev, addr,\n\t\t\t\t\t\t\t   elems->ie_start,\n\t\t\t\t\t\t\t   elems->total_len,\n\t\t\t\t\t\t\t   sig, GFP_KERNEL);\n\t\t}\n\t} else\n\t\tsta = __mesh_sta_info_alloc(sdata, addr);\n\n\treturn sta;\n}\n\n \nstatic struct sta_info *\nmesh_sta_info_get(struct ieee80211_sub_if_data *sdata,\n\t\t  u8 *addr, struct ieee802_11_elems *elems,\n\t\t  struct ieee80211_rx_status *rx_status) __acquires(RCU)\n{\n\tstruct sta_info *sta = NULL;\n\n\trcu_read_lock();\n\tsta = sta_info_get(sdata, addr);\n\tif (sta) {\n\t\tmesh_sta_info_init(sdata, sta, elems);\n\t} else {\n\t\trcu_read_unlock();\n\t\t \n\t\tsta = mesh_sta_info_alloc(sdata, addr, elems, rx_status);\n\t\tif (!sta) {\n\t\t\trcu_read_lock();\n\t\t\treturn NULL;\n\t\t}\n\n\t\tmesh_sta_info_init(sdata, sta, elems);\n\n\t\tif (sta_info_insert_rcu(sta))\n\t\t\treturn NULL;\n\t}\n\n\treturn sta;\n}\n\n \nvoid mesh_neighbour_update(struct ieee80211_sub_if_data *sdata,\n\t\t\t   u8 *hw_addr,\n\t\t\t   struct ieee802_11_elems *elems,\n\t\t\t   struct ieee80211_rx_status *rx_status)\n{\n\tstruct sta_info *sta;\n\tu64 changed = 0;\n\n\tsta = mesh_sta_info_get(sdata, hw_addr, elems, rx_status);\n\tif (!sta)\n\t\tgoto out;\n\n\tsta->mesh->connected_to_gate = elems->mesh_config->meshconf_form &\n\t\tIEEE80211_MESHCONF_FORM_CONNECTED_TO_GATE;\n\n\tif (mesh_peer_accepts_plinks(elems) &&\n\t    sta->mesh->plink_state == NL80211_PLINK_LISTEN &&\n\t    sdata->u.mesh.accepting_plinks &&\n\t    sdata->u.mesh.mshcfg.auto_open_plinks &&\n\t    rssi_threshold_check(sdata, sta))\n\t\tchanged = mesh_plink_open(sta);\n\n\tieee80211_mps_frame_release(sta, elems);\nout:\n\trcu_read_unlock();\n\tieee80211_mbss_info_change_notify(sdata, changed);\n}\n\nvoid mesh_plink_timer(struct timer_list *t)\n{\n\tstruct mesh_sta *mesh = from_timer(mesh, t, plink_timer);\n\tstruct sta_info *sta;\n\tu16 reason = 0;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct mesh_config *mshcfg;\n\tenum ieee80211_self_protected_actioncode action = 0;\n\n\t \n\tsta = mesh->plink_sta;\n\n\tif (sta->sdata->local->quiescing)\n\t\treturn;\n\n\tspin_lock_bh(&sta->mesh->plink_lock);\n\n\t \n\tif (time_before(jiffies, sta->mesh->plink_timer.expires)) {\n\t\tmpl_dbg(sta->sdata,\n\t\t\t\"Ignoring timer for %pM in state %s (timer adjusted)\",\n\t\t\tsta->sta.addr, mplstates[sta->mesh->plink_state]);\n\t\tspin_unlock_bh(&sta->mesh->plink_lock);\n\t\treturn;\n\t}\n\n\t \n\tif (sta->mesh->plink_state == NL80211_PLINK_LISTEN ||\n\t    sta->mesh->plink_state == NL80211_PLINK_ESTAB) {\n\t\tmpl_dbg(sta->sdata,\n\t\t\t\"Ignoring timer for %pM in state %s (timer deleted)\",\n\t\t\tsta->sta.addr, mplstates[sta->mesh->plink_state]);\n\t\tspin_unlock_bh(&sta->mesh->plink_lock);\n\t\treturn;\n\t}\n\n\tmpl_dbg(sta->sdata,\n\t\t\"Mesh plink timer for %pM fired on state %s\\n\",\n\t\tsta->sta.addr, mplstates[sta->mesh->plink_state]);\n\tsdata = sta->sdata;\n\tmshcfg = &sdata->u.mesh.mshcfg;\n\n\tswitch (sta->mesh->plink_state) {\n\tcase NL80211_PLINK_OPN_RCVD:\n\tcase NL80211_PLINK_OPN_SNT:\n\t\t \n\t\tif (sta->mesh->plink_retries < mshcfg->dot11MeshMaxRetries) {\n\t\t\tu32 rand;\n\t\t\tmpl_dbg(sta->sdata,\n\t\t\t\t\"Mesh plink for %pM (retry, timeout): %d %d\\n\",\n\t\t\t\tsta->sta.addr, sta->mesh->plink_retries,\n\t\t\t\tsta->mesh->plink_timeout);\n\t\t\tget_random_bytes(&rand, sizeof(u32));\n\t\t\tsta->mesh->plink_timeout = sta->mesh->plink_timeout +\n\t\t\t\t\t     rand % sta->mesh->plink_timeout;\n\t\t\t++sta->mesh->plink_retries;\n\t\t\tmod_plink_timer(sta, sta->mesh->plink_timeout);\n\t\t\taction = WLAN_SP_MESH_PEERING_OPEN;\n\t\t\tbreak;\n\t\t}\n\t\treason = WLAN_REASON_MESH_MAX_RETRIES;\n\t\tfallthrough;\n\tcase NL80211_PLINK_CNF_RCVD:\n\t\t \n\t\tif (!reason)\n\t\t\treason = WLAN_REASON_MESH_CONFIRM_TIMEOUT;\n\t\tsta->mesh->plink_state = NL80211_PLINK_HOLDING;\n\t\tmod_plink_timer(sta, mshcfg->dot11MeshHoldingTimeout);\n\t\taction = WLAN_SP_MESH_PEERING_CLOSE;\n\t\tbreak;\n\tcase NL80211_PLINK_HOLDING:\n\t\t \n\t\tdel_timer(&sta->mesh->plink_timer);\n\t\tmesh_plink_fsm_restart(sta);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock_bh(&sta->mesh->plink_lock);\n\tif (action)\n\t\tmesh_plink_frame_tx(sdata, sta, action, sta->sta.addr,\n\t\t\t\t    sta->mesh->llid, sta->mesh->plid, reason);\n}\n\nstatic inline void mesh_plink_timer_set(struct sta_info *sta, u32 timeout)\n{\n\tsta->mesh->plink_timeout = timeout;\n\tmod_timer(&sta->mesh->plink_timer, jiffies + msecs_to_jiffies(timeout));\n}\n\nstatic bool llid_in_use(struct ieee80211_sub_if_data *sdata,\n\t\t\tu16 llid)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tbool in_use = false;\n\tstruct sta_info *sta;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\n\t\tif (!memcmp(&sta->mesh->llid, &llid, sizeof(llid))) {\n\t\t\tin_use = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn in_use;\n}\n\nstatic u16 mesh_get_new_llid(struct ieee80211_sub_if_data *sdata)\n{\n\tu16 llid;\n\n\tdo {\n\t\tget_random_bytes(&llid, sizeof(llid));\n\t} while (llid_in_use(sdata, llid));\n\n\treturn llid;\n}\n\nu64 mesh_plink_open(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tu64 changed;\n\n\tif (!test_sta_flag(sta, WLAN_STA_AUTH))\n\t\treturn 0;\n\n\tspin_lock_bh(&sta->mesh->plink_lock);\n\tsta->mesh->llid = mesh_get_new_llid(sdata);\n\tif (sta->mesh->plink_state != NL80211_PLINK_LISTEN &&\n\t    sta->mesh->plink_state != NL80211_PLINK_BLOCKED) {\n\t\tspin_unlock_bh(&sta->mesh->plink_lock);\n\t\treturn 0;\n\t}\n\tsta->mesh->plink_state = NL80211_PLINK_OPN_SNT;\n\tmesh_plink_timer_set(sta, sdata->u.mesh.mshcfg.dot11MeshRetryTimeout);\n\tspin_unlock_bh(&sta->mesh->plink_lock);\n\tmpl_dbg(sdata,\n\t\t\"Mesh plink: starting establishment with %pM\\n\",\n\t\tsta->sta.addr);\n\n\t \n\tchanged = ieee80211_mps_local_status_update(sdata);\n\n\tmesh_plink_frame_tx(sdata, sta, WLAN_SP_MESH_PEERING_OPEN,\n\t\t\t    sta->sta.addr, sta->mesh->llid, 0, 0);\n\treturn changed;\n}\n\nu64 mesh_plink_block(struct sta_info *sta)\n{\n\tu64 changed;\n\n\tspin_lock_bh(&sta->mesh->plink_lock);\n\tchanged = __mesh_plink_deactivate(sta);\n\tsta->mesh->plink_state = NL80211_PLINK_BLOCKED;\n\tspin_unlock_bh(&sta->mesh->plink_lock);\n\tmesh_path_flush_by_nexthop(sta);\n\n\treturn changed;\n}\n\nstatic void mesh_plink_close(struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct sta_info *sta,\n\t\t\t     enum plink_event event)\n{\n\tstruct mesh_config *mshcfg = &sdata->u.mesh.mshcfg;\n\tu16 reason = (event == CLS_ACPT) ?\n\t\t     WLAN_REASON_MESH_CLOSE : WLAN_REASON_MESH_CONFIG;\n\n\tsta->mesh->reason = reason;\n\tsta->mesh->plink_state = NL80211_PLINK_HOLDING;\n\tmod_plink_timer(sta, mshcfg->dot11MeshHoldingTimeout);\n}\n\nstatic u64 mesh_plink_establish(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct sta_info *sta)\n{\n\tstruct mesh_config *mshcfg = &sdata->u.mesh.mshcfg;\n\tu64 changed = 0;\n\n\tdel_timer(&sta->mesh->plink_timer);\n\tsta->mesh->plink_state = NL80211_PLINK_ESTAB;\n\tchanged |= mesh_plink_inc_estab_count(sdata);\n\tchanged |= mesh_set_ht_prot_mode(sdata);\n\tchanged |= mesh_set_short_slot_time(sdata);\n\tmpl_dbg(sdata, \"Mesh plink with %pM ESTABLISHED\\n\", sta->sta.addr);\n\tieee80211_mps_sta_status_update(sta);\n\tchanged |= ieee80211_mps_set_sta_local_pm(sta, mshcfg->power_mode);\n\treturn changed;\n}\n\n \nstatic u64 mesh_plink_fsm(struct ieee80211_sub_if_data *sdata,\n\t\t\t  struct sta_info *sta, enum plink_event event)\n{\n\tstruct mesh_config *mshcfg = &sdata->u.mesh.mshcfg;\n\tenum ieee80211_self_protected_actioncode action = 0;\n\tu64 changed = 0;\n\tbool flush = false;\n\n\tmpl_dbg(sdata, \"peer %pM in state %s got event %s\\n\", sta->sta.addr,\n\t\tmplstates[sta->mesh->plink_state], mplevents[event]);\n\n\tspin_lock_bh(&sta->mesh->plink_lock);\n\tswitch (sta->mesh->plink_state) {\n\tcase NL80211_PLINK_LISTEN:\n\t\tswitch (event) {\n\t\tcase CLS_ACPT:\n\t\t\tmesh_plink_fsm_restart(sta);\n\t\t\tbreak;\n\t\tcase OPN_ACPT:\n\t\t\tsta->mesh->plink_state = NL80211_PLINK_OPN_RCVD;\n\t\t\tsta->mesh->llid = mesh_get_new_llid(sdata);\n\t\t\tmesh_plink_timer_set(sta,\n\t\t\t\t\t     mshcfg->dot11MeshRetryTimeout);\n\n\t\t\t \n\t\t\tchanged |= ieee80211_mps_local_status_update(sdata);\n\t\t\taction = WLAN_SP_MESH_PEERING_OPEN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NL80211_PLINK_OPN_SNT:\n\t\tswitch (event) {\n\t\tcase OPN_RJCT:\n\t\tcase CNF_RJCT:\n\t\tcase CLS_ACPT:\n\t\t\tmesh_plink_close(sdata, sta, event);\n\t\t\taction = WLAN_SP_MESH_PEERING_CLOSE;\n\t\t\tbreak;\n\t\tcase OPN_ACPT:\n\t\t\t \n\t\t\tsta->mesh->plink_state = NL80211_PLINK_OPN_RCVD;\n\t\t\taction = WLAN_SP_MESH_PEERING_CONFIRM;\n\t\t\tbreak;\n\t\tcase CNF_ACPT:\n\t\t\tsta->mesh->plink_state = NL80211_PLINK_CNF_RCVD;\n\t\t\tmod_plink_timer(sta, mshcfg->dot11MeshConfirmTimeout);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NL80211_PLINK_OPN_RCVD:\n\t\tswitch (event) {\n\t\tcase OPN_RJCT:\n\t\tcase CNF_RJCT:\n\t\tcase CLS_ACPT:\n\t\t\tmesh_plink_close(sdata, sta, event);\n\t\t\taction = WLAN_SP_MESH_PEERING_CLOSE;\n\t\t\tbreak;\n\t\tcase OPN_ACPT:\n\t\t\taction = WLAN_SP_MESH_PEERING_CONFIRM;\n\t\t\tbreak;\n\t\tcase CNF_ACPT:\n\t\t\tchanged |= mesh_plink_establish(sdata, sta);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NL80211_PLINK_CNF_RCVD:\n\t\tswitch (event) {\n\t\tcase OPN_RJCT:\n\t\tcase CNF_RJCT:\n\t\tcase CLS_ACPT:\n\t\t\tmesh_plink_close(sdata, sta, event);\n\t\t\taction = WLAN_SP_MESH_PEERING_CLOSE;\n\t\t\tbreak;\n\t\tcase OPN_ACPT:\n\t\t\tchanged |= mesh_plink_establish(sdata, sta);\n\t\t\taction = WLAN_SP_MESH_PEERING_CONFIRM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NL80211_PLINK_ESTAB:\n\t\tswitch (event) {\n\t\tcase CLS_ACPT:\n\t\t\tchanged |= __mesh_plink_deactivate(sta);\n\t\t\tchanged |= mesh_set_ht_prot_mode(sdata);\n\t\t\tchanged |= mesh_set_short_slot_time(sdata);\n\t\t\tmesh_plink_close(sdata, sta, event);\n\t\t\taction = WLAN_SP_MESH_PEERING_CLOSE;\n\t\t\tflush = true;\n\t\t\tbreak;\n\t\tcase OPN_ACPT:\n\t\t\taction = WLAN_SP_MESH_PEERING_CONFIRM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NL80211_PLINK_HOLDING:\n\t\tswitch (event) {\n\t\tcase CLS_ACPT:\n\t\t\tdel_timer(&sta->mesh->plink_timer);\n\t\t\tmesh_plink_fsm_restart(sta);\n\t\t\tbreak;\n\t\tcase OPN_ACPT:\n\t\tcase CNF_ACPT:\n\t\tcase OPN_RJCT:\n\t\tcase CNF_RJCT:\n\t\t\taction = WLAN_SP_MESH_PEERING_CLOSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\tspin_unlock_bh(&sta->mesh->plink_lock);\n\tif (flush)\n\t\tmesh_path_flush_by_nexthop(sta);\n\tif (action) {\n\t\tmesh_plink_frame_tx(sdata, sta, action, sta->sta.addr,\n\t\t\t\t    sta->mesh->llid, sta->mesh->plid,\n\t\t\t\t    sta->mesh->reason);\n\n\t\t \n\t\tif (action == WLAN_SP_MESH_PEERING_OPEN) {\n\t\t\tmesh_plink_frame_tx(sdata, sta,\n\t\t\t\t\t    WLAN_SP_MESH_PEERING_CONFIRM,\n\t\t\t\t\t    sta->sta.addr, sta->mesh->llid,\n\t\t\t\t\t    sta->mesh->plid, 0);\n\t\t}\n\t}\n\n\treturn changed;\n}\n\n \nstatic enum plink_event\nmesh_plink_get_event(struct ieee80211_sub_if_data *sdata,\n\t\t     struct sta_info *sta,\n\t\t     struct ieee802_11_elems *elems,\n\t\t     enum ieee80211_self_protected_actioncode ftype,\n\t\t     u16 llid, u16 plid)\n{\n\tenum plink_event event = PLINK_UNDEFINED;\n\tu8 ie_len = elems->peering_len;\n\tbool matches_local;\n\n\tmatches_local = (ftype == WLAN_SP_MESH_PEERING_CLOSE ||\n\t\t\t mesh_matches_local(sdata, elems));\n\n\t \n\tif (!matches_local && !sta) {\n\t\tevent = OPN_RJCT;\n\t\tgoto out;\n\t}\n\n\tif (!sta) {\n\t\tif (ftype != WLAN_SP_MESH_PEERING_OPEN) {\n\t\t\tmpl_dbg(sdata, \"Mesh plink: cls or cnf from unknown peer\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (!mesh_plink_free_count(sdata)) {\n\t\t\tmpl_dbg(sdata, \"Mesh plink error: no more free plinks\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tevent = OPN_ACPT;\n\t\tgoto out;\n\t} else {\n\t\tif (!test_sta_flag(sta, WLAN_STA_AUTH)) {\n\t\t\tmpl_dbg(sdata, \"Mesh plink: Action frame from non-authed peer\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (sta->mesh->plink_state == NL80211_PLINK_BLOCKED)\n\t\t\tgoto out;\n\t}\n\n\tswitch (ftype) {\n\tcase WLAN_SP_MESH_PEERING_OPEN:\n\t\tif (!matches_local)\n\t\t\tevent = OPN_RJCT;\n\t\telse if (!mesh_plink_free_count(sdata) ||\n\t\t\t (sta->mesh->plid && sta->mesh->plid != plid))\n\t\t\tevent = OPN_IGNR;\n\t\telse\n\t\t\tevent = OPN_ACPT;\n\t\tbreak;\n\tcase WLAN_SP_MESH_PEERING_CONFIRM:\n\t\tif (!matches_local)\n\t\t\tevent = CNF_RJCT;\n\t\telse if (!mesh_plink_free_count(sdata) ||\n\t\t\t sta->mesh->llid != llid ||\n\t\t\t (sta->mesh->plid && sta->mesh->plid != plid))\n\t\t\tevent = CNF_IGNR;\n\t\telse\n\t\t\tevent = CNF_ACPT;\n\t\tbreak;\n\tcase WLAN_SP_MESH_PEERING_CLOSE:\n\t\tif (sta->mesh->plink_state == NL80211_PLINK_ESTAB)\n\t\t\t \n\t\t\tevent = CLS_ACPT;\n\t\telse if (sta->mesh->plid != plid)\n\t\t\tevent = CLS_IGNR;\n\t\telse if (ie_len == 8 && sta->mesh->llid != llid)\n\t\t\tevent = CLS_IGNR;\n\t\telse\n\t\t\tevent = CLS_ACPT;\n\t\tbreak;\n\tdefault:\n\t\tmpl_dbg(sdata, \"Mesh plink: unknown frame subtype\\n\");\n\t\tbreak;\n\t}\n\nout:\n\treturn event;\n}\n\nstatic void\nmesh_process_plink_frame(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct ieee80211_mgmt *mgmt,\n\t\t\t struct ieee802_11_elems *elems,\n\t\t\t struct ieee80211_rx_status *rx_status)\n{\n\n\tstruct sta_info *sta;\n\tenum plink_event event;\n\tenum ieee80211_self_protected_actioncode ftype;\n\tu64 changed = 0;\n\tu8 ie_len = elems->peering_len;\n\tu16 plid, llid = 0;\n\n\tif (!elems->peering) {\n\t\tmpl_dbg(sdata,\n\t\t\t\"Mesh plink: missing necessary peer link ie\\n\");\n\t\treturn;\n\t}\n\n\tif (elems->rsn_len &&\n\t    sdata->u.mesh.security == IEEE80211_MESH_SEC_NONE) {\n\t\tmpl_dbg(sdata,\n\t\t\t\"Mesh plink: can't establish link with secure peer\\n\");\n\t\treturn;\n\t}\n\n\tftype = mgmt->u.action.u.self_prot.action_code;\n\tif ((ftype == WLAN_SP_MESH_PEERING_OPEN && ie_len != 4) ||\n\t    (ftype == WLAN_SP_MESH_PEERING_CONFIRM && ie_len != 6) ||\n\t    (ftype == WLAN_SP_MESH_PEERING_CLOSE && ie_len != 6\n\t\t\t\t\t\t\t&& ie_len != 8)) {\n\t\tmpl_dbg(sdata,\n\t\t\t\"Mesh plink: incorrect plink ie length %d %d\\n\",\n\t\t\tftype, ie_len);\n\t\treturn;\n\t}\n\n\tif (ftype != WLAN_SP_MESH_PEERING_CLOSE &&\n\t    (!elems->mesh_id || !elems->mesh_config)) {\n\t\tmpl_dbg(sdata, \"Mesh plink: missing necessary ie\\n\");\n\t\treturn;\n\t}\n\t \n\tplid = get_unaligned_le16(PLINK_GET_LLID(elems->peering));\n\tif (ftype == WLAN_SP_MESH_PEERING_CONFIRM ||\n\t    (ftype == WLAN_SP_MESH_PEERING_CLOSE && ie_len == 8))\n\t\tllid = get_unaligned_le16(PLINK_GET_PLID(elems->peering));\n\n\t \n\trcu_read_lock();\n\n\tsta = sta_info_get(sdata, mgmt->sa);\n\n\tif (ftype == WLAN_SP_MESH_PEERING_OPEN &&\n\t    !rssi_threshold_check(sdata, sta)) {\n\t\tmpl_dbg(sdata, \"Mesh plink: %pM does not meet rssi threshold\\n\",\n\t\t\tmgmt->sa);\n\t\tgoto unlock_rcu;\n\t}\n\n\t \n\tevent = mesh_plink_get_event(sdata, sta, elems, ftype, llid, plid);\n\n\tif (event == OPN_ACPT) {\n\t\trcu_read_unlock();\n\t\t \n\t\tsta = mesh_sta_info_get(sdata, mgmt->sa, elems, rx_status);\n\t\tif (!sta) {\n\t\t\tmpl_dbg(sdata, \"Mesh plink: failed to init peer!\\n\");\n\t\t\tgoto unlock_rcu;\n\t\t}\n\t\tsta->mesh->plid = plid;\n\t} else if (!sta && event == OPN_RJCT) {\n\t\tmesh_plink_frame_tx(sdata, NULL, WLAN_SP_MESH_PEERING_CLOSE,\n\t\t\t\t    mgmt->sa, 0, plid,\n\t\t\t\t    WLAN_REASON_MESH_CONFIG);\n\t\tgoto unlock_rcu;\n\t} else if (!sta || event == PLINK_UNDEFINED) {\n\t\t \n\t\tgoto unlock_rcu;\n\t}\n\n\tif (event == CNF_ACPT) {\n\t\t \n\t\tif (!sta->mesh->plid)\n\t\t\tsta->mesh->plid = plid;\n\n\t\tsta->mesh->aid = get_unaligned_le16(PLINK_CNF_AID(mgmt));\n\t}\n\n\tchanged |= mesh_plink_fsm(sdata, sta, event);\n\nunlock_rcu:\n\trcu_read_unlock();\n\n\tif (changed)\n\t\tieee80211_mbss_info_change_notify(sdata, changed);\n}\n\nvoid mesh_rx_plink_frame(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t struct ieee80211_rx_status *rx_status)\n{\n\tstruct ieee802_11_elems *elems;\n\tsize_t baselen;\n\tu8 *baseaddr;\n\n\t \n\tif (len < IEEE80211_MIN_ACTION_SIZE + 3)\n\t\treturn;\n\n\tif (sdata->u.mesh.user_mpm)\n\t\t \n\t\treturn;\n\n\tif (is_multicast_ether_addr(mgmt->da)) {\n\t\tmpl_dbg(sdata,\n\t\t\t\"Mesh plink: ignore frame from multicast address\\n\");\n\t\treturn;\n\t}\n\n\tbaseaddr = mgmt->u.action.u.self_prot.variable;\n\tbaselen = (u8 *) mgmt->u.action.u.self_prot.variable - (u8 *) mgmt;\n\tif (mgmt->u.action.u.self_prot.action_code ==\n\t\t\t\t\t\tWLAN_SP_MESH_PEERING_CONFIRM) {\n\t\tbaseaddr += 4;\n\t\tbaselen += 4;\n\n\t\tif (baselen > len)\n\t\t\treturn;\n\t}\n\telems = ieee802_11_parse_elems(baseaddr, len - baselen, true, NULL);\n\tif (elems) {\n\t\tmesh_process_plink_frame(sdata, mgmt, elems, rx_status);\n\t\tkfree(elems);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}