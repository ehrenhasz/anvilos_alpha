{
  "module_name": "mesh_sync.c",
  "hash_id": "d743ef660c72578b818b9d7a980b66e2bebfb74bc915de0bfc4edf8b2ad42cad",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/mesh_sync.c",
  "human_readable_source": "\n \n\n#include \"ieee80211_i.h\"\n#include \"mesh.h\"\n#include \"driver-ops.h\"\n\n \n#define TOFFSET_MINIMUM_ADJUSTMENT 10\n\n \n#define TOFFSET_SET_MARGIN 20\n\n \n#define TOFFSET_MAXIMUM_ADJUSTMENT 800\t\t \n\nstruct sync_method {\n\tu8 method;\n\tstruct ieee80211_mesh_sync_ops ops;\n};\n\n \nstatic bool mesh_peer_tbtt_adjusting(const struct ieee80211_meshconf_ie *cfg)\n{\n\treturn cfg &&\n\t       (cfg->meshconf_cap & IEEE80211_MESHCONF_CAPAB_TBTT_ADJUSTING);\n}\n\nvoid mesh_sync_adjust_tsf(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\t \n\tu64 beacon_int_fraction = sdata->vif.bss_conf.beacon_int * 1024 / 2500;\n\tu64 tsf;\n\tu64 tsfdelta;\n\n\tspin_lock_bh(&ifmsh->sync_offset_lock);\n\tif (ifmsh->sync_offset_clockdrift_max < beacon_int_fraction) {\n\t\tmsync_dbg(sdata, \"TSF : max clockdrift=%lld; adjusting\\n\",\n\t\t\t  (long long) ifmsh->sync_offset_clockdrift_max);\n\t\ttsfdelta = -ifmsh->sync_offset_clockdrift_max;\n\t\tifmsh->sync_offset_clockdrift_max = 0;\n\t} else {\n\t\tmsync_dbg(sdata, \"TSF : max clockdrift=%lld; adjusting by %llu\\n\",\n\t\t\t  (long long) ifmsh->sync_offset_clockdrift_max,\n\t\t\t  (unsigned long long) beacon_int_fraction);\n\t\ttsfdelta = -beacon_int_fraction;\n\t\tifmsh->sync_offset_clockdrift_max -= beacon_int_fraction;\n\t}\n\tspin_unlock_bh(&ifmsh->sync_offset_lock);\n\n\tif (local->ops->offset_tsf) {\n\t\tdrv_offset_tsf(local, sdata, tsfdelta);\n\t} else {\n\t\ttsf = drv_get_tsf(local, sdata);\n\t\tif (tsf != -1ULL)\n\t\t\tdrv_set_tsf(local, sdata, tsf + tsfdelta);\n\t}\n}\n\nstatic void\nmesh_sync_offset_rx_bcn_presp(struct ieee80211_sub_if_data *sdata, u16 stype,\n\t\t\t      struct ieee80211_mgmt *mgmt, unsigned int len,\n\t\t\t      const struct ieee80211_meshconf_ie *mesh_cfg,\n\t\t\t      struct ieee80211_rx_status *rx_status)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tu64 t_t, t_r;\n\n\tWARN_ON(ifmsh->mesh_sp_id != IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET);\n\n\t \n\tif (stype != IEEE80211_STYPE_BEACON)\n\t\treturn;\n\n\t \n\tif (ieee80211_have_rx_timestamp(rx_status))\n\t\tt_r = ieee80211_calculate_rx_timestamp(local, rx_status,\n\t\t\t\t\t\t       len + FCS_LEN, 24);\n\telse\n\t\tt_r = drv_get_tsf(local, sdata);\n\n\trcu_read_lock();\n\tsta = sta_info_get(sdata, mgmt->sa);\n\tif (!sta)\n\t\tgoto no_sync;\n\n\t \n\n\tif (mesh_peer_tbtt_adjusting(mesh_cfg)) {\n\t\tmsync_dbg(sdata, \"STA %pM : is adjusting TBTT\\n\",\n\t\t\t  sta->sta.addr);\n\t\tgoto no_sync;\n\t}\n\n\t \n\tt_t = le64_to_cpu(mgmt->u.beacon.timestamp);\n\tsta->mesh->t_offset = t_t - t_r;\n\n\tif (test_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN)) {\n\t\ts64 t_clockdrift = sta->mesh->t_offset_setpoint - sta->mesh->t_offset;\n\t\tmsync_dbg(sdata,\n\t\t\t  \"STA %pM : t_offset=%lld, t_offset_setpoint=%lld, t_clockdrift=%lld\\n\",\n\t\t\t  sta->sta.addr, (long long) sta->mesh->t_offset,\n\t\t\t  (long long) sta->mesh->t_offset_setpoint,\n\t\t\t  (long long) t_clockdrift);\n\n\t\tif (t_clockdrift > TOFFSET_MAXIMUM_ADJUSTMENT ||\n\t\t    t_clockdrift < -TOFFSET_MAXIMUM_ADJUSTMENT) {\n\t\t\tmsync_dbg(sdata,\n\t\t\t\t  \"STA %pM : t_clockdrift=%lld too large, setpoint reset\\n\",\n\t\t\t\t  sta->sta.addr,\n\t\t\t\t  (long long) t_clockdrift);\n\t\t\tclear_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN);\n\t\t\tgoto no_sync;\n\t\t}\n\n\t\tspin_lock_bh(&ifmsh->sync_offset_lock);\n\t\tif (t_clockdrift > ifmsh->sync_offset_clockdrift_max)\n\t\t\tifmsh->sync_offset_clockdrift_max = t_clockdrift;\n\t\tspin_unlock_bh(&ifmsh->sync_offset_lock);\n\t} else {\n\t\tsta->mesh->t_offset_setpoint = sta->mesh->t_offset - TOFFSET_SET_MARGIN;\n\t\tset_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN);\n\t\tmsync_dbg(sdata,\n\t\t\t  \"STA %pM : offset was invalid, t_offset=%lld\\n\",\n\t\t\t  sta->sta.addr,\n\t\t\t  (long long) sta->mesh->t_offset);\n\t}\n\nno_sync:\n\trcu_read_unlock();\n}\n\nstatic void mesh_sync_offset_adjust_tsf(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct beacon_data *beacon)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\n\tWARN_ON(ifmsh->mesh_sp_id != IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET);\n\tWARN_ON(!rcu_read_lock_held());\n\n\tspin_lock_bh(&ifmsh->sync_offset_lock);\n\n\tif (ifmsh->sync_offset_clockdrift_max > TOFFSET_MINIMUM_ADJUSTMENT) {\n\t\t \n\t\tmsync_dbg(sdata,\n\t\t\t  \"TSF : kicking off TSF adjustment with clockdrift_max=%lld\\n\",\n\t\t\t  ifmsh->sync_offset_clockdrift_max);\n\t\tset_bit(MESH_WORK_DRIFT_ADJUST, &ifmsh->wrkq_flags);\n\t} else {\n\t\tmsync_dbg(sdata,\n\t\t\t  \"TSF : max clockdrift=%lld; too small to adjust\\n\",\n\t\t\t  (long long)ifmsh->sync_offset_clockdrift_max);\n\t\tifmsh->sync_offset_clockdrift_max = 0;\n\t}\n\tspin_unlock_bh(&ifmsh->sync_offset_lock);\n}\n\nstatic const struct sync_method sync_methods[] = {\n\t{\n\t\t.method = IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET,\n\t\t.ops = {\n\t\t\t.rx_bcn_presp = &mesh_sync_offset_rx_bcn_presp,\n\t\t\t.adjust_tsf = &mesh_sync_offset_adjust_tsf,\n\t\t}\n\t},\n};\n\nconst struct ieee80211_mesh_sync_ops *ieee80211_mesh_sync_ops_get(u8 method)\n{\n\tint i;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(sync_methods); ++i) {\n\t\tif (sync_methods[i].method == method)\n\t\t\treturn &sync_methods[i].ops;\n\t}\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}