{
  "module_name": "mesh_ps.c",
  "hash_id": "1bcc08dcd560226a4b019ee16a05c66434af0eb5f23ad15f0ce4098869abe114",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/mesh_ps.c",
  "human_readable_source": "\n \n\n#include \"mesh.h\"\n#include \"wme.h\"\n\n\n \n\n \nstatic struct sk_buff *mps_qos_null_get(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_hdr *nullfunc;  \n\tstruct sk_buff *skb;\n\tint size = sizeof(*nullfunc);\n\t__le16 fc;\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + size + 2);\n\tif (!skb)\n\t\treturn NULL;\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tnullfunc = skb_put(skb, size);\n\tfc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_QOS_NULLFUNC);\n\tieee80211_fill_mesh_addresses(nullfunc, &fc, sta->sta.addr,\n\t\t\t\t      sdata->vif.addr);\n\tnullfunc->frame_control = fc;\n\tnullfunc->duration_id = 0;\n\tnullfunc->seq_ctrl = 0;\n\t \n\tmemcpy(nullfunc->addr1, sta->sta.addr, ETH_ALEN);\n\tskb_put_zero(skb, 2);  \n\tieee80211_mps_set_frame_flags(sdata, sta, nullfunc);\n\n\treturn skb;\n}\n\n \nstatic void mps_qos_null_tx(struct sta_info *sta)\n{\n\tstruct sk_buff *skb;\n\n\tskb = mps_qos_null_get(sta);\n\tif (!skb)\n\t\treturn;\n\n\tmps_dbg(sta->sdata, \"announcing peer-specific power mode to %pM\\n\",\n\t\tsta->sta.addr);\n\n\t \n\tif (!test_sta_flag(sta, WLAN_STA_PS_STA)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl((void *) skb->data);\n\n\t\tqc[0] |= IEEE80211_QOS_CTL_EOSP;\n\t}\n\n\tieee80211_tx_skb(sta->sdata, skb);\n}\n\n \nu64 ieee80211_mps_local_status_update(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct sta_info *sta;\n\tbool peering = false;\n\tint light_sleep_cnt = 0;\n\tint deep_sleep_cnt = 0;\n\tu64 changed = 0;\n\tenum nl80211_mesh_power_mode nonpeer_pm;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sta, &sdata->local->sta_list, list) {\n\t\tif (sdata != sta->sdata)\n\t\t\tcontinue;\n\n\t\tswitch (sta->mesh->plink_state) {\n\t\tcase NL80211_PLINK_OPN_SNT:\n\t\tcase NL80211_PLINK_OPN_RCVD:\n\t\tcase NL80211_PLINK_CNF_RCVD:\n\t\t\tpeering = true;\n\t\t\tbreak;\n\t\tcase NL80211_PLINK_ESTAB:\n\t\t\tif (sta->mesh->local_pm == NL80211_MESH_POWER_LIGHT_SLEEP)\n\t\t\t\tlight_sleep_cnt++;\n\t\t\telse if (sta->mesh->local_pm == NL80211_MESH_POWER_DEEP_SLEEP)\n\t\t\t\tdeep_sleep_cnt++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t \n\tif (peering) {\n\t\tmps_dbg(sdata, \"setting non-peer PM to active for peering\\n\");\n\t\tnonpeer_pm = NL80211_MESH_POWER_ACTIVE;\n\t} else if (light_sleep_cnt || deep_sleep_cnt) {\n\t\tmps_dbg(sdata, \"setting non-peer PM to deep sleep\\n\");\n\t\tnonpeer_pm = NL80211_MESH_POWER_DEEP_SLEEP;\n\t} else {\n\t\tmps_dbg(sdata, \"setting non-peer PM to user value\\n\");\n\t\tnonpeer_pm = ifmsh->mshcfg.power_mode;\n\t}\n\n\t \n\tif (ifmsh->nonpeer_pm != nonpeer_pm ||\n\t    !ifmsh->ps_peers_light_sleep != !light_sleep_cnt ||\n\t    !ifmsh->ps_peers_deep_sleep != !deep_sleep_cnt)\n\t\tchanged = BSS_CHANGED_BEACON;\n\n\tifmsh->nonpeer_pm = nonpeer_pm;\n\tifmsh->ps_peers_light_sleep = light_sleep_cnt;\n\tifmsh->ps_peers_deep_sleep = deep_sleep_cnt;\n\n\treturn changed;\n}\n\n \nu64 ieee80211_mps_set_sta_local_pm(struct sta_info *sta,\n\t\t\t\t   enum nl80211_mesh_power_mode pm)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\n\tif (sta->mesh->local_pm == pm)\n\t\treturn 0;\n\n\tmps_dbg(sdata, \"local STA operates in mode %d with %pM\\n\",\n\t\tpm, sta->sta.addr);\n\n\tsta->mesh->local_pm = pm;\n\n\t \n\tif (sta->mesh->plink_state == NL80211_PLINK_ESTAB)\n\t\tmps_qos_null_tx(sta);\n\n\treturn ieee80211_mps_local_status_update(sdata);\n}\n\n \nvoid ieee80211_mps_set_frame_flags(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct sta_info *sta,\n\t\t\t\t   struct ieee80211_hdr *hdr)\n{\n\tenum nl80211_mesh_power_mode pm;\n\tu8 *qc;\n\n\tif (WARN_ON(is_unicast_ether_addr(hdr->addr1) &&\n\t\t    ieee80211_is_data_qos(hdr->frame_control) &&\n\t\t    !sta))\n\t\treturn;\n\n\tif (is_unicast_ether_addr(hdr->addr1) &&\n\t    ieee80211_is_data_qos(hdr->frame_control) &&\n\t    sta->mesh->plink_state == NL80211_PLINK_ESTAB)\n\t\tpm = sta->mesh->local_pm;\n\telse\n\t\tpm = sdata->u.mesh.nonpeer_pm;\n\n\tif (pm == NL80211_MESH_POWER_ACTIVE)\n\t\thdr->frame_control &= cpu_to_le16(~IEEE80211_FCTL_PM);\n\telse\n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\n\tif (!ieee80211_is_data_qos(hdr->frame_control))\n\t\treturn;\n\n\tqc = ieee80211_get_qos_ctl(hdr);\n\n\tif ((is_unicast_ether_addr(hdr->addr1) &&\n\t     pm == NL80211_MESH_POWER_DEEP_SLEEP) ||\n\t    (is_multicast_ether_addr(hdr->addr1) &&\n\t     sdata->u.mesh.ps_peers_deep_sleep > 0))\n\t\tqc[1] |= (IEEE80211_QOS_CTL_MESH_PS_LEVEL >> 8);\n\telse\n\t\tqc[1] &= ~(IEEE80211_QOS_CTL_MESH_PS_LEVEL >> 8);\n}\n\n \nvoid ieee80211_mps_sta_status_update(struct sta_info *sta)\n{\n\tenum nl80211_mesh_power_mode pm;\n\tbool do_buffer;\n\n\t \n\tif (sta->sta_state < IEEE80211_STA_ASSOC)\n\t\treturn;\n\n\t \n\tif (sta->mesh->plink_state == NL80211_PLINK_ESTAB &&\n\t    sta->mesh->peer_pm != NL80211_MESH_POWER_UNKNOWN)\n\t\tpm = sta->mesh->peer_pm;\n\telse\n\t\tpm = sta->mesh->nonpeer_pm;\n\n\tdo_buffer = (pm != NL80211_MESH_POWER_ACTIVE);\n\n\t \n\tif (sta->mesh->plink_state != NL80211_PLINK_ESTAB) {\n\t\tclear_sta_flag(sta, WLAN_STA_MPSP_OWNER);\n\t\tclear_sta_flag(sta, WLAN_STA_MPSP_RECIPIENT);\n\t} else if (!do_buffer) {\n\t\tclear_sta_flag(sta, WLAN_STA_MPSP_OWNER);\n\t}\n\n\t \n\tif (test_sta_flag(sta, WLAN_STA_PS_STA) == do_buffer)\n\t\treturn;\n\n\tif (do_buffer) {\n\t\tset_sta_flag(sta, WLAN_STA_PS_STA);\n\t\tatomic_inc(&sta->sdata->u.mesh.ps.num_sta_ps);\n\t\tmps_dbg(sta->sdata, \"start PS buffering frames towards %pM\\n\",\n\t\t\tsta->sta.addr);\n\t} else {\n\t\tieee80211_sta_ps_deliver_wakeup(sta);\n\t}\n}\n\nstatic void mps_set_sta_peer_pm(struct sta_info *sta,\n\t\t\t\tstruct ieee80211_hdr *hdr)\n{\n\tenum nl80211_mesh_power_mode pm;\n\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\n\t \n\tif (ieee80211_has_pm(hdr->frame_control)) {\n\t\tif (qc[1] & (IEEE80211_QOS_CTL_MESH_PS_LEVEL >> 8))\n\t\t\tpm = NL80211_MESH_POWER_DEEP_SLEEP;\n\t\telse\n\t\t\tpm = NL80211_MESH_POWER_LIGHT_SLEEP;\n\t} else {\n\t\tpm = NL80211_MESH_POWER_ACTIVE;\n\t}\n\n\tif (sta->mesh->peer_pm == pm)\n\t\treturn;\n\n\tmps_dbg(sta->sdata, \"STA %pM enters mode %d\\n\",\n\t\tsta->sta.addr, pm);\n\n\tsta->mesh->peer_pm = pm;\n\n\tieee80211_mps_sta_status_update(sta);\n}\n\nstatic void mps_set_sta_nonpeer_pm(struct sta_info *sta,\n\t\t\t\t   struct ieee80211_hdr *hdr)\n{\n\tenum nl80211_mesh_power_mode pm;\n\n\tif (ieee80211_has_pm(hdr->frame_control))\n\t\tpm = NL80211_MESH_POWER_DEEP_SLEEP;\n\telse\n\t\tpm = NL80211_MESH_POWER_ACTIVE;\n\n\tif (sta->mesh->nonpeer_pm == pm)\n\t\treturn;\n\n\tmps_dbg(sta->sdata, \"STA %pM sets non-peer mode to %d\\n\",\n\t\tsta->sta.addr, pm);\n\n\tsta->mesh->nonpeer_pm = pm;\n\n\tieee80211_mps_sta_status_update(sta);\n}\n\n \nvoid ieee80211_mps_rx_h_sta_process(struct sta_info *sta,\n\t\t\t\t    struct ieee80211_hdr *hdr)\n{\n\tif (is_unicast_ether_addr(hdr->addr1) &&\n\t    ieee80211_is_data_qos(hdr->frame_control)) {\n\t\t \n\t\tmps_set_sta_peer_pm(sta, hdr);\n\n\t\t \n\t\tieee80211_mpsp_trigger_process(ieee80211_get_qos_ctl(hdr),\n\t\t\t\t\t       sta, false, false);\n\t} else {\n\t\t \n\t\tmps_set_sta_nonpeer_pm(sta, hdr);\n\t}\n}\n\n\n \n\nstatic void mpsp_trigger_send(struct sta_info *sta, bool rspi, bool eosp)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *nullfunc;\n\tstruct ieee80211_tx_info *info;\n\tu8 *qc;\n\n\tskb = mps_qos_null_get(sta);\n\tif (!skb)\n\t\treturn;\n\n\tnullfunc = (struct ieee80211_hdr *) skb->data;\n\tif (!eosp)\n\t\tnullfunc->frame_control |=\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t \n\tqc = ieee80211_get_qos_ctl(nullfunc);\n\tif (rspi)\n\t\tqc[1] |= (IEEE80211_QOS_CTL_RSPI >> 8);\n\tif (eosp)\n\t\tqc[0] |= IEEE80211_QOS_CTL_EOSP;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER |\n\t\t       IEEE80211_TX_CTL_REQ_TX_STATUS;\n\n\tmps_dbg(sdata, \"sending MPSP trigger%s%s to %pM\\n\",\n\t\trspi ? \" RSPI\" : \"\", eosp ? \" EOSP\" : \"\", sta->sta.addr);\n\n\tieee80211_tx_skb(sdata, skb);\n}\n\n \nstatic void mpsp_qos_null_append(struct sta_info *sta,\n\t\t\t\t struct sk_buff_head *frames)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct sk_buff *new_skb, *skb = skb_peek_tail(frames);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_tx_info *info;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\treturn;\n\n\tnew_skb = mps_qos_null_get(sta);\n\tif (!new_skb)\n\t\treturn;\n\n\tmps_dbg(sdata, \"appending QoS Null in MPSP towards %pM\\n\",\n\t\tsta->sta.addr);\n\t \n\tnew_skb->priority = 1;\n\tskb_set_queue_mapping(new_skb, IEEE80211_AC_BK);\n\tieee80211_set_qos_hdr(sdata, new_skb);\n\n\tinfo = IEEE80211_SKB_CB(new_skb);\n\tinfo->control.vif = &sdata->vif;\n\tinfo->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\n\t__skb_queue_tail(frames, new_skb);\n}\n\n \nstatic void mps_frame_deliver(struct sta_info *sta, int n_frames)\n{\n\tstruct ieee80211_local *local = sta->sdata->local;\n\tint ac;\n\tstruct sk_buff_head frames;\n\tstruct sk_buff *skb;\n\tbool more_data = false;\n\n\tskb_queue_head_init(&frames);\n\n\t \n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\twhile (n_frames != 0) {\n\t\t\tskb = skb_dequeue(&sta->tx_filtered[ac]);\n\t\t\tif (!skb) {\n\t\t\t\tskb = skb_dequeue(\n\t\t\t\t\t&sta->ps_tx_buf[ac]);\n\t\t\t\tif (skb)\n\t\t\t\t\tlocal->total_ps_buffered--;\n\t\t\t}\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\t\t\tn_frames--;\n\t\t\t__skb_queue_tail(&frames, skb);\n\t\t}\n\n\t\tif (!skb_queue_empty(&sta->tx_filtered[ac]) ||\n\t\t    !skb_queue_empty(&sta->ps_tx_buf[ac]))\n\t\t\tmore_data = true;\n\t}\n\n\t \n\tif (skb_queue_empty(&frames)) {\n\t\tmpsp_trigger_send(sta, false, true);\n\t\treturn;\n\t}\n\n\t \n\tif (test_sta_flag(sta, WLAN_STA_MPSP_OWNER))\n\t\tmpsp_qos_null_append(sta, &frames);\n\n\tmps_dbg(sta->sdata, \"sending %d frames to PS STA %pM\\n\",\n\t\tskb_queue_len(&frames), sta->sta.addr);\n\n\t \n\tskb_queue_walk(&frames, skb) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\tstruct ieee80211_hdr *hdr = (void *) skb->data;\n\n\t\t \n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_PS_BUFFER;\n\n\t\tif (more_data || !skb_queue_is_last(&frames, skb))\n\t\t\thdr->frame_control |=\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\telse\n\t\t\thdr->frame_control &=\n\t\t\t\tcpu_to_le16(~IEEE80211_FCTL_MOREDATA);\n\n\t\tif (skb_queue_is_last(&frames, skb) &&\n\t\t    ieee80211_is_data_qos(hdr->frame_control)) {\n\t\t\tu8 *qoshdr = ieee80211_get_qos_ctl(hdr);\n\n\t\t\t \n\t\t\t*qoshdr |= IEEE80211_QOS_CTL_EOSP;\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\t\t}\n\t}\n\n\tieee80211_add_pending_skbs(local, &frames);\n\tsta_info_recalc_tim(sta);\n}\n\n \nvoid ieee80211_mpsp_trigger_process(u8 *qc, struct sta_info *sta,\n\t\t\t\t    bool tx, bool acked)\n{\n\tu8 rspi = qc[1] & (IEEE80211_QOS_CTL_RSPI >> 8);\n\tu8 eosp = qc[0] & IEEE80211_QOS_CTL_EOSP;\n\n\tif (tx) {\n\t\tif (rspi && acked)\n\t\t\tset_sta_flag(sta, WLAN_STA_MPSP_RECIPIENT);\n\n\t\tif (eosp)\n\t\t\tclear_sta_flag(sta, WLAN_STA_MPSP_OWNER);\n\t\telse if (acked &&\n\t\t\t test_sta_flag(sta, WLAN_STA_PS_STA) &&\n\t\t\t !test_and_set_sta_flag(sta, WLAN_STA_MPSP_OWNER))\n\t\t\tmps_frame_deliver(sta, -1);\n\t} else {\n\t\tif (eosp)\n\t\t\tclear_sta_flag(sta, WLAN_STA_MPSP_RECIPIENT);\n\t\telse if (sta->mesh->local_pm != NL80211_MESH_POWER_ACTIVE)\n\t\t\tset_sta_flag(sta, WLAN_STA_MPSP_RECIPIENT);\n\n\t\tif (rspi && !test_and_set_sta_flag(sta, WLAN_STA_MPSP_OWNER))\n\t\t\tmps_frame_deliver(sta, -1);\n\t}\n}\n\n \nvoid ieee80211_mps_frame_release(struct sta_info *sta,\n\t\t\t\t struct ieee802_11_elems *elems)\n{\n\tint ac, buffer_local = 0;\n\tbool has_buffered = false;\n\n\tif (sta->mesh->plink_state == NL80211_PLINK_ESTAB)\n\t\thas_buffered = ieee80211_check_tim(elems->tim, elems->tim_len,\n\t\t\t\t\t\t   sta->mesh->aid);\n\n\tif (has_buffered)\n\t\tmps_dbg(sta->sdata, \"%pM indicates buffered frames\\n\",\n\t\t\tsta->sta.addr);\n\n\t \n\tif (test_sta_flag(sta, WLAN_STA_PS_STA) &&\n\t    (!elems->awake_window || !get_unaligned_le16(elems->awake_window)))\n\t\treturn;\n\n\tif (!test_sta_flag(sta, WLAN_STA_MPSP_OWNER))\n\t\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\t\tbuffer_local += skb_queue_len(&sta->ps_tx_buf[ac]) +\n\t\t\t\t\tskb_queue_len(&sta->tx_filtered[ac]);\n\n\tif (!has_buffered && !buffer_local)\n\t\treturn;\n\n\tif (sta->mesh->plink_state == NL80211_PLINK_ESTAB)\n\t\tmpsp_trigger_send(sta, has_buffered, !buffer_local);\n\telse\n\t\tmps_frame_deliver(sta, 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}