{
  "module_name": "mesh_pathtbl.c",
  "hash_id": "52eaba09a2a1ca894f50537e342658dd278beb84e7a38b36e31fdd97a195a0bb",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/mesh_pathtbl.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/list.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <net/mac80211.h>\n#include \"wme.h\"\n#include \"ieee80211_i.h\"\n#include \"mesh.h\"\n#include <linux/rhashtable.h>\n\nstatic void mesh_path_free_rcu(struct mesh_table *tbl, struct mesh_path *mpath);\n\nstatic u32 mesh_table_hash(const void *addr, u32 len, u32 seed)\n{\n\t \n\treturn jhash_1word(__get_unaligned_cpu32((u8 *)addr + 2), seed);\n}\n\nstatic const struct rhashtable_params mesh_rht_params = {\n\t.nelem_hint = 2,\n\t.automatic_shrinking = true,\n\t.key_len = ETH_ALEN,\n\t.key_offset = offsetof(struct mesh_path, dst),\n\t.head_offset = offsetof(struct mesh_path, rhash),\n\t.hashfn = mesh_table_hash,\n};\n\nstatic const struct rhashtable_params fast_tx_rht_params = {\n\t.nelem_hint = 10,\n\t.automatic_shrinking = true,\n\t.key_len = ETH_ALEN,\n\t.key_offset = offsetof(struct ieee80211_mesh_fast_tx, addr_key),\n\t.head_offset = offsetof(struct ieee80211_mesh_fast_tx, rhash),\n\t.hashfn = mesh_table_hash,\n};\n\nstatic void __mesh_fast_tx_entry_free(void *ptr, void *tblptr)\n{\n\tstruct ieee80211_mesh_fast_tx *entry = ptr;\n\n\tkfree_rcu(entry, fast_tx.rcu_head);\n}\n\nstatic void mesh_fast_tx_deinit(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct mesh_tx_cache *cache;\n\n\tcache = &sdata->u.mesh.tx_cache;\n\trhashtable_free_and_destroy(&cache->rht,\n\t\t\t\t    __mesh_fast_tx_entry_free, NULL);\n}\n\nstatic void mesh_fast_tx_init(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct mesh_tx_cache *cache;\n\n\tcache = &sdata->u.mesh.tx_cache;\n\trhashtable_init(&cache->rht, &fast_tx_rht_params);\n\tINIT_HLIST_HEAD(&cache->walk_head);\n\tspin_lock_init(&cache->walk_lock);\n}\n\nstatic inline bool mpath_expired(struct mesh_path *mpath)\n{\n\treturn (mpath->flags & MESH_PATH_ACTIVE) &&\n\t       time_after(jiffies, mpath->exp_time) &&\n\t       !(mpath->flags & MESH_PATH_FIXED);\n}\n\nstatic void mesh_path_rht_free(void *ptr, void *tblptr)\n{\n\tstruct mesh_path *mpath = ptr;\n\tstruct mesh_table *tbl = tblptr;\n\n\tmesh_path_free_rcu(tbl, mpath);\n}\n\nstatic void mesh_table_init(struct mesh_table *tbl)\n{\n\tINIT_HLIST_HEAD(&tbl->known_gates);\n\tINIT_HLIST_HEAD(&tbl->walk_head);\n\tatomic_set(&tbl->entries,  0);\n\tspin_lock_init(&tbl->gates_lock);\n\tspin_lock_init(&tbl->walk_lock);\n\n\t \n\tWARN_ON(rhashtable_init(&tbl->rhead, &mesh_rht_params));\n}\n\nstatic void mesh_table_free(struct mesh_table *tbl)\n{\n\trhashtable_free_and_destroy(&tbl->rhead,\n\t\t\t\t    mesh_path_rht_free, tbl);\n}\n\n \nvoid mesh_path_assign_nexthop(struct mesh_path *mpath, struct sta_info *sta)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tunsigned long flags;\n\n\trcu_assign_pointer(mpath->next_hop, sta);\n\n\tspin_lock_irqsave(&mpath->frame_queue.lock, flags);\n\tskb_queue_walk(&mpath->frame_queue, skb) {\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\t\tmemcpy(hdr->addr1, sta->sta.addr, ETH_ALEN);\n\t\tmemcpy(hdr->addr2, mpath->sdata->vif.addr, ETH_ALEN);\n\t\tieee80211_mps_set_frame_flags(sta->sdata, sta, hdr);\n\t}\n\n\tspin_unlock_irqrestore(&mpath->frame_queue.lock, flags);\n}\n\nstatic void prepare_for_gate(struct sk_buff *skb, char *dst_addr,\n\t\t\t     struct mesh_path *gate_mpath)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211s_hdr *mshdr;\n\tint mesh_hdrlen, hdrlen;\n\tchar *next_hop;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tmshdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);\n\n\tif (!(mshdr->flags & MESH_FLAGS_AE)) {\n\t\t \n\t\tmesh_hdrlen = 6;\n\n\t\t \n\t\tskb_push(skb, 2 * ETH_ALEN);\n\t\tmemmove(skb->data, hdr, hdrlen + mesh_hdrlen);\n\n\t\thdr = (struct ieee80211_hdr *) skb->data;\n\n\t\t \n\t\tmshdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);\n\t\tmshdr->flags = MESH_FLAGS_AE_A5_A6;\n\t\tmemcpy(mshdr->eaddr1, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(mshdr->eaddr2, hdr->addr4, ETH_ALEN);\n\t}\n\n\t \n\thdr = (struct ieee80211_hdr *) skb->data;\n\trcu_read_lock();\n\tnext_hop = rcu_dereference(gate_mpath->next_hop)->sta.addr;\n\tmemcpy(hdr->addr1, next_hop, ETH_ALEN);\n\trcu_read_unlock();\n\tmemcpy(hdr->addr2, gate_mpath->sdata->vif.addr, ETH_ALEN);\n\tmemcpy(hdr->addr3, dst_addr, ETH_ALEN);\n}\n\n \nstatic void mesh_path_move_to_queue(struct mesh_path *gate_mpath,\n\t\t\t\t    struct mesh_path *from_mpath,\n\t\t\t\t    bool copy)\n{\n\tstruct sk_buff *skb, *fskb, *tmp;\n\tstruct sk_buff_head failq;\n\tunsigned long flags;\n\n\tif (WARN_ON(gate_mpath == from_mpath))\n\t\treturn;\n\tif (WARN_ON(!gate_mpath->next_hop))\n\t\treturn;\n\n\t__skb_queue_head_init(&failq);\n\n\tspin_lock_irqsave(&from_mpath->frame_queue.lock, flags);\n\tskb_queue_splice_init(&from_mpath->frame_queue, &failq);\n\tspin_unlock_irqrestore(&from_mpath->frame_queue.lock, flags);\n\n\tskb_queue_walk_safe(&failq, fskb, tmp) {\n\t\tif (skb_queue_len(&gate_mpath->frame_queue) >=\n\t\t\t\t  MESH_FRAME_QUEUE_LEN) {\n\t\t\tmpath_dbg(gate_mpath->sdata, \"mpath queue full!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tskb = skb_copy(fskb, GFP_ATOMIC);\n\t\tif (WARN_ON(!skb))\n\t\t\tbreak;\n\n\t\tprepare_for_gate(skb, gate_mpath->dst, gate_mpath);\n\t\tskb_queue_tail(&gate_mpath->frame_queue, skb);\n\n\t\tif (copy)\n\t\t\tcontinue;\n\n\t\t__skb_unlink(fskb, &failq);\n\t\tkfree_skb(fskb);\n\t}\n\n\tmpath_dbg(gate_mpath->sdata, \"Mpath queue for gate %pM has %d frames\\n\",\n\t\t  gate_mpath->dst, skb_queue_len(&gate_mpath->frame_queue));\n\n\tif (!copy)\n\t\treturn;\n\n\tspin_lock_irqsave(&from_mpath->frame_queue.lock, flags);\n\tskb_queue_splice(&failq, &from_mpath->frame_queue);\n\tspin_unlock_irqrestore(&from_mpath->frame_queue.lock, flags);\n}\n\n\nstatic struct mesh_path *mpath_lookup(struct mesh_table *tbl, const u8 *dst,\n\t\t\t\t      struct ieee80211_sub_if_data *sdata)\n{\n\tstruct mesh_path *mpath;\n\n\tmpath = rhashtable_lookup(&tbl->rhead, dst, mesh_rht_params);\n\n\tif (mpath && mpath_expired(mpath)) {\n\t\tspin_lock_bh(&mpath->state_lock);\n\t\tmpath->flags &= ~MESH_PATH_ACTIVE;\n\t\tspin_unlock_bh(&mpath->state_lock);\n\t}\n\treturn mpath;\n}\n\n \nstruct mesh_path *\nmesh_path_lookup(struct ieee80211_sub_if_data *sdata, const u8 *dst)\n{\n\treturn mpath_lookup(&sdata->u.mesh.mesh_paths, dst, sdata);\n}\n\nstruct mesh_path *\nmpp_path_lookup(struct ieee80211_sub_if_data *sdata, const u8 *dst)\n{\n\treturn mpath_lookup(&sdata->u.mesh.mpp_paths, dst, sdata);\n}\n\nstatic struct mesh_path *\n__mesh_path_lookup_by_idx(struct mesh_table *tbl, int idx)\n{\n\tint i = 0;\n\tstruct mesh_path *mpath;\n\n\thlist_for_each_entry_rcu(mpath, &tbl->walk_head, walk_list) {\n\t\tif (i++ == idx)\n\t\t\tbreak;\n\t}\n\n\tif (!mpath)\n\t\treturn NULL;\n\n\tif (mpath_expired(mpath)) {\n\t\tspin_lock_bh(&mpath->state_lock);\n\t\tmpath->flags &= ~MESH_PATH_ACTIVE;\n\t\tspin_unlock_bh(&mpath->state_lock);\n\t}\n\treturn mpath;\n}\n\n \nstruct mesh_path *\nmesh_path_lookup_by_idx(struct ieee80211_sub_if_data *sdata, int idx)\n{\n\treturn __mesh_path_lookup_by_idx(&sdata->u.mesh.mesh_paths, idx);\n}\n\n \nstruct mesh_path *\nmpp_path_lookup_by_idx(struct ieee80211_sub_if_data *sdata, int idx)\n{\n\treturn __mesh_path_lookup_by_idx(&sdata->u.mesh.mpp_paths, idx);\n}\n\n \nint mesh_path_add_gate(struct mesh_path *mpath)\n{\n\tstruct mesh_table *tbl;\n\tint err;\n\n\trcu_read_lock();\n\ttbl = &mpath->sdata->u.mesh.mesh_paths;\n\n\tspin_lock_bh(&mpath->state_lock);\n\tif (mpath->is_gate) {\n\t\terr = -EEXIST;\n\t\tspin_unlock_bh(&mpath->state_lock);\n\t\tgoto err_rcu;\n\t}\n\tmpath->is_gate = true;\n\tmpath->sdata->u.mesh.num_gates++;\n\n\tspin_lock(&tbl->gates_lock);\n\thlist_add_head_rcu(&mpath->gate_list, &tbl->known_gates);\n\tspin_unlock(&tbl->gates_lock);\n\n\tspin_unlock_bh(&mpath->state_lock);\n\n\tmpath_dbg(mpath->sdata,\n\t\t  \"Mesh path: Recorded new gate: %pM. %d known gates\\n\",\n\t\t  mpath->dst, mpath->sdata->u.mesh.num_gates);\n\terr = 0;\nerr_rcu:\n\trcu_read_unlock();\n\treturn err;\n}\n\n \nstatic void mesh_gate_del(struct mesh_table *tbl, struct mesh_path *mpath)\n{\n\tlockdep_assert_held(&mpath->state_lock);\n\tif (!mpath->is_gate)\n\t\treturn;\n\n\tmpath->is_gate = false;\n\tspin_lock_bh(&tbl->gates_lock);\n\thlist_del_rcu(&mpath->gate_list);\n\tmpath->sdata->u.mesh.num_gates--;\n\tspin_unlock_bh(&tbl->gates_lock);\n\n\tmpath_dbg(mpath->sdata,\n\t\t  \"Mesh path: Deleted gate: %pM. %d known gates\\n\",\n\t\t  mpath->dst, mpath->sdata->u.mesh.num_gates);\n}\n\n \nint mesh_gate_num(struct ieee80211_sub_if_data *sdata)\n{\n\treturn sdata->u.mesh.num_gates;\n}\n\nstatic\nstruct mesh_path *mesh_path_new(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *dst, gfp_t gfp_flags)\n{\n\tstruct mesh_path *new_mpath;\n\n\tnew_mpath = kzalloc(sizeof(struct mesh_path), gfp_flags);\n\tif (!new_mpath)\n\t\treturn NULL;\n\n\tmemcpy(new_mpath->dst, dst, ETH_ALEN);\n\teth_broadcast_addr(new_mpath->rann_snd_addr);\n\tnew_mpath->is_root = false;\n\tnew_mpath->sdata = sdata;\n\tnew_mpath->flags = 0;\n\tskb_queue_head_init(&new_mpath->frame_queue);\n\tnew_mpath->exp_time = jiffies;\n\tspin_lock_init(&new_mpath->state_lock);\n\ttimer_setup(&new_mpath->timer, mesh_path_timer, 0);\n\n\treturn new_mpath;\n}\n\nstatic void mesh_fast_tx_entry_free(struct mesh_tx_cache *cache,\n\t\t\t\t    struct ieee80211_mesh_fast_tx *entry)\n{\n\thlist_del_rcu(&entry->walk_list);\n\trhashtable_remove_fast(&cache->rht, &entry->rhash, fast_tx_rht_params);\n\tkfree_rcu(entry, fast_tx.rcu_head);\n}\n\nstruct ieee80211_mesh_fast_tx *\nmesh_fast_tx_get(struct ieee80211_sub_if_data *sdata, const u8 *addr)\n{\n\tstruct ieee80211_mesh_fast_tx *entry;\n\tstruct mesh_tx_cache *cache;\n\n\tcache = &sdata->u.mesh.tx_cache;\n\tentry = rhashtable_lookup(&cache->rht, addr, fast_tx_rht_params);\n\tif (!entry)\n\t\treturn NULL;\n\n\tif (!(entry->mpath->flags & MESH_PATH_ACTIVE) ||\n\t    mpath_expired(entry->mpath)) {\n\t\tspin_lock_bh(&cache->walk_lock);\n\t\tentry = rhashtable_lookup(&cache->rht, addr, fast_tx_rht_params);\n\t\tif (entry)\n\t\t    mesh_fast_tx_entry_free(cache, entry);\n\t\tspin_unlock_bh(&cache->walk_lock);\n\t\treturn NULL;\n\t}\n\n\tmesh_path_refresh(sdata, entry->mpath, NULL);\n\tif (entry->mppath)\n\t\tentry->mppath->exp_time = jiffies;\n\tentry->timestamp = jiffies;\n\n\treturn entry;\n}\n\nvoid mesh_fast_tx_cache(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb, struct mesh_path *mpath)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_mesh_fast_tx *entry, *prev;\n\tstruct ieee80211_mesh_fast_tx build = {};\n\tstruct ieee80211s_hdr *meshhdr;\n\tstruct mesh_tx_cache *cache;\n\tstruct ieee80211_key *key;\n\tstruct mesh_path *mppath;\n\tstruct sta_info *sta;\n\tu8 *qc;\n\n\tif (sdata->noack_map ||\n\t    !ieee80211_is_data_qos(hdr->frame_control))\n\t\treturn;\n\n\tbuild.fast_tx.hdr_len = ieee80211_hdrlen(hdr->frame_control);\n\tmeshhdr = (struct ieee80211s_hdr *)(skb->data + build.fast_tx.hdr_len);\n\tbuild.hdrlen = ieee80211_get_mesh_hdrlen(meshhdr);\n\n\tcache = &sdata->u.mesh.tx_cache;\n\tif (atomic_read(&cache->rht.nelems) >= MESH_FAST_TX_CACHE_MAX_SIZE)\n\t\treturn;\n\n\tsta = rcu_dereference(mpath->next_hop);\n\tif (!sta)\n\t\treturn;\n\n\tif ((meshhdr->flags & MESH_FLAGS_AE) == MESH_FLAGS_AE_A5_A6) {\n\t\t \n\t\tmppath = mpp_path_lookup(sdata, meshhdr->eaddr1);\n\t\tif (!mppath)\n\t\t\treturn;\n\t\tbuild.mppath = mppath;\n\t} else if (ieee80211_has_a4(hdr->frame_control)) {\n\t\tmppath = mpath;\n\t} else {\n\t\treturn;\n\t}\n\n\t \n\tif (mppath->fast_tx_check == jiffies)\n\t\treturn;\n\n\tmppath->fast_tx_check = jiffies;\n\n\t \n\tspin_lock_bh(&sta->lock);\n\tkey = rcu_access_pointer(sta->ptk[sta->ptk_idx]);\n\tif (!key)\n\t\tkey = rcu_access_pointer(sdata->default_unicast_key);\n\tbuild.fast_tx.key = key;\n\n\tif (key) {\n\t\tbool gen_iv, iv_spc;\n\n\t\tgen_iv = key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\tiv_spc = key->conf.flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE;\n\n\t\tif (!(key->flags & KEY_FLAG_UPLOADED_TO_HARDWARE) ||\n\t\t    (key->flags & KEY_FLAG_TAINTED))\n\t\t\tgoto unlock_sta;\n\n\t\tswitch (key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\t\tif (gen_iv)\n\t\t\t\tbuild.fast_tx.pn_offs = build.fast_tx.hdr_len;\n\t\t\tif (gen_iv || iv_spc)\n\t\t\t\tbuild.fast_tx.hdr_len += IEEE80211_CCMP_HDR_LEN;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tif (gen_iv)\n\t\t\t\tbuild.fast_tx.pn_offs = build.fast_tx.hdr_len;\n\t\t\tif (gen_iv || iv_spc)\n\t\t\t\tbuild.fast_tx.hdr_len += IEEE80211_GCMP_HDR_LEN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto unlock_sta;\n\t\t}\n\t}\n\n\tmemcpy(build.addr_key, mppath->dst, ETH_ALEN);\n\tbuild.timestamp = jiffies;\n\tbuild.fast_tx.band = info->band;\n\tbuild.fast_tx.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\tbuild.fast_tx.sa_offs = offsetof(struct ieee80211_hdr, addr4);\n\tbuild.mpath = mpath;\n\tmemcpy(build.hdr, meshhdr, build.hdrlen);\n\tmemcpy(build.hdr + build.hdrlen, rfc1042_header, sizeof(rfc1042_header));\n\tbuild.hdrlen += sizeof(rfc1042_header);\n\tmemcpy(build.fast_tx.hdr, hdr, build.fast_tx.hdr_len);\n\n\thdr = (struct ieee80211_hdr *)build.fast_tx.hdr;\n\tif (build.fast_tx.key)\n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\n\tqc = ieee80211_get_qos_ctl(hdr);\n\tqc[1] |= IEEE80211_QOS_CTL_MESH_CONTROL_PRESENT >> 8;\n\n\tentry = kmemdup(&build, sizeof(build), GFP_ATOMIC);\n\tif (!entry)\n\t\tgoto unlock_sta;\n\n\tspin_lock(&cache->walk_lock);\n\tprev = rhashtable_lookup_get_insert_fast(&cache->rht,\n\t\t\t\t\t\t &entry->rhash,\n\t\t\t\t\t\t fast_tx_rht_params);\n\tif (unlikely(IS_ERR(prev))) {\n\t\tkfree(entry);\n\t\tgoto unlock_cache;\n\t}\n\n\t \n\tif (unlikely(prev)) {\n\t\trhashtable_replace_fast(&cache->rht, &prev->rhash,\n\t\t\t\t\t&entry->rhash, fast_tx_rht_params);\n\t\thlist_del_rcu(&prev->walk_list);\n\t\tkfree_rcu(prev, fast_tx.rcu_head);\n\t}\n\n\thlist_add_head(&entry->walk_list, &cache->walk_head);\n\nunlock_cache:\n\tspin_unlock(&cache->walk_lock);\nunlock_sta:\n\tspin_unlock_bh(&sta->lock);\n}\n\nvoid mesh_fast_tx_gc(struct ieee80211_sub_if_data *sdata)\n{\n\tunsigned long timeout = msecs_to_jiffies(MESH_FAST_TX_CACHE_TIMEOUT);\n\tstruct mesh_tx_cache *cache;\n\tstruct ieee80211_mesh_fast_tx *entry;\n\tstruct hlist_node *n;\n\n\tcache = &sdata->u.mesh.tx_cache;\n\tif (atomic_read(&cache->rht.nelems) < MESH_FAST_TX_CACHE_THRESHOLD_SIZE)\n\t\treturn;\n\n\tspin_lock_bh(&cache->walk_lock);\n\thlist_for_each_entry_safe(entry, n, &cache->walk_head, walk_list)\n\t\tif (!time_is_after_jiffies(entry->timestamp + timeout))\n\t\t\tmesh_fast_tx_entry_free(cache, entry);\n\tspin_unlock_bh(&cache->walk_lock);\n}\n\nvoid mesh_fast_tx_flush_mpath(struct mesh_path *mpath)\n{\n\tstruct ieee80211_sub_if_data *sdata = mpath->sdata;\n\tstruct mesh_tx_cache *cache = &sdata->u.mesh.tx_cache;\n\tstruct ieee80211_mesh_fast_tx *entry;\n\tstruct hlist_node *n;\n\n\tcache = &sdata->u.mesh.tx_cache;\n\tspin_lock_bh(&cache->walk_lock);\n\thlist_for_each_entry_safe(entry, n, &cache->walk_head, walk_list)\n\t\tif (entry->mpath == mpath)\n\t\t\tmesh_fast_tx_entry_free(cache, entry);\n\tspin_unlock_bh(&cache->walk_lock);\n}\n\nvoid mesh_fast_tx_flush_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct sta_info *sta)\n{\n\tstruct mesh_tx_cache *cache = &sdata->u.mesh.tx_cache;\n\tstruct ieee80211_mesh_fast_tx *entry;\n\tstruct hlist_node *n;\n\n\tcache = &sdata->u.mesh.tx_cache;\n\tspin_lock_bh(&cache->walk_lock);\n\thlist_for_each_entry_safe(entry, n, &cache->walk_head, walk_list)\n\t\tif (rcu_access_pointer(entry->mpath->next_hop) == sta)\n\t\t\tmesh_fast_tx_entry_free(cache, entry);\n\tspin_unlock_bh(&cache->walk_lock);\n}\n\nvoid mesh_fast_tx_flush_addr(struct ieee80211_sub_if_data *sdata,\n\t\t\t     const u8 *addr)\n{\n\tstruct mesh_tx_cache *cache = &sdata->u.mesh.tx_cache;\n\tstruct ieee80211_mesh_fast_tx *entry;\n\n\tcache = &sdata->u.mesh.tx_cache;\n\tspin_lock_bh(&cache->walk_lock);\n\tentry = rhashtable_lookup_fast(&cache->rht, addr, fast_tx_rht_params);\n\tif (entry)\n\t\tmesh_fast_tx_entry_free(cache, entry);\n\tspin_unlock_bh(&cache->walk_lock);\n}\n\n \nstruct mesh_path *mesh_path_add(struct ieee80211_sub_if_data *sdata,\n\t\t\t\tconst u8 *dst)\n{\n\tstruct mesh_table *tbl;\n\tstruct mesh_path *mpath, *new_mpath;\n\n\tif (ether_addr_equal(dst, sdata->vif.addr))\n\t\t \n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\tif (is_multicast_ether_addr(dst))\n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\tif (atomic_add_unless(&sdata->u.mesh.mpaths, 1, MESH_MAX_MPATHS) == 0)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tnew_mpath = mesh_path_new(sdata, dst, GFP_ATOMIC);\n\tif (!new_mpath)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttbl = &sdata->u.mesh.mesh_paths;\n\tspin_lock_bh(&tbl->walk_lock);\n\tmpath = rhashtable_lookup_get_insert_fast(&tbl->rhead,\n\t\t\t\t\t\t  &new_mpath->rhash,\n\t\t\t\t\t\t  mesh_rht_params);\n\tif (!mpath)\n\t\thlist_add_head(&new_mpath->walk_list, &tbl->walk_head);\n\tspin_unlock_bh(&tbl->walk_lock);\n\n\tif (mpath) {\n\t\tkfree(new_mpath);\n\n\t\tif (IS_ERR(mpath))\n\t\t\treturn mpath;\n\n\t\tnew_mpath = mpath;\n\t}\n\n\tsdata->u.mesh.mesh_paths_generation++;\n\treturn new_mpath;\n}\n\nint mpp_path_add(struct ieee80211_sub_if_data *sdata,\n\t\t const u8 *dst, const u8 *mpp)\n{\n\tstruct mesh_table *tbl;\n\tstruct mesh_path *new_mpath;\n\tint ret;\n\n\tif (ether_addr_equal(dst, sdata->vif.addr))\n\t\t \n\t\treturn -ENOTSUPP;\n\n\tif (is_multicast_ether_addr(dst))\n\t\treturn -ENOTSUPP;\n\n\tnew_mpath = mesh_path_new(sdata, dst, GFP_ATOMIC);\n\n\tif (!new_mpath)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_mpath->mpp, mpp, ETH_ALEN);\n\ttbl = &sdata->u.mesh.mpp_paths;\n\n\tspin_lock_bh(&tbl->walk_lock);\n\tret = rhashtable_lookup_insert_fast(&tbl->rhead,\n\t\t\t\t\t    &new_mpath->rhash,\n\t\t\t\t\t    mesh_rht_params);\n\tif (!ret)\n\t\thlist_add_head_rcu(&new_mpath->walk_list, &tbl->walk_head);\n\tspin_unlock_bh(&tbl->walk_lock);\n\n\tif (ret)\n\t\tkfree(new_mpath);\n\telse\n\t\tmesh_fast_tx_flush_addr(sdata, dst);\n\n\tsdata->u.mesh.mpp_paths_generation++;\n\treturn ret;\n}\n\n\n \nvoid mesh_plink_broken(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct mesh_table *tbl = &sdata->u.mesh.mesh_paths;\n\tstatic const u8 bcast[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tstruct mesh_path *mpath;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(mpath, &tbl->walk_head, walk_list) {\n\t\tif (rcu_access_pointer(mpath->next_hop) == sta &&\n\t\t    mpath->flags & MESH_PATH_ACTIVE &&\n\t\t    !(mpath->flags & MESH_PATH_FIXED)) {\n\t\t\tspin_lock_bh(&mpath->state_lock);\n\t\t\tmpath->flags &= ~MESH_PATH_ACTIVE;\n\t\t\t++mpath->sn;\n\t\t\tspin_unlock_bh(&mpath->state_lock);\n\t\t\tmesh_path_error_tx(sdata,\n\t\t\t\tsdata->u.mesh.mshcfg.element_ttl,\n\t\t\t\tmpath->dst, mpath->sn,\n\t\t\t\tWLAN_REASON_MESH_PATH_DEST_UNREACHABLE, bcast);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nstatic void mesh_path_free_rcu(struct mesh_table *tbl,\n\t\t\t       struct mesh_path *mpath)\n{\n\tstruct ieee80211_sub_if_data *sdata = mpath->sdata;\n\n\tspin_lock_bh(&mpath->state_lock);\n\tmpath->flags |= MESH_PATH_RESOLVING | MESH_PATH_DELETED;\n\tmesh_gate_del(tbl, mpath);\n\tspin_unlock_bh(&mpath->state_lock);\n\ttimer_shutdown_sync(&mpath->timer);\n\tatomic_dec(&sdata->u.mesh.mpaths);\n\tatomic_dec(&tbl->entries);\n\tmesh_path_flush_pending(mpath);\n\tkfree_rcu(mpath, rcu);\n}\n\nstatic void __mesh_path_del(struct mesh_table *tbl, struct mesh_path *mpath)\n{\n\thlist_del_rcu(&mpath->walk_list);\n\trhashtable_remove_fast(&tbl->rhead, &mpath->rhash, mesh_rht_params);\n\tif (tbl == &mpath->sdata->u.mesh.mpp_paths)\n\t\tmesh_fast_tx_flush_addr(mpath->sdata, mpath->dst);\n\telse\n\t\tmesh_fast_tx_flush_mpath(mpath);\n\tmesh_path_free_rcu(tbl, mpath);\n}\n\n \nvoid mesh_path_flush_by_nexthop(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct mesh_table *tbl = &sdata->u.mesh.mesh_paths;\n\tstruct mesh_path *mpath;\n\tstruct hlist_node *n;\n\n\tspin_lock_bh(&tbl->walk_lock);\n\thlist_for_each_entry_safe(mpath, n, &tbl->walk_head, walk_list) {\n\t\tif (rcu_access_pointer(mpath->next_hop) == sta)\n\t\t\t__mesh_path_del(tbl, mpath);\n\t}\n\tspin_unlock_bh(&tbl->walk_lock);\n}\n\nstatic void mpp_flush_by_proxy(struct ieee80211_sub_if_data *sdata,\n\t\t\t       const u8 *proxy)\n{\n\tstruct mesh_table *tbl = &sdata->u.mesh.mpp_paths;\n\tstruct mesh_path *mpath;\n\tstruct hlist_node *n;\n\n\tspin_lock_bh(&tbl->walk_lock);\n\thlist_for_each_entry_safe(mpath, n, &tbl->walk_head, walk_list) {\n\t\tif (ether_addr_equal(mpath->mpp, proxy))\n\t\t\t__mesh_path_del(tbl, mpath);\n\t}\n\tspin_unlock_bh(&tbl->walk_lock);\n}\n\nstatic void table_flush_by_iface(struct mesh_table *tbl)\n{\n\tstruct mesh_path *mpath;\n\tstruct hlist_node *n;\n\n\tspin_lock_bh(&tbl->walk_lock);\n\thlist_for_each_entry_safe(mpath, n, &tbl->walk_head, walk_list) {\n\t\t__mesh_path_del(tbl, mpath);\n\t}\n\tspin_unlock_bh(&tbl->walk_lock);\n}\n\n \nvoid mesh_path_flush_by_iface(struct ieee80211_sub_if_data *sdata)\n{\n\ttable_flush_by_iface(&sdata->u.mesh.mesh_paths);\n\ttable_flush_by_iface(&sdata->u.mesh.mpp_paths);\n}\n\n \nstatic int table_path_del(struct mesh_table *tbl,\n\t\t\t  struct ieee80211_sub_if_data *sdata,\n\t\t\t  const u8 *addr)\n{\n\tstruct mesh_path *mpath;\n\n\tspin_lock_bh(&tbl->walk_lock);\n\tmpath = rhashtable_lookup_fast(&tbl->rhead, addr, mesh_rht_params);\n\tif (!mpath) {\n\t\tspin_unlock_bh(&tbl->walk_lock);\n\t\treturn -ENXIO;\n\t}\n\n\t__mesh_path_del(tbl, mpath);\n\tspin_unlock_bh(&tbl->walk_lock);\n\treturn 0;\n}\n\n\n \nint mesh_path_del(struct ieee80211_sub_if_data *sdata, const u8 *addr)\n{\n\tint err;\n\n\t \n\tmpp_flush_by_proxy(sdata, addr);\n\n\terr = table_path_del(&sdata->u.mesh.mesh_paths, sdata, addr);\n\tsdata->u.mesh.mesh_paths_generation++;\n\treturn err;\n}\n\n \nvoid mesh_path_tx_pending(struct mesh_path *mpath)\n{\n\tif (mpath->flags & MESH_PATH_ACTIVE)\n\t\tieee80211_add_pending_skbs(mpath->sdata->local,\n\t\t\t\t&mpath->frame_queue);\n}\n\n \nint mesh_path_send_to_gates(struct mesh_path *mpath)\n{\n\tstruct ieee80211_sub_if_data *sdata = mpath->sdata;\n\tstruct mesh_table *tbl;\n\tstruct mesh_path *from_mpath = mpath;\n\tstruct mesh_path *gate;\n\tbool copy = false;\n\n\ttbl = &sdata->u.mesh.mesh_paths;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(gate, &tbl->known_gates, gate_list) {\n\t\tif (gate->flags & MESH_PATH_ACTIVE) {\n\t\t\tmpath_dbg(sdata, \"Forwarding to %pM\\n\", gate->dst);\n\t\t\tmesh_path_move_to_queue(gate, from_mpath, copy);\n\t\t\tfrom_mpath = gate;\n\t\t\tcopy = true;\n\t\t} else {\n\t\t\tmpath_dbg(sdata,\n\t\t\t\t  \"Not forwarding to %pM (flags %#x)\\n\",\n\t\t\t\t  gate->dst, gate->flags);\n\t\t}\n\t}\n\n\thlist_for_each_entry_rcu(gate, &tbl->known_gates, gate_list) {\n\t\tmpath_dbg(sdata, \"Sending to %pM\\n\", gate->dst);\n\t\tmesh_path_tx_pending(gate);\n\t}\n\trcu_read_unlock();\n\n\treturn (from_mpath == mpath) ? -EHOSTUNREACH : 0;\n}\n\n \nvoid mesh_path_discard_frame(struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct sk_buff *skb)\n{\n\tieee80211_free_txskb(&sdata->local->hw, skb);\n\tsdata->u.mesh.mshstats.dropped_frames_no_route++;\n}\n\n \nvoid mesh_path_flush_pending(struct mesh_path *mpath)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&mpath->frame_queue)) != NULL)\n\t\tmesh_path_discard_frame(mpath->sdata, skb);\n}\n\n \nvoid mesh_path_fix_nexthop(struct mesh_path *mpath, struct sta_info *next_hop)\n{\n\tspin_lock_bh(&mpath->state_lock);\n\tmesh_path_assign_nexthop(mpath, next_hop);\n\tmpath->sn = 0xffff;\n\tmpath->metric = 0;\n\tmpath->hop_count = 0;\n\tmpath->exp_time = 0;\n\tmpath->flags = MESH_PATH_FIXED | MESH_PATH_SN_VALID;\n\tmesh_path_activate(mpath);\n\tmesh_fast_tx_flush_mpath(mpath);\n\tspin_unlock_bh(&mpath->state_lock);\n\tewma_mesh_fail_avg_init(&next_hop->mesh->fail_avg);\n\t \n\tewma_mesh_fail_avg_add(&next_hop->mesh->fail_avg, 1);\n\tmesh_path_tx_pending(mpath);\n}\n\nvoid mesh_pathtbl_init(struct ieee80211_sub_if_data *sdata)\n{\n\tmesh_table_init(&sdata->u.mesh.mesh_paths);\n\tmesh_table_init(&sdata->u.mesh.mpp_paths);\n\tmesh_fast_tx_init(sdata);\n}\n\nstatic\nvoid mesh_path_tbl_expire(struct ieee80211_sub_if_data *sdata,\n\t\t\t  struct mesh_table *tbl)\n{\n\tstruct mesh_path *mpath;\n\tstruct hlist_node *n;\n\n\tspin_lock_bh(&tbl->walk_lock);\n\thlist_for_each_entry_safe(mpath, n, &tbl->walk_head, walk_list) {\n\t\tif ((!(mpath->flags & MESH_PATH_RESOLVING)) &&\n\t\t    (!(mpath->flags & MESH_PATH_FIXED)) &&\n\t\t     time_after(jiffies, mpath->exp_time + MESH_PATH_EXPIRE))\n\t\t\t__mesh_path_del(tbl, mpath);\n\t}\n\tspin_unlock_bh(&tbl->walk_lock);\n}\n\nvoid mesh_path_expire(struct ieee80211_sub_if_data *sdata)\n{\n\tmesh_path_tbl_expire(sdata, &sdata->u.mesh.mesh_paths);\n\tmesh_path_tbl_expire(sdata, &sdata->u.mesh.mpp_paths);\n}\n\nvoid mesh_pathtbl_unregister(struct ieee80211_sub_if_data *sdata)\n{\n\tmesh_fast_tx_deinit(sdata);\n\tmesh_table_free(&sdata->u.mesh.mesh_paths);\n\tmesh_table_free(&sdata->u.mesh.mpp_paths);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}