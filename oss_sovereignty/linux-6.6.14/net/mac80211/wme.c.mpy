{
  "module_name": "wme.c",
  "hash_id": "8b63bd3c17cb4b5a54ed3942118f17f685bafbfc87df1a275daeb6e4a1072ab1",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/wme.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/module.h>\n#include <linux/if_arp.h>\n#include <linux/types.h>\n#include <net/ip.h>\n#include <net/pkt_sched.h>\n\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"wme.h\"\n\n \nconst int ieee802_1d_to_ac[8] = {\n\tIEEE80211_AC_BE,\n\tIEEE80211_AC_BK,\n\tIEEE80211_AC_BK,\n\tIEEE80211_AC_BE,\n\tIEEE80211_AC_VI,\n\tIEEE80211_AC_VI,\n\tIEEE80211_AC_VO,\n\tIEEE80211_AC_VO\n};\n\nstatic int wme_downgrade_ac(struct sk_buff *skb)\n{\n\tswitch (skb->priority) {\n\tcase 6:\n\tcase 7:\n\t\tskb->priority = 5;  \n\t\treturn 0;\n\tcase 4:\n\tcase 5:\n\t\tskb->priority = 3;  \n\t\treturn 0;\n\tcase 0:\n\tcase 3:\n\t\tskb->priority = 2;  \n\t\treturn 0;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n \nstatic inline u8 ieee80211_fix_reserved_tid(u8 tid)\n{\n\tswitch (tid) {\n\tcase 0:\n\t\treturn 3;\n\tcase 1:\n\t\treturn 2;\n\tcase 2:\n\t\treturn 1;\n\tcase 3:\n\t\treturn 0;\n\tcase 4:\n\t\treturn 5;\n\tcase 5:\n\t\treturn 4;\n\tcase 6:\n\t\treturn 7;\n\tcase 7:\n\t\treturn 6;\n\t}\n\n\treturn 0;\n}\n\nstatic u16 ieee80211_downgrade_queue(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct sta_info *sta, struct sk_buff *skb)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\n\t \n\twhile (sdata->wmm_acm & BIT(skb->priority)) {\n\t\tint ac = ieee802_1d_to_ac[skb->priority];\n\n\t\tif (ifmgd->tx_tspec[ac].admitted_time &&\n\t\t    skb->priority == ifmgd->tx_tspec[ac].up)\n\t\t\treturn ac;\n\n\t\tif (wme_downgrade_ac(skb)) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (sta && sta->reserved_tid == skb->priority)\n\t\tskb->priority = ieee80211_fix_reserved_tid(skb->priority);\n\n\t \n\treturn ieee802_1d_to_ac[skb->priority];\n}\n\n \nu16 ieee80211_select_queue_80211(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t struct ieee80211_hdr *hdr)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tu8 *p;\n\n\t \n\tskb_get_hash(skb);\n\n\tif ((info->control.flags & IEEE80211_TX_CTRL_DONT_REORDER) ||\n\t    local->hw.queues < IEEE80211_NUM_ACS)\n\t\treturn 0;\n\n\tif (!ieee80211_is_data(hdr->frame_control)) {\n\t\tskb->priority = 7;\n\t\treturn ieee802_1d_to_ac[skb->priority];\n\t}\n\tif (!ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tskb->priority = 0;\n\t\treturn ieee802_1d_to_ac[skb->priority];\n\t}\n\n\tp = ieee80211_get_qos_ctl(hdr);\n\tskb->priority = *p & IEEE80211_QOS_CTL_TAG1D_MASK;\n\n\treturn ieee80211_downgrade_queue(sdata, NULL, skb);\n}\n\nu16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct sta_info *sta, struct sk_buff *skb)\n{\n\tconst struct ethhdr *eth = (void *)skb->data;\n\tstruct mac80211_qos_map *qos_map;\n\tbool qos;\n\n\t \n\tskb_get_hash(skb);\n\n\t \n\tif ((sdata->vif.type == NL80211_IFTYPE_MESH_POINT &&\n\t    !is_multicast_ether_addr(eth->h_dest)) ||\n\t    (sdata->vif.type == NL80211_IFTYPE_OCB && sta))\n\t\tqos = true;\n\telse if (sta)\n\t\tqos = sta->sta.wme;\n\telse\n\t\tqos = false;\n\n\tif (!qos) {\n\t\tskb->priority = 0;  \n\t\treturn IEEE80211_AC_BE;\n\t}\n\n\tif (skb->protocol == sdata->control_port_protocol) {\n\t\tskb->priority = 7;\n\t\tgoto downgrade;\n\t}\n\n\t \n\tqos_map = rcu_dereference(sdata->qos_map);\n\tskb->priority = cfg80211_classify8021d(skb, qos_map ?\n\t\t\t\t\t       &qos_map->qos_map : NULL);\n\n downgrade:\n\treturn ieee80211_downgrade_queue(sdata, sta, skb);\n}\n\n \nvoid ieee80211_set_qos_hdr(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tu8 tid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\tu8 flags;\n\tu8 *p;\n\n\tif (!ieee80211_is_data_qos(hdr->frame_control))\n\t\treturn;\n\n\tp = ieee80211_get_qos_ctl(hdr);\n\n\t \n\tif (info->flags & IEEE80211_TX_CTL_INJECTED) {\n\t\t \n\t\tif (*p & IEEE80211_QOS_CTL_ACK_POLICY_NOACK)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tflags = *p & ~(IEEE80211_QOS_CTL_TID_MASK |\n\t\t       IEEE80211_QOS_CTL_ACK_POLICY_MASK);\n\n\tif (is_multicast_ether_addr(hdr->addr1) ||\n\t    sdata->noack_map & BIT(tid)) {\n\t\tflags |= IEEE80211_QOS_CTL_ACK_POLICY_NOACK;\n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_ACK;\n\t}\n\n\t*p = flags | tid;\n\n\t \n\tp++;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif)) {\n\t\t \n\t\t*p &= ((IEEE80211_QOS_CTL_RSPI |\n\t\t\tIEEE80211_QOS_CTL_MESH_PS_LEVEL) >> 8);\n\n\t\t \n\t\tif (!ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\t\t*p |= (IEEE80211_QOS_CTL_MESH_CONTROL_PRESENT >> 8);\n\t} else {\n\t\t*p = 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}