{
  "module_name": "driver-ops.h",
  "hash_id": "bf08e4514ac7f3d0ef95991f483c243069cd1327cfb1c1794f6bf8601fdac3cd",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/driver-ops.h",
  "human_readable_source": " \n \n\n#ifndef __MAC80211_DRIVER_OPS\n#define __MAC80211_DRIVER_OPS\n\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"trace.h\"\n\n#define check_sdata_in_driver(sdata)\t({\t\t\t\t\t\\\n\tWARN_ONCE(!sdata->local->reconfig_failure &&\t\t\t\t\\\n\t\t  !(sdata->flags & IEEE80211_SDATA_IN_DRIVER),\t\t\t\\\n\t\t  \"%s: Failed check-sdata-in-driver check, flags: 0x%x\\n\",\t\\\n\t\t  sdata->dev ? sdata->dev->name : sdata->name, sdata->flags);\t\\\n\t!!(sdata->flags & IEEE80211_SDATA_IN_DRIVER);\t\t\t\t\\\n})\n\nstatic inline struct ieee80211_sub_if_data *\nget_bss_sdata(struct ieee80211_sub_if_data *sdata)\n{\n\tif (sdata && sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tsdata = container_of(sdata->bss, struct ieee80211_sub_if_data,\n\t\t\t\t     u.ap);\n\n\treturn sdata;\n}\n\nstatic inline void drv_tx(struct ieee80211_local *local,\n\t\t\t  struct ieee80211_tx_control *control,\n\t\t\t  struct sk_buff *skb)\n{\n\tlocal->ops->tx(&local->hw, control, skb);\n}\n\nstatic inline void drv_sync_rx_queues(struct ieee80211_local *local,\n\t\t\t\t      struct sta_info *sta)\n{\n\tif (local->ops->sync_rx_queues) {\n\t\ttrace_drv_sync_rx_queues(local, sta->sdata, &sta->sta);\n\t\tlocal->ops->sync_rx_queues(&local->hw);\n\t\ttrace_drv_return_void(local);\n\t}\n}\n\nstatic inline void drv_get_et_strings(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      u32 sset, u8 *data)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tif (local->ops->get_et_strings) {\n\t\ttrace_drv_get_et_strings(local, sset);\n\t\tlocal->ops->get_et_strings(&local->hw, &sdata->vif, sset, data);\n\t\ttrace_drv_return_void(local);\n\t}\n}\n\nstatic inline void drv_get_et_stats(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ethtool_stats *stats,\n\t\t\t\t    u64 *data)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tif (local->ops->get_et_stats) {\n\t\ttrace_drv_get_et_stats(local);\n\t\tlocal->ops->get_et_stats(&local->hw, &sdata->vif, stats, data);\n\t\ttrace_drv_return_void(local);\n\t}\n}\n\nstatic inline int drv_get_et_sset_count(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tint sset)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint rv = 0;\n\tif (local->ops->get_et_sset_count) {\n\t\ttrace_drv_get_et_sset_count(local, sset);\n\t\trv = local->ops->get_et_sset_count(&local->hw, &sdata->vif,\n\t\t\t\t\t\t   sset);\n\t\ttrace_drv_return_int(local, rv);\n\t}\n\treturn rv;\n}\n\nint drv_start(struct ieee80211_local *local);\nvoid drv_stop(struct ieee80211_local *local);\n\n#ifdef CONFIG_PM\nstatic inline int drv_suspend(struct ieee80211_local *local,\n\t\t\t      struct cfg80211_wowlan *wowlan)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\ttrace_drv_suspend(local);\n\tret = local->ops->suspend(&local->hw, wowlan);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline int drv_resume(struct ieee80211_local *local)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\ttrace_drv_resume(local);\n\tret = local->ops->resume(&local->hw);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline void drv_set_wakeup(struct ieee80211_local *local,\n\t\t\t\t  bool enabled)\n{\n\tmight_sleep();\n\n\tif (!local->ops->set_wakeup)\n\t\treturn;\n\n\ttrace_drv_set_wakeup(local, enabled);\n\tlocal->ops->set_wakeup(&local->hw, enabled);\n\ttrace_drv_return_void(local);\n}\n#endif\n\nint drv_add_interface(struct ieee80211_local *local,\n\t\t      struct ieee80211_sub_if_data *sdata);\n\nint drv_change_interface(struct ieee80211_local *local,\n\t\t\t struct ieee80211_sub_if_data *sdata,\n\t\t\t enum nl80211_iftype type, bool p2p);\n\nvoid drv_remove_interface(struct ieee80211_local *local,\n\t\t\t  struct ieee80211_sub_if_data *sdata);\n\nstatic inline int drv_config(struct ieee80211_local *local, u32 changed)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\ttrace_drv_config(local, changed);\n\tret = local->ops->config(&local->hw, changed);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline void drv_vif_cfg_changed(struct ieee80211_local *local,\n\t\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       u64 changed)\n{\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_vif_cfg_changed(local, sdata, changed);\n\tif (local->ops->vif_cfg_changed)\n\t\tlocal->ops->vif_cfg_changed(&local->hw, &sdata->vif, changed);\n\telse if (local->ops->bss_info_changed)\n\t\tlocal->ops->bss_info_changed(&local->hw, &sdata->vif,\n\t\t\t\t\t     &sdata->vif.bss_conf, changed);\n\ttrace_drv_return_void(local);\n}\n\nvoid drv_link_info_changed(struct ieee80211_local *local,\n\t\t\t   struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct ieee80211_bss_conf *info,\n\t\t\t   int link_id, u64 changed);\n\nstatic inline u64 drv_prepare_multicast(struct ieee80211_local *local,\n\t\t\t\t\tstruct netdev_hw_addr_list *mc_list)\n{\n\tu64 ret = 0;\n\n\ttrace_drv_prepare_multicast(local, mc_list->count);\n\n\tif (local->ops->prepare_multicast)\n\t\tret = local->ops->prepare_multicast(&local->hw, mc_list);\n\n\ttrace_drv_return_u64(local, ret);\n\n\treturn ret;\n}\n\nstatic inline void drv_configure_filter(struct ieee80211_local *local,\n\t\t\t\t\tunsigned int changed_flags,\n\t\t\t\t\tunsigned int *total_flags,\n\t\t\t\t\tu64 multicast)\n{\n\tmight_sleep();\n\n\ttrace_drv_configure_filter(local, changed_flags, total_flags,\n\t\t\t\t   multicast);\n\tlocal->ops->configure_filter(&local->hw, changed_flags, total_flags,\n\t\t\t\t     multicast);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_config_iface_filter(struct ieee80211_local *local,\n\t\t\t\t\t   struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   unsigned int filter_flags,\n\t\t\t\t\t   unsigned int changed_flags)\n{\n\tmight_sleep();\n\n\ttrace_drv_config_iface_filter(local, sdata, filter_flags,\n\t\t\t\t      changed_flags);\n\tif (local->ops->config_iface_filter)\n\t\tlocal->ops->config_iface_filter(&local->hw, &sdata->vif,\n\t\t\t\t\t\tfilter_flags,\n\t\t\t\t\t\tchanged_flags);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline int drv_set_tim(struct ieee80211_local *local,\n\t\t\t      struct ieee80211_sta *sta, bool set)\n{\n\tint ret = 0;\n\ttrace_drv_set_tim(local, sta, set);\n\tif (local->ops->set_tim)\n\t\tret = local->ops->set_tim(&local->hw, sta, set);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nint drv_set_key(struct ieee80211_local *local,\n\t\tenum set_key_cmd cmd,\n\t\tstruct ieee80211_sub_if_data *sdata,\n\t\tstruct ieee80211_sta *sta,\n\t\tstruct ieee80211_key_conf *key);\n\nstatic inline void drv_update_tkip_key(struct ieee80211_local *local,\n\t\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_key_conf *conf,\n\t\t\t\t       struct sta_info *sta, u32 iv32,\n\t\t\t\t       u16 *phase1key)\n{\n\tstruct ieee80211_sta *ista = NULL;\n\n\tif (sta)\n\t\tista = &sta->sta;\n\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_update_tkip_key(local, sdata, conf, ista, iv32);\n\tif (local->ops->update_tkip_key)\n\t\tlocal->ops->update_tkip_key(&local->hw, &sdata->vif, conf,\n\t\t\t\t\t    ista, iv32, phase1key);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline int drv_hw_scan(struct ieee80211_local *local,\n\t\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct ieee80211_scan_request *req)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_hw_scan(local, sdata);\n\tret = local->ops->hw_scan(&local->hw, &sdata->vif, req);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline void drv_cancel_hw_scan(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_sub_if_data *sdata)\n{\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_cancel_hw_scan(local, sdata);\n\tlocal->ops->cancel_hw_scan(&local->hw, &sdata->vif);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline int\ndrv_sched_scan_start(struct ieee80211_local *local,\n\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t     struct cfg80211_sched_scan_request *req,\n\t\t     struct ieee80211_scan_ies *ies)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_sched_scan_start(local, sdata);\n\tret = local->ops->sched_scan_start(&local->hw, &sdata->vif,\n\t\t\t\t\t      req, ies);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline int drv_sched_scan_stop(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_sub_if_data *sdata)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_sched_scan_stop(local, sdata);\n\tret = local->ops->sched_scan_stop(&local->hw, &sdata->vif);\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline void drv_sw_scan_start(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     const u8 *mac_addr)\n{\n\tmight_sleep();\n\n\ttrace_drv_sw_scan_start(local, sdata, mac_addr);\n\tif (local->ops->sw_scan_start)\n\t\tlocal->ops->sw_scan_start(&local->hw, &sdata->vif, mac_addr);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_sw_scan_complete(struct ieee80211_local *local,\n\t\t\t\t\tstruct ieee80211_sub_if_data *sdata)\n{\n\tmight_sleep();\n\n\ttrace_drv_sw_scan_complete(local, sdata);\n\tif (local->ops->sw_scan_complete)\n\t\tlocal->ops->sw_scan_complete(&local->hw, &sdata->vif);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline int drv_get_stats(struct ieee80211_local *local,\n\t\t\t\tstruct ieee80211_low_level_stats *stats)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tmight_sleep();\n\n\tif (local->ops->get_stats)\n\t\tret = local->ops->get_stats(&local->hw, stats);\n\ttrace_drv_get_stats(local, stats, ret);\n\n\treturn ret;\n}\n\nstatic inline void drv_get_key_seq(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_key *key,\n\t\t\t\t   struct ieee80211_key_seq *seq)\n{\n\tif (local->ops->get_key_seq)\n\t\tlocal->ops->get_key_seq(&local->hw, &key->conf, seq);\n\ttrace_drv_get_key_seq(local, &key->conf);\n}\n\nstatic inline int drv_set_frag_threshold(struct ieee80211_local *local,\n\t\t\t\t\tu32 value)\n{\n\tint ret = 0;\n\n\tmight_sleep();\n\n\ttrace_drv_set_frag_threshold(local, value);\n\tif (local->ops->set_frag_threshold)\n\t\tret = local->ops->set_frag_threshold(&local->hw, value);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline int drv_set_rts_threshold(struct ieee80211_local *local,\n\t\t\t\t\tu32 value)\n{\n\tint ret = 0;\n\n\tmight_sleep();\n\n\ttrace_drv_set_rts_threshold(local, value);\n\tif (local->ops->set_rts_threshold)\n\t\tret = local->ops->set_rts_threshold(&local->hw, value);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline int drv_set_coverage_class(struct ieee80211_local *local,\n\t\t\t\t\t s16 value)\n{\n\tint ret = 0;\n\tmight_sleep();\n\n\ttrace_drv_set_coverage_class(local, value);\n\tif (local->ops->set_coverage_class)\n\t\tlocal->ops->set_coverage_class(&local->hw, value);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline void drv_sta_notify(struct ieee80211_local *local,\n\t\t\t\t  struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  enum sta_notify_cmd cmd,\n\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_sta_notify(local, sdata, cmd, sta);\n\tif (local->ops->sta_notify)\n\t\tlocal->ops->sta_notify(&local->hw, &sdata->vif, cmd, sta);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline int drv_sta_add(struct ieee80211_local *local,\n\t\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tint ret = 0;\n\n\tmight_sleep();\n\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_sta_add(local, sdata, sta);\n\tif (local->ops->sta_add)\n\t\tret = local->ops->sta_add(&local->hw, &sdata->vif, sta);\n\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline void drv_sta_remove(struct ieee80211_local *local,\n\t\t\t\t  struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tmight_sleep();\n\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_sta_remove(local, sdata, sta);\n\tif (local->ops->sta_remove)\n\t\tlocal->ops->sta_remove(&local->hw, &sdata->vif, sta);\n\n\ttrace_drv_return_void(local);\n}\n\n#ifdef CONFIG_MAC80211_DEBUGFS\nstatic inline void drv_link_add_debugfs(struct ieee80211_local *local,\n\t\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct ieee80211_bss_conf *link_conf,\n\t\t\t\t\tstruct dentry *dir)\n{\n\tmight_sleep();\n\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\tif (local->ops->link_add_debugfs)\n\t\tlocal->ops->link_add_debugfs(&local->hw, &sdata->vif,\n\t\t\t\t\t     link_conf, dir);\n}\n\nstatic inline void drv_sta_add_debugfs(struct ieee80211_local *local,\n\t\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       struct dentry *dir)\n{\n\tmight_sleep();\n\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\tif (local->ops->sta_add_debugfs)\n\t\tlocal->ops->sta_add_debugfs(&local->hw, &sdata->vif,\n\t\t\t\t\t    sta, dir);\n}\n\nstatic inline void drv_link_sta_add_debugfs(struct ieee80211_local *local,\n\t\t\t\t\t    struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    struct ieee80211_link_sta *link_sta,\n\t\t\t\t\t    struct dentry *dir)\n{\n\tmight_sleep();\n\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\tif (local->ops->link_sta_add_debugfs)\n\t\tlocal->ops->link_sta_add_debugfs(&local->hw, &sdata->vif,\n\t\t\t\t\t\t link_sta, dir);\n}\n#endif\n\nstatic inline void drv_sta_pre_rcu_remove(struct ieee80211_local *local,\n\t\t\t\t\t  struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  struct sta_info *sta)\n{\n\tmight_sleep();\n\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_sta_pre_rcu_remove(local, sdata, &sta->sta);\n\tif (local->ops->sta_pre_rcu_remove)\n\t\tlocal->ops->sta_pre_rcu_remove(&local->hw, &sdata->vif,\n\t\t\t\t\t       &sta->sta);\n\ttrace_drv_return_void(local);\n}\n\n__must_check\nint drv_sta_state(struct ieee80211_local *local,\n\t\t  struct ieee80211_sub_if_data *sdata,\n\t\t  struct sta_info *sta,\n\t\t  enum ieee80211_sta_state old_state,\n\t\t  enum ieee80211_sta_state new_state);\n\n__must_check\nint drv_sta_set_txpwr(struct ieee80211_local *local,\n\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t      struct sta_info *sta);\n\nvoid drv_sta_rc_update(struct ieee80211_local *local,\n\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t       struct ieee80211_sta *sta, u32 changed);\n\nstatic inline void drv_sta_rate_tbl_update(struct ieee80211_local *local,\n\t\t\t\t\t   struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_sta_rate_tbl_update(local, sdata, sta);\n\tif (local->ops->sta_rate_tbl_update)\n\t\tlocal->ops->sta_rate_tbl_update(&local->hw, &sdata->vif, sta);\n\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_sta_statistics(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct station_info *sinfo)\n{\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_sta_statistics(local, sdata, sta);\n\tif (local->ops->sta_statistics)\n\t\tlocal->ops->sta_statistics(&local->hw, &sdata->vif, sta, sinfo);\n\ttrace_drv_return_void(local);\n}\n\nint drv_conf_tx(struct ieee80211_local *local,\n\t\tstruct ieee80211_link_data *link, u16 ac,\n\t\tconst struct ieee80211_tx_queue_params *params);\n\nu64 drv_get_tsf(struct ieee80211_local *local,\n\t\tstruct ieee80211_sub_if_data *sdata);\nvoid drv_set_tsf(struct ieee80211_local *local,\n\t\t struct ieee80211_sub_if_data *sdata,\n\t\t u64 tsf);\nvoid drv_offset_tsf(struct ieee80211_local *local,\n\t\t    struct ieee80211_sub_if_data *sdata,\n\t\t    s64 offset);\nvoid drv_reset_tsf(struct ieee80211_local *local,\n\t\t   struct ieee80211_sub_if_data *sdata);\n\nstatic inline int drv_tx_last_beacon(struct ieee80211_local *local)\n{\n\tint ret = 0;  \n\n\tmight_sleep();\n\n\ttrace_drv_tx_last_beacon(local);\n\tif (local->ops->tx_last_beacon)\n\t\tret = local->ops->tx_last_beacon(&local->hw);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nint drv_ampdu_action(struct ieee80211_local *local,\n\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t     struct ieee80211_ampdu_params *params);\n\nstatic inline int drv_get_survey(struct ieee80211_local *local, int idx,\n\t\t\t\tstruct survey_info *survey)\n{\n\tint ret = -EOPNOTSUPP;\n\n\ttrace_drv_get_survey(local, idx, survey);\n\n\tif (local->ops->get_survey)\n\t\tret = local->ops->get_survey(&local->hw, idx, survey);\n\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline void drv_rfkill_poll(struct ieee80211_local *local)\n{\n\tmight_sleep();\n\n\tif (local->ops->rfkill_poll)\n\t\tlocal->ops->rfkill_poll(&local->hw);\n}\n\nstatic inline void drv_flush(struct ieee80211_local *local,\n\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t     u32 queues, bool drop)\n{\n\tstruct ieee80211_vif *vif;\n\n\tmight_sleep();\n\n\tsdata = get_bss_sdata(sdata);\n\tvif = sdata ? &sdata->vif : NULL;\n\n\tif (sdata && !check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_flush(local, queues, drop);\n\tif (local->ops->flush)\n\t\tlocal->ops->flush(&local->hw, vif, queues, drop);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_flush_sta(struct ieee80211_local *local,\n\t\t\t\t struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct sta_info *sta)\n{\n\tmight_sleep();\n\n\tsdata = get_bss_sdata(sdata);\n\n\tif (sdata && !check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_flush_sta(local, sdata, &sta->sta);\n\tif (local->ops->flush_sta)\n\t\tlocal->ops->flush_sta(&local->hw, &sdata->vif, &sta->sta);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_channel_switch(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct ieee80211_channel_switch *ch_switch)\n{\n\tmight_sleep();\n\n\ttrace_drv_channel_switch(local, sdata, ch_switch);\n\tlocal->ops->channel_switch(&local->hw, &sdata->vif, ch_switch);\n\ttrace_drv_return_void(local);\n}\n\n\nstatic inline int drv_set_antenna(struct ieee80211_local *local,\n\t\t\t\t  u32 tx_ant, u32 rx_ant)\n{\n\tint ret = -EOPNOTSUPP;\n\tmight_sleep();\n\tif (local->ops->set_antenna)\n\t\tret = local->ops->set_antenna(&local->hw, tx_ant, rx_ant);\n\ttrace_drv_set_antenna(local, tx_ant, rx_ant, ret);\n\treturn ret;\n}\n\nstatic inline int drv_get_antenna(struct ieee80211_local *local,\n\t\t\t\t  u32 *tx_ant, u32 *rx_ant)\n{\n\tint ret = -EOPNOTSUPP;\n\tmight_sleep();\n\tif (local->ops->get_antenna)\n\t\tret = local->ops->get_antenna(&local->hw, tx_ant, rx_ant);\n\ttrace_drv_get_antenna(local, *tx_ant, *rx_ant, ret);\n\treturn ret;\n}\n\nstatic inline int drv_remain_on_channel(struct ieee80211_local *local,\n\t\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tunsigned int duration,\n\t\t\t\t\tenum ieee80211_roc_type type)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\ttrace_drv_remain_on_channel(local, sdata, chan, duration, type);\n\tret = local->ops->remain_on_channel(&local->hw, &sdata->vif,\n\t\t\t\t\t    chan, duration, type);\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline int\ndrv_cancel_remain_on_channel(struct ieee80211_local *local,\n\t\t\t     struct ieee80211_sub_if_data *sdata)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\ttrace_drv_cancel_remain_on_channel(local, sdata);\n\tret = local->ops->cancel_remain_on_channel(&local->hw, &sdata->vif);\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline int drv_set_ringparam(struct ieee80211_local *local,\n\t\t\t\t    u32 tx, u32 rx)\n{\n\tint ret = -ENOTSUPP;\n\n\tmight_sleep();\n\n\ttrace_drv_set_ringparam(local, tx, rx);\n\tif (local->ops->set_ringparam)\n\t\tret = local->ops->set_ringparam(&local->hw, tx, rx);\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline void drv_get_ringparam(struct ieee80211_local *local,\n\t\t\t\t     u32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max)\n{\n\tmight_sleep();\n\n\ttrace_drv_get_ringparam(local, tx, tx_max, rx, rx_max);\n\tif (local->ops->get_ringparam)\n\t\tlocal->ops->get_ringparam(&local->hw, tx, tx_max, rx, rx_max);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline bool drv_tx_frames_pending(struct ieee80211_local *local)\n{\n\tbool ret = false;\n\n\tmight_sleep();\n\n\ttrace_drv_tx_frames_pending(local);\n\tif (local->ops->tx_frames_pending)\n\t\tret = local->ops->tx_frames_pending(&local->hw);\n\ttrace_drv_return_bool(local, ret);\n\n\treturn ret;\n}\n\nstatic inline int drv_set_bitrate_mask(struct ieee80211_local *local,\n\t\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       const struct cfg80211_bitrate_mask *mask)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_set_bitrate_mask(local, sdata, mask);\n\tif (local->ops->set_bitrate_mask)\n\t\tret = local->ops->set_bitrate_mask(&local->hw,\n\t\t\t\t\t\t   &sdata->vif, mask);\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline void drv_set_rekey_data(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct cfg80211_gtk_rekey_data *data)\n{\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_set_rekey_data(local, sdata, data);\n\tif (local->ops->set_rekey_data)\n\t\tlocal->ops->set_rekey_data(&local->hw, &sdata->vif, data);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_event_callback(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      const struct ieee80211_event *event)\n{\n\ttrace_drv_event_callback(local, sdata, event);\n\tif (local->ops->event_callback)\n\t\tlocal->ops->event_callback(&local->hw, &sdata->vif, event);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void\ndrv_release_buffered_frames(struct ieee80211_local *local,\n\t\t\t    struct sta_info *sta, u16 tids, int num_frames,\n\t\t\t    enum ieee80211_frame_release_type reason,\n\t\t\t    bool more_data)\n{\n\ttrace_drv_release_buffered_frames(local, &sta->sta, tids, num_frames,\n\t\t\t\t\t  reason, more_data);\n\tif (local->ops->release_buffered_frames)\n\t\tlocal->ops->release_buffered_frames(&local->hw, &sta->sta, tids,\n\t\t\t\t\t\t    num_frames, reason,\n\t\t\t\t\t\t    more_data);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void\ndrv_allow_buffered_frames(struct ieee80211_local *local,\n\t\t\t  struct sta_info *sta, u16 tids, int num_frames,\n\t\t\t  enum ieee80211_frame_release_type reason,\n\t\t\t  bool more_data)\n{\n\ttrace_drv_allow_buffered_frames(local, &sta->sta, tids, num_frames,\n\t\t\t\t\treason, more_data);\n\tif (local->ops->allow_buffered_frames)\n\t\tlocal->ops->allow_buffered_frames(&local->hw, &sta->sta,\n\t\t\t\t\t\t  tids, num_frames, reason,\n\t\t\t\t\t\t  more_data);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_mgd_prepare_tx(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t\t\t      struct ieee80211_prep_tx_info *info)\n{\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\tWARN_ON_ONCE(sdata->vif.type != NL80211_IFTYPE_STATION);\n\n\ttrace_drv_mgd_prepare_tx(local, sdata, info->duration,\n\t\t\t\t info->subtype, info->success);\n\tif (local->ops->mgd_prepare_tx)\n\t\tlocal->ops->mgd_prepare_tx(&local->hw, &sdata->vif, info);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_mgd_complete_tx(struct ieee80211_local *local,\n\t\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_prep_tx_info *info)\n{\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\tWARN_ON_ONCE(sdata->vif.type != NL80211_IFTYPE_STATION);\n\n\ttrace_drv_mgd_complete_tx(local, sdata, info->duration,\n\t\t\t\t  info->subtype, info->success);\n\tif (local->ops->mgd_complete_tx)\n\t\tlocal->ops->mgd_complete_tx(&local->hw, &sdata->vif, info);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void\ndrv_mgd_protect_tdls_discover(struct ieee80211_local *local,\n\t\t\t      struct ieee80211_sub_if_data *sdata)\n{\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\tWARN_ON_ONCE(sdata->vif.type != NL80211_IFTYPE_STATION);\n\n\ttrace_drv_mgd_protect_tdls_discover(local, sdata);\n\tif (local->ops->mgd_protect_tdls_discover)\n\t\tlocal->ops->mgd_protect_tdls_discover(&local->hw, &sdata->vif);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline int drv_add_chanctx(struct ieee80211_local *local,\n\t\t\t\t  struct ieee80211_chanctx *ctx)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tmight_sleep();\n\n\ttrace_drv_add_chanctx(local, ctx);\n\tif (local->ops->add_chanctx)\n\t\tret = local->ops->add_chanctx(&local->hw, &ctx->conf);\n\ttrace_drv_return_int(local, ret);\n\tif (!ret)\n\t\tctx->driver_present = true;\n\n\treturn ret;\n}\n\nstatic inline void drv_remove_chanctx(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_chanctx *ctx)\n{\n\tmight_sleep();\n\n\tif (WARN_ON(!ctx->driver_present))\n\t\treturn;\n\n\ttrace_drv_remove_chanctx(local, ctx);\n\tif (local->ops->remove_chanctx)\n\t\tlocal->ops->remove_chanctx(&local->hw, &ctx->conf);\n\ttrace_drv_return_void(local);\n\tctx->driver_present = false;\n}\n\nstatic inline void drv_change_chanctx(struct ieee80211_local *local,\n\t\t\t\t      struct ieee80211_chanctx *ctx,\n\t\t\t\t      u32 changed)\n{\n\tmight_sleep();\n\n\ttrace_drv_change_chanctx(local, ctx, changed);\n\tif (local->ops->change_chanctx) {\n\t\tWARN_ON_ONCE(!ctx->driver_present);\n\t\tlocal->ops->change_chanctx(&local->hw, &ctx->conf, changed);\n\t}\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_verify_link_exists(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  struct ieee80211_bss_conf *link_conf)\n{\n\t \n\tif (sdata->deflink.conf != link_conf)\n\t\tsdata_assert_lock(sdata);\n}\n\nint drv_assign_vif_chanctx(struct ieee80211_local *local,\n\t\t\t   struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct ieee80211_bss_conf *link_conf,\n\t\t\t   struct ieee80211_chanctx *ctx);\nvoid drv_unassign_vif_chanctx(struct ieee80211_local *local,\n\t\t\t      struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct ieee80211_bss_conf *link_conf,\n\t\t\t      struct ieee80211_chanctx *ctx);\nint drv_switch_vif_chanctx(struct ieee80211_local *local,\n\t\t\t   struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t   int n_vifs, enum ieee80211_chanctx_switch_mode mode);\n\nstatic inline int drv_start_ap(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t       struct ieee80211_bss_conf *link_conf)\n{\n\tint ret = 0;\n\n\t \n\tdrv_verify_link_exists(sdata, link_conf);\n\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_start_ap(local, sdata, link_conf);\n\tif (local->ops->start_ap)\n\t\tret = local->ops->start_ap(&local->hw, &sdata->vif, link_conf);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline void drv_stop_ap(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t       struct ieee80211_bss_conf *link_conf)\n{\n\t \n\tdrv_verify_link_exists(sdata, link_conf);\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_stop_ap(local, sdata, link_conf);\n\tif (local->ops->stop_ap)\n\t\tlocal->ops->stop_ap(&local->hw, &sdata->vif, link_conf);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void\ndrv_reconfig_complete(struct ieee80211_local *local,\n\t\t      enum ieee80211_reconfig_type reconfig_type)\n{\n\tmight_sleep();\n\n\ttrace_drv_reconfig_complete(local, reconfig_type);\n\tif (local->ops->reconfig_complete)\n\t\tlocal->ops->reconfig_complete(&local->hw, reconfig_type);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void\ndrv_set_default_unicast_key(struct ieee80211_local *local,\n\t\t\t    struct ieee80211_sub_if_data *sdata,\n\t\t\t    int key_idx)\n{\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\tWARN_ON_ONCE(key_idx < -1 || key_idx > 3);\n\n\ttrace_drv_set_default_unicast_key(local, sdata, key_idx);\n\tif (local->ops->set_default_unicast_key)\n\t\tlocal->ops->set_default_unicast_key(&local->hw, &sdata->vif,\n\t\t\t\t\t\t    key_idx);\n\ttrace_drv_return_void(local);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline void drv_ipv6_addr_change(struct ieee80211_local *local,\n\t\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\t\tstruct inet6_dev *idev)\n{\n\ttrace_drv_ipv6_addr_change(local, sdata);\n\tif (local->ops->ipv6_addr_change)\n\t\tlocal->ops->ipv6_addr_change(&local->hw, &sdata->vif, idev);\n\ttrace_drv_return_void(local);\n}\n#endif\n\nstatic inline void\ndrv_channel_switch_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t  struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\tif (local->ops->channel_switch_beacon) {\n\t\ttrace_drv_channel_switch_beacon(local, sdata, chandef);\n\t\tlocal->ops->channel_switch_beacon(&local->hw, &sdata->vif,\n\t\t\t\t\t\t  chandef);\n\t}\n}\n\nstatic inline int\ndrv_pre_channel_switch(struct ieee80211_sub_if_data *sdata,\n\t\t       struct ieee80211_channel_switch *ch_switch)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret = 0;\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_pre_channel_switch(local, sdata, ch_switch);\n\tif (local->ops->pre_channel_switch)\n\t\tret = local->ops->pre_channel_switch(&local->hw, &sdata->vif,\n\t\t\t\t\t\t     ch_switch);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline int\ndrv_post_channel_switch(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret = 0;\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_post_channel_switch(local, sdata);\n\tif (local->ops->post_channel_switch)\n\t\tret = local->ops->post_channel_switch(&local->hw, &sdata->vif);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline void\ndrv_abort_channel_switch(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_abort_channel_switch(local, sdata);\n\n\tif (local->ops->abort_channel_switch)\n\t\tlocal->ops->abort_channel_switch(&local->hw, &sdata->vif);\n}\n\nstatic inline void\ndrv_channel_switch_rx_beacon(struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct ieee80211_channel_switch *ch_switch)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_channel_switch_rx_beacon(local, sdata, ch_switch);\n\tif (local->ops->channel_switch_rx_beacon)\n\t\tlocal->ops->channel_switch_rx_beacon(&local->hw, &sdata->vif,\n\t\t\t\t\t\t     ch_switch);\n}\n\nstatic inline int drv_join_ibss(struct ieee80211_local *local,\n\t\t\t\tstruct ieee80211_sub_if_data *sdata)\n{\n\tint ret = 0;\n\n\tmight_sleep();\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_join_ibss(local, sdata, &sdata->vif.bss_conf);\n\tif (local->ops->join_ibss)\n\t\tret = local->ops->join_ibss(&local->hw, &sdata->vif);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline void drv_leave_ibss(struct ieee80211_local *local,\n\t\t\t\t  struct ieee80211_sub_if_data *sdata)\n{\n\tmight_sleep();\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_leave_ibss(local, sdata);\n\tif (local->ops->leave_ibss)\n\t\tlocal->ops->leave_ibss(&local->hw, &sdata->vif);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline u32 drv_get_expected_throughput(struct ieee80211_local *local,\n\t\t\t\t\t      struct sta_info *sta)\n{\n\tu32 ret = 0;\n\n\ttrace_drv_get_expected_throughput(&sta->sta);\n\tif (local->ops->get_expected_throughput && sta->uploaded)\n\t\tret = local->ops->get_expected_throughput(&local->hw, &sta->sta);\n\ttrace_drv_return_u32(local, ret);\n\n\treturn ret;\n}\n\nstatic inline int drv_get_txpower(struct ieee80211_local *local,\n\t\t\t\t  struct ieee80211_sub_if_data *sdata, int *dbm)\n{\n\tint ret;\n\n\tif (!local->ops->get_txpower)\n\t\treturn -EOPNOTSUPP;\n\n\tret = local->ops->get_txpower(&local->hw, &sdata->vif, dbm);\n\ttrace_drv_get_txpower(local, sdata, *dbm, ret);\n\n\treturn ret;\n}\n\nstatic inline int\ndrv_tdls_channel_switch(struct ieee80211_local *local,\n\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\tstruct ieee80211_sta *sta, u8 oper_class,\n\t\t\tstruct cfg80211_chan_def *chandef,\n\t\t\tstruct sk_buff *tmpl_skb, u32 ch_sw_tm_ie)\n{\n\tint ret;\n\n\tmight_sleep();\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\tif (!local->ops->tdls_channel_switch)\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_drv_tdls_channel_switch(local, sdata, sta, oper_class, chandef);\n\tret = local->ops->tdls_channel_switch(&local->hw, &sdata->vif, sta,\n\t\t\t\t\t      oper_class, chandef, tmpl_skb,\n\t\t\t\t\t      ch_sw_tm_ie);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline void\ndrv_tdls_cancel_channel_switch(struct ieee80211_local *local,\n\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t       struct ieee80211_sta *sta)\n{\n\tmight_sleep();\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\tif (!local->ops->tdls_cancel_channel_switch)\n\t\treturn;\n\n\ttrace_drv_tdls_cancel_channel_switch(local, sdata, sta);\n\tlocal->ops->tdls_cancel_channel_switch(&local->hw, &sdata->vif, sta);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void\ndrv_tdls_recv_channel_switch(struct ieee80211_local *local,\n\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct ieee80211_tdls_ch_sw_params *params)\n{\n\ttrace_drv_tdls_recv_channel_switch(local, sdata, params);\n\tif (local->ops->tdls_recv_channel_switch)\n\t\tlocal->ops->tdls_recv_channel_switch(&local->hw, &sdata->vif,\n\t\t\t\t\t\t     params);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_wake_tx_queue(struct ieee80211_local *local,\n\t\t\t\t     struct txq_info *txq)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(txq->txq.vif);\n\n\t \n\tif (local->in_reconfig) {\n\t\tset_bit(IEEE80211_TXQ_DIRTY, &txq->flags);\n\t\treturn;\n\t}\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_wake_tx_queue(local, sdata, txq);\n\tlocal->ops->wake_tx_queue(&local->hw, &txq->txq);\n}\n\nstatic inline void schedule_and_wake_txq(struct ieee80211_local *local,\n\t\t\t\t\t struct txq_info *txqi)\n{\n\tieee80211_schedule_txq(&local->hw, &txqi->txq);\n\tdrv_wake_tx_queue(local, txqi);\n}\n\nstatic inline int drv_can_aggregate_in_amsdu(struct ieee80211_local *local,\n\t\t\t\t\t     struct sk_buff *head,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tif (!local->ops->can_aggregate_in_amsdu)\n\t\treturn true;\n\n\treturn local->ops->can_aggregate_in_amsdu(&local->hw, head, skb);\n}\n\nstatic inline int\ndrv_get_ftm_responder_stats(struct ieee80211_local *local,\n\t\t\t    struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct cfg80211_ftm_responder_stats *ftm_stats)\n{\n\tu32 ret = -EOPNOTSUPP;\n\n\tif (local->ops->get_ftm_responder_stats)\n\t\tret = local->ops->get_ftm_responder_stats(&local->hw,\n\t\t\t\t\t\t\t &sdata->vif,\n\t\t\t\t\t\t\t ftm_stats);\n\ttrace_drv_get_ftm_responder_stats(local, sdata, ftm_stats);\n\n\treturn ret;\n}\n\nstatic inline int drv_start_pmsr(struct ieee80211_local *local,\n\t\t\t\t struct ieee80211_sub_if_data *sdata,\n\t\t\t\t struct cfg80211_pmsr_request *request)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tmight_sleep();\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_start_pmsr(local, sdata);\n\n\tif (local->ops->start_pmsr)\n\t\tret = local->ops->start_pmsr(&local->hw, &sdata->vif, request);\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline void drv_abort_pmsr(struct ieee80211_local *local,\n\t\t\t\t  struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct cfg80211_pmsr_request *request)\n{\n\ttrace_drv_abort_pmsr(local, sdata);\n\n\tmight_sleep();\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\tif (local->ops->abort_pmsr)\n\t\tlocal->ops->abort_pmsr(&local->hw, &sdata->vif, request);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline int drv_start_nan(struct ieee80211_local *local,\n\t\t\t\tstruct ieee80211_sub_if_data *sdata,\n\t\t\t\tstruct cfg80211_nan_conf *conf)\n{\n\tint ret;\n\n\tmight_sleep();\n\tcheck_sdata_in_driver(sdata);\n\n\ttrace_drv_start_nan(local, sdata, conf);\n\tret = local->ops->start_nan(&local->hw, &sdata->vif, conf);\n\ttrace_drv_return_int(local, ret);\n\treturn ret;\n}\n\nstatic inline void drv_stop_nan(struct ieee80211_local *local,\n\t\t\t\tstruct ieee80211_sub_if_data *sdata)\n{\n\tmight_sleep();\n\tcheck_sdata_in_driver(sdata);\n\n\ttrace_drv_stop_nan(local, sdata);\n\tlocal->ops->stop_nan(&local->hw, &sdata->vif);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline int drv_nan_change_conf(struct ieee80211_local *local,\n\t\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct cfg80211_nan_conf *conf,\n\t\t\t\t       u32 changes)\n{\n\tint ret;\n\n\tmight_sleep();\n\tcheck_sdata_in_driver(sdata);\n\n\tif (!local->ops->nan_change_conf)\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_drv_nan_change_conf(local, sdata, conf, changes);\n\tret = local->ops->nan_change_conf(&local->hw, &sdata->vif, conf,\n\t\t\t\t\t  changes);\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline int drv_add_nan_func(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   const struct cfg80211_nan_func *nan_func)\n{\n\tint ret;\n\n\tmight_sleep();\n\tcheck_sdata_in_driver(sdata);\n\n\tif (!local->ops->add_nan_func)\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_drv_add_nan_func(local, sdata, nan_func);\n\tret = local->ops->add_nan_func(&local->hw, &sdata->vif, nan_func);\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline void drv_del_nan_func(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   u8 instance_id)\n{\n\tmight_sleep();\n\tcheck_sdata_in_driver(sdata);\n\n\ttrace_drv_del_nan_func(local, sdata, instance_id);\n\tif (local->ops->del_nan_func)\n\t\tlocal->ops->del_nan_func(&local->hw, &sdata->vif, instance_id);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline int drv_set_tid_config(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     struct cfg80211_tid_config *tid_conf)\n{\n\tint ret;\n\n\tmight_sleep();\n\tret = local->ops->set_tid_config(&local->hw, &sdata->vif, sta,\n\t\t\t\t\t tid_conf);\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline int drv_reset_tid_config(struct ieee80211_local *local,\n\t\t\t\t       struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_sta *sta, u8 tids)\n{\n\tint ret;\n\n\tmight_sleep();\n\tret = local->ops->reset_tid_config(&local->hw, &sdata->vif, sta, tids);\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline void drv_update_vif_offload(struct ieee80211_local *local,\n\t\t\t\t\t  struct ieee80211_sub_if_data *sdata)\n{\n\tmight_sleep();\n\tcheck_sdata_in_driver(sdata);\n\n\tif (!local->ops->update_vif_offload)\n\t\treturn;\n\n\ttrace_drv_update_vif_offload(local, sdata);\n\tlocal->ops->update_vif_offload(&local->hw, &sdata->vif);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_sta_set_4addr(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct ieee80211_sta *sta, bool enabled)\n{\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_sta_set_4addr(local, sdata, sta, enabled);\n\tif (local->ops->sta_set_4addr)\n\t\tlocal->ops->sta_set_4addr(&local->hw, &sdata->vif, sta, enabled);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_sta_set_decap_offload(struct ieee80211_local *local,\n\t\t\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t\t     bool enabled)\n{\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttrace_drv_sta_set_decap_offload(local, sdata, sta, enabled);\n\tif (local->ops->sta_set_decap_offload)\n\t\tlocal->ops->sta_set_decap_offload(&local->hw, &sdata->vif, sta,\n\t\t\t\t\t\t  enabled);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_add_twt_setup(struct ieee80211_local *local,\n\t\t\t\t     struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     struct ieee80211_twt_setup *twt)\n{\n\tstruct ieee80211_twt_params *twt_agrt;\n\n\tmight_sleep();\n\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\ttwt_agrt = (void *)twt->params;\n\n\ttrace_drv_add_twt_setup(local, sta, twt, twt_agrt);\n\tlocal->ops->add_twt_setup(&local->hw, sta, twt);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline void drv_twt_teardown_request(struct ieee80211_local *local,\n\t\t\t\t\t    struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t\t    u8 flowid)\n{\n\tmight_sleep();\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn;\n\n\tif (!local->ops->twt_teardown_request)\n\t\treturn;\n\n\ttrace_drv_twt_teardown_request(local, sta, flowid);\n\tlocal->ops->twt_teardown_request(&local->hw, sta, flowid);\n\ttrace_drv_return_void(local);\n}\n\nstatic inline int drv_net_fill_forward_path(struct ieee80211_local *local,\n\t\t\t\t\t    struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t\t    struct net_device_path_ctx *ctx,\n\t\t\t\t\t    struct net_device_path *path)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tsdata = get_bss_sdata(sdata);\n\tif (!check_sdata_in_driver(sdata))\n\t\treturn -EIO;\n\n\ttrace_drv_net_fill_forward_path(local, sdata, sta);\n\tif (local->ops->net_fill_forward_path)\n\t\tret = local->ops->net_fill_forward_path(&local->hw,\n\t\t\t\t\t\t\t&sdata->vif, sta,\n\t\t\t\t\t\t\tctx, path);\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nstatic inline int drv_net_setup_tc(struct ieee80211_local *local,\n\t\t\t\t   struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   enum tc_setup_type type, void *type_data)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tsdata = get_bss_sdata(sdata);\n\ttrace_drv_net_setup_tc(local, sdata, type);\n\tif (local->ops->net_setup_tc)\n\t\tret = local->ops->net_setup_tc(&local->hw, &sdata->vif, dev,\n\t\t\t\t\t       type, type_data);\n\ttrace_drv_return_int(local, ret);\n\n\treturn ret;\n}\n\nint drv_change_vif_links(struct ieee80211_local *local,\n\t\t\t struct ieee80211_sub_if_data *sdata,\n\t\t\t u16 old_links, u16 new_links,\n\t\t\t struct ieee80211_bss_conf *old[IEEE80211_MLD_MAX_NUM_LINKS]);\nint drv_change_sta_links(struct ieee80211_local *local,\n\t\t\t struct ieee80211_sub_if_data *sdata,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t u16 old_links, u16 new_links);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}