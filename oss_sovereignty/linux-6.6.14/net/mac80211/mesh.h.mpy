{
  "module_name": "mesh.h",
  "hash_id": "ee656e822aabfbc38f86b3c4a492ac33ebc1cb54ec96df5953a3966066d9b288",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/mesh.h",
  "human_readable_source": " \n \n\n#ifndef IEEE80211S_H\n#define IEEE80211S_H\n\n#include <linux/types.h>\n#include <linux/jhash.h>\n#include \"ieee80211_i.h\"\n\n\n \n\n \nenum mesh_path_flags {\n\tMESH_PATH_ACTIVE =\tBIT(0),\n\tMESH_PATH_RESOLVING =\tBIT(1),\n\tMESH_PATH_SN_VALID =\tBIT(2),\n\tMESH_PATH_FIXED\t=\tBIT(3),\n\tMESH_PATH_RESOLVED =\tBIT(4),\n\tMESH_PATH_REQ_QUEUED =\tBIT(5),\n\tMESH_PATH_DELETED =\tBIT(6),\n};\n\n \nenum mesh_deferred_task_flags {\n\tMESH_WORK_HOUSEKEEPING,\n\tMESH_WORK_ROOT,\n\tMESH_WORK_DRIFT_ADJUST,\n\tMESH_WORK_MBSS_CHANGED,\n};\n\n \nstruct mesh_path {\n\tu8 dst[ETH_ALEN];\n\tu8 mpp[ETH_ALEN];\t \n\tstruct rhash_head rhash;\n\tstruct hlist_node walk_list;\n\tstruct hlist_node gate_list;\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sta_info __rcu *next_hop;\n\tstruct timer_list timer;\n\tstruct sk_buff_head frame_queue;\n\tstruct rcu_head rcu;\n\tu32 sn;\n\tu32 metric;\n\tu8 hop_count;\n\tunsigned long exp_time;\n\tu32 discovery_timeout;\n\tu8 discovery_retries;\n\tenum mesh_path_flags flags;\n\tspinlock_t state_lock;\n\tu8 rann_snd_addr[ETH_ALEN];\n\tu32 rann_metric;\n\tunsigned long last_preq_to_root;\n\tunsigned long fast_tx_check;\n\tbool is_root;\n\tbool is_gate;\n\tu32 path_change_count;\n};\n\n#define MESH_FAST_TX_CACHE_MAX_SIZE\t\t512\n#define MESH_FAST_TX_CACHE_THRESHOLD_SIZE\t384\n#define MESH_FAST_TX_CACHE_TIMEOUT\t\t8000  \n\n \nstruct ieee80211_mesh_fast_tx {\n\tstruct rhash_head rhash;\n\tu8 addr_key[ETH_ALEN] __aligned(2);\n\n\tstruct ieee80211_fast_tx fast_tx;\n\tu8 hdr[sizeof(struct ieee80211s_hdr) + sizeof(rfc1042_header)];\n\tu16 hdrlen;\n\n\tstruct mesh_path *mpath, *mppath;\n\tstruct hlist_node walk_list;\n\tunsigned long timestamp;\n};\n\n \n \n#define RMC_BUCKETS\t\t256\n#define RMC_QUEUE_MAX_LEN\t4\n#define RMC_TIMEOUT\t\t(3 * HZ)\n\n \nstruct rmc_entry {\n\tstruct hlist_node list;\n\tunsigned long exp_time;\n\tu32 seqnum;\n\tu8 sa[ETH_ALEN];\n};\n\nstruct mesh_rmc {\n\tstruct hlist_head bucket[RMC_BUCKETS];\n\tu32 idx_mask;\n};\n\n#define IEEE80211_MESH_HOUSEKEEPING_INTERVAL (60 * HZ)\n\n#define MESH_PATH_EXPIRE (600 * HZ)\n\n \n#define MESH_MAX_PLINKS\t\t256\n\n \n#define MESH_MAX_MPATHS\t\t1024\n\n \n#define MESH_FRAME_QUEUE_LEN\t10\n\n \n \nint ieee80211_fill_mesh_addresses(struct ieee80211_hdr *hdr, __le16 *fc,\n\t\t\t\t  const u8 *da, const u8 *sa);\nunsigned int ieee80211_new_mesh_header(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211s_hdr *meshhdr,\n\t\t\t\t       const char *addr4or5, const char *addr6);\nint mesh_rmc_check(struct ieee80211_sub_if_data *sdata,\n\t\t   const u8 *addr, struct ieee80211s_hdr *mesh_hdr);\nbool mesh_matches_local(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct ieee802_11_elems *ie);\nint mesh_add_meshconf_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sk_buff *skb);\nint mesh_add_meshid_ie(struct ieee80211_sub_if_data *sdata,\n\t\t       struct sk_buff *skb);\nint mesh_add_rsn_ie(struct ieee80211_sub_if_data *sdata,\n\t\t    struct sk_buff *skb);\nint mesh_add_vendor_ies(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb);\nint mesh_add_ht_cap_ie(struct ieee80211_sub_if_data *sdata,\n\t\t       struct sk_buff *skb);\nint mesh_add_ht_oper_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb);\nint mesh_add_vht_cap_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb);\nint mesh_add_vht_oper_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sk_buff *skb);\nint mesh_add_he_cap_ie(struct ieee80211_sub_if_data *sdata,\n\t\t       struct sk_buff *skb, u8 ie_len);\nint mesh_add_he_oper_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb);\nint mesh_add_he_6ghz_cap_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct sk_buff *skb);\nint mesh_add_eht_cap_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb, u8 ie_len);\nint mesh_add_eht_oper_ie(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sk_buff *skb);\nvoid mesh_rmc_free(struct ieee80211_sub_if_data *sdata);\nint mesh_rmc_init(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211s_init(void);\nvoid ieee80211s_update_metric(struct ieee80211_local *local,\n\t\t\t      struct sta_info *sta,\n\t\t\t      struct ieee80211_tx_status *st);\nvoid ieee80211_mesh_init_sdata(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_mesh_teardown_sdata(struct ieee80211_sub_if_data *sdata);\nint ieee80211_start_mesh(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_stop_mesh(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211_mesh_root_setup(struct ieee80211_if_mesh *ifmsh);\nconst struct ieee80211_mesh_sync_ops *ieee80211_mesh_sync_ops_get(u8 method);\n \nvoid ieee80211_mbss_info_change_notify(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       u64 changed);\n\n \nu64 ieee80211_mps_local_status_update(struct ieee80211_sub_if_data *sdata);\nu64 ieee80211_mps_set_sta_local_pm(struct sta_info *sta,\n\t\t\t\t   enum nl80211_mesh_power_mode pm);\nvoid ieee80211_mps_set_frame_flags(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct sta_info *sta,\n\t\t\t\t   struct ieee80211_hdr *hdr);\nvoid ieee80211_mps_sta_status_update(struct sta_info *sta);\nvoid ieee80211_mps_rx_h_sta_process(struct sta_info *sta,\n\t\t\t\t    struct ieee80211_hdr *hdr);\nvoid ieee80211_mpsp_trigger_process(u8 *qc, struct sta_info *sta,\n\t\t\t\t    bool tx, bool acked);\nvoid ieee80211_mps_frame_release(struct sta_info *sta,\n\t\t\t\t struct ieee802_11_elems *elems);\n\n \nint mesh_nexthop_lookup(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb);\nint mesh_nexthop_resolve(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct sk_buff *skb);\nvoid mesh_path_start_discovery(struct ieee80211_sub_if_data *sdata);\nstruct mesh_path *mesh_path_lookup(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   const u8 *dst);\nstruct mesh_path *mpp_path_lookup(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  const u8 *dst);\nint mpp_path_add(struct ieee80211_sub_if_data *sdata,\n\t\t const u8 *dst, const u8 *mpp);\nstruct mesh_path *\nmesh_path_lookup_by_idx(struct ieee80211_sub_if_data *sdata, int idx);\nstruct mesh_path *\nmpp_path_lookup_by_idx(struct ieee80211_sub_if_data *sdata, int idx);\nvoid mesh_path_fix_nexthop(struct mesh_path *mpath, struct sta_info *next_hop);\nvoid mesh_path_expire(struct ieee80211_sub_if_data *sdata);\nvoid mesh_rx_path_sel_frame(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct ieee80211_mgmt *mgmt, size_t len);\nstruct mesh_path *\nmesh_path_add(struct ieee80211_sub_if_data *sdata, const u8 *dst);\n\nint mesh_path_add_gate(struct mesh_path *mpath);\nint mesh_path_send_to_gates(struct mesh_path *mpath);\nint mesh_gate_num(struct ieee80211_sub_if_data *sdata);\nu32 airtime_link_metric_get(struct ieee80211_local *local,\n\t\t\t    struct sta_info *sta);\n\n \nvoid mesh_neighbour_update(struct ieee80211_sub_if_data *sdata,\n\t\t\t   u8 *hw_addr, struct ieee802_11_elems *ie,\n\t\t\t   struct ieee80211_rx_status *rx_status);\nbool mesh_peer_accepts_plinks(struct ieee802_11_elems *ie);\nu64 mesh_accept_plinks_update(struct ieee80211_sub_if_data *sdata);\nvoid mesh_plink_timer(struct timer_list *t);\nvoid mesh_plink_broken(struct sta_info *sta);\nu64 mesh_plink_deactivate(struct sta_info *sta);\nu64 mesh_plink_open(struct sta_info *sta);\nu64 mesh_plink_block(struct sta_info *sta);\nvoid mesh_rx_plink_frame(struct ieee80211_sub_if_data *sdata,\n\t\t\t struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t struct ieee80211_rx_status *rx_status);\nvoid mesh_sta_cleanup(struct sta_info *sta);\n\n \n \nint mesh_path_error_tx(struct ieee80211_sub_if_data *sdata,\n\t\t       u8 ttl, const u8 *target, u32 target_sn,\n\t\t       u16 target_rcode, const u8 *ra);\nvoid mesh_path_assign_nexthop(struct mesh_path *mpath, struct sta_info *sta);\nvoid mesh_path_flush_pending(struct mesh_path *mpath);\nvoid mesh_path_tx_pending(struct mesh_path *mpath);\nvoid mesh_pathtbl_init(struct ieee80211_sub_if_data *sdata);\nvoid mesh_pathtbl_unregister(struct ieee80211_sub_if_data *sdata);\nint mesh_path_del(struct ieee80211_sub_if_data *sdata, const u8 *addr);\nvoid mesh_path_timer(struct timer_list *t);\nvoid mesh_path_flush_by_nexthop(struct sta_info *sta);\nvoid mesh_path_discard_frame(struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct sk_buff *skb);\nvoid mesh_path_tx_root_frame(struct ieee80211_sub_if_data *sdata);\n\nbool mesh_action_is_path_sel(struct ieee80211_mgmt *mgmt);\nstruct ieee80211_mesh_fast_tx *\nmesh_fast_tx_get(struct ieee80211_sub_if_data *sdata, const u8 *addr);\nbool ieee80211_mesh_xmit_fast(struct ieee80211_sub_if_data *sdata,\n\t\t\t      struct sk_buff *skb, u32 ctrl_flags);\nvoid mesh_fast_tx_cache(struct ieee80211_sub_if_data *sdata,\n\t\t\tstruct sk_buff *skb, struct mesh_path *mpath);\nvoid mesh_fast_tx_gc(struct ieee80211_sub_if_data *sdata);\nvoid mesh_fast_tx_flush_addr(struct ieee80211_sub_if_data *sdata,\n\t\t\t     const u8 *addr);\nvoid mesh_fast_tx_flush_mpath(struct mesh_path *mpath);\nvoid mesh_fast_tx_flush_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t    struct sta_info *sta);\nvoid mesh_path_refresh(struct ieee80211_sub_if_data *sdata,\n\t\t       struct mesh_path *mpath, const u8 *addr);\n\n#ifdef CONFIG_MAC80211_MESH\nstatic inline\nu64 mesh_plink_inc_estab_count(struct ieee80211_sub_if_data *sdata)\n{\n\tatomic_inc(&sdata->u.mesh.estab_plinks);\n\treturn mesh_accept_plinks_update(sdata) | BSS_CHANGED_BEACON;\n}\n\nstatic inline\nu64 mesh_plink_dec_estab_count(struct ieee80211_sub_if_data *sdata)\n{\n\tatomic_dec(&sdata->u.mesh.estab_plinks);\n\treturn mesh_accept_plinks_update(sdata) | BSS_CHANGED_BEACON;\n}\n\nstatic inline int mesh_plink_free_count(struct ieee80211_sub_if_data *sdata)\n{\n\treturn sdata->u.mesh.mshcfg.dot11MeshMaxPeerLinks -\n\t       atomic_read(&sdata->u.mesh.estab_plinks);\n}\n\nstatic inline bool mesh_plink_availables(struct ieee80211_sub_if_data *sdata)\n{\n\treturn (min_t(long, mesh_plink_free_count(sdata),\n\t\t   MESH_MAX_PLINKS - sdata->local->num_sta)) > 0;\n}\n\nstatic inline void mesh_path_activate(struct mesh_path *mpath)\n{\n\tmpath->flags |= MESH_PATH_ACTIVE | MESH_PATH_RESOLVED;\n}\n\nstatic inline bool mesh_path_sel_is_hwmp(struct ieee80211_sub_if_data *sdata)\n{\n\treturn sdata->u.mesh.mesh_pp_id == IEEE80211_PATH_PROTOCOL_HWMP;\n}\n\nvoid mesh_path_flush_by_iface(struct ieee80211_sub_if_data *sdata);\nvoid mesh_sync_adjust_tsf(struct ieee80211_sub_if_data *sdata);\nvoid ieee80211s_stop(void);\n#else\nstatic inline bool mesh_path_sel_is_hwmp(struct ieee80211_sub_if_data *sdata)\n{ return false; }\nstatic inline void mesh_path_flush_by_iface(struct ieee80211_sub_if_data *sdata)\n{}\nstatic inline void ieee80211s_stop(void) {}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}