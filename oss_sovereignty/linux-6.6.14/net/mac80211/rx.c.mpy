{
  "module_name": "rx.c",
  "hash_id": "b06e9dabd1651d08712d9b255563e61b1880b33fc5514f445d590e5fe076d535",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/rx.c",
  "human_readable_source": "\n \n\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <linux/kcov.h>\n#include <linux/bitops.h>\n#include <net/mac80211.h>\n#include <net/ieee80211_radiotap.h>\n#include <asm/unaligned.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"led.h\"\n#include \"mesh.h\"\n#include \"wep.h\"\n#include \"wpa.h\"\n#include \"tkip.h\"\n#include \"wme.h\"\n#include \"rate.h\"\n\n \nstatic struct sk_buff *ieee80211_clean_skb(struct sk_buff *skb,\n\t\t\t\t\t   unsigned int present_fcs_len,\n\t\t\t\t\t   unsigned int rtap_space)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tunsigned int hdrlen;\n\t__le16 fc;\n\n\tif (present_fcs_len)\n\t\t__pskb_trim(skb, skb->len - present_fcs_len);\n\tpskb_pull(skb, rtap_space);\n\n\t \n\tstatus->flag &= ~(RX_FLAG_RADIOTAP_TLV_AT_END |\n\t\t\t  RX_FLAG_RADIOTAP_LSIG |\n\t\t\t  RX_FLAG_RADIOTAP_HE_MU |\n\t\t\t  RX_FLAG_RADIOTAP_HE);\n\n\thdr = (void *)skb->data;\n\tfc = hdr->frame_control;\n\n\t \n\tif (likely(!ieee80211_is_mgmt(fc) || !ieee80211_has_order(fc)))\n\t\treturn skb;\n\n\thdrlen = ieee80211_hdrlen(fc);\n\thdr->frame_control &= ~cpu_to_le16(IEEE80211_FCTL_ORDER);\n\n\tif (!pskb_may_pull(skb, hdrlen)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tmemmove(skb->data + IEEE80211_HT_CTL_LEN, skb->data,\n\t\thdrlen - IEEE80211_HT_CTL_LEN);\n\tpskb_pull(skb, IEEE80211_HT_CTL_LEN);\n\n\treturn skb;\n}\n\nstatic inline bool should_drop_frame(struct sk_buff *skb, int present_fcs_len,\n\t\t\t\t     unsigned int rtap_space)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr;\n\n\thdr = (void *)(skb->data + rtap_space);\n\n\tif (status->flag & (RX_FLAG_FAILED_FCS_CRC |\n\t\t\t    RX_FLAG_FAILED_PLCP_CRC |\n\t\t\t    RX_FLAG_ONLY_MONITOR |\n\t\t\t    RX_FLAG_NO_PSDU))\n\t\treturn true;\n\n\tif (unlikely(skb->len < 16 + present_fcs_len + rtap_space))\n\t\treturn true;\n\n\tif (ieee80211_is_ctl(hdr->frame_control) &&\n\t    !ieee80211_is_pspoll(hdr->frame_control) &&\n\t    !ieee80211_is_back_req(hdr->frame_control))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int\nieee80211_rx_radiotap_hdrlen(struct ieee80211_local *local,\n\t\t\t     struct ieee80211_rx_status *status,\n\t\t\t     struct sk_buff *skb)\n{\n\tint len;\n\n\t \n\tlen = sizeof(struct ieee80211_radiotap_header) + 8;\n\n\t \n\tif (status->chains)\n\t\tlen += 4 * hweight8(status->chains);\n\n\tif (ieee80211_have_rx_timestamp(status)) {\n\t\tlen = ALIGN(len, 8);\n\t\tlen += 8;\n\t}\n\tif (ieee80211_hw_check(&local->hw, SIGNAL_DBM))\n\t\tlen += 1;\n\n\t \n\tif (!status->chains)\n\t\tlen += 1;\n\n\t \n\tlen = ALIGN(len, 2);\n\n\tif (status->encoding == RX_ENC_HT)  \n\t\tlen += 3;\n\n\tif (status->flag & RX_FLAG_AMPDU_DETAILS) {\n\t\tlen = ALIGN(len, 4);\n\t\tlen += 8;\n\t}\n\n\tif (status->encoding == RX_ENC_VHT) {\n\t\tlen = ALIGN(len, 2);\n\t\tlen += 12;\n\t}\n\n\tif (local->hw.radiotap_timestamp.units_pos >= 0) {\n\t\tlen = ALIGN(len, 8);\n\t\tlen += 12;\n\t}\n\n\tif (status->encoding == RX_ENC_HE &&\n\t    status->flag & RX_FLAG_RADIOTAP_HE) {\n\t\tlen = ALIGN(len, 2);\n\t\tlen += 12;\n\t\tBUILD_BUG_ON(sizeof(struct ieee80211_radiotap_he) != 12);\n\t}\n\n\tif (status->encoding == RX_ENC_HE &&\n\t    status->flag & RX_FLAG_RADIOTAP_HE_MU) {\n\t\tlen = ALIGN(len, 2);\n\t\tlen += 12;\n\t\tBUILD_BUG_ON(sizeof(struct ieee80211_radiotap_he_mu) != 12);\n\t}\n\n\tif (status->flag & RX_FLAG_NO_PSDU)\n\t\tlen += 1;\n\n\tif (status->flag & RX_FLAG_RADIOTAP_LSIG) {\n\t\tlen = ALIGN(len, 2);\n\t\tlen += 4;\n\t\tBUILD_BUG_ON(sizeof(struct ieee80211_radiotap_lsig) != 4);\n\t}\n\n\tif (status->chains) {\n\t\t \n\t\tlen += 2 * hweight8(status->chains);\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_TLV_AT_END) {\n\t\tint tlv_offset = 0;\n\n\t\t \n\t\tif (status->flag & RX_FLAG_RADIOTAP_HE)\n\t\t\ttlv_offset +=\n\t\t\t\tsizeof(struct ieee80211_radiotap_he);\n\t\tif (status->flag & RX_FLAG_RADIOTAP_HE_MU)\n\t\t\ttlv_offset +=\n\t\t\t\tsizeof(struct ieee80211_radiotap_he_mu);\n\t\tif (status->flag & RX_FLAG_RADIOTAP_LSIG)\n\t\t\ttlv_offset +=\n\t\t\t\tsizeof(struct ieee80211_radiotap_lsig);\n\n\t\t \n\t\tlen = ALIGN(len, 4);\n\n\t\t \n\t\tlen += skb_mac_header(skb) - &skb->data[tlv_offset];\n\t}\n\n\treturn len;\n}\n\nstatic void __ieee80211_queue_skb_to_iface(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   int link_id,\n\t\t\t\t\t   struct sta_info *sta,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\n\tif (link_id >= 0) {\n\t\tstatus->link_valid = 1;\n\t\tstatus->link_id = link_id;\n\t} else {\n\t\tstatus->link_valid = 0;\n\t}\n\n\tskb_queue_tail(&sdata->skb_queue, skb);\n\twiphy_work_queue(sdata->local->hw.wiphy, &sdata->work);\n\tif (sta)\n\t\tsta->deflink.rx_stats.packets++;\n}\n\nstatic void ieee80211_queue_skb_to_iface(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t int link_id,\n\t\t\t\t\t struct sta_info *sta,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tskb->protocol = 0;\n\t__ieee80211_queue_skb_to_iface(sdata, link_id, sta, skb);\n}\n\nstatic void ieee80211_handle_mu_mimo_mon(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t int rtap_space)\n{\n\tstruct {\n\t\tstruct ieee80211_hdr_3addr hdr;\n\t\tu8 category;\n\t\tu8 action_code;\n\t} __packed __aligned(2) action;\n\n\tif (!sdata)\n\t\treturn;\n\n\tBUILD_BUG_ON(sizeof(action) != IEEE80211_MIN_ACTION_SIZE + 1);\n\n\tif (skb->len < rtap_space + sizeof(action) +\n\t\t       VHT_MUMIMO_GROUPS_DATA_LEN)\n\t\treturn;\n\n\tif (!is_valid_ether_addr(sdata->u.mntr.mu_follow_addr))\n\t\treturn;\n\n\tskb_copy_bits(skb, rtap_space, &action, sizeof(action));\n\n\tif (!ieee80211_is_action(action.hdr.frame_control))\n\t\treturn;\n\n\tif (action.category != WLAN_CATEGORY_VHT)\n\t\treturn;\n\n\tif (action.action_code != WLAN_VHT_ACTION_GROUPID_MGMT)\n\t\treturn;\n\n\tif (!ether_addr_equal(action.hdr.addr1, sdata->u.mntr.mu_follow_addr))\n\t\treturn;\n\n\tskb = skb_copy(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tieee80211_queue_skb_to_iface(sdata, -1, NULL, skb);\n}\n\n \nstatic void\nieee80211_add_rx_radiotap_header(struct ieee80211_local *local,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t struct ieee80211_rate *rate,\n\t\t\t\t int rtap_len, bool has_fcs)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_radiotap_header *rthdr;\n\tunsigned char *pos;\n\t__le32 *it_present;\n\tu32 it_present_val;\n\tu16 rx_flags = 0;\n\tu16 channel_flags = 0;\n\tu32 tlvs_len = 0;\n\tint mpdulen, chain;\n\tunsigned long chains = status->chains;\n\tstruct ieee80211_radiotap_he he = {};\n\tstruct ieee80211_radiotap_he_mu he_mu = {};\n\tstruct ieee80211_radiotap_lsig lsig = {};\n\n\tif (status->flag & RX_FLAG_RADIOTAP_HE) {\n\t\the = *(struct ieee80211_radiotap_he *)skb->data;\n\t\tskb_pull(skb, sizeof(he));\n\t\tWARN_ON_ONCE(status->encoding != RX_ENC_HE);\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_HE_MU) {\n\t\the_mu = *(struct ieee80211_radiotap_he_mu *)skb->data;\n\t\tskb_pull(skb, sizeof(he_mu));\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_LSIG) {\n\t\tlsig = *(struct ieee80211_radiotap_lsig *)skb->data;\n\t\tskb_pull(skb, sizeof(lsig));\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_TLV_AT_END) {\n\t\t \n\t\ttlvs_len = skb_mac_header(skb) - skb->data;\n\t}\n\n\tmpdulen = skb->len;\n\tif (!(has_fcs && ieee80211_hw_check(&local->hw, RX_INCLUDES_FCS)))\n\t\tmpdulen += FCS_LEN;\n\n\trthdr = skb_push(skb, rtap_len - tlvs_len);\n\tmemset(rthdr, 0, rtap_len - tlvs_len);\n\tit_present = &rthdr->it_present;\n\n\t \n\trthdr->it_len = cpu_to_le16(rtap_len);\n\tit_present_val = BIT(IEEE80211_RADIOTAP_FLAGS) |\n\t\t\t BIT(IEEE80211_RADIOTAP_CHANNEL) |\n\t\t\t BIT(IEEE80211_RADIOTAP_RX_FLAGS);\n\n\tif (!status->chains)\n\t\tit_present_val |= BIT(IEEE80211_RADIOTAP_ANTENNA);\n\n\tfor_each_set_bit(chain, &chains, IEEE80211_MAX_CHAINS) {\n\t\tit_present_val |=\n\t\t\tBIT(IEEE80211_RADIOTAP_EXT) |\n\t\t\tBIT(IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE);\n\t\tput_unaligned_le32(it_present_val, it_present);\n\t\tit_present++;\n\t\tit_present_val = BIT(IEEE80211_RADIOTAP_ANTENNA) |\n\t\t\t\t BIT(IEEE80211_RADIOTAP_DBM_ANTSIGNAL);\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_TLV_AT_END)\n\t\tit_present_val |= BIT(IEEE80211_RADIOTAP_TLV);\n\n\tput_unaligned_le32(it_present_val, it_present);\n\n\t \n\tpos = (void *)&rthdr->it_optional[it_present + 1 - rthdr->it_optional];\n\n\t \n\n\t \n\tif (ieee80211_have_rx_timestamp(status)) {\n\t\t \n\t\twhile ((pos - (u8 *)rthdr) & 7)\n\t\t\t*pos++ = 0;\n\t\tput_unaligned_le64(\n\t\t\tieee80211_calculate_rx_timestamp(local, status,\n\t\t\t\t\t\t\t mpdulen, 0),\n\t\t\tpos);\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_TSFT));\n\t\tpos += 8;\n\t}\n\n\t \n\tif (has_fcs && ieee80211_hw_check(&local->hw, RX_INCLUDES_FCS))\n\t\t*pos |= IEEE80211_RADIOTAP_F_FCS;\n\tif (status->flag & (RX_FLAG_FAILED_FCS_CRC | RX_FLAG_FAILED_PLCP_CRC))\n\t\t*pos |= IEEE80211_RADIOTAP_F_BADFCS;\n\tif (status->enc_flags & RX_ENC_FLAG_SHORTPRE)\n\t\t*pos |= IEEE80211_RADIOTAP_F_SHORTPRE;\n\tpos++;\n\n\t \n\tif (!rate || status->encoding != RX_ENC_LEGACY) {\n\t\t \n\t\t*pos = 0;\n\t} else {\n\t\tint shift = 0;\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_RATE));\n\t\tif (status->bw == RATE_INFO_BW_10)\n\t\t\tshift = 1;\n\t\telse if (status->bw == RATE_INFO_BW_5)\n\t\t\tshift = 2;\n\t\t*pos = DIV_ROUND_UP(rate->bitrate, 5 * (1 << shift));\n\t}\n\tpos++;\n\n\t \n\t \n\tput_unaligned_le16(status->freq, pos);\n\tpos += 2;\n\tif (status->bw == RATE_INFO_BW_10)\n\t\tchannel_flags |= IEEE80211_CHAN_HALF;\n\telse if (status->bw == RATE_INFO_BW_5)\n\t\tchannel_flags |= IEEE80211_CHAN_QUARTER;\n\n\tif (status->band == NL80211_BAND_5GHZ ||\n\t    status->band == NL80211_BAND_6GHZ)\n\t\tchannel_flags |= IEEE80211_CHAN_OFDM | IEEE80211_CHAN_5GHZ;\n\telse if (status->encoding != RX_ENC_LEGACY)\n\t\tchannel_flags |= IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;\n\telse if (rate && rate->flags & IEEE80211_RATE_ERP_G)\n\t\tchannel_flags |= IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ;\n\telse if (rate)\n\t\tchannel_flags |= IEEE80211_CHAN_CCK | IEEE80211_CHAN_2GHZ;\n\telse\n\t\tchannel_flags |= IEEE80211_CHAN_2GHZ;\n\tput_unaligned_le16(channel_flags, pos);\n\tpos += 2;\n\n\t \n\tif (ieee80211_hw_check(&local->hw, SIGNAL_DBM) &&\n\t    !(status->flag & RX_FLAG_NO_SIGNAL_VAL)) {\n\t\t*pos = status->signal;\n\t\trthdr->it_present |=\n\t\t\tcpu_to_le32(BIT(IEEE80211_RADIOTAP_DBM_ANTSIGNAL));\n\t\tpos++;\n\t}\n\n\t \n\n\tif (!status->chains) {\n\t\t \n\t\t*pos = status->antenna;\n\t\tpos++;\n\t}\n\n\t \n\n\t \n\t \n\tif ((pos - (u8 *)rthdr) & 1)\n\t\t*pos++ = 0;\n\tif (status->flag & RX_FLAG_FAILED_PLCP_CRC)\n\t\trx_flags |= IEEE80211_RADIOTAP_F_RX_BADPLCP;\n\tput_unaligned_le16(rx_flags, pos);\n\tpos += 2;\n\n\tif (status->encoding == RX_ENC_HT) {\n\t\tunsigned int stbc;\n\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_MCS));\n\t\t*pos = local->hw.radiotap_mcs_details;\n\t\tif (status->enc_flags & RX_ENC_FLAG_HT_GF)\n\t\t\t*pos |= IEEE80211_RADIOTAP_MCS_HAVE_FMT;\n\t\tif (status->enc_flags & RX_ENC_FLAG_LDPC)\n\t\t\t*pos |= IEEE80211_RADIOTAP_MCS_HAVE_FEC;\n\t\tpos++;\n\t\t*pos = 0;\n\t\tif (status->enc_flags & RX_ENC_FLAG_SHORT_GI)\n\t\t\t*pos |= IEEE80211_RADIOTAP_MCS_SGI;\n\t\tif (status->bw == RATE_INFO_BW_40)\n\t\t\t*pos |= IEEE80211_RADIOTAP_MCS_BW_40;\n\t\tif (status->enc_flags & RX_ENC_FLAG_HT_GF)\n\t\t\t*pos |= IEEE80211_RADIOTAP_MCS_FMT_GF;\n\t\tif (status->enc_flags & RX_ENC_FLAG_LDPC)\n\t\t\t*pos |= IEEE80211_RADIOTAP_MCS_FEC_LDPC;\n\t\tstbc = (status->enc_flags & RX_ENC_FLAG_STBC_MASK) >> RX_ENC_FLAG_STBC_SHIFT;\n\t\t*pos |= stbc << IEEE80211_RADIOTAP_MCS_STBC_SHIFT;\n\t\tpos++;\n\t\t*pos++ = status->rate_idx;\n\t}\n\n\tif (status->flag & RX_FLAG_AMPDU_DETAILS) {\n\t\tu16 flags = 0;\n\n\t\t \n\t\twhile ((pos - (u8 *)rthdr) & 3)\n\t\t\tpos++;\n\t\trthdr->it_present |=\n\t\t\tcpu_to_le32(BIT(IEEE80211_RADIOTAP_AMPDU_STATUS));\n\t\tput_unaligned_le32(status->ampdu_reference, pos);\n\t\tpos += 4;\n\t\tif (status->flag & RX_FLAG_AMPDU_LAST_KNOWN)\n\t\t\tflags |= IEEE80211_RADIOTAP_AMPDU_LAST_KNOWN;\n\t\tif (status->flag & RX_FLAG_AMPDU_IS_LAST)\n\t\t\tflags |= IEEE80211_RADIOTAP_AMPDU_IS_LAST;\n\t\tif (status->flag & RX_FLAG_AMPDU_DELIM_CRC_ERROR)\n\t\t\tflags |= IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_ERR;\n\t\tif (status->flag & RX_FLAG_AMPDU_DELIM_CRC_KNOWN)\n\t\t\tflags |= IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_KNOWN;\n\t\tif (status->flag & RX_FLAG_AMPDU_EOF_BIT_KNOWN)\n\t\t\tflags |= IEEE80211_RADIOTAP_AMPDU_EOF_KNOWN;\n\t\tif (status->flag & RX_FLAG_AMPDU_EOF_BIT)\n\t\t\tflags |= IEEE80211_RADIOTAP_AMPDU_EOF;\n\t\tput_unaligned_le16(flags, pos);\n\t\tpos += 2;\n\t\tif (status->flag & RX_FLAG_AMPDU_DELIM_CRC_KNOWN)\n\t\t\t*pos++ = status->ampdu_delimiter_crc;\n\t\telse\n\t\t\t*pos++ = 0;\n\t\t*pos++ = 0;\n\t}\n\n\tif (status->encoding == RX_ENC_VHT) {\n\t\tu16 known = local->hw.radiotap_vht_details;\n\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_VHT));\n\t\tput_unaligned_le16(known, pos);\n\t\tpos += 2;\n\t\t \n\t\tif (status->enc_flags & RX_ENC_FLAG_SHORT_GI)\n\t\t\t*pos |= IEEE80211_RADIOTAP_VHT_FLAG_SGI;\n\t\t \n\t\tif (status->enc_flags & RX_ENC_FLAG_STBC_MASK)\n\t\t\t*pos |= IEEE80211_RADIOTAP_VHT_FLAG_STBC;\n\t\tif (status->enc_flags & RX_ENC_FLAG_BF)\n\t\t\t*pos |= IEEE80211_RADIOTAP_VHT_FLAG_BEAMFORMED;\n\t\tpos++;\n\t\t \n\t\tswitch (status->bw) {\n\t\tcase RATE_INFO_BW_80:\n\t\t\t*pos++ = 4;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_160:\n\t\t\t*pos++ = 11;\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_40:\n\t\t\t*pos++ = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*pos++ = 0;\n\t\t}\n\t\t \n\t\t*pos = (status->rate_idx << 4) | status->nss;\n\t\tpos += 4;\n\t\t \n\t\tif (status->enc_flags & RX_ENC_FLAG_LDPC)\n\t\t\t*pos |= IEEE80211_RADIOTAP_CODING_LDPC_USER0;\n\t\tpos++;\n\t\t \n\t\tpos++;\n\t\t \n\t\tpos += 2;\n\t}\n\n\tif (local->hw.radiotap_timestamp.units_pos >= 0) {\n\t\tu16 accuracy = 0;\n\t\tu8 flags = IEEE80211_RADIOTAP_TIMESTAMP_FLAG_32BIT;\n\n\t\trthdr->it_present |=\n\t\t\tcpu_to_le32(BIT(IEEE80211_RADIOTAP_TIMESTAMP));\n\n\t\t \n\t\twhile ((pos - (u8 *)rthdr) & 7)\n\t\t\tpos++;\n\n\t\tput_unaligned_le64(status->device_timestamp, pos);\n\t\tpos += sizeof(u64);\n\n\t\tif (local->hw.radiotap_timestamp.accuracy >= 0) {\n\t\t\taccuracy = local->hw.radiotap_timestamp.accuracy;\n\t\t\tflags |= IEEE80211_RADIOTAP_TIMESTAMP_FLAG_ACCURACY;\n\t\t}\n\t\tput_unaligned_le16(accuracy, pos);\n\t\tpos += sizeof(u16);\n\n\t\t*pos++ = local->hw.radiotap_timestamp.units_pos;\n\t\t*pos++ = flags;\n\t}\n\n\tif (status->encoding == RX_ENC_HE &&\n\t    status->flag & RX_FLAG_RADIOTAP_HE) {\n#define HE_PREP(f, val)\tle16_encode_bits(val, IEEE80211_RADIOTAP_HE_##f)\n\n\t\tif (status->enc_flags & RX_ENC_FLAG_STBC_MASK) {\n\t\t\the.data6 |= HE_PREP(DATA6_NSTS,\n\t\t\t\t\t    FIELD_GET(RX_ENC_FLAG_STBC_MASK,\n\t\t\t\t\t\t      status->enc_flags));\n\t\t\the.data3 |= HE_PREP(DATA3_STBC, 1);\n\t\t} else {\n\t\t\the.data6 |= HE_PREP(DATA6_NSTS, status->nss);\n\t\t}\n\n#define CHECK_GI(s) \\\n\tBUILD_BUG_ON(IEEE80211_RADIOTAP_HE_DATA5_GI_##s != \\\n\t\t     (int)NL80211_RATE_INFO_HE_GI_##s)\n\n\t\tCHECK_GI(0_8);\n\t\tCHECK_GI(1_6);\n\t\tCHECK_GI(3_2);\n\n\t\the.data3 |= HE_PREP(DATA3_DATA_MCS, status->rate_idx);\n\t\the.data3 |= HE_PREP(DATA3_DATA_DCM, status->he_dcm);\n\t\the.data3 |= HE_PREP(DATA3_CODING,\n\t\t\t\t    !!(status->enc_flags & RX_ENC_FLAG_LDPC));\n\n\t\the.data5 |= HE_PREP(DATA5_GI, status->he_gi);\n\n\t\tswitch (status->bw) {\n\t\tcase RATE_INFO_BW_20:\n\t\t\the.data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t    IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_20MHZ);\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_40:\n\t\t\the.data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t    IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_40MHZ);\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_80:\n\t\t\the.data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t    IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_80MHZ);\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_160:\n\t\t\the.data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t    IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_160MHZ);\n\t\t\tbreak;\n\t\tcase RATE_INFO_BW_HE_RU:\n#define CHECK_RU_ALLOC(s) \\\n\tBUILD_BUG_ON(IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_##s##T != \\\n\t\t     NL80211_RATE_INFO_HE_RU_ALLOC_##s + 4)\n\n\t\t\tCHECK_RU_ALLOC(26);\n\t\t\tCHECK_RU_ALLOC(52);\n\t\t\tCHECK_RU_ALLOC(106);\n\t\t\tCHECK_RU_ALLOC(242);\n\t\t\tCHECK_RU_ALLOC(484);\n\t\t\tCHECK_RU_ALLOC(996);\n\t\t\tCHECK_RU_ALLOC(2x996);\n\n\t\t\the.data5 |= HE_PREP(DATA5_DATA_BW_RU_ALLOC,\n\t\t\t\t\t    status->he_ru + 4);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ONCE(1, \"Invalid SU BW %d\\n\", status->bw);\n\t\t}\n\n\t\t \n\t\twhile ((pos - (u8 *)rthdr) & 1)\n\t\t\tpos++;\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_HE));\n\t\tmemcpy(pos, &he, sizeof(he));\n\t\tpos += sizeof(he);\n\t}\n\n\tif (status->encoding == RX_ENC_HE &&\n\t    status->flag & RX_FLAG_RADIOTAP_HE_MU) {\n\t\t \n\t\twhile ((pos - (u8 *)rthdr) & 1)\n\t\t\tpos++;\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_HE_MU));\n\t\tmemcpy(pos, &he_mu, sizeof(he_mu));\n\t\tpos += sizeof(he_mu);\n\t}\n\n\tif (status->flag & RX_FLAG_NO_PSDU) {\n\t\trthdr->it_present |=\n\t\t\tcpu_to_le32(BIT(IEEE80211_RADIOTAP_ZERO_LEN_PSDU));\n\t\t*pos++ = status->zero_length_psdu_type;\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_LSIG) {\n\t\t \n\t\twhile ((pos - (u8 *)rthdr) & 1)\n\t\t\tpos++;\n\t\trthdr->it_present |= cpu_to_le32(BIT(IEEE80211_RADIOTAP_LSIG));\n\t\tmemcpy(pos, &lsig, sizeof(lsig));\n\t\tpos += sizeof(lsig);\n\t}\n\n\tfor_each_set_bit(chain, &chains, IEEE80211_MAX_CHAINS) {\n\t\t*pos++ = status->chain_signal[chain];\n\t\t*pos++ = chain;\n\t}\n}\n\nstatic struct sk_buff *\nieee80211_make_monitor_skb(struct ieee80211_local *local,\n\t\t\t   struct sk_buff **origskb,\n\t\t\t   struct ieee80211_rate *rate,\n\t\t\t   int rtap_space, bool use_origskb)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(*origskb);\n\tint rt_hdrlen, needed_headroom;\n\tstruct sk_buff *skb;\n\n\t \n\trt_hdrlen = ieee80211_rx_radiotap_hdrlen(local, status, *origskb);\n\tneeded_headroom = rt_hdrlen - rtap_space;\n\n\tif (use_origskb) {\n\t\t \n\t\tskb = *origskb;\n\t\t*origskb = NULL;\n\n\t\t \n\t\tif (skb_headroom(skb) < needed_headroom &&\n\t\t    pskb_expand_head(skb, needed_headroom, 0, GFP_ATOMIC)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\t \n\t\tskb = skb_copy_expand(*origskb, needed_headroom + NET_SKB_PAD,\n\t\t\t\t      0, GFP_ATOMIC);\n\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t}\n\n\t \n\tieee80211_add_rx_radiotap_header(local, skb, rate, rt_hdrlen, true);\n\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\n\treturn skb;\n}\n\n \nstatic struct sk_buff *\nieee80211_rx_monitor(struct ieee80211_local *local, struct sk_buff *origskb,\n\t\t     struct ieee80211_rate *rate)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(origskb);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sk_buff *monskb = NULL;\n\tint present_fcs_len = 0;\n\tunsigned int rtap_space = 0;\n\tstruct ieee80211_sub_if_data *monitor_sdata =\n\t\trcu_dereference(local->monitor_sdata);\n\tbool only_monitor = false;\n\tunsigned int min_head_len;\n\n\tif (WARN_ON_ONCE(status->flag & RX_FLAG_RADIOTAP_TLV_AT_END &&\n\t\t\t !skb_mac_header_was_set(origskb))) {\n\t\t \n\t\tdev_kfree_skb(origskb);\n\t\treturn NULL;\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_HE)\n\t\trtap_space += sizeof(struct ieee80211_radiotap_he);\n\n\tif (status->flag & RX_FLAG_RADIOTAP_HE_MU)\n\t\trtap_space += sizeof(struct ieee80211_radiotap_he_mu);\n\n\tif (status->flag & RX_FLAG_RADIOTAP_LSIG)\n\t\trtap_space += sizeof(struct ieee80211_radiotap_lsig);\n\n\tif (status->flag & RX_FLAG_RADIOTAP_TLV_AT_END)\n\t\trtap_space += skb_mac_header(origskb) - &origskb->data[rtap_space];\n\n\tmin_head_len = rtap_space;\n\n\t \n\n\tif (!(status->flag & RX_FLAG_NO_PSDU)) {\n\t\tif (ieee80211_hw_check(&local->hw, RX_INCLUDES_FCS)) {\n\t\t\tif (unlikely(origskb->len <= FCS_LEN + rtap_space)) {\n\t\t\t\t \n\t\t\t\tWARN_ON(1);\n\t\t\t\tdev_kfree_skb(origskb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tpresent_fcs_len = FCS_LEN;\n\t\t}\n\n\t\t \n\t\tmin_head_len += 2;\n\t}\n\n\t \n\tif (!pskb_may_pull(origskb, min_head_len)) {\n\t\tdev_kfree_skb(origskb);\n\t\treturn NULL;\n\t}\n\n\tonly_monitor = should_drop_frame(origskb, present_fcs_len, rtap_space);\n\n\tif (!local->monitors || (status->flag & RX_FLAG_SKIP_MONITOR)) {\n\t\tif (only_monitor) {\n\t\t\tdev_kfree_skb(origskb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn ieee80211_clean_skb(origskb, present_fcs_len,\n\t\t\t\t\t   rtap_space);\n\t}\n\n\tieee80211_handle_mu_mimo_mon(monitor_sdata, origskb, rtap_space);\n\n\tlist_for_each_entry_rcu(sdata, &local->mon_list, u.mntr.list) {\n\t\tbool last_monitor = list_is_last(&sdata->u.mntr.list,\n\t\t\t\t\t\t &local->mon_list);\n\n\t\tif (!monskb)\n\t\t\tmonskb = ieee80211_make_monitor_skb(local, &origskb,\n\t\t\t\t\t\t\t    rate, rtap_space,\n\t\t\t\t\t\t\t    only_monitor &&\n\t\t\t\t\t\t\t    last_monitor);\n\n\t\tif (monskb) {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif (last_monitor) {\n\t\t\t\tskb = monskb;\n\t\t\t\tmonskb = NULL;\n\t\t\t} else {\n\t\t\t\tskb = skb_clone(monskb, GFP_ATOMIC);\n\t\t\t}\n\n\t\t\tif (skb) {\n\t\t\t\tskb->dev = sdata->dev;\n\t\t\t\tdev_sw_netstats_rx_add(skb->dev, skb->len);\n\t\t\t\tnetif_receive_skb(skb);\n\t\t\t}\n\t\t}\n\n\t\tif (last_monitor)\n\t\t\tbreak;\n\t}\n\n\t \n\tdev_kfree_skb(monskb);\n\n\t \n\tif (!origskb)\n\t\treturn NULL;\n\n\treturn ieee80211_clean_skb(origskb, present_fcs_len, rtap_space);\n}\n\nstatic void ieee80211_parse_qos(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\tint tid, seqno_idx, security_idx;\n\n\t \n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\t \n\t\ttid = *qc & IEEE80211_QOS_CTL_TID_MASK;\n\t\tif (*qc & IEEE80211_QOS_CTL_A_MSDU_PRESENT)\n\t\t\tstatus->rx_flags |= IEEE80211_RX_AMSDU;\n\n\t\tseqno_idx = tid;\n\t\tsecurity_idx = tid;\n\t} else {\n\t\t \n\t\tseqno_idx = IEEE80211_NUM_TIDS;\n\t\tsecurity_idx = 0;\n\t\tif (ieee80211_is_mgmt(hdr->frame_control))\n\t\t\tsecurity_idx = IEEE80211_NUM_TIDS;\n\t\ttid = 0;\n\t}\n\n\trx->seqno_idx = seqno_idx;\n\trx->security_idx = security_idx;\n\t \n\trx->skb->priority = (tid > 7) ? 0 : tid;\n}\n\n \nstatic void ieee80211_verify_alignment(struct ieee80211_rx_data *rx)\n{\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\tWARN_ON_ONCE((unsigned long)rx->skb->data & 1);\n#endif\n}\n\n\n \n\nstatic int ieee80211_is_unicast_robust_mgmt_frame(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (is_multicast_ether_addr(hdr->addr1))\n\t\treturn 0;\n\n\treturn ieee80211_is_robust_mgmt_frame(skb);\n}\n\n\nstatic int ieee80211_is_multicast_robust_mgmt_frame(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (!is_multicast_ether_addr(hdr->addr1))\n\t\treturn 0;\n\n\treturn ieee80211_is_robust_mgmt_frame(skb);\n}\n\n\n \nstatic int ieee80211_get_mmie_keyidx(struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *hdr = (struct ieee80211_mgmt *) skb->data;\n\tstruct ieee80211_mmie *mmie;\n\tstruct ieee80211_mmie_16 *mmie16;\n\n\tif (skb->len < 24 + sizeof(*mmie) || !is_multicast_ether_addr(hdr->da))\n\t\treturn -1;\n\n\tif (!ieee80211_is_robust_mgmt_frame(skb) &&\n\t    !ieee80211_is_beacon(hdr->frame_control))\n\t\treturn -1;  \n\n\tmmie = (struct ieee80211_mmie *)\n\t\t(skb->data + skb->len - sizeof(*mmie));\n\tif (mmie->element_id == WLAN_EID_MMIE &&\n\t    mmie->length == sizeof(*mmie) - 2)\n\t\treturn le16_to_cpu(mmie->key_id);\n\n\tmmie16 = (struct ieee80211_mmie_16 *)\n\t\t(skb->data + skb->len - sizeof(*mmie16));\n\tif (skb->len >= 24 + sizeof(*mmie16) &&\n\t    mmie16->element_id == WLAN_EID_MMIE &&\n\t    mmie16->length == sizeof(*mmie16) - 2)\n\t\treturn le16_to_cpu(mmie16->key_id);\n\n\treturn -1;\n}\n\nstatic int ieee80211_get_keyid(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\tint hdrlen = ieee80211_hdrlen(fc);\n\tu8 keyid;\n\n\t \n\tif (unlikely(skb->len < hdrlen + IEEE80211_WEP_IV_LEN))\n\t\treturn -EINVAL;\n\n\tskb_copy_bits(skb, hdrlen + 3, &keyid, 1);\n\n\tkeyid >>= 6;\n\n\treturn keyid;\n}\n\nstatic ieee80211_rx_result ieee80211_rx_mesh_check(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tchar *dev_addr = rx->sdata->vif.addr;\n\n\tif (ieee80211_is_data(hdr->frame_control)) {\n\t\tif (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\tif (ieee80211_has_tods(hdr->frame_control) ||\n\t\t\t    !ieee80211_has_fromds(hdr->frame_control))\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t\tif (ether_addr_equal(hdr->addr3, dev_addr))\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t} else {\n\t\t\tif (!ieee80211_has_a4(hdr->frame_control))\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t\tif (ether_addr_equal(hdr->addr4, dev_addr))\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t}\n\t}\n\n\t \n\n\tif (!rx->sta || sta_plink_state(rx->sta) != NL80211_PLINK_ESTAB) {\n\t\tstruct ieee80211_mgmt *mgmt;\n\n\t\tif (!ieee80211_is_mgmt(hdr->frame_control))\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\tif (ieee80211_is_action(hdr->frame_control)) {\n\t\t\tu8 category;\n\n\t\t\t \n\t\t\tif (rx->skb->len < IEEE80211_MIN_ACTION_SIZE)\n\t\t\t\treturn RX_DROP_MONITOR;\n\n\t\t\tmgmt = (struct ieee80211_mgmt *)hdr;\n\t\t\tcategory = mgmt->u.action.category;\n\t\t\tif (category != WLAN_CATEGORY_MESH_ACTION &&\n\t\t\t    category != WLAN_CATEGORY_SELF_PROTECTED)\n\t\t\t\treturn RX_DROP_MONITOR;\n\t\t\treturn RX_CONTINUE;\n\t\t}\n\n\t\tif (ieee80211_is_probe_req(hdr->frame_control) ||\n\t\t    ieee80211_is_probe_resp(hdr->frame_control) ||\n\t\t    ieee80211_is_beacon(hdr->frame_control) ||\n\t\t    ieee80211_is_auth(hdr->frame_control))\n\t\t\treturn RX_CONTINUE;\n\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\treturn RX_CONTINUE;\n}\n\nstatic inline bool ieee80211_rx_reorder_ready(struct tid_ampdu_rx *tid_agg_rx,\n\t\t\t\t\t      int index)\n{\n\tstruct sk_buff_head *frames = &tid_agg_rx->reorder_buf[index];\n\tstruct sk_buff *tail = skb_peek_tail(frames);\n\tstruct ieee80211_rx_status *status;\n\n\tif (tid_agg_rx->reorder_buf_filtered &&\n\t    tid_agg_rx->reorder_buf_filtered & BIT_ULL(index))\n\t\treturn true;\n\n\tif (!tail)\n\t\treturn false;\n\n\tstatus = IEEE80211_SKB_RXCB(tail);\n\tif (status->flag & RX_FLAG_AMSDU_MORE)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ieee80211_release_reorder_frame(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    struct tid_ampdu_rx *tid_agg_rx,\n\t\t\t\t\t    int index,\n\t\t\t\t\t    struct sk_buff_head *frames)\n{\n\tstruct sk_buff_head *skb_list = &tid_agg_rx->reorder_buf[index];\n\tstruct sk_buff *skb;\n\tstruct ieee80211_rx_status *status;\n\n\tlockdep_assert_held(&tid_agg_rx->reorder_lock);\n\n\tif (skb_queue_empty(skb_list))\n\t\tgoto no_frame;\n\n\tif (!ieee80211_rx_reorder_ready(tid_agg_rx, index)) {\n\t\t__skb_queue_purge(skb_list);\n\t\tgoto no_frame;\n\t}\n\n\t \n\ttid_agg_rx->stored_mpdu_num--;\n\twhile ((skb = __skb_dequeue(skb_list))) {\n\t\tstatus = IEEE80211_SKB_RXCB(skb);\n\t\tstatus->rx_flags |= IEEE80211_RX_DEFERRED_RELEASE;\n\t\t__skb_queue_tail(frames, skb);\n\t}\n\nno_frame:\n\tif (tid_agg_rx->reorder_buf_filtered)\n\t\ttid_agg_rx->reorder_buf_filtered &= ~BIT_ULL(index);\n\ttid_agg_rx->head_seq_num = ieee80211_sn_inc(tid_agg_rx->head_seq_num);\n}\n\nstatic void ieee80211_release_reorder_frames(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t     struct tid_ampdu_rx *tid_agg_rx,\n\t\t\t\t\t     u16 head_seq_num,\n\t\t\t\t\t     struct sk_buff_head *frames)\n{\n\tint index;\n\n\tlockdep_assert_held(&tid_agg_rx->reorder_lock);\n\n\twhile (ieee80211_sn_less(tid_agg_rx->head_seq_num, head_seq_num)) {\n\t\tindex = tid_agg_rx->head_seq_num % tid_agg_rx->buf_size;\n\t\tieee80211_release_reorder_frame(sdata, tid_agg_rx, index,\n\t\t\t\t\t\tframes);\n\t}\n}\n\n \n#define HT_RX_REORDER_BUF_TIMEOUT (HZ / 10)\n\nstatic void ieee80211_sta_reorder_release(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t  struct tid_ampdu_rx *tid_agg_rx,\n\t\t\t\t\t  struct sk_buff_head *frames)\n{\n\tint index, i, j;\n\n\tlockdep_assert_held(&tid_agg_rx->reorder_lock);\n\n\t \n\tindex = tid_agg_rx->head_seq_num % tid_agg_rx->buf_size;\n\tif (!ieee80211_rx_reorder_ready(tid_agg_rx, index) &&\n\t    tid_agg_rx->stored_mpdu_num) {\n\t\t \n\t\tint skipped = 1;\n\t\tfor (j = (index + 1) % tid_agg_rx->buf_size; j != index;\n\t\t     j = (j + 1) % tid_agg_rx->buf_size) {\n\t\t\tif (!ieee80211_rx_reorder_ready(tid_agg_rx, j)) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (skipped &&\n\t\t\t    !time_after(jiffies, tid_agg_rx->reorder_time[j] +\n\t\t\t\t\tHT_RX_REORDER_BUF_TIMEOUT))\n\t\t\t\tgoto set_release_timer;\n\n\t\t\t \n\t\t\tfor (i = (index + 1) % tid_agg_rx->buf_size; i != j;\n\t\t\t     i = (i + 1) % tid_agg_rx->buf_size)\n\t\t\t\t__skb_queue_purge(&tid_agg_rx->reorder_buf[i]);\n\n\t\t\tht_dbg_ratelimited(sdata,\n\t\t\t\t\t   \"release an RX reorder frame due to timeout on earlier frames\\n\");\n\t\t\tieee80211_release_reorder_frame(sdata, tid_agg_rx, j,\n\t\t\t\t\t\t\tframes);\n\n\t\t\t \n\t\t\ttid_agg_rx->head_seq_num =\n\t\t\t\t(tid_agg_rx->head_seq_num +\n\t\t\t\t skipped) & IEEE80211_SN_MASK;\n\t\t\tskipped = 0;\n\t\t}\n\t} else while (ieee80211_rx_reorder_ready(tid_agg_rx, index)) {\n\t\tieee80211_release_reorder_frame(sdata, tid_agg_rx, index,\n\t\t\t\t\t\tframes);\n\t\tindex =\ttid_agg_rx->head_seq_num % tid_agg_rx->buf_size;\n\t}\n\n\tif (tid_agg_rx->stored_mpdu_num) {\n\t\tj = index = tid_agg_rx->head_seq_num % tid_agg_rx->buf_size;\n\n\t\tfor (; j != (index - 1) % tid_agg_rx->buf_size;\n\t\t     j = (j + 1) % tid_agg_rx->buf_size) {\n\t\t\tif (ieee80211_rx_reorder_ready(tid_agg_rx, j))\n\t\t\t\tbreak;\n\t\t}\n\n set_release_timer:\n\n\t\tif (!tid_agg_rx->removed)\n\t\t\tmod_timer(&tid_agg_rx->reorder_timer,\n\t\t\t\t  tid_agg_rx->reorder_time[j] + 1 +\n\t\t\t\t  HT_RX_REORDER_BUF_TIMEOUT);\n\t} else {\n\t\tdel_timer(&tid_agg_rx->reorder_timer);\n\t}\n}\n\n \nstatic bool ieee80211_sta_manage_reorder_buf(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t     struct tid_ampdu_rx *tid_agg_rx,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     struct sk_buff_head *frames)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tu16 sc = le16_to_cpu(hdr->seq_ctrl);\n\tu16 mpdu_seq_num = (sc & IEEE80211_SCTL_SEQ) >> 4;\n\tu16 head_seq_num, buf_size;\n\tint index;\n\tbool ret = true;\n\n\tspin_lock(&tid_agg_rx->reorder_lock);\n\n\t \n\tif (unlikely(tid_agg_rx->auto_seq)) {\n\t\ttid_agg_rx->auto_seq = false;\n\t\ttid_agg_rx->ssn = mpdu_seq_num;\n\t\ttid_agg_rx->head_seq_num = mpdu_seq_num;\n\t}\n\n\tbuf_size = tid_agg_rx->buf_size;\n\thead_seq_num = tid_agg_rx->head_seq_num;\n\n\t \n\tif (unlikely(!tid_agg_rx->started)) {\n\t\tif (ieee80211_sn_less(mpdu_seq_num, head_seq_num)) {\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\t\ttid_agg_rx->started = true;\n\t}\n\n\t \n\tif (ieee80211_sn_less(mpdu_seq_num, head_seq_num)) {\n\t\tdev_kfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!ieee80211_sn_less(mpdu_seq_num, head_seq_num + buf_size)) {\n\t\thead_seq_num = ieee80211_sn_inc(\n\t\t\t\tieee80211_sn_sub(mpdu_seq_num, buf_size));\n\t\t \n\t\tieee80211_release_reorder_frames(sdata, tid_agg_rx,\n\t\t\t\t\t\t head_seq_num, frames);\n\t}\n\n\t \n\n\tindex = mpdu_seq_num % tid_agg_rx->buf_size;\n\n\t \n\tif (ieee80211_rx_reorder_ready(tid_agg_rx, index)) {\n\t\tdev_kfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\t \n\tif (mpdu_seq_num == tid_agg_rx->head_seq_num &&\n\t    tid_agg_rx->stored_mpdu_num == 0) {\n\t\tif (!(status->flag & RX_FLAG_AMSDU_MORE))\n\t\t\ttid_agg_rx->head_seq_num =\n\t\t\t\tieee80211_sn_inc(tid_agg_rx->head_seq_num);\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\t \n\t__skb_queue_tail(&tid_agg_rx->reorder_buf[index], skb);\n\tif (!(status->flag & RX_FLAG_AMSDU_MORE)) {\n\t\ttid_agg_rx->reorder_time[index] = jiffies;\n\t\ttid_agg_rx->stored_mpdu_num++;\n\t\tieee80211_sta_reorder_release(sdata, tid_agg_rx, frames);\n\t}\n\n out:\n\tspin_unlock(&tid_agg_rx->reorder_lock);\n\treturn ret;\n}\n\n \nstatic void ieee80211_rx_reorder_ampdu(struct ieee80211_rx_data *rx,\n\t\t\t\t       struct sk_buff_head *frames)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct sta_info *sta = rx->sta;\n\tstruct tid_ampdu_rx *tid_agg_rx;\n\tu16 sc;\n\tu8 tid, ack_policy;\n\n\tif (!ieee80211_is_data_qos(hdr->frame_control) ||\n\t    is_multicast_ether_addr(hdr->addr1))\n\t\tgoto dont_reorder;\n\n\t \n\n\tif (!sta)\n\t\tgoto dont_reorder;\n\n\tack_policy = *ieee80211_get_qos_ctl(hdr) &\n\t\t     IEEE80211_QOS_CTL_ACK_POLICY_MASK;\n\ttid = ieee80211_get_tid(hdr);\n\n\ttid_agg_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[tid]);\n\tif (!tid_agg_rx) {\n\t\tif (ack_policy == IEEE80211_QOS_CTL_ACK_POLICY_BLOCKACK &&\n\t\t    !test_bit(tid, rx->sta->ampdu_mlme.agg_session_valid) &&\n\t\t    !test_and_set_bit(tid, rx->sta->ampdu_mlme.unexpected_agg))\n\t\t\tieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid,\n\t\t\t\t\t     WLAN_BACK_RECIPIENT,\n\t\t\t\t\t     WLAN_REASON_QSTA_REQUIRE_SETUP);\n\t\tgoto dont_reorder;\n\t}\n\n\t \n\tif (unlikely(hdr->frame_control & cpu_to_le16(IEEE80211_STYPE_NULLFUNC)))\n\t\tgoto dont_reorder;\n\n\t \n\tif (ack_policy == IEEE80211_QOS_CTL_ACK_POLICY_NOACK)\n\t\tgoto dont_reorder;\n\n\t \n\n\t \n\tif (tid_agg_rx->timeout)\n\t\ttid_agg_rx->last_rx = jiffies;\n\n\t \n\tsc = le16_to_cpu(hdr->seq_ctrl);\n\tif (sc & IEEE80211_SCTL_FRAG) {\n\t\tieee80211_queue_skb_to_iface(rx->sdata, rx->link_id, NULL, skb);\n\t\treturn;\n\t}\n\n\t \n\tif (ieee80211_sta_manage_reorder_buf(rx->sdata, tid_agg_rx, skb,\n\t\t\t\t\t     frames))\n\t\treturn;\n\n dont_reorder:\n\t__skb_queue_tail(frames, skb);\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_check_dup(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\n\tif (status->flag & RX_FLAG_DUP_VALIDATED)\n\t\treturn RX_CONTINUE;\n\n\t \n\n\tif (rx->skb->len < 24)\n\t\treturn RX_CONTINUE;\n\n\tif (ieee80211_is_ctl(hdr->frame_control) ||\n\t    ieee80211_is_any_nullfunc(hdr->frame_control) ||\n\t    is_multicast_ether_addr(hdr->addr1))\n\t\treturn RX_CONTINUE;\n\n\tif (!rx->sta)\n\t\treturn RX_CONTINUE;\n\n\tif (unlikely(ieee80211_has_retry(hdr->frame_control) &&\n\t\t     rx->sta->last_seq_ctrl[rx->seqno_idx] == hdr->seq_ctrl)) {\n\t\tI802_DEBUG_INC(rx->local->dot11FrameDuplicateCount);\n\t\trx->link_sta->rx_stats.num_duplicates++;\n\t\treturn RX_DROP_UNUSABLE;\n\t} else if (!(status->flag & RX_FLAG_AMSDU_MORE)) {\n\t\trx->sta->last_seq_ctrl[rx->seqno_idx] = hdr->seq_ctrl;\n\t}\n\n\treturn RX_CONTINUE;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_check(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\n\t \n\n\tif (ieee80211_vif_is_mesh(&rx->sdata->vif))\n\t\treturn ieee80211_rx_mesh_check(rx);\n\n\tif (unlikely((ieee80211_is_data(hdr->frame_control) ||\n\t\t      ieee80211_is_pspoll(hdr->frame_control)) &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t     rx->sdata->vif.type != NL80211_IFTYPE_OCB &&\n\t\t     (!rx->sta || !test_sta_flag(rx->sta, WLAN_STA_ASSOC)))) {\n\t\t \n\t\tif (rx->sta && rx->sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t    ieee80211_is_data_present(hdr->frame_control)) {\n\t\t\tunsigned int hdrlen;\n\t\t\t__be16 ethertype;\n\n\t\t\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\n\t\t\tif (rx->skb->len < hdrlen + 8)\n\t\t\t\treturn RX_DROP_MONITOR;\n\n\t\t\tskb_copy_bits(rx->skb, hdrlen + 6, &ethertype, 2);\n\t\t\tif (ethertype == rx->sdata->control_port_protocol)\n\t\t\t\treturn RX_CONTINUE;\n\t\t}\n\n\t\tif (rx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t\t    cfg80211_rx_spurious_frame(rx->sdata->dev,\n\t\t\t\t\t       hdr->addr2,\n\t\t\t\t\t       GFP_ATOMIC))\n\t\t\treturn RX_DROP_UNUSABLE;\n\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\treturn RX_CONTINUE;\n}\n\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_check_more_data(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_local *local;\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb;\n\n\tlocal = rx->local;\n\tskb = rx->skb;\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\tif (!local->pspolling)\n\t\treturn RX_CONTINUE;\n\n\tif (!ieee80211_has_fromds(hdr->frame_control))\n\t\t \n\t\treturn RX_CONTINUE;\n\n\tif (!ieee80211_is_data(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\tif (!ieee80211_has_moredata(hdr->frame_control)) {\n\t\t \n\t\tlocal->pspolling = false;\n\t\treturn RX_CONTINUE;\n\t}\n\n\t \n\tieee80211_send_pspoll(local, rx->sdata);\n\n\treturn RX_CONTINUE;\n}\n\nstatic void sta_ps_start(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ps_data *ps;\n\tint tid;\n\n\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tps = &sdata->bss->ps;\n\telse\n\t\treturn;\n\n\tatomic_inc(&ps->num_sta_ps);\n\tset_sta_flag(sta, WLAN_STA_PS_STA);\n\tif (!ieee80211_hw_check(&local->hw, AP_LINK_PS))\n\t\tdrv_sta_notify(local, sdata, STA_NOTIFY_SLEEP, &sta->sta);\n\tps_dbg(sdata, \"STA %pM aid %d enters power save mode\\n\",\n\t       sta->sta.addr, sta->sta.aid);\n\n\tieee80211_clear_fast_xmit(sta);\n\n\tfor (tid = 0; tid < IEEE80211_NUM_TIDS; tid++) {\n\t\tstruct ieee80211_txq *txq = sta->sta.txq[tid];\n\t\tstruct txq_info *txqi = to_txq_info(txq);\n\n\t\tspin_lock(&local->active_txq_lock[txq->ac]);\n\t\tif (!list_empty(&txqi->schedule_order))\n\t\t\tlist_del_init(&txqi->schedule_order);\n\t\tspin_unlock(&local->active_txq_lock[txq->ac]);\n\n\t\tif (txq_has_queue(txq))\n\t\t\tset_bit(tid, &sta->txq_buffered_tids);\n\t\telse\n\t\t\tclear_bit(tid, &sta->txq_buffered_tids);\n\t}\n}\n\nstatic void sta_ps_end(struct sta_info *sta)\n{\n\tps_dbg(sta->sdata, \"STA %pM aid %d exits power save mode\\n\",\n\t       sta->sta.addr, sta->sta.aid);\n\n\tif (test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {\n\t\t \n\t\tclear_sta_flag(sta, WLAN_STA_PS_STA);\n\t\tps_dbg(sta->sdata, \"STA %pM aid %d driver-ps-blocked\\n\",\n\t\t       sta->sta.addr, sta->sta.aid);\n\t\treturn;\n\t}\n\n\tset_sta_flag(sta, WLAN_STA_PS_DELIVER);\n\tclear_sta_flag(sta, WLAN_STA_PS_STA);\n\tieee80211_sta_ps_deliver_wakeup(sta);\n}\n\nint ieee80211_sta_ps_transition(struct ieee80211_sta *pubsta, bool start)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tbool in_ps;\n\n\tWARN_ON(!ieee80211_hw_check(&sta->local->hw, AP_LINK_PS));\n\n\t \n\tin_ps = test_sta_flag(sta, WLAN_STA_PS_STA);\n\tif ((start && in_ps) || (!start && !in_ps))\n\t\treturn -EINVAL;\n\n\tif (start)\n\t\tsta_ps_start(sta);\n\telse\n\t\tsta_ps_end(sta);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_sta_ps_transition);\n\nvoid ieee80211_sta_pspoll(struct ieee80211_sta *pubsta)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\tif (test_sta_flag(sta, WLAN_STA_SP))\n\t\treturn;\n\n\tif (!test_sta_flag(sta, WLAN_STA_PS_DRIVER))\n\t\tieee80211_sta_ps_deliver_poll_response(sta);\n\telse\n\t\tset_sta_flag(sta, WLAN_STA_PSPOLL);\n}\nEXPORT_SYMBOL(ieee80211_sta_pspoll);\n\nvoid ieee80211_sta_uapsd_trigger(struct ieee80211_sta *pubsta, u8 tid)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tint ac = ieee80211_ac_from_tid(tid);\n\n\t \n\tif (!(sta->sta.uapsd_queues & ieee80211_ac_to_qos_mask[ac]) &&\n\t    tid != IEEE80211_NUM_TIDS)\n\t\treturn;\n\n\t \n\tif (test_sta_flag(sta, WLAN_STA_SP))\n\t\treturn;\n\n\tif (!test_sta_flag(sta, WLAN_STA_PS_DRIVER))\n\t\tieee80211_sta_ps_deliver_uapsd(sta);\n\telse\n\t\tset_sta_flag(sta, WLAN_STA_UAPSD);\n}\nEXPORT_SYMBOL(ieee80211_sta_uapsd_trigger);\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_uapsd_and_pspoll(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_hdr *hdr = (void *)rx->skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\n\tif (!rx->sta)\n\t\treturn RX_CONTINUE;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_AP &&\n\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN)\n\t\treturn RX_CONTINUE;\n\n\t \n\tif (ieee80211_hw_check(&sdata->local->hw, AP_LINK_PS))\n\t\treturn RX_CONTINUE;\n\n\t \n\tif (!test_sta_flag(rx->sta, WLAN_STA_PS_STA))\n\t\treturn RX_CONTINUE;\n\n\tif (unlikely(ieee80211_is_pspoll(hdr->frame_control))) {\n\t\tieee80211_sta_pspoll(&rx->sta->sta);\n\n\t\t \n\t\tdev_kfree_skb(rx->skb);\n\n\t\treturn RX_QUEUED;\n\t} else if (!ieee80211_has_morefrags(hdr->frame_control) &&\n\t\t   !(status->rx_flags & IEEE80211_RX_DEFERRED_RELEASE) &&\n\t\t   ieee80211_has_pm(hdr->frame_control) &&\n\t\t   (ieee80211_is_data_qos(hdr->frame_control) ||\n\t\t    ieee80211_is_qos_nullfunc(hdr->frame_control))) {\n\t\tu8 tid = ieee80211_get_tid(hdr);\n\n\t\tieee80211_sta_uapsd_trigger(&rx->sta->sta, tid);\n\t}\n\n\treturn RX_CONTINUE;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_sta_process(struct ieee80211_rx_data *rx)\n{\n\tstruct sta_info *sta = rx->sta;\n\tstruct link_sta_info *link_sta = rx->link_sta;\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tint i;\n\n\tif (!sta || !link_sta)\n\t\treturn RX_CONTINUE;\n\n\t \n\tif (rx->sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tu8 *bssid = ieee80211_get_bssid(hdr, rx->skb->len,\n\t\t\t\t\t\tNL80211_IFTYPE_ADHOC);\n\t\tif (ether_addr_equal(bssid, rx->sdata->u.ibss.bssid) &&\n\t\t    test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {\n\t\t\tlink_sta->rx_stats.last_rx = jiffies;\n\t\t\tif (ieee80211_is_data_present(hdr->frame_control) &&\n\t\t\t    !is_multicast_ether_addr(hdr->addr1))\n\t\t\t\tlink_sta->rx_stats.last_rate =\n\t\t\t\t\tsta_stats_encode_rate(status);\n\t\t}\n\t} else if (rx->sdata->vif.type == NL80211_IFTYPE_OCB) {\n\t\tlink_sta->rx_stats.last_rx = jiffies;\n\t} else if (!ieee80211_is_s1g_beacon(hdr->frame_control) &&\n\t\t   !is_multicast_ether_addr(hdr->addr1)) {\n\t\t \n\t\tlink_sta->rx_stats.last_rx = jiffies;\n\t\tif (ieee80211_is_data_present(hdr->frame_control))\n\t\t\tlink_sta->rx_stats.last_rate = sta_stats_encode_rate(status);\n\t}\n\n\tlink_sta->rx_stats.fragments++;\n\n\tu64_stats_update_begin(&link_sta->rx_stats.syncp);\n\tlink_sta->rx_stats.bytes += rx->skb->len;\n\tu64_stats_update_end(&link_sta->rx_stats.syncp);\n\n\tif (!(status->flag & RX_FLAG_NO_SIGNAL_VAL)) {\n\t\tlink_sta->rx_stats.last_signal = status->signal;\n\t\tewma_signal_add(&link_sta->rx_stats_avg.signal,\n\t\t\t\t-status->signal);\n\t}\n\n\tif (status->chains) {\n\t\tlink_sta->rx_stats.chains = status->chains;\n\t\tfor (i = 0; i < ARRAY_SIZE(status->chain_signal); i++) {\n\t\t\tint signal = status->chain_signal[i];\n\n\t\t\tif (!(status->chains & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\tlink_sta->rx_stats.chain_signal_last[i] = signal;\n\t\t\tewma_signal_add(&link_sta->rx_stats_avg.chain_signal[i],\n\t\t\t\t\t-signal);\n\t\t}\n\t}\n\n\tif (ieee80211_is_s1g_beacon(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t \n\tif (!ieee80211_hw_check(&sta->local->hw, AP_LINK_PS) &&\n\t    !ieee80211_has_morefrags(hdr->frame_control) &&\n\t    !is_multicast_ether_addr(hdr->addr1) &&\n\t    (ieee80211_is_mgmt(hdr->frame_control) ||\n\t     ieee80211_is_data(hdr->frame_control)) &&\n\t    !(status->rx_flags & IEEE80211_RX_DEFERRED_RELEASE) &&\n\t    (rx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)) {\n\t\tif (test_sta_flag(sta, WLAN_STA_PS_STA)) {\n\t\t\tif (!ieee80211_has_pm(hdr->frame_control))\n\t\t\t\tsta_ps_end(sta);\n\t\t} else {\n\t\t\tif (ieee80211_has_pm(hdr->frame_control))\n\t\t\t\tsta_ps_start(sta);\n\t\t}\n\t}\n\n\t \n\tif (ieee80211_vif_is_mesh(&rx->sdata->vif))\n\t\tieee80211_mps_rx_h_sta_process(sta, hdr);\n\n\t \n\tif (ieee80211_is_any_nullfunc(hdr->frame_control)) {\n\t\tI802_DEBUG_INC(rx->local->rx_handlers_drop_nullfunc);\n\n\t\t \n\t\tif (ieee80211_has_a4(hdr->frame_control) &&\n\t\t    (rx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t     (rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t      !rx->sdata->u.vlan.sta))) {\n\t\t\tif (!test_and_set_sta_flag(sta, WLAN_STA_4ADDR_EVENT))\n\t\t\t\tcfg80211_rx_unexpected_4addr_frame(\n\t\t\t\t\trx->sdata->dev, sta->sta.addr,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\treturn RX_DROP_M_UNEXPECTED_4ADDR_FRAME;\n\t\t}\n\t\t \n\t\tlink_sta->rx_stats.packets++;\n\t\tdev_kfree_skb(rx->skb);\n\t\treturn RX_QUEUED;\n\t}\n\n\treturn RX_CONTINUE;\n}  \n\nstatic struct ieee80211_key *\nieee80211_rx_get_bigtk(struct ieee80211_rx_data *rx, int idx)\n{\n\tstruct ieee80211_key *key = NULL;\n\tint idx2;\n\n\t \n\n\tif (idx < 0) {\n\t\tidx = NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS;\n\t\tidx2 = idx + 1;\n\t} else {\n\t\tif (idx == NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS)\n\t\t\tidx2 = idx + 1;\n\t\telse\n\t\t\tidx2 = idx - 1;\n\t}\n\n\tif (rx->link_sta)\n\t\tkey = rcu_dereference(rx->link_sta->gtk[idx]);\n\tif (!key)\n\t\tkey = rcu_dereference(rx->link->gtk[idx]);\n\tif (!key && rx->link_sta)\n\t\tkey = rcu_dereference(rx->link_sta->gtk[idx2]);\n\tif (!key)\n\t\tkey = rcu_dereference(rx->link->gtk[idx2]);\n\n\treturn key;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_decrypt(struct ieee80211_rx_data *rx)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tint keyidx;\n\tieee80211_rx_result result = RX_DROP_UNUSABLE;\n\tstruct ieee80211_key *sta_ptk = NULL;\n\tstruct ieee80211_key *ptk_idx = NULL;\n\tint mmie_keyidx = -1;\n\t__le16 fc;\n\n\tif (ieee80211_is_ext(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t \n\n\t \n\trx->key = NULL;\n\tfc = hdr->frame_control;\n\n\tif (rx->sta) {\n\t\tint keyid = rx->sta->ptk_idx;\n\t\tsta_ptk = rcu_dereference(rx->sta->ptk[keyid]);\n\n\t\tif (ieee80211_has_protected(fc) &&\n\t\t    !(status->flag & RX_FLAG_IV_STRIPPED)) {\n\t\t\tkeyid = ieee80211_get_keyid(rx->skb);\n\n\t\t\tif (unlikely(keyid < 0))\n\t\t\t\treturn RX_DROP_UNUSABLE;\n\n\t\t\tptk_idx = rcu_dereference(rx->sta->ptk[keyid]);\n\t\t}\n\t}\n\n\tif (!ieee80211_has_protected(fc))\n\t\tmmie_keyidx = ieee80211_get_mmie_keyidx(rx->skb);\n\n\tif (!is_multicast_ether_addr(hdr->addr1) && sta_ptk) {\n\t\trx->key = ptk_idx ? ptk_idx : sta_ptk;\n\t\tif ((status->flag & RX_FLAG_DECRYPTED) &&\n\t\t    (status->flag & RX_FLAG_IV_STRIPPED))\n\t\t\treturn RX_CONTINUE;\n\t\t \n\t\tif (!ieee80211_has_protected(fc))\n\t\t\treturn RX_CONTINUE;\n\t} else if (mmie_keyidx >= 0 && ieee80211_is_beacon(fc)) {\n\t\t \n\t\tif ((status->flag & RX_FLAG_DECRYPTED) &&\n\t\t    (status->flag & RX_FLAG_IV_STRIPPED))\n\t\t\treturn RX_CONTINUE;\n\n\t\tif (mmie_keyidx < NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS ||\n\t\t    mmie_keyidx >= NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS +\n\t\t\t\t   NUM_DEFAULT_BEACON_KEYS) {\n\t\t\tif (rx->sdata->dev)\n\t\t\t\tcfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,\n\t\t\t\t\t\t\t     skb->data,\n\t\t\t\t\t\t\t     skb->len);\n\t\t\treturn RX_DROP_M_BAD_BCN_KEYIDX;\n\t\t}\n\n\t\trx->key = ieee80211_rx_get_bigtk(rx, mmie_keyidx);\n\t\tif (!rx->key)\n\t\t\treturn RX_CONTINUE;  \n\t} else if (mmie_keyidx >= 0) {\n\t\t \n\t\tif ((status->flag & RX_FLAG_DECRYPTED) &&\n\t\t    (status->flag & RX_FLAG_IV_STRIPPED))\n\t\t\treturn RX_CONTINUE;\n\n\t\tif (mmie_keyidx < NUM_DEFAULT_KEYS ||\n\t\t    mmie_keyidx >= NUM_DEFAULT_KEYS + NUM_DEFAULT_MGMT_KEYS)\n\t\t\treturn RX_DROP_M_BAD_MGMT_KEYIDX;  \n\t\tif (rx->link_sta) {\n\t\t\tif (ieee80211_is_group_privacy_action(skb) &&\n\t\t\t    test_sta_flag(rx->sta, WLAN_STA_MFP))\n\t\t\t\treturn RX_DROP_MONITOR;\n\n\t\t\trx->key = rcu_dereference(rx->link_sta->gtk[mmie_keyidx]);\n\t\t}\n\t\tif (!rx->key)\n\t\t\trx->key = rcu_dereference(rx->link->gtk[mmie_keyidx]);\n\t} else if (!ieee80211_has_protected(fc)) {\n\t\t \n\t\tstruct ieee80211_key *key = NULL;\n\t\tint i;\n\n\t\tif (ieee80211_is_beacon(fc)) {\n\t\t\tkey = ieee80211_rx_get_bigtk(rx, -1);\n\t\t} else if (ieee80211_is_mgmt(fc) &&\n\t\t\t   is_multicast_ether_addr(hdr->addr1)) {\n\t\t\tkey = rcu_dereference(rx->link->default_mgmt_key);\n\t\t} else {\n\t\t\tif (rx->link_sta) {\n\t\t\t\tfor (i = 0; i < NUM_DEFAULT_KEYS; i++) {\n\t\t\t\t\tkey = rcu_dereference(rx->link_sta->gtk[i]);\n\t\t\t\t\tif (key)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!key) {\n\t\t\t\tfor (i = 0; i < NUM_DEFAULT_KEYS; i++) {\n\t\t\t\t\tkey = rcu_dereference(rx->link->gtk[i]);\n\t\t\t\t\tif (key)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (key)\n\t\t\trx->key = key;\n\t\treturn RX_CONTINUE;\n\t} else {\n\t\t \n\t\tif ((status->flag & RX_FLAG_DECRYPTED) &&\n\t\t    (status->flag & RX_FLAG_IV_STRIPPED))\n\t\t\treturn RX_CONTINUE;\n\n\t\tkeyidx = ieee80211_get_keyid(rx->skb);\n\n\t\tif (unlikely(keyidx < 0))\n\t\t\treturn RX_DROP_UNUSABLE;\n\n\t\t \n\t\tif (is_multicast_ether_addr(hdr->addr1) && rx->link_sta)\n\t\t\trx->key = rcu_dereference(rx->link_sta->gtk[keyidx]);\n\n\t\t \n\t\tif (!rx->key) {\n\t\t\tif (is_multicast_ether_addr(hdr->addr1))\n\t\t\t\trx->key = rcu_dereference(rx->link->gtk[keyidx]);\n\t\t\tif (!rx->key)\n\t\t\t\trx->key = rcu_dereference(rx->sdata->keys[keyidx]);\n\n\t\t\t \n\t\t\tif (rx->key &&\n\t\t\t    rx->key->conf.cipher != WLAN_CIPHER_SUITE_WEP40 &&\n\t\t\t    rx->key->conf.cipher != WLAN_CIPHER_SUITE_WEP104 &&\n\t\t\t    !is_multicast_ether_addr(hdr->addr1))\n\t\t\t\trx->key = NULL;\n\t\t}\n\t}\n\n\tif (rx->key) {\n\t\tif (unlikely(rx->key->flags & KEY_FLAG_TAINTED))\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\t \n\t} else {\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\tswitch (rx->key->conf.cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tresult = ieee80211_crypto_wep_decrypt(rx);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tresult = ieee80211_crypto_tkip_decrypt(rx);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tresult = ieee80211_crypto_ccmp_decrypt(\n\t\t\trx, IEEE80211_CCMP_MIC_LEN);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tresult = ieee80211_crypto_ccmp_decrypt(\n\t\t\trx, IEEE80211_CCMP_256_MIC_LEN);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tresult = ieee80211_crypto_aes_cmac_decrypt(rx);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tresult = ieee80211_crypto_aes_cmac_256_decrypt(rx);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tresult = ieee80211_crypto_aes_gmac_decrypt(rx);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tresult = ieee80211_crypto_gcmp_decrypt(rx);\n\t\tbreak;\n\tdefault:\n\t\tresult = RX_DROP_UNUSABLE;\n\t}\n\n\t \n\n\t \n\tstatus->flag |= RX_FLAG_DECRYPTED;\n\n\tif (unlikely(ieee80211_is_beacon(fc) && RX_RES_IS_UNUSABLE(result) &&\n\t\t     rx->sdata->dev))\n\t\tcfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,\n\t\t\t\t\t     skb->data, skb->len);\n\n\treturn result;\n}\n\nvoid ieee80211_init_frag_cache(struct ieee80211_fragment_cache *cache)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cache->entries); i++)\n\t\tskb_queue_head_init(&cache->entries[i].skb_list);\n}\n\nvoid ieee80211_destroy_frag_cache(struct ieee80211_fragment_cache *cache)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cache->entries); i++)\n\t\t__skb_queue_purge(&cache->entries[i].skb_list);\n}\n\nstatic inline struct ieee80211_fragment_entry *\nieee80211_reassemble_add(struct ieee80211_fragment_cache *cache,\n\t\t\t unsigned int frag, unsigned int seq, int rx_queue,\n\t\t\t struct sk_buff **skb)\n{\n\tstruct ieee80211_fragment_entry *entry;\n\n\tentry = &cache->entries[cache->next++];\n\tif (cache->next >= IEEE80211_FRAGMENT_MAX)\n\t\tcache->next = 0;\n\n\t__skb_queue_purge(&entry->skb_list);\n\n\t__skb_queue_tail(&entry->skb_list, *skb);  \n\t*skb = NULL;\n\tentry->first_frag_time = jiffies;\n\tentry->seq = seq;\n\tentry->rx_queue = rx_queue;\n\tentry->last_frag = frag;\n\tentry->check_sequential_pn = false;\n\tentry->extra_len = 0;\n\n\treturn entry;\n}\n\nstatic inline struct ieee80211_fragment_entry *\nieee80211_reassemble_find(struct ieee80211_fragment_cache *cache,\n\t\t\t  unsigned int frag, unsigned int seq,\n\t\t\t  int rx_queue, struct ieee80211_hdr *hdr)\n{\n\tstruct ieee80211_fragment_entry *entry;\n\tint i, idx;\n\n\tidx = cache->next;\n\tfor (i = 0; i < IEEE80211_FRAGMENT_MAX; i++) {\n\t\tstruct ieee80211_hdr *f_hdr;\n\t\tstruct sk_buff *f_skb;\n\n\t\tidx--;\n\t\tif (idx < 0)\n\t\t\tidx = IEEE80211_FRAGMENT_MAX - 1;\n\n\t\tentry = &cache->entries[idx];\n\t\tif (skb_queue_empty(&entry->skb_list) || entry->seq != seq ||\n\t\t    entry->rx_queue != rx_queue ||\n\t\t    entry->last_frag + 1 != frag)\n\t\t\tcontinue;\n\n\t\tf_skb = __skb_peek(&entry->skb_list);\n\t\tf_hdr = (struct ieee80211_hdr *) f_skb->data;\n\n\t\t \n\t\tif (((hdr->frame_control ^ f_hdr->frame_control) &\n\t\t     cpu_to_le16(IEEE80211_FCTL_FTYPE)) ||\n\t\t    !ether_addr_equal(hdr->addr1, f_hdr->addr1) ||\n\t\t    !ether_addr_equal(hdr->addr2, f_hdr->addr2))\n\t\t\tcontinue;\n\n\t\tif (time_after(jiffies, entry->first_frag_time + 2 * HZ)) {\n\t\t\t__skb_queue_purge(&entry->skb_list);\n\t\t\tcontinue;\n\t\t}\n\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool requires_sequential_pn(struct ieee80211_rx_data *rx, __le16 fc)\n{\n\treturn rx->key &&\n\t\t(rx->key->conf.cipher == WLAN_CIPHER_SUITE_CCMP ||\n\t\t rx->key->conf.cipher == WLAN_CIPHER_SUITE_CCMP_256 ||\n\t\t rx->key->conf.cipher == WLAN_CIPHER_SUITE_GCMP ||\n\t\t rx->key->conf.cipher == WLAN_CIPHER_SUITE_GCMP_256) &&\n\t\tieee80211_has_protected(fc);\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_defragment(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_fragment_cache *cache = &rx->sdata->frags;\n\tstruct ieee80211_hdr *hdr;\n\tu16 sc;\n\t__le16 fc;\n\tunsigned int frag, seq;\n\tstruct ieee80211_fragment_entry *entry;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\n\thdr = (struct ieee80211_hdr *)rx->skb->data;\n\tfc = hdr->frame_control;\n\n\tif (ieee80211_is_ctl(fc) || ieee80211_is_ext(fc))\n\t\treturn RX_CONTINUE;\n\n\tsc = le16_to_cpu(hdr->seq_ctrl);\n\tfrag = sc & IEEE80211_SCTL_FRAG;\n\n\tif (rx->sta)\n\t\tcache = &rx->sta->frags;\n\n\tif (likely(!ieee80211_has_morefrags(fc) && frag == 0))\n\t\tgoto out;\n\n\tif (is_multicast_ether_addr(hdr->addr1))\n\t\treturn RX_DROP_MONITOR;\n\n\tI802_DEBUG_INC(rx->local->rx_handlers_fragments);\n\n\tif (skb_linearize(rx->skb))\n\t\treturn RX_DROP_UNUSABLE;\n\n\t \n\thdr = (struct ieee80211_hdr *)rx->skb->data;\n\tseq = (sc & IEEE80211_SCTL_SEQ) >> 4;\n\n\tif (frag == 0) {\n\t\t \n\t\tentry = ieee80211_reassemble_add(cache, frag, seq,\n\t\t\t\t\t\t rx->seqno_idx, &(rx->skb));\n\t\tif (requires_sequential_pn(rx, fc)) {\n\t\t\tint queue = rx->security_idx;\n\n\t\t\t \n\t\t\tentry->check_sequential_pn = true;\n\t\t\tentry->is_protected = true;\n\t\t\tentry->key_color = rx->key->color;\n\t\t\tmemcpy(entry->last_pn,\n\t\t\t       rx->key->u.ccmp.rx_pn[queue],\n\t\t\t       IEEE80211_CCMP_PN_LEN);\n\t\t\tBUILD_BUG_ON(offsetof(struct ieee80211_key,\n\t\t\t\t\t      u.ccmp.rx_pn) !=\n\t\t\t\t     offsetof(struct ieee80211_key,\n\t\t\t\t\t      u.gcmp.rx_pn));\n\t\t\tBUILD_BUG_ON(sizeof(rx->key->u.ccmp.rx_pn[queue]) !=\n\t\t\t\t     sizeof(rx->key->u.gcmp.rx_pn[queue]));\n\t\t\tBUILD_BUG_ON(IEEE80211_CCMP_PN_LEN !=\n\t\t\t\t     IEEE80211_GCMP_PN_LEN);\n\t\t} else if (rx->key &&\n\t\t\t   (ieee80211_has_protected(fc) ||\n\t\t\t    (status->flag & RX_FLAG_DECRYPTED))) {\n\t\t\tentry->is_protected = true;\n\t\t\tentry->key_color = rx->key->color;\n\t\t}\n\t\treturn RX_QUEUED;\n\t}\n\n\t \n\tentry = ieee80211_reassemble_find(cache, frag, seq,\n\t\t\t\t\t  rx->seqno_idx, hdr);\n\tif (!entry) {\n\t\tI802_DEBUG_INC(rx->local->rx_handlers_drop_defrag);\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\t \n\tif (entry->check_sequential_pn) {\n\t\tint i;\n\t\tu8 pn[IEEE80211_CCMP_PN_LEN], *rpn;\n\n\t\tif (!requires_sequential_pn(rx, fc))\n\t\t\treturn RX_DROP_UNUSABLE;\n\n\t\t \n\t\tif (entry->key_color != rx->key->color)\n\t\t\treturn RX_DROP_UNUSABLE;\n\n\t\tmemcpy(pn, entry->last_pn, IEEE80211_CCMP_PN_LEN);\n\t\tfor (i = IEEE80211_CCMP_PN_LEN - 1; i >= 0; i--) {\n\t\t\tpn[i]++;\n\t\t\tif (pn[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\trpn = rx->ccm_gcm.pn;\n\t\tif (memcmp(pn, rpn, IEEE80211_CCMP_PN_LEN))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\tmemcpy(entry->last_pn, pn, IEEE80211_CCMP_PN_LEN);\n\t} else if (entry->is_protected &&\n\t\t   (!rx->key ||\n\t\t    (!ieee80211_has_protected(fc) &&\n\t\t     !(status->flag & RX_FLAG_DECRYPTED)) ||\n\t\t    rx->key->color != entry->key_color)) {\n\t\t \n\t\treturn RX_DROP_UNUSABLE;\n\t} else if (entry->is_protected && rx->key &&\n\t\t   entry->key_color != rx->key->color &&\n\t\t   (status->flag & RX_FLAG_DECRYPTED)) {\n\t\treturn RX_DROP_UNUSABLE;\n\t}\n\n\tskb_pull(rx->skb, ieee80211_hdrlen(fc));\n\t__skb_queue_tail(&entry->skb_list, rx->skb);\n\tentry->last_frag = frag;\n\tentry->extra_len += rx->skb->len;\n\tif (ieee80211_has_morefrags(fc)) {\n\t\trx->skb = NULL;\n\t\treturn RX_QUEUED;\n\t}\n\n\trx->skb = __skb_dequeue(&entry->skb_list);\n\tif (skb_tailroom(rx->skb) < entry->extra_len) {\n\t\tI802_DEBUG_INC(rx->local->rx_expand_skb_head_defrag);\n\t\tif (unlikely(pskb_expand_head(rx->skb, 0, entry->extra_len,\n\t\t\t\t\t      GFP_ATOMIC))) {\n\t\t\tI802_DEBUG_INC(rx->local->rx_handlers_drop_defrag);\n\t\t\t__skb_queue_purge(&entry->skb_list);\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\t}\n\t}\n\twhile ((skb = __skb_dequeue(&entry->skb_list))) {\n\t\tskb_put_data(rx->skb, skb->data, skb->len);\n\t\tdev_kfree_skb(skb);\n\t}\n\n out:\n\tieee80211_led_rx(rx->local);\n\tif (rx->sta)\n\t\trx->link_sta->rx_stats.packets++;\n\treturn RX_CONTINUE;\n}\n\nstatic int ieee80211_802_1x_port_control(struct ieee80211_rx_data *rx)\n{\n\tif (unlikely(!rx->sta || !test_sta_flag(rx->sta, WLAN_STA_AUTHORIZED)))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int ieee80211_drop_unencrypted(struct ieee80211_rx_data *rx, __le16 fc)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\n\t \n\tif (status->flag & RX_FLAG_DECRYPTED)\n\t\treturn 0;\n\n\t \n\tif (unlikely(!ieee80211_has_protected(fc) &&\n\t\t     !ieee80211_is_any_nullfunc(fc) &&\n\t\t     ieee80211_is_data(fc) && rx->key))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\nstatic int ieee80211_drop_unencrypted_mgmt(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\tstruct ieee80211_mgmt *mgmt = (void *)rx->skb->data;\n\t__le16 fc = mgmt->frame_control;\n\n\t \n\tif (status->flag & RX_FLAG_DECRYPTED)\n\t\treturn 0;\n\n\t \n\tif (ieee80211_is_action(fc) &&\n\t    mgmt->u.action.category == WLAN_CATEGORY_PROTECTED_DUAL_OF_ACTION)\n\t\treturn -EACCES;\n\n\tif (rx->sta && test_sta_flag(rx->sta, WLAN_STA_MFP)) {\n\t\tif (unlikely(!ieee80211_has_protected(fc) &&\n\t\t\t     ieee80211_is_unicast_robust_mgmt_frame(rx->skb))) {\n\t\t\tif (ieee80211_is_deauth(fc) ||\n\t\t\t    ieee80211_is_disassoc(fc)) {\n\t\t\t\t \n\t\t\t\tif (!rx->key)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tcfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,\n\t\t\t\t\t\t\t     rx->skb->data,\n\t\t\t\t\t\t\t     rx->skb->len);\n\t\t\t}\n\t\t\treturn -EACCES;\n\t\t}\n\t\t \n\t\tif (unlikely(ieee80211_is_multicast_robust_mgmt_frame(rx->skb) &&\n\t\t\t     ieee80211_get_mmie_keyidx(rx->skb) < 0)) {\n\t\t\tif (ieee80211_is_deauth(fc) ||\n\t\t\t    ieee80211_is_disassoc(fc))\n\t\t\t\tcfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,\n\t\t\t\t\t\t\t     rx->skb->data,\n\t\t\t\t\t\t\t     rx->skb->len);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (unlikely(ieee80211_is_beacon(fc) && rx->key &&\n\t\t\t     ieee80211_get_mmie_keyidx(rx->skb) < 0)) {\n\t\t\tcfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,\n\t\t\t\t\t\t     rx->skb->data,\n\t\t\t\t\t\t     rx->skb->len);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t \n\t\tif (unlikely(ieee80211_is_action(fc) && !rx->key &&\n\t\t\t     ieee80211_is_robust_mgmt_frame(rx->skb)))\n\t\t\treturn -EACCES;\n\n\t\t \n\t\tif (is_unicast_ether_addr(mgmt->da) &&\n\t\t    ieee80211_is_protected_dual_of_public_action(rx->skb))\n\t\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\nstatic int\n__ieee80211_data_to_8023(struct ieee80211_rx_data *rx, bool *port_control)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tbool check_port_control = false;\n\tstruct ethhdr *ehdr;\n\tint ret;\n\n\t*port_control = false;\n\tif (ieee80211_has_a4(hdr->frame_control) &&\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN && !sdata->u.vlan.sta)\n\t\treturn -1;\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    !!sdata->u.mgd.use_4addr != !!ieee80211_has_a4(hdr->frame_control)) {\n\n\t\tif (!sdata->u.mgd.use_4addr)\n\t\t\treturn -1;\n\t\telse if (!ether_addr_equal(hdr->addr1, sdata->vif.addr))\n\t\t\tcheck_port_control = true;\n\t}\n\n\tif (is_multicast_ether_addr(hdr->addr1) &&\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN && sdata->u.vlan.sta)\n\t\treturn -1;\n\n\tret = ieee80211_data_to_8023(rx->skb, sdata->vif.addr, sdata->vif.type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tehdr = (struct ethhdr *) rx->skb->data;\n\tif (ehdr->h_proto == rx->sdata->control_port_protocol)\n\t\t*port_control = true;\n\telse if (check_port_control)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nbool ieee80211_is_our_addr(struct ieee80211_sub_if_data *sdata,\n\t\t\t   const u8 *addr, int *out_link_id)\n{\n\tunsigned int link_id;\n\n\t \n\tif (ether_addr_equal(sdata->vif.addr, addr))\n\t\treturn true;\n\n\tif (!ieee80211_vif_is_mld(&sdata->vif))\n\t\treturn false;\n\n\tfor (link_id = 0; link_id < ARRAY_SIZE(sdata->vif.link_conf); link_id++) {\n\t\tstruct ieee80211_bss_conf *conf;\n\n\t\tconf = rcu_dereference(sdata->vif.link_conf[link_id]);\n\n\t\tif (!conf)\n\t\t\tcontinue;\n\t\tif (ether_addr_equal(conf->addr, addr)) {\n\t\t\tif (out_link_id)\n\t\t\t\t*out_link_id = link_id;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic bool ieee80211_frame_allowed(struct ieee80211_rx_data *rx, __le16 fc)\n{\n\tstatic const u8 pae_group_addr[ETH_ALEN] __aligned(2)\n\t\t= { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x03 };\n\tstruct ethhdr *ehdr = (struct ethhdr *) rx->skb->data;\n\n\t \n\tif (unlikely(ehdr->h_proto == rx->sdata->control_port_protocol))\n\t\treturn ieee80211_is_our_addr(rx->sdata, ehdr->h_dest, NULL) ||\n\t\t       ether_addr_equal(ehdr->h_dest, pae_group_addr);\n\n\tif (ieee80211_802_1x_port_control(rx) ||\n\t    ieee80211_drop_unencrypted(rx, fc))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ieee80211_deliver_skb_to_local_stack(struct sk_buff *skb,\n\t\t\t\t\t\t struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct net_device *dev = sdata->dev;\n\n\tif (unlikely((skb->protocol == sdata->control_port_protocol ||\n\t\t     (skb->protocol == cpu_to_be16(ETH_P_PREAUTH) &&\n\t\t      !sdata->control_port_no_preauth)) &&\n\t\t     sdata->control_port_over_nl80211)) {\n\t\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\t\tbool noencrypt = !(status->flag & RX_FLAG_DECRYPTED);\n\n\t\tcfg80211_rx_control_port(dev, skb, noencrypt, rx->link_id);\n\t\tdev_kfree_skb(skb);\n\t} else {\n\t\tstruct ethhdr *ehdr = (void *)skb_mac_header(skb);\n\n\t\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\t\t \n\t\tif (unlikely(skb->protocol == sdata->control_port_protocol &&\n\t\t\t     !ether_addr_equal(ehdr->h_dest, sdata->vif.addr)))\n\t\t\tether_addr_copy(ehdr->h_dest, sdata->vif.addr);\n\n\t\t \n\t\tif (rx->list)\n\t\t\tlist_add_tail(&skb->list, rx->list);\n\t\telse\n\t\t\tnetif_receive_skb(skb);\n\t}\n}\n\n \nstatic void\nieee80211_deliver_skb(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct net_device *dev = sdata->dev;\n\tstruct sk_buff *skb, *xmit_skb;\n\tstruct ethhdr *ehdr = (struct ethhdr *) rx->skb->data;\n\tstruct sta_info *dsta;\n\n\tskb = rx->skb;\n\txmit_skb = NULL;\n\n\tdev_sw_netstats_rx_add(dev, skb->len);\n\n\tif (rx->sta) {\n\t\t \n\t\tu64_stats_update_begin(&rx->link_sta->rx_stats.syncp);\n\t\trx->link_sta->rx_stats.msdu[rx->seqno_idx]++;\n\t\tu64_stats_update_end(&rx->link_sta->rx_stats.syncp);\n\t}\n\n\tif ((sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&\n\t    !(sdata->flags & IEEE80211_SDATA_DONT_BRIDGE_PACKETS) &&\n\t    ehdr->h_proto != rx->sdata->control_port_protocol &&\n\t    (sdata->vif.type != NL80211_IFTYPE_AP_VLAN || !sdata->u.vlan.sta)) {\n\t\tif (is_multicast_ether_addr(ehdr->h_dest) &&\n\t\t    ieee80211_vif_get_num_mcast_if(sdata) != 0) {\n\t\t\t \n\t\t\txmit_skb = skb_copy(skb, GFP_ATOMIC);\n\t\t\tif (!xmit_skb)\n\t\t\t\tnet_info_ratelimited(\"%s: failed to clone multicast frame\\n\",\n\t\t\t\t\t\t    dev->name);\n\t\t} else if (!is_multicast_ether_addr(ehdr->h_dest) &&\n\t\t\t   !ether_addr_equal(ehdr->h_dest, ehdr->h_source)) {\n\t\t\tdsta = sta_info_get(sdata, ehdr->h_dest);\n\t\t\tif (dsta) {\n\t\t\t\t \n\t\t\t\txmit_skb = skb;\n\t\t\t\tskb = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tif (skb) {\n\t\t \n\t\tint align;\n\n\t\talign = (unsigned long)(skb->data + sizeof(struct ethhdr)) & 3;\n\t\tif (align) {\n\t\t\tif (WARN_ON(skb_headroom(skb) < 3)) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tskb = NULL;\n\t\t\t} else {\n\t\t\t\tu8 *data = skb->data;\n\t\t\t\tsize_t len = skb_headlen(skb);\n\t\t\t\tskb->data -= align;\n\t\t\t\tmemmove(skb->data, data, len);\n\t\t\t\tskb_set_tail_pointer(skb, len);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (skb) {\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tieee80211_deliver_skb_to_local_stack(skb, rx);\n\t}\n\n\tif (xmit_skb) {\n\t\t \n\t\txmit_skb->priority += 256;\n\t\txmit_skb->protocol = htons(ETH_P_802_3);\n\t\tskb_reset_network_header(xmit_skb);\n\t\tskb_reset_mac_header(xmit_skb);\n\t\tdev_queue_xmit(xmit_skb);\n\t}\n}\n\n#ifdef CONFIG_MAC80211_MESH\nstatic bool\nieee80211_rx_mesh_fast_forward(struct ieee80211_sub_if_data *sdata,\n\t\t\t       struct sk_buff *skb, int hdrlen)\n{\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct ieee80211_mesh_fast_tx *entry = NULL;\n\tstruct ieee80211s_hdr *mesh_hdr;\n\tstruct tid_ampdu_tx *tid_tx;\n\tstruct sta_info *sta;\n\tstruct ethhdr eth;\n\tu8 tid;\n\n\tmesh_hdr = (struct ieee80211s_hdr *)(skb->data + sizeof(eth));\n\tif ((mesh_hdr->flags & MESH_FLAGS_AE) == MESH_FLAGS_AE_A5_A6)\n\t\tentry = mesh_fast_tx_get(sdata, mesh_hdr->eaddr1);\n\telse if (!(mesh_hdr->flags & MESH_FLAGS_AE))\n\t\tentry = mesh_fast_tx_get(sdata, skb->data);\n\tif (!entry)\n\t\treturn false;\n\n\tsta = rcu_dereference(entry->mpath->next_hop);\n\tif (!sta)\n\t\treturn false;\n\n\tif (skb_linearize(skb))\n\t\treturn false;\n\n\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\ttid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\n\tif (tid_tx) {\n\t\tif (!test_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state))\n\t\t\treturn false;\n\n\t\tif (tid_tx->timeout)\n\t\t\ttid_tx->last_tx = jiffies;\n\t}\n\n\tieee80211_aggr_check(sdata, sta, skb);\n\n\tif (ieee80211_get_8023_tunnel_proto(skb->data + hdrlen,\n\t\t\t\t\t    &skb->protocol))\n\t\thdrlen += ETH_ALEN;\n\telse\n\t\tskb->protocol = htons(skb->len - hdrlen);\n\tskb_set_network_header(skb, hdrlen + 2);\n\n\tskb->dev = sdata->dev;\n\tmemcpy(&eth, skb->data, ETH_HLEN - 2);\n\tskb_pull(skb, 2);\n\t__ieee80211_xmit_fast(sdata, sta, &entry->fast_tx, skb, tid_tx,\n\t\t\t      eth.h_dest, eth.h_source);\n\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_unicast);\n\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_frames);\n\n\treturn true;\n}\n#endif\n\nstatic ieee80211_rx_result\nieee80211_rx_mesh_data(struct ieee80211_sub_if_data *sdata, struct sta_info *sta,\n\t\t       struct sk_buff *skb)\n{\n#ifdef CONFIG_MAC80211_MESH\n\tstruct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;\n\tstruct ieee80211_local *local = sdata->local;\n\tuint16_t fc = IEEE80211_FTYPE_DATA | IEEE80211_STYPE_QOS_DATA;\n\tstruct ieee80211_hdr hdr = {\n\t\t.frame_control = cpu_to_le16(fc)\n\t};\n\tstruct ieee80211_hdr *fwd_hdr;\n\tstruct ieee80211s_hdr *mesh_hdr;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *fwd_skb;\n\tstruct ethhdr *eth;\n\tbool multicast;\n\tint tailroom = 0;\n\tint hdrlen, mesh_hdrlen;\n\tu8 *qos;\n\n\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\treturn RX_CONTINUE;\n\n\tif (!pskb_may_pull(skb, sizeof(*eth) + 6))\n\t\treturn RX_DROP_MONITOR;\n\n\tmesh_hdr = (struct ieee80211s_hdr *)(skb->data + sizeof(*eth));\n\tmesh_hdrlen = ieee80211_get_mesh_hdrlen(mesh_hdr);\n\n\tif (!pskb_may_pull(skb, sizeof(*eth) + mesh_hdrlen))\n\t\treturn RX_DROP_MONITOR;\n\n\teth = (struct ethhdr *)skb->data;\n\tmulticast = is_multicast_ether_addr(eth->h_dest);\n\n\tmesh_hdr = (struct ieee80211s_hdr *)(eth + 1);\n\tif (!mesh_hdr->ttl)\n\t\treturn RX_DROP_MONITOR;\n\n\t \n\tif (is_multicast_ether_addr(eth->h_dest) &&\n\t    mesh_rmc_check(sdata, eth->h_source, mesh_hdr))\n\t\treturn RX_DROP_MONITOR;\n\n\t \n\tif (sdata->crypto_tx_tailroom_needed_cnt)\n\t\ttailroom = IEEE80211_ENCRYPT_TAILROOM;\n\n\tif (mesh_hdr->flags & MESH_FLAGS_AE) {\n\t\tstruct mesh_path *mppath;\n\t\tchar *proxied_addr;\n\t\tbool update = false;\n\n\t\tif (multicast)\n\t\t\tproxied_addr = mesh_hdr->eaddr1;\n\t\telse if ((mesh_hdr->flags & MESH_FLAGS_AE) == MESH_FLAGS_AE_A5_A6)\n\t\t\t \n\t\t\tproxied_addr = mesh_hdr->eaddr2;\n\t\telse\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\trcu_read_lock();\n\t\tmppath = mpp_path_lookup(sdata, proxied_addr);\n\t\tif (!mppath) {\n\t\t\tmpp_path_add(sdata, proxied_addr, eth->h_source);\n\t\t} else {\n\t\t\tspin_lock_bh(&mppath->state_lock);\n\t\t\tif (!ether_addr_equal(mppath->mpp, eth->h_source)) {\n\t\t\t\tmemcpy(mppath->mpp, eth->h_source, ETH_ALEN);\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t\tmppath->exp_time = jiffies;\n\t\t\tspin_unlock_bh(&mppath->state_lock);\n\t\t}\n\n\t\t \n\t\tif (update)\n\t\t\tmesh_fast_tx_flush_addr(sdata, proxied_addr);\n\n\t\trcu_read_unlock();\n\t}\n\n\t \n\tif (ether_addr_equal(sdata->vif.addr, eth->h_dest))\n\t\tgoto rx_accept;\n\n\tif (!--mesh_hdr->ttl) {\n\t\tif (multicast)\n\t\t\tgoto rx_accept;\n\n\t\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh, dropped_frames_ttl);\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\tif (!ifmsh->mshcfg.dot11MeshForwarding) {\n\t\tif (is_multicast_ether_addr(eth->h_dest))\n\t\t\tgoto rx_accept;\n\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\tskb_set_queue_mapping(skb, ieee802_1d_to_ac[skb->priority]);\n\n\tif (!multicast &&\n\t    ieee80211_rx_mesh_fast_forward(sdata, skb, mesh_hdrlen))\n\t\treturn RX_QUEUED;\n\n\tieee80211_fill_mesh_addresses(&hdr, &hdr.frame_control,\n\t\t\t\t      eth->h_dest, eth->h_source);\n\thdrlen = ieee80211_hdrlen(hdr.frame_control);\n\tif (multicast) {\n\t\tint extra_head = sizeof(struct ieee80211_hdr) - sizeof(*eth);\n\n\t\tfwd_skb = skb_copy_expand(skb, local->tx_headroom + extra_head +\n\t\t\t\t\t       IEEE80211_ENCRYPT_HEADROOM,\n\t\t\t\t\t  tailroom, GFP_ATOMIC);\n\t\tif (!fwd_skb)\n\t\t\tgoto rx_accept;\n\t} else {\n\t\tfwd_skb = skb;\n\t\tskb = NULL;\n\n\t\tif (skb_cow_head(fwd_skb, hdrlen - sizeof(struct ethhdr)))\n\t\t\treturn RX_DROP_UNUSABLE;\n\n\t\tif (skb_linearize(fwd_skb))\n\t\t\treturn RX_DROP_UNUSABLE;\n\t}\n\n\tfwd_hdr = skb_push(fwd_skb, hdrlen - sizeof(struct ethhdr));\n\tmemcpy(fwd_hdr, &hdr, hdrlen - 2);\n\tqos = ieee80211_get_qos_ctl(fwd_hdr);\n\tqos[0] = qos[1] = 0;\n\n\tskb_reset_mac_header(fwd_skb);\n\thdrlen += mesh_hdrlen;\n\tif (ieee80211_get_8023_tunnel_proto(fwd_skb->data + hdrlen,\n\t\t\t\t\t    &fwd_skb->protocol))\n\t\thdrlen += ETH_ALEN;\n\telse\n\t\tfwd_skb->protocol = htons(fwd_skb->len - hdrlen);\n\tskb_set_network_header(fwd_skb, hdrlen + 2);\n\n\tinfo = IEEE80211_SKB_CB(fwd_skb);\n\tmemset(info, 0, sizeof(*info));\n\tinfo->control.flags |= IEEE80211_TX_INTCFL_NEED_TXPROCESSING;\n\tinfo->control.vif = &sdata->vif;\n\tinfo->control.jiffies = jiffies;\n\tfwd_skb->dev = sdata->dev;\n\tif (multicast) {\n\t\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_mcast);\n\t\tmemcpy(fwd_hdr->addr2, sdata->vif.addr, ETH_ALEN);\n\t\t \n\t\tieee80211_mps_set_frame_flags(sdata, NULL, fwd_hdr);\n\t} else if (!mesh_nexthop_lookup(sdata, fwd_skb)) {\n\t\t \n\t\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_unicast);\n\t} else {\n\t\t \n\t\tif (sta)\n\t\t\tmesh_path_error_tx(sdata, ifmsh->mshcfg.element_ttl,\n\t\t\t\t\t   hdr.addr3, 0,\n\t\t\t\t\t   WLAN_REASON_MESH_PATH_NOFORWARD,\n\t\t\t\t\t   sta->sta.addr);\n\t\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh, dropped_frames_no_route);\n\t\tkfree_skb(fwd_skb);\n\t\tgoto rx_accept;\n\t}\n\n\tIEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_frames);\n\tieee80211_add_pending_skb(local, fwd_skb);\n\nrx_accept:\n\tif (!skb)\n\t\treturn RX_QUEUED;\n\n\tieee80211_strip_8023_mesh_hdr(skb);\n#endif\n\n\treturn RX_CONTINUE;\n}\n\nstatic ieee80211_rx_result debug_noinline\n__ieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx, u8 data_offset)\n{\n\tstruct net_device *dev = rx->sdata->dev;\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\tstruct sk_buff_head frame_list;\n\tieee80211_rx_result res;\n\tstruct ethhdr ethhdr;\n\tconst u8 *check_da = ethhdr.h_dest, *check_sa = ethhdr.h_source;\n\n\tif (unlikely(ieee80211_has_a4(hdr->frame_control))) {\n\t\tcheck_da = NULL;\n\t\tcheck_sa = NULL;\n\t} else switch (rx->sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t\tcheck_da = NULL;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tif (!rx->sta ||\n\t\t\t    !test_sta_flag(rx->sta, WLAN_STA_TDLS_PEER))\n\t\t\t\tcheck_sa = NULL;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tcheck_sa = NULL;\n\t\t\tcheck_da = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tskb->dev = dev;\n\t__skb_queue_head_init(&frame_list);\n\n\tif (ieee80211_data_to_8023_exthdr(skb, &ethhdr,\n\t\t\t\t\t  rx->sdata->vif.addr,\n\t\t\t\t\t  rx->sdata->vif.type,\n\t\t\t\t\t  data_offset, true))\n\t\treturn RX_DROP_UNUSABLE;\n\n\tif (rx->sta->amsdu_mesh_control < 0) {\n\t\ts8 valid = -1;\n\t\tint i;\n\n\t\tfor (i = 0; i <= 2; i++) {\n\t\t\tif (!ieee80211_is_valid_amsdu(skb, i))\n\t\t\t\tcontinue;\n\n\t\t\tif (valid >= 0) {\n\t\t\t\t \n\t\t\t\tvalid = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvalid = i;\n\t\t}\n\n\t\trx->sta->amsdu_mesh_control = valid;\n\t}\n\n\tieee80211_amsdu_to_8023s(skb, &frame_list, dev->dev_addr,\n\t\t\t\t rx->sdata->vif.type,\n\t\t\t\t rx->local->hw.extra_tx_headroom,\n\t\t\t\t check_da, check_sa,\n\t\t\t\t rx->sta->amsdu_mesh_control);\n\n\twhile (!skb_queue_empty(&frame_list)) {\n\t\trx->skb = __skb_dequeue(&frame_list);\n\n\t\tres = ieee80211_rx_mesh_data(rx->sdata, rx->sta, rx->skb);\n\t\tswitch (res) {\n\t\tcase RX_QUEUED:\n\t\t\tcontinue;\n\t\tcase RX_CONTINUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (!ieee80211_frame_allowed(rx, fc))\n\t\t\tgoto free;\n\n\t\tieee80211_deliver_skb(rx);\n\t\tcontinue;\n\nfree:\n\t\tdev_kfree_skb(rx->skb);\n\t}\n\n\treturn RX_QUEUED;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\n\tif (!(status->rx_flags & IEEE80211_RX_AMSDU))\n\t\treturn RX_CONTINUE;\n\n\tif (unlikely(!ieee80211_is_data(fc)))\n\t\treturn RX_CONTINUE;\n\n\tif (unlikely(!ieee80211_is_data_present(fc)))\n\t\treturn RX_DROP_MONITOR;\n\n\tif (unlikely(ieee80211_has_a4(hdr->frame_control))) {\n\t\tswitch (rx->sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t\tif (!rx->sdata->u.vlan.sta)\n\t\t\t\treturn RX_DROP_UNUSABLE;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tif (!rx->sdata->u.mgd.use_4addr)\n\t\t\t\treturn RX_DROP_UNUSABLE;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\t}\n\t}\n\n\tif (is_multicast_ether_addr(hdr->addr1) || !rx->sta)\n\t\treturn RX_DROP_UNUSABLE;\n\n\tif (rx->key) {\n\t\t \n\t\tswitch (rx->key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\treturn RX_DROP_UNUSABLE;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn __ieee80211_rx_h_amsdu(rx, 0);\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_data(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_local *local = rx->local;\n\tstruct net_device *dev = sdata->dev;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\t__le16 fc = hdr->frame_control;\n\tieee80211_rx_result res;\n\tbool port_control;\n\tint err;\n\n\tif (unlikely(!ieee80211_is_data(hdr->frame_control)))\n\t\treturn RX_CONTINUE;\n\n\tif (unlikely(!ieee80211_is_data_present(hdr->frame_control)))\n\t\treturn RX_DROP_MONITOR;\n\n\t \n\tif (ieee80211_has_a4(hdr->frame_control) &&\n\t    sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tif (rx->sta &&\n\t\t    !test_and_set_sta_flag(rx->sta, WLAN_STA_4ADDR_EVENT))\n\t\t\tcfg80211_rx_unexpected_4addr_frame(\n\t\t\t\trx->sdata->dev, rx->sta->sta.addr, GFP_ATOMIC);\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\terr = __ieee80211_data_to_8023(rx, &port_control);\n\tif (unlikely(err))\n\t\treturn RX_DROP_UNUSABLE;\n\n\tres = ieee80211_rx_mesh_data(rx->sdata, rx->sta, rx->skb);\n\tif (res != RX_CONTINUE)\n\t\treturn res;\n\n\tif (!ieee80211_frame_allowed(rx, fc))\n\t\treturn RX_DROP_MONITOR;\n\n\t \n\tif (unlikely(((struct ethhdr *)rx->skb->data)->h_proto ==\n\t\t\t\t\t\tcpu_to_be16(ETH_P_TDLS))) {\n\t\tstruct ieee80211_tdls_data *tf = (void *)rx->skb->data;\n\n\t\tif (pskb_may_pull(rx->skb,\n\t\t\t\t  offsetof(struct ieee80211_tdls_data, u)) &&\n\t\t    tf->payload_type == WLAN_TDLS_SNAP_RFTYPE &&\n\t\t    tf->category == WLAN_CATEGORY_TDLS &&\n\t\t    (tf->action_code == WLAN_TDLS_CHANNEL_SWITCH_REQUEST ||\n\t\t     tf->action_code == WLAN_TDLS_CHANNEL_SWITCH_RESPONSE)) {\n\t\t\trx->skb->protocol = cpu_to_be16(ETH_P_TDLS);\n\t\t\t__ieee80211_queue_skb_to_iface(sdata, rx->link_id,\n\t\t\t\t\t\t       rx->sta, rx->skb);\n\t\t\treturn RX_QUEUED;\n\t\t}\n\t}\n\n\tif (rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t    unlikely(port_control) && sdata->bss) {\n\t\tsdata = container_of(sdata->bss, struct ieee80211_sub_if_data,\n\t\t\t\t     u.ap);\n\t\tdev = sdata->dev;\n\t\trx->sdata = sdata;\n\t}\n\n\trx->skb->dev = dev;\n\n\tif (!ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS) &&\n\t    local->ps_sdata && local->hw.conf.dynamic_ps_timeout > 0 &&\n\t    !is_multicast_ether_addr(\n\t\t    ((struct ethhdr *)rx->skb->data)->h_dest) &&\n\t    (!local->scanning &&\n\t     !test_bit(SDATA_STATE_OFFCHANNEL, &sdata->state)))\n\t\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t\t  msecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\n\n\tieee80211_deliver_skb(rx);\n\n\treturn RX_QUEUED;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_ctrl(struct ieee80211_rx_data *rx, struct sk_buff_head *frames)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_bar *bar = (struct ieee80211_bar *)skb->data;\n\tstruct tid_ampdu_rx *tid_agg_rx;\n\tu16 start_seq_num;\n\tu16 tid;\n\n\tif (likely(!ieee80211_is_ctl(bar->frame_control)))\n\t\treturn RX_CONTINUE;\n\n\tif (ieee80211_is_back_req(bar->frame_control)) {\n\t\tstruct {\n\t\t\t__le16 control, start_seq_num;\n\t\t} __packed bar_data;\n\t\tstruct ieee80211_event event = {\n\t\t\t.type = BAR_RX_EVENT,\n\t\t};\n\n\t\tif (!rx->sta)\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\tif (skb_copy_bits(skb, offsetof(struct ieee80211_bar, control),\n\t\t\t\t  &bar_data, sizeof(bar_data)))\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\ttid = le16_to_cpu(bar_data.control) >> 12;\n\n\t\tif (!test_bit(tid, rx->sta->ampdu_mlme.agg_session_valid) &&\n\t\t    !test_and_set_bit(tid, rx->sta->ampdu_mlme.unexpected_agg))\n\t\t\tieee80211_send_delba(rx->sdata, rx->sta->sta.addr, tid,\n\t\t\t\t\t     WLAN_BACK_RECIPIENT,\n\t\t\t\t\t     WLAN_REASON_QSTA_REQUIRE_SETUP);\n\n\t\ttid_agg_rx = rcu_dereference(rx->sta->ampdu_mlme.tid_rx[tid]);\n\t\tif (!tid_agg_rx)\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\tstart_seq_num = le16_to_cpu(bar_data.start_seq_num) >> 4;\n\t\tevent.u.ba.tid = tid;\n\t\tevent.u.ba.ssn = start_seq_num;\n\t\tevent.u.ba.sta = &rx->sta->sta;\n\n\t\t \n\t\tif (tid_agg_rx->timeout)\n\t\t\tmod_timer(&tid_agg_rx->session_timer,\n\t\t\t\t  TU_TO_EXP_TIME(tid_agg_rx->timeout));\n\n\t\tspin_lock(&tid_agg_rx->reorder_lock);\n\t\t \n\t\tieee80211_release_reorder_frames(rx->sdata, tid_agg_rx,\n\t\t\t\t\t\t start_seq_num, frames);\n\t\tspin_unlock(&tid_agg_rx->reorder_lock);\n\n\t\tdrv_event_callback(rx->local, rx->sdata, &event);\n\n\t\tkfree_skb(skb);\n\t\treturn RX_QUEUED;\n\t}\n\n\t \n\treturn RX_DROP_MONITOR;\n}\n\nstatic void ieee80211_process_sa_query_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct ieee80211_mgmt *mgmt,\n\t\t\t\t\t   size_t len)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *resp;\n\n\tif (!ether_addr_equal(mgmt->da, sdata->vif.addr)) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (!ether_addr_equal(mgmt->sa, sdata->deflink.u.mgd.bssid) ||\n\t    !ether_addr_equal(mgmt->bssid, sdata->deflink.u.mgd.bssid)) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (len < 24 + 1 + sizeof(resp->u.action.u.sa_query)) {\n\t\t \n\t\treturn;\n\t}\n\n\tskb = dev_alloc_skb(sizeof(*resp) + local->hw.extra_tx_headroom);\n\tif (skb == NULL)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\tresp = skb_put_zero(skb, 24);\n\tmemcpy(resp->da, mgmt->sa, ETH_ALEN);\n\tmemcpy(resp->sa, sdata->vif.addr, ETH_ALEN);\n\tmemcpy(resp->bssid, sdata->deflink.u.mgd.bssid, ETH_ALEN);\n\tresp->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\tskb_put(skb, 1 + sizeof(resp->u.action.u.sa_query));\n\tresp->u.action.category = WLAN_CATEGORY_SA_QUERY;\n\tresp->u.action.u.sa_query.action = WLAN_ACTION_SA_QUERY_RESPONSE;\n\tmemcpy(resp->u.action.u.sa_query.trans_id,\n\t       mgmt->u.action.u.sa_query.trans_id,\n\t       WLAN_SA_QUERY_TR_ID_LEN);\n\n\tieee80211_tx_skb(sdata, skb);\n}\n\nstatic void\nieee80211_rx_check_bss_color_collision(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)rx->skb->data;\n\tconst struct element *ie;\n\tsize_t baselen;\n\n\tif (!wiphy_ext_feature_isset(rx->local->hw.wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BSS_COLOR))\n\t\treturn;\n\n\tif (ieee80211_hw_check(&rx->local->hw, DETECTS_COLOR_COLLISION))\n\t\treturn;\n\n\tif (rx->sdata->vif.bss_conf.csa_active)\n\t\treturn;\n\n\tbaselen = mgmt->u.beacon.variable - rx->skb->data;\n\tif (baselen > rx->skb->len)\n\t\treturn;\n\n\tie = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_OPERATION,\n\t\t\t\t    mgmt->u.beacon.variable,\n\t\t\t\t    rx->skb->len - baselen);\n\tif (ie && ie->datalen >= sizeof(struct ieee80211_he_operation) &&\n\t    ie->datalen >= ieee80211_he_oper_size(ie->data + 1)) {\n\t\tstruct ieee80211_bss_conf *bss_conf = &rx->sdata->vif.bss_conf;\n\t\tconst struct ieee80211_he_operation *he_oper;\n\t\tu8 color;\n\n\t\the_oper = (void *)(ie->data + 1);\n\t\tif (le32_get_bits(he_oper->he_oper_params,\n\t\t\t\t  IEEE80211_HE_OPERATION_BSS_COLOR_DISABLED))\n\t\t\treturn;\n\n\t\tcolor = le32_get_bits(he_oper->he_oper_params,\n\t\t\t\t      IEEE80211_HE_OPERATION_BSS_COLOR_MASK);\n\t\tif (color == bss_conf->he_bss_color.color)\n\t\t\tieee80211_obss_color_collision_notify(&rx->sdata->vif,\n\t\t\t\t\t\t\t      BIT_ULL(color),\n\t\t\t\t\t\t\t      GFP_ATOMIC);\n\t}\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_mgmt_check(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) rx->skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\n\tif (ieee80211_is_s1g_beacon(mgmt->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t \n\tif (rx->skb->len < 24)\n\t\treturn RX_DROP_MONITOR;\n\n\tif (!ieee80211_is_mgmt(mgmt->frame_control))\n\t\treturn RX_DROP_MONITOR;\n\n\t \n\tif (ieee80211_is_action(mgmt->frame_control) &&\n\t    rx->skb->len < IEEE80211_MIN_ACTION_SIZE)\n\t\treturn RX_DROP_UNUSABLE;\n\n\tif (rx->sdata->vif.type == NL80211_IFTYPE_AP &&\n\t    ieee80211_is_beacon(mgmt->frame_control) &&\n\t    !(rx->flags & IEEE80211_RX_BEACON_REPORTED)) {\n\t\tint sig = 0;\n\n\t\t \n\t\tieee80211_rx_check_bss_color_collision(rx);\n\n\t\tif (ieee80211_hw_check(&rx->local->hw, SIGNAL_DBM) &&\n\t\t    !(status->flag & RX_FLAG_NO_SIGNAL_VAL))\n\t\t\tsig = status->signal;\n\n\t\tcfg80211_report_obss_beacon_khz(rx->local->hw.wiphy,\n\t\t\t\t\t\trx->skb->data, rx->skb->len,\n\t\t\t\t\t\tieee80211_rx_status_to_khz(status),\n\t\t\t\t\t\tsig);\n\t\trx->flags |= IEEE80211_RX_BEACON_REPORTED;\n\t}\n\n\tif (ieee80211_drop_unencrypted_mgmt(rx))\n\t\treturn RX_DROP_UNUSABLE;\n\n\treturn RX_CONTINUE;\n}\n\nstatic bool\nieee80211_process_rx_twt_action(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)rx->skb->data;\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\n\t \n\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\treturn false;\n\n\tif (!rx->local->ops->add_twt_setup)\n\t\treturn false;\n\n\tif (!sdata->vif.bss_conf.twt_responder)\n\t\treturn false;\n\n\tif (!rx->sta)\n\t\treturn false;\n\n\tswitch (mgmt->u.action.u.s1g.action_code) {\n\tcase WLAN_S1G_TWT_SETUP: {\n\t\tstruct ieee80211_twt_setup *twt;\n\n\t\tif (rx->skb->len < IEEE80211_MIN_ACTION_SIZE +\n\t\t\t\t   1 +  \n\t\t\t\t   sizeof(struct ieee80211_twt_setup) +\n\t\t\t\t   2  )\n\t\t\tbreak;\n\n\t\ttwt = (void *)mgmt->u.action.u.s1g.variable;\n\t\tif (twt->element_id != WLAN_EID_S1G_TWT)\n\t\t\tbreak;\n\n\t\tif (rx->skb->len < IEEE80211_MIN_ACTION_SIZE +\n\t\t\t\t   4 +  \n\t\t\t\t   twt->length)\n\t\t\tbreak;\n\n\t\treturn true;  \n\t}\n\tcase WLAN_S1G_TWT_TEARDOWN:\n\t\tif (rx->skb->len < IEEE80211_MIN_ACTION_SIZE + 2)\n\t\t\tbreak;\n\n\t\treturn true;  \n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_action(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_local *local = rx->local;\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) rx->skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\tint len = rx->skb->len;\n\n\tif (!ieee80211_is_action(mgmt->frame_control))\n\t\treturn RX_CONTINUE;\n\n\tif (!rx->sta && mgmt->u.action.category != WLAN_CATEGORY_PUBLIC &&\n\t    mgmt->u.action.category != WLAN_CATEGORY_SELF_PROTECTED &&\n\t    mgmt->u.action.category != WLAN_CATEGORY_SPECTRUM_MGMT)\n\t\treturn RX_DROP_UNUSABLE;\n\n\tswitch (mgmt->u.action.category) {\n\tcase WLAN_CATEGORY_HT:\n\t\t \n\t\tif (!rx->link_sta->pub->ht_cap.ht_supported)\n\t\t\tgoto invalid;\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\t\tbreak;\n\n\t\t \n\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 2)\n\t\t\tgoto invalid;\n\n\t\tswitch (mgmt->u.action.u.ht_smps.action) {\n\t\tcase WLAN_HT_ACTION_SMPS: {\n\t\t\tstruct ieee80211_supported_band *sband;\n\t\t\tenum ieee80211_smps_mode smps_mode;\n\t\t\tstruct sta_opmode_info sta_opmode = {};\n\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_AP &&\n\t\t\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN)\n\t\t\t\tgoto handled;\n\n\t\t\t \n\t\t\tswitch (mgmt->u.action.u.ht_smps.smps_control) {\n\t\t\tcase WLAN_HT_SMPS_CONTROL_DISABLED:\n\t\t\t\tsmps_mode = IEEE80211_SMPS_OFF;\n\t\t\t\tbreak;\n\t\t\tcase WLAN_HT_SMPS_CONTROL_STATIC:\n\t\t\t\tsmps_mode = IEEE80211_SMPS_STATIC;\n\t\t\t\tbreak;\n\t\t\tcase WLAN_HT_SMPS_CONTROL_DYNAMIC:\n\t\t\t\tsmps_mode = IEEE80211_SMPS_DYNAMIC;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto invalid;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (rx->link_sta->pub->smps_mode == smps_mode)\n\t\t\t\tgoto handled;\n\t\t\trx->link_sta->pub->smps_mode = smps_mode;\n\t\t\tsta_opmode.smps_mode =\n\t\t\t\tieee80211_smps_mode_to_smps_mode(smps_mode);\n\t\t\tsta_opmode.changed = STA_OPMODE_SMPS_MODE_CHANGED;\n\n\t\t\tsband = rx->local->hw.wiphy->bands[status->band];\n\n\t\t\trate_control_rate_update(local, sband, rx->sta, 0,\n\t\t\t\t\t\t IEEE80211_RC_SMPS_CHANGED);\n\t\t\tcfg80211_sta_opmode_change_notify(sdata->dev,\n\t\t\t\t\t\t\t  rx->sta->addr,\n\t\t\t\t\t\t\t  &sta_opmode,\n\t\t\t\t\t\t\t  GFP_ATOMIC);\n\t\t\tgoto handled;\n\t\t}\n\t\tcase WLAN_HT_ACTION_NOTIFY_CHANWIDTH: {\n\t\t\tstruct ieee80211_supported_band *sband;\n\t\t\tu8 chanwidth = mgmt->u.action.u.ht_notify_cw.chanwidth;\n\t\t\tenum ieee80211_sta_rx_bandwidth max_bw, new_bw;\n\t\t\tstruct sta_opmode_info sta_opmode = {};\n\n\t\t\t \n\t\t\tif (!(rx->link_sta->pub->ht_cap.cap &\n\t\t\t\t\tIEEE80211_HT_CAP_SUP_WIDTH_20_40))\n\t\t\t\tgoto handled;\n\n\t\t\tif (chanwidth == IEEE80211_HT_CHANWIDTH_20MHZ)\n\t\t\t\tmax_bw = IEEE80211_STA_RX_BW_20;\n\t\t\telse\n\t\t\t\tmax_bw = ieee80211_sta_cap_rx_bw(rx->link_sta);\n\n\t\t\t \n\t\t\trx->link_sta->cur_max_bandwidth = max_bw;\n\t\t\tnew_bw = ieee80211_sta_cur_vht_bw(rx->link_sta);\n\n\t\t\tif (rx->link_sta->pub->bandwidth == new_bw)\n\t\t\t\tgoto handled;\n\n\t\t\trx->link_sta->pub->bandwidth = new_bw;\n\t\t\tsband = rx->local->hw.wiphy->bands[status->band];\n\t\t\tsta_opmode.bw =\n\t\t\t\tieee80211_sta_rx_bw_to_chan_width(rx->link_sta);\n\t\t\tsta_opmode.changed = STA_OPMODE_MAX_BW_CHANGED;\n\n\t\t\trate_control_rate_update(local, sband, rx->sta, 0,\n\t\t\t\t\t\t IEEE80211_RC_BW_CHANGED);\n\t\t\tcfg80211_sta_opmode_change_notify(sdata->dev,\n\t\t\t\t\t\t\t  rx->sta->addr,\n\t\t\t\t\t\t\t  &sta_opmode,\n\t\t\t\t\t\t\t  GFP_ATOMIC);\n\t\t\tgoto handled;\n\t\t}\n\t\tdefault:\n\t\t\tgoto invalid;\n\t\t}\n\n\t\tbreak;\n\tcase WLAN_CATEGORY_PUBLIC:\n\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 1)\n\t\t\tgoto invalid;\n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\t\tbreak;\n\t\tif (!rx->sta)\n\t\t\tbreak;\n\t\tif (!ether_addr_equal(mgmt->bssid, sdata->deflink.u.mgd.bssid))\n\t\t\tbreak;\n\t\tif (mgmt->u.action.u.ext_chan_switch.action_code !=\n\t\t\t\tWLAN_PUB_ACTION_EXT_CHANSW_ANN)\n\t\t\tbreak;\n\t\tif (len < offsetof(struct ieee80211_mgmt,\n\t\t\t\t   u.action.u.ext_chan_switch.variable))\n\t\t\tgoto invalid;\n\t\tgoto queue;\n\tcase WLAN_CATEGORY_VHT:\n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\t\tbreak;\n\n\t\t \n\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 1)\n\t\t\tgoto invalid;\n\n\t\tswitch (mgmt->u.action.u.vht_opmode_notif.action_code) {\n\t\tcase WLAN_VHT_ACTION_OPMODE_NOTIF: {\n\t\t\t \n\t\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 2)\n\t\t\t\tgoto invalid;\n\t\t\tgoto queue;\n\t\t}\n\t\tcase WLAN_VHT_ACTION_GROUPID_MGMT: {\n\t\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 25)\n\t\t\t\tgoto invalid;\n\t\t\tgoto queue;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase WLAN_CATEGORY_BACK:\n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\t\tbreak;\n\n\t\t \n\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 1)\n\t\t\tbreak;\n\n\t\tswitch (mgmt->u.action.u.addba_req.action_code) {\n\t\tcase WLAN_ACTION_ADDBA_REQ:\n\t\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t\t   sizeof(mgmt->u.action.u.addba_req)))\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\tcase WLAN_ACTION_ADDBA_RESP:\n\t\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t\t   sizeof(mgmt->u.action.u.addba_resp)))\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\tcase WLAN_ACTION_DELBA:\n\t\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t\t   sizeof(mgmt->u.action.u.delba)))\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto invalid;\n\t\t}\n\n\t\tgoto queue;\n\tcase WLAN_CATEGORY_SPECTRUM_MGMT:\n\t\t \n\t\tif (len < IEEE80211_MIN_ACTION_SIZE + 1)\n\t\t\tbreak;\n\n\t\tswitch (mgmt->u.action.u.measurement.action_code) {\n\t\tcase WLAN_ACTION_SPCT_MSR_REQ:\n\t\t\tif (status->band != NL80211_BAND_5GHZ)\n\t\t\t\tbreak;\n\n\t\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t\t   sizeof(mgmt->u.action.u.measurement)))\n\t\t\t\tbreak;\n\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\t\t\tbreak;\n\n\t\t\tieee80211_process_measurement_req(sdata, mgmt, len);\n\t\t\tgoto handled;\n\t\tcase WLAN_ACTION_SPCT_CHL_SWITCH: {\n\t\t\tu8 *bssid;\n\t\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t\t   sizeof(mgmt->u.action.u.chan_switch)))\n\t\t\t\tbreak;\n\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t\t\t    sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT)\n\t\t\t\tbreak;\n\n\t\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\t\t\tbssid = sdata->deflink.u.mgd.bssid;\n\t\t\telse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\t\t\tbssid = sdata->u.ibss.bssid;\n\t\t\telse if (sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\t\t\tbssid = mgmt->sa;\n\t\t\telse\n\t\t\t\tbreak;\n\n\t\t\tif (!ether_addr_equal(mgmt->bssid, bssid))\n\t\t\t\tbreak;\n\n\t\t\tgoto queue;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase WLAN_CATEGORY_SELF_PROTECTED:\n\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t   sizeof(mgmt->u.action.u.self_prot.action_code)))\n\t\t\tbreak;\n\n\t\tswitch (mgmt->u.action.u.self_prot.action_code) {\n\t\tcase WLAN_SP_MESH_PEERING_OPEN:\n\t\tcase WLAN_SP_MESH_PEERING_CLOSE:\n\t\tcase WLAN_SP_MESH_PEERING_CONFIRM:\n\t\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\t\tgoto invalid;\n\t\t\tif (sdata->u.mesh.user_mpm)\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tgoto queue;\n\t\tcase WLAN_SP_MGK_INFORM:\n\t\tcase WLAN_SP_MGK_ACK:\n\t\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase WLAN_CATEGORY_MESH_ACTION:\n\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t   sizeof(mgmt->u.action.u.mesh_action.action_code)))\n\t\t\tbreak;\n\n\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tbreak;\n\t\tif (mesh_action_is_path_sel(mgmt) &&\n\t\t    !mesh_path_sel_is_hwmp(sdata))\n\t\t\tbreak;\n\t\tgoto queue;\n\tcase WLAN_CATEGORY_S1G:\n\t\tif (len < offsetofend(typeof(*mgmt),\n\t\t\t\t      u.action.u.s1g.action_code))\n\t\t\tbreak;\n\n\t\tswitch (mgmt->u.action.u.s1g.action_code) {\n\t\tcase WLAN_S1G_TWT_SETUP:\n\t\tcase WLAN_S1G_TWT_TEARDOWN:\n\t\t\tif (ieee80211_process_rx_twt_action(rx))\n\t\t\t\tgoto queue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn RX_CONTINUE;\n\n invalid:\n\tstatus->rx_flags |= IEEE80211_RX_MALFORMED_ACTION_FRM;\n\t \n\treturn RX_CONTINUE;\n\n handled:\n\tif (rx->sta)\n\t\trx->link_sta->rx_stats.packets++;\n\tdev_kfree_skb(rx->skb);\n\treturn RX_QUEUED;\n\n queue:\n\tieee80211_queue_skb_to_iface(sdata, rx->link_id, rx->sta, rx->skb);\n\treturn RX_QUEUED;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_userspace_mgmt(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\tstruct cfg80211_rx_info info = {\n\t\t.freq = ieee80211_rx_status_to_khz(status),\n\t\t.buf = rx->skb->data,\n\t\t.len = rx->skb->len,\n\t\t.link_id = rx->link_id,\n\t\t.have_link_id = rx->link_id >= 0,\n\t};\n\n\t \n\tif (status->rx_flags & IEEE80211_RX_MALFORMED_ACTION_FRM)\n\t\treturn RX_CONTINUE;\n\n\t \n\n\tif (ieee80211_hw_check(&rx->local->hw, SIGNAL_DBM) &&\n\t    !(status->flag & RX_FLAG_NO_SIGNAL_VAL))\n\t\tinfo.sig_dbm = status->signal;\n\n\tif (ieee80211_is_timing_measurement(rx->skb) ||\n\t    ieee80211_is_ftm(rx->skb)) {\n\t\tinfo.rx_tstamp = ktime_to_ns(skb_hwtstamps(rx->skb)->hwtstamp);\n\t\tinfo.ack_tstamp = ktime_to_ns(status->ack_tx_hwtstamp);\n\t}\n\n\tif (cfg80211_rx_mgmt_ext(&rx->sdata->wdev, &info)) {\n\t\tif (rx->sta)\n\t\t\trx->link_sta->rx_stats.packets++;\n\t\tdev_kfree_skb(rx->skb);\n\t\treturn RX_QUEUED;\n\t}\n\n\treturn RX_CONTINUE;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_action_post_userspace(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) rx->skb->data;\n\tint len = rx->skb->len;\n\n\tif (!ieee80211_is_action(mgmt->frame_control))\n\t\treturn RX_CONTINUE;\n\n\tswitch (mgmt->u.action.category) {\n\tcase WLAN_CATEGORY_SA_QUERY:\n\t\tif (len < (IEEE80211_MIN_ACTION_SIZE +\n\t\t\t   sizeof(mgmt->u.action.u.sa_query)))\n\t\t\tbreak;\n\n\t\tswitch (mgmt->u.action.u.sa_query.action) {\n\t\tcase WLAN_ACTION_SA_QUERY_REQUEST:\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\t\t\tbreak;\n\t\t\tieee80211_process_sa_query_req(sdata, mgmt, len);\n\t\t\tgoto handled;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn RX_CONTINUE;\n\n handled:\n\tif (rx->sta)\n\t\trx->link_sta->rx_stats.packets++;\n\tdev_kfree_skb(rx->skb);\n\treturn RX_QUEUED;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_action_return(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_local *local = rx->local;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *) rx->skb->data;\n\tstruct sk_buff *nskb;\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\n\tif (!ieee80211_is_action(mgmt->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t \n\tif (!(status->rx_flags & IEEE80211_RX_MALFORMED_ACTION_FRM) &&\n\t    (sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     sdata->vif.type == NL80211_IFTYPE_AP_VLAN))\n\t\treturn RX_DROP_MONITOR;\n\n\tif (is_multicast_ether_addr(mgmt->da))\n\t\treturn RX_DROP_MONITOR;\n\n\t \n\tif (mgmt->u.action.category & 0x80)\n\t\treturn RX_DROP_UNUSABLE;\n\n\tnskb = skb_copy_expand(rx->skb, local->hw.extra_tx_headroom, 0,\n\t\t\t       GFP_ATOMIC);\n\tif (nskb) {\n\t\tstruct ieee80211_mgmt *nmgmt = (void *)nskb->data;\n\n\t\tnmgmt->u.action.category |= 0x80;\n\t\tmemcpy(nmgmt->da, nmgmt->sa, ETH_ALEN);\n\t\tmemcpy(nmgmt->sa, rx->sdata->vif.addr, ETH_ALEN);\n\n\t\tmemset(nskb->cb, 0, sizeof(nskb->cb));\n\n\t\tif (rx->sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(nskb);\n\n\t\t\tinfo->flags = IEEE80211_TX_CTL_TX_OFFCHAN |\n\t\t\t\t      IEEE80211_TX_INTFL_OFFCHAN_TX_OK |\n\t\t\t\t      IEEE80211_TX_CTL_NO_CCK_RATE;\n\t\t\tif (ieee80211_hw_check(&local->hw, QUEUE_CONTROL))\n\t\t\t\tinfo->hw_queue =\n\t\t\t\t\tlocal->hw.offchannel_tx_hw_queue;\n\t\t}\n\n\t\t__ieee80211_tx_skb_tid_band(rx->sdata, nskb, 7, -1,\n\t\t\t\t\t    status->band);\n\t}\n\tdev_kfree_skb(rx->skb);\n\treturn RX_QUEUED;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_ext(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_hdr *hdr = (void *)rx->skb->data;\n\n\tif (!ieee80211_is_ext(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn RX_DROP_MONITOR;\n\n\t \n\tieee80211_queue_skb_to_iface(sdata, rx->link_id, rx->sta, rx->skb);\n\n\treturn RX_QUEUED;\n}\n\nstatic ieee80211_rx_result debug_noinline\nieee80211_rx_h_mgmt(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_mgmt *mgmt = (void *)rx->skb->data;\n\t__le16 stype;\n\n\tstype = mgmt->frame_control & cpu_to_le16(IEEE80211_FCTL_STYPE);\n\n\tif (!ieee80211_vif_is_mesh(&sdata->vif) &&\n\t    sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t    sdata->vif.type != NL80211_IFTYPE_OCB &&\n\t    sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\treturn RX_DROP_MONITOR;\n\n\tswitch (stype) {\n\tcase cpu_to_le16(IEEE80211_STYPE_AUTH):\n\tcase cpu_to_le16(IEEE80211_STYPE_BEACON):\n\tcase cpu_to_le16(IEEE80211_STYPE_PROBE_RESP):\n\t\t \n\t\tbreak;\n\tcase cpu_to_le16(IEEE80211_STYPE_DEAUTH):\n\t\tif (is_multicast_ether_addr(mgmt->da) &&\n\t\t    !is_broadcast_ether_addr(mgmt->da))\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\t \n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_ADHOC)\n\t\t\treturn RX_DROP_MONITOR;\n\t\tbreak;\n\tcase cpu_to_le16(IEEE80211_STYPE_ASSOC_RESP):\n\tcase cpu_to_le16(IEEE80211_STYPE_REASSOC_RESP):\n\tcase cpu_to_le16(IEEE80211_STYPE_DISASSOC):\n\t\tif (is_multicast_ether_addr(mgmt->da) &&\n\t\t    !is_broadcast_ether_addr(mgmt->da))\n\t\t\treturn RX_DROP_MONITOR;\n\n\t\t \n\t\tif (sdata->vif.type != NL80211_IFTYPE_STATION)\n\t\t\treturn RX_DROP_MONITOR;\n\t\tbreak;\n\tcase cpu_to_le16(IEEE80211_STYPE_PROBE_REQ):\n\t\t \n\t\tif (sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_MESH_POINT)\n\t\t\treturn RX_DROP_MONITOR;\n\t\tbreak;\n\tdefault:\n\t\treturn RX_DROP_MONITOR;\n\t}\n\n\tieee80211_queue_skb_to_iface(sdata, rx->link_id, rx->sta, rx->skb);\n\n\treturn RX_QUEUED;\n}\n\nstatic void ieee80211_rx_cooked_monitor(struct ieee80211_rx_data *rx,\n\t\t\t\t\tstruct ieee80211_rate *rate,\n\t\t\t\t\tieee80211_rx_result reason)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_local *local = rx->local;\n\tstruct sk_buff *skb = rx->skb, *skb2;\n\tstruct net_device *prev_dev = NULL;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tint needed_headroom;\n\n\t \n\tif (rx->flags & IEEE80211_RX_CMNTR)\n\t\tgoto out_free_skb;\n\trx->flags |= IEEE80211_RX_CMNTR;\n\n\t \n\tif (!local->cooked_mntrs)\n\t\tgoto out_free_skb;\n\n\t \n\tneeded_headroom = ieee80211_rx_radiotap_hdrlen(local, status, skb);\n\n\tif (skb_headroom(skb) < needed_headroom &&\n\t    pskb_expand_head(skb, needed_headroom, 0, GFP_ATOMIC))\n\t\tgoto out_free_skb;\n\n\t \n\tieee80211_add_rx_radiotap_header(local, skb, rate, needed_headroom,\n\t\t\t\t\t false);\n\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_MONITOR ||\n\t\t    !(sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES))\n\t\t\tcontinue;\n\n\t\tif (prev_dev) {\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb2) {\n\t\t\t\tskb2->dev = prev_dev;\n\t\t\t\tnetif_receive_skb(skb2);\n\t\t\t}\n\t\t}\n\n\t\tprev_dev = sdata->dev;\n\t\tdev_sw_netstats_rx_add(sdata->dev, skb->len);\n\t}\n\n\tif (prev_dev) {\n\t\tskb->dev = prev_dev;\n\t\tnetif_receive_skb(skb);\n\t\treturn;\n\t}\n\n out_free_skb:\n\tkfree_skb_reason(skb, (__force u32)reason);\n}\n\nstatic void ieee80211_rx_handlers_result(struct ieee80211_rx_data *rx,\n\t\t\t\t\t ieee80211_rx_result res)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_rate *rate = NULL;\n\n\tif (res == RX_QUEUED) {\n\t\tI802_DEBUG_INC(rx->sdata->local->rx_handlers_queued);\n\t\treturn;\n\t}\n\n\tif (res != RX_CONTINUE) {\n\t\tI802_DEBUG_INC(rx->sdata->local->rx_handlers_drop);\n\t\tif (rx->sta)\n\t\t\trx->link_sta->rx_stats.dropped++;\n\t}\n\n\tif (u32_get_bits((__force u32)res, SKB_DROP_REASON_SUBSYS_MASK) ==\n\t\t\tSKB_DROP_REASON_SUBSYS_MAC80211_UNUSABLE) {\n\t\tkfree_skb_reason(rx->skb, (__force u32)res);\n\t\treturn;\n\t}\n\n\tsband = rx->local->hw.wiphy->bands[status->band];\n\tif (status->encoding == RX_ENC_LEGACY)\n\t\trate = &sband->bitrates[status->rate_idx];\n\n\tieee80211_rx_cooked_monitor(rx, rate, res);\n}\n\nstatic void ieee80211_rx_handlers(struct ieee80211_rx_data *rx,\n\t\t\t\t  struct sk_buff_head *frames)\n{\n\tieee80211_rx_result res = RX_DROP_MONITOR;\n\tstruct sk_buff *skb;\n\n#define CALL_RXH(rxh)\t\t\t\\\n\tdo {\t\t\t\t\\\n\t\tres = rxh(rx);\t\t\\\n\t\tif (res != RX_CONTINUE)\t\\\n\t\t\tgoto rxh_next;  \\\n\t} while (0)\n\n\t \n\tspin_lock_bh(&rx->local->rx_path_lock);\n\n\twhile ((skb = __skb_dequeue(frames))) {\n\t\t \n\t\trx->skb = skb;\n\n\t\tif (WARN_ON_ONCE(!rx->link))\n\t\t\tgoto rxh_next;\n\n\t\tCALL_RXH(ieee80211_rx_h_check_more_data);\n\t\tCALL_RXH(ieee80211_rx_h_uapsd_and_pspoll);\n\t\tCALL_RXH(ieee80211_rx_h_sta_process);\n\t\tCALL_RXH(ieee80211_rx_h_decrypt);\n\t\tCALL_RXH(ieee80211_rx_h_defragment);\n\t\tCALL_RXH(ieee80211_rx_h_michael_mic_verify);\n\t\t \n\t\tCALL_RXH(ieee80211_rx_h_amsdu);\n\t\tCALL_RXH(ieee80211_rx_h_data);\n\n\t\t \n\t\tres = ieee80211_rx_h_ctrl(rx, frames);\n\t\tif (res != RX_CONTINUE)\n\t\t\tgoto rxh_next;\n\n\t\tCALL_RXH(ieee80211_rx_h_mgmt_check);\n\t\tCALL_RXH(ieee80211_rx_h_action);\n\t\tCALL_RXH(ieee80211_rx_h_userspace_mgmt);\n\t\tCALL_RXH(ieee80211_rx_h_action_post_userspace);\n\t\tCALL_RXH(ieee80211_rx_h_action_return);\n\t\tCALL_RXH(ieee80211_rx_h_ext);\n\t\tCALL_RXH(ieee80211_rx_h_mgmt);\n\n rxh_next:\n\t\tieee80211_rx_handlers_result(rx, res);\n\n#undef CALL_RXH\n\t}\n\n\tspin_unlock_bh(&rx->local->rx_path_lock);\n}\n\nstatic void ieee80211_invoke_rx_handlers(struct ieee80211_rx_data *rx)\n{\n\tstruct sk_buff_head reorder_release;\n\tieee80211_rx_result res = RX_DROP_MONITOR;\n\n\t__skb_queue_head_init(&reorder_release);\n\n#define CALL_RXH(rxh)\t\t\t\\\n\tdo {\t\t\t\t\\\n\t\tres = rxh(rx);\t\t\\\n\t\tif (res != RX_CONTINUE)\t\\\n\t\t\tgoto rxh_next;  \\\n\t} while (0)\n\n\tCALL_RXH(ieee80211_rx_h_check_dup);\n\tCALL_RXH(ieee80211_rx_h_check);\n\n\tieee80211_rx_reorder_ampdu(rx, &reorder_release);\n\n\tieee80211_rx_handlers(rx, &reorder_release);\n\treturn;\n\n rxh_next:\n\tieee80211_rx_handlers_result(rx, res);\n\n#undef CALL_RXH\n}\n\nstatic bool\nieee80211_rx_is_valid_sta_link_id(struct ieee80211_sta *sta, u8 link_id)\n{\n\treturn !!(sta->valid_links & BIT(link_id));\n}\n\nstatic bool ieee80211_rx_data_set_link(struct ieee80211_rx_data *rx,\n\t\t\t\t       u8 link_id)\n{\n\trx->link_id = link_id;\n\trx->link = rcu_dereference(rx->sdata->link[link_id]);\n\n\tif (!rx->sta)\n\t\treturn rx->link;\n\n\tif (!ieee80211_rx_is_valid_sta_link_id(&rx->sta->sta, link_id))\n\t\treturn false;\n\n\trx->link_sta = rcu_dereference(rx->sta->link[link_id]);\n\n\treturn rx->link && rx->link_sta;\n}\n\nstatic bool ieee80211_rx_data_set_sta(struct ieee80211_rx_data *rx,\n\t\t\t\t      struct sta_info *sta, int link_id)\n{\n\trx->link_id = link_id;\n\trx->sta = sta;\n\n\tif (sta) {\n\t\trx->local = sta->sdata->local;\n\t\tif (!rx->sdata)\n\t\t\trx->sdata = sta->sdata;\n\t\trx->link_sta = &sta->deflink;\n\t} else {\n\t\trx->link_sta = NULL;\n\t}\n\n\tif (link_id < 0)\n\t\trx->link = &rx->sdata->deflink;\n\telse if (!ieee80211_rx_data_set_link(rx, link_id))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nvoid ieee80211_release_reorder_timeout(struct sta_info *sta, int tid)\n{\n\tstruct sk_buff_head frames;\n\tstruct ieee80211_rx_data rx = {\n\t\t \n\t\t.security_idx = tid,\n\t\t.seqno_idx = tid,\n\t};\n\tstruct tid_ampdu_rx *tid_agg_rx;\n\tint link_id = -1;\n\n\t \n\tif (sta->sta.valid_links)\n\t\tlink_id = ffs(sta->sta.valid_links) - 1;\n\n\tif (!ieee80211_rx_data_set_sta(&rx, sta, link_id))\n\t\treturn;\n\n\ttid_agg_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[tid]);\n\tif (!tid_agg_rx)\n\t\treturn;\n\n\t__skb_queue_head_init(&frames);\n\n\tspin_lock(&tid_agg_rx->reorder_lock);\n\tieee80211_sta_reorder_release(sta->sdata, tid_agg_rx, &frames);\n\tspin_unlock(&tid_agg_rx->reorder_lock);\n\n\tif (!skb_queue_empty(&frames)) {\n\t\tstruct ieee80211_event event = {\n\t\t\t.type = BA_FRAME_TIMEOUT,\n\t\t\t.u.ba.tid = tid,\n\t\t\t.u.ba.sta = &sta->sta,\n\t\t};\n\t\tdrv_event_callback(rx.local, rx.sdata, &event);\n\t}\n\n\tieee80211_rx_handlers(&rx, &frames);\n}\n\nvoid ieee80211_mark_rx_ba_filtered_frames(struct ieee80211_sta *pubsta, u8 tid,\n\t\t\t\t\t  u16 ssn, u64 filtered,\n\t\t\t\t\t  u16 received_mpdus)\n{\n\tstruct ieee80211_local *local;\n\tstruct sta_info *sta;\n\tstruct tid_ampdu_rx *tid_agg_rx;\n\tstruct sk_buff_head frames;\n\tstruct ieee80211_rx_data rx = {\n\t\t \n\t\t.security_idx = tid,\n\t\t.seqno_idx = tid,\n\t};\n\tint i, diff;\n\n\tif (WARN_ON(!pubsta || tid >= IEEE80211_NUM_TIDS))\n\t\treturn;\n\n\t__skb_queue_head_init(&frames);\n\n\tsta = container_of(pubsta, struct sta_info, sta);\n\n\tlocal = sta->sdata->local;\n\tWARN_ONCE(local->hw.max_rx_aggregation_subframes > 64,\n\t\t  \"RX BA marker can't support max_rx_aggregation_subframes %u > 64\\n\",\n\t\t  local->hw.max_rx_aggregation_subframes);\n\n\tif (!ieee80211_rx_data_set_sta(&rx, sta, -1))\n\t\treturn;\n\n\trcu_read_lock();\n\ttid_agg_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[tid]);\n\tif (!tid_agg_rx)\n\t\tgoto out;\n\n\tspin_lock_bh(&tid_agg_rx->reorder_lock);\n\n\tif (received_mpdus >= IEEE80211_SN_MODULO >> 1) {\n\t\tint release;\n\n\t\t \n\t\trelease = (tid_agg_rx->head_seq_num + tid_agg_rx->buf_size) %\n\t\t\t   IEEE80211_SN_MODULO;\n\t\tieee80211_release_reorder_frames(sta->sdata, tid_agg_rx,\n\t\t\t\t\t\t release, &frames);\n\t\t \n\t\ttid_agg_rx->head_seq_num = ssn;\n\t} else {\n\t\tieee80211_release_reorder_frames(sta->sdata, tid_agg_rx, ssn,\n\t\t\t\t\t\t &frames);\n\t}\n\n\t \n\tdiff = (tid_agg_rx->head_seq_num - ssn) & IEEE80211_SN_MASK;\n\tif (diff >= tid_agg_rx->buf_size) {\n\t\ttid_agg_rx->reorder_buf_filtered = 0;\n\t\tgoto release;\n\t}\n\tfiltered = filtered >> diff;\n\tssn += diff;\n\n\t \n\tfor (i = 0; i < tid_agg_rx->buf_size; i++) {\n\t\tint index = (ssn + i) % tid_agg_rx->buf_size;\n\n\t\ttid_agg_rx->reorder_buf_filtered &= ~BIT_ULL(index);\n\t\tif (filtered & BIT_ULL(i))\n\t\t\ttid_agg_rx->reorder_buf_filtered |= BIT_ULL(index);\n\t}\n\n\t \n\tieee80211_sta_reorder_release(sta->sdata, tid_agg_rx, &frames);\n\nrelease:\n\tspin_unlock_bh(&tid_agg_rx->reorder_lock);\n\n\tieee80211_rx_handlers(&rx, &frames);\n\n out:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ieee80211_mark_rx_ba_filtered_frames);\n\n \n\nstatic inline int ieee80211_bssid_match(const u8 *raddr, const u8 *addr)\n{\n\treturn ether_addr_equal(raddr, addr) ||\n\t       is_broadcast_ether_addr(raddr);\n}\n\nstatic bool ieee80211_accept_frame(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tu8 *bssid = ieee80211_get_bssid(hdr, skb->len, sdata->vif.type);\n\tbool multicast = is_multicast_ether_addr(hdr->addr1) ||\n\t\t\t ieee80211_is_s1g_beacon(hdr->frame_control);\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!bssid && !sdata->u.mgd.use_4addr)\n\t\t\treturn false;\n\t\tif (ieee80211_is_first_frag(hdr->seq_ctrl) &&\n\t\t    ieee80211_is_robust_mgmt_frame(skb) && !rx->sta)\n\t\t\treturn false;\n\t\tif (multicast)\n\t\t\treturn true;\n\t\treturn ieee80211_is_our_addr(sdata, hdr->addr1, &rx->link_id);\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (!bssid)\n\t\t\treturn false;\n\t\tif (ether_addr_equal(sdata->vif.addr, hdr->addr2) ||\n\t\t    ether_addr_equal(sdata->u.ibss.bssid, hdr->addr2) ||\n\t\t    !is_valid_ether_addr(hdr->addr2))\n\t\t\treturn false;\n\t\tif (ieee80211_is_beacon(hdr->frame_control))\n\t\t\treturn true;\n\t\tif (!ieee80211_bssid_match(bssid, sdata->u.ibss.bssid))\n\t\t\treturn false;\n\t\tif (!multicast &&\n\t\t    !ether_addr_equal(sdata->vif.addr, hdr->addr1))\n\t\t\treturn false;\n\t\tif (!rx->sta) {\n\t\t\tint rate_idx;\n\t\t\tif (status->encoding != RX_ENC_LEGACY)\n\t\t\t\trate_idx = 0;  \n\t\t\telse\n\t\t\t\trate_idx = status->rate_idx;\n\t\t\tieee80211_ibss_rx_no_sta(sdata, bssid, hdr->addr2,\n\t\t\t\t\t\t BIT(rate_idx));\n\t\t}\n\t\treturn true;\n\tcase NL80211_IFTYPE_OCB:\n\t\tif (!bssid)\n\t\t\treturn false;\n\t\tif (!ieee80211_is_data_present(hdr->frame_control))\n\t\t\treturn false;\n\t\tif (!is_broadcast_ether_addr(bssid))\n\t\t\treturn false;\n\t\tif (!multicast &&\n\t\t    !ether_addr_equal(sdata->dev->dev_addr, hdr->addr1))\n\t\t\treturn false;\n\t\tif (!rx->sta) {\n\t\t\tint rate_idx;\n\t\t\tif (status->encoding != RX_ENC_LEGACY)\n\t\t\t\trate_idx = 0;  \n\t\t\telse\n\t\t\t\trate_idx = status->rate_idx;\n\t\t\tieee80211_ocb_rx_no_sta(sdata, bssid, hdr->addr2,\n\t\t\t\t\t\tBIT(rate_idx));\n\t\t}\n\t\treturn true;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (ether_addr_equal(sdata->vif.addr, hdr->addr2))\n\t\t\treturn false;\n\t\tif (multicast)\n\t\t\treturn true;\n\t\treturn ether_addr_equal(sdata->vif.addr, hdr->addr1);\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_AP:\n\t\tif (!bssid)\n\t\t\treturn ieee80211_is_our_addr(sdata, hdr->addr1,\n\t\t\t\t\t\t     &rx->link_id);\n\n\t\tif (!is_broadcast_ether_addr(bssid) &&\n\t\t    !ieee80211_is_our_addr(sdata, bssid, NULL)) {\n\t\t\t \n\t\t\tif (!multicast &&\n\t\t\t    !ieee80211_is_our_addr(sdata, hdr->addr1,\n\t\t\t\t\t\t   &rx->link_id))\n\t\t\t\treturn false;\n\t\t\tif (ieee80211_is_public_action(hdr, skb->len))\n\t\t\t\treturn true;\n\t\t\treturn ieee80211_is_beacon(hdr->frame_control);\n\t\t}\n\n\t\tif (!ieee80211_has_tods(hdr->frame_control)) {\n\t\t\t \n\t\t\tif (ieee80211_is_data(hdr->frame_control))\n\t\t\t\treturn false;\n\t\t\t \n\t\t\tif (ieee80211_is_action(hdr->frame_control) &&\n\t\t\t    !is_broadcast_ether_addr(bssid) &&\n\t\t\t    !ether_addr_equal(bssid, hdr->addr1))\n\t\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tif (ieee80211_is_data(hdr->frame_control) && multicast)\n\t\t\treturn false;\n\n\t\treturn true;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\treturn ieee80211_is_public_action(hdr, skb->len) ||\n\t\t       ieee80211_is_probe_req(hdr->frame_control) ||\n\t\t       ieee80211_is_probe_resp(hdr->frame_control) ||\n\t\t       ieee80211_is_beacon(hdr->frame_control);\n\tcase NL80211_IFTYPE_NAN:\n\t\t \n\t\treturn false;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tWARN_ON_ONCE(1);\n\treturn false;\n}\n\nvoid ieee80211_check_fast_rx(struct sta_info *sta)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_key *key;\n\tstruct ieee80211_fast_rx fastrx = {\n\t\t.dev = sdata->dev,\n\t\t.vif_type = sdata->vif.type,\n\t\t.control_port_protocol = sdata->control_port_protocol,\n\t}, *old, *new = NULL;\n\tu32 offload_flags;\n\tbool set_offload = false;\n\tbool assign = false;\n\tbool offload;\n\n\t \n\t__acquire(check_fast_rx);\n\n\tBUILD_BUG_ON(sizeof(fastrx.rfc1042_hdr) != sizeof(rfc1042_header));\n\tBUILD_BUG_ON(sizeof(fastrx.rfc1042_hdr) != ETH_ALEN);\n\tether_addr_copy(fastrx.rfc1042_hdr, rfc1042_header);\n\tether_addr_copy(fastrx.vif_addr, sdata->vif.addr);\n\n\tfastrx.uses_rss = ieee80211_hw_check(&local->hw, USES_RSS);\n\n\t \n\tif (ieee80211_hw_check(&local->hw, AMPDU_AGGREGATION) &&\n\t    !ieee80211_hw_check(&local->hw, SUPPORTS_REORDERING_BUFFER))\n\t\tgoto clear;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (sta->sta.tdls) {\n\t\t\tfastrx.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\t\tfastrx.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\t\tfastrx.expected_ds_bits = 0;\n\t\t} else {\n\t\t\tfastrx.da_offs = offsetof(struct ieee80211_hdr, addr1);\n\t\t\tfastrx.sa_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\t\tfastrx.expected_ds_bits =\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t}\n\n\t\tif (sdata->u.mgd.use_4addr && !sta->sta.tdls) {\n\t\t\tfastrx.expected_ds_bits |=\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_TODS);\n\t\t\tfastrx.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\t\tfastrx.sa_offs = offsetof(struct ieee80211_hdr, addr4);\n\t\t}\n\n\t\tif (!sdata->u.mgd.powersave)\n\t\t\tbreak;\n\n\t\t \n\t\tif (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK))\n\t\t\tgoto clear;\n\t\tif (ieee80211_hw_check(&local->hw, SUPPORTS_PS) &&\n\t\t    !ieee80211_hw_check(&local->hw, SUPPORTS_DYNAMIC_PS))\n\t\t\tgoto clear;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_AP:\n\t\t \n\t\tif (!ieee80211_hw_check(&local->hw, AP_LINK_PS))\n\t\t\tgoto clear;\n\t\tfastrx.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\tfastrx.sa_offs = offsetof(struct ieee80211_hdr, addr2);\n\t\tfastrx.expected_ds_bits = cpu_to_le16(IEEE80211_FCTL_TODS);\n\n\t\tfastrx.internal_forward =\n\t\t\t!(sdata->flags & IEEE80211_SDATA_DONT_BRIDGE_PACKETS) &&\n\t\t\t(sdata->vif.type != NL80211_IFTYPE_AP_VLAN ||\n\t\t\t !sdata->u.vlan.sta);\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->u.vlan.sta) {\n\t\t\tfastrx.expected_ds_bits |=\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_FROMDS);\n\t\t\tfastrx.sa_offs = offsetof(struct ieee80211_hdr, addr4);\n\t\t\tfastrx.internal_forward = 0;\n\t\t}\n\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tfastrx.expected_ds_bits = cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t\t      IEEE80211_FCTL_TODS);\n\t\tfastrx.da_offs = offsetof(struct ieee80211_hdr, addr3);\n\t\tfastrx.sa_offs = offsetof(struct ieee80211_hdr, addr4);\n\t\tbreak;\n\tdefault:\n\t\tgoto clear;\n\t}\n\n\tif (!test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\tgoto clear;\n\n\trcu_read_lock();\n\tkey = rcu_dereference(sta->ptk[sta->ptk_idx]);\n\tif (!key)\n\t\tkey = rcu_dereference(sdata->default_unicast_key);\n\tif (key) {\n\t\tswitch (key->conf.cipher) {\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\t \n\t\t\tgoto clear_rcu;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tgoto clear_rcu;\n\t\t}\n\n\t\tfastrx.key = true;\n\t\tfastrx.icv_len = key->conf.icv_len;\n\t}\n\n\tassign = true;\n clear_rcu:\n\trcu_read_unlock();\n clear:\n\t__release(check_fast_rx);\n\n\tif (assign)\n\t\tnew = kmemdup(&fastrx, sizeof(fastrx), GFP_KERNEL);\n\n\toffload_flags = get_bss_sdata(sdata)->vif.offload_flags;\n\toffload = offload_flags & IEEE80211_OFFLOAD_DECAP_ENABLED;\n\n\tif (assign && offload)\n\t\tset_offload = !test_and_set_sta_flag(sta, WLAN_STA_DECAP_OFFLOAD);\n\telse\n\t\tset_offload = test_and_clear_sta_flag(sta, WLAN_STA_DECAP_OFFLOAD);\n\n\tif (set_offload)\n\t\tdrv_sta_set_decap_offload(local, sdata, &sta->sta, assign);\n\n\tspin_lock_bh(&sta->lock);\n\told = rcu_dereference_protected(sta->fast_rx, true);\n\trcu_assign_pointer(sta->fast_rx, new);\n\tspin_unlock_bh(&sta->lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n}\n\nvoid ieee80211_clear_fast_rx(struct sta_info *sta)\n{\n\tstruct ieee80211_fast_rx *old;\n\n\tspin_lock_bh(&sta->lock);\n\told = rcu_dereference_protected(sta->fast_rx, true);\n\tRCU_INIT_POINTER(sta->fast_rx, NULL);\n\tspin_unlock_bh(&sta->lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n}\n\nvoid __ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\tlockdep_assert_held(&local->sta_mtx);\n\n\tlist_for_each_entry(sta, &local->sta_list, list) {\n\t\tif (sdata != sta->sdata &&\n\t\t    (!sta->sdata->bss || sta->sdata->bss != sdata->bss))\n\t\t\tcontinue;\n\t\tieee80211_check_fast_rx(sta);\n\t}\n}\n\nvoid ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\tmutex_lock(&local->sta_mtx);\n\t__ieee80211_check_fast_rx_iface(sdata);\n\tmutex_unlock(&local->sta_mtx);\n}\n\nstatic void ieee80211_rx_8023(struct ieee80211_rx_data *rx,\n\t\t\t      struct ieee80211_fast_rx *fast_rx,\n\t\t\t      int orig_len)\n{\n\tstruct ieee80211_sta_rx_stats *stats;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\tstruct sta_info *sta = rx->sta;\n\tstruct link_sta_info *link_sta;\n\tstruct sk_buff *skb = rx->skb;\n\tvoid *sa = skb->data + ETH_ALEN;\n\tvoid *da = skb->data;\n\n\tif (rx->link_id >= 0) {\n\t\tlink_sta = rcu_dereference(sta->link[rx->link_id]);\n\t\tif (WARN_ON_ONCE(!link_sta)) {\n\t\t\tdev_kfree_skb(rx->skb);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tlink_sta = &sta->deflink;\n\t}\n\n\tstats = &link_sta->rx_stats;\n\tif (fast_rx->uses_rss)\n\t\tstats = this_cpu_ptr(link_sta->pcpu_rx_stats);\n\n\t \n\tif (!(status->flag & RX_FLAG_NO_SIGNAL_VAL)) {\n\t\tstats->last_signal = status->signal;\n\t\tif (!fast_rx->uses_rss)\n\t\t\tewma_signal_add(&link_sta->rx_stats_avg.signal,\n\t\t\t\t\t-status->signal);\n\t}\n\n\tif (status->chains) {\n\t\tint i;\n\n\t\tstats->chains = status->chains;\n\t\tfor (i = 0; i < ARRAY_SIZE(status->chain_signal); i++) {\n\t\t\tint signal = status->chain_signal[i];\n\n\t\t\tif (!(status->chains & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\tstats->chain_signal_last[i] = signal;\n\t\t\tif (!fast_rx->uses_rss)\n\t\t\t\tewma_signal_add(&link_sta->rx_stats_avg.chain_signal[i],\n\t\t\t\t\t\t-signal);\n\t\t}\n\t}\n\t \n\n\tstats->last_rx = jiffies;\n\tstats->last_rate = sta_stats_encode_rate(status);\n\n\tstats->fragments++;\n\tstats->packets++;\n\n\tskb->dev = fast_rx->dev;\n\n\tdev_sw_netstats_rx_add(fast_rx->dev, skb->len);\n\n\t \n\tu64_stats_update_begin(&stats->syncp);\n\tstats->msdu[rx->seqno_idx]++;\n\tstats->bytes += orig_len;\n\tu64_stats_update_end(&stats->syncp);\n\n\tif (fast_rx->internal_forward) {\n\t\tstruct sk_buff *xmit_skb = NULL;\n\t\tif (is_multicast_ether_addr(da)) {\n\t\t\txmit_skb = skb_copy(skb, GFP_ATOMIC);\n\t\t} else if (!ether_addr_equal(da, sa) &&\n\t\t\t   sta_info_get(rx->sdata, da)) {\n\t\t\txmit_skb = skb;\n\t\t\tskb = NULL;\n\t\t}\n\n\t\tif (xmit_skb) {\n\t\t\t \n\t\t\txmit_skb->priority += 256;\n\t\t\txmit_skb->protocol = htons(ETH_P_802_3);\n\t\t\tskb_reset_network_header(xmit_skb);\n\t\t\tskb_reset_mac_header(xmit_skb);\n\t\t\tdev_queue_xmit(xmit_skb);\n\t\t}\n\n\t\tif (!skb)\n\t\t\treturn;\n\t}\n\n\t \n\tskb->protocol = eth_type_trans(skb, fast_rx->dev);\n\tieee80211_deliver_skb_to_local_stack(skb, rx);\n}\n\nstatic bool ieee80211_invoke_fast_rx(struct ieee80211_rx_data *rx,\n\t\t\t\t     struct ieee80211_fast_rx *fast_rx)\n{\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstatic ieee80211_rx_result res;\n\tint orig_len = skb->len;\n\tint hdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tint snap_offs = hdrlen;\n\tstruct {\n\t\tu8 snap[sizeof(rfc1042_header)];\n\t\t__be16 proto;\n\t} *payload __aligned(2);\n\tstruct {\n\t\tu8 da[ETH_ALEN];\n\t\tu8 sa[ETH_ALEN];\n\t} addrs __aligned(2);\n\tstruct ieee80211_sta_rx_stats *stats;\n\n\t \n\tif (!(status->flag & RX_FLAG_DUP_VALIDATED))\n\t\treturn false;\n\n#define FAST_RX_CRYPT_FLAGS\t(RX_FLAG_PN_VALIDATED | RX_FLAG_DECRYPTED)\n\n\t \n\tif (fast_rx->key &&\n\t    (status->flag & FAST_RX_CRYPT_FLAGS) != FAST_RX_CRYPT_FLAGS)\n\t\treturn false;\n\n\tif (unlikely(!ieee80211_is_data_present(hdr->frame_control)))\n\t\treturn false;\n\n\tif (unlikely(ieee80211_is_frag(hdr)))\n\t\treturn false;\n\n\t \n\tif (!ether_addr_equal(fast_rx->vif_addr, hdr->addr1))\n\t\treturn false;\n\n\tif ((hdr->frame_control & cpu_to_le16(IEEE80211_FCTL_FROMDS |\n\t\t\t\t\t      IEEE80211_FCTL_TODS)) !=\n\t    fast_rx->expected_ds_bits)\n\t\treturn false;\n\n\t \n\tif (fast_rx->key && !(status->flag & RX_FLAG_IV_STRIPPED)) {\n\t\t \n\t\tsnap_offs += IEEE80211_CCMP_HDR_LEN;\n\t}\n\n\tif (!ieee80211_vif_is_mesh(&rx->sdata->vif) &&\n\t    !(status->rx_flags & IEEE80211_RX_AMSDU)) {\n\t\tif (!pskb_may_pull(skb, snap_offs + sizeof(*payload)))\n\t\t\treturn false;\n\n\t\tpayload = (void *)(skb->data + snap_offs);\n\n\t\tif (!ether_addr_equal(payload->snap, fast_rx->rfc1042_hdr))\n\t\t\treturn false;\n\n\t\t \n\t\tif (unlikely(payload->proto == cpu_to_be16(ETH_P_TDLS) ||\n\t\t\t     payload->proto == fast_rx->control_port_protocol))\n\t\t\treturn false;\n\t}\n\n\t \n\n\tif (rx->key && !(status->flag & RX_FLAG_MIC_STRIPPED) &&\n\t    pskb_trim(skb, skb->len - fast_rx->icv_len))\n\t\tgoto drop;\n\n\tif (rx->key && !ieee80211_has_protected(hdr->frame_control))\n\t\tgoto drop;\n\n\tif (status->rx_flags & IEEE80211_RX_AMSDU) {\n\t\tif (__ieee80211_rx_h_amsdu(rx, snap_offs - hdrlen) !=\n\t\t    RX_QUEUED)\n\t\t\tgoto drop;\n\n\t\treturn true;\n\t}\n\n\t \n\tether_addr_copy(addrs.da, skb->data + fast_rx->da_offs);\n\tether_addr_copy(addrs.sa, skb->data + fast_rx->sa_offs);\n\tif (ieee80211_vif_is_mesh(&rx->sdata->vif)) {\n\t    skb_pull(skb, snap_offs - 2);\n\t    put_unaligned_be16(skb->len - 2, skb->data);\n\t} else {\n\t    skb_postpull_rcsum(skb, skb->data + snap_offs,\n\t\t\t       sizeof(rfc1042_header) + 2);\n\n\t     \n\t    skb_pull(skb, snap_offs + sizeof(rfc1042_header));\n\t}\n\t \n\tmemcpy(skb_push(skb, sizeof(addrs)), &addrs, sizeof(addrs));\n\n\tres = ieee80211_rx_mesh_data(rx->sdata, rx->sta, rx->skb);\n\tswitch (res) {\n\tcase RX_QUEUED:\n\t\treturn true;\n\tcase RX_CONTINUE:\n\t\tbreak;\n\tdefault:\n\t\tgoto drop;\n\t}\n\n\tieee80211_rx_8023(rx, fast_rx, orig_len);\n\n\treturn true;\n drop:\n\tdev_kfree_skb(skb);\n\n\tif (fast_rx->uses_rss)\n\t\tstats = this_cpu_ptr(rx->link_sta->pcpu_rx_stats);\n\telse\n\t\tstats = &rx->link_sta->rx_stats;\n\n\tstats->dropped++;\n\treturn true;\n}\n\n \nstatic bool ieee80211_prepare_and_rx_handle(struct ieee80211_rx_data *rx,\n\t\t\t\t\t    struct sk_buff *skb, bool consume)\n{\n\tstruct ieee80211_local *local = rx->local;\n\tstruct ieee80211_sub_if_data *sdata = rx->sdata;\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct link_sta_info *link_sta = rx->link_sta;\n\tstruct ieee80211_link_data *link = rx->link;\n\n\trx->skb = skb;\n\n\t \n\tif (consume && rx->sta) {\n\t\tstruct ieee80211_fast_rx *fast_rx;\n\n\t\tfast_rx = rcu_dereference(rx->sta->fast_rx);\n\t\tif (fast_rx && ieee80211_invoke_fast_rx(rx, fast_rx))\n\t\t\treturn true;\n\t}\n\n\tif (!ieee80211_accept_frame(rx))\n\t\treturn false;\n\n\tif (!consume) {\n\t\tstruct skb_shared_hwtstamps *shwt;\n\n\t\trx->skb = skb_copy(skb, GFP_ATOMIC);\n\t\tif (!rx->skb) {\n\t\t\tif (net_ratelimit())\n\t\t\t\twiphy_debug(local->hw.wiphy,\n\t\t\t\t\t\"failed to copy skb for %s\\n\",\n\t\t\t\t\tsdata->name);\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\tshwt = skb_hwtstamps(rx->skb);\n\t\tshwt->hwtstamp = skb_hwtstamps(skb)->hwtstamp;\n\n\t\t \n\t\thdr = (struct ieee80211_hdr *)rx->skb->data;\n\t}\n\n\tif (unlikely(rx->sta && rx->sta->sta.mlo) &&\n\t    is_unicast_ether_addr(hdr->addr1) &&\n\t    !ieee80211_is_probe_resp(hdr->frame_control) &&\n\t    !ieee80211_is_beacon(hdr->frame_control)) {\n\t\t \n\t\tif (ether_addr_equal(link->conf->addr, hdr->addr1))\n\t\t\tether_addr_copy(hdr->addr1, rx->sdata->vif.addr);\n\t\tif (ether_addr_equal(link_sta->addr, hdr->addr2))\n\t\t\tether_addr_copy(hdr->addr2, rx->sta->addr);\n\t\t \n\t\tif (!ieee80211_has_tods(hdr->frame_control) &&\n\t\t    !ieee80211_has_fromds(hdr->frame_control)) {\n\t\t\tif (ether_addr_equal(link_sta->addr, hdr->addr3))\n\t\t\t\tether_addr_copy(hdr->addr3, rx->sta->addr);\n\t\t\telse if (ether_addr_equal(link->conf->addr, hdr->addr3))\n\t\t\t\tether_addr_copy(hdr->addr3, rx->sdata->vif.addr);\n\t\t}\n\t\t \n\t}\n\n\tieee80211_invoke_rx_handlers(rx);\n\treturn true;\n}\n\nstatic void __ieee80211_rx_handle_8023(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_sta *pubsta,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       struct list_head *list)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_fast_rx *fast_rx;\n\tstruct ieee80211_rx_data rx;\n\tstruct sta_info *sta;\n\tint link_id = -1;\n\n\tmemset(&rx, 0, sizeof(rx));\n\trx.skb = skb;\n\trx.local = local;\n\trx.list = list;\n\trx.link_id = -1;\n\n\tI802_DEBUG_INC(local->dot11ReceivedFragmentCount);\n\n\t \n\tif (skb->len < sizeof(struct ethhdr))\n\t\tgoto drop;\n\n\tif (!pubsta)\n\t\tgoto drop;\n\n\tif (status->link_valid)\n\t\tlink_id = status->link_id;\n\n\t \n\tsta = container_of(pubsta, struct sta_info, sta);\n\tif (!ieee80211_rx_data_set_sta(&rx, sta, link_id))\n\t\tgoto drop;\n\n\tfast_rx = rcu_dereference(rx.sta->fast_rx);\n\tif (!fast_rx)\n\t\tgoto drop;\n\n\tieee80211_rx_8023(&rx, fast_rx, skb->len);\n\treturn;\n\ndrop:\n\tdev_kfree_skb(skb);\n}\n\nstatic bool ieee80211_rx_for_interface(struct ieee80211_rx_data *rx,\n\t\t\t\t       struct sk_buff *skb, bool consume)\n{\n\tstruct link_sta_info *link_sta;\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct sta_info *sta;\n\tint link_id = -1;\n\n\t \n\tlink_sta = link_sta_info_get_bss(rx->sdata, hdr->addr2);\n\tif (link_sta) {\n\t\tsta = link_sta->sta;\n\t\tlink_id = link_sta->link_id;\n\t} else {\n\t\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\n\t\tsta = sta_info_get_bss(rx->sdata, hdr->addr2);\n\t\tif (status->link_valid)\n\t\t\tlink_id = status->link_id;\n\t}\n\n\tif (!ieee80211_rx_data_set_sta(rx, sta, link_id))\n\t\treturn false;\n\n\treturn ieee80211_prepare_and_rx_handle(rx, skb, consume);\n}\n\n \nstatic void __ieee80211_rx_handle_packet(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_sta *pubsta,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t struct list_head *list)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_hdr *hdr;\n\t__le16 fc;\n\tstruct ieee80211_rx_data rx;\n\tstruct ieee80211_sub_if_data *prev;\n\tstruct rhlist_head *tmp;\n\tint err = 0;\n\n\tfc = ((struct ieee80211_hdr *)skb->data)->frame_control;\n\tmemset(&rx, 0, sizeof(rx));\n\trx.skb = skb;\n\trx.local = local;\n\trx.list = list;\n\trx.link_id = -1;\n\n\tif (ieee80211_is_data(fc) || ieee80211_is_mgmt(fc))\n\t\tI802_DEBUG_INC(local->dot11ReceivedFragmentCount);\n\n\tif (ieee80211_is_mgmt(fc)) {\n\t\t \n\t\tif (skb->len < ieee80211_hdrlen(fc))\n\t\t\terr = -ENOBUFS;\n\t\telse\n\t\t\terr = skb_linearize(skb);\n\t} else {\n\t\terr = !pskb_may_pull(skb, ieee80211_hdrlen(fc));\n\t}\n\n\tif (err) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tieee80211_parse_qos(&rx);\n\tieee80211_verify_alignment(&rx);\n\n\tif (unlikely(ieee80211_is_probe_resp(hdr->frame_control) ||\n\t\t     ieee80211_is_beacon(hdr->frame_control) ||\n\t\t     ieee80211_is_s1g_beacon(hdr->frame_control)))\n\t\tieee80211_scan_rx(local, skb);\n\n\tif (ieee80211_is_data(fc)) {\n\t\tstruct sta_info *sta, *prev_sta;\n\t\tint link_id = -1;\n\n\t\tif (status->link_valid)\n\t\t\tlink_id = status->link_id;\n\n\t\tif (pubsta) {\n\t\t\tsta = container_of(pubsta, struct sta_info, sta);\n\t\t\tif (!ieee80211_rx_data_set_sta(&rx, sta, link_id))\n\t\t\t\tgoto out;\n\n\t\t\t \n\n\t\t\tif (!status->link_valid && pubsta->mlo) {\n\t\t\t\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t\t\t\tstruct link_sta_info *link_sta;\n\n\t\t\t\tlink_sta = link_sta_info_get_bss(rx.sdata,\n\t\t\t\t\t\t\t\t hdr->addr2);\n\t\t\t\tif (!link_sta)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tieee80211_rx_data_set_link(&rx, link_sta->link_id);\n\t\t\t}\n\n\t\t\tif (ieee80211_prepare_and_rx_handle(&rx, skb, true))\n\t\t\t\treturn;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprev_sta = NULL;\n\n\t\tfor_each_sta_info(local, hdr->addr2, sta, tmp) {\n\t\t\tif (!prev_sta) {\n\t\t\t\tprev_sta = sta;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trx.sdata = prev_sta->sdata;\n\t\t\tif (!ieee80211_rx_data_set_sta(&rx, prev_sta, link_id))\n\t\t\t\tgoto out;\n\n\t\t\tif (!status->link_valid && prev_sta->sta.mlo)\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_prepare_and_rx_handle(&rx, skb, false);\n\n\t\t\tprev_sta = sta;\n\t\t}\n\n\t\tif (prev_sta) {\n\t\t\trx.sdata = prev_sta->sdata;\n\t\t\tif (!ieee80211_rx_data_set_sta(&rx, prev_sta, link_id))\n\t\t\t\tgoto out;\n\n\t\t\tif (!status->link_valid && prev_sta->sta.mlo)\n\t\t\t\tgoto out;\n\n\t\t\tif (ieee80211_prepare_and_rx_handle(&rx, skb, true))\n\t\t\t\treturn;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tprev = NULL;\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR ||\n\t\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\t\tcontinue;\n\n\t\t \n\n\t\tif (!prev) {\n\t\t\tprev = sdata;\n\t\t\tcontinue;\n\t\t}\n\n\t\trx.sdata = prev;\n\t\tieee80211_rx_for_interface(&rx, skb, false);\n\n\t\tprev = sdata;\n\t}\n\n\tif (prev) {\n\t\trx.sdata = prev;\n\n\t\tif (ieee80211_rx_for_interface(&rx, skb, true))\n\t\t\treturn;\n\t}\n\n out:\n\tdev_kfree_skb(skb);\n}\n\n \nvoid ieee80211_rx_list(struct ieee80211_hw *hw, struct ieee80211_sta *pubsta,\n\t\t       struct sk_buff *skb, struct list_head *list)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_rate *rate = NULL;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\n\tWARN_ON_ONCE(softirq_count() == 0);\n\n\tif (WARN_ON(status->band >= NUM_NL80211_BANDS))\n\t\tgoto drop;\n\n\tsband = local->hw.wiphy->bands[status->band];\n\tif (WARN_ON(!sband))\n\t\tgoto drop;\n\n\t \n\tif (unlikely(local->quiescing || local->suspended))\n\t\tgoto drop;\n\n\t \n\tif (unlikely(local->in_reconfig))\n\t\tgoto drop;\n\n\t \n\tif (WARN_ON(!local->started))\n\t\tgoto drop;\n\n\tif (likely(!(status->flag & RX_FLAG_FAILED_PLCP_CRC))) {\n\t\t \n\n\t\tswitch (status->encoding) {\n\t\tcase RX_ENC_HT:\n\t\t\t \n\t\t\tif (WARN(status->rate_idx > 76,\n\t\t\t\t \"Rate marked as an HT rate but passed \"\n\t\t\t\t \"status->rate_idx is not \"\n\t\t\t\t \"an MCS index [0-76]: %d (0x%02x)\\n\",\n\t\t\t\t status->rate_idx,\n\t\t\t\t status->rate_idx))\n\t\t\t\tgoto drop;\n\t\t\tbreak;\n\t\tcase RX_ENC_VHT:\n\t\t\tif (WARN_ONCE(status->rate_idx > 11 ||\n\t\t\t\t      !status->nss ||\n\t\t\t\t      status->nss > 8,\n\t\t\t\t      \"Rate marked as a VHT rate but data is invalid: MCS: %d, NSS: %d\\n\",\n\t\t\t\t      status->rate_idx, status->nss))\n\t\t\t\tgoto drop;\n\t\t\tbreak;\n\t\tcase RX_ENC_HE:\n\t\t\tif (WARN_ONCE(status->rate_idx > 11 ||\n\t\t\t\t      !status->nss ||\n\t\t\t\t      status->nss > 8,\n\t\t\t\t      \"Rate marked as an HE rate but data is invalid: MCS: %d, NSS: %d\\n\",\n\t\t\t\t      status->rate_idx, status->nss))\n\t\t\t\tgoto drop;\n\t\t\tbreak;\n\t\tcase RX_ENC_EHT:\n\t\t\tif (WARN_ONCE(status->rate_idx > 15 ||\n\t\t\t\t      !status->nss ||\n\t\t\t\t      status->nss > 8 ||\n\t\t\t\t      status->eht.gi > NL80211_RATE_INFO_EHT_GI_3_2,\n\t\t\t\t      \"Rate marked as an EHT rate but data is invalid: MCS:%d, NSS:%d, GI:%d\\n\",\n\t\t\t\t      status->rate_idx, status->nss, status->eht.gi))\n\t\t\t\tgoto drop;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tfallthrough;\n\t\tcase RX_ENC_LEGACY:\n\t\t\tif (WARN_ON(status->rate_idx >= sband->n_bitrates))\n\t\t\t\tgoto drop;\n\t\t\trate = &sband->bitrates[status->rate_idx];\n\t\t}\n\t}\n\n\tif (WARN_ON_ONCE(status->link_id >= IEEE80211_LINK_UNSPECIFIED))\n\t\tgoto drop;\n\n\tstatus->rx_flags = 0;\n\n\tkcov_remote_start_common(skb_get_kcov_handle(skb));\n\n\t \n\tif (!(status->flag & RX_FLAG_8023))\n\t\tskb = ieee80211_rx_monitor(local, skb, rate);\n\tif (skb) {\n\t\tif ((status->flag & RX_FLAG_8023) ||\n\t\t\tieee80211_is_data_present(hdr->frame_control))\n\t\t\tieee80211_tpt_led_trig_rx(local, skb->len);\n\n\t\tif (status->flag & RX_FLAG_8023)\n\t\t\t__ieee80211_rx_handle_8023(hw, pubsta, skb, list);\n\t\telse\n\t\t\t__ieee80211_rx_handle_packet(hw, pubsta, skb, list);\n\t}\n\n\tkcov_remote_stop();\n\treturn;\n drop:\n\tkfree_skb(skb);\n}\nEXPORT_SYMBOL(ieee80211_rx_list);\n\nvoid ieee80211_rx_napi(struct ieee80211_hw *hw, struct ieee80211_sta *pubsta,\n\t\t       struct sk_buff *skb, struct napi_struct *napi)\n{\n\tstruct sk_buff *tmp;\n\tLIST_HEAD(list);\n\n\n\t \n\trcu_read_lock();\n\tieee80211_rx_list(hw, pubsta, skb, &list);\n\trcu_read_unlock();\n\n\tif (!napi) {\n\t\tnetif_receive_skb_list(&list);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(skb, tmp, &list, list) {\n\t\tskb_list_del_init(skb);\n\t\tnapi_gro_receive(napi, skb);\n\t}\n}\nEXPORT_SYMBOL(ieee80211_rx_napi);\n\n \nvoid ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tBUILD_BUG_ON(sizeof(struct ieee80211_rx_status) > sizeof(skb->cb));\n\n\tskb->pkt_type = IEEE80211_RX_MSG;\n\tskb_queue_tail(&local->skb_queue, skb);\n\ttasklet_schedule(&local->tasklet);\n}\nEXPORT_SYMBOL(ieee80211_rx_irqsafe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}