{
  "module_name": "rate.c",
  "hash_id": "f72ceb128fc1688e364952f42d953905bc9b2d7904491676c34ddf606b5a0638",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/rate.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/rtnetlink.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"rate.h\"\n#include \"ieee80211_i.h\"\n#include \"debugfs.h\"\n\nstruct rate_control_alg {\n\tstruct list_head list;\n\tconst struct rate_control_ops *ops;\n};\n\nstatic LIST_HEAD(rate_ctrl_algs);\nstatic DEFINE_MUTEX(rate_ctrl_mutex);\n\nstatic char *ieee80211_default_rc_algo = CONFIG_MAC80211_RC_DEFAULT;\nmodule_param(ieee80211_default_rc_algo, charp, 0644);\nMODULE_PARM_DESC(ieee80211_default_rc_algo,\n\t\t \"Default rate control algorithm for mac80211 to use\");\n\nvoid rate_control_rate_init(struct sta_info *sta)\n{\n\tstruct ieee80211_local *local = sta->sdata->local;\n\tstruct rate_control_ref *ref = sta->rate_ctrl;\n\tstruct ieee80211_sta *ista = &sta->sta;\n\tvoid *priv_sta = sta->rate_ctrl_priv;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tieee80211_sta_set_rx_nss(&sta->deflink);\n\n\tif (!ref)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tchanctx_conf = rcu_dereference(sta->sdata->vif.bss_conf.chanctx_conf);\n\tif (WARN_ON(!chanctx_conf)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tsband = local->hw.wiphy->bands[chanctx_conf->def.chan->band];\n\n\t \n\tif (sband->band == NL80211_BAND_S1GHZ) {\n\t\tieee80211_s1g_sta_rate_init(sta);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&sta->rate_ctrl_lock);\n\tref->ops->rate_init(ref->priv, sband, &chanctx_conf->def, ista,\n\t\t\t    priv_sta);\n\tspin_unlock_bh(&sta->rate_ctrl_lock);\n\trcu_read_unlock();\n\tset_sta_flag(sta, WLAN_STA_RATE_CONTROL);\n}\n\nvoid rate_control_tx_status(struct ieee80211_local *local,\n\t\t\t    struct ieee80211_tx_status *st)\n{\n\tstruct rate_control_ref *ref = local->rate_ctrl;\n\tstruct sta_info *sta = container_of(st->sta, struct sta_info, sta);\n\tvoid *priv_sta = sta->rate_ctrl_priv;\n\tstruct ieee80211_supported_band *sband;\n\n\tif (!ref || !test_sta_flag(sta, WLAN_STA_RATE_CONTROL))\n\t\treturn;\n\n\tsband = local->hw.wiphy->bands[st->info->band];\n\n\tspin_lock_bh(&sta->rate_ctrl_lock);\n\tif (ref->ops->tx_status_ext)\n\t\tref->ops->tx_status_ext(ref->priv, sband, priv_sta, st);\n\telse if (st->skb)\n\t\tref->ops->tx_status(ref->priv, sband, st->sta, priv_sta, st->skb);\n\telse\n\t\tWARN_ON_ONCE(1);\n\n\tspin_unlock_bh(&sta->rate_ctrl_lock);\n}\n\nvoid rate_control_rate_update(struct ieee80211_local *local,\n\t\t\t      struct ieee80211_supported_band *sband,\n\t\t\t      struct sta_info *sta, unsigned int link_id,\n\t\t\t      u32 changed)\n{\n\tstruct rate_control_ref *ref = local->rate_ctrl;\n\tstruct ieee80211_sta *ista = &sta->sta;\n\tvoid *priv_sta = sta->rate_ctrl_priv;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\n\tWARN_ON(link_id != 0);\n\n\tif (ref && ref->ops->rate_update) {\n\t\trcu_read_lock();\n\n\t\tchanctx_conf = rcu_dereference(sta->sdata->vif.bss_conf.chanctx_conf);\n\t\tif (WARN_ON(!chanctx_conf)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock_bh(&sta->rate_ctrl_lock);\n\t\tref->ops->rate_update(ref->priv, sband, &chanctx_conf->def,\n\t\t\t\t      ista, priv_sta, changed);\n\t\tspin_unlock_bh(&sta->rate_ctrl_lock);\n\t\trcu_read_unlock();\n\t}\n\n\tdrv_sta_rc_update(local, sta->sdata, &sta->sta, changed);\n}\n\nint ieee80211_rate_control_register(const struct rate_control_ops *ops)\n{\n\tstruct rate_control_alg *alg;\n\n\tif (!ops->name)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rate_ctrl_mutex);\n\tlist_for_each_entry(alg, &rate_ctrl_algs, list) {\n\t\tif (!strcmp(alg->ops->name, ops->name)) {\n\t\t\t \n\t\t\tWARN_ON(1);\n\t\t\tmutex_unlock(&rate_ctrl_mutex);\n\t\t\treturn -EALREADY;\n\t\t}\n\t}\n\n\talg = kzalloc(sizeof(*alg), GFP_KERNEL);\n\tif (alg == NULL) {\n\t\tmutex_unlock(&rate_ctrl_mutex);\n\t\treturn -ENOMEM;\n\t}\n\talg->ops = ops;\n\n\tlist_add_tail(&alg->list, &rate_ctrl_algs);\n\tmutex_unlock(&rate_ctrl_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_rate_control_register);\n\nvoid ieee80211_rate_control_unregister(const struct rate_control_ops *ops)\n{\n\tstruct rate_control_alg *alg;\n\n\tmutex_lock(&rate_ctrl_mutex);\n\tlist_for_each_entry(alg, &rate_ctrl_algs, list) {\n\t\tif (alg->ops == ops) {\n\t\t\tlist_del(&alg->list);\n\t\t\tkfree(alg);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&rate_ctrl_mutex);\n}\nEXPORT_SYMBOL(ieee80211_rate_control_unregister);\n\nstatic const struct rate_control_ops *\nieee80211_try_rate_control_ops_get(const char *name)\n{\n\tstruct rate_control_alg *alg;\n\tconst struct rate_control_ops *ops = NULL;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tmutex_lock(&rate_ctrl_mutex);\n\tlist_for_each_entry(alg, &rate_ctrl_algs, list) {\n\t\tif (!strcmp(alg->ops->name, name)) {\n\t\t\tops = alg->ops;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&rate_ctrl_mutex);\n\treturn ops;\n}\n\n \nstatic const struct rate_control_ops *\nieee80211_rate_control_ops_get(const char *name)\n{\n\tconst struct rate_control_ops *ops;\n\tconst char *alg_name;\n\n\tkernel_param_lock(THIS_MODULE);\n\tif (!name)\n\t\talg_name = ieee80211_default_rc_algo;\n\telse\n\t\talg_name = name;\n\n\tops = ieee80211_try_rate_control_ops_get(alg_name);\n\tif (!ops && name)\n\t\t \n\t\tops = ieee80211_try_rate_control_ops_get(ieee80211_default_rc_algo);\n\n\t \n\tif (!ops && (strlen(CONFIG_MAC80211_RC_DEFAULT) > 0))\n\t\t \n\t\tops = ieee80211_try_rate_control_ops_get(CONFIG_MAC80211_RC_DEFAULT);\n\n\tkernel_param_unlock(THIS_MODULE);\n\n\treturn ops;\n}\n\n#ifdef CONFIG_MAC80211_DEBUGFS\nstatic ssize_t rcname_read(struct file *file, char __user *userbuf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct rate_control_ref *ref = file->private_data;\n\tint len = strlen(ref->ops->name);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos,\n\t\t\t\t       ref->ops->name, len);\n}\n\nconst struct file_operations rcname_ops = {\n\t.read = rcname_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n#endif\n\nstatic struct rate_control_ref *\nrate_control_alloc(const char *name, struct ieee80211_local *local)\n{\n\tstruct rate_control_ref *ref;\n\n\tref = kmalloc(sizeof(struct rate_control_ref), GFP_KERNEL);\n\tif (!ref)\n\t\treturn NULL;\n\tref->ops = ieee80211_rate_control_ops_get(name);\n\tif (!ref->ops)\n\t\tgoto free;\n\n\tref->priv = ref->ops->alloc(&local->hw);\n\tif (!ref->priv)\n\t\tgoto free;\n\treturn ref;\n\nfree:\n\tkfree(ref);\n\treturn NULL;\n}\n\nstatic void rate_control_free(struct ieee80211_local *local,\n\t\t\t      struct rate_control_ref *ctrl_ref)\n{\n\tctrl_ref->ops->free(ctrl_ref->priv);\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tdebugfs_remove_recursive(local->debugfs.rcdir);\n\tlocal->debugfs.rcdir = NULL;\n#endif\n\n\tkfree(ctrl_ref);\n}\n\nvoid ieee80211_check_rate_mask(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_supported_band *sband;\n\tu32 user_mask, basic_rates = link->conf->basic_rates;\n\tenum nl80211_band band;\n\n\tif (WARN_ON(!link->conf->chandef.chan))\n\t\treturn;\n\n\tband = link->conf->chandef.chan->band;\n\tif (band == NL80211_BAND_S1GHZ) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!basic_rates))\n\t\treturn;\n\n\tuser_mask = sdata->rc_rateidx_mask[band];\n\tsband = local->hw.wiphy->bands[band];\n\n\tif (user_mask & basic_rates)\n\t\treturn;\n\n\tsdata_dbg(sdata,\n\t\t  \"no overlap between basic rates (0x%x) and user mask (0x%x on band %d) - clearing the latter\",\n\t\t  basic_rates, user_mask, band);\n\tsdata->rc_rateidx_mask[band] = (1 << sband->n_bitrates) - 1;\n}\n\nstatic bool rc_no_data_or_no_ack_use_min(struct ieee80211_tx_rate_control *txrc)\n{\n\tstruct sk_buff *skb = txrc->skb;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\treturn (info->flags & (IEEE80211_TX_CTL_NO_ACK |\n\t\t\t       IEEE80211_TX_CTL_USE_MINRATE)) ||\n\t\t!ieee80211_is_tx_data(skb);\n}\n\nstatic void rc_send_low_basicrate(struct ieee80211_tx_rate *rate,\n\t\t\t\t  u32 basic_rates,\n\t\t\t\t  struct ieee80211_supported_band *sband)\n{\n\tu8 i;\n\n\tif (sband->band == NL80211_BAND_S1GHZ) {\n\t\t \n\t\trate->flags |= IEEE80211_TX_RC_S1G_MCS;\n\t\trate->idx = 0;\n\t\treturn;\n\t}\n\n\tif (basic_rates == 0)\n\t\treturn;  \n\tif (rate->idx < 0)\n\t\treturn;\n\tif (basic_rates & (1 << rate->idx))\n\t\treturn;  \n\n\tfor (i = rate->idx + 1; i <= sband->n_bitrates; i++) {\n\t\tif (basic_rates & (1 << i)) {\n\t\t\trate->idx = i;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n}\n\nstatic void __rate_control_send_low(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct ieee80211_tx_info *info,\n\t\t\t\t    u32 rate_mask)\n{\n\tint i;\n\tu32 rate_flags =\n\t\tieee80211_chandef_rate_flags(&hw->conf.chandef);\n\n\tif (sband->band == NL80211_BAND_S1GHZ) {\n\t\tinfo->control.rates[0].flags |= IEEE80211_TX_RC_S1G_MCS;\n\t\tinfo->control.rates[0].idx = 0;\n\t\treturn;\n\t}\n\n\tif ((sband->band == NL80211_BAND_2GHZ) &&\n\t    (info->flags & IEEE80211_TX_CTL_NO_CCK_RATE))\n\t\trate_flags |= IEEE80211_RATE_ERP_G;\n\n\tinfo->control.rates[0].idx = 0;\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tif (!(rate_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tif ((rate_flags & sband->bitrates[i].flags) != rate_flags)\n\t\t\tcontinue;\n\n\t\tif (!rate_supported(sta, sband->band, i))\n\t\t\tcontinue;\n\n\t\tinfo->control.rates[0].idx = i;\n\t\tbreak;\n\t}\n\tWARN_ONCE(i == sband->n_bitrates,\n\t\t  \"no supported rates for sta %pM (0x%x, band %d) in rate_mask 0x%x with flags 0x%x\\n\",\n\t\t  sta ? sta->addr : NULL,\n\t\t  sta ? sta->deflink.supp_rates[sband->band] : -1,\n\t\t  sband->band,\n\t\t  rate_mask, rate_flags);\n\n\tinfo->control.rates[0].count =\n\t\t(info->flags & IEEE80211_TX_CTL_NO_ACK) ?\n\t\t1 : hw->max_rate_tries;\n\n\tinfo->control.skip_table = 1;\n}\n\n\nstatic bool rate_control_send_low(struct ieee80211_sta *pubsta,\n\t\t\t\t  struct ieee80211_tx_rate_control *txrc)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);\n\tstruct ieee80211_supported_band *sband = txrc->sband;\n\tstruct sta_info *sta;\n\tint mcast_rate;\n\tbool use_basicrate = false;\n\n\tif (!pubsta || rc_no_data_or_no_ack_use_min(txrc)) {\n\t\t__rate_control_send_low(txrc->hw, sband, pubsta, info,\n\t\t\t\t\ttxrc->rate_idx_mask);\n\n\t\tif (!pubsta && txrc->bss) {\n\t\t\tmcast_rate = txrc->bss_conf->mcast_rate[sband->band];\n\t\t\tif (mcast_rate > 0) {\n\t\t\t\tinfo->control.rates[0].idx = mcast_rate - 1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tuse_basicrate = true;\n\t\t} else if (pubsta) {\n\t\t\tsta = container_of(pubsta, struct sta_info, sta);\n\t\t\tif (ieee80211_vif_is_mesh(&sta->sdata->vif))\n\t\t\t\tuse_basicrate = true;\n\t\t}\n\n\t\tif (use_basicrate)\n\t\t\trc_send_low_basicrate(&info->control.rates[0],\n\t\t\t\t\t      txrc->bss_conf->basic_rates,\n\t\t\t\t\t      sband);\n\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool rate_idx_match_legacy_mask(s8 *rate_idx, int n_bitrates, u32 mask)\n{\n\tint j;\n\n\t \n\tfor (j = *rate_idx; j >= 0; j--) {\n\t\tif (mask & (1 << j)) {\n\t\t\t \n\t\t\t*rate_idx = j;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t \n\tfor (j = *rate_idx + 1; j < n_bitrates; j++) {\n\t\tif (mask & (1 << j)) {\n\t\t\t \n\t\t\t*rate_idx = j;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool rate_idx_match_mcs_mask(s8 *rate_idx, u8 *mcs_mask)\n{\n\tint i, j;\n\tint ridx, rbit;\n\n\tridx = *rate_idx / 8;\n\trbit = *rate_idx % 8;\n\n\t \n\tif (ridx < 0 || ridx >= IEEE80211_HT_MCS_MASK_LEN)\n\t\treturn false;\n\n\t \n\tfor (i = ridx; i >= 0; i--) {\n\t\tfor (j = rbit; j >= 0; j--)\n\t\t\tif (mcs_mask[i] & BIT(j)) {\n\t\t\t\t*rate_idx = i * 8 + j;\n\t\t\t\treturn true;\n\t\t\t}\n\t\trbit = 7;\n\t}\n\n\t \n\tridx = (*rate_idx + 1) / 8;\n\trbit = (*rate_idx + 1) % 8;\n\n\tfor (i = ridx; i < IEEE80211_HT_MCS_MASK_LEN; i++) {\n\t\tfor (j = rbit; j < 8; j++)\n\t\t\tif (mcs_mask[i] & BIT(j)) {\n\t\t\t\t*rate_idx = i * 8 + j;\n\t\t\t\treturn true;\n\t\t\t}\n\t\trbit = 0;\n\t}\n\treturn false;\n}\n\nstatic bool rate_idx_match_vht_mcs_mask(s8 *rate_idx, u16 *vht_mask)\n{\n\tint i, j;\n\tint ridx, rbit;\n\n\tridx = *rate_idx >> 4;\n\trbit = *rate_idx & 0xf;\n\n\tif (ridx < 0 || ridx >= NL80211_VHT_NSS_MAX)\n\t\treturn false;\n\n\t \n\tfor (i = ridx; i >= 0; i--) {\n\t\tfor (j = rbit; j >= 0; j--) {\n\t\t\tif (vht_mask[i] & BIT(j)) {\n\t\t\t\t*rate_idx = (i << 4) | j;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\trbit = 15;\n\t}\n\n\t \n\tridx = (*rate_idx + 1) >> 4;\n\trbit = (*rate_idx + 1) & 0xf;\n\n\tfor (i = ridx; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tfor (j = rbit; j < 16; j++) {\n\t\t\tif (vht_mask[i] & BIT(j)) {\n\t\t\t\t*rate_idx = (i << 4) | j;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\trbit = 0;\n\t}\n\treturn false;\n}\n\nstatic void rate_idx_match_mask(s8 *rate_idx, u16 *rate_flags,\n\t\t\t\tstruct ieee80211_supported_band *sband,\n\t\t\t\tenum nl80211_chan_width chan_width,\n\t\t\t\tu32 mask,\n\t\t\t\tu8 mcs_mask[IEEE80211_HT_MCS_MASK_LEN],\n\t\t\t\tu16 vht_mask[NL80211_VHT_NSS_MAX])\n{\n\tif (*rate_flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\t \n\t\tif (rate_idx_match_vht_mcs_mask(rate_idx, vht_mask))\n\t\t\treturn;\n\n\t\t*rate_idx = 0;\n\t\t \n\t\t*rate_flags &= (IEEE80211_TX_RC_USE_RTS_CTS |\n\t\t\t\tIEEE80211_TX_RC_USE_CTS_PROTECT |\n\t\t\t\tIEEE80211_TX_RC_USE_SHORT_PREAMBLE);\n\n\t\t*rate_flags |= IEEE80211_TX_RC_MCS;\n\t\tif (chan_width == NL80211_CHAN_WIDTH_40)\n\t\t\t*rate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\n\t\tif (rate_idx_match_mcs_mask(rate_idx, mcs_mask))\n\t\t\treturn;\n\n\t\t \n\t\t*rate_flags &= ~(IEEE80211_TX_RC_MCS |\n\t\t\t\t IEEE80211_TX_RC_40_MHZ_WIDTH);\n\t\tif (rate_idx_match_legacy_mask(rate_idx, sband->n_bitrates,\n\t\t\t\t\t       mask))\n\t\t\treturn;\n\t} else if (*rate_flags & IEEE80211_TX_RC_MCS) {\n\t\t \n\t\tif (rate_idx_match_mcs_mask(rate_idx, mcs_mask))\n\t\t\treturn;\n\n\t\t \n\t\t*rate_idx = 0;\n\t\t \n\t\t*rate_flags &= (IEEE80211_TX_RC_USE_RTS_CTS |\n\t\t\t\tIEEE80211_TX_RC_USE_CTS_PROTECT |\n\t\t\t\tIEEE80211_TX_RC_USE_SHORT_PREAMBLE);\n\t\tif (rate_idx_match_legacy_mask(rate_idx, sband->n_bitrates,\n\t\t\t\t\t       mask))\n\t\t\treturn;\n\t} else {\n\t\t \n\t\tif (rate_idx_match_legacy_mask(rate_idx, sband->n_bitrates,\n\t\t\t\t\t       mask))\n\t\t\treturn;\n\n\t\t \n\t\tswitch (chan_width) {\n\t\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tcase NL80211_CHAN_WIDTH_5:\n\t\tcase NL80211_CHAN_WIDTH_10:\n\t\t\treturn;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t*rate_idx = 0;\n\t\t \n\t\t*rate_flags &= (IEEE80211_TX_RC_USE_RTS_CTS |\n\t\t\t\tIEEE80211_TX_RC_USE_CTS_PROTECT |\n\t\t\t\tIEEE80211_TX_RC_USE_SHORT_PREAMBLE);\n\n\t\t*rate_flags |= IEEE80211_TX_RC_MCS;\n\n\t\tif (chan_width == NL80211_CHAN_WIDTH_40)\n\t\t\t*rate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\n\t\tif (rate_idx_match_mcs_mask(rate_idx, mcs_mask))\n\t\t\treturn;\n\t}\n\n\t \n}\n\nstatic void rate_fixup_ratelist(struct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_supported_band *sband,\n\t\t\t\tstruct ieee80211_tx_info *info,\n\t\t\t\tstruct ieee80211_tx_rate *rates,\n\t\t\t\tint max_rates)\n{\n\tstruct ieee80211_rate *rate;\n\tbool inval = false;\n\tint i;\n\n\t \n\tif (!(rates[0].flags &\n\t      (IEEE80211_TX_RC_MCS | IEEE80211_TX_RC_VHT_MCS))) {\n\t\tu32 basic_rates = vif->bss_conf.basic_rates;\n\t\ts8 baserate = basic_rates ? ffs(basic_rates) - 1 : 0;\n\n\t\trate = &sband->bitrates[rates[0].idx];\n\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\t \n\t\t\tif (!(basic_rates & BIT(i)))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (sband->bitrates[i].bitrate > rate->bitrate)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (sband->bitrates[baserate].bitrate <\n\t\t\t     sband->bitrates[i].bitrate)\n\t\t\t\tbaserate = i;\n\t\t}\n\n\t\tinfo->control.rts_cts_rate_idx = baserate;\n\t}\n\n\tfor (i = 0; i < max_rates; i++) {\n\t\t \n\t\tif (inval) {\n\t\t\trates[i].idx = -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (rates[i].idx < 0) {\n\t\t\tinval = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (rates[i].flags & IEEE80211_TX_RC_MCS) {\n\t\t\tWARN_ON(rates[i].idx > 76);\n\n\t\t\tif (!(rates[i].flags & IEEE80211_TX_RC_USE_RTS_CTS) &&\n\t\t\t    info->control.use_cts_prot)\n\t\t\t\trates[i].flags |=\n\t\t\t\t\tIEEE80211_TX_RC_USE_CTS_PROTECT;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rates[i].flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\t\tWARN_ON(ieee80211_rate_get_vht_mcs(&rates[i]) > 9);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (info->control.use_rts) {\n\t\t\trates[i].flags |= IEEE80211_TX_RC_USE_RTS_CTS;\n\t\t\tinfo->control.use_cts_prot = false;\n\t\t}\n\n\t\t \n\t\tif (WARN_ON_ONCE(rates[i].idx >= sband->n_bitrates)) {\n\t\t\trates[i].idx = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\trate = &sband->bitrates[rates[i].idx];\n\n\t\t \n\t\tif (info->control.short_preamble &&\n\t\t    rate->flags & IEEE80211_RATE_SHORT_PREAMBLE)\n\t\t\trates[i].flags |= IEEE80211_TX_RC_USE_SHORT_PREAMBLE;\n\n\t\t \n\t\tif (!(rates[i].flags & IEEE80211_TX_RC_USE_RTS_CTS) &&\n\t\t    info->control.use_cts_prot &&\n\t\t    rate->flags & IEEE80211_RATE_ERP_G)\n\t\t\trates[i].flags |= IEEE80211_TX_RC_USE_CTS_PROTECT;\n\t}\n}\n\n\nstatic void rate_control_fill_sta_table(struct ieee80211_sta *sta,\n\t\t\t\t\tstruct ieee80211_tx_info *info,\n\t\t\t\t\tstruct ieee80211_tx_rate *rates,\n\t\t\t\t\tint max_rates)\n{\n\tstruct ieee80211_sta_rates *ratetbl = NULL;\n\tint i;\n\n\tif (sta && !info->control.skip_table)\n\t\tratetbl = rcu_dereference(sta->rates);\n\n\t \n\tmax_rates = min_t(int, max_rates, IEEE80211_TX_RATE_TABLE_SIZE);\n\tfor (i = 0; i < max_rates; i++) {\n\t\tif (i < ARRAY_SIZE(info->control.rates) &&\n\t\t    info->control.rates[i].idx >= 0 &&\n\t\t    info->control.rates[i].count) {\n\t\t\tif (rates != info->control.rates)\n\t\t\t\trates[i] = info->control.rates[i];\n\t\t} else if (ratetbl) {\n\t\t\trates[i].idx = ratetbl->rate[i].idx;\n\t\t\trates[i].flags = ratetbl->rate[i].flags;\n\t\t\tif (info->control.use_rts)\n\t\t\t\trates[i].count = ratetbl->rate[i].count_rts;\n\t\t\telse if (info->control.use_cts_prot)\n\t\t\t\trates[i].count = ratetbl->rate[i].count_cts;\n\t\t\telse\n\t\t\t\trates[i].count = ratetbl->rate[i].count;\n\t\t} else {\n\t\t\trates[i].idx = -1;\n\t\t\trates[i].count = 0;\n\t\t}\n\n\t\tif (rates[i].idx < 0 || !rates[i].count)\n\t\t\tbreak;\n\t}\n}\n\nstatic bool rate_control_cap_mask(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct ieee80211_supported_band *sband,\n\t\t\t\t  struct ieee80211_sta *sta, u32 *mask,\n\t\t\t\t  u8 mcs_mask[IEEE80211_HT_MCS_MASK_LEN],\n\t\t\t\t  u16 vht_mask[NL80211_VHT_NSS_MAX])\n{\n\tu32 i, flags;\n\n\t*mask = sdata->rc_rateidx_mask[sband->band];\n\tflags = ieee80211_chandef_rate_flags(&sdata->vif.bss_conf.chandef);\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tif ((flags & sband->bitrates[i].flags) != flags)\n\t\t\t*mask &= ~BIT(i);\n\t}\n\n\tif (*mask == (1 << sband->n_bitrates) - 1 &&\n\t    !sdata->rc_has_mcs_mask[sband->band] &&\n\t    !sdata->rc_has_vht_mcs_mask[sband->band])\n\t\treturn false;\n\n\tif (sdata->rc_has_mcs_mask[sband->band])\n\t\tmemcpy(mcs_mask, sdata->rc_rateidx_mcs_mask[sband->band],\n\t\t       IEEE80211_HT_MCS_MASK_LEN);\n\telse\n\t\tmemset(mcs_mask, 0xff, IEEE80211_HT_MCS_MASK_LEN);\n\n\tif (sdata->rc_has_vht_mcs_mask[sband->band])\n\t\tmemcpy(vht_mask, sdata->rc_rateidx_vht_mcs_mask[sband->band],\n\t\t       sizeof(u16) * NL80211_VHT_NSS_MAX);\n\telse\n\t\tmemset(vht_mask, 0xff, sizeof(u16) * NL80211_VHT_NSS_MAX);\n\n\tif (sta) {\n\t\t__le16 sta_vht_cap;\n\t\tu16 sta_vht_mask[NL80211_VHT_NSS_MAX];\n\n\t\t \n\t\t*mask &= sta->deflink.supp_rates[sband->band];\n\t\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)\n\t\t\tmcs_mask[i] &= sta->deflink.ht_cap.mcs.rx_mask[i];\n\n\t\tsta_vht_cap = sta->deflink.vht_cap.vht_mcs.rx_mcs_map;\n\t\tieee80211_get_vht_mask_from_cap(sta_vht_cap, sta_vht_mask);\n\t\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++)\n\t\t\tvht_mask[i] &= sta_vht_mask[i];\n\t}\n\n\treturn true;\n}\n\nstatic void\nrate_control_apply_mask_ratetbl(struct sta_info *sta,\n\t\t\t\tstruct ieee80211_supported_band *sband,\n\t\t\t\tstruct ieee80211_sta_rates *rates)\n{\n\tint i;\n\tu32 mask;\n\tu8 mcs_mask[IEEE80211_HT_MCS_MASK_LEN];\n\tu16 vht_mask[NL80211_VHT_NSS_MAX];\n\tenum nl80211_chan_width chan_width;\n\n\tif (!rate_control_cap_mask(sta->sdata, sband, &sta->sta, &mask,\n\t\t\t\t   mcs_mask, vht_mask))\n\t\treturn;\n\n\tchan_width = sta->sdata->vif.bss_conf.chandef.width;\n\tfor (i = 0; i < IEEE80211_TX_RATE_TABLE_SIZE; i++) {\n\t\tif (rates->rate[i].idx < 0)\n\t\t\tbreak;\n\n\t\trate_idx_match_mask(&rates->rate[i].idx, &rates->rate[i].flags,\n\t\t\t\t    sband, chan_width, mask, mcs_mask,\n\t\t\t\t    vht_mask);\n\t}\n}\n\nstatic void rate_control_apply_mask(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t\t    struct ieee80211_tx_rate *rates,\n\t\t\t\t    int max_rates)\n{\n\tenum nl80211_chan_width chan_width;\n\tu8 mcs_mask[IEEE80211_HT_MCS_MASK_LEN];\n\tu32 mask;\n\tu16 rate_flags, vht_mask[NL80211_VHT_NSS_MAX];\n\tint i;\n\n\t \n\tif (!rate_control_cap_mask(sdata, sband, sta, &mask, mcs_mask,\n\t\t\t\t   vht_mask))\n\t\treturn;\n\n\t \n\tchan_width = sdata->vif.bss_conf.chandef.width;\n\tfor (i = 0; i < max_rates; i++) {\n\t\t \n\t\tif (rates[i].idx < 0)\n\t\t\tbreak;\n\n\t\trate_flags = rates[i].flags;\n\t\trate_idx_match_mask(&rates[i].idx, &rate_flags, sband,\n\t\t\t\t    chan_width, mask, mcs_mask, vht_mask);\n\t\trates[i].flags = rate_flags;\n\t}\n}\n\nvoid ieee80211_get_tx_rates(struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct ieee80211_tx_rate *dest,\n\t\t\t    int max_rates)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_supported_band *sband;\n\n\trate_control_fill_sta_table(sta, info, dest, max_rates);\n\n\tif (!vif)\n\t\treturn;\n\n\tsdata = vif_to_sdata(vif);\n\tsband = sdata->local->hw.wiphy->bands[info->band];\n\n\tif (ieee80211_is_tx_data(skb))\n\t\trate_control_apply_mask(sdata, sta, sband, dest, max_rates);\n\n\tif (dest[0].idx < 0)\n\t\t__rate_control_send_low(&sdata->local->hw, sband, sta, info,\n\t\t\t\t\tsdata->rc_rateidx_mask[info->band]);\n\n\tif (sta)\n\t\trate_fixup_ratelist(vif, sband, info, dest, max_rates);\n}\nEXPORT_SYMBOL(ieee80211_get_tx_rates);\n\nvoid rate_control_get_rate(struct ieee80211_sub_if_data *sdata,\n\t\t\t   struct sta_info *sta,\n\t\t\t   struct ieee80211_tx_rate_control *txrc)\n{\n\tstruct rate_control_ref *ref = sdata->local->rate_ctrl;\n\tvoid *priv_sta = NULL;\n\tstruct ieee80211_sta *ista = NULL;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(txrc->skb);\n\tint i;\n\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\tinfo->control.rates[i].idx = -1;\n\t\tinfo->control.rates[i].flags = 0;\n\t\tinfo->control.rates[i].count = 0;\n\t}\n\n\tif (rate_control_send_low(sta ? &sta->sta : NULL, txrc))\n\t\treturn;\n\n\tif (ieee80211_hw_check(&sdata->local->hw, HAS_RATE_CONTROL))\n\t\treturn;\n\n\tif (sta && test_sta_flag(sta, WLAN_STA_RATE_CONTROL)) {\n\t\tista = &sta->sta;\n\t\tpriv_sta = sta->rate_ctrl_priv;\n\t}\n\n\tif (ista) {\n\t\tspin_lock_bh(&sta->rate_ctrl_lock);\n\t\tref->ops->get_rate(ref->priv, ista, priv_sta, txrc);\n\t\tspin_unlock_bh(&sta->rate_ctrl_lock);\n\t} else {\n\t\trate_control_send_low(NULL, txrc);\n\t}\n\n\tif (ieee80211_hw_check(&sdata->local->hw, SUPPORTS_RC_TABLE))\n\t\treturn;\n\n\tieee80211_get_tx_rates(&sdata->vif, ista, txrc->skb,\n\t\t\t       info->control.rates,\n\t\t\t       ARRAY_SIZE(info->control.rates));\n}\n\nint rate_control_set_rates(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_sta *pubsta,\n\t\t\t   struct ieee80211_sta_rates *rates)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\tstruct ieee80211_sta_rates *old;\n\tstruct ieee80211_supported_band *sband;\n\n\tsband = ieee80211_get_sband(sta->sdata);\n\tif (!sband)\n\t\treturn -EINVAL;\n\trate_control_apply_mask_ratetbl(sta, sband, rates);\n\t \n\told = rcu_dereference_protected(pubsta->rates, true);\n\trcu_assign_pointer(pubsta->rates, rates);\n\tif (old)\n\t\tkfree_rcu(old, rcu_head);\n\n\tif (sta->uploaded)\n\t\tdrv_sta_rate_tbl_update(hw_to_local(hw), sta->sdata, pubsta);\n\n\tieee80211_sta_set_expected_throughput(pubsta, sta_get_expected_throughput(sta));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rate_control_set_rates);\n\nint ieee80211_init_rate_ctrl_alg(struct ieee80211_local *local,\n\t\t\t\t const char *name)\n{\n\tstruct rate_control_ref *ref;\n\n\tASSERT_RTNL();\n\n\tif (local->open_count)\n\t\treturn -EBUSY;\n\n\tif (ieee80211_hw_check(&local->hw, HAS_RATE_CONTROL)) {\n\t\tif (WARN_ON(!local->ops->set_rts_threshold))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tref = rate_control_alloc(name, local);\n\tif (!ref) {\n\t\twiphy_warn(local->hw.wiphy,\n\t\t\t   \"Failed to select rate control algorithm\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tWARN_ON(local->rate_ctrl);\n\tlocal->rate_ctrl = ref;\n\n\twiphy_debug(local->hw.wiphy, \"Selected rate control algorithm '%s'\\n\",\n\t\t    ref->ops->name);\n\n\treturn 0;\n}\n\nvoid rate_control_deinitialize(struct ieee80211_local *local)\n{\n\tstruct rate_control_ref *ref;\n\n\tref = local->rate_ctrl;\n\n\tif (!ref)\n\t\treturn;\n\n\tlocal->rate_ctrl = NULL;\n\trate_control_free(local, ref);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}