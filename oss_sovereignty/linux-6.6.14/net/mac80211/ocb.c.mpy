{
  "module_name": "ocb.c",
  "hash_id": "21526e25f5f010a07aa2af316f353ae93191ea3bea26f6c877527ae88cb3d626",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/ocb.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/if_ether.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <net/mac80211.h>\n#include <asm/unaligned.h>\n\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n#include \"rate.h\"\n\n#define IEEE80211_OCB_HOUSEKEEPING_INTERVAL\t\t(60 * HZ)\n#define IEEE80211_OCB_PEER_INACTIVITY_LIMIT\t\t(240 * HZ)\n#define IEEE80211_OCB_MAX_STA_ENTRIES\t\t\t128\n\n \nenum ocb_deferred_task_flags {\n\tOCB_WORK_HOUSEKEEPING,\n};\n\nvoid ieee80211_ocb_rx_no_sta(struct ieee80211_sub_if_data *sdata,\n\t\t\t     const u8 *bssid, const u8 *addr,\n\t\t\t     u32 supp_rates)\n{\n\tstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_supported_band *sband;\n\tenum nl80211_bss_scan_width scan_width;\n\tstruct sta_info *sta;\n\tint band;\n\n\t \n\tif (local->num_sta >= IEEE80211_OCB_MAX_STA_ENTRIES) {\n\t\tnet_info_ratelimited(\"%s: No room for a new OCB STA entry %pM\\n\",\n\t\t\t\t     sdata->name, addr);\n\t\treturn;\n\t}\n\n\tocb_dbg(sdata, \"Adding new OCB station %pM\\n\", addr);\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);\n\tif (WARN_ON_ONCE(!chanctx_conf)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tband = chanctx_conf->def.chan->band;\n\tscan_width = cfg80211_chandef_to_scan_width(&chanctx_conf->def);\n\trcu_read_unlock();\n\n\tsta = sta_info_alloc(sdata, addr, GFP_ATOMIC);\n\tif (!sta)\n\t\treturn;\n\n\t \n\tsband = local->hw.wiphy->bands[band];\n\tsta->sta.deflink.supp_rates[band] =\n\t\tieee80211_mandatory_rates(sband, scan_width);\n\n\tspin_lock(&ifocb->incomplete_lock);\n\tlist_add(&sta->list, &ifocb->incomplete_stations);\n\tspin_unlock(&ifocb->incomplete_lock);\n\twiphy_work_queue(local->hw.wiphy, &sdata->work);\n}\n\nstatic struct sta_info *ieee80211_ocb_finish_sta(struct sta_info *sta)\n\t__acquires(RCU)\n{\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tu8 addr[ETH_ALEN];\n\n\tmemcpy(addr, sta->sta.addr, ETH_ALEN);\n\n\tocb_dbg(sdata, \"Adding new IBSS station %pM (dev=%s)\\n\",\n\t\taddr, sdata->name);\n\n\tsta_info_move_state(sta, IEEE80211_STA_AUTH);\n\tsta_info_move_state(sta, IEEE80211_STA_ASSOC);\n\tsta_info_move_state(sta, IEEE80211_STA_AUTHORIZED);\n\n\trate_control_rate_init(sta);\n\n\t \n\tif (sta_info_insert_rcu(sta))\n\t\treturn sta_info_get(sdata, addr);\n\treturn sta;\n}\n\nstatic void ieee80211_ocb_housekeeping(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\n\n\tocb_dbg(sdata, \"Running ocb housekeeping\\n\");\n\n\tieee80211_sta_expire(sdata, IEEE80211_OCB_PEER_INACTIVITY_LIMIT);\n\n\tmod_timer(&ifocb->housekeeping_timer,\n\t\t  round_jiffies(jiffies + IEEE80211_OCB_HOUSEKEEPING_INTERVAL));\n}\n\nvoid ieee80211_ocb_work(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\n\tstruct sta_info *sta;\n\n\tif (ifocb->joined != true)\n\t\treturn;\n\n\tsdata_lock(sdata);\n\n\tspin_lock_bh(&ifocb->incomplete_lock);\n\twhile (!list_empty(&ifocb->incomplete_stations)) {\n\t\tsta = list_first_entry(&ifocb->incomplete_stations,\n\t\t\t\t       struct sta_info, list);\n\t\tlist_del(&sta->list);\n\t\tspin_unlock_bh(&ifocb->incomplete_lock);\n\n\t\tieee80211_ocb_finish_sta(sta);\n\t\trcu_read_unlock();\n\t\tspin_lock_bh(&ifocb->incomplete_lock);\n\t}\n\tspin_unlock_bh(&ifocb->incomplete_lock);\n\n\tif (test_and_clear_bit(OCB_WORK_HOUSEKEEPING, &ifocb->wrkq_flags))\n\t\tieee80211_ocb_housekeeping(sdata);\n\n\tsdata_unlock(sdata);\n}\n\nstatic void ieee80211_ocb_housekeeping_timer(struct timer_list *t)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tfrom_timer(sdata, t, u.ocb.housekeeping_timer);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\n\n\tset_bit(OCB_WORK_HOUSEKEEPING, &ifocb->wrkq_flags);\n\n\twiphy_work_queue(local->hw.wiphy, &sdata->work);\n}\n\nvoid ieee80211_ocb_setup_sdata(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\n\n\ttimer_setup(&ifocb->housekeeping_timer,\n\t\t    ieee80211_ocb_housekeeping_timer, 0);\n\tINIT_LIST_HEAD(&ifocb->incomplete_stations);\n\tspin_lock_init(&ifocb->incomplete_lock);\n}\n\nint ieee80211_ocb_join(struct ieee80211_sub_if_data *sdata,\n\t\t       struct ocb_setup *setup)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\n\tu64 changed = BSS_CHANGED_OCB | BSS_CHANGED_BSSID;\n\tint err;\n\n\tif (ifocb->joined == true)\n\t\treturn -EINVAL;\n\n\tsdata->deflink.operating_11g_mode = true;\n\tsdata->deflink.smps_mode = IEEE80211_SMPS_OFF;\n\tsdata->deflink.needed_rx_chains = sdata->local->rx_chains;\n\n\tmutex_lock(&sdata->local->mtx);\n\terr = ieee80211_link_use_channel(&sdata->deflink, &setup->chandef,\n\t\t\t\t\t IEEE80211_CHANCTX_SHARED);\n\tmutex_unlock(&sdata->local->mtx);\n\tif (err)\n\t\treturn err;\n\n\tieee80211_bss_info_change_notify(sdata, changed);\n\n\tifocb->joined = true;\n\n\tset_bit(OCB_WORK_HOUSEKEEPING, &ifocb->wrkq_flags);\n\twiphy_work_queue(local->hw.wiphy, &sdata->work);\n\n\tnetif_carrier_on(sdata->dev);\n\treturn 0;\n}\n\nint ieee80211_ocb_leave(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_ocb *ifocb = &sdata->u.ocb;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\n\tifocb->joined = false;\n\tsta_info_flush(sdata);\n\n\tspin_lock_bh(&ifocb->incomplete_lock);\n\twhile (!list_empty(&ifocb->incomplete_stations)) {\n\t\tsta = list_first_entry(&ifocb->incomplete_stations,\n\t\t\t\t       struct sta_info, list);\n\t\tlist_del(&sta->list);\n\t\tspin_unlock_bh(&ifocb->incomplete_lock);\n\n\t\tsta_info_free(local, sta);\n\t\tspin_lock_bh(&ifocb->incomplete_lock);\n\t}\n\tspin_unlock_bh(&ifocb->incomplete_lock);\n\n\tnetif_carrier_off(sdata->dev);\n\tclear_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);\n\tieee80211_bss_info_change_notify(sdata, BSS_CHANGED_OCB);\n\n\tmutex_lock(&sdata->local->mtx);\n\tieee80211_link_release_channel(&sdata->deflink);\n\tmutex_unlock(&sdata->local->mtx);\n\n\tskb_queue_purge(&sdata->skb_queue);\n\n\tdel_timer_sync(&sdata->u.ocb.housekeeping_timer);\n\t \n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}