{
  "module_name": "ht.c",
  "hash_id": "43fa9ae460c5267d7bcea53e26fc184c9a5cc74b3a1a0db42b90151f04159042",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/ht.c",
  "human_readable_source": "\n \n\n#include <linux/ieee80211.h>\n#include <linux/export.h>\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"rate.h\"\n\nstatic void __check_htcap_disable(struct ieee80211_ht_cap *ht_capa,\n\t\t\t\t  struct ieee80211_ht_cap *ht_capa_mask,\n\t\t\t\t  struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t\t  u16 flag)\n{\n\t__le16 le_flag = cpu_to_le16(flag);\n\tif (ht_capa_mask->cap_info & le_flag) {\n\t\tif (!(ht_capa->cap_info & le_flag))\n\t\t\tht_cap->cap &= ~flag;\n\t}\n}\n\nstatic void __check_htcap_enable(struct ieee80211_ht_cap *ht_capa,\n\t\t\t\t  struct ieee80211_ht_cap *ht_capa_mask,\n\t\t\t\t  struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t\t  u16 flag)\n{\n\t__le16 le_flag = cpu_to_le16(flag);\n\n\tif ((ht_capa_mask->cap_info & le_flag) &&\n\t    (ht_capa->cap_info & le_flag))\n\t\tht_cap->cap |= flag;\n}\n\nvoid ieee80211_apply_htcap_overrides(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t     struct ieee80211_sta_ht_cap *ht_cap)\n{\n\tstruct ieee80211_ht_cap *ht_capa, *ht_capa_mask;\n\tu8 *scaps, *smask;\n\tint i;\n\n\tif (!ht_cap->ht_supported)\n\t\treturn;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tht_capa = &sdata->u.mgd.ht_capa;\n\t\tht_capa_mask = &sdata->u.mgd.ht_capa_mask;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tht_capa = &sdata->u.ibss.ht_capa;\n\t\tht_capa_mask = &sdata->u.ibss.ht_capa_mask;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tscaps = (u8 *)(&ht_capa->mcs.rx_mask);\n\tsmask = (u8 *)(&ht_capa_mask->mcs.rx_mask);\n\n\t \n\n\t \n\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++) {\n\t\tu8 m = smask[i];\n\t\tht_cap->mcs.rx_mask[i] &= ~m;  \n\t\t \n\t\tht_cap->mcs.rx_mask[i] |= (m & scaps[i]);\n\t}\n\n\t \n\t__check_htcap_disable(ht_capa, ht_capa_mask, ht_cap,\n\t\t\t      IEEE80211_HT_CAP_SUP_WIDTH_20_40);\n\t__check_htcap_disable(ht_capa, ht_capa_mask, ht_cap,\n\t\t\t      IEEE80211_HT_CAP_SGI_40);\n\n\t \n\t__check_htcap_disable(ht_capa, ht_capa_mask, ht_cap,\n\t\t\t      IEEE80211_HT_CAP_SGI_20);\n\n\t \n\t__check_htcap_disable(ht_capa, ht_capa_mask, ht_cap,\n\t\t\t      IEEE80211_HT_CAP_MAX_AMSDU);\n\n\t \n\t__check_htcap_disable(ht_capa, ht_capa_mask, ht_cap,\n\t\t\t      IEEE80211_HT_CAP_LDPC_CODING);\n\n\t \n\t__check_htcap_enable(ht_capa, ht_capa_mask, ht_cap,\n\t\t\t     IEEE80211_HT_CAP_40MHZ_INTOLERANT);\n\n\t \n\t__check_htcap_enable(ht_capa, ht_capa_mask, ht_cap,\n\t\t\t     IEEE80211_HT_CAP_TX_STBC);\n\n\t \n\tif (ht_capa_mask->cap_info & cpu_to_le16(IEEE80211_HT_CAP_RX_STBC))\n\t\tht_cap->cap |= le16_to_cpu(ht_capa->cap_info) &\n\t\t\t\t\tIEEE80211_HT_CAP_RX_STBC;\n\n\t \n\tif (ht_capa_mask->ampdu_params_info &\n\t    IEEE80211_HT_AMPDU_PARM_FACTOR) {\n\t\tu8 n = ht_capa->ampdu_params_info &\n\t\t       IEEE80211_HT_AMPDU_PARM_FACTOR;\n\t\tif (n < ht_cap->ampdu_factor)\n\t\t\tht_cap->ampdu_factor = n;\n\t}\n\n\t \n\tif (ht_capa_mask->ampdu_params_info &\n\t    IEEE80211_HT_AMPDU_PARM_DENSITY) {\n\t\tu8 n = (ht_capa->ampdu_params_info &\n\t\t\tIEEE80211_HT_AMPDU_PARM_DENSITY)\n\t\t\t>> IEEE80211_HT_AMPDU_PARM_DENSITY_SHIFT;\n\t\tif (n > ht_cap->ampdu_density)\n\t\t\tht_cap->ampdu_density = n;\n\t}\n}\n\n\nbool ieee80211_ht_cap_ie_to_sta_ht_cap(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t       struct ieee80211_supported_band *sband,\n\t\t\t\t       const struct ieee80211_ht_cap *ht_cap_ie,\n\t\t\t\t       struct link_sta_info *link_sta)\n{\n\tstruct ieee80211_bss_conf *link_conf;\n\tstruct sta_info *sta = link_sta->sta;\n\tstruct ieee80211_sta_ht_cap ht_cap, own_cap;\n\tu8 ampdu_info, tx_mcs_set_cap;\n\tint i, max_tx_streams;\n\tbool changed;\n\tenum ieee80211_sta_rx_bandwidth bw;\n\tenum nl80211_chan_width width;\n\n\tmemset(&ht_cap, 0, sizeof(ht_cap));\n\n\tif (!ht_cap_ie || !sband->ht_cap.ht_supported)\n\t\tgoto apply;\n\n\tht_cap.ht_supported = true;\n\n\town_cap = sband->ht_cap;\n\n\t \n\tif (sdata->vif.type == NL80211_IFTYPE_STATION ||\n\t    sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\tieee80211_apply_htcap_overrides(sdata, &own_cap);\n\n\t \n\tht_cap.cap = le16_to_cpu(ht_cap_ie->cap_info) &\n\t\t(own_cap.cap | ~(IEEE80211_HT_CAP_LDPC_CODING |\n\t\t\t\t IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t\t\t IEEE80211_HT_CAP_GRN_FLD |\n\t\t\t\t IEEE80211_HT_CAP_SGI_20 |\n\t\t\t\t IEEE80211_HT_CAP_SGI_40 |\n\t\t\t\t IEEE80211_HT_CAP_DSSSCCK40));\n\n\t \n\tif (!(own_cap.cap & IEEE80211_HT_CAP_TX_STBC))\n\t\tht_cap.cap &= ~IEEE80211_HT_CAP_RX_STBC;\n\tif (!(own_cap.cap & IEEE80211_HT_CAP_RX_STBC))\n\t\tht_cap.cap &= ~IEEE80211_HT_CAP_TX_STBC;\n\n\tampdu_info = ht_cap_ie->ampdu_params_info;\n\tht_cap.ampdu_factor =\n\t\tampdu_info & IEEE80211_HT_AMPDU_PARM_FACTOR;\n\tht_cap.ampdu_density =\n\t\t(ampdu_info & IEEE80211_HT_AMPDU_PARM_DENSITY) >> 2;\n\n\t \n\ttx_mcs_set_cap = own_cap.mcs.tx_params;\n\n\t \n\tht_cap.mcs.tx_params = ht_cap_ie->mcs.tx_params;\n\n\t \n\tif (!(tx_mcs_set_cap & IEEE80211_HT_MCS_TX_DEFINED))\n\t\tgoto apply;\n\n\t \n\tif (tx_mcs_set_cap & IEEE80211_HT_MCS_TX_RX_DIFF)\n\t\tmax_tx_streams =\n\t\t\t((tx_mcs_set_cap & IEEE80211_HT_MCS_TX_MAX_STREAMS_MASK)\n\t\t\t\t>> IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT) + 1;\n\telse\n\t\tmax_tx_streams = IEEE80211_HT_MCS_TX_MAX_STREAMS;\n\n\t \n\tfor (i = 0; i < max_tx_streams; i++)\n\t\tht_cap.mcs.rx_mask[i] =\n\t\t\town_cap.mcs.rx_mask[i] & ht_cap_ie->mcs.rx_mask[i];\n\n\tif (tx_mcs_set_cap & IEEE80211_HT_MCS_TX_UNEQUAL_MODULATION)\n\t\tfor (i = IEEE80211_HT_MCS_UNEQUAL_MODULATION_START_BYTE;\n\t\t     i < IEEE80211_HT_MCS_MASK_LEN; i++)\n\t\t\tht_cap.mcs.rx_mask[i] =\n\t\t\t\town_cap.mcs.rx_mask[i] &\n\t\t\t\t\tht_cap_ie->mcs.rx_mask[i];\n\n\t \n\tif (own_cap.mcs.rx_mask[32/8] & ht_cap_ie->mcs.rx_mask[32/8] & 1)\n\t\tht_cap.mcs.rx_mask[32/8] |= 1;\n\n\t \n\tht_cap.mcs.rx_highest = ht_cap_ie->mcs.rx_highest;\n\n\tif (ht_cap.cap & IEEE80211_HT_CAP_MAX_AMSDU)\n\t\tlink_sta->pub->agg.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_HT_7935;\n\telse\n\t\tlink_sta->pub->agg.max_amsdu_len = IEEE80211_MAX_MPDU_LEN_HT_3839;\n\n\tieee80211_sta_recalc_aggregates(&sta->sta);\n\n apply:\n\tchanged = memcmp(&link_sta->pub->ht_cap, &ht_cap, sizeof(ht_cap));\n\n\tmemcpy(&link_sta->pub->ht_cap, &ht_cap, sizeof(ht_cap));\n\n\trcu_read_lock();\n\tlink_conf = rcu_dereference(sdata->vif.link_conf[link_sta->link_id]);\n\tif (WARN_ON(!link_conf))\n\t\twidth = NL80211_CHAN_WIDTH_20_NOHT;\n\telse\n\t\twidth = link_conf->chandef.width;\n\n\tswitch (width) {\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tbw = IEEE80211_STA_RX_BW_20;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\tcase NL80211_CHAN_WIDTH_320:\n\t\tbw = ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?\n\t\t\t\tIEEE80211_STA_RX_BW_40 : IEEE80211_STA_RX_BW_20;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tlink_sta->pub->bandwidth = bw;\n\n\tlink_sta->cur_max_bandwidth =\n\t\tht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40 ?\n\t\t\t\tIEEE80211_STA_RX_BW_40 : IEEE80211_STA_RX_BW_20;\n\n\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tenum ieee80211_smps_mode smps_mode;\n\n\t\tswitch ((ht_cap.cap & IEEE80211_HT_CAP_SM_PS)\n\t\t\t\t>> IEEE80211_HT_CAP_SM_PS_SHIFT) {\n\t\tcase WLAN_HT_CAP_SM_PS_INVALID:\n\t\tcase WLAN_HT_CAP_SM_PS_STATIC:\n\t\t\tsmps_mode = IEEE80211_SMPS_STATIC;\n\t\t\tbreak;\n\t\tcase WLAN_HT_CAP_SM_PS_DYNAMIC:\n\t\t\tsmps_mode = IEEE80211_SMPS_DYNAMIC;\n\t\t\tbreak;\n\t\tcase WLAN_HT_CAP_SM_PS_DISABLED:\n\t\t\tsmps_mode = IEEE80211_SMPS_OFF;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (smps_mode != link_sta->pub->smps_mode)\n\t\t\tchanged = true;\n\t\tlink_sta->pub->smps_mode = smps_mode;\n\t} else {\n\t\tlink_sta->pub->smps_mode = IEEE80211_SMPS_OFF;\n\t}\n\n\treturn changed;\n}\n\nvoid ieee80211_sta_tear_down_BA_sessions(struct sta_info *sta,\n\t\t\t\t\t enum ieee80211_agg_stop_reason reason)\n{\n\tint i;\n\n\tmutex_lock(&sta->ampdu_mlme.mtx);\n\tfor (i = 0; i <  IEEE80211_NUM_TIDS; i++)\n\t\t___ieee80211_stop_rx_ba_session(sta, i, WLAN_BACK_RECIPIENT,\n\t\t\t\t\t\tWLAN_REASON_QSTA_LEAVE_QBSS,\n\t\t\t\t\t\treason != AGG_STOP_DESTROY_STA &&\n\t\t\t\t\t\treason != AGG_STOP_PEER_REQUEST);\n\n\tfor (i = 0; i <  IEEE80211_NUM_TIDS; i++)\n\t\t___ieee80211_stop_tx_ba_session(sta, i, reason);\n\tmutex_unlock(&sta->ampdu_mlme.mtx);\n\n\t \n\tif(reason == AGG_STOP_DESTROY_STA) {\n\t\tcancel_work_sync(&sta->ampdu_mlme.work);\n\n\t\tmutex_lock(&sta->ampdu_mlme.mtx);\n\t\tfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\n\t\t\tstruct tid_ampdu_tx *tid_tx =\n\t\t\t\trcu_dereference_protected_tid_tx(sta, i);\n\n\t\t\tif (!tid_tx)\n\t\t\t\tcontinue;\n\n\t\t\tif (test_and_clear_bit(HT_AGG_STATE_STOP_CB, &tid_tx->state))\n\t\t\t\tieee80211_stop_tx_ba_cb(sta, i, tid_tx);\n\t\t}\n\t\tmutex_unlock(&sta->ampdu_mlme.mtx);\n\t}\n}\n\nvoid ieee80211_ba_session_work(struct work_struct *work)\n{\n\tstruct sta_info *sta =\n\t\tcontainer_of(work, struct sta_info, ampdu_mlme.work);\n\tstruct tid_ampdu_tx *tid_tx;\n\tbool blocked;\n\tint tid;\n\n\t \n\tblocked = test_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\n\tmutex_lock(&sta->ampdu_mlme.mtx);\n\tfor (tid = 0; tid < IEEE80211_NUM_TIDS; tid++) {\n\t\tif (test_and_clear_bit(tid, sta->ampdu_mlme.tid_rx_timer_expired))\n\t\t\t___ieee80211_stop_rx_ba_session(\n\t\t\t\tsta, tid, WLAN_BACK_RECIPIENT,\n\t\t\t\tWLAN_REASON_QSTA_TIMEOUT, true);\n\n\t\tif (test_and_clear_bit(tid,\n\t\t\t\t       sta->ampdu_mlme.tid_rx_stop_requested))\n\t\t\t___ieee80211_stop_rx_ba_session(\n\t\t\t\tsta, tid, WLAN_BACK_RECIPIENT,\n\t\t\t\tWLAN_REASON_UNSPECIFIED, true);\n\n\t\tif (!blocked &&\n\t\t    test_and_clear_bit(tid,\n\t\t\t\t       sta->ampdu_mlme.tid_rx_manage_offl))\n\t\t\t___ieee80211_start_rx_ba_session(sta, 0, 0, 0, 1, tid,\n\t\t\t\t\t\t\t IEEE80211_MAX_AMPDU_BUF_HT,\n\t\t\t\t\t\t\t false, true, NULL);\n\n\t\tif (test_and_clear_bit(tid + IEEE80211_NUM_TIDS,\n\t\t\t\t       sta->ampdu_mlme.tid_rx_manage_offl))\n\t\t\t___ieee80211_stop_rx_ba_session(\n\t\t\t\tsta, tid, WLAN_BACK_RECIPIENT,\n\t\t\t\t0, false);\n\n\t\tspin_lock_bh(&sta->lock);\n\n\t\ttid_tx = sta->ampdu_mlme.tid_start_tx[tid];\n\t\tif (!blocked && tid_tx) {\n\t\t\tstruct txq_info *txqi = to_txq_info(sta->sta.txq[tid]);\n\t\t\tstruct ieee80211_sub_if_data *sdata =\n\t\t\t\tvif_to_sdata(txqi->txq.vif);\n\t\t\tstruct fq *fq = &sdata->local->fq;\n\n\t\t\tspin_lock_bh(&fq->lock);\n\n\t\t\t \n\t\t\tset_bit(IEEE80211_TXQ_STOP, &txqi->flags);\n\n\t\t\tif (!skb_queue_empty(&txqi->frags)) {\n\t\t\t\t \n\n\t\t\t\tspin_unlock_bh(&fq->lock);\n\t\t\t\tspin_unlock_bh(&sta->lock);\n\n\t\t\t\t \n\t\t\t\tsynchronize_net();\n\n\t\t\t\tmutex_unlock(&sta->ampdu_mlme.mtx);\n\n\t\t\t\tieee80211_queue_work(&sdata->local->hw, work);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tspin_unlock_bh(&fq->lock);\n\n\t\t\t \n\n\t\t\tsta->ampdu_mlme.tid_start_tx[tid] = NULL;\n\t\t\t \n\t\t\tif (sta->ampdu_mlme.tid_tx[tid])\n\t\t\t\tkfree(tid_tx);\n\t\t\telse\n\t\t\t\tieee80211_assign_tid_tx(sta, tid, tid_tx);\n\t\t\tspin_unlock_bh(&sta->lock);\n\n\t\t\tieee80211_tx_ba_session_handle_start(sta, tid);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock_bh(&sta->lock);\n\n\t\ttid_tx = rcu_dereference_protected_tid_tx(sta, tid);\n\t\tif (!tid_tx)\n\t\t\tcontinue;\n\n\t\tif (!blocked &&\n\t\t    test_and_clear_bit(HT_AGG_STATE_START_CB, &tid_tx->state))\n\t\t\tieee80211_start_tx_ba_cb(sta, tid, tid_tx);\n\t\tif (test_and_clear_bit(HT_AGG_STATE_WANT_STOP, &tid_tx->state))\n\t\t\t___ieee80211_stop_tx_ba_session(sta, tid,\n\t\t\t\t\t\t\tAGG_STOP_LOCAL_REQUEST);\n\t\tif (test_and_clear_bit(HT_AGG_STATE_STOP_CB, &tid_tx->state))\n\t\t\tieee80211_stop_tx_ba_cb(sta, tid, tid_tx);\n\t}\n\tmutex_unlock(&sta->ampdu_mlme.mtx);\n}\n\nvoid ieee80211_send_delba(struct ieee80211_sub_if_data *sdata,\n\t\t\t  const u8 *da, u16 tid,\n\t\t\t  u16 initiator, u16 reason_code)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *mgmt;\n\tu16 params;\n\n\tskb = dev_alloc_skb(sizeof(*mgmt) + local->hw.extra_tx_headroom);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\tmgmt = skb_put_zero(skb, 24);\n\tmemcpy(mgmt->da, da, ETH_ALEN);\n\tmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\n\tif (sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n\t    sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\tmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\n\telse if (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\tmemcpy(mgmt->bssid, sdata->deflink.u.mgd.bssid, ETH_ALEN);\n\telse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\tmemcpy(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN);\n\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\n\tskb_put(skb, 1 + sizeof(mgmt->u.action.u.delba));\n\n\tmgmt->u.action.category = WLAN_CATEGORY_BACK;\n\tmgmt->u.action.u.delba.action_code = WLAN_ACTION_DELBA;\n\tparams = (u16)(initiator << 11); \t \n\tparams |= (u16)(tid << 12); \t\t \n\n\tmgmt->u.action.u.delba.params = cpu_to_le16(params);\n\tmgmt->u.action.u.delba.reason_code = cpu_to_le16(reason_code);\n\n\tieee80211_tx_skb(sdata, skb);\n}\n\nvoid ieee80211_process_delba(struct ieee80211_sub_if_data *sdata,\n\t\t\t     struct sta_info *sta,\n\t\t\t     struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tu16 tid, params;\n\tu16 initiator;\n\n\tparams = le16_to_cpu(mgmt->u.action.u.delba.params);\n\ttid = (params & IEEE80211_DELBA_PARAM_TID_MASK) >> 12;\n\tinitiator = (params & IEEE80211_DELBA_PARAM_INITIATOR_MASK) >> 11;\n\n\tht_dbg_ratelimited(sdata, \"delba from %pM (%s) tid %d reason code %d\\n\",\n\t\t\t   mgmt->sa, initiator ? \"initiator\" : \"recipient\",\n\t\t\t   tid,\n\t\t\t   le16_to_cpu(mgmt->u.action.u.delba.reason_code));\n\n\tif (initiator == WLAN_BACK_INITIATOR)\n\t\t__ieee80211_stop_rx_ba_session(sta, tid, WLAN_BACK_INITIATOR, 0,\n\t\t\t\t\t       true);\n\telse\n\t\t__ieee80211_stop_tx_ba_session(sta, tid, AGG_STOP_PEER_REQUEST);\n}\n\nenum nl80211_smps_mode\nieee80211_smps_mode_to_smps_mode(enum ieee80211_smps_mode smps)\n{\n\tswitch (smps) {\n\tcase IEEE80211_SMPS_OFF:\n\t\treturn NL80211_SMPS_OFF;\n\tcase IEEE80211_SMPS_STATIC:\n\t\treturn NL80211_SMPS_STATIC;\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\treturn NL80211_SMPS_DYNAMIC;\n\tdefault:\n\t\treturn NL80211_SMPS_OFF;\n\t}\n}\n\nint ieee80211_send_smps_action(struct ieee80211_sub_if_data *sdata,\n\t\t\t       enum ieee80211_smps_mode smps, const u8 *da,\n\t\t\t       const u8 *bssid)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *action_frame;\n\n\t \n\tskb = dev_alloc_skb(27 + local->hw.extra_tx_headroom);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\taction_frame = skb_put(skb, 27);\n\tmemcpy(action_frame->da, da, ETH_ALEN);\n\tmemcpy(action_frame->sa, sdata->dev->dev_addr, ETH_ALEN);\n\tmemcpy(action_frame->bssid, bssid, ETH_ALEN);\n\taction_frame->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\taction_frame->u.action.category = WLAN_CATEGORY_HT;\n\taction_frame->u.action.u.ht_smps.action = WLAN_HT_ACTION_SMPS;\n\tswitch (smps) {\n\tcase IEEE80211_SMPS_AUTOMATIC:\n\tcase IEEE80211_SMPS_NUM_MODES:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase IEEE80211_SMPS_OFF:\n\t\taction_frame->u.action.u.ht_smps.smps_control =\n\t\t\t\tWLAN_HT_SMPS_CONTROL_DISABLED;\n\t\tbreak;\n\tcase IEEE80211_SMPS_STATIC:\n\t\taction_frame->u.action.u.ht_smps.smps_control =\n\t\t\t\tWLAN_HT_SMPS_CONTROL_STATIC;\n\t\tbreak;\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\taction_frame->u.action.u.ht_smps.smps_control =\n\t\t\t\tWLAN_HT_SMPS_CONTROL_DYNAMIC;\n\t\tbreak;\n\t}\n\n\t \n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;\n\tieee80211_tx_skb(sdata, skb);\n\n\treturn 0;\n}\n\nvoid ieee80211_request_smps(struct ieee80211_vif *vif, unsigned int link_id,\n\t\t\t    enum ieee80211_smps_mode smps_mode)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct ieee80211_link_data *link;\n\n\tif (WARN_ON_ONCE(vif->type != NL80211_IFTYPE_STATION))\n\t\treturn;\n\n\trcu_read_lock();\n\tlink = rcu_dereference(sdata->link[link_id]);\n\tif (WARN_ON(!link))\n\t\tgoto out;\n\n\tif (link->u.mgd.driver_smps_mode == smps_mode)\n\t\tgoto out;\n\n\tlink->u.mgd.driver_smps_mode = smps_mode;\n\twiphy_work_queue(sdata->local->hw.wiphy,\n\t\t\t &link->u.mgd.request_smps_work);\nout:\n\trcu_read_unlock();\n}\n \nEXPORT_SYMBOL_GPL(ieee80211_request_smps);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}