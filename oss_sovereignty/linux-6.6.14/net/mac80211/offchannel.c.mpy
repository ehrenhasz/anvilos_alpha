{
  "module_name": "offchannel.c",
  "hash_id": "30fa5845c71be0151c47d1758254dad02ccb2d55813de288a37d989b21639cc1",
  "original_prompt": "Ingested from linux-6.6.14/net/mac80211/offchannel.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <net/mac80211.h>\n#include \"ieee80211_i.h\"\n#include \"driver-ops.h\"\n\n \nstatic void ieee80211_offchannel_ps_enable(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tbool offchannel_ps_enabled = false;\n\n\t \n\n\tdel_timer_sync(&local->dynamic_ps_timer);\n\tdel_timer_sync(&ifmgd->bcn_mon_timer);\n\tdel_timer_sync(&ifmgd->conn_mon_timer);\n\n\tcancel_work_sync(&local->dynamic_ps_enable_work);\n\n\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\toffchannel_ps_enabled = true;\n\t\tlocal->hw.conf.flags &= ~IEEE80211_CONF_PS;\n\t\tieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);\n\t}\n\n\tif (!offchannel_ps_enabled ||\n\t    !ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK))\n\t\t \n\t\tieee80211_send_nullfunc(local, sdata, true);\n}\n\n \nstatic void ieee80211_offchannel_ps_disable(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\n\tif (!local->ps_sdata)\n\t\tieee80211_send_nullfunc(local, sdata, false);\n\telse if (local->hw.conf.dynamic_ps_timeout > 0) {\n\t\t \n\t\tieee80211_send_nullfunc(local, sdata, false);\n\t\tmod_timer(&local->dynamic_ps_timer, jiffies +\n\t\t\t  msecs_to_jiffies(local->hw.conf.dynamic_ps_timeout));\n\t}\n\n\tieee80211_sta_reset_beacon_monitor(sdata);\n\tieee80211_sta_reset_conn_monitor(sdata);\n}\n\nvoid ieee80211_offchannel_stop_vifs(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tif (WARN_ON(local->use_chanctx))\n\t\treturn;\n\n\t \n\n\t \n\tieee80211_stop_queues_by_reason(&local->hw, IEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_OFFCHANNEL,\n\t\t\t\t\tfalse);\n\tieee80211_flush_queues(local, NULL, false);\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE ||\n\t\t    sdata->vif.type == NL80211_IFTYPE_NAN)\n\t\t\tcontinue;\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_MONITOR)\n\t\t\tset_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);\n\n\t\t \n\t\tif (sdata->vif.bss_conf.enable_beacon) {\n\t\t\tset_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED,\n\t\t\t\t&sdata->state);\n\t\t\tsdata->vif.bss_conf.enable_beacon = false;\n\t\t\tieee80211_link_info_change_notify(\n\t\t\t\tsdata, &sdata->deflink,\n\t\t\t\tBSS_CHANGED_BEACON_ENABLED);\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t    sdata->u.mgd.associated)\n\t\t\tieee80211_offchannel_ps_enable(sdata);\n\t}\n\tmutex_unlock(&local->iflist_mtx);\n}\n\nvoid ieee80211_offchannel_return(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tif (WARN_ON(local->use_chanctx))\n\t\treturn;\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)\n\t\t\tcontinue;\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_MONITOR)\n\t\t\tclear_bit(SDATA_STATE_OFFCHANNEL, &sdata->state);\n\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t    sdata->u.mgd.associated)\n\t\t\tieee80211_offchannel_ps_disable(sdata);\n\n\t\tif (test_and_clear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED,\n\t\t\t\t       &sdata->state)) {\n\t\t\tsdata->vif.bss_conf.enable_beacon = true;\n\t\t\tieee80211_link_info_change_notify(\n\t\t\t\tsdata, &sdata->deflink,\n\t\t\t\tBSS_CHANGED_BEACON_ENABLED);\n\t\t}\n\t}\n\tmutex_unlock(&local->iflist_mtx);\n\n\tieee80211_wake_queues_by_reason(&local->hw, IEEE80211_MAX_QUEUE_MAP,\n\t\t\t\t\tIEEE80211_QUEUE_STOP_REASON_OFFCHANNEL,\n\t\t\t\t\tfalse);\n}\n\nstatic void ieee80211_roc_notify_destroy(struct ieee80211_roc_work *roc)\n{\n\t \n\tif (roc->frame) {\n\t\tcfg80211_mgmt_tx_status(&roc->sdata->wdev, roc->mgmt_tx_cookie,\n\t\t\t\t\troc->frame->data, roc->frame->len,\n\t\t\t\t\tfalse, GFP_KERNEL);\n\t\tieee80211_free_txskb(&roc->sdata->local->hw, roc->frame);\n\t}\n\n\tif (!roc->mgmt_tx_cookie)\n\t\tcfg80211_remain_on_channel_expired(&roc->sdata->wdev,\n\t\t\t\t\t\t   roc->cookie, roc->chan,\n\t\t\t\t\t\t   GFP_KERNEL);\n\telse\n\t\tcfg80211_tx_mgmt_expired(&roc->sdata->wdev,\n\t\t\t\t\t roc->mgmt_tx_cookie,\n\t\t\t\t\t roc->chan, GFP_KERNEL);\n\n\tlist_del(&roc->list);\n\tkfree(roc);\n}\n\nstatic unsigned long ieee80211_end_finished_rocs(struct ieee80211_local *local,\n\t\t\t\t\t\t unsigned long now)\n{\n\tstruct ieee80211_roc_work *roc, *tmp;\n\tlong remaining_dur_min = LONG_MAX;\n\n\tlockdep_assert_held(&local->mtx);\n\n\tlist_for_each_entry_safe(roc, tmp, &local->roc_list, list) {\n\t\tlong remaining;\n\n\t\tif (!roc->started)\n\t\t\tbreak;\n\n\t\tremaining = roc->start_time +\n\t\t\t    msecs_to_jiffies(roc->duration) -\n\t\t\t    now;\n\n\t\t \n\t\tif (roc->abort || roc->hw_begun || remaining <= 0)\n\t\t\tieee80211_roc_notify_destroy(roc);\n\t\telse\n\t\t\tremaining_dur_min = min(remaining_dur_min, remaining);\n\t}\n\n\treturn remaining_dur_min;\n}\n\nstatic bool ieee80211_recalc_sw_work(struct ieee80211_local *local,\n\t\t\t\t     unsigned long now)\n{\n\tlong dur = ieee80211_end_finished_rocs(local, now);\n\n\tif (dur == LONG_MAX)\n\t\treturn false;\n\n\twiphy_delayed_work_queue(local->hw.wiphy, &local->roc_work, dur);\n\treturn true;\n}\n\nstatic void ieee80211_handle_roc_started(struct ieee80211_roc_work *roc,\n\t\t\t\t\t unsigned long start_time)\n{\n\tif (WARN_ON(roc->notified))\n\t\treturn;\n\n\troc->start_time = start_time;\n\troc->started = true;\n\n\tif (roc->mgmt_tx_cookie) {\n\t\tif (!WARN_ON(!roc->frame)) {\n\t\t\tieee80211_tx_skb_tid_band(roc->sdata, roc->frame, 7,\n\t\t\t\t\t\t  roc->chan->band);\n\t\t\troc->frame = NULL;\n\t\t}\n\t} else {\n\t\tcfg80211_ready_on_channel(&roc->sdata->wdev, roc->cookie,\n\t\t\t\t\t  roc->chan, roc->req_duration,\n\t\t\t\t\t  GFP_KERNEL);\n\t}\n\n\troc->notified = true;\n}\n\nstatic void ieee80211_hw_roc_start(struct wiphy *wiphy, struct wiphy_work *work)\n{\n\tstruct ieee80211_local *local =\n\t\tcontainer_of(work, struct ieee80211_local, hw_roc_start);\n\tstruct ieee80211_roc_work *roc;\n\n\tmutex_lock(&local->mtx);\n\n\tlist_for_each_entry(roc, &local->roc_list, list) {\n\t\tif (!roc->started)\n\t\t\tbreak;\n\n\t\troc->hw_begun = true;\n\t\tieee80211_handle_roc_started(roc, local->hw_roc_start_time);\n\t}\n\n\tmutex_unlock(&local->mtx);\n}\n\nvoid ieee80211_ready_on_channel(struct ieee80211_hw *hw)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\tlocal->hw_roc_start_time = jiffies;\n\n\ttrace_api_ready_on_channel(local);\n\n\twiphy_work_queue(hw->wiphy, &local->hw_roc_start);\n}\nEXPORT_SYMBOL_GPL(ieee80211_ready_on_channel);\n\nstatic void _ieee80211_start_next_roc(struct ieee80211_local *local)\n{\n\tstruct ieee80211_roc_work *roc, *tmp;\n\tenum ieee80211_roc_type type;\n\tu32 min_dur, max_dur;\n\n\tlockdep_assert_held(&local->mtx);\n\n\tif (WARN_ON(list_empty(&local->roc_list)))\n\t\treturn;\n\n\troc = list_first_entry(&local->roc_list, struct ieee80211_roc_work,\n\t\t\t       list);\n\n\tif (WARN_ON(roc->started))\n\t\treturn;\n\n\tmin_dur = roc->duration;\n\tmax_dur = roc->duration;\n\ttype = roc->type;\n\n\tlist_for_each_entry(tmp, &local->roc_list, list) {\n\t\tif (tmp == roc)\n\t\t\tcontinue;\n\t\tif (tmp->sdata != roc->sdata || tmp->chan != roc->chan)\n\t\t\tbreak;\n\t\tmax_dur = max(tmp->duration, max_dur);\n\t\tmin_dur = min(tmp->duration, min_dur);\n\t\ttype = max(tmp->type, type);\n\t}\n\n\tif (local->ops->remain_on_channel) {\n\t\tint ret = drv_remain_on_channel(local, roc->sdata, roc->chan,\n\t\t\t\t\t\tmax_dur, type);\n\n\t\tif (ret) {\n\t\t\twiphy_warn(local->hw.wiphy,\n\t\t\t\t   \"failed to start next HW ROC (%d)\\n\", ret);\n\t\t\t \n\t\t\tlist_for_each_entry(tmp, &local->roc_list, list) {\n\t\t\t\tif (tmp->sdata != roc->sdata ||\n\t\t\t\t    tmp->chan != roc->chan)\n\t\t\t\t\tbreak;\n\t\t\t\ttmp->started = true;\n\t\t\t\ttmp->abort = true;\n\t\t\t}\n\t\t\twiphy_work_queue(local->hw.wiphy, &local->hw_roc_done);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry(tmp, &local->roc_list, list) {\n\t\t\tif (tmp->sdata != roc->sdata || tmp->chan != roc->chan)\n\t\t\t\tbreak;\n\t\t\ttmp->started = true;\n\t\t}\n\t} else {\n\t\t \n\t\troc->on_channel = roc->chan == local->_oper_chandef.chan &&\n\t\t\t\t  local->_oper_chandef.width != NL80211_CHAN_WIDTH_5 &&\n\t\t\t\t  local->_oper_chandef.width != NL80211_CHAN_WIDTH_10;\n\n\t\t \n\t\tieee80211_recalc_idle(local);\n\n\t\tif (!roc->on_channel) {\n\t\t\tieee80211_offchannel_stop_vifs(local);\n\n\t\t\tlocal->tmp_channel = roc->chan;\n\t\t\tieee80211_hw_config(local, 0);\n\t\t}\n\n\t\twiphy_delayed_work_queue(local->hw.wiphy, &local->roc_work,\n\t\t\t\t\t msecs_to_jiffies(min_dur));\n\n\t\t \n\t\tlist_for_each_entry(tmp, &local->roc_list, list) {\n\t\t\tif (tmp->sdata != roc->sdata || tmp->chan != roc->chan)\n\t\t\t\tbreak;\n\n\t\t\ttmp->on_channel = roc->on_channel;\n\t\t\tieee80211_handle_roc_started(tmp, jiffies);\n\t\t}\n\t}\n}\n\nvoid ieee80211_start_next_roc(struct ieee80211_local *local)\n{\n\tstruct ieee80211_roc_work *roc;\n\n\tlockdep_assert_held(&local->mtx);\n\n\tif (list_empty(&local->roc_list)) {\n\t\tieee80211_run_deferred_scan(local);\n\t\treturn;\n\t}\n\n\t \n\tif (local->in_reconfig)\n\t\treturn;\n\n\troc = list_first_entry(&local->roc_list, struct ieee80211_roc_work,\n\t\t\t       list);\n\n\tif (WARN_ON_ONCE(roc->started))\n\t\treturn;\n\n\tif (local->ops->remain_on_channel) {\n\t\t_ieee80211_start_next_roc(local);\n\t} else {\n\t\t \n\t\twiphy_delayed_work_queue(local->hw.wiphy, &local->roc_work,\n\t\t\t\t\t round_jiffies_relative(HZ / 2));\n\t}\n}\n\nstatic void __ieee80211_roc_work(struct ieee80211_local *local)\n{\n\tstruct ieee80211_roc_work *roc;\n\tbool on_channel;\n\n\tlockdep_assert_held(&local->mtx);\n\n\tif (WARN_ON(local->ops->remain_on_channel))\n\t\treturn;\n\n\troc = list_first_entry_or_null(&local->roc_list,\n\t\t\t\t       struct ieee80211_roc_work, list);\n\tif (!roc)\n\t\treturn;\n\n\tif (!roc->started) {\n\t\tWARN_ON(local->use_chanctx);\n\t\t_ieee80211_start_next_roc(local);\n\t} else {\n\t\ton_channel = roc->on_channel;\n\t\tif (ieee80211_recalc_sw_work(local, jiffies))\n\t\t\treturn;\n\n\t\t \n\n\t\tif (!on_channel) {\n\t\t\tieee80211_flush_queues(local, NULL, false);\n\n\t\t\tlocal->tmp_channel = NULL;\n\t\t\tieee80211_hw_config(local, 0);\n\n\t\t\tieee80211_offchannel_return(local);\n\t\t}\n\n\t\tieee80211_recalc_idle(local);\n\t\tieee80211_start_next_roc(local);\n\t}\n}\n\nstatic void ieee80211_roc_work(struct wiphy *wiphy, struct wiphy_work *work)\n{\n\tstruct ieee80211_local *local =\n\t\tcontainer_of(work, struct ieee80211_local, roc_work.work);\n\n\tmutex_lock(&local->mtx);\n\t__ieee80211_roc_work(local);\n\tmutex_unlock(&local->mtx);\n}\n\nstatic void ieee80211_hw_roc_done(struct wiphy *wiphy, struct wiphy_work *work)\n{\n\tstruct ieee80211_local *local =\n\t\tcontainer_of(work, struct ieee80211_local, hw_roc_done);\n\n\tmutex_lock(&local->mtx);\n\n\tieee80211_end_finished_rocs(local, jiffies);\n\n\t \n\tieee80211_start_next_roc(local);\n\n\tmutex_unlock(&local->mtx);\n}\n\nvoid ieee80211_remain_on_channel_expired(struct ieee80211_hw *hw)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\n\ttrace_api_remain_on_channel_expired(local);\n\n\twiphy_work_queue(hw->wiphy, &local->hw_roc_done);\n}\nEXPORT_SYMBOL_GPL(ieee80211_remain_on_channel_expired);\n\nstatic bool\nieee80211_coalesce_hw_started_roc(struct ieee80211_local *local,\n\t\t\t\t  struct ieee80211_roc_work *new_roc,\n\t\t\t\t  struct ieee80211_roc_work *cur_roc)\n{\n\tunsigned long now = jiffies;\n\tunsigned long remaining;\n\n\tif (WARN_ON(!cur_roc->started))\n\t\treturn false;\n\n\t \n\tif (!cur_roc->hw_begun && new_roc->duration > cur_roc->duration)\n\t\treturn false;\n\n\tremaining = cur_roc->start_time +\n\t\t    msecs_to_jiffies(cur_roc->duration) -\n\t\t    now;\n\n\t \n\tif (new_roc->duration > jiffies_to_msecs(remaining))\n\t\treturn false;\n\n\t \n\tlist_add(&new_roc->list, &cur_roc->list);\n\n\t \n\tif (cur_roc->hw_begun) {\n\t\tnew_roc->hw_begun = true;\n\t\tieee80211_handle_roc_started(new_roc, now);\n\t}\n\n\treturn true;\n}\n\nstatic int ieee80211_start_roc_work(struct ieee80211_local *local,\n\t\t\t\t    struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_channel *channel,\n\t\t\t\t    unsigned int duration, u64 *cookie,\n\t\t\t\t    struct sk_buff *txskb,\n\t\t\t\t    enum ieee80211_roc_type type)\n{\n\tstruct ieee80211_roc_work *roc, *tmp;\n\tbool queued = false, combine_started = true;\n\tint ret;\n\n\tlockdep_assert_held(&local->mtx);\n\n\tif (channel->freq_offset)\n\t\t \n\t\treturn -EOPNOTSUPP;\n\n\tif (local->use_chanctx && !local->ops->remain_on_channel)\n\t\treturn -EOPNOTSUPP;\n\n\troc = kzalloc(sizeof(*roc), GFP_KERNEL);\n\tif (!roc)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!duration)\n\t\tduration = 10;\n\n\troc->chan = channel;\n\troc->duration = duration;\n\troc->req_duration = duration;\n\troc->frame = txskb;\n\troc->type = type;\n\troc->sdata = sdata;\n\n\t \n\tif (!txskb) {\n\t\troc->cookie = ieee80211_mgmt_tx_cookie(local);\n\t\t*cookie = roc->cookie;\n\t} else {\n\t\troc->mgmt_tx_cookie = *cookie;\n\t}\n\n\t \n\tif (list_empty(&local->roc_list) &&\n\t    !local->scanning && !ieee80211_is_radar_required(local)) {\n\t\t \n\t\tif (!local->ops->remain_on_channel) {\n\t\t\tlist_add_tail(&roc->list, &local->roc_list);\n\t\t\twiphy_delayed_work_queue(local->hw.wiphy,\n\t\t\t\t\t\t &local->roc_work, 0);\n\t\t} else {\n\t\t\t \n\t\t\tret = drv_remain_on_channel(local, sdata, channel,\n\t\t\t\t\t\t    duration, type);\n\t\t\tif (ret) {\n\t\t\t\tkfree(roc);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\troc->started = true;\n\t\t\tlist_add_tail(&roc->list, &local->roc_list);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\n\tlist_for_each_entry(tmp, &local->roc_list, list) {\n\t\tif (tmp->chan != channel || tmp->sdata != sdata)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!tmp->started) {\n\t\t\tlist_add(&roc->list, &tmp->list);\n\t\t\tqueued = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!combine_started)\n\t\t\tcontinue;\n\n\t\tif (!local->ops->remain_on_channel) {\n\t\t\t \n\t\t\tunsigned long now = jiffies;\n\t\t\tu32 elapsed = jiffies_to_msecs(now - tmp->start_time);\n\t\t\tstruct wiphy *wiphy = local->hw.wiphy;\n\t\t\tu32 max_roc = wiphy->max_remain_on_channel_duration;\n\n\t\t\tif (elapsed + roc->duration > max_roc) {\n\t\t\t\tcombine_started = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlist_add(&roc->list, &tmp->list);\n\t\t\tqueued = true;\n\t\t\troc->on_channel = tmp->on_channel;\n\t\t\tieee80211_handle_roc_started(roc, now);\n\t\t\tieee80211_recalc_sw_work(local, now);\n\t\t\tbreak;\n\t\t}\n\n\t\tqueued = ieee80211_coalesce_hw_started_roc(local, roc, tmp);\n\t\tif (queued)\n\t\t\tbreak;\n\t\t \n\t\tcombine_started = false;\n\t}\n\n\tif (!queued)\n\t\tlist_add_tail(&roc->list, &local->roc_list);\n\n\treturn 0;\n}\n\nint ieee80211_remain_on_channel(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\tunsigned int duration, u64 *cookie)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret;\n\n\tmutex_lock(&local->mtx);\n\tret = ieee80211_start_roc_work(local, sdata, chan,\n\t\t\t\t       duration, cookie, NULL,\n\t\t\t\t       IEEE80211_ROC_TYPE_NORMAL);\n\tmutex_unlock(&local->mtx);\n\n\treturn ret;\n}\n\nstatic int ieee80211_cancel_roc(struct ieee80211_local *local,\n\t\t\t\tu64 cookie, bool mgmt_tx)\n{\n\tstruct ieee80211_roc_work *roc, *tmp, *found = NULL;\n\tint ret;\n\n\tif (!cookie)\n\t\treturn -ENOENT;\n\n\twiphy_work_flush(local->hw.wiphy, &local->hw_roc_start);\n\n\tmutex_lock(&local->mtx);\n\tlist_for_each_entry_safe(roc, tmp, &local->roc_list, list) {\n\t\tif (!mgmt_tx && roc->cookie != cookie)\n\t\t\tcontinue;\n\t\telse if (mgmt_tx && roc->mgmt_tx_cookie != cookie)\n\t\t\tcontinue;\n\n\t\tfound = roc;\n\t\tbreak;\n\t}\n\n\tif (!found) {\n\t\tmutex_unlock(&local->mtx);\n\t\treturn -ENOENT;\n\t}\n\n\tif (!found->started) {\n\t\tieee80211_roc_notify_destroy(found);\n\t\tgoto out_unlock;\n\t}\n\n\tif (local->ops->remain_on_channel) {\n\t\tret = drv_cancel_remain_on_channel(local, roc->sdata);\n\t\tif (WARN_ON_ONCE(ret)) {\n\t\t\tmutex_unlock(&local->mtx);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry_safe(roc, tmp, &local->roc_list, list) {\n\t\t\tif (!roc->started)\n\t\t\t\tbreak;\n\t\t\tif (roc == found)\n\t\t\t\tfound = NULL;\n\t\t\tieee80211_roc_notify_destroy(roc);\n\t\t}\n\n\t\t \n\t\tWARN_ON(found);\n\n\t\tieee80211_start_next_roc(local);\n\t} else {\n\t\t \n\t\tfound->abort = true;\n\t\twiphy_delayed_work_queue(local->hw.wiphy, &local->roc_work, 0);\n\t}\n\n out_unlock:\n\tmutex_unlock(&local->mtx);\n\n\treturn 0;\n}\n\nint ieee80211_cancel_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t       struct wireless_dev *wdev, u64 cookie)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tstruct ieee80211_local *local = sdata->local;\n\n\treturn ieee80211_cancel_roc(local, cookie, false);\n}\n\nint ieee80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t      struct cfg80211_mgmt_tx_params *params, u64 *cookie)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct sta_info *sta = NULL;\n\tconst struct ieee80211_mgmt *mgmt = (void *)params->buf;\n\tbool need_offchan = false;\n\tbool mlo_sta = false;\n\tint link_id = -1;\n\tu32 flags;\n\tint ret;\n\tu8 *data;\n\n\tif (params->dont_wait_for_ack)\n\t\tflags = IEEE80211_TX_CTL_NO_ACK;\n\telse\n\t\tflags = IEEE80211_TX_INTFL_NL80211_FRAME_TX |\n\t\t\tIEEE80211_TX_CTL_REQ_TX_STATUS;\n\n\tif (params->no_cck)\n\t\tflags |= IEEE80211_TX_CTL_NO_CCK_RATE;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (!sdata->vif.cfg.ibss_joined)\n\t\t\tneed_offchan = true;\n#ifdef CONFIG_MAC80211_MESH\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (ieee80211_vif_is_mesh(&sdata->vif) &&\n\t\t    !sdata->u.mesh.mesh_id_len)\n\t\t\tneed_offchan = true;\n#endif\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (sdata->vif.type != NL80211_IFTYPE_ADHOC &&\n\t\t    !ieee80211_vif_is_mesh(&sdata->vif) &&\n\t\t    !sdata->bss->active)\n\t\t\tneed_offchan = true;\n\n\t\trcu_read_lock();\n\t\tsta = sta_info_get_bss(sdata, mgmt->da);\n\t\tmlo_sta = sta && sta->sta.mlo;\n\n\t\tif (!ieee80211_is_action(mgmt->frame_control) ||\n\t\t    mgmt->u.action.category == WLAN_CATEGORY_PUBLIC ||\n\t\t    mgmt->u.action.category == WLAN_CATEGORY_SELF_PROTECTED ||\n\t\t    mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!sta) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOLINK;\n\t\t}\n\t\tif (params->link_id >= 0 &&\n\t\t    !(sta->sta.valid_links & BIT(params->link_id))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOLINK;\n\t\t}\n\t\tlink_id = params->link_id;\n\t\trcu_read_unlock();\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tsdata_lock(sdata);\n\t\tif (!sdata->u.mgd.associated ||\n\t\t    (params->offchan && params->wait &&\n\t\t     local->ops->remain_on_channel &&\n\t\t     memcmp(sdata->vif.cfg.ap_addr, mgmt->bssid, ETH_ALEN)))\n\t\t\tneed_offchan = true;\n\t\tsdata_unlock(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tneed_offchan = true;\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (need_offchan && !params->chan)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&local->mtx);\n\n\t \n\tif (!params->chan && mlo_sta) {\n\t\tneed_offchan = false;\n\t} else if (!need_offchan) {\n\t\tstruct ieee80211_chanctx_conf *chanctx_conf = NULL;\n\t\tint i;\n\n\t\trcu_read_lock();\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(sdata->vif.link_conf); i++) {\n\t\t\tstruct ieee80211_bss_conf *conf;\n\n\t\t\tconf = rcu_dereference(sdata->vif.link_conf[i]);\n\t\t\tif (!conf)\n\t\t\t\tcontinue;\n\n\t\t\tchanctx_conf = rcu_dereference(conf->chanctx_conf);\n\t\t\tif (!chanctx_conf)\n\t\t\t\tcontinue;\n\n\t\t\tif (mlo_sta && params->chan == chanctx_conf->def.chan &&\n\t\t\t    ether_addr_equal(sdata->vif.addr, mgmt->sa)) {\n\t\t\t\tlink_id = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ether_addr_equal(conf->addr, mgmt->sa))\n\t\t\t\tbreak;\n\n\t\t\tchanctx_conf = NULL;\n\t\t}\n\n\t\tif (chanctx_conf) {\n\t\t\tneed_offchan = params->chan &&\n\t\t\t\t       (params->chan !=\n\t\t\t\t\tchanctx_conf->def.chan);\n\t\t} else {\n\t\t\tneed_offchan = true;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (need_offchan && !params->offchan) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tskb = dev_alloc_skb(local->hw.extra_tx_headroom + params->len);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tskb_reserve(skb, local->hw.extra_tx_headroom);\n\n\tdata = skb_put_data(skb, params->buf, params->len);\n\n\t \n\tif (sdata->vif.bss_conf.csa_active &&\n\t    (sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     sdata->vif.type == NL80211_IFTYPE_MESH_POINT ||\n\t     sdata->vif.type == NL80211_IFTYPE_ADHOC) &&\n\t    params->n_csa_offsets) {\n\t\tint i;\n\t\tstruct beacon_data *beacon = NULL;\n\n\t\trcu_read_lock();\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tbeacon = rcu_dereference(sdata->deflink.u.ap.beacon);\n\t\telse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\t\tbeacon = rcu_dereference(sdata->u.ibss.presp);\n\t\telse if (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tbeacon = rcu_dereference(sdata->u.mesh.beacon);\n\n\t\tif (beacon)\n\t\t\tfor (i = 0; i < params->n_csa_offsets; i++)\n\t\t\t\tdata[params->csa_offsets[i]] =\n\t\t\t\t\tbeacon->cntdwn_current_counter;\n\n\t\trcu_read_unlock();\n\t}\n\n\tIEEE80211_SKB_CB(skb)->flags = flags;\n\n\tskb->dev = sdata->dev;\n\n\tif (!params->dont_wait_for_ack) {\n\t\t \n\t\tret = ieee80211_attach_ack_skb(local, skb, cookie, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\t \n\t\t*cookie = 0xffffffff;\n\t}\n\n\tif (!need_offchan) {\n\t\tieee80211_tx_skb_tid(sdata, skb, 7, link_id);\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_TX_OFFCHAN |\n\t\t\t\t\tIEEE80211_TX_INTFL_OFFCHAN_TX_OK;\n\tif (ieee80211_hw_check(&local->hw, QUEUE_CONTROL))\n\t\tIEEE80211_SKB_CB(skb)->hw_queue =\n\t\t\tlocal->hw.offchannel_tx_hw_queue;\n\n\t \n\tret = ieee80211_start_roc_work(local, sdata, params->chan,\n\t\t\t\t       params->wait, cookie, skb,\n\t\t\t\t       IEEE80211_ROC_TYPE_MGMT_TX);\n\tif (ret)\n\t\tieee80211_free_txskb(&local->hw, skb);\n out_unlock:\n\tmutex_unlock(&local->mtx);\n\treturn ret;\n}\n\nint ieee80211_mgmt_tx_cancel_wait(struct wiphy *wiphy,\n\t\t\t\t  struct wireless_dev *wdev, u64 cookie)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\n\treturn ieee80211_cancel_roc(local, cookie, true);\n}\n\nvoid ieee80211_roc_setup(struct ieee80211_local *local)\n{\n\twiphy_work_init(&local->hw_roc_start, ieee80211_hw_roc_start);\n\twiphy_work_init(&local->hw_roc_done, ieee80211_hw_roc_done);\n\twiphy_delayed_work_init(&local->roc_work, ieee80211_roc_work);\n\tINIT_LIST_HEAD(&local->roc_list);\n}\n\nvoid ieee80211_roc_purge(struct ieee80211_local *local,\n\t\t\t struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_roc_work *roc, *tmp;\n\tbool work_to_do = false;\n\n\tmutex_lock(&local->mtx);\n\tlist_for_each_entry_safe(roc, tmp, &local->roc_list, list) {\n\t\tif (sdata && roc->sdata != sdata)\n\t\t\tcontinue;\n\n\t\tif (roc->started) {\n\t\t\tif (local->ops->remain_on_channel) {\n\t\t\t\t \n\t\t\t\tdrv_cancel_remain_on_channel(local, roc->sdata);\n\t\t\t\tieee80211_roc_notify_destroy(roc);\n\t\t\t} else {\n\t\t\t\troc->abort = true;\n\t\t\t\twork_to_do = true;\n\t\t\t}\n\t\t} else {\n\t\t\tieee80211_roc_notify_destroy(roc);\n\t\t}\n\t}\n\tif (work_to_do)\n\t\t__ieee80211_roc_work(local);\n\tmutex_unlock(&local->mtx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}