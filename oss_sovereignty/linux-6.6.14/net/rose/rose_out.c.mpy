{
  "module_name": "rose_out.c",
  "hash_id": "f513f58a2616f2b722227696102d430094f7beb4baede8c19966c762476bcdc6",
  "original_prompt": "Ingested from linux-6.6.14/net/rose/rose_out.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/gfp.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/rose.h>\n\n \nstatic void rose_send_iframe(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tif (skb == NULL)\n\t\treturn;\n\n\tskb->data[2] |= (rose->vr << 5) & 0xE0;\n\tskb->data[2] |= (rose->vs << 1) & 0x0E;\n\n\trose_start_idletimer(sk);\n\n\trose_transmit_link(skb, rose->neighbour);\n}\n\nvoid rose_kick(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sk_buff *skb, *skbn;\n\tunsigned short start, end;\n\n\tif (rose->state != ROSE_STATE_3)\n\t\treturn;\n\n\tif (rose->condition & ROSE_COND_PEER_RX_BUSY)\n\t\treturn;\n\n\tif (!skb_peek(&sk->sk_write_queue))\n\t\treturn;\n\n\tstart = (skb_peek(&rose->ack_queue) == NULL) ? rose->va : rose->vs;\n\tend   = (rose->va + sysctl_rose_window_size) % ROSE_MODULUS;\n\n\tif (start == end)\n\t\treturn;\n\n\trose->vs = start;\n\n\t \n\n\tskb  = skb_dequeue(&sk->sk_write_queue);\n\n\tdo {\n\t\tif ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {\n\t\t\tskb_queue_head(&sk->sk_write_queue, skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tskb_set_owner_w(skbn, sk);\n\n\t\t \n\t\trose_send_iframe(sk, skbn);\n\n\t\trose->vs = (rose->vs + 1) % ROSE_MODULUS;\n\n\t\t \n\t\tskb_queue_tail(&rose->ack_queue, skb);\n\n\t} while (rose->vs != end &&\n\t\t (skb = skb_dequeue(&sk->sk_write_queue)) != NULL);\n\n\trose->vl         = rose->vr;\n\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\n\trose_stop_timer(sk);\n}\n\n \n\nvoid rose_enquiry_response(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tif (rose->condition & ROSE_COND_OWN_RX_BUSY)\n\t\trose_write_internal(sk, ROSE_RNR);\n\telse\n\t\trose_write_internal(sk, ROSE_RR);\n\n\trose->vl         = rose->vr;\n\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\n\trose_stop_timer(sk);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}