{
  "module_name": "rose_dev.c",
  "hash_id": "ef7b38b1050bc884f526446eaeacc1e1316a14b9229bf23bff2e3071d30ff9d4",
  "original_prompt": "Ingested from linux-6.6.14/net/rose/rose_dev.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/sysctl.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/in.h>\n#include <linux/if_ether.h>\n#include <linux/slab.h>\n\n#include <asm/io.h>\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n\n#include <net/ip.h>\n#include <net/arp.h>\n\n#include <net/ax25.h>\n#include <net/rose.h>\n\nstatic int rose_header(struct sk_buff *skb, struct net_device *dev,\n\t\t       unsigned short type,\n\t\t       const void *daddr, const void *saddr, unsigned int len)\n{\n\tunsigned char *buff = skb_push(skb, ROSE_MIN_LEN + 2);\n\n\tif (daddr)\n\t\tmemcpy(buff + 7, daddr, dev->addr_len);\n\n\t*buff++ = ROSE_GFI | ROSE_Q_BIT;\n\t*buff++ = 0x00;\n\t*buff++ = ROSE_DATA;\n\t*buff++ = 0x7F;\n\t*buff++ = AX25_P_IP;\n\n\tif (daddr != NULL)\n\t\treturn 37;\n\n\treturn -37;\n}\n\nstatic int rose_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sa = addr;\n\tint err;\n\n\tif (!memcmp(dev->dev_addr, sa->sa_data, dev->addr_len))\n\t\treturn 0;\n\n\tif (dev->flags & IFF_UP) {\n\t\terr = rose_add_loopback_node((rose_address *)sa->sa_data);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\trose_del_loopback_node((const rose_address *)dev->dev_addr);\n\t}\n\n\tdev_addr_set(dev, sa->sa_data);\n\n\treturn 0;\n}\n\nstatic int rose_open(struct net_device *dev)\n{\n\tint err;\n\n\terr = rose_add_loopback_node((const rose_address *)dev->dev_addr);\n\tif (err)\n\t\treturn err;\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int rose_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\trose_del_loopback_node((const rose_address *)dev->dev_addr);\n\treturn 0;\n}\n\nstatic netdev_tx_t rose_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tunsigned int len = skb->len;\n\n\tif (!netif_running(dev)) {\n\t\tprintk(KERN_ERR \"ROSE: rose_xmit - called when iface is down\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (!rose_route_frame(skb, NULL)) {\n\t\tdev_kfree_skb(skb);\n\t\tstats->tx_errors++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tstats->tx_packets++;\n\tstats->tx_bytes += len;\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct header_ops rose_header_ops = {\n\t.create\t= rose_header,\n};\n\nstatic const struct net_device_ops rose_netdev_ops = {\n\t.ndo_open\t\t= rose_open,\n\t.ndo_stop\t\t= rose_close,\n\t.ndo_start_xmit\t\t= rose_xmit,\n\t.ndo_set_mac_address    = rose_set_mac_address,\n};\n\nvoid rose_setup(struct net_device *dev)\n{\n\tdev->mtu\t\t= ROSE_MAX_PACKET_SIZE - 2;\n\tdev->netdev_ops\t\t= &rose_netdev_ops;\n\n\tdev->header_ops\t\t= &rose_header_ops;\n\tdev->hard_header_len\t= AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN;\n\tdev->addr_len\t\t= ROSE_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_ROSE;\n\n\t \n\tdev->flags\t\t= IFF_NOARP;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}