{
  "module_name": "rose_route.c",
  "hash_id": "e175afdc06216274bc1600dbf5492f2771fb3acce6ed6b2f8a611b997911ad9d",
  "original_prompt": "Ingested from linux-6.6.14/net/rose/rose_route.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <net/arp.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\t \n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <net/rose.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n\nstatic unsigned int rose_neigh_no = 1;\n\nstatic struct rose_node  *rose_node_list;\nstatic DEFINE_SPINLOCK(rose_node_list_lock);\nstatic struct rose_neigh *rose_neigh_list;\nstatic DEFINE_SPINLOCK(rose_neigh_list_lock);\nstatic struct rose_route *rose_route_list;\nstatic DEFINE_SPINLOCK(rose_route_list_lock);\n\nstruct rose_neigh *rose_loopback_neigh;\n\n \nstatic int __must_check rose_add_node(struct rose_route_struct *rose_route,\n\tstruct net_device *dev)\n{\n\tstruct rose_node  *rose_node, *rose_tmpn, *rose_tmpp;\n\tstruct rose_neigh *rose_neigh;\n\tint i, res = 0;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tspin_lock_bh(&rose_neigh_list_lock);\n\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == rose_route->mask) &&\n\t\t    (rosecmpm(&rose_route->address, &rose_node->address,\n\t\t\t      rose_route->mask) == 0))\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\n\tif (rose_node != NULL && rose_node->loopback) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (ax25cmp(&rose_route->neighbour,\n\t\t\t    &rose_neigh->callsign) == 0 &&\n\t\t    rose_neigh->dev == dev)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh == NULL) {\n\t\trose_neigh = kmalloc(sizeof(*rose_neigh), GFP_ATOMIC);\n\t\tif (rose_neigh == NULL) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\trose_neigh->callsign  = rose_route->neighbour;\n\t\trose_neigh->digipeat  = NULL;\n\t\trose_neigh->ax25      = NULL;\n\t\trose_neigh->dev       = dev;\n\t\trose_neigh->count     = 0;\n\t\trose_neigh->use       = 0;\n\t\trose_neigh->dce_mode  = 0;\n\t\trose_neigh->loopback  = 0;\n\t\trose_neigh->number    = rose_neigh_no++;\n\t\trose_neigh->restarted = 0;\n\n\t\tskb_queue_head_init(&rose_neigh->queue);\n\n\t\ttimer_setup(&rose_neigh->ftimer, NULL, 0);\n\t\ttimer_setup(&rose_neigh->t0timer, NULL, 0);\n\n\t\tif (rose_route->ndigis != 0) {\n\t\t\trose_neigh->digipeat =\n\t\t\t\tkmalloc(sizeof(ax25_digi), GFP_ATOMIC);\n\t\t\tif (rose_neigh->digipeat == NULL) {\n\t\t\t\tkfree(rose_neigh);\n\t\t\t\tres = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trose_neigh->digipeat->ndigi      = rose_route->ndigis;\n\t\t\trose_neigh->digipeat->lastrepeat = -1;\n\n\t\t\tfor (i = 0; i < rose_route->ndigis; i++) {\n\t\t\t\trose_neigh->digipeat->calls[i]    =\n\t\t\t\t\trose_route->digipeaters[i];\n\t\t\t\trose_neigh->digipeat->repeated[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\trose_neigh->next = rose_neigh_list;\n\t\trose_neigh_list  = rose_neigh;\n\t}\n\n\t \n\tif (rose_node == NULL) {\n\t\trose_tmpn = rose_node_list;\n\t\trose_tmpp = NULL;\n\n\t\twhile (rose_tmpn != NULL) {\n\t\t\tif (rose_tmpn->mask > rose_route->mask) {\n\t\t\t\trose_tmpp = rose_tmpn;\n\t\t\t\trose_tmpn = rose_tmpn->next;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\trose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC);\n\t\tif (rose_node == NULL) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\trose_node->address      = rose_route->address;\n\t\trose_node->mask         = rose_route->mask;\n\t\trose_node->count        = 1;\n\t\trose_node->loopback     = 0;\n\t\trose_node->neighbour[0] = rose_neigh;\n\n\t\tif (rose_tmpn == NULL) {\n\t\t\tif (rose_tmpp == NULL) {\t \n\t\t\t\trose_node_list  = rose_node;\n\t\t\t\trose_node->next = NULL;\n\t\t\t} else {\n\t\t\t\trose_tmpp->next = rose_node;\n\t\t\t\trose_node->next = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (rose_tmpp == NULL) {\t \n\t\t\t\trose_node->next = rose_node_list;\n\t\t\t\trose_node_list  = rose_node;\n\t\t\t} else {\n\t\t\t\trose_tmpp->next = rose_node;\n\t\t\t\trose_node->next = rose_tmpn;\n\t\t\t}\n\t\t}\n\t\trose_neigh->count++;\n\n\t\tgoto out;\n\t}\n\n\t \n\tif (rose_node->count < 3) {\n\t\trose_node->neighbour[rose_node->count] = rose_neigh;\n\t\trose_node->count++;\n\t\trose_neigh->count++;\n\t}\n\nout:\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\tspin_unlock_bh(&rose_node_list_lock);\n\n\treturn res;\n}\n\n \nstatic void rose_remove_node(struct rose_node *rose_node)\n{\n\tstruct rose_node *s;\n\n\tif ((s = rose_node_list) == rose_node) {\n\t\trose_node_list = rose_node->next;\n\t\tkfree(rose_node);\n\t\treturn;\n\t}\n\n\twhile (s != NULL && s->next != NULL) {\n\t\tif (s->next == rose_node) {\n\t\t\ts->next = rose_node->next;\n\t\t\tkfree(rose_node);\n\t\t\treturn;\n\t\t}\n\n\t\ts = s->next;\n\t}\n}\n\n \nstatic void rose_remove_neigh(struct rose_neigh *rose_neigh)\n{\n\tstruct rose_neigh *s;\n\n\tdel_timer_sync(&rose_neigh->ftimer);\n\tdel_timer_sync(&rose_neigh->t0timer);\n\n\tskb_queue_purge(&rose_neigh->queue);\n\n\tif ((s = rose_neigh_list) == rose_neigh) {\n\t\trose_neigh_list = rose_neigh->next;\n\t\tif (rose_neigh->ax25)\n\t\t\tax25_cb_put(rose_neigh->ax25);\n\t\tkfree(rose_neigh->digipeat);\n\t\tkfree(rose_neigh);\n\t\treturn;\n\t}\n\n\twhile (s != NULL && s->next != NULL) {\n\t\tif (s->next == rose_neigh) {\n\t\t\ts->next = rose_neigh->next;\n\t\t\tif (rose_neigh->ax25)\n\t\t\t\tax25_cb_put(rose_neigh->ax25);\n\t\t\tkfree(rose_neigh->digipeat);\n\t\t\tkfree(rose_neigh);\n\t\t\treturn;\n\t\t}\n\n\t\ts = s->next;\n\t}\n}\n\n \nstatic void rose_remove_route(struct rose_route *rose_route)\n{\n\tstruct rose_route *s;\n\n\tif (rose_route->neigh1 != NULL)\n\t\trose_route->neigh1->use--;\n\n\tif (rose_route->neigh2 != NULL)\n\t\trose_route->neigh2->use--;\n\n\tif ((s = rose_route_list) == rose_route) {\n\t\trose_route_list = rose_route->next;\n\t\tkfree(rose_route);\n\t\treturn;\n\t}\n\n\twhile (s != NULL && s->next != NULL) {\n\t\tif (s->next == rose_route) {\n\t\t\ts->next = rose_route->next;\n\t\t\tkfree(rose_route);\n\t\t\treturn;\n\t\t}\n\n\t\ts = s->next;\n\t}\n}\n\n \nstatic int rose_del_node(struct rose_route_struct *rose_route,\n\tstruct net_device *dev)\n{\n\tstruct rose_node  *rose_node;\n\tstruct rose_neigh *rose_neigh;\n\tint i, err = 0;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tspin_lock_bh(&rose_neigh_list_lock);\n\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == rose_route->mask) &&\n\t\t    (rosecmpm(&rose_route->address, &rose_node->address,\n\t\t\t      rose_route->mask) == 0))\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\n\tif (rose_node == NULL || rose_node->loopback) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (ax25cmp(&rose_route->neighbour,\n\t\t\t    &rose_neigh->callsign) == 0 &&\n\t\t    rose_neigh->dev == dev)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh == NULL) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < rose_node->count; i++) {\n\t\tif (rose_node->neighbour[i] == rose_neigh) {\n\t\t\trose_neigh->count--;\n\n\t\t\tif (rose_neigh->count == 0 && rose_neigh->use == 0)\n\t\t\t\trose_remove_neigh(rose_neigh);\n\n\t\t\trose_node->count--;\n\n\t\t\tif (rose_node->count == 0) {\n\t\t\t\trose_remove_node(rose_node);\n\t\t\t} else {\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\trose_node->neighbour[0] =\n\t\t\t\t\t\trose_node->neighbour[1];\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 1:\n\t\t\t\t\trose_node->neighbour[1] =\n\t\t\t\t\t\trose_node->neighbour[2];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = -EINVAL;\n\nout:\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\tspin_unlock_bh(&rose_node_list_lock);\n\n\treturn err;\n}\n\n \nvoid rose_add_loopback_neigh(void)\n{\n\tstruct rose_neigh *sn;\n\n\trose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);\n\tif (!rose_loopback_neigh)\n\t\treturn;\n\tsn = rose_loopback_neigh;\n\n\tsn->callsign  = null_ax25_address;\n\tsn->digipeat  = NULL;\n\tsn->ax25      = NULL;\n\tsn->dev       = NULL;\n\tsn->count     = 0;\n\tsn->use       = 0;\n\tsn->dce_mode  = 1;\n\tsn->loopback  = 1;\n\tsn->number    = rose_neigh_no++;\n\tsn->restarted = 1;\n\n\tskb_queue_head_init(&sn->queue);\n\n\ttimer_setup(&sn->ftimer, NULL, 0);\n\ttimer_setup(&sn->t0timer, NULL, 0);\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\tsn->next = rose_neigh_list;\n\trose_neigh_list           = sn;\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}\n\n \nint rose_add_loopback_node(const rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\tint err = 0;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t     (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t     rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\n\tif (rose_node != NULL)\n\t\tgoto out;\n\n\tif ((rose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC)) == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trose_node->address      = *address;\n\trose_node->mask         = 10;\n\trose_node->count        = 1;\n\trose_node->loopback     = 1;\n\trose_node->neighbour[0] = rose_loopback_neigh;\n\n\t \n\trose_node->next = rose_node_list;\n\trose_node_list  = rose_node;\n\n\trose_loopback_neigh->count++;\n\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n\n\treturn err;\n}\n\n \nvoid rose_del_loopback_node(const rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t    (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t    rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\n\tif (rose_node == NULL)\n\t\tgoto out;\n\n\trose_remove_node(rose_node);\n\n\trose_loopback_neigh->count--;\n\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n}\n\n \nvoid rose_rt_device_down(struct net_device *dev)\n{\n\tstruct rose_neigh *s, *rose_neigh;\n\tstruct rose_node  *t, *rose_node;\n\tint i;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tspin_lock_bh(&rose_neigh_list_lock);\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\ts          = rose_neigh;\n\t\trose_neigh = rose_neigh->next;\n\n\t\tif (s->dev != dev)\n\t\t\tcontinue;\n\n\t\trose_node = rose_node_list;\n\n\t\twhile (rose_node != NULL) {\n\t\t\tt         = rose_node;\n\t\t\trose_node = rose_node->next;\n\n\t\t\tfor (i = 0; i < t->count; i++) {\n\t\t\t\tif (t->neighbour[i] != s)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tt->count--;\n\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tt->neighbour[0] = t->neighbour[1];\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 1:\n\t\t\t\t\tt->neighbour[1] = t->neighbour[2];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t->count <= 0)\n\t\t\t\trose_remove_node(t);\n\t\t}\n\n\t\trose_remove_neigh(s);\n\t}\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\tspin_unlock_bh(&rose_node_list_lock);\n}\n\n#if 0  \n \nvoid rose_route_device_down(struct net_device *dev)\n{\n\tstruct rose_route *s, *rose_route;\n\n\tspin_lock_bh(&rose_route_list_lock);\n\trose_route = rose_route_list;\n\twhile (rose_route != NULL) {\n\t\ts          = rose_route;\n\t\trose_route = rose_route->next;\n\n\t\tif (s->neigh1->dev == dev || s->neigh2->dev == dev)\n\t\t\trose_remove_route(s);\n\t}\n\tspin_unlock_bh(&rose_route_list_lock);\n}\n#endif\n\n \nstatic int rose_clear_routes(void)\n{\n\tstruct rose_neigh *s, *rose_neigh;\n\tstruct rose_node  *t, *rose_node;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tspin_lock_bh(&rose_neigh_list_lock);\n\n\trose_neigh = rose_neigh_list;\n\trose_node  = rose_node_list;\n\n\twhile (rose_node != NULL) {\n\t\tt         = rose_node;\n\t\trose_node = rose_node->next;\n\t\tif (!t->loopback)\n\t\t\trose_remove_node(t);\n\t}\n\n\twhile (rose_neigh != NULL) {\n\t\ts          = rose_neigh;\n\t\trose_neigh = rose_neigh->next;\n\n\t\tif (s->use == 0 && !s->loopback) {\n\t\t\ts->count = 0;\n\t\t\trose_remove_neigh(s);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\tspin_unlock_bh(&rose_node_list_lock);\n\n\treturn 0;\n}\n\n \nstatic struct net_device *rose_ax25_dev_find(char *devname)\n{\n\tstruct net_device *dev;\n\n\tif ((dev = __dev_get_by_name(&init_net, devname)) == NULL)\n\t\treturn NULL;\n\n\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_AX25)\n\t\treturn dev;\n\n\treturn NULL;\n}\n\n \nstruct net_device *rose_dev_first(void)\n{\n\tstruct net_device *dev, *first = NULL;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, dev) {\n\t\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE)\n\t\t\tif (first == NULL || strncmp(dev->name, first->name, 3) < 0)\n\t\t\t\tfirst = dev;\n\t}\n\tif (first)\n\t\tdev_hold(first);\n\trcu_read_unlock();\n\n\treturn first;\n}\n\n \nstruct net_device *rose_dev_get(rose_address *addr)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, dev) {\n\t\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE &&\n\t\t    rosecmp(addr, (const rose_address *)dev->dev_addr) == 0) {\n\t\t\tdev_hold(dev);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdev = NULL;\nout:\n\trcu_read_unlock();\n\treturn dev;\n}\n\nstatic int rose_dev_exists(rose_address *addr)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, dev) {\n\t\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE &&\n\t\t    rosecmp(addr, (const rose_address *)dev->dev_addr) == 0)\n\t\t\tgoto out;\n\t}\n\tdev = NULL;\nout:\n\trcu_read_unlock();\n\treturn dev != NULL;\n}\n\n\n\n\nstruct rose_route *rose_route_free_lci(unsigned int lci, struct rose_neigh *neigh)\n{\n\tstruct rose_route *rose_route;\n\n\tfor (rose_route = rose_route_list; rose_route != NULL; rose_route = rose_route->next)\n\t\tif ((rose_route->neigh1 == neigh && rose_route->lci1 == lci) ||\n\t\t    (rose_route->neigh2 == neigh && rose_route->lci2 == lci))\n\t\t\treturn rose_route;\n\n\treturn NULL;\n}\n\n \nstruct rose_neigh *rose_get_neigh(rose_address *addr, unsigned char *cause,\n\tunsigned char *diagnostic, int route_frame)\n{\n\tstruct rose_neigh *res = NULL;\n\tstruct rose_node *node;\n\tint failed = 0;\n\tint i;\n\n\tif (!route_frame) spin_lock_bh(&rose_node_list_lock);\n\tfor (node = rose_node_list; node != NULL; node = node->next) {\n\t\tif (rosecmpm(addr, &node->address, node->mask) == 0) {\n\t\t\tfor (i = 0; i < node->count; i++) {\n\t\t\t\tif (node->neighbour[i]->restarted) {\n\t\t\t\t\tres = node->neighbour[i];\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!route_frame) {  \n\t\tfor (node = rose_node_list; node != NULL; node = node->next) {\n\t\t\tif (rosecmpm(addr, &node->address, node->mask) == 0) {\n\t\t\t\tfor (i = 0; i < node->count; i++) {\n\t\t\t\t\tif (!rose_ftimer_running(node->neighbour[i])) {\n\t\t\t\t\t\tres = node->neighbour[i];\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tfailed = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (failed) {\n\t\t*cause      = ROSE_OUT_OF_ORDER;\n\t\t*diagnostic = 0;\n\t} else {\n\t\t*cause      = ROSE_NOT_OBTAINABLE;\n\t\t*diagnostic = 0;\n\t}\n\nout:\n\tif (!route_frame) spin_unlock_bh(&rose_node_list_lock);\n\treturn res;\n}\n\n \nint rose_rt_ioctl(unsigned int cmd, void __user *arg)\n{\n\tstruct rose_route_struct rose_route;\n\tstruct net_device *dev;\n\tint err;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\t\tif (copy_from_user(&rose_route, arg, sizeof(struct rose_route_struct)))\n\t\t\treturn -EFAULT;\n\t\tif ((dev = rose_ax25_dev_find(rose_route.device)) == NULL)\n\t\t\treturn -EINVAL;\n\t\tif (rose_dev_exists(&rose_route.address))  \n\t\t\treturn -EINVAL;\n\t\tif (rose_route.mask > 10)  \n\t\t\treturn -EINVAL;\n\t\tif (rose_route.ndigis > AX25_MAX_DIGIS)\n\t\t\treturn -EINVAL;\n\t\terr = rose_add_node(&rose_route, dev);\n\t\treturn err;\n\n\tcase SIOCDELRT:\n\t\tif (copy_from_user(&rose_route, arg, sizeof(struct rose_route_struct)))\n\t\t\treturn -EFAULT;\n\t\tif ((dev = rose_ax25_dev_find(rose_route.device)) == NULL)\n\t\t\treturn -EINVAL;\n\t\terr = rose_del_node(&rose_route, dev);\n\t\treturn err;\n\n\tcase SIOCRSCLRRT:\n\t\treturn rose_clear_routes();\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void rose_del_route_by_neigh(struct rose_neigh *rose_neigh)\n{\n\tstruct rose_route *rose_route, *s;\n\n\trose_neigh->restarted = 0;\n\n\trose_stop_t0timer(rose_neigh);\n\trose_start_ftimer(rose_neigh);\n\n\tskb_queue_purge(&rose_neigh->queue);\n\n\tspin_lock_bh(&rose_route_list_lock);\n\n\trose_route = rose_route_list;\n\n\twhile (rose_route != NULL) {\n\t\tif ((rose_route->neigh1 == rose_neigh && rose_route->neigh2 == rose_neigh) ||\n\t\t    (rose_route->neigh1 == rose_neigh && rose_route->neigh2 == NULL)       ||\n\t\t    (rose_route->neigh2 == rose_neigh && rose_route->neigh1 == NULL)) {\n\t\t\ts = rose_route->next;\n\t\t\trose_remove_route(rose_route);\n\t\t\trose_route = s;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rose_route->neigh1 == rose_neigh) {\n\t\t\trose_route->neigh1->use--;\n\t\t\trose_route->neigh1 = NULL;\n\t\t\trose_transmit_clear_request(rose_route->neigh2, rose_route->lci2, ROSE_OUT_OF_ORDER, 0);\n\t\t}\n\n\t\tif (rose_route->neigh2 == rose_neigh) {\n\t\t\trose_route->neigh2->use--;\n\t\t\trose_route->neigh2 = NULL;\n\t\t\trose_transmit_clear_request(rose_route->neigh1, rose_route->lci1, ROSE_OUT_OF_ORDER, 0);\n\t\t}\n\n\t\trose_route = rose_route->next;\n\t}\n\tspin_unlock_bh(&rose_route_list_lock);\n}\n\n \nvoid rose_link_failed(ax25_cb *ax25, int reason)\n{\n\tstruct rose_neigh *rose_neigh;\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (rose_neigh->ax25 == ax25)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh != NULL) {\n\t\trose_neigh->ax25 = NULL;\n\t\tax25_cb_put(ax25);\n\n\t\trose_del_route_by_neigh(rose_neigh);\n\t\trose_kill_by_neigh(rose_neigh);\n\t}\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}\n\n \nvoid rose_link_device_down(struct net_device *dev)\n{\n\tstruct rose_neigh *rose_neigh;\n\n\tfor (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next) {\n\t\tif (rose_neigh->dev == dev) {\n\t\t\trose_del_route_by_neigh(rose_neigh);\n\t\t\trose_kill_by_neigh(rose_neigh);\n\t\t}\n\t}\n}\n\n \nint rose_route_frame(struct sk_buff *skb, ax25_cb *ax25)\n{\n\tstruct rose_neigh *rose_neigh, *new_neigh;\n\tstruct rose_route *rose_route;\n\tstruct rose_facilities_struct facilities;\n\trose_address *src_addr, *dest_addr;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci, new_lci;\n\tunsigned char cause, diagnostic;\n\tstruct net_device *dev;\n\tint res = 0;\n\tchar buf[11];\n\n\tif (skb->len < ROSE_MIN_LEN)\n\t\treturn res;\n\n\tif (!ax25)\n\t\treturn rose_loopback_queue(skb, NULL);\n\n\tframetype = skb->data[2];\n\tlci = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\tif (frametype == ROSE_CALL_REQUEST &&\n\t    (skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\n\t     skb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\n\t     ROSE_CALL_REQ_ADDR_LEN_VAL))\n\t\treturn res;\n\tsrc_addr  = (rose_address *)(skb->data + ROSE_CALL_REQ_SRC_ADDR_OFF);\n\tdest_addr = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\tspin_lock_bh(&rose_route_list_lock);\n\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (ax25cmp(&ax25->dest_addr, &rose_neigh->callsign) == 0 &&\n\t\t    ax25->ax25_dev->dev == rose_neigh->dev)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh == NULL) {\n\t\tprintk(\"rose_route : unknown neighbour or device %s\\n\",\n\t\t       ax2asc(buf, &ax25->dest_addr));\n\t\tgoto out;\n\t}\n\n\t \n\trose_stop_ftimer(rose_neigh);\n\n\t \n\tif (lci == 0) {\n\t\trose_link_rx_restart(skb, rose_neigh, frametype);\n\t\tgoto out;\n\t}\n\n\t \n\tif ((sk = rose_find_socket(lci, rose_neigh)) != NULL) {\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tstruct rose_sock *rose = rose_sk(sk);\n\n\t\t\t \n\t\t\trose_clear_queues(sk);\n\t\t\trose->cause\t = ROSE_NETWORK_CONGESTION;\n\t\t\trose->diagnostic = 0;\n\t\t\trose->neighbour->use--;\n\t\t\trose->neighbour\t = NULL;\n\t\t\trose->lci\t = 0;\n\t\t\trose->state\t = ROSE_STATE_0;\n\t\t\tsk->sk_state\t = TCP_CLOSE;\n\t\t\tsk->sk_err\t = 0;\n\t\t\tsk->sk_shutdown\t |= SEND_SHUTDOWN;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\tsock_set_flag(sk, SOCK_DEAD);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tskb_reset_transport_header(skb);\n\t\t\tres = rose_process_rx_frame(sk, skb);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (frametype == ROSE_CALL_REQUEST)\n\t\tif ((dev = rose_dev_get(dest_addr)) != NULL) {\n\t\t\tres = rose_rx_call_request(skb, dev, rose_neigh, lci);\n\t\t\tdev_put(dev);\n\t\t\tgoto out;\n\t\t}\n\n\tif (!sysctl_rose_routing_control) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NOT_OBTAINABLE, 0);\n\t\tgoto out;\n\t}\n\n\t \n\trose_route = rose_route_list;\n\twhile (rose_route != NULL) {\n\t\tif (rose_route->lci1 == lci &&\n\t\t    rose_route->neigh1 == rose_neigh) {\n\t\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\t\t \n\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tbreak;\n\t\t\t} else if (rose_route->neigh2 != NULL) {\n\t\t\t\tskb->data[0] &= 0xF0;\n\t\t\t\tskb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;\n\t\t\t\tskb->data[1]  = (rose_route->lci2 >> 0) & 0xFF;\n\t\t\t\trose_transmit_link(skb, rose_route->neigh2);\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tres = 1;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (rose_route->lci2 == lci &&\n\t\t    rose_route->neigh2 == rose_neigh) {\n\t\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\t\t \n\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tbreak;\n\t\t\t} else if (rose_route->neigh1 != NULL) {\n\t\t\t\tskb->data[0] &= 0xF0;\n\t\t\t\tskb->data[0] |= (rose_route->lci1 >> 8) & 0x0F;\n\t\t\t\tskb->data[1]  = (rose_route->lci1 >> 0) & 0xFF;\n\t\t\t\trose_transmit_link(skb, rose_route->neigh1);\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tres = 1;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trose_route = rose_route->next;\n\t}\n\n\t \n\tif (frametype != ROSE_CALL_REQUEST) {\t \n\t\tres = 0;\n\t\tgoto out;\n\t}\n\n\tmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\n\n\tif (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,\n\t\t\t\t   skb->len - ROSE_CALL_REQ_FACILITIES_OFF,\n\t\t\t\t   &facilities)) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_INVALID_FACILITY, 76);\n\t\tgoto out;\n\t}\n\n\t \n\trose_route = rose_route_list;\n\twhile (rose_route != NULL) {\n\t\tif (rose_route->rand == facilities.rand &&\n\t\t    rosecmp(src_addr, &rose_route->src_addr) == 0 &&\n\t\t    ax25cmp(&facilities.dest_call, &rose_route->src_call) == 0 &&\n\t\t    ax25cmp(&facilities.source_call, &rose_route->dest_call) == 0) {\n\t\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NOT_OBTAINABLE, 120);\n\t\t\tgoto out;\n\t\t}\n\t\trose_route = rose_route->next;\n\t}\n\n\tif ((new_neigh = rose_get_neigh(dest_addr, &cause, &diagnostic, 1)) == NULL) {\n\t\trose_transmit_clear_request(rose_neigh, lci, cause, diagnostic);\n\t\tgoto out;\n\t}\n\n\tif ((new_lci = rose_new_lci(new_neigh)) == 0) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NETWORK_CONGESTION, 71);\n\t\tgoto out;\n\t}\n\n\tif ((rose_route = kmalloc(sizeof(*rose_route), GFP_ATOMIC)) == NULL) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NETWORK_CONGESTION, 120);\n\t\tgoto out;\n\t}\n\n\trose_route->lci1      = lci;\n\trose_route->src_addr  = *src_addr;\n\trose_route->dest_addr = *dest_addr;\n\trose_route->src_call  = facilities.dest_call;\n\trose_route->dest_call = facilities.source_call;\n\trose_route->rand      = facilities.rand;\n\trose_route->neigh1    = rose_neigh;\n\trose_route->lci2      = new_lci;\n\trose_route->neigh2    = new_neigh;\n\n\trose_route->neigh1->use++;\n\trose_route->neigh2->use++;\n\n\trose_route->next = rose_route_list;\n\trose_route_list  = rose_route;\n\n\tskb->data[0] &= 0xF0;\n\tskb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;\n\tskb->data[1]  = (rose_route->lci2 >> 0) & 0xFF;\n\n\trose_transmit_link(skb, rose_route->neigh2);\n\tres = 1;\n\nout:\n\tspin_unlock_bh(&rose_route_list_lock);\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\n\treturn res;\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *rose_node_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rose_node_list_lock)\n{\n\tstruct rose_node *rose_node;\n\tint i = 1;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (rose_node = rose_node_list; rose_node && i < *pos;\n\t     rose_node = rose_node->next, ++i);\n\n\treturn (i == *pos) ? rose_node : NULL;\n}\n\nstatic void *rose_node_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\n\treturn (v == SEQ_START_TOKEN) ? rose_node_list\n\t\t: ((struct rose_node *)v)->next;\n}\n\nstatic void rose_node_stop(struct seq_file *seq, void *v)\n\t__releases(rose_node_list_lock)\n{\n\tspin_unlock_bh(&rose_node_list_lock);\n}\n\nstatic int rose_node_show(struct seq_file *seq, void *v)\n{\n\tchar rsbuf[11];\n\tint i;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"address    mask n neigh neigh neigh\\n\");\n\telse {\n\t\tconst struct rose_node *rose_node = v;\n\t\tseq_printf(seq, \"%-10s %04d %d\",\n\t\t\t   rose2asc(rsbuf, &rose_node->address),\n\t\t\t   rose_node->mask,\n\t\t\t   rose_node->count);\n\n\t\tfor (i = 0; i < rose_node->count; i++)\n\t\t\tseq_printf(seq, \" %05d\", rose_node->neighbour[i]->number);\n\n\t\tseq_puts(seq, \"\\n\");\n\t}\n\treturn 0;\n}\n\nconst struct seq_operations rose_node_seqops = {\n\t.start = rose_node_start,\n\t.next = rose_node_next,\n\t.stop = rose_node_stop,\n\t.show = rose_node_show,\n};\n\nstatic void *rose_neigh_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rose_neigh_list_lock)\n{\n\tstruct rose_neigh *rose_neigh;\n\tint i = 1;\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (rose_neigh = rose_neigh_list; rose_neigh && i < *pos;\n\t     rose_neigh = rose_neigh->next, ++i);\n\n\treturn (i == *pos) ? rose_neigh : NULL;\n}\n\nstatic void *rose_neigh_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\n\treturn (v == SEQ_START_TOKEN) ? rose_neigh_list\n\t\t: ((struct rose_neigh *)v)->next;\n}\n\nstatic void rose_neigh_stop(struct seq_file *seq, void *v)\n\t__releases(rose_neigh_list_lock)\n{\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}\n\nstatic int rose_neigh_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11];\n\tint i;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"addr  callsign  dev  count use mode restart  t0  tf digipeaters\\n\");\n\telse {\n\t\tstruct rose_neigh *rose_neigh = v;\n\n\t\t \n\t\tseq_printf(seq, \"%05d %-9s %-4s   %3d %3d  %3s     %3s %3lu %3lu\",\n\t\t\t   rose_neigh->number,\n\t\t\t   (rose_neigh->loopback) ? \"RSLOOP-0\" : ax2asc(buf, &rose_neigh->callsign),\n\t\t\t   rose_neigh->dev ? rose_neigh->dev->name : \"???\",\n\t\t\t   rose_neigh->count,\n\t\t\t   rose_neigh->use,\n\t\t\t   (rose_neigh->dce_mode) ? \"DCE\" : \"DTE\",\n\t\t\t   (rose_neigh->restarted) ? \"yes\" : \"no\",\n\t\t\t   ax25_display_timer(&rose_neigh->t0timer) / HZ,\n\t\t\t   ax25_display_timer(&rose_neigh->ftimer)  / HZ);\n\n\t\tif (rose_neigh->digipeat != NULL) {\n\t\t\tfor (i = 0; i < rose_neigh->digipeat->ndigi; i++)\n\t\t\t\tseq_printf(seq, \" %s\", ax2asc(buf, &rose_neigh->digipeat->calls[i]));\n\t\t}\n\n\t\tseq_puts(seq, \"\\n\");\n\t}\n\treturn 0;\n}\n\n\nconst struct seq_operations rose_neigh_seqops = {\n\t.start = rose_neigh_start,\n\t.next = rose_neigh_next,\n\t.stop = rose_neigh_stop,\n\t.show = rose_neigh_show,\n};\n\nstatic void *rose_route_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rose_route_list_lock)\n{\n\tstruct rose_route *rose_route;\n\tint i = 1;\n\n\tspin_lock_bh(&rose_route_list_lock);\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (rose_route = rose_route_list; rose_route && i < *pos;\n\t     rose_route = rose_route->next, ++i);\n\n\treturn (i == *pos) ? rose_route : NULL;\n}\n\nstatic void *rose_route_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\n\treturn (v == SEQ_START_TOKEN) ? rose_route_list\n\t\t: ((struct rose_route *)v)->next;\n}\n\nstatic void rose_route_stop(struct seq_file *seq, void *v)\n\t__releases(rose_route_list_lock)\n{\n\tspin_unlock_bh(&rose_route_list_lock);\n}\n\nstatic int rose_route_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11], rsbuf[11];\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"lci  address     callsign   neigh  <-> lci  address     callsign   neigh\\n\");\n\telse {\n\t\tstruct rose_route *rose_route = v;\n\n\t\tif (rose_route->neigh1)\n\t\t\tseq_printf(seq,\n\t\t\t\t   \"%3.3X  %-10s  %-9s  %05d      \",\n\t\t\t\t   rose_route->lci1,\n\t\t\t\t   rose2asc(rsbuf, &rose_route->src_addr),\n\t\t\t\t   ax2asc(buf, &rose_route->src_call),\n\t\t\t\t   rose_route->neigh1->number);\n\t\telse\n\t\t\tseq_puts(seq,\n\t\t\t\t \"000  *           *          00000      \");\n\n\t\tif (rose_route->neigh2)\n\t\t\tseq_printf(seq,\n\t\t\t\t   \"%3.3X  %-10s  %-9s  %05d\\n\",\n\t\t\t\t   rose_route->lci2,\n\t\t\t\t   rose2asc(rsbuf, &rose_route->dest_addr),\n\t\t\t\t   ax2asc(buf, &rose_route->dest_call),\n\t\t\t\t   rose_route->neigh2->number);\n\t\t else\n\t\t\t seq_puts(seq,\n\t\t\t\t  \"000  *           *          00000\\n\");\n\t\t}\n\treturn 0;\n}\n\nstruct seq_operations rose_route_seqops = {\n\t.start = rose_route_start,\n\t.next = rose_route_next,\n\t.stop = rose_route_stop,\n\t.show = rose_route_show,\n};\n#endif  \n\n \nvoid __exit rose_rt_free(void)\n{\n\tstruct rose_neigh *s, *rose_neigh = rose_neigh_list;\n\tstruct rose_node  *t, *rose_node  = rose_node_list;\n\tstruct rose_route *u, *rose_route = rose_route_list;\n\n\twhile (rose_neigh != NULL) {\n\t\ts          = rose_neigh;\n\t\trose_neigh = rose_neigh->next;\n\n\t\trose_remove_neigh(s);\n\t}\n\n\twhile (rose_node != NULL) {\n\t\tt         = rose_node;\n\t\trose_node = rose_node->next;\n\n\t\trose_remove_node(t);\n\t}\n\n\twhile (rose_route != NULL) {\n\t\tu          = rose_route;\n\t\trose_route = rose_route->next;\n\n\t\trose_remove_route(u);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}