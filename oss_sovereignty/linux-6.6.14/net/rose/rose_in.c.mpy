{
  "module_name": "rose_in.c",
  "hash_id": "16e207cf4e8033162edf9775204141f7f7b4266985b06526658aa481356afbe4",
  "original_prompt": "Ingested from linux-6.6.14/net/rose/rose_in.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/filter.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/rose.h>\n\n \nstatic int rose_state1_machine(struct sock *sk, struct sk_buff *skb, int frametype)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_ACCEPTED:\n\t\trose_stop_timer(sk);\n\t\trose_start_idletimer(sk);\n\t\trose->condition = 0x00;\n\t\trose->vs        = 0;\n\t\trose->va        = 0;\n\t\trose->vr        = 0;\n\t\trose->vl        = 0;\n\t\trose->state     = ROSE_STATE_3;\n\t\tsk->sk_state\t= TCP_ESTABLISHED;\n\t\tif (!sock_flag(sk, SOCK_DEAD))\n\t\t\tsk->sk_state_change(sk);\n\t\tbreak;\n\n\tcase ROSE_CLEAR_REQUEST:\n\t\trose_write_internal(sk, ROSE_CLEAR_CONFIRMATION);\n\t\trose_disconnect(sk, ECONNREFUSED, skb->data[3], skb->data[4]);\n\t\trose->neighbour->use--;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rose_state2_machine(struct sock *sk, struct sk_buff *skb, int frametype)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tswitch (frametype) {\n\tcase ROSE_CLEAR_REQUEST:\n\t\trose_write_internal(sk, ROSE_CLEAR_CONFIRMATION);\n\t\trose_disconnect(sk, 0, skb->data[3], skb->data[4]);\n\t\trose->neighbour->use--;\n\t\tbreak;\n\n\tcase ROSE_CLEAR_CONFIRMATION:\n\t\trose_disconnect(sk, 0, -1, -1);\n\t\trose->neighbour->use--;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rose_state3_machine(struct sock *sk, struct sk_buff *skb, int frametype, int ns, int nr, int q, int d, int m)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint queued = 0;\n\n\tswitch (frametype) {\n\tcase ROSE_RESET_REQUEST:\n\t\trose_stop_timer(sk);\n\t\trose_start_idletimer(sk);\n\t\trose_write_internal(sk, ROSE_RESET_CONFIRMATION);\n\t\trose->condition = 0x00;\n\t\trose->vs        = 0;\n\t\trose->vr        = 0;\n\t\trose->va        = 0;\n\t\trose->vl        = 0;\n\t\trose_requeue_frames(sk);\n\t\tbreak;\n\n\tcase ROSE_CLEAR_REQUEST:\n\t\trose_write_internal(sk, ROSE_CLEAR_CONFIRMATION);\n\t\trose_disconnect(sk, 0, skb->data[3], skb->data[4]);\n\t\trose->neighbour->use--;\n\t\tbreak;\n\n\tcase ROSE_RR:\n\tcase ROSE_RNR:\n\t\tif (!rose_validate_nr(sk, nr)) {\n\t\t\trose_write_internal(sk, ROSE_RESET_REQUEST);\n\t\t\trose->condition = 0x00;\n\t\t\trose->vs        = 0;\n\t\t\trose->vr        = 0;\n\t\t\trose->va        = 0;\n\t\t\trose->vl        = 0;\n\t\t\trose->state     = ROSE_STATE_4;\n\t\t\trose_start_t2timer(sk);\n\t\t\trose_stop_idletimer(sk);\n\t\t} else {\n\t\t\trose_frames_acked(sk, nr);\n\t\t\tif (frametype == ROSE_RNR) {\n\t\t\t\trose->condition |= ROSE_COND_PEER_RX_BUSY;\n\t\t\t} else {\n\t\t\t\trose->condition &= ~ROSE_COND_PEER_RX_BUSY;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ROSE_DATA:\t \n\t\trose->condition &= ~ROSE_COND_PEER_RX_BUSY;\n\t\tif (!rose_validate_nr(sk, nr)) {\n\t\t\trose_write_internal(sk, ROSE_RESET_REQUEST);\n\t\t\trose->condition = 0x00;\n\t\t\trose->vs        = 0;\n\t\t\trose->vr        = 0;\n\t\t\trose->va        = 0;\n\t\t\trose->vl        = 0;\n\t\t\trose->state     = ROSE_STATE_4;\n\t\t\trose_start_t2timer(sk);\n\t\t\trose_stop_idletimer(sk);\n\t\t\tbreak;\n\t\t}\n\t\trose_frames_acked(sk, nr);\n\t\tif (ns == rose->vr) {\n\t\t\trose_start_idletimer(sk);\n\t\t\tif (sk_filter_trim_cap(sk, skb, ROSE_MIN_LEN) == 0 &&\n\t\t\t    __sock_queue_rcv_skb(sk, skb) == 0) {\n\t\t\t\trose->vr = (rose->vr + 1) % ROSE_MODULUS;\n\t\t\t\tqueued = 1;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trose_write_internal(sk, ROSE_RESET_REQUEST);\n\t\t\t\trose->condition = 0x00;\n\t\t\t\trose->vs        = 0;\n\t\t\t\trose->vr        = 0;\n\t\t\t\trose->va        = 0;\n\t\t\t\trose->vl        = 0;\n\t\t\t\trose->state     = ROSE_STATE_4;\n\t\t\t\trose_start_t2timer(sk);\n\t\t\t\trose_stop_idletimer(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (atomic_read(&sk->sk_rmem_alloc) >\n\t\t\t    (sk->sk_rcvbuf >> 1))\n\t\t\t\trose->condition |= ROSE_COND_OWN_RX_BUSY;\n\t\t}\n\t\t \n\t\tif (((rose->vl + sysctl_rose_window_size) % ROSE_MODULUS) == rose->vr) {\n\t\t\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\t\t\trose_stop_timer(sk);\n\t\t\trose_enquiry_response(sk);\n\t\t} else {\n\t\t\trose->condition |= ROSE_COND_ACK_PENDING;\n\t\t\trose_start_hbtimer(sk);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_WARNING \"ROSE: unknown %02X in state 3\\n\", frametype);\n\t\tbreak;\n\t}\n\n\treturn queued;\n}\n\n \nstatic int rose_state4_machine(struct sock *sk, struct sk_buff *skb, int frametype)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tswitch (frametype) {\n\tcase ROSE_RESET_REQUEST:\n\t\trose_write_internal(sk, ROSE_RESET_CONFIRMATION);\n\t\tfallthrough;\n\tcase ROSE_RESET_CONFIRMATION:\n\t\trose_stop_timer(sk);\n\t\trose_start_idletimer(sk);\n\t\trose->condition = 0x00;\n\t\trose->va        = 0;\n\t\trose->vr        = 0;\n\t\trose->vs        = 0;\n\t\trose->vl        = 0;\n\t\trose->state     = ROSE_STATE_3;\n\t\trose_requeue_frames(sk);\n\t\tbreak;\n\n\tcase ROSE_CLEAR_REQUEST:\n\t\trose_write_internal(sk, ROSE_CLEAR_CONFIRMATION);\n\t\trose_disconnect(sk, 0, skb->data[3], skb->data[4]);\n\t\trose->neighbour->use--;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rose_state5_machine(struct sock *sk, struct sk_buff *skb, int frametype)\n{\n\tif (frametype == ROSE_CLEAR_REQUEST) {\n\t\trose_write_internal(sk, ROSE_CLEAR_CONFIRMATION);\n\t\trose_disconnect(sk, 0, skb->data[3], skb->data[4]);\n\t\trose_sk(sk)->neighbour->use--;\n\t}\n\n\treturn 0;\n}\n\n \nint rose_process_rx_frame(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint queued = 0, frametype, ns, nr, q, d, m;\n\n\tif (rose->state == ROSE_STATE_0)\n\t\treturn 0;\n\n\tframetype = rose_decode(skb, &ns, &nr, &q, &d, &m);\n\n\tswitch (rose->state) {\n\tcase ROSE_STATE_1:\n\t\tqueued = rose_state1_machine(sk, skb, frametype);\n\t\tbreak;\n\tcase ROSE_STATE_2:\n\t\tqueued = rose_state2_machine(sk, skb, frametype);\n\t\tbreak;\n\tcase ROSE_STATE_3:\n\t\tqueued = rose_state3_machine(sk, skb, frametype, ns, nr, q, d, m);\n\t\tbreak;\n\tcase ROSE_STATE_4:\n\t\tqueued = rose_state4_machine(sk, skb, frametype);\n\t\tbreak;\n\tcase ROSE_STATE_5:\n\t\tqueued = rose_state5_machine(sk, skb, frametype);\n\t\tbreak;\n\t}\n\n\trose_kick(sk);\n\n\treturn queued;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}