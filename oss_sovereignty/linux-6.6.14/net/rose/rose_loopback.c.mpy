{
  "module_name": "rose_loopback.c",
  "hash_id": "05bb974c1468e8d47bc5d2c8631abc27f9d7757fbca2b7d25f97a26d532c9172",
  "original_prompt": "Ingested from linux-6.6.14/net/rose/rose_loopback.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/timer.h>\n#include <net/ax25.h>\n#include <linux/skbuff.h>\n#include <net/rose.h>\n#include <linux/init.h>\n\nstatic struct sk_buff_head loopback_queue;\n#define ROSE_LOOPBACK_LIMIT 1000\nstatic struct timer_list loopback_timer;\n\nstatic void rose_set_loopback_timer(void);\nstatic void rose_loopback_timer(struct timer_list *unused);\n\nvoid rose_loopback_init(void)\n{\n\tskb_queue_head_init(&loopback_queue);\n\n\ttimer_setup(&loopback_timer, rose_loopback_timer, 0);\n}\n\nstatic int rose_loopback_running(void)\n{\n\treturn timer_pending(&loopback_timer);\n}\n\nint rose_loopback_queue(struct sk_buff *skb, struct rose_neigh *neigh)\n{\n\tstruct sk_buff *skbn = NULL;\n\n\tif (skb_queue_len(&loopback_queue) < ROSE_LOOPBACK_LIMIT)\n\t\tskbn = skb_clone(skb, GFP_ATOMIC);\n\n\tif (skbn) {\n\t\tconsume_skb(skb);\n\t\tskb_queue_tail(&loopback_queue, skbn);\n\n\t\tif (!rose_loopback_running())\n\t\t\trose_set_loopback_timer();\n\t} else {\n\t\tkfree_skb(skb);\n\t}\n\n\treturn 1;\n}\n\nstatic void rose_set_loopback_timer(void)\n{\n\tmod_timer(&loopback_timer, jiffies + 10);\n}\n\nstatic void rose_loopback_timer(struct timer_list *unused)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\trose_address *dest;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci_i, lci_o;\n\tint count;\n\n\tfor (count = 0; count < ROSE_LOOPBACK_LIMIT; count++) {\n\t\tskb = skb_dequeue(&loopback_queue);\n\t\tif (!skb)\n\t\t\treturn;\n\t\tif (skb->len < ROSE_MIN_LEN) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\t\tframetype = skb->data[2];\n\t\tif (frametype == ROSE_CALL_REQUEST &&\n\t\t    (skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\n\t\t     skb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\n\t\t     ROSE_CALL_REQ_ADDR_LEN_VAL)) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tdest      = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\n\t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n\n\t\tskb_reset_transport_header(skb);\n\n\t\tsk = rose_find_socket(lci_o, rose_loopback_neigh);\n\t\tif (sk) {\n\t\t\tif (rose_process_rx_frame(sk, skb) == 0)\n\t\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tif (!rose_loopback_neigh->dev &&\n\t\t\t    !rose_loopback_neigh->loopback) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdev = rose_dev_get(dest);\n\t\t\tif (!dev) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rose_rx_call_request(skb, dev, rose_loopback_neigh, lci_o) == 0) {\n\t\t\t\tdev_put(dev);\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\tif (!skb_queue_empty(&loopback_queue))\n\t\tmod_timer(&loopback_timer, jiffies + 1);\n}\n\nvoid __exit rose_loopback_clear(void)\n{\n\tstruct sk_buff *skb;\n\n\tdel_timer(&loopback_timer);\n\n\twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n\t\tskb->sk = NULL;\n\t\tkfree_skb(skb);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}