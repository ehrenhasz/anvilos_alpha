{
  "module_name": "rose_link.c",
  "hash_id": "03094087827aca81c7f8a641fae8eed22a8a4a72f66735a9a410675843ade2d5",
  "original_prompt": "Ingested from linux-6.6.14/net/rose/rose_link.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/rose.h>\n\nstatic void rose_ftimer_expiry(struct timer_list *);\nstatic void rose_t0timer_expiry(struct timer_list *);\n\nstatic void rose_transmit_restart_confirmation(struct rose_neigh *neigh);\nstatic void rose_transmit_restart_request(struct rose_neigh *neigh);\n\nvoid rose_start_ftimer(struct rose_neigh *neigh)\n{\n\tdel_timer(&neigh->ftimer);\n\n\tneigh->ftimer.function = rose_ftimer_expiry;\n\tneigh->ftimer.expires  =\n\t\tjiffies + msecs_to_jiffies(sysctl_rose_link_fail_timeout);\n\n\tadd_timer(&neigh->ftimer);\n}\n\nstatic void rose_start_t0timer(struct rose_neigh *neigh)\n{\n\tdel_timer(&neigh->t0timer);\n\n\tneigh->t0timer.function = rose_t0timer_expiry;\n\tneigh->t0timer.expires  =\n\t\tjiffies + msecs_to_jiffies(sysctl_rose_restart_request_timeout);\n\n\tadd_timer(&neigh->t0timer);\n}\n\nvoid rose_stop_ftimer(struct rose_neigh *neigh)\n{\n\tdel_timer(&neigh->ftimer);\n}\n\nvoid rose_stop_t0timer(struct rose_neigh *neigh)\n{\n\tdel_timer(&neigh->t0timer);\n}\n\nint rose_ftimer_running(struct rose_neigh *neigh)\n{\n\treturn timer_pending(&neigh->ftimer);\n}\n\nstatic int rose_t0timer_running(struct rose_neigh *neigh)\n{\n\treturn timer_pending(&neigh->t0timer);\n}\n\nstatic void rose_ftimer_expiry(struct timer_list *t)\n{\n}\n\nstatic void rose_t0timer_expiry(struct timer_list *t)\n{\n\tstruct rose_neigh *neigh = from_timer(neigh, t, t0timer);\n\n\trose_transmit_restart_request(neigh);\n\n\tneigh->dce_mode = 0;\n\n\trose_start_t0timer(neigh);\n}\n\n \nstatic int rose_send_frame(struct sk_buff *skb, struct rose_neigh *neigh)\n{\n\tconst ax25_address *rose_call;\n\tax25_cb *ax25s;\n\n\tif (ax25cmp(&rose_callsign, &null_ax25_address) == 0)\n\t\trose_call = (const ax25_address *)neigh->dev->dev_addr;\n\telse\n\t\trose_call = &rose_callsign;\n\n\tax25s = neigh->ax25;\n\tneigh->ax25 = ax25_send_frame(skb, 260, rose_call, &neigh->callsign, neigh->digipeat, neigh->dev);\n\tif (ax25s)\n\t\tax25_cb_put(ax25s);\n\n\treturn neigh->ax25 != NULL;\n}\n\n \nstatic int rose_link_up(struct rose_neigh *neigh)\n{\n\tconst ax25_address *rose_call;\n\tax25_cb *ax25s;\n\n\tif (ax25cmp(&rose_callsign, &null_ax25_address) == 0)\n\t\trose_call = (const ax25_address *)neigh->dev->dev_addr;\n\telse\n\t\trose_call = &rose_callsign;\n\n\tax25s = neigh->ax25;\n\tneigh->ax25 = ax25_find_cb(rose_call, &neigh->callsign, neigh->digipeat, neigh->dev);\n\tif (ax25s)\n\t\tax25_cb_put(ax25s);\n\n\treturn neigh->ax25 != NULL;\n}\n\n \nvoid rose_link_rx_restart(struct sk_buff *skb, struct rose_neigh *neigh, unsigned short frametype)\n{\n\tstruct sk_buff *skbn;\n\n\tswitch (frametype) {\n\tcase ROSE_RESTART_REQUEST:\n\t\trose_stop_t0timer(neigh);\n\t\tneigh->restarted = 1;\n\t\tneigh->dce_mode  = (skb->data[3] == ROSE_DTE_ORIGINATED);\n\t\trose_transmit_restart_confirmation(neigh);\n\t\tbreak;\n\n\tcase ROSE_RESTART_CONFIRMATION:\n\t\trose_stop_t0timer(neigh);\n\t\tneigh->restarted = 1;\n\t\tbreak;\n\n\tcase ROSE_DIAGNOSTIC:\n\t\tpr_warn(\"ROSE: received diagnostic #%d - %3ph\\n\", skb->data[3],\n\t\t\tskb->data + 4);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_WARNING \"ROSE: received unknown %02X with LCI 000\\n\", frametype);\n\t\tbreak;\n\t}\n\n\tif (neigh->restarted) {\n\t\twhile ((skbn = skb_dequeue(&neigh->queue)) != NULL)\n\t\t\tif (!rose_send_frame(skbn, neigh))\n\t\t\t\tkfree_skb(skbn);\n\t}\n}\n\n \nstatic void rose_transmit_restart_request(struct rose_neigh *neigh)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *dptr;\n\tint len;\n\n\tlen = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 3;\n\n\tif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN);\n\n\tdptr = skb_put(skb, ROSE_MIN_LEN + 3);\n\n\t*dptr++ = AX25_P_ROSE;\n\t*dptr++ = ROSE_GFI;\n\t*dptr++ = 0x00;\n\t*dptr++ = ROSE_RESTART_REQUEST;\n\t*dptr++ = ROSE_DTE_ORIGINATED;\n\t*dptr++ = 0;\n\n\tif (!rose_send_frame(skb, neigh))\n\t\tkfree_skb(skb);\n}\n\n \nstatic void rose_transmit_restart_confirmation(struct rose_neigh *neigh)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *dptr;\n\tint len;\n\n\tlen = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1;\n\n\tif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN);\n\n\tdptr = skb_put(skb, ROSE_MIN_LEN + 1);\n\n\t*dptr++ = AX25_P_ROSE;\n\t*dptr++ = ROSE_GFI;\n\t*dptr++ = 0x00;\n\t*dptr++ = ROSE_RESTART_CONFIRMATION;\n\n\tif (!rose_send_frame(skb, neigh))\n\t\tkfree_skb(skb);\n}\n\n \nvoid rose_transmit_clear_request(struct rose_neigh *neigh, unsigned int lci, unsigned char cause, unsigned char diagnostic)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *dptr;\n\tint len;\n\n\tif (!neigh->dev)\n\t\treturn;\n\n\tlen = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 3;\n\n\tif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN);\n\n\tdptr = skb_put(skb, ROSE_MIN_LEN + 3);\n\n\t*dptr++ = AX25_P_ROSE;\n\t*dptr++ = ((lci >> 8) & 0x0F) | ROSE_GFI;\n\t*dptr++ = ((lci >> 0) & 0xFF);\n\t*dptr++ = ROSE_CLEAR_REQUEST;\n\t*dptr++ = cause;\n\t*dptr++ = diagnostic;\n\n\tif (!rose_send_frame(skb, neigh))\n\t\tkfree_skb(skb);\n}\n\nvoid rose_transmit_link(struct sk_buff *skb, struct rose_neigh *neigh)\n{\n\tunsigned char *dptr;\n\n\tif (neigh->loopback) {\n\t\trose_loopback_queue(skb, neigh);\n\t\treturn;\n\t}\n\n\tif (!rose_link_up(neigh))\n\t\tneigh->restarted = 0;\n\n\tdptr = skb_push(skb, 1);\n\t*dptr++ = AX25_P_ROSE;\n\n\tif (neigh->restarted) {\n\t\tif (!rose_send_frame(skb, neigh))\n\t\t\tkfree_skb(skb);\n\t} else {\n\t\tskb_queue_tail(&neigh->queue, skb);\n\n\t\tif (!rose_t0timer_running(neigh)) {\n\t\t\trose_transmit_restart_request(neigh);\n\t\t\tneigh->dce_mode = 0;\n\t\t\trose_start_t0timer(neigh);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}