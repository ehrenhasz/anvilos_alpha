{
  "module_name": "af_rose.c",
  "hash_id": "55897c9e93340265b89b99e1a0a02fa98065817b015a28fdd6ae2787b1c20457",
  "original_prompt": "Ingested from linux-6.6.14/net/rose/af_rose.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/stat.h>\n#include <net/net_namespace.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <net/rose.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <net/tcp_states.h>\n#include <net/ip.h>\n#include <net/arp.h>\n\nstatic int rose_ndevs = 10;\n\nint sysctl_rose_restart_request_timeout = ROSE_DEFAULT_T0;\nint sysctl_rose_call_request_timeout    = ROSE_DEFAULT_T1;\nint sysctl_rose_reset_request_timeout   = ROSE_DEFAULT_T2;\nint sysctl_rose_clear_request_timeout   = ROSE_DEFAULT_T3;\nint sysctl_rose_no_activity_timeout     = ROSE_DEFAULT_IDLE;\nint sysctl_rose_ack_hold_back_timeout   = ROSE_DEFAULT_HB;\nint sysctl_rose_routing_control         = ROSE_DEFAULT_ROUTING;\nint sysctl_rose_link_fail_timeout       = ROSE_DEFAULT_FAIL_TIMEOUT;\nint sysctl_rose_maximum_vcs             = ROSE_DEFAULT_MAXVC;\nint sysctl_rose_window_size             = ROSE_DEFAULT_WINDOW_SIZE;\n\nstatic HLIST_HEAD(rose_list);\nstatic DEFINE_SPINLOCK(rose_list_lock);\n\nstatic const struct proto_ops rose_proto_ops;\n\nax25_address rose_callsign;\n\n \nstatic struct lock_class_key rose_netdev_xmit_lock_key;\nstatic struct lock_class_key rose_netdev_addr_lock_key;\n\nstatic void rose_set_lockdep_one(struct net_device *dev,\n\t\t\t\t struct netdev_queue *txq,\n\t\t\t\t void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock, &rose_netdev_xmit_lock_key);\n}\n\nstatic void rose_set_lockdep_key(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock, &rose_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, rose_set_lockdep_one, NULL);\n}\n\n \nchar *rose2asc(char *buf, const rose_address *addr)\n{\n\tif (addr->rose_addr[0] == 0x00 && addr->rose_addr[1] == 0x00 &&\n\t    addr->rose_addr[2] == 0x00 && addr->rose_addr[3] == 0x00 &&\n\t    addr->rose_addr[4] == 0x00) {\n\t\tstrcpy(buf, \"*\");\n\t} else {\n\t\tsprintf(buf, \"%02X%02X%02X%02X%02X\", addr->rose_addr[0] & 0xFF,\n\t\t\t\t\t\taddr->rose_addr[1] & 0xFF,\n\t\t\t\t\t\taddr->rose_addr[2] & 0xFF,\n\t\t\t\t\t\taddr->rose_addr[3] & 0xFF,\n\t\t\t\t\t\taddr->rose_addr[4] & 0xFF);\n\t}\n\n\treturn buf;\n}\n\n \nint rosecmp(const rose_address *addr1, const rose_address *addr2)\n{\n\tint i;\n\n\tfor (i = 0; i < 5; i++)\n\t\tif (addr1->rose_addr[i] != addr2->rose_addr[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n \nint rosecmpm(const rose_address *addr1, const rose_address *addr2,\n\t     unsigned short mask)\n{\n\tunsigned int i, j;\n\n\tif (mask > 10)\n\t\treturn 1;\n\n\tfor (i = 0; i < mask; i++) {\n\t\tj = i / 2;\n\n\t\tif ((i % 2) != 0) {\n\t\t\tif ((addr1->rose_addr[j] & 0x0F) != (addr2->rose_addr[j] & 0x0F))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif ((addr1->rose_addr[j] & 0xF0) != (addr2->rose_addr[j] & 0xF0))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void rose_remove_socket(struct sock *sk)\n{\n\tspin_lock_bh(&rose_list_lock);\n\tsk_del_node_init(sk);\n\tspin_unlock_bh(&rose_list_lock);\n}\n\n \nvoid rose_kill_by_neigh(struct rose_neigh *neigh)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_for_each(s, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (rose->neighbour == neigh) {\n\t\t\trose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);\n\t\t\trose->neighbour->use--;\n\t\t\trose->neighbour = NULL;\n\t\t}\n\t}\n\tspin_unlock_bh(&rose_list_lock);\n}\n\n \nstatic void rose_kill_by_device(struct net_device *dev)\n{\n\tstruct sock *sk, *array[16];\n\tstruct rose_sock *rose;\n\tbool rescan;\n\tint i, cnt;\n\nstart:\n\trescan = false;\n\tcnt = 0;\n\tspin_lock_bh(&rose_list_lock);\n\tsk_for_each(sk, &rose_list) {\n\t\trose = rose_sk(sk);\n\t\tif (rose->device == dev) {\n\t\t\tif (cnt == ARRAY_SIZE(array)) {\n\t\t\t\trescan = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsock_hold(sk);\n\t\t\tarray[cnt++] = sk;\n\t\t}\n\t}\n\tspin_unlock_bh(&rose_list_lock);\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tsk = array[cnt];\n\t\trose = rose_sk(sk);\n\t\tlock_sock(sk);\n\t\tspin_lock_bh(&rose_list_lock);\n\t\tif (rose->device == dev) {\n\t\t\trose_disconnect(sk, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);\n\t\t\tif (rose->neighbour)\n\t\t\t\trose->neighbour->use--;\n\t\t\tnetdev_put(rose->device, &rose->dev_tracker);\n\t\t\trose->device = NULL;\n\t\t}\n\t\tspin_unlock_bh(&rose_list_lock);\n\t\trelease_sock(sk);\n\t\tsock_put(sk);\n\t\tcond_resched();\n\t}\n\tif (rescan)\n\t\tgoto start;\n}\n\n \nstatic int rose_device_event(struct notifier_block *this,\n\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (dev->type) {\n\tcase ARPHRD_ROSE:\n\t\trose_kill_by_device(dev);\n\t\tbreak;\n\tcase ARPHRD_AX25:\n\t\trose_link_device_down(dev);\n\t\trose_rt_device_down(dev);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic void rose_insert_socket(struct sock *sk)\n{\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_add_node(sk, &rose_list);\n\tspin_unlock_bh(&rose_list_lock);\n}\n\n \nstatic struct sock *rose_find_listener(rose_address *addr, ax25_address *call)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_for_each(s, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (!rosecmp(&rose->source_addr, addr) &&\n\t\t    !ax25cmp(&rose->source_call, call) &&\n\t\t    !rose->source_ndigis && s->sk_state == TCP_LISTEN)\n\t\t\tgoto found;\n\t}\n\n\tsk_for_each(s, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (!rosecmp(&rose->source_addr, addr) &&\n\t\t    !ax25cmp(&rose->source_call, &null_ax25_address) &&\n\t\t    s->sk_state == TCP_LISTEN)\n\t\t\tgoto found;\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&rose_list_lock);\n\treturn s;\n}\n\n \nstruct sock *rose_find_socket(unsigned int lci, struct rose_neigh *neigh)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_for_each(s, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (rose->lci == lci && rose->neighbour == neigh)\n\t\t\tgoto found;\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&rose_list_lock);\n\treturn s;\n}\n\n \nunsigned int rose_new_lci(struct rose_neigh *neigh)\n{\n\tint lci;\n\n\tif (neigh->dce_mode) {\n\t\tfor (lci = 1; lci <= sysctl_rose_maximum_vcs; lci++)\n\t\t\tif (rose_find_socket(lci, neigh) == NULL && rose_route_free_lci(lci, neigh) == NULL)\n\t\t\t\treturn lci;\n\t} else {\n\t\tfor (lci = sysctl_rose_maximum_vcs; lci > 0; lci--)\n\t\t\tif (rose_find_socket(lci, neigh) == NULL && rose_route_free_lci(lci, neigh) == NULL)\n\t\t\t\treturn lci;\n\t}\n\n\treturn 0;\n}\n\n \nvoid rose_destroy_socket(struct sock *);\n\n \nstatic void rose_destroy_timer(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\n\trose_destroy_socket(sk);\n}\n\n \nvoid rose_destroy_socket(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\trose_remove_socket(sk);\n\trose_stop_heartbeat(sk);\n\trose_stop_idletimer(sk);\n\trose_stop_timer(sk);\n\n\trose_clear_queues(sk);\t\t \n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (skb->sk != sk) {\t \n\t\t\t \n\t\t\tsock_set_flag(skb->sk, SOCK_DEAD);\n\t\t\trose_start_heartbeat(skb->sk);\n\t\t\trose_sk(skb->sk)->state = ROSE_STATE_0;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\tif (sk_has_allocations(sk)) {\n\t\t \n\t\ttimer_setup(&sk->sk_timer, rose_destroy_timer, 0);\n\t\tsk->sk_timer.expires  = jiffies + 10 * HZ;\n\t\tadd_timer(&sk->sk_timer);\n\t} else\n\t\tsock_put(sk);\n}\n\n \n\nstatic int rose_setsockopt(struct socket *sock, int level, int optname,\n\t\tsockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint opt;\n\n\tif (level != SOL_ROSE)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&opt, optval, sizeof(int)))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase ROSE_DEFER:\n\t\trose->defer = opt ? 1 : 0;\n\t\treturn 0;\n\n\tcase ROSE_T1:\n\t\tif (opt < 1)\n\t\t\treturn -EINVAL;\n\t\trose->t1 = opt * HZ;\n\t\treturn 0;\n\n\tcase ROSE_T2:\n\t\tif (opt < 1)\n\t\t\treturn -EINVAL;\n\t\trose->t2 = opt * HZ;\n\t\treturn 0;\n\n\tcase ROSE_T3:\n\t\tif (opt < 1)\n\t\t\treturn -EINVAL;\n\t\trose->t3 = opt * HZ;\n\t\treturn 0;\n\n\tcase ROSE_HOLDBACK:\n\t\tif (opt < 1)\n\t\t\treturn -EINVAL;\n\t\trose->hb = opt * HZ;\n\t\treturn 0;\n\n\tcase ROSE_IDLE:\n\t\tif (opt < 0)\n\t\t\treturn -EINVAL;\n\t\trose->idle = opt * 60 * HZ;\n\t\treturn 0;\n\n\tcase ROSE_QBITINCL:\n\t\trose->qbitincl = opt ? 1 : 0;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\nstatic int rose_getsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint val = 0;\n\tint len;\n\n\tif (level != SOL_ROSE)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase ROSE_DEFER:\n\t\tval = rose->defer;\n\t\tbreak;\n\n\tcase ROSE_T1:\n\t\tval = rose->t1 / HZ;\n\t\tbreak;\n\n\tcase ROSE_T2:\n\t\tval = rose->t2 / HZ;\n\t\tbreak;\n\n\tcase ROSE_T3:\n\t\tval = rose->t3 / HZ;\n\t\tbreak;\n\n\tcase ROSE_HOLDBACK:\n\t\tval = rose->hb / HZ;\n\t\tbreak;\n\n\tcase ROSE_IDLE:\n\t\tval = rose->idle / (60 * HZ);\n\t\tbreak;\n\n\tcase ROSE_QBITINCL:\n\t\tval = rose->qbitincl;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn copy_to_user(optval, &val, len) ? -EFAULT : 0;\n}\n\nstatic int rose_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\n\tlock_sock(sk);\n\tif (sock->state != SS_UNCONNECTED) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tstruct rose_sock *rose = rose_sk(sk);\n\n\t\trose->dest_ndigis = 0;\n\t\tmemset(&rose->dest_addr, 0, ROSE_ADDR_LEN);\n\t\tmemset(&rose->dest_call, 0, AX25_ADDR_LEN);\n\t\tmemset(rose->dest_digis, 0, AX25_ADDR_LEN * ROSE_MAX_DIGIS);\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct proto rose_proto = {\n\t.name\t  = \"ROSE\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct rose_sock),\n};\n\nstatic int rose_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tstruct rose_sock *rose;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tif (sock->type != SOCK_SEQPACKET || protocol != 0)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\trose = rose_sk(sk);\n\n\tsock_init_data(sock, sk);\n\n\tskb_queue_head_init(&rose->ack_queue);\n#ifdef M_BIT\n\tskb_queue_head_init(&rose->frag_queue);\n\trose->fraglen    = 0;\n#endif\n\n\tsock->ops    = &rose_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\ttimer_setup(&rose->timer, NULL, 0);\n\ttimer_setup(&rose->idletimer, NULL, 0);\n\n\trose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);\n\trose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);\n\trose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);\n\trose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);\n\trose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);\n\n\trose->state = ROSE_STATE_0;\n\n\treturn 0;\n}\n\nstatic struct sock *rose_make_new(struct sock *osk)\n{\n\tstruct sock *sk;\n\tstruct rose_sock *rose, *orose;\n\n\tif (osk->sk_type != SOCK_SEQPACKET)\n\t\treturn NULL;\n\n\tsk = sk_alloc(sock_net(osk), PF_ROSE, GFP_ATOMIC, &rose_proto, 0);\n\tif (sk == NULL)\n\t\treturn NULL;\n\n\trose = rose_sk(sk);\n\n\tsock_init_data(NULL, sk);\n\n\tskb_queue_head_init(&rose->ack_queue);\n#ifdef M_BIT\n\tskb_queue_head_init(&rose->frag_queue);\n\trose->fraglen  = 0;\n#endif\n\n\tsk->sk_type     = osk->sk_type;\n\tsk->sk_priority = osk->sk_priority;\n\tsk->sk_protocol = osk->sk_protocol;\n\tsk->sk_rcvbuf   = osk->sk_rcvbuf;\n\tsk->sk_sndbuf   = osk->sk_sndbuf;\n\tsk->sk_state    = TCP_ESTABLISHED;\n\tsock_copy_flags(sk, osk);\n\n\ttimer_setup(&rose->timer, NULL, 0);\n\ttimer_setup(&rose->idletimer, NULL, 0);\n\n\torose\t\t= rose_sk(osk);\n\trose->t1\t= orose->t1;\n\trose->t2\t= orose->t2;\n\trose->t3\t= orose->t3;\n\trose->hb\t= orose->hb;\n\trose->idle\t= orose->idle;\n\trose->defer\t= orose->defer;\n\trose->device\t= orose->device;\n\tif (rose->device)\n\t\tnetdev_hold(rose->device, &rose->dev_tracker, GFP_ATOMIC);\n\trose->qbitincl\t= orose->qbitincl;\n\n\treturn sk;\n}\n\nstatic int rose_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose;\n\n\tif (sk == NULL) return 0;\n\n\tsock_hold(sk);\n\tsock_orphan(sk);\n\tlock_sock(sk);\n\trose = rose_sk(sk);\n\n\tswitch (rose->state) {\n\tcase ROSE_STATE_0:\n\t\trelease_sock(sk);\n\t\trose_disconnect(sk, 0, -1, -1);\n\t\tlock_sock(sk);\n\t\trose_destroy_socket(sk);\n\t\tbreak;\n\n\tcase ROSE_STATE_2:\n\t\trose->neighbour->use--;\n\t\trelease_sock(sk);\n\t\trose_disconnect(sk, 0, -1, -1);\n\t\tlock_sock(sk);\n\t\trose_destroy_socket(sk);\n\t\tbreak;\n\n\tcase ROSE_STATE_1:\n\tcase ROSE_STATE_3:\n\tcase ROSE_STATE_4:\n\tcase ROSE_STATE_5:\n\t\trose_clear_queues(sk);\n\t\trose_stop_idletimer(sk);\n\t\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\t\trose_start_t3timer(sk);\n\t\trose->state  = ROSE_STATE_2;\n\t\tsk->sk_state    = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_lock_bh(&rose_list_lock);\n\tnetdev_put(rose->device, &rose->dev_tracker);\n\trose->device = NULL;\n\tspin_unlock_bh(&rose_list_lock);\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int rose_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;\n\tstruct net_device *dev;\n\tax25_address *source;\n\tax25_uid_assoc *user;\n\tint n;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\n\tif (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))\n\t\treturn -EINVAL;\n\n\tif (addr->srose_family != AF_ROSE)\n\t\treturn -EINVAL;\n\n\tif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\n\t\treturn -EINVAL;\n\n\tif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tif ((dev = rose_dev_get(&addr->srose_addr)) == NULL)\n\t\treturn -EADDRNOTAVAIL;\n\n\tsource = &addr->srose_call;\n\n\tuser = ax25_findbyuid(current_euid());\n\tif (user) {\n\t\trose->source_call = user->call;\n\t\tax25_uid_put(user);\n\t} else {\n\t\tif (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE)) {\n\t\t\tdev_put(dev);\n\t\t\treturn -EACCES;\n\t\t}\n\t\trose->source_call   = *source;\n\t}\n\n\trose->source_addr   = addr->srose_addr;\n\trose->device        = dev;\n\tnetdev_tracker_alloc(rose->device, &rose->dev_tracker, GFP_KERNEL);\n\trose->source_ndigis = addr->srose_ndigis;\n\n\tif (addr_len == sizeof(struct full_sockaddr_rose)) {\n\t\tstruct full_sockaddr_rose *full_addr = (struct full_sockaddr_rose *)uaddr;\n\t\tfor (n = 0 ; n < addr->srose_ndigis ; n++)\n\t\t\trose->source_digis[n] = full_addr->srose_digis[n];\n\t} else {\n\t\tif (rose->source_ndigis == 1) {\n\t\t\trose->source_digis[0] = addr->srose_digi;\n\t\t}\n\t}\n\n\trose_insert_socket(sk);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\treturn 0;\n}\n\nstatic int rose_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;\n\tunsigned char cause, diagnostic;\n\tax25_uid_assoc *user;\n\tint n, err = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))\n\t\treturn -EINVAL;\n\n\tif (addr->srose_family != AF_ROSE)\n\t\treturn -EINVAL;\n\n\tif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\n\t\treturn -EINVAL;\n\n\tif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\t \n\tif ((rose->source_ndigis + addr->srose_ndigis) > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\t \n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = -ECONNREFUSED;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\t \n\t\terr = -EISCONN;\n\t\tgoto out_release;\n\t}\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trose->neighbour = rose_get_neigh(&addr->srose_addr, &cause,\n\t\t\t\t\t &diagnostic, 0);\n\tif (!rose->neighbour) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out_release;\n\t}\n\n\trose->lci = rose_new_lci(rose->neighbour);\n\tif (!rose->lci) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out_release;\n\t}\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\t \n\t\tstruct net_device *dev;\n\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\t\tdev = rose_dev_first();\n\t\tif (!dev) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tuser = ax25_findbyuid(current_euid());\n\t\tif (!user) {\n\t\t\terr = -EINVAL;\n\t\t\tdev_put(dev);\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tmemcpy(&rose->source_addr, dev->dev_addr, ROSE_ADDR_LEN);\n\t\trose->source_call = user->call;\n\t\trose->device      = dev;\n\t\tnetdev_tracker_alloc(rose->device, &rose->dev_tracker,\n\t\t\t\t     GFP_KERNEL);\n\t\tax25_uid_put(user);\n\n\t\trose_insert_socket(sk);\t\t \n\t}\n\trose->dest_addr   = addr->srose_addr;\n\trose->dest_call   = addr->srose_call;\n\trose->rand        = ((long)rose & 0xFFFF) + rose->lci;\n\trose->dest_ndigis = addr->srose_ndigis;\n\n\tif (addr_len == sizeof(struct full_sockaddr_rose)) {\n\t\tstruct full_sockaddr_rose *full_addr = (struct full_sockaddr_rose *)uaddr;\n\t\tfor (n = 0 ; n < addr->srose_ndigis ; n++)\n\t\t\trose->dest_digis[n] = full_addr->srose_digis[n];\n\t} else {\n\t\tif (rose->dest_ndigis == 1) {\n\t\t\trose->dest_digis[0] = addr->srose_digi;\n\t\t}\n\t}\n\n\t \n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state     = TCP_SYN_SENT;\n\n\trose->state = ROSE_STATE_1;\n\n\trose->neighbour->use++;\n\n\trose_write_internal(sk, ROSE_CALL_REQUEST);\n\trose_start_heartbeat(sk);\n\trose_start_t1timer(sk);\n\n\t \n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\n\t\terr = -EINPROGRESS;\n\t\tgoto out_release;\n\t}\n\n\t \n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\t\tbreak;\n\t\t\tif (!signal_pending(current)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tschedule();\n\t\t\t\tlock_sock(sk);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = sock_error(sk);\t \n\t\tgoto out_release;\n\t}\n\n\tsock->state = SS_CONNECTED;\n\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int rose_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\t       bool kern)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *newsk;\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk;\n\tint err = 0;\n\n\tif ((sk = sock->sk) == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto out_release;\n\t}\n\n\t \n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tbreak;\n\n\t\tif (flags & O_NONBLOCK) {\n\t\t\terr = -EWOULDBLOCK;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\trelease_sock(sk);\n\t\t\tschedule();\n\t\t\tlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\tif (err)\n\t\tgoto out_release;\n\n\tnewsk = skb->sk;\n\tsock_graft(newsk, newsock);\n\n\t \n\tskb->sk = NULL;\n\tkfree_skb(skb);\n\tsk_acceptq_removed(sk);\n\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\n\tmemset(srose, 0, sizeof(*srose));\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\n\treturn sizeof(struct full_sockaddr_rose);\n}\n\nint rose_rx_call_request(struct sk_buff *skb, struct net_device *dev, struct rose_neigh *neigh, unsigned int lci)\n{\n\tstruct sock *sk;\n\tstruct sock *make;\n\tstruct rose_sock *make_rose;\n\tstruct rose_facilities_struct facilities;\n\tint n;\n\n\tskb->sk = NULL;\t\t \n\n\t \n\tmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\n\n\tif (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,\n\t\t\t\t   skb->len - ROSE_CALL_REQ_FACILITIES_OFF,\n\t\t\t\t   &facilities)) {\n\t\trose_transmit_clear_request(neigh, lci, ROSE_INVALID_FACILITY, 76);\n\t\treturn 0;\n\t}\n\n\tsk = rose_find_listener(&facilities.source_addr, &facilities.source_call);\n\n\t \n\tif (sk == NULL || sk_acceptq_is_full(sk) ||\n\t    (make = rose_make_new(sk)) == NULL) {\n\t\trose_transmit_clear_request(neigh, lci, ROSE_NETWORK_CONGESTION, 120);\n\t\treturn 0;\n\t}\n\n\tskb->sk     = make;\n\tmake->sk_state = TCP_ESTABLISHED;\n\tmake_rose = rose_sk(make);\n\n\tmake_rose->lci           = lci;\n\tmake_rose->dest_addr     = facilities.dest_addr;\n\tmake_rose->dest_call     = facilities.dest_call;\n\tmake_rose->dest_ndigis   = facilities.dest_ndigis;\n\tfor (n = 0 ; n < facilities.dest_ndigis ; n++)\n\t\tmake_rose->dest_digis[n] = facilities.dest_digis[n];\n\tmake_rose->source_addr   = facilities.source_addr;\n\tmake_rose->source_call   = facilities.source_call;\n\tmake_rose->source_ndigis = facilities.source_ndigis;\n\tfor (n = 0 ; n < facilities.source_ndigis ; n++)\n\t\tmake_rose->source_digis[n] = facilities.source_digis[n];\n\tmake_rose->neighbour     = neigh;\n\tmake_rose->device        = dev;\n\t \n\tnetdev_tracker_alloc(make_rose->device, &make_rose->dev_tracker,\n\t\t\t     GFP_ATOMIC);\n\tmake_rose->facilities    = facilities;\n\n\tmake_rose->neighbour->use++;\n\n\tif (rose_sk(sk)->defer) {\n\t\tmake_rose->state = ROSE_STATE_5;\n\t} else {\n\t\trose_write_internal(make, ROSE_CALL_ACCEPTED);\n\t\tmake_rose->state = ROSE_STATE_3;\n\t\trose_start_idletimer(make);\n\t}\n\n\tmake_rose->condition = 0x00;\n\tmake_rose->vs        = 0;\n\tmake_rose->va        = 0;\n\tmake_rose->vr        = 0;\n\tmake_rose->vl        = 0;\n\tsk_acceptq_added(sk);\n\n\trose_insert_socket(make);\n\n\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\trose_start_heartbeat(make);\n\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk);\n\n\treturn 1;\n}\n\nstatic int rose_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_rose *, usrose, msg->msg_name);\n\tint err;\n\tstruct full_sockaddr_rose srose;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint n, size, qbit = 0;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\treturn -EPIPE;\n\t}\n\n\tif (rose->neighbour == NULL || rose->device == NULL)\n\t\treturn -ENETUNREACH;\n\n\tif (usrose != NULL) {\n\t\tif (msg->msg_namelen != sizeof(struct sockaddr_rose) && msg->msg_namelen != sizeof(struct full_sockaddr_rose))\n\t\t\treturn -EINVAL;\n\t\tmemset(&srose, 0, sizeof(struct full_sockaddr_rose));\n\t\tmemcpy(&srose, usrose, msg->msg_namelen);\n\t\tif (rosecmp(&rose->dest_addr, &srose.srose_addr) != 0 ||\n\t\t    ax25cmp(&rose->dest_call, &srose.srose_call) != 0)\n\t\t\treturn -EISCONN;\n\t\tif (srose.srose_ndigis != rose->dest_ndigis)\n\t\t\treturn -EISCONN;\n\t\tif (srose.srose_ndigis == rose->dest_ndigis) {\n\t\t\tfor (n = 0 ; n < srose.srose_ndigis ; n++)\n\t\t\t\tif (ax25cmp(&rose->dest_digis[n],\n\t\t\t\t\t    &srose.srose_digis[n]))\n\t\t\t\t\treturn -EISCONN;\n\t\t}\n\t\tif (srose.srose_family != AF_ROSE)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsrose.srose_family = AF_ROSE;\n\t\tsrose.srose_addr   = rose->dest_addr;\n\t\tsrose.srose_call   = rose->dest_call;\n\t\tsrose.srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\tsrose.srose_digis[n] = rose->dest_digis[n];\n\t}\n\n\t \n\t \n\tif (len > 65535)\n\t\treturn -EMSGSIZE;\n\n\tsize = len + AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN;\n\n\tif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)\n\t\treturn err;\n\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN);\n\n\t \n\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, len);\n\n\terr = memcpy_from_msg(skb_transport_header(skb), msg, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\t \n\tif (rose->qbitincl) {\n\t\tqbit = skb->data[0];\n\t\tskb_pull(skb, 1);\n\t}\n\n\t \n\tasmptr = skb_push(skb, ROSE_MIN_LEN);\n\n\t \n\tasmptr[0] = ((rose->lci >> 8) & 0x0F) | ROSE_GFI;\n\tasmptr[1] = (rose->lci >> 0) & 0xFF;\n\tasmptr[2] = ROSE_DATA;\n\n\tif (qbit)\n\t\tasmptr[0] |= ROSE_Q_BIT;\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOTCONN;\n\t}\n\n#ifdef M_BIT\n#define ROSE_PACLEN (256-ROSE_MIN_LEN)\n\tif (skb->len - ROSE_MIN_LEN > ROSE_PACLEN) {\n\t\tunsigned char header[ROSE_MIN_LEN];\n\t\tstruct sk_buff *skbn;\n\t\tint frontlen;\n\t\tint lg;\n\n\t\t \n\t\tskb_copy_from_linear_data(skb, header, ROSE_MIN_LEN);\n\t\tskb_pull(skb, ROSE_MIN_LEN);\n\n\t\tfrontlen = skb_headroom(skb);\n\n\t\twhile (skb->len > 0) {\n\t\t\tif ((skbn = sock_alloc_send_skb(sk, frontlen + ROSE_PACLEN, 0, &err)) == NULL) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tskbn->sk   = sk;\n\t\t\tskbn->free = 1;\n\t\t\tskbn->arp  = 1;\n\n\t\t\tskb_reserve(skbn, frontlen);\n\n\t\t\tlg = (ROSE_PACLEN > skb->len) ? skb->len : ROSE_PACLEN;\n\n\t\t\t \n\t\t\tskb_copy_from_linear_data(skb, skb_put(skbn, lg), lg);\n\t\t\tskb_pull(skb, lg);\n\n\t\t\t \n\t\t\tskb_push(skbn, ROSE_MIN_LEN);\n\t\t\tskb_copy_to_linear_data(skbn, header, ROSE_MIN_LEN);\n\n\t\t\tif (skb->len > 0)\n\t\t\t\tskbn->data[2] |= M_BIT;\n\n\t\t\tskb_queue_tail(&sk->sk_write_queue, skbn);  \n\t\t}\n\n\t\tskb->free = 1;\n\t\tkfree_skb(skb);\n\t} else {\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\t\t \n\t}\n#else\n\tskb_queue_tail(&sk->sk_write_queue, skb);\t \n#endif\n\n\trose_kick(sk);\n\n\treturn len;\n}\n\n\nstatic int rose_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t\tint flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tsize_t copied;\n\tunsigned char *asmptr;\n\tstruct sk_buff *skb;\n\tint n, er, qbit;\n\n\t \n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\n\t \n\tskb = skb_recv_datagram(sk, flags, &er);\n\tif (!skb)\n\t\treturn er;\n\n\tqbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\n\tskb_pull(skb, ROSE_MIN_LEN);\n\n\tif (rose->qbitincl) {\n\t\tasmptr  = skb_push(skb, 1);\n\t\t*asmptr = qbit;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tskb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_rose *srose;\n\t\tDECLARE_SOCKADDR(struct full_sockaddr_rose *, full_srose,\n\t\t\t\t msg->msg_name);\n\n\t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));\n\t\tsrose = msg->msg_name;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\tfull_srose->srose_digis[n] = rose->dest_digis[n];\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_rose);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn copied;\n}\n\n\nstatic int rose_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount;\n\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\treturn put_user(amount, (unsigned int __user *) argp);\n\t}\n\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0L;\n\n\t\tspin_lock_irq(&sk->sk_receive_queue.lock);\n\t\tif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\n\t\t\tamount = skb->len;\n\t\tspin_unlock_irq(&sk->sk_receive_queue.lock);\n\t\treturn put_user(amount, (unsigned int __user *) argp);\n\t}\n\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\t\treturn -EINVAL;\n\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\tcase SIOCRSCLRRT:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn rose_rt_ioctl(cmd, argp);\n\n\tcase SIOCRSGCAUSE: {\n\t\tstruct rose_cause_struct rose_cause;\n\t\trose_cause.cause      = rose->cause;\n\t\trose_cause.diagnostic = rose->diagnostic;\n\t\treturn copy_to_user(argp, &rose_cause, sizeof(struct rose_cause_struct)) ? -EFAULT : 0;\n\t}\n\n\tcase SIOCRSSCAUSE: {\n\t\tstruct rose_cause_struct rose_cause;\n\t\tif (copy_from_user(&rose_cause, argp, sizeof(struct rose_cause_struct)))\n\t\t\treturn -EFAULT;\n\t\trose->cause      = rose_cause.cause;\n\t\trose->diagnostic = rose_cause.diagnostic;\n\t\treturn 0;\n\t}\n\n\tcase SIOCRSSL2CALL:\n\t\tif (!capable(CAP_NET_ADMIN)) return -EPERM;\n\t\tif (ax25cmp(&rose_callsign, &null_ax25_address) != 0)\n\t\t\tax25_listen_release(&rose_callsign, NULL);\n\t\tif (copy_from_user(&rose_callsign, argp, sizeof(ax25_address)))\n\t\t\treturn -EFAULT;\n\t\tif (ax25cmp(&rose_callsign, &null_ax25_address) != 0)\n\t\t\treturn ax25_listen_register(&rose_callsign, NULL);\n\n\t\treturn 0;\n\n\tcase SIOCRSGL2CALL:\n\t\treturn copy_to_user(argp, &rose_callsign, sizeof(ax25_address)) ? -EFAULT : 0;\n\n\tcase SIOCRSACCEPT:\n\t\tif (rose->state == ROSE_STATE_5) {\n\t\t\trose_write_internal(sk, ROSE_CALL_ACCEPTED);\n\t\t\trose_start_idletimer(sk);\n\t\t\trose->condition = 0x00;\n\t\t\trose->vs        = 0;\n\t\t\trose->va        = 0;\n\t\t\trose->vr        = 0;\n\t\t\trose->vl        = 0;\n\t\t\trose->state     = ROSE_STATE_3;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void *rose_info_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rose_list_lock)\n{\n\tspin_lock_bh(&rose_list_lock);\n\treturn seq_hlist_start_head(&rose_list, *pos);\n}\n\nstatic void *rose_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &rose_list, pos);\n}\n\nstatic void rose_info_stop(struct seq_file *seq, void *v)\n\t__releases(rose_list_lock)\n{\n\tspin_unlock_bh(&rose_list_lock);\n}\n\nstatic int rose_info_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11], rsbuf[11];\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"dest_addr  dest_call src_addr   src_call  dev   lci neigh st vs vr va   t  t1  t2  t3  hb    idle Snd-Q Rcv-Q inode\\n\");\n\n\telse {\n\t\tstruct sock *s = sk_entry(v);\n\t\tstruct rose_sock *rose = rose_sk(s);\n\t\tconst char *devname, *callsign;\n\t\tconst struct net_device *dev = rose->device;\n\n\t\tif (!dev)\n\t\t\tdevname = \"???\";\n\t\telse\n\t\t\tdevname = dev->name;\n\n\t\tseq_printf(seq, \"%-10s %-9s \",\n\t\t\t   rose2asc(rsbuf, &rose->dest_addr),\n\t\t\t   ax2asc(buf, &rose->dest_call));\n\n\t\tif (ax25cmp(&rose->source_call, &null_ax25_address) == 0)\n\t\t\tcallsign = \"??????-?\";\n\t\telse\n\t\t\tcallsign = ax2asc(buf, &rose->source_call);\n\n\t\tseq_printf(seq,\n\t\t\t   \"%-10s %-9s %-5s %3.3X %05d  %d  %d  %d  %d %3lu %3lu %3lu %3lu %3lu %3lu/%03lu %5d %5d %ld\\n\",\n\t\t\trose2asc(rsbuf, &rose->source_addr),\n\t\t\tcallsign,\n\t\t\tdevname,\n\t\t\trose->lci & 0x0FFF,\n\t\t\t(rose->neighbour) ? rose->neighbour->number : 0,\n\t\t\trose->state,\n\t\t\trose->vs,\n\t\t\trose->vr,\n\t\t\trose->va,\n\t\t\tax25_display_timer(&rose->timer) / HZ,\n\t\t\trose->t1 / HZ,\n\t\t\trose->t2 / HZ,\n\t\t\trose->t3 / HZ,\n\t\t\trose->hb / HZ,\n\t\t\tax25_display_timer(&rose->idletimer) / (60 * HZ),\n\t\t\trose->idle / (60 * HZ),\n\t\t\tsk_wmem_alloc_get(s),\n\t\t\tsk_rmem_alloc_get(s),\n\t\t\ts->sk_socket ? SOCK_INODE(s->sk_socket)->i_ino : 0L);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct seq_operations rose_info_seqops = {\n\t.start = rose_info_start,\n\t.next = rose_info_next,\n\t.stop = rose_info_stop,\n\t.show = rose_info_show,\n};\n#endif\t \n\nstatic const struct net_proto_family rose_family_ops = {\n\t.family\t\t=\tPF_ROSE,\n\t.create\t\t=\trose_create,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic const struct proto_ops rose_proto_ops = {\n\t.family\t\t=\tPF_ROSE,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.release\t=\trose_release,\n\t.bind\t\t=\trose_bind,\n\t.connect\t=\trose_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.accept\t\t=\trose_accept,\n\t.getname\t=\trose_getname,\n\t.poll\t\t=\tdatagram_poll,\n\t.ioctl\t\t=\trose_ioctl,\n\t.gettstamp\t=\tsock_gettstamp,\n\t.listen\t\t=\trose_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.setsockopt\t=\trose_setsockopt,\n\t.getsockopt\t=\trose_getsockopt,\n\t.sendmsg\t=\trose_sendmsg,\n\t.recvmsg\t=\trose_recvmsg,\n\t.mmap\t\t=\tsock_no_mmap,\n};\n\nstatic struct notifier_block rose_dev_notifier = {\n\t.notifier_call\t=\trose_device_event,\n};\n\nstatic struct net_device **dev_rose;\n\nstatic struct ax25_protocol rose_pid = {\n\t.pid\t= AX25_P_ROSE,\n\t.func\t= rose_route_frame\n};\n\nstatic struct ax25_linkfail rose_linkfail_notifier = {\n\t.func\t= rose_link_failed\n};\n\nstatic int __init rose_proto_init(void)\n{\n\tint i;\n\tint rc;\n\n\tif (rose_ndevs > 0x7FFFFFFF/sizeof(struct net_device *)) {\n\t\tprintk(KERN_ERR \"ROSE: rose_proto_init - rose_ndevs parameter too large\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = proto_register(&rose_proto, 0);\n\tif (rc != 0)\n\t\tgoto out;\n\n\trose_callsign = null_ax25_address;\n\n\tdev_rose = kcalloc(rose_ndevs, sizeof(struct net_device *),\n\t\t\t   GFP_KERNEL);\n\tif (dev_rose == NULL) {\n\t\tprintk(KERN_ERR \"ROSE: rose_proto_init - unable to allocate device structure\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_proto_unregister;\n\t}\n\n\tfor (i = 0; i < rose_ndevs; i++) {\n\t\tstruct net_device *dev;\n\t\tchar name[IFNAMSIZ];\n\n\t\tsprintf(name, \"rose%d\", i);\n\t\tdev = alloc_netdev(0, name, NET_NAME_UNKNOWN, rose_setup);\n\t\tif (!dev) {\n\t\t\tprintk(KERN_ERR \"ROSE: rose_proto_init - unable to allocate memory\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\trc = register_netdev(dev);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"ROSE: netdevice registration failed\\n\");\n\t\t\tfree_netdev(dev);\n\t\t\tgoto fail;\n\t\t}\n\t\trose_set_lockdep_key(dev);\n\t\tdev_rose[i] = dev;\n\t}\n\n\tsock_register(&rose_family_ops);\n\tregister_netdevice_notifier(&rose_dev_notifier);\n\n\tax25_register_pid(&rose_pid);\n\tax25_linkfail_register(&rose_linkfail_notifier);\n\n#ifdef CONFIG_SYSCTL\n\trose_register_sysctl();\n#endif\n\trose_loopback_init();\n\n\trose_add_loopback_neigh();\n\n\tproc_create_seq(\"rose\", 0444, init_net.proc_net, &rose_info_seqops);\n\tproc_create_seq(\"rose_neigh\", 0444, init_net.proc_net,\n\t\t    &rose_neigh_seqops);\n\tproc_create_seq(\"rose_nodes\", 0444, init_net.proc_net,\n\t\t    &rose_node_seqops);\n\tproc_create_seq(\"rose_routes\", 0444, init_net.proc_net,\n\t\t    &rose_route_seqops);\nout:\n\treturn rc;\nfail:\n\twhile (--i >= 0) {\n\t\tunregister_netdev(dev_rose[i]);\n\t\tfree_netdev(dev_rose[i]);\n\t}\n\tkfree(dev_rose);\nout_proto_unregister:\n\tproto_unregister(&rose_proto);\n\tgoto out;\n}\nmodule_init(rose_proto_init);\n\nmodule_param(rose_ndevs, int, 0);\nMODULE_PARM_DESC(rose_ndevs, \"number of ROSE devices\");\n\nMODULE_AUTHOR(\"Jonathan Naylor G4KLX <g4klx@g4klx.demon.co.uk>\");\nMODULE_DESCRIPTION(\"The amateur radio ROSE network layer protocol\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_ROSE);\n\nstatic void __exit rose_exit(void)\n{\n\tint i;\n\n\tremove_proc_entry(\"rose\", init_net.proc_net);\n\tremove_proc_entry(\"rose_neigh\", init_net.proc_net);\n\tremove_proc_entry(\"rose_nodes\", init_net.proc_net);\n\tremove_proc_entry(\"rose_routes\", init_net.proc_net);\n\trose_loopback_clear();\n\n\trose_rt_free();\n\n\tax25_protocol_release(AX25_P_ROSE);\n\tax25_linkfail_release(&rose_linkfail_notifier);\n\n\tif (ax25cmp(&rose_callsign, &null_ax25_address) != 0)\n\t\tax25_listen_release(&rose_callsign, NULL);\n\n#ifdef CONFIG_SYSCTL\n\trose_unregister_sysctl();\n#endif\n\tunregister_netdevice_notifier(&rose_dev_notifier);\n\n\tsock_unregister(PF_ROSE);\n\n\tfor (i = 0; i < rose_ndevs; i++) {\n\t\tstruct net_device *dev = dev_rose[i];\n\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tfree_netdev(dev);\n\t\t}\n\t}\n\n\tkfree(dev_rose);\n\tproto_unregister(&rose_proto);\n}\n\nmodule_exit(rose_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}