{
  "module_name": "rose_subr.c",
  "hash_id": "959371757364629623c2f58d399b5bf98ddb2d7eafbd8e9b9c7430c3f7ab04ab",
  "original_prompt": "Ingested from linux-6.6.14/net/rose/rose_subr.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/rose.h>\n\nstatic int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose);\n\n \nvoid rose_clear_queues(struct sock *sk)\n{\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&rose_sk(sk)->ack_queue);\n}\n\n \nvoid rose_frames_acked(struct sock *sk, unsigned short nr)\n{\n\tstruct sk_buff *skb;\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\t \n\tif (rose->va != nr) {\n\t\twhile (skb_peek(&rose->ack_queue) != NULL && rose->va != nr) {\n\t\t\tskb = skb_dequeue(&rose->ack_queue);\n\t\t\tkfree_skb(skb);\n\t\t\trose->va = (rose->va + 1) % ROSE_MODULUS;\n\t\t}\n\t}\n}\n\nvoid rose_requeue_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\n\t \n\twhile ((skb = skb_dequeue(&rose_sk(sk)->ack_queue)) != NULL) {\n\t\tif (skb_prev == NULL)\n\t\t\tskb_queue_head(&sk->sk_write_queue, skb);\n\t\telse\n\t\t\tskb_append(skb_prev, skb, &sk->sk_write_queue);\n\t\tskb_prev = skb;\n\t}\n}\n\n \nint rose_validate_nr(struct sock *sk, unsigned short nr)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tunsigned short vc = rose->va;\n\n\twhile (vc != rose->vs) {\n\t\tif (nr == vc) return 1;\n\t\tvc = (vc + 1) % ROSE_MODULUS;\n\t}\n\n\treturn nr == rose->vs;\n}\n\n \nvoid rose_write_internal(struct sock *sk, int frametype)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned char  *dptr;\n\tunsigned char  lci1, lci2;\n\tint maxfaclen = 0;\n\tint len, faclen;\n\tint reserve;\n\n\treserve = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1;\n\tlen = ROSE_MIN_LEN;\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_REQUEST:\n\t\tlen   += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN;\n\t\tmaxfaclen = 256;\n\t\tbreak;\n\tcase ROSE_CALL_ACCEPTED:\n\tcase ROSE_CLEAR_REQUEST:\n\tcase ROSE_RESET_REQUEST:\n\t\tlen   += 2;\n\t\tbreak;\n\t}\n\n\tskb = alloc_skb(reserve + len + maxfaclen, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\t \n\tskb_reserve(skb, reserve);\n\n\tdptr = skb_put(skb, len);\n\n\tlci1 = (rose->lci >> 8) & 0x0F;\n\tlci2 = (rose->lci >> 0) & 0xFF;\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = ROSE_CALL_REQ_ADDR_LEN_VAL;\n\t\tmemcpy(dptr, &rose->dest_addr,  ROSE_ADDR_LEN);\n\t\tdptr   += ROSE_ADDR_LEN;\n\t\tmemcpy(dptr, &rose->source_addr, ROSE_ADDR_LEN);\n\t\tdptr   += ROSE_ADDR_LEN;\n\t\tfaclen = rose_create_facilities(dptr, rose);\n\t\tskb_put(skb, faclen);\n\t\tdptr   += faclen;\n\t\tbreak;\n\n\tcase ROSE_CALL_ACCEPTED:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = 0x00;\t\t \n\t\t*dptr++ = 0;\t\t \n\t\tbreak;\n\n\tcase ROSE_CLEAR_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = rose->cause;\n\t\t*dptr++ = rose->diagnostic;\n\t\tbreak;\n\n\tcase ROSE_RESET_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = ROSE_DTE_ORIGINATED;\n\t\t*dptr++ = 0;\n\t\tbreak;\n\n\tcase ROSE_RR:\n\tcase ROSE_RNR:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr   = frametype;\n\t\t*dptr++ |= (rose->vr << 5) & 0xE0;\n\t\tbreak;\n\n\tcase ROSE_CLEAR_CONFIRMATION:\n\tcase ROSE_RESET_CONFIRMATION:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++  = frametype;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"ROSE: rose_write_internal - invalid frametype %02X\\n\", frametype);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\trose_transmit_link(skb, rose->neighbour);\n}\n\nint rose_decode(struct sk_buff *skb, int *ns, int *nr, int *q, int *d, int *m)\n{\n\tunsigned char *frame;\n\n\tframe = skb->data;\n\n\t*ns = *nr = *q = *d = *m = 0;\n\n\tswitch (frame[2]) {\n\tcase ROSE_CALL_REQUEST:\n\tcase ROSE_CALL_ACCEPTED:\n\tcase ROSE_CLEAR_REQUEST:\n\tcase ROSE_CLEAR_CONFIRMATION:\n\tcase ROSE_RESET_REQUEST:\n\tcase ROSE_RESET_CONFIRMATION:\n\t\treturn frame[2];\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((frame[2] & 0x1F) == ROSE_RR  ||\n\t    (frame[2] & 0x1F) == ROSE_RNR) {\n\t\t*nr = (frame[2] >> 5) & 0x07;\n\t\treturn frame[2] & 0x1F;\n\t}\n\n\tif ((frame[2] & 0x01) == ROSE_DATA) {\n\t\t*q  = (frame[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\t\t*d  = (frame[0] & ROSE_D_BIT) == ROSE_D_BIT;\n\t\t*m  = (frame[2] & ROSE_M_BIT) == ROSE_M_BIT;\n\t\t*nr = (frame[2] >> 5) & 0x07;\n\t\t*ns = (frame[2] >> 1) & 0x07;\n\t\treturn ROSE_DATA;\n\t}\n\n\treturn ROSE_ILLEGAL;\n}\n\nstatic int rose_parse_national(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char *pt;\n\tunsigned char l, lg, n = 0;\n\tint fac_national_digis_received = 0;\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tif (len < 3)\n\t\t\t\treturn -1;\n\t\t\tif (*p == FAC_NATIONAL_RAND)\n\t\t\t\tfacilities->rand = ((p[1] << 8) & 0xFF00) + ((p[2] << 0) & 0x00FF);\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tif (len < 4)\n\t\t\t\treturn -1;\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tl = p[1];\n\t\t\tif (len < 2 + l)\n\t\t\t\treturn -1;\n\t\t\tif (*p == FAC_NATIONAL_DEST_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tif (l < AX25_ADDR_LEN)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tmemcpy(&facilities->source_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->source_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_SRC_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tif (l < AX25_ADDR_LEN)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tmemcpy(&facilities->dest_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->dest_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_CALL) {\n\t\t\t\tif (l < AX25_ADDR_LEN)\n\t\t\t\t\treturn -1;\n\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tif (l < 1 + ROSE_ADDR_LEN)\n\t\t\t\t\treturn -1;\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tif (l % AX25_ADDR_LEN)\n\t\t\t\t\treturn -1;\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT) {\n\t\t\t\t\t\tif (facilities->dest_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (facilities->source_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n\nstatic int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tif (len < 3)\n\t\t\t\treturn -1;\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tif (len < 4)\n\t\t\t\treturn -1;\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tl = p[1];\n\n\t\t\t \n\t\t\tif (l < 10 || l > 20)\n\t\t\t\treturn -1;\n\n\t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n\t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n\nint rose_parse_facilities(unsigned char *p, unsigned packet_len,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\n\tfacilities_len = *p++;\n\n\tif (facilities_len == 0 || (unsigned int)facilities_len > packet_len)\n\t\treturn 0;\n\n\twhile (facilities_len >= 3 && *p == 0x00) {\n\t\tfacilities_len--;\n\t\tp++;\n\n\t\tswitch (*p) {\n\t\tcase FAC_NATIONAL:\t\t \n\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\n\t\tcase FAC_CCITT:\t\t \n\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\tlen = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (len < 0)\n\t\t\treturn 0;\n\t\tif (WARN_ON(len >= facilities_len))\n\t\t\treturn 0;\n\t\tfacilities_len -= len + 1;\n\t\tp += len + 1;\n\t}\n\n\treturn facilities_len == 0;\n}\n\nstatic int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose)\n{\n\tunsigned char *p = buffer + 1;\n\tchar *callsign;\n\tchar buf[11];\n\tint len, nb;\n\n\t \n\tif (rose->rand != 0 || rose->source_ndigis == 1 || rose->dest_ndigis == 1) {\n\t\t*p++ = 0x00;\n\t\t*p++ = FAC_NATIONAL;\n\n\t\tif (rose->rand != 0) {\n\t\t\t*p++ = FAC_NATIONAL_RAND;\n\t\t\t*p++ = (rose->rand >> 8) & 0xFF;\n\t\t\t*p++ = (rose->rand >> 0) & 0xFF;\n\t\t}\n\n\t\t \n\t\tif ((rose->source_ndigis > 0) || (rose->dest_ndigis > 0)) {\n\t\t\tint maxdigi = 0;\n\t\t\t*p++ = FAC_NATIONAL_DIGIS;\n\t\t\t*p++ = AX25_ADDR_LEN * (rose->source_ndigis + rose->dest_ndigis);\n\t\t\tfor (nb = 0 ; nb < rose->source_ndigis ; nb++) {\n\t\t\t\tif (++maxdigi >= ROSE_MAX_DIGIS)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(p, &rose->source_digis[nb], AX25_ADDR_LEN);\n\t\t\t\tp[6] |= AX25_HBIT;\n\t\t\t\tp += AX25_ADDR_LEN;\n\t\t\t}\n\t\t\tfor (nb = 0 ; nb < rose->dest_ndigis ; nb++) {\n\t\t\t\tif (++maxdigi >= ROSE_MAX_DIGIS)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(p, &rose->dest_digis[nb], AX25_ADDR_LEN);\n\t\t\t\tp[6] &= ~AX25_HBIT;\n\t\t\t\tp += AX25_ADDR_LEN;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (rose->source_ndigis > 0) {\n\t\t\t*p++ = FAC_NATIONAL_SRC_DIGI;\n\t\t\t*p++ = AX25_ADDR_LEN;\n\t\t\tmemcpy(p, &rose->source_digis[0], AX25_ADDR_LEN);\n\t\t\tp   += AX25_ADDR_LEN;\n\t\t}\n\n\t\t \n\t\tif (rose->dest_ndigis > 0) {\n\t\t\t*p++ = FAC_NATIONAL_DEST_DIGI;\n\t\t\t*p++ = AX25_ADDR_LEN;\n\t\t\tmemcpy(p, &rose->dest_digis[0], AX25_ADDR_LEN);\n\t\t\tp   += AX25_ADDR_LEN;\n\t\t}\n\t}\n\n\t*p++ = 0x00;\n\t*p++ = FAC_CCITT;\n\n\t*p++ = FAC_CCITT_DEST_NSAP;\n\n\tcallsign = ax2asc(buf, &rose->dest_call);\n\n\t*p++ = strlen(callsign) + 10;\n\t*p++ = (strlen(callsign) + 9) * 2;\t\t \n\n\t*p++ = 0x47; *p++ = 0x00; *p++ = 0x11;\n\t*p++ = ROSE_ADDR_LEN * 2;\n\tmemcpy(p, &rose->dest_addr, ROSE_ADDR_LEN);\n\tp   += ROSE_ADDR_LEN;\n\n\tmemcpy(p, callsign, strlen(callsign));\n\tp   += strlen(callsign);\n\n\t*p++ = FAC_CCITT_SRC_NSAP;\n\n\tcallsign = ax2asc(buf, &rose->source_call);\n\n\t*p++ = strlen(callsign) + 10;\n\t*p++ = (strlen(callsign) + 9) * 2;\t\t \n\n\t*p++ = 0x47; *p++ = 0x00; *p++ = 0x11;\n\t*p++ = ROSE_ADDR_LEN * 2;\n\tmemcpy(p, &rose->source_addr, ROSE_ADDR_LEN);\n\tp   += ROSE_ADDR_LEN;\n\n\tmemcpy(p, callsign, strlen(callsign));\n\tp   += strlen(callsign);\n\n\tlen       = p - buffer;\n\tbuffer[0] = len - 1;\n\n\treturn len;\n}\n\nvoid rose_disconnect(struct sock *sk, int reason, int cause, int diagnostic)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\trose_stop_timer(sk);\n\trose_stop_idletimer(sk);\n\n\trose_clear_queues(sk);\n\n\trose->lci   = 0;\n\trose->state = ROSE_STATE_0;\n\n\tif (cause != -1)\n\t\trose->cause = cause;\n\n\tif (diagnostic != -1)\n\t\trose->diagnostic = diagnostic;\n\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = reason;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}