{
  "module_name": "mpls_iptunnel.c",
  "hash_id": "ff1ca3a33687f030bc8167a08ea6971b4acde0b04e348f9d65e15b3652ade79e",
  "original_prompt": "Ingested from linux-6.6.14/net/mpls/mpls_iptunnel.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/net.h>\n#include <linux/module.h>\n#include <linux/mpls.h>\n#include <linux/vmalloc.h>\n#include <net/ip.h>\n#include <net/dst.h>\n#include <net/lwtunnel.h>\n#include <net/netevent.h>\n#include <net/netns/generic.h>\n#include <net/ip6_fib.h>\n#include <net/route.h>\n#include <net/mpls_iptunnel.h>\n#include <linux/mpls_iptunnel.h>\n#include \"internal.h\"\n\nstatic const struct nla_policy mpls_iptunnel_policy[MPLS_IPTUNNEL_MAX + 1] = {\n\t[MPLS_IPTUNNEL_DST]\t= { .len = sizeof(u32) },\n\t[MPLS_IPTUNNEL_TTL]\t= { .type = NLA_U8 },\n};\n\nstatic unsigned int mpls_encap_size(struct mpls_iptunnel_encap *en)\n{\n\t \n\treturn en->labels * sizeof(struct mpls_shim_hdr);\n}\n\nstatic int mpls_xmit(struct sk_buff *skb)\n{\n\tstruct mpls_iptunnel_encap *tun_encap_info;\n\tstruct mpls_shim_hdr *hdr;\n\tstruct net_device *out_dev;\n\tunsigned int hh_len;\n\tunsigned int new_header_size;\n\tunsigned int mtu;\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct rtable *rt = NULL;\n\tstruct rt6_info *rt6 = NULL;\n\tstruct mpls_dev *out_mdev;\n\tstruct net *net;\n\tint err = 0;\n\tbool bos;\n\tint i;\n\tunsigned int ttl;\n\n\t \n\tout_dev = dst->dev;\n\tnet = dev_net(out_dev);\n\n\tskb_orphan(skb);\n\n\tif (!mpls_output_possible(out_dev) ||\n\t    !dst->lwtstate || skb_warn_if_lro(skb))\n\t\tgoto drop;\n\n\tskb_forward_csum(skb);\n\n\ttun_encap_info = mpls_lwtunnel_encap(dst->lwtstate);\n\n\t \n\tif (dst->ops->family == AF_INET) {\n\t\tif (tun_encap_info->ttl_propagate == MPLS_TTL_PROP_DISABLED)\n\t\t\tttl = tun_encap_info->default_ttl;\n\t\telse if (tun_encap_info->ttl_propagate == MPLS_TTL_PROP_DEFAULT &&\n\t\t\t !net->mpls.ip_ttl_propagate)\n\t\t\tttl = net->mpls.default_ttl;\n\t\telse\n\t\t\tttl = ip_hdr(skb)->ttl;\n\t\trt = (struct rtable *)dst;\n\t} else if (dst->ops->family == AF_INET6) {\n\t\tif (tun_encap_info->ttl_propagate == MPLS_TTL_PROP_DISABLED)\n\t\t\tttl = tun_encap_info->default_ttl;\n\t\telse if (tun_encap_info->ttl_propagate == MPLS_TTL_PROP_DEFAULT &&\n\t\t\t !net->mpls.ip_ttl_propagate)\n\t\t\tttl = net->mpls.default_ttl;\n\t\telse\n\t\t\tttl = ipv6_hdr(skb)->hop_limit;\n\t\trt6 = (struct rt6_info *)dst;\n\t} else {\n\t\tgoto drop;\n\t}\n\n\t \n\tnew_header_size = mpls_encap_size(tun_encap_info);\n\tmtu = mpls_dev_mtu(out_dev);\n\tif (mpls_pkt_too_big(skb, mtu - new_header_size))\n\t\tgoto drop;\n\n\thh_len = LL_RESERVED_SPACE(out_dev);\n\tif (!out_dev->header_ops)\n\t\thh_len = 0;\n\n\t \n\tif (skb_cow(skb, hh_len + new_header_size))\n\t\tgoto drop;\n\n\tskb_set_inner_protocol(skb, skb->protocol);\n\tskb_reset_inner_network_header(skb);\n\n\tskb_push(skb, new_header_size);\n\n\tskb_reset_network_header(skb);\n\n\tskb->dev = out_dev;\n\tskb->protocol = htons(ETH_P_MPLS_UC);\n\n\t \n\thdr = mpls_hdr(skb);\n\tbos = true;\n\tfor (i = tun_encap_info->labels - 1; i >= 0; i--) {\n\t\thdr[i] = mpls_entry_encode(tun_encap_info->label[i],\n\t\t\t\t\t   ttl, 0, bos);\n\t\tbos = false;\n\t}\n\n\tmpls_stats_inc_outucastpkts(out_dev, skb);\n\n\tif (rt) {\n\t\tif (rt->rt_gw_family == AF_INET6)\n\t\t\terr = neigh_xmit(NEIGH_ND_TABLE, out_dev, &rt->rt_gw6,\n\t\t\t\t\t skb);\n\t\telse\n\t\t\terr = neigh_xmit(NEIGH_ARP_TABLE, out_dev, &rt->rt_gw4,\n\t\t\t\t\t skb);\n\t} else if (rt6) {\n\t\tif (ipv6_addr_v4mapped(&rt6->rt6i_gateway)) {\n\t\t\t \n\t\t\terr = neigh_xmit(NEIGH_ARP_TABLE, out_dev, &rt6->rt6i_gateway.s6_addr32[3],\n\t\t\t\t\t skb);\n\t\t} else\n\t\t\terr = neigh_xmit(NEIGH_ND_TABLE, out_dev, &rt6->rt6i_gateway,\n\t\t\t\t\t skb);\n\t}\n\tif (err)\n\t\tnet_dbg_ratelimited(\"%s: packet transmission failed: %d\\n\",\n\t\t\t\t    __func__, err);\n\n\treturn LWTUNNEL_XMIT_DONE;\n\ndrop:\n\tout_mdev = out_dev ? mpls_dev_get(out_dev) : NULL;\n\tif (out_mdev)\n\t\tMPLS_INC_STATS(out_mdev, tx_errors);\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int mpls_build_state(struct net *net, struct nlattr *nla,\n\t\t\t    unsigned int family, const void *cfg,\n\t\t\t    struct lwtunnel_state **ts,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mpls_iptunnel_encap *tun_encap_info;\n\tstruct nlattr *tb[MPLS_IPTUNNEL_MAX + 1];\n\tstruct lwtunnel_state *newts;\n\tu8 n_labels;\n\tint ret;\n\n\tret = nla_parse_nested_deprecated(tb, MPLS_IPTUNNEL_MAX, nla,\n\t\t\t\t\t  mpls_iptunnel_policy, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!tb[MPLS_IPTUNNEL_DST]) {\n\t\tNL_SET_ERR_MSG(extack, \"MPLS_IPTUNNEL_DST attribute is missing\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (nla_get_labels(tb[MPLS_IPTUNNEL_DST], MAX_NEW_LABELS,\n\t\t\t   &n_labels, NULL, extack))\n\t\treturn -EINVAL;\n\n\tnewts = lwtunnel_state_alloc(struct_size(tun_encap_info, label,\n\t\t\t\t\t\t n_labels));\n\tif (!newts)\n\t\treturn -ENOMEM;\n\n\ttun_encap_info = mpls_lwtunnel_encap(newts);\n\tret = nla_get_labels(tb[MPLS_IPTUNNEL_DST], n_labels,\n\t\t\t     &tun_encap_info->labels, tun_encap_info->label,\n\t\t\t     extack);\n\tif (ret)\n\t\tgoto errout;\n\n\ttun_encap_info->ttl_propagate = MPLS_TTL_PROP_DEFAULT;\n\n\tif (tb[MPLS_IPTUNNEL_TTL]) {\n\t\ttun_encap_info->default_ttl = nla_get_u8(tb[MPLS_IPTUNNEL_TTL]);\n\t\t \n\t\ttun_encap_info->ttl_propagate = tun_encap_info->default_ttl ?\n\t\t\tMPLS_TTL_PROP_DISABLED :\n\t\t\tMPLS_TTL_PROP_ENABLED;\n\t}\n\n\tnewts->type = LWTUNNEL_ENCAP_MPLS;\n\tnewts->flags |= LWTUNNEL_STATE_XMIT_REDIRECT;\n\tnewts->headroom = mpls_encap_size(tun_encap_info);\n\n\t*ts = newts;\n\n\treturn 0;\n\nerrout:\n\tkfree(newts);\n\t*ts = NULL;\n\n\treturn ret;\n}\n\nstatic int mpls_fill_encap_info(struct sk_buff *skb,\n\t\t\t\tstruct lwtunnel_state *lwtstate)\n{\n\tstruct mpls_iptunnel_encap *tun_encap_info;\n\n\ttun_encap_info = mpls_lwtunnel_encap(lwtstate);\n\n\tif (nla_put_labels(skb, MPLS_IPTUNNEL_DST, tun_encap_info->labels,\n\t\t\t   tun_encap_info->label))\n\t\tgoto nla_put_failure;\n\n\tif (tun_encap_info->ttl_propagate != MPLS_TTL_PROP_DEFAULT &&\n\t    nla_put_u8(skb, MPLS_IPTUNNEL_TTL, tun_encap_info->default_ttl))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int mpls_encap_nlsize(struct lwtunnel_state *lwtstate)\n{\n\tstruct mpls_iptunnel_encap *tun_encap_info;\n\tint nlsize;\n\n\ttun_encap_info = mpls_lwtunnel_encap(lwtstate);\n\n\tnlsize = nla_total_size(tun_encap_info->labels * 4);\n\n\tif (tun_encap_info->ttl_propagate != MPLS_TTL_PROP_DEFAULT)\n\t\tnlsize += nla_total_size(1);\n\n\treturn nlsize;\n}\n\nstatic int mpls_encap_cmp(struct lwtunnel_state *a, struct lwtunnel_state *b)\n{\n\tstruct mpls_iptunnel_encap *a_hdr = mpls_lwtunnel_encap(a);\n\tstruct mpls_iptunnel_encap *b_hdr = mpls_lwtunnel_encap(b);\n\tint l;\n\n\tif (a_hdr->labels != b_hdr->labels ||\n\t    a_hdr->ttl_propagate != b_hdr->ttl_propagate ||\n\t    a_hdr->default_ttl != b_hdr->default_ttl)\n\t\treturn 1;\n\n\tfor (l = 0; l < a_hdr->labels; l++)\n\t\tif (a_hdr->label[l] != b_hdr->label[l])\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic const struct lwtunnel_encap_ops mpls_iptun_ops = {\n\t.build_state = mpls_build_state,\n\t.xmit = mpls_xmit,\n\t.fill_encap = mpls_fill_encap_info,\n\t.get_encap_size = mpls_encap_nlsize,\n\t.cmp_encap = mpls_encap_cmp,\n\t.owner = THIS_MODULE,\n};\n\nstatic int __init mpls_iptunnel_init(void)\n{\n\treturn lwtunnel_encap_add_ops(&mpls_iptun_ops, LWTUNNEL_ENCAP_MPLS);\n}\nmodule_init(mpls_iptunnel_init);\n\nstatic void __exit mpls_iptunnel_exit(void)\n{\n\tlwtunnel_encap_del_ops(&mpls_iptun_ops, LWTUNNEL_ENCAP_MPLS);\n}\nmodule_exit(mpls_iptunnel_exit);\n\nMODULE_ALIAS_RTNL_LWT(MPLS);\nMODULE_SOFTDEP(\"post: mpls_gso\");\nMODULE_DESCRIPTION(\"MultiProtocol Label Switching IP Tunnels\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}