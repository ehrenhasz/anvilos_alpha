{
  "module_name": "bpfilter_kern.c",
  "hash_id": "5f0394f3dc13368ec194f5f2777aaf52c7ffa1a59635b8b7ccfee132f515507e",
  "original_prompt": "Ingested from linux-6.6.14/net/bpfilter/bpfilter_kern.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/umh.h>\n#include <linux/bpfilter.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include \"msgfmt.h\"\n\nextern char bpfilter_umh_start;\nextern char bpfilter_umh_end;\n\nstatic void shutdown_umh(void)\n{\n\tstruct umd_info *info = &bpfilter_ops.info;\n\tstruct pid *tgid = info->tgid;\n\n\tif (tgid) {\n\t\tkill_pid(tgid, SIGKILL, 1);\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(info);\n\t}\n}\n\nstatic void __stop_umh(void)\n{\n\tif (IS_ENABLED(CONFIG_INET))\n\t\tshutdown_umh();\n}\n\nstatic int bpfilter_send_req(struct mbox_request *req)\n{\n\tstruct mbox_reply reply;\n\tloff_t pos = 0;\n\tssize_t n;\n\n\tif (!bpfilter_ops.info.tgid)\n\t\treturn -EFAULT;\n\tpos = 0;\n\tn = kernel_write(bpfilter_ops.info.pipe_to_umh, req, sizeof(*req),\n\t\t\t   &pos);\n\tif (n != sizeof(*req)) {\n\t\tpr_err(\"write fail %zd\\n\", n);\n\t\tgoto stop;\n\t}\n\tpos = 0;\n\tn = kernel_read(bpfilter_ops.info.pipe_from_umh, &reply, sizeof(reply),\n\t\t\t&pos);\n\tif (n != sizeof(reply)) {\n\t\tpr_err(\"read fail %zd\\n\", n);\n\t\tgoto stop;\n\t}\n\treturn reply.status;\nstop:\n\t__stop_umh();\n\treturn -EFAULT;\n}\n\nstatic int bpfilter_process_sockopt(struct sock *sk, int optname,\n\t\t\t\t    sockptr_t optval, unsigned int optlen,\n\t\t\t\t    bool is_set)\n{\n\tstruct mbox_request req = {\n\t\t.is_set\t\t= is_set,\n\t\t.pid\t\t= current->pid,\n\t\t.cmd\t\t= optname,\n\t\t.addr\t\t= (uintptr_t)optval.user,\n\t\t.len\t\t= optlen,\n\t};\n\tif (sockptr_is_kernel(optval)) {\n\t\tpr_err(\"kernel access not supported\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn bpfilter_send_req(&req);\n}\n\nstatic int start_umh(void)\n{\n\tstruct mbox_request req = { .pid = current->pid };\n\tint err;\n\n\t \n\terr = fork_usermode_driver(&bpfilter_ops.info);\n\tif (err)\n\t\treturn err;\n\tpr_info(\"Loaded bpfilter_umh pid %d\\n\", pid_nr(bpfilter_ops.info.tgid));\n\n\t \n\tif (bpfilter_send_req(&req) != 0) {\n\t\tshutdown_umh();\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init load_umh(void)\n{\n\tint err;\n\n\terr = umd_load_blob(&bpfilter_ops.info,\n\t\t\t    &bpfilter_umh_start,\n\t\t\t    &bpfilter_umh_end - &bpfilter_umh_start);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&bpfilter_ops.lock);\n\terr = start_umh();\n\tif (!err && IS_ENABLED(CONFIG_INET)) {\n\t\tbpfilter_ops.sockopt = &bpfilter_process_sockopt;\n\t\tbpfilter_ops.start = &start_umh;\n\t}\n\tmutex_unlock(&bpfilter_ops.lock);\n\tif (err)\n\t\tumd_unload_blob(&bpfilter_ops.info);\n\treturn err;\n}\n\nstatic void __exit fini_umh(void)\n{\n\tmutex_lock(&bpfilter_ops.lock);\n\tif (IS_ENABLED(CONFIG_INET)) {\n\t\tshutdown_umh();\n\t\tbpfilter_ops.start = NULL;\n\t\tbpfilter_ops.sockopt = NULL;\n\t}\n\tmutex_unlock(&bpfilter_ops.lock);\n\n\tumd_unload_blob(&bpfilter_ops.info);\n}\nmodule_init(load_umh);\nmodule_exit(fini_umh);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}