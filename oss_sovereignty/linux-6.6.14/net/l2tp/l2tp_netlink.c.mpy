{
  "module_name": "l2tp_netlink.c",
  "hash_id": "02a63ed197b43d694acf6c47f314ea159d7391e2a87fccdb33683b169ba81a40",
  "original_prompt": "Ingested from linux-6.6.14/net/l2tp/l2tp_netlink.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <net/sock.h>\n#include <net/genetlink.h>\n#include <net/udp.h>\n#include <linux/in.h>\n#include <linux/udp.h>\n#include <linux/socket.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <net/net_namespace.h>\n\n#include <linux/l2tp.h>\n\n#include \"l2tp_core.h\"\n\nstatic struct genl_family l2tp_nl_family;\n\nstatic const struct genl_multicast_group l2tp_multicast_group[] = {\n\t{\n\t\t.name = L2TP_GENL_MCGROUP,\n\t},\n};\n\nstatic int l2tp_nl_tunnel_send(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t       int flags, struct l2tp_tunnel *tunnel, u8 cmd);\nstatic int l2tp_nl_session_send(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t\tint flags, struct l2tp_session *session,\n\t\t\t\tu8 cmd);\n\n \nstatic const struct l2tp_nl_cmd_ops *l2tp_nl_cmd_ops[__L2TP_PWTYPE_MAX];\n\nstatic struct l2tp_session *l2tp_nl_session_get(struct genl_info *info)\n{\n\tu32 tunnel_id;\n\tu32 session_id;\n\tchar *ifname;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct l2tp_session *session = NULL;\n\tstruct net *net = genl_info_net(info);\n\n\tif (info->attrs[L2TP_ATTR_IFNAME]) {\n\t\tifname = nla_data(info->attrs[L2TP_ATTR_IFNAME]);\n\t\tsession = l2tp_session_get_by_ifname(net, ifname);\n\t} else if ((info->attrs[L2TP_ATTR_SESSION_ID]) &&\n\t\t   (info->attrs[L2TP_ATTR_CONN_ID])) {\n\t\ttunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_CONN_ID]);\n\t\tsession_id = nla_get_u32(info->attrs[L2TP_ATTR_SESSION_ID]);\n\t\ttunnel = l2tp_tunnel_get(net, tunnel_id);\n\t\tif (tunnel) {\n\t\t\tsession = l2tp_tunnel_get_session(tunnel, session_id);\n\t\t\tl2tp_tunnel_dec_refcount(tunnel);\n\t\t}\n\t}\n\n\treturn session;\n}\n\nstatic int l2tp_nl_cmd_noop(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint ret = -ENOBUFS;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thdr = genlmsg_put(msg, info->snd_portid, info->snd_seq,\n\t\t\t  &l2tp_nl_family, 0, L2TP_CMD_NOOP);\n\tif (!hdr) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err_out;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_unicast(genl_info_net(info), msg, info->snd_portid);\n\nerr_out:\n\tnlmsg_free(msg);\n\nout:\n\treturn ret;\n}\n\nstatic int l2tp_tunnel_notify(struct genl_family *family,\n\t\t\t      struct genl_info *info,\n\t\t\t      struct l2tp_tunnel *tunnel,\n\t\t\t      u8 cmd)\n{\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = l2tp_nl_tunnel_send(msg, info->snd_portid, info->snd_seq,\n\t\t\t\t  NLM_F_ACK, tunnel, cmd);\n\n\tif (ret >= 0) {\n\t\tret = genlmsg_multicast_allns(family, msg, 0, 0, GFP_ATOMIC);\n\t\t \n\t\tif (ret == -ESRCH)\n\t\t\tret = 0;\n\t\treturn ret;\n\t}\n\n\tnlmsg_free(msg);\n\n\treturn ret;\n}\n\nstatic int l2tp_session_notify(struct genl_family *family,\n\t\t\t       struct genl_info *info,\n\t\t\t       struct l2tp_session *session,\n\t\t\t       u8 cmd)\n{\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = l2tp_nl_session_send(msg, info->snd_portid, info->snd_seq,\n\t\t\t\t   NLM_F_ACK, session, cmd);\n\n\tif (ret >= 0) {\n\t\tret = genlmsg_multicast_allns(family, msg, 0, 0, GFP_ATOMIC);\n\t\t \n\t\tif (ret == -ESRCH)\n\t\t\tret = 0;\n\t\treturn ret;\n\t}\n\n\tnlmsg_free(msg);\n\n\treturn ret;\n}\n\nstatic int l2tp_nl_cmd_tunnel_create_get_addr(struct nlattr **attrs, struct l2tp_tunnel_cfg *cfg)\n{\n\tif (attrs[L2TP_ATTR_UDP_SPORT])\n\t\tcfg->local_udp_port = nla_get_u16(attrs[L2TP_ATTR_UDP_SPORT]);\n\tif (attrs[L2TP_ATTR_UDP_DPORT])\n\t\tcfg->peer_udp_port = nla_get_u16(attrs[L2TP_ATTR_UDP_DPORT]);\n\tcfg->use_udp_checksums = nla_get_flag(attrs[L2TP_ATTR_UDP_CSUM]);\n\n\t \n#if IS_ENABLED(CONFIG_IPV6)\n\tif (attrs[L2TP_ATTR_IP6_SADDR] && attrs[L2TP_ATTR_IP6_DADDR]) {\n\t\tcfg->local_ip6 = nla_data(attrs[L2TP_ATTR_IP6_SADDR]);\n\t\tcfg->peer_ip6 = nla_data(attrs[L2TP_ATTR_IP6_DADDR]);\n\t\tcfg->udp6_zero_tx_checksums = nla_get_flag(attrs[L2TP_ATTR_UDP_ZERO_CSUM6_TX]);\n\t\tcfg->udp6_zero_rx_checksums = nla_get_flag(attrs[L2TP_ATTR_UDP_ZERO_CSUM6_RX]);\n\t\treturn 0;\n\t}\n#endif\n\tif (attrs[L2TP_ATTR_IP_SADDR] && attrs[L2TP_ATTR_IP_DADDR]) {\n\t\tcfg->local_ip.s_addr = nla_get_in_addr(attrs[L2TP_ATTR_IP_SADDR]);\n\t\tcfg->peer_ip.s_addr = nla_get_in_addr(attrs[L2TP_ATTR_IP_DADDR]);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int l2tp_nl_cmd_tunnel_create(struct sk_buff *skb, struct genl_info *info)\n{\n\tu32 tunnel_id;\n\tu32 peer_tunnel_id;\n\tint proto_version;\n\tint fd = -1;\n\tint ret = 0;\n\tstruct l2tp_tunnel_cfg cfg = { 0, };\n\tstruct l2tp_tunnel *tunnel;\n\tstruct net *net = genl_info_net(info);\n\tstruct nlattr **attrs = info->attrs;\n\n\tif (!attrs[L2TP_ATTR_CONN_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\ttunnel_id = nla_get_u32(attrs[L2TP_ATTR_CONN_ID]);\n\n\tif (!attrs[L2TP_ATTR_PEER_CONN_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tpeer_tunnel_id = nla_get_u32(attrs[L2TP_ATTR_PEER_CONN_ID]);\n\n\tif (!attrs[L2TP_ATTR_PROTO_VERSION]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tproto_version = nla_get_u8(attrs[L2TP_ATTR_PROTO_VERSION]);\n\n\tif (!attrs[L2TP_ATTR_ENCAP_TYPE]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tcfg.encap = nla_get_u16(attrs[L2TP_ATTR_ENCAP_TYPE]);\n\n\t \n\tif (attrs[L2TP_ATTR_FD]) {\n\t\tfd = nla_get_u32(attrs[L2TP_ATTR_FD]);\n\t} else {\n\t\tret = l2tp_nl_cmd_tunnel_create_get_addr(attrs, &cfg);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = -EINVAL;\n\tswitch (cfg.encap) {\n\tcase L2TP_ENCAPTYPE_UDP:\n\tcase L2TP_ENCAPTYPE_IP:\n\t\tret = l2tp_tunnel_create(fd, proto_version, tunnel_id,\n\t\t\t\t\t peer_tunnel_id, &cfg, &tunnel);\n\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tl2tp_tunnel_inc_refcount(tunnel);\n\tret = l2tp_tunnel_register(tunnel, net, &cfg);\n\tif (ret < 0) {\n\t\tkfree(tunnel);\n\t\tgoto out;\n\t}\n\tret = l2tp_tunnel_notify(&l2tp_nl_family, info, tunnel,\n\t\t\t\t L2TP_CMD_TUNNEL_CREATE);\n\tl2tp_tunnel_dec_refcount(tunnel);\n\nout:\n\treturn ret;\n}\n\nstatic int l2tp_nl_cmd_tunnel_delete(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct l2tp_tunnel *tunnel;\n\tu32 tunnel_id;\n\tint ret = 0;\n\tstruct net *net = genl_info_net(info);\n\n\tif (!info->attrs[L2TP_ATTR_CONN_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\ttunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_CONN_ID]);\n\n\ttunnel = l2tp_tunnel_get(net, tunnel_id);\n\tif (!tunnel) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tl2tp_tunnel_notify(&l2tp_nl_family, info,\n\t\t\t   tunnel, L2TP_CMD_TUNNEL_DELETE);\n\n\tl2tp_tunnel_delete(tunnel);\n\n\tl2tp_tunnel_dec_refcount(tunnel);\n\nout:\n\treturn ret;\n}\n\nstatic int l2tp_nl_cmd_tunnel_modify(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct l2tp_tunnel *tunnel;\n\tu32 tunnel_id;\n\tint ret = 0;\n\tstruct net *net = genl_info_net(info);\n\n\tif (!info->attrs[L2TP_ATTR_CONN_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\ttunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_CONN_ID]);\n\n\ttunnel = l2tp_tunnel_get(net, tunnel_id);\n\tif (!tunnel) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tret = l2tp_tunnel_notify(&l2tp_nl_family, info,\n\t\t\t\t tunnel, L2TP_CMD_TUNNEL_MODIFY);\n\n\tl2tp_tunnel_dec_refcount(tunnel);\n\nout:\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int l2tp_nl_tunnel_send_addr6(struct sk_buff *skb, struct sock *sk,\n\t\t\t\t     enum l2tp_encap_type encap)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\tswitch (encap) {\n\tcase L2TP_ENCAPTYPE_UDP:\n\t\tif (udp_get_no_check6_tx(sk) &&\n\t\t    nla_put_flag(skb, L2TP_ATTR_UDP_ZERO_CSUM6_TX))\n\t\t\treturn -1;\n\t\tif (udp_get_no_check6_rx(sk) &&\n\t\t    nla_put_flag(skb, L2TP_ATTR_UDP_ZERO_CSUM6_RX))\n\t\t\treturn -1;\n\t\tif (nla_put_u16(skb, L2TP_ATTR_UDP_SPORT, ntohs(inet->inet_sport)) ||\n\t\t    nla_put_u16(skb, L2TP_ATTR_UDP_DPORT, ntohs(inet->inet_dport)))\n\t\t\treturn -1;\n\t\tfallthrough;\n\tcase L2TP_ENCAPTYPE_IP:\n\t\tif (nla_put_in6_addr(skb, L2TP_ATTR_IP6_SADDR, &np->saddr) ||\n\t\t    nla_put_in6_addr(skb, L2TP_ATTR_IP6_DADDR, &sk->sk_v6_daddr))\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic int l2tp_nl_tunnel_send_addr4(struct sk_buff *skb, struct sock *sk,\n\t\t\t\t     enum l2tp_encap_type encap)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\tswitch (encap) {\n\tcase L2TP_ENCAPTYPE_UDP:\n\t\tif (nla_put_u8(skb, L2TP_ATTR_UDP_CSUM, !sk->sk_no_check_tx) ||\n\t\t    nla_put_u16(skb, L2TP_ATTR_UDP_SPORT, ntohs(inet->inet_sport)) ||\n\t\t    nla_put_u16(skb, L2TP_ATTR_UDP_DPORT, ntohs(inet->inet_dport)))\n\t\t\treturn -1;\n\t\tfallthrough;\n\tcase L2TP_ENCAPTYPE_IP:\n\t\tif (nla_put_in_addr(skb, L2TP_ATTR_IP_SADDR, inet->inet_saddr) ||\n\t\t    nla_put_in_addr(skb, L2TP_ATTR_IP_DADDR, inet->inet_daddr))\n\t\t\treturn -1;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int l2tp_nl_tunnel_send_addr(struct sk_buff *skb, struct l2tp_tunnel *tunnel)\n{\n\tstruct sock *sk = tunnel->sock;\n\n\tif (!sk)\n\t\treturn 0;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\treturn l2tp_nl_tunnel_send_addr6(skb, sk, tunnel->encap);\n#endif\n\treturn l2tp_nl_tunnel_send_addr4(skb, sk, tunnel->encap);\n}\n\nstatic int l2tp_nl_tunnel_send(struct sk_buff *skb, u32 portid, u32 seq, int flags,\n\t\t\t       struct l2tp_tunnel *tunnel, u8 cmd)\n{\n\tvoid *hdr;\n\tstruct nlattr *nest;\n\n\thdr = genlmsg_put(skb, portid, seq, &l2tp_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u8(skb, L2TP_ATTR_PROTO_VERSION, tunnel->version) ||\n\t    nla_put_u32(skb, L2TP_ATTR_CONN_ID, tunnel->tunnel_id) ||\n\t    nla_put_u32(skb, L2TP_ATTR_PEER_CONN_ID, tunnel->peer_tunnel_id) ||\n\t    nla_put_u32(skb, L2TP_ATTR_DEBUG, 0) ||\n\t    nla_put_u16(skb, L2TP_ATTR_ENCAP_TYPE, tunnel->encap))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start_noflag(skb, L2TP_ATTR_STATS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(skb, L2TP_ATTR_TX_PACKETS,\n\t\t\t      atomic_long_read(&tunnel->stats.tx_packets),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_TX_BYTES,\n\t\t\t      atomic_long_read(&tunnel->stats.tx_bytes),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_TX_ERRORS,\n\t\t\t      atomic_long_read(&tunnel->stats.tx_errors),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_PACKETS,\n\t\t\t      atomic_long_read(&tunnel->stats.rx_packets),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_BYTES,\n\t\t\t      atomic_long_read(&tunnel->stats.rx_bytes),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_SEQ_DISCARDS,\n\t\t\t      atomic_long_read(&tunnel->stats.rx_seq_discards),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_COOKIE_DISCARDS,\n\t\t\t      atomic_long_read(&tunnel->stats.rx_cookie_discards),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_OOS_PACKETS,\n\t\t\t      atomic_long_read(&tunnel->stats.rx_oos_packets),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_ERRORS,\n\t\t\t      atomic_long_read(&tunnel->stats.rx_errors),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_INVALID,\n\t\t\t      atomic_long_read(&tunnel->stats.rx_invalid),\n\t\t\t      L2TP_ATTR_STATS_PAD))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest);\n\n\tif (l2tp_nl_tunnel_send_addr(skb, tunnel))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -1;\n}\n\nstatic int l2tp_nl_cmd_tunnel_get(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct l2tp_tunnel *tunnel;\n\tstruct sk_buff *msg;\n\tu32 tunnel_id;\n\tint ret = -ENOBUFS;\n\tstruct net *net = genl_info_net(info);\n\n\tif (!info->attrs[L2TP_ATTR_CONN_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\ttunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_CONN_ID]);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\ttunnel = l2tp_tunnel_get(net, tunnel_id);\n\tif (!tunnel) {\n\t\tret = -ENODEV;\n\t\tgoto err_nlmsg;\n\t}\n\n\tret = l2tp_nl_tunnel_send(msg, info->snd_portid, info->snd_seq,\n\t\t\t\t  NLM_F_ACK, tunnel, L2TP_CMD_TUNNEL_GET);\n\tif (ret < 0)\n\t\tgoto err_nlmsg_tunnel;\n\n\tl2tp_tunnel_dec_refcount(tunnel);\n\n\treturn genlmsg_unicast(net, msg, info->snd_portid);\n\nerr_nlmsg_tunnel:\n\tl2tp_tunnel_dec_refcount(tunnel);\nerr_nlmsg:\n\tnlmsg_free(msg);\nerr:\n\treturn ret;\n}\n\nstatic int l2tp_nl_cmd_tunnel_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint ti = cb->args[0];\n\tstruct l2tp_tunnel *tunnel;\n\tstruct net *net = sock_net(skb->sk);\n\n\tfor (;;) {\n\t\ttunnel = l2tp_tunnel_get_nth(net, ti);\n\t\tif (!tunnel)\n\t\t\tgoto out;\n\n\t\tif (l2tp_nl_tunnel_send(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\ttunnel, L2TP_CMD_TUNNEL_GET) < 0) {\n\t\t\tl2tp_tunnel_dec_refcount(tunnel);\n\t\t\tgoto out;\n\t\t}\n\t\tl2tp_tunnel_dec_refcount(tunnel);\n\n\t\tti++;\n\t}\n\nout:\n\tcb->args[0] = ti;\n\n\treturn skb->len;\n}\n\nstatic int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *info)\n{\n\tu32 tunnel_id = 0;\n\tu32 session_id;\n\tu32 peer_session_id;\n\tint ret = 0;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct l2tp_session *session;\n\tstruct l2tp_session_cfg cfg = { 0, };\n\tstruct net *net = genl_info_net(info);\n\n\tif (!info->attrs[L2TP_ATTR_CONN_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttunnel_id = nla_get_u32(info->attrs[L2TP_ATTR_CONN_ID]);\n\ttunnel = l2tp_tunnel_get(net, tunnel_id);\n\tif (!tunnel) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (!info->attrs[L2TP_ATTR_SESSION_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto out_tunnel;\n\t}\n\tsession_id = nla_get_u32(info->attrs[L2TP_ATTR_SESSION_ID]);\n\n\tif (!info->attrs[L2TP_ATTR_PEER_SESSION_ID]) {\n\t\tret = -EINVAL;\n\t\tgoto out_tunnel;\n\t}\n\tpeer_session_id = nla_get_u32(info->attrs[L2TP_ATTR_PEER_SESSION_ID]);\n\n\tif (!info->attrs[L2TP_ATTR_PW_TYPE]) {\n\t\tret = -EINVAL;\n\t\tgoto out_tunnel;\n\t}\n\tcfg.pw_type = nla_get_u16(info->attrs[L2TP_ATTR_PW_TYPE]);\n\tif (cfg.pw_type >= __L2TP_PWTYPE_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto out_tunnel;\n\t}\n\n\t \n\tif (tunnel->version == 2 && cfg.pw_type != L2TP_PWTYPE_PPP) {\n\t\tret = -EPROTONOSUPPORT;\n\t\tgoto out_tunnel;\n\t}\n\n\tif (tunnel->version > 2) {\n\t\tif (info->attrs[L2TP_ATTR_L2SPEC_TYPE]) {\n\t\t\tcfg.l2specific_type = nla_get_u8(info->attrs[L2TP_ATTR_L2SPEC_TYPE]);\n\t\t\tif (cfg.l2specific_type != L2TP_L2SPECTYPE_DEFAULT &&\n\t\t\t    cfg.l2specific_type != L2TP_L2SPECTYPE_NONE) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_tunnel;\n\t\t\t}\n\t\t} else {\n\t\t\tcfg.l2specific_type = L2TP_L2SPECTYPE_DEFAULT;\n\t\t}\n\n\t\tif (info->attrs[L2TP_ATTR_COOKIE]) {\n\t\t\tu16 len = nla_len(info->attrs[L2TP_ATTR_COOKIE]);\n\n\t\t\tif (len > 8) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_tunnel;\n\t\t\t}\n\t\t\tcfg.cookie_len = len;\n\t\t\tmemcpy(&cfg.cookie[0], nla_data(info->attrs[L2TP_ATTR_COOKIE]), len);\n\t\t}\n\t\tif (info->attrs[L2TP_ATTR_PEER_COOKIE]) {\n\t\t\tu16 len = nla_len(info->attrs[L2TP_ATTR_PEER_COOKIE]);\n\n\t\t\tif (len > 8) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_tunnel;\n\t\t\t}\n\t\t\tcfg.peer_cookie_len = len;\n\t\t\tmemcpy(&cfg.peer_cookie[0], nla_data(info->attrs[L2TP_ATTR_PEER_COOKIE]), len);\n\t\t}\n\t\tif (info->attrs[L2TP_ATTR_IFNAME])\n\t\t\tcfg.ifname = nla_data(info->attrs[L2TP_ATTR_IFNAME]);\n\t}\n\n\tif (info->attrs[L2TP_ATTR_RECV_SEQ])\n\t\tcfg.recv_seq = nla_get_u8(info->attrs[L2TP_ATTR_RECV_SEQ]);\n\n\tif (info->attrs[L2TP_ATTR_SEND_SEQ])\n\t\tcfg.send_seq = nla_get_u8(info->attrs[L2TP_ATTR_SEND_SEQ]);\n\n\tif (info->attrs[L2TP_ATTR_LNS_MODE])\n\t\tcfg.lns_mode = nla_get_u8(info->attrs[L2TP_ATTR_LNS_MODE]);\n\n\tif (info->attrs[L2TP_ATTR_RECV_TIMEOUT])\n\t\tcfg.reorder_timeout = nla_get_msecs(info->attrs[L2TP_ATTR_RECV_TIMEOUT]);\n\n#ifdef CONFIG_MODULES\n\tif (!l2tp_nl_cmd_ops[cfg.pw_type]) {\n\t\tgenl_unlock();\n\t\trequest_module(\"net-l2tp-type-%u\", cfg.pw_type);\n\t\tgenl_lock();\n\t}\n#endif\n\tif (!l2tp_nl_cmd_ops[cfg.pw_type] || !l2tp_nl_cmd_ops[cfg.pw_type]->session_create) {\n\t\tret = -EPROTONOSUPPORT;\n\t\tgoto out_tunnel;\n\t}\n\n\tret = l2tp_nl_cmd_ops[cfg.pw_type]->session_create(net, tunnel,\n\t\t\t\t\t\t\t   session_id,\n\t\t\t\t\t\t\t   peer_session_id,\n\t\t\t\t\t\t\t   &cfg);\n\n\tif (ret >= 0) {\n\t\tsession = l2tp_tunnel_get_session(tunnel, session_id);\n\t\tif (session) {\n\t\t\tret = l2tp_session_notify(&l2tp_nl_family, info, session,\n\t\t\t\t\t\t  L2TP_CMD_SESSION_CREATE);\n\t\t\tl2tp_session_dec_refcount(session);\n\t\t}\n\t}\n\nout_tunnel:\n\tl2tp_tunnel_dec_refcount(tunnel);\nout:\n\treturn ret;\n}\n\nstatic int l2tp_nl_cmd_session_delete(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret = 0;\n\tstruct l2tp_session *session;\n\tu16 pw_type;\n\n\tsession = l2tp_nl_session_get(info);\n\tif (!session) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tl2tp_session_notify(&l2tp_nl_family, info,\n\t\t\t    session, L2TP_CMD_SESSION_DELETE);\n\n\tpw_type = session->pwtype;\n\tif (pw_type < __L2TP_PWTYPE_MAX)\n\t\tif (l2tp_nl_cmd_ops[pw_type] && l2tp_nl_cmd_ops[pw_type]->session_delete)\n\t\t\tl2tp_nl_cmd_ops[pw_type]->session_delete(session);\n\n\tl2tp_session_dec_refcount(session);\n\nout:\n\treturn ret;\n}\n\nstatic int l2tp_nl_cmd_session_modify(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret = 0;\n\tstruct l2tp_session *session;\n\n\tsession = l2tp_nl_session_get(info);\n\tif (!session) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (info->attrs[L2TP_ATTR_RECV_SEQ])\n\t\tsession->recv_seq = nla_get_u8(info->attrs[L2TP_ATTR_RECV_SEQ]);\n\n\tif (info->attrs[L2TP_ATTR_SEND_SEQ]) {\n\t\tsession->send_seq = nla_get_u8(info->attrs[L2TP_ATTR_SEND_SEQ]);\n\t\tl2tp_session_set_header_len(session, session->tunnel->version);\n\t}\n\n\tif (info->attrs[L2TP_ATTR_LNS_MODE])\n\t\tsession->lns_mode = nla_get_u8(info->attrs[L2TP_ATTR_LNS_MODE]);\n\n\tif (info->attrs[L2TP_ATTR_RECV_TIMEOUT])\n\t\tsession->reorder_timeout = nla_get_msecs(info->attrs[L2TP_ATTR_RECV_TIMEOUT]);\n\n\tret = l2tp_session_notify(&l2tp_nl_family, info,\n\t\t\t\t  session, L2TP_CMD_SESSION_MODIFY);\n\n\tl2tp_session_dec_refcount(session);\n\nout:\n\treturn ret;\n}\n\nstatic int l2tp_nl_session_send(struct sk_buff *skb, u32 portid, u32 seq, int flags,\n\t\t\t\tstruct l2tp_session *session, u8 cmd)\n{\n\tvoid *hdr;\n\tstruct nlattr *nest;\n\tstruct l2tp_tunnel *tunnel = session->tunnel;\n\n\thdr = genlmsg_put(skb, portid, seq, &l2tp_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, L2TP_ATTR_CONN_ID, tunnel->tunnel_id) ||\n\t    nla_put_u32(skb, L2TP_ATTR_SESSION_ID, session->session_id) ||\n\t    nla_put_u32(skb, L2TP_ATTR_PEER_CONN_ID, tunnel->peer_tunnel_id) ||\n\t    nla_put_u32(skb, L2TP_ATTR_PEER_SESSION_ID, session->peer_session_id) ||\n\t    nla_put_u32(skb, L2TP_ATTR_DEBUG, 0) ||\n\t    nla_put_u16(skb, L2TP_ATTR_PW_TYPE, session->pwtype))\n\t\tgoto nla_put_failure;\n\n\tif ((session->ifname[0] &&\n\t     nla_put_string(skb, L2TP_ATTR_IFNAME, session->ifname)) ||\n\t    (session->cookie_len &&\n\t     nla_put(skb, L2TP_ATTR_COOKIE, session->cookie_len, session->cookie)) ||\n\t    (session->peer_cookie_len &&\n\t     nla_put(skb, L2TP_ATTR_PEER_COOKIE, session->peer_cookie_len, session->peer_cookie)) ||\n\t    nla_put_u8(skb, L2TP_ATTR_RECV_SEQ, session->recv_seq) ||\n\t    nla_put_u8(skb, L2TP_ATTR_SEND_SEQ, session->send_seq) ||\n\t    nla_put_u8(skb, L2TP_ATTR_LNS_MODE, session->lns_mode) ||\n\t    (l2tp_tunnel_uses_xfrm(tunnel) &&\n\t     nla_put_u8(skb, L2TP_ATTR_USING_IPSEC, 1)) ||\n\t    (session->reorder_timeout &&\n\t     nla_put_msecs(skb, L2TP_ATTR_RECV_TIMEOUT,\n\t\t\t   session->reorder_timeout, L2TP_ATTR_PAD)))\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start_noflag(skb, L2TP_ATTR_STATS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(skb, L2TP_ATTR_TX_PACKETS,\n\t\t\t      atomic_long_read(&session->stats.tx_packets),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_TX_BYTES,\n\t\t\t      atomic_long_read(&session->stats.tx_bytes),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_TX_ERRORS,\n\t\t\t      atomic_long_read(&session->stats.tx_errors),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_PACKETS,\n\t\t\t      atomic_long_read(&session->stats.rx_packets),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_BYTES,\n\t\t\t      atomic_long_read(&session->stats.rx_bytes),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_SEQ_DISCARDS,\n\t\t\t      atomic_long_read(&session->stats.rx_seq_discards),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_COOKIE_DISCARDS,\n\t\t\t      atomic_long_read(&session->stats.rx_cookie_discards),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_OOS_PACKETS,\n\t\t\t      atomic_long_read(&session->stats.rx_oos_packets),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_ERRORS,\n\t\t\t      atomic_long_read(&session->stats.rx_errors),\n\t\t\t      L2TP_ATTR_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, L2TP_ATTR_RX_INVALID,\n\t\t\t      atomic_long_read(&session->stats.rx_invalid),\n\t\t\t      L2TP_ATTR_STATS_PAD))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest);\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -1;\n}\n\nstatic int l2tp_nl_cmd_session_get(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct l2tp_session *session;\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tsession = l2tp_nl_session_get(info);\n\tif (!session) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tret = -ENOMEM;\n\t\tgoto err_ref;\n\t}\n\n\tret = l2tp_nl_session_send(msg, info->snd_portid, info->snd_seq,\n\t\t\t\t   0, session, L2TP_CMD_SESSION_GET);\n\tif (ret < 0)\n\t\tgoto err_ref_msg;\n\n\tret = genlmsg_unicast(genl_info_net(info), msg, info->snd_portid);\n\n\tl2tp_session_dec_refcount(session);\n\n\treturn ret;\n\nerr_ref_msg:\n\tnlmsg_free(msg);\nerr_ref:\n\tl2tp_session_dec_refcount(session);\nerr:\n\treturn ret;\n}\n\nstatic int l2tp_nl_cmd_session_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel = NULL;\n\tint ti = cb->args[0];\n\tint si = cb->args[1];\n\n\tfor (;;) {\n\t\tif (!tunnel) {\n\t\t\ttunnel = l2tp_tunnel_get_nth(net, ti);\n\t\t\tif (!tunnel)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tsession = l2tp_session_get_nth(tunnel, si);\n\t\tif (!session) {\n\t\t\tti++;\n\t\t\tl2tp_tunnel_dec_refcount(tunnel);\n\t\t\ttunnel = NULL;\n\t\t\tsi = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (l2tp_nl_session_send(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t session, L2TP_CMD_SESSION_GET) < 0) {\n\t\t\tl2tp_session_dec_refcount(session);\n\t\t\tl2tp_tunnel_dec_refcount(tunnel);\n\t\t\tbreak;\n\t\t}\n\t\tl2tp_session_dec_refcount(session);\n\n\t\tsi++;\n\t}\n\nout:\n\tcb->args[0] = ti;\n\tcb->args[1] = si;\n\n\treturn skb->len;\n}\n\nstatic const struct nla_policy l2tp_nl_policy[L2TP_ATTR_MAX + 1] = {\n\t[L2TP_ATTR_NONE]\t\t= { .type = NLA_UNSPEC, },\n\t[L2TP_ATTR_PW_TYPE]\t\t= { .type = NLA_U16, },\n\t[L2TP_ATTR_ENCAP_TYPE]\t\t= { .type = NLA_U16, },\n\t[L2TP_ATTR_OFFSET]\t\t= { .type = NLA_U16, },\n\t[L2TP_ATTR_DATA_SEQ]\t\t= { .type = NLA_U8, },\n\t[L2TP_ATTR_L2SPEC_TYPE]\t\t= { .type = NLA_U8, },\n\t[L2TP_ATTR_L2SPEC_LEN]\t\t= { .type = NLA_U8, },\n\t[L2TP_ATTR_PROTO_VERSION]\t= { .type = NLA_U8, },\n\t[L2TP_ATTR_CONN_ID]\t\t= { .type = NLA_U32, },\n\t[L2TP_ATTR_PEER_CONN_ID]\t= { .type = NLA_U32, },\n\t[L2TP_ATTR_SESSION_ID]\t\t= { .type = NLA_U32, },\n\t[L2TP_ATTR_PEER_SESSION_ID]\t= { .type = NLA_U32, },\n\t[L2TP_ATTR_UDP_CSUM]\t\t= { .type = NLA_U8, },\n\t[L2TP_ATTR_VLAN_ID]\t\t= { .type = NLA_U16, },\n\t[L2TP_ATTR_DEBUG]\t\t= { .type = NLA_U32, },\n\t[L2TP_ATTR_RECV_SEQ]\t\t= { .type = NLA_U8, },\n\t[L2TP_ATTR_SEND_SEQ]\t\t= { .type = NLA_U8, },\n\t[L2TP_ATTR_LNS_MODE]\t\t= { .type = NLA_U8, },\n\t[L2TP_ATTR_USING_IPSEC]\t\t= { .type = NLA_U8, },\n\t[L2TP_ATTR_RECV_TIMEOUT]\t= { .type = NLA_MSECS, },\n\t[L2TP_ATTR_FD]\t\t\t= { .type = NLA_U32, },\n\t[L2TP_ATTR_IP_SADDR]\t\t= { .type = NLA_U32, },\n\t[L2TP_ATTR_IP_DADDR]\t\t= { .type = NLA_U32, },\n\t[L2TP_ATTR_UDP_SPORT]\t\t= { .type = NLA_U16, },\n\t[L2TP_ATTR_UDP_DPORT]\t\t= { .type = NLA_U16, },\n\t[L2TP_ATTR_MTU]\t\t\t= { .type = NLA_U16, },\n\t[L2TP_ATTR_MRU]\t\t\t= { .type = NLA_U16, },\n\t[L2TP_ATTR_STATS]\t\t= { .type = NLA_NESTED, },\n\t[L2TP_ATTR_IP6_SADDR] = {\n\t\t.type = NLA_BINARY,\n\t\t.len = sizeof(struct in6_addr),\n\t},\n\t[L2TP_ATTR_IP6_DADDR] = {\n\t\t.type = NLA_BINARY,\n\t\t.len = sizeof(struct in6_addr),\n\t},\n\t[L2TP_ATTR_IFNAME] = {\n\t\t.type = NLA_NUL_STRING,\n\t\t.len = IFNAMSIZ - 1,\n\t},\n\t[L2TP_ATTR_COOKIE] = {\n\t\t.type = NLA_BINARY,\n\t\t.len = 8,\n\t},\n\t[L2TP_ATTR_PEER_COOKIE] = {\n\t\t.type = NLA_BINARY,\n\t\t.len = 8,\n\t},\n};\n\nstatic const struct genl_small_ops l2tp_nl_ops[] = {\n\t{\n\t\t.cmd = L2TP_CMD_NOOP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = l2tp_nl_cmd_noop,\n\t\t \n\t},\n\t{\n\t\t.cmd = L2TP_CMD_TUNNEL_CREATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = l2tp_nl_cmd_tunnel_create,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = L2TP_CMD_TUNNEL_DELETE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = l2tp_nl_cmd_tunnel_delete,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = L2TP_CMD_TUNNEL_MODIFY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = l2tp_nl_cmd_tunnel_modify,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = L2TP_CMD_TUNNEL_GET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = l2tp_nl_cmd_tunnel_get,\n\t\t.dumpit = l2tp_nl_cmd_tunnel_dump,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = L2TP_CMD_SESSION_CREATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = l2tp_nl_cmd_session_create,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = L2TP_CMD_SESSION_DELETE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = l2tp_nl_cmd_session_delete,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = L2TP_CMD_SESSION_MODIFY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = l2tp_nl_cmd_session_modify,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = L2TP_CMD_SESSION_GET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = l2tp_nl_cmd_session_get,\n\t\t.dumpit = l2tp_nl_cmd_session_dump,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n};\n\nstatic struct genl_family l2tp_nl_family __ro_after_init = {\n\t.name\t\t= L2TP_GENL_NAME,\n\t.version\t= L2TP_GENL_VERSION,\n\t.hdrsize\t= 0,\n\t.maxattr\t= L2TP_ATTR_MAX,\n\t.policy = l2tp_nl_policy,\n\t.netnsok\t= true,\n\t.module\t\t= THIS_MODULE,\n\t.small_ops\t= l2tp_nl_ops,\n\t.n_small_ops\t= ARRAY_SIZE(l2tp_nl_ops),\n\t.resv_start_op\t= L2TP_CMD_SESSION_GET + 1,\n\t.mcgrps\t\t= l2tp_multicast_group,\n\t.n_mcgrps\t= ARRAY_SIZE(l2tp_multicast_group),\n};\n\nint l2tp_nl_register_ops(enum l2tp_pwtype pw_type, const struct l2tp_nl_cmd_ops *ops)\n{\n\tint ret;\n\n\tret = -EINVAL;\n\tif (pw_type >= __L2TP_PWTYPE_MAX)\n\t\tgoto err;\n\n\tgenl_lock();\n\tret = -EBUSY;\n\tif (l2tp_nl_cmd_ops[pw_type])\n\t\tgoto out;\n\n\tl2tp_nl_cmd_ops[pw_type] = ops;\n\tret = 0;\n\nout:\n\tgenl_unlock();\nerr:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(l2tp_nl_register_ops);\n\nvoid l2tp_nl_unregister_ops(enum l2tp_pwtype pw_type)\n{\n\tif (pw_type < __L2TP_PWTYPE_MAX) {\n\t\tgenl_lock();\n\t\tl2tp_nl_cmd_ops[pw_type] = NULL;\n\t\tgenl_unlock();\n\t}\n}\nEXPORT_SYMBOL_GPL(l2tp_nl_unregister_ops);\n\nstatic int __init l2tp_nl_init(void)\n{\n\tpr_info(\"L2TP netlink interface\\n\");\n\treturn genl_register_family(&l2tp_nl_family);\n}\n\nstatic void l2tp_nl_cleanup(void)\n{\n\tgenl_unregister_family(&l2tp_nl_family);\n}\n\nmodule_init(l2tp_nl_init);\nmodule_exit(l2tp_nl_cleanup);\n\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP netlink\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.0\");\nMODULE_ALIAS_GENL_FAMILY(\"l2tp\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}