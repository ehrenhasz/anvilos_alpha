{
  "module_name": "l2tp_ppp.c",
  "hash_id": "3b287dc3decb771091fce521dd9e74bd175ccf60f815db560aed4d8ecdc8dc88",
  "original_prompt": "Ingested from linux-6.6.14/net/l2tp/l2tp_ppp.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n\n#include <linux/netdevice.h>\n#include <linux/net.h>\n#include <linux/inetdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/ip.h>\n#include <linux/udp.h>\n#include <linux/if_pppox.h>\n#include <linux/if_pppol2tp.h>\n#include <net/sock.h>\n#include <linux/ppp_channel.h>\n#include <linux/ppp_defs.h>\n#include <linux/ppp-ioctl.h>\n#include <linux/file.h>\n#include <linux/hash.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/l2tp.h>\n#include <linux/nsproxy.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/ip.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n\n#include <asm/byteorder.h>\n#include <linux/atomic.h>\n\n#include \"l2tp_core.h\"\n\n#define PPPOL2TP_DRV_VERSION\t\"V2.0\"\n\n \n#define PPPOL2TP_HEADER_OVERHEAD\t40\n\n \n#define PPPOL2TP_L2TP_HDR_SIZE_SEQ\t\t10\n#define PPPOL2TP_L2TP_HDR_SIZE_NOSEQ\t\t6\n\n \nstruct pppol2tp_session {\n\tint\t\t\towner;\t\t \n\n\tstruct mutex\t\tsk_lock;\t \n\tstruct sock __rcu\t*sk;\t\t \n\tstruct sock\t\t*__sk;\t\t \n\tstruct rcu_head\t\trcu;\t\t \n};\n\nstatic int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb);\n\nstatic const struct ppp_channel_ops pppol2tp_chan_ops = {\n\t.start_xmit =  pppol2tp_xmit,\n};\n\nstatic const struct proto_ops pppol2tp_ops;\n\n \nstatic struct sock *pppol2tp_session_get_sock(struct l2tp_session *session)\n{\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\tstruct sock *sk;\n\n\trcu_read_lock();\n\tsk = rcu_dereference(ps->sk);\n\tif (sk)\n\t\tsock_hold(sk);\n\trcu_read_unlock();\n\n\treturn sk;\n}\n\n \nstatic inline struct l2tp_session *pppol2tp_sock_to_session(struct sock *sk)\n{\n\tstruct l2tp_session *session;\n\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_hold(sk);\n\tsession = (struct l2tp_session *)(sk->sk_user_data);\n\tif (!session) {\n\t\tsock_put(sk);\n\t\tgoto out;\n\t}\n\tif (WARN_ON(session->magic != L2TP_SESSION_MAGIC)) {\n\t\tsession = NULL;\n\t\tsock_put(sk);\n\t\tgoto out;\n\t}\n\nout:\n\treturn session;\n}\n\n \n\n \nstatic int pppol2tp_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len, int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb)\n\t\tgoto end;\n\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\n\tkfree_skb(skb);\nend:\n\treturn err;\n}\n\nstatic void pppol2tp_recv(struct l2tp_session *session, struct sk_buff *skb, int data_len)\n{\n\tstruct pppol2tp_session *ps = l2tp_session_priv(session);\n\tstruct sock *sk = NULL;\n\n\t \n\trcu_read_lock();\n\tsk = rcu_dereference(ps->sk);\n\tif (!sk)\n\t\tgoto no_sock;\n\n\t \n\tif (pskb_may_pull(skb, 2) && skb->data[0] == PPP_ALLSTATIONS &&\n\t    skb->data[1] == PPP_UI)\n\t\tskb_pull(skb, 2);\n\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\tstruct pppox_sock *po;\n\n\t\tpo = pppox_sk(sk);\n\t\tppp_input(&po->chan, skb);\n\t} else {\n\t\tif (sock_queue_rcv_skb(sk, skb) < 0) {\n\t\t\tatomic_long_inc(&session->stats.rx_errors);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn;\n\nno_sock:\n\trcu_read_unlock();\n\tpr_warn_ratelimited(\"%s: no socket in recv\\n\", session->name);\n\tkfree_skb(skb);\n}\n\n \n\n \nstatic int pppol2tp_sendmsg(struct socket *sock, struct msghdr *m,\n\t\t\t    size_t total_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint uhlen;\n\n\terror = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_DEAD) || !(sk->sk_state & PPPOX_CONNECTED))\n\t\tgoto error;\n\n\t \n\terror = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (!session)\n\t\tgoto error;\n\n\ttunnel = session->tunnel;\n\n\tuhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\n\n\t \n\terror = -ENOMEM;\n\tskb = sock_wmalloc(sk, NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   uhlen + session->hdr_len +\n\t\t\t   2 + total_len,  \n\t\t\t   0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error_put_sess;\n\n\t \n\tskb_reserve(skb, NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\tskb_reserve(skb, uhlen);\n\n\t \n\tskb->data[0] = PPP_ALLSTATIONS;\n\tskb->data[1] = PPP_UI;\n\tskb_put(skb, 2);\n\n\t \n\terror = memcpy_from_msg(skb_put(skb, total_len), m, total_len);\n\tif (error < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error_put_sess;\n\t}\n\n\tlocal_bh_disable();\n\tl2tp_xmit_skb(session, skb);\n\tlocal_bh_enable();\n\n\tsock_put(sk);\n\n\treturn total_len;\n\nerror_put_sess:\n\tsock_put(sk);\nerror:\n\treturn error;\n}\n\n \nstatic int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb)\n{\n\tstruct sock *sk = (struct sock *)chan->private;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint uhlen, headroom;\n\n\tif (sock_flag(sk, SOCK_DEAD) || !(sk->sk_state & PPPOX_CONNECTED))\n\t\tgoto abort;\n\n\t \n\tsession = pppol2tp_sock_to_session(sk);\n\tif (!session)\n\t\tgoto abort;\n\n\ttunnel = session->tunnel;\n\n\tuhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\n\theadroom = NET_SKB_PAD +\n\t\t   sizeof(struct iphdr) +  \n\t\t   uhlen +\t\t \n\t\t   session->hdr_len +\t \n\t\t   2;\t\t\t \n\tif (skb_cow_head(skb, headroom))\n\t\tgoto abort_put_sess;\n\n\t \n\t__skb_push(skb, 2);\n\tskb->data[0] = PPP_ALLSTATIONS;\n\tskb->data[1] = PPP_UI;\n\n\tlocal_bh_disable();\n\tl2tp_xmit_skb(session, skb);\n\tlocal_bh_enable();\n\n\tsock_put(sk);\n\n\treturn 1;\n\nabort_put_sess:\n\tsock_put(sk);\nabort:\n\t \n\tkfree_skb(skb);\n\treturn 1;\n}\n\n \n\nstatic void pppol2tp_put_sk(struct rcu_head *head)\n{\n\tstruct pppol2tp_session *ps;\n\n\tps = container_of(head, typeof(*ps), rcu);\n\tsock_put(ps->__sk);\n}\n\n \nstatic void pppol2tp_session_destruct(struct sock *sk)\n{\n\tstruct l2tp_session *session = sk->sk_user_data;\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n\n\tif (session) {\n\t\tsk->sk_user_data = NULL;\n\t\tif (WARN_ON(session->magic != L2TP_SESSION_MAGIC))\n\t\t\treturn;\n\t\tl2tp_session_dec_refcount(session);\n\t}\n}\n\n \nstatic int pppol2tp_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tint error;\n\n\tif (!sk)\n\t\treturn 0;\n\n\terror = -EBADF;\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_DEAD) != 0)\n\t\tgoto error;\n\n\tpppox_unbind_sock(sk);\n\n\t \n\tsk->sk_state = PPPOX_DEAD;\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session) {\n\t\tstruct pppol2tp_session *ps;\n\n\t\tl2tp_session_delete(session);\n\n\t\tps = l2tp_session_priv(session);\n\t\tmutex_lock(&ps->sk_lock);\n\t\tps->__sk = rcu_dereference_protected(ps->sk,\n\t\t\t\t\t\t     lockdep_is_held(&ps->sk_lock));\n\t\tRCU_INIT_POINTER(ps->sk, NULL);\n\t\tmutex_unlock(&ps->sk_lock);\n\t\tcall_rcu(&ps->rcu, pppol2tp_put_sk);\n\n\t\t \n\t}\n\n\trelease_sock(sk);\n\n\t \n\tsock_put(sk);\n\n\treturn 0;\n\nerror:\n\trelease_sock(sk);\n\treturn error;\n}\n\nstatic struct proto pppol2tp_sk_proto = {\n\t.name\t  = \"PPPOL2TP\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct pppox_sock),\n};\n\nstatic int pppol2tp_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\trc = l2tp_udp_encap_recv(sk, skb);\n\tif (rc)\n\t\tkfree_skb(skb);\n\n\treturn NET_RX_SUCCESS;\n}\n\n \nstatic int pppol2tp_create(struct net *net, struct socket *sock, int kern)\n{\n\tint error = -ENOMEM;\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pppol2tp_sk_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_init_data(sock, sk);\n\n\tsock->state  = SS_UNCONNECTED;\n\tsock->ops    = &pppol2tp_ops;\n\n\tsk->sk_backlog_rcv = pppol2tp_backlog_recv;\n\tsk->sk_protocol\t   = PX_PROTO_OL2TP;\n\tsk->sk_family\t   = PF_PPPOX;\n\tsk->sk_state\t   = PPPOX_NONE;\n\tsk->sk_type\t   = SOCK_STREAM;\n\tsk->sk_destruct\t   = pppol2tp_session_destruct;\n\n\terror = 0;\n\nout:\n\treturn error;\n}\n\nstatic void pppol2tp_show(struct seq_file *m, void *arg)\n{\n\tstruct l2tp_session *session = arg;\n\tstruct sock *sk;\n\n\tsk = pppol2tp_session_get_sock(session);\n\tif (sk) {\n\t\tstruct pppox_sock *po = pppox_sk(sk);\n\n\t\tseq_printf(m, \"   interface %s\\n\", ppp_dev_name(&po->chan));\n\t\tsock_put(sk);\n\t}\n}\n\nstatic void pppol2tp_session_init(struct l2tp_session *session)\n{\n\tstruct pppol2tp_session *ps;\n\n\tsession->recv_skb = pppol2tp_recv;\n\tif (IS_ENABLED(CONFIG_L2TP_DEBUGFS))\n\t\tsession->show = pppol2tp_show;\n\n\tps = l2tp_session_priv(session);\n\tmutex_init(&ps->sk_lock);\n\tps->owner = current->pid;\n}\n\nstruct l2tp_connect_info {\n\tu8 version;\n\tint fd;\n\tu32 tunnel_id;\n\tu32 peer_tunnel_id;\n\tu32 session_id;\n\tu32 peer_session_id;\n};\n\nstatic int pppol2tp_sockaddr_get_info(const void *sa, int sa_len,\n\t\t\t\t      struct l2tp_connect_info *info)\n{\n\tswitch (sa_len) {\n\tcase sizeof(struct sockaddr_pppol2tp):\n\t{\n\t\tconst struct sockaddr_pppol2tp *sa_v2in4 = sa;\n\n\t\tif (sa_v2in4->sa_protocol != PX_PROTO_OL2TP)\n\t\t\treturn -EINVAL;\n\n\t\tinfo->version = 2;\n\t\tinfo->fd = sa_v2in4->pppol2tp.fd;\n\t\tinfo->tunnel_id = sa_v2in4->pppol2tp.s_tunnel;\n\t\tinfo->peer_tunnel_id = sa_v2in4->pppol2tp.d_tunnel;\n\t\tinfo->session_id = sa_v2in4->pppol2tp.s_session;\n\t\tinfo->peer_session_id = sa_v2in4->pppol2tp.d_session;\n\n\t\tbreak;\n\t}\n\tcase sizeof(struct sockaddr_pppol2tpv3):\n\t{\n\t\tconst struct sockaddr_pppol2tpv3 *sa_v3in4 = sa;\n\n\t\tif (sa_v3in4->sa_protocol != PX_PROTO_OL2TP)\n\t\t\treturn -EINVAL;\n\n\t\tinfo->version = 3;\n\t\tinfo->fd = sa_v3in4->pppol2tp.fd;\n\t\tinfo->tunnel_id = sa_v3in4->pppol2tp.s_tunnel;\n\t\tinfo->peer_tunnel_id = sa_v3in4->pppol2tp.d_tunnel;\n\t\tinfo->session_id = sa_v3in4->pppol2tp.s_session;\n\t\tinfo->peer_session_id = sa_v3in4->pppol2tp.d_session;\n\n\t\tbreak;\n\t}\n\tcase sizeof(struct sockaddr_pppol2tpin6):\n\t{\n\t\tconst struct sockaddr_pppol2tpin6 *sa_v2in6 = sa;\n\n\t\tif (sa_v2in6->sa_protocol != PX_PROTO_OL2TP)\n\t\t\treturn -EINVAL;\n\n\t\tinfo->version = 2;\n\t\tinfo->fd = sa_v2in6->pppol2tp.fd;\n\t\tinfo->tunnel_id = sa_v2in6->pppol2tp.s_tunnel;\n\t\tinfo->peer_tunnel_id = sa_v2in6->pppol2tp.d_tunnel;\n\t\tinfo->session_id = sa_v2in6->pppol2tp.s_session;\n\t\tinfo->peer_session_id = sa_v2in6->pppol2tp.d_session;\n\n\t\tbreak;\n\t}\n\tcase sizeof(struct sockaddr_pppol2tpv3in6):\n\t{\n\t\tconst struct sockaddr_pppol2tpv3in6 *sa_v3in6 = sa;\n\n\t\tif (sa_v3in6->sa_protocol != PX_PROTO_OL2TP)\n\t\t\treturn -EINVAL;\n\n\t\tinfo->version = 3;\n\t\tinfo->fd = sa_v3in6->pppol2tp.fd;\n\t\tinfo->tunnel_id = sa_v3in6->pppol2tp.s_tunnel;\n\t\tinfo->peer_tunnel_id = sa_v3in6->pppol2tp.d_tunnel;\n\t\tinfo->session_id = sa_v3in6->pppol2tp.s_session;\n\t\tinfo->peer_session_id = sa_v3in6->pppol2tp.d_session;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pppol2tp_tunnel_mtu(const struct l2tp_tunnel *tunnel)\n{\n\tint mtu;\n\n\tmtu = l2tp_tunnel_dst_mtu(tunnel);\n\tif (mtu <= PPPOL2TP_HEADER_OVERHEAD)\n\t\treturn 1500 - PPPOL2TP_HEADER_OVERHEAD;\n\n\treturn mtu - PPPOL2TP_HEADER_OVERHEAD;\n}\n\nstatic struct l2tp_tunnel *pppol2tp_tunnel_get(struct net *net,\n\t\t\t\t\t       const struct l2tp_connect_info *info,\n\t\t\t\t\t       bool *new_tunnel)\n{\n\tstruct l2tp_tunnel *tunnel;\n\tint error;\n\n\t*new_tunnel = false;\n\n\ttunnel = l2tp_tunnel_get(net, info->tunnel_id);\n\n\t \n\tif (!info->session_id && !info->peer_session_id) {\n\t\tif (!tunnel) {\n\t\t\tstruct l2tp_tunnel_cfg tcfg = {\n\t\t\t\t.encap = L2TP_ENCAPTYPE_UDP,\n\t\t\t};\n\n\t\t\t \n\t\t\tif (info->fd < 0)\n\t\t\t\treturn ERR_PTR(-EBADF);\n\n\t\t\terror = l2tp_tunnel_create(info->fd,\n\t\t\t\t\t\t   info->version,\n\t\t\t\t\t\t   info->tunnel_id,\n\t\t\t\t\t\t   info->peer_tunnel_id, &tcfg,\n\t\t\t\t\t\t   &tunnel);\n\t\t\tif (error < 0)\n\t\t\t\treturn ERR_PTR(error);\n\n\t\t\tl2tp_tunnel_inc_refcount(tunnel);\n\t\t\terror = l2tp_tunnel_register(tunnel, net, &tcfg);\n\t\t\tif (error < 0) {\n\t\t\t\tkfree(tunnel);\n\t\t\t\treturn ERR_PTR(error);\n\t\t\t}\n\n\t\t\t*new_tunnel = true;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!tunnel)\n\t\t\treturn ERR_PTR(-ENOENT);\n\n\t\t \n\t\tif (!tunnel->sock) {\n\t\t\tl2tp_tunnel_dec_refcount(tunnel);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t}\n\n\treturn tunnel;\n}\n\n \nstatic int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,\n\t\t\t    int sockaddr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct l2tp_session *session = NULL;\n\tstruct l2tp_connect_info info;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tstruct l2tp_session_cfg cfg = { 0, };\n\tbool drop_refcnt = false;\n\tbool new_session = false;\n\tbool new_tunnel = false;\n\tint error;\n\n\terror = pppol2tp_sockaddr_get_info(uservaddr, sockaddr_len, &info);\n\tif (error < 0)\n\t\treturn error;\n\n\t \n\tif (!info.tunnel_id)\n\t\treturn -EINVAL;\n\n\ttunnel = pppol2tp_tunnel_get(sock_net(sk), &info, &new_tunnel);\n\tif (IS_ERR(tunnel))\n\t\treturn PTR_ERR(tunnel);\n\n\tlock_sock(sk);\n\n\t \n\terror = -EBUSY;\n\tif (sk->sk_state & PPPOX_CONNECTED)\n\t\tgoto end;\n\n\t \n\terror = -EALREADY;\n\tif (sk->sk_user_data)\n\t\tgoto end;  \n\n\tif (tunnel->peer_tunnel_id == 0)\n\t\ttunnel->peer_tunnel_id = info.peer_tunnel_id;\n\n\tsession = l2tp_tunnel_get_session(tunnel, info.session_id);\n\tif (session) {\n\t\tdrop_refcnt = true;\n\n\t\tif (session->pwtype != L2TP_PWTYPE_PPP) {\n\t\t\terror = -EPROTOTYPE;\n\t\t\tgoto end;\n\t\t}\n\n\t\tps = l2tp_session_priv(session);\n\n\t\t \n\t\tmutex_lock(&ps->sk_lock);\n\t\tif (rcu_dereference_protected(ps->sk,\n\t\t\t\t\t      lockdep_is_held(&ps->sk_lock)) ||\n\t\t    ps->__sk) {\n\t\t\tmutex_unlock(&ps->sk_lock);\n\t\t\terror = -EEXIST;\n\t\t\tgoto end;\n\t\t}\n\t} else {\n\t\tcfg.pw_type = L2TP_PWTYPE_PPP;\n\n\t\tsession = l2tp_session_create(sizeof(struct pppol2tp_session),\n\t\t\t\t\t      tunnel, info.session_id,\n\t\t\t\t\t      info.peer_session_id, &cfg);\n\t\tif (IS_ERR(session)) {\n\t\t\terror = PTR_ERR(session);\n\t\t\tgoto end;\n\t\t}\n\n\t\tpppol2tp_session_init(session);\n\t\tps = l2tp_session_priv(session);\n\t\tl2tp_session_inc_refcount(session);\n\n\t\tmutex_lock(&ps->sk_lock);\n\t\terror = l2tp_session_register(session, tunnel);\n\t\tif (error < 0) {\n\t\t\tmutex_unlock(&ps->sk_lock);\n\t\t\tkfree(session);\n\t\t\tgoto end;\n\t\t}\n\t\tdrop_refcnt = true;\n\t\tnew_session = true;\n\t}\n\n\t \n\tif (session->session_id == 0 && session->peer_session_id == 0) {\n\t\terror = 0;\n\t\tgoto out_no_ppp;\n\t}\n\n\t \n\tpo->chan.hdrlen = PPPOL2TP_L2TP_HDR_SIZE_NOSEQ;\n\n\tpo->chan.private = sk;\n\tpo->chan.ops\t = &pppol2tp_chan_ops;\n\tpo->chan.mtu\t = pppol2tp_tunnel_mtu(tunnel);\n\n\terror = ppp_register_net_channel(sock_net(sk), &po->chan);\n\tif (error) {\n\t\tmutex_unlock(&ps->sk_lock);\n\t\tgoto end;\n\t}\n\nout_no_ppp:\n\t \n\tsk->sk_user_data = session;\n\trcu_assign_pointer(ps->sk, sk);\n\tmutex_unlock(&ps->sk_lock);\n\n\t \n\tdrop_refcnt = false;\n\n\tsk->sk_state = PPPOX_CONNECTED;\n\nend:\n\tif (error) {\n\t\tif (new_session)\n\t\t\tl2tp_session_delete(session);\n\t\tif (new_tunnel)\n\t\t\tl2tp_tunnel_delete(tunnel);\n\t}\n\tif (drop_refcnt)\n\t\tl2tp_session_dec_refcount(session);\n\tl2tp_tunnel_dec_refcount(tunnel);\n\trelease_sock(sk);\n\n\treturn error;\n}\n\n#ifdef CONFIG_L2TP_V3\n\n \nstatic int pppol2tp_session_create(struct net *net, struct l2tp_tunnel *tunnel,\n\t\t\t\t   u32 session_id, u32 peer_session_id,\n\t\t\t\t   struct l2tp_session_cfg *cfg)\n{\n\tint error;\n\tstruct l2tp_session *session;\n\n\t \n\tif (!tunnel->sock) {\n\t\terror = -ENOENT;\n\t\tgoto err;\n\t}\n\n\t \n\tsession = l2tp_session_create(sizeof(struct pppol2tp_session),\n\t\t\t\t      tunnel, session_id,\n\t\t\t\t      peer_session_id, cfg);\n\tif (IS_ERR(session)) {\n\t\terror = PTR_ERR(session);\n\t\tgoto err;\n\t}\n\n\tpppol2tp_session_init(session);\n\n\terror = l2tp_session_register(session, tunnel);\n\tif (error < 0)\n\t\tgoto err_sess;\n\n\treturn 0;\n\nerr_sess:\n\tkfree(session);\nerr:\n\treturn error;\n}\n\n#endif  \n\n \nstatic int pppol2tp_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int peer)\n{\n\tint len = 0;\n\tint error = 0;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct sock *sk = sock->sk;\n\tstruct inet_sock *inet;\n\tstruct pppol2tp_session *pls;\n\n\terror = -ENOTCONN;\n\tif (!sk)\n\t\tgoto end;\n\tif (!(sk->sk_state & PPPOX_CONNECTED))\n\t\tgoto end;\n\n\terror = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (!session)\n\t\tgoto end;\n\n\tpls = l2tp_session_priv(session);\n\ttunnel = session->tunnel;\n\n\tinet = inet_sk(tunnel->sock);\n\tif (tunnel->version == 2 && tunnel->sock->sk_family == AF_INET) {\n\t\tstruct sockaddr_pppol2tp sp;\n\n\t\tlen = sizeof(sp);\n\t\tmemset(&sp, 0, len);\n\t\tsp.sa_family\t= AF_PPPOX;\n\t\tsp.sa_protocol\t= PX_PROTO_OL2TP;\n\t\tsp.pppol2tp.fd  = tunnel->fd;\n\t\tsp.pppol2tp.pid = pls->owner;\n\t\tsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\n\t\tsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\n\t\tsp.pppol2tp.s_session = session->session_id;\n\t\tsp.pppol2tp.d_session = session->peer_session_id;\n\t\tsp.pppol2tp.addr.sin_family = AF_INET;\n\t\tsp.pppol2tp.addr.sin_port = inet->inet_dport;\n\t\tsp.pppol2tp.addr.sin_addr.s_addr = inet->inet_daddr;\n\t\tmemcpy(uaddr, &sp, len);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (tunnel->version == 2 && tunnel->sock->sk_family == AF_INET6) {\n\t\tstruct sockaddr_pppol2tpin6 sp;\n\n\t\tlen = sizeof(sp);\n\t\tmemset(&sp, 0, len);\n\t\tsp.sa_family\t= AF_PPPOX;\n\t\tsp.sa_protocol\t= PX_PROTO_OL2TP;\n\t\tsp.pppol2tp.fd  = tunnel->fd;\n\t\tsp.pppol2tp.pid = pls->owner;\n\t\tsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\n\t\tsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\n\t\tsp.pppol2tp.s_session = session->session_id;\n\t\tsp.pppol2tp.d_session = session->peer_session_id;\n\t\tsp.pppol2tp.addr.sin6_family = AF_INET6;\n\t\tsp.pppol2tp.addr.sin6_port = inet->inet_dport;\n\t\tmemcpy(&sp.pppol2tp.addr.sin6_addr, &tunnel->sock->sk_v6_daddr,\n\t\t       sizeof(tunnel->sock->sk_v6_daddr));\n\t\tmemcpy(uaddr, &sp, len);\n\t} else if (tunnel->version == 3 && tunnel->sock->sk_family == AF_INET6) {\n\t\tstruct sockaddr_pppol2tpv3in6 sp;\n\n\t\tlen = sizeof(sp);\n\t\tmemset(&sp, 0, len);\n\t\tsp.sa_family\t= AF_PPPOX;\n\t\tsp.sa_protocol\t= PX_PROTO_OL2TP;\n\t\tsp.pppol2tp.fd  = tunnel->fd;\n\t\tsp.pppol2tp.pid = pls->owner;\n\t\tsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\n\t\tsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\n\t\tsp.pppol2tp.s_session = session->session_id;\n\t\tsp.pppol2tp.d_session = session->peer_session_id;\n\t\tsp.pppol2tp.addr.sin6_family = AF_INET6;\n\t\tsp.pppol2tp.addr.sin6_port = inet->inet_dport;\n\t\tmemcpy(&sp.pppol2tp.addr.sin6_addr, &tunnel->sock->sk_v6_daddr,\n\t\t       sizeof(tunnel->sock->sk_v6_daddr));\n\t\tmemcpy(uaddr, &sp, len);\n#endif\n\t} else if (tunnel->version == 3) {\n\t\tstruct sockaddr_pppol2tpv3 sp;\n\n\t\tlen = sizeof(sp);\n\t\tmemset(&sp, 0, len);\n\t\tsp.sa_family\t= AF_PPPOX;\n\t\tsp.sa_protocol\t= PX_PROTO_OL2TP;\n\t\tsp.pppol2tp.fd  = tunnel->fd;\n\t\tsp.pppol2tp.pid = pls->owner;\n\t\tsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\n\t\tsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\n\t\tsp.pppol2tp.s_session = session->session_id;\n\t\tsp.pppol2tp.d_session = session->peer_session_id;\n\t\tsp.pppol2tp.addr.sin_family = AF_INET;\n\t\tsp.pppol2tp.addr.sin_port = inet->inet_dport;\n\t\tsp.pppol2tp.addr.sin_addr.s_addr = inet->inet_daddr;\n\t\tmemcpy(uaddr, &sp, len);\n\t}\n\n\terror = len;\n\n\tsock_put(sk);\nend:\n\treturn error;\n}\n\n \n\nstatic void pppol2tp_copy_stats(struct pppol2tp_ioc_stats *dest,\n\t\t\t\tconst struct l2tp_stats *stats)\n{\n\tmemset(dest, 0, sizeof(*dest));\n\n\tdest->tx_packets = atomic_long_read(&stats->tx_packets);\n\tdest->tx_bytes = atomic_long_read(&stats->tx_bytes);\n\tdest->tx_errors = atomic_long_read(&stats->tx_errors);\n\tdest->rx_packets = atomic_long_read(&stats->rx_packets);\n\tdest->rx_bytes = atomic_long_read(&stats->rx_bytes);\n\tdest->rx_seq_discards = atomic_long_read(&stats->rx_seq_discards);\n\tdest->rx_oos_packets = atomic_long_read(&stats->rx_oos_packets);\n\tdest->rx_errors = atomic_long_read(&stats->rx_errors);\n}\n\nstatic int pppol2tp_tunnel_copy_stats(struct pppol2tp_ioc_stats *stats,\n\t\t\t\t      struct l2tp_tunnel *tunnel)\n{\n\tstruct l2tp_session *session;\n\n\tif (!stats->session_id) {\n\t\tpppol2tp_copy_stats(stats, &tunnel->stats);\n\t\treturn 0;\n\t}\n\n\t \n\tsession = l2tp_tunnel_get_session(tunnel, stats->session_id);\n\tif (!session)\n\t\treturn -EBADR;\n\n\tif (session->pwtype != L2TP_PWTYPE_PPP) {\n\t\tl2tp_session_dec_refcount(session);\n\t\treturn -EBADR;\n\t}\n\n\tpppol2tp_copy_stats(stats, &session->stats);\n\tl2tp_session_dec_refcount(session);\n\n\treturn 0;\n}\n\nstatic int pppol2tp_ioctl(struct socket *sock, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct pppol2tp_ioc_stats stats;\n\tstruct l2tp_session *session;\n\n\tswitch (cmd) {\n\tcase PPPIOCGMRU:\n\tcase PPPIOCGFLAGS:\n\t\tsession = sock->sk->sk_user_data;\n\t\tif (!session)\n\t\t\treturn -ENOTCONN;\n\n\t\tif (WARN_ON(session->magic != L2TP_SESSION_MAGIC))\n\t\t\treturn -EBADF;\n\n\t\t \n\t\tif (!session->session_id && !session->peer_session_id)\n\t\t\treturn -ENOSYS;\n\n\t\tif (put_user(0, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase PPPIOCSMRU:\n\tcase PPPIOCSFLAGS:\n\t\tsession = sock->sk->sk_user_data;\n\t\tif (!session)\n\t\t\treturn -ENOTCONN;\n\n\t\tif (WARN_ON(session->magic != L2TP_SESSION_MAGIC))\n\t\t\treturn -EBADF;\n\n\t\t \n\t\tif (!session->session_id && !session->peer_session_id)\n\t\t\treturn -ENOSYS;\n\n\t\tif (!access_ok((int __user *)arg, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase PPPIOCGL2TPSTATS:\n\t\tsession = sock->sk->sk_user_data;\n\t\tif (!session)\n\t\t\treturn -ENOTCONN;\n\n\t\tif (WARN_ON(session->magic != L2TP_SESSION_MAGIC))\n\t\t\treturn -EBADF;\n\n\t\t \n\t\tif (!session->session_id && !session->peer_session_id) {\n\t\t\tu32 session_id;\n\t\t\tint err;\n\n\t\t\tif (copy_from_user(&stats, (void __user *)arg,\n\t\t\t\t\t   sizeof(stats)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tsession_id = stats.session_id;\n\t\t\terr = pppol2tp_tunnel_copy_stats(&stats,\n\t\t\t\t\t\t\t session->tunnel);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tstats.session_id = session_id;\n\t\t} else {\n\t\t\tpppol2tp_copy_stats(&stats, &session->stats);\n\t\t\tstats.session_id = session->session_id;\n\t\t}\n\t\tstats.tunnel_id = session->tunnel->tunnel_id;\n\t\tstats.using_ipsec = l2tp_tunnel_uses_xfrm(session->tunnel);\n\n\t\tif (copy_to_user((void __user *)arg, &stats, sizeof(stats)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic int pppol2tp_tunnel_setsockopt(struct sock *sk,\n\t\t\t\t      struct l2tp_tunnel *tunnel,\n\t\t\t\t      int optname, int val)\n{\n\tint err = 0;\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_DEBUG:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int pppol2tp_session_setsockopt(struct sock *sk,\n\t\t\t\t       struct l2tp_session *session,\n\t\t\t\t       int optname, int val)\n{\n\tint err = 0;\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_RECVSEQ:\n\t\tif (val != 0 && val != 1) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsession->recv_seq = !!val;\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_SENDSEQ:\n\t\tif (val != 0 && val != 1) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsession->send_seq = !!val;\n\t\t{\n\t\t\tstruct pppox_sock *po = pppox_sk(sk);\n\n\t\t\tpo->chan.hdrlen = val ? PPPOL2TP_L2TP_HDR_SIZE_SEQ :\n\t\t\t\tPPPOL2TP_L2TP_HDR_SIZE_NOSEQ;\n\t\t}\n\t\tl2tp_session_set_header_len(session, session->tunnel->version);\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_LNSMODE:\n\t\tif (val != 0 && val != 1) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsession->lns_mode = !!val;\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_DEBUG:\n\t\t \n\t\tbreak;\n\n\tcase PPPOL2TP_SO_REORDERTO:\n\t\tsession->reorder_timeout = msecs_to_jiffies(val);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int pppol2tp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val;\n\tint err;\n\n\tif (level != SOL_PPPOL2TP)\n\t\treturn -EINVAL;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&val, optval, sizeof(int)))\n\t\treturn -EFAULT;\n\n\terr = -ENOTCONN;\n\tif (!sk->sk_user_data)\n\t\tgoto end;\n\n\t \n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (!session)\n\t\tgoto end;\n\n\t \n\tif (session->session_id == 0 && session->peer_session_id == 0) {\n\t\ttunnel = session->tunnel;\n\t\terr = pppol2tp_tunnel_setsockopt(sk, tunnel, optname, val);\n\t} else {\n\t\terr = pppol2tp_session_setsockopt(sk, session, optname, val);\n\t}\n\n\tsock_put(sk);\nend:\n\treturn err;\n}\n\n \nstatic int pppol2tp_tunnel_getsockopt(struct sock *sk,\n\t\t\t\t      struct l2tp_tunnel *tunnel,\n\t\t\t\t      int optname, int *val)\n{\n\tint err = 0;\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_DEBUG:\n\t\t \n\t\t*val = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int pppol2tp_session_getsockopt(struct sock *sk,\n\t\t\t\t       struct l2tp_session *session,\n\t\t\t\t       int optname, int *val)\n{\n\tint err = 0;\n\n\tswitch (optname) {\n\tcase PPPOL2TP_SO_RECVSEQ:\n\t\t*val = session->recv_seq;\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_SENDSEQ:\n\t\t*val = session->send_seq;\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_LNSMODE:\n\t\t*val = session->lns_mode;\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_DEBUG:\n\t\t \n\t\t*val = 0;\n\t\tbreak;\n\n\tcase PPPOL2TP_SO_REORDERTO:\n\t\t*val = (int)jiffies_to_msecs(session->reorder_timeout);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t}\n\n\treturn err;\n}\n\n \nstatic int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val, len;\n\tint err;\n\n\tif (level != SOL_PPPOL2TP)\n\t\treturn -EINVAL;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\terr = -ENOTCONN;\n\tif (!sk->sk_user_data)\n\t\tgoto end;\n\n\t \n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (!session)\n\t\tgoto end;\n\n\t \n\tif (session->session_id == 0 && session->peer_session_id == 0) {\n\t\ttunnel = session->tunnel;\n\t\terr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\n\t\tif (err)\n\t\t\tgoto end_put_sess;\n\t} else {\n\t\terr = pppol2tp_session_getsockopt(sk, session, optname, &val);\n\t\tif (err)\n\t\t\tgoto end_put_sess;\n\t}\n\n\terr = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto end_put_sess;\n\n\tif (copy_to_user((void __user *)optval, &val, len))\n\t\tgoto end_put_sess;\n\n\terr = 0;\n\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}\n\n \n\nstatic unsigned int pppol2tp_net_id;\n\n#ifdef CONFIG_PROC_FS\n\nstruct pppol2tp_seq_data {\n\tstruct seq_net_private p;\n\tint tunnel_idx;\t\t\t \n\tint session_idx;\t\t \n\tstruct l2tp_tunnel *tunnel;\n\tstruct l2tp_session *session;\t \n};\n\nstatic void pppol2tp_next_tunnel(struct net *net, struct pppol2tp_seq_data *pd)\n{\n\t \n\tif (pd->tunnel)\n\t\tl2tp_tunnel_dec_refcount(pd->tunnel);\n\n\tfor (;;) {\n\t\tpd->tunnel = l2tp_tunnel_get_nth(net, pd->tunnel_idx);\n\t\tpd->tunnel_idx++;\n\n\t\t \n\t\tif (!pd->tunnel || pd->tunnel->version == 2)\n\t\t\treturn;\n\n\t\tl2tp_tunnel_dec_refcount(pd->tunnel);\n\t}\n}\n\nstatic void pppol2tp_next_session(struct net *net, struct pppol2tp_seq_data *pd)\n{\n\t \n\tif (pd->session)\n\t\tl2tp_session_dec_refcount(pd->session);\n\n\tpd->session = l2tp_session_get_nth(pd->tunnel, pd->session_idx);\n\tpd->session_idx++;\n\n\tif (!pd->session) {\n\t\tpd->session_idx = 0;\n\t\tpppol2tp_next_tunnel(net, pd);\n\t}\n}\n\nstatic void *pppol2tp_seq_start(struct seq_file *m, loff_t *offs)\n{\n\tstruct pppol2tp_seq_data *pd = SEQ_START_TOKEN;\n\tloff_t pos = *offs;\n\tstruct net *net;\n\n\tif (!pos)\n\t\tgoto out;\n\n\tif (WARN_ON(!m->private)) {\n\t\tpd = NULL;\n\t\tgoto out;\n\t}\n\n\tpd = m->private;\n\tnet = seq_file_net(m);\n\n\tif (!pd->tunnel)\n\t\tpppol2tp_next_tunnel(net, pd);\n\telse\n\t\tpppol2tp_next_session(net, pd);\n\n\t \n\tif (!pd->tunnel && !pd->session)\n\t\tpd = NULL;\n\nout:\n\treturn pd;\n}\n\nstatic void *pppol2tp_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn NULL;\n}\n\nstatic void pppol2tp_seq_stop(struct seq_file *p, void *v)\n{\n\tstruct pppol2tp_seq_data *pd = v;\n\n\tif (!pd || pd == SEQ_START_TOKEN)\n\t\treturn;\n\n\t \n\tif (pd->session) {\n\t\tl2tp_session_dec_refcount(pd->session);\n\t\tpd->session = NULL;\n\t}\n\tif (pd->tunnel) {\n\t\tl2tp_tunnel_dec_refcount(pd->tunnel);\n\t\tpd->tunnel = NULL;\n\t}\n}\n\nstatic void pppol2tp_seq_tunnel_show(struct seq_file *m, void *v)\n{\n\tstruct l2tp_tunnel *tunnel = v;\n\n\tseq_printf(m, \"\\nTUNNEL '%s', %c %d\\n\",\n\t\t   tunnel->name,\n\t\t   (tunnel == tunnel->sock->sk_user_data) ? 'Y' : 'N',\n\t\t   refcount_read(&tunnel->ref_count) - 1);\n\tseq_printf(m, \" %08x %ld/%ld/%ld %ld/%ld/%ld\\n\",\n\t\t   0,\n\t\t   atomic_long_read(&tunnel->stats.tx_packets),\n\t\t   atomic_long_read(&tunnel->stats.tx_bytes),\n\t\t   atomic_long_read(&tunnel->stats.tx_errors),\n\t\t   atomic_long_read(&tunnel->stats.rx_packets),\n\t\t   atomic_long_read(&tunnel->stats.rx_bytes),\n\t\t   atomic_long_read(&tunnel->stats.rx_errors));\n}\n\nstatic void pppol2tp_seq_session_show(struct seq_file *m, void *v)\n{\n\tstruct l2tp_session *session = v;\n\tstruct l2tp_tunnel *tunnel = session->tunnel;\n\tunsigned char state;\n\tchar user_data_ok;\n\tstruct sock *sk;\n\tu32 ip = 0;\n\tu16 port = 0;\n\n\tif (tunnel->sock) {\n\t\tstruct inet_sock *inet = inet_sk(tunnel->sock);\n\n\t\tip = ntohl(inet->inet_saddr);\n\t\tport = ntohs(inet->inet_sport);\n\t}\n\n\tsk = pppol2tp_session_get_sock(session);\n\tif (sk) {\n\t\tstate = sk->sk_state;\n\t\tuser_data_ok = (session == sk->sk_user_data) ? 'Y' : 'N';\n\t} else {\n\t\tstate = 0;\n\t\tuser_data_ok = 'N';\n\t}\n\n\tseq_printf(m, \"  SESSION '%s' %08X/%d %04X/%04X -> %04X/%04X %d %c\\n\",\n\t\t   session->name, ip, port,\n\t\t   tunnel->tunnel_id,\n\t\t   session->session_id,\n\t\t   tunnel->peer_tunnel_id,\n\t\t   session->peer_session_id,\n\t\t   state, user_data_ok);\n\tseq_printf(m, \"   0/0/%c/%c/%s %08x %u\\n\",\n\t\t   session->recv_seq ? 'R' : '-',\n\t\t   session->send_seq ? 'S' : '-',\n\t\t   session->lns_mode ? \"LNS\" : \"LAC\",\n\t\t   0,\n\t\t   jiffies_to_msecs(session->reorder_timeout));\n\tseq_printf(m, \"   %u/%u %ld/%ld/%ld %ld/%ld/%ld\\n\",\n\t\t   session->nr, session->ns,\n\t\t   atomic_long_read(&session->stats.tx_packets),\n\t\t   atomic_long_read(&session->stats.tx_bytes),\n\t\t   atomic_long_read(&session->stats.tx_errors),\n\t\t   atomic_long_read(&session->stats.rx_packets),\n\t\t   atomic_long_read(&session->stats.rx_bytes),\n\t\t   atomic_long_read(&session->stats.rx_errors));\n\n\tif (sk) {\n\t\tstruct pppox_sock *po = pppox_sk(sk);\n\n\t\tseq_printf(m, \"   interface %s\\n\", ppp_dev_name(&po->chan));\n\t\tsock_put(sk);\n\t}\n}\n\nstatic int pppol2tp_seq_show(struct seq_file *m, void *v)\n{\n\tstruct pppol2tp_seq_data *pd = v;\n\n\t \n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"PPPoL2TP driver info, \" PPPOL2TP_DRV_VERSION \"\\n\");\n\t\tseq_puts(m, \"TUNNEL name, user-data-ok session-count\\n\");\n\t\tseq_puts(m, \" debug tx-pkts/bytes/errs rx-pkts/bytes/errs\\n\");\n\t\tseq_puts(m, \"  SESSION name, addr/port src-tid/sid dest-tid/sid state user-data-ok\\n\");\n\t\tseq_puts(m, \"   mtu/mru/rcvseq/sendseq/lns debug reorderto\\n\");\n\t\tseq_puts(m, \"   nr/ns tx-pkts/bytes/errs rx-pkts/bytes/errs\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!pd->session)\n\t\tpppol2tp_seq_tunnel_show(m, pd->tunnel);\n\telse\n\t\tpppol2tp_seq_session_show(m, pd->session);\n\nout:\n\treturn 0;\n}\n\nstatic const struct seq_operations pppol2tp_seq_ops = {\n\t.start\t\t= pppol2tp_seq_start,\n\t.next\t\t= pppol2tp_seq_next,\n\t.stop\t\t= pppol2tp_seq_stop,\n\t.show\t\t= pppol2tp_seq_show,\n};\n#endif  \n\n \n\nstatic __net_init int pppol2tp_init_net(struct net *net)\n{\n\tstruct proc_dir_entry *pde;\n\tint err = 0;\n\n\tpde = proc_create_net(\"pppol2tp\", 0444, net->proc_net,\n\t\t\t      &pppol2tp_seq_ops, sizeof(struct pppol2tp_seq_data));\n\tif (!pde) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic __net_exit void pppol2tp_exit_net(struct net *net)\n{\n\tremove_proc_entry(\"pppol2tp\", net->proc_net);\n}\n\nstatic struct pernet_operations pppol2tp_net_ops = {\n\t.init = pppol2tp_init_net,\n\t.exit = pppol2tp_exit_net,\n\t.id   = &pppol2tp_net_id,\n};\n\n \n\nstatic const struct proto_ops pppol2tp_ops = {\n\t.family\t\t= AF_PPPOX,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= pppol2tp_release,\n\t.bind\t\t= sock_no_bind,\n\t.connect\t= pppol2tp_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.getname\t= pppol2tp_getname,\n\t.poll\t\t= datagram_poll,\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= sock_no_shutdown,\n\t.setsockopt\t= pppol2tp_setsockopt,\n\t.getsockopt\t= pppol2tp_getsockopt,\n\t.sendmsg\t= pppol2tp_sendmsg,\n\t.recvmsg\t= pppol2tp_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n\t.ioctl\t\t= pppox_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = pppox_compat_ioctl,\n#endif\n};\n\nstatic const struct pppox_proto pppol2tp_proto = {\n\t.create\t\t= pppol2tp_create,\n\t.ioctl\t\t= pppol2tp_ioctl,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_L2TP_V3\n\nstatic const struct l2tp_nl_cmd_ops pppol2tp_nl_cmd_ops = {\n\t.session_create\t= pppol2tp_session_create,\n\t.session_delete\t= l2tp_session_delete,\n};\n\n#endif  \n\nstatic int __init pppol2tp_init(void)\n{\n\tint err;\n\n\terr = register_pernet_device(&pppol2tp_net_ops);\n\tif (err)\n\t\tgoto out;\n\n\terr = proto_register(&pppol2tp_sk_proto, 0);\n\tif (err)\n\t\tgoto out_unregister_pppol2tp_pernet;\n\n\terr = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);\n\tif (err)\n\t\tgoto out_unregister_pppol2tp_proto;\n\n#ifdef CONFIG_L2TP_V3\n\terr = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);\n\tif (err)\n\t\tgoto out_unregister_pppox;\n#endif\n\n\tpr_info(\"PPPoL2TP kernel driver, %s\\n\", PPPOL2TP_DRV_VERSION);\n\nout:\n\treturn err;\n\n#ifdef CONFIG_L2TP_V3\nout_unregister_pppox:\n\tunregister_pppox_proto(PX_PROTO_OL2TP);\n#endif\nout_unregister_pppol2tp_proto:\n\tproto_unregister(&pppol2tp_sk_proto);\nout_unregister_pppol2tp_pernet:\n\tunregister_pernet_device(&pppol2tp_net_ops);\n\tgoto out;\n}\n\nstatic void __exit pppol2tp_exit(void)\n{\n#ifdef CONFIG_L2TP_V3\n\tl2tp_nl_unregister_ops(L2TP_PWTYPE_PPP);\n#endif\n\tunregister_pppox_proto(PX_PROTO_OL2TP);\n\tproto_unregister(&pppol2tp_sk_proto);\n\tunregister_pernet_device(&pppol2tp_net_ops);\n}\n\nmodule_init(pppol2tp_init);\nmodule_exit(pppol2tp_exit);\n\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"PPP over L2TP over UDP\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(PPPOL2TP_DRV_VERSION);\nMODULE_ALIAS_NET_PF_PROTO(PF_PPPOX, PX_PROTO_OL2TP);\nMODULE_ALIAS_L2TP_PWTYPE(7);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}