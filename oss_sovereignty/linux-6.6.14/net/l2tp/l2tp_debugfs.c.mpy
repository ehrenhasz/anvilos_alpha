{
  "module_name": "l2tp_debugfs.c",
  "hash_id": "7c04b89bbfa10abf668c9d8810afdbe5c51141ef5d4e8b25b6dd00c2feb07d1b",
  "original_prompt": "Ingested from linux-6.6.14/net/l2tp/l2tp_debugfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/hash.h>\n#include <linux/l2tp.h>\n#include <linux/in.h>\n#include <linux/etherdevice.h>\n#include <linux/spinlock.h>\n#include <linux/debugfs.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/tcp_states.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n#include \"l2tp_core.h\"\n\nstatic struct dentry *rootdir;\n\nstruct l2tp_dfs_seq_data {\n\tstruct net\t*net;\n\tnetns_tracker\tns_tracker;\n\tint tunnel_idx;\t\t\t \n\tint session_idx;\t\t \n\tstruct l2tp_tunnel *tunnel;\n\tstruct l2tp_session *session;\t \n};\n\nstatic void l2tp_dfs_next_tunnel(struct l2tp_dfs_seq_data *pd)\n{\n\t \n\tif (pd->tunnel)\n\t\tl2tp_tunnel_dec_refcount(pd->tunnel);\n\n\tpd->tunnel = l2tp_tunnel_get_nth(pd->net, pd->tunnel_idx);\n\tpd->tunnel_idx++;\n}\n\nstatic void l2tp_dfs_next_session(struct l2tp_dfs_seq_data *pd)\n{\n\t \n\tif (pd->session)\n\t\tl2tp_session_dec_refcount(pd->session);\n\n\tpd->session = l2tp_session_get_nth(pd->tunnel, pd->session_idx);\n\tpd->session_idx++;\n\n\tif (!pd->session) {\n\t\tpd->session_idx = 0;\n\t\tl2tp_dfs_next_tunnel(pd);\n\t}\n}\n\nstatic void *l2tp_dfs_seq_start(struct seq_file *m, loff_t *offs)\n{\n\tstruct l2tp_dfs_seq_data *pd = SEQ_START_TOKEN;\n\tloff_t pos = *offs;\n\n\tif (!pos)\n\t\tgoto out;\n\n\tif (WARN_ON(!m->private)) {\n\t\tpd = NULL;\n\t\tgoto out;\n\t}\n\tpd = m->private;\n\n\tif (!pd->tunnel)\n\t\tl2tp_dfs_next_tunnel(pd);\n\telse\n\t\tl2tp_dfs_next_session(pd);\n\n\t \n\tif (!pd->tunnel && !pd->session)\n\t\tpd = NULL;\n\nout:\n\treturn pd;\n}\n\nstatic void *l2tp_dfs_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn NULL;\n}\n\nstatic void l2tp_dfs_seq_stop(struct seq_file *p, void *v)\n{\n\tstruct l2tp_dfs_seq_data *pd = v;\n\n\tif (!pd || pd == SEQ_START_TOKEN)\n\t\treturn;\n\n\t \n\tif (pd->session) {\n\t\tl2tp_session_dec_refcount(pd->session);\n\t\tpd->session = NULL;\n\t}\n\tif (pd->tunnel) {\n\t\tl2tp_tunnel_dec_refcount(pd->tunnel);\n\t\tpd->tunnel = NULL;\n\t}\n}\n\nstatic void l2tp_dfs_seq_tunnel_show(struct seq_file *m, void *v)\n{\n\tstruct l2tp_tunnel *tunnel = v;\n\tstruct l2tp_session *session;\n\tint session_count = 0;\n\tint hash;\n\n\trcu_read_lock_bh();\n\tfor (hash = 0; hash < L2TP_HASH_SIZE; hash++) {\n\t\thlist_for_each_entry_rcu(session, &tunnel->session_hlist[hash], hlist) {\n\t\t\t \n\t\t\tif (session->session_id == 0)\n\t\t\t\tcontinue;\n\n\t\t\tsession_count++;\n\t\t}\n\t}\n\trcu_read_unlock_bh();\n\n\tseq_printf(m, \"\\nTUNNEL %u peer %u\", tunnel->tunnel_id, tunnel->peer_tunnel_id);\n\tif (tunnel->sock) {\n\t\tstruct inet_sock *inet = inet_sk(tunnel->sock);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (tunnel->sock->sk_family == AF_INET6) {\n\t\t\tconst struct ipv6_pinfo *np = inet6_sk(tunnel->sock);\n\n\t\t\tseq_printf(m, \" from %pI6c to %pI6c\\n\",\n\t\t\t\t   &np->saddr, &tunnel->sock->sk_v6_daddr);\n\t\t}\n#endif\n\t\tif (tunnel->sock->sk_family == AF_INET)\n\t\t\tseq_printf(m, \" from %pI4 to %pI4\\n\",\n\t\t\t\t   &inet->inet_saddr, &inet->inet_daddr);\n\n\t\tif (tunnel->encap == L2TP_ENCAPTYPE_UDP)\n\t\t\tseq_printf(m, \" source port %hu, dest port %hu\\n\",\n\t\t\t\t   ntohs(inet->inet_sport), ntohs(inet->inet_dport));\n\t}\n\tseq_printf(m, \" L2TPv%d, %s\\n\", tunnel->version,\n\t\t   tunnel->encap == L2TP_ENCAPTYPE_UDP ? \"UDP\" :\n\t\t   tunnel->encap == L2TP_ENCAPTYPE_IP ? \"IP\" :\n\t\t   \"\");\n\tseq_printf(m, \" %d sessions, refcnt %d/%d\\n\", session_count,\n\t\t   tunnel->sock ? refcount_read(&tunnel->sock->sk_refcnt) : 0,\n\t\t   refcount_read(&tunnel->ref_count));\n\tseq_printf(m, \" %08x rx %ld/%ld/%ld rx %ld/%ld/%ld\\n\",\n\t\t   0,\n\t\t   atomic_long_read(&tunnel->stats.tx_packets),\n\t\t   atomic_long_read(&tunnel->stats.tx_bytes),\n\t\t   atomic_long_read(&tunnel->stats.tx_errors),\n\t\t   atomic_long_read(&tunnel->stats.rx_packets),\n\t\t   atomic_long_read(&tunnel->stats.rx_bytes),\n\t\t   atomic_long_read(&tunnel->stats.rx_errors));\n}\n\nstatic void l2tp_dfs_seq_session_show(struct seq_file *m, void *v)\n{\n\tstruct l2tp_session *session = v;\n\n\tseq_printf(m, \"  SESSION %u, peer %u, %s\\n\", session->session_id,\n\t\t   session->peer_session_id,\n\t\t   session->pwtype == L2TP_PWTYPE_ETH ? \"ETH\" :\n\t\t   session->pwtype == L2TP_PWTYPE_PPP ? \"PPP\" :\n\t\t   \"\");\n\tif (session->send_seq || session->recv_seq)\n\t\tseq_printf(m, \"   nr %u, ns %u\\n\", session->nr, session->ns);\n\tseq_printf(m, \"   refcnt %d\\n\", refcount_read(&session->ref_count));\n\tseq_printf(m, \"   config 0/0/%c/%c/-/%s %08x %u\\n\",\n\t\t   session->recv_seq ? 'R' : '-',\n\t\t   session->send_seq ? 'S' : '-',\n\t\t   session->lns_mode ? \"LNS\" : \"LAC\",\n\t\t   0,\n\t\t   jiffies_to_msecs(session->reorder_timeout));\n\tseq_printf(m, \"   offset 0 l2specific %hu/%d\\n\",\n\t\t   session->l2specific_type, l2tp_get_l2specific_len(session));\n\tif (session->cookie_len) {\n\t\tseq_printf(m, \"   cookie %02x%02x%02x%02x\",\n\t\t\t   session->cookie[0], session->cookie[1],\n\t\t\t   session->cookie[2], session->cookie[3]);\n\t\tif (session->cookie_len == 8)\n\t\t\tseq_printf(m, \"%02x%02x%02x%02x\",\n\t\t\t\t   session->cookie[4], session->cookie[5],\n\t\t\t\t   session->cookie[6], session->cookie[7]);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\tif (session->peer_cookie_len) {\n\t\tseq_printf(m, \"   peer cookie %02x%02x%02x%02x\",\n\t\t\t   session->peer_cookie[0], session->peer_cookie[1],\n\t\t\t   session->peer_cookie[2], session->peer_cookie[3]);\n\t\tif (session->peer_cookie_len == 8)\n\t\t\tseq_printf(m, \"%02x%02x%02x%02x\",\n\t\t\t\t   session->peer_cookie[4], session->peer_cookie[5],\n\t\t\t\t   session->peer_cookie[6], session->peer_cookie[7]);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tseq_printf(m, \"   %u/%u tx %ld/%ld/%ld rx %ld/%ld/%ld\\n\",\n\t\t   session->nr, session->ns,\n\t\t   atomic_long_read(&session->stats.tx_packets),\n\t\t   atomic_long_read(&session->stats.tx_bytes),\n\t\t   atomic_long_read(&session->stats.tx_errors),\n\t\t   atomic_long_read(&session->stats.rx_packets),\n\t\t   atomic_long_read(&session->stats.rx_bytes),\n\t\t   atomic_long_read(&session->stats.rx_errors));\n\n\tif (session->show)\n\t\tsession->show(m, session);\n}\n\nstatic int l2tp_dfs_seq_show(struct seq_file *m, void *v)\n{\n\tstruct l2tp_dfs_seq_data *pd = v;\n\n\t \n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"TUNNEL ID, peer ID from IP to IP\\n\");\n\t\tseq_puts(m, \" L2TPv2/L2TPv3, UDP/IP\\n\");\n\t\tseq_puts(m, \" sessions session-count, refcnt refcnt/sk->refcnt\\n\");\n\t\tseq_puts(m, \" debug tx-pkts/bytes/errs rx-pkts/bytes/errs\\n\");\n\t\tseq_puts(m, \"  SESSION ID, peer ID, PWTYPE\\n\");\n\t\tseq_puts(m, \"   refcnt cnt\\n\");\n\t\tseq_puts(m, \"   offset OFFSET l2specific TYPE/LEN\\n\");\n\t\tseq_puts(m, \"   [ cookie ]\\n\");\n\t\tseq_puts(m, \"   [ peer cookie ]\\n\");\n\t\tseq_puts(m, \"   config mtu/mru/rcvseq/sendseq/dataseq/lns debug reorderto\\n\");\n\t\tseq_puts(m, \"   nr/ns tx-pkts/bytes/errs rx-pkts/bytes/errs\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!pd->session)\n\t\tl2tp_dfs_seq_tunnel_show(m, pd->tunnel);\n\telse\n\t\tl2tp_dfs_seq_session_show(m, pd->session);\n\nout:\n\treturn 0;\n}\n\nstatic const struct seq_operations l2tp_dfs_seq_ops = {\n\t.start\t\t= l2tp_dfs_seq_start,\n\t.next\t\t= l2tp_dfs_seq_next,\n\t.stop\t\t= l2tp_dfs_seq_stop,\n\t.show\t\t= l2tp_dfs_seq_show,\n};\n\nstatic int l2tp_dfs_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct l2tp_dfs_seq_data *pd;\n\tstruct seq_file *seq;\n\tint rc = -ENOMEM;\n\n\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\tgoto out;\n\n\t \n\tpd->net = get_net_ns_by_pid(current->pid);\n\tif (IS_ERR(pd->net)) {\n\t\trc = PTR_ERR(pd->net);\n\t\tgoto err_free_pd;\n\t}\n\tnetns_tracker_alloc(pd->net, &pd->ns_tracker, GFP_KERNEL);\n\trc = seq_open(file, &l2tp_dfs_seq_ops);\n\tif (rc)\n\t\tgoto err_free_net;\n\n\tseq = file->private_data;\n\tseq->private = pd;\n\nout:\n\treturn rc;\n\nerr_free_net:\n\tput_net_track(pd->net, &pd->ns_tracker);\nerr_free_pd:\n\tkfree(pd);\n\tgoto out;\n}\n\nstatic int l2tp_dfs_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct l2tp_dfs_seq_data *pd;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\tpd = seq->private;\n\tif (pd->net)\n\t\tput_net_track(pd->net, &pd->ns_tracker);\n\tkfree(pd);\n\tseq_release(inode, file);\n\n\treturn 0;\n}\n\nstatic const struct file_operations l2tp_dfs_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= l2tp_dfs_seq_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= l2tp_dfs_seq_release,\n};\n\nstatic int __init l2tp_debugfs_init(void)\n{\n\trootdir = debugfs_create_dir(\"l2tp\", NULL);\n\n\tdebugfs_create_file(\"tunnels\", 0600, rootdir, NULL, &l2tp_dfs_fops);\n\n\tpr_info(\"L2TP debugfs support\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit l2tp_debugfs_exit(void)\n{\n\tdebugfs_remove_recursive(rootdir);\n}\n\nmodule_init(l2tp_debugfs_init);\nmodule_exit(l2tp_debugfs_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP debugfs driver\");\nMODULE_VERSION(\"1.0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}