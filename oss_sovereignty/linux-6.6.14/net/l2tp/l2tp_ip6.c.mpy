{
  "module_name": "l2tp_ip6.c",
  "hash_id": "5ff51edd6e3ddba1d6234f5b3eea47be28bddbe75a1a3a797d4100bd78edef8f",
  "original_prompt": "Ingested from linux-6.6.14/net/l2tp/l2tp_ip6.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/icmp.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/random.h>\n#include <linux/socket.h>\n#include <linux/l2tp.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/tcp_states.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n\n#include \"l2tp_core.h\"\n\nstruct l2tp_ip6_sock {\n\t \n\tstruct inet_sock\tinet;\n\n\tu32\t\t\tconn_id;\n\tu32\t\t\tpeer_conn_id;\n\n\tstruct ipv6_pinfo\tinet6;\n};\n\nstatic DEFINE_RWLOCK(l2tp_ip6_lock);\nstatic struct hlist_head l2tp_ip6_table;\nstatic struct hlist_head l2tp_ip6_bind_table;\n\nstatic inline struct l2tp_ip6_sock *l2tp_ip6_sk(const struct sock *sk)\n{\n\treturn (struct l2tp_ip6_sock *)sk;\n}\n\nstatic struct sock *__l2tp_ip6_bind_lookup(const struct net *net,\n\t\t\t\t\t   const struct in6_addr *laddr,\n\t\t\t\t\t   const struct in6_addr *raddr,\n\t\t\t\t\t   int dif, u32 tunnel_id)\n{\n\tstruct sock *sk;\n\n\tsk_for_each_bound(sk, &l2tp_ip6_bind_table) {\n\t\tconst struct in6_addr *sk_laddr = inet6_rcv_saddr(sk);\n\t\tconst struct in6_addr *sk_raddr = &sk->sk_v6_daddr;\n\t\tconst struct l2tp_ip6_sock *l2tp = l2tp_ip6_sk(sk);\n\t\tint bound_dev_if;\n\n\t\tif (!net_eq(sock_net(sk), net))\n\t\t\tcontinue;\n\n\t\tbound_dev_if = READ_ONCE(sk->sk_bound_dev_if);\n\t\tif (bound_dev_if && dif && bound_dev_if != dif)\n\t\t\tcontinue;\n\n\t\tif (sk_laddr && !ipv6_addr_any(sk_laddr) &&\n\t\t    !ipv6_addr_any(laddr) && !ipv6_addr_equal(sk_laddr, laddr))\n\t\t\tcontinue;\n\n\t\tif (!ipv6_addr_any(sk_raddr) && raddr &&\n\t\t    !ipv6_addr_any(raddr) && !ipv6_addr_equal(sk_raddr, raddr))\n\t\t\tcontinue;\n\n\t\tif (l2tp->conn_id != tunnel_id)\n\t\t\tcontinue;\n\n\t\tgoto found;\n\t}\n\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\n \nstatic int l2tp_ip6_recv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tu32 session_id;\n\tu32 tunnel_id;\n\tunsigned char *ptr, *optr;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel = NULL;\n\tstruct ipv6hdr *iph;\n\n\tif (!pskb_may_pull(skb, 4))\n\t\tgoto discard;\n\n\t \n\toptr = skb->data;\n\tptr = skb->data;\n\tsession_id = ntohl(*((__be32 *)ptr));\n\tptr += 4;\n\n\t \n\tif (session_id == 0) {\n\t\t__skb_pull(skb, 4);\n\t\tgoto pass_up;\n\t}\n\n\t \n\tsession = l2tp_session_get(net, session_id);\n\tif (!session)\n\t\tgoto discard;\n\n\ttunnel = session->tunnel;\n\tif (!tunnel)\n\t\tgoto discard_sess;\n\n\tif (l2tp_v3_ensure_opt_in_linear(session, skb, &ptr, &optr))\n\t\tgoto discard_sess;\n\n\tl2tp_recv_common(session, skb, ptr, optr, 0, skb->len);\n\tl2tp_session_dec_refcount(session);\n\n\treturn 0;\n\npass_up:\n\t \n\tif (!pskb_may_pull(skb, 12))\n\t\tgoto discard;\n\n\tif ((skb->data[0] & 0xc0) != 0xc0)\n\t\tgoto discard;\n\n\ttunnel_id = ntohl(*(__be32 *)&skb->data[4]);\n\tiph = ipv6_hdr(skb);\n\n\tread_lock_bh(&l2tp_ip6_lock);\n\tsk = __l2tp_ip6_bind_lookup(net, &iph->daddr, &iph->saddr,\n\t\t\t\t    inet6_iif(skb), tunnel_id);\n\tif (!sk) {\n\t\tread_unlock_bh(&l2tp_ip6_lock);\n\t\tgoto discard;\n\t}\n\tsock_hold(sk);\n\tread_unlock_bh(&l2tp_ip6_lock);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_put;\n\n\tnf_reset_ct(skb);\n\n\treturn sk_receive_skb(sk, skb, 1);\n\ndiscard_sess:\n\tl2tp_session_dec_refcount(session);\n\tgoto discard;\n\ndiscard_put:\n\tsock_put(sk);\n\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int l2tp_ip6_hash(struct sock *sk)\n{\n\tif (sk_unhashed(sk)) {\n\t\twrite_lock_bh(&l2tp_ip6_lock);\n\t\tsk_add_node(sk, &l2tp_ip6_table);\n\t\twrite_unlock_bh(&l2tp_ip6_lock);\n\t}\n\treturn 0;\n}\n\nstatic void l2tp_ip6_unhash(struct sock *sk)\n{\n\tif (sk_unhashed(sk))\n\t\treturn;\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n}\n\nstatic int l2tp_ip6_open(struct sock *sk)\n{\n\t \n\tinet_sk(sk)->inet_num = IPPROTO_L2TP;\n\n\tl2tp_ip6_hash(sk);\n\treturn 0;\n}\n\nstatic void l2tp_ip6_close(struct sock *sk, long timeout)\n{\n\twrite_lock_bh(&l2tp_ip6_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsk_common_release(sk);\n}\n\nstatic void l2tp_ip6_destroy_sock(struct sock *sk)\n{\n\tstruct l2tp_tunnel *tunnel = l2tp_sk_to_tunnel(sk);\n\n\tlock_sock(sk);\n\tip6_flush_pending_frames(sk);\n\trelease_sock(sk);\n\n\tif (tunnel)\n\t\tl2tp_tunnel_delete(tunnel);\n}\n\nstatic int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n\tint bound_dev_if;\n\tint addr_type;\n\tint err;\n\n\tif (addr->l2tp_family != AF_INET6)\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(*addr))\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->l2tp_addr);\n\n\t \n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EADDRNOTAVAIL;\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out_unlock;\n\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out_unlock;\n\n\tbound_dev_if = sk->sk_bound_dev_if;\n\n\t \n\trcu_read_lock();\n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (addr->l2tp_scope_id)\n\t\t\t\tbound_dev_if = addr->l2tp_scope_id;\n\n\t\t\t \n\t\t\tif (!bound_dev_if)\n\t\t\t\tgoto out_unlock_rcu;\n\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk), bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock_rcu;\n\t\t}\n\n\t\t \n\t\tv4addr = LOOPBACK4_IPV6;\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))\n\t\t\tgoto out_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\tif (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr, NULL, bound_dev_if,\n\t\t\t\t   addr->l2tp_conn_id)) {\n\t\twrite_unlock_bh(&l2tp_ip6_lock);\n\t\terr = -EADDRINUSE;\n\t\tgoto out_unlock;\n\t}\n\n\tinet->inet_saddr = v4addr;\n\tinet->inet_rcv_saddr = v4addr;\n\tsk->sk_bound_dev_if = bound_dev_if;\n\tsk->sk_v6_rcv_saddr = addr->l2tp_addr;\n\tnp->saddr = addr->l2tp_addr;\n\n\tl2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trelease_sock(sk);\n\treturn 0;\n\nout_unlock_rcu:\n\trcu_read_unlock();\nout_unlock:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int l2tp_ip6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t    int addr_len)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sockaddr_in6\t*usin = (struct sockaddr_in6 *)uaddr;\n\tstruct in6_addr\t*daddr;\n\tint\taddr_type;\n\tint rc;\n\n\tif (addr_len < sizeof(*lsa))\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EINVAL;\n\n\tif (addr_type & IPV6_ADDR_MAPPED) {\n\t\tdaddr = &usin->sin6_addr;\n\t\tif (ipv4_is_multicast(daddr->s6_addr32[3]))\n\t\t\treturn -EINVAL;\n\t}\n\n\tlock_sock(sk);\n\n\t  \n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\trc = -EINVAL;\n\t\tgoto out_sk;\n\t}\n\n\trc = __ip6_datagram_connect(sk, uaddr, addr_len);\n\tif (rc < 0)\n\t\tgoto out_sk;\n\n\tl2tp_ip6_sk(sk)->peer_conn_id = lsa->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\nout_sk:\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int l2tp_ip6_disconnect(struct sock *sk, int flags)\n{\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn 0;\n\n\treturn __udp_disconnect(sk, flags);\n}\n\nstatic int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n\n\tlsa->l2tp_family = AF_INET6;\n\tlsa->l2tp_flowinfo = 0;\n\tlsa->l2tp_scope_id = 0;\n\tlsa->l2tp_unused = 0;\n\tif (peer) {\n\t\tif (!lsk->peer_conn_id)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = sk->sk_v6_daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = sk->sk_v6_rcv_saddr;\n\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = READ_ONCE(sk->sk_bound_dev_if);\n\treturn sizeof(*lsa);\n}\n\nstatic int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\t \n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0)\n\t\tgoto drop;\n\n\treturn 0;\n\ndrop:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_INDISCARDS);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\nstatic int l2tp_ip6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\t__be32 *transhdr = NULL;\n\tint err = 0;\n\n\tskb = skb_peek(&sk->sk_write_queue);\n\tif (!skb)\n\t\tgoto out;\n\n\ttranshdr = (__be32 *)skb_transport_header(skb);\n\t*transhdr = 0;\n\n\terr = ip6_push_pending_frames(sk);\n\nout:\n\treturn err;\n}\n\n \nstatic int l2tp_ip6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt_to_free = NULL;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi6 fl6;\n\tstruct ipcm6_cookie ipc6;\n\tint addr_len = msg->msg_namelen;\n\tint transhdrlen = 4;  \n\tint ulen;\n\tint err;\n\n\t \n\tif (len > INT_MAX - transhdrlen)\n\t\treturn -EMSGSIZE;\n\n\t \n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tfl6.flowi6_mark = READ_ONCE(sk->sk_mark);\n\tfl6.flowi6_uid = sk->sk_uid;\n\n\tipcm6_init(&ipc6);\n\n\tif (lsa) {\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\treturn -EINVAL;\n\n\t\tif (lsa->l2tp_family && lsa->l2tp_family != AF_INET6)\n\t\t\treturn -EAFNOSUPPORT;\n\n\t\tdaddr = &lsa->l2tp_addr;\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = lsa->l2tp_flowinfo & IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel & IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (IS_ERR(flowlabel))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    lsa->l2tp_scope_id &&\n\t\t    ipv6_addr_type(daddr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tfl6.flowi6_oif = lsa->l2tp_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t}\n\n\tif (fl6.flowi6_oif == 0)\n\t\tfl6.flowi6_oif = READ_ONCE(sk->sk_bound_dev_if);\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(struct ipv6_txoptions);\n\t\tipc6.opt = opt;\n\n\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, &ipc6);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel & IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (IS_ERR(flowlabel))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen | opt->opt_flen))\n\t\t\topt = NULL;\n\t}\n\n\tif (!opt) {\n\t\topt = txopt_get(np);\n\t\topt_to_free = opt;\n\t}\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\tipc6.opt = opt;\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1;  \n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6.saddr = np->saddr;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi_common(&fl6));\n\n\tif (ipc6.tclass < 0)\n\t\tipc6.tclass = np->tclass;\n\n\tfl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);\n\n\tdst = ip6_dst_lookup_flow(sock_net(sk), sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto out;\n\t}\n\n\tif (ipc6.hlimit < 0)\n\t\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tif (ipc6.dontfrag < 0)\n\t\tipc6.dontfrag = np->dontfrag;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\n\nback_from_confirm:\n\tlock_sock(sk);\n\tulen = len + skb_queue_empty(&sk->sk_write_queue) ? transhdrlen : 0;\n\terr = ip6_append_data(sk, ip_generic_getfrag, msg,\n\t\t\t      ulen, transhdrlen, &ipc6,\n\t\t\t      &fl6, (struct rt6_info *)dst,\n\t\t\t      msg->msg_flags);\n\tif (err)\n\t\tip6_flush_pending_frames(sk);\n\telse if (!(msg->msg_flags & MSG_MORE))\n\t\terr = l2tp_ip6_push_pending_frames(sk);\n\trelease_sock(sk);\ndone:\n\tdst_release(dst);\nout:\n\tfl6_sock_release(flowlabel);\n\ttxopt_put(opt_to_free);\n\n\treturn err < 0 ? err : len;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(dst, &fl6.daddr);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n\nstatic int l2tp_ip6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t    int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len, addr_len);\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t \n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n\t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n\t\tlsa->l2tp_flowinfo = 0;\n\t\tlsa->l2tp_scope_id = 0;\n\t\tlsa->l2tp_conn_id = 0;\n\t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tlsa->l2tp_scope_id = inet6_iif(skb);\n\t\t*addr_len = sizeof(*lsa);\n\t}\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}\n\nstatic struct proto l2tp_ip6_prot = {\n\t.name\t\t   = \"L2TP/IPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.init\t\t   = l2tp_ip6_open,\n\t.close\t\t   = l2tp_ip6_close,\n\t.bind\t\t   = l2tp_ip6_bind,\n\t.connect\t   = l2tp_ip6_connect,\n\t.disconnect\t   = l2tp_ip6_disconnect,\n\t.ioctl\t\t   = l2tp_ioctl,\n\t.destroy\t   = l2tp_ip6_destroy_sock,\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.sendmsg\t   = l2tp_ip6_sendmsg,\n\t.recvmsg\t   = l2tp_ip6_recvmsg,\n\t.backlog_rcv\t   = l2tp_ip6_backlog_recv,\n\t.hash\t\t   = l2tp_ip6_hash,\n\t.unhash\t\t   = l2tp_ip6_unhash,\n\t.obj_size\t   = sizeof(struct l2tp_ip6_sock),\n\t.ipv6_pinfo_offset = offsetof(struct l2tp_ip6_sock, inet6),\n};\n\nstatic const struct proto_ops l2tp_ip6_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = sock_no_accept,\n\t.getname\t   = l2tp_ip6_getname,\n\t.poll\t\t   = datagram_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = sock_no_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t   = inet6_compat_ioctl,\n#endif\n};\n\nstatic struct inet_protosw l2tp_ip6_protosw = {\n\t.type\t\t= SOCK_DGRAM,\n\t.protocol\t= IPPROTO_L2TP,\n\t.prot\t\t= &l2tp_ip6_prot,\n\t.ops\t\t= &l2tp_ip6_ops,\n};\n\nstatic struct inet6_protocol l2tp_ip6_protocol __read_mostly = {\n\t.handler\t= l2tp_ip6_recv,\n};\n\nstatic int __init l2tp_ip6_init(void)\n{\n\tint err;\n\n\tpr_info(\"L2TP IP encapsulation support for IPv6 (L2TPv3)\\n\");\n\n\terr = proto_register(&l2tp_ip6_prot, 1);\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = inet6_add_protocol(&l2tp_ip6_protocol, IPPROTO_L2TP);\n\tif (err)\n\t\tgoto out1;\n\n\tinet6_register_protosw(&l2tp_ip6_protosw);\n\treturn 0;\n\nout1:\n\tproto_unregister(&l2tp_ip6_prot);\nout:\n\treturn err;\n}\n\nstatic void __exit l2tp_ip6_exit(void)\n{\n\tinet6_unregister_protosw(&l2tp_ip6_protosw);\n\tinet6_del_protocol(&l2tp_ip6_protocol, IPPROTO_L2TP);\n\tproto_unregister(&l2tp_ip6_prot);\n}\n\nmodule_init(l2tp_ip6_init);\nmodule_exit(l2tp_ip6_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Chris Elston <celston@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP IP encapsulation for IPv6\");\nMODULE_VERSION(\"1.0\");\n\n \nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 115, 2);\nMODULE_ALIAS_NET_PF_PROTO(PF_INET6, 115);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}