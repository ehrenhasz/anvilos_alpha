{
  "module_name": "l2tp_eth.c",
  "hash_id": "150b8924aed8cda6c56546ce6216ddec7f5657e254bcaea53cc5985e5fea75fa",
  "original_prompt": "Ingested from linux-6.6.14/net/l2tp/l2tp_eth.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/hash.h>\n#include <linux/l2tp.h>\n#include <linux/in.h>\n#include <linux/etherdevice.h>\n#include <linux/spinlock.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/tcp_states.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/udp.h>\n\n#include \"l2tp_core.h\"\n\n \n#define L2TP_ETH_DEV_NAME\t\"l2tpeth%d\"\n\n \nstruct l2tp_eth {\n\tstruct l2tp_session\t*session;\n\tatomic_long_t\t\ttx_bytes;\n\tatomic_long_t\t\ttx_packets;\n\tatomic_long_t\t\ttx_dropped;\n\tatomic_long_t\t\trx_bytes;\n\tatomic_long_t\t\trx_packets;\n\tatomic_long_t\t\trx_errors;\n};\n\n \nstruct l2tp_eth_sess {\n\tstruct net_device __rcu *dev;\n};\n\nstatic int l2tp_eth_dev_init(struct net_device *dev)\n{\n\teth_hw_addr_random(dev);\n\teth_broadcast_addr(dev->broadcast);\n\tnetdev_lockdep_set_classes(dev);\n\n\treturn 0;\n}\n\nstatic void l2tp_eth_dev_uninit(struct net_device *dev)\n{\n\tstruct l2tp_eth *priv = netdev_priv(dev);\n\tstruct l2tp_eth_sess *spriv;\n\n\tspriv = l2tp_session_priv(priv->session);\n\tRCU_INIT_POINTER(spriv->dev, NULL);\n\t \n}\n\nstatic netdev_tx_t l2tp_eth_dev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct l2tp_eth *priv = netdev_priv(dev);\n\tstruct l2tp_session *session = priv->session;\n\tunsigned int len = skb->len;\n\tint ret = l2tp_xmit_skb(session, skb);\n\n\tif (likely(ret == NET_XMIT_SUCCESS)) {\n\t\tatomic_long_add(len, &priv->tx_bytes);\n\t\tatomic_long_inc(&priv->tx_packets);\n\t} else {\n\t\tatomic_long_inc(&priv->tx_dropped);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\nstatic void l2tp_eth_get_stats64(struct net_device *dev,\n\t\t\t\t struct rtnl_link_stats64 *stats)\n{\n\tstruct l2tp_eth *priv = netdev_priv(dev);\n\n\tstats->tx_bytes   = (unsigned long)atomic_long_read(&priv->tx_bytes);\n\tstats->tx_packets = (unsigned long)atomic_long_read(&priv->tx_packets);\n\tstats->tx_dropped = (unsigned long)atomic_long_read(&priv->tx_dropped);\n\tstats->rx_bytes   = (unsigned long)atomic_long_read(&priv->rx_bytes);\n\tstats->rx_packets = (unsigned long)atomic_long_read(&priv->rx_packets);\n\tstats->rx_errors  = (unsigned long)atomic_long_read(&priv->rx_errors);\n}\n\nstatic const struct net_device_ops l2tp_eth_netdev_ops = {\n\t.ndo_init\t\t= l2tp_eth_dev_init,\n\t.ndo_uninit\t\t= l2tp_eth_dev_uninit,\n\t.ndo_start_xmit\t\t= l2tp_eth_dev_xmit,\n\t.ndo_get_stats64\t= l2tp_eth_get_stats64,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic struct device_type l2tpeth_type = {\n\t.name = \"l2tpeth\",\n};\n\nstatic void l2tp_eth_dev_setup(struct net_device *dev)\n{\n\tSET_NETDEV_DEVTYPE(dev, &l2tpeth_type);\n\tether_setup(dev);\n\tdev->priv_flags\t\t&= ~IFF_TX_SKB_SHARING;\n\tdev->features\t\t|= NETIF_F_LLTX;\n\tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n}\n\nstatic void l2tp_eth_dev_recv(struct l2tp_session *session, struct sk_buff *skb, int data_len)\n{\n\tstruct l2tp_eth_sess *spriv = l2tp_session_priv(session);\n\tstruct net_device *dev;\n\tstruct l2tp_eth *priv;\n\n\tif (!pskb_may_pull(skb, ETH_HLEN))\n\t\tgoto error;\n\n\tsecpath_reset(skb);\n\n\t \n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb_dst_drop(skb);\n\tnf_reset_ct(skb);\n\n\trcu_read_lock();\n\tdev = rcu_dereference(spriv->dev);\n\tif (!dev)\n\t\tgoto error_rcu;\n\n\tpriv = netdev_priv(dev);\n\tif (dev_forward_skb(dev, skb) == NET_RX_SUCCESS) {\n\t\tatomic_long_inc(&priv->rx_packets);\n\t\tatomic_long_add(data_len, &priv->rx_bytes);\n\t} else {\n\t\tatomic_long_inc(&priv->rx_errors);\n\t}\n\trcu_read_unlock();\n\n\treturn;\n\nerror_rcu:\n\trcu_read_unlock();\nerror:\n\tkfree_skb(skb);\n}\n\nstatic void l2tp_eth_delete(struct l2tp_session *session)\n{\n\tstruct l2tp_eth_sess *spriv;\n\tstruct net_device *dev;\n\n\tif (session) {\n\t\tspriv = l2tp_session_priv(session);\n\n\t\trtnl_lock();\n\t\tdev = rtnl_dereference(spriv->dev);\n\t\tif (dev) {\n\t\t\tunregister_netdevice(dev);\n\t\t\trtnl_unlock();\n\t\t\tmodule_put(THIS_MODULE);\n\t\t} else {\n\t\t\trtnl_unlock();\n\t\t}\n\t}\n}\n\nstatic void l2tp_eth_show(struct seq_file *m, void *arg)\n{\n\tstruct l2tp_session *session = arg;\n\tstruct l2tp_eth_sess *spriv = l2tp_session_priv(session);\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tdev = rcu_dereference(spriv->dev);\n\tif (!dev) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tdev_hold(dev);\n\trcu_read_unlock();\n\n\tseq_printf(m, \"   interface %s\\n\", dev->name);\n\n\tdev_put(dev);\n}\n\nstatic void l2tp_eth_adjust_mtu(struct l2tp_tunnel *tunnel,\n\t\t\t\tstruct l2tp_session *session,\n\t\t\t\tstruct net_device *dev)\n{\n\tunsigned int overhead = 0;\n\tu32 l3_overhead = 0;\n\tu32 mtu;\n\n\t \n\tif (tunnel->encap == L2TP_ENCAPTYPE_UDP) {\n\t\toverhead += sizeof(struct udphdr);\n\t\tdev->needed_headroom += sizeof(struct udphdr);\n\t}\n\n\tlock_sock(tunnel->sock);\n\tl3_overhead = kernel_sock_ip_overhead(tunnel->sock);\n\trelease_sock(tunnel->sock);\n\n\tif (l3_overhead == 0) {\n\t\t \n\t\treturn;\n\t}\n\t \n\toverhead += session->hdr_len + ETH_HLEN + l3_overhead;\n\n\tmtu = l2tp_tunnel_dst_mtu(tunnel) - overhead;\n\tif (mtu < dev->min_mtu || mtu > dev->max_mtu)\n\t\tdev->mtu = ETH_DATA_LEN - overhead;\n\telse\n\t\tdev->mtu = mtu;\n\n\tdev->needed_headroom += session->hdr_len;\n}\n\nstatic int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,\n\t\t\t   u32 session_id, u32 peer_session_id,\n\t\t\t   struct l2tp_session_cfg *cfg)\n{\n\tunsigned char name_assign_type;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct l2tp_session *session;\n\tstruct l2tp_eth *priv;\n\tstruct l2tp_eth_sess *spriv;\n\tint rc;\n\n\tif (cfg->ifname) {\n\t\tstrscpy(name, cfg->ifname, IFNAMSIZ);\n\t\tname_assign_type = NET_NAME_USER;\n\t} else {\n\t\tstrcpy(name, L2TP_ETH_DEV_NAME);\n\t\tname_assign_type = NET_NAME_ENUM;\n\t}\n\n\tsession = l2tp_session_create(sizeof(*spriv), tunnel, session_id,\n\t\t\t\t      peer_session_id, cfg);\n\tif (IS_ERR(session)) {\n\t\trc = PTR_ERR(session);\n\t\tgoto err;\n\t}\n\n\tdev = alloc_netdev(sizeof(*priv), name, name_assign_type,\n\t\t\t   l2tp_eth_dev_setup);\n\tif (!dev) {\n\t\trc = -ENOMEM;\n\t\tgoto err_sess;\n\t}\n\n\tdev_net_set(dev, net);\n\tdev->min_mtu = 0;\n\tdev->max_mtu = ETH_MAX_MTU;\n\tl2tp_eth_adjust_mtu(tunnel, session, dev);\n\n\tpriv = netdev_priv(dev);\n\tpriv->session = session;\n\n\tsession->recv_skb = l2tp_eth_dev_recv;\n\tsession->session_close = l2tp_eth_delete;\n\tif (IS_ENABLED(CONFIG_L2TP_DEBUGFS))\n\t\tsession->show = l2tp_eth_show;\n\n\tspriv = l2tp_session_priv(session);\n\n\tl2tp_session_inc_refcount(session);\n\n\trtnl_lock();\n\n\t \n\trc = l2tp_session_register(session, tunnel);\n\tif (rc < 0) {\n\t\trtnl_unlock();\n\t\tgoto err_sess_dev;\n\t}\n\n\trc = register_netdevice(dev);\n\tif (rc < 0) {\n\t\trtnl_unlock();\n\t\tl2tp_session_delete(session);\n\t\tl2tp_session_dec_refcount(session);\n\t\tfree_netdev(dev);\n\n\t\treturn rc;\n\t}\n\n\tstrscpy(session->ifname, dev->name, IFNAMSIZ);\n\trcu_assign_pointer(spriv->dev, dev);\n\n\trtnl_unlock();\n\n\tl2tp_session_dec_refcount(session);\n\n\t__module_get(THIS_MODULE);\n\n\treturn 0;\n\nerr_sess_dev:\n\tl2tp_session_dec_refcount(session);\n\tfree_netdev(dev);\nerr_sess:\n\tkfree(session);\nerr:\n\treturn rc;\n}\n\nstatic const struct l2tp_nl_cmd_ops l2tp_eth_nl_cmd_ops = {\n\t.session_create\t= l2tp_eth_create,\n\t.session_delete\t= l2tp_session_delete,\n};\n\nstatic int __init l2tp_eth_init(void)\n{\n\tint err = 0;\n\n\terr = l2tp_nl_register_ops(L2TP_PWTYPE_ETH, &l2tp_eth_nl_cmd_ops);\n\tif (err)\n\t\tgoto err;\n\n\tpr_info(\"L2TP ethernet pseudowire support (L2TPv3)\\n\");\n\n\treturn 0;\n\nerr:\n\treturn err;\n}\n\nstatic void __exit l2tp_eth_exit(void)\n{\n\tl2tp_nl_unregister_ops(L2TP_PWTYPE_ETH);\n}\n\nmodule_init(l2tp_eth_init);\nmodule_exit(l2tp_eth_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP ethernet pseudowire driver\");\nMODULE_VERSION(\"1.0\");\nMODULE_ALIAS_L2TP_PWTYPE(5);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}