{
  "module_name": "l2tp_ip.c",
  "hash_id": "00e58af53f48eaafba2b8712da35f3c86ab09b91223f267e34e9036105ddd617",
  "original_prompt": "Ingested from linux-6.6.14/net/l2tp/l2tp_ip.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <asm/ioctls.h>\n#include <linux/icmp.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/random.h>\n#include <linux/socket.h>\n#include <linux/l2tp.h>\n#include <linux/in.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/tcp_states.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\n#include \"l2tp_core.h\"\n\nstruct l2tp_ip_sock {\n\t \n\tstruct inet_sock\tinet;\n\n\tu32\t\t\tconn_id;\n\tu32\t\t\tpeer_conn_id;\n};\n\nstatic DEFINE_RWLOCK(l2tp_ip_lock);\nstatic struct hlist_head l2tp_ip_table;\nstatic struct hlist_head l2tp_ip_bind_table;\n\nstatic inline struct l2tp_ip_sock *l2tp_ip_sk(const struct sock *sk)\n{\n\treturn (struct l2tp_ip_sock *)sk;\n}\n\nstatic struct sock *__l2tp_ip_bind_lookup(const struct net *net, __be32 laddr,\n\t\t\t\t\t  __be32 raddr, int dif, u32 tunnel_id)\n{\n\tstruct sock *sk;\n\n\tsk_for_each_bound(sk, &l2tp_ip_bind_table) {\n\t\tconst struct l2tp_ip_sock *l2tp = l2tp_ip_sk(sk);\n\t\tconst struct inet_sock *inet = inet_sk(sk);\n\t\tint bound_dev_if;\n\n\t\tif (!net_eq(sock_net(sk), net))\n\t\t\tcontinue;\n\n\t\tbound_dev_if = READ_ONCE(sk->sk_bound_dev_if);\n\t\tif (bound_dev_if && dif && bound_dev_if != dif)\n\t\t\tcontinue;\n\n\t\tif (inet->inet_rcv_saddr && laddr &&\n\t\t    inet->inet_rcv_saddr != laddr)\n\t\t\tcontinue;\n\n\t\tif (inet->inet_daddr && raddr && inet->inet_daddr != raddr)\n\t\t\tcontinue;\n\n\t\tif (l2tp->conn_id != tunnel_id)\n\t\t\tcontinue;\n\n\t\tgoto found;\n\t}\n\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\n \nstatic int l2tp_ip_recv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tu32 session_id;\n\tu32 tunnel_id;\n\tunsigned char *ptr, *optr;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel = NULL;\n\tstruct iphdr *iph;\n\n\tif (!pskb_may_pull(skb, 4))\n\t\tgoto discard;\n\n\t \n\toptr = skb->data;\n\tptr = skb->data;\n\tsession_id = ntohl(*((__be32 *)ptr));\n\tptr += 4;\n\n\t \n\tif (session_id == 0) {\n\t\t__skb_pull(skb, 4);\n\t\tgoto pass_up;\n\t}\n\n\t \n\tsession = l2tp_session_get(net, session_id);\n\tif (!session)\n\t\tgoto discard;\n\n\ttunnel = session->tunnel;\n\tif (!tunnel)\n\t\tgoto discard_sess;\n\n\tif (l2tp_v3_ensure_opt_in_linear(session, skb, &ptr, &optr))\n\t\tgoto discard_sess;\n\n\tl2tp_recv_common(session, skb, ptr, optr, 0, skb->len);\n\tl2tp_session_dec_refcount(session);\n\n\treturn 0;\n\npass_up:\n\t \n\tif (!pskb_may_pull(skb, 12))\n\t\tgoto discard;\n\n\tif ((skb->data[0] & 0xc0) != 0xc0)\n\t\tgoto discard;\n\n\ttunnel_id = ntohl(*(__be32 *)&skb->data[4]);\n\tiph = (struct iphdr *)skb_network_header(skb);\n\n\tread_lock_bh(&l2tp_ip_lock);\n\tsk = __l2tp_ip_bind_lookup(net, iph->daddr, iph->saddr, inet_iif(skb),\n\t\t\t\t   tunnel_id);\n\tif (!sk) {\n\t\tread_unlock_bh(&l2tp_ip_lock);\n\t\tgoto discard;\n\t}\n\tsock_hold(sk);\n\tread_unlock_bh(&l2tp_ip_lock);\n\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_put;\n\n\tnf_reset_ct(skb);\n\n\treturn sk_receive_skb(sk, skb, 1);\n\ndiscard_sess:\n\tl2tp_session_dec_refcount(session);\n\tgoto discard;\n\ndiscard_put:\n\tsock_put(sk);\n\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int l2tp_ip_hash(struct sock *sk)\n{\n\tif (sk_unhashed(sk)) {\n\t\twrite_lock_bh(&l2tp_ip_lock);\n\t\tsk_add_node(sk, &l2tp_ip_table);\n\t\twrite_unlock_bh(&l2tp_ip_lock);\n\t}\n\treturn 0;\n}\n\nstatic void l2tp_ip_unhash(struct sock *sk)\n{\n\tif (sk_unhashed(sk))\n\t\treturn;\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n}\n\nstatic int l2tp_ip_open(struct sock *sk)\n{\n\t \n\tinet_sk(sk)->inet_num = IPPROTO_L2TP;\n\n\tl2tp_ip_hash(sk);\n\treturn 0;\n}\n\nstatic void l2tp_ip_close(struct sock *sk, long timeout)\n{\n\twrite_lock_bh(&l2tp_ip_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tsk_common_release(sk);\n}\n\nstatic void l2tp_ip_destroy_sock(struct sock *sk)\n{\n\tstruct l2tp_tunnel *tunnel = l2tp_sk_to_tunnel(sk);\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue_tail(&sk->sk_write_queue)) != NULL)\n\t\tkfree_skb(skb);\n\n\tif (tunnel)\n\t\tl2tp_tunnel_delete(tunnel);\n}\n\nstatic int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *)uaddr;\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\tint chk_addr_ret;\n\n\tif (addr_len < sizeof(struct sockaddr_l2tpip))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tret = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out;\n\n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\n\tif (addr->l2tp_addr.s_addr) {\n\t\tinet->inet_rcv_saddr = addr->l2tp_addr.s_addr;\n\t\tinet->inet_saddr = addr->l2tp_addr.s_addr;\n\t}\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;   \n\n\twrite_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr, 0,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id)) {\n\t\twrite_unlock_bh(&l2tp_ip_lock);\n\t\tret = -EADDRINUSE;\n\t\tgoto out;\n\t}\n\n\tsk_dst_reset(sk);\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\nout:\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\nstatic int l2tp_ip_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_l2tpip *lsa = (struct sockaddr_l2tpip *)uaddr;\n\tint rc;\n\n\tif (addr_len < sizeof(*lsa))\n\t\treturn -EINVAL;\n\n\tif (ipv4_is_multicast(lsa->l2tp_addr.s_addr))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\t \n\tif (sock_flag(sk, SOCK_ZAPPED)) {\n\t\trc = -EINVAL;\n\t\tgoto out_sk;\n\t}\n\n\trc = __ip4_datagram_connect(sk, uaddr, addr_len);\n\tif (rc < 0)\n\t\tgoto out_sk;\n\n\tl2tp_ip_sk(sk)->peer_conn_id = lsa->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\nout_sk:\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int l2tp_ip_disconnect(struct sock *sk, int flags)\n{\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn 0;\n\n\treturn __udp_disconnect(sk, flags);\n}\n\nstatic int l2tp_ip_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t   int peer)\n{\n\tstruct sock *sk\t\t= sock->sk;\n\tstruct inet_sock *inet\t= inet_sk(sk);\n\tstruct l2tp_ip_sock *lsk = l2tp_ip_sk(sk);\n\tstruct sockaddr_l2tpip *lsa = (struct sockaddr_l2tpip *)uaddr;\n\n\tmemset(lsa, 0, sizeof(*lsa));\n\tlsa->l2tp_family = AF_INET;\n\tif (peer) {\n\t\tif (!inet->inet_dport)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr.s_addr = inet->inet_daddr;\n\t} else {\n\t\t__be32 addr = inet->inet_rcv_saddr;\n\n\t\tif (!addr)\n\t\t\taddr = inet->inet_saddr;\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t\tlsa->l2tp_addr.s_addr = addr;\n\t}\n\treturn sizeof(*lsa);\n}\n\nstatic int l2tp_ip_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\t \n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0)\n\t\tgoto drop;\n\n\treturn 0;\n\ndrop:\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_INDISCARDS);\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n \nstatic int l2tp_ip_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct sk_buff *skb;\n\tint rc;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 *fl4;\n\tint connected = 0;\n\t__be32 daddr;\n\n\tlock_sock(sk);\n\n\trc = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_DEAD))\n\t\tgoto out;\n\n\t \n\tif (msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_l2tpip *, lip, msg->msg_name);\n\n\t\trc = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*lip))\n\t\t\tgoto out;\n\n\t\tif (lip->l2tp_family != AF_INET) {\n\t\t\trc = -EAFNOSUPPORT;\n\t\t\tif (lip->l2tp_family != AF_UNSPEC)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tdaddr = lip->l2tp_addr.s_addr;\n\t} else {\n\t\trc = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\tdaddr = inet->inet_daddr;\n\t\tconnected = 1;\n\t}\n\n\t \n\trc = -ENOMEM;\n\tskb = sock_wmalloc(sk, 2 + NET_SKB_PAD + sizeof(struct iphdr) +\n\t\t\t   4 + len, 0, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto error;\n\n\t \n\tskb_reserve(skb, 2 + NET_SKB_PAD);\n\tskb_reset_network_header(skb);\n\tskb_reserve(skb, sizeof(struct iphdr));\n\tskb_reset_transport_header(skb);\n\n\t \n\t*((__be32 *)skb_put(skb, 4)) = 0;\n\n\t \n\trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tfl4 = &inet->cork.fl.u.ip4;\n\tif (connected)\n\t\trt = (struct rtable *)__sk_dst_check(sk, 0);\n\n\trcu_read_lock();\n\tif (!rt) {\n\t\tconst struct ip_options_rcu *inet_opt;\n\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\n\t\t \n\t\tif (inet_opt && inet_opt->opt.srr)\n\t\t\tdaddr = inet_opt->opt.faddr;\n\n\t\t \n\t\trt = ip_route_output_ports(sock_net(sk), fl4, sk,\n\t\t\t\t\t   daddr, inet->inet_saddr,\n\t\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto no_route;\n\t\tif (connected) {\n\t\t\tsk_setup_caps(sk, &rt->dst);\n\t\t} else {\n\t\t\tskb_dst_set(skb, &rt->dst);\n\t\t\tgoto xmit;\n\t\t}\n\t}\n\n\t \n\tskb_dst_set_noref(skb, &rt->dst);\n\nxmit:\n\t \n\trc = ip_queue_xmit(sk, skb, &inet->cork.fl);\n\trcu_read_unlock();\n\nerror:\n\tif (rc >= 0)\n\t\trc = len;\n\nout:\n\trelease_sock(sk);\n\treturn rc;\n\nno_route:\n\trcu_read_unlock();\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\tkfree_skb(skb);\n\trc = -EHOSTUNREACH;\n\tgoto out;\n}\n\nstatic int l2tp_ip_recvmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t   size_t len, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t \n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet_cmsg_flags(inet))\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}\n\nint l2tp_ioctl(struct sock *sk, int cmd, int *karg)\n{\n\tstruct sk_buff *skb;\n\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\t\t*karg = sk_wmem_alloc_get(sk);\n\t\tbreak;\n\tcase SIOCINQ:\n\t\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\t*karg = skb ? skb->len : 0;\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(l2tp_ioctl);\n\nstatic struct proto l2tp_ip_prot = {\n\t.name\t\t   = \"L2TP/IP\",\n\t.owner\t\t   = THIS_MODULE,\n\t.init\t\t   = l2tp_ip_open,\n\t.close\t\t   = l2tp_ip_close,\n\t.bind\t\t   = l2tp_ip_bind,\n\t.connect\t   = l2tp_ip_connect,\n\t.disconnect\t   = l2tp_ip_disconnect,\n\t.ioctl\t\t   = l2tp_ioctl,\n\t.destroy\t   = l2tp_ip_destroy_sock,\n\t.setsockopt\t   = ip_setsockopt,\n\t.getsockopt\t   = ip_getsockopt,\n\t.sendmsg\t   = l2tp_ip_sendmsg,\n\t.recvmsg\t   = l2tp_ip_recvmsg,\n\t.backlog_rcv\t   = l2tp_ip_backlog_recv,\n\t.hash\t\t   = l2tp_ip_hash,\n\t.unhash\t\t   = l2tp_ip_unhash,\n\t.obj_size\t   = sizeof(struct l2tp_ip_sock),\n};\n\nstatic const struct proto_ops l2tp_ip_ops = {\n\t.family\t\t   = PF_INET,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet_release,\n\t.bind\t\t   = inet_bind,\n\t.connect\t   = inet_dgram_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = sock_no_accept,\n\t.getname\t   = l2tp_ip_getname,\n\t.poll\t\t   = datagram_poll,\n\t.ioctl\t\t   = inet_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = sock_no_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = sock_common_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n};\n\nstatic struct inet_protosw l2tp_ip_protosw = {\n\t.type\t\t= SOCK_DGRAM,\n\t.protocol\t= IPPROTO_L2TP,\n\t.prot\t\t= &l2tp_ip_prot,\n\t.ops\t\t= &l2tp_ip_ops,\n};\n\nstatic struct net_protocol l2tp_ip_protocol __read_mostly = {\n\t.handler\t= l2tp_ip_recv,\n};\n\nstatic int __init l2tp_ip_init(void)\n{\n\tint err;\n\n\tpr_info(\"L2TP IP encapsulation support (L2TPv3)\\n\");\n\n\terr = proto_register(&l2tp_ip_prot, 1);\n\tif (err != 0)\n\t\tgoto out;\n\n\terr = inet_add_protocol(&l2tp_ip_protocol, IPPROTO_L2TP);\n\tif (err)\n\t\tgoto out1;\n\n\tinet_register_protosw(&l2tp_ip_protosw);\n\treturn 0;\n\nout1:\n\tproto_unregister(&l2tp_ip_prot);\nout:\n\treturn err;\n}\n\nstatic void __exit l2tp_ip_exit(void)\n{\n\tinet_unregister_protosw(&l2tp_ip_protosw);\n\tinet_del_protocol(&l2tp_ip_protocol, IPPROTO_L2TP);\n\tproto_unregister(&l2tp_ip_prot);\n}\n\nmodule_init(l2tp_ip_init);\nmodule_exit(l2tp_ip_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP over IP\");\nMODULE_VERSION(\"1.0\");\n\n \nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET, 115, 2);\nMODULE_ALIAS_NET_PF_PROTO(PF_INET, 115);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}