{
  "module_name": "trace.h",
  "hash_id": "4654a17abbdc36a500b0706bac3646987a9527a41d6fc36320d3e7bfc3388fbb",
  "original_prompt": "Ingested from linux-6.6.14/net/l2tp/trace.h",
  "human_readable_source": " \n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM l2tp\n\n#if !defined(_TRACE_L2TP_H) || defined(TRACE_HEADER_MULTI_READ)\n#define _TRACE_L2TP_H\n\n#include <linux/tracepoint.h>\n#include <linux/l2tp.h>\n#include \"l2tp_core.h\"\n\n#define encap_type_name(e) { L2TP_ENCAPTYPE_##e, #e }\n#define show_encap_type_name(val) \\\n\t__print_symbolic(val, \\\n\t\t\tencap_type_name(UDP), \\\n\t\t\tencap_type_name(IP))\n\n#define pw_type_name(p) { L2TP_PWTYPE_##p, #p }\n#define show_pw_type_name(val) \\\n\t__print_symbolic(val, \\\n\tpw_type_name(ETH_VLAN), \\\n\tpw_type_name(ETH), \\\n\tpw_type_name(PPP), \\\n\tpw_type_name(PPP_AC), \\\n\tpw_type_name(IP))\n\nDECLARE_EVENT_CLASS(tunnel_only_evt,\n\tTP_PROTO(struct l2tp_tunnel *tunnel),\n\tTP_ARGS(tunnel),\n\tTP_STRUCT__entry(\n\t\t__array(char, name, L2TP_TUNNEL_NAME_MAX)\n\t),\n\tTP_fast_assign(\n\t\tmemcpy(__entry->name, tunnel->name, L2TP_TUNNEL_NAME_MAX);\n\t),\n\tTP_printk(\"%s\", __entry->name)\n);\n\nDECLARE_EVENT_CLASS(session_only_evt,\n\tTP_PROTO(struct l2tp_session *session),\n\tTP_ARGS(session),\n\tTP_STRUCT__entry(\n\t\t__array(char, name, L2TP_SESSION_NAME_MAX)\n\t),\n\tTP_fast_assign(\n\t\tmemcpy(__entry->name, session->name, L2TP_SESSION_NAME_MAX);\n\t),\n\tTP_printk(\"%s\", __entry->name)\n);\n\nTRACE_EVENT(register_tunnel,\n\tTP_PROTO(struct l2tp_tunnel *tunnel),\n\tTP_ARGS(tunnel),\n\tTP_STRUCT__entry(\n\t\t__array(char, name, L2TP_TUNNEL_NAME_MAX)\n\t\t__field(int, fd)\n\t\t__field(u32, tid)\n\t\t__field(u32, ptid)\n\t\t__field(int, version)\n\t\t__field(enum l2tp_encap_type, encap)\n\t),\n\tTP_fast_assign(\n\t\tmemcpy(__entry->name, tunnel->name, L2TP_TUNNEL_NAME_MAX);\n\t\t__entry->fd = tunnel->fd;\n\t\t__entry->tid = tunnel->tunnel_id;\n\t\t__entry->ptid = tunnel->peer_tunnel_id;\n\t\t__entry->version = tunnel->version;\n\t\t__entry->encap = tunnel->encap;\n\t),\n\tTP_printk(\"%s: type=%s encap=%s version=L2TPv%d tid=%u ptid=%u fd=%d\",\n\t\t__entry->name,\n\t\t__entry->fd > 0 ? \"managed\" : \"unmanaged\",\n\t\tshow_encap_type_name(__entry->encap),\n\t\t__entry->version,\n\t\t__entry->tid,\n\t\t__entry->ptid,\n\t\t__entry->fd)\n);\n\nDEFINE_EVENT(tunnel_only_evt, delete_tunnel,\n\tTP_PROTO(struct l2tp_tunnel *tunnel),\n\tTP_ARGS(tunnel)\n);\n\nDEFINE_EVENT(tunnel_only_evt, free_tunnel,\n\tTP_PROTO(struct l2tp_tunnel *tunnel),\n\tTP_ARGS(tunnel)\n);\n\nTRACE_EVENT(register_session,\n\tTP_PROTO(struct l2tp_session *session),\n\tTP_ARGS(session),\n\tTP_STRUCT__entry(\n\t\t__array(char, name, L2TP_SESSION_NAME_MAX)\n\t\t__field(u32, tid)\n\t\t__field(u32, ptid)\n\t\t__field(u32, sid)\n\t\t__field(u32, psid)\n\t\t__field(enum l2tp_pwtype, pwtype)\n\t),\n\tTP_fast_assign(\n\t\tmemcpy(__entry->name, session->name, L2TP_SESSION_NAME_MAX);\n\t\t__entry->tid = session->tunnel ? session->tunnel->tunnel_id : 0;\n\t\t__entry->ptid = session->tunnel ? session->tunnel->peer_tunnel_id : 0;\n\t\t__entry->sid = session->session_id;\n\t\t__entry->psid = session->peer_session_id;\n\t\t__entry->pwtype = session->pwtype;\n\t),\n\tTP_printk(\"%s: pseudowire=%s sid=%u psid=%u tid=%u ptid=%u\",\n\t\t__entry->name,\n\t\tshow_pw_type_name(__entry->pwtype),\n\t\t__entry->sid,\n\t\t__entry->psid,\n\t\t__entry->sid,\n\t\t__entry->psid)\n);\n\nDEFINE_EVENT(session_only_evt, delete_session,\n\tTP_PROTO(struct l2tp_session *session),\n\tTP_ARGS(session)\n);\n\nDEFINE_EVENT(session_only_evt, free_session,\n\tTP_PROTO(struct l2tp_session *session),\n\tTP_ARGS(session)\n);\n\nDEFINE_EVENT(session_only_evt, session_seqnum_lns_enable,\n\tTP_PROTO(struct l2tp_session *session),\n\tTP_ARGS(session)\n);\n\nDEFINE_EVENT(session_only_evt, session_seqnum_lns_disable,\n\tTP_PROTO(struct l2tp_session *session),\n\tTP_ARGS(session)\n);\n\nDECLARE_EVENT_CLASS(session_seqnum_evt,\n\tTP_PROTO(struct l2tp_session *session),\n\tTP_ARGS(session),\n\tTP_STRUCT__entry(\n\t\t__array(char, name, L2TP_SESSION_NAME_MAX)\n\t\t__field(u32, ns)\n\t\t__field(u32, nr)\n\t),\n\tTP_fast_assign(\n\t\tmemcpy(__entry->name, session->name, L2TP_SESSION_NAME_MAX);\n\t\t__entry->ns = session->ns;\n\t\t__entry->nr = session->nr;\n\t),\n\tTP_printk(\"%s: ns=%u nr=%u\",\n\t\t__entry->name,\n\t\t__entry->ns,\n\t\t__entry->nr)\n);\n\nDEFINE_EVENT(session_seqnum_evt, session_seqnum_update,\n\tTP_PROTO(struct l2tp_session *session),\n\tTP_ARGS(session)\n);\n\nDEFINE_EVENT(session_seqnum_evt, session_seqnum_reset,\n\tTP_PROTO(struct l2tp_session *session),\n\tTP_ARGS(session)\n);\n\nDECLARE_EVENT_CLASS(session_pkt_discard_evt,\n\tTP_PROTO(struct l2tp_session *session, u32 pkt_ns),\n\tTP_ARGS(session, pkt_ns),\n\tTP_STRUCT__entry(\n\t\t__array(char, name, L2TP_SESSION_NAME_MAX)\n\t\t__field(u32, pkt_ns)\n\t\t__field(u32, my_nr)\n\t\t__field(u32, reorder_q_len)\n\t),\n\tTP_fast_assign(\n\t\tmemcpy(__entry->name, session->name, L2TP_SESSION_NAME_MAX);\n\t\t__entry->pkt_ns = pkt_ns,\n\t\t__entry->my_nr = session->nr;\n\t\t__entry->reorder_q_len = skb_queue_len(&session->reorder_q);\n\t),\n\tTP_printk(\"%s: pkt_ns=%u my_nr=%u reorder_q_len=%u\",\n\t\t__entry->name,\n\t\t__entry->pkt_ns,\n\t\t__entry->my_nr,\n\t\t__entry->reorder_q_len)\n);\n\nDEFINE_EVENT(session_pkt_discard_evt, session_pkt_expired,\n\tTP_PROTO(struct l2tp_session *session, u32 pkt_ns),\n\tTP_ARGS(session, pkt_ns)\n);\n\nDEFINE_EVENT(session_pkt_discard_evt, session_pkt_outside_rx_window,\n\tTP_PROTO(struct l2tp_session *session, u32 pkt_ns),\n\tTP_ARGS(session, pkt_ns)\n);\n\nDEFINE_EVENT(session_pkt_discard_evt, session_pkt_oos,\n\tTP_PROTO(struct l2tp_session *session, u32 pkt_ns),\n\tTP_ARGS(session, pkt_ns)\n);\n\n#endif  \n\n \n#undef TRACE_INCLUDE_PATH\n#define TRACE_INCLUDE_PATH .\n#undef TRACE_INCLUDE_FILE\n#define TRACE_INCLUDE_FILE trace\n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}