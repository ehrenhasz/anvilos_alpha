{
  "module_name": "l2tp_core.c",
  "hash_id": "5f26eddcbde5ac393fffc21b394d879fc66ec23cf8fc5374dc32b0acbfe431a0",
  "original_prompt": "Ingested from linux-6.6.14/net/l2tp/l2tp_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jiffies.h>\n\n#include <linux/netdevice.h>\n#include <linux/net.h>\n#include <linux/inetdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/udp.h>\n#include <linux/l2tp.h>\n#include <linux/hash.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/dst.h>\n#include <net/ip.h>\n#include <net/udp.h>\n#include <net/udp_tunnel.h>\n#include <net/inet_common.h>\n#include <net/xfrm.h>\n#include <net/protocol.h>\n#include <net/inet6_connection_sock.h>\n#include <net/inet_ecn.h>\n#include <net/ip6_route.h>\n#include <net/ip6_checksum.h>\n\n#include <asm/byteorder.h>\n#include <linux/atomic.h>\n\n#include \"l2tp_core.h\"\n#include \"trace.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\n#define L2TP_DRV_VERSION\t\"V2.0\"\n\n \n#define L2TP_HDRFLAG_T\t   0x8000\n#define L2TP_HDRFLAG_L\t   0x4000\n#define L2TP_HDRFLAG_S\t   0x0800\n#define L2TP_HDRFLAG_O\t   0x0200\n#define L2TP_HDRFLAG_P\t   0x0100\n\n#define L2TP_HDR_VER_MASK  0x000F\n#define L2TP_HDR_VER_2\t   0x0002\n#define L2TP_HDR_VER_3\t   0x0003\n\n \n#define L2TP_SLFLAG_S\t   0x40000000\n#define L2TP_SL_SEQ_MASK   0x00ffffff\n\n#define L2TP_HDR_SIZE_MAX\t\t14\n\n \n#define L2TP_DEFAULT_DEBUG_FLAGS\t0\n\n \nstruct l2tp_skb_cb {\n\tu32\t\t\tns;\n\tu16\t\t\thas_seq;\n\tu16\t\t\tlength;\n\tunsigned long\t\texpires;\n};\n\n#define L2TP_SKB_CB(skb)\t((struct l2tp_skb_cb *)&(skb)->cb[sizeof(struct inet_skb_parm)])\n\nstatic struct workqueue_struct *l2tp_wq;\n\n \nstatic unsigned int l2tp_net_id;\nstruct l2tp_net {\n\t \n\tspinlock_t l2tp_tunnel_idr_lock;\n\tstruct idr l2tp_tunnel_idr;\n\tstruct hlist_head l2tp_session_hlist[L2TP_HASH_SIZE_2];\n\t \n\tspinlock_t l2tp_session_hlist_lock;\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic bool l2tp_sk_is_v6(struct sock *sk)\n{\n\treturn sk->sk_family == PF_INET6 &&\n\t       !ipv6_addr_v4mapped(&sk->sk_v6_daddr);\n}\n#endif\n\nstatic inline struct l2tp_net *l2tp_pernet(const struct net *net)\n{\n\treturn net_generic(net, l2tp_net_id);\n}\n\n \nstatic inline struct hlist_head *\nl2tp_session_id_hash_2(struct l2tp_net *pn, u32 session_id)\n{\n\treturn &pn->l2tp_session_hlist[hash_32(session_id, L2TP_HASH_BITS_2)];\n}\n\n \nstatic inline struct hlist_head *\nl2tp_session_id_hash(struct l2tp_tunnel *tunnel, u32 session_id)\n{\n\treturn &tunnel->session_hlist[hash_32(session_id, L2TP_HASH_BITS)];\n}\n\nstatic void l2tp_tunnel_free(struct l2tp_tunnel *tunnel)\n{\n\ttrace_free_tunnel(tunnel);\n\tsock_put(tunnel->sock);\n\t \n}\n\nstatic void l2tp_session_free(struct l2tp_session *session)\n{\n\ttrace_free_session(session);\n\tif (session->tunnel)\n\t\tl2tp_tunnel_dec_refcount(session->tunnel);\n\tkfree(session);\n}\n\nstruct l2tp_tunnel *l2tp_sk_to_tunnel(struct sock *sk)\n{\n\tstruct l2tp_tunnel *tunnel = sk->sk_user_data;\n\n\tif (tunnel)\n\t\tif (WARN_ON(tunnel->magic != L2TP_TUNNEL_MAGIC))\n\t\t\treturn NULL;\n\n\treturn tunnel;\n}\nEXPORT_SYMBOL_GPL(l2tp_sk_to_tunnel);\n\nvoid l2tp_tunnel_inc_refcount(struct l2tp_tunnel *tunnel)\n{\n\trefcount_inc(&tunnel->ref_count);\n}\nEXPORT_SYMBOL_GPL(l2tp_tunnel_inc_refcount);\n\nvoid l2tp_tunnel_dec_refcount(struct l2tp_tunnel *tunnel)\n{\n\tif (refcount_dec_and_test(&tunnel->ref_count))\n\t\tl2tp_tunnel_free(tunnel);\n}\nEXPORT_SYMBOL_GPL(l2tp_tunnel_dec_refcount);\n\nvoid l2tp_session_inc_refcount(struct l2tp_session *session)\n{\n\trefcount_inc(&session->ref_count);\n}\nEXPORT_SYMBOL_GPL(l2tp_session_inc_refcount);\n\nvoid l2tp_session_dec_refcount(struct l2tp_session *session)\n{\n\tif (refcount_dec_and_test(&session->ref_count))\n\t\tl2tp_session_free(session);\n}\nEXPORT_SYMBOL_GPL(l2tp_session_dec_refcount);\n\n \nstruct l2tp_tunnel *l2tp_tunnel_get(const struct net *net, u32 tunnel_id)\n{\n\tconst struct l2tp_net *pn = l2tp_pernet(net);\n\tstruct l2tp_tunnel *tunnel;\n\n\trcu_read_lock_bh();\n\ttunnel = idr_find(&pn->l2tp_tunnel_idr, tunnel_id);\n\tif (tunnel && refcount_inc_not_zero(&tunnel->ref_count)) {\n\t\trcu_read_unlock_bh();\n\t\treturn tunnel;\n\t}\n\trcu_read_unlock_bh();\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(l2tp_tunnel_get);\n\nstruct l2tp_tunnel *l2tp_tunnel_get_nth(const struct net *net, int nth)\n{\n\tstruct l2tp_net *pn = l2tp_pernet(net);\n\tunsigned long tunnel_id, tmp;\n\tstruct l2tp_tunnel *tunnel;\n\tint count = 0;\n\n\trcu_read_lock_bh();\n\tidr_for_each_entry_ul(&pn->l2tp_tunnel_idr, tunnel, tmp, tunnel_id) {\n\t\tif (tunnel && ++count > nth &&\n\t\t    refcount_inc_not_zero(&tunnel->ref_count)) {\n\t\t\trcu_read_unlock_bh();\n\t\t\treturn tunnel;\n\t\t}\n\t}\n\trcu_read_unlock_bh();\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(l2tp_tunnel_get_nth);\n\nstruct l2tp_session *l2tp_tunnel_get_session(struct l2tp_tunnel *tunnel,\n\t\t\t\t\t     u32 session_id)\n{\n\tstruct hlist_head *session_list;\n\tstruct l2tp_session *session;\n\n\tsession_list = l2tp_session_id_hash(tunnel, session_id);\n\n\trcu_read_lock_bh();\n\thlist_for_each_entry_rcu(session, session_list, hlist)\n\t\tif (session->session_id == session_id) {\n\t\t\tl2tp_session_inc_refcount(session);\n\t\t\trcu_read_unlock_bh();\n\n\t\t\treturn session;\n\t\t}\n\trcu_read_unlock_bh();\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(l2tp_tunnel_get_session);\n\nstruct l2tp_session *l2tp_session_get(const struct net *net, u32 session_id)\n{\n\tstruct hlist_head *session_list;\n\tstruct l2tp_session *session;\n\n\tsession_list = l2tp_session_id_hash_2(l2tp_pernet(net), session_id);\n\n\trcu_read_lock_bh();\n\thlist_for_each_entry_rcu(session, session_list, global_hlist)\n\t\tif (session->session_id == session_id) {\n\t\t\tl2tp_session_inc_refcount(session);\n\t\t\trcu_read_unlock_bh();\n\n\t\t\treturn session;\n\t\t}\n\trcu_read_unlock_bh();\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(l2tp_session_get);\n\nstruct l2tp_session *l2tp_session_get_nth(struct l2tp_tunnel *tunnel, int nth)\n{\n\tint hash;\n\tstruct l2tp_session *session;\n\tint count = 0;\n\n\trcu_read_lock_bh();\n\tfor (hash = 0; hash < L2TP_HASH_SIZE; hash++) {\n\t\thlist_for_each_entry_rcu(session, &tunnel->session_hlist[hash], hlist) {\n\t\t\tif (++count > nth) {\n\t\t\t\tl2tp_session_inc_refcount(session);\n\t\t\t\trcu_read_unlock_bh();\n\t\t\t\treturn session;\n\t\t\t}\n\t\t}\n\t}\n\n\trcu_read_unlock_bh();\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(l2tp_session_get_nth);\n\n \nstruct l2tp_session *l2tp_session_get_by_ifname(const struct net *net,\n\t\t\t\t\t\tconst char *ifname)\n{\n\tstruct l2tp_net *pn = l2tp_pernet(net);\n\tint hash;\n\tstruct l2tp_session *session;\n\n\trcu_read_lock_bh();\n\tfor (hash = 0; hash < L2TP_HASH_SIZE_2; hash++) {\n\t\thlist_for_each_entry_rcu(session, &pn->l2tp_session_hlist[hash], global_hlist) {\n\t\t\tif (!strcmp(session->ifname, ifname)) {\n\t\t\t\tl2tp_session_inc_refcount(session);\n\t\t\t\trcu_read_unlock_bh();\n\n\t\t\t\treturn session;\n\t\t\t}\n\t\t}\n\t}\n\n\trcu_read_unlock_bh();\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(l2tp_session_get_by_ifname);\n\nint l2tp_session_register(struct l2tp_session *session,\n\t\t\t  struct l2tp_tunnel *tunnel)\n{\n\tstruct l2tp_session *session_walk;\n\tstruct hlist_head *g_head;\n\tstruct hlist_head *head;\n\tstruct l2tp_net *pn;\n\tint err;\n\n\thead = l2tp_session_id_hash(tunnel, session->session_id);\n\n\tspin_lock_bh(&tunnel->hlist_lock);\n\tif (!tunnel->acpt_newsess) {\n\t\terr = -ENODEV;\n\t\tgoto err_tlock;\n\t}\n\n\thlist_for_each_entry(session_walk, head, hlist)\n\t\tif (session_walk->session_id == session->session_id) {\n\t\t\terr = -EEXIST;\n\t\t\tgoto err_tlock;\n\t\t}\n\n\tif (tunnel->version == L2TP_HDR_VER_3) {\n\t\tpn = l2tp_pernet(tunnel->l2tp_net);\n\t\tg_head = l2tp_session_id_hash_2(pn, session->session_id);\n\n\t\tspin_lock_bh(&pn->l2tp_session_hlist_lock);\n\n\t\t \n\t\thlist_for_each_entry(session_walk, g_head, global_hlist)\n\t\t\tif (session_walk->session_id == session->session_id &&\n\t\t\t    (session_walk->tunnel->encap == L2TP_ENCAPTYPE_IP ||\n\t\t\t     tunnel->encap == L2TP_ENCAPTYPE_IP)) {\n\t\t\t\terr = -EEXIST;\n\t\t\t\tgoto err_tlock_pnlock;\n\t\t\t}\n\n\t\tl2tp_tunnel_inc_refcount(tunnel);\n\t\thlist_add_head_rcu(&session->global_hlist, g_head);\n\n\t\tspin_unlock_bh(&pn->l2tp_session_hlist_lock);\n\t} else {\n\t\tl2tp_tunnel_inc_refcount(tunnel);\n\t}\n\n\thlist_add_head_rcu(&session->hlist, head);\n\tspin_unlock_bh(&tunnel->hlist_lock);\n\n\ttrace_register_session(session);\n\n\treturn 0;\n\nerr_tlock_pnlock:\n\tspin_unlock_bh(&pn->l2tp_session_hlist_lock);\nerr_tlock:\n\tspin_unlock_bh(&tunnel->hlist_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(l2tp_session_register);\n\n \n\n \nstatic void l2tp_recv_queue_skb(struct l2tp_session *session, struct sk_buff *skb)\n{\n\tstruct sk_buff *skbp;\n\tstruct sk_buff *tmp;\n\tu32 ns = L2TP_SKB_CB(skb)->ns;\n\n\tspin_lock_bh(&session->reorder_q.lock);\n\tskb_queue_walk_safe(&session->reorder_q, skbp, tmp) {\n\t\tif (L2TP_SKB_CB(skbp)->ns > ns) {\n\t\t\t__skb_queue_before(&session->reorder_q, skbp, skb);\n\t\t\tatomic_long_inc(&session->stats.rx_oos_packets);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t__skb_queue_tail(&session->reorder_q, skb);\n\nout:\n\tspin_unlock_bh(&session->reorder_q.lock);\n}\n\n \nstatic void l2tp_recv_dequeue_skb(struct l2tp_session *session, struct sk_buff *skb)\n{\n\tstruct l2tp_tunnel *tunnel = session->tunnel;\n\tint length = L2TP_SKB_CB(skb)->length;\n\n\t \n\tskb_orphan(skb);\n\n\tatomic_long_inc(&tunnel->stats.rx_packets);\n\tatomic_long_add(length, &tunnel->stats.rx_bytes);\n\tatomic_long_inc(&session->stats.rx_packets);\n\tatomic_long_add(length, &session->stats.rx_bytes);\n\n\tif (L2TP_SKB_CB(skb)->has_seq) {\n\t\t \n\t\tsession->nr++;\n\t\tsession->nr &= session->nr_max;\n\t\ttrace_session_seqnum_update(session);\n\t}\n\n\t \n\tif (session->recv_skb)\n\t\t(*session->recv_skb)(session, skb, L2TP_SKB_CB(skb)->length);\n\telse\n\t\tkfree_skb(skb);\n}\n\n \nstatic void l2tp_recv_dequeue(struct l2tp_session *session)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *tmp;\n\n\t \nstart:\n\tspin_lock_bh(&session->reorder_q.lock);\n\tskb_queue_walk_safe(&session->reorder_q, skb, tmp) {\n\t\tstruct l2tp_skb_cb *cb = L2TP_SKB_CB(skb);\n\n\t\t \n\t\tif (time_after(jiffies, cb->expires)) {\n\t\t\tatomic_long_inc(&session->stats.rx_seq_discards);\n\t\t\tatomic_long_inc(&session->stats.rx_errors);\n\t\t\ttrace_session_pkt_expired(session, cb->ns);\n\t\t\tsession->reorder_skip = 1;\n\t\t\t__skb_unlink(skb, &session->reorder_q);\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cb->has_seq) {\n\t\t\tif (session->reorder_skip) {\n\t\t\t\tsession->reorder_skip = 0;\n\t\t\t\tsession->nr = cb->ns;\n\t\t\t\ttrace_session_seqnum_reset(session);\n\t\t\t}\n\t\t\tif (cb->ns != session->nr)\n\t\t\t\tgoto out;\n\t\t}\n\t\t__skb_unlink(skb, &session->reorder_q);\n\n\t\t \n\t\tspin_unlock_bh(&session->reorder_q.lock);\n\t\tl2tp_recv_dequeue_skb(session, skb);\n\t\tgoto start;\n\t}\n\nout:\n\tspin_unlock_bh(&session->reorder_q.lock);\n}\n\nstatic int l2tp_seq_check_rx_window(struct l2tp_session *session, u32 nr)\n{\n\tu32 nws;\n\n\tif (nr >= session->nr)\n\t\tnws = nr - session->nr;\n\telse\n\t\tnws = (session->nr_max + 1) - (session->nr - nr);\n\n\treturn nws < session->nr_window_size;\n}\n\n \nstatic int l2tp_recv_data_seq(struct l2tp_session *session, struct sk_buff *skb)\n{\n\tstruct l2tp_skb_cb *cb = L2TP_SKB_CB(skb);\n\n\tif (!l2tp_seq_check_rx_window(session, cb->ns)) {\n\t\t \n\t\ttrace_session_pkt_outside_rx_window(session, cb->ns);\n\t\tgoto discard;\n\t}\n\n\tif (session->reorder_timeout != 0) {\n\t\t \n\t\tl2tp_recv_queue_skb(session, skb);\n\t\tgoto out;\n\t}\n\n\t \n\tif (cb->ns == session->nr) {\n\t\tskb_queue_tail(&session->reorder_q, skb);\n\t} else {\n\t\tu32 nr_oos = cb->ns;\n\t\tu32 nr_next = (session->nr_oos + 1) & session->nr_max;\n\n\t\tif (nr_oos == nr_next)\n\t\t\tsession->nr_oos_count++;\n\t\telse\n\t\t\tsession->nr_oos_count = 0;\n\n\t\tsession->nr_oos = nr_oos;\n\t\tif (session->nr_oos_count > session->nr_oos_count_max) {\n\t\t\tsession->reorder_skip = 1;\n\t\t}\n\t\tif (!session->reorder_skip) {\n\t\t\tatomic_long_inc(&session->stats.rx_seq_discards);\n\t\t\ttrace_session_pkt_oos(session, cb->ns);\n\t\t\tgoto discard;\n\t\t}\n\t\tskb_queue_tail(&session->reorder_q, skb);\n\t}\n\nout:\n\treturn 0;\n\ndiscard:\n\treturn 1;\n}\n\n \nvoid l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,\n\t\t      unsigned char *ptr, unsigned char *optr, u16 hdrflags,\n\t\t      int length)\n{\n\tstruct l2tp_tunnel *tunnel = session->tunnel;\n\tint offset;\n\n\t \n\tif (session->peer_cookie_len > 0) {\n\t\tif (memcmp(ptr, &session->peer_cookie[0], session->peer_cookie_len)) {\n\t\t\tpr_debug_ratelimited(\"%s: cookie mismatch (%u/%u). Discarding.\\n\",\n\t\t\t\t\t     tunnel->name, tunnel->tunnel_id,\n\t\t\t\t\t     session->session_id);\n\t\t\tatomic_long_inc(&session->stats.rx_cookie_discards);\n\t\t\tgoto discard;\n\t\t}\n\t\tptr += session->peer_cookie_len;\n\t}\n\n\t \n\tL2TP_SKB_CB(skb)->has_seq = 0;\n\tif (tunnel->version == L2TP_HDR_VER_2) {\n\t\tif (hdrflags & L2TP_HDRFLAG_S) {\n\t\t\t \n\t\t\tL2TP_SKB_CB(skb)->ns = ntohs(*(__be16 *)ptr);\n\t\t\tL2TP_SKB_CB(skb)->has_seq = 1;\n\t\t\tptr += 2;\n\t\t\t \n\t\t\tptr += 2;\n\n\t\t}\n\t} else if (session->l2specific_type == L2TP_L2SPECTYPE_DEFAULT) {\n\t\tu32 l2h = ntohl(*(__be32 *)ptr);\n\n\t\tif (l2h & 0x40000000) {\n\t\t\t \n\t\t\tL2TP_SKB_CB(skb)->ns = l2h & 0x00ffffff;\n\t\t\tL2TP_SKB_CB(skb)->has_seq = 1;\n\t\t}\n\t\tptr += 4;\n\t}\n\n\tif (L2TP_SKB_CB(skb)->has_seq) {\n\t\t \n\t\tif (!session->lns_mode && !session->send_seq) {\n\t\t\ttrace_session_seqnum_lns_enable(session);\n\t\t\tsession->send_seq = 1;\n\t\t\tl2tp_session_set_header_len(session, tunnel->version);\n\t\t}\n\t} else {\n\t\t \n\t\tif (session->recv_seq) {\n\t\t\tpr_debug_ratelimited(\"%s: recv data has no seq numbers when required. Discarding.\\n\",\n\t\t\t\t\t     session->name);\n\t\t\tatomic_long_inc(&session->stats.rx_seq_discards);\n\t\t\tgoto discard;\n\t\t}\n\n\t\t \n\t\tif (!session->lns_mode && session->send_seq) {\n\t\t\ttrace_session_seqnum_lns_disable(session);\n\t\t\tsession->send_seq = 0;\n\t\t\tl2tp_session_set_header_len(session, tunnel->version);\n\t\t} else if (session->send_seq) {\n\t\t\tpr_debug_ratelimited(\"%s: recv data has no seq numbers when required. Discarding.\\n\",\n\t\t\t\t\t     session->name);\n\t\t\tatomic_long_inc(&session->stats.rx_seq_discards);\n\t\t\tgoto discard;\n\t\t}\n\t}\n\n\t \n\tif (tunnel->version == L2TP_HDR_VER_2) {\n\t\t \n\t\tif (hdrflags & L2TP_HDRFLAG_O) {\n\t\t\toffset = ntohs(*(__be16 *)ptr);\n\t\t\tptr += 2 + offset;\n\t\t}\n\t}\n\n\toffset = ptr - optr;\n\tif (!pskb_may_pull(skb, offset))\n\t\tgoto discard;\n\n\t__skb_pull(skb, offset);\n\n\t \n\tL2TP_SKB_CB(skb)->length = length;\n\tL2TP_SKB_CB(skb)->expires = jiffies +\n\t\t(session->reorder_timeout ? session->reorder_timeout : HZ);\n\n\t \n\tif (L2TP_SKB_CB(skb)->has_seq) {\n\t\tif (l2tp_recv_data_seq(session, skb))\n\t\t\tgoto discard;\n\t} else {\n\t\t \n\t\tskb_queue_tail(&session->reorder_q, skb);\n\t}\n\n\t \n\tl2tp_recv_dequeue(session);\n\n\treturn;\n\ndiscard:\n\tatomic_long_inc(&session->stats.rx_errors);\n\tkfree_skb(skb);\n}\nEXPORT_SYMBOL_GPL(l2tp_recv_common);\n\n \nstatic void l2tp_session_queue_purge(struct l2tp_session *session)\n{\n\tstruct sk_buff *skb = NULL;\n\n\twhile ((skb = skb_dequeue(&session->reorder_q))) {\n\t\tatomic_long_inc(&session->stats.rx_errors);\n\t\tkfree_skb(skb);\n\t}\n}\n\n \nstatic int l2tp_udp_recv_core(struct l2tp_tunnel *tunnel, struct sk_buff *skb)\n{\n\tstruct l2tp_session *session = NULL;\n\tunsigned char *ptr, *optr;\n\tu16 hdrflags;\n\tu32 tunnel_id, session_id;\n\tu16 version;\n\tint length;\n\n\t \n\n\t \n\t__skb_pull(skb, sizeof(struct udphdr));\n\n\t \n\tif (!pskb_may_pull(skb, L2TP_HDR_SIZE_MAX)) {\n\t\tpr_debug_ratelimited(\"%s: recv short packet (len=%d)\\n\",\n\t\t\t\t     tunnel->name, skb->len);\n\t\tgoto invalid;\n\t}\n\n\t \n\toptr = skb->data;\n\tptr = skb->data;\n\n\t \n\thdrflags = ntohs(*(__be16 *)ptr);\n\n\t \n\tversion = hdrflags & L2TP_HDR_VER_MASK;\n\tif (version != tunnel->version) {\n\t\tpr_debug_ratelimited(\"%s: recv protocol version mismatch: got %d expected %d\\n\",\n\t\t\t\t     tunnel->name, version, tunnel->version);\n\t\tgoto invalid;\n\t}\n\n\t \n\tlength = skb->len;\n\n\t \n\tif (hdrflags & L2TP_HDRFLAG_T)\n\t\tgoto pass;\n\n\t \n\tptr += 2;\n\n\tif (tunnel->version == L2TP_HDR_VER_2) {\n\t\t \n\t\tif (hdrflags & L2TP_HDRFLAG_L)\n\t\t\tptr += 2;\n\n\t\t \n\t\ttunnel_id = ntohs(*(__be16 *)ptr);\n\t\tptr += 2;\n\t\tsession_id = ntohs(*(__be16 *)ptr);\n\t\tptr += 2;\n\t} else {\n\t\tptr += 2;\t \n\t\ttunnel_id = tunnel->tunnel_id;\n\t\tsession_id = ntohl(*(__be32 *)ptr);\n\t\tptr += 4;\n\t}\n\n\t \n\tsession = l2tp_tunnel_get_session(tunnel, session_id);\n\tif (!session || !session->recv_skb) {\n\t\tif (session)\n\t\t\tl2tp_session_dec_refcount(session);\n\n\t\t \n\t\tpr_debug_ratelimited(\"%s: no session found (%u/%u). Passing up.\\n\",\n\t\t\t\t     tunnel->name, tunnel_id, session_id);\n\t\tgoto pass;\n\t}\n\n\tif (tunnel->version == L2TP_HDR_VER_3 &&\n\t    l2tp_v3_ensure_opt_in_linear(session, skb, &ptr, &optr)) {\n\t\tl2tp_session_dec_refcount(session);\n\t\tgoto invalid;\n\t}\n\n\tl2tp_recv_common(session, skb, ptr, optr, hdrflags, length);\n\tl2tp_session_dec_refcount(session);\n\n\treturn 0;\n\ninvalid:\n\tatomic_long_inc(&tunnel->stats.rx_invalid);\n\npass:\n\t \n\t__skb_push(skb, sizeof(struct udphdr));\n\n\treturn 1;\n}\n\n \nint l2tp_udp_encap_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct l2tp_tunnel *tunnel;\n\n\t \n\ttunnel = rcu_dereference_sk_user_data(sk);\n\tif (!tunnel)\n\t\tgoto pass_up;\n\tif (WARN_ON(tunnel->magic != L2TP_TUNNEL_MAGIC))\n\t\tgoto pass_up;\n\n\tif (l2tp_udp_recv_core(tunnel, skb))\n\t\tgoto pass_up;\n\n\treturn 0;\n\npass_up:\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(l2tp_udp_encap_recv);\n\n \n\n \nstatic int l2tp_build_l2tpv2_header(struct l2tp_session *session, void *buf)\n{\n\tstruct l2tp_tunnel *tunnel = session->tunnel;\n\t__be16 *bufp = buf;\n\t__be16 *optr = buf;\n\tu16 flags = L2TP_HDR_VER_2;\n\tu32 tunnel_id = tunnel->peer_tunnel_id;\n\tu32 session_id = session->peer_session_id;\n\n\tif (session->send_seq)\n\t\tflags |= L2TP_HDRFLAG_S;\n\n\t \n\t*bufp++ = htons(flags);\n\t*bufp++ = htons(tunnel_id);\n\t*bufp++ = htons(session_id);\n\tif (session->send_seq) {\n\t\t*bufp++ = htons(session->ns);\n\t\t*bufp++ = 0;\n\t\tsession->ns++;\n\t\tsession->ns &= 0xffff;\n\t\ttrace_session_seqnum_update(session);\n\t}\n\n\treturn bufp - optr;\n}\n\nstatic int l2tp_build_l2tpv3_header(struct l2tp_session *session, void *buf)\n{\n\tstruct l2tp_tunnel *tunnel = session->tunnel;\n\tchar *bufp = buf;\n\tchar *optr = bufp;\n\n\t \n\tif (tunnel->encap == L2TP_ENCAPTYPE_UDP) {\n\t\tu16 flags = L2TP_HDR_VER_3;\n\t\t*((__be16 *)bufp) = htons(flags);\n\t\tbufp += 2;\n\t\t*((__be16 *)bufp) = 0;\n\t\tbufp += 2;\n\t}\n\n\t*((__be32 *)bufp) = htonl(session->peer_session_id);\n\tbufp += 4;\n\tif (session->cookie_len) {\n\t\tmemcpy(bufp, &session->cookie[0], session->cookie_len);\n\t\tbufp += session->cookie_len;\n\t}\n\tif (session->l2specific_type == L2TP_L2SPECTYPE_DEFAULT) {\n\t\tu32 l2h = 0;\n\n\t\tif (session->send_seq) {\n\t\t\tl2h = 0x40000000 | session->ns;\n\t\t\tsession->ns++;\n\t\t\tsession->ns &= 0xffffff;\n\t\t\ttrace_session_seqnum_update(session);\n\t\t}\n\n\t\t*((__be32 *)bufp) = htonl(l2h);\n\t\tbufp += 4;\n\t}\n\n\treturn bufp - optr;\n}\n\n \nstatic int l2tp_xmit_queue(struct l2tp_tunnel *tunnel, struct sk_buff *skb, struct flowi *fl)\n{\n\tint err;\n\n\tskb->ignore_df = 1;\n\tskb_dst_drop(skb);\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (l2tp_sk_is_v6(tunnel->sock))\n\t\terr = inet6_csk_xmit(tunnel->sock, skb, NULL);\n\telse\n#endif\n\t\terr = ip_queue_xmit(tunnel->sock, skb, fl);\n\n\treturn err >= 0 ? NET_XMIT_SUCCESS : NET_XMIT_DROP;\n}\n\nstatic int l2tp_xmit_core(struct l2tp_session *session, struct sk_buff *skb, unsigned int *len)\n{\n\tstruct l2tp_tunnel *tunnel = session->tunnel;\n\tunsigned int data_len = skb->len;\n\tstruct sock *sk = tunnel->sock;\n\tint headroom, uhlen, udp_len;\n\tint ret = NET_XMIT_SUCCESS;\n\tstruct inet_sock *inet;\n\tstruct udphdr *uh;\n\n\t \n\tuhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(*uh) : 0;\n\theadroom = NET_SKB_PAD + sizeof(struct iphdr) + uhlen + session->hdr_len;\n\tif (skb_cow_head(skb, headroom)) {\n\t\tkfree_skb(skb);\n\t\treturn NET_XMIT_DROP;\n\t}\n\n\t \n\tif (tunnel->version == L2TP_HDR_VER_2)\n\t\tl2tp_build_l2tpv2_header(session, __skb_push(skb, session->hdr_len));\n\telse\n\t\tl2tp_build_l2tpv3_header(session, __skb_push(skb, session->hdr_len));\n\n\t \n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\tIPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED | IPSKB_REROUTED);\n\tnf_reset_ct(skb);\n\n\tbh_lock_sock_nested(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tkfree_skb(skb);\n\t\tret = NET_XMIT_DROP;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (tunnel->fd >= 0 && sk->sk_state != TCP_ESTABLISHED) {\n\t\tkfree_skb(skb);\n\t\tret = NET_XMIT_DROP;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\t*len = skb->len;\n\n\tinet = inet_sk(sk);\n\tswitch (tunnel->encap) {\n\tcase L2TP_ENCAPTYPE_UDP:\n\t\t \n\t\t__skb_push(skb, sizeof(*uh));\n\t\tskb_reset_transport_header(skb);\n\t\tuh = udp_hdr(skb);\n\t\tuh->source = inet->inet_sport;\n\t\tuh->dest = inet->inet_dport;\n\t\tudp_len = uhlen + session->hdr_len + data_len;\n\t\tuh->len = htons(udp_len);\n\n\t\t \n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (l2tp_sk_is_v6(sk))\n\t\t\tudp6_set_csum(udp_get_no_check6_tx(sk),\n\t\t\t\t      skb, &inet6_sk(sk)->saddr,\n\t\t\t\t      &sk->sk_v6_daddr, udp_len);\n\t\telse\n#endif\n\t\t\tudp_set_csum(sk->sk_no_check_tx, skb, inet->inet_saddr,\n\t\t\t\t     inet->inet_daddr, udp_len);\n\t\tbreak;\n\n\tcase L2TP_ENCAPTYPE_IP:\n\t\tbreak;\n\t}\n\n\tret = l2tp_xmit_queue(tunnel, skb, &inet->cork.fl);\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\n\treturn ret;\n}\n\n \nint l2tp_xmit_skb(struct l2tp_session *session, struct sk_buff *skb)\n{\n\tunsigned int len = 0;\n\tint ret;\n\n\tret = l2tp_xmit_core(session, skb, &len);\n\tif (ret == NET_XMIT_SUCCESS) {\n\t\tatomic_long_inc(&session->tunnel->stats.tx_packets);\n\t\tatomic_long_add(len, &session->tunnel->stats.tx_bytes);\n\t\tatomic_long_inc(&session->stats.tx_packets);\n\t\tatomic_long_add(len, &session->stats.tx_bytes);\n\t} else {\n\t\tatomic_long_inc(&session->tunnel->stats.tx_errors);\n\t\tatomic_long_inc(&session->stats.tx_errors);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(l2tp_xmit_skb);\n\n \n\n \nstatic void l2tp_tunnel_destruct(struct sock *sk)\n{\n\tstruct l2tp_tunnel *tunnel = l2tp_sk_to_tunnel(sk);\n\n\tif (!tunnel)\n\t\tgoto end;\n\n\t \n\tswitch (tunnel->encap) {\n\tcase L2TP_ENCAPTYPE_UDP:\n\t\t \n\t\tWRITE_ONCE(udp_sk(sk)->encap_type, 0);\n\t\tudp_sk(sk)->encap_rcv = NULL;\n\t\tudp_sk(sk)->encap_destroy = NULL;\n\t\tbreak;\n\tcase L2TP_ENCAPTYPE_IP:\n\t\tbreak;\n\t}\n\n\t \n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsk->sk_destruct = tunnel->old_sk_destruct;\n\tsk->sk_user_data = NULL;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\t \n\tif (sk->sk_destruct)\n\t\t(*sk->sk_destruct)(sk);\n\n\tkfree_rcu(tunnel, rcu);\nend:\n\treturn;\n}\n\n \nstatic void l2tp_session_unhash(struct l2tp_session *session)\n{\n\tstruct l2tp_tunnel *tunnel = session->tunnel;\n\n\t \n\tif (tunnel) {\n\t\t \n\t\tspin_lock_bh(&tunnel->hlist_lock);\n\t\thlist_del_init_rcu(&session->hlist);\n\t\tspin_unlock_bh(&tunnel->hlist_lock);\n\n\t\t \n\t\tif (tunnel->version != L2TP_HDR_VER_2) {\n\t\t\tstruct l2tp_net *pn = l2tp_pernet(tunnel->l2tp_net);\n\n\t\t\tspin_lock_bh(&pn->l2tp_session_hlist_lock);\n\t\t\thlist_del_init_rcu(&session->global_hlist);\n\t\t\tspin_unlock_bh(&pn->l2tp_session_hlist_lock);\n\t\t}\n\n\t\tsynchronize_rcu();\n\t}\n}\n\n \nstatic void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel)\n{\n\tstruct l2tp_session *session;\n\tint hash;\n\n\tspin_lock_bh(&tunnel->hlist_lock);\n\ttunnel->acpt_newsess = false;\n\tfor (hash = 0; hash < L2TP_HASH_SIZE; hash++) {\nagain:\n\t\thlist_for_each_entry_rcu(session, &tunnel->session_hlist[hash], hlist) {\n\t\t\thlist_del_init_rcu(&session->hlist);\n\n\t\t\tspin_unlock_bh(&tunnel->hlist_lock);\n\t\t\tl2tp_session_delete(session);\n\t\t\tspin_lock_bh(&tunnel->hlist_lock);\n\n\t\t\t \n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&tunnel->hlist_lock);\n}\n\n \nstatic void l2tp_udp_encap_destroy(struct sock *sk)\n{\n\tstruct l2tp_tunnel *tunnel = l2tp_sk_to_tunnel(sk);\n\n\tif (tunnel)\n\t\tl2tp_tunnel_delete(tunnel);\n}\n\nstatic void l2tp_tunnel_remove(struct net *net, struct l2tp_tunnel *tunnel)\n{\n\tstruct l2tp_net *pn = l2tp_pernet(net);\n\n\tspin_lock_bh(&pn->l2tp_tunnel_idr_lock);\n\tidr_remove(&pn->l2tp_tunnel_idr, tunnel->tunnel_id);\n\tspin_unlock_bh(&pn->l2tp_tunnel_idr_lock);\n}\n\n \nstatic void l2tp_tunnel_del_work(struct work_struct *work)\n{\n\tstruct l2tp_tunnel *tunnel = container_of(work, struct l2tp_tunnel,\n\t\t\t\t\t\t  del_work);\n\tstruct sock *sk = tunnel->sock;\n\tstruct socket *sock = sk->sk_socket;\n\n\tl2tp_tunnel_closeall(tunnel);\n\n\t \n\tif (tunnel->fd < 0) {\n\t\tif (sock) {\n\t\t\tkernel_sock_shutdown(sock, SHUT_RDWR);\n\t\t\tsock_release(sock);\n\t\t}\n\t}\n\n\tl2tp_tunnel_remove(tunnel->l2tp_net, tunnel);\n\t \n\tl2tp_tunnel_dec_refcount(tunnel);\n\n\t \n\tl2tp_tunnel_dec_refcount(tunnel);\n}\n\n \nstatic int l2tp_tunnel_sock_create(struct net *net,\n\t\t\t\t   u32 tunnel_id,\n\t\t\t\t   u32 peer_tunnel_id,\n\t\t\t\t   struct l2tp_tunnel_cfg *cfg,\n\t\t\t\t   struct socket **sockp)\n{\n\tint err = -EINVAL;\n\tstruct socket *sock = NULL;\n\tstruct udp_port_cfg udp_conf;\n\n\tswitch (cfg->encap) {\n\tcase L2TP_ENCAPTYPE_UDP:\n\t\tmemset(&udp_conf, 0, sizeof(udp_conf));\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (cfg->local_ip6 && cfg->peer_ip6) {\n\t\t\tudp_conf.family = AF_INET6;\n\t\t\tmemcpy(&udp_conf.local_ip6, cfg->local_ip6,\n\t\t\t       sizeof(udp_conf.local_ip6));\n\t\t\tmemcpy(&udp_conf.peer_ip6, cfg->peer_ip6,\n\t\t\t       sizeof(udp_conf.peer_ip6));\n\t\t\tudp_conf.use_udp6_tx_checksums =\n\t\t\t  !cfg->udp6_zero_tx_checksums;\n\t\t\tudp_conf.use_udp6_rx_checksums =\n\t\t\t  !cfg->udp6_zero_rx_checksums;\n\t\t} else\n#endif\n\t\t{\n\t\t\tudp_conf.family = AF_INET;\n\t\t\tudp_conf.local_ip = cfg->local_ip;\n\t\t\tudp_conf.peer_ip = cfg->peer_ip;\n\t\t\tudp_conf.use_udp_checksums = cfg->use_udp_checksums;\n\t\t}\n\n\t\tudp_conf.local_udp_port = htons(cfg->local_udp_port);\n\t\tudp_conf.peer_udp_port = htons(cfg->peer_udp_port);\n\n\t\terr = udp_sock_create(net, &udp_conf, &sock);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\tbreak;\n\n\tcase L2TP_ENCAPTYPE_IP:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (cfg->local_ip6 && cfg->peer_ip6) {\n\t\t\tstruct sockaddr_l2tpip6 ip6_addr = {0};\n\n\t\t\terr = sock_create_kern(net, AF_INET6, SOCK_DGRAM,\n\t\t\t\t\t       IPPROTO_L2TP, &sock);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\tip6_addr.l2tp_family = AF_INET6;\n\t\t\tmemcpy(&ip6_addr.l2tp_addr, cfg->local_ip6,\n\t\t\t       sizeof(ip6_addr.l2tp_addr));\n\t\t\tip6_addr.l2tp_conn_id = tunnel_id;\n\t\t\terr = kernel_bind(sock, (struct sockaddr *)&ip6_addr,\n\t\t\t\t\t  sizeof(ip6_addr));\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\tip6_addr.l2tp_family = AF_INET6;\n\t\t\tmemcpy(&ip6_addr.l2tp_addr, cfg->peer_ip6,\n\t\t\t       sizeof(ip6_addr.l2tp_addr));\n\t\t\tip6_addr.l2tp_conn_id = peer_tunnel_id;\n\t\t\terr = kernel_connect(sock,\n\t\t\t\t\t     (struct sockaddr *)&ip6_addr,\n\t\t\t\t\t     sizeof(ip6_addr), 0);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t} else\n#endif\n\t\t{\n\t\t\tstruct sockaddr_l2tpip ip_addr = {0};\n\n\t\t\terr = sock_create_kern(net, AF_INET, SOCK_DGRAM,\n\t\t\t\t\t       IPPROTO_L2TP, &sock);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\tip_addr.l2tp_family = AF_INET;\n\t\t\tip_addr.l2tp_addr = cfg->local_ip;\n\t\t\tip_addr.l2tp_conn_id = tunnel_id;\n\t\t\terr = kernel_bind(sock, (struct sockaddr *)&ip_addr,\n\t\t\t\t\t  sizeof(ip_addr));\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t\tip_addr.l2tp_family = AF_INET;\n\t\t\tip_addr.l2tp_addr = cfg->peer_ip;\n\t\t\tip_addr.l2tp_conn_id = peer_tunnel_id;\n\t\t\terr = kernel_connect(sock, (struct sockaddr *)&ip_addr,\n\t\t\t\t\t     sizeof(ip_addr), 0);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\nout:\n\t*sockp = sock;\n\tif (err < 0 && sock) {\n\t\tkernel_sock_shutdown(sock, SHUT_RDWR);\n\t\tsock_release(sock);\n\t\t*sockp = NULL;\n\t}\n\n\treturn err;\n}\n\nint l2tp_tunnel_create(int fd, int version, u32 tunnel_id, u32 peer_tunnel_id,\n\t\t       struct l2tp_tunnel_cfg *cfg, struct l2tp_tunnel **tunnelp)\n{\n\tstruct l2tp_tunnel *tunnel = NULL;\n\tint err;\n\tenum l2tp_encap_type encap = L2TP_ENCAPTYPE_UDP;\n\n\tif (cfg)\n\t\tencap = cfg->encap;\n\n\ttunnel = kzalloc(sizeof(*tunnel), GFP_KERNEL);\n\tif (!tunnel) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\ttunnel->version = version;\n\ttunnel->tunnel_id = tunnel_id;\n\ttunnel->peer_tunnel_id = peer_tunnel_id;\n\n\ttunnel->magic = L2TP_TUNNEL_MAGIC;\n\tsprintf(&tunnel->name[0], \"tunl %u\", tunnel_id);\n\tspin_lock_init(&tunnel->hlist_lock);\n\ttunnel->acpt_newsess = true;\n\n\ttunnel->encap = encap;\n\n\trefcount_set(&tunnel->ref_count, 1);\n\ttunnel->fd = fd;\n\n\t \n\tINIT_WORK(&tunnel->del_work, l2tp_tunnel_del_work);\n\n\tINIT_LIST_HEAD(&tunnel->list);\n\n\terr = 0;\nerr:\n\tif (tunnelp)\n\t\t*tunnelp = tunnel;\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(l2tp_tunnel_create);\n\nstatic int l2tp_validate_socket(const struct sock *sk, const struct net *net,\n\t\t\t\tenum l2tp_encap_type encap)\n{\n\tif (!net_eq(sock_net(sk), net))\n\t\treturn -EINVAL;\n\n\tif (sk->sk_type != SOCK_DGRAM)\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (sk->sk_family != PF_INET && sk->sk_family != PF_INET6)\n\t\treturn -EPROTONOSUPPORT;\n\n\tif ((encap == L2TP_ENCAPTYPE_UDP && sk->sk_protocol != IPPROTO_UDP) ||\n\t    (encap == L2TP_ENCAPTYPE_IP && sk->sk_protocol != IPPROTO_L2TP))\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (sk->sk_user_data)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nint l2tp_tunnel_register(struct l2tp_tunnel *tunnel, struct net *net,\n\t\t\t struct l2tp_tunnel_cfg *cfg)\n{\n\tstruct l2tp_net *pn = l2tp_pernet(net);\n\tu32 tunnel_id = tunnel->tunnel_id;\n\tstruct socket *sock;\n\tstruct sock *sk;\n\tint ret;\n\n\tspin_lock_bh(&pn->l2tp_tunnel_idr_lock);\n\tret = idr_alloc_u32(&pn->l2tp_tunnel_idr, NULL, &tunnel_id, tunnel_id,\n\t\t\t    GFP_ATOMIC);\n\tspin_unlock_bh(&pn->l2tp_tunnel_idr_lock);\n\tif (ret)\n\t\treturn ret == -ENOSPC ? -EEXIST : ret;\n\n\tif (tunnel->fd < 0) {\n\t\tret = l2tp_tunnel_sock_create(net, tunnel->tunnel_id,\n\t\t\t\t\t      tunnel->peer_tunnel_id, cfg,\n\t\t\t\t\t      &sock);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t} else {\n\t\tsock = sockfd_lookup(tunnel->fd, &ret);\n\t\tif (!sock)\n\t\t\tgoto err;\n\t}\n\n\tsk = sock->sk;\n\tlock_sock(sk);\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tret = l2tp_validate_socket(sk, net, tunnel->encap);\n\tif (ret < 0)\n\t\tgoto err_inval_sock;\n\trcu_assign_sk_user_data(sk, tunnel);\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\n\tif (tunnel->encap == L2TP_ENCAPTYPE_UDP) {\n\t\tstruct udp_tunnel_sock_cfg udp_cfg = {\n\t\t\t.sk_user_data = tunnel,\n\t\t\t.encap_type = UDP_ENCAP_L2TPINUDP,\n\t\t\t.encap_rcv = l2tp_udp_encap_recv,\n\t\t\t.encap_destroy = l2tp_udp_encap_destroy,\n\t\t};\n\n\t\tsetup_udp_tunnel_sock(net, sock, &udp_cfg);\n\t}\n\n\ttunnel->old_sk_destruct = sk->sk_destruct;\n\tsk->sk_destruct = &l2tp_tunnel_destruct;\n\tsk->sk_allocation = GFP_ATOMIC;\n\trelease_sock(sk);\n\n\tsock_hold(sk);\n\ttunnel->sock = sk;\n\ttunnel->l2tp_net = net;\n\n\tspin_lock_bh(&pn->l2tp_tunnel_idr_lock);\n\tidr_replace(&pn->l2tp_tunnel_idr, tunnel, tunnel->tunnel_id);\n\tspin_unlock_bh(&pn->l2tp_tunnel_idr_lock);\n\n\ttrace_register_tunnel(tunnel);\n\n\tif (tunnel->fd >= 0)\n\t\tsockfd_put(sock);\n\n\treturn 0;\n\nerr_inval_sock:\n\twrite_unlock_bh(&sk->sk_callback_lock);\n\trelease_sock(sk);\n\n\tif (tunnel->fd < 0)\n\t\tsock_release(sock);\n\telse\n\t\tsockfd_put(sock);\nerr:\n\tl2tp_tunnel_remove(net, tunnel);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(l2tp_tunnel_register);\n\n \nvoid l2tp_tunnel_delete(struct l2tp_tunnel *tunnel)\n{\n\tif (!test_and_set_bit(0, &tunnel->dead)) {\n\t\ttrace_delete_tunnel(tunnel);\n\t\tl2tp_tunnel_inc_refcount(tunnel);\n\t\tqueue_work(l2tp_wq, &tunnel->del_work);\n\t}\n}\nEXPORT_SYMBOL_GPL(l2tp_tunnel_delete);\n\nvoid l2tp_session_delete(struct l2tp_session *session)\n{\n\tif (test_and_set_bit(0, &session->dead))\n\t\treturn;\n\n\ttrace_delete_session(session);\n\tl2tp_session_unhash(session);\n\tl2tp_session_queue_purge(session);\n\tif (session->session_close)\n\t\t(*session->session_close)(session);\n\n\tl2tp_session_dec_refcount(session);\n}\nEXPORT_SYMBOL_GPL(l2tp_session_delete);\n\n \nvoid l2tp_session_set_header_len(struct l2tp_session *session, int version)\n{\n\tif (version == L2TP_HDR_VER_2) {\n\t\tsession->hdr_len = 6;\n\t\tif (session->send_seq)\n\t\t\tsession->hdr_len += 4;\n\t} else {\n\t\tsession->hdr_len = 4 + session->cookie_len;\n\t\tsession->hdr_len += l2tp_get_l2specific_len(session);\n\t\tif (session->tunnel->encap == L2TP_ENCAPTYPE_UDP)\n\t\t\tsession->hdr_len += 4;\n\t}\n}\nEXPORT_SYMBOL_GPL(l2tp_session_set_header_len);\n\nstruct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunnel, u32 session_id,\n\t\t\t\t\t u32 peer_session_id, struct l2tp_session_cfg *cfg)\n{\n\tstruct l2tp_session *session;\n\n\tsession = kzalloc(sizeof(*session) + priv_size, GFP_KERNEL);\n\tif (session) {\n\t\tsession->magic = L2TP_SESSION_MAGIC;\n\t\tsession->tunnel = tunnel;\n\n\t\tsession->session_id = session_id;\n\t\tsession->peer_session_id = peer_session_id;\n\t\tsession->nr = 0;\n\t\tif (tunnel->version == L2TP_HDR_VER_2)\n\t\t\tsession->nr_max = 0xffff;\n\t\telse\n\t\t\tsession->nr_max = 0xffffff;\n\t\tsession->nr_window_size = session->nr_max / 2;\n\t\tsession->nr_oos_count_max = 4;\n\n\t\t \n\t\tsession->reorder_skip = 1;\n\n\t\tsprintf(&session->name[0], \"sess %u/%u\",\n\t\t\ttunnel->tunnel_id, session->session_id);\n\n\t\tskb_queue_head_init(&session->reorder_q);\n\n\t\tINIT_HLIST_NODE(&session->hlist);\n\t\tINIT_HLIST_NODE(&session->global_hlist);\n\n\t\tif (cfg) {\n\t\t\tsession->pwtype = cfg->pw_type;\n\t\t\tsession->send_seq = cfg->send_seq;\n\t\t\tsession->recv_seq = cfg->recv_seq;\n\t\t\tsession->lns_mode = cfg->lns_mode;\n\t\t\tsession->reorder_timeout = cfg->reorder_timeout;\n\t\t\tsession->l2specific_type = cfg->l2specific_type;\n\t\t\tsession->cookie_len = cfg->cookie_len;\n\t\t\tmemcpy(&session->cookie[0], &cfg->cookie[0], cfg->cookie_len);\n\t\t\tsession->peer_cookie_len = cfg->peer_cookie_len;\n\t\t\tmemcpy(&session->peer_cookie[0], &cfg->peer_cookie[0], cfg->peer_cookie_len);\n\t\t}\n\n\t\tl2tp_session_set_header_len(session, tunnel->version);\n\n\t\trefcount_set(&session->ref_count, 1);\n\n\t\treturn session;\n\t}\n\n\treturn ERR_PTR(-ENOMEM);\n}\nEXPORT_SYMBOL_GPL(l2tp_session_create);\n\n \n\nstatic __net_init int l2tp_init_net(struct net *net)\n{\n\tstruct l2tp_net *pn = net_generic(net, l2tp_net_id);\n\tint hash;\n\n\tidr_init(&pn->l2tp_tunnel_idr);\n\tspin_lock_init(&pn->l2tp_tunnel_idr_lock);\n\n\tfor (hash = 0; hash < L2TP_HASH_SIZE_2; hash++)\n\t\tINIT_HLIST_HEAD(&pn->l2tp_session_hlist[hash]);\n\n\tspin_lock_init(&pn->l2tp_session_hlist_lock);\n\n\treturn 0;\n}\n\nstatic __net_exit void l2tp_exit_net(struct net *net)\n{\n\tstruct l2tp_net *pn = l2tp_pernet(net);\n\tstruct l2tp_tunnel *tunnel = NULL;\n\tunsigned long tunnel_id, tmp;\n\tint hash;\n\n\trcu_read_lock_bh();\n\tidr_for_each_entry_ul(&pn->l2tp_tunnel_idr, tunnel, tmp, tunnel_id) {\n\t\tif (tunnel)\n\t\t\tl2tp_tunnel_delete(tunnel);\n\t}\n\trcu_read_unlock_bh();\n\n\tif (l2tp_wq)\n\t\tflush_workqueue(l2tp_wq);\n\trcu_barrier();\n\n\tfor (hash = 0; hash < L2TP_HASH_SIZE_2; hash++)\n\t\tWARN_ON_ONCE(!hlist_empty(&pn->l2tp_session_hlist[hash]));\n\tidr_destroy(&pn->l2tp_tunnel_idr);\n}\n\nstatic struct pernet_operations l2tp_net_ops = {\n\t.init = l2tp_init_net,\n\t.exit = l2tp_exit_net,\n\t.id   = &l2tp_net_id,\n\t.size = sizeof(struct l2tp_net),\n};\n\nstatic int __init l2tp_init(void)\n{\n\tint rc = 0;\n\n\trc = register_pernet_device(&l2tp_net_ops);\n\tif (rc)\n\t\tgoto out;\n\n\tl2tp_wq = alloc_workqueue(\"l2tp\", WQ_UNBOUND, 0);\n\tif (!l2tp_wq) {\n\t\tpr_err(\"alloc_workqueue failed\\n\");\n\t\tunregister_pernet_device(&l2tp_net_ops);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpr_info(\"L2TP core driver, %s\\n\", L2TP_DRV_VERSION);\n\nout:\n\treturn rc;\n}\n\nstatic void __exit l2tp_exit(void)\n{\n\tunregister_pernet_device(&l2tp_net_ops);\n\tif (l2tp_wq) {\n\t\tdestroy_workqueue(l2tp_wq);\n\t\tl2tp_wq = NULL;\n\t}\n}\n\nmodule_init(l2tp_init);\nmodule_exit(l2tp_exit);\n\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP core\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(L2TP_DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}