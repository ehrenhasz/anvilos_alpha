{
  "module_name": "l3mdev.c",
  "hash_id": "89408ebc7fc20480810fb7adb8a347ff76ab88e1063c870bd30e70aa2642997c",
  "original_prompt": "Ingested from linux-6.6.14/net/l3mdev/l3mdev.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <net/fib_rules.h>\n#include <net/l3mdev.h>\n\nstatic DEFINE_SPINLOCK(l3mdev_lock);\n\nstruct l3mdev_handler {\n\tlookup_by_table_id_t dev_lookup;\n};\n\nstatic struct l3mdev_handler l3mdev_handlers[L3MDEV_TYPE_MAX + 1];\n\nstatic int l3mdev_check_type(enum l3mdev_type l3type)\n{\n\tif (l3type <= L3MDEV_TYPE_UNSPEC || l3type > L3MDEV_TYPE_MAX)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint l3mdev_table_lookup_register(enum l3mdev_type l3type,\n\t\t\t\t lookup_by_table_id_t fn)\n{\n\tstruct l3mdev_handler *hdlr;\n\tint res;\n\n\tres = l3mdev_check_type(l3type);\n\tif (res)\n\t\treturn res;\n\n\thdlr = &l3mdev_handlers[l3type];\n\n\tspin_lock(&l3mdev_lock);\n\n\tif (hdlr->dev_lookup) {\n\t\tres = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\thdlr->dev_lookup = fn;\n\tres = 0;\n\nunlock:\n\tspin_unlock(&l3mdev_lock);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(l3mdev_table_lookup_register);\n\nvoid l3mdev_table_lookup_unregister(enum l3mdev_type l3type,\n\t\t\t\t    lookup_by_table_id_t fn)\n{\n\tstruct l3mdev_handler *hdlr;\n\n\tif (l3mdev_check_type(l3type))\n\t\treturn;\n\n\thdlr = &l3mdev_handlers[l3type];\n\n\tspin_lock(&l3mdev_lock);\n\n\tif (hdlr->dev_lookup == fn)\n\t\thdlr->dev_lookup = NULL;\n\n\tspin_unlock(&l3mdev_lock);\n}\nEXPORT_SYMBOL_GPL(l3mdev_table_lookup_unregister);\n\nint l3mdev_ifindex_lookup_by_table_id(enum l3mdev_type l3type,\n\t\t\t\t      struct net *net, u32 table_id)\n{\n\tlookup_by_table_id_t lookup;\n\tstruct l3mdev_handler *hdlr;\n\tint ifindex = -EINVAL;\n\tint res;\n\n\tres = l3mdev_check_type(l3type);\n\tif (res)\n\t\treturn res;\n\n\thdlr = &l3mdev_handlers[l3type];\n\n\tspin_lock(&l3mdev_lock);\n\n\tlookup = hdlr->dev_lookup;\n\tif (!lookup)\n\t\tgoto unlock;\n\n\tifindex = lookup(net, table_id);\n\nunlock:\n\tspin_unlock(&l3mdev_lock);\n\n\treturn ifindex;\n}\nEXPORT_SYMBOL_GPL(l3mdev_ifindex_lookup_by_table_id);\n\n \n\nint l3mdev_master_ifindex_rcu(const struct net_device *dev)\n{\n\tint ifindex = 0;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (netif_is_l3_master(dev)) {\n\t\tifindex = dev->ifindex;\n\t} else if (netif_is_l3_slave(dev)) {\n\t\tstruct net_device *master;\n\t\tstruct net_device *_dev = (struct net_device *)dev;\n\n\t\t \n\t\tmaster = netdev_master_upper_dev_get_rcu(_dev);\n\t\tif (master)\n\t\t\tifindex = master->ifindex;\n\t}\n\n\treturn ifindex;\n}\nEXPORT_SYMBOL_GPL(l3mdev_master_ifindex_rcu);\n\n \nint l3mdev_master_upper_ifindex_by_index_rcu(struct net *net, int ifindex)\n{\n\tstruct net_device *dev;\n\n\tdev = dev_get_by_index_rcu(net, ifindex);\n\twhile (dev && !netif_is_l3_master(dev))\n\t\tdev = netdev_master_upper_dev_get_rcu(dev);\n\n\treturn dev ? dev->ifindex : 0;\n}\nEXPORT_SYMBOL_GPL(l3mdev_master_upper_ifindex_by_index_rcu);\n\n \n\nu32 l3mdev_fib_table_rcu(const struct net_device *dev)\n{\n\tu32 tb_id = 0;\n\n\tif (!dev)\n\t\treturn 0;\n\n\tif (netif_is_l3_master(dev)) {\n\t\tif (dev->l3mdev_ops->l3mdev_fib_table)\n\t\t\ttb_id = dev->l3mdev_ops->l3mdev_fib_table(dev);\n\t} else if (netif_is_l3_slave(dev)) {\n\t\t \n\t\tstruct net_device *_dev = (struct net_device *) dev;\n\t\tconst struct net_device *master;\n\n\t\tmaster = netdev_master_upper_dev_get_rcu(_dev);\n\t\tif (master &&\n\t\t    master->l3mdev_ops->l3mdev_fib_table)\n\t\t\ttb_id = master->l3mdev_ops->l3mdev_fib_table(master);\n\t}\n\n\treturn tb_id;\n}\nEXPORT_SYMBOL_GPL(l3mdev_fib_table_rcu);\n\nu32 l3mdev_fib_table_by_index(struct net *net, int ifindex)\n{\n\tstruct net_device *dev;\n\tu32 tb_id = 0;\n\n\tif (!ifindex)\n\t\treturn 0;\n\n\trcu_read_lock();\n\n\tdev = dev_get_by_index_rcu(net, ifindex);\n\tif (dev)\n\t\ttb_id = l3mdev_fib_table_rcu(dev);\n\n\trcu_read_unlock();\n\n\treturn tb_id;\n}\nEXPORT_SYMBOL_GPL(l3mdev_fib_table_by_index);\n\n \n\nstruct dst_entry *l3mdev_link_scope_lookup(struct net *net,\n\t\t\t\t\t   struct flowi6 *fl6)\n{\n\tstruct dst_entry *dst = NULL;\n\tstruct net_device *dev;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\tif (fl6->flowi6_oif) {\n\t\tdev = dev_get_by_index_rcu(net, fl6->flowi6_oif);\n\t\tif (dev && netif_is_l3_slave(dev))\n\t\t\tdev = netdev_master_upper_dev_get_rcu(dev);\n\n\t\tif (dev && netif_is_l3_master(dev) &&\n\t\t    dev->l3mdev_ops->l3mdev_link_scope_lookup)\n\t\t\tdst = dev->l3mdev_ops->l3mdev_link_scope_lookup(dev, fl6);\n\t}\n\n\treturn dst;\n}\nEXPORT_SYMBOL_GPL(l3mdev_link_scope_lookup);\n\n \n\nint l3mdev_fib_rule_match(struct net *net, struct flowi *fl,\n\t\t\t  struct fib_lookup_arg *arg)\n{\n\tstruct net_device *dev;\n\tint rc = 0;\n\n\t \n\tif (!fl->flowi_l3mdev)\n\t\treturn 0;\n\n\trcu_read_lock();\n\n\tdev = dev_get_by_index_rcu(net, fl->flowi_l3mdev);\n\tif (dev && netif_is_l3_master(dev) &&\n\t    dev->l3mdev_ops->l3mdev_fib_table) {\n\t\targ->table = dev->l3mdev_ops->l3mdev_fib_table(dev);\n\t\trc = 1;\n\t}\n\n\trcu_read_unlock();\n\n\treturn rc;\n}\n\nvoid l3mdev_update_flow(struct net *net, struct flowi *fl)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\n\tif (fl->flowi_oif) {\n\t\tdev = dev_get_by_index_rcu(net, fl->flowi_oif);\n\t\tif (dev) {\n\t\t\tif (!fl->flowi_l3mdev)\n\t\t\t\tfl->flowi_l3mdev = l3mdev_master_ifindex_rcu(dev);\n\n\t\t\t \n\t\t\tif (netif_is_l3_master(dev))\n\t\t\t\tfl->flowi_oif = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (fl->flowi_iif > LOOPBACK_IFINDEX && !fl->flowi_l3mdev) {\n\t\tdev = dev_get_by_index_rcu(net, fl->flowi_iif);\n\t\tif (dev)\n\t\t\tfl->flowi_l3mdev = l3mdev_master_ifindex_rcu(dev);\n\t}\n\nout:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(l3mdev_update_flow);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}