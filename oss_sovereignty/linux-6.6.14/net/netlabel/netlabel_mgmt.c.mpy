{
  "module_name": "netlabel_mgmt.c",
  "hash_id": "c8ae967547975f6a2aa06ae9e219705772a14118f963a6561358721046781f25",
  "original_prompt": "Ingested from linux-6.6.14/net/netlabel/netlabel_mgmt.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/netlink.h>\n#include <net/genetlink.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/netlabel.h>\n#include <net/cipso_ipv4.h>\n#include <net/calipso.h>\n#include <linux/atomic.h>\n\n#include \"netlabel_calipso.h\"\n#include \"netlabel_domainhash.h\"\n#include \"netlabel_user.h\"\n#include \"netlabel_mgmt.h\"\n\n \natomic_t netlabel_mgmt_protocount = ATOMIC_INIT(0);\n\n \nstruct netlbl_domhsh_walk_arg {\n\tstruct netlink_callback *nl_cb;\n\tstruct sk_buff *skb;\n\tu32 seq;\n};\n\n \nstatic struct genl_family netlbl_mgmt_gnl_family;\n\n \nstatic const struct nla_policy netlbl_mgmt_genl_policy[NLBL_MGMT_A_MAX + 1] = {\n\t[NLBL_MGMT_A_DOMAIN] = { .type = NLA_NUL_STRING },\n\t[NLBL_MGMT_A_PROTOCOL] = { .type = NLA_U32 },\n\t[NLBL_MGMT_A_VERSION] = { .type = NLA_U32 },\n\t[NLBL_MGMT_A_CV4DOI] = { .type = NLA_U32 },\n\t[NLBL_MGMT_A_FAMILY] = { .type = NLA_U16 },\n\t[NLBL_MGMT_A_CLPDOI] = { .type = NLA_U32 },\n};\n\n \n\n \nstatic int netlbl_mgmt_add_common(struct genl_info *info,\n\t\t\t\t  struct netlbl_audit *audit_info)\n{\n\tvoid *pmap = NULL;\n\tint ret_val = -EINVAL;\n\tstruct netlbl_domaddr_map *addrmap = NULL;\n\tstruct cipso_v4_doi *cipsov4 = NULL;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct calipso_doi *calipso = NULL;\n#endif\n\tu32 tmp_val;\n\tstruct netlbl_dom_map *entry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry->def.type = nla_get_u32(info->attrs[NLBL_MGMT_A_PROTOCOL]);\n\tif (info->attrs[NLBL_MGMT_A_DOMAIN]) {\n\t\tsize_t tmp_size = nla_len(info->attrs[NLBL_MGMT_A_DOMAIN]);\n\t\tentry->domain = kmalloc(tmp_size, GFP_KERNEL);\n\t\tif (entry->domain == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto add_free_entry;\n\t\t}\n\t\tnla_strscpy(entry->domain,\n\t\t\t    info->attrs[NLBL_MGMT_A_DOMAIN], tmp_size);\n\t}\n\n\t \n\n\tswitch (entry->def.type) {\n\tcase NETLBL_NLTYPE_UNLABELED:\n\t\tif (info->attrs[NLBL_MGMT_A_FAMILY])\n\t\t\tentry->family =\n\t\t\t\tnla_get_u16(info->attrs[NLBL_MGMT_A_FAMILY]);\n\t\telse\n\t\t\tentry->family = AF_UNSPEC;\n\t\tbreak;\n\tcase NETLBL_NLTYPE_CIPSOV4:\n\t\tif (!info->attrs[NLBL_MGMT_A_CV4DOI])\n\t\t\tgoto add_free_domain;\n\n\t\ttmp_val = nla_get_u32(info->attrs[NLBL_MGMT_A_CV4DOI]);\n\t\tcipsov4 = cipso_v4_doi_getdef(tmp_val);\n\t\tif (cipsov4 == NULL)\n\t\t\tgoto add_free_domain;\n\t\tentry->family = AF_INET;\n\t\tentry->def.cipso = cipsov4;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase NETLBL_NLTYPE_CALIPSO:\n\t\tif (!info->attrs[NLBL_MGMT_A_CLPDOI])\n\t\t\tgoto add_free_domain;\n\n\t\ttmp_val = nla_get_u32(info->attrs[NLBL_MGMT_A_CLPDOI]);\n\t\tcalipso = calipso_doi_getdef(tmp_val);\n\t\tif (calipso == NULL)\n\t\t\tgoto add_free_domain;\n\t\tentry->family = AF_INET6;\n\t\tentry->def.calipso = calipso;\n\t\tbreak;\n#endif  \n\tdefault:\n\t\tgoto add_free_domain;\n\t}\n\n\tif ((entry->family == AF_INET && info->attrs[NLBL_MGMT_A_IPV6ADDR]) ||\n\t    (entry->family == AF_INET6 && info->attrs[NLBL_MGMT_A_IPV4ADDR]))\n\t\tgoto add_doi_put_def;\n\n\tif (info->attrs[NLBL_MGMT_A_IPV4ADDR]) {\n\t\tstruct in_addr *addr;\n\t\tstruct in_addr *mask;\n\t\tstruct netlbl_domaddr4_map *map;\n\n\t\taddrmap = kzalloc(sizeof(*addrmap), GFP_KERNEL);\n\t\tif (addrmap == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto add_doi_put_def;\n\t\t}\n\t\tINIT_LIST_HEAD(&addrmap->list4);\n\t\tINIT_LIST_HEAD(&addrmap->list6);\n\n\t\tif (nla_len(info->attrs[NLBL_MGMT_A_IPV4ADDR]) !=\n\t\t    sizeof(struct in_addr)) {\n\t\t\tret_val = -EINVAL;\n\t\t\tgoto add_free_addrmap;\n\t\t}\n\t\tif (nla_len(info->attrs[NLBL_MGMT_A_IPV4MASK]) !=\n\t\t    sizeof(struct in_addr)) {\n\t\t\tret_val = -EINVAL;\n\t\t\tgoto add_free_addrmap;\n\t\t}\n\t\taddr = nla_data(info->attrs[NLBL_MGMT_A_IPV4ADDR]);\n\t\tmask = nla_data(info->attrs[NLBL_MGMT_A_IPV4MASK]);\n\n\t\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\t\tif (map == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto add_free_addrmap;\n\t\t}\n\t\tpmap = map;\n\t\tmap->list.addr = addr->s_addr & mask->s_addr;\n\t\tmap->list.mask = mask->s_addr;\n\t\tmap->list.valid = 1;\n\t\tmap->def.type = entry->def.type;\n\t\tif (cipsov4)\n\t\t\tmap->def.cipso = cipsov4;\n\n\t\tret_val = netlbl_af4list_add(&map->list, &addrmap->list4);\n\t\tif (ret_val != 0)\n\t\t\tgoto add_free_map;\n\n\t\tentry->family = AF_INET;\n\t\tentry->def.type = NETLBL_NLTYPE_ADDRSELECT;\n\t\tentry->def.addrsel = addrmap;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (info->attrs[NLBL_MGMT_A_IPV6ADDR]) {\n\t\tstruct in6_addr *addr;\n\t\tstruct in6_addr *mask;\n\t\tstruct netlbl_domaddr6_map *map;\n\n\t\taddrmap = kzalloc(sizeof(*addrmap), GFP_KERNEL);\n\t\tif (addrmap == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto add_doi_put_def;\n\t\t}\n\t\tINIT_LIST_HEAD(&addrmap->list4);\n\t\tINIT_LIST_HEAD(&addrmap->list6);\n\n\t\tif (nla_len(info->attrs[NLBL_MGMT_A_IPV6ADDR]) !=\n\t\t    sizeof(struct in6_addr)) {\n\t\t\tret_val = -EINVAL;\n\t\t\tgoto add_free_addrmap;\n\t\t}\n\t\tif (nla_len(info->attrs[NLBL_MGMT_A_IPV6MASK]) !=\n\t\t    sizeof(struct in6_addr)) {\n\t\t\tret_val = -EINVAL;\n\t\t\tgoto add_free_addrmap;\n\t\t}\n\t\taddr = nla_data(info->attrs[NLBL_MGMT_A_IPV6ADDR]);\n\t\tmask = nla_data(info->attrs[NLBL_MGMT_A_IPV6MASK]);\n\n\t\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\t\tif (map == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto add_free_addrmap;\n\t\t}\n\t\tpmap = map;\n\t\tmap->list.addr = *addr;\n\t\tmap->list.addr.s6_addr32[0] &= mask->s6_addr32[0];\n\t\tmap->list.addr.s6_addr32[1] &= mask->s6_addr32[1];\n\t\tmap->list.addr.s6_addr32[2] &= mask->s6_addr32[2];\n\t\tmap->list.addr.s6_addr32[3] &= mask->s6_addr32[3];\n\t\tmap->list.mask = *mask;\n\t\tmap->list.valid = 1;\n\t\tmap->def.type = entry->def.type;\n\t\tif (calipso)\n\t\t\tmap->def.calipso = calipso;\n\n\t\tret_val = netlbl_af6list_add(&map->list, &addrmap->list6);\n\t\tif (ret_val != 0)\n\t\t\tgoto add_free_map;\n\n\t\tentry->family = AF_INET6;\n\t\tentry->def.type = NETLBL_NLTYPE_ADDRSELECT;\n\t\tentry->def.addrsel = addrmap;\n#endif  \n\t}\n\n\tret_val = netlbl_domhsh_add(entry, audit_info);\n\tif (ret_val != 0)\n\t\tgoto add_free_map;\n\n\treturn 0;\n\nadd_free_map:\n\tkfree(pmap);\nadd_free_addrmap:\n\tkfree(addrmap);\nadd_doi_put_def:\n\tcipso_v4_doi_putdef(cipsov4);\n#if IS_ENABLED(CONFIG_IPV6)\n\tcalipso_doi_putdef(calipso);\n#endif\nadd_free_domain:\n\tkfree(entry->domain);\nadd_free_entry:\n\tkfree(entry);\n\treturn ret_val;\n}\n\n \nstatic int netlbl_mgmt_listentry(struct sk_buff *skb,\n\t\t\t\t struct netlbl_dom_map *entry)\n{\n\tint ret_val = 0;\n\tstruct nlattr *nla_a;\n\tstruct nlattr *nla_b;\n\tstruct netlbl_af4list *iter4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct netlbl_af6list *iter6;\n#endif\n\n\tif (entry->domain != NULL) {\n\t\tret_val = nla_put_string(skb,\n\t\t\t\t\t NLBL_MGMT_A_DOMAIN, entry->domain);\n\t\tif (ret_val != 0)\n\t\t\treturn ret_val;\n\t}\n\n\tret_val = nla_put_u16(skb, NLBL_MGMT_A_FAMILY, entry->family);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\tswitch (entry->def.type) {\n\tcase NETLBL_NLTYPE_ADDRSELECT:\n\t\tnla_a = nla_nest_start_noflag(skb, NLBL_MGMT_A_SELECTORLIST);\n\t\tif (nla_a == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tnetlbl_af4list_foreach_rcu(iter4, &entry->def.addrsel->list4) {\n\t\t\tstruct netlbl_domaddr4_map *map4;\n\t\t\tstruct in_addr addr_struct;\n\n\t\t\tnla_b = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t      NLBL_MGMT_A_ADDRSELECTOR);\n\t\t\tif (nla_b == NULL)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\taddr_struct.s_addr = iter4->addr;\n\t\t\tret_val = nla_put_in_addr(skb, NLBL_MGMT_A_IPV4ADDR,\n\t\t\t\t\t\t  addr_struct.s_addr);\n\t\t\tif (ret_val != 0)\n\t\t\t\treturn ret_val;\n\t\t\taddr_struct.s_addr = iter4->mask;\n\t\t\tret_val = nla_put_in_addr(skb, NLBL_MGMT_A_IPV4MASK,\n\t\t\t\t\t\t  addr_struct.s_addr);\n\t\t\tif (ret_val != 0)\n\t\t\t\treturn ret_val;\n\t\t\tmap4 = netlbl_domhsh_addr4_entry(iter4);\n\t\t\tret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL,\n\t\t\t\t\t      map4->def.type);\n\t\t\tif (ret_val != 0)\n\t\t\t\treturn ret_val;\n\t\t\tswitch (map4->def.type) {\n\t\t\tcase NETLBL_NLTYPE_CIPSOV4:\n\t\t\t\tret_val = nla_put_u32(skb, NLBL_MGMT_A_CV4DOI,\n\t\t\t\t\t\t      map4->def.cipso->doi);\n\t\t\t\tif (ret_val != 0)\n\t\t\t\t\treturn ret_val;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnla_nest_end(skb, nla_b);\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tnetlbl_af6list_foreach_rcu(iter6, &entry->def.addrsel->list6) {\n\t\t\tstruct netlbl_domaddr6_map *map6;\n\n\t\t\tnla_b = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t      NLBL_MGMT_A_ADDRSELECTOR);\n\t\t\tif (nla_b == NULL)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tret_val = nla_put_in6_addr(skb, NLBL_MGMT_A_IPV6ADDR,\n\t\t\t\t\t\t   &iter6->addr);\n\t\t\tif (ret_val != 0)\n\t\t\t\treturn ret_val;\n\t\t\tret_val = nla_put_in6_addr(skb, NLBL_MGMT_A_IPV6MASK,\n\t\t\t\t\t\t   &iter6->mask);\n\t\t\tif (ret_val != 0)\n\t\t\t\treturn ret_val;\n\t\t\tmap6 = netlbl_domhsh_addr6_entry(iter6);\n\t\t\tret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL,\n\t\t\t\t\t      map6->def.type);\n\t\t\tif (ret_val != 0)\n\t\t\t\treturn ret_val;\n\n\t\t\tswitch (map6->def.type) {\n\t\t\tcase NETLBL_NLTYPE_CALIPSO:\n\t\t\t\tret_val = nla_put_u32(skb, NLBL_MGMT_A_CLPDOI,\n\t\t\t\t\t\t      map6->def.calipso->doi);\n\t\t\t\tif (ret_val != 0)\n\t\t\t\t\treturn ret_val;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnla_nest_end(skb, nla_b);\n\t\t}\n#endif  \n\n\t\tnla_nest_end(skb, nla_a);\n\t\tbreak;\n\tcase NETLBL_NLTYPE_UNLABELED:\n\t\tret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL,\n\t\t\t\t      entry->def.type);\n\t\tbreak;\n\tcase NETLBL_NLTYPE_CIPSOV4:\n\t\tret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL,\n\t\t\t\t      entry->def.type);\n\t\tif (ret_val != 0)\n\t\t\treturn ret_val;\n\t\tret_val = nla_put_u32(skb, NLBL_MGMT_A_CV4DOI,\n\t\t\t\t      entry->def.cipso->doi);\n\t\tbreak;\n\tcase NETLBL_NLTYPE_CALIPSO:\n\t\tret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL,\n\t\t\t\t      entry->def.type);\n\t\tif (ret_val != 0)\n\t\t\treturn ret_val;\n\t\tret_val = nla_put_u32(skb, NLBL_MGMT_A_CLPDOI,\n\t\t\t\t      entry->def.calipso->doi);\n\t\tbreak;\n\t}\n\n\treturn ret_val;\n}\n\n \n\n \nstatic int netlbl_mgmt_add(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct netlbl_audit audit_info;\n\n\tif ((!info->attrs[NLBL_MGMT_A_DOMAIN]) ||\n\t    (!info->attrs[NLBL_MGMT_A_PROTOCOL]) ||\n\t    (info->attrs[NLBL_MGMT_A_IPV4ADDR] &&\n\t     info->attrs[NLBL_MGMT_A_IPV6ADDR]) ||\n\t    (info->attrs[NLBL_MGMT_A_IPV4MASK] &&\n\t     info->attrs[NLBL_MGMT_A_IPV6MASK]) ||\n\t    ((info->attrs[NLBL_MGMT_A_IPV4ADDR] != NULL) ^\n\t     (info->attrs[NLBL_MGMT_A_IPV4MASK] != NULL)) ||\n\t    ((info->attrs[NLBL_MGMT_A_IPV6ADDR] != NULL) ^\n\t     (info->attrs[NLBL_MGMT_A_IPV6MASK] != NULL)))\n\t\treturn -EINVAL;\n\n\tnetlbl_netlink_auditinfo(&audit_info);\n\n\treturn netlbl_mgmt_add_common(info, &audit_info);\n}\n\n \nstatic int netlbl_mgmt_remove(struct sk_buff *skb, struct genl_info *info)\n{\n\tchar *domain;\n\tstruct netlbl_audit audit_info;\n\n\tif (!info->attrs[NLBL_MGMT_A_DOMAIN])\n\t\treturn -EINVAL;\n\n\tnetlbl_netlink_auditinfo(&audit_info);\n\n\tdomain = nla_data(info->attrs[NLBL_MGMT_A_DOMAIN]);\n\treturn netlbl_domhsh_remove(domain, AF_UNSPEC, &audit_info);\n}\n\n \nstatic int netlbl_mgmt_listall_cb(struct netlbl_dom_map *entry, void *arg)\n{\n\tint ret_val = -ENOMEM;\n\tstruct netlbl_domhsh_walk_arg *cb_arg = arg;\n\tvoid *data;\n\n\tdata = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).portid,\n\t\t\t   cb_arg->seq, &netlbl_mgmt_gnl_family,\n\t\t\t   NLM_F_MULTI, NLBL_MGMT_C_LISTALL);\n\tif (data == NULL)\n\t\tgoto listall_cb_failure;\n\n\tret_val = netlbl_mgmt_listentry(cb_arg->skb, entry);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\n\tcb_arg->seq++;\n\tgenlmsg_end(cb_arg->skb, data);\n\treturn 0;\n\nlistall_cb_failure:\n\tgenlmsg_cancel(cb_arg->skb, data);\n\treturn ret_val;\n}\n\n \nstatic int netlbl_mgmt_listall(struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb)\n{\n\tstruct netlbl_domhsh_walk_arg cb_arg;\n\tu32 skip_bkt = cb->args[0];\n\tu32 skip_chain = cb->args[1];\n\n\tcb_arg.nl_cb = cb;\n\tcb_arg.skb = skb;\n\tcb_arg.seq = cb->nlh->nlmsg_seq;\n\n\tnetlbl_domhsh_walk(&skip_bkt,\n\t\t\t   &skip_chain,\n\t\t\t   netlbl_mgmt_listall_cb,\n\t\t\t   &cb_arg);\n\n\tcb->args[0] = skip_bkt;\n\tcb->args[1] = skip_chain;\n\treturn skb->len;\n}\n\n \nstatic int netlbl_mgmt_adddef(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct netlbl_audit audit_info;\n\n\tif ((!info->attrs[NLBL_MGMT_A_PROTOCOL]) ||\n\t    (info->attrs[NLBL_MGMT_A_IPV4ADDR] &&\n\t     info->attrs[NLBL_MGMT_A_IPV6ADDR]) ||\n\t    (info->attrs[NLBL_MGMT_A_IPV4MASK] &&\n\t     info->attrs[NLBL_MGMT_A_IPV6MASK]) ||\n\t    ((info->attrs[NLBL_MGMT_A_IPV4ADDR] != NULL) ^\n\t     (info->attrs[NLBL_MGMT_A_IPV4MASK] != NULL)) ||\n\t    ((info->attrs[NLBL_MGMT_A_IPV6ADDR] != NULL) ^\n\t     (info->attrs[NLBL_MGMT_A_IPV6MASK] != NULL)))\n\t\treturn -EINVAL;\n\n\tnetlbl_netlink_auditinfo(&audit_info);\n\n\treturn netlbl_mgmt_add_common(info, &audit_info);\n}\n\n \nstatic int netlbl_mgmt_removedef(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct netlbl_audit audit_info;\n\n\tnetlbl_netlink_auditinfo(&audit_info);\n\n\treturn netlbl_domhsh_remove_default(AF_UNSPEC, &audit_info);\n}\n\n \nstatic int netlbl_mgmt_listdef(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret_val = -ENOMEM;\n\tstruct sk_buff *ans_skb = NULL;\n\tvoid *data;\n\tstruct netlbl_dom_map *entry;\n\tu16 family;\n\n\tif (info->attrs[NLBL_MGMT_A_FAMILY])\n\t\tfamily = nla_get_u16(info->attrs[NLBL_MGMT_A_FAMILY]);\n\telse\n\t\tfamily = AF_INET;\n\n\tans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (ans_skb == NULL)\n\t\treturn -ENOMEM;\n\tdata = genlmsg_put_reply(ans_skb, info, &netlbl_mgmt_gnl_family,\n\t\t\t\t 0, NLBL_MGMT_C_LISTDEF);\n\tif (data == NULL)\n\t\tgoto listdef_failure;\n\n\trcu_read_lock();\n\tentry = netlbl_domhsh_getentry(NULL, family);\n\tif (entry == NULL) {\n\t\tret_val = -ENOENT;\n\t\tgoto listdef_failure_lock;\n\t}\n\tret_val = netlbl_mgmt_listentry(ans_skb, entry);\n\trcu_read_unlock();\n\tif (ret_val != 0)\n\t\tgoto listdef_failure;\n\n\tgenlmsg_end(ans_skb, data);\n\treturn genlmsg_reply(ans_skb, info);\n\nlistdef_failure_lock:\n\trcu_read_unlock();\nlistdef_failure:\n\tkfree_skb(ans_skb);\n\treturn ret_val;\n}\n\n \nstatic int netlbl_mgmt_protocols_cb(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb,\n\t\t\t\t    u32 protocol)\n{\n\tint ret_val = -ENOMEM;\n\tvoid *data;\n\n\tdata = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t   &netlbl_mgmt_gnl_family, NLM_F_MULTI,\n\t\t\t   NLBL_MGMT_C_PROTOCOLS);\n\tif (data == NULL)\n\t\tgoto protocols_cb_failure;\n\n\tret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL, protocol);\n\tif (ret_val != 0)\n\t\tgoto protocols_cb_failure;\n\n\tgenlmsg_end(skb, data);\n\treturn 0;\n\nprotocols_cb_failure:\n\tgenlmsg_cancel(skb, data);\n\treturn ret_val;\n}\n\n \nstatic int netlbl_mgmt_protocols(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tu32 protos_sent = cb->args[0];\n\n\tif (protos_sent == 0) {\n\t\tif (netlbl_mgmt_protocols_cb(skb,\n\t\t\t\t\t     cb,\n\t\t\t\t\t     NETLBL_NLTYPE_UNLABELED) < 0)\n\t\t\tgoto protocols_return;\n\t\tprotos_sent++;\n\t}\n\tif (protos_sent == 1) {\n\t\tif (netlbl_mgmt_protocols_cb(skb,\n\t\t\t\t\t     cb,\n\t\t\t\t\t     NETLBL_NLTYPE_CIPSOV4) < 0)\n\t\t\tgoto protocols_return;\n\t\tprotos_sent++;\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (protos_sent == 2) {\n\t\tif (netlbl_mgmt_protocols_cb(skb,\n\t\t\t\t\t     cb,\n\t\t\t\t\t     NETLBL_NLTYPE_CALIPSO) < 0)\n\t\t\tgoto protocols_return;\n\t\tprotos_sent++;\n\t}\n#endif\n\nprotocols_return:\n\tcb->args[0] = protos_sent;\n\treturn skb->len;\n}\n\n \nstatic int netlbl_mgmt_version(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret_val = -ENOMEM;\n\tstruct sk_buff *ans_skb = NULL;\n\tvoid *data;\n\n\tans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (ans_skb == NULL)\n\t\treturn -ENOMEM;\n\tdata = genlmsg_put_reply(ans_skb, info, &netlbl_mgmt_gnl_family,\n\t\t\t\t 0, NLBL_MGMT_C_VERSION);\n\tif (data == NULL)\n\t\tgoto version_failure;\n\n\tret_val = nla_put_u32(ans_skb,\n\t\t\t      NLBL_MGMT_A_VERSION,\n\t\t\t      NETLBL_PROTO_VERSION);\n\tif (ret_val != 0)\n\t\tgoto version_failure;\n\n\tgenlmsg_end(ans_skb, data);\n\treturn genlmsg_reply(ans_skb, info);\n\nversion_failure:\n\tkfree_skb(ans_skb);\n\treturn ret_val;\n}\n\n\n \n\nstatic const struct genl_small_ops netlbl_mgmt_genl_ops[] = {\n\t{\n\t.cmd = NLBL_MGMT_C_ADD,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = GENL_ADMIN_PERM,\n\t.doit = netlbl_mgmt_add,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_MGMT_C_REMOVE,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = GENL_ADMIN_PERM,\n\t.doit = netlbl_mgmt_remove,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_MGMT_C_LISTALL,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = 0,\n\t.doit = NULL,\n\t.dumpit = netlbl_mgmt_listall,\n\t},\n\t{\n\t.cmd = NLBL_MGMT_C_ADDDEF,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = GENL_ADMIN_PERM,\n\t.doit = netlbl_mgmt_adddef,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_MGMT_C_REMOVEDEF,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = GENL_ADMIN_PERM,\n\t.doit = netlbl_mgmt_removedef,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_MGMT_C_LISTDEF,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = 0,\n\t.doit = netlbl_mgmt_listdef,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_MGMT_C_PROTOCOLS,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = 0,\n\t.doit = NULL,\n\t.dumpit = netlbl_mgmt_protocols,\n\t},\n\t{\n\t.cmd = NLBL_MGMT_C_VERSION,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = 0,\n\t.doit = netlbl_mgmt_version,\n\t.dumpit = NULL,\n\t},\n};\n\nstatic struct genl_family netlbl_mgmt_gnl_family __ro_after_init = {\n\t.hdrsize = 0,\n\t.name = NETLBL_NLTYPE_MGMT_NAME,\n\t.version = NETLBL_PROTO_VERSION,\n\t.maxattr = NLBL_MGMT_A_MAX,\n\t.policy = netlbl_mgmt_genl_policy,\n\t.module = THIS_MODULE,\n\t.small_ops = netlbl_mgmt_genl_ops,\n\t.n_small_ops = ARRAY_SIZE(netlbl_mgmt_genl_ops),\n\t.resv_start_op = NLBL_MGMT_C_VERSION + 1,\n};\n\n \n\n \nint __init netlbl_mgmt_genl_init(void)\n{\n\treturn genl_register_family(&netlbl_mgmt_gnl_family);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}