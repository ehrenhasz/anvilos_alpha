{
  "module_name": "netlabel_addrlist.h",
  "hash_id": "9af1bef6bde4d22b330ed4f3947b7f495b5b1fbc989d363ff7ed03a735578747",
  "original_prompt": "Ingested from linux-6.6.14/net/netlabel/netlabel_addrlist.h",
  "human_readable_source": " \n \n\n \n\n#ifndef _NETLABEL_ADDRLIST_H\n#define _NETLABEL_ADDRLIST_H\n\n#include <linux/types.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/in6.h>\n#include <linux/audit.h>\n\n \nstruct netlbl_af4list {\n\t__be32 addr;\n\t__be32 mask;\n\n\tu32 valid;\n\tstruct list_head list;\n};\n\n \nstruct netlbl_af6list {\n\tstruct in6_addr addr;\n\tstruct in6_addr mask;\n\n\tu32 valid;\n\tstruct list_head list;\n};\n\n#define __af4list_entry(ptr) container_of(ptr, struct netlbl_af4list, list)\n\nstatic inline struct netlbl_af4list *__af4list_valid(struct list_head *s,\n\t\t\t\t\t\t     struct list_head *h)\n{\n\tstruct list_head *i = s;\n\tstruct netlbl_af4list *n = __af4list_entry(s);\n\twhile (i != h && !n->valid) {\n\t\ti = i->next;\n\t\tn = __af4list_entry(i);\n\t}\n\treturn n;\n}\n\nstatic inline struct netlbl_af4list *__af4list_valid_rcu(struct list_head *s,\n\t\t\t\t\t\t\t struct list_head *h)\n{\n\tstruct list_head *i = s;\n\tstruct netlbl_af4list *n = __af4list_entry(s);\n\twhile (i != h && !n->valid) {\n\t\ti = rcu_dereference(list_next_rcu(i));\n\t\tn = __af4list_entry(i);\n\t}\n\treturn n;\n}\n\n#define netlbl_af4list_foreach(iter, head)\t\t\t\t\\\n\tfor (iter = __af4list_valid((head)->next, head);\t\t\\\n\t     &iter->list != (head);\t\t\t\t\t\\\n\t     iter = __af4list_valid(iter->list.next, head))\n\n#define netlbl_af4list_foreach_rcu(iter, head)\t\t\t\t\\\n\tfor (iter = __af4list_valid_rcu((head)->next, head);\t\t\\\n\t     &iter->list != (head);\t\t\t\t\t\\\n\t     iter = __af4list_valid_rcu(iter->list.next, head))\n\n#define netlbl_af4list_foreach_safe(iter, tmp, head)\t\t\t\\\n\tfor (iter = __af4list_valid((head)->next, head),\t\t\\\n\t\t     tmp = __af4list_valid(iter->list.next, head);\t\\\n\t     &iter->list != (head);\t\t\t\t\t\\\n\t     iter = tmp, tmp = __af4list_valid(iter->list.next, head))\n\nint netlbl_af4list_add(struct netlbl_af4list *entry,\n\t\t       struct list_head *head);\nstruct netlbl_af4list *netlbl_af4list_remove(__be32 addr, __be32 mask,\n\t\t\t\t\t     struct list_head *head);\nvoid netlbl_af4list_remove_entry(struct netlbl_af4list *entry);\nstruct netlbl_af4list *netlbl_af4list_search(__be32 addr,\n\t\t\t\t\t     struct list_head *head);\nstruct netlbl_af4list *netlbl_af4list_search_exact(__be32 addr,\n\t\t\t\t\t\t   __be32 mask,\n\t\t\t\t\t\t   struct list_head *head);\n\n#ifdef CONFIG_AUDIT\nvoid netlbl_af4list_audit_addr(struct audit_buffer *audit_buf,\n\t\t\t       int src, const char *dev,\n\t\t\t       __be32 addr, __be32 mask);\n#else\nstatic inline void netlbl_af4list_audit_addr(struct audit_buffer *audit_buf,\n\t\t\t\t\t     int src, const char *dev,\n\t\t\t\t\t     __be32 addr, __be32 mask)\n{\n}\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\n\n#define __af6list_entry(ptr) container_of(ptr, struct netlbl_af6list, list)\n\nstatic inline struct netlbl_af6list *__af6list_valid(struct list_head *s,\n\t\t\t\t\t\t     struct list_head *h)\n{\n\tstruct list_head *i = s;\n\tstruct netlbl_af6list *n = __af6list_entry(s);\n\twhile (i != h && !n->valid) {\n\t\ti = i->next;\n\t\tn = __af6list_entry(i);\n\t}\n\treturn n;\n}\n\nstatic inline struct netlbl_af6list *__af6list_valid_rcu(struct list_head *s,\n\t\t\t\t\t\t\t struct list_head *h)\n{\n\tstruct list_head *i = s;\n\tstruct netlbl_af6list *n = __af6list_entry(s);\n\twhile (i != h && !n->valid) {\n\t\ti = rcu_dereference(list_next_rcu(i));\n\t\tn = __af6list_entry(i);\n\t}\n\treturn n;\n}\n\n#define netlbl_af6list_foreach(iter, head)\t\t\t\t\\\n\tfor (iter = __af6list_valid((head)->next, head);\t\t\\\n\t     &iter->list != (head);\t\t\t\t\t\\\n\t     iter = __af6list_valid(iter->list.next, head))\n\n#define netlbl_af6list_foreach_rcu(iter, head)\t\t\t\t\\\n\tfor (iter = __af6list_valid_rcu((head)->next, head);\t\t\\\n\t     &iter->list != (head);\t\t\t\t\t\\\n\t     iter = __af6list_valid_rcu(iter->list.next, head))\n\n#define netlbl_af6list_foreach_safe(iter, tmp, head)\t\t\t\\\n\tfor (iter = __af6list_valid((head)->next, head),\t\t\\\n\t\t     tmp = __af6list_valid(iter->list.next, head);\t\\\n\t     &iter->list != (head);\t\t\t\t\t\\\n\t     iter = tmp, tmp = __af6list_valid(iter->list.next, head))\n\nint netlbl_af6list_add(struct netlbl_af6list *entry,\n\t\t       struct list_head *head);\nstruct netlbl_af6list *netlbl_af6list_remove(const struct in6_addr *addr,\n\t\t\t\t\t     const struct in6_addr *mask,\n\t\t\t\t\t     struct list_head *head);\nvoid netlbl_af6list_remove_entry(struct netlbl_af6list *entry);\nstruct netlbl_af6list *netlbl_af6list_search(const struct in6_addr *addr,\n\t\t\t\t\t     struct list_head *head);\nstruct netlbl_af6list *netlbl_af6list_search_exact(const struct in6_addr *addr,\n\t\t\t\t\t\t   const struct in6_addr *mask,\n\t\t\t\t\t\t   struct list_head *head);\n\n#ifdef CONFIG_AUDIT\nvoid netlbl_af6list_audit_addr(struct audit_buffer *audit_buf,\n\t\t\t       int src,\n\t\t\t       const char *dev,\n\t\t\t       const struct in6_addr *addr,\n\t\t\t       const struct in6_addr *mask);\n#else\nstatic inline void netlbl_af6list_audit_addr(struct audit_buffer *audit_buf,\n\t\t\t\t\t     int src,\n\t\t\t\t\t     const char *dev,\n\t\t\t\t\t     const struct in6_addr *addr,\n\t\t\t\t\t     const struct in6_addr *mask)\n{\n}\n#endif\n#endif  \n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}