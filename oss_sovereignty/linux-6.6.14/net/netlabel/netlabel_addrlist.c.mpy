{
  "module_name": "netlabel_addrlist.c",
  "hash_id": "2174d62eb40ef85e109a1c01cc985b6ba64b27774ed889deb613e9bb1bb42270",
  "original_prompt": "Ingested from linux-6.6.14/net/netlabel/netlabel_addrlist.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <linux/audit.h>\n\n#include \"netlabel_addrlist.h\"\n\n \n\n \nstruct netlbl_af4list *netlbl_af4list_search(__be32 addr,\n\t\t\t\t\t     struct list_head *head)\n{\n\tstruct netlbl_af4list *iter;\n\n\tlist_for_each_entry_rcu(iter, head, list)\n\t\tif (iter->valid && (addr & iter->mask) == iter->addr)\n\t\t\treturn iter;\n\n\treturn NULL;\n}\n\n \nstruct netlbl_af4list *netlbl_af4list_search_exact(__be32 addr,\n\t\t\t\t\t\t   __be32 mask,\n\t\t\t\t\t\t   struct list_head *head)\n{\n\tstruct netlbl_af4list *iter;\n\n\tlist_for_each_entry_rcu(iter, head, list)\n\t\tif (iter->valid && iter->addr == addr && iter->mask == mask)\n\t\t\treturn iter;\n\n\treturn NULL;\n}\n\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nstruct netlbl_af6list *netlbl_af6list_search(const struct in6_addr *addr,\n\t\t\t\t\t     struct list_head *head)\n{\n\tstruct netlbl_af6list *iter;\n\n\tlist_for_each_entry_rcu(iter, head, list)\n\t\tif (iter->valid &&\n\t\t    ipv6_masked_addr_cmp(&iter->addr, &iter->mask, addr) == 0)\n\t\t\treturn iter;\n\n\treturn NULL;\n}\n\n \nstruct netlbl_af6list *netlbl_af6list_search_exact(const struct in6_addr *addr,\n\t\t\t\t\t\t   const struct in6_addr *mask,\n\t\t\t\t\t\t   struct list_head *head)\n{\n\tstruct netlbl_af6list *iter;\n\n\tlist_for_each_entry_rcu(iter, head, list)\n\t\tif (iter->valid &&\n\t\t    ipv6_addr_equal(&iter->addr, addr) &&\n\t\t    ipv6_addr_equal(&iter->mask, mask))\n\t\t\treturn iter;\n\n\treturn NULL;\n}\n#endif  \n\n \nint netlbl_af4list_add(struct netlbl_af4list *entry, struct list_head *head)\n{\n\tstruct netlbl_af4list *iter;\n\n\titer = netlbl_af4list_search(entry->addr, head);\n\tif (iter != NULL &&\n\t    iter->addr == entry->addr && iter->mask == entry->mask)\n\t\treturn -EEXIST;\n\n\t \n\tlist_for_each_entry_rcu(iter, head, list)\n\t\tif (iter->valid &&\n\t\t    ntohl(entry->mask) > ntohl(iter->mask)) {\n\t\t\t__list_add_rcu(&entry->list,\n\t\t\t\t       iter->list.prev,\n\t\t\t\t       &iter->list);\n\t\t\treturn 0;\n\t\t}\n\tlist_add_tail_rcu(&entry->list, head);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nint netlbl_af6list_add(struct netlbl_af6list *entry, struct list_head *head)\n{\n\tstruct netlbl_af6list *iter;\n\n\titer = netlbl_af6list_search(&entry->addr, head);\n\tif (iter != NULL &&\n\t    ipv6_addr_equal(&iter->addr, &entry->addr) &&\n\t    ipv6_addr_equal(&iter->mask, &entry->mask))\n\t\treturn -EEXIST;\n\n\t \n\tlist_for_each_entry_rcu(iter, head, list)\n\t\tif (iter->valid &&\n\t\t    ipv6_addr_cmp(&entry->mask, &iter->mask) > 0) {\n\t\t\t__list_add_rcu(&entry->list,\n\t\t\t\t       iter->list.prev,\n\t\t\t\t       &iter->list);\n\t\t\treturn 0;\n\t\t}\n\tlist_add_tail_rcu(&entry->list, head);\n\treturn 0;\n}\n#endif  \n\n \nvoid netlbl_af4list_remove_entry(struct netlbl_af4list *entry)\n{\n\tentry->valid = 0;\n\tlist_del_rcu(&entry->list);\n}\n\n \nstruct netlbl_af4list *netlbl_af4list_remove(__be32 addr, __be32 mask,\n\t\t\t\t\t     struct list_head *head)\n{\n\tstruct netlbl_af4list *entry;\n\n\tentry = netlbl_af4list_search_exact(addr, mask, head);\n\tif (entry == NULL)\n\t\treturn NULL;\n\tnetlbl_af4list_remove_entry(entry);\n\treturn entry;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nvoid netlbl_af6list_remove_entry(struct netlbl_af6list *entry)\n{\n\tentry->valid = 0;\n\tlist_del_rcu(&entry->list);\n}\n\n \nstruct netlbl_af6list *netlbl_af6list_remove(const struct in6_addr *addr,\n\t\t\t\t\t     const struct in6_addr *mask,\n\t\t\t\t\t     struct list_head *head)\n{\n\tstruct netlbl_af6list *entry;\n\n\tentry = netlbl_af6list_search_exact(addr, mask, head);\n\tif (entry == NULL)\n\t\treturn NULL;\n\tnetlbl_af6list_remove_entry(entry);\n\treturn entry;\n}\n#endif  \n\n \n\n#ifdef CONFIG_AUDIT\n \nvoid netlbl_af4list_audit_addr(struct audit_buffer *audit_buf,\n\t\t\t\t\tint src, const char *dev,\n\t\t\t\t\t__be32 addr, __be32 mask)\n{\n\tu32 mask_val = ntohl(mask);\n\tchar *dir = (src ? \"src\" : \"dst\");\n\n\tif (dev != NULL)\n\t\taudit_log_format(audit_buf, \" netif=%s\", dev);\n\taudit_log_format(audit_buf, \" %s=%pI4\", dir, &addr);\n\tif (mask_val != 0xffffffff) {\n\t\tu32 mask_len = 0;\n\t\twhile (mask_val > 0) {\n\t\t\tmask_val <<= 1;\n\t\t\tmask_len++;\n\t\t}\n\t\taudit_log_format(audit_buf, \" %s_prefixlen=%d\", dir, mask_len);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nvoid netlbl_af6list_audit_addr(struct audit_buffer *audit_buf,\n\t\t\t\t int src,\n\t\t\t\t const char *dev,\n\t\t\t\t const struct in6_addr *addr,\n\t\t\t\t const struct in6_addr *mask)\n{\n\tchar *dir = (src ? \"src\" : \"dst\");\n\n\tif (dev != NULL)\n\t\taudit_log_format(audit_buf, \" netif=%s\", dev);\n\taudit_log_format(audit_buf, \" %s=%pI6\", dir, addr);\n\tif (ntohl(mask->s6_addr32[3]) != 0xffffffff) {\n\t\tu32 mask_len = 0;\n\t\tu32 mask_val;\n\t\tint iter = -1;\n\t\twhile (ntohl(mask->s6_addr32[++iter]) == 0xffffffff)\n\t\t\tmask_len += 32;\n\t\tmask_val = ntohl(mask->s6_addr32[iter]);\n\t\twhile (mask_val > 0) {\n\t\t\tmask_val <<= 1;\n\t\t\tmask_len++;\n\t\t}\n\t\taudit_log_format(audit_buf, \" %s_prefixlen=%d\", dir, mask_len);\n\t}\n}\n#endif  \n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}