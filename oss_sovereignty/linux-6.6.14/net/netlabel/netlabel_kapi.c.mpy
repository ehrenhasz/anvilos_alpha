{
  "module_name": "netlabel_kapi.c",
  "hash_id": "8db8d4fbca196a9d4f8e31532c9e2afbe6185ce0329639f56cbd42e3d3b6e500",
  "original_prompt": "Ingested from linux-6.6.14/net/netlabel/netlabel_kapi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/audit.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/netlabel.h>\n#include <net/cipso_ipv4.h>\n#include <net/calipso.h>\n#include <asm/bug.h>\n#include <linux/atomic.h>\n\n#include \"netlabel_domainhash.h\"\n#include \"netlabel_unlabeled.h\"\n#include \"netlabel_cipso_v4.h\"\n#include \"netlabel_calipso.h\"\n#include \"netlabel_user.h\"\n#include \"netlabel_mgmt.h\"\n#include \"netlabel_addrlist.h\"\n\n \n\n \nint netlbl_cfg_map_del(const char *domain,\n\t\t       u16 family,\n\t\t       const void *addr,\n\t\t       const void *mask,\n\t\t       struct netlbl_audit *audit_info)\n{\n\tif (addr == NULL && mask == NULL) {\n\t\treturn netlbl_domhsh_remove(domain, family, audit_info);\n\t} else if (addr != NULL && mask != NULL) {\n\t\tswitch (family) {\n\t\tcase AF_INET:\n\t\t\treturn netlbl_domhsh_remove_af4(domain, addr, mask,\n\t\t\t\t\t\t\taudit_info);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase AF_INET6:\n\t\t\treturn netlbl_domhsh_remove_af6(domain, addr, mask,\n\t\t\t\t\t\t\taudit_info);\n#endif  \n\t\tdefault:\n\t\t\treturn -EPFNOSUPPORT;\n\t\t}\n\t} else\n\t\treturn -EINVAL;\n}\n\n \nint netlbl_cfg_unlbl_map_add(const char *domain,\n\t\t\t     u16 family,\n\t\t\t     const void *addr,\n\t\t\t     const void *mask,\n\t\t\t     struct netlbl_audit *audit_info)\n{\n\tint ret_val = -ENOMEM;\n\tstruct netlbl_dom_map *entry;\n\tstruct netlbl_domaddr_map *addrmap = NULL;\n\tstruct netlbl_domaddr4_map *map4 = NULL;\n\tstruct netlbl_domaddr6_map *map6 = NULL;\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\tif (domain != NULL) {\n\t\tentry->domain = kstrdup(domain, GFP_ATOMIC);\n\t\tif (entry->domain == NULL)\n\t\t\tgoto cfg_unlbl_map_add_failure;\n\t}\n\tentry->family = family;\n\n\tif (addr == NULL && mask == NULL)\n\t\tentry->def.type = NETLBL_NLTYPE_UNLABELED;\n\telse if (addr != NULL && mask != NULL) {\n\t\taddrmap = kzalloc(sizeof(*addrmap), GFP_ATOMIC);\n\t\tif (addrmap == NULL)\n\t\t\tgoto cfg_unlbl_map_add_failure;\n\t\tINIT_LIST_HEAD(&addrmap->list4);\n\t\tINIT_LIST_HEAD(&addrmap->list6);\n\n\t\tswitch (family) {\n\t\tcase AF_INET: {\n\t\t\tconst struct in_addr *addr4 = addr;\n\t\t\tconst struct in_addr *mask4 = mask;\n\t\t\tmap4 = kzalloc(sizeof(*map4), GFP_ATOMIC);\n\t\t\tif (map4 == NULL)\n\t\t\t\tgoto cfg_unlbl_map_add_failure;\n\t\t\tmap4->def.type = NETLBL_NLTYPE_UNLABELED;\n\t\t\tmap4->list.addr = addr4->s_addr & mask4->s_addr;\n\t\t\tmap4->list.mask = mask4->s_addr;\n\t\t\tmap4->list.valid = 1;\n\t\t\tret_val = netlbl_af4list_add(&map4->list,\n\t\t\t\t\t\t     &addrmap->list4);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto cfg_unlbl_map_add_failure;\n\t\t\tbreak;\n\t\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase AF_INET6: {\n\t\t\tconst struct in6_addr *addr6 = addr;\n\t\t\tconst struct in6_addr *mask6 = mask;\n\t\t\tmap6 = kzalloc(sizeof(*map6), GFP_ATOMIC);\n\t\t\tif (map6 == NULL)\n\t\t\t\tgoto cfg_unlbl_map_add_failure;\n\t\t\tmap6->def.type = NETLBL_NLTYPE_UNLABELED;\n\t\t\tmap6->list.addr = *addr6;\n\t\t\tmap6->list.addr.s6_addr32[0] &= mask6->s6_addr32[0];\n\t\t\tmap6->list.addr.s6_addr32[1] &= mask6->s6_addr32[1];\n\t\t\tmap6->list.addr.s6_addr32[2] &= mask6->s6_addr32[2];\n\t\t\tmap6->list.addr.s6_addr32[3] &= mask6->s6_addr32[3];\n\t\t\tmap6->list.mask = *mask6;\n\t\t\tmap6->list.valid = 1;\n\t\t\tret_val = netlbl_af6list_add(&map6->list,\n\t\t\t\t\t\t     &addrmap->list6);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto cfg_unlbl_map_add_failure;\n\t\t\tbreak;\n\t\t\t}\n#endif  \n\t\tdefault:\n\t\t\tgoto cfg_unlbl_map_add_failure;\n\t\t}\n\n\t\tentry->def.addrsel = addrmap;\n\t\tentry->def.type = NETLBL_NLTYPE_ADDRSELECT;\n\t} else {\n\t\tret_val = -EINVAL;\n\t\tgoto cfg_unlbl_map_add_failure;\n\t}\n\n\tret_val = netlbl_domhsh_add(entry, audit_info);\n\tif (ret_val != 0)\n\t\tgoto cfg_unlbl_map_add_failure;\n\n\treturn 0;\n\ncfg_unlbl_map_add_failure:\n\tkfree(entry->domain);\n\tkfree(entry);\n\tkfree(addrmap);\n\tkfree(map4);\n\tkfree(map6);\n\treturn ret_val;\n}\n\n\n \nint netlbl_cfg_unlbl_static_add(struct net *net,\n\t\t\t\tconst char *dev_name,\n\t\t\t\tconst void *addr,\n\t\t\t\tconst void *mask,\n\t\t\t\tu16 family,\n\t\t\t\tu32 secid,\n\t\t\t\tstruct netlbl_audit *audit_info)\n{\n\tu32 addr_len;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\taddr_len = sizeof(struct in_addr);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\taddr_len = sizeof(struct in6_addr);\n\t\tbreak;\n#endif  \n\tdefault:\n\t\treturn -EPFNOSUPPORT;\n\t}\n\n\treturn netlbl_unlhsh_add(net,\n\t\t\t\t dev_name, addr, mask, addr_len,\n\t\t\t\t secid, audit_info);\n}\n\n \nint netlbl_cfg_unlbl_static_del(struct net *net,\n\t\t\t\tconst char *dev_name,\n\t\t\t\tconst void *addr,\n\t\t\t\tconst void *mask,\n\t\t\t\tu16 family,\n\t\t\t\tstruct netlbl_audit *audit_info)\n{\n\tu32 addr_len;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\taddr_len = sizeof(struct in_addr);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\taddr_len = sizeof(struct in6_addr);\n\t\tbreak;\n#endif  \n\tdefault:\n\t\treturn -EPFNOSUPPORT;\n\t}\n\n\treturn netlbl_unlhsh_remove(net,\n\t\t\t\t    dev_name, addr, mask, addr_len,\n\t\t\t\t    audit_info);\n}\n\n \nint netlbl_cfg_cipsov4_add(struct cipso_v4_doi *doi_def,\n\t\t\t   struct netlbl_audit *audit_info)\n{\n\treturn cipso_v4_doi_add(doi_def, audit_info);\n}\n\n \nvoid netlbl_cfg_cipsov4_del(u32 doi, struct netlbl_audit *audit_info)\n{\n\tcipso_v4_doi_remove(doi, audit_info);\n}\n\n \nint netlbl_cfg_cipsov4_map_add(u32 doi,\n\t\t\t       const char *domain,\n\t\t\t       const struct in_addr *addr,\n\t\t\t       const struct in_addr *mask,\n\t\t\t       struct netlbl_audit *audit_info)\n{\n\tint ret_val = -ENOMEM;\n\tstruct cipso_v4_doi *doi_def;\n\tstruct netlbl_dom_map *entry;\n\tstruct netlbl_domaddr_map *addrmap = NULL;\n\tstruct netlbl_domaddr4_map *addrinfo = NULL;\n\n\tdoi_def = cipso_v4_doi_getdef(doi);\n\tif (doi_def == NULL)\n\t\treturn -ENOENT;\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (entry == NULL)\n\t\tgoto out_entry;\n\tentry->family = AF_INET;\n\tif (domain != NULL) {\n\t\tentry->domain = kstrdup(domain, GFP_ATOMIC);\n\t\tif (entry->domain == NULL)\n\t\t\tgoto out_domain;\n\t}\n\n\tif (addr == NULL && mask == NULL) {\n\t\tentry->def.cipso = doi_def;\n\t\tentry->def.type = NETLBL_NLTYPE_CIPSOV4;\n\t} else if (addr != NULL && mask != NULL) {\n\t\taddrmap = kzalloc(sizeof(*addrmap), GFP_ATOMIC);\n\t\tif (addrmap == NULL)\n\t\t\tgoto out_addrmap;\n\t\tINIT_LIST_HEAD(&addrmap->list4);\n\t\tINIT_LIST_HEAD(&addrmap->list6);\n\n\t\taddrinfo = kzalloc(sizeof(*addrinfo), GFP_ATOMIC);\n\t\tif (addrinfo == NULL)\n\t\t\tgoto out_addrinfo;\n\t\taddrinfo->def.cipso = doi_def;\n\t\taddrinfo->def.type = NETLBL_NLTYPE_CIPSOV4;\n\t\taddrinfo->list.addr = addr->s_addr & mask->s_addr;\n\t\taddrinfo->list.mask = mask->s_addr;\n\t\taddrinfo->list.valid = 1;\n\t\tret_val = netlbl_af4list_add(&addrinfo->list, &addrmap->list4);\n\t\tif (ret_val != 0)\n\t\t\tgoto cfg_cipsov4_map_add_failure;\n\n\t\tentry->def.addrsel = addrmap;\n\t\tentry->def.type = NETLBL_NLTYPE_ADDRSELECT;\n\t} else {\n\t\tret_val = -EINVAL;\n\t\tgoto out_addrmap;\n\t}\n\n\tret_val = netlbl_domhsh_add(entry, audit_info);\n\tif (ret_val != 0)\n\t\tgoto cfg_cipsov4_map_add_failure;\n\n\treturn 0;\n\ncfg_cipsov4_map_add_failure:\n\tkfree(addrinfo);\nout_addrinfo:\n\tkfree(addrmap);\nout_addrmap:\n\tkfree(entry->domain);\nout_domain:\n\tkfree(entry);\nout_entry:\n\tcipso_v4_doi_putdef(doi_def);\n\treturn ret_val;\n}\n\n \nint netlbl_cfg_calipso_add(struct calipso_doi *doi_def,\n\t\t\t   struct netlbl_audit *audit_info)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\treturn calipso_doi_add(doi_def, audit_info);\n#else  \n\treturn -ENOSYS;\n#endif  \n}\n\n \nvoid netlbl_cfg_calipso_del(u32 doi, struct netlbl_audit *audit_info)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tcalipso_doi_remove(doi, audit_info);\n#endif  \n}\n\n \nint netlbl_cfg_calipso_map_add(u32 doi,\n\t\t\t       const char *domain,\n\t\t\t       const struct in6_addr *addr,\n\t\t\t       const struct in6_addr *mask,\n\t\t\t       struct netlbl_audit *audit_info)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tint ret_val = -ENOMEM;\n\tstruct calipso_doi *doi_def;\n\tstruct netlbl_dom_map *entry;\n\tstruct netlbl_domaddr_map *addrmap = NULL;\n\tstruct netlbl_domaddr6_map *addrinfo = NULL;\n\n\tdoi_def = calipso_doi_getdef(doi);\n\tif (doi_def == NULL)\n\t\treturn -ENOENT;\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (entry == NULL)\n\t\tgoto out_entry;\n\tentry->family = AF_INET6;\n\tif (domain != NULL) {\n\t\tentry->domain = kstrdup(domain, GFP_ATOMIC);\n\t\tif (entry->domain == NULL)\n\t\t\tgoto out_domain;\n\t}\n\n\tif (addr == NULL && mask == NULL) {\n\t\tentry->def.calipso = doi_def;\n\t\tentry->def.type = NETLBL_NLTYPE_CALIPSO;\n\t} else if (addr != NULL && mask != NULL) {\n\t\taddrmap = kzalloc(sizeof(*addrmap), GFP_ATOMIC);\n\t\tif (addrmap == NULL)\n\t\t\tgoto out_addrmap;\n\t\tINIT_LIST_HEAD(&addrmap->list4);\n\t\tINIT_LIST_HEAD(&addrmap->list6);\n\n\t\taddrinfo = kzalloc(sizeof(*addrinfo), GFP_ATOMIC);\n\t\tif (addrinfo == NULL)\n\t\t\tgoto out_addrinfo;\n\t\taddrinfo->def.calipso = doi_def;\n\t\taddrinfo->def.type = NETLBL_NLTYPE_CALIPSO;\n\t\taddrinfo->list.addr = *addr;\n\t\taddrinfo->list.addr.s6_addr32[0] &= mask->s6_addr32[0];\n\t\taddrinfo->list.addr.s6_addr32[1] &= mask->s6_addr32[1];\n\t\taddrinfo->list.addr.s6_addr32[2] &= mask->s6_addr32[2];\n\t\taddrinfo->list.addr.s6_addr32[3] &= mask->s6_addr32[3];\n\t\taddrinfo->list.mask = *mask;\n\t\taddrinfo->list.valid = 1;\n\t\tret_val = netlbl_af6list_add(&addrinfo->list, &addrmap->list6);\n\t\tif (ret_val != 0)\n\t\t\tgoto cfg_calipso_map_add_failure;\n\n\t\tentry->def.addrsel = addrmap;\n\t\tentry->def.type = NETLBL_NLTYPE_ADDRSELECT;\n\t} else {\n\t\tret_val = -EINVAL;\n\t\tgoto out_addrmap;\n\t}\n\n\tret_val = netlbl_domhsh_add(entry, audit_info);\n\tif (ret_val != 0)\n\t\tgoto cfg_calipso_map_add_failure;\n\n\treturn 0;\n\ncfg_calipso_map_add_failure:\n\tkfree(addrinfo);\nout_addrinfo:\n\tkfree(addrmap);\nout_addrmap:\n\tkfree(entry->domain);\nout_domain:\n\tkfree(entry);\nout_entry:\n\tcalipso_doi_putdef(doi_def);\n\treturn ret_val;\n#else  \n\treturn -ENOSYS;\n#endif  \n}\n\n \n\n#define _CM_F_NONE\t0x00000000\n#define _CM_F_ALLOC\t0x00000001\n#define _CM_F_WALK\t0x00000002\n\n \nstatic struct netlbl_lsm_catmap *_netlbl_catmap_getnode(\n\t\t\t\t\t     struct netlbl_lsm_catmap **catmap,\n\t\t\t\t\t     u32 offset,\n\t\t\t\t\t     unsigned int cm_flags,\n\t\t\t\t\t     gfp_t gfp_flags)\n{\n\tstruct netlbl_lsm_catmap *iter = *catmap;\n\tstruct netlbl_lsm_catmap *prev = NULL;\n\n\tif (iter == NULL)\n\t\tgoto catmap_getnode_alloc;\n\tif (offset < iter->startbit)\n\t\tgoto catmap_getnode_walk;\n\twhile (iter && offset >= (iter->startbit + NETLBL_CATMAP_SIZE)) {\n\t\tprev = iter;\n\t\titer = iter->next;\n\t}\n\tif (iter == NULL || offset < iter->startbit)\n\t\tgoto catmap_getnode_walk;\n\n\treturn iter;\n\ncatmap_getnode_walk:\n\tif (cm_flags & _CM_F_WALK)\n\t\treturn iter;\ncatmap_getnode_alloc:\n\tif (!(cm_flags & _CM_F_ALLOC))\n\t\treturn NULL;\n\n\titer = netlbl_catmap_alloc(gfp_flags);\n\tif (iter == NULL)\n\t\treturn NULL;\n\titer->startbit = offset & ~(NETLBL_CATMAP_SIZE - 1);\n\n\tif (prev == NULL) {\n\t\titer->next = *catmap;\n\t\t*catmap = iter;\n\t} else {\n\t\titer->next = prev->next;\n\t\tprev->next = iter;\n\t}\n\n\treturn iter;\n}\n\n \nint netlbl_catmap_walk(struct netlbl_lsm_catmap *catmap, u32 offset)\n{\n\tstruct netlbl_lsm_catmap *iter;\n\tu32 idx;\n\tu32 bit;\n\tNETLBL_CATMAP_MAPTYPE bitmap;\n\n\titer = _netlbl_catmap_getnode(&catmap, offset, _CM_F_WALK, 0);\n\tif (iter == NULL)\n\t\treturn -ENOENT;\n\tif (offset > iter->startbit) {\n\t\toffset -= iter->startbit;\n\t\tidx = offset / NETLBL_CATMAP_MAPSIZE;\n\t\tbit = offset % NETLBL_CATMAP_MAPSIZE;\n\t} else {\n\t\tidx = 0;\n\t\tbit = 0;\n\t}\n\tbitmap = iter->bitmap[idx] >> bit;\n\n\tfor (;;) {\n\t\tif (bitmap != 0) {\n\t\t\twhile ((bitmap & NETLBL_CATMAP_BIT) == 0) {\n\t\t\t\tbitmap >>= 1;\n\t\t\t\tbit++;\n\t\t\t}\n\t\t\treturn iter->startbit +\n\t\t\t       (NETLBL_CATMAP_MAPSIZE * idx) + bit;\n\t\t}\n\t\tif (++idx >= NETLBL_CATMAP_MAPCNT) {\n\t\t\tif (iter->next != NULL) {\n\t\t\t\titer = iter->next;\n\t\t\t\tidx = 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n\t\t}\n\t\tbitmap = iter->bitmap[idx];\n\t\tbit = 0;\n\t}\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL(netlbl_catmap_walk);\n\n \nint netlbl_catmap_walkrng(struct netlbl_lsm_catmap *catmap, u32 offset)\n{\n\tstruct netlbl_lsm_catmap *iter;\n\tstruct netlbl_lsm_catmap *prev = NULL;\n\tu32 idx;\n\tu32 bit;\n\tNETLBL_CATMAP_MAPTYPE bitmask;\n\tNETLBL_CATMAP_MAPTYPE bitmap;\n\n\titer = _netlbl_catmap_getnode(&catmap, offset, _CM_F_WALK, 0);\n\tif (iter == NULL)\n\t\treturn -ENOENT;\n\tif (offset > iter->startbit) {\n\t\toffset -= iter->startbit;\n\t\tidx = offset / NETLBL_CATMAP_MAPSIZE;\n\t\tbit = offset % NETLBL_CATMAP_MAPSIZE;\n\t} else {\n\t\tidx = 0;\n\t\tbit = 0;\n\t}\n\tbitmask = NETLBL_CATMAP_BIT << bit;\n\n\tfor (;;) {\n\t\tbitmap = iter->bitmap[idx];\n\t\twhile (bitmask != 0 && (bitmap & bitmask) != 0) {\n\t\t\tbitmask <<= 1;\n\t\t\tbit++;\n\t\t}\n\n\t\tif (prev && idx == 0 && bit == 0)\n\t\t\treturn prev->startbit + NETLBL_CATMAP_SIZE - 1;\n\t\telse if (bitmask != 0)\n\t\t\treturn iter->startbit +\n\t\t\t\t(NETLBL_CATMAP_MAPSIZE * idx) + bit - 1;\n\t\telse if (++idx >= NETLBL_CATMAP_MAPCNT) {\n\t\t\tif (iter->next == NULL)\n\t\t\t\treturn iter->startbit + NETLBL_CATMAP_SIZE - 1;\n\t\t\tprev = iter;\n\t\t\titer = iter->next;\n\t\t\tidx = 0;\n\t\t}\n\t\tbitmask = NETLBL_CATMAP_BIT;\n\t\tbit = 0;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nint netlbl_catmap_getlong(struct netlbl_lsm_catmap *catmap,\n\t\t\t  u32 *offset,\n\t\t\t  unsigned long *bitmap)\n{\n\tstruct netlbl_lsm_catmap *iter;\n\tu32 off = *offset;\n\tu32 idx;\n\n\t \n\tif ((off & (BITS_PER_LONG - 1)) != 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (!catmap) {\n\t\t*offset = (u32)-1;\n\t\treturn 0;\n\t}\n\n\tif (off < catmap->startbit) {\n\t\toff = catmap->startbit;\n\t\t*offset = off;\n\t}\n\titer = _netlbl_catmap_getnode(&catmap, off, _CM_F_WALK, 0);\n\tif (iter == NULL) {\n\t\t*offset = (u32)-1;\n\t\treturn 0;\n\t}\n\n\tif (off < iter->startbit) {\n\t\t*offset = iter->startbit;\n\t\toff = 0;\n\t} else\n\t\toff -= iter->startbit;\n\tidx = off / NETLBL_CATMAP_MAPSIZE;\n\t*bitmap = iter->bitmap[idx] >> (off % NETLBL_CATMAP_MAPSIZE);\n\n\treturn 0;\n}\n\n \nint netlbl_catmap_setbit(struct netlbl_lsm_catmap **catmap,\n\t\t\t u32 bit,\n\t\t\t gfp_t flags)\n{\n\tstruct netlbl_lsm_catmap *iter;\n\tu32 idx;\n\n\titer = _netlbl_catmap_getnode(catmap, bit, _CM_F_ALLOC, flags);\n\tif (iter == NULL)\n\t\treturn -ENOMEM;\n\n\tbit -= iter->startbit;\n\tidx = bit / NETLBL_CATMAP_MAPSIZE;\n\titer->bitmap[idx] |= NETLBL_CATMAP_BIT << (bit % NETLBL_CATMAP_MAPSIZE);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(netlbl_catmap_setbit);\n\n \nint netlbl_catmap_setrng(struct netlbl_lsm_catmap **catmap,\n\t\t\t u32 start,\n\t\t\t u32 end,\n\t\t\t gfp_t flags)\n{\n\tint rc = 0;\n\tu32 spot = start;\n\n\twhile (rc == 0 && spot <= end) {\n\t\tif (((spot & (BITS_PER_LONG - 1)) == 0) &&\n\t\t    ((end - spot) > BITS_PER_LONG)) {\n\t\t\trc = netlbl_catmap_setlong(catmap,\n\t\t\t\t\t\t   spot,\n\t\t\t\t\t\t   (unsigned long)-1,\n\t\t\t\t\t\t   flags);\n\t\t\tspot += BITS_PER_LONG;\n\t\t} else\n\t\t\trc = netlbl_catmap_setbit(catmap, spot++, flags);\n\t}\n\n\treturn rc;\n}\n\n \nint netlbl_catmap_setlong(struct netlbl_lsm_catmap **catmap,\n\t\t\t  u32 offset,\n\t\t\t  unsigned long bitmap,\n\t\t\t  gfp_t flags)\n{\n\tstruct netlbl_lsm_catmap *iter;\n\tu32 idx;\n\n\t \n\tif ((offset & (BITS_PER_LONG - 1)) != 0)\n\t\treturn -EINVAL;\n\n\titer = _netlbl_catmap_getnode(catmap, offset, _CM_F_ALLOC, flags);\n\tif (iter == NULL)\n\t\treturn -ENOMEM;\n\n\toffset -= iter->startbit;\n\tidx = offset / NETLBL_CATMAP_MAPSIZE;\n\titer->bitmap[idx] |= (NETLBL_CATMAP_MAPTYPE)bitmap\n\t\t\t     << (offset % NETLBL_CATMAP_MAPSIZE);\n\n\treturn 0;\n}\n\n \n\n \nint netlbl_bitmap_walk(const unsigned char *bitmap, u32 bitmap_len,\n\t\t       u32 offset, u8 state)\n{\n\tu32 bit_spot;\n\tu32 byte_offset;\n\tunsigned char bitmask;\n\tunsigned char byte;\n\n\tif (offset >= bitmap_len)\n\t\treturn -1;\n\tbyte_offset = offset / 8;\n\tbyte = bitmap[byte_offset];\n\tbit_spot = offset;\n\tbitmask = 0x80 >> (offset % 8);\n\n\twhile (bit_spot < bitmap_len) {\n\t\tif ((state && (byte & bitmask) == bitmask) ||\n\t\t    (state == 0 && (byte & bitmask) == 0))\n\t\t\treturn bit_spot;\n\n\t\tif (++bit_spot >= bitmap_len)\n\t\t\treturn -1;\n\t\tbitmask >>= 1;\n\t\tif (bitmask == 0) {\n\t\t\tbyte = bitmap[++byte_offset];\n\t\t\tbitmask = 0x80;\n\t\t}\n\t}\n\n\treturn -1;\n}\nEXPORT_SYMBOL(netlbl_bitmap_walk);\n\n \nvoid netlbl_bitmap_setbit(unsigned char *bitmap, u32 bit, u8 state)\n{\n\tu32 byte_spot;\n\tu8 bitmask;\n\n\t \n\tbyte_spot = bit / 8;\n\tbitmask = 0x80 >> (bit % 8);\n\tif (state)\n\t\tbitmap[byte_spot] |= bitmask;\n\telse\n\t\tbitmap[byte_spot] &= ~bitmask;\n}\nEXPORT_SYMBOL(netlbl_bitmap_setbit);\n\n \n\n \nint netlbl_enabled(void)\n{\n\t \n\treturn (atomic_read(&netlabel_mgmt_protocount) > 0);\n}\n\n \nint netlbl_sock_setattr(struct sock *sk,\n\t\t\tu16 family,\n\t\t\tconst struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tstruct netlbl_dom_map *dom_entry;\n\n\trcu_read_lock();\n\tdom_entry = netlbl_domhsh_getentry(secattr->domain, family);\n\tif (dom_entry == NULL) {\n\t\tret_val = -ENOENT;\n\t\tgoto socket_setattr_return;\n\t}\n\tswitch (family) {\n\tcase AF_INET:\n\t\tswitch (dom_entry->def.type) {\n\t\tcase NETLBL_NLTYPE_ADDRSELECT:\n\t\t\tret_val = -EDESTADDRREQ;\n\t\t\tbreak;\n\t\tcase NETLBL_NLTYPE_CIPSOV4:\n\t\t\tret_val = cipso_v4_sock_setattr(sk,\n\t\t\t\t\t\t\tdom_entry->def.cipso,\n\t\t\t\t\t\t\tsecattr);\n\t\t\tbreak;\n\t\tcase NETLBL_NLTYPE_UNLABELED:\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_val = -ENOENT;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tswitch (dom_entry->def.type) {\n\t\tcase NETLBL_NLTYPE_ADDRSELECT:\n\t\t\tret_val = -EDESTADDRREQ;\n\t\t\tbreak;\n\t\tcase NETLBL_NLTYPE_CALIPSO:\n\t\t\tret_val = calipso_sock_setattr(sk,\n\t\t\t\t\t\t       dom_entry->def.calipso,\n\t\t\t\t\t\t       secattr);\n\t\t\tbreak;\n\t\tcase NETLBL_NLTYPE_UNLABELED:\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_val = -ENOENT;\n\t\t}\n\t\tbreak;\n#endif  \n\tdefault:\n\t\tret_val = -EPROTONOSUPPORT;\n\t}\n\nsocket_setattr_return:\n\trcu_read_unlock();\n\treturn ret_val;\n}\n\n \nvoid netlbl_sock_delattr(struct sock *sk)\n{\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tcipso_v4_sock_delattr(sk);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tcalipso_sock_delattr(sk);\n\t\tbreak;\n#endif  \n\t}\n}\n\n \nint netlbl_sock_getattr(struct sock *sk,\n\t\t\tstruct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tret_val = cipso_v4_sock_getattr(sk, secattr);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tret_val = calipso_sock_getattr(sk, secattr);\n\t\tbreak;\n#endif  \n\tdefault:\n\t\tret_val = -EPROTONOSUPPORT;\n\t}\n\n\treturn ret_val;\n}\n\n \nint netlbl_conn_setattr(struct sock *sk,\n\t\t\tstruct sockaddr *addr,\n\t\t\tconst struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tstruct sockaddr_in *addr4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct sockaddr_in6 *addr6;\n#endif\n\tstruct netlbl_dommap_def *entry;\n\n\trcu_read_lock();\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\taddr4 = (struct sockaddr_in *)addr;\n\t\tentry = netlbl_domhsh_getentry_af4(secattr->domain,\n\t\t\t\t\t\t   addr4->sin_addr.s_addr);\n\t\tif (entry == NULL) {\n\t\t\tret_val = -ENOENT;\n\t\t\tgoto conn_setattr_return;\n\t\t}\n\t\tswitch (entry->type) {\n\t\tcase NETLBL_NLTYPE_CIPSOV4:\n\t\t\tret_val = cipso_v4_sock_setattr(sk,\n\t\t\t\t\t\t\tentry->cipso, secattr);\n\t\t\tbreak;\n\t\tcase NETLBL_NLTYPE_UNLABELED:\n\t\t\t \n\t\t\tnetlbl_sock_delattr(sk);\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_val = -ENOENT;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\taddr6 = (struct sockaddr_in6 *)addr;\n\t\tentry = netlbl_domhsh_getentry_af6(secattr->domain,\n\t\t\t\t\t\t   &addr6->sin6_addr);\n\t\tif (entry == NULL) {\n\t\t\tret_val = -ENOENT;\n\t\t\tgoto conn_setattr_return;\n\t\t}\n\t\tswitch (entry->type) {\n\t\tcase NETLBL_NLTYPE_CALIPSO:\n\t\t\tret_val = calipso_sock_setattr(sk,\n\t\t\t\t\t\t       entry->calipso, secattr);\n\t\t\tbreak;\n\t\tcase NETLBL_NLTYPE_UNLABELED:\n\t\t\t \n\t\t\tnetlbl_sock_delattr(sk);\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_val = -ENOENT;\n\t\t}\n\t\tbreak;\n#endif  \n\tdefault:\n\t\tret_val = -EPROTONOSUPPORT;\n\t}\n\nconn_setattr_return:\n\trcu_read_unlock();\n\treturn ret_val;\n}\n\n \nint netlbl_req_setattr(struct request_sock *req,\n\t\t       const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tstruct netlbl_dommap_def *entry;\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\trcu_read_lock();\n\tswitch (req->rsk_ops->family) {\n\tcase AF_INET:\n\t\tentry = netlbl_domhsh_getentry_af4(secattr->domain,\n\t\t\t\t\t\t   ireq->ir_rmt_addr);\n\t\tif (entry == NULL) {\n\t\t\tret_val = -ENOENT;\n\t\t\tgoto req_setattr_return;\n\t\t}\n\t\tswitch (entry->type) {\n\t\tcase NETLBL_NLTYPE_CIPSOV4:\n\t\t\tret_val = cipso_v4_req_setattr(req,\n\t\t\t\t\t\t       entry->cipso, secattr);\n\t\t\tbreak;\n\t\tcase NETLBL_NLTYPE_UNLABELED:\n\t\t\tnetlbl_req_delattr(req);\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_val = -ENOENT;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tentry = netlbl_domhsh_getentry_af6(secattr->domain,\n\t\t\t\t\t\t   &ireq->ir_v6_rmt_addr);\n\t\tif (entry == NULL) {\n\t\t\tret_val = -ENOENT;\n\t\t\tgoto req_setattr_return;\n\t\t}\n\t\tswitch (entry->type) {\n\t\tcase NETLBL_NLTYPE_CALIPSO:\n\t\t\tret_val = calipso_req_setattr(req,\n\t\t\t\t\t\t      entry->calipso, secattr);\n\t\t\tbreak;\n\t\tcase NETLBL_NLTYPE_UNLABELED:\n\t\t\tnetlbl_req_delattr(req);\n\t\t\tret_val = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_val = -ENOENT;\n\t\t}\n\t\tbreak;\n#endif  \n\tdefault:\n\t\tret_val = -EPROTONOSUPPORT;\n\t}\n\nreq_setattr_return:\n\trcu_read_unlock();\n\treturn ret_val;\n}\n\n \nvoid netlbl_req_delattr(struct request_sock *req)\n{\n\tswitch (req->rsk_ops->family) {\n\tcase AF_INET:\n\t\tcipso_v4_req_delattr(req);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tcalipso_req_delattr(req);\n\t\tbreak;\n#endif  \n\t}\n}\n\n \nint netlbl_skbuff_setattr(struct sk_buff *skb,\n\t\t\t  u16 family,\n\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tstruct iphdr *hdr4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct ipv6hdr *hdr6;\n#endif\n\tstruct netlbl_dommap_def *entry;\n\n\trcu_read_lock();\n\tswitch (family) {\n\tcase AF_INET:\n\t\thdr4 = ip_hdr(skb);\n\t\tentry = netlbl_domhsh_getentry_af4(secattr->domain,\n\t\t\t\t\t\t   hdr4->daddr);\n\t\tif (entry == NULL) {\n\t\t\tret_val = -ENOENT;\n\t\t\tgoto skbuff_setattr_return;\n\t\t}\n\t\tswitch (entry->type) {\n\t\tcase NETLBL_NLTYPE_CIPSOV4:\n\t\t\tret_val = cipso_v4_skbuff_setattr(skb, entry->cipso,\n\t\t\t\t\t\t\t  secattr);\n\t\t\tbreak;\n\t\tcase NETLBL_NLTYPE_UNLABELED:\n\t\t\t \n\t\t\tret_val = cipso_v4_skbuff_delattr(skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_val = -ENOENT;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\thdr6 = ipv6_hdr(skb);\n\t\tentry = netlbl_domhsh_getentry_af6(secattr->domain,\n\t\t\t\t\t\t   &hdr6->daddr);\n\t\tif (entry == NULL) {\n\t\t\tret_val = -ENOENT;\n\t\t\tgoto skbuff_setattr_return;\n\t\t}\n\t\tswitch (entry->type) {\n\t\tcase NETLBL_NLTYPE_CALIPSO:\n\t\t\tret_val = calipso_skbuff_setattr(skb, entry->calipso,\n\t\t\t\t\t\t\t secattr);\n\t\t\tbreak;\n\t\tcase NETLBL_NLTYPE_UNLABELED:\n\t\t\t \n\t\t\tret_val = calipso_skbuff_delattr(skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_val = -ENOENT;\n\t\t}\n\t\tbreak;\n#endif  \n\tdefault:\n\t\tret_val = -EPROTONOSUPPORT;\n\t}\n\nskbuff_setattr_return:\n\trcu_read_unlock();\n\treturn ret_val;\n}\n\n \nint netlbl_skbuff_getattr(const struct sk_buff *skb,\n\t\t\t  u16 family,\n\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\tunsigned char *ptr;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tptr = cipso_v4_optptr(skb);\n\t\tif (ptr && cipso_v4_getattr(ptr, secattr) == 0)\n\t\t\treturn 0;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tptr = calipso_optptr(skb);\n\t\tif (ptr && calipso_getattr(ptr, secattr) == 0)\n\t\t\treturn 0;\n\t\tbreak;\n#endif  \n\t}\n\n\treturn netlbl_unlabel_getattr(skb, family, secattr);\n}\n\n \nvoid netlbl_skbuff_err(struct sk_buff *skb, u16 family, int error, int gateway)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\tif (cipso_v4_optptr(skb))\n\t\t\tcipso_v4_error(skb, error, gateway);\n\t\tbreak;\n\t}\n}\n\n \nvoid netlbl_cache_invalidate(void)\n{\n\tcipso_v4_cache_invalidate();\n#if IS_ENABLED(CONFIG_IPV6)\n\tcalipso_cache_invalidate();\n#endif  \n}\n\n \nint netlbl_cache_add(const struct sk_buff *skb, u16 family,\n\t\t     const struct netlbl_lsm_secattr *secattr)\n{\n\tunsigned char *ptr;\n\n\tif ((secattr->flags & NETLBL_SECATTR_CACHE) == 0)\n\t\treturn -ENOMSG;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tptr = cipso_v4_optptr(skb);\n\t\tif (ptr)\n\t\t\treturn cipso_v4_cache_add(ptr, secattr);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tptr = calipso_optptr(skb);\n\t\tif (ptr)\n\t\t\treturn calipso_cache_add(ptr, secattr);\n\t\tbreak;\n#endif  \n\t}\n\treturn -ENOMSG;\n}\n\n \n\n \nstruct audit_buffer *netlbl_audit_start(int type,\n\t\t\t\t\tstruct netlbl_audit *audit_info)\n{\n\treturn netlbl_audit_start_common(type, audit_info);\n}\nEXPORT_SYMBOL(netlbl_audit_start);\n\n \n\n \nstatic int __init netlbl_init(void)\n{\n\tint ret_val;\n\n\tprintk(KERN_INFO \"NetLabel: Initializing\\n\");\n\tprintk(KERN_INFO \"NetLabel:  domain hash size = %u\\n\",\n\t       (1 << NETLBL_DOMHSH_BITSIZE));\n\tprintk(KERN_INFO \"NetLabel:  protocols = UNLABELED CIPSOv4 CALIPSO\\n\");\n\n\tret_val = netlbl_domhsh_init(NETLBL_DOMHSH_BITSIZE);\n\tif (ret_val != 0)\n\t\tgoto init_failure;\n\n\tret_val = netlbl_unlabel_init(NETLBL_UNLHSH_BITSIZE);\n\tif (ret_val != 0)\n\t\tgoto init_failure;\n\n\tret_val = netlbl_netlink_init();\n\tif (ret_val != 0)\n\t\tgoto init_failure;\n\n\tret_val = netlbl_unlabel_defconf();\n\tif (ret_val != 0)\n\t\tgoto init_failure;\n\tprintk(KERN_INFO \"NetLabel:  unlabeled traffic allowed by default\\n\");\n\n\treturn 0;\n\ninit_failure:\n\tpanic(\"NetLabel: failed to initialize properly (%d)\\n\", ret_val);\n}\n\nsubsys_initcall(netlbl_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}