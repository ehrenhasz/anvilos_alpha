{
  "module_name": "netlabel_unlabeled.c",
  "hash_id": "216e150cd1a63100b401d765b802373c041209019d73a1c501fbdf7c57674cec",
  "original_prompt": "Ingested from linux-6.6.14/net/netlabel/netlabel_unlabeled.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/socket.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/notifier.h>\n#include <linux/netdevice.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/netlink.h>\n#include <net/genetlink.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/net_namespace.h>\n#include <net/netlabel.h>\n#include <asm/bug.h>\n#include <linux/atomic.h>\n\n#include \"netlabel_user.h\"\n#include \"netlabel_addrlist.h\"\n#include \"netlabel_domainhash.h\"\n#include \"netlabel_unlabeled.h\"\n#include \"netlabel_mgmt.h\"\n\n \n\n \nstruct netlbl_unlhsh_tbl {\n\tstruct list_head *tbl;\n\tu32 size;\n};\n#define netlbl_unlhsh_addr4_entry(iter) \\\n\tcontainer_of(iter, struct netlbl_unlhsh_addr4, list)\nstruct netlbl_unlhsh_addr4 {\n\tu32 secid;\n\n\tstruct netlbl_af4list list;\n\tstruct rcu_head rcu;\n};\n#define netlbl_unlhsh_addr6_entry(iter) \\\n\tcontainer_of(iter, struct netlbl_unlhsh_addr6, list)\nstruct netlbl_unlhsh_addr6 {\n\tu32 secid;\n\n\tstruct netlbl_af6list list;\n\tstruct rcu_head rcu;\n};\nstruct netlbl_unlhsh_iface {\n\tint ifindex;\n\tstruct list_head addr4_list;\n\tstruct list_head addr6_list;\n\n\tu32 valid;\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n};\n\n \nstruct netlbl_unlhsh_walk_arg {\n\tstruct netlink_callback *nl_cb;\n\tstruct sk_buff *skb;\n\tu32 seq;\n};\n\n \n \nstatic DEFINE_SPINLOCK(netlbl_unlhsh_lock);\n#define netlbl_unlhsh_rcu_deref(p) \\\n\trcu_dereference_check(p, lockdep_is_held(&netlbl_unlhsh_lock))\nstatic struct netlbl_unlhsh_tbl __rcu *netlbl_unlhsh;\nstatic struct netlbl_unlhsh_iface __rcu *netlbl_unlhsh_def;\n\n \nstatic u8 netlabel_unlabel_acceptflg;\n\n \nstatic struct genl_family netlbl_unlabel_gnl_family;\n\n \nstatic const struct nla_policy netlbl_unlabel_genl_policy[NLBL_UNLABEL_A_MAX + 1] = {\n\t[NLBL_UNLABEL_A_ACPTFLG] = { .type = NLA_U8 },\n\t[NLBL_UNLABEL_A_IPV6ADDR] = { .type = NLA_BINARY,\n\t\t\t\t      .len = sizeof(struct in6_addr) },\n\t[NLBL_UNLABEL_A_IPV6MASK] = { .type = NLA_BINARY,\n\t\t\t\t      .len = sizeof(struct in6_addr) },\n\t[NLBL_UNLABEL_A_IPV4ADDR] = { .type = NLA_BINARY,\n\t\t\t\t      .len = sizeof(struct in_addr) },\n\t[NLBL_UNLABEL_A_IPV4MASK] = { .type = NLA_BINARY,\n\t\t\t\t      .len = sizeof(struct in_addr) },\n\t[NLBL_UNLABEL_A_IFACE] = { .type = NLA_NUL_STRING,\n\t\t\t\t   .len = IFNAMSIZ - 1 },\n\t[NLBL_UNLABEL_A_SECCTX] = { .type = NLA_BINARY }\n};\n\n \n\n \nstatic void netlbl_unlhsh_free_iface(struct rcu_head *entry)\n{\n\tstruct netlbl_unlhsh_iface *iface;\n\tstruct netlbl_af4list *iter4;\n\tstruct netlbl_af4list *tmp4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct netlbl_af6list *iter6;\n\tstruct netlbl_af6list *tmp6;\n#endif  \n\n\tiface = container_of(entry, struct netlbl_unlhsh_iface, rcu);\n\n\t \n\n\tnetlbl_af4list_foreach_safe(iter4, tmp4, &iface->addr4_list) {\n\t\tnetlbl_af4list_remove_entry(iter4);\n\t\tkfree(netlbl_unlhsh_addr4_entry(iter4));\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tnetlbl_af6list_foreach_safe(iter6, tmp6, &iface->addr6_list) {\n\t\tnetlbl_af6list_remove_entry(iter6);\n\t\tkfree(netlbl_unlhsh_addr6_entry(iter6));\n\t}\n#endif  \n\tkfree(iface);\n}\n\n \nstatic u32 netlbl_unlhsh_hash(int ifindex)\n{\n\treturn ifindex & (netlbl_unlhsh_rcu_deref(netlbl_unlhsh)->size - 1);\n}\n\n \nstatic struct netlbl_unlhsh_iface *netlbl_unlhsh_search_iface(int ifindex)\n{\n\tu32 bkt;\n\tstruct list_head *bkt_list;\n\tstruct netlbl_unlhsh_iface *iter;\n\n\tbkt = netlbl_unlhsh_hash(ifindex);\n\tbkt_list = &netlbl_unlhsh_rcu_deref(netlbl_unlhsh)->tbl[bkt];\n\tlist_for_each_entry_rcu(iter, bkt_list, list,\n\t\t\t\tlockdep_is_held(&netlbl_unlhsh_lock))\n\t\tif (iter->valid && iter->ifindex == ifindex)\n\t\t\treturn iter;\n\n\treturn NULL;\n}\n\n \nstatic int netlbl_unlhsh_add_addr4(struct netlbl_unlhsh_iface *iface,\n\t\t\t\t   const struct in_addr *addr,\n\t\t\t\t   const struct in_addr *mask,\n\t\t\t\t   u32 secid)\n{\n\tint ret_val;\n\tstruct netlbl_unlhsh_addr4 *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\n\tentry->list.addr = addr->s_addr & mask->s_addr;\n\tentry->list.mask = mask->s_addr;\n\tentry->list.valid = 1;\n\tentry->secid = secid;\n\n\tspin_lock(&netlbl_unlhsh_lock);\n\tret_val = netlbl_af4list_add(&entry->list, &iface->addr4_list);\n\tspin_unlock(&netlbl_unlhsh_lock);\n\n\tif (ret_val != 0)\n\t\tkfree(entry);\n\treturn ret_val;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nstatic int netlbl_unlhsh_add_addr6(struct netlbl_unlhsh_iface *iface,\n\t\t\t\t   const struct in6_addr *addr,\n\t\t\t\t   const struct in6_addr *mask,\n\t\t\t\t   u32 secid)\n{\n\tint ret_val;\n\tstruct netlbl_unlhsh_addr6 *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\n\tentry->list.addr = *addr;\n\tentry->list.addr.s6_addr32[0] &= mask->s6_addr32[0];\n\tentry->list.addr.s6_addr32[1] &= mask->s6_addr32[1];\n\tentry->list.addr.s6_addr32[2] &= mask->s6_addr32[2];\n\tentry->list.addr.s6_addr32[3] &= mask->s6_addr32[3];\n\tentry->list.mask = *mask;\n\tentry->list.valid = 1;\n\tentry->secid = secid;\n\n\tspin_lock(&netlbl_unlhsh_lock);\n\tret_val = netlbl_af6list_add(&entry->list, &iface->addr6_list);\n\tspin_unlock(&netlbl_unlhsh_lock);\n\n\tif (ret_val != 0)\n\t\tkfree(entry);\n\treturn 0;\n}\n#endif  \n\n \nstatic struct netlbl_unlhsh_iface *netlbl_unlhsh_add_iface(int ifindex)\n{\n\tu32 bkt;\n\tstruct netlbl_unlhsh_iface *iface;\n\n\tiface = kzalloc(sizeof(*iface), GFP_ATOMIC);\n\tif (iface == NULL)\n\t\treturn NULL;\n\n\tiface->ifindex = ifindex;\n\tINIT_LIST_HEAD(&iface->addr4_list);\n\tINIT_LIST_HEAD(&iface->addr6_list);\n\tiface->valid = 1;\n\n\tspin_lock(&netlbl_unlhsh_lock);\n\tif (ifindex > 0) {\n\t\tbkt = netlbl_unlhsh_hash(ifindex);\n\t\tif (netlbl_unlhsh_search_iface(ifindex) != NULL)\n\t\t\tgoto add_iface_failure;\n\t\tlist_add_tail_rcu(&iface->list,\n\t\t\t     &netlbl_unlhsh_rcu_deref(netlbl_unlhsh)->tbl[bkt]);\n\t} else {\n\t\tINIT_LIST_HEAD(&iface->list);\n\t\tif (netlbl_unlhsh_rcu_deref(netlbl_unlhsh_def) != NULL)\n\t\t\tgoto add_iface_failure;\n\t\trcu_assign_pointer(netlbl_unlhsh_def, iface);\n\t}\n\tspin_unlock(&netlbl_unlhsh_lock);\n\n\treturn iface;\n\nadd_iface_failure:\n\tspin_unlock(&netlbl_unlhsh_lock);\n\tkfree(iface);\n\treturn NULL;\n}\n\n \nint netlbl_unlhsh_add(struct net *net,\n\t\t      const char *dev_name,\n\t\t      const void *addr,\n\t\t      const void *mask,\n\t\t      u32 addr_len,\n\t\t      u32 secid,\n\t\t      struct netlbl_audit *audit_info)\n{\n\tint ret_val;\n\tint ifindex;\n\tstruct net_device *dev;\n\tstruct netlbl_unlhsh_iface *iface;\n\tstruct audit_buffer *audit_buf = NULL;\n\tchar *secctx = NULL;\n\tu32 secctx_len;\n\n\tif (addr_len != sizeof(struct in_addr) &&\n\t    addr_len != sizeof(struct in6_addr))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tif (dev_name != NULL) {\n\t\tdev = dev_get_by_name_rcu(net, dev_name);\n\t\tif (dev == NULL) {\n\t\t\tret_val = -ENODEV;\n\t\t\tgoto unlhsh_add_return;\n\t\t}\n\t\tifindex = dev->ifindex;\n\t\tiface = netlbl_unlhsh_search_iface(ifindex);\n\t} else {\n\t\tifindex = 0;\n\t\tiface = rcu_dereference(netlbl_unlhsh_def);\n\t}\n\tif (iface == NULL) {\n\t\tiface = netlbl_unlhsh_add_iface(ifindex);\n\t\tif (iface == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto unlhsh_add_return;\n\t\t}\n\t}\n\taudit_buf = netlbl_audit_start_common(AUDIT_MAC_UNLBL_STCADD,\n\t\t\t\t\t      audit_info);\n\tswitch (addr_len) {\n\tcase sizeof(struct in_addr): {\n\t\tconst struct in_addr *addr4 = addr;\n\t\tconst struct in_addr *mask4 = mask;\n\n\t\tret_val = netlbl_unlhsh_add_addr4(iface, addr4, mask4, secid);\n\t\tif (audit_buf != NULL)\n\t\t\tnetlbl_af4list_audit_addr(audit_buf, 1,\n\t\t\t\t\t\t  dev_name,\n\t\t\t\t\t\t  addr4->s_addr,\n\t\t\t\t\t\t  mask4->s_addr);\n\t\tbreak;\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase sizeof(struct in6_addr): {\n\t\tconst struct in6_addr *addr6 = addr;\n\t\tconst struct in6_addr *mask6 = mask;\n\n\t\tret_val = netlbl_unlhsh_add_addr6(iface, addr6, mask6, secid);\n\t\tif (audit_buf != NULL)\n\t\t\tnetlbl_af6list_audit_addr(audit_buf, 1,\n\t\t\t\t\t\t  dev_name,\n\t\t\t\t\t\t  addr6, mask6);\n\t\tbreak;\n\t}\n#endif  \n\tdefault:\n\t\tret_val = -EINVAL;\n\t}\n\tif (ret_val == 0)\n\t\tatomic_inc(&netlabel_mgmt_protocount);\n\nunlhsh_add_return:\n\trcu_read_unlock();\n\tif (audit_buf != NULL) {\n\t\tif (security_secid_to_secctx(secid,\n\t\t\t\t\t     &secctx,\n\t\t\t\t\t     &secctx_len) == 0) {\n\t\t\taudit_log_format(audit_buf, \" sec_obj=%s\", secctx);\n\t\t\tsecurity_release_secctx(secctx, secctx_len);\n\t\t}\n\t\taudit_log_format(audit_buf, \" res=%u\", ret_val == 0 ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\treturn ret_val;\n}\n\n \nstatic int netlbl_unlhsh_remove_addr4(struct net *net,\n\t\t\t\t      struct netlbl_unlhsh_iface *iface,\n\t\t\t\t      const struct in_addr *addr,\n\t\t\t\t      const struct in_addr *mask,\n\t\t\t\t      struct netlbl_audit *audit_info)\n{\n\tstruct netlbl_af4list *list_entry;\n\tstruct netlbl_unlhsh_addr4 *entry;\n\tstruct audit_buffer *audit_buf;\n\tstruct net_device *dev;\n\tchar *secctx;\n\tu32 secctx_len;\n\n\tspin_lock(&netlbl_unlhsh_lock);\n\tlist_entry = netlbl_af4list_remove(addr->s_addr, mask->s_addr,\n\t\t\t\t\t   &iface->addr4_list);\n\tspin_unlock(&netlbl_unlhsh_lock);\n\tif (list_entry != NULL)\n\t\tentry = netlbl_unlhsh_addr4_entry(list_entry);\n\telse\n\t\tentry = NULL;\n\n\taudit_buf = netlbl_audit_start_common(AUDIT_MAC_UNLBL_STCDEL,\n\t\t\t\t\t      audit_info);\n\tif (audit_buf != NULL) {\n\t\tdev = dev_get_by_index(net, iface->ifindex);\n\t\tnetlbl_af4list_audit_addr(audit_buf, 1,\n\t\t\t\t\t  (dev != NULL ? dev->name : NULL),\n\t\t\t\t\t  addr->s_addr, mask->s_addr);\n\t\tdev_put(dev);\n\t\tif (entry != NULL &&\n\t\t    security_secid_to_secctx(entry->secid,\n\t\t\t\t\t     &secctx, &secctx_len) == 0) {\n\t\t\taudit_log_format(audit_buf, \" sec_obj=%s\", secctx);\n\t\t\tsecurity_release_secctx(secctx, secctx_len);\n\t\t}\n\t\taudit_log_format(audit_buf, \" res=%u\", entry != NULL ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\n\tif (entry == NULL)\n\t\treturn -ENOENT;\n\n\tkfree_rcu(entry, rcu);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nstatic int netlbl_unlhsh_remove_addr6(struct net *net,\n\t\t\t\t      struct netlbl_unlhsh_iface *iface,\n\t\t\t\t      const struct in6_addr *addr,\n\t\t\t\t      const struct in6_addr *mask,\n\t\t\t\t      struct netlbl_audit *audit_info)\n{\n\tstruct netlbl_af6list *list_entry;\n\tstruct netlbl_unlhsh_addr6 *entry;\n\tstruct audit_buffer *audit_buf;\n\tstruct net_device *dev;\n\tchar *secctx;\n\tu32 secctx_len;\n\n\tspin_lock(&netlbl_unlhsh_lock);\n\tlist_entry = netlbl_af6list_remove(addr, mask, &iface->addr6_list);\n\tspin_unlock(&netlbl_unlhsh_lock);\n\tif (list_entry != NULL)\n\t\tentry = netlbl_unlhsh_addr6_entry(list_entry);\n\telse\n\t\tentry = NULL;\n\n\taudit_buf = netlbl_audit_start_common(AUDIT_MAC_UNLBL_STCDEL,\n\t\t\t\t\t      audit_info);\n\tif (audit_buf != NULL) {\n\t\tdev = dev_get_by_index(net, iface->ifindex);\n\t\tnetlbl_af6list_audit_addr(audit_buf, 1,\n\t\t\t\t\t  (dev != NULL ? dev->name : NULL),\n\t\t\t\t\t  addr, mask);\n\t\tdev_put(dev);\n\t\tif (entry != NULL &&\n\t\t    security_secid_to_secctx(entry->secid,\n\t\t\t\t\t     &secctx, &secctx_len) == 0) {\n\t\t\taudit_log_format(audit_buf, \" sec_obj=%s\", secctx);\n\t\t\tsecurity_release_secctx(secctx, secctx_len);\n\t\t}\n\t\taudit_log_format(audit_buf, \" res=%u\", entry != NULL ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\n\tif (entry == NULL)\n\t\treturn -ENOENT;\n\n\tkfree_rcu(entry, rcu);\n\treturn 0;\n}\n#endif  \n\n \nstatic void netlbl_unlhsh_condremove_iface(struct netlbl_unlhsh_iface *iface)\n{\n\tstruct netlbl_af4list *iter4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct netlbl_af6list *iter6;\n#endif  \n\n\tspin_lock(&netlbl_unlhsh_lock);\n\tnetlbl_af4list_foreach_rcu(iter4, &iface->addr4_list)\n\t\tgoto unlhsh_condremove_failure;\n#if IS_ENABLED(CONFIG_IPV6)\n\tnetlbl_af6list_foreach_rcu(iter6, &iface->addr6_list)\n\t\tgoto unlhsh_condremove_failure;\n#endif  \n\tiface->valid = 0;\n\tif (iface->ifindex > 0)\n\t\tlist_del_rcu(&iface->list);\n\telse\n\t\tRCU_INIT_POINTER(netlbl_unlhsh_def, NULL);\n\tspin_unlock(&netlbl_unlhsh_lock);\n\n\tcall_rcu(&iface->rcu, netlbl_unlhsh_free_iface);\n\treturn;\n\nunlhsh_condremove_failure:\n\tspin_unlock(&netlbl_unlhsh_lock);\n}\n\n \nint netlbl_unlhsh_remove(struct net *net,\n\t\t\t const char *dev_name,\n\t\t\t const void *addr,\n\t\t\t const void *mask,\n\t\t\t u32 addr_len,\n\t\t\t struct netlbl_audit *audit_info)\n{\n\tint ret_val;\n\tstruct net_device *dev;\n\tstruct netlbl_unlhsh_iface *iface;\n\n\tif (addr_len != sizeof(struct in_addr) &&\n\t    addr_len != sizeof(struct in6_addr))\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tif (dev_name != NULL) {\n\t\tdev = dev_get_by_name_rcu(net, dev_name);\n\t\tif (dev == NULL) {\n\t\t\tret_val = -ENODEV;\n\t\t\tgoto unlhsh_remove_return;\n\t\t}\n\t\tiface = netlbl_unlhsh_search_iface(dev->ifindex);\n\t} else\n\t\tiface = rcu_dereference(netlbl_unlhsh_def);\n\tif (iface == NULL) {\n\t\tret_val = -ENOENT;\n\t\tgoto unlhsh_remove_return;\n\t}\n\tswitch (addr_len) {\n\tcase sizeof(struct in_addr):\n\t\tret_val = netlbl_unlhsh_remove_addr4(net,\n\t\t\t\t\t\t     iface, addr, mask,\n\t\t\t\t\t\t     audit_info);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase sizeof(struct in6_addr):\n\t\tret_val = netlbl_unlhsh_remove_addr6(net,\n\t\t\t\t\t\t     iface, addr, mask,\n\t\t\t\t\t\t     audit_info);\n\t\tbreak;\n#endif  \n\tdefault:\n\t\tret_val = -EINVAL;\n\t}\n\tif (ret_val == 0) {\n\t\tnetlbl_unlhsh_condremove_iface(iface);\n\t\tatomic_dec(&netlabel_mgmt_protocount);\n\t}\n\nunlhsh_remove_return:\n\trcu_read_unlock();\n\treturn ret_val;\n}\n\n \n\n \nstatic int netlbl_unlhsh_netdev_handler(struct notifier_block *this,\n\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netlbl_unlhsh_iface *iface = NULL;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif (event == NETDEV_DOWN) {\n\t\tspin_lock(&netlbl_unlhsh_lock);\n\t\tiface = netlbl_unlhsh_search_iface(dev->ifindex);\n\t\tif (iface != NULL && iface->valid) {\n\t\t\tiface->valid = 0;\n\t\t\tlist_del_rcu(&iface->list);\n\t\t} else\n\t\t\tiface = NULL;\n\t\tspin_unlock(&netlbl_unlhsh_lock);\n\t}\n\n\tif (iface != NULL)\n\t\tcall_rcu(&iface->rcu, netlbl_unlhsh_free_iface);\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic void netlbl_unlabel_acceptflg_set(u8 value,\n\t\t\t\t\t struct netlbl_audit *audit_info)\n{\n\tstruct audit_buffer *audit_buf;\n\tu8 old_val;\n\n\told_val = netlabel_unlabel_acceptflg;\n\tnetlabel_unlabel_acceptflg = value;\n\taudit_buf = netlbl_audit_start_common(AUDIT_MAC_UNLBL_ALLOW,\n\t\t\t\t\t      audit_info);\n\tif (audit_buf != NULL) {\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \" unlbl_accept=%u old=%u\", value, old_val);\n\t\taudit_log_end(audit_buf);\n\t}\n}\n\n \nstatic int netlbl_unlabel_addrinfo_get(struct genl_info *info,\n\t\t\t\t       void **addr,\n\t\t\t\t       void **mask,\n\t\t\t\t       u32 *len)\n{\n\tu32 addr_len;\n\n\tif (info->attrs[NLBL_UNLABEL_A_IPV4ADDR] &&\n\t    info->attrs[NLBL_UNLABEL_A_IPV4MASK]) {\n\t\taddr_len = nla_len(info->attrs[NLBL_UNLABEL_A_IPV4ADDR]);\n\t\tif (addr_len != sizeof(struct in_addr) &&\n\t\t    addr_len != nla_len(info->attrs[NLBL_UNLABEL_A_IPV4MASK]))\n\t\t\treturn -EINVAL;\n\t\t*len = addr_len;\n\t\t*addr = nla_data(info->attrs[NLBL_UNLABEL_A_IPV4ADDR]);\n\t\t*mask = nla_data(info->attrs[NLBL_UNLABEL_A_IPV4MASK]);\n\t\treturn 0;\n\t} else if (info->attrs[NLBL_UNLABEL_A_IPV6ADDR]) {\n\t\taddr_len = nla_len(info->attrs[NLBL_UNLABEL_A_IPV6ADDR]);\n\t\tif (addr_len != sizeof(struct in6_addr) &&\n\t\t    addr_len != nla_len(info->attrs[NLBL_UNLABEL_A_IPV6MASK]))\n\t\t\treturn -EINVAL;\n\t\t*len = addr_len;\n\t\t*addr = nla_data(info->attrs[NLBL_UNLABEL_A_IPV6ADDR]);\n\t\t*mask = nla_data(info->attrs[NLBL_UNLABEL_A_IPV6MASK]);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \n\n \nstatic int netlbl_unlabel_accept(struct sk_buff *skb, struct genl_info *info)\n{\n\tu8 value;\n\tstruct netlbl_audit audit_info;\n\n\tif (info->attrs[NLBL_UNLABEL_A_ACPTFLG]) {\n\t\tvalue = nla_get_u8(info->attrs[NLBL_UNLABEL_A_ACPTFLG]);\n\t\tif (value == 1 || value == 0) {\n\t\t\tnetlbl_netlink_auditinfo(&audit_info);\n\t\t\tnetlbl_unlabel_acceptflg_set(value, &audit_info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int netlbl_unlabel_list(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret_val = -EINVAL;\n\tstruct sk_buff *ans_skb;\n\tvoid *data;\n\n\tans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (ans_skb == NULL)\n\t\tgoto list_failure;\n\tdata = genlmsg_put_reply(ans_skb, info, &netlbl_unlabel_gnl_family,\n\t\t\t\t 0, NLBL_UNLABEL_C_LIST);\n\tif (data == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure;\n\t}\n\n\tret_val = nla_put_u8(ans_skb,\n\t\t\t     NLBL_UNLABEL_A_ACPTFLG,\n\t\t\t     netlabel_unlabel_acceptflg);\n\tif (ret_val != 0)\n\t\tgoto list_failure;\n\n\tgenlmsg_end(ans_skb, data);\n\treturn genlmsg_reply(ans_skb, info);\n\nlist_failure:\n\tkfree_skb(ans_skb);\n\treturn ret_val;\n}\n\n \nstatic int netlbl_unlabel_staticadd(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tint ret_val;\n\tchar *dev_name;\n\tvoid *addr;\n\tvoid *mask;\n\tu32 addr_len;\n\tu32 secid;\n\tstruct netlbl_audit audit_info;\n\n\t \n\tif (!info->attrs[NLBL_UNLABEL_A_SECCTX] ||\n\t    !info->attrs[NLBL_UNLABEL_A_IFACE] ||\n\t    !((!info->attrs[NLBL_UNLABEL_A_IPV4ADDR] ||\n\t       !info->attrs[NLBL_UNLABEL_A_IPV4MASK]) ^\n\t      (!info->attrs[NLBL_UNLABEL_A_IPV6ADDR] ||\n\t       !info->attrs[NLBL_UNLABEL_A_IPV6MASK])))\n\t\treturn -EINVAL;\n\n\tnetlbl_netlink_auditinfo(&audit_info);\n\n\tret_val = netlbl_unlabel_addrinfo_get(info, &addr, &mask, &addr_len);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tdev_name = nla_data(info->attrs[NLBL_UNLABEL_A_IFACE]);\n\tret_val = security_secctx_to_secid(\n\t\t                  nla_data(info->attrs[NLBL_UNLABEL_A_SECCTX]),\n\t\t\t\t  nla_len(info->attrs[NLBL_UNLABEL_A_SECCTX]),\n\t\t\t\t  &secid);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\treturn netlbl_unlhsh_add(&init_net,\n\t\t\t\t dev_name, addr, mask, addr_len, secid,\n\t\t\t\t &audit_info);\n}\n\n \nstatic int netlbl_unlabel_staticadddef(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tint ret_val;\n\tvoid *addr;\n\tvoid *mask;\n\tu32 addr_len;\n\tu32 secid;\n\tstruct netlbl_audit audit_info;\n\n\t \n\tif (!info->attrs[NLBL_UNLABEL_A_SECCTX] ||\n\t    !((!info->attrs[NLBL_UNLABEL_A_IPV4ADDR] ||\n\t       !info->attrs[NLBL_UNLABEL_A_IPV4MASK]) ^\n\t      (!info->attrs[NLBL_UNLABEL_A_IPV6ADDR] ||\n\t       !info->attrs[NLBL_UNLABEL_A_IPV6MASK])))\n\t\treturn -EINVAL;\n\n\tnetlbl_netlink_auditinfo(&audit_info);\n\n\tret_val = netlbl_unlabel_addrinfo_get(info, &addr, &mask, &addr_len);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tret_val = security_secctx_to_secid(\n\t\t                  nla_data(info->attrs[NLBL_UNLABEL_A_SECCTX]),\n\t\t\t\t  nla_len(info->attrs[NLBL_UNLABEL_A_SECCTX]),\n\t\t\t\t  &secid);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\treturn netlbl_unlhsh_add(&init_net,\n\t\t\t\t NULL, addr, mask, addr_len, secid,\n\t\t\t\t &audit_info);\n}\n\n \nstatic int netlbl_unlabel_staticremove(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tint ret_val;\n\tchar *dev_name;\n\tvoid *addr;\n\tvoid *mask;\n\tu32 addr_len;\n\tstruct netlbl_audit audit_info;\n\n\t \n\tif (!info->attrs[NLBL_UNLABEL_A_IFACE] ||\n\t    !((!info->attrs[NLBL_UNLABEL_A_IPV4ADDR] ||\n\t       !info->attrs[NLBL_UNLABEL_A_IPV4MASK]) ^\n\t      (!info->attrs[NLBL_UNLABEL_A_IPV6ADDR] ||\n\t       !info->attrs[NLBL_UNLABEL_A_IPV6MASK])))\n\t\treturn -EINVAL;\n\n\tnetlbl_netlink_auditinfo(&audit_info);\n\n\tret_val = netlbl_unlabel_addrinfo_get(info, &addr, &mask, &addr_len);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tdev_name = nla_data(info->attrs[NLBL_UNLABEL_A_IFACE]);\n\n\treturn netlbl_unlhsh_remove(&init_net,\n\t\t\t\t    dev_name, addr, mask, addr_len,\n\t\t\t\t    &audit_info);\n}\n\n \nstatic int netlbl_unlabel_staticremovedef(struct sk_buff *skb,\n\t\t\t\t\t  struct genl_info *info)\n{\n\tint ret_val;\n\tvoid *addr;\n\tvoid *mask;\n\tu32 addr_len;\n\tstruct netlbl_audit audit_info;\n\n\t \n\tif (!((!info->attrs[NLBL_UNLABEL_A_IPV4ADDR] ||\n\t       !info->attrs[NLBL_UNLABEL_A_IPV4MASK]) ^\n\t      (!info->attrs[NLBL_UNLABEL_A_IPV6ADDR] ||\n\t       !info->attrs[NLBL_UNLABEL_A_IPV6MASK])))\n\t\treturn -EINVAL;\n\n\tnetlbl_netlink_auditinfo(&audit_info);\n\n\tret_val = netlbl_unlabel_addrinfo_get(info, &addr, &mask, &addr_len);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\treturn netlbl_unlhsh_remove(&init_net,\n\t\t\t\t    NULL, addr, mask, addr_len,\n\t\t\t\t    &audit_info);\n}\n\n\n \nstatic int netlbl_unlabel_staticlist_gen(u32 cmd,\n\t\t\t\t       const struct netlbl_unlhsh_iface *iface,\n\t\t\t\t       const struct netlbl_unlhsh_addr4 *addr4,\n\t\t\t\t       const struct netlbl_unlhsh_addr6 *addr6,\n\t\t\t\t       void *arg)\n{\n\tint ret_val = -ENOMEM;\n\tstruct netlbl_unlhsh_walk_arg *cb_arg = arg;\n\tstruct net_device *dev;\n\tvoid *data;\n\tu32 secid;\n\tchar *secctx;\n\tu32 secctx_len;\n\n\tdata = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).portid,\n\t\t\t   cb_arg->seq, &netlbl_unlabel_gnl_family,\n\t\t\t   NLM_F_MULTI, cmd);\n\tif (data == NULL)\n\t\tgoto list_cb_failure;\n\n\tif (iface->ifindex > 0) {\n\t\tdev = dev_get_by_index(&init_net, iface->ifindex);\n\t\tif (!dev) {\n\t\t\tret_val = -ENODEV;\n\t\t\tgoto list_cb_failure;\n\t\t}\n\t\tret_val = nla_put_string(cb_arg->skb,\n\t\t\t\t\t NLBL_UNLABEL_A_IFACE, dev->name);\n\t\tdev_put(dev);\n\t\tif (ret_val != 0)\n\t\t\tgoto list_cb_failure;\n\t}\n\n\tif (addr4) {\n\t\tstruct in_addr addr_struct;\n\n\t\taddr_struct.s_addr = addr4->list.addr;\n\t\tret_val = nla_put_in_addr(cb_arg->skb,\n\t\t\t\t\t  NLBL_UNLABEL_A_IPV4ADDR,\n\t\t\t\t\t  addr_struct.s_addr);\n\t\tif (ret_val != 0)\n\t\t\tgoto list_cb_failure;\n\n\t\taddr_struct.s_addr = addr4->list.mask;\n\t\tret_val = nla_put_in_addr(cb_arg->skb,\n\t\t\t\t\t  NLBL_UNLABEL_A_IPV4MASK,\n\t\t\t\t\t  addr_struct.s_addr);\n\t\tif (ret_val != 0)\n\t\t\tgoto list_cb_failure;\n\n\t\tsecid = addr4->secid;\n\t} else {\n\t\tret_val = nla_put_in6_addr(cb_arg->skb,\n\t\t\t\t\t   NLBL_UNLABEL_A_IPV6ADDR,\n\t\t\t\t\t   &addr6->list.addr);\n\t\tif (ret_val != 0)\n\t\t\tgoto list_cb_failure;\n\n\t\tret_val = nla_put_in6_addr(cb_arg->skb,\n\t\t\t\t\t   NLBL_UNLABEL_A_IPV6MASK,\n\t\t\t\t\t   &addr6->list.mask);\n\t\tif (ret_val != 0)\n\t\t\tgoto list_cb_failure;\n\n\t\tsecid = addr6->secid;\n\t}\n\n\tret_val = security_secid_to_secctx(secid, &secctx, &secctx_len);\n\tif (ret_val != 0)\n\t\tgoto list_cb_failure;\n\tret_val = nla_put(cb_arg->skb,\n\t\t\t  NLBL_UNLABEL_A_SECCTX,\n\t\t\t  secctx_len,\n\t\t\t  secctx);\n\tsecurity_release_secctx(secctx, secctx_len);\n\tif (ret_val != 0)\n\t\tgoto list_cb_failure;\n\n\tcb_arg->seq++;\n\tgenlmsg_end(cb_arg->skb, data);\n\treturn 0;\n\nlist_cb_failure:\n\tgenlmsg_cancel(cb_arg->skb, data);\n\treturn ret_val;\n}\n\n \nstatic int netlbl_unlabel_staticlist(struct sk_buff *skb,\n\t\t\t\t     struct netlink_callback *cb)\n{\n\tstruct netlbl_unlhsh_walk_arg cb_arg;\n\tu32 skip_bkt = cb->args[0];\n\tu32 skip_chain = cb->args[1];\n\tu32 skip_addr4 = cb->args[2];\n\tu32 iter_bkt, iter_chain = 0, iter_addr4 = 0, iter_addr6 = 0;\n\tstruct netlbl_unlhsh_iface *iface;\n\tstruct list_head *iter_list;\n\tstruct netlbl_af4list *addr4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tu32 skip_addr6 = cb->args[3];\n\tstruct netlbl_af6list *addr6;\n#endif\n\n\tcb_arg.nl_cb = cb;\n\tcb_arg.skb = skb;\n\tcb_arg.seq = cb->nlh->nlmsg_seq;\n\n\trcu_read_lock();\n\tfor (iter_bkt = skip_bkt;\n\t     iter_bkt < rcu_dereference(netlbl_unlhsh)->size;\n\t     iter_bkt++) {\n\t\titer_list = &rcu_dereference(netlbl_unlhsh)->tbl[iter_bkt];\n\t\tlist_for_each_entry_rcu(iface, iter_list, list) {\n\t\t\tif (!iface->valid ||\n\t\t\t    iter_chain++ < skip_chain)\n\t\t\t\tcontinue;\n\t\t\tnetlbl_af4list_foreach_rcu(addr4,\n\t\t\t\t\t\t   &iface->addr4_list) {\n\t\t\t\tif (iter_addr4++ < skip_addr4)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (netlbl_unlabel_staticlist_gen(\n\t\t\t\t\t      NLBL_UNLABEL_C_STATICLIST,\n\t\t\t\t\t      iface,\n\t\t\t\t\t      netlbl_unlhsh_addr4_entry(addr4),\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      &cb_arg) < 0) {\n\t\t\t\t\titer_addr4--;\n\t\t\t\t\titer_chain--;\n\t\t\t\t\tgoto unlabel_staticlist_return;\n\t\t\t\t}\n\t\t\t}\n\t\t\titer_addr4 = 0;\n\t\t\tskip_addr4 = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tnetlbl_af6list_foreach_rcu(addr6,\n\t\t\t\t\t\t   &iface->addr6_list) {\n\t\t\t\tif (iter_addr6++ < skip_addr6)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (netlbl_unlabel_staticlist_gen(\n\t\t\t\t\t      NLBL_UNLABEL_C_STATICLIST,\n\t\t\t\t\t      iface,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      netlbl_unlhsh_addr6_entry(addr6),\n\t\t\t\t\t      &cb_arg) < 0) {\n\t\t\t\t\titer_addr6--;\n\t\t\t\t\titer_chain--;\n\t\t\t\t\tgoto unlabel_staticlist_return;\n\t\t\t\t}\n\t\t\t}\n\t\t\titer_addr6 = 0;\n\t\t\tskip_addr6 = 0;\n#endif  \n\t\t}\n\t\titer_chain = 0;\n\t\tskip_chain = 0;\n\t}\n\nunlabel_staticlist_return:\n\trcu_read_unlock();\n\tcb->args[0] = iter_bkt;\n\tcb->args[1] = iter_chain;\n\tcb->args[2] = iter_addr4;\n\tcb->args[3] = iter_addr6;\n\treturn skb->len;\n}\n\n \nstatic int netlbl_unlabel_staticlistdef(struct sk_buff *skb,\n\t\t\t\t\tstruct netlink_callback *cb)\n{\n\tstruct netlbl_unlhsh_walk_arg cb_arg;\n\tstruct netlbl_unlhsh_iface *iface;\n\tu32 iter_addr4 = 0, iter_addr6 = 0;\n\tstruct netlbl_af4list *addr4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct netlbl_af6list *addr6;\n#endif\n\n\tcb_arg.nl_cb = cb;\n\tcb_arg.skb = skb;\n\tcb_arg.seq = cb->nlh->nlmsg_seq;\n\n\trcu_read_lock();\n\tiface = rcu_dereference(netlbl_unlhsh_def);\n\tif (iface == NULL || !iface->valid)\n\t\tgoto unlabel_staticlistdef_return;\n\n\tnetlbl_af4list_foreach_rcu(addr4, &iface->addr4_list) {\n\t\tif (iter_addr4++ < cb->args[0])\n\t\t\tcontinue;\n\t\tif (netlbl_unlabel_staticlist_gen(NLBL_UNLABEL_C_STATICLISTDEF,\n\t\t\t\t\t      iface,\n\t\t\t\t\t      netlbl_unlhsh_addr4_entry(addr4),\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      &cb_arg) < 0) {\n\t\t\titer_addr4--;\n\t\t\tgoto unlabel_staticlistdef_return;\n\t\t}\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tnetlbl_af6list_foreach_rcu(addr6, &iface->addr6_list) {\n\t\tif (iter_addr6++ < cb->args[1])\n\t\t\tcontinue;\n\t\tif (netlbl_unlabel_staticlist_gen(NLBL_UNLABEL_C_STATICLISTDEF,\n\t\t\t\t\t      iface,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      netlbl_unlhsh_addr6_entry(addr6),\n\t\t\t\t\t      &cb_arg) < 0) {\n\t\t\titer_addr6--;\n\t\t\tgoto unlabel_staticlistdef_return;\n\t\t}\n\t}\n#endif  \n\nunlabel_staticlistdef_return:\n\trcu_read_unlock();\n\tcb->args[0] = iter_addr4;\n\tcb->args[1] = iter_addr6;\n\treturn skb->len;\n}\n\n \n\nstatic const struct genl_small_ops netlbl_unlabel_genl_ops[] = {\n\t{\n\t.cmd = NLBL_UNLABEL_C_STATICADD,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = GENL_ADMIN_PERM,\n\t.doit = netlbl_unlabel_staticadd,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_UNLABEL_C_STATICREMOVE,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = GENL_ADMIN_PERM,\n\t.doit = netlbl_unlabel_staticremove,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_UNLABEL_C_STATICLIST,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = 0,\n\t.doit = NULL,\n\t.dumpit = netlbl_unlabel_staticlist,\n\t},\n\t{\n\t.cmd = NLBL_UNLABEL_C_STATICADDDEF,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = GENL_ADMIN_PERM,\n\t.doit = netlbl_unlabel_staticadddef,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_UNLABEL_C_STATICREMOVEDEF,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = GENL_ADMIN_PERM,\n\t.doit = netlbl_unlabel_staticremovedef,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_UNLABEL_C_STATICLISTDEF,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = 0,\n\t.doit = NULL,\n\t.dumpit = netlbl_unlabel_staticlistdef,\n\t},\n\t{\n\t.cmd = NLBL_UNLABEL_C_ACCEPT,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = GENL_ADMIN_PERM,\n\t.doit = netlbl_unlabel_accept,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_UNLABEL_C_LIST,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = 0,\n\t.doit = netlbl_unlabel_list,\n\t.dumpit = NULL,\n\t},\n};\n\nstatic struct genl_family netlbl_unlabel_gnl_family __ro_after_init = {\n\t.hdrsize = 0,\n\t.name = NETLBL_NLTYPE_UNLABELED_NAME,\n\t.version = NETLBL_PROTO_VERSION,\n\t.maxattr = NLBL_UNLABEL_A_MAX,\n\t.policy = netlbl_unlabel_genl_policy,\n\t.module = THIS_MODULE,\n\t.small_ops = netlbl_unlabel_genl_ops,\n\t.n_small_ops = ARRAY_SIZE(netlbl_unlabel_genl_ops),\n\t.resv_start_op = NLBL_UNLABEL_C_STATICLISTDEF + 1,\n};\n\n \n\n \nint __init netlbl_unlabel_genl_init(void)\n{\n\treturn genl_register_family(&netlbl_unlabel_gnl_family);\n}\n\n \n\nstatic struct notifier_block netlbl_unlhsh_netdev_notifier = {\n\t.notifier_call = netlbl_unlhsh_netdev_handler,\n};\n\n \nint __init netlbl_unlabel_init(u32 size)\n{\n\tu32 iter;\n\tstruct netlbl_unlhsh_tbl *hsh_tbl;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\thsh_tbl = kmalloc(sizeof(*hsh_tbl), GFP_KERNEL);\n\tif (hsh_tbl == NULL)\n\t\treturn -ENOMEM;\n\thsh_tbl->size = 1 << size;\n\thsh_tbl->tbl = kcalloc(hsh_tbl->size,\n\t\t\t       sizeof(struct list_head),\n\t\t\t       GFP_KERNEL);\n\tif (hsh_tbl->tbl == NULL) {\n\t\tkfree(hsh_tbl);\n\t\treturn -ENOMEM;\n\t}\n\tfor (iter = 0; iter < hsh_tbl->size; iter++)\n\t\tINIT_LIST_HEAD(&hsh_tbl->tbl[iter]);\n\n\tspin_lock(&netlbl_unlhsh_lock);\n\trcu_assign_pointer(netlbl_unlhsh, hsh_tbl);\n\tspin_unlock(&netlbl_unlhsh_lock);\n\n\tregister_netdevice_notifier(&netlbl_unlhsh_netdev_notifier);\n\n\treturn 0;\n}\n\n \nint netlbl_unlabel_getattr(const struct sk_buff *skb,\n\t\t\t   u16 family,\n\t\t\t   struct netlbl_lsm_secattr *secattr)\n{\n\tstruct netlbl_unlhsh_iface *iface;\n\n\trcu_read_lock();\n\tiface = netlbl_unlhsh_search_iface(skb->skb_iif);\n\tif (iface == NULL)\n\t\tiface = rcu_dereference(netlbl_unlhsh_def);\n\tif (iface == NULL || !iface->valid)\n\t\tgoto unlabel_getattr_nolabel;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t \n\tif (family == PF_INET6 && ip_hdr(skb)->version == 4)\n\t\tfamily = PF_INET;\n#endif  \n\n\tswitch (family) {\n\tcase PF_INET: {\n\t\tstruct iphdr *hdr4;\n\t\tstruct netlbl_af4list *addr4;\n\n\t\thdr4 = ip_hdr(skb);\n\t\taddr4 = netlbl_af4list_search(hdr4->saddr,\n\t\t\t\t\t      &iface->addr4_list);\n\t\tif (addr4 == NULL)\n\t\t\tgoto unlabel_getattr_nolabel;\n\t\tsecattr->attr.secid = netlbl_unlhsh_addr4_entry(addr4)->secid;\n\t\tbreak;\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase PF_INET6: {\n\t\tstruct ipv6hdr *hdr6;\n\t\tstruct netlbl_af6list *addr6;\n\n\t\thdr6 = ipv6_hdr(skb);\n\t\taddr6 = netlbl_af6list_search(&hdr6->saddr,\n\t\t\t\t\t      &iface->addr6_list);\n\t\tif (addr6 == NULL)\n\t\t\tgoto unlabel_getattr_nolabel;\n\t\tsecattr->attr.secid = netlbl_unlhsh_addr6_entry(addr6)->secid;\n\t\tbreak;\n\t}\n#endif  \n\tdefault:\n\t\tgoto unlabel_getattr_nolabel;\n\t}\n\trcu_read_unlock();\n\n\tsecattr->flags |= NETLBL_SECATTR_SECID;\n\tsecattr->type = NETLBL_NLTYPE_UNLABELED;\n\treturn 0;\n\nunlabel_getattr_nolabel:\n\trcu_read_unlock();\n\tif (netlabel_unlabel_acceptflg == 0)\n\t\treturn -ENOMSG;\n\tsecattr->type = NETLBL_NLTYPE_UNLABELED;\n\treturn 0;\n}\n\n \nint __init netlbl_unlabel_defconf(void)\n{\n\tint ret_val;\n\tstruct netlbl_dom_map *entry;\n\tstruct netlbl_audit audit_info;\n\n\t \n\tsecurity_current_getsecid_subj(&audit_info.secid);\n\taudit_info.loginuid = GLOBAL_ROOT_UID;\n\taudit_info.sessionid = 0;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\tentry->family = AF_UNSPEC;\n\tentry->def.type = NETLBL_NLTYPE_UNLABELED;\n\tret_val = netlbl_domhsh_add_default(entry, &audit_info);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\tnetlbl_unlabel_acceptflg_set(1, &audit_info);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}