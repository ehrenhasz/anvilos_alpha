{
  "module_name": "netlabel_domainhash.c",
  "hash_id": "0a062ad89ed469d07608765c01a21b5b22cd0654e66cd67ef7894698cf87e04a",
  "original_prompt": "Ingested from linux-6.6.14/net/netlabel/netlabel_domainhash.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/rculist.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <net/netlabel.h>\n#include <net/cipso_ipv4.h>\n#include <net/calipso.h>\n#include <asm/bug.h>\n\n#include \"netlabel_mgmt.h\"\n#include \"netlabel_addrlist.h\"\n#include \"netlabel_calipso.h\"\n#include \"netlabel_domainhash.h\"\n#include \"netlabel_user.h\"\n\nstruct netlbl_domhsh_tbl {\n\tstruct list_head *tbl;\n\tu32 size;\n};\n\n \n \nstatic DEFINE_SPINLOCK(netlbl_domhsh_lock);\n#define netlbl_domhsh_rcu_deref(p) \\\n\trcu_dereference_check(p, lockdep_is_held(&netlbl_domhsh_lock))\nstatic struct netlbl_domhsh_tbl __rcu *netlbl_domhsh;\nstatic struct netlbl_dom_map __rcu *netlbl_domhsh_def_ipv4;\nstatic struct netlbl_dom_map __rcu *netlbl_domhsh_def_ipv6;\n\n \n\n \nstatic void netlbl_domhsh_free_entry(struct rcu_head *entry)\n{\n\tstruct netlbl_dom_map *ptr;\n\tstruct netlbl_af4list *iter4;\n\tstruct netlbl_af4list *tmp4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct netlbl_af6list *iter6;\n\tstruct netlbl_af6list *tmp6;\n#endif  \n\n\tptr = container_of(entry, struct netlbl_dom_map, rcu);\n\tif (ptr->def.type == NETLBL_NLTYPE_ADDRSELECT) {\n\t\tnetlbl_af4list_foreach_safe(iter4, tmp4,\n\t\t\t\t\t    &ptr->def.addrsel->list4) {\n\t\t\tnetlbl_af4list_remove_entry(iter4);\n\t\t\tkfree(netlbl_domhsh_addr4_entry(iter4));\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tnetlbl_af6list_foreach_safe(iter6, tmp6,\n\t\t\t\t\t    &ptr->def.addrsel->list6) {\n\t\t\tnetlbl_af6list_remove_entry(iter6);\n\t\t\tkfree(netlbl_domhsh_addr6_entry(iter6));\n\t\t}\n#endif  \n\t\tkfree(ptr->def.addrsel);\n\t}\n\tkfree(ptr->domain);\n\tkfree(ptr);\n}\n\n \nstatic u32 netlbl_domhsh_hash(const char *key)\n{\n\tu32 iter;\n\tu32 val;\n\tu32 len;\n\n\t \n\n\tfor (iter = 0, val = 0, len = strlen(key); iter < len; iter++)\n\t\tval = (val << 4 | (val >> (8 * sizeof(u32) - 4))) ^ key[iter];\n\treturn val & (netlbl_domhsh_rcu_deref(netlbl_domhsh)->size - 1);\n}\n\nstatic bool netlbl_family_match(u16 f1, u16 f2)\n{\n\treturn (f1 == f2) || (f1 == AF_UNSPEC) || (f2 == AF_UNSPEC);\n}\n\n \nstatic struct netlbl_dom_map *netlbl_domhsh_search(const char *domain,\n\t\t\t\t\t\t   u16 family)\n{\n\tu32 bkt;\n\tstruct list_head *bkt_list;\n\tstruct netlbl_dom_map *iter;\n\n\tif (domain != NULL) {\n\t\tbkt = netlbl_domhsh_hash(domain);\n\t\tbkt_list = &netlbl_domhsh_rcu_deref(netlbl_domhsh)->tbl[bkt];\n\t\tlist_for_each_entry_rcu(iter, bkt_list, list,\n\t\t\t\t\tlockdep_is_held(&netlbl_domhsh_lock))\n\t\t\tif (iter->valid &&\n\t\t\t    netlbl_family_match(iter->family, family) &&\n\t\t\t    strcmp(iter->domain, domain) == 0)\n\t\t\t\treturn iter;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct netlbl_dom_map *netlbl_domhsh_search_def(const char *domain,\n\t\t\t\t\t\t       u16 family)\n{\n\tstruct netlbl_dom_map *entry;\n\n\tentry = netlbl_domhsh_search(domain, family);\n\tif (entry != NULL)\n\t\treturn entry;\n\tif (family == AF_INET || family == AF_UNSPEC) {\n\t\tentry = netlbl_domhsh_rcu_deref(netlbl_domhsh_def_ipv4);\n\t\tif (entry != NULL && entry->valid)\n\t\t\treturn entry;\n\t}\n\tif (family == AF_INET6 || family == AF_UNSPEC) {\n\t\tentry = netlbl_domhsh_rcu_deref(netlbl_domhsh_def_ipv6);\n\t\tif (entry != NULL && entry->valid)\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void netlbl_domhsh_audit_add(struct netlbl_dom_map *entry,\n\t\t\t\t    struct netlbl_af4list *addr4,\n\t\t\t\t    struct netlbl_af6list *addr6,\n\t\t\t\t    int result,\n\t\t\t\t    struct netlbl_audit *audit_info)\n{\n\tstruct audit_buffer *audit_buf;\n\tstruct cipso_v4_doi *cipsov4 = NULL;\n\tstruct calipso_doi *calipso = NULL;\n\tu32 type;\n\n\taudit_buf = netlbl_audit_start_common(AUDIT_MAC_MAP_ADD, audit_info);\n\tif (audit_buf != NULL) {\n\t\taudit_log_format(audit_buf, \" nlbl_domain=%s\",\n\t\t\t\t entry->domain ? entry->domain : \"(default)\");\n\t\tif (addr4 != NULL) {\n\t\t\tstruct netlbl_domaddr4_map *map4;\n\t\t\tmap4 = netlbl_domhsh_addr4_entry(addr4);\n\t\t\ttype = map4->def.type;\n\t\t\tcipsov4 = map4->def.cipso;\n\t\t\tnetlbl_af4list_audit_addr(audit_buf, 0, NULL,\n\t\t\t\t\t\t  addr4->addr, addr4->mask);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else if (addr6 != NULL) {\n\t\t\tstruct netlbl_domaddr6_map *map6;\n\t\t\tmap6 = netlbl_domhsh_addr6_entry(addr6);\n\t\t\ttype = map6->def.type;\n\t\t\tcalipso = map6->def.calipso;\n\t\t\tnetlbl_af6list_audit_addr(audit_buf, 0, NULL,\n\t\t\t\t\t\t  &addr6->addr, &addr6->mask);\n#endif  \n\t\t} else {\n\t\t\ttype = entry->def.type;\n\t\t\tcipsov4 = entry->def.cipso;\n\t\t\tcalipso = entry->def.calipso;\n\t\t}\n\t\tswitch (type) {\n\t\tcase NETLBL_NLTYPE_UNLABELED:\n\t\t\taudit_log_format(audit_buf, \" nlbl_protocol=unlbl\");\n\t\t\tbreak;\n\t\tcase NETLBL_NLTYPE_CIPSOV4:\n\t\t\tBUG_ON(cipsov4 == NULL);\n\t\t\taudit_log_format(audit_buf,\n\t\t\t\t\t \" nlbl_protocol=cipsov4 cipso_doi=%u\",\n\t\t\t\t\t cipsov4->doi);\n\t\t\tbreak;\n\t\tcase NETLBL_NLTYPE_CALIPSO:\n\t\t\tBUG_ON(calipso == NULL);\n\t\t\taudit_log_format(audit_buf,\n\t\t\t\t\t \" nlbl_protocol=calipso calipso_doi=%u\",\n\t\t\t\t\t calipso->doi);\n\t\t\tbreak;\n\t\t}\n\t\taudit_log_format(audit_buf, \" res=%u\", result == 0 ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n}\n\n \nstatic int netlbl_domhsh_validate(const struct netlbl_dom_map *entry)\n{\n\tstruct netlbl_af4list *iter4;\n\tstruct netlbl_domaddr4_map *map4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct netlbl_af6list *iter6;\n\tstruct netlbl_domaddr6_map *map6;\n#endif  \n\n\tif (entry == NULL)\n\t\treturn -EINVAL;\n\n\tif (entry->family != AF_INET && entry->family != AF_INET6 &&\n\t    (entry->family != AF_UNSPEC ||\n\t     entry->def.type != NETLBL_NLTYPE_UNLABELED))\n\t\treturn -EINVAL;\n\n\tswitch (entry->def.type) {\n\tcase NETLBL_NLTYPE_UNLABELED:\n\t\tif (entry->def.cipso != NULL || entry->def.calipso != NULL ||\n\t\t    entry->def.addrsel != NULL)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NETLBL_NLTYPE_CIPSOV4:\n\t\tif (entry->family != AF_INET ||\n\t\t    entry->def.cipso == NULL)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NETLBL_NLTYPE_CALIPSO:\n\t\tif (entry->family != AF_INET6 ||\n\t\t    entry->def.calipso == NULL)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NETLBL_NLTYPE_ADDRSELECT:\n\t\tnetlbl_af4list_foreach(iter4, &entry->def.addrsel->list4) {\n\t\t\tmap4 = netlbl_domhsh_addr4_entry(iter4);\n\t\t\tswitch (map4->def.type) {\n\t\t\tcase NETLBL_NLTYPE_UNLABELED:\n\t\t\t\tif (map4->def.cipso != NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase NETLBL_NLTYPE_CIPSOV4:\n\t\t\t\tif (map4->def.cipso == NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tnetlbl_af6list_foreach(iter6, &entry->def.addrsel->list6) {\n\t\t\tmap6 = netlbl_domhsh_addr6_entry(iter6);\n\t\t\tswitch (map6->def.type) {\n\t\t\tcase NETLBL_NLTYPE_UNLABELED:\n\t\t\t\tif (map6->def.calipso != NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase NETLBL_NLTYPE_CALIPSO:\n\t\t\t\tif (map6->def.calipso == NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n#endif  \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nint __init netlbl_domhsh_init(u32 size)\n{\n\tu32 iter;\n\tstruct netlbl_domhsh_tbl *hsh_tbl;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\thsh_tbl = kmalloc(sizeof(*hsh_tbl), GFP_KERNEL);\n\tif (hsh_tbl == NULL)\n\t\treturn -ENOMEM;\n\thsh_tbl->size = 1 << size;\n\thsh_tbl->tbl = kcalloc(hsh_tbl->size,\n\t\t\t       sizeof(struct list_head),\n\t\t\t       GFP_KERNEL);\n\tif (hsh_tbl->tbl == NULL) {\n\t\tkfree(hsh_tbl);\n\t\treturn -ENOMEM;\n\t}\n\tfor (iter = 0; iter < hsh_tbl->size; iter++)\n\t\tINIT_LIST_HEAD(&hsh_tbl->tbl[iter]);\n\n\tspin_lock(&netlbl_domhsh_lock);\n\trcu_assign_pointer(netlbl_domhsh, hsh_tbl);\n\tspin_unlock(&netlbl_domhsh_lock);\n\n\treturn 0;\n}\n\n \nint netlbl_domhsh_add(struct netlbl_dom_map *entry,\n\t\t      struct netlbl_audit *audit_info)\n{\n\tint ret_val = 0;\n\tstruct netlbl_dom_map *entry_old, *entry_b;\n\tstruct netlbl_af4list *iter4;\n\tstruct netlbl_af4list *tmp4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct netlbl_af6list *iter6;\n\tstruct netlbl_af6list *tmp6;\n#endif  \n\n\tret_val = netlbl_domhsh_validate(entry);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\t \n\trcu_read_lock();\n\tspin_lock(&netlbl_domhsh_lock);\n\tif (entry->domain != NULL)\n\t\tentry_old = netlbl_domhsh_search(entry->domain, entry->family);\n\telse\n\t\tentry_old = netlbl_domhsh_search_def(entry->domain,\n\t\t\t\t\t\t     entry->family);\n\tif (entry_old == NULL) {\n\t\tentry->valid = 1;\n\n\t\tif (entry->domain != NULL) {\n\t\t\tu32 bkt = netlbl_domhsh_hash(entry->domain);\n\t\t\tlist_add_tail_rcu(&entry->list,\n\t\t\t\t    &rcu_dereference(netlbl_domhsh)->tbl[bkt]);\n\t\t} else {\n\t\t\tINIT_LIST_HEAD(&entry->list);\n\t\t\tswitch (entry->family) {\n\t\t\tcase AF_INET:\n\t\t\t\trcu_assign_pointer(netlbl_domhsh_def_ipv4,\n\t\t\t\t\t\t   entry);\n\t\t\t\tbreak;\n\t\t\tcase AF_INET6:\n\t\t\t\trcu_assign_pointer(netlbl_domhsh_def_ipv6,\n\t\t\t\t\t\t   entry);\n\t\t\t\tbreak;\n\t\t\tcase AF_UNSPEC:\n\t\t\t\tif (entry->def.type !=\n\t\t\t\t    NETLBL_NLTYPE_UNLABELED) {\n\t\t\t\t\tret_val = -EINVAL;\n\t\t\t\t\tgoto add_return;\n\t\t\t\t}\n\t\t\t\tentry_b = kzalloc(sizeof(*entry_b), GFP_ATOMIC);\n\t\t\t\tif (entry_b == NULL) {\n\t\t\t\t\tret_val = -ENOMEM;\n\t\t\t\t\tgoto add_return;\n\t\t\t\t}\n\t\t\t\tentry_b->family = AF_INET6;\n\t\t\t\tentry_b->def.type = NETLBL_NLTYPE_UNLABELED;\n\t\t\t\tentry_b->valid = 1;\n\t\t\t\tentry->family = AF_INET;\n\t\t\t\trcu_assign_pointer(netlbl_domhsh_def_ipv4,\n\t\t\t\t\t\t   entry);\n\t\t\t\trcu_assign_pointer(netlbl_domhsh_def_ipv6,\n\t\t\t\t\t\t   entry_b);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tret_val = -EINVAL;\n\t\t\t\tgoto add_return;\n\t\t\t}\n\t\t}\n\n\t\tif (entry->def.type == NETLBL_NLTYPE_ADDRSELECT) {\n\t\t\tnetlbl_af4list_foreach_rcu(iter4,\n\t\t\t\t\t\t   &entry->def.addrsel->list4)\n\t\t\t\tnetlbl_domhsh_audit_add(entry, iter4, NULL,\n\t\t\t\t\t\t\tret_val, audit_info);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tnetlbl_af6list_foreach_rcu(iter6,\n\t\t\t\t\t\t   &entry->def.addrsel->list6)\n\t\t\t\tnetlbl_domhsh_audit_add(entry, NULL, iter6,\n\t\t\t\t\t\t\tret_val, audit_info);\n#endif  \n\t\t} else\n\t\t\tnetlbl_domhsh_audit_add(entry, NULL, NULL,\n\t\t\t\t\t\tret_val, audit_info);\n\t} else if (entry_old->def.type == NETLBL_NLTYPE_ADDRSELECT &&\n\t\t   entry->def.type == NETLBL_NLTYPE_ADDRSELECT) {\n\t\tstruct list_head *old_list4;\n\t\tstruct list_head *old_list6;\n\n\t\told_list4 = &entry_old->def.addrsel->list4;\n\t\told_list6 = &entry_old->def.addrsel->list6;\n\n\t\t \n\t\tnetlbl_af4list_foreach_rcu(iter4, &entry->def.addrsel->list4)\n\t\t\tif (netlbl_af4list_search_exact(iter4->addr,\n\t\t\t\t\t\t\titer4->mask,\n\t\t\t\t\t\t\told_list4)) {\n\t\t\t\tret_val = -EEXIST;\n\t\t\t\tgoto add_return;\n\t\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tnetlbl_af6list_foreach_rcu(iter6, &entry->def.addrsel->list6)\n\t\t\tif (netlbl_af6list_search_exact(&iter6->addr,\n\t\t\t\t\t\t\t&iter6->mask,\n\t\t\t\t\t\t\told_list6)) {\n\t\t\t\tret_val = -EEXIST;\n\t\t\t\tgoto add_return;\n\t\t\t}\n#endif  \n\n\t\tnetlbl_af4list_foreach_safe(iter4, tmp4,\n\t\t\t\t\t    &entry->def.addrsel->list4) {\n\t\t\tnetlbl_af4list_remove_entry(iter4);\n\t\t\titer4->valid = 1;\n\t\t\tret_val = netlbl_af4list_add(iter4, old_list4);\n\t\t\tnetlbl_domhsh_audit_add(entry_old, iter4, NULL,\n\t\t\t\t\t\tret_val, audit_info);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto add_return;\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tnetlbl_af6list_foreach_safe(iter6, tmp6,\n\t\t\t\t\t    &entry->def.addrsel->list6) {\n\t\t\tnetlbl_af6list_remove_entry(iter6);\n\t\t\titer6->valid = 1;\n\t\t\tret_val = netlbl_af6list_add(iter6, old_list6);\n\t\t\tnetlbl_domhsh_audit_add(entry_old, NULL, iter6,\n\t\t\t\t\t\tret_val, audit_info);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto add_return;\n\t\t}\n#endif  \n\t\t \n\t\tnetlbl_domhsh_free_entry(&entry->rcu);\n\t} else\n\t\tret_val = -EINVAL;\n\nadd_return:\n\tspin_unlock(&netlbl_domhsh_lock);\n\trcu_read_unlock();\n\treturn ret_val;\n}\n\n \nint netlbl_domhsh_add_default(struct netlbl_dom_map *entry,\n\t\t\t      struct netlbl_audit *audit_info)\n{\n\treturn netlbl_domhsh_add(entry, audit_info);\n}\n\n \nint netlbl_domhsh_remove_entry(struct netlbl_dom_map *entry,\n\t\t\t       struct netlbl_audit *audit_info)\n{\n\tint ret_val = 0;\n\tstruct audit_buffer *audit_buf;\n\tstruct netlbl_af4list *iter4;\n\tstruct netlbl_domaddr4_map *map4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct netlbl_af6list *iter6;\n\tstruct netlbl_domaddr6_map *map6;\n#endif  \n\n\tif (entry == NULL)\n\t\treturn -ENOENT;\n\n\tspin_lock(&netlbl_domhsh_lock);\n\tif (entry->valid) {\n\t\tentry->valid = 0;\n\t\tif (entry == rcu_dereference(netlbl_domhsh_def_ipv4))\n\t\t\tRCU_INIT_POINTER(netlbl_domhsh_def_ipv4, NULL);\n\t\telse if (entry == rcu_dereference(netlbl_domhsh_def_ipv6))\n\t\t\tRCU_INIT_POINTER(netlbl_domhsh_def_ipv6, NULL);\n\t\telse\n\t\t\tlist_del_rcu(&entry->list);\n\t} else\n\t\tret_val = -ENOENT;\n\tspin_unlock(&netlbl_domhsh_lock);\n\n\tif (ret_val)\n\t\treturn ret_val;\n\n\taudit_buf = netlbl_audit_start_common(AUDIT_MAC_MAP_DEL, audit_info);\n\tif (audit_buf != NULL) {\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \" nlbl_domain=%s res=1\",\n\t\t\t\t entry->domain ? entry->domain : \"(default)\");\n\t\taudit_log_end(audit_buf);\n\t}\n\n\tswitch (entry->def.type) {\n\tcase NETLBL_NLTYPE_ADDRSELECT:\n\t\tnetlbl_af4list_foreach_rcu(iter4, &entry->def.addrsel->list4) {\n\t\t\tmap4 = netlbl_domhsh_addr4_entry(iter4);\n\t\t\tcipso_v4_doi_putdef(map4->def.cipso);\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tnetlbl_af6list_foreach_rcu(iter6, &entry->def.addrsel->list6) {\n\t\t\tmap6 = netlbl_domhsh_addr6_entry(iter6);\n\t\t\tcalipso_doi_putdef(map6->def.calipso);\n\t\t}\n#endif  \n\t\tbreak;\n\tcase NETLBL_NLTYPE_CIPSOV4:\n\t\tcipso_v4_doi_putdef(entry->def.cipso);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase NETLBL_NLTYPE_CALIPSO:\n\t\tcalipso_doi_putdef(entry->def.calipso);\n\t\tbreak;\n#endif  \n\t}\n\tcall_rcu(&entry->rcu, netlbl_domhsh_free_entry);\n\n\treturn ret_val;\n}\n\n \nint netlbl_domhsh_remove_af4(const char *domain,\n\t\t\t     const struct in_addr *addr,\n\t\t\t     const struct in_addr *mask,\n\t\t\t     struct netlbl_audit *audit_info)\n{\n\tstruct netlbl_dom_map *entry_map;\n\tstruct netlbl_af4list *entry_addr;\n\tstruct netlbl_af4list *iter4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct netlbl_af6list *iter6;\n#endif  \n\tstruct netlbl_domaddr4_map *entry;\n\n\trcu_read_lock();\n\n\tif (domain)\n\t\tentry_map = netlbl_domhsh_search(domain, AF_INET);\n\telse\n\t\tentry_map = netlbl_domhsh_search_def(domain, AF_INET);\n\tif (entry_map == NULL ||\n\t    entry_map->def.type != NETLBL_NLTYPE_ADDRSELECT)\n\t\tgoto remove_af4_failure;\n\n\tspin_lock(&netlbl_domhsh_lock);\n\tentry_addr = netlbl_af4list_remove(addr->s_addr, mask->s_addr,\n\t\t\t\t\t   &entry_map->def.addrsel->list4);\n\tspin_unlock(&netlbl_domhsh_lock);\n\n\tif (entry_addr == NULL)\n\t\tgoto remove_af4_failure;\n\tnetlbl_af4list_foreach_rcu(iter4, &entry_map->def.addrsel->list4)\n\t\tgoto remove_af4_single_addr;\n#if IS_ENABLED(CONFIG_IPV6)\n\tnetlbl_af6list_foreach_rcu(iter6, &entry_map->def.addrsel->list6)\n\t\tgoto remove_af4_single_addr;\n#endif  \n\t \n\tnetlbl_domhsh_remove_entry(entry_map, audit_info);\n\nremove_af4_single_addr:\n\trcu_read_unlock();\n\t \n\tsynchronize_rcu();\n\tentry = netlbl_domhsh_addr4_entry(entry_addr);\n\tcipso_v4_doi_putdef(entry->def.cipso);\n\tkfree(entry);\n\treturn 0;\n\nremove_af4_failure:\n\trcu_read_unlock();\n\treturn -ENOENT;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nint netlbl_domhsh_remove_af6(const char *domain,\n\t\t\t     const struct in6_addr *addr,\n\t\t\t     const struct in6_addr *mask,\n\t\t\t     struct netlbl_audit *audit_info)\n{\n\tstruct netlbl_dom_map *entry_map;\n\tstruct netlbl_af6list *entry_addr;\n\tstruct netlbl_af4list *iter4;\n\tstruct netlbl_af6list *iter6;\n\tstruct netlbl_domaddr6_map *entry;\n\n\trcu_read_lock();\n\n\tif (domain)\n\t\tentry_map = netlbl_domhsh_search(domain, AF_INET6);\n\telse\n\t\tentry_map = netlbl_domhsh_search_def(domain, AF_INET6);\n\tif (entry_map == NULL ||\n\t    entry_map->def.type != NETLBL_NLTYPE_ADDRSELECT)\n\t\tgoto remove_af6_failure;\n\n\tspin_lock(&netlbl_domhsh_lock);\n\tentry_addr = netlbl_af6list_remove(addr, mask,\n\t\t\t\t\t   &entry_map->def.addrsel->list6);\n\tspin_unlock(&netlbl_domhsh_lock);\n\n\tif (entry_addr == NULL)\n\t\tgoto remove_af6_failure;\n\tnetlbl_af4list_foreach_rcu(iter4, &entry_map->def.addrsel->list4)\n\t\tgoto remove_af6_single_addr;\n\tnetlbl_af6list_foreach_rcu(iter6, &entry_map->def.addrsel->list6)\n\t\tgoto remove_af6_single_addr;\n\t \n\tnetlbl_domhsh_remove_entry(entry_map, audit_info);\n\nremove_af6_single_addr:\n\trcu_read_unlock();\n\t \n\tsynchronize_rcu();\n\tentry = netlbl_domhsh_addr6_entry(entry_addr);\n\tcalipso_doi_putdef(entry->def.calipso);\n\tkfree(entry);\n\treturn 0;\n\nremove_af6_failure:\n\trcu_read_unlock();\n\treturn -ENOENT;\n}\n#endif  \n\n \nint netlbl_domhsh_remove(const char *domain, u16 family,\n\t\t\t struct netlbl_audit *audit_info)\n{\n\tint ret_val = -EINVAL;\n\tstruct netlbl_dom_map *entry;\n\n\trcu_read_lock();\n\n\tif (family == AF_INET || family == AF_UNSPEC) {\n\t\tif (domain)\n\t\t\tentry = netlbl_domhsh_search(domain, AF_INET);\n\t\telse\n\t\t\tentry = netlbl_domhsh_search_def(domain, AF_INET);\n\t\tret_val = netlbl_domhsh_remove_entry(entry, audit_info);\n\t\tif (ret_val && ret_val != -ENOENT)\n\t\t\tgoto done;\n\t}\n\tif (family == AF_INET6 || family == AF_UNSPEC) {\n\t\tint ret_val2;\n\n\t\tif (domain)\n\t\t\tentry = netlbl_domhsh_search(domain, AF_INET6);\n\t\telse\n\t\t\tentry = netlbl_domhsh_search_def(domain, AF_INET6);\n\t\tret_val2 = netlbl_domhsh_remove_entry(entry, audit_info);\n\t\tif (ret_val2 != -ENOENT)\n\t\t\tret_val = ret_val2;\n\t}\ndone:\n\trcu_read_unlock();\n\n\treturn ret_val;\n}\n\n \nint netlbl_domhsh_remove_default(u16 family, struct netlbl_audit *audit_info)\n{\n\treturn netlbl_domhsh_remove(NULL, family, audit_info);\n}\n\n \nstruct netlbl_dom_map *netlbl_domhsh_getentry(const char *domain, u16 family)\n{\n\tif (family == AF_UNSPEC)\n\t\treturn NULL;\n\treturn netlbl_domhsh_search_def(domain, family);\n}\n\n \nstruct netlbl_dommap_def *netlbl_domhsh_getentry_af4(const char *domain,\n\t\t\t\t\t\t     __be32 addr)\n{\n\tstruct netlbl_dom_map *dom_iter;\n\tstruct netlbl_af4list *addr_iter;\n\n\tdom_iter = netlbl_domhsh_search_def(domain, AF_INET);\n\tif (dom_iter == NULL)\n\t\treturn NULL;\n\n\tif (dom_iter->def.type != NETLBL_NLTYPE_ADDRSELECT)\n\t\treturn &dom_iter->def;\n\taddr_iter = netlbl_af4list_search(addr, &dom_iter->def.addrsel->list4);\n\tif (addr_iter == NULL)\n\t\treturn NULL;\n\treturn &(netlbl_domhsh_addr4_entry(addr_iter)->def);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nstruct netlbl_dommap_def *netlbl_domhsh_getentry_af6(const char *domain,\n\t\t\t\t\t\t   const struct in6_addr *addr)\n{\n\tstruct netlbl_dom_map *dom_iter;\n\tstruct netlbl_af6list *addr_iter;\n\n\tdom_iter = netlbl_domhsh_search_def(domain, AF_INET6);\n\tif (dom_iter == NULL)\n\t\treturn NULL;\n\n\tif (dom_iter->def.type != NETLBL_NLTYPE_ADDRSELECT)\n\t\treturn &dom_iter->def;\n\taddr_iter = netlbl_af6list_search(addr, &dom_iter->def.addrsel->list6);\n\tif (addr_iter == NULL)\n\t\treturn NULL;\n\treturn &(netlbl_domhsh_addr6_entry(addr_iter)->def);\n}\n#endif  \n\n \nint netlbl_domhsh_walk(u32 *skip_bkt,\n\t\t     u32 *skip_chain,\n\t\t     int (*callback) (struct netlbl_dom_map *entry, void *arg),\n\t\t     void *cb_arg)\n{\n\tint ret_val = -ENOENT;\n\tu32 iter_bkt;\n\tstruct list_head *iter_list;\n\tstruct netlbl_dom_map *iter_entry;\n\tu32 chain_cnt = 0;\n\n\trcu_read_lock();\n\tfor (iter_bkt = *skip_bkt;\n\t     iter_bkt < rcu_dereference(netlbl_domhsh)->size;\n\t     iter_bkt++, chain_cnt = 0) {\n\t\titer_list = &rcu_dereference(netlbl_domhsh)->tbl[iter_bkt];\n\t\tlist_for_each_entry_rcu(iter_entry, iter_list, list)\n\t\t\tif (iter_entry->valid) {\n\t\t\t\tif (chain_cnt++ < *skip_chain)\n\t\t\t\t\tcontinue;\n\t\t\t\tret_val = callback(iter_entry, cb_arg);\n\t\t\t\tif (ret_val < 0) {\n\t\t\t\t\tchain_cnt--;\n\t\t\t\t\tgoto walk_return;\n\t\t\t\t}\n\t\t\t}\n\t}\n\nwalk_return:\n\trcu_read_unlock();\n\t*skip_bkt = iter_bkt;\n\t*skip_chain = chain_cnt;\n\treturn ret_val;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}