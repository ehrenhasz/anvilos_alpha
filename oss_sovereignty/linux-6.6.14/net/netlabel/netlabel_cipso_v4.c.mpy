{
  "module_name": "netlabel_cipso_v4.c",
  "hash_id": "e07fadee5acd346a61afcfc4536e5a2bf42ad9e2a5ef83606d53f4a21d36601b",
  "original_prompt": "Ingested from linux-6.6.14/net/netlabel/netlabel_cipso_v4.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/string.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/netlink.h>\n#include <net/genetlink.h>\n#include <net/netlabel.h>\n#include <net/cipso_ipv4.h>\n#include <linux/atomic.h>\n\n#include \"netlabel_user.h\"\n#include \"netlabel_cipso_v4.h\"\n#include \"netlabel_mgmt.h\"\n#include \"netlabel_domainhash.h\"\n\n \nstruct netlbl_cipsov4_doiwalk_arg {\n\tstruct netlink_callback *nl_cb;\n\tstruct sk_buff *skb;\n\tu32 seq;\n};\n\n \nstruct netlbl_domhsh_walk_arg {\n\tstruct netlbl_audit *audit_info;\n\tu32 doi;\n};\n\n \nstatic struct genl_family netlbl_cipsov4_gnl_family;\n \nstatic const struct nla_policy netlbl_cipsov4_genl_policy[NLBL_CIPSOV4_A_MAX + 1] = {\n\t[NLBL_CIPSOV4_A_DOI] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MTYPE] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_TAG] = { .type = NLA_U8 },\n\t[NLBL_CIPSOV4_A_TAGLST] = { .type = NLA_NESTED },\n\t[NLBL_CIPSOV4_A_MLSLVLLOC] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MLSLVLREM] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MLSLVL] = { .type = NLA_NESTED },\n\t[NLBL_CIPSOV4_A_MLSLVLLST] = { .type = NLA_NESTED },\n\t[NLBL_CIPSOV4_A_MLSCATLOC] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MLSCATREM] = { .type = NLA_U32 },\n\t[NLBL_CIPSOV4_A_MLSCAT] = { .type = NLA_NESTED },\n\t[NLBL_CIPSOV4_A_MLSCATLST] = { .type = NLA_NESTED },\n};\n\n \n\n \nstatic int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested_deprecated(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\t\t   NLBL_CIPSOV4_A_MAX,\n\t\t\t\t\t   netlbl_cipsov4_genl_policy,\n\t\t\t\t\t   NULL) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla_type(nla) == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter >= CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\twhile (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter++] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}\n\n \n\n \nstatic int netlbl_cipsov4_add_std(struct genl_info *info,\n\t\t\t\t  struct netlbl_audit *audit_info)\n{\n\tint ret_val = -EINVAL;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\tstruct nlattr *nla_a;\n\tstruct nlattr *nla_b;\n\tint nla_a_rem;\n\tint nla_b_rem;\n\tu32 iter;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_TAGLST] ||\n\t    !info->attrs[NLBL_CIPSOV4_A_MLSLVLLST])\n\t\treturn -EINVAL;\n\n\tif (nla_validate_nested_deprecated(info->attrs[NLBL_CIPSOV4_A_MLSLVLLST],\n\t\t\t\t\t   NLBL_CIPSOV4_A_MAX,\n\t\t\t\t\t   netlbl_cipsov4_genl_policy,\n\t\t\t\t\t   NULL) != 0)\n\t\treturn -EINVAL;\n\n\tdoi_def = kmalloc(sizeof(*doi_def), GFP_KERNEL);\n\tif (doi_def == NULL)\n\t\treturn -ENOMEM;\n\tdoi_def->map.std = kzalloc(sizeof(*doi_def->map.std), GFP_KERNEL);\n\tif (doi_def->map.std == NULL) {\n\t\tkfree(doi_def);\n\t\treturn -ENOMEM;\n\t}\n\tdoi_def->type = CIPSO_V4_MAP_TRANS;\n\n\tret_val = netlbl_cipsov4_add_common(info, doi_def);\n\tif (ret_val != 0)\n\t\tgoto add_std_failure;\n\tret_val = -EINVAL;\n\n\tnla_for_each_nested(nla_a,\n\t\t\t    info->attrs[NLBL_CIPSOV4_A_MLSLVLLST],\n\t\t\t    nla_a_rem)\n\t\tif (nla_type(nla_a) == NLBL_CIPSOV4_A_MLSLVL) {\n\t\t\tif (nla_validate_nested_deprecated(nla_a,\n\t\t\t\t\t\t\t   NLBL_CIPSOV4_A_MAX,\n\t\t\t\t\t\t\t   netlbl_cipsov4_genl_policy,\n\t\t\t\t\t\t\t   NULL) != 0)\n\t\t\t\tgoto add_std_failure;\n\t\t\tnla_for_each_nested(nla_b, nla_a, nla_b_rem)\n\t\t\t\tswitch (nla_type(nla_b)) {\n\t\t\t\tcase NLBL_CIPSOV4_A_MLSLVLLOC:\n\t\t\t\t\tif (nla_get_u32(nla_b) >\n\t\t\t\t\t    CIPSO_V4_MAX_LOC_LVLS)\n\t\t\t\t\t\tgoto add_std_failure;\n\t\t\t\t\tif (nla_get_u32(nla_b) >=\n\t\t\t\t\t    doi_def->map.std->lvl.local_size)\n\t\t\t\t\t     doi_def->map.std->lvl.local_size =\n\t\t\t\t\t\t     nla_get_u32(nla_b) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase NLBL_CIPSOV4_A_MLSLVLREM:\n\t\t\t\t\tif (nla_get_u32(nla_b) >\n\t\t\t\t\t    CIPSO_V4_MAX_REM_LVLS)\n\t\t\t\t\t\tgoto add_std_failure;\n\t\t\t\t\tif (nla_get_u32(nla_b) >=\n\t\t\t\t\t    doi_def->map.std->lvl.cipso_size)\n\t\t\t\t\t     doi_def->map.std->lvl.cipso_size =\n\t\t\t\t\t\t     nla_get_u32(nla_b) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\tdoi_def->map.std->lvl.local = kcalloc(doi_def->map.std->lvl.local_size,\n\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t      GFP_KERNEL | __GFP_NOWARN);\n\tif (doi_def->map.std->lvl.local == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto add_std_failure;\n\t}\n\tdoi_def->map.std->lvl.cipso = kcalloc(doi_def->map.std->lvl.cipso_size,\n\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t      GFP_KERNEL | __GFP_NOWARN);\n\tif (doi_def->map.std->lvl.cipso == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto add_std_failure;\n\t}\n\tfor (iter = 0; iter < doi_def->map.std->lvl.local_size; iter++)\n\t\tdoi_def->map.std->lvl.local[iter] = CIPSO_V4_INV_LVL;\n\tfor (iter = 0; iter < doi_def->map.std->lvl.cipso_size; iter++)\n\t\tdoi_def->map.std->lvl.cipso[iter] = CIPSO_V4_INV_LVL;\n\tnla_for_each_nested(nla_a,\n\t\t\t    info->attrs[NLBL_CIPSOV4_A_MLSLVLLST],\n\t\t\t    nla_a_rem)\n\t\tif (nla_type(nla_a) == NLBL_CIPSOV4_A_MLSLVL) {\n\t\t\tstruct nlattr *lvl_loc;\n\t\t\tstruct nlattr *lvl_rem;\n\n\t\t\tlvl_loc = nla_find_nested(nla_a,\n\t\t\t\t\t\t  NLBL_CIPSOV4_A_MLSLVLLOC);\n\t\t\tlvl_rem = nla_find_nested(nla_a,\n\t\t\t\t\t\t  NLBL_CIPSOV4_A_MLSLVLREM);\n\t\t\tif (lvl_loc == NULL || lvl_rem == NULL)\n\t\t\t\tgoto add_std_failure;\n\t\t\tdoi_def->map.std->lvl.local[nla_get_u32(lvl_loc)] =\n\t\t\t\tnla_get_u32(lvl_rem);\n\t\t\tdoi_def->map.std->lvl.cipso[nla_get_u32(lvl_rem)] =\n\t\t\t\tnla_get_u32(lvl_loc);\n\t\t}\n\n\tif (info->attrs[NLBL_CIPSOV4_A_MLSCATLST]) {\n\t\tif (nla_validate_nested_deprecated(info->attrs[NLBL_CIPSOV4_A_MLSCATLST],\n\t\t\t\t\t\t   NLBL_CIPSOV4_A_MAX,\n\t\t\t\t\t\t   netlbl_cipsov4_genl_policy,\n\t\t\t\t\t\t   NULL) != 0)\n\t\t\tgoto add_std_failure;\n\n\t\tnla_for_each_nested(nla_a,\n\t\t\t\t    info->attrs[NLBL_CIPSOV4_A_MLSCATLST],\n\t\t\t\t    nla_a_rem)\n\t\t\tif (nla_type(nla_a) == NLBL_CIPSOV4_A_MLSCAT) {\n\t\t\t\tif (nla_validate_nested_deprecated(nla_a,\n\t\t\t\t\t\t\t\t   NLBL_CIPSOV4_A_MAX,\n\t\t\t\t\t\t\t\t   netlbl_cipsov4_genl_policy,\n\t\t\t\t\t\t\t\t   NULL) != 0)\n\t\t\t\t\tgoto add_std_failure;\n\t\t\t\tnla_for_each_nested(nla_b, nla_a, nla_b_rem)\n\t\t\t\t\tswitch (nla_type(nla_b)) {\n\t\t\t\t\tcase NLBL_CIPSOV4_A_MLSCATLOC:\n\t\t\t\t\t\tif (nla_get_u32(nla_b) >\n\t\t\t\t\t\t    CIPSO_V4_MAX_LOC_CATS)\n\t\t\t\t\t\t\tgoto add_std_failure;\n\t\t\t\t\t\tif (nla_get_u32(nla_b) >=\n\t\t\t\t\t      doi_def->map.std->cat.local_size)\n\t\t\t\t\t     doi_def->map.std->cat.local_size =\n\t\t\t\t\t\t     nla_get_u32(nla_b) + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase NLBL_CIPSOV4_A_MLSCATREM:\n\t\t\t\t\t\tif (nla_get_u32(nla_b) >\n\t\t\t\t\t\t    CIPSO_V4_MAX_REM_CATS)\n\t\t\t\t\t\t\tgoto add_std_failure;\n\t\t\t\t\t\tif (nla_get_u32(nla_b) >=\n\t\t\t\t\t      doi_def->map.std->cat.cipso_size)\n\t\t\t\t\t     doi_def->map.std->cat.cipso_size =\n\t\t\t\t\t\t     nla_get_u32(nla_b) + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\tdoi_def->map.std->cat.local = kcalloc(\n\t\t\t\t\t      doi_def->map.std->cat.local_size,\n\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t      GFP_KERNEL | __GFP_NOWARN);\n\t\tif (doi_def->map.std->cat.local == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto add_std_failure;\n\t\t}\n\t\tdoi_def->map.std->cat.cipso = kcalloc(\n\t\t\t\t\t      doi_def->map.std->cat.cipso_size,\n\t\t\t\t\t      sizeof(u32),\n\t\t\t\t\t      GFP_KERNEL | __GFP_NOWARN);\n\t\tif (doi_def->map.std->cat.cipso == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto add_std_failure;\n\t\t}\n\t\tfor (iter = 0; iter < doi_def->map.std->cat.local_size; iter++)\n\t\t\tdoi_def->map.std->cat.local[iter] = CIPSO_V4_INV_CAT;\n\t\tfor (iter = 0; iter < doi_def->map.std->cat.cipso_size; iter++)\n\t\t\tdoi_def->map.std->cat.cipso[iter] = CIPSO_V4_INV_CAT;\n\t\tnla_for_each_nested(nla_a,\n\t\t\t\t    info->attrs[NLBL_CIPSOV4_A_MLSCATLST],\n\t\t\t\t    nla_a_rem)\n\t\t\tif (nla_type(nla_a) == NLBL_CIPSOV4_A_MLSCAT) {\n\t\t\t\tstruct nlattr *cat_loc;\n\t\t\t\tstruct nlattr *cat_rem;\n\n\t\t\t\tcat_loc = nla_find_nested(nla_a,\n\t\t\t\t\t\t     NLBL_CIPSOV4_A_MLSCATLOC);\n\t\t\t\tcat_rem = nla_find_nested(nla_a,\n\t\t\t\t\t\t     NLBL_CIPSOV4_A_MLSCATREM);\n\t\t\t\tif (cat_loc == NULL || cat_rem == NULL)\n\t\t\t\t\tgoto add_std_failure;\n\t\t\t\tdoi_def->map.std->cat.local[\n\t\t\t\t\t\t\tnla_get_u32(cat_loc)] =\n\t\t\t\t\tnla_get_u32(cat_rem);\n\t\t\t\tdoi_def->map.std->cat.cipso[\n\t\t\t\t\t\t\tnla_get_u32(cat_rem)] =\n\t\t\t\t\tnla_get_u32(cat_loc);\n\t\t\t}\n\t}\n\n\tret_val = cipso_v4_doi_add(doi_def, audit_info);\n\tif (ret_val != 0)\n\t\tgoto add_std_failure;\n\treturn 0;\n\nadd_std_failure:\n\tcipso_v4_doi_free(doi_def);\n\treturn ret_val;\n}\n\n \nstatic int netlbl_cipsov4_add_pass(struct genl_info *info,\n\t\t\t\t   struct netlbl_audit *audit_info)\n{\n\tint ret_val;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_TAGLST])\n\t\treturn -EINVAL;\n\n\tdoi_def = kmalloc(sizeof(*doi_def), GFP_KERNEL);\n\tif (doi_def == NULL)\n\t\treturn -ENOMEM;\n\tdoi_def->type = CIPSO_V4_MAP_PASS;\n\n\tret_val = netlbl_cipsov4_add_common(info, doi_def);\n\tif (ret_val != 0)\n\t\tgoto add_pass_failure;\n\n\tret_val = cipso_v4_doi_add(doi_def, audit_info);\n\tif (ret_val != 0)\n\t\tgoto add_pass_failure;\n\treturn 0;\n\nadd_pass_failure:\n\tcipso_v4_doi_free(doi_def);\n\treturn ret_val;\n}\n\n \nstatic int netlbl_cipsov4_add_local(struct genl_info *info,\n\t\t\t\t    struct netlbl_audit *audit_info)\n{\n\tint ret_val;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_TAGLST])\n\t\treturn -EINVAL;\n\n\tdoi_def = kmalloc(sizeof(*doi_def), GFP_KERNEL);\n\tif (doi_def == NULL)\n\t\treturn -ENOMEM;\n\tdoi_def->type = CIPSO_V4_MAP_LOCAL;\n\n\tret_val = netlbl_cipsov4_add_common(info, doi_def);\n\tif (ret_val != 0)\n\t\tgoto add_local_failure;\n\n\tret_val = cipso_v4_doi_add(doi_def, audit_info);\n\tif (ret_val != 0)\n\t\tgoto add_local_failure;\n\treturn 0;\n\nadd_local_failure:\n\tcipso_v4_doi_free(doi_def);\n\treturn ret_val;\n}\n\n \nstatic int netlbl_cipsov4_add(struct sk_buff *skb, struct genl_info *info)\n\n{\n\tint ret_val = -EINVAL;\n\tstruct netlbl_audit audit_info;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_DOI] ||\n\t    !info->attrs[NLBL_CIPSOV4_A_MTYPE])\n\t\treturn -EINVAL;\n\n\tnetlbl_netlink_auditinfo(&audit_info);\n\tswitch (nla_get_u32(info->attrs[NLBL_CIPSOV4_A_MTYPE])) {\n\tcase CIPSO_V4_MAP_TRANS:\n\t\tret_val = netlbl_cipsov4_add_std(info, &audit_info);\n\t\tbreak;\n\tcase CIPSO_V4_MAP_PASS:\n\t\tret_val = netlbl_cipsov4_add_pass(info, &audit_info);\n\t\tbreak;\n\tcase CIPSO_V4_MAP_LOCAL:\n\t\tret_val = netlbl_cipsov4_add_local(info, &audit_info);\n\t\tbreak;\n\t}\n\tif (ret_val == 0)\n\t\tatomic_inc(&netlabel_mgmt_protocount);\n\n\treturn ret_val;\n}\n\n \nstatic int netlbl_cipsov4_list(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret_val;\n\tstruct sk_buff *ans_skb = NULL;\n\tu32 nlsze_mult = 1;\n\tvoid *data;\n\tu32 doi;\n\tstruct nlattr *nla_a;\n\tstruct nlattr *nla_b;\n\tstruct cipso_v4_doi *doi_def;\n\tu32 iter;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_DOI]) {\n\t\tret_val = -EINVAL;\n\t\tgoto list_failure;\n\t}\n\nlist_start:\n\tans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE * nlsze_mult, GFP_KERNEL);\n\tif (ans_skb == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure;\n\t}\n\tdata = genlmsg_put_reply(ans_skb, info, &netlbl_cipsov4_gnl_family,\n\t\t\t\t 0, NLBL_CIPSOV4_C_LIST);\n\tif (data == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure;\n\t}\n\n\tdoi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_getdef(doi);\n\tif (doi_def == NULL) {\n\t\tret_val = -EINVAL;\n\t\tgoto list_failure_lock;\n\t}\n\n\tret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MTYPE, doi_def->type);\n\tif (ret_val != 0)\n\t\tgoto list_failure_lock;\n\n\tnla_a = nla_nest_start_noflag(ans_skb, NLBL_CIPSOV4_A_TAGLST);\n\tif (nla_a == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto list_failure_lock;\n\t}\n\tfor (iter = 0;\n\t     iter < CIPSO_V4_TAG_MAXCNT &&\n\t       doi_def->tags[iter] != CIPSO_V4_TAG_INVALID;\n\t     iter++) {\n\t\tret_val = nla_put_u8(ans_skb,\n\t\t\t\t     NLBL_CIPSOV4_A_TAG,\n\t\t\t\t     doi_def->tags[iter]);\n\t\tif (ret_val != 0)\n\t\t\tgoto list_failure_lock;\n\t}\n\tnla_nest_end(ans_skb, nla_a);\n\n\tswitch (doi_def->type) {\n\tcase CIPSO_V4_MAP_TRANS:\n\t\tnla_a = nla_nest_start_noflag(ans_skb,\n\t\t\t\t\t      NLBL_CIPSOV4_A_MLSLVLLST);\n\t\tif (nla_a == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto list_failure_lock;\n\t\t}\n\t\tfor (iter = 0;\n\t\t     iter < doi_def->map.std->lvl.local_size;\n\t\t     iter++) {\n\t\t\tif (doi_def->map.std->lvl.local[iter] ==\n\t\t\t    CIPSO_V4_INV_LVL)\n\t\t\t\tcontinue;\n\n\t\t\tnla_b = nla_nest_start_noflag(ans_skb,\n\t\t\t\t\t\t      NLBL_CIPSOV4_A_MLSLVL);\n\t\t\tif (nla_b == NULL) {\n\t\t\t\tret_val = -ENOMEM;\n\t\t\t\tgoto list_retry;\n\t\t\t}\n\t\t\tret_val = nla_put_u32(ans_skb,\n\t\t\t\t\t      NLBL_CIPSOV4_A_MLSLVLLOC,\n\t\t\t\t\t      iter);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto list_retry;\n\t\t\tret_val = nla_put_u32(ans_skb,\n\t\t\t\t\t    NLBL_CIPSOV4_A_MLSLVLREM,\n\t\t\t\t\t    doi_def->map.std->lvl.local[iter]);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto list_retry;\n\t\t\tnla_nest_end(ans_skb, nla_b);\n\t\t}\n\t\tnla_nest_end(ans_skb, nla_a);\n\n\t\tnla_a = nla_nest_start_noflag(ans_skb,\n\t\t\t\t\t      NLBL_CIPSOV4_A_MLSCATLST);\n\t\tif (nla_a == NULL) {\n\t\t\tret_val = -ENOMEM;\n\t\t\tgoto list_retry;\n\t\t}\n\t\tfor (iter = 0;\n\t\t     iter < doi_def->map.std->cat.local_size;\n\t\t     iter++) {\n\t\t\tif (doi_def->map.std->cat.local[iter] ==\n\t\t\t    CIPSO_V4_INV_CAT)\n\t\t\t\tcontinue;\n\n\t\t\tnla_b = nla_nest_start_noflag(ans_skb,\n\t\t\t\t\t\t      NLBL_CIPSOV4_A_MLSCAT);\n\t\t\tif (nla_b == NULL) {\n\t\t\t\tret_val = -ENOMEM;\n\t\t\t\tgoto list_retry;\n\t\t\t}\n\t\t\tret_val = nla_put_u32(ans_skb,\n\t\t\t\t\t      NLBL_CIPSOV4_A_MLSCATLOC,\n\t\t\t\t\t      iter);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto list_retry;\n\t\t\tret_val = nla_put_u32(ans_skb,\n\t\t\t\t\t    NLBL_CIPSOV4_A_MLSCATREM,\n\t\t\t\t\t    doi_def->map.std->cat.local[iter]);\n\t\t\tif (ret_val != 0)\n\t\t\t\tgoto list_retry;\n\t\t\tnla_nest_end(ans_skb, nla_b);\n\t\t}\n\t\tnla_nest_end(ans_skb, nla_a);\n\n\t\tbreak;\n\t}\n\tcipso_v4_doi_putdef(doi_def);\n\trcu_read_unlock();\n\n\tgenlmsg_end(ans_skb, data);\n\treturn genlmsg_reply(ans_skb, info);\n\nlist_retry:\n\t \n\tif (nlsze_mult < 4) {\n\t\tcipso_v4_doi_putdef(doi_def);\n\t\trcu_read_unlock();\n\t\tkfree_skb(ans_skb);\n\t\tnlsze_mult *= 2;\n\t\tgoto list_start;\n\t}\nlist_failure_lock:\n\tcipso_v4_doi_putdef(doi_def);\n\trcu_read_unlock();\nlist_failure:\n\tkfree_skb(ans_skb);\n\treturn ret_val;\n}\n\n \nstatic int netlbl_cipsov4_listall_cb(struct cipso_v4_doi *doi_def, void *arg)\n{\n\tint ret_val = -ENOMEM;\n\tstruct netlbl_cipsov4_doiwalk_arg *cb_arg = arg;\n\tvoid *data;\n\n\tdata = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).portid,\n\t\t\t   cb_arg->seq, &netlbl_cipsov4_gnl_family,\n\t\t\t   NLM_F_MULTI, NLBL_CIPSOV4_C_LISTALL);\n\tif (data == NULL)\n\t\tgoto listall_cb_failure;\n\n\tret_val = nla_put_u32(cb_arg->skb, NLBL_CIPSOV4_A_DOI, doi_def->doi);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\tret_val = nla_put_u32(cb_arg->skb,\n\t\t\t      NLBL_CIPSOV4_A_MTYPE,\n\t\t\t      doi_def->type);\n\tif (ret_val != 0)\n\t\tgoto listall_cb_failure;\n\n\tgenlmsg_end(cb_arg->skb, data);\n\treturn 0;\n\nlistall_cb_failure:\n\tgenlmsg_cancel(cb_arg->skb, data);\n\treturn ret_val;\n}\n\n \nstatic int netlbl_cipsov4_listall(struct sk_buff *skb,\n\t\t\t\t  struct netlink_callback *cb)\n{\n\tstruct netlbl_cipsov4_doiwalk_arg cb_arg;\n\tu32 doi_skip = cb->args[0];\n\n\tcb_arg.nl_cb = cb;\n\tcb_arg.skb = skb;\n\tcb_arg.seq = cb->nlh->nlmsg_seq;\n\n\tcipso_v4_doi_walk(&doi_skip, netlbl_cipsov4_listall_cb, &cb_arg);\n\n\tcb->args[0] = doi_skip;\n\treturn skb->len;\n}\n\n \nstatic int netlbl_cipsov4_remove_cb(struct netlbl_dom_map *entry, void *arg)\n{\n\tstruct netlbl_domhsh_walk_arg *cb_arg = arg;\n\n\tif (entry->def.type == NETLBL_NLTYPE_CIPSOV4 &&\n\t    entry->def.cipso->doi == cb_arg->doi)\n\t\treturn netlbl_domhsh_remove_entry(entry, cb_arg->audit_info);\n\n\treturn 0;\n}\n\n \nstatic int netlbl_cipsov4_remove(struct sk_buff *skb, struct genl_info *info)\n{\n\tint ret_val = -EINVAL;\n\tstruct netlbl_domhsh_walk_arg cb_arg;\n\tstruct netlbl_audit audit_info;\n\tu32 skip_bkt = 0;\n\tu32 skip_chain = 0;\n\n\tif (!info->attrs[NLBL_CIPSOV4_A_DOI])\n\t\treturn -EINVAL;\n\n\tnetlbl_netlink_auditinfo(&audit_info);\n\tcb_arg.doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\tcb_arg.audit_info = &audit_info;\n\tret_val = netlbl_domhsh_walk(&skip_bkt, &skip_chain,\n\t\t\t\t     netlbl_cipsov4_remove_cb, &cb_arg);\n\tif (ret_val == 0 || ret_val == -ENOENT) {\n\t\tret_val = cipso_v4_doi_remove(cb_arg.doi, &audit_info);\n\t\tif (ret_val == 0)\n\t\t\tatomic_dec(&netlabel_mgmt_protocount);\n\t}\n\n\treturn ret_val;\n}\n\n \n\nstatic const struct genl_small_ops netlbl_cipsov4_ops[] = {\n\t{\n\t.cmd = NLBL_CIPSOV4_C_ADD,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = GENL_ADMIN_PERM,\n\t.doit = netlbl_cipsov4_add,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_CIPSOV4_C_REMOVE,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = GENL_ADMIN_PERM,\n\t.doit = netlbl_cipsov4_remove,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_CIPSOV4_C_LIST,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = 0,\n\t.doit = netlbl_cipsov4_list,\n\t.dumpit = NULL,\n\t},\n\t{\n\t.cmd = NLBL_CIPSOV4_C_LISTALL,\n\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t.flags = 0,\n\t.doit = NULL,\n\t.dumpit = netlbl_cipsov4_listall,\n\t},\n};\n\nstatic struct genl_family netlbl_cipsov4_gnl_family __ro_after_init = {\n\t.hdrsize = 0,\n\t.name = NETLBL_NLTYPE_CIPSOV4_NAME,\n\t.version = NETLBL_PROTO_VERSION,\n\t.maxattr = NLBL_CIPSOV4_A_MAX,\n\t.policy = netlbl_cipsov4_genl_policy,\n\t.module = THIS_MODULE,\n\t.small_ops = netlbl_cipsov4_ops,\n\t.n_small_ops = ARRAY_SIZE(netlbl_cipsov4_ops),\n\t.resv_start_op = NLBL_CIPSOV4_C_LISTALL + 1,\n};\n\n \n\n \nint __init netlbl_cipsov4_genl_init(void)\n{\n\treturn genl_register_family(&netlbl_cipsov4_gnl_family);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}