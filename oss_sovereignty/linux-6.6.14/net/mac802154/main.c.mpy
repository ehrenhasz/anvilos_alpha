{
  "module_name": "main.c",
  "hash_id": "7e37a0712d4d09ffed81f90dafc0820a1c583abdcea8f1af8becf95585b5aa1a",
  "original_prompt": "Ingested from linux-6.6.14/net/mac802154/main.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n\n#include <net/netlink.h>\n#include <net/nl802154.h>\n#include <net/mac802154.h>\n#include <net/ieee802154_netdev.h>\n#include <net/route.h>\n#include <net/cfg802154.h>\n\n#include \"ieee802154_i.h\"\n#include \"cfg.h\"\n\nstatic void ieee802154_tasklet_handler(struct tasklet_struct *t)\n{\n\tstruct ieee802154_local *local = from_tasklet(local, t, tasklet);\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&local->skb_queue))) {\n\t\tswitch (skb->pkt_type) {\n\t\tcase IEEE802154_RX_MSG:\n\t\t\t \n\t\t\tskb->pkt_type = 0;\n\t\t\tieee802154_rx(local, skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"mac802154: Packet is of unknown type %d\\n\",\n\t\t\t     skb->pkt_type);\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstruct ieee802154_hw *\nieee802154_alloc_hw(size_t priv_data_len, const struct ieee802154_ops *ops)\n{\n\tstruct wpan_phy *phy;\n\tstruct ieee802154_local *local;\n\tsize_t priv_size;\n\n\tif (WARN_ON(!ops || !(ops->xmit_async || ops->xmit_sync) || !ops->ed ||\n\t\t    !ops->start || !ops->stop || !ops->set_channel))\n\t\treturn NULL;\n\n\t \n\n\tpriv_size = ALIGN(sizeof(*local), NETDEV_ALIGN) + priv_data_len;\n\n\tphy = wpan_phy_new(&mac802154_config_ops, priv_size);\n\tif (!phy) {\n\t\tpr_err(\"failure to allocate master IEEE802.15.4 device\\n\");\n\t\treturn NULL;\n\t}\n\n\tphy->privid = mac802154_wpan_phy_privid;\n\n\tlocal = wpan_phy_priv(phy);\n\tlocal->phy = phy;\n\tlocal->hw.phy = local->phy;\n\tlocal->hw.priv = (char *)local + ALIGN(sizeof(*local), NETDEV_ALIGN);\n\tlocal->ops = ops;\n\n\tINIT_LIST_HEAD(&local->interfaces);\n\tINIT_LIST_HEAD(&local->rx_beacon_list);\n\tINIT_LIST_HEAD(&local->rx_mac_cmd_list);\n\tmutex_init(&local->iflist_mtx);\n\n\ttasklet_setup(&local->tasklet, ieee802154_tasklet_handler);\n\n\tskb_queue_head_init(&local->skb_queue);\n\n\tINIT_WORK(&local->sync_tx_work, ieee802154_xmit_sync_worker);\n\tINIT_DELAYED_WORK(&local->scan_work, mac802154_scan_worker);\n\tINIT_WORK(&local->rx_beacon_work, mac802154_rx_beacon_worker);\n\tINIT_DELAYED_WORK(&local->beacon_work, mac802154_beacon_worker);\n\tINIT_WORK(&local->rx_mac_cmd_work, mac802154_rx_mac_cmd_worker);\n\n\t \n\tphy->supported.max_minbe = 8;\n\tphy->supported.min_maxbe = 3;\n\tphy->supported.max_maxbe = 8;\n\tphy->supported.min_frame_retries = 0;\n\tphy->supported.max_frame_retries = 7;\n\tphy->supported.max_csma_backoffs = 5;\n\tphy->supported.lbt = NL802154_SUPPORTED_BOOL_FALSE;\n\n\t \n\tphy->supported.iftypes = BIT(NL802154_IFTYPE_NODE) | BIT(NL802154_IFTYPE_COORD);\n\n\treturn &local->hw;\n}\nEXPORT_SYMBOL(ieee802154_alloc_hw);\n\nvoid ieee802154_configure_durations(struct wpan_phy *phy,\n\t\t\t\t    unsigned int page, unsigned int channel)\n{\n\tu32 duration = 0;\n\n\tswitch (page) {\n\tcase 0:\n\t\tif (BIT(channel) & 0x1)\n\t\t\t \n\t\t\tduration = 50 * NSEC_PER_USEC;\n\t\telse if (BIT(channel) & 0x7FE)\n\t\t\t \n\t\t\tduration = 25 * NSEC_PER_USEC;\n\t\telse if (BIT(channel) & 0x7FFF800)\n\t\t\t \n\t\t\tduration = 16 * NSEC_PER_USEC;\n\t\tbreak;\n\tcase 2:\n\t\tif (BIT(channel) & 0x1)\n\t\t\t \n\t\t\tduration = 40 * NSEC_PER_USEC;\n\t\telse if (BIT(channel) & 0x7FE)\n\t\t\t \n\t\t\tduration = 16 * NSEC_PER_USEC;\n\t\tbreak;\n\tcase 3:\n\t\tif (BIT(channel) & 0x3FFF)\n\t\t\t \n\t\t\tduration = 6 * NSEC_PER_USEC;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!duration) {\n\t\tpr_debug(\"Unknown PHY symbol duration\\n\");\n\t\treturn;\n\t}\n\n\tphy->symbol_duration = duration;\n\tphy->lifs_period = (IEEE802154_LIFS_PERIOD * phy->symbol_duration) / NSEC_PER_SEC;\n\tphy->sifs_period = (IEEE802154_SIFS_PERIOD * phy->symbol_duration) / NSEC_PER_SEC;\n}\nEXPORT_SYMBOL(ieee802154_configure_durations);\n\nvoid ieee802154_free_hw(struct ieee802154_hw *hw)\n{\n\tstruct ieee802154_local *local = hw_to_local(hw);\n\n\tBUG_ON(!list_empty(&local->interfaces));\n\n\tmutex_destroy(&local->iflist_mtx);\n\n\twpan_phy_free(local->phy);\n}\nEXPORT_SYMBOL(ieee802154_free_hw);\n\nstatic void ieee802154_setup_wpan_phy_pib(struct wpan_phy *wpan_phy)\n{\n\t \n\n\twpan_phy->lifs_period =\n\t\t(IEEE802154_LIFS_PERIOD * wpan_phy->symbol_duration) / 1000;\n\twpan_phy->sifs_period =\n\t\t(IEEE802154_SIFS_PERIOD * wpan_phy->symbol_duration) / 1000;\n}\n\nint ieee802154_register_hw(struct ieee802154_hw *hw)\n{\n\tstruct ieee802154_local *local = hw_to_local(hw);\n\tchar mac_wq_name[IFNAMSIZ + 10] = {};\n\tstruct net_device *dev;\n\tint rc = -ENOSYS;\n\n\tlocal->workqueue =\n\t\tcreate_singlethread_workqueue(wpan_phy_name(local->phy));\n\tif (!local->workqueue) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsnprintf(mac_wq_name, IFNAMSIZ + 10, \"%s-mac-cmds\", wpan_phy_name(local->phy));\n\tlocal->mac_wq =\tcreate_singlethread_workqueue(mac_wq_name);\n\tif (!local->mac_wq) {\n\t\trc = -ENOMEM;\n\t\tgoto out_wq;\n\t}\n\n\thrtimer_init(&local->ifs_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tlocal->ifs_timer.function = ieee802154_xmit_ifs_timer;\n\n\twpan_phy_set_dev(local->phy, local->hw.parent);\n\n\tieee802154_setup_wpan_phy_pib(local->phy);\n\n\tieee802154_configure_durations(local->phy, local->phy->current_page,\n\t\t\t\t       local->phy->current_channel);\n\n\tif (!(hw->flags & IEEE802154_HW_CSMA_PARAMS)) {\n\t\tlocal->phy->supported.min_csma_backoffs = 4;\n\t\tlocal->phy->supported.max_csma_backoffs = 4;\n\t\tlocal->phy->supported.min_maxbe = 5;\n\t\tlocal->phy->supported.max_maxbe = 5;\n\t\tlocal->phy->supported.min_minbe = 3;\n\t\tlocal->phy->supported.max_minbe = 3;\n\t}\n\n\tif (!(hw->flags & IEEE802154_HW_FRAME_RETRIES)) {\n\t\tlocal->phy->supported.min_frame_retries = 3;\n\t\tlocal->phy->supported.max_frame_retries = 3;\n\t}\n\n\tif (hw->flags & IEEE802154_HW_PROMISCUOUS)\n\t\tlocal->phy->supported.iftypes |= BIT(NL802154_IFTYPE_MONITOR);\n\n\trc = wpan_phy_register(local->phy);\n\tif (rc < 0)\n\t\tgoto out_mac_wq;\n\n\trtnl_lock();\n\n\tdev = ieee802154_if_add(local, \"wpan%d\", NET_NAME_ENUM,\n\t\t\t\tNL802154_IFTYPE_NODE,\n\t\t\t\tcpu_to_le64(0x0000000000000000ULL));\n\tif (IS_ERR(dev)) {\n\t\trtnl_unlock();\n\t\trc = PTR_ERR(dev);\n\t\tgoto out_phy;\n\t}\n\n\trtnl_unlock();\n\n\treturn 0;\n\nout_phy:\n\twpan_phy_unregister(local->phy);\nout_mac_wq:\n\tdestroy_workqueue(local->mac_wq);\nout_wq:\n\tdestroy_workqueue(local->workqueue);\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL(ieee802154_register_hw);\n\nvoid ieee802154_unregister_hw(struct ieee802154_hw *hw)\n{\n\tstruct ieee802154_local *local = hw_to_local(hw);\n\n\ttasklet_kill(&local->tasklet);\n\tflush_workqueue(local->workqueue);\n\n\trtnl_lock();\n\n\tieee802154_remove_interfaces(local);\n\n\trtnl_unlock();\n\n\tdestroy_workqueue(local->mac_wq);\n\tdestroy_workqueue(local->workqueue);\n\twpan_phy_unregister(local->phy);\n}\nEXPORT_SYMBOL(ieee802154_unregister_hw);\n\nstatic int __init ieee802154_init(void)\n{\n\treturn ieee802154_iface_init();\n}\n\nstatic void __exit ieee802154_exit(void)\n{\n\tieee802154_iface_exit();\n\n\trcu_barrier();\n}\n\nsubsys_initcall(ieee802154_init);\nmodule_exit(ieee802154_exit);\n\nMODULE_DESCRIPTION(\"IEEE 802.15.4 subsystem\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}