{
  "module_name": "iface.c",
  "hash_id": "459d021ca55839152af6b840fe1dc2b2306be3d6968c867cbf85db885ccb5d5d",
  "original_prompt": "Ingested from linux-6.6.14/net/mac802154/iface.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/module.h>\n#include <linux/if_arp.h>\n#include <linux/ieee802154.h>\n\n#include <net/nl802154.h>\n#include <net/mac802154.h>\n#include <net/ieee802154_netdev.h>\n#include <net/cfg802154.h>\n\n#include \"ieee802154_i.h\"\n#include \"driver-ops.h\"\n\nint mac802154_wpan_update_llsec(struct net_device *dev)\n{\n\tstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\n\tstruct ieee802154_mlme_ops *ops = ieee802154_mlme_ops(dev);\n\tstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\n\tint rc = 0;\n\n\tif (ops->llsec) {\n\t\tstruct ieee802154_llsec_params params;\n\t\tint changed = 0;\n\n\t\tparams.pan_id = wpan_dev->pan_id;\n\t\tchanged |= IEEE802154_LLSEC_PARAM_PAN_ID;\n\n\t\tparams.hwaddr = wpan_dev->extended_addr;\n\t\tchanged |= IEEE802154_LLSEC_PARAM_HWADDR;\n\n\t\trc = ops->llsec->set_params(dev, &params, changed);\n\t}\n\n\treturn rc;\n}\n\nstatic int\nmac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\n\tstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\n\tstruct sockaddr_ieee802154 *sa =\n\t\t(struct sockaddr_ieee802154 *)&ifr->ifr_addr;\n\tint err = -ENOIOCTLCMD;\n\n\tif (cmd != SIOCGIFADDR && cmd != SIOCSIFADDR)\n\t\treturn err;\n\n\trtnl_lock();\n\n\tswitch (cmd) {\n\tcase SIOCGIFADDR:\n\t{\n\t\tu16 pan_id, short_addr;\n\n\t\tpan_id = le16_to_cpu(wpan_dev->pan_id);\n\t\tshort_addr = le16_to_cpu(wpan_dev->short_addr);\n\t\tif (pan_id == IEEE802154_PANID_BROADCAST ||\n\t\t    short_addr == IEEE802154_ADDR_BROADCAST) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsa->family = AF_IEEE802154;\n\t\tsa->addr.addr_type = IEEE802154_ADDR_SHORT;\n\t\tsa->addr.pan_id = pan_id;\n\t\tsa->addr.short_addr = short_addr;\n\n\t\terr = 0;\n\t\tbreak;\n\t}\n\tcase SIOCSIFADDR:\n\t\tif (netif_running(dev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tdev_warn(&dev->dev,\n\t\t\t \"Using DEBUGing ioctl SIOCSIFADDR isn't recommended!\\n\");\n\t\tif (sa->family != AF_IEEE802154 ||\n\t\t    sa->addr.addr_type != IEEE802154_ADDR_SHORT ||\n\t\t    sa->addr.pan_id == IEEE802154_PANID_BROADCAST ||\n\t\t    sa->addr.short_addr == IEEE802154_ADDR_BROADCAST ||\n\t\t    sa->addr.short_addr == IEEE802154_ADDR_UNDEF) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\twpan_dev->pan_id = cpu_to_le16(sa->addr.pan_id);\n\t\twpan_dev->short_addr = cpu_to_le16(sa->addr.short_addr);\n\n\t\terr = mac802154_wpan_update_llsec(dev);\n\t\tbreak;\n\t}\n\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int mac802154_wpan_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\n\tstruct sockaddr *addr = p;\n\t__le64 extended_addr;\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\t \n\tif (sdata->wpan_dev.lowpan_dev) {\n\t\tif (netif_running(sdata->wpan_dev.lowpan_dev))\n\t\t\treturn -EBUSY;\n\t}\n\n\tieee802154_be64_to_le64(&extended_addr, addr->sa_data);\n\tif (!ieee802154_is_valid_extended_unicast_addr(extended_addr))\n\t\treturn -EINVAL;\n\n\tdev_addr_set(dev, addr->sa_data);\n\tsdata->wpan_dev.extended_addr = extended_addr;\n\n\t \n\tif (sdata->wpan_dev.lowpan_dev)\n\t\tdev_addr_set(sdata->wpan_dev.lowpan_dev, dev->dev_addr);\n\n\treturn mac802154_wpan_update_llsec(dev);\n}\n\nstatic int ieee802154_setup_hw(struct ieee802154_sub_if_data *sdata)\n{\n\tstruct ieee802154_local *local = sdata->local;\n\tstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\n\tint ret;\n\n\tsdata->required_filtering = sdata->iface_default_filtering;\n\n\tif (local->hw.flags & IEEE802154_HW_AFILT) {\n\t\tlocal->addr_filt.pan_id = wpan_dev->pan_id;\n\t\tlocal->addr_filt.ieee_addr = wpan_dev->extended_addr;\n\t\tlocal->addr_filt.short_addr = wpan_dev->short_addr;\n\t}\n\n\tif (local->hw.flags & IEEE802154_HW_LBT) {\n\t\tret = drv_set_lbt_mode(local, wpan_dev->lbt);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (local->hw.flags & IEEE802154_HW_CSMA_PARAMS) {\n\t\tret = drv_set_csma_params(local, wpan_dev->min_be,\n\t\t\t\t\t  wpan_dev->max_be,\n\t\t\t\t\t  wpan_dev->csma_retries);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (local->hw.flags & IEEE802154_HW_FRAME_RETRIES) {\n\t\tret = drv_set_max_frame_retries(local, wpan_dev->frame_retries);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mac802154_slave_open(struct net_device *dev)\n{\n\tstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\n\tstruct ieee802154_local *local = sdata->local;\n\tint res;\n\n\tASSERT_RTNL();\n\n\tset_bit(SDATA_STATE_RUNNING, &sdata->state);\n\n\tif (!local->open_count) {\n\t\tres = ieee802154_setup_hw(sdata);\n\t\tif (res)\n\t\t\tgoto err;\n\n\t\tres = drv_start(local, sdata->required_filtering,\n\t\t\t\t&local->addr_filt);\n\t\tif (res)\n\t\t\tgoto err;\n\t}\n\n\tlocal->open_count++;\n\tnetif_start_queue(dev);\n\treturn 0;\nerr:\n\t \n\tclear_bit(SDATA_STATE_RUNNING, &sdata->state);\n\n\treturn res;\n}\n\nstatic int\nieee802154_check_mac_settings(struct ieee802154_local *local,\n\t\t\t      struct ieee802154_sub_if_data *sdata,\n\t\t\t      struct ieee802154_sub_if_data *nsdata)\n{\n\tstruct wpan_dev *nwpan_dev = &nsdata->wpan_dev;\n\tstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\n\n\tASSERT_RTNL();\n\n\tif (sdata->iface_default_filtering != nsdata->iface_default_filtering)\n\t\treturn -EBUSY;\n\n\tif (local->hw.flags & IEEE802154_HW_AFILT) {\n\t\tif (wpan_dev->pan_id != nwpan_dev->pan_id ||\n\t\t    wpan_dev->short_addr != nwpan_dev->short_addr ||\n\t\t    wpan_dev->extended_addr != nwpan_dev->extended_addr)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (local->hw.flags & IEEE802154_HW_CSMA_PARAMS) {\n\t\tif (wpan_dev->min_be != nwpan_dev->min_be ||\n\t\t    wpan_dev->max_be != nwpan_dev->max_be ||\n\t\t    wpan_dev->csma_retries != nwpan_dev->csma_retries)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (local->hw.flags & IEEE802154_HW_FRAME_RETRIES) {\n\t\tif (wpan_dev->frame_retries != nwpan_dev->frame_retries)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (local->hw.flags & IEEE802154_HW_LBT) {\n\t\tif (wpan_dev->lbt != nwpan_dev->lbt)\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nieee802154_check_concurrent_iface(struct ieee802154_sub_if_data *sdata,\n\t\t\t\t  enum nl802154_iftype iftype)\n{\n\tstruct ieee802154_local *local = sdata->local;\n\tstruct ieee802154_sub_if_data *nsdata;\n\n\t \n\tlist_for_each_entry(nsdata, &local->interfaces, list) {\n\t\tif (nsdata != sdata && ieee802154_sdata_running(nsdata)) {\n\t\t\tint ret;\n\n\t\t\t \n\t\t\tif (sdata->wpan_dev.iftype != NL802154_IFTYPE_MONITOR &&\n\t\t\t    nsdata->wpan_dev.iftype != NL802154_IFTYPE_MONITOR)\n\t\t\t\treturn -EBUSY;\n\n\t\t\t \n\t\t\tret = ieee802154_check_mac_settings(local, sdata, nsdata);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mac802154_wpan_open(struct net_device *dev)\n{\n\tint rc;\n\tstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\n\tstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\n\n\trc = ieee802154_check_concurrent_iface(sdata, wpan_dev->iftype);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn mac802154_slave_open(dev);\n}\n\nstatic int mac802154_slave_close(struct net_device *dev)\n{\n\tstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\n\tstruct ieee802154_local *local = sdata->local;\n\n\tASSERT_RTNL();\n\n\tif (mac802154_is_scanning(local))\n\t\tmac802154_abort_scan_locked(local, sdata);\n\n\tif (mac802154_is_beaconing(local))\n\t\tmac802154_stop_beacons_locked(local, sdata);\n\n\tnetif_stop_queue(dev);\n\tlocal->open_count--;\n\n\tclear_bit(SDATA_STATE_RUNNING, &sdata->state);\n\n\tif (!local->open_count)\n\t\tieee802154_stop_device(local);\n\n\treturn 0;\n}\n\nstatic int mac802154_set_header_security(struct ieee802154_sub_if_data *sdata,\n\t\t\t\t\t struct ieee802154_hdr *hdr,\n\t\t\t\t\t const struct ieee802154_mac_cb *cb)\n{\n\tstruct ieee802154_llsec_params params;\n\tu8 level;\n\n\tmac802154_llsec_get_params(&sdata->sec, &params);\n\n\tif (!params.enabled && cb->secen_override && cb->secen)\n\t\treturn -EINVAL;\n\tif (!params.enabled ||\n\t    (cb->secen_override && !cb->secen) ||\n\t    !params.out_level)\n\t\treturn 0;\n\tif (cb->seclevel_override && !cb->seclevel)\n\t\treturn -EINVAL;\n\n\tlevel = cb->seclevel_override ? cb->seclevel : params.out_level;\n\n\thdr->fc.security_enabled = 1;\n\thdr->sec.level = level;\n\thdr->sec.key_id_mode = params.out_key.mode;\n\tif (params.out_key.mode == IEEE802154_SCF_KEY_SHORT_INDEX)\n\t\thdr->sec.short_src = params.out_key.short_source;\n\telse if (params.out_key.mode == IEEE802154_SCF_KEY_HW_INDEX)\n\t\thdr->sec.extended_src = params.out_key.extended_source;\n\thdr->sec.key_id = params.out_key.id;\n\n\treturn 0;\n}\n\nstatic int ieee802154_header_create(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    const struct ieee802154_addr *daddr,\n\t\t\t\t    const struct ieee802154_addr *saddr,\n\t\t\t\t    unsigned len)\n{\n\tstruct ieee802154_hdr hdr;\n\tstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\n\tstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\n\tstruct ieee802154_mac_cb *cb = mac_cb(skb);\n\tint hlen;\n\n\tif (!daddr)\n\t\treturn -EINVAL;\n\n\tmemset(&hdr.fc, 0, sizeof(hdr.fc));\n\thdr.fc.type = cb->type;\n\thdr.fc.security_enabled = cb->secen;\n\thdr.fc.ack_request = cb->ackreq;\n\thdr.seq = atomic_inc_return(&dev->ieee802154_ptr->dsn) & 0xFF;\n\n\tif (mac802154_set_header_security(sdata, &hdr, cb) < 0)\n\t\treturn -EINVAL;\n\n\tif (!saddr) {\n\t\tif (wpan_dev->short_addr == cpu_to_le16(IEEE802154_ADDR_BROADCAST) ||\n\t\t    wpan_dev->short_addr == cpu_to_le16(IEEE802154_ADDR_UNDEF) ||\n\t\t    wpan_dev->pan_id == cpu_to_le16(IEEE802154_PANID_BROADCAST)) {\n\t\t\thdr.source.mode = IEEE802154_ADDR_LONG;\n\t\t\thdr.source.extended_addr = wpan_dev->extended_addr;\n\t\t} else {\n\t\t\thdr.source.mode = IEEE802154_ADDR_SHORT;\n\t\t\thdr.source.short_addr = wpan_dev->short_addr;\n\t\t}\n\n\t\thdr.source.pan_id = wpan_dev->pan_id;\n\t} else {\n\t\thdr.source = *(const struct ieee802154_addr *)saddr;\n\t}\n\n\thdr.dest = *(const struct ieee802154_addr *)daddr;\n\n\thlen = ieee802154_hdr_push(skb, &hdr);\n\tif (hlen < 0)\n\t\treturn -EINVAL;\n\n\tskb_reset_mac_header(skb);\n\tskb->mac_len = hlen;\n\n\tif (len > ieee802154_max_payload(&hdr))\n\t\treturn -EMSGSIZE;\n\n\treturn hlen;\n}\n\nstatic const struct wpan_dev_header_ops ieee802154_header_ops = {\n\t.create\t\t= ieee802154_header_create,\n};\n\n \nstatic int mac802154_header_create(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   unsigned short type,\n\t\t\t\t   const void *daddr,\n\t\t\t\t   const void *saddr,\n\t\t\t\t   unsigned len)\n{\n\tstruct ieee802154_hdr hdr;\n\tstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\n\tstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\n\tstruct ieee802154_mac_cb cb = { };\n\tint hlen;\n\n\tif (!daddr)\n\t\treturn -EINVAL;\n\n\tmemset(&hdr.fc, 0, sizeof(hdr.fc));\n\thdr.fc.type = IEEE802154_FC_TYPE_DATA;\n\thdr.fc.ack_request = wpan_dev->ackreq;\n\thdr.seq = atomic_inc_return(&dev->ieee802154_ptr->dsn) & 0xFF;\n\n\t \n\tif (mac802154_set_header_security(sdata, &hdr, &cb) < 0)\n\t\treturn -EINVAL;\n\n\thdr.dest.pan_id = wpan_dev->pan_id;\n\thdr.dest.mode = IEEE802154_ADDR_LONG;\n\tieee802154_be64_to_le64(&hdr.dest.extended_addr, daddr);\n\n\thdr.source.pan_id = hdr.dest.pan_id;\n\thdr.source.mode = IEEE802154_ADDR_LONG;\n\n\tif (!saddr)\n\t\thdr.source.extended_addr = wpan_dev->extended_addr;\n\telse\n\t\tieee802154_be64_to_le64(&hdr.source.extended_addr, saddr);\n\n\thlen = ieee802154_hdr_push(skb, &hdr);\n\tif (hlen < 0)\n\t\treturn -EINVAL;\n\n\tskb_reset_mac_header(skb);\n\tskb->mac_len = hlen;\n\n\tif (len > ieee802154_max_payload(&hdr))\n\t\treturn -EMSGSIZE;\n\n\treturn hlen;\n}\n\nstatic int\nmac802154_header_parse(const struct sk_buff *skb, unsigned char *haddr)\n{\n\tstruct ieee802154_hdr hdr;\n\n\tif (ieee802154_hdr_peek_addrs(skb, &hdr) < 0) {\n\t\tpr_debug(\"malformed packet\\n\");\n\t\treturn 0;\n\t}\n\n\tif (hdr.source.mode == IEEE802154_ADDR_LONG) {\n\t\tieee802154_le64_to_be64(haddr, &hdr.source.extended_addr);\n\t\treturn IEEE802154_EXTENDED_ADDR_LEN;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct header_ops mac802154_header_ops = {\n\t.create         = mac802154_header_create,\n\t.parse          = mac802154_header_parse,\n};\n\nstatic const struct net_device_ops mac802154_wpan_ops = {\n\t.ndo_open\t\t= mac802154_wpan_open,\n\t.ndo_stop\t\t= mac802154_slave_close,\n\t.ndo_start_xmit\t\t= ieee802154_subif_start_xmit,\n\t.ndo_do_ioctl\t\t= mac802154_wpan_ioctl,\n\t.ndo_set_mac_address\t= mac802154_wpan_mac_addr,\n};\n\nstatic const struct net_device_ops mac802154_monitor_ops = {\n\t.ndo_open\t\t= mac802154_wpan_open,\n\t.ndo_stop\t\t= mac802154_slave_close,\n\t.ndo_start_xmit\t\t= ieee802154_monitor_start_xmit,\n};\n\nstatic void mac802154_wpan_free(struct net_device *dev)\n{\n\tstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\n\n\tmac802154_llsec_destroy(&sdata->sec);\n}\n\nstatic void ieee802154_if_setup(struct net_device *dev)\n{\n\tdev->addr_len\t\t= IEEE802154_EXTENDED_ADDR_LEN;\n\tmemset(dev->broadcast, 0xff, IEEE802154_EXTENDED_ADDR_LEN);\n\n\t \n\tdev->hard_header_len\t= IEEE802154_MIN_HEADER_LEN - 1;\n\t \n\tdev->needed_tailroom\t= IEEE802154_MAX_AUTH_TAG_LEN +\n\t\t\t\t  IEEE802154_FCS_LEN;\n\t \n\tdev->mtu\t\t= IEEE802154_MTU - IEEE802154_FCS_LEN -\n\t\t\t\t  dev->hard_header_len;\n\tdev->tx_queue_len\t= 300;\n\tdev->flags\t\t= IFF_NOARP | IFF_BROADCAST;\n}\n\nstatic int\nieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,\n\t\t       enum nl802154_iftype type)\n{\n\tstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\n\tint ret;\n\tu8 tmp;\n\n\t \n\tsdata->wpan_dev.iftype = type;\n\n\tget_random_bytes(&tmp, sizeof(tmp));\n\tatomic_set(&wpan_dev->bsn, tmp);\n\tget_random_bytes(&tmp, sizeof(tmp));\n\tatomic_set(&wpan_dev->dsn, tmp);\n\n\t \n\twpan_dev->min_be = 3;\n\twpan_dev->max_be = 5;\n\twpan_dev->csma_retries = 4;\n\twpan_dev->frame_retries = 3;\n\n\twpan_dev->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);\n\twpan_dev->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);\n\n\tswitch (type) {\n\tcase NL802154_IFTYPE_COORD:\n\tcase NL802154_IFTYPE_NODE:\n\t\tieee802154_be64_to_le64(&wpan_dev->extended_addr,\n\t\t\t\t\tsdata->dev->dev_addr);\n\n\t\tsdata->dev->header_ops = &mac802154_header_ops;\n\t\tsdata->dev->needs_free_netdev = true;\n\t\tsdata->dev->priv_destructor = mac802154_wpan_free;\n\t\tsdata->dev->netdev_ops = &mac802154_wpan_ops;\n\t\tsdata->dev->ml_priv = &mac802154_mlme_wpan;\n\t\tsdata->iface_default_filtering = IEEE802154_FILTERING_4_FRAME_FIELDS;\n\t\twpan_dev->header_ops = &ieee802154_header_ops;\n\n\t\tmutex_init(&sdata->sec_mtx);\n\n\t\tmac802154_llsec_init(&sdata->sec);\n\t\tret = mac802154_wpan_update_llsec(sdata->dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tcase NL802154_IFTYPE_MONITOR:\n\t\tsdata->dev->needs_free_netdev = true;\n\t\tsdata->dev->netdev_ops = &mac802154_monitor_ops;\n\t\tsdata->iface_default_filtering = IEEE802154_FILTERING_NONE;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn 0;\n}\n\nstruct net_device *\nieee802154_if_add(struct ieee802154_local *local, const char *name,\n\t\t  unsigned char name_assign_type, enum nl802154_iftype type,\n\t\t  __le64 extended_addr)\n{\n\tu8 addr[IEEE802154_EXTENDED_ADDR_LEN];\n\tstruct net_device *ndev = NULL;\n\tstruct ieee802154_sub_if_data *sdata = NULL;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tndev = alloc_netdev(sizeof(*sdata), name,\n\t\t\t    name_assign_type, ieee802154_if_setup);\n\tif (!ndev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tndev->needed_headroom = local->hw.extra_tx_headroom +\n\t\t\t\tIEEE802154_MAX_HEADER_LEN;\n\n\tret = dev_alloc_name(ndev, ndev->name);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tieee802154_le64_to_be64(ndev->perm_addr,\n\t\t\t\t&local->hw.phy->perm_extended_addr);\n\tswitch (type) {\n\tcase NL802154_IFTYPE_COORD:\n\tcase NL802154_IFTYPE_NODE:\n\t\tndev->type = ARPHRD_IEEE802154;\n\t\tif (ieee802154_is_valid_extended_unicast_addr(extended_addr)) {\n\t\t\tieee802154_le64_to_be64(addr, &extended_addr);\n\t\t\tdev_addr_set(ndev, addr);\n\t\t} else {\n\t\t\tdev_addr_set(ndev, ndev->perm_addr);\n\t\t}\n\t\tbreak;\n\tcase NL802154_IFTYPE_MONITOR:\n\t\tndev->type = ARPHRD_IEEE802154_MONITOR;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tSET_NETDEV_DEV(ndev, &local->phy->dev);\n\tdev_net_set(ndev, wpan_phy_net(local->hw.phy));\n\tsdata = netdev_priv(ndev);\n\tndev->ieee802154_ptr = &sdata->wpan_dev;\n\tmemcpy(sdata->name, ndev->name, IFNAMSIZ);\n\tsdata->dev = ndev;\n\tsdata->wpan_dev.wpan_phy = local->hw.phy;\n\tsdata->local = local;\n\tINIT_LIST_HEAD(&sdata->wpan_dev.list);\n\n\t \n\tret = ieee802154_setup_sdata(sdata, type);\n\tif (ret)\n\t\tgoto err;\n\n\tret = register_netdevice(ndev);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_add_tail_rcu(&sdata->list, &local->interfaces);\n\tmutex_unlock(&local->iflist_mtx);\n\n\treturn ndev;\n\nerr:\n\tfree_netdev(ndev);\n\treturn ERR_PTR(ret);\n}\n\nvoid ieee802154_if_remove(struct ieee802154_sub_if_data *sdata)\n{\n\tASSERT_RTNL();\n\n\tmutex_lock(&sdata->local->iflist_mtx);\n\tlist_del_rcu(&sdata->list);\n\tmutex_unlock(&sdata->local->iflist_mtx);\n\n\tsynchronize_rcu();\n\tunregister_netdevice(sdata->dev);\n}\n\nvoid ieee802154_remove_interfaces(struct ieee802154_local *local)\n{\n\tstruct ieee802154_sub_if_data *sdata, *tmp;\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_for_each_entry_safe(sdata, tmp, &local->interfaces, list) {\n\t\tlist_del(&sdata->list);\n\n\t\tunregister_netdevice(sdata->dev);\n\t}\n\tmutex_unlock(&local->iflist_mtx);\n}\n\nstatic int netdev_notify(struct notifier_block *nb,\n\t\t\t unsigned long state, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct ieee802154_sub_if_data *sdata;\n\n\tif (state != NETDEV_CHANGENAME)\n\t\treturn NOTIFY_DONE;\n\n\tif (!dev->ieee802154_ptr || !dev->ieee802154_ptr->wpan_phy)\n\t\treturn NOTIFY_DONE;\n\n\tif (dev->ieee802154_ptr->wpan_phy->privid != mac802154_wpan_phy_privid)\n\t\treturn NOTIFY_DONE;\n\n\tsdata = IEEE802154_DEV_TO_SUB_IF(dev);\n\tmemcpy(sdata->name, dev->name, IFNAMSIZ);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block mac802154_netdev_notifier = {\n\t.notifier_call = netdev_notify,\n};\n\nint ieee802154_iface_init(void)\n{\n\treturn register_netdevice_notifier(&mac802154_netdev_notifier);\n}\n\nvoid ieee802154_iface_exit(void)\n{\n\tunregister_netdevice_notifier(&mac802154_netdev_notifier);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}