{
  "module_name": "rx.c",
  "hash_id": "bade90c433c1a4e427895f17d429549635854e403e888fedbf9bd12d88247471",
  "original_prompt": "Ingested from linux-6.6.14/net/mac802154/rx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/crc-ccitt.h>\n#include <asm/unaligned.h>\n\n#include <net/mac802154.h>\n#include <net/ieee802154_netdev.h>\n#include <net/nl802154.h>\n\n#include \"ieee802154_i.h\"\n\nstatic int ieee802154_deliver_skb(struct sk_buff *skb)\n{\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->protocol = htons(ETH_P_IEEE802154);\n\n\treturn netif_receive_skb(skb);\n}\n\nvoid mac802154_rx_beacon_worker(struct work_struct *work)\n{\n\tstruct ieee802154_local *local =\n\t\tcontainer_of(work, struct ieee802154_local, rx_beacon_work);\n\tstruct cfg802154_mac_pkt *mac_pkt;\n\n\tmac_pkt = list_first_entry_or_null(&local->rx_beacon_list,\n\t\t\t\t\t   struct cfg802154_mac_pkt, node);\n\tif (!mac_pkt)\n\t\treturn;\n\n\tmac802154_process_beacon(local, mac_pkt->skb, mac_pkt->page, mac_pkt->channel);\n\n\tlist_del(&mac_pkt->node);\n\tkfree_skb(mac_pkt->skb);\n\tkfree(mac_pkt);\n}\n\nstatic bool mac802154_should_answer_beacon_req(struct ieee802154_local *local)\n{\n\tstruct cfg802154_beacon_request *beacon_req;\n\tunsigned int interval;\n\n\trcu_read_lock();\n\tbeacon_req = rcu_dereference(local->beacon_req);\n\tif (!beacon_req) {\n\t\trcu_read_unlock();\n\t\treturn false;\n\t}\n\n\tinterval = beacon_req->interval;\n\trcu_read_unlock();\n\n\tif (!mac802154_is_beaconing(local))\n\t\treturn false;\n\n\treturn interval == IEEE802154_ACTIVE_SCAN_DURATION;\n}\n\nvoid mac802154_rx_mac_cmd_worker(struct work_struct *work)\n{\n\tstruct ieee802154_local *local =\n\t\tcontainer_of(work, struct ieee802154_local, rx_mac_cmd_work);\n\tstruct cfg802154_mac_pkt *mac_pkt;\n\tu8 mac_cmd;\n\tint rc;\n\n\tmac_pkt = list_first_entry_or_null(&local->rx_mac_cmd_list,\n\t\t\t\t\t   struct cfg802154_mac_pkt, node);\n\tif (!mac_pkt)\n\t\treturn;\n\n\trc = ieee802154_get_mac_cmd(mac_pkt->skb, &mac_cmd);\n\tif (rc)\n\t\tgoto out;\n\n\tswitch (mac_cmd) {\n\tcase IEEE802154_CMD_BEACON_REQ:\n\t\tdev_dbg(&mac_pkt->sdata->dev->dev, \"processing BEACON REQ\\n\");\n\t\tif (!mac802154_should_answer_beacon_req(local))\n\t\t\tbreak;\n\n\t\tqueue_delayed_work(local->mac_wq, &local->beacon_work, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\tlist_del(&mac_pkt->node);\n\tkfree_skb(mac_pkt->skb);\n\tkfree(mac_pkt);\n}\n\nstatic int\nieee802154_subif_frame(struct ieee802154_sub_if_data *sdata,\n\t\t       struct sk_buff *skb, const struct ieee802154_hdr *hdr)\n{\n\tstruct wpan_phy *wpan_phy = sdata->local->hw.phy;\n\tstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\n\tstruct cfg802154_mac_pkt *mac_pkt;\n\t__le16 span, sshort;\n\tint rc;\n\n\tpr_debug(\"getting packet via slave interface %s\\n\", sdata->dev->name);\n\n\tspan = wpan_dev->pan_id;\n\tsshort = wpan_dev->short_addr;\n\n\t \n\tif (sdata->required_filtering == IEEE802154_FILTERING_3_SCAN &&\n\t    sdata->required_filtering > wpan_phy->filtering) {\n\t\tif (mac_cb(skb)->type != IEEE802154_FC_TYPE_BEACON) {\n\t\t\tdev_dbg(&sdata->dev->dev,\n\t\t\t\t\"drop non-beacon frame (0x%x) during scan\\n\",\n\t\t\t\tmac_cb(skb)->type);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tswitch (mac_cb(skb)->dest.mode) {\n\tcase IEEE802154_ADDR_NONE:\n\t\tif (hdr->source.mode != IEEE802154_ADDR_NONE)\n\t\t\t \n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\telse\n\t\t\t \n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\tbreak;\n\tcase IEEE802154_ADDR_LONG:\n\t\tif (mac_cb(skb)->dest.pan_id != span &&\n\t\t    mac_cb(skb)->dest.pan_id != cpu_to_le16(IEEE802154_PANID_BROADCAST))\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\telse if (mac_cb(skb)->dest.extended_addr == wpan_dev->extended_addr)\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\telse\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tbreak;\n\tcase IEEE802154_ADDR_SHORT:\n\t\tif (mac_cb(skb)->dest.pan_id != span &&\n\t\t    mac_cb(skb)->dest.pan_id != cpu_to_le16(IEEE802154_PANID_BROADCAST))\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\telse if (mac_cb(skb)->dest.short_addr == sshort)\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t\telse if (mac_cb(skb)->dest.short_addr ==\n\t\t\t  cpu_to_le16(IEEE802154_ADDR_BROADCAST))\n\t\t\tskb->pkt_type = PACKET_BROADCAST;\n\t\telse\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"invalid dest mode\\n\");\n\t\tgoto fail;\n\t}\n\n\tskb->dev = sdata->dev;\n\n\t \n\trc = mac802154_llsec_decrypt(&sdata->sec, skb);\n\tif (rc) {\n\t\tpr_debug(\"decryption failed: %i\\n\", rc);\n\t\tgoto fail;\n\t}\n\n\tsdata->dev->stats.rx_packets++;\n\tsdata->dev->stats.rx_bytes += skb->len;\n\n\tswitch (mac_cb(skb)->type) {\n\tcase IEEE802154_FC_TYPE_BEACON:\n\t\tdev_dbg(&sdata->dev->dev, \"BEACON received\\n\");\n\t\tif (!mac802154_is_scanning(sdata->local))\n\t\t\tgoto fail;\n\n\t\tmac_pkt = kzalloc(sizeof(*mac_pkt), GFP_ATOMIC);\n\t\tif (!mac_pkt)\n\t\t\tgoto fail;\n\n\t\tmac_pkt->skb = skb_get(skb);\n\t\tmac_pkt->sdata = sdata;\n\t\tmac_pkt->page = sdata->local->scan_page;\n\t\tmac_pkt->channel = sdata->local->scan_channel;\n\t\tlist_add_tail(&mac_pkt->node, &sdata->local->rx_beacon_list);\n\t\tqueue_work(sdata->local->mac_wq, &sdata->local->rx_beacon_work);\n\t\treturn NET_RX_SUCCESS;\n\n\tcase IEEE802154_FC_TYPE_MAC_CMD:\n\t\tdev_dbg(&sdata->dev->dev, \"MAC COMMAND received\\n\");\n\t\tmac_pkt = kzalloc(sizeof(*mac_pkt), GFP_ATOMIC);\n\t\tif (!mac_pkt)\n\t\t\tgoto fail;\n\n\t\tmac_pkt->skb = skb_get(skb);\n\t\tmac_pkt->sdata = sdata;\n\t\tlist_add_tail(&mac_pkt->node, &sdata->local->rx_mac_cmd_list);\n\t\tqueue_work(sdata->local->mac_wq, &sdata->local->rx_mac_cmd_work);\n\t\treturn NET_RX_SUCCESS;\n\n\tcase IEEE802154_FC_TYPE_ACK:\n\t\tgoto fail;\n\n\tcase IEEE802154_FC_TYPE_DATA:\n\t\treturn ieee802154_deliver_skb(skb);\n\tdefault:\n\t\tpr_warn_ratelimited(\"ieee802154: bad frame received \"\n\t\t\t\t    \"(type = %d)\\n\", mac_cb(skb)->type);\n\t\tgoto fail;\n\t}\n\nfail:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\nstatic void\nieee802154_print_addr(const char *name, const struct ieee802154_addr *addr)\n{\n\tif (addr->mode == IEEE802154_ADDR_NONE) {\n\t\tpr_debug(\"%s not present\\n\", name);\n\t\treturn;\n\t}\n\n\tpr_debug(\"%s PAN ID: %04x\\n\", name, le16_to_cpu(addr->pan_id));\n\tif (addr->mode == IEEE802154_ADDR_SHORT) {\n\t\tpr_debug(\"%s is short: %04x\\n\", name,\n\t\t\t le16_to_cpu(addr->short_addr));\n\t} else {\n\t\tu64 hw = swab64((__force u64)addr->extended_addr);\n\n\t\tpr_debug(\"%s is hardware: %8phC\\n\", name, &hw);\n\t}\n}\n\nstatic int\nieee802154_parse_frame_start(struct sk_buff *skb, struct ieee802154_hdr *hdr)\n{\n\tint hlen;\n\tstruct ieee802154_mac_cb *cb = mac_cb(skb);\n\n\tskb_reset_mac_header(skb);\n\n\thlen = ieee802154_hdr_pull(skb, hdr);\n\tif (hlen < 0)\n\t\treturn -EINVAL;\n\n\tskb->mac_len = hlen;\n\n\tpr_debug(\"fc: %04x dsn: %02x\\n\", le16_to_cpup((__le16 *)&hdr->fc),\n\t\t hdr->seq);\n\n\tcb->type = hdr->fc.type;\n\tcb->ackreq = hdr->fc.ack_request;\n\tcb->secen = hdr->fc.security_enabled;\n\n\tieee802154_print_addr(\"destination\", &hdr->dest);\n\tieee802154_print_addr(\"source\", &hdr->source);\n\n\tcb->source = hdr->source;\n\tcb->dest = hdr->dest;\n\n\tif (hdr->fc.security_enabled) {\n\t\tu64 key;\n\n\t\tpr_debug(\"seclevel %i\\n\", hdr->sec.level);\n\n\t\tswitch (hdr->sec.key_id_mode) {\n\t\tcase IEEE802154_SCF_KEY_IMPLICIT:\n\t\t\tpr_debug(\"implicit key\\n\");\n\t\t\tbreak;\n\n\t\tcase IEEE802154_SCF_KEY_INDEX:\n\t\t\tpr_debug(\"key %02x\\n\", hdr->sec.key_id);\n\t\t\tbreak;\n\n\t\tcase IEEE802154_SCF_KEY_SHORT_INDEX:\n\t\t\tpr_debug(\"key %04x:%04x %02x\\n\",\n\t\t\t\t le32_to_cpu(hdr->sec.short_src) >> 16,\n\t\t\t\t le32_to_cpu(hdr->sec.short_src) & 0xffff,\n\t\t\t\t hdr->sec.key_id);\n\t\t\tbreak;\n\n\t\tcase IEEE802154_SCF_KEY_HW_INDEX:\n\t\t\tkey = swab64((__force u64)hdr->sec.extended_src);\n\t\t\tpr_debug(\"key source %8phC %02x\\n\", &key,\n\t\t\t\t hdr->sec.key_id);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\n__ieee802154_rx_handle_packet(struct ieee802154_local *local,\n\t\t\t      struct sk_buff *skb)\n{\n\tint ret;\n\tstruct ieee802154_sub_if_data *sdata;\n\tstruct ieee802154_hdr hdr;\n\tstruct sk_buff *skb2;\n\n\tret = ieee802154_parse_frame_start(skb, &hdr);\n\tif (ret) {\n\t\tpr_debug(\"got invalid frame\\n\");\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (sdata->wpan_dev.iftype == NL802154_IFTYPE_MONITOR)\n\t\t\tcontinue;\n\n\t\tif (!ieee802154_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (local->hw.phy->filtering < IEEE802154_FILTERING_4_FRAME_FIELDS &&\n\t\t    sdata->required_filtering == IEEE802154_FILTERING_4_FRAME_FIELDS)\n\t\t\tcontinue;\n\n\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (skb2) {\n\t\t\tskb2->dev = sdata->dev;\n\t\t\tieee802154_subif_frame(sdata, skb2, &hdr);\n\t\t}\n\t}\n}\n\nstatic void\nieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)\n{\n\tstruct sk_buff *skb2;\n\tstruct ieee802154_sub_if_data *sdata;\n\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_IEEE802154);\n\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (sdata->wpan_dev.iftype != NL802154_IFTYPE_MONITOR)\n\t\t\tcontinue;\n\n\t\tif (!ieee802154_sdata_running(sdata))\n\t\t\tcontinue;\n\n\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (skb2) {\n\t\t\tskb2->dev = sdata->dev;\n\t\t\tieee802154_deliver_skb(skb2);\n\n\t\t\tsdata->dev->stats.rx_packets++;\n\t\t\tsdata->dev->stats.rx_bytes += skb->len;\n\t\t}\n\t}\n}\n\nvoid ieee802154_rx(struct ieee802154_local *local, struct sk_buff *skb)\n{\n\tu16 crc;\n\n\tWARN_ON_ONCE(softirq_count() == 0);\n\n\tif (local->suspended)\n\t\tgoto free_skb;\n\n\t \n\tif (local->hw.flags & IEEE802154_HW_RX_OMIT_CKSUM) {\n\t\tcrc = crc_ccitt(0, skb->data, skb->len);\n\t\tput_unaligned_le16(crc, skb_put(skb, 2));\n\t}\n\n\trcu_read_lock();\n\n\tieee802154_monitors_rx(local, skb);\n\n\t \n\tif (local->hw.phy->filtering == IEEE802154_FILTERING_NONE) {\n\t\tcrc = crc_ccitt(0, skb->data, skb->len);\n\t\tif (crc)\n\t\t\tgoto drop;\n\t}\n\t \n\tskb_trim(skb, skb->len - 2);\n\n\t__ieee802154_rx_handle_packet(local, skb);\n\ndrop:\n\trcu_read_unlock();\nfree_skb:\n\tkfree_skb(skb);\n}\n\nvoid\nieee802154_rx_irqsafe(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)\n{\n\tstruct ieee802154_local *local = hw_to_local(hw);\n\tstruct ieee802154_mac_cb *cb = mac_cb_init(skb);\n\n\tcb->lqi = lqi;\n\tskb->pkt_type = IEEE802154_RX_MSG;\n\tskb_queue_tail(&local->skb_queue, skb);\n\ttasklet_schedule(&local->tasklet);\n}\nEXPORT_SYMBOL(ieee802154_rx_irqsafe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}