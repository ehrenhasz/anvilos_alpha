{
  "module_name": "tx.c",
  "hash_id": "65f60be0675272304ae32eb0b6c7d4b16dd55ea99687a0978b7184efc1b5fc65",
  "original_prompt": "Ingested from linux-6.6.14/net/mac802154/tx.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/crc-ccitt.h>\n#include <asm/unaligned.h>\n\n#include <net/rtnetlink.h>\n#include <net/ieee802154_netdev.h>\n#include <net/mac802154.h>\n#include <net/cfg802154.h>\n\n#include \"ieee802154_i.h\"\n#include \"driver-ops.h\"\n\nvoid ieee802154_xmit_sync_worker(struct work_struct *work)\n{\n\tstruct ieee802154_local *local =\n\t\tcontainer_of(work, struct ieee802154_local, sync_tx_work);\n\tstruct sk_buff *skb = local->tx_skb;\n\tstruct net_device *dev = skb->dev;\n\tint res;\n\n\tres = drv_xmit_sync(local, skb);\n\tif (res)\n\t\tgoto err_tx;\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\tieee802154_xmit_complete(&local->hw, skb, false);\n\n\treturn;\n\nerr_tx:\n\t \n\tieee802154_release_queue(local);\n\tif (atomic_dec_and_test(&local->phy->ongoing_txs))\n\t\twake_up(&local->phy->sync_txq);\n\tkfree_skb(skb);\n\tnetdev_dbg(dev, \"transmission failed\\n\");\n}\n\nstatic netdev_tx_t\nieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tint ret;\n\n\tif (!(local->hw.flags & IEEE802154_HW_TX_OMIT_CKSUM)) {\n\t\tstruct sk_buff *nskb;\n\t\tu16 crc;\n\n\t\tif (unlikely(skb_tailroom(skb) < IEEE802154_FCS_LEN)) {\n\t\t\tnskb = skb_copy_expand(skb, 0, IEEE802154_FCS_LEN,\n\t\t\t\t\t       GFP_ATOMIC);\n\t\t\tif (likely(nskb)) {\n\t\t\t\tconsume_skb(skb);\n\t\t\t\tskb = nskb;\n\t\t\t} else {\n\t\t\t\tgoto err_free_skb;\n\t\t\t}\n\t\t}\n\n\t\tcrc = crc_ccitt(0, skb->data, skb->len);\n\t\tput_unaligned_le16(crc, skb_put(skb, 2));\n\t}\n\n\t \n\tieee802154_hold_queue(local);\n\tatomic_inc(&local->phy->ongoing_txs);\n\n\t \n\tif (local->ops->xmit_async) {\n\t\tunsigned int len = skb->len;\n\n\t\tret = drv_xmit_async(local, skb);\n\t\tif (ret)\n\t\t\tgoto err_wake_netif_queue;\n\n\t\tdev->stats.tx_packets++;\n\t\tdev->stats.tx_bytes += len;\n\t} else {\n\t\tlocal->tx_skb = skb;\n\t\tqueue_work(local->workqueue, &local->sync_tx_work);\n\t}\n\n\treturn NETDEV_TX_OK;\n\nerr_wake_netif_queue:\n\tieee802154_release_queue(local);\n\tif (atomic_dec_and_test(&local->phy->ongoing_txs))\n\t\twake_up(&local->phy->sync_txq);\nerr_free_skb:\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ieee802154_sync_queue(struct ieee802154_local *local)\n{\n\tint ret;\n\n\tieee802154_hold_queue(local);\n\tieee802154_disable_queue(local);\n\twait_event(local->phy->sync_txq, !atomic_read(&local->phy->ongoing_txs));\n\tret = local->tx_result;\n\tieee802154_release_queue(local);\n\n\treturn ret;\n}\n\nint ieee802154_sync_and_hold_queue(struct ieee802154_local *local)\n{\n\tint ret;\n\n\tieee802154_hold_queue(local);\n\tret = ieee802154_sync_queue(local);\n\tset_bit(WPAN_PHY_FLAG_STATE_QUEUE_STOPPED, &local->phy->flags);\n\n\treturn ret;\n}\n\nint ieee802154_mlme_op_pre(struct ieee802154_local *local)\n{\n\treturn ieee802154_sync_and_hold_queue(local);\n}\n\nint ieee802154_mlme_tx_locked(struct ieee802154_local *local,\n\t\t\t      struct ieee802154_sub_if_data *sdata,\n\t\t\t      struct sk_buff *skb)\n{\n\t \n\tASSERT_RTNL();\n\n\t \n\tif (!local->open_count)\n\t\treturn -ENETDOWN;\n\n\t \n\tif (WARN_ON_ONCE(!netif_running(sdata->dev)))\n\t\treturn -ENETDOWN;\n\n\tieee802154_tx(local, skb);\n\treturn ieee802154_sync_queue(local);\n}\n\nint ieee802154_mlme_tx(struct ieee802154_local *local,\n\t\t       struct ieee802154_sub_if_data *sdata,\n\t\t       struct sk_buff *skb)\n{\n\tint ret;\n\n\trtnl_lock();\n\tret = ieee802154_mlme_tx_locked(local, sdata, skb);\n\trtnl_unlock();\n\n\treturn ret;\n}\n\nvoid ieee802154_mlme_op_post(struct ieee802154_local *local)\n{\n\tieee802154_release_queue(local);\n}\n\nint ieee802154_mlme_tx_one(struct ieee802154_local *local,\n\t\t\t   struct ieee802154_sub_if_data *sdata,\n\t\t\t   struct sk_buff *skb)\n{\n\tint ret;\n\n\tieee802154_mlme_op_pre(local);\n\tret = ieee802154_mlme_tx(local, sdata, skb);\n\tieee802154_mlme_op_post(local);\n\n\treturn ret;\n}\n\nint ieee802154_mlme_tx_one_locked(struct ieee802154_local *local,\n\t\t\t\t  struct ieee802154_sub_if_data *sdata,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tint ret;\n\n\tieee802154_mlme_op_pre(local);\n\tret = ieee802154_mlme_tx_locked(local, sdata, skb);\n\tieee802154_mlme_op_post(local);\n\n\treturn ret;\n}\n\nstatic bool ieee802154_queue_is_stopped(struct ieee802154_local *local)\n{\n\treturn test_bit(WPAN_PHY_FLAG_STATE_QUEUE_STOPPED, &local->phy->flags);\n}\n\nstatic netdev_tx_t\nieee802154_hot_tx(struct ieee802154_local *local, struct sk_buff *skb)\n{\n\t \n\tWARN_ON_ONCE(ieee802154_queue_is_stopped(local));\n\n\treturn ieee802154_tx(local, skb);\n}\n\nnetdev_tx_t\nieee802154_monitor_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\n\n\tskb->skb_iif = dev->ifindex;\n\n\treturn ieee802154_hot_tx(sdata->local, skb);\n}\n\nnetdev_tx_t\nieee802154_subif_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);\n\tint rc;\n\n\t \n\trc = mac802154_llsec_encrypt(&sdata->sec, skb);\n\tif (rc) {\n\t\tnetdev_warn(dev, \"encryption failed: %i\\n\", rc);\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tskb->skb_iif = dev->ifindex;\n\n\treturn ieee802154_hot_tx(sdata->local, skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}