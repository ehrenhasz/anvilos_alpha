{
  "module_name": "llsec.c",
  "hash_id": "626fb7acbb822f3cb00de95fa34bcc9298a7d5bd1802452bd9ac1c2844312771",
  "original_prompt": "Ingested from linux-6.6.14/net/mac802154/llsec.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/completion.h>\n#include <linux/ieee802154.h>\n#include <linux/rculist.h>\n\n#include <crypto/aead.h>\n#include <crypto/skcipher.h>\n\n#include \"ieee802154_i.h\"\n#include \"llsec.h\"\n\nstatic void llsec_key_put(struct mac802154_llsec_key *key);\nstatic bool llsec_key_id_equal(const struct ieee802154_llsec_key_id *a,\n\t\t\t       const struct ieee802154_llsec_key_id *b);\n\nstatic void llsec_dev_free(struct mac802154_llsec_device *dev);\n\nvoid mac802154_llsec_init(struct mac802154_llsec *sec)\n{\n\tmemset(sec, 0, sizeof(*sec));\n\n\tmemset(&sec->params.default_key_source, 0xFF, IEEE802154_ADDR_LEN);\n\n\tINIT_LIST_HEAD(&sec->table.security_levels);\n\tINIT_LIST_HEAD(&sec->table.devices);\n\tINIT_LIST_HEAD(&sec->table.keys);\n\thash_init(sec->devices_short);\n\thash_init(sec->devices_hw);\n\trwlock_init(&sec->lock);\n}\n\nvoid mac802154_llsec_destroy(struct mac802154_llsec *sec)\n{\n\tstruct ieee802154_llsec_seclevel *sl, *sn;\n\tstruct ieee802154_llsec_device *dev, *dn;\n\tstruct ieee802154_llsec_key_entry *key, *kn;\n\n\tlist_for_each_entry_safe(sl, sn, &sec->table.security_levels, list) {\n\t\tstruct mac802154_llsec_seclevel *msl;\n\n\t\tmsl = container_of(sl, struct mac802154_llsec_seclevel, level);\n\t\tlist_del(&sl->list);\n\t\tkfree_sensitive(msl);\n\t}\n\n\tlist_for_each_entry_safe(dev, dn, &sec->table.devices, list) {\n\t\tstruct mac802154_llsec_device *mdev;\n\n\t\tmdev = container_of(dev, struct mac802154_llsec_device, dev);\n\t\tlist_del(&dev->list);\n\t\tllsec_dev_free(mdev);\n\t}\n\n\tlist_for_each_entry_safe(key, kn, &sec->table.keys, list) {\n\t\tstruct mac802154_llsec_key *mkey;\n\n\t\tmkey = container_of(key->key, struct mac802154_llsec_key, key);\n\t\tlist_del(&key->list);\n\t\tllsec_key_put(mkey);\n\t\tkfree_sensitive(key);\n\t}\n}\n\nint mac802154_llsec_get_params(struct mac802154_llsec *sec,\n\t\t\t       struct ieee802154_llsec_params *params)\n{\n\tread_lock_bh(&sec->lock);\n\t*params = sec->params;\n\tread_unlock_bh(&sec->lock);\n\n\treturn 0;\n}\n\nint mac802154_llsec_set_params(struct mac802154_llsec *sec,\n\t\t\t       const struct ieee802154_llsec_params *params,\n\t\t\t       int changed)\n{\n\twrite_lock_bh(&sec->lock);\n\n\tif (changed & IEEE802154_LLSEC_PARAM_ENABLED)\n\t\tsec->params.enabled = params->enabled;\n\tif (changed & IEEE802154_LLSEC_PARAM_FRAME_COUNTER)\n\t\tsec->params.frame_counter = params->frame_counter;\n\tif (changed & IEEE802154_LLSEC_PARAM_OUT_LEVEL)\n\t\tsec->params.out_level = params->out_level;\n\tif (changed & IEEE802154_LLSEC_PARAM_OUT_KEY)\n\t\tsec->params.out_key = params->out_key;\n\tif (changed & IEEE802154_LLSEC_PARAM_KEY_SOURCE)\n\t\tsec->params.default_key_source = params->default_key_source;\n\tif (changed & IEEE802154_LLSEC_PARAM_PAN_ID)\n\t\tsec->params.pan_id = params->pan_id;\n\tif (changed & IEEE802154_LLSEC_PARAM_HWADDR)\n\t\tsec->params.hwaddr = params->hwaddr;\n\tif (changed & IEEE802154_LLSEC_PARAM_COORD_HWADDR)\n\t\tsec->params.coord_hwaddr = params->coord_hwaddr;\n\tif (changed & IEEE802154_LLSEC_PARAM_COORD_SHORTADDR)\n\t\tsec->params.coord_shortaddr = params->coord_shortaddr;\n\n\twrite_unlock_bh(&sec->lock);\n\n\treturn 0;\n}\n\nstatic struct mac802154_llsec_key*\nllsec_key_alloc(const struct ieee802154_llsec_key *template)\n{\n\tconst int authsizes[3] = { 4, 8, 16 };\n\tstruct mac802154_llsec_key *key;\n\tint i;\n\n\tkey = kzalloc(sizeof(*key), GFP_KERNEL);\n\tif (!key)\n\t\treturn NULL;\n\n\tkref_init(&key->ref);\n\tkey->key = *template;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(authsizes) != ARRAY_SIZE(key->tfm));\n\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++) {\n\t\tkey->tfm[i] = crypto_alloc_aead(\"ccm(aes)\", 0,\n\t\t\t\t\t\tCRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(key->tfm[i]))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setkey(key->tfm[i], template->key,\n\t\t\t\t       IEEE802154_LLSEC_KEY_SIZE))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setauthsize(key->tfm[i], authsizes[i]))\n\t\t\tgoto err_tfm;\n\t}\n\n\tkey->tfm0 = crypto_alloc_sync_skcipher(\"ctr(aes)\", 0, 0);\n\tif (IS_ERR(key->tfm0))\n\t\tgoto err_tfm;\n\n\tif (crypto_sync_skcipher_setkey(key->tfm0, template->key,\n\t\t\t\t   IEEE802154_LLSEC_KEY_SIZE))\n\t\tgoto err_tfm0;\n\n\treturn key;\n\nerr_tfm0:\n\tcrypto_free_sync_skcipher(key->tfm0);\nerr_tfm:\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++)\n\t\tif (!IS_ERR_OR_NULL(key->tfm[i]))\n\t\t\tcrypto_free_aead(key->tfm[i]);\n\n\tkfree_sensitive(key);\n\treturn NULL;\n}\n\nstatic void llsec_key_release(struct kref *ref)\n{\n\tstruct mac802154_llsec_key *key;\n\tint i;\n\n\tkey = container_of(ref, struct mac802154_llsec_key, ref);\n\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++)\n\t\tcrypto_free_aead(key->tfm[i]);\n\n\tcrypto_free_sync_skcipher(key->tfm0);\n\tkfree_sensitive(key);\n}\n\nstatic struct mac802154_llsec_key*\nllsec_key_get(struct mac802154_llsec_key *key)\n{\n\tkref_get(&key->ref);\n\treturn key;\n}\n\nstatic void llsec_key_put(struct mac802154_llsec_key *key)\n{\n\tkref_put(&key->ref, llsec_key_release);\n}\n\nstatic bool llsec_key_id_equal(const struct ieee802154_llsec_key_id *a,\n\t\t\t       const struct ieee802154_llsec_key_id *b)\n{\n\tif (a->mode != b->mode)\n\t\treturn false;\n\n\tif (a->mode == IEEE802154_SCF_KEY_IMPLICIT)\n\t\treturn ieee802154_addr_equal(&a->device_addr, &b->device_addr);\n\n\tif (a->id != b->id)\n\t\treturn false;\n\n\tswitch (a->mode) {\n\tcase IEEE802154_SCF_KEY_INDEX:\n\t\treturn true;\n\tcase IEEE802154_SCF_KEY_SHORT_INDEX:\n\t\treturn a->short_source == b->short_source;\n\tcase IEEE802154_SCF_KEY_HW_INDEX:\n\t\treturn a->extended_source == b->extended_source;\n\t}\n\n\treturn false;\n}\n\nint mac802154_llsec_key_add(struct mac802154_llsec *sec,\n\t\t\t    const struct ieee802154_llsec_key_id *id,\n\t\t\t    const struct ieee802154_llsec_key *key)\n{\n\tstruct mac802154_llsec_key *mkey = NULL;\n\tstruct ieee802154_llsec_key_entry *pos, *new;\n\n\tif (!(key->frame_types & (1 << IEEE802154_FC_TYPE_MAC_CMD)) &&\n\t    key->cmd_frame_ids)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(pos, &sec->table.keys, list) {\n\t\tif (llsec_key_id_equal(&pos->id, id))\n\t\t\treturn -EEXIST;\n\n\t\tif (memcmp(pos->key->key, key->key,\n\t\t\t   IEEE802154_LLSEC_KEY_SIZE))\n\t\t\tcontinue;\n\n\t\tmkey = container_of(pos->key, struct mac802154_llsec_key, key);\n\n\t\t \n\t\tif (pos->key->frame_types != key->frame_types ||\n\t\t    pos->key->cmd_frame_ids != key->cmd_frame_ids)\n\t\t\treturn -EEXIST;\n\n\t\tbreak;\n\t}\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tif (!mkey)\n\t\tmkey = llsec_key_alloc(key);\n\telse\n\t\tmkey = llsec_key_get(mkey);\n\n\tif (!mkey)\n\t\tgoto fail;\n\n\tnew->id = *id;\n\tnew->key = &mkey->key;\n\n\tlist_add_rcu(&new->list, &sec->table.keys);\n\n\treturn 0;\n\nfail:\n\tkfree_sensitive(new);\n\treturn -ENOMEM;\n}\n\nint mac802154_llsec_key_del(struct mac802154_llsec *sec,\n\t\t\t    const struct ieee802154_llsec_key_id *key)\n{\n\tstruct ieee802154_llsec_key_entry *pos;\n\n\tlist_for_each_entry(pos, &sec->table.keys, list) {\n\t\tstruct mac802154_llsec_key *mkey;\n\n\t\tmkey = container_of(pos->key, struct mac802154_llsec_key, key);\n\n\t\tif (llsec_key_id_equal(&pos->id, key)) {\n\t\t\tlist_del_rcu(&pos->list);\n\t\t\tllsec_key_put(mkey);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic bool llsec_dev_use_shortaddr(__le16 short_addr)\n{\n\treturn short_addr != cpu_to_le16(IEEE802154_ADDR_UNDEF) &&\n\t\tshort_addr != cpu_to_le16(0xffff);\n}\n\nstatic u32 llsec_dev_hash_short(__le16 short_addr, __le16 pan_id)\n{\n\treturn ((__force u16)short_addr) << 16 | (__force u16)pan_id;\n}\n\nstatic u64 llsec_dev_hash_long(__le64 hwaddr)\n{\n\treturn (__force u64)hwaddr;\n}\n\nstatic struct mac802154_llsec_device*\nllsec_dev_find_short(struct mac802154_llsec *sec, __le16 short_addr,\n\t\t     __le16 pan_id)\n{\n\tstruct mac802154_llsec_device *dev;\n\tu32 key = llsec_dev_hash_short(short_addr, pan_id);\n\n\thash_for_each_possible_rcu(sec->devices_short, dev, bucket_s, key) {\n\t\tif (dev->dev.short_addr == short_addr &&\n\t\t    dev->dev.pan_id == pan_id)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mac802154_llsec_device*\nllsec_dev_find_long(struct mac802154_llsec *sec, __le64 hwaddr)\n{\n\tstruct mac802154_llsec_device *dev;\n\tu64 key = llsec_dev_hash_long(hwaddr);\n\n\thash_for_each_possible_rcu(sec->devices_hw, dev, bucket_hw, key) {\n\t\tif (dev->dev.hwaddr == hwaddr)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\nstatic void llsec_dev_free(struct mac802154_llsec_device *dev)\n{\n\tstruct ieee802154_llsec_device_key *pos, *pn;\n\tstruct mac802154_llsec_device_key *devkey;\n\n\tlist_for_each_entry_safe(pos, pn, &dev->dev.keys, list) {\n\t\tdevkey = container_of(pos, struct mac802154_llsec_device_key,\n\t\t\t\t      devkey);\n\n\t\tlist_del(&pos->list);\n\t\tkfree_sensitive(devkey);\n\t}\n\n\tkfree_sensitive(dev);\n}\n\nint mac802154_llsec_dev_add(struct mac802154_llsec *sec,\n\t\t\t    const struct ieee802154_llsec_device *dev)\n{\n\tstruct mac802154_llsec_device *entry;\n\tu32 skey = llsec_dev_hash_short(dev->short_addr, dev->pan_id);\n\tu64 hwkey = llsec_dev_hash_long(dev->hwaddr);\n\n\tBUILD_BUG_ON(sizeof(hwkey) != IEEE802154_ADDR_LEN);\n\n\tif ((llsec_dev_use_shortaddr(dev->short_addr) &&\n\t     llsec_dev_find_short(sec, dev->short_addr, dev->pan_id)) ||\n\t     llsec_dev_find_long(sec, dev->hwaddr))\n\t\treturn -EEXIST;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->dev = *dev;\n\tspin_lock_init(&entry->lock);\n\tINIT_LIST_HEAD(&entry->dev.keys);\n\n\tif (llsec_dev_use_shortaddr(dev->short_addr))\n\t\thash_add_rcu(sec->devices_short, &entry->bucket_s, skey);\n\telse\n\t\tINIT_HLIST_NODE(&entry->bucket_s);\n\n\thash_add_rcu(sec->devices_hw, &entry->bucket_hw, hwkey);\n\tlist_add_tail_rcu(&entry->dev.list, &sec->table.devices);\n\n\treturn 0;\n}\n\nstatic void llsec_dev_free_rcu(struct rcu_head *rcu)\n{\n\tllsec_dev_free(container_of(rcu, struct mac802154_llsec_device, rcu));\n}\n\nint mac802154_llsec_dev_del(struct mac802154_llsec *sec, __le64 device_addr)\n{\n\tstruct mac802154_llsec_device *pos;\n\n\tpos = llsec_dev_find_long(sec, device_addr);\n\tif (!pos)\n\t\treturn -ENOENT;\n\n\thash_del_rcu(&pos->bucket_s);\n\thash_del_rcu(&pos->bucket_hw);\n\tlist_del_rcu(&pos->dev.list);\n\tcall_rcu(&pos->rcu, llsec_dev_free_rcu);\n\n\treturn 0;\n}\n\nstatic struct mac802154_llsec_device_key*\nllsec_devkey_find(struct mac802154_llsec_device *dev,\n\t\t  const struct ieee802154_llsec_key_id *key)\n{\n\tstruct ieee802154_llsec_device_key *devkey;\n\n\tlist_for_each_entry_rcu(devkey, &dev->dev.keys, list) {\n\t\tif (!llsec_key_id_equal(key, &devkey->key_id))\n\t\t\tcontinue;\n\n\t\treturn container_of(devkey, struct mac802154_llsec_device_key,\n\t\t\t\t    devkey);\n\t}\n\n\treturn NULL;\n}\n\nint mac802154_llsec_devkey_add(struct mac802154_llsec *sec,\n\t\t\t       __le64 dev_addr,\n\t\t\t       const struct ieee802154_llsec_device_key *key)\n{\n\tstruct mac802154_llsec_device *dev;\n\tstruct mac802154_llsec_device_key *devkey;\n\n\tdev = llsec_dev_find_long(sec, dev_addr);\n\n\tif (!dev)\n\t\treturn -ENOENT;\n\n\tif (llsec_devkey_find(dev, &key->key_id))\n\t\treturn -EEXIST;\n\n\tdevkey = kmalloc(sizeof(*devkey), GFP_KERNEL);\n\tif (!devkey)\n\t\treturn -ENOMEM;\n\n\tdevkey->devkey = *key;\n\tlist_add_tail_rcu(&devkey->devkey.list, &dev->dev.keys);\n\treturn 0;\n}\n\nint mac802154_llsec_devkey_del(struct mac802154_llsec *sec,\n\t\t\t       __le64 dev_addr,\n\t\t\t       const struct ieee802154_llsec_device_key *key)\n{\n\tstruct mac802154_llsec_device *dev;\n\tstruct mac802154_llsec_device_key *devkey;\n\n\tdev = llsec_dev_find_long(sec, dev_addr);\n\n\tif (!dev)\n\t\treturn -ENOENT;\n\n\tdevkey = llsec_devkey_find(dev, &key->key_id);\n\tif (!devkey)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&devkey->devkey.list);\n\tkfree_rcu(devkey, rcu);\n\treturn 0;\n}\n\nstatic struct mac802154_llsec_seclevel*\nllsec_find_seclevel(const struct mac802154_llsec *sec,\n\t\t    const struct ieee802154_llsec_seclevel *sl)\n{\n\tstruct ieee802154_llsec_seclevel *pos;\n\n\tlist_for_each_entry(pos, &sec->table.security_levels, list) {\n\t\tif (pos->frame_type != sl->frame_type ||\n\t\t    (pos->frame_type == IEEE802154_FC_TYPE_MAC_CMD &&\n\t\t     pos->cmd_frame_id != sl->cmd_frame_id) ||\n\t\t    pos->device_override != sl->device_override ||\n\t\t    pos->sec_levels != sl->sec_levels)\n\t\t\tcontinue;\n\n\t\treturn container_of(pos, struct mac802154_llsec_seclevel,\n\t\t\t\t    level);\n\t}\n\n\treturn NULL;\n}\n\nint mac802154_llsec_seclevel_add(struct mac802154_llsec *sec,\n\t\t\t\t const struct ieee802154_llsec_seclevel *sl)\n{\n\tstruct mac802154_llsec_seclevel *entry;\n\n\tif (llsec_find_seclevel(sec, sl))\n\t\treturn -EEXIST;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->level = *sl;\n\n\tlist_add_tail_rcu(&entry->level.list, &sec->table.security_levels);\n\n\treturn 0;\n}\n\nint mac802154_llsec_seclevel_del(struct mac802154_llsec *sec,\n\t\t\t\t const struct ieee802154_llsec_seclevel *sl)\n{\n\tstruct mac802154_llsec_seclevel *pos;\n\n\tpos = llsec_find_seclevel(sec, sl);\n\tif (!pos)\n\t\treturn -ENOENT;\n\n\tlist_del_rcu(&pos->level.list);\n\tkfree_rcu(pos, rcu);\n\n\treturn 0;\n}\n\nstatic int llsec_recover_addr(struct mac802154_llsec *sec,\n\t\t\t      struct ieee802154_addr *addr)\n{\n\t__le16 caddr = sec->params.coord_shortaddr;\n\n\taddr->pan_id = sec->params.pan_id;\n\n\tif (caddr == cpu_to_le16(IEEE802154_ADDR_BROADCAST)) {\n\t\treturn -EINVAL;\n\t} else if (caddr == cpu_to_le16(IEEE802154_ADDR_UNDEF)) {\n\t\taddr->extended_addr = sec->params.coord_hwaddr;\n\t\taddr->mode = IEEE802154_ADDR_LONG;\n\t} else {\n\t\taddr->short_addr = sec->params.coord_shortaddr;\n\t\taddr->mode = IEEE802154_ADDR_SHORT;\n\t}\n\n\treturn 0;\n}\n\nstatic struct mac802154_llsec_key*\nllsec_lookup_key(struct mac802154_llsec *sec,\n\t\t const struct ieee802154_hdr *hdr,\n\t\t const struct ieee802154_addr *addr,\n\t\t struct ieee802154_llsec_key_id *key_id)\n{\n\tstruct ieee802154_addr devaddr = *addr;\n\tu8 key_id_mode = hdr->sec.key_id_mode;\n\tstruct ieee802154_llsec_key_entry *key_entry;\n\tstruct mac802154_llsec_key *key;\n\n\tif (key_id_mode == IEEE802154_SCF_KEY_IMPLICIT &&\n\t    devaddr.mode == IEEE802154_ADDR_NONE) {\n\t\tif (hdr->fc.type == IEEE802154_FC_TYPE_BEACON) {\n\t\t\tdevaddr.extended_addr = sec->params.coord_hwaddr;\n\t\t\tdevaddr.mode = IEEE802154_ADDR_LONG;\n\t\t} else if (llsec_recover_addr(sec, &devaddr) < 0) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tlist_for_each_entry_rcu(key_entry, &sec->table.keys, list) {\n\t\tconst struct ieee802154_llsec_key_id *id = &key_entry->id;\n\n\t\tif (!(key_entry->key->frame_types & BIT(hdr->fc.type)))\n\t\t\tcontinue;\n\n\t\tif (id->mode != key_id_mode)\n\t\t\tcontinue;\n\n\t\tif (key_id_mode == IEEE802154_SCF_KEY_IMPLICIT) {\n\t\t\tif (ieee802154_addr_equal(&devaddr, &id->device_addr))\n\t\t\t\tgoto found;\n\t\t} else {\n\t\t\tif (id->id != hdr->sec.key_id)\n\t\t\t\tcontinue;\n\n\t\t\tif ((key_id_mode == IEEE802154_SCF_KEY_INDEX) ||\n\t\t\t    (key_id_mode == IEEE802154_SCF_KEY_SHORT_INDEX &&\n\t\t\t     id->short_source == hdr->sec.short_src) ||\n\t\t\t    (key_id_mode == IEEE802154_SCF_KEY_HW_INDEX &&\n\t\t\t     id->extended_source == hdr->sec.extended_src))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n\treturn NULL;\n\nfound:\n\tkey = container_of(key_entry->key, struct mac802154_llsec_key, key);\n\tif (key_id)\n\t\t*key_id = key_entry->id;\n\treturn llsec_key_get(key);\n}\n\nstatic void llsec_geniv(u8 iv[16], __le64 addr,\n\t\t\tconst struct ieee802154_sechdr *sec)\n{\n\t__be64 addr_bytes = (__force __be64) swab64((__force u64) addr);\n\t__be32 frame_counter = (__force __be32) swab32((__force u32) sec->frame_counter);\n\n\tiv[0] = 1;  \n\tmemcpy(iv + 1, &addr_bytes, sizeof(addr_bytes));\n\tmemcpy(iv + 9, &frame_counter, sizeof(frame_counter));\n\tiv[13] = sec->level;\n\tiv[14] = 0;\n\tiv[15] = 1;\n}\n\nstatic int\nllsec_do_encrypt_unauth(struct sk_buff *skb, const struct mac802154_llsec *sec,\n\t\t\tconst struct ieee802154_hdr *hdr,\n\t\t\tstruct mac802154_llsec_key *key)\n{\n\tu8 iv[16];\n\tstruct scatterlist src;\n\tSYNC_SKCIPHER_REQUEST_ON_STACK(req, key->tfm0);\n\tint err, datalen;\n\tunsigned char *data;\n\n\tllsec_geniv(iv, sec->params.hwaddr, &hdr->sec);\n\t \n\tdata = skb_mac_header(skb) + skb->mac_len;\n\tdatalen = skb_tail_pointer(skb) - data;\n\tsg_init_one(&src, data, datalen);\n\n\tskcipher_request_set_sync_tfm(req, key->tfm0);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &src, &src, datalen, iv);\n\terr = crypto_skcipher_encrypt(req);\n\tskcipher_request_zero(req);\n\treturn err;\n}\n\nstatic struct crypto_aead*\nllsec_tfm_by_len(struct mac802154_llsec_key *key, int authlen)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++)\n\t\tif (crypto_aead_authsize(key->tfm[i]) == authlen)\n\t\t\treturn key->tfm[i];\n\n\tBUG();\n}\n\nstatic int\nllsec_do_encrypt_auth(struct sk_buff *skb, const struct mac802154_llsec *sec,\n\t\t      const struct ieee802154_hdr *hdr,\n\t\t      struct mac802154_llsec_key *key)\n{\n\tu8 iv[16];\n\tunsigned char *data;\n\tint authlen, assoclen, datalen, rc;\n\tstruct scatterlist sg;\n\tstruct aead_request *req;\n\n\tauthlen = ieee802154_sechdr_authtag_len(&hdr->sec);\n\tllsec_geniv(iv, sec->params.hwaddr, &hdr->sec);\n\n\treq = aead_request_alloc(llsec_tfm_by_len(key, authlen), GFP_ATOMIC);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tassoclen = skb->mac_len;\n\n\tdata = skb_mac_header(skb) + skb->mac_len;\n\tdatalen = skb_tail_pointer(skb) - data;\n\n\tskb_put(skb, authlen);\n\n\tsg_init_one(&sg, skb_mac_header(skb), assoclen + datalen + authlen);\n\n\tif (!(hdr->sec.level & IEEE802154_SCF_SECLEVEL_ENC)) {\n\t\tassoclen += datalen;\n\t\tdatalen = 0;\n\t}\n\n\taead_request_set_callback(req, 0, NULL, NULL);\n\taead_request_set_crypt(req, &sg, &sg, datalen, iv);\n\taead_request_set_ad(req, assoclen);\n\n\trc = crypto_aead_encrypt(req);\n\n\tkfree_sensitive(req);\n\n\treturn rc;\n}\n\nstatic int llsec_do_encrypt(struct sk_buff *skb,\n\t\t\t    const struct mac802154_llsec *sec,\n\t\t\t    const struct ieee802154_hdr *hdr,\n\t\t\t    struct mac802154_llsec_key *key)\n{\n\tif (hdr->sec.level == IEEE802154_SCF_SECLEVEL_ENC)\n\t\treturn llsec_do_encrypt_unauth(skb, sec, hdr, key);\n\telse\n\t\treturn llsec_do_encrypt_auth(skb, sec, hdr, key);\n}\n\nint mac802154_llsec_encrypt(struct mac802154_llsec *sec, struct sk_buff *skb)\n{\n\tstruct ieee802154_hdr hdr;\n\tint rc, authlen, hlen;\n\tstruct mac802154_llsec_key *key;\n\tu32 frame_ctr;\n\n\thlen = ieee802154_hdr_pull(skb, &hdr);\n\n\t \n\tif (hlen < 0 ||\n\t    (hdr.fc.type != IEEE802154_FC_TYPE_DATA &&\n\t     hdr.fc.type != IEEE802154_FC_TYPE_BEACON))\n\t\treturn -EINVAL;\n\n\tif (!hdr.fc.security_enabled ||\n\t    (hdr.sec.level == IEEE802154_SCF_SECLEVEL_NONE)) {\n\t\tskb_push(skb, hlen);\n\t\treturn 0;\n\t}\n\n\tauthlen = ieee802154_sechdr_authtag_len(&hdr.sec);\n\n\tif (skb->len + hlen + authlen + IEEE802154_MFR_SIZE > IEEE802154_MTU)\n\t\treturn -EMSGSIZE;\n\n\trcu_read_lock();\n\n\tread_lock_bh(&sec->lock);\n\n\tif (!sec->params.enabled) {\n\t\trc = -EINVAL;\n\t\tgoto fail_read;\n\t}\n\n\tkey = llsec_lookup_key(sec, &hdr, &hdr.dest, NULL);\n\tif (!key) {\n\t\trc = -ENOKEY;\n\t\tgoto fail_read;\n\t}\n\n\tread_unlock_bh(&sec->lock);\n\n\twrite_lock_bh(&sec->lock);\n\n\tframe_ctr = be32_to_cpu(sec->params.frame_counter);\n\thdr.sec.frame_counter = cpu_to_le32(frame_ctr);\n\tif (frame_ctr == 0xFFFFFFFF) {\n\t\twrite_unlock_bh(&sec->lock);\n\t\tllsec_key_put(key);\n\t\trc = -EOVERFLOW;\n\t\tgoto fail;\n\t}\n\n\tsec->params.frame_counter = cpu_to_be32(frame_ctr + 1);\n\n\twrite_unlock_bh(&sec->lock);\n\n\trcu_read_unlock();\n\n\tskb->mac_len = ieee802154_hdr_push(skb, &hdr);\n\tskb_reset_mac_header(skb);\n\n\trc = llsec_do_encrypt(skb, sec, &hdr, key);\n\tllsec_key_put(key);\n\n\treturn rc;\n\nfail_read:\n\tread_unlock_bh(&sec->lock);\nfail:\n\trcu_read_unlock();\n\treturn rc;\n}\n\nstatic struct mac802154_llsec_device*\nllsec_lookup_dev(struct mac802154_llsec *sec,\n\t\t const struct ieee802154_addr *addr)\n{\n\tstruct ieee802154_addr devaddr = *addr;\n\tstruct mac802154_llsec_device *dev = NULL;\n\n\tif (devaddr.mode == IEEE802154_ADDR_NONE &&\n\t    llsec_recover_addr(sec, &devaddr) < 0)\n\t\treturn NULL;\n\n\tif (devaddr.mode == IEEE802154_ADDR_SHORT) {\n\t\tu32 key = llsec_dev_hash_short(devaddr.short_addr,\n\t\t\t\t\t       devaddr.pan_id);\n\n\t\thash_for_each_possible_rcu(sec->devices_short, dev,\n\t\t\t\t\t   bucket_s, key) {\n\t\t\tif (dev->dev.pan_id == devaddr.pan_id &&\n\t\t\t    dev->dev.short_addr == devaddr.short_addr)\n\t\t\t\treturn dev;\n\t\t}\n\t} else {\n\t\tu64 key = llsec_dev_hash_long(devaddr.extended_addr);\n\n\t\thash_for_each_possible_rcu(sec->devices_hw, dev,\n\t\t\t\t\t   bucket_hw, key) {\n\t\t\tif (dev->dev.hwaddr == devaddr.extended_addr)\n\t\t\t\treturn dev;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int\nllsec_lookup_seclevel(const struct mac802154_llsec *sec,\n\t\t      u8 frame_type, u8 cmd_frame_id,\n\t\t      struct ieee802154_llsec_seclevel *rlevel)\n{\n\tstruct ieee802154_llsec_seclevel *level;\n\n\tlist_for_each_entry_rcu(level, &sec->table.security_levels, list) {\n\t\tif (level->frame_type == frame_type &&\n\t\t    (frame_type != IEEE802154_FC_TYPE_MAC_CMD ||\n\t\t     level->cmd_frame_id == cmd_frame_id)) {\n\t\t\t*rlevel = *level;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nllsec_do_decrypt_unauth(struct sk_buff *skb, const struct mac802154_llsec *sec,\n\t\t\tconst struct ieee802154_hdr *hdr,\n\t\t\tstruct mac802154_llsec_key *key, __le64 dev_addr)\n{\n\tu8 iv[16];\n\tunsigned char *data;\n\tint datalen;\n\tstruct scatterlist src;\n\tSYNC_SKCIPHER_REQUEST_ON_STACK(req, key->tfm0);\n\tint err;\n\n\tllsec_geniv(iv, dev_addr, &hdr->sec);\n\tdata = skb_mac_header(skb) + skb->mac_len;\n\tdatalen = skb_tail_pointer(skb) - data;\n\n\tsg_init_one(&src, data, datalen);\n\n\tskcipher_request_set_sync_tfm(req, key->tfm0);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &src, &src, datalen, iv);\n\n\terr = crypto_skcipher_decrypt(req);\n\tskcipher_request_zero(req);\n\treturn err;\n}\n\nstatic int\nllsec_do_decrypt_auth(struct sk_buff *skb, const struct mac802154_llsec *sec,\n\t\t      const struct ieee802154_hdr *hdr,\n\t\t      struct mac802154_llsec_key *key, __le64 dev_addr)\n{\n\tu8 iv[16];\n\tunsigned char *data;\n\tint authlen, datalen, assoclen, rc;\n\tstruct scatterlist sg;\n\tstruct aead_request *req;\n\n\tauthlen = ieee802154_sechdr_authtag_len(&hdr->sec);\n\tllsec_geniv(iv, dev_addr, &hdr->sec);\n\n\treq = aead_request_alloc(llsec_tfm_by_len(key, authlen), GFP_ATOMIC);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tassoclen = skb->mac_len;\n\n\tdata = skb_mac_header(skb) + skb->mac_len;\n\tdatalen = skb_tail_pointer(skb) - data;\n\n\tsg_init_one(&sg, skb_mac_header(skb), assoclen + datalen);\n\n\tif (!(hdr->sec.level & IEEE802154_SCF_SECLEVEL_ENC)) {\n\t\tassoclen += datalen - authlen;\n\t\tdatalen = authlen;\n\t}\n\n\taead_request_set_callback(req, 0, NULL, NULL);\n\taead_request_set_crypt(req, &sg, &sg, datalen, iv);\n\taead_request_set_ad(req, assoclen);\n\n\trc = crypto_aead_decrypt(req);\n\n\tkfree_sensitive(req);\n\tskb_trim(skb, skb->len - authlen);\n\n\treturn rc;\n}\n\nstatic int\nllsec_do_decrypt(struct sk_buff *skb, const struct mac802154_llsec *sec,\n\t\t const struct ieee802154_hdr *hdr,\n\t\t struct mac802154_llsec_key *key, __le64 dev_addr)\n{\n\tif (hdr->sec.level == IEEE802154_SCF_SECLEVEL_ENC)\n\t\treturn llsec_do_decrypt_unauth(skb, sec, hdr, key, dev_addr);\n\telse\n\t\treturn llsec_do_decrypt_auth(skb, sec, hdr, key, dev_addr);\n}\n\nstatic int\nllsec_update_devkey_record(struct mac802154_llsec_device *dev,\n\t\t\t   const struct ieee802154_llsec_key_id *in_key)\n{\n\tstruct mac802154_llsec_device_key *devkey;\n\n\tdevkey = llsec_devkey_find(dev, in_key);\n\n\tif (!devkey) {\n\t\tstruct mac802154_llsec_device_key *next;\n\n\t\tnext = kzalloc(sizeof(*devkey), GFP_ATOMIC);\n\t\tif (!next)\n\t\t\treturn -ENOMEM;\n\n\t\tnext->devkey.key_id = *in_key;\n\n\t\tspin_lock_bh(&dev->lock);\n\n\t\tdevkey = llsec_devkey_find(dev, in_key);\n\t\tif (!devkey)\n\t\t\tlist_add_rcu(&next->devkey.list, &dev->dev.keys);\n\t\telse\n\t\t\tkfree_sensitive(next);\n\n\t\tspin_unlock_bh(&dev->lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nllsec_update_devkey_info(struct mac802154_llsec_device *dev,\n\t\t\t const struct ieee802154_llsec_key_id *in_key,\n\t\t\t u32 frame_counter)\n{\n\tstruct mac802154_llsec_device_key *devkey = NULL;\n\n\tif (dev->dev.key_mode == IEEE802154_LLSEC_DEVKEY_RESTRICT) {\n\t\tdevkey = llsec_devkey_find(dev, in_key);\n\t\tif (!devkey)\n\t\t\treturn -ENOENT;\n\t}\n\n\tif (dev->dev.key_mode == IEEE802154_LLSEC_DEVKEY_RECORD) {\n\t\tint rc = llsec_update_devkey_record(dev, in_key);\n\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\tspin_lock_bh(&dev->lock);\n\n\tif ((!devkey && frame_counter < dev->dev.frame_counter) ||\n\t    (devkey && frame_counter < devkey->devkey.frame_counter)) {\n\t\tspin_unlock_bh(&dev->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (devkey)\n\t\tdevkey->devkey.frame_counter = frame_counter + 1;\n\telse\n\t\tdev->dev.frame_counter = frame_counter + 1;\n\n\tspin_unlock_bh(&dev->lock);\n\n\treturn 0;\n}\n\nint mac802154_llsec_decrypt(struct mac802154_llsec *sec, struct sk_buff *skb)\n{\n\tstruct ieee802154_hdr hdr;\n\tstruct mac802154_llsec_key *key;\n\tstruct ieee802154_llsec_key_id key_id;\n\tstruct mac802154_llsec_device *dev;\n\tstruct ieee802154_llsec_seclevel seclevel;\n\tint err;\n\t__le64 dev_addr;\n\tu32 frame_ctr;\n\n\tif (ieee802154_hdr_peek(skb, &hdr) < 0)\n\t\treturn -EINVAL;\n\tif (!hdr.fc.security_enabled)\n\t\treturn 0;\n\tif (hdr.fc.version == 0)\n\t\treturn -EINVAL;\n\n\tread_lock_bh(&sec->lock);\n\tif (!sec->params.enabled) {\n\t\tread_unlock_bh(&sec->lock);\n\t\treturn -EINVAL;\n\t}\n\tread_unlock_bh(&sec->lock);\n\n\trcu_read_lock();\n\n\tkey = llsec_lookup_key(sec, &hdr, &hdr.source, &key_id);\n\tif (!key) {\n\t\terr = -ENOKEY;\n\t\tgoto fail;\n\t}\n\n\tdev = llsec_lookup_dev(sec, &hdr.source);\n\tif (!dev) {\n\t\terr = -EINVAL;\n\t\tgoto fail_dev;\n\t}\n\n\tif (llsec_lookup_seclevel(sec, hdr.fc.type, 0, &seclevel) < 0) {\n\t\terr = -EINVAL;\n\t\tgoto fail_dev;\n\t}\n\n\tif (!(seclevel.sec_levels & BIT(hdr.sec.level)) &&\n\t    (hdr.sec.level == 0 && seclevel.device_override &&\n\t     !dev->dev.seclevel_exempt)) {\n\t\terr = -EINVAL;\n\t\tgoto fail_dev;\n\t}\n\n\tframe_ctr = le32_to_cpu(hdr.sec.frame_counter);\n\n\tif (frame_ctr == 0xffffffff) {\n\t\terr = -EOVERFLOW;\n\t\tgoto fail_dev;\n\t}\n\n\terr = llsec_update_devkey_info(dev, &key_id, frame_ctr);\n\tif (err)\n\t\tgoto fail_dev;\n\n\tdev_addr = dev->dev.hwaddr;\n\n\trcu_read_unlock();\n\n\terr = llsec_do_decrypt(skb, sec, &hdr, key, dev_addr);\n\tllsec_key_put(key);\n\treturn err;\n\nfail_dev:\n\tllsec_key_put(key);\nfail:\n\trcu_read_unlock();\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}