{
  "module_name": "scan.c",
  "hash_id": "98df627c167cbe378188799035c4ba7580a0d5790fc01c18c83f6eac675d2afa",
  "original_prompt": "Ingested from linux-6.6.14/net/mac802154/scan.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/rtnetlink.h>\n#include <net/mac802154.h>\n\n#include \"ieee802154_i.h\"\n#include \"driver-ops.h\"\n#include \"../ieee802154/nl802154.h\"\n\n#define IEEE802154_BEACON_MHR_SZ 13\n#define IEEE802154_BEACON_PL_SZ 4\n#define IEEE802154_MAC_CMD_MHR_SZ 23\n#define IEEE802154_MAC_CMD_PL_SZ 1\n#define IEEE802154_BEACON_SKB_SZ (IEEE802154_BEACON_MHR_SZ + \\\n\t\t\t\t  IEEE802154_BEACON_PL_SZ)\n#define IEEE802154_MAC_CMD_SKB_SZ (IEEE802154_MAC_CMD_MHR_SZ + \\\n\t\t\t\t   IEEE802154_MAC_CMD_PL_SZ)\n\n \nstatic int mac802154_scan_cleanup_locked(struct ieee802154_local *local,\n\t\t\t\t\t struct ieee802154_sub_if_data *sdata,\n\t\t\t\t\t bool aborted)\n{\n\tstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\n\tstruct wpan_phy *wpan_phy = local->phy;\n\tstruct cfg802154_scan_request *request;\n\tu8 arg;\n\n\t \n\tclear_bit(IEEE802154_IS_SCANNING, &local->ongoing);\n\tcancel_delayed_work(&local->scan_work);\n\trequest = rcu_replace_pointer(local->scan_req, NULL, 1);\n\tif (!request)\n\t\treturn 0;\n\tkvfree_rcu_mightsleep(request);\n\n\t \n\tif (aborted)\n\t\targ = NL802154_SCAN_DONE_REASON_ABORTED;\n\telse\n\t\targ = NL802154_SCAN_DONE_REASON_FINISHED;\n\tnl802154_scan_done(wpan_phy, wpan_dev, arg);\n\n\t \n\tieee802154_mlme_op_post(local);\n\n\t \n\tdrv_set_channel(local, wpan_phy->current_page,\n\t\t\twpan_phy->current_channel);\n\tieee802154_configure_durations(wpan_phy, wpan_phy->current_page,\n\t\t\t\t       wpan_phy->current_channel);\n\tdrv_stop(local);\n\tsynchronize_net();\n\tsdata->required_filtering = sdata->iface_default_filtering;\n\tdrv_start(local, sdata->required_filtering, &local->addr_filt);\n\n\treturn 0;\n}\n\nint mac802154_abort_scan_locked(struct ieee802154_local *local,\n\t\t\t\tstruct ieee802154_sub_if_data *sdata)\n{\n\tASSERT_RTNL();\n\n\tif (!mac802154_is_scanning(local))\n\t\treturn -ESRCH;\n\n\treturn mac802154_scan_cleanup_locked(local, sdata, true);\n}\n\nstatic unsigned int mac802154_scan_get_channel_time(u8 duration_order,\n\t\t\t\t\t\t    u8 symbol_duration)\n{\n\tu64 base_super_frame_duration = (u64)symbol_duration *\n\t\tIEEE802154_SUPERFRAME_PERIOD * IEEE802154_SLOT_PERIOD;\n\n\treturn usecs_to_jiffies(base_super_frame_duration *\n\t\t\t\t(BIT(duration_order) + 1));\n}\n\nstatic void mac802154_flush_queued_beacons(struct ieee802154_local *local)\n{\n\tstruct cfg802154_mac_pkt *mac_pkt, *tmp;\n\n\tlist_for_each_entry_safe(mac_pkt, tmp, &local->rx_beacon_list, node) {\n\t\tlist_del(&mac_pkt->node);\n\t\tkfree_skb(mac_pkt->skb);\n\t\tkfree(mac_pkt);\n\t}\n}\n\nstatic void\nmac802154_scan_get_next_channel(struct ieee802154_local *local,\n\t\t\t\tstruct cfg802154_scan_request *scan_req,\n\t\t\t\tu8 *channel)\n{\n\t(*channel)++;\n\t*channel = find_next_bit((const unsigned long *)&scan_req->channels,\n\t\t\t\t IEEE802154_MAX_CHANNEL + 1,\n\t\t\t\t *channel);\n}\n\nstatic int mac802154_scan_find_next_chan(struct ieee802154_local *local,\n\t\t\t\t\t struct cfg802154_scan_request *scan_req,\n\t\t\t\t\t u8 page, u8 *channel)\n{\n\tmac802154_scan_get_next_channel(local, scan_req, channel);\n\tif (*channel > IEEE802154_MAX_CHANNEL)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int mac802154_scan_prepare_beacon_req(struct ieee802154_local *local)\n{\n\tmemset(&local->scan_beacon_req, 0, sizeof(local->scan_beacon_req));\n\tlocal->scan_beacon_req.mhr.fc.type = IEEE802154_FC_TYPE_MAC_CMD;\n\tlocal->scan_beacon_req.mhr.fc.dest_addr_mode = IEEE802154_SHORT_ADDRESSING;\n\tlocal->scan_beacon_req.mhr.fc.version = IEEE802154_2003_STD;\n\tlocal->scan_beacon_req.mhr.fc.source_addr_mode = IEEE802154_NO_ADDRESSING;\n\tlocal->scan_beacon_req.mhr.dest.mode = IEEE802154_ADDR_SHORT;\n\tlocal->scan_beacon_req.mhr.dest.pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);\n\tlocal->scan_beacon_req.mhr.dest.short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);\n\tlocal->scan_beacon_req.mac_pl.cmd_id = IEEE802154_CMD_BEACON_REQ;\n\n\treturn 0;\n}\n\nstatic int mac802154_transmit_beacon_req(struct ieee802154_local *local,\n\t\t\t\t\t struct ieee802154_sub_if_data *sdata)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = alloc_skb(IEEE802154_MAC_CMD_SKB_SZ, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\tskb->dev = sdata->dev;\n\n\tret = ieee802154_mac_cmd_push(skb, &local->scan_beacon_req, NULL, 0);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\treturn ieee802154_mlme_tx(local, sdata, skb);\n}\n\nvoid mac802154_scan_worker(struct work_struct *work)\n{\n\tstruct ieee802154_local *local =\n\t\tcontainer_of(work, struct ieee802154_local, scan_work.work);\n\tstruct cfg802154_scan_request *scan_req;\n\tstruct ieee802154_sub_if_data *sdata;\n\tunsigned int scan_duration = 0;\n\tstruct wpan_phy *wpan_phy;\n\tu8 scan_req_duration;\n\tu8 page, channel;\n\tint ret;\n\n\t \n\tdrv_stop(local);\n\tsynchronize_net();\n\tmac802154_flush_queued_beacons(local);\n\n\trcu_read_lock();\n\tscan_req = rcu_dereference(local->scan_req);\n\tif (unlikely(!scan_req)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tsdata = IEEE802154_WPAN_DEV_TO_SUB_IF(scan_req->wpan_dev);\n\n\t \n\tif (local->suspended || !ieee802154_sdata_running(sdata)) {\n\t\trcu_read_unlock();\n\t\tqueue_delayed_work(local->mac_wq, &local->scan_work,\n\t\t\t\t   msecs_to_jiffies(1000));\n\t\treturn;\n\t}\n\n\twpan_phy = scan_req->wpan_phy;\n\tscan_req_duration = scan_req->duration;\n\n\t \n\tpage = local->scan_page;\n\tchannel = local->scan_channel;\n\tdo {\n\t\tret = mac802154_scan_find_next_chan(local, scan_req, page, &channel);\n\t\tif (ret) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto end_scan;\n\t\t}\n\t} while (!ieee802154_chan_is_valid(scan_req->wpan_phy, page, channel));\n\n\trcu_read_unlock();\n\n\t \n\trtnl_lock();\n\tret = drv_set_channel(local, page, channel);\n\trtnl_unlock();\n\tif (ret) {\n\t\tdev_err(&sdata->dev->dev,\n\t\t\t\"Channel change failure during scan, aborting (%d)\\n\", ret);\n\t\tgoto end_scan;\n\t}\n\n\tlocal->scan_page = page;\n\tlocal->scan_channel = channel;\n\n\trtnl_lock();\n\tret = drv_start(local, IEEE802154_FILTERING_3_SCAN, &local->addr_filt);\n\trtnl_unlock();\n\tif (ret) {\n\t\tdev_err(&sdata->dev->dev,\n\t\t\t\"Restarting failure after channel change, aborting (%d)\\n\", ret);\n\t\tgoto end_scan;\n\t}\n\n\tif (scan_req->type == NL802154_SCAN_ACTIVE) {\n\t\tret = mac802154_transmit_beacon_req(local, sdata);\n\t\tif (ret)\n\t\t\tdev_err(&sdata->dev->dev,\n\t\t\t\t\"Error when transmitting beacon request (%d)\\n\", ret);\n\t}\n\n\tieee802154_configure_durations(wpan_phy, page, channel);\n\tscan_duration = mac802154_scan_get_channel_time(scan_req_duration,\n\t\t\t\t\t\t\twpan_phy->symbol_duration);\n\tdev_dbg(&sdata->dev->dev,\n\t\t\"Scan page %u channel %u for %ums\\n\",\n\t\tpage, channel, jiffies_to_msecs(scan_duration));\n\tqueue_delayed_work(local->mac_wq, &local->scan_work, scan_duration);\n\treturn;\n\nend_scan:\n\trtnl_lock();\n\tmac802154_scan_cleanup_locked(local, sdata, false);\n\trtnl_unlock();\n}\n\nint mac802154_trigger_scan_locked(struct ieee802154_sub_if_data *sdata,\n\t\t\t\t  struct cfg802154_scan_request *request)\n{\n\tstruct ieee802154_local *local = sdata->local;\n\n\tASSERT_RTNL();\n\n\tif (mac802154_is_scanning(local))\n\t\treturn -EBUSY;\n\n\tif (request->type != NL802154_SCAN_PASSIVE &&\n\t    request->type != NL802154_SCAN_ACTIVE)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\trcu_assign_pointer(local->scan_req, request);\n\n\t \n\tieee802154_mlme_op_pre(local);\n\n\tsdata->required_filtering = IEEE802154_FILTERING_3_SCAN;\n\tlocal->scan_page = request->page;\n\tlocal->scan_channel = -1;\n\tset_bit(IEEE802154_IS_SCANNING, &local->ongoing);\n\tif (request->type == NL802154_SCAN_ACTIVE)\n\t\tmac802154_scan_prepare_beacon_req(local);\n\n\tnl802154_scan_started(request->wpan_phy, request->wpan_dev);\n\n\tqueue_delayed_work(local->mac_wq, &local->scan_work, 0);\n\n\treturn 0;\n}\n\nint mac802154_process_beacon(struct ieee802154_local *local,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     u8 page, u8 channel)\n{\n\tstruct ieee802154_beacon_hdr *bh = (void *)skb->data;\n\tstruct ieee802154_addr *src = &mac_cb(skb)->source;\n\tstruct cfg802154_scan_request *scan_req;\n\tstruct ieee802154_coord_desc desc;\n\n\tif (skb->len != sizeof(*bh))\n\t\treturn -EINVAL;\n\n\tif (unlikely(src->mode == IEEE802154_ADDR_NONE))\n\t\treturn -EINVAL;\n\n\tdev_dbg(&skb->dev->dev,\n\t\t\"BEACON received on page %u channel %u\\n\",\n\t\tpage, channel);\n\n\tmemcpy(&desc.addr, src, sizeof(desc.addr));\n\tdesc.page = page;\n\tdesc.channel = channel;\n\tdesc.link_quality = mac_cb(skb)->lqi;\n\tdesc.superframe_spec = get_unaligned_le16(skb->data);\n\tdesc.gts_permit = bh->gts_permit;\n\n\ttrace_802154_scan_event(&desc);\n\n\trcu_read_lock();\n\tscan_req = rcu_dereference(local->scan_req);\n\tif (likely(scan_req))\n\t\tnl802154_scan_event(scan_req->wpan_phy, scan_req->wpan_dev, &desc);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int mac802154_transmit_beacon(struct ieee802154_local *local,\n\t\t\t\t     struct wpan_dev *wpan_dev)\n{\n\tstruct cfg802154_beacon_request *beacon_req;\n\tstruct ieee802154_sub_if_data *sdata;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\t \n\tlocal->beacon.mhr.seq = atomic_inc_return(&wpan_dev->bsn) & 0xFF;\n\n\tskb = alloc_skb(IEEE802154_BEACON_SKB_SZ, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\trcu_read_lock();\n\tbeacon_req = rcu_dereference(local->beacon_req);\n\tif (unlikely(!beacon_req)) {\n\t\trcu_read_unlock();\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tsdata = IEEE802154_WPAN_DEV_TO_SUB_IF(beacon_req->wpan_dev);\n\tskb->dev = sdata->dev;\n\n\trcu_read_unlock();\n\n\tret = ieee802154_beacon_push(skb, &local->beacon);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\t \n\treturn ieee802154_mlme_tx(local, sdata, skb);\n}\n\nvoid mac802154_beacon_worker(struct work_struct *work)\n{\n\tstruct ieee802154_local *local =\n\t\tcontainer_of(work, struct ieee802154_local, beacon_work.work);\n\tstruct cfg802154_beacon_request *beacon_req;\n\tstruct ieee802154_sub_if_data *sdata;\n\tstruct wpan_dev *wpan_dev;\n\tu8 interval;\n\tint ret;\n\n\trcu_read_lock();\n\tbeacon_req = rcu_dereference(local->beacon_req);\n\tif (unlikely(!beacon_req)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tsdata = IEEE802154_WPAN_DEV_TO_SUB_IF(beacon_req->wpan_dev);\n\n\t \n\tif (local->suspended || !ieee802154_sdata_running(sdata)) {\n\t\trcu_read_unlock();\n\t\tqueue_delayed_work(local->mac_wq, &local->beacon_work,\n\t\t\t\t   msecs_to_jiffies(1000));\n\t\treturn;\n\t}\n\n\twpan_dev = beacon_req->wpan_dev;\n\tinterval = beacon_req->interval;\n\n\trcu_read_unlock();\n\n\tdev_dbg(&sdata->dev->dev, \"Sending beacon\\n\");\n\tret = mac802154_transmit_beacon(local, wpan_dev);\n\tif (ret)\n\t\tdev_err(&sdata->dev->dev,\n\t\t\t\"Beacon could not be transmitted (%d)\\n\", ret);\n\n\tif (interval < IEEE802154_ACTIVE_SCAN_DURATION)\n\t\tqueue_delayed_work(local->mac_wq, &local->beacon_work,\n\t\t\t\t   local->beacon_interval);\n}\n\nint mac802154_stop_beacons_locked(struct ieee802154_local *local,\n\t\t\t\t  struct ieee802154_sub_if_data *sdata)\n{\n\tstruct wpan_dev *wpan_dev = &sdata->wpan_dev;\n\tstruct cfg802154_beacon_request *request;\n\n\tASSERT_RTNL();\n\n\tif (!mac802154_is_beaconing(local))\n\t\treturn -ESRCH;\n\n\tclear_bit(IEEE802154_IS_BEACONING, &local->ongoing);\n\tcancel_delayed_work(&local->beacon_work);\n\trequest = rcu_replace_pointer(local->beacon_req, NULL, 1);\n\tif (!request)\n\t\treturn 0;\n\tkvfree_rcu_mightsleep(request);\n\n\tnl802154_beaconing_done(wpan_dev);\n\n\treturn 0;\n}\n\nint mac802154_send_beacons_locked(struct ieee802154_sub_if_data *sdata,\n\t\t\t\t  struct cfg802154_beacon_request *request)\n{\n\tstruct ieee802154_local *local = sdata->local;\n\n\tASSERT_RTNL();\n\n\tif (mac802154_is_beaconing(local))\n\t\tmac802154_stop_beacons_locked(local, sdata);\n\n\t \n\trcu_assign_pointer(local->beacon_req, request);\n\n\tset_bit(IEEE802154_IS_BEACONING, &local->ongoing);\n\n\tmemset(&local->beacon, 0, sizeof(local->beacon));\n\tlocal->beacon.mhr.fc.type = IEEE802154_FC_TYPE_BEACON;\n\tlocal->beacon.mhr.fc.security_enabled = 0;\n\tlocal->beacon.mhr.fc.frame_pending = 0;\n\tlocal->beacon.mhr.fc.ack_request = 0;\n\tlocal->beacon.mhr.fc.intra_pan = 0;\n\tlocal->beacon.mhr.fc.dest_addr_mode = IEEE802154_NO_ADDRESSING;\n\tlocal->beacon.mhr.fc.version = IEEE802154_2003_STD;\n\tlocal->beacon.mhr.fc.source_addr_mode = IEEE802154_EXTENDED_ADDRESSING;\n\tatomic_set(&request->wpan_dev->bsn, -1);\n\tlocal->beacon.mhr.source.mode = IEEE802154_ADDR_LONG;\n\tlocal->beacon.mhr.source.pan_id = request->wpan_dev->pan_id;\n\tlocal->beacon.mhr.source.extended_addr = request->wpan_dev->extended_addr;\n\tlocal->beacon.mac_pl.beacon_order = request->interval;\n\tif (request->interval <= IEEE802154_MAX_SCAN_DURATION)\n\t\tlocal->beacon.mac_pl.superframe_order = request->interval;\n\tlocal->beacon.mac_pl.final_cap_slot = 0xf;\n\tlocal->beacon.mac_pl.battery_life_ext = 0;\n\t \n\tlocal->beacon.mac_pl.pan_coordinator = 1;\n\tlocal->beacon.mac_pl.assoc_permit = 1;\n\n\tif (request->interval == IEEE802154_ACTIVE_SCAN_DURATION)\n\t\treturn 0;\n\n\t \n\tlocal->beacon_interval =\n\t\tmac802154_scan_get_channel_time(request->interval,\n\t\t\t\t\t\trequest->wpan_phy->symbol_duration);\n\tqueue_delayed_work(local->mac_wq, &local->beacon_work, 0);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}