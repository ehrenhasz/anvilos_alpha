{
  "module_name": "util.c",
  "hash_id": "e5cc5ea3c9b5f6baca86d00fc219d616098e2373bf2a6e16ee25bbab77fd6923",
  "original_prompt": "Ingested from linux-6.6.14/net/mac802154/util.c",
  "human_readable_source": "\n \n\n#include \"ieee802154_i.h\"\n#include \"driver-ops.h\"\n\n \nconst void *const mac802154_wpan_phy_privid = &mac802154_wpan_phy_privid;\n\n \nstatic void ieee802154_wake_queue(struct ieee802154_hw *hw)\n{\n\tstruct ieee802154_local *local = hw_to_local(hw);\n\tstruct ieee802154_sub_if_data *sdata;\n\n\trcu_read_lock();\n\tclear_bit(WPAN_PHY_FLAG_STATE_QUEUE_STOPPED, &local->phy->flags);\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (!sdata->dev)\n\t\t\tcontinue;\n\n\t\tnetif_wake_queue(sdata->dev);\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void ieee802154_stop_queue(struct ieee802154_hw *hw)\n{\n\tstruct ieee802154_local *local = hw_to_local(hw);\n\tstruct ieee802154_sub_if_data *sdata;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (!sdata->dev)\n\t\t\tcontinue;\n\n\t\tnetif_stop_queue(sdata->dev);\n\t}\n\trcu_read_unlock();\n}\n\nvoid ieee802154_hold_queue(struct ieee802154_local *local)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&local->phy->queue_lock, flags);\n\tif (!atomic_fetch_inc(&local->phy->hold_txs))\n\t\tieee802154_stop_queue(&local->hw);\n\tspin_unlock_irqrestore(&local->phy->queue_lock, flags);\n}\n\nvoid ieee802154_release_queue(struct ieee802154_local *local)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&local->phy->queue_lock, flags);\n\tif (atomic_dec_and_test(&local->phy->hold_txs))\n\t\tieee802154_wake_queue(&local->hw);\n\tspin_unlock_irqrestore(&local->phy->queue_lock, flags);\n}\n\nvoid ieee802154_disable_queue(struct ieee802154_local *local)\n{\n\tstruct ieee802154_sub_if_data *sdata;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (!sdata->dev)\n\t\t\tcontinue;\n\n\t\tnetif_tx_disable(sdata->dev);\n\t}\n\trcu_read_unlock();\n}\n\nenum hrtimer_restart ieee802154_xmit_ifs_timer(struct hrtimer *timer)\n{\n\tstruct ieee802154_local *local =\n\t\tcontainer_of(timer, struct ieee802154_local, ifs_timer);\n\n\tieee802154_release_queue(local);\n\n\treturn HRTIMER_NORESTART;\n}\n\nvoid ieee802154_xmit_complete(struct ieee802154_hw *hw, struct sk_buff *skb,\n\t\t\t      bool ifs_handling)\n{\n\tstruct ieee802154_local *local = hw_to_local(hw);\n\n\tlocal->tx_result = IEEE802154_SUCCESS;\n\n\tif (ifs_handling) {\n\t\tu8 max_sifs_size;\n\n\t\t \n\t\tif (hw->flags & IEEE802154_HW_TX_OMIT_CKSUM)\n\t\t\tmax_sifs_size = IEEE802154_MAX_SIFS_FRAME_SIZE -\n\t\t\t\t\tIEEE802154_FCS_LEN;\n\t\telse\n\t\t\tmax_sifs_size = IEEE802154_MAX_SIFS_FRAME_SIZE;\n\n\t\tif (skb->len > max_sifs_size)\n\t\t\thrtimer_start(&local->ifs_timer,\n\t\t\t\t      hw->phy->lifs_period * NSEC_PER_USEC,\n\t\t\t\t      HRTIMER_MODE_REL);\n\t\telse\n\t\t\thrtimer_start(&local->ifs_timer,\n\t\t\t\t      hw->phy->sifs_period * NSEC_PER_USEC,\n\t\t\t\t      HRTIMER_MODE_REL);\n\t} else {\n\t\tieee802154_release_queue(local);\n\t}\n\n\tdev_consume_skb_any(skb);\n\tif (atomic_dec_and_test(&hw->phy->ongoing_txs))\n\t\twake_up(&hw->phy->sync_txq);\n}\nEXPORT_SYMBOL(ieee802154_xmit_complete);\n\nvoid ieee802154_xmit_error(struct ieee802154_hw *hw, struct sk_buff *skb,\n\t\t\t   int reason)\n{\n\tstruct ieee802154_local *local = hw_to_local(hw);\n\n\tlocal->tx_result = reason;\n\tieee802154_release_queue(local);\n\tdev_kfree_skb_any(skb);\n\tif (atomic_dec_and_test(&hw->phy->ongoing_txs))\n\t\twake_up(&hw->phy->sync_txq);\n}\nEXPORT_SYMBOL(ieee802154_xmit_error);\n\nvoid ieee802154_xmit_hw_error(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tieee802154_xmit_error(hw, skb, IEEE802154_SYSTEM_ERROR);\n}\nEXPORT_SYMBOL(ieee802154_xmit_hw_error);\n\nvoid ieee802154_stop_device(struct ieee802154_local *local)\n{\n\tflush_workqueue(local->workqueue);\n\thrtimer_cancel(&local->ifs_timer);\n\tdrv_stop(local);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}