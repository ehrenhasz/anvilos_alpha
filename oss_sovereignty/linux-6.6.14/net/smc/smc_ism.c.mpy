{
  "module_name": "smc_ism.c",
  "hash_id": "e1407eb8d6a9f16da132810156e495182b261f8a58c5f0b3744c4580513cbe61",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_ism.c",
  "human_readable_source": "\n \n\n#include <linux/if_vlan.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <asm/page.h>\n\n#include \"smc.h\"\n#include \"smc_core.h\"\n#include \"smc_ism.h\"\n#include \"smc_pnet.h\"\n#include \"smc_netlink.h\"\n#include \"linux/ism.h\"\n\nstruct smcd_dev_list smcd_dev_list = {\n\t.list = LIST_HEAD_INIT(smcd_dev_list.list),\n\t.mutex = __MUTEX_INITIALIZER(smcd_dev_list.mutex)\n};\n\nstatic bool smc_ism_v2_capable;\nstatic u8 smc_ism_v2_system_eid[SMC_MAX_EID_LEN];\n\n#if IS_ENABLED(CONFIG_ISM)\nstatic void smcd_register_dev(struct ism_dev *ism);\nstatic void smcd_unregister_dev(struct ism_dev *ism);\nstatic void smcd_handle_event(struct ism_dev *ism, struct ism_event *event);\nstatic void smcd_handle_irq(struct ism_dev *ism, unsigned int dmbno,\n\t\t\t    u16 dmbemask);\n\nstatic struct ism_client smc_ism_client = {\n\t.name = \"SMC-D\",\n\t.add = smcd_register_dev,\n\t.remove = smcd_unregister_dev,\n\t.handle_event = smcd_handle_event,\n\t.handle_irq = smcd_handle_irq,\n};\n#endif\n\n \nint smc_ism_cantalk(u64 peer_gid, unsigned short vlan_id, struct smcd_dev *smcd)\n{\n\treturn smcd->ops->query_remote_gid(smcd, peer_gid, vlan_id ? 1 : 0,\n\t\t\t\t\t   vlan_id);\n}\n\nvoid smc_ism_get_system_eid(u8 **eid)\n{\n\tif (!smc_ism_v2_capable)\n\t\t*eid = NULL;\n\telse\n\t\t*eid = smc_ism_v2_system_eid;\n}\n\nu16 smc_ism_get_chid(struct smcd_dev *smcd)\n{\n\treturn smcd->ops->get_chid(smcd);\n}\n\n \nbool smc_ism_is_v2_capable(void)\n{\n\treturn smc_ism_v2_capable;\n}\n\n \nvoid smc_ism_set_conn(struct smc_connection *conn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&conn->lgr->smcd->lock, flags);\n\tconn->lgr->smcd->conn[conn->rmb_desc->sba_idx] = conn;\n\tspin_unlock_irqrestore(&conn->lgr->smcd->lock, flags);\n}\n\n \nvoid smc_ism_unset_conn(struct smc_connection *conn)\n{\n\tunsigned long flags;\n\n\tif (!conn->rmb_desc)\n\t\treturn;\n\n\tspin_lock_irqsave(&conn->lgr->smcd->lock, flags);\n\tconn->lgr->smcd->conn[conn->rmb_desc->sba_idx] = NULL;\n\tspin_unlock_irqrestore(&conn->lgr->smcd->lock, flags);\n}\n\n \nint smc_ism_get_vlan(struct smcd_dev *smcd, unsigned short vlanid)\n{\n\tstruct smc_ism_vlanid *new_vlan, *vlan;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tif (!vlanid)\t\t\t \n\t\treturn -EINVAL;\n\n\t \n\tnew_vlan = kzalloc(sizeof(*new_vlan), GFP_KERNEL);\n\tif (!new_vlan)\n\t\treturn -ENOMEM;\n\tnew_vlan->vlanid = vlanid;\n\trefcount_set(&new_vlan->refcnt, 1);\n\n\t \n\tspin_lock_irqsave(&smcd->lock, flags);\n\tlist_for_each_entry(vlan, &smcd->vlan, list) {\n\t\tif (vlan->vlanid == vlanid) {\n\t\t\trefcount_inc(&vlan->refcnt);\n\t\t\tkfree(new_vlan);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (smcd->ops->add_vlan_id(smcd, vlanid)) {\n\t\tkfree(new_vlan);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tlist_add_tail(&new_vlan->list, &smcd->vlan);\nout:\n\tspin_unlock_irqrestore(&smcd->lock, flags);\n\treturn rc;\n}\n\n \nint smc_ism_put_vlan(struct smcd_dev *smcd, unsigned short vlanid)\n{\n\tstruct smc_ism_vlanid *vlan;\n\tunsigned long flags;\n\tbool found = false;\n\tint rc = 0;\n\n\tif (!vlanid)\t\t\t \n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&smcd->lock, flags);\n\tlist_for_each_entry(vlan, &smcd->vlan, list) {\n\t\tif (vlan->vlanid == vlanid) {\n\t\t\tif (!refcount_dec_and_test(&vlan->refcnt))\n\t\t\t\tgoto out;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {\n\t\trc = -ENOENT;\n\t\tgoto out;\t\t \n\t}\n\n\t \n\tif (smcd->ops->del_vlan_id(smcd, vlanid))\n\t\trc = -EIO;\n\tlist_del(&vlan->list);\n\tkfree(vlan);\nout:\n\tspin_unlock_irqrestore(&smcd->lock, flags);\n\treturn rc;\n}\n\nint smc_ism_unregister_dmb(struct smcd_dev *smcd, struct smc_buf_desc *dmb_desc)\n{\n\tstruct smcd_dmb dmb;\n\tint rc = 0;\n\n\tif (!dmb_desc->dma_addr)\n\t\treturn rc;\n\n\tmemset(&dmb, 0, sizeof(dmb));\n\tdmb.dmb_tok = dmb_desc->token;\n\tdmb.sba_idx = dmb_desc->sba_idx;\n\tdmb.cpu_addr = dmb_desc->cpu_addr;\n\tdmb.dma_addr = dmb_desc->dma_addr;\n\tdmb.dmb_len = dmb_desc->len;\n\trc = smcd->ops->unregister_dmb(smcd, &dmb);\n\tif (!rc || rc == ISM_ERROR) {\n\t\tdmb_desc->cpu_addr = NULL;\n\t\tdmb_desc->dma_addr = 0;\n\t}\n\n\treturn rc;\n}\n\nint smc_ism_register_dmb(struct smc_link_group *lgr, int dmb_len,\n\t\t\t struct smc_buf_desc *dmb_desc)\n{\n#if IS_ENABLED(CONFIG_ISM)\n\tstruct smcd_dmb dmb;\n\tint rc;\n\n\tmemset(&dmb, 0, sizeof(dmb));\n\tdmb.dmb_len = dmb_len;\n\tdmb.sba_idx = dmb_desc->sba_idx;\n\tdmb.vlan_id = lgr->vlan_id;\n\tdmb.rgid = lgr->peer_gid;\n\trc = lgr->smcd->ops->register_dmb(lgr->smcd, &dmb, &smc_ism_client);\n\tif (!rc) {\n\t\tdmb_desc->sba_idx = dmb.sba_idx;\n\t\tdmb_desc->token = dmb.dmb_tok;\n\t\tdmb_desc->cpu_addr = dmb.cpu_addr;\n\t\tdmb_desc->dma_addr = dmb.dma_addr;\n\t\tdmb_desc->len = dmb.dmb_len;\n\t}\n\treturn rc;\n#else\n\treturn 0;\n#endif\n}\n\nstatic int smc_nl_handle_smcd_dev(struct smcd_dev *smcd,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct netlink_callback *cb)\n{\n\tchar smc_pnet[SMC_MAX_PNETID_LEN + 1];\n\tstruct smc_pci_dev smc_pci_dev;\n\tstruct nlattr *port_attrs;\n\tstruct nlattr *attrs;\n\tstruct ism_dev *ism;\n\tint use_cnt = 0;\n\tvoid *nlh;\n\n\tism = smcd->priv;\n\tnlh = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &smc_gen_nl_family, NLM_F_MULTI,\n\t\t\t  SMC_NETLINK_GET_DEV_SMCD);\n\tif (!nlh)\n\t\tgoto errmsg;\n\tattrs = nla_nest_start(skb, SMC_GEN_DEV_SMCD);\n\tif (!attrs)\n\t\tgoto errout;\n\tuse_cnt = atomic_read(&smcd->lgr_cnt);\n\tif (nla_put_u32(skb, SMC_NLA_DEV_USE_CNT, use_cnt))\n\t\tgoto errattr;\n\tif (nla_put_u8(skb, SMC_NLA_DEV_IS_CRIT, use_cnt > 0))\n\t\tgoto errattr;\n\tmemset(&smc_pci_dev, 0, sizeof(smc_pci_dev));\n\tsmc_set_pci_values(to_pci_dev(ism->dev.parent), &smc_pci_dev);\n\tif (nla_put_u32(skb, SMC_NLA_DEV_PCI_FID, smc_pci_dev.pci_fid))\n\t\tgoto errattr;\n\tif (nla_put_u16(skb, SMC_NLA_DEV_PCI_CHID, smc_pci_dev.pci_pchid))\n\t\tgoto errattr;\n\tif (nla_put_u16(skb, SMC_NLA_DEV_PCI_VENDOR, smc_pci_dev.pci_vendor))\n\t\tgoto errattr;\n\tif (nla_put_u16(skb, SMC_NLA_DEV_PCI_DEVICE, smc_pci_dev.pci_device))\n\t\tgoto errattr;\n\tif (nla_put_string(skb, SMC_NLA_DEV_PCI_ID, smc_pci_dev.pci_id))\n\t\tgoto errattr;\n\n\tport_attrs = nla_nest_start(skb, SMC_NLA_DEV_PORT);\n\tif (!port_attrs)\n\t\tgoto errattr;\n\tif (nla_put_u8(skb, SMC_NLA_DEV_PORT_PNET_USR, smcd->pnetid_by_user))\n\t\tgoto errportattr;\n\tmemcpy(smc_pnet, smcd->pnetid, SMC_MAX_PNETID_LEN);\n\tsmc_pnet[SMC_MAX_PNETID_LEN] = 0;\n\tif (nla_put_string(skb, SMC_NLA_DEV_PORT_PNETID, smc_pnet))\n\t\tgoto errportattr;\n\n\tnla_nest_end(skb, port_attrs);\n\tnla_nest_end(skb, attrs);\n\tgenlmsg_end(skb, nlh);\n\treturn 0;\n\nerrportattr:\n\tnla_nest_cancel(skb, port_attrs);\nerrattr:\n\tnla_nest_cancel(skb, attrs);\nerrout:\n\tnlmsg_cancel(skb, nlh);\nerrmsg:\n\treturn -EMSGSIZE;\n}\n\nstatic void smc_nl_prep_smcd_dev(struct smcd_dev_list *dev_list,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct smc_nl_dmp_ctx *cb_ctx = smc_nl_dmp_ctx(cb);\n\tint snum = cb_ctx->pos[0];\n\tstruct smcd_dev *smcd;\n\tint num = 0;\n\n\tmutex_lock(&dev_list->mutex);\n\tlist_for_each_entry(smcd, &dev_list->list, list) {\n\t\tif (num < snum)\n\t\t\tgoto next;\n\t\tif (smc_nl_handle_smcd_dev(smcd, skb, cb))\n\t\t\tgoto errout;\nnext:\n\t\tnum++;\n\t}\nerrout:\n\tmutex_unlock(&dev_list->mutex);\n\tcb_ctx->pos[0] = num;\n}\n\nint smcd_nl_get_device(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tsmc_nl_prep_smcd_dev(&smcd_dev_list, skb, cb);\n\treturn skb->len;\n}\n\n#if IS_ENABLED(CONFIG_ISM)\nstruct smc_ism_event_work {\n\tstruct work_struct work;\n\tstruct smcd_dev *smcd;\n\tstruct ism_event event;\n};\n\n#define ISM_EVENT_REQUEST\t\t0x0001\n#define ISM_EVENT_RESPONSE\t\t0x0002\n#define ISM_EVENT_REQUEST_IR\t\t0x00000001\n#define ISM_EVENT_CODE_SHUTDOWN\t\t0x80\n#define ISM_EVENT_CODE_TESTLINK\t\t0x83\n\nunion smcd_sw_event_info {\n\tu64\tinfo;\n\tstruct {\n\t\tu8\t\tuid[SMC_LGR_ID_SIZE];\n\t\tunsigned short\tvlan_id;\n\t\tu16\t\tcode;\n\t};\n};\n\nstatic void smcd_handle_sw_event(struct smc_ism_event_work *wrk)\n{\n\tunion smcd_sw_event_info ev_info;\n\n\tev_info.info = wrk->event.info;\n\tswitch (wrk->event.code) {\n\tcase ISM_EVENT_CODE_SHUTDOWN:\t \n\t\tsmc_smcd_terminate(wrk->smcd, wrk->event.tok, ev_info.vlan_id);\n\t\tbreak;\n\tcase ISM_EVENT_CODE_TESTLINK:\t \n\t\tif (ev_info.code == ISM_EVENT_REQUEST) {\n\t\t\tev_info.code = ISM_EVENT_RESPONSE;\n\t\t\twrk->smcd->ops->signal_event(wrk->smcd,\n\t\t\t\t\t\t     wrk->event.tok,\n\t\t\t\t\t\t     ISM_EVENT_REQUEST_IR,\n\t\t\t\t\t\t     ISM_EVENT_CODE_TESTLINK,\n\t\t\t\t\t\t     ev_info.info);\n\t\t\t}\n\t\tbreak;\n\t}\n}\n\n \nstatic void smc_ism_event_work(struct work_struct *work)\n{\n\tstruct smc_ism_event_work *wrk =\n\t\tcontainer_of(work, struct smc_ism_event_work, work);\n\n\tswitch (wrk->event.type) {\n\tcase ISM_EVENT_GID:\t \n\t\tsmc_smcd_terminate(wrk->smcd, wrk->event.tok, VLAN_VID_MASK);\n\t\tbreak;\n\tcase ISM_EVENT_DMB:\n\t\tbreak;\n\tcase ISM_EVENT_SWR:\t \n\t\tsmcd_handle_sw_event(wrk);\n\t\tbreak;\n\t}\n\tkfree(wrk);\n}\n\nstatic struct smcd_dev *smcd_alloc_dev(struct device *parent, const char *name,\n\t\t\t\t       const struct smcd_ops *ops, int max_dmbs)\n{\n\tstruct smcd_dev *smcd;\n\n\tsmcd = devm_kzalloc(parent, sizeof(*smcd), GFP_KERNEL);\n\tif (!smcd)\n\t\treturn NULL;\n\tsmcd->conn = devm_kcalloc(parent, max_dmbs,\n\t\t\t\t  sizeof(struct smc_connection *), GFP_KERNEL);\n\tif (!smcd->conn)\n\t\treturn NULL;\n\n\tsmcd->event_wq = alloc_ordered_workqueue(\"ism_evt_wq-%s)\",\n\t\t\t\t\t\t WQ_MEM_RECLAIM, name);\n\tif (!smcd->event_wq)\n\t\treturn NULL;\n\n\tsmcd->ops = ops;\n\n\tspin_lock_init(&smcd->lock);\n\tspin_lock_init(&smcd->lgr_lock);\n\tINIT_LIST_HEAD(&smcd->vlan);\n\tINIT_LIST_HEAD(&smcd->lgr_list);\n\tinit_waitqueue_head(&smcd->lgrs_deleted);\n\treturn smcd;\n}\n\nstatic void smcd_register_dev(struct ism_dev *ism)\n{\n\tconst struct smcd_ops *ops = ism_get_smcd_ops();\n\tstruct smcd_dev *smcd;\n\n\tif (!ops)\n\t\treturn;\n\n\tsmcd = smcd_alloc_dev(&ism->pdev->dev, dev_name(&ism->pdev->dev), ops,\n\t\t\t      ISM_NR_DMBS);\n\tif (!smcd)\n\t\treturn;\n\tsmcd->priv = ism;\n\tism_set_priv(ism, &smc_ism_client, smcd);\n\tif (smc_pnetid_by_dev_port(&ism->pdev->dev, 0, smcd->pnetid))\n\t\tsmc_pnetid_by_table_smcd(smcd);\n\n\tmutex_lock(&smcd_dev_list.mutex);\n\tif (list_empty(&smcd_dev_list.list)) {\n\t\tu8 *system_eid = NULL;\n\n\t\tsystem_eid = smcd->ops->get_system_eid();\n\t\tif (smcd->ops->supports_v2()) {\n\t\t\tsmc_ism_v2_capable = true;\n\t\t\tmemcpy(smc_ism_v2_system_eid, system_eid,\n\t\t\t       SMC_MAX_EID_LEN);\n\t\t}\n\t}\n\t \n\tif (smcd->pnetid[0])\n\t\tlist_add_tail(&smcd->list, &smcd_dev_list.list);\n\telse\n\t\tlist_add(&smcd->list, &smcd_dev_list.list);\n\tmutex_unlock(&smcd_dev_list.mutex);\n\n\tpr_warn_ratelimited(\"smc: adding smcd device %s with pnetid %.16s%s\\n\",\n\t\t\t    dev_name(&ism->dev), smcd->pnetid,\n\t\t\t    smcd->pnetid_by_user ? \" (user defined)\" : \"\");\n\n\treturn;\n}\n\nstatic void smcd_unregister_dev(struct ism_dev *ism)\n{\n\tstruct smcd_dev *smcd = ism_get_priv(ism, &smc_ism_client);\n\n\tpr_warn_ratelimited(\"smc: removing smcd device %s\\n\",\n\t\t\t    dev_name(&ism->dev));\n\tsmcd->going_away = 1;\n\tsmc_smcd_terminate_all(smcd);\n\tmutex_lock(&smcd_dev_list.mutex);\n\tlist_del_init(&smcd->list);\n\tmutex_unlock(&smcd_dev_list.mutex);\n\tdestroy_workqueue(smcd->event_wq);\n}\n\n \nstatic void smcd_handle_event(struct ism_dev *ism, struct ism_event *event)\n{\n\tstruct smcd_dev *smcd = ism_get_priv(ism, &smc_ism_client);\n\tstruct smc_ism_event_work *wrk;\n\n\tif (smcd->going_away)\n\t\treturn;\n\t \n\twrk = kmalloc(sizeof(*wrk), GFP_ATOMIC);\n\tif (!wrk)\n\t\treturn;\n\tINIT_WORK(&wrk->work, smc_ism_event_work);\n\twrk->smcd = smcd;\n\twrk->event = *event;\n\tqueue_work(smcd->event_wq, &wrk->work);\n}\n\n \nstatic void smcd_handle_irq(struct ism_dev *ism, unsigned int dmbno,\n\t\t\t    u16 dmbemask)\n{\n\tstruct smcd_dev *smcd = ism_get_priv(ism, &smc_ism_client);\n\tstruct smc_connection *conn = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&smcd->lock, flags);\n\tconn = smcd->conn[dmbno];\n\tif (conn && !conn->killed)\n\t\ttasklet_schedule(&conn->rx_tsklet);\n\tspin_unlock_irqrestore(&smcd->lock, flags);\n}\n#endif\n\nint smc_ism_signal_shutdown(struct smc_link_group *lgr)\n{\n\tint rc = 0;\n#if IS_ENABLED(CONFIG_ISM)\n\tunion smcd_sw_event_info ev_info;\n\n\tif (lgr->peer_shutdown)\n\t\treturn 0;\n\n\tmemcpy(ev_info.uid, lgr->id, SMC_LGR_ID_SIZE);\n\tev_info.vlan_id = lgr->vlan_id;\n\tev_info.code = ISM_EVENT_REQUEST;\n\trc = lgr->smcd->ops->signal_event(lgr->smcd, lgr->peer_gid,\n\t\t\t\t\t  ISM_EVENT_REQUEST_IR,\n\t\t\t\t\t  ISM_EVENT_CODE_SHUTDOWN,\n\t\t\t\t\t  ev_info.info);\n#endif\n\treturn rc;\n}\n\nint smc_ism_init(void)\n{\n\tint rc = 0;\n\n#if IS_ENABLED(CONFIG_ISM)\n\tsmc_ism_v2_capable = false;\n\tmemset(smc_ism_v2_system_eid, 0, SMC_MAX_EID_LEN);\n\n\trc = ism_register_client(&smc_ism_client);\n#endif\n\treturn rc;\n}\n\nvoid smc_ism_exit(void)\n{\n#if IS_ENABLED(CONFIG_ISM)\n\tism_unregister_client(&smc_ism_client);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}