{
  "module_name": "smc_pnet.c",
  "hash_id": "7f54263e342ab9947dc59eb69c71af6ed79d6b9a26d9868b0b430fa613046b09",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_pnet.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <net/netlink.h>\n#include <net/genetlink.h>\n\n#include <uapi/linux/if.h>\n#include <uapi/linux/smc.h>\n\n#include <rdma/ib_verbs.h>\n\n#include <net/netns/generic.h>\n#include \"smc_netns.h\"\n\n#include \"smc_pnet.h\"\n#include \"smc_ib.h\"\n#include \"smc_ism.h\"\n#include \"smc_core.h\"\n\nstatic struct net_device *__pnet_find_base_ndev(struct net_device *ndev);\nstatic struct net_device *pnet_find_base_ndev(struct net_device *ndev);\n\nstatic const struct nla_policy smc_pnet_policy[SMC_PNETID_MAX + 1] = {\n\t[SMC_PNETID_NAME] = {\n\t\t.type = NLA_NUL_STRING,\n\t\t.len = SMC_MAX_PNETID_LEN\n\t},\n\t[SMC_PNETID_ETHNAME] = {\n\t\t.type = NLA_NUL_STRING,\n\t\t.len = IFNAMSIZ - 1\n\t},\n\t[SMC_PNETID_IBNAME] = {\n\t\t.type = NLA_NUL_STRING,\n\t\t.len = IB_DEVICE_NAME_MAX - 1\n\t},\n\t[SMC_PNETID_IBPORT] = { .type = NLA_U8 }\n};\n\nstatic struct genl_family smc_pnet_nl_family;\n\nenum smc_pnet_nametype {\n\tSMC_PNET_ETH\t= 1,\n\tSMC_PNET_IB\t= 2,\n};\n\n \nstruct smc_pnetentry {\n\tstruct list_head list;\n\tchar pnet_name[SMC_MAX_PNETID_LEN + 1];\n\tenum smc_pnet_nametype type;\n\tunion {\n\t\tstruct {\n\t\t\tchar eth_name[IFNAMSIZ + 1];\n\t\t\tstruct net_device *ndev;\n\t\t\tnetdevice_tracker dev_tracker;\n\t\t};\n\t\tstruct {\n\t\t\tchar ib_name[IB_DEVICE_NAME_MAX + 1];\n\t\t\tu8 ib_port;\n\t\t};\n\t};\n};\n\n \nbool smc_pnet_is_pnetid_set(u8 *pnetid)\n{\n\tif (pnetid[0] == 0 || pnetid[0] == _S)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic bool smc_pnet_match(u8 *pnetid1, u8 *pnetid2)\n{\n\tint i;\n\n\tfor (i = 0; i < SMC_MAX_PNETID_LEN; i++) {\n\t\tif ((pnetid1[i] == 0 || pnetid1[i] == _S) &&\n\t\t    (pnetid2[i] == 0 || pnetid2[i] == _S))\n\t\t\tbreak;\n\t\tif (pnetid1[i] != pnetid2[i])\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic int smc_pnet_remove_by_pnetid(struct net *net, char *pnet_name)\n{\n\tstruct smc_pnetentry *pnetelem, *tmp_pe;\n\tstruct smc_pnettable *pnettable;\n\tstruct smc_ib_device *ibdev;\n\tstruct smcd_dev *smcd;\n\tstruct smc_net *sn;\n\tint rc = -ENOENT;\n\tint ibport;\n\n\t \n\tsn = net_generic(net, smc_net_id);\n\tpnettable = &sn->pnettable;\n\n\t \n\tmutex_lock(&pnettable->lock);\n\tlist_for_each_entry_safe(pnetelem, tmp_pe, &pnettable->pnetlist,\n\t\t\t\t list) {\n\t\tif (!pnet_name ||\n\t\t    smc_pnet_match(pnetelem->pnet_name, pnet_name)) {\n\t\t\tlist_del(&pnetelem->list);\n\t\t\tif (pnetelem->type == SMC_PNET_ETH && pnetelem->ndev) {\n\t\t\t\tnetdev_put(pnetelem->ndev,\n\t\t\t\t\t   &pnetelem->dev_tracker);\n\t\t\t\tpr_warn_ratelimited(\"smc: net device %s \"\n\t\t\t\t\t\t    \"erased user defined \"\n\t\t\t\t\t\t    \"pnetid %.16s\\n\",\n\t\t\t\t\t\t    pnetelem->eth_name,\n\t\t\t\t\t\t    pnetelem->pnet_name);\n\t\t\t}\n\t\t\tkfree(pnetelem);\n\t\t\trc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&pnettable->lock);\n\n\t \n\tif (net != &init_net)\n\t\treturn rc;\n\n\t \n\tmutex_lock(&smc_ib_devices.mutex);\n\tlist_for_each_entry(ibdev, &smc_ib_devices.list, list) {\n\t\tfor (ibport = 0; ibport < SMC_MAX_PORTS; ibport++) {\n\t\t\tif (ibdev->pnetid_by_user[ibport] &&\n\t\t\t    (!pnet_name ||\n\t\t\t     smc_pnet_match(pnet_name,\n\t\t\t\t\t    ibdev->pnetid[ibport]))) {\n\t\t\t\tpr_warn_ratelimited(\"smc: ib device %s ibport \"\n\t\t\t\t\t\t    \"%d erased user defined \"\n\t\t\t\t\t\t    \"pnetid %.16s\\n\",\n\t\t\t\t\t\t    ibdev->ibdev->name,\n\t\t\t\t\t\t    ibport + 1,\n\t\t\t\t\t\t    ibdev->pnetid[ibport]);\n\t\t\t\tmemset(ibdev->pnetid[ibport], 0,\n\t\t\t\t       SMC_MAX_PNETID_LEN);\n\t\t\t\tibdev->pnetid_by_user[ibport] = false;\n\t\t\t\trc = 0;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&smc_ib_devices.mutex);\n\t \n\tmutex_lock(&smcd_dev_list.mutex);\n\tlist_for_each_entry(smcd, &smcd_dev_list.list, list) {\n\t\tif (smcd->pnetid_by_user &&\n\t\t    (!pnet_name ||\n\t\t     smc_pnet_match(pnet_name, smcd->pnetid))) {\n\t\t\tpr_warn_ratelimited(\"smc: smcd device %s \"\n\t\t\t\t\t    \"erased user defined pnetid \"\n\t\t\t\t\t    \"%.16s\\n\",\n\t\t\t\t\t    dev_name(smcd->ops->get_dev(smcd)),\n\t\t\t\t\t    smcd->pnetid);\n\t\t\tmemset(smcd->pnetid, 0, SMC_MAX_PNETID_LEN);\n\t\t\tsmcd->pnetid_by_user = false;\n\t\t\trc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&smcd_dev_list.mutex);\n\treturn rc;\n}\n\n \nstatic int smc_pnet_add_by_ndev(struct net_device *ndev)\n{\n\tstruct smc_pnetentry *pnetelem, *tmp_pe;\n\tstruct smc_pnettable *pnettable;\n\tstruct net *net = dev_net(ndev);\n\tstruct smc_net *sn;\n\tint rc = -ENOENT;\n\n\t \n\tsn = net_generic(net, smc_net_id);\n\tpnettable = &sn->pnettable;\n\n\tmutex_lock(&pnettable->lock);\n\tlist_for_each_entry_safe(pnetelem, tmp_pe, &pnettable->pnetlist, list) {\n\t\tif (pnetelem->type == SMC_PNET_ETH && !pnetelem->ndev &&\n\t\t    !strncmp(pnetelem->eth_name, ndev->name, IFNAMSIZ)) {\n\t\t\tnetdev_hold(ndev, &pnetelem->dev_tracker, GFP_ATOMIC);\n\t\t\tpnetelem->ndev = ndev;\n\t\t\trc = 0;\n\t\t\tpr_warn_ratelimited(\"smc: adding net device %s with \"\n\t\t\t\t\t    \"user defined pnetid %.16s\\n\",\n\t\t\t\t\t    pnetelem->eth_name,\n\t\t\t\t\t    pnetelem->pnet_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&pnettable->lock);\n\treturn rc;\n}\n\n \nstatic int smc_pnet_remove_by_ndev(struct net_device *ndev)\n{\n\tstruct smc_pnetentry *pnetelem, *tmp_pe;\n\tstruct smc_pnettable *pnettable;\n\tstruct net *net = dev_net(ndev);\n\tstruct smc_net *sn;\n\tint rc = -ENOENT;\n\n\t \n\tsn = net_generic(net, smc_net_id);\n\tpnettable = &sn->pnettable;\n\n\tmutex_lock(&pnettable->lock);\n\tlist_for_each_entry_safe(pnetelem, tmp_pe, &pnettable->pnetlist, list) {\n\t\tif (pnetelem->type == SMC_PNET_ETH && pnetelem->ndev == ndev) {\n\t\t\tnetdev_put(pnetelem->ndev, &pnetelem->dev_tracker);\n\t\t\tpnetelem->ndev = NULL;\n\t\t\trc = 0;\n\t\t\tpr_warn_ratelimited(\"smc: removing net device %s with \"\n\t\t\t\t\t    \"user defined pnetid %.16s\\n\",\n\t\t\t\t\t    pnetelem->eth_name,\n\t\t\t\t\t    pnetelem->pnet_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&pnettable->lock);\n\treturn rc;\n}\n\n \nstatic bool smc_pnet_apply_ib(struct smc_ib_device *ib_dev, u8 ib_port,\n\t\t\t      char *pnet_name)\n{\n\tbool applied = false;\n\n\tmutex_lock(&smc_ib_devices.mutex);\n\tif (!smc_pnet_is_pnetid_set(ib_dev->pnetid[ib_port - 1])) {\n\t\tmemcpy(ib_dev->pnetid[ib_port - 1], pnet_name,\n\t\t       SMC_MAX_PNETID_LEN);\n\t\tib_dev->pnetid_by_user[ib_port - 1] = true;\n\t\tapplied = true;\n\t}\n\tmutex_unlock(&smc_ib_devices.mutex);\n\treturn applied;\n}\n\n \nstatic bool smc_pnet_apply_smcd(struct smcd_dev *smcd_dev, char *pnet_name)\n{\n\tbool applied = false;\n\n\tmutex_lock(&smcd_dev_list.mutex);\n\tif (!smc_pnet_is_pnetid_set(smcd_dev->pnetid)) {\n\t\tmemcpy(smcd_dev->pnetid, pnet_name, SMC_MAX_PNETID_LEN);\n\t\tsmcd_dev->pnetid_by_user = true;\n\t\tapplied = true;\n\t}\n\tmutex_unlock(&smcd_dev_list.mutex);\n\treturn applied;\n}\n\n \nstatic bool smc_pnetid_valid(const char *pnet_name, char *pnetid)\n{\n\tchar *bf = skip_spaces(pnet_name);\n\tsize_t len = strlen(bf);\n\tchar *end = bf + len;\n\n\tif (!len)\n\t\treturn false;\n\twhile (--end >= bf && isspace(*end))\n\t\t;\n\tif (end - bf >= SMC_MAX_PNETID_LEN)\n\t\treturn false;\n\twhile (bf <= end) {\n\t\tif (!isalnum(*bf))\n\t\t\treturn false;\n\t\t*pnetid++ = islower(*bf) ? toupper(*bf) : *bf;\n\t\tbf++;\n\t}\n\t*pnetid = '\\0';\n\treturn true;\n}\n\n \nstatic struct smc_ib_device *smc_pnet_find_ib(char *ib_name)\n{\n\tstruct smc_ib_device *ibdev;\n\n\tmutex_lock(&smc_ib_devices.mutex);\n\tlist_for_each_entry(ibdev, &smc_ib_devices.list, list) {\n\t\tif (!strncmp(ibdev->ibdev->name, ib_name,\n\t\t\t     sizeof(ibdev->ibdev->name)) ||\n\t\t    (ibdev->ibdev->dev.parent &&\n\t\t     !strncmp(dev_name(ibdev->ibdev->dev.parent), ib_name,\n\t\t\t     IB_DEVICE_NAME_MAX - 1))) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\tibdev = NULL;\nout:\n\tmutex_unlock(&smc_ib_devices.mutex);\n\treturn ibdev;\n}\n\n \nstatic struct smcd_dev *smc_pnet_find_smcd(char *smcd_name)\n{\n\tstruct smcd_dev *smcd_dev;\n\n\tmutex_lock(&smcd_dev_list.mutex);\n\tlist_for_each_entry(smcd_dev, &smcd_dev_list.list, list) {\n\t\tif (!strncmp(dev_name(smcd_dev->ops->get_dev(smcd_dev)),\n\t\t\t     smcd_name, IB_DEVICE_NAME_MAX - 1))\n\t\t\tgoto out;\n\t}\n\tsmcd_dev = NULL;\nout:\n\tmutex_unlock(&smcd_dev_list.mutex);\n\treturn smcd_dev;\n}\n\nstatic int smc_pnet_add_eth(struct smc_pnettable *pnettable, struct net *net,\n\t\t\t    char *eth_name, char *pnet_name)\n{\n\tstruct smc_pnetentry *tmp_pe, *new_pe;\n\tstruct net_device *ndev, *base_ndev;\n\tu8 ndev_pnetid[SMC_MAX_PNETID_LEN];\n\tbool new_netdev;\n\tint rc;\n\n\t \n\trc = -EEXIST;\n\tndev = dev_get_by_name(net, eth_name);\t \n\tif (ndev) {\n\t\tbase_ndev = pnet_find_base_ndev(ndev);\n\t\tif (!smc_pnetid_by_dev_port(base_ndev->dev.parent,\n\t\t\t\t\t    base_ndev->dev_port, ndev_pnetid))\n\t\t\tgoto out_put;\n\t}\n\n\t \n\trc = -ENOMEM;\n\tnew_pe = kzalloc(sizeof(*new_pe), GFP_KERNEL);\n\tif (!new_pe)\n\t\tgoto out_put;\n\tnew_pe->type = SMC_PNET_ETH;\n\tmemcpy(new_pe->pnet_name, pnet_name, SMC_MAX_PNETID_LEN);\n\tstrncpy(new_pe->eth_name, eth_name, IFNAMSIZ);\n\trc = -EEXIST;\n\tnew_netdev = true;\n\tmutex_lock(&pnettable->lock);\n\tlist_for_each_entry(tmp_pe, &pnettable->pnetlist, list) {\n\t\tif (tmp_pe->type == SMC_PNET_ETH &&\n\t\t    !strncmp(tmp_pe->eth_name, eth_name, IFNAMSIZ)) {\n\t\t\tnew_netdev = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (new_netdev) {\n\t\tif (ndev) {\n\t\t\tnew_pe->ndev = ndev;\n\t\t\tnetdev_tracker_alloc(ndev, &new_pe->dev_tracker,\n\t\t\t\t\t     GFP_ATOMIC);\n\t\t}\n\t\tlist_add_tail(&new_pe->list, &pnettable->pnetlist);\n\t\tmutex_unlock(&pnettable->lock);\n\t} else {\n\t\tmutex_unlock(&pnettable->lock);\n\t\tkfree(new_pe);\n\t\tgoto out_put;\n\t}\n\tif (ndev)\n\t\tpr_warn_ratelimited(\"smc: net device %s \"\n\t\t\t\t    \"applied user defined pnetid %.16s\\n\",\n\t\t\t\t    new_pe->eth_name, new_pe->pnet_name);\n\treturn 0;\n\nout_put:\n\tdev_put(ndev);\n\treturn rc;\n}\n\nstatic int smc_pnet_add_ib(struct smc_pnettable *pnettable, char *ib_name,\n\t\t\t   u8 ib_port, char *pnet_name)\n{\n\tstruct smc_pnetentry *tmp_pe, *new_pe;\n\tstruct smc_ib_device *ib_dev;\n\tbool smcddev_applied = true;\n\tbool ibdev_applied = true;\n\tstruct smcd_dev *smcd;\n\tstruct device *dev;\n\tbool new_ibdev;\n\n\t \n\tib_dev = smc_pnet_find_ib(ib_name);\n\tif (ib_dev) {\n\t\tibdev_applied = smc_pnet_apply_ib(ib_dev, ib_port, pnet_name);\n\t\tif (ibdev_applied)\n\t\t\tpr_warn_ratelimited(\"smc: ib device %s ibport %d \"\n\t\t\t\t\t    \"applied user defined pnetid \"\n\t\t\t\t\t    \"%.16s\\n\", ib_dev->ibdev->name,\n\t\t\t\t\t    ib_port,\n\t\t\t\t\t    ib_dev->pnetid[ib_port - 1]);\n\t}\n\tsmcd = smc_pnet_find_smcd(ib_name);\n\tif (smcd) {\n\t\tsmcddev_applied = smc_pnet_apply_smcd(smcd, pnet_name);\n\t\tif (smcddev_applied) {\n\t\t\tdev = smcd->ops->get_dev(smcd);\n\t\t\tpr_warn_ratelimited(\"smc: smcd device %s \"\n\t\t\t\t\t    \"applied user defined pnetid \"\n\t\t\t\t\t    \"%.16s\\n\", dev_name(dev),\n\t\t\t\t\t    smcd->pnetid);\n\t\t}\n\t}\n\t \n\tif (!ibdev_applied || !smcddev_applied)\n\t\treturn -EEXIST;\n\n\t \n\tnew_pe = kzalloc(sizeof(*new_pe), GFP_KERNEL);\n\tif (!new_pe)\n\t\treturn -ENOMEM;\n\tnew_pe->type = SMC_PNET_IB;\n\tmemcpy(new_pe->pnet_name, pnet_name, SMC_MAX_PNETID_LEN);\n\tstrncpy(new_pe->ib_name, ib_name, IB_DEVICE_NAME_MAX);\n\tnew_pe->ib_port = ib_port;\n\n\tnew_ibdev = true;\n\tmutex_lock(&pnettable->lock);\n\tlist_for_each_entry(tmp_pe, &pnettable->pnetlist, list) {\n\t\tif (tmp_pe->type == SMC_PNET_IB &&\n\t\t    !strncmp(tmp_pe->ib_name, ib_name, IB_DEVICE_NAME_MAX)) {\n\t\t\tnew_ibdev = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (new_ibdev) {\n\t\tlist_add_tail(&new_pe->list, &pnettable->pnetlist);\n\t\tmutex_unlock(&pnettable->lock);\n\t} else {\n\t\tmutex_unlock(&pnettable->lock);\n\t\tkfree(new_pe);\n\t}\n\treturn (new_ibdev) ? 0 : -EEXIST;\n}\n\n \nstatic int smc_pnet_enter(struct net *net, struct nlattr *tb[])\n{\n\tchar pnet_name[SMC_MAX_PNETID_LEN + 1];\n\tstruct smc_pnettable *pnettable;\n\tbool new_netdev = false;\n\tbool new_ibdev = false;\n\tstruct smc_net *sn;\n\tu8 ibport = 1;\n\tchar *string;\n\tint rc;\n\n\t \n\tsn = net_generic(net, smc_net_id);\n\tpnettable = &sn->pnettable;\n\n\trc = -EINVAL;\n\tif (!tb[SMC_PNETID_NAME])\n\t\tgoto error;\n\tstring = (char *)nla_data(tb[SMC_PNETID_NAME]);\n\tif (!smc_pnetid_valid(string, pnet_name))\n\t\tgoto error;\n\n\tif (tb[SMC_PNETID_ETHNAME]) {\n\t\tstring = (char *)nla_data(tb[SMC_PNETID_ETHNAME]);\n\t\trc = smc_pnet_add_eth(pnettable, net, string, pnet_name);\n\t\tif (!rc)\n\t\t\tnew_netdev = true;\n\t\telse if (rc != -EEXIST)\n\t\t\tgoto error;\n\t}\n\n\t \n\tif (net != &init_net)\n\t\treturn new_netdev ? 0 : -EEXIST;\n\n\trc = -EINVAL;\n\tif (tb[SMC_PNETID_IBNAME]) {\n\t\tstring = (char *)nla_data(tb[SMC_PNETID_IBNAME]);\n\t\tstring = strim(string);\n\t\tif (tb[SMC_PNETID_IBPORT]) {\n\t\t\tibport = nla_get_u8(tb[SMC_PNETID_IBPORT]);\n\t\t\tif (ibport < 1 || ibport > SMC_MAX_PORTS)\n\t\t\t\tgoto error;\n\t\t}\n\t\trc = smc_pnet_add_ib(pnettable, string, ibport, pnet_name);\n\t\tif (!rc)\n\t\t\tnew_ibdev = true;\n\t\telse if (rc != -EEXIST)\n\t\t\tgoto error;\n\t}\n\treturn (new_netdev || new_ibdev) ? 0 : -EEXIST;\n\nerror:\n\treturn rc;\n}\n\n \nstatic int smc_pnet_set_nla(struct sk_buff *msg,\n\t\t\t    struct smc_pnetentry *pnetelem)\n{\n\tif (nla_put_string(msg, SMC_PNETID_NAME, pnetelem->pnet_name))\n\t\treturn -1;\n\tif (pnetelem->type == SMC_PNET_ETH) {\n\t\tif (nla_put_string(msg, SMC_PNETID_ETHNAME,\n\t\t\t\t   pnetelem->eth_name))\n\t\t\treturn -1;\n\t} else {\n\t\tif (nla_put_string(msg, SMC_PNETID_ETHNAME, \"n/a\"))\n\t\t\treturn -1;\n\t}\n\tif (pnetelem->type == SMC_PNET_IB) {\n\t\tif (nla_put_string(msg, SMC_PNETID_IBNAME, pnetelem->ib_name) ||\n\t\t    nla_put_u8(msg, SMC_PNETID_IBPORT, pnetelem->ib_port))\n\t\t\treturn -1;\n\t} else {\n\t\tif (nla_put_string(msg, SMC_PNETID_IBNAME, \"n/a\") ||\n\t\t    nla_put_u8(msg, SMC_PNETID_IBPORT, 0xff))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int smc_pnet_add(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\n\treturn smc_pnet_enter(net, info->attrs);\n}\n\nstatic int smc_pnet_del(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\n\tif (!info->attrs[SMC_PNETID_NAME])\n\t\treturn -EINVAL;\n\treturn smc_pnet_remove_by_pnetid(net,\n\t\t\t\t(char *)nla_data(info->attrs[SMC_PNETID_NAME]));\n}\n\nstatic int smc_pnet_dump_start(struct netlink_callback *cb)\n{\n\tcb->args[0] = 0;\n\treturn 0;\n}\n\nstatic int smc_pnet_dumpinfo(struct sk_buff *skb,\n\t\t\t     u32 portid, u32 seq, u32 flags,\n\t\t\t     struct smc_pnetentry *pnetelem)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, portid, seq, &smc_pnet_nl_family,\n\t\t\t  flags, SMC_PNETID_GET);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\tif (smc_pnet_set_nla(skb, pnetelem) < 0) {\n\t\tgenlmsg_cancel(skb, hdr);\n\t\treturn -EMSGSIZE;\n\t}\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n}\n\nstatic int _smc_pnet_dump(struct net *net, struct sk_buff *skb, u32 portid,\n\t\t\t  u32 seq, u8 *pnetid, int start_idx)\n{\n\tstruct smc_pnettable *pnettable;\n\tstruct smc_pnetentry *pnetelem;\n\tstruct smc_net *sn;\n\tint idx = 0;\n\n\t \n\tsn = net_generic(net, smc_net_id);\n\tpnettable = &sn->pnettable;\n\n\t \n\tmutex_lock(&pnettable->lock);\n\tlist_for_each_entry(pnetelem, &pnettable->pnetlist, list) {\n\t\tif (pnetid && !smc_pnet_match(pnetelem->pnet_name, pnetid))\n\t\t\tcontinue;\n\t\tif (idx++ < start_idx)\n\t\t\tcontinue;\n\t\t \n\t\tif (net != &init_net && pnetelem->type != SMC_PNET_ETH)\n\t\t\tcontinue;\n\t\tif (smc_pnet_dumpinfo(skb, portid, seq, NLM_F_MULTI,\n\t\t\t\t      pnetelem)) {\n\t\t\t--idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&pnettable->lock);\n\treturn idx;\n}\n\nstatic int smc_pnet_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint idx;\n\n\tidx = _smc_pnet_dump(net, skb, NETLINK_CB(cb->skb).portid,\n\t\t\t     cb->nlh->nlmsg_seq, NULL, cb->args[0]);\n\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\n \nstatic int smc_pnet_get(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!info->attrs[SMC_PNETID_NAME])\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\t_smc_pnet_dump(net, msg, info->snd_portid, info->snd_seq,\n\t\t       nla_data(info->attrs[SMC_PNETID_NAME]), 0);\n\n\t \n\thdr = nlmsg_put(msg, info->snd_portid, info->snd_seq, NLMSG_DONE, 0,\n\t\t\tNLM_F_MULTI);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -EMSGSIZE;\n\t}\n\treturn genlmsg_reply(msg, info);\n}\n\n \nstatic int smc_pnet_flush(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\n\tsmc_pnet_remove_by_pnetid(net, NULL);\n\treturn 0;\n}\n\n \nstatic const struct genl_ops smc_pnet_ops[] = {\n\t{\n\t\t.cmd = SMC_PNETID_GET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t \n\t\t.doit = smc_pnet_get,\n\t\t.dumpit = smc_pnet_dump,\n\t\t.start = smc_pnet_dump_start\n\t},\n\t{\n\t\t.cmd = SMC_PNETID_ADD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.doit = smc_pnet_add\n\t},\n\t{\n\t\t.cmd = SMC_PNETID_DEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.doit = smc_pnet_del\n\t},\n\t{\n\t\t.cmd = SMC_PNETID_FLUSH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.doit = smc_pnet_flush\n\t}\n};\n\n \nstatic struct genl_family smc_pnet_nl_family __ro_after_init = {\n\t.hdrsize = 0,\n\t.name = SMCR_GENL_FAMILY_NAME,\n\t.version = SMCR_GENL_FAMILY_VERSION,\n\t.maxattr = SMC_PNETID_MAX,\n\t.policy = smc_pnet_policy,\n\t.netnsok = true,\n\t.module = THIS_MODULE,\n\t.ops = smc_pnet_ops,\n\t.n_ops =  ARRAY_SIZE(smc_pnet_ops),\n\t.resv_start_op = SMC_PNETID_FLUSH + 1,\n};\n\nbool smc_pnet_is_ndev_pnetid(struct net *net, u8 *pnetid)\n{\n\tstruct smc_net *sn = net_generic(net, smc_net_id);\n\tstruct smc_pnetids_ndev_entry *pe;\n\tbool rc = false;\n\n\tread_lock(&sn->pnetids_ndev.lock);\n\tlist_for_each_entry(pe, &sn->pnetids_ndev.list, list) {\n\t\tif (smc_pnet_match(pnetid, pe->pnetid)) {\n\t\t\trc = true;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\nunlock:\n\tread_unlock(&sn->pnetids_ndev.lock);\n\treturn rc;\n}\n\nstatic int smc_pnet_add_pnetid(struct net *net, u8 *pnetid)\n{\n\tstruct smc_net *sn = net_generic(net, smc_net_id);\n\tstruct smc_pnetids_ndev_entry *pe, *pi;\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\tif (!pe)\n\t\treturn -ENOMEM;\n\n\twrite_lock(&sn->pnetids_ndev.lock);\n\tlist_for_each_entry(pi, &sn->pnetids_ndev.list, list) {\n\t\tif (smc_pnet_match(pnetid, pe->pnetid)) {\n\t\t\trefcount_inc(&pi->refcnt);\n\t\t\tkfree(pe);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\trefcount_set(&pe->refcnt, 1);\n\tmemcpy(pe->pnetid, pnetid, SMC_MAX_PNETID_LEN);\n\tlist_add_tail(&pe->list, &sn->pnetids_ndev.list);\n\nunlock:\n\twrite_unlock(&sn->pnetids_ndev.lock);\n\treturn 0;\n}\n\nstatic void smc_pnet_remove_pnetid(struct net *net, u8 *pnetid)\n{\n\tstruct smc_net *sn = net_generic(net, smc_net_id);\n\tstruct smc_pnetids_ndev_entry *pe, *pe2;\n\n\twrite_lock(&sn->pnetids_ndev.lock);\n\tlist_for_each_entry_safe(pe, pe2, &sn->pnetids_ndev.list, list) {\n\t\tif (smc_pnet_match(pnetid, pe->pnetid)) {\n\t\t\tif (refcount_dec_and_test(&pe->refcnt)) {\n\t\t\t\tlist_del(&pe->list);\n\t\t\t\tkfree(pe);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\twrite_unlock(&sn->pnetids_ndev.lock);\n}\n\nstatic void smc_pnet_add_base_pnetid(struct net *net, struct net_device *dev,\n\t\t\t\t     u8 *ndev_pnetid)\n{\n\tstruct net_device *base_dev;\n\n\tbase_dev = __pnet_find_base_ndev(dev);\n\tif (base_dev->flags & IFF_UP &&\n\t    !smc_pnetid_by_dev_port(base_dev->dev.parent, base_dev->dev_port,\n\t\t\t\t    ndev_pnetid)) {\n\t\t \n\t\tsmc_pnet_add_pnetid(net, ndev_pnetid);\n\t}\n}\n\n \nstatic void smc_pnet_create_pnetids_list(struct net *net)\n{\n\tu8 ndev_pnetid[SMC_MAX_PNETID_LEN];\n\tstruct net_device *dev;\n\n\trtnl_lock();\n\tfor_each_netdev(net, dev)\n\t\tsmc_pnet_add_base_pnetid(net, dev, ndev_pnetid);\n\trtnl_unlock();\n}\n\n \nstatic void smc_pnet_destroy_pnetids_list(struct net *net)\n{\n\tstruct smc_net *sn = net_generic(net, smc_net_id);\n\tstruct smc_pnetids_ndev_entry *pe, *temp_pe;\n\n\twrite_lock(&sn->pnetids_ndev.lock);\n\tlist_for_each_entry_safe(pe, temp_pe, &sn->pnetids_ndev.list, list) {\n\t\tlist_del(&pe->list);\n\t\tkfree(pe);\n\t}\n\twrite_unlock(&sn->pnetids_ndev.lock);\n}\n\nstatic int smc_pnet_netdev_event(struct notifier_block *this,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *event_dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(event_dev);\n\tu8 ndev_pnetid[SMC_MAX_PNETID_LEN];\n\n\tswitch (event) {\n\tcase NETDEV_REBOOT:\n\tcase NETDEV_UNREGISTER:\n\t\tsmc_pnet_remove_by_ndev(event_dev);\n\t\tsmc_ib_ndev_change(event_dev, event);\n\t\treturn NOTIFY_OK;\n\tcase NETDEV_REGISTER:\n\t\tsmc_pnet_add_by_ndev(event_dev);\n\t\tsmc_ib_ndev_change(event_dev, event);\n\t\treturn NOTIFY_OK;\n\tcase NETDEV_UP:\n\t\tsmc_pnet_add_base_pnetid(net, event_dev, ndev_pnetid);\n\t\treturn NOTIFY_OK;\n\tcase NETDEV_DOWN:\n\t\tevent_dev = __pnet_find_base_ndev(event_dev);\n\t\tif (!smc_pnetid_by_dev_port(event_dev->dev.parent,\n\t\t\t\t\t    event_dev->dev_port, ndev_pnetid)) {\n\t\t\t \n\t\t\tsmc_pnet_remove_pnetid(net, ndev_pnetid);\n\t\t}\n\t\treturn NOTIFY_OK;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\nstatic struct notifier_block smc_netdev_notifier = {\n\t.notifier_call = smc_pnet_netdev_event\n};\n\n \nint smc_pnet_net_init(struct net *net)\n{\n\tstruct smc_net *sn = net_generic(net, smc_net_id);\n\tstruct smc_pnettable *pnettable = &sn->pnettable;\n\tstruct smc_pnetids_ndev *pnetids_ndev = &sn->pnetids_ndev;\n\n\tINIT_LIST_HEAD(&pnettable->pnetlist);\n\tmutex_init(&pnettable->lock);\n\tINIT_LIST_HEAD(&pnetids_ndev->list);\n\trwlock_init(&pnetids_ndev->lock);\n\n\tsmc_pnet_create_pnetids_list(net);\n\n\t \n\tnet->smc.limit_smc_hs = 0;\n\n\treturn 0;\n}\n\nint __init smc_pnet_init(void)\n{\n\tint rc;\n\n\trc = genl_register_family(&smc_pnet_nl_family);\n\tif (rc)\n\t\treturn rc;\n\trc = register_netdevice_notifier(&smc_netdev_notifier);\n\tif (rc)\n\t\tgenl_unregister_family(&smc_pnet_nl_family);\n\n\treturn rc;\n}\n\n \nvoid smc_pnet_net_exit(struct net *net)\n{\n\t \n\tsmc_pnet_remove_by_pnetid(net, NULL);\n\tsmc_pnet_destroy_pnetids_list(net);\n}\n\nvoid smc_pnet_exit(void)\n{\n\tunregister_netdevice_notifier(&smc_netdev_notifier);\n\tgenl_unregister_family(&smc_pnet_nl_family);\n}\n\nstatic struct net_device *__pnet_find_base_ndev(struct net_device *ndev)\n{\n\tint i, nest_lvl;\n\n\tASSERT_RTNL();\n\tnest_lvl = ndev->lower_level;\n\tfor (i = 0; i < nest_lvl; i++) {\n\t\tstruct list_head *lower = &ndev->adj_list.lower;\n\n\t\tif (list_empty(lower))\n\t\t\tbreak;\n\t\tlower = lower->next;\n\t\tndev = netdev_lower_get_next(ndev, &lower);\n\t}\n\treturn ndev;\n}\n\n \nstatic struct net_device *pnet_find_base_ndev(struct net_device *ndev)\n{\n\trtnl_lock();\n\tndev = __pnet_find_base_ndev(ndev);\n\trtnl_unlock();\n\treturn ndev;\n}\n\nstatic int smc_pnet_find_ndev_pnetid_by_table(struct net_device *ndev,\n\t\t\t\t\t      u8 *pnetid)\n{\n\tstruct smc_pnettable *pnettable;\n\tstruct net *net = dev_net(ndev);\n\tstruct smc_pnetentry *pnetelem;\n\tstruct smc_net *sn;\n\tint rc = -ENOENT;\n\n\t \n\tsn = net_generic(net, smc_net_id);\n\tpnettable = &sn->pnettable;\n\n\tmutex_lock(&pnettable->lock);\n\tlist_for_each_entry(pnetelem, &pnettable->pnetlist, list) {\n\t\tif (pnetelem->type == SMC_PNET_ETH && ndev == pnetelem->ndev) {\n\t\t\t \n\t\t\tmemcpy(pnetid, pnetelem->pnet_name, SMC_MAX_PNETID_LEN);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&pnettable->lock);\n\treturn rc;\n}\n\nstatic int smc_pnet_determine_gid(struct smc_ib_device *ibdev, int i,\n\t\t\t\t  struct smc_init_info *ini)\n{\n\tif (!ini->check_smcrv2 &&\n\t    !smc_ib_determine_gid(ibdev, i, ini->vlan_id, ini->ib_gid, NULL,\n\t\t\t\t  NULL)) {\n\t\tini->ib_dev = ibdev;\n\t\tini->ib_port = i;\n\t\treturn 0;\n\t}\n\tif (ini->check_smcrv2 &&\n\t    !smc_ib_determine_gid(ibdev, i, ini->vlan_id, ini->smcrv2.ib_gid_v2,\n\t\t\t\t  NULL, &ini->smcrv2)) {\n\t\tini->smcrv2.ib_dev_v2 = ibdev;\n\t\tini->smcrv2.ib_port_v2 = i;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\n \nstatic void _smc_pnet_find_roce_by_pnetid(u8 *pnet_id,\n\t\t\t\t\t  struct smc_init_info *ini,\n\t\t\t\t\t  struct smc_ib_device *known_dev,\n\t\t\t\t\t  struct net *net)\n{\n\tstruct smc_ib_device *ibdev;\n\tint i;\n\n\tmutex_lock(&smc_ib_devices.mutex);\n\tlist_for_each_entry(ibdev, &smc_ib_devices.list, list) {\n\t\tif (ibdev == known_dev ||\n\t\t    !rdma_dev_access_netns(ibdev->ibdev, net))\n\t\t\tcontinue;\n\t\tfor (i = 1; i <= SMC_MAX_PORTS; i++) {\n\t\t\tif (!rdma_is_port_valid(ibdev->ibdev, i))\n\t\t\t\tcontinue;\n\t\t\tif (smc_pnet_match(ibdev->pnetid[i - 1], pnet_id) &&\n\t\t\t    smc_ib_port_active(ibdev, i) &&\n\t\t\t    !test_bit(i - 1, ibdev->ports_going_away)) {\n\t\t\t\tif (!smc_pnet_determine_gid(ibdev, i, ini))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tmutex_unlock(&smc_ib_devices.mutex);\n}\n\n \nvoid smc_pnet_find_alt_roce(struct smc_link_group *lgr,\n\t\t\t    struct smc_init_info *ini,\n\t\t\t    struct smc_ib_device *known_dev)\n{\n\tstruct net *net = lgr->net;\n\n\t_smc_pnet_find_roce_by_pnetid(lgr->pnet_id, ini, known_dev, net);\n}\n\n \nstatic void smc_pnet_find_rdma_dev(struct net_device *netdev,\n\t\t\t\t   struct smc_init_info *ini)\n{\n\tstruct net *net = dev_net(netdev);\n\tstruct smc_ib_device *ibdev;\n\n\tmutex_lock(&smc_ib_devices.mutex);\n\tlist_for_each_entry(ibdev, &smc_ib_devices.list, list) {\n\t\tstruct net_device *ndev;\n\t\tint i;\n\n\t\t \n\t\tif (!rdma_dev_access_netns(ibdev->ibdev, net))\n\t\t\tcontinue;\n\n\t\tfor (i = 1; i <= SMC_MAX_PORTS; i++) {\n\t\t\tif (!rdma_is_port_valid(ibdev->ibdev, i))\n\t\t\t\tcontinue;\n\t\t\tif (!ibdev->ibdev->ops.get_netdev)\n\t\t\t\tcontinue;\n\t\t\tndev = ibdev->ibdev->ops.get_netdev(ibdev->ibdev, i);\n\t\t\tif (!ndev)\n\t\t\t\tcontinue;\n\t\t\tdev_put(ndev);\n\t\t\tif (netdev == ndev &&\n\t\t\t    smc_ib_port_active(ibdev, i) &&\n\t\t\t    !test_bit(i - 1, ibdev->ports_going_away)) {\n\t\t\t\tif (!smc_pnet_determine_gid(ibdev, i, ini))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&smc_ib_devices.mutex);\n}\n\n \nstatic void smc_pnet_find_roce_by_pnetid(struct net_device *ndev,\n\t\t\t\t\t struct smc_init_info *ini)\n{\n\tu8 ndev_pnetid[SMC_MAX_PNETID_LEN];\n\tstruct net *net;\n\n\tndev = pnet_find_base_ndev(ndev);\n\tnet = dev_net(ndev);\n\tif (smc_pnetid_by_dev_port(ndev->dev.parent, ndev->dev_port,\n\t\t\t\t   ndev_pnetid) &&\n\t    smc_pnet_find_ndev_pnetid_by_table(ndev, ndev_pnetid)) {\n\t\tsmc_pnet_find_rdma_dev(ndev, ini);\n\t\treturn;  \n\t}\n\t_smc_pnet_find_roce_by_pnetid(ndev_pnetid, ini, NULL, net);\n}\n\nstatic void smc_pnet_find_ism_by_pnetid(struct net_device *ndev,\n\t\t\t\t\tstruct smc_init_info *ini)\n{\n\tu8 ndev_pnetid[SMC_MAX_PNETID_LEN];\n\tstruct smcd_dev *ismdev;\n\n\tndev = pnet_find_base_ndev(ndev);\n\tif (smc_pnetid_by_dev_port(ndev->dev.parent, ndev->dev_port,\n\t\t\t\t   ndev_pnetid) &&\n\t    smc_pnet_find_ndev_pnetid_by_table(ndev, ndev_pnetid))\n\t\treturn;  \n\n\tmutex_lock(&smcd_dev_list.mutex);\n\tlist_for_each_entry(ismdev, &smcd_dev_list.list, list) {\n\t\tif (smc_pnet_match(ismdev->pnetid, ndev_pnetid) &&\n\t\t    !ismdev->going_away &&\n\t\t    (!ini->ism_peer_gid[0] ||\n\t\t     !smc_ism_cantalk(ini->ism_peer_gid[0], ini->vlan_id,\n\t\t\t\t      ismdev))) {\n\t\t\tini->ism_dev[0] = ismdev;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&smcd_dev_list.mutex);\n}\n\n \nvoid smc_pnet_find_roce_resource(struct sock *sk, struct smc_init_info *ini)\n{\n\tstruct dst_entry *dst = sk_dst_get(sk);\n\n\tif (!dst)\n\t\tgoto out;\n\tif (!dst->dev)\n\t\tgoto out_rel;\n\n\tsmc_pnet_find_roce_by_pnetid(dst->dev, ini);\n\nout_rel:\n\tdst_release(dst);\nout:\n\treturn;\n}\n\nvoid smc_pnet_find_ism_resource(struct sock *sk, struct smc_init_info *ini)\n{\n\tstruct dst_entry *dst = sk_dst_get(sk);\n\n\tini->ism_dev[0] = NULL;\n\tif (!dst)\n\t\tgoto out;\n\tif (!dst->dev)\n\t\tgoto out_rel;\n\n\tsmc_pnet_find_ism_by_pnetid(dst->dev, ini);\n\nout_rel:\n\tdst_release(dst);\nout:\n\treturn;\n}\n\n \nint smc_pnetid_by_table_ib(struct smc_ib_device *smcibdev, u8 ib_port)\n{\n\tchar *ib_name = smcibdev->ibdev->name;\n\tstruct smc_pnettable *pnettable;\n\tstruct smc_pnetentry *tmp_pe;\n\tstruct smc_net *sn;\n\tint rc = -ENOENT;\n\n\t \n\tsn = net_generic(&init_net, smc_net_id);\n\tpnettable = &sn->pnettable;\n\n\tmutex_lock(&pnettable->lock);\n\tlist_for_each_entry(tmp_pe, &pnettable->pnetlist, list) {\n\t\tif (tmp_pe->type == SMC_PNET_IB &&\n\t\t    !strncmp(tmp_pe->ib_name, ib_name, IB_DEVICE_NAME_MAX) &&\n\t\t    tmp_pe->ib_port == ib_port) {\n\t\t\tsmc_pnet_apply_ib(smcibdev, ib_port, tmp_pe->pnet_name);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&pnettable->lock);\n\n\treturn rc;\n}\n\n \nint smc_pnetid_by_table_smcd(struct smcd_dev *smcddev)\n{\n\tconst char *ib_name = dev_name(smcddev->ops->get_dev(smcddev));\n\tstruct smc_pnettable *pnettable;\n\tstruct smc_pnetentry *tmp_pe;\n\tstruct smc_net *sn;\n\tint rc = -ENOENT;\n\n\t \n\tsn = net_generic(&init_net, smc_net_id);\n\tpnettable = &sn->pnettable;\n\n\tmutex_lock(&pnettable->lock);\n\tlist_for_each_entry(tmp_pe, &pnettable->pnetlist, list) {\n\t\tif (tmp_pe->type == SMC_PNET_IB &&\n\t\t    !strncmp(tmp_pe->ib_name, ib_name, IB_DEVICE_NAME_MAX)) {\n\t\t\tsmc_pnet_apply_smcd(smcddev, tmp_pe->pnet_name);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&pnettable->lock);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}