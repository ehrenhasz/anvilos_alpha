{
  "module_name": "smc_clc.c",
  "hash_id": "7e93b693d31d32ac60348c8ac61f47c4a5412f8f3897b7cb51d1677d6017a69b",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_clc.c",
  "human_readable_source": "\n \n\n#include <linux/in.h>\n#include <linux/inetdevice.h>\n#include <linux/if_ether.h>\n#include <linux/sched/signal.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n\n#include <net/addrconf.h>\n#include <net/sock.h>\n#include <net/tcp.h>\n\n#include \"smc.h\"\n#include \"smc_core.h\"\n#include \"smc_clc.h\"\n#include \"smc_ib.h\"\n#include \"smc_ism.h\"\n#include \"smc_netlink.h\"\n\n#define SMCR_CLC_ACCEPT_CONFIRM_LEN 68\n#define SMCD_CLC_ACCEPT_CONFIRM_LEN 48\n#define SMCD_CLC_ACCEPT_CONFIRM_LEN_V2 78\n#define SMCR_CLC_ACCEPT_CONFIRM_LEN_V2 108\n#define SMC_CLC_RECV_BUF_LEN\t100\n\n \nstatic const char SMC_EYECATCHER[4] = {'\\xe2', '\\xd4', '\\xc3', '\\xd9'};\n \nstatic const char SMCD_EYECATCHER[4] = {'\\xe2', '\\xd4', '\\xc3', '\\xc4'};\n\nstatic u8 smc_hostname[SMC_MAX_HOSTNAME_LEN];\n\nstruct smc_clc_eid_table {\n\trwlock_t lock;\n\tstruct list_head list;\n\tu8 ueid_cnt;\n\tu8 seid_enabled;\n};\n\nstatic struct smc_clc_eid_table smc_clc_eid_table;\n\nstruct smc_clc_eid_entry {\n\tstruct list_head list;\n\tu8 eid[SMC_MAX_EID_LEN];\n};\n\n \nstatic bool smc_clc_ueid_valid(char *ueid)\n{\n\tchar *end = ueid + SMC_MAX_EID_LEN;\n\n\twhile (--end >= ueid && isspace(*end))\n\t\t;\n\tif (end < ueid)\n\t\treturn false;\n\tif (!isalnum(*ueid) || islower(*ueid))\n\t\treturn false;\n\twhile (ueid <= end) {\n\t\tif ((!isalnum(*ueid) || islower(*ueid)) && *ueid != '.' &&\n\t\t    *ueid != '-')\n\t\t\treturn false;\n\t\tueid++;\n\t}\n\treturn true;\n}\n\nstatic int smc_clc_ueid_add(char *ueid)\n{\n\tstruct smc_clc_eid_entry *new_ueid, *tmp_ueid;\n\tint rc;\n\n\tif (!smc_clc_ueid_valid(ueid))\n\t\treturn -EINVAL;\n\n\t \n\tnew_ueid = kzalloc(sizeof(*new_ueid), GFP_KERNEL);\n\tif (!new_ueid)\n\t\treturn -ENOMEM;\n\tmemcpy(new_ueid->eid, ueid, SMC_MAX_EID_LEN);\n\n\twrite_lock(&smc_clc_eid_table.lock);\n\tif (smc_clc_eid_table.ueid_cnt >= SMC_MAX_UEID) {\n\t\trc = -ERANGE;\n\t\tgoto err_out;\n\t}\n\tlist_for_each_entry(tmp_ueid, &smc_clc_eid_table.list, list) {\n\t\tif (!memcmp(tmp_ueid->eid, ueid, SMC_MAX_EID_LEN)) {\n\t\t\trc = -EEXIST;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tlist_add_tail(&new_ueid->list, &smc_clc_eid_table.list);\n\tsmc_clc_eid_table.ueid_cnt++;\n\twrite_unlock(&smc_clc_eid_table.lock);\n\treturn 0;\n\nerr_out:\n\twrite_unlock(&smc_clc_eid_table.lock);\n\tkfree(new_ueid);\n\treturn rc;\n}\n\nint smc_clc_ueid_count(void)\n{\n\tint count;\n\n\tread_lock(&smc_clc_eid_table.lock);\n\tcount = smc_clc_eid_table.ueid_cnt;\n\tread_unlock(&smc_clc_eid_table.lock);\n\n\treturn count;\n}\n\nint smc_nl_add_ueid(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *nla_ueid = info->attrs[SMC_NLA_EID_TABLE_ENTRY];\n\tchar *ueid;\n\n\tif (!nla_ueid || nla_len(nla_ueid) != SMC_MAX_EID_LEN + 1)\n\t\treturn -EINVAL;\n\tueid = (char *)nla_data(nla_ueid);\n\n\treturn smc_clc_ueid_add(ueid);\n}\n\n \nstatic int smc_clc_ueid_remove(char *ueid)\n{\n\tstruct smc_clc_eid_entry *lst_ueid, *tmp_ueid;\n\tint rc = -ENOENT;\n\n\t \n\twrite_lock(&smc_clc_eid_table.lock);\n\tlist_for_each_entry_safe(lst_ueid, tmp_ueid, &smc_clc_eid_table.list,\n\t\t\t\t list) {\n\t\tif (!ueid || !memcmp(lst_ueid->eid, ueid, SMC_MAX_EID_LEN)) {\n\t\t\tlist_del(&lst_ueid->list);\n\t\t\tsmc_clc_eid_table.ueid_cnt--;\n\t\t\tkfree(lst_ueid);\n\t\t\trc = 0;\n\t\t}\n\t}\n\tif (!rc && !smc_clc_eid_table.ueid_cnt) {\n\t\tsmc_clc_eid_table.seid_enabled = 1;\n\t\trc = -EAGAIN;\t \n\t}\n\twrite_unlock(&smc_clc_eid_table.lock);\n\treturn rc;\n}\n\nint smc_nl_remove_ueid(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *nla_ueid = info->attrs[SMC_NLA_EID_TABLE_ENTRY];\n\tchar *ueid;\n\n\tif (!nla_ueid || nla_len(nla_ueid) != SMC_MAX_EID_LEN + 1)\n\t\treturn -EINVAL;\n\tueid = (char *)nla_data(nla_ueid);\n\n\treturn smc_clc_ueid_remove(ueid);\n}\n\nint smc_nl_flush_ueid(struct sk_buff *skb, struct genl_info *info)\n{\n\tsmc_clc_ueid_remove(NULL);\n\treturn 0;\n}\n\nstatic int smc_nl_ueid_dumpinfo(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t\tu32 flags, char *ueid)\n{\n\tchar ueid_str[SMC_MAX_EID_LEN + 1];\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, portid, seq, &smc_gen_nl_family,\n\t\t\t  flags, SMC_NETLINK_DUMP_UEID);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\tmemcpy(ueid_str, ueid, SMC_MAX_EID_LEN);\n\tueid_str[SMC_MAX_EID_LEN] = 0;\n\tif (nla_put_string(skb, SMC_NLA_EID_TABLE_ENTRY, ueid_str)) {\n\t\tgenlmsg_cancel(skb, hdr);\n\t\treturn -EMSGSIZE;\n\t}\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n}\n\nstatic int _smc_nl_ueid_dump(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t     int start_idx)\n{\n\tstruct smc_clc_eid_entry *lst_ueid;\n\tint idx = 0;\n\n\tread_lock(&smc_clc_eid_table.lock);\n\tlist_for_each_entry(lst_ueid, &smc_clc_eid_table.list, list) {\n\t\tif (idx++ < start_idx)\n\t\t\tcontinue;\n\t\tif (smc_nl_ueid_dumpinfo(skb, portid, seq, NLM_F_MULTI,\n\t\t\t\t\t lst_ueid->eid)) {\n\t\t\t--idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&smc_clc_eid_table.lock);\n\treturn idx;\n}\n\nint smc_nl_dump_ueid(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct smc_nl_dmp_ctx *cb_ctx = smc_nl_dmp_ctx(cb);\n\tint idx;\n\n\tidx = _smc_nl_ueid_dump(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, cb_ctx->pos[0]);\n\n\tcb_ctx->pos[0] = idx;\n\treturn skb->len;\n}\n\nint smc_nl_dump_seid(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct smc_nl_dmp_ctx *cb_ctx = smc_nl_dmp_ctx(cb);\n\tchar seid_str[SMC_MAX_EID_LEN + 1];\n\tu8 seid_enabled;\n\tvoid *hdr;\n\tu8 *seid;\n\n\tif (cb_ctx->pos[0])\n\t\treturn skb->len;\n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &smc_gen_nl_family, NLM_F_MULTI,\n\t\t\t  SMC_NETLINK_DUMP_SEID);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\tif (!smc_ism_is_v2_capable())\n\t\tgoto end;\n\n\tsmc_ism_get_system_eid(&seid);\n\tmemcpy(seid_str, seid, SMC_MAX_EID_LEN);\n\tseid_str[SMC_MAX_EID_LEN] = 0;\n\tif (nla_put_string(skb, SMC_NLA_SEID_ENTRY, seid_str))\n\t\tgoto err;\n\tread_lock(&smc_clc_eid_table.lock);\n\tseid_enabled = smc_clc_eid_table.seid_enabled;\n\tread_unlock(&smc_clc_eid_table.lock);\n\tif (nla_put_u8(skb, SMC_NLA_SEID_ENABLED, seid_enabled))\n\t\tgoto err;\nend:\n\tgenlmsg_end(skb, hdr);\n\tcb_ctx->pos[0]++;\n\treturn skb->len;\nerr:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nint smc_nl_enable_seid(struct sk_buff *skb, struct genl_info *info)\n{\n\twrite_lock(&smc_clc_eid_table.lock);\n\tsmc_clc_eid_table.seid_enabled = 1;\n\twrite_unlock(&smc_clc_eid_table.lock);\n\treturn 0;\n}\n\nint smc_nl_disable_seid(struct sk_buff *skb, struct genl_info *info)\n{\n\tint rc = 0;\n\n\twrite_lock(&smc_clc_eid_table.lock);\n\tif (!smc_clc_eid_table.ueid_cnt)\n\t\trc = -ENOENT;\n\telse\n\t\tsmc_clc_eid_table.seid_enabled = 0;\n\twrite_unlock(&smc_clc_eid_table.lock);\n\treturn rc;\n}\n\nstatic bool _smc_clc_match_ueid(u8 *peer_ueid)\n{\n\tstruct smc_clc_eid_entry *tmp_ueid;\n\n\tlist_for_each_entry(tmp_ueid, &smc_clc_eid_table.list, list) {\n\t\tif (!memcmp(tmp_ueid->eid, peer_ueid, SMC_MAX_EID_LEN))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool smc_clc_match_eid(u8 *negotiated_eid,\n\t\t       struct smc_clc_v2_extension *smc_v2_ext,\n\t\t       u8 *peer_eid, u8 *local_eid)\n{\n\tbool match = false;\n\tint i;\n\n\tnegotiated_eid[0] = 0;\n\tread_lock(&smc_clc_eid_table.lock);\n\tif (peer_eid && local_eid &&\n\t    smc_clc_eid_table.seid_enabled &&\n\t    smc_v2_ext->hdr.flag.seid &&\n\t    !memcmp(peer_eid, local_eid, SMC_MAX_EID_LEN)) {\n\t\tmemcpy(negotiated_eid, peer_eid, SMC_MAX_EID_LEN);\n\t\tmatch = true;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < smc_v2_ext->hdr.eid_cnt; i++) {\n\t\tif (_smc_clc_match_ueid(smc_v2_ext->user_eids[i])) {\n\t\t\tmemcpy(negotiated_eid, smc_v2_ext->user_eids[i],\n\t\t\t       SMC_MAX_EID_LEN);\n\t\t\tmatch = true;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tread_unlock(&smc_clc_eid_table.lock);\n\treturn match;\n}\n\n \nstatic bool smc_clc_msg_prop_valid(struct smc_clc_msg_proposal *pclc)\n{\n\tstruct smc_clc_msg_proposal_prefix *pclc_prfx;\n\tstruct smc_clc_smcd_v2_extension *smcd_v2_ext;\n\tstruct smc_clc_msg_hdr *hdr = &pclc->hdr;\n\tstruct smc_clc_v2_extension *v2_ext;\n\n\tv2_ext = smc_get_clc_v2_ext(pclc);\n\tpclc_prfx = smc_clc_proposal_get_prefix(pclc);\n\tif (hdr->version == SMC_V1) {\n\t\tif (hdr->typev1 == SMC_TYPE_N)\n\t\t\treturn false;\n\t\tif (ntohs(hdr->length) !=\n\t\t\tsizeof(*pclc) + ntohs(pclc->iparea_offset) +\n\t\t\tsizeof(*pclc_prfx) +\n\t\t\tpclc_prfx->ipv6_prefixes_cnt *\n\t\t\t\tsizeof(struct smc_clc_ipv6_prefix) +\n\t\t\tsizeof(struct smc_clc_msg_trail))\n\t\t\treturn false;\n\t} else {\n\t\tif (ntohs(hdr->length) !=\n\t\t\tsizeof(*pclc) +\n\t\t\tsizeof(struct smc_clc_msg_smcd) +\n\t\t\t(hdr->typev1 != SMC_TYPE_N ?\n\t\t\t\tsizeof(*pclc_prfx) +\n\t\t\t\tpclc_prfx->ipv6_prefixes_cnt *\n\t\t\t\tsizeof(struct smc_clc_ipv6_prefix) : 0) +\n\t\t\t(hdr->typev2 != SMC_TYPE_N ?\n\t\t\t\tsizeof(*v2_ext) +\n\t\t\t\tv2_ext->hdr.eid_cnt * SMC_MAX_EID_LEN : 0) +\n\t\t\t(smcd_indicated(hdr->typev2) ?\n\t\t\t\tsizeof(*smcd_v2_ext) + v2_ext->hdr.ism_gid_cnt *\n\t\t\t\t\tsizeof(struct smc_clc_smcd_gid_chid) :\n\t\t\t\t0) +\n\t\t\tsizeof(struct smc_clc_msg_trail))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic bool\nsmc_clc_msg_acc_conf_valid(struct smc_clc_msg_accept_confirm_v2 *clc_v2)\n{\n\tstruct smc_clc_msg_hdr *hdr = &clc_v2->hdr;\n\n\tif (hdr->typev1 != SMC_TYPE_R && hdr->typev1 != SMC_TYPE_D)\n\t\treturn false;\n\tif (hdr->version == SMC_V1) {\n\t\tif ((hdr->typev1 == SMC_TYPE_R &&\n\t\t     ntohs(hdr->length) != SMCR_CLC_ACCEPT_CONFIRM_LEN) ||\n\t\t    (hdr->typev1 == SMC_TYPE_D &&\n\t\t     ntohs(hdr->length) != SMCD_CLC_ACCEPT_CONFIRM_LEN))\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr->typev1 == SMC_TYPE_D &&\n\t\t    ntohs(hdr->length) < SMCD_CLC_ACCEPT_CONFIRM_LEN_V2)\n\t\t\treturn false;\n\t\tif (hdr->typev1 == SMC_TYPE_R &&\n\t\t    ntohs(hdr->length) < SMCR_CLC_ACCEPT_CONFIRM_LEN_V2)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic bool\nsmc_clc_msg_decl_valid(struct smc_clc_msg_decline *dclc)\n{\n\tstruct smc_clc_msg_hdr *hdr = &dclc->hdr;\n\n\tif (hdr->typev1 != SMC_TYPE_R && hdr->typev1 != SMC_TYPE_D)\n\t\treturn false;\n\tif (hdr->version == SMC_V1) {\n\t\tif (ntohs(hdr->length) != sizeof(struct smc_clc_msg_decline))\n\t\t\treturn false;\n\t} else {\n\t\tif (ntohs(hdr->length) != sizeof(struct smc_clc_msg_decline_v2))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int smc_clc_fill_fce(struct smc_clc_first_contact_ext_v2x *fce,\n\t\t\t    struct smc_init_info *ini)\n{\n\tint ret = sizeof(*fce);\n\n\tmemset(fce, 0, sizeof(*fce));\n\tfce->fce_v2_base.os_type = SMC_CLC_OS_LINUX;\n\tfce->fce_v2_base.release = ini->release_nr;\n\tmemcpy(fce->fce_v2_base.hostname, smc_hostname, sizeof(smc_hostname));\n\tif (ini->is_smcd && ini->release_nr < SMC_RELEASE_1) {\n\t\tret = sizeof(struct smc_clc_first_contact_ext);\n\t\tgoto out;\n\t}\n\n\tif (ini->release_nr >= SMC_RELEASE_1) {\n\t\tif (!ini->is_smcd) {\n\t\t\tfce->max_conns = ini->max_conns;\n\t\t\tfce->max_links = ini->max_links;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic bool smc_clc_msg_hdr_valid(struct smc_clc_msg_hdr *clcm, bool check_trl)\n{\n\tstruct smc_clc_msg_accept_confirm_v2 *clc_v2;\n\tstruct smc_clc_msg_proposal *pclc;\n\tstruct smc_clc_msg_decline *dclc;\n\tstruct smc_clc_msg_trail *trl;\n\n\tif (memcmp(clcm->eyecatcher, SMC_EYECATCHER, sizeof(SMC_EYECATCHER)) &&\n\t    memcmp(clcm->eyecatcher, SMCD_EYECATCHER, sizeof(SMCD_EYECATCHER)))\n\t\treturn false;\n\tswitch (clcm->type) {\n\tcase SMC_CLC_PROPOSAL:\n\t\tpclc = (struct smc_clc_msg_proposal *)clcm;\n\t\tif (!smc_clc_msg_prop_valid(pclc))\n\t\t\treturn false;\n\t\ttrl = (struct smc_clc_msg_trail *)\n\t\t\t((u8 *)pclc + ntohs(pclc->hdr.length) - sizeof(*trl));\n\t\tbreak;\n\tcase SMC_CLC_ACCEPT:\n\tcase SMC_CLC_CONFIRM:\n\t\tclc_v2 = (struct smc_clc_msg_accept_confirm_v2 *)clcm;\n\t\tif (!smc_clc_msg_acc_conf_valid(clc_v2))\n\t\t\treturn false;\n\t\ttrl = (struct smc_clc_msg_trail *)\n\t\t\t((u8 *)clc_v2 + ntohs(clc_v2->hdr.length) -\n\t\t\t\t\t\t\tsizeof(*trl));\n\t\tbreak;\n\tcase SMC_CLC_DECLINE:\n\t\tdclc = (struct smc_clc_msg_decline *)clcm;\n\t\tif (!smc_clc_msg_decl_valid(dclc))\n\t\t\treturn false;\n\t\tcheck_trl = false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\tif (check_trl &&\n\t    memcmp(trl->eyecatcher, SMC_EYECATCHER, sizeof(SMC_EYECATCHER)) &&\n\t    memcmp(trl->eyecatcher, SMCD_EYECATCHER, sizeof(SMCD_EYECATCHER)))\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic int smc_clc_prfx_set4_rcu(struct dst_entry *dst, __be32 ipv4,\n\t\t\t\t struct smc_clc_msg_proposal_prefix *prop)\n{\n\tstruct in_device *in_dev = __in_dev_get_rcu(dst->dev);\n\tconst struct in_ifaddr *ifa;\n\n\tif (!in_dev)\n\t\treturn -ENODEV;\n\n\tin_dev_for_each_ifa_rcu(ifa, in_dev) {\n\t\tif (!inet_ifa_match(ipv4, ifa))\n\t\t\tcontinue;\n\t\tprop->prefix_len = inet_mask_len(ifa->ifa_mask);\n\t\tprop->outgoing_subnet = ifa->ifa_address & ifa->ifa_mask;\n\t\t \n\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\n \nstatic int smc_clc_prfx_set6_rcu(struct dst_entry *dst,\n\t\t\t\t struct smc_clc_msg_proposal_prefix *prop,\n\t\t\t\t struct smc_clc_ipv6_prefix *ipv6_prfx)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct inet6_dev *in6_dev = __in6_dev_get(dst->dev);\n\tstruct inet6_ifaddr *ifa;\n\tint cnt = 0;\n\n\tif (!in6_dev)\n\t\treturn -ENODEV;\n\t \n\tlist_for_each_entry(ifa, &in6_dev->addr_list, if_list) {\n\t\tif (ipv6_addr_type(&ifa->addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tcontinue;\n\t\tipv6_addr_prefix(&ipv6_prfx[cnt].prefix,\n\t\t\t\t &ifa->addr, ifa->prefix_len);\n\t\tipv6_prfx[cnt].prefix_len = ifa->prefix_len;\n\t\tcnt++;\n\t\tif (cnt == SMC_CLC_MAX_V6_PREFIX)\n\t\t\tbreak;\n\t}\n\tprop->ipv6_prefixes_cnt = cnt;\n\tif (cnt)\n\t\treturn 0;\n#endif\n\treturn -ENOENT;\n}\n\n \nstatic int smc_clc_prfx_set(struct socket *clcsock,\n\t\t\t    struct smc_clc_msg_proposal_prefix *prop,\n\t\t\t    struct smc_clc_ipv6_prefix *ipv6_prfx)\n{\n\tstruct dst_entry *dst = sk_dst_get(clcsock->sk);\n\tstruct sockaddr_storage addrs;\n\tstruct sockaddr_in6 *addr6;\n\tstruct sockaddr_in *addr;\n\tint rc = -ENOENT;\n\n\tif (!dst) {\n\t\trc = -ENOTCONN;\n\t\tgoto out;\n\t}\n\tif (!dst->dev) {\n\t\trc = -ENODEV;\n\t\tgoto out_rel;\n\t}\n\t \n\tif (kernel_getsockname(clcsock, (struct sockaddr *)&addrs) < 0)\n\t\tgoto out_rel;\n\t \n\taddr6 = (struct sockaddr_in6 *)&addrs;\n\trcu_read_lock();\n\tif (addrs.ss_family == PF_INET) {\n\t\t \n\t\taddr = (struct sockaddr_in *)&addrs;\n\t\trc = smc_clc_prfx_set4_rcu(dst, addr->sin_addr.s_addr, prop);\n\t} else if (ipv6_addr_v4mapped(&addr6->sin6_addr)) {\n\t\t \n\t\trc = smc_clc_prfx_set4_rcu(dst, addr6->sin6_addr.s6_addr32[3],\n\t\t\t\t\t   prop);\n\t} else {\n\t\t \n\t\trc = smc_clc_prfx_set6_rcu(dst, prop, ipv6_prfx);\n\t}\n\trcu_read_unlock();\nout_rel:\n\tdst_release(dst);\nout:\n\treturn rc;\n}\n\n \nstatic int smc_clc_prfx_match4_rcu(struct net_device *dev,\n\t\t\t\t   struct smc_clc_msg_proposal_prefix *prop)\n{\n\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\tconst struct in_ifaddr *ifa;\n\n\tif (!in_dev)\n\t\treturn -ENODEV;\n\tin_dev_for_each_ifa_rcu(ifa, in_dev) {\n\t\tif (prop->prefix_len == inet_mask_len(ifa->ifa_mask) &&\n\t\t    inet_ifa_match(prop->outgoing_subnet, ifa))\n\t\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic int smc_clc_prfx_match6_rcu(struct net_device *dev,\n\t\t\t\t   struct smc_clc_msg_proposal_prefix *prop)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct inet6_dev *in6_dev = __in6_dev_get(dev);\n\tstruct smc_clc_ipv6_prefix *ipv6_prfx;\n\tstruct inet6_ifaddr *ifa;\n\tint i, max;\n\n\tif (!in6_dev)\n\t\treturn -ENODEV;\n\t \n\tipv6_prfx = (struct smc_clc_ipv6_prefix *)((u8 *)prop + sizeof(*prop));\n\tmax = min_t(u8, prop->ipv6_prefixes_cnt, SMC_CLC_MAX_V6_PREFIX);\n\tlist_for_each_entry(ifa, &in6_dev->addr_list, if_list) {\n\t\tif (ipv6_addr_type(&ifa->addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < max; i++) {\n\t\t\tif (ifa->prefix_len == ipv6_prfx[i].prefix_len &&\n\t\t\t    ipv6_prefix_equal(&ifa->addr, &ipv6_prfx[i].prefix,\n\t\t\t\t\t      ifa->prefix_len))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n#endif\n\treturn -ENOENT;\n}\n\n \nint smc_clc_prfx_match(struct socket *clcsock,\n\t\t       struct smc_clc_msg_proposal_prefix *prop)\n{\n\tstruct dst_entry *dst = sk_dst_get(clcsock->sk);\n\tint rc;\n\n\tif (!dst) {\n\t\trc = -ENOTCONN;\n\t\tgoto out;\n\t}\n\tif (!dst->dev) {\n\t\trc = -ENODEV;\n\t\tgoto out_rel;\n\t}\n\trcu_read_lock();\n\tif (!prop->ipv6_prefixes_cnt)\n\t\trc = smc_clc_prfx_match4_rcu(dst->dev, prop);\n\telse\n\t\trc = smc_clc_prfx_match6_rcu(dst->dev, prop);\n\trcu_read_unlock();\nout_rel:\n\tdst_release(dst);\nout:\n\treturn rc;\n}\n\n \nint smc_clc_wait_msg(struct smc_sock *smc, void *buf, int buflen,\n\t\t     u8 expected_type, unsigned long timeout)\n{\n\tlong rcvtimeo = smc->clcsock->sk->sk_rcvtimeo;\n\tstruct sock *clc_sk = smc->clcsock->sk;\n\tstruct smc_clc_msg_hdr *clcm = buf;\n\tstruct msghdr msg = {NULL, 0};\n\tint reason_code = 0;\n\tstruct kvec vec = {buf, buflen};\n\tint len, datlen, recvlen;\n\tbool check_trl = true;\n\tint krflags;\n\n\t \n\t \n\tkrflags = MSG_PEEK | MSG_WAITALL;\n\tclc_sk->sk_rcvtimeo = timeout;\n\tiov_iter_kvec(&msg.msg_iter, ITER_DEST, &vec, 1,\n\t\t\tsizeof(struct smc_clc_msg_hdr));\n\tlen = sock_recvmsg(smc->clcsock, &msg, krflags);\n\tif (signal_pending(current)) {\n\t\treason_code = -EINTR;\n\t\tclc_sk->sk_err = EINTR;\n\t\tsmc->sk.sk_err = EINTR;\n\t\tgoto out;\n\t}\n\tif (clc_sk->sk_err) {\n\t\treason_code = -clc_sk->sk_err;\n\t\tif (clc_sk->sk_err == EAGAIN &&\n\t\t    expected_type == SMC_CLC_DECLINE)\n\t\t\tclc_sk->sk_err = 0;  \n\t\telse\n\t\t\tsmc->sk.sk_err = clc_sk->sk_err;\n\t\tgoto out;\n\t}\n\tif (!len) {  \n\t\tsmc->sk.sk_err = ECONNRESET;\n\t\treason_code = -ECONNRESET;\n\t\tgoto out;\n\t}\n\tif (len < 0) {\n\t\tif (len != -EAGAIN || expected_type != SMC_CLC_DECLINE)\n\t\t\tsmc->sk.sk_err = -len;\n\t\treason_code = len;\n\t\tgoto out;\n\t}\n\tdatlen = ntohs(clcm->length);\n\tif ((len < sizeof(struct smc_clc_msg_hdr)) ||\n\t    (clcm->version < SMC_V1) ||\n\t    ((clcm->type != SMC_CLC_DECLINE) &&\n\t     (clcm->type != expected_type))) {\n\t\tsmc->sk.sk_err = EPROTO;\n\t\treason_code = -EPROTO;\n\t\tgoto out;\n\t}\n\n\t \n\tmemset(&msg, 0, sizeof(struct msghdr));\n\tif (datlen > buflen) {\n\t\tcheck_trl = false;\n\t\trecvlen = buflen;\n\t} else {\n\t\trecvlen = datlen;\n\t}\n\tiov_iter_kvec(&msg.msg_iter, ITER_DEST, &vec, 1, recvlen);\n\tkrflags = MSG_WAITALL;\n\tlen = sock_recvmsg(smc->clcsock, &msg, krflags);\n\tif (len < recvlen || !smc_clc_msg_hdr_valid(clcm, check_trl)) {\n\t\tsmc->sk.sk_err = EPROTO;\n\t\treason_code = -EPROTO;\n\t\tgoto out;\n\t}\n\tdatlen -= len;\n\twhile (datlen) {\n\t\tu8 tmp[SMC_CLC_RECV_BUF_LEN];\n\n\t\tvec.iov_base = &tmp;\n\t\tvec.iov_len = SMC_CLC_RECV_BUF_LEN;\n\t\t \n\t\trecvlen = datlen > SMC_CLC_RECV_BUF_LEN ?\n\t\t\t\t\t\tSMC_CLC_RECV_BUF_LEN : datlen;\n\t\tiov_iter_kvec(&msg.msg_iter, ITER_DEST, &vec, 1, recvlen);\n\t\tlen = sock_recvmsg(smc->clcsock, &msg, krflags);\n\t\tdatlen -= len;\n\t}\n\tif (clcm->type == SMC_CLC_DECLINE) {\n\t\tstruct smc_clc_msg_decline *dclc;\n\n\t\tdclc = (struct smc_clc_msg_decline *)clcm;\n\t\treason_code = SMC_CLC_DECL_PEERDECL;\n\t\tsmc->peer_diagnosis = ntohl(dclc->peer_diagnosis);\n\t\tif (((struct smc_clc_msg_decline *)buf)->hdr.typev2 &\n\t\t\t\t\t\tSMC_FIRST_CONTACT_MASK) {\n\t\t\tsmc->conn.lgr->sync_err = 1;\n\t\t\tsmc_lgr_terminate_sched(smc->conn.lgr);\n\t\t}\n\t}\n\nout:\n\tclc_sk->sk_rcvtimeo = rcvtimeo;\n\treturn reason_code;\n}\n\n \nint smc_clc_send_decline(struct smc_sock *smc, u32 peer_diag_info, u8 version)\n{\n\tstruct smc_clc_msg_decline *dclc_v1;\n\tstruct smc_clc_msg_decline_v2 dclc;\n\tstruct msghdr msg;\n\tint len, send_len;\n\tstruct kvec vec;\n\n\tdclc_v1 = (struct smc_clc_msg_decline *)&dclc;\n\tmemset(&dclc, 0, sizeof(dclc));\n\tmemcpy(dclc.hdr.eyecatcher, SMC_EYECATCHER, sizeof(SMC_EYECATCHER));\n\tdclc.hdr.type = SMC_CLC_DECLINE;\n\tdclc.hdr.version = version;\n\tdclc.os_type = version == SMC_V1 ? 0 : SMC_CLC_OS_LINUX;\n\tdclc.hdr.typev2 = (peer_diag_info == SMC_CLC_DECL_SYNCERR) ?\n\t\t\t\t\t\tSMC_FIRST_CONTACT_MASK : 0;\n\tif ((!smc_conn_lgr_valid(&smc->conn) || !smc->conn.lgr->is_smcd) &&\n\t    smc_ib_is_valid_local_systemid())\n\t\tmemcpy(dclc.id_for_peer, local_systemid,\n\t\t       sizeof(local_systemid));\n\tdclc.peer_diagnosis = htonl(peer_diag_info);\n\tif (version == SMC_V1) {\n\t\tmemcpy(dclc_v1->trl.eyecatcher, SMC_EYECATCHER,\n\t\t       sizeof(SMC_EYECATCHER));\n\t\tsend_len = sizeof(*dclc_v1);\n\t} else {\n\t\tmemcpy(dclc.trl.eyecatcher, SMC_EYECATCHER,\n\t\t       sizeof(SMC_EYECATCHER));\n\t\tsend_len = sizeof(dclc);\n\t}\n\tdclc.hdr.length = htons(send_len);\n\n\tmemset(&msg, 0, sizeof(msg));\n\tvec.iov_base = &dclc;\n\tvec.iov_len = send_len;\n\tlen = kernel_sendmsg(smc->clcsock, &msg, &vec, 1, send_len);\n\tif (len < 0 || len < send_len)\n\t\tlen = -EPROTO;\n\treturn len > 0 ? 0 : len;\n}\n\n \nint smc_clc_send_proposal(struct smc_sock *smc, struct smc_init_info *ini)\n{\n\tstruct smc_clc_smcd_v2_extension *smcd_v2_ext;\n\tstruct smc_clc_msg_proposal_prefix *pclc_prfx;\n\tstruct smc_clc_msg_proposal *pclc_base;\n\tstruct smc_clc_smcd_gid_chid *gidchids;\n\tstruct smc_clc_msg_proposal_area *pclc;\n\tstruct smc_clc_ipv6_prefix *ipv6_prfx;\n\tstruct smc_clc_v2_extension *v2_ext;\n\tstruct smc_clc_msg_smcd *pclc_smcd;\n\tstruct smc_clc_msg_trail *trl;\n\tstruct smcd_dev *smcd;\n\tint len, i, plen, rc;\n\tint reason_code = 0;\n\tstruct kvec vec[8];\n\tstruct msghdr msg;\n\n\tpclc = kzalloc(sizeof(*pclc), GFP_KERNEL);\n\tif (!pclc)\n\t\treturn -ENOMEM;\n\n\tpclc_base = &pclc->pclc_base;\n\tpclc_smcd = &pclc->pclc_smcd;\n\tpclc_prfx = &pclc->pclc_prfx;\n\tipv6_prfx = pclc->pclc_prfx_ipv6;\n\tv2_ext = &pclc->pclc_v2_ext;\n\tsmcd_v2_ext = &pclc->pclc_smcd_v2_ext;\n\tgidchids = pclc->pclc_gidchids;\n\ttrl = &pclc->pclc_trl;\n\n\tpclc_base->hdr.version = SMC_V2;\n\tpclc_base->hdr.typev1 = ini->smc_type_v1;\n\tpclc_base->hdr.typev2 = ini->smc_type_v2;\n\tplen = sizeof(*pclc_base) + sizeof(*pclc_smcd) + sizeof(*trl);\n\n\t \n\tif (ini->smc_type_v1 != SMC_TYPE_N) {\n\t\trc = smc_clc_prfx_set(smc->clcsock, pclc_prfx, ipv6_prfx);\n\t\tif (rc) {\n\t\t\tif (ini->smc_type_v2 == SMC_TYPE_N) {\n\t\t\t\tkfree(pclc);\n\t\t\t\treturn SMC_CLC_DECL_CNFERR;\n\t\t\t}\n\t\t\tpclc_base->hdr.typev1 = SMC_TYPE_N;\n\t\t} else {\n\t\t\tpclc_base->iparea_offset = htons(sizeof(*pclc_smcd));\n\t\t\tplen += sizeof(*pclc_prfx) +\n\t\t\t\t\tpclc_prfx->ipv6_prefixes_cnt *\n\t\t\t\t\tsizeof(ipv6_prfx[0]);\n\t\t}\n\t}\n\n\t \n\tmemcpy(pclc_base->hdr.eyecatcher, SMC_EYECATCHER,\n\t       sizeof(SMC_EYECATCHER));\n\tpclc_base->hdr.type = SMC_CLC_PROPOSAL;\n\tif (smcr_indicated(ini->smc_type_v1)) {\n\t\t \n\t\tmemcpy(pclc_base->lcl.id_for_peer, local_systemid,\n\t\t       sizeof(local_systemid));\n\t\tmemcpy(pclc_base->lcl.gid, ini->ib_gid, SMC_GID_SIZE);\n\t\tmemcpy(pclc_base->lcl.mac, &ini->ib_dev->mac[ini->ib_port - 1],\n\t\t       ETH_ALEN);\n\t}\n\tif (smcd_indicated(ini->smc_type_v1)) {\n\t\t \n\t\tif (ini->ism_dev[0]) {\n\t\t\tsmcd = ini->ism_dev[0];\n\t\t\tpclc_smcd->ism.gid =\n\t\t\t\thtonll(smcd->ops->get_local_gid(smcd));\n\t\t\tpclc_smcd->ism.chid =\n\t\t\t\thtons(smc_ism_get_chid(ini->ism_dev[0]));\n\t\t}\n\t}\n\tif (ini->smc_type_v2 == SMC_TYPE_N) {\n\t\tpclc_smcd->v2_ext_offset = 0;\n\t} else {\n\t\tstruct smc_clc_eid_entry *ueident;\n\t\tu16 v2_ext_offset;\n\n\t\tv2_ext->hdr.flag.release = SMC_RELEASE;\n\t\tv2_ext_offset = sizeof(*pclc_smcd) -\n\t\t\toffsetofend(struct smc_clc_msg_smcd, v2_ext_offset);\n\t\tif (ini->smc_type_v1 != SMC_TYPE_N)\n\t\t\tv2_ext_offset += sizeof(*pclc_prfx) +\n\t\t\t\t\t\tpclc_prfx->ipv6_prefixes_cnt *\n\t\t\t\t\t\tsizeof(ipv6_prfx[0]);\n\t\tpclc_smcd->v2_ext_offset = htons(v2_ext_offset);\n\t\tplen += sizeof(*v2_ext);\n\n\t\tread_lock(&smc_clc_eid_table.lock);\n\t\tv2_ext->hdr.eid_cnt = smc_clc_eid_table.ueid_cnt;\n\t\tplen += smc_clc_eid_table.ueid_cnt * SMC_MAX_EID_LEN;\n\t\ti = 0;\n\t\tlist_for_each_entry(ueident, &smc_clc_eid_table.list, list) {\n\t\t\tmemcpy(v2_ext->user_eids[i++], ueident->eid,\n\t\t\t       sizeof(ueident->eid));\n\t\t}\n\t\tread_unlock(&smc_clc_eid_table.lock);\n\t}\n\tif (smcd_indicated(ini->smc_type_v2)) {\n\t\tu8 *eid = NULL;\n\n\t\tv2_ext->hdr.flag.seid = smc_clc_eid_table.seid_enabled;\n\t\tv2_ext->hdr.ism_gid_cnt = ini->ism_offered_cnt;\n\t\tv2_ext->hdr.smcd_v2_ext_offset = htons(sizeof(*v2_ext) -\n\t\t\t\toffsetofend(struct smc_clnt_opts_area_hdr,\n\t\t\t\t\t    smcd_v2_ext_offset) +\n\t\t\t\tv2_ext->hdr.eid_cnt * SMC_MAX_EID_LEN);\n\t\tsmc_ism_get_system_eid(&eid);\n\t\tif (eid && v2_ext->hdr.flag.seid)\n\t\t\tmemcpy(smcd_v2_ext->system_eid, eid, SMC_MAX_EID_LEN);\n\t\tplen += sizeof(*smcd_v2_ext);\n\t\tif (ini->ism_offered_cnt) {\n\t\t\tfor (i = 1; i <= ini->ism_offered_cnt; i++) {\n\t\t\t\tsmcd = ini->ism_dev[i];\n\t\t\t\tgidchids[i - 1].gid =\n\t\t\t\t\thtonll(smcd->ops->get_local_gid(smcd));\n\t\t\t\tgidchids[i - 1].chid =\n\t\t\t\t\thtons(smc_ism_get_chid(ini->ism_dev[i]));\n\t\t\t}\n\t\t\tplen += ini->ism_offered_cnt *\n\t\t\t\tsizeof(struct smc_clc_smcd_gid_chid);\n\t\t}\n\t}\n\tif (smcr_indicated(ini->smc_type_v2)) {\n\t\tmemcpy(v2_ext->roce, ini->smcrv2.ib_gid_v2, SMC_GID_SIZE);\n\t\tv2_ext->max_conns = SMC_CONN_PER_LGR_PREFER;\n\t\tv2_ext->max_links = SMC_LINKS_PER_LGR_MAX_PREFER;\n\t}\n\n\tpclc_base->hdr.length = htons(plen);\n\tmemcpy(trl->eyecatcher, SMC_EYECATCHER, sizeof(SMC_EYECATCHER));\n\n\t \n\tmemset(&msg, 0, sizeof(msg));\n\ti = 0;\n\tvec[i].iov_base = pclc_base;\n\tvec[i++].iov_len = sizeof(*pclc_base);\n\tvec[i].iov_base = pclc_smcd;\n\tvec[i++].iov_len = sizeof(*pclc_smcd);\n\tif (ini->smc_type_v1 != SMC_TYPE_N) {\n\t\tvec[i].iov_base = pclc_prfx;\n\t\tvec[i++].iov_len = sizeof(*pclc_prfx);\n\t\tif (pclc_prfx->ipv6_prefixes_cnt > 0) {\n\t\t\tvec[i].iov_base = ipv6_prfx;\n\t\t\tvec[i++].iov_len = pclc_prfx->ipv6_prefixes_cnt *\n\t\t\t\t\t   sizeof(ipv6_prfx[0]);\n\t\t}\n\t}\n\tif (ini->smc_type_v2 != SMC_TYPE_N) {\n\t\tvec[i].iov_base = v2_ext;\n\t\tvec[i++].iov_len = sizeof(*v2_ext) +\n\t\t\t\t   (v2_ext->hdr.eid_cnt * SMC_MAX_EID_LEN);\n\t\tif (smcd_indicated(ini->smc_type_v2)) {\n\t\t\tvec[i].iov_base = smcd_v2_ext;\n\t\t\tvec[i++].iov_len = sizeof(*smcd_v2_ext);\n\t\t\tif (ini->ism_offered_cnt) {\n\t\t\t\tvec[i].iov_base = gidchids;\n\t\t\t\tvec[i++].iov_len = ini->ism_offered_cnt *\n\t\t\t\t\tsizeof(struct smc_clc_smcd_gid_chid);\n\t\t\t}\n\t\t}\n\t}\n\tvec[i].iov_base = trl;\n\tvec[i++].iov_len = sizeof(*trl);\n\t \n\tlen = kernel_sendmsg(smc->clcsock, &msg, vec, i, plen);\n\tif (len < 0) {\n\t\tsmc->sk.sk_err = smc->clcsock->sk->sk_err;\n\t\treason_code = -smc->sk.sk_err;\n\t} else if (len < ntohs(pclc_base->hdr.length)) {\n\t\treason_code = -ENETUNREACH;\n\t\tsmc->sk.sk_err = -reason_code;\n\t}\n\n\tkfree(pclc);\n\treturn reason_code;\n}\n\n \nstatic int smc_clc_send_confirm_accept(struct smc_sock *smc,\n\t\t\t\t       struct smc_clc_msg_accept_confirm_v2 *clc_v2,\n\t\t\t\t       int first_contact, u8 version,\n\t\t\t\t       u8 *eid, struct smc_init_info *ini)\n{\n\tstruct smc_connection *conn = &smc->conn;\n\tstruct smc_clc_first_contact_ext_v2x fce;\n\tstruct smcd_dev *smcd = conn->lgr->smcd;\n\tstruct smc_clc_msg_accept_confirm *clc;\n\tstruct smc_clc_fce_gid_ext gle;\n\tstruct smc_clc_msg_trail trl;\n\tint i, len, fce_len;\n\tstruct kvec vec[5];\n\tstruct msghdr msg;\n\n\t \n\tclc = (struct smc_clc_msg_accept_confirm *)clc_v2;\n\tclc->hdr.version = version;\t \n\tif (first_contact)\n\t\tclc->hdr.typev2 |= SMC_FIRST_CONTACT_MASK;\n\tif (conn->lgr->is_smcd) {\n\t\t \n\t\tmemcpy(clc->hdr.eyecatcher, SMCD_EYECATCHER,\n\t\t       sizeof(SMCD_EYECATCHER));\n\t\tclc->hdr.typev1 = SMC_TYPE_D;\n\t\tclc->d0.gid = htonll(smcd->ops->get_local_gid(smcd));\n\t\tclc->d0.token = htonll(conn->rmb_desc->token);\n\t\tclc->d0.dmbe_size = conn->rmbe_size_comp;\n\t\tclc->d0.dmbe_idx = 0;\n\t\tmemcpy(&clc->d0.linkid, conn->lgr->id, SMC_LGR_ID_SIZE);\n\t\tif (version == SMC_V1) {\n\t\t\tclc->hdr.length = htons(SMCD_CLC_ACCEPT_CONFIRM_LEN);\n\t\t} else {\n\t\t\tclc_v2->d1.chid = htons(smc_ism_get_chid(smcd));\n\t\t\tif (eid && eid[0])\n\t\t\t\tmemcpy(clc_v2->d1.eid, eid, SMC_MAX_EID_LEN);\n\t\t\tlen = SMCD_CLC_ACCEPT_CONFIRM_LEN_V2;\n\t\t\tif (first_contact) {\n\t\t\t\tfce_len = smc_clc_fill_fce(&fce, ini);\n\t\t\t\tlen += fce_len;\n\t\t\t}\n\t\t\tclc_v2->hdr.length = htons(len);\n\t\t}\n\t\tmemcpy(trl.eyecatcher, SMCD_EYECATCHER,\n\t\t       sizeof(SMCD_EYECATCHER));\n\t} else {\n\t\tstruct smc_link *link = conn->lnk;\n\n\t\t \n\t\tmemcpy(clc->hdr.eyecatcher, SMC_EYECATCHER,\n\t\t       sizeof(SMC_EYECATCHER));\n\t\tclc->hdr.typev1 = SMC_TYPE_R;\n\t\tclc->hdr.length = htons(SMCR_CLC_ACCEPT_CONFIRM_LEN);\n\t\tmemcpy(clc->r0.lcl.id_for_peer, local_systemid,\n\t\t       sizeof(local_systemid));\n\t\tmemcpy(&clc->r0.lcl.gid, link->gid, SMC_GID_SIZE);\n\t\tmemcpy(&clc->r0.lcl.mac, &link->smcibdev->mac[link->ibport - 1],\n\t\t       ETH_ALEN);\n\t\thton24(clc->r0.qpn, link->roce_qp->qp_num);\n\t\tclc->r0.rmb_rkey =\n\t\t\thtonl(conn->rmb_desc->mr[link->link_idx]->rkey);\n\t\tclc->r0.rmbe_idx = 1;  \n\t\tclc->r0.rmbe_alert_token = htonl(conn->alert_token_local);\n\t\tswitch (clc->hdr.type) {\n\t\tcase SMC_CLC_ACCEPT:\n\t\t\tclc->r0.qp_mtu = link->path_mtu;\n\t\t\tbreak;\n\t\tcase SMC_CLC_CONFIRM:\n\t\t\tclc->r0.qp_mtu = min(link->path_mtu, link->peer_mtu);\n\t\t\tbreak;\n\t\t}\n\t\tclc->r0.rmbe_size = conn->rmbe_size_comp;\n\t\tclc->r0.rmb_dma_addr = conn->rmb_desc->is_vm ?\n\t\t\tcpu_to_be64((uintptr_t)conn->rmb_desc->cpu_addr) :\n\t\t\tcpu_to_be64((u64)sg_dma_address\n\t\t\t\t    (conn->rmb_desc->sgt[link->link_idx].sgl));\n\t\thton24(clc->r0.psn, link->psn_initial);\n\t\tif (version == SMC_V1) {\n\t\t\tclc->hdr.length = htons(SMCR_CLC_ACCEPT_CONFIRM_LEN);\n\t\t} else {\n\t\t\tif (eid && eid[0])\n\t\t\t\tmemcpy(clc_v2->r1.eid, eid, SMC_MAX_EID_LEN);\n\t\t\tlen = SMCR_CLC_ACCEPT_CONFIRM_LEN_V2;\n\t\t\tif (first_contact) {\n\t\t\t\tfce_len = smc_clc_fill_fce(&fce, ini);\n\t\t\t\tlen += fce_len;\n\t\t\t\tfce.fce_v2_base.v2_direct = !link->lgr->uses_gateway;\n\t\t\t\tif (clc->hdr.type == SMC_CLC_CONFIRM) {\n\t\t\t\t\tmemset(&gle, 0, sizeof(gle));\n\t\t\t\t\tgle.gid_cnt = ini->smcrv2.gidlist.len;\n\t\t\t\t\tlen += sizeof(gle);\n\t\t\t\t\tlen += gle.gid_cnt * sizeof(gle.gid[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclc_v2->hdr.length = htons(len);\n\t\t}\n\t\tmemcpy(trl.eyecatcher, SMC_EYECATCHER, sizeof(SMC_EYECATCHER));\n\t}\n\n\tmemset(&msg, 0, sizeof(msg));\n\ti = 0;\n\tvec[i].iov_base = clc_v2;\n\tif (version > SMC_V1)\n\t\tvec[i++].iov_len = (clc->hdr.typev1 == SMC_TYPE_D ?\n\t\t\t\t\tSMCD_CLC_ACCEPT_CONFIRM_LEN_V2 :\n\t\t\t\t\tSMCR_CLC_ACCEPT_CONFIRM_LEN_V2) -\n\t\t\t\t   sizeof(trl);\n\telse\n\t\tvec[i++].iov_len = (clc->hdr.typev1 == SMC_TYPE_D ?\n\t\t\t\t\t\tSMCD_CLC_ACCEPT_CONFIRM_LEN :\n\t\t\t\t\t\tSMCR_CLC_ACCEPT_CONFIRM_LEN) -\n\t\t\t\t   sizeof(trl);\n\tif (version > SMC_V1 && first_contact) {\n\t\tvec[i].iov_base = &fce;\n\t\tvec[i++].iov_len = fce_len;\n\t\tif (!conn->lgr->is_smcd) {\n\t\t\tif (clc->hdr.type == SMC_CLC_CONFIRM) {\n\t\t\t\tvec[i].iov_base = &gle;\n\t\t\t\tvec[i++].iov_len = sizeof(gle);\n\t\t\t\tvec[i].iov_base = &ini->smcrv2.gidlist.list;\n\t\t\t\tvec[i++].iov_len = gle.gid_cnt *\n\t\t\t\t\t\t   sizeof(gle.gid[0]);\n\t\t\t}\n\t\t}\n\t}\n\tvec[i].iov_base = &trl;\n\tvec[i++].iov_len = sizeof(trl);\n\treturn kernel_sendmsg(smc->clcsock, &msg, vec, 1,\n\t\t\t      ntohs(clc->hdr.length));\n}\n\n \nint smc_clc_send_confirm(struct smc_sock *smc, bool clnt_first_contact,\n\t\t\t u8 version, u8 *eid, struct smc_init_info *ini)\n{\n\tstruct smc_clc_msg_accept_confirm_v2 cclc_v2;\n\tint reason_code = 0;\n\tint len;\n\n\t \n\tmemset(&cclc_v2, 0, sizeof(cclc_v2));\n\tcclc_v2.hdr.type = SMC_CLC_CONFIRM;\n\tlen = smc_clc_send_confirm_accept(smc, &cclc_v2, clnt_first_contact,\n\t\t\t\t\t  version, eid, ini);\n\tif (len < ntohs(cclc_v2.hdr.length)) {\n\t\tif (len >= 0) {\n\t\t\treason_code = -ENETUNREACH;\n\t\t\tsmc->sk.sk_err = -reason_code;\n\t\t} else {\n\t\t\tsmc->sk.sk_err = smc->clcsock->sk->sk_err;\n\t\t\treason_code = -smc->sk.sk_err;\n\t\t}\n\t}\n\treturn reason_code;\n}\n\n \nint smc_clc_send_accept(struct smc_sock *new_smc, bool srv_first_contact,\n\t\t\tu8 version, u8 *negotiated_eid, struct smc_init_info *ini)\n{\n\tstruct smc_clc_msg_accept_confirm_v2 aclc_v2;\n\tint len;\n\n\tmemset(&aclc_v2, 0, sizeof(aclc_v2));\n\taclc_v2.hdr.type = SMC_CLC_ACCEPT;\n\tlen = smc_clc_send_confirm_accept(new_smc, &aclc_v2, srv_first_contact,\n\t\t\t\t\t  version, negotiated_eid, ini);\n\tif (len < ntohs(aclc_v2.hdr.length))\n\t\tlen = len >= 0 ? -EPROTO : -new_smc->clcsock->sk->sk_err;\n\n\treturn len > 0 ? 0 : len;\n}\n\nint smc_clc_srv_v2x_features_validate(struct smc_clc_msg_proposal *pclc,\n\t\t\t\t      struct smc_init_info *ini)\n{\n\tstruct smc_clc_v2_extension *pclc_v2_ext;\n\n\tini->max_conns = SMC_CONN_PER_LGR_MAX;\n\tini->max_links = SMC_LINKS_ADD_LNK_MAX;\n\n\tif ((!(ini->smcd_version & SMC_V2) && !(ini->smcr_version & SMC_V2)) ||\n\t    ini->release_nr < SMC_RELEASE_1)\n\t\treturn 0;\n\n\tpclc_v2_ext = smc_get_clc_v2_ext(pclc);\n\tif (!pclc_v2_ext)\n\t\treturn SMC_CLC_DECL_NOV2EXT;\n\n\tif (ini->smcr_version & SMC_V2) {\n\t\tini->max_conns = min_t(u8, pclc_v2_ext->max_conns, SMC_CONN_PER_LGR_PREFER);\n\t\tif (ini->max_conns < SMC_CONN_PER_LGR_MIN)\n\t\t\treturn SMC_CLC_DECL_MAXCONNERR;\n\n\t\tini->max_links = min_t(u8, pclc_v2_ext->max_links, SMC_LINKS_PER_LGR_MAX_PREFER);\n\t\tif (ini->max_links < SMC_LINKS_ADD_LNK_MIN)\n\t\t\treturn SMC_CLC_DECL_MAXLINKERR;\n\t}\n\n\treturn 0;\n}\n\nint smc_clc_clnt_v2x_features_validate(struct smc_clc_first_contact_ext *fce,\n\t\t\t\t       struct smc_init_info *ini)\n{\n\tstruct smc_clc_first_contact_ext_v2x *fce_v2x =\n\t\t(struct smc_clc_first_contact_ext_v2x *)fce;\n\n\tif (ini->release_nr < SMC_RELEASE_1)\n\t\treturn 0;\n\n\tif (!ini->is_smcd) {\n\t\tif (fce_v2x->max_conns < SMC_CONN_PER_LGR_MIN)\n\t\t\treturn SMC_CLC_DECL_MAXCONNERR;\n\t\tini->max_conns = fce_v2x->max_conns;\n\n\t\tif (fce_v2x->max_links > SMC_LINKS_ADD_LNK_MAX ||\n\t\t    fce_v2x->max_links < SMC_LINKS_ADD_LNK_MIN)\n\t\t\treturn SMC_CLC_DECL_MAXLINKERR;\n\t\tini->max_links = fce_v2x->max_links;\n\t}\n\n\treturn 0;\n}\n\nint smc_clc_v2x_features_confirm_check(struct smc_clc_msg_accept_confirm *cclc,\n\t\t\t\t       struct smc_init_info *ini)\n{\n\tstruct smc_clc_msg_accept_confirm_v2 *clc_v2 =\n\t\t(struct smc_clc_msg_accept_confirm_v2 *)cclc;\n\tstruct smc_clc_first_contact_ext *fce =\n\t\tsmc_get_clc_first_contact_ext(clc_v2, ini->is_smcd);\n\tstruct smc_clc_first_contact_ext_v2x *fce_v2x =\n\t\t(struct smc_clc_first_contact_ext_v2x *)fce;\n\n\tif (cclc->hdr.version == SMC_V1 ||\n\t    !(cclc->hdr.typev2 & SMC_FIRST_CONTACT_MASK))\n\t\treturn 0;\n\n\tif (ini->release_nr != fce->release)\n\t\treturn SMC_CLC_DECL_RELEASEERR;\n\n\tif (fce->release < SMC_RELEASE_1)\n\t\treturn 0;\n\n\tif (!ini->is_smcd) {\n\t\tif (fce_v2x->max_conns != ini->max_conns)\n\t\t\treturn SMC_CLC_DECL_MAXCONNERR;\n\t\tif (fce_v2x->max_links != ini->max_links)\n\t\t\treturn SMC_CLC_DECL_MAXLINKERR;\n\t}\n\n\treturn 0;\n}\n\nvoid smc_clc_get_hostname(u8 **host)\n{\n\t*host = &smc_hostname[0];\n}\n\nvoid __init smc_clc_init(void)\n{\n\tstruct new_utsname *u;\n\n\tmemset(smc_hostname, _S, sizeof(smc_hostname));  \n\tu = utsname();\n\tmemcpy(smc_hostname, u->nodename,\n\t       min_t(size_t, strlen(u->nodename), sizeof(smc_hostname)));\n\n\tINIT_LIST_HEAD(&smc_clc_eid_table.list);\n\trwlock_init(&smc_clc_eid_table.lock);\n\tsmc_clc_eid_table.ueid_cnt = 0;\n\tsmc_clc_eid_table.seid_enabled = 1;\n}\n\nvoid smc_clc_exit(void)\n{\n\tsmc_clc_ueid_remove(NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}