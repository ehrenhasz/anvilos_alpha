{
  "module_name": "smc_tx.c",
  "hash_id": "c79ad6a4d6437ee78b631b1b180abfabe6947d421a9c26809d8cec46a67c174f",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_tx.c",
  "human_readable_source": "\n \n\n#include <linux/net.h>\n#include <linux/rcupdate.h>\n#include <linux/workqueue.h>\n#include <linux/sched/signal.h>\n\n#include <net/sock.h>\n#include <net/tcp.h>\n\n#include \"smc.h\"\n#include \"smc_wr.h\"\n#include \"smc_cdc.h\"\n#include \"smc_close.h\"\n#include \"smc_ism.h\"\n#include \"smc_tx.h\"\n#include \"smc_stats.h\"\n#include \"smc_tracepoint.h\"\n\n#define SMC_TX_WORK_DELAY\t0\n\n \n\n \nstatic void smc_tx_write_space(struct sock *sk)\n{\n\tstruct socket *sock = sk->sk_socket;\n\tstruct smc_sock *smc = smc_sk(sk);\n\tstruct socket_wq *wq;\n\n\t \n\tif (atomic_read(&smc->conn.sndbuf_space) && sock) {\n\t\tif (test_bit(SOCK_NOSPACE, &sock->flags))\n\t\t\tSMC_STAT_RMB_TX_FULL(smc, !smc->conn.lnk);\n\t\tclear_bit(SOCK_NOSPACE, &sock->flags);\n\t\trcu_read_lock();\n\t\twq = rcu_dereference(sk->sk_wq);\n\t\tif (skwq_has_sleeper(wq))\n\t\t\twake_up_interruptible_poll(&wq->wait,\n\t\t\t\t\t\t   EPOLLOUT | EPOLLWRNORM |\n\t\t\t\t\t\t   EPOLLWRBAND);\n\t\tif (wq && wq->fasync_list && !(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\t\tsock_wake_async(wq, SOCK_WAKE_SPACE, POLL_OUT);\n\t\trcu_read_unlock();\n\t}\n}\n\n \nvoid smc_tx_sndbuf_nonfull(struct smc_sock *smc)\n{\n\tif (smc->sk.sk_socket &&\n\t    test_bit(SOCK_NOSPACE, &smc->sk.sk_socket->flags))\n\t\tsmc->sk.sk_write_space(&smc->sk);\n}\n\n \nstatic int smc_tx_wait(struct smc_sock *smc, int flags)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct smc_connection *conn = &smc->conn;\n\tstruct sock *sk = &smc->sk;\n\tlong timeo;\n\tint rc = 0;\n\n\t \n\ttimeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\t\tif (sk->sk_err ||\n\t\t    (sk->sk_shutdown & SEND_SHUTDOWN) ||\n\t\t    conn->killed ||\n\t\t    conn->local_tx_ctrl.conn_state_flags.peer_done_writing) {\n\t\t\trc = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (smc_cdc_rxed_any_close(conn)) {\n\t\t\trc = -ECONNRESET;\n\t\t\tbreak;\n\t\t}\n\t\tif (!timeo) {\n\t\t\t \n\t\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\t\trc = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\trc = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\t\tsk_clear_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\t\tif (atomic_read(&conn->sndbuf_space) && !conn->urg_tx_pend)\n\t\t\tbreak;  \n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\tsk_wait_event(sk, &timeo,\n\t\t\t      READ_ONCE(sk->sk_err) ||\n\t\t\t      (READ_ONCE(sk->sk_shutdown) & SEND_SHUTDOWN) ||\n\t\t\t      smc_cdc_rxed_any_close(conn) ||\n\t\t\t      (atomic_read(&conn->sndbuf_space) &&\n\t\t\t       !conn->urg_tx_pend),\n\t\t\t      &wait);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn rc;\n}\n\nstatic bool smc_tx_is_corked(struct smc_sock *smc)\n{\n\tstruct tcp_sock *tp = tcp_sk(smc->clcsock->sk);\n\n\treturn (tp->nonagle & TCP_NAGLE_CORK) ? true : false;\n}\n\n \nstatic bool smc_should_autocork(struct smc_sock *smc)\n{\n\tstruct smc_connection *conn = &smc->conn;\n\tint corking_size;\n\n\tcorking_size = min_t(unsigned int, conn->sndbuf_desc->len >> 1,\n\t\t\t     sock_net(&smc->sk)->smc.sysctl_autocorking_size);\n\n\tif (atomic_read(&conn->cdc_pend_tx_wr) == 0 ||\n\t    smc_tx_prepared_sends(conn) > corking_size)\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool smc_tx_should_cork(struct smc_sock *smc, struct msghdr *msg)\n{\n\tstruct smc_connection *conn = &smc->conn;\n\n\tif (smc_should_autocork(smc))\n\t\treturn true;\n\n\t \n\tif ((msg->msg_flags & MSG_MORE ||\n\t     smc_tx_is_corked(smc)) &&\n\t    atomic_read(&conn->sndbuf_space))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint smc_tx_sendmsg(struct smc_sock *smc, struct msghdr *msg, size_t len)\n{\n\tsize_t copylen, send_done = 0, send_remaining = len;\n\tsize_t chunk_len, chunk_off, chunk_len_sum;\n\tstruct smc_connection *conn = &smc->conn;\n\tunion smc_host_cursor prep;\n\tstruct sock *sk = &smc->sk;\n\tchar *sndbuf_base;\n\tint tx_cnt_prep;\n\tint writespace;\n\tint rc, chunk;\n\n\t \n\tsk_clear_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\tif (sk->sk_err || (sk->sk_shutdown & SEND_SHUTDOWN)) {\n\t\trc = -EPIPE;\n\t\tgoto out_err;\n\t}\n\n\tif (sk->sk_state == SMC_INIT)\n\t\treturn -ENOTCONN;\n\n\tif (len > conn->sndbuf_desc->len)\n\t\tSMC_STAT_RMB_TX_SIZE_SMALL(smc, !conn->lnk);\n\n\tif (len > conn->peer_rmbe_size)\n\t\tSMC_STAT_RMB_TX_PEER_SIZE_SMALL(smc, !conn->lnk);\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\tSMC_STAT_INC(smc, urg_data_cnt);\n\n\twhile (msg_data_left(msg)) {\n\t\tif (smc->sk.sk_shutdown & SEND_SHUTDOWN ||\n\t\t    (smc->sk.sk_err == ECONNABORTED) ||\n\t\t    conn->killed)\n\t\t\treturn -EPIPE;\n\t\tif (smc_cdc_rxed_any_close(conn))\n\t\t\treturn send_done ?: -ECONNRESET;\n\n\t\tif (msg->msg_flags & MSG_OOB)\n\t\t\tconn->local_tx_ctrl.prod_flags.urg_data_pending = 1;\n\n\t\tif (!atomic_read(&conn->sndbuf_space) || conn->urg_tx_pend) {\n\t\t\tif (send_done)\n\t\t\t\treturn send_done;\n\t\t\trc = smc_tx_wait(smc, msg->msg_flags);\n\t\t\tif (rc)\n\t\t\t\tgoto out_err;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\t \n\t\twritespace = atomic_read(&conn->sndbuf_space);\n\t\t \n\t\tcopylen = min_t(size_t, send_remaining, writespace);\n\t\t \n\t\tsndbuf_base = conn->sndbuf_desc->cpu_addr;\n\t\tsmc_curs_copy(&prep, &conn->tx_curs_prep, conn);\n\t\ttx_cnt_prep = prep.count;\n\t\t \n\t\t \n\t\tchunk_len = min_t(size_t, copylen, conn->sndbuf_desc->len -\n\t\t\t\t  tx_cnt_prep);\n\t\tchunk_len_sum = chunk_len;\n\t\tchunk_off = tx_cnt_prep;\n\t\tfor (chunk = 0; chunk < 2; chunk++) {\n\t\t\trc = memcpy_from_msg(sndbuf_base + chunk_off,\n\t\t\t\t\t     msg, chunk_len);\n\t\t\tif (rc) {\n\t\t\t\tsmc_sndbuf_sync_sg_for_device(conn);\n\t\t\t\tif (send_done)\n\t\t\t\t\treturn send_done;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tsend_done += chunk_len;\n\t\t\tsend_remaining -= chunk_len;\n\n\t\t\tif (chunk_len_sum == copylen)\n\t\t\t\tbreak;  \n\t\t\t \n\t\t\tchunk_len = copylen - chunk_len;  \n\t\t\tchunk_len_sum += chunk_len;\n\t\t\tchunk_off = 0;  \n\t\t}\n\t\tsmc_sndbuf_sync_sg_for_device(conn);\n\t\t \n\t\tsmc_curs_add(conn->sndbuf_desc->len, &prep, copylen);\n\t\tsmc_curs_copy(&conn->tx_curs_prep, &prep, conn);\n\t\t \n\t\tsmp_mb__before_atomic();\n\t\tatomic_sub(copylen, &conn->sndbuf_space);\n\t\t \n\t\tsmp_mb__after_atomic();\n\t\t \n\t\tif ((msg->msg_flags & MSG_OOB) && !send_remaining)\n\t\t\tconn->urg_tx_pend = true;\n\t\t \n\t\tif (!smc_tx_should_cork(smc, msg))\n\t\t\tsmc_tx_sndbuf_nonempty(conn);\n\n\t\ttrace_smc_tx_sendmsg(smc, copylen);\n\t}  \n\n\treturn send_done;\n\nout_err:\n\trc = sk_stream_error(sk, msg->msg_flags, rc);\n\t \n\tif (unlikely(rc == -EAGAIN))\n\t\tsk->sk_write_space(sk);\n\treturn rc;\n}\n\n \n\n \nint smcd_tx_ism_write(struct smc_connection *conn, void *data, size_t len,\n\t\t      u32 offset, int signal)\n{\n\tint rc;\n\n\trc = smc_ism_write(conn->lgr->smcd, conn->peer_token,\n\t\t\t   conn->peer_rmbe_idx, signal, conn->tx_off + offset,\n\t\t\t   data, len);\n\tif (rc)\n\t\tconn->local_tx_ctrl.conn_state_flags.peer_conn_abort = 1;\n\treturn rc;\n}\n\n \nstatic int smc_tx_rdma_write(struct smc_connection *conn, int peer_rmbe_offset,\n\t\t\t     int num_sges, struct ib_rdma_wr *rdma_wr)\n{\n\tstruct smc_link_group *lgr = conn->lgr;\n\tstruct smc_link *link = conn->lnk;\n\tint rc;\n\n\trdma_wr->wr.wr_id = smc_wr_tx_get_next_wr_id(link);\n\trdma_wr->wr.num_sge = num_sges;\n\trdma_wr->remote_addr =\n\t\tlgr->rtokens[conn->rtoken_idx][link->link_idx].dma_addr +\n\t\t \n\t\tconn->tx_off +\n\t\t \n\t\tpeer_rmbe_offset;\n\trdma_wr->rkey = lgr->rtokens[conn->rtoken_idx][link->link_idx].rkey;\n\trc = ib_post_send(link->roce_qp, &rdma_wr->wr, NULL);\n\tif (rc)\n\t\tsmcr_link_down_cond_sched(link);\n\treturn rc;\n}\n\n \nstatic inline void smc_tx_advance_cursors(struct smc_connection *conn,\n\t\t\t\t\t  union smc_host_cursor *prod,\n\t\t\t\t\t  union smc_host_cursor *sent,\n\t\t\t\t\t  size_t len)\n{\n\tsmc_curs_add(conn->peer_rmbe_size, prod, len);\n\t \n\tsmp_mb__before_atomic();\n\t \n\tatomic_sub(len, &conn->peer_rmbe_space);\n\t \n\tsmp_mb__after_atomic();\n\tsmc_curs_add(conn->sndbuf_desc->len, sent, len);\n}\n\n \nstatic int smcr_tx_rdma_writes(struct smc_connection *conn, size_t len,\n\t\t\t       size_t src_off, size_t src_len,\n\t\t\t       size_t dst_off, size_t dst_len,\n\t\t\t       struct smc_rdma_wr *wr_rdma_buf)\n{\n\tstruct smc_link *link = conn->lnk;\n\n\tdma_addr_t dma_addr =\n\t\tsg_dma_address(conn->sndbuf_desc->sgt[link->link_idx].sgl);\n\tu64 virt_addr = (uintptr_t)conn->sndbuf_desc->cpu_addr;\n\tint src_len_sum = src_len, dst_len_sum = dst_len;\n\tint sent_count = src_off;\n\tint srcchunk, dstchunk;\n\tint num_sges;\n\tint rc;\n\n\tfor (dstchunk = 0; dstchunk < 2; dstchunk++) {\n\t\tstruct ib_rdma_wr *wr = &wr_rdma_buf->wr_tx_rdma[dstchunk];\n\t\tstruct ib_sge *sge = wr->wr.sg_list;\n\t\tu64 base_addr = dma_addr;\n\n\t\tif (dst_len < link->qp_attr.cap.max_inline_data) {\n\t\t\tbase_addr = virt_addr;\n\t\t\twr->wr.send_flags |= IB_SEND_INLINE;\n\t\t} else {\n\t\t\twr->wr.send_flags &= ~IB_SEND_INLINE;\n\t\t}\n\n\t\tnum_sges = 0;\n\t\tfor (srcchunk = 0; srcchunk < 2; srcchunk++) {\n\t\t\tsge[srcchunk].addr = conn->sndbuf_desc->is_vm ?\n\t\t\t\t(virt_addr + src_off) : (base_addr + src_off);\n\t\t\tsge[srcchunk].length = src_len;\n\t\t\tif (conn->sndbuf_desc->is_vm)\n\t\t\t\tsge[srcchunk].lkey =\n\t\t\t\t\tconn->sndbuf_desc->mr[link->link_idx]->lkey;\n\t\t\tnum_sges++;\n\n\t\t\tsrc_off += src_len;\n\t\t\tif (src_off >= conn->sndbuf_desc->len)\n\t\t\t\tsrc_off -= conn->sndbuf_desc->len;\n\t\t\t\t\t\t \n\t\t\tif (src_len_sum == dst_len)\n\t\t\t\tbreak;  \n\t\t\t \n\t\t\tsrc_len = dst_len - src_len;  \n\t\t\tsrc_len_sum += src_len;\n\t\t}\n\t\trc = smc_tx_rdma_write(conn, dst_off, num_sges, wr);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (dst_len_sum == len)\n\t\t\tbreak;  \n\t\t \n\t\tdst_off = 0;  \n\t\tdst_len = len - dst_len;  \n\t\tdst_len_sum += dst_len;\n\t\tsrc_len = min_t(int, dst_len, conn->sndbuf_desc->len -\n\t\t\t\tsent_count);\n\t\tsrc_len_sum = src_len;\n\t}\n\treturn 0;\n}\n\n \nstatic int smcd_tx_rdma_writes(struct smc_connection *conn, size_t len,\n\t\t\t       size_t src_off, size_t src_len,\n\t\t\t       size_t dst_off, size_t dst_len)\n{\n\tint src_len_sum = src_len, dst_len_sum = dst_len;\n\tint srcchunk, dstchunk;\n\tint rc;\n\n\tfor (dstchunk = 0; dstchunk < 2; dstchunk++) {\n\t\tfor (srcchunk = 0; srcchunk < 2; srcchunk++) {\n\t\t\tvoid *data = conn->sndbuf_desc->cpu_addr + src_off;\n\n\t\t\trc = smcd_tx_ism_write(conn, data, src_len, dst_off +\n\t\t\t\t\t       sizeof(struct smcd_cdc_msg), 0);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tdst_off += src_len;\n\t\t\tsrc_off += src_len;\n\t\t\tif (src_off >= conn->sndbuf_desc->len)\n\t\t\t\tsrc_off -= conn->sndbuf_desc->len;\n\t\t\t\t\t\t \n\t\t\tif (src_len_sum == dst_len)\n\t\t\t\tbreak;  \n\t\t\t \n\t\t\tsrc_len = dst_len - src_len;  \n\t\t\tsrc_len_sum += src_len;\n\t\t}\n\t\tif (dst_len_sum == len)\n\t\t\tbreak;  \n\t\t \n\t\tdst_off = 0;  \n\t\tdst_len = len - dst_len;  \n\t\tdst_len_sum += dst_len;\n\t\tsrc_len = min_t(int, dst_len, conn->sndbuf_desc->len - src_off);\n\t\tsrc_len_sum = src_len;\n\t}\n\treturn 0;\n}\n\n \nstatic int smc_tx_rdma_writes(struct smc_connection *conn,\n\t\t\t      struct smc_rdma_wr *wr_rdma_buf)\n{\n\tsize_t len, src_len, dst_off, dst_len;  \n\tunion smc_host_cursor sent, prep, prod, cons;\n\tstruct smc_cdc_producer_flags *pflags;\n\tint to_send, rmbespace;\n\tint rc;\n\n\t \n\tsmc_curs_copy(&sent, &conn->tx_curs_sent, conn);\n\tsmc_curs_copy(&prep, &conn->tx_curs_prep, conn);\n\t \n\tto_send = smc_curs_diff(conn->sndbuf_desc->len, &sent, &prep);\n\tif (to_send <= 0)\n\t\treturn 0;\n\n\t \n\t \n\trmbespace = atomic_read(&conn->peer_rmbe_space);\n\tif (rmbespace <= 0) {\n\t\tstruct smc_sock *smc = container_of(conn, struct smc_sock,\n\t\t\t\t\t\t    conn);\n\t\tSMC_STAT_RMB_TX_PEER_FULL(smc, !conn->lnk);\n\t\treturn 0;\n\t}\n\tsmc_curs_copy(&prod, &conn->local_tx_ctrl.prod, conn);\n\tsmc_curs_copy(&cons, &conn->local_rx_ctrl.cons, conn);\n\n\t \n\tpflags = &conn->local_tx_ctrl.prod_flags;\n\tpflags->write_blocked = (to_send >= rmbespace);\n\t \n\tlen = min(to_send, rmbespace);\n\n\t \n\tdst_off = prod.count;\n\tif (prod.wrap == cons.wrap) {\n\t\t \n\t\tdst_len = min_t(size_t,\n\t\t\t\tconn->peer_rmbe_size - prod.count, len);\n\t} else {\n\t\t \n\t\tdst_len = len;\n\t}\n\t \n\tif (sent.count + dst_len <= conn->sndbuf_desc->len) {\n\t\t \n\t\tsrc_len = dst_len;\n\t} else {\n\t\t \n\t\tsrc_len = conn->sndbuf_desc->len - sent.count;\n\t}\n\n\tif (conn->lgr->is_smcd)\n\t\trc = smcd_tx_rdma_writes(conn, len, sent.count, src_len,\n\t\t\t\t\t dst_off, dst_len);\n\telse\n\t\trc = smcr_tx_rdma_writes(conn, len, sent.count, src_len,\n\t\t\t\t\t dst_off, dst_len, wr_rdma_buf);\n\tif (rc)\n\t\treturn rc;\n\n\tif (conn->urg_tx_pend && len == to_send)\n\t\tpflags->urg_data_present = 1;\n\tsmc_tx_advance_cursors(conn, &prod, &sent, len);\n\t \n\tsmc_curs_copy(&conn->local_tx_ctrl.prod, &prod, conn);\n\t\t\t\t\t\t\t \n\tsmc_curs_copy(&conn->tx_curs_sent, &sent, conn); \n\n\treturn 0;\n}\n\n \nstatic int smcr_tx_sndbuf_nonempty(struct smc_connection *conn)\n{\n\tstruct smc_cdc_producer_flags *pflags = &conn->local_tx_ctrl.prod_flags;\n\tstruct smc_link *link = conn->lnk;\n\tstruct smc_rdma_wr *wr_rdma_buf;\n\tstruct smc_cdc_tx_pend *pend;\n\tstruct smc_wr_buf *wr_buf;\n\tint rc;\n\n\tif (!link || !smc_wr_tx_link_hold(link))\n\t\treturn -ENOLINK;\n\trc = smc_cdc_get_free_slot(conn, link, &wr_buf, &wr_rdma_buf, &pend);\n\tif (rc < 0) {\n\t\tsmc_wr_tx_link_put(link);\n\t\tif (rc == -EBUSY) {\n\t\t\tstruct smc_sock *smc =\n\t\t\t\tcontainer_of(conn, struct smc_sock, conn);\n\n\t\t\tif (smc->sk.sk_err == ECONNABORTED)\n\t\t\t\treturn sock_error(&smc->sk);\n\t\t\tif (conn->killed)\n\t\t\t\treturn -EPIPE;\n\t\t\trc = 0;\n\t\t\tmod_delayed_work(conn->lgr->tx_wq, &conn->tx_work,\n\t\t\t\t\t SMC_TX_WORK_DELAY);\n\t\t}\n\t\treturn rc;\n\t}\n\n\tspin_lock_bh(&conn->send_lock);\n\tif (link != conn->lnk) {\n\t\t \n\t\tsmc_wr_tx_put_slot(link,\n\t\t\t\t   (struct smc_wr_tx_pend_priv *)pend);\n\t\trc = -ENOLINK;\n\t\tgoto out_unlock;\n\t}\n\tif (!pflags->urg_data_present) {\n\t\trc = smc_tx_rdma_writes(conn, wr_rdma_buf);\n\t\tif (rc) {\n\t\t\tsmc_wr_tx_put_slot(link,\n\t\t\t\t\t   (struct smc_wr_tx_pend_priv *)pend);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\trc = smc_cdc_msg_send(conn, wr_buf, pend);\n\tif (!rc && pflags->urg_data_present) {\n\t\tpflags->urg_data_pending = 0;\n\t\tpflags->urg_data_present = 0;\n\t}\n\nout_unlock:\n\tspin_unlock_bh(&conn->send_lock);\n\tsmc_wr_tx_link_put(link);\n\treturn rc;\n}\n\nstatic int smcd_tx_sndbuf_nonempty(struct smc_connection *conn)\n{\n\tstruct smc_cdc_producer_flags *pflags = &conn->local_tx_ctrl.prod_flags;\n\tint rc = 0;\n\n\tspin_lock_bh(&conn->send_lock);\n\tif (!pflags->urg_data_present)\n\t\trc = smc_tx_rdma_writes(conn, NULL);\n\tif (!rc)\n\t\trc = smcd_cdc_msg_send(conn);\n\n\tif (!rc && pflags->urg_data_present) {\n\t\tpflags->urg_data_pending = 0;\n\t\tpflags->urg_data_present = 0;\n\t}\n\tspin_unlock_bh(&conn->send_lock);\n\treturn rc;\n}\n\nstatic int __smc_tx_sndbuf_nonempty(struct smc_connection *conn)\n{\n\tstruct smc_sock *smc = container_of(conn, struct smc_sock, conn);\n\tint rc = 0;\n\n\t \n\tif (unlikely(smc_tx_prepared_sends(conn) <= 0))\n\t\tgoto out;\n\n\t \n\tif (unlikely(atomic_read(&conn->peer_rmbe_space) <= 0)) {\n\t\tSMC_STAT_RMB_TX_PEER_FULL(smc, !conn->lnk);\n\t\tgoto out;\n\t}\n\n\tif (conn->killed ||\n\t    conn->local_rx_ctrl.conn_state_flags.peer_conn_abort) {\n\t\trc = -EPIPE;     \n\t\tgoto out;\n\t}\n\tif (conn->lgr->is_smcd)\n\t\trc = smcd_tx_sndbuf_nonempty(conn);\n\telse\n\t\trc = smcr_tx_sndbuf_nonempty(conn);\n\n\tif (!rc) {\n\t\t \n\t\tsmc_close_wake_tx_prepared(smc);\n\t}\n\nout:\n\treturn rc;\n}\n\nint smc_tx_sndbuf_nonempty(struct smc_connection *conn)\n{\n\tint rc;\n\n\t \n\tif (atomic_inc_return(&conn->tx_pushing) > 1)\n\t\treturn 0;\n\nagain:\n\tatomic_set(&conn->tx_pushing, 1);\n\tsmp_wmb();  \n\trc = __smc_tx_sndbuf_nonempty(conn);\n\n\t \n\tif (unlikely(!atomic_dec_and_test(&conn->tx_pushing)))\n\t\tgoto again;\n\n\treturn rc;\n}\n\n \nvoid smc_tx_pending(struct smc_connection *conn)\n{\n\tstruct smc_sock *smc = container_of(conn, struct smc_sock, conn);\n\tint rc;\n\n\tif (smc->sk.sk_err)\n\t\treturn;\n\n\trc = smc_tx_sndbuf_nonempty(conn);\n\tif (!rc && conn->local_rx_ctrl.prod_flags.write_blocked &&\n\t    !atomic_read(&conn->bytes_to_rcv))\n\t\tconn->local_rx_ctrl.prod_flags.write_blocked = 0;\n}\n\n \nvoid smc_tx_work(struct work_struct *work)\n{\n\tstruct smc_connection *conn = container_of(to_delayed_work(work),\n\t\t\t\t\t\t   struct smc_connection,\n\t\t\t\t\t\t   tx_work);\n\tstruct smc_sock *smc = container_of(conn, struct smc_sock, conn);\n\n\tlock_sock(&smc->sk);\n\tsmc_tx_pending(conn);\n\trelease_sock(&smc->sk);\n}\n\nvoid smc_tx_consumer_update(struct smc_connection *conn, bool force)\n{\n\tunion smc_host_cursor cfed, cons, prod;\n\tint sender_free = conn->rmb_desc->len;\n\tint to_confirm;\n\n\tsmc_curs_copy(&cons, &conn->local_tx_ctrl.cons, conn);\n\tsmc_curs_copy(&cfed, &conn->rx_curs_confirmed, conn);\n\tto_confirm = smc_curs_diff(conn->rmb_desc->len, &cfed, &cons);\n\tif (to_confirm > conn->rmbe_update_limit) {\n\t\tsmc_curs_copy(&prod, &conn->local_rx_ctrl.prod, conn);\n\t\tsender_free = conn->rmb_desc->len -\n\t\t\t      smc_curs_diff_large(conn->rmb_desc->len,\n\t\t\t\t\t\t  &cfed, &prod);\n\t}\n\n\tif (conn->local_rx_ctrl.prod_flags.cons_curs_upd_req ||\n\t    force ||\n\t    ((to_confirm > conn->rmbe_update_limit) &&\n\t     ((sender_free <= (conn->rmb_desc->len / 2)) ||\n\t      conn->local_rx_ctrl.prod_flags.write_blocked))) {\n\t\tif (conn->killed ||\n\t\t    conn->local_rx_ctrl.conn_state_flags.peer_conn_abort)\n\t\t\treturn;\n\t\tif ((smc_cdc_get_slot_and_msg_send(conn) < 0) &&\n\t\t    !conn->killed) {\n\t\t\tqueue_delayed_work(conn->lgr->tx_wq, &conn->tx_work,\n\t\t\t\t\t   SMC_TX_WORK_DELAY);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (conn->local_rx_ctrl.prod_flags.write_blocked &&\n\t    !atomic_read(&conn->bytes_to_rcv))\n\t\tconn->local_rx_ctrl.prod_flags.write_blocked = 0;\n}\n\n \n\n \nvoid smc_tx_init(struct smc_sock *smc)\n{\n\tsmc->sk.sk_write_space = smc_tx_write_space;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}