{
  "module_name": "smc_close.c",
  "hash_id": "7695f234380f528c8e97f5682bad5254c377e05dbaaec6dc5180a151df1861f3",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_close.c",
  "human_readable_source": "\n \n\n#include <linux/workqueue.h>\n#include <linux/sched/signal.h>\n\n#include <net/sock.h>\n#include <net/tcp.h>\n\n#include \"smc.h\"\n#include \"smc_tx.h\"\n#include \"smc_cdc.h\"\n#include \"smc_close.h\"\n\n \nvoid smc_clcsock_release(struct smc_sock *smc)\n{\n\tstruct socket *tcp;\n\n\tif (smc->listen_smc && current_work() != &smc->smc_listen_work)\n\t\tcancel_work_sync(&smc->smc_listen_work);\n\tmutex_lock(&smc->clcsock_release_lock);\n\tif (smc->clcsock) {\n\t\ttcp = smc->clcsock;\n\t\tsmc->clcsock = NULL;\n\t\tsock_release(tcp);\n\t}\n\tmutex_unlock(&smc->clcsock_release_lock);\n}\n\nstatic void smc_close_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\t \n\twhile ((sk = smc_accept_dequeue(parent, NULL)))\n\t\tsmc_close_non_accepted(sk);\n}\n\n \nstatic void smc_close_stream_wait(struct smc_sock *smc, long timeout)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct sock *sk = &smc->sk;\n\n\tif (!timeout)\n\t\treturn;\n\n\tif (!smc_tx_prepared_sends(&smc->conn))\n\t\treturn;\n\n\t \n\tsmc_tx_pending(&smc->conn);\n\n\tsmc->wait_close_tx_prepared = 1;\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\twhile (!signal_pending(current) && timeout) {\n\t\tint rc;\n\n\t\trc = sk_wait_event(sk, &timeout,\n\t\t\t\t   !smc_tx_prepared_sends(&smc->conn) ||\n\t\t\t\t   READ_ONCE(sk->sk_err) == ECONNABORTED ||\n\t\t\t\t   READ_ONCE(sk->sk_err) == ECONNRESET ||\n\t\t\t\t   smc->conn.killed,\n\t\t\t\t   &wait);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\tsmc->wait_close_tx_prepared = 0;\n}\n\nvoid smc_close_wake_tx_prepared(struct smc_sock *smc)\n{\n\tif (smc->wait_close_tx_prepared)\n\t\t \n\t\tsmc->sk.sk_state_change(&smc->sk);\n}\n\nstatic int smc_close_wr(struct smc_connection *conn)\n{\n\tconn->local_tx_ctrl.conn_state_flags.peer_done_writing = 1;\n\n\treturn smc_cdc_get_slot_and_msg_send(conn);\n}\n\nstatic int smc_close_final(struct smc_connection *conn)\n{\n\tif (atomic_read(&conn->bytes_to_rcv))\n\t\tconn->local_tx_ctrl.conn_state_flags.peer_conn_abort = 1;\n\telse\n\t\tconn->local_tx_ctrl.conn_state_flags.peer_conn_closed = 1;\n\tif (conn->killed)\n\t\treturn -EPIPE;\n\n\treturn smc_cdc_get_slot_and_msg_send(conn);\n}\n\nint smc_close_abort(struct smc_connection *conn)\n{\n\tconn->local_tx_ctrl.conn_state_flags.peer_conn_abort = 1;\n\n\treturn smc_cdc_get_slot_and_msg_send(conn);\n}\n\nstatic void smc_close_cancel_work(struct smc_sock *smc)\n{\n\tstruct sock *sk = &smc->sk;\n\n\trelease_sock(sk);\n\tif (cancel_work_sync(&smc->conn.close_work))\n\t\tsock_put(sk);\n\tcancel_delayed_work_sync(&smc->conn.tx_work);\n\tlock_sock(sk);\n}\n\n \nvoid smc_close_active_abort(struct smc_sock *smc)\n{\n\tstruct sock *sk = &smc->sk;\n\tbool release_clcsock = false;\n\n\tif (sk->sk_state != SMC_INIT && smc->clcsock && smc->clcsock->sk) {\n\t\tsk->sk_err = ECONNABORTED;\n\t\tif (smc->clcsock && smc->clcsock->sk)\n\t\t\ttcp_abort(smc->clcsock->sk, ECONNABORTED);\n\t}\n\tswitch (sk->sk_state) {\n\tcase SMC_ACTIVE:\n\tcase SMC_APPCLOSEWAIT1:\n\tcase SMC_APPCLOSEWAIT2:\n\t\tsk->sk_state = SMC_PEERABORTWAIT;\n\t\tsmc_close_cancel_work(smc);\n\t\tif (sk->sk_state != SMC_PEERABORTWAIT)\n\t\t\tbreak;\n\t\tsk->sk_state = SMC_CLOSED;\n\t\tsock_put(sk);  \n\t\tbreak;\n\tcase SMC_PEERCLOSEWAIT1:\n\tcase SMC_PEERCLOSEWAIT2:\n\tcase SMC_PEERFINCLOSEWAIT:\n\t\tsk->sk_state = SMC_PEERABORTWAIT;\n\t\tsmc_close_cancel_work(smc);\n\t\tif (sk->sk_state != SMC_PEERABORTWAIT)\n\t\t\tbreak;\n\t\tsk->sk_state = SMC_CLOSED;\n\t\tsmc_conn_free(&smc->conn);\n\t\trelease_clcsock = true;\n\t\tsock_put(sk);  \n\t\tbreak;\n\tcase SMC_PROCESSABORT:\n\tcase SMC_APPFINCLOSEWAIT:\n\t\tsk->sk_state = SMC_PEERABORTWAIT;\n\t\tsmc_close_cancel_work(smc);\n\t\tif (sk->sk_state != SMC_PEERABORTWAIT)\n\t\t\tbreak;\n\t\tsk->sk_state = SMC_CLOSED;\n\t\tsmc_conn_free(&smc->conn);\n\t\trelease_clcsock = true;\n\t\tbreak;\n\tcase SMC_INIT:\n\tcase SMC_PEERABORTWAIT:\n\tcase SMC_CLOSED:\n\t\tbreak;\n\t}\n\n\tsmc_sock_set_flag(sk, SOCK_DEAD);\n\tsk->sk_state_change(sk);\n\n\tif (release_clcsock) {\n\t\trelease_sock(sk);\n\t\tsmc_clcsock_release(smc);\n\t\tlock_sock(sk);\n\t}\n}\n\nstatic inline bool smc_close_sent_any_close(struct smc_connection *conn)\n{\n\treturn conn->local_tx_ctrl.conn_state_flags.peer_conn_abort ||\n\t       conn->local_tx_ctrl.conn_state_flags.peer_conn_closed;\n}\n\nint smc_close_active(struct smc_sock *smc)\n{\n\tstruct smc_cdc_conn_state_flags *txflags =\n\t\t&smc->conn.local_tx_ctrl.conn_state_flags;\n\tstruct smc_connection *conn = &smc->conn;\n\tstruct sock *sk = &smc->sk;\n\tint old_state;\n\tlong timeout;\n\tint rc = 0;\n\tint rc1 = 0;\n\n\ttimeout = current->flags & PF_EXITING ?\n\t\t  0 : sock_flag(sk, SOCK_LINGER) ?\n\t\t      sk->sk_lingertime : SMC_MAX_STREAM_WAIT_TIMEOUT;\n\n\told_state = sk->sk_state;\nagain:\n\tswitch (sk->sk_state) {\n\tcase SMC_INIT:\n\t\tsk->sk_state = SMC_CLOSED;\n\t\tbreak;\n\tcase SMC_LISTEN:\n\t\tsk->sk_state = SMC_CLOSED;\n\t\tsk->sk_state_change(sk);  \n\t\tif (smc->clcsock && smc->clcsock->sk) {\n\t\t\twrite_lock_bh(&smc->clcsock->sk->sk_callback_lock);\n\t\t\tsmc_clcsock_restore_cb(&smc->clcsock->sk->sk_data_ready,\n\t\t\t\t\t       &smc->clcsk_data_ready);\n\t\t\tsmc->clcsock->sk->sk_user_data = NULL;\n\t\t\twrite_unlock_bh(&smc->clcsock->sk->sk_callback_lock);\n\t\t\trc = kernel_sock_shutdown(smc->clcsock, SHUT_RDWR);\n\t\t}\n\t\tsmc_close_cleanup_listen(sk);\n\t\trelease_sock(sk);\n\t\tflush_work(&smc->tcp_listen_work);\n\t\tlock_sock(sk);\n\t\tbreak;\n\tcase SMC_ACTIVE:\n\t\tsmc_close_stream_wait(smc, timeout);\n\t\trelease_sock(sk);\n\t\tcancel_delayed_work_sync(&conn->tx_work);\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state == SMC_ACTIVE) {\n\t\t\t \n\t\t\trc = smc_close_final(conn);\n\t\t\tsk->sk_state = SMC_PEERCLOSEWAIT1;\n\n\t\t\t \n\t\t\tif (smc->clcsock && smc->clcsock->sk) {\n\t\t\t\trc1 = kernel_sock_shutdown(smc->clcsock,\n\t\t\t\t\t\t\t   SHUT_RDWR);\n\t\t\t\trc = rc ? rc : rc1;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tgoto again;\n\t\t}\n\t\tbreak;\n\tcase SMC_APPFINCLOSEWAIT:\n\t\t \n\t\tif (txflags->peer_done_writing &&\n\t\t    !smc_close_sent_any_close(conn)) {\n\t\t\t \n\t\t\trc = smc_close_final(conn);\n\t\t}\n\t\tsk->sk_state = SMC_CLOSED;\n\t\tbreak;\n\tcase SMC_APPCLOSEWAIT1:\n\tcase SMC_APPCLOSEWAIT2:\n\t\tif (!smc_cdc_rxed_any_close(conn))\n\t\t\tsmc_close_stream_wait(smc, timeout);\n\t\trelease_sock(sk);\n\t\tcancel_delayed_work_sync(&conn->tx_work);\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state != SMC_APPCLOSEWAIT1 &&\n\t\t    sk->sk_state != SMC_APPCLOSEWAIT2)\n\t\t\tgoto again;\n\t\t \n\t\trc = smc_close_final(conn);\n\t\tif (smc_cdc_rxed_any_close(conn)) {\n\t\t\t \n\t\t\tsk->sk_state = SMC_CLOSED;\n\t\t\tsock_put(sk);  \n\t\t} else {\n\t\t\t \n\t\t\tsk->sk_state = SMC_PEERFINCLOSEWAIT;\n\t\t}\n\t\tbreak;\n\tcase SMC_PEERCLOSEWAIT1:\n\tcase SMC_PEERCLOSEWAIT2:\n\t\tif (txflags->peer_done_writing &&\n\t\t    !smc_close_sent_any_close(conn)) {\n\t\t\t \n\t\t\trc = smc_close_final(conn);\n\t\t}\n\t\t \n\t\tbreak;\n\tcase SMC_PEERFINCLOSEWAIT:\n\t\t \n\t\tbreak;\n\tcase SMC_PROCESSABORT:\n\t\trc = smc_close_abort(conn);\n\t\tsk->sk_state = SMC_CLOSED;\n\t\tbreak;\n\tcase SMC_PEERABORTWAIT:\n\t\tsk->sk_state = SMC_CLOSED;\n\t\tbreak;\n\tcase SMC_CLOSED:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (old_state != sk->sk_state)\n\t\tsk->sk_state_change(sk);\n\treturn rc;\n}\n\nstatic void smc_close_passive_abort_received(struct smc_sock *smc)\n{\n\tstruct smc_cdc_conn_state_flags *txflags =\n\t\t&smc->conn.local_tx_ctrl.conn_state_flags;\n\tstruct sock *sk = &smc->sk;\n\n\tswitch (sk->sk_state) {\n\tcase SMC_INIT:\n\tcase SMC_ACTIVE:\n\tcase SMC_APPCLOSEWAIT1:\n\t\tsk->sk_state = SMC_PROCESSABORT;\n\t\tsock_put(sk);  \n\t\tbreak;\n\tcase SMC_APPFINCLOSEWAIT:\n\t\tsk->sk_state = SMC_PROCESSABORT;\n\t\tbreak;\n\tcase SMC_PEERCLOSEWAIT1:\n\tcase SMC_PEERCLOSEWAIT2:\n\t\tif (txflags->peer_done_writing &&\n\t\t    !smc_close_sent_any_close(&smc->conn))\n\t\t\t \n\t\t\tsk->sk_state = SMC_PROCESSABORT;\n\t\telse\n\t\t\tsk->sk_state = SMC_CLOSED;\n\t\tsock_put(sk);  \n\t\tbreak;\n\tcase SMC_APPCLOSEWAIT2:\n\tcase SMC_PEERFINCLOSEWAIT:\n\t\tsk->sk_state = SMC_CLOSED;\n\t\tsock_put(sk);  \n\t\tbreak;\n\tcase SMC_PEERABORTWAIT:\n\t\tsk->sk_state = SMC_CLOSED;\n\t\tbreak;\n\tcase SMC_PROCESSABORT:\n\t \n\t\tbreak;\n\t}\n}\n\n \nstatic void smc_close_passive_work(struct work_struct *work)\n{\n\tstruct smc_connection *conn = container_of(work,\n\t\t\t\t\t\t   struct smc_connection,\n\t\t\t\t\t\t   close_work);\n\tstruct smc_sock *smc = container_of(conn, struct smc_sock, conn);\n\tstruct smc_cdc_conn_state_flags *rxflags;\n\tbool release_clcsock = false;\n\tstruct sock *sk = &smc->sk;\n\tint old_state;\n\n\tlock_sock(sk);\n\told_state = sk->sk_state;\n\n\trxflags = &conn->local_rx_ctrl.conn_state_flags;\n\tif (rxflags->peer_conn_abort) {\n\t\t \n\t\tsmc_close_passive_abort_received(smc);\n\t\trelease_sock(sk);\n\t\tcancel_delayed_work_sync(&conn->tx_work);\n\t\tlock_sock(sk);\n\t\tgoto wakeup;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase SMC_INIT:\n\t\tsk->sk_state = SMC_APPCLOSEWAIT1;\n\t\tbreak;\n\tcase SMC_ACTIVE:\n\t\tsk->sk_state = SMC_APPCLOSEWAIT1;\n\t\t \n\t\tbreak;\n\tcase SMC_PEERCLOSEWAIT1:\n\t\tif (rxflags->peer_done_writing)\n\t\t\tsk->sk_state = SMC_PEERCLOSEWAIT2;\n\t\tfallthrough;\n\t\t \n\tcase SMC_PEERCLOSEWAIT2:\n\t\tif (!smc_cdc_rxed_any_close(conn))\n\t\t\tbreak;\n\t\tif (sock_flag(sk, SOCK_DEAD) &&\n\t\t    smc_close_sent_any_close(conn)) {\n\t\t\t \n\t\t\tsk->sk_state = SMC_CLOSED;\n\t\t} else {\n\t\t\t \n\t\t\tsk->sk_state = SMC_APPFINCLOSEWAIT;\n\t\t}\n\t\tsock_put(sk);  \n\t\tbreak;\n\tcase SMC_PEERFINCLOSEWAIT:\n\t\tif (smc_cdc_rxed_any_close(conn)) {\n\t\t\tsk->sk_state = SMC_CLOSED;\n\t\t\tsock_put(sk);  \n\t\t}\n\t\tbreak;\n\tcase SMC_APPCLOSEWAIT1:\n\tcase SMC_APPCLOSEWAIT2:\n\t\t \n\t\tbreak;\n\tcase SMC_APPFINCLOSEWAIT:\n\tcase SMC_PEERABORTWAIT:\n\tcase SMC_PROCESSABORT:\n\tcase SMC_CLOSED:\n\t\t \n\t\tbreak;\n\t}\n\nwakeup:\n\tsk->sk_data_ready(sk);  \n\tsk->sk_write_space(sk);  \n\n\tif (old_state != sk->sk_state) {\n\t\tsk->sk_state_change(sk);\n\t\tif ((sk->sk_state == SMC_CLOSED) &&\n\t\t    (sock_flag(sk, SOCK_DEAD) || !sk->sk_socket)) {\n\t\t\tsmc_conn_free(conn);\n\t\t\tif (smc->clcsock)\n\t\t\t\trelease_clcsock = true;\n\t\t}\n\t}\n\trelease_sock(sk);\n\tif (release_clcsock)\n\t\tsmc_clcsock_release(smc);\n\tsock_put(sk);  \n}\n\nint smc_close_shutdown_write(struct smc_sock *smc)\n{\n\tstruct smc_connection *conn = &smc->conn;\n\tstruct sock *sk = &smc->sk;\n\tint old_state;\n\tlong timeout;\n\tint rc = 0;\n\n\ttimeout = current->flags & PF_EXITING ?\n\t\t  0 : sock_flag(sk, SOCK_LINGER) ?\n\t\t      sk->sk_lingertime : SMC_MAX_STREAM_WAIT_TIMEOUT;\n\n\told_state = sk->sk_state;\nagain:\n\tswitch (sk->sk_state) {\n\tcase SMC_ACTIVE:\n\t\tsmc_close_stream_wait(smc, timeout);\n\t\trelease_sock(sk);\n\t\tcancel_delayed_work_sync(&conn->tx_work);\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state != SMC_ACTIVE)\n\t\t\tgoto again;\n\t\t \n\t\trc = smc_close_wr(conn);\n\t\tsk->sk_state = SMC_PEERCLOSEWAIT1;\n\t\tbreak;\n\tcase SMC_APPCLOSEWAIT1:\n\t\t \n\t\tif (!smc_cdc_rxed_any_close(conn))\n\t\t\tsmc_close_stream_wait(smc, timeout);\n\t\trelease_sock(sk);\n\t\tcancel_delayed_work_sync(&conn->tx_work);\n\t\tlock_sock(sk);\n\t\tif (sk->sk_state != SMC_APPCLOSEWAIT1)\n\t\t\tgoto again;\n\t\t \n\t\trc = smc_close_wr(conn);\n\t\tsk->sk_state = SMC_APPCLOSEWAIT2;\n\t\tbreak;\n\tcase SMC_APPCLOSEWAIT2:\n\tcase SMC_PEERFINCLOSEWAIT:\n\tcase SMC_PEERCLOSEWAIT1:\n\tcase SMC_PEERCLOSEWAIT2:\n\tcase SMC_APPFINCLOSEWAIT:\n\tcase SMC_PROCESSABORT:\n\tcase SMC_PEERABORTWAIT:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (old_state != sk->sk_state)\n\t\tsk->sk_state_change(sk);\n\treturn rc;\n}\n\n \nvoid smc_close_init(struct smc_sock *smc)\n{\n\tINIT_WORK(&smc->conn.close_work, smc_close_passive_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}