{
  "module_name": "smc_wr.h",
  "hash_id": "c3e38f9922c84ccd368c61741010becfd7fa07be28466d8d5eaa97fd69ed9259",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_wr.h",
  "human_readable_source": " \n \n\n#ifndef SMC_WR_H\n#define SMC_WR_H\n\n#include <linux/atomic.h>\n#include <rdma/ib_verbs.h>\n#include <asm/div64.h>\n\n#include \"smc.h\"\n#include \"smc_core.h\"\n\n#define SMC_WR_BUF_CNT 16\t \n\n#define SMC_WR_TX_WAIT_FREE_SLOT_TIME\t(10 * HZ)\n\n#define SMC_WR_TX_SIZE 44  \n\n#define SMC_WR_TX_PEND_PRIV_SIZE 32\n\nstruct smc_wr_tx_pend_priv {\n\tu8\t\t\tpriv[SMC_WR_TX_PEND_PRIV_SIZE];\n};\n\ntypedef void (*smc_wr_tx_handler)(struct smc_wr_tx_pend_priv *,\n\t\t\t\t  struct smc_link *,\n\t\t\t\t  enum ib_wc_status);\n\ntypedef bool (*smc_wr_tx_filter)(struct smc_wr_tx_pend_priv *,\n\t\t\t\t unsigned long);\n\ntypedef void (*smc_wr_tx_dismisser)(struct smc_wr_tx_pend_priv *);\n\nstruct smc_wr_rx_handler {\n\tstruct hlist_node\tlist;\t \n\tvoid\t\t\t(*handler)(struct ib_wc *, void *);\n\tu8\t\t\ttype;\n};\n\n \nstatic inline long smc_wr_tx_get_next_wr_id(struct smc_link *link)\n{\n\treturn atomic_long_inc_return(&link->wr_tx_id);\n}\n\nstatic inline void smc_wr_tx_set_wr_id(atomic_long_t *wr_tx_id, long val)\n{\n\tatomic_long_set(wr_tx_id, val);\n}\n\nstatic inline bool smc_wr_tx_link_hold(struct smc_link *link)\n{\n\tif (!smc_link_sendable(link))\n\t\treturn false;\n\tpercpu_ref_get(&link->wr_tx_refs);\n\treturn true;\n}\n\nstatic inline void smc_wr_tx_link_put(struct smc_link *link)\n{\n\tpercpu_ref_put(&link->wr_tx_refs);\n}\n\nstatic inline void smc_wr_drain_cq(struct smc_link *lnk)\n{\n\twait_event(lnk->wr_rx_empty_wait, lnk->wr_rx_id_compl == lnk->wr_rx_id);\n}\n\nstatic inline void smc_wr_wakeup_tx_wait(struct smc_link *lnk)\n{\n\twake_up_all(&lnk->wr_tx_wait);\n}\n\nstatic inline void smc_wr_wakeup_reg_wait(struct smc_link *lnk)\n{\n\twake_up(&lnk->wr_reg_wait);\n}\n\n \nstatic inline int smc_wr_rx_post(struct smc_link *link)\n{\n\tint rc;\n\tu64 wr_id, temp_wr_id;\n\tu32 index;\n\n\twr_id = ++link->wr_rx_id;  \n\ttemp_wr_id = wr_id;\n\tindex = do_div(temp_wr_id, link->wr_rx_cnt);\n\tlink->wr_rx_ibs[index].wr_id = wr_id;\n\trc = ib_post_recv(link->roce_qp, &link->wr_rx_ibs[index], NULL);\n\treturn rc;\n}\n\nint smc_wr_create_link(struct smc_link *lnk);\nint smc_wr_alloc_link_mem(struct smc_link *lnk);\nint smc_wr_alloc_lgr_mem(struct smc_link_group *lgr);\nvoid smc_wr_free_link(struct smc_link *lnk);\nvoid smc_wr_free_link_mem(struct smc_link *lnk);\nvoid smc_wr_free_lgr_mem(struct smc_link_group *lgr);\nvoid smc_wr_remember_qp_attr(struct smc_link *lnk);\nvoid smc_wr_remove_dev(struct smc_ib_device *smcibdev);\nvoid smc_wr_add_dev(struct smc_ib_device *smcibdev);\n\nint smc_wr_tx_get_free_slot(struct smc_link *link, smc_wr_tx_handler handler,\n\t\t\t    struct smc_wr_buf **wr_buf,\n\t\t\t    struct smc_rdma_wr **wrs,\n\t\t\t    struct smc_wr_tx_pend_priv **wr_pend_priv);\nint smc_wr_tx_get_v2_slot(struct smc_link *link,\n\t\t\t  smc_wr_tx_handler handler,\n\t\t\t  struct smc_wr_v2_buf **wr_buf,\n\t\t\t  struct smc_wr_tx_pend_priv **wr_pend_priv);\nint smc_wr_tx_put_slot(struct smc_link *link,\n\t\t       struct smc_wr_tx_pend_priv *wr_pend_priv);\nint smc_wr_tx_send(struct smc_link *link,\n\t\t   struct smc_wr_tx_pend_priv *wr_pend_priv);\nint smc_wr_tx_v2_send(struct smc_link *link,\n\t\t      struct smc_wr_tx_pend_priv *priv, int len);\nint smc_wr_tx_send_wait(struct smc_link *link, struct smc_wr_tx_pend_priv *priv,\n\t\t\tunsigned long timeout);\nvoid smc_wr_tx_cq_handler(struct ib_cq *ib_cq, void *cq_context);\nvoid smc_wr_tx_wait_no_pending_sends(struct smc_link *link);\n\nint smc_wr_rx_register_handler(struct smc_wr_rx_handler *handler);\nint smc_wr_rx_post_init(struct smc_link *link);\nvoid smc_wr_rx_cq_handler(struct ib_cq *ib_cq, void *cq_context);\nint smc_wr_reg_send(struct smc_link *link, struct ib_mr *mr);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}