{
  "module_name": "smc_diag.c",
  "hash_id": "879df46cac0a3a0f6db15e02ac0f67b9cf7f1ccd5cdcc416de4b59479401c357",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_diag.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/sock_diag.h>\n#include <linux/inet_diag.h>\n#include <linux/smc_diag.h>\n#include <net/netlink.h>\n#include <net/smc.h>\n\n#include \"smc.h\"\n#include \"smc_core.h\"\n\nstruct smc_diag_dump_ctx {\n\tint pos[2];\n};\n\nstatic struct smc_diag_dump_ctx *smc_dump_context(struct netlink_callback *cb)\n{\n\treturn (struct smc_diag_dump_ctx *)cb->ctx;\n}\n\nstatic void smc_diag_msg_common_fill(struct smc_diag_msg *r, struct sock *sk)\n{\n\tstruct smc_sock *smc = smc_sk(sk);\n\n\tmemset(r, 0, sizeof(*r));\n\tr->diag_family = sk->sk_family;\n\tsock_diag_save_cookie(sk, r->id.idiag_cookie);\n\tif (!smc->clcsock)\n\t\treturn;\n\tr->id.idiag_sport = htons(smc->clcsock->sk->sk_num);\n\tr->id.idiag_dport = smc->clcsock->sk->sk_dport;\n\tr->id.idiag_if = smc->clcsock->sk->sk_bound_dev_if;\n\tif (sk->sk_protocol == SMCPROTO_SMC) {\n\t\tr->id.idiag_src[0] = smc->clcsock->sk->sk_rcv_saddr;\n\t\tr->id.idiag_dst[0] = smc->clcsock->sk->sk_daddr;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (sk->sk_protocol == SMCPROTO_SMC6) {\n\t\tmemcpy(&r->id.idiag_src, &smc->clcsock->sk->sk_v6_rcv_saddr,\n\t\t       sizeof(smc->clcsock->sk->sk_v6_rcv_saddr));\n\t\tmemcpy(&r->id.idiag_dst, &smc->clcsock->sk->sk_v6_daddr,\n\t\t       sizeof(smc->clcsock->sk->sk_v6_daddr));\n#endif\n\t}\n}\n\nstatic int smc_diag_msg_attrs_fill(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t   struct smc_diag_msg *r,\n\t\t\t\t   struct user_namespace *user_ns)\n{\n\tif (nla_put_u8(skb, SMC_DIAG_SHUTDOWN, sk->sk_shutdown))\n\t\treturn 1;\n\n\tr->diag_uid = from_kuid_munged(user_ns, sock_i_uid(sk));\n\tr->diag_inode = sock_i_ino(sk);\n\treturn 0;\n}\n\nstatic int __smc_diag_dump(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct netlink_callback *cb,\n\t\t\t   const struct smc_diag_req *req,\n\t\t\t   struct nlattr *bc)\n{\n\tstruct smc_sock *smc = smc_sk(sk);\n\tstruct smc_diag_fallback fallback;\n\tstruct user_namespace *user_ns;\n\tstruct smc_diag_msg *r;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\tcb->nlh->nlmsg_type, sizeof(*r), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tr = nlmsg_data(nlh);\n\tsmc_diag_msg_common_fill(r, sk);\n\tr->diag_state = sk->sk_state;\n\tif (smc->use_fallback)\n\t\tr->diag_mode = SMC_DIAG_MODE_FALLBACK_TCP;\n\telse if (smc_conn_lgr_valid(&smc->conn) && smc->conn.lgr->is_smcd)\n\t\tr->diag_mode = SMC_DIAG_MODE_SMCD;\n\telse\n\t\tr->diag_mode = SMC_DIAG_MODE_SMCR;\n\tuser_ns = sk_user_ns(NETLINK_CB(cb->skb).sk);\n\tif (smc_diag_msg_attrs_fill(sk, skb, r, user_ns))\n\t\tgoto errout;\n\n\tfallback.reason = smc->fallback_rsn;\n\tfallback.peer_diagnosis = smc->peer_diagnosis;\n\tif (nla_put(skb, SMC_DIAG_FALLBACK, sizeof(fallback), &fallback) < 0)\n\t\tgoto errout;\n\n\tif ((req->diag_ext & (1 << (SMC_DIAG_CONNINFO - 1))) &&\n\t    smc->conn.alert_token_local) {\n\t\tstruct smc_connection *conn = &smc->conn;\n\t\tstruct smc_diag_conninfo cinfo = {\n\t\t\t.token = conn->alert_token_local,\n\t\t\t.sndbuf_size = conn->sndbuf_desc ?\n\t\t\t\tconn->sndbuf_desc->len : 0,\n\t\t\t.rmbe_size = conn->rmb_desc ? conn->rmb_desc->len : 0,\n\t\t\t.peer_rmbe_size = conn->peer_rmbe_size,\n\n\t\t\t.rx_prod.wrap = conn->local_rx_ctrl.prod.wrap,\n\t\t\t.rx_prod.count = conn->local_rx_ctrl.prod.count,\n\t\t\t.rx_cons.wrap = conn->local_rx_ctrl.cons.wrap,\n\t\t\t.rx_cons.count = conn->local_rx_ctrl.cons.count,\n\n\t\t\t.tx_prod.wrap = conn->local_tx_ctrl.prod.wrap,\n\t\t\t.tx_prod.count = conn->local_tx_ctrl.prod.count,\n\t\t\t.tx_cons.wrap = conn->local_tx_ctrl.cons.wrap,\n\t\t\t.tx_cons.count = conn->local_tx_ctrl.cons.count,\n\n\t\t\t.tx_prod_flags =\n\t\t\t\t*(u8 *)&conn->local_tx_ctrl.prod_flags,\n\t\t\t.tx_conn_state_flags =\n\t\t\t\t*(u8 *)&conn->local_tx_ctrl.conn_state_flags,\n\t\t\t.rx_prod_flags = *(u8 *)&conn->local_rx_ctrl.prod_flags,\n\t\t\t.rx_conn_state_flags =\n\t\t\t\t*(u8 *)&conn->local_rx_ctrl.conn_state_flags,\n\n\t\t\t.tx_prep.wrap = conn->tx_curs_prep.wrap,\n\t\t\t.tx_prep.count = conn->tx_curs_prep.count,\n\t\t\t.tx_sent.wrap = conn->tx_curs_sent.wrap,\n\t\t\t.tx_sent.count = conn->tx_curs_sent.count,\n\t\t\t.tx_fin.wrap = conn->tx_curs_fin.wrap,\n\t\t\t.tx_fin.count = conn->tx_curs_fin.count,\n\t\t};\n\n\t\tif (nla_put(skb, SMC_DIAG_CONNINFO, sizeof(cinfo), &cinfo) < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif (smc_conn_lgr_valid(&smc->conn) && !smc->conn.lgr->is_smcd &&\n\t    (req->diag_ext & (1 << (SMC_DIAG_LGRINFO - 1))) &&\n\t    !list_empty(&smc->conn.lgr->list)) {\n\t\tstruct smc_link *link = smc->conn.lnk;\n\n\t\tstruct smc_diag_lgrinfo linfo = {\n\t\t\t.role = smc->conn.lgr->role,\n\t\t\t.lnk[0].ibport = link->ibport,\n\t\t\t.lnk[0].link_id = link->link_id,\n\t\t};\n\n\t\tmemcpy(linfo.lnk[0].ibname, link->smcibdev->ibdev->name,\n\t\t       sizeof(link->smcibdev->ibdev->name));\n\t\tsmc_gid_be16_convert(linfo.lnk[0].gid, link->gid);\n\t\tsmc_gid_be16_convert(linfo.lnk[0].peer_gid, link->peer_gid);\n\n\t\tif (nla_put(skb, SMC_DIAG_LGRINFO, sizeof(linfo), &linfo) < 0)\n\t\t\tgoto errout;\n\t}\n\tif (smc_conn_lgr_valid(&smc->conn) && smc->conn.lgr->is_smcd &&\n\t    (req->diag_ext & (1 << (SMC_DIAG_DMBINFO - 1))) &&\n\t    !list_empty(&smc->conn.lgr->list)) {\n\t\tstruct smc_connection *conn = &smc->conn;\n\t\tstruct smcd_diag_dmbinfo dinfo;\n\t\tstruct smcd_dev *smcd = conn->lgr->smcd;\n\n\t\tmemset(&dinfo, 0, sizeof(dinfo));\n\n\t\tdinfo.linkid = *((u32 *)conn->lgr->id);\n\t\tdinfo.peer_gid = conn->lgr->peer_gid;\n\t\tdinfo.my_gid = smcd->ops->get_local_gid(smcd);\n\t\tdinfo.token = conn->rmb_desc->token;\n\t\tdinfo.peer_token = conn->peer_token;\n\n\t\tif (nla_put(skb, SMC_DIAG_DMBINFO, sizeof(dinfo), &dinfo) < 0)\n\t\t\tgoto errout;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nerrout:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int smc_diag_dump_proto(struct proto *prot, struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb, int p_type)\n{\n\tstruct smc_diag_dump_ctx *cb_ctx = smc_dump_context(cb);\n\tstruct net *net = sock_net(skb->sk);\n\tint snum = cb_ctx->pos[p_type];\n\tstruct nlattr *bc = NULL;\n\tstruct hlist_head *head;\n\tint rc = 0, num = 0;\n\tstruct sock *sk;\n\n\tread_lock(&prot->h.smc_hash->lock);\n\thead = &prot->h.smc_hash->ht;\n\tif (hlist_empty(head))\n\t\tgoto out;\n\n\tsk_for_each(sk, head) {\n\t\tif (!net_eq(sock_net(sk), net))\n\t\t\tcontinue;\n\t\tif (num < snum)\n\t\t\tgoto next;\n\t\trc = __smc_diag_dump(sk, skb, cb, nlmsg_data(cb->nlh), bc);\n\t\tif (rc < 0)\n\t\t\tgoto out;\nnext:\n\t\tnum++;\n\t}\n\nout:\n\tread_unlock(&prot->h.smc_hash->lock);\n\tcb_ctx->pos[p_type] = num;\n\treturn rc;\n}\n\nstatic int smc_diag_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint rc = 0;\n\n\trc = smc_diag_dump_proto(&smc_proto, skb, cb, SMCPROTO_SMC);\n\tif (!rc)\n\t\tsmc_diag_dump_proto(&smc_proto6, skb, cb, SMCPROTO_SMC6);\n\treturn skb->len;\n}\n\nstatic int smc_diag_handler_dump(struct sk_buff *skb, struct nlmsghdr *h)\n{\n\tstruct net *net = sock_net(skb->sk);\n\n\tif (h->nlmsg_type == SOCK_DIAG_BY_FAMILY &&\n\t    h->nlmsg_flags & NLM_F_DUMP) {\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = smc_diag_dump,\n\t\t\t\t.min_dump_alloc = SKB_WITH_OVERHEAD(32768),\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->diag_nlsk, skb, h, &c);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct sock_diag_handler smc_diag_handler = {\n\t.family = AF_SMC,\n\t.dump = smc_diag_handler_dump,\n};\n\nstatic int __init smc_diag_init(void)\n{\n\treturn sock_diag_register(&smc_diag_handler);\n}\n\nstatic void __exit smc_diag_exit(void)\n{\n\tsock_diag_unregister(&smc_diag_handler);\n}\n\nmodule_init(smc_diag_init);\nmodule_exit(smc_diag_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 43  );\nMODULE_ALIAS_GENL_FAMILY(SMCR_GENL_FAMILY_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}