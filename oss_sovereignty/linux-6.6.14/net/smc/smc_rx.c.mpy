{
  "module_name": "smc_rx.c",
  "hash_id": "f666c2f750f701bdbd75f717152ca014db8a67b261e7d4e8626c509754307ed9",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_rx.c",
  "human_readable_source": "\n \n\n#include <linux/net.h>\n#include <linux/rcupdate.h>\n#include <linux/sched/signal.h>\n#include <linux/splice.h>\n\n#include <net/sock.h>\n#include <trace/events/sock.h>\n\n#include \"smc.h\"\n#include \"smc_core.h\"\n#include \"smc_cdc.h\"\n#include \"smc_tx.h\"  \n#include \"smc_rx.h\"\n#include \"smc_stats.h\"\n#include \"smc_tracepoint.h\"\n\n \nstatic void smc_rx_wake_up(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\ttrace_sk_data_ready(sk);\n\n\t \n\t \n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (skwq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, EPOLLIN | EPOLLPRI |\n\t\t\t\t\t\tEPOLLRDNORM | EPOLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\tif ((sk->sk_shutdown == SHUTDOWN_MASK) ||\n\t    (sk->sk_state == SMC_CLOSED))\n\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\trcu_read_unlock();\n}\n\n \nstatic int smc_rx_update_consumer(struct smc_sock *smc,\n\t\t\t\t  union smc_host_cursor cons, size_t len)\n{\n\tstruct smc_connection *conn = &smc->conn;\n\tstruct sock *sk = &smc->sk;\n\tbool force = false;\n\tint diff, rc = 0;\n\n\tsmc_curs_add(conn->rmb_desc->len, &cons, len);\n\n\t \n\tif (conn->urg_state == SMC_URG_VALID || conn->urg_rx_skip_pend) {\n\t\tdiff = smc_curs_comp(conn->rmb_desc->len, &cons,\n\t\t\t\t     &conn->urg_curs);\n\t\tif (sock_flag(sk, SOCK_URGINLINE)) {\n\t\t\tif (diff == 0) {\n\t\t\t\tforce = true;\n\t\t\t\trc = 1;\n\t\t\t\tconn->urg_state = SMC_URG_READ;\n\t\t\t}\n\t\t} else {\n\t\t\tif (diff == 1) {\n\t\t\t\t \n\t\t\t\tforce = true;\n\t\t\t\tsmc_curs_add(conn->rmb_desc->len, &cons, 1);\n\t\t\t\tconn->urg_rx_skip_pend = false;\n\t\t\t} else if (diff < -1)\n\t\t\t\t \n\t\t\t\tconn->urg_state = SMC_URG_READ;\n\t\t}\n\t}\n\n\tsmc_curs_copy(&conn->local_tx_ctrl.cons, &cons, conn);\n\n\t \n\t \n\tsmc_tx_consumer_update(conn, force);\n\n\treturn rc;\n}\n\nstatic void smc_rx_update_cons(struct smc_sock *smc, size_t len)\n{\n\tstruct smc_connection *conn = &smc->conn;\n\tunion smc_host_cursor cons;\n\n\tsmc_curs_copy(&cons, &conn->local_tx_ctrl.cons, conn);\n\tsmc_rx_update_consumer(smc, cons, len);\n}\n\nstruct smc_spd_priv {\n\tstruct smc_sock *smc;\n\tsize_t\t\t len;\n};\n\nstatic void smc_rx_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\tstruct smc_spd_priv *priv = (struct smc_spd_priv *)buf->private;\n\tstruct smc_sock *smc = priv->smc;\n\tstruct smc_connection *conn;\n\tstruct sock *sk = &smc->sk;\n\n\tif (sk->sk_state == SMC_CLOSED ||\n\t    sk->sk_state == SMC_PEERFINCLOSEWAIT ||\n\t    sk->sk_state == SMC_APPFINCLOSEWAIT)\n\t\tgoto out;\n\tconn = &smc->conn;\n\tlock_sock(sk);\n\tsmc_rx_update_cons(smc, priv->len);\n\trelease_sock(sk);\n\tif (atomic_sub_and_test(priv->len, &conn->splice_pending))\n\t\tsmc_rx_wake_up(sk);\nout:\n\tkfree(priv);\n\tput_page(buf->page);\n\tsock_put(sk);\n}\n\nstatic const struct pipe_buf_operations smc_pipe_ops = {\n\t.release = smc_rx_pipe_buf_release,\n\t.get = generic_pipe_buf_get\n};\n\nstatic void smc_rx_spd_release(struct splice_pipe_desc *spd,\n\t\t\t       unsigned int i)\n{\n\tput_page(spd->pages[i]);\n}\n\nstatic int smc_rx_splice(struct pipe_inode_info *pipe, char *src, size_t len,\n\t\t\t struct smc_sock *smc)\n{\n\tstruct smc_link_group *lgr = smc->conn.lgr;\n\tint offset = offset_in_page(src);\n\tstruct partial_page *partial;\n\tstruct splice_pipe_desc spd;\n\tstruct smc_spd_priv **priv;\n\tstruct page **pages;\n\tint bytes, nr_pages;\n\tint i;\n\n\tnr_pages = !lgr->is_smcd && smc->conn.rmb_desc->is_vm ?\n\t\t   PAGE_ALIGN(len + offset) / PAGE_SIZE : 1;\n\n\tpages = kcalloc(nr_pages, sizeof(*pages), GFP_KERNEL);\n\tif (!pages)\n\t\tgoto out;\n\tpartial = kcalloc(nr_pages, sizeof(*partial), GFP_KERNEL);\n\tif (!partial)\n\t\tgoto out_page;\n\tpriv = kcalloc(nr_pages, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\tgoto out_part;\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpriv[i] = kzalloc(sizeof(**priv), GFP_KERNEL);\n\t\tif (!priv[i])\n\t\t\tgoto out_priv;\n\t}\n\n\tif (lgr->is_smcd ||\n\t    (!lgr->is_smcd && !smc->conn.rmb_desc->is_vm)) {\n\t\t \n\t\tpriv[0]->len = len;\n\t\tpriv[0]->smc = smc;\n\t\tpartial[0].offset = src - (char *)smc->conn.rmb_desc->cpu_addr;\n\t\tpartial[0].len = len;\n\t\tpartial[0].private = (unsigned long)priv[0];\n\t\tpages[0] = smc->conn.rmb_desc->pages;\n\t} else {\n\t\tint size, left = len;\n\t\tvoid *buf = src;\n\t\t \n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tsize = min_t(int, PAGE_SIZE - offset, left);\n\t\t\tpriv[i]->len = size;\n\t\t\tpriv[i]->smc = smc;\n\t\t\tpages[i] = vmalloc_to_page(buf);\n\t\t\tpartial[i].offset = offset;\n\t\t\tpartial[i].len = size;\n\t\t\tpartial[i].private = (unsigned long)priv[i];\n\t\t\tbuf += size / sizeof(*buf);\n\t\t\tleft -= size;\n\t\t\toffset = 0;\n\t\t}\n\t}\n\tspd.nr_pages_max = nr_pages;\n\tspd.nr_pages = nr_pages;\n\tspd.pages = pages;\n\tspd.partial = partial;\n\tspd.ops = &smc_pipe_ops;\n\tspd.spd_release = smc_rx_spd_release;\n\n\tbytes = splice_to_pipe(pipe, &spd);\n\tif (bytes > 0) {\n\t\tsock_hold(&smc->sk);\n\t\tif (!lgr->is_smcd && smc->conn.rmb_desc->is_vm) {\n\t\t\tfor (i = 0; i < PAGE_ALIGN(bytes + offset) / PAGE_SIZE; i++)\n\t\t\t\tget_page(pages[i]);\n\t\t} else {\n\t\t\tget_page(smc->conn.rmb_desc->pages);\n\t\t}\n\t\tatomic_add(bytes, &smc->conn.splice_pending);\n\t}\n\tkfree(priv);\n\tkfree(partial);\n\tkfree(pages);\n\n\treturn bytes;\n\nout_priv:\n\tfor (i = (i - 1); i >= 0; i--)\n\t\tkfree(priv[i]);\n\tkfree(priv);\nout_part:\n\tkfree(partial);\nout_page:\n\tkfree(pages);\nout:\n\treturn -ENOMEM;\n}\n\nstatic int smc_rx_data_available_and_no_splice_pend(struct smc_connection *conn)\n{\n\treturn atomic_read(&conn->bytes_to_rcv) &&\n\t       !atomic_read(&conn->splice_pending);\n}\n\n \nint smc_rx_wait(struct smc_sock *smc, long *timeo,\n\t\tint (*fcrit)(struct smc_connection *conn))\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct smc_connection *conn = &smc->conn;\n\tstruct smc_cdc_conn_state_flags *cflags =\n\t\t\t\t\t&conn->local_tx_ctrl.conn_state_flags;\n\tstruct sock *sk = &smc->sk;\n\tint rc;\n\n\tif (fcrit(conn))\n\t\treturn 1;\n\tsk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\trc = sk_wait_event(sk, timeo,\n\t\t\t   READ_ONCE(sk->sk_err) ||\n\t\t\t   cflags->peer_conn_abort ||\n\t\t\t   READ_ONCE(sk->sk_shutdown) & RCV_SHUTDOWN ||\n\t\t\t   conn->killed ||\n\t\t\t   fcrit(conn),\n\t\t\t   &wait);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\tsk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\treturn rc;\n}\n\nstatic int smc_rx_recv_urg(struct smc_sock *smc, struct msghdr *msg, int len,\n\t\t\t   int flags)\n{\n\tstruct smc_connection *conn = &smc->conn;\n\tunion smc_host_cursor cons;\n\tstruct sock *sk = &smc->sk;\n\tint rc = 0;\n\n\tif (sock_flag(sk, SOCK_URGINLINE) ||\n\t    !(conn->urg_state == SMC_URG_VALID) ||\n\t    conn->urg_state == SMC_URG_READ)\n\t\treturn -EINVAL;\n\n\tSMC_STAT_INC(smc, urg_data_cnt);\n\tif (conn->urg_state == SMC_URG_VALID) {\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tsmc->conn.urg_state = SMC_URG_READ;\n\t\tmsg->msg_flags |= MSG_OOB;\n\t\tif (len > 0) {\n\t\t\tif (!(flags & MSG_TRUNC))\n\t\t\t\trc = memcpy_to_msg(msg, &conn->urg_rx_byte, 1);\n\t\t\tlen = 1;\n\t\t\tsmc_curs_copy(&cons, &conn->local_tx_ctrl.cons, conn);\n\t\t\tif (smc_curs_diff(conn->rmb_desc->len, &cons,\n\t\t\t\t\t  &conn->urg_curs) > 1)\n\t\t\t\tconn->urg_rx_skip_pend = true;\n\t\t\t \n\t\t\tif (!(flags & MSG_PEEK))\n\t\t\t\tsmc_rx_update_consumer(smc, cons, 0);\n\t\t} else {\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\t}\n\n\t\treturn rc ? -EFAULT : len;\n\t}\n\n\tif (sk->sk_state == SMC_CLOSED || sk->sk_shutdown & RCV_SHUTDOWN)\n\t\treturn 0;\n\n\treturn -EAGAIN;\n}\n\nstatic bool smc_rx_recvmsg_data_available(struct smc_sock *smc)\n{\n\tstruct smc_connection *conn = &smc->conn;\n\n\tif (smc_rx_data_available(conn))\n\t\treturn true;\n\telse if (conn->urg_state == SMC_URG_VALID)\n\t\t \n\t\tsmc_rx_update_cons(smc, 0);\n\treturn false;\n}\n\n \nint smc_rx_recvmsg(struct smc_sock *smc, struct msghdr *msg,\n\t\t   struct pipe_inode_info *pipe, size_t len, int flags)\n{\n\tsize_t copylen, read_done = 0, read_remaining = len;\n\tsize_t chunk_len, chunk_off, chunk_len_sum;\n\tstruct smc_connection *conn = &smc->conn;\n\tint (*func)(struct smc_connection *conn);\n\tunion smc_host_cursor cons;\n\tint readable, chunk;\n\tchar *rcvbuf_base;\n\tstruct sock *sk;\n\tint splbytes;\n\tlong timeo;\n\tint target;\t\t \n\tint rc;\n\n\tif (unlikely(flags & MSG_ERRQUEUE))\n\t\treturn -EINVAL;  \n\n\tsk = &smc->sk;\n\tif (sk->sk_state == SMC_LISTEN)\n\t\treturn -ENOTCONN;\n\tif (flags & MSG_OOB)\n\t\treturn smc_rx_recv_urg(smc, msg, len, flags);\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\n\treadable = atomic_read(&conn->bytes_to_rcv);\n\tif (readable >= conn->rmb_desc->len)\n\t\tSMC_STAT_RMB_RX_FULL(smc, !conn->lnk);\n\n\tif (len < readable)\n\t\tSMC_STAT_RMB_RX_SIZE_SMALL(smc, !conn->lnk);\n\t \n\trcvbuf_base = conn->rx_off + conn->rmb_desc->cpu_addr;\n\n\tdo {  \n\t\tif (read_done >= target || (pipe && read_done))\n\t\t\tbreak;\n\n\t\tif (conn->killed)\n\t\t\tbreak;\n\n\t\tif (smc_rx_recvmsg_data_available(smc))\n\t\t\tgoto copy;\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\t \n\t\t\tif (smc_rx_recvmsg_data_available(smc))\n\t\t\t\tgoto copy;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (read_done) {\n\t\t\tif (sk->sk_err ||\n\t\t\t    sk->sk_state == SMC_CLOSED ||\n\t\t\t    !timeo ||\n\t\t\t    signal_pending(current))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (sk->sk_err) {\n\t\t\t\tread_done = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_state == SMC_CLOSED) {\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE)) {\n\t\t\t\t\t \n\t\t\t\t\tread_done = -ENOTCONN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo)\n\t\t\t\treturn -EAGAIN;\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tread_done = sock_intr_errno(timeo);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!smc_rx_data_available(conn)) {\n\t\t\tsmc_rx_wait(smc, &timeo, smc_rx_data_available);\n\t\t\tcontinue;\n\t\t}\n\ncopy:\n\t\t \n\t\t \n\t\treadable = atomic_read(&conn->bytes_to_rcv);\n\t\tsplbytes = atomic_read(&conn->splice_pending);\n\t\tif (!readable || (msg && splbytes)) {\n\t\t\tif (splbytes)\n\t\t\t\tfunc = smc_rx_data_available_and_no_splice_pend;\n\t\t\telse\n\t\t\t\tfunc = smc_rx_data_available;\n\t\t\tsmc_rx_wait(smc, &timeo, func);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsmc_curs_copy(&cons, &conn->local_tx_ctrl.cons, conn);\n\t\t \n\t\tif (splbytes)\n\t\t\tsmc_curs_add(conn->rmb_desc->len, &cons, splbytes);\n\t\tif (conn->urg_state == SMC_URG_VALID &&\n\t\t    sock_flag(&smc->sk, SOCK_URGINLINE) &&\n\t\t    readable > 1)\n\t\t\treadable--;\t \n\t\t \n\t\tcopylen = min_t(size_t, read_remaining, readable);\n\t\t \n\t\t \n\t\tchunk_len = min_t(size_t, copylen, conn->rmb_desc->len -\n\t\t\t\t  cons.count);\n\t\tchunk_len_sum = chunk_len;\n\t\tchunk_off = cons.count;\n\t\tsmc_rmb_sync_sg_for_cpu(conn);\n\t\tfor (chunk = 0; chunk < 2; chunk++) {\n\t\t\tif (!(flags & MSG_TRUNC)) {\n\t\t\t\tif (msg) {\n\t\t\t\t\trc = memcpy_to_msg(msg, rcvbuf_base +\n\t\t\t\t\t\t\t   chunk_off,\n\t\t\t\t\t\t\t   chunk_len);\n\t\t\t\t} else {\n\t\t\t\t\trc = smc_rx_splice(pipe, rcvbuf_base +\n\t\t\t\t\t\t\tchunk_off, chunk_len,\n\t\t\t\t\t\t\tsmc);\n\t\t\t\t}\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tif (!read_done)\n\t\t\t\t\t\tread_done = -EFAULT;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tread_remaining -= chunk_len;\n\t\t\tread_done += chunk_len;\n\n\t\t\tif (chunk_len_sum == copylen)\n\t\t\t\tbreak;  \n\t\t\t \n\t\t\tchunk_len = copylen - chunk_len;  \n\t\t\tchunk_len_sum += chunk_len;\n\t\t\tchunk_off = 0;  \n\t\t}\n\n\t\t \n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\t \n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_sub(copylen, &conn->bytes_to_rcv);\n\t\t\t \n\t\t\tsmp_mb__after_atomic();\n\t\t\tif (msg && smc_rx_update_consumer(smc, cons, copylen))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\ttrace_smc_rx_recvmsg(smc, copylen);\n\t} while (read_remaining);\nout:\n\treturn read_done;\n}\n\n \nvoid smc_rx_init(struct smc_sock *smc)\n{\n\tsmc->sk.sk_data_ready = smc_rx_wake_up;\n\tatomic_set(&smc->conn.splice_pending, 0);\n\tsmc->conn.urg_state = SMC_URG_READ;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}