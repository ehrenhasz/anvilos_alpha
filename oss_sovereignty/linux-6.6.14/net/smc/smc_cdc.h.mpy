{
  "module_name": "smc_cdc.h",
  "hash_id": "5e264e5ae8d8e323323d25ee0da965c2f0ca684c3bfc9af57f701d605e6b6cc0",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_cdc.h",
  "human_readable_source": " \n \n\n#ifndef SMC_CDC_H\n#define SMC_CDC_H\n\n#include <linux/kernel.h>  \n#include <linux/atomic.h>\n#include <linux/in.h>\n#include <linux/compiler.h>\n\n#include \"smc.h\"\n#include \"smc_core.h\"\n#include \"smc_wr.h\"\n\n#define\tSMC_CDC_MSG_TYPE\t\t0xFE\n\n \nunion smc_cdc_cursor {\t\t \n\tstruct {\n\t\t__be16\treserved;\n\t\t__be16\twrap;\n\t\t__be32\tcount;\n\t};\n#ifdef KERNEL_HAS_ATOMIC64\n\tatomic64_t\tacurs;\t\t \n#else\n\tu64\t\tacurs;\t\t \n#endif\n} __aligned(8);\n\n \nstruct smc_cdc_msg {\n\tstruct smc_wr_rx_hdr\t\tcommon;  \n\tu8\t\t\t\tlen;\t \n\t__be16\t\t\t\tseqno;\n\t__be32\t\t\t\ttoken;\n\tunion smc_cdc_cursor\t\tprod;\n\tunion smc_cdc_cursor\t\tcons;\t \n\tstruct smc_cdc_producer_flags\tprod_flags;\n\tstruct smc_cdc_conn_state_flags\tconn_state_flags;\n\tu8\t\t\t\treserved[18];\n};\n\n \nunion smcd_cdc_cursor {\n\tstruct {\n\t\tu16\twrap;\n\t\tu32\tcount;\n\t\tstruct smc_cdc_producer_flags\tprod_flags;\n\t\tstruct smc_cdc_conn_state_flags\tconn_state_flags;\n\t} __packed;\n#ifdef KERNEL_HAS_ATOMIC64\n\tatomic64_t\t\tacurs;\t\t \n#else\n\tu64\t\t\tacurs;\t\t \n#endif\n} __aligned(8);\n\n \nstruct smcd_cdc_msg {\n\tstruct smc_wr_rx_hdr common;\t \n\tu8 res1[7];\n\tunion smcd_cdc_cursor\tprod;\n\tunion smcd_cdc_cursor\tcons;\n\tu8 res3[8];\n} __aligned(8);\n\nstatic inline bool smc_cdc_rxed_any_close(struct smc_connection *conn)\n{\n\treturn conn->local_rx_ctrl.conn_state_flags.peer_conn_abort ||\n\t       conn->local_rx_ctrl.conn_state_flags.peer_conn_closed;\n}\n\nstatic inline bool smc_cdc_rxed_any_close_or_senddone(\n\tstruct smc_connection *conn)\n{\n\treturn smc_cdc_rxed_any_close(conn) ||\n\t       conn->local_rx_ctrl.conn_state_flags.peer_done_writing;\n}\n\nstatic inline void smc_curs_add(int size, union smc_host_cursor *curs,\n\t\t\t\tint value)\n{\n\tcurs->count += value;\n\tif (curs->count >= size) {\n\t\tcurs->wrap++;\n\t\tcurs->count -= size;\n\t}\n}\n\n \nstatic inline void smc_curs_copy(union smc_host_cursor *tgt,\n\t\t\t\t union smc_host_cursor *src,\n\t\t\t\t struct smc_connection *conn)\n{\n#ifndef KERNEL_HAS_ATOMIC64\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&conn->acurs_lock, flags);\n\ttgt->acurs = src->acurs;\n\tspin_unlock_irqrestore(&conn->acurs_lock, flags);\n#else\n\tatomic64_set(&tgt->acurs, atomic64_read(&src->acurs));\n#endif\n}\n\nstatic inline void smc_curs_copy_net(union smc_cdc_cursor *tgt,\n\t\t\t\t     union smc_cdc_cursor *src,\n\t\t\t\t     struct smc_connection *conn)\n{\n#ifndef KERNEL_HAS_ATOMIC64\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&conn->acurs_lock, flags);\n\ttgt->acurs = src->acurs;\n\tspin_unlock_irqrestore(&conn->acurs_lock, flags);\n#else\n\tatomic64_set(&tgt->acurs, atomic64_read(&src->acurs));\n#endif\n}\n\nstatic inline void smcd_curs_copy(union smcd_cdc_cursor *tgt,\n\t\t\t\t  union smcd_cdc_cursor *src,\n\t\t\t\t  struct smc_connection *conn)\n{\n#ifndef KERNEL_HAS_ATOMIC64\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&conn->acurs_lock, flags);\n\ttgt->acurs = src->acurs;\n\tspin_unlock_irqrestore(&conn->acurs_lock, flags);\n#else\n\tatomic64_set(&tgt->acurs, atomic64_read(&src->acurs));\n#endif\n}\n\n \nstatic inline int smc_curs_diff(unsigned int size,\n\t\t\t\tunion smc_host_cursor *old,\n\t\t\t\tunion smc_host_cursor *new)\n{\n\tif (old->wrap != new->wrap)\n\t\treturn max_t(int, 0,\n\t\t\t     ((size - old->count) + new->count));\n\n\treturn max_t(int, 0, (new->count - old->count));\n}\n\n \nstatic inline int smc_curs_comp(unsigned int size,\n\t\t\t\tunion smc_host_cursor *old,\n\t\t\t\tunion smc_host_cursor *new)\n{\n\tif (old->wrap > new->wrap ||\n\t    (old->wrap == new->wrap && old->count > new->count))\n\t\treturn -smc_curs_diff(size, new, old);\n\treturn smc_curs_diff(size, old, new);\n}\n\n \nstatic inline int smc_curs_diff_large(unsigned int size,\n\t\t\t\t      union smc_host_cursor *old,\n\t\t\t\t      union smc_host_cursor *new)\n{\n\tif (old->wrap < new->wrap)\n\t\treturn min_t(int,\n\t\t\t     (size - old->count) + new->count +\n\t\t\t     (new->wrap - old->wrap - 1) * size,\n\t\t\t     size);\n\n\tif (old->wrap > new->wrap)  \n\t\treturn min_t(int,\n\t\t\t     (size - old->count) + new->count +\n\t\t\t     (new->wrap + 0xffff - old->wrap) * size,\n\t\t\t     size);\n\n\treturn max_t(int, 0, (new->count - old->count));\n}\n\nstatic inline void smc_host_cursor_to_cdc(union smc_cdc_cursor *peer,\n\t\t\t\t\t  union smc_host_cursor *local,\n\t\t\t\t\t  union smc_host_cursor *save,\n\t\t\t\t\t  struct smc_connection *conn)\n{\n\tsmc_curs_copy(save, local, conn);\n\tpeer->count = htonl(save->count);\n\tpeer->wrap = htons(save->wrap);\n\t \n}\n\nstatic inline void smc_host_msg_to_cdc(struct smc_cdc_msg *peer,\n\t\t\t\t       struct smc_connection *conn,\n\t\t\t\t       union smc_host_cursor *save)\n{\n\tstruct smc_host_cdc_msg *local = &conn->local_tx_ctrl;\n\n\tpeer->common.type = local->common.type;\n\tpeer->len = local->len;\n\tpeer->seqno = htons(local->seqno);\n\tpeer->token = htonl(local->token);\n\tsmc_host_cursor_to_cdc(&peer->prod, &local->prod, save, conn);\n\tsmc_host_cursor_to_cdc(&peer->cons, &local->cons, save, conn);\n\tpeer->prod_flags = local->prod_flags;\n\tpeer->conn_state_flags = local->conn_state_flags;\n}\n\nstatic inline void smc_cdc_cursor_to_host(union smc_host_cursor *local,\n\t\t\t\t\t  union smc_cdc_cursor *peer,\n\t\t\t\t\t  struct smc_connection *conn)\n{\n\tunion smc_host_cursor temp, old;\n\tunion smc_cdc_cursor net;\n\n\tsmc_curs_copy(&old, local, conn);\n\tsmc_curs_copy_net(&net, peer, conn);\n\ttemp.count = ntohl(net.count);\n\ttemp.wrap = ntohs(net.wrap);\n\tif ((old.wrap > temp.wrap) && temp.wrap)\n\t\treturn;\n\tif ((old.wrap == temp.wrap) &&\n\t    (old.count > temp.count))\n\t\treturn;\n\tsmc_curs_copy(local, &temp, conn);\n}\n\nstatic inline void smcr_cdc_msg_to_host(struct smc_host_cdc_msg *local,\n\t\t\t\t\tstruct smc_cdc_msg *peer,\n\t\t\t\t\tstruct smc_connection *conn)\n{\n\tlocal->common.type = peer->common.type;\n\tlocal->len = peer->len;\n\tlocal->seqno = ntohs(peer->seqno);\n\tlocal->token = ntohl(peer->token);\n\tsmc_cdc_cursor_to_host(&local->prod, &peer->prod, conn);\n\tsmc_cdc_cursor_to_host(&local->cons, &peer->cons, conn);\n\tlocal->prod_flags = peer->prod_flags;\n\tlocal->conn_state_flags = peer->conn_state_flags;\n}\n\nstatic inline void smcd_cdc_msg_to_host(struct smc_host_cdc_msg *local,\n\t\t\t\t\tstruct smcd_cdc_msg *peer,\n\t\t\t\t\tstruct smc_connection *conn)\n{\n\tunion smc_host_cursor temp;\n\n\ttemp.wrap = peer->prod.wrap;\n\ttemp.count = peer->prod.count;\n\tsmc_curs_copy(&local->prod, &temp, conn);\n\n\ttemp.wrap = peer->cons.wrap;\n\ttemp.count = peer->cons.count;\n\tsmc_curs_copy(&local->cons, &temp, conn);\n\tlocal->prod_flags = peer->cons.prod_flags;\n\tlocal->conn_state_flags = peer->cons.conn_state_flags;\n}\n\nstatic inline void smc_cdc_msg_to_host(struct smc_host_cdc_msg *local,\n\t\t\t\t       struct smc_cdc_msg *peer,\n\t\t\t\t       struct smc_connection *conn)\n{\n\tif (conn->lgr->is_smcd)\n\t\tsmcd_cdc_msg_to_host(local, (struct smcd_cdc_msg *)peer, conn);\n\telse\n\t\tsmcr_cdc_msg_to_host(local, peer, conn);\n}\n\nstruct smc_cdc_tx_pend {\n\tstruct smc_connection\t*conn;\t\t \n\tunion smc_host_cursor\tcursor;\t\t \n\tunion smc_host_cursor\tp_cursor;\t \n\tu16\t\t\tctrl_seq;\t \n};\n\nint smc_cdc_get_free_slot(struct smc_connection *conn,\n\t\t\t  struct smc_link *link,\n\t\t\t  struct smc_wr_buf **wr_buf,\n\t\t\t  struct smc_rdma_wr **wr_rdma_buf,\n\t\t\t  struct smc_cdc_tx_pend **pend);\nvoid smc_cdc_wait_pend_tx_wr(struct smc_connection *conn);\nint smc_cdc_msg_send(struct smc_connection *conn, struct smc_wr_buf *wr_buf,\n\t\t     struct smc_cdc_tx_pend *pend);\nint smc_cdc_get_slot_and_msg_send(struct smc_connection *conn);\nint smcd_cdc_msg_send(struct smc_connection *conn);\nint smcr_cdc_msg_send_validation(struct smc_connection *conn,\n\t\t\t\t struct smc_cdc_tx_pend *pend,\n\t\t\t\t struct smc_wr_buf *wr_buf);\nint smc_cdc_init(void) __init;\nvoid smcd_cdc_rx_init(struct smc_connection *conn);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}