{
  "module_name": "smc.h",
  "hash_id": "a2ef5b5350759f9a27a17bb67ba5a1396fcce77ba77166a36c2858cafcb3bf43",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc.h",
  "human_readable_source": " \n \n#ifndef __SMC_H\n#define __SMC_H\n\n#include <linux/socket.h>\n#include <linux/types.h>\n#include <linux/compiler.h>  \n#include <net/genetlink.h>\n#include <net/sock.h>\n\n#include \"smc_ib.h\"\n\n#define SMC_V1\t\t1\t\t \n#define SMC_V2\t\t2\t\t \n\n#define SMC_RELEASE_0 0\n#define SMC_RELEASE_1 1\n#define SMC_RELEASE\tSMC_RELEASE_1  \n\n#define SMCPROTO_SMC\t\t0\t \n#define SMCPROTO_SMC6\t\t1\t \n\n#define SMC_MAX_ISM_DEVS\t8\t \n#define SMC_AUTOCORKING_DEFAULT_SIZE\t0x10000\t \n\nextern struct proto smc_proto;\nextern struct proto smc_proto6;\n\n#ifdef ATOMIC64_INIT\n#define KERNEL_HAS_ATOMIC64\n#endif\n\nenum smc_state {\t\t \n\tSMC_ACTIVE\t= 1,\n\tSMC_INIT\t= 2,\n\tSMC_CLOSED\t= 7,\n\tSMC_LISTEN\t= 10,\n\t \n\tSMC_PEERCLOSEWAIT1\t= 20,\n\tSMC_PEERCLOSEWAIT2\t= 21,\n\tSMC_APPFINCLOSEWAIT\t= 24,\n\tSMC_APPCLOSEWAIT1\t= 22,\n\tSMC_APPCLOSEWAIT2\t= 23,\n\tSMC_PEERFINCLOSEWAIT\t= 25,\n\t \n\tSMC_PEERABORTWAIT\t= 26,\n\tSMC_PROCESSABORT\t= 27,\n};\n\nstruct smc_link_group;\n\nstruct smc_wr_rx_hdr {\t \n\tunion {\n\t\tu8 type;\n#if defined(__BIG_ENDIAN_BITFIELD)\n\t\tstruct {\n\t\t\tu8 llc_version:4,\n\t\t\t   llc_type:4;\n\t\t};\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\t\tstruct {\n\t\t\tu8 llc_type:4,\n\t\t\t   llc_version:4;\n\t\t};\n#endif\n\t};\n} __aligned(1);\n\nstruct smc_cdc_conn_state_flags {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\tu8\tpeer_done_writing : 1;\t \n\tu8\tpeer_conn_closed : 1;\t \n\tu8\tpeer_conn_abort : 1;\t \n\tu8\treserved : 5;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\tu8\treserved : 5;\n\tu8\tpeer_conn_abort : 1;\n\tu8\tpeer_conn_closed : 1;\n\tu8\tpeer_done_writing : 1;\n#endif\n};\n\nstruct smc_cdc_producer_flags {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\tu8\twrite_blocked : 1;\t \n\tu8\turg_data_pending : 1;\t \n\tu8\turg_data_present : 1;\t \n\tu8\tcons_curs_upd_req : 1;\t \n\tu8\tfailover_validation : 1; \n\tu8\treserved : 3;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\tu8\treserved : 3;\n\tu8\tfailover_validation : 1;\n\tu8\tcons_curs_upd_req : 1;\n\tu8\turg_data_present : 1;\n\tu8\turg_data_pending : 1;\n\tu8\twrite_blocked : 1;\n#endif\n};\n\n \nunion smc_host_cursor {\t \n\tstruct {\n\t\tu16\treserved;\n\t\tu16\twrap;\t\t \n\t\tu32\tcount;\t\t \n\t};\n#ifdef KERNEL_HAS_ATOMIC64\n\tatomic64_t\t\tacurs;\t \n#else\n\tu64\t\t\tacurs;\t \n#endif\n} __aligned(8);\n\n \nstruct smc_host_cdc_msg {\t\t \n\tstruct smc_wr_rx_hdr\t\tcommon;  \n\tu8\t\t\t\tlen;\t \n\tu16\t\t\t\tseqno;\t \n\tu32\t\t\t\ttoken;\t \n\tunion smc_host_cursor\t\tprod;\t\t \n\tunion smc_host_cursor\t\tcons;\t\t \n\tstruct smc_cdc_producer_flags\tprod_flags;\t \n\tstruct smc_cdc_conn_state_flags\tconn_state_flags;  \n\tu8\t\t\t\treserved[18];\n} __aligned(8);\n\nenum smc_urg_state {\n\tSMC_URG_VALID\t= 1,\t\t\t \n\tSMC_URG_NOTYET\t= 2,\t\t\t \n\tSMC_URG_READ\t= 3,\t\t\t \n};\n\nstruct smc_mark_woken {\n\tbool woken;\n\tvoid *key;\n\twait_queue_entry_t wait_entry;\n};\n\nstruct smc_connection {\n\tstruct rb_node\t\talert_node;\n\tstruct smc_link_group\t*lgr;\t\t \n\tstruct smc_link\t\t*lnk;\t\t \n\tu32\t\t\talert_token_local;  \n\tu8\t\t\tpeer_rmbe_idx;\t \n\tint\t\t\tpeer_rmbe_size;\t \n\tatomic_t\t\tpeer_rmbe_space; \n\tint\t\t\trtoken_idx;\t \n\n\tstruct smc_buf_desc\t*sndbuf_desc;\t \n\tstruct smc_buf_desc\t*rmb_desc;\t \n\tint                     rmbe_size_comp;  \n\tint\t\t\trmbe_update_limit;\n\t\t\t\t\t\t \n\n\tstruct smc_host_cdc_msg\tlocal_tx_ctrl;\t \n\tunion smc_host_cursor\tlocal_tx_ctrl_fin;\n\t\t\t\t\t\t \n\tunion smc_host_cursor\ttx_curs_prep;\t \n\tunion smc_host_cursor\ttx_curs_sent;\t \n\tunion smc_host_cursor\ttx_curs_fin;\t \n\tatomic_t\t\tsndbuf_space;\t \n\tu16\t\t\ttx_cdc_seq;\t \n\tu16\t\t\ttx_cdc_seq_fin;\t \n\tspinlock_t\t\tsend_lock;\t \n\tatomic_t\t\tcdc_pend_tx_wr;  \n\twait_queue_head_t\tcdc_pend_tx_wq;  \n\tatomic_t\t\ttx_pushing;      \n\tstruct delayed_work\ttx_work;\t \n\tu32\t\t\ttx_off;\t\t \n\n\tstruct smc_host_cdc_msg\tlocal_rx_ctrl;\t \n\tunion smc_host_cursor\trx_curs_confirmed;  \n\tunion smc_host_cursor\turg_curs;\t \n\tenum smc_urg_state\turg_state;\n\tbool\t\t\turg_tx_pend;\t \n\tbool\t\t\turg_rx_skip_pend;\n\t\t\t\t\t\t \n\tchar\t\t\turg_rx_byte;\t \n\tbool\t\t\ttx_in_release_sock;\n\t\t\t\t\t\t \n\tatomic_t\t\tbytes_to_rcv;\t \n\tatomic_t\t\tsplice_pending;\t \n#ifndef KERNEL_HAS_ATOMIC64\n\tspinlock_t\t\tacurs_lock;\t \n#endif\n\tstruct work_struct\tclose_work;\t \n\tstruct work_struct\tabort_work;\t \n\tstruct tasklet_struct\trx_tsklet;\t \n\tu8\t\t\trx_off;\t\t \n\tu64\t\t\tpeer_token;\t \n\tu8\t\t\tkilled : 1;\t \n\tu8\t\t\tfreed : 1;\t \n\tu8\t\t\tout_of_sync : 1;  \n};\n\nstruct smc_sock {\t\t\t\t \n\tstruct sock\t\tsk;\n\tstruct socket\t\t*clcsock;\t \n\tvoid\t\t\t(*clcsk_state_change)(struct sock *sk);\n\t\t\t\t\t\t \n\tvoid\t\t\t(*clcsk_data_ready)(struct sock *sk);\n\t\t\t\t\t\t \n\tvoid\t\t\t(*clcsk_write_space)(struct sock *sk);\n\t\t\t\t\t\t \n\tvoid\t\t\t(*clcsk_error_report)(struct sock *sk);\n\t\t\t\t\t\t \n\tstruct smc_connection\tconn;\t\t \n\tstruct smc_sock\t\t*listen_smc;\t \n\tstruct work_struct\tconnect_work;\t \n\tstruct work_struct\ttcp_listen_work; \n\tstruct work_struct\tsmc_listen_work; \n\tstruct list_head\taccept_q;\t \n\tspinlock_t\t\taccept_q_lock;\t \n\tbool\t\t\tlimit_smc_hs;\t \n\tbool\t\t\tuse_fallback;\t \n\tint\t\t\tfallback_rsn;\t \n\tu32\t\t\tpeer_diagnosis;  \n\tatomic_t                queued_smc_hs;   \n\tstruct inet_connection_sock_af_ops\t\taf_ops;\n\tconst struct inet_connection_sock_af_ops\t*ori_af_ops;\n\t\t\t\t\t\t \n\tint\t\t\tsockopt_defer_accept;\n\t\t\t\t\t\t \n\tu8\t\t\twait_close_tx_prepared : 1;\n\t\t\t\t\t\t \n\tu8\t\t\tconnect_nonblock : 1;\n\t\t\t\t\t\t \n\tstruct mutex            clcsock_release_lock;\n\t\t\t\t\t\t \n};\n\n#define smc_sk(ptr) container_of_const(ptr, struct smc_sock, sk)\n\nstatic inline void smc_init_saved_callbacks(struct smc_sock *smc)\n{\n\tsmc->clcsk_state_change\t= NULL;\n\tsmc->clcsk_data_ready\t= NULL;\n\tsmc->clcsk_write_space\t= NULL;\n\tsmc->clcsk_error_report\t= NULL;\n}\n\nstatic inline struct smc_sock *smc_clcsock_user_data(const struct sock *clcsk)\n{\n\treturn (struct smc_sock *)\n\t       ((uintptr_t)clcsk->sk_user_data & ~SK_USER_DATA_NOCOPY);\n}\n\n \nstatic inline void smc_clcsock_replace_cb(void (**target_cb)(struct sock *),\n\t\t\t\t\t  void (*new_cb)(struct sock *),\n\t\t\t\t\t  void (**saved_cb)(struct sock *))\n{\n\t \n\tif (!*saved_cb)\n\t\t*saved_cb = *target_cb;\n\t*target_cb = new_cb;\n}\n\n \nstatic inline void smc_clcsock_restore_cb(void (**target_cb)(struct sock *),\n\t\t\t\t\t  void (**saved_cb)(struct sock *))\n{\n\tif (!*saved_cb)\n\t\treturn;\n\t*target_cb = *saved_cb;\n\t*saved_cb = NULL;\n}\n\nextern struct workqueue_struct\t*smc_hs_wq;\t \nextern struct workqueue_struct\t*smc_close_wq;\t \n\n#define SMC_SYSTEMID_LEN\t\t8\n\nextern u8\tlocal_systemid[SMC_SYSTEMID_LEN];  \n\n#define ntohll(x) be64_to_cpu(x)\n#define htonll(x) cpu_to_be64(x)\n\n \nstatic inline void hton24(u8 *net, u32 host)\n{\n\t__be32 t;\n\n\tt = cpu_to_be32(host);\n\tmemcpy(net, ((u8 *)&t) + 1, 3);\n}\n\n \nstatic inline u32 ntoh24(u8 *net)\n{\n\t__be32 t = 0;\n\n\tmemcpy(((u8 *)&t) + 1, net, 3);\n\treturn be32_to_cpu(t);\n}\n\n#ifdef CONFIG_XFRM\nstatic inline bool using_ipsec(struct smc_sock *smc)\n{\n\treturn (smc->clcsock->sk->sk_policy[0] ||\n\t\tsmc->clcsock->sk->sk_policy[1]) ? true : false;\n}\n#else\nstatic inline bool using_ipsec(struct smc_sock *smc)\n{\n\treturn false;\n}\n#endif\n\nstruct smc_gidlist;\n\nstruct sock *smc_accept_dequeue(struct sock *parent, struct socket *new_sock);\nvoid smc_close_non_accepted(struct sock *sk);\nvoid smc_fill_gid_list(struct smc_link_group *lgr,\n\t\t       struct smc_gidlist *gidlist,\n\t\t       struct smc_ib_device *known_dev, u8 *known_gid);\n\n \nint smc_nl_dump_hs_limitation(struct sk_buff *skb, struct netlink_callback *cb);\nint smc_nl_enable_hs_limitation(struct sk_buff *skb, struct genl_info *info);\nint smc_nl_disable_hs_limitation(struct sk_buff *skb, struct genl_info *info);\n\nstatic inline void smc_sock_set_flag(struct sock *sk, enum sock_flags flag)\n{\n\tset_bit(flag, &sk->sk_flags);\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}