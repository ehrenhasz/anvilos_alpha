{
  "module_name": "smc_llc.c",
  "hash_id": "7a96cfe91adadf6aef636f91d248a6eef9e6f052ff1746e05d12cc6d5c74743f",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_llc.c",
  "human_readable_source": "\n \n\n#include <net/tcp.h>\n#include <rdma/ib_verbs.h>\n\n#include \"smc.h\"\n#include \"smc_core.h\"\n#include \"smc_clc.h\"\n#include \"smc_llc.h\"\n#include \"smc_pnet.h\"\n\n#define SMC_LLC_DATA_LEN\t\t40\n\nstruct smc_llc_hdr {\n\tstruct smc_wr_rx_hdr common;\n\tunion {\n\t\tstruct {\n\t\t\tu8 length;\t \n\t#if defined(__BIG_ENDIAN_BITFIELD)\n\t\t\tu8 reserved:4,\n\t\t\t   add_link_rej_rsn:4;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\t\t\tu8 add_link_rej_rsn:4,\n\t\t\t   reserved:4;\n#endif\n\t\t};\n\t\tu16 length_v2;\t \n\t};\n\tu8 flags;\n} __packed;\t\t \n\n#define SMC_LLC_FLAG_NO_RMBE_EYEC\t0x03\n\nstruct smc_llc_msg_confirm_link {\t \n\tstruct smc_llc_hdr hd;\n\tu8 sender_mac[ETH_ALEN];\n\tu8 sender_gid[SMC_GID_SIZE];\n\tu8 sender_qp_num[3];\n\tu8 link_num;\n\tu8 link_uid[SMC_LGR_ID_SIZE];\n\tu8 max_links;\n\tu8 max_conns;\n\tu8 reserved[8];\n};\n\n#define SMC_LLC_FLAG_ADD_LNK_REJ\t0x40\n#define SMC_LLC_REJ_RSN_NO_ALT_PATH\t1\n\nstruct smc_llc_msg_add_link {\t\t \n\tstruct smc_llc_hdr hd;\n\tu8 sender_mac[ETH_ALEN];\n\tu8 reserved2[2];\n\tu8 sender_gid[SMC_GID_SIZE];\n\tu8 sender_qp_num[3];\n\tu8 link_num;\n#if defined(__BIG_ENDIAN_BITFIELD)\n\tu8 reserved3 : 4,\n\t   qp_mtu   : 4;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\tu8 qp_mtu   : 4,\n\t   reserved3 : 4;\n#endif\n\tu8 initial_psn[3];\n\tu8 reserved[8];\n};\n\nstruct smc_llc_msg_add_link_cont_rt {\n\t__be32 rmb_key;\n\t__be32 rmb_key_new;\n\t__be64 rmb_vaddr_new;\n};\n\nstruct smc_llc_msg_add_link_v2_ext {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\tu8 v2_direct : 1,\n\t   reserved  : 7;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\tu8 reserved  : 7,\n\t   v2_direct : 1;\n#endif\n\tu8 reserved2;\n\tu8 client_target_gid[SMC_GID_SIZE];\n\tu8 reserved3[8];\n\tu16 num_rkeys;\n\tstruct smc_llc_msg_add_link_cont_rt rt[];\n} __packed;\t\t \n\nstruct smc_llc_msg_req_add_link_v2 {\n\tstruct smc_llc_hdr hd;\n\tu8 reserved[20];\n\tu8 gid_cnt;\n\tu8 reserved2[3];\n\tu8 gid[][SMC_GID_SIZE];\n};\n\n#define SMC_LLC_RKEYS_PER_CONT_MSG\t2\n\nstruct smc_llc_msg_add_link_cont {\t \n\tstruct smc_llc_hdr hd;\n\tu8 link_num;\n\tu8 num_rkeys;\n\tu8 reserved2[2];\n\tstruct smc_llc_msg_add_link_cont_rt rt[SMC_LLC_RKEYS_PER_CONT_MSG];\n\tu8 reserved[4];\n} __packed;\t\t\t \n\n#define SMC_LLC_FLAG_DEL_LINK_ALL\t0x40\n#define SMC_LLC_FLAG_DEL_LINK_ORDERLY\t0x20\n\nstruct smc_llc_msg_del_link {\t\t \n\tstruct smc_llc_hdr hd;\n\tu8 link_num;\n\t__be32 reason;\n\tu8 reserved[35];\n} __packed;\t\t\t \n\nstruct smc_llc_msg_test_link {\t\t \n\tstruct smc_llc_hdr hd;\n\tu8 user_data[16];\n\tu8 reserved[24];\n};\n\nstruct smc_rmb_rtoken {\n\tunion {\n\t\tu8 num_rkeys;\t \n\t\t\t\t \n\t\t\t\t \n\t\tu8 link_id;\t \n\t};\n\t__be32 rmb_key;\n\t__be64 rmb_vaddr;\n} __packed;\t\t\t \n\n#define SMC_LLC_RKEYS_PER_MSG\t\t3\n#define SMC_LLC_RKEYS_PER_MSG_V2\t255\n\nstruct smc_llc_msg_confirm_rkey {\t \n\tstruct smc_llc_hdr hd;\n\tstruct smc_rmb_rtoken rtoken[SMC_LLC_RKEYS_PER_MSG];\n\tu8 reserved;\n};\n\n#define SMC_LLC_DEL_RKEY_MAX\t8\n#define SMC_LLC_FLAG_RKEY_RETRY\t0x10\n#define SMC_LLC_FLAG_RKEY_NEG\t0x20\n\nstruct smc_llc_msg_delete_rkey {\t \n\tstruct smc_llc_hdr hd;\n\tu8 num_rkeys;\n\tu8 err_mask;\n\tu8 reserved[2];\n\t__be32 rkey[8];\n\tu8 reserved2[4];\n};\n\nstruct smc_llc_msg_delete_rkey_v2 {\t \n\tstruct smc_llc_hdr hd;\n\tu8 num_rkeys;\n\tu8 num_inval_rkeys;\n\tu8 reserved[2];\n\t__be32 rkey[];\n};\n\nunion smc_llc_msg {\n\tstruct smc_llc_msg_confirm_link confirm_link;\n\tstruct smc_llc_msg_add_link add_link;\n\tstruct smc_llc_msg_req_add_link_v2 req_add_link;\n\tstruct smc_llc_msg_add_link_cont add_link_cont;\n\tstruct smc_llc_msg_del_link delete_link;\n\n\tstruct smc_llc_msg_confirm_rkey confirm_rkey;\n\tstruct smc_llc_msg_delete_rkey delete_rkey;\n\n\tstruct smc_llc_msg_test_link test_link;\n\tstruct {\n\t\tstruct smc_llc_hdr hdr;\n\t\tu8 data[SMC_LLC_DATA_LEN];\n\t} raw;\n};\n\n#define SMC_LLC_FLAG_RESP\t\t0x80\n\nstruct smc_llc_qentry {\n\tstruct list_head list;\n\tstruct smc_link *link;\n\tunion smc_llc_msg msg;\n};\n\nstatic void smc_llc_enqueue(struct smc_link *link, union smc_llc_msg *llc);\n\nstruct smc_llc_qentry *smc_llc_flow_qentry_clr(struct smc_llc_flow *flow)\n{\n\tstruct smc_llc_qentry *qentry = flow->qentry;\n\n\tflow->qentry = NULL;\n\treturn qentry;\n}\n\nvoid smc_llc_flow_qentry_del(struct smc_llc_flow *flow)\n{\n\tstruct smc_llc_qentry *qentry;\n\n\tif (flow->qentry) {\n\t\tqentry = flow->qentry;\n\t\tflow->qentry = NULL;\n\t\tkfree(qentry);\n\t}\n}\n\nstatic inline void smc_llc_flow_qentry_set(struct smc_llc_flow *flow,\n\t\t\t\t\t   struct smc_llc_qentry *qentry)\n{\n\tflow->qentry = qentry;\n}\n\nstatic void smc_llc_flow_parallel(struct smc_link_group *lgr, u8 flow_type,\n\t\t\t\t  struct smc_llc_qentry *qentry)\n{\n\tu8 msg_type = qentry->msg.raw.hdr.common.llc_type;\n\n\tif ((msg_type == SMC_LLC_ADD_LINK || msg_type == SMC_LLC_DELETE_LINK) &&\n\t    flow_type != msg_type && !lgr->delayed_event) {\n\t\tlgr->delayed_event = qentry;\n\t\treturn;\n\t}\n\t \n\tif (flow_type != msg_type)\n\t\tpr_warn_once(\"smc: SMC-R lg %*phN net %llu dropped parallel \"\n\t\t\t     \"LLC msg: msg %d flow %d role %d\\n\",\n\t\t\t     SMC_LGR_ID_SIZE, &lgr->id,\n\t\t\t     lgr->net->net_cookie,\n\t\t\t     qentry->msg.raw.hdr.common.type,\n\t\t\t     flow_type, lgr->role);\n\tkfree(qentry);\n}\n\n \nstatic bool smc_llc_flow_start(struct smc_llc_flow *flow,\n\t\t\t       struct smc_llc_qentry *qentry)\n{\n\tstruct smc_link_group *lgr = qentry->link->lgr;\n\n\tspin_lock_bh(&lgr->llc_flow_lock);\n\tif (flow->type) {\n\t\t \n\t\tsmc_llc_flow_parallel(lgr, flow->type, qentry);\n\t\tspin_unlock_bh(&lgr->llc_flow_lock);\n\t\treturn false;\n\t}\n\tswitch (qentry->msg.raw.hdr.common.llc_type) {\n\tcase SMC_LLC_ADD_LINK:\n\t\tflow->type = SMC_LLC_FLOW_ADD_LINK;\n\t\tbreak;\n\tcase SMC_LLC_DELETE_LINK:\n\t\tflow->type = SMC_LLC_FLOW_DEL_LINK;\n\t\tbreak;\n\tcase SMC_LLC_CONFIRM_RKEY:\n\tcase SMC_LLC_DELETE_RKEY:\n\t\tflow->type = SMC_LLC_FLOW_RKEY;\n\t\tbreak;\n\tdefault:\n\t\tflow->type = SMC_LLC_FLOW_NONE;\n\t}\n\tsmc_llc_flow_qentry_set(flow, qentry);\n\tspin_unlock_bh(&lgr->llc_flow_lock);\n\treturn true;\n}\n\n \nint smc_llc_flow_initiate(struct smc_link_group *lgr,\n\t\t\t  enum smc_llc_flowtype type)\n{\n\tenum smc_llc_flowtype allowed_remote = SMC_LLC_FLOW_NONE;\n\tint rc;\n\n\t \n\tif (type == SMC_LLC_FLOW_RKEY)\n\t\tallowed_remote = SMC_LLC_FLOW_RKEY;\nagain:\n\tif (list_empty(&lgr->list))\n\t\treturn -ENODEV;\n\tspin_lock_bh(&lgr->llc_flow_lock);\n\tif (lgr->llc_flow_lcl.type == SMC_LLC_FLOW_NONE &&\n\t    (lgr->llc_flow_rmt.type == SMC_LLC_FLOW_NONE ||\n\t     lgr->llc_flow_rmt.type == allowed_remote)) {\n\t\tlgr->llc_flow_lcl.type = type;\n\t\tspin_unlock_bh(&lgr->llc_flow_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock_bh(&lgr->llc_flow_lock);\n\trc = wait_event_timeout(lgr->llc_flow_waiter, (list_empty(&lgr->list) ||\n\t\t\t\t(lgr->llc_flow_lcl.type == SMC_LLC_FLOW_NONE &&\n\t\t\t\t (lgr->llc_flow_rmt.type == SMC_LLC_FLOW_NONE ||\n\t\t\t\t  lgr->llc_flow_rmt.type == allowed_remote))),\n\t\t\t\tSMC_LLC_WAIT_TIME * 10);\n\tif (!rc)\n\t\treturn -ETIMEDOUT;\n\tgoto again;\n}\n\n \nvoid smc_llc_flow_stop(struct smc_link_group *lgr, struct smc_llc_flow *flow)\n{\n\tspin_lock_bh(&lgr->llc_flow_lock);\n\tmemset(flow, 0, sizeof(*flow));\n\tflow->type = SMC_LLC_FLOW_NONE;\n\tspin_unlock_bh(&lgr->llc_flow_lock);\n\tif (!list_empty(&lgr->list) && lgr->delayed_event &&\n\t    flow == &lgr->llc_flow_lcl)\n\t\tschedule_work(&lgr->llc_event_work);\n\telse\n\t\twake_up(&lgr->llc_flow_waiter);\n}\n\n \nstruct smc_llc_qentry *smc_llc_wait(struct smc_link_group *lgr,\n\t\t\t\t    struct smc_link *lnk,\n\t\t\t\t    int time_out, u8 exp_msg)\n{\n\tstruct smc_llc_flow *flow = &lgr->llc_flow_lcl;\n\tu8 rcv_msg;\n\n\twait_event_timeout(lgr->llc_msg_waiter,\n\t\t\t   (flow->qentry ||\n\t\t\t    (lnk && !smc_link_usable(lnk)) ||\n\t\t\t    list_empty(&lgr->list)),\n\t\t\t   time_out);\n\tif (!flow->qentry ||\n\t    (lnk && !smc_link_usable(lnk)) || list_empty(&lgr->list)) {\n\t\tsmc_llc_flow_qentry_del(flow);\n\t\tgoto out;\n\t}\n\trcv_msg = flow->qentry->msg.raw.hdr.common.llc_type;\n\tif (exp_msg && rcv_msg != exp_msg) {\n\t\tif (exp_msg == SMC_LLC_ADD_LINK &&\n\t\t    rcv_msg == SMC_LLC_DELETE_LINK) {\n\t\t\t \n\t\t\tsmc_llc_flow_start(&lgr->llc_flow_lcl,\n\t\t\t\t\t   smc_llc_flow_qentry_clr(flow));\n\t\t\treturn NULL;\n\t\t}\n\t\tpr_warn_once(\"smc: SMC-R lg %*phN net %llu dropped unexpected LLC msg: \"\n\t\t\t     \"msg %d exp %d flow %d role %d flags %x\\n\",\n\t\t\t     SMC_LGR_ID_SIZE, &lgr->id, lgr->net->net_cookie,\n\t\t\t     rcv_msg, exp_msg,\n\t\t\t     flow->type, lgr->role,\n\t\t\t     flow->qentry->msg.raw.hdr.flags);\n\t\tsmc_llc_flow_qentry_del(flow);\n\t}\nout:\n\treturn flow->qentry;\n}\n\n \n\nstruct smc_llc_tx_pend {\n};\n\n \nstatic void smc_llc_tx_handler(struct smc_wr_tx_pend_priv *pend,\n\t\t\t       struct smc_link *link,\n\t\t\t       enum ib_wc_status wc_status)\n{\n\t \n}\n\n \nstatic int smc_llc_add_pending_send(struct smc_link *link,\n\t\t\t\t    struct smc_wr_buf **wr_buf,\n\t\t\t\t    struct smc_wr_tx_pend_priv **pend)\n{\n\tint rc;\n\n\trc = smc_wr_tx_get_free_slot(link, smc_llc_tx_handler, wr_buf, NULL,\n\t\t\t\t     pend);\n\tif (rc < 0)\n\t\treturn rc;\n\tBUILD_BUG_ON_MSG(\n\t\tsizeof(union smc_llc_msg) > SMC_WR_BUF_SIZE,\n\t\t\"must increase SMC_WR_BUF_SIZE to at least sizeof(struct smc_llc_msg)\");\n\tBUILD_BUG_ON_MSG(\n\t\tsizeof(union smc_llc_msg) != SMC_WR_TX_SIZE,\n\t\t\"must adapt SMC_WR_TX_SIZE to sizeof(struct smc_llc_msg); if not all smc_wr upper layer protocols use the same message size any more, must start to set link->wr_tx_sges[i].length on each individual smc_wr_tx_send()\");\n\tBUILD_BUG_ON_MSG(\n\t\tsizeof(struct smc_llc_tx_pend) > SMC_WR_TX_PEND_PRIV_SIZE,\n\t\t\"must increase SMC_WR_TX_PEND_PRIV_SIZE to at least sizeof(struct smc_llc_tx_pend)\");\n\treturn 0;\n}\n\nstatic int smc_llc_add_pending_send_v2(struct smc_link *link,\n\t\t\t\t       struct smc_wr_v2_buf **wr_buf,\n\t\t\t\t       struct smc_wr_tx_pend_priv **pend)\n{\n\tint rc;\n\n\trc = smc_wr_tx_get_v2_slot(link, smc_llc_tx_handler, wr_buf, pend);\n\tif (rc < 0)\n\t\treturn rc;\n\treturn 0;\n}\n\nstatic void smc_llc_init_msg_hdr(struct smc_llc_hdr *hdr,\n\t\t\t\t struct smc_link_group *lgr, size_t len)\n{\n\tif (lgr->smc_version == SMC_V2) {\n\t\thdr->common.llc_version = SMC_V2;\n\t\thdr->length_v2 = len;\n\t} else {\n\t\thdr->common.llc_version = 0;\n\t\thdr->length = len;\n\t}\n}\n\n \nint smc_llc_send_confirm_link(struct smc_link *link,\n\t\t\t      enum smc_llc_reqresp reqresp)\n{\n\tstruct smc_llc_msg_confirm_link *confllc;\n\tstruct smc_wr_tx_pend_priv *pend;\n\tstruct smc_wr_buf *wr_buf;\n\tint rc;\n\n\tif (!smc_wr_tx_link_hold(link))\n\t\treturn -ENOLINK;\n\trc = smc_llc_add_pending_send(link, &wr_buf, &pend);\n\tif (rc)\n\t\tgoto put_out;\n\tconfllc = (struct smc_llc_msg_confirm_link *)wr_buf;\n\tmemset(confllc, 0, sizeof(*confllc));\n\tconfllc->hd.common.llc_type = SMC_LLC_CONFIRM_LINK;\n\tsmc_llc_init_msg_hdr(&confllc->hd, link->lgr, sizeof(*confllc));\n\tconfllc->hd.flags |= SMC_LLC_FLAG_NO_RMBE_EYEC;\n\tif (reqresp == SMC_LLC_RESP)\n\t\tconfllc->hd.flags |= SMC_LLC_FLAG_RESP;\n\tmemcpy(confllc->sender_mac, link->smcibdev->mac[link->ibport - 1],\n\t       ETH_ALEN);\n\tmemcpy(confllc->sender_gid, link->gid, SMC_GID_SIZE);\n\thton24(confllc->sender_qp_num, link->roce_qp->qp_num);\n\tconfllc->link_num = link->link_id;\n\tmemcpy(confllc->link_uid, link->link_uid, SMC_LGR_ID_SIZE);\n\tconfllc->max_links = SMC_LINKS_ADD_LNK_MAX;\n\tif (link->lgr->smc_version == SMC_V2 &&\n\t    link->lgr->peer_smc_release >= SMC_RELEASE_1) {\n\t\tconfllc->max_conns = link->lgr->max_conns;\n\t\tconfllc->max_links = link->lgr->max_links;\n\t}\n\t \n\trc = smc_wr_tx_send(link, pend);\nput_out:\n\tsmc_wr_tx_link_put(link);\n\treturn rc;\n}\n\n \nstatic int smc_llc_send_confirm_rkey(struct smc_link *send_link,\n\t\t\t\t     struct smc_buf_desc *rmb_desc)\n{\n\tstruct smc_llc_msg_confirm_rkey *rkeyllc;\n\tstruct smc_wr_tx_pend_priv *pend;\n\tstruct smc_wr_buf *wr_buf;\n\tstruct smc_link *link;\n\tint i, rc, rtok_ix;\n\n\tif (!smc_wr_tx_link_hold(send_link))\n\t\treturn -ENOLINK;\n\trc = smc_llc_add_pending_send(send_link, &wr_buf, &pend);\n\tif (rc)\n\t\tgoto put_out;\n\trkeyllc = (struct smc_llc_msg_confirm_rkey *)wr_buf;\n\tmemset(rkeyllc, 0, sizeof(*rkeyllc));\n\trkeyllc->hd.common.llc_type = SMC_LLC_CONFIRM_RKEY;\n\tsmc_llc_init_msg_hdr(&rkeyllc->hd, send_link->lgr, sizeof(*rkeyllc));\n\n\trtok_ix = 1;\n\tfor (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {\n\t\tlink = &send_link->lgr->lnk[i];\n\t\tif (smc_link_active(link) && link != send_link) {\n\t\t\trkeyllc->rtoken[rtok_ix].link_id = link->link_id;\n\t\t\trkeyllc->rtoken[rtok_ix].rmb_key =\n\t\t\t\thtonl(rmb_desc->mr[link->link_idx]->rkey);\n\t\t\trkeyllc->rtoken[rtok_ix].rmb_vaddr = rmb_desc->is_vm ?\n\t\t\t\tcpu_to_be64((uintptr_t)rmb_desc->cpu_addr) :\n\t\t\t\tcpu_to_be64((u64)sg_dma_address\n\t\t\t\t\t    (rmb_desc->sgt[link->link_idx].sgl));\n\t\t\trtok_ix++;\n\t\t}\n\t}\n\t \n\trkeyllc->rtoken[0].num_rkeys = rtok_ix - 1;\n\trkeyllc->rtoken[0].rmb_key =\n\t\thtonl(rmb_desc->mr[send_link->link_idx]->rkey);\n\trkeyllc->rtoken[0].rmb_vaddr = rmb_desc->is_vm ?\n\t\tcpu_to_be64((uintptr_t)rmb_desc->cpu_addr) :\n\t\tcpu_to_be64((u64)sg_dma_address\n\t\t\t    (rmb_desc->sgt[send_link->link_idx].sgl));\n\t \n\trc = smc_wr_tx_send(send_link, pend);\nput_out:\n\tsmc_wr_tx_link_put(send_link);\n\treturn rc;\n}\n\n \nstatic int smc_llc_send_delete_rkey(struct smc_link *link,\n\t\t\t\t    struct smc_buf_desc *rmb_desc)\n{\n\tstruct smc_llc_msg_delete_rkey *rkeyllc;\n\tstruct smc_wr_tx_pend_priv *pend;\n\tstruct smc_wr_buf *wr_buf;\n\tint rc;\n\n\tif (!smc_wr_tx_link_hold(link))\n\t\treturn -ENOLINK;\n\trc = smc_llc_add_pending_send(link, &wr_buf, &pend);\n\tif (rc)\n\t\tgoto put_out;\n\trkeyllc = (struct smc_llc_msg_delete_rkey *)wr_buf;\n\tmemset(rkeyllc, 0, sizeof(*rkeyllc));\n\trkeyllc->hd.common.llc_type = SMC_LLC_DELETE_RKEY;\n\tsmc_llc_init_msg_hdr(&rkeyllc->hd, link->lgr, sizeof(*rkeyllc));\n\trkeyllc->num_rkeys = 1;\n\trkeyllc->rkey[0] = htonl(rmb_desc->mr[link->link_idx]->rkey);\n\t \n\trc = smc_wr_tx_send(link, pend);\nput_out:\n\tsmc_wr_tx_link_put(link);\n\treturn rc;\n}\n\n \nstatic struct smc_buf_desc *_smc_llc_get_next_rmb(struct smc_link_group *lgr,\n\t\t\t\t\t\t  int *buf_lst)\n{\n\tstruct smc_buf_desc *buf_pos;\n\n\twhile (*buf_lst < SMC_RMBE_SIZES) {\n\t\tbuf_pos = list_first_entry_or_null(&lgr->rmbs[*buf_lst],\n\t\t\t\t\t\t   struct smc_buf_desc, list);\n\t\tif (buf_pos)\n\t\t\treturn buf_pos;\n\t\t(*buf_lst)++;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct smc_buf_desc *smc_llc_get_next_rmb(struct smc_link_group *lgr,\n\t\t\t\t\t\t int *buf_lst,\n\t\t\t\t\t\t struct smc_buf_desc *buf_pos)\n{\n\tstruct smc_buf_desc *buf_next;\n\n\tif (!buf_pos)\n\t\treturn _smc_llc_get_next_rmb(lgr, buf_lst);\n\n\tif (list_is_last(&buf_pos->list, &lgr->rmbs[*buf_lst])) {\n\t\t(*buf_lst)++;\n\t\treturn _smc_llc_get_next_rmb(lgr, buf_lst);\n\t}\n\tbuf_next = list_next_entry(buf_pos, list);\n\treturn buf_next;\n}\n\nstatic struct smc_buf_desc *smc_llc_get_first_rmb(struct smc_link_group *lgr,\n\t\t\t\t\t\t  int *buf_lst)\n{\n\t*buf_lst = 0;\n\treturn smc_llc_get_next_rmb(lgr, buf_lst, NULL);\n}\n\nstatic int smc_llc_fill_ext_v2(struct smc_llc_msg_add_link_v2_ext *ext,\n\t\t\t       struct smc_link *link, struct smc_link *link_new)\n{\n\tstruct smc_link_group *lgr = link->lgr;\n\tstruct smc_buf_desc *buf_pos;\n\tint prim_lnk_idx, lnk_idx, i;\n\tstruct smc_buf_desc *rmb;\n\tint len = sizeof(*ext);\n\tint buf_lst;\n\n\text->v2_direct = !lgr->uses_gateway;\n\tmemcpy(ext->client_target_gid, link_new->gid, SMC_GID_SIZE);\n\n\tprim_lnk_idx = link->link_idx;\n\tlnk_idx = link_new->link_idx;\n\tdown_write(&lgr->rmbs_lock);\n\text->num_rkeys = lgr->conns_num;\n\tif (!ext->num_rkeys)\n\t\tgoto out;\n\tbuf_pos = smc_llc_get_first_rmb(lgr, &buf_lst);\n\tfor (i = 0; i < ext->num_rkeys; i++) {\n\t\twhile (buf_pos && !(buf_pos)->used)\n\t\t\tbuf_pos = smc_llc_get_next_rmb(lgr, &buf_lst, buf_pos);\n\t\tif (!buf_pos)\n\t\t\tbreak;\n\t\trmb = buf_pos;\n\t\text->rt[i].rmb_key = htonl(rmb->mr[prim_lnk_idx]->rkey);\n\t\text->rt[i].rmb_key_new = htonl(rmb->mr[lnk_idx]->rkey);\n\t\text->rt[i].rmb_vaddr_new = rmb->is_vm ?\n\t\t\tcpu_to_be64((uintptr_t)rmb->cpu_addr) :\n\t\t\tcpu_to_be64((u64)sg_dma_address(rmb->sgt[lnk_idx].sgl));\n\t\tbuf_pos = smc_llc_get_next_rmb(lgr, &buf_lst, buf_pos);\n\t}\n\tlen += i * sizeof(ext->rt[0]);\nout:\n\tup_write(&lgr->rmbs_lock);\n\treturn len;\n}\n\n \nint smc_llc_send_add_link(struct smc_link *link, u8 mac[], u8 gid[],\n\t\t\t  struct smc_link *link_new,\n\t\t\t  enum smc_llc_reqresp reqresp)\n{\n\tstruct smc_llc_msg_add_link_v2_ext *ext = NULL;\n\tstruct smc_llc_msg_add_link *addllc;\n\tstruct smc_wr_tx_pend_priv *pend;\n\tint len = sizeof(*addllc);\n\tint rc;\n\n\tif (!smc_wr_tx_link_hold(link))\n\t\treturn -ENOLINK;\n\tif (link->lgr->smc_version == SMC_V2) {\n\t\tstruct smc_wr_v2_buf *wr_buf;\n\n\t\trc = smc_llc_add_pending_send_v2(link, &wr_buf, &pend);\n\t\tif (rc)\n\t\t\tgoto put_out;\n\t\taddllc = (struct smc_llc_msg_add_link *)wr_buf;\n\t\text = (struct smc_llc_msg_add_link_v2_ext *)\n\t\t\t\t\t\t&wr_buf->raw[sizeof(*addllc)];\n\t\tmemset(ext, 0, SMC_WR_TX_SIZE);\n\t} else {\n\t\tstruct smc_wr_buf *wr_buf;\n\n\t\trc = smc_llc_add_pending_send(link, &wr_buf, &pend);\n\t\tif (rc)\n\t\t\tgoto put_out;\n\t\taddllc = (struct smc_llc_msg_add_link *)wr_buf;\n\t}\n\n\tmemset(addllc, 0, sizeof(*addllc));\n\taddllc->hd.common.llc_type = SMC_LLC_ADD_LINK;\n\tif (reqresp == SMC_LLC_RESP)\n\t\taddllc->hd.flags |= SMC_LLC_FLAG_RESP;\n\tmemcpy(addllc->sender_mac, mac, ETH_ALEN);\n\tmemcpy(addllc->sender_gid, gid, SMC_GID_SIZE);\n\tif (link_new) {\n\t\taddllc->link_num = link_new->link_id;\n\t\thton24(addllc->sender_qp_num, link_new->roce_qp->qp_num);\n\t\thton24(addllc->initial_psn, link_new->psn_initial);\n\t\tif (reqresp == SMC_LLC_REQ)\n\t\t\taddllc->qp_mtu = link_new->path_mtu;\n\t\telse\n\t\t\taddllc->qp_mtu = min(link_new->path_mtu,\n\t\t\t\t\t     link_new->peer_mtu);\n\t}\n\tif (ext && link_new)\n\t\tlen += smc_llc_fill_ext_v2(ext, link, link_new);\n\tsmc_llc_init_msg_hdr(&addllc->hd, link->lgr, len);\n\t \n\tif (link->lgr->smc_version == SMC_V2)\n\t\trc = smc_wr_tx_v2_send(link, pend, len);\n\telse\n\t\trc = smc_wr_tx_send(link, pend);\nput_out:\n\tsmc_wr_tx_link_put(link);\n\treturn rc;\n}\n\n \nint smc_llc_send_delete_link(struct smc_link *link, u8 link_del_id,\n\t\t\t     enum smc_llc_reqresp reqresp, bool orderly,\n\t\t\t     u32 reason)\n{\n\tstruct smc_llc_msg_del_link *delllc;\n\tstruct smc_wr_tx_pend_priv *pend;\n\tstruct smc_wr_buf *wr_buf;\n\tint rc;\n\n\tif (!smc_wr_tx_link_hold(link))\n\t\treturn -ENOLINK;\n\trc = smc_llc_add_pending_send(link, &wr_buf, &pend);\n\tif (rc)\n\t\tgoto put_out;\n\tdelllc = (struct smc_llc_msg_del_link *)wr_buf;\n\n\tmemset(delllc, 0, sizeof(*delllc));\n\tdelllc->hd.common.llc_type = SMC_LLC_DELETE_LINK;\n\tsmc_llc_init_msg_hdr(&delllc->hd, link->lgr, sizeof(*delllc));\n\tif (reqresp == SMC_LLC_RESP)\n\t\tdelllc->hd.flags |= SMC_LLC_FLAG_RESP;\n\tif (orderly)\n\t\tdelllc->hd.flags |= SMC_LLC_FLAG_DEL_LINK_ORDERLY;\n\tif (link_del_id)\n\t\tdelllc->link_num = link_del_id;\n\telse\n\t\tdelllc->hd.flags |= SMC_LLC_FLAG_DEL_LINK_ALL;\n\tdelllc->reason = htonl(reason);\n\t \n\trc = smc_wr_tx_send(link, pend);\nput_out:\n\tsmc_wr_tx_link_put(link);\n\treturn rc;\n}\n\n \nstatic int smc_llc_send_test_link(struct smc_link *link, u8 user_data[16])\n{\n\tstruct smc_llc_msg_test_link *testllc;\n\tstruct smc_wr_tx_pend_priv *pend;\n\tstruct smc_wr_buf *wr_buf;\n\tint rc;\n\n\tif (!smc_wr_tx_link_hold(link))\n\t\treturn -ENOLINK;\n\trc = smc_llc_add_pending_send(link, &wr_buf, &pend);\n\tif (rc)\n\t\tgoto put_out;\n\ttestllc = (struct smc_llc_msg_test_link *)wr_buf;\n\tmemset(testllc, 0, sizeof(*testllc));\n\ttestllc->hd.common.llc_type = SMC_LLC_TEST_LINK;\n\tsmc_llc_init_msg_hdr(&testllc->hd, link->lgr, sizeof(*testllc));\n\tmemcpy(testllc->user_data, user_data, sizeof(testllc->user_data));\n\t \n\trc = smc_wr_tx_send(link, pend);\nput_out:\n\tsmc_wr_tx_link_put(link);\n\treturn rc;\n}\n\n \nstatic int smc_llc_send_message(struct smc_link *link, void *llcbuf)\n{\n\tstruct smc_wr_tx_pend_priv *pend;\n\tstruct smc_wr_buf *wr_buf;\n\tint rc;\n\n\tif (!smc_wr_tx_link_hold(link))\n\t\treturn -ENOLINK;\n\trc = smc_llc_add_pending_send(link, &wr_buf, &pend);\n\tif (rc)\n\t\tgoto put_out;\n\tmemcpy(wr_buf, llcbuf, sizeof(union smc_llc_msg));\n\trc = smc_wr_tx_send(link, pend);\nput_out:\n\tsmc_wr_tx_link_put(link);\n\treturn rc;\n}\n\n \nstatic int smc_llc_send_message_wait(struct smc_link *link, void *llcbuf)\n{\n\tstruct smc_wr_tx_pend_priv *pend;\n\tstruct smc_wr_buf *wr_buf;\n\tint rc;\n\n\tif (!smc_wr_tx_link_hold(link))\n\t\treturn -ENOLINK;\n\trc = smc_llc_add_pending_send(link, &wr_buf, &pend);\n\tif (rc)\n\t\tgoto put_out;\n\tmemcpy(wr_buf, llcbuf, sizeof(union smc_llc_msg));\n\trc = smc_wr_tx_send_wait(link, pend, SMC_LLC_WAIT_TIME);\nput_out:\n\tsmc_wr_tx_link_put(link);\n\treturn rc;\n}\n\n \n\nstatic int smc_llc_alloc_alt_link(struct smc_link_group *lgr,\n\t\t\t\t  enum smc_lgr_type lgr_new_t)\n{\n\tint i;\n\n\tif (lgr->type == SMC_LGR_SYMMETRIC ||\n\t    (lgr->type != SMC_LGR_SINGLE &&\n\t     (lgr_new_t == SMC_LGR_ASYMMETRIC_LOCAL ||\n\t      lgr_new_t == SMC_LGR_ASYMMETRIC_PEER)))\n\t\treturn -EMLINK;\n\n\tif (lgr_new_t == SMC_LGR_ASYMMETRIC_LOCAL ||\n\t    lgr_new_t == SMC_LGR_ASYMMETRIC_PEER) {\n\t\tfor (i = SMC_LINKS_PER_LGR_MAX - 1; i >= 0; i--)\n\t\t\tif (lgr->lnk[i].state == SMC_LNK_UNUSED)\n\t\t\t\treturn i;\n\t} else {\n\t\tfor (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++)\n\t\t\tif (lgr->lnk[i].state == SMC_LNK_UNUSED)\n\t\t\t\treturn i;\n\t}\n\treturn -EMLINK;\n}\n\n \nstatic int smc_llc_add_link_cont(struct smc_link *link,\n\t\t\t\t struct smc_link *link_new, u8 *num_rkeys_todo,\n\t\t\t\t int *buf_lst, struct smc_buf_desc **buf_pos)\n{\n\tstruct smc_llc_msg_add_link_cont *addc_llc;\n\tstruct smc_link_group *lgr = link->lgr;\n\tint prim_lnk_idx, lnk_idx, i, rc;\n\tstruct smc_wr_tx_pend_priv *pend;\n\tstruct smc_wr_buf *wr_buf;\n\tstruct smc_buf_desc *rmb;\n\tu8 n;\n\n\tif (!smc_wr_tx_link_hold(link))\n\t\treturn -ENOLINK;\n\trc = smc_llc_add_pending_send(link, &wr_buf, &pend);\n\tif (rc)\n\t\tgoto put_out;\n\taddc_llc = (struct smc_llc_msg_add_link_cont *)wr_buf;\n\tmemset(addc_llc, 0, sizeof(*addc_llc));\n\n\tprim_lnk_idx = link->link_idx;\n\tlnk_idx = link_new->link_idx;\n\taddc_llc->link_num = link_new->link_id;\n\taddc_llc->num_rkeys = *num_rkeys_todo;\n\tn = *num_rkeys_todo;\n\tfor (i = 0; i < min_t(u8, n, SMC_LLC_RKEYS_PER_CONT_MSG); i++) {\n\t\twhile (*buf_pos && !(*buf_pos)->used)\n\t\t\t*buf_pos = smc_llc_get_next_rmb(lgr, buf_lst, *buf_pos);\n\t\tif (!*buf_pos) {\n\t\t\taddc_llc->num_rkeys = addc_llc->num_rkeys -\n\t\t\t\t\t      *num_rkeys_todo;\n\t\t\t*num_rkeys_todo = 0;\n\t\t\tbreak;\n\t\t}\n\t\trmb = *buf_pos;\n\n\t\taddc_llc->rt[i].rmb_key = htonl(rmb->mr[prim_lnk_idx]->rkey);\n\t\taddc_llc->rt[i].rmb_key_new = htonl(rmb->mr[lnk_idx]->rkey);\n\t\taddc_llc->rt[i].rmb_vaddr_new = rmb->is_vm ?\n\t\t\tcpu_to_be64((uintptr_t)rmb->cpu_addr) :\n\t\t\tcpu_to_be64((u64)sg_dma_address(rmb->sgt[lnk_idx].sgl));\n\n\t\t(*num_rkeys_todo)--;\n\t\t*buf_pos = smc_llc_get_next_rmb(lgr, buf_lst, *buf_pos);\n\t}\n\taddc_llc->hd.common.llc_type = SMC_LLC_ADD_LINK_CONT;\n\taddc_llc->hd.length = sizeof(struct smc_llc_msg_add_link_cont);\n\tif (lgr->role == SMC_CLNT)\n\t\taddc_llc->hd.flags |= SMC_LLC_FLAG_RESP;\n\trc = smc_wr_tx_send(link, pend);\nput_out:\n\tsmc_wr_tx_link_put(link);\n\treturn rc;\n}\n\nstatic int smc_llc_cli_rkey_exchange(struct smc_link *link,\n\t\t\t\t     struct smc_link *link_new)\n{\n\tstruct smc_llc_msg_add_link_cont *addc_llc;\n\tstruct smc_link_group *lgr = link->lgr;\n\tu8 max, num_rkeys_send, num_rkeys_recv;\n\tstruct smc_llc_qentry *qentry;\n\tstruct smc_buf_desc *buf_pos;\n\tint buf_lst;\n\tint rc = 0;\n\tint i;\n\n\tdown_write(&lgr->rmbs_lock);\n\tnum_rkeys_send = lgr->conns_num;\n\tbuf_pos = smc_llc_get_first_rmb(lgr, &buf_lst);\n\tdo {\n\t\tqentry = smc_llc_wait(lgr, NULL, SMC_LLC_WAIT_TIME,\n\t\t\t\t      SMC_LLC_ADD_LINK_CONT);\n\t\tif (!qentry) {\n\t\t\trc = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t\taddc_llc = &qentry->msg.add_link_cont;\n\t\tnum_rkeys_recv = addc_llc->num_rkeys;\n\t\tmax = min_t(u8, num_rkeys_recv, SMC_LLC_RKEYS_PER_CONT_MSG);\n\t\tfor (i = 0; i < max; i++) {\n\t\t\tsmc_rtoken_set(lgr, link->link_idx, link_new->link_idx,\n\t\t\t\t       addc_llc->rt[i].rmb_key,\n\t\t\t\t       addc_llc->rt[i].rmb_vaddr_new,\n\t\t\t\t       addc_llc->rt[i].rmb_key_new);\n\t\t\tnum_rkeys_recv--;\n\t\t}\n\t\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\t\trc = smc_llc_add_link_cont(link, link_new, &num_rkeys_send,\n\t\t\t\t\t   &buf_lst, &buf_pos);\n\t\tif (rc)\n\t\t\tbreak;\n\t} while (num_rkeys_send || num_rkeys_recv);\n\n\tup_write(&lgr->rmbs_lock);\n\treturn rc;\n}\n\n \nstatic int smc_llc_cli_add_link_reject(struct smc_llc_qentry *qentry)\n{\n\tqentry->msg.raw.hdr.flags |= SMC_LLC_FLAG_RESP;\n\tqentry->msg.raw.hdr.flags |= SMC_LLC_FLAG_ADD_LNK_REJ;\n\tqentry->msg.raw.hdr.add_link_rej_rsn = SMC_LLC_REJ_RSN_NO_ALT_PATH;\n\tsmc_llc_init_msg_hdr(&qentry->msg.raw.hdr, qentry->link->lgr,\n\t\t\t     sizeof(qentry->msg));\n\treturn smc_llc_send_message(qentry->link, &qentry->msg);\n}\n\nstatic int smc_llc_cli_conf_link(struct smc_link *link,\n\t\t\t\t struct smc_init_info *ini,\n\t\t\t\t struct smc_link *link_new,\n\t\t\t\t enum smc_lgr_type lgr_new_t)\n{\n\tstruct smc_link_group *lgr = link->lgr;\n\tstruct smc_llc_qentry *qentry = NULL;\n\tint rc = 0;\n\n\t \n\tqentry = smc_llc_wait(lgr, NULL, SMC_LLC_WAIT_FIRST_TIME, 0);\n\tif (!qentry) {\n\t\trc = smc_llc_send_delete_link(link, link_new->link_id,\n\t\t\t\t\t      SMC_LLC_REQ, false,\n\t\t\t\t\t      SMC_LLC_DEL_LOST_PATH);\n\t\treturn -ENOLINK;\n\t}\n\tif (qentry->msg.raw.hdr.common.llc_type != SMC_LLC_CONFIRM_LINK) {\n\t\t \n\t\tqentry->msg.raw.hdr.flags |= SMC_LLC_FLAG_RESP;\n\t\tsmc_llc_send_message(link, &qentry->msg);\n\t\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\t\treturn -ENOLINK;\n\t}\n\tsmc_llc_save_peer_uid(qentry);\n\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\n\trc = smc_ib_modify_qp_rts(link_new);\n\tif (rc) {\n\t\tsmc_llc_send_delete_link(link, link_new->link_id, SMC_LLC_REQ,\n\t\t\t\t\t false, SMC_LLC_DEL_LOST_PATH);\n\t\treturn -ENOLINK;\n\t}\n\tsmc_wr_remember_qp_attr(link_new);\n\n\trc = smcr_buf_reg_lgr(link_new);\n\tif (rc) {\n\t\tsmc_llc_send_delete_link(link, link_new->link_id, SMC_LLC_REQ,\n\t\t\t\t\t false, SMC_LLC_DEL_LOST_PATH);\n\t\treturn -ENOLINK;\n\t}\n\n\t \n\trc = smc_llc_send_confirm_link(link_new, SMC_LLC_RESP);\n\tif (rc) {\n\t\tsmc_llc_send_delete_link(link, link_new->link_id, SMC_LLC_REQ,\n\t\t\t\t\t false, SMC_LLC_DEL_LOST_PATH);\n\t\treturn -ENOLINK;\n\t}\n\tsmc_llc_link_active(link_new);\n\tif (lgr_new_t == SMC_LGR_ASYMMETRIC_LOCAL ||\n\t    lgr_new_t == SMC_LGR_ASYMMETRIC_PEER)\n\t\tsmcr_lgr_set_type_asym(lgr, lgr_new_t, link_new->link_idx);\n\telse\n\t\tsmcr_lgr_set_type(lgr, lgr_new_t);\n\treturn 0;\n}\n\nstatic void smc_llc_save_add_link_rkeys(struct smc_link *link,\n\t\t\t\t\tstruct smc_link *link_new)\n{\n\tstruct smc_llc_msg_add_link_v2_ext *ext;\n\tstruct smc_link_group *lgr = link->lgr;\n\tint max, i;\n\n\text = (struct smc_llc_msg_add_link_v2_ext *)((u8 *)lgr->wr_rx_buf_v2 +\n\t\t\t\t\t\t     SMC_WR_TX_SIZE);\n\tmax = min_t(u8, ext->num_rkeys, SMC_LLC_RKEYS_PER_MSG_V2);\n\tdown_write(&lgr->rmbs_lock);\n\tfor (i = 0; i < max; i++) {\n\t\tsmc_rtoken_set(lgr, link->link_idx, link_new->link_idx,\n\t\t\t       ext->rt[i].rmb_key,\n\t\t\t       ext->rt[i].rmb_vaddr_new,\n\t\t\t       ext->rt[i].rmb_key_new);\n\t}\n\tup_write(&lgr->rmbs_lock);\n}\n\nstatic void smc_llc_save_add_link_info(struct smc_link *link,\n\t\t\t\t       struct smc_llc_msg_add_link *add_llc)\n{\n\tlink->peer_qpn = ntoh24(add_llc->sender_qp_num);\n\tmemcpy(link->peer_gid, add_llc->sender_gid, SMC_GID_SIZE);\n\tmemcpy(link->peer_mac, add_llc->sender_mac, ETH_ALEN);\n\tlink->peer_psn = ntoh24(add_llc->initial_psn);\n\tlink->peer_mtu = add_llc->qp_mtu;\n}\n\n \nint smc_llc_cli_add_link(struct smc_link *link, struct smc_llc_qentry *qentry)\n{\n\tstruct smc_llc_msg_add_link *llc = &qentry->msg.add_link;\n\tenum smc_lgr_type lgr_new_t = SMC_LGR_SYMMETRIC;\n\tstruct smc_link_group *lgr = smc_get_lgr(link);\n\tstruct smc_init_info *ini = NULL;\n\tstruct smc_link *lnk_new = NULL;\n\tint lnk_idx, rc = 0;\n\n\tif (!llc->qp_mtu)\n\t\tgoto out_reject;\n\n\tini = kzalloc(sizeof(*ini), GFP_KERNEL);\n\tif (!ini) {\n\t\trc = -ENOMEM;\n\t\tgoto out_reject;\n\t}\n\n\tif (lgr->type == SMC_LGR_SINGLE && lgr->max_links <= 1) {\n\t\trc = 0;\n\t\tgoto out_reject;\n\t}\n\n\tini->vlan_id = lgr->vlan_id;\n\tif (lgr->smc_version == SMC_V2) {\n\t\tini->check_smcrv2 = true;\n\t\tini->smcrv2.saddr = lgr->saddr;\n\t\tini->smcrv2.daddr = smc_ib_gid_to_ipv4(llc->sender_gid);\n\t}\n\tsmc_pnet_find_alt_roce(lgr, ini, link->smcibdev);\n\tif (!memcmp(llc->sender_gid, link->peer_gid, SMC_GID_SIZE) &&\n\t    (lgr->smc_version == SMC_V2 ||\n\t     !memcmp(llc->sender_mac, link->peer_mac, ETH_ALEN))) {\n\t\tif (!ini->ib_dev && !ini->smcrv2.ib_dev_v2)\n\t\t\tgoto out_reject;\n\t\tlgr_new_t = SMC_LGR_ASYMMETRIC_PEER;\n\t}\n\tif (lgr->smc_version == SMC_V2 && !ini->smcrv2.ib_dev_v2) {\n\t\tlgr_new_t = SMC_LGR_ASYMMETRIC_LOCAL;\n\t\tini->smcrv2.ib_dev_v2 = link->smcibdev;\n\t\tini->smcrv2.ib_port_v2 = link->ibport;\n\t} else if (lgr->smc_version < SMC_V2 && !ini->ib_dev) {\n\t\tlgr_new_t = SMC_LGR_ASYMMETRIC_LOCAL;\n\t\tini->ib_dev = link->smcibdev;\n\t\tini->ib_port = link->ibport;\n\t}\n\tlnk_idx = smc_llc_alloc_alt_link(lgr, lgr_new_t);\n\tif (lnk_idx < 0)\n\t\tgoto out_reject;\n\tlnk_new = &lgr->lnk[lnk_idx];\n\trc = smcr_link_init(lgr, lnk_new, lnk_idx, ini);\n\tif (rc)\n\t\tgoto out_reject;\n\tsmc_llc_save_add_link_info(lnk_new, llc);\n\tlnk_new->link_id = llc->link_num;\t \n\tsmc_llc_link_set_uid(lnk_new);\n\n\trc = smc_ib_ready_link(lnk_new);\n\tif (rc)\n\t\tgoto out_clear_lnk;\n\n\trc = smcr_buf_map_lgr(lnk_new);\n\tif (rc)\n\t\tgoto out_clear_lnk;\n\n\trc = smc_llc_send_add_link(link,\n\t\t\t\t   lnk_new->smcibdev->mac[lnk_new->ibport - 1],\n\t\t\t\t   lnk_new->gid, lnk_new, SMC_LLC_RESP);\n\tif (rc)\n\t\tgoto out_clear_lnk;\n\tif (lgr->smc_version == SMC_V2) {\n\t\tsmc_llc_save_add_link_rkeys(link, lnk_new);\n\t} else {\n\t\trc = smc_llc_cli_rkey_exchange(link, lnk_new);\n\t\tif (rc) {\n\t\t\trc = 0;\n\t\t\tgoto out_clear_lnk;\n\t\t}\n\t}\n\trc = smc_llc_cli_conf_link(link, ini, lnk_new, lgr_new_t);\n\tif (!rc)\n\t\tgoto out;\nout_clear_lnk:\n\tlnk_new->state = SMC_LNK_INACTIVE;\n\tsmcr_link_clear(lnk_new, false);\nout_reject:\n\tsmc_llc_cli_add_link_reject(qentry);\nout:\n\tkfree(ini);\n\tkfree(qentry);\n\treturn rc;\n}\n\nstatic void smc_llc_send_request_add_link(struct smc_link *link)\n{\n\tstruct smc_llc_msg_req_add_link_v2 *llc;\n\tstruct smc_wr_tx_pend_priv *pend;\n\tstruct smc_wr_v2_buf *wr_buf;\n\tstruct smc_gidlist gidlist;\n\tint rc, len, i;\n\n\tif (!smc_wr_tx_link_hold(link))\n\t\treturn;\n\tif (link->lgr->type == SMC_LGR_SYMMETRIC ||\n\t    link->lgr->type == SMC_LGR_ASYMMETRIC_PEER)\n\t\tgoto put_out;\n\n\tsmc_fill_gid_list(link->lgr, &gidlist, link->smcibdev, link->gid);\n\tif (gidlist.len <= 1)\n\t\tgoto put_out;\n\n\trc = smc_llc_add_pending_send_v2(link, &wr_buf, &pend);\n\tif (rc)\n\t\tgoto put_out;\n\tllc = (struct smc_llc_msg_req_add_link_v2 *)wr_buf;\n\tmemset(llc, 0, SMC_WR_TX_SIZE);\n\n\tllc->hd.common.llc_type = SMC_LLC_REQ_ADD_LINK;\n\tfor (i = 0; i < gidlist.len; i++)\n\t\tmemcpy(llc->gid[i], gidlist.list[i], sizeof(gidlist.list[0]));\n\tllc->gid_cnt = gidlist.len;\n\tlen = sizeof(*llc) + (gidlist.len * sizeof(gidlist.list[0]));\n\tsmc_llc_init_msg_hdr(&llc->hd, link->lgr, len);\n\trc = smc_wr_tx_v2_send(link, pend, len);\n\tif (!rc)\n\t\t \n\t\tlink->lgr->llc_flow_lcl.type = SMC_LLC_FLOW_REQ_ADD_LINK;\nput_out:\n\tsmc_wr_tx_link_put(link);\n}\n\n \nstatic void smc_llc_cli_add_link_invite(struct smc_link *link,\n\t\t\t\t\tstruct smc_llc_qentry *qentry)\n{\n\tstruct smc_link_group *lgr = smc_get_lgr(link);\n\tstruct smc_init_info *ini = NULL;\n\n\tif (lgr->smc_version == SMC_V2) {\n\t\tsmc_llc_send_request_add_link(link);\n\t\tgoto out;\n\t}\n\n\tif (lgr->type == SMC_LGR_SYMMETRIC ||\n\t    lgr->type == SMC_LGR_ASYMMETRIC_PEER)\n\t\tgoto out;\n\n\tif (lgr->type == SMC_LGR_SINGLE && lgr->max_links <= 1)\n\t\tgoto out;\n\n\tini = kzalloc(sizeof(*ini), GFP_KERNEL);\n\tif (!ini)\n\t\tgoto out;\n\n\tini->vlan_id = lgr->vlan_id;\n\tsmc_pnet_find_alt_roce(lgr, ini, link->smcibdev);\n\tif (!ini->ib_dev)\n\t\tgoto out;\n\n\tsmc_llc_send_add_link(link, ini->ib_dev->mac[ini->ib_port - 1],\n\t\t\t      ini->ib_gid, NULL, SMC_LLC_REQ);\nout:\n\tkfree(ini);\n\tkfree(qentry);\n}\n\nstatic bool smc_llc_is_empty_llc_message(union smc_llc_msg *llc)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(llc->raw.data); i++)\n\t\tif (llc->raw.data[i])\n\t\t\treturn false;\n\treturn true;\n}\n\nstatic bool smc_llc_is_local_add_link(union smc_llc_msg *llc)\n{\n\tif (llc->raw.hdr.common.llc_type == SMC_LLC_ADD_LINK &&\n\t    smc_llc_is_empty_llc_message(llc))\n\t\treturn true;\n\treturn false;\n}\n\nstatic void smc_llc_process_cli_add_link(struct smc_link_group *lgr)\n{\n\tstruct smc_llc_qentry *qentry;\n\n\tqentry = smc_llc_flow_qentry_clr(&lgr->llc_flow_lcl);\n\n\tdown_write(&lgr->llc_conf_mutex);\n\tif (smc_llc_is_local_add_link(&qentry->msg))\n\t\tsmc_llc_cli_add_link_invite(qentry->link, qentry);\n\telse\n\t\tsmc_llc_cli_add_link(qentry->link, qentry);\n\tup_write(&lgr->llc_conf_mutex);\n}\n\nstatic int smc_llc_active_link_count(struct smc_link_group *lgr)\n{\n\tint i, link_count = 0;\n\n\tfor (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {\n\t\tif (!smc_link_active(&lgr->lnk[i]))\n\t\t\tcontinue;\n\t\tlink_count++;\n\t}\n\treturn link_count;\n}\n\n \nstatic struct smc_link *smc_llc_find_asym_link(struct smc_link_group *lgr)\n{\n\tint asym_idx = -ENOENT;\n\tint i, j, k;\n\tbool found;\n\n\t \n\tfound = false;\n\tfor (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {\n\t\tfor (j = i + 1; j < SMC_LINKS_PER_LGR_MAX; j++) {\n\t\t\tif (!smc_link_usable(&lgr->lnk[i]) ||\n\t\t\t    !smc_link_usable(&lgr->lnk[j]))\n\t\t\t\tcontinue;\n\t\t\tif (!memcmp(lgr->lnk[i].gid, lgr->lnk[j].gid,\n\t\t\t\t    SMC_GID_SIZE)) {\n\t\t\t\tfound = true;\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\tif (!found)\n\t\tgoto out;  \n\tfor (k = 0; k < SMC_LINKS_PER_LGR_MAX; k++) {\n\t\tif (!smc_link_usable(&lgr->lnk[k]))\n\t\t\tcontinue;\n\t\tif (k != i &&\n\t\t    !memcmp(lgr->lnk[i].peer_gid, lgr->lnk[k].peer_gid,\n\t\t\t    SMC_GID_SIZE)) {\n\t\t\tasym_idx = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (k != j &&\n\t\t    !memcmp(lgr->lnk[j].peer_gid, lgr->lnk[k].peer_gid,\n\t\t\t    SMC_GID_SIZE)) {\n\t\t\tasym_idx = j;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn (asym_idx < 0) ? NULL : &lgr->lnk[asym_idx];\n}\n\nstatic void smc_llc_delete_asym_link(struct smc_link_group *lgr)\n{\n\tstruct smc_link *lnk_new = NULL, *lnk_asym;\n\tstruct smc_llc_qentry *qentry;\n\tint rc;\n\n\tlnk_asym = smc_llc_find_asym_link(lgr);\n\tif (!lnk_asym)\n\t\treturn;  \n\tif (!smc_link_downing(&lnk_asym->state))\n\t\treturn;\n\tlnk_new = smc_switch_conns(lgr, lnk_asym, false);\n\tsmc_wr_tx_wait_no_pending_sends(lnk_asym);\n\tif (!lnk_new)\n\t\tgoto out_free;\n\t \n\tlgr->llc_flow_lcl.type = SMC_LLC_FLOW_DEL_LINK;\n\trc = smc_llc_send_delete_link(lnk_new, lnk_asym->link_id, SMC_LLC_REQ,\n\t\t\t\t      true, SMC_LLC_DEL_NO_ASYM_NEEDED);\n\tif (rc) {\n\t\tsmcr_link_down_cond(lnk_new);\n\t\tgoto out_free;\n\t}\n\tqentry = smc_llc_wait(lgr, lnk_new, SMC_LLC_WAIT_TIME,\n\t\t\t      SMC_LLC_DELETE_LINK);\n\tif (!qentry) {\n\t\tsmcr_link_down_cond(lnk_new);\n\t\tgoto out_free;\n\t}\n\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\nout_free:\n\tsmcr_link_clear(lnk_asym, true);\n}\n\nstatic int smc_llc_srv_rkey_exchange(struct smc_link *link,\n\t\t\t\t     struct smc_link *link_new)\n{\n\tstruct smc_llc_msg_add_link_cont *addc_llc;\n\tstruct smc_link_group *lgr = link->lgr;\n\tu8 max, num_rkeys_send, num_rkeys_recv;\n\tstruct smc_llc_qentry *qentry = NULL;\n\tstruct smc_buf_desc *buf_pos;\n\tint buf_lst;\n\tint rc = 0;\n\tint i;\n\n\tdown_write(&lgr->rmbs_lock);\n\tnum_rkeys_send = lgr->conns_num;\n\tbuf_pos = smc_llc_get_first_rmb(lgr, &buf_lst);\n\tdo {\n\t\tsmc_llc_add_link_cont(link, link_new, &num_rkeys_send,\n\t\t\t\t      &buf_lst, &buf_pos);\n\t\tqentry = smc_llc_wait(lgr, link, SMC_LLC_WAIT_TIME,\n\t\t\t\t      SMC_LLC_ADD_LINK_CONT);\n\t\tif (!qentry) {\n\t\t\trc = -ETIMEDOUT;\n\t\t\tgoto out;\n\t\t}\n\t\taddc_llc = &qentry->msg.add_link_cont;\n\t\tnum_rkeys_recv = addc_llc->num_rkeys;\n\t\tmax = min_t(u8, num_rkeys_recv, SMC_LLC_RKEYS_PER_CONT_MSG);\n\t\tfor (i = 0; i < max; i++) {\n\t\t\tsmc_rtoken_set(lgr, link->link_idx, link_new->link_idx,\n\t\t\t\t       addc_llc->rt[i].rmb_key,\n\t\t\t\t       addc_llc->rt[i].rmb_vaddr_new,\n\t\t\t\t       addc_llc->rt[i].rmb_key_new);\n\t\t\tnum_rkeys_recv--;\n\t\t}\n\t\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\t} while (num_rkeys_send || num_rkeys_recv);\nout:\n\tup_write(&lgr->rmbs_lock);\n\treturn rc;\n}\n\nstatic int smc_llc_srv_conf_link(struct smc_link *link,\n\t\t\t\t struct smc_link *link_new,\n\t\t\t\t enum smc_lgr_type lgr_new_t)\n{\n\tstruct smc_link_group *lgr = link->lgr;\n\tstruct smc_llc_qentry *qentry = NULL;\n\tint rc;\n\n\t \n\trc = smc_llc_send_confirm_link(link_new, SMC_LLC_REQ);\n\tif (rc)\n\t\treturn -ENOLINK;\n\t \n\tqentry = smc_llc_wait(lgr, link, SMC_LLC_WAIT_FIRST_TIME, 0);\n\tif (!qentry ||\n\t    qentry->msg.raw.hdr.common.llc_type != SMC_LLC_CONFIRM_LINK) {\n\t\t \n\t\tsmc_llc_send_delete_link(link, link_new->link_id, SMC_LLC_REQ,\n\t\t\t\t\t false, SMC_LLC_DEL_LOST_PATH);\n\t\tif (qentry)\n\t\t\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\t\treturn -ENOLINK;\n\t}\n\tsmc_llc_save_peer_uid(qentry);\n\tsmc_llc_link_active(link_new);\n\tif (lgr_new_t == SMC_LGR_ASYMMETRIC_LOCAL ||\n\t    lgr_new_t == SMC_LGR_ASYMMETRIC_PEER)\n\t\tsmcr_lgr_set_type_asym(lgr, lgr_new_t, link_new->link_idx);\n\telse\n\t\tsmcr_lgr_set_type(lgr, lgr_new_t);\n\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\treturn 0;\n}\n\nstatic void smc_llc_send_req_add_link_response(struct smc_llc_qentry *qentry)\n{\n\tqentry->msg.raw.hdr.flags |= SMC_LLC_FLAG_RESP;\n\tsmc_llc_init_msg_hdr(&qentry->msg.raw.hdr, qentry->link->lgr,\n\t\t\t     sizeof(qentry->msg));\n\tmemset(&qentry->msg.raw.data, 0, sizeof(qentry->msg.raw.data));\n\tsmc_llc_send_message(qentry->link, &qentry->msg);\n}\n\nint smc_llc_srv_add_link(struct smc_link *link,\n\t\t\t struct smc_llc_qentry *req_qentry)\n{\n\tenum smc_lgr_type lgr_new_t = SMC_LGR_SYMMETRIC;\n\tstruct smc_link_group *lgr = link->lgr;\n\tstruct smc_llc_msg_add_link *add_llc;\n\tstruct smc_llc_qentry *qentry = NULL;\n\tbool send_req_add_link_resp = false;\n\tstruct smc_link *link_new = NULL;\n\tstruct smc_init_info *ini = NULL;\n\tint lnk_idx, rc = 0;\n\n\tif (req_qentry &&\n\t    req_qentry->msg.raw.hdr.common.llc_type == SMC_LLC_REQ_ADD_LINK)\n\t\tsend_req_add_link_resp = true;\n\n\tini = kzalloc(sizeof(*ini), GFP_KERNEL);\n\tif (!ini) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (lgr->type == SMC_LGR_SINGLE && lgr->max_links <= 1) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tini->vlan_id = lgr->vlan_id;\n\tif (lgr->smc_version == SMC_V2) {\n\t\tini->check_smcrv2 = true;\n\t\tini->smcrv2.saddr = lgr->saddr;\n\t\tif (send_req_add_link_resp) {\n\t\t\tstruct smc_llc_msg_req_add_link_v2 *req_add =\n\t\t\t\t&req_qentry->msg.req_add_link;\n\n\t\t\tini->smcrv2.daddr = smc_ib_gid_to_ipv4(req_add->gid[0]);\n\t\t}\n\t}\n\tsmc_pnet_find_alt_roce(lgr, ini, link->smcibdev);\n\tif (lgr->smc_version == SMC_V2 && !ini->smcrv2.ib_dev_v2) {\n\t\tlgr_new_t = SMC_LGR_ASYMMETRIC_LOCAL;\n\t\tini->smcrv2.ib_dev_v2 = link->smcibdev;\n\t\tini->smcrv2.ib_port_v2 = link->ibport;\n\t} else if (lgr->smc_version < SMC_V2 && !ini->ib_dev) {\n\t\tlgr_new_t = SMC_LGR_ASYMMETRIC_LOCAL;\n\t\tini->ib_dev = link->smcibdev;\n\t\tini->ib_port = link->ibport;\n\t}\n\tlnk_idx = smc_llc_alloc_alt_link(lgr, lgr_new_t);\n\tif (lnk_idx < 0) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\trc = smcr_link_init(lgr, &lgr->lnk[lnk_idx], lnk_idx, ini);\n\tif (rc)\n\t\tgoto out;\n\tlink_new = &lgr->lnk[lnk_idx];\n\n\trc = smcr_buf_map_lgr(link_new);\n\tif (rc)\n\t\tgoto out_err;\n\n\trc = smc_llc_send_add_link(link,\n\t\t\t\t   link_new->smcibdev->mac[link_new->ibport-1],\n\t\t\t\t   link_new->gid, link_new, SMC_LLC_REQ);\n\tif (rc)\n\t\tgoto out_err;\n\tsend_req_add_link_resp = false;\n\t \n\tqentry = smc_llc_wait(lgr, link, SMC_LLC_WAIT_TIME, SMC_LLC_ADD_LINK);\n\tif (!qentry) {\n\t\trc = -ETIMEDOUT;\n\t\tgoto out_err;\n\t}\n\tadd_llc = &qentry->msg.add_link;\n\tif (add_llc->hd.flags & SMC_LLC_FLAG_ADD_LNK_REJ) {\n\t\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\t\trc = -ENOLINK;\n\t\tgoto out_err;\n\t}\n\tif (lgr->type == SMC_LGR_SINGLE &&\n\t    (!memcmp(add_llc->sender_gid, link->peer_gid, SMC_GID_SIZE) &&\n\t     (lgr->smc_version == SMC_V2 ||\n\t      !memcmp(add_llc->sender_mac, link->peer_mac, ETH_ALEN)))) {\n\t\tlgr_new_t = SMC_LGR_ASYMMETRIC_PEER;\n\t}\n\tsmc_llc_save_add_link_info(link_new, add_llc);\n\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\n\trc = smc_ib_ready_link(link_new);\n\tif (rc)\n\t\tgoto out_err;\n\trc = smcr_buf_reg_lgr(link_new);\n\tif (rc)\n\t\tgoto out_err;\n\tif (lgr->smc_version == SMC_V2) {\n\t\tsmc_llc_save_add_link_rkeys(link, link_new);\n\t} else {\n\t\trc = smc_llc_srv_rkey_exchange(link, link_new);\n\t\tif (rc)\n\t\t\tgoto out_err;\n\t}\n\trc = smc_llc_srv_conf_link(link, link_new, lgr_new_t);\n\tif (rc)\n\t\tgoto out_err;\n\tkfree(ini);\n\treturn 0;\nout_err:\n\tif (link_new) {\n\t\tlink_new->state = SMC_LNK_INACTIVE;\n\t\tsmcr_link_clear(link_new, false);\n\t}\nout:\n\tkfree(ini);\n\tif (send_req_add_link_resp)\n\t\tsmc_llc_send_req_add_link_response(req_qentry);\n\treturn rc;\n}\n\nstatic void smc_llc_process_srv_add_link(struct smc_link_group *lgr)\n{\n\tstruct smc_link *link = lgr->llc_flow_lcl.qentry->link;\n\tstruct smc_llc_qentry *qentry;\n\tint rc;\n\n\tqentry = smc_llc_flow_qentry_clr(&lgr->llc_flow_lcl);\n\n\tdown_write(&lgr->llc_conf_mutex);\n\trc = smc_llc_srv_add_link(link, qentry);\n\tif (!rc && lgr->type == SMC_LGR_SYMMETRIC) {\n\t\t \n\t\tsmc_llc_delete_asym_link(lgr);\n\t}\n\tup_write(&lgr->llc_conf_mutex);\n\tkfree(qentry);\n}\n\n \nvoid smc_llc_add_link_local(struct smc_link *link)\n{\n\tstruct smc_llc_msg_add_link add_llc = {};\n\n\tadd_llc.hd.common.llc_type = SMC_LLC_ADD_LINK;\n\tsmc_llc_init_msg_hdr(&add_llc.hd, link->lgr, sizeof(add_llc));\n\t \n\tsmc_llc_enqueue(link, (union smc_llc_msg *)&add_llc);\n}\n\n \nstatic void smc_llc_add_link_work(struct work_struct *work)\n{\n\tstruct smc_link_group *lgr = container_of(work, struct smc_link_group,\n\t\t\t\t\t\t  llc_add_link_work);\n\n\tif (list_empty(&lgr->list)) {\n\t\t \n\t\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\t\tgoto out;\n\t}\n\n\tif (lgr->role == SMC_CLNT)\n\t\tsmc_llc_process_cli_add_link(lgr);\n\telse\n\t\tsmc_llc_process_srv_add_link(lgr);\nout:\n\tif (lgr->llc_flow_lcl.type != SMC_LLC_FLOW_REQ_ADD_LINK)\n\t\tsmc_llc_flow_stop(lgr, &lgr->llc_flow_lcl);\n}\n\n \nvoid smc_llc_srv_delete_link_local(struct smc_link *link, u8 del_link_id)\n{\n\tstruct smc_llc_msg_del_link del_llc = {};\n\n\tdel_llc.hd.common.llc_type = SMC_LLC_DELETE_LINK;\n\tsmc_llc_init_msg_hdr(&del_llc.hd, link->lgr, sizeof(del_llc));\n\tdel_llc.link_num = del_link_id;\n\tdel_llc.reason = htonl(SMC_LLC_DEL_LOST_PATH);\n\tdel_llc.hd.flags |= SMC_LLC_FLAG_DEL_LINK_ORDERLY;\n\tsmc_llc_enqueue(link, (union smc_llc_msg *)&del_llc);\n}\n\nstatic void smc_llc_process_cli_delete_link(struct smc_link_group *lgr)\n{\n\tstruct smc_link *lnk_del = NULL, *lnk_asym, *lnk;\n\tstruct smc_llc_msg_del_link *del_llc;\n\tstruct smc_llc_qentry *qentry;\n\tint active_links;\n\tint lnk_idx;\n\n\tqentry = smc_llc_flow_qentry_clr(&lgr->llc_flow_lcl);\n\tlnk = qentry->link;\n\tdel_llc = &qentry->msg.delete_link;\n\n\tif (del_llc->hd.flags & SMC_LLC_FLAG_DEL_LINK_ALL) {\n\t\tsmc_lgr_terminate_sched(lgr);\n\t\tgoto out;\n\t}\n\tdown_write(&lgr->llc_conf_mutex);\n\t \n\tfor (lnk_idx = 0; lnk_idx < SMC_LINKS_PER_LGR_MAX; lnk_idx++) {\n\t\tif (lgr->lnk[lnk_idx].link_id != del_llc->link_num)\n\t\t\tcontinue;\n\t\tlnk_del = &lgr->lnk[lnk_idx];\n\t\tbreak;\n\t}\n\tdel_llc->hd.flags |= SMC_LLC_FLAG_RESP;\n\tif (!lnk_del) {\n\t\t \n\t\tdel_llc->reason = htonl(SMC_LLC_DEL_NOLNK);\n\t\tsmc_llc_send_message(lnk, &qentry->msg);\n\t\tgoto out_unlock;\n\t}\n\tlnk_asym = smc_llc_find_asym_link(lgr);\n\n\tdel_llc->reason = 0;\n\tsmc_llc_send_message(lnk, &qentry->msg);  \n\n\tif (smc_link_downing(&lnk_del->state))\n\t\tsmc_switch_conns(lgr, lnk_del, false);\n\tsmcr_link_clear(lnk_del, true);\n\n\tactive_links = smc_llc_active_link_count(lgr);\n\tif (lnk_del == lnk_asym) {\n\t\t \n\t} else if (active_links == 1) {\n\t\tsmcr_lgr_set_type(lgr, SMC_LGR_SINGLE);\n\t} else if (!active_links) {\n\t\tsmcr_lgr_set_type(lgr, SMC_LGR_NONE);\n\t\tsmc_lgr_terminate_sched(lgr);\n\t}\nout_unlock:\n\tup_write(&lgr->llc_conf_mutex);\nout:\n\tkfree(qentry);\n}\n\n \nvoid smc_llc_send_link_delete_all(struct smc_link_group *lgr, bool ord, u32 rsn)\n{\n\tstruct smc_llc_msg_del_link delllc = {};\n\tint i;\n\n\tdelllc.hd.common.llc_type = SMC_LLC_DELETE_LINK;\n\tsmc_llc_init_msg_hdr(&delllc.hd, lgr, sizeof(delllc));\n\tif (ord)\n\t\tdelllc.hd.flags |= SMC_LLC_FLAG_DEL_LINK_ORDERLY;\n\tdelllc.hd.flags |= SMC_LLC_FLAG_DEL_LINK_ALL;\n\tdelllc.reason = htonl(rsn);\n\n\tfor (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {\n\t\tif (!smc_link_sendable(&lgr->lnk[i]))\n\t\t\tcontinue;\n\t\tif (!smc_llc_send_message_wait(&lgr->lnk[i], &delllc))\n\t\t\tbreak;\n\t}\n}\n\nstatic void smc_llc_process_srv_delete_link(struct smc_link_group *lgr)\n{\n\tstruct smc_llc_msg_del_link *del_llc;\n\tstruct smc_link *lnk, *lnk_del;\n\tstruct smc_llc_qentry *qentry;\n\tint active_links;\n\tint i;\n\n\tdown_write(&lgr->llc_conf_mutex);\n\tqentry = smc_llc_flow_qentry_clr(&lgr->llc_flow_lcl);\n\tlnk = qentry->link;\n\tdel_llc = &qentry->msg.delete_link;\n\n\tif (qentry->msg.delete_link.hd.flags & SMC_LLC_FLAG_DEL_LINK_ALL) {\n\t\t \n\t\tsmc_llc_send_link_delete_all(lgr, true, ntohl(\n\t\t\t\t\t      qentry->msg.delete_link.reason));\n\t\tsmc_lgr_terminate_sched(lgr);\n\t\tgoto out;\n\t}\n\t \n\tlnk_del = NULL;\n\tfor (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {\n\t\tif (lgr->lnk[i].link_id == del_llc->link_num) {\n\t\t\tlnk_del = &lgr->lnk[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!lnk_del)\n\t\tgoto out;  \n\n\tif (smc_link_downing(&lnk_del->state)) {\n\t\tif (smc_switch_conns(lgr, lnk_del, false))\n\t\t\tsmc_wr_tx_wait_no_pending_sends(lnk_del);\n\t}\n\tif (!list_empty(&lgr->list)) {\n\t\t \n\t\tif (!smc_llc_send_message(lnk, &qentry->msg)) {\n\t\t\tstruct smc_llc_qentry *qentry2;\n\n\t\t\tqentry2 = smc_llc_wait(lgr, lnk, SMC_LLC_WAIT_TIME,\n\t\t\t\t\t       SMC_LLC_DELETE_LINK);\n\t\t\tif (qentry2)\n\t\t\t\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\t\t}\n\t}\n\tsmcr_link_clear(lnk_del, true);\n\n\tactive_links = smc_llc_active_link_count(lgr);\n\tif (active_links == 1) {\n\t\tsmcr_lgr_set_type(lgr, SMC_LGR_SINGLE);\n\t} else if (!active_links) {\n\t\tsmcr_lgr_set_type(lgr, SMC_LGR_NONE);\n\t\tsmc_lgr_terminate_sched(lgr);\n\t}\n\n\tif (lgr->type == SMC_LGR_SINGLE && !list_empty(&lgr->list)) {\n\t\t \n\t\tsmc_llc_add_link_local(lnk);\n\t}\nout:\n\tup_write(&lgr->llc_conf_mutex);\n\tkfree(qentry);\n}\n\nstatic void smc_llc_delete_link_work(struct work_struct *work)\n{\n\tstruct smc_link_group *lgr = container_of(work, struct smc_link_group,\n\t\t\t\t\t\t  llc_del_link_work);\n\n\tif (list_empty(&lgr->list)) {\n\t\t \n\t\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\t\tgoto out;\n\t}\n\n\tif (lgr->role == SMC_CLNT)\n\t\tsmc_llc_process_cli_delete_link(lgr);\n\telse\n\t\tsmc_llc_process_srv_delete_link(lgr);\nout:\n\tsmc_llc_flow_stop(lgr, &lgr->llc_flow_lcl);\n}\n\n \nstatic void smc_llc_rmt_conf_rkey(struct smc_link_group *lgr)\n{\n\tstruct smc_llc_msg_confirm_rkey *llc;\n\tstruct smc_llc_qentry *qentry;\n\tstruct smc_link *link;\n\tint num_entries;\n\tint rk_idx;\n\tint i;\n\n\tqentry = lgr->llc_flow_rmt.qentry;\n\tllc = &qentry->msg.confirm_rkey;\n\tlink = qentry->link;\n\n\tnum_entries = llc->rtoken[0].num_rkeys;\n\tif (num_entries > SMC_LLC_RKEYS_PER_MSG)\n\t\tgoto out_err;\n\t \n\trk_idx = smc_rtoken_add(link,\n\t\t\t\tllc->rtoken[0].rmb_vaddr,\n\t\t\t\tllc->rtoken[0].rmb_key);\n\tif (rk_idx < 0)\n\t\tgoto out_err;\n\n\tfor (i = 1; i <= min_t(u8, num_entries, SMC_LLC_RKEYS_PER_MSG - 1); i++)\n\t\tsmc_rtoken_set2(lgr, rk_idx, llc->rtoken[i].link_id,\n\t\t\t\tllc->rtoken[i].rmb_vaddr,\n\t\t\t\tllc->rtoken[i].rmb_key);\n\t \n\tgoto out;\nout_err:\n\tllc->hd.flags |= SMC_LLC_FLAG_RKEY_NEG;\n\tllc->hd.flags |= SMC_LLC_FLAG_RKEY_RETRY;\nout:\n\tllc->hd.flags |= SMC_LLC_FLAG_RESP;\n\tsmc_llc_init_msg_hdr(&llc->hd, link->lgr, sizeof(*llc));\n\tsmc_llc_send_message(link, &qentry->msg);\n\tsmc_llc_flow_qentry_del(&lgr->llc_flow_rmt);\n}\n\n \nstatic void smc_llc_rmt_delete_rkey(struct smc_link_group *lgr)\n{\n\tstruct smc_llc_msg_delete_rkey *llc;\n\tstruct smc_llc_qentry *qentry;\n\tstruct smc_link *link;\n\tu8 err_mask = 0;\n\tint i, max;\n\n\tqentry = lgr->llc_flow_rmt.qentry;\n\tllc = &qentry->msg.delete_rkey;\n\tlink = qentry->link;\n\n\tif (lgr->smc_version == SMC_V2) {\n\t\tstruct smc_llc_msg_delete_rkey_v2 *llcv2;\n\n\t\tmemcpy(lgr->wr_rx_buf_v2, llc, sizeof(*llc));\n\t\tllcv2 = (struct smc_llc_msg_delete_rkey_v2 *)lgr->wr_rx_buf_v2;\n\t\tllcv2->num_inval_rkeys = 0;\n\n\t\tmax = min_t(u8, llcv2->num_rkeys, SMC_LLC_RKEYS_PER_MSG_V2);\n\t\tfor (i = 0; i < max; i++) {\n\t\t\tif (smc_rtoken_delete(link, llcv2->rkey[i]))\n\t\t\t\tllcv2->num_inval_rkeys++;\n\t\t}\n\t\tmemset(&llc->rkey[0], 0, sizeof(llc->rkey));\n\t\tmemset(&llc->reserved2, 0, sizeof(llc->reserved2));\n\t\tsmc_llc_init_msg_hdr(&llc->hd, link->lgr, sizeof(*llc));\n\t\tif (llcv2->num_inval_rkeys) {\n\t\t\tllc->hd.flags |= SMC_LLC_FLAG_RKEY_NEG;\n\t\t\tllc->err_mask = llcv2->num_inval_rkeys;\n\t\t}\n\t\tgoto finish;\n\t}\n\n\tmax = min_t(u8, llc->num_rkeys, SMC_LLC_DEL_RKEY_MAX);\n\tfor (i = 0; i < max; i++) {\n\t\tif (smc_rtoken_delete(link, llc->rkey[i]))\n\t\t\terr_mask |= 1 << (SMC_LLC_DEL_RKEY_MAX - 1 - i);\n\t}\n\tif (err_mask) {\n\t\tllc->hd.flags |= SMC_LLC_FLAG_RKEY_NEG;\n\t\tllc->err_mask = err_mask;\n\t}\nfinish:\n\tllc->hd.flags |= SMC_LLC_FLAG_RESP;\n\tsmc_llc_send_message(link, &qentry->msg);\n\tsmc_llc_flow_qentry_del(&lgr->llc_flow_rmt);\n}\n\nstatic void smc_llc_protocol_violation(struct smc_link_group *lgr, u8 type)\n{\n\tpr_warn_ratelimited(\"smc: SMC-R lg %*phN net %llu LLC protocol violation: \"\n\t\t\t    \"llc_type %d\\n\", SMC_LGR_ID_SIZE, &lgr->id,\n\t\t\t    lgr->net->net_cookie, type);\n\tsmc_llc_set_termination_rsn(lgr, SMC_LLC_DEL_PROT_VIOL);\n\tsmc_lgr_terminate_sched(lgr);\n}\n\n \nstatic void smc_llc_event_flush(struct smc_link_group *lgr)\n{\n\tstruct smc_llc_qentry *qentry, *q;\n\n\tspin_lock_bh(&lgr->llc_event_q_lock);\n\tlist_for_each_entry_safe(qentry, q, &lgr->llc_event_q, list) {\n\t\tlist_del_init(&qentry->list);\n\t\tkfree(qentry);\n\t}\n\tspin_unlock_bh(&lgr->llc_event_q_lock);\n}\n\nstatic void smc_llc_event_handler(struct smc_llc_qentry *qentry)\n{\n\tunion smc_llc_msg *llc = &qentry->msg;\n\tstruct smc_link *link = qentry->link;\n\tstruct smc_link_group *lgr = link->lgr;\n\n\tif (!smc_link_usable(link))\n\t\tgoto out;\n\n\tswitch (llc->raw.hdr.common.llc_type) {\n\tcase SMC_LLC_TEST_LINK:\n\t\tllc->test_link.hd.flags |= SMC_LLC_FLAG_RESP;\n\t\tsmc_llc_send_message(link, llc);\n\t\tbreak;\n\tcase SMC_LLC_ADD_LINK:\n\t\tif (list_empty(&lgr->list))\n\t\t\tgoto out;\t \n\t\tif (lgr->role == SMC_CLNT) {\n\t\t\tif (smc_llc_is_local_add_link(llc)) {\n\t\t\t\tif (lgr->llc_flow_lcl.type ==\n\t\t\t\t    SMC_LLC_FLOW_ADD_LINK)\n\t\t\t\t\tbreak;\t \n\t\t\t\tif (smc_llc_flow_start(&lgr->llc_flow_lcl,\n\t\t\t\t\t\t       qentry)) {\n\t\t\t\t\tschedule_work(&lgr->llc_add_link_work);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (lgr->llc_flow_lcl.type == SMC_LLC_FLOW_ADD_LINK &&\n\t\t\t    !lgr->llc_flow_lcl.qentry) {\n\t\t\t\t \n\t\t\t\tsmc_llc_flow_qentry_set(&lgr->llc_flow_lcl,\n\t\t\t\t\t\t\tqentry);\n\t\t\t\twake_up(&lgr->llc_msg_waiter);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (lgr->llc_flow_lcl.type ==\n\t\t\t\t\tSMC_LLC_FLOW_REQ_ADD_LINK) {\n\t\t\t\t \n\t\t\t\tlgr->llc_flow_lcl.type = SMC_LLC_FLOW_ADD_LINK;\n\t\t\t\tsmc_llc_flow_qentry_set(&lgr->llc_flow_lcl,\n\t\t\t\t\t\t\tqentry);\n\t\t\t\tschedule_work(&lgr->llc_add_link_work);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (smc_llc_flow_start(&lgr->llc_flow_lcl, qentry)) {\n\t\t\t\tschedule_work(&lgr->llc_add_link_work);\n\t\t\t}\n\t\t} else if (smc_llc_flow_start(&lgr->llc_flow_lcl, qentry)) {\n\t\t\t \n\t\t\tschedule_work(&lgr->llc_add_link_work);\n\t\t}\n\t\treturn;\n\tcase SMC_LLC_CONFIRM_LINK:\n\tcase SMC_LLC_ADD_LINK_CONT:\n\t\tif (lgr->llc_flow_lcl.type != SMC_LLC_FLOW_NONE) {\n\t\t\t \n\t\t\tsmc_llc_flow_qentry_set(&lgr->llc_flow_lcl, qentry);\n\t\t\twake_up(&lgr->llc_msg_waiter);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase SMC_LLC_DELETE_LINK:\n\t\tif (lgr->llc_flow_lcl.type == SMC_LLC_FLOW_ADD_LINK &&\n\t\t    !lgr->llc_flow_lcl.qentry) {\n\t\t\t \n\t\t\tsmc_llc_flow_qentry_set(&lgr->llc_flow_lcl, qentry);\n\t\t\twake_up(&lgr->llc_msg_waiter);\n\t\t} else if (smc_llc_flow_start(&lgr->llc_flow_lcl, qentry)) {\n\t\t\tschedule_work(&lgr->llc_del_link_work);\n\t\t}\n\t\treturn;\n\tcase SMC_LLC_CONFIRM_RKEY:\n\t\t \n\t\tif (smc_llc_flow_start(&lgr->llc_flow_rmt, qentry)) {\n\t\t\t \n\t\t\tsmc_llc_rmt_conf_rkey(lgr);\n\t\t\tsmc_llc_flow_stop(lgr, &lgr->llc_flow_rmt);\n\t\t}\n\t\treturn;\n\tcase SMC_LLC_CONFIRM_RKEY_CONT:\n\t\t \n\t\tbreak;\n\tcase SMC_LLC_DELETE_RKEY:\n\t\t \n\t\tif (smc_llc_flow_start(&lgr->llc_flow_rmt, qentry)) {\n\t\t\t \n\t\t\tsmc_llc_rmt_delete_rkey(lgr);\n\t\t\tsmc_llc_flow_stop(lgr, &lgr->llc_flow_rmt);\n\t\t}\n\t\treturn;\n\tcase SMC_LLC_REQ_ADD_LINK:\n\t\t \n\t\tif (lgr->role == SMC_CLNT &&\n\t\t    lgr->llc_flow_lcl.type == SMC_LLC_FLOW_REQ_ADD_LINK &&\n\t\t    (llc->raw.hdr.flags & SMC_LLC_FLAG_RESP)) {\n\t\t\tsmc_llc_flow_stop(link->lgr, &lgr->llc_flow_lcl);\n\t\t} else if (lgr->role == SMC_SERV) {\n\t\t\tif (smc_llc_flow_start(&lgr->llc_flow_lcl, qentry)) {\n\t\t\t\t \n\t\t\t\tlgr->llc_flow_lcl.type = SMC_LLC_FLOW_ADD_LINK;\n\t\t\t\tschedule_work(&lgr->llc_add_link_work);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsmc_llc_protocol_violation(lgr, llc->raw.hdr.common.type);\n\t\tbreak;\n\t}\nout:\n\tkfree(qentry);\n}\n\n \nstatic void smc_llc_event_work(struct work_struct *work)\n{\n\tstruct smc_link_group *lgr = container_of(work, struct smc_link_group,\n\t\t\t\t\t\t  llc_event_work);\n\tstruct smc_llc_qentry *qentry;\n\n\tif (!lgr->llc_flow_lcl.type && lgr->delayed_event) {\n\t\tqentry = lgr->delayed_event;\n\t\tlgr->delayed_event = NULL;\n\t\tif (smc_link_usable(qentry->link))\n\t\t\tsmc_llc_event_handler(qentry);\n\t\telse\n\t\t\tkfree(qentry);\n\t}\n\nagain:\n\tspin_lock_bh(&lgr->llc_event_q_lock);\n\tif (!list_empty(&lgr->llc_event_q)) {\n\t\tqentry = list_first_entry(&lgr->llc_event_q,\n\t\t\t\t\t  struct smc_llc_qentry, list);\n\t\tlist_del_init(&qentry->list);\n\t\tspin_unlock_bh(&lgr->llc_event_q_lock);\n\t\tsmc_llc_event_handler(qentry);\n\t\tgoto again;\n\t}\n\tspin_unlock_bh(&lgr->llc_event_q_lock);\n}\n\n \nstatic void smc_llc_rx_response(struct smc_link *link,\n\t\t\t\tstruct smc_llc_qentry *qentry)\n{\n\tenum smc_llc_flowtype flowtype = link->lgr->llc_flow_lcl.type;\n\tstruct smc_llc_flow *flow = &link->lgr->llc_flow_lcl;\n\tu8 llc_type = qentry->msg.raw.hdr.common.llc_type;\n\n\tswitch (llc_type) {\n\tcase SMC_LLC_TEST_LINK:\n\t\tif (smc_link_active(link))\n\t\t\tcomplete(&link->llc_testlink_resp);\n\t\tbreak;\n\tcase SMC_LLC_ADD_LINK:\n\tcase SMC_LLC_ADD_LINK_CONT:\n\tcase SMC_LLC_CONFIRM_LINK:\n\t\tif (flowtype != SMC_LLC_FLOW_ADD_LINK || flow->qentry)\n\t\t\tbreak;\t \n\t\tgoto assign;\n\tcase SMC_LLC_DELETE_LINK:\n\t\tif (flowtype != SMC_LLC_FLOW_DEL_LINK || flow->qentry)\n\t\t\tbreak;\t \n\t\tgoto assign;\n\tcase SMC_LLC_CONFIRM_RKEY:\n\tcase SMC_LLC_DELETE_RKEY:\n\t\tif (flowtype != SMC_LLC_FLOW_RKEY || flow->qentry)\n\t\t\tbreak;\t \n\t\tgoto assign;\n\tcase SMC_LLC_CONFIRM_RKEY_CONT:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tsmc_llc_protocol_violation(link->lgr,\n\t\t\t\t\t   qentry->msg.raw.hdr.common.type);\n\t\tbreak;\n\t}\n\tkfree(qentry);\n\treturn;\nassign:\n\t \n\tsmc_llc_flow_qentry_set(&link->lgr->llc_flow_lcl, qentry);\n\twake_up(&link->lgr->llc_msg_waiter);\n}\n\nstatic void smc_llc_enqueue(struct smc_link *link, union smc_llc_msg *llc)\n{\n\tstruct smc_link_group *lgr = link->lgr;\n\tstruct smc_llc_qentry *qentry;\n\tunsigned long flags;\n\n\tqentry = kmalloc(sizeof(*qentry), GFP_ATOMIC);\n\tif (!qentry)\n\t\treturn;\n\tqentry->link = link;\n\tINIT_LIST_HEAD(&qentry->list);\n\tmemcpy(&qentry->msg, llc, sizeof(union smc_llc_msg));\n\n\t \n\tif ((llc->raw.hdr.flags & SMC_LLC_FLAG_RESP) &&\n\t    llc->raw.hdr.common.llc_type != SMC_LLC_REQ_ADD_LINK) {\n\t\tsmc_llc_rx_response(link, qentry);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&lgr->llc_event_q_lock, flags);\n\tlist_add_tail(&qentry->list, &lgr->llc_event_q);\n\tspin_unlock_irqrestore(&lgr->llc_event_q_lock, flags);\n\tqueue_work(system_highpri_wq, &lgr->llc_event_work);\n}\n\n \nstatic void smc_llc_rx_handler(struct ib_wc *wc, void *buf)\n{\n\tstruct smc_link *link = (struct smc_link *)wc->qp->qp_context;\n\tunion smc_llc_msg *llc = buf;\n\n\tif (wc->byte_len < sizeof(*llc))\n\t\treturn;  \n\tif (!llc->raw.hdr.common.llc_version) {\n\t\tif (llc->raw.hdr.length != sizeof(*llc))\n\t\t\treturn;  \n\t} else {\n\t\tif (llc->raw.hdr.length_v2 < sizeof(*llc))\n\t\t\treturn;  \n\t}\n\n\tsmc_llc_enqueue(link, llc);\n}\n\n \n\nstatic void smc_llc_testlink_work(struct work_struct *work)\n{\n\tstruct smc_link *link = container_of(to_delayed_work(work),\n\t\t\t\t\t     struct smc_link, llc_testlink_wrk);\n\tunsigned long next_interval;\n\tunsigned long expire_time;\n\tu8 user_data[16] = { 0 };\n\tint rc;\n\n\tif (!smc_link_active(link))\n\t\treturn;\t\t \n\texpire_time = link->wr_rx_tstamp + link->llc_testlink_time;\n\tif (time_is_after_jiffies(expire_time)) {\n\t\tnext_interval = expire_time - jiffies;\n\t\tgoto out;\n\t}\n\treinit_completion(&link->llc_testlink_resp);\n\tsmc_llc_send_test_link(link, user_data);\n\t \n\trc = wait_for_completion_interruptible_timeout(&link->llc_testlink_resp,\n\t\t\t\t\t\t       SMC_LLC_WAIT_TIME);\n\tif (!smc_link_active(link))\n\t\treturn;\t\t \n\tif (rc <= 0) {\n\t\tsmcr_link_down_cond_sched(link);\n\t\treturn;\n\t}\n\tnext_interval = link->llc_testlink_time;\nout:\n\tschedule_delayed_work(&link->llc_testlink_wrk, next_interval);\n}\n\nvoid smc_llc_lgr_init(struct smc_link_group *lgr, struct smc_sock *smc)\n{\n\tstruct net *net = sock_net(smc->clcsock->sk);\n\n\tINIT_WORK(&lgr->llc_event_work, smc_llc_event_work);\n\tINIT_WORK(&lgr->llc_add_link_work, smc_llc_add_link_work);\n\tINIT_WORK(&lgr->llc_del_link_work, smc_llc_delete_link_work);\n\tINIT_LIST_HEAD(&lgr->llc_event_q);\n\tspin_lock_init(&lgr->llc_event_q_lock);\n\tspin_lock_init(&lgr->llc_flow_lock);\n\tinit_waitqueue_head(&lgr->llc_flow_waiter);\n\tinit_waitqueue_head(&lgr->llc_msg_waiter);\n\tinit_rwsem(&lgr->llc_conf_mutex);\n\tlgr->llc_testlink_time = READ_ONCE(net->smc.sysctl_smcr_testlink_time);\n}\n\n \nvoid smc_llc_lgr_clear(struct smc_link_group *lgr)\n{\n\tsmc_llc_event_flush(lgr);\n\twake_up_all(&lgr->llc_flow_waiter);\n\twake_up_all(&lgr->llc_msg_waiter);\n\tcancel_work_sync(&lgr->llc_event_work);\n\tcancel_work_sync(&lgr->llc_add_link_work);\n\tcancel_work_sync(&lgr->llc_del_link_work);\n\tif (lgr->delayed_event) {\n\t\tkfree(lgr->delayed_event);\n\t\tlgr->delayed_event = NULL;\n\t}\n}\n\nint smc_llc_link_init(struct smc_link *link)\n{\n\tinit_completion(&link->llc_testlink_resp);\n\tINIT_DELAYED_WORK(&link->llc_testlink_wrk, smc_llc_testlink_work);\n\treturn 0;\n}\n\nvoid smc_llc_link_active(struct smc_link *link)\n{\n\tpr_warn_ratelimited(\"smc: SMC-R lg %*phN net %llu link added: id %*phN, \"\n\t\t\t    \"peerid %*phN, ibdev %s, ibport %d\\n\",\n\t\t\t    SMC_LGR_ID_SIZE, &link->lgr->id,\n\t\t\t    link->lgr->net->net_cookie,\n\t\t\t    SMC_LGR_ID_SIZE, &link->link_uid,\n\t\t\t    SMC_LGR_ID_SIZE, &link->peer_link_uid,\n\t\t\t    link->smcibdev->ibdev->name, link->ibport);\n\tlink->state = SMC_LNK_ACTIVE;\n\tif (link->lgr->llc_testlink_time) {\n\t\tlink->llc_testlink_time = link->lgr->llc_testlink_time;\n\t\tschedule_delayed_work(&link->llc_testlink_wrk,\n\t\t\t\t      link->llc_testlink_time);\n\t}\n}\n\n \nvoid smc_llc_link_clear(struct smc_link *link, bool log)\n{\n\tif (log)\n\t\tpr_warn_ratelimited(\"smc: SMC-R lg %*phN net %llu link removed: id %*phN\"\n\t\t\t\t    \", peerid %*phN, ibdev %s, ibport %d\\n\",\n\t\t\t\t    SMC_LGR_ID_SIZE, &link->lgr->id,\n\t\t\t\t    link->lgr->net->net_cookie,\n\t\t\t\t    SMC_LGR_ID_SIZE, &link->link_uid,\n\t\t\t\t    SMC_LGR_ID_SIZE, &link->peer_link_uid,\n\t\t\t\t    link->smcibdev->ibdev->name, link->ibport);\n\tcomplete(&link->llc_testlink_resp);\n\tcancel_delayed_work_sync(&link->llc_testlink_wrk);\n}\n\n \nint smc_llc_do_confirm_rkey(struct smc_link *send_link,\n\t\t\t    struct smc_buf_desc *rmb_desc)\n{\n\tstruct smc_link_group *lgr = send_link->lgr;\n\tstruct smc_llc_qentry *qentry = NULL;\n\tint rc = 0;\n\n\trc = smc_llc_send_confirm_rkey(send_link, rmb_desc);\n\tif (rc)\n\t\tgoto out;\n\t \n\tqentry = smc_llc_wait(lgr, send_link, SMC_LLC_WAIT_TIME,\n\t\t\t      SMC_LLC_CONFIRM_RKEY);\n\tif (!qentry || (qentry->msg.raw.hdr.flags & SMC_LLC_FLAG_RKEY_NEG))\n\t\trc = -EFAULT;\nout:\n\tif (qentry)\n\t\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\treturn rc;\n}\n\n \nint smc_llc_do_delete_rkey(struct smc_link_group *lgr,\n\t\t\t   struct smc_buf_desc *rmb_desc)\n{\n\tstruct smc_llc_qentry *qentry = NULL;\n\tstruct smc_link *send_link;\n\tint rc = 0;\n\n\tsend_link = smc_llc_usable_link(lgr);\n\tif (!send_link)\n\t\treturn -ENOLINK;\n\n\t \n\trc = smc_llc_send_delete_rkey(send_link, rmb_desc);\n\tif (rc)\n\t\tgoto out;\n\t \n\tqentry = smc_llc_wait(lgr, send_link, SMC_LLC_WAIT_TIME,\n\t\t\t      SMC_LLC_DELETE_RKEY);\n\tif (!qentry || (qentry->msg.raw.hdr.flags & SMC_LLC_FLAG_RKEY_NEG))\n\t\trc = -EFAULT;\nout:\n\tif (qentry)\n\t\tsmc_llc_flow_qentry_del(&lgr->llc_flow_lcl);\n\treturn rc;\n}\n\nvoid smc_llc_link_set_uid(struct smc_link *link)\n{\n\t__be32 link_uid;\n\n\tlink_uid = htonl(*((u32 *)link->lgr->id) + link->link_id);\n\tmemcpy(link->link_uid, &link_uid, SMC_LGR_ID_SIZE);\n}\n\n \nvoid smc_llc_save_peer_uid(struct smc_llc_qentry *qentry)\n{\n\tmemcpy(qentry->link->peer_link_uid, qentry->msg.confirm_link.link_uid,\n\t       SMC_LGR_ID_SIZE);\n}\n\n \nint smc_llc_eval_conf_link(struct smc_llc_qentry *qentry,\n\t\t\t   enum smc_llc_reqresp type)\n{\n\tif (type == SMC_LLC_REQ) {\t \n\t\tqentry->link->link_id = qentry->msg.confirm_link.link_num;\n\t\tsmc_llc_link_set_uid(qentry->link);\n\t}\n\tif (!(qentry->msg.raw.hdr.flags & SMC_LLC_FLAG_NO_RMBE_EYEC))\n\t\treturn -ENOTSUPP;\n\treturn 0;\n}\n\n \n\nstatic struct smc_wr_rx_handler smc_llc_rx_handlers[] = {\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_CONFIRM_LINK\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_TEST_LINK\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_ADD_LINK\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_ADD_LINK_CONT\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_DELETE_LINK\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_CONFIRM_RKEY\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_CONFIRM_RKEY_CONT\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_DELETE_RKEY\n\t},\n\t \n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_CONFIRM_LINK_V2\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_TEST_LINK_V2\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_ADD_LINK_V2\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_DELETE_LINK_V2\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_REQ_ADD_LINK_V2\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_CONFIRM_RKEY_V2\n\t},\n\t{\n\t\t.handler\t= smc_llc_rx_handler,\n\t\t.type\t\t= SMC_LLC_DELETE_RKEY_V2\n\t},\n\t{\n\t\t.handler\t= NULL,\n\t}\n};\n\nint __init smc_llc_init(void)\n{\n\tstruct smc_wr_rx_handler *handler;\n\tint rc = 0;\n\n\tfor (handler = smc_llc_rx_handlers; handler->handler; handler++) {\n\t\tINIT_HLIST_NODE(&handler->list);\n\t\trc = smc_wr_rx_register_handler(handler);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}