{
  "module_name": "smc_core.h",
  "hash_id": "988def8b1b8deef9f802eebb238a1e13903ce0df17248a60e472dcf44d65501d",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_core.h",
  "human_readable_source": " \n \n\n#ifndef _SMC_CORE_H\n#define _SMC_CORE_H\n\n#include <linux/atomic.h>\n#include <linux/smc.h>\n#include <linux/pci.h>\n#include <rdma/ib_verbs.h>\n#include <net/genetlink.h>\n\n#include \"smc.h\"\n#include \"smc_ib.h\"\n\n#define SMC_RMBS_PER_LGR_MAX\t255\t \n#define SMC_CONN_PER_LGR_MIN\t16\t \n#define SMC_CONN_PER_LGR_MAX\t255\t \n#define SMC_CONN_PER_LGR_PREFER\t255\t \n\nstruct smc_lgr_list {\t\t\t \n\tstruct list_head\tlist;\n\tspinlock_t\t\tlock;\t \n\tu32\t\t\tnum;\t \n};\n\nenum smc_lgr_role {\t\t \n\tSMC_CLNT,\t \n\tSMC_SERV\t \n};\n\nenum smc_link_state {\t\t\t \n\tSMC_LNK_UNUSED,\t\t \n\tSMC_LNK_INACTIVE,\t \n\tSMC_LNK_ACTIVATING,\t \n\tSMC_LNK_ACTIVE,\t\t \n};\n\n#define SMC_WR_BUF_SIZE\t\t48\t \n#define SMC_WR_BUF_V2_SIZE\t8192\t \n\nstruct smc_wr_buf {\n\tu8\traw[SMC_WR_BUF_SIZE];\n};\n\nstruct smc_wr_v2_buf {\n\tu8\traw[SMC_WR_BUF_V2_SIZE];\n};\n\n#define SMC_WR_REG_MR_WAIT_TIME\t(5 * HZ) \n\nenum smc_wr_reg_state {\n\tPOSTED,\t\t \n\tCONFIRMED,\t \n\tFAILED\t\t \n};\n\nstruct smc_rdma_sge {\t\t\t\t \n\tstruct ib_sge\t\twr_tx_rdma_sge[SMC_IB_MAX_SEND_SGE];\n};\n\n#define SMC_MAX_RDMA_WRITES\t2\t\t \n\nstruct smc_rdma_sges {\t\t\t\t \n\tstruct smc_rdma_sge\ttx_rdma_sge[SMC_MAX_RDMA_WRITES];\n};\n\nstruct smc_rdma_wr {\t\t\t\t \n\tstruct ib_rdma_wr\twr_tx_rdma[SMC_MAX_RDMA_WRITES];\n};\n\n#define SMC_LGR_ID_SIZE\t\t4\n\nstruct smc_link {\n\tstruct smc_ib_device\t*smcibdev;\t \n\tu8\t\t\tibport;\t\t \n\tstruct ib_pd\t\t*roce_pd;\t \n\tstruct ib_qp\t\t*roce_qp;\t \n\tstruct ib_qp_attr\tqp_attr;\t \n\n\tstruct smc_wr_buf\t*wr_tx_bufs;\t \n\tstruct ib_send_wr\t*wr_tx_ibs;\t \n\tstruct ib_sge\t\t*wr_tx_sges;\t \n\tstruct smc_rdma_sges\t*wr_tx_rdma_sges; \n\tstruct smc_rdma_wr\t*wr_tx_rdmas;\t \n\tstruct smc_wr_tx_pend\t*wr_tx_pends;\t \n\tstruct completion\t*wr_tx_compl;\t \n\t \n\tstruct ib_send_wr\t*wr_tx_v2_ib;\t \n\tstruct ib_sge\t\t*wr_tx_v2_sge;\t \n\tstruct smc_wr_tx_pend\t*wr_tx_v2_pend;\t \n\tdma_addr_t\t\twr_tx_dma_addr;\t \n\tdma_addr_t\t\twr_tx_v2_dma_addr;  \n\tatomic_long_t\t\twr_tx_id;\t \n\tunsigned long\t\t*wr_tx_mask;\t \n\tu32\t\t\twr_tx_cnt;\t \n\twait_queue_head_t\twr_tx_wait;\t \n\tstruct {\n\t\tstruct percpu_ref\twr_tx_refs;\n\t} ____cacheline_aligned_in_smp;\n\tstruct completion\ttx_ref_comp;\n\n\tstruct smc_wr_buf\t*wr_rx_bufs;\t \n\tstruct ib_recv_wr\t*wr_rx_ibs;\t \n\tstruct ib_sge\t\t*wr_rx_sges;\t \n\t \n\tdma_addr_t\t\twr_rx_dma_addr;\t \n\tdma_addr_t\t\twr_rx_v2_dma_addr;  \n\tu64\t\t\twr_rx_id;\t \n\tu64\t\t\twr_rx_id_compl;  \n\tu32\t\t\twr_rx_cnt;\t \n\tunsigned long\t\twr_rx_tstamp;\t \n\twait_queue_head_t       wr_rx_empty_wait;  \n\n\tstruct ib_reg_wr\twr_reg;\t\t \n\twait_queue_head_t\twr_reg_wait;\t \n\tstruct {\n\t\tstruct percpu_ref\twr_reg_refs;\n\t} ____cacheline_aligned_in_smp;\n\tstruct completion\treg_ref_comp;\n\tenum smc_wr_reg_state\twr_reg_state;\t \n\n\tu8\t\t\tgid[SMC_GID_SIZE]; \n\tu8\t\t\tsgid_index;\t \n\tu32\t\t\tpeer_qpn;\t \n\tenum ib_mtu\t\tpath_mtu;\t \n\tenum ib_mtu\t\tpeer_mtu;\t \n\tu32\t\t\tpsn_initial;\t \n\tu32\t\t\tpeer_psn;\t \n\tu8\t\t\tpeer_mac[ETH_ALEN];\t \n\tu8\t\t\tpeer_gid[SMC_GID_SIZE];\t \n\tu8\t\t\tlink_id;\t \n\tu8\t\t\tlink_uid[SMC_LGR_ID_SIZE];  \n\tu8\t\t\tpeer_link_uid[SMC_LGR_ID_SIZE];  \n\tu8\t\t\tlink_idx;\t \n\tu8\t\t\tlink_is_asym;\t \n\tu8\t\t\tclearing : 1;\t \n\trefcount_t\t\trefcnt;\t\t \n\tstruct smc_link_group\t*lgr;\t\t \n\tstruct work_struct\tlink_down_wrk;\t \n\tchar\t\t\tibname[IB_DEVICE_NAME_MAX];  \n\tint\t\t\tndev_ifidx;  \n\n\tenum smc_link_state\tstate;\t\t \n\tstruct delayed_work\tllc_testlink_wrk;  \n\tstruct completion\tllc_testlink_resp;  \n\tint\t\t\tllc_testlink_time;  \n\tatomic_t\t\tconn_cnt;  \n};\n\n \n#define SMC_LINKS_PER_LGR_MAX\t3\n#define SMC_SINGLE_LINK\t\t0\n#define SMC_LINKS_ADD_LNK_MIN\t1\t \n#define SMC_LINKS_ADD_LNK_MAX\t2\t \n#define SMC_LINKS_PER_LGR_MAX_PREFER\t2\t \n\n \nstruct smc_buf_desc {\n\tstruct list_head\tlist;\n\tvoid\t\t\t*cpu_addr;\t \n\tstruct page\t\t*pages;\n\tint\t\t\tlen;\t\t \n\tu32\t\t\tused;\t\t \n\tunion {\n\t\tstruct {  \n\t\t\tstruct sg_table\tsgt[SMC_LINKS_PER_LGR_MAX];\n\t\t\t\t\t \n\t\t\tstruct ib_mr\t*mr[SMC_LINKS_PER_LGR_MAX];\n\t\t\t\t\t \n\t\t\tu32\t\torder;\t \n\n\t\t\tu8\t\tis_conf_rkey;\n\t\t\t\t\t \n\t\t\tu8\t\tis_reg_mr[SMC_LINKS_PER_LGR_MAX];\n\t\t\t\t\t \n\t\t\tu8\t\tis_map_ib[SMC_LINKS_PER_LGR_MAX];\n\t\t\t\t\t \n\t\t\tu8\t\tis_dma_need_sync;\n\t\t\tu8\t\tis_reg_err;\n\t\t\t\t\t \n\t\t\tu8\t\tis_vm;\n\t\t\t\t\t \n\t\t};\n\t\tstruct {  \n\t\t\tunsigned short\tsba_idx;\n\t\t\t\t\t \n\t\t\tu64\t\ttoken;\n\t\t\t\t\t \n\t\t\tdma_addr_t\tdma_addr;\n\t\t\t\t\t \n\t\t};\n\t};\n};\n\nstruct smc_rtoken {\t\t\t\t \n\tu64\t\t\tdma_addr;\n\tu32\t\t\trkey;\n};\n\n#define SMC_BUF_MIN_SIZE\t16384\t \n#define SMC_RMBE_SIZES\t\t16\t \n \n\nstruct smcd_dev;\n\nenum smc_lgr_type {\t\t\t\t \n\tSMC_LGR_NONE,\t\t\t \n\tSMC_LGR_SINGLE,\t\t\t \n\tSMC_LGR_SYMMETRIC,\t\t \n\tSMC_LGR_ASYMMETRIC_PEER,\t \n\tSMC_LGR_ASYMMETRIC_LOCAL,\t \n};\n\nenum smcr_buf_type {\t\t \n\tSMCR_PHYS_CONT_BUFS\t= 0,\n\tSMCR_VIRT_CONT_BUFS\t= 1,\n\tSMCR_MIXED_BUFS\t\t= 2,\n};\n\nenum smc_llc_flowtype {\n\tSMC_LLC_FLOW_NONE\t= 0,\n\tSMC_LLC_FLOW_ADD_LINK\t= 2,\n\tSMC_LLC_FLOW_DEL_LINK\t= 4,\n\tSMC_LLC_FLOW_REQ_ADD_LINK = 5,\n\tSMC_LLC_FLOW_RKEY\t= 6,\n};\n\nstruct smc_llc_qentry;\n\nstruct smc_llc_flow {\n\tenum smc_llc_flowtype type;\n\tstruct smc_llc_qentry *qentry;\n};\n\nstruct smc_link_group {\n\tstruct list_head\tlist;\n\tstruct rb_root\t\tconns_all;\t \n\trwlock_t\t\tconns_lock;\t \n\tunsigned int\t\tconns_num;\t \n\tunsigned short\t\tvlan_id;\t \n\n\tstruct list_head\tsndbufs[SMC_RMBE_SIZES]; \n\tstruct rw_semaphore\tsndbufs_lock;\t \n\tstruct list_head\trmbs[SMC_RMBE_SIZES];\t \n\tstruct rw_semaphore\trmbs_lock;\t \n\n\tu8\t\t\tid[SMC_LGR_ID_SIZE];\t \n\tstruct delayed_work\tfree_work;\t \n\tstruct work_struct\tterminate_work;\t \n\tstruct workqueue_struct\t*tx_wq;\t\t \n\tu8\t\t\tsync_err : 1;\t \n\tu8\t\t\tterminating : 1; \n\tu8\t\t\tfreeing : 1;\t \n\n\trefcount_t\t\trefcnt;\t\t \n\tbool\t\t\tis_smcd;\t \n\tu8\t\t\tsmc_version;\n\tu8\t\t\tnegotiated_eid[SMC_MAX_EID_LEN];\n\tu8\t\t\tpeer_os;\t \n\tu8\t\t\tpeer_smc_release;\n\tu8\t\t\tpeer_hostname[SMC_MAX_HOSTNAME_LEN];\n\tunion {\n\t\tstruct {  \n\t\t\tenum smc_lgr_role\trole;\n\t\t\t\t\t\t \n\t\t\tstruct smc_link\t\tlnk[SMC_LINKS_PER_LGR_MAX];\n\t\t\t\t\t\t \n\t\t\tstruct smc_wr_v2_buf\t*wr_rx_buf_v2;\n\t\t\t\t\t\t \n\t\t\tstruct smc_wr_v2_buf\t*wr_tx_buf_v2;\n\t\t\t\t\t\t \n\t\t\tchar\t\t\tpeer_systemid[SMC_SYSTEMID_LEN];\n\t\t\t\t\t\t \n\t\t\tstruct smc_rtoken\trtokens[SMC_RMBS_PER_LGR_MAX]\n\t\t\t\t\t\t[SMC_LINKS_PER_LGR_MAX];\n\t\t\t\t\t\t \n\t\t\tDECLARE_BITMAP(rtokens_used_mask, SMC_RMBS_PER_LGR_MAX);\n\t\t\t\t\t\t \n\t\t\tu8\t\t\tnext_link_id;\n\t\t\tenum smc_lgr_type\ttype;\n\t\t\tenum smcr_buf_type\tbuf_type;\n\t\t\t\t\t\t \n\t\t\tu8\t\t\tpnet_id[SMC_MAX_PNETID_LEN + 1];\n\t\t\t\t\t\t \n\t\t\tstruct list_head\tllc_event_q;\n\t\t\t\t\t\t \n\t\t\tspinlock_t\t\tllc_event_q_lock;\n\t\t\t\t\t\t \n\t\t\tstruct rw_semaphore\tllc_conf_mutex;\n\t\t\t\t\t\t \n\t\t\tstruct work_struct\tllc_add_link_work;\n\t\t\tstruct work_struct\tllc_del_link_work;\n\t\t\tstruct work_struct\tllc_event_work;\n\t\t\t\t\t\t \n\t\t\twait_queue_head_t\tllc_flow_waiter;\n\t\t\t\t\t\t \n\t\t\twait_queue_head_t\tllc_msg_waiter;\n\t\t\t\t\t\t \n\t\t\tstruct smc_llc_flow\tllc_flow_lcl;\n\t\t\t\t\t\t \n\t\t\tstruct smc_llc_flow\tllc_flow_rmt;\n\t\t\t\t\t\t \n\t\t\tstruct smc_llc_qentry\t*delayed_event;\n\t\t\t\t\t\t \n\t\t\tspinlock_t\t\tllc_flow_lock;\n\t\t\t\t\t\t \n\t\t\tint\t\t\tllc_testlink_time;\n\t\t\t\t\t\t \n\t\t\tu32\t\t\tllc_termination_rsn;\n\t\t\t\t\t\t \n\t\t\tu8\t\t\tnexthop_mac[ETH_ALEN];\n\t\t\tu8\t\t\tuses_gateway;\n\t\t\t__be32\t\t\tsaddr;\n\t\t\t\t\t\t \n\t\t\tstruct net\t\t*net;\n\t\t\tu8\t\t\tmax_conns;\n\t\t\t\t\t\t \n\t\t\tu8\t\t\tmax_links;\n\t\t\t\t\t\t \n\t\t};\n\t\tstruct {  \n\t\t\tu64\t\t\tpeer_gid;\n\t\t\t\t\t\t \n\t\t\tstruct smcd_dev\t\t*smcd;\n\t\t\t\t\t\t \n\t\t\tu8\t\t\tpeer_shutdown : 1;\n\t\t\t\t\t\t \n\t\t};\n\t};\n};\n\nstruct smc_clc_msg_local;\n\n#define GID_LIST_SIZE\t2\n\nstruct smc_gidlist {\n\tu8\t\t\tlen;\n\tu8\t\t\tlist[GID_LIST_SIZE][SMC_GID_SIZE];\n};\n\nstruct smc_init_info_smcrv2 {\n\t \n\t__be32\t\t\tsaddr;\n\tstruct sock\t\t*clc_sk;\n\t__be32\t\t\tdaddr;\n\n\t \n\tstruct smc_ib_device\t*ib_dev_v2;\n\tu8\t\t\tib_port_v2;\n\tu8\t\t\tib_gid_v2[SMC_GID_SIZE];\n\n\t \n\tu8\t\t\tuses_gateway;\n\tu8\t\t\tnexthop_mac[ETH_ALEN];\n\n\tstruct smc_gidlist\tgidlist;\n};\n\nstruct smc_init_info {\n\tu8\t\t\tis_smcd;\n\tu8\t\t\tsmc_type_v1;\n\tu8\t\t\tsmc_type_v2;\n\tu8\t\t\trelease_nr;\n\tu8\t\t\tmax_conns;\n\tu8\t\t\tmax_links;\n\tu8\t\t\tfirst_contact_peer;\n\tu8\t\t\tfirst_contact_local;\n\tunsigned short\t\tvlan_id;\n\tu32\t\t\trc;\n\tu8\t\t\tnegotiated_eid[SMC_MAX_EID_LEN];\n\t \n\tu8\t\t\tsmcr_version;\n\tu8\t\t\tcheck_smcrv2;\n\tu8\t\t\tpeer_gid[SMC_GID_SIZE];\n\tu8\t\t\tpeer_mac[ETH_ALEN];\n\tu8\t\t\tpeer_systemid[SMC_SYSTEMID_LEN];\n\tstruct smc_ib_device\t*ib_dev;\n\tu8\t\t\tib_gid[SMC_GID_SIZE];\n\tu8\t\t\tib_port;\n\tu32\t\t\tib_clcqpn;\n\tstruct smc_init_info_smcrv2 smcrv2;\n\t \n\tu64\t\t\tism_peer_gid[SMC_MAX_ISM_DEVS + 1];\n\tstruct smcd_dev\t\t*ism_dev[SMC_MAX_ISM_DEVS + 1];\n\tu16\t\t\tism_chid[SMC_MAX_ISM_DEVS + 1];\n\tu8\t\t\tism_offered_cnt;  \n\tu8\t\t\tism_selected;     \n\tu8\t\t\tsmcd_version;\n};\n\n \nstatic inline struct smc_connection *smc_lgr_find_conn(\n\tu32 token, struct smc_link_group *lgr)\n{\n\tstruct smc_connection *res = NULL;\n\tstruct rb_node *node;\n\n\tnode = lgr->conns_all.rb_node;\n\twhile (node) {\n\t\tstruct smc_connection *cur = rb_entry(node,\n\t\t\t\t\tstruct smc_connection, alert_node);\n\n\t\tif (cur->alert_token_local > token) {\n\t\t\tnode = node->rb_left;\n\t\t} else {\n\t\t\tif (cur->alert_token_local < token) {\n\t\t\t\tnode = node->rb_right;\n\t\t\t} else {\n\t\t\t\tres = cur;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic inline bool smc_conn_lgr_valid(struct smc_connection *conn)\n{\n\treturn conn->lgr && conn->alert_token_local;\n}\n\n \nstatic inline bool smc_link_usable(struct smc_link *lnk)\n{\n\tif (lnk->state == SMC_LNK_UNUSED || lnk->state == SMC_LNK_INACTIVE)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic inline bool smc_link_sendable(struct smc_link *lnk)\n{\n\treturn smc_link_usable(lnk) &&\n\t\tlnk->qp_attr.cur_qp_state == IB_QPS_RTS;\n}\n\nstatic inline bool smc_link_active(struct smc_link *lnk)\n{\n\treturn lnk->state == SMC_LNK_ACTIVE;\n}\n\nstatic inline void smc_gid_be16_convert(__u8 *buf, u8 *gid_raw)\n{\n\tsprintf(buf, \"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\",\n\t\tbe16_to_cpu(((__be16 *)gid_raw)[0]),\n\t\tbe16_to_cpu(((__be16 *)gid_raw)[1]),\n\t\tbe16_to_cpu(((__be16 *)gid_raw)[2]),\n\t\tbe16_to_cpu(((__be16 *)gid_raw)[3]),\n\t\tbe16_to_cpu(((__be16 *)gid_raw)[4]),\n\t\tbe16_to_cpu(((__be16 *)gid_raw)[5]),\n\t\tbe16_to_cpu(((__be16 *)gid_raw)[6]),\n\t\tbe16_to_cpu(((__be16 *)gid_raw)[7]));\n}\n\nstruct smc_pci_dev {\n\t__u32\t\tpci_fid;\n\t__u16\t\tpci_pchid;\n\t__u16\t\tpci_vendor;\n\t__u16\t\tpci_device;\n\t__u8\t\tpci_id[SMC_PCI_ID_STR_LEN];\n};\n\nstatic inline void smc_set_pci_values(struct pci_dev *pci_dev,\n\t\t\t\t      struct smc_pci_dev *smc_dev)\n{\n\tsmc_dev->pci_vendor = pci_dev->vendor;\n\tsmc_dev->pci_device = pci_dev->device;\n\tsnprintf(smc_dev->pci_id, sizeof(smc_dev->pci_id), \"%s\",\n\t\t pci_name(pci_dev));\n#if IS_ENABLED(CONFIG_S390)\n\t{  \n\tstruct zpci_dev *zdev;\n\n\tzdev = to_zpci(pci_dev);\n\tsmc_dev->pci_fid = zdev->fid;\n\tsmc_dev->pci_pchid = zdev->pchid;\n\t}\n#endif\n}\n\nstruct smc_sock;\nstruct smc_clc_msg_accept_confirm;\n\nvoid smc_lgr_cleanup_early(struct smc_link_group *lgr);\nvoid smc_lgr_terminate_sched(struct smc_link_group *lgr);\nvoid smc_lgr_hold(struct smc_link_group *lgr);\nvoid smc_lgr_put(struct smc_link_group *lgr);\nvoid smcr_port_add(struct smc_ib_device *smcibdev, u8 ibport);\nvoid smcr_port_err(struct smc_ib_device *smcibdev, u8 ibport);\nvoid smc_smcd_terminate(struct smcd_dev *dev, u64 peer_gid,\n\t\t\tunsigned short vlan);\nvoid smc_smcd_terminate_all(struct smcd_dev *dev);\nvoid smc_smcr_terminate_all(struct smc_ib_device *smcibdev);\nint smc_buf_create(struct smc_sock *smc, bool is_smcd);\nint smc_uncompress_bufsize(u8 compressed);\nint smc_rmb_rtoken_handling(struct smc_connection *conn, struct smc_link *link,\n\t\t\t    struct smc_clc_msg_accept_confirm *clc);\nint smc_rtoken_add(struct smc_link *lnk, __be64 nw_vaddr, __be32 nw_rkey);\nint smc_rtoken_delete(struct smc_link *lnk, __be32 nw_rkey);\nvoid smc_rtoken_set(struct smc_link_group *lgr, int link_idx, int link_idx_new,\n\t\t    __be32 nw_rkey_known, __be64 nw_vaddr, __be32 nw_rkey);\nvoid smc_rtoken_set2(struct smc_link_group *lgr, int rtok_idx, int link_id,\n\t\t     __be64 nw_vaddr, __be32 nw_rkey);\nvoid smc_sndbuf_sync_sg_for_device(struct smc_connection *conn);\nvoid smc_rmb_sync_sg_for_cpu(struct smc_connection *conn);\nint smc_vlan_by_tcpsk(struct socket *clcsock, struct smc_init_info *ini);\n\nvoid smc_conn_free(struct smc_connection *conn);\nint smc_conn_create(struct smc_sock *smc, struct smc_init_info *ini);\nint smc_core_init(void);\nvoid smc_core_exit(void);\n\nint smcr_link_init(struct smc_link_group *lgr, struct smc_link *lnk,\n\t\t   u8 link_idx, struct smc_init_info *ini);\nvoid smcr_link_clear(struct smc_link *lnk, bool log);\nvoid smcr_link_hold(struct smc_link *lnk);\nvoid smcr_link_put(struct smc_link *lnk);\nvoid smc_switch_link_and_count(struct smc_connection *conn,\n\t\t\t       struct smc_link *to_lnk);\nint smcr_buf_map_lgr(struct smc_link *lnk);\nint smcr_buf_reg_lgr(struct smc_link *lnk);\nvoid smcr_lgr_set_type(struct smc_link_group *lgr, enum smc_lgr_type new_type);\nvoid smcr_lgr_set_type_asym(struct smc_link_group *lgr,\n\t\t\t    enum smc_lgr_type new_type, int asym_lnk_idx);\nint smcr_link_reg_buf(struct smc_link *link, struct smc_buf_desc *rmb_desc);\nstruct smc_link *smc_switch_conns(struct smc_link_group *lgr,\n\t\t\t\t  struct smc_link *from_lnk, bool is_dev_err);\nvoid smcr_link_down_cond(struct smc_link *lnk);\nvoid smcr_link_down_cond_sched(struct smc_link *lnk);\nint smc_nl_get_sys_info(struct sk_buff *skb, struct netlink_callback *cb);\nint smcr_nl_get_lgr(struct sk_buff *skb, struct netlink_callback *cb);\nint smcr_nl_get_link(struct sk_buff *skb, struct netlink_callback *cb);\nint smcd_nl_get_lgr(struct sk_buff *skb, struct netlink_callback *cb);\n\nstatic inline struct smc_link_group *smc_get_lgr(struct smc_link *link)\n{\n\treturn link->lgr;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}