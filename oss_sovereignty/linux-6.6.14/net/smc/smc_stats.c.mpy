{
  "module_name": "smc_stats.c",
  "hash_id": "1d7f80d870c192a725d90b960760d097b584e11c9f9f0c1b7fee73d98ad558f0",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_stats.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/ctype.h>\n#include <linux/smc.h>\n#include <net/genetlink.h>\n#include <net/sock.h>\n#include \"smc_netlink.h\"\n#include \"smc_stats.h\"\n\nint smc_stats_init(struct net *net)\n{\n\tnet->smc.fback_rsn = kzalloc(sizeof(*net->smc.fback_rsn), GFP_KERNEL);\n\tif (!net->smc.fback_rsn)\n\t\tgoto err_fback;\n\tnet->smc.smc_stats = alloc_percpu(struct smc_stats);\n\tif (!net->smc.smc_stats)\n\t\tgoto err_stats;\n\tmutex_init(&net->smc.mutex_fback_rsn);\n\treturn 0;\n\nerr_stats:\n\tkfree(net->smc.fback_rsn);\nerr_fback:\n\treturn -ENOMEM;\n}\n\nvoid smc_stats_exit(struct net *net)\n{\n\tkfree(net->smc.fback_rsn);\n\tif (net->smc.smc_stats)\n\t\tfree_percpu(net->smc.smc_stats);\n}\n\nstatic int smc_nl_fill_stats_rmb_data(struct sk_buff *skb,\n\t\t\t\t      struct smc_stats *stats, int tech,\n\t\t\t\t      int type)\n{\n\tstruct smc_stats_rmbcnt *stats_rmb_cnt;\n\tstruct nlattr *attrs;\n\n\tif (type == SMC_NLA_STATS_T_TX_RMB_STATS)\n\t\tstats_rmb_cnt = &stats->smc[tech].rmb_tx;\n\telse\n\t\tstats_rmb_cnt = &stats->smc[tech].rmb_rx;\n\n\tattrs = nla_nest_start(skb, type);\n\tif (!attrs)\n\t\tgoto errout;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_RMB_REUSE_CNT,\n\t\t\t      stats_rmb_cnt->reuse_cnt,\n\t\t\t      SMC_NLA_STATS_RMB_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_RMB_SIZE_SM_PEER_CNT,\n\t\t\t      stats_rmb_cnt->buf_size_small_peer_cnt,\n\t\t\t      SMC_NLA_STATS_RMB_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_RMB_SIZE_SM_CNT,\n\t\t\t      stats_rmb_cnt->buf_size_small_cnt,\n\t\t\t      SMC_NLA_STATS_RMB_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_RMB_FULL_PEER_CNT,\n\t\t\t      stats_rmb_cnt->buf_full_peer_cnt,\n\t\t\t      SMC_NLA_STATS_RMB_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_RMB_FULL_CNT,\n\t\t\t      stats_rmb_cnt->buf_full_cnt,\n\t\t\t      SMC_NLA_STATS_RMB_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_RMB_ALLOC_CNT,\n\t\t\t      stats_rmb_cnt->alloc_cnt,\n\t\t\t      SMC_NLA_STATS_RMB_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_RMB_DGRADE_CNT,\n\t\t\t      stats_rmb_cnt->dgrade_cnt,\n\t\t\t      SMC_NLA_STATS_RMB_PAD))\n\t\tgoto errattr;\n\n\tnla_nest_end(skb, attrs);\n\treturn 0;\n\nerrattr:\n\tnla_nest_cancel(skb, attrs);\nerrout:\n\treturn -EMSGSIZE;\n}\n\nstatic int smc_nl_fill_stats_bufsize_data(struct sk_buff *skb,\n\t\t\t\t\t  struct smc_stats *stats, int tech,\n\t\t\t\t\t  int type)\n{\n\tstruct smc_stats_memsize *stats_pload;\n\tstruct nlattr *attrs;\n\n\tif (type == SMC_NLA_STATS_T_TXPLOAD_SIZE)\n\t\tstats_pload = &stats->smc[tech].tx_pd;\n\telse if (type == SMC_NLA_STATS_T_RXPLOAD_SIZE)\n\t\tstats_pload = &stats->smc[tech].rx_pd;\n\telse if (type == SMC_NLA_STATS_T_TX_RMB_SIZE)\n\t\tstats_pload = &stats->smc[tech].tx_rmbsize;\n\telse if (type == SMC_NLA_STATS_T_RX_RMB_SIZE)\n\t\tstats_pload = &stats->smc[tech].rx_rmbsize;\n\telse\n\t\tgoto errout;\n\n\tattrs = nla_nest_start(skb, type);\n\tif (!attrs)\n\t\tgoto errout;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_PLOAD_8K,\n\t\t\t      stats_pload->buf[SMC_BUF_8K],\n\t\t\t      SMC_NLA_STATS_PLOAD_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_PLOAD_16K,\n\t\t\t      stats_pload->buf[SMC_BUF_16K],\n\t\t\t      SMC_NLA_STATS_PLOAD_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_PLOAD_32K,\n\t\t\t      stats_pload->buf[SMC_BUF_32K],\n\t\t\t      SMC_NLA_STATS_PLOAD_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_PLOAD_64K,\n\t\t\t      stats_pload->buf[SMC_BUF_64K],\n\t\t\t      SMC_NLA_STATS_PLOAD_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_PLOAD_128K,\n\t\t\t      stats_pload->buf[SMC_BUF_128K],\n\t\t\t      SMC_NLA_STATS_PLOAD_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_PLOAD_256K,\n\t\t\t      stats_pload->buf[SMC_BUF_256K],\n\t\t\t      SMC_NLA_STATS_PLOAD_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_PLOAD_512K,\n\t\t\t      stats_pload->buf[SMC_BUF_512K],\n\t\t\t      SMC_NLA_STATS_PLOAD_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_PLOAD_1024K,\n\t\t\t      stats_pload->buf[SMC_BUF_1024K],\n\t\t\t      SMC_NLA_STATS_PLOAD_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_PLOAD_G_1024K,\n\t\t\t      stats_pload->buf[SMC_BUF_G_1024K],\n\t\t\t      SMC_NLA_STATS_PLOAD_PAD))\n\t\tgoto errattr;\n\n\tnla_nest_end(skb, attrs);\n\treturn 0;\n\nerrattr:\n\tnla_nest_cancel(skb, attrs);\nerrout:\n\treturn -EMSGSIZE;\n}\n\nstatic int smc_nl_fill_stats_tech_data(struct sk_buff *skb,\n\t\t\t\t       struct smc_stats *stats, int tech)\n{\n\tstruct smc_stats_tech *smc_tech;\n\tstruct nlattr *attrs;\n\n\tsmc_tech = &stats->smc[tech];\n\tif (tech == SMC_TYPE_D)\n\t\tattrs = nla_nest_start(skb, SMC_NLA_STATS_SMCD_TECH);\n\telse\n\t\tattrs = nla_nest_start(skb, SMC_NLA_STATS_SMCR_TECH);\n\n\tif (!attrs)\n\t\tgoto errout;\n\tif (smc_nl_fill_stats_rmb_data(skb, stats, tech,\n\t\t\t\t       SMC_NLA_STATS_T_TX_RMB_STATS))\n\t\tgoto errattr;\n\tif (smc_nl_fill_stats_rmb_data(skb, stats, tech,\n\t\t\t\t       SMC_NLA_STATS_T_RX_RMB_STATS))\n\t\tgoto errattr;\n\tif (smc_nl_fill_stats_bufsize_data(skb, stats, tech,\n\t\t\t\t\t   SMC_NLA_STATS_T_TXPLOAD_SIZE))\n\t\tgoto errattr;\n\tif (smc_nl_fill_stats_bufsize_data(skb, stats, tech,\n\t\t\t\t\t   SMC_NLA_STATS_T_RXPLOAD_SIZE))\n\t\tgoto errattr;\n\tif (smc_nl_fill_stats_bufsize_data(skb, stats, tech,\n\t\t\t\t\t   SMC_NLA_STATS_T_TX_RMB_SIZE))\n\t\tgoto errattr;\n\tif (smc_nl_fill_stats_bufsize_data(skb, stats, tech,\n\t\t\t\t\t   SMC_NLA_STATS_T_RX_RMB_SIZE))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_CLNT_V1_SUCC,\n\t\t\t      smc_tech->clnt_v1_succ_cnt,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_CLNT_V2_SUCC,\n\t\t\t      smc_tech->clnt_v2_succ_cnt,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_SRV_V1_SUCC,\n\t\t\t      smc_tech->srv_v1_succ_cnt,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_SRV_V2_SUCC,\n\t\t\t      smc_tech->srv_v2_succ_cnt,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_RX_BYTES,\n\t\t\t      smc_tech->rx_bytes,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_TX_BYTES,\n\t\t\t      smc_tech->tx_bytes,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_RX_CNT,\n\t\t\t      smc_tech->rx_cnt,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_TX_CNT,\n\t\t\t      smc_tech->tx_cnt,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_SENDPAGE_CNT,\n\t\t\t      0,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_CORK_CNT,\n\t\t\t      smc_tech->cork_cnt,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_NDLY_CNT,\n\t\t\t      smc_tech->ndly_cnt,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_SPLICE_CNT,\n\t\t\t      smc_tech->splice_cnt,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_T_URG_DATA_CNT,\n\t\t\t      smc_tech->urg_data_cnt,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\n\tnla_nest_end(skb, attrs);\n\treturn 0;\n\nerrattr:\n\tnla_nest_cancel(skb, attrs);\nerrout:\n\treturn -EMSGSIZE;\n}\n\nint smc_nl_get_stats(struct sk_buff *skb,\n\t\t     struct netlink_callback *cb)\n{\n\tstruct smc_nl_dmp_ctx *cb_ctx = smc_nl_dmp_ctx(cb);\n\tstruct net *net = sock_net(skb->sk);\n\tstruct smc_stats *stats;\n\tstruct nlattr *attrs;\n\tint cpu, i, size;\n\tvoid *nlh;\n\tu64 *src;\n\tu64 *sum;\n\n\tif (cb_ctx->pos[0])\n\t\tgoto errmsg;\n\tnlh = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &smc_gen_nl_family, NLM_F_MULTI,\n\t\t\t  SMC_NETLINK_GET_STATS);\n\tif (!nlh)\n\t\tgoto errmsg;\n\n\tattrs = nla_nest_start(skb, SMC_GEN_STATS);\n\tif (!attrs)\n\t\tgoto errnest;\n\tstats = kzalloc(sizeof(*stats), GFP_KERNEL);\n\tif (!stats)\n\t\tgoto erralloc;\n\tsize = sizeof(*stats) / sizeof(u64);\n\tfor_each_possible_cpu(cpu) {\n\t\tsrc = (u64 *)per_cpu_ptr(net->smc.smc_stats, cpu);\n\t\tsum = (u64 *)stats;\n\t\tfor (i = 0; i < size; i++)\n\t\t\t*(sum++) += *(src++);\n\t}\n\tif (smc_nl_fill_stats_tech_data(skb, stats, SMC_TYPE_D))\n\t\tgoto errattr;\n\tif (smc_nl_fill_stats_tech_data(skb, stats, SMC_TYPE_R))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_CLNT_HS_ERR_CNT,\n\t\t\t      stats->clnt_hshake_err_cnt,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\tif (nla_put_u64_64bit(skb, SMC_NLA_STATS_SRV_HS_ERR_CNT,\n\t\t\t      stats->srv_hshake_err_cnt,\n\t\t\t      SMC_NLA_STATS_PAD))\n\t\tgoto errattr;\n\n\tnla_nest_end(skb, attrs);\n\tgenlmsg_end(skb, nlh);\n\tcb_ctx->pos[0] = 1;\n\tkfree(stats);\n\treturn skb->len;\n\nerrattr:\n\tkfree(stats);\nerralloc:\n\tnla_nest_cancel(skb, attrs);\nerrnest:\n\tgenlmsg_cancel(skb, nlh);\nerrmsg:\n\treturn skb->len;\n}\n\nstatic int smc_nl_get_fback_details(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb, int pos,\n\t\t\t\t    bool is_srv)\n{\n\tstruct smc_nl_dmp_ctx *cb_ctx = smc_nl_dmp_ctx(cb);\n\tstruct net *net = sock_net(skb->sk);\n\tint cnt_reported = cb_ctx->pos[2];\n\tstruct smc_stats_fback *trgt_arr;\n\tstruct nlattr *attrs;\n\tint rc = 0;\n\tvoid *nlh;\n\n\tif (is_srv)\n\t\ttrgt_arr = &net->smc.fback_rsn->srv[0];\n\telse\n\t\ttrgt_arr = &net->smc.fback_rsn->clnt[0];\n\tif (!trgt_arr[pos].fback_code)\n\t\treturn -ENODATA;\n\tnlh = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &smc_gen_nl_family, NLM_F_MULTI,\n\t\t\t  SMC_NETLINK_GET_FBACK_STATS);\n\tif (!nlh)\n\t\tgoto errmsg;\n\tattrs = nla_nest_start(skb, SMC_GEN_FBACK_STATS);\n\tif (!attrs)\n\t\tgoto errout;\n\tif (nla_put_u8(skb, SMC_NLA_FBACK_STATS_TYPE, is_srv))\n\t\tgoto errattr;\n\tif (!cnt_reported) {\n\t\tif (nla_put_u64_64bit(skb, SMC_NLA_FBACK_STATS_SRV_CNT,\n\t\t\t\t      net->smc.fback_rsn->srv_fback_cnt,\n\t\t\t\t      SMC_NLA_FBACK_STATS_PAD))\n\t\t\tgoto errattr;\n\t\tif (nla_put_u64_64bit(skb, SMC_NLA_FBACK_STATS_CLNT_CNT,\n\t\t\t\t      net->smc.fback_rsn->clnt_fback_cnt,\n\t\t\t\t      SMC_NLA_FBACK_STATS_PAD))\n\t\t\tgoto errattr;\n\t\tcnt_reported = 1;\n\t}\n\n\tif (nla_put_u32(skb, SMC_NLA_FBACK_STATS_RSN_CODE,\n\t\t\ttrgt_arr[pos].fback_code))\n\t\tgoto errattr;\n\tif (nla_put_u16(skb, SMC_NLA_FBACK_STATS_RSN_CNT,\n\t\t\ttrgt_arr[pos].count))\n\t\tgoto errattr;\n\n\tcb_ctx->pos[2] = cnt_reported;\n\tnla_nest_end(skb, attrs);\n\tgenlmsg_end(skb, nlh);\n\treturn rc;\n\nerrattr:\n\tnla_nest_cancel(skb, attrs);\nerrout:\n\tgenlmsg_cancel(skb, nlh);\nerrmsg:\n\treturn -EMSGSIZE;\n}\n\nint smc_nl_get_fback_stats(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct smc_nl_dmp_ctx *cb_ctx = smc_nl_dmp_ctx(cb);\n\tstruct net *net = sock_net(skb->sk);\n\tint rc_srv = 0, rc_clnt = 0, k;\n\tint skip_serv = cb_ctx->pos[1];\n\tint snum = cb_ctx->pos[0];\n\tbool is_srv = true;\n\n\tmutex_lock(&net->smc.mutex_fback_rsn);\n\tfor (k = 0; k < SMC_MAX_FBACK_RSN_CNT; k++) {\n\t\tif (k < snum)\n\t\t\tcontinue;\n\t\tif (!skip_serv) {\n\t\t\trc_srv = smc_nl_get_fback_details(skb, cb, k, is_srv);\n\t\t\tif (rc_srv && rc_srv != -ENODATA)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tskip_serv = 0;\n\t\t}\n\t\trc_clnt = smc_nl_get_fback_details(skb, cb, k, !is_srv);\n\t\tif (rc_clnt && rc_clnt != -ENODATA) {\n\t\t\tskip_serv = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (rc_clnt == -ENODATA && rc_srv == -ENODATA)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&net->smc.mutex_fback_rsn);\n\tcb_ctx->pos[1] = skip_serv;\n\tcb_ctx->pos[0] = k;\n\treturn skb->len;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}