{
  "module_name": "smc_clc.h",
  "hash_id": "ed33f76514dfd75eb80fcbe846d1df59d2fa044cd2916e2a2accecc73076e3e4",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_clc.h",
  "human_readable_source": " \n \n\n#ifndef _SMC_CLC_H\n#define _SMC_CLC_H\n\n#include <rdma/ib_verbs.h>\n#include <linux/smc.h>\n\n#include \"smc.h\"\n#include \"smc_netlink.h\"\n\n#define SMC_CLC_PROPOSAL\t0x01\n#define SMC_CLC_ACCEPT\t\t0x02\n#define SMC_CLC_CONFIRM\t\t0x03\n#define SMC_CLC_DECLINE\t\t0x04\n\n#define SMC_TYPE_R\t\t0\t\t \n#define SMC_TYPE_D\t\t1\t\t \n#define SMC_TYPE_N\t\t2\t\t \n#define SMC_TYPE_B\t\t3\t\t \n#define CLC_WAIT_TIME\t\t(6 * HZ)\t \n#define CLC_WAIT_TIME_SHORT\tHZ\t\t \n#define SMC_CLC_DECL_MEM\t0x01010000   \n#define SMC_CLC_DECL_TIMEOUT_CL\t0x02010000   \n#define SMC_CLC_DECL_TIMEOUT_AL\t0x02020000   \n#define SMC_CLC_DECL_CNFERR\t0x03000000   \n#define SMC_CLC_DECL_PEERNOSMC\t0x03010000   \n#define SMC_CLC_DECL_IPSEC\t0x03020000   \n#define SMC_CLC_DECL_NOSMCDEV\t0x03030000   \n#define SMC_CLC_DECL_NOSMCDDEV\t0x03030001   \n#define SMC_CLC_DECL_NOSMCRDEV\t0x03030002   \n#define SMC_CLC_DECL_NOISM2SUPP\t0x03030003   \n#define SMC_CLC_DECL_NOV2EXT\t0x03030004   \n#define SMC_CLC_DECL_NOV2DEXT\t0x03030005   \n#define SMC_CLC_DECL_NOSEID\t0x03030006   \n#define SMC_CLC_DECL_NOSMCD2DEV\t0x03030007   \n#define SMC_CLC_DECL_NOUEID\t0x03030008   \n#define SMC_CLC_DECL_RELEASEERR\t0x03030009   \n#define SMC_CLC_DECL_MAXCONNERR\t0x0303000a   \n#define SMC_CLC_DECL_MAXLINKERR\t0x0303000b   \n#define SMC_CLC_DECL_MODEUNSUPP\t0x03040000   \n#define SMC_CLC_DECL_RMBE_EC\t0x03050000   \n#define SMC_CLC_DECL_OPTUNSUPP\t0x03060000   \n#define SMC_CLC_DECL_DIFFPREFIX\t0x03070000   \n#define SMC_CLC_DECL_GETVLANERR\t0x03080000   \n#define SMC_CLC_DECL_ISMVLANERR\t0x03090000   \n#define SMC_CLC_DECL_NOACTLINK\t0x030a0000   \n#define SMC_CLC_DECL_NOSRVLINK\t0x030b0000   \n#define SMC_CLC_DECL_VERSMISMAT\t0x030c0000   \n#define SMC_CLC_DECL_MAX_DMB\t0x030d0000   \n#define SMC_CLC_DECL_NOROUTE\t0x030e0000   \n#define SMC_CLC_DECL_NOINDIRECT\t0x030f0000   \n#define SMC_CLC_DECL_SYNCERR\t0x04000000   \n#define SMC_CLC_DECL_PEERDECL\t0x05000000   \n#define SMC_CLC_DECL_INTERR\t0x09990000   \n#define SMC_CLC_DECL_ERR_RTOK\t0x09990001   \n#define SMC_CLC_DECL_ERR_RDYLNK\t0x09990002   \n#define SMC_CLC_DECL_ERR_REGBUF\t0x09990003   \n\n#define SMC_FIRST_CONTACT_MASK\t0b10\t \n\nstruct smc_clc_msg_hdr {\t \n\tu8 eyecatcher[4];\t \n\tu8 type;\t\t \n\t__be16 length;\n#if defined(__BIG_ENDIAN_BITFIELD)\n\tu8 version : 4,\n\t   typev2  : 2,\n\t   typev1  : 2;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\tu8 typev1  : 2,\n\t   typev2  : 2,\n\t   version : 4;\n#endif\n} __packed;\t\t\t \n\nstruct smc_clc_msg_trail {\t \n\tu8 eyecatcher[4];\n};\n\nstruct smc_clc_msg_local {\t \n\tu8 id_for_peer[SMC_SYSTEMID_LEN];  \n\tu8 gid[16];\t\t \n\tu8 mac[6];\t\t \n};\n\n \nstruct smc_clc_ipv6_prefix {\n\tstruct in6_addr prefix;\n\tu8 prefix_len;\n} __packed;\t\t\t \n\n#if defined(__BIG_ENDIAN_BITFIELD)\nstruct smc_clc_v2_flag {\n\tu8 release : 4,\n\t   rsvd    : 3,\n\t   seid    : 1;\n};\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\nstruct smc_clc_v2_flag {\n\tu8 seid   : 1,\n\trsvd      : 3,\n\trelease   : 4;\n};\n#endif\n\nstruct smc_clnt_opts_area_hdr {\n\tu8 eid_cnt;\t\t \n\tu8 ism_gid_cnt;\t\t \n\tu8 reserved1;\n\tstruct smc_clc_v2_flag flag;\n\tu8 reserved2[2];\n\t__be16 smcd_v2_ext_offset;  \n};\n\nstruct smc_clc_smcd_gid_chid {\n\t__be64 gid;\t\t \n\t__be16 chid;\t\t \n} __packed;\t\t \n\nstruct smc_clc_v2_extension {\n\tstruct smc_clnt_opts_area_hdr hdr;\n\tu8 roce[16];\t\t \n\tu8 max_conns;\n\tu8 max_links;\n\tu8 reserved[14];\n\tu8 user_eids[][SMC_MAX_EID_LEN];\n};\n\nstruct smc_clc_msg_proposal_prefix {\t \n\t__be32 outgoing_subnet;\t \n\tu8 prefix_len;\t\t \n\tu8 reserved[2];\n\tu8 ipv6_prefixes_cnt;\t \n} __aligned(4);\n\nstruct smc_clc_msg_smcd {\t \n\tstruct smc_clc_smcd_gid_chid ism;  \n\t__be16 v2_ext_offset;\t \n\tu8 vendor_oui[3];\t \n\tu8 vendor_exp_options[5];\n\tu8 reserved[20];\n};\n\nstruct smc_clc_smcd_v2_extension {\n\tu8 system_eid[SMC_MAX_EID_LEN];\n\tu8 reserved[16];\n\tstruct smc_clc_smcd_gid_chid gidchid[];\n};\n\nstruct smc_clc_msg_proposal {\t \n\tstruct smc_clc_msg_hdr hdr;\n\tstruct smc_clc_msg_local lcl;\n\t__be16 iparea_offset;\t \n} __aligned(4);\n\n#define SMC_CLC_MAX_V6_PREFIX\t\t8\n#define SMC_CLC_MAX_UEID\t\t8\n\nstruct smc_clc_msg_proposal_area {\n\tstruct smc_clc_msg_proposal\t\tpclc_base;\n\tstruct smc_clc_msg_smcd\t\t\tpclc_smcd;\n\tstruct smc_clc_msg_proposal_prefix\tpclc_prfx;\n\tstruct smc_clc_ipv6_prefix\tpclc_prfx_ipv6[SMC_CLC_MAX_V6_PREFIX];\n\tstruct smc_clc_v2_extension\t\tpclc_v2_ext;\n\tu8\t\t\tuser_eids[SMC_CLC_MAX_UEID][SMC_MAX_EID_LEN];\n\tstruct smc_clc_smcd_v2_extension\tpclc_smcd_v2_ext;\n\tstruct smc_clc_smcd_gid_chid\t\tpclc_gidchids[SMC_MAX_ISM_DEVS];\n\tstruct smc_clc_msg_trail\t\tpclc_trl;\n};\n\nstruct smcr_clc_msg_accept_confirm {\t \n\tstruct smc_clc_msg_local lcl;\n\tu8 qpn[3];\t\t\t \n\t__be32 rmb_rkey;\t\t \n\tu8 rmbe_idx;\t\t\t \n\t__be32 rmbe_alert_token;\t \n #if defined(__BIG_ENDIAN_BITFIELD)\n\tu8 rmbe_size : 4,\t\t \n\t   qp_mtu   : 4;\t\t \n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\tu8 qp_mtu   : 4,\n\t   rmbe_size : 4;\n#endif\n\tu8 reserved;\n\t__be64 rmb_dma_addr;\t \n\tu8 reserved2;\n\tu8 psn[3];\t\t \n} __packed;\n\nstruct smcd_clc_msg_accept_confirm_common {\t \n\t__be64 gid;\t\t \n\t__be64 token;\t\t \n\tu8 dmbe_idx;\t\t \n#if defined(__BIG_ENDIAN_BITFIELD)\n\tu8 dmbe_size : 4,\t \n\t   reserved3 : 4;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\tu8 reserved3 : 4,\n\t   dmbe_size : 4;\n#endif\n\tu16 reserved4;\n\t__be32 linkid;\t\t \n} __packed;\n\n#define SMC_CLC_OS_ZOS\t\t1\n#define SMC_CLC_OS_LINUX\t2\n#define SMC_CLC_OS_AIX\t\t3\n\nstruct smc_clc_first_contact_ext {\n#if defined(__BIG_ENDIAN_BITFIELD)\n\tu8 v2_direct : 1,\n\t   reserved  : 7;\n\tu8 os_type : 4,\n\t   release : 4;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\tu8 reserved  : 7,\n\t   v2_direct : 1;\n\tu8 release : 4,\n\t   os_type : 4;\n#endif\n\tu8 reserved2[2];\n\tu8 hostname[SMC_MAX_HOSTNAME_LEN];\n};\n\nstruct smc_clc_first_contact_ext_v2x {\n\tstruct smc_clc_first_contact_ext fce_v2_base;\n\tu8 max_conns;  \n\tu8 max_links;  \n\tu8 reserved3[2];\n\t__be32 vendor_exp_options;\n\tu8 reserved4[8];\n} __packed;\t\t \n\nstruct smc_clc_fce_gid_ext {\n\tu8 gid_cnt;\n\tu8 reserved2[3];\n\tu8 gid[][SMC_GID_SIZE];\n};\n\nstruct smc_clc_msg_accept_confirm {\t \n\tstruct smc_clc_msg_hdr hdr;\n\tunion {\n\t\tstruct smcr_clc_msg_accept_confirm r0;  \n\t\tstruct {  \n\t\t\tstruct smcd_clc_msg_accept_confirm_common d0;\n\t\t\tu32 reserved5[3];\n\t\t};\n\t};\n} __packed;\t\t\t \n\nstruct smc_clc_msg_accept_confirm_v2 {\t \n\tstruct smc_clc_msg_hdr hdr;\n\tunion {\n\t\tstruct {  \n\t\t\tstruct smcr_clc_msg_accept_confirm r0;\n\t\t\tu8 eid[SMC_MAX_EID_LEN];\n\t\t\tu8 reserved6[8];\n\t\t} r1;\n\t\tstruct {  \n\t\t\tstruct smcd_clc_msg_accept_confirm_common d0;\n\t\t\t__be16 chid;\n\t\t\tu8 eid[SMC_MAX_EID_LEN];\n\t\t\tu8 reserved5[8];\n\t\t} d1;\n\t};\n};\n\nstruct smc_clc_msg_decline {\t \n\tstruct smc_clc_msg_hdr hdr;\n\tu8 id_for_peer[SMC_SYSTEMID_LEN];  \n\t__be32 peer_diagnosis;\t \n#if defined(__BIG_ENDIAN_BITFIELD)\n\tu8 os_type  : 4,\n\t   reserved : 4;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\tu8 reserved : 4,\n\t   os_type  : 4;\n#endif\n\tu8 reserved2[3];\n\tstruct smc_clc_msg_trail trl;  \n} __aligned(4);\n\n#define SMC_DECL_DIAG_COUNT_V2\t4  \n\nstruct smc_clc_msg_decline_v2 {\t \n\tstruct smc_clc_msg_hdr hdr;\n\tu8 id_for_peer[SMC_SYSTEMID_LEN];  \n\t__be32 peer_diagnosis;\t \n#if defined(__BIG_ENDIAN_BITFIELD)\n\tu8 os_type  : 4,\n\t   reserved : 4;\n#elif defined(__LITTLE_ENDIAN_BITFIELD)\n\tu8 reserved : 4,\n\t   os_type  : 4;\n#endif\n\tu8 reserved2[3];\n\t__be32 peer_diagnosis_v2[SMC_DECL_DIAG_COUNT_V2];\n\tstruct smc_clc_msg_trail trl;  \n} __aligned(4);\n\n \nstatic inline struct smc_clc_msg_proposal_prefix *\nsmc_clc_proposal_get_prefix(struct smc_clc_msg_proposal *pclc)\n{\n\treturn (struct smc_clc_msg_proposal_prefix *)\n\t       ((u8 *)pclc + sizeof(*pclc) + ntohs(pclc->iparea_offset));\n}\n\nstatic inline bool smcr_indicated(int smc_type)\n{\n\treturn smc_type == SMC_TYPE_R || smc_type == SMC_TYPE_B;\n}\n\nstatic inline bool smcd_indicated(int smc_type)\n{\n\treturn smc_type == SMC_TYPE_D || smc_type == SMC_TYPE_B;\n}\n\nstatic inline u8 smc_indicated_type(int is_smcd, int is_smcr)\n{\n\tif (is_smcd && is_smcr)\n\t\treturn SMC_TYPE_B;\n\tif (is_smcd)\n\t\treturn SMC_TYPE_D;\n\tif (is_smcr)\n\t\treturn SMC_TYPE_R;\n\treturn SMC_TYPE_N;\n}\n\n \nstatic inline struct smc_clc_msg_smcd *\nsmc_get_clc_msg_smcd(struct smc_clc_msg_proposal *prop)\n{\n\tif (smcd_indicated(prop->hdr.typev1) &&\n\t    ntohs(prop->iparea_offset) != sizeof(struct smc_clc_msg_smcd))\n\t\treturn NULL;\n\n\treturn (struct smc_clc_msg_smcd *)(prop + 1);\n}\n\nstatic inline struct smc_clc_v2_extension *\nsmc_get_clc_v2_ext(struct smc_clc_msg_proposal *prop)\n{\n\tstruct smc_clc_msg_smcd *prop_smcd = smc_get_clc_msg_smcd(prop);\n\n\tif (!prop_smcd || !ntohs(prop_smcd->v2_ext_offset))\n\t\treturn NULL;\n\n\treturn (struct smc_clc_v2_extension *)\n\t       ((u8 *)prop_smcd +\n\t       offsetof(struct smc_clc_msg_smcd, v2_ext_offset) +\n\t       sizeof(prop_smcd->v2_ext_offset) +\n\t       ntohs(prop_smcd->v2_ext_offset));\n}\n\nstatic inline struct smc_clc_smcd_v2_extension *\nsmc_get_clc_smcd_v2_ext(struct smc_clc_v2_extension *prop_v2ext)\n{\n\tif (!prop_v2ext)\n\t\treturn NULL;\n\tif (!ntohs(prop_v2ext->hdr.smcd_v2_ext_offset))\n\t\treturn NULL;\n\n\treturn (struct smc_clc_smcd_v2_extension *)\n\t\t((u8 *)prop_v2ext +\n\t\t offsetof(struct smc_clc_v2_extension, hdr) +\n\t\t offsetof(struct smc_clnt_opts_area_hdr, smcd_v2_ext_offset) +\n\t\t sizeof(prop_v2ext->hdr.smcd_v2_ext_offset) +\n\t\t ntohs(prop_v2ext->hdr.smcd_v2_ext_offset));\n}\n\nstatic inline struct smc_clc_first_contact_ext *\nsmc_get_clc_first_contact_ext(struct smc_clc_msg_accept_confirm_v2 *clc_v2,\n\t\t\t      bool is_smcd)\n{\n\tint clc_v2_len;\n\n\tif (clc_v2->hdr.version == SMC_V1 ||\n\t    !(clc_v2->hdr.typev2 & SMC_FIRST_CONTACT_MASK))\n\t\treturn NULL;\n\n\tif (is_smcd)\n\t\tclc_v2_len =\n\t\t\toffsetofend(struct smc_clc_msg_accept_confirm_v2, d1);\n\telse\n\t\tclc_v2_len =\n\t\t\toffsetofend(struct smc_clc_msg_accept_confirm_v2, r1);\n\n\treturn (struct smc_clc_first_contact_ext *)(((u8 *)clc_v2) +\n\t\t\t\t\t\t    clc_v2_len);\n}\n\nstruct smcd_dev;\nstruct smc_init_info;\n\nint smc_clc_prfx_match(struct socket *clcsock,\n\t\t       struct smc_clc_msg_proposal_prefix *prop);\nint smc_clc_wait_msg(struct smc_sock *smc, void *buf, int buflen,\n\t\t     u8 expected_type, unsigned long timeout);\nint smc_clc_send_decline(struct smc_sock *smc, u32 peer_diag_info, u8 version);\nint smc_clc_send_proposal(struct smc_sock *smc, struct smc_init_info *ini);\nint smc_clc_send_confirm(struct smc_sock *smc, bool clnt_first_contact,\n\t\t\t u8 version, u8 *eid, struct smc_init_info *ini);\nint smc_clc_send_accept(struct smc_sock *smc, bool srv_first_contact,\n\t\t\tu8 version, u8 *negotiated_eid, struct smc_init_info *ini);\nint smc_clc_srv_v2x_features_validate(struct smc_clc_msg_proposal *pclc,\n\t\t\t\t      struct smc_init_info *ini);\nint smc_clc_clnt_v2x_features_validate(struct smc_clc_first_contact_ext *fce,\n\t\t\t\t       struct smc_init_info *ini);\nint smc_clc_v2x_features_confirm_check(struct smc_clc_msg_accept_confirm *cclc,\n\t\t\t\t       struct smc_init_info *ini);\nvoid smc_clc_init(void) __init;\nvoid smc_clc_exit(void);\nvoid smc_clc_get_hostname(u8 **host);\nbool smc_clc_match_eid(u8 *negotiated_eid,\n\t\t       struct smc_clc_v2_extension *smc_v2_ext,\n\t\t       u8 *peer_eid, u8 *local_eid);\nint smc_clc_ueid_count(void);\nint smc_nl_dump_ueid(struct sk_buff *skb, struct netlink_callback *cb);\nint smc_nl_add_ueid(struct sk_buff *skb, struct genl_info *info);\nint smc_nl_remove_ueid(struct sk_buff *skb, struct genl_info *info);\nint smc_nl_flush_ueid(struct sk_buff *skb, struct genl_info *info);\nint smc_nl_dump_seid(struct sk_buff *skb, struct netlink_callback *cb);\nint smc_nl_enable_seid(struct sk_buff *skb, struct genl_info *info);\nint smc_nl_disable_seid(struct sk_buff *skb, struct genl_info *info);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}