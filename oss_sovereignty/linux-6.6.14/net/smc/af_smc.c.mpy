{
  "module_name": "af_smc.c",
  "hash_id": "66c14f3cbc269958e2157eff23e3694ea00bd142be3f5bea5d69badf5b9ff9df",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/af_smc.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"smc\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/module.h>\n#include <linux/socket.h>\n#include <linux/workqueue.h>\n#include <linux/in.h>\n#include <linux/sched/signal.h>\n#include <linux/if_vlan.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ctype.h>\n#include <linux/splice.h>\n\n#include <net/sock.h>\n#include <net/tcp.h>\n#include <net/smc.h>\n#include <asm/ioctls.h>\n\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include \"smc_netns.h\"\n\n#include \"smc.h\"\n#include \"smc_clc.h\"\n#include \"smc_llc.h\"\n#include \"smc_cdc.h\"\n#include \"smc_core.h\"\n#include \"smc_ib.h\"\n#include \"smc_ism.h\"\n#include \"smc_pnet.h\"\n#include \"smc_netlink.h\"\n#include \"smc_tx.h\"\n#include \"smc_rx.h\"\n#include \"smc_close.h\"\n#include \"smc_stats.h\"\n#include \"smc_tracepoint.h\"\n#include \"smc_sysctl.h\"\n\nstatic DEFINE_MUTEX(smc_server_lgr_pending);\t \nstatic DEFINE_MUTEX(smc_client_lgr_pending);\t \n\nstatic struct workqueue_struct\t*smc_tcp_ls_wq;\t \nstruct workqueue_struct\t*smc_hs_wq;\t \nstruct workqueue_struct\t*smc_close_wq;\t \n\nstatic void smc_tcp_listen_work(struct work_struct *);\nstatic void smc_connect_work(struct work_struct *);\n\nint smc_nl_dump_hs_limitation(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct smc_nl_dmp_ctx *cb_ctx = smc_nl_dmp_ctx(cb);\n\tvoid *hdr;\n\n\tif (cb_ctx->pos[0])\n\t\tgoto out;\n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &smc_gen_nl_family, NLM_F_MULTI,\n\t\t\t  SMC_NETLINK_DUMP_HS_LIMITATION);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tif (nla_put_u8(skb, SMC_NLA_HS_LIMITATION_ENABLED,\n\t\t       sock_net(skb->sk)->smc.limit_smc_hs))\n\t\tgoto err;\n\n\tgenlmsg_end(skb, hdr);\n\tcb_ctx->pos[0] = 1;\nout:\n\treturn skb->len;\nerr:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nint smc_nl_enable_hs_limitation(struct sk_buff *skb, struct genl_info *info)\n{\n\tsock_net(skb->sk)->smc.limit_smc_hs = true;\n\treturn 0;\n}\n\nint smc_nl_disable_hs_limitation(struct sk_buff *skb, struct genl_info *info)\n{\n\tsock_net(skb->sk)->smc.limit_smc_hs = false;\n\treturn 0;\n}\n\nstatic void smc_set_keepalive(struct sock *sk, int val)\n{\n\tstruct smc_sock *smc = smc_sk(sk);\n\n\tsmc->clcsock->sk->sk_prot->keepalive(smc->clcsock->sk, val);\n}\n\nstatic struct sock *smc_tcp_syn_recv_sock(const struct sock *sk,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct request_sock *req,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  struct request_sock *req_unhash,\n\t\t\t\t\t  bool *own_req)\n{\n\tstruct smc_sock *smc;\n\tstruct sock *child;\n\n\tsmc = smc_clcsock_user_data(sk);\n\n\tif (READ_ONCE(sk->sk_ack_backlog) + atomic_read(&smc->queued_smc_hs) >\n\t\t\t\tsk->sk_max_ack_backlog)\n\t\tgoto drop;\n\n\tif (sk_acceptq_is_full(&smc->sk)) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\n\t\tgoto drop;\n\t}\n\n\t \n\tchild = smc->ori_af_ops->syn_recv_sock(sk, skb, req, dst, req_unhash,\n\t\t\t\t\t       own_req);\n\t \n\tif (child) {\n\t\trcu_assign_sk_user_data(child, NULL);\n\n\t\t \n\t\tif (inet_csk(child)->icsk_af_ops == inet_csk(sk)->icsk_af_ops)\n\t\t\tinet_csk(child)->icsk_af_ops = smc->ori_af_ops;\n\t}\n\treturn child;\n\ndrop:\n\tdst_release(dst);\n\ttcp_listendrop(sk);\n\treturn NULL;\n}\n\nstatic bool smc_hs_congested(const struct sock *sk)\n{\n\tconst struct smc_sock *smc;\n\n\tsmc = smc_clcsock_user_data(sk);\n\n\tif (!smc)\n\t\treturn true;\n\n\tif (workqueue_congested(WORK_CPU_UNBOUND, smc_hs_wq))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct smc_hashinfo smc_v4_hashinfo = {\n\t.lock = __RW_LOCK_UNLOCKED(smc_v4_hashinfo.lock),\n};\n\nstatic struct smc_hashinfo smc_v6_hashinfo = {\n\t.lock = __RW_LOCK_UNLOCKED(smc_v6_hashinfo.lock),\n};\n\nint smc_hash_sk(struct sock *sk)\n{\n\tstruct smc_hashinfo *h = sk->sk_prot->h.smc_hash;\n\tstruct hlist_head *head;\n\n\thead = &h->ht;\n\n\twrite_lock_bh(&h->lock);\n\tsk_add_node(sk, head);\n\twrite_unlock_bh(&h->lock);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(smc_hash_sk);\n\nvoid smc_unhash_sk(struct sock *sk)\n{\n\tstruct smc_hashinfo *h = sk->sk_prot->h.smc_hash;\n\n\twrite_lock_bh(&h->lock);\n\tif (sk_del_node_init(sk))\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\twrite_unlock_bh(&h->lock);\n}\nEXPORT_SYMBOL_GPL(smc_unhash_sk);\n\n \nstatic void smc_release_cb(struct sock *sk)\n{\n\tstruct smc_sock *smc = smc_sk(sk);\n\n\tif (smc->conn.tx_in_release_sock) {\n\t\tsmc_tx_pending(&smc->conn);\n\t\tsmc->conn.tx_in_release_sock = false;\n\t}\n}\n\nstruct proto smc_proto = {\n\t.name\t\t= \"SMC\",\n\t.owner\t\t= THIS_MODULE,\n\t.keepalive\t= smc_set_keepalive,\n\t.hash\t\t= smc_hash_sk,\n\t.unhash\t\t= smc_unhash_sk,\n\t.release_cb\t= smc_release_cb,\n\t.obj_size\t= sizeof(struct smc_sock),\n\t.h.smc_hash\t= &smc_v4_hashinfo,\n\t.slab_flags\t= SLAB_TYPESAFE_BY_RCU,\n};\nEXPORT_SYMBOL_GPL(smc_proto);\n\nstruct proto smc_proto6 = {\n\t.name\t\t= \"SMC6\",\n\t.owner\t\t= THIS_MODULE,\n\t.keepalive\t= smc_set_keepalive,\n\t.hash\t\t= smc_hash_sk,\n\t.unhash\t\t= smc_unhash_sk,\n\t.release_cb\t= smc_release_cb,\n\t.obj_size\t= sizeof(struct smc_sock),\n\t.h.smc_hash\t= &smc_v6_hashinfo,\n\t.slab_flags\t= SLAB_TYPESAFE_BY_RCU,\n};\nEXPORT_SYMBOL_GPL(smc_proto6);\n\nstatic void smc_fback_restore_callbacks(struct smc_sock *smc)\n{\n\tstruct sock *clcsk = smc->clcsock->sk;\n\n\twrite_lock_bh(&clcsk->sk_callback_lock);\n\tclcsk->sk_user_data = NULL;\n\n\tsmc_clcsock_restore_cb(&clcsk->sk_state_change, &smc->clcsk_state_change);\n\tsmc_clcsock_restore_cb(&clcsk->sk_data_ready, &smc->clcsk_data_ready);\n\tsmc_clcsock_restore_cb(&clcsk->sk_write_space, &smc->clcsk_write_space);\n\tsmc_clcsock_restore_cb(&clcsk->sk_error_report, &smc->clcsk_error_report);\n\n\twrite_unlock_bh(&clcsk->sk_callback_lock);\n}\n\nstatic void smc_restore_fallback_changes(struct smc_sock *smc)\n{\n\tif (smc->clcsock->file) {  \n\t\tsmc->clcsock->file->private_data = smc->sk.sk_socket;\n\t\tsmc->clcsock->file = NULL;\n\t\tsmc_fback_restore_callbacks(smc);\n\t}\n}\n\nstatic int __smc_release(struct smc_sock *smc)\n{\n\tstruct sock *sk = &smc->sk;\n\tint rc = 0;\n\n\tif (!smc->use_fallback) {\n\t\trc = smc_close_active(smc);\n\t\tsmc_sock_set_flag(sk, SOCK_DEAD);\n\t\tsk->sk_shutdown |= SHUTDOWN_MASK;\n\t} else {\n\t\tif (sk->sk_state != SMC_CLOSED) {\n\t\t\tif (sk->sk_state != SMC_LISTEN &&\n\t\t\t    sk->sk_state != SMC_INIT)\n\t\t\t\tsock_put(sk);  \n\t\t\tif (sk->sk_state == SMC_LISTEN) {\n\t\t\t\t \n\t\t\t\trc = kernel_sock_shutdown(smc->clcsock,\n\t\t\t\t\t\t\t  SHUT_RDWR);\n\t\t\t}\n\t\t\tsk->sk_state = SMC_CLOSED;\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\t\tsmc_restore_fallback_changes(smc);\n\t}\n\n\tsk->sk_prot->unhash(sk);\n\n\tif (sk->sk_state == SMC_CLOSED) {\n\t\tif (smc->clcsock) {\n\t\t\trelease_sock(sk);\n\t\t\tsmc_clcsock_release(smc);\n\t\t\tlock_sock(sk);\n\t\t}\n\t\tif (!smc->use_fallback)\n\t\t\tsmc_conn_free(&smc->conn);\n\t}\n\n\treturn rc;\n}\n\nstatic int smc_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct smc_sock *smc;\n\tint old_state, rc = 0;\n\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_hold(sk);  \n\tsmc = smc_sk(sk);\n\n\told_state = sk->sk_state;\n\n\t \n\tif (smc->connect_nonblock && old_state == SMC_INIT)\n\t\ttcp_abort(smc->clcsock->sk, ECONNABORTED);\n\n\tif (cancel_work_sync(&smc->connect_work))\n\t\tsock_put(&smc->sk);  \n\n\tif (sk->sk_state == SMC_LISTEN)\n\t\t \n\t\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\telse\n\t\tlock_sock(sk);\n\n\tif (old_state == SMC_INIT && sk->sk_state == SMC_ACTIVE &&\n\t    !smc->use_fallback)\n\t\tsmc_close_active_abort(smc);\n\n\trc = __smc_release(smc);\n\n\t \n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\n\tsock_put(sk);  \n\tsock_put(sk);  \nout:\n\treturn rc;\n}\n\nstatic void smc_destruct(struct sock *sk)\n{\n\tif (sk->sk_state != SMC_CLOSED)\n\t\treturn;\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\treturn;\n}\n\nstatic struct sock *smc_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t   int protocol)\n{\n\tstruct smc_sock *smc;\n\tstruct proto *prot;\n\tstruct sock *sk;\n\n\tprot = (protocol == SMCPROTO_SMC6) ? &smc_proto6 : &smc_proto;\n\tsk = sk_alloc(net, PF_SMC, GFP_KERNEL, prot, 0);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);  \n\tsk->sk_state = SMC_INIT;\n\tsk->sk_destruct = smc_destruct;\n\tsk->sk_protocol = protocol;\n\tWRITE_ONCE(sk->sk_sndbuf, 2 * READ_ONCE(net->smc.sysctl_wmem));\n\tWRITE_ONCE(sk->sk_rcvbuf, 2 * READ_ONCE(net->smc.sysctl_rmem));\n\tsmc = smc_sk(sk);\n\tINIT_WORK(&smc->tcp_listen_work, smc_tcp_listen_work);\n\tINIT_WORK(&smc->connect_work, smc_connect_work);\n\tINIT_DELAYED_WORK(&smc->conn.tx_work, smc_tx_work);\n\tINIT_LIST_HEAD(&smc->accept_q);\n\tspin_lock_init(&smc->accept_q_lock);\n\tspin_lock_init(&smc->conn.send_lock);\n\tsk->sk_prot->hash(sk);\n\tmutex_init(&smc->clcsock_release_lock);\n\tsmc_init_saved_callbacks(smc);\n\n\treturn sk;\n}\n\nstatic int smc_bind(struct socket *sock, struct sockaddr *uaddr,\n\t\t    int addr_len)\n{\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct smc_sock *smc;\n\tint rc;\n\n\tsmc = smc_sk(sk);\n\n\t \n\trc = -EINVAL;\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\tgoto out;\n\n\trc = -EAFNOSUPPORT;\n\tif (addr->sin_family != AF_INET &&\n\t    addr->sin_family != AF_INET6 &&\n\t    addr->sin_family != AF_UNSPEC)\n\t\tgoto out;\n\t \n\tif (addr->sin_family == AF_UNSPEC &&\n\t    addr->sin_addr.s_addr != htonl(INADDR_ANY))\n\t\tgoto out;\n\n\tlock_sock(sk);\n\n\t \n\trc = -EINVAL;\n\tif (sk->sk_state != SMC_INIT || smc->connect_nonblock)\n\t\tgoto out_rel;\n\n\tsmc->clcsock->sk->sk_reuse = sk->sk_reuse;\n\tsmc->clcsock->sk->sk_reuseport = sk->sk_reuseport;\n\trc = kernel_bind(smc->clcsock, uaddr, addr_len);\n\nout_rel:\n\trelease_sock(sk);\nout:\n\treturn rc;\n}\n\n \n\n#define SK_FLAGS_SMC_TO_CLC ((1UL << SOCK_URGINLINE) | \\\n\t\t\t     (1UL << SOCK_KEEPOPEN) | \\\n\t\t\t     (1UL << SOCK_LINGER) | \\\n\t\t\t     (1UL << SOCK_BROADCAST) | \\\n\t\t\t     (1UL << SOCK_TIMESTAMP) | \\\n\t\t\t     (1UL << SOCK_DBG) | \\\n\t\t\t     (1UL << SOCK_RCVTSTAMP) | \\\n\t\t\t     (1UL << SOCK_RCVTSTAMPNS) | \\\n\t\t\t     (1UL << SOCK_LOCALROUTE) | \\\n\t\t\t     (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE) | \\\n\t\t\t     (1UL << SOCK_RXQ_OVFL) | \\\n\t\t\t     (1UL << SOCK_WIFI_STATUS) | \\\n\t\t\t     (1UL << SOCK_NOFCS) | \\\n\t\t\t     (1UL << SOCK_FILTER_LOCKED) | \\\n\t\t\t     (1UL << SOCK_TSTAMP_NEW))\n\n \nstatic void smc_adjust_sock_bufsizes(struct sock *nsk, struct sock *osk,\n\t\t\t\t     unsigned long mask)\n{\n\tstruct net *nnet = sock_net(nsk);\n\n\tnsk->sk_userlocks = osk->sk_userlocks;\n\tif (osk->sk_userlocks & SOCK_SNDBUF_LOCK) {\n\t\tnsk->sk_sndbuf = osk->sk_sndbuf;\n\t} else {\n\t\tif (mask == SK_FLAGS_SMC_TO_CLC)\n\t\t\tWRITE_ONCE(nsk->sk_sndbuf,\n\t\t\t\t   READ_ONCE(nnet->ipv4.sysctl_tcp_wmem[1]));\n\t\telse\n\t\t\tWRITE_ONCE(nsk->sk_sndbuf,\n\t\t\t\t   2 * READ_ONCE(nnet->smc.sysctl_wmem));\n\t}\n\tif (osk->sk_userlocks & SOCK_RCVBUF_LOCK) {\n\t\tnsk->sk_rcvbuf = osk->sk_rcvbuf;\n\t} else {\n\t\tif (mask == SK_FLAGS_SMC_TO_CLC)\n\t\t\tWRITE_ONCE(nsk->sk_rcvbuf,\n\t\t\t\t   READ_ONCE(nnet->ipv4.sysctl_tcp_rmem[1]));\n\t\telse\n\t\t\tWRITE_ONCE(nsk->sk_rcvbuf,\n\t\t\t\t   2 * READ_ONCE(nnet->smc.sysctl_rmem));\n\t}\n}\n\nstatic void smc_copy_sock_settings(struct sock *nsk, struct sock *osk,\n\t\t\t\t   unsigned long mask)\n{\n\t \n\tnsk->sk_type = osk->sk_type;\n\tnsk->sk_sndtimeo = osk->sk_sndtimeo;\n\tnsk->sk_rcvtimeo = osk->sk_rcvtimeo;\n\tnsk->sk_mark = READ_ONCE(osk->sk_mark);\n\tnsk->sk_priority = osk->sk_priority;\n\tnsk->sk_rcvlowat = osk->sk_rcvlowat;\n\tnsk->sk_bound_dev_if = osk->sk_bound_dev_if;\n\tnsk->sk_err = osk->sk_err;\n\n\tnsk->sk_flags &= ~mask;\n\tnsk->sk_flags |= osk->sk_flags & mask;\n\n\tsmc_adjust_sock_bufsizes(nsk, osk, mask);\n}\n\nstatic void smc_copy_sock_settings_to_clc(struct smc_sock *smc)\n{\n\tsmc_copy_sock_settings(smc->clcsock->sk, &smc->sk, SK_FLAGS_SMC_TO_CLC);\n}\n\n#define SK_FLAGS_CLC_TO_SMC ((1UL << SOCK_URGINLINE) | \\\n\t\t\t     (1UL << SOCK_KEEPOPEN) | \\\n\t\t\t     (1UL << SOCK_LINGER) | \\\n\t\t\t     (1UL << SOCK_DBG))\n \nstatic void smc_copy_sock_settings_to_smc(struct smc_sock *smc)\n{\n\tsmc_copy_sock_settings(&smc->sk, smc->clcsock->sk, SK_FLAGS_CLC_TO_SMC);\n}\n\n \nstatic int smcr_lgr_reg_sndbufs(struct smc_link *link,\n\t\t\t\tstruct smc_buf_desc *snd_desc)\n{\n\tstruct smc_link_group *lgr = link->lgr;\n\tint i, rc = 0;\n\n\tif (!snd_desc->is_vm)\n\t\treturn -EINVAL;\n\n\t \n\tdown_write(&lgr->llc_conf_mutex);\n\tfor (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {\n\t\tif (!smc_link_active(&lgr->lnk[i]))\n\t\t\tcontinue;\n\t\trc = smcr_link_reg_buf(&lgr->lnk[i], snd_desc);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\tup_write(&lgr->llc_conf_mutex);\n\treturn rc;\n}\n\n \nstatic int smcr_lgr_reg_rmbs(struct smc_link *link,\n\t\t\t     struct smc_buf_desc *rmb_desc)\n{\n\tstruct smc_link_group *lgr = link->lgr;\n\tbool do_slow = false;\n\tint i, rc = 0;\n\n\trc = smc_llc_flow_initiate(lgr, SMC_LLC_FLOW_RKEY);\n\tif (rc)\n\t\treturn rc;\n\n\tdown_read(&lgr->llc_conf_mutex);\n\tfor (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {\n\t\tif (!smc_link_active(&lgr->lnk[i]))\n\t\t\tcontinue;\n\t\tif (!rmb_desc->is_reg_mr[link->link_idx]) {\n\t\t\tup_read(&lgr->llc_conf_mutex);\n\t\t\tgoto slow_path;\n\t\t}\n\t}\n\t \n\tgoto fast_path;\nslow_path:\n\tdo_slow = true;\n\t \n\tdown_write(&lgr->llc_conf_mutex);\n\tfor (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {\n\t\tif (!smc_link_active(&lgr->lnk[i]))\n\t\t\tcontinue;\n\t\trc = smcr_link_reg_buf(&lgr->lnk[i], rmb_desc);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\nfast_path:\n\t \n\trc = smc_llc_do_confirm_rkey(link, rmb_desc);\n\tif (rc) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\trmb_desc->is_conf_rkey = true;\nout:\n\tdo_slow ? up_write(&lgr->llc_conf_mutex) : up_read(&lgr->llc_conf_mutex);\n\tsmc_llc_flow_stop(lgr, &lgr->llc_flow_lcl);\n\treturn rc;\n}\n\nstatic int smcr_clnt_conf_first_link(struct smc_sock *smc)\n{\n\tstruct smc_link *link = smc->conn.lnk;\n\tstruct smc_llc_qentry *qentry;\n\tint rc;\n\n\t \n\tqentry = smc_llc_wait(link->lgr, NULL, 2 * SMC_LLC_WAIT_TIME,\n\t\t\t      SMC_LLC_CONFIRM_LINK);\n\tif (!qentry) {\n\t\tstruct smc_clc_msg_decline dclc;\n\n\t\trc = smc_clc_wait_msg(smc, &dclc, sizeof(dclc),\n\t\t\t\t      SMC_CLC_DECLINE, CLC_WAIT_TIME_SHORT);\n\t\treturn rc == -EAGAIN ? SMC_CLC_DECL_TIMEOUT_CL : rc;\n\t}\n\tsmc_llc_save_peer_uid(qentry);\n\trc = smc_llc_eval_conf_link(qentry, SMC_LLC_REQ);\n\tsmc_llc_flow_qentry_del(&link->lgr->llc_flow_lcl);\n\tif (rc)\n\t\treturn SMC_CLC_DECL_RMBE_EC;\n\n\trc = smc_ib_modify_qp_rts(link);\n\tif (rc)\n\t\treturn SMC_CLC_DECL_ERR_RDYLNK;\n\n\tsmc_wr_remember_qp_attr(link);\n\n\t \n\tif (smc->conn.sndbuf_desc->is_vm) {\n\t\tif (smcr_link_reg_buf(link, smc->conn.sndbuf_desc))\n\t\t\treturn SMC_CLC_DECL_ERR_REGBUF;\n\t}\n\n\t \n\tif (smcr_link_reg_buf(link, smc->conn.rmb_desc))\n\t\treturn SMC_CLC_DECL_ERR_REGBUF;\n\n\t \n\tsmc->conn.rmb_desc->is_conf_rkey = true;\n\n\t \n\trc = smc_llc_send_confirm_link(link, SMC_LLC_RESP);\n\tif (rc < 0)\n\t\treturn SMC_CLC_DECL_TIMEOUT_CL;\n\n\tsmc_llc_link_active(link);\n\tsmcr_lgr_set_type(link->lgr, SMC_LGR_SINGLE);\n\n\tif (link->lgr->max_links > 1) {\n\t\t \n\t\tqentry = smc_llc_wait(link->lgr, NULL, SMC_LLC_WAIT_TIME,\n\t\t\t\t      SMC_LLC_ADD_LINK);\n\t\tif (!qentry) {\n\t\t\tstruct smc_clc_msg_decline dclc;\n\n\t\t\trc = smc_clc_wait_msg(smc, &dclc, sizeof(dclc),\n\t\t\t\t\t      SMC_CLC_DECLINE, CLC_WAIT_TIME_SHORT);\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\trc = 0;  \n\t\t\treturn rc;\n\t\t}\n\t\tsmc_llc_flow_qentry_clr(&link->lgr->llc_flow_lcl);\n\t\tsmc_llc_cli_add_link(link, qentry);\n\t}\n\treturn 0;\n}\n\nstatic bool smc_isascii(char *hostname)\n{\n\tint i;\n\n\tfor (i = 0; i < SMC_MAX_HOSTNAME_LEN; i++)\n\t\tif (!isascii(hostname[i]))\n\t\t\treturn false;\n\treturn true;\n}\n\nstatic void smc_conn_save_peer_info_fce(struct smc_sock *smc,\n\t\t\t\t\tstruct smc_clc_msg_accept_confirm *clc)\n{\n\tstruct smc_clc_msg_accept_confirm_v2 *clc_v2 =\n\t\t(struct smc_clc_msg_accept_confirm_v2 *)clc;\n\tstruct smc_clc_first_contact_ext *fce;\n\tint clc_v2_len;\n\n\tif (clc->hdr.version == SMC_V1 ||\n\t    !(clc->hdr.typev2 & SMC_FIRST_CONTACT_MASK))\n\t\treturn;\n\n\tif (smc->conn.lgr->is_smcd) {\n\t\tmemcpy(smc->conn.lgr->negotiated_eid, clc_v2->d1.eid,\n\t\t       SMC_MAX_EID_LEN);\n\t\tclc_v2_len = offsetofend(struct smc_clc_msg_accept_confirm_v2,\n\t\t\t\t\t d1);\n\t} else {\n\t\tmemcpy(smc->conn.lgr->negotiated_eid, clc_v2->r1.eid,\n\t\t       SMC_MAX_EID_LEN);\n\t\tclc_v2_len = offsetofend(struct smc_clc_msg_accept_confirm_v2,\n\t\t\t\t\t r1);\n\t}\n\tfce = (struct smc_clc_first_contact_ext *)(((u8 *)clc_v2) + clc_v2_len);\n\tsmc->conn.lgr->peer_os = fce->os_type;\n\tsmc->conn.lgr->peer_smc_release = fce->release;\n\tif (smc_isascii(fce->hostname))\n\t\tmemcpy(smc->conn.lgr->peer_hostname, fce->hostname,\n\t\t       SMC_MAX_HOSTNAME_LEN);\n}\n\nstatic void smcr_conn_save_peer_info(struct smc_sock *smc,\n\t\t\t\t     struct smc_clc_msg_accept_confirm *clc)\n{\n\tint bufsize = smc_uncompress_bufsize(clc->r0.rmbe_size);\n\n\tsmc->conn.peer_rmbe_idx = clc->r0.rmbe_idx;\n\tsmc->conn.local_tx_ctrl.token = ntohl(clc->r0.rmbe_alert_token);\n\tsmc->conn.peer_rmbe_size = bufsize;\n\tatomic_set(&smc->conn.peer_rmbe_space, smc->conn.peer_rmbe_size);\n\tsmc->conn.tx_off = bufsize * (smc->conn.peer_rmbe_idx - 1);\n}\n\nstatic void smcd_conn_save_peer_info(struct smc_sock *smc,\n\t\t\t\t     struct smc_clc_msg_accept_confirm *clc)\n{\n\tint bufsize = smc_uncompress_bufsize(clc->d0.dmbe_size);\n\n\tsmc->conn.peer_rmbe_idx = clc->d0.dmbe_idx;\n\tsmc->conn.peer_token = ntohll(clc->d0.token);\n\t \n\tsmc->conn.peer_rmbe_size = bufsize - sizeof(struct smcd_cdc_msg);\n\tatomic_set(&smc->conn.peer_rmbe_space, smc->conn.peer_rmbe_size);\n\tsmc->conn.tx_off = bufsize * smc->conn.peer_rmbe_idx;\n}\n\nstatic void smc_conn_save_peer_info(struct smc_sock *smc,\n\t\t\t\t    struct smc_clc_msg_accept_confirm *clc)\n{\n\tif (smc->conn.lgr->is_smcd)\n\t\tsmcd_conn_save_peer_info(smc, clc);\n\telse\n\t\tsmcr_conn_save_peer_info(smc, clc);\n\tsmc_conn_save_peer_info_fce(smc, clc);\n}\n\nstatic void smc_link_save_peer_info(struct smc_link *link,\n\t\t\t\t    struct smc_clc_msg_accept_confirm *clc,\n\t\t\t\t    struct smc_init_info *ini)\n{\n\tlink->peer_qpn = ntoh24(clc->r0.qpn);\n\tmemcpy(link->peer_gid, ini->peer_gid, SMC_GID_SIZE);\n\tmemcpy(link->peer_mac, ini->peer_mac, sizeof(link->peer_mac));\n\tlink->peer_psn = ntoh24(clc->r0.psn);\n\tlink->peer_mtu = clc->r0.qp_mtu;\n}\n\nstatic void smc_stat_inc_fback_rsn_cnt(struct smc_sock *smc,\n\t\t\t\t       struct smc_stats_fback *fback_arr)\n{\n\tint cnt;\n\n\tfor (cnt = 0; cnt < SMC_MAX_FBACK_RSN_CNT; cnt++) {\n\t\tif (fback_arr[cnt].fback_code == smc->fallback_rsn) {\n\t\t\tfback_arr[cnt].count++;\n\t\t\tbreak;\n\t\t}\n\t\tif (!fback_arr[cnt].fback_code) {\n\t\t\tfback_arr[cnt].fback_code = smc->fallback_rsn;\n\t\t\tfback_arr[cnt].count++;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void smc_stat_fallback(struct smc_sock *smc)\n{\n\tstruct net *net = sock_net(&smc->sk);\n\n\tmutex_lock(&net->smc.mutex_fback_rsn);\n\tif (smc->listen_smc) {\n\t\tsmc_stat_inc_fback_rsn_cnt(smc, net->smc.fback_rsn->srv);\n\t\tnet->smc.fback_rsn->srv_fback_cnt++;\n\t} else {\n\t\tsmc_stat_inc_fback_rsn_cnt(smc, net->smc.fback_rsn->clnt);\n\t\tnet->smc.fback_rsn->clnt_fback_cnt++;\n\t}\n\tmutex_unlock(&net->smc.mutex_fback_rsn);\n}\n\n \nstatic void smc_fback_wakeup_waitqueue(struct smc_sock *smc, void *key)\n{\n\tstruct socket_wq *wq;\n\t__poll_t flags;\n\n\twq = rcu_dereference(smc->sk.sk_wq);\n\tif (!skwq_has_sleeper(wq))\n\t\treturn;\n\n\t \n\tif (!key) {\n\t\t \n\t\twake_up_interruptible_all(&wq->wait);\n\t} else {\n\t\tflags = key_to_poll(key);\n\t\tif (flags & (EPOLLIN | EPOLLOUT))\n\t\t\t \n\t\t\twake_up_interruptible_sync_poll(&wq->wait, flags);\n\t\telse if (flags & EPOLLERR)\n\t\t\t \n\t\t\twake_up_interruptible_poll(&wq->wait, flags);\n\t}\n}\n\nstatic int smc_fback_mark_woken(wait_queue_entry_t *wait,\n\t\t\t\tunsigned int mode, int sync, void *key)\n{\n\tstruct smc_mark_woken *mark =\n\t\tcontainer_of(wait, struct smc_mark_woken, wait_entry);\n\n\tmark->woken = true;\n\tmark->key = key;\n\treturn 0;\n}\n\nstatic void smc_fback_forward_wakeup(struct smc_sock *smc, struct sock *clcsk,\n\t\t\t\t     void (*clcsock_callback)(struct sock *sk))\n{\n\tstruct smc_mark_woken mark = { .woken = false };\n\tstruct socket_wq *wq;\n\n\tinit_waitqueue_func_entry(&mark.wait_entry,\n\t\t\t\t  smc_fback_mark_woken);\n\trcu_read_lock();\n\twq = rcu_dereference(clcsk->sk_wq);\n\tif (!wq)\n\t\tgoto out;\n\tadd_wait_queue(sk_sleep(clcsk), &mark.wait_entry);\n\tclcsock_callback(clcsk);\n\tremove_wait_queue(sk_sleep(clcsk), &mark.wait_entry);\n\n\tif (mark.woken)\n\t\tsmc_fback_wakeup_waitqueue(smc, mark.key);\nout:\n\trcu_read_unlock();\n}\n\nstatic void smc_fback_state_change(struct sock *clcsk)\n{\n\tstruct smc_sock *smc;\n\n\tread_lock_bh(&clcsk->sk_callback_lock);\n\tsmc = smc_clcsock_user_data(clcsk);\n\tif (smc)\n\t\tsmc_fback_forward_wakeup(smc, clcsk,\n\t\t\t\t\t smc->clcsk_state_change);\n\tread_unlock_bh(&clcsk->sk_callback_lock);\n}\n\nstatic void smc_fback_data_ready(struct sock *clcsk)\n{\n\tstruct smc_sock *smc;\n\n\tread_lock_bh(&clcsk->sk_callback_lock);\n\tsmc = smc_clcsock_user_data(clcsk);\n\tif (smc)\n\t\tsmc_fback_forward_wakeup(smc, clcsk,\n\t\t\t\t\t smc->clcsk_data_ready);\n\tread_unlock_bh(&clcsk->sk_callback_lock);\n}\n\nstatic void smc_fback_write_space(struct sock *clcsk)\n{\n\tstruct smc_sock *smc;\n\n\tread_lock_bh(&clcsk->sk_callback_lock);\n\tsmc = smc_clcsock_user_data(clcsk);\n\tif (smc)\n\t\tsmc_fback_forward_wakeup(smc, clcsk,\n\t\t\t\t\t smc->clcsk_write_space);\n\tread_unlock_bh(&clcsk->sk_callback_lock);\n}\n\nstatic void smc_fback_error_report(struct sock *clcsk)\n{\n\tstruct smc_sock *smc;\n\n\tread_lock_bh(&clcsk->sk_callback_lock);\n\tsmc = smc_clcsock_user_data(clcsk);\n\tif (smc)\n\t\tsmc_fback_forward_wakeup(smc, clcsk,\n\t\t\t\t\t smc->clcsk_error_report);\n\tread_unlock_bh(&clcsk->sk_callback_lock);\n}\n\nstatic void smc_fback_replace_callbacks(struct smc_sock *smc)\n{\n\tstruct sock *clcsk = smc->clcsock->sk;\n\n\twrite_lock_bh(&clcsk->sk_callback_lock);\n\tclcsk->sk_user_data = (void *)((uintptr_t)smc | SK_USER_DATA_NOCOPY);\n\n\tsmc_clcsock_replace_cb(&clcsk->sk_state_change, smc_fback_state_change,\n\t\t\t       &smc->clcsk_state_change);\n\tsmc_clcsock_replace_cb(&clcsk->sk_data_ready, smc_fback_data_ready,\n\t\t\t       &smc->clcsk_data_ready);\n\tsmc_clcsock_replace_cb(&clcsk->sk_write_space, smc_fback_write_space,\n\t\t\t       &smc->clcsk_write_space);\n\tsmc_clcsock_replace_cb(&clcsk->sk_error_report, smc_fback_error_report,\n\t\t\t       &smc->clcsk_error_report);\n\n\twrite_unlock_bh(&clcsk->sk_callback_lock);\n}\n\nstatic int smc_switch_to_fallback(struct smc_sock *smc, int reason_code)\n{\n\tint rc = 0;\n\n\tmutex_lock(&smc->clcsock_release_lock);\n\tif (!smc->clcsock) {\n\t\trc = -EBADF;\n\t\tgoto out;\n\t}\n\n\tsmc->use_fallback = true;\n\tsmc->fallback_rsn = reason_code;\n\tsmc_stat_fallback(smc);\n\ttrace_smc_switch_to_fallback(smc, reason_code);\n\tif (smc->sk.sk_socket && smc->sk.sk_socket->file) {\n\t\tsmc->clcsock->file = smc->sk.sk_socket->file;\n\t\tsmc->clcsock->file->private_data = smc->clcsock;\n\t\tsmc->clcsock->wq.fasync_list =\n\t\t\tsmc->sk.sk_socket->wq.fasync_list;\n\n\t\t \n\t\tsmc_fback_replace_callbacks(smc);\n\t}\nout:\n\tmutex_unlock(&smc->clcsock_release_lock);\n\treturn rc;\n}\n\n \nstatic int smc_connect_fallback(struct smc_sock *smc, int reason_code)\n{\n\tstruct net *net = sock_net(&smc->sk);\n\tint rc = 0;\n\n\trc = smc_switch_to_fallback(smc, reason_code);\n\tif (rc) {  \n\t\tthis_cpu_inc(net->smc.smc_stats->clnt_hshake_err_cnt);\n\t\tif (smc->sk.sk_state == SMC_INIT)\n\t\t\tsock_put(&smc->sk);  \n\t\treturn rc;\n\t}\n\tsmc_copy_sock_settings_to_clc(smc);\n\tsmc->connect_nonblock = 0;\n\tif (smc->sk.sk_state == SMC_INIT)\n\t\tsmc->sk.sk_state = SMC_ACTIVE;\n\treturn 0;\n}\n\n \nstatic int smc_connect_decline_fallback(struct smc_sock *smc, int reason_code,\n\t\t\t\t\tu8 version)\n{\n\tstruct net *net = sock_net(&smc->sk);\n\tint rc;\n\n\tif (reason_code < 0) {  \n\t\tthis_cpu_inc(net->smc.smc_stats->clnt_hshake_err_cnt);\n\t\tif (smc->sk.sk_state == SMC_INIT)\n\t\t\tsock_put(&smc->sk);  \n\t\treturn reason_code;\n\t}\n\tif (reason_code != SMC_CLC_DECL_PEERDECL) {\n\t\trc = smc_clc_send_decline(smc, reason_code, version);\n\t\tif (rc < 0) {\n\t\t\tthis_cpu_inc(net->smc.smc_stats->clnt_hshake_err_cnt);\n\t\t\tif (smc->sk.sk_state == SMC_INIT)\n\t\t\t\tsock_put(&smc->sk);  \n\t\t\treturn rc;\n\t\t}\n\t}\n\treturn smc_connect_fallback(smc, reason_code);\n}\n\nstatic void smc_conn_abort(struct smc_sock *smc, int local_first)\n{\n\tstruct smc_connection *conn = &smc->conn;\n\tstruct smc_link_group *lgr = conn->lgr;\n\tbool lgr_valid = false;\n\n\tif (smc_conn_lgr_valid(conn))\n\t\tlgr_valid = true;\n\n\tsmc_conn_free(conn);\n\tif (local_first && lgr_valid)\n\t\tsmc_lgr_cleanup_early(lgr);\n}\n\n \n \nstatic int smc_find_rdma_device(struct smc_sock *smc, struct smc_init_info *ini)\n{\n\t \n\tsmc_pnet_find_roce_resource(smc->clcsock->sk, ini);\n\tif (!ini->check_smcrv2 && !ini->ib_dev)\n\t\treturn SMC_CLC_DECL_NOSMCRDEV;\n\tif (ini->check_smcrv2 && !ini->smcrv2.ib_dev_v2)\n\t\treturn SMC_CLC_DECL_NOSMCRDEV;\n\treturn 0;\n}\n\n \n \nstatic int smc_find_ism_device(struct smc_sock *smc, struct smc_init_info *ini)\n{\n\t \n\tsmc_pnet_find_ism_resource(smc->clcsock->sk, ini);\n\tif (!ini->ism_dev[0])\n\t\treturn SMC_CLC_DECL_NOSMCDDEV;\n\telse\n\t\tini->ism_chid[0] = smc_ism_get_chid(ini->ism_dev[0]);\n\treturn 0;\n}\n\n \nstatic bool smc_find_ism_v2_is_unique_chid(u16 chid, struct smc_init_info *ini,\n\t\t\t\t\t   int cnt)\n{\n\tint i = (!ini->ism_dev[0]) ? 1 : 0;\n\n\tfor (; i < cnt; i++)\n\t\tif (ini->ism_chid[i] == chid)\n\t\t\treturn false;\n\treturn true;\n}\n\n \nstatic int smc_find_ism_v2_device_clnt(struct smc_sock *smc,\n\t\t\t\t       struct smc_init_info *ini)\n{\n\tint rc = SMC_CLC_DECL_NOSMCDDEV;\n\tstruct smcd_dev *smcd;\n\tint i = 1;\n\tu16 chid;\n\n\tif (smcd_indicated(ini->smc_type_v1))\n\t\trc = 0;\t\t \n\tmutex_lock(&smcd_dev_list.mutex);\n\tlist_for_each_entry(smcd, &smcd_dev_list.list, list) {\n\t\tif (smcd->going_away || smcd == ini->ism_dev[0])\n\t\t\tcontinue;\n\t\tchid = smc_ism_get_chid(smcd);\n\t\tif (!smc_find_ism_v2_is_unique_chid(chid, ini, i))\n\t\t\tcontinue;\n\t\tif (!smc_pnet_is_pnetid_set(smcd->pnetid) ||\n\t\t    smc_pnet_is_ndev_pnetid(sock_net(&smc->sk), smcd->pnetid)) {\n\t\t\tini->ism_dev[i] = smcd;\n\t\t\tini->ism_chid[i] = chid;\n\t\t\tini->is_smcd = true;\n\t\t\trc = 0;\n\t\t\ti++;\n\t\t\tif (i > SMC_MAX_ISM_DEVS)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&smcd_dev_list.mutex);\n\tini->ism_offered_cnt = i - 1;\n\tif (!ini->ism_dev[0] && !ini->ism_dev[1])\n\t\tini->smcd_version = 0;\n\n\treturn rc;\n}\n\n \nstatic int smc_connect_ism_vlan_setup(struct smc_sock *smc,\n\t\t\t\t      struct smc_init_info *ini)\n{\n\tif (ini->vlan_id && smc_ism_get_vlan(ini->ism_dev[0], ini->vlan_id))\n\t\treturn SMC_CLC_DECL_ISMVLANERR;\n\treturn 0;\n}\n\nstatic int smc_find_proposal_devices(struct smc_sock *smc,\n\t\t\t\t     struct smc_init_info *ini)\n{\n\tint rc = 0;\n\n\t \n\tif (!(ini->smcd_version & SMC_V1) ||\n\t    smc_find_ism_device(smc, ini) ||\n\t    smc_connect_ism_vlan_setup(smc, ini))\n\t\tini->smcd_version &= ~SMC_V1;\n\t \n\n\t \n\tif (!(ini->smcr_version & SMC_V1) ||\n\t    smc_find_rdma_device(smc, ini))\n\t\tini->smcr_version &= ~SMC_V1;\n\t \n\n\tini->smc_type_v1 = smc_indicated_type(ini->smcd_version & SMC_V1,\n\t\t\t\t\t      ini->smcr_version & SMC_V1);\n\n\t \n\tif (!(ini->smcd_version & SMC_V2) ||\n\t    !smc_ism_is_v2_capable() ||\n\t    smc_find_ism_v2_device_clnt(smc, ini))\n\t\tini->smcd_version &= ~SMC_V2;\n\n\t \n\tini->check_smcrv2 = true;\n\tini->smcrv2.saddr = smc->clcsock->sk->sk_rcv_saddr;\n\tif (!(ini->smcr_version & SMC_V2) ||\n\t    smc->clcsock->sk->sk_family != AF_INET ||\n\t    !smc_clc_ueid_count() ||\n\t    smc_find_rdma_device(smc, ini))\n\t\tini->smcr_version &= ~SMC_V2;\n\tini->check_smcrv2 = false;\n\n\tini->smc_type_v2 = smc_indicated_type(ini->smcd_version & SMC_V2,\n\t\t\t\t\t      ini->smcr_version & SMC_V2);\n\n\t \n\tif (ini->smc_type_v1 == SMC_TYPE_N && ini->smc_type_v2 == SMC_TYPE_N)\n\t\trc = SMC_CLC_DECL_NOSMCDEV;\n\n\treturn rc;\n}\n\n \nstatic int smc_connect_ism_vlan_cleanup(struct smc_sock *smc,\n\t\t\t\t\tstruct smc_init_info *ini)\n{\n\tif (!smcd_indicated(ini->smc_type_v1))\n\t\treturn 0;\n\tif (ini->vlan_id && smc_ism_put_vlan(ini->ism_dev[0], ini->vlan_id))\n\t\treturn SMC_CLC_DECL_CNFERR;\n\treturn 0;\n}\n\n#define SMC_CLC_MAX_ACCEPT_LEN \\\n\t(sizeof(struct smc_clc_msg_accept_confirm_v2) + \\\n\t sizeof(struct smc_clc_first_contact_ext_v2x) + \\\n\t sizeof(struct smc_clc_msg_trail))\n\n \nstatic int smc_connect_clc(struct smc_sock *smc,\n\t\t\t   struct smc_clc_msg_accept_confirm_v2 *aclc2,\n\t\t\t   struct smc_init_info *ini)\n{\n\tint rc = 0;\n\n\t \n\trc = smc_clc_send_proposal(smc, ini);\n\tif (rc)\n\t\treturn rc;\n\t \n\treturn smc_clc_wait_msg(smc, aclc2, SMC_CLC_MAX_ACCEPT_LEN,\n\t\t\t\tSMC_CLC_ACCEPT, CLC_WAIT_TIME);\n}\n\nvoid smc_fill_gid_list(struct smc_link_group *lgr,\n\t\t       struct smc_gidlist *gidlist,\n\t\t       struct smc_ib_device *known_dev, u8 *known_gid)\n{\n\tstruct smc_init_info *alt_ini = NULL;\n\n\tmemset(gidlist, 0, sizeof(*gidlist));\n\tmemcpy(gidlist->list[gidlist->len++], known_gid, SMC_GID_SIZE);\n\n\talt_ini = kzalloc(sizeof(*alt_ini), GFP_KERNEL);\n\tif (!alt_ini)\n\t\tgoto out;\n\n\talt_ini->vlan_id = lgr->vlan_id;\n\talt_ini->check_smcrv2 = true;\n\talt_ini->smcrv2.saddr = lgr->saddr;\n\tsmc_pnet_find_alt_roce(lgr, alt_ini, known_dev);\n\n\tif (!alt_ini->smcrv2.ib_dev_v2)\n\t\tgoto out;\n\n\tmemcpy(gidlist->list[gidlist->len++], alt_ini->smcrv2.ib_gid_v2,\n\t       SMC_GID_SIZE);\n\nout:\n\tkfree(alt_ini);\n}\n\nstatic int smc_connect_rdma_v2_prepare(struct smc_sock *smc,\n\t\t\t\t       struct smc_clc_msg_accept_confirm *aclc,\n\t\t\t\t       struct smc_init_info *ini)\n{\n\tstruct smc_clc_msg_accept_confirm_v2 *clc_v2 =\n\t\t(struct smc_clc_msg_accept_confirm_v2 *)aclc;\n\tstruct smc_clc_first_contact_ext *fce =\n\t\tsmc_get_clc_first_contact_ext(clc_v2, false);\n\tstruct net *net = sock_net(&smc->sk);\n\tint rc;\n\n\tif (!ini->first_contact_peer || aclc->hdr.version == SMC_V1)\n\t\treturn 0;\n\n\tif (fce->v2_direct) {\n\t\tmemcpy(ini->smcrv2.nexthop_mac, &aclc->r0.lcl.mac, ETH_ALEN);\n\t\tini->smcrv2.uses_gateway = false;\n\t} else {\n\t\tif (smc_ib_find_route(net, smc->clcsock->sk->sk_rcv_saddr,\n\t\t\t\t      smc_ib_gid_to_ipv4(aclc->r0.lcl.gid),\n\t\t\t\t      ini->smcrv2.nexthop_mac,\n\t\t\t\t      &ini->smcrv2.uses_gateway))\n\t\t\treturn SMC_CLC_DECL_NOROUTE;\n\t\tif (!ini->smcrv2.uses_gateway) {\n\t\t\t \n\t\t\treturn SMC_CLC_DECL_NOINDIRECT;\n\t\t}\n\t}\n\n\tini->release_nr = fce->release;\n\trc = smc_clc_clnt_v2x_features_validate(fce, ini);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\n \nstatic int smc_connect_rdma(struct smc_sock *smc,\n\t\t\t    struct smc_clc_msg_accept_confirm *aclc,\n\t\t\t    struct smc_init_info *ini)\n{\n\tint i, reason_code = 0;\n\tstruct smc_link *link;\n\tu8 *eid = NULL;\n\n\tini->is_smcd = false;\n\tini->ib_clcqpn = ntoh24(aclc->r0.qpn);\n\tini->first_contact_peer = aclc->hdr.typev2 & SMC_FIRST_CONTACT_MASK;\n\tmemcpy(ini->peer_systemid, aclc->r0.lcl.id_for_peer, SMC_SYSTEMID_LEN);\n\tmemcpy(ini->peer_gid, aclc->r0.lcl.gid, SMC_GID_SIZE);\n\tmemcpy(ini->peer_mac, aclc->r0.lcl.mac, ETH_ALEN);\n\tini->max_conns = SMC_CONN_PER_LGR_MAX;\n\tini->max_links = SMC_LINKS_ADD_LNK_MAX;\n\n\treason_code = smc_connect_rdma_v2_prepare(smc, aclc, ini);\n\tif (reason_code)\n\t\treturn reason_code;\n\n\tmutex_lock(&smc_client_lgr_pending);\n\treason_code = smc_conn_create(smc, ini);\n\tif (reason_code) {\n\t\tmutex_unlock(&smc_client_lgr_pending);\n\t\treturn reason_code;\n\t}\n\n\tsmc_conn_save_peer_info(smc, aclc);\n\n\tif (ini->first_contact_local) {\n\t\tlink = smc->conn.lnk;\n\t} else {\n\t\t \n\t\tlink = NULL;\n\t\tfor (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {\n\t\t\tstruct smc_link *l = &smc->conn.lgr->lnk[i];\n\n\t\t\tif (l->peer_qpn == ntoh24(aclc->r0.qpn) &&\n\t\t\t    !memcmp(l->peer_gid, &aclc->r0.lcl.gid,\n\t\t\t\t    SMC_GID_SIZE) &&\n\t\t\t    (aclc->hdr.version > SMC_V1 ||\n\t\t\t     !memcmp(l->peer_mac, &aclc->r0.lcl.mac,\n\t\t\t\t     sizeof(l->peer_mac)))) {\n\t\t\t\tlink = l;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!link) {\n\t\t\treason_code = SMC_CLC_DECL_NOSRVLINK;\n\t\t\tgoto connect_abort;\n\t\t}\n\t\tsmc_switch_link_and_count(&smc->conn, link);\n\t}\n\n\t \n\tif (smc_buf_create(smc, false)) {\n\t\treason_code = SMC_CLC_DECL_MEM;\n\t\tgoto connect_abort;\n\t}\n\n\tif (ini->first_contact_local)\n\t\tsmc_link_save_peer_info(link, aclc, ini);\n\n\tif (smc_rmb_rtoken_handling(&smc->conn, link, aclc)) {\n\t\treason_code = SMC_CLC_DECL_ERR_RTOK;\n\t\tgoto connect_abort;\n\t}\n\n\tsmc_close_init(smc);\n\tsmc_rx_init(smc);\n\n\tif (ini->first_contact_local) {\n\t\tif (smc_ib_ready_link(link)) {\n\t\t\treason_code = SMC_CLC_DECL_ERR_RDYLNK;\n\t\t\tgoto connect_abort;\n\t\t}\n\t} else {\n\t\t \n\t\tif (smc->conn.sndbuf_desc->is_vm) {\n\t\t\tif (smcr_lgr_reg_sndbufs(link, smc->conn.sndbuf_desc)) {\n\t\t\t\treason_code = SMC_CLC_DECL_ERR_REGBUF;\n\t\t\t\tgoto connect_abort;\n\t\t\t}\n\t\t}\n\t\tif (smcr_lgr_reg_rmbs(link, smc->conn.rmb_desc)) {\n\t\t\treason_code = SMC_CLC_DECL_ERR_REGBUF;\n\t\t\tgoto connect_abort;\n\t\t}\n\t}\n\n\tif (aclc->hdr.version > SMC_V1) {\n\t\tstruct smc_clc_msg_accept_confirm_v2 *clc_v2 =\n\t\t\t(struct smc_clc_msg_accept_confirm_v2 *)aclc;\n\n\t\teid = clc_v2->r1.eid;\n\t\tif (ini->first_contact_local)\n\t\t\tsmc_fill_gid_list(link->lgr, &ini->smcrv2.gidlist,\n\t\t\t\t\t  link->smcibdev, link->gid);\n\t}\n\n\treason_code = smc_clc_send_confirm(smc, ini->first_contact_local,\n\t\t\t\t\t   aclc->hdr.version, eid, ini);\n\tif (reason_code)\n\t\tgoto connect_abort;\n\n\tsmc_tx_init(smc);\n\n\tif (ini->first_contact_local) {\n\t\t \n\t\tsmc_llc_flow_initiate(link->lgr, SMC_LLC_FLOW_ADD_LINK);\n\t\treason_code = smcr_clnt_conf_first_link(smc);\n\t\tsmc_llc_flow_stop(link->lgr, &link->lgr->llc_flow_lcl);\n\t\tif (reason_code)\n\t\t\tgoto connect_abort;\n\t}\n\tmutex_unlock(&smc_client_lgr_pending);\n\n\tsmc_copy_sock_settings_to_clc(smc);\n\tsmc->connect_nonblock = 0;\n\tif (smc->sk.sk_state == SMC_INIT)\n\t\tsmc->sk.sk_state = SMC_ACTIVE;\n\n\treturn 0;\nconnect_abort:\n\tsmc_conn_abort(smc, ini->first_contact_local);\n\tmutex_unlock(&smc_client_lgr_pending);\n\tsmc->connect_nonblock = 0;\n\n\treturn reason_code;\n}\n\n \nstatic int\nsmc_v2_determine_accepted_chid(struct smc_clc_msg_accept_confirm_v2 *aclc,\n\t\t\t       struct smc_init_info *ini)\n{\n\tint i;\n\n\tfor (i = 0; i < ini->ism_offered_cnt + 1; i++) {\n\t\tif (ini->ism_chid[i] == ntohs(aclc->d1.chid)) {\n\t\t\tini->ism_selected = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EPROTO;\n}\n\n \nstatic int smc_connect_ism(struct smc_sock *smc,\n\t\t\t   struct smc_clc_msg_accept_confirm *aclc,\n\t\t\t   struct smc_init_info *ini)\n{\n\tu8 *eid = NULL;\n\tint rc = 0;\n\n\tini->is_smcd = true;\n\tini->first_contact_peer = aclc->hdr.typev2 & SMC_FIRST_CONTACT_MASK;\n\n\tif (aclc->hdr.version == SMC_V2) {\n\t\tstruct smc_clc_msg_accept_confirm_v2 *aclc_v2 =\n\t\t\t(struct smc_clc_msg_accept_confirm_v2 *)aclc;\n\n\t\tif (ini->first_contact_peer) {\n\t\t\tstruct smc_clc_first_contact_ext *fce =\n\t\t\t\tsmc_get_clc_first_contact_ext(aclc_v2, true);\n\n\t\t\tini->release_nr = fce->release;\n\t\t\trc = smc_clc_clnt_v2x_features_validate(fce, ini);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\trc = smc_v2_determine_accepted_chid(aclc_v2, ini);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tini->ism_peer_gid[ini->ism_selected] = ntohll(aclc->d0.gid);\n\n\t \n\tmutex_lock(&smc_server_lgr_pending);\n\trc = smc_conn_create(smc, ini);\n\tif (rc) {\n\t\tmutex_unlock(&smc_server_lgr_pending);\n\t\treturn rc;\n\t}\n\n\t \n\trc = smc_buf_create(smc, true);\n\tif (rc) {\n\t\trc = (rc == -ENOSPC) ? SMC_CLC_DECL_MAX_DMB : SMC_CLC_DECL_MEM;\n\t\tgoto connect_abort;\n\t}\n\n\tsmc_conn_save_peer_info(smc, aclc);\n\tsmc_close_init(smc);\n\tsmc_rx_init(smc);\n\tsmc_tx_init(smc);\n\n\tif (aclc->hdr.version > SMC_V1) {\n\t\tstruct smc_clc_msg_accept_confirm_v2 *clc_v2 =\n\t\t\t(struct smc_clc_msg_accept_confirm_v2 *)aclc;\n\n\t\teid = clc_v2->d1.eid;\n\t}\n\n\trc = smc_clc_send_confirm(smc, ini->first_contact_local,\n\t\t\t\t  aclc->hdr.version, eid, ini);\n\tif (rc)\n\t\tgoto connect_abort;\n\tmutex_unlock(&smc_server_lgr_pending);\n\n\tsmc_copy_sock_settings_to_clc(smc);\n\tsmc->connect_nonblock = 0;\n\tif (smc->sk.sk_state == SMC_INIT)\n\t\tsmc->sk.sk_state = SMC_ACTIVE;\n\n\treturn 0;\nconnect_abort:\n\tsmc_conn_abort(smc, ini->first_contact_local);\n\tmutex_unlock(&smc_server_lgr_pending);\n\tsmc->connect_nonblock = 0;\n\n\treturn rc;\n}\n\n \nstatic int smc_connect_check_aclc(struct smc_init_info *ini,\n\t\t\t\t  struct smc_clc_msg_accept_confirm *aclc)\n{\n\tif (aclc->hdr.typev1 != SMC_TYPE_R &&\n\t    aclc->hdr.typev1 != SMC_TYPE_D)\n\t\treturn SMC_CLC_DECL_MODEUNSUPP;\n\n\tif (aclc->hdr.version >= SMC_V2) {\n\t\tif ((aclc->hdr.typev1 == SMC_TYPE_R &&\n\t\t     !smcr_indicated(ini->smc_type_v2)) ||\n\t\t    (aclc->hdr.typev1 == SMC_TYPE_D &&\n\t\t     !smcd_indicated(ini->smc_type_v2)))\n\t\t\treturn SMC_CLC_DECL_MODEUNSUPP;\n\t} else {\n\t\tif ((aclc->hdr.typev1 == SMC_TYPE_R &&\n\t\t     !smcr_indicated(ini->smc_type_v1)) ||\n\t\t    (aclc->hdr.typev1 == SMC_TYPE_D &&\n\t\t     !smcd_indicated(ini->smc_type_v1)))\n\t\t\treturn SMC_CLC_DECL_MODEUNSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __smc_connect(struct smc_sock *smc)\n{\n\tu8 version = smc_ism_is_v2_capable() ? SMC_V2 : SMC_V1;\n\tstruct smc_clc_msg_accept_confirm_v2 *aclc2;\n\tstruct smc_clc_msg_accept_confirm *aclc;\n\tstruct smc_init_info *ini = NULL;\n\tu8 *buf = NULL;\n\tint rc = 0;\n\n\tif (smc->use_fallback)\n\t\treturn smc_connect_fallback(smc, smc->fallback_rsn);\n\n\t \n\tif (!tcp_sk(smc->clcsock->sk)->syn_smc)\n\t\treturn smc_connect_fallback(smc, SMC_CLC_DECL_PEERNOSMC);\n\n\t \n\tif (using_ipsec(smc))\n\t\treturn smc_connect_decline_fallback(smc, SMC_CLC_DECL_IPSEC,\n\t\t\t\t\t\t    version);\n\n\tini = kzalloc(sizeof(*ini), GFP_KERNEL);\n\tif (!ini)\n\t\treturn smc_connect_decline_fallback(smc, SMC_CLC_DECL_MEM,\n\t\t\t\t\t\t    version);\n\n\tini->smcd_version = SMC_V1 | SMC_V2;\n\tini->smcr_version = SMC_V1 | SMC_V2;\n\tini->smc_type_v1 = SMC_TYPE_B;\n\tini->smc_type_v2 = SMC_TYPE_B;\n\n\t \n\tif (smc_vlan_by_tcpsk(smc->clcsock, ini)) {\n\t\tini->smcd_version &= ~SMC_V1;\n\t\tini->smcr_version = 0;\n\t\tini->smc_type_v1 = SMC_TYPE_N;\n\t\tif (!ini->smcd_version) {\n\t\t\trc = SMC_CLC_DECL_GETVLANERR;\n\t\t\tgoto fallback;\n\t\t}\n\t}\n\n\trc = smc_find_proposal_devices(smc, ini);\n\tif (rc)\n\t\tgoto fallback;\n\n\tbuf = kzalloc(SMC_CLC_MAX_ACCEPT_LEN, GFP_KERNEL);\n\tif (!buf) {\n\t\trc = SMC_CLC_DECL_MEM;\n\t\tgoto fallback;\n\t}\n\taclc2 = (struct smc_clc_msg_accept_confirm_v2 *)buf;\n\taclc = (struct smc_clc_msg_accept_confirm *)aclc2;\n\n\t \n\trc = smc_connect_clc(smc, aclc2, ini);\n\tif (rc) {\n\t\t \n\t\tif (rc == -EAGAIN) {\n\t\t\trc = -ETIMEDOUT;\n\t\t\tsmc->sk.sk_err = ETIMEDOUT;\n\t\t}\n\t\tgoto vlan_cleanup;\n\t}\n\n\t \n\trc = smc_connect_check_aclc(ini, aclc);\n\tversion = aclc->hdr.version == SMC_V1 ? SMC_V1 : SMC_V2;\n\tif (rc)\n\t\tgoto vlan_cleanup;\n\n\t \n\tif (aclc->hdr.typev1 == SMC_TYPE_R) {\n\t\tini->smcr_version = version;\n\t\trc = smc_connect_rdma(smc, aclc, ini);\n\t} else if (aclc->hdr.typev1 == SMC_TYPE_D) {\n\t\tini->smcd_version = version;\n\t\trc = smc_connect_ism(smc, aclc, ini);\n\t}\n\tif (rc)\n\t\tgoto vlan_cleanup;\n\n\tSMC_STAT_CLNT_SUCC_INC(sock_net(smc->clcsock->sk), aclc);\n\tsmc_connect_ism_vlan_cleanup(smc, ini);\n\tkfree(buf);\n\tkfree(ini);\n\treturn 0;\n\nvlan_cleanup:\n\tsmc_connect_ism_vlan_cleanup(smc, ini);\n\tkfree(buf);\nfallback:\n\tkfree(ini);\n\treturn smc_connect_decline_fallback(smc, rc, version);\n}\n\nstatic void smc_connect_work(struct work_struct *work)\n{\n\tstruct smc_sock *smc = container_of(work, struct smc_sock,\n\t\t\t\t\t    connect_work);\n\tlong timeo = smc->sk.sk_sndtimeo;\n\tint rc = 0;\n\n\tif (!timeo)\n\t\ttimeo = MAX_SCHEDULE_TIMEOUT;\n\tlock_sock(smc->clcsock->sk);\n\tif (smc->clcsock->sk->sk_err) {\n\t\tsmc->sk.sk_err = smc->clcsock->sk->sk_err;\n\t} else if ((1 << smc->clcsock->sk->sk_state) &\n\t\t\t\t\t(TCPF_SYN_SENT | TCPF_SYN_RECV)) {\n\t\trc = sk_stream_wait_connect(smc->clcsock->sk, &timeo);\n\t\tif ((rc == -EPIPE) &&\n\t\t    ((1 << smc->clcsock->sk->sk_state) &\n\t\t\t\t\t(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)))\n\t\t\trc = 0;\n\t}\n\trelease_sock(smc->clcsock->sk);\n\tlock_sock(&smc->sk);\n\tif (rc != 0 || smc->sk.sk_err) {\n\t\tsmc->sk.sk_state = SMC_CLOSED;\n\t\tif (rc == -EPIPE || rc == -EAGAIN)\n\t\t\tsmc->sk.sk_err = EPIPE;\n\t\telse if (rc == -ECONNREFUSED)\n\t\t\tsmc->sk.sk_err = ECONNREFUSED;\n\t\telse if (signal_pending(current))\n\t\t\tsmc->sk.sk_err = -sock_intr_errno(timeo);\n\t\tsock_put(&smc->sk);  \n\t\tgoto out;\n\t}\n\n\trc = __smc_connect(smc);\n\tif (rc < 0)\n\t\tsmc->sk.sk_err = -rc;\n\nout:\n\tif (!sock_flag(&smc->sk, SOCK_DEAD)) {\n\t\tif (smc->sk.sk_err) {\n\t\t\tsmc->sk.sk_state_change(&smc->sk);\n\t\t} else {  \n\t\t\tsmc->clcsock->sk->sk_write_space(smc->clcsock->sk);\n\t\t\tsmc->sk.sk_write_space(&smc->sk);\n\t\t}\n\t}\n\trelease_sock(&smc->sk);\n}\n\nstatic int smc_connect(struct socket *sock, struct sockaddr *addr,\n\t\t       int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct smc_sock *smc;\n\tint rc = -EINVAL;\n\n\tsmc = smc_sk(sk);\n\n\t \n\tif (alen < sizeof(addr->sa_family))\n\t\tgoto out_err;\n\tif (addr->sa_family != AF_INET && addr->sa_family != AF_INET6)\n\t\tgoto out_err;\n\n\tlock_sock(sk);\n\tswitch (sock->state) {\n\tdefault:\n\t\trc = -EINVAL;\n\t\tgoto out;\n\tcase SS_CONNECTED:\n\t\trc = sk->sk_state == SMC_ACTIVE ? -EISCONN : -EINVAL;\n\t\tgoto out;\n\tcase SS_CONNECTING:\n\t\tif (sk->sk_state == SMC_ACTIVE)\n\t\t\tgoto connected;\n\t\tbreak;\n\tcase SS_UNCONNECTED:\n\t\tsock->state = SS_CONNECTING;\n\t\tbreak;\n\t}\n\n\tswitch (sk->sk_state) {\n\tdefault:\n\t\tgoto out;\n\tcase SMC_CLOSED:\n\t\trc = sock_error(sk) ? : -ECONNABORTED;\n\t\tsock->state = SS_UNCONNECTED;\n\t\tgoto out;\n\tcase SMC_ACTIVE:\n\t\trc = -EISCONN;\n\t\tgoto out;\n\tcase SMC_INIT:\n\t\tbreak;\n\t}\n\n\tsmc_copy_sock_settings_to_clc(smc);\n\ttcp_sk(smc->clcsock->sk)->syn_smc = 1;\n\tif (smc->connect_nonblock) {\n\t\trc = -EALREADY;\n\t\tgoto out;\n\t}\n\trc = kernel_connect(smc->clcsock, addr, alen, flags);\n\tif (rc && rc != -EINPROGRESS)\n\t\tgoto out;\n\n\tif (smc->use_fallback) {\n\t\tsock->state = rc ? SS_CONNECTING : SS_CONNECTED;\n\t\tgoto out;\n\t}\n\tsock_hold(&smc->sk);  \n\tif (flags & O_NONBLOCK) {\n\t\tif (queue_work(smc_hs_wq, &smc->connect_work))\n\t\t\tsmc->connect_nonblock = 1;\n\t\trc = -EINPROGRESS;\n\t\tgoto out;\n\t} else {\n\t\trc = __smc_connect(smc);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\nconnected:\n\trc = 0;\n\tsock->state = SS_CONNECTED;\nout:\n\trelease_sock(sk);\nout_err:\n\treturn rc;\n}\n\nstatic int smc_clcsock_accept(struct smc_sock *lsmc, struct smc_sock **new_smc)\n{\n\tstruct socket *new_clcsock = NULL;\n\tstruct sock *lsk = &lsmc->sk;\n\tstruct sock *new_sk;\n\tint rc = -EINVAL;\n\n\trelease_sock(lsk);\n\tnew_sk = smc_sock_alloc(sock_net(lsk), NULL, lsk->sk_protocol);\n\tif (!new_sk) {\n\t\trc = -ENOMEM;\n\t\tlsk->sk_err = ENOMEM;\n\t\t*new_smc = NULL;\n\t\tlock_sock(lsk);\n\t\tgoto out;\n\t}\n\t*new_smc = smc_sk(new_sk);\n\n\tmutex_lock(&lsmc->clcsock_release_lock);\n\tif (lsmc->clcsock)\n\t\trc = kernel_accept(lsmc->clcsock, &new_clcsock, SOCK_NONBLOCK);\n\tmutex_unlock(&lsmc->clcsock_release_lock);\n\tlock_sock(lsk);\n\tif  (rc < 0 && rc != -EAGAIN)\n\t\tlsk->sk_err = -rc;\n\tif (rc < 0 || lsk->sk_state == SMC_CLOSED) {\n\t\tnew_sk->sk_prot->unhash(new_sk);\n\t\tif (new_clcsock)\n\t\t\tsock_release(new_clcsock);\n\t\tnew_sk->sk_state = SMC_CLOSED;\n\t\tsmc_sock_set_flag(new_sk, SOCK_DEAD);\n\t\tsock_put(new_sk);  \n\t\t*new_smc = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tnew_clcsock->sk->sk_data_ready = lsmc->clcsk_data_ready;\n\n\t \n\tif (lsmc->use_fallback) {\n\t\tif (lsmc->clcsk_state_change)\n\t\t\tnew_clcsock->sk->sk_state_change = lsmc->clcsk_state_change;\n\t\tif (lsmc->clcsk_write_space)\n\t\t\tnew_clcsock->sk->sk_write_space = lsmc->clcsk_write_space;\n\t\tif (lsmc->clcsk_error_report)\n\t\t\tnew_clcsock->sk->sk_error_report = lsmc->clcsk_error_report;\n\t}\n\n\t(*new_smc)->clcsock = new_clcsock;\nout:\n\treturn rc;\n}\n\n \nstatic void smc_accept_enqueue(struct sock *parent, struct sock *sk)\n{\n\tstruct smc_sock *par = smc_sk(parent);\n\n\tsock_hold(sk);  \n\tspin_lock(&par->accept_q_lock);\n\tlist_add_tail(&smc_sk(sk)->accept_q, &par->accept_q);\n\tspin_unlock(&par->accept_q_lock);\n\tsk_acceptq_added(parent);\n}\n\n \nstatic void smc_accept_unlink(struct sock *sk)\n{\n\tstruct smc_sock *par = smc_sk(sk)->listen_smc;\n\n\tspin_lock(&par->accept_q_lock);\n\tlist_del_init(&smc_sk(sk)->accept_q);\n\tspin_unlock(&par->accept_q_lock);\n\tsk_acceptq_removed(&smc_sk(sk)->listen_smc->sk);\n\tsock_put(sk);  \n}\n\n \nstruct sock *smc_accept_dequeue(struct sock *parent,\n\t\t\t\tstruct socket *new_sock)\n{\n\tstruct smc_sock *isk, *n;\n\tstruct sock *new_sk;\n\n\tlist_for_each_entry_safe(isk, n, &smc_sk(parent)->accept_q, accept_q) {\n\t\tnew_sk = (struct sock *)isk;\n\n\t\tsmc_accept_unlink(new_sk);\n\t\tif (new_sk->sk_state == SMC_CLOSED) {\n\t\t\tnew_sk->sk_prot->unhash(new_sk);\n\t\t\tif (isk->clcsock) {\n\t\t\t\tsock_release(isk->clcsock);\n\t\t\t\tisk->clcsock = NULL;\n\t\t\t}\n\t\t\tsock_put(new_sk);  \n\t\t\tcontinue;\n\t\t}\n\t\tif (new_sock) {\n\t\t\tsock_graft(new_sk, new_sock);\n\t\t\tnew_sock->state = SS_CONNECTED;\n\t\t\tif (isk->use_fallback) {\n\t\t\t\tsmc_sk(new_sk)->clcsock->file = new_sock->file;\n\t\t\t\tisk->clcsock->file->private_data = isk->clcsock;\n\t\t\t}\n\t\t}\n\t\treturn new_sk;\n\t}\n\treturn NULL;\n}\n\n \nvoid smc_close_non_accepted(struct sock *sk)\n{\n\tstruct smc_sock *smc = smc_sk(sk);\n\n\tsock_hold(sk);  \n\tlock_sock(sk);\n\tif (!sk->sk_lingertime)\n\t\t \n\t\tWRITE_ONCE(sk->sk_lingertime, SMC_MAX_STREAM_WAIT_TIMEOUT);\n\t__smc_release(smc);\n\trelease_sock(sk);\n\tsock_put(sk);  \n\tsock_put(sk);  \n}\n\nstatic int smcr_serv_conf_first_link(struct smc_sock *smc)\n{\n\tstruct smc_link *link = smc->conn.lnk;\n\tstruct smc_llc_qentry *qentry;\n\tint rc;\n\n\t \n\tif (smc->conn.sndbuf_desc->is_vm) {\n\t\tif (smcr_link_reg_buf(link, smc->conn.sndbuf_desc))\n\t\t\treturn SMC_CLC_DECL_ERR_REGBUF;\n\t}\n\n\t \n\tif (smcr_link_reg_buf(link, smc->conn.rmb_desc))\n\t\treturn SMC_CLC_DECL_ERR_REGBUF;\n\n\t \n\trc = smc_llc_send_confirm_link(link, SMC_LLC_REQ);\n\tif (rc < 0)\n\t\treturn SMC_CLC_DECL_TIMEOUT_CL;\n\n\t \n\tqentry = smc_llc_wait(link->lgr, link, SMC_LLC_WAIT_TIME,\n\t\t\t      SMC_LLC_CONFIRM_LINK);\n\tif (!qentry) {\n\t\tstruct smc_clc_msg_decline dclc;\n\n\t\trc = smc_clc_wait_msg(smc, &dclc, sizeof(dclc),\n\t\t\t\t      SMC_CLC_DECLINE, CLC_WAIT_TIME_SHORT);\n\t\treturn rc == -EAGAIN ? SMC_CLC_DECL_TIMEOUT_CL : rc;\n\t}\n\tsmc_llc_save_peer_uid(qentry);\n\trc = smc_llc_eval_conf_link(qentry, SMC_LLC_RESP);\n\tsmc_llc_flow_qentry_del(&link->lgr->llc_flow_lcl);\n\tif (rc)\n\t\treturn SMC_CLC_DECL_RMBE_EC;\n\n\t \n\tsmc->conn.rmb_desc->is_conf_rkey = true;\n\n\tsmc_llc_link_active(link);\n\tsmcr_lgr_set_type(link->lgr, SMC_LGR_SINGLE);\n\n\tif (link->lgr->max_links > 1) {\n\t\tdown_write(&link->lgr->llc_conf_mutex);\n\t\t \n\t\tsmc_llc_srv_add_link(link, NULL);\n\t\tup_write(&link->lgr->llc_conf_mutex);\n\t}\n\treturn 0;\n}\n\n \nstatic void smc_listen_out(struct smc_sock *new_smc)\n{\n\tstruct smc_sock *lsmc = new_smc->listen_smc;\n\tstruct sock *newsmcsk = &new_smc->sk;\n\n\tif (tcp_sk(new_smc->clcsock->sk)->syn_smc)\n\t\tatomic_dec(&lsmc->queued_smc_hs);\n\n\tif (lsmc->sk.sk_state == SMC_LISTEN) {\n\t\tlock_sock_nested(&lsmc->sk, SINGLE_DEPTH_NESTING);\n\t\tsmc_accept_enqueue(&lsmc->sk, newsmcsk);\n\t\trelease_sock(&lsmc->sk);\n\t} else {  \n\t\tsmc_close_non_accepted(newsmcsk);\n\t}\n\n\t \n\tlsmc->sk.sk_data_ready(&lsmc->sk);\n\tsock_put(&lsmc->sk);  \n}\n\n \nstatic void smc_listen_out_connected(struct smc_sock *new_smc)\n{\n\tstruct sock *newsmcsk = &new_smc->sk;\n\n\tif (newsmcsk->sk_state == SMC_INIT)\n\t\tnewsmcsk->sk_state = SMC_ACTIVE;\n\n\tsmc_listen_out(new_smc);\n}\n\n \nstatic void smc_listen_out_err(struct smc_sock *new_smc)\n{\n\tstruct sock *newsmcsk = &new_smc->sk;\n\tstruct net *net = sock_net(newsmcsk);\n\n\tthis_cpu_inc(net->smc.smc_stats->srv_hshake_err_cnt);\n\tif (newsmcsk->sk_state == SMC_INIT)\n\t\tsock_put(&new_smc->sk);  \n\tnewsmcsk->sk_state = SMC_CLOSED;\n\n\tsmc_listen_out(new_smc);\n}\n\n \nstatic void smc_listen_decline(struct smc_sock *new_smc, int reason_code,\n\t\t\t       int local_first, u8 version)\n{\n\t \n\tsmc_conn_abort(new_smc, local_first);\n\tif (reason_code < 0 ||\n\t    smc_switch_to_fallback(new_smc, reason_code)) {\n\t\t \n\t\tsmc_listen_out_err(new_smc);\n\t\treturn;\n\t}\n\tif (reason_code && reason_code != SMC_CLC_DECL_PEERDECL) {\n\t\tif (smc_clc_send_decline(new_smc, reason_code, version) < 0) {\n\t\t\tsmc_listen_out_err(new_smc);\n\t\t\treturn;\n\t\t}\n\t}\n\tsmc_listen_out_connected(new_smc);\n}\n\n \nstatic int smc_listen_v2_check(struct smc_sock *new_smc,\n\t\t\t       struct smc_clc_msg_proposal *pclc,\n\t\t\t       struct smc_init_info *ini)\n{\n\tstruct smc_clc_smcd_v2_extension *pclc_smcd_v2_ext;\n\tstruct smc_clc_v2_extension *pclc_v2_ext;\n\tint rc = SMC_CLC_DECL_PEERNOSMC;\n\n\tini->smc_type_v1 = pclc->hdr.typev1;\n\tini->smc_type_v2 = pclc->hdr.typev2;\n\tini->smcd_version = smcd_indicated(ini->smc_type_v1) ? SMC_V1 : 0;\n\tini->smcr_version = smcr_indicated(ini->smc_type_v1) ? SMC_V1 : 0;\n\tif (pclc->hdr.version > SMC_V1) {\n\t\tif (smcd_indicated(ini->smc_type_v2))\n\t\t\tini->smcd_version |= SMC_V2;\n\t\tif (smcr_indicated(ini->smc_type_v2))\n\t\t\tini->smcr_version |= SMC_V2;\n\t}\n\tif (!(ini->smcd_version & SMC_V2) && !(ini->smcr_version & SMC_V2)) {\n\t\trc = SMC_CLC_DECL_PEERNOSMC;\n\t\tgoto out;\n\t}\n\tpclc_v2_ext = smc_get_clc_v2_ext(pclc);\n\tif (!pclc_v2_ext) {\n\t\tini->smcd_version &= ~SMC_V2;\n\t\tini->smcr_version &= ~SMC_V2;\n\t\trc = SMC_CLC_DECL_NOV2EXT;\n\t\tgoto out;\n\t}\n\tpclc_smcd_v2_ext = smc_get_clc_smcd_v2_ext(pclc_v2_ext);\n\tif (ini->smcd_version & SMC_V2) {\n\t\tif (!smc_ism_is_v2_capable()) {\n\t\t\tini->smcd_version &= ~SMC_V2;\n\t\t\trc = SMC_CLC_DECL_NOISM2SUPP;\n\t\t} else if (!pclc_smcd_v2_ext) {\n\t\t\tini->smcd_version &= ~SMC_V2;\n\t\t\trc = SMC_CLC_DECL_NOV2DEXT;\n\t\t} else if (!pclc_v2_ext->hdr.eid_cnt &&\n\t\t\t   !pclc_v2_ext->hdr.flag.seid) {\n\t\t\tini->smcd_version &= ~SMC_V2;\n\t\t\trc = SMC_CLC_DECL_NOUEID;\n\t\t}\n\t}\n\tif (ini->smcr_version & SMC_V2) {\n\t\tif (!pclc_v2_ext->hdr.eid_cnt) {\n\t\t\tini->smcr_version &= ~SMC_V2;\n\t\t\trc = SMC_CLC_DECL_NOUEID;\n\t\t}\n\t}\n\n\tini->release_nr = pclc_v2_ext->hdr.flag.release;\n\tif (pclc_v2_ext->hdr.flag.release > SMC_RELEASE)\n\t\tini->release_nr = SMC_RELEASE;\n\nout:\n\tif (!ini->smcd_version && !ini->smcr_version)\n\t\treturn rc;\n\n\treturn 0;\n}\n\n \nstatic int smc_listen_prfx_check(struct smc_sock *new_smc,\n\t\t\t\t struct smc_clc_msg_proposal *pclc)\n{\n\tstruct smc_clc_msg_proposal_prefix *pclc_prfx;\n\tstruct socket *newclcsock = new_smc->clcsock;\n\n\tif (pclc->hdr.typev1 == SMC_TYPE_N)\n\t\treturn 0;\n\tpclc_prfx = smc_clc_proposal_get_prefix(pclc);\n\tif (smc_clc_prfx_match(newclcsock, pclc_prfx))\n\t\treturn SMC_CLC_DECL_DIFFPREFIX;\n\n\treturn 0;\n}\n\n \nstatic int smc_listen_rdma_init(struct smc_sock *new_smc,\n\t\t\t\tstruct smc_init_info *ini)\n{\n\tint rc;\n\n\t \n\trc = smc_conn_create(new_smc, ini);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (smc_buf_create(new_smc, false)) {\n\t\tsmc_conn_abort(new_smc, ini->first_contact_local);\n\t\treturn SMC_CLC_DECL_MEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int smc_listen_ism_init(struct smc_sock *new_smc,\n\t\t\t       struct smc_init_info *ini)\n{\n\tint rc;\n\n\trc = smc_conn_create(new_smc, ini);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = smc_buf_create(new_smc, true);\n\tif (rc) {\n\t\tsmc_conn_abort(new_smc, ini->first_contact_local);\n\t\treturn (rc == -ENOSPC) ? SMC_CLC_DECL_MAX_DMB :\n\t\t\t\t\t SMC_CLC_DECL_MEM;\n\t}\n\n\treturn 0;\n}\n\nstatic bool smc_is_already_selected(struct smcd_dev *smcd,\n\t\t\t\t    struct smc_init_info *ini,\n\t\t\t\t    int matches)\n{\n\tint i;\n\n\tfor (i = 0; i < matches; i++)\n\t\tif (smcd == ini->ism_dev[i])\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void smc_check_ism_v2_match(struct smc_init_info *ini,\n\t\t\t\t   u16 proposed_chid, u64 proposed_gid,\n\t\t\t\t   unsigned int *matches)\n{\n\tstruct smcd_dev *smcd;\n\n\tlist_for_each_entry(smcd, &smcd_dev_list.list, list) {\n\t\tif (smcd->going_away)\n\t\t\tcontinue;\n\t\tif (smc_is_already_selected(smcd, ini, *matches))\n\t\t\tcontinue;\n\t\tif (smc_ism_get_chid(smcd) == proposed_chid &&\n\t\t    !smc_ism_cantalk(proposed_gid, ISM_RESERVED_VLANID, smcd)) {\n\t\t\tini->ism_peer_gid[*matches] = proposed_gid;\n\t\t\tini->ism_dev[*matches] = smcd;\n\t\t\t(*matches)++;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void smc_find_ism_store_rc(u32 rc, struct smc_init_info *ini)\n{\n\tif (!ini->rc)\n\t\tini->rc = rc;\n}\n\nstatic void smc_find_ism_v2_device_serv(struct smc_sock *new_smc,\n\t\t\t\t\tstruct smc_clc_msg_proposal *pclc,\n\t\t\t\t\tstruct smc_init_info *ini)\n{\n\tstruct smc_clc_smcd_v2_extension *smcd_v2_ext;\n\tstruct smc_clc_v2_extension *smc_v2_ext;\n\tstruct smc_clc_msg_smcd *pclc_smcd;\n\tunsigned int matches = 0;\n\tu8 smcd_version;\n\tu8 *eid = NULL;\n\tint i, rc;\n\n\tif (!(ini->smcd_version & SMC_V2) || !smcd_indicated(ini->smc_type_v2))\n\t\tgoto not_found;\n\n\tpclc_smcd = smc_get_clc_msg_smcd(pclc);\n\tsmc_v2_ext = smc_get_clc_v2_ext(pclc);\n\tsmcd_v2_ext = smc_get_clc_smcd_v2_ext(smc_v2_ext);\n\n\tmutex_lock(&smcd_dev_list.mutex);\n\tif (pclc_smcd->ism.chid)\n\t\t \n\t\tsmc_check_ism_v2_match(ini, ntohs(pclc_smcd->ism.chid),\n\t\t\t\t       ntohll(pclc_smcd->ism.gid), &matches);\n\tfor (i = 1; i <= smc_v2_ext->hdr.ism_gid_cnt; i++) {\n\t\t \n\t\tsmc_check_ism_v2_match(ini,\n\t\t\t\t       ntohs(smcd_v2_ext->gidchid[i - 1].chid),\n\t\t\t\t       ntohll(smcd_v2_ext->gidchid[i - 1].gid),\n\t\t\t\t       &matches);\n\t}\n\tmutex_unlock(&smcd_dev_list.mutex);\n\n\tif (!ini->ism_dev[0]) {\n\t\tsmc_find_ism_store_rc(SMC_CLC_DECL_NOSMCD2DEV, ini);\n\t\tgoto not_found;\n\t}\n\n\tsmc_ism_get_system_eid(&eid);\n\tif (!smc_clc_match_eid(ini->negotiated_eid, smc_v2_ext,\n\t\t\t       smcd_v2_ext->system_eid, eid))\n\t\tgoto not_found;\n\n\t \n\tsmcd_version = ini->smcd_version;\n\tfor (i = 0; i < matches; i++) {\n\t\tini->smcd_version = SMC_V2;\n\t\tini->is_smcd = true;\n\t\tini->ism_selected = i;\n\t\trc = smc_listen_ism_init(new_smc, ini);\n\t\tif (rc) {\n\t\t\tsmc_find_ism_store_rc(rc, ini);\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\treturn;  \n\t}\n\t \n\tini->smcd_version = smcd_version;\t \n\tini->negotiated_eid[0] = 0;\n\nnot_found:\n\tini->smcd_version &= ~SMC_V2;\n\tini->ism_dev[0] = NULL;\n\tini->is_smcd = false;\n}\n\nstatic void smc_find_ism_v1_device_serv(struct smc_sock *new_smc,\n\t\t\t\t\tstruct smc_clc_msg_proposal *pclc,\n\t\t\t\t\tstruct smc_init_info *ini)\n{\n\tstruct smc_clc_msg_smcd *pclc_smcd = smc_get_clc_msg_smcd(pclc);\n\tint rc = 0;\n\n\t \n\tif (!(ini->smcd_version & SMC_V1) || !smcd_indicated(ini->smc_type_v1))\n\t\tgoto not_found;\n\tini->is_smcd = true;  \n\tini->ism_peer_gid[0] = ntohll(pclc_smcd->ism.gid);\n\trc = smc_find_ism_device(new_smc, ini);\n\tif (rc)\n\t\tgoto not_found;\n\tini->ism_selected = 0;\n\trc = smc_listen_ism_init(new_smc, ini);\n\tif (!rc)\n\t\treturn;\t\t \n\nnot_found:\n\tsmc_find_ism_store_rc(rc, ini);\n\tini->smcd_version &= ~SMC_V1;\n\tini->ism_dev[0] = NULL;\n\tini->is_smcd = false;\n}\n\n \nstatic int smc_listen_rdma_reg(struct smc_sock *new_smc, bool local_first)\n{\n\tstruct smc_connection *conn = &new_smc->conn;\n\n\tif (!local_first) {\n\t\t \n\t\tif (conn->sndbuf_desc->is_vm) {\n\t\t\tif (smcr_lgr_reg_sndbufs(conn->lnk,\n\t\t\t\t\t\t conn->sndbuf_desc))\n\t\t\t\treturn SMC_CLC_DECL_ERR_REGBUF;\n\t\t}\n\t\tif (smcr_lgr_reg_rmbs(conn->lnk, conn->rmb_desc))\n\t\t\treturn SMC_CLC_DECL_ERR_REGBUF;\n\t}\n\n\treturn 0;\n}\n\nstatic void smc_find_rdma_v2_device_serv(struct smc_sock *new_smc,\n\t\t\t\t\t struct smc_clc_msg_proposal *pclc,\n\t\t\t\t\t struct smc_init_info *ini)\n{\n\tstruct smc_clc_v2_extension *smc_v2_ext;\n\tu8 smcr_version;\n\tint rc;\n\n\tif (!(ini->smcr_version & SMC_V2) || !smcr_indicated(ini->smc_type_v2))\n\t\tgoto not_found;\n\n\tsmc_v2_ext = smc_get_clc_v2_ext(pclc);\n\tif (!smc_clc_match_eid(ini->negotiated_eid, smc_v2_ext, NULL, NULL))\n\t\tgoto not_found;\n\n\t \n\tmemcpy(ini->peer_systemid, pclc->lcl.id_for_peer, SMC_SYSTEMID_LEN);\n\tmemcpy(ini->peer_gid, smc_v2_ext->roce, SMC_GID_SIZE);\n\tmemcpy(ini->peer_mac, pclc->lcl.mac, ETH_ALEN);\n\tini->check_smcrv2 = true;\n\tini->smcrv2.clc_sk = new_smc->clcsock->sk;\n\tini->smcrv2.saddr = new_smc->clcsock->sk->sk_rcv_saddr;\n\tini->smcrv2.daddr = smc_ib_gid_to_ipv4(smc_v2_ext->roce);\n\trc = smc_find_rdma_device(new_smc, ini);\n\tif (rc) {\n\t\tsmc_find_ism_store_rc(rc, ini);\n\t\tgoto not_found;\n\t}\n\tif (!ini->smcrv2.uses_gateway)\n\t\tmemcpy(ini->smcrv2.nexthop_mac, pclc->lcl.mac, ETH_ALEN);\n\n\tsmcr_version = ini->smcr_version;\n\tini->smcr_version = SMC_V2;\n\trc = smc_listen_rdma_init(new_smc, ini);\n\tif (!rc) {\n\t\trc = smc_listen_rdma_reg(new_smc, ini->first_contact_local);\n\t\tif (rc)\n\t\t\tsmc_conn_abort(new_smc, ini->first_contact_local);\n\t}\n\tif (!rc)\n\t\treturn;\n\tini->smcr_version = smcr_version;\n\tsmc_find_ism_store_rc(rc, ini);\n\nnot_found:\n\tini->smcr_version &= ~SMC_V2;\n\tini->smcrv2.ib_dev_v2 = NULL;\n\tini->check_smcrv2 = false;\n}\n\nstatic int smc_find_rdma_v1_device_serv(struct smc_sock *new_smc,\n\t\t\t\t\tstruct smc_clc_msg_proposal *pclc,\n\t\t\t\t\tstruct smc_init_info *ini)\n{\n\tint rc;\n\n\tif (!(ini->smcr_version & SMC_V1) || !smcr_indicated(ini->smc_type_v1))\n\t\treturn SMC_CLC_DECL_NOSMCDEV;\n\n\t \n\tmemcpy(ini->peer_systemid, pclc->lcl.id_for_peer, SMC_SYSTEMID_LEN);\n\tmemcpy(ini->peer_gid, pclc->lcl.gid, SMC_GID_SIZE);\n\tmemcpy(ini->peer_mac, pclc->lcl.mac, ETH_ALEN);\n\trc = smc_find_rdma_device(new_smc, ini);\n\tif (rc) {\n\t\t \n\t\treturn SMC_CLC_DECL_NOSMCDEV;\n\t}\n\trc = smc_listen_rdma_init(new_smc, ini);\n\tif (rc)\n\t\treturn rc;\n\treturn smc_listen_rdma_reg(new_smc, ini->first_contact_local);\n}\n\n \nstatic int smc_listen_find_device(struct smc_sock *new_smc,\n\t\t\t\t  struct smc_clc_msg_proposal *pclc,\n\t\t\t\t  struct smc_init_info *ini)\n{\n\tint prfx_rc;\n\n\t \n\tsmc_find_ism_v2_device_serv(new_smc, pclc, ini);\n\tif (ini->ism_dev[0])\n\t\treturn 0;\n\n\t \n\tprfx_rc = smc_listen_prfx_check(new_smc, pclc);\n\tif (prfx_rc)\n\t\tsmc_find_ism_store_rc(prfx_rc, ini);\n\n\t \n\tif (smc_vlan_by_tcpsk(new_smc->clcsock, ini))\n\t\treturn ini->rc ?: SMC_CLC_DECL_GETVLANERR;\n\n\t \n\tif (!prfx_rc)\n\t\tsmc_find_ism_v1_device_serv(new_smc, pclc, ini);\n\tif (ini->ism_dev[0])\n\t\treturn 0;\n\n\tif (!smcr_indicated(pclc->hdr.typev1) &&\n\t    !smcr_indicated(pclc->hdr.typev2))\n\t\t \n\t\treturn ini->rc ?: SMC_CLC_DECL_NOSMCDDEV;\n\n\t \n\tsmc_find_rdma_v2_device_serv(new_smc, pclc, ini);\n\tif (ini->smcrv2.ib_dev_v2)\n\t\treturn 0;\n\n\t \n\tif (!prfx_rc) {\n\t\tint rc;\n\n\t\trc = smc_find_rdma_v1_device_serv(new_smc, pclc, ini);\n\t\tsmc_find_ism_store_rc(rc, ini);\n\t\treturn (!rc) ? 0 : ini->rc;\n\t}\n\treturn prfx_rc;\n}\n\n \nstatic int smc_listen_rdma_finish(struct smc_sock *new_smc,\n\t\t\t\t  struct smc_clc_msg_accept_confirm *cclc,\n\t\t\t\t  bool local_first,\n\t\t\t\t  struct smc_init_info *ini)\n{\n\tstruct smc_link *link = new_smc->conn.lnk;\n\tint reason_code = 0;\n\n\tif (local_first)\n\t\tsmc_link_save_peer_info(link, cclc, ini);\n\n\tif (smc_rmb_rtoken_handling(&new_smc->conn, link, cclc))\n\t\treturn SMC_CLC_DECL_ERR_RTOK;\n\n\tif (local_first) {\n\t\tif (smc_ib_ready_link(link))\n\t\t\treturn SMC_CLC_DECL_ERR_RDYLNK;\n\t\t \n\t\tsmc_llc_flow_initiate(link->lgr, SMC_LLC_FLOW_ADD_LINK);\n\t\treason_code = smcr_serv_conf_first_link(new_smc);\n\t\tsmc_llc_flow_stop(link->lgr, &link->lgr->llc_flow_lcl);\n\t}\n\treturn reason_code;\n}\n\n \nstatic void smc_listen_work(struct work_struct *work)\n{\n\tstruct smc_sock *new_smc = container_of(work, struct smc_sock,\n\t\t\t\t\t\tsmc_listen_work);\n\tstruct socket *newclcsock = new_smc->clcsock;\n\tstruct smc_clc_msg_accept_confirm *cclc;\n\tstruct smc_clc_msg_proposal_area *buf;\n\tstruct smc_clc_msg_proposal *pclc;\n\tstruct smc_init_info *ini = NULL;\n\tu8 proposal_version = SMC_V1;\n\tu8 accept_version;\n\tint rc = 0;\n\n\tif (new_smc->listen_smc->sk.sk_state != SMC_LISTEN)\n\t\treturn smc_listen_out_err(new_smc);\n\n\tif (new_smc->use_fallback) {\n\t\tsmc_listen_out_connected(new_smc);\n\t\treturn;\n\t}\n\n\t \n\tif (!tcp_sk(newclcsock->sk)->syn_smc) {\n\t\trc = smc_switch_to_fallback(new_smc, SMC_CLC_DECL_PEERNOSMC);\n\t\tif (rc)\n\t\t\tsmc_listen_out_err(new_smc);\n\t\telse\n\t\t\tsmc_listen_out_connected(new_smc);\n\t\treturn;\n\t}\n\n\t \n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf) {\n\t\trc = SMC_CLC_DECL_MEM;\n\t\tgoto out_decl;\n\t}\n\tpclc = (struct smc_clc_msg_proposal *)buf;\n\trc = smc_clc_wait_msg(new_smc, pclc, sizeof(*buf),\n\t\t\t      SMC_CLC_PROPOSAL, CLC_WAIT_TIME);\n\tif (rc)\n\t\tgoto out_decl;\n\n\tif (pclc->hdr.version > SMC_V1)\n\t\tproposal_version = SMC_V2;\n\n\t \n\tif (using_ipsec(new_smc)) {\n\t\trc = SMC_CLC_DECL_IPSEC;\n\t\tgoto out_decl;\n\t}\n\n\tini = kzalloc(sizeof(*ini), GFP_KERNEL);\n\tif (!ini) {\n\t\trc = SMC_CLC_DECL_MEM;\n\t\tgoto out_decl;\n\t}\n\n\t \n\trc = smc_listen_v2_check(new_smc, pclc, ini);\n\tif (rc)\n\t\tgoto out_decl;\n\n\trc = smc_clc_srv_v2x_features_validate(pclc, ini);\n\tif (rc)\n\t\tgoto out_decl;\n\n\tmutex_lock(&smc_server_lgr_pending);\n\tsmc_close_init(new_smc);\n\tsmc_rx_init(new_smc);\n\tsmc_tx_init(new_smc);\n\n\t \n\trc = smc_listen_find_device(new_smc, pclc, ini);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t \n\taccept_version = ini->is_smcd ? ini->smcd_version : ini->smcr_version;\n\trc = smc_clc_send_accept(new_smc, ini->first_contact_local,\n\t\t\t\t accept_version, ini->negotiated_eid, ini);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t \n\tif (ini->is_smcd)\n\t\tmutex_unlock(&smc_server_lgr_pending);\n\n\t \n\tmemset(buf, 0, sizeof(*buf));\n\tcclc = (struct smc_clc_msg_accept_confirm *)buf;\n\trc = smc_clc_wait_msg(new_smc, cclc, sizeof(*buf),\n\t\t\t      SMC_CLC_CONFIRM, CLC_WAIT_TIME);\n\tif (rc) {\n\t\tif (!ini->is_smcd)\n\t\t\tgoto out_unlock;\n\t\tgoto out_decl;\n\t}\n\n\trc = smc_clc_v2x_features_confirm_check(cclc, ini);\n\tif (rc) {\n\t\tif (!ini->is_smcd)\n\t\t\tgoto out_unlock;\n\t\tgoto out_decl;\n\t}\n\n\t \n\tsmc_conn_save_peer_info_fce(new_smc, cclc);\n\n\t \n\tif (!ini->is_smcd) {\n\t\trc = smc_listen_rdma_finish(new_smc, cclc,\n\t\t\t\t\t    ini->first_contact_local, ini);\n\t\tif (rc)\n\t\t\tgoto out_unlock;\n\t\tmutex_unlock(&smc_server_lgr_pending);\n\t}\n\tsmc_conn_save_peer_info(new_smc, cclc);\n\tsmc_listen_out_connected(new_smc);\n\tSMC_STAT_SERV_SUCC_INC(sock_net(newclcsock->sk), ini);\n\tgoto out_free;\n\nout_unlock:\n\tmutex_unlock(&smc_server_lgr_pending);\nout_decl:\n\tsmc_listen_decline(new_smc, rc, ini ? ini->first_contact_local : 0,\n\t\t\t   proposal_version);\nout_free:\n\tkfree(ini);\n\tkfree(buf);\n}\n\nstatic void smc_tcp_listen_work(struct work_struct *work)\n{\n\tstruct smc_sock *lsmc = container_of(work, struct smc_sock,\n\t\t\t\t\t     tcp_listen_work);\n\tstruct sock *lsk = &lsmc->sk;\n\tstruct smc_sock *new_smc;\n\tint rc = 0;\n\n\tlock_sock(lsk);\n\twhile (lsk->sk_state == SMC_LISTEN) {\n\t\trc = smc_clcsock_accept(lsmc, &new_smc);\n\t\tif (rc)  \n\t\t\tgoto out;\n\t\tif (!new_smc)\n\t\t\tcontinue;\n\n\t\tif (tcp_sk(new_smc->clcsock->sk)->syn_smc)\n\t\t\tatomic_inc(&lsmc->queued_smc_hs);\n\n\t\tnew_smc->listen_smc = lsmc;\n\t\tnew_smc->use_fallback = lsmc->use_fallback;\n\t\tnew_smc->fallback_rsn = lsmc->fallback_rsn;\n\t\tsock_hold(lsk);  \n\t\tINIT_WORK(&new_smc->smc_listen_work, smc_listen_work);\n\t\tsmc_copy_sock_settings_to_smc(new_smc);\n\t\tsock_hold(&new_smc->sk);  \n\t\tif (!queue_work(smc_hs_wq, &new_smc->smc_listen_work))\n\t\t\tsock_put(&new_smc->sk);\n\t}\n\nout:\n\trelease_sock(lsk);\n\tsock_put(&lsmc->sk);  \n}\n\nstatic void smc_clcsock_data_ready(struct sock *listen_clcsock)\n{\n\tstruct smc_sock *lsmc;\n\n\tread_lock_bh(&listen_clcsock->sk_callback_lock);\n\tlsmc = smc_clcsock_user_data(listen_clcsock);\n\tif (!lsmc)\n\t\tgoto out;\n\tlsmc->clcsk_data_ready(listen_clcsock);\n\tif (lsmc->sk.sk_state == SMC_LISTEN) {\n\t\tsock_hold(&lsmc->sk);  \n\t\tif (!queue_work(smc_tcp_ls_wq, &lsmc->tcp_listen_work))\n\t\t\tsock_put(&lsmc->sk);\n\t}\nout:\n\tread_unlock_bh(&listen_clcsock->sk_callback_lock);\n}\n\nstatic int smc_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct smc_sock *smc;\n\tint rc;\n\n\tsmc = smc_sk(sk);\n\tlock_sock(sk);\n\n\trc = -EINVAL;\n\tif ((sk->sk_state != SMC_INIT && sk->sk_state != SMC_LISTEN) ||\n\t    smc->connect_nonblock || sock->state != SS_UNCONNECTED)\n\t\tgoto out;\n\n\trc = 0;\n\tif (sk->sk_state == SMC_LISTEN) {\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tgoto out;\n\t}\n\t \n\tsmc_copy_sock_settings_to_clc(smc);\n\tif (!smc->use_fallback)\n\t\ttcp_sk(smc->clcsock->sk)->syn_smc = 1;\n\n\t \n\twrite_lock_bh(&smc->clcsock->sk->sk_callback_lock);\n\tsmc->clcsock->sk->sk_user_data =\n\t\t(void *)((uintptr_t)smc | SK_USER_DATA_NOCOPY);\n\tsmc_clcsock_replace_cb(&smc->clcsock->sk->sk_data_ready,\n\t\t\t       smc_clcsock_data_ready, &smc->clcsk_data_ready);\n\twrite_unlock_bh(&smc->clcsock->sk->sk_callback_lock);\n\n\t \n\tsmc->ori_af_ops = inet_csk(smc->clcsock->sk)->icsk_af_ops;\n\n\tsmc->af_ops = *smc->ori_af_ops;\n\tsmc->af_ops.syn_recv_sock = smc_tcp_syn_recv_sock;\n\n\tinet_csk(smc->clcsock->sk)->icsk_af_ops = &smc->af_ops;\n\n\tif (smc->limit_smc_hs)\n\t\ttcp_sk(smc->clcsock->sk)->smc_hs_congested = smc_hs_congested;\n\n\trc = kernel_listen(smc->clcsock, backlog);\n\tif (rc) {\n\t\twrite_lock_bh(&smc->clcsock->sk->sk_callback_lock);\n\t\tsmc_clcsock_restore_cb(&smc->clcsock->sk->sk_data_ready,\n\t\t\t\t       &smc->clcsk_data_ready);\n\t\tsmc->clcsock->sk->sk_user_data = NULL;\n\t\twrite_unlock_bh(&smc->clcsock->sk->sk_callback_lock);\n\t\tgoto out;\n\t}\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\tsk->sk_state = SMC_LISTEN;\n\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int smc_accept(struct socket *sock, struct socket *new_sock,\n\t\t      int flags, bool kern)\n{\n\tstruct sock *sk = sock->sk, *nsk;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct smc_sock *lsmc;\n\tlong timeo;\n\tint rc = 0;\n\n\tlsmc = smc_sk(sk);\n\tsock_hold(sk);  \n\tlock_sock(sk);\n\n\tif (lsmc->sk.sk_state != SMC_LISTEN) {\n\t\trc = -EINVAL;\n\t\trelease_sock(sk);\n\t\tgoto out;\n\t}\n\n\t \n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (!(nsk = smc_accept_dequeue(sk, new_sock))) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (!timeo) {\n\t\t\trc = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\trelease_sock(sk);\n\t\ttimeo = schedule_timeout(timeo);\n\t\t \n\t\tsched_annotate_sleep();\n\t\tlock_sock(sk);\n\t\tif (signal_pending(current)) {\n\t\t\trc = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (!rc)\n\t\trc = sock_error(nsk);\n\trelease_sock(sk);\n\tif (rc)\n\t\tgoto out;\n\n\tif (lsmc->sockopt_defer_accept && !(flags & O_NONBLOCK)) {\n\t\t \n\t\ttimeo = msecs_to_jiffies(lsmc->sockopt_defer_accept *\n\t\t\t\t\t\t\t\tMSEC_PER_SEC);\n\t\tif (smc_sk(nsk)->use_fallback) {\n\t\t\tstruct sock *clcsk = smc_sk(nsk)->clcsock->sk;\n\n\t\t\tlock_sock(clcsk);\n\t\t\tif (skb_queue_empty(&clcsk->sk_receive_queue))\n\t\t\t\tsk_wait_data(clcsk, &timeo, NULL);\n\t\t\trelease_sock(clcsk);\n\t\t} else if (!atomic_read(&smc_sk(nsk)->conn.bytes_to_rcv)) {\n\t\t\tlock_sock(nsk);\n\t\t\tsmc_rx_wait(smc_sk(nsk), &timeo, smc_rx_data_available);\n\t\t\trelease_sock(nsk);\n\t\t}\n\t}\n\nout:\n\tsock_put(sk);  \n\treturn rc;\n}\n\nstatic int smc_getname(struct socket *sock, struct sockaddr *addr,\n\t\t       int peer)\n{\n\tstruct smc_sock *smc;\n\n\tif (peer && (sock->sk->sk_state != SMC_ACTIVE) &&\n\t    (sock->sk->sk_state != SMC_APPCLOSEWAIT1))\n\t\treturn -ENOTCONN;\n\n\tsmc = smc_sk(sock->sk);\n\n\treturn smc->clcsock->ops->getname(smc->clcsock, addr, peer);\n}\n\nstatic int smc_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct smc_sock *smc;\n\tint rc;\n\n\tsmc = smc_sk(sk);\n\tlock_sock(sk);\n\n\t \n\tif (msg->msg_flags & MSG_FASTOPEN) {\n\t\t \n\t\tif (sk->sk_state == SMC_INIT && !smc->connect_nonblock) {\n\t\t\trc = smc_switch_to_fallback(smc, SMC_CLC_DECL_OPTUNSUPP);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((sk->sk_state != SMC_ACTIVE) &&\n\t\t   (sk->sk_state != SMC_APPCLOSEWAIT1) &&\n\t\t   (sk->sk_state != SMC_INIT)) {\n\t\trc = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tif (smc->use_fallback) {\n\t\trc = smc->clcsock->ops->sendmsg(smc->clcsock, msg, len);\n\t} else {\n\t\trc = smc_tx_sendmsg(smc, msg, len);\n\t\tSMC_STAT_TX_PAYLOAD(smc, len, rc);\n\t}\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int smc_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct smc_sock *smc;\n\tint rc = -ENOTCONN;\n\n\tsmc = smc_sk(sk);\n\tlock_sock(sk);\n\tif (sk->sk_state == SMC_CLOSED && (sk->sk_shutdown & RCV_SHUTDOWN)) {\n\t\t \n\t\trc = 0;\n\t\tgoto out;\n\t}\n\tif ((sk->sk_state == SMC_INIT) ||\n\t    (sk->sk_state == SMC_LISTEN) ||\n\t    (sk->sk_state == SMC_CLOSED))\n\t\tgoto out;\n\n\tif (sk->sk_state == SMC_PEERFINCLOSEWAIT) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (smc->use_fallback) {\n\t\trc = smc->clcsock->ops->recvmsg(smc->clcsock, msg, len, flags);\n\t} else {\n\t\tmsg->msg_namelen = 0;\n\t\trc = smc_rx_recvmsg(smc, msg, NULL, len, flags);\n\t\tSMC_STAT_RX_PAYLOAD(smc, rc, rc);\n\t}\n\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic __poll_t smc_accept_poll(struct sock *parent)\n{\n\tstruct smc_sock *isk = smc_sk(parent);\n\t__poll_t mask = 0;\n\n\tspin_lock(&isk->accept_q_lock);\n\tif (!list_empty(&isk->accept_q))\n\t\tmask = EPOLLIN | EPOLLRDNORM;\n\tspin_unlock(&isk->accept_q_lock);\n\n\treturn mask;\n}\n\nstatic __poll_t smc_poll(struct file *file, struct socket *sock,\n\t\t\t     poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct smc_sock *smc;\n\t__poll_t mask = 0;\n\n\tif (!sk)\n\t\treturn EPOLLNVAL;\n\n\tsmc = smc_sk(sock->sk);\n\tif (smc->use_fallback) {\n\t\t \n\t\tmask = smc->clcsock->ops->poll(file, smc->clcsock, wait);\n\t\tsk->sk_err = smc->clcsock->sk->sk_err;\n\t} else {\n\t\tif (sk->sk_state != SMC_CLOSED)\n\t\t\tsock_poll_wait(file, sock, wait);\n\t\tif (sk->sk_err)\n\t\t\tmask |= EPOLLERR;\n\t\tif ((sk->sk_shutdown == SHUTDOWN_MASK) ||\n\t\t    (sk->sk_state == SMC_CLOSED))\n\t\t\tmask |= EPOLLHUP;\n\t\tif (sk->sk_state == SMC_LISTEN) {\n\t\t\t \n\t\t\tmask |= smc_accept_poll(sk);\n\t\t} else if (smc->use_fallback) {  \n\t\t\tmask |= smc->clcsock->ops->poll(file, smc->clcsock,\n\t\t\t\t\t\t\t   wait);\n\t\t\tsk->sk_err = smc->clcsock->sk->sk_err;\n\t\t} else {\n\t\t\tif ((sk->sk_state != SMC_INIT &&\n\t\t\t     atomic_read(&smc->conn.sndbuf_space)) ||\n\t\t\t    sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t\t\t} else {\n\t\t\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\t\t\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\t\t}\n\t\t\tif (atomic_read(&smc->conn.bytes_to_rcv))\n\t\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tmask |= EPOLLIN | EPOLLRDNORM | EPOLLRDHUP;\n\t\t\tif (sk->sk_state == SMC_APPCLOSEWAIT1)\n\t\t\t\tmask |= EPOLLIN;\n\t\t\tif (smc->conn.urg_state == SMC_URG_VALID)\n\t\t\t\tmask |= EPOLLPRI;\n\t\t}\n\t}\n\n\treturn mask;\n}\n\nstatic int smc_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tbool do_shutdown = true;\n\tstruct smc_sock *smc;\n\tint rc = -EINVAL;\n\tint old_state;\n\tint rc1 = 0;\n\n\tsmc = smc_sk(sk);\n\n\tif ((how < SHUT_RD) || (how > SHUT_RDWR))\n\t\treturn rc;\n\n\tlock_sock(sk);\n\n\tif (sock->state == SS_CONNECTING) {\n\t\tif (sk->sk_state == SMC_ACTIVE)\n\t\t\tsock->state = SS_CONNECTED;\n\t\telse if (sk->sk_state == SMC_PEERCLOSEWAIT1 ||\n\t\t\t sk->sk_state == SMC_PEERCLOSEWAIT2 ||\n\t\t\t sk->sk_state == SMC_APPCLOSEWAIT1 ||\n\t\t\t sk->sk_state == SMC_APPCLOSEWAIT2 ||\n\t\t\t sk->sk_state == SMC_APPFINCLOSEWAIT)\n\t\t\tsock->state = SS_DISCONNECTING;\n\t}\n\n\trc = -ENOTCONN;\n\tif ((sk->sk_state != SMC_ACTIVE) &&\n\t    (sk->sk_state != SMC_PEERCLOSEWAIT1) &&\n\t    (sk->sk_state != SMC_PEERCLOSEWAIT2) &&\n\t    (sk->sk_state != SMC_APPCLOSEWAIT1) &&\n\t    (sk->sk_state != SMC_APPCLOSEWAIT2) &&\n\t    (sk->sk_state != SMC_APPFINCLOSEWAIT))\n\t\tgoto out;\n\tif (smc->use_fallback) {\n\t\trc = kernel_sock_shutdown(smc->clcsock, how);\n\t\tsk->sk_shutdown = smc->clcsock->sk->sk_shutdown;\n\t\tif (sk->sk_shutdown == SHUTDOWN_MASK) {\n\t\t\tsk->sk_state = SMC_CLOSED;\n\t\t\tsk->sk_socket->state = SS_UNCONNECTED;\n\t\t\tsock_put(sk);\n\t\t}\n\t\tgoto out;\n\t}\n\tswitch (how) {\n\tcase SHUT_RDWR:\t\t \n\t\told_state = sk->sk_state;\n\t\trc = smc_close_active(smc);\n\t\tif (old_state == SMC_ACTIVE &&\n\t\t    sk->sk_state == SMC_PEERCLOSEWAIT1)\n\t\t\tdo_shutdown = false;\n\t\tbreak;\n\tcase SHUT_WR:\n\t\trc = smc_close_shutdown_write(smc);\n\t\tbreak;\n\tcase SHUT_RD:\n\t\trc = 0;\n\t\t \n\t\tbreak;\n\t}\n\tif (do_shutdown && smc->clcsock)\n\t\trc1 = kernel_sock_shutdown(smc->clcsock, how);\n\t \n\tsk->sk_shutdown |= how + 1;\n\n\tif (sk->sk_state == SMC_CLOSED)\n\t\tsock->state = SS_UNCONNECTED;\n\telse\n\t\tsock->state = SS_DISCONNECTING;\nout:\n\trelease_sock(sk);\n\treturn rc ? rc : rc1;\n}\n\nstatic int __smc_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct smc_sock *smc;\n\tint val, len;\n\n\tsmc = smc_sk(sock->sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlen = min_t(int, len, sizeof(int));\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase SMC_LIMIT_HS:\n\t\tval = smc->limit_smc_hs;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int __smc_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t    sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct smc_sock *smc;\n\tint val, rc;\n\n\tsmc = smc_sk(sk);\n\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase SMC_LIMIT_HS:\n\t\tif (optlen < sizeof(int)) {\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_sockptr(&val, optval, sizeof(int))) {\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tsmc->limit_smc_hs = !!val;\n\t\trc = 0;\n\t\tbreak;\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int smc_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct smc_sock *smc;\n\tint val, rc;\n\n\tif (level == SOL_TCP && optname == TCP_ULP)\n\t\treturn -EOPNOTSUPP;\n\telse if (level == SOL_SMC)\n\t\treturn __smc_setsockopt(sock, level, optname, optval, optlen);\n\n\tsmc = smc_sk(sk);\n\n\t \n\tmutex_lock(&smc->clcsock_release_lock);\n\tif (!smc->clcsock) {\n\t\tmutex_unlock(&smc->clcsock_release_lock);\n\t\treturn -EBADF;\n\t}\n\tif (unlikely(!smc->clcsock->ops->setsockopt))\n\t\trc = -EOPNOTSUPP;\n\telse\n\t\trc = smc->clcsock->ops->setsockopt(smc->clcsock, level, optname,\n\t\t\t\t\t\t   optval, optlen);\n\tif (smc->clcsock->sk->sk_err) {\n\t\tsk->sk_err = smc->clcsock->sk->sk_err;\n\t\tsk_error_report(sk);\n\t}\n\tmutex_unlock(&smc->clcsock_release_lock);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (copy_from_sockptr(&val, optval, sizeof(int)))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\tif (rc || smc->use_fallback)\n\t\tgoto out;\n\tswitch (optname) {\n\tcase TCP_FASTOPEN:\n\tcase TCP_FASTOPEN_CONNECT:\n\tcase TCP_FASTOPEN_KEY:\n\tcase TCP_FASTOPEN_NO_COOKIE:\n\t\t \n\t\tif (sk->sk_state == SMC_INIT && !smc->connect_nonblock) {\n\t\t\trc = smc_switch_to_fallback(smc, SMC_CLC_DECL_OPTUNSUPP);\n\t\t} else {\n\t\t\trc = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase TCP_NODELAY:\n\t\tif (sk->sk_state != SMC_INIT &&\n\t\t    sk->sk_state != SMC_LISTEN &&\n\t\t    sk->sk_state != SMC_CLOSED) {\n\t\t\tif (val) {\n\t\t\t\tSMC_STAT_INC(smc, ndly_cnt);\n\t\t\t\tsmc_tx_pending(&smc->conn);\n\t\t\t\tcancel_delayed_work(&smc->conn.tx_work);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase TCP_CORK:\n\t\tif (sk->sk_state != SMC_INIT &&\n\t\t    sk->sk_state != SMC_LISTEN &&\n\t\t    sk->sk_state != SMC_CLOSED) {\n\t\t\tif (!val) {\n\t\t\t\tSMC_STAT_INC(smc, cork_cnt);\n\t\t\t\tsmc_tx_pending(&smc->conn);\n\t\t\t\tcancel_delayed_work(&smc->conn.tx_work);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase TCP_DEFER_ACCEPT:\n\t\tsmc->sockopt_defer_accept = val;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int smc_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct smc_sock *smc;\n\tint rc;\n\n\tif (level == SOL_SMC)\n\t\treturn __smc_getsockopt(sock, level, optname, optval, optlen);\n\n\tsmc = smc_sk(sock->sk);\n\tmutex_lock(&smc->clcsock_release_lock);\n\tif (!smc->clcsock) {\n\t\tmutex_unlock(&smc->clcsock_release_lock);\n\t\treturn -EBADF;\n\t}\n\t \n\tif (unlikely(!smc->clcsock->ops->getsockopt)) {\n\t\tmutex_unlock(&smc->clcsock_release_lock);\n\t\treturn -EOPNOTSUPP;\n\t}\n\trc = smc->clcsock->ops->getsockopt(smc->clcsock, level, optname,\n\t\t\t\t\t   optval, optlen);\n\tmutex_unlock(&smc->clcsock_release_lock);\n\treturn rc;\n}\n\nstatic int smc_ioctl(struct socket *sock, unsigned int cmd,\n\t\t     unsigned long arg)\n{\n\tunion smc_host_cursor cons, urg;\n\tstruct smc_connection *conn;\n\tstruct smc_sock *smc;\n\tint answ;\n\n\tsmc = smc_sk(sock->sk);\n\tconn = &smc->conn;\n\tlock_sock(&smc->sk);\n\tif (smc->use_fallback) {\n\t\tif (!smc->clcsock) {\n\t\t\trelease_sock(&smc->sk);\n\t\t\treturn -EBADF;\n\t\t}\n\t\tansw = smc->clcsock->ops->ioctl(smc->clcsock, cmd, arg);\n\t\trelease_sock(&smc->sk);\n\t\treturn answ;\n\t}\n\tswitch (cmd) {\n\tcase SIOCINQ:  \n\t\tif (smc->sk.sk_state == SMC_LISTEN) {\n\t\t\trelease_sock(&smc->sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (smc->sk.sk_state == SMC_INIT ||\n\t\t    smc->sk.sk_state == SMC_CLOSED)\n\t\t\tansw = 0;\n\t\telse\n\t\t\tansw = atomic_read(&smc->conn.bytes_to_rcv);\n\t\tbreak;\n\tcase SIOCOUTQ:\n\t\t \n\t\tif (smc->sk.sk_state == SMC_LISTEN) {\n\t\t\trelease_sock(&smc->sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (smc->sk.sk_state == SMC_INIT ||\n\t\t    smc->sk.sk_state == SMC_CLOSED)\n\t\t\tansw = 0;\n\t\telse\n\t\t\tansw = smc->conn.sndbuf_desc->len -\n\t\t\t\t\tatomic_read(&smc->conn.sndbuf_space);\n\t\tbreak;\n\tcase SIOCOUTQNSD:\n\t\t \n\t\tif (smc->sk.sk_state == SMC_LISTEN) {\n\t\t\trelease_sock(&smc->sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (smc->sk.sk_state == SMC_INIT ||\n\t\t    smc->sk.sk_state == SMC_CLOSED)\n\t\t\tansw = 0;\n\t\telse\n\t\t\tansw = smc_tx_prepared_sends(&smc->conn);\n\t\tbreak;\n\tcase SIOCATMARK:\n\t\tif (smc->sk.sk_state == SMC_LISTEN) {\n\t\t\trelease_sock(&smc->sk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (smc->sk.sk_state == SMC_INIT ||\n\t\t    smc->sk.sk_state == SMC_CLOSED) {\n\t\t\tansw = 0;\n\t\t} else {\n\t\t\tsmc_curs_copy(&cons, &conn->local_tx_ctrl.cons, conn);\n\t\t\tsmc_curs_copy(&urg, &conn->urg_curs, conn);\n\t\t\tansw = smc_curs_diff(conn->rmb_desc->len,\n\t\t\t\t\t     &cons, &urg) == 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trelease_sock(&smc->sk);\n\t\treturn -ENOIOCTLCMD;\n\t}\n\trelease_sock(&smc->sk);\n\n\treturn put_user(answ, (int __user *)arg);\n}\n\n \nstatic ssize_t smc_splice_read(struct socket *sock, loff_t *ppos,\n\t\t\t       struct pipe_inode_info *pipe, size_t len,\n\t\t\t       unsigned int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct smc_sock *smc;\n\tint rc = -ENOTCONN;\n\n\tsmc = smc_sk(sk);\n\tlock_sock(sk);\n\tif (sk->sk_state == SMC_CLOSED && (sk->sk_shutdown & RCV_SHUTDOWN)) {\n\t\t \n\t\trc = 0;\n\t\tgoto out;\n\t}\n\tif (sk->sk_state == SMC_INIT ||\n\t    sk->sk_state == SMC_LISTEN ||\n\t    sk->sk_state == SMC_CLOSED)\n\t\tgoto out;\n\n\tif (sk->sk_state == SMC_PEERFINCLOSEWAIT) {\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tif (smc->use_fallback) {\n\t\trc = smc->clcsock->ops->splice_read(smc->clcsock, ppos,\n\t\t\t\t\t\t    pipe, len, flags);\n\t} else {\n\t\tif (*ppos) {\n\t\t\trc = -ESPIPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK)\n\t\t\tflags = MSG_DONTWAIT;\n\t\telse\n\t\t\tflags = 0;\n\t\tSMC_STAT_INC(smc, splice_cnt);\n\t\trc = smc_rx_recvmsg(smc, NULL, pipe, len, flags);\n\t}\nout:\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\n \nstatic const struct proto_ops smc_sock_ops = {\n\t.family\t\t= PF_SMC,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= smc_release,\n\t.bind\t\t= smc_bind,\n\t.connect\t= smc_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= smc_accept,\n\t.getname\t= smc_getname,\n\t.poll\t\t= smc_poll,\n\t.ioctl\t\t= smc_ioctl,\n\t.listen\t\t= smc_listen,\n\t.shutdown\t= smc_shutdown,\n\t.setsockopt\t= smc_setsockopt,\n\t.getsockopt\t= smc_getsockopt,\n\t.sendmsg\t= smc_sendmsg,\n\t.recvmsg\t= smc_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n\t.splice_read\t= smc_splice_read,\n};\n\nstatic int __smc_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern, struct socket *clcsock)\n{\n\tint family = (protocol == SMCPROTO_SMC6) ? PF_INET6 : PF_INET;\n\tstruct smc_sock *smc;\n\tstruct sock *sk;\n\tint rc;\n\n\trc = -ESOCKTNOSUPPORT;\n\tif (sock->type != SOCK_STREAM)\n\t\tgoto out;\n\n\trc = -EPROTONOSUPPORT;\n\tif (protocol != SMCPROTO_SMC && protocol != SMCPROTO_SMC6)\n\t\tgoto out;\n\n\trc = -ENOBUFS;\n\tsock->ops = &smc_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsk = smc_sock_alloc(net, sock, protocol);\n\tif (!sk)\n\t\tgoto out;\n\n\t \n\tsmc = smc_sk(sk);\n\tsmc->use_fallback = false;  \n\tsmc->fallback_rsn = 0;\n\n\t \n\tsmc->limit_smc_hs = net->smc.limit_smc_hs;\n\n\trc = 0;\n\tif (!clcsock) {\n\t\trc = sock_create_kern(net, family, SOCK_STREAM, IPPROTO_TCP,\n\t\t\t\t      &smc->clcsock);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tsk = smc->clcsock->sk;\n\t\t__netns_tracker_free(net, &sk->ns_tracker, false);\n\t\tsk->sk_net_refcnt = 1;\n\t\tget_net_track(net, &sk->ns_tracker, GFP_KERNEL);\n\t\tsock_inuse_add(net, 1);\n\t} else {\n\t\tsmc->clcsock = clcsock;\n\t}\n\nout:\n\treturn rc;\n}\n\nstatic int smc_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\treturn __smc_create(net, sock, protocol, kern, NULL);\n}\n\nstatic const struct net_proto_family smc_sock_family_ops = {\n\t.family\t= PF_SMC,\n\t.owner\t= THIS_MODULE,\n\t.create\t= smc_create,\n};\n\nstatic int smc_ulp_init(struct sock *sk)\n{\n\tstruct socket *tcp = sk->sk_socket;\n\tstruct net *net = sock_net(sk);\n\tstruct socket *smcsock;\n\tint protocol, ret;\n\n\t \n\tif (tcp->type != SOCK_STREAM || sk->sk_protocol != IPPROTO_TCP ||\n\t    (sk->sk_family != AF_INET && sk->sk_family != AF_INET6))\n\t\treturn -ESOCKTNOSUPPORT;\n\t \n\tif (tcp->state != SS_UNCONNECTED || !tcp->file || tcp->wq.fasync_list)\n\t\treturn -ENOTCONN;\n\n\tif (sk->sk_family == AF_INET)\n\t\tprotocol = SMCPROTO_SMC;\n\telse\n\t\tprotocol = SMCPROTO_SMC6;\n\n\tsmcsock = sock_alloc();\n\tif (!smcsock)\n\t\treturn -ENFILE;\n\n\tsmcsock->type = SOCK_STREAM;\n\t__module_get(THIS_MODULE);  \n\tret = __smc_create(net, smcsock, protocol, 1, tcp);\n\tif (ret) {\n\t\tsock_release(smcsock);  \n\t\treturn ret;\n\t}\n\n\t \n\tsmcsock->file = tcp->file;\n\tsmcsock->file->private_data = smcsock;\n\tsmcsock->file->f_inode = SOCK_INODE(smcsock);  \n\tsmcsock->file->f_path.dentry->d_inode = SOCK_INODE(smcsock);  \n\ttcp->file = NULL;\n\n\treturn ret;\n}\n\nstatic void smc_ulp_clone(const struct request_sock *req, struct sock *newsk,\n\t\t\t  const gfp_t priority)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(newsk);\n\n\t \n\ticsk->icsk_ulp_ops = NULL;\n}\n\nstatic struct tcp_ulp_ops smc_ulp_ops __read_mostly = {\n\t.name\t\t= \"smc\",\n\t.owner\t\t= THIS_MODULE,\n\t.init\t\t= smc_ulp_init,\n\t.clone\t\t= smc_ulp_clone,\n};\n\nunsigned int smc_net_id;\n\nstatic __net_init int smc_net_init(struct net *net)\n{\n\tint rc;\n\n\trc = smc_sysctl_net_init(net);\n\tif (rc)\n\t\treturn rc;\n\treturn smc_pnet_net_init(net);\n}\n\nstatic void __net_exit smc_net_exit(struct net *net)\n{\n\tsmc_sysctl_net_exit(net);\n\tsmc_pnet_net_exit(net);\n}\n\nstatic __net_init int smc_net_stat_init(struct net *net)\n{\n\treturn smc_stats_init(net);\n}\n\nstatic void __net_exit smc_net_stat_exit(struct net *net)\n{\n\tsmc_stats_exit(net);\n}\n\nstatic struct pernet_operations smc_net_ops = {\n\t.init = smc_net_init,\n\t.exit = smc_net_exit,\n\t.id   = &smc_net_id,\n\t.size = sizeof(struct smc_net),\n};\n\nstatic struct pernet_operations smc_net_stat_ops = {\n\t.init = smc_net_stat_init,\n\t.exit = smc_net_stat_exit,\n};\n\nstatic int __init smc_init(void)\n{\n\tint rc;\n\n\trc = register_pernet_subsys(&smc_net_ops);\n\tif (rc)\n\t\treturn rc;\n\n\trc = register_pernet_subsys(&smc_net_stat_ops);\n\tif (rc)\n\t\tgoto out_pernet_subsys;\n\n\trc = smc_ism_init();\n\tif (rc)\n\t\tgoto out_pernet_subsys_stat;\n\tsmc_clc_init();\n\n\trc = smc_nl_init();\n\tif (rc)\n\t\tgoto out_ism;\n\n\trc = smc_pnet_init();\n\tif (rc)\n\t\tgoto out_nl;\n\n\trc = -ENOMEM;\n\n\tsmc_tcp_ls_wq = alloc_workqueue(\"smc_tcp_ls_wq\", 0, 0);\n\tif (!smc_tcp_ls_wq)\n\t\tgoto out_pnet;\n\n\tsmc_hs_wq = alloc_workqueue(\"smc_hs_wq\", 0, 0);\n\tif (!smc_hs_wq)\n\t\tgoto out_alloc_tcp_ls_wq;\n\n\tsmc_close_wq = alloc_workqueue(\"smc_close_wq\", 0, 0);\n\tif (!smc_close_wq)\n\t\tgoto out_alloc_hs_wq;\n\n\trc = smc_core_init();\n\tif (rc) {\n\t\tpr_err(\"%s: smc_core_init fails with %d\\n\", __func__, rc);\n\t\tgoto out_alloc_wqs;\n\t}\n\n\trc = smc_llc_init();\n\tif (rc) {\n\t\tpr_err(\"%s: smc_llc_init fails with %d\\n\", __func__, rc);\n\t\tgoto out_core;\n\t}\n\n\trc = smc_cdc_init();\n\tif (rc) {\n\t\tpr_err(\"%s: smc_cdc_init fails with %d\\n\", __func__, rc);\n\t\tgoto out_core;\n\t}\n\n\trc = proto_register(&smc_proto, 1);\n\tif (rc) {\n\t\tpr_err(\"%s: proto_register(v4) fails with %d\\n\", __func__, rc);\n\t\tgoto out_core;\n\t}\n\n\trc = proto_register(&smc_proto6, 1);\n\tif (rc) {\n\t\tpr_err(\"%s: proto_register(v6) fails with %d\\n\", __func__, rc);\n\t\tgoto out_proto;\n\t}\n\n\trc = sock_register(&smc_sock_family_ops);\n\tif (rc) {\n\t\tpr_err(\"%s: sock_register fails with %d\\n\", __func__, rc);\n\t\tgoto out_proto6;\n\t}\n\tINIT_HLIST_HEAD(&smc_v4_hashinfo.ht);\n\tINIT_HLIST_HEAD(&smc_v6_hashinfo.ht);\n\n\trc = smc_ib_register_client();\n\tif (rc) {\n\t\tpr_err(\"%s: ib_register fails with %d\\n\", __func__, rc);\n\t\tgoto out_sock;\n\t}\n\n\trc = tcp_register_ulp(&smc_ulp_ops);\n\tif (rc) {\n\t\tpr_err(\"%s: tcp_ulp_register fails with %d\\n\", __func__, rc);\n\t\tgoto out_ib;\n\t}\n\n\tstatic_branch_enable(&tcp_have_smc);\n\treturn 0;\n\nout_ib:\n\tsmc_ib_unregister_client();\nout_sock:\n\tsock_unregister(PF_SMC);\nout_proto6:\n\tproto_unregister(&smc_proto6);\nout_proto:\n\tproto_unregister(&smc_proto);\nout_core:\n\tsmc_core_exit();\nout_alloc_wqs:\n\tdestroy_workqueue(smc_close_wq);\nout_alloc_hs_wq:\n\tdestroy_workqueue(smc_hs_wq);\nout_alloc_tcp_ls_wq:\n\tdestroy_workqueue(smc_tcp_ls_wq);\nout_pnet:\n\tsmc_pnet_exit();\nout_nl:\n\tsmc_nl_exit();\nout_ism:\n\tsmc_clc_exit();\n\tsmc_ism_exit();\nout_pernet_subsys_stat:\n\tunregister_pernet_subsys(&smc_net_stat_ops);\nout_pernet_subsys:\n\tunregister_pernet_subsys(&smc_net_ops);\n\n\treturn rc;\n}\n\nstatic void __exit smc_exit(void)\n{\n\tstatic_branch_disable(&tcp_have_smc);\n\ttcp_unregister_ulp(&smc_ulp_ops);\n\tsock_unregister(PF_SMC);\n\tsmc_core_exit();\n\tsmc_ib_unregister_client();\n\tsmc_ism_exit();\n\tdestroy_workqueue(smc_close_wq);\n\tdestroy_workqueue(smc_tcp_ls_wq);\n\tdestroy_workqueue(smc_hs_wq);\n\tproto_unregister(&smc_proto6);\n\tproto_unregister(&smc_proto);\n\tsmc_pnet_exit();\n\tsmc_nl_exit();\n\tsmc_clc_exit();\n\tunregister_pernet_subsys(&smc_net_stat_ops);\n\tunregister_pernet_subsys(&smc_net_ops);\n\trcu_barrier();\n}\n\nmodule_init(smc_init);\nmodule_exit(smc_exit);\n\nMODULE_AUTHOR(\"Ursula Braun <ubraun@linux.vnet.ibm.com>\");\nMODULE_DESCRIPTION(\"smc socket address family\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_SMC);\nMODULE_ALIAS_TCP_ULP(\"smc\");\nMODULE_ALIAS_GENL_FAMILY(SMC_GENL_FAMILY_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}