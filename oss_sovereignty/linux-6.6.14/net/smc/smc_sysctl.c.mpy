{
  "module_name": "smc_sysctl.c",
  "hash_id": "931a89190189dacaaf62744d00928eed6b054c24b690f3e27d02d6ef6cd9fa0c",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_sysctl.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <net/net_namespace.h>\n\n#include \"smc.h\"\n#include \"smc_core.h\"\n#include \"smc_llc.h\"\n#include \"smc_sysctl.h\"\n\nstatic int min_sndbuf = SMC_BUF_MIN_SIZE;\nstatic int min_rcvbuf = SMC_BUF_MIN_SIZE;\nstatic int max_sndbuf = INT_MAX / 2;\nstatic int max_rcvbuf = INT_MAX / 2;\nstatic const int net_smc_wmem_init = (64 * 1024);\nstatic const int net_smc_rmem_init = (64 * 1024);\n\nstatic struct ctl_table smc_table[] = {\n\t{\n\t\t.procname       = \"autocorking_size\",\n\t\t.data           = &init_net.smc.sysctl_autocorking_size,\n\t\t.maxlen         = sizeof(unsigned int),\n\t\t.mode           = 0644,\n\t\t.proc_handler\t= proc_douintvec,\n\t},\n\t{\n\t\t.procname\t= \"smcr_buf_type\",\n\t\t.data\t\t= &init_net.smc.sysctl_smcr_buf_type,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_douintvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{\n\t\t.procname\t= \"smcr_testlink_time\",\n\t\t.data\t\t= &init_net.smc.sysctl_smcr_testlink_time,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"wmem\",\n\t\t.data\t\t= &init_net.smc.sysctl_wmem,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_sndbuf,\n\t\t.extra2\t\t= &max_sndbuf,\n\t},\n\t{\n\t\t.procname\t= \"rmem\",\n\t\t.data\t\t= &init_net.smc.sysctl_rmem,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_rcvbuf,\n\t\t.extra2\t\t= &max_rcvbuf,\n\t},\n\t{  }\n};\n\nint __net_init smc_sysctl_net_init(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = smc_table;\n\tif (!net_eq(net, &init_net)) {\n\t\tint i;\n\n\t\ttable = kmemdup(table, sizeof(smc_table), GFP_KERNEL);\n\t\tif (!table)\n\t\t\tgoto err_alloc;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(smc_table) - 1; i++)\n\t\t\ttable[i].data += (void *)net - (void *)&init_net;\n\t}\n\n\tnet->smc.smc_hdr = register_net_sysctl_sz(net, \"net/smc\", table,\n\t\t\t\t\t\t  ARRAY_SIZE(smc_table));\n\tif (!net->smc.smc_hdr)\n\t\tgoto err_reg;\n\n\tnet->smc.sysctl_autocorking_size = SMC_AUTOCORKING_DEFAULT_SIZE;\n\tnet->smc.sysctl_smcr_buf_type = SMCR_PHYS_CONT_BUFS;\n\tnet->smc.sysctl_smcr_testlink_time = SMC_LLC_TESTLINK_DEFAULT_TIME;\n\tWRITE_ONCE(net->smc.sysctl_wmem, net_smc_wmem_init);\n\tWRITE_ONCE(net->smc.sysctl_rmem, net_smc_rmem_init);\n\n\treturn 0;\n\nerr_reg:\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\nerr_alloc:\n\treturn -ENOMEM;\n}\n\nvoid __net_exit smc_sysctl_net_exit(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = net->smc.smc_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(net->smc.smc_hdr);\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}