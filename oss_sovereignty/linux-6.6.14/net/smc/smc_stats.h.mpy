{
  "module_name": "smc_stats.h",
  "hash_id": "9032a47998caf33b277268454f21cd8887426a1d0869d53fc5d536153e8f3ec8",
  "original_prompt": "Ingested from linux-6.6.14/net/smc/smc_stats.h",
  "human_readable_source": " \n \n\n#ifndef NET_SMC_SMC_STATS_H_\n#define NET_SMC_SMC_STATS_H_\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/ctype.h>\n#include <linux/smc.h>\n\n#include \"smc_clc.h\"\n\n#define SMC_MAX_FBACK_RSN_CNT 30\n\nenum {\n\tSMC_BUF_8K,\n\tSMC_BUF_16K,\n\tSMC_BUF_32K,\n\tSMC_BUF_64K,\n\tSMC_BUF_128K,\n\tSMC_BUF_256K,\n\tSMC_BUF_512K,\n\tSMC_BUF_1024K,\n\tSMC_BUF_G_1024K,\n\tSMC_BUF_MAX,\n};\n\nstruct smc_stats_fback {\n\tint\tfback_code;\n\tu16\tcount;\n};\n\nstruct smc_stats_rsn {\n\tstruct\tsmc_stats_fback srv[SMC_MAX_FBACK_RSN_CNT];\n\tstruct\tsmc_stats_fback clnt[SMC_MAX_FBACK_RSN_CNT];\n\tu64\t\t\tsrv_fback_cnt;\n\tu64\t\t\tclnt_fback_cnt;\n};\n\nstruct smc_stats_rmbcnt {\n\tu64\tbuf_size_small_peer_cnt;\n\tu64\tbuf_size_small_cnt;\n\tu64\tbuf_full_peer_cnt;\n\tu64\tbuf_full_cnt;\n\tu64\treuse_cnt;\n\tu64\talloc_cnt;\n\tu64\tdgrade_cnt;\n};\n\nstruct smc_stats_memsize {\n\tu64\tbuf[SMC_BUF_MAX];\n};\n\nstruct smc_stats_tech {\n\tstruct smc_stats_memsize tx_rmbsize;\n\tstruct smc_stats_memsize rx_rmbsize;\n\tstruct smc_stats_memsize tx_pd;\n\tstruct smc_stats_memsize rx_pd;\n\tstruct smc_stats_rmbcnt rmb_tx;\n\tstruct smc_stats_rmbcnt rmb_rx;\n\tu64\t\t\tclnt_v1_succ_cnt;\n\tu64\t\t\tclnt_v2_succ_cnt;\n\tu64\t\t\tsrv_v1_succ_cnt;\n\tu64\t\t\tsrv_v2_succ_cnt;\n\tu64\t\t\turg_data_cnt;\n\tu64\t\t\tsplice_cnt;\n\tu64\t\t\tcork_cnt;\n\tu64\t\t\tndly_cnt;\n\tu64\t\t\trx_bytes;\n\tu64\t\t\ttx_bytes;\n\tu64\t\t\trx_cnt;\n\tu64\t\t\ttx_cnt;\n};\n\nstruct smc_stats {\n\tstruct smc_stats_tech\tsmc[2];\n\tu64\t\t\tclnt_hshake_err_cnt;\n\tu64\t\t\tsrv_hshake_err_cnt;\n};\n\n#define SMC_STAT_PAYLOAD_SUB(_smc_stats, _tech, key, _len, _rc) \\\ndo { \\\n\ttypeof(_smc_stats) stats = (_smc_stats); \\\n\ttypeof(_tech) t = (_tech); \\\n\ttypeof(_len) l = (_len); \\\n\tint _pos; \\\n\ttypeof(_rc) r = (_rc); \\\n\tint m = SMC_BUF_MAX - 1; \\\n\tthis_cpu_inc((*stats).smc[t].key ## _cnt); \\\n\tif (r <= 0 || l <= 0) \\\n\t\tbreak; \\\n\t_pos = fls64((l - 1) >> 13); \\\n\t_pos = (_pos <= m) ? _pos : m; \\\n\tthis_cpu_inc((*stats).smc[t].key ## _pd.buf[_pos]); \\\n\tthis_cpu_add((*stats).smc[t].key ## _bytes, r); \\\n} \\\nwhile (0)\n\n#define SMC_STAT_TX_PAYLOAD(_smc, length, rcode) \\\ndo { \\\n\ttypeof(_smc) __smc = _smc; \\\n\tstruct net *_net = sock_net(&__smc->sk); \\\n\tstruct smc_stats __percpu *_smc_stats = _net->smc.smc_stats; \\\n\ttypeof(length) _len = (length); \\\n\ttypeof(rcode) _rc = (rcode); \\\n\tbool is_smcd = !__smc->conn.lnk; \\\n\tif (is_smcd) \\\n\t\tSMC_STAT_PAYLOAD_SUB(_smc_stats, SMC_TYPE_D, tx, _len, _rc); \\\n\telse \\\n\t\tSMC_STAT_PAYLOAD_SUB(_smc_stats, SMC_TYPE_R, tx, _len, _rc); \\\n} \\\nwhile (0)\n\n#define SMC_STAT_RX_PAYLOAD(_smc, length, rcode) \\\ndo { \\\n\ttypeof(_smc) __smc = _smc; \\\n\tstruct net *_net = sock_net(&__smc->sk); \\\n\tstruct smc_stats __percpu *_smc_stats = _net->smc.smc_stats; \\\n\ttypeof(length) _len = (length); \\\n\ttypeof(rcode) _rc = (rcode); \\\n\tbool is_smcd = !__smc->conn.lnk; \\\n\tif (is_smcd) \\\n\t\tSMC_STAT_PAYLOAD_SUB(_smc_stats, SMC_TYPE_D, rx, _len, _rc); \\\n\telse \\\n\t\tSMC_STAT_PAYLOAD_SUB(_smc_stats, SMC_TYPE_R, rx, _len, _rc); \\\n} \\\nwhile (0)\n\n#define SMC_STAT_RMB_SIZE_SUB(_smc_stats, _tech, k, _len) \\\ndo { \\\n\ttypeof(_len) _l = (_len); \\\n\ttypeof(_tech) t = (_tech); \\\n\tint _pos; \\\n\tint m = SMC_BUF_MAX - 1; \\\n\tif (_l <= 0) \\\n\t\tbreak; \\\n\t_pos = fls((_l - 1) >> 13); \\\n\t_pos = (_pos <= m) ? _pos : m; \\\n\tthis_cpu_inc((*(_smc_stats)).smc[t].k ## _rmbsize.buf[_pos]); \\\n} \\\nwhile (0)\n\n#define SMC_STAT_RMB_SUB(_smc_stats, type, t, key) \\\n\tthis_cpu_inc((*(_smc_stats)).smc[t].rmb ## _ ## key.type ## _cnt)\n\n#define SMC_STAT_RMB_SIZE(_smc, _is_smcd, _is_rx, _len) \\\ndo { \\\n\tstruct net *_net = sock_net(&(_smc)->sk); \\\n\tstruct smc_stats __percpu *_smc_stats = _net->smc.smc_stats; \\\n\ttypeof(_is_smcd) is_d = (_is_smcd); \\\n\ttypeof(_is_rx) is_r = (_is_rx); \\\n\ttypeof(_len) l = (_len); \\\n\tif ((is_d) && (is_r)) \\\n\t\tSMC_STAT_RMB_SIZE_SUB(_smc_stats, SMC_TYPE_D, rx, l); \\\n\tif ((is_d) && !(is_r)) \\\n\t\tSMC_STAT_RMB_SIZE_SUB(_smc_stats, SMC_TYPE_D, tx, l); \\\n\tif (!(is_d) && (is_r)) \\\n\t\tSMC_STAT_RMB_SIZE_SUB(_smc_stats, SMC_TYPE_R, rx, l); \\\n\tif (!(is_d) && !(is_r)) \\\n\t\tSMC_STAT_RMB_SIZE_SUB(_smc_stats, SMC_TYPE_R, tx, l); \\\n} \\\nwhile (0)\n\n#define SMC_STAT_RMB(_smc, type, _is_smcd, _is_rx) \\\ndo { \\\n\tstruct net *net = sock_net(&(_smc)->sk); \\\n\tstruct smc_stats __percpu *_smc_stats = net->smc.smc_stats; \\\n\ttypeof(_is_smcd) is_d = (_is_smcd); \\\n\ttypeof(_is_rx) is_r = (_is_rx); \\\n\tif ((is_d) && (is_r)) \\\n\t\tSMC_STAT_RMB_SUB(_smc_stats, type, SMC_TYPE_D, rx); \\\n\tif ((is_d) && !(is_r)) \\\n\t\tSMC_STAT_RMB_SUB(_smc_stats, type, SMC_TYPE_D, tx); \\\n\tif (!(is_d) && (is_r)) \\\n\t\tSMC_STAT_RMB_SUB(_smc_stats, type, SMC_TYPE_R, rx); \\\n\tif (!(is_d) && !(is_r)) \\\n\t\tSMC_STAT_RMB_SUB(_smc_stats, type, SMC_TYPE_R, tx); \\\n} \\\nwhile (0)\n\n#define SMC_STAT_BUF_REUSE(smc, is_smcd, is_rx) \\\n\tSMC_STAT_RMB(smc, reuse, is_smcd, is_rx)\n\n#define SMC_STAT_RMB_ALLOC(smc, is_smcd, is_rx) \\\n\tSMC_STAT_RMB(smc, alloc, is_smcd, is_rx)\n\n#define SMC_STAT_RMB_DOWNGRADED(smc, is_smcd, is_rx) \\\n\tSMC_STAT_RMB(smc, dgrade, is_smcd, is_rx)\n\n#define SMC_STAT_RMB_TX_PEER_FULL(smc, is_smcd) \\\n\tSMC_STAT_RMB(smc, buf_full_peer, is_smcd, false)\n\n#define SMC_STAT_RMB_TX_FULL(smc, is_smcd) \\\n\tSMC_STAT_RMB(smc, buf_full, is_smcd, false)\n\n#define SMC_STAT_RMB_TX_PEER_SIZE_SMALL(smc, is_smcd) \\\n\tSMC_STAT_RMB(smc, buf_size_small_peer, is_smcd, false)\n\n#define SMC_STAT_RMB_TX_SIZE_SMALL(smc, is_smcd) \\\n\tSMC_STAT_RMB(smc, buf_size_small, is_smcd, false)\n\n#define SMC_STAT_RMB_RX_SIZE_SMALL(smc, is_smcd) \\\n\tSMC_STAT_RMB(smc, buf_size_small, is_smcd, true)\n\n#define SMC_STAT_RMB_RX_FULL(smc, is_smcd) \\\n\tSMC_STAT_RMB(smc, buf_full, is_smcd, true)\n\n#define SMC_STAT_INC(_smc, type) \\\ndo { \\\n\ttypeof(_smc) __smc = _smc; \\\n\tbool is_smcd = !(__smc)->conn.lnk; \\\n\tstruct net *net = sock_net(&(__smc)->sk); \\\n\tstruct smc_stats __percpu *smc_stats = net->smc.smc_stats; \\\n\tif ((is_smcd)) \\\n\t\tthis_cpu_inc(smc_stats->smc[SMC_TYPE_D].type); \\\n\telse \\\n\t\tthis_cpu_inc(smc_stats->smc[SMC_TYPE_R].type); \\\n} \\\nwhile (0)\n\n#define SMC_STAT_CLNT_SUCC_INC(net, _aclc) \\\ndo { \\\n\ttypeof(_aclc) acl = (_aclc); \\\n\tbool is_v2 = (acl->hdr.version == SMC_V2); \\\n\tbool is_smcd = (acl->hdr.typev1 == SMC_TYPE_D); \\\n\tstruct smc_stats __percpu *smc_stats = (net)->smc.smc_stats; \\\n\tif (is_v2 && is_smcd) \\\n\t\tthis_cpu_inc(smc_stats->smc[SMC_TYPE_D].clnt_v2_succ_cnt); \\\n\telse if (is_v2 && !is_smcd) \\\n\t\tthis_cpu_inc(smc_stats->smc[SMC_TYPE_R].clnt_v2_succ_cnt); \\\n\telse if (!is_v2 && is_smcd) \\\n\t\tthis_cpu_inc(smc_stats->smc[SMC_TYPE_D].clnt_v1_succ_cnt); \\\n\telse if (!is_v2 && !is_smcd) \\\n\t\tthis_cpu_inc(smc_stats->smc[SMC_TYPE_R].clnt_v1_succ_cnt); \\\n} \\\nwhile (0)\n\n#define SMC_STAT_SERV_SUCC_INC(net, _ini) \\\ndo { \\\n\ttypeof(_ini) i = (_ini); \\\n\tbool is_smcd = (i->is_smcd); \\\n\tu8 version = is_smcd ? i->smcd_version : i->smcr_version; \\\n\tbool is_v2 = (version & SMC_V2); \\\n\ttypeof(net->smc.smc_stats) smc_stats = (net)->smc.smc_stats; \\\n\tif (is_v2 && is_smcd) \\\n\t\tthis_cpu_inc(smc_stats->smc[SMC_TYPE_D].srv_v2_succ_cnt); \\\n\telse if (is_v2 && !is_smcd) \\\n\t\tthis_cpu_inc(smc_stats->smc[SMC_TYPE_R].srv_v2_succ_cnt); \\\n\telse if (!is_v2 && is_smcd) \\\n\t\tthis_cpu_inc(smc_stats->smc[SMC_TYPE_D].srv_v1_succ_cnt); \\\n\telse if (!is_v2 && !is_smcd) \\\n\t\tthis_cpu_inc(smc_stats->smc[SMC_TYPE_R].srv_v1_succ_cnt); \\\n} \\\nwhile (0)\n\nint smc_nl_get_stats(struct sk_buff *skb, struct netlink_callback *cb);\nint smc_nl_get_fback_stats(struct sk_buff *skb, struct netlink_callback *cb);\nint smc_stats_init(struct net *net);\nvoid smc_stats_exit(struct net *net);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}