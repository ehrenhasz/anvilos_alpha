{
  "module_name": "nsh.c",
  "hash_id": "9268042d9156301821962e8e7a758da3d524b617777d9105a7cf481a968f36ed",
  "original_prompt": "Ingested from linux-6.6.14/net/nsh/nsh.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/gso.h>\n#include <net/nsh.h>\n#include <net/tun_proto.h>\n\nint nsh_push(struct sk_buff *skb, const struct nshhdr *pushed_nh)\n{\n\tstruct nshhdr *nh;\n\tsize_t length = nsh_hdr_len(pushed_nh);\n\tu8 next_proto;\n\n\tif (skb->mac_len) {\n\t\tnext_proto = TUN_P_ETHERNET;\n\t} else {\n\t\tnext_proto = tun_p_from_eth_p(skb->protocol);\n\t\tif (!next_proto)\n\t\t\treturn -EAFNOSUPPORT;\n\t}\n\n\t \n\tif (skb_cow_head(skb, length) < 0)\n\t\treturn -ENOMEM;\n\n\tskb_push(skb, length);\n\tnh = (struct nshhdr *)(skb->data);\n\tmemcpy(nh, pushed_nh, length);\n\tnh->np = next_proto;\n\tskb_postpush_rcsum(skb, nh, length);\n\n\tskb->protocol = htons(ETH_P_NSH);\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tskb_reset_mac_len(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nsh_push);\n\nint nsh_pop(struct sk_buff *skb)\n{\n\tstruct nshhdr *nh;\n\tsize_t length;\n\t__be16 inner_proto;\n\n\tif (!pskb_may_pull(skb, NSH_BASE_HDR_LEN))\n\t\treturn -ENOMEM;\n\tnh = (struct nshhdr *)(skb->data);\n\tlength = nsh_hdr_len(nh);\n\tif (length < NSH_BASE_HDR_LEN)\n\t\treturn -EINVAL;\n\tinner_proto = tun_p_to_eth_p(nh->np);\n\tif (!pskb_may_pull(skb, length))\n\t\treturn -ENOMEM;\n\n\tif (!inner_proto)\n\t\treturn -EAFNOSUPPORT;\n\n\tskb_pull_rcsum(skb, length);\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tskb_reset_mac_len(skb);\n\tskb->protocol = inner_proto;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nsh_pop);\n\nstatic struct sk_buff *nsh_gso_segment(struct sk_buff *skb,\n\t\t\t\t       netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tu16 mac_offset = skb->mac_header;\n\tunsigned int nsh_len, mac_len;\n\t__be16 proto;\n\n\tskb_reset_network_header(skb);\n\n\tmac_len = skb->mac_len;\n\n\tif (unlikely(!pskb_may_pull(skb, NSH_BASE_HDR_LEN)))\n\t\tgoto out;\n\tnsh_len = nsh_hdr_len(nsh_hdr(skb));\n\tif (nsh_len < NSH_BASE_HDR_LEN)\n\t\tgoto out;\n\tif (unlikely(!pskb_may_pull(skb, nsh_len)))\n\t\tgoto out;\n\n\tproto = tun_p_to_eth_p(nsh_hdr(skb)->np);\n\tif (!proto)\n\t\tgoto out;\n\n\t__skb_pull(skb, nsh_len);\n\n\tskb_reset_mac_header(skb);\n\tskb->mac_len = proto == htons(ETH_P_TEB) ? ETH_HLEN : 0;\n\tskb->protocol = proto;\n\n\tfeatures &= NETIF_F_SG;\n\tsegs = skb_mac_gso_segment(skb, features);\n\tif (IS_ERR_OR_NULL(segs)) {\n\t\tskb_gso_error_unwind(skb, htons(ETH_P_NSH), nsh_len,\n\t\t\t\t     mac_offset, mac_len);\n\t\tgoto out;\n\t}\n\n\tfor (skb = segs; skb; skb = skb->next) {\n\t\tskb->protocol = htons(ETH_P_NSH);\n\t\t__skb_push(skb, nsh_len);\n\t\tskb->mac_header = mac_offset;\n\t\tskb->network_header = skb->mac_header + mac_len;\n\t\tskb->mac_len = mac_len;\n\t}\n\nout:\n\treturn segs;\n}\n\nstatic struct packet_offload nsh_packet_offload __read_mostly = {\n\t.type = htons(ETH_P_NSH),\n\t.priority = 15,\n\t.callbacks = {\n\t\t.gso_segment = nsh_gso_segment,\n\t},\n};\n\nstatic int __init nsh_init_module(void)\n{\n\tdev_add_offload(&nsh_packet_offload);\n\treturn 0;\n}\n\nstatic void __exit nsh_cleanup_module(void)\n{\n\tdev_remove_offload(&nsh_packet_offload);\n}\n\nmodule_init(nsh_init_module);\nmodule_exit(nsh_cleanup_module);\n\nMODULE_AUTHOR(\"Jiri Benc <jbenc@redhat.com>\");\nMODULE_DESCRIPTION(\"NSH protocol\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}