{
  "module_name": "igmp.c",
  "hash_id": "c99ec491ad3c13531663d797946adfac05c256702d33d9866b10f844891066cf",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/igmp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/if_arp.h>\n#include <linux/rtnetlink.h>\n#include <linux/times.h>\n#include <linux/pkt_sched.h>\n#include <linux/byteorder/generic.h>\n\n#include <net/net_namespace.h>\n#include <net/arp.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/route.h>\n#include <net/sock.h>\n#include <net/checksum.h>\n#include <net/inet_common.h>\n#include <linux/netfilter_ipv4.h>\n#ifdef CONFIG_IP_MROUTE\n#include <linux/mroute.h>\n#endif\n#ifdef CONFIG_PROC_FS\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#endif\n\n#ifdef CONFIG_IP_MULTICAST\n \n\n#define IGMP_QUERY_INTERVAL\t\t\t(125*HZ)\n#define IGMP_QUERY_RESPONSE_INTERVAL\t\t(10*HZ)\n\n#define IGMP_INITIAL_REPORT_DELAY\t\t(1)\n\n \n\n#define IGMP_V1_SEEN(in_dev) \\\n\t(IPV4_DEVCONF_ALL(dev_net(in_dev->dev), FORCE_IGMP_VERSION) == 1 || \\\n\t IN_DEV_CONF_GET((in_dev), FORCE_IGMP_VERSION) == 1 || \\\n\t ((in_dev)->mr_v1_seen && \\\n\t  time_before(jiffies, (in_dev)->mr_v1_seen)))\n#define IGMP_V2_SEEN(in_dev) \\\n\t(IPV4_DEVCONF_ALL(dev_net(in_dev->dev), FORCE_IGMP_VERSION) == 2 || \\\n\t IN_DEV_CONF_GET((in_dev), FORCE_IGMP_VERSION) == 2 || \\\n\t ((in_dev)->mr_v2_seen && \\\n\t  time_before(jiffies, (in_dev)->mr_v2_seen)))\n\nstatic int unsolicited_report_interval(struct in_device *in_dev)\n{\n\tint interval_ms, interval_jiffies;\n\n\tif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev))\n\t\tinterval_ms = IN_DEV_CONF_GET(\n\t\t\tin_dev,\n\t\t\tIGMPV2_UNSOLICITED_REPORT_INTERVAL);\n\telse  \n\t\tinterval_ms = IN_DEV_CONF_GET(\n\t\t\tin_dev,\n\t\t\tIGMPV3_UNSOLICITED_REPORT_INTERVAL);\n\n\tinterval_jiffies = msecs_to_jiffies(interval_ms);\n\n\t \n\tif (interval_jiffies <= 0)\n\t\tinterval_jiffies = 1;\n\treturn interval_jiffies;\n}\n\nstatic void igmpv3_add_delrec(struct in_device *in_dev, struct ip_mc_list *im,\n\t\t\t      gfp_t gfp);\nstatic void igmpv3_del_delrec(struct in_device *in_dev, struct ip_mc_list *im);\nstatic void igmpv3_clear_delrec(struct in_device *in_dev);\nstatic int sf_setstate(struct ip_mc_list *pmc);\nstatic void sf_markstate(struct ip_mc_list *pmc);\n#endif\nstatic void ip_mc_clear_src(struct ip_mc_list *pmc);\nstatic int ip_mc_add_src(struct in_device *in_dev, __be32 *pmca, int sfmode,\n\t\t\t int sfcount, __be32 *psfsrc, int delta);\n\nstatic void ip_ma_put(struct ip_mc_list *im)\n{\n\tif (refcount_dec_and_test(&im->refcnt)) {\n\t\tin_dev_put(im->interface);\n\t\tkfree_rcu(im, rcu);\n\t}\n}\n\n#define for_each_pmc_rcu(in_dev, pmc)\t\t\t\t\\\n\tfor (pmc = rcu_dereference(in_dev->mc_list);\t\t\\\n\t     pmc != NULL;\t\t\t\t\t\\\n\t     pmc = rcu_dereference(pmc->next_rcu))\n\n#define for_each_pmc_rtnl(in_dev, pmc)\t\t\t\t\\\n\tfor (pmc = rtnl_dereference(in_dev->mc_list);\t\t\\\n\t     pmc != NULL;\t\t\t\t\t\\\n\t     pmc = rtnl_dereference(pmc->next_rcu))\n\nstatic void ip_sf_list_clear_all(struct ip_sf_list *psf)\n{\n\tstruct ip_sf_list *next;\n\n\twhile (psf) {\n\t\tnext = psf->sf_next;\n\t\tkfree(psf);\n\t\tpsf = next;\n\t}\n}\n\n#ifdef CONFIG_IP_MULTICAST\n\n \n\nstatic void igmp_stop_timer(struct ip_mc_list *im)\n{\n\tspin_lock_bh(&im->lock);\n\tif (del_timer(&im->timer))\n\t\trefcount_dec(&im->refcnt);\n\tim->tm_running = 0;\n\tim->reporter = 0;\n\tim->unsolicit_count = 0;\n\tspin_unlock_bh(&im->lock);\n}\n\n \nstatic void igmp_start_timer(struct ip_mc_list *im, int max_delay)\n{\n\tint tv = get_random_u32_below(max_delay);\n\n\tim->tm_running = 1;\n\tif (refcount_inc_not_zero(&im->refcnt)) {\n\t\tif (mod_timer(&im->timer, jiffies + tv + 2))\n\t\t\tip_ma_put(im);\n\t}\n}\n\nstatic void igmp_gq_start_timer(struct in_device *in_dev)\n{\n\tint tv = get_random_u32_below(in_dev->mr_maxdelay);\n\tunsigned long exp = jiffies + tv + 2;\n\n\tif (in_dev->mr_gq_running &&\n\t    time_after_eq(exp, (in_dev->mr_gq_timer).expires))\n\t\treturn;\n\n\tin_dev->mr_gq_running = 1;\n\tif (!mod_timer(&in_dev->mr_gq_timer, exp))\n\t\tin_dev_hold(in_dev);\n}\n\nstatic void igmp_ifc_start_timer(struct in_device *in_dev, int delay)\n{\n\tint tv = get_random_u32_below(delay);\n\n\tif (!mod_timer(&in_dev->mr_ifc_timer, jiffies+tv+2))\n\t\tin_dev_hold(in_dev);\n}\n\nstatic void igmp_mod_timer(struct ip_mc_list *im, int max_delay)\n{\n\tspin_lock_bh(&im->lock);\n\tim->unsolicit_count = 0;\n\tif (del_timer(&im->timer)) {\n\t\tif ((long)(im->timer.expires-jiffies) < max_delay) {\n\t\t\tadd_timer(&im->timer);\n\t\t\tim->tm_running = 1;\n\t\t\tspin_unlock_bh(&im->lock);\n\t\t\treturn;\n\t\t}\n\t\trefcount_dec(&im->refcnt);\n\t}\n\tigmp_start_timer(im, max_delay);\n\tspin_unlock_bh(&im->lock);\n}\n\n\n \n\n#define IGMP_SIZE (sizeof(struct igmphdr)+sizeof(struct iphdr)+4)\n\n\nstatic int is_in(struct ip_mc_list *pmc, struct ip_sf_list *psf, int type,\n\tint gdeleted, int sdeleted)\n{\n\tswitch (type) {\n\tcase IGMPV3_MODE_IS_INCLUDE:\n\tcase IGMPV3_MODE_IS_EXCLUDE:\n\t\tif (gdeleted || sdeleted)\n\t\t\treturn 0;\n\t\tif (!(pmc->gsquery && !psf->sf_gsresp)) {\n\t\t\tif (pmc->sfmode == MCAST_INCLUDE)\n\t\t\t\treturn 1;\n\t\t\t \n\t\t\tif (psf->sf_count[MCAST_INCLUDE])\n\t\t\t\treturn type == IGMPV3_MODE_IS_INCLUDE;\n\t\t\treturn pmc->sfcount[MCAST_EXCLUDE] ==\n\t\t\t\tpsf->sf_count[MCAST_EXCLUDE];\n\t\t}\n\t\treturn 0;\n\tcase IGMPV3_CHANGE_TO_INCLUDE:\n\t\tif (gdeleted || sdeleted)\n\t\t\treturn 0;\n\t\treturn psf->sf_count[MCAST_INCLUDE] != 0;\n\tcase IGMPV3_CHANGE_TO_EXCLUDE:\n\t\tif (gdeleted || sdeleted)\n\t\t\treturn 0;\n\t\tif (pmc->sfcount[MCAST_EXCLUDE] == 0 ||\n\t\t    psf->sf_count[MCAST_INCLUDE])\n\t\t\treturn 0;\n\t\treturn pmc->sfcount[MCAST_EXCLUDE] ==\n\t\t\tpsf->sf_count[MCAST_EXCLUDE];\n\tcase IGMPV3_ALLOW_NEW_SOURCES:\n\t\tif (gdeleted || !psf->sf_crcount)\n\t\t\treturn 0;\n\t\treturn (pmc->sfmode == MCAST_INCLUDE) ^ sdeleted;\n\tcase IGMPV3_BLOCK_OLD_SOURCES:\n\t\tif (pmc->sfmode == MCAST_INCLUDE)\n\t\t\treturn gdeleted || (psf->sf_crcount && sdeleted);\n\t\treturn psf->sf_crcount && !gdeleted && !sdeleted;\n\t}\n\treturn 0;\n}\n\nstatic int\nigmp_scount(struct ip_mc_list *pmc, int type, int gdeleted, int sdeleted)\n{\n\tstruct ip_sf_list *psf;\n\tint scount = 0;\n\n\tfor (psf = pmc->sources; psf; psf = psf->sf_next) {\n\t\tif (!is_in(pmc, psf, type, gdeleted, sdeleted))\n\t\t\tcontinue;\n\t\tscount++;\n\t}\n\treturn scount;\n}\n\n \nstatic __be32 igmpv3_get_srcaddr(struct net_device *dev,\n\t\t\t\t const struct flowi4 *fl4)\n{\n\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\tconst struct in_ifaddr *ifa;\n\n\tif (!in_dev)\n\t\treturn htonl(INADDR_ANY);\n\n\tin_dev_for_each_ifa_rcu(ifa, in_dev) {\n\t\tif (fl4->saddr == ifa->ifa_local)\n\t\t\treturn fl4->saddr;\n\t}\n\n\treturn htonl(INADDR_ANY);\n}\n\nstatic struct sk_buff *igmpv3_newpack(struct net_device *dev, unsigned int mtu)\n{\n\tstruct sk_buff *skb;\n\tstruct rtable *rt;\n\tstruct iphdr *pip;\n\tstruct igmpv3_report *pig;\n\tstruct net *net = dev_net(dev);\n\tstruct flowi4 fl4;\n\tint hlen = LL_RESERVED_SPACE(dev);\n\tint tlen = dev->needed_tailroom;\n\tunsigned int size;\n\n\tsize = min(mtu, IP_MAX_MTU);\n\twhile (1) {\n\t\tskb = alloc_skb(size + hlen + tlen,\n\t\t\t\tGFP_ATOMIC | __GFP_NOWARN);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tsize >>= 1;\n\t\tif (size < 256)\n\t\t\treturn NULL;\n\t}\n\tskb->priority = TC_PRIO_CONTROL;\n\n\trt = ip_route_output_ports(net, &fl4, NULL, IGMPV3_ALL_MCR, 0,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_IGMP, 0, dev->ifindex);\n\tif (IS_ERR(rt)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tskb_dst_set(skb, &rt->dst);\n\tskb->dev = dev;\n\n\tskb_reserve(skb, hlen);\n\tskb_tailroom_reserve(skb, mtu, tlen);\n\n\tskb_reset_network_header(skb);\n\tpip = ip_hdr(skb);\n\tskb_put(skb, sizeof(struct iphdr) + 4);\n\n\tpip->version  = 4;\n\tpip->ihl      = (sizeof(struct iphdr)+4)>>2;\n\tpip->tos      = 0xc0;\n\tpip->frag_off = htons(IP_DF);\n\tpip->ttl      = 1;\n\tpip->daddr    = fl4.daddr;\n\n\trcu_read_lock();\n\tpip->saddr    = igmpv3_get_srcaddr(dev, &fl4);\n\trcu_read_unlock();\n\n\tpip->protocol = IPPROTO_IGMP;\n\tpip->tot_len  = 0;\t \n\tip_select_ident(net, skb, NULL);\n\t((u8 *)&pip[1])[0] = IPOPT_RA;\n\t((u8 *)&pip[1])[1] = 4;\n\t((u8 *)&pip[1])[2] = 0;\n\t((u8 *)&pip[1])[3] = 0;\n\n\tskb->transport_header = skb->network_header + sizeof(struct iphdr) + 4;\n\tskb_put(skb, sizeof(*pig));\n\tpig = igmpv3_report_hdr(skb);\n\tpig->type = IGMPV3_HOST_MEMBERSHIP_REPORT;\n\tpig->resv1 = 0;\n\tpig->csum = 0;\n\tpig->resv2 = 0;\n\tpig->ngrec = 0;\n\treturn skb;\n}\n\nstatic int igmpv3_sendpack(struct sk_buff *skb)\n{\n\tstruct igmphdr *pig = igmp_hdr(skb);\n\tconst int igmplen = skb_tail_pointer(skb) - skb_transport_header(skb);\n\n\tpig->csum = ip_compute_csum(igmp_hdr(skb), igmplen);\n\n\treturn ip_local_out(dev_net(skb_dst(skb)->dev), skb->sk, skb);\n}\n\nstatic int grec_size(struct ip_mc_list *pmc, int type, int gdel, int sdel)\n{\n\treturn sizeof(struct igmpv3_grec) + 4*igmp_scount(pmc, type, gdel, sdel);\n}\n\nstatic struct sk_buff *add_grhead(struct sk_buff *skb, struct ip_mc_list *pmc,\n\tint type, struct igmpv3_grec **ppgr, unsigned int mtu)\n{\n\tstruct net_device *dev = pmc->interface->dev;\n\tstruct igmpv3_report *pih;\n\tstruct igmpv3_grec *pgr;\n\n\tif (!skb) {\n\t\tskb = igmpv3_newpack(dev, mtu);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t}\n\tpgr = skb_put(skb, sizeof(struct igmpv3_grec));\n\tpgr->grec_type = type;\n\tpgr->grec_auxwords = 0;\n\tpgr->grec_nsrcs = 0;\n\tpgr->grec_mca = pmc->multiaddr;\n\tpih = igmpv3_report_hdr(skb);\n\tpih->ngrec = htons(ntohs(pih->ngrec)+1);\n\t*ppgr = pgr;\n\treturn skb;\n}\n\n#define AVAILABLE(skb)\t((skb) ? skb_availroom(skb) : 0)\n\nstatic struct sk_buff *add_grec(struct sk_buff *skb, struct ip_mc_list *pmc,\n\tint type, int gdeleted, int sdeleted)\n{\n\tstruct net_device *dev = pmc->interface->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct igmpv3_report *pih;\n\tstruct igmpv3_grec *pgr = NULL;\n\tstruct ip_sf_list *psf, *psf_next, *psf_prev, **psf_list;\n\tint scount, stotal, first, isquery, truncate;\n\tunsigned int mtu;\n\n\tif (pmc->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn skb;\n\tif (ipv4_is_local_multicast(pmc->multiaddr) &&\n\t    !READ_ONCE(net->ipv4.sysctl_igmp_llm_reports))\n\t\treturn skb;\n\n\tmtu = READ_ONCE(dev->mtu);\n\tif (mtu < IPV4_MIN_MTU)\n\t\treturn skb;\n\n\tisquery = type == IGMPV3_MODE_IS_INCLUDE ||\n\t\t  type == IGMPV3_MODE_IS_EXCLUDE;\n\ttruncate = type == IGMPV3_MODE_IS_EXCLUDE ||\n\t\t    type == IGMPV3_CHANGE_TO_EXCLUDE;\n\n\tstotal = scount = 0;\n\n\tpsf_list = sdeleted ? &pmc->tomb : &pmc->sources;\n\n\tif (!*psf_list)\n\t\tgoto empty_source;\n\n\tpih = skb ? igmpv3_report_hdr(skb) : NULL;\n\n\t \n\tif (truncate) {\n\t\tif (pih && pih->ngrec &&\n\t\t    AVAILABLE(skb) < grec_size(pmc, type, gdeleted, sdeleted)) {\n\t\t\tif (skb)\n\t\t\t\tigmpv3_sendpack(skb);\n\t\t\tskb = igmpv3_newpack(dev, mtu);\n\t\t}\n\t}\n\tfirst = 1;\n\tpsf_prev = NULL;\n\tfor (psf = *psf_list; psf; psf = psf_next) {\n\t\t__be32 *psrc;\n\n\t\tpsf_next = psf->sf_next;\n\n\t\tif (!is_in(pmc, psf, type, gdeleted, sdeleted)) {\n\t\t\tpsf_prev = psf;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (((gdeleted && pmc->sfmode == MCAST_EXCLUDE) ||\n\t\t     (!gdeleted && pmc->crcount)) &&\n\t\t    (type == IGMPV3_ALLOW_NEW_SOURCES ||\n\t\t     type == IGMPV3_BLOCK_OLD_SOURCES) && psf->sf_crcount)\n\t\t\tgoto decrease_sf_crcount;\n\n\t\t \n\t\tif (isquery)\n\t\t\tpsf->sf_gsresp = 0;\n\n\t\tif (AVAILABLE(skb) < sizeof(__be32) +\n\t\t    first*sizeof(struct igmpv3_grec)) {\n\t\t\tif (truncate && !first)\n\t\t\t\tbreak;\t  \n\t\t\tif (pgr)\n\t\t\t\tpgr->grec_nsrcs = htons(scount);\n\t\t\tif (skb)\n\t\t\t\tigmpv3_sendpack(skb);\n\t\t\tskb = igmpv3_newpack(dev, mtu);\n\t\t\tfirst = 1;\n\t\t\tscount = 0;\n\t\t}\n\t\tif (first) {\n\t\t\tskb = add_grhead(skb, pmc, type, &pgr, mtu);\n\t\t\tfirst = 0;\n\t\t}\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t\tpsrc = skb_put(skb, sizeof(__be32));\n\t\t*psrc = psf->sf_inaddr;\n\t\tscount++; stotal++;\n\t\tif ((type == IGMPV3_ALLOW_NEW_SOURCES ||\n\t\t     type == IGMPV3_BLOCK_OLD_SOURCES) && psf->sf_crcount) {\ndecrease_sf_crcount:\n\t\t\tpsf->sf_crcount--;\n\t\t\tif ((sdeleted || gdeleted) && psf->sf_crcount == 0) {\n\t\t\t\tif (psf_prev)\n\t\t\t\t\tpsf_prev->sf_next = psf->sf_next;\n\t\t\t\telse\n\t\t\t\t\t*psf_list = psf->sf_next;\n\t\t\t\tkfree(psf);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tpsf_prev = psf;\n\t}\n\nempty_source:\n\tif (!stotal) {\n\t\tif (type == IGMPV3_ALLOW_NEW_SOURCES ||\n\t\t    type == IGMPV3_BLOCK_OLD_SOURCES)\n\t\t\treturn skb;\n\t\tif (pmc->crcount || isquery) {\n\t\t\t \n\t\t\tif (skb && AVAILABLE(skb) < sizeof(struct igmpv3_grec)) {\n\t\t\t\tigmpv3_sendpack(skb);\n\t\t\t\tskb = NULL;  \n\t\t\t}\n\t\t\tskb = add_grhead(skb, pmc, type, &pgr, mtu);\n\t\t}\n\t}\n\tif (pgr)\n\t\tpgr->grec_nsrcs = htons(scount);\n\n\tif (isquery)\n\t\tpmc->gsquery = 0;\t \n\treturn skb;\n}\n\nstatic int igmpv3_send_report(struct in_device *in_dev, struct ip_mc_list *pmc)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct net *net = dev_net(in_dev->dev);\n\tint type;\n\n\tif (!pmc) {\n\t\trcu_read_lock();\n\t\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\t\tif (pmc->multiaddr == IGMP_ALL_HOSTS)\n\t\t\t\tcontinue;\n\t\t\tif (ipv4_is_local_multicast(pmc->multiaddr) &&\n\t\t\t    !READ_ONCE(net->ipv4.sysctl_igmp_llm_reports))\n\t\t\t\tcontinue;\n\t\t\tspin_lock_bh(&pmc->lock);\n\t\t\tif (pmc->sfcount[MCAST_EXCLUDE])\n\t\t\t\ttype = IGMPV3_MODE_IS_EXCLUDE;\n\t\t\telse\n\t\t\t\ttype = IGMPV3_MODE_IS_INCLUDE;\n\t\t\tskb = add_grec(skb, pmc, type, 0, 0);\n\t\t\tspin_unlock_bh(&pmc->lock);\n\t\t}\n\t\trcu_read_unlock();\n\t} else {\n\t\tspin_lock_bh(&pmc->lock);\n\t\tif (pmc->sfcount[MCAST_EXCLUDE])\n\t\t\ttype = IGMPV3_MODE_IS_EXCLUDE;\n\t\telse\n\t\t\ttype = IGMPV3_MODE_IS_INCLUDE;\n\t\tskb = add_grec(skb, pmc, type, 0, 0);\n\t\tspin_unlock_bh(&pmc->lock);\n\t}\n\tif (!skb)\n\t\treturn 0;\n\treturn igmpv3_sendpack(skb);\n}\n\n \nstatic void igmpv3_clear_zeros(struct ip_sf_list **ppsf)\n{\n\tstruct ip_sf_list *psf_prev, *psf_next, *psf;\n\n\tpsf_prev = NULL;\n\tfor (psf = *ppsf; psf; psf = psf_next) {\n\t\tpsf_next = psf->sf_next;\n\t\tif (psf->sf_crcount == 0) {\n\t\t\tif (psf_prev)\n\t\t\t\tpsf_prev->sf_next = psf->sf_next;\n\t\t\telse\n\t\t\t\t*ppsf = psf->sf_next;\n\t\t\tkfree(psf);\n\t\t} else\n\t\t\tpsf_prev = psf;\n\t}\n}\n\nstatic void kfree_pmc(struct ip_mc_list *pmc)\n{\n\tip_sf_list_clear_all(pmc->sources);\n\tip_sf_list_clear_all(pmc->tomb);\n\tkfree(pmc);\n}\n\nstatic void igmpv3_send_cr(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc, *pmc_prev, *pmc_next;\n\tstruct sk_buff *skb = NULL;\n\tint type, dtype;\n\n\trcu_read_lock();\n\tspin_lock_bh(&in_dev->mc_tomb_lock);\n\n\t \n\tpmc_prev = NULL;\n\tfor (pmc = in_dev->mc_tomb; pmc; pmc = pmc_next) {\n\t\tpmc_next = pmc->next;\n\t\tif (pmc->sfmode == MCAST_INCLUDE) {\n\t\t\ttype = IGMPV3_BLOCK_OLD_SOURCES;\n\t\t\tdtype = IGMPV3_BLOCK_OLD_SOURCES;\n\t\t\tskb = add_grec(skb, pmc, type, 1, 0);\n\t\t\tskb = add_grec(skb, pmc, dtype, 1, 1);\n\t\t}\n\t\tif (pmc->crcount) {\n\t\t\tif (pmc->sfmode == MCAST_EXCLUDE) {\n\t\t\t\ttype = IGMPV3_CHANGE_TO_INCLUDE;\n\t\t\t\tskb = add_grec(skb, pmc, type, 1, 0);\n\t\t\t}\n\t\t\tpmc->crcount--;\n\t\t\tif (pmc->crcount == 0) {\n\t\t\t\tigmpv3_clear_zeros(&pmc->tomb);\n\t\t\t\tigmpv3_clear_zeros(&pmc->sources);\n\t\t\t}\n\t\t}\n\t\tif (pmc->crcount == 0 && !pmc->tomb && !pmc->sources) {\n\t\t\tif (pmc_prev)\n\t\t\t\tpmc_prev->next = pmc_next;\n\t\t\telse\n\t\t\t\tin_dev->mc_tomb = pmc_next;\n\t\t\tin_dev_put(pmc->interface);\n\t\t\tkfree_pmc(pmc);\n\t\t} else\n\t\t\tpmc_prev = pmc;\n\t}\n\tspin_unlock_bh(&in_dev->mc_tomb_lock);\n\n\t \n\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\tspin_lock_bh(&pmc->lock);\n\t\tif (pmc->sfcount[MCAST_EXCLUDE]) {\n\t\t\ttype = IGMPV3_BLOCK_OLD_SOURCES;\n\t\t\tdtype = IGMPV3_ALLOW_NEW_SOURCES;\n\t\t} else {\n\t\t\ttype = IGMPV3_ALLOW_NEW_SOURCES;\n\t\t\tdtype = IGMPV3_BLOCK_OLD_SOURCES;\n\t\t}\n\t\tskb = add_grec(skb, pmc, type, 0, 0);\n\t\tskb = add_grec(skb, pmc, dtype, 0, 1);\t \n\n\t\t \n\t\tif (pmc->crcount) {\n\t\t\tif (pmc->sfmode == MCAST_EXCLUDE)\n\t\t\t\ttype = IGMPV3_CHANGE_TO_EXCLUDE;\n\t\t\telse\n\t\t\t\ttype = IGMPV3_CHANGE_TO_INCLUDE;\n\t\t\tskb = add_grec(skb, pmc, type, 0, 0);\n\t\t\tpmc->crcount--;\n\t\t}\n\t\tspin_unlock_bh(&pmc->lock);\n\t}\n\trcu_read_unlock();\n\n\tif (!skb)\n\t\treturn;\n\t(void) igmpv3_sendpack(skb);\n}\n\nstatic int igmp_send_report(struct in_device *in_dev, struct ip_mc_list *pmc,\n\tint type)\n{\n\tstruct sk_buff *skb;\n\tstruct iphdr *iph;\n\tstruct igmphdr *ih;\n\tstruct rtable *rt;\n\tstruct net_device *dev = in_dev->dev;\n\tstruct net *net = dev_net(dev);\n\t__be32\tgroup = pmc ? pmc->multiaddr : 0;\n\tstruct flowi4 fl4;\n\t__be32\tdst;\n\tint hlen, tlen;\n\n\tif (type == IGMPV3_HOST_MEMBERSHIP_REPORT)\n\t\treturn igmpv3_send_report(in_dev, pmc);\n\n\tif (ipv4_is_local_multicast(group) &&\n\t    !READ_ONCE(net->ipv4.sysctl_igmp_llm_reports))\n\t\treturn 0;\n\n\tif (type == IGMP_HOST_LEAVE_MESSAGE)\n\t\tdst = IGMP_ALL_ROUTER;\n\telse\n\t\tdst = group;\n\n\trt = ip_route_output_ports(net, &fl4, NULL, dst, 0,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_IGMP, 0, dev->ifindex);\n\tif (IS_ERR(rt))\n\t\treturn -1;\n\n\thlen = LL_RESERVED_SPACE(dev);\n\ttlen = dev->needed_tailroom;\n\tskb = alloc_skb(IGMP_SIZE + hlen + tlen, GFP_ATOMIC);\n\tif (!skb) {\n\t\tip_rt_put(rt);\n\t\treturn -1;\n\t}\n\tskb->priority = TC_PRIO_CONTROL;\n\n\tskb_dst_set(skb, &rt->dst);\n\n\tskb_reserve(skb, hlen);\n\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tskb_put(skb, sizeof(struct iphdr) + 4);\n\n\tiph->version  = 4;\n\tiph->ihl      = (sizeof(struct iphdr)+4)>>2;\n\tiph->tos      = 0xc0;\n\tiph->frag_off = htons(IP_DF);\n\tiph->ttl      = 1;\n\tiph->daddr    = dst;\n\tiph->saddr    = fl4.saddr;\n\tiph->protocol = IPPROTO_IGMP;\n\tip_select_ident(net, skb, NULL);\n\t((u8 *)&iph[1])[0] = IPOPT_RA;\n\t((u8 *)&iph[1])[1] = 4;\n\t((u8 *)&iph[1])[2] = 0;\n\t((u8 *)&iph[1])[3] = 0;\n\n\tih = skb_put(skb, sizeof(struct igmphdr));\n\tih->type = type;\n\tih->code = 0;\n\tih->csum = 0;\n\tih->group = group;\n\tih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));\n\n\treturn ip_local_out(net, skb->sk, skb);\n}\n\nstatic void igmp_gq_timer_expire(struct timer_list *t)\n{\n\tstruct in_device *in_dev = from_timer(in_dev, t, mr_gq_timer);\n\n\tin_dev->mr_gq_running = 0;\n\tigmpv3_send_report(in_dev, NULL);\n\tin_dev_put(in_dev);\n}\n\nstatic void igmp_ifc_timer_expire(struct timer_list *t)\n{\n\tstruct in_device *in_dev = from_timer(in_dev, t, mr_ifc_timer);\n\tu32 mr_ifc_count;\n\n\tigmpv3_send_cr(in_dev);\nrestart:\n\tmr_ifc_count = READ_ONCE(in_dev->mr_ifc_count);\n\n\tif (mr_ifc_count) {\n\t\tif (cmpxchg(&in_dev->mr_ifc_count,\n\t\t\t    mr_ifc_count,\n\t\t\t    mr_ifc_count - 1) != mr_ifc_count)\n\t\t\tgoto restart;\n\t\tigmp_ifc_start_timer(in_dev,\n\t\t\t\t     unsolicited_report_interval(in_dev));\n\t}\n\tin_dev_put(in_dev);\n}\n\nstatic void igmp_ifc_event(struct in_device *in_dev)\n{\n\tstruct net *net = dev_net(in_dev->dev);\n\tif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev))\n\t\treturn;\n\tWRITE_ONCE(in_dev->mr_ifc_count, in_dev->mr_qrv ?: READ_ONCE(net->ipv4.sysctl_igmp_qrv));\n\tigmp_ifc_start_timer(in_dev, 1);\n}\n\n\nstatic void igmp_timer_expire(struct timer_list *t)\n{\n\tstruct ip_mc_list *im = from_timer(im, t, timer);\n\tstruct in_device *in_dev = im->interface;\n\n\tspin_lock(&im->lock);\n\tim->tm_running = 0;\n\n\tif (im->unsolicit_count && --im->unsolicit_count)\n\t\tigmp_start_timer(im, unsolicited_report_interval(in_dev));\n\n\tim->reporter = 1;\n\tspin_unlock(&im->lock);\n\n\tif (IGMP_V1_SEEN(in_dev))\n\t\tigmp_send_report(in_dev, im, IGMP_HOST_MEMBERSHIP_REPORT);\n\telse if (IGMP_V2_SEEN(in_dev))\n\t\tigmp_send_report(in_dev, im, IGMPV2_HOST_MEMBERSHIP_REPORT);\n\telse\n\t\tigmp_send_report(in_dev, im, IGMPV3_HOST_MEMBERSHIP_REPORT);\n\n\tip_ma_put(im);\n}\n\n \nstatic int igmp_xmarksources(struct ip_mc_list *pmc, int nsrcs, __be32 *srcs)\n{\n\tstruct ip_sf_list *psf;\n\tint i, scount;\n\n\tscount = 0;\n\tfor (psf = pmc->sources; psf; psf = psf->sf_next) {\n\t\tif (scount == nsrcs)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nsrcs; i++) {\n\t\t\t \n\t\t\tif (psf->sf_count[MCAST_INCLUDE] ||\n\t\t\t    pmc->sfcount[MCAST_EXCLUDE] !=\n\t\t\t    psf->sf_count[MCAST_EXCLUDE])\n\t\t\t\tbreak;\n\t\t\tif (srcs[i] == psf->sf_inaddr) {\n\t\t\t\tscount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpmc->gsquery = 0;\n\tif (scount == nsrcs)\t \n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int igmp_marksources(struct ip_mc_list *pmc, int nsrcs, __be32 *srcs)\n{\n\tstruct ip_sf_list *psf;\n\tint i, scount;\n\n\tif (pmc->sfmode == MCAST_EXCLUDE)\n\t\treturn igmp_xmarksources(pmc, nsrcs, srcs);\n\n\t \n\tscount = 0;\n\tfor (psf = pmc->sources; psf; psf = psf->sf_next) {\n\t\tif (scount == nsrcs)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nsrcs; i++)\n\t\t\tif (srcs[i] == psf->sf_inaddr) {\n\t\t\t\tpsf->sf_gsresp = 1;\n\t\t\t\tscount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tif (!scount) {\n\t\tpmc->gsquery = 0;\n\t\treturn 0;\n\t}\n\tpmc->gsquery = 1;\n\treturn 1;\n}\n\n \nstatic bool igmp_heard_report(struct in_device *in_dev, __be32 group)\n{\n\tstruct ip_mc_list *im;\n\tstruct net *net = dev_net(in_dev->dev);\n\n\t \n\n\tif (group == IGMP_ALL_HOSTS)\n\t\treturn false;\n\tif (ipv4_is_local_multicast(group) &&\n\t    !READ_ONCE(net->ipv4.sysctl_igmp_llm_reports))\n\t\treturn false;\n\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, im) {\n\t\tif (im->multiaddr == group) {\n\t\t\tigmp_stop_timer(im);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn false;\n}\n\n \nstatic bool igmp_heard_query(struct in_device *in_dev, struct sk_buff *skb,\n\tint len)\n{\n\tstruct igmphdr \t\t*ih = igmp_hdr(skb);\n\tstruct igmpv3_query *ih3 = igmpv3_query_hdr(skb);\n\tstruct ip_mc_list\t*im;\n\t__be32\t\t\tgroup = ih->group;\n\tint\t\t\tmax_delay;\n\tint\t\t\tmark = 0;\n\tstruct net\t\t*net = dev_net(in_dev->dev);\n\n\n\tif (len == 8) {\n\t\tif (ih->code == 0) {\n\t\t\t \n\n\t\t\tmax_delay = IGMP_QUERY_RESPONSE_INTERVAL;\n\t\t\tin_dev->mr_v1_seen = jiffies +\n\t\t\t\t(in_dev->mr_qrv * in_dev->mr_qi) +\n\t\t\t\tin_dev->mr_qri;\n\t\t\tgroup = 0;\n\t\t} else {\n\t\t\t \n\t\t\tmax_delay = ih->code*(HZ/IGMP_TIMER_SCALE);\n\t\t\tin_dev->mr_v2_seen = jiffies +\n\t\t\t\t(in_dev->mr_qrv * in_dev->mr_qi) +\n\t\t\t\tin_dev->mr_qri;\n\t\t}\n\t\t \n\t\tWRITE_ONCE(in_dev->mr_ifc_count, 0);\n\t\tif (del_timer(&in_dev->mr_ifc_timer))\n\t\t\t__in_dev_put(in_dev);\n\t\t \n\t\tigmpv3_clear_delrec(in_dev);\n\t} else if (len < 12) {\n\t\treturn true;\t \n\t} else if (IGMP_V1_SEEN(in_dev)) {\n\t\t \n\t\tmax_delay = IGMP_QUERY_RESPONSE_INTERVAL;\n\t\tgroup = 0;\n\t} else if (IGMP_V2_SEEN(in_dev)) {\n\t\t \n\t\tmax_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);\n\t\tif (!max_delay)\n\t\t\tmax_delay = 1;\t \n\t} else {  \n\t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query)))\n\t\t\treturn true;\n\n\t\tih3 = igmpv3_query_hdr(skb);\n\t\tif (ih3->nsrcs) {\n\t\t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query)\n\t\t\t\t\t   + ntohs(ih3->nsrcs)*sizeof(__be32)))\n\t\t\t\treturn true;\n\t\t\tih3 = igmpv3_query_hdr(skb);\n\t\t}\n\n\t\tmax_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);\n\t\tif (!max_delay)\n\t\t\tmax_delay = 1;\t \n\t\tin_dev->mr_maxdelay = max_delay;\n\n\t\t \n\t\tin_dev->mr_qrv = ih3->qrv ?: READ_ONCE(net->ipv4.sysctl_igmp_qrv);\n\t\tin_dev->mr_qi = IGMPV3_QQIC(ih3->qqic)*HZ ?: IGMP_QUERY_INTERVAL;\n\n\t\t \n\t\tif (in_dev->mr_qri >= in_dev->mr_qi)\n\t\t\tin_dev->mr_qri = (in_dev->mr_qi/HZ - 1)*HZ;\n\n\t\tif (!group) {  \n\t\t\tif (ih3->nsrcs)\n\t\t\t\treturn true;\t \n\t\t\tigmp_gq_start_timer(in_dev);\n\t\t\treturn false;\n\t\t}\n\t\t \n\t\tmark = ih3->nsrcs != 0;\n\t}\n\n\t \n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, im) {\n\t\tint changed;\n\n\t\tif (group && group != im->multiaddr)\n\t\t\tcontinue;\n\t\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\t\tcontinue;\n\t\tif (ipv4_is_local_multicast(im->multiaddr) &&\n\t\t    !READ_ONCE(net->ipv4.sysctl_igmp_llm_reports))\n\t\t\tcontinue;\n\t\tspin_lock_bh(&im->lock);\n\t\tif (im->tm_running)\n\t\t\tim->gsquery = im->gsquery && mark;\n\t\telse\n\t\t\tim->gsquery = mark;\n\t\tchanged = !im->gsquery ||\n\t\t\tigmp_marksources(im, ntohs(ih3->nsrcs), ih3->srcs);\n\t\tspin_unlock_bh(&im->lock);\n\t\tif (changed)\n\t\t\tigmp_mod_timer(im, max_delay);\n\t}\n\trcu_read_unlock();\n\treturn false;\n}\n\n \nint igmp_rcv(struct sk_buff *skb)\n{\n\t \n\tstruct igmphdr *ih;\n\tstruct net_device *dev = skb->dev;\n\tstruct in_device *in_dev;\n\tint len = skb->len;\n\tbool dropped = true;\n\n\tif (netif_is_l3_master(dev)) {\n\t\tdev = dev_get_by_index_rcu(dev_net(dev), IPCB(skb)->iif);\n\t\tif (!dev)\n\t\t\tgoto drop;\n\t}\n\n\tin_dev = __in_dev_get_rcu(dev);\n\tif (!in_dev)\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, sizeof(struct igmphdr)))\n\t\tgoto drop;\n\n\tif (skb_checksum_simple_validate(skb))\n\t\tgoto drop;\n\n\tih = igmp_hdr(skb);\n\tswitch (ih->type) {\n\tcase IGMP_HOST_MEMBERSHIP_QUERY:\n\t\tdropped = igmp_heard_query(in_dev, skb, len);\n\t\tbreak;\n\tcase IGMP_HOST_MEMBERSHIP_REPORT:\n\tcase IGMPV2_HOST_MEMBERSHIP_REPORT:\n\t\t \n\t\tif (rt_is_output_route(skb_rtable(skb)))\n\t\t\tbreak;\n\t\t \n\t\tif (skb->pkt_type == PACKET_MULTICAST ||\n\t\t    skb->pkt_type == PACKET_BROADCAST)\n\t\t\tdropped = igmp_heard_report(in_dev, ih->group);\n\t\tbreak;\n\tcase IGMP_PIM:\n#ifdef CONFIG_IP_PIMSM_V1\n\t\treturn pim_rcv_v1(skb);\n#endif\n\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\tcase IGMP_DVMRP:\n\tcase IGMP_TRACE:\n\tcase IGMP_HOST_LEAVE_MESSAGE:\n\tcase IGMP_MTRACE:\n\tcase IGMP_MTRACE_RESP:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\ndrop:\n\tif (dropped)\n\t\tkfree_skb(skb);\n\telse\n\t\tconsume_skb(skb);\n\treturn 0;\n}\n\n#endif\n\n\n \n\nstatic void ip_mc_filter_add(struct in_device *in_dev, __be32 addr)\n{\n\tchar buf[MAX_ADDR_LEN];\n\tstruct net_device *dev = in_dev->dev;\n\n\t \n\tif (arp_mc_map(addr, buf, dev, 0) == 0)\n\t\tdev_mc_add(dev, buf);\n}\n\n \n\nstatic void ip_mc_filter_del(struct in_device *in_dev, __be32 addr)\n{\n\tchar buf[MAX_ADDR_LEN];\n\tstruct net_device *dev = in_dev->dev;\n\n\tif (arp_mc_map(addr, buf, dev, 0) == 0)\n\t\tdev_mc_del(dev, buf);\n}\n\n#ifdef CONFIG_IP_MULTICAST\n \nstatic void igmpv3_add_delrec(struct in_device *in_dev, struct ip_mc_list *im,\n\t\t\t      gfp_t gfp)\n{\n\tstruct ip_mc_list *pmc;\n\tstruct net *net = dev_net(in_dev->dev);\n\n\t \n\tpmc = kzalloc(sizeof(*pmc), gfp);\n\tif (!pmc)\n\t\treturn;\n\tspin_lock_init(&pmc->lock);\n\tspin_lock_bh(&im->lock);\n\tpmc->interface = im->interface;\n\tin_dev_hold(in_dev);\n\tpmc->multiaddr = im->multiaddr;\n\tpmc->crcount = in_dev->mr_qrv ?: READ_ONCE(net->ipv4.sysctl_igmp_qrv);\n\tpmc->sfmode = im->sfmode;\n\tif (pmc->sfmode == MCAST_INCLUDE) {\n\t\tstruct ip_sf_list *psf;\n\n\t\tpmc->tomb = im->tomb;\n\t\tpmc->sources = im->sources;\n\t\tim->tomb = im->sources = NULL;\n\t\tfor (psf = pmc->sources; psf; psf = psf->sf_next)\n\t\t\tpsf->sf_crcount = pmc->crcount;\n\t}\n\tspin_unlock_bh(&im->lock);\n\n\tspin_lock_bh(&in_dev->mc_tomb_lock);\n\tpmc->next = in_dev->mc_tomb;\n\tin_dev->mc_tomb = pmc;\n\tspin_unlock_bh(&in_dev->mc_tomb_lock);\n}\n\n \nstatic void igmpv3_del_delrec(struct in_device *in_dev, struct ip_mc_list *im)\n{\n\tstruct ip_mc_list *pmc, *pmc_prev;\n\tstruct ip_sf_list *psf;\n\tstruct net *net = dev_net(in_dev->dev);\n\t__be32 multiaddr = im->multiaddr;\n\n\tspin_lock_bh(&in_dev->mc_tomb_lock);\n\tpmc_prev = NULL;\n\tfor (pmc = in_dev->mc_tomb; pmc; pmc = pmc->next) {\n\t\tif (pmc->multiaddr == multiaddr)\n\t\t\tbreak;\n\t\tpmc_prev = pmc;\n\t}\n\tif (pmc) {\n\t\tif (pmc_prev)\n\t\t\tpmc_prev->next = pmc->next;\n\t\telse\n\t\t\tin_dev->mc_tomb = pmc->next;\n\t}\n\tspin_unlock_bh(&in_dev->mc_tomb_lock);\n\n\tspin_lock_bh(&im->lock);\n\tif (pmc) {\n\t\tim->interface = pmc->interface;\n\t\tif (im->sfmode == MCAST_INCLUDE) {\n\t\t\tswap(im->tomb, pmc->tomb);\n\t\t\tswap(im->sources, pmc->sources);\n\t\t\tfor (psf = im->sources; psf; psf = psf->sf_next)\n\t\t\t\tpsf->sf_crcount = in_dev->mr_qrv ?:\n\t\t\t\t\tREAD_ONCE(net->ipv4.sysctl_igmp_qrv);\n\t\t} else {\n\t\t\tim->crcount = in_dev->mr_qrv ?:\n\t\t\t\tREAD_ONCE(net->ipv4.sysctl_igmp_qrv);\n\t\t}\n\t\tin_dev_put(pmc->interface);\n\t\tkfree_pmc(pmc);\n\t}\n\tspin_unlock_bh(&im->lock);\n}\n\n \nstatic void igmpv3_clear_delrec(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc, *nextpmc;\n\n\tspin_lock_bh(&in_dev->mc_tomb_lock);\n\tpmc = in_dev->mc_tomb;\n\tin_dev->mc_tomb = NULL;\n\tspin_unlock_bh(&in_dev->mc_tomb_lock);\n\n\tfor (; pmc; pmc = nextpmc) {\n\t\tnextpmc = pmc->next;\n\t\tip_mc_clear_src(pmc);\n\t\tin_dev_put(pmc->interface);\n\t\tkfree_pmc(pmc);\n\t}\n\t \n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\tstruct ip_sf_list *psf;\n\n\t\tspin_lock_bh(&pmc->lock);\n\t\tpsf = pmc->tomb;\n\t\tpmc->tomb = NULL;\n\t\tspin_unlock_bh(&pmc->lock);\n\t\tip_sf_list_clear_all(psf);\n\t}\n\trcu_read_unlock();\n}\n#endif\n\nstatic void __igmp_group_dropped(struct ip_mc_list *im, gfp_t gfp)\n{\n\tstruct in_device *in_dev = im->interface;\n#ifdef CONFIG_IP_MULTICAST\n\tstruct net *net = dev_net(in_dev->dev);\n\tint reporter;\n#endif\n\n\tif (im->loaded) {\n\t\tim->loaded = 0;\n\t\tip_mc_filter_del(in_dev, im->multiaddr);\n\t}\n\n#ifdef CONFIG_IP_MULTICAST\n\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn;\n\tif (ipv4_is_local_multicast(im->multiaddr) &&\n\t    !READ_ONCE(net->ipv4.sysctl_igmp_llm_reports))\n\t\treturn;\n\n\treporter = im->reporter;\n\tigmp_stop_timer(im);\n\n\tif (!in_dev->dead) {\n\t\tif (IGMP_V1_SEEN(in_dev))\n\t\t\treturn;\n\t\tif (IGMP_V2_SEEN(in_dev)) {\n\t\t\tif (reporter)\n\t\t\t\tigmp_send_report(in_dev, im, IGMP_HOST_LEAVE_MESSAGE);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tigmpv3_add_delrec(in_dev, im, gfp);\n\n\t\tigmp_ifc_event(in_dev);\n\t}\n#endif\n}\n\nstatic void igmp_group_dropped(struct ip_mc_list *im)\n{\n\t__igmp_group_dropped(im, GFP_KERNEL);\n}\n\nstatic void igmp_group_added(struct ip_mc_list *im)\n{\n\tstruct in_device *in_dev = im->interface;\n#ifdef CONFIG_IP_MULTICAST\n\tstruct net *net = dev_net(in_dev->dev);\n#endif\n\n\tif (im->loaded == 0) {\n\t\tim->loaded = 1;\n\t\tip_mc_filter_add(in_dev, im->multiaddr);\n\t}\n\n#ifdef CONFIG_IP_MULTICAST\n\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn;\n\tif (ipv4_is_local_multicast(im->multiaddr) &&\n\t    !READ_ONCE(net->ipv4.sysctl_igmp_llm_reports))\n\t\treturn;\n\n\tif (in_dev->dead)\n\t\treturn;\n\n\tim->unsolicit_count = READ_ONCE(net->ipv4.sysctl_igmp_qrv);\n\tif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev)) {\n\t\tspin_lock_bh(&im->lock);\n\t\tigmp_start_timer(im, IGMP_INITIAL_REPORT_DELAY);\n\t\tspin_unlock_bh(&im->lock);\n\t\treturn;\n\t}\n\t \n\n\t \n\tif (im->sfmode == MCAST_EXCLUDE)\n\t\tim->crcount = in_dev->mr_qrv ?: READ_ONCE(net->ipv4.sysctl_igmp_qrv);\n\n\tigmp_ifc_event(in_dev);\n#endif\n}\n\n\n \n\nstatic u32 ip_mc_hash(const struct ip_mc_list *im)\n{\n\treturn hash_32((__force u32)im->multiaddr, MC_HASH_SZ_LOG);\n}\n\nstatic void ip_mc_hash_add(struct in_device *in_dev,\n\t\t\t   struct ip_mc_list *im)\n{\n\tstruct ip_mc_list __rcu **mc_hash;\n\tu32 hash;\n\n\tmc_hash = rtnl_dereference(in_dev->mc_hash);\n\tif (mc_hash) {\n\t\thash = ip_mc_hash(im);\n\t\tim->next_hash = mc_hash[hash];\n\t\trcu_assign_pointer(mc_hash[hash], im);\n\t\treturn;\n\t}\n\n\t \n\tif (in_dev->mc_count < 4)\n\t\treturn;\n\n\tmc_hash = kzalloc(sizeof(struct ip_mc_list *) << MC_HASH_SZ_LOG,\n\t\t\t  GFP_KERNEL);\n\tif (!mc_hash)\n\t\treturn;\n\n\tfor_each_pmc_rtnl(in_dev, im) {\n\t\thash = ip_mc_hash(im);\n\t\tim->next_hash = mc_hash[hash];\n\t\tRCU_INIT_POINTER(mc_hash[hash], im);\n\t}\n\n\trcu_assign_pointer(in_dev->mc_hash, mc_hash);\n}\n\nstatic void ip_mc_hash_remove(struct in_device *in_dev,\n\t\t\t      struct ip_mc_list *im)\n{\n\tstruct ip_mc_list __rcu **mc_hash = rtnl_dereference(in_dev->mc_hash);\n\tstruct ip_mc_list *aux;\n\n\tif (!mc_hash)\n\t\treturn;\n\tmc_hash += ip_mc_hash(im);\n\twhile ((aux = rtnl_dereference(*mc_hash)) != im)\n\t\tmc_hash = &aux->next_hash;\n\t*mc_hash = im->next_hash;\n}\n\n\n \nstatic void ____ip_mc_inc_group(struct in_device *in_dev, __be32 addr,\n\t\t\t\tunsigned int mode, gfp_t gfp)\n{\n\tstruct ip_mc_list *im;\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, im) {\n\t\tif (im->multiaddr == addr) {\n\t\t\tim->users++;\n\t\t\tip_mc_add_src(in_dev, &addr, mode, 0, NULL, 0);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tim = kzalloc(sizeof(*im), gfp);\n\tif (!im)\n\t\tgoto out;\n\n\tim->users = 1;\n\tim->interface = in_dev;\n\tin_dev_hold(in_dev);\n\tim->multiaddr = addr;\n\t \n\tim->sfmode = mode;\n\tim->sfcount[mode] = 1;\n\trefcount_set(&im->refcnt, 1);\n\tspin_lock_init(&im->lock);\n#ifdef CONFIG_IP_MULTICAST\n\ttimer_setup(&im->timer, igmp_timer_expire, 0);\n#endif\n\n\tim->next_rcu = in_dev->mc_list;\n\tin_dev->mc_count++;\n\trcu_assign_pointer(in_dev->mc_list, im);\n\n\tip_mc_hash_add(in_dev, im);\n\n#ifdef CONFIG_IP_MULTICAST\n\tigmpv3_del_delrec(in_dev, im);\n#endif\n\tigmp_group_added(im);\n\tif (!in_dev->dead)\n\t\tip_rt_multicast_event(in_dev);\nout:\n\treturn;\n}\n\nvoid __ip_mc_inc_group(struct in_device *in_dev, __be32 addr, gfp_t gfp)\n{\n\t____ip_mc_inc_group(in_dev, addr, MCAST_EXCLUDE, gfp);\n}\nEXPORT_SYMBOL(__ip_mc_inc_group);\n\nvoid ip_mc_inc_group(struct in_device *in_dev, __be32 addr)\n{\n\t__ip_mc_inc_group(in_dev, addr, GFP_KERNEL);\n}\nEXPORT_SYMBOL(ip_mc_inc_group);\n\nstatic int ip_mc_check_iphdr(struct sk_buff *skb)\n{\n\tconst struct iphdr *iph;\n\tunsigned int len;\n\tunsigned int offset = skb_network_offset(skb) + sizeof(*iph);\n\n\tif (!pskb_may_pull(skb, offset))\n\t\treturn -EINVAL;\n\n\tiph = ip_hdr(skb);\n\n\tif (iph->version != 4 || ip_hdrlen(skb) < sizeof(*iph))\n\t\treturn -EINVAL;\n\n\toffset += ip_hdrlen(skb) - sizeof(*iph);\n\n\tif (!pskb_may_pull(skb, offset))\n\t\treturn -EINVAL;\n\n\tiph = ip_hdr(skb);\n\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\treturn -EINVAL;\n\n\tlen = skb_network_offset(skb) + ntohs(iph->tot_len);\n\tif (skb->len < len || len < offset)\n\t\treturn -EINVAL;\n\n\tskb_set_transport_header(skb, offset);\n\n\treturn 0;\n}\n\nstatic int ip_mc_check_igmp_reportv3(struct sk_buff *skb)\n{\n\tunsigned int len = skb_transport_offset(skb);\n\n\tlen += sizeof(struct igmpv3_report);\n\n\treturn ip_mc_may_pull(skb, len) ? 0 : -EINVAL;\n}\n\nstatic int ip_mc_check_igmp_query(struct sk_buff *skb)\n{\n\tunsigned int transport_len = ip_transport_len(skb);\n\tunsigned int len;\n\n\t \n\tif (transport_len != sizeof(struct igmphdr)) {\n\t\t \n\t\tif (transport_len < sizeof(struct igmpv3_query))\n\t\t\treturn -EINVAL;\n\n\t\tlen = skb_transport_offset(skb) + sizeof(struct igmpv3_query);\n\t\tif (!ip_mc_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!igmp_hdr(skb)->group &&\n\t    ip_hdr(skb)->daddr != htonl(INADDR_ALLHOSTS_GROUP))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ip_mc_check_igmp_msg(struct sk_buff *skb)\n{\n\tswitch (igmp_hdr(skb)->type) {\n\tcase IGMP_HOST_LEAVE_MESSAGE:\n\tcase IGMP_HOST_MEMBERSHIP_REPORT:\n\tcase IGMPV2_HOST_MEMBERSHIP_REPORT:\n\t\treturn 0;\n\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\t\treturn ip_mc_check_igmp_reportv3(skb);\n\tcase IGMP_HOST_MEMBERSHIP_QUERY:\n\t\treturn ip_mc_check_igmp_query(skb);\n\tdefault:\n\t\treturn -ENOMSG;\n\t}\n}\n\nstatic __sum16 ip_mc_validate_checksum(struct sk_buff *skb)\n{\n\treturn skb_checksum_simple_validate(skb);\n}\n\nstatic int ip_mc_check_igmp_csum(struct sk_buff *skb)\n{\n\tunsigned int len = skb_transport_offset(skb) + sizeof(struct igmphdr);\n\tunsigned int transport_len = ip_transport_len(skb);\n\tstruct sk_buff *skb_chk;\n\n\tif (!ip_mc_may_pull(skb, len))\n\t\treturn -EINVAL;\n\n\tskb_chk = skb_checksum_trimmed(skb, transport_len,\n\t\t\t\t       ip_mc_validate_checksum);\n\tif (!skb_chk)\n\t\treturn -EINVAL;\n\n\tif (skb_chk != skb)\n\t\tkfree_skb(skb_chk);\n\n\treturn 0;\n}\n\n \nint ip_mc_check_igmp(struct sk_buff *skb)\n{\n\tint ret = ip_mc_check_iphdr(skb);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ip_hdr(skb)->protocol != IPPROTO_IGMP)\n\t\treturn -ENOMSG;\n\n\tret = ip_mc_check_igmp_csum(skb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ip_mc_check_igmp_msg(skb);\n}\nEXPORT_SYMBOL(ip_mc_check_igmp);\n\n \nstatic void ip_mc_rejoin_groups(struct in_device *in_dev)\n{\n#ifdef CONFIG_IP_MULTICAST\n\tstruct ip_mc_list *im;\n\tint type;\n\tstruct net *net = dev_net(in_dev->dev);\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, im) {\n\t\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\t\tcontinue;\n\t\tif (ipv4_is_local_multicast(im->multiaddr) &&\n\t\t    !READ_ONCE(net->ipv4.sysctl_igmp_llm_reports))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (IGMP_V1_SEEN(in_dev))\n\t\t\ttype = IGMP_HOST_MEMBERSHIP_REPORT;\n\t\telse if (IGMP_V2_SEEN(in_dev))\n\t\t\ttype = IGMPV2_HOST_MEMBERSHIP_REPORT;\n\t\telse\n\t\t\ttype = IGMPV3_HOST_MEMBERSHIP_REPORT;\n\t\tigmp_send_report(in_dev, im, type);\n\t}\n#endif\n}\n\n \n\nvoid __ip_mc_dec_group(struct in_device *in_dev, __be32 addr, gfp_t gfp)\n{\n\tstruct ip_mc_list *i;\n\tstruct ip_mc_list __rcu **ip;\n\n\tASSERT_RTNL();\n\n\tfor (ip = &in_dev->mc_list;\n\t     (i = rtnl_dereference(*ip)) != NULL;\n\t     ip = &i->next_rcu) {\n\t\tif (i->multiaddr == addr) {\n\t\t\tif (--i->users == 0) {\n\t\t\t\tip_mc_hash_remove(in_dev, i);\n\t\t\t\t*ip = i->next_rcu;\n\t\t\t\tin_dev->mc_count--;\n\t\t\t\t__igmp_group_dropped(i, gfp);\n\t\t\t\tip_mc_clear_src(i);\n\n\t\t\t\tif (!in_dev->dead)\n\t\t\t\t\tip_rt_multicast_event(in_dev);\n\n\t\t\t\tip_ma_put(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(__ip_mc_dec_group);\n\n \n\nvoid ip_mc_unmap(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc;\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, pmc)\n\t\tigmp_group_dropped(pmc);\n}\n\nvoid ip_mc_remap(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc;\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, pmc) {\n#ifdef CONFIG_IP_MULTICAST\n\t\tigmpv3_del_delrec(in_dev, pmc);\n#endif\n\t\tigmp_group_added(pmc);\n\t}\n}\n\n \n\nvoid ip_mc_down(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc;\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, pmc)\n\t\tigmp_group_dropped(pmc);\n\n#ifdef CONFIG_IP_MULTICAST\n\tWRITE_ONCE(in_dev->mr_ifc_count, 0);\n\tif (del_timer(&in_dev->mr_ifc_timer))\n\t\t__in_dev_put(in_dev);\n\tin_dev->mr_gq_running = 0;\n\tif (del_timer(&in_dev->mr_gq_timer))\n\t\t__in_dev_put(in_dev);\n#endif\n\n\tip_mc_dec_group(in_dev, IGMP_ALL_HOSTS);\n}\n\n#ifdef CONFIG_IP_MULTICAST\nstatic void ip_mc_reset(struct in_device *in_dev)\n{\n\tstruct net *net = dev_net(in_dev->dev);\n\n\tin_dev->mr_qi = IGMP_QUERY_INTERVAL;\n\tin_dev->mr_qri = IGMP_QUERY_RESPONSE_INTERVAL;\n\tin_dev->mr_qrv = READ_ONCE(net->ipv4.sysctl_igmp_qrv);\n}\n#else\nstatic void ip_mc_reset(struct in_device *in_dev)\n{\n}\n#endif\n\nvoid ip_mc_init_dev(struct in_device *in_dev)\n{\n\tASSERT_RTNL();\n\n#ifdef CONFIG_IP_MULTICAST\n\ttimer_setup(&in_dev->mr_gq_timer, igmp_gq_timer_expire, 0);\n\ttimer_setup(&in_dev->mr_ifc_timer, igmp_ifc_timer_expire, 0);\n#endif\n\tip_mc_reset(in_dev);\n\n\tspin_lock_init(&in_dev->mc_tomb_lock);\n}\n\n \n\nvoid ip_mc_up(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc;\n\n\tASSERT_RTNL();\n\n\tip_mc_reset(in_dev);\n\tip_mc_inc_group(in_dev, IGMP_ALL_HOSTS);\n\n\tfor_each_pmc_rtnl(in_dev, pmc) {\n#ifdef CONFIG_IP_MULTICAST\n\t\tigmpv3_del_delrec(in_dev, pmc);\n#endif\n\t\tigmp_group_added(pmc);\n\t}\n}\n\n \n\nvoid ip_mc_destroy_dev(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *i;\n\n\tASSERT_RTNL();\n\n\t \n\tip_mc_down(in_dev);\n#ifdef CONFIG_IP_MULTICAST\n\tigmpv3_clear_delrec(in_dev);\n#endif\n\n\twhile ((i = rtnl_dereference(in_dev->mc_list)) != NULL) {\n\t\tin_dev->mc_list = i->next_rcu;\n\t\tin_dev->mc_count--;\n\t\tip_mc_clear_src(i);\n\t\tip_ma_put(i);\n\t}\n}\n\n \nstatic struct in_device *ip_mc_find_dev(struct net *net, struct ip_mreqn *imr)\n{\n\tstruct net_device *dev = NULL;\n\tstruct in_device *idev = NULL;\n\n\tif (imr->imr_ifindex) {\n\t\tidev = inetdev_by_index(net, imr->imr_ifindex);\n\t\treturn idev;\n\t}\n\tif (imr->imr_address.s_addr) {\n\t\tdev = __ip_dev_find(net, imr->imr_address.s_addr, false);\n\t\tif (!dev)\n\t\t\treturn NULL;\n\t}\n\n\tif (!dev) {\n\t\tstruct rtable *rt = ip_route_output(net,\n\t\t\t\t\t\t    imr->imr_multiaddr.s_addr,\n\t\t\t\t\t\t    0, 0, 0);\n\t\tif (!IS_ERR(rt)) {\n\t\t\tdev = rt->dst.dev;\n\t\t\tip_rt_put(rt);\n\t\t}\n\t}\n\tif (dev) {\n\t\timr->imr_ifindex = dev->ifindex;\n\t\tidev = __in_dev_get_rtnl(dev);\n\t}\n\treturn idev;\n}\n\n \n\nstatic int ip_mc_del1_src(struct ip_mc_list *pmc, int sfmode,\n\t__be32 *psfsrc)\n{\n\tstruct ip_sf_list *psf, *psf_prev;\n\tint rv = 0;\n\n\tpsf_prev = NULL;\n\tfor (psf = pmc->sources; psf; psf = psf->sf_next) {\n\t\tif (psf->sf_inaddr == *psfsrc)\n\t\t\tbreak;\n\t\tpsf_prev = psf;\n\t}\n\tif (!psf || psf->sf_count[sfmode] == 0) {\n\t\t \n\t\treturn -ESRCH;\n\t}\n\tpsf->sf_count[sfmode]--;\n\tif (psf->sf_count[sfmode] == 0) {\n\t\tip_rt_multicast_event(pmc->interface);\n\t}\n\tif (!psf->sf_count[MCAST_INCLUDE] && !psf->sf_count[MCAST_EXCLUDE]) {\n#ifdef CONFIG_IP_MULTICAST\n\t\tstruct in_device *in_dev = pmc->interface;\n\t\tstruct net *net = dev_net(in_dev->dev);\n#endif\n\n\t\t \n\t\tif (psf_prev)\n\t\t\tpsf_prev->sf_next = psf->sf_next;\n\t\telse\n\t\t\tpmc->sources = psf->sf_next;\n#ifdef CONFIG_IP_MULTICAST\n\t\tif (psf->sf_oldin &&\n\t\t    !IGMP_V1_SEEN(in_dev) && !IGMP_V2_SEEN(in_dev)) {\n\t\t\tpsf->sf_crcount = in_dev->mr_qrv ?: READ_ONCE(net->ipv4.sysctl_igmp_qrv);\n\t\t\tpsf->sf_next = pmc->tomb;\n\t\t\tpmc->tomb = psf;\n\t\t\trv = 1;\n\t\t} else\n#endif\n\t\t\tkfree(psf);\n\t}\n\treturn rv;\n}\n\n#ifndef CONFIG_IP_MULTICAST\n#define igmp_ifc_event(x)\tdo { } while (0)\n#endif\n\nstatic int ip_mc_del_src(struct in_device *in_dev, __be32 *pmca, int sfmode,\n\t\t\t int sfcount, __be32 *psfsrc, int delta)\n{\n\tstruct ip_mc_list *pmc;\n\tint\tchangerec = 0;\n\tint\ti, err;\n\n\tif (!in_dev)\n\t\treturn -ENODEV;\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\tif (*pmca == pmc->multiaddr)\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\n\t\t \n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tspin_lock_bh(&pmc->lock);\n\trcu_read_unlock();\n#ifdef CONFIG_IP_MULTICAST\n\tsf_markstate(pmc);\n#endif\n\tif (!delta) {\n\t\terr = -EINVAL;\n\t\tif (!pmc->sfcount[sfmode])\n\t\t\tgoto out_unlock;\n\t\tpmc->sfcount[sfmode]--;\n\t}\n\terr = 0;\n\tfor (i = 0; i < sfcount; i++) {\n\t\tint rv = ip_mc_del1_src(pmc, sfmode, &psfsrc[i]);\n\n\t\tchangerec |= rv > 0;\n\t\tif (!err && rv < 0)\n\t\t\terr = rv;\n\t}\n\tif (pmc->sfmode == MCAST_EXCLUDE &&\n\t    pmc->sfcount[MCAST_EXCLUDE] == 0 &&\n\t    pmc->sfcount[MCAST_INCLUDE]) {\n#ifdef CONFIG_IP_MULTICAST\n\t\tstruct ip_sf_list *psf;\n\t\tstruct net *net = dev_net(in_dev->dev);\n#endif\n\n\t\t \n\t\tpmc->sfmode = MCAST_INCLUDE;\n#ifdef CONFIG_IP_MULTICAST\n\t\tpmc->crcount = in_dev->mr_qrv ?: READ_ONCE(net->ipv4.sysctl_igmp_qrv);\n\t\tWRITE_ONCE(in_dev->mr_ifc_count, pmc->crcount);\n\t\tfor (psf = pmc->sources; psf; psf = psf->sf_next)\n\t\t\tpsf->sf_crcount = 0;\n\t\tigmp_ifc_event(pmc->interface);\n\t} else if (sf_setstate(pmc) || changerec) {\n\t\tigmp_ifc_event(pmc->interface);\n#endif\n\t}\nout_unlock:\n\tspin_unlock_bh(&pmc->lock);\n\treturn err;\n}\n\n \nstatic int ip_mc_add1_src(struct ip_mc_list *pmc, int sfmode,\n\t__be32 *psfsrc)\n{\n\tstruct ip_sf_list *psf, *psf_prev;\n\n\tpsf_prev = NULL;\n\tfor (psf = pmc->sources; psf; psf = psf->sf_next) {\n\t\tif (psf->sf_inaddr == *psfsrc)\n\t\t\tbreak;\n\t\tpsf_prev = psf;\n\t}\n\tif (!psf) {\n\t\tpsf = kzalloc(sizeof(*psf), GFP_ATOMIC);\n\t\tif (!psf)\n\t\t\treturn -ENOBUFS;\n\t\tpsf->sf_inaddr = *psfsrc;\n\t\tif (psf_prev) {\n\t\t\tpsf_prev->sf_next = psf;\n\t\t} else\n\t\t\tpmc->sources = psf;\n\t}\n\tpsf->sf_count[sfmode]++;\n\tif (psf->sf_count[sfmode] == 1) {\n\t\tip_rt_multicast_event(pmc->interface);\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_IP_MULTICAST\nstatic void sf_markstate(struct ip_mc_list *pmc)\n{\n\tstruct ip_sf_list *psf;\n\tint mca_xcount = pmc->sfcount[MCAST_EXCLUDE];\n\n\tfor (psf = pmc->sources; psf; psf = psf->sf_next)\n\t\tif (pmc->sfcount[MCAST_EXCLUDE]) {\n\t\t\tpsf->sf_oldin = mca_xcount ==\n\t\t\t\tpsf->sf_count[MCAST_EXCLUDE] &&\n\t\t\t\t!psf->sf_count[MCAST_INCLUDE];\n\t\t} else\n\t\t\tpsf->sf_oldin = psf->sf_count[MCAST_INCLUDE] != 0;\n}\n\nstatic int sf_setstate(struct ip_mc_list *pmc)\n{\n\tstruct ip_sf_list *psf, *dpsf;\n\tint mca_xcount = pmc->sfcount[MCAST_EXCLUDE];\n\tint qrv = pmc->interface->mr_qrv;\n\tint new_in, rv;\n\n\trv = 0;\n\tfor (psf = pmc->sources; psf; psf = psf->sf_next) {\n\t\tif (pmc->sfcount[MCAST_EXCLUDE]) {\n\t\t\tnew_in = mca_xcount == psf->sf_count[MCAST_EXCLUDE] &&\n\t\t\t\t!psf->sf_count[MCAST_INCLUDE];\n\t\t} else\n\t\t\tnew_in = psf->sf_count[MCAST_INCLUDE] != 0;\n\t\tif (new_in) {\n\t\t\tif (!psf->sf_oldin) {\n\t\t\t\tstruct ip_sf_list *prev = NULL;\n\n\t\t\t\tfor (dpsf = pmc->tomb; dpsf; dpsf = dpsf->sf_next) {\n\t\t\t\t\tif (dpsf->sf_inaddr == psf->sf_inaddr)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tprev = dpsf;\n\t\t\t\t}\n\t\t\t\tif (dpsf) {\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\tprev->sf_next = dpsf->sf_next;\n\t\t\t\t\telse\n\t\t\t\t\t\tpmc->tomb = dpsf->sf_next;\n\t\t\t\t\tkfree(dpsf);\n\t\t\t\t}\n\t\t\t\tpsf->sf_crcount = qrv;\n\t\t\t\trv++;\n\t\t\t}\n\t\t} else if (psf->sf_oldin) {\n\n\t\t\tpsf->sf_crcount = 0;\n\t\t\t \n\t\t\tfor (dpsf = pmc->tomb; dpsf; dpsf = dpsf->sf_next)\n\t\t\t\tif (dpsf->sf_inaddr == psf->sf_inaddr)\n\t\t\t\t\tbreak;\n\t\t\tif (!dpsf) {\n\t\t\t\tdpsf = kmalloc(sizeof(*dpsf), GFP_ATOMIC);\n\t\t\t\tif (!dpsf)\n\t\t\t\t\tcontinue;\n\t\t\t\t*dpsf = *psf;\n\t\t\t\t \n\t\t\t\tdpsf->sf_next = pmc->tomb;\n\t\t\t\tpmc->tomb = dpsf;\n\t\t\t}\n\t\t\tdpsf->sf_crcount = qrv;\n\t\t\trv++;\n\t\t}\n\t}\n\treturn rv;\n}\n#endif\n\n \nstatic int ip_mc_add_src(struct in_device *in_dev, __be32 *pmca, int sfmode,\n\t\t\t int sfcount, __be32 *psfsrc, int delta)\n{\n\tstruct ip_mc_list *pmc;\n\tint\tisexclude;\n\tint\ti, err;\n\n\tif (!in_dev)\n\t\treturn -ENODEV;\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\tif (*pmca == pmc->multiaddr)\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\n\t\t \n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tspin_lock_bh(&pmc->lock);\n\trcu_read_unlock();\n\n#ifdef CONFIG_IP_MULTICAST\n\tsf_markstate(pmc);\n#endif\n\tisexclude = pmc->sfmode == MCAST_EXCLUDE;\n\tif (!delta)\n\t\tpmc->sfcount[sfmode]++;\n\terr = 0;\n\tfor (i = 0; i < sfcount; i++) {\n\t\terr = ip_mc_add1_src(pmc, sfmode, &psfsrc[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif (err) {\n\t\tint j;\n\n\t\tif (!delta)\n\t\t\tpmc->sfcount[sfmode]--;\n\t\tfor (j = 0; j < i; j++)\n\t\t\t(void) ip_mc_del1_src(pmc, sfmode, &psfsrc[j]);\n\t} else if (isexclude != (pmc->sfcount[MCAST_EXCLUDE] != 0)) {\n#ifdef CONFIG_IP_MULTICAST\n\t\tstruct ip_sf_list *psf;\n\t\tstruct net *net = dev_net(pmc->interface->dev);\n\t\tin_dev = pmc->interface;\n#endif\n\n\t\t \n\t\tif (pmc->sfcount[MCAST_EXCLUDE])\n\t\t\tpmc->sfmode = MCAST_EXCLUDE;\n\t\telse if (pmc->sfcount[MCAST_INCLUDE])\n\t\t\tpmc->sfmode = MCAST_INCLUDE;\n#ifdef CONFIG_IP_MULTICAST\n\t\t \n\n\t\tpmc->crcount = in_dev->mr_qrv ?: READ_ONCE(net->ipv4.sysctl_igmp_qrv);\n\t\tWRITE_ONCE(in_dev->mr_ifc_count, pmc->crcount);\n\t\tfor (psf = pmc->sources; psf; psf = psf->sf_next)\n\t\t\tpsf->sf_crcount = 0;\n\t\tigmp_ifc_event(in_dev);\n\t} else if (sf_setstate(pmc)) {\n\t\tigmp_ifc_event(in_dev);\n#endif\n\t}\n\tspin_unlock_bh(&pmc->lock);\n\treturn err;\n}\n\nstatic void ip_mc_clear_src(struct ip_mc_list *pmc)\n{\n\tstruct ip_sf_list *tomb, *sources;\n\n\tspin_lock_bh(&pmc->lock);\n\ttomb = pmc->tomb;\n\tpmc->tomb = NULL;\n\tsources = pmc->sources;\n\tpmc->sources = NULL;\n\tpmc->sfmode = MCAST_EXCLUDE;\n\tpmc->sfcount[MCAST_INCLUDE] = 0;\n\tpmc->sfcount[MCAST_EXCLUDE] = 1;\n\tspin_unlock_bh(&pmc->lock);\n\n\tip_sf_list_clear_all(tomb);\n\tip_sf_list_clear_all(sources);\n}\n\n \nstatic int __ip_mc_join_group(struct sock *sk, struct ip_mreqn *imr,\n\t\t\t      unsigned int mode)\n{\n\t__be32 addr = imr->imr_multiaddr.s_addr;\n\tstruct ip_mc_socklist *iml, *i;\n\tstruct in_device *in_dev;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint ifindex;\n\tint count = 0;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\tin_dev = ip_mc_find_dev(net, imr);\n\n\tif (!in_dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\n\terr = -EADDRINUSE;\n\tifindex = imr->imr_ifindex;\n\tfor_each_pmc_rtnl(inet, i) {\n\t\tif (i->multi.imr_multiaddr.s_addr == addr &&\n\t\t    i->multi.imr_ifindex == ifindex)\n\t\t\tgoto done;\n\t\tcount++;\n\t}\n\terr = -ENOBUFS;\n\tif (count >= READ_ONCE(net->ipv4.sysctl_igmp_max_memberships))\n\t\tgoto done;\n\timl = sock_kmalloc(sk, sizeof(*iml), GFP_KERNEL);\n\tif (!iml)\n\t\tgoto done;\n\n\tmemcpy(&iml->multi, imr, sizeof(*imr));\n\timl->next_rcu = inet->mc_list;\n\timl->sflist = NULL;\n\timl->sfmode = mode;\n\trcu_assign_pointer(inet->mc_list, iml);\n\t____ip_mc_inc_group(in_dev, addr, mode, GFP_KERNEL);\n\terr = 0;\ndone:\n\treturn err;\n}\n\n \nint ip_mc_join_group(struct sock *sk, struct ip_mreqn *imr)\n{\n\treturn __ip_mc_join_group(sk, imr, MCAST_EXCLUDE);\n}\nEXPORT_SYMBOL(ip_mc_join_group);\n\n \nint ip_mc_join_group_ssm(struct sock *sk, struct ip_mreqn *imr,\n\t\t\t unsigned int mode)\n{\n\treturn __ip_mc_join_group(sk, imr, mode);\n}\n\nstatic int ip_mc_leave_src(struct sock *sk, struct ip_mc_socklist *iml,\n\t\t\t   struct in_device *in_dev)\n{\n\tstruct ip_sf_socklist *psf = rtnl_dereference(iml->sflist);\n\tint err;\n\n\tif (!psf) {\n\t\t \n\t\treturn ip_mc_del_src(in_dev, &iml->multi.imr_multiaddr.s_addr,\n\t\t\timl->sfmode, 0, NULL, 0);\n\t}\n\terr = ip_mc_del_src(in_dev, &iml->multi.imr_multiaddr.s_addr,\n\t\t\timl->sfmode, psf->sl_count, psf->sl_addr, 0);\n\tRCU_INIT_POINTER(iml->sflist, NULL);\n\t \n\tatomic_sub(struct_size(psf, sl_addr, psf->sl_max), &sk->sk_omem_alloc);\n\tkfree_rcu(psf, rcu);\n\treturn err;\n}\n\nint ip_mc_leave_group(struct sock *sk, struct ip_mreqn *imr)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_mc_socklist *iml;\n\tstruct ip_mc_socklist __rcu **imlp;\n\tstruct in_device *in_dev;\n\tstruct net *net = sock_net(sk);\n\t__be32 group = imr->imr_multiaddr.s_addr;\n\tu32 ifindex;\n\tint ret = -EADDRNOTAVAIL;\n\n\tASSERT_RTNL();\n\n\tin_dev = ip_mc_find_dev(net, imr);\n\tif (!imr->imr_ifindex && !imr->imr_address.s_addr && !in_dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tifindex = imr->imr_ifindex;\n\tfor (imlp = &inet->mc_list;\n\t     (iml = rtnl_dereference(*imlp)) != NULL;\n\t     imlp = &iml->next_rcu) {\n\t\tif (iml->multi.imr_multiaddr.s_addr != group)\n\t\t\tcontinue;\n\t\tif (ifindex) {\n\t\t\tif (iml->multi.imr_ifindex != ifindex)\n\t\t\t\tcontinue;\n\t\t} else if (imr->imr_address.s_addr && imr->imr_address.s_addr !=\n\t\t\t\timl->multi.imr_address.s_addr)\n\t\t\tcontinue;\n\n\t\t(void) ip_mc_leave_src(sk, iml, in_dev);\n\n\t\t*imlp = iml->next_rcu;\n\n\t\tif (in_dev)\n\t\t\tip_mc_dec_group(in_dev, group);\n\n\t\t \n\t\tatomic_sub(sizeof(*iml), &sk->sk_omem_alloc);\n\t\tkfree_rcu(iml, rcu);\n\t\treturn 0;\n\t}\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(ip_mc_leave_group);\n\nint ip_mc_source(int add, int omode, struct sock *sk, struct\n\tip_mreq_source *mreqs, int ifindex)\n{\n\tint err;\n\tstruct ip_mreqn imr;\n\t__be32 addr = mreqs->imr_multiaddr;\n\tstruct ip_mc_socklist *pmc;\n\tstruct in_device *in_dev = NULL;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_sf_socklist *psl;\n\tstruct net *net = sock_net(sk);\n\tint leavegroup = 0;\n\tint i, j, rv;\n\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\tASSERT_RTNL();\n\n\timr.imr_multiaddr.s_addr = mreqs->imr_multiaddr;\n\timr.imr_address.s_addr = mreqs->imr_interface;\n\timr.imr_ifindex = ifindex;\n\tin_dev = ip_mc_find_dev(net, &imr);\n\n\tif (!in_dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\terr = -EADDRNOTAVAIL;\n\n\tfor_each_pmc_rtnl(inet, pmc) {\n\t\tif ((pmc->multi.imr_multiaddr.s_addr ==\n\t\t     imr.imr_multiaddr.s_addr) &&\n\t\t    (pmc->multi.imr_ifindex == imr.imr_ifindex))\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\t\t \n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\t \n\tif (pmc->sflist) {\n\t\tif (pmc->sfmode != omode) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t} else if (pmc->sfmode != omode) {\n\t\t \n\t\tip_mc_add_src(in_dev, &mreqs->imr_multiaddr, omode, 0, NULL, 0);\n\t\tip_mc_del_src(in_dev, &mreqs->imr_multiaddr, pmc->sfmode, 0,\n\t\t\tNULL, 0);\n\t\tpmc->sfmode = omode;\n\t}\n\n\tpsl = rtnl_dereference(pmc->sflist);\n\tif (!add) {\n\t\tif (!psl)\n\t\t\tgoto done;\t \n\t\trv = !0;\n\t\tfor (i = 0; i < psl->sl_count; i++) {\n\t\t\trv = memcmp(&psl->sl_addr[i], &mreqs->imr_sourceaddr,\n\t\t\t\tsizeof(__be32));\n\t\t\tif (rv == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (rv)\t\t \n\t\t\tgoto done;\t \n\n\t\t \n\t\tif (psl->sl_count == 1 && omode == MCAST_INCLUDE) {\n\t\t\tleavegroup = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tip_mc_del_src(in_dev, &mreqs->imr_multiaddr, omode, 1,\n\t\t\t&mreqs->imr_sourceaddr, 1);\n\n\t\tfor (j = i+1; j < psl->sl_count; j++)\n\t\t\tpsl->sl_addr[j-1] = psl->sl_addr[j];\n\t\tpsl->sl_count--;\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\t \n\n\tif (psl && psl->sl_count >= READ_ONCE(net->ipv4.sysctl_igmp_max_msf)) {\n\t\terr = -ENOBUFS;\n\t\tgoto done;\n\t}\n\tif (!psl || psl->sl_count == psl->sl_max) {\n\t\tstruct ip_sf_socklist *newpsl;\n\t\tint count = IP_SFBLOCK;\n\n\t\tif (psl)\n\t\t\tcount += psl->sl_max;\n\t\tnewpsl = sock_kmalloc(sk, struct_size(newpsl, sl_addr, count),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!newpsl) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto done;\n\t\t}\n\t\tnewpsl->sl_max = count;\n\t\tnewpsl->sl_count = count - IP_SFBLOCK;\n\t\tif (psl) {\n\t\t\tfor (i = 0; i < psl->sl_count; i++)\n\t\t\t\tnewpsl->sl_addr[i] = psl->sl_addr[i];\n\t\t\t \n\t\t\tatomic_sub(struct_size(psl, sl_addr, psl->sl_max),\n\t\t\t\t   &sk->sk_omem_alloc);\n\t\t}\n\t\trcu_assign_pointer(pmc->sflist, newpsl);\n\t\tif (psl)\n\t\t\tkfree_rcu(psl, rcu);\n\t\tpsl = newpsl;\n\t}\n\trv = 1;\t \n\tfor (i = 0; i < psl->sl_count; i++) {\n\t\trv = memcmp(&psl->sl_addr[i], &mreqs->imr_sourceaddr,\n\t\t\tsizeof(__be32));\n\t\tif (rv == 0)\n\t\t\tbreak;\n\t}\n\tif (rv == 0)\t\t \n\t\tgoto done;\n\tfor (j = psl->sl_count-1; j >= i; j--)\n\t\tpsl->sl_addr[j+1] = psl->sl_addr[j];\n\tpsl->sl_addr[i] = mreqs->imr_sourceaddr;\n\tpsl->sl_count++;\n\terr = 0;\n\t \n\tip_mc_add_src(in_dev, &mreqs->imr_multiaddr, omode, 1,\n\t\t&mreqs->imr_sourceaddr, 1);\ndone:\n\tif (leavegroup)\n\t\terr = ip_mc_leave_group(sk, &imr);\n\treturn err;\n}\n\nint ip_mc_msfilter(struct sock *sk, struct ip_msfilter *msf, int ifindex)\n{\n\tint err = 0;\n\tstruct ip_mreqn\timr;\n\t__be32 addr = msf->imsf_multiaddr;\n\tstruct ip_mc_socklist *pmc;\n\tstruct in_device *in_dev;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_sf_socklist *newpsl, *psl;\n\tstruct net *net = sock_net(sk);\n\tint leavegroup = 0;\n\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\tif (msf->imsf_fmode != MCAST_INCLUDE &&\n\t    msf->imsf_fmode != MCAST_EXCLUDE)\n\t\treturn -EINVAL;\n\n\tASSERT_RTNL();\n\n\timr.imr_multiaddr.s_addr = msf->imsf_multiaddr;\n\timr.imr_address.s_addr = msf->imsf_interface;\n\timr.imr_ifindex = ifindex;\n\tin_dev = ip_mc_find_dev(net, &imr);\n\n\tif (!in_dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\n\t \n\tif (msf->imsf_fmode == MCAST_INCLUDE && msf->imsf_numsrc == 0) {\n\t\tleavegroup = 1;\n\t\tgoto done;\n\t}\n\n\tfor_each_pmc_rtnl(inet, pmc) {\n\t\tif (pmc->multi.imr_multiaddr.s_addr == msf->imsf_multiaddr &&\n\t\t    pmc->multi.imr_ifindex == imr.imr_ifindex)\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\t\t \n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tif (msf->imsf_numsrc) {\n\t\tnewpsl = sock_kmalloc(sk, struct_size(newpsl, sl_addr,\n\t\t\t\t\t\t      msf->imsf_numsrc),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!newpsl) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto done;\n\t\t}\n\t\tnewpsl->sl_max = newpsl->sl_count = msf->imsf_numsrc;\n\t\tmemcpy(newpsl->sl_addr, msf->imsf_slist_flex,\n\t\t       flex_array_size(msf, imsf_slist_flex, msf->imsf_numsrc));\n\t\terr = ip_mc_add_src(in_dev, &msf->imsf_multiaddr,\n\t\t\tmsf->imsf_fmode, newpsl->sl_count, newpsl->sl_addr, 0);\n\t\tif (err) {\n\t\t\tsock_kfree_s(sk, newpsl,\n\t\t\t\t     struct_size(newpsl, sl_addr,\n\t\t\t\t\t\t newpsl->sl_max));\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tnewpsl = NULL;\n\t\t(void) ip_mc_add_src(in_dev, &msf->imsf_multiaddr,\n\t\t\t\t     msf->imsf_fmode, 0, NULL, 0);\n\t}\n\tpsl = rtnl_dereference(pmc->sflist);\n\tif (psl) {\n\t\t(void) ip_mc_del_src(in_dev, &msf->imsf_multiaddr, pmc->sfmode,\n\t\t\tpsl->sl_count, psl->sl_addr, 0);\n\t\t \n\t\tatomic_sub(struct_size(psl, sl_addr, psl->sl_max),\n\t\t\t   &sk->sk_omem_alloc);\n\t} else {\n\t\t(void) ip_mc_del_src(in_dev, &msf->imsf_multiaddr, pmc->sfmode,\n\t\t\t0, NULL, 0);\n\t}\n\trcu_assign_pointer(pmc->sflist, newpsl);\n\tif (psl)\n\t\tkfree_rcu(psl, rcu);\n\tpmc->sfmode = msf->imsf_fmode;\n\terr = 0;\ndone:\n\tif (leavegroup)\n\t\terr = ip_mc_leave_group(sk, &imr);\n\treturn err;\n}\nint ip_mc_msfget(struct sock *sk, struct ip_msfilter *msf,\n\t\t sockptr_t optval, sockptr_t optlen)\n{\n\tint err, len, count, copycount, msf_size;\n\tstruct ip_mreqn\timr;\n\t__be32 addr = msf->imsf_multiaddr;\n\tstruct ip_mc_socklist *pmc;\n\tstruct in_device *in_dev;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_sf_socklist *psl;\n\tstruct net *net = sock_net(sk);\n\n\tASSERT_RTNL();\n\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\timr.imr_multiaddr.s_addr = msf->imsf_multiaddr;\n\timr.imr_address.s_addr = msf->imsf_interface;\n\timr.imr_ifindex = 0;\n\tin_dev = ip_mc_find_dev(net, &imr);\n\n\tif (!in_dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\terr = -EADDRNOTAVAIL;\n\n\tfor_each_pmc_rtnl(inet, pmc) {\n\t\tif (pmc->multi.imr_multiaddr.s_addr == msf->imsf_multiaddr &&\n\t\t    pmc->multi.imr_ifindex == imr.imr_ifindex)\n\t\t\tbreak;\n\t}\n\tif (!pmc)\t\t \n\t\tgoto done;\n\tmsf->imsf_fmode = pmc->sfmode;\n\tpsl = rtnl_dereference(pmc->sflist);\n\tif (!psl) {\n\t\tcount = 0;\n\t} else {\n\t\tcount = psl->sl_count;\n\t}\n\tcopycount = count < msf->imsf_numsrc ? count : msf->imsf_numsrc;\n\tlen = flex_array_size(psl, sl_addr, copycount);\n\tmsf->imsf_numsrc = count;\n\tmsf_size = IP_MSFILTER_SIZE(copycount);\n\tif (copy_to_sockptr(optlen, &msf_size, sizeof(int)) ||\n\t    copy_to_sockptr(optval, msf, IP_MSFILTER_SIZE(0))) {\n\t\treturn -EFAULT;\n\t}\n\tif (len &&\n\t    copy_to_sockptr_offset(optval,\n\t\t\t\t   offsetof(struct ip_msfilter, imsf_slist_flex),\n\t\t\t\t   psl->sl_addr, len))\n\t\treturn -EFAULT;\n\treturn 0;\ndone:\n\treturn err;\n}\n\nint ip_mc_gsfget(struct sock *sk, struct group_filter *gsf,\n\t\t sockptr_t optval, size_t ss_offset)\n{\n\tint i, count, copycount;\n\tstruct sockaddr_in *psin;\n\t__be32 addr;\n\tstruct ip_mc_socklist *pmc;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_sf_socklist *psl;\n\n\tASSERT_RTNL();\n\n\tpsin = (struct sockaddr_in *)&gsf->gf_group;\n\tif (psin->sin_family != AF_INET)\n\t\treturn -EINVAL;\n\taddr = psin->sin_addr.s_addr;\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\tfor_each_pmc_rtnl(inet, pmc) {\n\t\tif (pmc->multi.imr_multiaddr.s_addr == addr &&\n\t\t    pmc->multi.imr_ifindex == gsf->gf_interface)\n\t\t\tbreak;\n\t}\n\tif (!pmc)\t\t \n\t\treturn -EADDRNOTAVAIL;\n\tgsf->gf_fmode = pmc->sfmode;\n\tpsl = rtnl_dereference(pmc->sflist);\n\tcount = psl ? psl->sl_count : 0;\n\tcopycount = count < gsf->gf_numsrc ? count : gsf->gf_numsrc;\n\tgsf->gf_numsrc = count;\n\tfor (i = 0; i < copycount; i++) {\n\t\tstruct sockaddr_storage ss;\n\n\t\tpsin = (struct sockaddr_in *)&ss;\n\t\tmemset(&ss, 0, sizeof(ss));\n\t\tpsin->sin_family = AF_INET;\n\t\tpsin->sin_addr.s_addr = psl->sl_addr[i];\n\t\tif (copy_to_sockptr_offset(optval, ss_offset,\n\t\t\t\t\t   &ss, sizeof(ss)))\n\t\t\treturn -EFAULT;\n\t\tss_offset += sizeof(ss);\n\t}\n\treturn 0;\n}\n\n \nint ip_mc_sf_allow(const struct sock *sk, __be32 loc_addr, __be32 rmt_addr,\n\t\t   int dif, int sdif)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tstruct ip_mc_socklist *pmc;\n\tstruct ip_sf_socklist *psl;\n\tint i;\n\tint ret;\n\n\tret = 1;\n\tif (!ipv4_is_multicast(loc_addr))\n\t\tgoto out;\n\n\trcu_read_lock();\n\tfor_each_pmc_rcu(inet, pmc) {\n\t\tif (pmc->multi.imr_multiaddr.s_addr == loc_addr &&\n\t\t    (pmc->multi.imr_ifindex == dif ||\n\t\t     (sdif && pmc->multi.imr_ifindex == sdif)))\n\t\t\tbreak;\n\t}\n\tret = inet_test_bit(MC_ALL, sk);\n\tif (!pmc)\n\t\tgoto unlock;\n\tpsl = rcu_dereference(pmc->sflist);\n\tret = (pmc->sfmode == MCAST_EXCLUDE);\n\tif (!psl)\n\t\tgoto unlock;\n\n\tfor (i = 0; i < psl->sl_count; i++) {\n\t\tif (psl->sl_addr[i] == rmt_addr)\n\t\t\tbreak;\n\t}\n\tret = 0;\n\tif (pmc->sfmode == MCAST_INCLUDE && i >= psl->sl_count)\n\t\tgoto unlock;\n\tif (pmc->sfmode == MCAST_EXCLUDE && i < psl->sl_count)\n\t\tgoto unlock;\n\tret = 1;\nunlock:\n\trcu_read_unlock();\nout:\n\treturn ret;\n}\n\n \n\nvoid ip_mc_drop_socket(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_mc_socklist *iml;\n\tstruct net *net = sock_net(sk);\n\n\tif (!inet->mc_list)\n\t\treturn;\n\n\trtnl_lock();\n\twhile ((iml = rtnl_dereference(inet->mc_list)) != NULL) {\n\t\tstruct in_device *in_dev;\n\n\t\tinet->mc_list = iml->next_rcu;\n\t\tin_dev = inetdev_by_index(net, iml->multi.imr_ifindex);\n\t\t(void) ip_mc_leave_src(sk, iml, in_dev);\n\t\tif (in_dev)\n\t\t\tip_mc_dec_group(in_dev, iml->multi.imr_multiaddr.s_addr);\n\t\t \n\t\tatomic_sub(sizeof(*iml), &sk->sk_omem_alloc);\n\t\tkfree_rcu(iml, rcu);\n\t}\n\trtnl_unlock();\n}\n\n \nint ip_check_mc_rcu(struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u8 proto)\n{\n\tstruct ip_mc_list *im;\n\tstruct ip_mc_list __rcu **mc_hash;\n\tstruct ip_sf_list *psf;\n\tint rv = 0;\n\n\tmc_hash = rcu_dereference(in_dev->mc_hash);\n\tif (mc_hash) {\n\t\tu32 hash = hash_32((__force u32)mc_addr, MC_HASH_SZ_LOG);\n\n\t\tfor (im = rcu_dereference(mc_hash[hash]);\n\t\t     im != NULL;\n\t\t     im = rcu_dereference(im->next_hash)) {\n\t\t\tif (im->multiaddr == mc_addr)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tfor_each_pmc_rcu(in_dev, im) {\n\t\t\tif (im->multiaddr == mc_addr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (im && proto == IPPROTO_IGMP) {\n\t\trv = 1;\n\t} else if (im) {\n\t\tif (src_addr) {\n\t\t\tspin_lock_bh(&im->lock);\n\t\t\tfor (psf = im->sources; psf; psf = psf->sf_next) {\n\t\t\t\tif (psf->sf_inaddr == src_addr)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (psf)\n\t\t\t\trv = psf->sf_count[MCAST_INCLUDE] ||\n\t\t\t\t\tpsf->sf_count[MCAST_EXCLUDE] !=\n\t\t\t\t\tim->sfcount[MCAST_EXCLUDE];\n\t\t\telse\n\t\t\t\trv = im->sfcount[MCAST_EXCLUDE] != 0;\n\t\t\tspin_unlock_bh(&im->lock);\n\t\t} else\n\t\t\trv = 1;  \n\t}\n\treturn rv;\n}\n\n#if defined(CONFIG_PROC_FS)\nstruct igmp_mc_iter_state {\n\tstruct seq_net_private p;\n\tstruct net_device *dev;\n\tstruct in_device *in_dev;\n};\n\n#define\tigmp_mc_seq_private(seq)\t((struct igmp_mc_iter_state *)(seq)->private)\n\nstatic inline struct ip_mc_list *igmp_mc_get_first(struct seq_file *seq)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct ip_mc_list *im = NULL;\n\tstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\n\n\tstate->in_dev = NULL;\n\tfor_each_netdev_rcu(net, state->dev) {\n\t\tstruct in_device *in_dev;\n\n\t\tin_dev = __in_dev_get_rcu(state->dev);\n\t\tif (!in_dev)\n\t\t\tcontinue;\n\t\tim = rcu_dereference(in_dev->mc_list);\n\t\tif (im) {\n\t\t\tstate->in_dev = in_dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn im;\n}\n\nstatic struct ip_mc_list *igmp_mc_get_next(struct seq_file *seq, struct ip_mc_list *im)\n{\n\tstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\n\n\tim = rcu_dereference(im->next_rcu);\n\twhile (!im) {\n\t\tstate->dev = next_net_device_rcu(state->dev);\n\t\tif (!state->dev) {\n\t\t\tstate->in_dev = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tstate->in_dev = __in_dev_get_rcu(state->dev);\n\t\tif (!state->in_dev)\n\t\t\tcontinue;\n\t\tim = rcu_dereference(state->in_dev->mc_list);\n\t}\n\treturn im;\n}\n\nstatic struct ip_mc_list *igmp_mc_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct ip_mc_list *im = igmp_mc_get_first(seq);\n\tif (im)\n\t\twhile (pos && (im = igmp_mc_get_next(seq, im)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : im;\n}\n\nstatic void *igmp_mc_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn *pos ? igmp_mc_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *igmp_mc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ip_mc_list *im;\n\tif (v == SEQ_START_TOKEN)\n\t\tim = igmp_mc_get_first(seq);\n\telse\n\t\tim = igmp_mc_get_next(seq, v);\n\t++*pos;\n\treturn im;\n}\n\nstatic void igmp_mc_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rcu)\n{\n\tstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\n\n\tstate->in_dev = NULL;\n\tstate->dev = NULL;\n\trcu_read_unlock();\n}\n\nstatic int igmp_mc_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"Idx\\tDevice    : Count Querier\\tGroup    Users Timer\\tReporter\\n\");\n\telse {\n\t\tstruct ip_mc_list *im = v;\n\t\tstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\n\t\tchar   *querier;\n\t\tlong delta;\n\n#ifdef CONFIG_IP_MULTICAST\n\t\tquerier = IGMP_V1_SEEN(state->in_dev) ? \"V1\" :\n\t\t\t  IGMP_V2_SEEN(state->in_dev) ? \"V2\" :\n\t\t\t  \"V3\";\n#else\n\t\tquerier = \"NONE\";\n#endif\n\n\t\tif (rcu_access_pointer(state->in_dev->mc_list) == im) {\n\t\t\tseq_printf(seq, \"%d\\t%-10s: %5d %7s\\n\",\n\t\t\t\t   state->dev->ifindex, state->dev->name, state->in_dev->mc_count, querier);\n\t\t}\n\n\t\tdelta = im->timer.expires - jiffies;\n\t\tseq_printf(seq,\n\t\t\t   \"\\t\\t\\t\\t%08X %5d %d:%08lX\\t\\t%d\\n\",\n\t\t\t   im->multiaddr, im->users,\n\t\t\t   im->tm_running,\n\t\t\t   im->tm_running ? jiffies_delta_to_clock_t(delta) : 0,\n\t\t\t   im->reporter);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations igmp_mc_seq_ops = {\n\t.start\t=\tigmp_mc_seq_start,\n\t.next\t=\tigmp_mc_seq_next,\n\t.stop\t=\tigmp_mc_seq_stop,\n\t.show\t=\tigmp_mc_seq_show,\n};\n\nstruct igmp_mcf_iter_state {\n\tstruct seq_net_private p;\n\tstruct net_device *dev;\n\tstruct in_device *idev;\n\tstruct ip_mc_list *im;\n};\n\n#define igmp_mcf_seq_private(seq)\t((struct igmp_mcf_iter_state *)(seq)->private)\n\nstatic inline struct ip_sf_list *igmp_mcf_get_first(struct seq_file *seq)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct ip_sf_list *psf = NULL;\n\tstruct ip_mc_list *im = NULL;\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\n\tstate->idev = NULL;\n\tstate->im = NULL;\n\tfor_each_netdev_rcu(net, state->dev) {\n\t\tstruct in_device *idev;\n\t\tidev = __in_dev_get_rcu(state->dev);\n\t\tif (unlikely(!idev))\n\t\t\tcontinue;\n\t\tim = rcu_dereference(idev->mc_list);\n\t\tif (likely(im)) {\n\t\t\tspin_lock_bh(&im->lock);\n\t\t\tpsf = im->sources;\n\t\t\tif (likely(psf)) {\n\t\t\t\tstate->im = im;\n\t\t\t\tstate->idev = idev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_bh(&im->lock);\n\t\t}\n\t}\n\treturn psf;\n}\n\nstatic struct ip_sf_list *igmp_mcf_get_next(struct seq_file *seq, struct ip_sf_list *psf)\n{\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\n\tpsf = psf->sf_next;\n\twhile (!psf) {\n\t\tspin_unlock_bh(&state->im->lock);\n\t\tstate->im = state->im->next;\n\t\twhile (!state->im) {\n\t\t\tstate->dev = next_net_device_rcu(state->dev);\n\t\t\tif (!state->dev) {\n\t\t\t\tstate->idev = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstate->idev = __in_dev_get_rcu(state->dev);\n\t\t\tif (!state->idev)\n\t\t\t\tcontinue;\n\t\t\tstate->im = rcu_dereference(state->idev->mc_list);\n\t\t}\n\t\tif (!state->im)\n\t\t\tbreak;\n\t\tspin_lock_bh(&state->im->lock);\n\t\tpsf = state->im->sources;\n\t}\nout:\n\treturn psf;\n}\n\nstatic struct ip_sf_list *igmp_mcf_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct ip_sf_list *psf = igmp_mcf_get_first(seq);\n\tif (psf)\n\t\twhile (pos && (psf = igmp_mcf_get_next(seq, psf)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : psf;\n}\n\nstatic void *igmp_mcf_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn *pos ? igmp_mcf_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *igmp_mcf_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ip_sf_list *psf;\n\tif (v == SEQ_START_TOKEN)\n\t\tpsf = igmp_mcf_get_first(seq);\n\telse\n\t\tpsf = igmp_mcf_get_next(seq, v);\n\t++*pos;\n\treturn psf;\n}\n\nstatic void igmp_mcf_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rcu)\n{\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\tif (likely(state->im)) {\n\t\tspin_unlock_bh(&state->im->lock);\n\t\tstate->im = NULL;\n\t}\n\tstate->idev = NULL;\n\tstate->dev = NULL;\n\trcu_read_unlock();\n}\n\nstatic int igmp_mcf_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct ip_sf_list *psf = v;\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Idx Device        MCA        SRC    INC    EXC\\n\");\n\t} else {\n\t\tseq_printf(seq,\n\t\t\t   \"%3d %6.6s 0x%08x \"\n\t\t\t   \"0x%08x %6lu %6lu\\n\",\n\t\t\t   state->dev->ifindex, state->dev->name,\n\t\t\t   ntohl(state->im->multiaddr),\n\t\t\t   ntohl(psf->sf_inaddr),\n\t\t\t   psf->sf_count[MCAST_INCLUDE],\n\t\t\t   psf->sf_count[MCAST_EXCLUDE]);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations igmp_mcf_seq_ops = {\n\t.start\t=\tigmp_mcf_seq_start,\n\t.next\t=\tigmp_mcf_seq_next,\n\t.stop\t=\tigmp_mcf_seq_stop,\n\t.show\t=\tigmp_mcf_seq_show,\n};\n\nstatic int __net_init igmp_net_init(struct net *net)\n{\n\tstruct proc_dir_entry *pde;\n\tint err;\n\n\tpde = proc_create_net(\"igmp\", 0444, net->proc_net, &igmp_mc_seq_ops,\n\t\t\tsizeof(struct igmp_mc_iter_state));\n\tif (!pde)\n\t\tgoto out_igmp;\n\tpde = proc_create_net(\"mcfilter\", 0444, net->proc_net,\n\t\t\t&igmp_mcf_seq_ops, sizeof(struct igmp_mcf_iter_state));\n\tif (!pde)\n\t\tgoto out_mcfilter;\n\terr = inet_ctl_sock_create(&net->ipv4.mc_autojoin_sk, AF_INET,\n\t\t\t\t   SOCK_DGRAM, 0, net);\n\tif (err < 0) {\n\t\tpr_err(\"Failed to initialize the IGMP autojoin socket (err %d)\\n\",\n\t\t       err);\n\t\tgoto out_sock;\n\t}\n\n\treturn 0;\n\nout_sock:\n\tremove_proc_entry(\"mcfilter\", net->proc_net);\nout_mcfilter:\n\tremove_proc_entry(\"igmp\", net->proc_net);\nout_igmp:\n\treturn -ENOMEM;\n}\n\nstatic void __net_exit igmp_net_exit(struct net *net)\n{\n\tremove_proc_entry(\"mcfilter\", net->proc_net);\n\tremove_proc_entry(\"igmp\", net->proc_net);\n\tinet_ctl_sock_destroy(net->ipv4.mc_autojoin_sk);\n}\n\nstatic struct pernet_operations igmp_net_ops = {\n\t.init = igmp_net_init,\n\t.exit = igmp_net_exit,\n};\n#endif\n\nstatic int igmp_netdev_event(struct notifier_block *this,\n\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct in_device *in_dev;\n\n\tswitch (event) {\n\tcase NETDEV_RESEND_IGMP:\n\t\tin_dev = __in_dev_get_rtnl(dev);\n\t\tif (in_dev)\n\t\t\tip_mc_rejoin_groups(in_dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block igmp_notifier = {\n\t.notifier_call = igmp_netdev_event,\n};\n\nint __init igmp_mc_init(void)\n{\n#if defined(CONFIG_PROC_FS)\n\tint err;\n\n\terr = register_pernet_subsys(&igmp_net_ops);\n\tif (err)\n\t\treturn err;\n\terr = register_netdevice_notifier(&igmp_notifier);\n\tif (err)\n\t\tgoto reg_notif_fail;\n\treturn 0;\n\nreg_notif_fail:\n\tunregister_pernet_subsys(&igmp_net_ops);\n\treturn err;\n#else\n\treturn register_netdevice_notifier(&igmp_notifier);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}