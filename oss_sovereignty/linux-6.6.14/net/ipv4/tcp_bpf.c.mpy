{
  "module_name": "tcp_bpf.c",
  "hash_id": "46eefdef112698791046319e99f15ce5fc571db33b7f0b1c1ae52c1ad87211b7",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_bpf.c",
  "human_readable_source": "\n \n\tif (unlikely(!skb_queue_empty(&sk->sk_receive_queue))) {\n\t\ttcp_data_ready(sk);\n\t\t \n\t\tif (unlikely(!skb_queue_empty(&sk->sk_receive_queue))) {\n\t\t\tcopied = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nmsg_bytes_ready:\n\tcopied = sk_msg_recvmsg(sk, psock, msg, len, flags);\n\t \n\tif (copied == -EFAULT) {\n\t\tbool is_fin = is_next_msg_fin(psock);\n\n\t\tif (is_fin) {\n\t\t\tcopied = 0;\n\t\t\tseq++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tseq += copied;\n\tif (!copied) {\n\t\tlong timeo;\n\t\tint data;\n\n\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\tgoto out;\n\n\t\tif (sk->sk_err) {\n\t\t\tcopied = sock_error(sk);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tgoto out;\n\n\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\tcopied = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\t\tif (!timeo) {\n\t\t\tcopied = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tcopied = sock_intr_errno(timeo);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata = tcp_msg_wait_data(sk, psock, timeo);\n\t\tif (data < 0) {\n\t\t\tcopied = data;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (data && !sk_psock_queue_empty(psock))\n\t\t\tgoto msg_bytes_ready;\n\t\tcopied = -EAGAIN;\n\t}\nout:\n\tif (!peek)\n\t\tWRITE_ONCE(tcp->copied_seq, seq);\n\ttcp_rcv_space_adjust(sk);\n\tif (copied > 0)\n\t\t__tcp_cleanup_rbuf(sk, copied);\n\nunlock:\n\trelease_sock(sk);\n\tsk_psock_put(sk, psock);\n\treturn copied;\n}\n\nstatic int tcp_bpf_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t   int flags, int *addr_len)\n{\n\tstruct sk_psock *psock;\n\tint copied, ret;\n\n\tif (unlikely(flags & MSG_ERRQUEUE))\n\t\treturn inet_recv_error(sk, msg, len, addr_len);\n\n\tif (!len)\n\t\treturn 0;\n\n\tpsock = sk_psock_get(sk);\n\tif (unlikely(!psock))\n\t\treturn tcp_recvmsg(sk, msg, len, flags, addr_len);\n\tif (!skb_queue_empty(&sk->sk_receive_queue) &&\n\t    sk_psock_queue_empty(psock)) {\n\t\tsk_psock_put(sk, psock);\n\t\treturn tcp_recvmsg(sk, msg, len, flags, addr_len);\n\t}\n\tlock_sock(sk);\nmsg_bytes_ready:\n\tcopied = sk_msg_recvmsg(sk, psock, msg, len, flags);\n\tif (!copied) {\n\t\tlong timeo;\n\t\tint data;\n\n\t\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\t\tdata = tcp_msg_wait_data(sk, psock, timeo);\n\t\tif (data < 0) {\n\t\t\tret = data;\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (data) {\n\t\t\tif (!sk_psock_queue_empty(psock))\n\t\t\t\tgoto msg_bytes_ready;\n\t\t\trelease_sock(sk);\n\t\t\tsk_psock_put(sk, psock);\n\t\t\treturn tcp_recvmsg(sk, msg, len, flags, addr_len);\n\t\t}\n\t\tcopied = -EAGAIN;\n\t}\n\tret = copied;\n\nunlock:\n\trelease_sock(sk);\n\tsk_psock_put(sk, psock);\n\treturn ret;\n}\n\nstatic int tcp_bpf_send_verdict(struct sock *sk, struct sk_psock *psock,\n\t\t\t\tstruct sk_msg *msg, int *copied, int flags)\n{\n\tbool cork = false, enospc = sk_msg_full(msg), redir_ingress;\n\tstruct sock *sk_redir;\n\tu32 tosend, origsize, sent, delta = 0;\n\tu32 eval;\n\tint ret;\n\nmore_data:\n\tif (psock->eval == __SK_NONE) {\n\t\t \n\t\tdelta = msg->sg.size;\n\t\tpsock->eval = sk_psock_msg_verdict(sk, psock, msg);\n\t\tdelta -= msg->sg.size;\n\t}\n\n\tif (msg->cork_bytes &&\n\t    msg->cork_bytes > msg->sg.size && !enospc) {\n\t\tpsock->cork_bytes = msg->cork_bytes - msg->sg.size;\n\t\tif (!psock->cork) {\n\t\t\tpsock->cork = kzalloc(sizeof(*psock->cork),\n\t\t\t\t\t      GFP_ATOMIC | __GFP_NOWARN);\n\t\t\tif (!psock->cork)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(psock->cork, msg, sizeof(*msg));\n\t\treturn 0;\n\t}\n\n\ttosend = msg->sg.size;\n\tif (psock->apply_bytes && psock->apply_bytes < tosend)\n\t\ttosend = psock->apply_bytes;\n\teval = __SK_NONE;\n\n\tswitch (psock->eval) {\n\tcase __SK_PASS:\n\t\tret = tcp_bpf_push(sk, msg, tosend, flags, true);\n\t\tif (unlikely(ret)) {\n\t\t\t*copied -= sk_msg_free(sk, msg);\n\t\t\tbreak;\n\t\t}\n\t\tsk_msg_apply_bytes(psock, tosend);\n\t\tbreak;\n\tcase __SK_REDIRECT:\n\t\tredir_ingress = psock->redir_ingress;\n\t\tsk_redir = psock->sk_redir;\n\t\tsk_msg_apply_bytes(psock, tosend);\n\t\tif (!psock->apply_bytes) {\n\t\t\t \n\t\t\teval = psock->eval;\n\t\t\tpsock->eval = __SK_NONE;\n\t\t\tpsock->sk_redir = NULL;\n\t\t}\n\t\tif (psock->cork) {\n\t\t\tcork = true;\n\t\t\tpsock->cork = NULL;\n\t\t}\n\t\tsk_msg_return(sk, msg, tosend);\n\t\trelease_sock(sk);\n\n\t\torigsize = msg->sg.size;\n\t\tret = tcp_bpf_sendmsg_redir(sk_redir, redir_ingress,\n\t\t\t\t\t    msg, tosend, flags);\n\t\tsent = origsize - msg->sg.size;\n\n\t\tif (eval == __SK_REDIRECT)\n\t\t\tsock_put(sk_redir);\n\n\t\tlock_sock(sk);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tint free = sk_msg_free_nocharge(sk, msg);\n\n\t\t\tif (!cork)\n\t\t\t\t*copied -= free;\n\t\t}\n\t\tif (cork) {\n\t\t\tsk_msg_free(sk, msg);\n\t\t\tkfree(msg);\n\t\t\tmsg = NULL;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tcase __SK_DROP:\n\tdefault:\n\t\tsk_msg_free_partial(sk, msg, tosend);\n\t\tsk_msg_apply_bytes(psock, tosend);\n\t\t*copied -= (tosend + delta);\n\t\treturn -EACCES;\n\t}\n\n\tif (likely(!ret)) {\n\t\tif (!psock->apply_bytes) {\n\t\t\tpsock->eval =  __SK_NONE;\n\t\t\tif (psock->sk_redir) {\n\t\t\t\tsock_put(psock->sk_redir);\n\t\t\t\tpsock->sk_redir = NULL;\n\t\t\t}\n\t\t}\n\t\tif (msg &&\n\t\t    msg->sg.data[msg->sg.start].page_link &&\n\t\t    msg->sg.data[msg->sg.start].length) {\n\t\t\tif (eval == __SK_REDIRECT)\n\t\t\t\tsk_mem_charge(sk, tosend - sent);\n\t\t\tgoto more_data;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int tcp_bpf_sendmsg(struct sock *sk, struct msghdr *msg, size_t size)\n{\n\tstruct sk_msg tmp, *msg_tx = NULL;\n\tint copied = 0, err = 0;\n\tstruct sk_psock *psock;\n\tlong timeo;\n\tint flags;\n\n\t \n\tflags = (msg->msg_flags & ~MSG_SENDPAGE_DECRYPTED);\n\tflags |= MSG_NO_SHARED_FRAGS;\n\n\tpsock = sk_psock_get(sk);\n\tif (unlikely(!psock))\n\t\treturn tcp_sendmsg(sk, msg, size);\n\n\tlock_sock(sk);\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\twhile (msg_data_left(msg)) {\n\t\tbool enospc = false;\n\t\tu32 copy, osize;\n\n\t\tif (sk->sk_err) {\n\t\t\terr = -sk->sk_err;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tcopy = msg_data_left(msg);\n\t\tif (!sk_stream_memory_free(sk))\n\t\t\tgoto wait_for_sndbuf;\n\t\tif (psock->cork) {\n\t\t\tmsg_tx = psock->cork;\n\t\t} else {\n\t\t\tmsg_tx = &tmp;\n\t\t\tsk_msg_init(msg_tx);\n\t\t}\n\n\t\tosize = msg_tx->sg.size;\n\t\terr = sk_msg_alloc(sk, msg_tx, msg_tx->sg.size + copy, msg_tx->sg.end - 1);\n\t\tif (err) {\n\t\t\tif (err != -ENOSPC)\n\t\t\t\tgoto wait_for_memory;\n\t\t\tenospc = true;\n\t\t\tcopy = msg_tx->sg.size - osize;\n\t\t}\n\n\t\terr = sk_msg_memcopy_from_iter(sk, &msg->msg_iter, msg_tx,\n\t\t\t\t\t       copy);\n\t\tif (err < 0) {\n\t\t\tsk_msg_trim(sk, msg_tx, osize);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tcopied += copy;\n\t\tif (psock->cork_bytes) {\n\t\t\tif (size > psock->cork_bytes)\n\t\t\t\tpsock->cork_bytes = 0;\n\t\t\telse\n\t\t\t\tpsock->cork_bytes -= size;\n\t\t\tif (psock->cork_bytes && !enospc)\n\t\t\t\tgoto out_err;\n\t\t\t \n\t\t\tpsock->eval = __SK_NONE;\n\t\t\tpsock->cork_bytes = 0;\n\t\t}\n\n\t\terr = tcp_bpf_send_verdict(sk, psock, msg_tx, &copied, flags);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto out_err;\n\t\tcontinue;\nwait_for_sndbuf:\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\nwait_for_memory:\n\t\terr = sk_stream_wait_memory(sk, &timeo);\n\t\tif (err) {\n\t\t\tif (msg_tx && msg_tx != psock->cork)\n\t\t\t\tsk_msg_free(sk, msg_tx);\n\t\t\tgoto out_err;\n\t\t}\n\t}\nout_err:\n\tif (err < 0)\n\t\terr = sk_stream_error(sk, msg->msg_flags, err);\n\trelease_sock(sk);\n\tsk_psock_put(sk, psock);\n\treturn copied ? copied : err;\n}\n\nenum {\n\tTCP_BPF_IPV4,\n\tTCP_BPF_IPV6,\n\tTCP_BPF_NUM_PROTS,\n};\n\nenum {\n\tTCP_BPF_BASE,\n\tTCP_BPF_TX,\n\tTCP_BPF_RX,\n\tTCP_BPF_TXRX,\n\tTCP_BPF_NUM_CFGS,\n};\n\nstatic struct proto *tcpv6_prot_saved __read_mostly;\nstatic DEFINE_SPINLOCK(tcpv6_prot_lock);\nstatic struct proto tcp_bpf_prots[TCP_BPF_NUM_PROTS][TCP_BPF_NUM_CFGS];\n\nstatic void tcp_bpf_rebuild_protos(struct proto prot[TCP_BPF_NUM_CFGS],\n\t\t\t\t   struct proto *base)\n{\n\tprot[TCP_BPF_BASE]\t\t\t= *base;\n\tprot[TCP_BPF_BASE].destroy\t\t= sock_map_destroy;\n\tprot[TCP_BPF_BASE].close\t\t= sock_map_close;\n\tprot[TCP_BPF_BASE].recvmsg\t\t= tcp_bpf_recvmsg;\n\tprot[TCP_BPF_BASE].sock_is_readable\t= sk_msg_is_readable;\n\n\tprot[TCP_BPF_TX]\t\t\t= prot[TCP_BPF_BASE];\n\tprot[TCP_BPF_TX].sendmsg\t\t= tcp_bpf_sendmsg;\n\n\tprot[TCP_BPF_RX]\t\t\t= prot[TCP_BPF_BASE];\n\tprot[TCP_BPF_RX].recvmsg\t\t= tcp_bpf_recvmsg_parser;\n\n\tprot[TCP_BPF_TXRX]\t\t\t= prot[TCP_BPF_TX];\n\tprot[TCP_BPF_TXRX].recvmsg\t\t= tcp_bpf_recvmsg_parser;\n}\n\nstatic void tcp_bpf_check_v6_needs_rebuild(struct proto *ops)\n{\n\tif (unlikely(ops != smp_load_acquire(&tcpv6_prot_saved))) {\n\t\tspin_lock_bh(&tcpv6_prot_lock);\n\t\tif (likely(ops != tcpv6_prot_saved)) {\n\t\t\ttcp_bpf_rebuild_protos(tcp_bpf_prots[TCP_BPF_IPV6], ops);\n\t\t\tsmp_store_release(&tcpv6_prot_saved, ops);\n\t\t}\n\t\tspin_unlock_bh(&tcpv6_prot_lock);\n\t}\n}\n\nstatic int __init tcp_bpf_v4_build_proto(void)\n{\n\ttcp_bpf_rebuild_protos(tcp_bpf_prots[TCP_BPF_IPV4], &tcp_prot);\n\treturn 0;\n}\nlate_initcall(tcp_bpf_v4_build_proto);\n\nstatic int tcp_bpf_assert_proto_ops(struct proto *ops)\n{\n\t \n\treturn ops->recvmsg  == tcp_recvmsg &&\n\t       ops->sendmsg  == tcp_sendmsg ? 0 : -ENOTSUPP;\n}\n\nint tcp_bpf_update_proto(struct sock *sk, struct sk_psock *psock, bool restore)\n{\n\tint family = sk->sk_family == AF_INET6 ? TCP_BPF_IPV6 : TCP_BPF_IPV4;\n\tint config = psock->progs.msg_parser   ? TCP_BPF_TX   : TCP_BPF_BASE;\n\n\tif (psock->progs.stream_verdict || psock->progs.skb_verdict) {\n\t\tconfig = (config == TCP_BPF_TX) ? TCP_BPF_TXRX : TCP_BPF_RX;\n\t}\n\n\tif (restore) {\n\t\tif (inet_csk_has_ulp(sk)) {\n\t\t\t \n\t\t\tWRITE_ONCE(sk->sk_prot->unhash, psock->saved_unhash);\n\t\t\ttcp_update_ulp(sk, psock->sk_proto, psock->saved_write_space);\n\t\t} else {\n\t\t\tsk->sk_write_space = psock->saved_write_space;\n\t\t\t \n\t\t\tsock_replace_proto(sk, psock->sk_proto);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (sk->sk_family == AF_INET6) {\n\t\tif (tcp_bpf_assert_proto_ops(psock->sk_proto))\n\t\t\treturn -EINVAL;\n\n\t\ttcp_bpf_check_v6_needs_rebuild(psock->sk_proto);\n\t}\n\n\t \n\tsock_replace_proto(sk, &tcp_bpf_prots[family][config]);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tcp_bpf_update_proto);\n\n \nvoid tcp_bpf_clone(const struct sock *sk, struct sock *newsk)\n{\n\tstruct proto *prot = newsk->sk_prot;\n\n\tif (is_insidevar(prot, tcp_bpf_prots))\n\t\tnewsk->sk_prot = sk->sk_prot_creator;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}