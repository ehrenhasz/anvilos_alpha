{
  "module_name": "ip_tunnel_core.c",
  "hash_id": "48a21d01f13d9766550a89553a02c215b49aee81ae93566a2cccb9aadac4f351",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ip_tunnel_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/in.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/in6.h>\n#include <linux/inetdevice.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/static_key.h>\n\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/protocol.h>\n#include <net/ip_tunnels.h>\n#include <net/ip6_tunnel.h>\n#include <net/ip6_checksum.h>\n#include <net/arp.h>\n#include <net/checksum.h>\n#include <net/dsfield.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/rtnetlink.h>\n#include <net/dst_metadata.h>\n#include <net/geneve.h>\n#include <net/vxlan.h>\n#include <net/erspan.h>\n\nconst struct ip_tunnel_encap_ops __rcu *\n\t\tiptun_encaps[MAX_IPTUN_ENCAP_OPS] __read_mostly;\nEXPORT_SYMBOL(iptun_encaps);\n\nconst struct ip6_tnl_encap_ops __rcu *\n\t\tip6tun_encaps[MAX_IPTUN_ENCAP_OPS] __read_mostly;\nEXPORT_SYMBOL(ip6tun_encaps);\n\nvoid iptunnel_xmit(struct sock *sk, struct rtable *rt, struct sk_buff *skb,\n\t\t   __be32 src, __be32 dst, __u8 proto,\n\t\t   __u8 tos, __u8 ttl, __be16 df, bool xnet)\n{\n\tint pkt_len = skb->len - skb_inner_network_offset(skb);\n\tstruct net *net = dev_net(rt->dst.dev);\n\tstruct net_device *dev = skb->dev;\n\tstruct iphdr *iph;\n\tint err;\n\n\tskb_scrub_packet(skb, xnet);\n\n\tskb_clear_hash_if_not_l4(skb);\n\tskb_dst_set(skb, &rt->dst);\n\tmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\n\n\t \n\tskb_push(skb, sizeof(struct iphdr));\n\tskb_reset_network_header(skb);\n\n\tiph = ip_hdr(skb);\n\n\tiph->version\t=\t4;\n\tiph->ihl\t=\tsizeof(struct iphdr) >> 2;\n\tiph->frag_off\t=\tip_mtu_locked(&rt->dst) ? 0 : df;\n\tiph->protocol\t=\tproto;\n\tiph->tos\t=\ttos;\n\tiph->daddr\t=\tdst;\n\tiph->saddr\t=\tsrc;\n\tiph->ttl\t=\tttl;\n\t__ip_select_ident(net, iph, skb_shinfo(skb)->gso_segs ?: 1);\n\n\terr = ip_local_out(net, sk, skb);\n\n\tif (dev) {\n\t\tif (unlikely(net_xmit_eval(err)))\n\t\t\tpkt_len = 0;\n\t\tiptunnel_xmit_stats(dev, pkt_len);\n\t}\n}\nEXPORT_SYMBOL_GPL(iptunnel_xmit);\n\nint __iptunnel_pull_header(struct sk_buff *skb, int hdr_len,\n\t\t\t   __be16 inner_proto, bool raw_proto, bool xnet)\n{\n\tif (unlikely(!pskb_may_pull(skb, hdr_len)))\n\t\treturn -ENOMEM;\n\n\tskb_pull_rcsum(skb, hdr_len);\n\n\tif (!raw_proto && inner_proto == htons(ETH_P_TEB)) {\n\t\tstruct ethhdr *eh;\n\n\t\tif (unlikely(!pskb_may_pull(skb, ETH_HLEN)))\n\t\t\treturn -ENOMEM;\n\n\t\teh = (struct ethhdr *)skb->data;\n\t\tif (likely(eth_proto_is_802_3(eh->h_proto)))\n\t\t\tskb->protocol = eh->h_proto;\n\t\telse\n\t\t\tskb->protocol = htons(ETH_P_802_2);\n\n\t} else {\n\t\tskb->protocol = inner_proto;\n\t}\n\n\tskb_clear_hash_if_not_l4(skb);\n\t__vlan_hwaccel_clear_tag(skb);\n\tskb_set_queue_mapping(skb, 0);\n\tskb_scrub_packet(skb, xnet);\n\n\treturn iptunnel_pull_offloads(skb);\n}\nEXPORT_SYMBOL_GPL(__iptunnel_pull_header);\n\nstruct metadata_dst *iptunnel_metadata_reply(struct metadata_dst *md,\n\t\t\t\t\t     gfp_t flags)\n{\n\tstruct metadata_dst *res;\n\tstruct ip_tunnel_info *dst, *src;\n\n\tif (!md || md->type != METADATA_IP_TUNNEL ||\n\t    md->u.tun_info.mode & IP_TUNNEL_INFO_TX)\n\t\treturn NULL;\n\n\tsrc = &md->u.tun_info;\n\tres = metadata_dst_alloc(src->options_len, METADATA_IP_TUNNEL, flags);\n\tif (!res)\n\t\treturn NULL;\n\n\tdst = &res->u.tun_info;\n\tdst->key.tun_id = src->key.tun_id;\n\tif (src->mode & IP_TUNNEL_INFO_IPV6)\n\t\tmemcpy(&dst->key.u.ipv6.dst, &src->key.u.ipv6.src,\n\t\t       sizeof(struct in6_addr));\n\telse\n\t\tdst->key.u.ipv4.dst = src->key.u.ipv4.src;\n\tdst->key.tun_flags = src->key.tun_flags;\n\tdst->mode = src->mode | IP_TUNNEL_INFO_TX;\n\tip_tunnel_info_opts_set(dst, ip_tunnel_info_opts(src),\n\t\t\t\tsrc->options_len, 0);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(iptunnel_metadata_reply);\n\nint iptunnel_handle_offloads(struct sk_buff *skb,\n\t\t\t     int gso_type_mask)\n{\n\tint err;\n\n\tif (likely(!skb->encapsulation)) {\n\t\tskb_reset_inner_headers(skb);\n\t\tskb->encapsulation = 1;\n\t}\n\n\tif (skb_is_gso(skb)) {\n\t\terr = skb_header_unclone(skb, GFP_ATOMIC);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t\tskb_shinfo(skb)->gso_type |= gso_type_mask;\n\t\treturn 0;\n\t}\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t \n\t\tskb->encapsulation = 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(iptunnel_handle_offloads);\n\n \nstatic int iptunnel_pmtud_build_icmp(struct sk_buff *skb, int mtu)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct icmphdr *icmph;\n\tstruct iphdr *niph;\n\tstruct ethhdr eh;\n\tint len, err;\n\n\tif (!pskb_may_pull(skb, ETH_HLEN + sizeof(struct iphdr)))\n\t\treturn -EINVAL;\n\n\tskb_copy_bits(skb, skb_mac_offset(skb), &eh, ETH_HLEN);\n\tpskb_pull(skb, ETH_HLEN);\n\tskb_reset_network_header(skb);\n\n\terr = pskb_trim(skb, 576 - sizeof(*niph) - sizeof(*icmph));\n\tif (err)\n\t\treturn err;\n\n\tlen = skb->len + sizeof(*icmph);\n\terr = skb_cow(skb, sizeof(*niph) + sizeof(*icmph) + ETH_HLEN);\n\tif (err)\n\t\treturn err;\n\n\ticmph = skb_push(skb, sizeof(*icmph));\n\t*icmph = (struct icmphdr) {\n\t\t.type\t\t\t= ICMP_DEST_UNREACH,\n\t\t.code\t\t\t= ICMP_FRAG_NEEDED,\n\t\t.checksum\t\t= 0,\n\t\t.un.frag.__unused\t= 0,\n\t\t.un.frag.mtu\t\t= htons(mtu),\n\t};\n\ticmph->checksum = csum_fold(skb_checksum(skb, 0, len, 0));\n\tskb_reset_transport_header(skb);\n\n\tniph = skb_push(skb, sizeof(*niph));\n\t*niph = (struct iphdr) {\n\t\t.ihl\t\t\t= sizeof(*niph) / 4u,\n\t\t.version \t\t= 4,\n\t\t.tos \t\t\t= 0,\n\t\t.tot_len\t\t= htons(len + sizeof(*niph)),\n\t\t.id\t\t\t= 0,\n\t\t.frag_off\t\t= htons(IP_DF),\n\t\t.ttl\t\t\t= iph->ttl,\n\t\t.protocol\t\t= IPPROTO_ICMP,\n\t\t.saddr\t\t\t= iph->daddr,\n\t\t.daddr\t\t\t= iph->saddr,\n\t};\n\tip_send_check(niph);\n\tskb_reset_network_header(skb);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\teth_header(skb, skb->dev, ntohs(eh.h_proto), eh.h_source, eh.h_dest, 0);\n\tskb_reset_mac_header(skb);\n\n\treturn skb->len;\n}\n\n \nstatic int iptunnel_pmtud_check_icmp(struct sk_buff *skb, int mtu)\n{\n\tconst struct icmphdr *icmph = icmp_hdr(skb);\n\tconst struct iphdr *iph = ip_hdr(skb);\n\n\tif (mtu < 576 || iph->frag_off != htons(IP_DF))\n\t\treturn 0;\n\n\tif (ipv4_is_lbcast(iph->daddr)  || ipv4_is_multicast(iph->daddr) ||\n\t    ipv4_is_zeronet(iph->saddr) || ipv4_is_loopback(iph->saddr)  ||\n\t    ipv4_is_lbcast(iph->saddr)  || ipv4_is_multicast(iph->saddr))\n\t\treturn 0;\n\n\tif (iph->protocol == IPPROTO_ICMP && icmp_is_err(icmph->type))\n\t\treturn 0;\n\n\treturn iptunnel_pmtud_build_icmp(skb, mtu);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nstatic int iptunnel_pmtud_build_icmpv6(struct sk_buff *skb, int mtu)\n{\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tstruct icmp6hdr *icmp6h;\n\tstruct ipv6hdr *nip6h;\n\tstruct ethhdr eh;\n\tint len, err;\n\t__wsum csum;\n\n\tif (!pskb_may_pull(skb, ETH_HLEN + sizeof(struct ipv6hdr)))\n\t\treturn -EINVAL;\n\n\tskb_copy_bits(skb, skb_mac_offset(skb), &eh, ETH_HLEN);\n\tpskb_pull(skb, ETH_HLEN);\n\tskb_reset_network_header(skb);\n\n\terr = pskb_trim(skb, IPV6_MIN_MTU - sizeof(*nip6h) - sizeof(*icmp6h));\n\tif (err)\n\t\treturn err;\n\n\tlen = skb->len + sizeof(*icmp6h);\n\terr = skb_cow(skb, sizeof(*nip6h) + sizeof(*icmp6h) + ETH_HLEN);\n\tif (err)\n\t\treturn err;\n\n\ticmp6h = skb_push(skb, sizeof(*icmp6h));\n\t*icmp6h = (struct icmp6hdr) {\n\t\t.icmp6_type\t\t= ICMPV6_PKT_TOOBIG,\n\t\t.icmp6_code\t\t= 0,\n\t\t.icmp6_cksum\t\t= 0,\n\t\t.icmp6_mtu\t\t= htonl(mtu),\n\t};\n\tskb_reset_transport_header(skb);\n\n\tnip6h = skb_push(skb, sizeof(*nip6h));\n\t*nip6h = (struct ipv6hdr) {\n\t\t.priority\t\t= 0,\n\t\t.version\t\t= 6,\n\t\t.flow_lbl\t\t= { 0 },\n\t\t.payload_len\t\t= htons(len),\n\t\t.nexthdr\t\t= IPPROTO_ICMPV6,\n\t\t.hop_limit\t\t= ip6h->hop_limit,\n\t\t.saddr\t\t\t= ip6h->daddr,\n\t\t.daddr\t\t\t= ip6h->saddr,\n\t};\n\tskb_reset_network_header(skb);\n\n\tcsum = csum_partial(icmp6h, len, 0);\n\ticmp6h->icmp6_cksum = csum_ipv6_magic(&nip6h->saddr, &nip6h->daddr, len,\n\t\t\t\t\t      IPPROTO_ICMPV6, csum);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\teth_header(skb, skb->dev, ntohs(eh.h_proto), eh.h_source, eh.h_dest, 0);\n\tskb_reset_mac_header(skb);\n\n\treturn skb->len;\n}\n\n \nstatic int iptunnel_pmtud_check_icmpv6(struct sk_buff *skb, int mtu)\n{\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tint stype = ipv6_addr_type(&ip6h->saddr);\n\tu8 proto = ip6h->nexthdr;\n\t__be16 frag_off;\n\tint offset;\n\n\tif (mtu < IPV6_MIN_MTU)\n\t\treturn 0;\n\n\tif (stype == IPV6_ADDR_ANY || stype == IPV6_ADDR_MULTICAST ||\n\t    stype == IPV6_ADDR_LOOPBACK)\n\t\treturn 0;\n\n\toffset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &proto,\n\t\t\t\t  &frag_off);\n\tif (offset < 0 || (frag_off & htons(~0x7)))\n\t\treturn 0;\n\n\tif (proto == IPPROTO_ICMPV6) {\n\t\tstruct icmp6hdr *icmp6h;\n\n\t\tif (!pskb_may_pull(skb, skb_network_header(skb) +\n\t\t\t\t\toffset + 1 - skb->data))\n\t\t\treturn 0;\n\n\t\ticmp6h = (struct icmp6hdr *)(skb_network_header(skb) + offset);\n\t\tif (icmpv6_is_err(icmp6h->icmp6_type) ||\n\t\t    icmp6h->icmp6_type == NDISC_REDIRECT)\n\t\t\treturn 0;\n\t}\n\n\treturn iptunnel_pmtud_build_icmpv6(skb, mtu);\n}\n#endif  \n\n \nint skb_tunnel_check_pmtu(struct sk_buff *skb, struct dst_entry *encap_dst,\n\t\t\t  int headroom, bool reply)\n{\n\tu32 mtu = dst_mtu(encap_dst) - headroom;\n\n\tif ((skb_is_gso(skb) && skb_gso_validate_network_len(skb, mtu)) ||\n\t    (!skb_is_gso(skb) && (skb->len - skb_network_offset(skb)) <= mtu))\n\t\treturn 0;\n\n\tskb_dst_update_pmtu_no_confirm(skb, mtu);\n\n\tif (!reply || skb->pkt_type == PACKET_HOST)\n\t\treturn 0;\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn iptunnel_pmtud_check_icmp(skb, mtu);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (skb->protocol == htons(ETH_P_IPV6))\n\t\treturn iptunnel_pmtud_check_icmpv6(skb, mtu);\n#endif\n\treturn 0;\n}\nEXPORT_SYMBOL(skb_tunnel_check_pmtu);\n\nstatic const struct nla_policy ip_tun_policy[LWTUNNEL_IP_MAX + 1] = {\n\t[LWTUNNEL_IP_UNSPEC]\t= { .strict_start_type = LWTUNNEL_IP_OPTS },\n\t[LWTUNNEL_IP_ID]\t= { .type = NLA_U64 },\n\t[LWTUNNEL_IP_DST]\t= { .type = NLA_U32 },\n\t[LWTUNNEL_IP_SRC]\t= { .type = NLA_U32 },\n\t[LWTUNNEL_IP_TTL]\t= { .type = NLA_U8 },\n\t[LWTUNNEL_IP_TOS]\t= { .type = NLA_U8 },\n\t[LWTUNNEL_IP_FLAGS]\t= { .type = NLA_U16 },\n\t[LWTUNNEL_IP_OPTS]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy ip_opts_policy[LWTUNNEL_IP_OPTS_MAX + 1] = {\n\t[LWTUNNEL_IP_OPTS_GENEVE]\t= { .type = NLA_NESTED },\n\t[LWTUNNEL_IP_OPTS_VXLAN]\t= { .type = NLA_NESTED },\n\t[LWTUNNEL_IP_OPTS_ERSPAN]\t= { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy\ngeneve_opt_policy[LWTUNNEL_IP_OPT_GENEVE_MAX + 1] = {\n\t[LWTUNNEL_IP_OPT_GENEVE_CLASS]\t= { .type = NLA_U16 },\n\t[LWTUNNEL_IP_OPT_GENEVE_TYPE]\t= { .type = NLA_U8 },\n\t[LWTUNNEL_IP_OPT_GENEVE_DATA]\t= { .type = NLA_BINARY, .len = 128 },\n};\n\nstatic const struct nla_policy\nvxlan_opt_policy[LWTUNNEL_IP_OPT_VXLAN_MAX + 1] = {\n\t[LWTUNNEL_IP_OPT_VXLAN_GBP]\t= { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nerspan_opt_policy[LWTUNNEL_IP_OPT_ERSPAN_MAX + 1] = {\n\t[LWTUNNEL_IP_OPT_ERSPAN_VER]\t= { .type = NLA_U8 },\n\t[LWTUNNEL_IP_OPT_ERSPAN_INDEX]\t= { .type = NLA_U32 },\n\t[LWTUNNEL_IP_OPT_ERSPAN_DIR]\t= { .type = NLA_U8 },\n\t[LWTUNNEL_IP_OPT_ERSPAN_HWID]\t= { .type = NLA_U8 },\n};\n\nstatic int ip_tun_parse_opts_geneve(struct nlattr *attr,\n\t\t\t\t    struct ip_tunnel_info *info, int opts_len,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[LWTUNNEL_IP_OPT_GENEVE_MAX + 1];\n\tint data_len, err;\n\n\terr = nla_parse_nested(tb, LWTUNNEL_IP_OPT_GENEVE_MAX, attr,\n\t\t\t       geneve_opt_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[LWTUNNEL_IP_OPT_GENEVE_CLASS] ||\n\t    !tb[LWTUNNEL_IP_OPT_GENEVE_TYPE] ||\n\t    !tb[LWTUNNEL_IP_OPT_GENEVE_DATA])\n\t\treturn -EINVAL;\n\n\tattr = tb[LWTUNNEL_IP_OPT_GENEVE_DATA];\n\tdata_len = nla_len(attr);\n\tif (data_len % 4)\n\t\treturn -EINVAL;\n\n\tif (info) {\n\t\tstruct geneve_opt *opt = ip_tunnel_info_opts(info) + opts_len;\n\n\t\tmemcpy(opt->opt_data, nla_data(attr), data_len);\n\t\topt->length = data_len / 4;\n\t\tattr = tb[LWTUNNEL_IP_OPT_GENEVE_CLASS];\n\t\topt->opt_class = nla_get_be16(attr);\n\t\tattr = tb[LWTUNNEL_IP_OPT_GENEVE_TYPE];\n\t\topt->type = nla_get_u8(attr);\n\t\tinfo->key.tun_flags |= TUNNEL_GENEVE_OPT;\n\t}\n\n\treturn sizeof(struct geneve_opt) + data_len;\n}\n\nstatic int ip_tun_parse_opts_vxlan(struct nlattr *attr,\n\t\t\t\t   struct ip_tunnel_info *info, int opts_len,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[LWTUNNEL_IP_OPT_VXLAN_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(tb, LWTUNNEL_IP_OPT_VXLAN_MAX, attr,\n\t\t\t       vxlan_opt_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[LWTUNNEL_IP_OPT_VXLAN_GBP])\n\t\treturn -EINVAL;\n\n\tif (info) {\n\t\tstruct vxlan_metadata *md =\n\t\t\tip_tunnel_info_opts(info) + opts_len;\n\n\t\tattr = tb[LWTUNNEL_IP_OPT_VXLAN_GBP];\n\t\tmd->gbp = nla_get_u32(attr);\n\t\tmd->gbp &= VXLAN_GBP_MASK;\n\t\tinfo->key.tun_flags |= TUNNEL_VXLAN_OPT;\n\t}\n\n\treturn sizeof(struct vxlan_metadata);\n}\n\nstatic int ip_tun_parse_opts_erspan(struct nlattr *attr,\n\t\t\t\t    struct ip_tunnel_info *info, int opts_len,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[LWTUNNEL_IP_OPT_ERSPAN_MAX + 1];\n\tint err;\n\tu8 ver;\n\n\terr = nla_parse_nested(tb, LWTUNNEL_IP_OPT_ERSPAN_MAX, attr,\n\t\t\t       erspan_opt_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[LWTUNNEL_IP_OPT_ERSPAN_VER])\n\t\treturn -EINVAL;\n\n\tver = nla_get_u8(tb[LWTUNNEL_IP_OPT_ERSPAN_VER]);\n\tif (ver == 1) {\n\t\tif (!tb[LWTUNNEL_IP_OPT_ERSPAN_INDEX])\n\t\t\treturn -EINVAL;\n\t} else if (ver == 2) {\n\t\tif (!tb[LWTUNNEL_IP_OPT_ERSPAN_DIR] ||\n\t\t    !tb[LWTUNNEL_IP_OPT_ERSPAN_HWID])\n\t\t\treturn -EINVAL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (info) {\n\t\tstruct erspan_metadata *md =\n\t\t\tip_tunnel_info_opts(info) + opts_len;\n\n\t\tmd->version = ver;\n\t\tif (ver == 1) {\n\t\t\tattr = tb[LWTUNNEL_IP_OPT_ERSPAN_INDEX];\n\t\t\tmd->u.index = nla_get_be32(attr);\n\t\t} else {\n\t\t\tattr = tb[LWTUNNEL_IP_OPT_ERSPAN_DIR];\n\t\t\tmd->u.md2.dir = nla_get_u8(attr);\n\t\t\tattr = tb[LWTUNNEL_IP_OPT_ERSPAN_HWID];\n\t\t\tset_hwid(&md->u.md2, nla_get_u8(attr));\n\t\t}\n\n\t\tinfo->key.tun_flags |= TUNNEL_ERSPAN_OPT;\n\t}\n\n\treturn sizeof(struct erspan_metadata);\n}\n\nstatic int ip_tun_parse_opts(struct nlattr *attr, struct ip_tunnel_info *info,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tint err, rem, opt_len, opts_len = 0;\n\tstruct nlattr *nla;\n\t__be16 type = 0;\n\n\tif (!attr)\n\t\treturn 0;\n\n\terr = nla_validate(nla_data(attr), nla_len(attr), LWTUNNEL_IP_OPTS_MAX,\n\t\t\t   ip_opts_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tnla_for_each_attr(nla, nla_data(attr), nla_len(attr), rem) {\n\t\tswitch (nla_type(nla)) {\n\t\tcase LWTUNNEL_IP_OPTS_GENEVE:\n\t\t\tif (type && type != TUNNEL_GENEVE_OPT)\n\t\t\t\treturn -EINVAL;\n\t\t\topt_len = ip_tun_parse_opts_geneve(nla, info, opts_len,\n\t\t\t\t\t\t\t   extack);\n\t\t\tif (opt_len < 0)\n\t\t\t\treturn opt_len;\n\t\t\topts_len += opt_len;\n\t\t\tif (opts_len > IP_TUNNEL_OPTS_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t\ttype = TUNNEL_GENEVE_OPT;\n\t\t\tbreak;\n\t\tcase LWTUNNEL_IP_OPTS_VXLAN:\n\t\t\tif (type)\n\t\t\t\treturn -EINVAL;\n\t\t\topt_len = ip_tun_parse_opts_vxlan(nla, info, opts_len,\n\t\t\t\t\t\t\t  extack);\n\t\t\tif (opt_len < 0)\n\t\t\t\treturn opt_len;\n\t\t\topts_len += opt_len;\n\t\t\ttype = TUNNEL_VXLAN_OPT;\n\t\t\tbreak;\n\t\tcase LWTUNNEL_IP_OPTS_ERSPAN:\n\t\t\tif (type)\n\t\t\t\treturn -EINVAL;\n\t\t\topt_len = ip_tun_parse_opts_erspan(nla, info, opts_len,\n\t\t\t\t\t\t\t   extack);\n\t\t\tif (opt_len < 0)\n\t\t\t\treturn opt_len;\n\t\t\topts_len += opt_len;\n\t\t\ttype = TUNNEL_ERSPAN_OPT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn opts_len;\n}\n\nstatic int ip_tun_get_optlen(struct nlattr *attr,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\treturn ip_tun_parse_opts(attr, NULL, extack);\n}\n\nstatic int ip_tun_set_opts(struct nlattr *attr, struct ip_tunnel_info *info,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\treturn ip_tun_parse_opts(attr, info, extack);\n}\n\nstatic int ip_tun_build_state(struct net *net, struct nlattr *attr,\n\t\t\t      unsigned int family, const void *cfg,\n\t\t\t      struct lwtunnel_state **ts,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[LWTUNNEL_IP_MAX + 1];\n\tstruct lwtunnel_state *new_state;\n\tstruct ip_tunnel_info *tun_info;\n\tint err, opt_len;\n\n\terr = nla_parse_nested_deprecated(tb, LWTUNNEL_IP_MAX, attr,\n\t\t\t\t\t  ip_tun_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\topt_len = ip_tun_get_optlen(tb[LWTUNNEL_IP_OPTS], extack);\n\tif (opt_len < 0)\n\t\treturn opt_len;\n\n\tnew_state = lwtunnel_state_alloc(sizeof(*tun_info) + opt_len);\n\tif (!new_state)\n\t\treturn -ENOMEM;\n\n\tnew_state->type = LWTUNNEL_ENCAP_IP;\n\n\ttun_info = lwt_tun_info(new_state);\n\n\terr = ip_tun_set_opts(tb[LWTUNNEL_IP_OPTS], tun_info, extack);\n\tif (err < 0) {\n\t\tlwtstate_free(new_state);\n\t\treturn err;\n\t}\n\n#ifdef CONFIG_DST_CACHE\n\terr = dst_cache_init(&tun_info->dst_cache, GFP_KERNEL);\n\tif (err) {\n\t\tlwtstate_free(new_state);\n\t\treturn err;\n\t}\n#endif\n\n\tif (tb[LWTUNNEL_IP_ID])\n\t\ttun_info->key.tun_id = nla_get_be64(tb[LWTUNNEL_IP_ID]);\n\n\tif (tb[LWTUNNEL_IP_DST])\n\t\ttun_info->key.u.ipv4.dst = nla_get_in_addr(tb[LWTUNNEL_IP_DST]);\n\n\tif (tb[LWTUNNEL_IP_SRC])\n\t\ttun_info->key.u.ipv4.src = nla_get_in_addr(tb[LWTUNNEL_IP_SRC]);\n\n\tif (tb[LWTUNNEL_IP_TTL])\n\t\ttun_info->key.ttl = nla_get_u8(tb[LWTUNNEL_IP_TTL]);\n\n\tif (tb[LWTUNNEL_IP_TOS])\n\t\ttun_info->key.tos = nla_get_u8(tb[LWTUNNEL_IP_TOS]);\n\n\tif (tb[LWTUNNEL_IP_FLAGS])\n\t\ttun_info->key.tun_flags |=\n\t\t\t\t(nla_get_be16(tb[LWTUNNEL_IP_FLAGS]) &\n\t\t\t\t ~TUNNEL_OPTIONS_PRESENT);\n\n\ttun_info->mode = IP_TUNNEL_INFO_TX;\n\ttun_info->options_len = opt_len;\n\n\t*ts = new_state;\n\n\treturn 0;\n}\n\nstatic void ip_tun_destroy_state(struct lwtunnel_state *lwtstate)\n{\n#ifdef CONFIG_DST_CACHE\n\tstruct ip_tunnel_info *tun_info = lwt_tun_info(lwtstate);\n\n\tdst_cache_destroy(&tun_info->dst_cache);\n#endif\n}\n\nstatic int ip_tun_fill_encap_opts_geneve(struct sk_buff *skb,\n\t\t\t\t\t struct ip_tunnel_info *tun_info)\n{\n\tstruct geneve_opt *opt;\n\tstruct nlattr *nest;\n\tint offset = 0;\n\n\tnest = nla_nest_start_noflag(skb, LWTUNNEL_IP_OPTS_GENEVE);\n\tif (!nest)\n\t\treturn -ENOMEM;\n\n\twhile (tun_info->options_len > offset) {\n\t\topt = ip_tunnel_info_opts(tun_info) + offset;\n\t\tif (nla_put_be16(skb, LWTUNNEL_IP_OPT_GENEVE_CLASS,\n\t\t\t\t opt->opt_class) ||\n\t\t    nla_put_u8(skb, LWTUNNEL_IP_OPT_GENEVE_TYPE, opt->type) ||\n\t\t    nla_put(skb, LWTUNNEL_IP_OPT_GENEVE_DATA, opt->length * 4,\n\t\t\t    opt->opt_data)) {\n\t\t\tnla_nest_cancel(skb, nest);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\toffset += sizeof(*opt) + opt->length * 4;\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n}\n\nstatic int ip_tun_fill_encap_opts_vxlan(struct sk_buff *skb,\n\t\t\t\t\tstruct ip_tunnel_info *tun_info)\n{\n\tstruct vxlan_metadata *md;\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, LWTUNNEL_IP_OPTS_VXLAN);\n\tif (!nest)\n\t\treturn -ENOMEM;\n\n\tmd = ip_tunnel_info_opts(tun_info);\n\tif (nla_put_u32(skb, LWTUNNEL_IP_OPT_VXLAN_GBP, md->gbp)) {\n\t\tnla_nest_cancel(skb, nest);\n\t\treturn -ENOMEM;\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n}\n\nstatic int ip_tun_fill_encap_opts_erspan(struct sk_buff *skb,\n\t\t\t\t\t struct ip_tunnel_info *tun_info)\n{\n\tstruct erspan_metadata *md;\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, LWTUNNEL_IP_OPTS_ERSPAN);\n\tif (!nest)\n\t\treturn -ENOMEM;\n\n\tmd = ip_tunnel_info_opts(tun_info);\n\tif (nla_put_u8(skb, LWTUNNEL_IP_OPT_ERSPAN_VER, md->version))\n\t\tgoto err;\n\n\tif (md->version == 1 &&\n\t    nla_put_be32(skb, LWTUNNEL_IP_OPT_ERSPAN_INDEX, md->u.index))\n\t\tgoto err;\n\n\tif (md->version == 2 &&\n\t    (nla_put_u8(skb, LWTUNNEL_IP_OPT_ERSPAN_DIR, md->u.md2.dir) ||\n\t     nla_put_u8(skb, LWTUNNEL_IP_OPT_ERSPAN_HWID,\n\t\t\tget_hwid(&md->u.md2))))\n\t\tgoto err;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\nerr:\n\tnla_nest_cancel(skb, nest);\n\treturn -ENOMEM;\n}\n\nstatic int ip_tun_fill_encap_opts(struct sk_buff *skb, int type,\n\t\t\t\t  struct ip_tunnel_info *tun_info)\n{\n\tstruct nlattr *nest;\n\tint err = 0;\n\n\tif (!(tun_info->key.tun_flags & TUNNEL_OPTIONS_PRESENT))\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(skb, type);\n\tif (!nest)\n\t\treturn -ENOMEM;\n\n\tif (tun_info->key.tun_flags & TUNNEL_GENEVE_OPT)\n\t\terr = ip_tun_fill_encap_opts_geneve(skb, tun_info);\n\telse if (tun_info->key.tun_flags & TUNNEL_VXLAN_OPT)\n\t\terr = ip_tun_fill_encap_opts_vxlan(skb, tun_info);\n\telse if (tun_info->key.tun_flags & TUNNEL_ERSPAN_OPT)\n\t\terr = ip_tun_fill_encap_opts_erspan(skb, tun_info);\n\n\tif (err) {\n\t\tnla_nest_cancel(skb, nest);\n\t\treturn err;\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n}\n\nstatic int ip_tun_fill_encap_info(struct sk_buff *skb,\n\t\t\t\t  struct lwtunnel_state *lwtstate)\n{\n\tstruct ip_tunnel_info *tun_info = lwt_tun_info(lwtstate);\n\n\tif (nla_put_be64(skb, LWTUNNEL_IP_ID, tun_info->key.tun_id,\n\t\t\t LWTUNNEL_IP_PAD) ||\n\t    nla_put_in_addr(skb, LWTUNNEL_IP_DST, tun_info->key.u.ipv4.dst) ||\n\t    nla_put_in_addr(skb, LWTUNNEL_IP_SRC, tun_info->key.u.ipv4.src) ||\n\t    nla_put_u8(skb, LWTUNNEL_IP_TOS, tun_info->key.tos) ||\n\t    nla_put_u8(skb, LWTUNNEL_IP_TTL, tun_info->key.ttl) ||\n\t    nla_put_be16(skb, LWTUNNEL_IP_FLAGS, tun_info->key.tun_flags) ||\n\t    ip_tun_fill_encap_opts(skb, LWTUNNEL_IP_OPTS, tun_info))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int ip_tun_opts_nlsize(struct ip_tunnel_info *info)\n{\n\tint opt_len;\n\n\tif (!(info->key.tun_flags & TUNNEL_OPTIONS_PRESENT))\n\t\treturn 0;\n\n\topt_len = nla_total_size(0);\t\t \n\tif (info->key.tun_flags & TUNNEL_GENEVE_OPT) {\n\t\tstruct geneve_opt *opt;\n\t\tint offset = 0;\n\n\t\topt_len += nla_total_size(0);\t \n\t\twhile (info->options_len > offset) {\n\t\t\topt = ip_tunnel_info_opts(info) + offset;\n\t\t\topt_len += nla_total_size(2)\t \n\t\t\t\t   + nla_total_size(1)\t \n\t\t\t\t   + nla_total_size(opt->length * 4);\n\t\t\t\t\t\t\t \n\t\t\toffset += sizeof(*opt) + opt->length * 4;\n\t\t}\n\t} else if (info->key.tun_flags & TUNNEL_VXLAN_OPT) {\n\t\topt_len += nla_total_size(0)\t \n\t\t\t   + nla_total_size(4);\t \n\t} else if (info->key.tun_flags & TUNNEL_ERSPAN_OPT) {\n\t\tstruct erspan_metadata *md = ip_tunnel_info_opts(info);\n\n\t\topt_len += nla_total_size(0)\t \n\t\t\t   + nla_total_size(1)\t \n\t\t\t   + (md->version == 1 ? nla_total_size(4)\n\t\t\t\t\t\t \n\t\t\t\t\t       : nla_total_size(1) +\n\t\t\t\t\t\t nla_total_size(1));\n\t\t\t\t\t\t \n\t}\n\n\treturn opt_len;\n}\n\nstatic int ip_tun_encap_nlsize(struct lwtunnel_state *lwtstate)\n{\n\treturn nla_total_size_64bit(8)\t \n\t\t+ nla_total_size(4)\t \n\t\t+ nla_total_size(4)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(2)\t \n\t\t+ ip_tun_opts_nlsize(lwt_tun_info(lwtstate));\n\t\t\t\t\t \n}\n\nstatic int ip_tun_cmp_encap(struct lwtunnel_state *a, struct lwtunnel_state *b)\n{\n\tstruct ip_tunnel_info *info_a = lwt_tun_info(a);\n\tstruct ip_tunnel_info *info_b = lwt_tun_info(b);\n\n\treturn memcmp(info_a, info_b, sizeof(info_a->key)) ||\n\t       info_a->mode != info_b->mode ||\n\t       info_a->options_len != info_b->options_len ||\n\t       memcmp(ip_tunnel_info_opts(info_a),\n\t\t      ip_tunnel_info_opts(info_b), info_a->options_len);\n}\n\nstatic const struct lwtunnel_encap_ops ip_tun_lwt_ops = {\n\t.build_state = ip_tun_build_state,\n\t.destroy_state = ip_tun_destroy_state,\n\t.fill_encap = ip_tun_fill_encap_info,\n\t.get_encap_size = ip_tun_encap_nlsize,\n\t.cmp_encap = ip_tun_cmp_encap,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct nla_policy ip6_tun_policy[LWTUNNEL_IP6_MAX + 1] = {\n\t[LWTUNNEL_IP6_UNSPEC]\t= { .strict_start_type = LWTUNNEL_IP6_OPTS },\n\t[LWTUNNEL_IP6_ID]\t\t= { .type = NLA_U64 },\n\t[LWTUNNEL_IP6_DST]\t\t= { .len = sizeof(struct in6_addr) },\n\t[LWTUNNEL_IP6_SRC]\t\t= { .len = sizeof(struct in6_addr) },\n\t[LWTUNNEL_IP6_HOPLIMIT]\t\t= { .type = NLA_U8 },\n\t[LWTUNNEL_IP6_TC]\t\t= { .type = NLA_U8 },\n\t[LWTUNNEL_IP6_FLAGS]\t\t= { .type = NLA_U16 },\n\t[LWTUNNEL_IP6_OPTS]\t\t= { .type = NLA_NESTED },\n};\n\nstatic int ip6_tun_build_state(struct net *net, struct nlattr *attr,\n\t\t\t       unsigned int family, const void *cfg,\n\t\t\t       struct lwtunnel_state **ts,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[LWTUNNEL_IP6_MAX + 1];\n\tstruct lwtunnel_state *new_state;\n\tstruct ip_tunnel_info *tun_info;\n\tint err, opt_len;\n\n\terr = nla_parse_nested_deprecated(tb, LWTUNNEL_IP6_MAX, attr,\n\t\t\t\t\t  ip6_tun_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\topt_len = ip_tun_get_optlen(tb[LWTUNNEL_IP6_OPTS], extack);\n\tif (opt_len < 0)\n\t\treturn opt_len;\n\n\tnew_state = lwtunnel_state_alloc(sizeof(*tun_info) + opt_len);\n\tif (!new_state)\n\t\treturn -ENOMEM;\n\n\tnew_state->type = LWTUNNEL_ENCAP_IP6;\n\n\ttun_info = lwt_tun_info(new_state);\n\n\terr = ip_tun_set_opts(tb[LWTUNNEL_IP6_OPTS], tun_info, extack);\n\tif (err < 0) {\n\t\tlwtstate_free(new_state);\n\t\treturn err;\n\t}\n\n\tif (tb[LWTUNNEL_IP6_ID])\n\t\ttun_info->key.tun_id = nla_get_be64(tb[LWTUNNEL_IP6_ID]);\n\n\tif (tb[LWTUNNEL_IP6_DST])\n\t\ttun_info->key.u.ipv6.dst = nla_get_in6_addr(tb[LWTUNNEL_IP6_DST]);\n\n\tif (tb[LWTUNNEL_IP6_SRC])\n\t\ttun_info->key.u.ipv6.src = nla_get_in6_addr(tb[LWTUNNEL_IP6_SRC]);\n\n\tif (tb[LWTUNNEL_IP6_HOPLIMIT])\n\t\ttun_info->key.ttl = nla_get_u8(tb[LWTUNNEL_IP6_HOPLIMIT]);\n\n\tif (tb[LWTUNNEL_IP6_TC])\n\t\ttun_info->key.tos = nla_get_u8(tb[LWTUNNEL_IP6_TC]);\n\n\tif (tb[LWTUNNEL_IP6_FLAGS])\n\t\ttun_info->key.tun_flags |=\n\t\t\t\t(nla_get_be16(tb[LWTUNNEL_IP6_FLAGS]) &\n\t\t\t\t ~TUNNEL_OPTIONS_PRESENT);\n\n\ttun_info->mode = IP_TUNNEL_INFO_TX | IP_TUNNEL_INFO_IPV6;\n\ttun_info->options_len = opt_len;\n\n\t*ts = new_state;\n\n\treturn 0;\n}\n\nstatic int ip6_tun_fill_encap_info(struct sk_buff *skb,\n\t\t\t\t   struct lwtunnel_state *lwtstate)\n{\n\tstruct ip_tunnel_info *tun_info = lwt_tun_info(lwtstate);\n\n\tif (nla_put_be64(skb, LWTUNNEL_IP6_ID, tun_info->key.tun_id,\n\t\t\t LWTUNNEL_IP6_PAD) ||\n\t    nla_put_in6_addr(skb, LWTUNNEL_IP6_DST, &tun_info->key.u.ipv6.dst) ||\n\t    nla_put_in6_addr(skb, LWTUNNEL_IP6_SRC, &tun_info->key.u.ipv6.src) ||\n\t    nla_put_u8(skb, LWTUNNEL_IP6_TC, tun_info->key.tos) ||\n\t    nla_put_u8(skb, LWTUNNEL_IP6_HOPLIMIT, tun_info->key.ttl) ||\n\t    nla_put_be16(skb, LWTUNNEL_IP6_FLAGS, tun_info->key.tun_flags) ||\n\t    ip_tun_fill_encap_opts(skb, LWTUNNEL_IP6_OPTS, tun_info))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int ip6_tun_encap_nlsize(struct lwtunnel_state *lwtstate)\n{\n\treturn nla_total_size_64bit(8)\t \n\t\t+ nla_total_size(16)\t \n\t\t+ nla_total_size(16)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(2)\t \n\t\t+ ip_tun_opts_nlsize(lwt_tun_info(lwtstate));\n\t\t\t\t\t \n}\n\nstatic const struct lwtunnel_encap_ops ip6_tun_lwt_ops = {\n\t.build_state = ip6_tun_build_state,\n\t.fill_encap = ip6_tun_fill_encap_info,\n\t.get_encap_size = ip6_tun_encap_nlsize,\n\t.cmp_encap = ip_tun_cmp_encap,\n\t.owner = THIS_MODULE,\n};\n\nvoid __init ip_tunnel_core_init(void)\n{\n\t \n\tBUILD_BUG_ON(IP_TUNNEL_OPTS_MAX != 255);\n\n\tlwtunnel_encap_add_ops(&ip_tun_lwt_ops, LWTUNNEL_ENCAP_IP);\n\tlwtunnel_encap_add_ops(&ip6_tun_lwt_ops, LWTUNNEL_ENCAP_IP6);\n}\n\nDEFINE_STATIC_KEY_FALSE(ip_tunnel_metadata_cnt);\nEXPORT_SYMBOL(ip_tunnel_metadata_cnt);\n\nvoid ip_tunnel_need_metadata(void)\n{\n\tstatic_branch_inc(&ip_tunnel_metadata_cnt);\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_need_metadata);\n\nvoid ip_tunnel_unneed_metadata(void)\n{\n\tstatic_branch_dec(&ip_tunnel_metadata_cnt);\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_unneed_metadata);\n\n \n__be16 ip_tunnel_parse_protocol(const struct sk_buff *skb)\n{\n\tif (skb_network_header(skb) >= skb->head &&\n\t    (skb_network_header(skb) + sizeof(struct iphdr)) <= skb_tail_pointer(skb) &&\n\t    ip_hdr(skb)->version == 4)\n\t\treturn htons(ETH_P_IP);\n\tif (skb_network_header(skb) >= skb->head &&\n\t    (skb_network_header(skb) + sizeof(struct ipv6hdr)) <= skb_tail_pointer(skb) &&\n\t    ipv6_hdr(skb)->version == 6)\n\t\treturn htons(ETH_P_IPV6);\n\treturn 0;\n}\nEXPORT_SYMBOL(ip_tunnel_parse_protocol);\n\nconst struct header_ops ip_tunnel_header_ops = { .parse_protocol = ip_tunnel_parse_protocol };\nEXPORT_SYMBOL(ip_tunnel_header_ops);\n\n \nbool ip_tunnel_netlink_encap_parms(struct nlattr *data[],\n\t\t\t\t   struct ip_tunnel_encap *encap)\n{\n\tbool ret = false;\n\n\tmemset(encap, 0, sizeof(*encap));\n\n\tif (!data)\n\t\treturn ret;\n\n\tif (data[IFLA_IPTUN_ENCAP_TYPE]) {\n\t\tret = true;\n\t\tencap->type = nla_get_u16(data[IFLA_IPTUN_ENCAP_TYPE]);\n\t}\n\n\tif (data[IFLA_IPTUN_ENCAP_FLAGS]) {\n\t\tret = true;\n\t\tencap->flags = nla_get_u16(data[IFLA_IPTUN_ENCAP_FLAGS]);\n\t}\n\n\tif (data[IFLA_IPTUN_ENCAP_SPORT]) {\n\t\tret = true;\n\t\tencap->sport = nla_get_be16(data[IFLA_IPTUN_ENCAP_SPORT]);\n\t}\n\n\tif (data[IFLA_IPTUN_ENCAP_DPORT]) {\n\t\tret = true;\n\t\tencap->dport = nla_get_be16(data[IFLA_IPTUN_ENCAP_DPORT]);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_netlink_encap_parms);\n\nvoid ip_tunnel_netlink_parms(struct nlattr *data[],\n\t\t\t     struct ip_tunnel_parm *parms)\n{\n\tif (data[IFLA_IPTUN_LINK])\n\t\tparms->link = nla_get_u32(data[IFLA_IPTUN_LINK]);\n\n\tif (data[IFLA_IPTUN_LOCAL])\n\t\tparms->iph.saddr = nla_get_be32(data[IFLA_IPTUN_LOCAL]);\n\n\tif (data[IFLA_IPTUN_REMOTE])\n\t\tparms->iph.daddr = nla_get_be32(data[IFLA_IPTUN_REMOTE]);\n\n\tif (data[IFLA_IPTUN_TTL]) {\n\t\tparms->iph.ttl = nla_get_u8(data[IFLA_IPTUN_TTL]);\n\t\tif (parms->iph.ttl)\n\t\t\tparms->iph.frag_off = htons(IP_DF);\n\t}\n\n\tif (data[IFLA_IPTUN_TOS])\n\t\tparms->iph.tos = nla_get_u8(data[IFLA_IPTUN_TOS]);\n\n\tif (!data[IFLA_IPTUN_PMTUDISC] || nla_get_u8(data[IFLA_IPTUN_PMTUDISC]))\n\t\tparms->iph.frag_off = htons(IP_DF);\n\n\tif (data[IFLA_IPTUN_FLAGS])\n\t\tparms->i_flags = nla_get_be16(data[IFLA_IPTUN_FLAGS]);\n\n\tif (data[IFLA_IPTUN_PROTO])\n\t\tparms->iph.protocol = nla_get_u8(data[IFLA_IPTUN_PROTO]);\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_netlink_parms);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}