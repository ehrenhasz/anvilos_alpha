{
  "module_name": "ip_tunnel.c",
  "hash_id": "983292e19d5384cc6bbc62defe0c1d37b4a8a2a335d70242a8645d41e792fe89",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ip_tunnel.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/in6.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/rculist.h>\n#include <linux/err.h>\n\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/protocol.h>\n#include <net/ip_tunnels.h>\n#include <net/arp.h>\n#include <net/checksum.h>\n#include <net/dsfield.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/rtnetlink.h>\n#include <net/udp.h>\n#include <net/dst_metadata.h>\n\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n#endif\n\nstatic unsigned int ip_tunnel_hash(__be32 key, __be32 remote)\n{\n\treturn hash_32((__force u32)key ^ (__force u32)remote,\n\t\t\t IP_TNL_HASH_BITS);\n}\n\nstatic bool ip_tunnel_key_match(const struct ip_tunnel_parm *p,\n\t\t\t\t__be16 flags, __be32 key)\n{\n\tif (p->i_flags & TUNNEL_KEY) {\n\t\tif (flags & TUNNEL_KEY)\n\t\t\treturn key == p->i_key;\n\t\telse\n\t\t\t \n\t\t\treturn false;\n\t} else\n\t\treturn !(flags & TUNNEL_KEY);\n}\n\n \nstruct ip_tunnel *ip_tunnel_lookup(struct ip_tunnel_net *itn,\n\t\t\t\t   int link, __be16 flags,\n\t\t\t\t   __be32 remote, __be32 local,\n\t\t\t\t   __be32 key)\n{\n\tstruct ip_tunnel *t, *cand = NULL;\n\tstruct hlist_head *head;\n\tstruct net_device *ndev;\n\tunsigned int hash;\n\n\thash = ip_tunnel_hash(key, remote);\n\thead = &itn->tunnels[hash];\n\n\thlist_for_each_entry_rcu(t, head, hash_node) {\n\t\tif (local != t->parms.iph.saddr ||\n\t\t    remote != t->parms.iph.daddr ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (!ip_tunnel_key_match(&t->parms, flags, key))\n\t\t\tcontinue;\n\n\t\tif (t->parms.link == link)\n\t\t\treturn t;\n\t\telse\n\t\t\tcand = t;\n\t}\n\n\thlist_for_each_entry_rcu(t, head, hash_node) {\n\t\tif (remote != t->parms.iph.daddr ||\n\t\t    t->parms.iph.saddr != 0 ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (!ip_tunnel_key_match(&t->parms, flags, key))\n\t\t\tcontinue;\n\n\t\tif (t->parms.link == link)\n\t\t\treturn t;\n\t\telse if (!cand)\n\t\t\tcand = t;\n\t}\n\n\thash = ip_tunnel_hash(key, 0);\n\thead = &itn->tunnels[hash];\n\n\thlist_for_each_entry_rcu(t, head, hash_node) {\n\t\tif ((local != t->parms.iph.saddr || t->parms.iph.daddr != 0) &&\n\t\t    (local != t->parms.iph.daddr || !ipv4_is_multicast(local)))\n\t\t\tcontinue;\n\n\t\tif (!(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (!ip_tunnel_key_match(&t->parms, flags, key))\n\t\t\tcontinue;\n\n\t\tif (t->parms.link == link)\n\t\t\treturn t;\n\t\telse if (!cand)\n\t\t\tcand = t;\n\t}\n\n\thlist_for_each_entry_rcu(t, head, hash_node) {\n\t\tif ((!(flags & TUNNEL_NO_KEY) && t->parms.i_key != key) ||\n\t\t    t->parms.iph.saddr != 0 ||\n\t\t    t->parms.iph.daddr != 0 ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->parms.link == link)\n\t\t\treturn t;\n\t\telse if (!cand)\n\t\t\tcand = t;\n\t}\n\n\tif (cand)\n\t\treturn cand;\n\n\tt = rcu_dereference(itn->collect_md_tun);\n\tif (t && t->dev->flags & IFF_UP)\n\t\treturn t;\n\n\tndev = READ_ONCE(itn->fb_tunnel_dev);\n\tif (ndev && ndev->flags & IFF_UP)\n\t\treturn netdev_priv(ndev);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_lookup);\n\nstatic struct hlist_head *ip_bucket(struct ip_tunnel_net *itn,\n\t\t\t\t    struct ip_tunnel_parm *parms)\n{\n\tunsigned int h;\n\t__be32 remote;\n\t__be32 i_key = parms->i_key;\n\n\tif (parms->iph.daddr && !ipv4_is_multicast(parms->iph.daddr))\n\t\tremote = parms->iph.daddr;\n\telse\n\t\tremote = 0;\n\n\tif (!(parms->i_flags & TUNNEL_KEY) && (parms->i_flags & VTI_ISVTI))\n\t\ti_key = 0;\n\n\th = ip_tunnel_hash(i_key, remote);\n\treturn &itn->tunnels[h];\n}\n\nstatic void ip_tunnel_add(struct ip_tunnel_net *itn, struct ip_tunnel *t)\n{\n\tstruct hlist_head *head = ip_bucket(itn, &t->parms);\n\n\tif (t->collect_md)\n\t\trcu_assign_pointer(itn->collect_md_tun, t);\n\thlist_add_head_rcu(&t->hash_node, head);\n}\n\nstatic void ip_tunnel_del(struct ip_tunnel_net *itn, struct ip_tunnel *t)\n{\n\tif (t->collect_md)\n\t\trcu_assign_pointer(itn->collect_md_tun, NULL);\n\thlist_del_init_rcu(&t->hash_node);\n}\n\nstatic struct ip_tunnel *ip_tunnel_find(struct ip_tunnel_net *itn,\n\t\t\t\t\tstruct ip_tunnel_parm *parms,\n\t\t\t\t\tint type)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\t__be32 key = parms->i_key;\n\t__be16 flags = parms->i_flags;\n\tint link = parms->link;\n\tstruct ip_tunnel *t = NULL;\n\tstruct hlist_head *head = ip_bucket(itn, parms);\n\n\thlist_for_each_entry_rcu(t, head, hash_node) {\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr &&\n\t\t    link == t->parms.link &&\n\t\t    type == t->dev->type &&\n\t\t    ip_tunnel_key_match(&t->parms, flags, key))\n\t\t\tbreak;\n\t}\n\treturn t;\n}\n\nstatic struct net_device *__ip_tunnel_create(struct net *net,\n\t\t\t\t\t     const struct rtnl_link_ops *ops,\n\t\t\t\t\t     struct ip_tunnel_parm *parms)\n{\n\tint err;\n\tstruct ip_tunnel *tunnel;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\n\terr = -E2BIG;\n\tif (parms->name[0]) {\n\t\tif (!dev_valid_name(parms->name))\n\t\t\tgoto failed;\n\t\tstrscpy(name, parms->name, IFNAMSIZ);\n\t} else {\n\t\tif (strlen(ops->kind) > (IFNAMSIZ - 3))\n\t\t\tgoto failed;\n\t\tstrcpy(name, ops->kind);\n\t\tstrcat(name, \"%d\");\n\t}\n\n\tASSERT_RTNL();\n\tdev = alloc_netdev(ops->priv_size, name, NET_NAME_UNKNOWN, ops->setup);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\tdev_net_set(dev, net);\n\n\tdev->rtnl_link_ops = ops;\n\n\ttunnel = netdev_priv(dev);\n\ttunnel->parms = *parms;\n\ttunnel->net = net;\n\n\terr = register_netdevice(dev);\n\tif (err)\n\t\tgoto failed_free;\n\n\treturn dev;\n\nfailed_free:\n\tfree_netdev(dev);\nfailed:\n\treturn ERR_PTR(err);\n}\n\nstatic int ip_tunnel_bind_dev(struct net_device *dev)\n{\n\tstruct net_device *tdev = NULL;\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tconst struct iphdr *iph;\n\tint hlen = LL_MAX_HEADER;\n\tint mtu = ETH_DATA_LEN;\n\tint t_hlen = tunnel->hlen + sizeof(struct iphdr);\n\n\tiph = &tunnel->parms.iph;\n\n\t \n\tif (iph->daddr) {\n\t\tstruct flowi4 fl4;\n\t\tstruct rtable *rt;\n\n\t\tip_tunnel_init_flow(&fl4, iph->protocol, iph->daddr,\n\t\t\t\t    iph->saddr, tunnel->parms.o_key,\n\t\t\t\t    RT_TOS(iph->tos), dev_net(dev),\n\t\t\t\t    tunnel->parms.link, tunnel->fwmark, 0, 0);\n\t\trt = ip_route_output_key(tunnel->net, &fl4);\n\n\t\tif (!IS_ERR(rt)) {\n\t\t\ttdev = rt->dst.dev;\n\t\t\tip_rt_put(rt);\n\t\t}\n\t\tif (dev->type != ARPHRD_ETHER)\n\t\t\tdev->flags |= IFF_POINTOPOINT;\n\n\t\tdst_cache_reset(&tunnel->dst_cache);\n\t}\n\n\tif (!tdev && tunnel->parms.link)\n\t\ttdev = __dev_get_by_index(tunnel->net, tunnel->parms.link);\n\n\tif (tdev) {\n\t\thlen = tdev->hard_header_len + tdev->needed_headroom;\n\t\tmtu = min(tdev->mtu, IP_MAX_MTU);\n\t}\n\n\tdev->needed_headroom = t_hlen + hlen;\n\tmtu -= t_hlen + (dev->type == ARPHRD_ETHER ? dev->hard_header_len : 0);\n\n\tif (mtu < IPV4_MIN_MTU)\n\t\tmtu = IPV4_MIN_MTU;\n\n\treturn mtu;\n}\n\nstatic struct ip_tunnel *ip_tunnel_create(struct net *net,\n\t\t\t\t\t  struct ip_tunnel_net *itn,\n\t\t\t\t\t  struct ip_tunnel_parm *parms)\n{\n\tstruct ip_tunnel *nt;\n\tstruct net_device *dev;\n\tint t_hlen;\n\tint mtu;\n\tint err;\n\n\tdev = __ip_tunnel_create(net, itn->rtnl_link_ops, parms);\n\tif (IS_ERR(dev))\n\t\treturn ERR_CAST(dev);\n\n\tmtu = ip_tunnel_bind_dev(dev);\n\terr = dev_set_mtu(dev, mtu);\n\tif (err)\n\t\tgoto err_dev_set_mtu;\n\n\tnt = netdev_priv(dev);\n\tt_hlen = nt->hlen + sizeof(struct iphdr);\n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = IP_MAX_MTU - t_hlen;\n\tif (dev->type == ARPHRD_ETHER)\n\t\tdev->max_mtu -= dev->hard_header_len;\n\n\tip_tunnel_add(itn, nt);\n\treturn nt;\n\nerr_dev_set_mtu:\n\tunregister_netdevice(dev);\n\treturn ERR_PTR(err);\n}\n\nvoid ip_tunnel_md_udp_encap(struct sk_buff *skb, struct ip_tunnel_info *info)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tconst struct udphdr *udph;\n\n\tif (iph->protocol != IPPROTO_UDP)\n\t\treturn;\n\n\tudph = (struct udphdr *)((__u8 *)iph + (iph->ihl << 2));\n\tinfo->encap.sport = udph->source;\n\tinfo->encap.dport = udph->dest;\n}\nEXPORT_SYMBOL(ip_tunnel_md_udp_encap);\n\nint ip_tunnel_rcv(struct ip_tunnel *tunnel, struct sk_buff *skb,\n\t\t  const struct tnl_ptk_info *tpi, struct metadata_dst *tun_dst,\n\t\t  bool log_ecn_error)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tint err;\n\n#ifdef CONFIG_NET_IPGRE_BROADCAST\n\tif (ipv4_is_multicast(iph->daddr)) {\n\t\tDEV_STATS_INC(tunnel->dev, multicast);\n\t\tskb->pkt_type = PACKET_BROADCAST;\n\t}\n#endif\n\n\tif ((!(tpi->flags&TUNNEL_CSUM) &&  (tunnel->parms.i_flags&TUNNEL_CSUM)) ||\n\t     ((tpi->flags&TUNNEL_CSUM) && !(tunnel->parms.i_flags&TUNNEL_CSUM))) {\n\t\tDEV_STATS_INC(tunnel->dev, rx_crc_errors);\n\t\tDEV_STATS_INC(tunnel->dev, rx_errors);\n\t\tgoto drop;\n\t}\n\n\tif (tunnel->parms.i_flags&TUNNEL_SEQ) {\n\t\tif (!(tpi->flags&TUNNEL_SEQ) ||\n\t\t    (tunnel->i_seqno && (s32)(ntohl(tpi->seq) - tunnel->i_seqno) < 0)) {\n\t\t\tDEV_STATS_INC(tunnel->dev, rx_fifo_errors);\n\t\t\tDEV_STATS_INC(tunnel->dev, rx_errors);\n\t\t\tgoto drop;\n\t\t}\n\t\ttunnel->i_seqno = ntohl(tpi->seq) + 1;\n\t}\n\n\tskb_set_network_header(skb, (tunnel->dev->type == ARPHRD_ETHER) ? ETH_HLEN : 0);\n\n\terr = IP_ECN_decapsulate(iph, skb);\n\tif (unlikely(err)) {\n\t\tif (log_ecn_error)\n\t\t\tnet_info_ratelimited(\"non-ECT from %pI4 with TOS=%#x\\n\",\n\t\t\t\t\t&iph->saddr, iph->tos);\n\t\tif (err > 1) {\n\t\t\tDEV_STATS_INC(tunnel->dev, rx_frame_errors);\n\t\t\tDEV_STATS_INC(tunnel->dev, rx_errors);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tdev_sw_netstats_rx_add(tunnel->dev, skb->len);\n\tskb_scrub_packet(skb, !net_eq(tunnel->net, dev_net(tunnel->dev)));\n\n\tif (tunnel->dev->type == ARPHRD_ETHER) {\n\t\tskb->protocol = eth_type_trans(skb, tunnel->dev);\n\t\tskb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);\n\t} else {\n\t\tskb->dev = tunnel->dev;\n\t}\n\n\tif (tun_dst)\n\t\tskb_dst_set(skb, (struct dst_entry *)tun_dst);\n\n\tgro_cells_receive(&tunnel->gro_cells, skb);\n\treturn 0;\n\ndrop:\n\tif (tun_dst)\n\t\tdst_release((struct dst_entry *)tun_dst);\n\tkfree_skb(skb);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_rcv);\n\nint ip_tunnel_encap_add_ops(const struct ip_tunnel_encap_ops *ops,\n\t\t\t    unsigned int num)\n{\n\tif (num >= MAX_IPTUN_ENCAP_OPS)\n\t\treturn -ERANGE;\n\n\treturn !cmpxchg((const struct ip_tunnel_encap_ops **)\n\t\t\t&iptun_encaps[num],\n\t\t\tNULL, ops) ? 0 : -1;\n}\nEXPORT_SYMBOL(ip_tunnel_encap_add_ops);\n\nint ip_tunnel_encap_del_ops(const struct ip_tunnel_encap_ops *ops,\n\t\t\t    unsigned int num)\n{\n\tint ret;\n\n\tif (num >= MAX_IPTUN_ENCAP_OPS)\n\t\treturn -ERANGE;\n\n\tret = (cmpxchg((const struct ip_tunnel_encap_ops **)\n\t\t       &iptun_encaps[num],\n\t\t       ops, NULL) == ops) ? 0 : -1;\n\n\tsynchronize_net();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ip_tunnel_encap_del_ops);\n\nint ip_tunnel_encap_setup(struct ip_tunnel *t,\n\t\t\t  struct ip_tunnel_encap *ipencap)\n{\n\tint hlen;\n\n\tmemset(&t->encap, 0, sizeof(t->encap));\n\n\thlen = ip_encap_hlen(ipencap);\n\tif (hlen < 0)\n\t\treturn hlen;\n\n\tt->encap.type = ipencap->type;\n\tt->encap.sport = ipencap->sport;\n\tt->encap.dport = ipencap->dport;\n\tt->encap.flags = ipencap->flags;\n\n\tt->encap_hlen = hlen;\n\tt->hlen = t->encap_hlen + t->tun_hlen;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_encap_setup);\n\nstatic int tnl_update_pmtu(struct net_device *dev, struct sk_buff *skb,\n\t\t\t    struct rtable *rt, __be16 df,\n\t\t\t    const struct iphdr *inner_iph,\n\t\t\t    int tunnel_hlen, __be32 dst, bool md)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tint pkt_size;\n\tint mtu;\n\n\ttunnel_hlen = md ? tunnel_hlen : tunnel->hlen;\n\tpkt_size = skb->len - tunnel_hlen;\n\tpkt_size -= dev->type == ARPHRD_ETHER ? dev->hard_header_len : 0;\n\n\tif (df) {\n\t\tmtu = dst_mtu(&rt->dst) - (sizeof(struct iphdr) + tunnel_hlen);\n\t\tmtu -= dev->type == ARPHRD_ETHER ? dev->hard_header_len : 0;\n\t} else {\n\t\tmtu = skb_valid_dst(skb) ? dst_mtu(skb_dst(skb)) : dev->mtu;\n\t}\n\n\tif (skb_valid_dst(skb))\n\t\tskb_dst_update_pmtu_no_confirm(skb, mtu);\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tif (!skb_is_gso(skb) &&\n\t\t    (inner_iph->frag_off & htons(IP_DF)) &&\n\t\t    mtu < pkt_size) {\n\t\t\ticmp_ndo_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, htonl(mtu));\n\t\t\treturn -E2BIG;\n\t\t}\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tstruct rt6_info *rt6;\n\t\t__be32 daddr;\n\n\t\trt6 = skb_valid_dst(skb) ? (struct rt6_info *)skb_dst(skb) :\n\t\t\t\t\t   NULL;\n\t\tdaddr = md ? dst : tunnel->parms.iph.daddr;\n\n\t\tif (rt6 && mtu < dst_mtu(skb_dst(skb)) &&\n\t\t\t   mtu >= IPV6_MIN_MTU) {\n\t\t\tif ((daddr && !ipv4_is_multicast(daddr)) ||\n\t\t\t    rt6->rt6i_dst.plen == 128) {\n\t\t\t\trt6->rt6i_flags |= RTF_MODIFIED;\n\t\t\t\tdst_metric_set(skb_dst(skb), RTAX_MTU, mtu);\n\t\t\t}\n\t\t}\n\n\t\tif (!skb_is_gso(skb) && mtu >= IPV6_MIN_MTU &&\n\t\t\t\t\tmtu < pkt_size) {\n\t\t\ticmpv6_ndo_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\t\treturn -E2BIG;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\nvoid ip_md_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t       u8 proto, int tunnel_hlen)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tu32 headroom = sizeof(struct iphdr);\n\tstruct ip_tunnel_info *tun_info;\n\tconst struct ip_tunnel_key *key;\n\tconst struct iphdr *inner_iph;\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\t__be16 df = 0;\n\tu8 tos, ttl;\n\tbool use_cache;\n\n\ttun_info = skb_tunnel_info(skb);\n\tif (unlikely(!tun_info || !(tun_info->mode & IP_TUNNEL_INFO_TX) ||\n\t\t     ip_tunnel_info_af(tun_info) != AF_INET))\n\t\tgoto tx_error;\n\tkey = &tun_info->key;\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\tinner_iph = (const struct iphdr *)skb_inner_network_header(skb);\n\ttos = key->tos;\n\tif (tos == 1) {\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\ttos = inner_iph->tos;\n\t\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\t\ttos = ipv6_get_dsfield((const struct ipv6hdr *)inner_iph);\n\t}\n\tip_tunnel_init_flow(&fl4, proto, key->u.ipv4.dst, key->u.ipv4.src,\n\t\t\t    tunnel_id_to_key32(key->tun_id), RT_TOS(tos),\n\t\t\t    dev_net(dev), 0, skb->mark, skb_get_hash(skb),\n\t\t\t    key->flow_flags);\n\n\tif (!tunnel_hlen)\n\t\ttunnel_hlen = ip_encap_hlen(&tun_info->encap);\n\n\tif (ip_tunnel_encap(skb, &tun_info->encap, &proto, &fl4) < 0)\n\t\tgoto tx_error;\n\n\tuse_cache = ip_tunnel_dst_cache_usable(skb, tun_info);\n\tif (use_cache)\n\t\trt = dst_cache_get_ip4(&tun_info->dst_cache, &fl4.saddr);\n\tif (!rt) {\n\t\trt = ip_route_output_key(tunnel->net, &fl4);\n\t\tif (IS_ERR(rt)) {\n\t\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\t\tgoto tx_error;\n\t\t}\n\t\tif (use_cache)\n\t\t\tdst_cache_set_ip4(&tun_info->dst_cache, &rt->dst,\n\t\t\t\t\t  fl4.saddr);\n\t}\n\tif (rt->dst.dev == dev) {\n\t\tip_rt_put(rt);\n\t\tDEV_STATS_INC(dev, collisions);\n\t\tgoto tx_error;\n\t}\n\n\tif (key->tun_flags & TUNNEL_DONT_FRAGMENT)\n\t\tdf = htons(IP_DF);\n\tif (tnl_update_pmtu(dev, skb, rt, df, inner_iph, tunnel_hlen,\n\t\t\t    key->u.ipv4.dst, true)) {\n\t\tip_rt_put(rt);\n\t\tgoto tx_error;\n\t}\n\n\ttos = ip_tunnel_ecn_encap(tos, inner_iph, skb);\n\tttl = key->ttl;\n\tif (ttl == 0) {\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tttl = inner_iph->ttl;\n\t\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\t\tttl = ((const struct ipv6hdr *)inner_iph)->hop_limit;\n\t\telse\n\t\t\tttl = ip4_dst_hoplimit(&rt->dst);\n\t}\n\n\theadroom += LL_RESERVED_SPACE(rt->dst.dev) + rt->dst.header_len;\n\tif (headroom > READ_ONCE(dev->needed_headroom))\n\t\tWRITE_ONCE(dev->needed_headroom, headroom);\n\n\tif (skb_cow_head(skb, READ_ONCE(dev->needed_headroom))) {\n\t\tip_rt_put(rt);\n\t\tgoto tx_dropped;\n\t}\n\tiptunnel_xmit(NULL, rt, skb, fl4.saddr, fl4.daddr, proto, tos, ttl,\n\t\t      df, !net_eq(tunnel->net, dev_net(dev)));\n\treturn;\ntx_error:\n\tDEV_STATS_INC(dev, tx_errors);\n\tgoto kfree;\ntx_dropped:\n\tDEV_STATS_INC(dev, tx_dropped);\nkfree:\n\tkfree_skb(skb);\n}\nEXPORT_SYMBOL_GPL(ip_md_tunnel_xmit);\n\nvoid ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t    const struct iphdr *tnl_params, u8 protocol)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct ip_tunnel_info *tun_info = NULL;\n\tconst struct iphdr *inner_iph;\n\tunsigned int max_headroom;\t \n\tstruct rtable *rt = NULL;\t\t \n\t__be16 payload_protocol;\n\tbool use_cache = false;\n\tstruct flowi4 fl4;\n\tbool md = false;\n\tbool connected;\n\tu8 tos, ttl;\n\t__be32 dst;\n\t__be16 df;\n\n\tinner_iph = (const struct iphdr *)skb_inner_network_header(skb);\n\tconnected = (tunnel->parms.iph.daddr != 0);\n\tpayload_protocol = skb_protocol(skb, true);\n\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\n\tdst = tnl_params->daddr;\n\tif (dst == 0) {\n\t\t \n\n\t\tif (!skb_dst(skb)) {\n\t\t\tDEV_STATS_INC(dev, tx_fifo_errors);\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\ttun_info = skb_tunnel_info(skb);\n\t\tif (tun_info && (tun_info->mode & IP_TUNNEL_INFO_TX) &&\n\t\t    ip_tunnel_info_af(tun_info) == AF_INET &&\n\t\t    tun_info->key.u.ipv4.dst) {\n\t\t\tdst = tun_info->key.u.ipv4.dst;\n\t\t\tmd = true;\n\t\t\tconnected = true;\n\t\t} else if (payload_protocol == htons(ETH_P_IP)) {\n\t\t\trt = skb_rtable(skb);\n\t\t\tdst = rt_nexthop(rt, inner_iph->daddr);\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse if (payload_protocol == htons(ETH_P_IPV6)) {\n\t\t\tconst struct in6_addr *addr6;\n\t\t\tstruct neighbour *neigh;\n\t\t\tbool do_tx_error_icmp;\n\t\t\tint addr_type;\n\n\t\t\tneigh = dst_neigh_lookup(skb_dst(skb),\n\t\t\t\t\t\t &ipv6_hdr(skb)->daddr);\n\t\t\tif (!neigh)\n\t\t\t\tgoto tx_error;\n\n\t\t\taddr6 = (const struct in6_addr *)&neigh->primary_key;\n\t\t\taddr_type = ipv6_addr_type(addr6);\n\n\t\t\tif (addr_type == IPV6_ADDR_ANY) {\n\t\t\t\taddr6 = &ipv6_hdr(skb)->daddr;\n\t\t\t\taddr_type = ipv6_addr_type(addr6);\n\t\t\t}\n\n\t\t\tif ((addr_type & IPV6_ADDR_COMPATv4) == 0)\n\t\t\t\tdo_tx_error_icmp = true;\n\t\t\telse {\n\t\t\t\tdo_tx_error_icmp = false;\n\t\t\t\tdst = addr6->s6_addr32[3];\n\t\t\t}\n\t\t\tneigh_release(neigh);\n\t\t\tif (do_tx_error_icmp)\n\t\t\t\tgoto tx_error_icmp;\n\t\t}\n#endif\n\t\telse\n\t\t\tgoto tx_error;\n\n\t\tif (!md)\n\t\t\tconnected = false;\n\t}\n\n\ttos = tnl_params->tos;\n\tif (tos & 0x1) {\n\t\ttos &= ~0x1;\n\t\tif (payload_protocol == htons(ETH_P_IP)) {\n\t\t\ttos = inner_iph->tos;\n\t\t\tconnected = false;\n\t\t} else if (payload_protocol == htons(ETH_P_IPV6)) {\n\t\t\ttos = ipv6_get_dsfield((const struct ipv6hdr *)inner_iph);\n\t\t\tconnected = false;\n\t\t}\n\t}\n\n\tip_tunnel_init_flow(&fl4, protocol, dst, tnl_params->saddr,\n\t\t\t    tunnel->parms.o_key, RT_TOS(tos),\n\t\t\t    dev_net(dev), tunnel->parms.link,\n\t\t\t    tunnel->fwmark, skb_get_hash(skb), 0);\n\n\tif (ip_tunnel_encap(skb, &tunnel->encap, &protocol, &fl4) < 0)\n\t\tgoto tx_error;\n\n\tif (connected && md) {\n\t\tuse_cache = ip_tunnel_dst_cache_usable(skb, tun_info);\n\t\tif (use_cache)\n\t\t\trt = dst_cache_get_ip4(&tun_info->dst_cache,\n\t\t\t\t\t       &fl4.saddr);\n\t} else {\n\t\trt = connected ? dst_cache_get_ip4(&tunnel->dst_cache,\n\t\t\t\t\t\t&fl4.saddr) : NULL;\n\t}\n\n\tif (!rt) {\n\t\trt = ip_route_output_key(tunnel->net, &fl4);\n\n\t\tif (IS_ERR(rt)) {\n\t\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\t\tgoto tx_error;\n\t\t}\n\t\tif (use_cache)\n\t\t\tdst_cache_set_ip4(&tun_info->dst_cache, &rt->dst,\n\t\t\t\t\t  fl4.saddr);\n\t\telse if (!md && connected)\n\t\t\tdst_cache_set_ip4(&tunnel->dst_cache, &rt->dst,\n\t\t\t\t\t  fl4.saddr);\n\t}\n\n\tif (rt->dst.dev == dev) {\n\t\tip_rt_put(rt);\n\t\tDEV_STATS_INC(dev, collisions);\n\t\tgoto tx_error;\n\t}\n\n\tdf = tnl_params->frag_off;\n\tif (payload_protocol == htons(ETH_P_IP) && !tunnel->ignore_df)\n\t\tdf |= (inner_iph->frag_off & htons(IP_DF));\n\n\tif (tnl_update_pmtu(dev, skb, rt, df, inner_iph, 0, 0, false)) {\n\t\tip_rt_put(rt);\n\t\tgoto tx_error;\n\t}\n\n\tif (tunnel->err_count > 0) {\n\t\tif (time_before(jiffies,\n\t\t\t\ttunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\n\t\t\ttunnel->err_count--;\n\n\t\t\tdst_link_failure(skb);\n\t\t} else\n\t\t\ttunnel->err_count = 0;\n\t}\n\n\ttos = ip_tunnel_ecn_encap(tos, inner_iph, skb);\n\tttl = tnl_params->ttl;\n\tif (ttl == 0) {\n\t\tif (payload_protocol == htons(ETH_P_IP))\n\t\t\tttl = inner_iph->ttl;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse if (payload_protocol == htons(ETH_P_IPV6))\n\t\t\tttl = ((const struct ipv6hdr *)inner_iph)->hop_limit;\n#endif\n\t\telse\n\t\t\tttl = ip4_dst_hoplimit(&rt->dst);\n\t}\n\n\tmax_headroom = LL_RESERVED_SPACE(rt->dst.dev) + sizeof(struct iphdr)\n\t\t\t+ rt->dst.header_len + ip_encap_hlen(&tunnel->encap);\n\tif (max_headroom > READ_ONCE(dev->needed_headroom))\n\t\tWRITE_ONCE(dev->needed_headroom, max_headroom);\n\n\tif (skb_cow_head(skb, READ_ONCE(dev->needed_headroom))) {\n\t\tip_rt_put(rt);\n\t\tDEV_STATS_INC(dev, tx_dropped);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tiptunnel_xmit(NULL, rt, skb, fl4.saddr, fl4.daddr, protocol, tos, ttl,\n\t\t      df, !net_eq(tunnel->net, dev_net(dev)));\n\treturn;\n\n#if IS_ENABLED(CONFIG_IPV6)\ntx_error_icmp:\n\tdst_link_failure(skb);\n#endif\ntx_error:\n\tDEV_STATS_INC(dev, tx_errors);\n\tkfree_skb(skb);\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_xmit);\n\nstatic void ip_tunnel_update(struct ip_tunnel_net *itn,\n\t\t\t     struct ip_tunnel *t,\n\t\t\t     struct net_device *dev,\n\t\t\t     struct ip_tunnel_parm *p,\n\t\t\t     bool set_mtu,\n\t\t\t     __u32 fwmark)\n{\n\tip_tunnel_del(itn, t);\n\tt->parms.iph.saddr = p->iph.saddr;\n\tt->parms.iph.daddr = p->iph.daddr;\n\tt->parms.i_key = p->i_key;\n\tt->parms.o_key = p->o_key;\n\tif (dev->type != ARPHRD_ETHER) {\n\t\t__dev_addr_set(dev, &p->iph.saddr, 4);\n\t\tmemcpy(dev->broadcast, &p->iph.daddr, 4);\n\t}\n\tip_tunnel_add(itn, t);\n\n\tt->parms.iph.ttl = p->iph.ttl;\n\tt->parms.iph.tos = p->iph.tos;\n\tt->parms.iph.frag_off = p->iph.frag_off;\n\n\tif (t->parms.link != p->link || t->fwmark != fwmark) {\n\t\tint mtu;\n\n\t\tt->parms.link = p->link;\n\t\tt->fwmark = fwmark;\n\t\tmtu = ip_tunnel_bind_dev(dev);\n\t\tif (set_mtu)\n\t\t\tdev->mtu = mtu;\n\t}\n\tdst_cache_reset(&t->dst_cache);\n\tnetdev_state_change(dev);\n}\n\nint ip_tunnel_ctl(struct net_device *dev, struct ip_tunnel_parm *p, int cmd)\n{\n\tint err = 0;\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct net *net = t->net;\n\tstruct ip_tunnel_net *itn = net_generic(net, t->ip_tnl_net_id);\n\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n\t\tif (dev == itn->fb_tunnel_dev) {\n\t\t\tt = ip_tunnel_find(itn, p, itn->fb_tunnel_dev->type);\n\t\t\tif (!t)\n\t\t\t\tt = netdev_priv(dev);\n\t\t}\n\t\tmemcpy(p, &t->parms, sizeof(*p));\n\t\tbreak;\n\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto done;\n\t\tif (p->iph.ttl)\n\t\t\tp->iph.frag_off |= htons(IP_DF);\n\t\tif (!(p->i_flags & VTI_ISVTI)) {\n\t\t\tif (!(p->i_flags & TUNNEL_KEY))\n\t\t\t\tp->i_key = 0;\n\t\t\tif (!(p->o_flags & TUNNEL_KEY))\n\t\t\t\tp->o_key = 0;\n\t\t}\n\n\t\tt = ip_tunnel_find(itn, p, itn->type);\n\n\t\tif (cmd == SIOCADDTUNNEL) {\n\t\t\tif (!t) {\n\t\t\t\tt = ip_tunnel_create(net, itn, p);\n\t\t\t\terr = PTR_ERR_OR_ZERO(t);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\t\tif (dev != itn->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {\n\t\t\tif (t) {\n\t\t\t\tif (t->dev != dev) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunsigned int nflags = 0;\n\n\t\t\t\tif (ipv4_is_multicast(p->iph.daddr))\n\t\t\t\t\tnflags = IFF_BROADCAST;\n\t\t\t\telse if (p->iph.daddr)\n\t\t\t\t\tnflags = IFF_POINTOPOINT;\n\n\t\t\t\tif ((dev->flags^nflags)&(IFF_POINTOPOINT|IFF_BROADCAST)) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tt = netdev_priv(dev);\n\t\t\t}\n\t\t}\n\n\t\tif (t) {\n\t\t\terr = 0;\n\t\t\tip_tunnel_update(itn, t, dev, p, true, 0);\n\t\t} else {\n\t\t\terr = -ENOENT;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCDELTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\tif (dev == itn->fb_tunnel_dev) {\n\t\t\terr = -ENOENT;\n\t\t\tt = ip_tunnel_find(itn, p, itn->fb_tunnel_dev->type);\n\t\t\tif (!t)\n\t\t\t\tgoto done;\n\t\t\terr = -EPERM;\n\t\t\tif (t == netdev_priv(itn->fb_tunnel_dev))\n\t\t\t\tgoto done;\n\t\t\tdev = t->dev;\n\t\t}\n\t\tunregister_netdevice(dev);\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\ndone:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_ctl);\n\nint ip_tunnel_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t     void __user *data, int cmd)\n{\n\tstruct ip_tunnel_parm p;\n\tint err;\n\n\tif (copy_from_user(&p, data, sizeof(p)))\n\t\treturn -EFAULT;\n\terr = dev->netdev_ops->ndo_tunnel_ctl(dev, &p, cmd);\n\tif (!err && copy_to_user(data, &p, sizeof(p)))\n\t\treturn -EFAULT;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_siocdevprivate);\n\nint __ip_tunnel_change_mtu(struct net_device *dev, int new_mtu, bool strict)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tint t_hlen = tunnel->hlen + sizeof(struct iphdr);\n\tint max_mtu = IP_MAX_MTU - t_hlen;\n\n\tif (dev->type == ARPHRD_ETHER)\n\t\tmax_mtu -= dev->hard_header_len;\n\n\tif (new_mtu < ETH_MIN_MTU)\n\t\treturn -EINVAL;\n\n\tif (new_mtu > max_mtu) {\n\t\tif (strict)\n\t\t\treturn -EINVAL;\n\n\t\tnew_mtu = max_mtu;\n\t}\n\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__ip_tunnel_change_mtu);\n\nint ip_tunnel_change_mtu(struct net_device *dev, int new_mtu)\n{\n\treturn __ip_tunnel_change_mtu(dev, new_mtu, true);\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_change_mtu);\n\nstatic void ip_tunnel_dev_free(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\n\tgro_cells_destroy(&tunnel->gro_cells);\n\tdst_cache_destroy(&tunnel->dst_cache);\n\tfree_percpu(dev->tstats);\n}\n\nvoid ip_tunnel_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct ip_tunnel_net *itn;\n\n\titn = net_generic(tunnel->net, tunnel->ip_tnl_net_id);\n\n\tif (itn->fb_tunnel_dev != dev) {\n\t\tip_tunnel_del(itn, netdev_priv(dev));\n\t\tunregister_netdevice_queue(dev, head);\n\t}\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_dellink);\n\nstruct net *ip_tunnel_get_link_net(const struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\n\treturn tunnel->net;\n}\nEXPORT_SYMBOL(ip_tunnel_get_link_net);\n\nint ip_tunnel_get_iflink(const struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\n\treturn tunnel->parms.link;\n}\nEXPORT_SYMBOL(ip_tunnel_get_iflink);\n\nint ip_tunnel_init_net(struct net *net, unsigned int ip_tnl_net_id,\n\t\t\t\t  struct rtnl_link_ops *ops, char *devname)\n{\n\tstruct ip_tunnel_net *itn = net_generic(net, ip_tnl_net_id);\n\tstruct ip_tunnel_parm parms;\n\tunsigned int i;\n\n\titn->rtnl_link_ops = ops;\n\tfor (i = 0; i < IP_TNL_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&itn->tunnels[i]);\n\n\tif (!ops || !net_has_fallback_tunnels(net)) {\n\t\tstruct ip_tunnel_net *it_init_net;\n\n\t\tit_init_net = net_generic(&init_net, ip_tnl_net_id);\n\t\titn->type = it_init_net->type;\n\t\titn->fb_tunnel_dev = NULL;\n\t\treturn 0;\n\t}\n\n\tmemset(&parms, 0, sizeof(parms));\n\tif (devname)\n\t\tstrscpy(parms.name, devname, IFNAMSIZ);\n\n\trtnl_lock();\n\titn->fb_tunnel_dev = __ip_tunnel_create(net, ops, &parms);\n\t \n\tif (!IS_ERR(itn->fb_tunnel_dev)) {\n\t\titn->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;\n\t\titn->fb_tunnel_dev->mtu = ip_tunnel_bind_dev(itn->fb_tunnel_dev);\n\t\tip_tunnel_add(itn, netdev_priv(itn->fb_tunnel_dev));\n\t\titn->type = itn->fb_tunnel_dev->type;\n\t}\n\trtnl_unlock();\n\n\treturn PTR_ERR_OR_ZERO(itn->fb_tunnel_dev);\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_init_net);\n\nstatic void ip_tunnel_destroy(struct net *net, struct ip_tunnel_net *itn,\n\t\t\t      struct list_head *head,\n\t\t\t      struct rtnl_link_ops *ops)\n{\n\tstruct net_device *dev, *aux;\n\tint h;\n\n\tfor_each_netdev_safe(net, dev, aux)\n\t\tif (dev->rtnl_link_ops == ops)\n\t\t\tunregister_netdevice_queue(dev, head);\n\n\tfor (h = 0; h < IP_TNL_HASH_SIZE; h++) {\n\t\tstruct ip_tunnel *t;\n\t\tstruct hlist_node *n;\n\t\tstruct hlist_head *thead = &itn->tunnels[h];\n\n\t\thlist_for_each_entry_safe(t, n, thead, hash_node)\n\t\t\t \n\t\t\tif (!net_eq(dev_net(t->dev), net))\n\t\t\t\tunregister_netdevice_queue(t->dev, head);\n\t}\n}\n\nvoid ip_tunnel_delete_nets(struct list_head *net_list, unsigned int id,\n\t\t\t   struct rtnl_link_ops *ops)\n{\n\tstruct ip_tunnel_net *itn;\n\tstruct net *net;\n\tLIST_HEAD(list);\n\n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\titn = net_generic(net, id);\n\t\tip_tunnel_destroy(net, itn, &list, ops);\n\t}\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_delete_nets);\n\nint ip_tunnel_newlink(struct net_device *dev, struct nlattr *tb[],\n\t\t      struct ip_tunnel_parm *p, __u32 fwmark)\n{\n\tstruct ip_tunnel *nt;\n\tstruct net *net = dev_net(dev);\n\tstruct ip_tunnel_net *itn;\n\tint mtu;\n\tint err;\n\n\tnt = netdev_priv(dev);\n\titn = net_generic(net, nt->ip_tnl_net_id);\n\n\tif (nt->collect_md) {\n\t\tif (rtnl_dereference(itn->collect_md_tun))\n\t\t\treturn -EEXIST;\n\t} else {\n\t\tif (ip_tunnel_find(itn, p, dev->type))\n\t\t\treturn -EEXIST;\n\t}\n\n\tnt->net = net;\n\tnt->parms = *p;\n\tnt->fwmark = fwmark;\n\terr = register_netdevice(dev);\n\tif (err)\n\t\tgoto err_register_netdevice;\n\n\tif (dev->type == ARPHRD_ETHER && !tb[IFLA_ADDRESS])\n\t\teth_hw_addr_random(dev);\n\n\tmtu = ip_tunnel_bind_dev(dev);\n\tif (tb[IFLA_MTU]) {\n\t\tunsigned int max = IP_MAX_MTU - (nt->hlen + sizeof(struct iphdr));\n\n\t\tif (dev->type == ARPHRD_ETHER)\n\t\t\tmax -= dev->hard_header_len;\n\n\t\tmtu = clamp(dev->mtu, (unsigned int)ETH_MIN_MTU, max);\n\t}\n\n\terr = dev_set_mtu(dev, mtu);\n\tif (err)\n\t\tgoto err_dev_set_mtu;\n\n\tip_tunnel_add(itn, nt);\n\treturn 0;\n\nerr_dev_set_mtu:\n\tunregister_netdevice(dev);\nerr_register_netdevice:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_newlink);\n\nint ip_tunnel_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t struct ip_tunnel_parm *p, __u32 fwmark)\n{\n\tstruct ip_tunnel *t;\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct net *net = tunnel->net;\n\tstruct ip_tunnel_net *itn = net_generic(net, tunnel->ip_tnl_net_id);\n\n\tif (dev == itn->fb_tunnel_dev)\n\t\treturn -EINVAL;\n\n\tt = ip_tunnel_find(itn, p, dev->type);\n\n\tif (t) {\n\t\tif (t->dev != dev)\n\t\t\treturn -EEXIST;\n\t} else {\n\t\tt = tunnel;\n\n\t\tif (dev->type != ARPHRD_ETHER) {\n\t\t\tunsigned int nflags = 0;\n\n\t\t\tif (ipv4_is_multicast(p->iph.daddr))\n\t\t\t\tnflags = IFF_BROADCAST;\n\t\t\telse if (p->iph.daddr)\n\t\t\t\tnflags = IFF_POINTOPOINT;\n\n\t\t\tif ((dev->flags ^ nflags) &\n\t\t\t    (IFF_POINTOPOINT | IFF_BROADCAST))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tip_tunnel_update(itn, t, dev, p, !tb[IFLA_MTU], fwmark);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_changelink);\n\nint ip_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct iphdr *iph = &tunnel->parms.iph;\n\tint err;\n\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = ip_tunnel_dev_free;\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\terr = dst_cache_init(&tunnel->dst_cache, GFP_KERNEL);\n\tif (err) {\n\t\tfree_percpu(dev->tstats);\n\t\treturn err;\n\t}\n\n\terr = gro_cells_init(&tunnel->gro_cells, dev);\n\tif (err) {\n\t\tdst_cache_destroy(&tunnel->dst_cache);\n\t\tfree_percpu(dev->tstats);\n\t\treturn err;\n\t}\n\n\ttunnel->dev = dev;\n\ttunnel->net = dev_net(dev);\n\tstrcpy(tunnel->parms.name, dev->name);\n\tiph->version\t\t= 4;\n\tiph->ihl\t\t= 5;\n\n\tif (tunnel->collect_md)\n\t\tnetif_keep_dst(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_init);\n\nvoid ip_tunnel_uninit(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct net *net = tunnel->net;\n\tstruct ip_tunnel_net *itn;\n\n\titn = net_generic(net, tunnel->ip_tnl_net_id);\n\tip_tunnel_del(itn, netdev_priv(dev));\n\tif (itn->fb_tunnel_dev == dev)\n\t\tWRITE_ONCE(itn->fb_tunnel_dev, NULL);\n\n\tdst_cache_reset(&tunnel->dst_cache);\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_uninit);\n\n \nvoid ip_tunnel_setup(struct net_device *dev, unsigned int net_id)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\ttunnel->ip_tnl_net_id = net_id;\n}\nEXPORT_SYMBOL_GPL(ip_tunnel_setup);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}