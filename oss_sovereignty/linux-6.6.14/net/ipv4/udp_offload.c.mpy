{
  "module_name": "udp_offload.c",
  "hash_id": "ad1444371b2d57eed64fbb1fb486f32554ec7b66d2d1c87f3fa536607b6c1c75",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/udp_offload.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <net/gro.h>\n#include <net/gso.h>\n#include <net/udp.h>\n#include <net/protocol.h>\n#include <net/inet_common.h>\n\nstatic struct sk_buff *__skb_udp_tunnel_segment(struct sk_buff *skb,\n\tnetdev_features_t features,\n\tstruct sk_buff *(*gso_inner_segment)(struct sk_buff *skb,\n\t\t\t\t\t     netdev_features_t features),\n\t__be16 new_protocol, bool is_ipv6)\n{\n\tint tnl_hlen = skb_inner_mac_header(skb) - skb_transport_header(skb);\n\tbool remcsum, need_csum, offload_csum, gso_partial;\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct udphdr *uh = udp_hdr(skb);\n\tu16 mac_offset = skb->mac_header;\n\t__be16 protocol = skb->protocol;\n\tu16 mac_len = skb->mac_len;\n\tint udp_offset, outer_hlen;\n\t__wsum partial;\n\tbool need_ipsec;\n\n\tif (unlikely(!pskb_may_pull(skb, tnl_hlen)))\n\t\tgoto out;\n\n\t \n\tif (skb_shinfo(skb)->gso_type & SKB_GSO_PARTIAL)\n\t\tpartial = (__force __wsum)uh->len;\n\telse\n\t\tpartial = (__force __wsum)htonl(skb->len);\n\tpartial = csum_sub(csum_unfold(uh->check), partial);\n\n\t \n\tskb->encapsulation = 0;\n\tSKB_GSO_CB(skb)->encap_level = 0;\n\t__skb_pull(skb, tnl_hlen);\n\tskb_reset_mac_header(skb);\n\tskb_set_network_header(skb, skb_inner_network_offset(skb));\n\tskb_set_transport_header(skb, skb_inner_transport_offset(skb));\n\tskb->mac_len = skb_inner_network_offset(skb);\n\tskb->protocol = new_protocol;\n\n\tneed_csum = !!(skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL_CSUM);\n\tskb->encap_hdr_csum = need_csum;\n\n\tremcsum = !!(skb_shinfo(skb)->gso_type & SKB_GSO_TUNNEL_REMCSUM);\n\tskb->remcsum_offload = remcsum;\n\n\tneed_ipsec = skb_dst(skb) && dst_xfrm(skb_dst(skb));\n\t \n\toffload_csum = !!(need_csum &&\n\t\t\t  !need_ipsec &&\n\t\t\t  (skb->dev->features &\n\t\t\t   (is_ipv6 ? (NETIF_F_HW_CSUM | NETIF_F_IPV6_CSUM) :\n\t\t\t\t      (NETIF_F_HW_CSUM | NETIF_F_IP_CSUM))));\n\n\tfeatures &= skb->dev->hw_enc_features;\n\tif (need_csum)\n\t\tfeatures &= ~NETIF_F_SCTP_CRC;\n\n\t \n\tif (remcsum) {\n\t\tfeatures &= ~NETIF_F_CSUM_MASK;\n\t\tif (!need_csum || offload_csum)\n\t\t\tfeatures |= NETIF_F_HW_CSUM;\n\t}\n\n\t \n\tsegs = gso_inner_segment(skb, features);\n\tif (IS_ERR_OR_NULL(segs)) {\n\t\tskb_gso_error_unwind(skb, protocol, tnl_hlen, mac_offset,\n\t\t\t\t     mac_len);\n\t\tgoto out;\n\t}\n\n\tgso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);\n\n\touter_hlen = skb_tnl_header_len(skb);\n\tudp_offset = outer_hlen - tnl_hlen;\n\tskb = segs;\n\tdo {\n\t\tunsigned int len;\n\n\t\tif (remcsum)\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\t \n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tskb_reset_inner_headers(skb);\n\t\t\tskb->encapsulation = 1;\n\t\t}\n\n\t\tskb->mac_len = mac_len;\n\t\tskb->protocol = protocol;\n\n\t\t__skb_push(skb, outer_hlen);\n\t\tskb_reset_mac_header(skb);\n\t\tskb_set_network_header(skb, mac_len);\n\t\tskb_set_transport_header(skb, udp_offset);\n\t\tlen = skb->len - udp_offset;\n\t\tuh = udp_hdr(skb);\n\n\t\t \n\t\tif (gso_partial && skb_is_gso(skb)) {\n\t\t\tuh->len = htons(skb_shinfo(skb)->gso_size +\n\t\t\t\t\tSKB_GSO_CB(skb)->data_offset +\n\t\t\t\t\tskb->head - (unsigned char *)uh);\n\t\t} else {\n\t\t\tuh->len = htons(len);\n\t\t}\n\n\t\tif (!need_csum)\n\t\t\tcontinue;\n\n\t\tuh->check = ~csum_fold(csum_add(partial,\n\t\t\t\t       (__force __wsum)htonl(len)));\n\n\t\tif (skb->encapsulation || !offload_csum) {\n\t\t\tuh->check = gso_make_checksum(skb, ~uh->check);\n\t\t\tif (uh->check == 0)\n\t\t\t\tuh->check = CSUM_MANGLED_0;\n\t\t} else {\n\t\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\t\tskb->csum_offset = offsetof(struct udphdr, check);\n\t\t}\n\t} while ((skb = skb->next));\nout:\n\treturn segs;\n}\n\nstruct sk_buff *skb_udp_tunnel_segment(struct sk_buff *skb,\n\t\t\t\t       netdev_features_t features,\n\t\t\t\t       bool is_ipv6)\n{\n\tconst struct net_offload __rcu **offloads;\n\t__be16 protocol = skb->protocol;\n\tconst struct net_offload *ops;\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct sk_buff *(*gso_inner_segment)(struct sk_buff *skb,\n\t\t\t\t\t     netdev_features_t features);\n\n\trcu_read_lock();\n\n\tswitch (skb->inner_protocol_type) {\n\tcase ENCAP_TYPE_ETHER:\n\t\tprotocol = skb->inner_protocol;\n\t\tgso_inner_segment = skb_mac_gso_segment;\n\t\tbreak;\n\tcase ENCAP_TYPE_IPPROTO:\n\t\toffloads = is_ipv6 ? inet6_offloads : inet_offloads;\n\t\tops = rcu_dereference(offloads[skb->inner_ipproto]);\n\t\tif (!ops || !ops->callbacks.gso_segment)\n\t\t\tgoto out_unlock;\n\t\tgso_inner_segment = ops->callbacks.gso_segment;\n\t\tbreak;\n\tdefault:\n\t\tgoto out_unlock;\n\t}\n\n\tsegs = __skb_udp_tunnel_segment(skb, features, gso_inner_segment,\n\t\t\t\t\tprotocol, is_ipv6);\n\nout_unlock:\n\trcu_read_unlock();\n\n\treturn segs;\n}\nEXPORT_SYMBOL(skb_udp_tunnel_segment);\n\nstatic void __udpv4_gso_segment_csum(struct sk_buff *seg,\n\t\t\t\t     __be32 *oldip, __be32 *newip,\n\t\t\t\t     __be16 *oldport, __be16 *newport)\n{\n\tstruct udphdr *uh;\n\tstruct iphdr *iph;\n\n\tif (*oldip == *newip && *oldport == *newport)\n\t\treturn;\n\n\tuh = udp_hdr(seg);\n\tiph = ip_hdr(seg);\n\n\tif (uh->check) {\n\t\tinet_proto_csum_replace4(&uh->check, seg, *oldip, *newip,\n\t\t\t\t\t true);\n\t\tinet_proto_csum_replace2(&uh->check, seg, *oldport, *newport,\n\t\t\t\t\t false);\n\t\tif (!uh->check)\n\t\t\tuh->check = CSUM_MANGLED_0;\n\t}\n\t*oldport = *newport;\n\n\tcsum_replace4(&iph->check, *oldip, *newip);\n\t*oldip = *newip;\n}\n\nstatic struct sk_buff *__udpv4_gso_segment_list_csum(struct sk_buff *segs)\n{\n\tstruct sk_buff *seg;\n\tstruct udphdr *uh, *uh2;\n\tstruct iphdr *iph, *iph2;\n\n\tseg = segs;\n\tuh = udp_hdr(seg);\n\tiph = ip_hdr(seg);\n\n\tif ((udp_hdr(seg)->dest == udp_hdr(seg->next)->dest) &&\n\t    (udp_hdr(seg)->source == udp_hdr(seg->next)->source) &&\n\t    (ip_hdr(seg)->daddr == ip_hdr(seg->next)->daddr) &&\n\t    (ip_hdr(seg)->saddr == ip_hdr(seg->next)->saddr))\n\t\treturn segs;\n\n\twhile ((seg = seg->next)) {\n\t\tuh2 = udp_hdr(seg);\n\t\tiph2 = ip_hdr(seg);\n\n\t\t__udpv4_gso_segment_csum(seg,\n\t\t\t\t\t &iph2->saddr, &iph->saddr,\n\t\t\t\t\t &uh2->source, &uh->source);\n\t\t__udpv4_gso_segment_csum(seg,\n\t\t\t\t\t &iph2->daddr, &iph->daddr,\n\t\t\t\t\t &uh2->dest, &uh->dest);\n\t}\n\n\treturn segs;\n}\n\nstatic struct sk_buff *__udp_gso_segment_list(struct sk_buff *skb,\n\t\t\t\t\t      netdev_features_t features,\n\t\t\t\t\t      bool is_ipv6)\n{\n\tunsigned int mss = skb_shinfo(skb)->gso_size;\n\n\tskb = skb_segment_list(skb, features, skb_mac_header_len(skb));\n\tif (IS_ERR(skb))\n\t\treturn skb;\n\n\tudp_hdr(skb)->len = htons(sizeof(struct udphdr) + mss);\n\n\treturn is_ipv6 ? skb : __udpv4_gso_segment_list_csum(skb);\n}\n\nstruct sk_buff *__udp_gso_segment(struct sk_buff *gso_skb,\n\t\t\t\t  netdev_features_t features, bool is_ipv6)\n{\n\tstruct sock *sk = gso_skb->sk;\n\tunsigned int sum_truesize = 0;\n\tstruct sk_buff *segs, *seg;\n\tstruct udphdr *uh;\n\tunsigned int mss;\n\tbool copy_dtor;\n\t__sum16 check;\n\t__be16 newlen;\n\n\tmss = skb_shinfo(gso_skb)->gso_size;\n\tif (gso_skb->len <= sizeof(*uh) + mss)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (skb_gso_ok(gso_skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t \n\t\tskb_shinfo(gso_skb)->gso_segs = DIV_ROUND_UP(gso_skb->len - sizeof(*uh),\n\t\t\t\t\t\t\t     mss);\n\t\treturn NULL;\n\t}\n\n\tif (skb_shinfo(gso_skb)->gso_type & SKB_GSO_FRAGLIST)\n\t\treturn __udp_gso_segment_list(gso_skb, features, is_ipv6);\n\n\tskb_pull(gso_skb, sizeof(*uh));\n\n\t \n\tcopy_dtor = gso_skb->destructor == sock_wfree;\n\tif (copy_dtor)\n\t\tgso_skb->destructor = NULL;\n\n\tsegs = skb_segment(gso_skb, features);\n\tif (IS_ERR_OR_NULL(segs)) {\n\t\tif (copy_dtor)\n\t\t\tgso_skb->destructor = sock_wfree;\n\t\treturn segs;\n\t}\n\n\t \n\tif (skb_is_gso(segs))\n\t\tmss *= skb_shinfo(segs)->gso_segs;\n\n\tseg = segs;\n\tuh = udp_hdr(seg);\n\n\t \n\tskb_shinfo(seg)->tskey = skb_shinfo(gso_skb)->tskey;\n\tskb_shinfo(seg)->tx_flags |=\n\t\t\t(skb_shinfo(gso_skb)->tx_flags & SKBTX_ANY_TSTAMP);\n\n\t \n\tnewlen = htons(sizeof(*uh) + mss);\n\tcheck = csum16_add(csum16_sub(uh->check, uh->len), newlen);\n\n\tfor (;;) {\n\t\tif (copy_dtor) {\n\t\t\tseg->destructor = sock_wfree;\n\t\t\tseg->sk = sk;\n\t\t\tsum_truesize += seg->truesize;\n\t\t}\n\n\t\tif (!seg->next)\n\t\t\tbreak;\n\n\t\tuh->len = newlen;\n\t\tuh->check = check;\n\n\t\tif (seg->ip_summed == CHECKSUM_PARTIAL)\n\t\t\tgso_reset_checksum(seg, ~check);\n\t\telse\n\t\t\tuh->check = gso_make_checksum(seg, ~check) ? :\n\t\t\t\t    CSUM_MANGLED_0;\n\n\t\tseg = seg->next;\n\t\tuh = udp_hdr(seg);\n\t}\n\n\t \n\tnewlen = htons(skb_tail_pointer(seg) - skb_transport_header(seg) +\n\t\t       seg->data_len);\n\tcheck = csum16_add(csum16_sub(uh->check, uh->len), newlen);\n\n\tuh->len = newlen;\n\tuh->check = check;\n\n\tif (seg->ip_summed == CHECKSUM_PARTIAL)\n\t\tgso_reset_checksum(seg, ~check);\n\telse\n\t\tuh->check = gso_make_checksum(seg, ~check) ? : CSUM_MANGLED_0;\n\n\t \n\tif (copy_dtor) {\n\t\tint delta = sum_truesize - gso_skb->truesize;\n\n\t\t \n\t\tif (likely(delta >= 0))\n\t\t\trefcount_add(delta, &sk->sk_wmem_alloc);\n\t\telse\n\t\t\tWARN_ON_ONCE(refcount_sub_and_test(-delta, &sk->sk_wmem_alloc));\n\t}\n\treturn segs;\n}\nEXPORT_SYMBOL_GPL(__udp_gso_segment);\n\nstatic struct sk_buff *udp4_ufo_fragment(struct sk_buff *skb,\n\t\t\t\t\t netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\t__wsum csum;\n\tstruct udphdr *uh;\n\tstruct iphdr *iph;\n\n\tif (skb->encapsulation &&\n\t    (skb_shinfo(skb)->gso_type &\n\t     (SKB_GSO_UDP_TUNNEL|SKB_GSO_UDP_TUNNEL_CSUM))) {\n\t\tsegs = skb_udp_tunnel_segment(skb, features, false);\n\t\tgoto out;\n\t}\n\n\tif (!(skb_shinfo(skb)->gso_type & (SKB_GSO_UDP | SKB_GSO_UDP_L4)))\n\t\tgoto out;\n\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\tgoto out;\n\n\tif (skb_shinfo(skb)->gso_type & SKB_GSO_UDP_L4)\n\t\treturn __udp_gso_segment(skb, features, false);\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\t \n\n\tuh = udp_hdr(skb);\n\tiph = ip_hdr(skb);\n\n\tuh->check = 0;\n\tcsum = skb_checksum(skb, 0, skb->len, 0);\n\tuh->check = udp_v4_check(skb->len, iph->saddr, iph->daddr, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\n\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t \n\tif (!skb->encap_hdr_csum)\n\t\tfeatures |= NETIF_F_HW_CSUM;\n\n\t \n\tsegs = skb_segment(skb, features);\nout:\n\treturn segs;\n}\n\nstatic int skb_gro_receive_list(struct sk_buff *p, struct sk_buff *skb)\n{\n\tif (unlikely(p->len + skb->len >= 65536))\n\t\treturn -E2BIG;\n\n\tif (NAPI_GRO_CB(p)->last == p)\n\t\tskb_shinfo(p)->frag_list = skb;\n\telse\n\t\tNAPI_GRO_CB(p)->last->next = skb;\n\n\tskb_pull(skb, skb_gro_offset(skb));\n\n\tNAPI_GRO_CB(p)->last = skb;\n\tNAPI_GRO_CB(p)->count++;\n\tp->data_len += skb->len;\n\n\t \n\tskb->destructor = NULL;\n\tp->truesize += skb->truesize;\n\tp->len += skb->len;\n\n\tNAPI_GRO_CB(skb)->same_flow = 1;\n\n\treturn 0;\n}\n\n\n#define UDP_GRO_CNT_MAX 64\nstatic struct sk_buff *udp_gro_receive_segment(struct list_head *head,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_gro_udphdr(skb);\n\tstruct sk_buff *pp = NULL;\n\tstruct udphdr *uh2;\n\tstruct sk_buff *p;\n\tunsigned int ulen;\n\tint ret = 0;\n\n\t \n\tif (!uh->check) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\n\t \n\tulen = ntohs(uh->len);\n\tif (ulen <= sizeof(*uh) || ulen != skb_gro_len(skb)) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\t \n\tskb_gro_pull(skb, sizeof(struct udphdr));\n\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tuh2 = udp_hdr(p);\n\n\t\t \n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (NAPI_GRO_CB(skb)->is_flist != NAPI_GRO_CB(p)->is_flist) {\n\t\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\t\treturn p;\n\t\t}\n\n\t\t \n\t\tif (ulen > ntohs(uh2->len)) {\n\t\t\tpp = p;\n\t\t} else {\n\t\t\tif (NAPI_GRO_CB(skb)->is_flist) {\n\t\t\t\tif (!pskb_may_pull(skb, skb_gro_offset(skb))) {\n\t\t\t\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif ((skb->ip_summed != p->ip_summed) ||\n\t\t\t\t    (skb->csum_level != p->csum_level)) {\n\t\t\t\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tret = skb_gro_receive_list(p, skb);\n\t\t\t} else {\n\t\t\t\tskb_gro_postpull_rcsum(skb, uh,\n\t\t\t\t\t\t       sizeof(struct udphdr));\n\n\t\t\t\tret = skb_gro_receive(p, skb);\n\t\t\t}\n\t\t}\n\n\t\tif (ret || ulen != ntohs(uh2->len) ||\n\t\t    NAPI_GRO_CB(p)->count >= UDP_GRO_CNT_MAX)\n\t\t\tpp = p;\n\n\t\treturn pp;\n\t}\n\n\t \n\treturn NULL;\n}\n\nstruct sk_buff *udp_gro_receive(struct list_head *head, struct sk_buff *skb,\n\t\t\t\tstruct udphdr *uh, struct sock *sk)\n{\n\tstruct sk_buff *pp = NULL;\n\tstruct sk_buff *p;\n\tstruct udphdr *uh2;\n\tunsigned int off = skb_gro_offset(skb);\n\tint flush = 1;\n\n\t \n\tNAPI_GRO_CB(skb)->is_flist = 0;\n\tif (!sk || !udp_sk(sk)->gro_receive) {\n\t\tif (skb->dev->features & NETIF_F_GRO_FRAGLIST)\n\t\t\tNAPI_GRO_CB(skb)->is_flist = sk ? !udp_test_bit(GRO_ENABLED, sk) : 1;\n\n\t\tif ((!sk && (skb->dev->features & NETIF_F_GRO_UDP_FWD)) ||\n\t\t    (sk && udp_test_bit(GRO_ENABLED, sk)) || NAPI_GRO_CB(skb)->is_flist)\n\t\t\treturn call_gro_receive(udp_gro_receive_segment, head, skb);\n\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (NAPI_GRO_CB(skb)->encap_mark ||\n\t    (uh->check && skb->ip_summed != CHECKSUM_PARTIAL &&\n\t     NAPI_GRO_CB(skb)->csum_cnt == 0 &&\n\t     !NAPI_GRO_CB(skb)->csum_valid))\n\t\tgoto out;\n\n\t \n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\n\tflush = 0;\n\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tuh2 = (struct udphdr   *)(p->data + off);\n\n\t\t \n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||\n\t\t    (!uh->check ^ !uh2->check)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tskb_gro_pull(skb, sizeof(struct udphdr));  \n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tpp = call_gro_receive_sk(udp_sk(sk)->gro_receive, sk, head, skb);\n\nout:\n\tskb_gro_flush_final(skb, pp, flush);\n\treturn pp;\n}\nEXPORT_SYMBOL(udp_gro_receive);\n\nstatic struct sock *udp4_gro_lookup_skb(struct sk_buff *skb, __be16 sport,\n\t\t\t\t\t__be16 dport)\n{\n\tconst struct iphdr *iph = skb_gro_network_header(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tint iif, sdif;\n\n\tinet_get_iif_sdif(skb, &iif, &sdif);\n\n\treturn __udp4_lib_lookup(net, iph->saddr, sport,\n\t\t\t\t iph->daddr, dport, iif,\n\t\t\t\t sdif, net->ipv4.udp_table, NULL);\n}\n\nINDIRECT_CALLABLE_SCOPE\nstruct sk_buff *udp4_gro_receive(struct list_head *head, struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_gro_udphdr(skb);\n\tstruct sock *sk = NULL;\n\tstruct sk_buff *pp;\n\n\tif (unlikely(!uh))\n\t\tgoto flush;\n\n\t \n\tif (NAPI_GRO_CB(skb)->flush)\n\t\tgoto skip;\n\n\tif (skb_gro_checksum_validate_zero_check(skb, IPPROTO_UDP, uh->check,\n\t\t\t\t\t\t inet_gro_compute_pseudo))\n\t\tgoto flush;\n\telse if (uh->check)\n\t\tskb_gro_checksum_try_convert(skb, IPPROTO_UDP,\n\t\t\t\t\t     inet_gro_compute_pseudo);\nskip:\n\tNAPI_GRO_CB(skb)->is_ipv6 = 0;\n\n\tif (static_branch_unlikely(&udp_encap_needed_key))\n\t\tsk = udp4_gro_lookup_skb(skb, uh->source, uh->dest);\n\n\tpp = udp_gro_receive(head, skb, uh, sk);\n\treturn pp;\n\nflush:\n\tNAPI_GRO_CB(skb)->flush = 1;\n\treturn NULL;\n}\n\nstatic int udp_gro_complete_segment(struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_hdr(skb);\n\n\tskb->csum_start = (unsigned char *)uh - skb->head;\n\tskb->csum_offset = offsetof(struct udphdr, check);\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\n\tskb_shinfo(skb)->gso_segs = NAPI_GRO_CB(skb)->count;\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_UDP_L4;\n\n\tif (skb->encapsulation)\n\t\tskb->inner_transport_header = skb->transport_header;\n\n\treturn 0;\n}\n\nint udp_gro_complete(struct sk_buff *skb, int nhoff,\n\t\t     udp_lookup_t lookup)\n{\n\t__be16 newlen = htons(skb->len - nhoff);\n\tstruct udphdr *uh = (struct udphdr *)(skb->data + nhoff);\n\tstruct sock *sk;\n\tint err;\n\n\tuh->len = newlen;\n\n\tsk = INDIRECT_CALL_INET(lookup, udp6_lib_lookup_skb,\n\t\t\t\tudp4_lib_lookup_skb, skb, uh->source, uh->dest);\n\tif (sk && udp_sk(sk)->gro_complete) {\n\t\tskb_shinfo(skb)->gso_type = uh->check ? SKB_GSO_UDP_TUNNEL_CSUM\n\t\t\t\t\t: SKB_GSO_UDP_TUNNEL;\n\n\t\t \n\t\tNAPI_GRO_CB(skb)->encap_mark = 0;\n\n\t\t \n\t\tskb->encapsulation = 1;\n\t\terr = udp_sk(sk)->gro_complete(sk, skb,\n\t\t\t\tnhoff + sizeof(struct udphdr));\n\t} else {\n\t\terr = udp_gro_complete_segment(skb);\n\t}\n\n\tif (skb->remcsum_offload)\n\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_TUNNEL_REMCSUM;\n\n\treturn err;\n}\nEXPORT_SYMBOL(udp_gro_complete);\n\nINDIRECT_CALLABLE_SCOPE int udp4_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct udphdr *uh = (struct udphdr *)(skb->data + nhoff);\n\n\t \n\tif (NAPI_GRO_CB(skb)->is_flist && !NAPI_GRO_CB(skb)->encap_mark) {\n\t\tuh->len = htons(skb->len - nhoff);\n\n\t\tskb_shinfo(skb)->gso_type |= (SKB_GSO_FRAGLIST|SKB_GSO_UDP_L4);\n\t\tskb_shinfo(skb)->gso_segs = NAPI_GRO_CB(skb)->count;\n\n\t\tif (skb->ip_summed == CHECKSUM_UNNECESSARY) {\n\t\t\tif (skb->csum_level < SKB_MAX_CSUM_LEVEL)\n\t\t\t\tskb->csum_level++;\n\t\t} else {\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\tskb->csum_level = 0;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (uh->check)\n\t\tuh->check = ~udp_v4_check(skb->len - nhoff, iph->saddr,\n\t\t\t\t\t  iph->daddr, 0);\n\n\treturn udp_gro_complete(skb, nhoff, udp4_lib_lookup_skb);\n}\n\nstatic const struct net_offload udpv4_offload = {\n\t.callbacks = {\n\t\t.gso_segment = udp4_ufo_fragment,\n\t\t.gro_receive  =\tudp4_gro_receive,\n\t\t.gro_complete =\tudp4_gro_complete,\n\t},\n};\n\nint __init udpv4_offload_init(void)\n{\n\treturn inet_add_offload(&udpv4_offload, IPPROTO_UDP);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}