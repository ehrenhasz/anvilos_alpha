{
  "module_name": "ipconfig.c",
  "hash_id": "6b8145eab62b20e3fa98398e70bafc567245dbd3848bd802c6edd8c849c08daa",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ipconfig.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/utsname.h>\n#include <linux/in.h>\n#include <linux/if.h>\n#include <linux/inet.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/socket.h>\n#include <linux/route.h>\n#include <linux/udp.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/major.h>\n#include <linux/root_dev.h>\n#include <linux/delay.h>\n#include <linux/nfs_fs.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <net/net_namespace.h>\n#include <net/arp.h>\n#include <net/ip.h>\n#include <net/ipconfig.h>\n#include <net/route.h>\n\n#include <linux/uaccess.h>\n#include <net/checksum.h>\n#include <asm/processor.h>\n\n#if defined(CONFIG_IP_PNP_DHCP)\n#define IPCONFIG_DHCP\n#endif\n#if defined(CONFIG_IP_PNP_BOOTP) || defined(CONFIG_IP_PNP_DHCP)\n#define IPCONFIG_BOOTP\n#endif\n#if defined(CONFIG_IP_PNP_RARP)\n#define IPCONFIG_RARP\n#endif\n#if defined(IPCONFIG_BOOTP) || defined(IPCONFIG_RARP)\n#define IPCONFIG_DYNAMIC\n#endif\n\n \n#define CONF_POST_OPEN\t\t10\t \n\n \n#define CONF_OPEN_RETRIES \t2\t \n#define CONF_SEND_RETRIES \t6\t \n#define CONF_BASE_TIMEOUT\t(HZ*2)\t \n#define CONF_TIMEOUT_RANDOM\t(HZ)\t \n#define CONF_TIMEOUT_MULT\t*7/4\t \n#define CONF_TIMEOUT_MAX\t(HZ*30)\t \n#define CONF_NAMESERVERS_MAX   3        \n#define CONF_NTP_SERVERS_MAX   3\t \n\n#define NONE cpu_to_be32(INADDR_NONE)\n#define ANY cpu_to_be32(INADDR_ANY)\n\n \nstatic unsigned int carrier_timeout = 120;\n\n \n\n \nint ic_set_manually __initdata = 0;\t\t \n\nstatic int ic_enable __initdata;\t\t \n\n \nint ic_proto_enabled __initdata = 0\n#ifdef IPCONFIG_BOOTP\n\t\t\t| IC_BOOTP\n#endif\n#ifdef CONFIG_IP_PNP_DHCP\n\t\t\t| IC_USE_DHCP\n#endif\n#ifdef IPCONFIG_RARP\n\t\t\t| IC_RARP\n#endif\n\t\t\t;\n\nstatic int ic_host_name_set __initdata;\t \n\n__be32 ic_myaddr = NONE;\t\t \nstatic __be32 ic_netmask = NONE;\t \n__be32 ic_gateway = NONE;\t \n\n#ifdef IPCONFIG_DYNAMIC\nstatic __be32 ic_addrservaddr = NONE;\t \n#endif\n\n__be32 ic_servaddr = NONE;\t \n\n__be32 root_server_addr = NONE;\t \nu8 root_server_path[256] = { 0, };\t \n\n \nstatic char vendor_class_identifier[253] __initdata;\n\n#if defined(CONFIG_IP_PNP_DHCP)\nstatic char dhcp_client_identifier[253] __initdata;\n#endif\n\n \n\n#ifdef IPCONFIG_DYNAMIC\nstatic int ic_proto_used;\t\t\t \n#else\n#define ic_proto_used 0\n#endif\nstatic __be32 ic_nameservers[CONF_NAMESERVERS_MAX];  \nstatic __be32 ic_ntp_servers[CONF_NTP_SERVERS_MAX];  \nstatic u8 ic_domain[64];\t\t \n\n \n\n \nstatic char user_dev_name[IFNAMSIZ] __initdata = { 0, };\n\n \nstatic int ic_proto_have_if __initdata;\n\n \nstatic int ic_dev_mtu __initdata;\n\n#ifdef IPCONFIG_DYNAMIC\nstatic DEFINE_SPINLOCK(ic_recv_lock);\nstatic volatile int ic_got_reply __initdata;     \n#endif\n#ifdef IPCONFIG_DHCP\nstatic int ic_dhcp_msgtype __initdata;\t \n#endif\n\n\n \n\nstruct ic_device {\n\tstruct ic_device *next;\n\tstruct net_device *dev;\n\tunsigned short flags;\n\tshort able;\n\t__be32 xid;\n};\n\nstatic struct ic_device *ic_first_dev __initdata;\t \nstatic struct ic_device *ic_dev __initdata;\t\t \n\nstatic bool __init ic_is_init_dev(struct net_device *dev)\n{\n\tif (dev->flags & IFF_LOOPBACK)\n\t\treturn false;\n\treturn user_dev_name[0] ? !strcmp(dev->name, user_dev_name) :\n\t    (!(dev->flags & IFF_LOOPBACK) &&\n\t     (dev->flags & (IFF_POINTOPOINT|IFF_BROADCAST)) &&\n\t     strncmp(dev->name, \"dummy\", 5));\n}\n\nstatic int __init ic_open_devs(void)\n{\n\tstruct ic_device *d, **last;\n\tstruct net_device *dev;\n\tunsigned short oflags;\n\tunsigned long start, next_msg;\n\n\tlast = &ic_first_dev;\n\trtnl_lock();\n\n\t \n\tfor_each_netdev(&init_net, dev) {\n\t\tif (!(dev->flags & IFF_LOOPBACK))\n\t\t\tcontinue;\n\t\tif (dev_change_flags(dev, dev->flags | IFF_UP, NULL) < 0)\n\t\t\tpr_err(\"IP-Config: Failed to open %s\\n\", dev->name);\n\t}\n\n\tfor_each_netdev(&init_net, dev) {\n\t\tif (ic_is_init_dev(dev)) {\n\t\t\tint able = 0;\n\t\t\tif (dev->mtu >= 364)\n\t\t\t\table |= IC_BOOTP;\n\t\t\telse\n\t\t\t\tpr_warn(\"DHCP/BOOTP: Ignoring device %s, MTU %d too small\\n\",\n\t\t\t\t\tdev->name, dev->mtu);\n\t\t\tif (!(dev->flags & IFF_NOARP))\n\t\t\t\table |= IC_RARP;\n\t\t\table &= ic_proto_enabled;\n\t\t\tif (ic_proto_enabled && !able)\n\t\t\t\tcontinue;\n\t\t\toflags = dev->flags;\n\t\t\tif (dev_change_flags(dev, oflags | IFF_UP, NULL) < 0) {\n\t\t\t\tpr_err(\"IP-Config: Failed to open %s\\n\",\n\t\t\t\t       dev->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!(d = kmalloc(sizeof(struct ic_device), GFP_KERNEL))) {\n\t\t\t\trtnl_unlock();\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\td->dev = dev;\n\t\t\t*last = d;\n\t\t\tlast = &d->next;\n\t\t\td->flags = oflags;\n\t\t\td->able = able;\n\t\t\tif (able & IC_BOOTP)\n\t\t\t\tget_random_bytes(&d->xid, sizeof(__be32));\n\t\t\telse\n\t\t\t\td->xid = 0;\n\t\t\tic_proto_have_if |= able;\n\t\t\tpr_debug(\"IP-Config: %s UP (able=%d, xid=%08x)\\n\",\n\t\t\t\t dev->name, able, d->xid);\n\t\t}\n\t}\n\t \n\trtnl_unlock();\n\n\t \n\tif (!ic_first_dev)\n\t\tgoto have_carrier;\n\n\t \n\tstart = jiffies;\n\tnext_msg = start + msecs_to_jiffies(20000);\n\twhile (time_before(jiffies, start +\n\t\t\t   msecs_to_jiffies(carrier_timeout * 1000))) {\n\t\tint wait, elapsed;\n\n\t\trtnl_lock();\n\t\tfor_each_netdev(&init_net, dev)\n\t\t\tif (ic_is_init_dev(dev) && netif_carrier_ok(dev)) {\n\t\t\t\trtnl_unlock();\n\t\t\t\tgoto have_carrier;\n\t\t\t}\n\t\trtnl_unlock();\n\n\t\tmsleep(1);\n\n\t\tif (time_before(jiffies, next_msg))\n\t\t\tcontinue;\n\n\t\telapsed = jiffies_to_msecs(jiffies - start);\n\t\twait = (carrier_timeout * 1000 - elapsed + 500) / 1000;\n\t\tpr_info(\"Waiting up to %d more seconds for network.\\n\", wait);\n\t\tnext_msg = jiffies + msecs_to_jiffies(20000);\n\t}\nhave_carrier:\n\n\t*last = NULL;\n\n\tif (!ic_first_dev) {\n\t\tif (user_dev_name[0])\n\t\t\tpr_err(\"IP-Config: Device `%s' not found\\n\",\n\t\t\t       user_dev_name);\n\t\telse\n\t\t\tpr_err(\"IP-Config: No network devices available\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\n \nstatic void __init ic_close_devs(void)\n{\n\tstruct net_device *selected_dev = ic_dev ? ic_dev->dev : NULL;\n\tstruct ic_device *d, *next;\n\tstruct net_device *dev;\n\n\trtnl_lock();\n\tnext = ic_first_dev;\n\twhile ((d = next)) {\n\t\tbool bring_down = (d != ic_dev);\n\t\tstruct net_device *lower;\n\t\tstruct list_head *iter;\n\n\t\tnext = d->next;\n\t\tdev = d->dev;\n\n\t\tif (selected_dev) {\n\t\t\tnetdev_for_each_lower_dev(selected_dev, lower, iter) {\n\t\t\t\tif (dev == lower) {\n\t\t\t\t\tbring_down = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bring_down) {\n\t\t\tpr_debug(\"IP-Config: Downing %s\\n\", dev->name);\n\t\t\tdev_change_flags(dev, d->flags, NULL);\n\t\t}\n\t\tkfree(d);\n\t}\n\trtnl_unlock();\n}\n\n \n\nstatic inline void\nset_sockaddr(struct sockaddr_in *sin, __be32 addr, __be16 port)\n{\n\tsin->sin_family = AF_INET;\n\tsin->sin_addr.s_addr = addr;\n\tsin->sin_port = port;\n}\n\n \n\nstatic int __init ic_setup_if(void)\n{\n\tstruct ifreq ir;\n\tstruct sockaddr_in *sin = (void *) &ir.ifr_ifru.ifru_addr;\n\tint err;\n\n\tmemset(&ir, 0, sizeof(ir));\n\tstrcpy(ir.ifr_ifrn.ifrn_name, ic_dev->dev->name);\n\tset_sockaddr(sin, ic_myaddr, 0);\n\tif ((err = devinet_ioctl(&init_net, SIOCSIFADDR, &ir)) < 0) {\n\t\tpr_err(\"IP-Config: Unable to set interface address (%d)\\n\",\n\t\t       err);\n\t\treturn -1;\n\t}\n\tset_sockaddr(sin, ic_netmask, 0);\n\tif ((err = devinet_ioctl(&init_net, SIOCSIFNETMASK, &ir)) < 0) {\n\t\tpr_err(\"IP-Config: Unable to set interface netmask (%d)\\n\",\n\t\t       err);\n\t\treturn -1;\n\t}\n\tset_sockaddr(sin, ic_myaddr | ~ic_netmask, 0);\n\tif ((err = devinet_ioctl(&init_net, SIOCSIFBRDADDR, &ir)) < 0) {\n\t\tpr_err(\"IP-Config: Unable to set interface broadcast address (%d)\\n\",\n\t\t       err);\n\t\treturn -1;\n\t}\n\t \n\tif (ic_dev_mtu != 0) {\n\t\trtnl_lock();\n\t\tif ((err = dev_set_mtu(ic_dev->dev, ic_dev_mtu)) < 0)\n\t\t\tpr_err(\"IP-Config: Unable to set interface mtu to %d (%d)\\n\",\n\t\t\t       ic_dev_mtu, err);\n\t\trtnl_unlock();\n\t}\n\treturn 0;\n}\n\nstatic int __init ic_setup_routes(void)\n{\n\t \n\n\tif (ic_gateway != NONE) {\n\t\tstruct rtentry rm;\n\t\tint err;\n\n\t\tmemset(&rm, 0, sizeof(rm));\n\t\tif ((ic_gateway ^ ic_myaddr) & ic_netmask) {\n\t\t\tpr_err(\"IP-Config: Gateway not on directly connected network\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tset_sockaddr((struct sockaddr_in *) &rm.rt_dst, 0, 0);\n\t\tset_sockaddr((struct sockaddr_in *) &rm.rt_genmask, 0, 0);\n\t\tset_sockaddr((struct sockaddr_in *) &rm.rt_gateway, ic_gateway, 0);\n\t\trm.rt_flags = RTF_UP | RTF_GATEWAY;\n\t\tif ((err = ip_rt_ioctl(&init_net, SIOCADDRT, &rm)) < 0) {\n\t\t\tpr_err(\"IP-Config: Cannot add default route (%d)\\n\",\n\t\t\t       err);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int __init ic_defaults(void)\n{\n\t \n\n\tif (!ic_host_name_set)\n\t\tsprintf(init_utsname()->nodename, \"%pI4\", &ic_myaddr);\n\n\tif (root_server_addr == NONE)\n\t\troot_server_addr = ic_servaddr;\n\n\tif (ic_netmask == NONE) {\n\t\tif (IN_CLASSA(ntohl(ic_myaddr)))\n\t\t\tic_netmask = htonl(IN_CLASSA_NET);\n\t\telse if (IN_CLASSB(ntohl(ic_myaddr)))\n\t\t\tic_netmask = htonl(IN_CLASSB_NET);\n\t\telse if (IN_CLASSC(ntohl(ic_myaddr)))\n\t\t\tic_netmask = htonl(IN_CLASSC_NET);\n\t\telse if (IN_CLASSE(ntohl(ic_myaddr)))\n\t\t\tic_netmask = htonl(IN_CLASSE_NET);\n\t\telse {\n\t\t\tpr_err(\"IP-Config: Unable to guess netmask for address %pI4\\n\",\n\t\t\t       &ic_myaddr);\n\t\t\treturn -1;\n\t\t}\n\t\tpr_notice(\"IP-Config: Guessing netmask %pI4\\n\",\n\t\t\t  &ic_netmask);\n\t}\n\n\treturn 0;\n}\n\n \n\n#ifdef IPCONFIG_RARP\n\nstatic int ic_rarp_recv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev);\n\nstatic struct packet_type rarp_packet_type __initdata = {\n\t.type =\tcpu_to_be16(ETH_P_RARP),\n\t.func =\tic_rarp_recv,\n};\n\nstatic inline void __init ic_rarp_init(void)\n{\n\tdev_add_pack(&rarp_packet_type);\n}\n\nstatic inline void __init ic_rarp_cleanup(void)\n{\n\tdev_remove_pack(&rarp_packet_type);\n}\n\n \nstatic int __init\nic_rarp_recv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct arphdr *rarp;\n\tunsigned char *rarp_ptr;\n\t__be32 sip, tip;\n\tunsigned char *tha;\t\t \n\tstruct ic_device *d;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto drop;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NET_RX_DROP;\n\n\tif (!pskb_may_pull(skb, sizeof(struct arphdr)))\n\t\tgoto drop;\n\n\t \n\trarp = (struct arphdr *)skb_transport_header(skb);\n\n\t \n\tif (rarp->ar_hln != dev->addr_len || dev->type != ntohs(rarp->ar_hrd))\n\t\tgoto drop;\n\n\t \n\tif (rarp->ar_op != htons(ARPOP_RREPLY))\n\t\tgoto drop;\n\n\t \n\tif (rarp->ar_pro != htons(ETH_P_IP))\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, arp_hdr_len(dev)))\n\t\tgoto drop;\n\n\t \n\trarp = (struct arphdr *)skb_transport_header(skb);\n\trarp_ptr = (unsigned char *) (rarp + 1);\n\n\t \n\tspin_lock(&ic_recv_lock);\n\n\t \n\tif (ic_got_reply)\n\t\tgoto drop_unlock;\n\n\t \n\td = ic_first_dev;\n\twhile (d && d->dev != dev)\n\t\td = d->next;\n\tif (!d)\n\t\tgoto drop_unlock;\t \n\n\t \n\trarp_ptr += dev->addr_len;\n\tmemcpy(&sip, rarp_ptr, 4);\n\trarp_ptr += 4;\n\ttha = rarp_ptr;\n\trarp_ptr += dev->addr_len;\n\tmemcpy(&tip, rarp_ptr, 4);\n\n\t \n\tif (memcmp(tha, dev->dev_addr, dev->addr_len))\n\t\tgoto drop_unlock;\n\n\t \n\tif (ic_servaddr != NONE && ic_servaddr != sip)\n\t\tgoto drop_unlock;\n\n\t \n\tic_dev = d;\n\tif (ic_myaddr == NONE)\n\t\tic_myaddr = tip;\n\tic_servaddr = sip;\n\tic_addrservaddr = sip;\n\tic_got_reply = IC_RARP;\n\ndrop_unlock:\n\t \n\tspin_unlock(&ic_recv_lock);\n\ndrop:\n\t \n\tkfree_skb(skb);\n\treturn 0;\n}\n\n\n \nstatic void __init ic_rarp_send_if(struct ic_device *d)\n{\n\tstruct net_device *dev = d->dev;\n\tarp_send(ARPOP_RREQUEST, ETH_P_RARP, 0, dev, 0, NULL,\n\t\t dev->dev_addr, dev->dev_addr);\n}\n#endif\n\n \nstatic inline void __init ic_nameservers_predef(void)\n{\n\tint i;\n\n\tfor (i = 0; i < CONF_NAMESERVERS_MAX; i++)\n\t\tic_nameservers[i] = NONE;\n}\n\n \nstatic inline void __init ic_ntp_servers_predef(void)\n{\n\tint i;\n\n\tfor (i = 0; i < CONF_NTP_SERVERS_MAX; i++)\n\t\tic_ntp_servers[i] = NONE;\n}\n\n \n\n#ifdef IPCONFIG_BOOTP\n\nstruct bootp_pkt {\t\t \n\tstruct iphdr iph;\t \n\tstruct udphdr udph;\t \n\tu8 op;\t\t\t \n\tu8 htype;\t\t \n\tu8 hlen;\t\t \n\tu8 hops;\t\t \n\t__be32 xid;\t\t \n\t__be16 secs;\t\t \n\t__be16 flags;\t\t \n\t__be32 client_ip;\t\t \n\t__be32 your_ip;\t\t \n\t__be32 server_ip;\t\t \n\t__be32 relay_ip;\t\t \n\tu8 hw_addr[16];\t\t \n\tu8 serv_name[64];\t \n\tu8 boot_file[128];\t \n\tu8 exten[312];\t\t \n};\n\n \n#define BOOTP_REQUEST\t1\n#define BOOTP_REPLY\t2\n\n \n#define DHCPDISCOVER\t1\n#define DHCPOFFER\t2\n#define DHCPREQUEST\t3\n#define DHCPDECLINE\t4\n#define DHCPACK\t\t5\n#define DHCPNAK\t\t6\n#define DHCPRELEASE\t7\n#define DHCPINFORM\t8\n\nstatic int ic_bootp_recv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev);\n\nstatic struct packet_type bootp_packet_type __initdata = {\n\t.type =\tcpu_to_be16(ETH_P_IP),\n\t.func =\tic_bootp_recv,\n};\n\n \nstatic int ic_nameservers_fallback __initdata;\n\n \n\nstatic const u8 ic_bootp_cookie[4] = { 99, 130, 83, 99 };\n\n#ifdef IPCONFIG_DHCP\n\nstatic void __init\nic_dhcp_init_options(u8 *options, struct ic_device *d)\n{\n\tu8 mt = ((ic_servaddr == NONE)\n\t\t ? DHCPDISCOVER : DHCPREQUEST);\n\tu8 *e = options;\n\tint len;\n\n\tpr_debug(\"DHCP: Sending message type %d (%s)\\n\", mt, d->dev->name);\n\n\tmemcpy(e, ic_bootp_cookie, 4);\t \n\te += 4;\n\n\t*e++ = 53;\t\t \n\t*e++ = 1;\n\t*e++ = mt;\n\n\tif (mt == DHCPREQUEST) {\n\t\t*e++ = 54;\t \n\t\t*e++ = 4;\n\t\tmemcpy(e, &ic_servaddr, 4);\n\t\te += 4;\n\n\t\t*e++ = 50;\t \n\t\t*e++ = 4;\n\t\tmemcpy(e, &ic_myaddr, 4);\n\t\te += 4;\n\t}\n\n\t \n\t{\n\t\tstatic const u8 ic_req_params[] = {\n\t\t\t1,\t \n\t\t\t3,\t \n\t\t\t6,\t \n\t\t\t12,\t \n\t\t\t15,\t \n\t\t\t17,\t \n\t\t\t26,\t \n\t\t\t40,\t \n\t\t\t42,\t \n\t\t};\n\n\t\t*e++ = 55;\t \n\t\t*e++ = sizeof(ic_req_params);\n\t\tmemcpy(e, ic_req_params, sizeof(ic_req_params));\n\t\te += sizeof(ic_req_params);\n\n\t\tif (ic_host_name_set) {\n\t\t\t*e++ = 12;\t \n\t\t\tlen = strlen(utsname()->nodename);\n\t\t\t*e++ = len;\n\t\t\tmemcpy(e, utsname()->nodename, len);\n\t\t\te += len;\n\t\t}\n\t\tif (*vendor_class_identifier) {\n\t\t\tpr_info(\"DHCP: sending class identifier \\\"%s\\\"\\n\",\n\t\t\t\tvendor_class_identifier);\n\t\t\t*e++ = 60;\t \n\t\t\tlen = strlen(vendor_class_identifier);\n\t\t\t*e++ = len;\n\t\t\tmemcpy(e, vendor_class_identifier, len);\n\t\t\te += len;\n\t\t}\n\t\tlen = strlen(dhcp_client_identifier + 1);\n\t\t \n\t\tif (len >= 1 && len < 312 - (e - options) - 1) {\n\t\t\t*e++ = 61;\n\t\t\t*e++ = len + 1;\n\t\t\tmemcpy(e, dhcp_client_identifier, len + 1);\n\t\t\te += len + 1;\n\t\t}\n\t}\n\n\t*e++ = 255;\t \n}\n\n#endif  \n\nstatic void __init ic_bootp_init_ext(u8 *e)\n{\n\tmemcpy(e, ic_bootp_cookie, 4);\t \n\te += 4;\n\t*e++ = 1;\t\t \n\t*e++ = 4;\n\te += 4;\n\t*e++ = 3;\t\t \n\t*e++ = 4;\n\te += 4;\n#if CONF_NAMESERVERS_MAX > 0\n\t*e++ = 6;\t\t \n\t*e++ = 4 * CONF_NAMESERVERS_MAX;\n\te += 4 * CONF_NAMESERVERS_MAX;\n#endif\n\t*e++ = 12;\t\t \n\t*e++ = 32;\n\te += 32;\n\t*e++ = 40;\t\t \n\t*e++ = 32;\n\te += 32;\n\t*e++ = 17;\t\t \n\t*e++ = 40;\n\te += 40;\n\n\t*e++ = 57;\t\t \n\t*e++ = 2;\n\t*e++ = 1;\t\t \n\t*e++ = 150;\n\n\t*e++ = 255;\t\t \n}\n\n\n \nstatic inline void __init ic_bootp_init(void)\n{\n\t \n\tic_nameservers_predef();\n\tic_ntp_servers_predef();\n\n\tdev_add_pack(&bootp_packet_type);\n}\n\n\n \nstatic inline void __init ic_bootp_cleanup(void)\n{\n\tdev_remove_pack(&bootp_packet_type);\n}\n\n\n \nstatic void __init ic_bootp_send_if(struct ic_device *d, unsigned long jiffies_diff)\n{\n\tstruct net_device *dev = d->dev;\n\tstruct sk_buff *skb;\n\tstruct bootp_pkt *b;\n\tstruct iphdr *h;\n\tint hlen = LL_RESERVED_SPACE(dev);\n\tint tlen = dev->needed_tailroom;\n\n\t \n\tskb = alloc_skb(sizeof(struct bootp_pkt) + hlen + tlen + 15,\n\t\t\tGFP_KERNEL);\n\tif (!skb)\n\t\treturn;\n\tskb_reserve(skb, hlen);\n\tb = skb_put_zero(skb, sizeof(struct bootp_pkt));\n\n\t \n\tskb_reset_network_header(skb);\n\th = ip_hdr(skb);\n\th->version = 4;\n\th->ihl = 5;\n\th->tot_len = htons(sizeof(struct bootp_pkt));\n\th->frag_off = htons(IP_DF);\n\th->ttl = 64;\n\th->protocol = IPPROTO_UDP;\n\th->daddr = htonl(INADDR_BROADCAST);\n\th->check = ip_fast_csum((unsigned char *) h, h->ihl);\n\n\t \n\tb->udph.source = htons(68);\n\tb->udph.dest = htons(67);\n\tb->udph.len = htons(sizeof(struct bootp_pkt) - sizeof(struct iphdr));\n\t \n\n\t \n\tb->op = BOOTP_REQUEST;\n\tif (dev->type < 256)  \n\t\tb->htype = dev->type;\n\telse if (dev->type == ARPHRD_FDDI)\n\t\tb->htype = ARPHRD_ETHER;\n\telse {\n\t\tpr_warn(\"Unknown ARP type 0x%04x for device %s\\n\", dev->type,\n\t\t\tdev->name);\n\t\tb->htype = dev->type;  \n\t}\n\n\t \n\tb->hlen = dev->addr_len;\n\tmemcpy(b->hw_addr, dev->dev_addr, dev->addr_len);\n\tb->secs = htons(jiffies_diff / HZ);\n\tb->xid = d->xid;\n\n\t \n#ifdef IPCONFIG_DHCP\n\tif (ic_proto_enabled & IC_USE_DHCP)\n\t\tic_dhcp_init_options(b->exten, d);\n\telse\n#endif\n\t\tic_bootp_init_ext(b->exten);\n\n\t \n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_IP);\n\tif (dev_hard_header(skb, dev, ntohs(skb->protocol),\n\t\t\t    dev->broadcast, dev->dev_addr, skb->len) < 0) {\n\t\tkfree_skb(skb);\n\t\tprintk(\"E\");\n\t\treturn;\n\t}\n\n\tif (dev_queue_xmit(skb) < 0)\n\t\tprintk(\"E\");\n}\n\n\n \nstatic int __init ic_bootp_string(char *dest, char *src, int len, int max)\n{\n\tif (!len)\n\t\treturn 0;\n\tif (len > max-1)\n\t\tlen = max-1;\n\tmemcpy(dest, src, len);\n\tdest[len] = '\\0';\n\treturn 1;\n}\n\n\n \nstatic void __init ic_do_bootp_ext(u8 *ext)\n{\n\tu8 servers;\n\tint i;\n\t__be16 mtu;\n\n\tu8 *c;\n\n\tpr_debug(\"DHCP/BOOTP: Got extension %d:\", *ext);\n\tfor (c=ext+2; c<ext+2+ext[1]; c++)\n\t\tpr_debug(\" %02x\", *c);\n\tpr_debug(\"\\n\");\n\n\tswitch (*ext++) {\n\tcase 1:\t\t \n\t\tif (ic_netmask == NONE)\n\t\t\tmemcpy(&ic_netmask, ext+1, 4);\n\t\tbreak;\n\tcase 3:\t\t \n\t\tif (ic_gateway == NONE)\n\t\t\tmemcpy(&ic_gateway, ext+1, 4);\n\t\tbreak;\n\tcase 6:\t\t \n\t\tservers= *ext/4;\n\t\tif (servers > CONF_NAMESERVERS_MAX)\n\t\t\tservers = CONF_NAMESERVERS_MAX;\n\t\tfor (i = 0; i < servers; i++) {\n\t\t\tif (ic_nameservers[i] == NONE ||\n\t\t\t    ic_nameservers_fallback)\n\t\t\t\tmemcpy(&ic_nameservers[i], ext+1+4*i, 4);\n\t\t}\n\t\tbreak;\n\tcase 12:\t \n\t\tif (!ic_host_name_set) {\n\t\t\tic_bootp_string(utsname()->nodename, ext+1, *ext,\n\t\t\t\t\t__NEW_UTS_LEN);\n\t\t\tic_host_name_set = 1;\n\t\t}\n\t\tbreak;\n\tcase 15:\t \n\t\tif (!ic_domain[0])\n\t\t\tic_bootp_string(ic_domain, ext+1, *ext, sizeof(ic_domain));\n\t\tbreak;\n\tcase 17:\t \n\t\tif (!root_server_path[0])\n\t\t\tic_bootp_string(root_server_path, ext+1, *ext,\n\t\t\t\t\tsizeof(root_server_path));\n\t\tbreak;\n\tcase 26:\t \n\t\tmemcpy(&mtu, ext+1, sizeof(mtu));\n\t\tic_dev_mtu = ntohs(mtu);\n\t\tbreak;\n\tcase 40:\t \n\t\tic_bootp_string(utsname()->domainname, ext+1, *ext,\n\t\t\t\t__NEW_UTS_LEN);\n\t\tbreak;\n\tcase 42:\t \n\t\tservers = *ext / 4;\n\t\tif (servers > CONF_NTP_SERVERS_MAX)\n\t\t\tservers = CONF_NTP_SERVERS_MAX;\n\t\tfor (i = 0; i < servers; i++) {\n\t\t\tif (ic_ntp_servers[i] == NONE)\n\t\t\t\tmemcpy(&ic_ntp_servers[i], ext+1+4*i, 4);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n\n \nstatic int __init ic_bootp_recv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct bootp_pkt *b;\n\tstruct iphdr *h;\n\tstruct ic_device *d;\n\tint len, ext_len;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto drop;\n\n\t \n\tif (skb->pkt_type == PACKET_OTHERHOST)\n\t\tgoto drop;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NET_RX_DROP;\n\n\tif (!pskb_may_pull(skb,\n\t\t\t   sizeof(struct iphdr) +\n\t\t\t   sizeof(struct udphdr)))\n\t\tgoto drop;\n\n\tb = (struct bootp_pkt *)skb_network_header(skb);\n\th = &b->iph;\n\n\tif (h->ihl != 5 || h->version != 4 || h->protocol != IPPROTO_UDP)\n\t\tgoto drop;\n\n\t \n\tif (ip_is_fragment(h)) {\n\t\tnet_err_ratelimited(\"DHCP/BOOTP: Ignoring fragmented reply\\n\");\n\t\tgoto drop;\n\t}\n\n\tif (skb->len < ntohs(h->tot_len))\n\t\tgoto drop;\n\n\tif (ip_fast_csum((char *) h, h->ihl))\n\t\tgoto drop;\n\n\tif (b->udph.source != htons(67) || b->udph.dest != htons(68))\n\t\tgoto drop;\n\n\tif (ntohs(h->tot_len) < ntohs(b->udph.len) + sizeof(struct iphdr))\n\t\tgoto drop;\n\n\tlen = ntohs(b->udph.len) - sizeof(struct udphdr);\n\text_len = len - (sizeof(*b) -\n\t\t\t sizeof(struct iphdr) -\n\t\t\t sizeof(struct udphdr) -\n\t\t\t sizeof(b->exten));\n\tif (ext_len < 0)\n\t\tgoto drop;\n\n\t \n\tif (!pskb_may_pull(skb, skb->len))\n\t\tgoto drop;\n\n\tb = (struct bootp_pkt *)skb_network_header(skb);\n\th = &b->iph;\n\n\t \n\tspin_lock(&ic_recv_lock);\n\n\t \n\tif (ic_got_reply)\n\t\tgoto drop_unlock;\n\n\t \n\td = ic_first_dev;\n\twhile (d && d->dev != dev)\n\t\td = d->next;\n\tif (!d)\n\t\tgoto drop_unlock;   \n\n\t \n\tif (b->op != BOOTP_REPLY ||\n\t    b->xid != d->xid) {\n\t\tnet_err_ratelimited(\"DHCP/BOOTP: Reply not for us on %s, op[%x] xid[%x]\\n\",\n\t\t\t\t    d->dev->name, b->op, b->xid);\n\t\tgoto drop_unlock;\n\t}\n\n\t \n\tif (ext_len >= 4 &&\n\t    !memcmp(b->exten, ic_bootp_cookie, 4)) {  \n\t\tu8 *end = (u8 *) b + ntohs(b->iph.tot_len);\n\t\tu8 *ext;\n\n#ifdef IPCONFIG_DHCP\n\t\tif (ic_proto_enabled & IC_USE_DHCP) {\n\t\t\t__be32 server_id = NONE;\n\t\t\tint mt = 0;\n\n\t\t\text = &b->exten[4];\n\t\t\twhile (ext < end && *ext != 0xff) {\n\t\t\t\tu8 *opt = ext++;\n\t\t\t\tif (*opt == 0)\t \n\t\t\t\t\tcontinue;\n\t\t\t\text += *ext + 1;\n\t\t\t\tif (ext >= end)\n\t\t\t\t\tbreak;\n\t\t\t\tswitch (*opt) {\n\t\t\t\tcase 53:\t \n\t\t\t\t\tif (opt[1])\n\t\t\t\t\t\tmt = opt[2];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 54:\t \n\t\t\t\t\tif (opt[1] >= 4)\n\t\t\t\t\t\tmemcpy(&server_id, opt + 2, 4);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpr_debug(\"DHCP: Got message type %d (%s)\\n\", mt, d->dev->name);\n\n\t\t\tswitch (mt) {\n\t\t\tcase DHCPOFFER:\n\t\t\t\t \n\t\t\t\tif (ic_myaddr != NONE)\n\t\t\t\t\tgoto drop_unlock;\n\n\t\t\t\t \n\t\t\t\tic_myaddr = b->your_ip;\n\t\t\t\tic_servaddr = server_id;\n\t\t\t\tpr_debug(\"DHCP: Offered address %pI4 by server %pI4\\n\",\n\t\t\t\t\t &ic_myaddr, &b->iph.saddr);\n\t\t\t\t \n\t\t\t\tif ((server_id != NONE) &&\n\t\t\t\t    (b->server_ip != server_id))\n\t\t\t\t\tb->server_ip = ic_servaddr;\n\t\t\t\tbreak;\n\n\t\t\tcase DHCPACK:\n\t\t\t\tif (memcmp(dev->dev_addr, b->hw_addr, dev->addr_len) != 0)\n\t\t\t\t\tgoto drop_unlock;\n\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tic_myaddr = NONE;\n\t\t\t\tic_servaddr = NONE;\n\t\t\t\tgoto drop_unlock;\n\t\t\t}\n\n\t\t\tic_dhcp_msgtype = mt;\n\n\t\t}\n#endif  \n\n\t\text = &b->exten[4];\n\t\twhile (ext < end && *ext != 0xff) {\n\t\t\tu8 *opt = ext++;\n\t\t\tif (*opt == 0)\t \n\t\t\t\tcontinue;\n\t\t\text += *ext + 1;\n\t\t\tif (ext < end)\n\t\t\t\tic_do_bootp_ext(opt);\n\t\t}\n\t}\n\n\t \n\tic_dev = d;\n\tic_myaddr = b->your_ip;\n\tic_servaddr = b->server_ip;\n\tic_addrservaddr = b->iph.saddr;\n\tif (ic_gateway == NONE && b->relay_ip)\n\t\tic_gateway = b->relay_ip;\n\tif (ic_nameservers[0] == NONE) {\n\t\tic_nameservers[0] = ic_servaddr;\n\t\tic_nameservers_fallback = 1;\n\t}\n\tic_got_reply = IC_BOOTP;\n\ndrop_unlock:\n\t \n\tspin_unlock(&ic_recv_lock);\n\ndrop:\n\t \n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\n\n#endif\n\n\n \n\n#ifdef IPCONFIG_DYNAMIC\n\nstatic int __init ic_dynamic(void)\n{\n\tint retries;\n\tstruct ic_device *d;\n\tunsigned long start_jiffies, timeout, jiff;\n\tint do_bootp = ic_proto_have_if & IC_BOOTP;\n\tint do_rarp = ic_proto_have_if & IC_RARP;\n\n\t \n\tif (!ic_proto_enabled) {\n\t\tpr_err(\"IP-Config: Incomplete network configuration information\\n\");\n\t\treturn -1;\n\t}\n\n#ifdef IPCONFIG_BOOTP\n\tif ((ic_proto_enabled ^ ic_proto_have_if) & IC_BOOTP)\n\t\tpr_err(\"DHCP/BOOTP: No suitable device found\\n\");\n#endif\n#ifdef IPCONFIG_RARP\n\tif ((ic_proto_enabled ^ ic_proto_have_if) & IC_RARP)\n\t\tpr_err(\"RARP: No suitable device found\\n\");\n#endif\n\n\tif (!ic_proto_have_if)\n\t\t \n\t\treturn -1;\n\n\t \n#ifdef IPCONFIG_BOOTP\n\tif (do_bootp)\n\t\tic_bootp_init();\n#endif\n#ifdef IPCONFIG_RARP\n\tif (do_rarp)\n\t\tic_rarp_init();\n#endif\n\n\t \n\tpr_notice(\"Sending %s%s%s requests .\",\n\t\t  do_bootp\n\t\t  ? ((ic_proto_enabled & IC_USE_DHCP) ? \"DHCP\" : \"BOOTP\") : \"\",\n\t\t  (do_bootp && do_rarp) ? \" and \" : \"\",\n\t\t  do_rarp ? \"RARP\" : \"\");\n\n\tstart_jiffies = jiffies;\n\td = ic_first_dev;\n\tretries = CONF_SEND_RETRIES;\n\tget_random_bytes(&timeout, sizeof(timeout));\n\ttimeout = CONF_BASE_TIMEOUT + (timeout % (unsigned int) CONF_TIMEOUT_RANDOM);\n\tfor (;;) {\n#ifdef IPCONFIG_BOOTP\n\t\tif (do_bootp && (d->able & IC_BOOTP))\n\t\t\tic_bootp_send_if(d, jiffies - start_jiffies);\n#endif\n#ifdef IPCONFIG_RARP\n\t\tif (do_rarp && (d->able & IC_RARP))\n\t\t\tic_rarp_send_if(d);\n#endif\n\n\t\tif (!d->next) {\n\t\t\tjiff = jiffies + timeout;\n\t\t\twhile (time_before(jiffies, jiff) && !ic_got_reply)\n\t\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n#ifdef IPCONFIG_DHCP\n\t\t \n\t\tif ((ic_got_reply & IC_BOOTP) &&\n\t\t    (ic_proto_enabled & IC_USE_DHCP) &&\n\t\t    ic_dhcp_msgtype != DHCPACK) {\n\t\t\tic_got_reply = 0;\n\t\t\t \n\t\t\td = ic_dev;\n\t\t\tpr_cont(\",\");\n\t\t\tcontinue;\n\t\t}\n#endif  \n\n\t\tif (ic_got_reply) {\n\t\t\tpr_cont(\" OK\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((d = d->next))\n\t\t\tcontinue;\n\n\t\tif (! --retries) {\n\t\t\tpr_cont(\" timed out!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\td = ic_first_dev;\n\n\t\ttimeout = timeout CONF_TIMEOUT_MULT;\n\t\tif (timeout > CONF_TIMEOUT_MAX)\n\t\t\ttimeout = CONF_TIMEOUT_MAX;\n\n\t\tpr_cont(\".\");\n\t}\n\n#ifdef IPCONFIG_BOOTP\n\tif (do_bootp)\n\t\tic_bootp_cleanup();\n#endif\n#ifdef IPCONFIG_RARP\n\tif (do_rarp)\n\t\tic_rarp_cleanup();\n#endif\n\n\tif (!ic_got_reply) {\n\t\tic_myaddr = NONE;\n\t\treturn -1;\n\t}\n\n\tpr_info(\"IP-Config: Got %s answer from %pI4, my address is %pI4\\n\",\n\t\t((ic_got_reply & IC_RARP) ? \"RARP\"\n\t\t: (ic_proto_enabled & IC_USE_DHCP) ? \"DHCP\" : \"BOOTP\"),\n\t\t&ic_addrservaddr, &ic_myaddr);\n\n\treturn 0;\n}\n\n#endif  \n\n#ifdef CONFIG_PROC_FS\n \nstatic struct proc_dir_entry *ipconfig_dir;\n\n \nstatic int pnp_seq_show(struct seq_file *seq, void *v)\n{\n\tint i;\n\n\tif (ic_proto_used & IC_PROTO)\n\t\tseq_printf(seq, \"#PROTO: %s\\n\",\n\t\t\t   (ic_proto_used & IC_RARP) ? \"RARP\"\n\t\t\t   : (ic_proto_used & IC_USE_DHCP) ? \"DHCP\" : \"BOOTP\");\n\telse\n\t\tseq_puts(seq, \"#MANUAL\\n\");\n\n\tif (ic_domain[0])\n\t\tseq_printf(seq,\n\t\t\t   \"domain %s\\n\", ic_domain);\n\tfor (i = 0; i < CONF_NAMESERVERS_MAX; i++) {\n\t\tif (ic_nameservers[i] != NONE)\n\t\t\tseq_printf(seq, \"nameserver %pI4\\n\",\n\t\t\t\t   &ic_nameservers[i]);\n\t}\n\tif (ic_servaddr != NONE)\n\t\tseq_printf(seq, \"bootserver %pI4\\n\",\n\t\t\t   &ic_servaddr);\n\treturn 0;\n}\n\n \nstatic int __init ipconfig_proc_net_init(void)\n{\n\tipconfig_dir = proc_net_mkdir(&init_net, \"ipconfig\", init_net.proc_net);\n\tif (!ipconfig_dir)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic int ipconfig_proc_net_create(const char *name,\n\t\t\t\t    const struct proc_ops *proc_ops)\n{\n\tchar *pname;\n\tstruct proc_dir_entry *p;\n\n\tif (!ipconfig_dir)\n\t\treturn -ENOMEM;\n\n\tpname = kasprintf(GFP_KERNEL, \"%s%s\", \"ipconfig/\", name);\n\tif (!pname)\n\t\treturn -ENOMEM;\n\n\tp = proc_create(pname, 0444, init_net.proc_net, proc_ops);\n\tkfree(pname);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic int ntp_servers_show(struct seq_file *seq, void *v)\n{\n\tint i;\n\n\tfor (i = 0; i < CONF_NTP_SERVERS_MAX; i++) {\n\t\tif (ic_ntp_servers[i] != NONE)\n\t\t\tseq_printf(seq, \"%pI4\\n\", &ic_ntp_servers[i]);\n\t}\n\treturn 0;\n}\nDEFINE_PROC_SHOW_ATTRIBUTE(ntp_servers);\n#endif  \n\n \n__be32 __init root_nfs_parse_addr(char *name)\n{\n\t__be32 addr;\n\tint octets = 0;\n\tchar *cp, *cq;\n\n\tcp = cq = name;\n\twhile (octets < 4) {\n\t\twhile (*cp >= '0' && *cp <= '9')\n\t\t\tcp++;\n\t\tif (cp == cq || cp - cq > 3)\n\t\t\tbreak;\n\t\tif (*cp == '.' || octets == 3)\n\t\t\toctets++;\n\t\tif (octets < 4)\n\t\t\tcp++;\n\t\tcq = cp;\n\t}\n\tif (octets == 4 && (*cp == ':' || *cp == '\\0')) {\n\t\tif (*cp == ':')\n\t\t\t*cp++ = '\\0';\n\t\taddr = in_aton(name);\n\t\tmemmove(name, cp, strlen(cp) + 1);\n\t} else\n\t\taddr = NONE;\n\n\treturn addr;\n}\n\n#define DEVICE_WAIT_MAX\t\t12  \n\nstatic int __init wait_for_devices(void)\n{\n\tint i;\n\tbool try_init_devs = true;\n\n\tfor (i = 0; i < DEVICE_WAIT_MAX; i++) {\n\t\tstruct net_device *dev;\n\t\tint found = 0;\n\n\t\t \n\t\twait_for_device_probe();\n\n\t\trtnl_lock();\n\t\tfor_each_netdev(&init_net, dev) {\n\t\t\tif (ic_is_init_dev(dev)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trtnl_unlock();\n\t\tif (found)\n\t\t\treturn 0;\n\t\tif (try_init_devs &&\n\t\t    (ROOT_DEV == Root_NFS || ROOT_DEV == Root_CIFS)) {\n\t\t\ttry_init_devs = false;\n\t\t\twait_for_init_devices_probe();\n\t\t}\n\t\tssleep(1);\n\t}\n\treturn -ENODEV;\n}\n\n \n\nstatic int __init ip_auto_config(void)\n{\n\t__be32 addr;\n#ifdef IPCONFIG_DYNAMIC\n\tint retries = CONF_OPEN_RETRIES;\n#endif\n\tint err;\n\tunsigned int i, count;\n\n\t \n\tif (ic_set_manually == 0) {\n\t\tic_nameservers_predef();\n\t\tic_ntp_servers_predef();\n\t}\n\n#ifdef CONFIG_PROC_FS\n\tproc_create_single(\"pnp\", 0444, init_net.proc_net, pnp_seq_show);\n\n\tif (ipconfig_proc_net_init() == 0)\n\t\tipconfig_proc_net_create(\"ntp_servers\", &ntp_servers_proc_ops);\n#endif  \n\n\tif (!ic_enable)\n\t\treturn 0;\n\n\tpr_debug(\"IP-Config: Entered.\\n\");\n#ifdef IPCONFIG_DYNAMIC\n try_try_again:\n#endif\n\t \n\terr = wait_for_devices();\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ic_open_devs();\n\tif (err)\n\t\treturn err;\n\n\t \n\tmsleep(CONF_POST_OPEN);\n\n\t \n\tif (ic_myaddr == NONE ||\n#if defined(CONFIG_ROOT_NFS) || defined(CONFIG_CIFS_ROOT)\n\t    (root_server_addr == NONE &&\n\t     ic_servaddr == NONE &&\n\t     (ROOT_DEV == Root_NFS || ROOT_DEV == Root_CIFS)) ||\n#endif\n\t    ic_first_dev->next) {\n#ifdef IPCONFIG_DYNAMIC\n\t\tif (ic_dynamic() < 0) {\n\t\t\tic_close_devs();\n\n\t\t\t \n#ifdef CONFIG_ROOT_NFS\n\t\t\tif (ROOT_DEV ==  Root_NFS) {\n\t\t\t\tpr_err(\"IP-Config: Retrying forever (NFS root)...\\n\");\n\t\t\t\tgoto try_try_again;\n\t\t\t}\n#endif\n#ifdef CONFIG_CIFS_ROOT\n\t\t\tif (ROOT_DEV == Root_CIFS) {\n\t\t\t\tpr_err(\"IP-Config: Retrying forever (CIFS root)...\\n\");\n\t\t\t\tgoto try_try_again;\n\t\t\t}\n#endif\n\n\t\t\tif (--retries) {\n\t\t\t\tpr_err(\"IP-Config: Reopening network devices...\\n\");\n\t\t\t\tgoto try_try_again;\n\t\t\t}\n\n\t\t\t \n\t\t\tpr_err(\"IP-Config: Auto-configuration of network failed\\n\");\n\t\t\treturn -1;\n\t\t}\n#else  \n\t\tpr_err(\"IP-Config: Incomplete network configuration information\\n\");\n\t\tic_close_devs();\n\t\treturn -1;\n#endif  \n\t} else {\n\t\t \n\t\tic_dev = ic_first_dev;\n\t}\n\n\taddr = root_nfs_parse_addr(root_server_path);\n\tif (root_server_addr == NONE)\n\t\troot_server_addr = addr;\n\n\t \n\tif (ic_defaults() < 0)\n\t\treturn -1;\n\n\t \n#ifdef IPCONFIG_DYNAMIC\n\tic_proto_used = ic_got_reply | (ic_proto_enabled & IC_USE_DHCP);\n#endif\n\n#ifndef IPCONFIG_SILENT\n\t \n\tpr_info(\"IP-Config: Complete:\\n\");\n\n\tpr_info(\"     device=%s, hwaddr=%*phC, ipaddr=%pI4, mask=%pI4, gw=%pI4\\n\",\n\t\tic_dev->dev->name, ic_dev->dev->addr_len, ic_dev->dev->dev_addr,\n\t\t&ic_myaddr, &ic_netmask, &ic_gateway);\n\tpr_info(\"     host=%s, domain=%s, nis-domain=%s\\n\",\n\t\tutsname()->nodename, ic_domain, utsname()->domainname);\n\tpr_info(\"     bootserver=%pI4, rootserver=%pI4, rootpath=%s\",\n\t\t&ic_servaddr, &root_server_addr, root_server_path);\n\tif (ic_dev_mtu)\n\t\tpr_cont(\", mtu=%d\", ic_dev_mtu);\n\t \n\tfor (i = 0, count = 0; i < CONF_NAMESERVERS_MAX; i++) {\n\t\tif (ic_nameservers[i] != NONE) {\n\t\t\tif (i == 0)\n\t\t\t\tpr_info(\"     nameserver%u=%pI4\",\n\t\t\t\t\ti, &ic_nameservers[i]);\n\t\t\telse\n\t\t\t\tpr_cont(\", nameserver%u=%pI4\",\n\t\t\t\t\ti, &ic_nameservers[i]);\n\n\t\t\tcount++;\n\t\t}\n\t\tif ((i + 1 == CONF_NAMESERVERS_MAX) && count > 0)\n\t\t\tpr_cont(\"\\n\");\n\t}\n\t \n\tfor (i = 0, count = 0; i < CONF_NTP_SERVERS_MAX; i++) {\n\t\tif (ic_ntp_servers[i] != NONE) {\n\t\t\tif (i == 0)\n\t\t\t\tpr_info(\"     ntpserver%u=%pI4\",\n\t\t\t\t\ti, &ic_ntp_servers[i]);\n\t\t\telse\n\t\t\t\tpr_cont(\", ntpserver%u=%pI4\",\n\t\t\t\t\ti, &ic_ntp_servers[i]);\n\n\t\t\tcount++;\n\t\t}\n\t\tif ((i + 1 == CONF_NTP_SERVERS_MAX) && count > 0)\n\t\t\tpr_cont(\"\\n\");\n\t}\n#endif  \n\n\t \n\tif (ic_setup_if() < 0 || ic_setup_routes() < 0)\n\t\terr = -1;\n\telse\n\t\terr = 0;\n\n\tic_close_devs();\n\n\treturn err;\n}\n\nlate_initcall(ip_auto_config);\n\n\n \nstatic int __init ic_proto_name(char *name)\n{\n\tif (!strcmp(name, \"on\") || !strcmp(name, \"any\")) {\n\t\treturn 1;\n\t}\n\tif (!strcmp(name, \"off\") || !strcmp(name, \"none\")) {\n\t\treturn 0;\n\t}\n#ifdef CONFIG_IP_PNP_DHCP\n\telse if (!strncmp(name, \"dhcp\", 4)) {\n\t\tchar *client_id;\n\n\t\tic_proto_enabled &= ~IC_RARP;\n\t\tclient_id = strstr(name, \"dhcp,\");\n\t\tif (client_id) {\n\t\t\tchar *v;\n\n\t\t\tclient_id = client_id + 5;\n\t\t\tv = strchr(client_id, ',');\n\t\t\tif (!v)\n\t\t\t\treturn 1;\n\t\t\t*v = 0;\n\t\t\tif (kstrtou8(client_id, 0, dhcp_client_identifier))\n\t\t\t\tpr_debug(\"DHCP: Invalid client identifier type\\n\");\n\t\t\tstrncpy(dhcp_client_identifier + 1, v + 1, 251);\n\t\t\t*v = ',';\n\t\t}\n\t\treturn 1;\n\t}\n#endif\n#ifdef CONFIG_IP_PNP_BOOTP\n\telse if (!strcmp(name, \"bootp\")) {\n\t\tic_proto_enabled &= ~(IC_RARP | IC_USE_DHCP);\n\t\treturn 1;\n\t}\n#endif\n#ifdef CONFIG_IP_PNP_RARP\n\telse if (!strcmp(name, \"rarp\")) {\n\t\tic_proto_enabled &= ~(IC_BOOTP | IC_USE_DHCP);\n\t\treturn 1;\n\t}\n#endif\n#ifdef IPCONFIG_DYNAMIC\n\telse if (!strcmp(name, \"both\")) {\n\t\tic_proto_enabled &= ~IC_USE_DHCP;  \n\t\treturn 1;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int __init ip_auto_config_setup(char *addrs)\n{\n\tchar *cp, *ip, *dp;\n\tint num = 0;\n\n\tic_set_manually = 1;\n\tic_enable = 1;\n\n\t \n\tif (ic_proto_name(addrs))\n\t\treturn 1;\n\n\t \n\tif (*addrs == 0 ||\n\t    strcmp(addrs, \"off\") == 0 ||\n\t    strcmp(addrs, \"none\") == 0) {\n\t\tic_enable = 0;\n\t\treturn 1;\n\t}\n\n\t \n\tic_nameservers_predef();\n\tic_ntp_servers_predef();\n\n\t \n\tip = addrs;\n\twhile (ip && *ip) {\n\t\tif ((cp = strchr(ip, ':')))\n\t\t\t*cp++ = '\\0';\n\t\tif (strlen(ip) > 0) {\n\t\t\tpr_debug(\"IP-Config: Parameter #%d: `%s'\\n\", num, ip);\n\t\t\tswitch (num) {\n\t\t\tcase 0:\n\t\t\t\tif ((ic_myaddr = in_aton(ip)) == ANY)\n\t\t\t\t\tic_myaddr = NONE;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif ((ic_servaddr = in_aton(ip)) == ANY)\n\t\t\t\t\tic_servaddr = NONE;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif ((ic_gateway = in_aton(ip)) == ANY)\n\t\t\t\t\tic_gateway = NONE;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif ((ic_netmask = in_aton(ip)) == ANY)\n\t\t\t\t\tic_netmask = NONE;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif ((dp = strchr(ip, '.'))) {\n\t\t\t\t\t*dp++ = '\\0';\n\t\t\t\t\tstrscpy(utsname()->domainname, dp,\n\t\t\t\t\t\tsizeof(utsname()->domainname));\n\t\t\t\t}\n\t\t\t\tstrscpy(utsname()->nodename, ip,\n\t\t\t\t\tsizeof(utsname()->nodename));\n\t\t\t\tic_host_name_set = 1;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tstrscpy(user_dev_name, ip, sizeof(user_dev_name));\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (ic_proto_name(ip) == 0 &&\n\t\t\t\t    ic_myaddr == NONE) {\n\t\t\t\t\tic_enable = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tif (CONF_NAMESERVERS_MAX >= 1) {\n\t\t\t\t\tic_nameservers[0] = in_aton(ip);\n\t\t\t\t\tif (ic_nameservers[0] == ANY)\n\t\t\t\t\t\tic_nameservers[0] = NONE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tif (CONF_NAMESERVERS_MAX >= 2) {\n\t\t\t\t\tic_nameservers[1] = in_aton(ip);\n\t\t\t\t\tif (ic_nameservers[1] == ANY)\n\t\t\t\t\t\tic_nameservers[1] = NONE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (CONF_NTP_SERVERS_MAX >= 1) {\n\t\t\t\t\tic_ntp_servers[0] = in_aton(ip);\n\t\t\t\t\tif (ic_ntp_servers[0] == ANY)\n\t\t\t\t\t\tic_ntp_servers[0] = NONE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tip = cp;\n\t\tnum++;\n\t}\n\n\treturn 1;\n}\n__setup(\"ip=\", ip_auto_config_setup);\n\nstatic int __init nfsaddrs_config_setup(char *addrs)\n{\n\treturn ip_auto_config_setup(addrs);\n}\n__setup(\"nfsaddrs=\", nfsaddrs_config_setup);\n\nstatic int __init vendor_class_identifier_setup(char *addrs)\n{\n\tif (strscpy(vendor_class_identifier, addrs,\n\t\t    sizeof(vendor_class_identifier))\n\t    >= sizeof(vendor_class_identifier))\n\t\tpr_warn(\"DHCP: vendorclass too long, truncated to \\\"%s\\\"\\n\",\n\t\t\tvendor_class_identifier);\n\treturn 1;\n}\n__setup(\"dhcpclass=\", vendor_class_identifier_setup);\n\nstatic int __init set_carrier_timeout(char *str)\n{\n\tssize_t ret;\n\n\tif (!str)\n\t\treturn 0;\n\n\tret = kstrtouint(str, 0, &carrier_timeout);\n\tif (ret)\n\t\treturn 0;\n\n\treturn 1;\n}\n__setup(\"carrier_timeout=\", set_carrier_timeout);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}