{
  "module_name": "tcp_dctcp.c",
  "hash_id": "6713b382bc2ca9f9bfc3b046b2789a2a9507ecbac9416550e8a968000feb5676",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_dctcp.c",
  "human_readable_source": "\n \n\n#include <linux/btf.h>\n#include <linux/btf_ids.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <net/tcp.h>\n#include <linux/inet_diag.h>\n#include \"tcp_dctcp.h\"\n\n#define DCTCP_MAX_ALPHA\t1024U\n\nstruct dctcp {\n\tu32 old_delivered;\n\tu32 old_delivered_ce;\n\tu32 prior_rcv_nxt;\n\tu32 dctcp_alpha;\n\tu32 next_seq;\n\tu32 ce_state;\n\tu32 loss_cwnd;\n\tstruct tcp_plb_state plb;\n};\n\nstatic unsigned int dctcp_shift_g __read_mostly = 4;  \nmodule_param(dctcp_shift_g, uint, 0644);\nMODULE_PARM_DESC(dctcp_shift_g, \"parameter g for updating dctcp_alpha\");\n\nstatic unsigned int dctcp_alpha_on_init __read_mostly = DCTCP_MAX_ALPHA;\nmodule_param(dctcp_alpha_on_init, uint, 0644);\nMODULE_PARM_DESC(dctcp_alpha_on_init, \"parameter for initial alpha value\");\n\nstatic struct tcp_congestion_ops dctcp_reno;\n\nstatic void dctcp_reset(const struct tcp_sock *tp, struct dctcp *ca)\n{\n\tca->next_seq = tp->snd_nxt;\n\n\tca->old_delivered = tp->delivered;\n\tca->old_delivered_ce = tp->delivered_ce;\n}\n\n__bpf_kfunc static void dctcp_init(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\tif ((tp->ecn_flags & TCP_ECN_OK) ||\n\t    (sk->sk_state == TCP_LISTEN ||\n\t     sk->sk_state == TCP_CLOSE)) {\n\t\tstruct dctcp *ca = inet_csk_ca(sk);\n\n\t\tca->prior_rcv_nxt = tp->rcv_nxt;\n\n\t\tca->dctcp_alpha = min(dctcp_alpha_on_init, DCTCP_MAX_ALPHA);\n\n\t\tca->loss_cwnd = 0;\n\t\tca->ce_state = 0;\n\n\t\tdctcp_reset(tp, ca);\n\t\ttcp_plb_init(sk, &ca->plb);\n\n\t\treturn;\n\t}\n\n\t \n\tinet_csk(sk)->icsk_ca_ops = &dctcp_reno;\n\tINET_ECN_dontxmit(sk);\n}\n\n__bpf_kfunc static u32 dctcp_ssthresh(struct sock *sk)\n{\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tca->loss_cwnd = tcp_snd_cwnd(tp);\n\treturn max(tcp_snd_cwnd(tp) - ((tcp_snd_cwnd(tp) * ca->dctcp_alpha) >> 11U), 2U);\n}\n\n__bpf_kfunc static void dctcp_update_alpha(struct sock *sk, u32 flags)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\n\t \n\tif (!before(tp->snd_una, ca->next_seq)) {\n\t\tu32 delivered = tp->delivered - ca->old_delivered;\n\t\tu32 delivered_ce = tp->delivered_ce - ca->old_delivered_ce;\n\t\tu32 alpha = ca->dctcp_alpha;\n\t\tu32 ce_ratio = 0;\n\n\t\tif (delivered > 0) {\n\t\t\t \n\t\t\tif (delivered_ce > 0)\n\t\t\t\tce_ratio = (delivered_ce << TCP_PLB_SCALE) / delivered;\n\t\t\ttcp_plb_update_state(sk, &ca->plb, (int)ce_ratio);\n\t\t\ttcp_plb_check_rehash(sk, &ca->plb);\n\t\t}\n\n\t\t \n\n\t\talpha -= min_not_zero(alpha, alpha >> dctcp_shift_g);\n\t\tif (delivered_ce) {\n\n\t\t\t \n\t\t\tdelivered_ce <<= (10 - dctcp_shift_g);\n\t\t\tdelivered_ce /= max(1U, delivered);\n\n\t\t\talpha = min(alpha + delivered_ce, DCTCP_MAX_ALPHA);\n\t\t}\n\t\t \n\t\tWRITE_ONCE(ca->dctcp_alpha, alpha);\n\t\tdctcp_reset(tp, ca);\n\t}\n}\n\nstatic void dctcp_react_to_loss(struct sock *sk)\n{\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tca->loss_cwnd = tcp_snd_cwnd(tp);\n\ttp->snd_ssthresh = max(tcp_snd_cwnd(tp) >> 1U, 2U);\n}\n\n__bpf_kfunc static void dctcp_state(struct sock *sk, u8 new_state)\n{\n\tif (new_state == TCP_CA_Recovery &&\n\t    new_state != inet_csk(sk)->icsk_ca_state)\n\t\tdctcp_react_to_loss(sk);\n\t \n}\n\n__bpf_kfunc static void dctcp_cwnd_event(struct sock *sk, enum tcp_ca_event ev)\n{\n\tstruct dctcp *ca = inet_csk_ca(sk);\n\n\tswitch (ev) {\n\tcase CA_EVENT_ECN_IS_CE:\n\tcase CA_EVENT_ECN_NO_CE:\n\t\tdctcp_ece_ack_update(sk, ev, &ca->prior_rcv_nxt, &ca->ce_state);\n\t\tbreak;\n\tcase CA_EVENT_LOSS:\n\t\ttcp_plb_update_state_upon_rto(sk, &ca->plb);\n\t\tdctcp_react_to_loss(sk);\n\t\tbreak;\n\tcase CA_EVENT_TX_START:\n\t\ttcp_plb_check_rehash(sk, &ca->plb);  \n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic size_t dctcp_get_info(struct sock *sk, u32 ext, int *attr,\n\t\t\t     union tcp_cc_info *info)\n{\n\tconst struct dctcp *ca = inet_csk_ca(sk);\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t \n\tif (ext & (1 << (INET_DIAG_DCTCPINFO - 1)) ||\n\t    ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tmemset(&info->dctcp, 0, sizeof(info->dctcp));\n\t\tif (inet_csk(sk)->icsk_ca_ops != &dctcp_reno) {\n\t\t\tinfo->dctcp.dctcp_enabled = 1;\n\t\t\tinfo->dctcp.dctcp_ce_state = (u16) ca->ce_state;\n\t\t\tinfo->dctcp.dctcp_alpha = ca->dctcp_alpha;\n\t\t\tinfo->dctcp.dctcp_ab_ecn = tp->mss_cache *\n\t\t\t\t\t\t   (tp->delivered_ce - ca->old_delivered_ce);\n\t\t\tinfo->dctcp.dctcp_ab_tot = tp->mss_cache *\n\t\t\t\t\t\t   (tp->delivered - ca->old_delivered);\n\t\t}\n\n\t\t*attr = INET_DIAG_DCTCPINFO;\n\t\treturn sizeof(info->dctcp);\n\t}\n\treturn 0;\n}\n\n__bpf_kfunc static u32 dctcp_cwnd_undo(struct sock *sk)\n{\n\tconst struct dctcp *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\treturn max(tcp_snd_cwnd(tp), ca->loss_cwnd);\n}\n\nstatic struct tcp_congestion_ops dctcp __read_mostly = {\n\t.init\t\t= dctcp_init,\n\t.in_ack_event   = dctcp_update_alpha,\n\t.cwnd_event\t= dctcp_cwnd_event,\n\t.ssthresh\t= dctcp_ssthresh,\n\t.cong_avoid\t= tcp_reno_cong_avoid,\n\t.undo_cwnd\t= dctcp_cwnd_undo,\n\t.set_state\t= dctcp_state,\n\t.get_info\t= dctcp_get_info,\n\t.flags\t\t= TCP_CONG_NEEDS_ECN,\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"dctcp\",\n};\n\nstatic struct tcp_congestion_ops dctcp_reno __read_mostly = {\n\t.ssthresh\t= tcp_reno_ssthresh,\n\t.cong_avoid\t= tcp_reno_cong_avoid,\n\t.undo_cwnd\t= tcp_reno_undo_cwnd,\n\t.get_info\t= dctcp_get_info,\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"dctcp-reno\",\n};\n\nBTF_SET8_START(tcp_dctcp_check_kfunc_ids)\n#ifdef CONFIG_X86\n#ifdef CONFIG_DYNAMIC_FTRACE\nBTF_ID_FLAGS(func, dctcp_init)\nBTF_ID_FLAGS(func, dctcp_update_alpha)\nBTF_ID_FLAGS(func, dctcp_cwnd_event)\nBTF_ID_FLAGS(func, dctcp_ssthresh)\nBTF_ID_FLAGS(func, dctcp_cwnd_undo)\nBTF_ID_FLAGS(func, dctcp_state)\n#endif\n#endif\nBTF_SET8_END(tcp_dctcp_check_kfunc_ids)\n\nstatic const struct btf_kfunc_id_set tcp_dctcp_kfunc_set = {\n\t.owner = THIS_MODULE,\n\t.set   = &tcp_dctcp_check_kfunc_ids,\n};\n\nstatic int __init dctcp_register(void)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct dctcp) > ICSK_CA_PRIV_SIZE);\n\n\tret = register_btf_kfunc_id_set(BPF_PROG_TYPE_STRUCT_OPS, &tcp_dctcp_kfunc_set);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn tcp_register_congestion_control(&dctcp);\n}\n\nstatic void __exit dctcp_unregister(void)\n{\n\ttcp_unregister_congestion_control(&dctcp);\n}\n\nmodule_init(dctcp_register);\nmodule_exit(dctcp_unregister);\n\nMODULE_AUTHOR(\"Daniel Borkmann <dborkman@redhat.com>\");\nMODULE_AUTHOR(\"Florian Westphal <fw@strlen.de>\");\nMODULE_AUTHOR(\"Glenn Judd <glenn.judd@morganstanley.com>\");\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DataCenter TCP (DCTCP)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}