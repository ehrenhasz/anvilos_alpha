{
  "module_name": "tcp_ulp.c",
  "hash_id": "f6691facebbff7791e7d18d821799a9cf2607e3d24182a7b1c32658473ecf22c",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_ulp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/gfp.h>\n#include <net/tcp.h>\n\nstatic DEFINE_SPINLOCK(tcp_ulp_list_lock);\nstatic LIST_HEAD(tcp_ulp_list);\n\n \nstatic struct tcp_ulp_ops *tcp_ulp_find(const char *name)\n{\n\tstruct tcp_ulp_ops *e;\n\n\tlist_for_each_entry_rcu(e, &tcp_ulp_list, list,\n\t\t\t\tlockdep_is_held(&tcp_ulp_list_lock)) {\n\t\tif (strcmp(e->name, name) == 0)\n\t\t\treturn e;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct tcp_ulp_ops *__tcp_ulp_find_autoload(const char *name)\n{\n\tconst struct tcp_ulp_ops *ulp = NULL;\n\n\trcu_read_lock();\n\tulp = tcp_ulp_find(name);\n\n#ifdef CONFIG_MODULES\n\tif (!ulp && capable(CAP_NET_ADMIN)) {\n\t\trcu_read_unlock();\n\t\trequest_module(\"tcp-ulp-%s\", name);\n\t\trcu_read_lock();\n\t\tulp = tcp_ulp_find(name);\n\t}\n#endif\n\tif (!ulp || !try_module_get(ulp->owner))\n\t\tulp = NULL;\n\n\trcu_read_unlock();\n\treturn ulp;\n}\n\n \nint tcp_register_ulp(struct tcp_ulp_ops *ulp)\n{\n\tint ret = 0;\n\n\tspin_lock(&tcp_ulp_list_lock);\n\tif (tcp_ulp_find(ulp->name))\n\t\tret = -EEXIST;\n\telse\n\t\tlist_add_tail_rcu(&ulp->list, &tcp_ulp_list);\n\tspin_unlock(&tcp_ulp_list_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tcp_register_ulp);\n\nvoid tcp_unregister_ulp(struct tcp_ulp_ops *ulp)\n{\n\tspin_lock(&tcp_ulp_list_lock);\n\tlist_del_rcu(&ulp->list);\n\tspin_unlock(&tcp_ulp_list_lock);\n\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL_GPL(tcp_unregister_ulp);\n\n \nvoid tcp_get_available_ulp(char *buf, size_t maxlen)\n{\n\tstruct tcp_ulp_ops *ulp_ops;\n\tsize_t offs = 0;\n\n\t*buf = '\\0';\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ulp_ops, &tcp_ulp_list, list) {\n\t\toffs += snprintf(buf + offs, maxlen - offs,\n\t\t\t\t \"%s%s\",\n\t\t\t\t offs == 0 ? \"\" : \" \", ulp_ops->name);\n\n\t\tif (WARN_ON_ONCE(offs >= maxlen))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}\n\nvoid tcp_update_ulp(struct sock *sk, struct proto *proto,\n\t\t    void (*write_space)(struct sock *sk))\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ulp_ops->update)\n\t\ticsk->icsk_ulp_ops->update(sk, proto, write_space);\n}\n\nvoid tcp_cleanup_ulp(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\t \n\tif (!icsk->icsk_ulp_ops)\n\t\treturn;\n\n\tif (icsk->icsk_ulp_ops->release)\n\t\ticsk->icsk_ulp_ops->release(sk);\n\tmodule_put(icsk->icsk_ulp_ops->owner);\n\n\ticsk->icsk_ulp_ops = NULL;\n}\n\nstatic int __tcp_set_ulp(struct sock *sk, const struct tcp_ulp_ops *ulp_ops)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tint err;\n\n\terr = -EEXIST;\n\tif (icsk->icsk_ulp_ops)\n\t\tgoto out_err;\n\n\tif (sk->sk_socket)\n\t\tclear_bit(SOCK_SUPPORT_ZC, &sk->sk_socket->flags);\n\n\terr = -ENOTCONN;\n\tif (!ulp_ops->clone && sk->sk_state == TCP_LISTEN)\n\t\tgoto out_err;\n\n\terr = ulp_ops->init(sk);\n\tif (err)\n\t\tgoto out_err;\n\n\ticsk->icsk_ulp_ops = ulp_ops;\n\treturn 0;\nout_err:\n\tmodule_put(ulp_ops->owner);\n\treturn err;\n}\n\nint tcp_set_ulp(struct sock *sk, const char *name)\n{\n\tconst struct tcp_ulp_ops *ulp_ops;\n\n\tsock_owned_by_me(sk);\n\n\tulp_ops = __tcp_ulp_find_autoload(name);\n\tif (!ulp_ops)\n\t\treturn -ENOENT;\n\n\treturn __tcp_set_ulp(sk, ulp_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}