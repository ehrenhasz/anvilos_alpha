{
  "module_name": "tcp_vegas.c",
  "hash_id": "08aea3e483d745a062734fdca1b2260360af885654a2e2cbe2dcf9f1d7cbf6a9",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_vegas.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/inet_diag.h>\n\n#include <net/tcp.h>\n\n#include \"tcp_vegas.h\"\n\nstatic int alpha = 2;\nstatic int beta  = 4;\nstatic int gamma = 1;\n\nmodule_param(alpha, int, 0644);\nMODULE_PARM_DESC(alpha, \"lower bound of packets in network\");\nmodule_param(beta, int, 0644);\nMODULE_PARM_DESC(beta, \"upper bound of packets in network\");\nmodule_param(gamma, int, 0644);\nMODULE_PARM_DESC(gamma, \"limit on increase (scale by 2)\");\n\n \nstatic void vegas_enable(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct vegas *vegas = inet_csk_ca(sk);\n\n\t \n\tvegas->doing_vegas_now = 1;\n\n\t \n\tvegas->beg_snd_nxt = tp->snd_nxt;\n\n\tvegas->cntRTT = 0;\n\tvegas->minRTT = 0x7fffffff;\n}\n\n \nstatic inline void vegas_disable(struct sock *sk)\n{\n\tstruct vegas *vegas = inet_csk_ca(sk);\n\n\tvegas->doing_vegas_now = 0;\n}\n\nvoid tcp_vegas_init(struct sock *sk)\n{\n\tstruct vegas *vegas = inet_csk_ca(sk);\n\n\tvegas->baseRTT = 0x7fffffff;\n\tvegas_enable(sk);\n}\nEXPORT_SYMBOL_GPL(tcp_vegas_init);\n\n \nvoid tcp_vegas_pkts_acked(struct sock *sk, const struct ack_sample *sample)\n{\n\tstruct vegas *vegas = inet_csk_ca(sk);\n\tu32 vrtt;\n\n\tif (sample->rtt_us < 0)\n\t\treturn;\n\n\t \n\tvrtt = sample->rtt_us + 1;\n\n\t \n\tif (vrtt < vegas->baseRTT)\n\t\tvegas->baseRTT = vrtt;\n\n\t \n\tvegas->minRTT = min(vegas->minRTT, vrtt);\n\tvegas->cntRTT++;\n}\nEXPORT_SYMBOL_GPL(tcp_vegas_pkts_acked);\n\nvoid tcp_vegas_state(struct sock *sk, u8 ca_state)\n{\n\tif (ca_state == TCP_CA_Open)\n\t\tvegas_enable(sk);\n\telse\n\t\tvegas_disable(sk);\n}\nEXPORT_SYMBOL_GPL(tcp_vegas_state);\n\n \nvoid tcp_vegas_cwnd_event(struct sock *sk, enum tcp_ca_event event)\n{\n\tif (event == CA_EVENT_CWND_RESTART ||\n\t    event == CA_EVENT_TX_START)\n\t\ttcp_vegas_init(sk);\n}\nEXPORT_SYMBOL_GPL(tcp_vegas_cwnd_event);\n\nstatic inline u32 tcp_vegas_ssthresh(struct tcp_sock *tp)\n{\n\treturn  min(tp->snd_ssthresh, tcp_snd_cwnd(tp));\n}\n\nstatic void tcp_vegas_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct vegas *vegas = inet_csk_ca(sk);\n\n\tif (!vegas->doing_vegas_now) {\n\t\ttcp_reno_cong_avoid(sk, ack, acked);\n\t\treturn;\n\t}\n\n\tif (after(ack, vegas->beg_snd_nxt)) {\n\t\t \n\n\t\t \n\t\tvegas->beg_snd_nxt  = tp->snd_nxt;\n\n\t\t \n\n\t\tif (vegas->cntRTT <= 2) {\n\t\t\t \n\t\t\ttcp_reno_cong_avoid(sk, ack, acked);\n\t\t} else {\n\t\t\tu32 rtt, diff;\n\t\t\tu64 target_cwnd;\n\n\t\t\t \n\n\t\t\t \n\t\t\trtt = vegas->minRTT;\n\n\t\t\t \n\t\t\ttarget_cwnd = (u64)tcp_snd_cwnd(tp) * vegas->baseRTT;\n\t\t\tdo_div(target_cwnd, rtt);\n\n\t\t\t \n\t\t\tdiff = tcp_snd_cwnd(tp) * (rtt-vegas->baseRTT) / vegas->baseRTT;\n\n\t\t\tif (diff > gamma && tcp_in_slow_start(tp)) {\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\ttcp_snd_cwnd_set(tp, min(tcp_snd_cwnd(tp),\n\t\t\t\t\t\t\t (u32)target_cwnd + 1));\n\t\t\t\ttp->snd_ssthresh = tcp_vegas_ssthresh(tp);\n\n\t\t\t} else if (tcp_in_slow_start(tp)) {\n\t\t\t\t \n\t\t\t\ttcp_slow_start(tp, acked);\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tif (diff > beta) {\n\t\t\t\t\t \n\t\t\t\t\ttcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) - 1);\n\t\t\t\t\ttp->snd_ssthresh\n\t\t\t\t\t\t= tcp_vegas_ssthresh(tp);\n\t\t\t\t} else if (diff < alpha) {\n\t\t\t\t\t \n\t\t\t\t\ttcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) + 1);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tcp_snd_cwnd(tp) < 2)\n\t\t\t\ttcp_snd_cwnd_set(tp, 2);\n\t\t\telse if (tcp_snd_cwnd(tp) > tp->snd_cwnd_clamp)\n\t\t\t\ttcp_snd_cwnd_set(tp, tp->snd_cwnd_clamp);\n\n\t\t\ttp->snd_ssthresh = tcp_current_ssthresh(sk);\n\t\t}\n\n\t\t \n\t\tvegas->cntRTT = 0;\n\t\tvegas->minRTT = 0x7fffffff;\n\t}\n\t \n\telse if (tcp_in_slow_start(tp))\n\t\ttcp_slow_start(tp, acked);\n}\n\n \nsize_t tcp_vegas_get_info(struct sock *sk, u32 ext, int *attr,\n\t\t\t  union tcp_cc_info *info)\n{\n\tconst struct vegas *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tinfo->vegas.tcpv_enabled = ca->doing_vegas_now;\n\t\tinfo->vegas.tcpv_rttcnt = ca->cntRTT;\n\t\tinfo->vegas.tcpv_rtt = ca->baseRTT;\n\t\tinfo->vegas.tcpv_minrtt = ca->minRTT;\n\n\t\t*attr = INET_DIAG_VEGASINFO;\n\t\treturn sizeof(struct tcpvegas_info);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tcp_vegas_get_info);\n\nstatic struct tcp_congestion_ops tcp_vegas __read_mostly = {\n\t.init\t\t= tcp_vegas_init,\n\t.ssthresh\t= tcp_reno_ssthresh,\n\t.undo_cwnd\t= tcp_reno_undo_cwnd,\n\t.cong_avoid\t= tcp_vegas_cong_avoid,\n\t.pkts_acked\t= tcp_vegas_pkts_acked,\n\t.set_state\t= tcp_vegas_state,\n\t.cwnd_event\t= tcp_vegas_cwnd_event,\n\t.get_info\t= tcp_vegas_get_info,\n\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"vegas\",\n};\n\nstatic int __init tcp_vegas_register(void)\n{\n\tBUILD_BUG_ON(sizeof(struct vegas) > ICSK_CA_PRIV_SIZE);\n\ttcp_register_congestion_control(&tcp_vegas);\n\treturn 0;\n}\n\nstatic void __exit tcp_vegas_unregister(void)\n{\n\ttcp_unregister_congestion_control(&tcp_vegas);\n}\n\nmodule_init(tcp_vegas_register);\nmodule_exit(tcp_vegas_unregister);\n\nMODULE_AUTHOR(\"Stephen Hemminger\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TCP Vegas\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}