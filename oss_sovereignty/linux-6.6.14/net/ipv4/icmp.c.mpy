{
  "module_name": "icmp.c",
  "hash_id": "c111bc762b024e96c2989152ae27ec53124eb86e7b1aa2567f9e2d4587a78fde",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/icmp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/string.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/slab.h>\n#include <net/snmp.h>\n#include <net/ip.h>\n#include <net/route.h>\n#include <net/protocol.h>\n#include <net/icmp.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/raw.h>\n#include <net/ping.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/init.h>\n#include <linux/uaccess.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <net/inet_common.h>\n#include <net/ip_fib.h>\n#include <net/l3mdev.h>\n\n \n\nstruct icmp_bxm {\n\tstruct sk_buff *skb;\n\tint offset;\n\tint data_len;\n\n\tstruct {\n\t\tstruct icmphdr icmph;\n\t\t__be32\t       times[3];\n\t} data;\n\tint head_len;\n\tstruct ip_options_data replyopts;\n};\n\n \n \n\nconst struct icmp_err icmp_err_convert[] = {\n\t{\n\t\t.errno = ENETUNREACH,\t \n\t\t.fatal = 0,\n\t},\n\t{\n\t\t.errno = EHOSTUNREACH,\t \n\t\t.fatal = 0,\n\t},\n\t{\n\t\t.errno = ENOPROTOOPT\t ,\n\t\t.fatal = 1,\n\t},\n\t{\n\t\t.errno = ECONNREFUSED,\t \n\t\t.fatal = 1,\n\t},\n\t{\n\t\t.errno = EMSGSIZE,\t \n\t\t.fatal = 0,\n\t},\n\t{\n\t\t.errno = EOPNOTSUPP,\t \n\t\t.fatal = 0,\n\t},\n\t{\n\t\t.errno = ENETUNREACH,\t \n\t\t.fatal = 1,\n\t},\n\t{\n\t\t.errno = EHOSTDOWN,\t \n\t\t.fatal = 1,\n\t},\n\t{\n\t\t.errno = ENONET,\t \n\t\t.fatal = 1,\n\t},\n\t{\n\t\t.errno = ENETUNREACH,\t \n\t\t.fatal = 1,\n\t},\n\t{\n\t\t.errno = EHOSTUNREACH,\t \n\t\t.fatal = 1,\n\t},\n\t{\n\t\t.errno = ENETUNREACH,\t \n\t\t.fatal = 0,\n\t},\n\t{\n\t\t.errno = EHOSTUNREACH,\t \n\t\t.fatal = 0,\n\t},\n\t{\n\t\t.errno = EHOSTUNREACH,\t \n\t\t.fatal = 1,\n\t},\n\t{\n\t\t.errno = EHOSTUNREACH,\t \n\t\t.fatal = 1,\n\t},\n\t{\n\t\t.errno = EHOSTUNREACH,\t \n\t\t.fatal = 1,\n\t},\n};\nEXPORT_SYMBOL(icmp_err_convert);\n\n \n\nstruct icmp_control {\n\tenum skb_drop_reason (*handler)(struct sk_buff *skb);\n\tshort   error;\t\t \n};\n\nstatic const struct icmp_control icmp_pointers[NR_ICMP_TYPES+1];\n\nstatic DEFINE_PER_CPU(struct sock *, ipv4_icmp_sk);\n\n \nstatic inline struct sock *icmp_xmit_lock(struct net *net)\n{\n\tstruct sock *sk;\n\n\tsk = this_cpu_read(ipv4_icmp_sk);\n\n\tif (unlikely(!spin_trylock(&sk->sk_lock.slock))) {\n\t\t \n\t\treturn NULL;\n\t}\n\tsock_net_set(sk, net);\n\treturn sk;\n}\n\nstatic inline void icmp_xmit_unlock(struct sock *sk)\n{\n\tsock_net_set(sk, &init_net);\n\tspin_unlock(&sk->sk_lock.slock);\n}\n\nint sysctl_icmp_msgs_per_sec __read_mostly = 1000;\nint sysctl_icmp_msgs_burst __read_mostly = 50;\n\nstatic struct {\n\tspinlock_t\tlock;\n\tu32\t\tcredit;\n\tu32\t\tstamp;\n} icmp_global = {\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(icmp_global.lock),\n};\n\n \nbool icmp_global_allow(void)\n{\n\tu32 credit, delta, incr = 0, now = (u32)jiffies;\n\tbool rc = false;\n\n\t \n\tif (!READ_ONCE(icmp_global.credit)) {\n\t\tdelta = min_t(u32, now - READ_ONCE(icmp_global.stamp), HZ);\n\t\tif (delta < HZ / 50)\n\t\t\treturn false;\n\t}\n\n\tspin_lock(&icmp_global.lock);\n\tdelta = min_t(u32, now - icmp_global.stamp, HZ);\n\tif (delta >= HZ / 50) {\n\t\tincr = READ_ONCE(sysctl_icmp_msgs_per_sec) * delta / HZ;\n\t\tif (incr)\n\t\t\tWRITE_ONCE(icmp_global.stamp, now);\n\t}\n\tcredit = min_t(u32, icmp_global.credit + incr,\n\t\t       READ_ONCE(sysctl_icmp_msgs_burst));\n\tif (credit) {\n\t\t \n\t\tcredit = max_t(int, credit - get_random_u32_below(3), 0);\n\t\trc = true;\n\t}\n\tWRITE_ONCE(icmp_global.credit, credit);\n\tspin_unlock(&icmp_global.lock);\n\treturn rc;\n}\nEXPORT_SYMBOL(icmp_global_allow);\n\nstatic bool icmpv4_mask_allow(struct net *net, int type, int code)\n{\n\tif (type > NR_ICMP_TYPES)\n\t\treturn true;\n\n\t \n\tif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED)\n\t\treturn true;\n\n\t \n\tif (!((1 << type) & READ_ONCE(net->ipv4.sysctl_icmp_ratemask)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool icmpv4_global_allow(struct net *net, int type, int code)\n{\n\tif (icmpv4_mask_allow(net, type, code))\n\t\treturn true;\n\n\tif (icmp_global_allow())\n\t\treturn true;\n\n\t__ICMP_INC_STATS(net, ICMP_MIB_RATELIMITGLOBAL);\n\treturn false;\n}\n\n \n\nstatic bool icmpv4_xrlim_allow(struct net *net, struct rtable *rt,\n\t\t\t       struct flowi4 *fl4, int type, int code)\n{\n\tstruct dst_entry *dst = &rt->dst;\n\tstruct inet_peer *peer;\n\tbool rc = true;\n\tint vif;\n\n\tif (icmpv4_mask_allow(net, type, code))\n\t\tgoto out;\n\n\t \n\tif (dst->dev && (dst->dev->flags&IFF_LOOPBACK))\n\t\tgoto out;\n\n\tvif = l3mdev_master_ifindex(dst->dev);\n\tpeer = inet_getpeer_v4(net->ipv4.peers, fl4->daddr, vif, 1);\n\trc = inet_peer_xrlim_allow(peer,\n\t\t\t\t   READ_ONCE(net->ipv4.sysctl_icmp_ratelimit));\n\tif (peer)\n\t\tinet_putpeer(peer);\nout:\n\tif (!rc)\n\t\t__ICMP_INC_STATS(net, ICMP_MIB_RATELIMITHOST);\n\treturn rc;\n}\n\n \nvoid icmp_out_count(struct net *net, unsigned char type)\n{\n\tICMPMSGOUT_INC_STATS(net, type);\n\tICMP_INC_STATS(net, ICMP_MIB_OUTMSGS);\n}\n\n \nstatic int icmp_glue_bits(void *from, char *to, int offset, int len, int odd,\n\t\t\t  struct sk_buff *skb)\n{\n\tstruct icmp_bxm *icmp_param = from;\n\t__wsum csum;\n\n\tcsum = skb_copy_and_csum_bits(icmp_param->skb,\n\t\t\t\t      icmp_param->offset + offset,\n\t\t\t\t      to, len);\n\n\tskb->csum = csum_block_add(skb->csum, csum, odd);\n\tif (icmp_pointers[icmp_param->data.icmph.type].error)\n\t\tnf_ct_attach(skb, icmp_param->skb);\n\treturn 0;\n}\n\nstatic void icmp_push_reply(struct sock *sk,\n\t\t\t    struct icmp_bxm *icmp_param,\n\t\t\t    struct flowi4 *fl4,\n\t\t\t    struct ipcm_cookie *ipc, struct rtable **rt)\n{\n\tstruct sk_buff *skb;\n\n\tif (ip_append_data(sk, fl4, icmp_glue_bits, icmp_param,\n\t\t\t   icmp_param->data_len+icmp_param->head_len,\n\t\t\t   icmp_param->head_len,\n\t\t\t   ipc, rt, MSG_DONTWAIT) < 0) {\n\t\t__ICMP_INC_STATS(sock_net(sk), ICMP_MIB_OUTERRORS);\n\t\tip_flush_pending_frames(sk);\n\t} else if ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {\n\t\tstruct icmphdr *icmph = icmp_hdr(skb);\n\t\t__wsum csum;\n\t\tstruct sk_buff *skb1;\n\n\t\tcsum = csum_partial_copy_nocheck((void *)&icmp_param->data,\n\t\t\t\t\t\t (char *)icmph,\n\t\t\t\t\t\t icmp_param->head_len);\n\t\tskb_queue_walk(&sk->sk_write_queue, skb1) {\n\t\t\tcsum = csum_add(csum, skb1->csum);\n\t\t}\n\t\ticmph->checksum = csum_fold(csum);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tip_push_pending_frames(sk, fl4);\n\t}\n}\n\n \n\nstatic void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)\n{\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct net *net = dev_net(rt->dst.dev);\n\tstruct flowi4 fl4;\n\tstruct sock *sk;\n\tstruct inet_sock *inet;\n\t__be32 daddr, saddr;\n\tu32 mark = IP4_REPLY_MARK(net, skb->mark);\n\tint type = icmp_param->data.icmph.type;\n\tint code = icmp_param->data.icmph.code;\n\n\tif (ip_options_echo(net, &icmp_param->replyopts.opt.opt, skb))\n\t\treturn;\n\n\t \n\tlocal_bh_disable();\n\n\t \n\tif (!icmpv4_global_allow(net, type, code))\n\t\tgoto out_bh_enable;\n\n\tsk = icmp_xmit_lock(net);\n\tif (!sk)\n\t\tgoto out_bh_enable;\n\tinet = inet_sk(sk);\n\n\ticmp_param->data.icmph.checksum = 0;\n\n\tipcm_init(&ipc);\n\tinet->tos = ip_hdr(skb)->tos;\n\tipc.sockc.mark = mark;\n\tdaddr = ipc.addr = ip_hdr(skb)->saddr;\n\tsaddr = fib_compute_spec_dst(skb);\n\n\tif (icmp_param->replyopts.opt.opt.optlen) {\n\t\tipc.opt = &icmp_param->replyopts.opt;\n\t\tif (ipc.opt->opt.srr)\n\t\t\tdaddr = icmp_param->replyopts.opt.opt.faddr;\n\t}\n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.daddr = daddr;\n\tfl4.saddr = saddr;\n\tfl4.flowi4_mark = mark;\n\tfl4.flowi4_uid = sock_net_uid(net, NULL);\n\tfl4.flowi4_tos = RT_TOS(ip_hdr(skb)->tos);\n\tfl4.flowi4_proto = IPPROTO_ICMP;\n\tfl4.flowi4_oif = l3mdev_master_ifindex(skb->dev);\n\tsecurity_skb_classify_flow(skb, flowi4_to_flowi_common(&fl4));\n\trt = ip_route_output_key(net, &fl4);\n\tif (IS_ERR(rt))\n\t\tgoto out_unlock;\n\tif (icmpv4_xrlim_allow(net, rt, &fl4, type, code))\n\t\ticmp_push_reply(sk, icmp_param, &fl4, &ipc, &rt);\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\nout_bh_enable:\n\tlocal_bh_enable();\n}\n\n \nstatic struct net_device *icmp_get_route_lookup_dev(struct sk_buff *skb)\n{\n\tstruct net_device *route_lookup_dev = NULL;\n\n\tif (skb->dev)\n\t\troute_lookup_dev = skb->dev;\n\telse if (skb_dst(skb))\n\t\troute_lookup_dev = skb_dst(skb)->dev;\n\treturn route_lookup_dev;\n}\n\nstatic struct rtable *icmp_route_lookup(struct net *net,\n\t\t\t\t\tstruct flowi4 *fl4,\n\t\t\t\t\tstruct sk_buff *skb_in,\n\t\t\t\t\tconst struct iphdr *iph,\n\t\t\t\t\t__be32 saddr, u8 tos, u32 mark,\n\t\t\t\t\tint type, int code,\n\t\t\t\t\tstruct icmp_bxm *param)\n{\n\tstruct net_device *route_lookup_dev;\n\tstruct rtable *rt, *rt2;\n\tstruct flowi4 fl4_dec;\n\tint err;\n\n\tmemset(fl4, 0, sizeof(*fl4));\n\tfl4->daddr = (param->replyopts.opt.opt.srr ?\n\t\t      param->replyopts.opt.opt.faddr : iph->saddr);\n\tfl4->saddr = saddr;\n\tfl4->flowi4_mark = mark;\n\tfl4->flowi4_uid = sock_net_uid(net, NULL);\n\tfl4->flowi4_tos = RT_TOS(tos);\n\tfl4->flowi4_proto = IPPROTO_ICMP;\n\tfl4->fl4_icmp_type = type;\n\tfl4->fl4_icmp_code = code;\n\troute_lookup_dev = icmp_get_route_lookup_dev(skb_in);\n\tfl4->flowi4_oif = l3mdev_master_ifindex(route_lookup_dev);\n\n\tsecurity_skb_classify_flow(skb_in, flowi4_to_flowi_common(fl4));\n\trt = ip_route_output_key_hash(net, fl4, skb_in);\n\tif (IS_ERR(rt))\n\t\treturn rt;\n\n\t \n\trt2 = rt;\n\n\trt = (struct rtable *) xfrm_lookup(net, &rt->dst,\n\t\t\t\t\t   flowi4_to_flowi(fl4), NULL, 0);\n\tif (!IS_ERR(rt)) {\n\t\tif (rt != rt2)\n\t\t\treturn rt;\n\t} else if (PTR_ERR(rt) == -EPERM) {\n\t\trt = NULL;\n\t} else\n\t\treturn rt;\n\n\terr = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4_dec), AF_INET);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tif (inet_addr_type_dev_table(net, route_lookup_dev,\n\t\t\t\t     fl4_dec.saddr) == RTN_LOCAL) {\n\t\trt2 = __ip_route_output_key(net, &fl4_dec);\n\t\tif (IS_ERR(rt2))\n\t\t\terr = PTR_ERR(rt2);\n\t} else {\n\t\tstruct flowi4 fl4_2 = {};\n\t\tunsigned long orefdst;\n\n\t\tfl4_2.daddr = fl4_dec.saddr;\n\t\trt2 = ip_route_output_key(net, &fl4_2);\n\t\tif (IS_ERR(rt2)) {\n\t\t\terr = PTR_ERR(rt2);\n\t\t\tgoto relookup_failed;\n\t\t}\n\t\t \n\t\torefdst = skb_in->_skb_refdst;  \n\t\tskb_dst_set(skb_in, NULL);\n\t\terr = ip_route_input(skb_in, fl4_dec.daddr, fl4_dec.saddr,\n\t\t\t\t     RT_TOS(tos), rt2->dst.dev);\n\n\t\tdst_release(&rt2->dst);\n\t\trt2 = skb_rtable(skb_in);\n\t\tskb_in->_skb_refdst = orefdst;  \n\t}\n\n\tif (err)\n\t\tgoto relookup_failed;\n\n\trt2 = (struct rtable *) xfrm_lookup(net, &rt2->dst,\n\t\t\t\t\t    flowi4_to_flowi(&fl4_dec), NULL,\n\t\t\t\t\t    XFRM_LOOKUP_ICMP);\n\tif (!IS_ERR(rt2)) {\n\t\tdst_release(&rt->dst);\n\t\tmemcpy(fl4, &fl4_dec, sizeof(*fl4));\n\t\trt = rt2;\n\t} else if (PTR_ERR(rt2) == -EPERM) {\n\t\tif (rt)\n\t\t\tdst_release(&rt->dst);\n\t\treturn rt2;\n\t} else {\n\t\terr = PTR_ERR(rt2);\n\t\tgoto relookup_failed;\n\t}\n\treturn rt;\n\nrelookup_failed:\n\tif (rt)\n\t\treturn rt;\n\treturn ERR_PTR(err);\n}\n\n \n\nvoid __icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info,\n\t\t const struct ip_options *opt)\n{\n\tstruct iphdr *iph;\n\tint room;\n\tstruct icmp_bxm icmp_param;\n\tstruct rtable *rt = skb_rtable(skb_in);\n\tstruct ipcm_cookie ipc;\n\tstruct flowi4 fl4;\n\t__be32 saddr;\n\tu8  tos;\n\tu32 mark;\n\tstruct net *net;\n\tstruct sock *sk;\n\n\tif (!rt)\n\t\tgoto out;\n\n\tif (rt->dst.dev)\n\t\tnet = dev_net(rt->dst.dev);\n\telse if (skb_in->dev)\n\t\tnet = dev_net(skb_in->dev);\n\telse\n\t\tgoto out;\n\n\t \n\tiph = ip_hdr(skb_in);\n\n\tif ((u8 *)iph < skb_in->head ||\n\t    (skb_network_header(skb_in) + sizeof(*iph)) >\n\t    skb_tail_pointer(skb_in))\n\t\tgoto out;\n\n\t \n\tif (skb_in->pkt_type != PACKET_HOST)\n\t\tgoto out;\n\n\t \n\tif (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\tgoto out;\n\n\t \n\tif (iph->frag_off & htons(IP_OFFSET))\n\t\tgoto out;\n\n\t \n\tif (icmp_pointers[type].error) {\n\t\t \n\t\tif (iph->protocol == IPPROTO_ICMP) {\n\t\t\tu8 _inner_type, *itp;\n\n\t\t\titp = skb_header_pointer(skb_in,\n\t\t\t\t\t\t skb_network_header(skb_in) +\n\t\t\t\t\t\t (iph->ihl << 2) +\n\t\t\t\t\t\t offsetof(struct icmphdr,\n\t\t\t\t\t\t\t  type) -\n\t\t\t\t\t\t skb_in->data,\n\t\t\t\t\t\t sizeof(_inner_type),\n\t\t\t\t\t\t &_inner_type);\n\t\t\tif (!itp)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tif (*itp > NR_ICMP_TYPES ||\n\t\t\t    icmp_pointers[*itp].error)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tlocal_bh_disable();\n\n\t \n\tif (!(skb_in->dev && (skb_in->dev->flags&IFF_LOOPBACK)) &&\n\t      !icmpv4_global_allow(net, type, code))\n\t\tgoto out_bh_enable;\n\n\tsk = icmp_xmit_lock(net);\n\tif (!sk)\n\t\tgoto out_bh_enable;\n\n\t \n\n\tsaddr = iph->daddr;\n\tif (!(rt->rt_flags & RTCF_LOCAL)) {\n\t\tstruct net_device *dev = NULL;\n\n\t\trcu_read_lock();\n\t\tif (rt_is_input_route(rt) &&\n\t\t    READ_ONCE(net->ipv4.sysctl_icmp_errors_use_inbound_ifaddr))\n\t\t\tdev = dev_get_by_index_rcu(net, inet_iif(skb_in));\n\n\t\tif (dev)\n\t\t\tsaddr = inet_select_addr(dev, iph->saddr,\n\t\t\t\t\t\t RT_SCOPE_LINK);\n\t\telse\n\t\t\tsaddr = 0;\n\t\trcu_read_unlock();\n\t}\n\n\ttos = icmp_pointers[type].error ? (RT_TOS(iph->tos) |\n\t\t\t\t\t   IPTOS_PREC_INTERNETCONTROL) :\n\t\t\t\t\t   iph->tos;\n\tmark = IP4_REPLY_MARK(net, skb_in->mark);\n\n\tif (__ip_options_echo(net, &icmp_param.replyopts.opt.opt, skb_in, opt))\n\t\tgoto out_unlock;\n\n\n\t \n\n\ticmp_param.data.icmph.type\t = type;\n\ticmp_param.data.icmph.code\t = code;\n\ticmp_param.data.icmph.un.gateway = info;\n\ticmp_param.data.icmph.checksum\t = 0;\n\ticmp_param.skb\t  = skb_in;\n\ticmp_param.offset = skb_network_offset(skb_in);\n\tinet_sk(sk)->tos = tos;\n\tipcm_init(&ipc);\n\tipc.addr = iph->saddr;\n\tipc.opt = &icmp_param.replyopts.opt;\n\tipc.sockc.mark = mark;\n\n\trt = icmp_route_lookup(net, &fl4, skb_in, iph, saddr, tos, mark,\n\t\t\t       type, code, &icmp_param);\n\tif (IS_ERR(rt))\n\t\tgoto out_unlock;\n\n\t \n\tif (!icmpv4_xrlim_allow(net, rt, &fl4, type, code))\n\t\tgoto ende;\n\n\t \n\n\troom = dst_mtu(&rt->dst);\n\tif (room > 576)\n\t\troom = 576;\n\troom -= sizeof(struct iphdr) + icmp_param.replyopts.opt.opt.optlen;\n\troom -= sizeof(struct icmphdr);\n\t \n\tif (room <= (int)sizeof(struct iphdr))\n\t\tgoto ende;\n\n\ticmp_param.data_len = skb_in->len - icmp_param.offset;\n\tif (icmp_param.data_len > room)\n\t\ticmp_param.data_len = room;\n\ticmp_param.head_len = sizeof(struct icmphdr);\n\n\t \n\tif (!fl4.saddr)\n\t\tfl4.saddr = htonl(INADDR_DUMMY);\n\n\ticmp_push_reply(sk, &icmp_param, &fl4, &ipc, &rt);\nende:\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\nout_bh_enable:\n\tlocal_bh_enable();\nout:;\n}\nEXPORT_SYMBOL(__icmp_send);\n\n#if IS_ENABLED(CONFIG_NF_NAT)\n#include <net/netfilter/nf_conntrack.h>\nvoid icmp_ndo_send(struct sk_buff *skb_in, int type, int code, __be32 info)\n{\n\tstruct sk_buff *cloned_skb = NULL;\n\tstruct ip_options opts = { 0 };\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn *ct;\n\t__be32 orig_ip;\n\n\tct = nf_ct_get(skb_in, &ctinfo);\n\tif (!ct || !(ct->status & IPS_SRC_NAT)) {\n\t\t__icmp_send(skb_in, type, code, info, &opts);\n\t\treturn;\n\t}\n\n\tif (skb_shared(skb_in))\n\t\tskb_in = cloned_skb = skb_clone(skb_in, GFP_ATOMIC);\n\n\tif (unlikely(!skb_in || skb_network_header(skb_in) < skb_in->head ||\n\t    (skb_network_header(skb_in) + sizeof(struct iphdr)) >\n\t    skb_tail_pointer(skb_in) || skb_ensure_writable(skb_in,\n\t    skb_network_offset(skb_in) + sizeof(struct iphdr))))\n\t\tgoto out;\n\n\torig_ip = ip_hdr(skb_in)->saddr;\n\tip_hdr(skb_in)->saddr = ct->tuplehash[0].tuple.src.u3.ip;\n\t__icmp_send(skb_in, type, code, info, &opts);\n\tip_hdr(skb_in)->saddr = orig_ip;\nout:\n\tconsume_skb(cloned_skb);\n}\nEXPORT_SYMBOL(icmp_ndo_send);\n#endif\n\nstatic void icmp_socket_deliver(struct sk_buff *skb, u32 info)\n{\n\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\tconst struct net_protocol *ipprot;\n\tint protocol = iph->protocol;\n\n\t \n\tif (!pskb_may_pull(skb, iph->ihl * 4 + 8)) {\n\t\t__ICMP_INC_STATS(dev_net(skb->dev), ICMP_MIB_INERRORS);\n\t\treturn;\n\t}\n\n\traw_icmp_error(skb, protocol, info);\n\n\tipprot = rcu_dereference(inet_protos[protocol]);\n\tif (ipprot && ipprot->err_handler)\n\t\tipprot->err_handler(skb, info);\n}\n\nstatic bool icmp_tag_validation(int proto)\n{\n\tbool ok;\n\n\trcu_read_lock();\n\tok = rcu_dereference(inet_protos[proto])->icmp_strict_tag_validation;\n\trcu_read_unlock();\n\treturn ok;\n}\n\n \n\nstatic enum skb_drop_reason icmp_unreach(struct sk_buff *skb)\n{\n\tenum skb_drop_reason reason = SKB_NOT_DROPPED_YET;\n\tconst struct iphdr *iph;\n\tstruct icmphdr *icmph;\n\tstruct net *net;\n\tu32 info = 0;\n\n\tnet = dev_net(skb_dst(skb)->dev);\n\n\t \n\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\tgoto out_err;\n\n\ticmph = icmp_hdr(skb);\n\tiph   = (const struct iphdr *)skb->data;\n\n\tif (iph->ihl < 5)  {  \n\t\treason = SKB_DROP_REASON_IP_INHDR;\n\t\tgoto out_err;\n\t}\n\n\tswitch (icmph->type) {\n\tcase ICMP_DEST_UNREACH:\n\t\tswitch (icmph->code & 15) {\n\t\tcase ICMP_NET_UNREACH:\n\t\tcase ICMP_HOST_UNREACH:\n\t\tcase ICMP_PROT_UNREACH:\n\t\tcase ICMP_PORT_UNREACH:\n\t\t\tbreak;\n\t\tcase ICMP_FRAG_NEEDED:\n\t\t\t \n\t\t\tswitch (READ_ONCE(net->ipv4.sysctl_ip_no_pmtu_disc)) {\n\t\t\tdefault:\n\t\t\t\tnet_dbg_ratelimited(\"%pI4: fragmentation needed and DF set\\n\",\n\t\t\t\t\t\t    &iph->daddr);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tgoto out;\n\t\t\tcase 3:\n\t\t\t\tif (!icmp_tag_validation(iph->protocol))\n\t\t\t\t\tgoto out;\n\t\t\t\tfallthrough;\n\t\t\tcase 0:\n\t\t\t\tinfo = ntohs(icmph->un.frag.mtu);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ICMP_SR_FAILED:\n\t\t\tnet_dbg_ratelimited(\"%pI4: Source Route Failed\\n\",\n\t\t\t\t\t    &iph->daddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (icmph->code > NR_ICMP_UNREACH)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase ICMP_PARAMETERPROB:\n\t\tinfo = ntohl(icmph->un.gateway) >> 24;\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\t__ICMP_INC_STATS(net, ICMP_MIB_INTIMEEXCDS);\n\t\tif (icmph->code == ICMP_EXC_FRAGTIME)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\n\t \n\n\t \n\n\tif (!READ_ONCE(net->ipv4.sysctl_icmp_ignore_bogus_error_responses) &&\n\t    inet_addr_type_dev_table(net, skb->dev, iph->daddr) == RTN_BROADCAST) {\n\t\tnet_warn_ratelimited(\"%pI4 sent an invalid ICMP type %u, code %u error to a broadcast: %pI4 on %s\\n\",\n\t\t\t\t     &ip_hdr(skb)->saddr,\n\t\t\t\t     icmph->type, icmph->code,\n\t\t\t\t     &iph->daddr, skb->dev->name);\n\t\tgoto out;\n\t}\n\n\ticmp_socket_deliver(skb, info);\n\nout:\n\treturn reason;\nout_err:\n\t__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);\n\treturn reason ?: SKB_DROP_REASON_NOT_SPECIFIED;\n}\n\n\n \n\nstatic enum skb_drop_reason icmp_redirect(struct sk_buff *skb)\n{\n\tif (skb->len < sizeof(struct iphdr)) {\n\t\t__ICMP_INC_STATS(dev_net(skb->dev), ICMP_MIB_INERRORS);\n\t\treturn SKB_DROP_REASON_PKT_TOO_SMALL;\n\t}\n\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr))) {\n\t\t \n\t\treturn SKB_DROP_REASON_NOMEM;\n\t}\n\n\ticmp_socket_deliver(skb, ntohl(icmp_hdr(skb)->un.gateway));\n\treturn SKB_NOT_DROPPED_YET;\n}\n\n \n\nstatic enum skb_drop_reason icmp_echo(struct sk_buff *skb)\n{\n\tstruct icmp_bxm icmp_param;\n\tstruct net *net;\n\n\tnet = dev_net(skb_dst(skb)->dev);\n\t \n\tif (READ_ONCE(net->ipv4.sysctl_icmp_echo_ignore_all))\n\t\treturn SKB_NOT_DROPPED_YET;\n\n\ticmp_param.data.icmph\t   = *icmp_hdr(skb);\n\ticmp_param.skb\t\t   = skb;\n\ticmp_param.offset\t   = 0;\n\ticmp_param.data_len\t   = skb->len;\n\ticmp_param.head_len\t   = sizeof(struct icmphdr);\n\n\tif (icmp_param.data.icmph.type == ICMP_ECHO)\n\t\ticmp_param.data.icmph.type = ICMP_ECHOREPLY;\n\telse if (!icmp_build_probe(skb, &icmp_param.data.icmph))\n\t\treturn SKB_NOT_DROPPED_YET;\n\n\ticmp_reply(&icmp_param, skb);\n\treturn SKB_NOT_DROPPED_YET;\n}\n\n \n\nbool icmp_build_probe(struct sk_buff *skb, struct icmphdr *icmphdr)\n{\n\tstruct icmp_ext_hdr *ext_hdr, _ext_hdr;\n\tstruct icmp_ext_echo_iio *iio, _iio;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct net_device *dev;\n\tchar buff[IFNAMSIZ];\n\tu16 ident_len;\n\tu8 status;\n\n\tif (!READ_ONCE(net->ipv4.sysctl_icmp_echo_enable_probe))\n\t\treturn false;\n\n\t \n\tif (!(ntohs(icmphdr->un.echo.sequence) & 1))\n\t\treturn false;\n\t \n\ticmphdr->un.echo.sequence &= htons(0xFF00);\n\tif (icmphdr->type == ICMP_EXT_ECHO)\n\t\ticmphdr->type = ICMP_EXT_ECHOREPLY;\n\telse\n\t\ticmphdr->type = ICMPV6_EXT_ECHO_REPLY;\n\text_hdr = skb_header_pointer(skb, 0, sizeof(_ext_hdr), &_ext_hdr);\n\t \n\tiio = skb_header_pointer(skb, sizeof(_ext_hdr), sizeof(iio->extobj_hdr), &_iio);\n\tif (!ext_hdr || !iio)\n\t\tgoto send_mal_query;\n\tif (ntohs(iio->extobj_hdr.length) <= sizeof(iio->extobj_hdr) ||\n\t    ntohs(iio->extobj_hdr.length) > sizeof(_iio))\n\t\tgoto send_mal_query;\n\tident_len = ntohs(iio->extobj_hdr.length) - sizeof(iio->extobj_hdr);\n\tiio = skb_header_pointer(skb, sizeof(_ext_hdr),\n\t\t\t\t sizeof(iio->extobj_hdr) + ident_len, &_iio);\n\tif (!iio)\n\t\tgoto send_mal_query;\n\n\tstatus = 0;\n\tdev = NULL;\n\tswitch (iio->extobj_hdr.class_type) {\n\tcase ICMP_EXT_ECHO_CTYPE_NAME:\n\t\tif (ident_len >= IFNAMSIZ)\n\t\t\tgoto send_mal_query;\n\t\tmemset(buff, 0, sizeof(buff));\n\t\tmemcpy(buff, &iio->ident.name, ident_len);\n\t\tdev = dev_get_by_name(net, buff);\n\t\tbreak;\n\tcase ICMP_EXT_ECHO_CTYPE_INDEX:\n\t\tif (ident_len != sizeof(iio->ident.ifindex))\n\t\t\tgoto send_mal_query;\n\t\tdev = dev_get_by_index(net, ntohl(iio->ident.ifindex));\n\t\tbreak;\n\tcase ICMP_EXT_ECHO_CTYPE_ADDR:\n\t\tif (ident_len < sizeof(iio->ident.addr.ctype3_hdr) ||\n\t\t    ident_len != sizeof(iio->ident.addr.ctype3_hdr) +\n\t\t\t\t iio->ident.addr.ctype3_hdr.addrlen)\n\t\t\tgoto send_mal_query;\n\t\tswitch (ntohs(iio->ident.addr.ctype3_hdr.afi)) {\n\t\tcase ICMP_AFI_IP:\n\t\t\tif (iio->ident.addr.ctype3_hdr.addrlen != sizeof(struct in_addr))\n\t\t\t\tgoto send_mal_query;\n\t\t\tdev = ip_dev_find(net, iio->ident.addr.ip_addr.ipv4_addr);\n\t\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase ICMP_AFI_IP6:\n\t\t\tif (iio->ident.addr.ctype3_hdr.addrlen != sizeof(struct in6_addr))\n\t\t\t\tgoto send_mal_query;\n\t\t\tdev = ipv6_stub->ipv6_dev_find(net, &iio->ident.addr.ip_addr.ipv6_addr, dev);\n\t\t\tdev_hold(dev);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tgoto send_mal_query;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto send_mal_query;\n\t}\n\tif (!dev) {\n\t\ticmphdr->code = ICMP_EXT_CODE_NO_IF;\n\t\treturn true;\n\t}\n\t \n\tif (dev->flags & IFF_UP)\n\t\tstatus |= ICMP_EXT_ECHOREPLY_ACTIVE;\n\tif (__in_dev_get_rcu(dev) && __in_dev_get_rcu(dev)->ifa_list)\n\t\tstatus |= ICMP_EXT_ECHOREPLY_IPV4;\n\tif (!list_empty(&rcu_dereference(dev->ip6_ptr)->addr_list))\n\t\tstatus |= ICMP_EXT_ECHOREPLY_IPV6;\n\tdev_put(dev);\n\ticmphdr->un.echo.sequence |= htons(status);\n\treturn true;\nsend_mal_query:\n\ticmphdr->code = ICMP_EXT_CODE_MAL_QUERY;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(icmp_build_probe);\n\n \nstatic enum skb_drop_reason icmp_timestamp(struct sk_buff *skb)\n{\n\tstruct icmp_bxm icmp_param;\n\t \n\tif (skb->len < 4)\n\t\tgoto out_err;\n\n\t \n\ticmp_param.data.times[1] = inet_current_timestamp();\n\ticmp_param.data.times[2] = icmp_param.data.times[1];\n\n\tBUG_ON(skb_copy_bits(skb, 0, &icmp_param.data.times[0], 4));\n\n\ticmp_param.data.icmph\t   = *icmp_hdr(skb);\n\ticmp_param.data.icmph.type = ICMP_TIMESTAMPREPLY;\n\ticmp_param.data.icmph.code = 0;\n\ticmp_param.skb\t\t   = skb;\n\ticmp_param.offset\t   = 0;\n\ticmp_param.data_len\t   = 0;\n\ticmp_param.head_len\t   = sizeof(struct icmphdr) + 12;\n\ticmp_reply(&icmp_param, skb);\n\treturn SKB_NOT_DROPPED_YET;\n\nout_err:\n\t__ICMP_INC_STATS(dev_net(skb_dst(skb)->dev), ICMP_MIB_INERRORS);\n\treturn SKB_DROP_REASON_PKT_TOO_SMALL;\n}\n\nstatic enum skb_drop_reason icmp_discard(struct sk_buff *skb)\n{\n\t \n\treturn SKB_NOT_DROPPED_YET;\n}\n\n \nint icmp_rcv(struct sk_buff *skb)\n{\n\tenum skb_drop_reason reason = SKB_DROP_REASON_NOT_SPECIFIED;\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct net *net = dev_net(rt->dst.dev);\n\tstruct icmphdr *icmph;\n\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tstruct sec_path *sp = skb_sec_path(skb);\n\t\tint nh;\n\n\t\tif (!(sp && sp->xvec[sp->len - 1]->props.flags &\n\t\t\t\t XFRM_STATE_ICMP)) {\n\t\t\treason = SKB_DROP_REASON_XFRM_POLICY;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (!pskb_may_pull(skb, sizeof(*icmph) + sizeof(struct iphdr)))\n\t\t\tgoto drop;\n\n\t\tnh = skb_network_offset(skb);\n\t\tskb_set_network_header(skb, sizeof(*icmph));\n\n\t\tif (!xfrm4_policy_check_reverse(NULL, XFRM_POLICY_IN,\n\t\t\t\t\t\tskb)) {\n\t\t\treason = SKB_DROP_REASON_XFRM_POLICY;\n\t\t\tgoto drop;\n\t\t}\n\n\t\tskb_set_network_header(skb, nh);\n\t}\n\n\t__ICMP_INC_STATS(net, ICMP_MIB_INMSGS);\n\n\tif (skb_checksum_simple_validate(skb))\n\t\tgoto csum_error;\n\n\tif (!pskb_pull(skb, sizeof(*icmph)))\n\t\tgoto error;\n\n\ticmph = icmp_hdr(skb);\n\n\tICMPMSGIN_INC_STATS(net, icmph->type);\n\n\t \n\tif (icmph->type == ICMP_EXT_ECHO) {\n\t\t \n\t\treason = icmp_echo(skb);\n\t\tgoto reason_check;\n\t}\n\n\tif (icmph->type == ICMP_EXT_ECHOREPLY) {\n\t\treason = ping_rcv(skb);\n\t\tgoto reason_check;\n\t}\n\n\t \n\tif (icmph->type > NR_ICMP_TYPES) {\n\t\treason = SKB_DROP_REASON_UNHANDLED_PROTO;\n\t\tgoto error;\n\t}\n\n\t \n\n\tif (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST)) {\n\t\t \n\t\tif ((icmph->type == ICMP_ECHO ||\n\t\t     icmph->type == ICMP_TIMESTAMP) &&\n\t\t    READ_ONCE(net->ipv4.sysctl_icmp_echo_ignore_broadcasts)) {\n\t\t\treason = SKB_DROP_REASON_INVALID_PROTO;\n\t\t\tgoto error;\n\t\t}\n\t\tif (icmph->type != ICMP_ECHO &&\n\t\t    icmph->type != ICMP_TIMESTAMP &&\n\t\t    icmph->type != ICMP_ADDRESS &&\n\t\t    icmph->type != ICMP_ADDRESSREPLY) {\n\t\t\treason = SKB_DROP_REASON_INVALID_PROTO;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treason = icmp_pointers[icmph->type].handler(skb);\nreason_check:\n\tif (!reason)  {\n\t\tconsume_skb(skb);\n\t\treturn NET_RX_SUCCESS;\n\t}\n\ndrop:\n\tkfree_skb_reason(skb, reason);\n\treturn NET_RX_DROP;\ncsum_error:\n\treason = SKB_DROP_REASON_ICMP_CSUM;\n\t__ICMP_INC_STATS(net, ICMP_MIB_CSUMERRORS);\nerror:\n\t__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);\n\tgoto drop;\n}\n\nstatic bool ip_icmp_error_rfc4884_validate(const struct sk_buff *skb, int off)\n{\n\tstruct icmp_extobj_hdr *objh, _objh;\n\tstruct icmp_ext_hdr *exth, _exth;\n\tu16 olen;\n\n\texth = skb_header_pointer(skb, off, sizeof(_exth), &_exth);\n\tif (!exth)\n\t\treturn false;\n\tif (exth->version != 2)\n\t\treturn true;\n\n\tif (exth->checksum &&\n\t    csum_fold(skb_checksum(skb, off, skb->len - off, 0)))\n\t\treturn false;\n\n\toff += sizeof(_exth);\n\twhile (off < skb->len) {\n\t\tobjh = skb_header_pointer(skb, off, sizeof(_objh), &_objh);\n\t\tif (!objh)\n\t\t\treturn false;\n\n\t\tolen = ntohs(objh->length);\n\t\tif (olen < sizeof(_objh))\n\t\t\treturn false;\n\n\t\toff += olen;\n\t\tif (off > skb->len)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid ip_icmp_error_rfc4884(const struct sk_buff *skb,\n\t\t\t   struct sock_ee_data_rfc4884 *out,\n\t\t\t   int thlen, int off)\n{\n\tint hlen;\n\n\t \n\thlen = -skb_transport_offset(skb) - thlen;\n\n\t \n\tif (off < 128 || off < hlen)\n\t\treturn;\n\n\t \n\toff -= hlen;\n\tif (off + sizeof(struct icmp_ext_hdr) > skb->len)\n\t\treturn;\n\n\tout->len = off;\n\n\tif (!ip_icmp_error_rfc4884_validate(skb, off))\n\t\tout->flags |= SO_EE_RFC4884_FLAG_INVALID;\n}\nEXPORT_SYMBOL_GPL(ip_icmp_error_rfc4884);\n\nint icmp_err(struct sk_buff *skb, u32 info)\n{\n\tstruct iphdr *iph = (struct iphdr *)skb->data;\n\tint offset = iph->ihl<<2;\n\tstruct icmphdr *icmph = (struct icmphdr *)(skb->data + offset);\n\tint type = icmp_hdr(skb)->type;\n\tint code = icmp_hdr(skb)->code;\n\tstruct net *net = dev_net(skb->dev);\n\n\t \n\tif (icmph->type != ICMP_ECHOREPLY) {\n\t\tping_err(skb, offset, info);\n\t\treturn 0;\n\t}\n\n\tif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED)\n\t\tipv4_update_pmtu(skb, net, info, 0, IPPROTO_ICMP);\n\telse if (type == ICMP_REDIRECT)\n\t\tipv4_redirect(skb, net, 0, IPPROTO_ICMP);\n\n\treturn 0;\n}\n\n \nstatic const struct icmp_control icmp_pointers[NR_ICMP_TYPES + 1] = {\n\t[ICMP_ECHOREPLY] = {\n\t\t.handler = ping_rcv,\n\t},\n\t[1] = {\n\t\t.handler = icmp_discard,\n\t\t.error = 1,\n\t},\n\t[2] = {\n\t\t.handler = icmp_discard,\n\t\t.error = 1,\n\t},\n\t[ICMP_DEST_UNREACH] = {\n\t\t.handler = icmp_unreach,\n\t\t.error = 1,\n\t},\n\t[ICMP_SOURCE_QUENCH] = {\n\t\t.handler = icmp_unreach,\n\t\t.error = 1,\n\t},\n\t[ICMP_REDIRECT] = {\n\t\t.handler = icmp_redirect,\n\t\t.error = 1,\n\t},\n\t[6] = {\n\t\t.handler = icmp_discard,\n\t\t.error = 1,\n\t},\n\t[7] = {\n\t\t.handler = icmp_discard,\n\t\t.error = 1,\n\t},\n\t[ICMP_ECHO] = {\n\t\t.handler = icmp_echo,\n\t},\n\t[9] = {\n\t\t.handler = icmp_discard,\n\t\t.error = 1,\n\t},\n\t[10] = {\n\t\t.handler = icmp_discard,\n\t\t.error = 1,\n\t},\n\t[ICMP_TIME_EXCEEDED] = {\n\t\t.handler = icmp_unreach,\n\t\t.error = 1,\n\t},\n\t[ICMP_PARAMETERPROB] = {\n\t\t.handler = icmp_unreach,\n\t\t.error = 1,\n\t},\n\t[ICMP_TIMESTAMP] = {\n\t\t.handler = icmp_timestamp,\n\t},\n\t[ICMP_TIMESTAMPREPLY] = {\n\t\t.handler = icmp_discard,\n\t},\n\t[ICMP_INFO_REQUEST] = {\n\t\t.handler = icmp_discard,\n\t},\n\t[ICMP_INFO_REPLY] = {\n\t\t.handler = icmp_discard,\n\t},\n\t[ICMP_ADDRESS] = {\n\t\t.handler = icmp_discard,\n\t},\n\t[ICMP_ADDRESSREPLY] = {\n\t\t.handler = icmp_discard,\n\t},\n};\n\nstatic int __net_init icmp_sk_init(struct net *net)\n{\n\t \n\tnet->ipv4.sysctl_icmp_echo_ignore_all = 0;\n\tnet->ipv4.sysctl_icmp_echo_enable_probe = 0;\n\tnet->ipv4.sysctl_icmp_echo_ignore_broadcasts = 1;\n\n\t \n\tnet->ipv4.sysctl_icmp_ignore_bogus_error_responses = 1;\n\n\t \n\n\tnet->ipv4.sysctl_icmp_ratelimit = 1 * HZ;\n\tnet->ipv4.sysctl_icmp_ratemask = 0x1818;\n\tnet->ipv4.sysctl_icmp_errors_use_inbound_ifaddr = 0;\n\n\treturn 0;\n}\n\nstatic struct pernet_operations __net_initdata icmp_sk_ops = {\n       .init = icmp_sk_init,\n};\n\nint __init icmp_init(void)\n{\n\tint err, i;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct sock *sk;\n\n\t\terr = inet_ctl_sock_create(&sk, PF_INET,\n\t\t\t\t\t   SOCK_RAW, IPPROTO_ICMP, &init_net);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tper_cpu(ipv4_icmp_sk, i) = sk;\n\n\t\t \n\t\tsk->sk_sndbuf =\t2 * SKB_TRUESIZE(64 * 1024);\n\n\t\t \n\t\tsock_set_flag(sk, SOCK_USE_WRITE_QUEUE);\n\t\tinet_sk(sk)->pmtudisc = IP_PMTUDISC_DONT;\n\t}\n\treturn register_pernet_subsys(&icmp_sk_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}