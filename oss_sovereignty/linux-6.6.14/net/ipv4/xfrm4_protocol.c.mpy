{
  "module_name": "xfrm4_protocol.c",
  "hash_id": "9c0858e84e94b4745fcd3587b2920d58544061b2dd89ea15ab25416d1f9faf10",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/xfrm4_protocol.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/skbuff.h>\n#include <net/icmp.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\nstatic struct xfrm4_protocol __rcu *esp4_handlers __read_mostly;\nstatic struct xfrm4_protocol __rcu *ah4_handlers __read_mostly;\nstatic struct xfrm4_protocol __rcu *ipcomp4_handlers __read_mostly;\nstatic DEFINE_MUTEX(xfrm4_protocol_mutex);\n\nstatic inline struct xfrm4_protocol __rcu **proto_handlers(u8 protocol)\n{\n\tswitch (protocol) {\n\tcase IPPROTO_ESP:\n\t\treturn &esp4_handlers;\n\tcase IPPROTO_AH:\n\t\treturn &ah4_handlers;\n\tcase IPPROTO_COMP:\n\t\treturn &ipcomp4_handlers;\n\t}\n\n\treturn NULL;\n}\n\n#define for_each_protocol_rcu(head, handler)\t\t\\\n\tfor (handler = rcu_dereference(head);\t\t\\\n\t     handler != NULL;\t\t\t\t\\\n\t     handler = rcu_dereference(handler->next))\t\\\n\nstatic int xfrm4_rcv_cb(struct sk_buff *skb, u8 protocol, int err)\n{\n\tint ret;\n\tstruct xfrm4_protocol *handler;\n\tstruct xfrm4_protocol __rcu **head = proto_handlers(protocol);\n\n\tif (!head)\n\t\treturn 0;\n\n\tfor_each_protocol_rcu(*head, handler)\n\t\tif ((ret = handler->cb_handler(skb, err)) <= 0)\n\t\t\treturn ret;\n\n\treturn 0;\n}\n\nint xfrm4_rcv_encap(struct sk_buff *skb, int nexthdr, __be32 spi,\n\t\t    int encap_type)\n{\n\tint ret;\n\tstruct xfrm4_protocol *handler;\n\tstruct xfrm4_protocol __rcu **head = proto_handlers(nexthdr);\n\n\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;\n\tXFRM_SPI_SKB_CB(skb)->family = AF_INET;\n\tXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);\n\n\tif (!head)\n\t\tgoto out;\n\n\tif (!skb_dst(skb)) {\n\t\tconst struct iphdr *iph = ip_hdr(skb);\n\n\t\tif (ip_route_input_noref(skb, iph->daddr, iph->saddr,\n\t\t\t\t\t iph->tos, skb->dev))\n\t\t\tgoto drop;\n\t}\n\n\tfor_each_protocol_rcu(*head, handler)\n\t\tif ((ret = handler->input_handler(skb, nexthdr, spi, encap_type)) != -EINVAL)\n\t\t\treturn ret;\n\nout:\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\nEXPORT_SYMBOL(xfrm4_rcv_encap);\n\nstatic int xfrm4_esp_rcv(struct sk_buff *skb)\n{\n\tint ret;\n\tstruct xfrm4_protocol *handler;\n\n\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;\n\n\tfor_each_protocol_rcu(esp4_handlers, handler)\n\t\tif ((ret = handler->handler(skb)) != -EINVAL)\n\t\t\treturn ret;\n\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int xfrm4_esp_err(struct sk_buff *skb, u32 info)\n{\n\tstruct xfrm4_protocol *handler;\n\n\tfor_each_protocol_rcu(esp4_handlers, handler)\n\t\tif (!handler->err_handler(skb, info))\n\t\t\treturn 0;\n\n\treturn -ENOENT;\n}\n\nstatic int xfrm4_ah_rcv(struct sk_buff *skb)\n{\n\tint ret;\n\tstruct xfrm4_protocol *handler;\n\n\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;\n\n\tfor_each_protocol_rcu(ah4_handlers, handler)\n\t\tif ((ret = handler->handler(skb)) != -EINVAL)\n\t\t\treturn ret;\n\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int xfrm4_ah_err(struct sk_buff *skb, u32 info)\n{\n\tstruct xfrm4_protocol *handler;\n\n\tfor_each_protocol_rcu(ah4_handlers, handler)\n\t\tif (!handler->err_handler(skb, info))\n\t\t\treturn 0;\n\n\treturn -ENOENT;\n}\n\nstatic int xfrm4_ipcomp_rcv(struct sk_buff *skb)\n{\n\tint ret;\n\tstruct xfrm4_protocol *handler;\n\n\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;\n\n\tfor_each_protocol_rcu(ipcomp4_handlers, handler)\n\t\tif ((ret = handler->handler(skb)) != -EINVAL)\n\t\t\treturn ret;\n\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int xfrm4_ipcomp_err(struct sk_buff *skb, u32 info)\n{\n\tstruct xfrm4_protocol *handler;\n\n\tfor_each_protocol_rcu(ipcomp4_handlers, handler)\n\t\tif (!handler->err_handler(skb, info))\n\t\t\treturn 0;\n\n\treturn -ENOENT;\n}\n\nstatic const struct net_protocol esp4_protocol = {\n\t.handler\t=\txfrm4_esp_rcv,\n\t.err_handler\t=\txfrm4_esp_err,\n\t.no_policy\t=\t1,\n};\n\nstatic const struct net_protocol ah4_protocol = {\n\t.handler\t=\txfrm4_ah_rcv,\n\t.err_handler\t=\txfrm4_ah_err,\n\t.no_policy\t=\t1,\n};\n\nstatic const struct net_protocol ipcomp4_protocol = {\n\t.handler\t=\txfrm4_ipcomp_rcv,\n\t.err_handler\t=\txfrm4_ipcomp_err,\n\t.no_policy\t=\t1,\n};\n\nstatic const struct xfrm_input_afinfo xfrm4_input_afinfo = {\n\t.family\t\t=\tAF_INET,\n\t.callback\t=\txfrm4_rcv_cb,\n};\n\nstatic inline const struct net_protocol *netproto(unsigned char protocol)\n{\n\tswitch (protocol) {\n\tcase IPPROTO_ESP:\n\t\treturn &esp4_protocol;\n\tcase IPPROTO_AH:\n\t\treturn &ah4_protocol;\n\tcase IPPROTO_COMP:\n\t\treturn &ipcomp4_protocol;\n\t}\n\n\treturn NULL;\n}\n\nint xfrm4_protocol_register(struct xfrm4_protocol *handler,\n\t\t\t    unsigned char protocol)\n{\n\tstruct xfrm4_protocol __rcu **pprev;\n\tstruct xfrm4_protocol *t;\n\tbool add_netproto = false;\n\tint ret = -EEXIST;\n\tint priority = handler->priority;\n\n\tif (!proto_handlers(protocol) || !netproto(protocol))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&xfrm4_protocol_mutex);\n\n\tif (!rcu_dereference_protected(*proto_handlers(protocol),\n\t\t\t\t       lockdep_is_held(&xfrm4_protocol_mutex)))\n\t\tadd_netproto = true;\n\n\tfor (pprev = proto_handlers(protocol);\n\t     (t = rcu_dereference_protected(*pprev,\n\t\t\tlockdep_is_held(&xfrm4_protocol_mutex))) != NULL;\n\t     pprev = &t->next) {\n\t\tif (t->priority < priority)\n\t\t\tbreak;\n\t\tif (t->priority == priority)\n\t\t\tgoto err;\n\t}\n\n\thandler->next = *pprev;\n\trcu_assign_pointer(*pprev, handler);\n\n\tret = 0;\n\nerr:\n\tmutex_unlock(&xfrm4_protocol_mutex);\n\n\tif (add_netproto) {\n\t\tif (inet_add_protocol(netproto(protocol), protocol)) {\n\t\t\tpr_err(\"%s: can't add protocol\\n\", __func__);\n\t\t\tret = -EAGAIN;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(xfrm4_protocol_register);\n\nint xfrm4_protocol_deregister(struct xfrm4_protocol *handler,\n\t\t\t      unsigned char protocol)\n{\n\tstruct xfrm4_protocol __rcu **pprev;\n\tstruct xfrm4_protocol *t;\n\tint ret = -ENOENT;\n\n\tif (!proto_handlers(protocol) || !netproto(protocol))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&xfrm4_protocol_mutex);\n\n\tfor (pprev = proto_handlers(protocol);\n\t     (t = rcu_dereference_protected(*pprev,\n\t\t\tlockdep_is_held(&xfrm4_protocol_mutex))) != NULL;\n\t     pprev = &t->next) {\n\t\tif (t == handler) {\n\t\t\t*pprev = handler->next;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!rcu_dereference_protected(*proto_handlers(protocol),\n\t\t\t\t       lockdep_is_held(&xfrm4_protocol_mutex))) {\n\t\tif (inet_del_protocol(netproto(protocol), protocol) < 0) {\n\t\t\tpr_err(\"%s: can't remove protocol\\n\", __func__);\n\t\t\tret = -EAGAIN;\n\t\t}\n\t}\n\n\tmutex_unlock(&xfrm4_protocol_mutex);\n\n\tsynchronize_net();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(xfrm4_protocol_deregister);\n\nvoid __init xfrm4_protocol_init(void)\n{\n\txfrm_input_register_afinfo(&xfrm4_input_afinfo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}