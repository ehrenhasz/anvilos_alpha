{
  "module_name": "fib_frontend.c",
  "hash_id": "0832596355c3986fb8752ce3bcd9c82f48d329feac5f2bfd2fad9eaa64f04b58",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/fib_frontend.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/if_addr.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/cache.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <net/inet_dscp.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/route.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <net/arp.h>\n#include <net/ip_fib.h>\n#include <net/nexthop.h>\n#include <net/rtnetlink.h>\n#include <net/xfrm.h>\n#include <net/l3mdev.h>\n#include <net/lwtunnel.h>\n#include <trace/events/fib.h>\n\n#ifndef CONFIG_IP_MULTIPLE_TABLES\n\nstatic int __net_init fib4_rules_init(struct net *net)\n{\n\tstruct fib_table *local_table, *main_table;\n\n\tmain_table  = fib_trie_table(RT_TABLE_MAIN, NULL);\n\tif (!main_table)\n\t\treturn -ENOMEM;\n\n\tlocal_table = fib_trie_table(RT_TABLE_LOCAL, main_table);\n\tif (!local_table)\n\t\tgoto fail;\n\n\thlist_add_head_rcu(&local_table->tb_hlist,\n\t\t\t\t&net->ipv4.fib_table_hash[TABLE_LOCAL_INDEX]);\n\thlist_add_head_rcu(&main_table->tb_hlist,\n\t\t\t\t&net->ipv4.fib_table_hash[TABLE_MAIN_INDEX]);\n\treturn 0;\n\nfail:\n\tfib_free_table(main_table);\n\treturn -ENOMEM;\n}\n#else\n\nstruct fib_table *fib_new_table(struct net *net, u32 id)\n{\n\tstruct fib_table *tb, *alias = NULL;\n\tunsigned int h;\n\n\tif (id == 0)\n\t\tid = RT_TABLE_MAIN;\n\ttb = fib_get_table(net, id);\n\tif (tb)\n\t\treturn tb;\n\n\tif (id == RT_TABLE_LOCAL && !net->ipv4.fib_has_custom_rules)\n\t\talias = fib_new_table(net, RT_TABLE_MAIN);\n\n\ttb = fib_trie_table(id, alias);\n\tif (!tb)\n\t\treturn NULL;\n\n\tswitch (id) {\n\tcase RT_TABLE_MAIN:\n\t\trcu_assign_pointer(net->ipv4.fib_main, tb);\n\t\tbreak;\n\tcase RT_TABLE_DEFAULT:\n\t\trcu_assign_pointer(net->ipv4.fib_default, tb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\th = id & (FIB_TABLE_HASHSZ - 1);\n\thlist_add_head_rcu(&tb->tb_hlist, &net->ipv4.fib_table_hash[h]);\n\treturn tb;\n}\nEXPORT_SYMBOL_GPL(fib_new_table);\n\n \nstruct fib_table *fib_get_table(struct net *net, u32 id)\n{\n\tstruct fib_table *tb;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\tif (id == 0)\n\t\tid = RT_TABLE_MAIN;\n\th = id & (FIB_TABLE_HASHSZ - 1);\n\n\thead = &net->ipv4.fib_table_hash[h];\n\thlist_for_each_entry_rcu(tb, head, tb_hlist,\n\t\t\t\t lockdep_rtnl_is_held()) {\n\t\tif (tb->tb_id == id)\n\t\t\treturn tb;\n\t}\n\treturn NULL;\n}\n#endif  \n\nstatic void fib_replace_table(struct net *net, struct fib_table *old,\n\t\t\t      struct fib_table *new)\n{\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n\tswitch (new->tb_id) {\n\tcase RT_TABLE_MAIN:\n\t\trcu_assign_pointer(net->ipv4.fib_main, new);\n\t\tbreak;\n\tcase RT_TABLE_DEFAULT:\n\t\trcu_assign_pointer(net->ipv4.fib_default, new);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n#endif\n\t \n\thlist_replace_rcu(&old->tb_hlist, &new->tb_hlist);\n}\n\nint fib_unmerge(struct net *net)\n{\n\tstruct fib_table *old, *new, *main_table;\n\n\t \n\told = fib_get_table(net, RT_TABLE_LOCAL);\n\tif (!old)\n\t\treturn 0;\n\n\tnew = fib_trie_unmerge(old);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t \n\tif (new == old)\n\t\treturn 0;\n\n\t \n\tfib_replace_table(net, old, new);\n\tfib_free_table(old);\n\n\t \n\tmain_table = fib_get_table(net, RT_TABLE_MAIN);\n\tif (!main_table)\n\t\treturn 0;\n\n\t \n\tfib_table_flush_external(main_table);\n\n\treturn 0;\n}\n\nvoid fib_flush(struct net *net)\n{\n\tint flushed = 0;\n\tunsigned int h;\n\n\tfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\n\t\tstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\n\t\tstruct hlist_node *tmp;\n\t\tstruct fib_table *tb;\n\n\t\thlist_for_each_entry_safe(tb, tmp, head, tb_hlist)\n\t\t\tflushed += fib_table_flush(net, tb, false);\n\t}\n\n\tif (flushed)\n\t\trt_cache_flush(net);\n}\n\n \nstatic inline unsigned int __inet_dev_addr_type(struct net *net,\n\t\t\t\t\t\tconst struct net_device *dev,\n\t\t\t\t\t\t__be32 addr, u32 tb_id)\n{\n\tstruct flowi4\t\tfl4 = { .daddr = addr };\n\tstruct fib_result\tres;\n\tunsigned int ret = RTN_BROADCAST;\n\tstruct fib_table *table;\n\n\tif (ipv4_is_zeronet(addr) || ipv4_is_lbcast(addr))\n\t\treturn RTN_BROADCAST;\n\tif (ipv4_is_multicast(addr))\n\t\treturn RTN_MULTICAST;\n\n\trcu_read_lock();\n\n\ttable = fib_get_table(net, tb_id);\n\tif (table) {\n\t\tret = RTN_UNICAST;\n\t\tif (!fib_table_lookup(table, &fl4, &res, FIB_LOOKUP_NOREF)) {\n\t\t\tstruct fib_nh_common *nhc = fib_info_nhc(res.fi, 0);\n\n\t\t\tif (!dev || dev == nhc->nhc_dev)\n\t\t\t\tret = res.type;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}\n\nunsigned int inet_addr_type_table(struct net *net, __be32 addr, u32 tb_id)\n{\n\treturn __inet_dev_addr_type(net, NULL, addr, tb_id);\n}\nEXPORT_SYMBOL(inet_addr_type_table);\n\nunsigned int inet_addr_type(struct net *net, __be32 addr)\n{\n\treturn __inet_dev_addr_type(net, NULL, addr, RT_TABLE_LOCAL);\n}\nEXPORT_SYMBOL(inet_addr_type);\n\nunsigned int inet_dev_addr_type(struct net *net, const struct net_device *dev,\n\t\t\t\t__be32 addr)\n{\n\tu32 rt_table = l3mdev_fib_table(dev) ? : RT_TABLE_LOCAL;\n\n\treturn __inet_dev_addr_type(net, dev, addr, rt_table);\n}\nEXPORT_SYMBOL(inet_dev_addr_type);\n\n \nunsigned int inet_addr_type_dev_table(struct net *net,\n\t\t\t\t      const struct net_device *dev,\n\t\t\t\t      __be32 addr)\n{\n\tu32 rt_table = l3mdev_fib_table(dev) ? : RT_TABLE_LOCAL;\n\n\treturn __inet_dev_addr_type(net, NULL, addr, rt_table);\n}\nEXPORT_SYMBOL(inet_addr_type_dev_table);\n\n__be32 fib_compute_spec_dst(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct in_device *in_dev;\n\tstruct fib_result res;\n\tstruct rtable *rt;\n\tstruct net *net;\n\tint scope;\n\n\trt = skb_rtable(skb);\n\tif ((rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST | RTCF_LOCAL)) ==\n\t    RTCF_LOCAL)\n\t\treturn ip_hdr(skb)->daddr;\n\n\tin_dev = __in_dev_get_rcu(dev);\n\n\tnet = dev_net(dev);\n\n\tscope = RT_SCOPE_UNIVERSE;\n\tif (!ipv4_is_zeronet(ip_hdr(skb)->saddr)) {\n\t\tbool vmark = in_dev && IN_DEV_SRC_VMARK(in_dev);\n\t\tstruct flowi4 fl4 = {\n\t\t\t.flowi4_iif = LOOPBACK_IFINDEX,\n\t\t\t.flowi4_l3mdev = l3mdev_master_ifindex_rcu(dev),\n\t\t\t.daddr = ip_hdr(skb)->saddr,\n\t\t\t.flowi4_tos = ip_hdr(skb)->tos & IPTOS_RT_MASK,\n\t\t\t.flowi4_scope = scope,\n\t\t\t.flowi4_mark = vmark ? skb->mark : 0,\n\t\t};\n\t\tif (!fib_lookup(net, &fl4, &res, 0))\n\t\t\treturn fib_result_prefsrc(net, &res);\n\t} else {\n\t\tscope = RT_SCOPE_LINK;\n\t}\n\n\treturn inet_select_addr(dev, ip_hdr(skb)->saddr, scope);\n}\n\nbool fib_info_nh_uses_dev(struct fib_info *fi, const struct net_device *dev)\n{\n\tbool dev_match = false;\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\tif (unlikely(fi->nh)) {\n\t\tdev_match = nexthop_uses_dev(fi->nh, dev);\n\t} else {\n\t\tint ret;\n\n\t\tfor (ret = 0; ret < fib_info_num_path(fi); ret++) {\n\t\t\tconst struct fib_nh_common *nhc = fib_info_nhc(fi, ret);\n\n\t\t\tif (nhc_l3mdev_matches_dev(nhc, dev)) {\n\t\t\t\tdev_match = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#else\n\tif (fib_info_nhc(fi, 0)->nhc_dev == dev)\n\t\tdev_match = true;\n#endif\n\n\treturn dev_match;\n}\nEXPORT_SYMBOL_GPL(fib_info_nh_uses_dev);\n\n \nstatic int __fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,\n\t\t\t\t u8 tos, int oif, struct net_device *dev,\n\t\t\t\t int rpf, struct in_device *idev, u32 *itag)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct flow_keys flkeys;\n\tint ret, no_addr;\n\tstruct fib_result res;\n\tstruct flowi4 fl4;\n\tbool dev_match;\n\n\tfl4.flowi4_oif = 0;\n\tfl4.flowi4_l3mdev = l3mdev_master_ifindex_rcu(dev);\n\tfl4.flowi4_iif = oif ? : LOOPBACK_IFINDEX;\n\tfl4.daddr = src;\n\tfl4.saddr = dst;\n\tfl4.flowi4_tos = tos;\n\tfl4.flowi4_scope = RT_SCOPE_UNIVERSE;\n\tfl4.flowi4_tun_key.tun_id = 0;\n\tfl4.flowi4_flags = 0;\n\tfl4.flowi4_uid = sock_net_uid(net, NULL);\n\tfl4.flowi4_multipath_hash = 0;\n\n\tno_addr = idev->ifa_list == NULL;\n\n\tfl4.flowi4_mark = IN_DEV_SRC_VMARK(idev) ? skb->mark : 0;\n\tif (!fib4_rules_early_flow_dissect(net, skb, &fl4, &flkeys)) {\n\t\tfl4.flowi4_proto = 0;\n\t\tfl4.fl4_sport = 0;\n\t\tfl4.fl4_dport = 0;\n\t} else {\n\t\tswap(fl4.fl4_sport, fl4.fl4_dport);\n\t}\n\n\tif (fib_lookup(net, &fl4, &res, 0))\n\t\tgoto last_resort;\n\tif (res.type != RTN_UNICAST &&\n\t    (res.type != RTN_LOCAL || !IN_DEV_ACCEPT_LOCAL(idev)))\n\t\tgoto e_inval;\n\tfib_combine_itag(itag, &res);\n\n\tdev_match = fib_info_nh_uses_dev(res.fi, dev);\n\t \n\tdev_match = dev_match || (res.type == RTN_LOCAL &&\n\t\t\t\t  dev == net->loopback_dev);\n\tif (dev_match) {\n\t\tret = FIB_RES_NHC(res)->nhc_scope >= RT_SCOPE_HOST;\n\t\treturn ret;\n\t}\n\tif (no_addr)\n\t\tgoto last_resort;\n\tif (rpf == 1)\n\t\tgoto e_rpf;\n\tfl4.flowi4_oif = dev->ifindex;\n\n\tret = 0;\n\tif (fib_lookup(net, &fl4, &res, FIB_LOOKUP_IGNORE_LINKSTATE) == 0) {\n\t\tif (res.type == RTN_UNICAST)\n\t\t\tret = FIB_RES_NHC(res)->nhc_scope >= RT_SCOPE_HOST;\n\t}\n\treturn ret;\n\nlast_resort:\n\tif (rpf)\n\t\tgoto e_rpf;\n\t*itag = 0;\n\treturn 0;\n\ne_inval:\n\treturn -EINVAL;\ne_rpf:\n\treturn -EXDEV;\n}\n\n \nint fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst,\n\t\t\tu8 tos, int oif, struct net_device *dev,\n\t\t\tstruct in_device *idev, u32 *itag)\n{\n\tint r = secpath_exists(skb) ? 0 : IN_DEV_RPFILTER(idev);\n\tstruct net *net = dev_net(dev);\n\n\tif (!r && !fib_num_tclassid_users(net) &&\n\t    (dev->ifindex != oif || !IN_DEV_TX_REDIRECTS(idev))) {\n\t\tif (IN_DEV_ACCEPT_LOCAL(idev))\n\t\t\tgoto ok;\n\t\t \n\t\tif (net->ipv4.fib_has_custom_local_routes ||\n\t\t    fib4_has_custom_rules(net))\n\t\t\tgoto full_check;\n\t\t \n\t\tif (inet_lookup_ifaddr_rcu(net, src))\n\t\t\treturn -EINVAL;\n\nok:\n\t\t*itag = 0;\n\t\treturn 0;\n\t}\n\nfull_check:\n\treturn __fib_validate_source(skb, src, dst, tos, oif, dev, r, idev, itag);\n}\n\nstatic inline __be32 sk_extract_addr(struct sockaddr *addr)\n{\n\treturn ((struct sockaddr_in *) addr)->sin_addr.s_addr;\n}\n\nstatic int put_rtax(struct nlattr *mx, int len, int type, u32 value)\n{\n\tstruct nlattr *nla;\n\n\tnla = (struct nlattr *) ((char *) mx + len);\n\tnla->nla_type = type;\n\tnla->nla_len = nla_attr_size(4);\n\t*(u32 *) nla_data(nla) = value;\n\n\treturn len + nla_total_size(4);\n}\n\nstatic int rtentry_to_fib_config(struct net *net, int cmd, struct rtentry *rt,\n\t\t\t\t struct fib_config *cfg)\n{\n\t__be32 addr;\n\tint plen;\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\tcfg->fc_nlinfo.nl_net = net;\n\n\tif (rt->rt_dst.sa_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\t \n\tplen = 32;\n\taddr = sk_extract_addr(&rt->rt_dst);\n\tif (!(rt->rt_flags & RTF_HOST)) {\n\t\t__be32 mask = sk_extract_addr(&rt->rt_genmask);\n\n\t\tif (rt->rt_genmask.sa_family != AF_INET) {\n\t\t\tif (mask || rt->rt_genmask.sa_family)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tif (bad_mask(mask, addr))\n\t\t\treturn -EINVAL;\n\n\t\tplen = inet_mask_len(mask);\n\t}\n\n\tcfg->fc_dst_len = plen;\n\tcfg->fc_dst = addr;\n\n\tif (cmd != SIOCDELRT) {\n\t\tcfg->fc_nlflags = NLM_F_CREATE;\n\t\tcfg->fc_protocol = RTPROT_BOOT;\n\t}\n\n\tif (rt->rt_metric)\n\t\tcfg->fc_priority = rt->rt_metric - 1;\n\n\tif (rt->rt_flags & RTF_REJECT) {\n\t\tcfg->fc_scope = RT_SCOPE_HOST;\n\t\tcfg->fc_type = RTN_UNREACHABLE;\n\t\treturn 0;\n\t}\n\n\tcfg->fc_scope = RT_SCOPE_NOWHERE;\n\tcfg->fc_type = RTN_UNICAST;\n\n\tif (rt->rt_dev) {\n\t\tchar *colon;\n\t\tstruct net_device *dev;\n\t\tchar devname[IFNAMSIZ];\n\n\t\tif (copy_from_user(devname, rt->rt_dev, IFNAMSIZ-1))\n\t\t\treturn -EFAULT;\n\n\t\tdevname[IFNAMSIZ-1] = 0;\n\t\tcolon = strchr(devname, ':');\n\t\tif (colon)\n\t\t\t*colon = 0;\n\t\tdev = __dev_get_by_name(net, devname);\n\t\tif (!dev)\n\t\t\treturn -ENODEV;\n\t\tcfg->fc_oif = dev->ifindex;\n\t\tcfg->fc_table = l3mdev_fib_table(dev);\n\t\tif (colon) {\n\t\t\tconst struct in_ifaddr *ifa;\n\t\t\tstruct in_device *in_dev;\n\n\t\t\tin_dev = __in_dev_get_rtnl(dev);\n\t\t\tif (!in_dev)\n\t\t\t\treturn -ENODEV;\n\n\t\t\t*colon = ':';\n\n\t\t\trcu_read_lock();\n\t\t\tin_dev_for_each_ifa_rcu(ifa, in_dev) {\n\t\t\t\tif (strcmp(ifa->ifa_label, devname) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\n\t\t\tif (!ifa)\n\t\t\t\treturn -ENODEV;\n\t\t\tcfg->fc_prefsrc = ifa->ifa_local;\n\t\t}\n\t}\n\n\taddr = sk_extract_addr(&rt->rt_gateway);\n\tif (rt->rt_gateway.sa_family == AF_INET && addr) {\n\t\tunsigned int addr_type;\n\n\t\tcfg->fc_gw4 = addr;\n\t\tcfg->fc_gw_family = AF_INET;\n\t\taddr_type = inet_addr_type_table(net, addr, cfg->fc_table);\n\t\tif (rt->rt_flags & RTF_GATEWAY &&\n\t\t    addr_type == RTN_UNICAST)\n\t\t\tcfg->fc_scope = RT_SCOPE_UNIVERSE;\n\t}\n\n\tif (!cfg->fc_table)\n\t\tcfg->fc_table = RT_TABLE_MAIN;\n\n\tif (cmd == SIOCDELRT)\n\t\treturn 0;\n\n\tif (rt->rt_flags & RTF_GATEWAY && !cfg->fc_gw_family)\n\t\treturn -EINVAL;\n\n\tif (cfg->fc_scope == RT_SCOPE_NOWHERE)\n\t\tcfg->fc_scope = RT_SCOPE_LINK;\n\n\tif (rt->rt_flags & (RTF_MTU | RTF_WINDOW | RTF_IRTT)) {\n\t\tstruct nlattr *mx;\n\t\tint len = 0;\n\n\t\tmx = kcalloc(3, nla_total_size(4), GFP_KERNEL);\n\t\tif (!mx)\n\t\t\treturn -ENOMEM;\n\n\t\tif (rt->rt_flags & RTF_MTU)\n\t\t\tlen = put_rtax(mx, len, RTAX_ADVMSS, rt->rt_mtu - 40);\n\n\t\tif (rt->rt_flags & RTF_WINDOW)\n\t\t\tlen = put_rtax(mx, len, RTAX_WINDOW, rt->rt_window);\n\n\t\tif (rt->rt_flags & RTF_IRTT)\n\t\t\tlen = put_rtax(mx, len, RTAX_RTT, rt->rt_irtt << 3);\n\n\t\tcfg->fc_mx = mx;\n\t\tcfg->fc_mx_len = len;\n\t}\n\n\treturn 0;\n}\n\n \nint ip_rt_ioctl(struct net *net, unsigned int cmd, struct rtentry *rt)\n{\n\tstruct fib_config cfg;\n\tint err;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\t\t \n\tcase SIOCDELRT:\t\t \n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\trtnl_lock();\n\t\terr = rtentry_to_fib_config(net, cmd, rt, &cfg);\n\t\tif (err == 0) {\n\t\t\tstruct fib_table *tb;\n\n\t\t\tif (cmd == SIOCDELRT) {\n\t\t\t\ttb = fib_get_table(net, cfg.fc_table);\n\t\t\t\tif (tb)\n\t\t\t\t\terr = fib_table_delete(net, tb, &cfg,\n\t\t\t\t\t\t\t       NULL);\n\t\t\t\telse\n\t\t\t\t\terr = -ESRCH;\n\t\t\t} else {\n\t\t\t\ttb = fib_new_table(net, cfg.fc_table);\n\t\t\t\tif (tb)\n\t\t\t\t\terr = fib_table_insert(net, tb,\n\t\t\t\t\t\t\t       &cfg, NULL);\n\t\t\t\telse\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t}\n\n\t\t\t \n\t\t\tkfree(cfg.fc_mx);\n\t\t}\n\t\trtnl_unlock();\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}\n\nconst struct nla_policy rtm_ipv4_policy[RTA_MAX + 1] = {\n\t[RTA_UNSPEC]\t\t= { .strict_start_type = RTA_DPORT + 1 },\n\t[RTA_DST]\t\t= { .type = NLA_U32 },\n\t[RTA_SRC]\t\t= { .type = NLA_U32 },\n\t[RTA_IIF]\t\t= { .type = NLA_U32 },\n\t[RTA_OIF]\t\t= { .type = NLA_U32 },\n\t[RTA_GATEWAY]\t\t= { .type = NLA_U32 },\n\t[RTA_PRIORITY]\t\t= { .type = NLA_U32 },\n\t[RTA_PREFSRC]\t\t= { .type = NLA_U32 },\n\t[RTA_METRICS]\t\t= { .type = NLA_NESTED },\n\t[RTA_MULTIPATH]\t\t= { .len = sizeof(struct rtnexthop) },\n\t[RTA_FLOW]\t\t= { .type = NLA_U32 },\n\t[RTA_ENCAP_TYPE]\t= { .type = NLA_U16 },\n\t[RTA_ENCAP]\t\t= { .type = NLA_NESTED },\n\t[RTA_UID]\t\t= { .type = NLA_U32 },\n\t[RTA_MARK]\t\t= { .type = NLA_U32 },\n\t[RTA_TABLE]\t\t= { .type = NLA_U32 },\n\t[RTA_IP_PROTO]\t\t= { .type = NLA_U8 },\n\t[RTA_SPORT]\t\t= { .type = NLA_U16 },\n\t[RTA_DPORT]\t\t= { .type = NLA_U16 },\n\t[RTA_NH_ID]\t\t= { .type = NLA_U32 },\n};\n\nint fib_gw_from_via(struct fib_config *cfg, struct nlattr *nla,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct rtvia *via;\n\tint alen;\n\n\tif (nla_len(nla) < offsetof(struct rtvia, rtvia_addr)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid attribute length for RTA_VIA\");\n\t\treturn -EINVAL;\n\t}\n\n\tvia = nla_data(nla);\n\talen = nla_len(nla) - offsetof(struct rtvia, rtvia_addr);\n\n\tswitch (via->rtvia_family) {\n\tcase AF_INET:\n\t\tif (alen != sizeof(__be32)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid IPv4 address in RTA_VIA\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcfg->fc_gw_family = AF_INET;\n\t\tcfg->fc_gw4 = *((__be32 *)via->rtvia_addr);\n\t\tbreak;\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (alen != sizeof(struct in6_addr)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid IPv6 address in RTA_VIA\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcfg->fc_gw_family = AF_INET6;\n\t\tcfg->fc_gw6 = *((struct in6_addr *)via->rtvia_addr);\n#else\n\t\tNL_SET_ERR_MSG(extack, \"IPv6 support not enabled in kernel\");\n\t\treturn -EINVAL;\n#endif\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG(extack, \"Unsupported address family in RTA_VIA\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtm_to_fib_config(struct net *net, struct sk_buff *skb,\n\t\t\t     struct nlmsghdr *nlh, struct fib_config *cfg,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tbool has_gw = false, has_via = false;\n\tstruct nlattr *attr;\n\tint err, remaining;\n\tstruct rtmsg *rtm;\n\n\terr = nlmsg_validate_deprecated(nlh, sizeof(*rtm), RTA_MAX,\n\t\t\t\t\trtm_ipv4_policy, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\n\trtm = nlmsg_data(nlh);\n\n\tif (!inet_validate_dscp(rtm->rtm_tos)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid dsfield (tos): ECN bits must be 0\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\tcfg->fc_dscp = inet_dsfield_to_dscp(rtm->rtm_tos);\n\n\tcfg->fc_dst_len = rtm->rtm_dst_len;\n\tcfg->fc_table = rtm->rtm_table;\n\tcfg->fc_protocol = rtm->rtm_protocol;\n\tcfg->fc_scope = rtm->rtm_scope;\n\tcfg->fc_type = rtm->rtm_type;\n\tcfg->fc_flags = rtm->rtm_flags;\n\tcfg->fc_nlflags = nlh->nlmsg_flags;\n\n\tcfg->fc_nlinfo.portid = NETLINK_CB(skb).portid;\n\tcfg->fc_nlinfo.nlh = nlh;\n\tcfg->fc_nlinfo.nl_net = net;\n\n\tif (cfg->fc_type > RTN_MAX) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid route type\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\tnlmsg_for_each_attr(attr, nlh, sizeof(struct rtmsg), remaining) {\n\t\tswitch (nla_type(attr)) {\n\t\tcase RTA_DST:\n\t\t\tcfg->fc_dst = nla_get_be32(attr);\n\t\t\tbreak;\n\t\tcase RTA_OIF:\n\t\t\tcfg->fc_oif = nla_get_u32(attr);\n\t\t\tbreak;\n\t\tcase RTA_GATEWAY:\n\t\t\thas_gw = true;\n\t\t\tcfg->fc_gw4 = nla_get_be32(attr);\n\t\t\tif (cfg->fc_gw4)\n\t\t\t\tcfg->fc_gw_family = AF_INET;\n\t\t\tbreak;\n\t\tcase RTA_VIA:\n\t\t\thas_via = true;\n\t\t\terr = fib_gw_from_via(cfg, attr, extack);\n\t\t\tif (err)\n\t\t\t\tgoto errout;\n\t\t\tbreak;\n\t\tcase RTA_PRIORITY:\n\t\t\tcfg->fc_priority = nla_get_u32(attr);\n\t\t\tbreak;\n\t\tcase RTA_PREFSRC:\n\t\t\tcfg->fc_prefsrc = nla_get_be32(attr);\n\t\t\tbreak;\n\t\tcase RTA_METRICS:\n\t\t\tcfg->fc_mx = nla_data(attr);\n\t\t\tcfg->fc_mx_len = nla_len(attr);\n\t\t\tbreak;\n\t\tcase RTA_MULTIPATH:\n\t\t\terr = lwtunnel_valid_encap_type_attr(nla_data(attr),\n\t\t\t\t\t\t\t     nla_len(attr),\n\t\t\t\t\t\t\t     extack);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tcfg->fc_mp = nla_data(attr);\n\t\t\tcfg->fc_mp_len = nla_len(attr);\n\t\t\tbreak;\n\t\tcase RTA_FLOW:\n\t\t\tcfg->fc_flow = nla_get_u32(attr);\n\t\t\tbreak;\n\t\tcase RTA_TABLE:\n\t\t\tcfg->fc_table = nla_get_u32(attr);\n\t\t\tbreak;\n\t\tcase RTA_ENCAP:\n\t\t\tcfg->fc_encap = attr;\n\t\t\tbreak;\n\t\tcase RTA_ENCAP_TYPE:\n\t\t\tcfg->fc_encap_type = nla_get_u16(attr);\n\t\t\terr = lwtunnel_valid_encap_type(cfg->fc_encap_type,\n\t\t\t\t\t\t\textack);\n\t\t\tif (err < 0)\n\t\t\t\tgoto errout;\n\t\t\tbreak;\n\t\tcase RTA_NH_ID:\n\t\t\tcfg->fc_nh_id = nla_get_u32(attr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cfg->fc_nh_id) {\n\t\tif (cfg->fc_oif || cfg->fc_gw_family ||\n\t\t    cfg->fc_encap || cfg->fc_mp) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Nexthop specification and nexthop id are mutually exclusive\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (has_gw && has_via) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Nexthop configuration can not contain both GATEWAY and VIA\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cfg->fc_table)\n\t\tcfg->fc_table = RT_TABLE_MAIN;\n\n\treturn 0;\nerrout:\n\treturn err;\n}\n\nstatic int inet_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib_config cfg;\n\tstruct fib_table *tb;\n\tint err;\n\n\terr = rtm_to_fib_config(net, skb, nlh, &cfg, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tif (cfg.fc_nh_id && !nexthop_find_by_id(net, cfg.fc_nh_id)) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop id does not exist\");\n\t\terr = -EINVAL;\n\t\tgoto errout;\n\t}\n\n\ttb = fib_get_table(net, cfg.fc_table);\n\tif (!tb) {\n\t\tNL_SET_ERR_MSG(extack, \"FIB table does not exist\");\n\t\terr = -ESRCH;\n\t\tgoto errout;\n\t}\n\n\terr = fib_table_delete(net, tb, &cfg, extack);\nerrout:\n\treturn err;\n}\n\nstatic int inet_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib_config cfg;\n\tstruct fib_table *tb;\n\tint err;\n\n\terr = rtm_to_fib_config(net, skb, nlh, &cfg, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\ttb = fib_new_table(net, cfg.fc_table);\n\tif (!tb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\terr = fib_table_insert(net, tb, &cfg, extack);\n\tif (!err && cfg.fc_type == RTN_LOCAL)\n\t\tnet->ipv4.fib_has_custom_local_routes = true;\nerrout:\n\treturn err;\n}\n\nint ip_valid_fib_dump_req(struct net *net, const struct nlmsghdr *nlh,\n\t\t\t  struct fib_dump_filter *filter,\n\t\t\t  struct netlink_callback *cb)\n{\n\tstruct netlink_ext_ack *extack = cb->extack;\n\tstruct nlattr *tb[RTA_MAX + 1];\n\tstruct rtmsg *rtm;\n\tint err, i;\n\n\tASSERT_RTNL();\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*rtm))) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid header for FIB dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\trtm = nlmsg_data(nlh);\n\tif (rtm->rtm_dst_len || rtm->rtm_src_len  || rtm->rtm_tos   ||\n\t    rtm->rtm_scope) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid values in header for FIB dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rtm->rtm_flags & ~(RTM_F_CLONED | RTM_F_PREFIX)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid flags for FIB dump request\");\n\t\treturn -EINVAL;\n\t}\n\tif (rtm->rtm_flags & RTM_F_CLONED)\n\t\tfilter->dump_routes = false;\n\telse\n\t\tfilter->dump_exceptions = false;\n\n\tfilter->flags    = rtm->rtm_flags;\n\tfilter->protocol = rtm->rtm_protocol;\n\tfilter->rt_type  = rtm->rtm_type;\n\tfilter->table_id = rtm->rtm_table;\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t\t    rtm_ipv4_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i <= RTA_MAX; ++i) {\n\t\tint ifindex;\n\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase RTA_TABLE:\n\t\t\tfilter->table_id = nla_get_u32(tb[i]);\n\t\t\tbreak;\n\t\tcase RTA_OIF:\n\t\t\tifindex = nla_get_u32(tb[i]);\n\t\t\tfilter->dev = __dev_get_by_index(net, ifindex);\n\t\t\tif (!filter->dev)\n\t\t\t\treturn -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported attribute in dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (filter->flags || filter->protocol || filter->rt_type ||\n\t    filter->table_id || filter->dev) {\n\t\tfilter->filter_set = 1;\n\t\tcb->answer_flags = NLM_F_DUMP_FILTERED;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ip_valid_fib_dump_req);\n\nstatic int inet_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct fib_dump_filter filter = { .dump_routes = true,\n\t\t\t\t\t  .dump_exceptions = true };\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tunsigned int h, s_h;\n\tunsigned int e = 0, s_e;\n\tstruct fib_table *tb;\n\tstruct hlist_head *head;\n\tint dumped = 0, err;\n\n\tif (cb->strict_check) {\n\t\terr = ip_valid_fib_dump_req(net, nlh, &filter, cb);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (nlmsg_len(nlh) >= sizeof(struct rtmsg)) {\n\t\tstruct rtmsg *rtm = nlmsg_data(nlh);\n\n\t\tfilter.flags = rtm->rtm_flags & (RTM_F_PREFIX | RTM_F_CLONED);\n\t}\n\n\t \n\tif (filter.flags & RTM_F_PREFIX)\n\t\treturn skb->len;\n\n\tif (filter.table_id) {\n\t\ttb = fib_get_table(net, filter.table_id);\n\t\tif (!tb) {\n\t\t\tif (rtnl_msg_family(cb->nlh) != PF_INET)\n\t\t\t\treturn skb->len;\n\n\t\t\tNL_SET_ERR_MSG(cb->extack, \"ipv4: FIB table does not exist\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\trcu_read_lock();\n\t\terr = fib_table_dump(tb, skb, cb, &filter);\n\t\trcu_read_unlock();\n\t\treturn skb->len ? : err;\n\t}\n\n\ts_h = cb->args[0];\n\ts_e = cb->args[1];\n\n\trcu_read_lock();\n\n\tfor (h = s_h; h < FIB_TABLE_HASHSZ; h++, s_e = 0) {\n\t\te = 0;\n\t\thead = &net->ipv4.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(tb, head, tb_hlist) {\n\t\t\tif (e < s_e)\n\t\t\t\tgoto next;\n\t\t\tif (dumped)\n\t\t\t\tmemset(&cb->args[2], 0, sizeof(cb->args) -\n\t\t\t\t\t\t 2 * sizeof(cb->args[0]));\n\t\t\terr = fib_table_dump(tb, skb, cb, &filter);\n\t\t\tif (err < 0) {\n\t\t\t\tif (likely(skb->len))\n\t\t\t\t\tgoto out;\n\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tdumped = 1;\nnext:\n\t\t\te++;\n\t\t}\n\t}\nout:\n\terr = skb->len;\nout_err:\n\trcu_read_unlock();\n\n\tcb->args[1] = e;\n\tcb->args[0] = h;\n\n\treturn err;\n}\n\n \nstatic void fib_magic(int cmd, int type, __be32 dst, int dst_len,\n\t\t      struct in_ifaddr *ifa, u32 rt_priority)\n{\n\tstruct net *net = dev_net(ifa->ifa_dev->dev);\n\tu32 tb_id = l3mdev_fib_table(ifa->ifa_dev->dev);\n\tstruct fib_table *tb;\n\tstruct fib_config cfg = {\n\t\t.fc_protocol = RTPROT_KERNEL,\n\t\t.fc_type = type,\n\t\t.fc_dst = dst,\n\t\t.fc_dst_len = dst_len,\n\t\t.fc_priority = rt_priority,\n\t\t.fc_prefsrc = ifa->ifa_local,\n\t\t.fc_oif = ifa->ifa_dev->dev->ifindex,\n\t\t.fc_nlflags = NLM_F_CREATE | NLM_F_APPEND,\n\t\t.fc_nlinfo = {\n\t\t\t.nl_net = net,\n\t\t},\n\t};\n\n\tif (!tb_id)\n\t\ttb_id = (type == RTN_UNICAST) ? RT_TABLE_MAIN : RT_TABLE_LOCAL;\n\n\ttb = fib_new_table(net, tb_id);\n\tif (!tb)\n\t\treturn;\n\n\tcfg.fc_table = tb->tb_id;\n\n\tif (type != RTN_LOCAL)\n\t\tcfg.fc_scope = RT_SCOPE_LINK;\n\telse\n\t\tcfg.fc_scope = RT_SCOPE_HOST;\n\n\tif (cmd == RTM_NEWROUTE)\n\t\tfib_table_insert(net, tb, &cfg, NULL);\n\telse\n\t\tfib_table_delete(net, tb, &cfg, NULL);\n}\n\nvoid fib_add_ifaddr(struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct net_device *dev = in_dev->dev;\n\tstruct in_ifaddr *prim = ifa;\n\t__be32 mask = ifa->ifa_mask;\n\t__be32 addr = ifa->ifa_local;\n\t__be32 prefix = ifa->ifa_address & mask;\n\n\tif (ifa->ifa_flags & IFA_F_SECONDARY) {\n\t\tprim = inet_ifa_byprefix(in_dev, prefix, mask);\n\t\tif (!prim) {\n\t\t\tpr_warn(\"%s: bug: prim == NULL\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfib_magic(RTM_NEWROUTE, RTN_LOCAL, addr, 32, prim, 0);\n\n\tif (!(dev->flags & IFF_UP))\n\t\treturn;\n\n\t \n\tif (ifa->ifa_broadcast && ifa->ifa_broadcast != htonl(0xFFFFFFFF)) {\n\t\tfib_magic(RTM_NEWROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32,\n\t\t\t  prim, 0);\n\t\tarp_invalidate(dev, ifa->ifa_broadcast, false);\n\t}\n\n\tif (!ipv4_is_zeronet(prefix) && !(ifa->ifa_flags & IFA_F_SECONDARY) &&\n\t    (prefix != addr || ifa->ifa_prefixlen < 32)) {\n\t\tif (!(ifa->ifa_flags & IFA_F_NOPREFIXROUTE))\n\t\t\tfib_magic(RTM_NEWROUTE,\n\t\t\t\t  dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,\n\t\t\t\t  prefix, ifa->ifa_prefixlen, prim,\n\t\t\t\t  ifa->ifa_rt_priority);\n\n\t\t \n\t\tif (ifa->ifa_prefixlen < 31) {\n\t\t\tfib_magic(RTM_NEWROUTE, RTN_BROADCAST, prefix | ~mask,\n\t\t\t\t  32, prim, 0);\n\t\t\tarp_invalidate(dev, prefix | ~mask, false);\n\t\t}\n\t}\n}\n\nvoid fib_modify_prefix_metric(struct in_ifaddr *ifa, u32 new_metric)\n{\n\t__be32 prefix = ifa->ifa_address & ifa->ifa_mask;\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct net_device *dev = in_dev->dev;\n\n\tif (!(dev->flags & IFF_UP) ||\n\t    ifa->ifa_flags & (IFA_F_SECONDARY | IFA_F_NOPREFIXROUTE) ||\n\t    ipv4_is_zeronet(prefix) ||\n\t    (prefix == ifa->ifa_local && ifa->ifa_prefixlen == 32))\n\t\treturn;\n\n\t \n\tfib_magic(RTM_NEWROUTE,\n\t\t  dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,\n\t\t  prefix, ifa->ifa_prefixlen, ifa, new_metric);\n\n\t \n\tfib_magic(RTM_DELROUTE,\n\t\t  dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,\n\t\t  prefix, ifa->ifa_prefixlen, ifa, ifa->ifa_rt_priority);\n}\n\n \nvoid fib_del_ifaddr(struct in_ifaddr *ifa, struct in_ifaddr *iprim)\n{\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct net_device *dev = in_dev->dev;\n\tstruct in_ifaddr *ifa1;\n\tstruct in_ifaddr *prim = ifa, *prim1 = NULL;\n\t__be32 brd = ifa->ifa_address | ~ifa->ifa_mask;\n\t__be32 any = ifa->ifa_address & ifa->ifa_mask;\n#define LOCAL_OK\t1\n#define BRD_OK\t\t2\n#define BRD0_OK\t\t4\n#define BRD1_OK\t\t8\n\tunsigned int ok = 0;\n\tint subnet = 0;\t\t \n\tint gone = 1;\t\t \n\tint same_prefsrc = 0;\t \n\n\tif (ifa->ifa_flags & IFA_F_SECONDARY) {\n\t\tprim = inet_ifa_byprefix(in_dev, any, ifa->ifa_mask);\n\t\tif (!prim) {\n\t\t\t \n\t\t\tif (!in_dev->dead)\n\t\t\t\tpr_warn(\"%s: bug: prim == NULL\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tif (iprim && iprim != prim) {\n\t\t\tpr_warn(\"%s: bug: iprim != prim\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t} else if (!ipv4_is_zeronet(any) &&\n\t\t   (any != ifa->ifa_local || ifa->ifa_prefixlen < 32)) {\n\t\tif (!(ifa->ifa_flags & IFA_F_NOPREFIXROUTE))\n\t\t\tfib_magic(RTM_DELROUTE,\n\t\t\t\t  dev->flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST,\n\t\t\t\t  any, ifa->ifa_prefixlen, prim, 0);\n\t\tsubnet = 1;\n\t}\n\n\tif (in_dev->dead)\n\t\tgoto no_promotions;\n\n\t \n\trcu_read_lock();\n\tin_dev_for_each_ifa_rcu(ifa1, in_dev) {\n\t\tif (ifa1 == ifa) {\n\t\t\t \n\t\t\tgone = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (iprim && ifa1->ifa_mask == iprim->ifa_mask &&\n\t\t    inet_ifa_match(ifa1->ifa_address, iprim))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ifa1->ifa_flags & IFA_F_SECONDARY) {\n\t\t\t \n\t\t\tif (ifa1->ifa_mask == prim->ifa_mask &&\n\t\t\t    inet_ifa_match(ifa1->ifa_address, prim))\n\t\t\t\tprim1 = prim;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tif (!same_prefsrc)\n\t\t\t\t\tcontinue;\n\t\t\t\t \n\t\t\t\tif (!prim1 ||\n\t\t\t\t    ifa1->ifa_mask != prim1->ifa_mask ||\n\t\t\t\t    !inet_ifa_match(ifa1->ifa_address, prim1))\n\t\t\t\t\tprim1 = inet_ifa_byprefix(in_dev,\n\t\t\t\t\t\t\tifa1->ifa_address,\n\t\t\t\t\t\t\tifa1->ifa_mask);\n\t\t\t\tif (!prim1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (prim1->ifa_local != prim->ifa_local)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (prim->ifa_local != ifa1->ifa_local)\n\t\t\t\tcontinue;\n\t\t\tprim1 = ifa1;\n\t\t\tif (prim != prim1)\n\t\t\t\tsame_prefsrc = 1;\n\t\t}\n\t\tif (ifa->ifa_local == ifa1->ifa_local)\n\t\t\tok |= LOCAL_OK;\n\t\tif (ifa->ifa_broadcast == ifa1->ifa_broadcast)\n\t\t\tok |= BRD_OK;\n\t\tif (brd == ifa1->ifa_broadcast)\n\t\t\tok |= BRD1_OK;\n\t\tif (any == ifa1->ifa_broadcast)\n\t\t\tok |= BRD0_OK;\n\t\t \n\t\tif (prim1 == ifa1 && ifa1->ifa_prefixlen < 31) {\n\t\t\t__be32 brd1 = ifa1->ifa_address | ~ifa1->ifa_mask;\n\t\t\t__be32 any1 = ifa1->ifa_address & ifa1->ifa_mask;\n\n\t\t\tif (!ipv4_is_zeronet(any1)) {\n\t\t\t\tif (ifa->ifa_broadcast == brd1 ||\n\t\t\t\t    ifa->ifa_broadcast == any1)\n\t\t\t\t\tok |= BRD_OK;\n\t\t\t\tif (brd == brd1 || brd == any1)\n\t\t\t\t\tok |= BRD1_OK;\n\t\t\t\tif (any == brd1 || any == any1)\n\t\t\t\t\tok |= BRD0_OK;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\nno_promotions:\n\tif (!(ok & BRD_OK))\n\t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32,\n\t\t\t  prim, 0);\n\tif (subnet && ifa->ifa_prefixlen < 31) {\n\t\tif (!(ok & BRD1_OK))\n\t\t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, brd, 32,\n\t\t\t\t  prim, 0);\n\t\tif (!(ok & BRD0_OK))\n\t\t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, any, 32,\n\t\t\t\t  prim, 0);\n\t}\n\tif (!(ok & LOCAL_OK)) {\n\t\tunsigned int addr_type;\n\n\t\tfib_magic(RTM_DELROUTE, RTN_LOCAL, ifa->ifa_local, 32, prim, 0);\n\n\t\t \n\t\taddr_type = inet_addr_type_dev_table(dev_net(dev), dev,\n\t\t\t\t\t\t     ifa->ifa_local);\n\t\tif (gone && addr_type != RTN_LOCAL) {\n\t\t\t \n\t\t\tif (fib_sync_down_addr(dev, ifa->ifa_local))\n\t\t\t\tfib_flush(dev_net(dev));\n\t\t}\n\t}\n#undef LOCAL_OK\n#undef BRD_OK\n#undef BRD0_OK\n#undef BRD1_OK\n}\n\nstatic void nl_fib_lookup(struct net *net, struct fib_result_nl *frn)\n{\n\n\tstruct fib_result       res;\n\tstruct flowi4           fl4 = {\n\t\t.flowi4_mark = frn->fl_mark,\n\t\t.daddr = frn->fl_addr,\n\t\t.flowi4_tos = frn->fl_tos,\n\t\t.flowi4_scope = frn->fl_scope,\n\t};\n\tstruct fib_table *tb;\n\n\trcu_read_lock();\n\n\ttb = fib_get_table(net, frn->tb_id_in);\n\n\tfrn->err = -ENOENT;\n\tif (tb) {\n\t\tlocal_bh_disable();\n\n\t\tfrn->tb_id = tb->tb_id;\n\t\tfrn->err = fib_table_lookup(tb, &fl4, &res, FIB_LOOKUP_NOREF);\n\n\t\tif (!frn->err) {\n\t\t\tfrn->prefixlen = res.prefixlen;\n\t\t\tfrn->nh_sel = res.nh_sel;\n\t\t\tfrn->type = res.type;\n\t\t\tfrn->scope = res.scope;\n\t\t}\n\t\tlocal_bh_enable();\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic void nl_fib_input(struct sk_buff *skb)\n{\n\tstruct net *net;\n\tstruct fib_result_nl *frn;\n\tstruct nlmsghdr *nlh;\n\tu32 portid;\n\n\tnet = sock_net(skb->sk);\n\tnlh = nlmsg_hdr(skb);\n\tif (skb->len < nlmsg_total_size(sizeof(*frn)) ||\n\t    skb->len < nlh->nlmsg_len ||\n\t    nlmsg_len(nlh) < sizeof(*frn))\n\t\treturn;\n\n\tskb = netlink_skb_clone(skb, GFP_KERNEL);\n\tif (!skb)\n\t\treturn;\n\tnlh = nlmsg_hdr(skb);\n\n\tfrn = nlmsg_data(nlh);\n\tnl_fib_lookup(net, frn);\n\n\tportid = NETLINK_CB(skb).portid;       \n\tNETLINK_CB(skb).portid = 0;         \n\tNETLINK_CB(skb).dst_group = 0;   \n\tnlmsg_unicast(net->ipv4.fibnl, skb, portid);\n}\n\nstatic int __net_init nl_fib_lookup_init(struct net *net)\n{\n\tstruct sock *sk;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= nl_fib_input,\n\t};\n\n\tsk = netlink_kernel_create(net, NETLINK_FIB_LOOKUP, &cfg);\n\tif (!sk)\n\t\treturn -EAFNOSUPPORT;\n\tnet->ipv4.fibnl = sk;\n\treturn 0;\n}\n\nstatic void nl_fib_lookup_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->ipv4.fibnl);\n\tnet->ipv4.fibnl = NULL;\n}\n\nstatic void fib_disable_ip(struct net_device *dev, unsigned long event,\n\t\t\t   bool force)\n{\n\tif (fib_sync_down_dev(dev, event, force))\n\t\tfib_flush(dev_net(dev));\n\telse\n\t\trt_cache_flush(dev_net(dev));\n\tarp_ifdown(dev);\n}\n\nstatic int fib_inetaddr_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct in_ifaddr *ifa = ptr;\n\tstruct net_device *dev = ifa->ifa_dev->dev;\n\tstruct net *net = dev_net(dev);\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tfib_add_ifaddr(ifa);\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\t\tfib_sync_up(dev, RTNH_F_DEAD);\n#endif\n\t\tatomic_inc(&net->ipv4.dev_addr_genid);\n\t\trt_cache_flush(dev_net(dev));\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tfib_del_ifaddr(ifa, NULL);\n\t\tatomic_inc(&net->ipv4.dev_addr_genid);\n\t\tif (!ifa->ifa_dev->ifa_list) {\n\t\t\t \n\t\t\tfib_disable_ip(dev, event, true);\n\t\t} else {\n\t\t\trt_cache_flush(dev_net(dev));\n\t\t}\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic int fib_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_changeupper_info *upper_info = ptr;\n\tstruct netdev_notifier_info_ext *info_ext = ptr;\n\tstruct in_device *in_dev;\n\tstruct net *net = dev_net(dev);\n\tstruct in_ifaddr *ifa;\n\tunsigned int flags;\n\n\tif (event == NETDEV_UNREGISTER) {\n\t\tfib_disable_ip(dev, event, true);\n\t\trt_flush_dev(dev);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tin_dev = __in_dev_get_rtnl(dev);\n\tif (!in_dev)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tin_dev_for_each_ifa_rtnl(ifa, in_dev) {\n\t\t\tfib_add_ifaddr(ifa);\n\t\t}\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\t\tfib_sync_up(dev, RTNH_F_DEAD);\n#endif\n\t\tatomic_inc(&net->ipv4.dev_addr_genid);\n\t\trt_cache_flush(net);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tfib_disable_ip(dev, event, false);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tflags = dev_get_flags(dev);\n\t\tif (flags & (IFF_RUNNING | IFF_LOWER_UP))\n\t\t\tfib_sync_up(dev, RTNH_F_LINKDOWN);\n\t\telse\n\t\t\tfib_sync_down_dev(dev, event, false);\n\t\trt_cache_flush(net);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tfib_sync_mtu(dev, info_ext->ext.mtu);\n\t\trt_cache_flush(net);\n\t\tbreak;\n\tcase NETDEV_CHANGEUPPER:\n\t\tupper_info = ptr;\n\t\t \n\t\tif (upper_info->upper_dev &&\n\t\t    netif_is_l3_master(upper_info->upper_dev))\n\t\t\tfib_disable_ip(dev, NETDEV_DOWN, true);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block fib_inetaddr_notifier = {\n\t.notifier_call = fib_inetaddr_event,\n};\n\nstatic struct notifier_block fib_netdev_notifier = {\n\t.notifier_call = fib_netdev_event,\n};\n\nstatic int __net_init ip_fib_net_init(struct net *net)\n{\n\tint err;\n\tsize_t size = sizeof(struct hlist_head) * FIB_TABLE_HASHSZ;\n\n\terr = fib4_notifier_init(net);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\t \n\tnet->ipv4.sysctl_fib_multipath_hash_fields =\n\t\tFIB_MULTIPATH_HASH_FIELD_DEFAULT_MASK;\n#endif\n\n\t \n\tsize = max_t(size_t, size, L1_CACHE_BYTES);\n\n\tnet->ipv4.fib_table_hash = kzalloc(size, GFP_KERNEL);\n\tif (!net->ipv4.fib_table_hash) {\n\t\terr = -ENOMEM;\n\t\tgoto err_table_hash_alloc;\n\t}\n\n\terr = fib4_rules_init(net);\n\tif (err < 0)\n\t\tgoto err_rules_init;\n\treturn 0;\n\nerr_rules_init:\n\tkfree(net->ipv4.fib_table_hash);\nerr_table_hash_alloc:\n\tfib4_notifier_exit(net);\n\treturn err;\n}\n\nstatic void ip_fib_net_exit(struct net *net)\n{\n\tint i;\n\n\tASSERT_RTNL();\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n\tRCU_INIT_POINTER(net->ipv4.fib_main, NULL);\n\tRCU_INIT_POINTER(net->ipv4.fib_default, NULL);\n#endif\n\t \n\tfor (i = FIB_TABLE_HASHSZ - 1; i >= 0; i--) {\n\t\tstruct hlist_head *head = &net->ipv4.fib_table_hash[i];\n\t\tstruct hlist_node *tmp;\n\t\tstruct fib_table *tb;\n\n\t\thlist_for_each_entry_safe(tb, tmp, head, tb_hlist) {\n\t\t\thlist_del(&tb->tb_hlist);\n\t\t\tfib_table_flush(net, tb, true);\n\t\t\tfib_free_table(tb);\n\t\t}\n\t}\n\n#ifdef CONFIG_IP_MULTIPLE_TABLES\n\tfib4_rules_exit(net);\n#endif\n\n\tkfree(net->ipv4.fib_table_hash);\n\tfib4_notifier_exit(net);\n}\n\nstatic int __net_init fib_net_init(struct net *net)\n{\n\tint error;\n\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tatomic_set(&net->ipv4.fib_num_tclassid_users, 0);\n#endif\n\terror = ip_fib_net_init(net);\n\tif (error < 0)\n\t\tgoto out;\n\terror = nl_fib_lookup_init(net);\n\tif (error < 0)\n\t\tgoto out_nlfl;\n\terror = fib_proc_init(net);\n\tif (error < 0)\n\t\tgoto out_proc;\nout:\n\treturn error;\n\nout_proc:\n\tnl_fib_lookup_exit(net);\nout_nlfl:\n\trtnl_lock();\n\tip_fib_net_exit(net);\n\trtnl_unlock();\n\tgoto out;\n}\n\nstatic void __net_exit fib_net_exit(struct net *net)\n{\n\tfib_proc_exit(net);\n\tnl_fib_lookup_exit(net);\n}\n\nstatic void __net_exit fib_net_exit_batch(struct list_head *net_list)\n{\n\tstruct net *net;\n\n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list)\n\t\tip_fib_net_exit(net);\n\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations fib_net_ops = {\n\t.init = fib_net_init,\n\t.exit = fib_net_exit,\n\t.exit_batch = fib_net_exit_batch,\n};\n\nvoid __init ip_fib_init(void)\n{\n\tfib_trie_init();\n\n\tregister_pernet_subsys(&fib_net_ops);\n\n\tregister_netdevice_notifier(&fib_netdev_notifier);\n\tregister_inetaddr_notifier(&fib_inetaddr_notifier);\n\n\trtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL, 0);\n\trtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL, 0);\n\trtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}