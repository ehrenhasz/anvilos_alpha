{
  "module_name": "fib_trie.c",
  "hash_id": "d42b75b02822d0cd7ed48b6e4ad86ba8d8c95d1f1ce57fc33943fa5aaeccc612",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/fib_trie.c",
  "human_readable_source": "\n \n#include <linux/cache.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/proc_fs.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <linux/netlink.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/notifier.h>\n#include <net/net_namespace.h>\n#include <net/inet_dscp.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/route.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <net/ip_fib.h>\n#include <net/fib_notifier.h>\n#include <trace/events/fib.h>\n#include \"fib_lookup.h\"\n\nstatic int call_fib_entry_notifier(struct notifier_block *nb,\n\t\t\t\t   enum fib_event_type event_type, u32 dst,\n\t\t\t\t   int dst_len, struct fib_alias *fa,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct fib_entry_notifier_info info = {\n\t\t.info.extack = extack,\n\t\t.dst = dst,\n\t\t.dst_len = dst_len,\n\t\t.fi = fa->fa_info,\n\t\t.dscp = fa->fa_dscp,\n\t\t.type = fa->fa_type,\n\t\t.tb_id = fa->tb_id,\n\t};\n\treturn call_fib4_notifier(nb, event_type, &info.info);\n}\n\nstatic int call_fib_entry_notifiers(struct net *net,\n\t\t\t\t    enum fib_event_type event_type, u32 dst,\n\t\t\t\t    int dst_len, struct fib_alias *fa,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib_entry_notifier_info info = {\n\t\t.info.extack = extack,\n\t\t.dst = dst,\n\t\t.dst_len = dst_len,\n\t\t.fi = fa->fa_info,\n\t\t.dscp = fa->fa_dscp,\n\t\t.type = fa->fa_type,\n\t\t.tb_id = fa->tb_id,\n\t};\n\treturn call_fib4_notifiers(net, event_type, &info.info);\n}\n\n#define MAX_STAT_DEPTH 32\n\n#define KEYLENGTH\t(8*sizeof(t_key))\n#define KEY_MAX\t\t((t_key)~0)\n\ntypedef unsigned int t_key;\n\n#define IS_TRIE(n)\t((n)->pos >= KEYLENGTH)\n#define IS_TNODE(n)\t((n)->bits)\n#define IS_LEAF(n)\t(!(n)->bits)\n\nstruct key_vector {\n\tt_key key;\n\tunsigned char pos;\t\t \n\tunsigned char bits;\t\t \n\tunsigned char slen;\n\tunion {\n\t\t \n\t\tstruct hlist_head leaf;\n\t\t \n\t\tDECLARE_FLEX_ARRAY(struct key_vector __rcu *, tnode);\n\t};\n};\n\nstruct tnode {\n\tstruct rcu_head rcu;\n\tt_key empty_children;\t\t \n\tt_key full_children;\t\t \n\tstruct key_vector __rcu *parent;\n\tstruct key_vector kv[1];\n#define tn_bits kv[0].bits\n};\n\n#define TNODE_SIZE(n)\toffsetof(struct tnode, kv[0].tnode[n])\n#define LEAF_SIZE\tTNODE_SIZE(1)\n\n#ifdef CONFIG_IP_FIB_TRIE_STATS\nstruct trie_use_stats {\n\tunsigned int gets;\n\tunsigned int backtrack;\n\tunsigned int semantic_match_passed;\n\tunsigned int semantic_match_miss;\n\tunsigned int null_node_hit;\n\tunsigned int resize_node_skipped;\n};\n#endif\n\nstruct trie_stat {\n\tunsigned int totdepth;\n\tunsigned int maxdepth;\n\tunsigned int tnodes;\n\tunsigned int leaves;\n\tunsigned int nullpointers;\n\tunsigned int prefixes;\n\tunsigned int nodesizes[MAX_STAT_DEPTH];\n};\n\nstruct trie {\n\tstruct key_vector kv[1];\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\tstruct trie_use_stats __percpu *stats;\n#endif\n};\n\nstatic struct key_vector *resize(struct trie *t, struct key_vector *tn);\nstatic unsigned int tnode_free_size;\n\n \nunsigned int sysctl_fib_sync_mem = 512 * 1024;\nunsigned int sysctl_fib_sync_mem_min = 64 * 1024;\nunsigned int sysctl_fib_sync_mem_max = 64 * 1024 * 1024;\n\nstatic struct kmem_cache *fn_alias_kmem __ro_after_init;\nstatic struct kmem_cache *trie_leaf_kmem __ro_after_init;\n\nstatic inline struct tnode *tn_info(struct key_vector *kv)\n{\n\treturn container_of(kv, struct tnode, kv[0]);\n}\n\n \n#define node_parent(tn) rtnl_dereference(tn_info(tn)->parent)\n#define get_child(tn, i) rtnl_dereference((tn)->tnode[i])\n\n \n#define node_parent_rcu(tn) rcu_dereference_rtnl(tn_info(tn)->parent)\n#define get_child_rcu(tn, i) rcu_dereference_rtnl((tn)->tnode[i])\n\n \nstatic inline void node_set_parent(struct key_vector *n, struct key_vector *tp)\n{\n\tif (n)\n\t\trcu_assign_pointer(tn_info(n)->parent, tp);\n}\n\n#define NODE_INIT_PARENT(n, p) RCU_INIT_POINTER(tn_info(n)->parent, p)\n\n \nstatic inline unsigned long child_length(const struct key_vector *tn)\n{\n\treturn (1ul << tn->bits) & ~(1ul);\n}\n\n#define get_cindex(key, kv) (((key) ^ (kv)->key) >> (kv)->pos)\n\nstatic inline unsigned long get_index(t_key key, struct key_vector *kv)\n{\n\tunsigned long index = key ^ kv->key;\n\n\tif ((BITS_PER_LONG <= KEYLENGTH) && (KEYLENGTH == kv->pos))\n\t\treturn 0;\n\n\treturn index >> kv->pos;\n}\n\n \n\nstatic const int halve_threshold = 25;\nstatic const int inflate_threshold = 50;\nstatic const int halve_threshold_root = 15;\nstatic const int inflate_threshold_root = 30;\n\nstatic void __alias_free_mem(struct rcu_head *head)\n{\n\tstruct fib_alias *fa = container_of(head, struct fib_alias, rcu);\n\tkmem_cache_free(fn_alias_kmem, fa);\n}\n\nstatic inline void alias_free_mem_rcu(struct fib_alias *fa)\n{\n\tcall_rcu(&fa->rcu, __alias_free_mem);\n}\n\n#define TNODE_VMALLOC_MAX \\\n\tilog2((SIZE_MAX - TNODE_SIZE(0)) / sizeof(struct key_vector *))\n\nstatic void __node_free_rcu(struct rcu_head *head)\n{\n\tstruct tnode *n = container_of(head, struct tnode, rcu);\n\n\tif (!n->tn_bits)\n\t\tkmem_cache_free(trie_leaf_kmem, n);\n\telse\n\t\tkvfree(n);\n}\n\n#define node_free(n) call_rcu(&tn_info(n)->rcu, __node_free_rcu)\n\nstatic struct tnode *tnode_alloc(int bits)\n{\n\tsize_t size;\n\n\t \n\tif (bits > TNODE_VMALLOC_MAX)\n\t\treturn NULL;\n\n\t \n\tsize = TNODE_SIZE(1ul << bits);\n\n\tif (size <= PAGE_SIZE)\n\t\treturn kzalloc(size, GFP_KERNEL);\n\telse\n\t\treturn vzalloc(size);\n}\n\nstatic inline void empty_child_inc(struct key_vector *n)\n{\n\ttn_info(n)->empty_children++;\n\n\tif (!tn_info(n)->empty_children)\n\t\ttn_info(n)->full_children++;\n}\n\nstatic inline void empty_child_dec(struct key_vector *n)\n{\n\tif (!tn_info(n)->empty_children)\n\t\ttn_info(n)->full_children--;\n\n\ttn_info(n)->empty_children--;\n}\n\nstatic struct key_vector *leaf_new(t_key key, struct fib_alias *fa)\n{\n\tstruct key_vector *l;\n\tstruct tnode *kv;\n\n\tkv = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);\n\tif (!kv)\n\t\treturn NULL;\n\n\t \n\tl = kv->kv;\n\tl->key = key;\n\tl->pos = 0;\n\tl->bits = 0;\n\tl->slen = fa->fa_slen;\n\n\t \n\tINIT_HLIST_HEAD(&l->leaf);\n\thlist_add_head(&fa->fa_list, &l->leaf);\n\n\treturn l;\n}\n\nstatic struct key_vector *tnode_new(t_key key, int pos, int bits)\n{\n\tunsigned int shift = pos + bits;\n\tstruct key_vector *tn;\n\tstruct tnode *tnode;\n\n\t \n\tBUG_ON(!bits || (shift > KEYLENGTH));\n\n\ttnode = tnode_alloc(bits);\n\tif (!tnode)\n\t\treturn NULL;\n\n\tpr_debug(\"AT %p s=%zu %zu\\n\", tnode, TNODE_SIZE(0),\n\t\t sizeof(struct key_vector *) << bits);\n\n\tif (bits == KEYLENGTH)\n\t\ttnode->full_children = 1;\n\telse\n\t\ttnode->empty_children = 1ul << bits;\n\n\ttn = tnode->kv;\n\ttn->key = (shift < KEYLENGTH) ? (key >> shift) << shift : 0;\n\ttn->pos = pos;\n\ttn->bits = bits;\n\ttn->slen = pos;\n\n\treturn tn;\n}\n\n \nstatic inline int tnode_full(struct key_vector *tn, struct key_vector *n)\n{\n\treturn n && ((n->pos + n->bits) == tn->pos) && IS_TNODE(n);\n}\n\n \nstatic void put_child(struct key_vector *tn, unsigned long i,\n\t\t      struct key_vector *n)\n{\n\tstruct key_vector *chi = get_child(tn, i);\n\tint isfull, wasfull;\n\n\tBUG_ON(i >= child_length(tn));\n\n\t \n\tif (!n && chi)\n\t\tempty_child_inc(tn);\n\tif (n && !chi)\n\t\tempty_child_dec(tn);\n\n\t \n\twasfull = tnode_full(tn, chi);\n\tisfull = tnode_full(tn, n);\n\n\tif (wasfull && !isfull)\n\t\ttn_info(tn)->full_children--;\n\telse if (!wasfull && isfull)\n\t\ttn_info(tn)->full_children++;\n\n\tif (n && (tn->slen < n->slen))\n\t\ttn->slen = n->slen;\n\n\trcu_assign_pointer(tn->tnode[i], n);\n}\n\nstatic void update_children(struct key_vector *tn)\n{\n\tunsigned long i;\n\n\t \n\tfor (i = child_length(tn); i;) {\n\t\tstruct key_vector *inode = get_child(tn, --i);\n\n\t\tif (!inode)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (node_parent(inode) == tn)\n\t\t\tupdate_children(inode);\n\t\telse\n\t\t\tnode_set_parent(inode, tn);\n\t}\n}\n\nstatic inline void put_child_root(struct key_vector *tp, t_key key,\n\t\t\t\t  struct key_vector *n)\n{\n\tif (IS_TRIE(tp))\n\t\trcu_assign_pointer(tp->tnode[0], n);\n\telse\n\t\tput_child(tp, get_index(key, tp), n);\n}\n\nstatic inline void tnode_free_init(struct key_vector *tn)\n{\n\ttn_info(tn)->rcu.next = NULL;\n}\n\nstatic inline void tnode_free_append(struct key_vector *tn,\n\t\t\t\t     struct key_vector *n)\n{\n\ttn_info(n)->rcu.next = tn_info(tn)->rcu.next;\n\ttn_info(tn)->rcu.next = &tn_info(n)->rcu;\n}\n\nstatic void tnode_free(struct key_vector *tn)\n{\n\tstruct callback_head *head = &tn_info(tn)->rcu;\n\n\twhile (head) {\n\t\thead = head->next;\n\t\ttnode_free_size += TNODE_SIZE(1ul << tn->bits);\n\t\tnode_free(tn);\n\n\t\ttn = container_of(head, struct tnode, rcu)->kv;\n\t}\n\n\tif (tnode_free_size >= READ_ONCE(sysctl_fib_sync_mem)) {\n\t\ttnode_free_size = 0;\n\t\tsynchronize_rcu();\n\t}\n}\n\nstatic struct key_vector *replace(struct trie *t,\n\t\t\t\t  struct key_vector *oldtnode,\n\t\t\t\t  struct key_vector *tn)\n{\n\tstruct key_vector *tp = node_parent(oldtnode);\n\tunsigned long i;\n\n\t \n\tNODE_INIT_PARENT(tn, tp);\n\tput_child_root(tp, tn->key, tn);\n\n\t \n\tupdate_children(tn);\n\n\t \n\ttnode_free(oldtnode);\n\n\t \n\tfor (i = child_length(tn); i;) {\n\t\tstruct key_vector *inode = get_child(tn, --i);\n\n\t\t \n\t\tif (tnode_full(tn, inode))\n\t\t\ttn = resize(t, inode);\n\t}\n\n\treturn tp;\n}\n\nstatic struct key_vector *inflate(struct trie *t,\n\t\t\t\t  struct key_vector *oldtnode)\n{\n\tstruct key_vector *tn;\n\tunsigned long i;\n\tt_key m;\n\n\tpr_debug(\"In inflate\\n\");\n\n\ttn = tnode_new(oldtnode->key, oldtnode->pos - 1, oldtnode->bits + 1);\n\tif (!tn)\n\t\tgoto notnode;\n\n\t \n\ttnode_free_init(oldtnode);\n\n\t \n\tfor (i = child_length(oldtnode), m = 1u << tn->pos; i;) {\n\t\tstruct key_vector *inode = get_child(oldtnode, --i);\n\t\tstruct key_vector *node0, *node1;\n\t\tunsigned long j, k;\n\n\t\t \n\t\tif (!inode)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!tnode_full(oldtnode, inode)) {\n\t\t\tput_child(tn, get_index(inode->key, tn), inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\ttnode_free_append(oldtnode, inode);\n\n\t\t \n\t\tif (inode->bits == 1) {\n\t\t\tput_child(tn, 2 * i + 1, get_child(inode, 1));\n\t\t\tput_child(tn, 2 * i, get_child(inode, 0));\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tnode1 = tnode_new(inode->key | m, inode->pos, inode->bits - 1);\n\t\tif (!node1)\n\t\t\tgoto nomem;\n\t\tnode0 = tnode_new(inode->key, inode->pos, inode->bits - 1);\n\n\t\ttnode_free_append(tn, node1);\n\t\tif (!node0)\n\t\t\tgoto nomem;\n\t\ttnode_free_append(tn, node0);\n\n\t\t \n\t\tfor (k = child_length(inode), j = k / 2; j;) {\n\t\t\tput_child(node1, --j, get_child(inode, --k));\n\t\t\tput_child(node0, j, get_child(inode, j));\n\t\t\tput_child(node1, --j, get_child(inode, --k));\n\t\t\tput_child(node0, j, get_child(inode, j));\n\t\t}\n\n\t\t \n\t\tNODE_INIT_PARENT(node1, tn);\n\t\tNODE_INIT_PARENT(node0, tn);\n\n\t\t \n\t\tput_child(tn, 2 * i + 1, node1);\n\t\tput_child(tn, 2 * i, node0);\n\t}\n\n\t \n\treturn replace(t, oldtnode, tn);\nnomem:\n\t \n\ttnode_free(tn);\nnotnode:\n\treturn NULL;\n}\n\nstatic struct key_vector *halve(struct trie *t,\n\t\t\t\tstruct key_vector *oldtnode)\n{\n\tstruct key_vector *tn;\n\tunsigned long i;\n\n\tpr_debug(\"In halve\\n\");\n\n\ttn = tnode_new(oldtnode->key, oldtnode->pos + 1, oldtnode->bits - 1);\n\tif (!tn)\n\t\tgoto notnode;\n\n\t \n\ttnode_free_init(oldtnode);\n\n\t \n\tfor (i = child_length(oldtnode); i;) {\n\t\tstruct key_vector *node1 = get_child(oldtnode, --i);\n\t\tstruct key_vector *node0 = get_child(oldtnode, --i);\n\t\tstruct key_vector *inode;\n\n\t\t \n\t\tif (!node1 || !node0) {\n\t\t\tput_child(tn, i / 2, node1 ? : node0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tinode = tnode_new(node0->key, oldtnode->pos, 1);\n\t\tif (!inode)\n\t\t\tgoto nomem;\n\t\ttnode_free_append(tn, inode);\n\n\t\t \n\t\tput_child(inode, 1, node1);\n\t\tput_child(inode, 0, node0);\n\t\tNODE_INIT_PARENT(inode, tn);\n\n\t\t \n\t\tput_child(tn, i / 2, inode);\n\t}\n\n\t \n\treturn replace(t, oldtnode, tn);\nnomem:\n\t \n\ttnode_free(tn);\nnotnode:\n\treturn NULL;\n}\n\nstatic struct key_vector *collapse(struct trie *t,\n\t\t\t\t   struct key_vector *oldtnode)\n{\n\tstruct key_vector *n, *tp;\n\tunsigned long i;\n\n\t \n\tfor (n = NULL, i = child_length(oldtnode); !n && i;)\n\t\tn = get_child(oldtnode, --i);\n\n\t \n\ttp = node_parent(oldtnode);\n\tput_child_root(tp, oldtnode->key, n);\n\tnode_set_parent(n, tp);\n\n\t \n\tnode_free(oldtnode);\n\n\treturn tp;\n}\n\nstatic unsigned char update_suffix(struct key_vector *tn)\n{\n\tunsigned char slen = tn->pos;\n\tunsigned long stride, i;\n\tunsigned char slen_max;\n\n\t \n\tslen_max = min_t(unsigned char, tn->pos + tn->bits - 1, tn->slen);\n\n\t \n\tfor (i = 0, stride = 0x2ul ; i < child_length(tn); i += stride) {\n\t\tstruct key_vector *n = get_child(tn, i);\n\n\t\tif (!n || (n->slen <= slen))\n\t\t\tcontinue;\n\n\t\t \n\t\tstride <<= (n->slen - slen);\n\t\tslen = n->slen;\n\t\ti &= ~(stride - 1);\n\n\t\t \n\t\tif (slen >= slen_max)\n\t\t\tbreak;\n\t}\n\n\ttn->slen = slen;\n\n\treturn slen;\n}\n\n \nstatic inline bool should_inflate(struct key_vector *tp, struct key_vector *tn)\n{\n\tunsigned long used = child_length(tn);\n\tunsigned long threshold = used;\n\n\t \n\tthreshold *= IS_TRIE(tp) ? inflate_threshold_root : inflate_threshold;\n\tused -= tn_info(tn)->empty_children;\n\tused += tn_info(tn)->full_children;\n\n\t \n\n\treturn (used > 1) && tn->pos && ((50 * used) >= threshold);\n}\n\nstatic inline bool should_halve(struct key_vector *tp, struct key_vector *tn)\n{\n\tunsigned long used = child_length(tn);\n\tunsigned long threshold = used;\n\n\t \n\tthreshold *= IS_TRIE(tp) ? halve_threshold_root : halve_threshold;\n\tused -= tn_info(tn)->empty_children;\n\n\t \n\n\treturn (used > 1) && (tn->bits > 1) && ((100 * used) < threshold);\n}\n\nstatic inline bool should_collapse(struct key_vector *tn)\n{\n\tunsigned long used = child_length(tn);\n\n\tused -= tn_info(tn)->empty_children;\n\n\t \n\tif ((tn->bits == KEYLENGTH) && tn_info(tn)->full_children)\n\t\tused -= KEY_MAX;\n\n\t \n\treturn used < 2;\n}\n\n#define MAX_WORK 10\nstatic struct key_vector *resize(struct trie *t, struct key_vector *tn)\n{\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\tstruct trie_use_stats __percpu *stats = t->stats;\n#endif\n\tstruct key_vector *tp = node_parent(tn);\n\tunsigned long cindex = get_index(tn->key, tp);\n\tint max_work = MAX_WORK;\n\n\tpr_debug(\"In tnode_resize %p inflate_threshold=%d threshold=%d\\n\",\n\t\t tn, inflate_threshold, halve_threshold);\n\n\t \n\tBUG_ON(tn != get_child(tp, cindex));\n\n\t \n\twhile (should_inflate(tp, tn) && max_work) {\n\t\ttp = inflate(t, tn);\n\t\tif (!tp) {\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\t\t\tthis_cpu_inc(stats->resize_node_skipped);\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t\tmax_work--;\n\t\ttn = get_child(tp, cindex);\n\t}\n\n\t \n\ttp = node_parent(tn);\n\n\t \n\tif (max_work != MAX_WORK)\n\t\treturn tp;\n\n\t \n\twhile (should_halve(tp, tn) && max_work) {\n\t\ttp = halve(t, tn);\n\t\tif (!tp) {\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\t\t\tthis_cpu_inc(stats->resize_node_skipped);\n#endif\n\t\t\tbreak;\n\t\t}\n\n\t\tmax_work--;\n\t\ttn = get_child(tp, cindex);\n\t}\n\n\t \n\tif (should_collapse(tn))\n\t\treturn collapse(t, tn);\n\n\t \n\treturn node_parent(tn);\n}\n\nstatic void node_pull_suffix(struct key_vector *tn, unsigned char slen)\n{\n\tunsigned char node_slen = tn->slen;\n\n\twhile ((node_slen > tn->pos) && (node_slen > slen)) {\n\t\tslen = update_suffix(tn);\n\t\tif (node_slen == slen)\n\t\t\tbreak;\n\n\t\ttn = node_parent(tn);\n\t\tnode_slen = tn->slen;\n\t}\n}\n\nstatic void node_push_suffix(struct key_vector *tn, unsigned char slen)\n{\n\twhile (tn->slen < slen) {\n\t\ttn->slen = slen;\n\t\ttn = node_parent(tn);\n\t}\n}\n\n \nstatic struct key_vector *fib_find_node(struct trie *t,\n\t\t\t\t\tstruct key_vector **tp, u32 key)\n{\n\tstruct key_vector *pn, *n = t->kv;\n\tunsigned long index = 0;\n\n\tdo {\n\t\tpn = n;\n\t\tn = get_child_rcu(n, index);\n\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tindex = get_cindex(key, n);\n\n\t\t \n\t\tif (index >= (1ul << n->bits)) {\n\t\t\tn = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t} while (IS_TNODE(n));\n\n\t*tp = pn;\n\n\treturn n;\n}\n\n \nstatic struct fib_alias *fib_find_alias(struct hlist_head *fah, u8 slen,\n\t\t\t\t\tdscp_t dscp, u32 prio, u32 tb_id,\n\t\t\t\t\tbool find_first)\n{\n\tstruct fib_alias *fa;\n\n\tif (!fah)\n\t\treturn NULL;\n\n\thlist_for_each_entry(fa, fah, fa_list) {\n\t\t \n\t\tu8 __fa_dscp = inet_dscp_to_dsfield(fa->fa_dscp);\n\t\tu8 __dscp = inet_dscp_to_dsfield(dscp);\n\n\t\tif (fa->fa_slen < slen)\n\t\t\tcontinue;\n\t\tif (fa->fa_slen != slen)\n\t\t\tbreak;\n\t\tif (fa->tb_id > tb_id)\n\t\t\tcontinue;\n\t\tif (fa->tb_id != tb_id)\n\t\t\tbreak;\n\t\tif (find_first)\n\t\t\treturn fa;\n\t\tif (__fa_dscp > __dscp)\n\t\t\tcontinue;\n\t\tif (fa->fa_info->fib_priority >= prio || __fa_dscp < __dscp)\n\t\t\treturn fa;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct fib_alias *\nfib_find_matching_alias(struct net *net, const struct fib_rt_info *fri)\n{\n\tu8 slen = KEYLENGTH - fri->dst_len;\n\tstruct key_vector *l, *tp;\n\tstruct fib_table *tb;\n\tstruct fib_alias *fa;\n\tstruct trie *t;\n\n\ttb = fib_get_table(net, fri->tb_id);\n\tif (!tb)\n\t\treturn NULL;\n\n\tt = (struct trie *)tb->tb_data;\n\tl = fib_find_node(t, &tp, be32_to_cpu(fri->dst));\n\tif (!l)\n\t\treturn NULL;\n\n\thlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {\n\t\tif (fa->fa_slen == slen && fa->tb_id == fri->tb_id &&\n\t\t    fa->fa_dscp == fri->dscp && fa->fa_info == fri->fi &&\n\t\t    fa->fa_type == fri->type)\n\t\t\treturn fa;\n\t}\n\n\treturn NULL;\n}\n\nvoid fib_alias_hw_flags_set(struct net *net, const struct fib_rt_info *fri)\n{\n\tu8 fib_notify_on_flag_change;\n\tstruct fib_alias *fa_match;\n\tstruct sk_buff *skb;\n\tint err;\n\n\trcu_read_lock();\n\n\tfa_match = fib_find_matching_alias(net, fri);\n\tif (!fa_match)\n\t\tgoto out;\n\n\t \n\tif (READ_ONCE(fa_match->offload) == fri->offload &&\n\t    READ_ONCE(fa_match->trap) == fri->trap &&\n\t    READ_ONCE(fa_match->offload_failed) == fri->offload_failed)\n\t\tgoto out;\n\n\tWRITE_ONCE(fa_match->offload, fri->offload);\n\tWRITE_ONCE(fa_match->trap, fri->trap);\n\n\tfib_notify_on_flag_change = READ_ONCE(net->ipv4.sysctl_fib_notify_on_flag_change);\n\n\t \n\tif (fib_notify_on_flag_change == 2 &&\n\t    READ_ONCE(fa_match->offload_failed) == fri->offload_failed)\n\t\tgoto out;\n\n\tWRITE_ONCE(fa_match->offload_failed, fri->offload_failed);\n\n\tif (!fib_notify_on_flag_change)\n\t\tgoto out;\n\n\tskb = nlmsg_new(fib_nlmsg_size(fa_match->fa_info), GFP_ATOMIC);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\terr = fib_dump_info(skb, 0, 0, RTM_NEWROUTE, fri, 0);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV4_ROUTE, NULL, GFP_ATOMIC);\n\tgoto out;\n\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_IPV4_ROUTE, err);\nout:\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(fib_alias_hw_flags_set);\n\nstatic void trie_rebalance(struct trie *t, struct key_vector *tn)\n{\n\twhile (!IS_TRIE(tn))\n\t\ttn = resize(t, tn);\n}\n\nstatic int fib_insert_node(struct trie *t, struct key_vector *tp,\n\t\t\t   struct fib_alias *new, t_key key)\n{\n\tstruct key_vector *n, *l;\n\n\tl = leaf_new(key, new);\n\tif (!l)\n\t\tgoto noleaf;\n\n\t \n\tn = get_child(tp, get_index(key, tp));\n\n\t \n\tif (n) {\n\t\tstruct key_vector *tn;\n\n\t\ttn = tnode_new(key, __fls(key ^ n->key), 1);\n\t\tif (!tn)\n\t\t\tgoto notnode;\n\n\t\t \n\t\tNODE_INIT_PARENT(tn, tp);\n\t\tput_child(tn, get_index(key, tn) ^ 1, n);\n\n\t\t \n\t\tput_child_root(tp, key, tn);\n\t\tnode_set_parent(n, tn);\n\n\t\t \n\t\ttp = tn;\n\t}\n\n\t \n\tnode_push_suffix(tp, new->fa_slen);\n\tNODE_INIT_PARENT(l, tp);\n\tput_child_root(tp, key, l);\n\ttrie_rebalance(t, tp);\n\n\treturn 0;\nnotnode:\n\tnode_free(l);\nnoleaf:\n\treturn -ENOMEM;\n}\n\nstatic int fib_insert_alias(struct trie *t, struct key_vector *tp,\n\t\t\t    struct key_vector *l, struct fib_alias *new,\n\t\t\t    struct fib_alias *fa, t_key key)\n{\n\tif (!l)\n\t\treturn fib_insert_node(t, tp, new, key);\n\n\tif (fa) {\n\t\thlist_add_before_rcu(&new->fa_list, &fa->fa_list);\n\t} else {\n\t\tstruct fib_alias *last;\n\n\t\thlist_for_each_entry(last, &l->leaf, fa_list) {\n\t\t\tif (new->fa_slen < last->fa_slen)\n\t\t\t\tbreak;\n\t\t\tif ((new->fa_slen == last->fa_slen) &&\n\t\t\t    (new->tb_id > last->tb_id))\n\t\t\t\tbreak;\n\t\t\tfa = last;\n\t\t}\n\n\t\tif (fa)\n\t\t\thlist_add_behind_rcu(&new->fa_list, &fa->fa_list);\n\t\telse\n\t\t\thlist_add_head_rcu(&new->fa_list, &l->leaf);\n\t}\n\n\t \n\tif (l->slen < new->fa_slen) {\n\t\tl->slen = new->fa_slen;\n\t\tnode_push_suffix(tp, new->fa_slen);\n\t}\n\n\treturn 0;\n}\n\nstatic bool fib_valid_key_len(u32 key, u8 plen, struct netlink_ext_ack *extack)\n{\n\tif (plen > KEYLENGTH) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid prefix length\");\n\t\treturn false;\n\t}\n\n\tif ((plen < KEYLENGTH) && (key << plen)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid prefix for given prefix length\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void fib_remove_alias(struct trie *t, struct key_vector *tp,\n\t\t\t     struct key_vector *l, struct fib_alias *old);\n\n \nint fib_table_insert(struct net *net, struct fib_table *tb,\n\t\t     struct fib_config *cfg, struct netlink_ext_ack *extack)\n{\n\tstruct trie *t = (struct trie *)tb->tb_data;\n\tstruct fib_alias *fa, *new_fa;\n\tstruct key_vector *l, *tp;\n\tu16 nlflags = NLM_F_EXCL;\n\tstruct fib_info *fi;\n\tu8 plen = cfg->fc_dst_len;\n\tu8 slen = KEYLENGTH - plen;\n\tdscp_t dscp;\n\tu32 key;\n\tint err;\n\n\tkey = ntohl(cfg->fc_dst);\n\n\tif (!fib_valid_key_len(key, plen, extack))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"Insert table=%u %08x/%d\\n\", tb->tb_id, key, plen);\n\n\tfi = fib_create_info(cfg, extack);\n\tif (IS_ERR(fi)) {\n\t\terr = PTR_ERR(fi);\n\t\tgoto err;\n\t}\n\n\tdscp = cfg->fc_dscp;\n\tl = fib_find_node(t, &tp, key);\n\tfa = l ? fib_find_alias(&l->leaf, slen, dscp, fi->fib_priority,\n\t\t\t\ttb->tb_id, false) : NULL;\n\n\t \n\n\tif (fa && fa->fa_dscp == dscp &&\n\t    fa->fa_info->fib_priority == fi->fib_priority) {\n\t\tstruct fib_alias *fa_first, *fa_match;\n\n\t\terr = -EEXIST;\n\t\tif (cfg->fc_nlflags & NLM_F_EXCL)\n\t\t\tgoto out;\n\n\t\tnlflags &= ~NLM_F_EXCL;\n\n\t\t \n\t\tfa_match = NULL;\n\t\tfa_first = fa;\n\t\thlist_for_each_entry_from(fa, fa_list) {\n\t\t\tif ((fa->fa_slen != slen) ||\n\t\t\t    (fa->tb_id != tb->tb_id) ||\n\t\t\t    (fa->fa_dscp != dscp))\n\t\t\t\tbreak;\n\t\t\tif (fa->fa_info->fib_priority != fi->fib_priority)\n\t\t\t\tbreak;\n\t\t\tif (fa->fa_type == cfg->fc_type &&\n\t\t\t    fa->fa_info == fi) {\n\t\t\t\tfa_match = fa;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (cfg->fc_nlflags & NLM_F_REPLACE) {\n\t\t\tstruct fib_info *fi_drop;\n\t\t\tu8 state;\n\n\t\t\tnlflags |= NLM_F_REPLACE;\n\t\t\tfa = fa_first;\n\t\t\tif (fa_match) {\n\t\t\t\tif (fa == fa_match)\n\t\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = -ENOBUFS;\n\t\t\tnew_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);\n\t\t\tif (!new_fa)\n\t\t\t\tgoto out;\n\n\t\t\tfi_drop = fa->fa_info;\n\t\t\tnew_fa->fa_dscp = fa->fa_dscp;\n\t\t\tnew_fa->fa_info = fi;\n\t\t\tnew_fa->fa_type = cfg->fc_type;\n\t\t\tstate = fa->fa_state;\n\t\t\tnew_fa->fa_state = state & ~FA_S_ACCESSED;\n\t\t\tnew_fa->fa_slen = fa->fa_slen;\n\t\t\tnew_fa->tb_id = tb->tb_id;\n\t\t\tnew_fa->fa_default = -1;\n\t\t\tnew_fa->offload = 0;\n\t\t\tnew_fa->trap = 0;\n\t\t\tnew_fa->offload_failed = 0;\n\n\t\t\thlist_replace_rcu(&fa->fa_list, &new_fa->fa_list);\n\n\t\t\tif (fib_find_alias(&l->leaf, fa->fa_slen, 0, 0,\n\t\t\t\t\t   tb->tb_id, true) == new_fa) {\n\t\t\t\tenum fib_event_type fib_event;\n\n\t\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\t\t\t\terr = call_fib_entry_notifiers(net, fib_event,\n\t\t\t\t\t\t\t       key, plen,\n\t\t\t\t\t\t\t       new_fa, extack);\n\t\t\t\tif (err) {\n\t\t\t\t\thlist_replace_rcu(&new_fa->fa_list,\n\t\t\t\t\t\t\t  &fa->fa_list);\n\t\t\t\t\tgoto out_free_new_fa;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen,\n\t\t\t\t  tb->tb_id, &cfg->fc_nlinfo, nlflags);\n\n\t\t\talias_free_mem_rcu(fa);\n\n\t\t\tfib_release_info(fi_drop);\n\t\t\tif (state & FA_S_ACCESSED)\n\t\t\t\trt_cache_flush(cfg->fc_nlinfo.nl_net);\n\n\t\t\tgoto succeeded;\n\t\t}\n\t\t \n\t\tif (fa_match)\n\t\t\tgoto out;\n\n\t\tif (cfg->fc_nlflags & NLM_F_APPEND)\n\t\t\tnlflags |= NLM_F_APPEND;\n\t\telse\n\t\t\tfa = fa_first;\n\t}\n\terr = -ENOENT;\n\tif (!(cfg->fc_nlflags & NLM_F_CREATE))\n\t\tgoto out;\n\n\tnlflags |= NLM_F_CREATE;\n\terr = -ENOBUFS;\n\tnew_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);\n\tif (!new_fa)\n\t\tgoto out;\n\n\tnew_fa->fa_info = fi;\n\tnew_fa->fa_dscp = dscp;\n\tnew_fa->fa_type = cfg->fc_type;\n\tnew_fa->fa_state = 0;\n\tnew_fa->fa_slen = slen;\n\tnew_fa->tb_id = tb->tb_id;\n\tnew_fa->fa_default = -1;\n\tnew_fa->offload = 0;\n\tnew_fa->trap = 0;\n\tnew_fa->offload_failed = 0;\n\n\t \n\terr = fib_insert_alias(t, tp, l, new_fa, fa, key);\n\tif (err)\n\t\tgoto out_free_new_fa;\n\n\t \n\tl = l ? l : fib_find_node(t, &tp, key);\n\tif (WARN_ON_ONCE(!l)) {\n\t\terr = -ENOENT;\n\t\tgoto out_free_new_fa;\n\t}\n\n\tif (fib_find_alias(&l->leaf, new_fa->fa_slen, 0, 0, tb->tb_id, true) ==\n\t    new_fa) {\n\t\tenum fib_event_type fib_event;\n\n\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\t\terr = call_fib_entry_notifiers(net, fib_event, key, plen,\n\t\t\t\t\t       new_fa, extack);\n\t\tif (err)\n\t\t\tgoto out_remove_new_fa;\n\t}\n\n\tif (!plen)\n\t\ttb->tb_num_default++;\n\n\trt_cache_flush(cfg->fc_nlinfo.nl_net);\n\trtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, new_fa->tb_id,\n\t\t  &cfg->fc_nlinfo, nlflags);\nsucceeded:\n\treturn 0;\n\nout_remove_new_fa:\n\tfib_remove_alias(t, tp, l, new_fa);\nout_free_new_fa:\n\tkmem_cache_free(fn_alias_kmem, new_fa);\nout:\n\tfib_release_info(fi);\nerr:\n\treturn err;\n}\n\nstatic inline t_key prefix_mismatch(t_key key, struct key_vector *n)\n{\n\tt_key prefix = n->key;\n\n\treturn (key ^ prefix) & (prefix | -prefix);\n}\n\nbool fib_lookup_good_nhc(const struct fib_nh_common *nhc, int fib_flags,\n\t\t\t const struct flowi4 *flp)\n{\n\tif (nhc->nhc_flags & RTNH_F_DEAD)\n\t\treturn false;\n\n\tif (ip_ignore_linkdown(nhc->nhc_dev) &&\n\t    nhc->nhc_flags & RTNH_F_LINKDOWN &&\n\t    !(fib_flags & FIB_LOOKUP_IGNORE_LINKSTATE))\n\t\treturn false;\n\n\tif (flp->flowi4_oif && flp->flowi4_oif != nhc->nhc_oif)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nint fib_table_lookup(struct fib_table *tb, const struct flowi4 *flp,\n\t\t     struct fib_result *res, int fib_flags)\n{\n\tstruct trie *t = (struct trie *) tb->tb_data;\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\tstruct trie_use_stats __percpu *stats = t->stats;\n#endif\n\tconst t_key key = ntohl(flp->daddr);\n\tstruct key_vector *n, *pn;\n\tstruct fib_alias *fa;\n\tunsigned long index;\n\tt_key cindex;\n\n\tpn = t->kv;\n\tcindex = 0;\n\n\tn = get_child_rcu(pn, cindex);\n\tif (!n) {\n\t\ttrace_fib_table_lookup(tb->tb_id, flp, NULL, -EAGAIN);\n\t\treturn -EAGAIN;\n\t}\n\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\tthis_cpu_inc(stats->gets);\n#endif\n\n\t \n\tfor (;;) {\n\t\tindex = get_cindex(key, n);\n\n\t\t \n\t\tif (index >= (1ul << n->bits))\n\t\t\tbreak;\n\n\t\t \n\t\tif (IS_LEAF(n))\n\t\t\tgoto found;\n\n\t\t \n\t\tif (n->slen > n->pos) {\n\t\t\tpn = n;\n\t\t\tcindex = index;\n\t\t}\n\n\t\tn = get_child_rcu(n, index);\n\t\tif (unlikely(!n))\n\t\t\tgoto backtrace;\n\t}\n\n\t \n\tfor (;;) {\n\t\t \n\t\tstruct key_vector __rcu **cptr = n->tnode;\n\n\t\t \n\t\tif (unlikely(prefix_mismatch(key, n)) || (n->slen == n->pos))\n\t\t\tgoto backtrace;\n\n\t\t \n\t\tif (unlikely(IS_LEAF(n)))\n\t\t\tbreak;\n\n\t\t \n\n\t\twhile ((n = rcu_dereference(*cptr)) == NULL) {\nbacktrace:\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\t\t\tif (!n)\n\t\t\t\tthis_cpu_inc(stats->null_node_hit);\n#endif\n\t\t\t \n\t\t\twhile (!cindex) {\n\t\t\t\tt_key pkey = pn->key;\n\n\t\t\t\t \n\t\t\t\tif (IS_TRIE(pn)) {\n\t\t\t\t\ttrace_fib_table_lookup(tb->tb_id, flp,\n\t\t\t\t\t\t\t       NULL, -EAGAIN);\n\t\t\t\t\treturn -EAGAIN;\n\t\t\t\t}\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\t\t\t\tthis_cpu_inc(stats->backtrack);\n#endif\n\t\t\t\t \n\t\t\t\tpn = node_parent_rcu(pn);\n\t\t\t\tcindex = get_index(pkey, pn);\n\t\t\t}\n\n\t\t\t \n\t\t\tcindex &= cindex - 1;\n\n\t\t\t \n\t\t\tcptr = &pn->tnode[cindex];\n\t\t}\n\t}\n\nfound:\n\t \n\tindex = key ^ n->key;\n\n\t \n\thlist_for_each_entry_rcu(fa, &n->leaf, fa_list) {\n\t\tstruct fib_info *fi = fa->fa_info;\n\t\tstruct fib_nh_common *nhc;\n\t\tint nhsel, err;\n\n\t\tif ((BITS_PER_LONG > KEYLENGTH) || (fa->fa_slen < KEYLENGTH)) {\n\t\t\tif (index >= (1ul << fa->fa_slen))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (fa->fa_dscp &&\n\t\t    inet_dscp_to_dsfield(fa->fa_dscp) != flp->flowi4_tos)\n\t\t\tcontinue;\n\t\t \n\t\tif (READ_ONCE(fi->fib_dead))\n\t\t\tcontinue;\n\t\tif (fa->fa_info->fib_scope < flp->flowi4_scope)\n\t\t\tcontinue;\n\t\tfib_alias_accessed(fa);\n\t\terr = fib_props[fa->fa_type].error;\n\t\tif (unlikely(err < 0)) {\nout_reject:\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\t\t\tthis_cpu_inc(stats->semantic_match_passed);\n#endif\n\t\t\ttrace_fib_table_lookup(tb->tb_id, flp, NULL, err);\n\t\t\treturn err;\n\t\t}\n\t\tif (fi->fib_flags & RTNH_F_DEAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely(fi->nh)) {\n\t\t\tif (nexthop_is_blackhole(fi->nh)) {\n\t\t\t\terr = fib_props[RTN_BLACKHOLE].error;\n\t\t\t\tgoto out_reject;\n\t\t\t}\n\n\t\t\tnhc = nexthop_get_nhc_lookup(fi->nh, fib_flags, flp,\n\t\t\t\t\t\t     &nhsel);\n\t\t\tif (nhc)\n\t\t\t\tgoto set_result;\n\t\t\tgoto miss;\n\t\t}\n\n\t\tfor (nhsel = 0; nhsel < fib_info_num_path(fi); nhsel++) {\n\t\t\tnhc = fib_info_nhc(fi, nhsel);\n\n\t\t\tif (!fib_lookup_good_nhc(nhc, fib_flags, flp))\n\t\t\t\tcontinue;\nset_result:\n\t\t\tif (!(fib_flags & FIB_LOOKUP_NOREF))\n\t\t\t\trefcount_inc(&fi->fib_clntref);\n\n\t\t\tres->prefix = htonl(n->key);\n\t\t\tres->prefixlen = KEYLENGTH - fa->fa_slen;\n\t\t\tres->nh_sel = nhsel;\n\t\t\tres->nhc = nhc;\n\t\t\tres->type = fa->fa_type;\n\t\t\tres->scope = fi->fib_scope;\n\t\t\tres->fi = fi;\n\t\t\tres->table = tb;\n\t\t\tres->fa_head = &n->leaf;\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\t\t\tthis_cpu_inc(stats->semantic_match_passed);\n#endif\n\t\t\ttrace_fib_table_lookup(tb->tb_id, flp, nhc, err);\n\n\t\t\treturn err;\n\t\t}\n\t}\nmiss:\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\tthis_cpu_inc(stats->semantic_match_miss);\n#endif\n\tgoto backtrace;\n}\nEXPORT_SYMBOL_GPL(fib_table_lookup);\n\nstatic void fib_remove_alias(struct trie *t, struct key_vector *tp,\n\t\t\t     struct key_vector *l, struct fib_alias *old)\n{\n\t \n\tstruct hlist_node **pprev = old->fa_list.pprev;\n\tstruct fib_alias *fa = hlist_entry(pprev, typeof(*fa), fa_list.next);\n\n\t \n\thlist_del_rcu(&old->fa_list);\n\n\t \n\tif (hlist_empty(&l->leaf)) {\n\t\tif (tp->slen == l->slen)\n\t\t\tnode_pull_suffix(tp, tp->pos);\n\t\tput_child_root(tp, l->key, NULL);\n\t\tnode_free(l);\n\t\ttrie_rebalance(t, tp);\n\t\treturn;\n\t}\n\n\t \n\tif (*pprev)\n\t\treturn;\n\n\t \n\tl->slen = fa->fa_slen;\n\tnode_pull_suffix(tp, fa->fa_slen);\n}\n\nstatic void fib_notify_alias_delete(struct net *net, u32 key,\n\t\t\t\t    struct hlist_head *fah,\n\t\t\t\t    struct fib_alias *fa_to_delete,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib_alias *fa_next, *fa_to_notify;\n\tu32 tb_id = fa_to_delete->tb_id;\n\tu8 slen = fa_to_delete->fa_slen;\n\tenum fib_event_type fib_event;\n\n\t \n\tif (fib_find_alias(fah, slen, 0, 0, tb_id, true) != fa_to_delete)\n\t\treturn;\n\n\t \n\tfa_next = hlist_entry_safe(fa_to_delete->fa_list.next,\n\t\t\t\t   struct fib_alias, fa_list);\n\tif (fa_next && fa_next->fa_slen == slen && fa_next->tb_id == tb_id) {\n\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\t\tfa_to_notify = fa_next;\n\t} else {\n\t\tfib_event = FIB_EVENT_ENTRY_DEL;\n\t\tfa_to_notify = fa_to_delete;\n\t}\n\tcall_fib_entry_notifiers(net, fib_event, key, KEYLENGTH - slen,\n\t\t\t\t fa_to_notify, extack);\n}\n\n \nint fib_table_delete(struct net *net, struct fib_table *tb,\n\t\t     struct fib_config *cfg, struct netlink_ext_ack *extack)\n{\n\tstruct trie *t = (struct trie *) tb->tb_data;\n\tstruct fib_alias *fa, *fa_to_delete;\n\tstruct key_vector *l, *tp;\n\tu8 plen = cfg->fc_dst_len;\n\tu8 slen = KEYLENGTH - plen;\n\tdscp_t dscp;\n\tu32 key;\n\n\tkey = ntohl(cfg->fc_dst);\n\n\tif (!fib_valid_key_len(key, plen, extack))\n\t\treturn -EINVAL;\n\n\tl = fib_find_node(t, &tp, key);\n\tif (!l)\n\t\treturn -ESRCH;\n\n\tdscp = cfg->fc_dscp;\n\tfa = fib_find_alias(&l->leaf, slen, dscp, 0, tb->tb_id, false);\n\tif (!fa)\n\t\treturn -ESRCH;\n\n\tpr_debug(\"Deleting %08x/%d dsfield=0x%02x t=%p\\n\", key, plen,\n\t\t inet_dscp_to_dsfield(dscp), t);\n\n\tfa_to_delete = NULL;\n\thlist_for_each_entry_from(fa, fa_list) {\n\t\tstruct fib_info *fi = fa->fa_info;\n\n\t\tif ((fa->fa_slen != slen) ||\n\t\t    (fa->tb_id != tb->tb_id) ||\n\t\t    (fa->fa_dscp != dscp))\n\t\t\tbreak;\n\n\t\tif ((!cfg->fc_type || fa->fa_type == cfg->fc_type) &&\n\t\t    (cfg->fc_scope == RT_SCOPE_NOWHERE ||\n\t\t     fa->fa_info->fib_scope == cfg->fc_scope) &&\n\t\t    (!cfg->fc_prefsrc ||\n\t\t     fi->fib_prefsrc == cfg->fc_prefsrc) &&\n\t\t    (!cfg->fc_protocol ||\n\t\t     fi->fib_protocol == cfg->fc_protocol) &&\n\t\t    fib_nh_match(net, cfg, fi, extack) == 0 &&\n\t\t    fib_metrics_match(cfg, fi)) {\n\t\t\tfa_to_delete = fa;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!fa_to_delete)\n\t\treturn -ESRCH;\n\n\tfib_notify_alias_delete(net, key, &l->leaf, fa_to_delete, extack);\n\trtmsg_fib(RTM_DELROUTE, htonl(key), fa_to_delete, plen, tb->tb_id,\n\t\t  &cfg->fc_nlinfo, 0);\n\n\tif (!plen)\n\t\ttb->tb_num_default--;\n\n\tfib_remove_alias(t, tp, l, fa_to_delete);\n\n\tif (fa_to_delete->fa_state & FA_S_ACCESSED)\n\t\trt_cache_flush(cfg->fc_nlinfo.nl_net);\n\n\tfib_release_info(fa_to_delete->fa_info);\n\talias_free_mem_rcu(fa_to_delete);\n\treturn 0;\n}\n\n \nstatic struct key_vector *leaf_walk_rcu(struct key_vector **tn, t_key key)\n{\n\tstruct key_vector *pn, *n = *tn;\n\tunsigned long cindex;\n\n\t \n\tdo {\n\t\t \n\t\tpn = n;\n\t\tcindex = (key > pn->key) ? get_index(key, pn) : 0;\n\n\t\tif (cindex >> pn->bits)\n\t\t\tbreak;\n\n\t\t \n\t\tn = get_child_rcu(pn, cindex++);\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\t \n\t\tif (IS_LEAF(n) && (n->key >= key))\n\t\t\tgoto found;\n\t} while (IS_TNODE(n));\n\n\t \n\twhile (!IS_TRIE(pn)) {\n\t\t \n\t\tif (cindex >= (1ul << pn->bits)) {\n\t\t\tt_key pkey = pn->key;\n\n\t\t\tpn = node_parent_rcu(pn);\n\t\t\tcindex = get_index(pkey, pn) + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tn = get_child_rcu(pn, cindex++);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (IS_LEAF(n))\n\t\t\tgoto found;\n\n\t\t \n\t\tpn = n;\n\t\tcindex = 0;\n\t}\n\n\t*tn = pn;\n\treturn NULL;  \nfound:\n\t \n\t*tn = pn;\n\treturn n;\n}\n\nstatic void fib_trie_free(struct fib_table *tb)\n{\n\tstruct trie *t = (struct trie *)tb->tb_data;\n\tstruct key_vector *pn = t->kv;\n\tunsigned long cindex = 1;\n\tstruct hlist_node *tmp;\n\tstruct fib_alias *fa;\n\n\t \n\tfor (;;) {\n\t\tstruct key_vector *n;\n\n\t\tif (!(cindex--)) {\n\t\t\tt_key pkey = pn->key;\n\n\t\t\tif (IS_TRIE(pn))\n\t\t\t\tbreak;\n\n\t\t\tn = pn;\n\t\t\tpn = node_parent(pn);\n\n\t\t\t \n\t\t\tput_child_root(pn, n->key, NULL);\n\t\t\tnode_free(n);\n\n\t\t\tcindex = get_index(pkey, pn);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tn = get_child(pn, cindex);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tif (IS_TNODE(n)) {\n\t\t\t \n\t\t\tpn = n;\n\t\t\tcindex = 1ul << n->bits;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\thlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {\n\t\t\thlist_del_rcu(&fa->fa_list);\n\t\t\talias_free_mem_rcu(fa);\n\t\t}\n\n\t\tput_child_root(pn, n->key, NULL);\n\t\tnode_free(n);\n\t}\n\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\tfree_percpu(t->stats);\n#endif\n\tkfree(tb);\n}\n\nstruct fib_table *fib_trie_unmerge(struct fib_table *oldtb)\n{\n\tstruct trie *ot = (struct trie *)oldtb->tb_data;\n\tstruct key_vector *l, *tp = ot->kv;\n\tstruct fib_table *local_tb;\n\tstruct fib_alias *fa;\n\tstruct trie *lt;\n\tt_key key = 0;\n\n\tif (oldtb->tb_data == oldtb->__data)\n\t\treturn oldtb;\n\n\tlocal_tb = fib_trie_table(RT_TABLE_LOCAL, NULL);\n\tif (!local_tb)\n\t\treturn NULL;\n\n\tlt = (struct trie *)local_tb->tb_data;\n\n\twhile ((l = leaf_walk_rcu(&tp, key)) != NULL) {\n\t\tstruct key_vector *local_l = NULL, *local_tp;\n\n\t\thlist_for_each_entry(fa, &l->leaf, fa_list) {\n\t\t\tstruct fib_alias *new_fa;\n\n\t\t\tif (local_tb->tb_id != fa->tb_id)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tnew_fa = kmem_cache_alloc(fn_alias_kmem, GFP_KERNEL);\n\t\t\tif (!new_fa)\n\t\t\t\tgoto out;\n\n\t\t\tmemcpy(new_fa, fa, sizeof(*fa));\n\n\t\t\t \n\t\t\tif (!local_l)\n\t\t\t\tlocal_l = fib_find_node(lt, &local_tp, l->key);\n\n\t\t\tif (fib_insert_alias(lt, local_tp, local_l, new_fa,\n\t\t\t\t\t     NULL, l->key)) {\n\t\t\t\tkmem_cache_free(fn_alias_kmem, new_fa);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tkey = l->key + 1;\n\t\tif (key < l->key)\n\t\t\tbreak;\n\t}\n\n\treturn local_tb;\nout:\n\tfib_trie_free(local_tb);\n\n\treturn NULL;\n}\n\n \nvoid fib_table_flush_external(struct fib_table *tb)\n{\n\tstruct trie *t = (struct trie *)tb->tb_data;\n\tstruct key_vector *pn = t->kv;\n\tunsigned long cindex = 1;\n\tstruct hlist_node *tmp;\n\tstruct fib_alias *fa;\n\n\t \n\tfor (;;) {\n\t\tunsigned char slen = 0;\n\t\tstruct key_vector *n;\n\n\t\tif (!(cindex--)) {\n\t\t\tt_key pkey = pn->key;\n\n\t\t\t \n\t\t\tif (IS_TRIE(pn))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (pn->slen > pn->pos)\n\t\t\t\tupdate_suffix(pn);\n\n\t\t\t \n\t\t\tpn = resize(t, pn);\n\t\t\tcindex = get_index(pkey, pn);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tn = get_child(pn, cindex);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tif (IS_TNODE(n)) {\n\t\t\t \n\t\t\tpn = n;\n\t\t\tcindex = 1ul << n->bits;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\thlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {\n\t\t\t \n\t\t\tif (tb->tb_id != fa->tb_id) {\n\t\t\t\thlist_del_rcu(&fa->fa_list);\n\t\t\t\talias_free_mem_rcu(fa);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tslen = fa->fa_slen;\n\t\t}\n\n\t\t \n\t\tn->slen = slen;\n\n\t\tif (hlist_empty(&n->leaf)) {\n\t\t\tput_child_root(pn, n->key, NULL);\n\t\t\tnode_free(n);\n\t\t}\n\t}\n}\n\n \nint fib_table_flush(struct net *net, struct fib_table *tb, bool flush_all)\n{\n\tstruct trie *t = (struct trie *)tb->tb_data;\n\tstruct nl_info info = { .nl_net = net };\n\tstruct key_vector *pn = t->kv;\n\tunsigned long cindex = 1;\n\tstruct hlist_node *tmp;\n\tstruct fib_alias *fa;\n\tint found = 0;\n\n\t \n\tfor (;;) {\n\t\tunsigned char slen = 0;\n\t\tstruct key_vector *n;\n\n\t\tif (!(cindex--)) {\n\t\t\tt_key pkey = pn->key;\n\n\t\t\t \n\t\t\tif (IS_TRIE(pn))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (pn->slen > pn->pos)\n\t\t\t\tupdate_suffix(pn);\n\n\t\t\t \n\t\t\tpn = resize(t, pn);\n\t\t\tcindex = get_index(pkey, pn);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tn = get_child(pn, cindex);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tif (IS_TNODE(n)) {\n\t\t\t \n\t\t\tpn = n;\n\t\t\tcindex = 1ul << n->bits;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\thlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {\n\t\t\tstruct fib_info *fi = fa->fa_info;\n\n\t\t\tif (!fi || tb->tb_id != fa->tb_id ||\n\t\t\t    (!(fi->fib_flags & RTNH_F_DEAD) &&\n\t\t\t     !fib_props[fa->fa_type].error)) {\n\t\t\t\tslen = fa->fa_slen;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!flush_all && fib_props[fa->fa_type].error) {\n\t\t\t\tslen = fa->fa_slen;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfib_notify_alias_delete(net, n->key, &n->leaf, fa,\n\t\t\t\t\t\tNULL);\n\t\t\tif (fi->pfsrc_removed)\n\t\t\t\trtmsg_fib(RTM_DELROUTE, htonl(n->key), fa,\n\t\t\t\t\t  KEYLENGTH - fa->fa_slen, tb->tb_id, &info, 0);\n\t\t\thlist_del_rcu(&fa->fa_list);\n\t\t\tfib_release_info(fa->fa_info);\n\t\t\talias_free_mem_rcu(fa);\n\t\t\tfound++;\n\t\t}\n\n\t\t \n\t\tn->slen = slen;\n\n\t\tif (hlist_empty(&n->leaf)) {\n\t\t\tput_child_root(pn, n->key, NULL);\n\t\t\tnode_free(n);\n\t\t}\n\t}\n\n\tpr_debug(\"trie_flush found=%d\\n\", found);\n\treturn found;\n}\n\n \nstatic void __fib_info_notify_update(struct net *net, struct fib_table *tb,\n\t\t\t\t     struct nl_info *info)\n{\n\tstruct trie *t = (struct trie *)tb->tb_data;\n\tstruct key_vector *pn = t->kv;\n\tunsigned long cindex = 1;\n\tstruct fib_alias *fa;\n\n\tfor (;;) {\n\t\tstruct key_vector *n;\n\n\t\tif (!(cindex--)) {\n\t\t\tt_key pkey = pn->key;\n\n\t\t\tif (IS_TRIE(pn))\n\t\t\t\tbreak;\n\n\t\t\tpn = node_parent(pn);\n\t\t\tcindex = get_index(pkey, pn);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tn = get_child(pn, cindex);\n\t\tif (!n)\n\t\t\tcontinue;\n\n\t\tif (IS_TNODE(n)) {\n\t\t\t \n\t\t\tpn = n;\n\t\t\tcindex = 1ul << n->bits;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\thlist_for_each_entry(fa, &n->leaf, fa_list) {\n\t\t\tstruct fib_info *fi = fa->fa_info;\n\n\t\t\tif (!fi || !fi->nh_updated || fa->tb_id != tb->tb_id)\n\t\t\t\tcontinue;\n\n\t\t\trtmsg_fib(RTM_NEWROUTE, htonl(n->key), fa,\n\t\t\t\t  KEYLENGTH - fa->fa_slen, tb->tb_id,\n\t\t\t\t  info, NLM_F_REPLACE);\n\t\t}\n\t}\n}\n\nvoid fib_info_notify_update(struct net *net, struct nl_info *info)\n{\n\tunsigned int h;\n\n\tfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\n\t\tstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\n\t\tstruct fib_table *tb;\n\n\t\thlist_for_each_entry_rcu(tb, head, tb_hlist,\n\t\t\t\t\t lockdep_rtnl_is_held())\n\t\t\t__fib_info_notify_update(net, tb, info);\n\t}\n}\n\nstatic int fib_leaf_notify(struct key_vector *l, struct fib_table *tb,\n\t\t\t   struct notifier_block *nb,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct fib_alias *fa;\n\tint last_slen = -1;\n\tint err;\n\n\thlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {\n\t\tstruct fib_info *fi = fa->fa_info;\n\n\t\tif (!fi)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (tb->tb_id != fa->tb_id)\n\t\t\tcontinue;\n\n\t\tif (fa->fa_slen == last_slen)\n\t\t\tcontinue;\n\n\t\tlast_slen = fa->fa_slen;\n\t\terr = call_fib_entry_notifier(nb, FIB_EVENT_ENTRY_REPLACE,\n\t\t\t\t\t      l->key, KEYLENGTH - fa->fa_slen,\n\t\t\t\t\t      fa, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int fib_table_notify(struct fib_table *tb, struct notifier_block *nb,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct trie *t = (struct trie *)tb->tb_data;\n\tstruct key_vector *l, *tp = t->kv;\n\tt_key key = 0;\n\tint err;\n\n\twhile ((l = leaf_walk_rcu(&tp, key)) != NULL) {\n\t\terr = fib_leaf_notify(l, tb, nb, extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tkey = l->key + 1;\n\t\t \n\t\tif (key < l->key)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint fib_notify(struct net *net, struct notifier_block *nb,\n\t       struct netlink_ext_ack *extack)\n{\n\tunsigned int h;\n\tint err;\n\n\tfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\n\t\tstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\n\t\tstruct fib_table *tb;\n\n\t\thlist_for_each_entry_rcu(tb, head, tb_hlist) {\n\t\t\terr = fib_table_notify(tb, nb, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void __trie_free_rcu(struct rcu_head *head)\n{\n\tstruct fib_table *tb = container_of(head, struct fib_table, rcu);\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\tstruct trie *t = (struct trie *)tb->tb_data;\n\n\tif (tb->tb_data == tb->__data)\n\t\tfree_percpu(t->stats);\n#endif  \n\tkfree(tb);\n}\n\nvoid fib_free_table(struct fib_table *tb)\n{\n\tcall_rcu(&tb->rcu, __trie_free_rcu);\n}\n\nstatic int fn_trie_dump_leaf(struct key_vector *l, struct fib_table *tb,\n\t\t\t     struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t     struct fib_dump_filter *filter)\n{\n\tunsigned int flags = NLM_F_MULTI;\n\t__be32 xkey = htonl(l->key);\n\tint i, s_i, i_fa, s_fa, err;\n\tstruct fib_alias *fa;\n\n\tif (filter->filter_set ||\n\t    !filter->dump_exceptions || !filter->dump_routes)\n\t\tflags |= NLM_F_DUMP_FILTERED;\n\n\ts_i = cb->args[4];\n\ts_fa = cb->args[5];\n\ti = 0;\n\n\t \n\thlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {\n\t\tstruct fib_info *fi = fa->fa_info;\n\n\t\tif (i < s_i)\n\t\t\tgoto next;\n\n\t\ti_fa = 0;\n\n\t\tif (tb->tb_id != fa->tb_id)\n\t\t\tgoto next;\n\n\t\tif (filter->filter_set) {\n\t\t\tif (filter->rt_type && fa->fa_type != filter->rt_type)\n\t\t\t\tgoto next;\n\n\t\t\tif ((filter->protocol &&\n\t\t\t     fi->fib_protocol != filter->protocol))\n\t\t\t\tgoto next;\n\n\t\t\tif (filter->dev &&\n\t\t\t    !fib_info_nh_uses_dev(fi, filter->dev))\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tif (filter->dump_routes) {\n\t\t\tif (!s_fa) {\n\t\t\t\tstruct fib_rt_info fri;\n\n\t\t\t\tfri.fi = fi;\n\t\t\t\tfri.tb_id = tb->tb_id;\n\t\t\t\tfri.dst = xkey;\n\t\t\t\tfri.dst_len = KEYLENGTH - fa->fa_slen;\n\t\t\t\tfri.dscp = fa->fa_dscp;\n\t\t\t\tfri.type = fa->fa_type;\n\t\t\t\tfri.offload = READ_ONCE(fa->offload);\n\t\t\t\tfri.trap = READ_ONCE(fa->trap);\n\t\t\t\tfri.offload_failed = READ_ONCE(fa->offload_failed);\n\t\t\t\terr = fib_dump_info(skb,\n\t\t\t\t\t\t    NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t    cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t    RTM_NEWROUTE, &fri, flags);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto stop;\n\t\t\t}\n\n\t\t\ti_fa++;\n\t\t}\n\n\t\tif (filter->dump_exceptions) {\n\t\t\terr = fib_dump_info_fnhe(skb, cb, tb->tb_id, fi,\n\t\t\t\t\t\t &i_fa, s_fa, flags);\n\t\t\tif (err < 0)\n\t\t\t\tgoto stop;\n\t\t}\n\nnext:\n\t\ti++;\n\t}\n\n\tcb->args[4] = i;\n\treturn skb->len;\n\nstop:\n\tcb->args[4] = i;\n\tcb->args[5] = i_fa;\n\treturn err;\n}\n\n \nint fib_table_dump(struct fib_table *tb, struct sk_buff *skb,\n\t\t   struct netlink_callback *cb, struct fib_dump_filter *filter)\n{\n\tstruct trie *t = (struct trie *)tb->tb_data;\n\tstruct key_vector *l, *tp = t->kv;\n\t \n\tint count = cb->args[2];\n\tt_key key = cb->args[3];\n\n\t \n\tif (count && !key)\n\t\treturn skb->len;\n\n\twhile ((l = leaf_walk_rcu(&tp, key)) != NULL) {\n\t\tint err;\n\n\t\terr = fn_trie_dump_leaf(l, tb, skb, cb, filter);\n\t\tif (err < 0) {\n\t\t\tcb->args[3] = key;\n\t\t\tcb->args[2] = count;\n\t\t\treturn err;\n\t\t}\n\n\t\t++count;\n\t\tkey = l->key + 1;\n\n\t\tmemset(&cb->args[4], 0,\n\t\t       sizeof(cb->args) - 4*sizeof(cb->args[0]));\n\n\t\t \n\t\tif (key < l->key)\n\t\t\tbreak;\n\t}\n\n\tcb->args[3] = key;\n\tcb->args[2] = count;\n\n\treturn skb->len;\n}\n\nvoid __init fib_trie_init(void)\n{\n\tfn_alias_kmem = kmem_cache_create(\"ip_fib_alias\",\n\t\t\t\t\t  sizeof(struct fib_alias),\n\t\t\t\t\t  0, SLAB_PANIC | SLAB_ACCOUNT, NULL);\n\n\ttrie_leaf_kmem = kmem_cache_create(\"ip_fib_trie\",\n\t\t\t\t\t   LEAF_SIZE,\n\t\t\t\t\t   0, SLAB_PANIC | SLAB_ACCOUNT, NULL);\n}\n\nstruct fib_table *fib_trie_table(u32 id, struct fib_table *alias)\n{\n\tstruct fib_table *tb;\n\tstruct trie *t;\n\tsize_t sz = sizeof(*tb);\n\n\tif (!alias)\n\t\tsz += sizeof(struct trie);\n\n\ttb = kzalloc(sz, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\n\ttb->tb_id = id;\n\ttb->tb_num_default = 0;\n\ttb->tb_data = (alias ? alias->__data : tb->__data);\n\n\tif (alias)\n\t\treturn tb;\n\n\tt = (struct trie *) tb->tb_data;\n\tt->kv[0].pos = KEYLENGTH;\n\tt->kv[0].slen = KEYLENGTH;\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\tt->stats = alloc_percpu(struct trie_use_stats);\n\tif (!t->stats) {\n\t\tkfree(tb);\n\t\ttb = NULL;\n\t}\n#endif\n\n\treturn tb;\n}\n\n#ifdef CONFIG_PROC_FS\n \nstruct fib_trie_iter {\n\tstruct seq_net_private p;\n\tstruct fib_table *tb;\n\tstruct key_vector *tnode;\n\tunsigned int index;\n\tunsigned int depth;\n};\n\nstatic struct key_vector *fib_trie_get_next(struct fib_trie_iter *iter)\n{\n\tunsigned long cindex = iter->index;\n\tstruct key_vector *pn = iter->tnode;\n\tt_key pkey;\n\n\tpr_debug(\"get_next iter={node=%p index=%d depth=%d}\\n\",\n\t\t iter->tnode, iter->index, iter->depth);\n\n\twhile (!IS_TRIE(pn)) {\n\t\twhile (cindex < child_length(pn)) {\n\t\t\tstruct key_vector *n = get_child_rcu(pn, cindex++);\n\n\t\t\tif (!n)\n\t\t\t\tcontinue;\n\n\t\t\tif (IS_LEAF(n)) {\n\t\t\t\titer->tnode = pn;\n\t\t\t\titer->index = cindex;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\titer->tnode = n;\n\t\t\t\titer->index = 0;\n\t\t\t\t++iter->depth;\n\t\t\t}\n\n\t\t\treturn n;\n\t\t}\n\n\t\t \n\t\tpkey = pn->key;\n\t\tpn = node_parent_rcu(pn);\n\t\tcindex = get_index(pkey, pn) + 1;\n\t\t--iter->depth;\n\t}\n\n\t \n\titer->tnode = pn;\n\titer->index = 0;\n\n\treturn NULL;\n}\n\nstatic struct key_vector *fib_trie_get_first(struct fib_trie_iter *iter,\n\t\t\t\t\t     struct trie *t)\n{\n\tstruct key_vector *n, *pn;\n\n\tif (!t)\n\t\treturn NULL;\n\n\tpn = t->kv;\n\tn = rcu_dereference(pn->tnode[0]);\n\tif (!n)\n\t\treturn NULL;\n\n\tif (IS_TNODE(n)) {\n\t\titer->tnode = n;\n\t\titer->index = 0;\n\t\titer->depth = 1;\n\t} else {\n\t\titer->tnode = pn;\n\t\titer->index = 0;\n\t\titer->depth = 0;\n\t}\n\n\treturn n;\n}\n\nstatic void trie_collect_stats(struct trie *t, struct trie_stat *s)\n{\n\tstruct key_vector *n;\n\tstruct fib_trie_iter iter;\n\n\tmemset(s, 0, sizeof(*s));\n\n\trcu_read_lock();\n\tfor (n = fib_trie_get_first(&iter, t); n; n = fib_trie_get_next(&iter)) {\n\t\tif (IS_LEAF(n)) {\n\t\t\tstruct fib_alias *fa;\n\n\t\t\ts->leaves++;\n\t\t\ts->totdepth += iter.depth;\n\t\t\tif (iter.depth > s->maxdepth)\n\t\t\t\ts->maxdepth = iter.depth;\n\n\t\t\thlist_for_each_entry_rcu(fa, &n->leaf, fa_list)\n\t\t\t\t++s->prefixes;\n\t\t} else {\n\t\t\ts->tnodes++;\n\t\t\tif (n->bits < MAX_STAT_DEPTH)\n\t\t\t\ts->nodesizes[n->bits]++;\n\t\t\ts->nullpointers += tn_info(n)->empty_children;\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void trie_show_stats(struct seq_file *seq, struct trie_stat *stat)\n{\n\tunsigned int i, max, pointers, bytes, avdepth;\n\n\tif (stat->leaves)\n\t\tavdepth = stat->totdepth*100 / stat->leaves;\n\telse\n\t\tavdepth = 0;\n\n\tseq_printf(seq, \"\\tAver depth:     %u.%02d\\n\",\n\t\t   avdepth / 100, avdepth % 100);\n\tseq_printf(seq, \"\\tMax depth:      %u\\n\", stat->maxdepth);\n\n\tseq_printf(seq, \"\\tLeaves:         %u\\n\", stat->leaves);\n\tbytes = LEAF_SIZE * stat->leaves;\n\n\tseq_printf(seq, \"\\tPrefixes:       %u\\n\", stat->prefixes);\n\tbytes += sizeof(struct fib_alias) * stat->prefixes;\n\n\tseq_printf(seq, \"\\tInternal nodes: %u\\n\\t\", stat->tnodes);\n\tbytes += TNODE_SIZE(0) * stat->tnodes;\n\n\tmax = MAX_STAT_DEPTH;\n\twhile (max > 0 && stat->nodesizes[max-1] == 0)\n\t\tmax--;\n\n\tpointers = 0;\n\tfor (i = 1; i < max; i++)\n\t\tif (stat->nodesizes[i] != 0) {\n\t\t\tseq_printf(seq, \"  %u: %u\",  i, stat->nodesizes[i]);\n\t\t\tpointers += (1<<i) * stat->nodesizes[i];\n\t\t}\n\tseq_putc(seq, '\\n');\n\tseq_printf(seq, \"\\tPointers: %u\\n\", pointers);\n\n\tbytes += sizeof(struct key_vector *) * pointers;\n\tseq_printf(seq, \"Null ptrs: %u\\n\", stat->nullpointers);\n\tseq_printf(seq, \"Total size: %u  kB\\n\", (bytes + 1023) / 1024);\n}\n\n#ifdef CONFIG_IP_FIB_TRIE_STATS\nstatic void trie_show_usage(struct seq_file *seq,\n\t\t\t    const struct trie_use_stats __percpu *stats)\n{\n\tstruct trie_use_stats s = { 0 };\n\tint cpu;\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct trie_use_stats *pcpu = per_cpu_ptr(stats, cpu);\n\n\t\ts.gets += pcpu->gets;\n\t\ts.backtrack += pcpu->backtrack;\n\t\ts.semantic_match_passed += pcpu->semantic_match_passed;\n\t\ts.semantic_match_miss += pcpu->semantic_match_miss;\n\t\ts.null_node_hit += pcpu->null_node_hit;\n\t\ts.resize_node_skipped += pcpu->resize_node_skipped;\n\t}\n\n\tseq_printf(seq, \"\\nCounters:\\n---------\\n\");\n\tseq_printf(seq, \"gets = %u\\n\", s.gets);\n\tseq_printf(seq, \"backtracks = %u\\n\", s.backtrack);\n\tseq_printf(seq, \"semantic match passed = %u\\n\",\n\t\t   s.semantic_match_passed);\n\tseq_printf(seq, \"semantic match miss = %u\\n\", s.semantic_match_miss);\n\tseq_printf(seq, \"null node hit= %u\\n\", s.null_node_hit);\n\tseq_printf(seq, \"skipped node resize = %u\\n\\n\", s.resize_node_skipped);\n}\n#endif  \n\nstatic void fib_table_print(struct seq_file *seq, struct fib_table *tb)\n{\n\tif (tb->tb_id == RT_TABLE_LOCAL)\n\t\tseq_puts(seq, \"Local:\\n\");\n\telse if (tb->tb_id == RT_TABLE_MAIN)\n\t\tseq_puts(seq, \"Main:\\n\");\n\telse\n\t\tseq_printf(seq, \"Id %d:\\n\", tb->tb_id);\n}\n\n\nstatic int fib_triestat_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct net *net = seq->private;\n\tunsigned int h;\n\n\tseq_printf(seq,\n\t\t   \"Basic info: size of leaf:\"\n\t\t   \" %zd bytes, size of tnode: %zd bytes.\\n\",\n\t\t   LEAF_SIZE, TNODE_SIZE(0));\n\n\trcu_read_lock();\n\tfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\n\t\tstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\n\t\tstruct fib_table *tb;\n\n\t\thlist_for_each_entry_rcu(tb, head, tb_hlist) {\n\t\t\tstruct trie *t = (struct trie *) tb->tb_data;\n\t\t\tstruct trie_stat stat;\n\n\t\t\tif (!t)\n\t\t\t\tcontinue;\n\n\t\t\tfib_table_print(seq, tb);\n\n\t\t\ttrie_collect_stats(t, &stat);\n\t\t\ttrie_show_stats(seq, &stat);\n#ifdef CONFIG_IP_FIB_TRIE_STATS\n\t\t\ttrie_show_usage(seq, t->stats);\n#endif\n\t\t}\n\t\tcond_resched_rcu();\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic struct key_vector *fib_trie_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct fib_trie_iter *iter = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tloff_t idx = 0;\n\tunsigned int h;\n\n\tfor (h = 0; h < FIB_TABLE_HASHSZ; h++) {\n\t\tstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\n\t\tstruct fib_table *tb;\n\n\t\thlist_for_each_entry_rcu(tb, head, tb_hlist) {\n\t\t\tstruct key_vector *n;\n\n\t\t\tfor (n = fib_trie_get_first(iter,\n\t\t\t\t\t\t    (struct trie *) tb->tb_data);\n\t\t\t     n; n = fib_trie_get_next(iter))\n\t\t\t\tif (pos == idx++) {\n\t\t\t\t\titer->tb = tb;\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void *fib_trie_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\trcu_read_lock();\n\treturn fib_trie_get_idx(seq, *pos);\n}\n\nstatic void *fib_trie_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct fib_trie_iter *iter = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct fib_table *tb = iter->tb;\n\tstruct hlist_node *tb_node;\n\tunsigned int h;\n\tstruct key_vector *n;\n\n\t++*pos;\n\t \n\tn = fib_trie_get_next(iter);\n\tif (n)\n\t\treturn n;\n\n\t \n\th = tb->tb_id & (FIB_TABLE_HASHSZ - 1);\n\twhile ((tb_node = rcu_dereference(hlist_next_rcu(&tb->tb_hlist)))) {\n\t\ttb = hlist_entry(tb_node, struct fib_table, tb_hlist);\n\t\tn = fib_trie_get_first(iter, (struct trie *) tb->tb_data);\n\t\tif (n)\n\t\t\tgoto found;\n\t}\n\n\t \n\twhile (++h < FIB_TABLE_HASHSZ) {\n\t\tstruct hlist_head *head = &net->ipv4.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(tb, head, tb_hlist) {\n\t\t\tn = fib_trie_get_first(iter, (struct trie *) tb->tb_data);\n\t\t\tif (n)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\treturn NULL;\n\nfound:\n\titer->tb = tb;\n\treturn n;\n}\n\nstatic void fib_trie_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\nstatic void seq_indent(struct seq_file *seq, int n)\n{\n\twhile (n-- > 0)\n\t\tseq_puts(seq, \"   \");\n}\n\nstatic inline const char *rtn_scope(char *buf, size_t len, enum rt_scope_t s)\n{\n\tswitch (s) {\n\tcase RT_SCOPE_UNIVERSE: return \"universe\";\n\tcase RT_SCOPE_SITE:\treturn \"site\";\n\tcase RT_SCOPE_LINK:\treturn \"link\";\n\tcase RT_SCOPE_HOST:\treturn \"host\";\n\tcase RT_SCOPE_NOWHERE:\treturn \"nowhere\";\n\tdefault:\n\t\tsnprintf(buf, len, \"scope=%d\", s);\n\t\treturn buf;\n\t}\n}\n\nstatic const char *const rtn_type_names[__RTN_MAX] = {\n\t[RTN_UNSPEC] = \"UNSPEC\",\n\t[RTN_UNICAST] = \"UNICAST\",\n\t[RTN_LOCAL] = \"LOCAL\",\n\t[RTN_BROADCAST] = \"BROADCAST\",\n\t[RTN_ANYCAST] = \"ANYCAST\",\n\t[RTN_MULTICAST] = \"MULTICAST\",\n\t[RTN_BLACKHOLE] = \"BLACKHOLE\",\n\t[RTN_UNREACHABLE] = \"UNREACHABLE\",\n\t[RTN_PROHIBIT] = \"PROHIBIT\",\n\t[RTN_THROW] = \"THROW\",\n\t[RTN_NAT] = \"NAT\",\n\t[RTN_XRESOLVE] = \"XRESOLVE\",\n};\n\nstatic inline const char *rtn_type(char *buf, size_t len, unsigned int t)\n{\n\tif (t < __RTN_MAX && rtn_type_names[t])\n\t\treturn rtn_type_names[t];\n\tsnprintf(buf, len, \"type %u\", t);\n\treturn buf;\n}\n\n \nstatic int fib_trie_seq_show(struct seq_file *seq, void *v)\n{\n\tconst struct fib_trie_iter *iter = seq->private;\n\tstruct key_vector *n = v;\n\n\tif (IS_TRIE(node_parent_rcu(n)))\n\t\tfib_table_print(seq, iter->tb);\n\n\tif (IS_TNODE(n)) {\n\t\t__be32 prf = htonl(n->key);\n\n\t\tseq_indent(seq, iter->depth-1);\n\t\tseq_printf(seq, \"  +-- %pI4/%zu %u %u %u\\n\",\n\t\t\t   &prf, KEYLENGTH - n->pos - n->bits, n->bits,\n\t\t\t   tn_info(n)->full_children,\n\t\t\t   tn_info(n)->empty_children);\n\t} else {\n\t\t__be32 val = htonl(n->key);\n\t\tstruct fib_alias *fa;\n\n\t\tseq_indent(seq, iter->depth);\n\t\tseq_printf(seq, \"  |-- %pI4\\n\", &val);\n\n\t\thlist_for_each_entry_rcu(fa, &n->leaf, fa_list) {\n\t\t\tchar buf1[32], buf2[32];\n\n\t\t\tseq_indent(seq, iter->depth + 1);\n\t\t\tseq_printf(seq, \"  /%zu %s %s\",\n\t\t\t\t   KEYLENGTH - fa->fa_slen,\n\t\t\t\t   rtn_scope(buf1, sizeof(buf1),\n\t\t\t\t\t     fa->fa_info->fib_scope),\n\t\t\t\t   rtn_type(buf2, sizeof(buf2),\n\t\t\t\t\t    fa->fa_type));\n\t\t\tif (fa->fa_dscp)\n\t\t\t\tseq_printf(seq, \" tos=%d\",\n\t\t\t\t\t   inet_dscp_to_dsfield(fa->fa_dscp));\n\t\t\tseq_putc(seq, '\\n');\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct seq_operations fib_trie_seq_ops = {\n\t.start  = fib_trie_seq_start,\n\t.next   = fib_trie_seq_next,\n\t.stop   = fib_trie_seq_stop,\n\t.show   = fib_trie_seq_show,\n};\n\nstruct fib_route_iter {\n\tstruct seq_net_private p;\n\tstruct fib_table *main_tb;\n\tstruct key_vector *tnode;\n\tloff_t\tpos;\n\tt_key\tkey;\n};\n\nstatic struct key_vector *fib_route_get_idx(struct fib_route_iter *iter,\n\t\t\t\t\t    loff_t pos)\n{\n\tstruct key_vector *l, **tp = &iter->tnode;\n\tt_key key;\n\n\t \n\tif (iter->pos > 0 && pos >= iter->pos) {\n\t\tkey = iter->key;\n\t} else {\n\t\titer->pos = 1;\n\t\tkey = 0;\n\t}\n\n\tpos -= iter->pos;\n\n\twhile ((l = leaf_walk_rcu(tp, key)) && (pos-- > 0)) {\n\t\tkey = l->key + 1;\n\t\titer->pos++;\n\t\tl = NULL;\n\n\t\t \n\t\tif (!key)\n\t\t\tbreak;\n\t}\n\n\tif (l)\n\t\titer->key = l->key;\t \n\telse\n\t\titer->pos = 0;\t\t \n\n\treturn l;\n}\n\nstatic void *fib_route_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct fib_route_iter *iter = seq->private;\n\tstruct fib_table *tb;\n\tstruct trie *t;\n\n\trcu_read_lock();\n\n\ttb = fib_get_table(seq_file_net(seq), RT_TABLE_MAIN);\n\tif (!tb)\n\t\treturn NULL;\n\n\titer->main_tb = tb;\n\tt = (struct trie *)tb->tb_data;\n\titer->tnode = t->kv;\n\n\tif (*pos != 0)\n\t\treturn fib_route_get_idx(iter, *pos);\n\n\titer->pos = 0;\n\titer->key = KEY_MAX;\n\n\treturn SEQ_START_TOKEN;\n}\n\nstatic void *fib_route_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct fib_route_iter *iter = seq->private;\n\tstruct key_vector *l = NULL;\n\tt_key key = iter->key + 1;\n\n\t++*pos;\n\n\t \n\tif ((v == SEQ_START_TOKEN) || key)\n\t\tl = leaf_walk_rcu(&iter->tnode, key);\n\n\tif (l) {\n\t\titer->key = l->key;\n\t\titer->pos++;\n\t} else {\n\t\titer->pos = 0;\n\t}\n\n\treturn l;\n}\n\nstatic void fib_route_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\nstatic unsigned int fib_flag_trans(int type, __be32 mask, struct fib_info *fi)\n{\n\tunsigned int flags = 0;\n\n\tif (type == RTN_UNREACHABLE || type == RTN_PROHIBIT)\n\t\tflags = RTF_REJECT;\n\tif (fi) {\n\t\tconst struct fib_nh_common *nhc = fib_info_nhc(fi, 0);\n\n\t\tif (nhc->nhc_gw.ipv4)\n\t\t\tflags |= RTF_GATEWAY;\n\t}\n\tif (mask == htonl(0xFFFFFFFF))\n\t\tflags |= RTF_HOST;\n\tflags |= RTF_UP;\n\treturn flags;\n}\n\n \nstatic int fib_route_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct fib_route_iter *iter = seq->private;\n\tstruct fib_table *tb = iter->main_tb;\n\tstruct fib_alias *fa;\n\tstruct key_vector *l = v;\n\t__be32 prefix;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(seq, \"%-127s\\n\", \"Iface\\tDestination\\tGateway \"\n\t\t\t   \"\\tFlags\\tRefCnt\\tUse\\tMetric\\tMask\\t\\tMTU\"\n\t\t\t   \"\\tWindow\\tIRTT\");\n\t\treturn 0;\n\t}\n\n\tprefix = htonl(l->key);\n\n\thlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {\n\t\tstruct fib_info *fi = fa->fa_info;\n\t\t__be32 mask = inet_make_mask(KEYLENGTH - fa->fa_slen);\n\t\tunsigned int flags = fib_flag_trans(fa->fa_type, mask, fi);\n\n\t\tif ((fa->fa_type == RTN_BROADCAST) ||\n\t\t    (fa->fa_type == RTN_MULTICAST))\n\t\t\tcontinue;\n\n\t\tif (fa->tb_id != tb->tb_id)\n\t\t\tcontinue;\n\n\t\tseq_setwidth(seq, 127);\n\n\t\tif (fi) {\n\t\t\tstruct fib_nh_common *nhc = fib_info_nhc(fi, 0);\n\t\t\t__be32 gw = 0;\n\n\t\t\tif (nhc->nhc_gw_family == AF_INET)\n\t\t\t\tgw = nhc->nhc_gw.ipv4;\n\n\t\t\tseq_printf(seq,\n\t\t\t\t   \"%s\\t%08X\\t%08X\\t%04X\\t%d\\t%u\\t\"\n\t\t\t\t   \"%d\\t%08X\\t%d\\t%u\\t%u\",\n\t\t\t\t   nhc->nhc_dev ? nhc->nhc_dev->name : \"*\",\n\t\t\t\t   prefix, gw, flags, 0, 0,\n\t\t\t\t   fi->fib_priority,\n\t\t\t\t   mask,\n\t\t\t\t   (fi->fib_advmss ?\n\t\t\t\t    fi->fib_advmss + 40 : 0),\n\t\t\t\t   fi->fib_window,\n\t\t\t\t   fi->fib_rtt >> 3);\n\t\t} else {\n\t\t\tseq_printf(seq,\n\t\t\t\t   \"*\\t%08X\\t%08X\\t%04X\\t%d\\t%u\\t\"\n\t\t\t\t   \"%d\\t%08X\\t%d\\t%u\\t%u\",\n\t\t\t\t   prefix, 0, flags, 0, 0, 0,\n\t\t\t\t   mask, 0, 0, 0);\n\t\t}\n\t\tseq_pad(seq, '\\n');\n\t}\n\n\treturn 0;\n}\n\nstatic const struct seq_operations fib_route_seq_ops = {\n\t.start  = fib_route_seq_start,\n\t.next   = fib_route_seq_next,\n\t.stop   = fib_route_seq_stop,\n\t.show   = fib_route_seq_show,\n};\n\nint __net_init fib_proc_init(struct net *net)\n{\n\tif (!proc_create_net(\"fib_trie\", 0444, net->proc_net, &fib_trie_seq_ops,\n\t\t\tsizeof(struct fib_trie_iter)))\n\t\tgoto out1;\n\n\tif (!proc_create_net_single(\"fib_triestat\", 0444, net->proc_net,\n\t\t\tfib_triestat_seq_show, NULL))\n\t\tgoto out2;\n\n\tif (!proc_create_net(\"route\", 0444, net->proc_net, &fib_route_seq_ops,\n\t\t\tsizeof(struct fib_route_iter)))\n\t\tgoto out3;\n\n\treturn 0;\n\nout3:\n\tremove_proc_entry(\"fib_triestat\", net->proc_net);\nout2:\n\tremove_proc_entry(\"fib_trie\", net->proc_net);\nout1:\n\treturn -ENOMEM;\n}\n\nvoid __net_exit fib_proc_exit(struct net *net)\n{\n\tremove_proc_entry(\"fib_trie\", net->proc_net);\n\tremove_proc_entry(\"fib_triestat\", net->proc_net);\n\tremove_proc_entry(\"route\", net->proc_net);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}