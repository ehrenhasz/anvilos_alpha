{
  "module_name": "tcp_minisocks.c",
  "hash_id": "30ef6b02673713d18310521f57d24358706851bee7cbfd95000d10ab29b0b8dd",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_minisocks.c",
  "human_readable_source": "\n \n\n#include <net/tcp.h>\n#include <net/xfrm.h>\n#include <net/busy_poll.h>\n\nstatic bool tcp_in_window(u32 seq, u32 end_seq, u32 s_win, u32 e_win)\n{\n\tif (seq == s_win)\n\t\treturn true;\n\tif (after(end_seq, s_win) && before(seq, e_win))\n\t\treturn true;\n\treturn seq == e_win && seq == end_seq;\n}\n\nstatic enum tcp_tw_status\ntcp_timewait_check_oow_rate_limit(struct inet_timewait_sock *tw,\n\t\t\t\t  const struct sk_buff *skb, int mib_idx)\n{\n\tstruct tcp_timewait_sock *tcptw = tcp_twsk((struct sock *)tw);\n\n\tif (!tcp_oow_rate_limited(twsk_net(tw), skb, mib_idx,\n\t\t\t\t  &tcptw->tw_last_oow_ack_time)) {\n\t\t \n\t\treturn TCP_TW_ACK;\n\t}\n\n\t \n\tinet_twsk_put(tw);\n\treturn TCP_TW_SUCCESS;\n}\n\n \nenum tcp_tw_status\ntcp_timewait_state_process(struct inet_timewait_sock *tw, struct sk_buff *skb,\n\t\t\t   const struct tcphdr *th)\n{\n\tstruct tcp_options_received tmp_opt;\n\tstruct tcp_timewait_sock *tcptw = tcp_twsk((struct sock *)tw);\n\tbool paws_reject = false;\n\n\ttmp_opt.saw_tstamp = 0;\n\tif (th->doff > (sizeof(*th) >> 2) && tcptw->tw_ts_recent_stamp) {\n\t\ttcp_parse_options(twsk_net(tw), skb, &tmp_opt, 0, NULL);\n\n\t\tif (tmp_opt.saw_tstamp) {\n\t\t\tif (tmp_opt.rcv_tsecr)\n\t\t\t\ttmp_opt.rcv_tsecr -= tcptw->tw_ts_offset;\n\t\t\ttmp_opt.ts_recent\t= tcptw->tw_ts_recent;\n\t\t\ttmp_opt.ts_recent_stamp\t= tcptw->tw_ts_recent_stamp;\n\t\t\tpaws_reject = tcp_paws_reject(&tmp_opt, th->rst);\n\t\t}\n\t}\n\n\tif (tw->tw_substate == TCP_FIN_WAIT2) {\n\t\t \n\n\t\t \n\t\tif (paws_reject ||\n\t\t    !tcp_in_window(TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq,\n\t\t\t\t   tcptw->tw_rcv_nxt,\n\t\t\t\t   tcptw->tw_rcv_nxt + tcptw->tw_rcv_wnd))\n\t\t\treturn tcp_timewait_check_oow_rate_limit(\n\t\t\t\ttw, skb, LINUX_MIB_TCPACKSKIPPEDFINWAIT2);\n\n\t\tif (th->rst)\n\t\t\tgoto kill;\n\n\t\tif (th->syn && !before(TCP_SKB_CB(skb)->seq, tcptw->tw_rcv_nxt))\n\t\t\treturn TCP_TW_RST;\n\n\t\t \n\t\tif (!th->ack ||\n\t\t    !after(TCP_SKB_CB(skb)->end_seq, tcptw->tw_rcv_nxt) ||\n\t\t    TCP_SKB_CB(skb)->end_seq == TCP_SKB_CB(skb)->seq) {\n\t\t\tinet_twsk_put(tw);\n\t\t\treturn TCP_TW_SUCCESS;\n\t\t}\n\n\t\t \n\t\tif (!th->fin ||\n\t\t    TCP_SKB_CB(skb)->end_seq != tcptw->tw_rcv_nxt + 1)\n\t\t\treturn TCP_TW_RST;\n\n\t\t \n\t\ttw->tw_substate\t  = TCP_TIME_WAIT;\n\t\ttcptw->tw_rcv_nxt = TCP_SKB_CB(skb)->end_seq;\n\t\tif (tmp_opt.saw_tstamp) {\n\t\t\ttcptw->tw_ts_recent_stamp = ktime_get_seconds();\n\t\t\ttcptw->tw_ts_recent\t  = tmp_opt.rcv_tsval;\n\t\t}\n\n\t\tinet_twsk_reschedule(tw, TCP_TIMEWAIT_LEN);\n\t\treturn TCP_TW_ACK;\n\t}\n\n\t \n\n\tif (!paws_reject &&\n\t    (TCP_SKB_CB(skb)->seq == tcptw->tw_rcv_nxt &&\n\t     (TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq || th->rst))) {\n\t\t \n\n\t\tif (th->rst) {\n\t\t\t \n\t\t\tif (!READ_ONCE(twsk_net(tw)->ipv4.sysctl_tcp_rfc1337)) {\nkill:\n\t\t\t\tinet_twsk_deschedule_put(tw);\n\t\t\t\treturn TCP_TW_SUCCESS;\n\t\t\t}\n\t\t} else {\n\t\t\tinet_twsk_reschedule(tw, TCP_TIMEWAIT_LEN);\n\t\t}\n\n\t\tif (tmp_opt.saw_tstamp) {\n\t\t\ttcptw->tw_ts_recent\t  = tmp_opt.rcv_tsval;\n\t\t\ttcptw->tw_ts_recent_stamp = ktime_get_seconds();\n\t\t}\n\n\t\tinet_twsk_put(tw);\n\t\treturn TCP_TW_SUCCESS;\n\t}\n\n\t \n\n\tif (th->syn && !th->rst && !th->ack && !paws_reject &&\n\t    (after(TCP_SKB_CB(skb)->seq, tcptw->tw_rcv_nxt) ||\n\t     (tmp_opt.saw_tstamp &&\n\t      (s32)(tcptw->tw_ts_recent - tmp_opt.rcv_tsval) < 0))) {\n\t\tu32 isn = tcptw->tw_snd_nxt + 65535 + 2;\n\t\tif (isn == 0)\n\t\t\tisn++;\n\t\tTCP_SKB_CB(skb)->tcp_tw_isn = isn;\n\t\treturn TCP_TW_SYN;\n\t}\n\n\tif (paws_reject)\n\t\t__NET_INC_STATS(twsk_net(tw), LINUX_MIB_PAWSESTABREJECTED);\n\n\tif (!th->rst) {\n\t\t \n\t\tif (paws_reject || th->ack)\n\t\t\tinet_twsk_reschedule(tw, TCP_TIMEWAIT_LEN);\n\n\t\treturn tcp_timewait_check_oow_rate_limit(\n\t\t\ttw, skb, LINUX_MIB_TCPACKSKIPPEDTIMEWAIT);\n\t}\n\tinet_twsk_put(tw);\n\treturn TCP_TW_SUCCESS;\n}\nEXPORT_SYMBOL(tcp_timewait_state_process);\n\nstatic void tcp_time_wait_init(struct sock *sk, struct tcp_timewait_sock *tcptw)\n{\n#ifdef CONFIG_TCP_MD5SIG\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcp_md5sig_key *key;\n\n\t \n\ttcptw->tw_md5_key = NULL;\n\tif (!static_branch_unlikely(&tcp_md5_needed.key))\n\t\treturn;\n\n\tkey = tp->af_specific->md5_lookup(sk, sk);\n\tif (key) {\n\t\ttcptw->tw_md5_key = kmemdup(key, sizeof(*key), GFP_ATOMIC);\n\t\tif (!tcptw->tw_md5_key)\n\t\t\treturn;\n\t\tif (!tcp_alloc_md5sig_pool())\n\t\t\tgoto out_free;\n\t\tif (!static_key_fast_inc_not_disabled(&tcp_md5_needed.key.key))\n\t\t\tgoto out_free;\n\t}\n\treturn;\nout_free:\n\tWARN_ON_ONCE(1);\n\tkfree(tcptw->tw_md5_key);\n\ttcptw->tw_md5_key = NULL;\n#endif\n}\n\n \nvoid tcp_time_wait(struct sock *sk, int state, int timeo)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct inet_timewait_sock *tw;\n\n\ttw = inet_twsk_alloc(sk, &net->ipv4.tcp_death_row, state);\n\n\tif (tw) {\n\t\tstruct tcp_timewait_sock *tcptw = tcp_twsk((struct sock *)tw);\n\t\tconst int rto = (icsk->icsk_rto << 2) - (icsk->icsk_rto >> 1);\n\n\t\ttw->tw_transparent\t= inet_test_bit(TRANSPARENT, sk);\n\t\ttw->tw_mark\t\t= sk->sk_mark;\n\t\ttw->tw_priority\t\t= sk->sk_priority;\n\t\ttw->tw_rcv_wscale\t= tp->rx_opt.rcv_wscale;\n\t\ttcptw->tw_rcv_nxt\t= tp->rcv_nxt;\n\t\ttcptw->tw_snd_nxt\t= tp->snd_nxt;\n\t\ttcptw->tw_rcv_wnd\t= tcp_receive_window(tp);\n\t\ttcptw->tw_ts_recent\t= tp->rx_opt.ts_recent;\n\t\ttcptw->tw_ts_recent_stamp = tp->rx_opt.ts_recent_stamp;\n\t\ttcptw->tw_ts_offset\t= tp->tsoffset;\n\t\ttcptw->tw_last_oow_ack_time = 0;\n\t\ttcptw->tw_tx_delay\t= tp->tcp_tx_delay;\n\t\ttw->tw_txhash\t\t= sk->sk_txhash;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (tw->tw_family == PF_INET6) {\n\t\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\t\t\ttw->tw_v6_daddr = sk->sk_v6_daddr;\n\t\t\ttw->tw_v6_rcv_saddr = sk->sk_v6_rcv_saddr;\n\t\t\ttw->tw_tclass = np->tclass;\n\t\t\ttw->tw_flowlabel = be32_to_cpu(np->flow_label & IPV6_FLOWLABEL_MASK);\n\t\t\ttw->tw_ipv6only = sk->sk_ipv6only;\n\t\t}\n#endif\n\n\t\ttcp_time_wait_init(sk, tcptw);\n\n\t\t \n\t\tif (timeo < rto)\n\t\t\ttimeo = rto;\n\n\t\tif (state == TCP_TIME_WAIT)\n\t\t\ttimeo = TCP_TIMEWAIT_LEN;\n\n\t\t \n\t\tlocal_bh_disable();\n\t\tinet_twsk_schedule(tw, timeo);\n\t\t \n\t\tinet_twsk_hashdance(tw, sk, net->ipv4.tcp_death_row.hashinfo);\n\t\tlocal_bh_enable();\n\t} else {\n\t\t \n\t\tNET_INC_STATS(net, LINUX_MIB_TCPTIMEWAITOVERFLOW);\n\t}\n\n\ttcp_update_metrics(sk);\n\ttcp_done(sk);\n}\nEXPORT_SYMBOL(tcp_time_wait);\n\nvoid tcp_twsk_destructor(struct sock *sk)\n{\n#ifdef CONFIG_TCP_MD5SIG\n\tif (static_branch_unlikely(&tcp_md5_needed.key)) {\n\t\tstruct tcp_timewait_sock *twsk = tcp_twsk(sk);\n\n\t\tif (twsk->tw_md5_key) {\n\t\t\tkfree_rcu(twsk->tw_md5_key, rcu);\n\t\t\tstatic_branch_slow_dec_deferred(&tcp_md5_needed);\n\t\t}\n\t}\n#endif\n}\nEXPORT_SYMBOL_GPL(tcp_twsk_destructor);\n\nvoid tcp_twsk_purge(struct list_head *net_exit_list, int family)\n{\n\tbool purged_once = false;\n\tstruct net *net;\n\n\tlist_for_each_entry(net, net_exit_list, exit_list) {\n\t\tif (net->ipv4.tcp_death_row.hashinfo->pernet) {\n\t\t\t \n\t\t\tinet_twsk_purge(net->ipv4.tcp_death_row.hashinfo, family);\n\t\t} else if (!purged_once) {\n\t\t\t \n\t\t\tif (refcount_read(&net->ipv4.tcp_death_row.tw_refcount) == 1)\n\t\t\t\tcontinue;\n\n\t\t\tinet_twsk_purge(&tcp_hashinfo, family);\n\t\t\tpurged_once = true;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(tcp_twsk_purge);\n\n \nvoid tcp_openreq_init_rwin(struct request_sock *req,\n\t\t\t   const struct sock *sk_listener,\n\t\t\t   const struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct tcp_sock *tp = tcp_sk(sk_listener);\n\tint full_space = tcp_full_space(sk_listener);\n\tu32 window_clamp;\n\t__u8 rcv_wscale;\n\tu32 rcv_wnd;\n\tint mss;\n\n\tmss = tcp_mss_clamp(tp, dst_metric_advmss(dst));\n\twindow_clamp = READ_ONCE(tp->window_clamp);\n\t \n\treq->rsk_window_clamp = window_clamp ? : dst_metric(dst, RTAX_WINDOW);\n\n\t \n\tif (sk_listener->sk_userlocks & SOCK_RCVBUF_LOCK &&\n\t    (req->rsk_window_clamp > full_space || req->rsk_window_clamp == 0))\n\t\treq->rsk_window_clamp = full_space;\n\n\trcv_wnd = tcp_rwnd_init_bpf((struct sock *)req);\n\tif (rcv_wnd == 0)\n\t\trcv_wnd = dst_metric(dst, RTAX_INITRWND);\n\telse if (full_space < rcv_wnd * mss)\n\t\tfull_space = rcv_wnd * mss;\n\n\t \n\ttcp_select_initial_window(sk_listener, full_space,\n\t\tmss - (ireq->tstamp_ok ? TCPOLEN_TSTAMP_ALIGNED : 0),\n\t\t&req->rsk_rcv_wnd,\n\t\t&req->rsk_window_clamp,\n\t\tireq->wscale_ok,\n\t\t&rcv_wscale,\n\t\trcv_wnd);\n\tireq->rcv_wscale = rcv_wscale;\n}\nEXPORT_SYMBOL(tcp_openreq_init_rwin);\n\nstatic void tcp_ecn_openreq_child(struct tcp_sock *tp,\n\t\t\t\t  const struct request_sock *req)\n{\n\ttp->ecn_flags = inet_rsk(req)->ecn_ok ? TCP_ECN_OK : 0;\n}\n\nvoid tcp_ca_openreq_child(struct sock *sk, const struct dst_entry *dst)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tu32 ca_key = dst_metric(dst, RTAX_CC_ALGO);\n\tbool ca_got_dst = false;\n\n\tif (ca_key != TCP_CA_UNSPEC) {\n\t\tconst struct tcp_congestion_ops *ca;\n\n\t\trcu_read_lock();\n\t\tca = tcp_ca_find_key(ca_key);\n\t\tif (likely(ca && bpf_try_module_get(ca, ca->owner))) {\n\t\t\ticsk->icsk_ca_dst_locked = tcp_ca_dst_locked(dst);\n\t\t\ticsk->icsk_ca_ops = ca;\n\t\t\tca_got_dst = true;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\t \n\tif (!ca_got_dst &&\n\t    (!icsk->icsk_ca_setsockopt ||\n\t     !bpf_try_module_get(icsk->icsk_ca_ops, icsk->icsk_ca_ops->owner)))\n\t\ttcp_assign_congestion_control(sk);\n\n\ttcp_set_ca_state(sk, TCP_CA_Open);\n}\nEXPORT_SYMBOL_GPL(tcp_ca_openreq_child);\n\nstatic void smc_check_reset_syn_req(const struct tcp_sock *oldtp,\n\t\t\t\t    struct request_sock *req,\n\t\t\t\t    struct tcp_sock *newtp)\n{\n#if IS_ENABLED(CONFIG_SMC)\n\tstruct inet_request_sock *ireq;\n\n\tif (static_branch_unlikely(&tcp_have_smc)) {\n\t\tireq = inet_rsk(req);\n\t\tif (oldtp->syn_smc && !ireq->smc_ok)\n\t\t\tnewtp->syn_smc = 0;\n\t}\n#endif\n}\n\n \nstruct sock *tcp_create_openreq_child(const struct sock *sk,\n\t\t\t\t      struct request_sock *req,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct sock *newsk = inet_csk_clone_lock(sk, req, GFP_ATOMIC);\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct tcp_request_sock *treq = tcp_rsk(req);\n\tstruct inet_connection_sock *newicsk;\n\tconst struct tcp_sock *oldtp;\n\tstruct tcp_sock *newtp;\n\tu32 seq;\n\n\tif (!newsk)\n\t\treturn NULL;\n\n\tnewicsk = inet_csk(newsk);\n\tnewtp = tcp_sk(newsk);\n\toldtp = tcp_sk(sk);\n\n\tsmc_check_reset_syn_req(oldtp, req, newtp);\n\n\t \n\tnewtp->pred_flags = 0;\n\n\tseq = treq->rcv_isn + 1;\n\tnewtp->rcv_wup = seq;\n\tWRITE_ONCE(newtp->copied_seq, seq);\n\tWRITE_ONCE(newtp->rcv_nxt, seq);\n\tnewtp->segs_in = 1;\n\n\tseq = treq->snt_isn + 1;\n\tnewtp->snd_sml = newtp->snd_una = seq;\n\tWRITE_ONCE(newtp->snd_nxt, seq);\n\tnewtp->snd_up = seq;\n\n\tINIT_LIST_HEAD(&newtp->tsq_node);\n\tINIT_LIST_HEAD(&newtp->tsorted_sent_queue);\n\n\ttcp_init_wl(newtp, treq->rcv_isn);\n\n\tminmax_reset(&newtp->rtt_min, tcp_jiffies32, ~0U);\n\tnewicsk->icsk_ack.lrcvtime = tcp_jiffies32;\n\n\tnewtp->lsndtime = tcp_jiffies32;\n\tnewsk->sk_txhash = READ_ONCE(treq->txhash);\n\tnewtp->total_retrans = req->num_retrans;\n\n\ttcp_init_xmit_timers(newsk);\n\tWRITE_ONCE(newtp->write_seq, newtp->pushed_seq = treq->snt_isn + 1);\n\n\tif (sock_flag(newsk, SOCK_KEEPOPEN))\n\t\tinet_csk_reset_keepalive_timer(newsk,\n\t\t\t\t\t       keepalive_time_when(newtp));\n\n\tnewtp->rx_opt.tstamp_ok = ireq->tstamp_ok;\n\tnewtp->rx_opt.sack_ok = ireq->sack_ok;\n\tnewtp->window_clamp = req->rsk_window_clamp;\n\tnewtp->rcv_ssthresh = req->rsk_rcv_wnd;\n\tnewtp->rcv_wnd = req->rsk_rcv_wnd;\n\tnewtp->rx_opt.wscale_ok = ireq->wscale_ok;\n\tif (newtp->rx_opt.wscale_ok) {\n\t\tnewtp->rx_opt.snd_wscale = ireq->snd_wscale;\n\t\tnewtp->rx_opt.rcv_wscale = ireq->rcv_wscale;\n\t} else {\n\t\tnewtp->rx_opt.snd_wscale = newtp->rx_opt.rcv_wscale = 0;\n\t\tnewtp->window_clamp = min(newtp->window_clamp, 65535U);\n\t}\n\tnewtp->snd_wnd = ntohs(tcp_hdr(skb)->window) << newtp->rx_opt.snd_wscale;\n\tnewtp->max_window = newtp->snd_wnd;\n\n\tif (newtp->rx_opt.tstamp_ok) {\n\t\tnewtp->rx_opt.ts_recent = READ_ONCE(req->ts_recent);\n\t\tnewtp->rx_opt.ts_recent_stamp = ktime_get_seconds();\n\t\tnewtp->tcp_header_len = sizeof(struct tcphdr) + TCPOLEN_TSTAMP_ALIGNED;\n\t} else {\n\t\tnewtp->rx_opt.ts_recent_stamp = 0;\n\t\tnewtp->tcp_header_len = sizeof(struct tcphdr);\n\t}\n\tif (req->num_timeout) {\n\t\tnewtp->undo_marker = treq->snt_isn;\n\t\tnewtp->retrans_stamp = div_u64(treq->snt_synack,\n\t\t\t\t\t       USEC_PER_SEC / TCP_TS_HZ);\n\t}\n\tnewtp->tsoffset = treq->ts_off;\n#ifdef CONFIG_TCP_MD5SIG\n\tnewtp->md5sig_info = NULL;\t \n#endif\n\tif (skb->len >= TCP_MSS_DEFAULT + newtp->tcp_header_len)\n\t\tnewicsk->icsk_ack.last_seg_size = skb->len - newtp->tcp_header_len;\n\tnewtp->rx_opt.mss_clamp = req->mss;\n\ttcp_ecn_openreq_child(newtp, req);\n\tnewtp->fastopen_req = NULL;\n\tRCU_INIT_POINTER(newtp->fastopen_rsk, NULL);\n\n\tnewtp->bpf_chg_cc_inprogress = 0;\n\ttcp_bpf_clone(sk, newsk);\n\n\t__TCP_INC_STATS(sock_net(sk), TCP_MIB_PASSIVEOPENS);\n\n\treturn newsk;\n}\nEXPORT_SYMBOL(tcp_create_openreq_child);\n\n \n\nstruct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct request_sock *req,\n\t\t\t   bool fastopen, bool *req_stolen)\n{\n\tstruct tcp_options_received tmp_opt;\n\tstruct sock *child;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__be32 flg = tcp_flag_word(th) & (TCP_FLAG_RST|TCP_FLAG_SYN|TCP_FLAG_ACK);\n\tbool paws_reject = false;\n\tbool own_req;\n\n\ttmp_opt.saw_tstamp = 0;\n\tif (th->doff > (sizeof(struct tcphdr)>>2)) {\n\t\ttcp_parse_options(sock_net(sk), skb, &tmp_opt, 0, NULL);\n\n\t\tif (tmp_opt.saw_tstamp) {\n\t\t\ttmp_opt.ts_recent = READ_ONCE(req->ts_recent);\n\t\t\tif (tmp_opt.rcv_tsecr)\n\t\t\t\ttmp_opt.rcv_tsecr -= tcp_rsk(req)->ts_off;\n\t\t\t \n\t\t\ttmp_opt.ts_recent_stamp = ktime_get_seconds() - reqsk_timeout(req, TCP_RTO_MAX) / HZ;\n\t\t\tpaws_reject = tcp_paws_reject(&tmp_opt, th->rst);\n\t\t}\n\t}\n\n\t \n\tif (TCP_SKB_CB(skb)->seq == tcp_rsk(req)->rcv_isn &&\n\t    flg == TCP_FLAG_SYN &&\n\t    !paws_reject) {\n\t\t \n\t\tif (!tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t\t  LINUX_MIB_TCPACKSKIPPEDSYNRECV,\n\t\t\t\t\t  &tcp_rsk(req)->last_oow_ack_time) &&\n\n\t\t    !inet_rtx_syn_ack(sk, req)) {\n\t\t\tunsigned long expires = jiffies;\n\n\t\t\texpires += reqsk_timeout(req, TCP_RTO_MAX);\n\t\t\tif (!fastopen)\n\t\t\t\tmod_timer_pending(&req->rsk_timer, expires);\n\t\t\telse\n\t\t\t\treq->rsk_timer.expires = expires;\n\t\t}\n\t\treturn NULL;\n\t}\n\n\t \n\n\t \n\tif ((flg & TCP_FLAG_ACK) && !fastopen &&\n\t    (TCP_SKB_CB(skb)->ack_seq !=\n\t     tcp_rsk(req)->snt_isn + 1))\n\t\treturn sk;\n\n\t \n\n\t \n\n\tif (paws_reject || !tcp_in_window(TCP_SKB_CB(skb)->seq, TCP_SKB_CB(skb)->end_seq,\n\t\t\t\t\t  tcp_rsk(req)->rcv_nxt, tcp_rsk(req)->rcv_nxt + req->rsk_rcv_wnd)) {\n\t\t \n\t\tif (!(flg & TCP_FLAG_RST) &&\n\t\t    !tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t\t  LINUX_MIB_TCPACKSKIPPEDSYNRECV,\n\t\t\t\t\t  &tcp_rsk(req)->last_oow_ack_time))\n\t\t\treq->rsk_ops->send_ack(sk, skb, req);\n\t\tif (paws_reject)\n\t\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_PAWSESTABREJECTED);\n\t\treturn NULL;\n\t}\n\n\t \n\n\t \n\tif (tmp_opt.saw_tstamp && !after(TCP_SKB_CB(skb)->seq, tcp_rsk(req)->rcv_nxt))\n\t\tWRITE_ONCE(req->ts_recent, tmp_opt.rcv_tsval);\n\n\tif (TCP_SKB_CB(skb)->seq == tcp_rsk(req)->rcv_isn) {\n\t\t \n\t\tflg &= ~TCP_FLAG_SYN;\n\t}\n\n\t \n\tif (flg & (TCP_FLAG_RST|TCP_FLAG_SYN)) {\n\t\tTCP_INC_STATS(sock_net(sk), TCP_MIB_ATTEMPTFAILS);\n\t\tgoto embryonic_reset;\n\t}\n\n\t \n\tif (!(flg & TCP_FLAG_ACK))\n\t\treturn NULL;\n\n\t \n\tif (fastopen)\n\t\treturn sk;\n\n\t \n\tif (req->num_timeout < READ_ONCE(inet_csk(sk)->icsk_accept_queue.rskq_defer_accept) &&\n\t    TCP_SKB_CB(skb)->end_seq == tcp_rsk(req)->rcv_isn + 1) {\n\t\tinet_rsk(req)->acked = 1;\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPDEFERACCEPTDROP);\n\t\treturn NULL;\n\t}\n\n\t \n\tchild = inet_csk(sk)->icsk_af_ops->syn_recv_sock(sk, skb, req, NULL,\n\t\t\t\t\t\t\t req, &own_req);\n\tif (!child)\n\t\tgoto listen_overflow;\n\n\tif (own_req && rsk_drop_req(req)) {\n\t\treqsk_queue_removed(&inet_csk(req->rsk_listener)->icsk_accept_queue, req);\n\t\tinet_csk_reqsk_queue_drop_and_put(req->rsk_listener, req);\n\t\treturn child;\n\t}\n\n\tsock_rps_save_rxhash(child, skb);\n\ttcp_synack_rtt_meas(child, req);\n\t*req_stolen = !own_req;\n\treturn inet_csk_complete_hashdance(sk, child, req, own_req);\n\nlisten_overflow:\n\tif (sk != req->rsk_listener)\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPMIGRATEREQFAILURE);\n\n\tif (!READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_abort_on_overflow)) {\n\t\tinet_rsk(req)->acked = 1;\n\t\treturn NULL;\n\t}\n\nembryonic_reset:\n\tif (!(flg & TCP_FLAG_RST)) {\n\t\t \n\t\treq->rsk_ops->send_reset(sk, skb);\n\t} else if (fastopen) {  \n\t\treqsk_fastopen_remove(sk, req, true);\n\t\ttcp_reset(sk, skb);\n\t}\n\tif (!fastopen) {\n\t\tbool unlinked = inet_csk_reqsk_queue_drop(sk, req);\n\n\t\tif (unlinked)\n\t\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_EMBRYONICRSTS);\n\t\t*req_stolen = !unlinked;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(tcp_check_req);\n\n \n\nint tcp_child_process(struct sock *parent, struct sock *child,\n\t\t      struct sk_buff *skb)\n\t__releases(&((child)->sk_lock.slock))\n{\n\tint ret = 0;\n\tint state = child->sk_state;\n\n\t \n\tsk_mark_napi_id_set(child, skb);\n\n\ttcp_segs_in(tcp_sk(child), skb);\n\tif (!sock_owned_by_user(child)) {\n\t\tret = tcp_rcv_state_process(child, skb);\n\t\t \n\t\tif (state == TCP_SYN_RECV && child->sk_state != state)\n\t\t\tparent->sk_data_ready(parent);\n\t} else {\n\t\t \n\t\t__sk_add_backlog(child, skb);\n\t}\n\n\tbh_unlock_sock(child);\n\tsock_put(child);\n\treturn ret;\n}\nEXPORT_SYMBOL(tcp_child_process);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}