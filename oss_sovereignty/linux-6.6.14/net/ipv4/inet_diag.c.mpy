{
  "module_name": "inet_diag.c",
  "hash_id": "9a6298f24edc8821254f15e7be98828fa4ccb124e0fb10dff6ecdce208fac236",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/inet_diag.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/cache.h>\n#include <linux/init.h>\n#include <linux/time.h>\n\n#include <net/icmp.h>\n#include <net/tcp.h>\n#include <net/ipv6.h>\n#include <net/inet_common.h>\n#include <net/inet_connection_sock.h>\n#include <net/inet_hashtables.h>\n#include <net/inet_timewait_sock.h>\n#include <net/inet6_hashtables.h>\n#include <net/bpf_sk_storage.h>\n#include <net/netlink.h>\n\n#include <linux/inet.h>\n#include <linux/stddef.h>\n\n#include <linux/inet_diag.h>\n#include <linux/sock_diag.h>\n\nstatic const struct inet_diag_handler **inet_diag_table;\n\nstruct inet_diag_entry {\n\tconst __be32 *saddr;\n\tconst __be32 *daddr;\n\tu16 sport;\n\tu16 dport;\n\tu16 family;\n\tu16 userlocks;\n\tu32 ifindex;\n\tu32 mark;\n#ifdef CONFIG_SOCK_CGROUP_DATA\n\tu64 cgroup_id;\n#endif\n};\n\nstatic DEFINE_MUTEX(inet_diag_table_mutex);\n\nstatic const struct inet_diag_handler *inet_diag_lock_handler(int proto)\n{\n\tif (proto < 0 || proto >= IPPROTO_MAX) {\n\t\tmutex_lock(&inet_diag_table_mutex);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tif (!inet_diag_table[proto])\n\t\tsock_load_diag_module(AF_INET, proto);\n\n\tmutex_lock(&inet_diag_table_mutex);\n\tif (!inet_diag_table[proto])\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn inet_diag_table[proto];\n}\n\nstatic void inet_diag_unlock_handler(const struct inet_diag_handler *handler)\n{\n\tmutex_unlock(&inet_diag_table_mutex);\n}\n\nvoid inet_diag_msg_common_fill(struct inet_diag_msg *r, struct sock *sk)\n{\n\tr->idiag_family = sk->sk_family;\n\n\tr->id.idiag_sport = htons(sk->sk_num);\n\tr->id.idiag_dport = sk->sk_dport;\n\tr->id.idiag_if = sk->sk_bound_dev_if;\n\tsock_diag_save_cookie(sk, r->id.idiag_cookie);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6) {\n\t\t*(struct in6_addr *)r->id.idiag_src = sk->sk_v6_rcv_saddr;\n\t\t*(struct in6_addr *)r->id.idiag_dst = sk->sk_v6_daddr;\n\t} else\n#endif\n\t{\n\tmemset(&r->id.idiag_src, 0, sizeof(r->id.idiag_src));\n\tmemset(&r->id.idiag_dst, 0, sizeof(r->id.idiag_dst));\n\n\tr->id.idiag_src[0] = sk->sk_rcv_saddr;\n\tr->id.idiag_dst[0] = sk->sk_daddr;\n\t}\n}\nEXPORT_SYMBOL_GPL(inet_diag_msg_common_fill);\n\nstatic size_t inet_sk_attr_size(struct sock *sk,\n\t\t\t\tconst struct inet_diag_req_v2 *req,\n\t\t\t\tbool net_admin)\n{\n\tconst struct inet_diag_handler *handler;\n\tsize_t aux = 0;\n\n\thandler = inet_diag_table[req->sdiag_protocol];\n\tif (handler && handler->idiag_get_aux_size)\n\t\taux = handler->idiag_get_aux_size(sk, net_admin);\n\n\treturn\t  nla_total_size(sizeof(struct tcp_info))\n\t\t+ nla_total_size(sizeof(struct inet_diag_msg))\n\t\t+ inet_diag_msg_attrs_size()\n\t\t+ nla_total_size(sizeof(struct inet_diag_meminfo))\n\t\t+ nla_total_size(SK_MEMINFO_VARS * sizeof(u32))\n\t\t+ nla_total_size(TCP_CA_NAME_MAX)\n\t\t+ nla_total_size(sizeof(struct tcpvegas_info))\n\t\t+ aux\n\t\t+ 64;\n}\n\nint inet_diag_msg_attrs_fill(struct sock *sk, struct sk_buff *skb,\n\t\t\t     struct inet_diag_msg *r, int ext,\n\t\t\t     struct user_namespace *user_ns,\n\t\t\t     bool net_admin)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tstruct inet_diag_sockopt inet_sockopt;\n\n\tif (nla_put_u8(skb, INET_DIAG_SHUTDOWN, sk->sk_shutdown))\n\t\tgoto errout;\n\n\t \n\tif (ext & (1 << (INET_DIAG_TOS - 1)))\n\t\tif (nla_put_u8(skb, INET_DIAG_TOS, inet->tos) < 0)\n\t\t\tgoto errout;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (r->idiag_family == AF_INET6) {\n\t\tif (ext & (1 << (INET_DIAG_TCLASS - 1)))\n\t\t\tif (nla_put_u8(skb, INET_DIAG_TCLASS,\n\t\t\t\t       inet6_sk(sk)->tclass) < 0)\n\t\t\t\tgoto errout;\n\n\t\tif (((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    nla_put_u8(skb, INET_DIAG_SKV6ONLY, ipv6_only_sock(sk)))\n\t\t\tgoto errout;\n\t}\n#endif\n\n\tif (net_admin && nla_put_u32(skb, INET_DIAG_MARK, READ_ONCE(sk->sk_mark)))\n\t\tgoto errout;\n\n\tif (ext & (1 << (INET_DIAG_CLASS_ID - 1)) ||\n\t    ext & (1 << (INET_DIAG_TCLASS - 1))) {\n\t\tu32 classid = 0;\n\n#ifdef CONFIG_SOCK_CGROUP_DATA\n\t\tclassid = sock_cgroup_classid(&sk->sk_cgrp_data);\n#endif\n\t\t \n\t\tif (!classid)\n\t\t\tclassid = sk->sk_priority;\n\n\t\tif (nla_put_u32(skb, INET_DIAG_CLASS_ID, classid))\n\t\t\tgoto errout;\n\t}\n\n#ifdef CONFIG_SOCK_CGROUP_DATA\n\tif (nla_put_u64_64bit(skb, INET_DIAG_CGROUP_ID,\n\t\t\t      cgroup_id(sock_cgroup_ptr(&sk->sk_cgrp_data)),\n\t\t\t      INET_DIAG_PAD))\n\t\tgoto errout;\n#endif\n\n\tr->idiag_uid = from_kuid_munged(user_ns, sock_i_uid(sk));\n\tr->idiag_inode = sock_i_ino(sk);\n\n\tmemset(&inet_sockopt, 0, sizeof(inet_sockopt));\n\tinet_sockopt.recverr\t= inet_test_bit(RECVERR, sk);\n\tinet_sockopt.is_icsk\t= inet_test_bit(IS_ICSK, sk);\n\tinet_sockopt.freebind\t= inet_test_bit(FREEBIND, sk);\n\tinet_sockopt.hdrincl\t= inet_test_bit(HDRINCL, sk);\n\tinet_sockopt.mc_loop\t= inet_test_bit(MC_LOOP, sk);\n\tinet_sockopt.transparent = inet_test_bit(TRANSPARENT, sk);\n\tinet_sockopt.mc_all\t= inet_test_bit(MC_ALL, sk);\n\tinet_sockopt.nodefrag\t= inet_test_bit(NODEFRAG, sk);\n\tinet_sockopt.bind_address_no_port = inet_test_bit(BIND_ADDRESS_NO_PORT, sk);\n\tinet_sockopt.recverr_rfc4884 = inet_test_bit(RECVERR_RFC4884, sk);\n\tinet_sockopt.defer_connect = inet_test_bit(DEFER_CONNECT, sk);\n\tif (nla_put(skb, INET_DIAG_SOCKOPT, sizeof(inet_sockopt),\n\t\t    &inet_sockopt))\n\t\tgoto errout;\n\n\treturn 0;\nerrout:\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(inet_diag_msg_attrs_fill);\n\nstatic int inet_diag_parse_attrs(const struct nlmsghdr *nlh, int hdrlen,\n\t\t\t\t struct nlattr **req_nlas)\n{\n\tstruct nlattr *nla;\n\tint remaining;\n\n\tnlmsg_for_each_attr(nla, nlh, hdrlen, remaining) {\n\t\tint type = nla_type(nla);\n\n\t\tif (type == INET_DIAG_REQ_PROTOCOL && nla_len(nla) != sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (type < __INET_DIAG_REQ_MAX)\n\t\t\treq_nlas[type] = nla;\n\t}\n\treturn 0;\n}\n\nstatic int inet_diag_get_protocol(const struct inet_diag_req_v2 *req,\n\t\t\t\t  const struct inet_diag_dump_data *data)\n{\n\tif (data->req_nlas[INET_DIAG_REQ_PROTOCOL])\n\t\treturn nla_get_u32(data->req_nlas[INET_DIAG_REQ_PROTOCOL]);\n\treturn req->sdiag_protocol;\n}\n\n#define MAX_DUMP_ALLOC_SIZE (KMALLOC_MAX_SIZE - SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))\n\nint inet_sk_diag_fill(struct sock *sk, struct inet_connection_sock *icsk,\n\t\t      struct sk_buff *skb, struct netlink_callback *cb,\n\t\t      const struct inet_diag_req_v2 *req,\n\t\t      u16 nlmsg_flags, bool net_admin)\n{\n\tconst struct tcp_congestion_ops *ca_ops;\n\tconst struct inet_diag_handler *handler;\n\tstruct inet_diag_dump_data *cb_data;\n\tint ext = req->idiag_ext;\n\tstruct inet_diag_msg *r;\n\tstruct nlmsghdr  *nlh;\n\tstruct nlattr *attr;\n\tvoid *info = NULL;\n\n\tcb_data = cb->data;\n\thandler = inet_diag_table[inet_diag_get_protocol(req, cb_data)];\n\tBUG_ON(!handler);\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\tcb->nlh->nlmsg_type, sizeof(*r), nlmsg_flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tr = nlmsg_data(nlh);\n\tBUG_ON(!sk_fullsock(sk));\n\n\tinet_diag_msg_common_fill(r, sk);\n\tr->idiag_state = sk->sk_state;\n\tr->idiag_timer = 0;\n\tr->idiag_retrans = 0;\n\tr->idiag_expires = 0;\n\n\tif (inet_diag_msg_attrs_fill(sk, skb, r, ext,\n\t\t\t\t     sk_user_ns(NETLINK_CB(cb->skb).sk),\n\t\t\t\t     net_admin))\n\t\tgoto errout;\n\n\tif (ext & (1 << (INET_DIAG_MEMINFO - 1))) {\n\t\tstruct inet_diag_meminfo minfo = {\n\t\t\t.idiag_rmem = sk_rmem_alloc_get(sk),\n\t\t\t.idiag_wmem = READ_ONCE(sk->sk_wmem_queued),\n\t\t\t.idiag_fmem = sk_forward_alloc_get(sk),\n\t\t\t.idiag_tmem = sk_wmem_alloc_get(sk),\n\t\t};\n\n\t\tif (nla_put(skb, INET_DIAG_MEMINFO, sizeof(minfo), &minfo) < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif (ext & (1 << (INET_DIAG_SKMEMINFO - 1)))\n\t\tif (sock_diag_put_meminfo(sk, skb, INET_DIAG_SKMEMINFO))\n\t\t\tgoto errout;\n\n\t \n\tif (sk->sk_type == SOCK_RAW) {\n\t\tif (nla_put_u8(skb, INET_DIAG_PROTOCOL, sk->sk_protocol))\n\t\t\tgoto errout;\n\t}\n\n\tif (!icsk) {\n\t\thandler->idiag_get_info(sk, r, NULL);\n\t\tgoto out;\n\t}\n\n\tif (icsk->icsk_pending == ICSK_TIME_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_REO_TIMEOUT ||\n\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\n\t\tr->idiag_timer = 1;\n\t\tr->idiag_retrans = icsk->icsk_retransmits;\n\t\tr->idiag_expires =\n\t\t\tjiffies_delta_to_msecs(icsk->icsk_timeout - jiffies);\n\t} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {\n\t\tr->idiag_timer = 4;\n\t\tr->idiag_retrans = icsk->icsk_probes_out;\n\t\tr->idiag_expires =\n\t\t\tjiffies_delta_to_msecs(icsk->icsk_timeout - jiffies);\n\t} else if (timer_pending(&sk->sk_timer)) {\n\t\tr->idiag_timer = 2;\n\t\tr->idiag_retrans = icsk->icsk_probes_out;\n\t\tr->idiag_expires =\n\t\t\tjiffies_delta_to_msecs(sk->sk_timer.expires - jiffies);\n\t}\n\n\tif ((ext & (1 << (INET_DIAG_INFO - 1))) && handler->idiag_info_size) {\n\t\tattr = nla_reserve_64bit(skb, INET_DIAG_INFO,\n\t\t\t\t\t handler->idiag_info_size,\n\t\t\t\t\t INET_DIAG_PAD);\n\t\tif (!attr)\n\t\t\tgoto errout;\n\n\t\tinfo = nla_data(attr);\n\t}\n\n\tif (ext & (1 << (INET_DIAG_CONG - 1))) {\n\t\tint err = 0;\n\n\t\trcu_read_lock();\n\t\tca_ops = READ_ONCE(icsk->icsk_ca_ops);\n\t\tif (ca_ops)\n\t\t\terr = nla_put_string(skb, INET_DIAG_CONG, ca_ops->name);\n\t\trcu_read_unlock();\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\thandler->idiag_get_info(sk, r, info);\n\n\tif (ext & (1 << (INET_DIAG_INFO - 1)) && handler->idiag_get_aux)\n\t\tif (handler->idiag_get_aux(sk, net_admin, skb) < 0)\n\t\t\tgoto errout;\n\n\tif (sk->sk_state < TCP_TIME_WAIT) {\n\t\tunion tcp_cc_info info;\n\t\tsize_t sz = 0;\n\t\tint attr;\n\n\t\trcu_read_lock();\n\t\tca_ops = READ_ONCE(icsk->icsk_ca_ops);\n\t\tif (ca_ops && ca_ops->get_info)\n\t\t\tsz = ca_ops->get_info(sk, ext, &attr, &info);\n\t\trcu_read_unlock();\n\t\tif (sz && nla_put(skb, attr, sz, &info) < 0)\n\t\t\tgoto errout;\n\t}\n\n\t \n\tif (cb_data->bpf_stg_diag) {\n\t\tbool first_nlmsg = ((unsigned char *)nlh == skb->data);\n\t\tunsigned int prev_min_dump_alloc;\n\t\tunsigned int total_nla_size = 0;\n\t\tunsigned int msg_len;\n\t\tint err;\n\n\t\tmsg_len = skb_tail_pointer(skb) - (unsigned char *)nlh;\n\t\terr = bpf_sk_storage_diag_put(cb_data->bpf_stg_diag, sk, skb,\n\t\t\t\t\t      INET_DIAG_SK_BPF_STORAGES,\n\t\t\t\t\t      &total_nla_size);\n\n\t\tif (!err)\n\t\t\tgoto out;\n\n\t\ttotal_nla_size += msg_len;\n\t\tprev_min_dump_alloc = cb->min_dump_alloc;\n\t\tif (total_nla_size > prev_min_dump_alloc)\n\t\t\tcb->min_dump_alloc = min_t(u32, total_nla_size,\n\t\t\t\t\t\t   MAX_DUMP_ALLOC_SIZE);\n\n\t\tif (!first_nlmsg)\n\t\t\tgoto errout;\n\n\t\tif (cb->min_dump_alloc > prev_min_dump_alloc)\n\t\t\t \n\t\t\tgoto errout;\n\n\t\tWARN_ON_ONCE(total_nla_size <= prev_min_dump_alloc);\n\n\t\t \n\t}\n\nout:\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nerrout:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL_GPL(inet_sk_diag_fill);\n\nstatic int inet_twsk_diag_fill(struct sock *sk,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb,\n\t\t\t       u16 nlmsg_flags, bool net_admin)\n{\n\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\tstruct inet_diag_msg *r;\n\tstruct nlmsghdr *nlh;\n\tlong tmo;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\tcb->nlh->nlmsg_seq, cb->nlh->nlmsg_type,\n\t\t\tsizeof(*r), nlmsg_flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tr = nlmsg_data(nlh);\n\tBUG_ON(tw->tw_state != TCP_TIME_WAIT);\n\n\tinet_diag_msg_common_fill(r, sk);\n\tr->idiag_retrans      = 0;\n\n\tr->idiag_state\t      = tw->tw_substate;\n\tr->idiag_timer\t      = 3;\n\ttmo = tw->tw_timer.expires - jiffies;\n\tr->idiag_expires      = jiffies_delta_to_msecs(tmo);\n\tr->idiag_rqueue\t      = 0;\n\tr->idiag_wqueue\t      = 0;\n\tr->idiag_uid\t      = 0;\n\tr->idiag_inode\t      = 0;\n\n\tif (net_admin && nla_put_u32(skb, INET_DIAG_MARK,\n\t\t\t\t     tw->tw_mark)) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int inet_req_diag_fill(struct sock *sk, struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb,\n\t\t\t      u16 nlmsg_flags, bool net_admin)\n{\n\tstruct request_sock *reqsk = inet_reqsk(sk);\n\tstruct inet_diag_msg *r;\n\tstruct nlmsghdr *nlh;\n\tlong tmo;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\tcb->nlh->nlmsg_type, sizeof(*r), nlmsg_flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tr = nlmsg_data(nlh);\n\tinet_diag_msg_common_fill(r, sk);\n\tr->idiag_state = TCP_SYN_RECV;\n\tr->idiag_timer = 1;\n\tr->idiag_retrans = reqsk->num_retrans;\n\n\tBUILD_BUG_ON(offsetof(struct inet_request_sock, ir_cookie) !=\n\t\t     offsetof(struct sock, sk_cookie));\n\n\ttmo = inet_reqsk(sk)->rsk_timer.expires - jiffies;\n\tr->idiag_expires = jiffies_delta_to_msecs(tmo);\n\tr->idiag_rqueue\t= 0;\n\tr->idiag_wqueue\t= 0;\n\tr->idiag_uid\t= 0;\n\tr->idiag_inode\t= 0;\n\n\tif (net_admin && nla_put_u32(skb, INET_DIAG_MARK,\n\t\t\t\t     inet_rsk(reqsk)->ir_mark)) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int sk_diag_fill(struct sock *sk, struct sk_buff *skb,\n\t\t\tstruct netlink_callback *cb,\n\t\t\tconst struct inet_diag_req_v2 *r,\n\t\t\tu16 nlmsg_flags, bool net_admin)\n{\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\treturn inet_twsk_diag_fill(sk, skb, cb, nlmsg_flags, net_admin);\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\treturn inet_req_diag_fill(sk, skb, cb, nlmsg_flags, net_admin);\n\n\treturn inet_sk_diag_fill(sk, inet_csk(sk), skb, cb, r, nlmsg_flags,\n\t\t\t\t net_admin);\n}\n\nstruct sock *inet_diag_find_one_icsk(struct net *net,\n\t\t\t\t     struct inet_hashinfo *hashinfo,\n\t\t\t\t     const struct inet_diag_req_v2 *req)\n{\n\tstruct sock *sk;\n\n\trcu_read_lock();\n\tif (req->sdiag_family == AF_INET)\n\t\tsk = inet_lookup(net, hashinfo, NULL, 0, req->id.idiag_dst[0],\n\t\t\t\t req->id.idiag_dport, req->id.idiag_src[0],\n\t\t\t\t req->id.idiag_sport, req->id.idiag_if);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (req->sdiag_family == AF_INET6) {\n\t\tif (ipv6_addr_v4mapped((struct in6_addr *)req->id.idiag_dst) &&\n\t\t    ipv6_addr_v4mapped((struct in6_addr *)req->id.idiag_src))\n\t\t\tsk = inet_lookup(net, hashinfo, NULL, 0, req->id.idiag_dst[3],\n\t\t\t\t\t req->id.idiag_dport, req->id.idiag_src[3],\n\t\t\t\t\t req->id.idiag_sport, req->id.idiag_if);\n\t\telse\n\t\t\tsk = inet6_lookup(net, hashinfo, NULL, 0,\n\t\t\t\t\t  (struct in6_addr *)req->id.idiag_dst,\n\t\t\t\t\t  req->id.idiag_dport,\n\t\t\t\t\t  (struct in6_addr *)req->id.idiag_src,\n\t\t\t\t\t  req->id.idiag_sport,\n\t\t\t\t\t  req->id.idiag_if);\n\t}\n#endif\n\telse {\n\t\trcu_read_unlock();\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\trcu_read_unlock();\n\tif (!sk)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (sock_diag_check_cookie(sk, req->id.idiag_cookie)) {\n\t\tsock_gen_put(sk);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(inet_diag_find_one_icsk);\n\nint inet_diag_dump_one_icsk(struct inet_hashinfo *hashinfo,\n\t\t\t    struct netlink_callback *cb,\n\t\t\t    const struct inet_diag_req_v2 *req)\n{\n\tstruct sk_buff *in_skb = cb->skb;\n\tbool net_admin = netlink_net_capable(in_skb, CAP_NET_ADMIN);\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct sk_buff *rep;\n\tstruct sock *sk;\n\tint err;\n\n\tsk = inet_diag_find_one_icsk(net, hashinfo, req);\n\tif (IS_ERR(sk))\n\t\treturn PTR_ERR(sk);\n\n\trep = nlmsg_new(inet_sk_attr_size(sk, req, net_admin), GFP_KERNEL);\n\tif (!rep) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = sk_diag_fill(sk, rep, cb, req, 0, net_admin);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tnlmsg_free(rep);\n\t\tgoto out;\n\t}\n\terr = nlmsg_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid);\n\nout:\n\tif (sk)\n\t\tsock_gen_put(sk);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(inet_diag_dump_one_icsk);\n\nstatic int inet_diag_cmd_exact(int cmd, struct sk_buff *in_skb,\n\t\t\t       const struct nlmsghdr *nlh,\n\t\t\t       int hdrlen,\n\t\t\t       const struct inet_diag_req_v2 *req)\n{\n\tconst struct inet_diag_handler *handler;\n\tstruct inet_diag_dump_data dump_data;\n\tint err, protocol;\n\n\tmemset(&dump_data, 0, sizeof(dump_data));\n\terr = inet_diag_parse_attrs(nlh, hdrlen, dump_data.req_nlas);\n\tif (err)\n\t\treturn err;\n\n\tprotocol = inet_diag_get_protocol(req, &dump_data);\n\n\thandler = inet_diag_lock_handler(protocol);\n\tif (IS_ERR(handler)) {\n\t\terr = PTR_ERR(handler);\n\t} else if (cmd == SOCK_DIAG_BY_FAMILY) {\n\t\tstruct netlink_callback cb = {\n\t\t\t.nlh = nlh,\n\t\t\t.skb = in_skb,\n\t\t\t.data = &dump_data,\n\t\t};\n\t\terr = handler->dump_one(&cb, req);\n\t} else if (cmd == SOCK_DESTROY && handler->destroy) {\n\t\terr = handler->destroy(in_skb, req);\n\t} else {\n\t\terr = -EOPNOTSUPP;\n\t}\n\tinet_diag_unlock_handler(handler);\n\n\treturn err;\n}\n\nstatic int bitstring_match(const __be32 *a1, const __be32 *a2, int bits)\n{\n\tint words = bits >> 5;\n\n\tbits &= 0x1f;\n\n\tif (words) {\n\t\tif (memcmp(a1, a2, words << 2))\n\t\t\treturn 0;\n\t}\n\tif (bits) {\n\t\t__be32 w1, w2;\n\t\t__be32 mask;\n\n\t\tw1 = a1[words];\n\t\tw2 = a2[words];\n\n\t\tmask = htonl((0xffffffff) << (32 - bits));\n\n\t\tif ((w1 ^ w2) & mask)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int inet_diag_bc_run(const struct nlattr *_bc,\n\t\t\t    const struct inet_diag_entry *entry)\n{\n\tconst void *bc = nla_data(_bc);\n\tint len = nla_len(_bc);\n\n\twhile (len > 0) {\n\t\tint yes = 1;\n\t\tconst struct inet_diag_bc_op *op = bc;\n\n\t\tswitch (op->code) {\n\t\tcase INET_DIAG_BC_NOP:\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_JMP:\n\t\t\tyes = 0;\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_S_EQ:\n\t\t\tyes = entry->sport == op[1].no;\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_S_GE:\n\t\t\tyes = entry->sport >= op[1].no;\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_S_LE:\n\t\t\tyes = entry->sport <= op[1].no;\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_D_EQ:\n\t\t\tyes = entry->dport == op[1].no;\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_D_GE:\n\t\t\tyes = entry->dport >= op[1].no;\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_D_LE:\n\t\t\tyes = entry->dport <= op[1].no;\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_AUTO:\n\t\t\tyes = !(entry->userlocks & SOCK_BINDPORT_LOCK);\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_S_COND:\n\t\tcase INET_DIAG_BC_D_COND: {\n\t\t\tconst struct inet_diag_hostcond *cond;\n\t\t\tconst __be32 *addr;\n\n\t\t\tcond = (const struct inet_diag_hostcond *)(op + 1);\n\t\t\tif (cond->port != -1 &&\n\t\t\t    cond->port != (op->code == INET_DIAG_BC_S_COND ?\n\t\t\t\t\t     entry->sport : entry->dport)) {\n\t\t\t\tyes = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (op->code == INET_DIAG_BC_S_COND)\n\t\t\t\taddr = entry->saddr;\n\t\t\telse\n\t\t\t\taddr = entry->daddr;\n\n\t\t\tif (cond->family != AF_UNSPEC &&\n\t\t\t    cond->family != entry->family) {\n\t\t\t\tif (entry->family == AF_INET6 &&\n\t\t\t\t    cond->family == AF_INET) {\n\t\t\t\t\tif (addr[0] == 0 && addr[1] == 0 &&\n\t\t\t\t\t    addr[2] == htonl(0xffff) &&\n\t\t\t\t\t    bitstring_match(addr + 3,\n\t\t\t\t\t\t\t    cond->addr,\n\t\t\t\t\t\t\t    cond->prefix_len))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tyes = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (cond->prefix_len == 0)\n\t\t\t\tbreak;\n\t\t\tif (bitstring_match(addr, cond->addr,\n\t\t\t\t\t    cond->prefix_len))\n\t\t\t\tbreak;\n\t\t\tyes = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcase INET_DIAG_BC_DEV_COND: {\n\t\t\tu32 ifindex;\n\n\t\t\tifindex = *((const u32 *)(op + 1));\n\t\t\tif (ifindex != entry->ifindex)\n\t\t\t\tyes = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcase INET_DIAG_BC_MARK_COND: {\n\t\t\tstruct inet_diag_markcond *cond;\n\n\t\t\tcond = (struct inet_diag_markcond *)(op + 1);\n\t\t\tif ((entry->mark & cond->mask) != cond->mark)\n\t\t\t\tyes = 0;\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_SOCK_CGROUP_DATA\n\t\tcase INET_DIAG_BC_CGROUP_COND: {\n\t\t\tu64 cgroup_id;\n\n\t\t\tcgroup_id = get_unaligned((const u64 *)(op + 1));\n\t\t\tif (cgroup_id != entry->cgroup_id)\n\t\t\t\tyes = 0;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\t}\n\n\t\tif (yes) {\n\t\t\tlen -= op->yes;\n\t\t\tbc += op->yes;\n\t\t} else {\n\t\t\tlen -= op->no;\n\t\t\tbc += op->no;\n\t\t}\n\t}\n\treturn len == 0;\n}\n\n \nstatic void entry_fill_addrs(struct inet_diag_entry *entry,\n\t\t\t     const struct sock *sk)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6) {\n\t\tentry->saddr = sk->sk_v6_rcv_saddr.s6_addr32;\n\t\tentry->daddr = sk->sk_v6_daddr.s6_addr32;\n\t} else\n#endif\n\t{\n\t\tentry->saddr = &sk->sk_rcv_saddr;\n\t\tentry->daddr = &sk->sk_daddr;\n\t}\n}\n\nint inet_diag_bc_sk(const struct nlattr *bc, struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_diag_entry entry;\n\n\tif (!bc)\n\t\treturn 1;\n\n\tentry.family = sk->sk_family;\n\tentry_fill_addrs(&entry, sk);\n\tentry.sport = inet->inet_num;\n\tentry.dport = ntohs(inet->inet_dport);\n\tentry.ifindex = sk->sk_bound_dev_if;\n\tentry.userlocks = sk_fullsock(sk) ? sk->sk_userlocks : 0;\n\tif (sk_fullsock(sk))\n\t\tentry.mark = READ_ONCE(sk->sk_mark);\n\telse if (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tentry.mark = inet_rsk(inet_reqsk(sk))->ir_mark;\n\telse if (sk->sk_state == TCP_TIME_WAIT)\n\t\tentry.mark = inet_twsk(sk)->tw_mark;\n\telse\n\t\tentry.mark = 0;\n#ifdef CONFIG_SOCK_CGROUP_DATA\n\tentry.cgroup_id = sk_fullsock(sk) ?\n\t\tcgroup_id(sock_cgroup_ptr(&sk->sk_cgrp_data)) : 0;\n#endif\n\n\treturn inet_diag_bc_run(bc, &entry);\n}\nEXPORT_SYMBOL_GPL(inet_diag_bc_sk);\n\nstatic int valid_cc(const void *bc, int len, int cc)\n{\n\twhile (len >= 0) {\n\t\tconst struct inet_diag_bc_op *op = bc;\n\n\t\tif (cc > len)\n\t\t\treturn 0;\n\t\tif (cc == len)\n\t\t\treturn 1;\n\t\tif (op->yes < 4 || op->yes & 3)\n\t\t\treturn 0;\n\t\tlen -= op->yes;\n\t\tbc  += op->yes;\n\t}\n\treturn 0;\n}\n\n \nstatic bool valid_devcond(const struct inet_diag_bc_op *op, int len,\n\t\t\t  int *min_len)\n{\n\t \n\t*min_len += sizeof(u32);\n\tif (len < *min_len)\n\t\treturn false;\n\n\treturn true;\n}\n \nstatic bool valid_hostcond(const struct inet_diag_bc_op *op, int len,\n\t\t\t   int *min_len)\n{\n\tstruct inet_diag_hostcond *cond;\n\tint addr_len;\n\n\t \n\t*min_len += sizeof(struct inet_diag_hostcond);\n\tif (len < *min_len)\n\t\treturn false;\n\tcond = (struct inet_diag_hostcond *)(op + 1);\n\n\t \n\tswitch (cond->family) {\n\tcase AF_UNSPEC:\n\t\taddr_len = 0;\n\t\tbreak;\n\tcase AF_INET:\n\t\taddr_len = sizeof(struct in_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taddr_len = sizeof(struct in6_addr);\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\t*min_len += addr_len;\n\tif (len < *min_len)\n\t\treturn false;\n\n\t \n\tif (cond->prefix_len > 8 * addr_len)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool valid_port_comparison(const struct inet_diag_bc_op *op,\n\t\t\t\t  int len, int *min_len)\n{\n\t \n\t*min_len += sizeof(struct inet_diag_bc_op);\n\tif (len < *min_len)\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool valid_markcond(const struct inet_diag_bc_op *op, int len,\n\t\t\t   int *min_len)\n{\n\t*min_len += sizeof(struct inet_diag_markcond);\n\treturn len >= *min_len;\n}\n\n#ifdef CONFIG_SOCK_CGROUP_DATA\nstatic bool valid_cgroupcond(const struct inet_diag_bc_op *op, int len,\n\t\t\t     int *min_len)\n{\n\t*min_len += sizeof(u64);\n\treturn len >= *min_len;\n}\n#endif\n\nstatic int inet_diag_bc_audit(const struct nlattr *attr,\n\t\t\t      const struct sk_buff *skb)\n{\n\tbool net_admin = netlink_net_capable(skb, CAP_NET_ADMIN);\n\tconst void *bytecode, *bc;\n\tint bytecode_len, len;\n\n\tif (!attr || nla_len(attr) < sizeof(struct inet_diag_bc_op))\n\t\treturn -EINVAL;\n\n\tbytecode = bc = nla_data(attr);\n\tlen = bytecode_len = nla_len(attr);\n\n\twhile (len > 0) {\n\t\tint min_len = sizeof(struct inet_diag_bc_op);\n\t\tconst struct inet_diag_bc_op *op = bc;\n\n\t\tswitch (op->code) {\n\t\tcase INET_DIAG_BC_S_COND:\n\t\tcase INET_DIAG_BC_D_COND:\n\t\t\tif (!valid_hostcond(bc, len, &min_len))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_DEV_COND:\n\t\t\tif (!valid_devcond(bc, len, &min_len))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_S_EQ:\n\t\tcase INET_DIAG_BC_S_GE:\n\t\tcase INET_DIAG_BC_S_LE:\n\t\tcase INET_DIAG_BC_D_EQ:\n\t\tcase INET_DIAG_BC_D_GE:\n\t\tcase INET_DIAG_BC_D_LE:\n\t\t\tif (!valid_port_comparison(bc, len, &min_len))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_MARK_COND:\n\t\t\tif (!net_admin)\n\t\t\t\treturn -EPERM;\n\t\t\tif (!valid_markcond(bc, len, &min_len))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n#ifdef CONFIG_SOCK_CGROUP_DATA\n\t\tcase INET_DIAG_BC_CGROUP_COND:\n\t\t\tif (!valid_cgroupcond(bc, len, &min_len))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n#endif\n\t\tcase INET_DIAG_BC_AUTO:\n\t\tcase INET_DIAG_BC_JMP:\n\t\tcase INET_DIAG_BC_NOP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (op->code != INET_DIAG_BC_NOP) {\n\t\t\tif (op->no < min_len || op->no > len + 4 || op->no & 3)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (op->no < len &&\n\t\t\t    !valid_cc(bytecode, bytecode_len, len - op->no))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (op->yes < min_len || op->yes > len + 4 || op->yes & 3)\n\t\t\treturn -EINVAL;\n\t\tbc  += op->yes;\n\t\tlen -= op->yes;\n\t}\n\treturn len == 0 ? 0 : -EINVAL;\n}\n\nstatic void twsk_build_assert(void)\n{\n\tBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_family) !=\n\t\t     offsetof(struct sock, sk_family));\n\n\tBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_num) !=\n\t\t     offsetof(struct inet_sock, inet_num));\n\n\tBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_dport) !=\n\t\t     offsetof(struct inet_sock, inet_dport));\n\n\tBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_rcv_saddr) !=\n\t\t     offsetof(struct inet_sock, inet_rcv_saddr));\n\n\tBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_daddr) !=\n\t\t     offsetof(struct inet_sock, inet_daddr));\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_v6_rcv_saddr) !=\n\t\t     offsetof(struct sock, sk_v6_rcv_saddr));\n\n\tBUILD_BUG_ON(offsetof(struct inet_timewait_sock, tw_v6_daddr) !=\n\t\t     offsetof(struct sock, sk_v6_daddr));\n#endif\n}\n\nvoid inet_diag_dump_icsk(struct inet_hashinfo *hashinfo, struct sk_buff *skb,\n\t\t\t struct netlink_callback *cb,\n\t\t\t const struct inet_diag_req_v2 *r)\n{\n\tbool net_admin = netlink_net_capable(cb->skb, CAP_NET_ADMIN);\n\tstruct inet_diag_dump_data *cb_data = cb->data;\n\tstruct net *net = sock_net(skb->sk);\n\tu32 idiag_states = r->idiag_states;\n\tint i, num, s_i, s_num;\n\tstruct nlattr *bc;\n\tstruct sock *sk;\n\n\tbc = cb_data->inet_diag_nla_bc;\n\tif (idiag_states & TCPF_SYN_RECV)\n\t\tidiag_states |= TCPF_NEW_SYN_RECV;\n\ts_i = cb->args[1];\n\ts_num = num = cb->args[2];\n\n\tif (cb->args[0] == 0) {\n\t\tif (!(idiag_states & TCPF_LISTEN) || r->id.idiag_dport)\n\t\t\tgoto skip_listen_ht;\n\n\t\tfor (i = s_i; i <= hashinfo->lhash2_mask; i++) {\n\t\t\tstruct inet_listen_hashbucket *ilb;\n\t\t\tstruct hlist_nulls_node *node;\n\n\t\t\tnum = 0;\n\t\t\tilb = &hashinfo->lhash2[i];\n\n\t\t\tspin_lock(&ilb->lock);\n\t\t\tsk_nulls_for_each(sk, node, &ilb->nulls_head) {\n\t\t\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\t\t\tif (!net_eq(sock_net(sk), net))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (num < s_num) {\n\t\t\t\t\tnum++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (r->sdiag_family != AF_UNSPEC &&\n\t\t\t\t    sk->sk_family != r->sdiag_family)\n\t\t\t\t\tgoto next_listen;\n\n\t\t\t\tif (r->id.idiag_sport != inet->inet_sport &&\n\t\t\t\t    r->id.idiag_sport)\n\t\t\t\t\tgoto next_listen;\n\n\t\t\t\tif (!inet_diag_bc_sk(bc, sk))\n\t\t\t\t\tgoto next_listen;\n\n\t\t\t\tif (inet_sk_diag_fill(sk, inet_csk(sk), skb,\n\t\t\t\t\t\t      cb, r, NLM_F_MULTI,\n\t\t\t\t\t\t      net_admin) < 0) {\n\t\t\t\t\tspin_unlock(&ilb->lock);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\nnext_listen:\n\t\t\t\t++num;\n\t\t\t}\n\t\t\tspin_unlock(&ilb->lock);\n\n\t\t\ts_num = 0;\n\t\t}\nskip_listen_ht:\n\t\tcb->args[0] = 1;\n\t\ts_i = num = s_num = 0;\n\t}\n\n\tif (!(idiag_states & ~TCPF_LISTEN))\n\t\tgoto out;\n\n#define SKARR_SZ 16\n\tfor (i = s_i; i <= hashinfo->ehash_mask; i++) {\n\t\tstruct inet_ehash_bucket *head = &hashinfo->ehash[i];\n\t\tspinlock_t *lock = inet_ehash_lockp(hashinfo, i);\n\t\tstruct hlist_nulls_node *node;\n\t\tstruct sock *sk_arr[SKARR_SZ];\n\t\tint num_arr[SKARR_SZ];\n\t\tint idx, accum, res;\n\n\t\tif (hlist_nulls_empty(&head->chain))\n\t\t\tcontinue;\n\n\t\tif (i > s_i)\n\t\t\ts_num = 0;\n\nnext_chunk:\n\t\tnum = 0;\n\t\taccum = 0;\n\t\tspin_lock_bh(lock);\n\t\tsk_nulls_for_each(sk, node, &head->chain) {\n\t\t\tint state;\n\n\t\t\tif (!net_eq(sock_net(sk), net))\n\t\t\t\tcontinue;\n\t\t\tif (num < s_num)\n\t\t\t\tgoto next_normal;\n\t\t\tstate = (sk->sk_state == TCP_TIME_WAIT) ?\n\t\t\t\tinet_twsk(sk)->tw_substate : sk->sk_state;\n\t\t\tif (!(idiag_states & (1 << state)))\n\t\t\t\tgoto next_normal;\n\t\t\tif (r->sdiag_family != AF_UNSPEC &&\n\t\t\t    sk->sk_family != r->sdiag_family)\n\t\t\t\tgoto next_normal;\n\t\t\tif (r->id.idiag_sport != htons(sk->sk_num) &&\n\t\t\t    r->id.idiag_sport)\n\t\t\t\tgoto next_normal;\n\t\t\tif (r->id.idiag_dport != sk->sk_dport &&\n\t\t\t    r->id.idiag_dport)\n\t\t\t\tgoto next_normal;\n\t\t\ttwsk_build_assert();\n\n\t\t\tif (!inet_diag_bc_sk(bc, sk))\n\t\t\t\tgoto next_normal;\n\n\t\t\tif (!refcount_inc_not_zero(&sk->sk_refcnt))\n\t\t\t\tgoto next_normal;\n\n\t\t\tnum_arr[accum] = num;\n\t\t\tsk_arr[accum] = sk;\n\t\t\tif (++accum == SKARR_SZ)\n\t\t\t\tbreak;\nnext_normal:\n\t\t\t++num;\n\t\t}\n\t\tspin_unlock_bh(lock);\n\t\tres = 0;\n\t\tfor (idx = 0; idx < accum; idx++) {\n\t\t\tif (res >= 0) {\n\t\t\t\tres = sk_diag_fill(sk_arr[idx], skb, cb, r,\n\t\t\t\t\t\t   NLM_F_MULTI, net_admin);\n\t\t\t\tif (res < 0)\n\t\t\t\t\tnum = num_arr[idx];\n\t\t\t}\n\t\t\tsock_gen_put(sk_arr[idx]);\n\t\t}\n\t\tif (res < 0)\n\t\t\tbreak;\n\t\tcond_resched();\n\t\tif (accum == SKARR_SZ) {\n\t\t\ts_num = num + 1;\n\t\t\tgoto next_chunk;\n\t\t}\n\t}\n\ndone:\n\tcb->args[1] = i;\n\tcb->args[2] = num;\nout:\n\t;\n}\nEXPORT_SYMBOL_GPL(inet_diag_dump_icsk);\n\nstatic int __inet_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t    const struct inet_diag_req_v2 *r)\n{\n\tstruct inet_diag_dump_data *cb_data = cb->data;\n\tconst struct inet_diag_handler *handler;\n\tu32 prev_min_dump_alloc;\n\tint protocol, err = 0;\n\n\tprotocol = inet_diag_get_protocol(r, cb_data);\n\nagain:\n\tprev_min_dump_alloc = cb->min_dump_alloc;\n\thandler = inet_diag_lock_handler(protocol);\n\tif (!IS_ERR(handler))\n\t\thandler->dump(skb, cb, r);\n\telse\n\t\terr = PTR_ERR(handler);\n\tinet_diag_unlock_handler(handler);\n\n\t \n\tif (!skb->len && cb->min_dump_alloc > prev_min_dump_alloc) {\n\t\terr = pskb_expand_head(skb, 0, cb->min_dump_alloc, GFP_KERNEL);\n\t\tif (!err)\n\t\t\tgoto again;\n\t}\n\n\treturn err ? : skb->len;\n}\n\nstatic int inet_diag_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\treturn __inet_diag_dump(skb, cb, nlmsg_data(cb->nlh));\n}\n\nstatic int __inet_diag_dump_start(struct netlink_callback *cb, int hdrlen)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct inet_diag_dump_data *cb_data;\n\tstruct sk_buff *skb = cb->skb;\n\tstruct nlattr *nla;\n\tint err;\n\n\tcb_data = kzalloc(sizeof(*cb_data), GFP_KERNEL);\n\tif (!cb_data)\n\t\treturn -ENOMEM;\n\n\terr = inet_diag_parse_attrs(nlh, hdrlen, cb_data->req_nlas);\n\tif (err) {\n\t\tkfree(cb_data);\n\t\treturn err;\n\t}\n\tnla = cb_data->inet_diag_nla_bc;\n\tif (nla) {\n\t\terr = inet_diag_bc_audit(nla, skb);\n\t\tif (err) {\n\t\t\tkfree(cb_data);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tnla = cb_data->inet_diag_nla_bpf_stgs;\n\tif (nla) {\n\t\tstruct bpf_sk_storage_diag *bpf_stg_diag;\n\n\t\tbpf_stg_diag = bpf_sk_storage_diag_alloc(nla);\n\t\tif (IS_ERR(bpf_stg_diag)) {\n\t\t\tkfree(cb_data);\n\t\t\treturn PTR_ERR(bpf_stg_diag);\n\t\t}\n\t\tcb_data->bpf_stg_diag = bpf_stg_diag;\n\t}\n\n\tcb->data = cb_data;\n\treturn 0;\n}\n\nstatic int inet_diag_dump_start(struct netlink_callback *cb)\n{\n\treturn __inet_diag_dump_start(cb, sizeof(struct inet_diag_req_v2));\n}\n\nstatic int inet_diag_dump_start_compat(struct netlink_callback *cb)\n{\n\treturn __inet_diag_dump_start(cb, sizeof(struct inet_diag_req));\n}\n\nstatic int inet_diag_dump_done(struct netlink_callback *cb)\n{\n\tstruct inet_diag_dump_data *cb_data = cb->data;\n\n\tbpf_sk_storage_diag_free(cb_data->bpf_stg_diag);\n\tkfree(cb->data);\n\n\treturn 0;\n}\n\nstatic int inet_diag_type2proto(int type)\n{\n\tswitch (type) {\n\tcase TCPDIAG_GETSOCK:\n\t\treturn IPPROTO_TCP;\n\tcase DCCPDIAG_GETSOCK:\n\t\treturn IPPROTO_DCCP;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int inet_diag_dump_compat(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct inet_diag_req *rc = nlmsg_data(cb->nlh);\n\tstruct inet_diag_req_v2 req;\n\n\treq.sdiag_family = AF_UNSPEC;  \n\treq.sdiag_protocol = inet_diag_type2proto(cb->nlh->nlmsg_type);\n\treq.idiag_ext = rc->idiag_ext;\n\treq.idiag_states = rc->idiag_states;\n\treq.id = rc->id;\n\n\treturn __inet_diag_dump(skb, cb, &req);\n}\n\nstatic int inet_diag_get_exact_compat(struct sk_buff *in_skb,\n\t\t\t\t      const struct nlmsghdr *nlh)\n{\n\tstruct inet_diag_req *rc = nlmsg_data(nlh);\n\tstruct inet_diag_req_v2 req;\n\n\treq.sdiag_family = rc->idiag_family;\n\treq.sdiag_protocol = inet_diag_type2proto(nlh->nlmsg_type);\n\treq.idiag_ext = rc->idiag_ext;\n\treq.idiag_states = rc->idiag_states;\n\treq.id = rc->id;\n\n\treturn inet_diag_cmd_exact(SOCK_DIAG_BY_FAMILY, in_skb, nlh,\n\t\t\t\t   sizeof(struct inet_diag_req), &req);\n}\n\nstatic int inet_diag_rcv_msg_compat(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint hdrlen = sizeof(struct inet_diag_req);\n\tstruct net *net = sock_net(skb->sk);\n\n\tif (nlh->nlmsg_type >= INET_DIAG_GETSOCK_MAX ||\n\t    nlmsg_len(nlh) < hdrlen)\n\t\treturn -EINVAL;\n\n\tif (nlh->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = inet_diag_dump_start_compat,\n\t\t\t.done = inet_diag_dump_done,\n\t\t\t.dump = inet_diag_dump_compat,\n\t\t};\n\t\treturn netlink_dump_start(net->diag_nlsk, skb, nlh, &c);\n\t}\n\n\treturn inet_diag_get_exact_compat(skb, nlh);\n}\n\nstatic int inet_diag_handler_cmd(struct sk_buff *skb, struct nlmsghdr *h)\n{\n\tint hdrlen = sizeof(struct inet_diag_req_v2);\n\tstruct net *net = sock_net(skb->sk);\n\n\tif (nlmsg_len(h) < hdrlen)\n\t\treturn -EINVAL;\n\n\tif (h->nlmsg_type == SOCK_DIAG_BY_FAMILY &&\n\t    h->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.start = inet_diag_dump_start,\n\t\t\t.done = inet_diag_dump_done,\n\t\t\t.dump = inet_diag_dump,\n\t\t};\n\t\treturn netlink_dump_start(net->diag_nlsk, skb, h, &c);\n\t}\n\n\treturn inet_diag_cmd_exact(h->nlmsg_type, skb, h, hdrlen,\n\t\t\t\t   nlmsg_data(h));\n}\n\nstatic\nint inet_diag_handler_get_info(struct sk_buff *skb, struct sock *sk)\n{\n\tconst struct inet_diag_handler *handler;\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *attr;\n\tstruct inet_diag_msg *r;\n\tvoid *info = NULL;\n\tint err = 0;\n\n\tnlh = nlmsg_put(skb, 0, 0, SOCK_DIAG_BY_FAMILY, sizeof(*r), 0);\n\tif (!nlh)\n\t\treturn -ENOMEM;\n\n\tr = nlmsg_data(nlh);\n\tmemset(r, 0, sizeof(*r));\n\tinet_diag_msg_common_fill(r, sk);\n\tif (sk->sk_type == SOCK_DGRAM || sk->sk_type == SOCK_STREAM)\n\t\tr->id.idiag_sport = inet_sk(sk)->inet_sport;\n\tr->idiag_state = sk->sk_state;\n\n\tif ((err = nla_put_u8(skb, INET_DIAG_PROTOCOL, sk->sk_protocol))) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\thandler = inet_diag_lock_handler(sk->sk_protocol);\n\tif (IS_ERR(handler)) {\n\t\tinet_diag_unlock_handler(handler);\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn PTR_ERR(handler);\n\t}\n\n\tattr = handler->idiag_info_size\n\t\t? nla_reserve_64bit(skb, INET_DIAG_INFO,\n\t\t\t\t    handler->idiag_info_size,\n\t\t\t\t    INET_DIAG_PAD)\n\t\t: NULL;\n\tif (attr)\n\t\tinfo = nla_data(attr);\n\n\thandler->idiag_get_info(sk, r, info);\n\tinet_diag_unlock_handler(handler);\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic const struct sock_diag_handler inet_diag_handler = {\n\t.family = AF_INET,\n\t.dump = inet_diag_handler_cmd,\n\t.get_info = inet_diag_handler_get_info,\n\t.destroy = inet_diag_handler_cmd,\n};\n\nstatic const struct sock_diag_handler inet6_diag_handler = {\n\t.family = AF_INET6,\n\t.dump = inet_diag_handler_cmd,\n\t.get_info = inet_diag_handler_get_info,\n\t.destroy = inet_diag_handler_cmd,\n};\n\nint inet_diag_register(const struct inet_diag_handler *h)\n{\n\tconst __u16 type = h->idiag_type;\n\tint err = -EINVAL;\n\n\tif (type >= IPPROTO_MAX)\n\t\tgoto out;\n\n\tmutex_lock(&inet_diag_table_mutex);\n\terr = -EEXIST;\n\tif (!inet_diag_table[type]) {\n\t\tinet_diag_table[type] = h;\n\t\terr = 0;\n\t}\n\tmutex_unlock(&inet_diag_table_mutex);\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(inet_diag_register);\n\nvoid inet_diag_unregister(const struct inet_diag_handler *h)\n{\n\tconst __u16 type = h->idiag_type;\n\n\tif (type >= IPPROTO_MAX)\n\t\treturn;\n\n\tmutex_lock(&inet_diag_table_mutex);\n\tinet_diag_table[type] = NULL;\n\tmutex_unlock(&inet_diag_table_mutex);\n}\nEXPORT_SYMBOL_GPL(inet_diag_unregister);\n\nstatic int __init inet_diag_init(void)\n{\n\tconst int inet_diag_table_size = (IPPROTO_MAX *\n\t\t\t\t\t  sizeof(struct inet_diag_handler *));\n\tint err = -ENOMEM;\n\n\tinet_diag_table = kzalloc(inet_diag_table_size, GFP_KERNEL);\n\tif (!inet_diag_table)\n\t\tgoto out;\n\n\terr = sock_diag_register(&inet_diag_handler);\n\tif (err)\n\t\tgoto out_free_nl;\n\n\terr = sock_diag_register(&inet6_diag_handler);\n\tif (err)\n\t\tgoto out_free_inet;\n\n\tsock_diag_register_inet_compat(inet_diag_rcv_msg_compat);\nout:\n\treturn err;\n\nout_free_inet:\n\tsock_diag_unregister(&inet_diag_handler);\nout_free_nl:\n\tkfree(inet_diag_table);\n\tgoto out;\n}\n\nstatic void __exit inet_diag_exit(void)\n{\n\tsock_diag_unregister(&inet6_diag_handler);\n\tsock_diag_unregister(&inet_diag_handler);\n\tsock_diag_unregister_inet_compat(inet_diag_rcv_msg_compat);\n\tkfree(inet_diag_table);\n}\n\nmodule_init(inet_diag_init);\nmodule_exit(inet_diag_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 2  );\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 10  );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}