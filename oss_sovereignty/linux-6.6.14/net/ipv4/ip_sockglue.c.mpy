{
  "module_name": "ip_sockglue.c",
  "hash_id": "f64a57584232845c77d22b61e89007576668cf6b618878e59b4db5afb4c14fdf",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ip_sockglue.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/icmp.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/tcp_states.h>\n#include <linux/udp.h>\n#include <linux/igmp.h>\n#include <linux/netfilter.h>\n#include <linux/route.h>\n#include <linux/mroute.h>\n#include <net/inet_ecn.h>\n#include <net/route.h>\n#include <net/xfrm.h>\n#include <net/compat.h>\n#include <net/checksum.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/transp_v6.h>\n#endif\n#include <net/ip_fib.h>\n\n#include <linux/errqueue.h>\n#include <linux/uaccess.h>\n\n#include <linux/bpfilter.h>\n\n \n\nstatic void ip_cmsg_recv_pktinfo(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct in_pktinfo info = *PKTINFO_SKB_CB(skb);\n\n\tinfo.ipi_addr.s_addr = ip_hdr(skb)->daddr;\n\n\tput_cmsg(msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);\n}\n\nstatic void ip_cmsg_recv_ttl(struct msghdr *msg, struct sk_buff *skb)\n{\n\tint ttl = ip_hdr(skb)->ttl;\n\tput_cmsg(msg, SOL_IP, IP_TTL, sizeof(int), &ttl);\n}\n\nstatic void ip_cmsg_recv_tos(struct msghdr *msg, struct sk_buff *skb)\n{\n\tput_cmsg(msg, SOL_IP, IP_TOS, 1, &ip_hdr(skb)->tos);\n}\n\nstatic void ip_cmsg_recv_opts(struct msghdr *msg, struct sk_buff *skb)\n{\n\tif (IPCB(skb)->opt.optlen == 0)\n\t\treturn;\n\n\tput_cmsg(msg, SOL_IP, IP_RECVOPTS, IPCB(skb)->opt.optlen,\n\t\t ip_hdr(skb) + 1);\n}\n\n\nstatic void ip_cmsg_recv_retopts(struct net *net, struct msghdr *msg,\n\t\t\t\t struct sk_buff *skb)\n{\n\tunsigned char optbuf[sizeof(struct ip_options) + 40];\n\tstruct ip_options *opt = (struct ip_options *)optbuf;\n\n\tif (IPCB(skb)->opt.optlen == 0)\n\t\treturn;\n\n\tif (ip_options_echo(net, opt, skb)) {\n\t\tmsg->msg_flags |= MSG_CTRUNC;\n\t\treturn;\n\t}\n\tip_options_undo(opt);\n\n\tput_cmsg(msg, SOL_IP, IP_RETOPTS, opt->optlen, opt->__data);\n}\n\nstatic void ip_cmsg_recv_fragsize(struct msghdr *msg, struct sk_buff *skb)\n{\n\tint val;\n\n\tif (IPCB(skb)->frag_max_size == 0)\n\t\treturn;\n\n\tval = IPCB(skb)->frag_max_size;\n\tput_cmsg(msg, SOL_IP, IP_RECVFRAGSIZE, sizeof(val), &val);\n}\n\nstatic void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\n\tif (offset != 0) {\n\t\tint tend_off = skb_transport_offset(skb) + tlen;\n\t\tcsum = csum_sub(csum, skb_checksum(skb, tend_off, offset, 0));\n\t}\n\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}\n\nstatic void ip_cmsg_recv_security(struct msghdr *msg, struct sk_buff *skb)\n{\n\tchar *secdata;\n\tu32 seclen, secid;\n\tint err;\n\n\terr = security_socket_getpeersec_dgram(NULL, skb, &secid);\n\tif (err)\n\t\treturn;\n\n\terr = security_secid_to_secctx(secid, &secdata, &seclen);\n\tif (err)\n\t\treturn;\n\n\tput_cmsg(msg, SOL_IP, SCM_SECURITY, seclen, secdata);\n\tsecurity_release_secctx(secdata, seclen);\n}\n\nstatic void ip_cmsg_recv_dstaddr(struct msghdr *msg, struct sk_buff *skb)\n{\n\t__be16 _ports[2], *ports;\n\tstruct sockaddr_in sin;\n\n\t \n\tports = skb_header_pointer(skb, skb_transport_offset(skb),\n\t\t\t\t   sizeof(_ports), &_ports);\n\tif (!ports)\n\t\treturn;\n\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = ip_hdr(skb)->daddr;\n\tsin.sin_port = ports[1];\n\tmemset(sin.sin_zero, 0, sizeof(sin.sin_zero));\n\n\tput_cmsg(msg, SOL_IP, IP_ORIGDSTADDR, sizeof(sin), &sin);\n}\n\nvoid ip_cmsg_recv_offset(struct msghdr *msg, struct sock *sk,\n\t\t\t struct sk_buff *skb, int tlen, int offset)\n{\n\tunsigned long flags = inet_cmsg_flags(inet_sk(sk));\n\n\tif (!flags)\n\t\treturn;\n\n\t \n\tif (flags & IP_CMSG_PKTINFO) {\n\t\tip_cmsg_recv_pktinfo(msg, skb);\n\n\t\tflags &= ~IP_CMSG_PKTINFO;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_TTL) {\n\t\tip_cmsg_recv_ttl(msg, skb);\n\n\t\tflags &= ~IP_CMSG_TTL;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_TOS) {\n\t\tip_cmsg_recv_tos(msg, skb);\n\n\t\tflags &= ~IP_CMSG_TOS;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_RECVOPTS) {\n\t\tip_cmsg_recv_opts(msg, skb);\n\n\t\tflags &= ~IP_CMSG_RECVOPTS;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_RETOPTS) {\n\t\tip_cmsg_recv_retopts(sock_net(sk), msg, skb);\n\n\t\tflags &= ~IP_CMSG_RETOPTS;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_PASSSEC) {\n\t\tip_cmsg_recv_security(msg, skb);\n\n\t\tflags &= ~IP_CMSG_PASSSEC;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_ORIGDSTADDR) {\n\t\tip_cmsg_recv_dstaddr(msg, skb);\n\n\t\tflags &= ~IP_CMSG_ORIGDSTADDR;\n\t\tif (!flags)\n\t\t\treturn;\n\t}\n\n\tif (flags & IP_CMSG_CHECKSUM)\n\t\tip_cmsg_recv_checksum(msg, skb, tlen, offset);\n\n\tif (flags & IP_CMSG_RECVFRAGSIZE)\n\t\tip_cmsg_recv_fragsize(msg, skb);\n}\nEXPORT_SYMBOL(ip_cmsg_recv_offset);\n\nint ip_cmsg_send(struct sock *sk, struct msghdr *msg, struct ipcm_cookie *ipc,\n\t\t bool allow_ipv6)\n{\n\tint err, val;\n\tstruct cmsghdr *cmsg;\n\tstruct net *net = sock_net(sk);\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\tif (!CMSG_OK(msg, cmsg))\n\t\t\treturn -EINVAL;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (allow_ipv6 &&\n\t\t    cmsg->cmsg_level == SOL_IPV6 &&\n\t\t    cmsg->cmsg_type == IPV6_PKTINFO) {\n\t\t\tstruct in6_pktinfo *src_info;\n\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(*src_info)))\n\t\t\t\treturn -EINVAL;\n\t\t\tsrc_info = (struct in6_pktinfo *)CMSG_DATA(cmsg);\n\t\t\tif (!ipv6_addr_v4mapped(&src_info->ipi6_addr))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (src_info->ipi6_ifindex)\n\t\t\t\tipc->oif = src_info->ipi6_ifindex;\n\t\t\tipc->addr = src_info->ipi6_addr.s6_addr32[3];\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tif (cmsg->cmsg_level == SOL_SOCKET) {\n\t\t\terr = __sock_cmsg_send(sk, cmsg, &ipc->sockc);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cmsg->cmsg_level != SOL_IP)\n\t\t\tcontinue;\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase IP_RETOPTS:\n\t\t\terr = cmsg->cmsg_len - sizeof(struct cmsghdr);\n\n\t\t\t \n\t\t\terr = ip_options_get(net, &ipc->opt,\n\t\t\t\t\t     KERNEL_SOCKPTR(CMSG_DATA(cmsg)),\n\t\t\t\t\t     err < 40 ? err : 40);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase IP_PKTINFO:\n\t\t{\n\t\t\tstruct in_pktinfo *info;\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct in_pktinfo)))\n\t\t\t\treturn -EINVAL;\n\t\t\tinfo = (struct in_pktinfo *)CMSG_DATA(cmsg);\n\t\t\tif (info->ipi_ifindex)\n\t\t\t\tipc->oif = info->ipi_ifindex;\n\t\t\tipc->addr = info->ipi_spec_dst.s_addr;\n\t\t\tbreak;\n\t\t}\n\t\tcase IP_TTL:\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\n\t\t\t\treturn -EINVAL;\n\t\t\tval = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (val < 1 || val > 255)\n\t\t\t\treturn -EINVAL;\n\t\t\tipc->ttl = val;\n\t\t\tbreak;\n\t\tcase IP_TOS:\n\t\t\tif (cmsg->cmsg_len == CMSG_LEN(sizeof(int)))\n\t\t\t\tval = *(int *)CMSG_DATA(cmsg);\n\t\t\telse if (cmsg->cmsg_len == CMSG_LEN(sizeof(u8)))\n\t\t\t\tval = *(u8 *)CMSG_DATA(cmsg);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tif (val < 0 || val > 255)\n\t\t\t\treturn -EINVAL;\n\t\t\tipc->tos = val;\n\t\t\tipc->priority = rt_tos2priority(ipc->tos);\n\t\t\tbreak;\n\t\tcase IP_PROTOCOL:\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\n\t\t\t\treturn -EINVAL;\n\t\t\tval = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (val < 1 || val > 255)\n\t\t\t\treturn -EINVAL;\n\t\t\tipc->protocol = val;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void ip_ra_destroy_rcu(struct rcu_head *head)\n{\n\tstruct ip_ra_chain *ra = container_of(head, struct ip_ra_chain, rcu);\n\n\tsock_put(ra->saved_sk);\n\tkfree(ra);\n}\n\nint ip_ra_control(struct sock *sk, unsigned char on,\n\t\t  void (*destructor)(struct sock *))\n{\n\tstruct ip_ra_chain *ra, *new_ra;\n\tstruct ip_ra_chain __rcu **rap;\n\tstruct net *net = sock_net(sk);\n\n\tif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\treturn -EINVAL;\n\n\tnew_ra = on ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n\tif (on && !new_ra)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&net->ipv4.ra_mutex);\n\tfor (rap = &net->ipv4.ra_chain;\n\t     (ra = rcu_dereference_protected(*rap,\n\t\t\tlockdep_is_held(&net->ipv4.ra_mutex))) != NULL;\n\t     rap = &ra->next) {\n\t\tif (ra->sk == sk) {\n\t\t\tif (on) {\n\t\t\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\t\t\tkfree(new_ra);\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\t\t\t \n\t\t\tra->sk = NULL;\n\t\t\tRCU_INIT_POINTER(*rap, ra->next);\n\t\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\n\t\t\tif (ra->destructor)\n\t\t\t\tra->destructor(sk);\n\t\t\t \n\t\t\tra->saved_sk = sk;\n\t\t\tcall_rcu(&ra->rcu, ip_ra_destroy_rcu);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!new_ra) {\n\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\treturn -ENOBUFS;\n\t}\n\tnew_ra->sk = sk;\n\tnew_ra->destructor = destructor;\n\n\tRCU_INIT_POINTER(new_ra->next, ra);\n\trcu_assign_pointer(*rap, new_ra);\n\tsock_hold(sk);\n\tmutex_unlock(&net->ipv4.ra_mutex);\n\n\treturn 0;\n}\n\nstatic void ipv4_icmp_error_rfc4884(const struct sk_buff *skb,\n\t\t\t\t    struct sock_ee_data_rfc4884 *out)\n{\n\tswitch (icmp_hdr(skb)->type) {\n\tcase ICMP_DEST_UNREACH:\n\tcase ICMP_TIME_EXCEEDED:\n\tcase ICMP_PARAMETERPROB:\n\t\tip_icmp_error_rfc4884(skb, out, sizeof(struct icmphdr),\n\t\t\t\t      icmp_hdr(skb)->un.reserved[1] * 4);\n\t}\n}\n\nvoid ip_icmp_error(struct sock *sk, struct sk_buff *skb, int err,\n\t\t   __be16 port, u32 info, u8 *payload)\n{\n\tstruct sock_exterr_skb *serr;\n\n\tskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tserr = SKB_EXT_ERR(skb);\n\tserr->ee.ee_errno = err;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_ICMP;\n\tserr->ee.ee_type = icmp_hdr(skb)->type;\n\tserr->ee.ee_code = icmp_hdr(skb)->code;\n\tserr->ee.ee_pad = 0;\n\tserr->ee.ee_info = info;\n\tserr->ee.ee_data = 0;\n\tserr->addr_offset = (u8 *)&(((struct iphdr *)(icmp_hdr(skb) + 1))->daddr) -\n\t\t\t\t   skb_network_header(skb);\n\tserr->port = port;\n\n\tif (skb_pull(skb, payload - skb->data)) {\n\t\tif (inet_test_bit(RECVERR_RFC4884, sk))\n\t\t\tipv4_icmp_error_rfc4884(skb, &serr->ee.ee_rfc4884);\n\n\t\tskb_reset_transport_header(skb);\n\t\tif (sock_queue_err_skb(sk, skb) == 0)\n\t\t\treturn;\n\t}\n\tkfree_skb(skb);\n}\nEXPORT_SYMBOL_GPL(ip_icmp_error);\n\nvoid ip_local_error(struct sock *sk, int err, __be32 daddr, __be16 port, u32 info)\n{\n\tstruct sock_exterr_skb *serr;\n\tstruct iphdr *iph;\n\tstruct sk_buff *skb;\n\n\tif (!inet_test_bit(RECVERR, sk))\n\t\treturn;\n\n\tskb = alloc_skb(sizeof(struct iphdr), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put(skb, sizeof(struct iphdr));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->daddr = daddr;\n\n\tserr = SKB_EXT_ERR(skb);\n\tserr->ee.ee_errno = err;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\n\tserr->ee.ee_type = 0;\n\tserr->ee.ee_code = 0;\n\tserr->ee.ee_pad = 0;\n\tserr->ee.ee_info = info;\n\tserr->ee.ee_data = 0;\n\tserr->addr_offset = (u8 *)&iph->daddr - skb_network_header(skb);\n\tserr->port = port;\n\n\t__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\n\tskb_reset_transport_header(skb);\n\n\tif (sock_queue_err_skb(sk, skb))\n\t\tkfree_skb(skb);\n}\n\n \nstatic inline bool ipv4_datagram_support_addr(struct sock_exterr_skb *serr)\n{\n\treturn serr->ee.ee_origin == SO_EE_ORIGIN_ICMP ||\n\t       serr->ee.ee_origin == SO_EE_ORIGIN_LOCAL || serr->port;\n}\n\n \nstatic bool ipv4_datagram_support_cmsg(const struct sock *sk,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       int ee_origin)\n{\n\tstruct in_pktinfo *info;\n\n\tif (ee_origin == SO_EE_ORIGIN_ICMP)\n\t\treturn true;\n\n\tif (ee_origin == SO_EE_ORIGIN_LOCAL)\n\t\treturn false;\n\n\t \n\tinfo = PKTINFO_SKB_CB(skb);\n\tif (!(READ_ONCE(sk->sk_tsflags) & SOF_TIMESTAMPING_OPT_CMSG) ||\n\t    !info->ipi_ifindex)\n\t\treturn false;\n\n\tinfo->ipi_spec_dst.s_addr = ip_hdr(skb)->saddr;\n\treturn true;\n}\n\n \nint ip_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)\n{\n\tstruct sock_exterr_skb *serr;\n\tstruct sk_buff *skb;\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct {\n\t\tstruct sock_extended_err ee;\n\t\tstruct sockaddr_in\t offender;\n\t} errhdr;\n\tint err;\n\tint copied;\n\n\terr = -EAGAIN;\n\tskb = sock_dequeue_err_skb(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (unlikely(err)) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tserr = SKB_EXT_ERR(skb);\n\n\tif (sin && ipv4_datagram_support_addr(serr)) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = *(__be32 *)(skb_network_header(skb) +\n\t\t\t\t\t\t   serr->addr_offset);\n\t\tsin->sin_port = serr->port;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\n\tmemcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));\n\tsin = &errhdr.offender;\n\tmemset(sin, 0, sizeof(*sin));\n\n\tif (ipv4_datagram_support_cmsg(sk, skb, serr->ee.ee_origin)) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tif (inet_cmsg_flags(inet_sk(sk)))\n\t\t\tip_cmsg_recv(msg, skb);\n\t}\n\n\tput_cmsg(msg, SOL_IP, IP_RECVERR, sizeof(errhdr), &errhdr);\n\n\t \n\n\tmsg->msg_flags |= MSG_ERRQUEUE;\n\terr = copied;\n\n\tconsume_skb(skb);\nout:\n\treturn err;\n}\n\nvoid __ip_sock_set_tos(struct sock *sk, int val)\n{\n\tif (sk->sk_type == SOCK_STREAM) {\n\t\tval &= ~INET_ECN_MASK;\n\t\tval |= inet_sk(sk)->tos & INET_ECN_MASK;\n\t}\n\tif (inet_sk(sk)->tos != val) {\n\t\tinet_sk(sk)->tos = val;\n\t\tWRITE_ONCE(sk->sk_priority, rt_tos2priority(val));\n\t\tsk_dst_reset(sk);\n\t}\n}\n\nvoid ip_sock_set_tos(struct sock *sk, int val)\n{\n\tlock_sock(sk);\n\t__ip_sock_set_tos(sk, val);\n\trelease_sock(sk);\n}\nEXPORT_SYMBOL(ip_sock_set_tos);\n\nvoid ip_sock_set_freebind(struct sock *sk)\n{\n\tinet_set_bit(FREEBIND, sk);\n}\nEXPORT_SYMBOL(ip_sock_set_freebind);\n\nvoid ip_sock_set_recverr(struct sock *sk)\n{\n\tinet_set_bit(RECVERR, sk);\n}\nEXPORT_SYMBOL(ip_sock_set_recverr);\n\nint ip_sock_set_mtu_discover(struct sock *sk, int val)\n{\n\tif (val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_OMIT)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tinet_sk(sk)->pmtudisc = val;\n\trelease_sock(sk);\n\treturn 0;\n}\nEXPORT_SYMBOL(ip_sock_set_mtu_discover);\n\nvoid ip_sock_set_pktinfo(struct sock *sk)\n{\n\tinet_set_bit(PKTINFO, sk);\n}\nEXPORT_SYMBOL(ip_sock_set_pktinfo);\n\n \nstatic bool setsockopt_needs_rtnl(int optname)\n{\n\tswitch (optname) {\n\tcase IP_ADD_MEMBERSHIP:\n\tcase IP_ADD_SOURCE_MEMBERSHIP:\n\tcase IP_BLOCK_SOURCE:\n\tcase IP_DROP_MEMBERSHIP:\n\tcase IP_DROP_SOURCE_MEMBERSHIP:\n\tcase IP_MSFILTER:\n\tcase IP_UNBLOCK_SOURCE:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_MSFILTER:\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int set_mcast_msfilter(struct sock *sk, int ifindex,\n\t\t\t      int numsrc, int fmode,\n\t\t\t      struct sockaddr_storage *group,\n\t\t\t      struct sockaddr_storage *list)\n{\n\tstruct ip_msfilter *msf;\n\tstruct sockaddr_in *psin;\n\tint err, i;\n\n\tmsf = kmalloc(IP_MSFILTER_SIZE(numsrc), GFP_KERNEL);\n\tif (!msf)\n\t\treturn -ENOBUFS;\n\n\tpsin = (struct sockaddr_in *)group;\n\tif (psin->sin_family != AF_INET)\n\t\tgoto Eaddrnotavail;\n\tmsf->imsf_multiaddr = psin->sin_addr.s_addr;\n\tmsf->imsf_interface = 0;\n\tmsf->imsf_fmode = fmode;\n\tmsf->imsf_numsrc = numsrc;\n\tfor (i = 0; i < numsrc; ++i) {\n\t\tpsin = (struct sockaddr_in *)&list[i];\n\n\t\tif (psin->sin_family != AF_INET)\n\t\t\tgoto Eaddrnotavail;\n\t\tmsf->imsf_slist_flex[i] = psin->sin_addr.s_addr;\n\t}\n\terr = ip_mc_msfilter(sk, msf, ifindex);\n\tkfree(msf);\n\treturn err;\n\nEaddrnotavail:\n\tkfree(msf);\n\treturn -EADDRNOTAVAIL;\n}\n\nstatic int copy_group_source_from_sockptr(struct group_source_req *greqs,\n\t\tsockptr_t optval, int optlen)\n{\n\tif (in_compat_syscall()) {\n\t\tstruct compat_group_source_req gr32;\n\n\t\tif (optlen != sizeof(gr32))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&gr32, optval, sizeof(gr32)))\n\t\t\treturn -EFAULT;\n\t\tgreqs->gsr_interface = gr32.gsr_interface;\n\t\tgreqs->gsr_group = gr32.gsr_group;\n\t\tgreqs->gsr_source = gr32.gsr_source;\n\t} else {\n\t\tif (optlen != sizeof(*greqs))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(greqs, optval, sizeof(*greqs)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_mcast_group_source(struct sock *sk, int optname,\n\t\tsockptr_t optval, int optlen)\n{\n\tstruct group_source_req greqs;\n\tstruct ip_mreq_source mreqs;\n\tstruct sockaddr_in *psin;\n\tint omode, add, err;\n\n\terr = copy_group_source_from_sockptr(&greqs, optval, optlen);\n\tif (err)\n\t\treturn err;\n\n\tif (greqs.gsr_group.ss_family != AF_INET ||\n\t    greqs.gsr_source.ss_family != AF_INET)\n\t\treturn -EADDRNOTAVAIL;\n\n\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\tmreqs.imr_multiaddr = psin->sin_addr.s_addr;\n\tpsin = (struct sockaddr_in *)&greqs.gsr_source;\n\tmreqs.imr_sourceaddr = psin->sin_addr.s_addr;\n\tmreqs.imr_interface = 0;  \n\n\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\tomode = MCAST_EXCLUDE;\n\t\tadd = 1;\n\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\tomode = MCAST_EXCLUDE;\n\t\tadd = 0;\n\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\tstruct ip_mreqn mreq;\n\n\t\tpsin = (struct sockaddr_in *)&greqs.gsr_group;\n\t\tmreq.imr_multiaddr = psin->sin_addr;\n\t\tmreq.imr_address.s_addr = 0;\n\t\tmreq.imr_ifindex = greqs.gsr_interface;\n\t\terr = ip_mc_join_group_ssm(sk, &mreq, MCAST_INCLUDE);\n\t\tif (err && err != -EADDRINUSE)\n\t\t\treturn err;\n\t\tgreqs.gsr_interface = mreq.imr_ifindex;\n\t\tomode = MCAST_INCLUDE;\n\t\tadd = 1;\n\t} else   {\n\t\tomode = MCAST_INCLUDE;\n\t\tadd = 0;\n\t}\n\treturn ip_mc_source(add, omode, sk, &mreqs, greqs.gsr_interface);\n}\n\nstatic int ip_set_mcast_msfilter(struct sock *sk, sockptr_t optval, int optlen)\n{\n\tstruct group_filter *gsf = NULL;\n\tint err;\n\n\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\treturn -EINVAL;\n\tif (optlen > READ_ONCE(sysctl_optmem_max))\n\t\treturn -ENOBUFS;\n\n\tgsf = memdup_sockptr(optval, optlen);\n\tif (IS_ERR(gsf))\n\t\treturn PTR_ERR(gsf);\n\n\t \n\terr = -ENOBUFS;\n\tif (gsf->gf_numsrc >= 0x1ffffff ||\n\t    gsf->gf_numsrc > READ_ONCE(sock_net(sk)->ipv4.sysctl_igmp_max_msf))\n\t\tgoto out_free_gsf;\n\n\terr = -EINVAL;\n\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen)\n\t\tgoto out_free_gsf;\n\n\terr = set_mcast_msfilter(sk, gsf->gf_interface, gsf->gf_numsrc,\n\t\t\t\t gsf->gf_fmode, &gsf->gf_group,\n\t\t\t\t gsf->gf_slist_flex);\nout_free_gsf:\n\tkfree(gsf);\n\treturn err;\n}\n\nstatic int compat_ip_set_mcast_msfilter(struct sock *sk, sockptr_t optval,\n\t\tint optlen)\n{\n\tconst int size0 = offsetof(struct compat_group_filter, gf_slist_flex);\n\tstruct compat_group_filter *gf32;\n\tunsigned int n;\n\tvoid *p;\n\tint err;\n\n\tif (optlen < size0)\n\t\treturn -EINVAL;\n\tif (optlen > READ_ONCE(sysctl_optmem_max) - 4)\n\t\treturn -ENOBUFS;\n\n\tp = kmalloc(optlen + 4, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\tgf32 = p + 4;  \n\n\terr = -EFAULT;\n\tif (copy_from_sockptr(gf32, optval, optlen))\n\t\tgoto out_free_gsf;\n\n\t \n\tn = gf32->gf_numsrc;\n\terr = -ENOBUFS;\n\tif (n >= 0x1ffffff)\n\t\tgoto out_free_gsf;\n\n\terr = -EINVAL;\n\tif (offsetof(struct compat_group_filter, gf_slist_flex[n]) > optlen)\n\t\tgoto out_free_gsf;\n\n\t \n\terr = -ENOBUFS;\n\tif (n > READ_ONCE(sock_net(sk)->ipv4.sysctl_igmp_max_msf))\n\t\tgoto out_free_gsf;\n\terr = set_mcast_msfilter(sk, gf32->gf_interface, n, gf32->gf_fmode,\n\t\t\t\t &gf32->gf_group, gf32->gf_slist_flex);\nout_free_gsf:\n\tkfree(p);\n\treturn err;\n}\n\nstatic int ip_mcast_join_leave(struct sock *sk, int optname,\n\t\tsockptr_t optval, int optlen)\n{\n\tstruct ip_mreqn mreq = { };\n\tstruct sockaddr_in *psin;\n\tstruct group_req greq;\n\n\tif (optlen < sizeof(struct group_req))\n\t\treturn -EINVAL;\n\tif (copy_from_sockptr(&greq, optval, sizeof(greq)))\n\t\treturn -EFAULT;\n\n\tpsin = (struct sockaddr_in *)&greq.gr_group;\n\tif (psin->sin_family != AF_INET)\n\t\treturn -EINVAL;\n\tmreq.imr_multiaddr = psin->sin_addr;\n\tmreq.imr_ifindex = greq.gr_interface;\n\tif (optname == MCAST_JOIN_GROUP)\n\t\treturn ip_mc_join_group(sk, &mreq);\n\treturn ip_mc_leave_group(sk, &mreq);\n}\n\nstatic int compat_ip_mcast_join_leave(struct sock *sk, int optname,\n\t\tsockptr_t optval, int optlen)\n{\n\tstruct compat_group_req greq;\n\tstruct ip_mreqn mreq = { };\n\tstruct sockaddr_in *psin;\n\n\tif (optlen < sizeof(struct compat_group_req))\n\t\treturn -EINVAL;\n\tif (copy_from_sockptr(&greq, optval, sizeof(greq)))\n\t\treturn -EFAULT;\n\n\tpsin = (struct sockaddr_in *)&greq.gr_group;\n\tif (psin->sin_family != AF_INET)\n\t\treturn -EINVAL;\n\tmreq.imr_multiaddr = psin->sin_addr;\n\tmreq.imr_ifindex = greq.gr_interface;\n\n\tif (optname == MCAST_JOIN_GROUP)\n\t\treturn ip_mc_join_group(sk, &mreq);\n\treturn ip_mc_leave_group(sk, &mreq);\n}\n\nDEFINE_STATIC_KEY_FALSE(ip4_min_ttl);\n\nint do_ip_setsockopt(struct sock *sk, int level, int optname,\n\t\t     sockptr_t optval, unsigned int optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint val = 0, err;\n\tbool needs_rtnl = setsockopt_needs_rtnl(optname);\n\n\tswitch (optname) {\n\tcase IP_PKTINFO:\n\tcase IP_RECVTTL:\n\tcase IP_RECVOPTS:\n\tcase IP_RECVTOS:\n\tcase IP_RETOPTS:\n\tcase IP_TOS:\n\tcase IP_TTL:\n\tcase IP_HDRINCL:\n\tcase IP_MTU_DISCOVER:\n\tcase IP_RECVERR:\n\tcase IP_ROUTER_ALERT:\n\tcase IP_FREEBIND:\n\tcase IP_PASSSEC:\n\tcase IP_TRANSPARENT:\n\tcase IP_MINTTL:\n\tcase IP_NODEFRAG:\n\tcase IP_BIND_ADDRESS_NO_PORT:\n\tcase IP_UNICAST_IF:\n\tcase IP_MULTICAST_TTL:\n\tcase IP_MULTICAST_ALL:\n\tcase IP_MULTICAST_LOOP:\n\tcase IP_RECVORIGDSTADDR:\n\tcase IP_CHECKSUM:\n\tcase IP_RECVFRAGSIZE:\n\tcase IP_RECVERR_RFC4884:\n\tcase IP_LOCAL_PORT_RANGE:\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (optlen >= sizeof(char)) {\n\t\t\tunsigned char ucval;\n\n\t\t\tif (copy_from_sockptr(&ucval, optval, sizeof(ucval)))\n\t\t\t\treturn -EFAULT;\n\t\t\tval = (int) ucval;\n\t\t}\n\t}\n\n\t \n\n\tif (optname == IP_ROUTER_ALERT)\n\t\treturn ip_ra_control(sk, val ? 1 : 0, NULL);\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_setsockopt(sk, optname, optval, optlen);\n\n\t \n\tswitch (optname) {\n\tcase IP_PKTINFO:\n\t\tinet_assign_bit(PKTINFO, sk, val);\n\t\treturn 0;\n\tcase IP_RECVTTL:\n\t\tinet_assign_bit(TTL, sk, val);\n\t\treturn 0;\n\tcase IP_RECVTOS:\n\t\tinet_assign_bit(TOS, sk, val);\n\t\treturn 0;\n\tcase IP_RECVOPTS:\n\t\tinet_assign_bit(RECVOPTS, sk, val);\n\t\treturn 0;\n\tcase IP_RETOPTS:\n\t\tinet_assign_bit(RETOPTS, sk, val);\n\t\treturn 0;\n\tcase IP_PASSSEC:\n\t\tinet_assign_bit(PASSSEC, sk, val);\n\t\treturn 0;\n\tcase IP_RECVORIGDSTADDR:\n\t\tinet_assign_bit(ORIGDSTADDR, sk, val);\n\t\treturn 0;\n\tcase IP_RECVFRAGSIZE:\n\t\tif (sk->sk_type != SOCK_RAW && sk->sk_type != SOCK_DGRAM)\n\t\t\treturn -EINVAL;\n\t\tinet_assign_bit(RECVFRAGSIZE, sk, val);\n\t\treturn 0;\n\tcase IP_RECVERR:\n\t\tinet_assign_bit(RECVERR, sk, val);\n\t\tif (!val)\n\t\t\tskb_errqueue_purge(&sk->sk_error_queue);\n\t\treturn 0;\n\tcase IP_RECVERR_RFC4884:\n\t\tif (val < 0 || val > 1)\n\t\t\treturn -EINVAL;\n\t\tinet_assign_bit(RECVERR_RFC4884, sk, val);\n\t\treturn 0;\n\tcase IP_FREEBIND:\n\t\tif (optlen < 1)\n\t\t\treturn -EINVAL;\n\t\tinet_assign_bit(FREEBIND, sk, val);\n\t\treturn 0;\n\tcase IP_HDRINCL:\n\t\tif (sk->sk_type != SOCK_RAW)\n\t\t\treturn -ENOPROTOOPT;\n\t\tinet_assign_bit(HDRINCL, sk, val);\n\t\treturn 0;\n\tcase IP_MULTICAST_LOOP:\n\t\tif (optlen < 1)\n\t\t\treturn -EINVAL;\n\t\tinet_assign_bit(MC_LOOP, sk, val);\n\t\treturn 0;\n\tcase IP_MULTICAST_ALL:\n\t\tif (optlen < 1)\n\t\t\treturn -EINVAL;\n\t\tif (val != 0 && val != 1)\n\t\t\treturn -EINVAL;\n\t\tinet_assign_bit(MC_ALL, sk, val);\n\t\treturn 0;\n\tcase IP_TRANSPARENT:\n\t\tif (!!val && !sockopt_ns_capable(sock_net(sk)->user_ns, CAP_NET_RAW) &&\n\t\t    !sockopt_ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (optlen < 1)\n\t\t\treturn -EINVAL;\n\t\tinet_assign_bit(TRANSPARENT, sk, val);\n\t\treturn 0;\n\tcase IP_NODEFRAG:\n\t\tif (sk->sk_type != SOCK_RAW)\n\t\t\treturn -ENOPROTOOPT;\n\t\tinet_assign_bit(NODEFRAG, sk, val);\n\t\treturn 0;\n\tcase IP_BIND_ADDRESS_NO_PORT:\n\t\tinet_assign_bit(BIND_ADDRESS_NO_PORT, sk, val);\n\t\treturn 0;\n\tcase IP_TTL:\n\t\tif (optlen < 1)\n\t\t\treturn -EINVAL;\n\t\tif (val != -1 && (val < 1 || val > 255))\n\t\t\treturn -EINVAL;\n\t\tWRITE_ONCE(inet->uc_ttl, val);\n\t\treturn 0;\n\tcase IP_MINTTL:\n\t\tif (optlen < 1)\n\t\t\treturn -EINVAL;\n\t\tif (val < 0 || val > 255)\n\t\t\treturn -EINVAL;\n\n\t\tif (val)\n\t\t\tstatic_branch_enable(&ip4_min_ttl);\n\n\t\tWRITE_ONCE(inet->min_ttl, val);\n\t\treturn 0;\n\t}\n\n\terr = 0;\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tsockopt_lock_sock(sk);\n\n\tswitch (optname) {\n\tcase IP_OPTIONS:\n\t{\n\t\tstruct ip_options_rcu *old, *opt = NULL;\n\n\t\tif (optlen > 40)\n\t\t\tgoto e_inval;\n\t\terr = ip_options_get(sock_net(sk), &opt, optval, optlen);\n\t\tif (err)\n\t\t\tbreak;\n\t\told = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\tlockdep_sock_is_held(sk));\n\t\tif (inet_test_bit(IS_ICSK, sk)) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tif (sk->sk_family == PF_INET ||\n\t\t\t    (!((1 << sk->sk_state) &\n\t\t\t       (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t\t     inet->inet_daddr != LOOPBACK4_IPV6)) {\n#endif\n\t\t\t\tif (old)\n\t\t\t\t\ticsk->icsk_ext_hdr_len -= old->opt.optlen;\n\t\t\t\tif (opt)\n\t\t\t\t\ticsk->icsk_ext_hdr_len += opt->opt.optlen;\n\t\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\t}\n#endif\n\t\t}\n\t\trcu_assign_pointer(inet->inet_opt, opt);\n\t\tif (old)\n\t\t\tkfree_rcu(old, rcu);\n\t\tbreak;\n\t}\n\tcase IP_CHECKSUM:\n\t\tif (val) {\n\t\t\tif (!(inet_test_bit(CHECKSUM, sk))) {\n\t\t\t\tinet_inc_convert_csum(sk);\n\t\t\t\tinet_set_bit(CHECKSUM, sk);\n\t\t\t}\n\t\t} else {\n\t\t\tif (inet_test_bit(CHECKSUM, sk)) {\n\t\t\t\tinet_dec_convert_csum(sk);\n\t\t\t\tinet_clear_bit(CHECKSUM, sk);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IP_TOS:\t \n\t\t__ip_sock_set_tos(sk, val);\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tif (val < IP_PMTUDISC_DONT || val > IP_PMTUDISC_OMIT)\n\t\t\tgoto e_inval;\n\t\tinet->pmtudisc = val;\n\t\tbreak;\n\tcase IP_MULTICAST_TTL:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\tif (optlen < 1)\n\t\t\tgoto e_inval;\n\t\tif (val == -1)\n\t\t\tval = 1;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\t\tinet->mc_ttl = val;\n\t\tbreak;\n\tcase IP_UNICAST_IF:\n\t{\n\t\tstruct net_device *dev = NULL;\n\t\tint ifindex;\n\t\tint midx;\n\n\t\tif (optlen != sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tifindex = (__force int)ntohl((__force __be32)val);\n\t\tif (ifindex == 0) {\n\t\t\tinet->uc_index = 0;\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev = dev_get_by_index(sock_net(sk), ifindex);\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\n\t\tmidx = l3mdev_master_ifindex(dev);\n\t\tdev_put(dev);\n\n\t\terr = -EINVAL;\n\t\tif (sk->sk_bound_dev_if && midx != sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tinet->uc_index = ifindex;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct ip_mreqn mreq;\n\t\tstruct net_device *dev = NULL;\n\t\tint midx;\n\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tgoto e_inval;\n\t\t \n\n\t\tif (optlen < sizeof(struct in_addr))\n\t\t\tgoto e_inval;\n\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_sockptr(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (optlen >= sizeof(struct ip_mreq)) {\n\t\t\t\tif (copy_from_sockptr(&mreq, optval,\n\t\t\t\t\t\t      sizeof(struct ip_mreq)))\n\t\t\t\t\tbreak;\n\t\t\t} else if (optlen >= sizeof(struct in_addr)) {\n\t\t\t\tif (copy_from_sockptr(&mreq.imr_address, optval,\n\t\t\t\t\t\t      sizeof(struct in_addr)))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!mreq.imr_ifindex) {\n\t\t\tif (mreq.imr_address.s_addr == htonl(INADDR_ANY)) {\n\t\t\t\tinet->mc_index = 0;\n\t\t\t\tinet->mc_addr  = 0;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev = ip_dev_find(sock_net(sk), mreq.imr_address.s_addr);\n\t\t\tif (dev)\n\t\t\t\tmreq.imr_ifindex = dev->ifindex;\n\t\t} else\n\t\t\tdev = dev_get_by_index(sock_net(sk), mreq.imr_ifindex);\n\n\n\t\terr = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\n\t\tmidx = l3mdev_master_ifindex(dev);\n\n\t\tdev_put(dev);\n\n\t\terr = -EINVAL;\n\t\tif (sk->sk_bound_dev_if &&\n\t\t    mreq.imr_ifindex != sk->sk_bound_dev_if &&\n\t\t    midx != sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tinet->mc_index = mreq.imr_ifindex;\n\t\tinet->mc_addr  = mreq.imr_address.s_addr;\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\tcase IP_ADD_MEMBERSHIP:\n\tcase IP_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreqn mreq;\n\n\t\terr = -EPROTO;\n\t\tif (inet_test_bit(IS_ICSK, sk))\n\t\t\tbreak;\n\n\t\tif (optlen < sizeof(struct ip_mreq))\n\t\t\tgoto e_inval;\n\t\terr = -EFAULT;\n\t\tif (optlen >= sizeof(struct ip_mreqn)) {\n\t\t\tif (copy_from_sockptr(&mreq, optval, sizeof(mreq)))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmemset(&mreq, 0, sizeof(mreq));\n\t\t\tif (copy_from_sockptr(&mreq, optval,\n\t\t\t\t\t      sizeof(struct ip_mreq)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (optname == IP_ADD_MEMBERSHIP)\n\t\t\terr = ip_mc_join_group(sk, &mreq);\n\t\telse\n\t\t\terr = ip_mc_leave_group(sk, &mreq);\n\t\tbreak;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter *msf;\n\n\t\tif (optlen < IP_MSFILTER_SIZE(0))\n\t\t\tgoto e_inval;\n\t\tif (optlen > READ_ONCE(sysctl_optmem_max)) {\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tmsf = memdup_sockptr(optval, optlen);\n\t\tif (IS_ERR(msf)) {\n\t\t\terr = PTR_ERR(msf);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (msf->imsf_numsrc >= 0x3ffffffcU ||\n\t\t    msf->imsf_numsrc > READ_ONCE(net->ipv4.sysctl_igmp_max_msf)) {\n\t\t\tkfree(msf);\n\t\t\terr = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\tif (IP_MSFILTER_SIZE(msf->imsf_numsrc) > optlen) {\n\t\t\tkfree(msf);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = ip_mc_msfilter(sk, msf, 0);\n\t\tkfree(msf);\n\t\tbreak;\n\t}\n\tcase IP_BLOCK_SOURCE:\n\tcase IP_UNBLOCK_SOURCE:\n\tcase IP_ADD_SOURCE_MEMBERSHIP:\n\tcase IP_DROP_SOURCE_MEMBERSHIP:\n\t{\n\t\tstruct ip_mreq_source mreqs;\n\t\tint omode, add;\n\n\t\tif (optlen != sizeof(struct ip_mreq_source))\n\t\t\tgoto e_inval;\n\t\tif (copy_from_sockptr(&mreqs, optval, sizeof(mreqs))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (optname == IP_BLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 1;\n\t\t} else if (optname == IP_UNBLOCK_SOURCE) {\n\t\t\tomode = MCAST_EXCLUDE;\n\t\t\tadd = 0;\n\t\t} else if (optname == IP_ADD_SOURCE_MEMBERSHIP) {\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tmreq.imr_multiaddr.s_addr = mreqs.imr_multiaddr;\n\t\t\tmreq.imr_address.s_addr = mreqs.imr_interface;\n\t\t\tmreq.imr_ifindex = 0;\n\t\t\terr = ip_mc_join_group_ssm(sk, &mreq, MCAST_INCLUDE);\n\t\t\tif (err && err != -EADDRINUSE)\n\t\t\t\tbreak;\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 1;\n\t\t} else   {\n\t\t\tomode = MCAST_INCLUDE;\n\t\t\tadd = 0;\n\t\t}\n\t\terr = ip_mc_source(add, omode, sk, &mreqs, 0);\n\t\tbreak;\n\t}\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t\tif (in_compat_syscall())\n\t\t\terr = compat_ip_mcast_join_leave(sk, optname, optval,\n\t\t\t\t\t\t\t optlen);\n\t\telse\n\t\t\terr = ip_mcast_join_leave(sk, optname, optval, optlen);\n\t\tbreak;\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t\terr = do_mcast_group_source(sk, optname, optval, optlen);\n\t\tbreak;\n\tcase MCAST_MSFILTER:\n\t\tif (in_compat_syscall())\n\t\t\terr = compat_ip_set_mcast_msfilter(sk, optval, optlen);\n\t\telse\n\t\t\terr = ip_set_mcast_msfilter(sk, optval, optlen);\n\t\tbreak;\n\tcase IP_IPSEC_POLICY:\n\tcase IP_XFRM_POLICY:\n\t\terr = -EPERM;\n\t\tif (!sockopt_ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IP_LOCAL_PORT_RANGE:\n\t{\n\t\tconst __u16 lo = val;\n\t\tconst __u16 hi = val >> 16;\n\n\t\tif (optlen != sizeof(__u32))\n\t\t\tgoto e_inval;\n\t\tif (lo != 0 && hi != 0 && lo > hi)\n\t\t\tgoto e_inval;\n\n\t\tinet->local_port_range.lo = lo;\n\t\tinet->local_port_range.hi = hi;\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\tsockopt_release_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn err;\n\ne_inval:\n\tsockopt_release_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn -EINVAL;\n}\n\n \nvoid ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = inet_test_bit(PKTINFO, sk) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\t \n\t\tstruct rtable *rt = skb_rtable(skb);\n\t\tbool l3slave = ipv4_l3mdev_skb(IPCB(skb)->flags);\n\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\telse if (l3slave && rt && rt->rt_iif)\n\t\t\tpktinfo->ipi_ifindex = rt->rt_iif;\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}\n\nint ip_setsockopt(struct sock *sk, int level, int optname, sockptr_t optval,\n\t\tunsigned int optlen)\n{\n\tint err;\n\n\tif (level != SOL_IP)\n\t\treturn -ENOPROTOOPT;\n\n\terr = do_ip_setsockopt(sk, level, optname, optval, optlen);\n#if IS_ENABLED(CONFIG_BPFILTER_UMH)\n\tif (optname >= BPFILTER_IPT_SO_SET_REPLACE &&\n\t    optname < BPFILTER_IPT_SET_MAX)\n\t\terr = bpfilter_ip_set_sockopt(sk, optname, optval, optlen);\n#endif\n#ifdef CONFIG_NETFILTER\n\t \n\tif (err == -ENOPROTOOPT && optname != IP_HDRINCL &&\n\t\t\toptname != IP_IPSEC_POLICY &&\n\t\t\toptname != IP_XFRM_POLICY &&\n\t\t\t!ip_mroute_opt(optname))\n\t\terr = nf_setsockopt(sk, PF_INET, optname, optval, optlen);\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(ip_setsockopt);\n\n \n\nstatic bool getsockopt_needs_rtnl(int optname)\n{\n\tswitch (optname) {\n\tcase IP_MSFILTER:\n\tcase MCAST_MSFILTER:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int ip_get_mcast_msfilter(struct sock *sk, sockptr_t optval,\n\t\t\t\t sockptr_t optlen, int len)\n{\n\tconst int size0 = offsetof(struct group_filter, gf_slist_flex);\n\tstruct group_filter gsf;\n\tint num, gsf_size;\n\tint err;\n\n\tif (len < size0)\n\t\treturn -EINVAL;\n\tif (copy_from_sockptr(&gsf, optval, size0))\n\t\treturn -EFAULT;\n\n\tnum = gsf.gf_numsrc;\n\terr = ip_mc_gsfget(sk, &gsf, optval,\n\t\t\t   offsetof(struct group_filter, gf_slist_flex));\n\tif (err)\n\t\treturn err;\n\tif (gsf.gf_numsrc < num)\n\t\tnum = gsf.gf_numsrc;\n\tgsf_size = GROUP_FILTER_SIZE(num);\n\tif (copy_to_sockptr(optlen, &gsf_size, sizeof(int)) ||\n\t    copy_to_sockptr(optval, &gsf, size0))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_ip_get_mcast_msfilter(struct sock *sk, sockptr_t optval,\n\t\t\t\t\tsockptr_t optlen, int len)\n{\n\tconst int size0 = offsetof(struct compat_group_filter, gf_slist_flex);\n\tstruct compat_group_filter gf32;\n\tstruct group_filter gf;\n\tint num;\n\tint err;\n\n\tif (len < size0)\n\t\treturn -EINVAL;\n\tif (copy_from_sockptr(&gf32, optval, size0))\n\t\treturn -EFAULT;\n\n\tgf.gf_interface = gf32.gf_interface;\n\tgf.gf_fmode = gf32.gf_fmode;\n\tnum = gf.gf_numsrc = gf32.gf_numsrc;\n\tgf.gf_group = gf32.gf_group;\n\n\terr = ip_mc_gsfget(sk, &gf, optval,\n\t\t\t   offsetof(struct compat_group_filter, gf_slist_flex));\n\tif (err)\n\t\treturn err;\n\tif (gf.gf_numsrc < num)\n\t\tnum = gf.gf_numsrc;\n\tlen = GROUP_FILTER_SIZE(num) - (sizeof(gf) - sizeof(gf32));\n\tif (copy_to_sockptr(optlen, &len, sizeof(int)) ||\n\t    copy_to_sockptr_offset(optval, offsetof(struct compat_group_filter, gf_fmode),\n\t\t\t\t   &gf.gf_fmode, sizeof(gf.gf_fmode)) ||\n\t    copy_to_sockptr_offset(optval, offsetof(struct compat_group_filter, gf_numsrc),\n\t\t\t\t   &gf.gf_numsrc, sizeof(gf.gf_numsrc)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint do_ip_getsockopt(struct sock *sk, int level, int optname,\n\t\t     sockptr_t optval, sockptr_t optlen)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tbool needs_rtnl = getsockopt_needs_rtnl(optname);\n\tint val, err = 0;\n\tint len;\n\n\tif (level != SOL_IP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ip_mroute_opt(optname))\n\t\treturn ip_mroute_getsockopt(sk, optname, optval, optlen);\n\n\tif (copy_from_sockptr(&len, optlen, sizeof(int)))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (optname) {\n\tcase IP_PKTINFO:\n\t\tval = inet_test_bit(PKTINFO, sk);\n\t\tgoto copyval;\n\tcase IP_RECVTTL:\n\t\tval = inet_test_bit(TTL, sk);\n\t\tgoto copyval;\n\tcase IP_RECVTOS:\n\t\tval = inet_test_bit(TOS, sk);\n\t\tgoto copyval;\n\tcase IP_RECVOPTS:\n\t\tval = inet_test_bit(RECVOPTS, sk);\n\t\tgoto copyval;\n\tcase IP_RETOPTS:\n\t\tval = inet_test_bit(RETOPTS, sk);\n\t\tgoto copyval;\n\tcase IP_PASSSEC:\n\t\tval = inet_test_bit(PASSSEC, sk);\n\t\tgoto copyval;\n\tcase IP_RECVORIGDSTADDR:\n\t\tval = inet_test_bit(ORIGDSTADDR, sk);\n\t\tgoto copyval;\n\tcase IP_CHECKSUM:\n\t\tval = inet_test_bit(CHECKSUM, sk);\n\t\tgoto copyval;\n\tcase IP_RECVFRAGSIZE:\n\t\tval = inet_test_bit(RECVFRAGSIZE, sk);\n\t\tgoto copyval;\n\tcase IP_RECVERR:\n\t\tval = inet_test_bit(RECVERR, sk);\n\t\tgoto copyval;\n\tcase IP_RECVERR_RFC4884:\n\t\tval = inet_test_bit(RECVERR_RFC4884, sk);\n\t\tgoto copyval;\n\tcase IP_FREEBIND:\n\t\tval = inet_test_bit(FREEBIND, sk);\n\t\tgoto copyval;\n\tcase IP_HDRINCL:\n\t\tval = inet_test_bit(HDRINCL, sk);\n\t\tgoto copyval;\n\tcase IP_MULTICAST_LOOP:\n\t\tval = inet_test_bit(MC_LOOP, sk);\n\t\tgoto copyval;\n\tcase IP_MULTICAST_ALL:\n\t\tval = inet_test_bit(MC_ALL, sk);\n\t\tgoto copyval;\n\tcase IP_TRANSPARENT:\n\t\tval = inet_test_bit(TRANSPARENT, sk);\n\t\tgoto copyval;\n\tcase IP_NODEFRAG:\n\t\tval = inet_test_bit(NODEFRAG, sk);\n\t\tgoto copyval;\n\tcase IP_BIND_ADDRESS_NO_PORT:\n\t\tval = inet_test_bit(BIND_ADDRESS_NO_PORT, sk);\n\t\tgoto copyval;\n\tcase IP_TTL:\n\t\tval = READ_ONCE(inet->uc_ttl);\n\t\tif (val < 0)\n\t\t\tval = READ_ONCE(sock_net(sk)->ipv4.sysctl_ip_default_ttl);\n\t\tgoto copyval;\n\tcase IP_MINTTL:\n\t\tval = READ_ONCE(inet->min_ttl);\n\t\tgoto copyval;\n\t}\n\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tsockopt_lock_sock(sk);\n\n\tswitch (optname) {\n\tcase IP_OPTIONS:\n\t{\n\t\tunsigned char optbuf[sizeof(struct ip_options)+40];\n\t\tstruct ip_options *opt = (struct ip_options *)optbuf;\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\t     lockdep_sock_is_held(sk));\n\t\topt->optlen = 0;\n\t\tif (inet_opt)\n\t\t\tmemcpy(optbuf, &inet_opt->opt,\n\t\t\t       sizeof(struct ip_options) +\n\t\t\t       inet_opt->opt.optlen);\n\t\tsockopt_release_sock(sk);\n\n\t\tif (opt->optlen == 0) {\n\t\t\tlen = 0;\n\t\t\treturn copy_to_sockptr(optlen, &len, sizeof(int));\n\t\t}\n\n\t\tip_options_undo(opt);\n\n\t\tlen = min_t(unsigned int, len, opt->optlen);\n\t\tif (copy_to_sockptr(optlen, &len, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_sockptr(optval, opt->__data, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase IP_TOS:\n\t\tval = inet->tos;\n\t\tbreak;\n\tcase IP_MTU_DISCOVER:\n\t\tval = inet->pmtudisc;\n\t\tbreak;\n\tcase IP_MTU:\n\t{\n\t\tstruct dst_entry *dst;\n\t\tval = 0;\n\t\tdst = sk_dst_get(sk);\n\t\tif (dst) {\n\t\t\tval = dst_mtu(dst);\n\t\t\tdst_release(dst);\n\t\t}\n\t\tif (!val) {\n\t\t\tsockopt_release_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tbreak;\n\t}\n\tcase IP_MULTICAST_TTL:\n\t\tval = inet->mc_ttl;\n\t\tbreak;\n\tcase IP_UNICAST_IF:\n\t\tval = (__force int)htonl((__u32) inet->uc_index);\n\t\tbreak;\n\tcase IP_MULTICAST_IF:\n\t{\n\t\tstruct in_addr addr;\n\t\tlen = min_t(unsigned int, len, sizeof(struct in_addr));\n\t\taddr.s_addr = inet->mc_addr;\n\t\tsockopt_release_sock(sk);\n\n\t\tif (copy_to_sockptr(optlen, &len, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_sockptr(optval, &addr, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tcase IP_MSFILTER:\n\t{\n\t\tstruct ip_msfilter msf;\n\n\t\tif (len < IP_MSFILTER_SIZE(0)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (copy_from_sockptr(&msf, optval, IP_MSFILTER_SIZE(0))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\terr = ip_mc_msfget(sk, &msf, optval, optlen);\n\t\tgoto out;\n\t}\n\tcase MCAST_MSFILTER:\n\t\tif (in_compat_syscall())\n\t\t\terr = compat_ip_get_mcast_msfilter(sk, optval, optlen,\n\t\t\t\t\t\t\t   len);\n\t\telse\n\t\t\terr = ip_get_mcast_msfilter(sk, optval, optlen, len);\n\t\tgoto out;\n\tcase IP_PKTOPTIONS:\n\t{\n\t\tstruct msghdr msg;\n\n\t\tsockopt_release_sock(sk);\n\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\treturn -ENOPROTOOPT;\n\n\t\tif (optval.is_kernel) {\n\t\t\tmsg.msg_control_is_user = false;\n\t\t\tmsg.msg_control = optval.kernel;\n\t\t} else {\n\t\t\tmsg.msg_control_is_user = true;\n\t\t\tmsg.msg_control_user = optval.user;\n\t\t}\n\t\tmsg.msg_controllen = len;\n\t\tmsg.msg_flags = in_compat_syscall() ? MSG_CMSG_COMPAT : 0;\n\n\t\tif (inet_test_bit(PKTINFO, sk)) {\n\t\t\tstruct in_pktinfo info;\n\n\t\t\tinfo.ipi_addr.s_addr = inet->inet_rcv_saddr;\n\t\t\tinfo.ipi_spec_dst.s_addr = inet->inet_rcv_saddr;\n\t\t\tinfo.ipi_ifindex = inet->mc_index;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);\n\t\t}\n\t\tif (inet_test_bit(TTL, sk)) {\n\t\t\tint hlim = inet->mc_ttl;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_TTL, sizeof(hlim), &hlim);\n\t\t}\n\t\tif (inet_test_bit(TOS, sk)) {\n\t\t\tint tos = inet->rcv_tos;\n\t\t\tput_cmsg(&msg, SOL_IP, IP_TOS, sizeof(tos), &tos);\n\t\t}\n\t\tlen -= msg.msg_controllen;\n\t\treturn copy_to_sockptr(optlen, &len, sizeof(int));\n\t}\n\tcase IP_LOCAL_PORT_RANGE:\n\t\tval = inet->local_port_range.hi << 16 | inet->local_port_range.lo;\n\t\tbreak;\n\tcase IP_PROTOCOL:\n\t\tval = inet_sk(sk)->inet_num;\n\t\tbreak;\n\tdefault:\n\t\tsockopt_release_sock(sk);\n\t\treturn -ENOPROTOOPT;\n\t}\n\tsockopt_release_sock(sk);\ncopyval:\n\tif (len < sizeof(int) && len > 0 && val >= 0 && val <= 255) {\n\t\tunsigned char ucval = (unsigned char)val;\n\t\tlen = 1;\n\t\tif (copy_to_sockptr(optlen, &len, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_sockptr(optval, &ucval, 1))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tlen = min_t(unsigned int, sizeof(int), len);\n\t\tif (copy_to_sockptr(optlen, &len, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_sockptr(optval, &val, len))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n\nout:\n\tsockopt_release_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\treturn err;\n}\n\nint ip_getsockopt(struct sock *sk, int level,\n\t\t  int optname, char __user *optval, int __user *optlen)\n{\n\tint err;\n\n\terr = do_ip_getsockopt(sk, level, optname,\n\t\t\t       USER_SOCKPTR(optval), USER_SOCKPTR(optlen));\n\n#if IS_ENABLED(CONFIG_BPFILTER_UMH)\n\tif (optname >= BPFILTER_IPT_SO_GET_INFO &&\n\t    optname < BPFILTER_IPT_GET_MAX)\n\t\terr = bpfilter_ip_get_sockopt(sk, optname, optval, optlen);\n#endif\n#ifdef CONFIG_NETFILTER\n\t \n\tif (err == -ENOPROTOOPT && optname != IP_PKTOPTIONS &&\n\t\t\t!ip_mroute_opt(optname)) {\n\t\tint len;\n\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\n\t\terr = nf_getsockopt(sk, PF_INET, optname, optval, &len);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t\treturn err;\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(ip_getsockopt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}