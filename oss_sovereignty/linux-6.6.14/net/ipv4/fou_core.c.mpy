{
  "module_name": "fou_core.c",
  "hash_id": "5fff8e50092749269d7abe2fd1ca31036c391b80bd40071463b844081022741f",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/fou_core.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/socket.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/icmp.h>\n#include <linux/udp.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <net/genetlink.h>\n#include <net/gro.h>\n#include <net/gue.h>\n#include <net/fou.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/udp.h>\n#include <net/udp_tunnel.h>\n#include <uapi/linux/fou.h>\n#include <uapi/linux/genetlink.h>\n\n#include \"fou_nl.h\"\n\nstruct fou {\n\tstruct socket *sock;\n\tu8 protocol;\n\tu8 flags;\n\t__be16 port;\n\tu8 family;\n\tu16 type;\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n};\n\n#define FOU_F_REMCSUM_NOPARTIAL BIT(0)\n\nstruct fou_cfg {\n\tu16 type;\n\tu8 protocol;\n\tu8 flags;\n\tstruct udp_port_cfg udp_config;\n};\n\nstatic unsigned int fou_net_id;\n\nstruct fou_net {\n\tstruct list_head fou_list;\n\tstruct mutex fou_lock;\n};\n\nstatic inline struct fou *fou_from_sock(struct sock *sk)\n{\n\treturn sk->sk_user_data;\n}\n\nstatic int fou_recv_pull(struct sk_buff *skb, struct fou *fou, size_t len)\n{\n\t \n\tif (fou->family == AF_INET)\n\t\tip_hdr(skb)->tot_len = htons(ntohs(ip_hdr(skb)->tot_len) - len);\n\telse\n\t\tipv6_hdr(skb)->payload_len =\n\t\t    htons(ntohs(ipv6_hdr(skb)->payload_len) - len);\n\n\t__skb_pull(skb, len);\n\tskb_postpull_rcsum(skb, udp_hdr(skb), len);\n\tskb_reset_transport_header(skb);\n\treturn iptunnel_pull_offloads(skb);\n}\n\nstatic int fou_udp_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct fou *fou = fou_from_sock(sk);\n\n\tif (!fou)\n\t\treturn 1;\n\n\tif (fou_recv_pull(skb, fou, sizeof(struct udphdr)))\n\t\tgoto drop;\n\n\treturn -fou->protocol;\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic struct guehdr *gue_remcsum(struct sk_buff *skb, struct guehdr *guehdr,\n\t\t\t\t  void *data, size_t hdrlen, u8 ipproto,\n\t\t\t\t  bool nopartial)\n{\n\t__be16 *pd = data;\n\tsize_t start = ntohs(pd[0]);\n\tsize_t offset = ntohs(pd[1]);\n\tsize_t plen = sizeof(struct udphdr) + hdrlen +\n\t    max_t(size_t, offset + sizeof(u16), start);\n\n\tif (skb->remcsum_offload)\n\t\treturn guehdr;\n\n\tif (!pskb_may_pull(skb, plen))\n\t\treturn NULL;\n\tguehdr = (struct guehdr *)&udp_hdr(skb)[1];\n\n\tskb_remcsum_process(skb, (void *)guehdr + hdrlen,\n\t\t\t    start, offset, nopartial);\n\n\treturn guehdr;\n}\n\nstatic int gue_control_message(struct sk_buff *skb, struct guehdr *guehdr)\n{\n\t \n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int gue_udp_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct fou *fou = fou_from_sock(sk);\n\tsize_t len, optlen, hdrlen;\n\tstruct guehdr *guehdr;\n\tvoid *data;\n\tu16 doffset = 0;\n\tu8 proto_ctype;\n\n\tif (!fou)\n\t\treturn 1;\n\n\tlen = sizeof(struct udphdr) + sizeof(struct guehdr);\n\tif (!pskb_may_pull(skb, len))\n\t\tgoto drop;\n\n\tguehdr = (struct guehdr *)&udp_hdr(skb)[1];\n\n\tswitch (guehdr->version) {\n\tcase 0:  \n\t\tbreak;\n\n\tcase 1: {\n\t\t \n\n\t\tint prot;\n\n\t\tswitch (((struct iphdr *)guehdr)->version) {\n\t\tcase 4:\n\t\t\tprot = IPPROTO_IPIP;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprot = IPPROTO_IPV6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (fou_recv_pull(skb, fou, sizeof(struct udphdr)))\n\t\t\tgoto drop;\n\n\t\treturn -prot;\n\t}\n\n\tdefault:  \n\t\tgoto drop;\n\t}\n\n\toptlen = guehdr->hlen << 2;\n\tlen += optlen;\n\n\tif (!pskb_may_pull(skb, len))\n\t\tgoto drop;\n\n\t \n\tguehdr = (struct guehdr *)&udp_hdr(skb)[1];\n\n\tif (validate_gue_flags(guehdr, optlen))\n\t\tgoto drop;\n\n\thdrlen = sizeof(struct guehdr) + optlen;\n\n\tif (fou->family == AF_INET)\n\t\tip_hdr(skb)->tot_len = htons(ntohs(ip_hdr(skb)->tot_len) - len);\n\telse\n\t\tipv6_hdr(skb)->payload_len =\n\t\t    htons(ntohs(ipv6_hdr(skb)->payload_len) - len);\n\n\t \n\tskb_postpull_rcsum(skb, udp_hdr(skb), len);\n\n\tdata = &guehdr[1];\n\n\tif (guehdr->flags & GUE_FLAG_PRIV) {\n\t\t__be32 flags = *(__be32 *)(data + doffset);\n\n\t\tdoffset += GUE_LEN_PRIV;\n\n\t\tif (flags & GUE_PFLAG_REMCSUM) {\n\t\t\tguehdr = gue_remcsum(skb, guehdr, data + doffset,\n\t\t\t\t\t     hdrlen, guehdr->proto_ctype,\n\t\t\t\t\t     !!(fou->flags &\n\t\t\t\t\t\tFOU_F_REMCSUM_NOPARTIAL));\n\t\t\tif (!guehdr)\n\t\t\t\tgoto drop;\n\n\t\t\tdata = &guehdr[1];\n\n\t\t\tdoffset += GUE_PLEN_REMCSUM;\n\t\t}\n\t}\n\n\tif (unlikely(guehdr->control))\n\t\treturn gue_control_message(skb, guehdr);\n\n\tproto_ctype = guehdr->proto_ctype;\n\t__skb_pull(skb, sizeof(struct udphdr) + hdrlen);\n\tskb_reset_transport_header(skb);\n\n\tif (iptunnel_pull_offloads(skb))\n\t\tgoto drop;\n\n\treturn -proto_ctype;\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic struct sk_buff *fou_gro_receive(struct sock *sk,\n\t\t\t\t       struct list_head *head,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tconst struct net_offload __rcu **offloads;\n\tu8 proto = fou_from_sock(sk)->protocol;\n\tconst struct net_offload *ops;\n\tstruct sk_buff *pp = NULL;\n\n\t \n\tNAPI_GRO_CB(skb)->encap_mark = 0;\n\n\t \n\tNAPI_GRO_CB(skb)->is_fou = 1;\n\n\toffloads = NAPI_GRO_CB(skb)->is_ipv6 ? inet6_offloads : inet_offloads;\n\tops = rcu_dereference(offloads[proto]);\n\tif (!ops || !ops->callbacks.gro_receive)\n\t\tgoto out;\n\n\tpp = call_gro_receive(ops->callbacks.gro_receive, head, skb);\n\nout:\n\treturn pp;\n}\n\nstatic int fou_gro_complete(struct sock *sk, struct sk_buff *skb,\n\t\t\t    int nhoff)\n{\n\tconst struct net_offload __rcu **offloads;\n\tu8 proto = fou_from_sock(sk)->protocol;\n\tconst struct net_offload *ops;\n\tint err = -ENOSYS;\n\n\toffloads = NAPI_GRO_CB(skb)->is_ipv6 ? inet6_offloads : inet_offloads;\n\tops = rcu_dereference(offloads[proto]);\n\tif (WARN_ON(!ops || !ops->callbacks.gro_complete))\n\t\tgoto out;\n\n\terr = ops->callbacks.gro_complete(skb, nhoff);\n\n\tskb_set_inner_mac_header(skb, nhoff);\n\nout:\n\treturn err;\n}\n\nstatic struct guehdr *gue_gro_remcsum(struct sk_buff *skb, unsigned int off,\n\t\t\t\t      struct guehdr *guehdr, void *data,\n\t\t\t\t      size_t hdrlen, struct gro_remcsum *grc,\n\t\t\t\t      bool nopartial)\n{\n\t__be16 *pd = data;\n\tsize_t start = ntohs(pd[0]);\n\tsize_t offset = ntohs(pd[1]);\n\n\tif (skb->remcsum_offload)\n\t\treturn guehdr;\n\n\tif (!NAPI_GRO_CB(skb)->csum_valid)\n\t\treturn NULL;\n\n\tguehdr = skb_gro_remcsum_process(skb, (void *)guehdr, off, hdrlen,\n\t\t\t\t\t start, offset, grc, nopartial);\n\n\tskb->remcsum_offload = 1;\n\n\treturn guehdr;\n}\n\nstatic struct sk_buff *gue_gro_receive(struct sock *sk,\n\t\t\t\t       struct list_head *head,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tconst struct net_offload __rcu **offloads;\n\tconst struct net_offload *ops;\n\tstruct sk_buff *pp = NULL;\n\tstruct sk_buff *p;\n\tstruct guehdr *guehdr;\n\tsize_t len, optlen, hdrlen, off;\n\tvoid *data;\n\tu16 doffset = 0;\n\tint flush = 1;\n\tstruct fou *fou = fou_from_sock(sk);\n\tstruct gro_remcsum grc;\n\tu8 proto;\n\n\tskb_gro_remcsum_init(&grc);\n\n\toff = skb_gro_offset(skb);\n\tlen = off + sizeof(*guehdr);\n\n\tguehdr = skb_gro_header(skb, len, off);\n\tif (unlikely(!guehdr))\n\t\tgoto out;\n\n\tswitch (guehdr->version) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tswitch (((struct iphdr *)guehdr)->version) {\n\t\tcase 4:\n\t\t\tproto = IPPROTO_IPIP;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tproto = IPPROTO_IPV6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\tgoto next_proto;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\toptlen = guehdr->hlen << 2;\n\tlen += optlen;\n\n\tif (skb_gro_header_hard(skb, len)) {\n\t\tguehdr = skb_gro_header_slow(skb, len, off);\n\t\tif (unlikely(!guehdr))\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(guehdr->control) || guehdr->version != 0 ||\n\t    validate_gue_flags(guehdr, optlen))\n\t\tgoto out;\n\n\thdrlen = sizeof(*guehdr) + optlen;\n\n\t \n\tskb_gro_postpull_rcsum(skb, guehdr, hdrlen);\n\n\tdata = &guehdr[1];\n\n\tif (guehdr->flags & GUE_FLAG_PRIV) {\n\t\t__be32 flags = *(__be32 *)(data + doffset);\n\n\t\tdoffset += GUE_LEN_PRIV;\n\n\t\tif (flags & GUE_PFLAG_REMCSUM) {\n\t\t\tguehdr = gue_gro_remcsum(skb, off, guehdr,\n\t\t\t\t\t\t data + doffset, hdrlen, &grc,\n\t\t\t\t\t\t !!(fou->flags &\n\t\t\t\t\t\t    FOU_F_REMCSUM_NOPARTIAL));\n\n\t\t\tif (!guehdr)\n\t\t\t\tgoto out;\n\n\t\t\tdata = &guehdr[1];\n\n\t\t\tdoffset += GUE_PLEN_REMCSUM;\n\t\t}\n\t}\n\n\tskb_gro_pull(skb, hdrlen);\n\n\tlist_for_each_entry(p, head, list) {\n\t\tconst struct guehdr *guehdr2;\n\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tguehdr2 = (struct guehdr *)(p->data + off);\n\n\t\t \n\t\tif (guehdr->word != guehdr2->word) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (guehdr->hlen && memcmp(&guehdr[1], &guehdr2[1],\n\t\t\t\t\t   guehdr->hlen << 2)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tproto = guehdr->proto_ctype;\n\nnext_proto:\n\n\t \n\tNAPI_GRO_CB(skb)->encap_mark = 0;\n\n\t \n\tNAPI_GRO_CB(skb)->is_fou = 1;\n\n\toffloads = NAPI_GRO_CB(skb)->is_ipv6 ? inet6_offloads : inet_offloads;\n\tops = rcu_dereference(offloads[proto]);\n\tif (WARN_ON_ONCE(!ops || !ops->callbacks.gro_receive))\n\t\tgoto out;\n\n\tpp = call_gro_receive(ops->callbacks.gro_receive, head, skb);\n\tflush = 0;\n\nout:\n\tskb_gro_flush_final_remcsum(skb, pp, flush, &grc);\n\n\treturn pp;\n}\n\nstatic int gue_gro_complete(struct sock *sk, struct sk_buff *skb, int nhoff)\n{\n\tstruct guehdr *guehdr = (struct guehdr *)(skb->data + nhoff);\n\tconst struct net_offload __rcu **offloads;\n\tconst struct net_offload *ops;\n\tunsigned int guehlen = 0;\n\tu8 proto;\n\tint err = -ENOENT;\n\n\tswitch (guehdr->version) {\n\tcase 0:\n\t\tproto = guehdr->proto_ctype;\n\t\tguehlen = sizeof(*guehdr) + (guehdr->hlen << 2);\n\t\tbreak;\n\tcase 1:\n\t\tswitch (((struct iphdr *)guehdr)->version) {\n\t\tcase 4:\n\t\t\tproto = IPPROTO_IPIP;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tproto = IPPROTO_IPV6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn err;\n\t}\n\n\toffloads = NAPI_GRO_CB(skb)->is_ipv6 ? inet6_offloads : inet_offloads;\n\tops = rcu_dereference(offloads[proto]);\n\tif (WARN_ON(!ops || !ops->callbacks.gro_complete))\n\t\tgoto out;\n\n\terr = ops->callbacks.gro_complete(skb, nhoff + guehlen);\n\n\tskb_set_inner_mac_header(skb, nhoff + guehlen);\n\nout:\n\treturn err;\n}\n\nstatic bool fou_cfg_cmp(struct fou *fou, struct fou_cfg *cfg)\n{\n\tstruct sock *sk = fou->sock->sk;\n\tstruct udp_port_cfg *udp_cfg = &cfg->udp_config;\n\n\tif (fou->family != udp_cfg->family ||\n\t    fou->port != udp_cfg->local_udp_port ||\n\t    sk->sk_dport != udp_cfg->peer_udp_port ||\n\t    sk->sk_bound_dev_if != udp_cfg->bind_ifindex)\n\t\treturn false;\n\n\tif (fou->family == AF_INET) {\n\t\tif (sk->sk_rcv_saddr != udp_cfg->local_ip.s_addr ||\n\t\t    sk->sk_daddr != udp_cfg->peer_ip.s_addr)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else {\n\t\tif (ipv6_addr_cmp(&sk->sk_v6_rcv_saddr, &udp_cfg->local_ip6) ||\n\t\t    ipv6_addr_cmp(&sk->sk_v6_daddr, &udp_cfg->peer_ip6))\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n#endif\n\t}\n\n\treturn false;\n}\n\nstatic int fou_add_to_port_list(struct net *net, struct fou *fou,\n\t\t\t\tstruct fou_cfg *cfg)\n{\n\tstruct fou_net *fn = net_generic(net, fou_net_id);\n\tstruct fou *fout;\n\n\tmutex_lock(&fn->fou_lock);\n\tlist_for_each_entry(fout, &fn->fou_list, list) {\n\t\tif (fou_cfg_cmp(fout, cfg)) {\n\t\t\tmutex_unlock(&fn->fou_lock);\n\t\t\treturn -EALREADY;\n\t\t}\n\t}\n\n\tlist_add(&fou->list, &fn->fou_list);\n\tmutex_unlock(&fn->fou_lock);\n\n\treturn 0;\n}\n\nstatic void fou_release(struct fou *fou)\n{\n\tstruct socket *sock = fou->sock;\n\n\tlist_del(&fou->list);\n\tudp_tunnel_sock_release(sock);\n\n\tkfree_rcu(fou, rcu);\n}\n\nstatic int fou_create(struct net *net, struct fou_cfg *cfg,\n\t\t      struct socket **sockp)\n{\n\tstruct socket *sock = NULL;\n\tstruct fou *fou = NULL;\n\tstruct sock *sk;\n\tstruct udp_tunnel_sock_cfg tunnel_cfg;\n\tint err;\n\n\t \n\terr = udp_sock_create(net, &cfg->udp_config, &sock);\n\tif (err < 0)\n\t\tgoto error;\n\n\t \n\tfou = kzalloc(sizeof(*fou), GFP_KERNEL);\n\tif (!fou) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tsk = sock->sk;\n\n\tfou->port = cfg->udp_config.local_udp_port;\n\tfou->family = cfg->udp_config.family;\n\tfou->flags = cfg->flags;\n\tfou->type = cfg->type;\n\tfou->sock = sock;\n\n\tmemset(&tunnel_cfg, 0, sizeof(tunnel_cfg));\n\ttunnel_cfg.encap_type = 1;\n\ttunnel_cfg.sk_user_data = fou;\n\ttunnel_cfg.encap_destroy = NULL;\n\n\t \n\tswitch (cfg->type) {\n\tcase FOU_ENCAP_DIRECT:\n\t\ttunnel_cfg.encap_rcv = fou_udp_recv;\n\t\ttunnel_cfg.gro_receive = fou_gro_receive;\n\t\ttunnel_cfg.gro_complete = fou_gro_complete;\n\t\tfou->protocol = cfg->protocol;\n\t\tbreak;\n\tcase FOU_ENCAP_GUE:\n\t\ttunnel_cfg.encap_rcv = gue_udp_recv;\n\t\ttunnel_cfg.gro_receive = gue_gro_receive;\n\t\ttunnel_cfg.gro_complete = gue_gro_complete;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tsetup_udp_tunnel_sock(net, sock, &tunnel_cfg);\n\n\tsk->sk_allocation = GFP_ATOMIC;\n\n\terr = fou_add_to_port_list(net, fou, cfg);\n\tif (err)\n\t\tgoto error;\n\n\tif (sockp)\n\t\t*sockp = sock;\n\n\treturn 0;\n\nerror:\n\tkfree(fou);\n\tif (sock)\n\t\tudp_tunnel_sock_release(sock);\n\n\treturn err;\n}\n\nstatic int fou_destroy(struct net *net, struct fou_cfg *cfg)\n{\n\tstruct fou_net *fn = net_generic(net, fou_net_id);\n\tint err = -EINVAL;\n\tstruct fou *fou;\n\n\tmutex_lock(&fn->fou_lock);\n\tlist_for_each_entry(fou, &fn->fou_list, list) {\n\t\tif (fou_cfg_cmp(fou, cfg)) {\n\t\t\tfou_release(fou);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&fn->fou_lock);\n\n\treturn err;\n}\n\nstatic struct genl_family fou_nl_family;\n\nstatic int parse_nl_config(struct genl_info *info,\n\t\t\t   struct fou_cfg *cfg)\n{\n\tbool has_local = false, has_peer = false;\n\tstruct nlattr *attr;\n\tint ifindex;\n\t__be16 port;\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\n\tcfg->udp_config.family = AF_INET;\n\n\tif (info->attrs[FOU_ATTR_AF]) {\n\t\tu8 family = nla_get_u8(info->attrs[FOU_ATTR_AF]);\n\n\t\tswitch (family) {\n\t\tcase AF_INET:\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tcfg->udp_config.ipv6_v6only = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tcfg->udp_config.family = family;\n\t}\n\n\tif (info->attrs[FOU_ATTR_PORT]) {\n\t\tport = nla_get_be16(info->attrs[FOU_ATTR_PORT]);\n\t\tcfg->udp_config.local_udp_port = port;\n\t}\n\n\tif (info->attrs[FOU_ATTR_IPPROTO])\n\t\tcfg->protocol = nla_get_u8(info->attrs[FOU_ATTR_IPPROTO]);\n\n\tif (info->attrs[FOU_ATTR_TYPE])\n\t\tcfg->type = nla_get_u8(info->attrs[FOU_ATTR_TYPE]);\n\n\tif (info->attrs[FOU_ATTR_REMCSUM_NOPARTIAL])\n\t\tcfg->flags |= FOU_F_REMCSUM_NOPARTIAL;\n\n\tif (cfg->udp_config.family == AF_INET) {\n\t\tif (info->attrs[FOU_ATTR_LOCAL_V4]) {\n\t\t\tattr = info->attrs[FOU_ATTR_LOCAL_V4];\n\t\t\tcfg->udp_config.local_ip.s_addr = nla_get_in_addr(attr);\n\t\t\thas_local = true;\n\t\t}\n\n\t\tif (info->attrs[FOU_ATTR_PEER_V4]) {\n\t\t\tattr = info->attrs[FOU_ATTR_PEER_V4];\n\t\t\tcfg->udp_config.peer_ip.s_addr = nla_get_in_addr(attr);\n\t\t\thas_peer = true;\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else {\n\t\tif (info->attrs[FOU_ATTR_LOCAL_V6]) {\n\t\t\tattr = info->attrs[FOU_ATTR_LOCAL_V6];\n\t\t\tcfg->udp_config.local_ip6 = nla_get_in6_addr(attr);\n\t\t\thas_local = true;\n\t\t}\n\n\t\tif (info->attrs[FOU_ATTR_PEER_V6]) {\n\t\t\tattr = info->attrs[FOU_ATTR_PEER_V6];\n\t\t\tcfg->udp_config.peer_ip6 = nla_get_in6_addr(attr);\n\t\t\thas_peer = true;\n\t\t}\n#endif\n\t}\n\n\tif (has_peer) {\n\t\tif (info->attrs[FOU_ATTR_PEER_PORT]) {\n\t\t\tport = nla_get_be16(info->attrs[FOU_ATTR_PEER_PORT]);\n\t\t\tcfg->udp_config.peer_udp_port = port;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[FOU_ATTR_IFINDEX]) {\n\t\tif (!has_local)\n\t\t\treturn -EINVAL;\n\n\t\tifindex = nla_get_s32(info->attrs[FOU_ATTR_IFINDEX]);\n\n\t\tcfg->udp_config.bind_ifindex = ifindex;\n\t}\n\n\treturn 0;\n}\n\nint fou_nl_add_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct fou_cfg cfg;\n\tint err;\n\n\terr = parse_nl_config(info, &cfg);\n\tif (err)\n\t\treturn err;\n\n\treturn fou_create(net, &cfg, NULL);\n}\n\nint fou_nl_del_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct fou_cfg cfg;\n\tint err;\n\n\terr = parse_nl_config(info, &cfg);\n\tif (err)\n\t\treturn err;\n\n\treturn fou_destroy(net, &cfg);\n}\n\nstatic int fou_fill_info(struct fou *fou, struct sk_buff *msg)\n{\n\tstruct sock *sk = fou->sock->sk;\n\n\tif (nla_put_u8(msg, FOU_ATTR_AF, fou->sock->sk->sk_family) ||\n\t    nla_put_be16(msg, FOU_ATTR_PORT, fou->port) ||\n\t    nla_put_be16(msg, FOU_ATTR_PEER_PORT, sk->sk_dport) ||\n\t    nla_put_u8(msg, FOU_ATTR_IPPROTO, fou->protocol) ||\n\t    nla_put_u8(msg, FOU_ATTR_TYPE, fou->type) ||\n\t    nla_put_s32(msg, FOU_ATTR_IFINDEX, sk->sk_bound_dev_if))\n\t\treturn -1;\n\n\tif (fou->flags & FOU_F_REMCSUM_NOPARTIAL)\n\t\tif (nla_put_flag(msg, FOU_ATTR_REMCSUM_NOPARTIAL))\n\t\t\treturn -1;\n\n\tif (fou->sock->sk->sk_family == AF_INET) {\n\t\tif (nla_put_in_addr(msg, FOU_ATTR_LOCAL_V4, sk->sk_rcv_saddr))\n\t\t\treturn -1;\n\n\t\tif (nla_put_in_addr(msg, FOU_ATTR_PEER_V4, sk->sk_daddr))\n\t\t\treturn -1;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else {\n\t\tif (nla_put_in6_addr(msg, FOU_ATTR_LOCAL_V6,\n\t\t\t\t     &sk->sk_v6_rcv_saddr))\n\t\t\treturn -1;\n\n\t\tif (nla_put_in6_addr(msg, FOU_ATTR_PEER_V6, &sk->sk_v6_daddr))\n\t\t\treturn -1;\n#endif\n\t}\n\n\treturn 0;\n}\n\nstatic int fou_dump_info(struct fou *fou, u32 portid, u32 seq,\n\t\t\t u32 flags, struct sk_buff *skb, u8 cmd)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, portid, seq, &fou_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tif (fou_fill_info(fou, skb) < 0)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nint fou_nl_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct fou_net *fn = net_generic(net, fou_net_id);\n\tstruct sk_buff *msg;\n\tstruct fou_cfg cfg;\n\tstruct fou *fout;\n\t__be16 port;\n\tu8 family;\n\tint ret;\n\n\tret = parse_nl_config(info, &cfg);\n\tif (ret)\n\t\treturn ret;\n\tport = cfg.udp_config.local_udp_port;\n\tif (port == 0)\n\t\treturn -EINVAL;\n\n\tfamily = cfg.udp_config.family;\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tret = -ESRCH;\n\tmutex_lock(&fn->fou_lock);\n\tlist_for_each_entry(fout, &fn->fou_list, list) {\n\t\tif (fou_cfg_cmp(fout, &cfg)) {\n\t\t\tret = fou_dump_info(fout, info->snd_portid,\n\t\t\t\t\t    info->snd_seq, 0, msg,\n\t\t\t\t\t    info->genlhdr->cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&fn->fou_lock);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\treturn genlmsg_reply(msg, info);\n\nout_free:\n\tnlmsg_free(msg);\n\treturn ret;\n}\n\nint fou_nl_get_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fou_net *fn = net_generic(net, fou_net_id);\n\tstruct fou *fout;\n\tint idx = 0, ret;\n\n\tmutex_lock(&fn->fou_lock);\n\tlist_for_each_entry(fout, &fn->fou_list, list) {\n\t\tif (idx++ < cb->args[0])\n\t\t\tcontinue;\n\t\tret = fou_dump_info(fout, NETLINK_CB(cb->skb).portid,\n\t\t\t\t    cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t    skb, FOU_CMD_GET);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&fn->fou_lock);\n\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic struct genl_family fou_nl_family __ro_after_init = {\n\t.hdrsize\t= 0,\n\t.name\t\t= FOU_GENL_NAME,\n\t.version\t= FOU_GENL_VERSION,\n\t.maxattr\t= FOU_ATTR_MAX,\n\t.policy\t\t= fou_nl_policy,\n\t.netnsok\t= true,\n\t.module\t\t= THIS_MODULE,\n\t.small_ops\t= fou_nl_ops,\n\t.n_small_ops\t= ARRAY_SIZE(fou_nl_ops),\n\t.resv_start_op\t= FOU_CMD_GET + 1,\n};\n\nsize_t fou_encap_hlen(struct ip_tunnel_encap *e)\n{\n\treturn sizeof(struct udphdr);\n}\nEXPORT_SYMBOL(fou_encap_hlen);\n\nsize_t gue_encap_hlen(struct ip_tunnel_encap *e)\n{\n\tsize_t len;\n\tbool need_priv = false;\n\n\tlen = sizeof(struct udphdr) + sizeof(struct guehdr);\n\n\tif (e->flags & TUNNEL_ENCAP_FLAG_REMCSUM) {\n\t\tlen += GUE_PLEN_REMCSUM;\n\t\tneed_priv = true;\n\t}\n\n\tlen += need_priv ? GUE_LEN_PRIV : 0;\n\n\treturn len;\n}\nEXPORT_SYMBOL(gue_encap_hlen);\n\nint __fou_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,\n\t\t       u8 *protocol, __be16 *sport, int type)\n{\n\tint err;\n\n\terr = iptunnel_handle_offloads(skb, type);\n\tif (err)\n\t\treturn err;\n\n\t*sport = e->sport ? : udp_flow_src_port(dev_net(skb->dev),\n\t\t\t\t\t\tskb, 0, 0, false);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__fou_build_header);\n\nint __gue_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,\n\t\t       u8 *protocol, __be16 *sport, int type)\n{\n\tstruct guehdr *guehdr;\n\tsize_t hdrlen, optlen = 0;\n\tvoid *data;\n\tbool need_priv = false;\n\tint err;\n\n\tif ((e->flags & TUNNEL_ENCAP_FLAG_REMCSUM) &&\n\t    skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\toptlen += GUE_PLEN_REMCSUM;\n\t\ttype |= SKB_GSO_TUNNEL_REMCSUM;\n\t\tneed_priv = true;\n\t}\n\n\toptlen += need_priv ? GUE_LEN_PRIV : 0;\n\n\terr = iptunnel_handle_offloads(skb, type);\n\tif (err)\n\t\treturn err;\n\n\t \n\t*sport = e->sport ? : udp_flow_src_port(dev_net(skb->dev),\n\t\t\t\t\t\tskb, 0, 0, false);\n\n\thdrlen = sizeof(struct guehdr) + optlen;\n\n\tskb_push(skb, hdrlen);\n\n\tguehdr = (struct guehdr *)skb->data;\n\n\tguehdr->control = 0;\n\tguehdr->version = 0;\n\tguehdr->hlen = optlen >> 2;\n\tguehdr->flags = 0;\n\tguehdr->proto_ctype = *protocol;\n\n\tdata = &guehdr[1];\n\n\tif (need_priv) {\n\t\t__be32 *flags = data;\n\n\t\tguehdr->flags |= GUE_FLAG_PRIV;\n\t\t*flags = 0;\n\t\tdata += GUE_LEN_PRIV;\n\n\t\tif (type & SKB_GSO_TUNNEL_REMCSUM) {\n\t\t\tu16 csum_start = skb_checksum_start_offset(skb);\n\t\t\t__be16 *pd = data;\n\n\t\t\tif (csum_start < hdrlen)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcsum_start -= hdrlen;\n\t\t\tpd[0] = htons(csum_start);\n\t\t\tpd[1] = htons(csum_start + skb->csum_offset);\n\n\t\t\tif (!skb_is_gso(skb)) {\n\t\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\t\tskb->encapsulation = 0;\n\t\t\t}\n\n\t\t\t*flags |= GUE_PFLAG_REMCSUM;\n\t\t\tdata += GUE_PLEN_REMCSUM;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(__gue_build_header);\n\n#ifdef CONFIG_NET_FOU_IP_TUNNELS\n\nstatic void fou_build_udp(struct sk_buff *skb, struct ip_tunnel_encap *e,\n\t\t\t  struct flowi4 *fl4, u8 *protocol, __be16 sport)\n{\n\tstruct udphdr *uh;\n\n\tskb_push(skb, sizeof(struct udphdr));\n\tskb_reset_transport_header(skb);\n\n\tuh = udp_hdr(skb);\n\n\tuh->dest = e->dport;\n\tuh->source = sport;\n\tuh->len = htons(skb->len);\n\tudp_set_csum(!(e->flags & TUNNEL_ENCAP_FLAG_CSUM), skb,\n\t\t     fl4->saddr, fl4->daddr, skb->len);\n\n\t*protocol = IPPROTO_UDP;\n}\n\nstatic int fou_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,\n\t\t\t    u8 *protocol, struct flowi4 *fl4)\n{\n\tint type = e->flags & TUNNEL_ENCAP_FLAG_CSUM ? SKB_GSO_UDP_TUNNEL_CSUM :\n\t\t\t\t\t\t       SKB_GSO_UDP_TUNNEL;\n\t__be16 sport;\n\tint err;\n\n\terr = __fou_build_header(skb, e, protocol, &sport, type);\n\tif (err)\n\t\treturn err;\n\n\tfou_build_udp(skb, e, fl4, protocol, sport);\n\n\treturn 0;\n}\n\nstatic int gue_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,\n\t\t\t    u8 *protocol, struct flowi4 *fl4)\n{\n\tint type = e->flags & TUNNEL_ENCAP_FLAG_CSUM ? SKB_GSO_UDP_TUNNEL_CSUM :\n\t\t\t\t\t\t       SKB_GSO_UDP_TUNNEL;\n\t__be16 sport;\n\tint err;\n\n\terr = __gue_build_header(skb, e, protocol, &sport, type);\n\tif (err)\n\t\treturn err;\n\n\tfou_build_udp(skb, e, fl4, protocol, sport);\n\n\treturn 0;\n}\n\nstatic int gue_err_proto_handler(int proto, struct sk_buff *skb, u32 info)\n{\n\tconst struct net_protocol *ipprot = rcu_dereference(inet_protos[proto]);\n\n\tif (ipprot && ipprot->err_handler) {\n\t\tif (!ipprot->err_handler(skb, info))\n\t\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int gue_err(struct sk_buff *skb, u32 info)\n{\n\tint transport_offset = skb_transport_offset(skb);\n\tstruct guehdr *guehdr;\n\tsize_t len, optlen;\n\tint ret;\n\n\tlen = sizeof(struct udphdr) + sizeof(struct guehdr);\n\tif (!pskb_may_pull(skb, transport_offset + len))\n\t\treturn -EINVAL;\n\n\tguehdr = (struct guehdr *)&udp_hdr(skb)[1];\n\n\tswitch (guehdr->version) {\n\tcase 0:  \n\t\tbreak;\n\tcase 1: {\n\t\t \n\t\tskb_set_transport_header(skb, -(int)sizeof(struct icmphdr));\n\n\t\tswitch (((struct iphdr *)guehdr)->version) {\n\t\tcase 4:\n\t\t\tret = gue_err_proto_handler(IPPROTO_IPIP, skb, info);\n\t\t\tgoto out;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase 6:\n\t\t\tret = gue_err_proto_handler(IPPROTO_IPV6, skb, info);\n\t\t\tgoto out;\n#endif\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdefault:  \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (guehdr->control)\n\t\treturn -ENOENT;\n\n\toptlen = guehdr->hlen << 2;\n\n\tif (!pskb_may_pull(skb, transport_offset + len + optlen))\n\t\treturn -EINVAL;\n\n\tguehdr = (struct guehdr *)&udp_hdr(skb)[1];\n\tif (validate_gue_flags(guehdr, optlen))\n\t\treturn -EINVAL;\n\n\t \n\tif (guehdr->proto_ctype == IPPROTO_UDP ||\n\t    guehdr->proto_ctype == IPPROTO_UDPLITE)\n\t\treturn -EOPNOTSUPP;\n\n\tskb_set_transport_header(skb, -(int)sizeof(struct icmphdr));\n\tret = gue_err_proto_handler(guehdr->proto_ctype, skb, info);\n\nout:\n\tskb_set_transport_header(skb, transport_offset);\n\treturn ret;\n}\n\n\nstatic const struct ip_tunnel_encap_ops fou_iptun_ops = {\n\t.encap_hlen = fou_encap_hlen,\n\t.build_header = fou_build_header,\n\t.err_handler = gue_err,\n};\n\nstatic const struct ip_tunnel_encap_ops gue_iptun_ops = {\n\t.encap_hlen = gue_encap_hlen,\n\t.build_header = gue_build_header,\n\t.err_handler = gue_err,\n};\n\nstatic int ip_tunnel_encap_add_fou_ops(void)\n{\n\tint ret;\n\n\tret = ip_tunnel_encap_add_ops(&fou_iptun_ops, TUNNEL_ENCAP_FOU);\n\tif (ret < 0) {\n\t\tpr_err(\"can't add fou ops\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ip_tunnel_encap_add_ops(&gue_iptun_ops, TUNNEL_ENCAP_GUE);\n\tif (ret < 0) {\n\t\tpr_err(\"can't add gue ops\\n\");\n\t\tip_tunnel_encap_del_ops(&fou_iptun_ops, TUNNEL_ENCAP_FOU);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ip_tunnel_encap_del_fou_ops(void)\n{\n\tip_tunnel_encap_del_ops(&fou_iptun_ops, TUNNEL_ENCAP_FOU);\n\tip_tunnel_encap_del_ops(&gue_iptun_ops, TUNNEL_ENCAP_GUE);\n}\n\n#else\n\nstatic int ip_tunnel_encap_add_fou_ops(void)\n{\n\treturn 0;\n}\n\nstatic void ip_tunnel_encap_del_fou_ops(void)\n{\n}\n\n#endif\n\nstatic __net_init int fou_init_net(struct net *net)\n{\n\tstruct fou_net *fn = net_generic(net, fou_net_id);\n\n\tINIT_LIST_HEAD(&fn->fou_list);\n\tmutex_init(&fn->fou_lock);\n\treturn 0;\n}\n\nstatic __net_exit void fou_exit_net(struct net *net)\n{\n\tstruct fou_net *fn = net_generic(net, fou_net_id);\n\tstruct fou *fou, *next;\n\n\t \n\tmutex_lock(&fn->fou_lock);\n\tlist_for_each_entry_safe(fou, next, &fn->fou_list, list)\n\t\tfou_release(fou);\n\tmutex_unlock(&fn->fou_lock);\n}\n\nstatic struct pernet_operations fou_net_ops = {\n\t.init = fou_init_net,\n\t.exit = fou_exit_net,\n\t.id   = &fou_net_id,\n\t.size = sizeof(struct fou_net),\n};\n\nstatic int __init fou_init(void)\n{\n\tint ret;\n\n\tret = register_pernet_device(&fou_net_ops);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = genl_register_family(&fou_nl_family);\n\tif (ret < 0)\n\t\tgoto unregister;\n\n\tret = register_fou_bpf();\n\tif (ret < 0)\n\t\tgoto kfunc_failed;\n\n\tret = ip_tunnel_encap_add_fou_ops();\n\tif (ret == 0)\n\t\treturn 0;\n\nkfunc_failed:\n\tgenl_unregister_family(&fou_nl_family);\nunregister:\n\tunregister_pernet_device(&fou_net_ops);\nexit:\n\treturn ret;\n}\n\nstatic void __exit fou_fini(void)\n{\n\tip_tunnel_encap_del_fou_ops();\n\tgenl_unregister_family(&fou_nl_family);\n\tunregister_pernet_device(&fou_net_ops);\n}\n\nmodule_init(fou_init);\nmodule_exit(fou_fini);\nMODULE_AUTHOR(\"Tom Herbert <therbert@google.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Foo over UDP\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}