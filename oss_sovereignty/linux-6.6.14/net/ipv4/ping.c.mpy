{
  "module_name": "ping.c",
  "hash_id": "b940203abcdf0a92f68569251688756c2ee91005ee727f968a15175764d3148a",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ping.c",
  "human_readable_source": "\n \n\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/mm.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <net/snmp.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/protocol.h>\n#include <linux/skbuff.h>\n#include <linux/proc_fs.h>\n#include <linux/export.h>\n#include <linux/bpf-cgroup.h>\n#include <net/sock.h>\n#include <net/ping.h>\n#include <net/udp.h>\n#include <net/route.h>\n#include <net/inet_common.h>\n#include <net/checksum.h>\n\n#if IS_ENABLED(CONFIG_IPV6)\n#include <linux/in6.h>\n#include <linux/icmpv6.h>\n#include <net/addrconf.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#endif\n\nstruct ping_table {\n\tstruct hlist_head\thash[PING_HTABLE_SIZE];\n\tspinlock_t\t\tlock;\n};\n\nstatic struct ping_table ping_table;\nstruct pingv6_ops pingv6_ops;\nEXPORT_SYMBOL_GPL(pingv6_ops);\n\nstatic u16 ping_port_rover;\n\nstatic inline u32 ping_hashfn(const struct net *net, u32 num, u32 mask)\n{\n\tu32 res = (num + net_hash_mix(net)) & mask;\n\n\tpr_debug(\"hash(%u) = %u\\n\", num, res);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(ping_hash);\n\nstatic inline struct hlist_head *ping_hashslot(struct ping_table *table,\n\t\t\t\t\t       struct net *net, unsigned int num)\n{\n\treturn &table->hash[ping_hashfn(net, num, PING_HTABLE_MASK)];\n}\n\nint ping_get_port(struct sock *sk, unsigned short ident)\n{\n\tstruct inet_sock *isk, *isk2;\n\tstruct hlist_head *hlist;\n\tstruct sock *sk2 = NULL;\n\n\tisk = inet_sk(sk);\n\tspin_lock(&ping_table.lock);\n\tif (ident == 0) {\n\t\tu32 i;\n\t\tu16 result = ping_port_rover + 1;\n\n\t\tfor (i = 0; i < (1L << 16); i++, result++) {\n\t\t\tif (!result)\n\t\t\t\tresult++;  \n\t\t\thlist = ping_hashslot(&ping_table, sock_net(sk),\n\t\t\t\t\t    result);\n\t\t\tsk_for_each(sk2, hlist) {\n\t\t\t\tisk2 = inet_sk(sk2);\n\n\t\t\t\tif (isk2->inet_num == result)\n\t\t\t\t\tgoto next_port;\n\t\t\t}\n\n\t\t\t \n\t\t\tping_port_rover = ident = result;\n\t\t\tbreak;\nnext_port:\n\t\t\t;\n\t\t}\n\t\tif (i >= (1L << 16))\n\t\t\tgoto fail;\n\t} else {\n\t\thlist = ping_hashslot(&ping_table, sock_net(sk), ident);\n\t\tsk_for_each(sk2, hlist) {\n\t\t\tisk2 = inet_sk(sk2);\n\n\t\t\t \n\t\t\tif ((isk2->inet_num == ident) &&\n\t\t\t    (sk2 != sk) &&\n\t\t\t    (!sk2->sk_reuse || !sk->sk_reuse))\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tpr_debug(\"found port/ident = %d\\n\", ident);\n\tisk->inet_num = ident;\n\tif (sk_unhashed(sk)) {\n\t\tpr_debug(\"was not hashed\\n\");\n\t\tsk_add_node_rcu(sk, hlist);\n\t\tsock_set_flag(sk, SOCK_RCU_FREE);\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t}\n\tspin_unlock(&ping_table.lock);\n\treturn 0;\n\nfail:\n\tspin_unlock(&ping_table.lock);\n\treturn -EADDRINUSE;\n}\nEXPORT_SYMBOL_GPL(ping_get_port);\n\nint ping_hash(struct sock *sk)\n{\n\tpr_debug(\"ping_hash(sk->port=%u)\\n\", inet_sk(sk)->inet_num);\n\tBUG();  \n\n\treturn 0;\n}\n\nvoid ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tspin_lock(&ping_table.lock);\n\tif (sk_del_node_init_rcu(sk)) {\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t}\n\tspin_unlock(&ping_table.lock);\n}\nEXPORT_SYMBOL_GPL(ping_unhash);\n\n \nstatic struct sock *ping_lookup(struct net *net, struct sk_buff *skb, u16 ident)\n{\n\tstruct hlist_head *hslot = ping_hashslot(&ping_table, net, ident);\n\tstruct sock *sk = NULL;\n\tstruct inet_sock *isk;\n\tint dif, sdif;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tdif = inet_iif(skb);\n\t\tsdif = inet_sdif(skb);\n\t\tpr_debug(\"try to find: num = %d, daddr = %pI4, dif = %d\\n\",\n\t\t\t (int)ident, &ip_hdr(skb)->daddr, dif);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tdif = inet6_iif(skb);\n\t\tsdif = inet6_sdif(skb);\n\t\tpr_debug(\"try to find: num = %d, daddr = %pI6c, dif = %d\\n\",\n\t\t\t (int)ident, &ipv6_hdr(skb)->daddr, dif);\n#endif\n\t} else {\n\t\treturn NULL;\n\t}\n\n\tsk_for_each_rcu(sk, hslot) {\n\t\tisk = inet_sk(sk);\n\n\t\tpr_debug(\"iterate\\n\");\n\t\tif (isk->inet_num != ident)\n\t\t\tcontinue;\n\n\t\tif (skb->protocol == htons(ETH_P_IP) &&\n\t\t    sk->sk_family == AF_INET) {\n\t\t\tpr_debug(\"found: %p: num=%d, daddr=%pI4, dif=%d\\n\", sk,\n\t\t\t\t (int) isk->inet_num, &isk->inet_rcv_saddr,\n\t\t\t\t sk->sk_bound_dev_if);\n\n\t\t\tif (isk->inet_rcv_saddr &&\n\t\t\t    isk->inet_rcv_saddr != ip_hdr(skb)->daddr)\n\t\t\t\tcontinue;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else if (skb->protocol == htons(ETH_P_IPV6) &&\n\t\t\t   sk->sk_family == AF_INET6) {\n\n\t\t\tpr_debug(\"found: %p: num=%d, daddr=%pI6c, dif=%d\\n\", sk,\n\t\t\t\t (int) isk->inet_num,\n\t\t\t\t &sk->sk_v6_rcv_saddr,\n\t\t\t\t sk->sk_bound_dev_if);\n\n\t\t\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr) &&\n\t\t\t    !ipv6_addr_equal(&sk->sk_v6_rcv_saddr,\n\t\t\t\t\t     &ipv6_hdr(skb)->daddr))\n\t\t\t\tcontinue;\n#endif\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif &&\n\t\t    sk->sk_bound_dev_if != sdif)\n\t\t\tcontinue;\n\n\t\tgoto exit;\n\t}\n\n\tsk = NULL;\nexit:\n\n\treturn sk;\n}\n\nstatic void inet_get_ping_group_range_net(struct net *net, kgid_t *low,\n\t\t\t\t\t  kgid_t *high)\n{\n\tkgid_t *data = net->ipv4.ping_group_range.range;\n\tunsigned int seq;\n\n\tdo {\n\t\tseq = read_seqbegin(&net->ipv4.ping_group_range.lock);\n\n\t\t*low = data[0];\n\t\t*high = data[1];\n\t} while (read_seqretry(&net->ipv4.ping_group_range.lock, seq));\n}\n\n\nint ping_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tkgid_t group = current_egid();\n\tstruct group_info *group_info;\n\tint i;\n\tkgid_t low, high;\n\tint ret = 0;\n\n\tif (sk->sk_family == AF_INET6)\n\t\tsk->sk_ipv6only = 1;\n\n\tinet_get_ping_group_range_net(net, &low, &high);\n\tif (gid_lte(low, group) && gid_lte(group, high))\n\t\treturn 0;\n\n\tgroup_info = get_current_groups();\n\tfor (i = 0; i < group_info->ngroups; i++) {\n\t\tkgid_t gid = group_info->gid[i];\n\n\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n\t\t\tgoto out_release_group;\n\t}\n\n\tret = -EACCES;\n\nout_release_group:\n\tput_group_info(group_info);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ping_init_sock);\n\nvoid ping_close(struct sock *sk, long timeout)\n{\n\tpr_debug(\"ping_close(sk=%p,sk->num=%u)\\n\",\n\t\t inet_sk(sk), inet_sk(sk)->inet_num);\n\tpr_debug(\"isk->refcnt = %d\\n\", refcount_read(&sk->sk_refcnt));\n\n\tsk_common_release(sk);\n}\nEXPORT_SYMBOL_GPL(ping_close);\n\nstatic int ping_pre_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t    int addr_len)\n{\n\t \n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\treturn BPF_CGROUP_RUN_PROG_INET4_CONNECT_LOCK(sk, uaddr);\n}\n\n \nstatic int ping_check_bind_addr(struct sock *sk, struct inet_sock *isk,\n\t\t\t\tstruct sockaddr *uaddr, int addr_len)\n{\n\tstruct net *net = sock_net(sk);\n\tif (sk->sk_family == AF_INET) {\n\t\tstruct sockaddr_in *addr = (struct sockaddr_in *) uaddr;\n\t\tu32 tb_id = RT_TABLE_LOCAL;\n\t\tint chk_addr_ret;\n\n\t\tif (addr_len < sizeof(*addr))\n\t\t\treturn -EINVAL;\n\n\t\tif (addr->sin_family != AF_INET &&\n\t\t    !(addr->sin_family == AF_UNSPEC &&\n\t\t      addr->sin_addr.s_addr == htonl(INADDR_ANY)))\n\t\t\treturn -EAFNOSUPPORT;\n\n\t\tpr_debug(\"ping_check_bind_addr(sk=%p,addr=%pI4,port=%d)\\n\",\n\t\t\t sk, &addr->sin_addr.s_addr, ntohs(addr->sin_port));\n\n\t\tif (addr->sin_addr.s_addr == htonl(INADDR_ANY))\n\t\t\treturn 0;\n\n\t\ttb_id = l3mdev_fib_table_by_index(net, sk->sk_bound_dev_if) ? : tb_id;\n\t\tchk_addr_ret = inet_addr_type_table(net, addr->sin_addr.s_addr, tb_id);\n\n\t\tif (chk_addr_ret == RTN_MULTICAST ||\n\t\t    chk_addr_ret == RTN_BROADCAST ||\n\t\t    (chk_addr_ret != RTN_LOCAL &&\n\t\t     !inet_can_nonlocal_bind(net, isk)))\n\t\t\treturn -EADDRNOTAVAIL;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (sk->sk_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) uaddr;\n\t\tint addr_type, scoped, has_addr;\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (addr_len < sizeof(*addr))\n\t\t\treturn -EINVAL;\n\n\t\tif (addr->sin6_family != AF_INET6)\n\t\t\treturn -EAFNOSUPPORT;\n\n\t\tpr_debug(\"ping_check_bind_addr(sk=%p,addr=%pI6c,port=%d)\\n\",\n\t\t\t sk, addr->sin6_addr.s6_addr, ntohs(addr->sin6_port));\n\n\t\taddr_type = ipv6_addr_type(&addr->sin6_addr);\n\t\tscoped = __ipv6_addr_needs_scope_id(addr_type);\n\t\tif ((addr_type != IPV6_ADDR_ANY &&\n\t\t     !(addr_type & IPV6_ADDR_UNICAST)) ||\n\t\t    (scoped && !addr->sin6_scope_id))\n\t\t\treturn -EINVAL;\n\n\t\trcu_read_lock();\n\t\tif (addr->sin6_scope_id) {\n\t\t\tdev = dev_get_by_index_rcu(net, addr->sin6_scope_id);\n\t\t\tif (!dev) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\n\t\tif (!dev && sk->sk_bound_dev_if) {\n\t\t\tdev = dev_get_by_index_rcu(net, sk->sk_bound_dev_if);\n\t\t\tif (!dev) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t\thas_addr = pingv6_ops.ipv6_chk_addr(net, &addr->sin6_addr, dev,\n\t\t\t\t\t\t    scoped);\n\t\trcu_read_unlock();\n\n\t\tif (!(ipv6_can_nonlocal_bind(net, isk) || has_addr ||\n\t\t      addr_type == IPV6_ADDR_ANY))\n\t\t\treturn -EADDRNOTAVAIL;\n\n\t\tif (scoped)\n\t\t\tsk->sk_bound_dev_if = addr->sin6_scope_id;\n#endif\n\t} else {\n\t\treturn -EAFNOSUPPORT;\n\t}\n\treturn 0;\n}\n\nstatic void ping_set_saddr(struct sock *sk, struct sockaddr *saddr)\n{\n\tif (saddr->sa_family == AF_INET) {\n\t\tstruct inet_sock *isk = inet_sk(sk);\n\t\tstruct sockaddr_in *addr = (struct sockaddr_in *) saddr;\n\t\tisk->inet_rcv_saddr = isk->inet_saddr = addr->sin_addr.s_addr;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (saddr->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) saddr;\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tsk->sk_v6_rcv_saddr = np->saddr = addr->sin6_addr;\n#endif\n\t}\n}\n\n \n\nint ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tunsigned short snum;\n\tint err;\n\tint dif = sk->sk_bound_dev_if;\n\n\terr = ping_check_bind_addr(sk, isk, uaddr, addr_len);\n\tif (err)\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (isk->inet_num != 0)\n\t\tgoto out;\n\n\terr = -EADDRINUSE;\n\tsnum = ntohs(((struct sockaddr_in *)uaddr)->sin_port);\n\tif (ping_get_port(sk, snum) != 0) {\n\t\t \n\t\tsk->sk_bound_dev_if = dif;\n\t\tgoto out;\n\t}\n\tping_set_saddr(sk, uaddr);\n\n\tpr_debug(\"after bind(): num = %hu, dif = %d\\n\",\n\t\t isk->inet_num,\n\t\t sk->sk_bound_dev_if);\n\n\terr = 0;\n\tif (sk->sk_family == AF_INET && isk->inet_rcv_saddr)\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6 && !ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n#endif\n\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tisk->inet_sport = htons(isk->inet_num);\n\tisk->inet_daddr = 0;\n\tisk->inet_dport = 0;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\tmemset(&sk->sk_v6_daddr, 0, sizeof(sk->sk_v6_daddr));\n#endif\n\n\tsk_dst_reset(sk);\nout:\n\trelease_sock(sk);\n\tpr_debug(\"ping_v4_bind -> %d\\n\", err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ping_bind);\n\n \n\nstatic inline int ping_supported(int family, int type, int code)\n{\n\treturn (family == AF_INET && type == ICMP_ECHO && code == 0) ||\n\t       (family == AF_INET && type == ICMP_EXT_ECHO && code == 0) ||\n\t       (family == AF_INET6 && type == ICMPV6_ECHO_REQUEST && code == 0) ||\n\t       (family == AF_INET6 && type == ICMPV6_EXT_ECHO_REQUEST && code == 0);\n}\n\n \n\nvoid ping_err(struct sk_buff *skb, int offset, u32 info)\n{\n\tint family;\n\tstruct icmphdr *icmph;\n\tstruct inet_sock *inet_sock;\n\tint type;\n\tint code;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tint harderr;\n\tint err;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tfamily = AF_INET;\n\t\ttype = icmp_hdr(skb)->type;\n\t\tcode = icmp_hdr(skb)->code;\n\t\ticmph = (struct icmphdr *)(skb->data + offset);\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tfamily = AF_INET6;\n\t\ttype = icmp6_hdr(skb)->icmp6_type;\n\t\tcode = icmp6_hdr(skb)->icmp6_code;\n\t\ticmph = (struct icmphdr *) (skb->data + offset);\n\t} else {\n\t\tBUG();\n\t}\n\n\t \n\n\tif (!ping_supported(family, icmph->type, icmph->code))\n\t\treturn;\n\n\tpr_debug(\"ping_err(proto=0x%x,type=%d,code=%d,id=%04x,seq=%04x)\\n\",\n\t\t skb->protocol, type, code, ntohs(icmph->un.echo.id),\n\t\t ntohs(icmph->un.echo.sequence));\n\n\tsk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));\n\tif (!sk) {\n\t\tpr_debug(\"no socket, dropping\\n\");\n\t\treturn;\t \n\t}\n\tpr_debug(\"err on socket %p\\n\", sk);\n\n\terr = 0;\n\tharderr = 0;\n\tinet_sock = inet_sk(sk);\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tswitch (type) {\n\t\tdefault:\n\t\tcase ICMP_TIME_EXCEEDED:\n\t\t\terr = EHOSTUNREACH;\n\t\t\tbreak;\n\t\tcase ICMP_SOURCE_QUENCH:\n\t\t\t \n\t\t\terr = EREMOTEIO;\n\t\t\tbreak;\n\t\tcase ICMP_PARAMETERPROB:\n\t\t\terr = EPROTO;\n\t\t\tharderr = 1;\n\t\t\tbreak;\n\t\tcase ICMP_DEST_UNREACH:\n\t\t\tif (code == ICMP_FRAG_NEEDED) {  \n\t\t\t\tipv4_sk_update_pmtu(skb, sk, info);\n\t\t\t\tif (inet_sock->pmtudisc != IP_PMTUDISC_DONT) {\n\t\t\t\t\terr = EMSGSIZE;\n\t\t\t\t\tharderr = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = EHOSTUNREACH;\n\t\t\tif (code <= NR_ICMP_UNREACH) {\n\t\t\t\tharderr = icmp_err_convert[code].fatal;\n\t\t\t\terr = icmp_err_convert[code].errno;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ICMP_REDIRECT:\n\t\t\t \n\t\t\tipv4_sk_redirect(skb, sk);\n\t\t\terr = EREMOTEIO;\n\t\t\tbreak;\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tharderr = pingv6_ops.icmpv6_err_convert(type, code, &err);\n#endif\n\t}\n\n\t \n\tif ((family == AF_INET && !inet_test_bit(RECVERR, sk)) ||\n\t    (family == AF_INET6 && !inet6_sk(sk)->recverr)) {\n\t\tif (!harderr || sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t} else {\n\t\tif (family == AF_INET) {\n\t\t\tip_icmp_error(sk, skb, err, 0  ,\n\t\t\t\t      info, (u8 *)icmph);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else if (family == AF_INET6) {\n\t\t\tpingv6_ops.ipv6_icmp_error(sk, skb, err, 0,\n\t\t\t\t\t\t   info, (u8 *)icmph);\n#endif\n\t\t}\n\t}\n\tsk->sk_err = err;\n\tsk_error_report(sk);\nout:\n\treturn;\n}\nEXPORT_SYMBOL_GPL(ping_err);\n\n \n\nint ping_getfrag(void *from, char *to,\n\t\t int offset, int fraglen, int odd, struct sk_buff *skb)\n{\n\tstruct pingfakehdr *pfh = from;\n\n\tif (!csum_and_copy_from_iter_full(to, fraglen, &pfh->wcheck,\n\t\t\t\t\t  &pfh->msg->msg_iter))\n\t\treturn -EFAULT;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t \n\tif (pfh->family == AF_INET6) {\n\t\tskb->csum = csum_block_add(skb->csum, pfh->wcheck, odd);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tpfh->wcheck = 0;\n\t}\n#endif\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ping_getfrag);\n\nstatic int ping_v4_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh,\n\t\t\t\t       struct flowi4 *fl4)\n{\n\tstruct sk_buff *skb = skb_peek(&sk->sk_write_queue);\n\n\tif (!skb)\n\t\treturn 0;\n\tpfh->wcheck = csum_partial((char *)&pfh->icmph,\n\t\tsizeof(struct icmphdr), pfh->wcheck);\n\tpfh->icmph.checksum = csum_fold(pfh->wcheck);\n\tmemcpy(icmp_hdr(skb), &pfh->icmph, sizeof(struct icmphdr));\n\tskb->ip_summed = CHECKSUM_NONE;\n\treturn ip_push_pending_frames(sk, fl4);\n}\n\nint ping_common_sendmsg(int family, struct msghdr *msg, size_t len,\n\t\t\tvoid *user_icmph, size_t icmph_len)\n{\n\tu8 type, code;\n\n\tif (len > 0xFFFF)\n\t\treturn -EMSGSIZE;\n\n\t \n\tif (len < icmph_len)\n\t\treturn -EINVAL;\n\n\t \n\n\t \n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (memcpy_from_msg(user_icmph, msg, icmph_len))\n\t\treturn -EFAULT;\n\n\tif (family == AF_INET) {\n\t\ttype = ((struct icmphdr *) user_icmph)->type;\n\t\tcode = ((struct icmphdr *) user_icmph)->code;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\ttype = ((struct icmp6hdr *) user_icmph)->icmp6_type;\n\t\tcode = ((struct icmp6hdr *) user_icmph)->icmp6_code;\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (!ping_supported(family, type, code))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ping_common_sendmsg);\n\nstatic int ping_v4_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct icmphdr user_icmph;\n\tstruct pingfakehdr pfh;\n\tstruct rtable *rt = NULL;\n\tstruct ip_options_data opt_copy;\n\tint free = 0;\n\t__be32 saddr, daddr, faddr;\n\tu8 tos, scope;\n\tint err;\n\n\tpr_debug(\"ping_v4_sendmsg(sk=%p,sk->num=%u)\\n\", inet, inet->inet_num);\n\n\terr = ping_common_sendmsg(AF_INET, msg, len, &user_icmph,\n\t\t\t\t  sizeof(user_icmph));\n\tif (err)\n\t\treturn err;\n\n\t \n\n\tif (msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\treturn -EINVAL;\n\t\tif (usin->sin_family != AF_INET)\n\t\t\treturn -EAFNOSUPPORT;\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t \n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = inet->inet_daddr;\n\t\t \n\t}\n\n\tipcm_init_sk(&ipc, inet);\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sk, msg, &ipc, false);\n\t\tif (unlikely(err)) {\n\t\t\tkfree(ipc.opt);\n\t\t\treturn err;\n\t\t}\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = faddr = daddr;\n\n\tif (ipc.opt && ipc.opt->opt.srr) {\n\t\tif (!daddr) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tfaddr = ipc.opt->opt.faddr;\n\t}\n\ttos = get_rttos(&ipc, inet);\n\tscope = ip_sendmsg_scope(inet, &ipc, msg);\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif || netif_index_is_l3_master(sock_net(sk), ipc.oif))\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t} else if (!ipc.oif)\n\t\tipc.oif = inet->uc_index;\n\n\tflowi4_init_output(&fl4, ipc.oif, ipc.sockc.mark, tos, scope,\n\t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk), faddr,\n\t\t\t   saddr, 0, 0, sk->sk_uid);\n\n\tfl4.fl4_icmp_type = user_icmph.type;\n\tfl4.fl4_icmp_code = user_icmph.code;\n\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi_common(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tif (err == -ENETUNREACH)\n\t\t\tIP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);\n\t\tgoto out;\n\t}\n\n\terr = -EACCES;\n\tif ((rt->rt_flags & RTCF_BROADCAST) &&\n\t    !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto out;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (!ipc.addr)\n\t\tipc.addr = fl4.daddr;\n\n\tlock_sock(sk);\n\n\tpfh.icmph.type = user_icmph.type;  \n\tpfh.icmph.code = user_icmph.code;  \n\tpfh.icmph.checksum = 0;\n\tpfh.icmph.un.echo.id = inet->inet_sport;\n\tpfh.icmph.un.echo.sequence = user_icmph.un.echo.sequence;\n\tpfh.msg = msg;\n\tpfh.wcheck = 0;\n\tpfh.family = AF_INET;\n\n\terr = ip_append_data(sk, &fl4, ping_getfrag, &pfh, len,\n\t\t\t     sizeof(struct icmphdr), &ipc, &rt,\n\t\t\t     msg->msg_flags);\n\tif (err)\n\t\tip_flush_pending_frames(sk);\n\telse\n\t\terr = ping_v4_push_pending_frames(sk, &pfh, &fl4);\n\trelease_sock(sk);\n\nout:\n\tip_rt_put(rt);\nout_free:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tif (!err) {\n\t\ticmp_out_count(sock_net(sk), user_icmph.type);\n\t\treturn len;\n\t}\n\treturn err;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(&rt->dst, &fl4.daddr);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}\n\nint ping_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int flags,\n\t\t int *addr_len)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tint family = sk->sk_family;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\n\tpr_debug(\"ping_recvmsg(sk=%p,sk->num=%u)\\n\", isk, isk->inet_num);\n\n\terr = -EOPNOTSUPP;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn inet_recv_error(sk, msg, len, addr_len);\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t \n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t \n\tif (family == AF_INET) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n\t\t\tsin->sin_port = 0  ;\n\t\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t\t*addr_len = sizeof(*sin);\n\t\t}\n\n\t\tif (inet_cmsg_flags(isk))\n\t\t\tip_cmsg_recv(msg, skb);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n\t\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\n\t\tif (sin6) {\n\t\t\tsin6->sin6_family = AF_INET6;\n\t\t\tsin6->sin6_port = 0;\n\t\t\tsin6->sin6_addr = ip6->saddr;\n\t\t\tsin6->sin6_flowinfo = 0;\n\t\t\tif (np->sndflow)\n\t\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n\t\t\tsin6->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t    inet6_iif(skb));\n\t\t\t*addr_len = sizeof(*sin6);\n\t\t}\n\n\t\tif (inet6_sk(sk)->rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_common_ctl(sk, msg, skb);\n\t\tif (skb->protocol == htons(ETH_P_IPV6) &&\n\t\t    inet6_sk(sk)->rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_specific_ctl(sk, msg, skb);\n\t\telse if (skb->protocol == htons(ETH_P_IP) &&\n\t\t\t inet_cmsg_flags(isk))\n\t\t\tip_cmsg_recv(msg, skb);\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\terr = copied;\n\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tpr_debug(\"ping_recvmsg -> %d\\n\", err);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ping_recvmsg);\n\nstatic enum skb_drop_reason __ping_queue_rcv_skb(struct sock *sk,\n\t\t\t\t\t\t struct sk_buff *skb)\n{\n\tenum skb_drop_reason reason;\n\n\tpr_debug(\"ping_queue_rcv_skb(sk=%p,sk->num=%d,skb=%p)\\n\",\n\t\t inet_sk(sk), inet_sk(sk)->inet_num, skb);\n\tif (sock_queue_rcv_skb_reason(sk, skb, &reason) < 0) {\n\t\tkfree_skb_reason(skb, reason);\n\t\tpr_debug(\"ping_queue_rcv_skb -> failed\\n\");\n\t\treturn reason;\n\t}\n\treturn SKB_NOT_DROPPED_YET;\n}\n\nint ping_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\treturn __ping_queue_rcv_skb(sk, skb) ? -1 : 0;\n}\nEXPORT_SYMBOL_GPL(ping_queue_rcv_skb);\n\n\n \n\nenum skb_drop_reason ping_rcv(struct sk_buff *skb)\n{\n\tenum skb_drop_reason reason = SKB_DROP_REASON_NO_SOCKET;\n\tstruct sock *sk;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct icmphdr *icmph = icmp_hdr(skb);\n\n\t \n\n\tpr_debug(\"ping_rcv(skb=%p,id=%04x,seq=%04x)\\n\",\n\t\t skb, ntohs(icmph->un.echo.id), ntohs(icmph->un.echo.sequence));\n\n\t \n\tskb_push(skb, skb->data - (u8 *)icmph);\n\n\tsk = ping_lookup(net, skb, ntohs(icmph->un.echo.id));\n\tif (sk) {\n\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\n\t\tpr_debug(\"rcv on socket %p\\n\", sk);\n\t\tif (skb2)\n\t\t\treason = __ping_queue_rcv_skb(sk, skb2);\n\t\telse\n\t\t\treason = SKB_DROP_REASON_NOMEM;\n\t}\n\n\tif (reason)\n\t\tpr_debug(\"no socket, dropping\\n\");\n\n\treturn reason;\n}\nEXPORT_SYMBOL_GPL(ping_rcv);\n\nstruct proto ping_prot = {\n\t.name =\t\t\"PING\",\n\t.owner =\tTHIS_MODULE,\n\t.init =\t\tping_init_sock,\n\t.close =\tping_close,\n\t.pre_connect =\tping_pre_connect,\n\t.connect =\tip4_datagram_connect,\n\t.disconnect =\t__udp_disconnect,\n\t.setsockopt =\tip_setsockopt,\n\t.getsockopt =\tip_getsockopt,\n\t.sendmsg =\tping_v4_sendmsg,\n\t.recvmsg =\tping_recvmsg,\n\t.bind =\t\tping_bind,\n\t.backlog_rcv =\tping_queue_rcv_skb,\n\t.release_cb =\tip4_datagram_release_cb,\n\t.hash =\t\tping_hash,\n\t.unhash =\tping_unhash,\n\t.get_port =\tping_get_port,\n\t.put_port =\tping_unhash,\n\t.obj_size =\tsizeof(struct inet_sock),\n};\nEXPORT_SYMBOL(ping_prot);\n\n#ifdef CONFIG_PROC_FS\n\nstatic struct sock *ping_get_first(struct seq_file *seq, int start)\n{\n\tstruct sock *sk;\n\tstruct ping_iter_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\n\tfor (state->bucket = start; state->bucket < PING_HTABLE_SIZE;\n\t     ++state->bucket) {\n\t\tstruct hlist_head *hslot;\n\n\t\thslot = &ping_table.hash[state->bucket];\n\n\t\tif (hlist_empty(hslot))\n\t\t\tcontinue;\n\n\t\tsk_for_each(sk, hslot) {\n\t\t\tif (net_eq(sock_net(sk), net) &&\n\t\t\t    sk->sk_family == state->family)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tsk = NULL;\nfound:\n\treturn sk;\n}\n\nstatic struct sock *ping_get_next(struct seq_file *seq, struct sock *sk)\n{\n\tstruct ping_iter_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\n\tdo {\n\t\tsk = sk_next(sk);\n\t} while (sk && (!net_eq(sock_net(sk), net)));\n\n\tif (!sk)\n\t\treturn ping_get_first(seq, state->bucket + 1);\n\treturn sk;\n}\n\nstatic struct sock *ping_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct sock *sk = ping_get_first(seq, 0);\n\n\tif (sk)\n\t\twhile (pos && (sk = ping_get_next(seq, sk)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : sk;\n}\n\nvoid *ping_seq_start(struct seq_file *seq, loff_t *pos, sa_family_t family)\n\t__acquires(ping_table.lock)\n{\n\tstruct ping_iter_state *state = seq->private;\n\tstate->bucket = 0;\n\tstate->family = family;\n\n\tspin_lock(&ping_table.lock);\n\n\treturn *pos ? ping_get_idx(seq, *pos-1) : SEQ_START_TOKEN;\n}\nEXPORT_SYMBOL_GPL(ping_seq_start);\n\nstatic void *ping_v4_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn ping_seq_start(seq, pos, AF_INET);\n}\n\nvoid *ping_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct sock *sk;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tsk = ping_get_idx(seq, 0);\n\telse\n\t\tsk = ping_get_next(seq, v);\n\n\t++*pos;\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(ping_seq_next);\n\nvoid ping_seq_stop(struct seq_file *seq, void *v)\n\t__releases(ping_table.lock)\n{\n\tspin_unlock(&ping_table.lock);\n}\nEXPORT_SYMBOL_GPL(ping_seq_stop);\n\nstatic void ping_v4_format_sock(struct sock *sp, struct seq_file *f,\n\t\tint bucket)\n{\n\tstruct inet_sock *inet = inet_sk(sp);\n\t__be32 dest = inet->inet_daddr;\n\t__be32 src = inet->inet_rcv_saddr;\n\t__u16 destp = ntohs(inet->inet_dport);\n\t__u16 srcp = ntohs(inet->inet_sport);\n\n\tseq_printf(f, \"%5d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %u\",\n\t\tbucket, src, srcp, dest, destp, sp->sk_state,\n\t\tsk_wmem_alloc_get(sp),\n\t\tsk_rmem_alloc_get(sp),\n\t\t0, 0L, 0,\n\t\tfrom_kuid_munged(seq_user_ns(f), sock_i_uid(sp)),\n\t\t0, sock_i_ino(sp),\n\t\trefcount_read(&sp->sk_refcnt), sp,\n\t\tatomic_read(&sp->sk_drops));\n}\n\nstatic int ping_v4_seq_show(struct seq_file *seq, void *v)\n{\n\tseq_setwidth(seq, 127);\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"  sl  local_address rem_address   st tx_queue \"\n\t\t\t   \"rx_queue tr tm->when retrnsmt   uid  timeout \"\n\t\t\t   \"inode ref pointer drops\");\n\telse {\n\t\tstruct ping_iter_state *state = seq->private;\n\n\t\tping_v4_format_sock(v, seq, state->bucket);\n\t}\n\tseq_pad(seq, '\\n');\n\treturn 0;\n}\n\nstatic const struct seq_operations ping_v4_seq_ops = {\n\t.start\t\t= ping_v4_seq_start,\n\t.show\t\t= ping_v4_seq_show,\n\t.next\t\t= ping_seq_next,\n\t.stop\t\t= ping_seq_stop,\n};\n\nstatic int __net_init ping_v4_proc_init_net(struct net *net)\n{\n\tif (!proc_create_net(\"icmp\", 0444, net->proc_net, &ping_v4_seq_ops,\n\t\t\tsizeof(struct ping_iter_state)))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void __net_exit ping_v4_proc_exit_net(struct net *net)\n{\n\tremove_proc_entry(\"icmp\", net->proc_net);\n}\n\nstatic struct pernet_operations ping_v4_net_ops = {\n\t.init = ping_v4_proc_init_net,\n\t.exit = ping_v4_proc_exit_net,\n};\n\nint __init ping_proc_init(void)\n{\n\treturn register_pernet_subsys(&ping_v4_net_ops);\n}\n\nvoid ping_proc_exit(void)\n{\n\tunregister_pernet_subsys(&ping_v4_net_ops);\n}\n\n#endif\n\nvoid __init ping_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PING_HTABLE_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&ping_table.hash[i]);\n\tspin_lock_init(&ping_table.lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}