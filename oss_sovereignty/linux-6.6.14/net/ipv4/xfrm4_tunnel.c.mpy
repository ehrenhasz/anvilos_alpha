{
  "module_name": "xfrm4_tunnel.c",
  "hash_id": "b2e00544572b459ba7ca9d61b06e5cd5f536ada7b72f45ac4520a46719d57b06",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/xfrm4_tunnel.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"IPsec: \" fmt\n\n#include <linux/skbuff.h>\n#include <linux/module.h>\n#include <net/xfrm.h>\n#include <net/protocol.h>\n\nstatic int ipip_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tskb_push(skb, -skb_network_offset(skb));\n\treturn 0;\n}\n\nstatic int ipip_xfrm_rcv(struct xfrm_state *x, struct sk_buff *skb)\n{\n\treturn ip_hdr(skb)->protocol;\n}\n\nstatic int ipip_init_state(struct xfrm_state *x, struct netlink_ext_ack *extack)\n{\n\tif (x->props.mode != XFRM_MODE_TUNNEL) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv4 tunnel can only be used with tunnel mode\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (x->encap) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv4 tunnel is not compatible with encapsulation\");\n\t\treturn -EINVAL;\n\t}\n\n\tx->props.header_len = sizeof(struct iphdr);\n\n\treturn 0;\n}\n\nstatic void ipip_destroy(struct xfrm_state *x)\n{\n}\n\nstatic const struct xfrm_type ipip_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.proto\t     \t= IPPROTO_IPIP,\n\t.init_state\t= ipip_init_state,\n\t.destructor\t= ipip_destroy,\n\t.input\t\t= ipip_xfrm_rcv,\n\t.output\t\t= ipip_output\n};\n\nstatic int xfrm_tunnel_rcv(struct sk_buff *skb)\n{\n\treturn xfrm4_rcv_spi(skb, IPPROTO_IPIP, ip_hdr(skb)->saddr);\n}\n\nstatic int xfrm_tunnel_err(struct sk_buff *skb, u32 info)\n{\n\treturn -ENOENT;\n}\n\nstatic struct xfrm_tunnel xfrm_tunnel_handler __read_mostly = {\n\t.handler\t=\txfrm_tunnel_rcv,\n\t.err_handler\t=\txfrm_tunnel_err,\n\t.priority\t=\t4,\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct xfrm_tunnel xfrm64_tunnel_handler __read_mostly = {\n\t.handler\t=\txfrm_tunnel_rcv,\n\t.err_handler\t=\txfrm_tunnel_err,\n\t.priority\t=\t3,\n};\n#endif\n\nstatic int __init ipip_init(void)\n{\n\tif (xfrm_register_type(&ipip_type, AF_INET) < 0) {\n\t\tpr_info(\"%s: can't add xfrm type\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (xfrm4_tunnel_register(&xfrm_tunnel_handler, AF_INET)) {\n\t\tpr_info(\"%s: can't add xfrm handler for AF_INET\\n\", __func__);\n\t\txfrm_unregister_type(&ipip_type, AF_INET);\n\t\treturn -EAGAIN;\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (xfrm4_tunnel_register(&xfrm64_tunnel_handler, AF_INET6)) {\n\t\tpr_info(\"%s: can't add xfrm handler for AF_INET6\\n\", __func__);\n\t\txfrm4_tunnel_deregister(&xfrm_tunnel_handler, AF_INET);\n\t\txfrm_unregister_type(&ipip_type, AF_INET);\n\t\treturn -EAGAIN;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic void __exit ipip_fini(void)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (xfrm4_tunnel_deregister(&xfrm64_tunnel_handler, AF_INET6))\n\t\tpr_info(\"%s: can't remove xfrm handler for AF_INET6\\n\",\n\t\t\t__func__);\n#endif\n\tif (xfrm4_tunnel_deregister(&xfrm_tunnel_handler, AF_INET))\n\t\tpr_info(\"%s: can't remove xfrm handler for AF_INET\\n\",\n\t\t\t__func__);\n\txfrm_unregister_type(&ipip_type, AF_INET);\n}\n\nmodule_init(ipip_init);\nmodule_exit(ipip_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_XFRM_TYPE(AF_INET, XFRM_PROTO_IPIP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}