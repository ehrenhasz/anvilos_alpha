{
  "module_name": "sysctl_net_ipv4.c",
  "hash_id": "68b63e16d0764a739c2a1448986718b0199fe6ea7be0e6a79fff3b89e994c6a0",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/sysctl_net_ipv4.c",
  "human_readable_source": "\n \n\n#include <linux/sysctl.h>\n#include <linux/seqlock.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/icmp.h>\n#include <net/ip.h>\n#include <net/ip_fib.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/cipso_ipv4.h>\n#include <net/ping.h>\n#include <net/protocol.h>\n#include <net/netevent.h>\n\nstatic int tcp_retr1_max = 255;\nstatic int ip_local_port_range_min[] = { 1, 1 };\nstatic int ip_local_port_range_max[] = { 65535, 65535 };\nstatic int tcp_adv_win_scale_min = -31;\nstatic int tcp_adv_win_scale_max = 31;\nstatic int tcp_app_win_max = 31;\nstatic int tcp_min_snd_mss_min = TCP_MIN_SND_MSS;\nstatic int tcp_min_snd_mss_max = 65535;\nstatic int ip_privileged_port_min;\nstatic int ip_privileged_port_max = 65535;\nstatic int ip_ttl_min = 1;\nstatic int ip_ttl_max = 255;\nstatic int tcp_syn_retries_min = 1;\nstatic int tcp_syn_retries_max = MAX_TCP_SYNCNT;\nstatic int tcp_syn_linear_timeouts_max = MAX_TCP_SYNCNT;\nstatic unsigned long ip_ping_group_range_min[] = { 0, 0 };\nstatic unsigned long ip_ping_group_range_max[] = { GID_T_MAX, GID_T_MAX };\nstatic u32 u32_max_div_HZ = UINT_MAX / HZ;\nstatic int one_day_secs = 24 * 3600;\nstatic u32 fib_multipath_hash_fields_all_mask __maybe_unused =\n\tFIB_MULTIPATH_HASH_FIELD_ALL_MASK;\nstatic unsigned int tcp_child_ehash_entries_max = 16 * 1024 * 1024;\nstatic unsigned int udp_child_hash_entries_max = UDP_HTABLE_SIZE_MAX;\nstatic int tcp_plb_max_rounds = 31;\nstatic int tcp_plb_max_cong_thresh = 256;\n\n \nstatic int sysctl_tcp_low_latency __read_mostly;\n\n \nstatic void set_local_port_range(struct net *net, int range[2])\n{\n\tbool same_parity = !((range[0] ^ range[1]) & 1);\n\n\twrite_seqlock_bh(&net->ipv4.ip_local_ports.lock);\n\tif (same_parity && !net->ipv4.ip_local_ports.warned) {\n\t\tnet->ipv4.ip_local_ports.warned = true;\n\t\tpr_err_ratelimited(\"ip_local_port_range: prefer different parity for start/end values.\\n\");\n\t}\n\tnet->ipv4.ip_local_ports.range[0] = range[0];\n\tnet->ipv4.ip_local_ports.range[1] = range[1];\n\twrite_sequnlock_bh(&net->ipv4.ip_local_ports.lock);\n}\n\n \nstatic int ipv4_local_port_range(struct ctl_table *table, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net =\n\t\tcontainer_of(table->data, struct net, ipv4.ip_local_ports.range);\n\tint ret;\n\tint range[2];\n\tstruct ctl_table tmp = {\n\t\t.data = &range,\n\t\t.maxlen = sizeof(range),\n\t\t.mode = table->mode,\n\t\t.extra1 = &ip_local_port_range_min,\n\t\t.extra2 = &ip_local_port_range_max,\n\t};\n\n\tinet_get_local_port_range(net, &range[0], &range[1]);\n\n\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\n\n\tif (write && ret == 0) {\n\t\t \n\t\tif ((range[1] < range[0]) ||\n\t\t    (range[0] < READ_ONCE(net->ipv4.sysctl_ip_prot_sock)))\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tset_local_port_range(net, range);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ipv4_privileged_ports(struct ctl_table *table, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = container_of(table->data, struct net,\n\t    ipv4.sysctl_ip_prot_sock);\n\tint ret;\n\tint pports;\n\tint range[2];\n\tstruct ctl_table tmp = {\n\t\t.data = &pports,\n\t\t.maxlen = sizeof(pports),\n\t\t.mode = table->mode,\n\t\t.extra1 = &ip_privileged_port_min,\n\t\t.extra2 = &ip_privileged_port_max,\n\t};\n\n\tpports = READ_ONCE(net->ipv4.sysctl_ip_prot_sock);\n\n\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\n\n\tif (write && ret == 0) {\n\t\tinet_get_local_port_range(net, &range[0], &range[1]);\n\t\t \n\t\tif (range[0] < pports)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tWRITE_ONCE(net->ipv4.sysctl_ip_prot_sock, pports);\n\t}\n\n\treturn ret;\n}\n\nstatic void inet_get_ping_group_range_table(struct ctl_table *table, kgid_t *low, kgid_t *high)\n{\n\tkgid_t *data = table->data;\n\tstruct net *net =\n\t\tcontainer_of(table->data, struct net, ipv4.ping_group_range.range);\n\tunsigned int seq;\n\tdo {\n\t\tseq = read_seqbegin(&net->ipv4.ping_group_range.lock);\n\n\t\t*low = data[0];\n\t\t*high = data[1];\n\t} while (read_seqretry(&net->ipv4.ping_group_range.lock, seq));\n}\n\n \nstatic void set_ping_group_range(struct ctl_table *table, kgid_t low, kgid_t high)\n{\n\tkgid_t *data = table->data;\n\tstruct net *net =\n\t\tcontainer_of(table->data, struct net, ipv4.ping_group_range.range);\n\twrite_seqlock(&net->ipv4.ping_group_range.lock);\n\tdata[0] = low;\n\tdata[1] = high;\n\twrite_sequnlock(&net->ipv4.ping_group_range.lock);\n}\n\n \nstatic int ipv4_ping_group_range(struct ctl_table *table, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint ret;\n\tunsigned long urange[2];\n\tkgid_t low, high;\n\tstruct ctl_table tmp = {\n\t\t.data = &urange,\n\t\t.maxlen = sizeof(urange),\n\t\t.mode = table->mode,\n\t\t.extra1 = &ip_ping_group_range_min,\n\t\t.extra2 = &ip_ping_group_range_max,\n\t};\n\n\tinet_get_ping_group_range_table(table, &low, &high);\n\turange[0] = from_kgid_munged(user_ns, low);\n\turange[1] = from_kgid_munged(user_ns, high);\n\tret = proc_doulongvec_minmax(&tmp, write, buffer, lenp, ppos);\n\n\tif (write && ret == 0) {\n\t\tlow = make_kgid(user_ns, urange[0]);\n\t\thigh = make_kgid(user_ns, urange[1]);\n\t\tif (!gid_valid(low) || !gid_valid(high))\n\t\t\treturn -EINVAL;\n\t\tif (urange[1] < urange[0] || gid_lt(high, low)) {\n\t\t\tlow = make_kgid(&init_user_ns, 1);\n\t\t\thigh = make_kgid(&init_user_ns, 0);\n\t\t}\n\t\tset_ping_group_range(table, low, high);\n\t}\n\n\treturn ret;\n}\n\nstatic int ipv4_fwd_update_priority(struct ctl_table *table, int write,\n\t\t\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net;\n\tint ret;\n\n\tnet = container_of(table->data, struct net,\n\t\t\t   ipv4.sysctl_ip_fwd_update_priority);\n\tret = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);\n\tif (write && ret == 0)\n\t\tcall_netevent_notifiers(NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE,\n\t\t\t\t\tnet);\n\n\treturn ret;\n}\n\nstatic int proc_tcp_congestion_control(struct ctl_table *ctl, int write,\n\t\t\t\t       void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = container_of(ctl->data, struct net,\n\t\t\t\t       ipv4.tcp_congestion_control);\n\tchar val[TCP_CA_NAME_MAX];\n\tstruct ctl_table tbl = {\n\t\t.data = val,\n\t\t.maxlen = TCP_CA_NAME_MAX,\n\t};\n\tint ret;\n\n\ttcp_get_default_congestion_control(net, val);\n\n\tret = proc_dostring(&tbl, write, buffer, lenp, ppos);\n\tif (write && ret == 0)\n\t\tret = tcp_set_default_congestion_control(net, val);\n\treturn ret;\n}\n\nstatic int proc_tcp_available_congestion_control(struct ctl_table *ctl,\n\t\t\t\t\t\t int write, void *buffer,\n\t\t\t\t\t\t size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table tbl = { .maxlen = TCP_CA_BUF_MAX, };\n\tint ret;\n\n\ttbl.data = kmalloc(tbl.maxlen, GFP_USER);\n\tif (!tbl.data)\n\t\treturn -ENOMEM;\n\ttcp_get_available_congestion_control(tbl.data, TCP_CA_BUF_MAX);\n\tret = proc_dostring(&tbl, write, buffer, lenp, ppos);\n\tkfree(tbl.data);\n\treturn ret;\n}\n\nstatic int proc_allowed_congestion_control(struct ctl_table *ctl,\n\t\t\t\t\t   int write, void *buffer,\n\t\t\t\t\t   size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table tbl = { .maxlen = TCP_CA_BUF_MAX };\n\tint ret;\n\n\ttbl.data = kmalloc(tbl.maxlen, GFP_USER);\n\tif (!tbl.data)\n\t\treturn -ENOMEM;\n\n\ttcp_get_allowed_congestion_control(tbl.data, tbl.maxlen);\n\tret = proc_dostring(&tbl, write, buffer, lenp, ppos);\n\tif (write && ret == 0)\n\t\tret = tcp_set_allowed_congestion_control(tbl.data);\n\tkfree(tbl.data);\n\treturn ret;\n}\n\nstatic int sscanf_key(char *buf, __le32 *key)\n{\n\tu32 user_key[4];\n\tint i, ret = 0;\n\n\tif (sscanf(buf, \"%x-%x-%x-%x\", user_key, user_key + 1,\n\t\t   user_key + 2, user_key + 3) != 4) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(user_key); i++)\n\t\t\tkey[i] = cpu_to_le32(user_key[i]);\n\t}\n\tpr_debug(\"proc TFO key set 0x%x-%x-%x-%x <- 0x%s: %u\\n\",\n\t\t user_key[0], user_key[1], user_key[2], user_key[3], buf, ret);\n\n\treturn ret;\n}\n\nstatic int proc_tcp_fastopen_key(struct ctl_table *table, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = container_of(table->data, struct net,\n\t    ipv4.sysctl_tcp_fastopen);\n\t \n\tstruct ctl_table tbl = { .maxlen = ((TCP_FASTOPEN_KEY_LENGTH *\n\t\t\t\t\t    2 * TCP_FASTOPEN_KEY_MAX) +\n\t\t\t\t\t    (TCP_FASTOPEN_KEY_MAX * 5)) };\n\tu32 user_key[TCP_FASTOPEN_KEY_BUF_LENGTH / sizeof(u32)];\n\t__le32 key[TCP_FASTOPEN_KEY_BUF_LENGTH / sizeof(__le32)];\n\tchar *backup_data;\n\tint ret, i = 0, off = 0, n_keys;\n\n\ttbl.data = kmalloc(tbl.maxlen, GFP_KERNEL);\n\tif (!tbl.data)\n\t\treturn -ENOMEM;\n\n\tn_keys = tcp_fastopen_get_cipher(net, NULL, (u64 *)key);\n\tif (!n_keys) {\n\t\tmemset(&key[0], 0, TCP_FASTOPEN_KEY_LENGTH);\n\t\tn_keys = 1;\n\t}\n\n\tfor (i = 0; i < n_keys * 4; i++)\n\t\tuser_key[i] = le32_to_cpu(key[i]);\n\n\tfor (i = 0; i < n_keys; i++) {\n\t\toff += snprintf(tbl.data + off, tbl.maxlen - off,\n\t\t\t\t\"%08x-%08x-%08x-%08x\",\n\t\t\t\tuser_key[i * 4],\n\t\t\t\tuser_key[i * 4 + 1],\n\t\t\t\tuser_key[i * 4 + 2],\n\t\t\t\tuser_key[i * 4 + 3]);\n\n\t\tif (WARN_ON_ONCE(off >= tbl.maxlen - 1))\n\t\t\tbreak;\n\n\t\tif (i + 1 < n_keys)\n\t\t\toff += snprintf(tbl.data + off, tbl.maxlen - off, \",\");\n\t}\n\n\tret = proc_dostring(&tbl, write, buffer, lenp, ppos);\n\n\tif (write && ret == 0) {\n\t\tbackup_data = strchr(tbl.data, ',');\n\t\tif (backup_data) {\n\t\t\t*backup_data = '\\0';\n\t\t\tbackup_data++;\n\t\t}\n\t\tif (sscanf_key(tbl.data, key)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto bad_key;\n\t\t}\n\t\tif (backup_data) {\n\t\t\tif (sscanf_key(backup_data, key + 4)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto bad_key;\n\t\t\t}\n\t\t}\n\t\ttcp_fastopen_reset_cipher(net, NULL, key,\n\t\t\t\t\t  backup_data ? key + 4 : NULL);\n\t}\n\nbad_key:\n\tkfree(tbl.data);\n\treturn ret;\n}\n\nstatic int proc_tfo_blackhole_detect_timeout(struct ctl_table *table,\n\t\t\t\t\t     int write, void *buffer,\n\t\t\t\t\t     size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = container_of(table->data, struct net,\n\t    ipv4.sysctl_tcp_fastopen_blackhole_timeout);\n\tint ret;\n\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (write && ret == 0)\n\t\tatomic_set(&net->ipv4.tfo_active_disable_times, 0);\n\n\treturn ret;\n}\n\nstatic int proc_tcp_available_ulp(struct ctl_table *ctl,\n\t\t\t\t  int write, void *buffer, size_t *lenp,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct ctl_table tbl = { .maxlen = TCP_ULP_BUF_MAX, };\n\tint ret;\n\n\ttbl.data = kmalloc(tbl.maxlen, GFP_USER);\n\tif (!tbl.data)\n\t\treturn -ENOMEM;\n\ttcp_get_available_ulp(tbl.data, TCP_ULP_BUF_MAX);\n\tret = proc_dostring(&tbl, write, buffer, lenp, ppos);\n\tkfree(tbl.data);\n\n\treturn ret;\n}\n\nstatic int proc_tcp_ehash_entries(struct ctl_table *table, int write,\n\t\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = container_of(table->data, struct net,\n\t\t\t\t       ipv4.sysctl_tcp_child_ehash_entries);\n\tstruct inet_hashinfo *hinfo = net->ipv4.tcp_death_row.hashinfo;\n\tint tcp_ehash_entries;\n\tstruct ctl_table tbl;\n\n\ttcp_ehash_entries = hinfo->ehash_mask + 1;\n\n\t \n\tif (!net_eq(net, &init_net) && !hinfo->pernet)\n\t\ttcp_ehash_entries *= -1;\n\n\tmemset(&tbl, 0, sizeof(tbl));\n\ttbl.data = &tcp_ehash_entries;\n\ttbl.maxlen = sizeof(int);\n\n\treturn proc_dointvec(&tbl, write, buffer, lenp, ppos);\n}\n\nstatic int proc_udp_hash_entries(struct ctl_table *table, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = container_of(table->data, struct net,\n\t\t\t\t       ipv4.sysctl_udp_child_hash_entries);\n\tint udp_hash_entries;\n\tstruct ctl_table tbl;\n\n\tudp_hash_entries = net->ipv4.udp_table->mask + 1;\n\n\t \n\tif (!net_eq(net, &init_net) && net->ipv4.udp_table == &udp_table)\n\t\tudp_hash_entries *= -1;\n\n\tmemset(&tbl, 0, sizeof(tbl));\n\ttbl.data = &udp_hash_entries;\n\ttbl.maxlen = sizeof(int);\n\n\treturn proc_dointvec(&tbl, write, buffer, lenp, ppos);\n}\n\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\nstatic int proc_fib_multipath_hash_policy(struct ctl_table *table, int write,\n\t\t\t\t\t  void *buffer, size_t *lenp,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct net *net = container_of(table->data, struct net,\n\t    ipv4.sysctl_fib_multipath_hash_policy);\n\tint ret;\n\n\tret = proc_dou8vec_minmax(table, write, buffer, lenp, ppos);\n\tif (write && ret == 0)\n\t\tcall_netevent_notifiers(NETEVENT_IPV4_MPATH_HASH_UPDATE, net);\n\n\treturn ret;\n}\n\nstatic int proc_fib_multipath_hash_fields(struct ctl_table *table, int write,\n\t\t\t\t\t  void *buffer, size_t *lenp,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct net *net;\n\tint ret;\n\n\tnet = container_of(table->data, struct net,\n\t\t\t   ipv4.sysctl_fib_multipath_hash_fields);\n\tret = proc_douintvec_minmax(table, write, buffer, lenp, ppos);\n\tif (write && ret == 0)\n\t\tcall_netevent_notifiers(NETEVENT_IPV4_MPATH_HASH_UPDATE, net);\n\n\treturn ret;\n}\n#endif\n\nstatic struct ctl_table ipv4_table[] = {\n\t{\n\t\t.procname\t= \"tcp_max_orphans\",\n\t\t.data\t\t= &sysctl_tcp_max_orphans,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"inet_peer_threshold\",\n\t\t.data\t\t= &inet_peer_threshold,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"inet_peer_minttl\",\n\t\t.data\t\t= &inet_peer_minttl,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"inet_peer_maxttl\",\n\t\t.data\t\t= &inet_peer_maxttl,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"tcp_mem\",\n\t\t.maxlen\t\t= sizeof(sysctl_tcp_mem),\n\t\t.data\t\t= &sysctl_tcp_mem,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_low_latency\",\n\t\t.data\t\t= &sysctl_tcp_low_latency,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n#ifdef CONFIG_NETLABEL\n\t{\n\t\t.procname\t= \"cipso_cache_enable\",\n\t\t.data\t\t= &cipso_v4_cache_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"cipso_cache_bucket_size\",\n\t\t.data\t\t= &cipso_v4_cache_bucketsize,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"cipso_rbm_optfmt\",\n\t\t.data\t\t= &cipso_v4_rbm_optfmt,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"cipso_rbm_strictvalid\",\n\t\t.data\t\t= &cipso_v4_rbm_strictvalid,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif  \n\t{\n\t\t.procname\t= \"tcp_available_ulp\",\n\t\t.maxlen\t\t= TCP_ULP_BUF_MAX,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler   = proc_tcp_available_ulp,\n\t},\n\t{\n\t\t.procname\t= \"icmp_msgs_per_sec\",\n\t\t.data\t\t= &sysctl_icmp_msgs_per_sec,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n\t{\n\t\t.procname\t= \"icmp_msgs_burst\",\n\t\t.data\t\t= &sysctl_icmp_msgs_burst,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n\t{\n\t\t.procname\t= \"udp_mem\",\n\t\t.data\t\t= &sysctl_udp_mem,\n\t\t.maxlen\t\t= sizeof(sysctl_udp_mem),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"fib_sync_mem\",\n\t\t.data\t\t= &sysctl_fib_sync_mem,\n\t\t.maxlen\t\t= sizeof(sysctl_fib_sync_mem),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_douintvec_minmax,\n\t\t.extra1\t\t= &sysctl_fib_sync_mem_min,\n\t\t.extra2\t\t= &sysctl_fib_sync_mem_max,\n\t},\n\t{ }\n};\n\nstatic struct ctl_table ipv4_net_table[] = {\n\t{\n\t\t.procname\t= \"tcp_max_tw_buckets\",\n\t\t.data\t\t= &init_net.ipv4.tcp_death_row.sysctl_max_tw_buckets,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"icmp_echo_ignore_all\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_icmp_echo_ignore_all,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE\n\t},\n\t{\n\t\t.procname\t= \"icmp_echo_enable_probe\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_icmp_echo_enable_probe,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE\n\t},\n\t{\n\t\t.procname\t= \"icmp_echo_ignore_broadcasts\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_icmp_echo_ignore_broadcasts,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE\n\t},\n\t{\n\t\t.procname\t= \"icmp_ignore_bogus_error_responses\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_icmp_ignore_bogus_error_responses,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE\n\t},\n\t{\n\t\t.procname\t= \"icmp_errors_use_inbound_ifaddr\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_icmp_errors_use_inbound_ifaddr,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE\n\t},\n\t{\n\t\t.procname\t= \"icmp_ratelimit\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_icmp_ratelimit,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_ms_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"icmp_ratemask\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_icmp_ratemask,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"ping_group_range\",\n\t\t.data\t\t= &init_net.ipv4.ping_group_range.range,\n\t\t.maxlen\t\t= sizeof(gid_t)*2,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= ipv4_ping_group_range,\n\t},\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\t{\n\t\t.procname\t= \"raw_l3mdev_accept\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_raw_l3mdev_accept,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"tcp_ecn\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_ecn,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{\n\t\t.procname\t= \"tcp_ecn_fallback\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_ecn_fallback,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"ip_dynaddr\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_ip_dynaddr,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"ip_early_demux\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_ip_early_demux,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname       = \"udp_early_demux\",\n\t\t.data           = &init_net.ipv4.sysctl_udp_early_demux,\n\t\t.maxlen         = sizeof(u8),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname       = \"tcp_early_demux\",\n\t\t.data           = &init_net.ipv4.sysctl_tcp_early_demux,\n\t\t.maxlen         = sizeof(u8),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname       = \"nexthop_compat_mode\",\n\t\t.data           = &init_net.ipv4.sysctl_nexthop_compat_mode,\n\t\t.maxlen         = sizeof(u8),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"ip_default_ttl\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_ip_default_ttl,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= &ip_ttl_min,\n\t\t.extra2\t\t= &ip_ttl_max,\n\t},\n\t{\n\t\t.procname\t= \"ip_local_port_range\",\n\t\t.maxlen\t\t= sizeof(init_net.ipv4.ip_local_ports.range),\n\t\t.data\t\t= &init_net.ipv4.ip_local_ports.range,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= ipv4_local_port_range,\n\t},\n\t{\n\t\t.procname\t= \"ip_local_reserved_ports\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_local_reserved_ports,\n\t\t.maxlen\t\t= 65536,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_large_bitmap,\n\t},\n\t{\n\t\t.procname\t= \"ip_no_pmtu_disc\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_ip_no_pmtu_disc,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"ip_forward_use_pmtu\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_ip_fwd_use_pmtu,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"ip_forward_update_priority\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_ip_fwd_update_priority,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler   = ipv4_fwd_update_priority,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"ip_nonlocal_bind\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_ip_nonlocal_bind,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"ip_autobind_reuse\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_ip_autobind_reuse,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1         = SYSCTL_ZERO,\n\t\t.extra2         = SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"fwmark_reflect\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_fwmark_reflect,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_fwmark_accept\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_fwmark_accept,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\t{\n\t\t.procname\t= \"tcp_l3mdev_accept\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_l3mdev_accept,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"tcp_mtu_probing\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_mtu_probing,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_base_mss\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_base_mss,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"tcp_min_snd_mss\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_min_snd_mss,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &tcp_min_snd_mss_min,\n\t\t.extra2\t\t= &tcp_min_snd_mss_max,\n\t},\n\t{\n\t\t.procname\t= \"tcp_mtu_probe_floor\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_mtu_probe_floor,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &tcp_min_snd_mss_min,\n\t\t.extra2\t\t= &tcp_min_snd_mss_max,\n\t},\n\t{\n\t\t.procname\t= \"tcp_probe_threshold\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_probe_threshold,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"tcp_probe_interval\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_probe_interval,\n\t\t.maxlen\t\t= sizeof(u32),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_douintvec_minmax,\n\t\t.extra2\t\t= &u32_max_div_HZ,\n\t},\n\t{\n\t\t.procname\t= \"igmp_link_local_mcast_reports\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_igmp_llm_reports,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"igmp_max_memberships\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_igmp_max_memberships,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"igmp_max_msf\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_igmp_max_msf,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n#ifdef CONFIG_IP_MULTICAST\n\t{\n\t\t.procname\t= \"igmp_qrv\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_igmp_qrv,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE\n\t},\n#endif\n\t{\n\t\t.procname\t= \"tcp_congestion_control\",\n\t\t.data\t\t= &init_net.ipv4.tcp_congestion_control,\n\t\t.mode\t\t= 0644,\n\t\t.maxlen\t\t= TCP_CA_NAME_MAX,\n\t\t.proc_handler\t= proc_tcp_congestion_control,\n\t},\n\t{\n\t\t.procname\t= \"tcp_available_congestion_control\",\n\t\t.maxlen\t\t= TCP_CA_BUF_MAX,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler   = proc_tcp_available_congestion_control,\n\t},\n\t{\n\t\t.procname\t= \"tcp_allowed_congestion_control\",\n\t\t.maxlen\t\t= TCP_CA_BUF_MAX,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler   = proc_allowed_congestion_control,\n\t},\n\t{\n\t\t.procname\t= \"tcp_keepalive_time\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_keepalive_time,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"tcp_keepalive_probes\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_keepalive_probes,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_keepalive_intvl\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_keepalive_intvl,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"tcp_syn_retries\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_syn_retries,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= &tcp_syn_retries_min,\n\t\t.extra2\t\t= &tcp_syn_retries_max\n\t},\n\t{\n\t\t.procname\t= \"tcp_synack_retries\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_synack_retries,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n#ifdef CONFIG_SYN_COOKIES\n\t{\n\t\t.procname\t= \"tcp_syncookies\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_syncookies,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"tcp_migrate_req\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_migrate_req,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE\n\t},\n\t{\n\t\t.procname\t= \"tcp_reordering\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_reordering,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"tcp_retries1\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_retries1,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra2\t\t= &tcp_retr1_max\n\t},\n\t{\n\t\t.procname\t= \"tcp_retries2\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_retries2,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_orphan_retries\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_orphan_retries,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_fin_timeout\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_fin_timeout,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"tcp_notsent_lowat\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_notsent_lowat,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_douintvec,\n\t},\n\t{\n\t\t.procname\t= \"tcp_tw_reuse\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_tw_reuse,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{\n\t\t.procname\t= \"tcp_max_syn_backlog\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_max_syn_backlog,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"tcp_fastopen\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_fastopen,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"tcp_fastopen_key\",\n\t\t.mode\t\t= 0600,\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_fastopen,\n\t\t \n\t\t.maxlen\t\t= ((TCP_FASTOPEN_KEY_LENGTH *\n\t\t\t\t   2 * TCP_FASTOPEN_KEY_MAX) +\n\t\t\t\t   (TCP_FASTOPEN_KEY_MAX * 5)),\n\t\t.proc_handler\t= proc_tcp_fastopen_key,\n\t},\n\t{\n\t\t.procname\t= \"tcp_fastopen_blackhole_timeout_sec\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_fastopen_blackhole_timeout,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_tfo_blackhole_detect_timeout,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\t{\n\t\t.procname\t= \"fib_multipath_use_neigh\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_fib_multipath_use_neigh,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"fib_multipath_hash_policy\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_fib_multipath_hash_policy,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_fib_multipath_hash_policy,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_THREE,\n\t},\n\t{\n\t\t.procname\t= \"fib_multipath_hash_fields\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_fib_multipath_hash_fields,\n\t\t.maxlen\t\t= sizeof(u32),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_fib_multipath_hash_fields,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= &fib_multipath_hash_fields_all_mask,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"ip_unprivileged_port_start\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.data\t\t= &init_net.ipv4.sysctl_ip_prot_sock,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= ipv4_privileged_ports,\n\t},\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\t{\n\t\t.procname\t= \"udp_l3mdev_accept\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_udp_l3mdev_accept,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"tcp_sack\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_sack,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_window_scaling\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_window_scaling,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_timestamps\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_timestamps,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_early_retrans\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_early_retrans,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_FOUR,\n\t},\n\t{\n\t\t.procname\t= \"tcp_recovery\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_recovery,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname       = \"tcp_thin_linear_timeouts\",\n\t\t.data           = &init_net.ipv4.sysctl_tcp_thin_linear_timeouts,\n\t\t.maxlen         = sizeof(u8),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_slow_start_after_idle\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_slow_start_after_idle,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_retrans_collapse\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_retrans_collapse,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_stdurg\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_stdurg,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_rfc1337\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_rfc1337,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_abort_on_overflow\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_abort_on_overflow,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_fack\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_fack,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_max_reordering\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_max_reordering,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"tcp_dsack\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_dsack,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_app_win\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_app_win,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &tcp_app_win_max,\n\t},\n\t{\n\t\t.procname\t= \"tcp_adv_win_scale\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_adv_win_scale,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &tcp_adv_win_scale_min,\n\t\t.extra2\t\t= &tcp_adv_win_scale_max,\n\t},\n\t{\n\t\t.procname\t= \"tcp_frto\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_frto,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_no_metrics_save\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_nometrics_save,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_no_ssthresh_metrics_save\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_no_ssthresh_metrics_save,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"tcp_moderate_rcvbuf\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_moderate_rcvbuf,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_tso_win_divisor\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_tso_win_divisor,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_workaround_signed_windows\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_workaround_signed_windows,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_limit_output_bytes\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_limit_output_bytes,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"tcp_challenge_ack_limit\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_challenge_ack_limit,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"tcp_min_tso_segs\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_min_tso_segs,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"tcp_tso_rtt_log\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_tso_rtt_log,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_min_rtt_wlen\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_min_rtt_wlen,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &one_day_secs\n\t},\n\t{\n\t\t.procname\t= \"tcp_autocorking\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_autocorking,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"tcp_invalid_ratelimit\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_invalid_ratelimit,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_ms_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"tcp_pacing_ss_ratio\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_pacing_ss_ratio,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE_THOUSAND,\n\t},\n\t{\n\t\t.procname\t= \"tcp_pacing_ca_ratio\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_pacing_ca_ratio,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE_THOUSAND,\n\t},\n\t{\n\t\t.procname\t= \"tcp_wmem\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_wmem,\n\t\t.maxlen\t\t= sizeof(init_net.ipv4.sysctl_tcp_wmem),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"tcp_rmem\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_rmem,\n\t\t.maxlen\t\t= sizeof(init_net.ipv4.sysctl_tcp_rmem),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"tcp_comp_sack_delay_ns\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_comp_sack_delay_ns,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_comp_sack_slack_ns\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_comp_sack_slack_ns,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"tcp_comp_sack_nr\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_comp_sack_nr,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t},\n\t{\n\t\t.procname       = \"tcp_reflect_tos\",\n\t\t.data           = &init_net.ipv4.sysctl_tcp_reflect_tos,\n\t\t.maxlen         = sizeof(u8),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dou8vec_minmax,\n\t\t.extra1         = SYSCTL_ZERO,\n\t\t.extra2         = SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"tcp_ehash_entries\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_child_ehash_entries,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_tcp_ehash_entries,\n\t},\n\t{\n\t\t.procname\t= \"tcp_child_ehash_entries\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_child_ehash_entries,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_douintvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &tcp_child_ehash_entries_max,\n\t},\n\t{\n\t\t.procname\t= \"udp_hash_entries\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_udp_child_hash_entries,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_udp_hash_entries,\n\t},\n\t{\n\t\t.procname\t= \"udp_child_hash_entries\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_udp_child_hash_entries,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_douintvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &udp_child_hash_entries_max,\n\t},\n\t{\n\t\t.procname\t= \"udp_rmem_min\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_udp_rmem_min,\n\t\t.maxlen\t\t= sizeof(init_net.ipv4.sysctl_udp_rmem_min),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE\n\t},\n\t{\n\t\t.procname\t= \"udp_wmem_min\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_udp_wmem_min,\n\t\t.maxlen\t\t= sizeof(init_net.ipv4.sysctl_udp_wmem_min),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE\n\t},\n\t{\n\t\t.procname\t= \"fib_notify_on_flag_change\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_fib_notify_on_flag_change,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{\n\t\t.procname       = \"tcp_plb_enabled\",\n\t\t.data           = &init_net.ipv4.sysctl_tcp_plb_enabled,\n\t\t.maxlen         = sizeof(u8),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dou8vec_minmax,\n\t\t.extra1         = SYSCTL_ZERO,\n\t\t.extra2         = SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname       = \"tcp_plb_idle_rehash_rounds\",\n\t\t.data           = &init_net.ipv4.sysctl_tcp_plb_idle_rehash_rounds,\n\t\t.maxlen         = sizeof(u8),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dou8vec_minmax,\n\t\t.extra2\t\t= &tcp_plb_max_rounds,\n\t},\n\t{\n\t\t.procname       = \"tcp_plb_rehash_rounds\",\n\t\t.data           = &init_net.ipv4.sysctl_tcp_plb_rehash_rounds,\n\t\t.maxlen         = sizeof(u8),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dou8vec_minmax,\n\t\t.extra2         = &tcp_plb_max_rounds,\n\t},\n\t{\n\t\t.procname       = \"tcp_plb_suspend_rto_sec\",\n\t\t.data           = &init_net.ipv4.sysctl_tcp_plb_suspend_rto_sec,\n\t\t.maxlen         = sizeof(u8),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname       = \"tcp_plb_cong_thresh\",\n\t\t.data           = &init_net.ipv4.sysctl_tcp_plb_cong_thresh,\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec_minmax,\n\t\t.extra1         = SYSCTL_ZERO,\n\t\t.extra2         = &tcp_plb_max_cong_thresh,\n\t},\n\t{\n\t\t.procname\t= \"tcp_syn_linear_timeouts\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_syn_linear_timeouts,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &tcp_syn_linear_timeouts_max,\n\t},\n\t{\n\t\t.procname\t= \"tcp_shrink_window\",\n\t\t.data\t\t= &init_net.ipv4.sysctl_tcp_shrink_window,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{ }\n};\n\nstatic __net_init int ipv4_sysctl_init_net(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = ipv4_net_table;\n\tif (!net_eq(net, &init_net)) {\n\t\tint i;\n\n\t\ttable = kmemdup(table, sizeof(ipv4_net_table), GFP_KERNEL);\n\t\tif (!table)\n\t\t\tgoto err_alloc;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(ipv4_net_table) - 1; i++) {\n\t\t\tif (table[i].data) {\n\t\t\t\t \n\t\t\t\ttable[i].data += (void *)net - (void *)&init_net;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttable[i].mode &= ~0222;\n\t\t\t}\n\t\t}\n\t}\n\n\tnet->ipv4.ipv4_hdr = register_net_sysctl_sz(net, \"net/ipv4\", table,\n\t\t\t\t\t\t    ARRAY_SIZE(ipv4_net_table));\n\tif (!net->ipv4.ipv4_hdr)\n\t\tgoto err_reg;\n\n\tnet->ipv4.sysctl_local_reserved_ports = kzalloc(65536 / 8, GFP_KERNEL);\n\tif (!net->ipv4.sysctl_local_reserved_ports)\n\t\tgoto err_ports;\n\n\treturn 0;\n\nerr_ports:\n\tunregister_net_sysctl_table(net->ipv4.ipv4_hdr);\nerr_reg:\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\nerr_alloc:\n\treturn -ENOMEM;\n}\n\nstatic __net_exit void ipv4_sysctl_exit_net(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\tkfree(net->ipv4.sysctl_local_reserved_ports);\n\ttable = net->ipv4.ipv4_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(net->ipv4.ipv4_hdr);\n\tkfree(table);\n}\n\nstatic __net_initdata struct pernet_operations ipv4_sysctl_ops = {\n\t.init = ipv4_sysctl_init_net,\n\t.exit = ipv4_sysctl_exit_net,\n};\n\nstatic __init int sysctl_ipv4_init(void)\n{\n\tstruct ctl_table_header *hdr;\n\n\thdr = register_net_sysctl(&init_net, \"net/ipv4\", ipv4_table);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tif (register_pernet_subsys(&ipv4_sysctl_ops)) {\n\t\tunregister_net_sysctl_table(hdr);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n__initcall(sysctl_ipv4_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}