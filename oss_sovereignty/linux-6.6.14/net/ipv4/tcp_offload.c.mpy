{
  "module_name": "tcp_offload.c",
  "hash_id": "f7b0c22b0dd84ad918d6bdc4ed88deb5e159855047ad9a7922bda44471875646",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_offload.c",
  "human_readable_source": "\n \n\n#include <linux/indirect_call_wrapper.h>\n#include <linux/skbuff.h>\n#include <net/gro.h>\n#include <net/gso.h>\n#include <net/tcp.h>\n#include <net/protocol.h>\n\nstatic void tcp_gso_tstamp(struct sk_buff *skb, unsigned int ts_seq,\n\t\t\t   unsigned int seq, unsigned int mss)\n{\n\twhile (skb) {\n\t\tif (before(ts_seq, seq + mss)) {\n\t\t\tskb_shinfo(skb)->tx_flags |= SKBTX_SW_TSTAMP;\n\t\t\tskb_shinfo(skb)->tskey = ts_seq;\n\t\t\treturn;\n\t\t}\n\n\t\tskb = skb->next;\n\t\tseq += mss;\n\t}\n}\n\nstatic struct sk_buff *tcp4_gso_segment(struct sk_buff *skb,\n\t\t\t\t\tnetdev_features_t features)\n{\n\tif (!(skb_shinfo(skb)->gso_type & SKB_GSO_TCPV4))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (unlikely(skb->ip_summed != CHECKSUM_PARTIAL)) {\n\t\tconst struct iphdr *iph = ip_hdr(skb);\n\t\tstruct tcphdr *th = tcp_hdr(skb);\n\n\t\t \n\n\t\tth->check = 0;\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\t__tcp_v4_send_check(skb, iph->saddr, iph->daddr);\n\t}\n\n\treturn tcp_gso_segment(skb, features);\n}\n\nstruct sk_buff *tcp_gso_segment(struct sk_buff *skb,\n\t\t\t\tnetdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int sum_truesize = 0;\n\tstruct tcphdr *th;\n\tunsigned int thlen;\n\tunsigned int seq;\n\tunsigned int oldlen;\n\tunsigned int mss;\n\tstruct sk_buff *gso_skb = skb;\n\t__sum16 newcheck;\n\tbool ooo_okay, copy_destructor;\n\t__wsum delta;\n\n\tth = tcp_hdr(skb);\n\tthlen = th->doff * 4;\n\tif (thlen < sizeof(*th))\n\t\tgoto out;\n\n\tif (!pskb_may_pull(skb, thlen))\n\t\tgoto out;\n\n\toldlen = ~skb->len;\n\t__skb_pull(skb, thlen);\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t \n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\tcopy_destructor = gso_skb->destructor == tcp_wfree;\n\tooo_okay = gso_skb->ooo_okay;\n\t \n\tskb->ooo_okay = 0;\n\n\tsegs = skb_segment(skb, features);\n\tif (IS_ERR(segs))\n\t\tgoto out;\n\n\t \n\tsegs->ooo_okay = ooo_okay;\n\n\t \n\tif (skb_is_gso(segs))\n\t\tmss *= skb_shinfo(segs)->gso_segs;\n\n\tdelta = (__force __wsum)htonl(oldlen + thlen + mss);\n\n\tskb = segs;\n\tth = tcp_hdr(skb);\n\tseq = ntohl(th->seq);\n\n\tif (unlikely(skb_shinfo(gso_skb)->tx_flags & SKBTX_SW_TSTAMP))\n\t\ttcp_gso_tstamp(segs, skb_shinfo(gso_skb)->tskey, seq, mss);\n\n\tnewcheck = ~csum_fold(csum_add(csum_unfold(th->check), delta));\n\n\twhile (skb->next) {\n\t\tth->fin = th->psh = 0;\n\t\tth->check = newcheck;\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\tgso_reset_checksum(skb, ~th->check);\n\t\telse\n\t\t\tth->check = gso_make_checksum(skb, ~th->check);\n\n\t\tseq += mss;\n\t\tif (copy_destructor) {\n\t\t\tskb->destructor = gso_skb->destructor;\n\t\t\tskb->sk = gso_skb->sk;\n\t\t\tsum_truesize += skb->truesize;\n\t\t}\n\t\tskb = skb->next;\n\t\tth = tcp_hdr(skb);\n\n\t\tth->seq = htonl(seq);\n\t\tth->cwr = 0;\n\t}\n\n\t \n\tif (copy_destructor) {\n\t\tint delta;\n\n\t\tswap(gso_skb->sk, skb->sk);\n\t\tswap(gso_skb->destructor, skb->destructor);\n\t\tsum_truesize += skb->truesize;\n\t\tdelta = sum_truesize - gso_skb->truesize;\n\t\t \n\t\tif (likely(delta >= 0))\n\t\t\trefcount_add(delta, &skb->sk->sk_wmem_alloc);\n\t\telse\n\t\t\tWARN_ON_ONCE(refcount_sub_and_test(-delta, &skb->sk->sk_wmem_alloc));\n\t}\n\n\tdelta = (__force __wsum)htonl(oldlen +\n\t\t\t\t      (skb_tail_pointer(skb) -\n\t\t\t\t       skb_transport_header(skb)) +\n\t\t\t\t      skb->data_len);\n\tth->check = ~csum_fold(csum_add(csum_unfold(th->check), delta));\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tgso_reset_checksum(skb, ~th->check);\n\telse\n\t\tth->check = gso_make_checksum(skb, ~th->check);\nout:\n\treturn segs;\n}\n\nstruct sk_buff *tcp_gro_receive(struct list_head *head, struct sk_buff *skb)\n{\n\tstruct sk_buff *pp = NULL;\n\tstruct sk_buff *p;\n\tstruct tcphdr *th;\n\tstruct tcphdr *th2;\n\tunsigned int len;\n\tunsigned int thlen;\n\t__be32 flags;\n\tunsigned int mss = 1;\n\tunsigned int hlen;\n\tunsigned int off;\n\tint flush = 1;\n\tint i;\n\n\toff = skb_gro_offset(skb);\n\thlen = off + sizeof(*th);\n\tth = skb_gro_header(skb, hlen, off);\n\tif (unlikely(!th))\n\t\tgoto out;\n\n\tthlen = th->doff * 4;\n\tif (thlen < sizeof(*th))\n\t\tgoto out;\n\n\thlen = off + thlen;\n\tif (skb_gro_header_hard(skb, hlen)) {\n\t\tth = skb_gro_header_slow(skb, hlen, off);\n\t\tif (unlikely(!th))\n\t\t\tgoto out;\n\t}\n\n\tskb_gro_pull(skb, thlen);\n\n\tlen = skb_gro_len(skb);\n\tflags = tcp_flag_word(th);\n\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tth2 = tcp_hdr(p);\n\n\t\tif (*(u32 *)&th->source ^ *(u32 *)&th2->source) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tgoto found;\n\t}\n\tp = NULL;\n\tgoto out_check_final;\n\nfound:\n\t \n\tflush = NAPI_GRO_CB(p)->flush;\n\tflush |= (__force int)(flags & TCP_FLAG_CWR);\n\tflush |= (__force int)((flags ^ tcp_flag_word(th2)) &\n\t\t  ~(TCP_FLAG_CWR | TCP_FLAG_FIN | TCP_FLAG_PSH));\n\tflush |= (__force int)(th->ack_seq ^ th2->ack_seq);\n\tfor (i = sizeof(*th); i < thlen; i += 4)\n\t\tflush |= *(u32 *)((u8 *)th + i) ^\n\t\t\t *(u32 *)((u8 *)th2 + i);\n\n\t \n\tif (NAPI_GRO_CB(p)->flush_id != 1 ||\n\t    NAPI_GRO_CB(p)->count != 1 ||\n\t    !NAPI_GRO_CB(p)->is_atomic)\n\t\tflush |= NAPI_GRO_CB(p)->flush_id;\n\telse\n\t\tNAPI_GRO_CB(p)->is_atomic = false;\n\n\tmss = skb_shinfo(p)->gso_size;\n\n\t \n\tif (unlikely(skb_is_gso(skb)))\n\t\tflush |= (mss != skb_shinfo(skb)->gso_size);\n\telse\n\t\tflush |= (len - 1) >= mss;\n\n\tflush |= (ntohl(th2->seq) + skb_gro_len(p)) ^ ntohl(th->seq);\n#ifdef CONFIG_TLS_DEVICE\n\tflush |= p->decrypted ^ skb->decrypted;\n#endif\n\n\tif (flush || skb_gro_receive(p, skb)) {\n\t\tmss = 1;\n\t\tgoto out_check_final;\n\t}\n\n\ttcp_flag_word(th2) |= flags & (TCP_FLAG_FIN | TCP_FLAG_PSH);\n\nout_check_final:\n\t \n\tif (unlikely(skb_is_gso(skb)))\n\t\tflush = len != NAPI_GRO_CB(skb)->count * skb_shinfo(skb)->gso_size;\n\telse\n\t\tflush = len < mss;\n\n\tflush |= (__force int)(flags & (TCP_FLAG_URG | TCP_FLAG_PSH |\n\t\t\t\t\tTCP_FLAG_RST | TCP_FLAG_SYN |\n\t\t\t\t\tTCP_FLAG_FIN));\n\n\tif (p && (!NAPI_GRO_CB(skb)->same_flow || flush))\n\t\tpp = p;\n\nout:\n\tNAPI_GRO_CB(skb)->flush |= (flush != 0);\n\n\treturn pp;\n}\n\nvoid tcp_gro_complete(struct sk_buff *skb)\n{\n\tstruct tcphdr *th = tcp_hdr(skb);\n\n\tskb->csum_start = (unsigned char *)th - skb->head;\n\tskb->csum_offset = offsetof(struct tcphdr, check);\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\n\tskb_shinfo(skb)->gso_segs = NAPI_GRO_CB(skb)->count;\n\n\tif (th->cwr)\n\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_TCP_ECN;\n\n\tif (skb->encapsulation)\n\t\tskb->inner_transport_header = skb->transport_header;\n}\nEXPORT_SYMBOL(tcp_gro_complete);\n\nINDIRECT_CALLABLE_SCOPE\nstruct sk_buff *tcp4_gro_receive(struct list_head *head, struct sk_buff *skb)\n{\n\t \n\tif (!NAPI_GRO_CB(skb)->flush &&\n\t    skb_gro_checksum_validate(skb, IPPROTO_TCP,\n\t\t\t\t      inet_gro_compute_pseudo)) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\n\treturn tcp_gro_receive(head, skb);\n}\n\nINDIRECT_CALLABLE_SCOPE int tcp4_gro_complete(struct sk_buff *skb, int thoff)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct tcphdr *th = tcp_hdr(skb);\n\n\tth->check = ~tcp_v4_check(skb->len - thoff, iph->saddr,\n\t\t\t\t  iph->daddr, 0);\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_TCPV4;\n\n\tif (NAPI_GRO_CB(skb)->is_atomic)\n\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_TCP_FIXEDID;\n\n\ttcp_gro_complete(skb);\n\treturn 0;\n}\n\nstatic const struct net_offload tcpv4_offload = {\n\t.callbacks = {\n\t\t.gso_segment\t=\ttcp4_gso_segment,\n\t\t.gro_receive\t=\ttcp4_gro_receive,\n\t\t.gro_complete\t=\ttcp4_gro_complete,\n\t},\n};\n\nint __init tcpv4_offload_init(void)\n{\n\treturn inet_add_offload(&tcpv4_offload, IPPROTO_TCP);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}