{
  "module_name": "raw_diag.c",
  "hash_id": "b9b2cfd3f3460cc5b14122911e6961f9ee950da6ae500388ea5f21348c32da39",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/raw_diag.c",
  "human_readable_source": "\n#include <linux/module.h>\n\n#include <linux/inet_diag.h>\n#include <linux/sock_diag.h>\n\n#include <net/inet_sock.h>\n#include <net/raw.h>\n#include <net/rawv6.h>\n\n#ifdef pr_fmt\n# undef pr_fmt\n#endif\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\nstatic struct raw_hashinfo *\nraw_get_hashinfo(const struct inet_diag_req_v2 *r)\n{\n\tif (r->sdiag_family == AF_INET) {\n\t\treturn &raw_v4_hashinfo;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (r->sdiag_family == AF_INET6) {\n\t\treturn &raw_v6_hashinfo;\n#endif\n\t} else {\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n}\n\n \n\nstatic bool raw_lookup(struct net *net, const struct sock *sk,\n\t\t       const struct inet_diag_req_v2 *req)\n{\n\tstruct inet_diag_req_raw *r = (void *)req;\n\n\tif (r->sdiag_family == AF_INET)\n\t\treturn raw_v4_match(net, sk, r->sdiag_raw_protocol,\n\t\t\t\t    r->id.idiag_dst[0],\n\t\t\t\t    r->id.idiag_src[0],\n\t\t\t\t    r->id.idiag_if, 0);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\treturn raw_v6_match(net, sk, r->sdiag_raw_protocol,\n\t\t\t\t    (const struct in6_addr *)r->id.idiag_src,\n\t\t\t\t    (const struct in6_addr *)r->id.idiag_dst,\n\t\t\t\t    r->id.idiag_if, 0);\n#endif\n\treturn false;\n}\n\nstatic struct sock *raw_sock_get(struct net *net, const struct inet_diag_req_v2 *r)\n{\n\tstruct raw_hashinfo *hashinfo = raw_get_hashinfo(r);\n\tstruct hlist_head *hlist;\n\tstruct sock *sk;\n\tint slot;\n\n\tif (IS_ERR(hashinfo))\n\t\treturn ERR_CAST(hashinfo);\n\n\trcu_read_lock();\n\tfor (slot = 0; slot < RAW_HTABLE_SIZE; slot++) {\n\t\thlist = &hashinfo->ht[slot];\n\t\tsk_for_each_rcu(sk, hlist) {\n\t\t\tif (raw_lookup(net, sk, r)) {\n\t\t\t\t \n\t\t\t\tif (refcount_inc_not_zero(&sk->sk_refcnt))\n\t\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\tsk = ERR_PTR(-ENOENT);\nout_unlock:\n\trcu_read_unlock();\n\n\treturn sk;\n}\n\nstatic int raw_diag_dump_one(struct netlink_callback *cb,\n\t\t\t     const struct inet_diag_req_v2 *r)\n{\n\tstruct sk_buff *in_skb = cb->skb;\n\tstruct sk_buff *rep;\n\tstruct sock *sk;\n\tstruct net *net;\n\tint err;\n\n\tnet = sock_net(in_skb->sk);\n\tsk = raw_sock_get(net, r);\n\tif (IS_ERR(sk))\n\t\treturn PTR_ERR(sk);\n\n\trep = nlmsg_new(nla_total_size(sizeof(struct inet_diag_msg)) +\n\t\t\tinet_diag_msg_attrs_size() +\n\t\t\tnla_total_size(sizeof(struct inet_diag_meminfo)) + 64,\n\t\t\tGFP_KERNEL);\n\tif (!rep) {\n\t\tsock_put(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = inet_sk_diag_fill(sk, NULL, rep, cb, r, 0,\n\t\t\t\tnetlink_net_capable(in_skb, CAP_NET_ADMIN));\n\tsock_put(sk);\n\n\tif (err < 0) {\n\t\tkfree_skb(rep);\n\t\treturn err;\n\t}\n\n\terr = nlmsg_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid);\n\n\treturn err;\n}\n\nstatic int sk_diag_dump(struct sock *sk, struct sk_buff *skb,\n\t\t\tstruct netlink_callback *cb,\n\t\t\tconst struct inet_diag_req_v2 *r,\n\t\t\tstruct nlattr *bc, bool net_admin)\n{\n\tif (!inet_diag_bc_sk(bc, sk))\n\t\treturn 0;\n\n\treturn inet_sk_diag_fill(sk, NULL, skb, cb, r, NLM_F_MULTI, net_admin);\n}\n\nstatic void raw_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t  const struct inet_diag_req_v2 *r)\n{\n\tbool net_admin = netlink_net_capable(cb->skb, CAP_NET_ADMIN);\n\tstruct raw_hashinfo *hashinfo = raw_get_hashinfo(r);\n\tstruct net *net = sock_net(skb->sk);\n\tstruct inet_diag_dump_data *cb_data;\n\tint num, s_num, slot, s_slot;\n\tstruct hlist_head *hlist;\n\tstruct sock *sk = NULL;\n\tstruct nlattr *bc;\n\n\tif (IS_ERR(hashinfo))\n\t\treturn;\n\n\tcb_data = cb->data;\n\tbc = cb_data->inet_diag_nla_bc;\n\ts_slot = cb->args[0];\n\tnum = s_num = cb->args[1];\n\n\trcu_read_lock();\n\tfor (slot = s_slot; slot < RAW_HTABLE_SIZE; s_num = 0, slot++) {\n\t\tnum = 0;\n\n\t\thlist = &hashinfo->ht[slot];\n\t\tsk_for_each_rcu(sk, hlist) {\n\t\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\t\tif (!net_eq(sock_net(sk), net))\n\t\t\t\tcontinue;\n\t\t\tif (num < s_num)\n\t\t\t\tgoto next;\n\t\t\tif (sk->sk_family != r->sdiag_family)\n\t\t\t\tgoto next;\n\t\t\tif (r->id.idiag_sport != inet->inet_sport &&\n\t\t\t    r->id.idiag_sport)\n\t\t\t\tgoto next;\n\t\t\tif (r->id.idiag_dport != inet->inet_dport &&\n\t\t\t    r->id.idiag_dport)\n\t\t\t\tgoto next;\n\t\t\tif (sk_diag_dump(sk, skb, cb, r, bc, net_admin) < 0)\n\t\t\t\tgoto out_unlock;\nnext:\n\t\t\tnum++;\n\t\t}\n\t}\n\nout_unlock:\n\trcu_read_unlock();\n\n\tcb->args[0] = slot;\n\tcb->args[1] = num;\n}\n\nstatic void raw_diag_get_info(struct sock *sk, struct inet_diag_msg *r,\n\t\t\t      void *info)\n{\n\tr->idiag_rqueue = sk_rmem_alloc_get(sk);\n\tr->idiag_wqueue = sk_wmem_alloc_get(sk);\n}\n\n#ifdef CONFIG_INET_DIAG_DESTROY\nstatic int raw_diag_destroy(struct sk_buff *in_skb,\n\t\t\t    const struct inet_diag_req_v2 *r)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct sock *sk;\n\tint err;\n\n\tsk = raw_sock_get(net, r);\n\tif (IS_ERR(sk))\n\t\treturn PTR_ERR(sk);\n\terr = sock_diag_destroy(sk, ECONNABORTED);\n\tsock_put(sk);\n\treturn err;\n}\n#endif\n\nstatic const struct inet_diag_handler raw_diag_handler = {\n\t.dump\t\t\t= raw_diag_dump,\n\t.dump_one\t\t= raw_diag_dump_one,\n\t.idiag_get_info\t\t= raw_diag_get_info,\n\t.idiag_type\t\t= IPPROTO_RAW,\n\t.idiag_info_size\t= 0,\n#ifdef CONFIG_INET_DIAG_DESTROY\n\t.destroy\t\t= raw_diag_destroy,\n#endif\n};\n\nstatic void __always_unused __check_inet_diag_req_raw(void)\n{\n\t \n#define __offset_mismatch(m1, m2)\t\t\t\\\n\t(offsetof(struct inet_diag_req_v2, m1) !=\t\\\n\t offsetof(struct inet_diag_req_raw, m2))\n\n\tBUILD_BUG_ON(sizeof(struct inet_diag_req_v2) !=\n\t\t     sizeof(struct inet_diag_req_raw));\n\tBUILD_BUG_ON(__offset_mismatch(sdiag_family, sdiag_family));\n\tBUILD_BUG_ON(__offset_mismatch(sdiag_protocol, sdiag_protocol));\n\tBUILD_BUG_ON(__offset_mismatch(idiag_ext, idiag_ext));\n\tBUILD_BUG_ON(__offset_mismatch(pad, sdiag_raw_protocol));\n\tBUILD_BUG_ON(__offset_mismatch(idiag_states, idiag_states));\n\tBUILD_BUG_ON(__offset_mismatch(id, id));\n#undef __offset_mismatch\n}\n\nstatic int __init raw_diag_init(void)\n{\n\treturn inet_diag_register(&raw_diag_handler);\n}\n\nstatic void __exit raw_diag_exit(void)\n{\n\tinet_diag_unregister(&raw_diag_handler);\n}\n\nmodule_init(raw_diag_init);\nmodule_exit(raw_diag_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 2-255  );\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 10-255  );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}