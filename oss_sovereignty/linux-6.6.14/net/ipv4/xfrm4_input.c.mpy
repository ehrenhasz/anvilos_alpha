{
  "module_name": "xfrm4_input.c",
  "hash_id": "296881b85642811e9f46ad182f6e28e30bb173034f7a716b0c4905fcc0c0a851",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/xfrm4_input.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <net/ip.h>\n#include <net/xfrm.h>\n\nstatic int xfrm4_rcv_encap_finish2(struct net *net, struct sock *sk,\n\t\t\t\t   struct sk_buff *skb)\n{\n\treturn dst_input(skb);\n}\n\nstatic inline int xfrm4_rcv_encap_finish(struct net *net, struct sock *sk,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tif (!skb_dst(skb)) {\n\t\tconst struct iphdr *iph = ip_hdr(skb);\n\n\t\tif (ip_route_input_noref(skb, iph->daddr, iph->saddr,\n\t\t\t\t\t iph->tos, skb->dev))\n\t\t\tgoto drop;\n\t}\n\n\tif (xfrm_trans_queue(skb, xfrm4_rcv_encap_finish2))\n\t\tgoto drop;\n\n\treturn 0;\ndrop:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\nint xfrm4_transport_finish(struct sk_buff *skb, int async)\n{\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tstruct iphdr *iph = ip_hdr(skb);\n\n\tiph->protocol = XFRM_MODE_SKB_CB(skb)->protocol;\n\n#ifndef CONFIG_NETFILTER\n\tif (!async)\n\t\treturn -iph->protocol;\n#endif\n\n\t__skb_push(skb, skb->data - skb_network_header(skb));\n\tiph->tot_len = htons(skb->len);\n\tip_send_check(iph);\n\n\tif (xo && (xo->flags & XFRM_GRO)) {\n\t\tskb_mac_header_rebuild(skb);\n\t\tskb_reset_transport_header(skb);\n\t\treturn 0;\n\t}\n\n\tNF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,\n\t\tdev_net(skb->dev), NULL, skb, skb->dev, NULL,\n\t\txfrm4_rcv_encap_finish);\n\treturn 0;\n}\n\n \nint xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct udphdr *uh;\n\tstruct iphdr *iph;\n\tint iphlen, len;\n\t__u8 *udpdata;\n\t__be32 *udpdata32;\n\tu16 encap_type;\n\n\tencap_type = READ_ONCE(up->encap_type);\n\t \n\tif (!encap_type)\n\t\treturn 1;\n\n\t \n\tlen = skb->len - sizeof(struct udphdr);\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr) + min(len, 8)))\n\t\treturn 1;\n\n\t \n\tuh = udp_hdr(skb);\n\tudpdata = (__u8 *)uh + sizeof(struct udphdr);\n\tudpdata32 = (__be32 *)udpdata;\n\n\tswitch (encap_type) {\n\tdefault:\n\tcase UDP_ENCAP_ESPINUDP:\n\t\t \n\t\tif (len == 1 && udpdata[0] == 0xff) {\n\t\t\tgoto drop;\n\t\t} else if (len > sizeof(struct ip_esp_hdr) && udpdata32[0] != 0) {\n\t\t\t \n\t\t\tlen = sizeof(struct udphdr);\n\t\t} else\n\t\t\t \n\t\t\treturn 1;\n\t\tbreak;\n\tcase UDP_ENCAP_ESPINUDP_NON_IKE:\n\t\t \n\t\tif (len == 1 && udpdata[0] == 0xff) {\n\t\t\tgoto drop;\n\t\t} else if (len > 2 * sizeof(u32) + sizeof(struct ip_esp_hdr) &&\n\t\t\t   udpdata32[0] == 0 && udpdata32[1] == 0) {\n\n\t\t\t \n\t\t\tlen = sizeof(struct udphdr) + 2 * sizeof(u32);\n\t\t} else\n\t\t\t \n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\n\t \n\tif (skb_unclone(skb, GFP_ATOMIC))\n\t\tgoto drop;\n\n\t \n\tiph = ip_hdr(skb);\n\tiphlen = iph->ihl << 2;\n\tiph->tot_len = htons(ntohs(iph->tot_len) - len);\n\tif (skb->len < iphlen + len) {\n\t\t \n\t\tgoto drop;\n\t}\n\n\t \n\t__skb_pull(skb, len);\n\tskb_reset_transport_header(skb);\n\n\t \n\treturn xfrm4_rcv_encap(skb, IPPROTO_ESP, 0, encap_type);\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\nEXPORT_SYMBOL(xfrm4_udp_encap_rcv);\n\nint xfrm4_rcv(struct sk_buff *skb)\n{\n\treturn xfrm4_rcv_spi(skb, ip_hdr(skb)->protocol, 0);\n}\nEXPORT_SYMBOL(xfrm4_rcv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}