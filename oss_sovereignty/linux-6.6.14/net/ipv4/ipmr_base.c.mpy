{
  "module_name": "ipmr_base.c",
  "hash_id": "f717b941ffc6a724ef79abbf156d32c390869d7fae872df1b7b6d5748ac12c6f",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ipmr_base.c",
  "human_readable_source": " \n\n#include <linux/rhashtable.h>\n#include <linux/mroute_base.h>\n\n \nvoid vif_device_init(struct vif_device *v,\n\t\t     struct net_device *dev,\n\t\t     unsigned long rate_limit,\n\t\t     unsigned char threshold,\n\t\t     unsigned short flags,\n\t\t     unsigned short get_iflink_mask)\n{\n\tRCU_INIT_POINTER(v->dev, NULL);\n\tv->bytes_in = 0;\n\tv->bytes_out = 0;\n\tv->pkt_in = 0;\n\tv->pkt_out = 0;\n\tv->rate_limit = rate_limit;\n\tv->flags = flags;\n\tv->threshold = threshold;\n\tif (v->flags & get_iflink_mask)\n\t\tv->link = dev_get_iflink(dev);\n\telse\n\t\tv->link = dev->ifindex;\n}\nEXPORT_SYMBOL(vif_device_init);\n\nstruct mr_table *\nmr_table_alloc(struct net *net, u32 id,\n\t       struct mr_table_ops *ops,\n\t       void (*expire_func)(struct timer_list *t),\n\t       void (*table_set)(struct mr_table *mrt,\n\t\t\t\t struct net *net))\n{\n\tstruct mr_table *mrt;\n\tint err;\n\n\tmrt = kzalloc(sizeof(*mrt), GFP_KERNEL);\n\tif (!mrt)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmrt->id = id;\n\twrite_pnet(&mrt->net, net);\n\n\tmrt->ops = *ops;\n\terr = rhltable_init(&mrt->mfc_hash, mrt->ops.rht_params);\n\tif (err) {\n\t\tkfree(mrt);\n\t\treturn ERR_PTR(err);\n\t}\n\tINIT_LIST_HEAD(&mrt->mfc_cache_list);\n\tINIT_LIST_HEAD(&mrt->mfc_unres_queue);\n\n\ttimer_setup(&mrt->ipmr_expire_timer, expire_func, 0);\n\n\tmrt->mroute_reg_vif_num = -1;\n\ttable_set(mrt, net);\n\treturn mrt;\n}\nEXPORT_SYMBOL(mr_table_alloc);\n\nvoid *mr_mfc_find_parent(struct mr_table *mrt, void *hasharg, int parent)\n{\n\tstruct rhlist_head *tmp, *list;\n\tstruct mr_mfc *c;\n\n\tlist = rhltable_lookup(&mrt->mfc_hash, hasharg, *mrt->ops.rht_params);\n\trhl_for_each_entry_rcu(c, tmp, list, mnode)\n\t\tif (parent == -1 || parent == c->mfc_parent)\n\t\t\treturn c;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(mr_mfc_find_parent);\n\nvoid *mr_mfc_find_any_parent(struct mr_table *mrt, int vifi)\n{\n\tstruct rhlist_head *tmp, *list;\n\tstruct mr_mfc *c;\n\n\tlist = rhltable_lookup(&mrt->mfc_hash, mrt->ops.cmparg_any,\n\t\t\t       *mrt->ops.rht_params);\n\trhl_for_each_entry_rcu(c, tmp, list, mnode)\n\t\tif (c->mfc_un.res.ttls[vifi] < 255)\n\t\t\treturn c;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(mr_mfc_find_any_parent);\n\nvoid *mr_mfc_find_any(struct mr_table *mrt, int vifi, void *hasharg)\n{\n\tstruct rhlist_head *tmp, *list;\n\tstruct mr_mfc *c, *proxy;\n\n\tlist = rhltable_lookup(&mrt->mfc_hash, hasharg, *mrt->ops.rht_params);\n\trhl_for_each_entry_rcu(c, tmp, list, mnode) {\n\t\tif (c->mfc_un.res.ttls[vifi] < 255)\n\t\t\treturn c;\n\n\t\t \n\t\tproxy = mr_mfc_find_any_parent(mrt, c->mfc_parent);\n\t\tif (proxy && proxy->mfc_un.res.ttls[vifi] < 255)\n\t\t\treturn c;\n\t}\n\n\treturn mr_mfc_find_any_parent(mrt, vifi);\n}\nEXPORT_SYMBOL(mr_mfc_find_any);\n\n#ifdef CONFIG_PROC_FS\nvoid *mr_vif_seq_idx(struct net *net, struct mr_vif_iter *iter, loff_t pos)\n{\n\tstruct mr_table *mrt = iter->mrt;\n\n\tfor (iter->ct = 0; iter->ct < mrt->maxvif; ++iter->ct) {\n\t\tif (!VIF_EXISTS(mrt, iter->ct))\n\t\t\tcontinue;\n\t\tif (pos-- == 0)\n\t\t\treturn &mrt->vif_table[iter->ct];\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(mr_vif_seq_idx);\n\nvoid *mr_vif_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct mr_vif_iter *iter = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct mr_table *mrt = iter->mrt;\n\n\t++*pos;\n\tif (v == SEQ_START_TOKEN)\n\t\treturn mr_vif_seq_idx(net, iter, 0);\n\n\twhile (++iter->ct < mrt->maxvif) {\n\t\tif (!VIF_EXISTS(mrt, iter->ct))\n\t\t\tcontinue;\n\t\treturn &mrt->vif_table[iter->ct];\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(mr_vif_seq_next);\n\nvoid *mr_mfc_seq_idx(struct net *net,\n\t\t     struct mr_mfc_iter *it, loff_t pos)\n{\n\tstruct mr_table *mrt = it->mrt;\n\tstruct mr_mfc *mfc;\n\n\trcu_read_lock();\n\tit->cache = &mrt->mfc_cache_list;\n\tlist_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list)\n\t\tif (pos-- == 0)\n\t\t\treturn mfc;\n\trcu_read_unlock();\n\n\tspin_lock_bh(it->lock);\n\tit->cache = &mrt->mfc_unres_queue;\n\tlist_for_each_entry(mfc, it->cache, list)\n\t\tif (pos-- == 0)\n\t\t\treturn mfc;\n\tspin_unlock_bh(it->lock);\n\n\tit->cache = NULL;\n\treturn NULL;\n}\nEXPORT_SYMBOL(mr_mfc_seq_idx);\n\nvoid *mr_mfc_seq_next(struct seq_file *seq, void *v,\n\t\t      loff_t *pos)\n{\n\tstruct mr_mfc_iter *it = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct mr_table *mrt = it->mrt;\n\tstruct mr_mfc *c = v;\n\n\t++*pos;\n\n\tif (v == SEQ_START_TOKEN)\n\t\treturn mr_mfc_seq_idx(net, seq->private, 0);\n\n\tif (c->list.next != it->cache)\n\t\treturn list_entry(c->list.next, struct mr_mfc, list);\n\n\tif (it->cache == &mrt->mfc_unres_queue)\n\t\tgoto end_of_list;\n\n\t \n\trcu_read_unlock();\n\tit->cache = &mrt->mfc_unres_queue;\n\n\tspin_lock_bh(it->lock);\n\tif (!list_empty(it->cache))\n\t\treturn list_first_entry(it->cache, struct mr_mfc, list);\n\nend_of_list:\n\tspin_unlock_bh(it->lock);\n\tit->cache = NULL;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(mr_mfc_seq_next);\n#endif\n\nint mr_fill_mroute(struct mr_table *mrt, struct sk_buff *skb,\n\t\t   struct mr_mfc *c, struct rtmsg *rtm)\n{\n\tstruct net_device *vif_dev;\n\tstruct rta_mfc_stats mfcs;\n\tstruct nlattr *mp_attr;\n\tstruct rtnexthop *nhp;\n\tunsigned long lastuse;\n\tint ct;\n\n\t \n\tif (c->mfc_parent >= MAXVIFS) {\n\t\trtm->rtm_flags |= RTNH_F_UNRESOLVED;\n\t\treturn -ENOENT;\n\t}\n\n\trcu_read_lock();\n\tvif_dev = rcu_dereference(mrt->vif_table[c->mfc_parent].dev);\n\tif (vif_dev && nla_put_u32(skb, RTA_IIF, vif_dev->ifindex) < 0) {\n\t\trcu_read_unlock();\n\t\treturn -EMSGSIZE;\n\t}\n\trcu_read_unlock();\n\n\tif (c->mfc_flags & MFC_OFFLOAD)\n\t\trtm->rtm_flags |= RTNH_F_OFFLOAD;\n\n\tmp_attr = nla_nest_start_noflag(skb, RTA_MULTIPATH);\n\tif (!mp_attr)\n\t\treturn -EMSGSIZE;\n\n\trcu_read_lock();\n\tfor (ct = c->mfc_un.res.minvif; ct < c->mfc_un.res.maxvif; ct++) {\n\t\tstruct vif_device *vif = &mrt->vif_table[ct];\n\n\t\tvif_dev = rcu_dereference(vif->dev);\n\t\tif (vif_dev && c->mfc_un.res.ttls[ct] < 255) {\n\n\t\t\tnhp = nla_reserve_nohdr(skb, sizeof(*nhp));\n\t\t\tif (!nhp) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tnla_nest_cancel(skb, mp_attr);\n\t\t\t\treturn -EMSGSIZE;\n\t\t\t}\n\n\t\t\tnhp->rtnh_flags = 0;\n\t\t\tnhp->rtnh_hops = c->mfc_un.res.ttls[ct];\n\t\t\tnhp->rtnh_ifindex = vif_dev->ifindex;\n\t\t\tnhp->rtnh_len = sizeof(*nhp);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tnla_nest_end(skb, mp_attr);\n\n\tlastuse = READ_ONCE(c->mfc_un.res.lastuse);\n\tlastuse = time_after_eq(jiffies, lastuse) ? jiffies - lastuse : 0;\n\n\tmfcs.mfcs_packets = c->mfc_un.res.pkt;\n\tmfcs.mfcs_bytes = c->mfc_un.res.bytes;\n\tmfcs.mfcs_wrong_if = c->mfc_un.res.wrong_if;\n\tif (nla_put_64bit(skb, RTA_MFC_STATS, sizeof(mfcs), &mfcs, RTA_PAD) ||\n\t    nla_put_u64_64bit(skb, RTA_EXPIRES, jiffies_to_clock_t(lastuse),\n\t\t\t      RTA_PAD))\n\t\treturn -EMSGSIZE;\n\n\trtm->rtm_type = RTN_MULTICAST;\n\treturn 1;\n}\nEXPORT_SYMBOL(mr_fill_mroute);\n\nstatic bool mr_mfc_uses_dev(const struct mr_table *mrt,\n\t\t\t    const struct mr_mfc *c,\n\t\t\t    const struct net_device *dev)\n{\n\tint ct;\n\n\tfor (ct = c->mfc_un.res.minvif; ct < c->mfc_un.res.maxvif; ct++) {\n\t\tconst struct net_device *vif_dev;\n\t\tconst struct vif_device *vif;\n\n\t\tvif = &mrt->vif_table[ct];\n\t\tvif_dev = rcu_access_pointer(vif->dev);\n\t\tif (vif_dev && c->mfc_un.res.ttls[ct] < 255 &&\n\t\t    vif_dev == dev)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint mr_table_dump(struct mr_table *mrt, struct sk_buff *skb,\n\t\t  struct netlink_callback *cb,\n\t\t  int (*fill)(struct mr_table *mrt, struct sk_buff *skb,\n\t\t\t      u32 portid, u32 seq, struct mr_mfc *c,\n\t\t\t      int cmd, int flags),\n\t\t  spinlock_t *lock, struct fib_dump_filter *filter)\n{\n\tunsigned int e = 0, s_e = cb->args[1];\n\tunsigned int flags = NLM_F_MULTI;\n\tstruct mr_mfc *mfc;\n\tint err;\n\n\tif (filter->filter_set)\n\t\tflags |= NLM_F_DUMP_FILTERED;\n\n\tlist_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list) {\n\t\tif (e < s_e)\n\t\t\tgoto next_entry;\n\t\tif (filter->dev &&\n\t\t    !mr_mfc_uses_dev(mrt, mfc, filter->dev))\n\t\t\tgoto next_entry;\n\n\t\terr = fill(mrt, skb, NETLINK_CB(cb->skb).portid,\n\t\t\t   cb->nlh->nlmsg_seq, mfc, RTM_NEWROUTE, flags);\n\t\tif (err < 0)\n\t\t\tgoto out;\nnext_entry:\n\t\te++;\n\t}\n\n\tspin_lock_bh(lock);\n\tlist_for_each_entry(mfc, &mrt->mfc_unres_queue, list) {\n\t\tif (e < s_e)\n\t\t\tgoto next_entry2;\n\t\tif (filter->dev &&\n\t\t    !mr_mfc_uses_dev(mrt, mfc, filter->dev))\n\t\t\tgoto next_entry2;\n\n\t\terr = fill(mrt, skb, NETLINK_CB(cb->skb).portid,\n\t\t\t   cb->nlh->nlmsg_seq, mfc, RTM_NEWROUTE, flags);\n\t\tif (err < 0) {\n\t\t\tspin_unlock_bh(lock);\n\t\t\tgoto out;\n\t\t}\nnext_entry2:\n\t\te++;\n\t}\n\tspin_unlock_bh(lock);\n\terr = 0;\nout:\n\tcb->args[1] = e;\n\treturn err;\n}\nEXPORT_SYMBOL(mr_table_dump);\n\nint mr_rtm_dumproute(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t     struct mr_table *(*iter)(struct net *net,\n\t\t\t\t\t      struct mr_table *mrt),\n\t\t     int (*fill)(struct mr_table *mrt,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t u32 portid, u32 seq, struct mr_mfc *c,\n\t\t\t\t int cmd, int flags),\n\t\t     spinlock_t *lock, struct fib_dump_filter *filter)\n{\n\tunsigned int t = 0, s_t = cb->args[0];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct mr_table *mrt;\n\tint err;\n\n\t \n\tif (filter->filter_set) {\n\t\tif (filter->protocol || filter->flags ||\n\t\t    (filter->rt_type && filter->rt_type != RTN_MULTICAST))\n\t\t\treturn skb->len;\n\t}\n\n\trcu_read_lock();\n\tfor (mrt = iter(net, NULL); mrt; mrt = iter(net, mrt)) {\n\t\tif (t < s_t)\n\t\t\tgoto next_table;\n\n\t\terr = mr_table_dump(mrt, skb, cb, fill, lock, filter);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tcb->args[1] = 0;\nnext_table:\n\t\tt++;\n\t}\n\trcu_read_unlock();\n\n\tcb->args[0] = t;\n\n\treturn skb->len;\n}\nEXPORT_SYMBOL(mr_rtm_dumproute);\n\nint mr_dump(struct net *net, struct notifier_block *nb, unsigned short family,\n\t    int (*rules_dump)(struct net *net,\n\t\t\t      struct notifier_block *nb,\n\t\t\t      struct netlink_ext_ack *extack),\n\t    struct mr_table *(*mr_iter)(struct net *net,\n\t\t\t\t\tstruct mr_table *mrt),\n\t    struct netlink_ext_ack *extack)\n{\n\tstruct mr_table *mrt;\n\tint err;\n\n\terr = rules_dump(net, nb, extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (mrt = mr_iter(net, NULL); mrt; mrt = mr_iter(net, mrt)) {\n\t\tstruct vif_device *v = &mrt->vif_table[0];\n\t\tstruct net_device *vif_dev;\n\t\tstruct mr_mfc *mfc;\n\t\tint vifi;\n\n\t\t \n\t\trcu_read_lock();\n\t\tfor (vifi = 0; vifi < mrt->maxvif; vifi++, v++) {\n\t\t\tvif_dev = rcu_dereference(v->dev);\n\t\t\tif (!vif_dev)\n\t\t\t\tcontinue;\n\n\t\t\terr = mr_call_vif_notifier(nb, family,\n\t\t\t\t\t\t   FIB_EVENT_VIF_ADD, v,\n\t\t\t\t\t\t   vif_dev, vifi,\n\t\t\t\t\t\t   mrt->id, extack);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tlist_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list) {\n\t\t\terr = mr_call_mfc_notifier(nb, family,\n\t\t\t\t\t\t   FIB_EVENT_ENTRY_ADD,\n\t\t\t\t\t\t   mfc, mrt->id, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mr_dump);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}