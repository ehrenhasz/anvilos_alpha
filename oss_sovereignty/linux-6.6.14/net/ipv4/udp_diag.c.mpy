{
  "module_name": "udp_diag.c",
  "hash_id": "0bd4fe08691c4e87e91da02b0b8c1d08e4b37b639e33fe273bc917af54426756",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/udp_diag.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/inet_diag.h>\n#include <linux/udp.h>\n#include <net/udp.h>\n#include <net/udplite.h>\n#include <linux/sock_diag.h>\n\nstatic int sk_diag_dump(struct sock *sk, struct sk_buff *skb,\n\t\t\tstruct netlink_callback *cb,\n\t\t\tconst struct inet_diag_req_v2 *req,\n\t\t\tstruct nlattr *bc, bool net_admin)\n{\n\tif (!inet_diag_bc_sk(bc, sk))\n\t\treturn 0;\n\n\treturn inet_sk_diag_fill(sk, NULL, skb, cb, req, NLM_F_MULTI,\n\t\t\t\t net_admin);\n}\n\nstatic int udp_dump_one(struct udp_table *tbl,\n\t\t\tstruct netlink_callback *cb,\n\t\t\tconst struct inet_diag_req_v2 *req)\n{\n\tstruct sk_buff *in_skb = cb->skb;\n\tint err;\n\tstruct sock *sk = NULL;\n\tstruct sk_buff *rep;\n\tstruct net *net = sock_net(in_skb->sk);\n\n\trcu_read_lock();\n\tif (req->sdiag_family == AF_INET)\n\t\t \n\t\tsk = __udp4_lib_lookup(net,\n\t\t\t\treq->id.idiag_src[0], req->id.idiag_sport,\n\t\t\t\treq->id.idiag_dst[0], req->id.idiag_dport,\n\t\t\t\treq->id.idiag_if, 0, tbl, NULL);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (req->sdiag_family == AF_INET6)\n\t\tsk = __udp6_lib_lookup(net,\n\t\t\t\t(struct in6_addr *)req->id.idiag_src,\n\t\t\t\treq->id.idiag_sport,\n\t\t\t\t(struct in6_addr *)req->id.idiag_dst,\n\t\t\t\treq->id.idiag_dport,\n\t\t\t\treq->id.idiag_if, 0, tbl, NULL);\n#endif\n\tif (sk && !refcount_inc_not_zero(&sk->sk_refcnt))\n\t\tsk = NULL;\n\trcu_read_unlock();\n\terr = -ENOENT;\n\tif (!sk)\n\t\tgoto out_nosk;\n\n\terr = sock_diag_check_cookie(sk, req->id.idiag_cookie);\n\tif (err)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\trep = nlmsg_new(nla_total_size(sizeof(struct inet_diag_msg)) +\n\t\t\tinet_diag_msg_attrs_size() +\n\t\t\tnla_total_size(sizeof(struct inet_diag_meminfo)) + 64,\n\t\t\tGFP_KERNEL);\n\tif (!rep)\n\t\tgoto out;\n\n\terr = inet_sk_diag_fill(sk, NULL, rep, cb, req, 0,\n\t\t\t\tnetlink_net_capable(in_skb, CAP_NET_ADMIN));\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(rep);\n\t\tgoto out;\n\t}\n\terr = nlmsg_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid);\n\nout:\n\tif (sk)\n\t\tsock_put(sk);\nout_nosk:\n\treturn err;\n}\n\nstatic void udp_dump(struct udp_table *table, struct sk_buff *skb,\n\t\t     struct netlink_callback *cb,\n\t\t     const struct inet_diag_req_v2 *r)\n{\n\tbool net_admin = netlink_net_capable(cb->skb, CAP_NET_ADMIN);\n\tstruct net *net = sock_net(skb->sk);\n\tstruct inet_diag_dump_data *cb_data;\n\tint num, s_num, slot, s_slot;\n\tstruct nlattr *bc;\n\n\tcb_data = cb->data;\n\tbc = cb_data->inet_diag_nla_bc;\n\ts_slot = cb->args[0];\n\tnum = s_num = cb->args[1];\n\n\tfor (slot = s_slot; slot <= table->mask; s_num = 0, slot++) {\n\t\tstruct udp_hslot *hslot = &table->hash[slot];\n\t\tstruct sock *sk;\n\n\t\tnum = 0;\n\n\t\tif (hlist_empty(&hslot->head))\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(&hslot->lock);\n\t\tsk_for_each(sk, &hslot->head) {\n\t\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\t\tif (!net_eq(sock_net(sk), net))\n\t\t\t\tcontinue;\n\t\t\tif (num < s_num)\n\t\t\t\tgoto next;\n\t\t\tif (!(r->idiag_states & (1 << sk->sk_state)))\n\t\t\t\tgoto next;\n\t\t\tif (r->sdiag_family != AF_UNSPEC &&\n\t\t\t\t\tsk->sk_family != r->sdiag_family)\n\t\t\t\tgoto next;\n\t\t\tif (r->id.idiag_sport != inet->inet_sport &&\n\t\t\t    r->id.idiag_sport)\n\t\t\t\tgoto next;\n\t\t\tif (r->id.idiag_dport != inet->inet_dport &&\n\t\t\t    r->id.idiag_dport)\n\t\t\t\tgoto next;\n\n\t\t\tif (sk_diag_dump(sk, skb, cb, r, bc, net_admin) < 0) {\n\t\t\t\tspin_unlock_bh(&hslot->lock);\n\t\t\t\tgoto done;\n\t\t\t}\nnext:\n\t\t\tnum++;\n\t\t}\n\t\tspin_unlock_bh(&hslot->lock);\n\t}\ndone:\n\tcb->args[0] = slot;\n\tcb->args[1] = num;\n}\n\nstatic void udp_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t  const struct inet_diag_req_v2 *r)\n{\n\tudp_dump(sock_net(cb->skb->sk)->ipv4.udp_table, skb, cb, r);\n}\n\nstatic int udp_diag_dump_one(struct netlink_callback *cb,\n\t\t\t     const struct inet_diag_req_v2 *req)\n{\n\treturn udp_dump_one(sock_net(cb->skb->sk)->ipv4.udp_table, cb, req);\n}\n\nstatic void udp_diag_get_info(struct sock *sk, struct inet_diag_msg *r,\n\t\tvoid *info)\n{\n\tr->idiag_rqueue = udp_rqueue_get(sk);\n\tr->idiag_wqueue = sk_wmem_alloc_get(sk);\n}\n\n#ifdef CONFIG_INET_DIAG_DESTROY\nstatic int __udp_diag_destroy(struct sk_buff *in_skb,\n\t\t\t      const struct inet_diag_req_v2 *req,\n\t\t\t      struct udp_table *tbl)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct sock *sk;\n\tint err;\n\n\trcu_read_lock();\n\n\tif (req->sdiag_family == AF_INET)\n\t\tsk = __udp4_lib_lookup(net,\n\t\t\t\treq->id.idiag_dst[0], req->id.idiag_dport,\n\t\t\t\treq->id.idiag_src[0], req->id.idiag_sport,\n\t\t\t\treq->id.idiag_if, 0, tbl, NULL);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse if (req->sdiag_family == AF_INET6) {\n\t\tif (ipv6_addr_v4mapped((struct in6_addr *)req->id.idiag_dst) &&\n\t\t    ipv6_addr_v4mapped((struct in6_addr *)req->id.idiag_src))\n\t\t\tsk = __udp4_lib_lookup(net,\n\t\t\t\t\treq->id.idiag_dst[3], req->id.idiag_dport,\n\t\t\t\t\treq->id.idiag_src[3], req->id.idiag_sport,\n\t\t\t\t\treq->id.idiag_if, 0, tbl, NULL);\n\n\t\telse\n\t\t\tsk = __udp6_lib_lookup(net,\n\t\t\t\t\t(struct in6_addr *)req->id.idiag_dst,\n\t\t\t\t\treq->id.idiag_dport,\n\t\t\t\t\t(struct in6_addr *)req->id.idiag_src,\n\t\t\t\t\treq->id.idiag_sport,\n\t\t\t\t\treq->id.idiag_if, 0, tbl, NULL);\n\t}\n#endif\n\telse {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tif (sk && !refcount_inc_not_zero(&sk->sk_refcnt))\n\t\tsk = NULL;\n\n\trcu_read_unlock();\n\n\tif (!sk)\n\t\treturn -ENOENT;\n\n\tif (sock_diag_check_cookie(sk, req->id.idiag_cookie)) {\n\t\tsock_put(sk);\n\t\treturn -ENOENT;\n\t}\n\n\terr = sock_diag_destroy(sk, ECONNABORTED);\n\n\tsock_put(sk);\n\n\treturn err;\n}\n\nstatic int udp_diag_destroy(struct sk_buff *in_skb,\n\t\t\t    const struct inet_diag_req_v2 *req)\n{\n\treturn __udp_diag_destroy(in_skb, req, sock_net(in_skb->sk)->ipv4.udp_table);\n}\n\nstatic int udplite_diag_destroy(struct sk_buff *in_skb,\n\t\t\t\tconst struct inet_diag_req_v2 *req)\n{\n\treturn __udp_diag_destroy(in_skb, req, &udplite_table);\n}\n\n#endif\n\nstatic const struct inet_diag_handler udp_diag_handler = {\n\t.dump\t\t = udp_diag_dump,\n\t.dump_one\t = udp_diag_dump_one,\n\t.idiag_get_info  = udp_diag_get_info,\n\t.idiag_type\t = IPPROTO_UDP,\n\t.idiag_info_size = 0,\n#ifdef CONFIG_INET_DIAG_DESTROY\n\t.destroy\t = udp_diag_destroy,\n#endif\n};\n\nstatic void udplite_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t      const struct inet_diag_req_v2 *r)\n{\n\tudp_dump(&udplite_table, skb, cb, r);\n}\n\nstatic int udplite_diag_dump_one(struct netlink_callback *cb,\n\t\t\t\t const struct inet_diag_req_v2 *req)\n{\n\treturn udp_dump_one(&udplite_table, cb, req);\n}\n\nstatic const struct inet_diag_handler udplite_diag_handler = {\n\t.dump\t\t = udplite_diag_dump,\n\t.dump_one\t = udplite_diag_dump_one,\n\t.idiag_get_info  = udp_diag_get_info,\n\t.idiag_type\t = IPPROTO_UDPLITE,\n\t.idiag_info_size = 0,\n#ifdef CONFIG_INET_DIAG_DESTROY\n\t.destroy\t = udplite_diag_destroy,\n#endif\n};\n\nstatic int __init udp_diag_init(void)\n{\n\tint err;\n\n\terr = inet_diag_register(&udp_diag_handler);\n\tif (err)\n\t\tgoto out;\n\terr = inet_diag_register(&udplite_diag_handler);\n\tif (err)\n\t\tgoto out_lite;\nout:\n\treturn err;\nout_lite:\n\tinet_diag_unregister(&udp_diag_handler);\n\tgoto out;\n}\n\nstatic void __exit udp_diag_exit(void)\n{\n\tinet_diag_unregister(&udplite_diag_handler);\n\tinet_diag_unregister(&udp_diag_handler);\n}\n\nmodule_init(udp_diag_init);\nmodule_exit(udp_diag_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 2-17  );\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 2-136  );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}