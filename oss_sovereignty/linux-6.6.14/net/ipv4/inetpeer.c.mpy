{
  "module_name": "inetpeer.c",
  "hash_id": "1275547ae429467d09d1218dcb88429a2df7cee35d7ecd378398f841c7db9114",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/inetpeer.c",
  "human_readable_source": " \n\n#include <linux/cache.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/random.h>\n#include <linux/timer.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/net.h>\n#include <linux/workqueue.h>\n#include <net/ip.h>\n#include <net/inetpeer.h>\n#include <net/secure_seq.h>\n\n \n\nstatic struct kmem_cache *peer_cachep __ro_after_init;\n\nvoid inet_peer_base_init(struct inet_peer_base *bp)\n{\n\tbp->rb_root = RB_ROOT;\n\tseqlock_init(&bp->lock);\n\tbp->total = 0;\n}\nEXPORT_SYMBOL_GPL(inet_peer_base_init);\n\n#define PEER_MAX_GC 32\n\n \nint inet_peer_threshold __read_mostly;\t \nint inet_peer_minttl __read_mostly = 120 * HZ;\t \nint inet_peer_maxttl __read_mostly = 10 * 60 * HZ;\t \n\n \nvoid __init inet_initpeers(void)\n{\n\tu64 nr_entries;\n\n\t  \n\tnr_entries = div64_ul((u64)totalram_pages() << PAGE_SHIFT,\n\t\t\t      100 * L1_CACHE_ALIGN(sizeof(struct inet_peer)));\n\n\tinet_peer_threshold = clamp_val(nr_entries, 4096, 65536 + 128);\n\n\tpeer_cachep = kmem_cache_create(\"inet_peer_cache\",\n\t\t\tsizeof(struct inet_peer),\n\t\t\t0, SLAB_HWCACHE_ALIGN | SLAB_PANIC,\n\t\t\tNULL);\n}\n\n \nstatic struct inet_peer *lookup(const struct inetpeer_addr *daddr,\n\t\t\t\tstruct inet_peer_base *base,\n\t\t\t\tunsigned int seq,\n\t\t\t\tstruct inet_peer *gc_stack[],\n\t\t\t\tunsigned int *gc_cnt,\n\t\t\t\tstruct rb_node **parent_p,\n\t\t\t\tstruct rb_node ***pp_p)\n{\n\tstruct rb_node **pp, *parent, *next;\n\tstruct inet_peer *p;\n\n\tpp = &base->rb_root.rb_node;\n\tparent = NULL;\n\twhile (1) {\n\t\tint cmp;\n\n\t\tnext = rcu_dereference_raw(*pp);\n\t\tif (!next)\n\t\t\tbreak;\n\t\tparent = next;\n\t\tp = rb_entry(parent, struct inet_peer, rb_node);\n\t\tcmp = inetpeer_addr_cmp(daddr, &p->daddr);\n\t\tif (cmp == 0) {\n\t\t\tif (!refcount_inc_not_zero(&p->refcnt))\n\t\t\t\tbreak;\n\t\t\treturn p;\n\t\t}\n\t\tif (gc_stack) {\n\t\t\tif (*gc_cnt < PEER_MAX_GC)\n\t\t\t\tgc_stack[(*gc_cnt)++] = p;\n\t\t} else if (unlikely(read_seqretry(&base->lock, seq))) {\n\t\t\tbreak;\n\t\t}\n\t\tif (cmp == -1)\n\t\t\tpp = &next->rb_left;\n\t\telse\n\t\t\tpp = &next->rb_right;\n\t}\n\t*parent_p = parent;\n\t*pp_p = pp;\n\treturn NULL;\n}\n\nstatic void inetpeer_free_rcu(struct rcu_head *head)\n{\n\tkmem_cache_free(peer_cachep, container_of(head, struct inet_peer, rcu));\n}\n\n \nstatic void inet_peer_gc(struct inet_peer_base *base,\n\t\t\t struct inet_peer *gc_stack[],\n\t\t\t unsigned int gc_cnt)\n{\n\tint peer_threshold, peer_maxttl, peer_minttl;\n\tstruct inet_peer *p;\n\t__u32 delta, ttl;\n\tint i;\n\n\tpeer_threshold = READ_ONCE(inet_peer_threshold);\n\tpeer_maxttl = READ_ONCE(inet_peer_maxttl);\n\tpeer_minttl = READ_ONCE(inet_peer_minttl);\n\n\tif (base->total >= peer_threshold)\n\t\tttl = 0;  \n\telse\n\t\tttl = peer_maxttl - (peer_maxttl - peer_minttl) / HZ *\n\t\t\tbase->total / peer_threshold * HZ;\n\tfor (i = 0; i < gc_cnt; i++) {\n\t\tp = gc_stack[i];\n\n\t\t \n\t\tdelta = (__u32)jiffies - READ_ONCE(p->dtime);\n\n\t\tif (delta < ttl || !refcount_dec_if_one(&p->refcnt))\n\t\t\tgc_stack[i] = NULL;\n\t}\n\tfor (i = 0; i < gc_cnt; i++) {\n\t\tp = gc_stack[i];\n\t\tif (p) {\n\t\t\trb_erase(&p->rb_node, &base->rb_root);\n\t\t\tbase->total--;\n\t\t\tcall_rcu(&p->rcu, inetpeer_free_rcu);\n\t\t}\n\t}\n}\n\nstruct inet_peer *inet_getpeer(struct inet_peer_base *base,\n\t\t\t       const struct inetpeer_addr *daddr,\n\t\t\t       int create)\n{\n\tstruct inet_peer *p, *gc_stack[PEER_MAX_GC];\n\tstruct rb_node **pp, *parent;\n\tunsigned int gc_cnt, seq;\n\tint invalidated;\n\n\t \n\trcu_read_lock();\n\tseq = read_seqbegin(&base->lock);\n\tp = lookup(daddr, base, seq, NULL, &gc_cnt, &parent, &pp);\n\tinvalidated = read_seqretry(&base->lock, seq);\n\trcu_read_unlock();\n\n\tif (p)\n\t\treturn p;\n\n\t \n\tif (!create && !invalidated)\n\t\treturn NULL;\n\n\t \n\tparent = NULL;\n\twrite_seqlock_bh(&base->lock);\n\n\tgc_cnt = 0;\n\tp = lookup(daddr, base, seq, gc_stack, &gc_cnt, &parent, &pp);\n\tif (!p && create) {\n\t\tp = kmem_cache_alloc(peer_cachep, GFP_ATOMIC);\n\t\tif (p) {\n\t\t\tp->daddr = *daddr;\n\t\t\tp->dtime = (__u32)jiffies;\n\t\t\trefcount_set(&p->refcnt, 2);\n\t\t\tatomic_set(&p->rid, 0);\n\t\t\tp->metrics[RTAX_LOCK-1] = INETPEER_METRICS_NEW;\n\t\t\tp->rate_tokens = 0;\n\t\t\tp->n_redirects = 0;\n\t\t\t \n\t\t\tp->rate_last = jiffies - 60*HZ;\n\n\t\t\trb_link_node(&p->rb_node, parent, pp);\n\t\t\trb_insert_color(&p->rb_node, &base->rb_root);\n\t\t\tbase->total++;\n\t\t}\n\t}\n\tif (gc_cnt)\n\t\tinet_peer_gc(base, gc_stack, gc_cnt);\n\twrite_sequnlock_bh(&base->lock);\n\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(inet_getpeer);\n\nvoid inet_putpeer(struct inet_peer *p)\n{\n\t \n\tWRITE_ONCE(p->dtime, (__u32)jiffies);\n\n\tif (refcount_dec_and_test(&p->refcnt))\n\t\tcall_rcu(&p->rcu, inetpeer_free_rcu);\n}\nEXPORT_SYMBOL_GPL(inet_putpeer);\n\n \n#define XRLIM_BURST_FACTOR 6\nbool inet_peer_xrlim_allow(struct inet_peer *peer, int timeout)\n{\n\tunsigned long now, token;\n\tbool rc = false;\n\n\tif (!peer)\n\t\treturn true;\n\n\ttoken = peer->rate_tokens;\n\tnow = jiffies;\n\ttoken += now - peer->rate_last;\n\tpeer->rate_last = now;\n\tif (token > XRLIM_BURST_FACTOR * timeout)\n\t\ttoken = XRLIM_BURST_FACTOR * timeout;\n\tif (token >= timeout) {\n\t\ttoken -= timeout;\n\t\trc = true;\n\t}\n\tpeer->rate_tokens = token;\n\treturn rc;\n}\nEXPORT_SYMBOL(inet_peer_xrlim_allow);\n\nvoid inetpeer_invalidate_tree(struct inet_peer_base *base)\n{\n\tstruct rb_node *p = rb_first(&base->rb_root);\n\n\twhile (p) {\n\t\tstruct inet_peer *peer = rb_entry(p, struct inet_peer, rb_node);\n\n\t\tp = rb_next(p);\n\t\trb_erase(&peer->rb_node, &base->rb_root);\n\t\tinet_putpeer(peer);\n\t\tcond_resched();\n\t}\n\n\tbase->total = 0;\n}\nEXPORT_SYMBOL(inetpeer_invalidate_tree);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}