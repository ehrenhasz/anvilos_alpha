{
  "module_name": "raw.c",
  "hash_id": "066dec7d19221260337d82193fccd09b047a00969297161e5eed09851243cc33",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/raw.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/current.h>\n#include <linux/uaccess.h>\n#include <asm/ioctls.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/sockios.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/mroute.h>\n#include <linux/netdevice.h>\n#include <linux/in_route.h>\n#include <linux/route.h>\n#include <linux/skbuff.h>\n#include <linux/igmp.h>\n#include <net/net_namespace.h>\n#include <net/dst.h>\n#include <net/sock.h>\n#include <linux/ip.h>\n#include <linux/net.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/raw.h>\n#include <net/snmp.h>\n#include <net/tcp_states.h>\n#include <net/inet_common.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/rtnetlink.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/compat.h>\n#include <linux/uio.h>\n\nstruct raw_frag_vec {\n\tstruct msghdr *msg;\n\tunion {\n\t\tstruct icmphdr icmph;\n\t\tchar c[1];\n\t} hdr;\n\tint hlen;\n};\n\nstruct raw_hashinfo raw_v4_hashinfo;\nEXPORT_SYMBOL_GPL(raw_v4_hashinfo);\n\nint raw_hash_sk(struct sock *sk)\n{\n\tstruct raw_hashinfo *h = sk->sk_prot->h.raw_hash;\n\tstruct hlist_head *hlist;\n\n\thlist = &h->ht[raw_hashfunc(sock_net(sk), inet_sk(sk)->inet_num)];\n\n\tspin_lock(&h->lock);\n\tsk_add_node_rcu(sk, hlist);\n\tsock_set_flag(sk, SOCK_RCU_FREE);\n\tspin_unlock(&h->lock);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(raw_hash_sk);\n\nvoid raw_unhash_sk(struct sock *sk)\n{\n\tstruct raw_hashinfo *h = sk->sk_prot->h.raw_hash;\n\n\tspin_lock(&h->lock);\n\tif (sk_del_node_init_rcu(sk))\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tspin_unlock(&h->lock);\n}\nEXPORT_SYMBOL_GPL(raw_unhash_sk);\n\nbool raw_v4_match(struct net *net, const struct sock *sk, unsigned short num,\n\t\t  __be32 raddr, __be32 laddr, int dif, int sdif)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\n\tif (net_eq(sock_net(sk), net) && inet->inet_num == num\t&&\n\t    !(inet->inet_daddr && inet->inet_daddr != raddr) \t&&\n\t    !(inet->inet_rcv_saddr && inet->inet_rcv_saddr != laddr) &&\n\t    raw_sk_bound_dev_eq(net, sk->sk_bound_dev_if, dif, sdif))\n\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(raw_v4_match);\n\n \nstatic int icmp_filter(const struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct icmphdr _hdr;\n\tconst struct icmphdr *hdr;\n\n\thdr = skb_header_pointer(skb, skb_transport_offset(skb),\n\t\t\t\t sizeof(_hdr), &_hdr);\n\tif (!hdr)\n\t\treturn 1;\n\n\tif (hdr->type < 32) {\n\t\t__u32 data = raw_sk(sk)->filter.data;\n\n\t\treturn ((1U << hdr->type) & data) != 0;\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic int raw_v4_input(struct net *net, struct sk_buff *skb,\n\t\t\tconst struct iphdr *iph, int hash)\n{\n\tint sdif = inet_sdif(skb);\n\tstruct hlist_head *hlist;\n\tint dif = inet_iif(skb);\n\tint delivered = 0;\n\tstruct sock *sk;\n\n\thlist = &raw_v4_hashinfo.ht[hash];\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, hlist) {\n\t\tif (!raw_v4_match(net, sk, iph->protocol,\n\t\t\t\t  iph->saddr, iph->daddr, dif, sdif))\n\t\t\tcontinue;\n\t\tdelivered = 1;\n\t\tif ((iph->protocol != IPPROTO_ICMP || !icmp_filter(sk, skb)) &&\n\t\t    ip_mc_sf_allow(sk, iph->daddr, iph->saddr,\n\t\t\t\t   skb->dev->ifindex, sdif)) {\n\t\t\tstruct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t \n\t\t\tif (clone)\n\t\t\t\traw_rcv(sk, clone);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn delivered;\n}\n\nint raw_local_deliver(struct sk_buff *skb, int protocol)\n{\n\tstruct net *net = dev_net(skb->dev);\n\n\treturn raw_v4_input(net, skb, ip_hdr(skb),\n\t\t\t    raw_hashfunc(net, protocol));\n}\n\nstatic void raw_err(struct sock *sk, struct sk_buff *skb, u32 info)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tint harderr = 0;\n\tbool recverr;\n\tint err = 0;\n\n\tif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED)\n\t\tipv4_sk_update_pmtu(skb, sk, info);\n\telse if (type == ICMP_REDIRECT) {\n\t\tipv4_sk_redirect(skb, sk);\n\t\treturn;\n\t}\n\n\t \n\trecverr = inet_test_bit(RECVERR, sk);\n\tif (!recverr && sk->sk_state != TCP_ESTABLISHED)\n\t\treturn;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_TIME_EXCEEDED:\n\t\terr = EHOSTUNREACH;\n\t\tbreak;\n\tcase ICMP_SOURCE_QUENCH:\n\t\treturn;\n\tcase ICMP_PARAMETERPROB:\n\t\terr = EPROTO;\n\t\tharderr = 1;\n\t\tbreak;\n\tcase ICMP_DEST_UNREACH:\n\t\terr = EHOSTUNREACH;\n\t\tif (code > NR_ICMP_UNREACH)\n\t\t\tbreak;\n\t\tif (code == ICMP_FRAG_NEEDED) {\n\t\t\tharderr = inet->pmtudisc != IP_PMTUDISC_DONT;\n\t\t\terr = EMSGSIZE;\n\t\t} else {\n\t\t\terr = icmp_err_convert[code].errno;\n\t\t\tharderr = icmp_err_convert[code].fatal;\n\t\t}\n\t}\n\n\tif (recverr) {\n\t\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\t\tu8 *payload = skb->data + (iph->ihl << 2);\n\n\t\tif (inet_test_bit(HDRINCL, sk))\n\t\t\tpayload = skb->data;\n\t\tip_icmp_error(sk, skb, err, 0, info, payload);\n\t}\n\n\tif (recverr || harderr) {\n\t\tsk->sk_err = err;\n\t\tsk_error_report(sk);\n\t}\n}\n\nvoid raw_icmp_error(struct sk_buff *skb, int protocol, u32 info)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tint dif = skb->dev->ifindex;\n\tint sdif = inet_sdif(skb);\n\tstruct hlist_head *hlist;\n\tconst struct iphdr *iph;\n\tstruct sock *sk;\n\tint hash;\n\n\thash = raw_hashfunc(net, protocol);\n\thlist = &raw_v4_hashinfo.ht[hash];\n\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, hlist) {\n\t\tiph = (const struct iphdr *)skb->data;\n\t\tif (!raw_v4_match(net, sk, iph->protocol,\n\t\t\t\t  iph->daddr, iph->saddr, dif, sdif))\n\t\t\tcontinue;\n\t\traw_err(sk, skb, info);\n\t}\n\trcu_read_unlock();\n}\n\nstatic int raw_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tenum skb_drop_reason reason;\n\n\t \n\n\tipv4_pktinfo_prepare(sk, skb);\n\tif (sock_queue_rcv_skb_reason(sk, skb, &reason) < 0) {\n\t\tkfree_skb_reason(skb, reason);\n\t\treturn NET_RX_DROP;\n\t}\n\n\treturn NET_RX_SUCCESS;\n}\n\nint raw_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tkfree_skb_reason(skb, SKB_DROP_REASON_XFRM_POLICY);\n\t\treturn NET_RX_DROP;\n\t}\n\tnf_reset_ct(skb);\n\n\tskb_push(skb, skb->data - skb_network_header(skb));\n\n\traw_rcv_skb(sk, skb);\n\treturn 0;\n}\n\nstatic int raw_send_hdrinc(struct sock *sk, struct flowi4 *fl4,\n\t\t\t   struct msghdr *msg, size_t length,\n\t\t\t   struct rtable **rtp, unsigned int flags,\n\t\t\t   const struct sockcm_cookie *sockc)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct iphdr *iph;\n\tstruct sk_buff *skb;\n\tunsigned int iphlen;\n\tint err;\n\tstruct rtable *rt = *rtp;\n\tint hlen, tlen;\n\n\tif (length > rt->dst.dev->mtu) {\n\t\tip_local_error(sk, EMSGSIZE, fl4->daddr, inet->inet_dport,\n\t\t\t       rt->dst.dev->mtu);\n\t\treturn -EMSGSIZE;\n\t}\n\tif (length < sizeof(struct iphdr))\n\t\treturn -EINVAL;\n\n\tif (flags&MSG_PROBE)\n\t\tgoto out;\n\n\thlen = LL_RESERVED_SPACE(rt->dst.dev);\n\ttlen = rt->dst.dev->needed_tailroom;\n\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t  length + hlen + tlen + 15,\n\t\t\t\t  flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto error;\n\tskb_reserve(skb, hlen);\n\n\tskb->priority = READ_ONCE(sk->sk_priority);\n\tskb->mark = sockc->mark;\n\tskb->tstamp = sockc->transmit_time;\n\tskb_dst_set(skb, &rt->dst);\n\t*rtp = NULL;\n\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tskb_put(skb, length);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb_setup_tx_timestamp(skb, sockc->tsflags);\n\n\tif (flags & MSG_CONFIRM)\n\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\tskb->transport_header = skb->network_header;\n\terr = -EFAULT;\n\tif (memcpy_from_msg(iph, msg, length))\n\t\tgoto error_free;\n\n\tiphlen = iph->ihl * 4;\n\n\t \n\terr = -EINVAL;\n\tif (iphlen > length)\n\t\tgoto error_free;\n\n\tif (iphlen >= sizeof(*iph)) {\n\t\tif (!iph->saddr)\n\t\t\tiph->saddr = fl4->saddr;\n\t\tiph->check   = 0;\n\t\tiph->tot_len = htons(length);\n\t\tif (!iph->id)\n\t\t\tip_select_ident(net, skb, NULL);\n\n\t\tiph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);\n\t\tskb->transport_header += iphlen;\n\t\tif (iph->protocol == IPPROTO_ICMP &&\n\t\t    length >= iphlen + sizeof(struct icmphdr))\n\t\t\ticmp_out_count(net, ((struct icmphdr *)\n\t\t\t\tskb_transport_header(skb))->type);\n\t}\n\n\terr = NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_OUT,\n\t\t      net, sk, skb, NULL, rt->dst.dev,\n\t\t      dst_output);\n\tif (err > 0)\n\t\terr = net_xmit_errno(err);\n\tif (err)\n\t\tgoto error;\nout:\n\treturn 0;\n\nerror_free:\n\tkfree_skb(skb);\nerror:\n\tIP_INC_STATS(net, IPSTATS_MIB_OUTDISCARDS);\n\tif (err == -ENOBUFS && !inet_test_bit(RECVERR, sk))\n\t\terr = 0;\n\treturn err;\n}\n\nstatic int raw_probe_proto_opt(struct raw_frag_vec *rfv, struct flowi4 *fl4)\n{\n\tint err;\n\n\tif (fl4->flowi4_proto != IPPROTO_ICMP)\n\t\treturn 0;\n\n\t \n\trfv->hlen = 2;\n\n\terr = memcpy_from_msg(rfv->hdr.c, rfv->msg, rfv->hlen);\n\tif (err)\n\t\treturn err;\n\n\tfl4->fl4_icmp_type = rfv->hdr.icmph.type;\n\tfl4->fl4_icmp_code = rfv->hdr.icmph.code;\n\n\treturn 0;\n}\n\nstatic int raw_getfrag(void *from, char *to, int offset, int len, int odd,\n\t\t       struct sk_buff *skb)\n{\n\tstruct raw_frag_vec *rfv = from;\n\n\tif (offset < rfv->hlen) {\n\t\tint copy = min(rfv->hlen - offset, len);\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\tmemcpy(to, rfv->hdr.c + offset, copy);\n\t\telse\n\t\t\tskb->csum = csum_block_add(\n\t\t\t\tskb->csum,\n\t\t\t\tcsum_partial_copy_nocheck(rfv->hdr.c + offset,\n\t\t\t\t\t\t\t  to, copy),\n\t\t\t\todd);\n\n\t\todd = 0;\n\t\toffset += copy;\n\t\tto += copy;\n\t\tlen -= copy;\n\n\t\tif (!len)\n\t\t\treturn 0;\n\t}\n\n\toffset -= rfv->hlen;\n\n\treturn ip_generic_getfrag(rfv->msg, to, offset, len, odd, skb);\n}\n\nstatic int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\tu8 tos, scope;\n\tint free = 0;\n\t__be32 daddr;\n\t__be32 saddr;\n\tint err;\n\tstruct ip_options_data opt_copy;\n\tstruct raw_frag_vec rfv;\n\tint hdrincl;\n\n\terr = -EMSGSIZE;\n\tif (len > 0xFFFF)\n\t\tgoto out;\n\n\thdrincl = inet_test_bit(HDRINCL, sk);\n\n\t \n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\t \n\t\tgoto out;                \n\n\t \n\n\tif (msg->msg_namelen) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\tgoto out;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tpr_info_once(\"%s: %s forgot to set AF_INET. Fix it!\\n\",\n\t\t\t\t     __func__, current->comm);\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tif (usin->sin_family)\n\t\t\t\tgoto out;\n\t\t}\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\t \n\t} else {\n\t\terr = -EDESTADDRREQ;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tdaddr = inet->inet_daddr;\n\t}\n\n\tipcm_init_sk(&ipc, inet);\n\t \n\tif (hdrincl)\n\t\tipc.protocol = IPPROTO_RAW;\n\n\tif (msg->msg_controllen) {\n\t\terr = ip_cmsg_send(sk, msg, &ipc, false);\n\t\tif (unlikely(err)) {\n\t\t\tkfree(ipc.opt);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = daddr;\n\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (ipc.opt) {\n\t\terr = -EINVAL;\n\t\t \n\t\tif (hdrincl)\n\t\t\tgoto done;\n\t\tif (ipc.opt->opt.srr) {\n\t\t\tif (!daddr)\n\t\t\t\tgoto done;\n\t\t\tdaddr = ipc.opt->opt.faddr;\n\t\t}\n\t}\n\ttos = get_rttos(&ipc, inet);\n\tscope = ip_sendmsg_scope(inet, &ipc, msg);\n\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif || netif_index_is_l3_master(sock_net(sk), ipc.oif))\n\t\t\tipc.oif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t} else if (!ipc.oif) {\n\t\tipc.oif = inet->uc_index;\n\t} else if (ipv4_is_lbcast(daddr) && inet->uc_index) {\n\t\t \n\t\tif (ipc.oif != inet->uc_index &&\n\t\t    ipc.oif == l3mdev_master_ifindex_by_index(sock_net(sk),\n\t\t\t\t\t\t\t      inet->uc_index)) {\n\t\t\tipc.oif = inet->uc_index;\n\t\t}\n\t}\n\n\tflowi4_init_output(&fl4, ipc.oif, ipc.sockc.mark, tos, scope,\n\t\t\t   hdrincl ? ipc.protocol : sk->sk_protocol,\n\t\t\t   inet_sk_flowi_flags(sk) |\n\t\t\t    (hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),\n\t\t\t   daddr, saddr, 0, 0, sk->sk_uid);\n\n\tif (!hdrincl) {\n\t\trfv.msg = msg;\n\t\trfv.hlen = 0;\n\n\t\terr = raw_probe_proto_opt(&rfv, &fl4);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tsecurity_sk_classify_flow(sk, flowi4_to_flowi_common(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\trt = NULL;\n\t\tgoto done;\n\t}\n\n\terr = -EACCES;\n\tif (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST))\n\t\tgoto done;\n\n\tif (msg->msg_flags & MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tif (hdrincl)\n\t\terr = raw_send_hdrinc(sk, &fl4, msg, len,\n\t\t\t\t      &rt, msg->msg_flags, &ipc.sockc);\n\n\t else {\n\t\tif (!ipc.addr)\n\t\t\tipc.addr = fl4.daddr;\n\t\tlock_sock(sk);\n\t\terr = ip_append_data(sk, &fl4, raw_getfrag,\n\t\t\t\t     &rfv, len, 0,\n\t\t\t\t     &ipc, &rt, msg->msg_flags);\n\t\tif (err)\n\t\t\tip_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE)) {\n\t\t\terr = ip_push_pending_frames(sk, &fl4);\n\t\t\tif (err == -ENOBUFS && !inet_test_bit(RECVERR, sk))\n\t\t\t\terr = 0;\n\t\t}\n\t\trelease_sock(sk);\n\t}\ndone:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tip_rt_put(rt);\n\nout:\n\tif (err < 0)\n\t\treturn err;\n\treturn len;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(&rt->dst, &fl4.daddr);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n\nstatic void raw_close(struct sock *sk, long timeout)\n{\n\t \n\tip_ra_control(sk, 0, NULL);\n\n\tsk_common_release(sk);\n}\n\nstatic void raw_destroy(struct sock *sk)\n{\n\tlock_sock(sk);\n\tip_flush_pending_frames(sk);\n\trelease_sock(sk);\n}\n\n \nstatic int raw_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_in *addr = (struct sockaddr_in *) uaddr;\n\tstruct net *net = sock_net(sk);\n\tu32 tb_id = RT_TABLE_LOCAL;\n\tint ret = -EINVAL;\n\tint chk_addr_ret;\n\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_in))\n\t\tgoto out;\n\n\tif (sk->sk_bound_dev_if)\n\t\ttb_id = l3mdev_fib_table_by_index(net,\n\t\t\t\t\t\t  sk->sk_bound_dev_if) ? : tb_id;\n\n\tchk_addr_ret = inet_addr_type_table(net, addr->sin_addr.s_addr, tb_id);\n\n\tret = -EADDRNOTAVAIL;\n\tif (!inet_addr_valid_or_nonlocal(net, inet, addr->sin_addr.s_addr,\n\t\t\t\t\t chk_addr_ret))\n\t\tgoto out;\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = addr->sin_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;   \n\tsk_dst_reset(sk);\n\tret = 0;\nout:\n\trelease_sock(sk);\n\treturn ret;\n}\n\n \n\nstatic int raw_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t       int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = ip_recv_error(sk, msg, len, addr_len);\n\t\tgoto out;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_cmsgs(msg, sk, skb);\n\n\t \n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet_cmsg_flags(inet))\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}\n\nstatic int raw_sk_init(struct sock *sk)\n{\n\tstruct raw_sock *rp = raw_sk(sk);\n\n\tif (inet_sk(sk)->inet_num == IPPROTO_ICMP)\n\t\tmemset(&rp->filter, 0, sizeof(rp->filter));\n\treturn 0;\n}\n\nstatic int raw_seticmpfilter(struct sock *sk, sockptr_t optval, int optlen)\n{\n\tif (optlen > sizeof(struct icmp_filter))\n\t\toptlen = sizeof(struct icmp_filter);\n\tif (copy_from_sockptr(&raw_sk(sk)->filter, optval, optlen))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int raw_geticmpfilter(struct sock *sk, char __user *optval, int __user *optlen)\n{\n\tint len, ret = -EFAULT;\n\n\tif (get_user(len, optlen))\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (len < 0)\n\t\tgoto out;\n\tif (len > sizeof(struct icmp_filter))\n\t\tlen = sizeof(struct icmp_filter);\n\tret = -EFAULT;\n\tif (put_user(len, optlen) ||\n\t    copy_to_user(optval, &raw_sk(sk)->filter, len))\n\t\tgoto out;\n\tret = 0;\nout:\treturn ret;\n}\n\nstatic int do_raw_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t     sockptr_t optval, unsigned int optlen)\n{\n\tif (optname == ICMP_FILTER) {\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMP)\n\t\t\treturn -EOPNOTSUPP;\n\t\telse\n\t\t\treturn raw_seticmpfilter(sk, optval, optlen);\n\t}\n\treturn -ENOPROTOOPT;\n}\n\nstatic int raw_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\tif (level != SOL_RAW)\n\t\treturn ip_setsockopt(sk, level, optname, optval, optlen);\n\treturn do_raw_setsockopt(sk, level, optname, optval, optlen);\n}\n\nstatic int do_raw_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tif (optname == ICMP_FILTER) {\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMP)\n\t\t\treturn -EOPNOTSUPP;\n\t\telse\n\t\t\treturn raw_geticmpfilter(sk, optval, optlen);\n\t}\n\treturn -ENOPROTOOPT;\n}\n\nstatic int raw_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tif (level != SOL_RAW)\n\t\treturn ip_getsockopt(sk, level, optname, optval, optlen);\n\treturn do_raw_getsockopt(sk, level, optname, optval, optlen);\n}\n\nstatic int raw_ioctl(struct sock *sk, int cmd, int *karg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ: {\n\t\t*karg = sk_wmem_alloc_get(sk);\n\t\treturn 0;\n\t}\n\tcase SIOCINQ: {\n\t\tstruct sk_buff *skb;\n\n\t\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\t*karg = skb->len;\n\t\telse\n\t\t\t*karg = 0;\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\treturn 0;\n\t}\n\n\tdefault:\n#ifdef CONFIG_IP_MROUTE\n\t\treturn ipmr_ioctl(sk, cmd, karg);\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_raw_ioctl(struct sock *sk, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\tcase SIOCINQ:\n\t\treturn -ENOIOCTLCMD;\n\tdefault:\n#ifdef CONFIG_IP_MROUTE\n\t\treturn ipmr_compat_ioctl(sk, cmd, compat_ptr(arg));\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n#endif\n\nint raw_abort(struct sock *sk, int err)\n{\n\tlock_sock(sk);\n\n\tsk->sk_err = err;\n\tsk_error_report(sk);\n\t__udp_disconnect(sk, 0);\n\n\trelease_sock(sk);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(raw_abort);\n\nstruct proto raw_prot = {\n\t.name\t\t   = \"RAW\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = raw_close,\n\t.destroy\t   = raw_destroy,\n\t.connect\t   = ip4_datagram_connect,\n\t.disconnect\t   = __udp_disconnect,\n\t.ioctl\t\t   = raw_ioctl,\n\t.init\t\t   = raw_sk_init,\n\t.setsockopt\t   = raw_setsockopt,\n\t.getsockopt\t   = raw_getsockopt,\n\t.sendmsg\t   = raw_sendmsg,\n\t.recvmsg\t   = raw_recvmsg,\n\t.bind\t\t   = raw_bind,\n\t.backlog_rcv\t   = raw_rcv_skb,\n\t.release_cb\t   = ip4_datagram_release_cb,\n\t.hash\t\t   = raw_hash_sk,\n\t.unhash\t\t   = raw_unhash_sk,\n\t.obj_size\t   = sizeof(struct raw_sock),\n\t.useroffset\t   = offsetof(struct raw_sock, filter),\n\t.usersize\t   = sizeof_field(struct raw_sock, filter),\n\t.h.raw_hash\t   = &raw_v4_hashinfo,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t   = compat_raw_ioctl,\n#endif\n\t.diag_destroy\t   = raw_abort,\n};\n\n#ifdef CONFIG_PROC_FS\nstatic struct sock *raw_get_first(struct seq_file *seq, int bucket)\n{\n\tstruct raw_hashinfo *h = pde_data(file_inode(seq->file));\n\tstruct raw_iter_state *state = raw_seq_private(seq);\n\tstruct hlist_head *hlist;\n\tstruct sock *sk;\n\n\tfor (state->bucket = bucket; state->bucket < RAW_HTABLE_SIZE;\n\t\t\t++state->bucket) {\n\t\thlist = &h->ht[state->bucket];\n\t\tsk_for_each(sk, hlist) {\n\t\t\tif (sock_net(sk) == seq_file_net(seq))\n\t\t\t\treturn sk;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct sock *raw_get_next(struct seq_file *seq, struct sock *sk)\n{\n\tstruct raw_iter_state *state = raw_seq_private(seq);\n\n\tdo {\n\t\tsk = sk_next(sk);\n\t} while (sk && sock_net(sk) != seq_file_net(seq));\n\n\tif (!sk)\n\t\treturn raw_get_first(seq, state->bucket + 1);\n\treturn sk;\n}\n\nstatic struct sock *raw_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct sock *sk = raw_get_first(seq, 0);\n\n\tif (sk)\n\t\twhile (pos && (sk = raw_get_next(seq, sk)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : sk;\n}\n\nvoid *raw_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(&h->lock)\n{\n\tstruct raw_hashinfo *h = pde_data(file_inode(seq->file));\n\n\tspin_lock(&h->lock);\n\n\treturn *pos ? raw_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\nEXPORT_SYMBOL_GPL(raw_seq_start);\n\nvoid *raw_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct sock *sk;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tsk = raw_get_first(seq, 0);\n\telse\n\t\tsk = raw_get_next(seq, v);\n\t++*pos;\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(raw_seq_next);\n\nvoid raw_seq_stop(struct seq_file *seq, void *v)\n\t__releases(&h->lock)\n{\n\tstruct raw_hashinfo *h = pde_data(file_inode(seq->file));\n\n\tspin_unlock(&h->lock);\n}\nEXPORT_SYMBOL_GPL(raw_seq_stop);\n\nstatic void raw_sock_seq_show(struct seq_file *seq, struct sock *sp, int i)\n{\n\tstruct inet_sock *inet = inet_sk(sp);\n\t__be32 dest = inet->inet_daddr,\n\t       src = inet->inet_rcv_saddr;\n\t__u16 destp = 0,\n\t      srcp  = inet->inet_num;\n\n\tseq_printf(seq, \"%4d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %u\\n\",\n\t\ti, src, srcp, dest, destp, sp->sk_state,\n\t\tsk_wmem_alloc_get(sp),\n\t\tsk_rmem_alloc_get(sp),\n\t\t0, 0L, 0,\n\t\tfrom_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t0, sock_i_ino(sp),\n\t\trefcount_read(&sp->sk_refcnt), sp, atomic_read(&sp->sk_drops));\n}\n\nstatic int raw_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq, \"  sl  local_address rem_address   st tx_queue \"\n\t\t\t\t\"rx_queue tr tm->when retrnsmt   uid  timeout \"\n\t\t\t\t\"inode ref pointer drops\\n\");\n\telse\n\t\traw_sock_seq_show(seq, v, raw_seq_private(seq)->bucket);\n\treturn 0;\n}\n\nstatic const struct seq_operations raw_seq_ops = {\n\t.start = raw_seq_start,\n\t.next  = raw_seq_next,\n\t.stop  = raw_seq_stop,\n\t.show  = raw_seq_show,\n};\n\nstatic __net_init int raw_init_net(struct net *net)\n{\n\tif (!proc_create_net_data(\"raw\", 0444, net->proc_net, &raw_seq_ops,\n\t\t\tsizeof(struct raw_iter_state), &raw_v4_hashinfo))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic __net_exit void raw_exit_net(struct net *net)\n{\n\tremove_proc_entry(\"raw\", net->proc_net);\n}\n\nstatic __net_initdata struct pernet_operations raw_net_ops = {\n\t.init = raw_init_net,\n\t.exit = raw_exit_net,\n};\n\nint __init raw_proc_init(void)\n{\n\n\treturn register_pernet_subsys(&raw_net_ops);\n}\n\nvoid __init raw_proc_exit(void)\n{\n\tunregister_pernet_subsys(&raw_net_ops);\n}\n#endif  \n\nstatic void raw_sysctl_init_net(struct net *net)\n{\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\tnet->ipv4.sysctl_raw_l3mdev_accept = 1;\n#endif\n}\n\nstatic int __net_init raw_sysctl_init(struct net *net)\n{\n\traw_sysctl_init_net(net);\n\treturn 0;\n}\n\nstatic struct pernet_operations __net_initdata raw_sysctl_ops = {\n\t.init\t= raw_sysctl_init,\n};\n\nvoid __init raw_init(void)\n{\n\traw_sysctl_init_net(&init_net);\n\tif (register_pernet_subsys(&raw_sysctl_ops))\n\t\tpanic(\"RAW: failed to init sysctl parameters.\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}