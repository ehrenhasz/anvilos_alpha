{
  "module_name": "af_inet.c",
  "hash_id": "5444ef1b74ef34a99b4b198c3ee886b66c60b7d68a81f247f033628c3a9cb59e",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/af_inet.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"IPv4: \" fmt\n\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/capability.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/stat.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n\n#include <linux/uaccess.h>\n\n#include <linux/inet.h>\n#include <linux/igmp.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <net/checksum.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/arp.h>\n#include <net/route.h>\n#include <net/ip_fib.h>\n#include <net/inet_connection_sock.h>\n#include <net/gro.h>\n#include <net/gso.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/udplite.h>\n#include <net/ping.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/raw.h>\n#include <net/icmp.h>\n#include <net/inet_common.h>\n#include <net/ip_tunnels.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/secure_seq.h>\n#ifdef CONFIG_IP_MROUTE\n#include <linux/mroute.h>\n#endif\n#include <net/l3mdev.h>\n#include <net/compat.h>\n\n#include <trace/events/sock.h>\n\n \nstatic struct list_head inetsw[SOCK_MAX];\nstatic DEFINE_SPINLOCK(inetsw_lock);\n\n \n\nvoid inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\n\tsk_mem_reclaim_final(sk);\n\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON_ONCE(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON_ONCE(refcount_read(&sk->sk_wmem_alloc));\n\tWARN_ON_ONCE(sk->sk_wmem_queued);\n\tWARN_ON_ONCE(sk_forward_alloc_get(sk));\n\n\tkfree(rcu_dereference_protected(inet->inet_opt, 1));\n\tdst_release(rcu_dereference_protected(sk->sk_dst_cache, 1));\n\tdst_release(rcu_dereference_protected(sk->sk_rx_dst, 1));\n}\nEXPORT_SYMBOL(inet_sock_destruct);\n\n \n\n \n\nstatic int inet_autobind(struct sock *sk)\n{\n\tstruct inet_sock *inet;\n\t \n\tlock_sock(sk);\n\tinet = inet_sk(sk);\n\tif (!inet->inet_num) {\n\t\tif (sk->sk_prot->get_port(sk, 0)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tinet->inet_sport = htons(inet->inet_num);\n\t}\n\trelease_sock(sk);\n\treturn 0;\n}\n\nint __inet_listen_sk(struct sock *sk, int backlog)\n{\n\tunsigned char old_state = sk->sk_state;\n\tint err, tcp_fastopen;\n\n\tif (!((1 << old_state) & (TCPF_CLOSE | TCPF_LISTEN)))\n\t\treturn -EINVAL;\n\n\tWRITE_ONCE(sk->sk_max_ack_backlog, backlog);\n\t \n\tif (old_state != TCP_LISTEN) {\n\t\t \n\t\ttcp_fastopen = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_fastopen);\n\t\tif ((tcp_fastopen & TFO_SERVER_WO_SOCKOPT1) &&\n\t\t    (tcp_fastopen & TFO_SERVER_ENABLE) &&\n\t\t    !inet_csk(sk)->icsk_accept_queue.fastopenq.max_qlen) {\n\t\t\tfastopen_queue_tune(sk, backlog);\n\t\t\ttcp_fastopen_init_key_once(sock_net(sk));\n\t\t}\n\n\t\terr = inet_csk_listen_start(sk);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttcp_call_bpf(sk, BPF_SOCK_OPS_TCP_LISTEN_CB, 0, NULL);\n\t}\n\treturn 0;\n}\n\n \nint inet_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sock->state != SS_UNCONNECTED || sock->type != SOCK_STREAM)\n\t\tgoto out;\n\n\terr = __inet_listen_sk(sk, backlog);\n\nout:\n\trelease_sock(sk);\n\treturn err;\n}\nEXPORT_SYMBOL(inet_listen);\n\n \n\nstatic int inet_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tstruct inet_protosw *answer;\n\tstruct inet_sock *inet;\n\tstruct proto *answer_prot;\n\tunsigned char answer_flags;\n\tint try_loading_module = 0;\n\tint err;\n\n\tif (protocol < 0 || protocol >= IPPROTO_MAX)\n\t\treturn -EINVAL;\n\n\tsock->state = SS_UNCONNECTED;\n\n\t \nlookup_protocol:\n\terr = -ESOCKTNOSUPPORT;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(answer, &inetsw[sock->type], list) {\n\n\t\terr = 0;\n\t\t \n\t\tif (protocol == answer->protocol) {\n\t\t\tif (protocol != IPPROTO_IP)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tif (IPPROTO_IP == protocol) {\n\t\t\t\tprotocol = answer->protocol;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IPPROTO_IP == answer->protocol)\n\t\t\t\tbreak;\n\t\t}\n\t\terr = -EPROTONOSUPPORT;\n\t}\n\n\tif (unlikely(err)) {\n\t\tif (try_loading_module < 2) {\n\t\t\trcu_read_unlock();\n\t\t\t \n\t\t\tif (++try_loading_module == 1)\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d-type-%d\",\n\t\t\t\t\t       PF_INET, protocol, sock->type);\n\t\t\t \n\t\t\telse\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d\",\n\t\t\t\t\t       PF_INET, protocol);\n\t\t\tgoto lookup_protocol;\n\t\t} else\n\t\t\tgoto out_rcu_unlock;\n\t}\n\n\terr = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern &&\n\t    !ns_capable(net->user_ns, CAP_NET_RAW))\n\t\tgoto out_rcu_unlock;\n\n\tsock->ops = answer->ops;\n\tanswer_prot = answer->prot;\n\tanswer_flags = answer->flags;\n\trcu_read_unlock();\n\n\tWARN_ON(!answer_prot->slab);\n\n\terr = -ENOMEM;\n\tsk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\terr = 0;\n\tif (INET_PROTOSW_REUSE & answer_flags)\n\t\tsk->sk_reuse = SK_CAN_REUSE;\n\n\tinet = inet_sk(sk);\n\tinet_assign_bit(IS_ICSK, sk, INET_PROTOSW_ICSK & answer_flags);\n\n\tinet_clear_bit(NODEFRAG, sk);\n\n\tif (SOCK_RAW == sock->type) {\n\t\tinet->inet_num = protocol;\n\t\tif (IPPROTO_RAW == protocol)\n\t\t\tinet_set_bit(HDRINCL, sk);\n\t}\n\n\tif (READ_ONCE(net->ipv4.sysctl_ip_no_pmtu_disc))\n\t\tinet->pmtudisc = IP_PMTUDISC_DONT;\n\telse\n\t\tinet->pmtudisc = IP_PMTUDISC_WANT;\n\n\tatomic_set(&inet->inet_id, 0);\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct\t   = inet_sock_destruct;\n\tsk->sk_protocol\t   = protocol;\n\tsk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;\n\tsk->sk_txrehash = READ_ONCE(net->core.sysctl_txrehash);\n\n\tinet->uc_ttl\t= -1;\n\tinet_set_bit(MC_LOOP, sk);\n\tinet->mc_ttl\t= 1;\n\tinet_set_bit(MC_ALL, sk);\n\tinet->mc_index\t= 0;\n\tinet->mc_list\t= NULL;\n\tinet->rcv_tos\t= 0;\n\n\tif (inet->inet_num) {\n\t\t \n\t\tinet->inet_sport = htons(inet->inet_num);\n\t\t \n\t\terr = sk->sk_prot->hash(sk);\n\t\tif (err) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (sk->sk_prot->init) {\n\t\terr = sk->sk_prot->init(sk);\n\t\tif (err) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!kern) {\n\t\terr = BPF_CGROUP_RUN_PROG_INET_SOCK(sk);\n\t\tif (err) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn err;\nout_rcu_unlock:\n\trcu_read_unlock();\n\tgoto out;\n}\n\n\n \nint inet_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk) {\n\t\tlong timeout;\n\n\t\tif (!sk->sk_kern_sock)\n\t\t\tBPF_CGROUP_RUN_PROG_INET_SOCK_RELEASE(sk);\n\n\t\t \n\t\tip_mc_drop_socket(sk);\n\n\t\t \n\t\ttimeout = 0;\n\t\tif (sock_flag(sk, SOCK_LINGER) &&\n\t\t    !(current->flags & PF_EXITING))\n\t\t\ttimeout = sk->sk_lingertime;\n\t\tsk->sk_prot->close(sk, timeout);\n\t\tsock->sk = NULL;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(inet_release);\n\nint inet_bind_sk(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tu32 flags = BIND_WITH_LOCK;\n\tint err;\n\n\t \n\tif (sk->sk_prot->bind) {\n\t\treturn sk->sk_prot->bind(sk, uaddr, addr_len);\n\t}\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\t \n\terr = BPF_CGROUP_RUN_PROG_INET_BIND_LOCK(sk, uaddr,\n\t\t\t\t\t\t CGROUP_INET4_BIND, &flags);\n\tif (err)\n\t\treturn err;\n\n\treturn __inet_bind(sk, uaddr, addr_len, flags);\n}\n\nint inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\treturn inet_bind_sk(sock->sk, uaddr, addr_len);\n}\nEXPORT_SYMBOL(inet_bind);\n\nint __inet_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len,\n\t\tu32 flags)\n{\n\tstruct sockaddr_in *addr = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tunsigned short snum;\n\tint chk_addr_ret;\n\tu32 tb_id = RT_TABLE_LOCAL;\n\tint err;\n\n\tif (addr->sin_family != AF_INET) {\n\t\t \n\t\terr = -EAFNOSUPPORT;\n\t\tif (addr->sin_family != AF_UNSPEC ||\n\t\t    addr->sin_addr.s_addr != htonl(INADDR_ANY))\n\t\t\tgoto out;\n\t}\n\n\ttb_id = l3mdev_fib_table_by_index(net, sk->sk_bound_dev_if) ? : tb_id;\n\tchk_addr_ret = inet_addr_type_table(net, addr->sin_addr.s_addr, tb_id);\n\n\t \n\terr = -EADDRNOTAVAIL;\n\tif (!inet_addr_valid_or_nonlocal(net, inet, addr->sin_addr.s_addr,\n\t                                 chk_addr_ret))\n\t\tgoto out;\n\n\tsnum = ntohs(addr->sin_port);\n\terr = -EACCES;\n\tif (!(flags & BIND_NO_CAP_NET_BIND_SERVICE) &&\n\t    snum && inet_port_requires_bind_service(net, snum) &&\n\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\tgoto out;\n\n\t \n\tif (flags & BIND_WITH_LOCK)\n\t\tlock_sock(sk);\n\n\t \n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_CLOSE || inet->inet_num)\n\t\tgoto out_release_sock;\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = addr->sin_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;   \n\n\t \n\tif (snum || !(inet_test_bit(BIND_ADDRESS_NO_PORT, sk) ||\n\t\t      (flags & BIND_FORCE_ADDRESS_NO_PORT))) {\n\t\terr = sk->sk_prot->get_port(sk, snum);\n\t\tif (err) {\n\t\t\tinet->inet_saddr = inet->inet_rcv_saddr = 0;\n\t\t\tgoto out_release_sock;\n\t\t}\n\t\tif (!(flags & BIND_FROM_BPF)) {\n\t\t\terr = BPF_CGROUP_RUN_PROG_INET4_POST_BIND(sk);\n\t\t\tif (err) {\n\t\t\t\tinet->inet_saddr = inet->inet_rcv_saddr = 0;\n\t\t\t\tif (sk->sk_prot->put_port)\n\t\t\t\t\tsk->sk_prot->put_port(sk);\n\t\t\t\tgoto out_release_sock;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (inet->inet_rcv_saddr)\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tinet->inet_sport = htons(inet->inet_num);\n\tinet->inet_daddr = 0;\n\tinet->inet_dport = 0;\n\tsk_dst_reset(sk);\n\terr = 0;\nout_release_sock:\n\tif (flags & BIND_WITH_LOCK)\n\t\trelease_sock(sk);\nout:\n\treturn err;\n}\n\nint inet_dgram_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tconst struct proto *prot;\n\tint err;\n\n\tif (addr_len < sizeof(uaddr->sa_family))\n\t\treturn -EINVAL;\n\n\t \n\tprot = READ_ONCE(sk->sk_prot);\n\n\tif (uaddr->sa_family == AF_UNSPEC)\n\t\treturn prot->disconnect(sk, flags);\n\n\tif (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) {\n\t\terr = prot->pre_connect(sk, uaddr, addr_len);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data_race(!inet_sk(sk)->inet_num) && inet_autobind(sk))\n\t\treturn -EAGAIN;\n\treturn prot->connect(sk, uaddr, addr_len);\n}\nEXPORT_SYMBOL(inet_dgram_connect);\n\nstatic long inet_wait_for_connect(struct sock *sk, long timeo, int writebias)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tsk->sk_write_pending += writebias;\n\n\t \n\twhile ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {\n\t\trelease_sock(sk);\n\t\ttimeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\t\tlock_sock(sk);\n\t\tif (signal_pending(current) || !timeo)\n\t\t\tbreak;\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\tsk->sk_write_pending -= writebias;\n\treturn timeo;\n}\n\n \nint __inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int addr_len, int flags, int is_sendmsg)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tlong timeo;\n\n\t \n\tif (uaddr) {\n\t\tif (addr_len < sizeof(uaddr->sa_family))\n\t\t\treturn -EINVAL;\n\n\t\tif (uaddr->sa_family == AF_UNSPEC) {\n\t\t\tsk->sk_disconnects++;\n\t\t\terr = sk->sk_prot->disconnect(sk, flags);\n\t\t\tsock->state = err ? SS_DISCONNECTING : SS_UNCONNECTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (sock->state) {\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\tcase SS_CONNECTED:\n\t\terr = -EISCONN;\n\t\tgoto out;\n\tcase SS_CONNECTING:\n\t\tif (inet_test_bit(DEFER_CONNECT, sk))\n\t\t\terr = is_sendmsg ? -EINPROGRESS : -EISCONN;\n\t\telse\n\t\t\terr = -EALREADY;\n\t\t \n\t\tbreak;\n\tcase SS_UNCONNECTED:\n\t\terr = -EISCONN;\n\t\tif (sk->sk_state != TCP_CLOSE)\n\t\t\tgoto out;\n\n\t\tif (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) {\n\t\t\terr = sk->sk_prot->pre_connect(sk, uaddr, addr_len);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\terr = sk->sk_prot->connect(sk, uaddr, addr_len);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\tsock->state = SS_CONNECTING;\n\n\t\tif (!err && inet_test_bit(DEFER_CONNECT, sk))\n\t\t\tgoto out;\n\n\t\t \n\t\terr = -EINPROGRESS;\n\t\tbreak;\n\t}\n\n\ttimeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\n\n\tif ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {\n\t\tint writebias = (sk->sk_protocol == IPPROTO_TCP) &&\n\t\t\t\ttcp_sk(sk)->fastopen_req &&\n\t\t\t\ttcp_sk(sk)->fastopen_req->data ? 1 : 0;\n\t\tint dis = sk->sk_disconnects;\n\n\t\t \n\t\tif (!timeo || !inet_wait_for_connect(sk, timeo, writebias))\n\t\t\tgoto out;\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\n\t\tif (dis != sk->sk_disconnects) {\n\t\t\terr = -EPIPE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto sock_error;\n\n\t \n\n\tsock->state = SS_CONNECTED;\n\terr = 0;\nout:\n\treturn err;\n\nsock_error:\n\terr = sock_error(sk) ? : -ECONNABORTED;\n\tsock->state = SS_UNCONNECTED;\n\tsk->sk_disconnects++;\n\tif (sk->sk_prot->disconnect(sk, flags))\n\t\tsock->state = SS_DISCONNECTING;\n\tgoto out;\n}\nEXPORT_SYMBOL(__inet_stream_connect);\n\nint inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t\tint addr_len, int flags)\n{\n\tint err;\n\n\tlock_sock(sock->sk);\n\terr = __inet_stream_connect(sock, uaddr, addr_len, flags, 0);\n\trelease_sock(sock->sk);\n\treturn err;\n}\nEXPORT_SYMBOL(inet_stream_connect);\n\nvoid __inet_accept(struct socket *sock, struct socket *newsock, struct sock *newsk)\n{\n\tsock_rps_record_flow(newsk);\n\tWARN_ON(!((1 << newsk->sk_state) &\n\t\t  (TCPF_ESTABLISHED | TCPF_SYN_RECV |\n\t\t  TCPF_CLOSE_WAIT | TCPF_CLOSE)));\n\n\tif (test_bit(SOCK_SUPPORT_ZC, &sock->flags))\n\t\tset_bit(SOCK_SUPPORT_ZC, &newsock->flags);\n\tsock_graft(newsk, newsock);\n\n\tnewsock->state = SS_CONNECTED;\n}\n\n \n\nint inet_accept(struct socket *sock, struct socket *newsock, int flags,\n\t\tbool kern)\n{\n\tstruct sock *sk1 = sock->sk, *sk2;\n\tint err = -EINVAL;\n\n\t \n\tsk2 = READ_ONCE(sk1->sk_prot)->accept(sk1, flags, &err, kern);\n\tif (!sk2)\n\t\treturn err;\n\n\tlock_sock(sk2);\n\t__inet_accept(sock, newsock, sk2);\n\trelease_sock(sk2);\n\treturn 0;\n}\nEXPORT_SYMBOL(inet_accept);\n\n \nint inet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t int peer)\n{\n\tstruct sock *sk\t\t= sock->sk;\n\tstruct inet_sock *inet\t= inet_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in *, sin, uaddr);\n\n\tsin->sin_family = AF_INET;\n\tlock_sock(sk);\n\tif (peer) {\n\t\tif (!inet->inet_dport ||\n\t\t    (((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_SYN_SENT)) &&\n\t\t     peer == 1)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tsin->sin_port = inet->inet_dport;\n\t\tsin->sin_addr.s_addr = inet->inet_daddr;\n\t\tBPF_CGROUP_RUN_SA_PROG(sk, (struct sockaddr *)sin,\n\t\t\t\t       CGROUP_INET4_GETPEERNAME);\n\t} else {\n\t\t__be32 addr = inet->inet_rcv_saddr;\n\t\tif (!addr)\n\t\t\taddr = inet->inet_saddr;\n\t\tsin->sin_port = inet->inet_sport;\n\t\tsin->sin_addr.s_addr = addr;\n\t\tBPF_CGROUP_RUN_SA_PROG(sk, (struct sockaddr *)sin,\n\t\t\t\t       CGROUP_INET4_GETSOCKNAME);\n\t}\n\trelease_sock(sk);\n\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\treturn sizeof(*sin);\n}\nEXPORT_SYMBOL(inet_getname);\n\nint inet_send_prepare(struct sock *sk)\n{\n\tsock_rps_record_flow(sk);\n\n\t \n\tif (data_race(!inet_sk(sk)->inet_num) && !sk->sk_prot->no_autobind &&\n\t    inet_autobind(sk))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(inet_send_prepare);\n\nint inet_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (unlikely(inet_send_prepare(sk)))\n\t\treturn -EAGAIN;\n\n\treturn INDIRECT_CALL_2(sk->sk_prot->sendmsg, tcp_sendmsg, udp_sendmsg,\n\t\t\t       sk, msg, size);\n}\nEXPORT_SYMBOL(inet_sendmsg);\n\nvoid inet_splice_eof(struct socket *sock)\n{\n\tconst struct proto *prot;\n\tstruct sock *sk = sock->sk;\n\n\tif (unlikely(inet_send_prepare(sk)))\n\t\treturn;\n\n\t \n\tprot = READ_ONCE(sk->sk_prot);\n\tif (prot->splice_eof)\n\t\tprot->splice_eof(sock);\n}\nEXPORT_SYMBOL_GPL(inet_splice_eof);\n\nINDIRECT_CALLABLE_DECLARE(int udp_recvmsg(struct sock *, struct msghdr *,\n\t\t\t\t\t  size_t, int, int *));\nint inet_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint addr_len = 0;\n\tint err;\n\n\tif (likely(!(flags & MSG_ERRQUEUE)))\n\t\tsock_rps_record_flow(sk);\n\n\terr = INDIRECT_CALL_2(sk->sk_prot->recvmsg, tcp_recvmsg, udp_recvmsg,\n\t\t\t      sk, msg, size, flags, &addr_len);\n\tif (err >= 0)\n\t\tmsg->msg_namelen = addr_len;\n\treturn err;\n}\nEXPORT_SYMBOL(inet_recvmsg);\n\nint inet_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\t \n\thow++;  \n\tif ((how & ~SHUTDOWN_MASK) || !how)\t \n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sock->state == SS_CONNECTING) {\n\t\tif ((1 << sk->sk_state) &\n\t\t    (TCPF_SYN_SENT | TCPF_SYN_RECV | TCPF_CLOSE))\n\t\t\tsock->state = SS_DISCONNECTING;\n\t\telse\n\t\t\tsock->state = SS_CONNECTED;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase TCP_CLOSE:\n\t\terr = -ENOTCONN;\n\t\t \n\t\tfallthrough;\n\tdefault:\n\t\tWRITE_ONCE(sk->sk_shutdown, sk->sk_shutdown | how);\n\t\tif (sk->sk_prot->shutdown)\n\t\t\tsk->sk_prot->shutdown(sk, how);\n\t\tbreak;\n\n\t \n\tcase TCP_LISTEN:\n\t\tif (!(how & RCV_SHUTDOWN))\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase TCP_SYN_SENT:\n\t\terr = sk->sk_prot->disconnect(sk, O_NONBLOCK);\n\t\tsock->state = err ? SS_DISCONNECTING : SS_UNCONNECTED;\n\t\tbreak;\n\t}\n\n\t \n\tsk->sk_state_change(sk);\n\trelease_sock(sk);\n\treturn err;\n}\nEXPORT_SYMBOL(inet_shutdown);\n\n \n\nint inet_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tstruct net *net = sock_net(sk);\n\tvoid __user *p = (void __user *)arg;\n\tstruct ifreq ifr;\n\tstruct rtentry rt;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\tif (copy_from_user(&rt, p, sizeof(struct rtentry)))\n\t\t\treturn -EFAULT;\n\t\terr = ip_rt_ioctl(net, cmd, &rt);\n\t\tbreak;\n\tcase SIOCRTMSG:\n\t\terr = -EINVAL;\n\t\tbreak;\n\tcase SIOCDARP:\n\tcase SIOCGARP:\n\tcase SIOCSARP:\n\t\terr = arp_ioctl(net, cmd, (void __user *)arg);\n\t\tbreak;\n\tcase SIOCGIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCGIFPFLAGS:\n\t\tif (get_user_ifreq(&ifr, NULL, p))\n\t\t\treturn -EFAULT;\n\t\terr = devinet_ioctl(net, cmd, &ifr);\n\t\tif (!err && put_user_ifreq(&ifr, p))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCSIFADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCSIFPFLAGS:\n\tcase SIOCSIFFLAGS:\n\t\tif (get_user_ifreq(&ifr, NULL, p))\n\t\t\treturn -EFAULT;\n\t\terr = devinet_ioctl(net, cmd, &ifr);\n\t\tbreak;\n\tdefault:\n\t\tif (sk->sk_prot->ioctl)\n\t\t\terr = sk_ioctl(sk, cmd, (void __user *)arg);\n\t\telse\n\t\t\terr = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL(inet_ioctl);\n\n#ifdef CONFIG_COMPAT\nstatic int inet_compat_routing_ioctl(struct sock *sk, unsigned int cmd,\n\t\tstruct compat_rtentry __user *ur)\n{\n\tcompat_uptr_t rtdev;\n\tstruct rtentry rt;\n\n\tif (copy_from_user(&rt.rt_dst, &ur->rt_dst,\n\t\t\t3 * sizeof(struct sockaddr)) ||\n\t    get_user(rt.rt_flags, &ur->rt_flags) ||\n\t    get_user(rt.rt_metric, &ur->rt_metric) ||\n\t    get_user(rt.rt_mtu, &ur->rt_mtu) ||\n\t    get_user(rt.rt_window, &ur->rt_window) ||\n\t    get_user(rt.rt_irtt, &ur->rt_irtt) ||\n\t    get_user(rtdev, &ur->rt_dev))\n\t\treturn -EFAULT;\n\n\trt.rt_dev = compat_ptr(rtdev);\n\treturn ip_rt_ioctl(sock_net(sk), cmd, &rt);\n}\n\nstatic int inet_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct sock *sk = sock->sk;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\treturn inet_compat_routing_ioctl(sk, cmd, argp);\n\tdefault:\n\t\tif (!sk->sk_prot->compat_ioctl)\n\t\t\treturn -ENOIOCTLCMD;\n\t\treturn sk->sk_prot->compat_ioctl(sk, cmd, arg);\n\t}\n}\n#endif  \n\nconst struct proto_ops inet_stream_ops = {\n\t.family\t\t   = PF_INET,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet_release,\n\t.bind\t\t   = inet_bind,\n\t.connect\t   = inet_stream_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = inet_accept,\n\t.getname\t   = inet_getname,\n\t.poll\t\t   = tcp_poll,\n\t.ioctl\t\t   = inet_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = inet_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = inet_recvmsg,\n#ifdef CONFIG_MMU\n\t.mmap\t\t   = tcp_mmap,\n#endif\n\t.splice_eof\t   = inet_splice_eof,\n\t.splice_read\t   = tcp_splice_read,\n\t.read_sock\t   = tcp_read_sock,\n\t.read_skb\t   = tcp_read_skb,\n\t.sendmsg_locked    = tcp_sendmsg_locked,\n\t.peek_len\t   = tcp_peek_len,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t   = inet_compat_ioctl,\n#endif\n\t.set_rcvlowat\t   = tcp_set_rcvlowat,\n};\nEXPORT_SYMBOL(inet_stream_ops);\n\nconst struct proto_ops inet_dgram_ops = {\n\t.family\t\t   = PF_INET,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet_release,\n\t.bind\t\t   = inet_bind,\n\t.connect\t   = inet_dgram_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = sock_no_accept,\n\t.getname\t   = inet_getname,\n\t.poll\t\t   = udp_poll,\n\t.ioctl\t\t   = inet_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = sock_no_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.read_skb\t   = udp_read_skb,\n\t.recvmsg\t   = inet_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n\t.splice_eof\t   = inet_splice_eof,\n\t.set_peek_off\t   = sk_set_peek_off,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t   = inet_compat_ioctl,\n#endif\n};\nEXPORT_SYMBOL(inet_dgram_ops);\n\n \nstatic const struct proto_ops inet_sockraw_ops = {\n\t.family\t\t   = PF_INET,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet_release,\n\t.bind\t\t   = inet_bind,\n\t.connect\t   = inet_dgram_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = sock_no_accept,\n\t.getname\t   = inet_getname,\n\t.poll\t\t   = datagram_poll,\n\t.ioctl\t\t   = inet_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = sock_no_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = inet_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n\t.splice_eof\t   = inet_splice_eof,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t   = inet_compat_ioctl,\n#endif\n};\n\nstatic const struct net_proto_family inet_family_ops = {\n\t.family = PF_INET,\n\t.create = inet_create,\n\t.owner\t= THIS_MODULE,\n};\n\n \nstatic struct inet_protosw inetsw_array[] =\n{\n\t{\n\t\t.type =       SOCK_STREAM,\n\t\t.protocol =   IPPROTO_TCP,\n\t\t.prot =       &tcp_prot,\n\t\t.ops =        &inet_stream_ops,\n\t\t.flags =      INET_PROTOSW_PERMANENT |\n\t\t\t      INET_PROTOSW_ICSK,\n\t},\n\n\t{\n\t\t.type =       SOCK_DGRAM,\n\t\t.protocol =   IPPROTO_UDP,\n\t\t.prot =       &udp_prot,\n\t\t.ops =        &inet_dgram_ops,\n\t\t.flags =      INET_PROTOSW_PERMANENT,\n       },\n\n       {\n\t\t.type =       SOCK_DGRAM,\n\t\t.protocol =   IPPROTO_ICMP,\n\t\t.prot =       &ping_prot,\n\t\t.ops =        &inet_sockraw_ops,\n\t\t.flags =      INET_PROTOSW_REUSE,\n       },\n\n       {\n\t       .type =       SOCK_RAW,\n\t       .protocol =   IPPROTO_IP,\t \n\t       .prot =       &raw_prot,\n\t       .ops =        &inet_sockraw_ops,\n\t       .flags =      INET_PROTOSW_REUSE,\n       }\n};\n\n#define INETSW_ARRAY_LEN ARRAY_SIZE(inetsw_array)\n\nvoid inet_register_protosw(struct inet_protosw *p)\n{\n\tstruct list_head *lh;\n\tstruct inet_protosw *answer;\n\tint protocol = p->protocol;\n\tstruct list_head *last_perm;\n\n\tspin_lock_bh(&inetsw_lock);\n\n\tif (p->type >= SOCK_MAX)\n\t\tgoto out_illegal;\n\n\t \n\tlast_perm = &inetsw[p->type];\n\tlist_for_each(lh, &inetsw[p->type]) {\n\t\tanswer = list_entry(lh, struct inet_protosw, list);\n\t\t \n\t\tif ((INET_PROTOSW_PERMANENT & answer->flags) == 0)\n\t\t\tbreak;\n\t\tif (protocol == answer->protocol)\n\t\t\tgoto out_permanent;\n\t\tlast_perm = lh;\n\t}\n\n\t \n\tlist_add_rcu(&p->list, last_perm);\nout:\n\tspin_unlock_bh(&inetsw_lock);\n\n\treturn;\n\nout_permanent:\n\tpr_err(\"Attempt to override permanent protocol %d\\n\", protocol);\n\tgoto out;\n\nout_illegal:\n\tpr_err(\"Ignoring attempt to register invalid socket type %d\\n\",\n\t       p->type);\n\tgoto out;\n}\nEXPORT_SYMBOL(inet_register_protosw);\n\nvoid inet_unregister_protosw(struct inet_protosw *p)\n{\n\tif (INET_PROTOSW_PERMANENT & p->flags) {\n\t\tpr_err(\"Attempt to unregister permanent protocol %d\\n\",\n\t\t       p->protocol);\n\t} else {\n\t\tspin_lock_bh(&inetsw_lock);\n\t\tlist_del_rcu(&p->list);\n\t\tspin_unlock_bh(&inetsw_lock);\n\n\t\tsynchronize_net();\n\t}\n}\nEXPORT_SYMBOL(inet_unregister_protosw);\n\nstatic int inet_sk_reselect_saddr(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__be32 old_saddr = inet->inet_saddr;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 *fl4;\n\tstruct rtable *rt;\n\t__be32 new_saddr;\n\tstruct ip_options_rcu *inet_opt;\n\tint err;\n\n\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t     lockdep_sock_is_held(sk));\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\n\t \n\tfl4 = &inet->cork.fl.u.ip4;\n\trt = ip_route_connect(fl4, daddr, 0, sk->sk_bound_dev_if,\n\t\t\t      sk->sk_protocol, inet->inet_sport,\n\t\t\t      inet->inet_dport, sk);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tnew_saddr = fl4->saddr;\n\n\tif (new_saddr == old_saddr) {\n\t\tsk_setup_caps(sk, &rt->dst);\n\t\treturn 0;\n\t}\n\n\terr = inet_bhash2_update_saddr(sk, &new_saddr, AF_INET);\n\tif (err) {\n\t\tip_rt_put(rt);\n\t\treturn err;\n\t}\n\n\tsk_setup_caps(sk, &rt->dst);\n\n\tif (READ_ONCE(sock_net(sk)->ipv4.sysctl_ip_dynaddr) > 1) {\n\t\tpr_info(\"%s(): shifting inet->saddr from %pI4 to %pI4\\n\",\n\t\t\t__func__, &old_saddr, &new_saddr);\n\t}\n\n\t \n\treturn __sk_prot_rehash(sk);\n}\n\nint inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tstruct ip_options_rcu *inet_opt;\n\tstruct flowi4 *fl4;\n\tint err;\n\n\t \n\tif (rt)\n\t\treturn 0;\n\n\t \n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tdaddr = inet->inet_daddr;\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trcu_read_unlock();\n\tfl4 = &inet->cork.fl.u.ip4;\n\trt = ip_route_output_ports(sock_net(sk), fl4, sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\n\t\t \n\t\tsk->sk_route_caps = 0;\n\t\t \n\t\tif (!READ_ONCE(sock_net(sk)->ipv4.sysctl_ip_dynaddr) ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tWRITE_ONCE(sk->sk_err_soft, -err);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL(inet_sk_rebuild_header);\n\nvoid inet_sk_set_state(struct sock *sk, int state)\n{\n\ttrace_inet_sock_set_state(sk, sk->sk_state, state);\n\tsk->sk_state = state;\n}\nEXPORT_SYMBOL(inet_sk_set_state);\n\nvoid inet_sk_state_store(struct sock *sk, int newstate)\n{\n\ttrace_inet_sock_set_state(sk, sk->sk_state, newstate);\n\tsmp_store_release(&sk->sk_state, newstate);\n}\n\nstruct sk_buff *inet_gso_segment(struct sk_buff *skb,\n\t\t\t\t netdev_features_t features)\n{\n\tbool udpfrag = false, fixedid = false, gso_partial, encap;\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tconst struct net_offload *ops;\n\tunsigned int offset = 0;\n\tstruct iphdr *iph;\n\tint proto, tot_len;\n\tint nhoff;\n\tint ihl;\n\tint id;\n\n\tskb_reset_network_header(skb);\n\tnhoff = skb_network_header(skb) - skb_mac_header(skb);\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*iph))))\n\t\tgoto out;\n\n\tiph = ip_hdr(skb);\n\tihl = iph->ihl * 4;\n\tif (ihl < sizeof(*iph))\n\t\tgoto out;\n\n\tid = ntohs(iph->id);\n\tproto = iph->protocol;\n\n\t \n\tif (unlikely(!pskb_may_pull(skb, ihl)))\n\t\tgoto out;\n\t__skb_pull(skb, ihl);\n\n\tencap = SKB_GSO_CB(skb)->encap_level > 0;\n\tif (encap)\n\t\tfeatures &= skb->dev->hw_enc_features;\n\tSKB_GSO_CB(skb)->encap_level += ihl;\n\n\tskb_reset_transport_header(skb);\n\n\tsegs = ERR_PTR(-EPROTONOSUPPORT);\n\n\tif (!skb->encapsulation || encap) {\n\t\tudpfrag = !!(skb_shinfo(skb)->gso_type & SKB_GSO_UDP);\n\t\tfixedid = !!(skb_shinfo(skb)->gso_type & SKB_GSO_TCP_FIXEDID);\n\n\t\t \n\t\tif (fixedid && !(ip_hdr(skb)->frag_off & htons(IP_DF)))\n\t\t\tgoto out;\n\t}\n\n\tops = rcu_dereference(inet_offloads[proto]);\n\tif (likely(ops && ops->callbacks.gso_segment)) {\n\t\tsegs = ops->callbacks.gso_segment(skb, features);\n\t\tif (!segs)\n\t\t\tskb->network_header = skb_mac_header(skb) + nhoff - skb->head;\n\t}\n\n\tif (IS_ERR_OR_NULL(segs))\n\t\tgoto out;\n\n\tgso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);\n\n\tskb = segs;\n\tdo {\n\t\tiph = (struct iphdr *)(skb_mac_header(skb) + nhoff);\n\t\tif (udpfrag) {\n\t\t\tiph->frag_off = htons(offset >> 3);\n\t\t\tif (skb->next)\n\t\t\t\tiph->frag_off |= htons(IP_MF);\n\t\t\toffset += skb->len - nhoff - ihl;\n\t\t\ttot_len = skb->len - nhoff;\n\t\t} else if (skb_is_gso(skb)) {\n\t\t\tif (!fixedid) {\n\t\t\t\tiph->id = htons(id);\n\t\t\t\tid += skb_shinfo(skb)->gso_segs;\n\t\t\t}\n\n\t\t\tif (gso_partial)\n\t\t\t\ttot_len = skb_shinfo(skb)->gso_size +\n\t\t\t\t\t  SKB_GSO_CB(skb)->data_offset +\n\t\t\t\t\t  skb->head - (unsigned char *)iph;\n\t\t\telse\n\t\t\t\ttot_len = skb->len - nhoff;\n\t\t} else {\n\t\t\tif (!fixedid)\n\t\t\t\tiph->id = htons(id++);\n\t\t\ttot_len = skb->len - nhoff;\n\t\t}\n\t\tiph->tot_len = htons(tot_len);\n\t\tip_send_check(iph);\n\t\tif (encap)\n\t\t\tskb_reset_inner_headers(skb);\n\t\tskb->network_header = (u8 *)iph - skb->head;\n\t\tskb_reset_mac_len(skb);\n\t} while ((skb = skb->next));\n\nout:\n\treturn segs;\n}\n\nstatic struct sk_buff *ipip_gso_segment(struct sk_buff *skb,\n\t\t\t\t\tnetdev_features_t features)\n{\n\tif (!(skb_shinfo(skb)->gso_type & SKB_GSO_IPXIP4))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn inet_gso_segment(skb, features);\n}\n\nstruct sk_buff *inet_gro_receive(struct list_head *head, struct sk_buff *skb)\n{\n\tconst struct net_offload *ops;\n\tstruct sk_buff *pp = NULL;\n\tconst struct iphdr *iph;\n\tstruct sk_buff *p;\n\tunsigned int hlen;\n\tunsigned int off;\n\tunsigned int id;\n\tint flush = 1;\n\tint proto;\n\n\toff = skb_gro_offset(skb);\n\thlen = off + sizeof(*iph);\n\tiph = skb_gro_header(skb, hlen, off);\n\tif (unlikely(!iph))\n\t\tgoto out;\n\n\tproto = iph->protocol;\n\n\tops = rcu_dereference(inet_offloads[proto]);\n\tif (!ops || !ops->callbacks.gro_receive)\n\t\tgoto out;\n\n\tif (*(u8 *)iph != 0x45)\n\t\tgoto out;\n\n\tif (ip_is_fragment(iph))\n\t\tgoto out;\n\n\tif (unlikely(ip_fast_csum((u8 *)iph, 5)))\n\t\tgoto out;\n\n\tNAPI_GRO_CB(skb)->proto = proto;\n\tid = ntohl(*(__be32 *)&iph->id);\n\tflush = (u16)((ntohl(*(__be32 *)iph) ^ skb_gro_len(skb)) | (id & ~IP_DF));\n\tid >>= 16;\n\n\tlist_for_each_entry(p, head, list) {\n\t\tstruct iphdr *iph2;\n\t\tu16 flush_id;\n\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tiph2 = (struct iphdr *)(p->data + off);\n\t\t \n\t\tif ((iph->protocol ^ iph2->protocol) |\n\t\t    ((__force u32)iph->saddr ^ (__force u32)iph2->saddr) |\n\t\t    ((__force u32)iph->daddr ^ (__force u32)iph2->daddr)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tNAPI_GRO_CB(p)->flush |=\n\t\t\t(iph->ttl ^ iph2->ttl) |\n\t\t\t(iph->tos ^ iph2->tos) |\n\t\t\t((iph->frag_off ^ iph2->frag_off) & htons(IP_DF));\n\n\t\tNAPI_GRO_CB(p)->flush |= flush;\n\n\t\t \n\t\tflush_id = (u16)(id - ntohs(iph2->id));\n\n\t\t \n\t\tif (!NAPI_GRO_CB(p)->is_atomic ||\n\t\t    !(iph->frag_off & htons(IP_DF))) {\n\t\t\tflush_id ^= NAPI_GRO_CB(p)->count;\n\t\t\tflush_id = flush_id ? 0xFFFF : 0;\n\t\t}\n\n\t\t \n\t\tif (NAPI_GRO_CB(skb)->is_atomic)\n\t\t\tNAPI_GRO_CB(p)->flush_id = flush_id;\n\t\telse\n\t\t\tNAPI_GRO_CB(p)->flush_id |= flush_id;\n\t}\n\n\tNAPI_GRO_CB(skb)->is_atomic = !!(iph->frag_off & htons(IP_DF));\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\tskb_set_network_header(skb, off);\n\t \n\n\t \n\tskb_gro_pull(skb, sizeof(*iph));\n\tskb_set_transport_header(skb, skb_gro_offset(skb));\n\n\tpp = indirect_call_gro_receive(tcp4_gro_receive, udp4_gro_receive,\n\t\t\t\t       ops->callbacks.gro_receive, head, skb);\n\nout:\n\tskb_gro_flush_final(skb, pp, flush);\n\n\treturn pp;\n}\n\nstatic struct sk_buff *ipip_gro_receive(struct list_head *head,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tif (NAPI_GRO_CB(skb)->encap_mark) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\n\treturn inet_gro_receive(head, skb);\n}\n\n#define SECONDS_PER_DAY\t86400\n\n \n__be32 inet_current_timestamp(void)\n{\n\tu32 secs;\n\tu32 msecs;\n\tstruct timespec64 ts;\n\n\tktime_get_real_ts64(&ts);\n\n\t \n\t(void)div_u64_rem(ts.tv_sec, SECONDS_PER_DAY, &secs);\n\t \n\tmsecs = secs * MSEC_PER_SEC;\n\t \n\tmsecs += (u32)ts.tv_nsec / NSEC_PER_MSEC;\n\n\t \n\treturn htonl(msecs);\n}\nEXPORT_SYMBOL(inet_current_timestamp);\n\nint inet_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)\n{\n\tif (sk->sk_family == AF_INET)\n\t\treturn ip_recv_error(sk, msg, len, addr_len);\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\treturn pingv6_ops.ipv6_recv_error(sk, msg, len, addr_len);\n#endif\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(inet_recv_error);\n\nint inet_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tstruct iphdr *iph = (struct iphdr *)(skb->data + nhoff);\n\tconst struct net_offload *ops;\n\t__be16 totlen = iph->tot_len;\n\tint proto = iph->protocol;\n\tint err = -ENOSYS;\n\n\tif (skb->encapsulation) {\n\t\tskb_set_inner_protocol(skb, cpu_to_be16(ETH_P_IP));\n\t\tskb_set_inner_network_header(skb, nhoff);\n\t}\n\n\tiph_set_totlen(iph, skb->len - nhoff);\n\tcsum_replace2(&iph->check, totlen, iph->tot_len);\n\n\tops = rcu_dereference(inet_offloads[proto]);\n\tif (WARN_ON(!ops || !ops->callbacks.gro_complete))\n\t\tgoto out;\n\n\t \n\terr = INDIRECT_CALL_2(ops->callbacks.gro_complete,\n\t\t\t      tcp4_gro_complete, udp4_gro_complete,\n\t\t\t      skb, nhoff + sizeof(*iph));\n\nout:\n\treturn err;\n}\n\nstatic int ipip_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tskb->encapsulation = 1;\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_IPXIP4;\n\treturn inet_gro_complete(skb, nhoff);\n}\n\nint inet_ctl_sock_create(struct sock **sk, unsigned short family,\n\t\t\t unsigned short type, unsigned char protocol,\n\t\t\t struct net *net)\n{\n\tstruct socket *sock;\n\tint rc = sock_create_kern(net, family, type, protocol, &sock);\n\n\tif (rc == 0) {\n\t\t*sk = sock->sk;\n\t\t(*sk)->sk_allocation = GFP_ATOMIC;\n\t\t(*sk)->sk_use_task_frag = false;\n\t\t \n\t\t(*sk)->sk_prot->unhash(*sk);\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(inet_ctl_sock_create);\n\nunsigned long snmp_fold_field(void __percpu *mib, int offt)\n{\n\tunsigned long res = 0;\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\tres += snmp_get_cpu_field(mib, i, offt);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(snmp_fold_field);\n\n#if BITS_PER_LONG==32\n\nu64 snmp_get_cpu_field64(void __percpu *mib, int cpu, int offt,\n\t\t\t size_t syncp_offset)\n{\n\tvoid *bhptr;\n\tstruct u64_stats_sync *syncp;\n\tu64 v;\n\tunsigned int start;\n\n\tbhptr = per_cpu_ptr(mib, cpu);\n\tsyncp = (struct u64_stats_sync *)(bhptr + syncp_offset);\n\tdo {\n\t\tstart = u64_stats_fetch_begin(syncp);\n\t\tv = *(((u64 *)bhptr) + offt);\n\t} while (u64_stats_fetch_retry(syncp, start));\n\n\treturn v;\n}\nEXPORT_SYMBOL_GPL(snmp_get_cpu_field64);\n\nu64 snmp_fold_field64(void __percpu *mib, int offt, size_t syncp_offset)\n{\n\tu64 res = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tres += snmp_get_cpu_field64(mib, cpu, offt, syncp_offset);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(snmp_fold_field64);\n#endif\n\n#ifdef CONFIG_IP_MULTICAST\nstatic const struct net_protocol igmp_protocol = {\n\t.handler =\tigmp_rcv,\n};\n#endif\n\nstatic const struct net_protocol tcp_protocol = {\n\t.handler\t=\ttcp_v4_rcv,\n\t.err_handler\t=\ttcp_v4_err,\n\t.no_policy\t=\t1,\n\t.icmp_strict_tag_validation = 1,\n};\n\nstatic const struct net_protocol udp_protocol = {\n\t.handler =\tudp_rcv,\n\t.err_handler =\tudp_err,\n\t.no_policy =\t1,\n};\n\nstatic const struct net_protocol icmp_protocol = {\n\t.handler =\ticmp_rcv,\n\t.err_handler =\ticmp_err,\n\t.no_policy =\t1,\n};\n\nstatic __net_init int ipv4_mib_init_net(struct net *net)\n{\n\tint i;\n\n\tnet->mib.tcp_statistics = alloc_percpu(struct tcp_mib);\n\tif (!net->mib.tcp_statistics)\n\t\tgoto err_tcp_mib;\n\tnet->mib.ip_statistics = alloc_percpu(struct ipstats_mib);\n\tif (!net->mib.ip_statistics)\n\t\tgoto err_ip_mib;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct ipstats_mib *af_inet_stats;\n\t\taf_inet_stats = per_cpu_ptr(net->mib.ip_statistics, i);\n\t\tu64_stats_init(&af_inet_stats->syncp);\n\t}\n\n\tnet->mib.net_statistics = alloc_percpu(struct linux_mib);\n\tif (!net->mib.net_statistics)\n\t\tgoto err_net_mib;\n\tnet->mib.udp_statistics = alloc_percpu(struct udp_mib);\n\tif (!net->mib.udp_statistics)\n\t\tgoto err_udp_mib;\n\tnet->mib.udplite_statistics = alloc_percpu(struct udp_mib);\n\tif (!net->mib.udplite_statistics)\n\t\tgoto err_udplite_mib;\n\tnet->mib.icmp_statistics = alloc_percpu(struct icmp_mib);\n\tif (!net->mib.icmp_statistics)\n\t\tgoto err_icmp_mib;\n\tnet->mib.icmpmsg_statistics = kzalloc(sizeof(struct icmpmsg_mib),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!net->mib.icmpmsg_statistics)\n\t\tgoto err_icmpmsg_mib;\n\n\ttcp_mib_init(net);\n\treturn 0;\n\nerr_icmpmsg_mib:\n\tfree_percpu(net->mib.icmp_statistics);\nerr_icmp_mib:\n\tfree_percpu(net->mib.udplite_statistics);\nerr_udplite_mib:\n\tfree_percpu(net->mib.udp_statistics);\nerr_udp_mib:\n\tfree_percpu(net->mib.net_statistics);\nerr_net_mib:\n\tfree_percpu(net->mib.ip_statistics);\nerr_ip_mib:\n\tfree_percpu(net->mib.tcp_statistics);\nerr_tcp_mib:\n\treturn -ENOMEM;\n}\n\nstatic __net_exit void ipv4_mib_exit_net(struct net *net)\n{\n\tkfree(net->mib.icmpmsg_statistics);\n\tfree_percpu(net->mib.icmp_statistics);\n\tfree_percpu(net->mib.udplite_statistics);\n\tfree_percpu(net->mib.udp_statistics);\n\tfree_percpu(net->mib.net_statistics);\n\tfree_percpu(net->mib.ip_statistics);\n\tfree_percpu(net->mib.tcp_statistics);\n#ifdef CONFIG_MPTCP\n\t \n\tfree_percpu(net->mib.mptcp_statistics);\n#endif\n}\n\nstatic __net_initdata struct pernet_operations ipv4_mib_ops = {\n\t.init = ipv4_mib_init_net,\n\t.exit = ipv4_mib_exit_net,\n};\n\nstatic int __init init_ipv4_mibs(void)\n{\n\treturn register_pernet_subsys(&ipv4_mib_ops);\n}\n\nstatic __net_init int inet_init_net(struct net *net)\n{\n\t \n\tseqlock_init(&net->ipv4.ip_local_ports.lock);\n\tnet->ipv4.ip_local_ports.range[0] =  32768;\n\tnet->ipv4.ip_local_ports.range[1] =  60999;\n\n\tseqlock_init(&net->ipv4.ping_group_range.lock);\n\t \n\tnet->ipv4.ping_group_range.range[0] = make_kgid(&init_user_ns, 1);\n\tnet->ipv4.ping_group_range.range[1] = make_kgid(&init_user_ns, 0);\n\n\t \n\tnet->ipv4.sysctl_ip_default_ttl = IPDEFTTL;\n\tnet->ipv4.sysctl_ip_fwd_update_priority = 1;\n\tnet->ipv4.sysctl_ip_dynaddr = 0;\n\tnet->ipv4.sysctl_ip_early_demux = 1;\n\tnet->ipv4.sysctl_udp_early_demux = 1;\n\tnet->ipv4.sysctl_tcp_early_demux = 1;\n\tnet->ipv4.sysctl_nexthop_compat_mode = 1;\n#ifdef CONFIG_SYSCTL\n\tnet->ipv4.sysctl_ip_prot_sock = PROT_SOCK;\n#endif\n\n\t \n\tnet->ipv4.sysctl_igmp_max_memberships = 20;\n\tnet->ipv4.sysctl_igmp_max_msf = 10;\n\t \n\tnet->ipv4.sysctl_igmp_llm_reports = 1;\n\tnet->ipv4.sysctl_igmp_qrv = 2;\n\n\tnet->ipv4.sysctl_fib_notify_on_flag_change = 0;\n\n\treturn 0;\n}\n\nstatic __net_initdata struct pernet_operations af_inet_ops = {\n\t.init = inet_init_net,\n};\n\nstatic int __init init_inet_pernet_ops(void)\n{\n\treturn register_pernet_subsys(&af_inet_ops);\n}\n\nstatic int ipv4_proc_init(void);\n\n \n\nstatic struct packet_offload ip_packet_offload __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_IP),\n\t.callbacks = {\n\t\t.gso_segment = inet_gso_segment,\n\t\t.gro_receive = inet_gro_receive,\n\t\t.gro_complete = inet_gro_complete,\n\t},\n};\n\nstatic const struct net_offload ipip_offload = {\n\t.callbacks = {\n\t\t.gso_segment\t= ipip_gso_segment,\n\t\t.gro_receive\t= ipip_gro_receive,\n\t\t.gro_complete\t= ipip_gro_complete,\n\t},\n};\n\nstatic int __init ipip_offload_init(void)\n{\n\treturn inet_add_offload(&ipip_offload, IPPROTO_IPIP);\n}\n\nstatic int __init ipv4_offload_init(void)\n{\n\t \n\tif (udpv4_offload_init() < 0)\n\t\tpr_crit(\"%s: Cannot add UDP protocol offload\\n\", __func__);\n\tif (tcpv4_offload_init() < 0)\n\t\tpr_crit(\"%s: Cannot add TCP protocol offload\\n\", __func__);\n\tif (ipip_offload_init() < 0)\n\t\tpr_crit(\"%s: Cannot add IPIP protocol offload\\n\", __func__);\n\n\tdev_add_offload(&ip_packet_offload);\n\treturn 0;\n}\n\nfs_initcall(ipv4_offload_init);\n\nstatic struct packet_type ip_packet_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_IP),\n\t.func = ip_rcv,\n\t.list_func = ip_list_rcv,\n};\n\nstatic int __init inet_init(void)\n{\n\tstruct inet_protosw *q;\n\tstruct list_head *r;\n\tint rc;\n\n\tsock_skb_cb_check_size(sizeof(struct inet_skb_parm));\n\n\traw_hashinfo_init(&raw_v4_hashinfo);\n\n\trc = proto_register(&tcp_prot, 1);\n\tif (rc)\n\t\tgoto out;\n\n\trc = proto_register(&udp_prot, 1);\n\tif (rc)\n\t\tgoto out_unregister_tcp_proto;\n\n\trc = proto_register(&raw_prot, 1);\n\tif (rc)\n\t\tgoto out_unregister_udp_proto;\n\n\trc = proto_register(&ping_prot, 1);\n\tif (rc)\n\t\tgoto out_unregister_raw_proto;\n\n\t \n\n\t(void)sock_register(&inet_family_ops);\n\n#ifdef CONFIG_SYSCTL\n\tip_static_sysctl_init();\n#endif\n\n\t \n\n\tif (inet_add_protocol(&icmp_protocol, IPPROTO_ICMP) < 0)\n\t\tpr_crit(\"%s: Cannot add ICMP protocol\\n\", __func__);\n\tif (inet_add_protocol(&udp_protocol, IPPROTO_UDP) < 0)\n\t\tpr_crit(\"%s: Cannot add UDP protocol\\n\", __func__);\n\tif (inet_add_protocol(&tcp_protocol, IPPROTO_TCP) < 0)\n\t\tpr_crit(\"%s: Cannot add TCP protocol\\n\", __func__);\n#ifdef CONFIG_IP_MULTICAST\n\tif (inet_add_protocol(&igmp_protocol, IPPROTO_IGMP) < 0)\n\t\tpr_crit(\"%s: Cannot add IGMP protocol\\n\", __func__);\n#endif\n\n\t \n\tfor (r = &inetsw[0]; r < &inetsw[SOCK_MAX]; ++r)\n\t\tINIT_LIST_HEAD(r);\n\n\tfor (q = inetsw_array; q < &inetsw_array[INETSW_ARRAY_LEN]; ++q)\n\t\tinet_register_protosw(q);\n\n\t \n\n\tarp_init();\n\n\t \n\n\tip_init();\n\n\t \n\tif (init_ipv4_mibs())\n\t\tpanic(\"%s: Cannot init ipv4 mibs\\n\", __func__);\n\n\t \n\ttcp_init();\n\n\t \n\tudp_init();\n\n\t \n\tudplite4_register();\n\n\traw_init();\n\n\tping_init();\n\n\t \n\n\tif (icmp_init() < 0)\n\t\tpanic(\"Failed to create the ICMP control socket.\\n\");\n\n\t \n#if defined(CONFIG_IP_MROUTE)\n\tif (ip_mr_init())\n\t\tpr_crit(\"%s: Cannot init ipv4 mroute\\n\", __func__);\n#endif\n\n\tif (init_inet_pernet_ops())\n\t\tpr_crit(\"%s: Cannot init ipv4 inet pernet ops\\n\", __func__);\n\n\tipv4_proc_init();\n\n\tipfrag_init();\n\n\tdev_add_pack(&ip_packet_type);\n\n\tip_tunnel_core_init();\n\n\trc = 0;\nout:\n\treturn rc;\nout_unregister_raw_proto:\n\tproto_unregister(&raw_prot);\nout_unregister_udp_proto:\n\tproto_unregister(&udp_prot);\nout_unregister_tcp_proto:\n\tproto_unregister(&tcp_prot);\n\tgoto out;\n}\n\nfs_initcall(inet_init);\n\n \n\n#ifdef CONFIG_PROC_FS\nstatic int __init ipv4_proc_init(void)\n{\n\tint rc = 0;\n\n\tif (raw_proc_init())\n\t\tgoto out_raw;\n\tif (tcp4_proc_init())\n\t\tgoto out_tcp;\n\tif (udp4_proc_init())\n\t\tgoto out_udp;\n\tif (ping_proc_init())\n\t\tgoto out_ping;\n\tif (ip_misc_proc_init())\n\t\tgoto out_misc;\nout:\n\treturn rc;\nout_misc:\n\tping_proc_exit();\nout_ping:\n\tudp4_proc_exit();\nout_udp:\n\ttcp4_proc_exit();\nout_tcp:\n\traw_proc_exit();\nout_raw:\n\trc = -ENOMEM;\n\tgoto out;\n}\n\n#else  \nstatic int __init ipv4_proc_init(void)\n{\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}