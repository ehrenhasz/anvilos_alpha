{
  "module_name": "fib_semantics.c",
  "hash_id": "7d70fa0163328c2daafd3af553ecfc9c873927f04e3b854b770c48a7ba9b4adb",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/fib_semantics.c",
  "human_readable_source": "\n \n\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/netlink.h>\n#include <linux/hash.h>\n#include <linux/nospec.h>\n\n#include <net/arp.h>\n#include <net/inet_dscp.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/route.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <net/ip_fib.h>\n#include <net/ip6_fib.h>\n#include <net/nexthop.h>\n#include <net/netlink.h>\n#include <net/rtnh.h>\n#include <net/lwtunnel.h>\n#include <net/fib_notifier.h>\n#include <net/addrconf.h>\n\n#include \"fib_lookup.h\"\n\nstatic DEFINE_SPINLOCK(fib_info_lock);\nstatic struct hlist_head *fib_info_hash;\nstatic struct hlist_head *fib_info_laddrhash;\nstatic unsigned int fib_info_hash_size;\nstatic unsigned int fib_info_hash_bits;\nstatic unsigned int fib_info_cnt;\n\n#define DEVINDEX_HASHBITS 8\n#define DEVINDEX_HASHSIZE (1U << DEVINDEX_HASHBITS)\nstatic struct hlist_head fib_info_devhash[DEVINDEX_HASHSIZE];\n\n \n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\n#define for_nexthops(fi) {\t\t\t\t\t\t\\\n\tint nhsel; const struct fib_nh *nh;\t\t\t\t\\\n\tfor (nhsel = 0, nh = (fi)->fib_nh;\t\t\t\t\\\n\t     nhsel < fib_info_num_path((fi));\t\t\t\t\\\n\t     nh++, nhsel++)\n\n#define change_nexthops(fi) {\t\t\t\t\t\t\\\n\tint nhsel; struct fib_nh *nexthop_nh;\t\t\t\t\\\n\tfor (nhsel = 0,\tnexthop_nh = (struct fib_nh *)((fi)->fib_nh);\t\\\n\t     nhsel < fib_info_num_path((fi));\t\t\t\t\\\n\t     nexthop_nh++, nhsel++)\n\n#else  \n\n \n\n#define for_nexthops(fi) {\t\t\t\t\t\t\\\n\tint nhsel; const struct fib_nh *nh = (fi)->fib_nh;\t\t\\\n\tfor (nhsel = 0; nhsel < 1; nhsel++)\n\n#define change_nexthops(fi) {\t\t\t\t\t\t\\\n\tint nhsel;\t\t\t\t\t\t\t\\\n\tstruct fib_nh *nexthop_nh = (struct fib_nh *)((fi)->fib_nh);\t\\\n\tfor (nhsel = 0; nhsel < 1; nhsel++)\n\n#endif  \n\n#define endfor_nexthops(fi) }\n\n\nconst struct fib_prop fib_props[RTN_MAX + 1] = {\n\t[RTN_UNSPEC] = {\n\t\t.error\t= 0,\n\t\t.scope\t= RT_SCOPE_NOWHERE,\n\t},\n\t[RTN_UNICAST] = {\n\t\t.error\t= 0,\n\t\t.scope\t= RT_SCOPE_UNIVERSE,\n\t},\n\t[RTN_LOCAL] = {\n\t\t.error\t= 0,\n\t\t.scope\t= RT_SCOPE_HOST,\n\t},\n\t[RTN_BROADCAST] = {\n\t\t.error\t= 0,\n\t\t.scope\t= RT_SCOPE_LINK,\n\t},\n\t[RTN_ANYCAST] = {\n\t\t.error\t= 0,\n\t\t.scope\t= RT_SCOPE_LINK,\n\t},\n\t[RTN_MULTICAST] = {\n\t\t.error\t= 0,\n\t\t.scope\t= RT_SCOPE_UNIVERSE,\n\t},\n\t[RTN_BLACKHOLE] = {\n\t\t.error\t= -EINVAL,\n\t\t.scope\t= RT_SCOPE_UNIVERSE,\n\t},\n\t[RTN_UNREACHABLE] = {\n\t\t.error\t= -EHOSTUNREACH,\n\t\t.scope\t= RT_SCOPE_UNIVERSE,\n\t},\n\t[RTN_PROHIBIT] = {\n\t\t.error\t= -EACCES,\n\t\t.scope\t= RT_SCOPE_UNIVERSE,\n\t},\n\t[RTN_THROW] = {\n\t\t.error\t= -EAGAIN,\n\t\t.scope\t= RT_SCOPE_UNIVERSE,\n\t},\n\t[RTN_NAT] = {\n\t\t.error\t= -EINVAL,\n\t\t.scope\t= RT_SCOPE_NOWHERE,\n\t},\n\t[RTN_XRESOLVE] = {\n\t\t.error\t= -EINVAL,\n\t\t.scope\t= RT_SCOPE_NOWHERE,\n\t},\n};\n\nstatic void rt_fibinfo_free(struct rtable __rcu **rtp)\n{\n\tstruct rtable *rt = rcu_dereference_protected(*rtp, 1);\n\n\tif (!rt)\n\t\treturn;\n\n\t \n\n\tdst_dev_put(&rt->dst);\n\tdst_release_immediate(&rt->dst);\n}\n\nstatic void free_nh_exceptions(struct fib_nh_common *nhc)\n{\n\tstruct fnhe_hash_bucket *hash;\n\tint i;\n\n\thash = rcu_dereference_protected(nhc->nhc_exceptions, 1);\n\tif (!hash)\n\t\treturn;\n\tfor (i = 0; i < FNHE_HASH_SIZE; i++) {\n\t\tstruct fib_nh_exception *fnhe;\n\n\t\tfnhe = rcu_dereference_protected(hash[i].chain, 1);\n\t\twhile (fnhe) {\n\t\t\tstruct fib_nh_exception *next;\n\n\t\t\tnext = rcu_dereference_protected(fnhe->fnhe_next, 1);\n\n\t\t\trt_fibinfo_free(&fnhe->fnhe_rth_input);\n\t\t\trt_fibinfo_free(&fnhe->fnhe_rth_output);\n\n\t\t\tkfree(fnhe);\n\n\t\t\tfnhe = next;\n\t\t}\n\t}\n\tkfree(hash);\n}\n\nstatic void rt_fibinfo_free_cpus(struct rtable __rcu * __percpu *rtp)\n{\n\tint cpu;\n\n\tif (!rtp)\n\t\treturn;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct rtable *rt;\n\n\t\trt = rcu_dereference_protected(*per_cpu_ptr(rtp, cpu), 1);\n\t\tif (rt) {\n\t\t\tdst_dev_put(&rt->dst);\n\t\t\tdst_release_immediate(&rt->dst);\n\t\t}\n\t}\n\tfree_percpu(rtp);\n}\n\nvoid fib_nh_common_release(struct fib_nh_common *nhc)\n{\n\tnetdev_put(nhc->nhc_dev, &nhc->nhc_dev_tracker);\n\tlwtstate_put(nhc->nhc_lwtstate);\n\trt_fibinfo_free_cpus(nhc->nhc_pcpu_rth_output);\n\trt_fibinfo_free(&nhc->nhc_rth_input);\n\tfree_nh_exceptions(nhc);\n}\nEXPORT_SYMBOL_GPL(fib_nh_common_release);\n\nvoid fib_nh_release(struct net *net, struct fib_nh *fib_nh)\n{\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tif (fib_nh->nh_tclassid)\n\t\tatomic_dec(&net->ipv4.fib_num_tclassid_users);\n#endif\n\tfib_nh_common_release(&fib_nh->nh_common);\n}\n\n \nstatic void free_fib_info_rcu(struct rcu_head *head)\n{\n\tstruct fib_info *fi = container_of(head, struct fib_info, rcu);\n\n\tif (fi->nh) {\n\t\tnexthop_put(fi->nh);\n\t} else {\n\t\tchange_nexthops(fi) {\n\t\t\tfib_nh_release(fi->fib_net, nexthop_nh);\n\t\t} endfor_nexthops(fi);\n\t}\n\n\tip_fib_metrics_put(fi->fib_metrics);\n\n\tkfree(fi);\n}\n\nvoid free_fib_info(struct fib_info *fi)\n{\n\tif (fi->fib_dead == 0) {\n\t\tpr_warn(\"Freeing alive fib_info %p\\n\", fi);\n\t\treturn;\n\t}\n\n\tcall_rcu(&fi->rcu, free_fib_info_rcu);\n}\nEXPORT_SYMBOL_GPL(free_fib_info);\n\nvoid fib_release_info(struct fib_info *fi)\n{\n\tspin_lock_bh(&fib_info_lock);\n\tif (fi && refcount_dec_and_test(&fi->fib_treeref)) {\n\t\thlist_del(&fi->fib_hash);\n\n\t\t \n\t\tWRITE_ONCE(fib_info_cnt, fib_info_cnt - 1);\n\n\t\tif (fi->fib_prefsrc)\n\t\t\thlist_del(&fi->fib_lhash);\n\t\tif (fi->nh) {\n\t\t\tlist_del(&fi->nh_list);\n\t\t} else {\n\t\t\tchange_nexthops(fi) {\n\t\t\t\tif (!nexthop_nh->fib_nh_dev)\n\t\t\t\t\tcontinue;\n\t\t\t\thlist_del(&nexthop_nh->nh_hash);\n\t\t\t} endfor_nexthops(fi)\n\t\t}\n\t\t \n\t\tWRITE_ONCE(fi->fib_dead, 1);\n\t\tfib_info_put(fi);\n\t}\n\tspin_unlock_bh(&fib_info_lock);\n}\n\nstatic inline int nh_comp(struct fib_info *fi, struct fib_info *ofi)\n{\n\tconst struct fib_nh *onh;\n\n\tif (fi->nh || ofi->nh)\n\t\treturn nexthop_cmp(fi->nh, ofi->nh) ? 0 : -1;\n\n\tif (ofi->fib_nhs == 0)\n\t\treturn 0;\n\n\tfor_nexthops(fi) {\n\t\tonh = fib_info_nh(ofi, nhsel);\n\n\t\tif (nh->fib_nh_oif != onh->fib_nh_oif ||\n\t\t    nh->fib_nh_gw_family != onh->fib_nh_gw_family ||\n\t\t    nh->fib_nh_scope != onh->fib_nh_scope ||\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\t\t    nh->fib_nh_weight != onh->fib_nh_weight ||\n#endif\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\t\t    nh->nh_tclassid != onh->nh_tclassid ||\n#endif\n\t\t    lwtunnel_cmp_encap(nh->fib_nh_lws, onh->fib_nh_lws) ||\n\t\t    ((nh->fib_nh_flags ^ onh->fib_nh_flags) & ~RTNH_COMPARE_MASK))\n\t\t\treturn -1;\n\n\t\tif (nh->fib_nh_gw_family == AF_INET &&\n\t\t    nh->fib_nh_gw4 != onh->fib_nh_gw4)\n\t\t\treturn -1;\n\n\t\tif (nh->fib_nh_gw_family == AF_INET6 &&\n\t\t    ipv6_addr_cmp(&nh->fib_nh_gw6, &onh->fib_nh_gw6))\n\t\t\treturn -1;\n\t} endfor_nexthops(fi);\n\treturn 0;\n}\n\nstatic inline unsigned int fib_devindex_hashfn(unsigned int val)\n{\n\treturn hash_32(val, DEVINDEX_HASHBITS);\n}\n\nstatic struct hlist_head *\nfib_info_devhash_bucket(const struct net_device *dev)\n{\n\tu32 val = net_hash_mix(dev_net(dev)) ^ dev->ifindex;\n\n\treturn &fib_info_devhash[fib_devindex_hashfn(val)];\n}\n\nstatic unsigned int fib_info_hashfn_1(int init_val, u8 protocol, u8 scope,\n\t\t\t\t      u32 prefsrc, u32 priority)\n{\n\tunsigned int val = init_val;\n\n\tval ^= (protocol << 8) | scope;\n\tval ^= prefsrc;\n\tval ^= priority;\n\n\treturn val;\n}\n\nstatic unsigned int fib_info_hashfn_result(unsigned int val)\n{\n\tunsigned int mask = (fib_info_hash_size - 1);\n\n\treturn (val ^ (val >> 7) ^ (val >> 12)) & mask;\n}\n\nstatic inline unsigned int fib_info_hashfn(struct fib_info *fi)\n{\n\tunsigned int val;\n\n\tval = fib_info_hashfn_1(fi->fib_nhs, fi->fib_protocol,\n\t\t\t\tfi->fib_scope, (__force u32)fi->fib_prefsrc,\n\t\t\t\tfi->fib_priority);\n\n\tif (fi->nh) {\n\t\tval ^= fib_devindex_hashfn(fi->nh->id);\n\t} else {\n\t\tfor_nexthops(fi) {\n\t\t\tval ^= fib_devindex_hashfn(nh->fib_nh_oif);\n\t\t} endfor_nexthops(fi)\n\t}\n\n\treturn fib_info_hashfn_result(val);\n}\n\n \nstatic struct fib_info *fib_find_info_nh(struct net *net,\n\t\t\t\t\t const struct fib_config *cfg)\n{\n\tstruct hlist_head *head;\n\tstruct fib_info *fi;\n\tunsigned int hash;\n\n\thash = fib_info_hashfn_1(fib_devindex_hashfn(cfg->fc_nh_id),\n\t\t\t\t cfg->fc_protocol, cfg->fc_scope,\n\t\t\t\t (__force u32)cfg->fc_prefsrc,\n\t\t\t\t cfg->fc_priority);\n\thash = fib_info_hashfn_result(hash);\n\thead = &fib_info_hash[hash];\n\n\thlist_for_each_entry(fi, head, fib_hash) {\n\t\tif (!net_eq(fi->fib_net, net))\n\t\t\tcontinue;\n\t\tif (!fi->nh || fi->nh->id != cfg->fc_nh_id)\n\t\t\tcontinue;\n\t\tif (cfg->fc_protocol == fi->fib_protocol &&\n\t\t    cfg->fc_scope == fi->fib_scope &&\n\t\t    cfg->fc_prefsrc == fi->fib_prefsrc &&\n\t\t    cfg->fc_priority == fi->fib_priority &&\n\t\t    cfg->fc_type == fi->fib_type &&\n\t\t    cfg->fc_table == fi->fib_tb_id &&\n\t\t    !((cfg->fc_flags ^ fi->fib_flags) & ~RTNH_COMPARE_MASK))\n\t\t\treturn fi;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct fib_info *fib_find_info(struct fib_info *nfi)\n{\n\tstruct hlist_head *head;\n\tstruct fib_info *fi;\n\tunsigned int hash;\n\n\thash = fib_info_hashfn(nfi);\n\thead = &fib_info_hash[hash];\n\n\thlist_for_each_entry(fi, head, fib_hash) {\n\t\tif (!net_eq(fi->fib_net, nfi->fib_net))\n\t\t\tcontinue;\n\t\tif (fi->fib_nhs != nfi->fib_nhs)\n\t\t\tcontinue;\n\t\tif (nfi->fib_protocol == fi->fib_protocol &&\n\t\t    nfi->fib_scope == fi->fib_scope &&\n\t\t    nfi->fib_prefsrc == fi->fib_prefsrc &&\n\t\t    nfi->fib_priority == fi->fib_priority &&\n\t\t    nfi->fib_type == fi->fib_type &&\n\t\t    nfi->fib_tb_id == fi->fib_tb_id &&\n\t\t    memcmp(nfi->fib_metrics, fi->fib_metrics,\n\t\t\t   sizeof(u32) * RTAX_MAX) == 0 &&\n\t\t    !((nfi->fib_flags ^ fi->fib_flags) & ~RTNH_COMPARE_MASK) &&\n\t\t    nh_comp(fi, nfi) == 0)\n\t\t\treturn fi;\n\t}\n\n\treturn NULL;\n}\n\n \nint ip_fib_check_default(__be32 gw, struct net_device *dev)\n{\n\tstruct hlist_head *head;\n\tstruct fib_nh *nh;\n\n\tspin_lock(&fib_info_lock);\n\n\thead = fib_info_devhash_bucket(dev);\n\n\thlist_for_each_entry(nh, head, nh_hash) {\n\t\tif (nh->fib_nh_dev == dev &&\n\t\t    nh->fib_nh_gw4 == gw &&\n\t\t    !(nh->fib_nh_flags & RTNH_F_DEAD)) {\n\t\t\tspin_unlock(&fib_info_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tspin_unlock(&fib_info_lock);\n\n\treturn -1;\n}\n\nsize_t fib_nlmsg_size(struct fib_info *fi)\n{\n\tsize_t payload = NLMSG_ALIGN(sizeof(struct rtmsg))\n\t\t\t + nla_total_size(4)  \n\t\t\t + nla_total_size(4)  \n\t\t\t + nla_total_size(4)  \n\t\t\t + nla_total_size(4)  \n\t\t\t + nla_total_size(TCP_CA_NAME_MAX);  \n\tunsigned int nhs = fib_info_num_path(fi);\n\n\t \n\tpayload += nla_total_size((RTAX_MAX * nla_total_size(4)));\n\n\tif (fi->nh)\n\t\tpayload += nla_total_size(4);  \n\n\tif (nhs) {\n\t\tsize_t nh_encapsize = 0;\n\t\t \n\n\t\t \n\t\tsize_t nhsize = nla_total_size(sizeof(struct rtnexthop));\n\t\tunsigned int i;\n\n\t\t \n\t\tnhsize += 2 * nla_total_size(4);\n\n\t\t \n\t\tfor (i = 0; i < fib_info_num_path(fi); i++) {\n\t\t\tstruct fib_nh_common *nhc = fib_info_nhc(fi, i);\n\n\t\t\tif (nhc->nhc_lwtstate) {\n\t\t\t\t \n\t\t\t\tnh_encapsize += lwtunnel_get_encap_size(\n\t\t\t\t\t\tnhc->nhc_lwtstate);\n\t\t\t\t \n\t\t\t\tnh_encapsize +=  nla_total_size(2);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tpayload += nla_total_size((nhs * nhsize) + nh_encapsize);\n\n\t}\n\n\treturn payload;\n}\n\nvoid rtmsg_fib(int event, __be32 key, struct fib_alias *fa,\n\t       int dst_len, u32 tb_id, const struct nl_info *info,\n\t       unsigned int nlm_flags)\n{\n\tstruct fib_rt_info fri;\n\tstruct sk_buff *skb;\n\tu32 seq = info->nlh ? info->nlh->nlmsg_seq : 0;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(fib_nlmsg_size(fa->fa_info), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\tfri.fi = fa->fa_info;\n\tfri.tb_id = tb_id;\n\tfri.dst = key;\n\tfri.dst_len = dst_len;\n\tfri.dscp = fa->fa_dscp;\n\tfri.type = fa->fa_type;\n\tfri.offload = READ_ONCE(fa->offload);\n\tfri.trap = READ_ONCE(fa->trap);\n\tfri.offload_failed = READ_ONCE(fa->offload_failed);\n\terr = fib_dump_info(skb, info->portid, seq, event, &fri, nlm_flags);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, info->nl_net, info->portid, RTNLGRP_IPV4_ROUTE,\n\t\t    info->nlh, GFP_KERNEL);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(info->nl_net, RTNLGRP_IPV4_ROUTE, err);\n}\n\nstatic int fib_detect_death(struct fib_info *fi, int order,\n\t\t\t    struct fib_info **last_resort, int *last_idx,\n\t\t\t    int dflt)\n{\n\tconst struct fib_nh_common *nhc = fib_info_nhc(fi, 0);\n\tstruct neighbour *n;\n\tint state = NUD_NONE;\n\n\tif (likely(nhc->nhc_gw_family == AF_INET))\n\t\tn = neigh_lookup(&arp_tbl, &nhc->nhc_gw.ipv4, nhc->nhc_dev);\n\telse if (nhc->nhc_gw_family == AF_INET6)\n\t\tn = neigh_lookup(ipv6_stub->nd_tbl, &nhc->nhc_gw.ipv6,\n\t\t\t\t nhc->nhc_dev);\n\telse\n\t\tn = NULL;\n\n\tif (n) {\n\t\tstate = READ_ONCE(n->nud_state);\n\t\tneigh_release(n);\n\t} else {\n\t\treturn 0;\n\t}\n\tif (state == NUD_REACHABLE)\n\t\treturn 0;\n\tif ((state & NUD_VALID) && order != dflt)\n\t\treturn 0;\n\tif ((state & NUD_VALID) ||\n\t    (*last_idx < 0 && order > dflt && state != NUD_INCOMPLETE)) {\n\t\t*last_resort = fi;\n\t\t*last_idx = order;\n\t}\n\treturn 1;\n}\n\nint fib_nh_common_init(struct net *net, struct fib_nh_common *nhc,\n\t\t       struct nlattr *encap, u16 encap_type,\n\t\t       void *cfg, gfp_t gfp_flags,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tnhc->nhc_pcpu_rth_output = alloc_percpu_gfp(struct rtable __rcu *,\n\t\t\t\t\t\t    gfp_flags);\n\tif (!nhc->nhc_pcpu_rth_output)\n\t\treturn -ENOMEM;\n\n\tif (encap) {\n\t\tstruct lwtunnel_state *lwtstate;\n\n\t\tif (encap_type == LWTUNNEL_ENCAP_NONE) {\n\t\t\tNL_SET_ERR_MSG(extack, \"LWT encap type not specified\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto lwt_failure;\n\t\t}\n\t\terr = lwtunnel_build_state(net, encap_type, encap,\n\t\t\t\t\t   nhc->nhc_family, cfg, &lwtstate,\n\t\t\t\t\t   extack);\n\t\tif (err)\n\t\t\tgoto lwt_failure;\n\n\t\tnhc->nhc_lwtstate = lwtstate_get(lwtstate);\n\t}\n\n\treturn 0;\n\nlwt_failure:\n\trt_fibinfo_free_cpus(nhc->nhc_pcpu_rth_output);\n\tnhc->nhc_pcpu_rth_output = NULL;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(fib_nh_common_init);\n\nint fib_nh_init(struct net *net, struct fib_nh *nh,\n\t\tstruct fib_config *cfg, int nh_weight,\n\t\tstruct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tnh->fib_nh_family = AF_INET;\n\n\terr = fib_nh_common_init(net, &nh->nh_common, cfg->fc_encap,\n\t\t\t\t cfg->fc_encap_type, cfg, GFP_KERNEL, extack);\n\tif (err)\n\t\treturn err;\n\n\tnh->fib_nh_oif = cfg->fc_oif;\n\tnh->fib_nh_gw_family = cfg->fc_gw_family;\n\tif (cfg->fc_gw_family == AF_INET)\n\t\tnh->fib_nh_gw4 = cfg->fc_gw4;\n\telse if (cfg->fc_gw_family == AF_INET6)\n\t\tnh->fib_nh_gw6 = cfg->fc_gw6;\n\n\tnh->fib_nh_flags = cfg->fc_flags;\n\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tnh->nh_tclassid = cfg->fc_flow;\n\tif (nh->nh_tclassid)\n\t\tatomic_inc(&net->ipv4.fib_num_tclassid_users);\n#endif\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\tnh->fib_nh_weight = nh_weight;\n#endif\n\treturn 0;\n}\n\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\nstatic int fib_count_nexthops(struct rtnexthop *rtnh, int remaining,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint nhs = 0;\n\n\twhile (rtnh_ok(rtnh, remaining)) {\n\t\tnhs++;\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t}\n\n\t \n\tif (remaining > 0) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid nexthop configuration - extra data after nexthops\");\n\t\tnhs = 0;\n\t}\n\n\treturn nhs;\n}\n\nstatic int fib_gw_from_attr(__be32 *gw, struct nlattr *nla,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (nla_len(nla) < sizeof(*gw)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid IPv4 address in RTA_GATEWAY\");\n\t\treturn -EINVAL;\n\t}\n\n\t*gw = nla_get_in_addr(nla);\n\n\treturn 0;\n}\n\n \nstatic int fib_get_nhs(struct fib_info *fi, struct rtnexthop *rtnh,\n\t\t       int remaining, struct fib_config *cfg,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net *net = fi->fib_net;\n\tstruct fib_config fib_cfg;\n\tstruct fib_nh *nh;\n\tint ret;\n\n\tchange_nexthops(fi) {\n\t\tint attrlen;\n\n\t\tmemset(&fib_cfg, 0, sizeof(fib_cfg));\n\n\t\tif (!rtnh_ok(rtnh, remaining)) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Invalid nexthop configuration - extra data after nexthop\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rtnh->rtnh_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN)) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Invalid flags for nexthop - can not contain DEAD or LINKDOWN\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfib_cfg.fc_flags = (cfg->fc_flags & ~0xFF) | rtnh->rtnh_flags;\n\t\tfib_cfg.fc_oif = rtnh->rtnh_ifindex;\n\n\t\tattrlen = rtnh_attrlen(rtnh);\n\t\tif (attrlen > 0) {\n\t\t\tstruct nlattr *nla, *nlav, *attrs = rtnh_attrs(rtnh);\n\n\t\t\tnla = nla_find(attrs, attrlen, RTA_GATEWAY);\n\t\t\tnlav = nla_find(attrs, attrlen, RTA_VIA);\n\t\t\tif (nla && nlav) {\n\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t       \"Nexthop configuration can not contain both GATEWAY and VIA\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (nla) {\n\t\t\t\tret = fib_gw_from_attr(&fib_cfg.fc_gw4, nla,\n\t\t\t\t\t\t       extack);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto errout;\n\n\t\t\t\tif (fib_cfg.fc_gw4)\n\t\t\t\t\tfib_cfg.fc_gw_family = AF_INET;\n\t\t\t} else if (nlav) {\n\t\t\t\tret = fib_gw_from_via(&fib_cfg, nlav, extack);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\n\t\t\tnla = nla_find(attrs, attrlen, RTA_FLOW);\n\t\t\tif (nla) {\n\t\t\t\tif (nla_len(nla) < sizeof(u32)) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid RTA_FLOW\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tfib_cfg.fc_flow = nla_get_u32(nla);\n\t\t\t}\n\n\t\t\tfib_cfg.fc_encap = nla_find(attrs, attrlen, RTA_ENCAP);\n\t\t\t \n\t\t\tnla = nla_find(attrs, attrlen, RTA_ENCAP_TYPE);\n\t\t\tif (nla)\n\t\t\t\tfib_cfg.fc_encap_type = nla_get_u16(nla);\n\t\t}\n\n\t\tret = fib_nh_init(net, nexthop_nh, &fib_cfg,\n\t\t\t\t  rtnh->rtnh_hops + 1, extack);\n\t\tif (ret)\n\t\t\tgoto errout;\n\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t} endfor_nexthops(fi);\n\n\tret = -EINVAL;\n\tnh = fib_info_nh(fi, 0);\n\tif (cfg->fc_oif && nh->fib_nh_oif != cfg->fc_oif) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Nexthop device index does not match RTA_OIF\");\n\t\tgoto errout;\n\t}\n\tif (cfg->fc_gw_family) {\n\t\tif (cfg->fc_gw_family != nh->fib_nh_gw_family ||\n\t\t    (cfg->fc_gw_family == AF_INET &&\n\t\t     nh->fib_nh_gw4 != cfg->fc_gw4) ||\n\t\t    (cfg->fc_gw_family == AF_INET6 &&\n\t\t     ipv6_addr_cmp(&nh->fib_nh_gw6, &cfg->fc_gw6))) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Nexthop gateway does not match RTA_GATEWAY or RTA_VIA\");\n\t\t\tgoto errout;\n\t\t}\n\t}\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tif (cfg->fc_flow && nh->nh_tclassid != cfg->fc_flow) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Nexthop class id does not match RTA_FLOW\");\n\t\tgoto errout;\n\t}\n#endif\n\tret = 0;\nerrout:\n\treturn ret;\n}\n\n \nstatic void fib_rebalance(struct fib_info *fi)\n{\n\tint total;\n\tint w;\n\n\tif (fib_info_num_path(fi) < 2)\n\t\treturn;\n\n\ttotal = 0;\n\tfor_nexthops(fi) {\n\t\tif (nh->fib_nh_flags & RTNH_F_DEAD)\n\t\t\tcontinue;\n\n\t\tif (ip_ignore_linkdown(nh->fib_nh_dev) &&\n\t\t    nh->fib_nh_flags & RTNH_F_LINKDOWN)\n\t\t\tcontinue;\n\n\t\ttotal += nh->fib_nh_weight;\n\t} endfor_nexthops(fi);\n\n\tw = 0;\n\tchange_nexthops(fi) {\n\t\tint upper_bound;\n\n\t\tif (nexthop_nh->fib_nh_flags & RTNH_F_DEAD) {\n\t\t\tupper_bound = -1;\n\t\t} else if (ip_ignore_linkdown(nexthop_nh->fib_nh_dev) &&\n\t\t\t   nexthop_nh->fib_nh_flags & RTNH_F_LINKDOWN) {\n\t\t\tupper_bound = -1;\n\t\t} else {\n\t\t\tw += nexthop_nh->fib_nh_weight;\n\t\t\tupper_bound = DIV_ROUND_CLOSEST_ULL((u64)w << 31,\n\t\t\t\t\t\t\t    total) - 1;\n\t\t}\n\n\t\tatomic_set(&nexthop_nh->fib_nh_upper_bound, upper_bound);\n\t} endfor_nexthops(fi);\n}\n#else  \n\nstatic int fib_get_nhs(struct fib_info *fi, struct rtnexthop *rtnh,\n\t\t       int remaining, struct fib_config *cfg,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tNL_SET_ERR_MSG(extack, \"Multipath support not enabled in kernel\");\n\n\treturn -EINVAL;\n}\n\n#define fib_rebalance(fi) do { } while (0)\n\n#endif  \n\nstatic int fib_encap_match(struct net *net, u16 encap_type,\n\t\t\t   struct nlattr *encap,\n\t\t\t   const struct fib_nh *nh,\n\t\t\t   const struct fib_config *cfg,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct lwtunnel_state *lwtstate;\n\tint ret, result = 0;\n\n\tif (encap_type == LWTUNNEL_ENCAP_NONE)\n\t\treturn 0;\n\n\tret = lwtunnel_build_state(net, encap_type, encap, AF_INET,\n\t\t\t\t   cfg, &lwtstate, extack);\n\tif (!ret) {\n\t\tresult = lwtunnel_cmp_encap(lwtstate, nh->fib_nh_lws);\n\t\tlwtstate_free(lwtstate);\n\t}\n\n\treturn result;\n}\n\nint fib_nh_match(struct net *net, struct fib_config *cfg, struct fib_info *fi,\n\t\t struct netlink_ext_ack *extack)\n{\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\tstruct rtnexthop *rtnh;\n\tint remaining;\n#endif\n\n\tif (cfg->fc_priority && cfg->fc_priority != fi->fib_priority)\n\t\treturn 1;\n\n\tif (cfg->fc_nh_id) {\n\t\tif (fi->nh && cfg->fc_nh_id == fi->nh->id)\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\n\tif (fi->nh) {\n\t\tif (cfg->fc_oif || cfg->fc_gw_family || cfg->fc_mp)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tif (cfg->fc_oif || cfg->fc_gw_family) {\n\t\tstruct fib_nh *nh;\n\n\t\tnh = fib_info_nh(fi, 0);\n\t\tif (cfg->fc_encap) {\n\t\t\tif (fib_encap_match(net, cfg->fc_encap_type,\n\t\t\t\t\t    cfg->fc_encap, nh, cfg, extack))\n\t\t\t\treturn 1;\n\t\t}\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\t\tif (cfg->fc_flow &&\n\t\t    cfg->fc_flow != nh->nh_tclassid)\n\t\t\treturn 1;\n#endif\n\t\tif ((cfg->fc_oif && cfg->fc_oif != nh->fib_nh_oif) ||\n\t\t    (cfg->fc_gw_family &&\n\t\t     cfg->fc_gw_family != nh->fib_nh_gw_family))\n\t\t\treturn 1;\n\n\t\tif (cfg->fc_gw_family == AF_INET &&\n\t\t    cfg->fc_gw4 != nh->fib_nh_gw4)\n\t\t\treturn 1;\n\n\t\tif (cfg->fc_gw_family == AF_INET6 &&\n\t\t    ipv6_addr_cmp(&cfg->fc_gw6, &nh->fib_nh_gw6))\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\tif (!cfg->fc_mp)\n\t\treturn 0;\n\n\trtnh = cfg->fc_mp;\n\tremaining = cfg->fc_mp_len;\n\n\tfor_nexthops(fi) {\n\t\tint attrlen;\n\n\t\tif (!rtnh_ok(rtnh, remaining))\n\t\t\treturn -EINVAL;\n\n\t\tif (rtnh->rtnh_ifindex && rtnh->rtnh_ifindex != nh->fib_nh_oif)\n\t\t\treturn 1;\n\n\t\tattrlen = rtnh_attrlen(rtnh);\n\t\tif (attrlen > 0) {\n\t\t\tstruct nlattr *nla, *nlav, *attrs = rtnh_attrs(rtnh);\n\t\t\tint err;\n\n\t\t\tnla = nla_find(attrs, attrlen, RTA_GATEWAY);\n\t\t\tnlav = nla_find(attrs, attrlen, RTA_VIA);\n\t\t\tif (nla && nlav) {\n\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t       \"Nexthop configuration can not contain both GATEWAY and VIA\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (nla) {\n\t\t\t\t__be32 gw;\n\n\t\t\t\terr = fib_gw_from_attr(&gw, nla, extack);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tif (nh->fib_nh_gw_family != AF_INET ||\n\t\t\t\t    gw != nh->fib_nh_gw4)\n\t\t\t\t\treturn 1;\n\t\t\t} else if (nlav) {\n\t\t\t\tstruct fib_config cfg2;\n\n\t\t\t\terr = fib_gw_from_via(&cfg2, nlav, extack);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tswitch (nh->fib_nh_gw_family) {\n\t\t\t\tcase AF_INET:\n\t\t\t\t\tif (cfg2.fc_gw_family != AF_INET ||\n\t\t\t\t\t    cfg2.fc_gw4 != nh->fib_nh_gw4)\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase AF_INET6:\n\t\t\t\t\tif (cfg2.fc_gw_family != AF_INET6 ||\n\t\t\t\t\t    ipv6_addr_cmp(&cfg2.fc_gw6,\n\t\t\t\t\t\t\t  &nh->fib_nh_gw6))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\t\t\tnla = nla_find(attrs, attrlen, RTA_FLOW);\n\t\t\tif (nla) {\n\t\t\t\tif (nla_len(nla) < sizeof(u32)) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack, \"Invalid RTA_FLOW\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif (nla_get_u32(nla) != nh->nh_tclassid)\n\t\t\t\t\treturn 1;\n\t\t\t}\n#endif\n\t\t}\n\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t} endfor_nexthops(fi);\n#endif\n\treturn 0;\n}\n\nbool fib_metrics_match(struct fib_config *cfg, struct fib_info *fi)\n{\n\tstruct nlattr *nla;\n\tint remaining;\n\n\tif (!cfg->fc_mx)\n\t\treturn true;\n\n\tnla_for_each_attr(nla, cfg->fc_mx, cfg->fc_mx_len, remaining) {\n\t\tint type = nla_type(nla);\n\t\tu32 fi_val, val;\n\n\t\tif (!type)\n\t\t\tcontinue;\n\t\tif (type > RTAX_MAX)\n\t\t\treturn false;\n\n\t\ttype = array_index_nospec(type, RTAX_MAX + 1);\n\t\tif (type == RTAX_CC_ALGO) {\n\t\t\tchar tmp[TCP_CA_NAME_MAX];\n\t\t\tbool ecn_ca = false;\n\n\t\t\tnla_strscpy(tmp, nla, sizeof(tmp));\n\t\t\tval = tcp_ca_get_key_by_name(fi->fib_net, tmp, &ecn_ca);\n\t\t} else {\n\t\t\tif (nla_len(nla) != sizeof(u32))\n\t\t\t\treturn false;\n\t\t\tval = nla_get_u32(nla);\n\t\t}\n\n\t\tfi_val = fi->fib_metrics->metrics[type - 1];\n\t\tif (type == RTAX_FEATURES)\n\t\t\tfi_val &= ~DST_FEATURE_ECN_CA;\n\n\t\tif (fi_val != val)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int fib_check_nh_v6_gw(struct net *net, struct fib_nh *nh,\n\t\t\t      u32 table, struct netlink_ext_ack *extack)\n{\n\tstruct fib6_config cfg = {\n\t\t.fc_table = table,\n\t\t.fc_flags = nh->fib_nh_flags | RTF_GATEWAY,\n\t\t.fc_ifindex = nh->fib_nh_oif,\n\t\t.fc_gateway = nh->fib_nh_gw6,\n\t};\n\tstruct fib6_nh fib6_nh = {};\n\tint err;\n\n\terr = ipv6_stub->fib6_nh_init(net, &fib6_nh, &cfg, GFP_KERNEL, extack);\n\tif (!err) {\n\t\tnh->fib_nh_dev = fib6_nh.fib_nh_dev;\n\t\tnetdev_hold(nh->fib_nh_dev, &nh->fib_nh_dev_tracker,\n\t\t\t    GFP_KERNEL);\n\t\tnh->fib_nh_oif = nh->fib_nh_dev->ifindex;\n\t\tnh->fib_nh_scope = RT_SCOPE_LINK;\n\n\t\tipv6_stub->fib6_nh_release(&fib6_nh);\n\t}\n\n\treturn err;\n}\n\n \nstatic int fib_check_nh_v4_gw(struct net *net, struct fib_nh *nh, u32 table,\n\t\t\t      u8 scope, struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev;\n\tstruct fib_result res;\n\tint err = 0;\n\n\tif (nh->fib_nh_flags & RTNH_F_ONLINK) {\n\t\tunsigned int addr_type;\n\n\t\tif (scope >= RT_SCOPE_LINK) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop has invalid scope\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev = __dev_get_by_index(net, nh->fib_nh_oif);\n\t\tif (!dev) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop device required for onlink\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!(dev->flags & IFF_UP)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop device is not up\");\n\t\t\treturn -ENETDOWN;\n\t\t}\n\t\taddr_type = inet_addr_type_dev_table(net, dev, nh->fib_nh_gw4);\n\t\tif (addr_type != RTN_UNICAST) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop has invalid gateway\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!netif_carrier_ok(dev))\n\t\t\tnh->fib_nh_flags |= RTNH_F_LINKDOWN;\n\t\tnh->fib_nh_dev = dev;\n\t\tnetdev_hold(dev, &nh->fib_nh_dev_tracker, GFP_ATOMIC);\n\t\tnh->fib_nh_scope = RT_SCOPE_LINK;\n\t\treturn 0;\n\t}\n\trcu_read_lock();\n\t{\n\t\tstruct fib_table *tbl = NULL;\n\t\tstruct flowi4 fl4 = {\n\t\t\t.daddr = nh->fib_nh_gw4,\n\t\t\t.flowi4_scope = scope + 1,\n\t\t\t.flowi4_oif = nh->fib_nh_oif,\n\t\t\t.flowi4_iif = LOOPBACK_IFINDEX,\n\t\t};\n\n\t\t \n\t\tif (fl4.flowi4_scope < RT_SCOPE_LINK)\n\t\t\tfl4.flowi4_scope = RT_SCOPE_LINK;\n\n\t\tif (table && table != RT_TABLE_MAIN)\n\t\t\ttbl = fib_get_table(net, table);\n\n\t\tif (tbl)\n\t\t\terr = fib_table_lookup(tbl, &fl4, &res,\n\t\t\t\t\t       FIB_LOOKUP_IGNORE_LINKSTATE |\n\t\t\t\t\t       FIB_LOOKUP_NOREF);\n\n\t\t \n\t\tif (!tbl || err) {\n\t\t\terr = fib_lookup(net, &fl4, &res,\n\t\t\t\t\t FIB_LOOKUP_IGNORE_LINKSTATE);\n\t\t}\n\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop has invalid gateway\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = -EINVAL;\n\tif (res.type != RTN_UNICAST && res.type != RTN_LOCAL) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop has invalid gateway\");\n\t\tgoto out;\n\t}\n\tnh->fib_nh_scope = res.scope;\n\tnh->fib_nh_oif = FIB_RES_OIF(res);\n\tnh->fib_nh_dev = dev = FIB_RES_DEV(res);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"No egress device for nexthop gateway\");\n\t\tgoto out;\n\t}\n\tnetdev_hold(dev, &nh->fib_nh_dev_tracker, GFP_ATOMIC);\n\tif (!netif_carrier_ok(dev))\n\t\tnh->fib_nh_flags |= RTNH_F_LINKDOWN;\n\terr = (dev->flags & IFF_UP) ? 0 : -ENETDOWN;\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic int fib_check_nh_nongw(struct net *net, struct fib_nh *nh,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct in_device *in_dev;\n\tint err;\n\n\tif (nh->fib_nh_flags & (RTNH_F_PERVASIVE | RTNH_F_ONLINK)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid flags for nexthop - PERVASIVE and ONLINK can not be set\");\n\t\treturn -EINVAL;\n\t}\n\n\trcu_read_lock();\n\n\terr = -ENODEV;\n\tin_dev = inetdev_by_index(net, nh->fib_nh_oif);\n\tif (!in_dev)\n\t\tgoto out;\n\terr = -ENETDOWN;\n\tif (!(in_dev->dev->flags & IFF_UP)) {\n\t\tNL_SET_ERR_MSG(extack, \"Device for nexthop is not up\");\n\t\tgoto out;\n\t}\n\n\tnh->fib_nh_dev = in_dev->dev;\n\tnetdev_hold(nh->fib_nh_dev, &nh->fib_nh_dev_tracker, GFP_ATOMIC);\n\tnh->fib_nh_scope = RT_SCOPE_HOST;\n\tif (!netif_carrier_ok(nh->fib_nh_dev))\n\t\tnh->fib_nh_flags |= RTNH_F_LINKDOWN;\n\terr = 0;\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nint fib_check_nh(struct net *net, struct fib_nh *nh, u32 table, u8 scope,\n\t\t struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tif (nh->fib_nh_gw_family == AF_INET)\n\t\terr = fib_check_nh_v4_gw(net, nh, table, scope, extack);\n\telse if (nh->fib_nh_gw_family == AF_INET6)\n\t\terr = fib_check_nh_v6_gw(net, nh, table, extack);\n\telse\n\t\terr = fib_check_nh_nongw(net, nh, extack);\n\n\treturn err;\n}\n\nstatic struct hlist_head *\nfib_info_laddrhash_bucket(const struct net *net, __be32 val)\n{\n\tu32 slot = hash_32(net_hash_mix(net) ^ (__force u32)val,\n\t\t\t   fib_info_hash_bits);\n\n\treturn &fib_info_laddrhash[slot];\n}\n\nstatic void fib_info_hash_move(struct hlist_head *new_info_hash,\n\t\t\t       struct hlist_head *new_laddrhash,\n\t\t\t       unsigned int new_size)\n{\n\tstruct hlist_head *old_info_hash, *old_laddrhash;\n\tunsigned int old_size = fib_info_hash_size;\n\tunsigned int i;\n\n\tspin_lock_bh(&fib_info_lock);\n\told_info_hash = fib_info_hash;\n\told_laddrhash = fib_info_laddrhash;\n\tfib_info_hash_size = new_size;\n\tfib_info_hash_bits = ilog2(new_size);\n\n\tfor (i = 0; i < old_size; i++) {\n\t\tstruct hlist_head *head = &fib_info_hash[i];\n\t\tstruct hlist_node *n;\n\t\tstruct fib_info *fi;\n\n\t\thlist_for_each_entry_safe(fi, n, head, fib_hash) {\n\t\t\tstruct hlist_head *dest;\n\t\t\tunsigned int new_hash;\n\n\t\t\tnew_hash = fib_info_hashfn(fi);\n\t\t\tdest = &new_info_hash[new_hash];\n\t\t\thlist_add_head(&fi->fib_hash, dest);\n\t\t}\n\t}\n\tfib_info_hash = new_info_hash;\n\n\tfib_info_laddrhash = new_laddrhash;\n\tfor (i = 0; i < old_size; i++) {\n\t\tstruct hlist_head *lhead = &old_laddrhash[i];\n\t\tstruct hlist_node *n;\n\t\tstruct fib_info *fi;\n\n\t\thlist_for_each_entry_safe(fi, n, lhead, fib_lhash) {\n\t\t\tstruct hlist_head *ldest;\n\n\t\t\tldest = fib_info_laddrhash_bucket(fi->fib_net,\n\t\t\t\t\t\t\t  fi->fib_prefsrc);\n\t\t\thlist_add_head(&fi->fib_lhash, ldest);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&fib_info_lock);\n\n\tkvfree(old_info_hash);\n\tkvfree(old_laddrhash);\n}\n\n__be32 fib_info_update_nhc_saddr(struct net *net, struct fib_nh_common *nhc,\n\t\t\t\t unsigned char scope)\n{\n\tstruct fib_nh *nh;\n\t__be32 saddr;\n\n\tif (nhc->nhc_family != AF_INET)\n\t\treturn inet_select_addr(nhc->nhc_dev, 0, scope);\n\n\tnh = container_of(nhc, struct fib_nh, nh_common);\n\tsaddr = inet_select_addr(nh->fib_nh_dev, nh->fib_nh_gw4, scope);\n\n\tWRITE_ONCE(nh->nh_saddr, saddr);\n\tWRITE_ONCE(nh->nh_saddr_genid, atomic_read(&net->ipv4.dev_addr_genid));\n\n\treturn saddr;\n}\n\n__be32 fib_result_prefsrc(struct net *net, struct fib_result *res)\n{\n\tstruct fib_nh_common *nhc = res->nhc;\n\n\tif (res->fi->fib_prefsrc)\n\t\treturn res->fi->fib_prefsrc;\n\n\tif (nhc->nhc_family == AF_INET) {\n\t\tstruct fib_nh *nh;\n\n\t\tnh = container_of(nhc, struct fib_nh, nh_common);\n\t\tif (READ_ONCE(nh->nh_saddr_genid) ==\n\t\t    atomic_read(&net->ipv4.dev_addr_genid))\n\t\t\treturn READ_ONCE(nh->nh_saddr);\n\t}\n\n\treturn fib_info_update_nhc_saddr(net, nhc, res->fi->fib_scope);\n}\n\nstatic bool fib_valid_prefsrc(struct fib_config *cfg, __be32 fib_prefsrc)\n{\n\tif (cfg->fc_type != RTN_LOCAL || !cfg->fc_dst ||\n\t    fib_prefsrc != cfg->fc_dst) {\n\t\tu32 tb_id = cfg->fc_table;\n\t\tint rc;\n\n\t\tif (tb_id == RT_TABLE_MAIN)\n\t\t\ttb_id = RT_TABLE_LOCAL;\n\n\t\trc = inet_addr_type_table(cfg->fc_nlinfo.nl_net,\n\t\t\t\t\t  fib_prefsrc, tb_id);\n\n\t\tif (rc != RTN_LOCAL && tb_id != RT_TABLE_LOCAL) {\n\t\t\trc = inet_addr_type_table(cfg->fc_nlinfo.nl_net,\n\t\t\t\t\t\t  fib_prefsrc, RT_TABLE_LOCAL);\n\t\t}\n\n\t\tif (rc != RTN_LOCAL)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstruct fib_info *fib_create_info(struct fib_config *cfg,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tint err;\n\tstruct fib_info *fi = NULL;\n\tstruct nexthop *nh = NULL;\n\tstruct fib_info *ofi;\n\tint nhs = 1;\n\tstruct net *net = cfg->fc_nlinfo.nl_net;\n\n\tif (cfg->fc_type > RTN_MAX)\n\t\tgoto err_inval;\n\n\t \n\tif (fib_props[cfg->fc_type].scope > cfg->fc_scope) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid scope\");\n\t\tgoto err_inval;\n\t}\n\n\tif (cfg->fc_flags & (RTNH_F_DEAD | RTNH_F_LINKDOWN)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid rtm_flags - can not contain DEAD or LINKDOWN\");\n\t\tgoto err_inval;\n\t}\n\n\tif (cfg->fc_nh_id) {\n\t\tif (!cfg->fc_mx) {\n\t\t\tfi = fib_find_info_nh(net, cfg);\n\t\t\tif (fi) {\n\t\t\t\trefcount_inc(&fi->fib_treeref);\n\t\t\t\treturn fi;\n\t\t\t}\n\t\t}\n\n\t\tnh = nexthop_find_by_id(net, cfg->fc_nh_id);\n\t\tif (!nh) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop id does not exist\");\n\t\t\tgoto err_inval;\n\t\t}\n\t\tnhs = 0;\n\t}\n\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\tif (cfg->fc_mp) {\n\t\tnhs = fib_count_nexthops(cfg->fc_mp, cfg->fc_mp_len, extack);\n\t\tif (nhs == 0)\n\t\t\tgoto err_inval;\n\t}\n#endif\n\n\terr = -ENOBUFS;\n\n\t \n\tif (READ_ONCE(fib_info_cnt) >= fib_info_hash_size) {\n\t\tunsigned int new_size = fib_info_hash_size << 1;\n\t\tstruct hlist_head *new_info_hash;\n\t\tstruct hlist_head *new_laddrhash;\n\t\tsize_t bytes;\n\n\t\tif (!new_size)\n\t\t\tnew_size = 16;\n\t\tbytes = (size_t)new_size * sizeof(struct hlist_head *);\n\t\tnew_info_hash = kvzalloc(bytes, GFP_KERNEL);\n\t\tnew_laddrhash = kvzalloc(bytes, GFP_KERNEL);\n\t\tif (!new_info_hash || !new_laddrhash) {\n\t\t\tkvfree(new_info_hash);\n\t\t\tkvfree(new_laddrhash);\n\t\t} else {\n\t\t\tfib_info_hash_move(new_info_hash, new_laddrhash, new_size);\n\t\t}\n\t\tif (!fib_info_hash_size)\n\t\t\tgoto failure;\n\t}\n\n\tfi = kzalloc(struct_size(fi, fib_nh, nhs), GFP_KERNEL);\n\tif (!fi)\n\t\tgoto failure;\n\tfi->fib_metrics = ip_fib_metrics_init(fi->fib_net, cfg->fc_mx,\n\t\t\t\t\t      cfg->fc_mx_len, extack);\n\tif (IS_ERR(fi->fib_metrics)) {\n\t\terr = PTR_ERR(fi->fib_metrics);\n\t\tkfree(fi);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tfi->fib_net = net;\n\tfi->fib_protocol = cfg->fc_protocol;\n\tfi->fib_scope = cfg->fc_scope;\n\tfi->fib_flags = cfg->fc_flags;\n\tfi->fib_priority = cfg->fc_priority;\n\tfi->fib_prefsrc = cfg->fc_prefsrc;\n\tfi->fib_type = cfg->fc_type;\n\tfi->fib_tb_id = cfg->fc_table;\n\n\tfi->fib_nhs = nhs;\n\tif (nh) {\n\t\tif (!nexthop_get(nh)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop has been deleted\");\n\t\t\terr = -EINVAL;\n\t\t} else {\n\t\t\terr = 0;\n\t\t\tfi->nh = nh;\n\t\t}\n\t} else {\n\t\tchange_nexthops(fi) {\n\t\t\tnexthop_nh->nh_parent = fi;\n\t\t} endfor_nexthops(fi)\n\n\t\tif (cfg->fc_mp)\n\t\t\terr = fib_get_nhs(fi, cfg->fc_mp, cfg->fc_mp_len, cfg,\n\t\t\t\t\t  extack);\n\t\telse\n\t\t\terr = fib_nh_init(net, fi->fib_nh, cfg, 1, extack);\n\t}\n\n\tif (err != 0)\n\t\tgoto failure;\n\n\tif (fib_props[cfg->fc_type].error) {\n\t\tif (cfg->fc_gw_family || cfg->fc_oif || cfg->fc_mp) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Gateway, device and multipath can not be specified for this route type\");\n\t\t\tgoto err_inval;\n\t\t}\n\t\tgoto link_it;\n\t} else {\n\t\tswitch (cfg->fc_type) {\n\t\tcase RTN_UNICAST:\n\t\tcase RTN_LOCAL:\n\t\tcase RTN_BROADCAST:\n\t\tcase RTN_ANYCAST:\n\t\tcase RTN_MULTICAST:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid route type\");\n\t\t\tgoto err_inval;\n\t\t}\n\t}\n\n\tif (cfg->fc_scope > RT_SCOPE_HOST) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid scope\");\n\t\tgoto err_inval;\n\t}\n\n\tif (fi->nh) {\n\t\terr = fib_check_nexthop(fi->nh, cfg->fc_scope, extack);\n\t\tif (err)\n\t\t\tgoto failure;\n\t} else if (cfg->fc_scope == RT_SCOPE_HOST) {\n\t\tstruct fib_nh *nh = fi->fib_nh;\n\n\t\t \n\t\tif (nhs != 1) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Route with host scope can not have multiple nexthops\");\n\t\t\tgoto err_inval;\n\t\t}\n\t\tif (nh->fib_nh_gw_family) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Route with host scope can not have a gateway\");\n\t\t\tgoto err_inval;\n\t\t}\n\t\tnh->fib_nh_scope = RT_SCOPE_NOWHERE;\n\t\tnh->fib_nh_dev = dev_get_by_index(net, nh->fib_nh_oif);\n\t\terr = -ENODEV;\n\t\tif (!nh->fib_nh_dev)\n\t\t\tgoto failure;\n\t\tnetdev_tracker_alloc(nh->fib_nh_dev, &nh->fib_nh_dev_tracker,\n\t\t\t\t     GFP_KERNEL);\n\t} else {\n\t\tint linkdown = 0;\n\n\t\tchange_nexthops(fi) {\n\t\t\terr = fib_check_nh(cfg->fc_nlinfo.nl_net, nexthop_nh,\n\t\t\t\t\t   cfg->fc_table, cfg->fc_scope,\n\t\t\t\t\t   extack);\n\t\t\tif (err != 0)\n\t\t\t\tgoto failure;\n\t\t\tif (nexthop_nh->fib_nh_flags & RTNH_F_LINKDOWN)\n\t\t\t\tlinkdown++;\n\t\t} endfor_nexthops(fi)\n\t\tif (linkdown == fi->fib_nhs)\n\t\t\tfi->fib_flags |= RTNH_F_LINKDOWN;\n\t}\n\n\tif (fi->fib_prefsrc && !fib_valid_prefsrc(cfg, fi->fib_prefsrc)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid prefsrc address\");\n\t\tgoto err_inval;\n\t}\n\n\tif (!fi->nh) {\n\t\tchange_nexthops(fi) {\n\t\t\tfib_info_update_nhc_saddr(net, &nexthop_nh->nh_common,\n\t\t\t\t\t\t  fi->fib_scope);\n\t\t\tif (nexthop_nh->fib_nh_gw_family == AF_INET6)\n\t\t\t\tfi->fib_nh_is_v6 = true;\n\t\t} endfor_nexthops(fi)\n\n\t\tfib_rebalance(fi);\n\t}\n\nlink_it:\n\tofi = fib_find_info(fi);\n\tif (ofi) {\n\t\t \n\t\tfi->fib_dead = 1;\n\t\tfree_fib_info(fi);\n\t\trefcount_inc(&ofi->fib_treeref);\n\t\treturn ofi;\n\t}\n\n\trefcount_set(&fi->fib_treeref, 1);\n\trefcount_set(&fi->fib_clntref, 1);\n\tspin_lock_bh(&fib_info_lock);\n\tfib_info_cnt++;\n\thlist_add_head(&fi->fib_hash,\n\t\t       &fib_info_hash[fib_info_hashfn(fi)]);\n\tif (fi->fib_prefsrc) {\n\t\tstruct hlist_head *head;\n\n\t\thead = fib_info_laddrhash_bucket(net, fi->fib_prefsrc);\n\t\thlist_add_head(&fi->fib_lhash, head);\n\t}\n\tif (fi->nh) {\n\t\tlist_add(&fi->nh_list, &nh->fi_list);\n\t} else {\n\t\tchange_nexthops(fi) {\n\t\t\tstruct hlist_head *head;\n\n\t\t\tif (!nexthop_nh->fib_nh_dev)\n\t\t\t\tcontinue;\n\t\t\thead = fib_info_devhash_bucket(nexthop_nh->fib_nh_dev);\n\t\t\thlist_add_head(&nexthop_nh->nh_hash, head);\n\t\t} endfor_nexthops(fi)\n\t}\n\tspin_unlock_bh(&fib_info_lock);\n\treturn fi;\n\nerr_inval:\n\terr = -EINVAL;\n\nfailure:\n\tif (fi) {\n\t\t \n\t\tfi->fib_dead = 1;\n\t\tfree_fib_info(fi);\n\t}\n\n\treturn ERR_PTR(err);\n}\n\nint fib_nexthop_info(struct sk_buff *skb, const struct fib_nh_common *nhc,\n\t\t     u8 rt_family, unsigned char *flags, bool skip_oif)\n{\n\tif (nhc->nhc_flags & RTNH_F_DEAD)\n\t\t*flags |= RTNH_F_DEAD;\n\n\tif (nhc->nhc_flags & RTNH_F_LINKDOWN) {\n\t\t*flags |= RTNH_F_LINKDOWN;\n\n\t\trcu_read_lock();\n\t\tswitch (nhc->nhc_family) {\n\t\tcase AF_INET:\n\t\t\tif (ip_ignore_linkdown(nhc->nhc_dev))\n\t\t\t\t*flags |= RTNH_F_DEAD;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tif (ip6_ignore_linkdown(nhc->nhc_dev))\n\t\t\t\t*flags |= RTNH_F_DEAD;\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tswitch (nhc->nhc_gw_family) {\n\tcase AF_INET:\n\t\tif (nla_put_in_addr(skb, RTA_GATEWAY, nhc->nhc_gw.ipv4))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase AF_INET6:\n\t\t \n\t\tif (rt_family != nhc->nhc_gw_family) {\n\t\t\tint alen = sizeof(struct in6_addr);\n\t\t\tstruct nlattr *nla;\n\t\t\tstruct rtvia *via;\n\n\t\t\tnla = nla_reserve(skb, RTA_VIA, alen + 2);\n\t\t\tif (!nla)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tvia = nla_data(nla);\n\t\t\tvia->rtvia_family = AF_INET6;\n\t\t\tmemcpy(via->rtvia_addr, &nhc->nhc_gw.ipv6, alen);\n\t\t} else if (nla_put_in6_addr(skb, RTA_GATEWAY,\n\t\t\t\t\t    &nhc->nhc_gw.ipv6) < 0) {\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tbreak;\n\t}\n\n\t*flags |= (nhc->nhc_flags &\n\t\t   (RTNH_F_ONLINK | RTNH_F_OFFLOAD | RTNH_F_TRAP));\n\n\tif (!skip_oif && nhc->nhc_dev &&\n\t    nla_put_u32(skb, RTA_OIF, nhc->nhc_dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nhc->nhc_lwtstate &&\n\t    lwtunnel_fill_encap(skb, nhc->nhc_lwtstate,\n\t\t\t\tRTA_ENCAP, RTA_ENCAP_TYPE) < 0)\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL_GPL(fib_nexthop_info);\n\n#if IS_ENABLED(CONFIG_IP_ROUTE_MULTIPATH) || IS_ENABLED(CONFIG_IPV6)\nint fib_add_nexthop(struct sk_buff *skb, const struct fib_nh_common *nhc,\n\t\t    int nh_weight, u8 rt_family, u32 nh_tclassid)\n{\n\tconst struct net_device *dev = nhc->nhc_dev;\n\tstruct rtnexthop *rtnh;\n\tunsigned char flags = 0;\n\n\trtnh = nla_reserve_nohdr(skb, sizeof(*rtnh));\n\tif (!rtnh)\n\t\tgoto nla_put_failure;\n\n\trtnh->rtnh_hops = nh_weight - 1;\n\trtnh->rtnh_ifindex = dev ? dev->ifindex : 0;\n\n\tif (fib_nexthop_info(skb, nhc, rt_family, &flags, true) < 0)\n\t\tgoto nla_put_failure;\n\n\trtnh->rtnh_flags = flags;\n\n\tif (nh_tclassid && nla_put_u32(skb, RTA_FLOW, nh_tclassid))\n\t\tgoto nla_put_failure;\n\n\t \n\trtnh->rtnh_len = nlmsg_get_pos(skb) - (void *)rtnh;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL_GPL(fib_add_nexthop);\n#endif\n\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\nstatic int fib_add_multipath(struct sk_buff *skb, struct fib_info *fi)\n{\n\tstruct nlattr *mp;\n\n\tmp = nla_nest_start_noflag(skb, RTA_MULTIPATH);\n\tif (!mp)\n\t\tgoto nla_put_failure;\n\n\tif (unlikely(fi->nh)) {\n\t\tif (nexthop_mpath_fill_node(skb, fi->nh, AF_INET) < 0)\n\t\t\tgoto nla_put_failure;\n\t\tgoto mp_end;\n\t}\n\n\tfor_nexthops(fi) {\n\t\tu32 nh_tclassid = 0;\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\t\tnh_tclassid = nh->nh_tclassid;\n#endif\n\t\tif (fib_add_nexthop(skb, &nh->nh_common, nh->fib_nh_weight,\n\t\t\t\t    AF_INET, nh_tclassid) < 0)\n\t\t\tgoto nla_put_failure;\n\t} endfor_nexthops(fi);\n\nmp_end:\n\tnla_nest_end(skb, mp);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n#else\nstatic int fib_add_multipath(struct sk_buff *skb, struct fib_info *fi)\n{\n\treturn 0;\n}\n#endif\n\nint fib_dump_info(struct sk_buff *skb, u32 portid, u32 seq, int event,\n\t\t  const struct fib_rt_info *fri, unsigned int flags)\n{\n\tunsigned int nhs = fib_info_num_path(fri->fi);\n\tstruct fib_info *fi = fri->fi;\n\tu32 tb_id = fri->tb_id;\n\tstruct nlmsghdr *nlh;\n\tstruct rtmsg *rtm;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*rtm), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\trtm = nlmsg_data(nlh);\n\trtm->rtm_family = AF_INET;\n\trtm->rtm_dst_len = fri->dst_len;\n\trtm->rtm_src_len = 0;\n\trtm->rtm_tos = inet_dscp_to_dsfield(fri->dscp);\n\tif (tb_id < 256)\n\t\trtm->rtm_table = tb_id;\n\telse\n\t\trtm->rtm_table = RT_TABLE_COMPAT;\n\tif (nla_put_u32(skb, RTA_TABLE, tb_id))\n\t\tgoto nla_put_failure;\n\trtm->rtm_type = fri->type;\n\trtm->rtm_flags = fi->fib_flags;\n\trtm->rtm_scope = fi->fib_scope;\n\trtm->rtm_protocol = fi->fib_protocol;\n\n\tif (rtm->rtm_dst_len &&\n\t    nla_put_in_addr(skb, RTA_DST, fri->dst))\n\t\tgoto nla_put_failure;\n\tif (fi->fib_priority &&\n\t    nla_put_u32(skb, RTA_PRIORITY, fi->fib_priority))\n\t\tgoto nla_put_failure;\n\tif (rtnetlink_put_metrics(skb, fi->fib_metrics->metrics) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (fi->fib_prefsrc &&\n\t    nla_put_in_addr(skb, RTA_PREFSRC, fi->fib_prefsrc))\n\t\tgoto nla_put_failure;\n\n\tif (fi->nh) {\n\t\tif (nla_put_u32(skb, RTA_NH_ID, fi->nh->id))\n\t\t\tgoto nla_put_failure;\n\t\tif (nexthop_is_blackhole(fi->nh))\n\t\t\trtm->rtm_type = RTN_BLACKHOLE;\n\t\tif (!READ_ONCE(fi->fib_net->ipv4.sysctl_nexthop_compat_mode))\n\t\t\tgoto offload;\n\t}\n\n\tif (nhs == 1) {\n\t\tconst struct fib_nh_common *nhc = fib_info_nhc(fi, 0);\n\t\tunsigned char flags = 0;\n\n\t\tif (fib_nexthop_info(skb, nhc, AF_INET, &flags, false) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\trtm->rtm_flags = flags;\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\t\tif (nhc->nhc_family == AF_INET) {\n\t\t\tstruct fib_nh *nh;\n\n\t\t\tnh = container_of(nhc, struct fib_nh, nh_common);\n\t\t\tif (nh->nh_tclassid &&\n\t\t\t    nla_put_u32(skb, RTA_FLOW, nh->nh_tclassid))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n#endif\n\t} else {\n\t\tif (fib_add_multipath(skb, fi) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\noffload:\n\tif (fri->offload)\n\t\trtm->rtm_flags |= RTM_F_OFFLOAD;\n\tif (fri->trap)\n\t\trtm->rtm_flags |= RTM_F_TRAP;\n\tif (fri->offload_failed)\n\t\trtm->rtm_flags |= RTM_F_OFFLOAD_FAILED;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\n \nint fib_sync_down_addr(struct net_device *dev, __be32 local)\n{\n\tint tb_id = l3mdev_fib_table(dev) ? : RT_TABLE_MAIN;\n\tstruct net *net = dev_net(dev);\n\tstruct hlist_head *head;\n\tstruct fib_info *fi;\n\tint ret = 0;\n\n\tif (!fib_info_laddrhash || local == 0)\n\t\treturn 0;\n\n\thead = fib_info_laddrhash_bucket(net, local);\n\thlist_for_each_entry(fi, head, fib_lhash) {\n\t\tif (!net_eq(fi->fib_net, net) ||\n\t\t    fi->fib_tb_id != tb_id)\n\t\t\tcontinue;\n\t\tif (fi->fib_prefsrc == local) {\n\t\t\tfi->fib_flags |= RTNH_F_DEAD;\n\t\t\tfi->pfsrc_removed = true;\n\t\t\tret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int call_fib_nh_notifiers(struct fib_nh *nh,\n\t\t\t\t enum fib_event_type event_type)\n{\n\tbool ignore_link_down = ip_ignore_linkdown(nh->fib_nh_dev);\n\tstruct fib_nh_notifier_info info = {\n\t\t.fib_nh = nh,\n\t};\n\n\tswitch (event_type) {\n\tcase FIB_EVENT_NH_ADD:\n\t\tif (nh->fib_nh_flags & RTNH_F_DEAD)\n\t\t\tbreak;\n\t\tif (ignore_link_down && nh->fib_nh_flags & RTNH_F_LINKDOWN)\n\t\t\tbreak;\n\t\treturn call_fib4_notifiers(dev_net(nh->fib_nh_dev), event_type,\n\t\t\t\t\t   &info.info);\n\tcase FIB_EVENT_NH_DEL:\n\t\tif ((ignore_link_down && nh->fib_nh_flags & RTNH_F_LINKDOWN) ||\n\t\t    (nh->fib_nh_flags & RTNH_F_DEAD))\n\t\t\treturn call_fib4_notifiers(dev_net(nh->fib_nh_dev),\n\t\t\t\t\t\t   event_type, &info.info);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nvoid fib_nhc_update_mtu(struct fib_nh_common *nhc, u32 new, u32 orig)\n{\n\tstruct fnhe_hash_bucket *bucket;\n\tint i;\n\n\tbucket = rcu_dereference_protected(nhc->nhc_exceptions, 1);\n\tif (!bucket)\n\t\treturn;\n\n\tfor (i = 0; i < FNHE_HASH_SIZE; i++) {\n\t\tstruct fib_nh_exception *fnhe;\n\n\t\tfor (fnhe = rcu_dereference_protected(bucket[i].chain, 1);\n\t\t     fnhe;\n\t\t     fnhe = rcu_dereference_protected(fnhe->fnhe_next, 1)) {\n\t\t\tif (fnhe->fnhe_mtu_locked) {\n\t\t\t\tif (new <= fnhe->fnhe_pmtu) {\n\t\t\t\t\tfnhe->fnhe_pmtu = new;\n\t\t\t\t\tfnhe->fnhe_mtu_locked = false;\n\t\t\t\t}\n\t\t\t} else if (new < fnhe->fnhe_pmtu ||\n\t\t\t\t   orig == fnhe->fnhe_pmtu) {\n\t\t\t\tfnhe->fnhe_pmtu = new;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid fib_sync_mtu(struct net_device *dev, u32 orig_mtu)\n{\n\tstruct hlist_head *head = fib_info_devhash_bucket(dev);\n\tstruct fib_nh *nh;\n\n\thlist_for_each_entry(nh, head, nh_hash) {\n\t\tif (nh->fib_nh_dev == dev)\n\t\t\tfib_nhc_update_mtu(&nh->nh_common, dev->mtu, orig_mtu);\n\t}\n}\n\n \nint fib_sync_down_dev(struct net_device *dev, unsigned long event, bool force)\n{\n\tstruct hlist_head *head = fib_info_devhash_bucket(dev);\n\tstruct fib_info *prev_fi = NULL;\n\tint scope = RT_SCOPE_NOWHERE;\n\tstruct fib_nh *nh;\n\tint ret = 0;\n\n\tif (force)\n\t\tscope = -1;\n\n\thlist_for_each_entry(nh, head, nh_hash) {\n\t\tstruct fib_info *fi = nh->nh_parent;\n\t\tint dead;\n\n\t\tBUG_ON(!fi->fib_nhs);\n\t\tif (nh->fib_nh_dev != dev || fi == prev_fi)\n\t\t\tcontinue;\n\t\tprev_fi = fi;\n\t\tdead = 0;\n\t\tchange_nexthops(fi) {\n\t\t\tif (nexthop_nh->fib_nh_flags & RTNH_F_DEAD)\n\t\t\t\tdead++;\n\t\t\telse if (nexthop_nh->fib_nh_dev == dev &&\n\t\t\t\t nexthop_nh->fib_nh_scope != scope) {\n\t\t\t\tswitch (event) {\n\t\t\t\tcase NETDEV_DOWN:\n\t\t\t\tcase NETDEV_UNREGISTER:\n\t\t\t\t\tnexthop_nh->fib_nh_flags |= RTNH_F_DEAD;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase NETDEV_CHANGE:\n\t\t\t\t\tnexthop_nh->fib_nh_flags |= RTNH_F_LINKDOWN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcall_fib_nh_notifiers(nexthop_nh,\n\t\t\t\t\t\t      FIB_EVENT_NH_DEL);\n\t\t\t\tdead++;\n\t\t\t}\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\t\t\tif (event == NETDEV_UNREGISTER &&\n\t\t\t    nexthop_nh->fib_nh_dev == dev) {\n\t\t\t\tdead = fi->fib_nhs;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t} endfor_nexthops(fi)\n\t\tif (dead == fi->fib_nhs) {\n\t\t\tswitch (event) {\n\t\t\tcase NETDEV_DOWN:\n\t\t\tcase NETDEV_UNREGISTER:\n\t\t\t\tfi->fib_flags |= RTNH_F_DEAD;\n\t\t\t\tfallthrough;\n\t\t\tcase NETDEV_CHANGE:\n\t\t\t\tfi->fib_flags |= RTNH_F_LINKDOWN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret++;\n\t\t}\n\n\t\tfib_rebalance(fi);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void fib_select_default(const struct flowi4 *flp, struct fib_result *res)\n{\n\tstruct fib_info *fi = NULL, *last_resort = NULL;\n\tstruct hlist_head *fa_head = res->fa_head;\n\tstruct fib_table *tb = res->table;\n\tu8 slen = 32 - res->prefixlen;\n\tint order = -1, last_idx = -1;\n\tstruct fib_alias *fa, *fa1 = NULL;\n\tu32 last_prio = res->fi->fib_priority;\n\tdscp_t last_dscp = 0;\n\n\thlist_for_each_entry_rcu(fa, fa_head, fa_list) {\n\t\tstruct fib_info *next_fi = fa->fa_info;\n\t\tstruct fib_nh_common *nhc;\n\n\t\tif (fa->fa_slen != slen)\n\t\t\tcontinue;\n\t\tif (fa->fa_dscp &&\n\t\t    fa->fa_dscp != inet_dsfield_to_dscp(flp->flowi4_tos))\n\t\t\tcontinue;\n\t\tif (fa->tb_id != tb->tb_id)\n\t\t\tcontinue;\n\t\tif (next_fi->fib_priority > last_prio &&\n\t\t    fa->fa_dscp == last_dscp) {\n\t\t\tif (last_dscp)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tif (next_fi->fib_flags & RTNH_F_DEAD)\n\t\t\tcontinue;\n\t\tlast_dscp = fa->fa_dscp;\n\t\tlast_prio = next_fi->fib_priority;\n\n\t\tif (next_fi->fib_scope != res->scope ||\n\t\t    fa->fa_type != RTN_UNICAST)\n\t\t\tcontinue;\n\n\t\tnhc = fib_info_nhc(next_fi, 0);\n\t\tif (!nhc->nhc_gw_family || nhc->nhc_scope != RT_SCOPE_LINK)\n\t\t\tcontinue;\n\n\t\tfib_alias_accessed(fa);\n\n\t\tif (!fi) {\n\t\t\tif (next_fi != res->fi)\n\t\t\t\tbreak;\n\t\t\tfa1 = fa;\n\t\t} else if (!fib_detect_death(fi, order, &last_resort,\n\t\t\t\t\t     &last_idx, fa1->fa_default)) {\n\t\t\tfib_result_assign(res, fi);\n\t\t\tfa1->fa_default = order;\n\t\t\tgoto out;\n\t\t}\n\t\tfi = next_fi;\n\t\torder++;\n\t}\n\n\tif (order <= 0 || !fi) {\n\t\tif (fa1)\n\t\t\tfa1->fa_default = -1;\n\t\tgoto out;\n\t}\n\n\tif (!fib_detect_death(fi, order, &last_resort, &last_idx,\n\t\t\t      fa1->fa_default)) {\n\t\tfib_result_assign(res, fi);\n\t\tfa1->fa_default = order;\n\t\tgoto out;\n\t}\n\n\tif (last_idx >= 0)\n\t\tfib_result_assign(res, last_resort);\n\tfa1->fa_default = last_idx;\nout:\n\treturn;\n}\n\n \nint fib_sync_up(struct net_device *dev, unsigned char nh_flags)\n{\n\tstruct fib_info *prev_fi;\n\tstruct hlist_head *head;\n\tstruct fib_nh *nh;\n\tint ret;\n\n\tif (!(dev->flags & IFF_UP))\n\t\treturn 0;\n\n\tif (nh_flags & RTNH_F_DEAD) {\n\t\tunsigned int flags = dev_get_flags(dev);\n\n\t\tif (flags & (IFF_RUNNING | IFF_LOWER_UP))\n\t\t\tnh_flags |= RTNH_F_LINKDOWN;\n\t}\n\n\tprev_fi = NULL;\n\thead = fib_info_devhash_bucket(dev);\n\tret = 0;\n\n\thlist_for_each_entry(nh, head, nh_hash) {\n\t\tstruct fib_info *fi = nh->nh_parent;\n\t\tint alive;\n\n\t\tBUG_ON(!fi->fib_nhs);\n\t\tif (nh->fib_nh_dev != dev || fi == prev_fi)\n\t\t\tcontinue;\n\n\t\tprev_fi = fi;\n\t\talive = 0;\n\t\tchange_nexthops(fi) {\n\t\t\tif (!(nexthop_nh->fib_nh_flags & nh_flags)) {\n\t\t\t\talive++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!nexthop_nh->fib_nh_dev ||\n\t\t\t    !(nexthop_nh->fib_nh_dev->flags & IFF_UP))\n\t\t\t\tcontinue;\n\t\t\tif (nexthop_nh->fib_nh_dev != dev ||\n\t\t\t    !__in_dev_get_rtnl(dev))\n\t\t\t\tcontinue;\n\t\t\talive++;\n\t\t\tnexthop_nh->fib_nh_flags &= ~nh_flags;\n\t\t\tcall_fib_nh_notifiers(nexthop_nh, FIB_EVENT_NH_ADD);\n\t\t} endfor_nexthops(fi)\n\n\t\tif (alive > 0) {\n\t\t\tfi->fib_flags &= ~nh_flags;\n\t\t\tret++;\n\t\t}\n\n\t\tfib_rebalance(fi);\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\nstatic bool fib_good_nh(const struct fib_nh *nh)\n{\n\tint state = NUD_REACHABLE;\n\n\tif (nh->fib_nh_scope == RT_SCOPE_LINK) {\n\t\tstruct neighbour *n;\n\n\t\trcu_read_lock();\n\n\t\tif (likely(nh->fib_nh_gw_family == AF_INET))\n\t\t\tn = __ipv4_neigh_lookup_noref(nh->fib_nh_dev,\n\t\t\t\t\t\t   (__force u32)nh->fib_nh_gw4);\n\t\telse if (nh->fib_nh_gw_family == AF_INET6)\n\t\t\tn = __ipv6_neigh_lookup_noref_stub(nh->fib_nh_dev,\n\t\t\t\t\t\t\t   &nh->fib_nh_gw6);\n\t\telse\n\t\t\tn = NULL;\n\t\tif (n)\n\t\t\tstate = READ_ONCE(n->nud_state);\n\n\t\trcu_read_unlock();\n\t}\n\n\treturn !!(state & NUD_VALID);\n}\n\nvoid fib_select_multipath(struct fib_result *res, int hash)\n{\n\tstruct fib_info *fi = res->fi;\n\tstruct net *net = fi->fib_net;\n\tbool first = false;\n\n\tif (unlikely(res->fi->nh)) {\n\t\tnexthop_path_fib_result(res, hash);\n\t\treturn;\n\t}\n\n\tchange_nexthops(fi) {\n\t\tif (READ_ONCE(net->ipv4.sysctl_fib_multipath_use_neigh)) {\n\t\t\tif (!fib_good_nh(nexthop_nh))\n\t\t\t\tcontinue;\n\t\t\tif (!first) {\n\t\t\t\tres->nh_sel = nhsel;\n\t\t\t\tres->nhc = &nexthop_nh->nh_common;\n\t\t\t\tfirst = true;\n\t\t\t}\n\t\t}\n\n\t\tif (hash > atomic_read(&nexthop_nh->fib_nh_upper_bound))\n\t\t\tcontinue;\n\n\t\tres->nh_sel = nhsel;\n\t\tres->nhc = &nexthop_nh->nh_common;\n\t\treturn;\n\t} endfor_nexthops(fi);\n}\n#endif\n\nvoid fib_select_path(struct net *net, struct fib_result *res,\n\t\t     struct flowi4 *fl4, const struct sk_buff *skb)\n{\n\tif (fl4->flowi4_oif)\n\t\tgoto check_saddr;\n\n#ifdef CONFIG_IP_ROUTE_MULTIPATH\n\tif (fib_info_num_path(res->fi) > 1) {\n\t\tint h = fib_multipath_hash(net, fl4, skb, NULL);\n\n\t\tfib_select_multipath(res, h);\n\t}\n\telse\n#endif\n\tif (!res->prefixlen &&\n\t    res->table->tb_num_default > 1 &&\n\t    res->type == RTN_UNICAST)\n\t\tfib_select_default(fl4, res);\n\ncheck_saddr:\n\tif (!fl4->saddr)\n\t\tfl4->saddr = fib_result_prefsrc(net, res);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}