{
  "module_name": "nf_reject_ipv4.c",
  "hash_id": "959db56b89ac3a3394c6978642d6efc48398aba9801cd68d828bda2cd2e100a8",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter/nf_reject_ipv4.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <net/ip.h>\n#include <net/tcp.h>\n#include <net/route.h>\n#include <net/dst.h>\n#include <net/netfilter/ipv4/nf_reject.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_bridge.h>\n\nstatic int nf_reject_iphdr_validate(struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tu32 len;\n\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\treturn 0;\n\n\tiph = ip_hdr(skb);\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\treturn 0;\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len)\n\t\treturn 0;\n\telse if (len < (iph->ihl*4))\n\t\treturn 0;\n\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstruct sk_buff *nf_reject_skb_v4_tcp_reset(struct net *net,\n\t\t\t\t\t   struct sk_buff *oldskb,\n\t\t\t\t\t   const struct net_device *dev,\n\t\t\t\t\t   int hook)\n{\n\tconst struct tcphdr *oth;\n\tstruct sk_buff *nskb;\n\tstruct iphdr *niph;\n\tstruct tcphdr _oth;\n\n\tif (!nf_reject_iphdr_validate(oldskb))\n\t\treturn NULL;\n\n\toth = nf_reject_ip_tcphdr_get(oldskb, &_oth, hook);\n\tif (!oth)\n\t\treturn NULL;\n\n\tnskb = alloc_skb(sizeof(struct iphdr) + sizeof(struct tcphdr) +\n\t\t\t LL_MAX_HEADER, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn NULL;\n\n\tnskb->dev = (struct net_device *)dev;\n\n\tskb_reserve(nskb, LL_MAX_HEADER);\n\tniph = nf_reject_iphdr_put(nskb, oldskb, IPPROTO_TCP,\n\t\t\t\t   READ_ONCE(net->ipv4.sysctl_ip_default_ttl));\n\tnf_reject_ip_tcphdr_put(nskb, oldskb, oth);\n\tniph->tot_len = htons(nskb->len);\n\tip_send_check(niph);\n\n\treturn nskb;\n}\nEXPORT_SYMBOL_GPL(nf_reject_skb_v4_tcp_reset);\n\nstruct sk_buff *nf_reject_skb_v4_unreach(struct net *net,\n\t\t\t\t\t struct sk_buff *oldskb,\n\t\t\t\t\t const struct net_device *dev,\n\t\t\t\t\t int hook, u8 code)\n{\n\tstruct sk_buff *nskb;\n\tstruct iphdr *niph;\n\tstruct icmphdr *icmph;\n\tunsigned int len;\n\tint dataoff;\n\t__wsum csum;\n\tu8 proto;\n\n\tif (!nf_reject_iphdr_validate(oldskb))\n\t\treturn NULL;\n\n\t \n\tif (ip_hdr(oldskb)->frag_off & htons(IP_OFFSET))\n\t\treturn NULL;\n\n\t \n\tlen = min_t(unsigned int, 536, oldskb->len);\n\n\tif (!pskb_may_pull(oldskb, len))\n\t\treturn NULL;\n\n\tif (pskb_trim_rcsum(oldskb, ntohs(ip_hdr(oldskb)->tot_len)))\n\t\treturn NULL;\n\n\tdataoff = ip_hdrlen(oldskb);\n\tproto = ip_hdr(oldskb)->protocol;\n\n\tif (!skb_csum_unnecessary(oldskb) &&\n\t    nf_reject_verify_csum(oldskb, dataoff, proto) &&\n\t    nf_ip_checksum(oldskb, hook, ip_hdrlen(oldskb), proto))\n\t\treturn NULL;\n\n\tnskb = alloc_skb(sizeof(struct iphdr) + sizeof(struct icmphdr) +\n\t\t\t LL_MAX_HEADER + len, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn NULL;\n\n\tnskb->dev = (struct net_device *)dev;\n\n\tskb_reserve(nskb, LL_MAX_HEADER);\n\tniph = nf_reject_iphdr_put(nskb, oldskb, IPPROTO_ICMP,\n\t\t\t\t   READ_ONCE(net->ipv4.sysctl_ip_default_ttl));\n\n\tskb_reset_transport_header(nskb);\n\ticmph = skb_put_zero(nskb, sizeof(struct icmphdr));\n\ticmph->type     = ICMP_DEST_UNREACH;\n\ticmph->code\t= code;\n\n\tskb_put_data(nskb, skb_network_header(oldskb), len);\n\n\tcsum = csum_partial((void *)icmph, len + sizeof(struct icmphdr), 0);\n\ticmph->checksum = csum_fold(csum);\n\n\tniph->tot_len\t= htons(nskb->len);\n\tip_send_check(niph);\n\n\treturn nskb;\n}\nEXPORT_SYMBOL_GPL(nf_reject_skb_v4_unreach);\n\nconst struct tcphdr *nf_reject_ip_tcphdr_get(struct sk_buff *oldskb,\n\t\t\t\t\t     struct tcphdr *_oth, int hook)\n{\n\tconst struct tcphdr *oth;\n\n\t \n\tif (ip_hdr(oldskb)->frag_off & htons(IP_OFFSET))\n\t\treturn NULL;\n\n\tif (ip_hdr(oldskb)->protocol != IPPROTO_TCP)\n\t\treturn NULL;\n\n\toth = skb_header_pointer(oldskb, ip_hdrlen(oldskb),\n\t\t\t\t sizeof(struct tcphdr), _oth);\n\tif (oth == NULL)\n\t\treturn NULL;\n\n\t \n\tif (oth->rst)\n\t\treturn NULL;\n\n\t \n\tif (nf_ip_checksum(oldskb, hook, ip_hdrlen(oldskb), IPPROTO_TCP))\n\t\treturn NULL;\n\n\treturn oth;\n}\nEXPORT_SYMBOL_GPL(nf_reject_ip_tcphdr_get);\n\nstruct iphdr *nf_reject_iphdr_put(struct sk_buff *nskb,\n\t\t\t\t  const struct sk_buff *oldskb,\n\t\t\t\t  __u8 protocol, int ttl)\n{\n\tstruct iphdr *niph, *oiph = ip_hdr(oldskb);\n\n\tskb_reset_network_header(nskb);\n\tniph = skb_put(nskb, sizeof(struct iphdr));\n\tniph->version\t= 4;\n\tniph->ihl\t= sizeof(struct iphdr) / 4;\n\tniph->tos\t= 0;\n\tniph->id\t= 0;\n\tniph->frag_off\t= htons(IP_DF);\n\tniph->protocol\t= protocol;\n\tniph->check\t= 0;\n\tniph->saddr\t= oiph->daddr;\n\tniph->daddr\t= oiph->saddr;\n\tniph->ttl\t= ttl;\n\n\tnskb->protocol = htons(ETH_P_IP);\n\n\treturn niph;\n}\nEXPORT_SYMBOL_GPL(nf_reject_iphdr_put);\n\nvoid nf_reject_ip_tcphdr_put(struct sk_buff *nskb, const struct sk_buff *oldskb,\n\t\t\t  const struct tcphdr *oth)\n{\n\tstruct iphdr *niph = ip_hdr(nskb);\n\tstruct tcphdr *tcph;\n\n\tskb_reset_transport_header(nskb);\n\ttcph = skb_put_zero(nskb, sizeof(struct tcphdr));\n\ttcph->source\t= oth->dest;\n\ttcph->dest\t= oth->source;\n\ttcph->doff\t= sizeof(struct tcphdr) / 4;\n\n\tif (oth->ack) {\n\t\ttcph->seq = oth->ack_seq;\n\t} else {\n\t\ttcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn + oth->fin +\n\t\t\t\t      oldskb->len - ip_hdrlen(oldskb) -\n\t\t\t\t      (oth->doff << 2));\n\t\ttcph->ack = 1;\n\t}\n\n\ttcph->rst\t= 1;\n\ttcph->check = ~tcp_v4_check(sizeof(struct tcphdr), niph->saddr,\n\t\t\t\t    niph->daddr, 0);\n\tnskb->ip_summed = CHECKSUM_PARTIAL;\n\tnskb->csum_start = (unsigned char *)tcph - nskb->head;\n\tnskb->csum_offset = offsetof(struct tcphdr, check);\n}\nEXPORT_SYMBOL_GPL(nf_reject_ip_tcphdr_put);\n\nstatic int nf_reject_fill_skb_dst(struct sk_buff *skb_in)\n{\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi fl;\n\n\tmemset(&fl, 0, sizeof(struct flowi));\n\tfl.u.ip4.daddr = ip_hdr(skb_in)->saddr;\n\tnf_ip_route(dev_net(skb_in->dev), &dst, &fl, false);\n\tif (!dst)\n\t\treturn -1;\n\n\tskb_dst_set(skb_in, dst);\n\treturn 0;\n}\n\n \nvoid nf_send_reset(struct net *net, struct sock *sk, struct sk_buff *oldskb,\n\t\t   int hook)\n{\n\tstruct sk_buff *nskb;\n\tstruct iphdr *niph;\n\tconst struct tcphdr *oth;\n\tstruct tcphdr _oth;\n\n\toth = nf_reject_ip_tcphdr_get(oldskb, &_oth, hook);\n\tif (!oth)\n\t\treturn;\n\n\tif ((hook == NF_INET_PRE_ROUTING || hook == NF_INET_INGRESS) &&\n\t    nf_reject_fill_skb_dst(oldskb) < 0)\n\t\treturn;\n\n\tif (skb_rtable(oldskb)->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\treturn;\n\n\tnskb = alloc_skb(sizeof(struct iphdr) + sizeof(struct tcphdr) +\n\t\t\t LL_MAX_HEADER, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn;\n\n\t \n\tskb_dst_set_noref(nskb, skb_dst(oldskb));\n\n\tnskb->mark = IP4_REPLY_MARK(net, oldskb->mark);\n\n\tskb_reserve(nskb, LL_MAX_HEADER);\n\tniph = nf_reject_iphdr_put(nskb, oldskb, IPPROTO_TCP,\n\t\t\t\t   ip4_dst_hoplimit(skb_dst(nskb)));\n\tnf_reject_ip_tcphdr_put(nskb, oldskb, oth);\n\tif (ip_route_me_harder(net, sk, nskb, RTN_UNSPEC))\n\t\tgoto free_nskb;\n\n\tniph = ip_hdr(nskb);\n\n\t \n\tif (nskb->len > dst_mtu(skb_dst(nskb)))\n\t\tgoto free_nskb;\n\n\tnf_ct_attach(nskb, oldskb);\n\tnf_ct_set_closing(skb_nfct(oldskb));\n\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\t \n\tif (nf_bridge_info_exists(oldskb)) {\n\t\tstruct ethhdr *oeth = eth_hdr(oldskb);\n\t\tstruct net_device *br_indev;\n\n\t\tbr_indev = nf_bridge_get_physindev(oldskb, net);\n\t\tif (!br_indev)\n\t\t\tgoto free_nskb;\n\n\t\tnskb->dev = br_indev;\n\t\tniph->tot_len = htons(nskb->len);\n\t\tip_send_check(niph);\n\t\tif (dev_hard_header(nskb, nskb->dev, ntohs(nskb->protocol),\n\t\t\t\t    oeth->h_source, oeth->h_dest, nskb->len) < 0)\n\t\t\tgoto free_nskb;\n\t\tdev_queue_xmit(nskb);\n\t} else\n#endif\n\t\tip_local_out(net, nskb->sk, nskb);\n\n\treturn;\n\n free_nskb:\n\tkfree_skb(nskb);\n}\nEXPORT_SYMBOL_GPL(nf_send_reset);\n\nvoid nf_send_unreach(struct sk_buff *skb_in, int code, int hook)\n{\n\tstruct iphdr *iph = ip_hdr(skb_in);\n\tint dataoff = ip_hdrlen(skb_in);\n\tu8 proto = iph->protocol;\n\n\tif (iph->frag_off & htons(IP_OFFSET))\n\t\treturn;\n\n\tif ((hook == NF_INET_PRE_ROUTING || hook == NF_INET_INGRESS) &&\n\t    nf_reject_fill_skb_dst(skb_in) < 0)\n\t\treturn;\n\n\tif (skb_csum_unnecessary(skb_in) ||\n\t    !nf_reject_verify_csum(skb_in, dataoff, proto)) {\n\t\ticmp_send(skb_in, ICMP_DEST_UNREACH, code, 0);\n\t\treturn;\n\t}\n\n\tif (nf_ip_checksum(skb_in, hook, dataoff, proto) == 0)\n\t\ticmp_send(skb_in, ICMP_DEST_UNREACH, code, 0);\n}\nEXPORT_SYMBOL_GPL(nf_send_unreach);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}