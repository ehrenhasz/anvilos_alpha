{
  "module_name": "arp_tables.c",
  "hash_id": "526ac457394836bb8c701e28bdb5eb5e076f3778107456894f8a152eb53318b9",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter/arp_tables.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/capability.h>\n#include <linux/if_arp.h>\n#include <linux/kmod.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <net/compat.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_arp/arp_tables.h>\n#include \"../../netfilter/xt_repldata.h\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David S. Miller <davem@redhat.com>\");\nMODULE_DESCRIPTION(\"arptables core\");\n\nvoid *arpt_alloc_initial_table(const struct xt_table *info)\n{\n\treturn xt_alloc_initial_table(arpt, ARPT);\n}\nEXPORT_SYMBOL_GPL(arpt_alloc_initial_table);\n\nstatic inline int arp_devaddr_compare(const struct arpt_devaddr_info *ap,\n\t\t\t\t      const char *hdr_addr, int len)\n{\n\tint i, ret;\n\n\tif (len > ARPT_DEV_ADDR_LEN_MAX)\n\t\tlen = ARPT_DEV_ADDR_LEN_MAX;\n\n\tret = 0;\n\tfor (i = 0; i < len; i++)\n\t\tret |= (hdr_addr[i] ^ ap->addr[i]) & ap->mask[i];\n\n\treturn ret != 0;\n}\n\n \nstatic unsigned long ifname_compare(const char *_a, const char *_b, const char *_mask)\n{\n#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tunsigned long ret = ifname_compare_aligned(_a, _b, _mask);\n#else\n\tunsigned long ret = 0;\n\tconst u16 *a = (const u16 *)_a;\n\tconst u16 *b = (const u16 *)_b;\n\tconst u16 *mask = (const u16 *)_mask;\n\tint i;\n\n\tfor (i = 0; i < IFNAMSIZ/sizeof(u16); i++)\n\t\tret |= (a[i] ^ b[i]) & mask[i];\n#endif\n\treturn ret;\n}\n\n \nstatic inline int arp_packet_match(const struct arphdr *arphdr,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   const char *indev,\n\t\t\t\t   const char *outdev,\n\t\t\t\t   const struct arpt_arp *arpinfo)\n{\n\tconst char *arpptr = (char *)(arphdr + 1);\n\tconst char *src_devaddr, *tgt_devaddr;\n\t__be32 src_ipaddr, tgt_ipaddr;\n\tlong ret;\n\n\tif (NF_INVF(arpinfo, ARPT_INV_ARPOP,\n\t\t    (arphdr->ar_op & arpinfo->arpop_mask) != arpinfo->arpop))\n\t\treturn 0;\n\n\tif (NF_INVF(arpinfo, ARPT_INV_ARPHRD,\n\t\t    (arphdr->ar_hrd & arpinfo->arhrd_mask) != arpinfo->arhrd))\n\t\treturn 0;\n\n\tif (NF_INVF(arpinfo, ARPT_INV_ARPPRO,\n\t\t    (arphdr->ar_pro & arpinfo->arpro_mask) != arpinfo->arpro))\n\t\treturn 0;\n\n\tif (NF_INVF(arpinfo, ARPT_INV_ARPHLN,\n\t\t    (arphdr->ar_hln & arpinfo->arhln_mask) != arpinfo->arhln))\n\t\treturn 0;\n\n\tsrc_devaddr = arpptr;\n\tarpptr += dev->addr_len;\n\tmemcpy(&src_ipaddr, arpptr, sizeof(u32));\n\tarpptr += sizeof(u32);\n\ttgt_devaddr = arpptr;\n\tarpptr += dev->addr_len;\n\tmemcpy(&tgt_ipaddr, arpptr, sizeof(u32));\n\n\tif (NF_INVF(arpinfo, ARPT_INV_SRCDEVADDR,\n\t\t    arp_devaddr_compare(&arpinfo->src_devaddr, src_devaddr,\n\t\t\t\t\tdev->addr_len)) ||\n\t    NF_INVF(arpinfo, ARPT_INV_TGTDEVADDR,\n\t\t    arp_devaddr_compare(&arpinfo->tgt_devaddr, tgt_devaddr,\n\t\t\t\t\tdev->addr_len)))\n\t\treturn 0;\n\n\tif (NF_INVF(arpinfo, ARPT_INV_SRCIP,\n\t\t    (src_ipaddr & arpinfo->smsk.s_addr) != arpinfo->src.s_addr) ||\n\t    NF_INVF(arpinfo, ARPT_INV_TGTIP,\n\t\t    (tgt_ipaddr & arpinfo->tmsk.s_addr) != arpinfo->tgt.s_addr))\n\t\treturn 0;\n\n\t \n\tret = ifname_compare(indev, arpinfo->iniface, arpinfo->iniface_mask);\n\n\tif (NF_INVF(arpinfo, ARPT_INV_VIA_IN, ret != 0))\n\t\treturn 0;\n\n\tret = ifname_compare(outdev, arpinfo->outiface, arpinfo->outiface_mask);\n\n\tif (NF_INVF(arpinfo, ARPT_INV_VIA_OUT, ret != 0))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline int arp_checkentry(const struct arpt_arp *arp)\n{\n\tif (arp->flags & ~ARPT_F_MASK)\n\t\treturn 0;\n\tif (arp->invflags & ~ARPT_INV_MASK)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic unsigned int\narpt_error(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tnet_err_ratelimited(\"arp_tables: error: '%s'\\n\",\n\t\t\t    (const char *)par->targinfo);\n\n\treturn NF_DROP;\n}\n\nstatic inline const struct xt_entry_target *\narpt_get_target_c(const struct arpt_entry *e)\n{\n\treturn arpt_get_target((struct arpt_entry *)e);\n}\n\nstatic inline struct arpt_entry *\nget_entry(const void *base, unsigned int offset)\n{\n\treturn (struct arpt_entry *)(base + offset);\n}\n\nstatic inline\nstruct arpt_entry *arpt_next_entry(const struct arpt_entry *entry)\n{\n\treturn (void *)entry + entry->next_offset;\n}\n\nunsigned int arpt_do_table(void *priv,\n\t\t\t   struct sk_buff *skb,\n\t\t\t   const struct nf_hook_state *state)\n{\n\tconst struct xt_table *table = priv;\n\tunsigned int hook = state->hook;\n\tstatic const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long))));\n\tunsigned int verdict = NF_DROP;\n\tconst struct arphdr *arp;\n\tstruct arpt_entry *e, **jumpstack;\n\tconst char *indev, *outdev;\n\tconst void *table_base;\n\tunsigned int cpu, stackidx = 0;\n\tconst struct xt_table_info *private;\n\tstruct xt_action_param acpar;\n\tunsigned int addend;\n\n\tif (!pskb_may_pull(skb, arp_hdr_len(skb->dev)))\n\t\treturn NF_DROP;\n\n\tindev = state->in ? state->in->name : nulldevname;\n\toutdev = state->out ? state->out->name : nulldevname;\n\n\tlocal_bh_disable();\n\taddend = xt_write_recseq_begin();\n\tprivate = READ_ONCE(table->private);  \n\tcpu     = smp_processor_id();\n\ttable_base = private->entries;\n\tjumpstack  = (struct arpt_entry **)private->jumpstack[cpu];\n\n\t \n\te = get_entry(table_base, private->hook_entry[hook]);\n\n\tacpar.state   = state;\n\tacpar.hotdrop = false;\n\n\tarp = arp_hdr(skb);\n\tdo {\n\t\tconst struct xt_entry_target *t;\n\t\tstruct xt_counters *counter;\n\n\t\tif (!arp_packet_match(arp, skb->dev, indev, outdev, &e->arp)) {\n\t\t\te = arpt_next_entry(e);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcounter = xt_get_this_cpu_counter(&e->counters);\n\t\tADD_COUNTER(*counter, arp_hdr_len(skb->dev), 1);\n\n\t\tt = arpt_get_target_c(e);\n\n\t\t \n\t\tif (!t->u.kernel.target->target) {\n\t\t\tint v;\n\n\t\t\tv = ((struct xt_standard_target *)t)->verdict;\n\t\t\tif (v < 0) {\n\t\t\t\t \n\t\t\t\tif (v != XT_RETURN) {\n\t\t\t\t\tverdict = (unsigned int)(-v) - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (stackidx == 0) {\n\t\t\t\t\te = get_entry(table_base,\n\t\t\t\t\t\t      private->underflow[hook]);\n\t\t\t\t} else {\n\t\t\t\t\te = jumpstack[--stackidx];\n\t\t\t\t\te = arpt_next_entry(e);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (table_base + v\n\t\t\t    != arpt_next_entry(e)) {\n\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n\t\t\t\t\tverdict = NF_DROP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjumpstack[stackidx++] = e;\n\t\t\t}\n\n\t\t\te = get_entry(table_base, v);\n\t\t\tcontinue;\n\t\t}\n\n\t\tacpar.target   = t->u.kernel.target;\n\t\tacpar.targinfo = t->data;\n\t\tverdict = t->u.kernel.target->target(skb, &acpar);\n\n\t\tif (verdict == XT_CONTINUE) {\n\t\t\t \n\t\t\tarp = arp_hdr(skb);\n\t\t\te = arpt_next_entry(e);\n\t\t} else {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t} while (!acpar.hotdrop);\n\txt_write_recseq_end(addend);\n\tlocal_bh_enable();\n\n\tif (acpar.hotdrop)\n\t\treturn NF_DROP;\n\telse\n\t\treturn verdict;\n}\n\n \nstatic inline bool unconditional(const struct arpt_entry *e)\n{\n\tstatic const struct arpt_arp uncond;\n\n\treturn e->target_offset == sizeof(struct arpt_entry) &&\n\t       memcmp(&e->arp, &uncond, sizeof(uncond)) == 0;\n}\n\n \nstatic int mark_source_chains(const struct xt_table_info *newinfo,\n\t\t\t      unsigned int valid_hooks, void *entry0,\n\t\t\t      unsigned int *offsets)\n{\n\tunsigned int hook;\n\n\t \n\tfor (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {\n\t\tunsigned int pos = newinfo->hook_entry[hook];\n\t\tstruct arpt_entry *e = entry0 + pos;\n\n\t\tif (!(valid_hooks & (1 << hook)))\n\t\t\tcontinue;\n\n\t\t \n\t\te->counters.pcnt = pos;\n\n\t\tfor (;;) {\n\t\t\tconst struct xt_standard_target *t\n\t\t\t\t= (void *)arpt_get_target_c(e);\n\t\t\tint visited = e->comefrom & (1 << hook);\n\n\t\t\tif (e->comefrom & (1 << NF_ARP_NUMHOOKS))\n\t\t\t\treturn 0;\n\n\t\t\te->comefrom\n\t\t\t\t|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));\n\n\t\t\t \n\t\t\tif ((unconditional(e) &&\n\t\t\t     (strcmp(t->target.u.user.name,\n\t\t\t\t     XT_STANDARD_TARGET) == 0) &&\n\t\t\t     t->verdict < 0) || visited) {\n\t\t\t\tunsigned int oldpos, size;\n\n\t\t\t\t \n\t\t\t\tdo {\n\t\t\t\t\te->comefrom ^= (1<<NF_ARP_NUMHOOKS);\n\t\t\t\t\toldpos = pos;\n\t\t\t\t\tpos = e->counters.pcnt;\n\t\t\t\t\te->counters.pcnt = 0;\n\n\t\t\t\t\t \n\t\t\t\t\tif (pos == oldpos)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\te = entry0 + pos;\n\t\t\t\t} while (oldpos == pos + e->next_offset);\n\n\t\t\t\t \n\t\t\t\tsize = e->next_offset;\n\t\t\t\te = entry0 + pos + size;\n\t\t\t\tif (pos + size >= newinfo->size)\n\t\t\t\t\treturn 0;\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos += size;\n\t\t\t} else {\n\t\t\t\tint newpos = t->verdict;\n\n\t\t\t\tif (strcmp(t->target.u.user.name,\n\t\t\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t\t\t    newpos >= 0) {\n\t\t\t\t\t \n\t\t\t\t\tif (!xt_find_jump_offset(offsets, newpos,\n\t\t\t\t\t\t\t\t newinfo->number))\n\t\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tnewpos = pos + e->next_offset;\n\t\t\t\t\tif (newpos >= newinfo->size)\n\t\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\te = entry0 + newpos;\n\t\t\t\te->counters.pcnt = pos;\n\t\t\t\tpos = newpos;\n\t\t\t}\n\t\t}\nnext:\t\t;\n\t}\n\treturn 1;\n}\n\nstatic int check_target(struct arpt_entry *e, struct net *net, const char *name)\n{\n\tstruct xt_entry_target *t = arpt_get_target(e);\n\tstruct xt_tgchk_param par = {\n\t\t.net       = net,\n\t\t.table     = name,\n\t\t.entryinfo = e,\n\t\t.target    = t->u.kernel.target,\n\t\t.targinfo  = t->data,\n\t\t.hook_mask = e->comefrom,\n\t\t.family    = NFPROTO_ARP,\n\t};\n\n\treturn xt_check_target(&par, t->u.target_size - sizeof(*t), 0, false);\n}\n\nstatic int\nfind_check_entry(struct arpt_entry *e, struct net *net, const char *name,\n\t\t unsigned int size,\n\t\t struct xt_percpu_counter_alloc_state *alloc_state)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tint ret;\n\n\tif (!xt_percpu_counter_alloc(alloc_state, &e->counters))\n\t\treturn -ENOMEM;\n\n\tt = arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\n\tret = check_target(e, net, name);\n\tif (ret)\n\t\tgoto err;\n\treturn 0;\nerr:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\txt_percpu_counter_free(&e->counters);\n\n\treturn ret;\n}\n\nstatic bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}\n\nstatic inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit)\n\t\treturn -EINVAL;\n\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target))\n\t\treturn -EINVAL;\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t     e->next_offset);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t \n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}\n\nstatic void cleanup_entry(struct arpt_entry *e, struct net *net)\n{\n\tstruct xt_tgdtor_param par;\n\tstruct xt_entry_target *t;\n\n\tt = arpt_get_target(e);\n\tpar.net      = net;\n\tpar.target   = t->u.kernel.target;\n\tpar.targinfo = t->data;\n\tpar.family   = NFPROTO_ARP;\n\tif (par.target->destroy != NULL)\n\t\tpar.target->destroy(&par);\n\tmodule_put(par.target->me);\n\txt_percpu_counter_free(&e->counters);\n}\n\n \nstatic int translate_table(struct net *net,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   void *entry0,\n\t\t\t   const struct arpt_replace *repl)\n{\n\tstruct xt_percpu_counter_alloc_state alloc_state = { 0 };\n\tstruct arpt_entry *iter;\n\tunsigned int *offsets;\n\tunsigned int i;\n\tint ret = 0;\n\n\tnewinfo->size = repl->size;\n\tnewinfo->number = repl->num_entries;\n\n\t \n\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {\n\t\tnewinfo->hook_entry[i] = 0xFFFFFFFF;\n\t\tnewinfo->underflow[i] = 0xFFFFFFFF;\n\t}\n\n\toffsets = xt_alloc_entry_offsets(newinfo->number);\n\tif (!offsets)\n\t\treturn -ENOMEM;\n\ti = 0;\n\n\t \n\txt_entry_foreach(iter, entry0, newinfo->size) {\n\t\tret = check_entry_size_and_hooks(iter, newinfo, entry0,\n\t\t\t\t\t\t entry0 + repl->size,\n\t\t\t\t\t\t repl->hook_entry,\n\t\t\t\t\t\t repl->underflow,\n\t\t\t\t\t\t repl->valid_hooks);\n\t\tif (ret != 0)\n\t\t\tgoto out_free;\n\t\tif (i < repl->num_entries)\n\t\t\toffsets[i] = (void *)iter - entry0;\n\t\t++i;\n\t\tif (strcmp(arpt_get_target(iter)->u.user.name,\n\t\t    XT_ERROR_TARGET) == 0)\n\t\t\t++newinfo->stacksize;\n\t}\n\n\tret = -EINVAL;\n\tif (i != repl->num_entries)\n\t\tgoto out_free;\n\n\tret = xt_check_table_hooks(newinfo, repl->valid_hooks);\n\tif (ret)\n\t\tgoto out_free;\n\n\tif (!mark_source_chains(newinfo, repl->valid_hooks, entry0, offsets)) {\n\t\tret = -ELOOP;\n\t\tgoto out_free;\n\t}\n\tkvfree(offsets);\n\n\t \n\ti = 0;\n\txt_entry_foreach(iter, entry0, newinfo->size) {\n\t\tret = find_check_entry(iter, net, repl->name, repl->size,\n\t\t\t\t       &alloc_state);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t\t++i;\n\t}\n\n\tif (ret != 0) {\n\t\txt_entry_foreach(iter, entry0, newinfo->size) {\n\t\t\tif (i-- == 0)\n\t\t\t\tbreak;\n\t\t\tcleanup_entry(iter, net);\n\t\t}\n\t\treturn ret;\n\t}\n\n\treturn ret;\n out_free:\n\tkvfree(offsets);\n\treturn ret;\n}\n\nstatic void get_counters(const struct xt_table_info *t,\n\t\t\t struct xt_counters counters[])\n{\n\tstruct arpt_entry *iter;\n\tunsigned int cpu;\n\tunsigned int i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tseqcount_t *s = &per_cpu(xt_recseq, cpu);\n\n\t\ti = 0;\n\t\txt_entry_foreach(iter, t->entries, t->size) {\n\t\t\tstruct xt_counters *tmp;\n\t\t\tu64 bcnt, pcnt;\n\t\t\tunsigned int start;\n\n\t\t\ttmp = xt_get_per_cpu_counter(&iter->counters, cpu);\n\t\t\tdo {\n\t\t\t\tstart = read_seqcount_begin(s);\n\t\t\t\tbcnt = tmp->bcnt;\n\t\t\t\tpcnt = tmp->pcnt;\n\t\t\t} while (read_seqcount_retry(s, start));\n\n\t\t\tADD_COUNTER(counters[i], bcnt, pcnt);\n\t\t\t++i;\n\t\t\tcond_resched();\n\t\t}\n\t}\n}\n\nstatic void get_old_counters(const struct xt_table_info *t,\n\t\t\t     struct xt_counters counters[])\n{\n\tstruct arpt_entry *iter;\n\tunsigned int cpu, i;\n\n\tfor_each_possible_cpu(cpu) {\n\t\ti = 0;\n\t\txt_entry_foreach(iter, t->entries, t->size) {\n\t\t\tstruct xt_counters *tmp;\n\n\t\t\ttmp = xt_get_per_cpu_counter(&iter->counters, cpu);\n\t\t\tADD_COUNTER(counters[i], tmp->bcnt, tmp->pcnt);\n\t\t\t++i;\n\t\t}\n\t\tcond_resched();\n\t}\n}\n\nstatic struct xt_counters *alloc_counters(const struct xt_table *table)\n{\n\tunsigned int countersize;\n\tstruct xt_counters *counters;\n\tconst struct xt_table_info *private = table->private;\n\n\t \n\tcountersize = sizeof(struct xt_counters) * private->number;\n\tcounters = vzalloc(countersize);\n\n\tif (counters == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_counters(private, counters);\n\n\treturn counters;\n}\n\nstatic int copy_entries_to_user(unsigned int total_size,\n\t\t\t\tconst struct xt_table *table,\n\t\t\t\tvoid __user *userptr)\n{\n\tunsigned int off, num;\n\tconst struct arpt_entry *e;\n\tstruct xt_counters *counters;\n\tstruct xt_table_info *private = table->private;\n\tint ret = 0;\n\tvoid *loc_cpu_entry;\n\n\tcounters = alloc_counters(table);\n\tif (IS_ERR(counters))\n\t\treturn PTR_ERR(counters);\n\n\tloc_cpu_entry = private->entries;\n\n\t \n\t \n\tfor (off = 0, num = 0; off < total_size; off += e->next_offset, num++){\n\t\tconst struct xt_entry_target *t;\n\n\t\te = loc_cpu_entry + off;\n\t\tif (copy_to_user(userptr + off, e, sizeof(*e))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto free_counters;\n\t\t}\n\t\tif (copy_to_user(userptr + off\n\t\t\t\t + offsetof(struct arpt_entry, counters),\n\t\t\t\t &counters[num],\n\t\t\t\t sizeof(counters[num])) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto free_counters;\n\t\t}\n\n\t\tt = arpt_get_target_c(e);\n\t\tif (xt_target_to_user(t, userptr + off + e->target_offset)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto free_counters;\n\t\t}\n\t}\n\n free_counters:\n\tvfree(counters);\n\treturn ret;\n}\n\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\nstatic void compat_standard_from_user(void *dst, const void *src)\n{\n\tint v = *(compat_int_t *)src;\n\n\tif (v > 0)\n\t\tv += xt_compat_calc_jump(NFPROTO_ARP, v);\n\tmemcpy(dst, &v, sizeof(v));\n}\n\nstatic int compat_standard_to_user(void __user *dst, const void *src)\n{\n\tcompat_int_t cv = *(int *)src;\n\n\tif (cv > 0)\n\t\tcv -= xt_compat_calc_jump(NFPROTO_ARP, cv);\n\treturn copy_to_user(dst, &cv, sizeof(cv)) ? -EFAULT : 0;\n}\n\nstatic int compat_calc_entry(const struct arpt_entry *e,\n\t\t\t     const struct xt_table_info *info,\n\t\t\t     const void *base, struct xt_table_info *newinfo)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int entry_offset;\n\tint off, i, ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - base;\n\n\tt = arpt_get_target_c(e);\n\toff += xt_compat_target_offset(t->u.kernel.target);\n\tnewinfo->size -= off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {\n\t\tif (info->hook_entry[i] &&\n\t\t    (e < (struct arpt_entry *)(base + info->hook_entry[i])))\n\t\t\tnewinfo->hook_entry[i] -= off;\n\t\tif (info->underflow[i] &&\n\t\t    (e < (struct arpt_entry *)(base + info->underflow[i])))\n\t\t\tnewinfo->underflow[i] -= off;\n\t}\n\treturn 0;\n}\n\nstatic int compat_table_info(const struct xt_table_info *info,\n\t\t\t     struct xt_table_info *newinfo)\n{\n\tstruct arpt_entry *iter;\n\tconst void *loc_cpu_entry;\n\tint ret;\n\n\tif (!newinfo || !info)\n\t\treturn -EINVAL;\n\n\t \n\tmemcpy(newinfo, info, offsetof(struct xt_table_info, entries));\n\tnewinfo->initial_entries = 0;\n\tloc_cpu_entry = info->entries;\n\tret = xt_compat_init_offsets(NFPROTO_ARP, info->number);\n\tif (ret)\n\t\treturn ret;\n\txt_entry_foreach(iter, loc_cpu_entry, info->size) {\n\t\tret = compat_calc_entry(iter, info, loc_cpu_entry, newinfo);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic int get_info(struct net *net, void __user *user, const int *len)\n{\n\tchar name[XT_TABLE_MAXNAMELEN];\n\tstruct xt_table *t;\n\tint ret;\n\n\tif (*len != sizeof(struct arpt_getinfo))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(name, user, sizeof(name)) != 0)\n\t\treturn -EFAULT;\n\n\tname[XT_TABLE_MAXNAMELEN-1] = '\\0';\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\tif (in_compat_syscall())\n\t\txt_compat_lock(NFPROTO_ARP);\n#endif\n\tt = xt_request_find_table_lock(net, NFPROTO_ARP, name);\n\tif (!IS_ERR(t)) {\n\t\tstruct arpt_getinfo info;\n\t\tconst struct xt_table_info *private = t->private;\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\t\tstruct xt_table_info tmp;\n\n\t\tif (in_compat_syscall()) {\n\t\t\tret = compat_table_info(private, &tmp);\n\t\t\txt_compat_flush_offsets(NFPROTO_ARP);\n\t\t\tprivate = &tmp;\n\t\t}\n#endif\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.valid_hooks = t->valid_hooks;\n\t\tmemcpy(info.hook_entry, private->hook_entry,\n\t\t       sizeof(info.hook_entry));\n\t\tmemcpy(info.underflow, private->underflow,\n\t\t       sizeof(info.underflow));\n\t\tinfo.num_entries = private->number;\n\t\tinfo.size = private->size;\n\t\tstrcpy(info.name, name);\n\n\t\tif (copy_to_user(user, &info, *len) != 0)\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = 0;\n\t\txt_table_unlock(t);\n\t\tmodule_put(t->me);\n\t} else\n\t\tret = PTR_ERR(t);\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\tif (in_compat_syscall())\n\t\txt_compat_unlock(NFPROTO_ARP);\n#endif\n\treturn ret;\n}\n\nstatic int get_entries(struct net *net, struct arpt_get_entries __user *uptr,\n\t\t       const int *len)\n{\n\tint ret;\n\tstruct arpt_get_entries get;\n\tstruct xt_table *t;\n\n\tif (*len < sizeof(get))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&get, uptr, sizeof(get)) != 0)\n\t\treturn -EFAULT;\n\tif (*len != sizeof(struct arpt_get_entries) + get.size)\n\t\treturn -EINVAL;\n\n\tget.name[sizeof(get.name) - 1] = '\\0';\n\n\tt = xt_find_table_lock(net, NFPROTO_ARP, get.name);\n\tif (!IS_ERR(t)) {\n\t\tconst struct xt_table_info *private = t->private;\n\n\t\tif (get.size == private->size)\n\t\t\tret = copy_entries_to_user(private->size,\n\t\t\t\t\t\t   t, uptr->entrytable);\n\t\telse\n\t\t\tret = -EAGAIN;\n\n\t\tmodule_put(t->me);\n\t\txt_table_unlock(t);\n\t} else\n\t\tret = PTR_ERR(t);\n\n\treturn ret;\n}\n\nstatic int __do_replace(struct net *net, const char *name,\n\t\t\tunsigned int valid_hooks,\n\t\t\tstruct xt_table_info *newinfo,\n\t\t\tunsigned int num_counters,\n\t\t\tvoid __user *counters_ptr)\n{\n\tint ret;\n\tstruct xt_table *t;\n\tstruct xt_table_info *oldinfo;\n\tstruct xt_counters *counters;\n\tvoid *loc_cpu_old_entry;\n\tstruct arpt_entry *iter;\n\n\tret = 0;\n\tcounters = xt_counters_alloc(num_counters);\n\tif (!counters) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tt = xt_request_find_table_lock(net, NFPROTO_ARP, name);\n\tif (IS_ERR(t)) {\n\t\tret = PTR_ERR(t);\n\t\tgoto free_newinfo_counters_untrans;\n\t}\n\n\t \n\tif (valid_hooks != t->valid_hooks) {\n\t\tret = -EINVAL;\n\t\tgoto put_module;\n\t}\n\n\toldinfo = xt_replace_table(t, num_counters, newinfo, &ret);\n\tif (!oldinfo)\n\t\tgoto put_module;\n\n\t \n\tif ((oldinfo->number > oldinfo->initial_entries) ||\n\t    (newinfo->number <= oldinfo->initial_entries))\n\t\tmodule_put(t->me);\n\tif ((oldinfo->number > oldinfo->initial_entries) &&\n\t    (newinfo->number <= oldinfo->initial_entries))\n\t\tmodule_put(t->me);\n\n\txt_table_unlock(t);\n\n\tget_old_counters(oldinfo, counters);\n\n\t \n\tloc_cpu_old_entry = oldinfo->entries;\n\txt_entry_foreach(iter, loc_cpu_old_entry, oldinfo->size)\n\t\tcleanup_entry(iter, net);\n\n\txt_free_table_info(oldinfo);\n\tif (copy_to_user(counters_ptr, counters,\n\t\t\t sizeof(struct xt_counters) * num_counters) != 0) {\n\t\t \n\t\tnet_warn_ratelimited(\"arptables: counters copy to user failed while replacing table\\n\");\n\t}\n\tvfree(counters);\n\treturn ret;\n\n put_module:\n\tmodule_put(t->me);\n\txt_table_unlock(t);\n free_newinfo_counters_untrans:\n\tvfree(counters);\n out:\n\treturn ret;\n}\n\nstatic int do_replace(struct net *net, sockptr_t arg, unsigned int len)\n{\n\tint ret;\n\tstruct arpt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct arpt_entry *iter;\n\n\tif (copy_from_sockptr(&tmp, arg, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t \n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters == 0)\n\t\treturn -EINVAL;\n\n\ttmp.name[sizeof(tmp.name)-1] = 0;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tloc_cpu_entry = newinfo->entries;\n\tif (copy_from_sockptr_offset(loc_cpu_entry, arg, sizeof(tmp),\n\t\t\ttmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_table(net, newinfo, loc_cpu_entry, &tmp);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, tmp.counters);\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}\n\nstatic int do_add_counters(struct net *net, sockptr_t arg, unsigned int len)\n{\n\tunsigned int i;\n\tstruct xt_counters_info tmp;\n\tstruct xt_counters *paddc;\n\tstruct xt_table *t;\n\tconst struct xt_table_info *private;\n\tint ret = 0;\n\tstruct arpt_entry *iter;\n\tunsigned int addend;\n\n\tpaddc = xt_copy_counters(arg, len, &tmp);\n\tif (IS_ERR(paddc))\n\t\treturn PTR_ERR(paddc);\n\n\tt = xt_find_table_lock(net, NFPROTO_ARP, tmp.name);\n\tif (IS_ERR(t)) {\n\t\tret = PTR_ERR(t);\n\t\tgoto free;\n\t}\n\n\tlocal_bh_disable();\n\tprivate = t->private;\n\tif (private->number != tmp.num_counters) {\n\t\tret = -EINVAL;\n\t\tgoto unlock_up_free;\n\t}\n\n\ti = 0;\n\n\taddend = xt_write_recseq_begin();\n\txt_entry_foreach(iter,  private->entries, private->size) {\n\t\tstruct xt_counters *tmp;\n\n\t\ttmp = xt_get_this_cpu_counter(&iter->counters);\n\t\tADD_COUNTER(*tmp, paddc[i].bcnt, paddc[i].pcnt);\n\t\t++i;\n\t}\n\txt_write_recseq_end(addend);\n unlock_up_free:\n\tlocal_bh_enable();\n\txt_table_unlock(t);\n\tmodule_put(t->me);\n free:\n\tvfree(paddc);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\nstruct compat_arpt_replace {\n\tchar\t\t\t\tname[XT_TABLE_MAXNAMELEN];\n\tu32\t\t\t\tvalid_hooks;\n\tu32\t\t\t\tnum_entries;\n\tu32\t\t\t\tsize;\n\tu32\t\t\t\thook_entry[NF_ARP_NUMHOOKS];\n\tu32\t\t\t\tunderflow[NF_ARP_NUMHOOKS];\n\tu32\t\t\t\tnum_counters;\n\tcompat_uptr_t\t\t\tcounters;\n\tstruct compat_arpt_entry\tentries[];\n};\n\nstatic inline void compat_release_entry(struct compat_arpt_entry *e)\n{\n\tstruct xt_entry_target *t;\n\n\tt = compat_arpt_get_target(e);\n\tmodule_put(t->u.kernel.target->me);\n}\n\nstatic int\ncheck_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off;\n\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit)\n\t\treturn -EINVAL;\n\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target))\n\t\treturn -EINVAL;\n\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\n\tret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t\t    e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\n\treturn 0;\n\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}\n\nstatic void\ncompat_copy_entry_from_user(struct compat_arpt_entry *e, void **dstptr,\n\t\t\t    unsigned int *size,\n\t\t\t    struct xt_table_info *newinfo, unsigned char *base)\n{\n\tstruct xt_entry_target *t;\n\tstruct arpt_entry *de;\n\tunsigned int origsize;\n\tint h;\n\n\torigsize = *size;\n\tde = *dstptr;\n\tmemcpy(de, e, sizeof(struct arpt_entry));\n\tmemcpy(&de->counters, &e->counters, sizeof(e->counters));\n\n\t*dstptr += sizeof(struct arpt_entry);\n\t*size += sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\n\tde->target_offset = e->target_offset - (origsize - *size);\n\tt = compat_arpt_get_target(e);\n\txt_compat_target_from_user(t, dstptr, size);\n\n\tde->next_offset = e->next_offset - (origsize - *size);\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)de - base < newinfo->hook_entry[h])\n\t\t\tnewinfo->hook_entry[h] -= origsize - *size;\n\t\tif ((unsigned char *)de - base < newinfo->underflow[h])\n\t\t\tnewinfo->underflow[h] -= origsize - *size;\n\t}\n}\n\nstatic int translate_compat_table(struct net *net,\n\t\t\t\t  struct xt_table_info **pinfo,\n\t\t\t\t  void **pentry0,\n\t\t\t\t  const struct compat_arpt_replace *compatr)\n{\n\tunsigned int i, j;\n\tstruct xt_table_info *newinfo, *info;\n\tvoid *pos, *entry0, *entry1;\n\tstruct compat_arpt_entry *iter0;\n\tstruct arpt_replace repl;\n\tunsigned int size;\n\tint ret;\n\n\tinfo = *pinfo;\n\tentry0 = *pentry0;\n\tsize = compatr->size;\n\tinfo->number = compatr->num_entries;\n\n\tj = 0;\n\txt_compat_lock(NFPROTO_ARP);\n\tret = xt_compat_init_offsets(NFPROTO_ARP, compatr->num_entries);\n\tif (ret)\n\t\tgoto out_unlock;\n\t \n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tret = check_compat_entry_size_and_hooks(iter0, info, &size,\n\t\t\t\t\t\t\tentry0,\n\t\t\t\t\t\t\tentry0 + compatr->size);\n\t\tif (ret != 0)\n\t\t\tgoto out_unlock;\n\t\t++j;\n\t}\n\n\tret = -EINVAL;\n\tif (j != compatr->num_entries)\n\t\tgoto out_unlock;\n\n\tret = -ENOMEM;\n\tnewinfo = xt_alloc_table_info(size);\n\tif (!newinfo)\n\t\tgoto out_unlock;\n\n\tmemset(newinfo->entries, 0, size);\n\n\tnewinfo->number = compatr->num_entries;\n\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {\n\t\tnewinfo->hook_entry[i] = compatr->hook_entry[i];\n\t\tnewinfo->underflow[i] = compatr->underflow[i];\n\t}\n\tentry1 = newinfo->entries;\n\tpos = entry1;\n\tsize = compatr->size;\n\txt_entry_foreach(iter0, entry0, compatr->size)\n\t\tcompat_copy_entry_from_user(iter0, &pos, &size,\n\t\t\t\t\t    newinfo, entry1);\n\n\t \n\n\txt_compat_flush_offsets(NFPROTO_ARP);\n\txt_compat_unlock(NFPROTO_ARP);\n\n\tmemcpy(&repl, compatr, sizeof(*compatr));\n\n\tfor (i = 0; i < NF_ARP_NUMHOOKS; i++) {\n\t\trepl.hook_entry[i] = newinfo->hook_entry[i];\n\t\trepl.underflow[i] = newinfo->underflow[i];\n\t}\n\n\trepl.num_counters = 0;\n\trepl.counters = NULL;\n\trepl.size = newinfo->size;\n\tret = translate_table(net, newinfo, entry1, &repl);\n\tif (ret)\n\t\tgoto free_newinfo;\n\n\t*pinfo = newinfo;\n\t*pentry0 = entry1;\n\txt_free_table_info(info);\n\treturn 0;\n\nfree_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\nout_unlock:\n\txt_compat_flush_offsets(NFPROTO_ARP);\n\txt_compat_unlock(NFPROTO_ARP);\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tcompat_release_entry(iter0);\n\t}\n\treturn ret;\n}\n\nstatic int compat_do_replace(struct net *net, sockptr_t arg, unsigned int len)\n{\n\tint ret;\n\tstruct compat_arpt_replace tmp;\n\tstruct xt_table_info *newinfo;\n\tvoid *loc_cpu_entry;\n\tstruct arpt_entry *iter;\n\n\tif (copy_from_sockptr(&tmp, arg, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\n\t \n\tif (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters == 0)\n\t\treturn -EINVAL;\n\n\ttmp.name[sizeof(tmp.name)-1] = 0;\n\n\tnewinfo = xt_alloc_table_info(tmp.size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tloc_cpu_entry = newinfo->entries;\n\tif (copy_from_sockptr_offset(loc_cpu_entry, arg, sizeof(tmp),\n\t\t\ttmp.size) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto free_newinfo;\n\t}\n\n\tret = translate_compat_table(net, &newinfo, &loc_cpu_entry, &tmp);\n\tif (ret != 0)\n\t\tgoto free_newinfo;\n\n\tret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,\n\t\t\t   tmp.num_counters, compat_ptr(tmp.counters));\n\tif (ret)\n\t\tgoto free_newinfo_untrans;\n\treturn 0;\n\n free_newinfo_untrans:\n\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\tcleanup_entry(iter, net);\n free_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\n}\n\nstatic int compat_copy_entry_to_user(struct arpt_entry *e, void __user **dstptr,\n\t\t\t\t     compat_uint_t *size,\n\t\t\t\t     struct xt_counters *counters,\n\t\t\t\t     unsigned int i)\n{\n\tstruct xt_entry_target *t;\n\tstruct compat_arpt_entry __user *ce;\n\tu_int16_t target_offset, next_offset;\n\tcompat_uint_t origsize;\n\tint ret;\n\n\torigsize = *size;\n\tce = *dstptr;\n\tif (copy_to_user(ce, e, sizeof(struct arpt_entry)) != 0 ||\n\t    copy_to_user(&ce->counters, &counters[i],\n\t    sizeof(counters[i])) != 0)\n\t\treturn -EFAULT;\n\n\t*dstptr += sizeof(struct compat_arpt_entry);\n\t*size -= sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\n\ttarget_offset = e->target_offset - (origsize - *size);\n\n\tt = arpt_get_target(e);\n\tret = xt_compat_target_to_user(t, dstptr, size);\n\tif (ret)\n\t\treturn ret;\n\tnext_offset = e->next_offset - (origsize - *size);\n\tif (put_user(target_offset, &ce->target_offset) != 0 ||\n\t    put_user(next_offset, &ce->next_offset) != 0)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int compat_copy_entries_to_user(unsigned int total_size,\n\t\t\t\t       struct xt_table *table,\n\t\t\t\t       void __user *userptr)\n{\n\tstruct xt_counters *counters;\n\tconst struct xt_table_info *private = table->private;\n\tvoid __user *pos;\n\tunsigned int size;\n\tint ret = 0;\n\tunsigned int i = 0;\n\tstruct arpt_entry *iter;\n\n\tcounters = alloc_counters(table);\n\tif (IS_ERR(counters))\n\t\treturn PTR_ERR(counters);\n\n\tpos = userptr;\n\tsize = total_size;\n\txt_entry_foreach(iter, private->entries, total_size) {\n\t\tret = compat_copy_entry_to_user(iter, &pos,\n\t\t\t\t\t\t&size, counters, i++);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t}\n\tvfree(counters);\n\treturn ret;\n}\n\nstruct compat_arpt_get_entries {\n\tchar name[XT_TABLE_MAXNAMELEN];\n\tcompat_uint_t size;\n\tstruct compat_arpt_entry entrytable[];\n};\n\nstatic int compat_get_entries(struct net *net,\n\t\t\t      struct compat_arpt_get_entries __user *uptr,\n\t\t\t      int *len)\n{\n\tint ret;\n\tstruct compat_arpt_get_entries get;\n\tstruct xt_table *t;\n\n\tif (*len < sizeof(get))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&get, uptr, sizeof(get)) != 0)\n\t\treturn -EFAULT;\n\tif (*len != sizeof(struct compat_arpt_get_entries) + get.size)\n\t\treturn -EINVAL;\n\n\tget.name[sizeof(get.name) - 1] = '\\0';\n\n\txt_compat_lock(NFPROTO_ARP);\n\tt = xt_find_table_lock(net, NFPROTO_ARP, get.name);\n\tif (!IS_ERR(t)) {\n\t\tconst struct xt_table_info *private = t->private;\n\t\tstruct xt_table_info info;\n\n\t\tret = compat_table_info(private, &info);\n\t\tif (!ret && get.size == info.size) {\n\t\t\tret = compat_copy_entries_to_user(private->size,\n\t\t\t\t\t\t\t  t, uptr->entrytable);\n\t\t} else if (!ret)\n\t\t\tret = -EAGAIN;\n\n\t\txt_compat_flush_offsets(NFPROTO_ARP);\n\t\tmodule_put(t->me);\n\t\txt_table_unlock(t);\n\t} else\n\t\tret = PTR_ERR(t);\n\n\txt_compat_unlock(NFPROTO_ARP);\n\treturn ret;\n}\n#endif\n\nstatic int do_arpt_set_ctl(struct sock *sk, int cmd, sockptr_t arg,\n\t\tunsigned int len)\n{\n\tint ret;\n\n\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase ARPT_SO_SET_REPLACE:\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\t\tif (in_compat_syscall())\n\t\t\tret = compat_do_replace(sock_net(sk), arg, len);\n\t\telse\n#endif\n\t\t\tret = do_replace(sock_net(sk), arg, len);\n\t\tbreak;\n\n\tcase ARPT_SO_SET_ADD_COUNTERS:\n\t\tret = do_add_counters(sock_net(sk), arg, len);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int do_arpt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n{\n\tint ret;\n\n\tif (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase ARPT_SO_GET_INFO:\n\t\tret = get_info(sock_net(sk), user, len);\n\t\tbreak;\n\n\tcase ARPT_SO_GET_ENTRIES:\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\t\tif (in_compat_syscall())\n\t\t\tret = compat_get_entries(sock_net(sk), user, len);\n\t\telse\n#endif\n\t\t\tret = get_entries(sock_net(sk), user, len);\n\t\tbreak;\n\n\tcase ARPT_SO_GET_REVISION_TARGET: {\n\t\tstruct xt_get_revision rev;\n\n\t\tif (*len != sizeof(rev)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(&rev, user, sizeof(rev)) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\trev.name[sizeof(rev.name)-1] = 0;\n\n\t\ttry_then_request_module(xt_find_revision(NFPROTO_ARP, rev.name,\n\t\t\t\t\t\t\t rev.revision, 1, &ret),\n\t\t\t\t\t\"arpt_%s\", rev.name);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void __arpt_unregister_table(struct net *net, struct xt_table *table)\n{\n\tstruct xt_table_info *private;\n\tvoid *loc_cpu_entry;\n\tstruct module *table_owner = table->me;\n\tstruct arpt_entry *iter;\n\n\tprivate = xt_unregister_table(table);\n\n\t \n\tloc_cpu_entry = private->entries;\n\txt_entry_foreach(iter, loc_cpu_entry, private->size)\n\t\tcleanup_entry(iter, net);\n\tif (private->number > private->initial_entries)\n\t\tmodule_put(table_owner);\n\txt_free_table_info(private);\n}\n\nint arpt_register_table(struct net *net,\n\t\t\tconst struct xt_table *table,\n\t\t\tconst struct arpt_replace *repl,\n\t\t\tconst struct nf_hook_ops *template_ops)\n{\n\tstruct nf_hook_ops *ops;\n\tunsigned int num_ops;\n\tint ret, i;\n\tstruct xt_table_info *newinfo;\n\tstruct xt_table_info bootstrap = {0};\n\tvoid *loc_cpu_entry;\n\tstruct xt_table *new_table;\n\n\tnewinfo = xt_alloc_table_info(repl->size);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\n\tloc_cpu_entry = newinfo->entries;\n\tmemcpy(loc_cpu_entry, repl->entries, repl->size);\n\n\tret = translate_table(net, newinfo, loc_cpu_entry, repl);\n\tif (ret != 0) {\n\t\txt_free_table_info(newinfo);\n\t\treturn ret;\n\t}\n\n\tnew_table = xt_register_table(net, table, &bootstrap, newinfo);\n\tif (IS_ERR(new_table)) {\n\t\tstruct arpt_entry *iter;\n\n\t\txt_entry_foreach(iter, loc_cpu_entry, newinfo->size)\n\t\t\tcleanup_entry(iter, net);\n\t\txt_free_table_info(newinfo);\n\t\treturn PTR_ERR(new_table);\n\t}\n\n\tnum_ops = hweight32(table->valid_hooks);\n\tif (num_ops == 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tops = kmemdup(template_ops, sizeof(*ops) * num_ops, GFP_KERNEL);\n\tif (!ops) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tfor (i = 0; i < num_ops; i++)\n\t\tops[i].priv = new_table;\n\n\tnew_table->ops = ops;\n\n\tret = nf_register_net_hooks(net, ops, num_ops);\n\tif (ret != 0)\n\t\tgoto out_free;\n\n\treturn ret;\n\nout_free:\n\t__arpt_unregister_table(net, new_table);\n\treturn ret;\n}\n\nvoid arpt_unregister_table_pre_exit(struct net *net, const char *name)\n{\n\tstruct xt_table *table = xt_find_table(net, NFPROTO_ARP, name);\n\n\tif (table)\n\t\tnf_unregister_net_hooks(net, table->ops, hweight32(table->valid_hooks));\n}\nEXPORT_SYMBOL(arpt_unregister_table_pre_exit);\n\nvoid arpt_unregister_table(struct net *net, const char *name)\n{\n\tstruct xt_table *table = xt_find_table(net, NFPROTO_ARP, name);\n\n\tif (table)\n\t\t__arpt_unregister_table(net, table);\n}\n\n \nstatic struct xt_target arpt_builtin_tg[] __read_mostly = {\n\t{\n\t\t.name             = XT_STANDARD_TARGET,\n\t\t.targetsize       = sizeof(int),\n\t\t.family           = NFPROTO_ARP,\n#ifdef CONFIG_NETFILTER_XTABLES_COMPAT\n\t\t.compatsize       = sizeof(compat_int_t),\n\t\t.compat_from_user = compat_standard_from_user,\n\t\t.compat_to_user   = compat_standard_to_user,\n#endif\n\t},\n\t{\n\t\t.name             = XT_ERROR_TARGET,\n\t\t.target           = arpt_error,\n\t\t.targetsize       = XT_FUNCTION_MAXNAMELEN,\n\t\t.family           = NFPROTO_ARP,\n\t},\n};\n\nstatic struct nf_sockopt_ops arpt_sockopts = {\n\t.pf\t\t= PF_INET,\n\t.set_optmin\t= ARPT_BASE_CTL,\n\t.set_optmax\t= ARPT_SO_SET_MAX+1,\n\t.set\t\t= do_arpt_set_ctl,\n\t.get_optmin\t= ARPT_BASE_CTL,\n\t.get_optmax\t= ARPT_SO_GET_MAX+1,\n\t.get\t\t= do_arpt_get_ctl,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __net_init arp_tables_net_init(struct net *net)\n{\n\treturn xt_proto_init(net, NFPROTO_ARP);\n}\n\nstatic void __net_exit arp_tables_net_exit(struct net *net)\n{\n\txt_proto_fini(net, NFPROTO_ARP);\n}\n\nstatic struct pernet_operations arp_tables_net_ops = {\n\t.init = arp_tables_net_init,\n\t.exit = arp_tables_net_exit,\n};\n\nstatic int __init arp_tables_init(void)\n{\n\tint ret;\n\n\tret = register_pernet_subsys(&arp_tables_net_ops);\n\tif (ret < 0)\n\t\tgoto err1;\n\n\t \n\tret = xt_register_targets(arpt_builtin_tg, ARRAY_SIZE(arpt_builtin_tg));\n\tif (ret < 0)\n\t\tgoto err2;\n\n\t \n\tret = nf_register_sockopt(&arpt_sockopts);\n\tif (ret < 0)\n\t\tgoto err4;\n\n\treturn 0;\n\nerr4:\n\txt_unregister_targets(arpt_builtin_tg, ARRAY_SIZE(arpt_builtin_tg));\nerr2:\n\tunregister_pernet_subsys(&arp_tables_net_ops);\nerr1:\n\treturn ret;\n}\n\nstatic void __exit arp_tables_fini(void)\n{\n\tnf_unregister_sockopt(&arpt_sockopts);\n\txt_unregister_targets(arpt_builtin_tg, ARRAY_SIZE(arpt_builtin_tg));\n\tunregister_pernet_subsys(&arp_tables_net_ops);\n}\n\nEXPORT_SYMBOL(arpt_register_table);\nEXPORT_SYMBOL(arpt_unregister_table);\nEXPORT_SYMBOL(arpt_do_table);\n\nmodule_init(arp_tables_init);\nmodule_exit(arp_tables_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}