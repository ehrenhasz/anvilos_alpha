{
  "module_name": "nft_fib_ipv4.c",
  "hash_id": "17c1d58f94ca8d17dabf8acf03052cd0a48675d73e2157c35d109150f1ec6061",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter/nft_fib_ipv4.c",
  "human_readable_source": "\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nft_fib.h>\n\n#include <net/ip_fib.h>\n#include <net/route.h>\n\n \nstatic __be32 get_saddr(__be32 addr)\n{\n\tif (ipv4_is_multicast(addr) || ipv4_is_lbcast(addr) ||\n\t    ipv4_is_zeronet(addr))\n\t\treturn 0;\n\treturn addr;\n}\n\n#define DSCP_BITS     0xfc\n\nvoid nft_fib4_eval_type(const struct nft_expr *expr, struct nft_regs *regs,\n\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tconst struct nft_fib *priv = nft_expr_priv(expr);\n\tint noff = skb_network_offset(pkt->skb);\n\tu32 *dst = &regs->data[priv->dreg];\n\tconst struct net_device *dev = NULL;\n\tstruct iphdr *iph, _iph;\n\t__be32 addr;\n\n\tif (priv->flags & NFTA_FIB_F_IIF)\n\t\tdev = nft_in(pkt);\n\telse if (priv->flags & NFTA_FIB_F_OIF)\n\t\tdev = nft_out(pkt);\n\n\tiph = skb_header_pointer(pkt->skb, noff, sizeof(_iph), &_iph);\n\tif (!iph) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\tif (priv->flags & NFTA_FIB_F_DADDR)\n\t\taddr = iph->daddr;\n\telse\n\t\taddr = iph->saddr;\n\n\t*dst = inet_dev_addr_type(nft_net(pkt), dev, addr);\n}\nEXPORT_SYMBOL_GPL(nft_fib4_eval_type);\n\nvoid nft_fib4_eval(const struct nft_expr *expr, struct nft_regs *regs,\n\t\t   const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_fib *priv = nft_expr_priv(expr);\n\tint noff = skb_network_offset(pkt->skb);\n\tu32 *dest = &regs->data[priv->dreg];\n\tstruct iphdr *iph, _iph;\n\tstruct fib_result res;\n\tstruct flowi4 fl4 = {\n\t\t.flowi4_scope = RT_SCOPE_UNIVERSE,\n\t\t.flowi4_iif = LOOPBACK_IFINDEX,\n\t\t.flowi4_uid = sock_net_uid(nft_net(pkt), NULL),\n\t};\n\tconst struct net_device *oif;\n\tconst struct net_device *found;\n\n\t \n\tif (priv->flags & NFTA_FIB_F_OIF)\n\t\toif = nft_out(pkt);\n\telse if (priv->flags & NFTA_FIB_F_IIF)\n\t\toif = nft_in(pkt);\n\telse\n\t\toif = NULL;\n\n\tif (priv->flags & NFTA_FIB_F_IIF)\n\t\tfl4.flowi4_l3mdev = l3mdev_master_ifindex_rcu(oif);\n\n\tif (nft_hook(pkt) == NF_INET_PRE_ROUTING &&\n\t    nft_fib_is_loopback(pkt->skb, nft_in(pkt))) {\n\t\tnft_fib_store_result(dest, priv, nft_in(pkt));\n\t\treturn;\n\t}\n\n\tiph = skb_header_pointer(pkt->skb, noff, sizeof(_iph), &_iph);\n\tif (!iph) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\tif (ipv4_is_zeronet(iph->saddr)) {\n\t\tif (ipv4_is_lbcast(iph->daddr) ||\n\t\t    ipv4_is_local_multicast(iph->daddr)) {\n\t\t\tnft_fib_store_result(dest, priv, pkt->skb->dev);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (priv->flags & NFTA_FIB_F_MARK)\n\t\tfl4.flowi4_mark = pkt->skb->mark;\n\n\tfl4.flowi4_tos = iph->tos & DSCP_BITS;\n\n\tif (priv->flags & NFTA_FIB_F_DADDR) {\n\t\tfl4.daddr = iph->daddr;\n\t\tfl4.saddr = get_saddr(iph->saddr);\n\t} else {\n\t\tif (nft_hook(pkt) == NF_INET_FORWARD &&\n\t\t    priv->flags & NFTA_FIB_F_IIF)\n\t\t\tfl4.flowi4_iif = nft_out(pkt)->ifindex;\n\n\t\tfl4.daddr = iph->saddr;\n\t\tfl4.saddr = get_saddr(iph->daddr);\n\t}\n\n\t*dest = 0;\n\n\tif (fib_lookup(nft_net(pkt), &fl4, &res, FIB_LOOKUP_IGNORE_LINKSTATE))\n\t\treturn;\n\n\tswitch (res.type) {\n\tcase RTN_UNICAST:\n\t\tbreak;\n\tcase RTN_LOCAL:  \n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!oif) {\n\t\tfound = FIB_RES_DEV(res);\n\t} else {\n\t\tif (!fib_info_nh_uses_dev(res.fi, oif))\n\t\t\treturn;\n\t\tfound = oif;\n\t}\n\n\tnft_fib_store_result(dest, priv, found);\n}\nEXPORT_SYMBOL_GPL(nft_fib4_eval);\n\nstatic struct nft_expr_type nft_fib4_type;\n\nstatic const struct nft_expr_ops nft_fib4_type_ops = {\n\t.type\t\t= &nft_fib4_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_fib)),\n\t.eval\t\t= nft_fib4_eval_type,\n\t.init\t\t= nft_fib_init,\n\t.dump\t\t= nft_fib_dump,\n\t.validate\t= nft_fib_validate,\n\t.reduce\t\t= nft_fib_reduce,\n};\n\nstatic const struct nft_expr_ops nft_fib4_ops = {\n\t.type\t\t= &nft_fib4_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_fib)),\n\t.eval\t\t= nft_fib4_eval,\n\t.init\t\t= nft_fib_init,\n\t.dump\t\t= nft_fib_dump,\n\t.validate\t= nft_fib_validate,\n\t.reduce\t\t= nft_fib_reduce,\n};\n\nstatic const struct nft_expr_ops *\nnft_fib4_select_ops(const struct nft_ctx *ctx,\n\t\t    const struct nlattr * const tb[])\n{\n\tenum nft_fib_result result;\n\n\tif (!tb[NFTA_FIB_RESULT])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tresult = ntohl(nla_get_be32(tb[NFTA_FIB_RESULT]));\n\n\tswitch (result) {\n\tcase NFT_FIB_RESULT_OIF:\n\t\treturn &nft_fib4_ops;\n\tcase NFT_FIB_RESULT_OIFNAME:\n\t\treturn &nft_fib4_ops;\n\tcase NFT_FIB_RESULT_ADDRTYPE:\n\t\treturn &nft_fib4_type_ops;\n\tdefault:\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n}\n\nstatic struct nft_expr_type nft_fib4_type __read_mostly = {\n\t.name\t\t= \"fib\",\n\t.select_ops\t= nft_fib4_select_ops,\n\t.policy\t\t= nft_fib_policy,\n\t.maxattr\t= NFTA_FIB_MAX,\n\t.family\t\t= NFPROTO_IPV4,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_fib4_module_init(void)\n{\n\treturn nft_register_expr(&nft_fib4_type);\n}\n\nstatic void __exit nft_fib4_module_exit(void)\n{\n\tnft_unregister_expr(&nft_fib4_type);\n}\n\nmodule_init(nft_fib4_module_init);\nmodule_exit(nft_fib4_module_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Florian Westphal <fw@strlen.de>\");\nMODULE_ALIAS_NFT_AF_EXPR(2, \"fib\");\nMODULE_DESCRIPTION(\"nftables fib / ip route lookup support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}