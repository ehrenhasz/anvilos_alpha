{
  "module_name": "ipt_rpfilter.c",
  "hash_id": "673c61b39af6849cf25a7fd0c8d1b12042df8a7b1eb76fe0242b0c61330f9716",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter/ipt_rpfilter.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/ip.h>\n#include <net/ip.h>\n#include <net/ip_fib.h>\n#include <net/route.h>\n\n#include <linux/netfilter/xt_rpfilter.h>\n#include <linux/netfilter/x_tables.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Florian Westphal <fw@strlen.de>\");\nMODULE_DESCRIPTION(\"iptables: ipv4 reverse path filter match\");\n\n \nstatic __be32 rpfilter_get_saddr(__be32 addr)\n{\n\tif (ipv4_is_multicast(addr) || ipv4_is_lbcast(addr) ||\n\t    ipv4_is_zeronet(addr))\n\t\treturn 0;\n\treturn addr;\n}\n\nstatic bool rpfilter_lookup_reverse(struct net *net, struct flowi4 *fl4,\n\t\t\t\tconst struct net_device *dev, u8 flags)\n{\n\tstruct fib_result res;\n\n\tif (fib_lookup(net, fl4, &res, FIB_LOOKUP_IGNORE_LINKSTATE))\n\t\treturn false;\n\n\tif (res.type != RTN_UNICAST) {\n\t\tif (res.type != RTN_LOCAL || !(flags & XT_RPFILTER_ACCEPT_LOCAL))\n\t\t\treturn false;\n\t}\n\treturn fib_info_nh_uses_dev(res.fi, dev) || flags & XT_RPFILTER_LOOSE;\n}\n\nstatic bool\nrpfilter_is_loopback(const struct sk_buff *skb, const struct net_device *in)\n{\n\treturn skb->pkt_type == PACKET_LOOPBACK || in->flags & IFF_LOOPBACK;\n}\n\nstatic bool rpfilter_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_rpfilter_info *info;\n\tconst struct iphdr *iph;\n\tstruct flowi4 flow;\n\tbool invert;\n\n\tinfo = par->matchinfo;\n\tinvert = info->flags & XT_RPFILTER_INVERT;\n\n\tif (rpfilter_is_loopback(skb, xt_in(par)))\n\t\treturn true ^ invert;\n\n\tiph = ip_hdr(skb);\n\tif (ipv4_is_zeronet(iph->saddr)) {\n\t\tif (ipv4_is_lbcast(iph->daddr) ||\n\t\t    ipv4_is_local_multicast(iph->daddr))\n\t\t\treturn true ^ invert;\n\t}\n\n\tmemset(&flow, 0, sizeof(flow));\n\tflow.flowi4_iif = LOOPBACK_IFINDEX;\n\tflow.daddr = iph->saddr;\n\tflow.saddr = rpfilter_get_saddr(iph->daddr);\n\tflow.flowi4_mark = info->flags & XT_RPFILTER_VALID_MARK ? skb->mark : 0;\n\tflow.flowi4_tos = iph->tos & IPTOS_RT_MASK;\n\tflow.flowi4_scope = RT_SCOPE_UNIVERSE;\n\tflow.flowi4_l3mdev = l3mdev_master_ifindex_rcu(xt_in(par));\n\tflow.flowi4_uid = sock_net_uid(xt_net(par), NULL);\n\n\treturn rpfilter_lookup_reverse(xt_net(par), &flow, xt_in(par), info->flags) ^ invert;\n}\n\nstatic int rpfilter_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_rpfilter_info *info = par->matchinfo;\n\tunsigned int options = ~XT_RPFILTER_OPTION_MASK;\n\tif (info->flags & options) {\n\t\tpr_info_ratelimited(\"unknown options\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (strcmp(par->table, \"mangle\") != 0 &&\n\t    strcmp(par->table, \"raw\") != 0) {\n\t\tpr_info_ratelimited(\"only valid in \\'raw\\' or \\'mangle\\' table, not \\'%s\\'\\n\",\n\t\t\t\t    par->table);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct xt_match rpfilter_mt_reg __read_mostly = {\n\t.name\t\t= \"rpfilter\",\n\t.family\t\t= NFPROTO_IPV4,\n\t.checkentry\t= rpfilter_check,\n\t.match\t\t= rpfilter_mt,\n\t.matchsize\t= sizeof(struct xt_rpfilter_info),\n\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING),\n\t.me\t\t= THIS_MODULE\n};\n\nstatic int __init rpfilter_mt_init(void)\n{\n\treturn xt_register_match(&rpfilter_mt_reg);\n}\n\nstatic void __exit rpfilter_mt_exit(void)\n{\n\txt_unregister_match(&rpfilter_mt_reg);\n}\n\nmodule_init(rpfilter_mt_init);\nmodule_exit(rpfilter_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}