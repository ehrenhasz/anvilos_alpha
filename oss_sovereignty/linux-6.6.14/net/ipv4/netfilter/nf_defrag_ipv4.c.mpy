{
  "module_name": "nf_defrag_ipv4.c",
  "hash_id": "e49607f354534ccecf95748e1d4b36580d185e61efd7c99abe3785cf1e8674cc",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter/nf_defrag_ipv4.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/ip.h>\n#include <linux/netfilter.h>\n#include <linux/module.h>\n#include <linux/rcupdate.h>\n#include <linux/skbuff.h>\n#include <net/netns/generic.h>\n#include <net/route.h>\n#include <net/ip.h>\n\n#include <linux/netfilter_bridge.h>\n#include <linux/netfilter_ipv4.h>\n#include <net/netfilter/ipv4/nf_defrag_ipv4.h>\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#include <net/netfilter/nf_conntrack.h>\n#endif\n#include <net/netfilter/nf_conntrack_zones.h>\n\nstatic DEFINE_MUTEX(defrag4_mutex);\n\nstatic int nf_ct_ipv4_gather_frags(struct net *net, struct sk_buff *skb,\n\t\t\t\t   u_int32_t user)\n{\n\tint err;\n\n\tlocal_bh_disable();\n\terr = ip_defrag(net, skb, user);\n\tlocal_bh_enable();\n\n\tif (!err)\n\t\tskb->ignore_df = 1;\n\n\treturn err;\n}\n\nstatic enum ip_defrag_users nf_ct_defrag_user(unsigned int hooknum,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tu16 zone_id = NF_CT_DEFAULT_ZONE_ID;\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (skb_nfct(skb)) {\n\t\tenum ip_conntrack_info ctinfo;\n\t\tconst struct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\n\t\tzone_id = nf_ct_zone_id(nf_ct_zone(ct), CTINFO2DIR(ctinfo));\n\t}\n#endif\n\tif (nf_bridge_in_prerouting(skb))\n\t\treturn IP_DEFRAG_CONNTRACK_BRIDGE_IN + zone_id;\n\n\tif (hooknum == NF_INET_PRE_ROUTING)\n\t\treturn IP_DEFRAG_CONNTRACK_IN + zone_id;\n\telse\n\t\treturn IP_DEFRAG_CONNTRACK_OUT + zone_id;\n}\n\nstatic unsigned int ipv4_conntrack_defrag(void *priv,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  const struct nf_hook_state *state)\n{\n\tstruct sock *sk = skb->sk;\n\n\tif (sk && sk_fullsock(sk) && (sk->sk_family == PF_INET) &&\n\t    inet_test_bit(NODEFRAG, sk))\n\t\treturn NF_ACCEPT;\n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#if !IS_ENABLED(CONFIG_NF_NAT)\n\t \n\tif (skb_nfct(skb) && !nf_ct_is_template((struct nf_conn *)skb_nfct(skb)))\n\t\treturn NF_ACCEPT;\n#endif\n\tif (skb->_nfct == IP_CT_UNTRACKED)\n\t\treturn NF_ACCEPT;\n#endif\n\t \n\tif (ip_is_fragment(ip_hdr(skb))) {\n\t\tenum ip_defrag_users user =\n\t\t\tnf_ct_defrag_user(state->hook, skb);\n\n\t\tif (nf_ct_ipv4_gather_frags(state->net, skb, user))\n\t\t\treturn NF_STOLEN;\n\t}\n\treturn NF_ACCEPT;\n}\n\nstatic const struct nf_hook_ops ipv4_defrag_ops[] = {\n\t{\n\t\t.hook\t\t= ipv4_conntrack_defrag,\n\t\t.pf\t\t= NFPROTO_IPV4,\n\t\t.hooknum\t= NF_INET_PRE_ROUTING,\n\t\t.priority\t= NF_IP_PRI_CONNTRACK_DEFRAG,\n\t},\n\t{\n\t\t.hook           = ipv4_conntrack_defrag,\n\t\t.pf             = NFPROTO_IPV4,\n\t\t.hooknum        = NF_INET_LOCAL_OUT,\n\t\t.priority       = NF_IP_PRI_CONNTRACK_DEFRAG,\n\t},\n};\n\nstatic void __net_exit defrag4_net_exit(struct net *net)\n{\n\tif (net->nf.defrag_ipv4_users) {\n\t\tnf_unregister_net_hooks(net, ipv4_defrag_ops,\n\t\t\t\t\tARRAY_SIZE(ipv4_defrag_ops));\n\t\tnet->nf.defrag_ipv4_users = 0;\n\t}\n}\n\nstatic const struct nf_defrag_hook defrag_hook = {\n\t.owner = THIS_MODULE,\n\t.enable = nf_defrag_ipv4_enable,\n\t.disable = nf_defrag_ipv4_disable,\n};\n\nstatic struct pernet_operations defrag4_net_ops = {\n\t.exit = defrag4_net_exit,\n};\n\nstatic int __init nf_defrag_init(void)\n{\n\tint err;\n\n\terr = register_pernet_subsys(&defrag4_net_ops);\n\tif (err)\n\t\treturn err;\n\n\trcu_assign_pointer(nf_defrag_v4_hook, &defrag_hook);\n\treturn err;\n}\n\nstatic void __exit nf_defrag_fini(void)\n{\n\trcu_assign_pointer(nf_defrag_v4_hook, NULL);\n\tunregister_pernet_subsys(&defrag4_net_ops);\n}\n\nint nf_defrag_ipv4_enable(struct net *net)\n{\n\tint err = 0;\n\n\tmutex_lock(&defrag4_mutex);\n\tif (net->nf.defrag_ipv4_users == UINT_MAX) {\n\t\terr = -EOVERFLOW;\n\t\tgoto out_unlock;\n\t}\n\n\tif (net->nf.defrag_ipv4_users) {\n\t\tnet->nf.defrag_ipv4_users++;\n\t\tgoto out_unlock;\n\t}\n\n\terr = nf_register_net_hooks(net, ipv4_defrag_ops,\n\t\t\t\t    ARRAY_SIZE(ipv4_defrag_ops));\n\tif (err == 0)\n\t\tnet->nf.defrag_ipv4_users = 1;\n\n out_unlock:\n\tmutex_unlock(&defrag4_mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nf_defrag_ipv4_enable);\n\nvoid nf_defrag_ipv4_disable(struct net *net)\n{\n\tmutex_lock(&defrag4_mutex);\n\tif (net->nf.defrag_ipv4_users) {\n\t\tnet->nf.defrag_ipv4_users--;\n\t\tif (net->nf.defrag_ipv4_users == 0)\n\t\t\tnf_unregister_net_hooks(net, ipv4_defrag_ops,\n\t\t\t\t\t\tARRAY_SIZE(ipv4_defrag_ops));\n\t}\n\n\tmutex_unlock(&defrag4_mutex);\n}\nEXPORT_SYMBOL_GPL(nf_defrag_ipv4_disable);\n\nmodule_init(nf_defrag_init);\nmodule_exit(nf_defrag_fini);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}