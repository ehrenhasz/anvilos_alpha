{
  "module_name": "iptable_mangle.c",
  "hash_id": "b1128d5cc636cb1e3edc1508825cb081c2220a098009b741e45535bbd612631d",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter/iptable_mangle.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/route.h>\n#include <linux/ip.h>\n#include <net/ip.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Netfilter Core Team <coreteam@netfilter.org>\");\nMODULE_DESCRIPTION(\"iptables mangle table\");\n\n#define MANGLE_VALID_HOOKS ((1 << NF_INET_PRE_ROUTING) | \\\n\t\t\t    (1 << NF_INET_LOCAL_IN) | \\\n\t\t\t    (1 << NF_INET_FORWARD) | \\\n\t\t\t    (1 << NF_INET_LOCAL_OUT) | \\\n\t\t\t    (1 << NF_INET_POST_ROUTING))\n\nstatic const struct xt_table packet_mangler = {\n\t.name\t\t= \"mangle\",\n\t.valid_hooks\t= MANGLE_VALID_HOOKS,\n\t.me\t\t= THIS_MODULE,\n\t.af\t\t= NFPROTO_IPV4,\n\t.priority\t= NF_IP_PRI_MANGLE,\n};\n\nstatic unsigned int\nipt_mangle_out(void *priv, struct sk_buff *skb, const struct nf_hook_state *state)\n{\n\tunsigned int ret;\n\tconst struct iphdr *iph;\n\tu_int8_t tos;\n\t__be32 saddr, daddr;\n\tu_int32_t mark;\n\tint err;\n\n\t \n\tmark = skb->mark;\n\tiph = ip_hdr(skb);\n\tsaddr = iph->saddr;\n\tdaddr = iph->daddr;\n\ttos = iph->tos;\n\n\tret = ipt_do_table(priv, skb, state);\n\t \n\tif (ret != NF_DROP && ret != NF_STOLEN) {\n\t\tiph = ip_hdr(skb);\n\n\t\tif (iph->saddr != saddr ||\n\t\t    iph->daddr != daddr ||\n\t\t    skb->mark != mark ||\n\t\t    iph->tos != tos) {\n\t\t\terr = ip_route_me_harder(state->net, state->sk, skb, RTN_UNSPEC);\n\t\t\tif (err < 0)\n\t\t\t\tret = NF_DROP_ERR(err);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic unsigned int\niptable_mangle_hook(void *priv,\n\t\t     struct sk_buff *skb,\n\t\t     const struct nf_hook_state *state)\n{\n\tif (state->hook == NF_INET_LOCAL_OUT)\n\t\treturn ipt_mangle_out(priv, skb, state);\n\treturn ipt_do_table(priv, skb, state);\n}\n\nstatic struct nf_hook_ops *mangle_ops __read_mostly;\nstatic int iptable_mangle_table_init(struct net *net)\n{\n\tstruct ipt_replace *repl;\n\tint ret;\n\n\trepl = ipt_alloc_initial_table(&packet_mangler);\n\tif (repl == NULL)\n\t\treturn -ENOMEM;\n\tret = ipt_register_table(net, &packet_mangler, repl, mangle_ops);\n\tkfree(repl);\n\treturn ret;\n}\n\nstatic void __net_exit iptable_mangle_net_pre_exit(struct net *net)\n{\n\tipt_unregister_table_pre_exit(net, \"mangle\");\n}\n\nstatic void __net_exit iptable_mangle_net_exit(struct net *net)\n{\n\tipt_unregister_table_exit(net, \"mangle\");\n}\n\nstatic struct pernet_operations iptable_mangle_net_ops = {\n\t.pre_exit = iptable_mangle_net_pre_exit,\n\t.exit = iptable_mangle_net_exit,\n};\n\nstatic int __init iptable_mangle_init(void)\n{\n\tint ret = xt_register_template(&packet_mangler,\n\t\t\t\t       iptable_mangle_table_init);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmangle_ops = xt_hook_ops_alloc(&packet_mangler, iptable_mangle_hook);\n\tif (IS_ERR(mangle_ops)) {\n\t\txt_unregister_template(&packet_mangler);\n\t\tret = PTR_ERR(mangle_ops);\n\t\treturn ret;\n\t}\n\n\tret = register_pernet_subsys(&iptable_mangle_net_ops);\n\tif (ret < 0) {\n\t\txt_unregister_template(&packet_mangler);\n\t\tkfree(mangle_ops);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit iptable_mangle_fini(void)\n{\n\tunregister_pernet_subsys(&iptable_mangle_net_ops);\n\txt_unregister_template(&packet_mangler);\n\tkfree(mangle_ops);\n}\n\nmodule_init(iptable_mangle_init);\nmodule_exit(iptable_mangle_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}