{
  "module_name": "nf_tproxy_ipv4.c",
  "hash_id": "7ef1103e1b1b2553fccc586e31d0243efe816df034390164ac93036010ed7296",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter/nf_tproxy_ipv4.c",
  "human_readable_source": "\n \n\n#include <net/netfilter/nf_tproxy.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/inet_sock.h>\n#include <linux/ip.h>\n#include <net/checksum.h>\n#include <net/udp.h>\n#include <net/tcp.h>\n#include <linux/inetdevice.h>\n\nstruct sock *\nnf_tproxy_handle_time_wait4(struct net *net, struct sk_buff *skb,\n\t\t\t __be32 laddr, __be16 lport, struct sock *sk)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct tcphdr _hdr, *hp;\n\n\thp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_hdr), &_hdr);\n\tif (hp == NULL) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn NULL;\n\t}\n\n\tif (hp->syn && !hp->rst && !hp->ack && !hp->fin) {\n\t\t \n\t\tstruct sock *sk2;\n\n\t\tsk2 = nf_tproxy_get_sock_v4(net, skb, iph->protocol,\n\t\t\t\t\t    iph->saddr, laddr ? laddr : iph->daddr,\n\t\t\t\t\t    hp->source, lport ? lport : hp->dest,\n\t\t\t\t\t    skb->dev, NF_TPROXY_LOOKUP_LISTENER);\n\t\tif (sk2) {\n\t\t\tnf_tproxy_twsk_deschedule_put(inet_twsk(sk));\n\t\t\tsk = sk2;\n\t\t}\n\t}\n\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(nf_tproxy_handle_time_wait4);\n\n__be32 nf_tproxy_laddr4(struct sk_buff *skb, __be32 user_laddr, __be32 daddr)\n{\n\tconst struct in_ifaddr *ifa;\n\tstruct in_device *indev;\n\t__be32 laddr;\n\n\tif (user_laddr)\n\t\treturn user_laddr;\n\n\tladdr = 0;\n\tindev = __in_dev_get_rcu(skb->dev);\n\n\tin_dev_for_each_ifa_rcu(ifa, indev) {\n\t\tif (ifa->ifa_flags & IFA_F_SECONDARY)\n\t\t\tcontinue;\n\n\t\tladdr = ifa->ifa_local;\n\t\tbreak;\n\t}\n\n\treturn laddr ? laddr : daddr;\n}\nEXPORT_SYMBOL_GPL(nf_tproxy_laddr4);\n\nstruct sock *\nnf_tproxy_get_sock_v4(struct net *net, struct sk_buff *skb,\n\t\t      const u8 protocol,\n\t\t      const __be32 saddr, const __be32 daddr,\n\t\t      const __be16 sport, const __be16 dport,\n\t\t      const struct net_device *in,\n\t\t      const enum nf_tproxy_lookup_t lookup_type)\n{\n\tstruct inet_hashinfo *hinfo = net->ipv4.tcp_death_row.hashinfo;\n\tstruct sock *sk;\n\n\tswitch (protocol) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr _hdr, *hp;\n\n\t\thp = skb_header_pointer(skb, ip_hdrlen(skb),\n\t\t\t\t\tsizeof(struct tcphdr), &_hdr);\n\t\tif (hp == NULL)\n\t\t\treturn NULL;\n\n\t\tswitch (lookup_type) {\n\t\tcase NF_TPROXY_LOOKUP_LISTENER:\n\t\t\tsk = inet_lookup_listener(net, hinfo, skb,\n\t\t\t\t\t\t  ip_hdrlen(skb) + __tcp_hdrlen(hp),\n\t\t\t\t\t\t  saddr, sport, daddr, dport,\n\t\t\t\t\t\t  in->ifindex, 0);\n\n\t\t\tif (sk && !refcount_inc_not_zero(&sk->sk_refcnt))\n\t\t\t\tsk = NULL;\n\t\t\t \n\t\t\tbreak;\n\t\tcase NF_TPROXY_LOOKUP_ESTABLISHED:\n\t\t\tsk = inet_lookup_established(net, hinfo, saddr, sport,\n\t\t\t\t\t\t     daddr, dport, in->ifindex);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tbreak;\n\t\t}\n\tcase IPPROTO_UDP:\n\t\tsk = udp4_lib_lookup(net, saddr, sport, daddr, dport,\n\t\t\t\t     in->ifindex);\n\t\tif (sk) {\n\t\t\tint connected = (sk->sk_state == TCP_ESTABLISHED);\n\t\t\tint wildcard = (inet_sk(sk)->inet_rcv_saddr == 0);\n\n\t\t\t \n\t\t\tif ((lookup_type == NF_TPROXY_LOOKUP_ESTABLISHED &&\n\t\t\t      (!connected || wildcard)) ||\n\t\t\t    (lookup_type == NF_TPROXY_LOOKUP_LISTENER && connected)) {\n\t\t\t\tsock_put(sk);\n\t\t\t\tsk = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tsk = NULL;\n\t}\n\n\tpr_debug(\"tproxy socket lookup: proto %u %08x:%u -> %08x:%u, lookup type: %d, sock %p\\n\",\n\t\t protocol, ntohl(saddr), ntohs(sport), ntohl(daddr), ntohs(dport), lookup_type, sk);\n\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(nf_tproxy_get_sock_v4);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Balazs Scheidler, Krisztian Kovacs\");\nMODULE_DESCRIPTION(\"Netfilter IPv4 transparent proxy support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}