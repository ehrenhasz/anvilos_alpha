{
  "module_name": "ipt_ECN.c",
  "hash_id": "8fdcbcafb3e599e999736b8478e6be26f6d81d6413c93dac392545d527af04df",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter/ipt_ECN.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/in.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <net/ip.h>\n#include <linux/tcp.h>\n#include <net/checksum.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv4/ip_tables.h>\n#include <linux/netfilter_ipv4/ipt_ECN.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Harald Welte <laforge@netfilter.org>\");\nMODULE_DESCRIPTION(\"Xtables: Explicit Congestion Notification (ECN) flag modification\");\n\n \nstatic inline bool\nset_ect_ip(struct sk_buff *skb, const struct ipt_ECN_info *einfo)\n{\n\tstruct iphdr *iph = ip_hdr(skb);\n\n\tif ((iph->tos & IPT_ECN_IP_MASK) != (einfo->ip_ect & IPT_ECN_IP_MASK)) {\n\t\t__u8 oldtos;\n\t\tif (skb_ensure_writable(skb, sizeof(struct iphdr)))\n\t\t\treturn false;\n\t\tiph = ip_hdr(skb);\n\t\toldtos = iph->tos;\n\t\tiph->tos &= ~IPT_ECN_IP_MASK;\n\t\tiph->tos |= (einfo->ip_ect & IPT_ECN_IP_MASK);\n\t\tcsum_replace2(&iph->check, htons(oldtos), htons(iph->tos));\n\t}\n\treturn true;\n}\n\n \nstatic inline bool\nset_ect_tcp(struct sk_buff *skb, const struct ipt_ECN_info *einfo)\n{\n\tstruct tcphdr _tcph, *tcph;\n\t__be16 oldval;\n\n\t \n\ttcph = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_tcph), &_tcph);\n\tif (!tcph)\n\t\treturn false;\n\n\tif ((!(einfo->operation & IPT_ECN_OP_SET_ECE) ||\n\t     tcph->ece == einfo->proto.tcp.ece) &&\n\t    (!(einfo->operation & IPT_ECN_OP_SET_CWR) ||\n\t     tcph->cwr == einfo->proto.tcp.cwr))\n\t\treturn true;\n\n\tif (skb_ensure_writable(skb, ip_hdrlen(skb) + sizeof(*tcph)))\n\t\treturn false;\n\ttcph = (void *)ip_hdr(skb) + ip_hdrlen(skb);\n\n\toldval = ((__be16 *)tcph)[6];\n\tif (einfo->operation & IPT_ECN_OP_SET_ECE)\n\t\ttcph->ece = einfo->proto.tcp.ece;\n\tif (einfo->operation & IPT_ECN_OP_SET_CWR)\n\t\ttcph->cwr = einfo->proto.tcp.cwr;\n\n\tinet_proto_csum_replace2(&tcph->check, skb,\n\t\t\t\t oldval, ((__be16 *)tcph)[6], false);\n\treturn true;\n}\n\nstatic unsigned int\necn_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct ipt_ECN_info *einfo = par->targinfo;\n\n\tif (einfo->operation & IPT_ECN_OP_SET_IP)\n\t\tif (!set_ect_ip(skb, einfo))\n\t\t\treturn NF_DROP;\n\n\tif (einfo->operation & (IPT_ECN_OP_SET_ECE | IPT_ECN_OP_SET_CWR) &&\n\t    ip_hdr(skb)->protocol == IPPROTO_TCP)\n\t\tif (!set_ect_tcp(skb, einfo))\n\t\t\treturn NF_DROP;\n\n\treturn XT_CONTINUE;\n}\n\nstatic int ecn_tg_check(const struct xt_tgchk_param *par)\n{\n\tconst struct ipt_ECN_info *einfo = par->targinfo;\n\tconst struct ipt_entry *e = par->entryinfo;\n\n\tif (einfo->operation & IPT_ECN_OP_MASK)\n\t\treturn -EINVAL;\n\n\tif (einfo->ip_ect & ~IPT_ECN_IP_MASK)\n\t\treturn -EINVAL;\n\n\tif ((einfo->operation & (IPT_ECN_OP_SET_ECE|IPT_ECN_OP_SET_CWR)) &&\n\t    (e->ip.proto != IPPROTO_TCP || (e->ip.invflags & XT_INV_PROTO))) {\n\t\tpr_info_ratelimited(\"cannot use operation on non-tcp rule\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic struct xt_target ecn_tg_reg __read_mostly = {\n\t.name\t\t= \"ECN\",\n\t.family\t\t= NFPROTO_IPV4,\n\t.target\t\t= ecn_tg,\n\t.targetsize\t= sizeof(struct ipt_ECN_info),\n\t.table\t\t= \"mangle\",\n\t.checkentry\t= ecn_tg_check,\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init ecn_tg_init(void)\n{\n\treturn xt_register_target(&ecn_tg_reg);\n}\n\nstatic void __exit ecn_tg_exit(void)\n{\n\txt_unregister_target(&ecn_tg_reg);\n}\n\nmodule_init(ecn_tg_init);\nmodule_exit(ecn_tg_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}