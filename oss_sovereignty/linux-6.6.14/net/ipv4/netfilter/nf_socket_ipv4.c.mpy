{
  "module_name": "nf_socket_ipv4.c",
  "hash_id": "70b3823d36f53f002cf7dfb2b6bd902470ef78ffd118a072f29e71783e880859",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter/nf_socket_ipv4.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/icmp.h>\n#include <net/sock.h>\n#include <net/inet_sock.h>\n#include <net/netfilter/nf_socket.h>\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#include <net/netfilter/nf_conntrack.h>\n#endif\n\nstatic int\nextract_icmp4_fields(const struct sk_buff *skb, u8 *protocol,\n\t\t     __be32 *raddr, __be32 *laddr,\n\t\t     __be16 *rport, __be16 *lport)\n{\n\tunsigned int outside_hdrlen = ip_hdrlen(skb);\n\tstruct iphdr *inside_iph, _inside_iph;\n\tstruct icmphdr *icmph, _icmph;\n\t__be16 *ports, _ports[2];\n\n\ticmph = skb_header_pointer(skb, outside_hdrlen,\n\t\t\t\t   sizeof(_icmph), &_icmph);\n\tif (icmph == NULL)\n\t\treturn 1;\n\n\tif (!icmp_is_err(icmph->type))\n\t\treturn 1;\n\n\tinside_iph = skb_header_pointer(skb, outside_hdrlen +\n\t\t\t\t\tsizeof(struct icmphdr),\n\t\t\t\t\tsizeof(_inside_iph), &_inside_iph);\n\tif (inside_iph == NULL)\n\t\treturn 1;\n\n\tif (inside_iph->protocol != IPPROTO_TCP &&\n\t    inside_iph->protocol != IPPROTO_UDP)\n\t\treturn 1;\n\n\tports = skb_header_pointer(skb, outside_hdrlen +\n\t\t\t\t   sizeof(struct icmphdr) +\n\t\t\t\t   (inside_iph->ihl << 2),\n\t\t\t\t   sizeof(_ports), &_ports);\n\tif (ports == NULL)\n\t\treturn 1;\n\n\t \n\t*protocol = inside_iph->protocol;\n\t*laddr = inside_iph->saddr;\n\t*lport = ports[0];\n\t*raddr = inside_iph->daddr;\n\t*rport = ports[1];\n\n\treturn 0;\n}\n\nstatic struct sock *\nnf_socket_get_sock_v4(struct net *net, struct sk_buff *skb, const int doff,\n\t\t      const u8 protocol,\n\t\t      const __be32 saddr, const __be32 daddr,\n\t\t      const __be16 sport, const __be16 dport,\n\t\t      const struct net_device *in)\n{\n\tswitch (protocol) {\n\tcase IPPROTO_TCP:\n\t\treturn inet_lookup(net, net->ipv4.tcp_death_row.hashinfo,\n\t\t\t\t   skb, doff, saddr, sport, daddr, dport,\n\t\t\t\t   in->ifindex);\n\tcase IPPROTO_UDP:\n\t\treturn udp4_lib_lookup(net, saddr, sport, daddr, dport,\n\t\t\t\t       in->ifindex);\n\t}\n\treturn NULL;\n}\n\nstruct sock *nf_sk_lookup_slow_v4(struct net *net, const struct sk_buff *skb,\n\t\t\t\t  const struct net_device *indev)\n{\n\t__be32 daddr, saddr;\n\t__be16 dport, sport;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct sk_buff *data_skb = NULL;\n\tu8 protocol;\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tenum ip_conntrack_info ctinfo;\n\tstruct nf_conn const *ct;\n#endif\n\tint doff = 0;\n\n\tif (iph->protocol == IPPROTO_UDP || iph->protocol == IPPROTO_TCP) {\n\t\tstruct tcphdr _hdr;\n\t\tstruct udphdr *hp;\n\n\t\thp = skb_header_pointer(skb, ip_hdrlen(skb),\n\t\t\t\t\tiph->protocol == IPPROTO_UDP ?\n\t\t\t\t\tsizeof(*hp) : sizeof(_hdr), &_hdr);\n\t\tif (hp == NULL)\n\t\t\treturn NULL;\n\n\t\tprotocol = iph->protocol;\n\t\tsaddr = iph->saddr;\n\t\tsport = hp->source;\n\t\tdaddr = iph->daddr;\n\t\tdport = hp->dest;\n\t\tdata_skb = (struct sk_buff *)skb;\n\t\tdoff = iph->protocol == IPPROTO_TCP ?\n\t\t\tip_hdrlen(skb) + __tcp_hdrlen((struct tcphdr *)hp) :\n\t\t\tip_hdrlen(skb) + sizeof(*hp);\n\n\t} else if (iph->protocol == IPPROTO_ICMP) {\n\t\tif (extract_icmp4_fields(skb, &protocol, &saddr, &daddr,\n\t\t\t\t\t &sport, &dport))\n\t\t\treturn NULL;\n\t} else {\n\t\treturn NULL;\n\t}\n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\t \n\tct = nf_ct_get(skb, &ctinfo);\n\tif (ct &&\n\t    ((iph->protocol != IPPROTO_ICMP &&\n\t      ctinfo == IP_CT_ESTABLISHED_REPLY) ||\n\t     (iph->protocol == IPPROTO_ICMP &&\n\t      ctinfo == IP_CT_RELATED_REPLY)) &&\n\t    (ct->status & IPS_SRC_NAT_DONE)) {\n\n\t\tdaddr = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;\n\t\tdport = (iph->protocol == IPPROTO_TCP) ?\n\t\t\tct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.tcp.port :\n\t\t\tct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;\n\t}\n#endif\n\n\treturn nf_socket_get_sock_v4(net, data_skb, doff, protocol, saddr,\n\t\t\t\t     daddr, sport, dport, indev);\n}\nEXPORT_SYMBOL_GPL(nf_sk_lookup_slow_v4);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Krisztian Kovacs, Balazs Scheidler\");\nMODULE_DESCRIPTION(\"Netfilter IPv4 socket lookup infrastructure\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}