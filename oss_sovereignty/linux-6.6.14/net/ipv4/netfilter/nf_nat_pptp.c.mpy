{
  "module_name": "nf_nat_pptp.c",
  "hash_id": "b3463e7534b65438db34bafbea003a1b6d6cde4022042520addba8b4221d60ab",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter/nf_nat_pptp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/tcp.h>\n\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_nat_helper.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <linux/netfilter/nf_conntrack_proto_gre.h>\n#include <linux/netfilter/nf_conntrack_pptp.h>\n\n#define NF_NAT_PPTP_VERSION \"3.0\"\n\n#define REQ_CID(req, off)\t\t(*(__be16 *)((char *)(req) + (off)))\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Harald Welte <laforge@gnumonks.org>\");\nMODULE_DESCRIPTION(\"Netfilter NAT helper module for PPTP\");\nMODULE_ALIAS_NF_NAT_HELPER(\"pptp\");\n\nstatic void pptp_nat_expected(struct nf_conn *ct,\n\t\t\t      struct nf_conntrack_expect *exp)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tconst struct nf_conn *master = ct->master;\n\tstruct nf_conntrack_expect *other_exp;\n\tstruct nf_conntrack_tuple t = {};\n\tconst struct nf_ct_pptp_master *ct_pptp_info;\n\tconst struct nf_nat_pptp *nat_pptp_info;\n\tstruct nf_nat_range2 range;\n\tstruct nf_conn_nat *nat;\n\n\tnat = nf_ct_nat_ext_add(ct);\n\tif (WARN_ON_ONCE(!nat))\n\t\treturn;\n\n\tnat_pptp_info = &nat->help.nat_pptp_info;\n\tct_pptp_info = nfct_help_data(master);\n\n\t \n\tif (exp->dir == IP_CT_DIR_ORIGINAL) {\n\t\tpr_debug(\"we are PNS->PAC\\n\");\n\t\t \n\t\tt.src.l3num = AF_INET;\n\t\tt.src.u3.ip = master->tuplehash[!exp->dir].tuple.src.u3.ip;\n\t\tt.src.u.gre.key = ct_pptp_info->pac_call_id;\n\t\tt.dst.u3.ip = master->tuplehash[!exp->dir].tuple.dst.u3.ip;\n\t\tt.dst.u.gre.key = ct_pptp_info->pns_call_id;\n\t\tt.dst.protonum = IPPROTO_GRE;\n\t} else {\n\t\tpr_debug(\"we are PAC->PNS\\n\");\n\t\t \n\t\tt.src.l3num = AF_INET;\n\t\tt.src.u3.ip = master->tuplehash[!exp->dir].tuple.src.u3.ip;\n\t\tt.src.u.gre.key = nat_pptp_info->pns_call_id;\n\t\tt.dst.u3.ip = master->tuplehash[!exp->dir].tuple.dst.u3.ip;\n\t\tt.dst.u.gre.key = nat_pptp_info->pac_call_id;\n\t\tt.dst.protonum = IPPROTO_GRE;\n\t}\n\n\tpr_debug(\"trying to unexpect other dir: \");\n\tnf_ct_dump_tuple_ip(&t);\n\tother_exp = nf_ct_expect_find_get(net, nf_ct_zone(ct), &t);\n\tif (other_exp) {\n\t\tnf_ct_unexpect_related(other_exp);\n\t\tnf_ct_expect_put(other_exp);\n\t\tpr_debug(\"success\\n\");\n\t} else {\n\t\tpr_debug(\"not found!\\n\");\n\t}\n\n\t \n\tBUG_ON(ct->status & IPS_NAT_DONE_MASK);\n\n\t \n\trange.flags = NF_NAT_RANGE_MAP_IPS;\n\trange.min_addr = range.max_addr\n\t\t= ct->master->tuplehash[!exp->dir].tuple.dst.u3;\n\tif (exp->dir == IP_CT_DIR_ORIGINAL) {\n\t\trange.flags |= NF_NAT_RANGE_PROTO_SPECIFIED;\n\t\trange.min_proto = range.max_proto = exp->saved_proto;\n\t}\n\tnf_nat_setup_info(ct, &range, NF_NAT_MANIP_SRC);\n\n\t \n\trange.flags = NF_NAT_RANGE_MAP_IPS;\n\trange.min_addr = range.max_addr\n\t\t= ct->master->tuplehash[!exp->dir].tuple.src.u3;\n\tif (exp->dir == IP_CT_DIR_REPLY) {\n\t\trange.flags |= NF_NAT_RANGE_PROTO_SPECIFIED;\n\t\trange.min_proto = range.max_proto = exp->saved_proto;\n\t}\n\tnf_nat_setup_info(ct, &range, NF_NAT_MANIP_DST);\n}\n\n \nstatic int\npptp_outbound_pkt(struct sk_buff *skb,\n\t\t  struct nf_conn *ct,\n\t\t  enum ip_conntrack_info ctinfo,\n\t\t  unsigned int protoff,\n\t\t  struct PptpControlHeader *ctlh,\n\t\t  union pptp_ctrl_union *pptpReq)\n\n{\n\tstruct nf_ct_pptp_master *ct_pptp_info;\n\tstruct nf_conn_nat *nat = nfct_nat(ct);\n\tstruct nf_nat_pptp *nat_pptp_info;\n\tu_int16_t msg;\n\t__be16 new_callid;\n\tunsigned int cid_off;\n\n\tif (WARN_ON_ONCE(!nat))\n\t\treturn NF_DROP;\n\n\tnat_pptp_info = &nat->help.nat_pptp_info;\n\tct_pptp_info = nfct_help_data(ct);\n\n\tnew_callid = ct_pptp_info->pns_call_id;\n\n\tswitch (msg = ntohs(ctlh->messageType)) {\n\tcase PPTP_OUT_CALL_REQUEST:\n\t\tcid_off = offsetof(union pptp_ctrl_union, ocreq.callID);\n\t\t \n\n\t\t \n\t\tnat_pptp_info->pns_call_id = ct_pptp_info->pns_call_id;\n\n\t\t \n\t\tnew_callid = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.tcp.port;\n\n\t\t \n\t\tct_pptp_info->pns_call_id = new_callid;\n\t\tbreak;\n\tcase PPTP_IN_CALL_REPLY:\n\t\tcid_off = offsetof(union pptp_ctrl_union, icack.callID);\n\t\tbreak;\n\tcase PPTP_CALL_CLEAR_REQUEST:\n\t\tcid_off = offsetof(union pptp_ctrl_union, clrreq.callID);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"unknown outbound packet 0x%04x:%s\\n\", msg,\n\t\t\t pptp_msg_name(msg));\n\t\tfallthrough;\n\tcase PPTP_SET_LINK_INFO:\n\t\t \n\tcase PPTP_START_SESSION_REQUEST:\n\tcase PPTP_START_SESSION_REPLY:\n\tcase PPTP_STOP_SESSION_REQUEST:\n\tcase PPTP_STOP_SESSION_REPLY:\n\tcase PPTP_ECHO_REQUEST:\n\tcase PPTP_ECHO_REPLY:\n\t\t \n\t\treturn NF_ACCEPT;\n\t}\n\n\t \n\tpr_debug(\"altering call id from 0x%04x to 0x%04x\\n\",\n\t\t ntohs(REQ_CID(pptpReq, cid_off)), ntohs(new_callid));\n\n\t \n\tif (!nf_nat_mangle_tcp_packet(skb, ct, ctinfo, protoff,\n\t\t\t\t      cid_off + sizeof(struct pptp_pkt_hdr) +\n\t\t\t\t      sizeof(struct PptpControlHeader),\n\t\t\t\t      sizeof(new_callid), (char *)&new_callid,\n\t\t\t\t      sizeof(new_callid)))\n\t\treturn NF_DROP;\n\treturn NF_ACCEPT;\n}\n\nstatic void\npptp_exp_gre(struct nf_conntrack_expect *expect_orig,\n\t     struct nf_conntrack_expect *expect_reply)\n{\n\tconst struct nf_conn *ct = expect_orig->master;\n\tstruct nf_conn_nat *nat = nfct_nat(ct);\n\tstruct nf_ct_pptp_master *ct_pptp_info;\n\tstruct nf_nat_pptp *nat_pptp_info;\n\n\tif (WARN_ON_ONCE(!nat))\n\t\treturn;\n\n\tnat_pptp_info = &nat->help.nat_pptp_info;\n\tct_pptp_info = nfct_help_data(ct);\n\n\t \n\tnat_pptp_info->pac_call_id = ct_pptp_info->pac_call_id;\n\n\t \n\texpect_orig->saved_proto.gre.key = ct_pptp_info->pns_call_id;\n\texpect_orig->tuple.src.u.gre.key = nat_pptp_info->pns_call_id;\n\texpect_orig->tuple.dst.u.gre.key = ct_pptp_info->pac_call_id;\n\texpect_orig->dir = IP_CT_DIR_ORIGINAL;\n\n\t \n\texpect_reply->saved_proto.gre.key = nat_pptp_info->pns_call_id;\n\texpect_reply->tuple.src.u.gre.key = nat_pptp_info->pac_call_id;\n\texpect_reply->tuple.dst.u.gre.key = ct_pptp_info->pns_call_id;\n\texpect_reply->dir = IP_CT_DIR_REPLY;\n}\n\n \nstatic int\npptp_inbound_pkt(struct sk_buff *skb,\n\t\t struct nf_conn *ct,\n\t\t enum ip_conntrack_info ctinfo,\n\t\t unsigned int protoff,\n\t\t struct PptpControlHeader *ctlh,\n\t\t union pptp_ctrl_union *pptpReq)\n{\n\tconst struct nf_nat_pptp *nat_pptp_info;\n\tstruct nf_conn_nat *nat = nfct_nat(ct);\n\tu_int16_t msg;\n\t__be16 new_pcid;\n\tunsigned int pcid_off;\n\n\tif (WARN_ON_ONCE(!nat))\n\t\treturn NF_DROP;\n\n\tnat_pptp_info = &nat->help.nat_pptp_info;\n\tnew_pcid = nat_pptp_info->pns_call_id;\n\n\tswitch (msg = ntohs(ctlh->messageType)) {\n\tcase PPTP_OUT_CALL_REPLY:\n\t\tpcid_off = offsetof(union pptp_ctrl_union, ocack.peersCallID);\n\t\tbreak;\n\tcase PPTP_IN_CALL_CONNECT:\n\t\tpcid_off = offsetof(union pptp_ctrl_union, iccon.peersCallID);\n\t\tbreak;\n\tcase PPTP_IN_CALL_REQUEST:\n\t\t \n\t\treturn NF_ACCEPT;\n\tcase PPTP_WAN_ERROR_NOTIFY:\n\t\tpcid_off = offsetof(union pptp_ctrl_union, wanerr.peersCallID);\n\t\tbreak;\n\tcase PPTP_CALL_DISCONNECT_NOTIFY:\n\t\tpcid_off = offsetof(union pptp_ctrl_union, disc.callID);\n\t\tbreak;\n\tcase PPTP_SET_LINK_INFO:\n\t\tpcid_off = offsetof(union pptp_ctrl_union, setlink.peersCallID);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"unknown inbound packet %s\\n\", pptp_msg_name(msg));\n\t\tfallthrough;\n\tcase PPTP_START_SESSION_REQUEST:\n\tcase PPTP_START_SESSION_REPLY:\n\tcase PPTP_STOP_SESSION_REQUEST:\n\tcase PPTP_STOP_SESSION_REPLY:\n\tcase PPTP_ECHO_REQUEST:\n\tcase PPTP_ECHO_REPLY:\n\t\t \n\t\treturn NF_ACCEPT;\n\t}\n\n\t \n\n\t \n\tpr_debug(\"altering peer call id from 0x%04x to 0x%04x\\n\",\n\t\t ntohs(REQ_CID(pptpReq, pcid_off)), ntohs(new_pcid));\n\n\tif (!nf_nat_mangle_tcp_packet(skb, ct, ctinfo, protoff,\n\t\t\t\t      pcid_off + sizeof(struct pptp_pkt_hdr) +\n\t\t\t\t      sizeof(struct PptpControlHeader),\n\t\t\t\t      sizeof(new_pcid), (char *)&new_pcid,\n\t\t\t\t      sizeof(new_pcid)))\n\t\treturn NF_DROP;\n\treturn NF_ACCEPT;\n}\n\nstatic const struct nf_nat_pptp_hook pptp_hooks = {\n\t.outbound = pptp_outbound_pkt,\n\t.inbound = pptp_inbound_pkt,\n\t.exp_gre = pptp_exp_gre,\n\t.expectfn = pptp_nat_expected,\n};\n\nstatic int __init nf_nat_helper_pptp_init(void)\n{\n\tWARN_ON(nf_nat_pptp_hook != NULL);\n\tRCU_INIT_POINTER(nf_nat_pptp_hook, &pptp_hooks);\n\n\treturn 0;\n}\n\nstatic void __exit nf_nat_helper_pptp_fini(void)\n{\n\tRCU_INIT_POINTER(nf_nat_pptp_hook, NULL);\n\tsynchronize_rcu();\n}\n\nmodule_init(nf_nat_helper_pptp_init);\nmodule_exit(nf_nat_helper_pptp_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}