{
  "module_name": "nft_dup_ipv4.c",
  "hash_id": "4eb77f3ccfc213ac809c8c09a9eba4b039f6a54aeedf6a427d53715742c9793a",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter/nft_dup_ipv4.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/ipv4/nf_dup_ipv4.h>\n\nstruct nft_dup_ipv4 {\n\tu8\tsreg_addr;\n\tu8\tsreg_dev;\n};\n\nstatic void nft_dup_ipv4_eval(const struct nft_expr *expr,\n\t\t\t      struct nft_regs *regs,\n\t\t\t      const struct nft_pktinfo *pkt)\n{\n\tstruct nft_dup_ipv4 *priv = nft_expr_priv(expr);\n\tstruct in_addr gw = {\n\t\t.s_addr = (__force __be32)regs->data[priv->sreg_addr],\n\t};\n\tint oif = priv->sreg_dev ? regs->data[priv->sreg_dev] : -1;\n\n\tnf_dup_ipv4(nft_net(pkt), pkt->skb, nft_hook(pkt), &gw, oif);\n}\n\nstatic int nft_dup_ipv4_init(const struct nft_ctx *ctx,\n\t\t\t     const struct nft_expr *expr,\n\t\t\t     const struct nlattr * const tb[])\n{\n\tstruct nft_dup_ipv4 *priv = nft_expr_priv(expr);\n\tint err;\n\n\tif (tb[NFTA_DUP_SREG_ADDR] == NULL)\n\t\treturn -EINVAL;\n\n\terr = nft_parse_register_load(tb[NFTA_DUP_SREG_ADDR], &priv->sreg_addr,\n\t\t\t\t      sizeof(struct in_addr));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[NFTA_DUP_SREG_DEV])\n\t\terr = nft_parse_register_load(tb[NFTA_DUP_SREG_DEV],\n\t\t\t\t\t      &priv->sreg_dev, sizeof(int));\n\n\treturn err;\n}\n\nstatic int nft_dup_ipv4_dump(struct sk_buff *skb,\n\t\t\t     const struct nft_expr *expr, bool reset)\n{\n\tstruct nft_dup_ipv4 *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_DUP_SREG_ADDR, priv->sreg_addr))\n\t\tgoto nla_put_failure;\n\tif (priv->sreg_dev &&\n\t    nft_dump_register(skb, NFTA_DUP_SREG_DEV, priv->sreg_dev))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic struct nft_expr_type nft_dup_ipv4_type;\nstatic const struct nft_expr_ops nft_dup_ipv4_ops = {\n\t.type\t\t= &nft_dup_ipv4_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_dup_ipv4)),\n\t.eval\t\t= nft_dup_ipv4_eval,\n\t.init\t\t= nft_dup_ipv4_init,\n\t.dump\t\t= nft_dup_ipv4_dump,\n\t.reduce\t\t= NFT_REDUCE_READONLY,\n};\n\nstatic const struct nla_policy nft_dup_ipv4_policy[NFTA_DUP_MAX + 1] = {\n\t[NFTA_DUP_SREG_ADDR]\t= { .type = NLA_U32 },\n\t[NFTA_DUP_SREG_DEV]\t= { .type = NLA_U32 },\n};\n\nstatic struct nft_expr_type nft_dup_ipv4_type __read_mostly = {\n\t.family\t\t= NFPROTO_IPV4,\n\t.name\t\t= \"dup\",\n\t.ops\t\t= &nft_dup_ipv4_ops,\n\t.policy\t\t= nft_dup_ipv4_policy,\n\t.maxattr\t= NFTA_DUP_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_dup_ipv4_module_init(void)\n{\n\treturn nft_register_expr(&nft_dup_ipv4_type);\n}\n\nstatic void __exit nft_dup_ipv4_module_exit(void)\n{\n\tnft_unregister_expr(&nft_dup_ipv4_type);\n}\n\nmodule_init(nft_dup_ipv4_module_init);\nmodule_exit(nft_dup_ipv4_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pablo Neira Ayuso <pablo@netfilter.org>\");\nMODULE_ALIAS_NFT_AF_EXPR(AF_INET, \"dup\");\nMODULE_DESCRIPTION(\"IPv4 nftables packet duplication support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}