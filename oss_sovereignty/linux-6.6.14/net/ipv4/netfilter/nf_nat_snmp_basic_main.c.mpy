{
  "module_name": "nf_nat_snmp_basic_main.c",
  "hash_id": "b88a565a4cf1aac18baeae7455d96400e2b07f37ef4f17623b76983c42dfa651",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter/nf_nat_snmp_basic_main.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/udp.h>\n#include <net/checksum.h>\n#include <net/udp.h>\n\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <linux/netfilter/nf_conntrack_snmp.h>\n#include \"nf_nat_snmp_basic.asn1.h\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Morris <jmorris@intercode.com.au>\");\nMODULE_DESCRIPTION(\"Basic SNMP Application Layer Gateway\");\nMODULE_ALIAS(\"ip_nat_snmp_basic\");\nMODULE_ALIAS_NFCT_HELPER(\"snmp_trap\");\n\n#define SNMP_PORT 161\n#define SNMP_TRAP_PORT 162\n\nstatic DEFINE_SPINLOCK(snmp_lock);\n\nstruct snmp_ctx {\n\tunsigned char *begin;\n\t__sum16 *check;\n\t__be32 from;\n\t__be32 to;\n};\n\nstatic void fast_csum(struct snmp_ctx *ctx, unsigned char offset)\n{\n\tunsigned char s[12] = {0,};\n\tint size;\n\n\tif (offset & 1) {\n\t\tmemcpy(&s[1], &ctx->from, 4);\n\t\tmemcpy(&s[7], &ctx->to, 4);\n\t\ts[0] = ~0;\n\t\ts[1] = ~s[1];\n\t\ts[2] = ~s[2];\n\t\ts[3] = ~s[3];\n\t\ts[4] = ~s[4];\n\t\ts[5] = ~0;\n\t\tsize = 12;\n\t} else {\n\t\tmemcpy(&s[0], &ctx->from, 4);\n\t\tmemcpy(&s[4], &ctx->to, 4);\n\t\ts[0] = ~s[0];\n\t\ts[1] = ~s[1];\n\t\ts[2] = ~s[2];\n\t\ts[3] = ~s[3];\n\t\tsize = 8;\n\t}\n\t*ctx->check = csum_fold(csum_partial(s, size,\n\t\t\t\t\t     ~csum_unfold(*ctx->check)));\n}\n\nint snmp_version(void *context, size_t hdrlen, unsigned char tag,\n\t\t const void *data, size_t datalen)\n{\n\tif (datalen != 1)\n\t\treturn -EINVAL;\n\tif (*(unsigned char *)data > 1)\n\t\treturn -ENOTSUPP;\n\treturn 1;\n}\n\nint snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata;\n\n\tif (datalen != 4)\n\t\treturn -EINVAL;\n\tpdata = (__be32 *)data;\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\n\treturn 1;\n}\n\nstatic int snmp_translate(struct nf_conn *ct, int dir, struct sk_buff *skb)\n{\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct udphdr *udph = (struct udphdr *)((__be32 *)iph + iph->ihl);\n\tu16 datalen = ntohs(udph->len) - sizeof(struct udphdr);\n\tchar *data = (unsigned char *)udph + sizeof(struct udphdr);\n\tstruct snmp_ctx ctx;\n\tint ret;\n\n\tif (dir == IP_CT_DIR_ORIGINAL) {\n\t\tctx.from = ct->tuplehash[dir].tuple.src.u3.ip;\n\t\tctx.to = ct->tuplehash[!dir].tuple.dst.u3.ip;\n\t} else {\n\t\tctx.from = ct->tuplehash[!dir].tuple.src.u3.ip;\n\t\tctx.to = ct->tuplehash[dir].tuple.dst.u3.ip;\n\t}\n\n\tif (ctx.from == ctx.to)\n\t\treturn NF_ACCEPT;\n\n\tctx.begin = (unsigned char *)udph + sizeof(struct udphdr);\n\tctx.check = &udph->check;\n\tret = asn1_ber_decoder(&nf_nat_snmp_basic_decoder, &ctx, data, datalen);\n\tif (ret < 0) {\n\t\tnf_ct_helper_log(skb, ct, \"parser failed\\n\");\n\t\treturn NF_DROP;\n\t}\n\n\treturn NF_ACCEPT;\n}\n\n \nstatic int help(struct sk_buff *skb, unsigned int protoff,\n\t\tstruct nf_conn *ct,\n\t\tenum ip_conntrack_info ctinfo)\n{\n\tint dir = CTINFO2DIR(ctinfo);\n\tunsigned int ret;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tconst struct udphdr *udph = (struct udphdr *)((__be32 *)iph + iph->ihl);\n\n\t \n\tif (udph->source == htons(SNMP_PORT) && dir != IP_CT_DIR_REPLY)\n\t\treturn NF_ACCEPT;\n\tif (udph->dest == htons(SNMP_TRAP_PORT) && dir != IP_CT_DIR_ORIGINAL)\n\t\treturn NF_ACCEPT;\n\n\t \n\tif (!(ct->status & IPS_NAT_MASK))\n\t\treturn NF_ACCEPT;\n\n\t \n\tif (ntohs(udph->len) != skb->len - (iph->ihl << 2)) {\n\t\tnf_ct_helper_log(skb, ct, \"dropping malformed packet\\n\");\n\t\treturn NF_DROP;\n\t}\n\n\tif (skb_ensure_writable(skb, skb->len)) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot mangle packet\");\n\t\treturn NF_DROP;\n\t}\n\n\tspin_lock_bh(&snmp_lock);\n\tret = snmp_translate(ct, dir, skb);\n\tspin_unlock_bh(&snmp_lock);\n\treturn ret;\n}\n\nstatic const struct nf_conntrack_expect_policy snmp_exp_policy = {\n\t.max_expected\t= 0,\n\t.timeout\t= 180,\n};\n\nstatic struct nf_conntrack_helper snmp_trap_helper __read_mostly = {\n\t.me\t\t\t= THIS_MODULE,\n\t.help\t\t\t= help,\n\t.expect_policy\t\t= &snmp_exp_policy,\n\t.name\t\t\t= \"snmp_trap\",\n\t.tuple.src.l3num\t= AF_INET,\n\t.tuple.src.u.udp.port\t= cpu_to_be16(SNMP_TRAP_PORT),\n\t.tuple.dst.protonum\t= IPPROTO_UDP,\n};\n\nstatic int __init nf_nat_snmp_basic_init(void)\n{\n\tBUG_ON(nf_nat_snmp_hook != NULL);\n\tRCU_INIT_POINTER(nf_nat_snmp_hook, help);\n\n\treturn nf_conntrack_helper_register(&snmp_trap_helper);\n}\n\nstatic void __exit nf_nat_snmp_basic_fini(void)\n{\n\tRCU_INIT_POINTER(nf_nat_snmp_hook, NULL);\n\tsynchronize_rcu();\n\tnf_conntrack_helper_unregister(&snmp_trap_helper);\n}\n\nmodule_init(nf_nat_snmp_basic_init);\nmodule_exit(nf_nat_snmp_basic_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}