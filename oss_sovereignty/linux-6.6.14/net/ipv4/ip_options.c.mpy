{
  "module_name": "ip_options.c",
  "hash_id": "4577942084527bf4ca4086f247a8a379679b70fe304c4f5c9ca61ddb88533036",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ip_options.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"IPv4: \" fmt\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/icmp.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/route.h>\n#include <net/cipso_ipv4.h>\n#include <net/ip_fib.h>\n\n \n\nvoid ip_options_build(struct sk_buff *skb, struct ip_options *opt,\n\t\t      __be32 daddr, struct rtable *rt)\n{\n\tunsigned char *iph = skb_network_header(skb);\n\n\tmemcpy(&(IPCB(skb)->opt), opt, sizeof(struct ip_options));\n\tmemcpy(iph + sizeof(struct iphdr), opt->__data, opt->optlen);\n\topt = &(IPCB(skb)->opt);\n\n\tif (opt->srr)\n\t\tmemcpy(iph + opt->srr + iph[opt->srr + 1] - 4, &daddr, 4);\n\n\tif (opt->rr_needaddr)\n\t\tip_rt_get_source(iph + opt->rr + iph[opt->rr + 2] - 5, skb, rt);\n\tif (opt->ts_needaddr)\n\t\tip_rt_get_source(iph + opt->ts + iph[opt->ts + 2] - 9, skb, rt);\n\tif (opt->ts_needtime) {\n\t\t__be32 midtime;\n\n\t\tmidtime = inet_current_timestamp();\n\t\tmemcpy(iph + opt->ts + iph[opt->ts + 2] - 5, &midtime, 4);\n\t}\n}\n\n \n\nint __ip_options_echo(struct net *net, struct ip_options *dopt,\n\t\t      struct sk_buff *skb, const struct ip_options *sopt)\n{\n\tunsigned char *sptr, *dptr;\n\tint soffset, doffset;\n\tint\toptlen;\n\n\tmemset(dopt, 0, sizeof(struct ip_options));\n\n\tif (sopt->optlen == 0)\n\t\treturn 0;\n\n\tsptr = skb_network_header(skb);\n\tdptr = dopt->__data;\n\n\tif (sopt->rr) {\n\t\toptlen  = sptr[sopt->rr+1];\n\t\tsoffset = sptr[sopt->rr+2];\n\t\tdopt->rr = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->rr, optlen);\n\t\tif (sopt->rr_needaddr && soffset <= optlen) {\n\t\t\tif (soffset + 3 > optlen)\n\t\t\t\treturn -EINVAL;\n\t\t\tdptr[2] = soffset + 4;\n\t\t\tdopt->rr_needaddr = 1;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->ts) {\n\t\toptlen = sptr[sopt->ts+1];\n\t\tsoffset = sptr[sopt->ts+2];\n\t\tdopt->ts = dopt->optlen + sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->ts, optlen);\n\t\tif (soffset <= optlen) {\n\t\t\tif (sopt->ts_needaddr) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdopt->ts_needaddr = 1;\n\t\t\t\tsoffset += 4;\n\t\t\t}\n\t\t\tif (sopt->ts_needtime) {\n\t\t\t\tif (soffset + 3 > optlen)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif ((dptr[3]&0xF) != IPOPT_TS_PRESPEC) {\n\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\tsoffset += 4;\n\t\t\t\t} else {\n\t\t\t\t\tdopt->ts_needtime = 0;\n\n\t\t\t\t\tif (soffset + 7 <= optlen) {\n\t\t\t\t\t\t__be32 addr;\n\n\t\t\t\t\t\tmemcpy(&addr, dptr+soffset-1, 4);\n\t\t\t\t\t\tif (inet_addr_type(net, addr) != RTN_UNICAST) {\n\t\t\t\t\t\t\tdopt->ts_needtime = 1;\n\t\t\t\t\t\t\tsoffset += 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdptr[2] = soffset;\n\t\t}\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\tif (sopt->srr) {\n\t\tunsigned char *start = sptr+sopt->srr;\n\t\t__be32 faddr;\n\n\t\toptlen  = start[1];\n\t\tsoffset = start[2];\n\t\tdoffset = 0;\n\t\tif (soffset > optlen)\n\t\t\tsoffset = optlen + 1;\n\t\tsoffset -= 4;\n\t\tif (soffset > 3) {\n\t\t\tmemcpy(&faddr, &start[soffset-1], 4);\n\t\t\tfor (soffset -= 4, doffset = 4; soffset > 3; soffset -= 4, doffset += 4)\n\t\t\t\tmemcpy(&dptr[doffset-1], &start[soffset-1], 4);\n\t\t\t \n\t\t\tif (memcmp(&ip_hdr(skb)->saddr,\n\t\t\t\t   &start[soffset + 3], 4) == 0)\n\t\t\t\tdoffset -= 4;\n\t\t}\n\t\tif (doffset > 3) {\n\t\t\tdopt->faddr = faddr;\n\t\t\tdptr[0] = start[0];\n\t\t\tdptr[1] = doffset+3;\n\t\t\tdptr[2] = 4;\n\t\t\tdptr += doffset+3;\n\t\t\tdopt->srr = dopt->optlen + sizeof(struct iphdr);\n\t\t\tdopt->optlen += doffset+3;\n\t\t\tdopt->is_strictroute = sopt->is_strictroute;\n\t\t}\n\t}\n\tif (sopt->cipso) {\n\t\toptlen  = sptr[sopt->cipso+1];\n\t\tdopt->cipso = dopt->optlen+sizeof(struct iphdr);\n\t\tmemcpy(dptr, sptr+sopt->cipso, optlen);\n\t\tdptr += optlen;\n\t\tdopt->optlen += optlen;\n\t}\n\twhile (dopt->optlen & 3) {\n\t\t*dptr++ = IPOPT_END;\n\t\tdopt->optlen++;\n\t}\n\treturn 0;\n}\n\n \n\nvoid ip_options_fragment(struct sk_buff *skb)\n{\n\tunsigned char *optptr = skb_network_header(skb) + sizeof(struct iphdr);\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tint  l = opt->optlen;\n\tint  optlen;\n\n\twhile (l > 0) {\n\t\tswitch (*optptr) {\n\t\tcase IPOPT_END:\n\t\t\treturn;\n\t\tcase IPOPT_NOOP:\n\t\t\tl--;\n\t\t\toptptr++;\n\t\t\tcontinue;\n\t\t}\n\t\toptlen = optptr[1];\n\t\tif (optlen < 2 || optlen > l)\n\t\t  return;\n\t\tif (!IPOPT_COPIED(*optptr))\n\t\t\tmemset(optptr, IPOPT_NOOP, optlen);\n\t\tl -= optlen;\n\t\toptptr += optlen;\n\t}\n\topt->ts = 0;\n\topt->rr = 0;\n\topt->rr_needaddr = 0;\n\topt->ts_needaddr = 0;\n\topt->ts_needtime = 0;\n}\n\n \nstatic void spec_dst_fill(__be32 *spec_dst, struct sk_buff *skb)\n{\n\tif (*spec_dst == htonl(INADDR_ANY))\n\t\t*spec_dst = fib_compute_spec_dst(skb);\n}\n\n \n\nint __ip_options_compile(struct net *net,\n\t\t\t struct ip_options *opt, struct sk_buff *skb,\n\t\t\t __be32 *info)\n{\n\t__be32 spec_dst = htonl(INADDR_ANY);\n\tunsigned char *pp_ptr = NULL;\n\tstruct rtable *rt = NULL;\n\tunsigned char *optptr;\n\tunsigned char *iph;\n\tint optlen, l;\n\n\tif (skb) {\n\t\trt = skb_rtable(skb);\n\t\toptptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\t} else\n\t\toptptr = opt->__data;\n\tiph = optptr - sizeof(struct iphdr);\n\n\tfor (l = opt->optlen; l > 0; ) {\n\t\tswitch (*optptr) {\n\t\tcase IPOPT_END:\n\t\t\tfor (optptr++, l--; l > 0; optptr++, l--) {\n\t\t\t\tif (*optptr != IPOPT_END) {\n\t\t\t\t\t*optptr = IPOPT_END;\n\t\t\t\t\topt->is_changed = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto eol;\n\t\tcase IPOPT_NOOP:\n\t\t\tl--;\n\t\t\toptptr++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(l < 2)) {\n\t\t\tpp_ptr = optptr;\n\t\t\tgoto error;\n\t\t}\n\t\toptlen = optptr[1];\n\t\tif (optlen < 2 || optlen > l) {\n\t\t\tpp_ptr = optptr;\n\t\t\tgoto error;\n\t\t}\n\t\tswitch (*optptr) {\n\t\tcase IPOPT_SSRR:\n\t\tcase IPOPT_LSRR:\n\t\t\tif (optlen < 3) {\n\t\t\t\tpp_ptr = optptr + 1;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (optptr[2] < 4) {\n\t\t\t\tpp_ptr = optptr + 2;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t \n\t\t\tif (opt->srr) {\n\t\t\t\tpp_ptr = optptr;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (!skb) {\n\t\t\t\tif (optptr[2] != 4 || optlen < 7 || ((optlen-3) & 3)) {\n\t\t\t\t\tpp_ptr = optptr + 1;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tmemcpy(&opt->faddr, &optptr[3], 4);\n\t\t\t\tif (optlen > 7)\n\t\t\t\t\tmemmove(&optptr[3], &optptr[7], optlen-7);\n\t\t\t}\n\t\t\topt->is_strictroute = (optptr[0] == IPOPT_SSRR);\n\t\t\topt->srr = optptr - iph;\n\t\t\tbreak;\n\t\tcase IPOPT_RR:\n\t\t\tif (opt->rr) {\n\t\t\t\tpp_ptr = optptr;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (optlen < 3) {\n\t\t\t\tpp_ptr = optptr + 1;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (optptr[2] < 4) {\n\t\t\t\tpp_ptr = optptr + 2;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (optptr[2] <= optlen) {\n\t\t\t\tif (optptr[2]+3 > optlen) {\n\t\t\t\t\tpp_ptr = optptr + 2;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tif (rt) {\n\t\t\t\t\tspec_dst_fill(&spec_dst, skb);\n\t\t\t\t\tmemcpy(&optptr[optptr[2]-1], &spec_dst, 4);\n\t\t\t\t\topt->is_changed = 1;\n\t\t\t\t}\n\t\t\t\toptptr[2] += 4;\n\t\t\t\topt->rr_needaddr = 1;\n\t\t\t}\n\t\t\topt->rr = optptr - iph;\n\t\t\tbreak;\n\t\tcase IPOPT_TIMESTAMP:\n\t\t\tif (opt->ts) {\n\t\t\t\tpp_ptr = optptr;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (optlen < 4) {\n\t\t\t\tpp_ptr = optptr + 1;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (optptr[2] < 5) {\n\t\t\t\tpp_ptr = optptr + 2;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (optptr[2] <= optlen) {\n\t\t\t\tunsigned char *timeptr = NULL;\n\t\t\t\tif (optptr[2]+3 > optlen) {\n\t\t\t\t\tpp_ptr = optptr + 2;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tswitch (optptr[3]&0xF) {\n\t\t\t\tcase IPOPT_TS_TSONLY:\n\t\t\t\t\tif (skb)\n\t\t\t\t\t\ttimeptr = &optptr[optptr[2]-1];\n\t\t\t\t\topt->ts_needtime = 1;\n\t\t\t\t\toptptr[2] += 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IPOPT_TS_TSANDADDR:\n\t\t\t\t\tif (optptr[2]+7 > optlen) {\n\t\t\t\t\t\tpp_ptr = optptr + 2;\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t\tif (rt)  {\n\t\t\t\t\t\tspec_dst_fill(&spec_dst, skb);\n\t\t\t\t\t\tmemcpy(&optptr[optptr[2]-1], &spec_dst, 4);\n\t\t\t\t\t\ttimeptr = &optptr[optptr[2]+3];\n\t\t\t\t\t}\n\t\t\t\t\topt->ts_needaddr = 1;\n\t\t\t\t\topt->ts_needtime = 1;\n\t\t\t\t\toptptr[2] += 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IPOPT_TS_PRESPEC:\n\t\t\t\t\tif (optptr[2]+7 > optlen) {\n\t\t\t\t\t\tpp_ptr = optptr + 2;\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\t__be32 addr;\n\t\t\t\t\t\tmemcpy(&addr, &optptr[optptr[2]-1], 4);\n\t\t\t\t\t\tif (inet_addr_type(net, addr) == RTN_UNICAST)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (skb)\n\t\t\t\t\t\t\ttimeptr = &optptr[optptr[2]+3];\n\t\t\t\t\t}\n\t\t\t\t\topt->ts_needtime = 1;\n\t\t\t\t\toptptr[2] += 8;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!skb && !ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\t\t\t\tpp_ptr = optptr + 3;\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (timeptr) {\n\t\t\t\t\t__be32 midtime;\n\n\t\t\t\t\tmidtime = inet_current_timestamp();\n\t\t\t\t\tmemcpy(timeptr, &midtime, 4);\n\t\t\t\t\topt->is_changed = 1;\n\t\t\t\t}\n\t\t\t} else if ((optptr[3]&0xF) != IPOPT_TS_PRESPEC) {\n\t\t\t\tunsigned int overflow = optptr[3]>>4;\n\t\t\t\tif (overflow == 15) {\n\t\t\t\t\tpp_ptr = optptr + 3;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tif (skb) {\n\t\t\t\t\toptptr[3] = (optptr[3]&0xF)|((overflow+1)<<4);\n\t\t\t\t\topt->is_changed = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\topt->ts = optptr - iph;\n\t\t\tbreak;\n\t\tcase IPOPT_RA:\n\t\t\tif (optlen < 4) {\n\t\t\t\tpp_ptr = optptr + 1;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (optptr[2] == 0 && optptr[3] == 0)\n\t\t\t\topt->router_alert = optptr - iph;\n\t\t\tbreak;\n\t\tcase IPOPT_CIPSO:\n\t\t\tif ((!skb && !ns_capable(net->user_ns, CAP_NET_RAW)) || opt->cipso) {\n\t\t\t\tpp_ptr = optptr;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\topt->cipso = optptr - iph;\n\t\t\tif (cipso_v4_validate(skb, &optptr)) {\n\t\t\t\tpp_ptr = optptr;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IPOPT_SEC:\n\t\tcase IPOPT_SID:\n\t\tdefault:\n\t\t\tif (!skb && !ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\t\tpp_ptr = optptr;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tl -= optlen;\n\t\toptptr += optlen;\n\t}\n\neol:\n\tif (!pp_ptr)\n\t\treturn 0;\n\nerror:\n\tif (info)\n\t\t*info = htonl((pp_ptr-iph)<<24);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(__ip_options_compile);\n\nint ip_options_compile(struct net *net,\n\t\t       struct ip_options *opt, struct sk_buff *skb)\n{\n\tint ret;\n\t__be32 info;\n\n\tret = __ip_options_compile(net, opt, skb, &info);\n\tif (ret != 0 && skb)\n\t\ticmp_send(skb, ICMP_PARAMETERPROB, 0, info);\n\treturn ret;\n}\nEXPORT_SYMBOL(ip_options_compile);\n\n \n\nvoid ip_options_undo(struct ip_options *opt)\n{\n\tif (opt->srr) {\n\t\tunsigned char *optptr = opt->__data + opt->srr - sizeof(struct iphdr);\n\n\t\tmemmove(optptr + 7, optptr + 3, optptr[1] - 7);\n\t\tmemcpy(optptr + 3, &opt->faddr, 4);\n\t}\n\tif (opt->rr_needaddr) {\n\t\tunsigned char *optptr = opt->__data + opt->rr - sizeof(struct iphdr);\n\n\t\toptptr[2] -= 4;\n\t\tmemset(&optptr[optptr[2] - 1], 0, 4);\n\t}\n\tif (opt->ts) {\n\t\tunsigned char *optptr = opt->__data + opt->ts - sizeof(struct iphdr);\n\n\t\tif (opt->ts_needtime) {\n\t\t\toptptr[2] -= 4;\n\t\t\tmemset(&optptr[optptr[2] - 1], 0, 4);\n\t\t\tif ((optptr[3] & 0xF) == IPOPT_TS_PRESPEC)\n\t\t\t\toptptr[2] -= 4;\n\t\t}\n\t\tif (opt->ts_needaddr) {\n\t\t\toptptr[2] -= 4;\n\t\t\tmemset(&optptr[optptr[2] - 1], 0, 4);\n\t\t}\n\t}\n}\n\nint ip_options_get(struct net *net, struct ip_options_rcu **optp,\n\t\t   sockptr_t data, int optlen)\n{\n\tstruct ip_options_rcu *opt;\n\n\topt = kzalloc(sizeof(struct ip_options_rcu) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen && copy_from_sockptr(opt->opt.__data, data, optlen)) {\n\t\tkfree(opt);\n\t\treturn -EFAULT;\n\t}\n\n\twhile (optlen & 3)\n\t\topt->opt.__data[optlen++] = IPOPT_END;\n\topt->opt.optlen = optlen;\n\tif (optlen && ip_options_compile(net, &opt->opt, NULL)) {\n\t\tkfree(opt);\n\t\treturn -EINVAL;\n\t}\n\tkfree(*optp);\n\t*optp = opt;\n\treturn 0;\n}\n\nvoid ip_forward_options(struct sk_buff *skb)\n{\n\tstruct   ip_options *opt\t= &(IPCB(skb)->opt);\n\tunsigned char *optptr;\n\tstruct rtable *rt = skb_rtable(skb);\n\tunsigned char *raw = skb_network_header(skb);\n\n\tif (opt->rr_needaddr) {\n\t\toptptr = (unsigned char *)raw + opt->rr;\n\t\tip_rt_get_source(&optptr[optptr[2]-5], skb, rt);\n\t\topt->is_changed = 1;\n\t}\n\tif (opt->srr_is_hit) {\n\t\tint srrptr, srrspace;\n\n\t\toptptr = raw + opt->srr;\n\n\t\tfor ( srrptr = optptr[2], srrspace = optptr[1];\n\t\t     srrptr <= srrspace;\n\t\t     srrptr += 4\n\t\t     ) {\n\t\t\tif (srrptr + 3 > srrspace)\n\t\t\t\tbreak;\n\t\t\tif (memcmp(&opt->nexthop, &optptr[srrptr-1], 4) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (srrptr + 3 <= srrspace) {\n\t\t\topt->is_changed = 1;\n\t\t\tip_hdr(skb)->daddr = opt->nexthop;\n\t\t\tip_rt_get_source(&optptr[srrptr-1], skb, rt);\n\t\t\toptptr[2] = srrptr+4;\n\t\t} else {\n\t\t\tnet_crit_ratelimited(\"%s(): Argh! Destination lost!\\n\",\n\t\t\t\t\t     __func__);\n\t\t}\n\t\tif (opt->ts_needaddr) {\n\t\t\toptptr = raw + opt->ts;\n\t\t\tip_rt_get_source(&optptr[optptr[2]-9], skb, rt);\n\t\t\topt->is_changed = 1;\n\t\t}\n\t}\n\tif (opt->is_changed) {\n\t\topt->is_changed = 0;\n\t\tip_send_check(ip_hdr(skb));\n\t}\n}\n\nint ip_options_rcv_srr(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tint srrspace, srrptr;\n\t__be32 nexthop;\n\tstruct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = skb_network_header(skb) + opt->srr;\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct rtable *rt2;\n\tunsigned long orefdst;\n\tint err;\n\n\tif (!rt)\n\t\treturn 0;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\treturn -EINVAL;\n\tif (rt->rt_type == RTN_UNICAST) {\n\t\tif (!opt->is_strictroute)\n\t\t\treturn 0;\n\t\ticmp_send(skb, ICMP_PARAMETERPROB, 0, htonl(16<<24));\n\t\treturn -EINVAL;\n\t}\n\tif (rt->rt_type != RTN_LOCAL)\n\t\treturn -EINVAL;\n\n\tfor (srrptr = optptr[2], srrspace = optptr[1]; srrptr <= srrspace; srrptr += 4) {\n\t\tif (srrptr + 3 > srrspace) {\n\t\t\ticmp_send(skb, ICMP_PARAMETERPROB, 0, htonl((opt->srr+2)<<24));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&nexthop, &optptr[srrptr-1], 4);\n\n\t\torefdst = skb->_skb_refdst;\n\t\tskb_dst_set(skb, NULL);\n\t\terr = ip_route_input(skb, nexthop, iph->saddr, iph->tos, dev);\n\t\trt2 = skb_rtable(skb);\n\t\tif (err || (rt2->rt_type != RTN_UNICAST && rt2->rt_type != RTN_LOCAL)) {\n\t\t\tskb_dst_drop(skb);\n\t\t\tskb->_skb_refdst = orefdst;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trefdst_drop(orefdst);\n\t\tif (rt2->rt_type != RTN_LOCAL)\n\t\t\tbreak;\n\t\t \n\t\tiph->daddr = nexthop;\n\t\topt->is_changed = 1;\n\t}\n\tif (srrptr <= srrspace) {\n\t\topt->srr_is_hit = 1;\n\t\topt->nexthop = nexthop;\n\t\topt->is_changed = 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ip_options_rcv_srr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}