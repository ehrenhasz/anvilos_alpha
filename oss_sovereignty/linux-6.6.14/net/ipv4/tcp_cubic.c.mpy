{
  "module_name": "tcp_cubic.c",
  "hash_id": "83870dc3bbb82ffa1066f6f3988da129e2243ebf47379607421e4d18bf10ca8a",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_cubic.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/btf.h>\n#include <linux/btf_ids.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <net/tcp.h>\n\n#define BICTCP_BETA_SCALE    1024\t \n#define\tBICTCP_HZ\t\t10\t \n\n \n#define HYSTART_ACK_TRAIN\t0x1\n#define HYSTART_DELAY\t\t0x2\n\n \n#define HYSTART_MIN_SAMPLES\t8\n#define HYSTART_DELAY_MIN\t(4000U)\t \n#define HYSTART_DELAY_MAX\t(16000U)\t \n#define HYSTART_DELAY_THRESH(x)\tclamp(x, HYSTART_DELAY_MIN, HYSTART_DELAY_MAX)\n\nstatic int fast_convergence __read_mostly = 1;\nstatic int beta __read_mostly = 717;\t \nstatic int initial_ssthresh __read_mostly;\nstatic int bic_scale __read_mostly = 41;\nstatic int tcp_friendliness __read_mostly = 1;\n\nstatic int hystart __read_mostly = 1;\nstatic int hystart_detect __read_mostly = HYSTART_ACK_TRAIN | HYSTART_DELAY;\nstatic int hystart_low_window __read_mostly = 16;\nstatic int hystart_ack_delta_us __read_mostly = 2000;\n\nstatic u32 cube_rtt_scale __read_mostly;\nstatic u32 beta_scale __read_mostly;\nstatic u64 cube_factor __read_mostly;\n\n \nmodule_param(fast_convergence, int, 0644);\nMODULE_PARM_DESC(fast_convergence, \"turn on/off fast convergence\");\nmodule_param(beta, int, 0644);\nMODULE_PARM_DESC(beta, \"beta for multiplicative increase\");\nmodule_param(initial_ssthresh, int, 0644);\nMODULE_PARM_DESC(initial_ssthresh, \"initial value of slow start threshold\");\nmodule_param(bic_scale, int, 0444);\nMODULE_PARM_DESC(bic_scale, \"scale (scaled by 1024) value for bic function (bic_scale/1024)\");\nmodule_param(tcp_friendliness, int, 0644);\nMODULE_PARM_DESC(tcp_friendliness, \"turn on/off tcp friendliness\");\nmodule_param(hystart, int, 0644);\nMODULE_PARM_DESC(hystart, \"turn on/off hybrid slow start algorithm\");\nmodule_param(hystart_detect, int, 0644);\nMODULE_PARM_DESC(hystart_detect, \"hybrid slow start detection mechanisms\"\n\t\t \" 1: packet-train 2: delay 3: both packet-train and delay\");\nmodule_param(hystart_low_window, int, 0644);\nMODULE_PARM_DESC(hystart_low_window, \"lower bound cwnd for hybrid slow start\");\nmodule_param(hystart_ack_delta_us, int, 0644);\nMODULE_PARM_DESC(hystart_ack_delta_us, \"spacing between ack's indicating train (usecs)\");\n\n \nstruct bictcp {\n\tu32\tcnt;\t\t \n\tu32\tlast_max_cwnd;\t \n\tu32\tlast_cwnd;\t \n\tu32\tlast_time;\t \n\tu32\tbic_origin_point; \n\tu32\tbic_K;\t\t \n\tu32\tdelay_min;\t \n\tu32\tepoch_start;\t \n\tu32\tack_cnt;\t \n\tu32\ttcp_cwnd;\t \n\tu16\tunused;\n\tu8\tsample_cnt;\t \n\tu8\tfound;\t\t \n\tu32\tround_start;\t \n\tu32\tend_seq;\t \n\tu32\tlast_ack;\t \n\tu32\tcurr_rtt;\t \n};\n\nstatic inline void bictcp_reset(struct bictcp *ca)\n{\n\tmemset(ca, 0, offsetof(struct bictcp, unused));\n\tca->found = 0;\n}\n\nstatic inline u32 bictcp_clock_us(const struct sock *sk)\n{\n\treturn tcp_sk(sk)->tcp_mstamp;\n}\n\nstatic inline void bictcp_hystart_reset(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bictcp *ca = inet_csk_ca(sk);\n\n\tca->round_start = ca->last_ack = bictcp_clock_us(sk);\n\tca->end_seq = tp->snd_nxt;\n\tca->curr_rtt = ~0U;\n\tca->sample_cnt = 0;\n}\n\n__bpf_kfunc static void cubictcp_init(struct sock *sk)\n{\n\tstruct bictcp *ca = inet_csk_ca(sk);\n\n\tbictcp_reset(ca);\n\n\tif (hystart)\n\t\tbictcp_hystart_reset(sk);\n\n\tif (!hystart && initial_ssthresh)\n\t\ttcp_sk(sk)->snd_ssthresh = initial_ssthresh;\n}\n\n__bpf_kfunc static void cubictcp_cwnd_event(struct sock *sk, enum tcp_ca_event event)\n{\n\tif (event == CA_EVENT_TX_START) {\n\t\tstruct bictcp *ca = inet_csk_ca(sk);\n\t\tu32 now = tcp_jiffies32;\n\t\ts32 delta;\n\n\t\tdelta = now - tcp_sk(sk)->lsndtime;\n\n\t\t \n\t\tif (ca->epoch_start && delta > 0) {\n\t\t\tca->epoch_start += delta;\n\t\t\tif (after(ca->epoch_start, now))\n\t\t\t\tca->epoch_start = now;\n\t\t}\n\t\treturn;\n\t}\n}\n\n \nstatic u32 cubic_root(u64 a)\n{\n\tu32 x, b, shift;\n\t \n\tstatic const u8 v[] = {\n\t\t     0,   54,   54,   54,  118,  118,  118,  118,\n\t\t   123,  129,  134,  138,  143,  147,  151,  156,\n\t\t   157,  161,  164,  168,  170,  173,  176,  179,\n\t\t   181,  185,  187,  190,  192,  194,  197,  199,\n\t\t   200,  202,  204,  206,  209,  211,  213,  215,\n\t\t   217,  219,  221,  222,  224,  225,  227,  229,\n\t\t   231,  232,  234,  236,  237,  239,  240,  242,\n\t\t   244,  245,  246,  248,  250,  251,  252,  254,\n\t};\n\n\tb = fls64(a);\n\tif (b < 7) {\n\t\t \n\t\treturn ((u32)v[(u32)a] + 35) >> 6;\n\t}\n\n\tb = ((b * 84) >> 8) - 1;\n\tshift = (a >> (b * 3));\n\n\tx = ((u32)(((u32)v[shift] + 10) << b)) >> 6;\n\n\t \n\tx = (2 * x + (u32)div64_u64(a, (u64)x * (u64)(x - 1)));\n\tx = ((x * 341) >> 10);\n\treturn x;\n}\n\n \nstatic inline void bictcp_update(struct bictcp *ca, u32 cwnd, u32 acked)\n{\n\tu32 delta, bic_target, max_cnt;\n\tu64 offs, t;\n\n\tca->ack_cnt += acked;\t \n\n\tif (ca->last_cwnd == cwnd &&\n\t    (s32)(tcp_jiffies32 - ca->last_time) <= HZ / 32)\n\t\treturn;\n\n\t \n\tif (ca->epoch_start && tcp_jiffies32 == ca->last_time)\n\t\tgoto tcp_friendliness;\n\n\tca->last_cwnd = cwnd;\n\tca->last_time = tcp_jiffies32;\n\n\tif (ca->epoch_start == 0) {\n\t\tca->epoch_start = tcp_jiffies32;\t \n\t\tca->ack_cnt = acked;\t\t\t \n\t\tca->tcp_cwnd = cwnd;\t\t\t \n\n\t\tif (ca->last_max_cwnd <= cwnd) {\n\t\t\tca->bic_K = 0;\n\t\t\tca->bic_origin_point = cwnd;\n\t\t} else {\n\t\t\t \n\t\t\tca->bic_K = cubic_root(cube_factor\n\t\t\t\t\t       * (ca->last_max_cwnd - cwnd));\n\t\t\tca->bic_origin_point = ca->last_max_cwnd;\n\t\t}\n\t}\n\n\t \n\t \n\n\tt = (s32)(tcp_jiffies32 - ca->epoch_start);\n\tt += usecs_to_jiffies(ca->delay_min);\n\t \n\tt <<= BICTCP_HZ;\n\tdo_div(t, HZ);\n\n\tif (t < ca->bic_K)\t\t \n\t\toffs = ca->bic_K - t;\n\telse\n\t\toffs = t - ca->bic_K;\n\n\t \n\tdelta = (cube_rtt_scale * offs * offs * offs) >> (10+3*BICTCP_HZ);\n\tif (t < ca->bic_K)                             \n\t\tbic_target = ca->bic_origin_point - delta;\n\telse                                           \n\t\tbic_target = ca->bic_origin_point + delta;\n\n\t \n\tif (bic_target > cwnd) {\n\t\tca->cnt = cwnd / (bic_target - cwnd);\n\t} else {\n\t\tca->cnt = 100 * cwnd;               \n\t}\n\n\t \n\tif (ca->last_max_cwnd == 0 && ca->cnt > 20)\n\t\tca->cnt = 20;\t \n\ntcp_friendliness:\n\t \n\tif (tcp_friendliness) {\n\t\tu32 scale = beta_scale;\n\n\t\tdelta = (cwnd * scale) >> 3;\n\t\twhile (ca->ack_cnt > delta) {\t\t \n\t\t\tca->ack_cnt -= delta;\n\t\t\tca->tcp_cwnd++;\n\t\t}\n\n\t\tif (ca->tcp_cwnd > cwnd) {\t \n\t\t\tdelta = ca->tcp_cwnd - cwnd;\n\t\t\tmax_cnt = cwnd / delta;\n\t\t\tif (ca->cnt > max_cnt)\n\t\t\t\tca->cnt = max_cnt;\n\t\t}\n\t}\n\n\t \n\tca->cnt = max(ca->cnt, 2U);\n}\n\n__bpf_kfunc static void cubictcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bictcp *ca = inet_csk_ca(sk);\n\n\tif (!tcp_is_cwnd_limited(sk))\n\t\treturn;\n\n\tif (tcp_in_slow_start(tp)) {\n\t\tacked = tcp_slow_start(tp, acked);\n\t\tif (!acked)\n\t\t\treturn;\n\t}\n\tbictcp_update(ca, tcp_snd_cwnd(tp), acked);\n\ttcp_cong_avoid_ai(tp, ca->cnt, acked);\n}\n\n__bpf_kfunc static u32 cubictcp_recalc_ssthresh(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct bictcp *ca = inet_csk_ca(sk);\n\n\tca->epoch_start = 0;\t \n\n\t \n\tif (tcp_snd_cwnd(tp) < ca->last_max_cwnd && fast_convergence)\n\t\tca->last_max_cwnd = (tcp_snd_cwnd(tp) * (BICTCP_BETA_SCALE + beta))\n\t\t\t/ (2 * BICTCP_BETA_SCALE);\n\telse\n\t\tca->last_max_cwnd = tcp_snd_cwnd(tp);\n\n\treturn max((tcp_snd_cwnd(tp) * beta) / BICTCP_BETA_SCALE, 2U);\n}\n\n__bpf_kfunc static void cubictcp_state(struct sock *sk, u8 new_state)\n{\n\tif (new_state == TCP_CA_Loss) {\n\t\tbictcp_reset(inet_csk_ca(sk));\n\t\tbictcp_hystart_reset(sk);\n\t}\n}\n\n \nstatic u32 hystart_ack_delay(const struct sock *sk)\n{\n\tunsigned long rate;\n\n\trate = READ_ONCE(sk->sk_pacing_rate);\n\tif (!rate)\n\t\treturn 0;\n\treturn min_t(u64, USEC_PER_MSEC,\n\t\t     div64_ul((u64)sk->sk_gso_max_size * 4 * USEC_PER_SEC, rate));\n}\n\nstatic void hystart_update(struct sock *sk, u32 delay)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bictcp *ca = inet_csk_ca(sk);\n\tu32 threshold;\n\n\tif (after(tp->snd_una, ca->end_seq))\n\t\tbictcp_hystart_reset(sk);\n\n\tif (hystart_detect & HYSTART_ACK_TRAIN) {\n\t\tu32 now = bictcp_clock_us(sk);\n\n\t\t \n\t\tif ((s32)(now - ca->last_ack) <= hystart_ack_delta_us) {\n\t\t\tca->last_ack = now;\n\n\t\t\tthreshold = ca->delay_min + hystart_ack_delay(sk);\n\n\t\t\t \n\t\t\tif (sk->sk_pacing_status == SK_PACING_NONE)\n\t\t\t\tthreshold >>= 1;\n\n\t\t\tif ((s32)(now - ca->round_start) > threshold) {\n\t\t\t\tca->found = 1;\n\t\t\t\tpr_debug(\"hystart_ack_train (%u > %u) delay_min %u (+ ack_delay %u) cwnd %u\\n\",\n\t\t\t\t\t now - ca->round_start, threshold,\n\t\t\t\t\t ca->delay_min, hystart_ack_delay(sk), tcp_snd_cwnd(tp));\n\t\t\t\tNET_INC_STATS(sock_net(sk),\n\t\t\t\t\t      LINUX_MIB_TCPHYSTARTTRAINDETECT);\n\t\t\t\tNET_ADD_STATS(sock_net(sk),\n\t\t\t\t\t      LINUX_MIB_TCPHYSTARTTRAINCWND,\n\t\t\t\t\t      tcp_snd_cwnd(tp));\n\t\t\t\ttp->snd_ssthresh = tcp_snd_cwnd(tp);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hystart_detect & HYSTART_DELAY) {\n\t\t \n\t\tif (ca->curr_rtt > delay)\n\t\t\tca->curr_rtt = delay;\n\t\tif (ca->sample_cnt < HYSTART_MIN_SAMPLES) {\n\t\t\tca->sample_cnt++;\n\t\t} else {\n\t\t\tif (ca->curr_rtt > ca->delay_min +\n\t\t\t    HYSTART_DELAY_THRESH(ca->delay_min >> 3)) {\n\t\t\t\tca->found = 1;\n\t\t\t\tNET_INC_STATS(sock_net(sk),\n\t\t\t\t\t      LINUX_MIB_TCPHYSTARTDELAYDETECT);\n\t\t\t\tNET_ADD_STATS(sock_net(sk),\n\t\t\t\t\t      LINUX_MIB_TCPHYSTARTDELAYCWND,\n\t\t\t\t\t      tcp_snd_cwnd(tp));\n\t\t\t\ttp->snd_ssthresh = tcp_snd_cwnd(tp);\n\t\t\t}\n\t\t}\n\t}\n}\n\n__bpf_kfunc static void cubictcp_acked(struct sock *sk, const struct ack_sample *sample)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct bictcp *ca = inet_csk_ca(sk);\n\tu32 delay;\n\n\t \n\tif (sample->rtt_us < 0)\n\t\treturn;\n\n\t \n\tif (ca->epoch_start && (s32)(tcp_jiffies32 - ca->epoch_start) < HZ)\n\t\treturn;\n\n\tdelay = sample->rtt_us;\n\tif (delay == 0)\n\t\tdelay = 1;\n\n\t \n\tif (ca->delay_min == 0 || ca->delay_min > delay)\n\t\tca->delay_min = delay;\n\n\t \n\tif (!ca->found && tcp_in_slow_start(tp) && hystart &&\n\t    tcp_snd_cwnd(tp) >= hystart_low_window)\n\t\thystart_update(sk, delay);\n}\n\nstatic struct tcp_congestion_ops cubictcp __read_mostly = {\n\t.init\t\t= cubictcp_init,\n\t.ssthresh\t= cubictcp_recalc_ssthresh,\n\t.cong_avoid\t= cubictcp_cong_avoid,\n\t.set_state\t= cubictcp_state,\n\t.undo_cwnd\t= tcp_reno_undo_cwnd,\n\t.cwnd_event\t= cubictcp_cwnd_event,\n\t.pkts_acked     = cubictcp_acked,\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"cubic\",\n};\n\nBTF_SET8_START(tcp_cubic_check_kfunc_ids)\n#ifdef CONFIG_X86\n#ifdef CONFIG_DYNAMIC_FTRACE\nBTF_ID_FLAGS(func, cubictcp_init)\nBTF_ID_FLAGS(func, cubictcp_recalc_ssthresh)\nBTF_ID_FLAGS(func, cubictcp_cong_avoid)\nBTF_ID_FLAGS(func, cubictcp_state)\nBTF_ID_FLAGS(func, cubictcp_cwnd_event)\nBTF_ID_FLAGS(func, cubictcp_acked)\n#endif\n#endif\nBTF_SET8_END(tcp_cubic_check_kfunc_ids)\n\nstatic const struct btf_kfunc_id_set tcp_cubic_kfunc_set = {\n\t.owner = THIS_MODULE,\n\t.set   = &tcp_cubic_check_kfunc_ids,\n};\n\nstatic int __init cubictcp_register(void)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct bictcp) > ICSK_CA_PRIV_SIZE);\n\n\t \n\n\tbeta_scale = 8*(BICTCP_BETA_SCALE+beta) / 3\n\t\t/ (BICTCP_BETA_SCALE - beta);\n\n\tcube_rtt_scale = (bic_scale * 10);\t \n\n\t \n\n\t \n\tcube_factor = 1ull << (10+3*BICTCP_HZ);  \n\n\t \n\tdo_div(cube_factor, bic_scale * 10);\n\n\tret = register_btf_kfunc_id_set(BPF_PROG_TYPE_STRUCT_OPS, &tcp_cubic_kfunc_set);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn tcp_register_congestion_control(&cubictcp);\n}\n\nstatic void __exit cubictcp_unregister(void)\n{\n\ttcp_unregister_congestion_control(&cubictcp);\n}\n\nmodule_init(cubictcp_register);\nmodule_exit(cubictcp_unregister);\n\nMODULE_AUTHOR(\"Sangtae Ha, Stephen Hemminger\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"CUBIC TCP\");\nMODULE_VERSION(\"2.3\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}