{
  "module_name": "ip_input.c",
  "hash_id": "4f4498d8bd4fe79c1f1d6645fbb34f0095ae82d2dcd715d567c811ac167fd590",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ip_input.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"IPv4: \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n\n#include <linux/net.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/indirect_call_wrapper.h>\n\n#include <net/snmp.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/route.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/arp.h>\n#include <net/icmp.h>\n#include <net/raw.h>\n#include <net/checksum.h>\n#include <net/inet_ecn.h>\n#include <linux/netfilter_ipv4.h>\n#include <net/xfrm.h>\n#include <linux/mroute.h>\n#include <linux/netlink.h>\n#include <net/dst_metadata.h>\n\n \nbool ip_call_ra_chain(struct sk_buff *skb)\n{\n\tstruct ip_ra_chain *ra;\n\tu8 protocol = ip_hdr(skb)->protocol;\n\tstruct sock *last = NULL;\n\tstruct net_device *dev = skb->dev;\n\tstruct net *net = dev_net(dev);\n\n\tfor (ra = rcu_dereference(net->ipv4.ra_chain); ra; ra = rcu_dereference(ra->next)) {\n\t\tstruct sock *sk = ra->sk;\n\n\t\t \n\t\tif (sk && inet_sk(sk)->inet_num == protocol &&\n\t\t    (!sk->sk_bound_dev_if ||\n\t\t     sk->sk_bound_dev_if == dev->ifindex)) {\n\t\t\tif (ip_is_fragment(ip_hdr(skb))) {\n\t\t\t\tif (ip_defrag(net, skb, IP_DEFRAG_CALL_RA_CHAIN))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (last) {\n\t\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (skb2)\n\t\t\t\t\traw_rcv(last, skb2);\n\t\t\t}\n\t\t\tlast = sk;\n\t\t}\n\t}\n\n\tif (last) {\n\t\traw_rcv(last, skb);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nINDIRECT_CALLABLE_DECLARE(int udp_rcv(struct sk_buff *));\nINDIRECT_CALLABLE_DECLARE(int tcp_v4_rcv(struct sk_buff *));\nvoid ip_protocol_deliver_rcu(struct net *net, struct sk_buff *skb, int protocol)\n{\n\tconst struct net_protocol *ipprot;\n\tint raw, ret;\n\nresubmit:\n\traw = raw_local_deliver(skb, protocol);\n\n\tipprot = rcu_dereference(inet_protos[protocol]);\n\tif (ipprot) {\n\t\tif (!ipprot->no_policy) {\n\t\t\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\t\t\tkfree_skb_reason(skb,\n\t\t\t\t\t\t SKB_DROP_REASON_XFRM_POLICY);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnf_reset_ct(skb);\n\t\t}\n\t\tret = INDIRECT_CALL_2(ipprot->handler, tcp_v4_rcv, udp_rcv,\n\t\t\t\t      skb);\n\t\tif (ret < 0) {\n\t\t\tprotocol = -ret;\n\t\t\tgoto resubmit;\n\t\t}\n\t\t__IP_INC_STATS(net, IPSTATS_MIB_INDELIVERS);\n\t} else {\n\t\tif (!raw) {\n\t\t\tif (xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\t\t\t__IP_INC_STATS(net, IPSTATS_MIB_INUNKNOWNPROTOS);\n\t\t\t\ticmp_send(skb, ICMP_DEST_UNREACH,\n\t\t\t\t\t  ICMP_PROT_UNREACH, 0);\n\t\t\t}\n\t\t\tkfree_skb_reason(skb, SKB_DROP_REASON_IP_NOPROTO);\n\t\t} else {\n\t\t\t__IP_INC_STATS(net, IPSTATS_MIB_INDELIVERS);\n\t\t\tconsume_skb(skb);\n\t\t}\n\t}\n}\n\nstatic int ip_local_deliver_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tskb_clear_delivery_time(skb);\n\t__skb_pull(skb, skb_network_header_len(skb));\n\n\trcu_read_lock();\n\tip_protocol_deliver_rcu(net, skb, ip_hdr(skb)->protocol);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\n \nint ip_local_deliver(struct sk_buff *skb)\n{\n\t \n\tstruct net *net = dev_net(skb->dev);\n\n\tif (ip_is_fragment(ip_hdr(skb))) {\n\t\tif (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))\n\t\t\treturn 0;\n\t}\n\n\treturn NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN,\n\t\t       net, NULL, skb, skb->dev, NULL,\n\t\t       ip_local_deliver_finish);\n}\nEXPORT_SYMBOL(ip_local_deliver);\n\nstatic inline bool ip_rcv_options(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip_options *opt;\n\tconst struct iphdr *iph;\n\n\t \n\tif (skb_cow(skb, skb_headroom(skb))) {\n\t\t__IP_INC_STATS(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\n\tif (ip_options_compile(dev_net(dev), opt, skb)) {\n\t\t__IP_INC_STATS(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\n\t\tgoto drop;\n\t}\n\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\n\t\tif (in_dev) {\n\t\t\tif (!IN_DEV_SOURCE_ROUTE(in_dev)) {\n\t\t\t\tif (IN_DEV_LOG_MARTIANS(in_dev))\n\t\t\t\t\tnet_info_ratelimited(\"source route option %pI4 -> %pI4\\n\",\n\t\t\t\t\t\t\t     &iph->saddr,\n\t\t\t\t\t\t\t     &iph->daddr);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\n\t\tif (ip_options_rcv_srr(skb, dev))\n\t\t\tgoto drop;\n\t}\n\n\treturn false;\ndrop:\n\treturn true;\n}\n\nstatic bool ip_can_use_hint(const struct sk_buff *skb, const struct iphdr *iph,\n\t\t\t    const struct sk_buff *hint)\n{\n\treturn hint && !skb_dst(skb) && ip_hdr(hint)->daddr == iph->daddr &&\n\t       ip_hdr(hint)->tos == iph->tos;\n}\n\nint tcp_v4_early_demux(struct sk_buff *skb);\nint udp_v4_early_demux(struct sk_buff *skb);\nstatic int ip_rcv_finish_core(struct net *net, struct sock *sk,\n\t\t\t      struct sk_buff *skb, struct net_device *dev,\n\t\t\t      const struct sk_buff *hint)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tint err, drop_reason;\n\tstruct rtable *rt;\n\n\tdrop_reason = SKB_DROP_REASON_NOT_SPECIFIED;\n\n\tif (ip_can_use_hint(skb, iph, hint)) {\n\t\terr = ip_route_use_hint(skb, iph->daddr, iph->saddr, iph->tos,\n\t\t\t\t\tdev, hint);\n\t\tif (unlikely(err))\n\t\t\tgoto drop_error;\n\t}\n\n\tif (READ_ONCE(net->ipv4.sysctl_ip_early_demux) &&\n\t    !skb_dst(skb) &&\n\t    !skb->sk &&\n\t    !ip_is_fragment(iph)) {\n\t\tswitch (iph->protocol) {\n\t\tcase IPPROTO_TCP:\n\t\t\tif (READ_ONCE(net->ipv4.sysctl_tcp_early_demux)) {\n\t\t\t\ttcp_v4_early_demux(skb);\n\n\t\t\t\t \n\t\t\t\tiph = ip_hdr(skb);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IPPROTO_UDP:\n\t\t\tif (READ_ONCE(net->ipv4.sysctl_udp_early_demux)) {\n\t\t\t\terr = udp_v4_early_demux(skb);\n\t\t\t\tif (unlikely(err))\n\t\t\t\t\tgoto drop_error;\n\n\t\t\t\t \n\t\t\t\tiph = ip_hdr(skb);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!skb_valid_dst(skb)) {\n\t\terr = ip_route_input_noref(skb, iph->daddr, iph->saddr,\n\t\t\t\t\t   iph->tos, dev);\n\t\tif (unlikely(err))\n\t\t\tgoto drop_error;\n\t} else {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\n\t\tif (in_dev && IN_DEV_ORCONF(in_dev, NOPOLICY))\n\t\t\tIPCB(skb)->flags |= IPSKB_NOPOLICY;\n\t}\n\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tif (unlikely(skb_dst(skb)->tclassid)) {\n\t\tstruct ip_rt_acct *st = this_cpu_ptr(ip_rt_acct);\n\t\tu32 idx = skb_dst(skb)->tclassid;\n\t\tst[idx&0xFF].o_packets++;\n\t\tst[idx&0xFF].o_bytes += skb->len;\n\t\tst[(idx>>16)&0xFF].i_packets++;\n\t\tst[(idx>>16)&0xFF].i_bytes += skb->len;\n\t}\n#endif\n\n\tif (iph->ihl > 5 && ip_rcv_options(skb, dev))\n\t\tgoto drop;\n\n\trt = skb_rtable(skb);\n\tif (rt->rt_type == RTN_MULTICAST) {\n\t\t__IP_UPD_PO_STATS(net, IPSTATS_MIB_INMCAST, skb->len);\n\t} else if (rt->rt_type == RTN_BROADCAST) {\n\t\t__IP_UPD_PO_STATS(net, IPSTATS_MIB_INBCAST, skb->len);\n\t} else if (skb->pkt_type == PACKET_BROADCAST ||\n\t\t   skb->pkt_type == PACKET_MULTICAST) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\n\t\t \n\t\tif (in_dev &&\n\t\t    IN_DEV_ORCONF(in_dev, DROP_UNICAST_IN_L2_MULTICAST)) {\n\t\t\tdrop_reason = SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\treturn NET_RX_SUCCESS;\n\ndrop:\n\tkfree_skb_reason(skb, drop_reason);\n\treturn NET_RX_DROP;\n\ndrop_error:\n\tif (err == -EXDEV) {\n\t\tdrop_reason = SKB_DROP_REASON_IP_RPFILTER;\n\t\t__NET_INC_STATS(net, LINUX_MIB_IPRPFILTER);\n\t}\n\tgoto drop;\n}\n\nstatic int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tint ret;\n\n\t \n\tskb = l3mdev_ip_rcv(skb);\n\tif (!skb)\n\t\treturn NET_RX_SUCCESS;\n\n\tret = ip_rcv_finish_core(net, sk, skb, dev, NULL);\n\tif (ret != NET_RX_DROP)\n\t\tret = dst_input(skb);\n\treturn ret;\n}\n\n \nstatic struct sk_buff *ip_rcv_core(struct sk_buff *skb, struct net *net)\n{\n\tconst struct iphdr *iph;\n\tint drop_reason;\n\tu32 len;\n\n\t \n\tif (skb->pkt_type == PACKET_OTHERHOST) {\n\t\tdev_core_stats_rx_otherhost_dropped_inc(skb->dev);\n\t\tdrop_reason = SKB_DROP_REASON_OTHERHOST;\n\t\tgoto drop;\n\t}\n\n\t__IP_UPD_PO_STATS(net, IPSTATS_MIB_IN, skb->len);\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb) {\n\t\t__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);\n\t\tgoto out;\n\t}\n\n\tdrop_reason = SKB_DROP_REASON_NOT_SPECIFIED;\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\tgoto inhdr_error;\n\n\tiph = ip_hdr(skb);\n\n\t \n\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\n\tBUILD_BUG_ON(IPSTATS_MIB_ECT1PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_1);\n\tBUILD_BUG_ON(IPSTATS_MIB_ECT0PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_0);\n\tBUILD_BUG_ON(IPSTATS_MIB_CEPKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_CE);\n\t__IP_ADD_STATS(net,\n\t\t       IPSTATS_MIB_NOECTPKTS + (iph->tos & INET_ECN_MASK),\n\t\t       max_t(unsigned short, 1, skb_shinfo(skb)->gso_segs));\n\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tiph = ip_hdr(skb);\n\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto csum_error;\n\n\tlen = iph_totlen(skb, iph);\n\tif (skb->len < len) {\n\t\tdrop_reason = SKB_DROP_REASON_PKT_TOO_SMALL;\n\t\t__IP_INC_STATS(net, IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\t \n\tif (pskb_trim_rcsum(skb, len)) {\n\t\t__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tiph = ip_hdr(skb);\n\tskb->transport_header = skb->network_header + iph->ihl*4;\n\n\t \n\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\tIPCB(skb)->iif = skb->skb_iif;\n\n\t \n\tif (!skb_sk_is_prefetched(skb))\n\t\tskb_orphan(skb);\n\n\treturn skb;\n\ncsum_error:\n\tdrop_reason = SKB_DROP_REASON_IP_CSUM;\n\t__IP_INC_STATS(net, IPSTATS_MIB_CSUMERRORS);\ninhdr_error:\n\tif (drop_reason == SKB_DROP_REASON_NOT_SPECIFIED)\n\t\tdrop_reason = SKB_DROP_REASON_IP_INHDR;\n\t__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);\ndrop:\n\tkfree_skb_reason(skb, drop_reason);\nout:\n\treturn NULL;\n}\n\n \nint ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,\n\t   struct net_device *orig_dev)\n{\n\tstruct net *net = dev_net(dev);\n\n\tskb = ip_rcv_core(skb, net);\n\tif (skb == NULL)\n\t\treturn NET_RX_DROP;\n\n\treturn NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,\n\t\t       net, NULL, skb, dev, NULL,\n\t\t       ip_rcv_finish);\n}\n\nstatic void ip_sublist_rcv_finish(struct list_head *head)\n{\n\tstruct sk_buff *skb, *next;\n\n\tlist_for_each_entry_safe(skb, next, head, list) {\n\t\tskb_list_del_init(skb);\n\t\tdst_input(skb);\n\t}\n}\n\nstatic struct sk_buff *ip_extract_route_hint(const struct net *net,\n\t\t\t\t\t     struct sk_buff *skb, int rt_type)\n{\n\tif (fib4_has_custom_rules(net) || rt_type == RTN_BROADCAST ||\n\t    IPCB(skb)->flags & IPSKB_MULTIPATH)\n\t\treturn NULL;\n\n\treturn skb;\n}\n\nstatic void ip_list_rcv_finish(struct net *net, struct sock *sk,\n\t\t\t       struct list_head *head)\n{\n\tstruct sk_buff *skb, *next, *hint = NULL;\n\tstruct dst_entry *curr_dst = NULL;\n\tstruct list_head sublist;\n\n\tINIT_LIST_HEAD(&sublist);\n\tlist_for_each_entry_safe(skb, next, head, list) {\n\t\tstruct net_device *dev = skb->dev;\n\t\tstruct dst_entry *dst;\n\n\t\tskb_list_del_init(skb);\n\t\t \n\t\tskb = l3mdev_ip_rcv(skb);\n\t\tif (!skb)\n\t\t\tcontinue;\n\t\tif (ip_rcv_finish_core(net, sk, skb, dev, hint) == NET_RX_DROP)\n\t\t\tcontinue;\n\n\t\tdst = skb_dst(skb);\n\t\tif (curr_dst != dst) {\n\t\t\thint = ip_extract_route_hint(net, skb,\n\t\t\t\t\t       ((struct rtable *)dst)->rt_type);\n\n\t\t\t \n\t\t\tif (!list_empty(&sublist))\n\t\t\t\tip_sublist_rcv_finish(&sublist);\n\t\t\t \n\t\t\tINIT_LIST_HEAD(&sublist);\n\t\t\tcurr_dst = dst;\n\t\t}\n\t\tlist_add_tail(&skb->list, &sublist);\n\t}\n\t \n\tip_sublist_rcv_finish(&sublist);\n}\n\nstatic void ip_sublist_rcv(struct list_head *head, struct net_device *dev,\n\t\t\t   struct net *net)\n{\n\tNF_HOOK_LIST(NFPROTO_IPV4, NF_INET_PRE_ROUTING, net, NULL,\n\t\t     head, dev, NULL, ip_rcv_finish);\n\tip_list_rcv_finish(net, NULL, head);\n}\n\n \nvoid ip_list_rcv(struct list_head *head, struct packet_type *pt,\n\t\t struct net_device *orig_dev)\n{\n\tstruct net_device *curr_dev = NULL;\n\tstruct net *curr_net = NULL;\n\tstruct sk_buff *skb, *next;\n\tstruct list_head sublist;\n\n\tINIT_LIST_HEAD(&sublist);\n\tlist_for_each_entry_safe(skb, next, head, list) {\n\t\tstruct net_device *dev = skb->dev;\n\t\tstruct net *net = dev_net(dev);\n\n\t\tskb_list_del_init(skb);\n\t\tskb = ip_rcv_core(skb, net);\n\t\tif (skb == NULL)\n\t\t\tcontinue;\n\n\t\tif (curr_dev != dev || curr_net != net) {\n\t\t\t \n\t\t\tif (!list_empty(&sublist))\n\t\t\t\tip_sublist_rcv(&sublist, curr_dev, curr_net);\n\t\t\t \n\t\t\tINIT_LIST_HEAD(&sublist);\n\t\t\tcurr_dev = dev;\n\t\t\tcurr_net = net;\n\t\t}\n\t\tlist_add_tail(&skb->list, &sublist);\n\t}\n\t \n\tif (!list_empty(&sublist))\n\t\tip_sublist_rcv(&sublist, curr_dev, curr_net);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}