{
  "module_name": "udp_tunnel_core.c",
  "hash_id": "92d3867ed5ca508297cb338c98d5d2cc4fec771e61af2e750546730c11ed3747",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/udp_tunnel_core.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/socket.h>\n#include <linux/kernel.h>\n#include <net/dst_metadata.h>\n#include <net/udp.h>\n#include <net/udp_tunnel.h>\n\nint udp_sock_create4(struct net *net, struct udp_port_cfg *cfg,\n\t\t     struct socket **sockp)\n{\n\tint err;\n\tstruct socket *sock = NULL;\n\tstruct sockaddr_in udp_addr;\n\n\terr = sock_create_kern(net, AF_INET, SOCK_DGRAM, 0, &sock);\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (cfg->bind_ifindex) {\n\t\terr = sock_bindtoindex(sock->sk, cfg->bind_ifindex, true);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\tudp_addr.sin_family = AF_INET;\n\tudp_addr.sin_addr = cfg->local_ip;\n\tudp_addr.sin_port = cfg->local_udp_port;\n\terr = kernel_bind(sock, (struct sockaddr *)&udp_addr,\n\t\t\t  sizeof(udp_addr));\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (cfg->peer_udp_port) {\n\t\tudp_addr.sin_family = AF_INET;\n\t\tudp_addr.sin_addr = cfg->peer_ip;\n\t\tudp_addr.sin_port = cfg->peer_udp_port;\n\t\terr = kernel_connect(sock, (struct sockaddr *)&udp_addr,\n\t\t\t\t     sizeof(udp_addr), 0);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\tsock->sk->sk_no_check_tx = !cfg->use_udp_checksums;\n\n\t*sockp = sock;\n\treturn 0;\n\nerror:\n\tif (sock) {\n\t\tkernel_sock_shutdown(sock, SHUT_RDWR);\n\t\tsock_release(sock);\n\t}\n\t*sockp = NULL;\n\treturn err;\n}\nEXPORT_SYMBOL(udp_sock_create4);\n\nvoid setup_udp_tunnel_sock(struct net *net, struct socket *sock,\n\t\t\t   struct udp_tunnel_sock_cfg *cfg)\n{\n\tstruct sock *sk = sock->sk;\n\n\t \n\tinet_clear_bit(MC_LOOP, sk);\n\n\t \n\tinet_inc_convert_csum(sk);\n\n\trcu_assign_sk_user_data(sk, cfg->sk_user_data);\n\n\tudp_sk(sk)->encap_type = cfg->encap_type;\n\tudp_sk(sk)->encap_rcv = cfg->encap_rcv;\n\tudp_sk(sk)->encap_err_rcv = cfg->encap_err_rcv;\n\tudp_sk(sk)->encap_err_lookup = cfg->encap_err_lookup;\n\tudp_sk(sk)->encap_destroy = cfg->encap_destroy;\n\tudp_sk(sk)->gro_receive = cfg->gro_receive;\n\tudp_sk(sk)->gro_complete = cfg->gro_complete;\n\n\tudp_tunnel_encap_enable(sk);\n}\nEXPORT_SYMBOL_GPL(setup_udp_tunnel_sock);\n\nvoid udp_tunnel_push_rx_port(struct net_device *dev, struct socket *sock,\n\t\t\t     unsigned short type)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct udp_tunnel_info ti;\n\n\tti.type = type;\n\tti.sa_family = sk->sk_family;\n\tti.port = inet_sk(sk)->inet_sport;\n\n\tudp_tunnel_nic_add_port(dev, &ti);\n}\nEXPORT_SYMBOL_GPL(udp_tunnel_push_rx_port);\n\nvoid udp_tunnel_drop_rx_port(struct net_device *dev, struct socket *sock,\n\t\t\t     unsigned short type)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct udp_tunnel_info ti;\n\n\tti.type = type;\n\tti.sa_family = sk->sk_family;\n\tti.port = inet_sk(sk)->inet_sport;\n\n\tudp_tunnel_nic_del_port(dev, &ti);\n}\nEXPORT_SYMBOL_GPL(udp_tunnel_drop_rx_port);\n\n \nvoid udp_tunnel_notify_add_rx_port(struct socket *sock, unsigned short type)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct udp_tunnel_info ti;\n\tstruct net_device *dev;\n\n\tti.type = type;\n\tti.sa_family = sk->sk_family;\n\tti.port = inet_sk(sk)->inet_sport;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tudp_tunnel_nic_add_port(dev, &ti);\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(udp_tunnel_notify_add_rx_port);\n\n \nvoid udp_tunnel_notify_del_rx_port(struct socket *sock, unsigned short type)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct udp_tunnel_info ti;\n\tstruct net_device *dev;\n\n\tti.type = type;\n\tti.sa_family = sk->sk_family;\n\tti.port = inet_sk(sk)->inet_sport;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tudp_tunnel_nic_del_port(dev, &ti);\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(udp_tunnel_notify_del_rx_port);\n\nvoid udp_tunnel_xmit_skb(struct rtable *rt, struct sock *sk, struct sk_buff *skb,\n\t\t\t __be32 src, __be32 dst, __u8 tos, __u8 ttl,\n\t\t\t __be16 df, __be16 src_port, __be16 dst_port,\n\t\t\t bool xnet, bool nocheck)\n{\n\tstruct udphdr *uh;\n\n\t__skb_push(skb, sizeof(*uh));\n\tskb_reset_transport_header(skb);\n\tuh = udp_hdr(skb);\n\n\tuh->dest = dst_port;\n\tuh->source = src_port;\n\tuh->len = htons(skb->len);\n\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\n\tudp_set_csum(nocheck, skb, src, dst, skb->len);\n\n\tiptunnel_xmit(sk, rt, skb, src, dst, IPPROTO_UDP, tos, ttl, df, xnet);\n}\nEXPORT_SYMBOL_GPL(udp_tunnel_xmit_skb);\n\nvoid udp_tunnel_sock_release(struct socket *sock)\n{\n\trcu_assign_sk_user_data(sock->sk, NULL);\n\tsynchronize_rcu();\n\tkernel_sock_shutdown(sock, SHUT_RDWR);\n\tsock_release(sock);\n}\nEXPORT_SYMBOL_GPL(udp_tunnel_sock_release);\n\nstruct metadata_dst *udp_tun_rx_dst(struct sk_buff *skb,  unsigned short family,\n\t\t\t\t    __be16 flags, __be64 tunnel_id, int md_size)\n{\n\tstruct metadata_dst *tun_dst;\n\tstruct ip_tunnel_info *info;\n\n\tif (family == AF_INET)\n\t\ttun_dst = ip_tun_rx_dst(skb, flags, tunnel_id, md_size);\n\telse\n\t\ttun_dst = ipv6_tun_rx_dst(skb, flags, tunnel_id, md_size);\n\tif (!tun_dst)\n\t\treturn NULL;\n\n\tinfo = &tun_dst->u.tun_info;\n\tinfo->key.tp_src = udp_hdr(skb)->source;\n\tinfo->key.tp_dst = udp_hdr(skb)->dest;\n\tif (udp_hdr(skb)->check)\n\t\tinfo->key.tun_flags |= TUNNEL_CSUM;\n\treturn tun_dst;\n}\nEXPORT_SYMBOL_GPL(udp_tun_rx_dst);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}