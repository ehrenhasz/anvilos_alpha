{
  "module_name": "fib_rules.c",
  "hash_id": "4a39a012ff51aa1220726ed1efd239e23d9e39b3d5c9480df7b26e0c615a2f96",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/fib_rules.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/inetdevice.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/export.h>\n#include <net/inet_dscp.h>\n#include <net/ip.h>\n#include <net/route.h>\n#include <net/tcp.h>\n#include <net/ip_fib.h>\n#include <net/nexthop.h>\n#include <net/fib_rules.h>\n#include <linux/indirect_call_wrapper.h>\n\nstruct fib4_rule {\n\tstruct fib_rule\t\tcommon;\n\tu8\t\t\tdst_len;\n\tu8\t\t\tsrc_len;\n\tdscp_t\t\t\tdscp;\n\t__be32\t\t\tsrc;\n\t__be32\t\t\tsrcmask;\n\t__be32\t\t\tdst;\n\t__be32\t\t\tdstmask;\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tu32\t\t\ttclassid;\n#endif\n};\n\nstatic bool fib4_rule_matchall(const struct fib_rule *rule)\n{\n\tstruct fib4_rule *r = container_of(rule, struct fib4_rule, common);\n\n\tif (r->dst_len || r->src_len || r->dscp)\n\t\treturn false;\n\treturn fib_rule_matchall(rule);\n}\n\nbool fib4_rule_default(const struct fib_rule *rule)\n{\n\tif (!fib4_rule_matchall(rule) || rule->action != FR_ACT_TO_TBL ||\n\t    rule->l3mdev)\n\t\treturn false;\n\tif (rule->table != RT_TABLE_LOCAL && rule->table != RT_TABLE_MAIN &&\n\t    rule->table != RT_TABLE_DEFAULT)\n\t\treturn false;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(fib4_rule_default);\n\nint fib4_rules_dump(struct net *net, struct notifier_block *nb,\n\t\t    struct netlink_ext_ack *extack)\n{\n\treturn fib_rules_dump(net, nb, AF_INET, extack);\n}\n\nunsigned int fib4_rules_seq_read(struct net *net)\n{\n\treturn fib_rules_seq_read(net, AF_INET);\n}\n\nint __fib_lookup(struct net *net, struct flowi4 *flp,\n\t\t struct fib_result *res, unsigned int flags)\n{\n\tstruct fib_lookup_arg arg = {\n\t\t.result = res,\n\t\t.flags = flags,\n\t};\n\tint err;\n\n\t \n\tl3mdev_update_flow(net, flowi4_to_flowi(flp));\n\n\terr = fib_rules_lookup(net->ipv4.rules_ops, flowi4_to_flowi(flp), 0, &arg);\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tif (arg.rule)\n\t\tres->tclassid = ((struct fib4_rule *)arg.rule)->tclassid;\n\telse\n\t\tres->tclassid = 0;\n#endif\n\n\tif (err == -ESRCH)\n\t\terr = -ENETUNREACH;\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__fib_lookup);\n\nINDIRECT_CALLABLE_SCOPE int fib4_rule_action(struct fib_rule *rule,\n\t\t\t\t\t     struct flowi *flp, int flags,\n\t\t\t\t\t     struct fib_lookup_arg *arg)\n{\n\tint err = -EAGAIN;\n\tstruct fib_table *tbl;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\n\tcase FR_ACT_UNREACHABLE:\n\t\treturn -ENETUNREACH;\n\n\tcase FR_ACT_PROHIBIT:\n\t\treturn -EACCES;\n\n\tcase FR_ACT_BLACKHOLE:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trcu_read_lock();\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttbl = fib_get_table(rule->fr_net, tb_id);\n\tif (tbl)\n\t\terr = fib_table_lookup(tbl, &flp->u.ip4,\n\t\t\t\t       (struct fib_result *)arg->result,\n\t\t\t\t       arg->flags);\n\n\trcu_read_unlock();\n\treturn err;\n}\n\nINDIRECT_CALLABLE_SCOPE bool fib4_rule_suppress(struct fib_rule *rule,\n\t\t\t\t\t\tint flags,\n\t\t\t\t\t\tstruct fib_lookup_arg *arg)\n{\n\tstruct fib_result *result = arg->result;\n\tstruct net_device *dev = NULL;\n\n\tif (result->fi) {\n\t\tstruct fib_nh_common *nhc = fib_info_nhc(result->fi, 0);\n\n\t\tdev = nhc->nhc_dev;\n\t}\n\n\t \n\tif (result->prefixlen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\n\t \n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\n\treturn false;\n\nsuppress_route:\n\tif (!(arg->flags & FIB_LOOKUP_NOREF))\n\t\tfib_info_put(result->fi);\n\treturn true;\n}\n\nINDIRECT_CALLABLE_SCOPE int fib4_rule_match(struct fib_rule *rule,\n\t\t\t\t\t    struct flowi *fl, int flags)\n{\n\tstruct fib4_rule *r = (struct fib4_rule *) rule;\n\tstruct flowi4 *fl4 = &fl->u.ip4;\n\t__be32 daddr = fl4->daddr;\n\t__be32 saddr = fl4->saddr;\n\n\tif (((saddr ^ r->src) & r->srcmask) ||\n\t    ((daddr ^ r->dst) & r->dstmask))\n\t\treturn 0;\n\n\tif (r->dscp && r->dscp != inet_dsfield_to_dscp(fl4->flowi4_tos))\n\t\treturn 0;\n\n\tif (rule->ip_proto && (rule->ip_proto != fl4->flowi4_proto))\n\t\treturn 0;\n\n\tif (fib_rule_port_range_set(&rule->sport_range) &&\n\t    !fib_rule_port_inrange(&rule->sport_range, fl4->fl4_sport))\n\t\treturn 0;\n\n\tif (fib_rule_port_range_set(&rule->dport_range) &&\n\t    !fib_rule_port_inrange(&rule->dport_range, fl4->fl4_dport))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic struct fib_table *fib_empty_table(struct net *net)\n{\n\tu32 id = 1;\n\n\twhile (1) {\n\t\tif (!fib_get_table(net, id))\n\t\t\treturn fib_new_table(net, id);\n\n\t\tif (id++ == RT_TABLE_MAX)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic int fib4_rule_configure(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t       struct fib_rule_hdr *frh,\n\t\t\t       struct nlattr **tb,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint err = -EINVAL;\n\tstruct fib4_rule *rule4 = (struct fib4_rule *) rule;\n\n\tif (!inet_validate_dscp(frh->tos)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid dsfield (tos): ECN bits must be 0\");\n\t\tgoto errout;\n\t}\n\t \n\tif (frh->tos & ~IPTOS_TOS_MASK) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid tos\");\n\t\tgoto errout;\n\t}\n\trule4->dscp = inet_dsfield_to_dscp(frh->tos);\n\n\t \n\terr = fib_unmerge(net);\n\tif (err)\n\t\tgoto errout;\n\n\tif (rule->table == RT_TABLE_UNSPEC && !rule->l3mdev) {\n\t\tif (rule->action == FR_ACT_TO_TBL) {\n\t\t\tstruct fib_table *table;\n\n\t\t\ttable = fib_empty_table(net);\n\t\t\tif (!table) {\n\t\t\t\terr = -ENOBUFS;\n\t\t\t\tgoto errout;\n\t\t\t}\n\n\t\t\trule->table = table->tb_id;\n\t\t}\n\t}\n\n\tif (frh->src_len)\n\t\trule4->src = nla_get_in_addr(tb[FRA_SRC]);\n\n\tif (frh->dst_len)\n\t\trule4->dst = nla_get_in_addr(tb[FRA_DST]);\n\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tif (tb[FRA_FLOW]) {\n\t\trule4->tclassid = nla_get_u32(tb[FRA_FLOW]);\n\t\tif (rule4->tclassid)\n\t\t\tatomic_inc(&net->ipv4.fib_num_tclassid_users);\n\t}\n#endif\n\n\tif (fib_rule_requires_fldissect(rule))\n\t\tnet->ipv4.fib_rules_require_fldissect++;\n\n\trule4->src_len = frh->src_len;\n\trule4->srcmask = inet_make_mask(rule4->src_len);\n\trule4->dst_len = frh->dst_len;\n\trule4->dstmask = inet_make_mask(rule4->dst_len);\n\n\tnet->ipv4.fib_has_custom_rules = true;\n\n\terr = 0;\nerrout:\n\treturn err;\n}\n\nstatic int fib4_rule_delete(struct fib_rule *rule)\n{\n\tstruct net *net = rule->fr_net;\n\tint err;\n\n\t \n\terr = fib_unmerge(net);\n\tif (err)\n\t\tgoto errout;\n\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tif (((struct fib4_rule *)rule)->tclassid)\n\t\tatomic_dec(&net->ipv4.fib_num_tclassid_users);\n#endif\n\tnet->ipv4.fib_has_custom_rules = true;\n\n\tif (net->ipv4.fib_rules_require_fldissect &&\n\t    fib_rule_requires_fldissect(rule))\n\t\tnet->ipv4.fib_rules_require_fldissect--;\nerrout:\n\treturn err;\n}\n\nstatic int fib4_rule_compare(struct fib_rule *rule, struct fib_rule_hdr *frh,\n\t\t\t     struct nlattr **tb)\n{\n\tstruct fib4_rule *rule4 = (struct fib4_rule *) rule;\n\n\tif (frh->src_len && (rule4->src_len != frh->src_len))\n\t\treturn 0;\n\n\tif (frh->dst_len && (rule4->dst_len != frh->dst_len))\n\t\treturn 0;\n\n\tif (frh->tos && inet_dscp_to_dsfield(rule4->dscp) != frh->tos)\n\t\treturn 0;\n\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tif (tb[FRA_FLOW] && (rule4->tclassid != nla_get_u32(tb[FRA_FLOW])))\n\t\treturn 0;\n#endif\n\n\tif (frh->src_len && (rule4->src != nla_get_in_addr(tb[FRA_SRC])))\n\t\treturn 0;\n\n\tif (frh->dst_len && (rule4->dst != nla_get_in_addr(tb[FRA_DST])))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int fib4_rule_fill(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t  struct fib_rule_hdr *frh)\n{\n\tstruct fib4_rule *rule4 = (struct fib4_rule *) rule;\n\n\tfrh->dst_len = rule4->dst_len;\n\tfrh->src_len = rule4->src_len;\n\tfrh->tos = inet_dscp_to_dsfield(rule4->dscp);\n\n\tif ((rule4->dst_len &&\n\t     nla_put_in_addr(skb, FRA_DST, rule4->dst)) ||\n\t    (rule4->src_len &&\n\t     nla_put_in_addr(skb, FRA_SRC, rule4->src)))\n\t\tgoto nla_put_failure;\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tif (rule4->tclassid &&\n\t    nla_put_u32(skb, FRA_FLOW, rule4->tclassid))\n\t\tgoto nla_put_failure;\n#endif\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic size_t fib4_rule_nlmsg_payload(struct fib_rule *rule)\n{\n\treturn nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4);  \n}\n\nstatic void fib4_rule_flush_cache(struct fib_rules_ops *ops)\n{\n\trt_cache_flush(ops->fro_net);\n}\n\nstatic const struct fib_rules_ops __net_initconst fib4_rules_ops_template = {\n\t.family\t\t= AF_INET,\n\t.rule_size\t= sizeof(struct fib4_rule),\n\t.addr_size\t= sizeof(u32),\n\t.action\t\t= fib4_rule_action,\n\t.suppress\t= fib4_rule_suppress,\n\t.match\t\t= fib4_rule_match,\n\t.configure\t= fib4_rule_configure,\n\t.delete\t\t= fib4_rule_delete,\n\t.compare\t= fib4_rule_compare,\n\t.fill\t\t= fib4_rule_fill,\n\t.nlmsg_payload\t= fib4_rule_nlmsg_payload,\n\t.flush_cache\t= fib4_rule_flush_cache,\n\t.nlgroup\t= RTNLGRP_IPV4_RULE,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int fib_default_rules_init(struct fib_rules_ops *ops)\n{\n\tint err;\n\n\terr = fib_default_rule_add(ops, 0, RT_TABLE_LOCAL, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = fib_default_rule_add(ops, 0x7FFE, RT_TABLE_MAIN, 0);\n\tif (err < 0)\n\t\treturn err;\n\terr = fib_default_rule_add(ops, 0x7FFF, RT_TABLE_DEFAULT, 0);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}\n\nint __net_init fib4_rules_init(struct net *net)\n{\n\tint err;\n\tstruct fib_rules_ops *ops;\n\n\tops = fib_rules_register(&fib4_rules_ops_template, net);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\terr = fib_default_rules_init(ops);\n\tif (err < 0)\n\t\tgoto fail;\n\tnet->ipv4.rules_ops = ops;\n\tnet->ipv4.fib_has_custom_rules = false;\n\tnet->ipv4.fib_rules_require_fldissect = 0;\n\treturn 0;\n\nfail:\n\t \n\tfib_rules_unregister(ops);\n\treturn err;\n}\n\nvoid __net_exit fib4_rules_exit(struct net *net)\n{\n\tfib_rules_unregister(net->ipv4.rules_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}