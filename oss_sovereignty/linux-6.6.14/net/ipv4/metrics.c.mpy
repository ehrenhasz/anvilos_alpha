{
  "module_name": "metrics.c",
  "hash_id": "9f788209d9f0bfd03e806c3ac6f7fa3dad6e11a1d35ffa0b97f71b11a20c00b2",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/metrics.c",
  "human_readable_source": "\n#include <linux/netlink.h>\n#include <linux/nospec.h>\n#include <linux/rtnetlink.h>\n#include <linux/types.h>\n#include <net/ip.h>\n#include <net/net_namespace.h>\n#include <net/tcp.h>\n\nstatic int ip_metrics_convert(struct net *net, struct nlattr *fc_mx,\n\t\t\t      int fc_mx_len, u32 *metrics,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tbool ecn_ca = false;\n\tstruct nlattr *nla;\n\tint remaining;\n\n\tnla_for_each_attr(nla, fc_mx, fc_mx_len, remaining) {\n\t\tint type = nla_type(nla);\n\t\tu32 val;\n\n\t\tif (!type)\n\t\t\tcontinue;\n\t\tif (type > RTAX_MAX) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid metric type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttype = array_index_nospec(type, RTAX_MAX + 1);\n\t\tif (type == RTAX_CC_ALGO) {\n\t\t\tchar tmp[TCP_CA_NAME_MAX];\n\n\t\t\tnla_strscpy(tmp, nla, sizeof(tmp));\n\t\t\tval = tcp_ca_get_key_by_name(net, tmp, &ecn_ca);\n\t\t\tif (val == TCP_CA_UNSPEC) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"Unknown tcp congestion algorithm\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (nla_len(nla) != sizeof(u32)) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Invalid attribute in metrics\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tval = nla_get_u32(nla);\n\t\t}\n\t\tif (type == RTAX_ADVMSS && val > 65535 - 40)\n\t\t\tval = 65535 - 40;\n\t\tif (type == RTAX_MTU && val > 65535 - 15)\n\t\t\tval = 65535 - 15;\n\t\tif (type == RTAX_HOPLIMIT && val > 255)\n\t\t\tval = 255;\n\t\tif (type == RTAX_FEATURES && (val & ~RTAX_FEATURE_MASK)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Unknown flag set in feature mask in metrics attribute\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmetrics[type - 1] = val;\n\t}\n\n\tif (ecn_ca)\n\t\tmetrics[RTAX_FEATURES - 1] |= DST_FEATURE_ECN_CA;\n\n\treturn 0;\n}\n\nstruct dst_metrics *ip_fib_metrics_init(struct net *net, struct nlattr *fc_mx,\n\t\t\t\t\tint fc_mx_len,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct dst_metrics *fib_metrics;\n\tint err;\n\n\tif (!fc_mx)\n\t\treturn (struct dst_metrics *)&dst_default_metrics;\n\n\tfib_metrics = kzalloc(sizeof(*fib_metrics), GFP_KERNEL);\n\tif (unlikely(!fib_metrics))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = ip_metrics_convert(net, fc_mx, fc_mx_len, fib_metrics->metrics,\n\t\t\t\t extack);\n\tif (!err) {\n\t\trefcount_set(&fib_metrics->refcnt, 1);\n\t} else {\n\t\tkfree(fib_metrics);\n\t\tfib_metrics = ERR_PTR(err);\n\t}\n\n\treturn fib_metrics;\n}\nEXPORT_SYMBOL_GPL(ip_fib_metrics_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}