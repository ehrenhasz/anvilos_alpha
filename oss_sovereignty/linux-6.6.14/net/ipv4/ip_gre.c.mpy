{
  "module_name": "ip_gre.c",
  "hash_id": "c5f1ee6d9a2a911b0f36678369d7a7b745cd49671b2da96f9f34ada02a271ce1",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ip_gre.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if_arp.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/in6.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/protocol.h>\n#include <net/ip_tunnels.h>\n#include <net/arp.h>\n#include <net/checksum.h>\n#include <net/dsfield.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/rtnetlink.h>\n#include <net/gre.h>\n#include <net/dst_metadata.h>\n#include <net/erspan.h>\n\n \n\nstatic bool log_ecn_error = true;\nmodule_param(log_ecn_error, bool, 0644);\nMODULE_PARM_DESC(log_ecn_error, \"Log packets received with corrupted ECN\");\n\nstatic struct rtnl_link_ops ipgre_link_ops __read_mostly;\nstatic const struct header_ops ipgre_header_ops;\n\nstatic int ipgre_tunnel_init(struct net_device *dev);\nstatic void erspan_build_header(struct sk_buff *skb,\n\t\t\t\tu32 id, u32 index,\n\t\t\t\tbool truncate, bool is_ipv4);\n\nstatic unsigned int ipgre_net_id __read_mostly;\nstatic unsigned int gre_tap_net_id __read_mostly;\nstatic unsigned int erspan_net_id __read_mostly;\n\nstatic int ipgre_err(struct sk_buff *skb, u32 info,\n\t\t     const struct tnl_ptk_info *tpi)\n{\n\n\t \n\tstruct net *net = dev_net(skb->dev);\n\tstruct ip_tunnel_net *itn;\n\tconst struct iphdr *iph;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tunsigned int data_len = 0;\n\tstruct ip_tunnel *t;\n\n\tif (tpi->proto == htons(ETH_P_TEB))\n\t\titn = net_generic(net, gre_tap_net_id);\n\telse if (tpi->proto == htons(ETH_P_ERSPAN) ||\n\t\t tpi->proto == htons(ETH_P_ERSPAN2))\n\t\titn = net_generic(net, erspan_net_id);\n\telse\n\t\titn = net_generic(net, ipgre_net_id);\n\n\tiph = (const struct iphdr *)(icmp_hdr(skb) + 1);\n\tt = ip_tunnel_lookup(itn, skb->dev->ifindex, tpi->flags,\n\t\t\t     iph->daddr, iph->saddr, tpi->key);\n\n\tif (!t)\n\t\treturn -ENOENT;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_PARAMETERPROB:\n\t\treturn 0;\n\n\tcase ICMP_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMP_SR_FAILED:\n\t\tcase ICMP_PORT_UNREACH:\n\t\t\t \n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_TIME_EXCEEDED:\n\t\tif (code != ICMP_EXC_TTL)\n\t\t\treturn 0;\n\t\tdata_len = icmp_hdr(skb)->un.reserved[1] * 4;  \n\t\tbreak;\n\n\tcase ICMP_REDIRECT:\n\t\tbreak;\n\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (tpi->proto == htons(ETH_P_IPV6) &&\n\t    !ip6_err_gen_icmpv6_unreach(skb, iph->ihl * 4 + tpi->hdr_len,\n\t\t\t\t\ttype, data_len))\n\t\treturn 0;\n#endif\n\n\tif (t->parms.iph.daddr == 0 ||\n\t    ipv4_is_multicast(t->parms.iph.daddr))\n\t\treturn 0;\n\n\tif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\n\t\treturn 0;\n\n\tif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n\n\treturn 0;\n}\n\nstatic void gre_err(struct sk_buff *skb, u32 info)\n{\n\t \n\n\tconst struct iphdr *iph = (struct iphdr *)skb->data;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tstruct tnl_ptk_info tpi;\n\n\tif (gre_parse_header(skb, &tpi, NULL, htons(ETH_P_IP),\n\t\t\t     iph->ihl * 4) < 0)\n\t\treturn;\n\n\tif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED) {\n\t\tipv4_update_pmtu(skb, dev_net(skb->dev), info,\n\t\t\t\t skb->dev->ifindex, IPPROTO_GRE);\n\t\treturn;\n\t}\n\tif (type == ICMP_REDIRECT) {\n\t\tipv4_redirect(skb, dev_net(skb->dev), skb->dev->ifindex,\n\t\t\t      IPPROTO_GRE);\n\t\treturn;\n\t}\n\n\tipgre_err(skb, info, &tpi);\n}\n\nstatic bool is_erspan_type1(int gre_hdr_len)\n{\n\t \n\treturn gre_hdr_len == 4;\n}\n\nstatic int erspan_rcv(struct sk_buff *skb, struct tnl_ptk_info *tpi,\n\t\t      int gre_hdr_len)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct metadata_dst *tun_dst = NULL;\n\tstruct erspan_base_hdr *ershdr;\n\tstruct ip_tunnel_net *itn;\n\tstruct ip_tunnel *tunnel;\n\tconst struct iphdr *iph;\n\tstruct erspan_md2 *md2;\n\tint ver;\n\tint len;\n\n\titn = net_generic(net, erspan_net_id);\n\tiph = ip_hdr(skb);\n\tif (is_erspan_type1(gre_hdr_len)) {\n\t\tver = 0;\n\t\ttunnel = ip_tunnel_lookup(itn, skb->dev->ifindex,\n\t\t\t\t\t  tpi->flags | TUNNEL_NO_KEY,\n\t\t\t\t\t  iph->saddr, iph->daddr, 0);\n\t} else {\n\t\tershdr = (struct erspan_base_hdr *)(skb->data + gre_hdr_len);\n\t\tver = ershdr->ver;\n\t\ttunnel = ip_tunnel_lookup(itn, skb->dev->ifindex,\n\t\t\t\t\t  tpi->flags | TUNNEL_KEY,\n\t\t\t\t\t  iph->saddr, iph->daddr, tpi->key);\n\t}\n\n\tif (tunnel) {\n\t\tif (is_erspan_type1(gre_hdr_len))\n\t\t\tlen = gre_hdr_len;\n\t\telse\n\t\t\tlen = gre_hdr_len + erspan_hdr_len(ver);\n\n\t\tif (unlikely(!pskb_may_pull(skb, len)))\n\t\t\treturn PACKET_REJECT;\n\n\t\tif (__iptunnel_pull_header(skb,\n\t\t\t\t\t   len,\n\t\t\t\t\t   htons(ETH_P_TEB),\n\t\t\t\t\t   false, false) < 0)\n\t\t\tgoto drop;\n\n\t\tif (tunnel->collect_md) {\n\t\t\tstruct erspan_metadata *pkt_md, *md;\n\t\t\tstruct ip_tunnel_info *info;\n\t\t\tunsigned char *gh;\n\t\t\t__be64 tun_id;\n\t\t\t__be16 flags;\n\n\t\t\ttpi->flags |= TUNNEL_KEY;\n\t\t\tflags = tpi->flags;\n\t\t\ttun_id = key32_to_tunnel_id(tpi->key);\n\n\t\t\ttun_dst = ip_tun_rx_dst(skb, flags,\n\t\t\t\t\t\ttun_id, sizeof(*md));\n\t\t\tif (!tun_dst)\n\t\t\t\treturn PACKET_REJECT;\n\n\t\t\t \n\t\t\tgh = skb_network_header(skb) +\n\t\t\t     skb_network_header_len(skb);\n\t\t\tpkt_md = (struct erspan_metadata *)(gh + gre_hdr_len +\n\t\t\t\t\t\t\t    sizeof(*ershdr));\n\t\t\tmd = ip_tunnel_info_opts(&tun_dst->u.tun_info);\n\t\t\tmd->version = ver;\n\t\t\tmd2 = &md->u.md2;\n\t\t\tmemcpy(md2, pkt_md, ver == 1 ? ERSPAN_V1_MDSIZE :\n\t\t\t\t\t\t       ERSPAN_V2_MDSIZE);\n\n\t\t\tinfo = &tun_dst->u.tun_info;\n\t\t\tinfo->key.tun_flags |= TUNNEL_ERSPAN_OPT;\n\t\t\tinfo->options_len = sizeof(*md);\n\t\t}\n\n\t\tskb_reset_mac_header(skb);\n\t\tip_tunnel_rcv(tunnel, skb, tpi, tun_dst, log_ecn_error);\n\t\treturn PACKET_RCVD;\n\t}\n\treturn PACKET_REJECT;\n\ndrop:\n\tkfree_skb(skb);\n\treturn PACKET_RCVD;\n}\n\nstatic int __ipgre_rcv(struct sk_buff *skb, const struct tnl_ptk_info *tpi,\n\t\t       struct ip_tunnel_net *itn, int hdr_len, bool raw_proto)\n{\n\tstruct metadata_dst *tun_dst = NULL;\n\tconst struct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\n\tiph = ip_hdr(skb);\n\ttunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, tpi->flags,\n\t\t\t\t  iph->saddr, iph->daddr, tpi->key);\n\n\tif (tunnel) {\n\t\tconst struct iphdr *tnl_params;\n\n\t\tif (__iptunnel_pull_header(skb, hdr_len, tpi->proto,\n\t\t\t\t\t   raw_proto, false) < 0)\n\t\t\tgoto drop;\n\n\t\t \n\t\tif (tunnel->dev->header_ops == &ipgre_header_ops)\n\t\t\tskb_pop_mac_header(skb);\n\t\telse\n\t\t\tskb_reset_mac_header(skb);\n\n\t\ttnl_params = &tunnel->parms.iph;\n\t\tif (tunnel->collect_md || tnl_params->daddr == 0) {\n\t\t\t__be16 flags;\n\t\t\t__be64 tun_id;\n\n\t\t\tflags = tpi->flags & (TUNNEL_CSUM | TUNNEL_KEY);\n\t\t\ttun_id = key32_to_tunnel_id(tpi->key);\n\t\t\ttun_dst = ip_tun_rx_dst(skb, flags, tun_id, 0);\n\t\t\tif (!tun_dst)\n\t\t\t\treturn PACKET_REJECT;\n\t\t}\n\n\t\tip_tunnel_rcv(tunnel, skb, tpi, tun_dst, log_ecn_error);\n\t\treturn PACKET_RCVD;\n\t}\n\treturn PACKET_NEXT;\n\ndrop:\n\tkfree_skb(skb);\n\treturn PACKET_RCVD;\n}\n\nstatic int ipgre_rcv(struct sk_buff *skb, const struct tnl_ptk_info *tpi,\n\t\t     int hdr_len)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct ip_tunnel_net *itn;\n\tint res;\n\n\tif (tpi->proto == htons(ETH_P_TEB))\n\t\titn = net_generic(net, gre_tap_net_id);\n\telse\n\t\titn = net_generic(net, ipgre_net_id);\n\n\tres = __ipgre_rcv(skb, tpi, itn, hdr_len, false);\n\tif (res == PACKET_NEXT && tpi->proto == htons(ETH_P_TEB)) {\n\t\t \n\t\titn = net_generic(net, ipgre_net_id);\n\t\tres = __ipgre_rcv(skb, tpi, itn, hdr_len, true);\n\t}\n\treturn res;\n}\n\nstatic int gre_rcv(struct sk_buff *skb)\n{\n\tstruct tnl_ptk_info tpi;\n\tbool csum_err = false;\n\tint hdr_len;\n\n#ifdef CONFIG_NET_IPGRE_BROADCAST\n\tif (ipv4_is_multicast(ip_hdr(skb)->daddr)) {\n\t\t \n\t\tif (rt_is_output_route(skb_rtable(skb)))\n\t\t\tgoto drop;\n\t}\n#endif\n\n\thdr_len = gre_parse_header(skb, &tpi, &csum_err, htons(ETH_P_IP), 0);\n\tif (hdr_len < 0)\n\t\tgoto drop;\n\n\tif (unlikely(tpi.proto == htons(ETH_P_ERSPAN) ||\n\t\t     tpi.proto == htons(ETH_P_ERSPAN2))) {\n\t\tif (erspan_rcv(skb, &tpi, hdr_len) == PACKET_RCVD)\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\n\tif (ipgre_rcv(skb, &tpi, hdr_len) == PACKET_RCVD)\n\t\treturn 0;\n\nout:\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic void __gre_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t       const struct iphdr *tnl_params,\n\t\t       __be16 proto)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\t__be16 flags = tunnel->parms.o_flags;\n\n\t \n\tgre_build_header(skb, tunnel->tun_hlen,\n\t\t\t flags, proto, tunnel->parms.o_key,\n\t\t\t (flags & TUNNEL_SEQ) ? htonl(atomic_fetch_inc(&tunnel->o_seqno)) : 0);\n\n\tip_tunnel_xmit(skb, dev, tnl_params, tnl_params->protocol);\n}\n\nstatic int gre_handle_offloads(struct sk_buff *skb, bool csum)\n{\n\treturn iptunnel_handle_offloads(skb, csum ? SKB_GSO_GRE_CSUM : SKB_GSO_GRE);\n}\n\nstatic void gre_fb_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t\t__be16 proto)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct ip_tunnel_info *tun_info;\n\tconst struct ip_tunnel_key *key;\n\tint tunnel_hlen;\n\t__be16 flags;\n\n\ttun_info = skb_tunnel_info(skb);\n\tif (unlikely(!tun_info || !(tun_info->mode & IP_TUNNEL_INFO_TX) ||\n\t\t     ip_tunnel_info_af(tun_info) != AF_INET))\n\t\tgoto err_free_skb;\n\n\tkey = &tun_info->key;\n\ttunnel_hlen = gre_calc_hlen(key->tun_flags);\n\n\tif (skb_cow_head(skb, dev->needed_headroom))\n\t\tgoto err_free_skb;\n\n\t \n\tif (gre_handle_offloads(skb, !!(tun_info->key.tun_flags & TUNNEL_CSUM)))\n\t\tgoto err_free_skb;\n\n\tflags = tun_info->key.tun_flags &\n\t\t(TUNNEL_CSUM | TUNNEL_KEY | TUNNEL_SEQ);\n\tgre_build_header(skb, tunnel_hlen, flags, proto,\n\t\t\t tunnel_id_to_key32(tun_info->key.tun_id),\n\t\t\t (flags & TUNNEL_SEQ) ? htonl(atomic_fetch_inc(&tunnel->o_seqno)) : 0);\n\n\tip_md_tunnel_xmit(skb, dev, IPPROTO_GRE, tunnel_hlen);\n\n\treturn;\n\nerr_free_skb:\n\tkfree_skb(skb);\n\tDEV_STATS_INC(dev, tx_dropped);\n}\n\nstatic void erspan_fb_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct ip_tunnel_info *tun_info;\n\tconst struct ip_tunnel_key *key;\n\tstruct erspan_metadata *md;\n\tbool truncate = false;\n\t__be16 proto;\n\tint tunnel_hlen;\n\tint version;\n\tint nhoff;\n\n\ttun_info = skb_tunnel_info(skb);\n\tif (unlikely(!tun_info || !(tun_info->mode & IP_TUNNEL_INFO_TX) ||\n\t\t     ip_tunnel_info_af(tun_info) != AF_INET))\n\t\tgoto err_free_skb;\n\n\tkey = &tun_info->key;\n\tif (!(tun_info->key.tun_flags & TUNNEL_ERSPAN_OPT))\n\t\tgoto err_free_skb;\n\tif (tun_info->options_len < sizeof(*md))\n\t\tgoto err_free_skb;\n\tmd = ip_tunnel_info_opts(tun_info);\n\n\t \n\tversion = md->version;\n\ttunnel_hlen = 8 + erspan_hdr_len(version);\n\n\tif (skb_cow_head(skb, dev->needed_headroom))\n\t\tgoto err_free_skb;\n\n\tif (gre_handle_offloads(skb, false))\n\t\tgoto err_free_skb;\n\n\tif (skb->len > dev->mtu + dev->hard_header_len) {\n\t\tif (pskb_trim(skb, dev->mtu + dev->hard_header_len))\n\t\t\tgoto err_free_skb;\n\t\ttruncate = true;\n\t}\n\n\tnhoff = skb_network_offset(skb);\n\tif (skb->protocol == htons(ETH_P_IP) &&\n\t    (ntohs(ip_hdr(skb)->tot_len) > skb->len - nhoff))\n\t\ttruncate = true;\n\n\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tint thoff;\n\n\t\tif (skb_transport_header_was_set(skb))\n\t\t\tthoff = skb_transport_offset(skb);\n\t\telse\n\t\t\tthoff = nhoff + sizeof(struct ipv6hdr);\n\t\tif (ntohs(ipv6_hdr(skb)->payload_len) > skb->len - thoff)\n\t\t\ttruncate = true;\n\t}\n\n\tif (version == 1) {\n\t\terspan_build_header(skb, ntohl(tunnel_id_to_key32(key->tun_id)),\n\t\t\t\t    ntohl(md->u.index), truncate, true);\n\t\tproto = htons(ETH_P_ERSPAN);\n\t} else if (version == 2) {\n\t\terspan_build_header_v2(skb,\n\t\t\t\t       ntohl(tunnel_id_to_key32(key->tun_id)),\n\t\t\t\t       md->u.md2.dir,\n\t\t\t\t       get_hwid(&md->u.md2),\n\t\t\t\t       truncate, true);\n\t\tproto = htons(ETH_P_ERSPAN2);\n\t} else {\n\t\tgoto err_free_skb;\n\t}\n\n\tgre_build_header(skb, 8, TUNNEL_SEQ,\n\t\t\t proto, 0, htonl(atomic_fetch_inc(&tunnel->o_seqno)));\n\n\tip_md_tunnel_xmit(skb, dev, IPPROTO_GRE, tunnel_hlen);\n\n\treturn;\n\nerr_free_skb:\n\tkfree_skb(skb);\n\tDEV_STATS_INC(dev, tx_dropped);\n}\n\nstatic int gre_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct ip_tunnel_info *info = skb_tunnel_info(skb);\n\tconst struct ip_tunnel_key *key;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\n\tif (ip_tunnel_info_af(info) != AF_INET)\n\t\treturn -EINVAL;\n\n\tkey = &info->key;\n\tip_tunnel_init_flow(&fl4, IPPROTO_GRE, key->u.ipv4.dst, key->u.ipv4.src,\n\t\t\t    tunnel_id_to_key32(key->tun_id),\n\t\t\t    key->tos & ~INET_ECN_MASK, dev_net(dev), 0,\n\t\t\t    skb->mark, skb_get_hash(skb), key->flow_flags);\n\trt = ip_route_output_key(dev_net(dev), &fl4);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tip_rt_put(rt);\n\tinfo->key.u.ipv4.src = fl4.saddr;\n\treturn 0;\n}\n\nstatic netdev_tx_t ipgre_xmit(struct sk_buff *skb,\n\t\t\t      struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tconst struct iphdr *tnl_params;\n\n\tif (!pskb_inet_may_pull(skb))\n\t\tgoto free_skb;\n\n\tif (tunnel->collect_md) {\n\t\tgre_fb_xmit(skb, dev, skb->protocol);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (dev->header_ops) {\n\t\tint pull_len = tunnel->hlen + sizeof(struct iphdr);\n\n\t\tif (skb_cow_head(skb, 0))\n\t\t\tgoto free_skb;\n\n\t\ttnl_params = (const struct iphdr *)skb->data;\n\n\t\tif (!pskb_network_may_pull(skb, pull_len))\n\t\t\tgoto free_skb;\n\n\t\t \n\t\tskb_pull(skb, pull_len);\n\t\tskb_reset_mac_header(skb);\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t\t    skb_checksum_start(skb) < skb->data)\n\t\t\tgoto free_skb;\n\t} else {\n\t\tif (skb_cow_head(skb, dev->needed_headroom))\n\t\t\tgoto free_skb;\n\n\t\ttnl_params = &tunnel->parms.iph;\n\t}\n\n\tif (gre_handle_offloads(skb, !!(tunnel->parms.o_flags & TUNNEL_CSUM)))\n\t\tgoto free_skb;\n\n\t__gre_xmit(skb, dev, tnl_params, skb->protocol);\n\treturn NETDEV_TX_OK;\n\nfree_skb:\n\tkfree_skb(skb);\n\tDEV_STATS_INC(dev, tx_dropped);\n\treturn NETDEV_TX_OK;\n}\n\nstatic netdev_tx_t erspan_xmit(struct sk_buff *skb,\n\t\t\t       struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tbool truncate = false;\n\t__be16 proto;\n\n\tif (!pskb_inet_may_pull(skb))\n\t\tgoto free_skb;\n\n\tif (tunnel->collect_md) {\n\t\terspan_fb_xmit(skb, dev);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (gre_handle_offloads(skb, false))\n\t\tgoto free_skb;\n\n\tif (skb_cow_head(skb, dev->needed_headroom))\n\t\tgoto free_skb;\n\n\tif (skb->len > dev->mtu + dev->hard_header_len) {\n\t\tif (pskb_trim(skb, dev->mtu + dev->hard_header_len))\n\t\t\tgoto free_skb;\n\t\ttruncate = true;\n\t}\n\n\t \n\tif (tunnel->erspan_ver == 0) {\n\t\tproto = htons(ETH_P_ERSPAN);\n\t\ttunnel->parms.o_flags &= ~TUNNEL_SEQ;\n\t} else if (tunnel->erspan_ver == 1) {\n\t\terspan_build_header(skb, ntohl(tunnel->parms.o_key),\n\t\t\t\t    tunnel->index,\n\t\t\t\t    truncate, true);\n\t\tproto = htons(ETH_P_ERSPAN);\n\t} else if (tunnel->erspan_ver == 2) {\n\t\terspan_build_header_v2(skb, ntohl(tunnel->parms.o_key),\n\t\t\t\t       tunnel->dir, tunnel->hwid,\n\t\t\t\t       truncate, true);\n\t\tproto = htons(ETH_P_ERSPAN2);\n\t} else {\n\t\tgoto free_skb;\n\t}\n\n\ttunnel->parms.o_flags &= ~TUNNEL_KEY;\n\t__gre_xmit(skb, dev, &tunnel->parms.iph, proto);\n\treturn NETDEV_TX_OK;\n\nfree_skb:\n\tkfree_skb(skb);\n\tDEV_STATS_INC(dev, tx_dropped);\n\treturn NETDEV_TX_OK;\n}\n\nstatic netdev_tx_t gre_tap_xmit(struct sk_buff *skb,\n\t\t\t\tstruct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\n\tif (!pskb_inet_may_pull(skb))\n\t\tgoto free_skb;\n\n\tif (tunnel->collect_md) {\n\t\tgre_fb_xmit(skb, dev, htons(ETH_P_TEB));\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (gre_handle_offloads(skb, !!(tunnel->parms.o_flags & TUNNEL_CSUM)))\n\t\tgoto free_skb;\n\n\tif (skb_cow_head(skb, dev->needed_headroom))\n\t\tgoto free_skb;\n\n\t__gre_xmit(skb, dev, &tunnel->parms.iph, htons(ETH_P_TEB));\n\treturn NETDEV_TX_OK;\n\nfree_skb:\n\tkfree_skb(skb);\n\tDEV_STATS_INC(dev, tx_dropped);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ipgre_link_update(struct net_device *dev, bool set_mtu)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\t__be16 flags;\n\tint len;\n\n\tlen = tunnel->tun_hlen;\n\ttunnel->tun_hlen = gre_calc_hlen(tunnel->parms.o_flags);\n\tlen = tunnel->tun_hlen - len;\n\ttunnel->hlen = tunnel->hlen + len;\n\n\tif (dev->header_ops)\n\t\tdev->hard_header_len += len;\n\telse\n\t\tdev->needed_headroom += len;\n\n\tif (set_mtu)\n\t\tdev->mtu = max_t(int, dev->mtu - len, 68);\n\n\tflags = tunnel->parms.o_flags;\n\n\tif (flags & TUNNEL_SEQ ||\n\t    (flags & TUNNEL_CSUM && tunnel->encap.type != TUNNEL_ENCAP_NONE)) {\n\t\tdev->features &= ~NETIF_F_GSO_SOFTWARE;\n\t\tdev->hw_features &= ~NETIF_F_GSO_SOFTWARE;\n\t} else {\n\t\tdev->features |= NETIF_F_GSO_SOFTWARE;\n\t\tdev->hw_features |= NETIF_F_GSO_SOFTWARE;\n\t}\n}\n\nstatic int ipgre_tunnel_ctl(struct net_device *dev, struct ip_tunnel_parm *p,\n\t\t\t    int cmd)\n{\n\tint err;\n\n\tif (cmd == SIOCADDTUNNEL || cmd == SIOCCHGTUNNEL) {\n\t\tif (p->iph.version != 4 || p->iph.protocol != IPPROTO_GRE ||\n\t\t    p->iph.ihl != 5 || (p->iph.frag_off & htons(~IP_DF)) ||\n\t\t    ((p->i_flags | p->o_flags) & (GRE_VERSION | GRE_ROUTING)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tp->i_flags = gre_flags_to_tnl_flags(p->i_flags);\n\tp->o_flags = gre_flags_to_tnl_flags(p->o_flags);\n\n\terr = ip_tunnel_ctl(dev, p, cmd);\n\tif (err)\n\t\treturn err;\n\n\tif (cmd == SIOCCHGTUNNEL) {\n\t\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\t\tt->parms.i_flags = p->i_flags;\n\t\tt->parms.o_flags = p->o_flags;\n\n\t\tif (strcmp(dev->rtnl_link_ops->kind, \"erspan\"))\n\t\t\tipgre_link_update(dev, true);\n\t}\n\n\tp->i_flags = gre_tnl_flags_to_gre_flags(p->i_flags);\n\tp->o_flags = gre_tnl_flags_to_gre_flags(p->o_flags);\n\treturn 0;\n}\n\n \nstatic int ipgre_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\tunsigned short type,\n\t\t\tconst void *daddr, const void *saddr, unsigned int len)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct iphdr *iph;\n\tstruct gre_base_hdr *greh;\n\n\tiph = skb_push(skb, t->hlen + sizeof(*iph));\n\tgreh = (struct gre_base_hdr *)(iph+1);\n\tgreh->flags = gre_tnl_flags_to_gre_flags(t->parms.o_flags);\n\tgreh->protocol = htons(type);\n\n\tmemcpy(iph, &t->parms.iph, sizeof(struct iphdr));\n\n\t \n\tif (saddr)\n\t\tmemcpy(&iph->saddr, saddr, 4);\n\tif (daddr)\n\t\tmemcpy(&iph->daddr, daddr, 4);\n\tif (iph->daddr)\n\t\treturn t->hlen + sizeof(*iph);\n\n\treturn -(t->hlen + sizeof(*iph));\n}\n\nstatic int ipgre_header_parse(const struct sk_buff *skb, unsigned char *haddr)\n{\n\tconst struct iphdr *iph = (const struct iphdr *) skb_mac_header(skb);\n\tmemcpy(haddr, &iph->saddr, 4);\n\treturn 4;\n}\n\nstatic const struct header_ops ipgre_header_ops = {\n\t.create\t= ipgre_header,\n\t.parse\t= ipgre_header_parse,\n};\n\n#ifdef CONFIG_NET_IPGRE_BROADCAST\nstatic int ipgre_open(struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (ipv4_is_multicast(t->parms.iph.daddr)) {\n\t\tstruct flowi4 fl4;\n\t\tstruct rtable *rt;\n\n\t\trt = ip_route_output_gre(t->net, &fl4,\n\t\t\t\t\t t->parms.iph.daddr,\n\t\t\t\t\t t->parms.iph.saddr,\n\t\t\t\t\t t->parms.o_key,\n\t\t\t\t\t RT_TOS(t->parms.iph.tos),\n\t\t\t\t\t t->parms.link);\n\t\tif (IS_ERR(rt))\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tdev = rt->dst.dev;\n\t\tip_rt_put(rt);\n\t\tif (!__in_dev_get_rtnl(dev))\n\t\t\treturn -EADDRNOTAVAIL;\n\t\tt->mlink = dev->ifindex;\n\t\tip_mc_inc_group(__in_dev_get_rtnl(dev), t->parms.iph.daddr);\n\t}\n\treturn 0;\n}\n\nstatic int ipgre_close(struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {\n\t\tstruct in_device *in_dev;\n\t\tin_dev = inetdev_by_index(t->net, t->mlink);\n\t\tif (in_dev)\n\t\t\tip_mc_dec_group(in_dev, t->parms.iph.daddr);\n\t}\n\treturn 0;\n}\n#endif\n\nstatic const struct net_device_ops ipgre_netdev_ops = {\n\t.ndo_init\t\t= ipgre_tunnel_init,\n\t.ndo_uninit\t\t= ip_tunnel_uninit,\n#ifdef CONFIG_NET_IPGRE_BROADCAST\n\t.ndo_open\t\t= ipgre_open,\n\t.ndo_stop\t\t= ipgre_close,\n#endif\n\t.ndo_start_xmit\t\t= ipgre_xmit,\n\t.ndo_siocdevprivate\t= ip_tunnel_siocdevprivate,\n\t.ndo_change_mtu\t\t= ip_tunnel_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_get_iflink\t\t= ip_tunnel_get_iflink,\n\t.ndo_tunnel_ctl\t\t= ipgre_tunnel_ctl,\n};\n\n#define GRE_FEATURES (NETIF_F_SG |\t\t\\\n\t\t      NETIF_F_FRAGLIST |\t\\\n\t\t      NETIF_F_HIGHDMA |\t\t\\\n\t\t      NETIF_F_HW_CSUM)\n\nstatic void ipgre_tunnel_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &ipgre_netdev_ops;\n\tdev->type\t\t= ARPHRD_IPGRE;\n\tip_tunnel_setup(dev, ipgre_net_id);\n}\n\nstatic void __gre_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel;\n\t__be16 flags;\n\n\ttunnel = netdev_priv(dev);\n\ttunnel->tun_hlen = gre_calc_hlen(tunnel->parms.o_flags);\n\ttunnel->parms.iph.protocol = IPPROTO_GRE;\n\n\ttunnel->hlen = tunnel->tun_hlen + tunnel->encap_hlen;\n\tdev->needed_headroom = tunnel->hlen + sizeof(tunnel->parms.iph);\n\n\tdev->features\t\t|= GRE_FEATURES | NETIF_F_LLTX;\n\tdev->hw_features\t|= GRE_FEATURES;\n\n\tflags = tunnel->parms.o_flags;\n\n\t \n\tif (flags & TUNNEL_SEQ)\n\t\treturn;\n\tif (flags & TUNNEL_CSUM && tunnel->encap.type != TUNNEL_ENCAP_NONE)\n\t\treturn;\n\n\tdev->features |= NETIF_F_GSO_SOFTWARE;\n\tdev->hw_features |= NETIF_F_GSO_SOFTWARE;\n}\n\nstatic int ipgre_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct iphdr *iph = &tunnel->parms.iph;\n\n\t__gre_tunnel_init(dev);\n\n\t__dev_addr_set(dev, &iph->saddr, 4);\n\tmemcpy(dev->broadcast, &iph->daddr, 4);\n\n\tdev->flags\t\t= IFF_NOARP;\n\tnetif_keep_dst(dev);\n\tdev->addr_len\t\t= 4;\n\n\tif (iph->daddr && !tunnel->collect_md) {\n#ifdef CONFIG_NET_IPGRE_BROADCAST\n\t\tif (ipv4_is_multicast(iph->daddr)) {\n\t\t\tif (!iph->saddr)\n\t\t\t\treturn -EINVAL;\n\t\t\tdev->flags = IFF_BROADCAST;\n\t\t\tdev->header_ops = &ipgre_header_ops;\n\t\t\tdev->hard_header_len = tunnel->hlen + sizeof(*iph);\n\t\t\tdev->needed_headroom = 0;\n\t\t}\n#endif\n\t} else if (!tunnel->collect_md) {\n\t\tdev->header_ops = &ipgre_header_ops;\n\t\tdev->hard_header_len = tunnel->hlen + sizeof(*iph);\n\t\tdev->needed_headroom = 0;\n\t}\n\n\treturn ip_tunnel_init(dev);\n}\n\nstatic const struct gre_protocol ipgre_protocol = {\n\t.handler     = gre_rcv,\n\t.err_handler = gre_err,\n};\n\nstatic int __net_init ipgre_init_net(struct net *net)\n{\n\treturn ip_tunnel_init_net(net, ipgre_net_id, &ipgre_link_ops, NULL);\n}\n\nstatic void __net_exit ipgre_exit_batch_net(struct list_head *list_net)\n{\n\tip_tunnel_delete_nets(list_net, ipgre_net_id, &ipgre_link_ops);\n}\n\nstatic struct pernet_operations ipgre_net_ops = {\n\t.init = ipgre_init_net,\n\t.exit_batch = ipgre_exit_batch_net,\n\t.id   = &ipgre_net_id,\n\t.size = sizeof(struct ip_tunnel_net),\n};\n\nstatic int ipgre_tunnel_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\t__be16 flags;\n\n\tif (!data)\n\t\treturn 0;\n\n\tflags = 0;\n\tif (data[IFLA_GRE_IFLAGS])\n\t\tflags |= nla_get_be16(data[IFLA_GRE_IFLAGS]);\n\tif (data[IFLA_GRE_OFLAGS])\n\t\tflags |= nla_get_be16(data[IFLA_GRE_OFLAGS]);\n\tif (flags & (GRE_VERSION|GRE_ROUTING))\n\t\treturn -EINVAL;\n\n\tif (data[IFLA_GRE_COLLECT_METADATA] &&\n\t    data[IFLA_GRE_ENCAP_TYPE] &&\n\t    nla_get_u16(data[IFLA_GRE_ENCAP_TYPE]) != TUNNEL_ENCAP_NONE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ipgre_tap_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\t__be32 daddr;\n\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (!data)\n\t\tgoto out;\n\n\tif (data[IFLA_GRE_REMOTE]) {\n\t\tmemcpy(&daddr, nla_data(data[IFLA_GRE_REMOTE]), 4);\n\t\tif (!daddr)\n\t\t\treturn -EINVAL;\n\t}\n\nout:\n\treturn ipgre_tunnel_validate(tb, data, extack);\n}\n\nstatic int erspan_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\t__be16 flags = 0;\n\tint ret;\n\n\tif (!data)\n\t\treturn 0;\n\n\tret = ipgre_tap_validate(tb, data, extack);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data[IFLA_GRE_ERSPAN_VER] &&\n\t    nla_get_u8(data[IFLA_GRE_ERSPAN_VER]) == 0)\n\t\treturn 0;\n\n\t \n\tif (data[IFLA_GRE_OFLAGS])\n\t\tflags |= nla_get_be16(data[IFLA_GRE_OFLAGS]);\n\tif (data[IFLA_GRE_IFLAGS])\n\t\tflags |= nla_get_be16(data[IFLA_GRE_IFLAGS]);\n\tif (!data[IFLA_GRE_COLLECT_METADATA] &&\n\t    flags != (GRE_SEQ | GRE_KEY))\n\t\treturn -EINVAL;\n\n\t \n\tif (data[IFLA_GRE_IKEY] &&\n\t    (ntohl(nla_get_be32(data[IFLA_GRE_IKEY])) & ~ID_MASK))\n\t\treturn -EINVAL;\n\n\tif (data[IFLA_GRE_OKEY] &&\n\t    (ntohl(nla_get_be32(data[IFLA_GRE_OKEY])) & ~ID_MASK))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ipgre_netlink_parms(struct net_device *dev,\n\t\t\t\tstruct nlattr *data[],\n\t\t\t\tstruct nlattr *tb[],\n\t\t\t\tstruct ip_tunnel_parm *parms,\n\t\t\t\t__u32 *fwmark)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tmemset(parms, 0, sizeof(*parms));\n\n\tparms->iph.protocol = IPPROTO_GRE;\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (data[IFLA_GRE_LINK])\n\t\tparms->link = nla_get_u32(data[IFLA_GRE_LINK]);\n\n\tif (data[IFLA_GRE_IFLAGS])\n\t\tparms->i_flags = gre_flags_to_tnl_flags(nla_get_be16(data[IFLA_GRE_IFLAGS]));\n\n\tif (data[IFLA_GRE_OFLAGS])\n\t\tparms->o_flags = gre_flags_to_tnl_flags(nla_get_be16(data[IFLA_GRE_OFLAGS]));\n\n\tif (data[IFLA_GRE_IKEY])\n\t\tparms->i_key = nla_get_be32(data[IFLA_GRE_IKEY]);\n\n\tif (data[IFLA_GRE_OKEY])\n\t\tparms->o_key = nla_get_be32(data[IFLA_GRE_OKEY]);\n\n\tif (data[IFLA_GRE_LOCAL])\n\t\tparms->iph.saddr = nla_get_in_addr(data[IFLA_GRE_LOCAL]);\n\n\tif (data[IFLA_GRE_REMOTE])\n\t\tparms->iph.daddr = nla_get_in_addr(data[IFLA_GRE_REMOTE]);\n\n\tif (data[IFLA_GRE_TTL])\n\t\tparms->iph.ttl = nla_get_u8(data[IFLA_GRE_TTL]);\n\n\tif (data[IFLA_GRE_TOS])\n\t\tparms->iph.tos = nla_get_u8(data[IFLA_GRE_TOS]);\n\n\tif (!data[IFLA_GRE_PMTUDISC] || nla_get_u8(data[IFLA_GRE_PMTUDISC])) {\n\t\tif (t->ignore_df)\n\t\t\treturn -EINVAL;\n\t\tparms->iph.frag_off = htons(IP_DF);\n\t}\n\n\tif (data[IFLA_GRE_COLLECT_METADATA]) {\n\t\tt->collect_md = true;\n\t\tif (dev->type == ARPHRD_IPGRE)\n\t\t\tdev->type = ARPHRD_NONE;\n\t}\n\n\tif (data[IFLA_GRE_IGNORE_DF]) {\n\t\tif (nla_get_u8(data[IFLA_GRE_IGNORE_DF])\n\t\t  && (parms->iph.frag_off & htons(IP_DF)))\n\t\t\treturn -EINVAL;\n\t\tt->ignore_df = !!nla_get_u8(data[IFLA_GRE_IGNORE_DF]);\n\t}\n\n\tif (data[IFLA_GRE_FWMARK])\n\t\t*fwmark = nla_get_u32(data[IFLA_GRE_FWMARK]);\n\n\treturn 0;\n}\n\nstatic int erspan_netlink_parms(struct net_device *dev,\n\t\t\t\tstruct nlattr *data[],\n\t\t\t\tstruct nlattr *tb[],\n\t\t\t\tstruct ip_tunnel_parm *parms,\n\t\t\t\t__u32 *fwmark)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tint err;\n\n\terr = ipgre_netlink_parms(dev, data, tb, parms, fwmark);\n\tif (err)\n\t\treturn err;\n\tif (!data)\n\t\treturn 0;\n\n\tif (data[IFLA_GRE_ERSPAN_VER]) {\n\t\tt->erspan_ver = nla_get_u8(data[IFLA_GRE_ERSPAN_VER]);\n\n\t\tif (t->erspan_ver > 2)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (t->erspan_ver == 1) {\n\t\tif (data[IFLA_GRE_ERSPAN_INDEX]) {\n\t\t\tt->index = nla_get_u32(data[IFLA_GRE_ERSPAN_INDEX]);\n\t\t\tif (t->index & ~INDEX_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (t->erspan_ver == 2) {\n\t\tif (data[IFLA_GRE_ERSPAN_DIR]) {\n\t\t\tt->dir = nla_get_u8(data[IFLA_GRE_ERSPAN_DIR]);\n\t\t\tif (t->dir & ~(DIR_MASK >> DIR_OFFSET))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (data[IFLA_GRE_ERSPAN_HWID]) {\n\t\t\tt->hwid = nla_get_u16(data[IFLA_GRE_ERSPAN_HWID]);\n\t\t\tif (t->hwid & ~(HWID_MASK >> HWID_OFFSET))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool ipgre_netlink_encap_parms(struct nlattr *data[],\n\t\t\t\t      struct ip_tunnel_encap *ipencap)\n{\n\tbool ret = false;\n\n\tmemset(ipencap, 0, sizeof(*ipencap));\n\n\tif (!data)\n\t\treturn ret;\n\n\tif (data[IFLA_GRE_ENCAP_TYPE]) {\n\t\tret = true;\n\t\tipencap->type = nla_get_u16(data[IFLA_GRE_ENCAP_TYPE]);\n\t}\n\n\tif (data[IFLA_GRE_ENCAP_FLAGS]) {\n\t\tret = true;\n\t\tipencap->flags = nla_get_u16(data[IFLA_GRE_ENCAP_FLAGS]);\n\t}\n\n\tif (data[IFLA_GRE_ENCAP_SPORT]) {\n\t\tret = true;\n\t\tipencap->sport = nla_get_be16(data[IFLA_GRE_ENCAP_SPORT]);\n\t}\n\n\tif (data[IFLA_GRE_ENCAP_DPORT]) {\n\t\tret = true;\n\t\tipencap->dport = nla_get_be16(data[IFLA_GRE_ENCAP_DPORT]);\n\t}\n\n\treturn ret;\n}\n\nstatic int gre_tap_init(struct net_device *dev)\n{\n\t__gre_tunnel_init(dev);\n\tdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\tnetif_keep_dst(dev);\n\n\treturn ip_tunnel_init(dev);\n}\n\nstatic const struct net_device_ops gre_tap_netdev_ops = {\n\t.ndo_init\t\t= gre_tap_init,\n\t.ndo_uninit\t\t= ip_tunnel_uninit,\n\t.ndo_start_xmit\t\t= gre_tap_xmit,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_change_mtu\t\t= ip_tunnel_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_get_iflink\t\t= ip_tunnel_get_iflink,\n\t.ndo_fill_metadata_dst\t= gre_fill_metadata_dst,\n};\n\nstatic int erspan_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\n\tif (tunnel->erspan_ver == 0)\n\t\ttunnel->tun_hlen = 4;  \n\telse\n\t\ttunnel->tun_hlen = 8;  \n\n\ttunnel->parms.iph.protocol = IPPROTO_GRE;\n\ttunnel->hlen = tunnel->tun_hlen + tunnel->encap_hlen +\n\t\t       erspan_hdr_len(tunnel->erspan_ver);\n\n\tdev->features\t\t|= GRE_FEATURES;\n\tdev->hw_features\t|= GRE_FEATURES;\n\tdev->priv_flags\t\t|= IFF_LIVE_ADDR_CHANGE;\n\tnetif_keep_dst(dev);\n\n\treturn ip_tunnel_init(dev);\n}\n\nstatic const struct net_device_ops erspan_netdev_ops = {\n\t.ndo_init\t\t= erspan_tunnel_init,\n\t.ndo_uninit\t\t= ip_tunnel_uninit,\n\t.ndo_start_xmit\t\t= erspan_xmit,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_change_mtu\t\t= ip_tunnel_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_get_iflink\t\t= ip_tunnel_get_iflink,\n\t.ndo_fill_metadata_dst\t= gre_fill_metadata_dst,\n};\n\nstatic void ipgre_tap_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->max_mtu = 0;\n\tdev->netdev_ops\t= &gre_tap_netdev_ops;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->priv_flags\t|= IFF_LIVE_ADDR_CHANGE;\n\tip_tunnel_setup(dev, gre_tap_net_id);\n}\n\nstatic int\nipgre_newlink_encap_setup(struct net_device *dev, struct nlattr *data[])\n{\n\tstruct ip_tunnel_encap ipencap;\n\n\tif (ipgre_netlink_encap_parms(data, &ipencap)) {\n\t\tstruct ip_tunnel *t = netdev_priv(dev);\n\t\tint err = ip_tunnel_encap_setup(t, &ipencap);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipgre_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct ip_tunnel_parm p;\n\t__u32 fwmark = 0;\n\tint err;\n\n\terr = ipgre_newlink_encap_setup(dev, data);\n\tif (err)\n\t\treturn err;\n\n\terr = ipgre_netlink_parms(dev, data, tb, &p, &fwmark);\n\tif (err < 0)\n\t\treturn err;\n\treturn ip_tunnel_newlink(dev, tb, &p, fwmark);\n}\n\nstatic int erspan_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t  struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ip_tunnel_parm p;\n\t__u32 fwmark = 0;\n\tint err;\n\n\terr = ipgre_newlink_encap_setup(dev, data);\n\tif (err)\n\t\treturn err;\n\n\terr = erspan_netlink_parms(dev, data, tb, &p, &fwmark);\n\tif (err)\n\t\treturn err;\n\treturn ip_tunnel_newlink(dev, tb, &p, fwmark);\n}\n\nstatic int ipgre_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t    struct nlattr *data[],\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\t__u32 fwmark = t->fwmark;\n\tstruct ip_tunnel_parm p;\n\tint err;\n\n\terr = ipgre_newlink_encap_setup(dev, data);\n\tif (err)\n\t\treturn err;\n\n\terr = ipgre_netlink_parms(dev, data, tb, &p, &fwmark);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ip_tunnel_changelink(dev, tb, &p, fwmark);\n\tif (err < 0)\n\t\treturn err;\n\n\tt->parms.i_flags = p.i_flags;\n\tt->parms.o_flags = p.o_flags;\n\n\tipgre_link_update(dev, !tb[IFLA_MTU]);\n\n\treturn 0;\n}\n\nstatic int erspan_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t     struct nlattr *data[],\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\t__u32 fwmark = t->fwmark;\n\tstruct ip_tunnel_parm p;\n\tint err;\n\n\terr = ipgre_newlink_encap_setup(dev, data);\n\tif (err)\n\t\treturn err;\n\n\terr = erspan_netlink_parms(dev, data, tb, &p, &fwmark);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ip_tunnel_changelink(dev, tb, &p, fwmark);\n\tif (err < 0)\n\t\treturn err;\n\n\tt->parms.i_flags = p.i_flags;\n\tt->parms.o_flags = p.o_flags;\n\n\treturn 0;\n}\n\nstatic size_t ipgre_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(0) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t0;\n}\n\nstatic int ipgre_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_parm *p = &t->parms;\n\t__be16 o_flags = p->o_flags;\n\n\tif (nla_put_u32(skb, IFLA_GRE_LINK, p->link) ||\n\t    nla_put_be16(skb, IFLA_GRE_IFLAGS,\n\t\t\t gre_tnl_flags_to_gre_flags(p->i_flags)) ||\n\t    nla_put_be16(skb, IFLA_GRE_OFLAGS,\n\t\t\t gre_tnl_flags_to_gre_flags(o_flags)) ||\n\t    nla_put_be32(skb, IFLA_GRE_IKEY, p->i_key) ||\n\t    nla_put_be32(skb, IFLA_GRE_OKEY, p->o_key) ||\n\t    nla_put_in_addr(skb, IFLA_GRE_LOCAL, p->iph.saddr) ||\n\t    nla_put_in_addr(skb, IFLA_GRE_REMOTE, p->iph.daddr) ||\n\t    nla_put_u8(skb, IFLA_GRE_TTL, p->iph.ttl) ||\n\t    nla_put_u8(skb, IFLA_GRE_TOS, p->iph.tos) ||\n\t    nla_put_u8(skb, IFLA_GRE_PMTUDISC,\n\t\t       !!(p->iph.frag_off & htons(IP_DF))) ||\n\t    nla_put_u32(skb, IFLA_GRE_FWMARK, t->fwmark))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(skb, IFLA_GRE_ENCAP_TYPE,\n\t\t\tt->encap.type) ||\n\t    nla_put_be16(skb, IFLA_GRE_ENCAP_SPORT,\n\t\t\t t->encap.sport) ||\n\t    nla_put_be16(skb, IFLA_GRE_ENCAP_DPORT,\n\t\t\t t->encap.dport) ||\n\t    nla_put_u16(skb, IFLA_GRE_ENCAP_FLAGS,\n\t\t\tt->encap.flags))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_GRE_IGNORE_DF, t->ignore_df))\n\t\tgoto nla_put_failure;\n\n\tif (t->collect_md) {\n\t\tif (nla_put_flag(skb, IFLA_GRE_COLLECT_METADATA))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int erspan_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (t->erspan_ver <= 2) {\n\t\tif (t->erspan_ver != 0 && !t->collect_md)\n\t\t\tt->parms.o_flags |= TUNNEL_KEY;\n\n\t\tif (nla_put_u8(skb, IFLA_GRE_ERSPAN_VER, t->erspan_ver))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (t->erspan_ver == 1) {\n\t\t\tif (nla_put_u32(skb, IFLA_GRE_ERSPAN_INDEX, t->index))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else if (t->erspan_ver == 2) {\n\t\t\tif (nla_put_u8(skb, IFLA_GRE_ERSPAN_DIR, t->dir))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u16(skb, IFLA_GRE_ERSPAN_HWID, t->hwid))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\treturn ipgre_fill_info(skb, dev);\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic void erspan_setup(struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tether_setup(dev);\n\tdev->max_mtu = 0;\n\tdev->netdev_ops = &erspan_netdev_ops;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\tip_tunnel_setup(dev, erspan_net_id);\n\tt->erspan_ver = 1;\n}\n\nstatic const struct nla_policy ipgre_policy[IFLA_GRE_MAX + 1] = {\n\t[IFLA_GRE_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_GRE_IFLAGS]\t= { .type = NLA_U16 },\n\t[IFLA_GRE_OFLAGS]\t= { .type = NLA_U16 },\n\t[IFLA_GRE_IKEY]\t\t= { .type = NLA_U32 },\n\t[IFLA_GRE_OKEY]\t\t= { .type = NLA_U32 },\n\t[IFLA_GRE_LOCAL]\t= { .len = sizeof_field(struct iphdr, saddr) },\n\t[IFLA_GRE_REMOTE]\t= { .len = sizeof_field(struct iphdr, daddr) },\n\t[IFLA_GRE_TTL]\t\t= { .type = NLA_U8 },\n\t[IFLA_GRE_TOS]\t\t= { .type = NLA_U8 },\n\t[IFLA_GRE_PMTUDISC]\t= { .type = NLA_U8 },\n\t[IFLA_GRE_ENCAP_TYPE]\t= { .type = NLA_U16 },\n\t[IFLA_GRE_ENCAP_FLAGS]\t= { .type = NLA_U16 },\n\t[IFLA_GRE_ENCAP_SPORT]\t= { .type = NLA_U16 },\n\t[IFLA_GRE_ENCAP_DPORT]\t= { .type = NLA_U16 },\n\t[IFLA_GRE_COLLECT_METADATA]\t= { .type = NLA_FLAG },\n\t[IFLA_GRE_IGNORE_DF]\t= { .type = NLA_U8 },\n\t[IFLA_GRE_FWMARK]\t= { .type = NLA_U32 },\n\t[IFLA_GRE_ERSPAN_INDEX]\t= { .type = NLA_U32 },\n\t[IFLA_GRE_ERSPAN_VER]\t= { .type = NLA_U8 },\n\t[IFLA_GRE_ERSPAN_DIR]\t= { .type = NLA_U8 },\n\t[IFLA_GRE_ERSPAN_HWID]\t= { .type = NLA_U16 },\n};\n\nstatic struct rtnl_link_ops ipgre_link_ops __read_mostly = {\n\t.kind\t\t= \"gre\",\n\t.maxtype\t= IFLA_GRE_MAX,\n\t.policy\t\t= ipgre_policy,\n\t.priv_size\t= sizeof(struct ip_tunnel),\n\t.setup\t\t= ipgre_tunnel_setup,\n\t.validate\t= ipgre_tunnel_validate,\n\t.newlink\t= ipgre_newlink,\n\t.changelink\t= ipgre_changelink,\n\t.dellink\t= ip_tunnel_dellink,\n\t.get_size\t= ipgre_get_size,\n\t.fill_info\t= ipgre_fill_info,\n\t.get_link_net\t= ip_tunnel_get_link_net,\n};\n\nstatic struct rtnl_link_ops ipgre_tap_ops __read_mostly = {\n\t.kind\t\t= \"gretap\",\n\t.maxtype\t= IFLA_GRE_MAX,\n\t.policy\t\t= ipgre_policy,\n\t.priv_size\t= sizeof(struct ip_tunnel),\n\t.setup\t\t= ipgre_tap_setup,\n\t.validate\t= ipgre_tap_validate,\n\t.newlink\t= ipgre_newlink,\n\t.changelink\t= ipgre_changelink,\n\t.dellink\t= ip_tunnel_dellink,\n\t.get_size\t= ipgre_get_size,\n\t.fill_info\t= ipgre_fill_info,\n\t.get_link_net\t= ip_tunnel_get_link_net,\n};\n\nstatic struct rtnl_link_ops erspan_link_ops __read_mostly = {\n\t.kind\t\t= \"erspan\",\n\t.maxtype\t= IFLA_GRE_MAX,\n\t.policy\t\t= ipgre_policy,\n\t.priv_size\t= sizeof(struct ip_tunnel),\n\t.setup\t\t= erspan_setup,\n\t.validate\t= erspan_validate,\n\t.newlink\t= erspan_newlink,\n\t.changelink\t= erspan_changelink,\n\t.dellink\t= ip_tunnel_dellink,\n\t.get_size\t= ipgre_get_size,\n\t.fill_info\t= erspan_fill_info,\n\t.get_link_net\t= ip_tunnel_get_link_net,\n};\n\nstruct net_device *gretap_fb_dev_create(struct net *net, const char *name,\n\t\t\t\t\tu8 name_assign_type)\n{\n\tstruct nlattr *tb[IFLA_MAX + 1];\n\tstruct net_device *dev;\n\tLIST_HEAD(list_kill);\n\tstruct ip_tunnel *t;\n\tint err;\n\n\tmemset(&tb, 0, sizeof(tb));\n\n\tdev = rtnl_create_link(net, name, name_assign_type,\n\t\t\t       &ipgre_tap_ops, tb, NULL);\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\t \n\tt = netdev_priv(dev);\n\tt->collect_md = true;\n\n\terr = ipgre_newlink(net, dev, tb, NULL, NULL);\n\tif (err < 0) {\n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t \n\terr = __ip_tunnel_change_mtu(dev, IP_MAX_MTU, false);\n\tif (err)\n\t\tgoto out;\n\n\terr = rtnl_configure_link(dev, NULL, 0, NULL);\n\tif (err < 0)\n\t\tgoto out;\n\n\treturn dev;\nout:\n\tip_tunnel_dellink(dev, &list_kill);\n\tunregister_netdevice_many(&list_kill);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(gretap_fb_dev_create);\n\nstatic int __net_init ipgre_tap_init_net(struct net *net)\n{\n\treturn ip_tunnel_init_net(net, gre_tap_net_id, &ipgre_tap_ops, \"gretap0\");\n}\n\nstatic void __net_exit ipgre_tap_exit_batch_net(struct list_head *list_net)\n{\n\tip_tunnel_delete_nets(list_net, gre_tap_net_id, &ipgre_tap_ops);\n}\n\nstatic struct pernet_operations ipgre_tap_net_ops = {\n\t.init = ipgre_tap_init_net,\n\t.exit_batch = ipgre_tap_exit_batch_net,\n\t.id   = &gre_tap_net_id,\n\t.size = sizeof(struct ip_tunnel_net),\n};\n\nstatic int __net_init erspan_init_net(struct net *net)\n{\n\treturn ip_tunnel_init_net(net, erspan_net_id,\n\t\t\t\t  &erspan_link_ops, \"erspan0\");\n}\n\nstatic void __net_exit erspan_exit_batch_net(struct list_head *net_list)\n{\n\tip_tunnel_delete_nets(net_list, erspan_net_id, &erspan_link_ops);\n}\n\nstatic struct pernet_operations erspan_net_ops = {\n\t.init = erspan_init_net,\n\t.exit_batch = erspan_exit_batch_net,\n\t.id   = &erspan_net_id,\n\t.size = sizeof(struct ip_tunnel_net),\n};\n\nstatic int __init ipgre_init(void)\n{\n\tint err;\n\n\tpr_info(\"GRE over IPv4 tunneling driver\\n\");\n\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = register_pernet_device(&ipgre_tap_net_ops);\n\tif (err < 0)\n\t\tgoto pnet_tap_failed;\n\n\terr = register_pernet_device(&erspan_net_ops);\n\tif (err < 0)\n\t\tgoto pnet_erspan_failed;\n\n\terr = gre_add_protocol(&ipgre_protocol, GREPROTO_CISCO);\n\tif (err < 0) {\n\t\tpr_info(\"%s: can't add protocol\\n\", __func__);\n\t\tgoto add_proto_failed;\n\t}\n\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\n\n\terr = rtnl_link_register(&erspan_link_ops);\n\tif (err < 0)\n\t\tgoto erspan_link_failed;\n\n\treturn 0;\n\nerspan_link_failed:\n\trtnl_link_unregister(&ipgre_tap_ops);\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tgre_del_protocol(&ipgre_protocol, GREPROTO_CISCO);\nadd_proto_failed:\n\tunregister_pernet_device(&erspan_net_ops);\npnet_erspan_failed:\n\tunregister_pernet_device(&ipgre_tap_net_ops);\npnet_tap_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\n\treturn err;\n}\n\nstatic void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\trtnl_link_unregister(&erspan_link_ops);\n\tgre_del_protocol(&ipgre_protocol, GREPROTO_CISCO);\n\tunregister_pernet_device(&ipgre_tap_net_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tunregister_pernet_device(&erspan_net_ops);\n}\n\nmodule_init(ipgre_init);\nmodule_exit(ipgre_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(\"gre\");\nMODULE_ALIAS_RTNL_LINK(\"gretap\");\nMODULE_ALIAS_RTNL_LINK(\"erspan\");\nMODULE_ALIAS_NETDEV(\"gre0\");\nMODULE_ALIAS_NETDEV(\"gretap0\");\nMODULE_ALIAS_NETDEV(\"erspan0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}