{
  "module_name": "ipip.c",
  "hash_id": "7f2b97cf5465d3453dbf9d44e84a01f0b646d9715e8f4ec10d5dff48a7c2052b",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ipip.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/if_ether.h>\n\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/ip_tunnels.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/dst_metadata.h>\n\nstatic bool log_ecn_error = true;\nmodule_param(log_ecn_error, bool, 0644);\nMODULE_PARM_DESC(log_ecn_error, \"Log packets received with corrupted ECN\");\n\nstatic unsigned int ipip_net_id __read_mostly;\n\nstatic int ipip_tunnel_init(struct net_device *dev);\nstatic struct rtnl_link_ops ipip_link_ops __read_mostly;\n\nstatic int ipip_err(struct sk_buff *skb, u32 info)\n{\n\t \n\tstruct net *net = dev_net(skb->dev);\n\tstruct ip_tunnel_net *itn = net_generic(net, ipip_net_id);\n\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tstruct ip_tunnel *t;\n\tint err = 0;\n\n\tt = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,\n\t\t\t     iph->daddr, iph->saddr, 0);\n\tif (!t) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase ICMP_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMP_SR_FAILED:\n\t\t\t \n\t\t\tgoto out;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ICMP_TIME_EXCEEDED:\n\t\tif (code != ICMP_EXC_TTL)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase ICMP_REDIRECT:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED) {\n\t\tipv4_update_pmtu(skb, net, info, t->parms.link, iph->protocol);\n\t\tgoto out;\n\t}\n\n\tif (type == ICMP_REDIRECT) {\n\t\tipv4_redirect(skb, net, t->parms.link, iph->protocol);\n\t\tgoto out;\n\t}\n\n\tif (t->parms.iph.daddr == 0) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\n\t\tgoto out;\n\n\tif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n\nout:\n\treturn err;\n}\n\nstatic const struct tnl_ptk_info ipip_tpi = {\n\t \n\t.proto = htons(ETH_P_IP),\n};\n\n#if IS_ENABLED(CONFIG_MPLS)\nstatic const struct tnl_ptk_info mplsip_tpi = {\n\t \n\t.proto = htons(ETH_P_MPLS_UC),\n};\n#endif\n\nstatic int ipip_tunnel_rcv(struct sk_buff *skb, u8 ipproto)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct ip_tunnel_net *itn = net_generic(net, ipip_net_id);\n\tstruct metadata_dst *tun_dst = NULL;\n\tstruct ip_tunnel *tunnel;\n\tconst struct iphdr *iph;\n\n\tiph = ip_hdr(skb);\n\ttunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,\n\t\t\tiph->saddr, iph->daddr, 0);\n\tif (tunnel) {\n\t\tconst struct tnl_ptk_info *tpi;\n\n\t\tif (tunnel->parms.iph.protocol != ipproto &&\n\t\t    tunnel->parms.iph.protocol != 0)\n\t\t\tgoto drop;\n\n\t\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\t\tgoto drop;\n#if IS_ENABLED(CONFIG_MPLS)\n\t\tif (ipproto == IPPROTO_MPLS)\n\t\t\ttpi = &mplsip_tpi;\n\t\telse\n#endif\n\t\t\ttpi = &ipip_tpi;\n\t\tif (iptunnel_pull_header(skb, 0, tpi->proto, false))\n\t\t\tgoto drop;\n\t\tif (tunnel->collect_md) {\n\t\t\ttun_dst = ip_tun_rx_dst(skb, 0, 0, 0);\n\t\t\tif (!tun_dst)\n\t\t\t\treturn 0;\n\t\t\tip_tunnel_md_udp_encap(skb, &tun_dst->u.tun_info);\n\t\t}\n\t\tskb_reset_mac_header(skb);\n\n\t\treturn ip_tunnel_rcv(tunnel, skb, tpi, tun_dst, log_ecn_error);\n\t}\n\n\treturn -1;\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int ipip_rcv(struct sk_buff *skb)\n{\n\treturn ipip_tunnel_rcv(skb, IPPROTO_IPIP);\n}\n\n#if IS_ENABLED(CONFIG_MPLS)\nstatic int mplsip_rcv(struct sk_buff *skb)\n{\n\treturn ipip_tunnel_rcv(skb, IPPROTO_MPLS);\n}\n#endif\n\n \nstatic netdev_tx_t ipip_tunnel_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tconst struct iphdr  *tiph = &tunnel->parms.iph;\n\tu8 ipproto;\n\n\tif (!pskb_inet_may_pull(skb))\n\t\tgoto tx_error;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tipproto = IPPROTO_IPIP;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_MPLS)\n\tcase htons(ETH_P_MPLS_UC):\n\t\tipproto = IPPROTO_MPLS;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tgoto tx_error;\n\t}\n\n\tif (tiph->protocol != ipproto && tiph->protocol != 0)\n\t\tgoto tx_error;\n\n\tif (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP4))\n\t\tgoto tx_error;\n\n\tskb_set_inner_ipproto(skb, ipproto);\n\n\tif (tunnel->collect_md)\n\t\tip_md_tunnel_xmit(skb, dev, ipproto, 0);\n\telse\n\t\tip_tunnel_xmit(skb, dev, tiph, ipproto);\n\treturn NETDEV_TX_OK;\n\ntx_error:\n\tkfree_skb(skb);\n\n\tDEV_STATS_INC(dev, tx_errors);\n\treturn NETDEV_TX_OK;\n}\n\nstatic bool ipip_tunnel_ioctl_verify_protocol(u8 ipproto)\n{\n\tswitch (ipproto) {\n\tcase 0:\n\tcase IPPROTO_IPIP:\n#if IS_ENABLED(CONFIG_MPLS)\n\tcase IPPROTO_MPLS:\n#endif\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int\nipip_tunnel_ctl(struct net_device *dev, struct ip_tunnel_parm *p, int cmd)\n{\n\tif (cmd == SIOCADDTUNNEL || cmd == SIOCCHGTUNNEL) {\n\t\tif (p->iph.version != 4 ||\n\t\t    !ipip_tunnel_ioctl_verify_protocol(p->iph.protocol) ||\n\t\t    p->iph.ihl != 5 || (p->iph.frag_off & htons(~IP_DF)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tp->i_key = p->o_key = 0;\n\tp->i_flags = p->o_flags = 0;\n\treturn ip_tunnel_ctl(dev, p, cmd);\n}\n\nstatic const struct net_device_ops ipip_netdev_ops = {\n\t.ndo_init       = ipip_tunnel_init,\n\t.ndo_uninit     = ip_tunnel_uninit,\n\t.ndo_start_xmit\t= ipip_tunnel_xmit,\n\t.ndo_siocdevprivate = ip_tunnel_siocdevprivate,\n\t.ndo_change_mtu = ip_tunnel_change_mtu,\n\t.ndo_get_stats64 = dev_get_tstats64,\n\t.ndo_get_iflink = ip_tunnel_get_iflink,\n\t.ndo_tunnel_ctl\t= ipip_tunnel_ctl,\n};\n\n#define IPIP_FEATURES (NETIF_F_SG |\t\t\\\n\t\t       NETIF_F_FRAGLIST |\t\\\n\t\t       NETIF_F_HIGHDMA |\t\\\n\t\t       NETIF_F_GSO_SOFTWARE |\t\\\n\t\t       NETIF_F_HW_CSUM)\n\nstatic void ipip_tunnel_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &ipip_netdev_ops;\n\tdev->header_ops\t\t= &ip_tunnel_header_ops;\n\n\tdev->type\t\t= ARPHRD_TUNNEL;\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->addr_len\t\t= 4;\n\tdev->features\t\t|= NETIF_F_LLTX;\n\tnetif_keep_dst(dev);\n\n\tdev->features\t\t|= IPIP_FEATURES;\n\tdev->hw_features\t|= IPIP_FEATURES;\n\tip_tunnel_setup(dev, ipip_net_id);\n}\n\nstatic int ipip_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\n\t__dev_addr_set(dev, &tunnel->parms.iph.saddr, 4);\n\tmemcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);\n\n\ttunnel->tun_hlen = 0;\n\ttunnel->hlen = tunnel->tun_hlen + tunnel->encap_hlen;\n\treturn ip_tunnel_init(dev);\n}\n\nstatic int ipip_tunnel_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tu8 proto;\n\n\tif (!data || !data[IFLA_IPTUN_PROTO])\n\t\treturn 0;\n\n\tproto = nla_get_u8(data[IFLA_IPTUN_PROTO]);\n\tif (proto != IPPROTO_IPIP && proto != IPPROTO_MPLS && proto != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void ipip_netlink_parms(struct nlattr *data[],\n\t\t\t       struct ip_tunnel_parm *parms, bool *collect_md,\n\t\t\t       __u32 *fwmark)\n{\n\tmemset(parms, 0, sizeof(*parms));\n\n\tparms->iph.version = 4;\n\tparms->iph.protocol = IPPROTO_IPIP;\n\tparms->iph.ihl = 5;\n\t*collect_md = false;\n\n\tif (!data)\n\t\treturn;\n\n\tip_tunnel_netlink_parms(data, parms);\n\n\tif (data[IFLA_IPTUN_COLLECT_METADATA])\n\t\t*collect_md = true;\n\n\tif (data[IFLA_IPTUN_FWMARK])\n\t\t*fwmark = nla_get_u32(data[IFLA_IPTUN_FWMARK]);\n}\n\nstatic int ipip_newlink(struct net *src_net, struct net_device *dev,\n\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_parm p;\n\tstruct ip_tunnel_encap ipencap;\n\t__u32 fwmark = 0;\n\n\tif (ip_tunnel_netlink_encap_parms(data, &ipencap)) {\n\t\tint err = ip_tunnel_encap_setup(t, &ipencap);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tipip_netlink_parms(data, &p, &t->collect_md, &fwmark);\n\treturn ip_tunnel_newlink(dev, tb, &p, fwmark);\n}\n\nstatic int ipip_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t   struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_parm p;\n\tstruct ip_tunnel_encap ipencap;\n\tbool collect_md;\n\t__u32 fwmark = t->fwmark;\n\n\tif (ip_tunnel_netlink_encap_parms(data, &ipencap)) {\n\t\tint err = ip_tunnel_encap_setup(t, &ipencap);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tipip_netlink_parms(data, &p, &collect_md, &fwmark);\n\tif (collect_md)\n\t\treturn -EINVAL;\n\n\tif (((dev->flags & IFF_POINTOPOINT) && !p.iph.daddr) ||\n\t    (!(dev->flags & IFF_POINTOPOINT) && p.iph.daddr))\n\t\treturn -EINVAL;\n\n\treturn ip_tunnel_changelink(dev, tb, &p, fwmark);\n}\n\nstatic size_t ipip_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(0) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t0;\n}\n\nstatic int ipip_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct ip_tunnel_parm *parm = &tunnel->parms;\n\n\tif (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||\n\t    nla_put_in_addr(skb, IFLA_IPTUN_LOCAL, parm->iph.saddr) ||\n\t    nla_put_in_addr(skb, IFLA_IPTUN_REMOTE, parm->iph.daddr) ||\n\t    nla_put_u8(skb, IFLA_IPTUN_TTL, parm->iph.ttl) ||\n\t    nla_put_u8(skb, IFLA_IPTUN_TOS, parm->iph.tos) ||\n\t    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->iph.protocol) ||\n\t    nla_put_u8(skb, IFLA_IPTUN_PMTUDISC,\n\t\t       !!(parm->iph.frag_off & htons(IP_DF))) ||\n\t    nla_put_u32(skb, IFLA_IPTUN_FWMARK, tunnel->fwmark))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(skb, IFLA_IPTUN_ENCAP_TYPE,\n\t\t\ttunnel->encap.type) ||\n\t    nla_put_be16(skb, IFLA_IPTUN_ENCAP_SPORT,\n\t\t\t tunnel->encap.sport) ||\n\t    nla_put_be16(skb, IFLA_IPTUN_ENCAP_DPORT,\n\t\t\t tunnel->encap.dport) ||\n\t    nla_put_u16(skb, IFLA_IPTUN_ENCAP_FLAGS,\n\t\t\ttunnel->encap.flags))\n\t\tgoto nla_put_failure;\n\n\tif (tunnel->collect_md)\n\t\tif (nla_put_flag(skb, IFLA_IPTUN_COLLECT_METADATA))\n\t\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy ipip_policy[IFLA_IPTUN_MAX + 1] = {\n\t[IFLA_IPTUN_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_IPTUN_LOCAL]\t\t= { .type = NLA_U32 },\n\t[IFLA_IPTUN_REMOTE]\t\t= { .type = NLA_U32 },\n\t[IFLA_IPTUN_TTL]\t\t= { .type = NLA_U8 },\n\t[IFLA_IPTUN_TOS]\t\t= { .type = NLA_U8 },\n\t[IFLA_IPTUN_PROTO]\t\t= { .type = NLA_U8 },\n\t[IFLA_IPTUN_PMTUDISC]\t\t= { .type = NLA_U8 },\n\t[IFLA_IPTUN_ENCAP_TYPE]\t\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_ENCAP_FLAGS]\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_ENCAP_SPORT]\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_ENCAP_DPORT]\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_COLLECT_METADATA]\t= { .type = NLA_FLAG },\n\t[IFLA_IPTUN_FWMARK]\t\t= { .type = NLA_U32 },\n};\n\nstatic struct rtnl_link_ops ipip_link_ops __read_mostly = {\n\t.kind\t\t= \"ipip\",\n\t.maxtype\t= IFLA_IPTUN_MAX,\n\t.policy\t\t= ipip_policy,\n\t.priv_size\t= sizeof(struct ip_tunnel),\n\t.setup\t\t= ipip_tunnel_setup,\n\t.validate\t= ipip_tunnel_validate,\n\t.newlink\t= ipip_newlink,\n\t.changelink\t= ipip_changelink,\n\t.dellink\t= ip_tunnel_dellink,\n\t.get_size\t= ipip_get_size,\n\t.fill_info\t= ipip_fill_info,\n\t.get_link_net\t= ip_tunnel_get_link_net,\n};\n\nstatic struct xfrm_tunnel ipip_handler __read_mostly = {\n\t.handler\t=\tipip_rcv,\n\t.err_handler\t=\tipip_err,\n\t.priority\t=\t1,\n};\n\n#if IS_ENABLED(CONFIG_MPLS)\nstatic struct xfrm_tunnel mplsip_handler __read_mostly = {\n\t.handler\t=\tmplsip_rcv,\n\t.err_handler\t=\tipip_err,\n\t.priority\t=\t1,\n};\n#endif\n\nstatic int __net_init ipip_init_net(struct net *net)\n{\n\treturn ip_tunnel_init_net(net, ipip_net_id, &ipip_link_ops, \"tunl0\");\n}\n\nstatic void __net_exit ipip_exit_batch_net(struct list_head *list_net)\n{\n\tip_tunnel_delete_nets(list_net, ipip_net_id, &ipip_link_ops);\n}\n\nstatic struct pernet_operations ipip_net_ops = {\n\t.init = ipip_init_net,\n\t.exit_batch = ipip_exit_batch_net,\n\t.id   = &ipip_net_id,\n\t.size = sizeof(struct ip_tunnel_net),\n};\n\nstatic int __init ipip_init(void)\n{\n\tint err;\n\n\tpr_info(\"ipip: IPv4 and MPLS over IPv4 tunneling driver\\n\");\n\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\terr = xfrm4_tunnel_register(&ipip_handler, AF_INET);\n\tif (err < 0) {\n\t\tpr_info(\"%s: can't register tunnel\\n\", __func__);\n\t\tgoto xfrm_tunnel_ipip_failed;\n\t}\n#if IS_ENABLED(CONFIG_MPLS)\n\terr = xfrm4_tunnel_register(&mplsip_handler, AF_MPLS);\n\tif (err < 0) {\n\t\tpr_info(\"%s: can't register tunnel\\n\", __func__);\n\t\tgoto xfrm_tunnel_mplsip_failed;\n\t}\n#endif\n\terr = rtnl_link_register(&ipip_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\nout:\n\treturn err;\n\nrtnl_link_failed:\n#if IS_ENABLED(CONFIG_MPLS)\n\txfrm4_tunnel_deregister(&mplsip_handler, AF_MPLS);\nxfrm_tunnel_mplsip_failed:\n\n#endif\n\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\nxfrm_tunnel_ipip_failed:\n\tunregister_pernet_device(&ipip_net_ops);\n\tgoto out;\n}\n\nstatic void __exit ipip_fini(void)\n{\n\trtnl_link_unregister(&ipip_link_ops);\n\tif (xfrm4_tunnel_deregister(&ipip_handler, AF_INET))\n\t\tpr_info(\"%s: can't deregister tunnel\\n\", __func__);\n#if IS_ENABLED(CONFIG_MPLS)\n\tif (xfrm4_tunnel_deregister(&mplsip_handler, AF_MPLS))\n\t\tpr_info(\"%s: can't deregister tunnel\\n\", __func__);\n#endif\n\tunregister_pernet_device(&ipip_net_ops);\n}\n\nmodule_init(ipip_init);\nmodule_exit(ipip_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(\"ipip\");\nMODULE_ALIAS_NETDEV(\"tunl0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}