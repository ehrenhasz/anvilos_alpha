{
  "module_name": "tcp_illinois.c",
  "hash_id": "e6fcdbdee7e2fa9c5b0a2a835fe77901c4cf4fd28cbba9630387606f61467419",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_illinois.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/inet_diag.h>\n#include <asm/div64.h>\n#include <net/tcp.h>\n\n#define ALPHA_SHIFT\t7\n#define ALPHA_SCALE\t(1u<<ALPHA_SHIFT)\n#define ALPHA_MIN\t((3*ALPHA_SCALE)/10)\t \n#define ALPHA_MAX\t(10*ALPHA_SCALE)\t \n#define ALPHA_BASE\tALPHA_SCALE\t\t \n#define RTT_MAX\t\t(U32_MAX / ALPHA_MAX)\t \n\n#define BETA_SHIFT\t6\n#define BETA_SCALE\t(1u<<BETA_SHIFT)\n#define BETA_MIN\t(BETA_SCALE/8)\t\t \n#define BETA_MAX\t(BETA_SCALE/2)\t\t \n#define BETA_BASE\tBETA_MAX\n\nstatic int win_thresh __read_mostly = 15;\nmodule_param(win_thresh, int, 0);\nMODULE_PARM_DESC(win_thresh, \"Window threshold for starting adaptive sizing\");\n\nstatic int theta __read_mostly = 5;\nmodule_param(theta, int, 0);\nMODULE_PARM_DESC(theta, \"# of fast RTT's before full growth\");\n\n \nstruct illinois {\n\tu64\tsum_rtt;\t \n\tu16\tcnt_rtt;\t \n\tu32\tbase_rtt;\t \n\tu32\tmax_rtt;\t \n\tu32\tend_seq;\t \n\tu32\talpha;\t\t \n\tu32\tbeta;\t\t \n\tu16\tacked;\t\t \n\tu8\trtt_above;\t \n\tu8\trtt_low;\t \n};\n\nstatic void rtt_reset(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct illinois *ca = inet_csk_ca(sk);\n\n\tca->end_seq = tp->snd_nxt;\n\tca->cnt_rtt = 0;\n\tca->sum_rtt = 0;\n\n\t \n}\n\nstatic void tcp_illinois_init(struct sock *sk)\n{\n\tstruct illinois *ca = inet_csk_ca(sk);\n\n\tca->alpha = ALPHA_MAX;\n\tca->beta = BETA_BASE;\n\tca->base_rtt = 0x7fffffff;\n\tca->max_rtt = 0;\n\n\tca->acked = 0;\n\tca->rtt_low = 0;\n\tca->rtt_above = 0;\n\n\trtt_reset(sk);\n}\n\n \nstatic void tcp_illinois_acked(struct sock *sk, const struct ack_sample *sample)\n{\n\tstruct illinois *ca = inet_csk_ca(sk);\n\ts32 rtt_us = sample->rtt_us;\n\n\tca->acked = sample->pkts_acked;\n\n\t \n\tif (rtt_us < 0)\n\t\treturn;\n\n\t \n\tif (rtt_us > RTT_MAX)\n\t\trtt_us = RTT_MAX;\n\n\t \n\tif (ca->base_rtt > rtt_us)\n\t\tca->base_rtt = rtt_us;\n\n\t \n\tif (ca->max_rtt < rtt_us)\n\t\tca->max_rtt = rtt_us;\n\n\t++ca->cnt_rtt;\n\tca->sum_rtt += rtt_us;\n}\n\n \nstatic inline u32 max_delay(const struct illinois *ca)\n{\n\treturn ca->max_rtt - ca->base_rtt;\n}\n\n \nstatic inline u32 avg_delay(const struct illinois *ca)\n{\n\tu64 t = ca->sum_rtt;\n\n\tdo_div(t, ca->cnt_rtt);\n\treturn t - ca->base_rtt;\n}\n\n \nstatic u32 alpha(struct illinois *ca, u32 da, u32 dm)\n{\n\tu32 d1 = dm / 100;\t \n\n\tif (da <= d1) {\n\t\t \n\t\tif (!ca->rtt_above)\n\t\t\treturn ALPHA_MAX;\n\n\t\t \n\t\tif (++ca->rtt_low < theta)\n\t\t\treturn ca->alpha;\n\n\t\tca->rtt_low = 0;\n\t\tca->rtt_above = 0;\n\t\treturn ALPHA_MAX;\n\t}\n\n\tca->rtt_above = 1;\n\n\t \n\n\tdm -= d1;\n\tda -= d1;\n\treturn (dm * ALPHA_MAX) /\n\t\t(dm + (da  * (ALPHA_MAX - ALPHA_MIN)) / ALPHA_MIN);\n}\n\n \nstatic u32 beta(u32 da, u32 dm)\n{\n\tu32 d2, d3;\n\n\td2 = dm / 10;\n\tif (da <= d2)\n\t\treturn BETA_MIN;\n\n\td3 = (8 * dm) / 10;\n\tif (da >= d3 || d3 <= d2)\n\t\treturn BETA_MAX;\n\n\t \n\treturn (BETA_MIN * d3 - BETA_MAX * d2 + (BETA_MAX - BETA_MIN) * da)\n\t\t/ (d3 - d2);\n}\n\n \nstatic void update_params(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct illinois *ca = inet_csk_ca(sk);\n\n\tif (tcp_snd_cwnd(tp) < win_thresh) {\n\t\tca->alpha = ALPHA_BASE;\n\t\tca->beta = BETA_BASE;\n\t} else if (ca->cnt_rtt > 0) {\n\t\tu32 dm = max_delay(ca);\n\t\tu32 da = avg_delay(ca);\n\n\t\tca->alpha = alpha(ca, da, dm);\n\t\tca->beta = beta(da, dm);\n\t}\n\n\trtt_reset(sk);\n}\n\n \nstatic void tcp_illinois_state(struct sock *sk, u8 new_state)\n{\n\tstruct illinois *ca = inet_csk_ca(sk);\n\n\tif (new_state == TCP_CA_Loss) {\n\t\tca->alpha = ALPHA_BASE;\n\t\tca->beta = BETA_BASE;\n\t\tca->rtt_low = 0;\n\t\tca->rtt_above = 0;\n\t\trtt_reset(sk);\n\t}\n}\n\n \nstatic void tcp_illinois_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct illinois *ca = inet_csk_ca(sk);\n\n\tif (after(ack, ca->end_seq))\n\t\tupdate_params(sk);\n\n\t \n\tif (!tcp_is_cwnd_limited(sk))\n\t\treturn;\n\n\t \n\tif (tcp_in_slow_start(tp))\n\t\ttcp_slow_start(tp, acked);\n\n\telse {\n\t\tu32 delta;\n\n\t\t \n\t\ttp->snd_cwnd_cnt += ca->acked;\n\t\tca->acked = 1;\n\n\t\t \n\t\tdelta = (tp->snd_cwnd_cnt * ca->alpha) >> ALPHA_SHIFT;\n\t\tif (delta >= tcp_snd_cwnd(tp)) {\n\t\t\ttcp_snd_cwnd_set(tp, min(tcp_snd_cwnd(tp) + delta / tcp_snd_cwnd(tp),\n\t\t\t\t\t\t (u32)tp->snd_cwnd_clamp));\n\t\t\ttp->snd_cwnd_cnt = 0;\n\t\t}\n\t}\n}\n\nstatic u32 tcp_illinois_ssthresh(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct illinois *ca = inet_csk_ca(sk);\n\tu32 decr;\n\n\t \n\tdecr = (tcp_snd_cwnd(tp) * ca->beta) >> BETA_SHIFT;\n\treturn max(tcp_snd_cwnd(tp) - decr, 2U);\n}\n\n \nstatic size_t tcp_illinois_info(struct sock *sk, u32 ext, int *attr,\n\t\t\t\tunion tcp_cc_info *info)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tinfo->vegas.tcpv_enabled = 1;\n\t\tinfo->vegas.tcpv_rttcnt = ca->cnt_rtt;\n\t\tinfo->vegas.tcpv_minrtt = ca->base_rtt;\n\t\tinfo->vegas.tcpv_rtt = 0;\n\n\t\tif (info->vegas.tcpv_rttcnt > 0) {\n\t\t\tu64 t = ca->sum_rtt;\n\n\t\t\tdo_div(t, info->vegas.tcpv_rttcnt);\n\t\t\tinfo->vegas.tcpv_rtt = t;\n\t\t}\n\t\t*attr = INET_DIAG_VEGASINFO;\n\t\treturn sizeof(struct tcpvegas_info);\n\t}\n\treturn 0;\n}\n\nstatic struct tcp_congestion_ops tcp_illinois __read_mostly = {\n\t.init\t\t= tcp_illinois_init,\n\t.ssthresh\t= tcp_illinois_ssthresh,\n\t.undo_cwnd\t= tcp_reno_undo_cwnd,\n\t.cong_avoid\t= tcp_illinois_cong_avoid,\n\t.set_state\t= tcp_illinois_state,\n\t.get_info\t= tcp_illinois_info,\n\t.pkts_acked\t= tcp_illinois_acked,\n\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"illinois\",\n};\n\nstatic int __init tcp_illinois_register(void)\n{\n\tBUILD_BUG_ON(sizeof(struct illinois) > ICSK_CA_PRIV_SIZE);\n\treturn tcp_register_congestion_control(&tcp_illinois);\n}\n\nstatic void __exit tcp_illinois_unregister(void)\n{\n\ttcp_unregister_congestion_control(&tcp_illinois);\n}\n\nmodule_init(tcp_illinois_register);\nmodule_exit(tcp_illinois_unregister);\n\nMODULE_AUTHOR(\"Stephen Hemminger, Shao Liu\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TCP Illinois\");\nMODULE_VERSION(\"1.0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}