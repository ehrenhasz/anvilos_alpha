{
  "module_name": "udp_bpf.c",
  "hash_id": "d8d859652d790780ea3ea650ad20aea335cf894f31abe446736de64f27b4a939",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/udp_bpf.c",
  "human_readable_source": "\n/* Copyright (c) 2020 Cloudflare Ltd https:\n\n#include <linux/skmsg.h>\n#include <net/sock.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n\n#include \"udp_impl.h\"\n\nstatic struct proto *udpv6_prot_saved __read_mostly;\n\nstatic int sk_udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t  int flags, int *addr_len)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\treturn udpv6_prot_saved->recvmsg(sk, msg, len, flags, addr_len);\n#endif\n\treturn udp_prot.recvmsg(sk, msg, len, flags, addr_len);\n}\n\nstatic bool udp_sk_has_data(struct sock *sk)\n{\n\treturn !skb_queue_empty(&udp_sk(sk)->reader_queue) ||\n\t       !skb_queue_empty(&sk->sk_receive_queue);\n}\n\nstatic bool psock_has_data(struct sk_psock *psock)\n{\n\treturn !skb_queue_empty(&psock->ingress_skb) ||\n\t       !sk_psock_queue_empty(psock);\n}\n\n#define udp_msg_has_data(__sk, __psock)\t\\\n\t\t({ udp_sk_has_data(__sk) || psock_has_data(__psock); })\n\nstatic int udp_msg_wait_data(struct sock *sk, struct sk_psock *psock,\n\t\t\t     long timeo)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint ret = 0;\n\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\treturn 1;\n\n\tif (!timeo)\n\t\treturn ret;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tsk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\tret = udp_msg_has_data(sk, psock);\n\tif (!ret) {\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\t\tret = udp_msg_has_data(sk, psock);\n\t}\n\tsk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn ret;\n}\n\nstatic int udp_bpf_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t   int flags, int *addr_len)\n{\n\tstruct sk_psock *psock;\n\tint copied, ret;\n\n\tif (unlikely(flags & MSG_ERRQUEUE))\n\t\treturn inet_recv_error(sk, msg, len, addr_len);\n\n\tif (!len)\n\t\treturn 0;\n\n\tpsock = sk_psock_get(sk);\n\tif (unlikely(!psock))\n\t\treturn sk_udp_recvmsg(sk, msg, len, flags, addr_len);\n\n\tif (!psock_has_data(psock)) {\n\t\tret = sk_udp_recvmsg(sk, msg, len, flags, addr_len);\n\t\tgoto out;\n\t}\n\nmsg_bytes_ready:\n\tcopied = sk_msg_recvmsg(sk, psock, msg, len, flags);\n\tif (!copied) {\n\t\tlong timeo;\n\t\tint data;\n\n\t\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\t\tdata = udp_msg_wait_data(sk, psock, timeo);\n\t\tif (data) {\n\t\t\tif (psock_has_data(psock))\n\t\t\t\tgoto msg_bytes_ready;\n\t\t\tret = sk_udp_recvmsg(sk, msg, len, flags, addr_len);\n\t\t\tgoto out;\n\t\t}\n\t\tcopied = -EAGAIN;\n\t}\n\tret = copied;\nout:\n\tsk_psock_put(sk, psock);\n\treturn ret;\n}\n\nenum {\n\tUDP_BPF_IPV4,\n\tUDP_BPF_IPV6,\n\tUDP_BPF_NUM_PROTS,\n};\n\nstatic DEFINE_SPINLOCK(udpv6_prot_lock);\nstatic struct proto udp_bpf_prots[UDP_BPF_NUM_PROTS];\n\nstatic void udp_bpf_rebuild_protos(struct proto *prot, const struct proto *base)\n{\n\t*prot        = *base;\n\tprot->close  = sock_map_close;\n\tprot->recvmsg = udp_bpf_recvmsg;\n\tprot->sock_is_readable = sk_msg_is_readable;\n}\n\nstatic void udp_bpf_check_v6_needs_rebuild(struct proto *ops)\n{\n\tif (unlikely(ops != smp_load_acquire(&udpv6_prot_saved))) {\n\t\tspin_lock_bh(&udpv6_prot_lock);\n\t\tif (likely(ops != udpv6_prot_saved)) {\n\t\t\tudp_bpf_rebuild_protos(&udp_bpf_prots[UDP_BPF_IPV6], ops);\n\t\t\tsmp_store_release(&udpv6_prot_saved, ops);\n\t\t}\n\t\tspin_unlock_bh(&udpv6_prot_lock);\n\t}\n}\n\nstatic int __init udp_bpf_v4_build_proto(void)\n{\n\tudp_bpf_rebuild_protos(&udp_bpf_prots[UDP_BPF_IPV4], &udp_prot);\n\treturn 0;\n}\nlate_initcall(udp_bpf_v4_build_proto);\n\nint udp_bpf_update_proto(struct sock *sk, struct sk_psock *psock, bool restore)\n{\n\tint family = sk->sk_family == AF_INET ? UDP_BPF_IPV4 : UDP_BPF_IPV6;\n\n\tif (restore) {\n\t\tsk->sk_write_space = psock->saved_write_space;\n\t\tsock_replace_proto(sk, psock->sk_proto);\n\t\treturn 0;\n\t}\n\n\tif (sk->sk_family == AF_INET6)\n\t\tudp_bpf_check_v6_needs_rebuild(psock->sk_proto);\n\n\tsock_replace_proto(sk, &udp_bpf_prots[family]);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(udp_bpf_update_proto);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}