{
  "module_name": "netfilter.c",
  "hash_id": "f4215034c917a71130d70c1176c2114ae65a26ee97c2b2a26c1b010cf357059d",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/netfilter.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/ip.h>\n#include <linux/skbuff.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <net/route.h>\n#include <net/xfrm.h>\n#include <net/ip.h>\n#include <net/netfilter/nf_queue.h>\n\n \nint ip_route_me_harder(struct net *net, struct sock *sk, struct sk_buff *skb, unsigned int addr_type)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct rtable *rt;\n\tstruct flowi4 fl4 = {};\n\t__be32 saddr = iph->saddr;\n\t__u8 flags;\n\tstruct net_device *dev = skb_dst(skb)->dev;\n\tstruct flow_keys flkeys;\n\tunsigned int hh_len;\n\n\tsk = sk_to_full_sk(sk);\n\tflags = sk ? inet_sk_flowi_flags(sk) : 0;\n\n\tif (addr_type == RTN_UNSPEC)\n\t\taddr_type = inet_addr_type_dev_table(net, dev, saddr);\n\tif (addr_type == RTN_LOCAL || addr_type == RTN_UNICAST)\n\t\tflags |= FLOWI_FLAG_ANYSRC;\n\telse\n\t\tsaddr = 0;\n\n\t \n\tfl4.daddr = iph->daddr;\n\tfl4.saddr = saddr;\n\tfl4.flowi4_tos = RT_TOS(iph->tos);\n\tfl4.flowi4_oif = sk ? sk->sk_bound_dev_if : 0;\n\tfl4.flowi4_l3mdev = l3mdev_master_ifindex(dev);\n\tfl4.flowi4_mark = skb->mark;\n\tfl4.flowi4_flags = flags;\n\tfib4_rules_early_flow_dissect(net, skb, &fl4, &flkeys);\n\trt = ip_route_output_key(net, &fl4);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\t \n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, &rt->dst);\n\n\tif (skb_dst(skb)->error)\n\t\treturn skb_dst(skb)->error;\n\n#ifdef CONFIG_XFRM\n\tif (!(IPCB(skb)->flags & IPSKB_XFRM_TRANSFORMED) &&\n\t    xfrm_decode_session(skb, flowi4_to_flowi(&fl4), AF_INET) == 0) {\n\t\tstruct dst_entry *dst = skb_dst(skb);\n\t\tskb_dst_set(skb, NULL);\n\t\tdst = xfrm_lookup(net, dst, flowi4_to_flowi(&fl4), sk, 0);\n\t\tif (IS_ERR(dst))\n\t\t\treturn PTR_ERR(dst);\n\t\tskb_dst_set(skb, dst);\n\t}\n#endif\n\n\t \n\thh_len = skb_dst(skb)->dev->hard_header_len;\n\tif (skb_headroom(skb) < hh_len &&\n\t    pskb_expand_head(skb, HH_DATA_ALIGN(hh_len - skb_headroom(skb)),\n\t\t\t\t0, GFP_ATOMIC))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ip_route_me_harder);\n\nint nf_ip_route(struct net *net, struct dst_entry **dst, struct flowi *fl,\n\t\tbool strict __always_unused)\n{\n\tstruct rtable *rt = ip_route_output_key(net, &fl->u.ip4);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\t*dst = &rt->dst;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nf_ip_route);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}