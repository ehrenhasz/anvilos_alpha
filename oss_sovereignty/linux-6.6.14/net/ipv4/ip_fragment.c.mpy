{
  "module_name": "ip_fragment.c",
  "hash_id": "8f343252d4ae2b1c735167a1bc8c8526a61fa8bd66a8ee16eb6e1137f4be9fe7",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ip_fragment.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"IPv4: \" fmt\n\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/skbuff.h>\n#include <linux/list.h>\n#include <linux/ip.h>\n#include <linux/icmp.h>\n#include <linux/netdevice.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <net/route.h>\n#include <net/dst.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/checksum.h>\n#include <net/inetpeer.h>\n#include <net/inet_frag.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/inet.h>\n#include <linux/netfilter_ipv4.h>\n#include <net/inet_ecn.h>\n#include <net/l3mdev.h>\n\n \nstatic const char ip_frag_cache_name[] = \"ip4-frags\";\n\n \nstruct ipq {\n\tstruct inet_frag_queue q;\n\n\tu8\t\tecn;  \n\tu16\t\tmax_df_size;  \n\tint             iif;\n\tunsigned int    rid;\n\tstruct inet_peer *peer;\n};\n\nstatic u8 ip4_frag_ecn(u8 tos)\n{\n\treturn 1 << (tos & INET_ECN_MASK);\n}\n\nstatic struct inet_frags ip4_frags;\n\nstatic int ip_frag_reasm(struct ipq *qp, struct sk_buff *skb,\n\t\t\t struct sk_buff *prev_tail, struct net_device *dev);\n\n\nstatic void ip4_frag_init(struct inet_frag_queue *q, const void *a)\n{\n\tstruct ipq *qp = container_of(q, struct ipq, q);\n\tstruct net *net = q->fqdir->net;\n\n\tconst struct frag_v4_compare_key *key = a;\n\n\tq->key.v4 = *key;\n\tqp->ecn = 0;\n\tqp->peer = q->fqdir->max_dist ?\n\t\tinet_getpeer_v4(net->ipv4.peers, key->saddr, key->vif, 1) :\n\t\tNULL;\n}\n\nstatic void ip4_frag_free(struct inet_frag_queue *q)\n{\n\tstruct ipq *qp;\n\n\tqp = container_of(q, struct ipq, q);\n\tif (qp->peer)\n\t\tinet_putpeer(qp->peer);\n}\n\n\n \n\nstatic void ipq_put(struct ipq *ipq)\n{\n\tinet_frag_put(&ipq->q);\n}\n\n \nstatic void ipq_kill(struct ipq *ipq)\n{\n\tinet_frag_kill(&ipq->q);\n}\n\nstatic bool frag_expire_skip_icmp(u32 user)\n{\n\treturn user == IP_DEFRAG_AF_PACKET ||\n\t       ip_defrag_user_in_between(user, IP_DEFRAG_CONNTRACK_IN,\n\t\t\t\t\t __IP_DEFRAG_CONNTRACK_IN_END) ||\n\t       ip_defrag_user_in_between(user, IP_DEFRAG_CONNTRACK_BRIDGE_IN,\n\t\t\t\t\t __IP_DEFRAG_CONNTRACK_BRIDGE_IN);\n}\n\n \nstatic void ip_expire(struct timer_list *t)\n{\n\tstruct inet_frag_queue *frag = from_timer(frag, t, timer);\n\tconst struct iphdr *iph;\n\tstruct sk_buff *head = NULL;\n\tstruct net *net;\n\tstruct ipq *qp;\n\tint err;\n\n\tqp = container_of(frag, struct ipq, q);\n\tnet = qp->q.fqdir->net;\n\n\trcu_read_lock();\n\n\t \n\tif (READ_ONCE(qp->q.fqdir->dead))\n\t\tgoto out_rcu_unlock;\n\n\tspin_lock(&qp->q.lock);\n\n\tif (qp->q.flags & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tqp->q.flags |= INET_FRAG_DROP;\n\tipq_kill(qp);\n\t__IP_INC_STATS(net, IPSTATS_MIB_REASMFAILS);\n\t__IP_INC_STATS(net, IPSTATS_MIB_REASMTIMEOUT);\n\n\tif (!(qp->q.flags & INET_FRAG_FIRST_IN))\n\t\tgoto out;\n\n\t \n\thead = inet_frag_pull_head(&qp->q);\n\tif (!head)\n\t\tgoto out;\n\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n\tif (!head->dev)\n\t\tgoto out;\n\n\n\t \n\tiph = ip_hdr(head);\n\terr = ip_route_input_noref(head, iph->daddr, iph->saddr,\n\t\t\t\t\t   iph->tos, head->dev);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif (frag_expire_skip_icmp(qp->q.key.v4.user) &&\n\t    (skb_rtable(head)->rt_type != RTN_LOCAL))\n\t\tgoto out;\n\n\tspin_unlock(&qp->q.lock);\n\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\n\tgoto out_rcu_unlock;\n\nout:\n\tspin_unlock(&qp->q.lock);\nout_rcu_unlock:\n\trcu_read_unlock();\n\tkfree_skb_reason(head, SKB_DROP_REASON_FRAG_REASM_TIMEOUT);\n\tipq_put(qp);\n}\n\n \nstatic struct ipq *ip_find(struct net *net, struct iphdr *iph,\n\t\t\t   u32 user, int vif)\n{\n\tstruct frag_v4_compare_key key = {\n\t\t.saddr = iph->saddr,\n\t\t.daddr = iph->daddr,\n\t\t.user = user,\n\t\t.vif = vif,\n\t\t.id = iph->id,\n\t\t.protocol = iph->protocol,\n\t};\n\tstruct inet_frag_queue *q;\n\n\tq = inet_frag_find(net->ipv4.fqdir, &key);\n\tif (!q)\n\t\treturn NULL;\n\n\treturn container_of(q, struct ipq, q);\n}\n\n \nstatic int ip_frag_too_far(struct ipq *qp)\n{\n\tstruct inet_peer *peer = qp->peer;\n\tunsigned int max = qp->q.fqdir->max_dist;\n\tunsigned int start, end;\n\n\tint rc;\n\n\tif (!peer || !max)\n\t\treturn 0;\n\n\tstart = qp->rid;\n\tend = atomic_inc_return(&peer->rid);\n\tqp->rid = end;\n\n\trc = qp->q.fragments_tail && (end - start) > max;\n\n\tif (rc)\n\t\t__IP_INC_STATS(qp->q.fqdir->net, IPSTATS_MIB_REASMFAILS);\n\n\treturn rc;\n}\n\nstatic int ip_frag_reinit(struct ipq *qp)\n{\n\tunsigned int sum_truesize = 0;\n\n\tif (!mod_timer(&qp->q.timer, jiffies + qp->q.fqdir->timeout)) {\n\t\trefcount_inc(&qp->q.refcnt);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tsum_truesize = inet_frag_rbtree_purge(&qp->q.rb_fragments,\n\t\t\t\t\t      SKB_DROP_REASON_FRAG_TOO_FAR);\n\tsub_frag_mem_limit(qp->q.fqdir, sum_truesize);\n\n\tqp->q.flags = 0;\n\tqp->q.len = 0;\n\tqp->q.meat = 0;\n\tqp->q.rb_fragments = RB_ROOT;\n\tqp->q.fragments_tail = NULL;\n\tqp->q.last_run_head = NULL;\n\tqp->iif = 0;\n\tqp->ecn = 0;\n\n\treturn 0;\n}\n\n \nstatic int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)\n{\n\tstruct net *net = qp->q.fqdir->net;\n\tint ihl, end, flags, offset;\n\tstruct sk_buff *prev_tail;\n\tstruct net_device *dev;\n\tunsigned int fragsize;\n\tint err = -ENOENT;\n\tSKB_DR(reason);\n\tu8 ecn;\n\n\t \n\tif (qp->q.flags & INET_FRAG_COMPLETE) {\n\t\tSKB_DR_SET(reason, DUP_FRAG);\n\t\tgoto err;\n\t}\n\n\tif (!(IPCB(skb)->flags & IPSKB_FRAG_COMPLETE) &&\n\t    unlikely(ip_frag_too_far(qp)) &&\n\t    unlikely(err = ip_frag_reinit(qp))) {\n\t\tipq_kill(qp);\n\t\tgoto err;\n\t}\n\n\tecn = ip4_frag_ecn(ip_hdr(skb)->tos);\n\toffset = ntohs(ip_hdr(skb)->frag_off);\n\tflags = offset & ~IP_OFFSET;\n\toffset &= IP_OFFSET;\n\toffset <<= 3;\t\t \n\tihl = ip_hdrlen(skb);\n\n\t \n\tend = offset + skb->len - skb_network_offset(skb) - ihl;\n\terr = -EINVAL;\n\n\t \n\tif ((flags & IP_MF) == 0) {\n\t\t \n\t\tif (end < qp->q.len ||\n\t\t    ((qp->q.flags & INET_FRAG_LAST_IN) && end != qp->q.len))\n\t\t\tgoto discard_qp;\n\t\tqp->q.flags |= INET_FRAG_LAST_IN;\n\t\tqp->q.len = end;\n\t} else {\n\t\tif (end&7) {\n\t\t\tend &= ~7;\n\t\t\tif (skb->ip_summed != CHECKSUM_UNNECESSARY)\n\t\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t}\n\t\tif (end > qp->q.len) {\n\t\t\t \n\t\t\tif (qp->q.flags & INET_FRAG_LAST_IN)\n\t\t\t\tgoto discard_qp;\n\t\t\tqp->q.len = end;\n\t\t}\n\t}\n\tif (end == offset)\n\t\tgoto discard_qp;\n\n\terr = -ENOMEM;\n\tif (!pskb_pull(skb, skb_network_offset(skb) + ihl))\n\t\tgoto discard_qp;\n\n\terr = pskb_trim_rcsum(skb, end - offset);\n\tif (err)\n\t\tgoto discard_qp;\n\n\t \n\tdev = skb->dev;\n\t \n\tbarrier();\n\n\tprev_tail = qp->q.fragments_tail;\n\terr = inet_frag_queue_insert(&qp->q, skb, offset, end);\n\tif (err)\n\t\tgoto insert_error;\n\n\tif (dev)\n\t\tqp->iif = dev->ifindex;\n\n\tqp->q.stamp = skb->tstamp;\n\tqp->q.mono_delivery_time = skb->mono_delivery_time;\n\tqp->q.meat += skb->len;\n\tqp->ecn |= ecn;\n\tadd_frag_mem_limit(qp->q.fqdir, skb->truesize);\n\tif (offset == 0)\n\t\tqp->q.flags |= INET_FRAG_FIRST_IN;\n\n\tfragsize = skb->len + ihl;\n\n\tif (fragsize > qp->q.max_size)\n\t\tqp->q.max_size = fragsize;\n\n\tif (ip_hdr(skb)->frag_off & htons(IP_DF) &&\n\t    fragsize > qp->max_df_size)\n\t\tqp->max_df_size = fragsize;\n\n\tif (qp->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    qp->q.meat == qp->q.len) {\n\t\tunsigned long orefdst = skb->_skb_refdst;\n\n\t\tskb->_skb_refdst = 0UL;\n\t\terr = ip_frag_reasm(qp, skb, prev_tail, dev);\n\t\tskb->_skb_refdst = orefdst;\n\t\tif (err)\n\t\t\tinet_frag_kill(&qp->q);\n\t\treturn err;\n\t}\n\n\tskb_dst_drop(skb);\n\treturn -EINPROGRESS;\n\ninsert_error:\n\tif (err == IPFRAG_DUP) {\n\t\tSKB_DR_SET(reason, DUP_FRAG);\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\terr = -EINVAL;\n\t__IP_INC_STATS(net, IPSTATS_MIB_REASM_OVERLAPS);\ndiscard_qp:\n\tinet_frag_kill(&qp->q);\n\t__IP_INC_STATS(net, IPSTATS_MIB_REASMFAILS);\nerr:\n\tkfree_skb_reason(skb, reason);\n\treturn err;\n}\n\nstatic bool ip_frag_coalesce_ok(const struct ipq *qp)\n{\n\treturn qp->q.key.v4.user == IP_DEFRAG_LOCAL_DELIVER;\n}\n\n \nstatic int ip_frag_reasm(struct ipq *qp, struct sk_buff *skb,\n\t\t\t struct sk_buff *prev_tail, struct net_device *dev)\n{\n\tstruct net *net = qp->q.fqdir->net;\n\tstruct iphdr *iph;\n\tvoid *reasm_data;\n\tint len, err;\n\tu8 ecn;\n\n\tipq_kill(qp);\n\n\tecn = ip_frag_ecn_table[qp->ecn];\n\tif (unlikely(ecn == 0xff)) {\n\t\terr = -EINVAL;\n\t\tgoto out_fail;\n\t}\n\n\t \n\treasm_data = inet_frag_reasm_prepare(&qp->q, skb, prev_tail);\n\tif (!reasm_data)\n\t\tgoto out_nomem;\n\n\tlen = ip_hdrlen(skb) + qp->q.len;\n\terr = -E2BIG;\n\tif (len > 65535)\n\t\tgoto out_oversize;\n\n\tinet_frag_reasm_finish(&qp->q, skb, reasm_data,\n\t\t\t       ip_frag_coalesce_ok(qp));\n\n\tskb->dev = dev;\n\tIPCB(skb)->frag_max_size = max(qp->max_df_size, qp->q.max_size);\n\n\tiph = ip_hdr(skb);\n\tiph->tot_len = htons(len);\n\tiph->tos |= ecn;\n\n\t \n\tif (qp->max_df_size == qp->q.max_size) {\n\t\tIPCB(skb)->flags |= IPSKB_FRAG_PMTU;\n\t\tiph->frag_off = htons(IP_DF);\n\t} else {\n\t\tiph->frag_off = 0;\n\t}\n\n\tip_send_check(iph);\n\n\t__IP_INC_STATS(net, IPSTATS_MIB_REASMOKS);\n\tqp->q.rb_fragments = RB_ROOT;\n\tqp->q.fragments_tail = NULL;\n\tqp->q.last_run_head = NULL;\n\treturn 0;\n\nout_nomem:\n\tnet_dbg_ratelimited(\"queue_glue: no memory for gluing queue %p\\n\", qp);\n\terr = -ENOMEM;\n\tgoto out_fail;\nout_oversize:\n\tnet_info_ratelimited(\"Oversized IP packet from %pI4\\n\", &qp->q.key.v4.saddr);\nout_fail:\n\t__IP_INC_STATS(net, IPSTATS_MIB_REASMFAILS);\n\treturn err;\n}\n\n \nint ip_defrag(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb->dev ? : skb_dst(skb)->dev;\n\tint vif = l3mdev_master_ifindex_rcu(dev);\n\tstruct ipq *qp;\n\n\t__IP_INC_STATS(net, IPSTATS_MIB_REASMREQDS);\n\tskb_orphan(skb);\n\n\t \n\tqp = ip_find(net, ip_hdr(skb), user, vif);\n\tif (qp) {\n\t\tint ret;\n\n\t\tspin_lock(&qp->q.lock);\n\n\t\tret = ip_frag_queue(qp, skb);\n\n\t\tspin_unlock(&qp->q.lock);\n\t\tipq_put(qp);\n\t\treturn ret;\n\t}\n\n\t__IP_INC_STATS(net, IPSTATS_MIB_REASMFAILS);\n\tkfree_skb(skb);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(ip_defrag);\n\nstruct sk_buff *ip_check_defrag(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct iphdr iph;\n\tint netoff;\n\tu32 len;\n\n\tif (skb->protocol != htons(ETH_P_IP))\n\t\treturn skb;\n\n\tnetoff = skb_network_offset(skb);\n\n\tif (skb_copy_bits(skb, netoff, &iph, sizeof(iph)) < 0)\n\t\treturn skb;\n\n\tif (iph.ihl < 5 || iph.version != 4)\n\t\treturn skb;\n\n\tlen = ntohs(iph.tot_len);\n\tif (skb->len < netoff + len || len < (iph.ihl * 4))\n\t\treturn skb;\n\n\tif (ip_is_fragment(&iph)) {\n\t\tskb = skb_share_check(skb, GFP_ATOMIC);\n\t\tif (skb) {\n\t\t\tif (!pskb_may_pull(skb, netoff + iph.ihl * 4)) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (pskb_trim_rcsum(skb, netoff + len)) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\t\tif (ip_defrag(net, skb, user))\n\t\t\t\treturn NULL;\n\t\t\tskb_clear_hash(skb);\n\t\t}\n\t}\n\treturn skb;\n}\nEXPORT_SYMBOL(ip_check_defrag);\n\n#ifdef CONFIG_SYSCTL\nstatic int dist_min;\n\nstatic struct ctl_table ip4_frags_ns_ctl_table[] = {\n\t{\n\t\t.procname\t= \"ipfrag_high_thresh\",\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"ipfrag_low_thresh\",\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"ipfrag_time\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"ipfrag_max_dist\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &dist_min,\n\t},\n\t{ }\n};\n\n \nstatic int ip4_frags_secret_interval_unused;\nstatic struct ctl_table ip4_frags_ctl_table[] = {\n\t{\n\t\t.procname\t= \"ipfrag_secret_interval\",\n\t\t.data\t\t= &ip4_frags_secret_interval_unused,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{ }\n};\n\nstatic int __net_init ip4_frags_ns_ctl_register(struct net *net)\n{\n\tstruct ctl_table *table;\n\tstruct ctl_table_header *hdr;\n\n\ttable = ip4_frags_ns_ctl_table;\n\tif (!net_eq(net, &init_net)) {\n\t\ttable = kmemdup(table, sizeof(ip4_frags_ns_ctl_table), GFP_KERNEL);\n\t\tif (!table)\n\t\t\tgoto err_alloc;\n\n\t}\n\ttable[0].data\t= &net->ipv4.fqdir->high_thresh;\n\ttable[0].extra1\t= &net->ipv4.fqdir->low_thresh;\n\ttable[1].data\t= &net->ipv4.fqdir->low_thresh;\n\ttable[1].extra2\t= &net->ipv4.fqdir->high_thresh;\n\ttable[2].data\t= &net->ipv4.fqdir->timeout;\n\ttable[3].data\t= &net->ipv4.fqdir->max_dist;\n\n\thdr = register_net_sysctl_sz(net, \"net/ipv4\", table,\n\t\t\t\t     ARRAY_SIZE(ip4_frags_ns_ctl_table));\n\tif (!hdr)\n\t\tgoto err_reg;\n\n\tnet->ipv4.frags_hdr = hdr;\n\treturn 0;\n\nerr_reg:\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\nerr_alloc:\n\treturn -ENOMEM;\n}\n\nstatic void __net_exit ip4_frags_ns_ctl_unregister(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = net->ipv4.frags_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(net->ipv4.frags_hdr);\n\tkfree(table);\n}\n\nstatic void __init ip4_frags_ctl_register(void)\n{\n\tregister_net_sysctl(&init_net, \"net/ipv4\", ip4_frags_ctl_table);\n}\n#else\nstatic int ip4_frags_ns_ctl_register(struct net *net)\n{\n\treturn 0;\n}\n\nstatic void ip4_frags_ns_ctl_unregister(struct net *net)\n{\n}\n\nstatic void __init ip4_frags_ctl_register(void)\n{\n}\n#endif\n\nstatic int __net_init ipv4_frags_init_net(struct net *net)\n{\n\tint res;\n\n\tres = fqdir_init(&net->ipv4.fqdir, &ip4_frags, net);\n\tif (res < 0)\n\t\treturn res;\n\t \n\tnet->ipv4.fqdir->high_thresh = 4 * 1024 * 1024;\n\tnet->ipv4.fqdir->low_thresh  = 3 * 1024 * 1024;\n\t \n\tnet->ipv4.fqdir->timeout = IP_FRAG_TIME;\n\n\tnet->ipv4.fqdir->max_dist = 64;\n\n\tres = ip4_frags_ns_ctl_register(net);\n\tif (res < 0)\n\t\tfqdir_exit(net->ipv4.fqdir);\n\treturn res;\n}\n\nstatic void __net_exit ipv4_frags_pre_exit_net(struct net *net)\n{\n\tfqdir_pre_exit(net->ipv4.fqdir);\n}\n\nstatic void __net_exit ipv4_frags_exit_net(struct net *net)\n{\n\tip4_frags_ns_ctl_unregister(net);\n\tfqdir_exit(net->ipv4.fqdir);\n}\n\nstatic struct pernet_operations ip4_frags_ops = {\n\t.init\t\t= ipv4_frags_init_net,\n\t.pre_exit\t= ipv4_frags_pre_exit_net,\n\t.exit\t\t= ipv4_frags_exit_net,\n};\n\n\nstatic u32 ip4_key_hashfn(const void *data, u32 len, u32 seed)\n{\n\treturn jhash2(data,\n\t\t      sizeof(struct frag_v4_compare_key) / sizeof(u32), seed);\n}\n\nstatic u32 ip4_obj_hashfn(const void *data, u32 len, u32 seed)\n{\n\tconst struct inet_frag_queue *fq = data;\n\n\treturn jhash2((const u32 *)&fq->key.v4,\n\t\t      sizeof(struct frag_v4_compare_key) / sizeof(u32), seed);\n}\n\nstatic int ip4_obj_cmpfn(struct rhashtable_compare_arg *arg, const void *ptr)\n{\n\tconst struct frag_v4_compare_key *key = arg->key;\n\tconst struct inet_frag_queue *fq = ptr;\n\n\treturn !!memcmp(&fq->key, key, sizeof(*key));\n}\n\nstatic const struct rhashtable_params ip4_rhash_params = {\n\t.head_offset\t\t= offsetof(struct inet_frag_queue, node),\n\t.key_offset\t\t= offsetof(struct inet_frag_queue, key),\n\t.key_len\t\t= sizeof(struct frag_v4_compare_key),\n\t.hashfn\t\t\t= ip4_key_hashfn,\n\t.obj_hashfn\t\t= ip4_obj_hashfn,\n\t.obj_cmpfn\t\t= ip4_obj_cmpfn,\n\t.automatic_shrinking\t= true,\n};\n\nvoid __init ipfrag_init(void)\n{\n\tip4_frags.constructor = ip4_frag_init;\n\tip4_frags.destructor = ip4_frag_free;\n\tip4_frags.qsize = sizeof(struct ipq);\n\tip4_frags.frag_expire = ip_expire;\n\tip4_frags.frags_cache_name = ip_frag_cache_name;\n\tip4_frags.rhash_params = ip4_rhash_params;\n\tif (inet_frags_init(&ip4_frags))\n\t\tpanic(\"IP: failed to allocate ip4_frags cache\\n\");\n\tip4_frags_ctl_register();\n\tregister_pernet_subsys(&ip4_frags_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}