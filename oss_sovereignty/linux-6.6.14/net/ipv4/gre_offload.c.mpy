{
  "module_name": "gre_offload.c",
  "hash_id": "cb2bba573afd6f444837ac4611b334e06f3eb9d297bd9bece7e0c1f102ac0448",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/gre_offload.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <net/protocol.h>\n#include <net/gre.h>\n#include <net/gro.h>\n#include <net/gso.h>\n\nstatic struct sk_buff *gre_gso_segment(struct sk_buff *skb,\n\t\t\t\t       netdev_features_t features)\n{\n\tint tnl_hlen = skb_inner_mac_header(skb) - skb_transport_header(skb);\n\tbool need_csum, offload_csum, gso_partial, need_ipsec;\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tu16 mac_offset = skb->mac_header;\n\t__be16 protocol = skb->protocol;\n\tu16 mac_len = skb->mac_len;\n\tint gre_offset, outer_hlen;\n\n\tif (!skb->encapsulation)\n\t\tgoto out;\n\n\tif (unlikely(tnl_hlen < sizeof(struct gre_base_hdr)))\n\t\tgoto out;\n\n\tif (unlikely(!pskb_may_pull(skb, tnl_hlen)))\n\t\tgoto out;\n\n\t \n\tskb->encapsulation = 0;\n\tSKB_GSO_CB(skb)->encap_level = 0;\n\t__skb_pull(skb, tnl_hlen);\n\tskb_reset_mac_header(skb);\n\tskb_set_network_header(skb, skb_inner_network_offset(skb));\n\tskb->mac_len = skb_inner_network_offset(skb);\n\tskb->protocol = skb->inner_protocol;\n\n\tneed_csum = !!(skb_shinfo(skb)->gso_type & SKB_GSO_GRE_CSUM);\n\tskb->encap_hdr_csum = need_csum;\n\n\tfeatures &= skb->dev->hw_enc_features;\n\tif (need_csum)\n\t\tfeatures &= ~NETIF_F_SCTP_CRC;\n\n\tneed_ipsec = skb_dst(skb) && dst_xfrm(skb_dst(skb));\n\t \n\toffload_csum = !!(need_csum && !need_ipsec &&\n\t\t\t  (skb->dev->features & NETIF_F_HW_CSUM));\n\n\t \n\tsegs = skb_mac_gso_segment(skb, features);\n\tif (IS_ERR_OR_NULL(segs)) {\n\t\tskb_gso_error_unwind(skb, protocol, tnl_hlen, mac_offset,\n\t\t\t\t     mac_len);\n\t\tgoto out;\n\t}\n\n\tgso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);\n\n\touter_hlen = skb_tnl_header_len(skb);\n\tgre_offset = outer_hlen - tnl_hlen;\n\tskb = segs;\n\tdo {\n\t\tstruct gre_base_hdr *greh;\n\t\t__sum16 *pcsum;\n\n\t\t \n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tskb_reset_inner_headers(skb);\n\t\t\tskb->encapsulation = 1;\n\t\t}\n\n\t\tskb->mac_len = mac_len;\n\t\tskb->protocol = protocol;\n\n\t\t__skb_push(skb, outer_hlen);\n\t\tskb_reset_mac_header(skb);\n\t\tskb_set_network_header(skb, mac_len);\n\t\tskb_set_transport_header(skb, gre_offset);\n\n\t\tif (!need_csum)\n\t\t\tcontinue;\n\n\t\tgreh = (struct gre_base_hdr *)skb_transport_header(skb);\n\t\tpcsum = (__sum16 *)(greh + 1);\n\n\t\tif (gso_partial && skb_is_gso(skb)) {\n\t\t\tunsigned int partial_adj;\n\n\t\t\t \n\t\t\tpartial_adj = skb->len + skb_headroom(skb) -\n\t\t\t\t      SKB_GSO_CB(skb)->data_offset -\n\t\t\t\t      skb_shinfo(skb)->gso_size;\n\t\t\t*pcsum = ~csum_fold((__force __wsum)htonl(partial_adj));\n\t\t} else {\n\t\t\t*pcsum = 0;\n\t\t}\n\n\t\t*(pcsum + 1) = 0;\n\t\tif (skb->encapsulation || !offload_csum) {\n\t\t\t*pcsum = gso_make_checksum(skb, 0);\n\t\t} else {\n\t\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\t\tskb->csum_offset = sizeof(*greh);\n\t\t}\n\t} while ((skb = skb->next));\nout:\n\treturn segs;\n}\n\nstatic struct sk_buff *gre_gro_receive(struct list_head *head,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct sk_buff *pp = NULL;\n\tstruct sk_buff *p;\n\tconst struct gre_base_hdr *greh;\n\tunsigned int hlen, grehlen;\n\tunsigned int off;\n\tint flush = 1;\n\tstruct packet_offload *ptype;\n\t__be16 type;\n\n\tif (NAPI_GRO_CB(skb)->encap_mark)\n\t\tgoto out;\n\n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\n\toff = skb_gro_offset(skb);\n\thlen = off + sizeof(*greh);\n\tgreh = skb_gro_header(skb, hlen, off);\n\tif (unlikely(!greh))\n\t\tgoto out;\n\n\t \n\tif ((greh->flags & ~(GRE_KEY|GRE_CSUM)) != 0)\n\t\tgoto out;\n\n\t \n\tif ((greh->flags & GRE_CSUM) && NAPI_GRO_CB(skb)->is_fou)\n\t\tgoto out;\n\n\ttype = greh->protocol;\n\n\tptype = gro_find_receive_by_type(type);\n\tif (!ptype)\n\t\tgoto out;\n\n\tgrehlen = GRE_HEADER_SECTION;\n\n\tif (greh->flags & GRE_KEY)\n\t\tgrehlen += GRE_HEADER_SECTION;\n\n\tif (greh->flags & GRE_CSUM)\n\t\tgrehlen += GRE_HEADER_SECTION;\n\n\thlen = off + grehlen;\n\tif (skb_gro_header_hard(skb, hlen)) {\n\t\tgreh = skb_gro_header_slow(skb, hlen, off);\n\t\tif (unlikely(!greh))\n\t\t\tgoto out;\n\t}\n\n\t \n\tif ((greh->flags & GRE_CSUM) && !NAPI_GRO_CB(skb)->flush) {\n\t\tif (skb_gro_checksum_simple_validate(skb))\n\t\t\tgoto out;\n\n\t\tskb_gro_checksum_try_convert(skb, IPPROTO_GRE,\n\t\t\t\t\t     null_compute_pseudo);\n\t}\n\n\tlist_for_each_entry(p, head, list) {\n\t\tconst struct gre_base_hdr *greh2;\n\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\t \n\t\tgreh2 = (struct gre_base_hdr *)(p->data + off);\n\n\t\tif (greh2->flags != greh->flags ||\n\t\t    greh2->protocol != greh->protocol) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (greh->flags & GRE_KEY) {\n\t\t\t \n\t\t\tif (*(__be32 *)(greh2+1) != *(__be32 *)(greh+1)) {\n\t\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tskb_gro_pull(skb, grehlen);\n\n\t \n\tskb_gro_postpull_rcsum(skb, greh, grehlen);\n\n\tpp = call_gro_receive(ptype->callbacks.gro_receive, head, skb);\n\tflush = 0;\n\nout:\n\tskb_gro_flush_final(skb, pp, flush);\n\n\treturn pp;\n}\n\nstatic int gre_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tstruct gre_base_hdr *greh = (struct gre_base_hdr *)(skb->data + nhoff);\n\tstruct packet_offload *ptype;\n\tunsigned int grehlen = sizeof(*greh);\n\tint err = -ENOENT;\n\t__be16 type;\n\n\tskb->encapsulation = 1;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_GRE;\n\n\ttype = greh->protocol;\n\tif (greh->flags & GRE_KEY)\n\t\tgrehlen += GRE_HEADER_SECTION;\n\n\tif (greh->flags & GRE_CSUM)\n\t\tgrehlen += GRE_HEADER_SECTION;\n\n\tptype = gro_find_complete_by_type(type);\n\tif (ptype)\n\t\terr = ptype->callbacks.gro_complete(skb, nhoff + grehlen);\n\n\tskb_set_inner_mac_header(skb, nhoff + grehlen);\n\n\treturn err;\n}\n\nstatic const struct net_offload gre_offload = {\n\t.callbacks = {\n\t\t.gso_segment = gre_gso_segment,\n\t\t.gro_receive = gre_gro_receive,\n\t\t.gro_complete = gre_gro_complete,\n\t},\n};\n\nstatic int __init gre_offload_init(void)\n{\n\tint err;\n\n\terr = inet_add_offload(&gre_offload, IPPROTO_GRE);\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (err)\n\t\treturn err;\n\n\terr = inet6_add_offload(&gre_offload, IPPROTO_GRE);\n\tif (err)\n\t\tinet_del_offload(&gre_offload, IPPROTO_GRE);\n#endif\n\n\treturn err;\n}\ndevice_initcall(gre_offload_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}