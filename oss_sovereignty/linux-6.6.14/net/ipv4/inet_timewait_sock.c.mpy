{
  "module_name": "inet_timewait_sock.c",
  "hash_id": "4b032f9ce6ecd13af586d531ada24a475862e5eb215b7a3242f9e4d5eda0a870",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/inet_timewait_sock.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <net/inet_hashtables.h>\n#include <net/inet_timewait_sock.h>\n#include <net/ip.h>\n\n\n \nvoid inet_twsk_bind_unhash(struct inet_timewait_sock *tw,\n\t\t\t  struct inet_hashinfo *hashinfo)\n{\n\tstruct inet_bind2_bucket *tb2 = tw->tw_tb2;\n\tstruct inet_bind_bucket *tb = tw->tw_tb;\n\n\tif (!tb)\n\t\treturn;\n\n\t__hlist_del(&tw->tw_bind_node);\n\ttw->tw_tb = NULL;\n\tinet_bind_bucket_destroy(hashinfo->bind_bucket_cachep, tb);\n\n\t__hlist_del(&tw->tw_bind2_node);\n\ttw->tw_tb2 = NULL;\n\tinet_bind2_bucket_destroy(hashinfo->bind2_bucket_cachep, tb2);\n\n\t__sock_put((struct sock *)tw);\n}\n\n \nstatic void inet_twsk_kill(struct inet_timewait_sock *tw)\n{\n\tstruct inet_hashinfo *hashinfo = tw->tw_dr->hashinfo;\n\tspinlock_t *lock = inet_ehash_lockp(hashinfo, tw->tw_hash);\n\tstruct inet_bind_hashbucket *bhead, *bhead2;\n\n\tspin_lock(lock);\n\tsk_nulls_del_node_init_rcu((struct sock *)tw);\n\tspin_unlock(lock);\n\n\t \n\tbhead = &hashinfo->bhash[inet_bhashfn(twsk_net(tw), tw->tw_num,\n\t\t\thashinfo->bhash_size)];\n\tbhead2 = inet_bhashfn_portaddr(hashinfo, (struct sock *)tw,\n\t\t\t\t       twsk_net(tw), tw->tw_num);\n\n\tspin_lock(&bhead->lock);\n\tspin_lock(&bhead2->lock);\n\tinet_twsk_bind_unhash(tw, hashinfo);\n\tspin_unlock(&bhead2->lock);\n\tspin_unlock(&bhead->lock);\n\n\trefcount_dec(&tw->tw_dr->tw_refcount);\n\tinet_twsk_put(tw);\n}\n\nvoid inet_twsk_free(struct inet_timewait_sock *tw)\n{\n\tstruct module *owner = tw->tw_prot->owner;\n\ttwsk_destructor((struct sock *)tw);\n\tkmem_cache_free(tw->tw_prot->twsk_prot->twsk_slab, tw);\n\tmodule_put(owner);\n}\n\nvoid inet_twsk_put(struct inet_timewait_sock *tw)\n{\n\tif (refcount_dec_and_test(&tw->tw_refcnt))\n\t\tinet_twsk_free(tw);\n}\nEXPORT_SYMBOL_GPL(inet_twsk_put);\n\nstatic void inet_twsk_add_node_rcu(struct inet_timewait_sock *tw,\n\t\t\t\t   struct hlist_nulls_head *list)\n{\n\thlist_nulls_add_head_rcu(&tw->tw_node, list);\n}\n\nstatic void inet_twsk_add_bind_node(struct inet_timewait_sock *tw,\n\t\t\t\t    struct hlist_head *list)\n{\n\thlist_add_head(&tw->tw_bind_node, list);\n}\n\nstatic void inet_twsk_add_bind2_node(struct inet_timewait_sock *tw,\n\t\t\t\t     struct hlist_head *list)\n{\n\thlist_add_head(&tw->tw_bind2_node, list);\n}\n\n \nvoid inet_twsk_hashdance(struct inet_timewait_sock *tw, struct sock *sk,\n\t\t\t   struct inet_hashinfo *hashinfo)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct inet_ehash_bucket *ehead = inet_ehash_bucket(hashinfo, sk->sk_hash);\n\tspinlock_t *lock = inet_ehash_lockp(hashinfo, sk->sk_hash);\n\tstruct inet_bind_hashbucket *bhead, *bhead2;\n\n\t \n\tbhead = &hashinfo->bhash[inet_bhashfn(twsk_net(tw), inet->inet_num,\n\t\t\thashinfo->bhash_size)];\n\tbhead2 = inet_bhashfn_portaddr(hashinfo, sk, twsk_net(tw), inet->inet_num);\n\n\tspin_lock(&bhead->lock);\n\tspin_lock(&bhead2->lock);\n\n\ttw->tw_tb = icsk->icsk_bind_hash;\n\tWARN_ON(!icsk->icsk_bind_hash);\n\tinet_twsk_add_bind_node(tw, &tw->tw_tb->owners);\n\n\ttw->tw_tb2 = icsk->icsk_bind2_hash;\n\tWARN_ON(!icsk->icsk_bind2_hash);\n\tinet_twsk_add_bind2_node(tw, &tw->tw_tb2->deathrow);\n\n\tspin_unlock(&bhead2->lock);\n\tspin_unlock(&bhead->lock);\n\n\tspin_lock(lock);\n\n\tinet_twsk_add_node_rcu(tw, &ehead->chain);\n\n\t \n\tif (__sk_nulls_del_node_init_rcu(sk))\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\n\tspin_unlock(lock);\n\n\t \n\trefcount_set(&tw->tw_refcnt, 3);\n}\nEXPORT_SYMBOL_GPL(inet_twsk_hashdance);\n\nstatic void tw_timer_handler(struct timer_list *t)\n{\n\tstruct inet_timewait_sock *tw = from_timer(tw, t, tw_timer);\n\n\tinet_twsk_kill(tw);\n}\n\nstruct inet_timewait_sock *inet_twsk_alloc(const struct sock *sk,\n\t\t\t\t\t   struct inet_timewait_death_row *dr,\n\t\t\t\t\t   const int state)\n{\n\tstruct inet_timewait_sock *tw;\n\n\tif (refcount_read(&dr->tw_refcount) - 1 >=\n\t    READ_ONCE(dr->sysctl_max_tw_buckets))\n\t\treturn NULL;\n\n\ttw = kmem_cache_alloc(sk->sk_prot_creator->twsk_prot->twsk_slab,\n\t\t\t      GFP_ATOMIC);\n\tif (tw) {\n\t\tconst struct inet_sock *inet = inet_sk(sk);\n\n\t\ttw->tw_dr\t    = dr;\n\t\t \n\t\ttw->tw_daddr\t    = inet->inet_daddr;\n\t\ttw->tw_rcv_saddr    = inet->inet_rcv_saddr;\n\t\ttw->tw_bound_dev_if = sk->sk_bound_dev_if;\n\t\ttw->tw_tos\t    = inet->tos;\n\t\ttw->tw_num\t    = inet->inet_num;\n\t\ttw->tw_state\t    = TCP_TIME_WAIT;\n\t\ttw->tw_substate\t    = state;\n\t\ttw->tw_sport\t    = inet->inet_sport;\n\t\ttw->tw_dport\t    = inet->inet_dport;\n\t\ttw->tw_family\t    = sk->sk_family;\n\t\ttw->tw_reuse\t    = sk->sk_reuse;\n\t\ttw->tw_reuseport    = sk->sk_reuseport;\n\t\ttw->tw_hash\t    = sk->sk_hash;\n\t\ttw->tw_ipv6only\t    = 0;\n\t\ttw->tw_transparent  = inet_test_bit(TRANSPARENT, sk);\n\t\ttw->tw_prot\t    = sk->sk_prot_creator;\n\t\tatomic64_set(&tw->tw_cookie, atomic64_read(&sk->sk_cookie));\n\t\ttwsk_net_set(tw, sock_net(sk));\n\t\ttimer_setup(&tw->tw_timer, tw_timer_handler, TIMER_PINNED);\n\t\t \n\t\trefcount_set(&tw->tw_refcnt, 0);\n\n\t\t__module_get(tw->tw_prot->owner);\n\t}\n\n\treturn tw;\n}\nEXPORT_SYMBOL_GPL(inet_twsk_alloc);\n\n \n\n \nvoid inet_twsk_deschedule_put(struct inet_timewait_sock *tw)\n{\n\tif (del_timer_sync(&tw->tw_timer))\n\t\tinet_twsk_kill(tw);\n\tinet_twsk_put(tw);\n}\nEXPORT_SYMBOL(inet_twsk_deschedule_put);\n\nvoid __inet_twsk_schedule(struct inet_timewait_sock *tw, int timeo, bool rearm)\n{\n\t \n\n\tif (!rearm) {\n\t\tbool kill = timeo <= 4*HZ;\n\n\t\t__NET_INC_STATS(twsk_net(tw), kill ? LINUX_MIB_TIMEWAITKILLED :\n\t\t\t\t\t\t     LINUX_MIB_TIMEWAITED);\n\t\tBUG_ON(mod_timer(&tw->tw_timer, jiffies + timeo));\n\t\trefcount_inc(&tw->tw_dr->tw_refcount);\n\t} else {\n\t\tmod_timer_pending(&tw->tw_timer, jiffies + timeo);\n\t}\n}\nEXPORT_SYMBOL_GPL(__inet_twsk_schedule);\n\nvoid inet_twsk_purge(struct inet_hashinfo *hashinfo, int family)\n{\n\tstruct inet_timewait_sock *tw;\n\tstruct sock *sk;\n\tstruct hlist_nulls_node *node;\n\tunsigned int slot;\n\n\tfor (slot = 0; slot <= hashinfo->ehash_mask; slot++) {\n\t\tstruct inet_ehash_bucket *head = &hashinfo->ehash[slot];\nrestart_rcu:\n\t\tcond_resched();\n\t\trcu_read_lock();\nrestart:\n\t\tsk_nulls_for_each_rcu(sk, node, &head->chain) {\n\t\t\tif (sk->sk_state != TCP_TIME_WAIT) {\n\t\t\t\t \n\t\t\t\tif (unlikely(sk->sk_state == TCP_NEW_SYN_RECV &&\n\t\t\t\t\t     hashinfo->pernet)) {\n\t\t\t\t\tstruct request_sock *req = inet_reqsk(sk);\n\n\t\t\t\t\tinet_csk_reqsk_queue_drop_and_put(req->rsk_listener, req);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttw = inet_twsk(sk);\n\t\t\tif ((tw->tw_family != family) ||\n\t\t\t\trefcount_read(&twsk_net(tw)->ns.count))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely(!refcount_inc_not_zero(&tw->tw_refcnt)))\n\t\t\t\tcontinue;\n\n\t\t\tif (unlikely((tw->tw_family != family) ||\n\t\t\t\t     refcount_read(&twsk_net(tw)->ns.count))) {\n\t\t\t\tinet_twsk_put(tw);\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\trcu_read_unlock();\n\t\t\tlocal_bh_disable();\n\t\t\tinet_twsk_deschedule_put(tw);\n\t\t\tlocal_bh_enable();\n\t\t\tgoto restart_rcu;\n\t\t}\n\t\t \n\t\tif (get_nulls_value(node) != slot)\n\t\t\tgoto restart;\n\t\trcu_read_unlock();\n\t}\n}\nEXPORT_SYMBOL_GPL(inet_twsk_purge);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}