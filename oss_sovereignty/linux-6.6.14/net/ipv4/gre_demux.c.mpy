{
  "module_name": "gre_demux.c",
  "hash_id": "3df2b8b8ef229dac48394af75a1a7934d6905eff0477a633566e038dddc6803d",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/gre_demux.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/if.h>\n#include <linux/icmp.h>\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/skbuff.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/netdevice.h>\n#include <linux/if_tunnel.h>\n#include <linux/spinlock.h>\n#include <net/protocol.h>\n#include <net/gre.h>\n#include <net/erspan.h>\n\n#include <net/icmp.h>\n#include <net/route.h>\n#include <net/xfrm.h>\n\nstatic const struct gre_protocol __rcu *gre_proto[GREPROTO_MAX] __read_mostly;\n\nint gre_add_protocol(const struct gre_protocol *proto, u8 version)\n{\n\tif (version >= GREPROTO_MAX)\n\t\treturn -EINVAL;\n\n\treturn (cmpxchg((const struct gre_protocol **)&gre_proto[version], NULL, proto) == NULL) ?\n\t\t0 : -EBUSY;\n}\nEXPORT_SYMBOL_GPL(gre_add_protocol);\n\nint gre_del_protocol(const struct gre_protocol *proto, u8 version)\n{\n\tint ret;\n\n\tif (version >= GREPROTO_MAX)\n\t\treturn -EINVAL;\n\n\tret = (cmpxchg((const struct gre_protocol **)&gre_proto[version], proto, NULL) == proto) ?\n\t\t0 : -EBUSY;\n\n\tif (ret)\n\t\treturn ret;\n\n\tsynchronize_rcu();\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gre_del_protocol);\n\n \nint gre_parse_header(struct sk_buff *skb, struct tnl_ptk_info *tpi,\n\t\t     bool *csum_err, __be16 proto, int nhs)\n{\n\tconst struct gre_base_hdr *greh;\n\t__be32 *options;\n\tint hdr_len;\n\n\tif (unlikely(!pskb_may_pull(skb, nhs + sizeof(struct gre_base_hdr))))\n\t\treturn -EINVAL;\n\n\tgreh = (struct gre_base_hdr *)(skb->data + nhs);\n\tif (unlikely(greh->flags & (GRE_VERSION | GRE_ROUTING)))\n\t\treturn -EINVAL;\n\n\ttpi->flags = gre_flags_to_tnl_flags(greh->flags);\n\thdr_len = gre_calc_hlen(tpi->flags);\n\n\tif (!pskb_may_pull(skb, nhs + hdr_len))\n\t\treturn -EINVAL;\n\n\tgreh = (struct gre_base_hdr *)(skb->data + nhs);\n\ttpi->proto = greh->protocol;\n\n\toptions = (__be32 *)(greh + 1);\n\tif (greh->flags & GRE_CSUM) {\n\t\tif (!skb_checksum_simple_validate(skb)) {\n\t\t\tskb_checksum_try_convert(skb, IPPROTO_GRE,\n\t\t\t\t\t\t null_compute_pseudo);\n\t\t} else if (csum_err) {\n\t\t\t*csum_err = true;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toptions++;\n\t}\n\n\tif (greh->flags & GRE_KEY) {\n\t\ttpi->key = *options;\n\t\toptions++;\n\t} else {\n\t\ttpi->key = 0;\n\t}\n\tif (unlikely(greh->flags & GRE_SEQ)) {\n\t\ttpi->seq = *options;\n\t\toptions++;\n\t} else {\n\t\ttpi->seq = 0;\n\t}\n\t \n\tif (greh->flags == 0 && tpi->proto == htons(ETH_P_WCCP)) {\n\t\tu8 _val, *val;\n\n\t\tval = skb_header_pointer(skb, nhs + hdr_len,\n\t\t\t\t\t sizeof(_val), &_val);\n\t\tif (!val)\n\t\t\treturn -EINVAL;\n\t\ttpi->proto = proto;\n\t\tif ((*val & 0xF0) != 0x40)\n\t\t\thdr_len += 4;\n\t}\n\ttpi->hdr_len = hdr_len;\n\n\t \n\tif ((greh->protocol == htons(ETH_P_ERSPAN) && hdr_len != 4) ||\n\t    greh->protocol == htons(ETH_P_ERSPAN2)) {\n\t\tstruct erspan_base_hdr *ershdr;\n\n\t\tif (!pskb_may_pull(skb, nhs + hdr_len + sizeof(*ershdr)))\n\t\t\treturn -EINVAL;\n\n\t\tershdr = (struct erspan_base_hdr *)(skb->data + nhs + hdr_len);\n\t\ttpi->key = cpu_to_be32(get_session_id(ershdr));\n\t}\n\n\treturn hdr_len;\n}\nEXPORT_SYMBOL(gre_parse_header);\n\nstatic int gre_rcv(struct sk_buff *skb)\n{\n\tconst struct gre_protocol *proto;\n\tu8 ver;\n\tint ret;\n\n\tif (!pskb_may_pull(skb, 12))\n\t\tgoto drop;\n\n\tver = skb->data[1]&0x7f;\n\tif (ver >= GREPROTO_MAX)\n\t\tgoto drop;\n\n\trcu_read_lock();\n\tproto = rcu_dereference(gre_proto[ver]);\n\tif (!proto || !proto->handler)\n\t\tgoto drop_unlock;\n\tret = proto->handler(skb);\n\trcu_read_unlock();\n\treturn ret;\n\ndrop_unlock:\n\trcu_read_unlock();\ndrop:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\nstatic int gre_err(struct sk_buff *skb, u32 info)\n{\n\tconst struct gre_protocol *proto;\n\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\tu8 ver = skb->data[(iph->ihl<<2) + 1]&0x7f;\n\tint err = 0;\n\n\tif (ver >= GREPROTO_MAX)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tproto = rcu_dereference(gre_proto[ver]);\n\tif (proto && proto->err_handler)\n\t\tproto->err_handler(skb, info);\n\telse\n\t\terr = -EPROTONOSUPPORT;\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic const struct net_protocol net_gre_protocol = {\n\t.handler     = gre_rcv,\n\t.err_handler = gre_err,\n};\n\nstatic int __init gre_init(void)\n{\n\tpr_info(\"GRE over IPv4 demultiplexor driver\\n\");\n\n\tif (inet_add_protocol(&net_gre_protocol, IPPROTO_GRE) < 0) {\n\t\tpr_err(\"can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic void __exit gre_exit(void)\n{\n\tinet_del_protocol(&net_gre_protocol, IPPROTO_GRE);\n}\n\nmodule_init(gre_init);\nmodule_exit(gre_exit);\n\nMODULE_DESCRIPTION(\"GRE over IPv4 demultiplexer driver\");\nMODULE_AUTHOR(\"D. Kozlov (xeb@mail.ru)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}