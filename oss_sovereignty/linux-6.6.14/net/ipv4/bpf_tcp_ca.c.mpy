{
  "module_name": "bpf_tcp_ca.c",
  "hash_id": "94eb6bb99370ff17f77fb86dda99a992efb41681987ea6202fffc2928a997ba1",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/bpf_tcp_ca.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n#include <linux/btf.h>\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <net/tcp.h>\n#include <net/bpf_sk_storage.h>\n\n \nextern struct bpf_struct_ops bpf_tcp_congestion_ops;\n\nstatic u32 unsupported_ops[] = {\n\toffsetof(struct tcp_congestion_ops, get_info),\n};\n\nstatic const struct btf_type *tcp_sock_type;\nstatic u32 tcp_sock_id, sock_id;\n\nstatic int bpf_tcp_ca_init(struct btf *btf)\n{\n\ts32 type_id;\n\n\ttype_id = btf_find_by_name_kind(btf, \"sock\", BTF_KIND_STRUCT);\n\tif (type_id < 0)\n\t\treturn -EINVAL;\n\tsock_id = type_id;\n\n\ttype_id = btf_find_by_name_kind(btf, \"tcp_sock\", BTF_KIND_STRUCT);\n\tif (type_id < 0)\n\t\treturn -EINVAL;\n\ttcp_sock_id = type_id;\n\ttcp_sock_type = btf_type_by_id(btf, tcp_sock_id);\n\n\treturn 0;\n}\n\nstatic bool is_unsupported(u32 member_offset)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(unsupported_ops); i++) {\n\t\tif (member_offset == unsupported_ops[i])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool bpf_tcp_ca_is_valid_access(int off, int size,\n\t\t\t\t       enum bpf_access_type type,\n\t\t\t\t       const struct bpf_prog *prog,\n\t\t\t\t       struct bpf_insn_access_aux *info)\n{\n\tif (!bpf_tracing_btf_ctx_access(off, size, type, prog, info))\n\t\treturn false;\n\n\tif (base_type(info->reg_type) == PTR_TO_BTF_ID &&\n\t    !bpf_type_has_unsafe_modifiers(info->reg_type) &&\n\t    info->btf_id == sock_id)\n\t\t \n\t\tinfo->btf_id = tcp_sock_id;\n\n\treturn true;\n}\n\nstatic int bpf_tcp_ca_btf_struct_access(struct bpf_verifier_log *log,\n\t\t\t\t\tconst struct bpf_reg_state *reg,\n\t\t\t\t\tint off, int size)\n{\n\tconst struct btf_type *t;\n\tsize_t end;\n\n\tt = btf_type_by_id(reg->btf, reg->btf_id);\n\tif (t != tcp_sock_type) {\n\t\tbpf_log(log, \"only read is supported\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tswitch (off) {\n\tcase offsetof(struct sock, sk_pacing_rate):\n\t\tend = offsetofend(struct sock, sk_pacing_rate);\n\t\tbreak;\n\tcase offsetof(struct sock, sk_pacing_status):\n\t\tend = offsetofend(struct sock, sk_pacing_status);\n\t\tbreak;\n\tcase bpf_ctx_range(struct inet_connection_sock, icsk_ca_priv):\n\t\tend = offsetofend(struct inet_connection_sock, icsk_ca_priv);\n\t\tbreak;\n\tcase offsetof(struct inet_connection_sock, icsk_ack.pending):\n\t\tend = offsetofend(struct inet_connection_sock,\n\t\t\t\t  icsk_ack.pending);\n\t\tbreak;\n\tcase offsetof(struct tcp_sock, snd_cwnd):\n\t\tend = offsetofend(struct tcp_sock, snd_cwnd);\n\t\tbreak;\n\tcase offsetof(struct tcp_sock, snd_cwnd_cnt):\n\t\tend = offsetofend(struct tcp_sock, snd_cwnd_cnt);\n\t\tbreak;\n\tcase offsetof(struct tcp_sock, snd_ssthresh):\n\t\tend = offsetofend(struct tcp_sock, snd_ssthresh);\n\t\tbreak;\n\tcase offsetof(struct tcp_sock, ecn_flags):\n\t\tend = offsetofend(struct tcp_sock, ecn_flags);\n\t\tbreak;\n\tcase offsetof(struct tcp_sock, app_limited):\n\t\tend = offsetofend(struct tcp_sock, app_limited);\n\t\tbreak;\n\tdefault:\n\t\tbpf_log(log, \"no write support to tcp_sock at off %d\\n\", off);\n\t\treturn -EACCES;\n\t}\n\n\tif (off + size > end) {\n\t\tbpf_log(log,\n\t\t\t\"write access at off %d with size %d beyond the member of tcp_sock ended at %zu\\n\",\n\t\t\toff, size, end);\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\nBPF_CALL_2(bpf_tcp_send_ack, struct tcp_sock *, tp, u32, rcv_nxt)\n{\n\t \n\t__tcp_send_ack((struct sock *)tp, rcv_nxt);\n\treturn 0;\n}\n\nstatic const struct bpf_func_proto bpf_tcp_send_ack_proto = {\n\t.func\t\t= bpf_tcp_send_ack,\n\t.gpl_only\t= false,\n\t \n\t.ret_type\t= RET_INTEGER,\n\t.arg1_type\t= ARG_PTR_TO_BTF_ID,\n\t.arg1_btf_id\t= &tcp_sock_id,\n\t.arg2_type\t= ARG_ANYTHING,\n};\n\nstatic u32 prog_ops_moff(const struct bpf_prog *prog)\n{\n\tconst struct btf_member *m;\n\tconst struct btf_type *t;\n\tu32 midx;\n\n\tmidx = prog->expected_attach_type;\n\tt = bpf_tcp_congestion_ops.type;\n\tm = &btf_type_member(t)[midx];\n\n\treturn __btf_member_bit_offset(t, m) / 8;\n}\n\nstatic const struct bpf_func_proto *\nbpf_tcp_ca_get_func_proto(enum bpf_func_id func_id,\n\t\t\t  const struct bpf_prog *prog)\n{\n\tswitch (func_id) {\n\tcase BPF_FUNC_tcp_send_ack:\n\t\treturn &bpf_tcp_send_ack_proto;\n\tcase BPF_FUNC_sk_storage_get:\n\t\treturn &bpf_sk_storage_get_proto;\n\tcase BPF_FUNC_sk_storage_delete:\n\t\treturn &bpf_sk_storage_delete_proto;\n\tcase BPF_FUNC_setsockopt:\n\t\t \n\t\tif (prog_ops_moff(prog) !=\n\t\t    offsetof(struct tcp_congestion_ops, release))\n\t\t\treturn &bpf_sk_setsockopt_proto;\n\t\treturn NULL;\n\tcase BPF_FUNC_getsockopt:\n\t\t \n\t\tif (prog_ops_moff(prog) !=\n\t\t    offsetof(struct tcp_congestion_ops, release))\n\t\t\treturn &bpf_sk_getsockopt_proto;\n\t\treturn NULL;\n\tcase BPF_FUNC_ktime_get_coarse_ns:\n\t\treturn &bpf_ktime_get_coarse_ns_proto;\n\tdefault:\n\t\treturn bpf_base_func_proto(func_id);\n\t}\n}\n\nBTF_SET8_START(bpf_tcp_ca_check_kfunc_ids)\nBTF_ID_FLAGS(func, tcp_reno_ssthresh)\nBTF_ID_FLAGS(func, tcp_reno_cong_avoid)\nBTF_ID_FLAGS(func, tcp_reno_undo_cwnd)\nBTF_ID_FLAGS(func, tcp_slow_start)\nBTF_ID_FLAGS(func, tcp_cong_avoid_ai)\nBTF_SET8_END(bpf_tcp_ca_check_kfunc_ids)\n\nstatic const struct btf_kfunc_id_set bpf_tcp_ca_kfunc_set = {\n\t.owner = THIS_MODULE,\n\t.set   = &bpf_tcp_ca_check_kfunc_ids,\n};\n\nstatic const struct bpf_verifier_ops bpf_tcp_ca_verifier_ops = {\n\t.get_func_proto\t\t= bpf_tcp_ca_get_func_proto,\n\t.is_valid_access\t= bpf_tcp_ca_is_valid_access,\n\t.btf_struct_access\t= bpf_tcp_ca_btf_struct_access,\n};\n\nstatic int bpf_tcp_ca_init_member(const struct btf_type *t,\n\t\t\t\t  const struct btf_member *member,\n\t\t\t\t  void *kdata, const void *udata)\n{\n\tconst struct tcp_congestion_ops *utcp_ca;\n\tstruct tcp_congestion_ops *tcp_ca;\n\tu32 moff;\n\n\tutcp_ca = (const struct tcp_congestion_ops *)udata;\n\ttcp_ca = (struct tcp_congestion_ops *)kdata;\n\n\tmoff = __btf_member_bit_offset(t, member) / 8;\n\tswitch (moff) {\n\tcase offsetof(struct tcp_congestion_ops, flags):\n\t\tif (utcp_ca->flags & ~TCP_CONG_MASK)\n\t\t\treturn -EINVAL;\n\t\ttcp_ca->flags = utcp_ca->flags;\n\t\treturn 1;\n\tcase offsetof(struct tcp_congestion_ops, name):\n\t\tif (bpf_obj_name_cpy(tcp_ca->name, utcp_ca->name,\n\t\t\t\t     sizeof(tcp_ca->name)) <= 0)\n\t\t\treturn -EINVAL;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int bpf_tcp_ca_check_member(const struct btf_type *t,\n\t\t\t\t   const struct btf_member *member,\n\t\t\t\t   const struct bpf_prog *prog)\n{\n\tif (is_unsupported(__btf_member_bit_offset(t, member) / 8))\n\t\treturn -ENOTSUPP;\n\treturn 0;\n}\n\nstatic int bpf_tcp_ca_reg(void *kdata)\n{\n\treturn tcp_register_congestion_control(kdata);\n}\n\nstatic void bpf_tcp_ca_unreg(void *kdata)\n{\n\ttcp_unregister_congestion_control(kdata);\n}\n\nstatic int bpf_tcp_ca_update(void *kdata, void *old_kdata)\n{\n\treturn tcp_update_congestion_control(kdata, old_kdata);\n}\n\nstatic int bpf_tcp_ca_validate(void *kdata)\n{\n\treturn tcp_validate_congestion_control(kdata);\n}\n\nstruct bpf_struct_ops bpf_tcp_congestion_ops = {\n\t.verifier_ops = &bpf_tcp_ca_verifier_ops,\n\t.reg = bpf_tcp_ca_reg,\n\t.unreg = bpf_tcp_ca_unreg,\n\t.update = bpf_tcp_ca_update,\n\t.check_member = bpf_tcp_ca_check_member,\n\t.init_member = bpf_tcp_ca_init_member,\n\t.init = bpf_tcp_ca_init,\n\t.validate = bpf_tcp_ca_validate,\n\t.name = \"tcp_congestion_ops\",\n};\n\nstatic int __init bpf_tcp_ca_kfunc_init(void)\n{\n\treturn register_btf_kfunc_id_set(BPF_PROG_TYPE_STRUCT_OPS, &bpf_tcp_ca_kfunc_set);\n}\nlate_initcall(bpf_tcp_ca_kfunc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}