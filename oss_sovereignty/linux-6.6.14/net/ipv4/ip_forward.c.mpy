{
  "module_name": "ip_forward.c",
  "hash_id": "30a74b0a9120ea4a1c04e4cb2a3bb63e9c733a74e3357c68a44ad498dcdaac26",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ip_forward.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/icmp.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/icmp.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/netfilter_ipv4.h>\n#include <net/checksum.h>\n#include <linux/route.h>\n#include <net/route.h>\n#include <net/xfrm.h>\n\nstatic bool ip_exceeds_mtu(const struct sk_buff *skb, unsigned int mtu)\n{\n\tif (skb->len <= mtu)\n\t\treturn false;\n\n\tif (unlikely((ip_hdr(skb)->frag_off & htons(IP_DF)) == 0))\n\t\treturn false;\n\n\t \n\tif (unlikely(IPCB(skb)->frag_max_size > mtu))\n\t\treturn true;\n\n\tif (skb->ignore_df)\n\t\treturn false;\n\n\tif (skb_is_gso(skb) && skb_gso_validate_network_len(skb, mtu))\n\t\treturn false;\n\n\treturn true;\n}\n\n\nstatic int ip_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ip_options *opt\t= &(IPCB(skb)->opt);\n\n\t__IP_INC_STATS(net, IPSTATS_MIB_OUTFORWDATAGRAMS);\n\n#ifdef CONFIG_NET_SWITCHDEV\n\tif (skb->offload_l3_fwd_mark) {\n\t\tconsume_skb(skb);\n\t\treturn 0;\n\t}\n#endif\n\n\tif (unlikely(opt->optlen))\n\t\tip_forward_options(skb);\n\n\tskb_clear_tstamp(skb);\n\treturn dst_output(net, sk, skb);\n}\n\nint ip_forward(struct sk_buff *skb)\n{\n\tu32 mtu;\n\tstruct iphdr *iph;\t \n\tstruct rtable *rt;\t \n\tstruct ip_options *opt\t= &(IPCB(skb)->opt);\n\tstruct net *net;\n\tSKB_DR(reason);\n\n\t \n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto drop;\n\n\tif (unlikely(skb->sk))\n\t\tgoto drop;\n\n\tif (skb_warn_if_lro(skb))\n\t\tgoto drop;\n\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_FWD, skb)) {\n\t\tSKB_DR_SET(reason, XFRM_POLICY);\n\t\tgoto drop;\n\t}\n\n\tif (IPCB(skb)->opt.router_alert && ip_call_ra_chain(skb))\n\t\treturn NET_RX_SUCCESS;\n\n\tskb_forward_csum(skb);\n\tnet = dev_net(skb->dev);\n\n\t \n\tif (ip_hdr(skb)->ttl <= 1)\n\t\tgoto too_many_hops;\n\n\tif (!xfrm4_route_forward(skb)) {\n\t\tSKB_DR_SET(reason, XFRM_POLICY);\n\t\tgoto drop;\n\t}\n\n\trt = skb_rtable(skb);\n\n\tif (opt->is_strictroute && rt->rt_uses_gateway)\n\t\tgoto sr_failed;\n\n\tIPCB(skb)->flags |= IPSKB_FORWARDED;\n\tmtu = ip_dst_mtu_maybe_forward(&rt->dst, true);\n\tif (ip_exceeds_mtu(skb, mtu)) {\n\t\tIP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);\n\t\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\n\t\t\t  htonl(mtu));\n\t\tSKB_DR_SET(reason, PKT_TOO_BIG);\n\t\tgoto drop;\n\t}\n\n\t \n\tif (skb_cow(skb, LL_RESERVED_SPACE(rt->dst.dev)+rt->dst.header_len))\n\t\tgoto drop;\n\tiph = ip_hdr(skb);\n\n\t \n\tip_decrease_ttl(iph);\n\n\t \n\tif (IPCB(skb)->flags & IPSKB_DOREDIRECT && !opt->srr &&\n\t    !skb_sec_path(skb))\n\t\tip_rt_send_redirect(skb);\n\n\tif (READ_ONCE(net->ipv4.sysctl_ip_fwd_update_priority))\n\t\tskb->priority = rt_tos2priority(iph->tos);\n\n\treturn NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD,\n\t\t       net, NULL, skb, skb->dev, rt->dst.dev,\n\t\t       ip_forward_finish);\n\nsr_failed:\n\t \n\t icmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, 0);\n\t goto drop;\n\ntoo_many_hops:\n\t \n\t__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);\n\ticmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0);\n\tSKB_DR_SET(reason, IP_INHDR);\ndrop:\n\tkfree_skb_reason(skb, reason);\n\treturn NET_RX_DROP;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}