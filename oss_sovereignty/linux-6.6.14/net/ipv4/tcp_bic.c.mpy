{
  "module_name": "tcp_bic.c",
  "hash_id": "71c3d2527fb614eeb8b20b02aab9fcaf12f03831245a12fd5e4bf13b914472ff",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_bic.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <net/tcp.h>\n\n#define BICTCP_BETA_SCALE    1024\t \n#define BICTCP_B\t\t4\t  \n\nstatic int fast_convergence = 1;\nstatic int max_increment = 16;\nstatic int low_window = 14;\nstatic int beta = 819;\t\t \nstatic int initial_ssthresh;\nstatic int smooth_part = 20;\n\nmodule_param(fast_convergence, int, 0644);\nMODULE_PARM_DESC(fast_convergence, \"turn on/off fast convergence\");\nmodule_param(max_increment, int, 0644);\nMODULE_PARM_DESC(max_increment, \"Limit on increment allowed during binary search\");\nmodule_param(low_window, int, 0644);\nMODULE_PARM_DESC(low_window, \"lower bound on congestion window (for TCP friendliness)\");\nmodule_param(beta, int, 0644);\nMODULE_PARM_DESC(beta, \"beta for multiplicative increase\");\nmodule_param(initial_ssthresh, int, 0644);\nMODULE_PARM_DESC(initial_ssthresh, \"initial value of slow start threshold\");\nmodule_param(smooth_part, int, 0644);\nMODULE_PARM_DESC(smooth_part, \"log(B/(B*Smin))/log(B/(B-1))+B, # of RTT from Wmax-B to Wmax\");\n\n \nstruct bictcp {\n\tu32\tcnt;\t\t \n\tu32\tlast_max_cwnd;\t \n\tu32\tlast_cwnd;\t \n\tu32\tlast_time;\t \n\tu32\tepoch_start;\t \n#define ACK_RATIO_SHIFT\t4\n\tu32\tdelayed_ack;\t \n};\n\nstatic inline void bictcp_reset(struct bictcp *ca)\n{\n\tca->cnt = 0;\n\tca->last_max_cwnd = 0;\n\tca->last_cwnd = 0;\n\tca->last_time = 0;\n\tca->epoch_start = 0;\n\tca->delayed_ack = 2 << ACK_RATIO_SHIFT;\n}\n\nstatic void bictcp_init(struct sock *sk)\n{\n\tstruct bictcp *ca = inet_csk_ca(sk);\n\n\tbictcp_reset(ca);\n\n\tif (initial_ssthresh)\n\t\ttcp_sk(sk)->snd_ssthresh = initial_ssthresh;\n}\n\n \nstatic inline void bictcp_update(struct bictcp *ca, u32 cwnd)\n{\n\tif (ca->last_cwnd == cwnd &&\n\t    (s32)(tcp_jiffies32 - ca->last_time) <= HZ / 32)\n\t\treturn;\n\n\tca->last_cwnd = cwnd;\n\tca->last_time = tcp_jiffies32;\n\n\tif (ca->epoch_start == 0)  \n\t\tca->epoch_start = tcp_jiffies32;\n\n\t \n\tif (cwnd <= low_window) {\n\t\tca->cnt = cwnd;\n\t\treturn;\n\t}\n\n\t \n\tif (cwnd < ca->last_max_cwnd) {\n\t\t__u32\tdist = (ca->last_max_cwnd - cwnd)\n\t\t\t/ BICTCP_B;\n\n\t\tif (dist > max_increment)\n\t\t\t \n\t\t\tca->cnt = cwnd / max_increment;\n\t\telse if (dist <= 1U)\n\t\t\t \n\t\t\tca->cnt = (cwnd * smooth_part) / BICTCP_B;\n\t\telse\n\t\t\t \n\t\t\tca->cnt = cwnd / dist;\n\t} else {\n\t\t \n\t\tif (cwnd < ca->last_max_cwnd + BICTCP_B)\n\t\t\t \n\t\t\tca->cnt = (cwnd * smooth_part) / BICTCP_B;\n\t\telse if (cwnd < ca->last_max_cwnd + max_increment*(BICTCP_B-1))\n\t\t\t \n\t\t\tca->cnt = (cwnd * (BICTCP_B-1))\n\t\t\t\t/ (cwnd - ca->last_max_cwnd);\n\t\telse\n\t\t\t \n\t\t\tca->cnt = cwnd / max_increment;\n\t}\n\n\t \n\tif (ca->last_max_cwnd == 0) {\n\t\tif (ca->cnt > 20)  \n\t\t\tca->cnt = 20;\n\t}\n\n\tca->cnt = (ca->cnt << ACK_RATIO_SHIFT) / ca->delayed_ack;\n\tif (ca->cnt == 0)\t\t\t \n\t\tca->cnt = 1;\n}\n\nstatic void bictcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct bictcp *ca = inet_csk_ca(sk);\n\n\tif (!tcp_is_cwnd_limited(sk))\n\t\treturn;\n\n\tif (tcp_in_slow_start(tp)) {\n\t\tacked = tcp_slow_start(tp, acked);\n\t\tif (!acked)\n\t\t\treturn;\n\t}\n\tbictcp_update(ca, tcp_snd_cwnd(tp));\n\ttcp_cong_avoid_ai(tp, ca->cnt, acked);\n}\n\n \nstatic u32 bictcp_recalc_ssthresh(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct bictcp *ca = inet_csk_ca(sk);\n\n\tca->epoch_start = 0;\t \n\n\t \n\tif (tcp_snd_cwnd(tp) < ca->last_max_cwnd && fast_convergence)\n\t\tca->last_max_cwnd = (tcp_snd_cwnd(tp) * (BICTCP_BETA_SCALE + beta))\n\t\t\t/ (2 * BICTCP_BETA_SCALE);\n\telse\n\t\tca->last_max_cwnd = tcp_snd_cwnd(tp);\n\n\tif (tcp_snd_cwnd(tp) <= low_window)\n\t\treturn max(tcp_snd_cwnd(tp) >> 1U, 2U);\n\telse\n\t\treturn max((tcp_snd_cwnd(tp) * beta) / BICTCP_BETA_SCALE, 2U);\n}\n\nstatic void bictcp_state(struct sock *sk, u8 new_state)\n{\n\tif (new_state == TCP_CA_Loss)\n\t\tbictcp_reset(inet_csk_ca(sk));\n}\n\n \nstatic void bictcp_acked(struct sock *sk, const struct ack_sample *sample)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\n\tif (icsk->icsk_ca_state == TCP_CA_Open) {\n\t\tstruct bictcp *ca = inet_csk_ca(sk);\n\n\t\tca->delayed_ack += sample->pkts_acked -\n\t\t\t(ca->delayed_ack >> ACK_RATIO_SHIFT);\n\t}\n}\n\nstatic struct tcp_congestion_ops bictcp __read_mostly = {\n\t.init\t\t= bictcp_init,\n\t.ssthresh\t= bictcp_recalc_ssthresh,\n\t.cong_avoid\t= bictcp_cong_avoid,\n\t.set_state\t= bictcp_state,\n\t.undo_cwnd\t= tcp_reno_undo_cwnd,\n\t.pkts_acked     = bictcp_acked,\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bic\",\n};\n\nstatic int __init bictcp_register(void)\n{\n\tBUILD_BUG_ON(sizeof(struct bictcp) > ICSK_CA_PRIV_SIZE);\n\treturn tcp_register_congestion_control(&bictcp);\n}\n\nstatic void __exit bictcp_unregister(void)\n{\n\ttcp_unregister_congestion_control(&bictcp);\n}\n\nmodule_init(bictcp_register);\nmodule_exit(bictcp_unregister);\n\nMODULE_AUTHOR(\"Stephen Hemminger\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"BIC TCP\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}