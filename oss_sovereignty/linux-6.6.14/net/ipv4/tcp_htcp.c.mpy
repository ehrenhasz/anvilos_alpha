{
  "module_name": "tcp_htcp.c",
  "hash_id": "5349aaa247e78c092b805ff18393d2a2dd4626e2467306b3df7c10809ccd5185",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_htcp.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <net/tcp.h>\n\n#define ALPHA_BASE\t(1<<7)\t \n#define BETA_MIN\t(1<<6)\t \n#define BETA_MAX\t102\t \n\nstatic int use_rtt_scaling __read_mostly = 1;\nmodule_param(use_rtt_scaling, int, 0644);\nMODULE_PARM_DESC(use_rtt_scaling, \"turn on/off RTT scaling\");\n\nstatic int use_bandwidth_switch __read_mostly = 1;\nmodule_param(use_bandwidth_switch, int, 0644);\nMODULE_PARM_DESC(use_bandwidth_switch, \"turn on/off bandwidth switcher\");\n\nstruct htcp {\n\tu32\talpha;\t\t \n\tu8\tbeta;            \n\tu8\tmodeswitch;\t \n\tu16\tpkts_acked;\n\tu32\tpacketcount;\n\tu32\tminRTT;\n\tu32\tmaxRTT;\n\tu32\tlast_cong;\t \n\tu32\tundo_last_cong;\n\n\tu32\tundo_maxRTT;\n\tu32\tundo_old_maxB;\n\n\t \n\tu32\tminB;\n\tu32\tmaxB;\n\tu32\told_maxB;\n\tu32\tBi;\n\tu32\tlasttime;\n};\n\nstatic inline u32 htcp_cong_time(const struct htcp *ca)\n{\n\treturn jiffies - ca->last_cong;\n}\n\nstatic inline u32 htcp_ccount(const struct htcp *ca)\n{\n\treturn htcp_cong_time(ca) / ca->minRTT;\n}\n\nstatic inline void htcp_reset(struct htcp *ca)\n{\n\tca->undo_last_cong = ca->last_cong;\n\tca->undo_maxRTT = ca->maxRTT;\n\tca->undo_old_maxB = ca->old_maxB;\n\n\tca->last_cong = jiffies;\n}\n\nstatic u32 htcp_cwnd_undo(struct sock *sk)\n{\n\tstruct htcp *ca = inet_csk_ca(sk);\n\n\tif (ca->undo_last_cong) {\n\t\tca->last_cong = ca->undo_last_cong;\n\t\tca->maxRTT = ca->undo_maxRTT;\n\t\tca->old_maxB = ca->undo_old_maxB;\n\t\tca->undo_last_cong = 0;\n\t}\n\n\treturn tcp_reno_undo_cwnd(sk);\n}\n\nstatic inline void measure_rtt(struct sock *sk, u32 srtt)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct htcp *ca = inet_csk_ca(sk);\n\n\t \n\tif (ca->minRTT > srtt || !ca->minRTT)\n\t\tca->minRTT = srtt;\n\n\t \n\tif (icsk->icsk_ca_state == TCP_CA_Open) {\n\t\tif (ca->maxRTT < ca->minRTT)\n\t\t\tca->maxRTT = ca->minRTT;\n\t\tif (ca->maxRTT < srtt &&\n\t\t    srtt <= ca->maxRTT + msecs_to_jiffies(20))\n\t\t\tca->maxRTT = srtt;\n\t}\n}\n\nstatic void measure_achieved_throughput(struct sock *sk,\n\t\t\t\t\tconst struct ack_sample *sample)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct htcp *ca = inet_csk_ca(sk);\n\tu32 now = tcp_jiffies32;\n\n\tif (icsk->icsk_ca_state == TCP_CA_Open)\n\t\tca->pkts_acked = sample->pkts_acked;\n\n\tif (sample->rtt_us > 0)\n\t\tmeasure_rtt(sk, usecs_to_jiffies(sample->rtt_us));\n\n\tif (!use_bandwidth_switch)\n\t\treturn;\n\n\t \n\tif (!((1 << icsk->icsk_ca_state) & (TCPF_CA_Open | TCPF_CA_Disorder))) {\n\t\tca->packetcount = 0;\n\t\tca->lasttime = now;\n\t\treturn;\n\t}\n\n\tca->packetcount += sample->pkts_acked;\n\n\tif (ca->packetcount >= tcp_snd_cwnd(tp) - (ca->alpha >> 7 ? : 1) &&\n\t    now - ca->lasttime >= ca->minRTT &&\n\t    ca->minRTT > 0) {\n\t\t__u32 cur_Bi = ca->packetcount * HZ / (now - ca->lasttime);\n\n\t\tif (htcp_ccount(ca) <= 3) {\n\t\t\t \n\t\t\tca->minB = ca->maxB = ca->Bi = cur_Bi;\n\t\t} else {\n\t\t\tca->Bi = (3 * ca->Bi + cur_Bi) / 4;\n\t\t\tif (ca->Bi > ca->maxB)\n\t\t\t\tca->maxB = ca->Bi;\n\t\t\tif (ca->minB > ca->maxB)\n\t\t\t\tca->minB = ca->maxB;\n\t\t}\n\t\tca->packetcount = 0;\n\t\tca->lasttime = now;\n\t}\n}\n\nstatic inline void htcp_beta_update(struct htcp *ca, u32 minRTT, u32 maxRTT)\n{\n\tif (use_bandwidth_switch) {\n\t\tu32 maxB = ca->maxB;\n\t\tu32 old_maxB = ca->old_maxB;\n\n\t\tca->old_maxB = ca->maxB;\n\t\tif (!between(5 * maxB, 4 * old_maxB, 6 * old_maxB)) {\n\t\t\tca->beta = BETA_MIN;\n\t\t\tca->modeswitch = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ca->modeswitch && minRTT > msecs_to_jiffies(10) && maxRTT) {\n\t\tca->beta = (minRTT << 7) / maxRTT;\n\t\tif (ca->beta < BETA_MIN)\n\t\t\tca->beta = BETA_MIN;\n\t\telse if (ca->beta > BETA_MAX)\n\t\t\tca->beta = BETA_MAX;\n\t} else {\n\t\tca->beta = BETA_MIN;\n\t\tca->modeswitch = 1;\n\t}\n}\n\nstatic inline void htcp_alpha_update(struct htcp *ca)\n{\n\tu32 minRTT = ca->minRTT;\n\tu32 factor = 1;\n\tu32 diff = htcp_cong_time(ca);\n\n\tif (diff > HZ) {\n\t\tdiff -= HZ;\n\t\tfactor = 1 + (10 * diff + ((diff / 2) * (diff / 2) / HZ)) / HZ;\n\t}\n\n\tif (use_rtt_scaling && minRTT) {\n\t\tu32 scale = (HZ << 3) / (10 * minRTT);\n\n\t\t \n\t\tscale = min(max(scale, 1U << 2), 10U << 3);\n\t\tfactor = (factor << 3) / scale;\n\t\tif (!factor)\n\t\t\tfactor = 1;\n\t}\n\n\tca->alpha = 2 * factor * ((1 << 7) - ca->beta);\n\tif (!ca->alpha)\n\t\tca->alpha = ALPHA_BASE;\n}\n\n \nstatic void htcp_param_update(struct sock *sk)\n{\n\tstruct htcp *ca = inet_csk_ca(sk);\n\tu32 minRTT = ca->minRTT;\n\tu32 maxRTT = ca->maxRTT;\n\n\thtcp_beta_update(ca, minRTT, maxRTT);\n\thtcp_alpha_update(ca);\n\n\t \n\tif (minRTT > 0 && maxRTT > minRTT)\n\t\tca->maxRTT = minRTT + ((maxRTT - minRTT) * 95) / 100;\n}\n\nstatic u32 htcp_recalc_ssthresh(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct htcp *ca = inet_csk_ca(sk);\n\n\thtcp_param_update(sk);\n\treturn max((tcp_snd_cwnd(tp) * ca->beta) >> 7, 2U);\n}\n\nstatic void htcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct htcp *ca = inet_csk_ca(sk);\n\n\tif (!tcp_is_cwnd_limited(sk))\n\t\treturn;\n\n\tif (tcp_in_slow_start(tp))\n\t\ttcp_slow_start(tp, acked);\n\telse {\n\t\t \n\t\tif ((tp->snd_cwnd_cnt * ca->alpha)>>7 >= tcp_snd_cwnd(tp)) {\n\t\t\tif (tcp_snd_cwnd(tp) < tp->snd_cwnd_clamp)\n\t\t\t\ttcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) + 1);\n\t\t\ttp->snd_cwnd_cnt = 0;\n\t\t\thtcp_alpha_update(ca);\n\t\t} else\n\t\t\ttp->snd_cwnd_cnt += ca->pkts_acked;\n\n\t\tca->pkts_acked = 1;\n\t}\n}\n\nstatic void htcp_init(struct sock *sk)\n{\n\tstruct htcp *ca = inet_csk_ca(sk);\n\n\tmemset(ca, 0, sizeof(struct htcp));\n\tca->alpha = ALPHA_BASE;\n\tca->beta = BETA_MIN;\n\tca->pkts_acked = 1;\n\tca->last_cong = jiffies;\n}\n\nstatic void htcp_state(struct sock *sk, u8 new_state)\n{\n\tswitch (new_state) {\n\tcase TCP_CA_Open:\n\t\t{\n\t\t\tstruct htcp *ca = inet_csk_ca(sk);\n\n\t\t\tif (ca->undo_last_cong) {\n\t\t\t\tca->last_cong = jiffies;\n\t\t\t\tca->undo_last_cong = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase TCP_CA_CWR:\n\tcase TCP_CA_Recovery:\n\tcase TCP_CA_Loss:\n\t\thtcp_reset(inet_csk_ca(sk));\n\t\tbreak;\n\t}\n}\n\nstatic struct tcp_congestion_ops htcp __read_mostly = {\n\t.init\t\t= htcp_init,\n\t.ssthresh\t= htcp_recalc_ssthresh,\n\t.cong_avoid\t= htcp_cong_avoid,\n\t.set_state\t= htcp_state,\n\t.undo_cwnd\t= htcp_cwnd_undo,\n\t.pkts_acked\t= measure_achieved_throughput,\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"htcp\",\n};\n\nstatic int __init htcp_register(void)\n{\n\tBUILD_BUG_ON(sizeof(struct htcp) > ICSK_CA_PRIV_SIZE);\n\tBUILD_BUG_ON(BETA_MIN >= BETA_MAX);\n\treturn tcp_register_congestion_control(&htcp);\n}\n\nstatic void __exit htcp_unregister(void)\n{\n\ttcp_unregister_congestion_control(&htcp);\n}\n\nmodule_init(htcp_register);\nmodule_exit(htcp_unregister);\n\nMODULE_AUTHOR(\"Baruch Even\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"H-TCP\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}