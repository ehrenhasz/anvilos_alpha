{
  "module_name": "syncookies.c",
  "hash_id": "95ed9e645fc79c27471219acaf826f1d5f4aea87df63ba0ac55b351be755fcda",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/syncookies.c",
  "human_readable_source": "\n \n\n#include <linux/tcp.h>\n#include <linux/siphash.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <net/secure_seq.h>\n#include <net/tcp.h>\n#include <net/route.h>\n\nstatic siphash_aligned_key_t syncookie_secret[2];\n\n#define COOKIEBITS 24\t \n#define COOKIEMASK (((__u32)1 << COOKIEBITS) - 1)\n\n \n#define TS_OPT_WSCALE_MASK\t0xf\n#define TS_OPT_SACK\t\tBIT(4)\n#define TS_OPT_ECN\t\tBIT(5)\n \n#define TSBITS\t6\n\nstatic u32 cookie_hash(__be32 saddr, __be32 daddr, __be16 sport, __be16 dport,\n\t\t       u32 count, int c)\n{\n\tnet_get_random_once(syncookie_secret, sizeof(syncookie_secret));\n\treturn siphash_4u32((__force u32)saddr, (__force u32)daddr,\n\t\t\t    (__force u32)sport << 16 | (__force u32)dport,\n\t\t\t    count, &syncookie_secret[c]);\n}\n\n\n \nu64 cookie_init_timestamp(struct request_sock *req, u64 now)\n{\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tu64 ts, ts_now = tcp_ns_to_ts(now);\n\tu32 options = 0;\n\n\toptions = ireq->wscale_ok ? ireq->snd_wscale : TS_OPT_WSCALE_MASK;\n\tif (ireq->sack_ok)\n\t\toptions |= TS_OPT_SACK;\n\tif (ireq->ecn_ok)\n\t\toptions |= TS_OPT_ECN;\n\n\tts = (ts_now >> TSBITS) << TSBITS;\n\tts |= options;\n\tif (ts > ts_now)\n\t\tts -= (1UL << TSBITS);\n\n\treturn ts * (NSEC_PER_SEC / TCP_TS_HZ);\n}\n\n\nstatic __u32 secure_tcp_syn_cookie(__be32 saddr, __be32 daddr, __be16 sport,\n\t\t\t\t   __be16 dport, __u32 sseq, __u32 data)\n{\n\t \n\tu32 count = tcp_cookie_time();\n\treturn (cookie_hash(saddr, daddr, sport, dport, 0, 0) +\n\t\tsseq + (count << COOKIEBITS) +\n\t\t((cookie_hash(saddr, daddr, sport, dport, count, 1) + data)\n\t\t & COOKIEMASK));\n}\n\n \nstatic __u32 check_tcp_syn_cookie(__u32 cookie, __be32 saddr, __be32 daddr,\n\t\t\t\t  __be16 sport, __be16 dport, __u32 sseq)\n{\n\tu32 diff, count = tcp_cookie_time();\n\n\t \n\tcookie -= cookie_hash(saddr, daddr, sport, dport, 0, 0) + sseq;\n\n\t \n\tdiff = (count - (cookie >> COOKIEBITS)) & ((__u32) -1 >> COOKIEBITS);\n\tif (diff >= MAX_SYNCOOKIE_AGE)\n\t\treturn (__u32)-1;\n\n\treturn (cookie -\n\t\tcookie_hash(saddr, daddr, sport, dport, count - diff, 1))\n\t\t& COOKIEMASK;\t \n}\n\n \nstatic __u16 const msstab[] = {\n\t536,\n\t1300,\n\t1440,\t \n\t1460,\n};\n\n \nu32 __cookie_v4_init_sequence(const struct iphdr *iph, const struct tcphdr *th,\n\t\t\t      u16 *mssp)\n{\n\tint mssind;\n\tconst __u16 mss = *mssp;\n\n\tfor (mssind = ARRAY_SIZE(msstab) - 1; mssind ; mssind--)\n\t\tif (mss >= msstab[mssind])\n\t\t\tbreak;\n\t*mssp = msstab[mssind];\n\n\treturn secure_tcp_syn_cookie(iph->saddr, iph->daddr,\n\t\t\t\t     th->source, th->dest, ntohl(th->seq),\n\t\t\t\t     mssind);\n}\nEXPORT_SYMBOL_GPL(__cookie_v4_init_sequence);\n\n__u32 cookie_v4_init_sequence(const struct sk_buff *skb, __u16 *mssp)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\treturn __cookie_v4_init_sequence(iph, th, mssp);\n}\n\n \nint __cookie_v4_check(const struct iphdr *iph, const struct tcphdr *th,\n\t\t      u32 cookie)\n{\n\t__u32 seq = ntohl(th->seq) - 1;\n\t__u32 mssind = check_tcp_syn_cookie(cookie, iph->saddr, iph->daddr,\n\t\t\t\t\t    th->source, th->dest, seq);\n\n\treturn mssind < ARRAY_SIZE(msstab) ? msstab[mssind] : 0;\n}\nEXPORT_SYMBOL_GPL(__cookie_v4_check);\n\nstruct sock *tcp_get_cookie_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t struct request_sock *req,\n\t\t\t\t struct dst_entry *dst, u32 tsoff)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct sock *child;\n\tbool own_req;\n\n\tchild = icsk->icsk_af_ops->syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t\t NULL, &own_req);\n\tif (child) {\n\t\trefcount_set(&req->rsk_refcnt, 1);\n\t\ttcp_sk(child)->tsoffset = tsoff;\n\t\tsock_rps_save_rxhash(child, skb);\n\n\t\tif (rsk_drop_req(req)) {\n\t\t\treqsk_put(req);\n\t\t\treturn child;\n\t\t}\n\n\t\tif (inet_csk_reqsk_queue_add(sk, req, child))\n\t\t\treturn child;\n\n\t\tbh_unlock_sock(child);\n\t\tsock_put(child);\n\t}\n\t__reqsk_free(req);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(tcp_get_cookie_sock);\n\n \nbool cookie_timestamp_decode(const struct net *net,\n\t\t\t     struct tcp_options_received *tcp_opt)\n{\n\t \n\tu32 options = tcp_opt->rcv_tsecr;\n\n\tif (!tcp_opt->saw_tstamp)  {\n\t\ttcp_clear_options(tcp_opt);\n\t\treturn true;\n\t}\n\n\tif (!READ_ONCE(net->ipv4.sysctl_tcp_timestamps))\n\t\treturn false;\n\n\ttcp_opt->sack_ok = (options & TS_OPT_SACK) ? TCP_SACK_SEEN : 0;\n\n\tif (tcp_opt->sack_ok && !READ_ONCE(net->ipv4.sysctl_tcp_sack))\n\t\treturn false;\n\n\tif ((options & TS_OPT_WSCALE_MASK) == TS_OPT_WSCALE_MASK)\n\t\treturn true;  \n\n\ttcp_opt->wscale_ok = 1;\n\ttcp_opt->snd_wscale = options & TS_OPT_WSCALE_MASK;\n\n\treturn READ_ONCE(net->ipv4.sysctl_tcp_window_scaling) != 0;\n}\nEXPORT_SYMBOL(cookie_timestamp_decode);\n\nbool cookie_ecn_ok(const struct tcp_options_received *tcp_opt,\n\t\t   const struct net *net, const struct dst_entry *dst)\n{\n\tbool ecn_ok = tcp_opt->rcv_tsecr & TS_OPT_ECN;\n\n\tif (!ecn_ok)\n\t\treturn false;\n\n\tif (READ_ONCE(net->ipv4.sysctl_tcp_ecn))\n\t\treturn true;\n\n\treturn dst_feature(dst, RTAX_FEATURE_ECN);\n}\nEXPORT_SYMBOL(cookie_ecn_ok);\n\nstruct request_sock *cookie_tcp_reqsk_alloc(const struct request_sock_ops *ops,\n\t\t\t\t\t    const struct tcp_request_sock_ops *af_ops,\n\t\t\t\t\t    struct sock *sk,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct tcp_request_sock *treq;\n\tstruct request_sock *req;\n\n\tif (sk_is_mptcp(sk))\n\t\treq = mptcp_subflow_reqsk_alloc(ops, sk, false);\n\telse\n\t\treq = inet_reqsk_alloc(ops, sk, false);\n\n\tif (!req)\n\t\treturn NULL;\n\n\ttreq = tcp_rsk(req);\n\n\t \n\ttreq->af_specific = af_ops;\n\n\ttreq->syn_tos = TCP_SKB_CB(skb)->ip_dsfield;\n#if IS_ENABLED(CONFIG_MPTCP)\n\ttreq->is_mptcp = sk_is_mptcp(sk);\n\tif (treq->is_mptcp) {\n\t\tint err = mptcp_subflow_init_cookie_req(req, sk, skb);\n\n\t\tif (err) {\n\t\t\treqsk_free(req);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif\n\n\treturn req;\n}\nEXPORT_SYMBOL_GPL(cookie_tcp_reqsk_alloc);\n\n \nstruct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &TCP_SKB_CB(skb)->header.h4.opt;\n\tstruct tcp_options_received tcp_opt;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint full_space, mss;\n\tstruct rtable *rt;\n\t__u8 rcv_wscale;\n\tstruct flowi4 fl4;\n\tu32 tsoff = 0;\n\n\tif (!READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_syncookies) ||\n\t    !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk))\n\t\tgoto out;\n\n\tmss = __cookie_v4_check(ip_hdr(skb), th, cookie);\n\tif (mss == 0) {\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t \n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(sock_net(sk), skb, &tcp_opt, 0, NULL);\n\n\tif (tcp_opt.saw_tstamp && tcp_opt.rcv_tsecr) {\n\t\ttsoff = secure_tcp_ts_off(sock_net(sk),\n\t\t\t\t\t  ip_hdr(skb)->daddr,\n\t\t\t\t\t  ip_hdr(skb)->saddr);\n\t\ttcp_opt.rcv_tsecr -= tsoff;\n\t}\n\n\tif (!cookie_timestamp_decode(sock_net(sk), &tcp_opt))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = cookie_tcp_reqsk_alloc(&tcp_request_sock_ops,\n\t\t\t\t     &tcp_request_sock_ipv4_ops, sk, skb);\n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->rcv_isn\t\t= ntohl(th->seq) - 1;\n\ttreq->snt_isn\t\t= cookie;\n\ttreq->ts_off\t\t= 0;\n\ttreq->txhash\t\t= net_tx_rndhash();\n\treq->mss\t\t= mss;\n\tireq->ir_num\t\t= ntohs(th->dest);\n\tireq->ir_rmt_port\t= th->source;\n\tsk_rcv_saddr_set(req_to_sk(req), ip_hdr(skb)->daddr);\n\tsk_daddr_set(req_to_sk(req), ip_hdr(skb)->saddr);\n\tireq->ir_mark\t\t= inet_request_mark(sk, skb);\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\ttreq->snt_synack\t= 0;\n\ttreq->tfo_listener\t= false;\n\n\tif (IS_ENABLED(CONFIG_SMC))\n\t\tireq->smc_ok = 0;\n\n\tireq->ir_iif = inet_request_bound_dev_if(sk, skb);\n\n\t \n\tRCU_INIT_POINTER(ireq->ireq_opt, tcp_v4_save_options(sock_net(sk), skb));\n\n\tif (security_inet_conn_request(sk, skb, req)) {\n\t\treqsk_free(req);\n\t\tgoto out;\n\t}\n\n\treq->num_retrans = 0;\n\n\t \n\tflowi4_init_output(&fl4, ireq->ir_iif, ireq->ir_mark,\n\t\t\t   ip_sock_rt_tos(sk), ip_sock_rt_scope(sk),\n\t\t\t   IPPROTO_TCP, inet_sk_flowi_flags(sk),\n\t\t\t   opt->srr ? opt->faddr : ireq->ir_rmt_addr,\n\t\t\t   ireq->ir_loc_addr, th->source, th->dest, sk->sk_uid);\n\tsecurity_req_classify_flow(req, flowi4_to_flowi_common(&fl4));\n\trt = ip_route_output_key(sock_net(sk), &fl4);\n\tif (IS_ERR(rt)) {\n\t\treqsk_free(req);\n\t\tgoto out;\n\t}\n\n\t \n\treq->rsk_window_clamp = tp->window_clamp ? :dst_metric(&rt->dst, RTAX_WINDOW);\n\t \n\tfull_space = tcp_full_space(sk);\n\tif (sk->sk_userlocks & SOCK_RCVBUF_LOCK &&\n\t    (req->rsk_window_clamp > full_space || req->rsk_window_clamp == 0))\n\t\treq->rsk_window_clamp = full_space;\n\n\ttcp_select_initial_window(sk, full_space, req->mss,\n\t\t\t\t  &req->rsk_rcv_wnd, &req->rsk_window_clamp,\n\t\t\t\t  ireq->wscale_ok, &rcv_wscale,\n\t\t\t\t  dst_metric(&rt->dst, RTAX_INITRWND));\n\n\tireq->rcv_wscale  = rcv_wscale;\n\tireq->ecn_ok = cookie_ecn_ok(&tcp_opt, sock_net(sk), &rt->dst);\n\n\tret = tcp_get_cookie_sock(sk, skb, req, &rt->dst, tsoff);\n\t \n\tif (ret)\n\t\tinet_sk(ret)->cork.fl.u.ip4 = fl4;\nout:\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}