{
  "module_name": "tcp_diag.c",
  "hash_id": "48d8e54290149dcd12670f24333b8551edcb657e96bb6db608be37ca9c542c90",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_diag.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/sock_diag.h>\n#include <linux/inet_diag.h>\n\n#include <linux/tcp.h>\n\n#include <net/netlink.h>\n#include <net/tcp.h>\n\nstatic void tcp_diag_get_info(struct sock *sk, struct inet_diag_msg *r,\n\t\t\t      void *_info)\n{\n\tstruct tcp_info *info = _info;\n\n\tif (inet_sk_state_load(sk) == TCP_LISTEN) {\n\t\tr->idiag_rqueue = READ_ONCE(sk->sk_ack_backlog);\n\t\tr->idiag_wqueue = READ_ONCE(sk->sk_max_ack_backlog);\n\t} else if (sk->sk_type == SOCK_STREAM) {\n\t\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t\tr->idiag_rqueue = max_t(int, READ_ONCE(tp->rcv_nxt) -\n\t\t\t\t\t     READ_ONCE(tp->copied_seq), 0);\n\t\tr->idiag_wqueue = READ_ONCE(tp->write_seq) - tp->snd_una;\n\t}\n\tif (info)\n\t\ttcp_get_info(sk, info);\n}\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic void tcp_diag_md5sig_fill(struct tcp_diag_md5sig *info,\n\t\t\t\t const struct tcp_md5sig_key *key)\n{\n\tinfo->tcpm_family = key->family;\n\tinfo->tcpm_prefixlen = key->prefixlen;\n\tinfo->tcpm_keylen = key->keylen;\n\tmemcpy(info->tcpm_key, key->key, key->keylen);\n\n\tif (key->family == AF_INET)\n\t\tinfo->tcpm_addr[0] = key->addr.a4.s_addr;\n\t#if IS_ENABLED(CONFIG_IPV6)\n\telse if (key->family == AF_INET6)\n\t\tmemcpy(&info->tcpm_addr, &key->addr.a6,\n\t\t       sizeof(info->tcpm_addr));\n\t#endif\n}\n\nstatic int tcp_diag_put_md5sig(struct sk_buff *skb,\n\t\t\t       const struct tcp_md5sig_info *md5sig)\n{\n\tconst struct tcp_md5sig_key *key;\n\tstruct tcp_diag_md5sig *info;\n\tstruct nlattr *attr;\n\tint md5sig_count = 0;\n\n\thlist_for_each_entry_rcu(key, &md5sig->head, node)\n\t\tmd5sig_count++;\n\tif (md5sig_count == 0)\n\t\treturn 0;\n\n\tattr = nla_reserve(skb, INET_DIAG_MD5SIG,\n\t\t\t   md5sig_count * sizeof(struct tcp_diag_md5sig));\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tinfo = nla_data(attr);\n\tmemset(info, 0, md5sig_count * sizeof(struct tcp_diag_md5sig));\n\thlist_for_each_entry_rcu(key, &md5sig->head, node) {\n\t\ttcp_diag_md5sig_fill(info++, key);\n\t\tif (--md5sig_count == 0)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int tcp_diag_put_ulp(struct sk_buff *skb, struct sock *sk,\n\t\t\t    const struct tcp_ulp_ops *ulp_ops)\n{\n\tstruct nlattr *nest;\n\tint err;\n\n\tnest = nla_nest_start_noflag(skb, INET_DIAG_ULP_INFO);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\terr = nla_put_string(skb, INET_ULP_INFO_NAME, ulp_ops->name);\n\tif (err)\n\t\tgoto nla_failure;\n\n\tif (ulp_ops->get_info)\n\t\terr = ulp_ops->get_info(sk, skb);\n\tif (err)\n\t\tgoto nla_failure;\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nnla_failure:\n\tnla_nest_cancel(skb, nest);\n\treturn err;\n}\n\nstatic int tcp_diag_get_aux(struct sock *sk, bool net_admin,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tint err = 0;\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (net_admin) {\n\t\tstruct tcp_md5sig_info *md5sig;\n\n\t\trcu_read_lock();\n\t\tmd5sig = rcu_dereference(tcp_sk(sk)->md5sig_info);\n\t\tif (md5sig)\n\t\t\terr = tcp_diag_put_md5sig(skb, md5sig);\n\t\trcu_read_unlock();\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n#endif\n\n\tif (net_admin) {\n\t\tconst struct tcp_ulp_ops *ulp_ops;\n\n\t\tulp_ops = icsk->icsk_ulp_ops;\n\t\tif (ulp_ops)\n\t\t\terr = tcp_diag_put_ulp(skb, sk, ulp_ops);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic size_t tcp_diag_get_aux_size(struct sock *sk, bool net_admin)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tsize_t size = 0;\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (net_admin && sk_fullsock(sk)) {\n\t\tconst struct tcp_md5sig_info *md5sig;\n\t\tconst struct tcp_md5sig_key *key;\n\t\tsize_t md5sig_count = 0;\n\n\t\trcu_read_lock();\n\t\tmd5sig = rcu_dereference(tcp_sk(sk)->md5sig_info);\n\t\tif (md5sig) {\n\t\t\thlist_for_each_entry_rcu(key, &md5sig->head, node)\n\t\t\t\tmd5sig_count++;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsize += nla_total_size(md5sig_count *\n\t\t\t\t       sizeof(struct tcp_diag_md5sig));\n\t}\n#endif\n\n\tif (net_admin && sk_fullsock(sk)) {\n\t\tconst struct tcp_ulp_ops *ulp_ops;\n\n\t\tulp_ops = icsk->icsk_ulp_ops;\n\t\tif (ulp_ops) {\n\t\t\tsize += nla_total_size(0) +\n\t\t\t\tnla_total_size(TCP_ULP_NAME_MAX);\n\t\t\tif (ulp_ops->get_info_size)\n\t\t\t\tsize += ulp_ops->get_info_size(sk);\n\t\t}\n\t}\n\treturn size;\n}\n\nstatic void tcp_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t  const struct inet_diag_req_v2 *r)\n{\n\tstruct inet_hashinfo *hinfo;\n\n\thinfo = sock_net(cb->skb->sk)->ipv4.tcp_death_row.hashinfo;\n\n\tinet_diag_dump_icsk(hinfo, skb, cb, r);\n}\n\nstatic int tcp_diag_dump_one(struct netlink_callback *cb,\n\t\t\t     const struct inet_diag_req_v2 *req)\n{\n\tstruct inet_hashinfo *hinfo;\n\n\thinfo = sock_net(cb->skb->sk)->ipv4.tcp_death_row.hashinfo;\n\n\treturn inet_diag_dump_one_icsk(hinfo, cb, req);\n}\n\n#ifdef CONFIG_INET_DIAG_DESTROY\nstatic int tcp_diag_destroy(struct sk_buff *in_skb,\n\t\t\t    const struct inet_diag_req_v2 *req)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct inet_hashinfo *hinfo;\n\tstruct sock *sk;\n\tint err;\n\n\thinfo = net->ipv4.tcp_death_row.hashinfo;\n\tsk = inet_diag_find_one_icsk(net, hinfo, req);\n\n\tif (IS_ERR(sk))\n\t\treturn PTR_ERR(sk);\n\n\terr = sock_diag_destroy(sk, ECONNABORTED);\n\n\tsock_gen_put(sk);\n\n\treturn err;\n}\n#endif\n\nstatic const struct inet_diag_handler tcp_diag_handler = {\n\t.dump\t\t\t= tcp_diag_dump,\n\t.dump_one\t\t= tcp_diag_dump_one,\n\t.idiag_get_info\t\t= tcp_diag_get_info,\n\t.idiag_get_aux\t\t= tcp_diag_get_aux,\n\t.idiag_get_aux_size\t= tcp_diag_get_aux_size,\n\t.idiag_type\t\t= IPPROTO_TCP,\n\t.idiag_info_size\t= sizeof(struct tcp_info),\n#ifdef CONFIG_INET_DIAG_DESTROY\n\t.destroy\t\t= tcp_diag_destroy,\n#endif\n};\n\nstatic int __init tcp_diag_init(void)\n{\n\treturn inet_diag_register(&tcp_diag_handler);\n}\n\nstatic void __exit tcp_diag_exit(void)\n{\n\tinet_diag_unregister(&tcp_diag_handler);\n}\n\nmodule_init(tcp_diag_init);\nmodule_exit(tcp_diag_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 2-6  );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}