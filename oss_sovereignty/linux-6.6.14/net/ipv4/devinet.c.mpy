{
  "module_name": "devinet.c",
  "hash_id": "80b0dbbd9a3637b6a142fee5d04ad16594df77cabaea6764af2b570874eaba1a",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/devinet.c",
  "human_readable_source": "\n \n\n\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/if_addr.h>\n#include <linux/if_ether.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/notifier.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n#include <linux/kmod.h>\n#include <linux/netconf.h>\n\n#include <net/arp.h>\n#include <net/ip.h>\n#include <net/route.h>\n#include <net/ip_fib.h>\n#include <net/rtnetlink.h>\n#include <net/net_namespace.h>\n#include <net/addrconf.h>\n\n#define IPV6ONLY_FLAGS\t\\\n\t\t(IFA_F_NODAD | IFA_F_OPTIMISTIC | IFA_F_DADFAILED | \\\n\t\t IFA_F_HOMEADDRESS | IFA_F_TENTATIVE | \\\n\t\t IFA_F_MANAGETEMPADDR | IFA_F_STABLE_PRIVACY)\n\nstatic struct ipv4_devconf ipv4_devconf = {\n\t.data = {\n\t\t[IPV4_DEVCONF_ACCEPT_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SEND_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SECURE_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SHARED_MEDIA - 1] = 1,\n\t\t[IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL - 1] = 10000  ,\n\t\t[IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL - 1] =  1000  ,\n\t\t[IPV4_DEVCONF_ARP_EVICT_NOCARRIER - 1] = 1,\n\t},\n};\n\nstatic struct ipv4_devconf ipv4_devconf_dflt = {\n\t.data = {\n\t\t[IPV4_DEVCONF_ACCEPT_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SEND_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SECURE_REDIRECTS - 1] = 1,\n\t\t[IPV4_DEVCONF_SHARED_MEDIA - 1] = 1,\n\t\t[IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE - 1] = 1,\n\t\t[IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL - 1] = 10000  ,\n\t\t[IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL - 1] =  1000  ,\n\t\t[IPV4_DEVCONF_ARP_EVICT_NOCARRIER - 1] = 1,\n\t},\n};\n\n#define IPV4_DEVCONF_DFLT(net, attr) \\\n\tIPV4_DEVCONF((*net->ipv4.devconf_dflt), attr)\n\nstatic const struct nla_policy ifa_ipv4_policy[IFA_MAX+1] = {\n\t[IFA_LOCAL]     \t= { .type = NLA_U32 },\n\t[IFA_ADDRESS]   \t= { .type = NLA_U32 },\n\t[IFA_BROADCAST] \t= { .type = NLA_U32 },\n\t[IFA_LABEL]     \t= { .type = NLA_STRING, .len = IFNAMSIZ - 1 },\n\t[IFA_CACHEINFO]\t\t= { .len = sizeof(struct ifa_cacheinfo) },\n\t[IFA_FLAGS]\t\t= { .type = NLA_U32 },\n\t[IFA_RT_PRIORITY]\t= { .type = NLA_U32 },\n\t[IFA_TARGET_NETNSID]\t= { .type = NLA_S32 },\n\t[IFA_PROTO]\t\t= { .type = NLA_U8 },\n};\n\nstruct inet_fill_args {\n\tu32 portid;\n\tu32 seq;\n\tint event;\n\tunsigned int flags;\n\tint netnsid;\n\tint ifindex;\n};\n\n#define IN4_ADDR_HSIZE_SHIFT\t8\n#define IN4_ADDR_HSIZE\t\t(1U << IN4_ADDR_HSIZE_SHIFT)\n\nstatic struct hlist_head inet_addr_lst[IN4_ADDR_HSIZE];\n\nstatic u32 inet_addr_hash(const struct net *net, __be32 addr)\n{\n\tu32 val = (__force u32) addr ^ net_hash_mix(net);\n\n\treturn hash_32(val, IN4_ADDR_HSIZE_SHIFT);\n}\n\nstatic void inet_hash_insert(struct net *net, struct in_ifaddr *ifa)\n{\n\tu32 hash = inet_addr_hash(net, ifa->ifa_local);\n\n\tASSERT_RTNL();\n\thlist_add_head_rcu(&ifa->hash, &inet_addr_lst[hash]);\n}\n\nstatic void inet_hash_remove(struct in_ifaddr *ifa)\n{\n\tASSERT_RTNL();\n\thlist_del_init_rcu(&ifa->hash);\n}\n\n \nstruct net_device *__ip_dev_find(struct net *net, __be32 addr, bool devref)\n{\n\tstruct net_device *result = NULL;\n\tstruct in_ifaddr *ifa;\n\n\trcu_read_lock();\n\tifa = inet_lookup_ifaddr_rcu(net, addr);\n\tif (!ifa) {\n\t\tstruct flowi4 fl4 = { .daddr = addr };\n\t\tstruct fib_result res = { 0 };\n\t\tstruct fib_table *local;\n\n\t\t \n\t\tlocal = fib_get_table(net, RT_TABLE_LOCAL);\n\t\tif (local &&\n\t\t    !fib_table_lookup(local, &fl4, &res, FIB_LOOKUP_NOREF) &&\n\t\t    res.type == RTN_LOCAL)\n\t\t\tresult = FIB_RES_DEV(res);\n\t} else {\n\t\tresult = ifa->ifa_dev->dev;\n\t}\n\tif (result && devref)\n\t\tdev_hold(result);\n\trcu_read_unlock();\n\treturn result;\n}\nEXPORT_SYMBOL(__ip_dev_find);\n\n \nstruct in_ifaddr *inet_lookup_ifaddr_rcu(struct net *net, __be32 addr)\n{\n\tu32 hash = inet_addr_hash(net, addr);\n\tstruct in_ifaddr *ifa;\n\n\thlist_for_each_entry_rcu(ifa, &inet_addr_lst[hash], hash)\n\t\tif (ifa->ifa_local == addr &&\n\t\t    net_eq(dev_net(ifa->ifa_dev->dev), net))\n\t\t\treturn ifa;\n\n\treturn NULL;\n}\n\nstatic void rtmsg_ifa(int event, struct in_ifaddr *, struct nlmsghdr *, u32);\n\nstatic BLOCKING_NOTIFIER_HEAD(inetaddr_chain);\nstatic BLOCKING_NOTIFIER_HEAD(inetaddr_validator_chain);\nstatic void inet_del_ifa(struct in_device *in_dev,\n\t\t\t struct in_ifaddr __rcu **ifap,\n\t\t\t int destroy);\n#ifdef CONFIG_SYSCTL\nstatic int devinet_sysctl_register(struct in_device *idev);\nstatic void devinet_sysctl_unregister(struct in_device *idev);\n#else\nstatic int devinet_sysctl_register(struct in_device *idev)\n{\n\treturn 0;\n}\nstatic void devinet_sysctl_unregister(struct in_device *idev)\n{\n}\n#endif\n\n \n\nstatic struct in_ifaddr *inet_alloc_ifa(void)\n{\n\treturn kzalloc(sizeof(struct in_ifaddr), GFP_KERNEL_ACCOUNT);\n}\n\nstatic void inet_rcu_free_ifa(struct rcu_head *head)\n{\n\tstruct in_ifaddr *ifa = container_of(head, struct in_ifaddr, rcu_head);\n\tif (ifa->ifa_dev)\n\t\tin_dev_put(ifa->ifa_dev);\n\tkfree(ifa);\n}\n\nstatic void inet_free_ifa(struct in_ifaddr *ifa)\n{\n\tcall_rcu(&ifa->rcu_head, inet_rcu_free_ifa);\n}\n\nstatic void in_dev_free_rcu(struct rcu_head *head)\n{\n\tstruct in_device *idev = container_of(head, struct in_device, rcu_head);\n\n\tkfree(rcu_dereference_protected(idev->mc_hash, 1));\n\tkfree(idev);\n}\n\nvoid in_dev_finish_destroy(struct in_device *idev)\n{\n\tstruct net_device *dev = idev->dev;\n\n\tWARN_ON(idev->ifa_list);\n\tWARN_ON(idev->mc_list);\n#ifdef NET_REFCNT_DEBUG\n\tpr_debug(\"%s: %p=%s\\n\", __func__, idev, dev ? dev->name : \"NIL\");\n#endif\n\tnetdev_put(dev, &idev->dev_tracker);\n\tif (!idev->dead)\n\t\tpr_err(\"Freeing alive in_device %p\\n\", idev);\n\telse\n\t\tcall_rcu(&idev->rcu_head, in_dev_free_rcu);\n}\nEXPORT_SYMBOL(in_dev_finish_destroy);\n\nstatic struct in_device *inetdev_init(struct net_device *dev)\n{\n\tstruct in_device *in_dev;\n\tint err = -ENOMEM;\n\n\tASSERT_RTNL();\n\n\tin_dev = kzalloc(sizeof(*in_dev), GFP_KERNEL);\n\tif (!in_dev)\n\t\tgoto out;\n\tmemcpy(&in_dev->cnf, dev_net(dev)->ipv4.devconf_dflt,\n\t\t\tsizeof(in_dev->cnf));\n\tin_dev->cnf.sysctl = NULL;\n\tin_dev->dev = dev;\n\tin_dev->arp_parms = neigh_parms_alloc(dev, &arp_tbl);\n\tif (!in_dev->arp_parms)\n\t\tgoto out_kfree;\n\tif (IPV4_DEVCONF(in_dev->cnf, FORWARDING))\n\t\tdev_disable_lro(dev);\n\t \n\tnetdev_hold(dev, &in_dev->dev_tracker, GFP_KERNEL);\n\t \n\trefcount_set(&in_dev->refcnt, 1);\n\n\terr = devinet_sysctl_register(in_dev);\n\tif (err) {\n\t\tin_dev->dead = 1;\n\t\tneigh_parms_release(&arp_tbl, in_dev->arp_parms);\n\t\tin_dev_put(in_dev);\n\t\tin_dev = NULL;\n\t\tgoto out;\n\t}\n\tip_mc_init_dev(in_dev);\n\tif (dev->flags & IFF_UP)\n\t\tip_mc_up(in_dev);\n\n\t \n\trcu_assign_pointer(dev->ip_ptr, in_dev);\nout:\n\treturn in_dev ?: ERR_PTR(err);\nout_kfree:\n\tkfree(in_dev);\n\tin_dev = NULL;\n\tgoto out;\n}\n\nstatic void inetdev_destroy(struct in_device *in_dev)\n{\n\tstruct net_device *dev;\n\tstruct in_ifaddr *ifa;\n\n\tASSERT_RTNL();\n\n\tdev = in_dev->dev;\n\n\tin_dev->dead = 1;\n\n\tip_mc_destroy_dev(in_dev);\n\n\twhile ((ifa = rtnl_dereference(in_dev->ifa_list)) != NULL) {\n\t\tinet_del_ifa(in_dev, &in_dev->ifa_list, 0);\n\t\tinet_free_ifa(ifa);\n\t}\n\n\tRCU_INIT_POINTER(dev->ip_ptr, NULL);\n\n\tdevinet_sysctl_unregister(in_dev);\n\tneigh_parms_release(&arp_tbl, in_dev->arp_parms);\n\tarp_ifdown(dev);\n\n\tin_dev_put(in_dev);\n}\n\nint inet_addr_onlink(struct in_device *in_dev, __be32 a, __be32 b)\n{\n\tconst struct in_ifaddr *ifa;\n\n\trcu_read_lock();\n\tin_dev_for_each_ifa_rcu(ifa, in_dev) {\n\t\tif (inet_ifa_match(a, ifa)) {\n\t\t\tif (!b || inet_ifa_match(b, ifa)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic void __inet_del_ifa(struct in_device *in_dev,\n\t\t\t   struct in_ifaddr __rcu **ifap,\n\t\t\t   int destroy, struct nlmsghdr *nlh, u32 portid)\n{\n\tstruct in_ifaddr *promote = NULL;\n\tstruct in_ifaddr *ifa, *ifa1;\n\tstruct in_ifaddr __rcu **last_prim;\n\tstruct in_ifaddr *prev_prom = NULL;\n\tint do_promote = IN_DEV_PROMOTE_SECONDARIES(in_dev);\n\n\tASSERT_RTNL();\n\n\tifa1 = rtnl_dereference(*ifap);\n\tlast_prim = ifap;\n\tif (in_dev->dead)\n\t\tgoto no_promotions;\n\n\t \n\n\tif (!(ifa1->ifa_flags & IFA_F_SECONDARY)) {\n\t\tstruct in_ifaddr __rcu **ifap1 = &ifa1->ifa_next;\n\n\t\twhile ((ifa = rtnl_dereference(*ifap1)) != NULL) {\n\t\t\tif (!(ifa->ifa_flags & IFA_F_SECONDARY) &&\n\t\t\t    ifa1->ifa_scope <= ifa->ifa_scope)\n\t\t\t\tlast_prim = &ifa->ifa_next;\n\n\t\t\tif (!(ifa->ifa_flags & IFA_F_SECONDARY) ||\n\t\t\t    ifa1->ifa_mask != ifa->ifa_mask ||\n\t\t\t    !inet_ifa_match(ifa1->ifa_address, ifa)) {\n\t\t\t\tifap1 = &ifa->ifa_next;\n\t\t\t\tprev_prom = ifa;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!do_promote) {\n\t\t\t\tinet_hash_remove(ifa);\n\t\t\t\t*ifap1 = ifa->ifa_next;\n\n\t\t\t\trtmsg_ifa(RTM_DELADDR, ifa, nlh, portid);\n\t\t\t\tblocking_notifier_call_chain(&inetaddr_chain,\n\t\t\t\t\t\tNETDEV_DOWN, ifa);\n\t\t\t\tinet_free_ifa(ifa);\n\t\t\t} else {\n\t\t\t\tpromote = ifa;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (ifa = promote; ifa; ifa = rtnl_dereference(ifa->ifa_next)) {\n\t\tif (ifa1->ifa_mask == ifa->ifa_mask &&\n\t\t    inet_ifa_match(ifa1->ifa_address, ifa))\n\t\t\tfib_del_ifaddr(ifa, ifa1);\n\t}\n\nno_promotions:\n\t \n\n\t*ifap = ifa1->ifa_next;\n\tinet_hash_remove(ifa1);\n\n\t \n\n\t \n\trtmsg_ifa(RTM_DELADDR, ifa1, nlh, portid);\n\tblocking_notifier_call_chain(&inetaddr_chain, NETDEV_DOWN, ifa1);\n\n\tif (promote) {\n\t\tstruct in_ifaddr *next_sec;\n\n\t\tnext_sec = rtnl_dereference(promote->ifa_next);\n\t\tif (prev_prom) {\n\t\t\tstruct in_ifaddr *last_sec;\n\n\t\t\trcu_assign_pointer(prev_prom->ifa_next, next_sec);\n\n\t\t\tlast_sec = rtnl_dereference(*last_prim);\n\t\t\trcu_assign_pointer(promote->ifa_next, last_sec);\n\t\t\trcu_assign_pointer(*last_prim, promote);\n\t\t}\n\n\t\tpromote->ifa_flags &= ~IFA_F_SECONDARY;\n\t\trtmsg_ifa(RTM_NEWADDR, promote, nlh, portid);\n\t\tblocking_notifier_call_chain(&inetaddr_chain,\n\t\t\t\tNETDEV_UP, promote);\n\t\tfor (ifa = next_sec; ifa;\n\t\t     ifa = rtnl_dereference(ifa->ifa_next)) {\n\t\t\tif (ifa1->ifa_mask != ifa->ifa_mask ||\n\t\t\t    !inet_ifa_match(ifa1->ifa_address, ifa))\n\t\t\t\t\tcontinue;\n\t\t\tfib_add_ifaddr(ifa);\n\t\t}\n\n\t}\n\tif (destroy)\n\t\tinet_free_ifa(ifa1);\n}\n\nstatic void inet_del_ifa(struct in_device *in_dev,\n\t\t\t struct in_ifaddr __rcu **ifap,\n\t\t\t int destroy)\n{\n\t__inet_del_ifa(in_dev, ifap, destroy, NULL, 0);\n}\n\nstatic void check_lifetime(struct work_struct *work);\n\nstatic DECLARE_DELAYED_WORK(check_lifetime_work, check_lifetime);\n\nstatic int __inet_insert_ifa(struct in_ifaddr *ifa, struct nlmsghdr *nlh,\n\t\t\t     u32 portid, struct netlink_ext_ack *extack)\n{\n\tstruct in_ifaddr __rcu **last_primary, **ifap;\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct in_validator_info ivi;\n\tstruct in_ifaddr *ifa1;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tif (!ifa->ifa_local) {\n\t\tinet_free_ifa(ifa);\n\t\treturn 0;\n\t}\n\n\tifa->ifa_flags &= ~IFA_F_SECONDARY;\n\tlast_primary = &in_dev->ifa_list;\n\n\t \n\tifa->ifa_flags &= ~IPV6ONLY_FLAGS;\n\n\tifap = &in_dev->ifa_list;\n\tifa1 = rtnl_dereference(*ifap);\n\n\twhile (ifa1) {\n\t\tif (!(ifa1->ifa_flags & IFA_F_SECONDARY) &&\n\t\t    ifa->ifa_scope <= ifa1->ifa_scope)\n\t\t\tlast_primary = &ifa1->ifa_next;\n\t\tif (ifa1->ifa_mask == ifa->ifa_mask &&\n\t\t    inet_ifa_match(ifa1->ifa_address, ifa)) {\n\t\t\tif (ifa1->ifa_local == ifa->ifa_local) {\n\t\t\t\tinet_free_ifa(ifa);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\tif (ifa1->ifa_scope != ifa->ifa_scope) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"ipv4: Invalid scope value\");\n\t\t\t\tinet_free_ifa(ifa);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tifa->ifa_flags |= IFA_F_SECONDARY;\n\t\t}\n\n\t\tifap = &ifa1->ifa_next;\n\t\tifa1 = rtnl_dereference(*ifap);\n\t}\n\n\t \n\tivi.ivi_addr = ifa->ifa_address;\n\tivi.ivi_dev = ifa->ifa_dev;\n\tivi.extack = extack;\n\tret = blocking_notifier_call_chain(&inetaddr_validator_chain,\n\t\t\t\t\t   NETDEV_UP, &ivi);\n\tret = notifier_to_errno(ret);\n\tif (ret) {\n\t\tinet_free_ifa(ifa);\n\t\treturn ret;\n\t}\n\n\tif (!(ifa->ifa_flags & IFA_F_SECONDARY))\n\t\tifap = last_primary;\n\n\trcu_assign_pointer(ifa->ifa_next, *ifap);\n\trcu_assign_pointer(*ifap, ifa);\n\n\tinet_hash_insert(dev_net(in_dev->dev), ifa);\n\n\tcancel_delayed_work(&check_lifetime_work);\n\tqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work, 0);\n\n\t \n\trtmsg_ifa(RTM_NEWADDR, ifa, nlh, portid);\n\tblocking_notifier_call_chain(&inetaddr_chain, NETDEV_UP, ifa);\n\n\treturn 0;\n}\n\nstatic int inet_insert_ifa(struct in_ifaddr *ifa)\n{\n\treturn __inet_insert_ifa(ifa, NULL, 0, NULL);\n}\n\nstatic int inet_set_ifa(struct net_device *dev, struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\n\tASSERT_RTNL();\n\n\tif (!in_dev) {\n\t\tinet_free_ifa(ifa);\n\t\treturn -ENOBUFS;\n\t}\n\tipv4_devconf_setall(in_dev);\n\tneigh_parms_data_state_setall(in_dev->arp_parms);\n\tif (ifa->ifa_dev != in_dev) {\n\t\tWARN_ON(ifa->ifa_dev);\n\t\tin_dev_hold(in_dev);\n\t\tifa->ifa_dev = in_dev;\n\t}\n\tif (ipv4_is_loopback(ifa->ifa_local))\n\t\tifa->ifa_scope = RT_SCOPE_HOST;\n\treturn inet_insert_ifa(ifa);\n}\n\n \nstruct in_device *inetdev_by_index(struct net *net, int ifindex)\n{\n\tstruct net_device *dev;\n\tstruct in_device *in_dev = NULL;\n\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(net, ifindex);\n\tif (dev)\n\t\tin_dev = rcu_dereference_rtnl(dev->ip_ptr);\n\trcu_read_unlock();\n\treturn in_dev;\n}\nEXPORT_SYMBOL(inetdev_by_index);\n\n \n\nstruct in_ifaddr *inet_ifa_byprefix(struct in_device *in_dev, __be32 prefix,\n\t\t\t\t    __be32 mask)\n{\n\tstruct in_ifaddr *ifa;\n\n\tASSERT_RTNL();\n\n\tin_dev_for_each_ifa_rtnl(ifa, in_dev) {\n\t\tif (ifa->ifa_mask == mask && inet_ifa_match(prefix, ifa))\n\t\t\treturn ifa;\n\t}\n\treturn NULL;\n}\n\nstatic int ip_mc_autojoin_config(struct net *net, bool join,\n\t\t\t\t const struct in_ifaddr *ifa)\n{\n#if defined(CONFIG_IP_MULTICAST)\n\tstruct ip_mreqn mreq = {\n\t\t.imr_multiaddr.s_addr = ifa->ifa_address,\n\t\t.imr_ifindex = ifa->ifa_dev->dev->ifindex,\n\t};\n\tstruct sock *sk = net->ipv4.mc_autojoin_sk;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tlock_sock(sk);\n\tif (join)\n\t\tret = ip_mc_join_group(sk, &mreq);\n\telse\n\t\tret = ip_mc_leave_group(sk, &mreq);\n\trelease_sock(sk);\n\n\treturn ret;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic int inet_rtm_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct in_ifaddr __rcu **ifap;\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct in_device *in_dev;\n\tstruct ifaddrmsg *ifm;\n\tstruct in_ifaddr *ifa;\n\tint err;\n\n\tASSERT_RTNL();\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFA_MAX,\n\t\t\t\t     ifa_ipv4_policy, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tifm = nlmsg_data(nlh);\n\tin_dev = inetdev_by_index(net, ifm->ifa_index);\n\tif (!in_dev) {\n\t\tNL_SET_ERR_MSG(extack, \"ipv4: Device not found\");\n\t\terr = -ENODEV;\n\t\tgoto errout;\n\t}\n\n\tfor (ifap = &in_dev->ifa_list; (ifa = rtnl_dereference(*ifap)) != NULL;\n\t     ifap = &ifa->ifa_next) {\n\t\tif (tb[IFA_LOCAL] &&\n\t\t    ifa->ifa_local != nla_get_in_addr(tb[IFA_LOCAL]))\n\t\t\tcontinue;\n\n\t\tif (tb[IFA_LABEL] && nla_strcmp(tb[IFA_LABEL], ifa->ifa_label))\n\t\t\tcontinue;\n\n\t\tif (tb[IFA_ADDRESS] &&\n\t\t    (ifm->ifa_prefixlen != ifa->ifa_prefixlen ||\n\t\t    !inet_ifa_match(nla_get_in_addr(tb[IFA_ADDRESS]), ifa)))\n\t\t\tcontinue;\n\n\t\tif (ipv4_is_multicast(ifa->ifa_address))\n\t\t\tip_mc_autojoin_config(net, false, ifa);\n\t\t__inet_del_ifa(in_dev, ifap, 1, nlh, NETLINK_CB(skb).portid);\n\t\treturn 0;\n\t}\n\n\tNL_SET_ERR_MSG(extack, \"ipv4: Address not found\");\n\terr = -EADDRNOTAVAIL;\nerrout:\n\treturn err;\n}\n\n#define INFINITY_LIFE_TIME\t0xFFFFFFFF\n\nstatic void check_lifetime(struct work_struct *work)\n{\n\tunsigned long now, next, next_sec, next_sched;\n\tstruct in_ifaddr *ifa;\n\tstruct hlist_node *n;\n\tint i;\n\n\tnow = jiffies;\n\tnext = round_jiffies_up(now + ADDR_CHECK_FREQUENCY);\n\n\tfor (i = 0; i < IN4_ADDR_HSIZE; i++) {\n\t\tbool change_needed = false;\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(ifa, &inet_addr_lst[i], hash) {\n\t\t\tunsigned long age;\n\n\t\t\tif (ifa->ifa_flags & IFA_F_PERMANENT)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tage = (now - ifa->ifa_tstamp +\n\t\t\t       ADDRCONF_TIMER_FUZZ_MINUS) / HZ;\n\n\t\t\tif (ifa->ifa_valid_lft != INFINITY_LIFE_TIME &&\n\t\t\t    age >= ifa->ifa_valid_lft) {\n\t\t\t\tchange_needed = true;\n\t\t\t} else if (ifa->ifa_preferred_lft ==\n\t\t\t\t   INFINITY_LIFE_TIME) {\n\t\t\t\tcontinue;\n\t\t\t} else if (age >= ifa->ifa_preferred_lft) {\n\t\t\t\tif (time_before(ifa->ifa_tstamp +\n\t\t\t\t\t\tifa->ifa_valid_lft * HZ, next))\n\t\t\t\t\tnext = ifa->ifa_tstamp +\n\t\t\t\t\t       ifa->ifa_valid_lft * HZ;\n\n\t\t\t\tif (!(ifa->ifa_flags & IFA_F_DEPRECATED))\n\t\t\t\t\tchange_needed = true;\n\t\t\t} else if (time_before(ifa->ifa_tstamp +\n\t\t\t\t\t       ifa->ifa_preferred_lft * HZ,\n\t\t\t\t\t       next)) {\n\t\t\t\tnext = ifa->ifa_tstamp +\n\t\t\t\t       ifa->ifa_preferred_lft * HZ;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!change_needed)\n\t\t\tcontinue;\n\t\trtnl_lock();\n\t\thlist_for_each_entry_safe(ifa, n, &inet_addr_lst[i], hash) {\n\t\t\tunsigned long age;\n\n\t\t\tif (ifa->ifa_flags & IFA_F_PERMANENT)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tage = (now - ifa->ifa_tstamp +\n\t\t\t       ADDRCONF_TIMER_FUZZ_MINUS) / HZ;\n\n\t\t\tif (ifa->ifa_valid_lft != INFINITY_LIFE_TIME &&\n\t\t\t    age >= ifa->ifa_valid_lft) {\n\t\t\t\tstruct in_ifaddr __rcu **ifap;\n\t\t\t\tstruct in_ifaddr *tmp;\n\n\t\t\t\tifap = &ifa->ifa_dev->ifa_list;\n\t\t\t\ttmp = rtnl_dereference(*ifap);\n\t\t\t\twhile (tmp) {\n\t\t\t\t\tif (tmp == ifa) {\n\t\t\t\t\t\tinet_del_ifa(ifa->ifa_dev,\n\t\t\t\t\t\t\t     ifap, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tifap = &tmp->ifa_next;\n\t\t\t\t\ttmp = rtnl_dereference(*ifap);\n\t\t\t\t}\n\t\t\t} else if (ifa->ifa_preferred_lft !=\n\t\t\t\t   INFINITY_LIFE_TIME &&\n\t\t\t\t   age >= ifa->ifa_preferred_lft &&\n\t\t\t\t   !(ifa->ifa_flags & IFA_F_DEPRECATED)) {\n\t\t\t\tifa->ifa_flags |= IFA_F_DEPRECATED;\n\t\t\t\trtmsg_ifa(RTM_NEWADDR, ifa, NULL, 0);\n\t\t\t}\n\t\t}\n\t\trtnl_unlock();\n\t}\n\n\tnext_sec = round_jiffies_up(next);\n\tnext_sched = next;\n\n\t \n\tif (time_before(next_sec, next + ADDRCONF_TIMER_FUZZ))\n\t\tnext_sched = next_sec;\n\n\tnow = jiffies;\n\t \n\tif (time_before(next_sched, now + ADDRCONF_TIMER_FUZZ_MAX))\n\t\tnext_sched = now + ADDRCONF_TIMER_FUZZ_MAX;\n\n\tqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work,\n\t\t\tnext_sched - now);\n}\n\nstatic void set_ifa_lifetime(struct in_ifaddr *ifa, __u32 valid_lft,\n\t\t\t     __u32 prefered_lft)\n{\n\tunsigned long timeout;\n\n\tifa->ifa_flags &= ~(IFA_F_PERMANENT | IFA_F_DEPRECATED);\n\n\ttimeout = addrconf_timeout_fixup(valid_lft, HZ);\n\tif (addrconf_finite_timeout(timeout))\n\t\tifa->ifa_valid_lft = timeout;\n\telse\n\t\tifa->ifa_flags |= IFA_F_PERMANENT;\n\n\ttimeout = addrconf_timeout_fixup(prefered_lft, HZ);\n\tif (addrconf_finite_timeout(timeout)) {\n\t\tif (timeout == 0)\n\t\t\tifa->ifa_flags |= IFA_F_DEPRECATED;\n\t\tifa->ifa_preferred_lft = timeout;\n\t}\n\tifa->ifa_tstamp = jiffies;\n\tif (!ifa->ifa_cstamp)\n\t\tifa->ifa_cstamp = ifa->ifa_tstamp;\n}\n\nstatic struct in_ifaddr *rtm_to_ifaddr(struct net *net, struct nlmsghdr *nlh,\n\t\t\t\t       __u32 *pvalid_lft, __u32 *pprefered_lft,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct in_ifaddr *ifa;\n\tstruct ifaddrmsg *ifm;\n\tstruct net_device *dev;\n\tstruct in_device *in_dev;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFA_MAX,\n\t\t\t\t     ifa_ipv4_policy, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tifm = nlmsg_data(nlh);\n\terr = -EINVAL;\n\n\tif (ifm->ifa_prefixlen > 32) {\n\t\tNL_SET_ERR_MSG(extack, \"ipv4: Invalid prefix length\");\n\t\tgoto errout;\n\t}\n\n\tif (!tb[IFA_LOCAL]) {\n\t\tNL_SET_ERR_MSG(extack, \"ipv4: Local address is not supplied\");\n\t\tgoto errout;\n\t}\n\n\tdev = __dev_get_by_index(net, ifm->ifa_index);\n\terr = -ENODEV;\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack, \"ipv4: Device not found\");\n\t\tgoto errout;\n\t}\n\n\tin_dev = __in_dev_get_rtnl(dev);\n\terr = -ENOBUFS;\n\tif (!in_dev)\n\t\tgoto errout;\n\n\tifa = inet_alloc_ifa();\n\tif (!ifa)\n\t\t \n\t\tgoto errout;\n\n\tipv4_devconf_setall(in_dev);\n\tneigh_parms_data_state_setall(in_dev->arp_parms);\n\tin_dev_hold(in_dev);\n\n\tif (!tb[IFA_ADDRESS])\n\t\ttb[IFA_ADDRESS] = tb[IFA_LOCAL];\n\n\tINIT_HLIST_NODE(&ifa->hash);\n\tifa->ifa_prefixlen = ifm->ifa_prefixlen;\n\tifa->ifa_mask = inet_make_mask(ifm->ifa_prefixlen);\n\tifa->ifa_flags = tb[IFA_FLAGS] ? nla_get_u32(tb[IFA_FLAGS]) :\n\t\t\t\t\t ifm->ifa_flags;\n\tifa->ifa_scope = ifm->ifa_scope;\n\tifa->ifa_dev = in_dev;\n\n\tifa->ifa_local = nla_get_in_addr(tb[IFA_LOCAL]);\n\tifa->ifa_address = nla_get_in_addr(tb[IFA_ADDRESS]);\n\n\tif (tb[IFA_BROADCAST])\n\t\tifa->ifa_broadcast = nla_get_in_addr(tb[IFA_BROADCAST]);\n\n\tif (tb[IFA_LABEL])\n\t\tnla_strscpy(ifa->ifa_label, tb[IFA_LABEL], IFNAMSIZ);\n\telse\n\t\tmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\n\n\tif (tb[IFA_RT_PRIORITY])\n\t\tifa->ifa_rt_priority = nla_get_u32(tb[IFA_RT_PRIORITY]);\n\n\tif (tb[IFA_PROTO])\n\t\tifa->ifa_proto = nla_get_u8(tb[IFA_PROTO]);\n\n\tif (tb[IFA_CACHEINFO]) {\n\t\tstruct ifa_cacheinfo *ci;\n\n\t\tci = nla_data(tb[IFA_CACHEINFO]);\n\t\tif (!ci->ifa_valid || ci->ifa_prefered > ci->ifa_valid) {\n\t\t\tNL_SET_ERR_MSG(extack, \"ipv4: address lifetime invalid\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto errout_free;\n\t\t}\n\t\t*pvalid_lft = ci->ifa_valid;\n\t\t*pprefered_lft = ci->ifa_prefered;\n\t}\n\n\treturn ifa;\n\nerrout_free:\n\tinet_free_ifa(ifa);\nerrout:\n\treturn ERR_PTR(err);\n}\n\nstatic struct in_ifaddr *find_matching_ifa(struct in_ifaddr *ifa)\n{\n\tstruct in_device *in_dev = ifa->ifa_dev;\n\tstruct in_ifaddr *ifa1;\n\n\tif (!ifa->ifa_local)\n\t\treturn NULL;\n\n\tin_dev_for_each_ifa_rtnl(ifa1, in_dev) {\n\t\tif (ifa1->ifa_mask == ifa->ifa_mask &&\n\t\t    inet_ifa_match(ifa1->ifa_address, ifa) &&\n\t\t    ifa1->ifa_local == ifa->ifa_local)\n\t\t\treturn ifa1;\n\t}\n\treturn NULL;\n}\n\nstatic int inet_rtm_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct in_ifaddr *ifa;\n\tstruct in_ifaddr *ifa_existing;\n\t__u32 valid_lft = INFINITY_LIFE_TIME;\n\t__u32 prefered_lft = INFINITY_LIFE_TIME;\n\n\tASSERT_RTNL();\n\n\tifa = rtm_to_ifaddr(net, nlh, &valid_lft, &prefered_lft, extack);\n\tif (IS_ERR(ifa))\n\t\treturn PTR_ERR(ifa);\n\n\tifa_existing = find_matching_ifa(ifa);\n\tif (!ifa_existing) {\n\t\t \n\t\tset_ifa_lifetime(ifa, valid_lft, prefered_lft);\n\t\tif (ifa->ifa_flags & IFA_F_MCAUTOJOIN) {\n\t\t\tint ret = ip_mc_autojoin_config(net, true, ifa);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"ipv4: Multicast auto join failed\");\n\t\t\t\tinet_free_ifa(ifa);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\treturn __inet_insert_ifa(ifa, nlh, NETLINK_CB(skb).portid,\n\t\t\t\t\t extack);\n\t} else {\n\t\tu32 new_metric = ifa->ifa_rt_priority;\n\t\tu8 new_proto = ifa->ifa_proto;\n\n\t\tinet_free_ifa(ifa);\n\n\t\tif (nlh->nlmsg_flags & NLM_F_EXCL ||\n\t\t    !(nlh->nlmsg_flags & NLM_F_REPLACE)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"ipv4: Address already assigned\");\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tifa = ifa_existing;\n\n\t\tif (ifa->ifa_rt_priority != new_metric) {\n\t\t\tfib_modify_prefix_metric(ifa, new_metric);\n\t\t\tifa->ifa_rt_priority = new_metric;\n\t\t}\n\n\t\tifa->ifa_proto = new_proto;\n\n\t\tset_ifa_lifetime(ifa, valid_lft, prefered_lft);\n\t\tcancel_delayed_work(&check_lifetime_work);\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&check_lifetime_work, 0);\n\t\trtmsg_ifa(RTM_NEWADDR, ifa, nlh, NETLINK_CB(skb).portid);\n\t}\n\treturn 0;\n}\n\n \n\nstatic int inet_abc_len(__be32 addr)\n{\n\tint rc = -1;\t \n\n\tif (ipv4_is_zeronet(addr) || ipv4_is_lbcast(addr))\n\t\trc = 0;\n\telse {\n\t\t__u32 haddr = ntohl(addr);\n\t\tif (IN_CLASSA(haddr))\n\t\t\trc = 8;\n\t\telse if (IN_CLASSB(haddr))\n\t\t\trc = 16;\n\t\telse if (IN_CLASSC(haddr))\n\t\t\trc = 24;\n\t\telse if (IN_CLASSE(haddr))\n\t\t\trc = 32;\n\t}\n\n\treturn rc;\n}\n\n\nint devinet_ioctl(struct net *net, unsigned int cmd, struct ifreq *ifr)\n{\n\tstruct sockaddr_in sin_orig;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)&ifr->ifr_addr;\n\tstruct in_ifaddr __rcu **ifap = NULL;\n\tstruct in_device *in_dev;\n\tstruct in_ifaddr *ifa = NULL;\n\tstruct net_device *dev;\n\tchar *colon;\n\tint ret = -EFAULT;\n\tint tryaddrmatch = 0;\n\n\tifr->ifr_name[IFNAMSIZ - 1] = 0;\n\n\t \n\tmemcpy(&sin_orig, sin, sizeof(*sin));\n\n\tcolon = strchr(ifr->ifr_name, ':');\n\tif (colon)\n\t\t*colon = 0;\n\n\tdev_load(net, ifr->ifr_name);\n\n\tswitch (cmd) {\n\tcase SIOCGIFADDR:\t \n\tcase SIOCGIFBRDADDR:\t \n\tcase SIOCGIFDSTADDR:\t \n\tcase SIOCGIFNETMASK:\t \n\t\t \n\t\ttryaddrmatch = (sin_orig.sin_family == AF_INET);\n\t\tmemset(sin, 0, sizeof(*sin));\n\t\tsin->sin_family = AF_INET;\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tret = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SIOCSIFADDR:\t \n\tcase SIOCSIFBRDADDR:\t \n\tcase SIOCSIFDSTADDR:\t \n\tcase SIOCSIFNETMASK: \t \n\t\tret = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto out;\n\t\tret = -EINVAL;\n\t\tif (sin->sin_family != AF_INET)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trtnl_lock();\n\n\tret = -ENODEV;\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (!dev)\n\t\tgoto done;\n\n\tif (colon)\n\t\t*colon = ':';\n\n\tin_dev = __in_dev_get_rtnl(dev);\n\tif (in_dev) {\n\t\tif (tryaddrmatch) {\n\t\t\t \n\t\t\t \n\t\t\t \n\n\t\t\tfor (ifap = &in_dev->ifa_list;\n\t\t\t     (ifa = rtnl_dereference(*ifap)) != NULL;\n\t\t\t     ifap = &ifa->ifa_next) {\n\t\t\t\tif (!strcmp(ifr->ifr_name, ifa->ifa_label) &&\n\t\t\t\t    sin_orig.sin_addr.s_addr ==\n\t\t\t\t\t\t\tifa->ifa_local) {\n\t\t\t\t\tbreak;  \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (!ifa) {\n\t\t\tfor (ifap = &in_dev->ifa_list;\n\t\t\t     (ifa = rtnl_dereference(*ifap)) != NULL;\n\t\t\t     ifap = &ifa->ifa_next)\n\t\t\t\tif (!strcmp(ifr->ifr_name, ifa->ifa_label))\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = -EADDRNOTAVAIL;\n\tif (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS)\n\t\tgoto done;\n\n\tswitch (cmd) {\n\tcase SIOCGIFADDR:\t \n\t\tret = 0;\n\t\tsin->sin_addr.s_addr = ifa->ifa_local;\n\t\tbreak;\n\n\tcase SIOCGIFBRDADDR:\t \n\t\tret = 0;\n\t\tsin->sin_addr.s_addr = ifa->ifa_broadcast;\n\t\tbreak;\n\n\tcase SIOCGIFDSTADDR:\t \n\t\tret = 0;\n\t\tsin->sin_addr.s_addr = ifa->ifa_address;\n\t\tbreak;\n\n\tcase SIOCGIFNETMASK:\t \n\t\tret = 0;\n\t\tsin->sin_addr.s_addr = ifa->ifa_mask;\n\t\tbreak;\n\n\tcase SIOCSIFFLAGS:\n\t\tif (colon) {\n\t\t\tret = -EADDRNOTAVAIL;\n\t\t\tif (!ifa)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t\tif (!(ifr->ifr_flags & IFF_UP))\n\t\t\t\tinet_del_ifa(in_dev, ifap, 1);\n\t\t\tbreak;\n\t\t}\n\t\tret = dev_change_flags(dev, ifr->ifr_flags, NULL);\n\t\tbreak;\n\n\tcase SIOCSIFADDR:\t \n\t\tret = -EINVAL;\n\t\tif (inet_abc_len(sin->sin_addr.s_addr) < 0)\n\t\t\tbreak;\n\n\t\tif (!ifa) {\n\t\t\tret = -ENOBUFS;\n\t\t\tifa = inet_alloc_ifa();\n\t\t\tif (!ifa)\n\t\t\t\tbreak;\n\t\t\tINIT_HLIST_NODE(&ifa->hash);\n\t\t\tif (colon)\n\t\t\t\tmemcpy(ifa->ifa_label, ifr->ifr_name, IFNAMSIZ);\n\t\t\telse\n\t\t\t\tmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\n\t\t} else {\n\t\t\tret = 0;\n\t\t\tif (ifa->ifa_local == sin->sin_addr.s_addr)\n\t\t\t\tbreak;\n\t\t\tinet_del_ifa(in_dev, ifap, 0);\n\t\t\tifa->ifa_broadcast = 0;\n\t\t\tifa->ifa_scope = 0;\n\t\t}\n\n\t\tifa->ifa_address = ifa->ifa_local = sin->sin_addr.s_addr;\n\n\t\tif (!(dev->flags & IFF_POINTOPOINT)) {\n\t\t\tifa->ifa_prefixlen = inet_abc_len(ifa->ifa_address);\n\t\t\tifa->ifa_mask = inet_make_mask(ifa->ifa_prefixlen);\n\t\t\tif ((dev->flags & IFF_BROADCAST) &&\n\t\t\t    ifa->ifa_prefixlen < 31)\n\t\t\t\tifa->ifa_broadcast = ifa->ifa_address |\n\t\t\t\t\t\t     ~ifa->ifa_mask;\n\t\t} else {\n\t\t\tifa->ifa_prefixlen = 32;\n\t\t\tifa->ifa_mask = inet_make_mask(32);\n\t\t}\n\t\tset_ifa_lifetime(ifa, INFINITY_LIFE_TIME, INFINITY_LIFE_TIME);\n\t\tret = inet_set_ifa(dev, ifa);\n\t\tbreak;\n\n\tcase SIOCSIFBRDADDR:\t \n\t\tret = 0;\n\t\tif (ifa->ifa_broadcast != sin->sin_addr.s_addr) {\n\t\t\tinet_del_ifa(in_dev, ifap, 0);\n\t\t\tifa->ifa_broadcast = sin->sin_addr.s_addr;\n\t\t\tinet_insert_ifa(ifa);\n\t\t}\n\t\tbreak;\n\n\tcase SIOCSIFDSTADDR:\t \n\t\tret = 0;\n\t\tif (ifa->ifa_address == sin->sin_addr.s_addr)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (inet_abc_len(sin->sin_addr.s_addr) < 0)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tinet_del_ifa(in_dev, ifap, 0);\n\t\tifa->ifa_address = sin->sin_addr.s_addr;\n\t\tinet_insert_ifa(ifa);\n\t\tbreak;\n\n\tcase SIOCSIFNETMASK: \t \n\n\t\t \n\t\tret = -EINVAL;\n\t\tif (bad_mask(sin->sin_addr.s_addr, 0))\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (ifa->ifa_mask != sin->sin_addr.s_addr) {\n\t\t\t__be32 old_mask = ifa->ifa_mask;\n\t\t\tinet_del_ifa(in_dev, ifap, 0);\n\t\t\tifa->ifa_mask = sin->sin_addr.s_addr;\n\t\t\tifa->ifa_prefixlen = inet_mask_len(ifa->ifa_mask);\n\n\t\t\t \n\t\t\tif ((dev->flags & IFF_BROADCAST) &&\n\t\t\t    (ifa->ifa_prefixlen < 31) &&\n\t\t\t    (ifa->ifa_broadcast ==\n\t\t\t     (ifa->ifa_local|~old_mask))) {\n\t\t\t\tifa->ifa_broadcast = (ifa->ifa_local |\n\t\t\t\t\t\t      ~sin->sin_addr.s_addr);\n\t\t\t}\n\t\t\tinet_insert_ifa(ifa);\n\t\t}\n\t\tbreak;\n\t}\ndone:\n\trtnl_unlock();\nout:\n\treturn ret;\n}\n\nint inet_gifconf(struct net_device *dev, char __user *buf, int len, int size)\n{\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\tconst struct in_ifaddr *ifa;\n\tstruct ifreq ifr;\n\tint done = 0;\n\n\tif (WARN_ON(size > sizeof(struct ifreq)))\n\t\tgoto out;\n\n\tif (!in_dev)\n\t\tgoto out;\n\n\tin_dev_for_each_ifa_rtnl(ifa, in_dev) {\n\t\tif (!buf) {\n\t\t\tdone += size;\n\t\t\tcontinue;\n\t\t}\n\t\tif (len < size)\n\t\t\tbreak;\n\t\tmemset(&ifr, 0, sizeof(struct ifreq));\n\t\tstrcpy(ifr.ifr_name, ifa->ifa_label);\n\n\t\t(*(struct sockaddr_in *)&ifr.ifr_addr).sin_family = AF_INET;\n\t\t(*(struct sockaddr_in *)&ifr.ifr_addr).sin_addr.s_addr =\n\t\t\t\t\t\t\t\tifa->ifa_local;\n\n\t\tif (copy_to_user(buf + done, &ifr, size)) {\n\t\t\tdone = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tlen  -= size;\n\t\tdone += size;\n\t}\nout:\n\treturn done;\n}\n\nstatic __be32 in_dev_select_addr(const struct in_device *in_dev,\n\t\t\t\t int scope)\n{\n\tconst struct in_ifaddr *ifa;\n\n\tin_dev_for_each_ifa_rcu(ifa, in_dev) {\n\t\tif (ifa->ifa_flags & IFA_F_SECONDARY)\n\t\t\tcontinue;\n\t\tif (ifa->ifa_scope != RT_SCOPE_LINK &&\n\t\t    ifa->ifa_scope <= scope)\n\t\t\treturn ifa->ifa_local;\n\t}\n\n\treturn 0;\n}\n\n__be32 inet_select_addr(const struct net_device *dev, __be32 dst, int scope)\n{\n\tconst struct in_ifaddr *ifa;\n\t__be32 addr = 0;\n\tunsigned char localnet_scope = RT_SCOPE_HOST;\n\tstruct in_device *in_dev;\n\tstruct net *net = dev_net(dev);\n\tint master_idx;\n\n\trcu_read_lock();\n\tin_dev = __in_dev_get_rcu(dev);\n\tif (!in_dev)\n\t\tgoto no_in_dev;\n\n\tif (unlikely(IN_DEV_ROUTE_LOCALNET(in_dev)))\n\t\tlocalnet_scope = RT_SCOPE_LINK;\n\n\tin_dev_for_each_ifa_rcu(ifa, in_dev) {\n\t\tif (ifa->ifa_flags & IFA_F_SECONDARY)\n\t\t\tcontinue;\n\t\tif (min(ifa->ifa_scope, localnet_scope) > scope)\n\t\t\tcontinue;\n\t\tif (!dst || inet_ifa_match(dst, ifa)) {\n\t\t\taddr = ifa->ifa_local;\n\t\t\tbreak;\n\t\t}\n\t\tif (!addr)\n\t\t\taddr = ifa->ifa_local;\n\t}\n\n\tif (addr)\n\t\tgoto out_unlock;\nno_in_dev:\n\tmaster_idx = l3mdev_master_ifindex_rcu(dev);\n\n\t \n\tif (master_idx &&\n\t    (dev = dev_get_by_index_rcu(net, master_idx)) &&\n\t    (in_dev = __in_dev_get_rcu(dev))) {\n\t\taddr = in_dev_select_addr(in_dev, scope);\n\t\tif (addr)\n\t\t\tgoto out_unlock;\n\t}\n\n\t \n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (l3mdev_master_ifindex_rcu(dev) != master_idx)\n\t\t\tcontinue;\n\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (!in_dev)\n\t\t\tcontinue;\n\n\t\taddr = in_dev_select_addr(in_dev, scope);\n\t\tif (addr)\n\t\t\tgoto out_unlock;\n\t}\nout_unlock:\n\trcu_read_unlock();\n\treturn addr;\n}\nEXPORT_SYMBOL(inet_select_addr);\n\nstatic __be32 confirm_addr_indev(struct in_device *in_dev, __be32 dst,\n\t\t\t      __be32 local, int scope)\n{\n\tunsigned char localnet_scope = RT_SCOPE_HOST;\n\tconst struct in_ifaddr *ifa;\n\t__be32 addr = 0;\n\tint same = 0;\n\n\tif (unlikely(IN_DEV_ROUTE_LOCALNET(in_dev)))\n\t\tlocalnet_scope = RT_SCOPE_LINK;\n\n\tin_dev_for_each_ifa_rcu(ifa, in_dev) {\n\t\tunsigned char min_scope = min(ifa->ifa_scope, localnet_scope);\n\n\t\tif (!addr &&\n\t\t    (local == ifa->ifa_local || !local) &&\n\t\t    min_scope <= scope) {\n\t\t\taddr = ifa->ifa_local;\n\t\t\tif (same)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!same) {\n\t\t\tsame = (!local || inet_ifa_match(local, ifa)) &&\n\t\t\t\t(!dst || inet_ifa_match(dst, ifa));\n\t\t\tif (same && addr) {\n\t\t\t\tif (local || !dst)\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tif (inet_ifa_match(addr, ifa))\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tif (min_scope <= scope) {\n\t\t\t\t\taddr = ifa->ifa_local;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tsame = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn same ? addr : 0;\n}\n\n \n__be32 inet_confirm_addr(struct net *net, struct in_device *in_dev,\n\t\t\t __be32 dst, __be32 local, int scope)\n{\n\t__be32 addr = 0;\n\tstruct net_device *dev;\n\n\tif (in_dev)\n\t\treturn confirm_addr_indev(in_dev, dst, local, scope);\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev) {\n\t\t\taddr = confirm_addr_indev(in_dev, dst, local, scope);\n\t\t\tif (addr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn addr;\n}\nEXPORT_SYMBOL(inet_confirm_addr);\n\n \n\nint register_inetaddr_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&inetaddr_chain, nb);\n}\nEXPORT_SYMBOL(register_inetaddr_notifier);\n\nint unregister_inetaddr_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&inetaddr_chain, nb);\n}\nEXPORT_SYMBOL(unregister_inetaddr_notifier);\n\nint register_inetaddr_validator_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&inetaddr_validator_chain, nb);\n}\nEXPORT_SYMBOL(register_inetaddr_validator_notifier);\n\nint unregister_inetaddr_validator_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&inetaddr_validator_chain,\n\t    nb);\n}\nEXPORT_SYMBOL(unregister_inetaddr_validator_notifier);\n\n \nstatic void inetdev_changename(struct net_device *dev, struct in_device *in_dev)\n{\n\tstruct in_ifaddr *ifa;\n\tint named = 0;\n\n\tin_dev_for_each_ifa_rtnl(ifa, in_dev) {\n\t\tchar old[IFNAMSIZ], *dot;\n\n\t\tmemcpy(old, ifa->ifa_label, IFNAMSIZ);\n\t\tmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\n\t\tif (named++ == 0)\n\t\t\tgoto skip;\n\t\tdot = strchr(old, ':');\n\t\tif (!dot) {\n\t\t\tsprintf(old, \":%d\", named);\n\t\t\tdot = old;\n\t\t}\n\t\tif (strlen(dot) + strlen(dev->name) < IFNAMSIZ)\n\t\t\tstrcat(ifa->ifa_label, dot);\n\t\telse\n\t\t\tstrcpy(ifa->ifa_label + (IFNAMSIZ - strlen(dot) - 1), dot);\nskip:\n\t\trtmsg_ifa(RTM_NEWADDR, ifa, NULL, 0);\n\t}\n}\n\nstatic void inetdev_send_gratuitous_arp(struct net_device *dev,\n\t\t\t\t\tstruct in_device *in_dev)\n\n{\n\tconst struct in_ifaddr *ifa;\n\n\tin_dev_for_each_ifa_rtnl(ifa, in_dev) {\n\t\tarp_send(ARPOP_REQUEST, ETH_P_ARP,\n\t\t\t ifa->ifa_local, dev,\n\t\t\t ifa->ifa_local, NULL,\n\t\t\t dev->dev_addr, NULL);\n\t}\n}\n\n \n\nstatic int inetdev_event(struct notifier_block *this, unsigned long event,\n\t\t\t void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\n\tASSERT_RTNL();\n\n\tif (!in_dev) {\n\t\tif (event == NETDEV_REGISTER) {\n\t\t\tin_dev = inetdev_init(dev);\n\t\t\tif (IS_ERR(in_dev))\n\t\t\t\treturn notifier_from_errno(PTR_ERR(in_dev));\n\t\t\tif (dev->flags & IFF_LOOPBACK) {\n\t\t\t\tIN_DEV_CONF_SET(in_dev, NOXFRM, 1);\n\t\t\t\tIN_DEV_CONF_SET(in_dev, NOPOLICY, 1);\n\t\t\t}\n\t\t} else if (event == NETDEV_CHANGEMTU) {\n\t\t\t \n\t\t\tif (inetdev_valid_mtu(dev->mtu))\n\t\t\t\tin_dev = inetdev_init(dev);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\tpr_debug(\"%s: bug\\n\", __func__);\n\t\tRCU_INIT_POINTER(dev->ip_ptr, NULL);\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\tif (!inetdev_valid_mtu(dev->mtu))\n\t\t\tbreak;\n\t\tif (dev->flags & IFF_LOOPBACK) {\n\t\t\tstruct in_ifaddr *ifa = inet_alloc_ifa();\n\n\t\t\tif (ifa) {\n\t\t\t\tINIT_HLIST_NODE(&ifa->hash);\n\t\t\t\tifa->ifa_local =\n\t\t\t\t  ifa->ifa_address = htonl(INADDR_LOOPBACK);\n\t\t\t\tifa->ifa_prefixlen = 8;\n\t\t\t\tifa->ifa_mask = inet_make_mask(8);\n\t\t\t\tin_dev_hold(in_dev);\n\t\t\t\tifa->ifa_dev = in_dev;\n\t\t\t\tifa->ifa_scope = RT_SCOPE_HOST;\n\t\t\t\tmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\n\t\t\t\tset_ifa_lifetime(ifa, INFINITY_LIFE_TIME,\n\t\t\t\t\t\t INFINITY_LIFE_TIME);\n\t\t\t\tipv4_devconf_setall(in_dev);\n\t\t\t\tneigh_parms_data_state_setall(in_dev->arp_parms);\n\t\t\t\tinet_insert_ifa(ifa);\n\t\t\t}\n\t\t}\n\t\tip_mc_up(in_dev);\n\t\tfallthrough;\n\tcase NETDEV_CHANGEADDR:\n\t\tif (!IN_DEV_ARP_NOTIFY(in_dev))\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase NETDEV_NOTIFY_PEERS:\n\t\t \n\t\tinetdev_send_gratuitous_arp(dev, in_dev);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tip_mc_down(in_dev);\n\t\tbreak;\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\tip_mc_unmap(in_dev);\n\t\tbreak;\n\tcase NETDEV_POST_TYPE_CHANGE:\n\t\tip_mc_remap(in_dev);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tif (inetdev_valid_mtu(dev->mtu))\n\t\t\tbreak;\n\t\t \n\t\tfallthrough;\n\tcase NETDEV_UNREGISTER:\n\t\tinetdev_destroy(in_dev);\n\t\tbreak;\n\tcase NETDEV_CHANGENAME:\n\t\t \n\t\tinetdev_changename(dev, in_dev);\n\n\t\tdevinet_sysctl_unregister(in_dev);\n\t\tdevinet_sysctl_register(in_dev);\n\t\tbreak;\n\t}\nout:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block ip_netdev_notifier = {\n\t.notifier_call = inetdev_event,\n};\n\nstatic size_t inet_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifaddrmsg))\n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(IFNAMSIZ)  \n\t       + nla_total_size(4)   \n\t       + nla_total_size(1)   \n\t       + nla_total_size(4)   \n\t       + nla_total_size(sizeof(struct ifa_cacheinfo));  \n}\n\nstatic inline u32 cstamp_delta(unsigned long cstamp)\n{\n\treturn (cstamp - INITIAL_JIFFIES) * 100UL / HZ;\n}\n\nstatic int put_cacheinfo(struct sk_buff *skb, unsigned long cstamp,\n\t\t\t unsigned long tstamp, u32 preferred, u32 valid)\n{\n\tstruct ifa_cacheinfo ci;\n\n\tci.cstamp = cstamp_delta(cstamp);\n\tci.tstamp = cstamp_delta(tstamp);\n\tci.ifa_prefered = preferred;\n\tci.ifa_valid = valid;\n\n\treturn nla_put(skb, IFA_CACHEINFO, sizeof(ci), &ci);\n}\n\nstatic int inet_fill_ifaddr(struct sk_buff *skb, struct in_ifaddr *ifa,\n\t\t\t    struct inet_fill_args *args)\n{\n\tstruct ifaddrmsg *ifm;\n\tstruct nlmsghdr  *nlh;\n\tu32 preferred, valid;\n\n\tnlh = nlmsg_put(skb, args->portid, args->seq, args->event, sizeof(*ifm),\n\t\t\targs->flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifa_family = AF_INET;\n\tifm->ifa_prefixlen = ifa->ifa_prefixlen;\n\tifm->ifa_flags = ifa->ifa_flags;\n\tifm->ifa_scope = ifa->ifa_scope;\n\tifm->ifa_index = ifa->ifa_dev->dev->ifindex;\n\n\tif (args->netnsid >= 0 &&\n\t    nla_put_s32(skb, IFA_TARGET_NETNSID, args->netnsid))\n\t\tgoto nla_put_failure;\n\n\tif (!(ifm->ifa_flags & IFA_F_PERMANENT)) {\n\t\tpreferred = ifa->ifa_preferred_lft;\n\t\tvalid = ifa->ifa_valid_lft;\n\t\tif (preferred != INFINITY_LIFE_TIME) {\n\t\t\tlong tval = (jiffies - ifa->ifa_tstamp) / HZ;\n\n\t\t\tif (preferred > tval)\n\t\t\t\tpreferred -= tval;\n\t\t\telse\n\t\t\t\tpreferred = 0;\n\t\t\tif (valid != INFINITY_LIFE_TIME) {\n\t\t\t\tif (valid > tval)\n\t\t\t\t\tvalid -= tval;\n\t\t\t\telse\n\t\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpreferred = INFINITY_LIFE_TIME;\n\t\tvalid = INFINITY_LIFE_TIME;\n\t}\n\tif ((ifa->ifa_address &&\n\t     nla_put_in_addr(skb, IFA_ADDRESS, ifa->ifa_address)) ||\n\t    (ifa->ifa_local &&\n\t     nla_put_in_addr(skb, IFA_LOCAL, ifa->ifa_local)) ||\n\t    (ifa->ifa_broadcast &&\n\t     nla_put_in_addr(skb, IFA_BROADCAST, ifa->ifa_broadcast)) ||\n\t    (ifa->ifa_label[0] &&\n\t     nla_put_string(skb, IFA_LABEL, ifa->ifa_label)) ||\n\t    (ifa->ifa_proto &&\n\t     nla_put_u8(skb, IFA_PROTO, ifa->ifa_proto)) ||\n\t    nla_put_u32(skb, IFA_FLAGS, ifa->ifa_flags) ||\n\t    (ifa->ifa_rt_priority &&\n\t     nla_put_u32(skb, IFA_RT_PRIORITY, ifa->ifa_rt_priority)) ||\n\t    put_cacheinfo(skb, ifa->ifa_cstamp, ifa->ifa_tstamp,\n\t\t\t  preferred, valid))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int inet_valid_dump_ifaddr_req(const struct nlmsghdr *nlh,\n\t\t\t\t      struct inet_fill_args *fillargs,\n\t\t\t\t      struct net **tgt_net, struct sock *sk,\n\t\t\t\t      struct netlink_callback *cb)\n{\n\tstruct netlink_ext_ack *extack = cb->extack;\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct ifaddrmsg *ifm;\n\tint err, i;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifm))) {\n\t\tNL_SET_ERR_MSG(extack, \"ipv4: Invalid header for address dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifa_prefixlen || ifm->ifa_flags || ifm->ifa_scope) {\n\t\tNL_SET_ERR_MSG(extack, \"ipv4: Invalid values in header for address dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tfillargs->ifindex = ifm->ifa_index;\n\tif (fillargs->ifindex) {\n\t\tcb->answer_flags |= NLM_F_DUMP_FILTERED;\n\t\tfillargs->flags |= NLM_F_DUMP_FILTERED;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*ifm), tb, IFA_MAX,\n\t\t\t\t\t    ifa_ipv4_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i <= IFA_MAX; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tif (i == IFA_TARGET_NETNSID) {\n\t\t\tstruct net *net;\n\n\t\t\tfillargs->netnsid = nla_get_s32(tb[i]);\n\n\t\t\tnet = rtnl_get_net_ns_capable(sk, fillargs->netnsid);\n\t\t\tif (IS_ERR(net)) {\n\t\t\t\tfillargs->netnsid = -1;\n\t\t\t\tNL_SET_ERR_MSG(extack, \"ipv4: Invalid target network namespace id\");\n\t\t\t\treturn PTR_ERR(net);\n\t\t\t}\n\t\t\t*tgt_net = net;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG(extack, \"ipv4: Unsupported attribute in dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int in_dev_dump_addr(struct in_device *in_dev, struct sk_buff *skb,\n\t\t\t    struct netlink_callback *cb, int s_ip_idx,\n\t\t\t    struct inet_fill_args *fillargs)\n{\n\tstruct in_ifaddr *ifa;\n\tint ip_idx = 0;\n\tint err;\n\n\tin_dev_for_each_ifa_rtnl(ifa, in_dev) {\n\t\tif (ip_idx < s_ip_idx) {\n\t\t\tip_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = inet_fill_ifaddr(skb, ifa, fillargs);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\n\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\n\t\tip_idx++;\n\t}\n\terr = 0;\n\ndone:\n\tcb->args[2] = ip_idx;\n\n\treturn err;\n}\n\nstatic int inet_dump_ifaddr(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct inet_fill_args fillargs = {\n\t\t.portid = NETLINK_CB(cb->skb).portid,\n\t\t.seq = nlh->nlmsg_seq,\n\t\t.event = RTM_NEWADDR,\n\t\t.flags = NLM_F_MULTI,\n\t\t.netnsid = -1,\n\t};\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net *tgt_net = net;\n\tint h, s_h;\n\tint idx, s_idx;\n\tint s_ip_idx;\n\tstruct net_device *dev;\n\tstruct in_device *in_dev;\n\tstruct hlist_head *head;\n\tint err = 0;\n\n\ts_h = cb->args[0];\n\ts_idx = idx = cb->args[1];\n\ts_ip_idx = cb->args[2];\n\n\tif (cb->strict_check) {\n\t\terr = inet_valid_dump_ifaddr_req(nlh, &fillargs, &tgt_net,\n\t\t\t\t\t\t skb->sk, cb);\n\t\tif (err < 0)\n\t\t\tgoto put_tgt_net;\n\n\t\terr = 0;\n\t\tif (fillargs.ifindex) {\n\t\t\tdev = __dev_get_by_index(tgt_net, fillargs.ifindex);\n\t\t\tif (!dev) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto put_tgt_net;\n\t\t\t}\n\n\t\t\tin_dev = __in_dev_get_rtnl(dev);\n\t\t\tif (in_dev) {\n\t\t\t\terr = in_dev_dump_addr(in_dev, skb, cb, s_ip_idx,\n\t\t\t\t\t\t       &fillargs);\n\t\t\t}\n\t\t\tgoto put_tgt_net;\n\t\t}\n\t}\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &tgt_net->dev_index_head[h];\n\t\trcu_read_lock();\n\t\tcb->seq = atomic_read(&tgt_net->ipv4.dev_addr_genid) ^\n\t\t\t  tgt_net->dev_base_seq;\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (h > s_h || idx > s_idx)\n\t\t\t\ts_ip_idx = 0;\n\t\t\tin_dev = __in_dev_get_rcu(dev);\n\t\t\tif (!in_dev)\n\t\t\t\tgoto cont;\n\n\t\t\terr = in_dev_dump_addr(in_dev, skb, cb, s_ip_idx,\n\t\t\t\t\t       &fillargs);\n\t\t\tif (err < 0) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto done;\n\t\t\t}\ncont:\n\t\t\tidx++;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\ndone:\n\tcb->args[0] = h;\n\tcb->args[1] = idx;\nput_tgt_net:\n\tif (fillargs.netnsid >= 0)\n\t\tput_net(tgt_net);\n\n\treturn skb->len ? : err;\n}\n\nstatic void rtmsg_ifa(int event, struct in_ifaddr *ifa, struct nlmsghdr *nlh,\n\t\t      u32 portid)\n{\n\tstruct inet_fill_args fillargs = {\n\t\t.portid = portid,\n\t\t.seq = nlh ? nlh->nlmsg_seq : 0,\n\t\t.event = event,\n\t\t.flags = 0,\n\t\t.netnsid = -1,\n\t};\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\tstruct net *net;\n\n\tnet = dev_net(ifa->ifa_dev->dev);\n\tskb = nlmsg_new(inet_nlmsg_size(), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet_fill_ifaddr(skb, ifa, &fillargs);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, portid, RTNLGRP_IPV4_IFADDR, nlh, GFP_KERNEL);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV4_IFADDR, err);\n}\n\nstatic size_t inet_get_link_af_size(const struct net_device *dev,\n\t\t\t\t    u32 ext_filter_mask)\n{\n\tstruct in_device *in_dev = rcu_dereference_rtnl(dev->ip_ptr);\n\n\tif (!in_dev)\n\t\treturn 0;\n\n\treturn nla_total_size(IPV4_DEVCONF_MAX * 4);  \n}\n\nstatic int inet_fill_link_af(struct sk_buff *skb, const struct net_device *dev,\n\t\t\t     u32 ext_filter_mask)\n{\n\tstruct in_device *in_dev = rcu_dereference_rtnl(dev->ip_ptr);\n\tstruct nlattr *nla;\n\tint i;\n\n\tif (!in_dev)\n\t\treturn -ENODATA;\n\n\tnla = nla_reserve(skb, IFLA_INET_CONF, IPV4_DEVCONF_MAX * 4);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < IPV4_DEVCONF_MAX; i++)\n\t\t((u32 *) nla_data(nla))[i] = in_dev->cnf.data[i];\n\n\treturn 0;\n}\n\nstatic const struct nla_policy inet_af_policy[IFLA_INET_MAX+1] = {\n\t[IFLA_INET_CONF]\t= { .type = NLA_NESTED },\n};\n\nstatic int inet_validate_link_af(const struct net_device *dev,\n\t\t\t\t const struct nlattr *nla,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *a, *tb[IFLA_INET_MAX+1];\n\tint err, rem;\n\n\tif (dev && !__in_dev_get_rtnl(dev))\n\t\treturn -EAFNOSUPPORT;\n\n\terr = nla_parse_nested_deprecated(tb, IFLA_INET_MAX, nla,\n\t\t\t\t\t  inet_af_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_INET_CONF]) {\n\t\tnla_for_each_nested(a, tb[IFLA_INET_CONF], rem) {\n\t\t\tint cfgid = nla_type(a);\n\n\t\t\tif (nla_len(a) < 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (cfgid <= 0 || cfgid > IPV4_DEVCONF_MAX)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int inet_set_link_af(struct net_device *dev, const struct nlattr *nla,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\tstruct nlattr *a, *tb[IFLA_INET_MAX+1];\n\tint rem;\n\n\tif (!in_dev)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (nla_parse_nested_deprecated(tb, IFLA_INET_MAX, nla, NULL, NULL) < 0)\n\t\treturn -EINVAL;\n\n\tif (tb[IFLA_INET_CONF]) {\n\t\tnla_for_each_nested(a, tb[IFLA_INET_CONF], rem)\n\t\t\tipv4_devconf_set(in_dev, nla_type(a), nla_get_u32(a));\n\t}\n\n\treturn 0;\n}\n\nstatic int inet_netconf_msgsize_devconf(int type)\n{\n\tint size = NLMSG_ALIGN(sizeof(struct netconfmsg))\n\t\t   + nla_total_size(4);\t \n\tbool all = false;\n\n\tif (type == NETCONFA_ALL)\n\t\tall = true;\n\n\tif (all || type == NETCONFA_FORWARDING)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_RP_FILTER)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_MC_FORWARDING)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_BC_FORWARDING)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_PROXY_NEIGH)\n\t\tsize += nla_total_size(4);\n\tif (all || type == NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN)\n\t\tsize += nla_total_size(4);\n\n\treturn size;\n}\n\nstatic int inet_netconf_fill_devconf(struct sk_buff *skb, int ifindex,\n\t\t\t\t     struct ipv4_devconf *devconf, u32 portid,\n\t\t\t\t     u32 seq, int event, unsigned int flags,\n\t\t\t\t     int type)\n{\n\tstruct nlmsghdr  *nlh;\n\tstruct netconfmsg *ncm;\n\tbool all = false;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct netconfmsg),\n\t\t\tflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tif (type == NETCONFA_ALL)\n\t\tall = true;\n\n\tncm = nlmsg_data(nlh);\n\tncm->ncm_family = AF_INET;\n\n\tif (nla_put_s32(skb, NETCONFA_IFINDEX, ifindex) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (!devconf)\n\t\tgoto out;\n\n\tif ((all || type == NETCONFA_FORWARDING) &&\n\t    nla_put_s32(skb, NETCONFA_FORWARDING,\n\t\t\tIPV4_DEVCONF(*devconf, FORWARDING)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_RP_FILTER) &&\n\t    nla_put_s32(skb, NETCONFA_RP_FILTER,\n\t\t\tIPV4_DEVCONF(*devconf, RP_FILTER)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_MC_FORWARDING) &&\n\t    nla_put_s32(skb, NETCONFA_MC_FORWARDING,\n\t\t\tIPV4_DEVCONF(*devconf, MC_FORWARDING)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_BC_FORWARDING) &&\n\t    nla_put_s32(skb, NETCONFA_BC_FORWARDING,\n\t\t\tIPV4_DEVCONF(*devconf, BC_FORWARDING)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_PROXY_NEIGH) &&\n\t    nla_put_s32(skb, NETCONFA_PROXY_NEIGH,\n\t\t\tIPV4_DEVCONF(*devconf, PROXY_ARP)) < 0)\n\t\tgoto nla_put_failure;\n\tif ((all || type == NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN) &&\n\t    nla_put_s32(skb, NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\tIPV4_DEVCONF(*devconf, IGNORE_ROUTES_WITH_LINKDOWN)) < 0)\n\t\tgoto nla_put_failure;\n\nout:\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nvoid inet_netconf_notify_devconf(struct net *net, int event, int type,\n\t\t\t\t int ifindex, struct ipv4_devconf *devconf)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(inet_netconf_msgsize_devconf(type), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet_netconf_fill_devconf(skb, ifindex, devconf, 0, 0,\n\t\t\t\t\tevent, 0, type);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV4_NETCONF, NULL, GFP_KERNEL);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV4_NETCONF, err);\n}\n\nstatic const struct nla_policy devconf_ipv4_policy[NETCONFA_MAX+1] = {\n\t[NETCONFA_IFINDEX]\t= { .len = sizeof(int) },\n\t[NETCONFA_FORWARDING]\t= { .len = sizeof(int) },\n\t[NETCONFA_RP_FILTER]\t= { .len = sizeof(int) },\n\t[NETCONFA_PROXY_NEIGH]\t= { .len = sizeof(int) },\n\t[NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN]\t= { .len = sizeof(int) },\n};\n\nstatic int inet_netconf_valid_get_req(struct sk_buff *skb,\n\t\t\t\t      const struct nlmsghdr *nlh,\n\t\t\t\t      struct nlattr **tb,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint i, err;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(struct netconfmsg))) {\n\t\tNL_SET_ERR_MSG(extack, \"ipv4: Invalid header for netconf get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(struct netconfmsg),\n\t\t\t\t\t      tb, NETCONFA_MAX,\n\t\t\t\t\t      devconf_ipv4_policy, extack);\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(struct netconfmsg),\n\t\t\t\t\t    tb, NETCONFA_MAX,\n\t\t\t\t\t    devconf_ipv4_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <= NETCONFA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NETCONFA_IFINDEX:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG(extack, \"ipv4: Unsupported attribute in netconf get request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int inet_netconf_get_devconf(struct sk_buff *in_skb,\n\t\t\t\t    struct nlmsghdr *nlh,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NETCONFA_MAX+1];\n\tstruct sk_buff *skb;\n\tstruct ipv4_devconf *devconf;\n\tstruct in_device *in_dev;\n\tstruct net_device *dev;\n\tint ifindex;\n\tint err;\n\n\terr = inet_netconf_valid_get_req(in_skb, nlh, tb, extack);\n\tif (err)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\tif (!tb[NETCONFA_IFINDEX])\n\t\tgoto errout;\n\n\tifindex = nla_get_s32(tb[NETCONFA_IFINDEX]);\n\tswitch (ifindex) {\n\tcase NETCONFA_IFINDEX_ALL:\n\t\tdevconf = net->ipv4.devconf_all;\n\t\tbreak;\n\tcase NETCONFA_IFINDEX_DEFAULT:\n\t\tdevconf = net->ipv4.devconf_dflt;\n\t\tbreak;\n\tdefault:\n\t\tdev = __dev_get_by_index(net, ifindex);\n\t\tif (!dev)\n\t\t\tgoto errout;\n\t\tin_dev = __in_dev_get_rtnl(dev);\n\t\tif (!in_dev)\n\t\t\tgoto errout;\n\t\tdevconf = &in_dev->cnf;\n\t\tbreak;\n\t}\n\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(inet_netconf_msgsize_devconf(NETCONFA_ALL), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet_netconf_fill_devconf(skb, ifindex, devconf,\n\t\t\t\t\tNETLINK_CB(in_skb).portid,\n\t\t\t\t\tnlh->nlmsg_seq, RTM_NEWNETCONF, 0,\n\t\t\t\t\tNETCONFA_ALL);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n}\n\nstatic int inet_netconf_dump_devconf(struct sk_buff *skb,\n\t\t\t\t     struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tint h, s_h;\n\tint idx, s_idx;\n\tstruct net_device *dev;\n\tstruct in_device *in_dev;\n\tstruct hlist_head *head;\n\n\tif (cb->strict_check) {\n\t\tstruct netlink_ext_ack *extack = cb->extack;\n\t\tstruct netconfmsg *ncm;\n\n\t\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ncm))) {\n\t\t\tNL_SET_ERR_MSG(extack, \"ipv4: Invalid header for netconf dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (nlmsg_attrlen(nlh, sizeof(*ncm))) {\n\t\t\tNL_SET_ERR_MSG(extack, \"ipv4: Invalid data after header in netconf dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ts_h = cb->args[0];\n\ts_idx = idx = cb->args[1];\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\trcu_read_lock();\n\t\tcb->seq = atomic_read(&net->ipv4.dev_addr_genid) ^\n\t\t\t  net->dev_base_seq;\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tin_dev = __in_dev_get_rcu(dev);\n\t\t\tif (!in_dev)\n\t\t\t\tgoto cont;\n\n\t\t\tif (inet_netconf_fill_devconf(skb, dev->ifindex,\n\t\t\t\t\t\t      &in_dev->cnf,\n\t\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t      nlh->nlmsg_seq,\n\t\t\t\t\t\t      RTM_NEWNETCONF,\n\t\t\t\t\t\t      NLM_F_MULTI,\n\t\t\t\t\t\t      NETCONFA_ALL) < 0) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (h == NETDEV_HASHENTRIES) {\n\t\tif (inet_netconf_fill_devconf(skb, NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t      net->ipv4.devconf_all,\n\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t      nlh->nlmsg_seq,\n\t\t\t\t\t      RTM_NEWNETCONF, NLM_F_MULTI,\n\t\t\t\t\t      NETCONFA_ALL) < 0)\n\t\t\tgoto done;\n\t\telse\n\t\t\th++;\n\t}\n\tif (h == NETDEV_HASHENTRIES + 1) {\n\t\tif (inet_netconf_fill_devconf(skb, NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t\t      net->ipv4.devconf_dflt,\n\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t      nlh->nlmsg_seq,\n\t\t\t\t\t      RTM_NEWNETCONF, NLM_F_MULTI,\n\t\t\t\t\t      NETCONFA_ALL) < 0)\n\t\t\tgoto done;\n\t\telse\n\t\t\th++;\n\t}\ndone:\n\tcb->args[0] = h;\n\tcb->args[1] = idx;\n\n\treturn skb->len;\n}\n\n#ifdef CONFIG_SYSCTL\n\nstatic void devinet_copy_dflt_conf(struct net *net, int i)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tstruct in_device *in_dev;\n\n\t\tin_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !test_bit(i, in_dev->cnf.state))\n\t\t\tin_dev->cnf.data[i] = net->ipv4.devconf_dflt->data[i];\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void inet_forward_change(struct net *net)\n{\n\tstruct net_device *dev;\n\tint on = IPV4_DEVCONF_ALL(net, FORWARDING);\n\n\tIPV4_DEVCONF_ALL(net, ACCEPT_REDIRECTS) = !on;\n\tIPV4_DEVCONF_DFLT(net, FORWARDING) = on;\n\tinet_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t    NETCONFA_FORWARDING,\n\t\t\t\t    NETCONFA_IFINDEX_ALL,\n\t\t\t\t    net->ipv4.devconf_all);\n\tinet_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t    NETCONFA_FORWARDING,\n\t\t\t\t    NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t    net->ipv4.devconf_dflt);\n\n\tfor_each_netdev(net, dev) {\n\t\tstruct in_device *in_dev;\n\n\t\tif (on)\n\t\t\tdev_disable_lro(dev);\n\n\t\tin_dev = __in_dev_get_rtnl(dev);\n\t\tif (in_dev) {\n\t\t\tIN_DEV_CONF_SET(in_dev, FORWARDING, on);\n\t\t\tinet_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t    NETCONFA_FORWARDING,\n\t\t\t\t\t\t    dev->ifindex, &in_dev->cnf);\n\t\t}\n\t}\n}\n\nstatic int devinet_conf_ifindex(struct net *net, struct ipv4_devconf *cnf)\n{\n\tif (cnf == net->ipv4.devconf_dflt)\n\t\treturn NETCONFA_IFINDEX_DEFAULT;\n\telse if (cnf == net->ipv4.devconf_all)\n\t\treturn NETCONFA_IFINDEX_ALL;\n\telse {\n\t\tstruct in_device *idev\n\t\t\t= container_of(cnf, struct in_device, cnf);\n\t\treturn idev->dev->ifindex;\n\t}\n}\n\nstatic int devinet_conf_proc(struct ctl_table *ctl, int write,\n\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint old_value = *(int *)ctl->data;\n\tint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\tint new_value = *(int *)ctl->data;\n\n\tif (write) {\n\t\tstruct ipv4_devconf *cnf = ctl->extra1;\n\t\tstruct net *net = ctl->extra2;\n\t\tint i = (int *)ctl->data - cnf->data;\n\t\tint ifindex;\n\n\t\tset_bit(i, cnf->state);\n\n\t\tif (cnf == net->ipv4.devconf_dflt)\n\t\t\tdevinet_copy_dflt_conf(net, i);\n\t\tif (i == IPV4_DEVCONF_ACCEPT_LOCAL - 1 ||\n\t\t    i == IPV4_DEVCONF_ROUTE_LOCALNET - 1)\n\t\t\tif ((new_value == 0) && (old_value != 0))\n\t\t\t\trt_cache_flush(net);\n\n\t\tif (i == IPV4_DEVCONF_BC_FORWARDING - 1 &&\n\t\t    new_value != old_value)\n\t\t\trt_cache_flush(net);\n\n\t\tif (i == IPV4_DEVCONF_RP_FILTER - 1 &&\n\t\t    new_value != old_value) {\n\t\t\tifindex = devinet_conf_ifindex(net, cnf);\n\t\t\tinet_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t    NETCONFA_RP_FILTER,\n\t\t\t\t\t\t    ifindex, cnf);\n\t\t}\n\t\tif (i == IPV4_DEVCONF_PROXY_ARP - 1 &&\n\t\t    new_value != old_value) {\n\t\t\tifindex = devinet_conf_ifindex(net, cnf);\n\t\t\tinet_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t    NETCONFA_PROXY_NEIGH,\n\t\t\t\t\t\t    ifindex, cnf);\n\t\t}\n\t\tif (i == IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN - 1 &&\n\t\t    new_value != old_value) {\n\t\t\tifindex = devinet_conf_ifindex(net, cnf);\n\t\t\tinet_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t    NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\t\t\t\t    ifindex, cnf);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int devinet_sysctl_forward(struct ctl_table *ctl, int write,\n\t\t\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = ctl->data;\n\tint val = *valp;\n\tloff_t pos = *ppos;\n\tstruct net *net = ctl->extra2;\n\tint ret;\n\n\tif (write && !ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\tif (write && *valp != val) {\n\t\tif (valp != &IPV4_DEVCONF_DFLT(net, FORWARDING)) {\n\t\t\tif (!rtnl_trylock()) {\n\t\t\t\t \n\t\t\t\t*valp = val;\n\t\t\t\t*ppos = pos;\n\t\t\t\treturn restart_syscall();\n\t\t\t}\n\t\t\tif (valp == &IPV4_DEVCONF_ALL(net, FORWARDING)) {\n\t\t\t\tinet_forward_change(net);\n\t\t\t} else {\n\t\t\t\tstruct ipv4_devconf *cnf = ctl->extra1;\n\t\t\t\tstruct in_device *idev =\n\t\t\t\t\tcontainer_of(cnf, struct in_device, cnf);\n\t\t\t\tif (*valp)\n\t\t\t\t\tdev_disable_lro(idev->dev);\n\t\t\t\tinet_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t\t    NETCONFA_FORWARDING,\n\t\t\t\t\t\t\t    idev->dev->ifindex,\n\t\t\t\t\t\t\t    cnf);\n\t\t\t}\n\t\t\trtnl_unlock();\n\t\t\trt_cache_flush(net);\n\t\t} else\n\t\t\tinet_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t    NETCONFA_FORWARDING,\n\t\t\t\t\t\t    NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t\t\t    net->ipv4.devconf_dflt);\n\t}\n\n\treturn ret;\n}\n\nstatic int ipv4_doint_and_flush(struct ctl_table *ctl, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = ctl->data;\n\tint val = *valp;\n\tint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\tstruct net *net = ctl->extra2;\n\n\tif (write && *valp != val)\n\t\trt_cache_flush(net);\n\n\treturn ret;\n}\n\n#define DEVINET_SYSCTL_ENTRY(attr, name, mval, proc) \\\n\t{ \\\n\t\t.procname\t= name, \\\n\t\t.data\t\t= ipv4_devconf.data + \\\n\t\t\t\t  IPV4_DEVCONF_ ## attr - 1, \\\n\t\t.maxlen\t\t= sizeof(int), \\\n\t\t.mode\t\t= mval, \\\n\t\t.proc_handler\t= proc, \\\n\t\t.extra1\t\t= &ipv4_devconf, \\\n\t}\n\n#define DEVINET_SYSCTL_RW_ENTRY(attr, name) \\\n\tDEVINET_SYSCTL_ENTRY(attr, name, 0644, devinet_conf_proc)\n\n#define DEVINET_SYSCTL_RO_ENTRY(attr, name) \\\n\tDEVINET_SYSCTL_ENTRY(attr, name, 0444, devinet_conf_proc)\n\n#define DEVINET_SYSCTL_COMPLEX_ENTRY(attr, name, proc) \\\n\tDEVINET_SYSCTL_ENTRY(attr, name, 0644, proc)\n\n#define DEVINET_SYSCTL_FLUSHING_ENTRY(attr, name) \\\n\tDEVINET_SYSCTL_COMPLEX_ENTRY(attr, name, ipv4_doint_and_flush)\n\nstatic struct devinet_sysctl_table {\n\tstruct ctl_table_header *sysctl_header;\n\tstruct ctl_table devinet_vars[__IPV4_DEVCONF_MAX];\n} devinet_sysctl = {\n\t.devinet_vars = {\n\t\tDEVINET_SYSCTL_COMPLEX_ENTRY(FORWARDING, \"forwarding\",\n\t\t\t\t\t     devinet_sysctl_forward),\n\t\tDEVINET_SYSCTL_RO_ENTRY(MC_FORWARDING, \"mc_forwarding\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(BC_FORWARDING, \"bc_forwarding\"),\n\n\t\tDEVINET_SYSCTL_RW_ENTRY(ACCEPT_REDIRECTS, \"accept_redirects\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(SECURE_REDIRECTS, \"secure_redirects\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(SHARED_MEDIA, \"shared_media\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(RP_FILTER, \"rp_filter\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(SEND_REDIRECTS, \"send_redirects\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ACCEPT_SOURCE_ROUTE,\n\t\t\t\t\t\"accept_source_route\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ACCEPT_LOCAL, \"accept_local\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(SRC_VMARK, \"src_valid_mark\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(PROXY_ARP, \"proxy_arp\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(MEDIUM_ID, \"medium_id\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(BOOTP_RELAY, \"bootp_relay\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(LOG_MARTIANS, \"log_martians\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(TAG, \"tag\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARPFILTER, \"arp_filter\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_ANNOUNCE, \"arp_announce\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_IGNORE, \"arp_ignore\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_ACCEPT, \"arp_accept\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_NOTIFY, \"arp_notify\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(ARP_EVICT_NOCARRIER,\n\t\t\t\t\t\"arp_evict_nocarrier\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(PROXY_ARP_PVLAN, \"proxy_arp_pvlan\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(FORCE_IGMP_VERSION,\n\t\t\t\t\t\"force_igmp_version\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(IGMPV2_UNSOLICITED_REPORT_INTERVAL,\n\t\t\t\t\t\"igmpv2_unsolicited_report_interval\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(IGMPV3_UNSOLICITED_REPORT_INTERVAL,\n\t\t\t\t\t\"igmpv3_unsolicited_report_interval\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\t\t\t\"ignore_routes_with_linkdown\"),\n\t\tDEVINET_SYSCTL_RW_ENTRY(DROP_GRATUITOUS_ARP,\n\t\t\t\t\t\"drop_gratuitous_arp\"),\n\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(NOXFRM, \"disable_xfrm\"),\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(NOPOLICY, \"disable_policy\"),\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(PROMOTE_SECONDARIES,\n\t\t\t\t\t      \"promote_secondaries\"),\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(ROUTE_LOCALNET,\n\t\t\t\t\t      \"route_localnet\"),\n\t\tDEVINET_SYSCTL_FLUSHING_ENTRY(DROP_UNICAST_IN_L2_MULTICAST,\n\t\t\t\t\t      \"drop_unicast_in_l2_multicast\"),\n\t},\n};\n\nstatic int __devinet_sysctl_register(struct net *net, char *dev_name,\n\t\t\t\t     int ifindex, struct ipv4_devconf *p)\n{\n\tint i;\n\tstruct devinet_sysctl_table *t;\n\tchar path[sizeof(\"net/ipv4/conf/\") + IFNAMSIZ];\n\n\tt = kmemdup(&devinet_sysctl, sizeof(*t), GFP_KERNEL_ACCOUNT);\n\tif (!t)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(t->devinet_vars) - 1; i++) {\n\t\tt->devinet_vars[i].data += (char *)p - (char *)&ipv4_devconf;\n\t\tt->devinet_vars[i].extra1 = p;\n\t\tt->devinet_vars[i].extra2 = net;\n\t}\n\n\tsnprintf(path, sizeof(path), \"net/ipv4/conf/%s\", dev_name);\n\n\tt->sysctl_header = register_net_sysctl(net, path, t->devinet_vars);\n\tif (!t->sysctl_header)\n\t\tgoto free;\n\n\tp->sysctl = t;\n\n\tinet_netconf_notify_devconf(net, RTM_NEWNETCONF, NETCONFA_ALL,\n\t\t\t\t    ifindex, p);\n\treturn 0;\n\nfree:\n\tkfree(t);\nout:\n\treturn -ENOMEM;\n}\n\nstatic void __devinet_sysctl_unregister(struct net *net,\n\t\t\t\t\tstruct ipv4_devconf *cnf, int ifindex)\n{\n\tstruct devinet_sysctl_table *t = cnf->sysctl;\n\n\tif (t) {\n\t\tcnf->sysctl = NULL;\n\t\tunregister_net_sysctl_table(t->sysctl_header);\n\t\tkfree(t);\n\t}\n\n\tinet_netconf_notify_devconf(net, RTM_DELNETCONF, 0, ifindex, NULL);\n}\n\nstatic int devinet_sysctl_register(struct in_device *idev)\n{\n\tint err;\n\n\tif (!sysctl_dev_name_is_allowed(idev->dev->name))\n\t\treturn -EINVAL;\n\n\terr = neigh_sysctl_register(idev->dev, idev->arp_parms, NULL);\n\tif (err)\n\t\treturn err;\n\terr = __devinet_sysctl_register(dev_net(idev->dev), idev->dev->name,\n\t\t\t\t\tidev->dev->ifindex, &idev->cnf);\n\tif (err)\n\t\tneigh_sysctl_unregister(idev->arp_parms);\n\treturn err;\n}\n\nstatic void devinet_sysctl_unregister(struct in_device *idev)\n{\n\tstruct net *net = dev_net(idev->dev);\n\n\t__devinet_sysctl_unregister(net, &idev->cnf, idev->dev->ifindex);\n\tneigh_sysctl_unregister(idev->arp_parms);\n}\n\nstatic struct ctl_table ctl_forward_entry[] = {\n\t{\n\t\t.procname\t= \"ip_forward\",\n\t\t.data\t\t= &ipv4_devconf.data[\n\t\t\t\t\tIPV4_DEVCONF_FORWARDING - 1],\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= devinet_sysctl_forward,\n\t\t.extra1\t\t= &ipv4_devconf,\n\t\t.extra2\t\t= &init_net,\n\t},\n\t{ },\n};\n#endif\n\nstatic __net_init int devinet_init_net(struct net *net)\n{\n\tint err;\n\tstruct ipv4_devconf *all, *dflt;\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\tstruct ctl_table_header *forw_hdr;\n#endif\n\n\terr = -ENOMEM;\n\tall = kmemdup(&ipv4_devconf, sizeof(ipv4_devconf), GFP_KERNEL);\n\tif (!all)\n\t\tgoto err_alloc_all;\n\n\tdflt = kmemdup(&ipv4_devconf_dflt, sizeof(ipv4_devconf_dflt), GFP_KERNEL);\n\tif (!dflt)\n\t\tgoto err_alloc_dflt;\n\n#ifdef CONFIG_SYSCTL\n\ttbl = kmemdup(ctl_forward_entry, sizeof(ctl_forward_entry), GFP_KERNEL);\n\tif (!tbl)\n\t\tgoto err_alloc_ctl;\n\n\ttbl[0].data = &all->data[IPV4_DEVCONF_FORWARDING - 1];\n\ttbl[0].extra1 = all;\n\ttbl[0].extra2 = net;\n#endif\n\n\tif (!net_eq(net, &init_net)) {\n\t\tswitch (net_inherit_devconf()) {\n\t\tcase 3:\n\t\t\t \n\t\t\tmemcpy(all, current->nsproxy->net_ns->ipv4.devconf_all,\n\t\t\t       sizeof(ipv4_devconf));\n\t\t\tmemcpy(dflt,\n\t\t\t       current->nsproxy->net_ns->ipv4.devconf_dflt,\n\t\t\t       sizeof(ipv4_devconf_dflt));\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase 1:\n\t\t\t \n\t\t\tmemcpy(all, init_net.ipv4.devconf_all,\n\t\t\t       sizeof(ipv4_devconf));\n\t\t\tmemcpy(dflt, init_net.ipv4.devconf_dflt,\n\t\t\t       sizeof(ipv4_devconf_dflt));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef CONFIG_SYSCTL\n\terr = __devinet_sysctl_register(net, \"all\", NETCONFA_IFINDEX_ALL, all);\n\tif (err < 0)\n\t\tgoto err_reg_all;\n\n\terr = __devinet_sysctl_register(net, \"default\",\n\t\t\t\t\tNETCONFA_IFINDEX_DEFAULT, dflt);\n\tif (err < 0)\n\t\tgoto err_reg_dflt;\n\n\terr = -ENOMEM;\n\tforw_hdr = register_net_sysctl_sz(net, \"net/ipv4\", tbl,\n\t\t\t\t\t  ARRAY_SIZE(ctl_forward_entry));\n\tif (!forw_hdr)\n\t\tgoto err_reg_ctl;\n\tnet->ipv4.forw_hdr = forw_hdr;\n#endif\n\n\tnet->ipv4.devconf_all = all;\n\tnet->ipv4.devconf_dflt = dflt;\n\treturn 0;\n\n#ifdef CONFIG_SYSCTL\nerr_reg_ctl:\n\t__devinet_sysctl_unregister(net, dflt, NETCONFA_IFINDEX_DEFAULT);\nerr_reg_dflt:\n\t__devinet_sysctl_unregister(net, all, NETCONFA_IFINDEX_ALL);\nerr_reg_all:\n\tkfree(tbl);\nerr_alloc_ctl:\n#endif\n\tkfree(dflt);\nerr_alloc_dflt:\n\tkfree(all);\nerr_alloc_all:\n\treturn err;\n}\n\nstatic __net_exit void devinet_exit_net(struct net *net)\n{\n#ifdef CONFIG_SYSCTL\n\tstruct ctl_table *tbl;\n\n\ttbl = net->ipv4.forw_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(net->ipv4.forw_hdr);\n\t__devinet_sysctl_unregister(net, net->ipv4.devconf_dflt,\n\t\t\t\t    NETCONFA_IFINDEX_DEFAULT);\n\t__devinet_sysctl_unregister(net, net->ipv4.devconf_all,\n\t\t\t\t    NETCONFA_IFINDEX_ALL);\n\tkfree(tbl);\n#endif\n\tkfree(net->ipv4.devconf_dflt);\n\tkfree(net->ipv4.devconf_all);\n}\n\nstatic __net_initdata struct pernet_operations devinet_ops = {\n\t.init = devinet_init_net,\n\t.exit = devinet_exit_net,\n};\n\nstatic struct rtnl_af_ops inet_af_ops __read_mostly = {\n\t.family\t\t  = AF_INET,\n\t.fill_link_af\t  = inet_fill_link_af,\n\t.get_link_af_size = inet_get_link_af_size,\n\t.validate_link_af = inet_validate_link_af,\n\t.set_link_af\t  = inet_set_link_af,\n};\n\nvoid __init devinet_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < IN4_ADDR_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&inet_addr_lst[i]);\n\n\tregister_pernet_subsys(&devinet_ops);\n\tregister_netdevice_notifier(&ip_netdev_notifier);\n\n\tqueue_delayed_work(system_power_efficient_wq, &check_lifetime_work, 0);\n\n\trtnl_af_register(&inet_af_ops);\n\n\trtnl_register(PF_INET, RTM_NEWADDR, inet_rtm_newaddr, NULL, 0);\n\trtnl_register(PF_INET, RTM_DELADDR, inet_rtm_deladdr, NULL, 0);\n\trtnl_register(PF_INET, RTM_GETADDR, NULL, inet_dump_ifaddr, 0);\n\trtnl_register(PF_INET, RTM_GETNETCONF, inet_netconf_get_devconf,\n\t\t      inet_netconf_dump_devconf, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}