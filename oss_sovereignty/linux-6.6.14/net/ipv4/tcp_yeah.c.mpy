{
  "module_name": "tcp_yeah.c",
  "hash_id": "9bf70b40c5f9d8a38b6c31af4c8dda5816029670ac1e516b707d8689ee83b499",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_yeah.c",
  "human_readable_source": "\n \n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/inet_diag.h>\n\n#include <net/tcp.h>\n\n#include \"tcp_vegas.h\"\n\n#define TCP_YEAH_ALPHA       80  \n#define TCP_YEAH_GAMMA        1  \n#define TCP_YEAH_DELTA        3  \n#define TCP_YEAH_EPSILON      1  \n#define TCP_YEAH_PHY          8  \n#define TCP_YEAH_RHO         16  \n#define TCP_YEAH_ZETA        50  \n\n#define TCP_SCALABLE_AI_CNT\t 100U\n\n \nstruct yeah {\n\tstruct vegas vegas;\t \n\n\t \n\tu32 lastQ;\n\tu32 doing_reno_now;\n\n\tu32 reno_count;\n\tu32 fast_count;\n};\n\nstatic void tcp_yeah_init(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct yeah *yeah = inet_csk_ca(sk);\n\n\ttcp_vegas_init(sk);\n\n\tyeah->doing_reno_now = 0;\n\tyeah->lastQ = 0;\n\n\tyeah->reno_count = 2;\n\n\t \n\ttp->snd_cwnd_clamp = min_t(u32, tp->snd_cwnd_clamp, 0xffffffff/128);\n}\n\nstatic void tcp_yeah_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct yeah *yeah = inet_csk_ca(sk);\n\n\tif (!tcp_is_cwnd_limited(sk))\n\t\treturn;\n\n\tif (tcp_in_slow_start(tp)) {\n\t\tacked = tcp_slow_start(tp, acked);\n\t\tif (!acked)\n\t\t\tgoto do_vegas;\n\t}\n\n\tif (!yeah->doing_reno_now) {\n\t\t \n\t\ttcp_cong_avoid_ai(tp, min(tcp_snd_cwnd(tp), TCP_SCALABLE_AI_CNT),\n\t\t\t\t  acked);\n\t} else {\n\t\t \n\t\ttcp_cong_avoid_ai(tp, tcp_snd_cwnd(tp), acked);\n\t}\n\n\t \ndo_vegas:\n\tif (after(ack, yeah->vegas.beg_snd_nxt)) {\n\t\t \n\n\t\tif (yeah->vegas.cntRTT > 2) {\n\t\t\tu32 rtt, queue;\n\t\t\tu64 bw;\n\n\t\t\t \n\n\t\t\t \n\t\t\trtt = yeah->vegas.minRTT;\n\n\t\t\t \n\t\t\tbw = tcp_snd_cwnd(tp);\n\t\t\tbw *= rtt - yeah->vegas.baseRTT;\n\t\t\tdo_div(bw, rtt);\n\t\t\tqueue = bw;\n\n\t\t\tif (queue > TCP_YEAH_ALPHA ||\n\t\t\t    rtt - yeah->vegas.baseRTT > (yeah->vegas.baseRTT / TCP_YEAH_PHY)) {\n\t\t\t\tif (queue > TCP_YEAH_ALPHA &&\n\t\t\t\t    tcp_snd_cwnd(tp) > yeah->reno_count) {\n\t\t\t\t\tu32 reduction = min(queue / TCP_YEAH_GAMMA ,\n\t\t\t\t\t\t\t    tcp_snd_cwnd(tp) >> TCP_YEAH_EPSILON);\n\n\t\t\t\t\ttcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) - reduction);\n\n\t\t\t\t\ttcp_snd_cwnd_set(tp, max(tcp_snd_cwnd(tp),\n\t\t\t\t\t\t\t\t yeah->reno_count));\n\n\t\t\t\t\ttp->snd_ssthresh = tcp_snd_cwnd(tp);\n\t\t\t\t}\n\n\t\t\t\tif (yeah->reno_count <= 2)\n\t\t\t\t\tyeah->reno_count = max(tcp_snd_cwnd(tp)>>1, 2U);\n\t\t\t\telse\n\t\t\t\t\tyeah->reno_count++;\n\n\t\t\t\tyeah->doing_reno_now = min(yeah->doing_reno_now + 1,\n\t\t\t\t\t\t\t   0xffffffU);\n\t\t\t} else {\n\t\t\t\tyeah->fast_count++;\n\n\t\t\t\tif (yeah->fast_count > TCP_YEAH_ZETA) {\n\t\t\t\t\tyeah->reno_count = 2;\n\t\t\t\t\tyeah->fast_count = 0;\n\t\t\t\t}\n\n\t\t\t\tyeah->doing_reno_now = 0;\n\t\t\t}\n\n\t\t\tyeah->lastQ = queue;\n\t\t}\n\n\t\t \n\t\tyeah->vegas.beg_snd_una  = yeah->vegas.beg_snd_nxt;\n\t\tyeah->vegas.beg_snd_nxt  = tp->snd_nxt;\n\t\tyeah->vegas.beg_snd_cwnd = tcp_snd_cwnd(tp);\n\n\t\t \n\t\tyeah->vegas.cntRTT = 0;\n\t\tyeah->vegas.minRTT = 0x7fffffff;\n\t}\n}\n\nstatic u32 tcp_yeah_ssthresh(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct yeah *yeah = inet_csk_ca(sk);\n\tu32 reduction;\n\n\tif (yeah->doing_reno_now < TCP_YEAH_RHO) {\n\t\treduction = yeah->lastQ;\n\n\t\treduction = min(reduction, max(tcp_snd_cwnd(tp)>>1, 2U));\n\n\t\treduction = max(reduction, tcp_snd_cwnd(tp) >> TCP_YEAH_DELTA);\n\t} else\n\t\treduction = max(tcp_snd_cwnd(tp)>>1, 2U);\n\n\tyeah->fast_count = 0;\n\tyeah->reno_count = max(yeah->reno_count>>1, 2U);\n\n\treturn max_t(int, tcp_snd_cwnd(tp) - reduction, 2);\n}\n\nstatic struct tcp_congestion_ops tcp_yeah __read_mostly = {\n\t.init\t\t= tcp_yeah_init,\n\t.ssthresh\t= tcp_yeah_ssthresh,\n\t.undo_cwnd      = tcp_reno_undo_cwnd,\n\t.cong_avoid\t= tcp_yeah_cong_avoid,\n\t.set_state\t= tcp_vegas_state,\n\t.cwnd_event\t= tcp_vegas_cwnd_event,\n\t.get_info\t= tcp_vegas_get_info,\n\t.pkts_acked\t= tcp_vegas_pkts_acked,\n\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"yeah\",\n};\n\nstatic int __init tcp_yeah_register(void)\n{\n\tBUILD_BUG_ON(sizeof(struct yeah) > ICSK_CA_PRIV_SIZE);\n\ttcp_register_congestion_control(&tcp_yeah);\n\treturn 0;\n}\n\nstatic void __exit tcp_yeah_unregister(void)\n{\n\ttcp_unregister_congestion_control(&tcp_yeah);\n}\n\nmodule_init(tcp_yeah_register);\nmodule_exit(tcp_yeah_unregister);\n\nMODULE_AUTHOR(\"Angelo P. Castellani\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"YeAH TCP\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}