{
  "module_name": "tcp_timer.c",
  "hash_id": "7f1c7280881f4b4aca15d14872dbe8b6ef8116f174dbe9dc684988e3ac3963f5",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_timer.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <net/tcp.h>\n\nstatic u32 tcp_clamp_rto_to_user_timeout(const struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tu32 elapsed, start_ts, user_timeout;\n\ts32 remaining;\n\n\tstart_ts = tcp_sk(sk)->retrans_stamp;\n\tuser_timeout = READ_ONCE(icsk->icsk_user_timeout);\n\tif (!user_timeout)\n\t\treturn icsk->icsk_rto;\n\telapsed = tcp_time_stamp(tcp_sk(sk)) - start_ts;\n\tremaining = user_timeout - elapsed;\n\tif (remaining <= 0)\n\t\treturn 1;  \n\n\treturn min_t(u32, icsk->icsk_rto, msecs_to_jiffies(remaining));\n}\n\nu32 tcp_clamp_probe0_to_user_timeout(const struct sock *sk, u32 when)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tu32 remaining, user_timeout;\n\ts32 elapsed;\n\n\tuser_timeout = READ_ONCE(icsk->icsk_user_timeout);\n\tif (!user_timeout || !icsk->icsk_probes_tstamp)\n\t\treturn when;\n\n\telapsed = tcp_jiffies32 - icsk->icsk_probes_tstamp;\n\tif (unlikely(elapsed < 0))\n\t\telapsed = 0;\n\tremaining = msecs_to_jiffies(user_timeout) - elapsed;\n\tremaining = max_t(u32, remaining, TCP_TIMEOUT_MIN);\n\n\treturn min_t(u32, remaining, when);\n}\n\n \n\nstatic void tcp_write_err(struct sock *sk)\n{\n\tWRITE_ONCE(sk->sk_err, READ_ONCE(sk->sk_err_soft) ? : ETIMEDOUT);\n\tsk_error_report(sk);\n\n\ttcp_write_queue_purge(sk);\n\ttcp_done(sk);\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONTIMEOUT);\n}\n\n \nstatic int tcp_out_of_resources(struct sock *sk, bool do_reset)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint shift = 0;\n\n\t \n\tif ((s32)(tcp_jiffies32 - tp->lsndtime) > 2*TCP_RTO_MAX || !do_reset)\n\t\tshift++;\n\n\t \n\tif (READ_ONCE(sk->sk_err_soft))\n\t\tshift++;\n\n\tif (tcp_check_oom(sk, shift)) {\n\t\t \n\t\tif ((s32)(tcp_jiffies32 - tp->lsndtime) <= TCP_TIMEWAIT_LEN ||\n\t\t     \n\t\t    (!tp->snd_wnd && !tp->packets_out))\n\t\t\tdo_reset = true;\n\t\tif (do_reset)\n\t\t\ttcp_send_active_reset(sk, GFP_ATOMIC);\n\t\ttcp_done(sk);\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPABORTONMEMORY);\n\t\treturn 1;\n\t}\n\n\tif (!check_net(sock_net(sk))) {\n\t\t \n\t\ttcp_done(sk);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int tcp_orphan_retries(struct sock *sk, bool alive)\n{\n\tint retries = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_orphan_retries);  \n\n\t \n\tif (READ_ONCE(sk->sk_err_soft) && !alive)\n\t\tretries = 0;\n\n\t \n\tif (retries == 0 && alive)\n\t\tretries = 8;\n\treturn retries;\n}\n\nstatic void tcp_mtu_probing(struct inet_connection_sock *icsk, struct sock *sk)\n{\n\tconst struct net *net = sock_net(sk);\n\tint mss;\n\n\t \n\tif (!READ_ONCE(net->ipv4.sysctl_tcp_mtu_probing))\n\t\treturn;\n\n\tif (!icsk->icsk_mtup.enabled) {\n\t\ticsk->icsk_mtup.enabled = 1;\n\t\ticsk->icsk_mtup.probe_timestamp = tcp_jiffies32;\n\t} else {\n\t\tmss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;\n\t\tmss = min(READ_ONCE(net->ipv4.sysctl_tcp_base_mss), mss);\n\t\tmss = max(mss, READ_ONCE(net->ipv4.sysctl_tcp_mtu_probe_floor));\n\t\tmss = max(mss, READ_ONCE(net->ipv4.sysctl_tcp_min_snd_mss));\n\t\ticsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);\n\t}\n\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n}\n\nstatic unsigned int tcp_model_timeout(struct sock *sk,\n\t\t\t\t      unsigned int boundary,\n\t\t\t\t      unsigned int rto_base)\n{\n\tunsigned int linear_backoff_thresh, timeout;\n\n\tlinear_backoff_thresh = ilog2(TCP_RTO_MAX / rto_base);\n\tif (boundary <= linear_backoff_thresh)\n\t\ttimeout = ((2 << boundary) - 1) * rto_base;\n\telse\n\t\ttimeout = ((2 << linear_backoff_thresh) - 1) * rto_base +\n\t\t\t(boundary - linear_backoff_thresh) * TCP_RTO_MAX;\n\treturn jiffies_to_msecs(timeout);\n}\n \nstatic bool retransmits_timed_out(struct sock *sk,\n\t\t\t\t  unsigned int boundary,\n\t\t\t\t  unsigned int timeout)\n{\n\tunsigned int start_ts;\n\n\tif (!inet_csk(sk)->icsk_retransmits)\n\t\treturn false;\n\n\tstart_ts = tcp_sk(sk)->retrans_stamp;\n\tif (likely(timeout == 0)) {\n\t\tunsigned int rto_base = TCP_RTO_MIN;\n\n\t\tif ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV))\n\t\t\trto_base = tcp_timeout_init(sk);\n\t\ttimeout = tcp_model_timeout(sk, boundary, rto_base);\n\t}\n\n\treturn (s32)(tcp_time_stamp(tcp_sk(sk)) - start_ts - timeout) >= 0;\n}\n\n \nstatic int tcp_write_timeout(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tbool expired = false, do_reset;\n\tint retry_until, max_retransmits;\n\n\tif ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV)) {\n\t\tif (icsk->icsk_retransmits)\n\t\t\t__dst_negative_advice(sk);\n\t\t \n\t\tretry_until = READ_ONCE(icsk->icsk_syn_retries) ? :\n\t\t\tREAD_ONCE(net->ipv4.sysctl_tcp_syn_retries);\n\n\t\tmax_retransmits = retry_until;\n\t\tif (sk->sk_state == TCP_SYN_SENT)\n\t\t\tmax_retransmits += READ_ONCE(net->ipv4.sysctl_tcp_syn_linear_timeouts);\n\n\t\texpired = icsk->icsk_retransmits >= max_retransmits;\n\t} else {\n\t\tif (retransmits_timed_out(sk, READ_ONCE(net->ipv4.sysctl_tcp_retries1), 0)) {\n\t\t\t \n\t\t\ttcp_mtu_probing(icsk, sk);\n\n\t\t\t__dst_negative_advice(sk);\n\t\t}\n\n\t\tretry_until = READ_ONCE(net->ipv4.sysctl_tcp_retries2);\n\t\tif (sock_flag(sk, SOCK_DEAD)) {\n\t\t\tconst bool alive = icsk->icsk_rto < TCP_RTO_MAX;\n\n\t\t\tretry_until = tcp_orphan_retries(sk, alive);\n\t\t\tdo_reset = alive ||\n\t\t\t\t!retransmits_timed_out(sk, retry_until, 0);\n\n\t\t\tif (tcp_out_of_resources(sk, do_reset))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\tif (!expired)\n\t\texpired = retransmits_timed_out(sk, retry_until,\n\t\t\t\t\t\tREAD_ONCE(icsk->icsk_user_timeout));\n\ttcp_fastopen_active_detect_blackhole(sk, expired);\n\n\tif (BPF_SOCK_OPS_TEST_FLAG(tp, BPF_SOCK_OPS_RTO_CB_FLAG))\n\t\ttcp_call_bpf_3arg(sk, BPF_SOCK_OPS_RTO_CB,\n\t\t\t\t  icsk->icsk_retransmits,\n\t\t\t\t  icsk->icsk_rto, (int)expired);\n\n\tif (expired) {\n\t\t \n\t\ttcp_write_err(sk);\n\t\treturn 1;\n\t}\n\n\tif (sk_rethink_txhash(sk)) {\n\t\ttp->timeout_rehash++;\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPTIMEOUTREHASH);\n\t}\n\n\treturn 0;\n}\n\n \nvoid tcp_delack_timer_handler(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif ((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))\n\t\treturn;\n\n\t \n\tif (tp->compressed_ack) {\n\t\ttcp_mstamp_refresh(tp);\n\t\ttcp_sack_compress_send_ack(sk);\n\t\treturn;\n\t}\n\n\tif (!(icsk->icsk_ack.pending & ICSK_ACK_TIMER))\n\t\treturn;\n\n\tif (time_after(icsk->icsk_ack.timeout, jiffies)) {\n\t\tsk_reset_timer(sk, &icsk->icsk_delack_timer, icsk->icsk_ack.timeout);\n\t\treturn;\n\t}\n\ticsk->icsk_ack.pending &= ~ICSK_ACK_TIMER;\n\n\tif (inet_csk_ack_scheduled(sk)) {\n\t\tif (!inet_csk_in_pingpong_mode(sk)) {\n\t\t\t \n\t\t\ticsk->icsk_ack.ato = min(icsk->icsk_ack.ato << 1, icsk->icsk_rto);\n\t\t} else {\n\t\t\t \n\t\t\tinet_csk_exit_pingpong_mode(sk);\n\t\t\ticsk->icsk_ack.ato      = TCP_ATO_MIN;\n\t\t}\n\t\ttcp_mstamp_refresh(tp);\n\t\ttcp_send_ack(sk);\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKS);\n\t}\n}\n\n\n \nstatic void tcp_delack_timer(struct timer_list *t)\n{\n\tstruct inet_connection_sock *icsk =\n\t\t\tfrom_timer(icsk, t, icsk_delack_timer);\n\tstruct sock *sk = &icsk->icsk_inet.sk;\n\n\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk)) {\n\t\ttcp_delack_timer_handler(sk);\n\t} else {\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_DELAYEDACKLOCKED);\n\t\t \n\t\tif (!test_and_set_bit(TCP_DELACK_TIMER_DEFERRED, &sk->sk_tsq_flags))\n\t\t\tsock_hold(sk);\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\nstatic void tcp_probe_timer(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct sk_buff *skb = tcp_send_head(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint max_probes;\n\n\tif (tp->packets_out || !skb) {\n\t\ticsk->icsk_probes_out = 0;\n\t\ticsk->icsk_probes_tstamp = 0;\n\t\treturn;\n\t}\n\n\t \n\tif (!icsk->icsk_probes_tstamp) {\n\t\ticsk->icsk_probes_tstamp = tcp_jiffies32;\n\t} else {\n\t\tu32 user_timeout = READ_ONCE(icsk->icsk_user_timeout);\n\n\t\tif (user_timeout &&\n\t\t    (s32)(tcp_jiffies32 - icsk->icsk_probes_tstamp) >=\n\t\t     msecs_to_jiffies(user_timeout))\n\t\tgoto abort;\n\t}\n\tmax_probes = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_retries2);\n\tif (sock_flag(sk, SOCK_DEAD)) {\n\t\tconst bool alive = inet_csk_rto_backoff(icsk, TCP_RTO_MAX) < TCP_RTO_MAX;\n\n\t\tmax_probes = tcp_orphan_retries(sk, alive);\n\t\tif (!alive && icsk->icsk_backoff >= max_probes)\n\t\t\tgoto abort;\n\t\tif (tcp_out_of_resources(sk, true))\n\t\t\treturn;\n\t}\n\n\tif (icsk->icsk_probes_out >= max_probes) {\nabort:\t\ttcp_write_err(sk);\n\t} else {\n\t\t \n\t\ttcp_send_probe0(sk);\n\t}\n}\n\n \nstatic void tcp_fastopen_synack_timer(struct sock *sk, struct request_sock *req)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint max_retries;\n\n\treq->rsk_ops->syn_ack_timeout(req);\n\n\t \n\tmax_retries = READ_ONCE(icsk->icsk_syn_retries) ? :\n\t\tREAD_ONCE(sock_net(sk)->ipv4.sysctl_tcp_synack_retries) + 1;\n\n\tif (req->num_timeout >= max_retries) {\n\t\ttcp_write_err(sk);\n\t\treturn;\n\t}\n\t \n\tif (icsk->icsk_retransmits == 1)\n\t\ttcp_enter_loss(sk);\n\t \n\tinet_rtx_syn_ack(sk, req);\n\treq->num_timeout++;\n\ticsk->icsk_retransmits++;\n\tif (!tp->retrans_stamp)\n\t\ttp->retrans_stamp = tcp_time_stamp(tp);\n\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,\n\t\t\t  req->timeout << req->num_timeout, TCP_RTO_MAX);\n}\n\nstatic bool tcp_rtx_probe0_timed_out(const struct sock *sk,\n\t\t\t\t     const struct sk_buff *skb)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst int timeout = TCP_RTO_MAX * 2;\n\tu32 rcv_delta, rtx_delta;\n\n\trcv_delta = inet_csk(sk)->icsk_timeout - tp->rcv_tstamp;\n\tif (rcv_delta <= timeout)\n\t\treturn false;\n\n\trtx_delta = (u32)msecs_to_jiffies(tcp_time_stamp(tp) -\n\t\t\t(tp->retrans_stamp ?: tcp_skb_timestamp(skb)));\n\n\treturn rtx_delta > timeout;\n}\n\n \nvoid tcp_retransmit_timer(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct request_sock *req;\n\tstruct sk_buff *skb;\n\n\treq = rcu_dereference_protected(tp->fastopen_rsk,\n\t\t\t\t\tlockdep_sock_is_held(sk));\n\tif (req) {\n\t\tWARN_ON_ONCE(sk->sk_state != TCP_SYN_RECV &&\n\t\t\t     sk->sk_state != TCP_FIN_WAIT1);\n\t\ttcp_fastopen_synack_timer(sk, req);\n\t\t \n\t\treturn;\n\t}\n\n\tif (!tp->packets_out)\n\t\treturn;\n\n\tskb = tcp_rtx_queue_head(sk);\n\tif (WARN_ON_ONCE(!skb))\n\t\treturn;\n\n\ttp->tlp_high_seq = 0;\n\n\tif (!tp->snd_wnd && !sock_flag(sk, SOCK_DEAD) &&\n\t    !((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV))) {\n\t\t \n\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\tu32 rtx_delta;\n\n\t\trtx_delta = tcp_time_stamp(tp) - (tp->retrans_stamp ?: tcp_skb_timestamp(skb));\n\t\tif (sk->sk_family == AF_INET) {\n\t\t\tnet_dbg_ratelimited(\"Probing zero-window on %pI4:%u/%u, seq=%u:%u, recv %ums ago, lasting %ums\\n\",\n\t\t\t\t&inet->inet_daddr, ntohs(inet->inet_dport),\n\t\t\t\tinet->inet_num, tp->snd_una, tp->snd_nxt,\n\t\t\t\tjiffies_to_msecs(jiffies - tp->rcv_tstamp),\n\t\t\t\trtx_delta);\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse if (sk->sk_family == AF_INET6) {\n\t\t\tnet_dbg_ratelimited(\"Probing zero-window on %pI6:%u/%u, seq=%u:%u, recv %ums ago, lasting %ums\\n\",\n\t\t\t\t&sk->sk_v6_daddr, ntohs(inet->inet_dport),\n\t\t\t\tinet->inet_num, tp->snd_una, tp->snd_nxt,\n\t\t\t\tjiffies_to_msecs(jiffies - tp->rcv_tstamp),\n\t\t\t\trtx_delta);\n\t\t}\n#endif\n\t\tif (tcp_rtx_probe0_timed_out(sk, skb)) {\n\t\t\ttcp_write_err(sk);\n\t\t\tgoto out;\n\t\t}\n\t\ttcp_enter_loss(sk);\n\t\ttcp_retransmit_skb(sk, skb, 1);\n\t\t__sk_dst_reset(sk);\n\t\tgoto out_reset_timer;\n\t}\n\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPTIMEOUTS);\n\tif (tcp_write_timeout(sk))\n\t\tgoto out;\n\n\tif (icsk->icsk_retransmits == 0) {\n\t\tint mib_idx = 0;\n\n\t\tif (icsk->icsk_ca_state == TCP_CA_Recovery) {\n\t\t\tif (tcp_is_sack(tp))\n\t\t\t\tmib_idx = LINUX_MIB_TCPSACKRECOVERYFAIL;\n\t\t\telse\n\t\t\t\tmib_idx = LINUX_MIB_TCPRENORECOVERYFAIL;\n\t\t} else if (icsk->icsk_ca_state == TCP_CA_Loss) {\n\t\t\tmib_idx = LINUX_MIB_TCPLOSSFAILURES;\n\t\t} else if ((icsk->icsk_ca_state == TCP_CA_Disorder) ||\n\t\t\t   tp->sacked_out) {\n\t\t\tif (tcp_is_sack(tp))\n\t\t\t\tmib_idx = LINUX_MIB_TCPSACKFAILURES;\n\t\t\telse\n\t\t\t\tmib_idx = LINUX_MIB_TCPRENOFAILURES;\n\t\t}\n\t\tif (mib_idx)\n\t\t\t__NET_INC_STATS(sock_net(sk), mib_idx);\n\t}\n\n\ttcp_enter_loss(sk);\n\n\ticsk->icsk_retransmits++;\n\tif (tcp_retransmit_skb(sk, tcp_rtx_queue_head(sk), 1) > 0) {\n\t\t \n\t\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,\n\t\t\t\t\t  TCP_RESOURCE_PROBE_INTERVAL,\n\t\t\t\t\t  TCP_RTO_MAX);\n\t\tgoto out;\n\t}\n\n\t \n\ticsk->icsk_backoff++;\n\nout_reset_timer:\n\t \n\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t    (tp->thin_lto || READ_ONCE(net->ipv4.sysctl_tcp_thin_linear_timeouts)) &&\n\t    tcp_stream_is_thin(tp) &&\n\t    icsk->icsk_retransmits <= TCP_THIN_LINEAR_RETRIES) {\n\t\ticsk->icsk_backoff = 0;\n\t\ticsk->icsk_rto = clamp(__tcp_set_rto(tp),\n\t\t\t\t       tcp_rto_min(sk),\n\t\t\t\t       TCP_RTO_MAX);\n\t} else if (sk->sk_state != TCP_SYN_SENT ||\n\t\t   icsk->icsk_backoff >\n\t\t   READ_ONCE(net->ipv4.sysctl_tcp_syn_linear_timeouts)) {\n\t\t \n\t\ticsk->icsk_rto = min(icsk->icsk_rto << 1, TCP_RTO_MAX);\n\t}\n\tinet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,\n\t\t\t\t  tcp_clamp_rto_to_user_timeout(sk), TCP_RTO_MAX);\n\tif (retransmits_timed_out(sk, READ_ONCE(net->ipv4.sysctl_tcp_retries1) + 1, 0))\n\t\t__sk_dst_reset(sk);\n\nout:;\n}\n\n \nvoid tcp_write_timer_handler(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tint event;\n\n\tif (((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN)) ||\n\t    !icsk->icsk_pending)\n\t\treturn;\n\n\tif (time_after(icsk->icsk_timeout, jiffies)) {\n\t\tsk_reset_timer(sk, &icsk->icsk_retransmit_timer, icsk->icsk_timeout);\n\t\treturn;\n\t}\n\n\ttcp_mstamp_refresh(tcp_sk(sk));\n\tevent = icsk->icsk_pending;\n\n\tswitch (event) {\n\tcase ICSK_TIME_REO_TIMEOUT:\n\t\ttcp_rack_reo_timeout(sk);\n\t\tbreak;\n\tcase ICSK_TIME_LOSS_PROBE:\n\t\ttcp_send_loss_probe(sk);\n\t\tbreak;\n\tcase ICSK_TIME_RETRANS:\n\t\ticsk->icsk_pending = 0;\n\t\ttcp_retransmit_timer(sk);\n\t\tbreak;\n\tcase ICSK_TIME_PROBE0:\n\t\ticsk->icsk_pending = 0;\n\t\ttcp_probe_timer(sk);\n\t\tbreak;\n\t}\n}\n\nstatic void tcp_write_timer(struct timer_list *t)\n{\n\tstruct inet_connection_sock *icsk =\n\t\t\tfrom_timer(icsk, t, icsk_retransmit_timer);\n\tstruct sock *sk = &icsk->icsk_inet.sk;\n\n\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk)) {\n\t\ttcp_write_timer_handler(sk);\n\t} else {\n\t\t \n\t\tif (!test_and_set_bit(TCP_WRITE_TIMER_DEFERRED, &sk->sk_tsq_flags))\n\t\t\tsock_hold(sk);\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\nvoid tcp_syn_ack_timeout(const struct request_sock *req)\n{\n\tstruct net *net = read_pnet(&inet_rsk(req)->ireq_net);\n\n\t__NET_INC_STATS(net, LINUX_MIB_TCPTIMEOUTS);\n}\nEXPORT_SYMBOL(tcp_syn_ack_timeout);\n\nvoid tcp_set_keepalive(struct sock *sk, int val)\n{\n\tif ((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))\n\t\treturn;\n\n\tif (val && !sock_flag(sk, SOCK_KEEPOPEN))\n\t\tinet_csk_reset_keepalive_timer(sk, keepalive_time_when(tcp_sk(sk)));\n\telse if (!val)\n\t\tinet_csk_delete_keepalive_timer(sk);\n}\nEXPORT_SYMBOL_GPL(tcp_set_keepalive);\n\n\nstatic void tcp_keepalive_timer (struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 elapsed;\n\n\t \n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\t \n\t\tinet_csk_reset_keepalive_timer (sk, HZ/20);\n\t\tgoto out;\n\t}\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tpr_err(\"Hmm... keepalive on a LISTEN ???\\n\");\n\t\tgoto out;\n\t}\n\n\ttcp_mstamp_refresh(tp);\n\tif (sk->sk_state == TCP_FIN_WAIT2 && sock_flag(sk, SOCK_DEAD)) {\n\t\tif (READ_ONCE(tp->linger2) >= 0) {\n\t\t\tconst int tmo = tcp_fin_time(sk) - TCP_TIMEWAIT_LEN;\n\n\t\t\tif (tmo > 0) {\n\t\t\t\ttcp_time_wait(sk, TCP_FIN_WAIT2, tmo);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ttcp_send_active_reset(sk, GFP_ATOMIC);\n\t\tgoto death;\n\t}\n\n\tif (!sock_flag(sk, SOCK_KEEPOPEN) ||\n\t    ((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_SYN_SENT)))\n\t\tgoto out;\n\n\telapsed = keepalive_time_when(tp);\n\n\t \n\tif (tp->packets_out || !tcp_write_queue_empty(sk))\n\t\tgoto resched;\n\n\telapsed = keepalive_time_elapsed(tp);\n\n\tif (elapsed >= keepalive_time_when(tp)) {\n\t\tu32 user_timeout = READ_ONCE(icsk->icsk_user_timeout);\n\n\t\t \n\t\tif ((user_timeout != 0 &&\n\t\t    elapsed >= msecs_to_jiffies(user_timeout) &&\n\t\t    icsk->icsk_probes_out > 0) ||\n\t\t    (user_timeout == 0 &&\n\t\t    icsk->icsk_probes_out >= keepalive_probes(tp))) {\n\t\t\ttcp_send_active_reset(sk, GFP_ATOMIC);\n\t\t\ttcp_write_err(sk);\n\t\t\tgoto out;\n\t\t}\n\t\tif (tcp_write_wakeup(sk, LINUX_MIB_TCPKEEPALIVE) <= 0) {\n\t\t\ticsk->icsk_probes_out++;\n\t\t\telapsed = keepalive_intvl_when(tp);\n\t\t} else {\n\t\t\t \n\t\t\telapsed = TCP_RESOURCE_PROBE_INTERVAL;\n\t\t}\n\t} else {\n\t\t \n\t\telapsed = keepalive_time_when(tp) - elapsed;\n\t}\n\nresched:\n\tinet_csk_reset_keepalive_timer (sk, elapsed);\n\tgoto out;\n\ndeath:\n\ttcp_done(sk);\n\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\nstatic enum hrtimer_restart tcp_compressed_ack_kick(struct hrtimer *timer)\n{\n\tstruct tcp_sock *tp = container_of(timer, struct tcp_sock, compressed_ack_timer);\n\tstruct sock *sk = (struct sock *)tp;\n\n\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (tp->compressed_ack) {\n\t\t\t \n\t\t\ttp->compressed_ack--;\n\t\t\ttcp_send_ack(sk);\n\t\t}\n\t} else {\n\t\tif (!test_and_set_bit(TCP_DELACK_TIMER_DEFERRED,\n\t\t\t\t      &sk->sk_tsq_flags))\n\t\t\tsock_hold(sk);\n\t}\n\tbh_unlock_sock(sk);\n\n\tsock_put(sk);\n\n\treturn HRTIMER_NORESTART;\n}\n\nvoid tcp_init_xmit_timers(struct sock *sk)\n{\n\tinet_csk_init_xmit_timers(sk, &tcp_write_timer, &tcp_delack_timer,\n\t\t\t\t  &tcp_keepalive_timer);\n\thrtimer_init(&tcp_sk(sk)->pacing_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_ABS_PINNED_SOFT);\n\ttcp_sk(sk)->pacing_timer.function = tcp_pace_kick;\n\n\thrtimer_init(&tcp_sk(sk)->compressed_ack_timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_REL_PINNED_SOFT);\n\ttcp_sk(sk)->compressed_ack_timer.function = tcp_compressed_ack_kick;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}