{
  "module_name": "arp.c",
  "hash_id": "fe7f397f12c37903ed899c18697aaf887b01015ce18e96d1ef11cc5b75853c08",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/arp.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/capability.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/mm.h>\n#include <linux/inet.h>\n#include <linux/inetdevice.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/fddidevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/stat.h>\n#include <linux/init.h>\n#include <linux/net.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\n#include <net/net_namespace.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/route.h>\n#include <net/protocol.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <net/arp.h>\n#include <net/ax25.h>\n#include <net/netrom.h>\n#include <net/dst_metadata.h>\n#include <net/ip_tunnels.h>\n\n#include <linux/uaccess.h>\n\n#include <linux/netfilter_arp.h>\n\n \nstatic u32 arp_hash(const void *pkey, const struct net_device *dev, __u32 *hash_rnd);\nstatic bool arp_key_eq(const struct neighbour *n, const void *pkey);\nstatic int arp_constructor(struct neighbour *neigh);\nstatic void arp_solicit(struct neighbour *neigh, struct sk_buff *skb);\nstatic void arp_error_report(struct neighbour *neigh, struct sk_buff *skb);\nstatic void parp_redo(struct sk_buff *skb);\nstatic int arp_is_multicast(const void *pkey);\n\nstatic const struct neigh_ops arp_generic_ops = {\n\t.family =\t\tAF_INET,\n\t.solicit =\t\tarp_solicit,\n\t.error_report =\t\tarp_error_report,\n\t.output =\t\tneigh_resolve_output,\n\t.connected_output =\tneigh_connected_output,\n};\n\nstatic const struct neigh_ops arp_hh_ops = {\n\t.family =\t\tAF_INET,\n\t.solicit =\t\tarp_solicit,\n\t.error_report =\t\tarp_error_report,\n\t.output =\t\tneigh_resolve_output,\n\t.connected_output =\tneigh_resolve_output,\n};\n\nstatic const struct neigh_ops arp_direct_ops = {\n\t.family =\t\tAF_INET,\n\t.output =\t\tneigh_direct_output,\n\t.connected_output =\tneigh_direct_output,\n};\n\nstruct neigh_table arp_tbl = {\n\t.family\t\t= AF_INET,\n\t.key_len\t= 4,\n\t.protocol\t= cpu_to_be16(ETH_P_IP),\n\t.hash\t\t= arp_hash,\n\t.key_eq\t\t= arp_key_eq,\n\t.constructor\t= arp_constructor,\n\t.proxy_redo\t= parp_redo,\n\t.is_multicast\t= arp_is_multicast,\n\t.id\t\t= \"arp_cache\",\n\t.parms\t\t= {\n\t\t.tbl\t\t\t= &arp_tbl,\n\t\t.reachable_time\t\t= 30 * HZ,\n\t\t.data\t= {\n\t\t\t[NEIGH_VAR_MCAST_PROBES] = 3,\n\t\t\t[NEIGH_VAR_UCAST_PROBES] = 3,\n\t\t\t[NEIGH_VAR_RETRANS_TIME] = 1 * HZ,\n\t\t\t[NEIGH_VAR_BASE_REACHABLE_TIME] = 30 * HZ,\n\t\t\t[NEIGH_VAR_DELAY_PROBE_TIME] = 5 * HZ,\n\t\t\t[NEIGH_VAR_INTERVAL_PROBE_TIME_MS] = 5 * HZ,\n\t\t\t[NEIGH_VAR_GC_STALETIME] = 60 * HZ,\n\t\t\t[NEIGH_VAR_QUEUE_LEN_BYTES] = SK_WMEM_MAX,\n\t\t\t[NEIGH_VAR_PROXY_QLEN] = 64,\n\t\t\t[NEIGH_VAR_ANYCAST_DELAY] = 1 * HZ,\n\t\t\t[NEIGH_VAR_PROXY_DELAY]\t= (8 * HZ) / 10,\n\t\t\t[NEIGH_VAR_LOCKTIME] = 1 * HZ,\n\t\t},\n\t},\n\t.gc_interval\t= 30 * HZ,\n\t.gc_thresh1\t= 128,\n\t.gc_thresh2\t= 512,\n\t.gc_thresh3\t= 1024,\n};\nEXPORT_SYMBOL(arp_tbl);\n\nint arp_mc_map(__be32 addr, u8 *haddr, struct net_device *dev, int dir)\n{\n\tswitch (dev->type) {\n\tcase ARPHRD_ETHER:\n\tcase ARPHRD_FDDI:\n\tcase ARPHRD_IEEE802:\n\t\tip_eth_mc_map(addr, haddr);\n\t\treturn 0;\n\tcase ARPHRD_INFINIBAND:\n\t\tip_ib_mc_map(addr, dev->broadcast, haddr);\n\t\treturn 0;\n\tcase ARPHRD_IPGRE:\n\t\tip_ipgre_mc_map(addr, dev->broadcast, haddr);\n\t\treturn 0;\n\tdefault:\n\t\tif (dir) {\n\t\t\tmemcpy(haddr, dev->broadcast, dev->addr_len);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n\nstatic u32 arp_hash(const void *pkey,\n\t\t    const struct net_device *dev,\n\t\t    __u32 *hash_rnd)\n{\n\treturn arp_hashfn(pkey, dev, hash_rnd);\n}\n\nstatic bool arp_key_eq(const struct neighbour *neigh, const void *pkey)\n{\n\treturn neigh_key_eq32(neigh, pkey);\n}\n\nstatic int arp_constructor(struct neighbour *neigh)\n{\n\t__be32 addr;\n\tstruct net_device *dev = neigh->dev;\n\tstruct in_device *in_dev;\n\tstruct neigh_parms *parms;\n\tu32 inaddr_any = INADDR_ANY;\n\n\tif (dev->flags & (IFF_LOOPBACK | IFF_POINTOPOINT))\n\t\tmemcpy(neigh->primary_key, &inaddr_any, arp_tbl.key_len);\n\n\taddr = *(__be32 *)neigh->primary_key;\n\trcu_read_lock();\n\tin_dev = __in_dev_get_rcu(dev);\n\tif (!in_dev) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tneigh->type = inet_addr_type_dev_table(dev_net(dev), dev, addr);\n\n\tparms = in_dev->arp_parms;\n\t__neigh_parms_put(neigh->parms);\n\tneigh->parms = neigh_parms_clone(parms);\n\trcu_read_unlock();\n\n\tif (!dev->header_ops) {\n\t\tneigh->nud_state = NUD_NOARP;\n\t\tneigh->ops = &arp_direct_ops;\n\t\tneigh->output = neigh_direct_output;\n\t} else {\n\t\t \n\n\t\tif (neigh->type == RTN_MULTICAST) {\n\t\t\tneigh->nud_state = NUD_NOARP;\n\t\t\tarp_mc_map(addr, neigh->ha, dev, 1);\n\t\t} else if (dev->flags & (IFF_NOARP | IFF_LOOPBACK)) {\n\t\t\tneigh->nud_state = NUD_NOARP;\n\t\t\tmemcpy(neigh->ha, dev->dev_addr, dev->addr_len);\n\t\t} else if (neigh->type == RTN_BROADCAST ||\n\t\t\t   (dev->flags & IFF_POINTOPOINT)) {\n\t\t\tneigh->nud_state = NUD_NOARP;\n\t\t\tmemcpy(neigh->ha, dev->broadcast, dev->addr_len);\n\t\t}\n\n\t\tif (dev->header_ops->cache)\n\t\t\tneigh->ops = &arp_hh_ops;\n\t\telse\n\t\t\tneigh->ops = &arp_generic_ops;\n\n\t\tif (neigh->nud_state & NUD_VALID)\n\t\t\tneigh->output = neigh->ops->connected_output;\n\t\telse\n\t\t\tneigh->output = neigh->ops->output;\n\t}\n\treturn 0;\n}\n\nstatic void arp_error_report(struct neighbour *neigh, struct sk_buff *skb)\n{\n\tdst_link_failure(skb);\n\tkfree_skb_reason(skb, SKB_DROP_REASON_NEIGH_FAILED);\n}\n\n \nstatic void arp_send_dst(int type, int ptype, __be32 dest_ip,\n\t\t\t struct net_device *dev, __be32 src_ip,\n\t\t\t const unsigned char *dest_hw,\n\t\t\t const unsigned char *src_hw,\n\t\t\t const unsigned char *target_hw,\n\t\t\t struct dst_entry *dst)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tif (dev->flags & IFF_NOARP)\n\t\treturn;\n\n\tskb = arp_create(type, ptype, dest_ip, dev, src_ip,\n\t\t\t dest_hw, src_hw, target_hw);\n\tif (!skb)\n\t\treturn;\n\n\tskb_dst_set(skb, dst_clone(dst));\n\tarp_xmit(skb);\n}\n\nvoid arp_send(int type, int ptype, __be32 dest_ip,\n\t      struct net_device *dev, __be32 src_ip,\n\t      const unsigned char *dest_hw, const unsigned char *src_hw,\n\t      const unsigned char *target_hw)\n{\n\tarp_send_dst(type, ptype, dest_ip, dev, src_ip, dest_hw, src_hw,\n\t\t     target_hw, NULL);\n}\nEXPORT_SYMBOL(arp_send);\n\nstatic void arp_solicit(struct neighbour *neigh, struct sk_buff *skb)\n{\n\t__be32 saddr = 0;\n\tu8 dst_ha[MAX_ADDR_LEN], *dst_hw = NULL;\n\tstruct net_device *dev = neigh->dev;\n\t__be32 target = *(__be32 *)neigh->primary_key;\n\tint probes = atomic_read(&neigh->probes);\n\tstruct in_device *in_dev;\n\tstruct dst_entry *dst = NULL;\n\n\trcu_read_lock();\n\tin_dev = __in_dev_get_rcu(dev);\n\tif (!in_dev) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tswitch (IN_DEV_ARP_ANNOUNCE(in_dev)) {\n\tdefault:\n\tcase 0:\t\t \n\t\tif (skb && inet_addr_type_dev_table(dev_net(dev), dev,\n\t\t\t\t\t  ip_hdr(skb)->saddr) == RTN_LOCAL)\n\t\t\tsaddr = ip_hdr(skb)->saddr;\n\t\tbreak;\n\tcase 1:\t\t \n\t\tif (!skb)\n\t\t\tbreak;\n\t\tsaddr = ip_hdr(skb)->saddr;\n\t\tif (inet_addr_type_dev_table(dev_net(dev), dev,\n\t\t\t\t\t     saddr) == RTN_LOCAL) {\n\t\t\t \n\t\t\tif (inet_addr_onlink(in_dev, target, saddr))\n\t\t\t\tbreak;\n\t\t}\n\t\tsaddr = 0;\n\t\tbreak;\n\tcase 2:\t\t \n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (!saddr)\n\t\tsaddr = inet_select_addr(dev, target, RT_SCOPE_LINK);\n\n\tprobes -= NEIGH_VAR(neigh->parms, UCAST_PROBES);\n\tif (probes < 0) {\n\t\tif (!(READ_ONCE(neigh->nud_state) & NUD_VALID))\n\t\t\tpr_debug(\"trying to ucast probe in NUD_INVALID\\n\");\n\t\tneigh_ha_snapshot(dst_ha, neigh, dev);\n\t\tdst_hw = dst_ha;\n\t} else {\n\t\tprobes -= NEIGH_VAR(neigh->parms, APP_PROBES);\n\t\tif (probes < 0) {\n\t\t\tneigh_app_ns(neigh);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (skb && !(dev->priv_flags & IFF_XMIT_DST_RELEASE))\n\t\tdst = skb_dst(skb);\n\tarp_send_dst(ARPOP_REQUEST, ETH_P_ARP, target, dev, saddr,\n\t\t     dst_hw, dev->dev_addr, NULL, dst);\n}\n\nstatic int arp_ignore(struct in_device *in_dev, __be32 sip, __be32 tip)\n{\n\tstruct net *net = dev_net(in_dev->dev);\n\tint scope;\n\n\tswitch (IN_DEV_ARP_IGNORE(in_dev)) {\n\tcase 0:\t \n\t\treturn 0;\n\tcase 1:\t \n\t\tsip = 0;\n\t\tscope = RT_SCOPE_HOST;\n\t\tbreak;\n\tcase 2:\t \n\t\tscope = RT_SCOPE_HOST;\n\t\tbreak;\n\tcase 3:\t \n\t\tsip = 0;\n\t\tscope = RT_SCOPE_LINK;\n\t\tin_dev = NULL;\n\t\tbreak;\n\tcase 4:\t \n\tcase 5:\n\tcase 6:\n\tcase 7:\n\t\treturn 0;\n\tcase 8:\t \n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn !inet_confirm_addr(net, in_dev, sip, tip, scope);\n}\n\nstatic int arp_accept(struct in_device *in_dev, __be32 sip)\n{\n\tstruct net *net = dev_net(in_dev->dev);\n\tint scope = RT_SCOPE_LINK;\n\n\tswitch (IN_DEV_ARP_ACCEPT(in_dev)) {\n\tcase 0:  \n\t\treturn 0;\n\tcase 1:  \n\t\treturn 1;\n\tcase 2:  \n\t\treturn !!inet_confirm_addr(net, in_dev, sip, 0, scope);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int arp_filter(__be32 sip, __be32 tip, struct net_device *dev)\n{\n\tstruct rtable *rt;\n\tint flag = 0;\n\t \n\tstruct net *net = dev_net(dev);\n\n\trt = ip_route_output(net, sip, tip, 0, l3mdev_master_ifindex_rcu(dev));\n\tif (IS_ERR(rt))\n\t\treturn 1;\n\tif (rt->dst.dev != dev) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_ARPFILTER);\n\t\tflag = 1;\n\t}\n\tip_rt_put(rt);\n\treturn flag;\n}\n\n \nstatic inline int arp_fwd_proxy(struct in_device *in_dev,\n\t\t\t\tstruct net_device *dev,\tstruct rtable *rt)\n{\n\tstruct in_device *out_dev;\n\tint imi, omi = -1;\n\n\tif (rt->dst.dev == dev)\n\t\treturn 0;\n\n\tif (!IN_DEV_PROXY_ARP(in_dev))\n\t\treturn 0;\n\timi = IN_DEV_MEDIUM_ID(in_dev);\n\tif (imi == 0)\n\t\treturn 1;\n\tif (imi == -1)\n\t\treturn 0;\n\n\t \n\n\tout_dev = __in_dev_get_rcu(rt->dst.dev);\n\tif (out_dev)\n\t\tomi = IN_DEV_MEDIUM_ID(out_dev);\n\n\treturn omi != imi && omi != -1;\n}\n\n \nstatic inline int arp_fwd_pvlan(struct in_device *in_dev,\n\t\t\t\tstruct net_device *dev,\tstruct rtable *rt,\n\t\t\t\t__be32 sip, __be32 tip)\n{\n\t \n\tif (rt->dst.dev != dev)\n\t\treturn 0;\n\n\t \n\tif (sip == tip)\n\t\treturn 0;\n\n\tif (IN_DEV_PROXY_ARP_PVLAN(in_dev))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \n\n \nstruct sk_buff *arp_create(int type, int ptype, __be32 dest_ip,\n\t\t\t   struct net_device *dev, __be32 src_ip,\n\t\t\t   const unsigned char *dest_hw,\n\t\t\t   const unsigned char *src_hw,\n\t\t\t   const unsigned char *target_hw)\n{\n\tstruct sk_buff *skb;\n\tstruct arphdr *arp;\n\tunsigned char *arp_ptr;\n\tint hlen = LL_RESERVED_SPACE(dev);\n\tint tlen = dev->needed_tailroom;\n\n\t \n\n\tskb = alloc_skb(arp_hdr_len(dev) + hlen + tlen, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, hlen);\n\tskb_reset_network_header(skb);\n\tarp = skb_put(skb, arp_hdr_len(dev));\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_ARP);\n\tif (!src_hw)\n\t\tsrc_hw = dev->dev_addr;\n\tif (!dest_hw)\n\t\tdest_hw = dev->broadcast;\n\n\t \n\tif (dev_hard_header(skb, dev, ptype, dest_hw, src_hw, skb->len) < 0)\n\t\tgoto out;\n\n\t \n\t \n\tswitch (dev->type) {\n\tdefault:\n\t\tarp->ar_hrd = htons(dev->type);\n\t\tarp->ar_pro = htons(ETH_P_IP);\n\t\tbreak;\n\n#if IS_ENABLED(CONFIG_AX25)\n\tcase ARPHRD_AX25:\n\t\tarp->ar_hrd = htons(ARPHRD_AX25);\n\t\tarp->ar_pro = htons(AX25_P_IP);\n\t\tbreak;\n\n#if IS_ENABLED(CONFIG_NETROM)\n\tcase ARPHRD_NETROM:\n\t\tarp->ar_hrd = htons(ARPHRD_NETROM);\n\t\tarp->ar_pro = htons(AX25_P_IP);\n\t\tbreak;\n#endif\n#endif\n\n#if IS_ENABLED(CONFIG_FDDI)\n\tcase ARPHRD_FDDI:\n\t\tarp->ar_hrd = htons(ARPHRD_ETHER);\n\t\tarp->ar_pro = htons(ETH_P_IP);\n\t\tbreak;\n#endif\n\t}\n\n\tarp->ar_hln = dev->addr_len;\n\tarp->ar_pln = 4;\n\tarp->ar_op = htons(type);\n\n\tarp_ptr = (unsigned char *)(arp + 1);\n\n\tmemcpy(arp_ptr, src_hw, dev->addr_len);\n\tarp_ptr += dev->addr_len;\n\tmemcpy(arp_ptr, &src_ip, 4);\n\tarp_ptr += 4;\n\n\tswitch (dev->type) {\n#if IS_ENABLED(CONFIG_FIREWIRE_NET)\n\tcase ARPHRD_IEEE1394:\n\t\tbreak;\n#endif\n\tdefault:\n\t\tif (target_hw)\n\t\t\tmemcpy(arp_ptr, target_hw, dev->addr_len);\n\t\telse\n\t\t\tmemset(arp_ptr, 0, dev->addr_len);\n\t\tarp_ptr += dev->addr_len;\n\t}\n\tmemcpy(arp_ptr, &dest_ip, 4);\n\n\treturn skb;\n\nout:\n\tkfree_skb(skb);\n\treturn NULL;\n}\nEXPORT_SYMBOL(arp_create);\n\nstatic int arp_xmit_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\treturn dev_queue_xmit(skb);\n}\n\n \nvoid arp_xmit(struct sk_buff *skb)\n{\n\t \n\tNF_HOOK(NFPROTO_ARP, NF_ARP_OUT,\n\t\tdev_net(skb->dev), NULL, skb, NULL, skb->dev,\n\t\tarp_xmit_finish);\n}\nEXPORT_SYMBOL(arp_xmit);\n\nstatic bool arp_is_garp(struct net *net, struct net_device *dev,\n\t\t\tint *addr_type, __be16 ar_op,\n\t\t\t__be32 sip, __be32 tip,\n\t\t\tunsigned char *sha, unsigned char *tha)\n{\n\tbool is_garp = tip == sip;\n\n\t \n\tif (is_garp && ar_op == htons(ARPOP_REPLY))\n\t\tis_garp =\n\t\t\t \n\t\t\ttha &&\n\t\t\t!memcmp(tha, sha, dev->addr_len);\n\n\tif (is_garp) {\n\t\t*addr_type = inet_addr_type_dev_table(net, dev, sip);\n\t\tif (*addr_type != RTN_UNICAST)\n\t\t\tis_garp = false;\n\t}\n\treturn is_garp;\n}\n\n \n\nstatic int arp_process(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\tstruct arphdr *arp;\n\tunsigned char *arp_ptr;\n\tstruct rtable *rt;\n\tunsigned char *sha;\n\tunsigned char *tha = NULL;\n\t__be32 sip, tip;\n\tu16 dev_type = dev->type;\n\tint addr_type;\n\tstruct neighbour *n;\n\tstruct dst_entry *reply_dst = NULL;\n\tbool is_garp = false;\n\n\t \n\n\tif (!in_dev)\n\t\tgoto out_free_skb;\n\n\tarp = arp_hdr(skb);\n\n\tswitch (dev_type) {\n\tdefault:\n\t\tif (arp->ar_pro != htons(ETH_P_IP) ||\n\t\t    htons(dev_type) != arp->ar_hrd)\n\t\t\tgoto out_free_skb;\n\t\tbreak;\n\tcase ARPHRD_ETHER:\n\tcase ARPHRD_FDDI:\n\tcase ARPHRD_IEEE802:\n\t\t \n\t\tif ((arp->ar_hrd != htons(ARPHRD_ETHER) &&\n\t\t     arp->ar_hrd != htons(ARPHRD_IEEE802)) ||\n\t\t    arp->ar_pro != htons(ETH_P_IP))\n\t\t\tgoto out_free_skb;\n\t\tbreak;\n\tcase ARPHRD_AX25:\n\t\tif (arp->ar_pro != htons(AX25_P_IP) ||\n\t\t    arp->ar_hrd != htons(ARPHRD_AX25))\n\t\t\tgoto out_free_skb;\n\t\tbreak;\n\tcase ARPHRD_NETROM:\n\t\tif (arp->ar_pro != htons(AX25_P_IP) ||\n\t\t    arp->ar_hrd != htons(ARPHRD_NETROM))\n\t\t\tgoto out_free_skb;\n\t\tbreak;\n\t}\n\n\t \n\n\tif (arp->ar_op != htons(ARPOP_REPLY) &&\n\t    arp->ar_op != htons(ARPOP_REQUEST))\n\t\tgoto out_free_skb;\n\n \n\tarp_ptr = (unsigned char *)(arp + 1);\n\tsha\t= arp_ptr;\n\tarp_ptr += dev->addr_len;\n\tmemcpy(&sip, arp_ptr, 4);\n\tarp_ptr += 4;\n\tswitch (dev_type) {\n#if IS_ENABLED(CONFIG_FIREWIRE_NET)\n\tcase ARPHRD_IEEE1394:\n\t\tbreak;\n#endif\n\tdefault:\n\t\ttha = arp_ptr;\n\t\tarp_ptr += dev->addr_len;\n\t}\n\tmemcpy(&tip, arp_ptr, 4);\n \n\tif (ipv4_is_multicast(tip) ||\n\t    (!IN_DEV_ROUTE_LOCALNET(in_dev) && ipv4_is_loopback(tip)))\n\t\tgoto out_free_skb;\n\n  \n\tif (sip == tip && IN_DEV_ORCONF(in_dev, DROP_GRATUITOUS_ARP))\n\t\tgoto out_free_skb;\n\n \n\tif (dev_type == ARPHRD_DLCI)\n\t\tsha = dev->broadcast;\n\n \n\n\tif (arp->ar_op == htons(ARPOP_REQUEST) && skb_metadata_dst(skb))\n\t\treply_dst = (struct dst_entry *)\n\t\t\t    iptunnel_metadata_reply(skb_metadata_dst(skb),\n\t\t\t\t\t\t    GFP_ATOMIC);\n\n\t \n\tif (sip == 0) {\n\t\tif (arp->ar_op == htons(ARPOP_REQUEST) &&\n\t\t    inet_addr_type_dev_table(net, dev, tip) == RTN_LOCAL &&\n\t\t    !arp_ignore(in_dev, sip, tip))\n\t\t\tarp_send_dst(ARPOP_REPLY, ETH_P_ARP, sip, dev, tip,\n\t\t\t\t     sha, dev->dev_addr, sha, reply_dst);\n\t\tgoto out_consume_skb;\n\t}\n\n\tif (arp->ar_op == htons(ARPOP_REQUEST) &&\n\t    ip_route_input_noref(skb, tip, sip, 0, dev) == 0) {\n\n\t\trt = skb_rtable(skb);\n\t\taddr_type = rt->rt_type;\n\n\t\tif (addr_type == RTN_LOCAL) {\n\t\t\tint dont_send;\n\n\t\t\tdont_send = arp_ignore(in_dev, sip, tip);\n\t\t\tif (!dont_send && IN_DEV_ARPFILTER(in_dev))\n\t\t\t\tdont_send = arp_filter(sip, tip, dev);\n\t\t\tif (!dont_send) {\n\t\t\t\tn = neigh_event_ns(&arp_tbl, sha, &sip, dev);\n\t\t\t\tif (n) {\n\t\t\t\t\tarp_send_dst(ARPOP_REPLY, ETH_P_ARP,\n\t\t\t\t\t\t     sip, dev, tip, sha,\n\t\t\t\t\t\t     dev->dev_addr, sha,\n\t\t\t\t\t\t     reply_dst);\n\t\t\t\t\tneigh_release(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto out_consume_skb;\n\t\t} else if (IN_DEV_FORWARD(in_dev)) {\n\t\t\tif (addr_type == RTN_UNICAST  &&\n\t\t\t    (arp_fwd_proxy(in_dev, dev, rt) ||\n\t\t\t     arp_fwd_pvlan(in_dev, dev, rt, sip, tip) ||\n\t\t\t     (rt->dst.dev != dev &&\n\t\t\t      pneigh_lookup(&arp_tbl, net, &tip, dev, 0)))) {\n\t\t\t\tn = neigh_event_ns(&arp_tbl, sha, &sip, dev);\n\t\t\t\tif (n)\n\t\t\t\t\tneigh_release(n);\n\n\t\t\t\tif (NEIGH_CB(skb)->flags & LOCALLY_ENQUEUED ||\n\t\t\t\t    skb->pkt_type == PACKET_HOST ||\n\t\t\t\t    NEIGH_VAR(in_dev->arp_parms, PROXY_DELAY) == 0) {\n\t\t\t\t\tarp_send_dst(ARPOP_REPLY, ETH_P_ARP,\n\t\t\t\t\t\t     sip, dev, tip, sha,\n\t\t\t\t\t\t     dev->dev_addr, sha,\n\t\t\t\t\t\t     reply_dst);\n\t\t\t\t} else {\n\t\t\t\t\tpneigh_enqueue(&arp_tbl,\n\t\t\t\t\t\t       in_dev->arp_parms, skb);\n\t\t\t\t\tgoto out_free_dst;\n\t\t\t\t}\n\t\t\t\tgoto out_consume_skb;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tn = __neigh_lookup(&arp_tbl, &sip, dev, 0);\n\n\taddr_type = -1;\n\tif (n || arp_accept(in_dev, sip)) {\n\t\tis_garp = arp_is_garp(net, dev, &addr_type, arp->ar_op,\n\t\t\t\t      sip, tip, sha, tha);\n\t}\n\n\tif (arp_accept(in_dev, sip)) {\n\t\t \n\t\tif (!n &&\n\t\t    (is_garp ||\n\t\t     (arp->ar_op == htons(ARPOP_REPLY) &&\n\t\t      (addr_type == RTN_UNICAST ||\n\t\t       (addr_type < 0 &&\n\t\t\t \n\t\t\tinet_addr_type_dev_table(net, dev, sip) ==\n\t\t\t\tRTN_UNICAST)))))\n\t\t\tn = __neigh_lookup(&arp_tbl, &sip, dev, 1);\n\t}\n\n\tif (n) {\n\t\tint state = NUD_REACHABLE;\n\t\tint override;\n\n\t\t \n\t\toverride = time_after(jiffies,\n\t\t\t\t      n->updated +\n\t\t\t\t      NEIGH_VAR(n->parms, LOCKTIME)) ||\n\t\t\t   is_garp;\n\n\t\t \n\t\tif (arp->ar_op != htons(ARPOP_REPLY) ||\n\t\t    skb->pkt_type != PACKET_HOST)\n\t\t\tstate = NUD_STALE;\n\t\tneigh_update(n, sha, state,\n\t\t\t     override ? NEIGH_UPDATE_F_OVERRIDE : 0, 0);\n\t\tneigh_release(n);\n\t}\n\nout_consume_skb:\n\tconsume_skb(skb);\n\nout_free_dst:\n\tdst_release(reply_dst);\n\treturn NET_RX_SUCCESS;\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn NET_RX_DROP;\n}\n\nstatic void parp_redo(struct sk_buff *skb)\n{\n\tarp_process(dev_net(skb->dev), NULL, skb);\n}\n\nstatic int arp_is_multicast(const void *pkey)\n{\n\treturn ipv4_is_multicast(*((__be32 *)pkey));\n}\n\n \n\nstatic int arp_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t   struct packet_type *pt, struct net_device *orig_dev)\n{\n\tconst struct arphdr *arp;\n\n\t \n\tif (dev->flags & IFF_NOARP ||\n\t    skb->pkt_type == PACKET_OTHERHOST ||\n\t    skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto consumeskb;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto out_of_mem;\n\n\t \n\tif (!pskb_may_pull(skb, arp_hdr_len(dev)))\n\t\tgoto freeskb;\n\n\tarp = arp_hdr(skb);\n\tif (arp->ar_hln != dev->addr_len || arp->ar_pln != 4)\n\t\tgoto freeskb;\n\n\tmemset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));\n\n\treturn NF_HOOK(NFPROTO_ARP, NF_ARP_IN,\n\t\t       dev_net(dev), NULL, skb, dev, NULL,\n\t\t       arp_process);\n\nconsumeskb:\n\tconsume_skb(skb);\n\treturn NET_RX_SUCCESS;\nfreeskb:\n\tkfree_skb(skb);\nout_of_mem:\n\treturn NET_RX_DROP;\n}\n\n \n\n \n\nstatic int arp_req_set_proxy(struct net *net, struct net_device *dev, int on)\n{\n\tif (!dev) {\n\t\tIPV4_DEVCONF_ALL(net, PROXY_ARP) = on;\n\t\treturn 0;\n\t}\n\tif (__in_dev_get_rtnl(dev)) {\n\t\tIN_DEV_CONF_SET(__in_dev_get_rtnl(dev), PROXY_ARP, on);\n\t\treturn 0;\n\t}\n\treturn -ENXIO;\n}\n\nstatic int arp_req_set_public(struct net *net, struct arpreq *r,\n\t\tstruct net_device *dev)\n{\n\t__be32 ip = ((struct sockaddr_in *)&r->arp_pa)->sin_addr.s_addr;\n\t__be32 mask = ((struct sockaddr_in *)&r->arp_netmask)->sin_addr.s_addr;\n\n\tif (mask && mask != htonl(0xFFFFFFFF))\n\t\treturn -EINVAL;\n\tif (!dev && (r->arp_flags & ATF_COM)) {\n\t\tdev = dev_getbyhwaddr_rcu(net, r->arp_ha.sa_family,\n\t\t\t\t      r->arp_ha.sa_data);\n\t\tif (!dev)\n\t\t\treturn -ENODEV;\n\t}\n\tif (mask) {\n\t\tif (!pneigh_lookup(&arp_tbl, net, &ip, dev, 1))\n\t\t\treturn -ENOBUFS;\n\t\treturn 0;\n\t}\n\n\treturn arp_req_set_proxy(net, dev, 1);\n}\n\nstatic int arp_req_set(struct net *net, struct arpreq *r,\n\t\t       struct net_device *dev)\n{\n\t__be32 ip;\n\tstruct neighbour *neigh;\n\tint err;\n\n\tif (r->arp_flags & ATF_PUBL)\n\t\treturn arp_req_set_public(net, r, dev);\n\n\tip = ((struct sockaddr_in *)&r->arp_pa)->sin_addr.s_addr;\n\tif (r->arp_flags & ATF_PERM)\n\t\tr->arp_flags |= ATF_COM;\n\tif (!dev) {\n\t\tstruct rtable *rt = ip_route_output(net, ip, 0, RTO_ONLINK, 0);\n\n\t\tif (IS_ERR(rt))\n\t\t\treturn PTR_ERR(rt);\n\t\tdev = rt->dst.dev;\n\t\tip_rt_put(rt);\n\t\tif (!dev)\n\t\t\treturn -EINVAL;\n\t}\n\tswitch (dev->type) {\n#if IS_ENABLED(CONFIG_FDDI)\n\tcase ARPHRD_FDDI:\n\t\t \n\t\tif (r->arp_ha.sa_family != ARPHRD_FDDI &&\n\t\t    r->arp_ha.sa_family != ARPHRD_ETHER &&\n\t\t    r->arp_ha.sa_family != ARPHRD_IEEE802)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tif (r->arp_ha.sa_family != dev->type)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tneigh = __neigh_lookup_errno(&arp_tbl, &ip, dev);\n\terr = PTR_ERR(neigh);\n\tif (!IS_ERR(neigh)) {\n\t\tunsigned int state = NUD_STALE;\n\t\tif (r->arp_flags & ATF_PERM)\n\t\t\tstate = NUD_PERMANENT;\n\t\terr = neigh_update(neigh, (r->arp_flags & ATF_COM) ?\n\t\t\t\t   r->arp_ha.sa_data : NULL, state,\n\t\t\t\t   NEIGH_UPDATE_F_OVERRIDE |\n\t\t\t\t   NEIGH_UPDATE_F_ADMIN, 0);\n\t\tneigh_release(neigh);\n\t}\n\treturn err;\n}\n\nstatic unsigned int arp_state_to_flags(struct neighbour *neigh)\n{\n\tif (neigh->nud_state&NUD_PERMANENT)\n\t\treturn ATF_PERM | ATF_COM;\n\telse if (neigh->nud_state&NUD_VALID)\n\t\treturn ATF_COM;\n\telse\n\t\treturn 0;\n}\n\n \n\nstatic int arp_req_get(struct arpreq *r, struct net_device *dev)\n{\n\t__be32 ip = ((struct sockaddr_in *) &r->arp_pa)->sin_addr.s_addr;\n\tstruct neighbour *neigh;\n\tint err = -ENXIO;\n\n\tneigh = neigh_lookup(&arp_tbl, &ip, dev);\n\tif (neigh) {\n\t\tif (!(READ_ONCE(neigh->nud_state) & NUD_NOARP)) {\n\t\t\tread_lock_bh(&neigh->lock);\n\t\t\tmemcpy(r->arp_ha.sa_data, neigh->ha, dev->addr_len);\n\t\t\tr->arp_flags = arp_state_to_flags(neigh);\n\t\t\tread_unlock_bh(&neigh->lock);\n\t\t\tr->arp_ha.sa_family = dev->type;\n\t\t\tstrscpy(r->arp_dev, dev->name, sizeof(r->arp_dev));\n\t\t\terr = 0;\n\t\t}\n\t\tneigh_release(neigh);\n\t}\n\treturn err;\n}\n\nint arp_invalidate(struct net_device *dev, __be32 ip, bool force)\n{\n\tstruct neighbour *neigh = neigh_lookup(&arp_tbl, &ip, dev);\n\tint err = -ENXIO;\n\tstruct neigh_table *tbl = &arp_tbl;\n\n\tif (neigh) {\n\t\tif ((READ_ONCE(neigh->nud_state) & NUD_VALID) && !force) {\n\t\t\tneigh_release(neigh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (READ_ONCE(neigh->nud_state) & ~NUD_NOARP)\n\t\t\terr = neigh_update(neigh, NULL, NUD_FAILED,\n\t\t\t\t\t   NEIGH_UPDATE_F_OVERRIDE|\n\t\t\t\t\t   NEIGH_UPDATE_F_ADMIN, 0);\n\t\twrite_lock_bh(&tbl->lock);\n\t\tneigh_release(neigh);\n\t\tneigh_remove_one(neigh, tbl);\n\t\twrite_unlock_bh(&tbl->lock);\n\t}\n\n\treturn err;\n}\n\nstatic int arp_req_delete_public(struct net *net, struct arpreq *r,\n\t\tstruct net_device *dev)\n{\n\t__be32 ip = ((struct sockaddr_in *) &r->arp_pa)->sin_addr.s_addr;\n\t__be32 mask = ((struct sockaddr_in *)&r->arp_netmask)->sin_addr.s_addr;\n\n\tif (mask == htonl(0xFFFFFFFF))\n\t\treturn pneigh_delete(&arp_tbl, net, &ip, dev);\n\n\tif (mask)\n\t\treturn -EINVAL;\n\n\treturn arp_req_set_proxy(net, dev, 0);\n}\n\nstatic int arp_req_delete(struct net *net, struct arpreq *r,\n\t\t\t  struct net_device *dev)\n{\n\t__be32 ip;\n\n\tif (r->arp_flags & ATF_PUBL)\n\t\treturn arp_req_delete_public(net, r, dev);\n\n\tip = ((struct sockaddr_in *)&r->arp_pa)->sin_addr.s_addr;\n\tif (!dev) {\n\t\tstruct rtable *rt = ip_route_output(net, ip, 0, RTO_ONLINK, 0);\n\t\tif (IS_ERR(rt))\n\t\t\treturn PTR_ERR(rt);\n\t\tdev = rt->dst.dev;\n\t\tip_rt_put(rt);\n\t\tif (!dev)\n\t\t\treturn -EINVAL;\n\t}\n\treturn arp_invalidate(dev, ip, true);\n}\n\n \n\nint arp_ioctl(struct net *net, unsigned int cmd, void __user *arg)\n{\n\tint err;\n\tstruct arpreq r;\n\tstruct net_device *dev = NULL;\n\n\tswitch (cmd) {\n\tcase SIOCDARP:\n\tcase SIOCSARP:\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tfallthrough;\n\tcase SIOCGARP:\n\t\terr = copy_from_user(&r, arg, sizeof(struct arpreq));\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (r.arp_pa.sa_family != AF_INET)\n\t\treturn -EPFNOSUPPORT;\n\n\tif (!(r.arp_flags & ATF_PUBL) &&\n\t    (r.arp_flags & (ATF_NETMASK | ATF_DONTPUB)))\n\t\treturn -EINVAL;\n\tif (!(r.arp_flags & ATF_NETMASK))\n\t\t((struct sockaddr_in *)&r.arp_netmask)->sin_addr.s_addr =\n\t\t\t\t\t\t\t   htonl(0xFFFFFFFFUL);\n\trtnl_lock();\n\tif (r.arp_dev[0]) {\n\t\terr = -ENODEV;\n\t\tdev = __dev_get_by_name(net, r.arp_dev);\n\t\tif (!dev)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (!r.arp_ha.sa_family)\n\t\t\tr.arp_ha.sa_family = dev->type;\n\t\terr = -EINVAL;\n\t\tif ((r.arp_flags & ATF_COM) && r.arp_ha.sa_family != dev->type)\n\t\t\tgoto out;\n\t} else if (cmd == SIOCGARP) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase SIOCDARP:\n\t\terr = arp_req_delete(net, &r, dev);\n\t\tbreak;\n\tcase SIOCSARP:\n\t\terr = arp_req_set(net, &r, dev);\n\t\tbreak;\n\tcase SIOCGARP:\n\t\terr = arp_req_get(&r, dev);\n\t\tbreak;\n\t}\nout:\n\trtnl_unlock();\n\tif (cmd == SIOCGARP && !err && copy_to_user(arg, &r, sizeof(r)))\n\t\terr = -EFAULT;\n\treturn err;\n}\n\nstatic int arp_netdev_event(struct notifier_block *this, unsigned long event,\n\t\t\t    void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_change_info *change_info;\n\tstruct in_device *in_dev;\n\tbool evict_nocarrier;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEADDR:\n\t\tneigh_changeaddr(&arp_tbl, dev);\n\t\trt_cache_flush(dev_net(dev));\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tchange_info = ptr;\n\t\tif (change_info->flags_changed & IFF_NOARP)\n\t\t\tneigh_changeaddr(&arp_tbl, dev);\n\n\t\tin_dev = __in_dev_get_rtnl(dev);\n\t\tif (!in_dev)\n\t\t\tevict_nocarrier = true;\n\t\telse\n\t\t\tevict_nocarrier = IN_DEV_ARP_EVICT_NOCARRIER(in_dev);\n\n\t\tif (evict_nocarrier && !netif_carrier_ok(dev))\n\t\t\tneigh_carrier_down(&arp_tbl, dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block arp_netdev_notifier = {\n\t.notifier_call = arp_netdev_event,\n};\n\n \nvoid arp_ifdown(struct net_device *dev)\n{\n\tneigh_ifdown(&arp_tbl, dev);\n}\n\n\n \n\nstatic struct packet_type arp_packet_type __read_mostly = {\n\t.type =\tcpu_to_be16(ETH_P_ARP),\n\t.func =\tarp_rcv,\n};\n\n#ifdef CONFIG_PROC_FS\n#if IS_ENABLED(CONFIG_AX25)\n\n \nstatic void ax2asc2(ax25_address *a, char *buf)\n{\n\tchar c, *s;\n\tint n;\n\n\tfor (n = 0, s = buf; n < 6; n++) {\n\t\tc = (a->ax25_call[n] >> 1) & 0x7F;\n\n\t\tif (c != ' ')\n\t\t\t*s++ = c;\n\t}\n\n\t*s++ = '-';\n\tn = (a->ax25_call[6] >> 1) & 0x0F;\n\tif (n > 9) {\n\t\t*s++ = '1';\n\t\tn -= 10;\n\t}\n\n\t*s++ = n + '0';\n\t*s++ = '\\0';\n\n\tif (*buf == '\\0' || *buf == '-') {\n\t\tbuf[0] = '*';\n\t\tbuf[1] = '\\0';\n\t}\n}\n#endif  \n\n#define HBUFFERLEN 30\n\nstatic void arp_format_neigh_entry(struct seq_file *seq,\n\t\t\t\t   struct neighbour *n)\n{\n\tchar hbuffer[HBUFFERLEN];\n\tint k, j;\n\tchar tbuf[16];\n\tstruct net_device *dev = n->dev;\n\tint hatype = dev->type;\n\n\tread_lock(&n->lock);\n\t \n#if IS_ENABLED(CONFIG_AX25)\n\tif (hatype == ARPHRD_AX25 || hatype == ARPHRD_NETROM)\n\t\tax2asc2((ax25_address *)n->ha, hbuffer);\n\telse {\n#endif\n\tfor (k = 0, j = 0; k < HBUFFERLEN - 3 && j < dev->addr_len; j++) {\n\t\thbuffer[k++] = hex_asc_hi(n->ha[j]);\n\t\thbuffer[k++] = hex_asc_lo(n->ha[j]);\n\t\thbuffer[k++] = ':';\n\t}\n\tif (k != 0)\n\t\t--k;\n\thbuffer[k] = 0;\n#if IS_ENABLED(CONFIG_AX25)\n\t}\n#endif\n\tsprintf(tbuf, \"%pI4\", n->primary_key);\n\tseq_printf(seq, \"%-16s 0x%-10x0x%-10x%-17s     *        %s\\n\",\n\t\t   tbuf, hatype, arp_state_to_flags(n), hbuffer, dev->name);\n\tread_unlock(&n->lock);\n}\n\nstatic void arp_format_pneigh_entry(struct seq_file *seq,\n\t\t\t\t    struct pneigh_entry *n)\n{\n\tstruct net_device *dev = n->dev;\n\tint hatype = dev ? dev->type : 0;\n\tchar tbuf[16];\n\n\tsprintf(tbuf, \"%pI4\", n->key);\n\tseq_printf(seq, \"%-16s 0x%-10x0x%-10x%s     *        %s\\n\",\n\t\t   tbuf, hatype, ATF_PUBL | ATF_PERM, \"00:00:00:00:00:00\",\n\t\t   dev ? dev->name : \"*\");\n}\n\nstatic int arp_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"IP address       HW type     Flags       \"\n\t\t\t      \"HW address            Mask     Device\\n\");\n\t} else {\n\t\tstruct neigh_seq_state *state = seq->private;\n\n\t\tif (state->flags & NEIGH_SEQ_IS_PNEIGH)\n\t\t\tarp_format_pneigh_entry(seq, v);\n\t\telse\n\t\t\tarp_format_neigh_entry(seq, v);\n\t}\n\n\treturn 0;\n}\n\nstatic void *arp_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\t \n\treturn neigh_seq_start(seq, pos, &arp_tbl, NEIGH_SEQ_SKIP_NOARP);\n}\n\nstatic const struct seq_operations arp_seq_ops = {\n\t.start\t= arp_seq_start,\n\t.next\t= neigh_seq_next,\n\t.stop\t= neigh_seq_stop,\n\t.show\t= arp_seq_show,\n};\n#endif  \n\nstatic int __net_init arp_net_init(struct net *net)\n{\n\tif (!proc_create_net(\"arp\", 0444, net->proc_net, &arp_seq_ops,\n\t\t\tsizeof(struct neigh_seq_state)))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void __net_exit arp_net_exit(struct net *net)\n{\n\tremove_proc_entry(\"arp\", net->proc_net);\n}\n\nstatic struct pernet_operations arp_net_ops = {\n\t.init = arp_net_init,\n\t.exit = arp_net_exit,\n};\n\nvoid __init arp_init(void)\n{\n\tneigh_table_init(NEIGH_ARP_TABLE, &arp_tbl);\n\n\tdev_add_pack(&arp_packet_type);\n\tregister_pernet_subsys(&arp_net_ops);\n#ifdef CONFIG_SYSCTL\n\tneigh_sysctl_register(NULL, &arp_tbl.parms, NULL);\n#endif\n\tregister_netdevice_notifier(&arp_netdev_notifier);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}