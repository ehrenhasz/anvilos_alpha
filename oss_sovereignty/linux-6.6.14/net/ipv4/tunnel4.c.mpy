{
  "module_name": "tunnel4.c",
  "hash_id": "4feabd867d02dd3075e010ae7ee4e7d6785a65ec4c7b26a20c0a1ae2ea583f15",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tunnel4.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/mpls.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/icmp.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\nstatic struct xfrm_tunnel __rcu *tunnel4_handlers __read_mostly;\nstatic struct xfrm_tunnel __rcu *tunnel64_handlers __read_mostly;\nstatic struct xfrm_tunnel __rcu *tunnelmpls4_handlers __read_mostly;\nstatic DEFINE_MUTEX(tunnel4_mutex);\n\nstatic inline struct xfrm_tunnel __rcu **fam_handlers(unsigned short family)\n{\n\treturn (family == AF_INET) ? &tunnel4_handlers :\n\t\t(family == AF_INET6) ? &tunnel64_handlers :\n\t\t&tunnelmpls4_handlers;\n}\n\nint xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family)\n{\n\tstruct xfrm_tunnel __rcu **pprev;\n\tstruct xfrm_tunnel *t;\n\n\tint ret = -EEXIST;\n\tint priority = handler->priority;\n\n\tmutex_lock(&tunnel4_mutex);\n\n\tfor (pprev = fam_handlers(family);\n\t     (t = rcu_dereference_protected(*pprev,\n\t\t\tlockdep_is_held(&tunnel4_mutex))) != NULL;\n\t     pprev = &t->next) {\n\t\tif (t->priority > priority)\n\t\t\tbreak;\n\t\tif (t->priority == priority)\n\t\t\tgoto err;\n\t}\n\n\thandler->next = *pprev;\n\trcu_assign_pointer(*pprev, handler);\n\n\tret = 0;\n\nerr:\n\tmutex_unlock(&tunnel4_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(xfrm4_tunnel_register);\n\nint xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family)\n{\n\tstruct xfrm_tunnel __rcu **pprev;\n\tstruct xfrm_tunnel *t;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&tunnel4_mutex);\n\n\tfor (pprev = fam_handlers(family);\n\t     (t = rcu_dereference_protected(*pprev,\n\t\t\tlockdep_is_held(&tunnel4_mutex))) != NULL;\n\t     pprev = &t->next) {\n\t\tif (t == handler) {\n\t\t\t*pprev = handler->next;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&tunnel4_mutex);\n\n\tsynchronize_net();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(xfrm4_tunnel_deregister);\n\n#define for_each_tunnel_rcu(head, handler)\t\t\\\n\tfor (handler = rcu_dereference(head);\t\t\\\n\t     handler != NULL;\t\t\t\t\\\n\t     handler = rcu_dereference(handler->next))\t\\\n\nstatic int tunnel4_rcv(struct sk_buff *skb)\n{\n\tstruct xfrm_tunnel *handler;\n\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\tgoto drop;\n\n\tfor_each_tunnel_rcu(tunnel4_handlers, handler)\n\t\tif (!handler->handler(skb))\n\t\t\treturn 0;\n\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_INET_XFRM_TUNNEL)\nstatic int tunnel4_rcv_cb(struct sk_buff *skb, u8 proto, int err)\n{\n\tstruct xfrm_tunnel __rcu *head;\n\tstruct xfrm_tunnel *handler;\n\tint ret;\n\n\thead = (proto == IPPROTO_IPIP) ? tunnel4_handlers : tunnel64_handlers;\n\n\tfor_each_tunnel_rcu(head, handler) {\n\t\tif (handler->cb_handler) {\n\t\t\tret = handler->cb_handler(skb, err);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct xfrm_input_afinfo tunnel4_input_afinfo = {\n\t.family\t\t=\tAF_INET,\n\t.is_ipip\t=\ttrue,\n\t.callback\t=\ttunnel4_rcv_cb,\n};\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int tunnel64_rcv(struct sk_buff *skb)\n{\n\tstruct xfrm_tunnel *handler;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto drop;\n\n\tfor_each_tunnel_rcu(tunnel64_handlers, handler)\n\t\tif (!handler->handler(skb))\n\t\t\treturn 0;\n\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_MPLS)\nstatic int tunnelmpls4_rcv(struct sk_buff *skb)\n{\n\tstruct xfrm_tunnel *handler;\n\n\tif (!pskb_may_pull(skb, sizeof(struct mpls_label)))\n\t\tgoto drop;\n\n\tfor_each_tunnel_rcu(tunnelmpls4_handlers, handler)\n\t\tif (!handler->handler(skb))\n\t\t\treturn 0;\n\n\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0);\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n#endif\n\nstatic int tunnel4_err(struct sk_buff *skb, u32 info)\n{\n\tstruct xfrm_tunnel *handler;\n\n\tfor_each_tunnel_rcu(tunnel4_handlers, handler)\n\t\tif (!handler->err_handler(skb, info))\n\t\t\treturn 0;\n\n\treturn -ENOENT;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int tunnel64_err(struct sk_buff *skb, u32 info)\n{\n\tstruct xfrm_tunnel *handler;\n\n\tfor_each_tunnel_rcu(tunnel64_handlers, handler)\n\t\tif (!handler->err_handler(skb, info))\n\t\t\treturn 0;\n\n\treturn -ENOENT;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_MPLS)\nstatic int tunnelmpls4_err(struct sk_buff *skb, u32 info)\n{\n\tstruct xfrm_tunnel *handler;\n\n\tfor_each_tunnel_rcu(tunnelmpls4_handlers, handler)\n\t\tif (!handler->err_handler(skb, info))\n\t\t\treturn 0;\n\n\treturn -ENOENT;\n}\n#endif\n\nstatic const struct net_protocol tunnel4_protocol = {\n\t.handler\t=\ttunnel4_rcv,\n\t.err_handler\t=\ttunnel4_err,\n\t.no_policy\t=\t1,\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic const struct net_protocol tunnel64_protocol = {\n\t.handler\t=\ttunnel64_rcv,\n\t.err_handler\t=\ttunnel64_err,\n\t.no_policy\t=\t1,\n};\n#endif\n\n#if IS_ENABLED(CONFIG_MPLS)\nstatic const struct net_protocol tunnelmpls4_protocol = {\n\t.handler\t=\ttunnelmpls4_rcv,\n\t.err_handler\t=\ttunnelmpls4_err,\n\t.no_policy\t=\t1,\n};\n#endif\n\nstatic int __init tunnel4_init(void)\n{\n\tif (inet_add_protocol(&tunnel4_protocol, IPPROTO_IPIP))\n\t\tgoto err;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (inet_add_protocol(&tunnel64_protocol, IPPROTO_IPV6)) {\n\t\tinet_del_protocol(&tunnel4_protocol, IPPROTO_IPIP);\n\t\tgoto err;\n\t}\n#endif\n#if IS_ENABLED(CONFIG_MPLS)\n\tif (inet_add_protocol(&tunnelmpls4_protocol, IPPROTO_MPLS)) {\n\t\tinet_del_protocol(&tunnel4_protocol, IPPROTO_IPIP);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tinet_del_protocol(&tunnel64_protocol, IPPROTO_IPV6);\n#endif\n\t\tgoto err;\n\t}\n#endif\n#if IS_ENABLED(CONFIG_INET_XFRM_TUNNEL)\n\tif (xfrm_input_register_afinfo(&tunnel4_input_afinfo)) {\n\t\tinet_del_protocol(&tunnel4_protocol, IPPROTO_IPIP);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tinet_del_protocol(&tunnel64_protocol, IPPROTO_IPV6);\n#endif\n#if IS_ENABLED(CONFIG_MPLS)\n\t\tinet_del_protocol(&tunnelmpls4_protocol, IPPROTO_MPLS);\n#endif\n\t\tgoto err;\n\t}\n#endif\n\treturn 0;\n\nerr:\n\tpr_err(\"%s: can't add protocol\\n\", __func__);\n\treturn -EAGAIN;\n}\n\nstatic void __exit tunnel4_fini(void)\n{\n#if IS_ENABLED(CONFIG_INET_XFRM_TUNNEL)\n\tif (xfrm_input_unregister_afinfo(&tunnel4_input_afinfo))\n\t\tpr_err(\"tunnel4 close: can't remove input afinfo\\n\");\n#endif\n#if IS_ENABLED(CONFIG_MPLS)\n\tif (inet_del_protocol(&tunnelmpls4_protocol, IPPROTO_MPLS))\n\t\tpr_err(\"tunnelmpls4 close: can't remove protocol\\n\");\n#endif\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (inet_del_protocol(&tunnel64_protocol, IPPROTO_IPV6))\n\t\tpr_err(\"tunnel64 close: can't remove protocol\\n\");\n#endif\n\tif (inet_del_protocol(&tunnel4_protocol, IPPROTO_IPIP))\n\t\tpr_err(\"tunnel4 close: can't remove protocol\\n\");\n}\n\nmodule_init(tunnel4_init);\nmodule_exit(tunnel4_fini);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}