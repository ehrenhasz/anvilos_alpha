{
  "module_name": "tcp_cdg.c",
  "hash_id": "a9572e88aad4a325b43303e70b118eb58abdb3fb651224fb748c44f602e809a9",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_cdg.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/sched/clock.h>\n\n#include <net/tcp.h>\n\n#define HYSTART_ACK_TRAIN\t1\n#define HYSTART_DELAY\t\t2\n\nstatic int window __read_mostly = 8;\nstatic unsigned int backoff_beta __read_mostly = 0.7071 * 1024;  \nstatic unsigned int backoff_factor __read_mostly = 42;\nstatic unsigned int hystart_detect __read_mostly = 3;\nstatic unsigned int use_ineff __read_mostly = 5;\nstatic bool use_shadow __read_mostly = true;\nstatic bool use_tolerance __read_mostly;\n\nmodule_param(window, int, 0444);\nMODULE_PARM_DESC(window, \"gradient window size (power of two <= 256)\");\nmodule_param(backoff_beta, uint, 0644);\nMODULE_PARM_DESC(backoff_beta, \"backoff beta (0-1024)\");\nmodule_param(backoff_factor, uint, 0644);\nMODULE_PARM_DESC(backoff_factor, \"backoff probability scale factor\");\nmodule_param(hystart_detect, uint, 0644);\nMODULE_PARM_DESC(hystart_detect, \"use Hybrid Slow start \"\n\t\t \"(0: disabled, 1: ACK train, 2: delay threshold, 3: both)\");\nmodule_param(use_ineff, uint, 0644);\nMODULE_PARM_DESC(use_ineff, \"use ineffectual backoff detection (threshold)\");\nmodule_param(use_shadow, bool, 0644);\nMODULE_PARM_DESC(use_shadow, \"use shadow window heuristic\");\nmodule_param(use_tolerance, bool, 0644);\nMODULE_PARM_DESC(use_tolerance, \"use loss tolerance heuristic\");\n\nstruct cdg_minmax {\n\tunion {\n\t\tstruct {\n\t\t\ts32 min;\n\t\t\ts32 max;\n\t\t};\n\t\tu64 v64;\n\t};\n};\n\nenum cdg_state {\n\tCDG_UNKNOWN = 0,\n\tCDG_NONFULL = 1,\n\tCDG_FULL    = 2,\n\tCDG_BACKOFF = 3,\n};\n\nstruct cdg {\n\tstruct cdg_minmax rtt;\n\tstruct cdg_minmax rtt_prev;\n\tstruct cdg_minmax *gradients;\n\tstruct cdg_minmax gsum;\n\tbool gfilled;\n\tu8  tail;\n\tu8  state;\n\tu8  delack;\n\tu32 rtt_seq;\n\tu32 shadow_wnd;\n\tu16 backoff_cnt;\n\tu16 sample_cnt;\n\ts32 delay_min;\n\tu32 last_ack;\n\tu32 round_start;\n};\n\n \nstatic u32 __pure nexp_u32(u32 ux)\n{\n\tstatic const u16 v[] = {\n\t\t \n\t\t65535,\n\t\t65518, 65501, 65468, 65401, 65267, 65001, 64470, 63422,\n\t\t61378, 57484, 50423, 38795, 22965, 8047,  987,   14,\n\t};\n\tu32 msb = ux >> 8;\n\tu32 res;\n\tint i;\n\n\t \n\tif (msb > U16_MAX)\n\t\treturn 0;\n\n\t \n\tres = U32_MAX - (ux & 0xff) * (U32_MAX / 1000000);\n\n\t \n\tfor (i = 1; msb; i++, msb >>= 1) {\n\t\tu32 y = v[i & -(msb & 1)] + U32_C(1);\n\n\t\tres = ((u64)res * y) >> 16;\n\t}\n\n\treturn res;\n}\n\n \nstatic void tcp_cdg_hystart_update(struct sock *sk)\n{\n\tstruct cdg *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tca->delay_min = min_not_zero(ca->delay_min, ca->rtt.min);\n\tif (ca->delay_min == 0)\n\t\treturn;\n\n\tif (hystart_detect & HYSTART_ACK_TRAIN) {\n\t\tu32 now_us = tp->tcp_mstamp;\n\n\t\tif (ca->last_ack == 0 || !tcp_is_cwnd_limited(sk)) {\n\t\t\tca->last_ack = now_us;\n\t\t\tca->round_start = now_us;\n\t\t} else if (before(now_us, ca->last_ack + 3000)) {\n\t\t\tu32 base_owd = max(ca->delay_min / 2U, 125U);\n\n\t\t\tca->last_ack = now_us;\n\t\t\tif (after(now_us, ca->round_start + base_owd)) {\n\t\t\t\tNET_INC_STATS(sock_net(sk),\n\t\t\t\t\t      LINUX_MIB_TCPHYSTARTTRAINDETECT);\n\t\t\t\tNET_ADD_STATS(sock_net(sk),\n\t\t\t\t\t      LINUX_MIB_TCPHYSTARTTRAINCWND,\n\t\t\t\t\t      tcp_snd_cwnd(tp));\n\t\t\t\ttp->snd_ssthresh = tcp_snd_cwnd(tp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hystart_detect & HYSTART_DELAY) {\n\t\tif (ca->sample_cnt < 8) {\n\t\t\tca->sample_cnt++;\n\t\t} else {\n\t\t\ts32 thresh = max(ca->delay_min + ca->delay_min / 8U,\n\t\t\t\t\t 125U);\n\n\t\t\tif (ca->rtt.min > thresh) {\n\t\t\t\tNET_INC_STATS(sock_net(sk),\n\t\t\t\t\t      LINUX_MIB_TCPHYSTARTDELAYDETECT);\n\t\t\t\tNET_ADD_STATS(sock_net(sk),\n\t\t\t\t\t      LINUX_MIB_TCPHYSTARTDELAYCWND,\n\t\t\t\t\t      tcp_snd_cwnd(tp));\n\t\t\t\ttp->snd_ssthresh = tcp_snd_cwnd(tp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic s32 tcp_cdg_grad(struct cdg *ca)\n{\n\ts32 gmin = ca->rtt.min - ca->rtt_prev.min;\n\ts32 gmax = ca->rtt.max - ca->rtt_prev.max;\n\ts32 grad;\n\n\tif (ca->gradients) {\n\t\tca->gsum.min += gmin - ca->gradients[ca->tail].min;\n\t\tca->gsum.max += gmax - ca->gradients[ca->tail].max;\n\t\tca->gradients[ca->tail].min = gmin;\n\t\tca->gradients[ca->tail].max = gmax;\n\t\tca->tail = (ca->tail + 1) & (window - 1);\n\t\tgmin = ca->gsum.min;\n\t\tgmax = ca->gsum.max;\n\t}\n\n\t \n\tgrad = gmin > 0 ? gmin : gmax;\n\n\t \n\tif (!ca->gfilled) {\n\t\tif (!ca->gradients && window > 1)\n\t\t\tgrad *= window;  \n\t\telse if (ca->tail == 0)\n\t\t\tca->gfilled = true;\n\t\telse\n\t\t\tgrad = (grad * window) / (int)ca->tail;\n\t}\n\n\t \n\tif (gmin <= -32 || gmax <= -32)\n\t\tca->backoff_cnt = 0;\n\n\tif (use_tolerance) {\n\t\t \n\t\tgmin = DIV_ROUND_CLOSEST(gmin, 64);\n\t\tgmax = DIV_ROUND_CLOSEST(gmax, 64);\n\n\t\tif (gmin > 0 && gmax <= 0)\n\t\t\tca->state = CDG_FULL;\n\t\telse if ((gmin > 0 && gmax > 0) || gmax < 0)\n\t\t\tca->state = CDG_NONFULL;\n\t}\n\treturn grad;\n}\n\nstatic bool tcp_cdg_backoff(struct sock *sk, u32 grad)\n{\n\tstruct cdg *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (get_random_u32() <= nexp_u32(grad * backoff_factor))\n\t\treturn false;\n\n\tif (use_ineff) {\n\t\tca->backoff_cnt++;\n\t\tif (ca->backoff_cnt > use_ineff)\n\t\t\treturn false;\n\t}\n\n\tca->shadow_wnd = max(ca->shadow_wnd, tcp_snd_cwnd(tp));\n\tca->state = CDG_BACKOFF;\n\ttcp_enter_cwr(sk);\n\treturn true;\n}\n\n \nstatic void tcp_cdg_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tstruct cdg *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 prior_snd_cwnd;\n\tu32 incr;\n\n\tif (tcp_in_slow_start(tp) && hystart_detect)\n\t\ttcp_cdg_hystart_update(sk);\n\n\tif (after(ack, ca->rtt_seq) && ca->rtt.v64) {\n\t\ts32 grad = 0;\n\n\t\tif (ca->rtt_prev.v64)\n\t\t\tgrad = tcp_cdg_grad(ca);\n\t\tca->rtt_seq = tp->snd_nxt;\n\t\tca->rtt_prev = ca->rtt;\n\t\tca->rtt.v64 = 0;\n\t\tca->last_ack = 0;\n\t\tca->sample_cnt = 0;\n\n\t\tif (grad > 0 && tcp_cdg_backoff(sk, grad))\n\t\t\treturn;\n\t}\n\n\tif (!tcp_is_cwnd_limited(sk)) {\n\t\tca->shadow_wnd = min(ca->shadow_wnd, tcp_snd_cwnd(tp));\n\t\treturn;\n\t}\n\n\tprior_snd_cwnd = tcp_snd_cwnd(tp);\n\ttcp_reno_cong_avoid(sk, ack, acked);\n\n\tincr = tcp_snd_cwnd(tp) - prior_snd_cwnd;\n\tca->shadow_wnd = max(ca->shadow_wnd, ca->shadow_wnd + incr);\n}\n\nstatic void tcp_cdg_acked(struct sock *sk, const struct ack_sample *sample)\n{\n\tstruct cdg *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (sample->rtt_us <= 0)\n\t\treturn;\n\n\t \n\tif (tp->sacked_out == 0) {\n\t\tif (sample->pkts_acked == 1 && ca->delack) {\n\t\t\t \n\t\t\tca->rtt.min = min(ca->rtt.min, sample->rtt_us);\n\t\t\tca->delack--;\n\t\t\treturn;\n\t\t} else if (sample->pkts_acked > 1 && ca->delack < 5) {\n\t\t\tca->delack++;\n\t\t}\n\t}\n\n\tca->rtt.min = min_not_zero(ca->rtt.min, sample->rtt_us);\n\tca->rtt.max = max(ca->rtt.max, sample->rtt_us);\n}\n\nstatic u32 tcp_cdg_ssthresh(struct sock *sk)\n{\n\tstruct cdg *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tif (ca->state == CDG_BACKOFF)\n\t\treturn max(2U, (tcp_snd_cwnd(tp) * min(1024U, backoff_beta)) >> 10);\n\n\tif (ca->state == CDG_NONFULL && use_tolerance)\n\t\treturn tcp_snd_cwnd(tp);\n\n\tca->shadow_wnd = min(ca->shadow_wnd >> 1, tcp_snd_cwnd(tp));\n\tif (use_shadow)\n\t\treturn max3(2U, ca->shadow_wnd, tcp_snd_cwnd(tp) >> 1);\n\treturn max(2U, tcp_snd_cwnd(tp) >> 1);\n}\n\nstatic void tcp_cdg_cwnd_event(struct sock *sk, const enum tcp_ca_event ev)\n{\n\tstruct cdg *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct cdg_minmax *gradients;\n\n\tswitch (ev) {\n\tcase CA_EVENT_CWND_RESTART:\n\t\tgradients = ca->gradients;\n\t\tif (gradients)\n\t\t\tmemset(gradients, 0, window * sizeof(gradients[0]));\n\t\tmemset(ca, 0, sizeof(*ca));\n\n\t\tca->gradients = gradients;\n\t\tca->rtt_seq = tp->snd_nxt;\n\t\tca->shadow_wnd = tcp_snd_cwnd(tp);\n\t\tbreak;\n\tcase CA_EVENT_COMPLETE_CWR:\n\t\tca->state = CDG_UNKNOWN;\n\t\tca->rtt_seq = tp->snd_nxt;\n\t\tca->rtt_prev = ca->rtt;\n\t\tca->rtt.v64 = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void tcp_cdg_init(struct sock *sk)\n{\n\tstruct cdg *ca = inet_csk_ca(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tca->gradients = NULL;\n\t \n\tif (window > 1)\n\t\tca->gradients = kcalloc(window, sizeof(ca->gradients[0]),\n\t\t\t\t\tGFP_NOWAIT | __GFP_NOWARN);\n\tca->rtt_seq = tp->snd_nxt;\n\tca->shadow_wnd = tcp_snd_cwnd(tp);\n}\n\nstatic void tcp_cdg_release(struct sock *sk)\n{\n\tstruct cdg *ca = inet_csk_ca(sk);\n\n\tkfree(ca->gradients);\n\tca->gradients = NULL;\n}\n\nstatic struct tcp_congestion_ops tcp_cdg __read_mostly = {\n\t.cong_avoid = tcp_cdg_cong_avoid,\n\t.cwnd_event = tcp_cdg_cwnd_event,\n\t.pkts_acked = tcp_cdg_acked,\n\t.undo_cwnd = tcp_reno_undo_cwnd,\n\t.ssthresh = tcp_cdg_ssthresh,\n\t.release = tcp_cdg_release,\n\t.init = tcp_cdg_init,\n\t.owner = THIS_MODULE,\n\t.name = \"cdg\",\n};\n\nstatic int __init tcp_cdg_register(void)\n{\n\tif (backoff_beta > 1024 || window < 1 || window > 256)\n\t\treturn -ERANGE;\n\tif (!is_power_of_2(window))\n\t\treturn -EINVAL;\n\n\tBUILD_BUG_ON(sizeof(struct cdg) > ICSK_CA_PRIV_SIZE);\n\ttcp_register_congestion_control(&tcp_cdg);\n\treturn 0;\n}\n\nstatic void __exit tcp_cdg_unregister(void)\n{\n\ttcp_unregister_congestion_control(&tcp_cdg);\n}\n\nmodule_init(tcp_cdg_register);\nmodule_exit(tcp_cdg_unregister);\nMODULE_AUTHOR(\"Kenneth Klette Jonassen\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TCP CDG\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}