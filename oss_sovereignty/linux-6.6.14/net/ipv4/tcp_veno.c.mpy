{
  "module_name": "tcp_veno.c",
  "hash_id": "743d80b294c8ed3a7ddb01e7bdf54721764b1292ca72a08778ae71e2351be59b",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_veno.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/inet_diag.h>\n\n#include <net/tcp.h>\n\n \n#define V_PARAM_SHIFT 1\nstatic const int beta = 3 << V_PARAM_SHIFT;\n\n \nstruct veno {\n\tu8 doing_veno_now;\t \n\tu16 cntrtt;\t\t \n\tu32 minrtt;\t\t \n\tu32 basertt;\t\t \n\tu32 inc;\t\t \n\tu32 diff;\t\t \n};\n\n \nstatic inline void veno_enable(struct sock *sk)\n{\n\tstruct veno *veno = inet_csk_ca(sk);\n\n\t \n\tveno->doing_veno_now = 1;\n\n\tveno->minrtt = 0x7fffffff;\n}\n\nstatic inline void veno_disable(struct sock *sk)\n{\n\tstruct veno *veno = inet_csk_ca(sk);\n\n\t \n\tveno->doing_veno_now = 0;\n}\n\nstatic void tcp_veno_init(struct sock *sk)\n{\n\tstruct veno *veno = inet_csk_ca(sk);\n\n\tveno->basertt = 0x7fffffff;\n\tveno->inc = 1;\n\tveno_enable(sk);\n}\n\n \nstatic void tcp_veno_pkts_acked(struct sock *sk,\n\t\t\t\tconst struct ack_sample *sample)\n{\n\tstruct veno *veno = inet_csk_ca(sk);\n\tu32 vrtt;\n\n\tif (sample->rtt_us < 0)\n\t\treturn;\n\n\t \n\tvrtt = sample->rtt_us + 1;\n\n\t \n\tif (vrtt < veno->basertt)\n\t\tveno->basertt = vrtt;\n\n\t \n\tveno->minrtt = min(veno->minrtt, vrtt);\n\tveno->cntrtt++;\n}\n\nstatic void tcp_veno_state(struct sock *sk, u8 ca_state)\n{\n\tif (ca_state == TCP_CA_Open)\n\t\tveno_enable(sk);\n\telse\n\t\tveno_disable(sk);\n}\n\n \nstatic void tcp_veno_cwnd_event(struct sock *sk, enum tcp_ca_event event)\n{\n\tif (event == CA_EVENT_CWND_RESTART || event == CA_EVENT_TX_START)\n\t\ttcp_veno_init(sk);\n}\n\nstatic void tcp_veno_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct veno *veno = inet_csk_ca(sk);\n\n\tif (!veno->doing_veno_now) {\n\t\ttcp_reno_cong_avoid(sk, ack, acked);\n\t\treturn;\n\t}\n\n\t \n\tif (!tcp_is_cwnd_limited(sk))\n\t\treturn;\n\n\t \n\tif (veno->cntrtt <= 2) {\n\t\t \n\t\ttcp_reno_cong_avoid(sk, ack, acked);\n\t} else {\n\t\tu64 target_cwnd;\n\t\tu32 rtt;\n\n\t\t \n\n\t\trtt = veno->minrtt;\n\n\t\ttarget_cwnd = (u64)tcp_snd_cwnd(tp) * veno->basertt;\n\t\ttarget_cwnd <<= V_PARAM_SHIFT;\n\t\tdo_div(target_cwnd, rtt);\n\n\t\tveno->diff = (tcp_snd_cwnd(tp) << V_PARAM_SHIFT) - target_cwnd;\n\n\t\tif (tcp_in_slow_start(tp)) {\n\t\t\t \n\t\t\tacked = tcp_slow_start(tp, acked);\n\t\t\tif (!acked)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (veno->diff < beta) {\n\t\t\t \n\t\t\ttcp_cong_avoid_ai(tp, tcp_snd_cwnd(tp), acked);\n\t\t} else {\n\t\t\t \n\t\t\tif (tp->snd_cwnd_cnt >= tcp_snd_cwnd(tp)) {\n\t\t\t\tif (veno->inc &&\n\t\t\t\t    tcp_snd_cwnd(tp) < tp->snd_cwnd_clamp) {\n\t\t\t\t\ttcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) + 1);\n\t\t\t\t\tveno->inc = 0;\n\t\t\t\t} else\n\t\t\t\t\tveno->inc = 1;\n\t\t\t\ttp->snd_cwnd_cnt = 0;\n\t\t\t} else\n\t\t\t\ttp->snd_cwnd_cnt += acked;\n\t\t}\ndone:\n\t\tif (tcp_snd_cwnd(tp) < 2)\n\t\t\ttcp_snd_cwnd_set(tp, 2);\n\t\telse if (tcp_snd_cwnd(tp) > tp->snd_cwnd_clamp)\n\t\t\ttcp_snd_cwnd_set(tp, tp->snd_cwnd_clamp);\n\t}\n\t \n\t \n\tveno->minrtt = 0x7fffffff;\n}\n\n \nstatic u32 tcp_veno_ssthresh(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct veno *veno = inet_csk_ca(sk);\n\n\tif (veno->diff < beta)\n\t\t \n\t\treturn max(tcp_snd_cwnd(tp) * 4 / 5, 2U);\n\telse\n\t\t \n\t\treturn max(tcp_snd_cwnd(tp) >> 1U, 2U);\n}\n\nstatic struct tcp_congestion_ops tcp_veno __read_mostly = {\n\t.init\t\t= tcp_veno_init,\n\t.ssthresh\t= tcp_veno_ssthresh,\n\t.undo_cwnd\t= tcp_reno_undo_cwnd,\n\t.cong_avoid\t= tcp_veno_cong_avoid,\n\t.pkts_acked\t= tcp_veno_pkts_acked,\n\t.set_state\t= tcp_veno_state,\n\t.cwnd_event\t= tcp_veno_cwnd_event,\n\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"veno\",\n};\n\nstatic int __init tcp_veno_register(void)\n{\n\tBUILD_BUG_ON(sizeof(struct veno) > ICSK_CA_PRIV_SIZE);\n\ttcp_register_congestion_control(&tcp_veno);\n\treturn 0;\n}\n\nstatic void __exit tcp_veno_unregister(void)\n{\n\ttcp_unregister_congestion_control(&tcp_veno);\n}\n\nmodule_init(tcp_veno_register);\nmodule_exit(tcp_veno_unregister);\n\nMODULE_AUTHOR(\"Bin Zhou, Cheng Peng Fu\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TCP Veno\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}