{
  "module_name": "ipcomp.c",
  "hash_id": "420b7073919b02d4c26ceaa0897b463e194efe3887d495515d197733d70f2e7a",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ipcomp.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/rtnetlink.h>\n#include <net/ip.h>\n#include <net/xfrm.h>\n#include <net/icmp.h>\n#include <net/ipcomp.h>\n#include <net/protocol.h>\n#include <net/sock.h>\n\nstatic int ipcomp4_err(struct sk_buff *skb, u32 info)\n{\n\tstruct net *net = dev_net(skb->dev);\n\t__be32 spi;\n\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\tstruct ip_comp_hdr *ipch = (struct ip_comp_hdr *)(skb->data+(iph->ihl<<2));\n\tstruct xfrm_state *x;\n\n\tswitch (icmp_hdr(skb)->type) {\n\tcase ICMP_DEST_UNREACH:\n\t\tif (icmp_hdr(skb)->code != ICMP_FRAG_NEEDED)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase ICMP_REDIRECT:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tspi = htonl(ntohs(ipch->cpi));\n\tx = xfrm_state_lookup(net, skb->mark, (const xfrm_address_t *)&iph->daddr,\n\t\t\t      spi, IPPROTO_COMP, AF_INET);\n\tif (!x)\n\t\treturn 0;\n\n\tif (icmp_hdr(skb)->type == ICMP_DEST_UNREACH)\n\t\tipv4_update_pmtu(skb, net, info, 0, IPPROTO_COMP);\n\telse\n\t\tipv4_redirect(skb, net, 0, IPPROTO_COMP);\n\txfrm_state_put(x);\n\n\treturn 0;\n}\n\n \nstatic struct xfrm_state *ipcomp_tunnel_create(struct xfrm_state *x)\n{\n\tstruct net *net = xs_net(x);\n\tstruct xfrm_state *t;\n\n\tt = xfrm_state_alloc(net);\n\tif (!t)\n\t\tgoto out;\n\n\tt->id.proto = IPPROTO_IPIP;\n\tt->id.spi = x->props.saddr.a4;\n\tt->id.daddr.a4 = x->id.daddr.a4;\n\tmemcpy(&t->sel, &x->sel, sizeof(t->sel));\n\tt->props.family = AF_INET;\n\tt->props.mode = x->props.mode;\n\tt->props.saddr.a4 = x->props.saddr.a4;\n\tt->props.flags = x->props.flags;\n\tt->props.extra_flags = x->props.extra_flags;\n\tmemcpy(&t->mark, &x->mark, sizeof(t->mark));\n\tt->if_id = x->if_id;\n\n\tif (xfrm_init_state(t))\n\t\tgoto error;\n\n\tatomic_set(&t->tunnel_users, 1);\nout:\n\treturn t;\n\nerror:\n\tt->km.state = XFRM_STATE_DEAD;\n\txfrm_state_put(t);\n\tt = NULL;\n\tgoto out;\n}\n\n \nstatic int ipcomp_tunnel_attach(struct xfrm_state *x)\n{\n\tstruct net *net = xs_net(x);\n\tint err = 0;\n\tstruct xfrm_state *t;\n\tu32 mark = x->mark.v & x->mark.m;\n\n\tt = xfrm_state_lookup(net, mark, (xfrm_address_t *)&x->id.daddr.a4,\n\t\t\t      x->props.saddr.a4, IPPROTO_IPIP, AF_INET);\n\tif (!t) {\n\t\tt = ipcomp_tunnel_create(x);\n\t\tif (!t) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\txfrm_state_insert(t);\n\t\txfrm_state_hold(t);\n\t}\n\tx->tunnel = t;\n\tatomic_inc(&t->tunnel_users);\nout:\n\treturn err;\n}\n\nstatic int ipcomp4_init_state(struct xfrm_state *x,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint err = -EINVAL;\n\n\tx->props.header_len = 0;\n\tswitch (x->props.mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\t\tbreak;\n\tcase XFRM_MODE_TUNNEL:\n\t\tx->props.header_len += sizeof(struct iphdr);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG(extack, \"Unsupported XFRM mode for IPcomp\");\n\t\tgoto out;\n\t}\n\n\terr = ipcomp_init_state(x, extack);\n\tif (err)\n\t\tgoto out;\n\n\tif (x->props.mode == XFRM_MODE_TUNNEL) {\n\t\terr = ipcomp_tunnel_attach(x);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Kernel error: failed to initialize the associated state\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = 0;\nout:\n\treturn err;\n}\n\nstatic int ipcomp4_rcv_cb(struct sk_buff *skb, int err)\n{\n\treturn 0;\n}\n\nstatic const struct xfrm_type ipcomp_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.proto\t     \t= IPPROTO_COMP,\n\t.init_state\t= ipcomp4_init_state,\n\t.destructor\t= ipcomp_destroy,\n\t.input\t\t= ipcomp_input,\n\t.output\t\t= ipcomp_output\n};\n\nstatic struct xfrm4_protocol ipcomp4_protocol = {\n\t.handler\t=\txfrm4_rcv,\n\t.input_handler\t=\txfrm_input,\n\t.cb_handler\t=\tipcomp4_rcv_cb,\n\t.err_handler\t=\tipcomp4_err,\n\t.priority\t=\t0,\n};\n\nstatic int __init ipcomp4_init(void)\n{\n\tif (xfrm_register_type(&ipcomp_type, AF_INET) < 0) {\n\t\tpr_info(\"%s: can't add xfrm type\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\tif (xfrm4_protocol_register(&ipcomp4_protocol, IPPROTO_COMP) < 0) {\n\t\tpr_info(\"%s: can't add protocol\\n\", __func__);\n\t\txfrm_unregister_type(&ipcomp_type, AF_INET);\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic void __exit ipcomp4_fini(void)\n{\n\tif (xfrm4_protocol_deregister(&ipcomp4_protocol, IPPROTO_COMP) < 0)\n\t\tpr_info(\"%s: can't remove protocol\\n\", __func__);\n\txfrm_unregister_type(&ipcomp_type, AF_INET);\n}\n\nmodule_init(ipcomp4_init);\nmodule_exit(ipcomp4_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"IP Payload Compression Protocol (IPComp/IPv4) - RFC3173\");\nMODULE_AUTHOR(\"James Morris <jmorris@intercode.com.au>\");\n\nMODULE_ALIAS_XFRM_TYPE(AF_INET, XFRM_PROTO_COMP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}