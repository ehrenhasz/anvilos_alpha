{
  "module_name": "tcp_nv.c",
  "hash_id": "e666a1fafe05edbceea797d3941ae71cdbc51044d71e74446597c7c2bb73a9a6",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_nv.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <net/tcp.h>\n#include <linux/inet_diag.h>\n\n \n\nstatic int nv_pad __read_mostly = 10;\nstatic int nv_pad_buffer __read_mostly = 2;\nstatic int nv_reset_period __read_mostly = 5;  \nstatic int nv_min_cwnd __read_mostly = 2;\nstatic int nv_cong_dec_mult __read_mostly = 30 * 128 / 100;  \nstatic int nv_ssthresh_factor __read_mostly = 8;  \nstatic int nv_rtt_factor __read_mostly = 128;  \nstatic int nv_loss_dec_factor __read_mostly = 819;  \nstatic int nv_cwnd_growth_rate_neg __read_mostly = 8;\nstatic int nv_cwnd_growth_rate_pos __read_mostly;  \nstatic int nv_dec_eval_min_calls __read_mostly = 60;\nstatic int nv_inc_eval_min_calls __read_mostly = 20;\nstatic int nv_ssthresh_eval_min_calls __read_mostly = 30;\nstatic int nv_stop_rtt_cnt __read_mostly = 10;\nstatic int nv_rtt_min_cnt __read_mostly = 2;\n\nmodule_param(nv_pad, int, 0644);\nMODULE_PARM_DESC(nv_pad, \"max queued packets allowed in network\");\nmodule_param(nv_reset_period, int, 0644);\nMODULE_PARM_DESC(nv_reset_period, \"nv_min_rtt reset period (secs)\");\nmodule_param(nv_min_cwnd, int, 0644);\nMODULE_PARM_DESC(nv_min_cwnd, \"NV will not decrease cwnd below this value\"\n\t\t \" without losses\");\n\n \nstruct tcpnv {\n\tunsigned long nv_min_rtt_reset_jiffies;   \n\ts8  cwnd_growth_factor;\t \n\tu8  available8;\n\tu16 available16;\n\tu8  nv_allow_cwnd_growth:1,  \n\t\tnv_reset:1,\t     \n\t\tnv_catchup:1;\t     \n\tu8  nv_eval_call_cnt;\t \n\tu8  nv_min_cwnd;\t \n\tu8  nv_rtt_cnt;\t\t ;\n\tu32 nv_last_rtt;\t \n\tu32 nv_min_rtt;\t\t \n\tu32 nv_min_rtt_new;\t \n\tu32 nv_base_rtt;         \n\tu32 nv_lower_bound_rtt;  \n\tu32 nv_rtt_max_rate;\t \n\tu32 nv_rtt_start_seq;\t \n\tu32 nv_last_snd_una;\t \n\tu32 nv_no_cong_cnt;\t \n};\n\n#define NV_INIT_RTT\t  U32_MAX\n#define NV_MIN_CWND\t  4\n#define NV_MIN_CWND_GROW  2\n#define NV_TSO_CWND_BOUND 80\n\nstatic inline void tcpnv_reset(struct tcpnv *ca, struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\tca->nv_reset = 0;\n\tca->nv_no_cong_cnt = 0;\n\tca->nv_rtt_cnt = 0;\n\tca->nv_last_rtt = 0;\n\tca->nv_rtt_max_rate = 0;\n\tca->nv_rtt_start_seq = tp->snd_una;\n\tca->nv_eval_call_cnt = 0;\n\tca->nv_last_snd_una = tp->snd_una;\n}\n\nstatic void tcpnv_init(struct sock *sk)\n{\n\tstruct tcpnv *ca = inet_csk_ca(sk);\n\tint base_rtt;\n\n\ttcpnv_reset(ca, sk);\n\n\t \n\tbase_rtt = tcp_call_bpf(sk, BPF_SOCK_OPS_BASE_RTT, 0, NULL);\n\tif (base_rtt > 0) {\n\t\tca->nv_base_rtt = base_rtt;\n\t\tca->nv_lower_bound_rtt = (base_rtt * 205) >> 8;  \n\t} else {\n\t\tca->nv_base_rtt = 0;\n\t\tca->nv_lower_bound_rtt = 0;\n\t}\n\n\tca->nv_allow_cwnd_growth = 1;\n\tca->nv_min_rtt_reset_jiffies = jiffies + 2 * HZ;\n\tca->nv_min_rtt = NV_INIT_RTT;\n\tca->nv_min_rtt_new = NV_INIT_RTT;\n\tca->nv_min_cwnd = NV_MIN_CWND;\n\tca->nv_catchup = 0;\n\tca->cwnd_growth_factor = 0;\n}\n\n \ninline u32 nv_get_bounded_rtt(struct tcpnv *ca, u32 val)\n{\n\tif (ca->nv_lower_bound_rtt > 0 && val < ca->nv_lower_bound_rtt)\n\t\treturn ca->nv_lower_bound_rtt;\n\telse if (ca->nv_base_rtt > 0 && val > ca->nv_base_rtt)\n\t\treturn ca->nv_base_rtt;\n\telse\n\t\treturn val;\n}\n\nstatic void tcpnv_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcpnv *ca = inet_csk_ca(sk);\n\tu32 cnt;\n\n\tif (!tcp_is_cwnd_limited(sk))\n\t\treturn;\n\n\t \n\tif (!ca->nv_allow_cwnd_growth)\n\t\treturn;\n\n\tif (tcp_in_slow_start(tp)) {\n\t\tacked = tcp_slow_start(tp, acked);\n\t\tif (!acked)\n\t\t\treturn;\n\t}\n\n\tif (ca->cwnd_growth_factor < 0) {\n\t\tcnt = tcp_snd_cwnd(tp) << -ca->cwnd_growth_factor;\n\t\ttcp_cong_avoid_ai(tp, cnt, acked);\n\t} else {\n\t\tcnt = max(4U, tcp_snd_cwnd(tp) >> ca->cwnd_growth_factor);\n\t\ttcp_cong_avoid_ai(tp, cnt, acked);\n\t}\n}\n\nstatic u32 tcpnv_recalc_ssthresh(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\treturn max((tcp_snd_cwnd(tp) * nv_loss_dec_factor) >> 10, 2U);\n}\n\nstatic void tcpnv_state(struct sock *sk, u8 new_state)\n{\n\tstruct tcpnv *ca = inet_csk_ca(sk);\n\n\tif (new_state == TCP_CA_Open && ca->nv_reset) {\n\t\ttcpnv_reset(ca, sk);\n\t} else if (new_state == TCP_CA_Loss || new_state == TCP_CA_CWR ||\n\t\tnew_state == TCP_CA_Recovery) {\n\t\tca->nv_reset = 1;\n\t\tca->nv_allow_cwnd_growth = 0;\n\t\tif (new_state == TCP_CA_Loss) {\n\t\t\t \n\t\t\tif (ca->cwnd_growth_factor > 0)\n\t\t\t\tca->cwnd_growth_factor = 0;\n\t\t\t \n\t\t\tif (nv_cwnd_growth_rate_neg > 0 &&\n\t\t\t    ca->cwnd_growth_factor > -8)\n\t\t\t\tca->cwnd_growth_factor--;\n\t\t}\n\t}\n}\n\n \nstatic void tcpnv_acked(struct sock *sk, const struct ack_sample *sample)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct tcpnv *ca = inet_csk_ca(sk);\n\tunsigned long now = jiffies;\n\tu64 rate64;\n\tu32 rate, max_win, cwnd_by_slope;\n\tu32 avg_rtt;\n\tu32 bytes_acked = 0;\n\n\t \n\tif (sample->rtt_us < 0)\n\t\treturn;\n\n\t \n\tif (icsk->icsk_ca_state != TCP_CA_Open &&\n\t    icsk->icsk_ca_state != TCP_CA_Disorder)\n\t\treturn;\n\n\t \n\tif (ca->nv_catchup && tcp_snd_cwnd(tp) >= nv_min_cwnd) {\n\t\tca->nv_catchup = 0;\n\t\tca->nv_allow_cwnd_growth = 0;\n\t}\n\n\tbytes_acked = tp->snd_una - ca->nv_last_snd_una;\n\tca->nv_last_snd_una = tp->snd_una;\n\n\tif (sample->in_flight == 0)\n\t\treturn;\n\n\t \n\tif (nv_rtt_factor > 0) {\n\t\tif (ca->nv_last_rtt > 0) {\n\t\t\tavg_rtt = (((u64)sample->rtt_us) * nv_rtt_factor +\n\t\t\t\t   ((u64)ca->nv_last_rtt)\n\t\t\t\t   * (256 - nv_rtt_factor)) >> 8;\n\t\t} else {\n\t\t\tavg_rtt = sample->rtt_us;\n\t\t\tca->nv_min_rtt = avg_rtt << 1;\n\t\t}\n\t\tca->nv_last_rtt = avg_rtt;\n\t} else {\n\t\tavg_rtt = sample->rtt_us;\n\t}\n\n\t \n\trate64 = ((u64)sample->in_flight) * 80000;\n\tdo_div(rate64, avg_rtt ?: 1);\n\trate = (u32)rate64;\n\n\t \n\tif (ca->nv_rtt_max_rate < rate)\n\t\tca->nv_rtt_max_rate = rate;\n\n\t \n\tif (ca->nv_eval_call_cnt < 255)\n\t\tca->nv_eval_call_cnt++;\n\n\t \n\tavg_rtt = nv_get_bounded_rtt(ca, avg_rtt);\n\n\t \n\tif (avg_rtt < ca->nv_min_rtt)\n\t\tca->nv_min_rtt = avg_rtt;\n\n\t \n\tif (avg_rtt < ca->nv_min_rtt_new)\n\t\tca->nv_min_rtt_new = avg_rtt;\n\n\t \n\tif (time_after_eq(now, ca->nv_min_rtt_reset_jiffies)) {\n\t\tunsigned char rand;\n\n\t\tca->nv_min_rtt = ca->nv_min_rtt_new;\n\t\tca->nv_min_rtt_new = NV_INIT_RTT;\n\t\tget_random_bytes(&rand, 1);\n\t\tca->nv_min_rtt_reset_jiffies =\n\t\t\tnow + ((nv_reset_period * (384 + rand) * HZ) >> 9);\n\t\t \n\t\tca->nv_min_cwnd = max(ca->nv_min_cwnd / 2, NV_MIN_CWND);\n\t}\n\n\t \n\tif (before(ca->nv_rtt_start_seq, tp->snd_una)) {\n\t\tca->nv_rtt_start_seq = tp->snd_nxt;\n\t\tif (ca->nv_rtt_cnt < 0xff)\n\t\t\t \n\t\t\tca->nv_rtt_cnt++;\n\n\t\t \n\t\tif (ca->nv_eval_call_cnt == 1 &&\n\t\t    bytes_acked >= (ca->nv_min_cwnd - 1) * tp->mss_cache &&\n\t\t    ca->nv_min_cwnd < (NV_TSO_CWND_BOUND + 1)) {\n\t\t\tca->nv_min_cwnd = min(ca->nv_min_cwnd\n\t\t\t\t\t      + NV_MIN_CWND_GROW,\n\t\t\t\t\t      NV_TSO_CWND_BOUND + 1);\n\t\t\tca->nv_rtt_start_seq = tp->snd_nxt +\n\t\t\t\tca->nv_min_cwnd * tp->mss_cache;\n\t\t\tca->nv_eval_call_cnt = 0;\n\t\t\tca->nv_allow_cwnd_growth = 1;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tcwnd_by_slope = (u32)\n\t\t\tdiv64_u64(((u64)ca->nv_rtt_max_rate) * ca->nv_min_rtt,\n\t\t\t\t  80000ULL * tp->mss_cache);\n\t\tmax_win = cwnd_by_slope + nv_pad;\n\n\t\t \n\t\tif (tcp_snd_cwnd(tp) > max_win) {\n\t\t\t \n\t\t\tif (ca->nv_rtt_cnt < nv_rtt_min_cnt) {\n\t\t\t\treturn;\n\t\t\t} else if (tp->snd_ssthresh == TCP_INFINITE_SSTHRESH) {\n\t\t\t\tif (ca->nv_eval_call_cnt <\n\t\t\t\t    nv_ssthresh_eval_min_calls)\n\t\t\t\t\treturn;\n\t\t\t\t \n\t\t\t} else if (ca->nv_eval_call_cnt <\n\t\t\t\t   nv_dec_eval_min_calls) {\n\t\t\t\tif (ca->nv_allow_cwnd_growth &&\n\t\t\t\t    ca->nv_rtt_cnt > nv_stop_rtt_cnt)\n\t\t\t\t\tca->nv_allow_cwnd_growth = 0;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tca->nv_allow_cwnd_growth = 0;\n\t\t\ttp->snd_ssthresh =\n\t\t\t\t(nv_ssthresh_factor * max_win) >> 3;\n\t\t\tif (tcp_snd_cwnd(tp) - max_win > 2) {\n\t\t\t\t \n\t\t\t\tint dec;\n\n\t\t\t\tdec = max(2U, ((tcp_snd_cwnd(tp) - max_win) *\n\t\t\t\t\t       nv_cong_dec_mult) >> 7);\n\t\t\t\ttcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) - dec);\n\t\t\t} else if (nv_cong_dec_mult > 0) {\n\t\t\t\ttcp_snd_cwnd_set(tp, max_win);\n\t\t\t}\n\t\t\tif (ca->cwnd_growth_factor > 0)\n\t\t\t\tca->cwnd_growth_factor = 0;\n\t\t\tca->nv_no_cong_cnt = 0;\n\t\t} else if (tcp_snd_cwnd(tp) <= max_win - nv_pad_buffer) {\n\t\t\t \n\t\t\tif (ca->nv_eval_call_cnt < nv_inc_eval_min_calls)\n\t\t\t\treturn;\n\n\t\t\tca->nv_allow_cwnd_growth = 1;\n\t\t\tca->nv_no_cong_cnt++;\n\t\t\tif (ca->cwnd_growth_factor < 0 &&\n\t\t\t    nv_cwnd_growth_rate_neg > 0 &&\n\t\t\t    ca->nv_no_cong_cnt > nv_cwnd_growth_rate_neg) {\n\t\t\t\tca->cwnd_growth_factor++;\n\t\t\t\tca->nv_no_cong_cnt = 0;\n\t\t\t} else if (ca->cwnd_growth_factor >= 0 &&\n\t\t\t\t   nv_cwnd_growth_rate_pos > 0 &&\n\t\t\t\t   ca->nv_no_cong_cnt >\n\t\t\t\t   nv_cwnd_growth_rate_pos) {\n\t\t\t\tca->cwnd_growth_factor++;\n\t\t\t\tca->nv_no_cong_cnt = 0;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tca->nv_eval_call_cnt = 0;\n\t\tca->nv_rtt_cnt = 0;\n\t\tca->nv_rtt_max_rate = 0;\n\n\t\t \n\t\tif (tcp_snd_cwnd(tp) < nv_min_cwnd)\n\t\t\ttcp_snd_cwnd_set(tp, nv_min_cwnd);\n\t}\n}\n\n \nstatic size_t tcpnv_get_info(struct sock *sk, u32 ext, int *attr,\n\t\t\t     union tcp_cc_info *info)\n{\n\tconst struct tcpnv *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tinfo->vegas.tcpv_enabled = 1;\n\t\tinfo->vegas.tcpv_rttcnt = ca->nv_rtt_cnt;\n\t\tinfo->vegas.tcpv_rtt = ca->nv_last_rtt;\n\t\tinfo->vegas.tcpv_minrtt = ca->nv_min_rtt;\n\n\t\t*attr = INET_DIAG_VEGASINFO;\n\t\treturn sizeof(struct tcpvegas_info);\n\t}\n\treturn 0;\n}\n\nstatic struct tcp_congestion_ops tcpnv __read_mostly = {\n\t.init\t\t= tcpnv_init,\n\t.ssthresh\t= tcpnv_recalc_ssthresh,\n\t.cong_avoid\t= tcpnv_cong_avoid,\n\t.set_state\t= tcpnv_state,\n\t.undo_cwnd\t= tcp_reno_undo_cwnd,\n\t.pkts_acked     = tcpnv_acked,\n\t.get_info\t= tcpnv_get_info,\n\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"nv\",\n};\n\nstatic int __init tcpnv_register(void)\n{\n\tBUILD_BUG_ON(sizeof(struct tcpnv) > ICSK_CA_PRIV_SIZE);\n\n\treturn tcp_register_congestion_control(&tcpnv);\n}\n\nstatic void __exit tcpnv_unregister(void)\n{\n\ttcp_unregister_congestion_control(&tcpnv);\n}\n\nmodule_init(tcpnv_register);\nmodule_exit(tcpnv_unregister);\n\nMODULE_AUTHOR(\"Lawrence Brakmo\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TCP NV\");\nMODULE_VERSION(\"1.0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}