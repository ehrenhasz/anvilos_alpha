{
  "module_name": "udp_tunnel_nic.c",
  "hash_id": "6603bad1fc00935a9ebb75351558c5af452c2f665f56504aaf07c9133b3964ea",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/udp_tunnel_nic.c",
  "human_readable_source": "\n\n\n#include <linux/ethtool_netlink.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <net/udp_tunnel.h>\n#include <net/vxlan.h>\n\nenum udp_tunnel_nic_table_entry_flags {\n\tUDP_TUNNEL_NIC_ENTRY_ADD\t= BIT(0),\n\tUDP_TUNNEL_NIC_ENTRY_DEL\t= BIT(1),\n\tUDP_TUNNEL_NIC_ENTRY_OP_FAIL\t= BIT(2),\n\tUDP_TUNNEL_NIC_ENTRY_FROZEN\t= BIT(3),\n};\n\nstruct udp_tunnel_nic_table_entry {\n\t__be16 port;\n\tu8 type;\n\tu8 flags;\n\tu16 use_cnt;\n#define UDP_TUNNEL_NIC_USE_CNT_MAX\tU16_MAX\n\tu8 hw_priv;\n};\n\n \nstruct udp_tunnel_nic {\n\tstruct work_struct work;\n\n\tstruct net_device *dev;\n\n\tu8 need_sync:1;\n\tu8 need_replay:1;\n\tu8 work_pending:1;\n\n\tunsigned int n_tables;\n\tunsigned long missed;\n\tstruct udp_tunnel_nic_table_entry **entries;\n};\n\n \nstatic struct workqueue_struct *udp_tunnel_nic_workqueue;\n\nstatic const char *udp_tunnel_nic_tunnel_type_name(unsigned int type)\n{\n\tswitch (type) {\n\tcase UDP_TUNNEL_TYPE_VXLAN:\n\t\treturn \"vxlan\";\n\tcase UDP_TUNNEL_TYPE_GENEVE:\n\t\treturn \"geneve\";\n\tcase UDP_TUNNEL_TYPE_VXLAN_GPE:\n\t\treturn \"vxlan-gpe\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic bool\nudp_tunnel_nic_entry_is_free(struct udp_tunnel_nic_table_entry *entry)\n{\n\treturn entry->use_cnt == 0 && !entry->flags;\n}\n\nstatic bool\nudp_tunnel_nic_entry_is_present(struct udp_tunnel_nic_table_entry *entry)\n{\n\treturn entry->use_cnt && !(entry->flags & ~UDP_TUNNEL_NIC_ENTRY_FROZEN);\n}\n\nstatic bool\nudp_tunnel_nic_entry_is_frozen(struct udp_tunnel_nic_table_entry *entry)\n{\n\treturn entry->flags & UDP_TUNNEL_NIC_ENTRY_FROZEN;\n}\n\nstatic void\nudp_tunnel_nic_entry_freeze_used(struct udp_tunnel_nic_table_entry *entry)\n{\n\tif (!udp_tunnel_nic_entry_is_free(entry))\n\t\tentry->flags |= UDP_TUNNEL_NIC_ENTRY_FROZEN;\n}\n\nstatic void\nudp_tunnel_nic_entry_unfreeze(struct udp_tunnel_nic_table_entry *entry)\n{\n\tentry->flags &= ~UDP_TUNNEL_NIC_ENTRY_FROZEN;\n}\n\nstatic bool\nudp_tunnel_nic_entry_is_queued(struct udp_tunnel_nic_table_entry *entry)\n{\n\treturn entry->flags & (UDP_TUNNEL_NIC_ENTRY_ADD |\n\t\t\t       UDP_TUNNEL_NIC_ENTRY_DEL);\n}\n\nstatic void\nudp_tunnel_nic_entry_queue(struct udp_tunnel_nic *utn,\n\t\t\t   struct udp_tunnel_nic_table_entry *entry,\n\t\t\t   unsigned int flag)\n{\n\tentry->flags |= flag;\n\tutn->need_sync = 1;\n}\n\nstatic void\nudp_tunnel_nic_ti_from_entry(struct udp_tunnel_nic_table_entry *entry,\n\t\t\t     struct udp_tunnel_info *ti)\n{\n\tmemset(ti, 0, sizeof(*ti));\n\tti->port = entry->port;\n\tti->type = entry->type;\n\tti->hw_priv = entry->hw_priv;\n}\n\nstatic bool\nudp_tunnel_nic_is_empty(struct net_device *dev, struct udp_tunnel_nic *utn)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tunsigned int i, j;\n\n\tfor (i = 0; i < utn->n_tables; i++)\n\t\tfor (j = 0; j < info->tables[i].n_entries; j++)\n\t\t\tif (!udp_tunnel_nic_entry_is_free(&utn->entries[i][j]))\n\t\t\t\treturn false;\n\treturn true;\n}\n\nstatic bool\nudp_tunnel_nic_should_replay(struct net_device *dev, struct udp_tunnel_nic *utn)\n{\n\tconst struct udp_tunnel_nic_table_info *table;\n\tunsigned int i, j;\n\n\tif (!utn->missed)\n\t\treturn false;\n\n\tfor (i = 0; i < utn->n_tables; i++) {\n\t\ttable = &dev->udp_tunnel_nic_info->tables[i];\n\t\tif (!test_bit(i, &utn->missed))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < table->n_entries; j++)\n\t\t\tif (udp_tunnel_nic_entry_is_free(&utn->entries[i][j]))\n\t\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void\n__udp_tunnel_nic_get_port(struct net_device *dev, unsigned int table,\n\t\t\t  unsigned int idx, struct udp_tunnel_info *ti)\n{\n\tstruct udp_tunnel_nic_table_entry *entry;\n\tstruct udp_tunnel_nic *utn;\n\n\tutn = dev->udp_tunnel_nic;\n\tentry = &utn->entries[table][idx];\n\n\tif (entry->use_cnt)\n\t\tudp_tunnel_nic_ti_from_entry(entry, ti);\n}\n\nstatic void\n__udp_tunnel_nic_set_port_priv(struct net_device *dev, unsigned int table,\n\t\t\t       unsigned int idx, u8 priv)\n{\n\tdev->udp_tunnel_nic->entries[table][idx].hw_priv = priv;\n}\n\nstatic void\nudp_tunnel_nic_entry_update_done(struct udp_tunnel_nic_table_entry *entry,\n\t\t\t\t int err)\n{\n\tbool dodgy = entry->flags & UDP_TUNNEL_NIC_ENTRY_OP_FAIL;\n\n\tWARN_ON_ONCE(entry->flags & UDP_TUNNEL_NIC_ENTRY_ADD &&\n\t\t     entry->flags & UDP_TUNNEL_NIC_ENTRY_DEL);\n\n\tif (entry->flags & UDP_TUNNEL_NIC_ENTRY_ADD &&\n\t    (!err || (err == -EEXIST && dodgy)))\n\t\tentry->flags &= ~UDP_TUNNEL_NIC_ENTRY_ADD;\n\n\tif (entry->flags & UDP_TUNNEL_NIC_ENTRY_DEL &&\n\t    (!err || (err == -ENOENT && dodgy)))\n\t\tentry->flags &= ~UDP_TUNNEL_NIC_ENTRY_DEL;\n\n\tif (!err)\n\t\tentry->flags &= ~UDP_TUNNEL_NIC_ENTRY_OP_FAIL;\n\telse\n\t\tentry->flags |= UDP_TUNNEL_NIC_ENTRY_OP_FAIL;\n}\n\nstatic void\nudp_tunnel_nic_device_sync_one(struct net_device *dev,\n\t\t\t       struct udp_tunnel_nic *utn,\n\t\t\t       unsigned int table, unsigned int idx)\n{\n\tstruct udp_tunnel_nic_table_entry *entry;\n\tstruct udp_tunnel_info ti;\n\tint err;\n\n\tentry = &utn->entries[table][idx];\n\tif (!udp_tunnel_nic_entry_is_queued(entry))\n\t\treturn;\n\n\tudp_tunnel_nic_ti_from_entry(entry, &ti);\n\tif (entry->flags & UDP_TUNNEL_NIC_ENTRY_ADD)\n\t\terr = dev->udp_tunnel_nic_info->set_port(dev, table, idx, &ti);\n\telse\n\t\terr = dev->udp_tunnel_nic_info->unset_port(dev, table, idx,\n\t\t\t\t\t\t\t   &ti);\n\tudp_tunnel_nic_entry_update_done(entry, err);\n\n\tif (err)\n\t\tnetdev_warn(dev,\n\t\t\t    \"UDP tunnel port sync failed port %d type %s: %d\\n\",\n\t\t\t    be16_to_cpu(entry->port),\n\t\t\t    udp_tunnel_nic_tunnel_type_name(entry->type),\n\t\t\t    err);\n}\n\nstatic void\nudp_tunnel_nic_device_sync_by_port(struct net_device *dev,\n\t\t\t\t   struct udp_tunnel_nic *utn)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tunsigned int i, j;\n\n\tfor (i = 0; i < utn->n_tables; i++)\n\t\tfor (j = 0; j < info->tables[i].n_entries; j++)\n\t\t\tudp_tunnel_nic_device_sync_one(dev, utn, i, j);\n}\n\nstatic void\nudp_tunnel_nic_device_sync_by_table(struct net_device *dev,\n\t\t\t\t    struct udp_tunnel_nic *utn)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tunsigned int i, j;\n\tint err;\n\n\tfor (i = 0; i < utn->n_tables; i++) {\n\t\t \n\t\tfor (j = 0; j < info->tables[i].n_entries; j++)\n\t\t\tif (udp_tunnel_nic_entry_is_queued(&utn->entries[i][j]))\n\t\t\t\tbreak;\n\t\tif (j == info->tables[i].n_entries)\n\t\t\tcontinue;\n\n\t\terr = info->sync_table(dev, i);\n\t\tif (err)\n\t\t\tnetdev_warn(dev, \"UDP tunnel port sync failed for table %d: %d\\n\",\n\t\t\t\t    i, err);\n\n\t\tfor (j = 0; j < info->tables[i].n_entries; j++) {\n\t\t\tstruct udp_tunnel_nic_table_entry *entry;\n\n\t\t\tentry = &utn->entries[i][j];\n\t\t\tif (udp_tunnel_nic_entry_is_queued(entry))\n\t\t\t\tudp_tunnel_nic_entry_update_done(entry, err);\n\t\t}\n\t}\n}\n\nstatic void\n__udp_tunnel_nic_device_sync(struct net_device *dev, struct udp_tunnel_nic *utn)\n{\n\tif (!utn->need_sync)\n\t\treturn;\n\n\tif (dev->udp_tunnel_nic_info->sync_table)\n\t\tudp_tunnel_nic_device_sync_by_table(dev, utn);\n\telse\n\t\tudp_tunnel_nic_device_sync_by_port(dev, utn);\n\n\tutn->need_sync = 0;\n\t \n\tutn->need_replay = udp_tunnel_nic_should_replay(dev, utn);\n}\n\nstatic void\nudp_tunnel_nic_device_sync(struct net_device *dev, struct udp_tunnel_nic *utn)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tbool may_sleep;\n\n\tif (!utn->need_sync)\n\t\treturn;\n\n\t \n\tmay_sleep = info->flags & UDP_TUNNEL_NIC_INFO_MAY_SLEEP;\n\tif (!may_sleep)\n\t\t__udp_tunnel_nic_device_sync(dev, utn);\n\tif (may_sleep || utn->need_replay) {\n\t\tqueue_work(udp_tunnel_nic_workqueue, &utn->work);\n\t\tutn->work_pending = 1;\n\t}\n}\n\nstatic bool\nudp_tunnel_nic_table_is_capable(const struct udp_tunnel_nic_table_info *table,\n\t\t\t\tstruct udp_tunnel_info *ti)\n{\n\treturn table->tunnel_types & ti->type;\n}\n\nstatic bool\nudp_tunnel_nic_is_capable(struct net_device *dev, struct udp_tunnel_nic *utn,\n\t\t\t  struct udp_tunnel_info *ti)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tunsigned int i;\n\n\t \n\tif (info->flags & UDP_TUNNEL_NIC_INFO_IPV4_ONLY &&\n\t    ti->sa_family != AF_INET)\n\t\treturn false;\n\n\tfor (i = 0; i < utn->n_tables; i++)\n\t\tif (udp_tunnel_nic_table_is_capable(&info->tables[i], ti))\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic int\nudp_tunnel_nic_has_collision(struct net_device *dev, struct udp_tunnel_nic *utn,\n\t\t\t     struct udp_tunnel_info *ti)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tstruct udp_tunnel_nic_table_entry *entry;\n\tunsigned int i, j;\n\n\tfor (i = 0; i < utn->n_tables; i++)\n\t\tfor (j = 0; j < info->tables[i].n_entries; j++) {\n\t\t\tentry =\t&utn->entries[i][j];\n\n\t\t\tif (!udp_tunnel_nic_entry_is_free(entry) &&\n\t\t\t    entry->port == ti->port &&\n\t\t\t    entry->type != ti->type) {\n\t\t\t\t__set_bit(i, &utn->missed);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nstatic void\nudp_tunnel_nic_entry_adj(struct udp_tunnel_nic *utn,\n\t\t\t unsigned int table, unsigned int idx, int use_cnt_adj)\n{\n\tstruct udp_tunnel_nic_table_entry *entry =  &utn->entries[table][idx];\n\tbool dodgy = entry->flags & UDP_TUNNEL_NIC_ENTRY_OP_FAIL;\n\tunsigned int from, to;\n\n\tWARN_ON(entry->use_cnt + (u32)use_cnt_adj > U16_MAX);\n\n\t \n\tentry->use_cnt += use_cnt_adj;\n\tif (!dodgy && !entry->use_cnt == !(entry->use_cnt - use_cnt_adj))\n\t\treturn;\n\n\t \n\tif (use_cnt_adj < 0) {\n\t\tfrom = UDP_TUNNEL_NIC_ENTRY_ADD;\n\t\tto = UDP_TUNNEL_NIC_ENTRY_DEL;\n\t} else {\n\t\tfrom = UDP_TUNNEL_NIC_ENTRY_DEL;\n\t\tto = UDP_TUNNEL_NIC_ENTRY_ADD;\n\t}\n\n\tif (entry->flags & from) {\n\t\tentry->flags &= ~from;\n\t\tif (!dodgy)\n\t\t\treturn;\n\t}\n\n\tudp_tunnel_nic_entry_queue(utn, entry, to);\n}\n\nstatic bool\nudp_tunnel_nic_entry_try_adj(struct udp_tunnel_nic *utn,\n\t\t\t     unsigned int table, unsigned int idx,\n\t\t\t     struct udp_tunnel_info *ti, int use_cnt_adj)\n{\n\tstruct udp_tunnel_nic_table_entry *entry =  &utn->entries[table][idx];\n\n\tif (udp_tunnel_nic_entry_is_free(entry) ||\n\t    entry->port != ti->port ||\n\t    entry->type != ti->type)\n\t\treturn false;\n\n\tif (udp_tunnel_nic_entry_is_frozen(entry))\n\t\treturn true;\n\n\tudp_tunnel_nic_entry_adj(utn, table, idx, use_cnt_adj);\n\treturn true;\n}\n\n \nstatic bool\nudp_tunnel_nic_try_existing(struct net_device *dev, struct udp_tunnel_nic *utn,\n\t\t\t    struct udp_tunnel_info *ti, int use_cnt_adj)\n{\n\tconst struct udp_tunnel_nic_table_info *table;\n\tunsigned int i, j;\n\n\tfor (i = 0; i < utn->n_tables; i++) {\n\t\ttable = &dev->udp_tunnel_nic_info->tables[i];\n\t\tif (!udp_tunnel_nic_table_is_capable(table, ti))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < table->n_entries; j++)\n\t\t\tif (udp_tunnel_nic_entry_try_adj(utn, i, j, ti,\n\t\t\t\t\t\t\t use_cnt_adj))\n\t\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool\nudp_tunnel_nic_add_existing(struct net_device *dev, struct udp_tunnel_nic *utn,\n\t\t\t    struct udp_tunnel_info *ti)\n{\n\treturn udp_tunnel_nic_try_existing(dev, utn, ti, +1);\n}\n\nstatic bool\nudp_tunnel_nic_del_existing(struct net_device *dev, struct udp_tunnel_nic *utn,\n\t\t\t    struct udp_tunnel_info *ti)\n{\n\treturn udp_tunnel_nic_try_existing(dev, utn, ti, -1);\n}\n\nstatic bool\nudp_tunnel_nic_add_new(struct net_device *dev, struct udp_tunnel_nic *utn,\n\t\t       struct udp_tunnel_info *ti)\n{\n\tconst struct udp_tunnel_nic_table_info *table;\n\tunsigned int i, j;\n\n\tfor (i = 0; i < utn->n_tables; i++) {\n\t\ttable = &dev->udp_tunnel_nic_info->tables[i];\n\t\tif (!udp_tunnel_nic_table_is_capable(table, ti))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < table->n_entries; j++) {\n\t\t\tstruct udp_tunnel_nic_table_entry *entry;\n\n\t\t\tentry = &utn->entries[i][j];\n\t\t\tif (!udp_tunnel_nic_entry_is_free(entry))\n\t\t\t\tcontinue;\n\n\t\t\tentry->port = ti->port;\n\t\t\tentry->type = ti->type;\n\t\t\tentry->use_cnt = 1;\n\t\t\tudp_tunnel_nic_entry_queue(utn, entry,\n\t\t\t\t\t\t   UDP_TUNNEL_NIC_ENTRY_ADD);\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\t__set_bit(i, &utn->missed);\n\t}\n\n\treturn false;\n}\n\nstatic void\n__udp_tunnel_nic_add_port(struct net_device *dev, struct udp_tunnel_info *ti)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tstruct udp_tunnel_nic *utn;\n\n\tutn = dev->udp_tunnel_nic;\n\tif (!utn)\n\t\treturn;\n\tif (!netif_running(dev) && info->flags & UDP_TUNNEL_NIC_INFO_OPEN_ONLY)\n\t\treturn;\n\tif (info->flags & UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN &&\n\t    ti->port == htons(IANA_VXLAN_UDP_PORT)) {\n\t\tif (ti->type != UDP_TUNNEL_TYPE_VXLAN)\n\t\t\tnetdev_warn(dev, \"device assumes port 4789 will be used by vxlan tunnels\\n\");\n\t\treturn;\n\t}\n\n\tif (!udp_tunnel_nic_is_capable(dev, utn, ti))\n\t\treturn;\n\n\t \n\tif (udp_tunnel_nic_has_collision(dev, utn, ti))\n\t\treturn;\n\n\tif (!udp_tunnel_nic_add_existing(dev, utn, ti))\n\t\tudp_tunnel_nic_add_new(dev, utn, ti);\n\n\tudp_tunnel_nic_device_sync(dev, utn);\n}\n\nstatic void\n__udp_tunnel_nic_del_port(struct net_device *dev, struct udp_tunnel_info *ti)\n{\n\tstruct udp_tunnel_nic *utn;\n\n\tutn = dev->udp_tunnel_nic;\n\tif (!utn)\n\t\treturn;\n\n\tif (!udp_tunnel_nic_is_capable(dev, utn, ti))\n\t\treturn;\n\n\tudp_tunnel_nic_del_existing(dev, utn, ti);\n\n\tudp_tunnel_nic_device_sync(dev, utn);\n}\n\nstatic void __udp_tunnel_nic_reset_ntf(struct net_device *dev)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tstruct udp_tunnel_nic *utn;\n\tunsigned int i, j;\n\n\tASSERT_RTNL();\n\n\tutn = dev->udp_tunnel_nic;\n\tif (!utn)\n\t\treturn;\n\n\tutn->need_sync = false;\n\tfor (i = 0; i < utn->n_tables; i++)\n\t\tfor (j = 0; j < info->tables[i].n_entries; j++) {\n\t\t\tstruct udp_tunnel_nic_table_entry *entry;\n\n\t\t\tentry = &utn->entries[i][j];\n\n\t\t\tentry->flags &= ~(UDP_TUNNEL_NIC_ENTRY_DEL |\n\t\t\t\t\t  UDP_TUNNEL_NIC_ENTRY_OP_FAIL);\n\t\t\t \n\t\t\tWARN_ON(entry->flags & UDP_TUNNEL_NIC_ENTRY_FROZEN);\n\t\t\tif (!entry->use_cnt)\n\t\t\t\tcontinue;\n\n\t\t\tudp_tunnel_nic_entry_queue(utn, entry,\n\t\t\t\t\t\t   UDP_TUNNEL_NIC_ENTRY_ADD);\n\t\t}\n\n\t__udp_tunnel_nic_device_sync(dev, utn);\n}\n\nstatic size_t\n__udp_tunnel_nic_dump_size(struct net_device *dev, unsigned int table)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tstruct udp_tunnel_nic *utn;\n\tunsigned int j;\n\tsize_t size;\n\n\tutn = dev->udp_tunnel_nic;\n\tif (!utn)\n\t\treturn 0;\n\n\tsize = 0;\n\tfor (j = 0; j < info->tables[table].n_entries; j++) {\n\t\tif (!udp_tunnel_nic_entry_is_present(&utn->entries[table][j]))\n\t\t\tcontinue;\n\n\t\tsize += nla_total_size(0) +\t\t  \n\t\t\tnla_total_size(sizeof(__be16)) +  \n\t\t\tnla_total_size(sizeof(u32));\t  \n\t}\n\n\treturn size;\n}\n\nstatic int\n__udp_tunnel_nic_dump_write(struct net_device *dev, unsigned int table,\n\t\t\t    struct sk_buff *skb)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tstruct udp_tunnel_nic *utn;\n\tstruct nlattr *nest;\n\tunsigned int j;\n\n\tutn = dev->udp_tunnel_nic;\n\tif (!utn)\n\t\treturn 0;\n\n\tfor (j = 0; j < info->tables[table].n_entries; j++) {\n\t\tif (!udp_tunnel_nic_entry_is_present(&utn->entries[table][j]))\n\t\t\tcontinue;\n\n\t\tnest = nla_nest_start(skb, ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY);\n\t\tif (!nest)\n\t\t\treturn -EMSGSIZE;\n\n\t\tif (nla_put_be16(skb, ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT,\n\t\t\t\t utn->entries[table][j].port) ||\n\t\t    nla_put_u32(skb, ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE,\n\t\t\t\tilog2(utn->entries[table][j].type)))\n\t\t\tgoto err_cancel;\n\n\t\tnla_nest_end(skb, nest);\n\t}\n\n\treturn 0;\n\nerr_cancel:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic const struct udp_tunnel_nic_ops __udp_tunnel_nic_ops = {\n\t.get_port\t= __udp_tunnel_nic_get_port,\n\t.set_port_priv\t= __udp_tunnel_nic_set_port_priv,\n\t.add_port\t= __udp_tunnel_nic_add_port,\n\t.del_port\t= __udp_tunnel_nic_del_port,\n\t.reset_ntf\t= __udp_tunnel_nic_reset_ntf,\n\t.dump_size\t= __udp_tunnel_nic_dump_size,\n\t.dump_write\t= __udp_tunnel_nic_dump_write,\n};\n\nstatic void\nudp_tunnel_nic_flush(struct net_device *dev, struct udp_tunnel_nic *utn)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tunsigned int i, j;\n\n\tfor (i = 0; i < utn->n_tables; i++)\n\t\tfor (j = 0; j < info->tables[i].n_entries; j++) {\n\t\t\tint adj_cnt = -utn->entries[i][j].use_cnt;\n\n\t\t\tif (adj_cnt)\n\t\t\t\tudp_tunnel_nic_entry_adj(utn, i, j, adj_cnt);\n\t\t}\n\n\t__udp_tunnel_nic_device_sync(dev, utn);\n\n\tfor (i = 0; i < utn->n_tables; i++)\n\t\tmemset(utn->entries[i], 0, array_size(info->tables[i].n_entries,\n\t\t\t\t\t\t      sizeof(**utn->entries)));\n\tWARN_ON(utn->need_sync);\n\tutn->need_replay = 0;\n}\n\nstatic void\nudp_tunnel_nic_replay(struct net_device *dev, struct udp_tunnel_nic *utn)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tstruct udp_tunnel_nic_shared_node *node;\n\tunsigned int i, j;\n\n\t \n\tfor (i = 0; i < utn->n_tables; i++)\n\t\tfor (j = 0; j < info->tables[i].n_entries; j++)\n\t\t\tudp_tunnel_nic_entry_freeze_used(&utn->entries[i][j]);\n\tutn->missed = 0;\n\tutn->need_replay = 0;\n\n\tif (!info->shared) {\n\t\tudp_tunnel_get_rx_info(dev);\n\t} else {\n\t\tlist_for_each_entry(node, &info->shared->devices, list)\n\t\t\tudp_tunnel_get_rx_info(node->dev);\n\t}\n\n\tfor (i = 0; i < utn->n_tables; i++)\n\t\tfor (j = 0; j < info->tables[i].n_entries; j++)\n\t\t\tudp_tunnel_nic_entry_unfreeze(&utn->entries[i][j]);\n}\n\nstatic void udp_tunnel_nic_device_sync_work(struct work_struct *work)\n{\n\tstruct udp_tunnel_nic *utn =\n\t\tcontainer_of(work, struct udp_tunnel_nic, work);\n\n\trtnl_lock();\n\tutn->work_pending = 0;\n\t__udp_tunnel_nic_device_sync(utn->dev, utn);\n\n\tif (utn->need_replay)\n\t\tudp_tunnel_nic_replay(utn->dev, utn);\n\trtnl_unlock();\n}\n\nstatic struct udp_tunnel_nic *\nudp_tunnel_nic_alloc(const struct udp_tunnel_nic_info *info,\n\t\t     unsigned int n_tables)\n{\n\tstruct udp_tunnel_nic *utn;\n\tunsigned int i;\n\n\tutn = kzalloc(sizeof(*utn), GFP_KERNEL);\n\tif (!utn)\n\t\treturn NULL;\n\tutn->n_tables = n_tables;\n\tINIT_WORK(&utn->work, udp_tunnel_nic_device_sync_work);\n\n\tutn->entries = kmalloc_array(n_tables, sizeof(void *), GFP_KERNEL);\n\tif (!utn->entries)\n\t\tgoto err_free_utn;\n\n\tfor (i = 0; i < n_tables; i++) {\n\t\tutn->entries[i] = kcalloc(info->tables[i].n_entries,\n\t\t\t\t\t  sizeof(*utn->entries[i]), GFP_KERNEL);\n\t\tif (!utn->entries[i])\n\t\t\tgoto err_free_prev_entries;\n\t}\n\n\treturn utn;\n\nerr_free_prev_entries:\n\twhile (i--)\n\t\tkfree(utn->entries[i]);\n\tkfree(utn->entries);\nerr_free_utn:\n\tkfree(utn);\n\treturn NULL;\n}\n\nstatic void udp_tunnel_nic_free(struct udp_tunnel_nic *utn)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < utn->n_tables; i++)\n\t\tkfree(utn->entries[i]);\n\tkfree(utn->entries);\n\tkfree(utn);\n}\n\nstatic int udp_tunnel_nic_register(struct net_device *dev)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\tstruct udp_tunnel_nic_shared_node *node = NULL;\n\tstruct udp_tunnel_nic *utn;\n\tunsigned int n_tables, i;\n\n\tBUILD_BUG_ON(sizeof(utn->missed) * BITS_PER_BYTE <\n\t\t     UDP_TUNNEL_NIC_MAX_TABLES);\n\t \n\tBUILD_BUG_ON(UDP_TUNNEL_NIC_USE_CNT_MAX <\n\t\t     UDP_TUNNEL_NIC_MAX_SHARING_DEVICES * 2);\n\n\t \n\tif (WARN_ON(!info->set_port != !info->unset_port) ||\n\t    WARN_ON(!info->set_port == !info->sync_table) ||\n\t    WARN_ON(!info->tables[0].n_entries))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(info->shared &&\n\t\t    info->flags & UDP_TUNNEL_NIC_INFO_OPEN_ONLY))\n\t\treturn -EINVAL;\n\n\tn_tables = 1;\n\tfor (i = 1; i < UDP_TUNNEL_NIC_MAX_TABLES; i++) {\n\t\tif (!info->tables[i].n_entries)\n\t\t\tcontinue;\n\n\t\tn_tables++;\n\t\tif (WARN_ON(!info->tables[i - 1].n_entries))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (info->shared) {\n\t\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\t\tif (!node)\n\t\t\treturn -ENOMEM;\n\n\t\tnode->dev = dev;\n\t}\n\n\tif (info->shared && info->shared->udp_tunnel_nic_info) {\n\t\tutn = info->shared->udp_tunnel_nic_info;\n\t} else {\n\t\tutn = udp_tunnel_nic_alloc(info, n_tables);\n\t\tif (!utn) {\n\t\t\tkfree(node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (info->shared) {\n\t\tif (!info->shared->udp_tunnel_nic_info) {\n\t\t\tINIT_LIST_HEAD(&info->shared->devices);\n\t\t\tinfo->shared->udp_tunnel_nic_info = utn;\n\t\t}\n\n\t\tlist_add_tail(&node->list, &info->shared->devices);\n\t}\n\n\tutn->dev = dev;\n\tdev_hold(dev);\n\tdev->udp_tunnel_nic = utn;\n\n\tif (!(info->flags & UDP_TUNNEL_NIC_INFO_OPEN_ONLY))\n\t\tudp_tunnel_get_rx_info(dev);\n\n\treturn 0;\n}\n\nstatic void\nudp_tunnel_nic_unregister(struct net_device *dev, struct udp_tunnel_nic *utn)\n{\n\tconst struct udp_tunnel_nic_info *info = dev->udp_tunnel_nic_info;\n\n\t \n\tif (info->shared) {\n\t\tstruct udp_tunnel_nic_shared_node *node, *first;\n\n\t\tlist_for_each_entry(node, &info->shared->devices, list)\n\t\t\tif (node->dev == dev)\n\t\t\t\tbreak;\n\t\tif (list_entry_is_head(node, &info->shared->devices, list))\n\t\t\treturn;\n\n\t\tlist_del(&node->list);\n\t\tkfree(node);\n\n\t\tfirst = list_first_entry_or_null(&info->shared->devices,\n\t\t\t\t\t\t typeof(*first), list);\n\t\tif (first) {\n\t\t\tudp_tunnel_drop_rx_info(dev);\n\t\t\tutn->dev = first->dev;\n\t\t\tgoto release_dev;\n\t\t}\n\n\t\tinfo->shared->udp_tunnel_nic_info = NULL;\n\t}\n\n\t \n\tudp_tunnel_nic_flush(dev, utn);\n\n\t \n\tif (utn->work_pending)\n\t\treturn;\n\n\tudp_tunnel_nic_free(utn);\nrelease_dev:\n\tdev->udp_tunnel_nic = NULL;\n\tdev_put(dev);\n}\n\nstatic int\nudp_tunnel_nic_netdevice_event(struct notifier_block *unused,\n\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tconst struct udp_tunnel_nic_info *info;\n\tstruct udp_tunnel_nic *utn;\n\n\tinfo = dev->udp_tunnel_nic_info;\n\tif (!info)\n\t\treturn NOTIFY_DONE;\n\n\tif (event == NETDEV_REGISTER) {\n\t\tint err;\n\n\t\terr = udp_tunnel_nic_register(dev);\n\t\tif (err)\n\t\t\tnetdev_WARN(dev, \"failed to register for UDP tunnel offloads: %d\", err);\n\t\treturn notifier_from_errno(err);\n\t}\n\t \n\tutn = dev->udp_tunnel_nic;\n\tif (!utn)\n\t\treturn NOTIFY_DONE;\n\n\tif (event == NETDEV_UNREGISTER) {\n\t\tudp_tunnel_nic_unregister(dev, utn);\n\t\treturn NOTIFY_OK;\n\t}\n\n\t \n\tif (!(info->flags & UDP_TUNNEL_NIC_INFO_OPEN_ONLY))\n\t\treturn NOTIFY_DONE;\n\n\tif (event == NETDEV_UP) {\n\t\tWARN_ON(!udp_tunnel_nic_is_empty(dev, utn));\n\t\tudp_tunnel_get_rx_info(dev);\n\t\treturn NOTIFY_OK;\n\t}\n\tif (event == NETDEV_GOING_DOWN) {\n\t\tudp_tunnel_nic_flush(dev, utn);\n\t\treturn NOTIFY_OK;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block udp_tunnel_nic_notifier_block __read_mostly = {\n\t.notifier_call = udp_tunnel_nic_netdevice_event,\n};\n\nstatic int __init udp_tunnel_nic_init_module(void)\n{\n\tint err;\n\n\tudp_tunnel_nic_workqueue = alloc_ordered_workqueue(\"udp_tunnel_nic\", 0);\n\tif (!udp_tunnel_nic_workqueue)\n\t\treturn -ENOMEM;\n\n\trtnl_lock();\n\tudp_tunnel_nic_ops = &__udp_tunnel_nic_ops;\n\trtnl_unlock();\n\n\terr = register_netdevice_notifier(&udp_tunnel_nic_notifier_block);\n\tif (err)\n\t\tgoto err_unset_ops;\n\n\treturn 0;\n\nerr_unset_ops:\n\trtnl_lock();\n\tudp_tunnel_nic_ops = NULL;\n\trtnl_unlock();\n\tdestroy_workqueue(udp_tunnel_nic_workqueue);\n\treturn err;\n}\nlate_initcall(udp_tunnel_nic_init_module);\n\nstatic void __exit udp_tunnel_nic_cleanup_module(void)\n{\n\tunregister_netdevice_notifier(&udp_tunnel_nic_notifier_block);\n\n\trtnl_lock();\n\tudp_tunnel_nic_ops = NULL;\n\trtnl_unlock();\n\n\tdestroy_workqueue(udp_tunnel_nic_workqueue);\n}\nmodule_exit(udp_tunnel_nic_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}