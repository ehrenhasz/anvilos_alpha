{
  "module_name": "Kconfig",
  "hash_id": "d7e5acc35d719b46f79994be0e90004794e1add31ac6edc4e8b0d747f51d4dd7",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0-only\n#\n# IP configuration\n#\nconfig IP_MULTICAST\n\tbool \"IP: multicasting\"\n\thelp\n\t  This is code for addressing several networked computers at once,\n\t  enlarging your kernel by about 2 KB. You need multicasting if you\n\t  intend to participate in the MBONE, a high bandwidth network on top\n\t  of the Internet which carries audio and video broadcasts. More\n\t  information about the MBONE is on the WWW at\n\t  <https://www.savetz.com/mbone/>. For most people, it's safe to say N.\n\nconfig IP_ADVANCED_ROUTER\n\tbool \"IP: advanced router\"\n\thelp\n\t  If you intend to run your Linux box mostly as a router, i.e. as a\n\t  computer that forwards and redistributes network packets, say Y; you\n\t  will then be presented with several options that allow more precise\n\t  control about the routing process.\n\n\t  The answer to this question won't directly affect the kernel:\n\t  answering N will just cause the configurator to skip all the\n\t  questions about advanced routing.\n\n\t  Note that your box can only act as a router if you enable IP\n\t  forwarding in your kernel; you can do that by saying Y to \"/proc\n\t  file system support\" and \"Sysctl support\" below and executing the\n\t  line\n\n\t  echo \"1\" > /proc/sys/net/ipv4/ip_forward\n\n\t  at boot time after the /proc file system has been mounted.\n\n\t  If you turn on IP forwarding, you should consider the rp_filter, which\n\t  automatically rejects incoming packets if the routing table entry\n\t  for their source address doesn't match the network interface they're\n\t  arriving on. This has security advantages because it prevents the\n\t  so-called IP spoofing, however it can pose problems if you use\n\t  asymmetric routing (packets from you to a host take a different path\n\t  than packets from that host to you) or if you operate a non-routing\n\t  host which has several IP addresses on different interfaces. To turn\n\t  rp_filter on use:\n\n\t  echo 1 > /proc/sys/net/ipv4/conf/<device>/rp_filter\n\t   or\n\t  echo 1 > /proc/sys/net/ipv4/conf/all/rp_filter\n\n\t  Note that some distributions enable it in startup scripts.\n\t  For details about rp_filter strict and loose mode read\n\t  <file:Documentation/networking/ip-sysctl.rst>.\n\n\t  If unsure, say N here.\n\nconfig IP_FIB_TRIE_STATS\n\tbool \"FIB TRIE statistics\"\n\tdepends on IP_ADVANCED_ROUTER\n\thelp\n\t  Keep track of statistics on structure of FIB TRIE table.\n\t  Useful for testing and measuring TRIE performance.\n\nconfig IP_MULTIPLE_TABLES\n\tbool \"IP: policy routing\"\n\tdepends on IP_ADVANCED_ROUTER\n\tselect FIB_RULES\n\thelp\n\t  Normally, a router decides what to do with a received packet based\n\t  solely on the packet's final destination address. If you say Y here,\n\t  the Linux router will also be able to take the packet's source\n\t  address into account. Furthermore, the TOS (Type-Of-Service) field\n\t  of the packet can be used for routing decisions as well.\n\n\t  If you need more information, see the Linux Advanced\n\t  Routing and Traffic Control documentation at\n\t  <https://lartc.org/howto/lartc.rpdb.html>\n\n\t  If unsure, say N.\n\nconfig IP_ROUTE_MULTIPATH\n\tbool \"IP: equal cost multipath\"\n\tdepends on IP_ADVANCED_ROUTER\n\thelp\n\t  Normally, the routing tables specify a single action to be taken in\n\t  a deterministic manner for a given packet. If you say Y here\n\t  however, it becomes possible to attach several actions to a packet\n\t  pattern, in effect specifying several alternative paths to travel\n\t  for those packets. The router considers all these paths to be of\n\t  equal \"cost\" and chooses one of them in a non-deterministic fashion\n\t  if a matching packet arrives.\n\nconfig IP_ROUTE_VERBOSE\n\tbool \"IP: verbose route monitoring\"\n\tdepends on IP_ADVANCED_ROUTER\n\thelp\n\t  If you say Y here, which is recommended, then the kernel will print\n\t  verbose messages regarding the routing, for example warnings about\n\t  received packets which look strange and could be evidence of an\n\t  attack or a misconfigured system somewhere. The information is\n\t  handled by the klogd daemon which is responsible for kernel messages\n\t  (\"man klogd\").\n\nconfig IP_ROUTE_CLASSID\n\tbool\n\nconfig IP_PNP\n\tbool \"IP: kernel level autoconfiguration\"\n\thelp\n\t  This enables automatic configuration of IP addresses of devices and\n\t  of the routing table during kernel boot, based on either information\n\t  supplied on the kernel command line or by BOOTP or RARP protocols.\n\t  You need to say Y only for diskless machines requiring network\n\t  access to boot (in which case you want to say Y to \"Root file system\n\t  on NFS\" as well), because all other machines configure the network\n\t  in their startup scripts.\n\nconfig IP_PNP_DHCP\n\tbool \"IP: DHCP support\"\n\tdepends on IP_PNP\n\thelp\n\t  If you want your Linux box to mount its whole root file system (the\n\t  one containing the directory /) from some other computer over the\n\t  net via NFS and you want the IP address of your computer to be\n\t  discovered automatically at boot time using the DHCP protocol (a\n\t  special protocol designed for doing this job), say Y here. In case\n\t  the boot ROM of your network card was designed for booting Linux and\n\t  does DHCP itself, providing all necessary information on the kernel\n\t  command line, you can say N here.\n\n\t  If unsure, say Y. Note that if you want to use DHCP, a DHCP server\n\t  must be operating on your network.  Read\n\t  <file:Documentation/admin-guide/nfs/nfsroot.rst> for details.\n\nconfig IP_PNP_BOOTP\n\tbool \"IP: BOOTP support\"\n\tdepends on IP_PNP\n\thelp\n\t  If you want your Linux box to mount its whole root file system (the\n\t  one containing the directory /) from some other computer over the\n\t  net via NFS and you want the IP address of your computer to be\n\t  discovered automatically at boot time using the BOOTP protocol (a\n\t  special protocol designed for doing this job), say Y here. In case\n\t  the boot ROM of your network card was designed for booting Linux and\n\t  does BOOTP itself, providing all necessary information on the kernel\n\t  command line, you can say N here. If unsure, say Y. Note that if you\n\t  want to use BOOTP, a BOOTP server must be operating on your network.\n\t  Read <file:Documentation/admin-guide/nfs/nfsroot.rst> for details.\n\nconfig IP_PNP_RARP\n\tbool \"IP: RARP support\"\n\tdepends on IP_PNP\n\thelp\n\t  If you want your Linux box to mount its whole root file system (the\n\t  one containing the directory /) from some other computer over the\n\t  net via NFS and you want the IP address of your computer to be\n\t  discovered automatically at boot time using the RARP protocol (an\n\t  older protocol which is being obsoleted by BOOTP and DHCP), say Y\n\t  here. Note that if you want to use RARP, a RARP server must be\n\t  operating on your network. Read\n\t  <file:Documentation/admin-guide/nfs/nfsroot.rst> for details.\n\nconfig NET_IPIP\n\ttristate \"IP: tunneling\"\n\tselect INET_TUNNEL\n\tselect NET_IP_TUNNEL\n\thelp\n\t  Tunneling means encapsulating data of one protocol type within\n\t  another protocol and sending it over a channel that understands the\n\t  encapsulating protocol. This particular tunneling driver implements\n\t  encapsulation of IP within IP, which sounds kind of pointless, but\n\t  can be useful if you want to make your (or some other) machine\n\t  appear on a different network than it physically is, or to use\n\t  mobile-IP facilities (allowing laptops to seamlessly move between\n\t  networks without changing their IP addresses).\n\n\t  Saying Y to this option will produce two modules ( = code which can\n\t  be inserted in and removed from the running kernel whenever you\n\t  want). Most people won't need this and can say N.\n\nconfig NET_IPGRE_DEMUX\n\ttristate \"IP: GRE demultiplexer\"\n\thelp\n\t  This is helper module to demultiplex GRE packets on GRE version field criteria.\n\t  Required by ip_gre and pptp modules.\n\nconfig NET_IP_TUNNEL\n\ttristate\n\tselect DST_CACHE\n\tselect GRO_CELLS\n\tdefault n\n\nconfig NET_IPGRE\n\ttristate \"IP: GRE tunnels over IP\"\n\tdepends on (IPV6 || IPV6=n) && NET_IPGRE_DEMUX\n\tselect NET_IP_TUNNEL\n\thelp\n\t  Tunneling means encapsulating data of one protocol type within\n\t  another protocol and sending it over a channel that understands the\n\t  encapsulating protocol. This particular tunneling driver implements\n\t  GRE (Generic Routing Encapsulation) and at this time allows\n\t  encapsulating of IPv4 or IPv6 over existing IPv4 infrastructure.\n\t  This driver is useful if the other endpoint is a Cisco router: Cisco\n\t  likes GRE much better than the other Linux tunneling driver (\"IP\n\t  tunneling\" above). In addition, GRE allows multicast redistribution\n\t  through the tunnel.\n\nconfig NET_IPGRE_BROADCAST\n\tbool \"IP: broadcast GRE over IP\"\n\tdepends on IP_MULTICAST && NET_IPGRE\n\thelp\n\t  One application of GRE/IP is to construct a broadcast WAN (Wide Area\n\t  Network), which looks like a normal Ethernet LAN (Local Area\n\t  Network), but can be distributed all over the Internet. If you want\n\t  to do that, say Y here and to \"IP multicast routing\" below.\n\nconfig IP_MROUTE_COMMON\n\tbool\n\tdepends on IP_MROUTE || IPV6_MROUTE\n\nconfig IP_MROUTE\n\tbool \"IP: multicast routing\"\n\tdepends on IP_MULTICAST\n\tselect IP_MROUTE_COMMON\n\thelp\n\t  This is used if you want your machine to act as a router for IP\n\t  packets that have several destination addresses. It is needed on the\n\t  MBONE, a high bandwidth network on top of the Internet which carries\n\t  audio and video broadcasts. In order to do that, you would most\n\t  likely run the program mrouted. If you haven't heard about it, you\n\t  don't need it.\n\nconfig IP_MROUTE_MULTIPLE_TABLES\n\tbool \"IP: multicast policy routing\"\n\tdepends on IP_MROUTE && IP_ADVANCED_ROUTER\n\tselect FIB_RULES\n\thelp\n\t  Normally, a multicast router runs a userspace daemon and decides\n\t  what to do with a multicast packet based on the source and\n\t  destination addresses. If you say Y here, the multicast router\n\t  will also be able to take interfaces and packet marks into\n\t  account and run multiple instances of userspace daemons\n\t  simultaneously, each one handling a single table.\n\n\t  If unsure, say N.\n\nconfig IP_PIMSM_V1\n\tbool \"IP: PIM-SM version 1 support\"\n\tdepends on IP_MROUTE\n\thelp\n\t  Kernel side support for Sparse Mode PIM (Protocol Independent\n\t  Multicast) version 1. This multicast routing protocol is used widely\n\t  because Cisco supports it. You need special software to use it\n\t  (pimd-v1). Please see <http://netweb.usc.edu/pim/> for more\n\t  information about PIM.\n\n\t  Say Y if you want to use PIM-SM v1. Note that you can say N here if\n\t  you just want to use Dense Mode PIM.\n\nconfig IP_PIMSM_V2\n\tbool \"IP: PIM-SM version 2 support\"\n\tdepends on IP_MROUTE\n\thelp\n\t  Kernel side support for Sparse Mode PIM version 2. In order to use\n\t  this, you need an experimental routing daemon supporting it (pimd or\n\t  gated-5). This routing protocol is not used widely, so say N unless\n\t  you want to play with it.\n\nconfig SYN_COOKIES\n\tbool \"IP: TCP syncookie support\"\n\thelp\n\t  Normal TCP/IP networking is open to an attack known as \"SYN\n\t  flooding\". This denial-of-service attack prevents legitimate remote\n\t  users from being able to connect to your computer during an ongoing\n\t  attack and requires very little work from the attacker, who can\n\t  operate from anywhere on the Internet.\n\n\t  SYN cookies provide protection against this type of attack. If you\n\t  say Y here, the TCP/IP stack will use a cryptographic challenge\n\t  protocol known as \"SYN cookies\" to enable legitimate users to\n\t  continue to connect, even when your machine is under attack. There\n\t  is no need for the legitimate users to change their TCP/IP software;\n\t  SYN cookies work transparently to them. For technical information\n\t  about SYN cookies, check out <https://cr.yp.to/syncookies.html>.\n\n\t  If you are SYN flooded, the source address reported by the kernel is\n\t  likely to have been forged by the attacker; it is only reported as\n\t  an aid in tracing the packets to their actual source and should not\n\t  be taken as absolute truth.\n\n\t  SYN cookies may prevent correct error reporting on clients when the\n\t  server is really overloaded. If this happens frequently better turn\n\t  them off.\n\n\t  If you say Y here, you can disable SYN cookies at run time by\n\t  saying Y to \"/proc file system support\" and\n\t  \"Sysctl support\" below and executing the command\n\n\t  echo 0 > /proc/sys/net/ipv4/tcp_syncookies\n\n\t  after the /proc file system has been mounted.\n\n\t  If unsure, say N.\n\nconfig NET_IPVTI\n\ttristate \"Virtual (secure) IP: tunneling\"\n\tdepends on IPV6 || IPV6=n\n\tselect INET_TUNNEL\n\tselect NET_IP_TUNNEL\n\tselect XFRM\n\thelp\n\t  Tunneling means encapsulating data of one protocol type within\n\t  another protocol and sending it over a channel that understands the\n\t  encapsulating protocol. This can be used with xfrm mode tunnel to give\n\t  the notion of a secure tunnel for IPSEC and then use routing protocol\n\t  on top.\n\nconfig NET_UDP_TUNNEL\n\ttristate\n\tselect NET_IP_TUNNEL\n\tdefault n\n\nconfig NET_FOU\n\ttristate \"IP: Foo (IP protocols) over UDP\"\n\tselect NET_UDP_TUNNEL\n\thelp\n\t  Foo over UDP allows any IP protocol to be directly encapsulated\n\t  over UDP include tunnels (IPIP, GRE, SIT). By encapsulating in UDP\n\t  network mechanisms and optimizations for UDP (such as ECMP\n\t  and RSS) can be leveraged to provide better service.\n\nconfig NET_FOU_IP_TUNNELS\n\tbool \"IP: FOU encapsulation of IP tunnels\"\n\tdepends on NET_IPIP || NET_IPGRE || IPV6_SIT\n\tselect NET_FOU\n\thelp\n\t  Allow configuration of FOU or GUE encapsulation for IP tunnels.\n\t  When this option is enabled IP tunnels can be configured to use\n\t  FOU or GUE encapsulation.\n\nconfig INET_AH\n\ttristate \"IP: AH transformation\"\n\tselect XFRM_AH\n\thelp\n\t  Support for IPsec AH (Authentication Header).\n\n\t  AH can be used with various authentication algorithms.  Besides\n\t  enabling AH support itself, this option enables the generic\n\t  implementations of the algorithms that RFC 8221 lists as MUST be\n\t  implemented.  If you need any other algorithms, you'll need to enable\n\t  them in the crypto API.  You should also enable accelerated\n\t  implementations of any needed algorithms when available.\n\n\t  If unsure, say Y.\n\nconfig INET_ESP\n\ttristate \"IP: ESP transformation\"\n\tselect XFRM_ESP\n\thelp\n\t  Support for IPsec ESP (Encapsulating Security Payload).\n\n\t  ESP can be used with various encryption and authentication algorithms.\n\t  Besides enabling ESP support itself, this option enables the generic\n\t  implementations of the algorithms that RFC 8221 lists as MUST be\n\t  implemented.  If you need any other algorithms, you'll need to enable\n\t  them in the crypto API.  You should also enable accelerated\n\t  implementations of any needed algorithms when available.\n\n\t  If unsure, say Y.\n\nconfig INET_ESP_OFFLOAD\n\ttristate \"IP: ESP transformation offload\"\n\tdepends on INET_ESP\n\tselect XFRM_OFFLOAD\n\tdefault n\n\thelp\n\t  Support for ESP transformation offload. This makes sense\n\t  only if this system really does IPsec and want to do it\n\t  with high throughput. A typical desktop system does not\n\t  need it, even if it does IPsec.\n\n\t  If unsure, say N.\n\nconfig INET_ESPINTCP\n\tbool \"IP: ESP in TCP encapsulation (RFC 8229)\"\n\tdepends on XFRM && INET_ESP\n\tselect STREAM_PARSER\n\tselect NET_SOCK_MSG\n\tselect XFRM_ESPINTCP\n\thelp\n\t  Support for RFC 8229 encapsulation of ESP and IKE over\n\t  TCP/IPv4 sockets.\n\n\t  If unsure, say N.\n\nconfig INET_IPCOMP\n\ttristate \"IP: IPComp transformation\"\n\tselect INET_XFRM_TUNNEL\n\tselect XFRM_IPCOMP\n\thelp\n\t  Support for IP Payload Compression Protocol (IPComp) (RFC3173),\n\t  typically needed for IPsec.\n\n\t  If unsure, say Y.\n\nconfig INET_TABLE_PERTURB_ORDER\n\tint \"INET: Source port perturbation table size (as power of 2)\" if EXPERT\n\tdefault 16\n\thelp\n\t  Source port perturbation table size (as power of 2) for\n\t  RFC 6056 3.3.4.  Algorithm 4: Double-Hash Port Selection Algorithm.\n\n\t  The default is almost always what you want.\n\t  Only change this if you know what you are doing.\n\nconfig INET_XFRM_TUNNEL\n\ttristate\n\tselect INET_TUNNEL\n\tdefault n\n\nconfig INET_TUNNEL\n\ttristate\n\tdefault n\n\nconfig INET_DIAG\n\ttristate \"INET: socket monitoring interface\"\n\tdefault y\n\thelp\n\t  Support for INET (TCP, DCCP, etc) socket monitoring interface used by\n\t  native Linux tools such as ss. ss is included in iproute2, currently\n\t  downloadable at:\n\n\t    http://www.linuxfoundation.org/collaborate/workgroups/networking/iproute2\n\n\t  If unsure, say Y.\n\nconfig INET_TCP_DIAG\n\tdepends on INET_DIAG\n\tdef_tristate INET_DIAG\n\nconfig INET_UDP_DIAG\n\ttristate \"UDP: socket monitoring interface\"\n\tdepends on INET_DIAG && (IPV6 || IPV6=n)\n\tdefault n\n\thelp\n\t  Support for UDP socket monitoring interface used by the ss tool.\n\t  If unsure, say Y.\n\nconfig INET_RAW_DIAG\n\ttristate \"RAW: socket monitoring interface\"\n\tdepends on INET_DIAG && (IPV6 || IPV6=n)\n\tdefault n\n\thelp\n\t  Support for RAW socket monitoring interface used by the ss tool.\n\t  If unsure, say Y.\n\nconfig INET_DIAG_DESTROY\n\tbool \"INET: allow privileged process to administratively close sockets\"\n\tdepends on INET_DIAG\n\tdefault n\n\thelp\n\t  Provides a SOCK_DESTROY operation that allows privileged processes\n\t  (e.g., a connection manager or a network administration tool such as\n\t  ss) to close sockets opened by other processes. Closing a socket in\n\t  this way interrupts any blocking read/write/connect operations on\n\t  the socket and causes future socket calls to behave as if the socket\n\t  had been disconnected.\n\t  If unsure, say N.\n\nmenuconfig TCP_CONG_ADVANCED\n\tbool \"TCP: advanced congestion control\"\n\thelp\n\t  Support for selection of various TCP congestion control\n\t  modules.\n\n\t  Nearly all users can safely say no here, and a safe default\n\t  selection will be made (CUBIC with new Reno as a fallback).\n\n\t  If unsure, say N.\n\nif TCP_CONG_ADVANCED\n\nconfig TCP_CONG_BIC\n\ttristate \"Binary Increase Congestion (BIC) control\"\n\tdefault m\n\thelp\n\t  BIC-TCP is a sender-side only change that ensures a linear RTT\n\t  fairness under large windows while offering both scalability and\n\t  bounded TCP-friendliness. The protocol combines two schemes\n\t  called additive increase and binary search increase. When the\n\t  congestion window is large, additive increase with a large\n\t  increment ensures linear RTT fairness as well as good\n\t  scalability. Under small congestion windows, binary search\n\t  increase provides TCP friendliness.\n\t  See http://www.csc.ncsu.edu/faculty/rhee/export/bitcp/\n\nconfig TCP_CONG_CUBIC\n\ttristate \"CUBIC TCP\"\n\tdefault y\n\thelp\n\t  This is version 2.0 of BIC-TCP which uses a cubic growth function\n\t  among other techniques.\n\t  See http://www.csc.ncsu.edu/faculty/rhee/export/bitcp/cubic-paper.pdf\n\nconfig TCP_CONG_WESTWOOD\n\ttristate \"TCP Westwood+\"\n\tdefault m\n\thelp\n\t  TCP Westwood+ is a sender-side only modification of the TCP Reno\n\t  protocol stack that optimizes the performance of TCP congestion\n\t  control. It is based on end-to-end bandwidth estimation to set\n\t  congestion window and slow start threshold after a congestion\n\t  episode. Using this estimation, TCP Westwood+ adaptively sets a\n\t  slow start threshold and a congestion window which takes into\n\t  account the bandwidth used  at the time congestion is experienced.\n\t  TCP Westwood+ significantly increases fairness wrt TCP Reno in\n\t  wired networks and throughput over wireless links.\n\nconfig TCP_CONG_HTCP\n\ttristate \"H-TCP\"\n\tdefault m\n\thelp\n\t  H-TCP is a send-side only modifications of the TCP Reno\n\t  protocol stack that optimizes the performance of TCP\n\t  congestion control for high speed network links. It uses a\n\t  modeswitch to change the alpha and beta parameters of TCP Reno\n\t  based on network conditions and in a way so as to be fair with\n\t  other Reno and H-TCP flows.\n\nconfig TCP_CONG_HSTCP\n\ttristate \"High Speed TCP\"\n\tdefault n\n\thelp\n\t  Sally Floyd's High Speed TCP (RFC 3649) congestion control.\n\t  A modification to TCP's congestion control mechanism for use\n\t  with large congestion windows. A table indicates how much to\n\t  increase the congestion window by when an ACK is received.\n\t  For more detail see https://www.icir.org/floyd/hstcp.html\n\nconfig TCP_CONG_HYBLA\n\ttristate \"TCP-Hybla congestion control algorithm\"\n\tdefault n\n\thelp\n\t  TCP-Hybla is a sender-side only change that eliminates penalization of\n\t  long-RTT, large-bandwidth connections, like when satellite legs are\n\t  involved, especially when sharing a common bottleneck with normal\n\t  terrestrial connections.\n\nconfig TCP_CONG_VEGAS\n\ttristate \"TCP Vegas\"\n\tdefault n\n\thelp\n\t  TCP Vegas is a sender-side only change to TCP that anticipates\n\t  the onset of congestion by estimating the bandwidth. TCP Vegas\n\t  adjusts the sending rate by modifying the congestion\n\t  window. TCP Vegas should provide less packet loss, but it is\n\t  not as aggressive as TCP Reno.\n\nconfig TCP_CONG_NV\n\ttristate \"TCP NV\"\n\tdefault n\n\thelp\n\t  TCP NV is a follow up to TCP Vegas. It has been modified to deal with\n\t  10G networks, measurement noise introduced by LRO, GRO and interrupt\n\t  coalescence. In addition, it will decrease its cwnd multiplicatively\n\t  instead of linearly.\n\n\t  Note that in general congestion avoidance (cwnd decreased when # packets\n\t  queued grows) cannot coexist with congestion control (cwnd decreased only\n\t  when there is packet loss) due to fairness issues. One scenario when they\n\t  can coexist safely is when the CA flows have RTTs << CC flows RTTs.\n\n\t  For further details see http://www.brakmo.org/networking/tcp-nv/\n\nconfig TCP_CONG_SCALABLE\n\ttristate \"Scalable TCP\"\n\tdefault n\n\thelp\n\t  Scalable TCP is a sender-side only change to TCP which uses a\n\t  MIMD congestion control algorithm which has some nice scaling\n\t  properties, though is known to have fairness issues.\n\t  See http://www.deneholme.net/tom/scalable/\n\nconfig TCP_CONG_LP\n\ttristate \"TCP Low Priority\"\n\tdefault n\n\thelp\n\t  TCP Low Priority (TCP-LP), a distributed algorithm whose goal is\n\t  to utilize only the excess network bandwidth as compared to the\n\t  ``fair share`` of bandwidth as targeted by TCP.\n\t  See http://www-ece.rice.edu/networks/TCP-LP/\n\nconfig TCP_CONG_VENO\n\ttristate \"TCP Veno\"\n\tdefault n\n\thelp\n\t  TCP Veno is a sender-side only enhancement of TCP to obtain better\n\t  throughput over wireless networks. TCP Veno makes use of state\n\t  distinguishing to circumvent the difficult judgment of the packet loss\n\t  type. TCP Veno cuts down less congestion window in response to random\n\t  loss packets.\n\t  See <http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1177186>\n\nconfig TCP_CONG_YEAH\n\ttristate \"YeAH TCP\"\n\tselect TCP_CONG_VEGAS\n\tdefault n\n\thelp\n\t  YeAH-TCP is a sender-side high-speed enabled TCP congestion control\n\t  algorithm, which uses a mixed loss/delay approach to compute the\n\t  congestion window. It's design goals target high efficiency,\n\t  internal, RTT and Reno fairness, resilience to link loss while\n\t  keeping network elements load as low as possible.\n\n\t  For further details look here:\n\t    http://wil.cs.caltech.edu/pfldnet2007/paper/YeAH_TCP.pdf\n\nconfig TCP_CONG_ILLINOIS\n\ttristate \"TCP Illinois\"\n\tdefault n\n\thelp\n\t  TCP-Illinois is a sender-side modification of TCP Reno for\n\t  high speed long delay links. It uses round-trip-time to\n\t  adjust the alpha and beta parameters to achieve a higher average\n\t  throughput and maintain fairness.\n\n\t  For further details see:\n\t    http://www.ews.uiuc.edu/~shaoliu/tcpillinois/index.html\n\nconfig TCP_CONG_DCTCP\n\ttristate \"DataCenter TCP (DCTCP)\"\n\tdefault n\n\thelp\n\t  DCTCP leverages Explicit Congestion Notification (ECN) in the network to\n\t  provide multi-bit feedback to the end hosts. It is designed to provide:\n\n\t  - High burst tolerance (incast due to partition/aggregate),\n\t  - Low latency (short flows, queries),\n\t  - High throughput (continuous data updates, large file transfers) with\n\t    commodity, shallow-buffered switches.\n\n\t  All switches in the data center network running DCTCP must support\n\t  ECN marking and be configured for marking when reaching defined switch\n\t  buffer thresholds. The default ECN marking threshold heuristic for\n\t  DCTCP on switches is 20 packets (30KB) at 1Gbps, and 65 packets\n\t  (~100KB) at 10Gbps, but might need further careful tweaking.\n\n\t  For further details see:\n\t    http://simula.stanford.edu/~alizade/Site/DCTCP_files/dctcp-final.pdf\n\nconfig TCP_CONG_CDG\n\ttristate \"CAIA Delay-Gradient (CDG)\"\n\tdefault n\n\thelp\n\t  CAIA Delay-Gradient (CDG) is a TCP congestion control that modifies\n\t  the TCP sender in order to:\n\n\t  o Use the delay gradient as a congestion signal.\n\t  o Back off with an average probability that is independent of the RTT.\n\t  o Coexist with flows that use loss-based congestion control.\n\t  o Tolerate packet loss unrelated to congestion.\n\n\t  For further details see:\n\t    D.A. Hayes and G. Armitage. \"Revisiting TCP congestion control using\n\t    delay gradients.\" In Networking 2011. Preprint: http://goo.gl/No3vdg\n\nconfig TCP_CONG_BBR\n\ttristate \"BBR TCP\"\n\tdefault n\n\thelp\n\n\t  BBR (Bottleneck Bandwidth and RTT) TCP congestion control aims to\n\t  maximize network utilization and minimize queues. It builds an explicit\n\t  model of the bottleneck delivery rate and path round-trip propagation\n\t  delay. It tolerates packet loss and delay unrelated to congestion. It\n\t  can operate over LAN, WAN, cellular, wifi, or cable modem links. It can\n\t  coexist with flows that use loss-based congestion control, and can\n\t  operate with shallow buffers, deep buffers, bufferbloat, policers, or\n\t  AQM schemes that do not provide a delay signal. It requires the fq\n\t  (\"Fair Queue\") pacing packet scheduler.\n\nchoice\n\tprompt \"Default TCP congestion control\"\n\tdefault DEFAULT_CUBIC\n\thelp\n\t  Select the TCP congestion control that will be used by default\n\t  for all connections.\n\n\tconfig DEFAULT_BIC\n\t\tbool \"Bic\" if TCP_CONG_BIC=y\n\n\tconfig DEFAULT_CUBIC\n\t\tbool \"Cubic\" if TCP_CONG_CUBIC=y\n\n\tconfig DEFAULT_HTCP\n\t\tbool \"Htcp\" if TCP_CONG_HTCP=y\n\n\tconfig DEFAULT_HYBLA\n\t\tbool \"Hybla\" if TCP_CONG_HYBLA=y\n\n\tconfig DEFAULT_VEGAS\n\t\tbool \"Vegas\" if TCP_CONG_VEGAS=y\n\n\tconfig DEFAULT_VENO\n\t\tbool \"Veno\" if TCP_CONG_VENO=y\n\n\tconfig DEFAULT_WESTWOOD\n\t\tbool \"Westwood\" if TCP_CONG_WESTWOOD=y\n\n\tconfig DEFAULT_DCTCP\n\t\tbool \"DCTCP\" if TCP_CONG_DCTCP=y\n\n\tconfig DEFAULT_CDG\n\t\tbool \"CDG\" if TCP_CONG_CDG=y\n\n\tconfig DEFAULT_BBR\n\t\tbool \"BBR\" if TCP_CONG_BBR=y\n\n\tconfig DEFAULT_RENO\n\t\tbool \"Reno\"\nendchoice\n\nendif\n\nconfig TCP_CONG_CUBIC\n\ttristate\n\tdepends on !TCP_CONG_ADVANCED\n\tdefault y\n\nconfig DEFAULT_TCP_CONG\n\tstring\n\tdefault \"bic\" if DEFAULT_BIC\n\tdefault \"cubic\" if DEFAULT_CUBIC\n\tdefault \"htcp\" if DEFAULT_HTCP\n\tdefault \"hybla\" if DEFAULT_HYBLA\n\tdefault \"vegas\" if DEFAULT_VEGAS\n\tdefault \"westwood\" if DEFAULT_WESTWOOD\n\tdefault \"veno\" if DEFAULT_VENO\n\tdefault \"reno\" if DEFAULT_RENO\n\tdefault \"dctcp\" if DEFAULT_DCTCP\n\tdefault \"cdg\" if DEFAULT_CDG\n\tdefault \"bbr\" if DEFAULT_BBR\n\tdefault \"cubic\"\n\nconfig TCP_MD5SIG\n\tbool \"TCP: MD5 Signature Option support (RFC2385)\"\n\tselect CRYPTO\n\tselect CRYPTO_MD5\n\thelp\n\t  RFC2385 specifies a method of giving MD5 protection to TCP sessions.\n\t  Its main (only?) use is to protect BGP sessions between core routers\n\t  on the Internet.\n\n\t  If unsure, say N.\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}