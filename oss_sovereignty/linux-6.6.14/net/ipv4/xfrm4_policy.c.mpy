{
  "module_name": "xfrm4_policy.c",
  "hash_id": "3703ff0b261ac6e99ce322c822548b80f7768460dfdd905ba5aae8559a75bf7d",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/xfrm4_policy.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/inetdevice.h>\n#include <net/dst.h>\n#include <net/xfrm.h>\n#include <net/ip.h>\n#include <net/l3mdev.h>\n\nstatic struct dst_entry *__xfrm4_dst_lookup(struct net *net, struct flowi4 *fl4,\n\t\t\t\t\t    int tos, int oif,\n\t\t\t\t\t    const xfrm_address_t *saddr,\n\t\t\t\t\t    const xfrm_address_t *daddr,\n\t\t\t\t\t    u32 mark)\n{\n\tstruct rtable *rt;\n\n\tmemset(fl4, 0, sizeof(*fl4));\n\tfl4->daddr = daddr->a4;\n\tfl4->flowi4_tos = tos;\n\tfl4->flowi4_l3mdev = l3mdev_master_ifindex_by_index(net, oif);\n\tfl4->flowi4_mark = mark;\n\tif (saddr)\n\t\tfl4->saddr = saddr->a4;\n\n\trt = __ip_route_output_key(net, fl4);\n\tif (!IS_ERR(rt))\n\t\treturn &rt->dst;\n\n\treturn ERR_CAST(rt);\n}\n\nstatic struct dst_entry *xfrm4_dst_lookup(struct net *net, int tos, int oif,\n\t\t\t\t\t  const xfrm_address_t *saddr,\n\t\t\t\t\t  const xfrm_address_t *daddr,\n\t\t\t\t\t  u32 mark)\n{\n\tstruct flowi4 fl4;\n\n\treturn __xfrm4_dst_lookup(net, &fl4, tos, oif, saddr, daddr, mark);\n}\n\nstatic int xfrm4_get_saddr(struct net *net, int oif,\n\t\t\t   xfrm_address_t *saddr, xfrm_address_t *daddr,\n\t\t\t   u32 mark)\n{\n\tstruct dst_entry *dst;\n\tstruct flowi4 fl4;\n\n\tdst = __xfrm4_dst_lookup(net, &fl4, 0, oif, NULL, daddr, mark);\n\tif (IS_ERR(dst))\n\t\treturn -EHOSTUNREACH;\n\n\tsaddr->a4 = fl4.saddr;\n\tdst_release(dst);\n\treturn 0;\n}\n\nstatic int xfrm4_fill_dst(struct xfrm_dst *xdst, struct net_device *dev,\n\t\t\t  const struct flowi *fl)\n{\n\tstruct rtable *rt = (struct rtable *)xdst->route;\n\tconst struct flowi4 *fl4 = &fl->u.ip4;\n\n\txdst->u.rt.rt_iif = fl4->flowi4_iif;\n\n\txdst->u.dst.dev = dev;\n\tnetdev_hold(dev, &xdst->u.dst.dev_tracker, GFP_ATOMIC);\n\n\t \n\txdst->u.rt.rt_is_input = rt->rt_is_input;\n\txdst->u.rt.rt_flags = rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST |\n\t\t\t\t\t      RTCF_LOCAL);\n\txdst->u.rt.rt_type = rt->rt_type;\n\txdst->u.rt.rt_uses_gateway = rt->rt_uses_gateway;\n\txdst->u.rt.rt_gw_family = rt->rt_gw_family;\n\tif (rt->rt_gw_family == AF_INET)\n\t\txdst->u.rt.rt_gw4 = rt->rt_gw4;\n\telse if (rt->rt_gw_family == AF_INET6)\n\t\txdst->u.rt.rt_gw6 = rt->rt_gw6;\n\txdst->u.rt.rt_pmtu = rt->rt_pmtu;\n\txdst->u.rt.rt_mtu_locked = rt->rt_mtu_locked;\n\trt_add_uncached_list(&xdst->u.rt);\n\n\treturn 0;\n}\n\nstatic void xfrm4_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t      struct sk_buff *skb, u32 mtu,\n\t\t\t      bool confirm_neigh)\n{\n\tstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\n\tstruct dst_entry *path = xdst->route;\n\n\tpath->ops->update_pmtu(path, sk, skb, mtu, confirm_neigh);\n}\n\nstatic void xfrm4_redirect(struct dst_entry *dst, struct sock *sk,\n\t\t\t   struct sk_buff *skb)\n{\n\tstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\n\tstruct dst_entry *path = xdst->route;\n\n\tpath->ops->redirect(path, sk, skb);\n}\n\nstatic void xfrm4_dst_destroy(struct dst_entry *dst)\n{\n\tstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\n\n\tdst_destroy_metrics_generic(dst);\n\trt_del_uncached_list(&xdst->u.rt);\n\txfrm_dst_destroy(xdst);\n}\n\nstatic struct dst_ops xfrm4_dst_ops_template = {\n\t.family =\t\tAF_INET,\n\t.update_pmtu =\t\txfrm4_update_pmtu,\n\t.redirect =\t\txfrm4_redirect,\n\t.cow_metrics =\t\tdst_cow_metrics_generic,\n\t.destroy =\t\txfrm4_dst_destroy,\n\t.ifdown =\t\txfrm_dst_ifdown,\n\t.local_out =\t\t__ip_local_out,\n\t.gc_thresh =\t\t32768,\n};\n\nstatic const struct xfrm_policy_afinfo xfrm4_policy_afinfo = {\n\t.dst_ops =\t\t&xfrm4_dst_ops_template,\n\t.dst_lookup =\t\txfrm4_dst_lookup,\n\t.get_saddr =\t\txfrm4_get_saddr,\n\t.fill_dst =\t\txfrm4_fill_dst,\n\t.blackhole_route =\tipv4_blackhole_route,\n};\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table xfrm4_policy_table[] = {\n\t{\n\t\t.procname       = \"xfrm4_gc_thresh\",\n\t\t.data           = &init_net.xfrm.xfrm4_dst_ops.gc_thresh,\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec,\n\t},\n\t{ }\n};\n\nstatic __net_init int xfrm4_net_sysctl_init(struct net *net)\n{\n\tstruct ctl_table *table;\n\tstruct ctl_table_header *hdr;\n\n\ttable = xfrm4_policy_table;\n\tif (!net_eq(net, &init_net)) {\n\t\ttable = kmemdup(table, sizeof(xfrm4_policy_table), GFP_KERNEL);\n\t\tif (!table)\n\t\t\tgoto err_alloc;\n\n\t\ttable[0].data = &net->xfrm.xfrm4_dst_ops.gc_thresh;\n\t}\n\n\thdr = register_net_sysctl_sz(net, \"net/ipv4\", table,\n\t\t\t\t     ARRAY_SIZE(xfrm4_policy_table));\n\tif (!hdr)\n\t\tgoto err_reg;\n\n\tnet->ipv4.xfrm4_hdr = hdr;\n\treturn 0;\n\nerr_reg:\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\nerr_alloc:\n\treturn -ENOMEM;\n}\n\nstatic __net_exit void xfrm4_net_sysctl_exit(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\tif (!net->ipv4.xfrm4_hdr)\n\t\treturn;\n\n\ttable = net->ipv4.xfrm4_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(net->ipv4.xfrm4_hdr);\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\n}\n#else  \nstatic inline int xfrm4_net_sysctl_init(struct net *net)\n{\n\treturn 0;\n}\n\nstatic inline void xfrm4_net_sysctl_exit(struct net *net)\n{\n}\n#endif\n\nstatic int __net_init xfrm4_net_init(struct net *net)\n{\n\tint ret;\n\n\tmemcpy(&net->xfrm.xfrm4_dst_ops, &xfrm4_dst_ops_template,\n\t       sizeof(xfrm4_dst_ops_template));\n\tret = dst_entries_init(&net->xfrm.xfrm4_dst_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xfrm4_net_sysctl_init(net);\n\tif (ret)\n\t\tdst_entries_destroy(&net->xfrm.xfrm4_dst_ops);\n\n\treturn ret;\n}\n\nstatic void __net_exit xfrm4_net_exit(struct net *net)\n{\n\txfrm4_net_sysctl_exit(net);\n\tdst_entries_destroy(&net->xfrm.xfrm4_dst_ops);\n}\n\nstatic struct pernet_operations __net_initdata xfrm4_net_ops = {\n\t.init\t= xfrm4_net_init,\n\t.exit\t= xfrm4_net_exit,\n};\n\nstatic void __init xfrm4_policy_init(void)\n{\n\txfrm_policy_register_afinfo(&xfrm4_policy_afinfo, AF_INET);\n}\n\nvoid __init xfrm4_init(void)\n{\n\txfrm4_state_init();\n\txfrm4_policy_init();\n\txfrm4_protocol_init();\n\tregister_pernet_subsys(&xfrm4_net_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}