{
  "module_name": "datagram.c",
  "hash_id": "00623b687a32cf69b4a2202195cacda4f53a293287173c9b1e2128b774854932",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/datagram.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/in.h>\n#include <net/ip.h>\n#include <net/sock.h>\n#include <net/route.h>\n#include <net/tcp_states.h>\n#include <net/sock_reuseport.h>\n\nint __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_in *usin = (struct sockaddr_in *) uaddr;\n\tstruct flowi4 *fl4;\n\tstruct rtable *rt;\n\t__be32 saddr;\n\tint oif;\n\tint err;\n\n\n\tif (addr_len < sizeof(*usin))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tsk_dst_reset(sk);\n\n\toif = sk->sk_bound_dev_if;\n\tsaddr = inet->inet_saddr;\n\tif (ipv4_is_multicast(usin->sin_addr.s_addr)) {\n\t\tif (!oif || netif_index_is_l3_master(sock_net(sk), oif))\n\t\t\toif = inet->mc_index;\n\t\tif (!saddr)\n\t\t\tsaddr = inet->mc_addr;\n\t} else if (!oif) {\n\t\toif = inet->uc_index;\n\t}\n\tfl4 = &inet->cork.fl.u.ip4;\n\trt = ip_route_connect(fl4, usin->sin_addr.s_addr, saddr, oif,\n\t\t\t      sk->sk_protocol, inet->inet_sport,\n\t\t\t      usin->sin_port, sk);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\tif (err == -ENETUNREACH)\n\t\t\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\t\tgoto out;\n\t}\n\n\tif ((rt->rt_flags & RTCF_BROADCAST) && !sock_flag(sk, SOCK_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!inet->inet_saddr)\n\t\tinet->inet_saddr = fl4->saddr;\t \n\tif (!inet->inet_rcv_saddr) {\n\t\tinet->inet_rcv_saddr = fl4->saddr;\n\t\tif (sk->sk_prot->rehash)\n\t\t\tsk->sk_prot->rehash(sk);\n\t}\n\tinet->inet_daddr = fl4->daddr;\n\tinet->inet_dport = usin->sin_port;\n\treuseport_has_conns_set(sk);\n\tsk->sk_state = TCP_ESTABLISHED;\n\tsk_set_txhash(sk);\n\tatomic_set(&inet->inet_id, get_random_u16());\n\n\tsk_dst_set(sk, &rt->dst);\n\terr = 0;\nout:\n\treturn err;\n}\nEXPORT_SYMBOL(__ip4_datagram_connect);\n\nint ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tint res;\n\n\tlock_sock(sk);\n\tres = __ip4_datagram_connect(sk, uaddr, addr_len);\n\trelease_sock(sk);\n\treturn res;\n}\nEXPORT_SYMBOL(ip4_datagram_connect);\n\n \nvoid ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct dst_entry *dst;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\n\trcu_read_lock();\n\n\tdst = __sk_dst_get(sk);\n\tif (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\n\tdst = !IS_ERR(rt) ? &rt->dst : NULL;\n\tsk_dst_set(sk, dst);\n\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(ip4_datagram_release_cb);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}