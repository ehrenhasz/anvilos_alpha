{
  "module_name": "tcp_plb.c",
  "hash_id": "0650752f464088c773ba29ad4f0262c28cb81f0d87e7f43e480d674d3ce6aeef",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_plb.c",
  "human_readable_source": " \n\n#include <net/tcp.h>\n\n \nvoid tcp_plb_update_state(const struct sock *sk, struct tcp_plb_state *plb,\n\t\t\t  const int cong_ratio)\n{\n\tstruct net *net = sock_net(sk);\n\n\tif (!READ_ONCE(net->ipv4.sysctl_tcp_plb_enabled))\n\t\treturn;\n\n\tif (cong_ratio >= 0) {\n\t\tif (cong_ratio < READ_ONCE(net->ipv4.sysctl_tcp_plb_cong_thresh))\n\t\t\tplb->consec_cong_rounds = 0;\n\t\telse if (plb->consec_cong_rounds <\n\t\t\t READ_ONCE(net->ipv4.sysctl_tcp_plb_rehash_rounds))\n\t\t\tplb->consec_cong_rounds++;\n\t}\n}\nEXPORT_SYMBOL_GPL(tcp_plb_update_state);\n\n \nvoid tcp_plb_check_rehash(struct sock *sk, struct tcp_plb_state *plb)\n{\n\tstruct net *net = sock_net(sk);\n\tu32 max_suspend;\n\tbool forced_rehash = false, idle_rehash = false;\n\n\tif (!READ_ONCE(net->ipv4.sysctl_tcp_plb_enabled))\n\t\treturn;\n\n\tforced_rehash = plb->consec_cong_rounds >=\n\t\t\tREAD_ONCE(net->ipv4.sysctl_tcp_plb_rehash_rounds);\n\t \n\tidle_rehash = READ_ONCE(net->ipv4.sysctl_tcp_plb_idle_rehash_rounds) &&\n\t\t      !tcp_sk(sk)->packets_out &&\n\t\t      plb->consec_cong_rounds >=\n\t\t      READ_ONCE(net->ipv4.sysctl_tcp_plb_idle_rehash_rounds);\n\n\tif (!forced_rehash && !idle_rehash)\n\t\treturn;\n\n\t \n\tmax_suspend = 2 * READ_ONCE(net->ipv4.sysctl_tcp_plb_suspend_rto_sec) * HZ;\n\tif (plb->pause_until &&\n\t    (!before(tcp_jiffies32, plb->pause_until) ||\n\t     before(tcp_jiffies32 + max_suspend, plb->pause_until)))\n\t\tplb->pause_until = 0;\n\n\tif (plb->pause_until)\n\t\treturn;\n\n\tsk_rethink_txhash(sk);\n\tplb->consec_cong_rounds = 0;\n\ttcp_sk(sk)->plb_rehash++;\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPPLBREHASH);\n}\nEXPORT_SYMBOL_GPL(tcp_plb_check_rehash);\n\n \nvoid tcp_plb_update_state_upon_rto(struct sock *sk, struct tcp_plb_state *plb)\n{\n\tstruct net *net = sock_net(sk);\n\tu32 pause;\n\n\tif (!READ_ONCE(net->ipv4.sysctl_tcp_plb_enabled))\n\t\treturn;\n\n\tpause = READ_ONCE(net->ipv4.sysctl_tcp_plb_suspend_rto_sec) * HZ;\n\tpause += get_random_u32_below(pause);\n\tplb->pause_until = tcp_jiffies32 + pause;\n\n\t \n\tplb->consec_cong_rounds = 0;\n}\nEXPORT_SYMBOL_GPL(tcp_plb_update_state_upon_rto);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}