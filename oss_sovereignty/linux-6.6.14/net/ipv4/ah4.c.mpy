{
  "module_name": "ah4.c",
  "hash_id": "8c41871f1fb3c7987ebb0f4eb48ab6a597731096ca4713ae154e2aed78dd55c0",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ah4.c",
  "human_readable_source": "\n#define pr_fmt(fmt) \"IPsec: \" fmt\n\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <net/ip.h>\n#include <net/xfrm.h>\n#include <net/ah.h>\n#include <linux/crypto.h>\n#include <linux/pfkeyv2.h>\n#include <linux/scatterlist.h>\n#include <net/icmp.h>\n#include <net/protocol.h>\n\nstruct ah_skb_cb {\n\tstruct xfrm_skb_cb xfrm;\n\tvoid *tmp;\n};\n\n#define AH_SKB_CB(__skb) ((struct ah_skb_cb *)&((__skb)->cb[0]))\n\nstatic void *ah_alloc_tmp(struct crypto_ahash *ahash, int nfrags,\n\t\t\t  unsigned int size)\n{\n\tunsigned int len;\n\n\tlen = size + crypto_ahash_digestsize(ahash) +\n\t      (crypto_ahash_alignmask(ahash) &\n\t       ~(crypto_tfm_ctx_alignment() - 1));\n\n\tlen = ALIGN(len, crypto_tfm_ctx_alignment());\n\n\tlen += sizeof(struct ahash_request) + crypto_ahash_reqsize(ahash);\n\tlen = ALIGN(len, __alignof__(struct scatterlist));\n\n\tlen += sizeof(struct scatterlist) * nfrags;\n\n\treturn kmalloc(len, GFP_ATOMIC);\n}\n\nstatic inline u8 *ah_tmp_auth(void *tmp, unsigned int offset)\n{\n\treturn tmp + offset;\n}\n\nstatic inline u8 *ah_tmp_icv(struct crypto_ahash *ahash, void *tmp,\n\t\t\t     unsigned int offset)\n{\n\treturn PTR_ALIGN((u8 *)tmp + offset, crypto_ahash_alignmask(ahash) + 1);\n}\n\nstatic inline struct ahash_request *ah_tmp_req(struct crypto_ahash *ahash,\n\t\t\t\t\t       u8 *icv)\n{\n\tstruct ahash_request *req;\n\n\treq = (void *)PTR_ALIGN(icv + crypto_ahash_digestsize(ahash),\n\t\t\t\tcrypto_tfm_ctx_alignment());\n\n\tahash_request_set_tfm(req, ahash);\n\n\treturn req;\n}\n\nstatic inline struct scatterlist *ah_req_sg(struct crypto_ahash *ahash,\n\t\t\t\t\t     struct ahash_request *req)\n{\n\treturn (void *)ALIGN((unsigned long)(req + 1) +\n\t\t\t     crypto_ahash_reqsize(ahash),\n\t\t\t     __alignof__(struct scatterlist));\n}\n\n \n\nstatic int ip_clear_mutable_options(const struct iphdr *iph, __be32 *daddr)\n{\n\tunsigned char *optptr = (unsigned char *)(iph+1);\n\tint  l = iph->ihl*4 - sizeof(struct iphdr);\n\tint  optlen;\n\n\twhile (l > 0) {\n\t\tswitch (*optptr) {\n\t\tcase IPOPT_END:\n\t\t\treturn 0;\n\t\tcase IPOPT_NOOP:\n\t\t\tl--;\n\t\t\toptptr++;\n\t\t\tcontinue;\n\t\t}\n\t\toptlen = optptr[1];\n\t\tif (optlen<2 || optlen>l)\n\t\t\treturn -EINVAL;\n\t\tswitch (*optptr) {\n\t\tcase IPOPT_SEC:\n\t\tcase 0x85:\t \n\t\tcase IPOPT_CIPSO:\n\t\tcase IPOPT_RA:\n\t\tcase 0x80|21:\t \n\t\t\tbreak;\n\t\tcase IPOPT_LSRR:\n\t\tcase IPOPT_SSRR:\n\t\t\tif (optlen < 6)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemcpy(daddr, optptr+optlen-4, 4);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tmemset(optptr, 0, optlen);\n\t\t}\n\t\tl -= optlen;\n\t\toptptr += optlen;\n\t}\n\treturn 0;\n}\n\nstatic void ah_output_done(void *data, int err)\n{\n\tu8 *icv;\n\tstruct iphdr *iph;\n\tstruct sk_buff *skb = data;\n\tstruct xfrm_state *x = skb_dst(skb)->xfrm;\n\tstruct ah_data *ahp = x->data;\n\tstruct iphdr *top_iph = ip_hdr(skb);\n\tstruct ip_auth_hdr *ah = ip_auth_hdr(skb);\n\tint ihl = ip_hdrlen(skb);\n\n\tiph = AH_SKB_CB(skb)->tmp;\n\ticv = ah_tmp_icv(ahp->ahash, iph, ihl);\n\tmemcpy(ah->auth_data, icv, ahp->icv_trunc_len);\n\n\ttop_iph->tos = iph->tos;\n\ttop_iph->ttl = iph->ttl;\n\ttop_iph->frag_off = iph->frag_off;\n\tif (top_iph->ihl != 5) {\n\t\ttop_iph->daddr = iph->daddr;\n\t\tmemcpy(top_iph+1, iph+1, top_iph->ihl*4 - sizeof(struct iphdr));\n\t}\n\n\tkfree(AH_SKB_CB(skb)->tmp);\n\txfrm_output_resume(skb->sk, skb, err);\n}\n\nstatic int ah_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err;\n\tint nfrags;\n\tint ihl;\n\tu8 *icv;\n\tstruct sk_buff *trailer;\n\tstruct crypto_ahash *ahash;\n\tstruct ahash_request *req;\n\tstruct scatterlist *sg;\n\tstruct iphdr *iph, *top_iph;\n\tstruct ip_auth_hdr *ah;\n\tstruct ah_data *ahp;\n\tint seqhi_len = 0;\n\t__be32 *seqhi;\n\tint sglists = 0;\n\tstruct scatterlist *seqhisg;\n\n\tahp = x->data;\n\tahash = ahp->ahash;\n\n\tif ((err = skb_cow_data(skb, 0, &trailer)) < 0)\n\t\tgoto out;\n\tnfrags = err;\n\n\tskb_push(skb, -skb_network_offset(skb));\n\tah = ip_auth_hdr(skb);\n\tihl = ip_hdrlen(skb);\n\n\tif (x->props.flags & XFRM_STATE_ESN) {\n\t\tsglists = 1;\n\t\tseqhi_len = sizeof(*seqhi);\n\t}\n\terr = -ENOMEM;\n\tiph = ah_alloc_tmp(ahash, nfrags + sglists, ihl + seqhi_len);\n\tif (!iph)\n\t\tgoto out;\n\tseqhi = (__be32 *)((char *)iph + ihl);\n\ticv = ah_tmp_icv(ahash, seqhi, seqhi_len);\n\treq = ah_tmp_req(ahash, icv);\n\tsg = ah_req_sg(ahash, req);\n\tseqhisg = sg + nfrags;\n\n\tmemset(ah->auth_data, 0, ahp->icv_trunc_len);\n\n\ttop_iph = ip_hdr(skb);\n\n\tiph->tos = top_iph->tos;\n\tiph->ttl = top_iph->ttl;\n\tiph->frag_off = top_iph->frag_off;\n\n\tif (top_iph->ihl != 5) {\n\t\tiph->daddr = top_iph->daddr;\n\t\tmemcpy(iph+1, top_iph+1, top_iph->ihl*4 - sizeof(struct iphdr));\n\t\terr = ip_clear_mutable_options(top_iph, &top_iph->daddr);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tah->nexthdr = *skb_mac_header(skb);\n\t*skb_mac_header(skb) = IPPROTO_AH;\n\n\ttop_iph->tos = 0;\n\ttop_iph->tot_len = htons(skb->len);\n\ttop_iph->frag_off = 0;\n\ttop_iph->ttl = 0;\n\ttop_iph->check = 0;\n\n\tif (x->props.flags & XFRM_STATE_ALIGN4)\n\t\tah->hdrlen  = (XFRM_ALIGN4(sizeof(*ah) + ahp->icv_trunc_len) >> 2) - 2;\n\telse\n\t\tah->hdrlen  = (XFRM_ALIGN8(sizeof(*ah) + ahp->icv_trunc_len) >> 2) - 2;\n\n\tah->reserved = 0;\n\tah->spi = x->id.spi;\n\tah->seq_no = htonl(XFRM_SKB_CB(skb)->seq.output.low);\n\n\tsg_init_table(sg, nfrags + sglists);\n\terr = skb_to_sgvec_nomark(skb, sg, 0, skb->len);\n\tif (unlikely(err < 0))\n\t\tgoto out_free;\n\n\tif (x->props.flags & XFRM_STATE_ESN) {\n\t\t \n\t\t*seqhi = htonl(XFRM_SKB_CB(skb)->seq.output.hi);\n\t\tsg_set_buf(seqhisg, seqhi, seqhi_len);\n\t}\n\tahash_request_set_crypt(req, sg, icv, skb->len + seqhi_len);\n\tahash_request_set_callback(req, 0, ah_output_done, skb);\n\n\tAH_SKB_CB(skb)->tmp = iph;\n\n\terr = crypto_ahash_digest(req);\n\tif (err) {\n\t\tif (err == -EINPROGRESS)\n\t\t\tgoto out;\n\n\t\tif (err == -ENOSPC)\n\t\t\terr = NET_XMIT_DROP;\n\t\tgoto out_free;\n\t}\n\n\tmemcpy(ah->auth_data, icv, ahp->icv_trunc_len);\n\n\ttop_iph->tos = iph->tos;\n\ttop_iph->ttl = iph->ttl;\n\ttop_iph->frag_off = iph->frag_off;\n\tif (top_iph->ihl != 5) {\n\t\ttop_iph->daddr = iph->daddr;\n\t\tmemcpy(top_iph+1, iph+1, top_iph->ihl*4 - sizeof(struct iphdr));\n\t}\n\nout_free:\n\tkfree(iph);\nout:\n\treturn err;\n}\n\nstatic void ah_input_done(void *data, int err)\n{\n\tu8 *auth_data;\n\tu8 *icv;\n\tstruct iphdr *work_iph;\n\tstruct sk_buff *skb = data;\n\tstruct xfrm_state *x = xfrm_input_state(skb);\n\tstruct ah_data *ahp = x->data;\n\tstruct ip_auth_hdr *ah = ip_auth_hdr(skb);\n\tint ihl = ip_hdrlen(skb);\n\tint ah_hlen = (ah->hdrlen + 2) << 2;\n\n\tif (err)\n\t\tgoto out;\n\n\twork_iph = AH_SKB_CB(skb)->tmp;\n\tauth_data = ah_tmp_auth(work_iph, ihl);\n\ticv = ah_tmp_icv(ahp->ahash, auth_data, ahp->icv_trunc_len);\n\n\terr = crypto_memneq(icv, auth_data, ahp->icv_trunc_len) ? -EBADMSG : 0;\n\tif (err)\n\t\tgoto out;\n\n\terr = ah->nexthdr;\n\n\tskb->network_header += ah_hlen;\n\tmemcpy(skb_network_header(skb), work_iph, ihl);\n\t__skb_pull(skb, ah_hlen + ihl);\n\n\tif (x->props.mode == XFRM_MODE_TUNNEL)\n\t\tskb_reset_transport_header(skb);\n\telse\n\t\tskb_set_transport_header(skb, -ihl);\nout:\n\tkfree(AH_SKB_CB(skb)->tmp);\n\txfrm_input_resume(skb, err);\n}\n\nstatic int ah_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint ah_hlen;\n\tint ihl;\n\tint nexthdr;\n\tint nfrags;\n\tu8 *auth_data;\n\tu8 *icv;\n\tstruct sk_buff *trailer;\n\tstruct crypto_ahash *ahash;\n\tstruct ahash_request *req;\n\tstruct scatterlist *sg;\n\tstruct iphdr *iph, *work_iph;\n\tstruct ip_auth_hdr *ah;\n\tstruct ah_data *ahp;\n\tint err = -ENOMEM;\n\tint seqhi_len = 0;\n\t__be32 *seqhi;\n\tint sglists = 0;\n\tstruct scatterlist *seqhisg;\n\n\tif (!pskb_may_pull(skb, sizeof(*ah)))\n\t\tgoto out;\n\n\tah = (struct ip_auth_hdr *)skb->data;\n\tahp = x->data;\n\tahash = ahp->ahash;\n\n\tnexthdr = ah->nexthdr;\n\tah_hlen = (ah->hdrlen + 2) << 2;\n\n\tif (x->props.flags & XFRM_STATE_ALIGN4) {\n\t\tif (ah_hlen != XFRM_ALIGN4(sizeof(*ah) + ahp->icv_full_len) &&\n\t\t    ah_hlen != XFRM_ALIGN4(sizeof(*ah) + ahp->icv_trunc_len))\n\t\t\tgoto out;\n\t} else {\n\t\tif (ah_hlen != XFRM_ALIGN8(sizeof(*ah) + ahp->icv_full_len) &&\n\t\t    ah_hlen != XFRM_ALIGN8(sizeof(*ah) + ahp->icv_trunc_len))\n\t\t\tgoto out;\n\t}\n\n\tif (!pskb_may_pull(skb, ah_hlen))\n\t\tgoto out;\n\n\t \n\tif (skb_unclone(skb, GFP_ATOMIC))\n\t\tgoto out;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\n\tif ((err = skb_cow_data(skb, 0, &trailer)) < 0)\n\t\tgoto out;\n\tnfrags = err;\n\n\tah = (struct ip_auth_hdr *)skb->data;\n\tiph = ip_hdr(skb);\n\tihl = ip_hdrlen(skb);\n\n\tif (x->props.flags & XFRM_STATE_ESN) {\n\t\tsglists = 1;\n\t\tseqhi_len = sizeof(*seqhi);\n\t}\n\n\twork_iph = ah_alloc_tmp(ahash, nfrags + sglists, ihl +\n\t\t\t\tahp->icv_trunc_len + seqhi_len);\n\tif (!work_iph) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tseqhi = (__be32 *)((char *)work_iph + ihl);\n\tauth_data = ah_tmp_auth(seqhi, seqhi_len);\n\ticv = ah_tmp_icv(ahash, auth_data, ahp->icv_trunc_len);\n\treq = ah_tmp_req(ahash, icv);\n\tsg = ah_req_sg(ahash, req);\n\tseqhisg = sg + nfrags;\n\n\tmemcpy(work_iph, iph, ihl);\n\tmemcpy(auth_data, ah->auth_data, ahp->icv_trunc_len);\n\tmemset(ah->auth_data, 0, ahp->icv_trunc_len);\n\n\tiph->ttl = 0;\n\tiph->tos = 0;\n\tiph->frag_off = 0;\n\tiph->check = 0;\n\tif (ihl > sizeof(*iph)) {\n\t\t__be32 dummy;\n\t\terr = ip_clear_mutable_options(iph, &dummy);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tskb_push(skb, ihl);\n\n\tsg_init_table(sg, nfrags + sglists);\n\terr = skb_to_sgvec_nomark(skb, sg, 0, skb->len);\n\tif (unlikely(err < 0))\n\t\tgoto out_free;\n\n\tif (x->props.flags & XFRM_STATE_ESN) {\n\t\t \n\t\t*seqhi = XFRM_SKB_CB(skb)->seq.input.hi;\n\t\tsg_set_buf(seqhisg, seqhi, seqhi_len);\n\t}\n\tahash_request_set_crypt(req, sg, icv, skb->len + seqhi_len);\n\tahash_request_set_callback(req, 0, ah_input_done, skb);\n\n\tAH_SKB_CB(skb)->tmp = work_iph;\n\n\terr = crypto_ahash_digest(req);\n\tif (err) {\n\t\tif (err == -EINPROGRESS)\n\t\t\tgoto out;\n\n\t\tgoto out_free;\n\t}\n\n\terr = crypto_memneq(icv, auth_data, ahp->icv_trunc_len) ? -EBADMSG : 0;\n\tif (err)\n\t\tgoto out_free;\n\n\tskb->network_header += ah_hlen;\n\tmemcpy(skb_network_header(skb), work_iph, ihl);\n\t__skb_pull(skb, ah_hlen + ihl);\n\tif (x->props.mode == XFRM_MODE_TUNNEL)\n\t\tskb_reset_transport_header(skb);\n\telse\n\t\tskb_set_transport_header(skb, -ihl);\n\n\terr = nexthdr;\n\nout_free:\n\tkfree (work_iph);\nout:\n\treturn err;\n}\n\nstatic int ah4_err(struct sk_buff *skb, u32 info)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\tstruct ip_auth_hdr *ah = (struct ip_auth_hdr *)(skb->data+(iph->ihl<<2));\n\tstruct xfrm_state *x;\n\n\tswitch (icmp_hdr(skb)->type) {\n\tcase ICMP_DEST_UNREACH:\n\t\tif (icmp_hdr(skb)->code != ICMP_FRAG_NEEDED)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase ICMP_REDIRECT:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tx = xfrm_state_lookup(net, skb->mark, (const xfrm_address_t *)&iph->daddr,\n\t\t\t      ah->spi, IPPROTO_AH, AF_INET);\n\tif (!x)\n\t\treturn 0;\n\n\tif (icmp_hdr(skb)->type == ICMP_DEST_UNREACH)\n\t\tipv4_update_pmtu(skb, net, info, 0, IPPROTO_AH);\n\telse\n\t\tipv4_redirect(skb, net, 0, IPPROTO_AH);\n\txfrm_state_put(x);\n\n\treturn 0;\n}\n\nstatic int ah_init_state(struct xfrm_state *x, struct netlink_ext_ack *extack)\n{\n\tstruct ah_data *ahp = NULL;\n\tstruct xfrm_algo_desc *aalg_desc;\n\tstruct crypto_ahash *ahash;\n\n\tif (!x->aalg) {\n\t\tNL_SET_ERR_MSG(extack, \"AH requires a state with an AUTH algorithm\");\n\t\tgoto error;\n\t}\n\n\tif (x->encap) {\n\t\tNL_SET_ERR_MSG(extack, \"AH is not compatible with encapsulation\");\n\t\tgoto error;\n\t}\n\n\tahp = kzalloc(sizeof(*ahp), GFP_KERNEL);\n\tif (!ahp)\n\t\treturn -ENOMEM;\n\n\tahash = crypto_alloc_ahash(x->aalg->alg_name, 0, 0);\n\tif (IS_ERR(ahash)) {\n\t\tNL_SET_ERR_MSG(extack, \"Kernel was unable to initialize cryptographic operations\");\n\t\tgoto error;\n\t}\n\n\tahp->ahash = ahash;\n\tif (crypto_ahash_setkey(ahash, x->aalg->alg_key,\n\t\t\t\t(x->aalg->alg_key_len + 7) / 8)) {\n\t\tNL_SET_ERR_MSG(extack, \"Kernel was unable to initialize cryptographic operations\");\n\t\tgoto error;\n\t}\n\n\t \n\taalg_desc = xfrm_aalg_get_byname(x->aalg->alg_name, 0);\n\tBUG_ON(!aalg_desc);\n\n\tif (aalg_desc->uinfo.auth.icv_fullbits/8 !=\n\t    crypto_ahash_digestsize(ahash)) {\n\t\tNL_SET_ERR_MSG(extack, \"Kernel was unable to initialize cryptographic operations\");\n\t\tgoto error;\n\t}\n\n\tahp->icv_full_len = aalg_desc->uinfo.auth.icv_fullbits/8;\n\tahp->icv_trunc_len = x->aalg->alg_trunc_len/8;\n\n\tif (x->props.flags & XFRM_STATE_ALIGN4)\n\t\tx->props.header_len = XFRM_ALIGN4(sizeof(struct ip_auth_hdr) +\n\t\t\t\t\t\t  ahp->icv_trunc_len);\n\telse\n\t\tx->props.header_len = XFRM_ALIGN8(sizeof(struct ip_auth_hdr) +\n\t\t\t\t\t\t  ahp->icv_trunc_len);\n\tif (x->props.mode == XFRM_MODE_TUNNEL)\n\t\tx->props.header_len += sizeof(struct iphdr);\n\tx->data = ahp;\n\n\treturn 0;\n\nerror:\n\tif (ahp) {\n\t\tcrypto_free_ahash(ahp->ahash);\n\t\tkfree(ahp);\n\t}\n\treturn -EINVAL;\n}\n\nstatic void ah_destroy(struct xfrm_state *x)\n{\n\tstruct ah_data *ahp = x->data;\n\n\tif (!ahp)\n\t\treturn;\n\n\tcrypto_free_ahash(ahp->ahash);\n\tkfree(ahp);\n}\n\nstatic int ah4_rcv_cb(struct sk_buff *skb, int err)\n{\n\treturn 0;\n}\n\nstatic const struct xfrm_type ah_type =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.proto\t     \t= IPPROTO_AH,\n\t.flags\t\t= XFRM_TYPE_REPLAY_PROT,\n\t.init_state\t= ah_init_state,\n\t.destructor\t= ah_destroy,\n\t.input\t\t= ah_input,\n\t.output\t\t= ah_output\n};\n\nstatic struct xfrm4_protocol ah4_protocol = {\n\t.handler\t=\txfrm4_rcv,\n\t.input_handler\t=\txfrm_input,\n\t.cb_handler\t=\tah4_rcv_cb,\n\t.err_handler\t=\tah4_err,\n\t.priority\t=\t0,\n};\n\nstatic int __init ah4_init(void)\n{\n\tif (xfrm_register_type(&ah_type, AF_INET) < 0) {\n\t\tpr_info(\"%s: can't add xfrm type\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\tif (xfrm4_protocol_register(&ah4_protocol, IPPROTO_AH) < 0) {\n\t\tpr_info(\"%s: can't add protocol\\n\", __func__);\n\t\txfrm_unregister_type(&ah_type, AF_INET);\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic void __exit ah4_fini(void)\n{\n\tif (xfrm4_protocol_deregister(&ah4_protocol, IPPROTO_AH) < 0)\n\t\tpr_info(\"%s: can't remove protocol\\n\", __func__);\n\txfrm_unregister_type(&ah_type, AF_INET);\n}\n\nmodule_init(ah4_init);\nmodule_exit(ah4_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_XFRM_TYPE(AF_INET, XFRM_PROTO_AH);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}