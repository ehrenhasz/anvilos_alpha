{
  "module_name": "tcp_hybla.c",
  "hash_id": "c4cfe24a053cdecce169ad275a054ab4db6305145b63c4530ab4c625456226f6",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_hybla.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <net/tcp.h>\n\n \nstruct hybla {\n\tbool  hybla_en;\n\tu32   snd_cwnd_cents;  \n\tu32   rho;\t       \n\tu32   rho2;\t       \n\tu32   rho_3ls;\t       \n\tu32   rho2_7ls;\t       \n\tu32   minrtt_us;       \n};\n\n \nstatic int rtt0 = 25;\nmodule_param(rtt0, int, 0644);\nMODULE_PARM_DESC(rtt0, \"reference rout trip time (ms)\");\n\n \nstatic inline void hybla_recalc_param (struct sock *sk)\n{\n\tstruct hybla *ca = inet_csk_ca(sk);\n\n\tca->rho_3ls = max_t(u32,\n\t\t\t    tcp_sk(sk)->srtt_us / (rtt0 * USEC_PER_MSEC),\n\t\t\t    8U);\n\tca->rho = ca->rho_3ls >> 3;\n\tca->rho2_7ls = (ca->rho_3ls * ca->rho_3ls) << 1;\n\tca->rho2 = ca->rho2_7ls >> 7;\n}\n\nstatic void hybla_init(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct hybla *ca = inet_csk_ca(sk);\n\n\tca->rho = 0;\n\tca->rho2 = 0;\n\tca->rho_3ls = 0;\n\tca->rho2_7ls = 0;\n\tca->snd_cwnd_cents = 0;\n\tca->hybla_en = true;\n\ttcp_snd_cwnd_set(tp, 2);\n\ttp->snd_cwnd_clamp = 65535;\n\n\t \n\thybla_recalc_param(sk);\n\n\t \n\tca->minrtt_us = tp->srtt_us;\n\ttcp_snd_cwnd_set(tp, ca->rho);\n}\n\nstatic void hybla_state(struct sock *sk, u8 ca_state)\n{\n\tstruct hybla *ca = inet_csk_ca(sk);\n\n\tca->hybla_en = (ca_state == TCP_CA_Open);\n}\n\nstatic inline u32 hybla_fraction(u32 odds)\n{\n\tstatic const u32 fractions[] = {\n\t\t128, 139, 152, 165, 181, 197, 215, 234,\n\t};\n\n\treturn (odds < ARRAY_SIZE(fractions)) ? fractions[odds] : 128;\n}\n\n \nstatic void hybla_cong_avoid(struct sock *sk, u32 ack, u32 acked)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct hybla *ca = inet_csk_ca(sk);\n\tu32 increment, odd, rho_fractions;\n\tint is_slowstart = 0;\n\n\t \n\tif (tp->srtt_us < ca->minrtt_us) {\n\t\thybla_recalc_param(sk);\n\t\tca->minrtt_us = tp->srtt_us;\n\t}\n\n\tif (!tcp_is_cwnd_limited(sk))\n\t\treturn;\n\n\tif (!ca->hybla_en) {\n\t\ttcp_reno_cong_avoid(sk, ack, acked);\n\t\treturn;\n\t}\n\n\tif (ca->rho == 0)\n\t\thybla_recalc_param(sk);\n\n\trho_fractions = ca->rho_3ls - (ca->rho << 3);\n\n\tif (tcp_in_slow_start(tp)) {\n\t\t \n\t\tis_slowstart = 1;\n\t\tincrement = ((1 << min(ca->rho, 16U)) *\n\t\t\thybla_fraction(rho_fractions)) - 128;\n\t} else {\n\t\t \n\t\tincrement = ca->rho2_7ls / tcp_snd_cwnd(tp);\n\t\tif (increment < 128)\n\t\t\ttp->snd_cwnd_cnt++;\n\t}\n\n\todd = increment % 128;\n\ttcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) + (increment >> 7));\n\tca->snd_cwnd_cents += odd;\n\n\t \n\twhile (ca->snd_cwnd_cents >= 128) {\n\t\ttcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) + 1);\n\t\tca->snd_cwnd_cents -= 128;\n\t\ttp->snd_cwnd_cnt = 0;\n\t}\n\t \n\tif (increment == 0 && odd == 0 && tp->snd_cwnd_cnt >= tcp_snd_cwnd(tp)) {\n\t\ttcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) + 1);\n\t\ttp->snd_cwnd_cnt = 0;\n\t}\n\t \n\tif (is_slowstart)\n\t\ttcp_snd_cwnd_set(tp, min(tcp_snd_cwnd(tp), tp->snd_ssthresh));\n\n\ttcp_snd_cwnd_set(tp, min(tcp_snd_cwnd(tp), tp->snd_cwnd_clamp));\n}\n\nstatic struct tcp_congestion_ops tcp_hybla __read_mostly = {\n\t.init\t\t= hybla_init,\n\t.ssthresh\t= tcp_reno_ssthresh,\n\t.undo_cwnd\t= tcp_reno_undo_cwnd,\n\t.cong_avoid\t= hybla_cong_avoid,\n\t.set_state\t= hybla_state,\n\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"hybla\"\n};\n\nstatic int __init hybla_register(void)\n{\n\tBUILD_BUG_ON(sizeof(struct hybla) > ICSK_CA_PRIV_SIZE);\n\treturn tcp_register_congestion_control(&tcp_hybla);\n}\n\nstatic void __exit hybla_unregister(void)\n{\n\ttcp_unregister_congestion_control(&tcp_hybla);\n}\n\nmodule_init(hybla_register);\nmodule_exit(hybla_unregister);\n\nMODULE_AUTHOR(\"Daniele Lacamera\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TCP Hybla\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}