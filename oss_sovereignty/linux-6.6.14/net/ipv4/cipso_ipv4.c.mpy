{
  "module_name": "cipso_ipv4.c",
  "hash_id": "74e23e3d5203b3da6a9236ae2ac3bd0c2ae87b78d7158777bcbd122e2fa989aa",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/cipso_ipv4.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/jhash.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/tcp.h>\n#include <net/netlabel.h>\n#include <net/cipso_ipv4.h>\n#include <linux/atomic.h>\n#include <linux/bug.h>\n#include <asm/unaligned.h>\n\n \n \nstatic DEFINE_SPINLOCK(cipso_v4_doi_list_lock);\nstatic LIST_HEAD(cipso_v4_doi_list);\n\n \nint cipso_v4_cache_enabled = 1;\nint cipso_v4_cache_bucketsize = 10;\n#define CIPSO_V4_CACHE_BUCKETBITS     7\n#define CIPSO_V4_CACHE_BUCKETS        (1 << CIPSO_V4_CACHE_BUCKETBITS)\n#define CIPSO_V4_CACHE_REORDERLIMIT   10\nstruct cipso_v4_map_cache_bkt {\n\tspinlock_t lock;\n\tu32 size;\n\tstruct list_head list;\n};\n\nstruct cipso_v4_map_cache_entry {\n\tu32 hash;\n\tunsigned char *key;\n\tsize_t key_len;\n\n\tstruct netlbl_lsm_cache *lsm_data;\n\n\tu32 activity;\n\tstruct list_head list;\n};\n\nstatic struct cipso_v4_map_cache_bkt *cipso_v4_cache;\n\n \nint cipso_v4_rbm_optfmt;\nint cipso_v4_rbm_strictvalid = 1;\n\n \n\n \n#define CIPSO_V4_OPT_LEN_MAX          40\n\n \n#define CIPSO_V4_HDR_LEN              6\n\n \n#define CIPSO_V4_TAG_RBM_BLEN         4\n\n \n#define CIPSO_V4_TAG_ENUM_BLEN        4\n\n \n#define CIPSO_V4_TAG_RNG_BLEN         4\n \n#define CIPSO_V4_TAG_RNG_CAT_MAX      8\n\n \n#define CIPSO_V4_TAG_LOC_BLEN         6\n\n \n\n \nstatic void cipso_v4_cache_entry_free(struct cipso_v4_map_cache_entry *entry)\n{\n\tif (entry->lsm_data)\n\t\tnetlbl_secattr_cache_free(entry->lsm_data);\n\tkfree(entry->key);\n\tkfree(entry);\n}\n\n \nstatic u32 cipso_v4_map_cache_hash(const unsigned char *key, u32 key_len)\n{\n\treturn jhash(key, key_len, 0);\n}\n\n \n\n \nstatic int __init cipso_v4_cache_init(void)\n{\n\tu32 iter;\n\n\tcipso_v4_cache = kcalloc(CIPSO_V4_CACHE_BUCKETS,\n\t\t\t\t sizeof(struct cipso_v4_map_cache_bkt),\n\t\t\t\t GFP_KERNEL);\n\tif (!cipso_v4_cache)\n\t\treturn -ENOMEM;\n\n\tfor (iter = 0; iter < CIPSO_V4_CACHE_BUCKETS; iter++) {\n\t\tspin_lock_init(&cipso_v4_cache[iter].lock);\n\t\tcipso_v4_cache[iter].size = 0;\n\t\tINIT_LIST_HEAD(&cipso_v4_cache[iter].list);\n\t}\n\n\treturn 0;\n}\n\n \nvoid cipso_v4_cache_invalidate(void)\n{\n\tstruct cipso_v4_map_cache_entry *entry, *tmp_entry;\n\tu32 iter;\n\n\tfor (iter = 0; iter < CIPSO_V4_CACHE_BUCKETS; iter++) {\n\t\tspin_lock_bh(&cipso_v4_cache[iter].lock);\n\t\tlist_for_each_entry_safe(entry,\n\t\t\t\t\t tmp_entry,\n\t\t\t\t\t &cipso_v4_cache[iter].list, list) {\n\t\t\tlist_del(&entry->list);\n\t\t\tcipso_v4_cache_entry_free(entry);\n\t\t}\n\t\tcipso_v4_cache[iter].size = 0;\n\t\tspin_unlock_bh(&cipso_v4_cache[iter].lock);\n\t}\n}\n\n \nstatic int cipso_v4_cache_check(const unsigned char *key,\n\t\t\t\tu32 key_len,\n\t\t\t\tstruct netlbl_lsm_secattr *secattr)\n{\n\tu32 bkt;\n\tstruct cipso_v4_map_cache_entry *entry;\n\tstruct cipso_v4_map_cache_entry *prev_entry = NULL;\n\tu32 hash;\n\n\tif (!READ_ONCE(cipso_v4_cache_enabled))\n\t\treturn -ENOENT;\n\n\thash = cipso_v4_map_cache_hash(key, key_len);\n\tbkt = hash & (CIPSO_V4_CACHE_BUCKETS - 1);\n\tspin_lock_bh(&cipso_v4_cache[bkt].lock);\n\tlist_for_each_entry(entry, &cipso_v4_cache[bkt].list, list) {\n\t\tif (entry->hash == hash &&\n\t\t    entry->key_len == key_len &&\n\t\t    memcmp(entry->key, key, key_len) == 0) {\n\t\t\tentry->activity += 1;\n\t\t\trefcount_inc(&entry->lsm_data->refcount);\n\t\t\tsecattr->cache = entry->lsm_data;\n\t\t\tsecattr->flags |= NETLBL_SECATTR_CACHE;\n\t\t\tsecattr->type = NETLBL_NLTYPE_CIPSOV4;\n\t\t\tif (!prev_entry) {\n\t\t\t\tspin_unlock_bh(&cipso_v4_cache[bkt].lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (prev_entry->activity > 0)\n\t\t\t\tprev_entry->activity -= 1;\n\t\t\tif (entry->activity > prev_entry->activity &&\n\t\t\t    entry->activity - prev_entry->activity >\n\t\t\t    CIPSO_V4_CACHE_REORDERLIMIT) {\n\t\t\t\t__list_del(entry->list.prev, entry->list.next);\n\t\t\t\t__list_add(&entry->list,\n\t\t\t\t\t   prev_entry->list.prev,\n\t\t\t\t\t   &prev_entry->list);\n\t\t\t}\n\n\t\t\tspin_unlock_bh(&cipso_v4_cache[bkt].lock);\n\t\t\treturn 0;\n\t\t}\n\t\tprev_entry = entry;\n\t}\n\tspin_unlock_bh(&cipso_v4_cache[bkt].lock);\n\n\treturn -ENOENT;\n}\n\n \nint cipso_v4_cache_add(const unsigned char *cipso_ptr,\n\t\t       const struct netlbl_lsm_secattr *secattr)\n{\n\tint bkt_size = READ_ONCE(cipso_v4_cache_bucketsize);\n\tint ret_val = -EPERM;\n\tu32 bkt;\n\tstruct cipso_v4_map_cache_entry *entry = NULL;\n\tstruct cipso_v4_map_cache_entry *old_entry = NULL;\n\tu32 cipso_ptr_len;\n\n\tif (!READ_ONCE(cipso_v4_cache_enabled) || bkt_size <= 0)\n\t\treturn 0;\n\n\tcipso_ptr_len = cipso_ptr[1];\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry->key = kmemdup(cipso_ptr, cipso_ptr_len, GFP_ATOMIC);\n\tif (!entry->key) {\n\t\tret_val = -ENOMEM;\n\t\tgoto cache_add_failure;\n\t}\n\tentry->key_len = cipso_ptr_len;\n\tentry->hash = cipso_v4_map_cache_hash(cipso_ptr, cipso_ptr_len);\n\trefcount_inc(&secattr->cache->refcount);\n\tentry->lsm_data = secattr->cache;\n\n\tbkt = entry->hash & (CIPSO_V4_CACHE_BUCKETS - 1);\n\tspin_lock_bh(&cipso_v4_cache[bkt].lock);\n\tif (cipso_v4_cache[bkt].size < bkt_size) {\n\t\tlist_add(&entry->list, &cipso_v4_cache[bkt].list);\n\t\tcipso_v4_cache[bkt].size += 1;\n\t} else {\n\t\told_entry = list_entry(cipso_v4_cache[bkt].list.prev,\n\t\t\t\t       struct cipso_v4_map_cache_entry, list);\n\t\tlist_del(&old_entry->list);\n\t\tlist_add(&entry->list, &cipso_v4_cache[bkt].list);\n\t\tcipso_v4_cache_entry_free(old_entry);\n\t}\n\tspin_unlock_bh(&cipso_v4_cache[bkt].lock);\n\n\treturn 0;\n\ncache_add_failure:\n\tif (entry)\n\t\tcipso_v4_cache_entry_free(entry);\n\treturn ret_val;\n}\n\n \n\n \nstatic struct cipso_v4_doi *cipso_v4_doi_search(u32 doi)\n{\n\tstruct cipso_v4_doi *iter;\n\n\tlist_for_each_entry_rcu(iter, &cipso_v4_doi_list, list)\n\t\tif (iter->doi == doi && refcount_read(&iter->refcount))\n\t\t\treturn iter;\n\treturn NULL;\n}\n\n \nint cipso_v4_doi_add(struct cipso_v4_doi *doi_def,\n\t\t     struct netlbl_audit *audit_info)\n{\n\tint ret_val = -EINVAL;\n\tu32 iter;\n\tu32 doi;\n\tu32 doi_type;\n\tstruct audit_buffer *audit_buf;\n\n\tdoi = doi_def->doi;\n\tdoi_type = doi_def->type;\n\n\tif (doi_def->doi == CIPSO_V4_DOI_UNKNOWN)\n\t\tgoto doi_add_return;\n\tfor (iter = 0; iter < CIPSO_V4_TAG_MAXCNT; iter++) {\n\t\tswitch (doi_def->tags[iter]) {\n\t\tcase CIPSO_V4_TAG_RBITMAP:\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_RANGE:\n\t\tcase CIPSO_V4_TAG_ENUM:\n\t\t\tif (doi_def->type != CIPSO_V4_MAP_PASS)\n\t\t\t\tgoto doi_add_return;\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_LOCAL:\n\t\t\tif (doi_def->type != CIPSO_V4_MAP_LOCAL)\n\t\t\t\tgoto doi_add_return;\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_INVALID:\n\t\t\tif (iter == 0)\n\t\t\t\tgoto doi_add_return;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto doi_add_return;\n\t\t}\n\t}\n\n\trefcount_set(&doi_def->refcount, 1);\n\n\tspin_lock(&cipso_v4_doi_list_lock);\n\tif (cipso_v4_doi_search(doi_def->doi)) {\n\t\tspin_unlock(&cipso_v4_doi_list_lock);\n\t\tret_val = -EEXIST;\n\t\tgoto doi_add_return;\n\t}\n\tlist_add_tail_rcu(&doi_def->list, &cipso_v4_doi_list);\n\tspin_unlock(&cipso_v4_doi_list_lock);\n\tret_val = 0;\n\ndoi_add_return:\n\taudit_buf = netlbl_audit_start(AUDIT_MAC_CIPSOV4_ADD, audit_info);\n\tif (audit_buf) {\n\t\tconst char *type_str;\n\t\tswitch (doi_type) {\n\t\tcase CIPSO_V4_MAP_TRANS:\n\t\t\ttype_str = \"trans\";\n\t\t\tbreak;\n\t\tcase CIPSO_V4_MAP_PASS:\n\t\t\ttype_str = \"pass\";\n\t\t\tbreak;\n\t\tcase CIPSO_V4_MAP_LOCAL:\n\t\t\ttype_str = \"local\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype_str = \"(unknown)\";\n\t\t}\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \" cipso_doi=%u cipso_type=%s res=%u\",\n\t\t\t\t doi, type_str, ret_val == 0 ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\n\treturn ret_val;\n}\n\n \nvoid cipso_v4_doi_free(struct cipso_v4_doi *doi_def)\n{\n\tif (!doi_def)\n\t\treturn;\n\n\tswitch (doi_def->type) {\n\tcase CIPSO_V4_MAP_TRANS:\n\t\tkfree(doi_def->map.std->lvl.cipso);\n\t\tkfree(doi_def->map.std->lvl.local);\n\t\tkfree(doi_def->map.std->cat.cipso);\n\t\tkfree(doi_def->map.std->cat.local);\n\t\tkfree(doi_def->map.std);\n\t\tbreak;\n\t}\n\tkfree(doi_def);\n}\n\n \nstatic void cipso_v4_doi_free_rcu(struct rcu_head *entry)\n{\n\tstruct cipso_v4_doi *doi_def;\n\n\tdoi_def = container_of(entry, struct cipso_v4_doi, rcu);\n\tcipso_v4_doi_free(doi_def);\n}\n\n \nint cipso_v4_doi_remove(u32 doi, struct netlbl_audit *audit_info)\n{\n\tint ret_val;\n\tstruct cipso_v4_doi *doi_def;\n\tstruct audit_buffer *audit_buf;\n\n\tspin_lock(&cipso_v4_doi_list_lock);\n\tdoi_def = cipso_v4_doi_search(doi);\n\tif (!doi_def) {\n\t\tspin_unlock(&cipso_v4_doi_list_lock);\n\t\tret_val = -ENOENT;\n\t\tgoto doi_remove_return;\n\t}\n\tlist_del_rcu(&doi_def->list);\n\tspin_unlock(&cipso_v4_doi_list_lock);\n\n\tcipso_v4_doi_putdef(doi_def);\n\tret_val = 0;\n\ndoi_remove_return:\n\taudit_buf = netlbl_audit_start(AUDIT_MAC_CIPSOV4_DEL, audit_info);\n\tif (audit_buf) {\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \" cipso_doi=%u res=%u\",\n\t\t\t\t doi, ret_val == 0 ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\n\treturn ret_val;\n}\n\n \nstruct cipso_v4_doi *cipso_v4_doi_getdef(u32 doi)\n{\n\tstruct cipso_v4_doi *doi_def;\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_search(doi);\n\tif (!doi_def)\n\t\tgoto doi_getdef_return;\n\tif (!refcount_inc_not_zero(&doi_def->refcount))\n\t\tdoi_def = NULL;\n\ndoi_getdef_return:\n\trcu_read_unlock();\n\treturn doi_def;\n}\n\n \nvoid cipso_v4_doi_putdef(struct cipso_v4_doi *doi_def)\n{\n\tif (!doi_def)\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&doi_def->refcount))\n\t\treturn;\n\n\tcipso_v4_cache_invalidate();\n\tcall_rcu(&doi_def->rcu, cipso_v4_doi_free_rcu);\n}\n\n \nint cipso_v4_doi_walk(u32 *skip_cnt,\n\t\t     int (*callback) (struct cipso_v4_doi *doi_def, void *arg),\n\t\t     void *cb_arg)\n{\n\tint ret_val = -ENOENT;\n\tu32 doi_cnt = 0;\n\tstruct cipso_v4_doi *iter_doi;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(iter_doi, &cipso_v4_doi_list, list)\n\t\tif (refcount_read(&iter_doi->refcount) > 0) {\n\t\t\tif (doi_cnt++ < *skip_cnt)\n\t\t\t\tcontinue;\n\t\t\tret_val = callback(iter_doi, cb_arg);\n\t\t\tif (ret_val < 0) {\n\t\t\t\tdoi_cnt--;\n\t\t\t\tgoto doi_walk_return;\n\t\t\t}\n\t\t}\n\ndoi_walk_return:\n\trcu_read_unlock();\n\t*skip_cnt = doi_cnt;\n\treturn ret_val;\n}\n\n \n\n \nstatic int cipso_v4_map_lvl_valid(const struct cipso_v4_doi *doi_def, u8 level)\n{\n\tswitch (doi_def->type) {\n\tcase CIPSO_V4_MAP_PASS:\n\t\treturn 0;\n\tcase CIPSO_V4_MAP_TRANS:\n\t\tif ((level < doi_def->map.std->lvl.cipso_size) &&\n\t\t    (doi_def->map.std->lvl.cipso[level] < CIPSO_V4_INV_LVL))\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn -EFAULT;\n}\n\n \nstatic int cipso_v4_map_lvl_hton(const struct cipso_v4_doi *doi_def,\n\t\t\t\t u32 host_lvl,\n\t\t\t\t u32 *net_lvl)\n{\n\tswitch (doi_def->type) {\n\tcase CIPSO_V4_MAP_PASS:\n\t\t*net_lvl = host_lvl;\n\t\treturn 0;\n\tcase CIPSO_V4_MAP_TRANS:\n\t\tif (host_lvl < doi_def->map.std->lvl.local_size &&\n\t\t    doi_def->map.std->lvl.local[host_lvl] < CIPSO_V4_INV_LVL) {\n\t\t\t*net_lvl = doi_def->map.std->lvl.local[host_lvl];\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EPERM;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int cipso_v4_map_lvl_ntoh(const struct cipso_v4_doi *doi_def,\n\t\t\t\t u32 net_lvl,\n\t\t\t\t u32 *host_lvl)\n{\n\tstruct cipso_v4_std_map_tbl *map_tbl;\n\n\tswitch (doi_def->type) {\n\tcase CIPSO_V4_MAP_PASS:\n\t\t*host_lvl = net_lvl;\n\t\treturn 0;\n\tcase CIPSO_V4_MAP_TRANS:\n\t\tmap_tbl = doi_def->map.std;\n\t\tif (net_lvl < map_tbl->lvl.cipso_size &&\n\t\t    map_tbl->lvl.cipso[net_lvl] < CIPSO_V4_INV_LVL) {\n\t\t\t*host_lvl = doi_def->map.std->lvl.cipso[net_lvl];\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EPERM;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int cipso_v4_map_cat_rbm_valid(const struct cipso_v4_doi *doi_def,\n\t\t\t\t      const unsigned char *bitmap,\n\t\t\t\t      u32 bitmap_len)\n{\n\tint cat = -1;\n\tu32 bitmap_len_bits = bitmap_len * 8;\n\tu32 cipso_cat_size;\n\tu32 *cipso_array;\n\n\tswitch (doi_def->type) {\n\tcase CIPSO_V4_MAP_PASS:\n\t\treturn 0;\n\tcase CIPSO_V4_MAP_TRANS:\n\t\tcipso_cat_size = doi_def->map.std->cat.cipso_size;\n\t\tcipso_array = doi_def->map.std->cat.cipso;\n\t\tfor (;;) {\n\t\t\tcat = netlbl_bitmap_walk(bitmap,\n\t\t\t\t\t\t bitmap_len_bits,\n\t\t\t\t\t\t cat + 1,\n\t\t\t\t\t\t 1);\n\t\t\tif (cat < 0)\n\t\t\t\tbreak;\n\t\t\tif (cat >= cipso_cat_size ||\n\t\t\t    cipso_array[cat] >= CIPSO_V4_INV_CAT)\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (cat == -1)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn -EFAULT;\n}\n\n \nstatic int cipso_v4_map_cat_rbm_hton(const struct cipso_v4_doi *doi_def,\n\t\t\t\t     const struct netlbl_lsm_secattr *secattr,\n\t\t\t\t     unsigned char *net_cat,\n\t\t\t\t     u32 net_cat_len)\n{\n\tint host_spot = -1;\n\tu32 net_spot = CIPSO_V4_INV_CAT;\n\tu32 net_spot_max = 0;\n\tu32 net_clen_bits = net_cat_len * 8;\n\tu32 host_cat_size = 0;\n\tu32 *host_cat_array = NULL;\n\n\tif (doi_def->type == CIPSO_V4_MAP_TRANS) {\n\t\thost_cat_size = doi_def->map.std->cat.local_size;\n\t\thost_cat_array = doi_def->map.std->cat.local;\n\t}\n\n\tfor (;;) {\n\t\thost_spot = netlbl_catmap_walk(secattr->attr.mls.cat,\n\t\t\t\t\t       host_spot + 1);\n\t\tif (host_spot < 0)\n\t\t\tbreak;\n\n\t\tswitch (doi_def->type) {\n\t\tcase CIPSO_V4_MAP_PASS:\n\t\t\tnet_spot = host_spot;\n\t\t\tbreak;\n\t\tcase CIPSO_V4_MAP_TRANS:\n\t\t\tif (host_spot >= host_cat_size)\n\t\t\t\treturn -EPERM;\n\t\t\tnet_spot = host_cat_array[host_spot];\n\t\t\tif (net_spot >= CIPSO_V4_INV_CAT)\n\t\t\t\treturn -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (net_spot >= net_clen_bits)\n\t\t\treturn -ENOSPC;\n\t\tnetlbl_bitmap_setbit(net_cat, net_spot, 1);\n\n\t\tif (net_spot > net_spot_max)\n\t\t\tnet_spot_max = net_spot;\n\t}\n\n\tif (++net_spot_max % 8)\n\t\treturn net_spot_max / 8 + 1;\n\treturn net_spot_max / 8;\n}\n\n \nstatic int cipso_v4_map_cat_rbm_ntoh(const struct cipso_v4_doi *doi_def,\n\t\t\t\t     const unsigned char *net_cat,\n\t\t\t\t     u32 net_cat_len,\n\t\t\t\t     struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tint net_spot = -1;\n\tu32 host_spot = CIPSO_V4_INV_CAT;\n\tu32 net_clen_bits = net_cat_len * 8;\n\tu32 net_cat_size = 0;\n\tu32 *net_cat_array = NULL;\n\n\tif (doi_def->type == CIPSO_V4_MAP_TRANS) {\n\t\tnet_cat_size = doi_def->map.std->cat.cipso_size;\n\t\tnet_cat_array = doi_def->map.std->cat.cipso;\n\t}\n\n\tfor (;;) {\n\t\tnet_spot = netlbl_bitmap_walk(net_cat,\n\t\t\t\t\t      net_clen_bits,\n\t\t\t\t\t      net_spot + 1,\n\t\t\t\t\t      1);\n\t\tif (net_spot < 0) {\n\t\t\tif (net_spot == -2)\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\n\t\tswitch (doi_def->type) {\n\t\tcase CIPSO_V4_MAP_PASS:\n\t\t\thost_spot = net_spot;\n\t\t\tbreak;\n\t\tcase CIPSO_V4_MAP_TRANS:\n\t\t\tif (net_spot >= net_cat_size)\n\t\t\t\treturn -EPERM;\n\t\t\thost_spot = net_cat_array[net_spot];\n\t\t\tif (host_spot >= CIPSO_V4_INV_CAT)\n\t\t\t\treturn -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tret_val = netlbl_catmap_setbit(&secattr->attr.mls.cat,\n\t\t\t\t\t\t       host_spot,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\tif (ret_val != 0)\n\t\t\treturn ret_val;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int cipso_v4_map_cat_enum_valid(const struct cipso_v4_doi *doi_def,\n\t\t\t\t       const unsigned char *enumcat,\n\t\t\t\t       u32 enumcat_len)\n{\n\tu16 cat;\n\tint cat_prev = -1;\n\tu32 iter;\n\n\tif (doi_def->type != CIPSO_V4_MAP_PASS || enumcat_len & 0x01)\n\t\treturn -EFAULT;\n\n\tfor (iter = 0; iter < enumcat_len; iter += 2) {\n\t\tcat = get_unaligned_be16(&enumcat[iter]);\n\t\tif (cat <= cat_prev)\n\t\t\treturn -EFAULT;\n\t\tcat_prev = cat;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cipso_v4_map_cat_enum_hton(const struct cipso_v4_doi *doi_def,\n\t\t\t\t      const struct netlbl_lsm_secattr *secattr,\n\t\t\t\t      unsigned char *net_cat,\n\t\t\t\t      u32 net_cat_len)\n{\n\tint cat = -1;\n\tu32 cat_iter = 0;\n\n\tfor (;;) {\n\t\tcat = netlbl_catmap_walk(secattr->attr.mls.cat, cat + 1);\n\t\tif (cat < 0)\n\t\t\tbreak;\n\t\tif ((cat_iter + 2) > net_cat_len)\n\t\t\treturn -ENOSPC;\n\n\t\t*((__be16 *)&net_cat[cat_iter]) = htons(cat);\n\t\tcat_iter += 2;\n\t}\n\n\treturn cat_iter;\n}\n\n \nstatic int cipso_v4_map_cat_enum_ntoh(const struct cipso_v4_doi *doi_def,\n\t\t\t\t      const unsigned char *net_cat,\n\t\t\t\t      u32 net_cat_len,\n\t\t\t\t      struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tu32 iter;\n\n\tfor (iter = 0; iter < net_cat_len; iter += 2) {\n\t\tret_val = netlbl_catmap_setbit(&secattr->attr.mls.cat,\n\t\t\t\t\t     get_unaligned_be16(&net_cat[iter]),\n\t\t\t\t\t     GFP_ATOMIC);\n\t\tif (ret_val != 0)\n\t\t\treturn ret_val;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cipso_v4_map_cat_rng_valid(const struct cipso_v4_doi *doi_def,\n\t\t\t\t      const unsigned char *rngcat,\n\t\t\t\t      u32 rngcat_len)\n{\n\tu16 cat_high;\n\tu16 cat_low;\n\tu32 cat_prev = CIPSO_V4_MAX_REM_CATS + 1;\n\tu32 iter;\n\n\tif (doi_def->type != CIPSO_V4_MAP_PASS || rngcat_len & 0x01)\n\t\treturn -EFAULT;\n\n\tfor (iter = 0; iter < rngcat_len; iter += 4) {\n\t\tcat_high = get_unaligned_be16(&rngcat[iter]);\n\t\tif ((iter + 4) <= rngcat_len)\n\t\t\tcat_low = get_unaligned_be16(&rngcat[iter + 2]);\n\t\telse\n\t\t\tcat_low = 0;\n\n\t\tif (cat_high > cat_prev)\n\t\t\treturn -EFAULT;\n\n\t\tcat_prev = cat_low;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cipso_v4_map_cat_rng_hton(const struct cipso_v4_doi *doi_def,\n\t\t\t\t     const struct netlbl_lsm_secattr *secattr,\n\t\t\t\t     unsigned char *net_cat,\n\t\t\t\t     u32 net_cat_len)\n{\n\tint iter = -1;\n\tu16 array[CIPSO_V4_TAG_RNG_CAT_MAX * 2];\n\tu32 array_cnt = 0;\n\tu32 cat_size = 0;\n\n\t \n\tif (net_cat_len >\n\t    (CIPSO_V4_OPT_LEN_MAX - CIPSO_V4_HDR_LEN - CIPSO_V4_TAG_RNG_BLEN))\n\t\treturn -ENOSPC;\n\n\tfor (;;) {\n\t\titer = netlbl_catmap_walk(secattr->attr.mls.cat, iter + 1);\n\t\tif (iter < 0)\n\t\t\tbreak;\n\t\tcat_size += (iter == 0 ? 0 : sizeof(u16));\n\t\tif (cat_size > net_cat_len)\n\t\t\treturn -ENOSPC;\n\t\tarray[array_cnt++] = iter;\n\n\t\titer = netlbl_catmap_walkrng(secattr->attr.mls.cat, iter);\n\t\tif (iter < 0)\n\t\t\treturn -EFAULT;\n\t\tcat_size += sizeof(u16);\n\t\tif (cat_size > net_cat_len)\n\t\t\treturn -ENOSPC;\n\t\tarray[array_cnt++] = iter;\n\t}\n\n\tfor (iter = 0; array_cnt > 0;) {\n\t\t*((__be16 *)&net_cat[iter]) = htons(array[--array_cnt]);\n\t\titer += 2;\n\t\tarray_cnt--;\n\t\tif (array[array_cnt] != 0) {\n\t\t\t*((__be16 *)&net_cat[iter]) = htons(array[array_cnt]);\n\t\t\titer += 2;\n\t\t}\n\t}\n\n\treturn cat_size;\n}\n\n \nstatic int cipso_v4_map_cat_rng_ntoh(const struct cipso_v4_doi *doi_def,\n\t\t\t\t     const unsigned char *net_cat,\n\t\t\t\t     u32 net_cat_len,\n\t\t\t\t     struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tu32 net_iter;\n\tu16 cat_low;\n\tu16 cat_high;\n\n\tfor (net_iter = 0; net_iter < net_cat_len; net_iter += 4) {\n\t\tcat_high = get_unaligned_be16(&net_cat[net_iter]);\n\t\tif ((net_iter + 4) <= net_cat_len)\n\t\t\tcat_low = get_unaligned_be16(&net_cat[net_iter + 2]);\n\t\telse\n\t\t\tcat_low = 0;\n\n\t\tret_val = netlbl_catmap_setrng(&secattr->attr.mls.cat,\n\t\t\t\t\t       cat_low,\n\t\t\t\t\t       cat_high,\n\t\t\t\t\t       GFP_ATOMIC);\n\t\tif (ret_val != 0)\n\t\t\treturn ret_val;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic void cipso_v4_gentag_hdr(const struct cipso_v4_doi *doi_def,\n\t\t\t\tunsigned char *buf,\n\t\t\t\tu32 len)\n{\n\tbuf[0] = IPOPT_CIPSO;\n\tbuf[1] = CIPSO_V4_HDR_LEN + len;\n\tput_unaligned_be32(doi_def->doi, &buf[2]);\n}\n\n \nstatic int cipso_v4_gentag_rbm(const struct cipso_v4_doi *doi_def,\n\t\t\t       const struct netlbl_lsm_secattr *secattr,\n\t\t\t       unsigned char *buffer,\n\t\t\t       u32 buffer_len)\n{\n\tint ret_val;\n\tu32 tag_len;\n\tu32 level;\n\n\tif ((secattr->flags & NETLBL_SECATTR_MLS_LVL) == 0)\n\t\treturn -EPERM;\n\n\tret_val = cipso_v4_map_lvl_hton(doi_def,\n\t\t\t\t\tsecattr->attr.mls.lvl,\n\t\t\t\t\t&level);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\tif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\n\t\tret_val = cipso_v4_map_cat_rbm_hton(doi_def,\n\t\t\t\t\t\t    secattr,\n\t\t\t\t\t\t    &buffer[4],\n\t\t\t\t\t\t    buffer_len - 4);\n\t\tif (ret_val < 0)\n\t\t\treturn ret_val;\n\n\t\t \n\t\tif (READ_ONCE(cipso_v4_rbm_optfmt) && ret_val > 0 &&\n\t\t    ret_val <= 10)\n\t\t\ttag_len = 14;\n\t\telse\n\t\t\ttag_len = 4 + ret_val;\n\t} else\n\t\ttag_len = 4;\n\n\tbuffer[0] = CIPSO_V4_TAG_RBITMAP;\n\tbuffer[1] = tag_len;\n\tbuffer[3] = level;\n\n\treturn tag_len;\n}\n\n \nstatic int cipso_v4_parsetag_rbm(const struct cipso_v4_doi *doi_def,\n\t\t\t\t const unsigned char *tag,\n\t\t\t\t struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tu8 tag_len = tag[1];\n\tu32 level;\n\n\tret_val = cipso_v4_map_lvl_ntoh(doi_def, tag[3], &level);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tsecattr->attr.mls.lvl = level;\n\tsecattr->flags |= NETLBL_SECATTR_MLS_LVL;\n\n\tif (tag_len > 4) {\n\t\tret_val = cipso_v4_map_cat_rbm_ntoh(doi_def,\n\t\t\t\t\t\t    &tag[4],\n\t\t\t\t\t\t    tag_len - 4,\n\t\t\t\t\t\t    secattr);\n\t\tif (ret_val != 0) {\n\t\t\tnetlbl_catmap_free(secattr->attr.mls.cat);\n\t\t\treturn ret_val;\n\t\t}\n\n\t\tif (secattr->attr.mls.cat)\n\t\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cipso_v4_gentag_enum(const struct cipso_v4_doi *doi_def,\n\t\t\t\tconst struct netlbl_lsm_secattr *secattr,\n\t\t\t\tunsigned char *buffer,\n\t\t\t\tu32 buffer_len)\n{\n\tint ret_val;\n\tu32 tag_len;\n\tu32 level;\n\n\tif (!(secattr->flags & NETLBL_SECATTR_MLS_LVL))\n\t\treturn -EPERM;\n\n\tret_val = cipso_v4_map_lvl_hton(doi_def,\n\t\t\t\t\tsecattr->attr.mls.lvl,\n\t\t\t\t\t&level);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\tif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\n\t\tret_val = cipso_v4_map_cat_enum_hton(doi_def,\n\t\t\t\t\t\t     secattr,\n\t\t\t\t\t\t     &buffer[4],\n\t\t\t\t\t\t     buffer_len - 4);\n\t\tif (ret_val < 0)\n\t\t\treturn ret_val;\n\n\t\ttag_len = 4 + ret_val;\n\t} else\n\t\ttag_len = 4;\n\n\tbuffer[0] = CIPSO_V4_TAG_ENUM;\n\tbuffer[1] = tag_len;\n\tbuffer[3] = level;\n\n\treturn tag_len;\n}\n\n \nstatic int cipso_v4_parsetag_enum(const struct cipso_v4_doi *doi_def,\n\t\t\t\t  const unsigned char *tag,\n\t\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tu8 tag_len = tag[1];\n\tu32 level;\n\n\tret_val = cipso_v4_map_lvl_ntoh(doi_def, tag[3], &level);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tsecattr->attr.mls.lvl = level;\n\tsecattr->flags |= NETLBL_SECATTR_MLS_LVL;\n\n\tif (tag_len > 4) {\n\t\tret_val = cipso_v4_map_cat_enum_ntoh(doi_def,\n\t\t\t\t\t\t     &tag[4],\n\t\t\t\t\t\t     tag_len - 4,\n\t\t\t\t\t\t     secattr);\n\t\tif (ret_val != 0) {\n\t\t\tnetlbl_catmap_free(secattr->attr.mls.cat);\n\t\t\treturn ret_val;\n\t\t}\n\n\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cipso_v4_gentag_rng(const struct cipso_v4_doi *doi_def,\n\t\t\t       const struct netlbl_lsm_secattr *secattr,\n\t\t\t       unsigned char *buffer,\n\t\t\t       u32 buffer_len)\n{\n\tint ret_val;\n\tu32 tag_len;\n\tu32 level;\n\n\tif (!(secattr->flags & NETLBL_SECATTR_MLS_LVL))\n\t\treturn -EPERM;\n\n\tret_val = cipso_v4_map_lvl_hton(doi_def,\n\t\t\t\t\tsecattr->attr.mls.lvl,\n\t\t\t\t\t&level);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\tif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\n\t\tret_val = cipso_v4_map_cat_rng_hton(doi_def,\n\t\t\t\t\t\t    secattr,\n\t\t\t\t\t\t    &buffer[4],\n\t\t\t\t\t\t    buffer_len - 4);\n\t\tif (ret_val < 0)\n\t\t\treturn ret_val;\n\n\t\ttag_len = 4 + ret_val;\n\t} else\n\t\ttag_len = 4;\n\n\tbuffer[0] = CIPSO_V4_TAG_RANGE;\n\tbuffer[1] = tag_len;\n\tbuffer[3] = level;\n\n\treturn tag_len;\n}\n\n \nstatic int cipso_v4_parsetag_rng(const struct cipso_v4_doi *doi_def,\n\t\t\t\t const unsigned char *tag,\n\t\t\t\t struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tu8 tag_len = tag[1];\n\tu32 level;\n\n\tret_val = cipso_v4_map_lvl_ntoh(doi_def, tag[3], &level);\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\tsecattr->attr.mls.lvl = level;\n\tsecattr->flags |= NETLBL_SECATTR_MLS_LVL;\n\n\tif (tag_len > 4) {\n\t\tret_val = cipso_v4_map_cat_rng_ntoh(doi_def,\n\t\t\t\t\t\t    &tag[4],\n\t\t\t\t\t\t    tag_len - 4,\n\t\t\t\t\t\t    secattr);\n\t\tif (ret_val != 0) {\n\t\t\tnetlbl_catmap_free(secattr->attr.mls.cat);\n\t\t\treturn ret_val;\n\t\t}\n\n\t\tif (secattr->attr.mls.cat)\n\t\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cipso_v4_gentag_loc(const struct cipso_v4_doi *doi_def,\n\t\t\t       const struct netlbl_lsm_secattr *secattr,\n\t\t\t       unsigned char *buffer,\n\t\t\t       u32 buffer_len)\n{\n\tif (!(secattr->flags & NETLBL_SECATTR_SECID))\n\t\treturn -EPERM;\n\n\tbuffer[0] = CIPSO_V4_TAG_LOCAL;\n\tbuffer[1] = CIPSO_V4_TAG_LOC_BLEN;\n\t*(u32 *)&buffer[2] = secattr->attr.secid;\n\n\treturn CIPSO_V4_TAG_LOC_BLEN;\n}\n\n \nstatic int cipso_v4_parsetag_loc(const struct cipso_v4_doi *doi_def,\n\t\t\t\t const unsigned char *tag,\n\t\t\t\t struct netlbl_lsm_secattr *secattr)\n{\n\tsecattr->attr.secid = *(u32 *)&tag[2];\n\tsecattr->flags |= NETLBL_SECATTR_SECID;\n\n\treturn 0;\n}\n\n \nunsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\tint optlen;\n\tint taglen;\n\n\tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 1; ) {\n\t\tswitch (optptr[0]) {\n\t\tcase IPOPT_END:\n\t\t\treturn NULL;\n\t\tcase IPOPT_NOOP:\n\t\t\ttaglen = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttaglen = optptr[1];\n\t\t}\n\t\tif (!taglen || taglen > optlen)\n\t\t\treturn NULL;\n\t\tif (optptr[0] == IPOPT_CIPSO)\n\t\t\treturn optptr;\n\n\t\toptlen -= taglen;\n\t\toptptr += taglen;\n\t}\n\n\treturn NULL;\n}\n\n \nint cipso_v4_validate(const struct sk_buff *skb, unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char *tag;\n\tunsigned char opt_iter;\n\tunsigned char err_offset = 0;\n\tu8 opt_len;\n\tu8 tag_len;\n\tstruct cipso_v4_doi *doi_def = NULL;\n\tu32 tag_iter;\n\n\t \n\topt_len = opt[1];\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto validate_return;\n\t}\n\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_search(get_unaligned_be32(&opt[2]));\n\tif (!doi_def) {\n\t\terr_offset = 2;\n\t\tgoto validate_return_locked;\n\t}\n\n\topt_iter = CIPSO_V4_HDR_LEN;\n\ttag = opt + opt_iter;\n\twhile (opt_iter < opt_len) {\n\t\tfor (tag_iter = 0; doi_def->tags[tag_iter] != tag[0];)\n\t\t\tif (doi_def->tags[tag_iter] == CIPSO_V4_TAG_INVALID ||\n\t\t\t    ++tag_iter == CIPSO_V4_TAG_MAXCNT) {\n\t\t\t\terr_offset = opt_iter;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\tif (opt_iter + 1 == opt_len) {\n\t\t\terr_offset = opt_iter;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\t\ttag_len = tag[1];\n\t\tif (tag_len > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\tswitch (tag[0]) {\n\t\tcase CIPSO_V4_TAG_RBITMAP:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RBM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (READ_ONCE(cipso_v4_rbm_strictvalid)) {\n\t\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t\tif (tag_len > CIPSO_V4_TAG_RBM_BLEN &&\n\t\t\t\t    cipso_v4_map_cat_rbm_valid(doi_def,\n\t\t\t\t\t\t\t    &tag[4],\n\t\t\t\t\t\t\t    tag_len - 4) < 0) {\n\t\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\t\tgoto validate_return_locked;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_ENUM:\n\t\t\tif (tag_len < CIPSO_V4_TAG_ENUM_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_ENUM_BLEN &&\n\t\t\t    cipso_v4_map_cat_enum_valid(doi_def,\n\t\t\t\t\t\t\t&tag[4],\n\t\t\t\t\t\t\ttag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_RANGE:\n\t\t\tif (tag_len < CIPSO_V4_TAG_RNG_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\n\t\t\tif (cipso_v4_map_lvl_valid(doi_def,\n\t\t\t\t\t\t   tag[3]) < 0) {\n\t\t\t\terr_offset = opt_iter + 3;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len > CIPSO_V4_TAG_RNG_BLEN &&\n\t\t\t    cipso_v4_map_cat_rng_valid(doi_def,\n\t\t\t\t\t\t       &tag[4],\n\t\t\t\t\t\t       tag_len - 4) < 0) {\n\t\t\t\terr_offset = opt_iter + 4;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_LOCAL:\n\t\t\t \n\t\t\tif (!skb || !(skb->dev->flags & IFF_LOOPBACK)) {\n\t\t\t\terr_offset = opt_iter;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tif (tag_len != CIPSO_V4_TAG_LOC_BLEN) {\n\t\t\t\terr_offset = opt_iter + 1;\n\t\t\t\tgoto validate_return_locked;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_offset = opt_iter;\n\t\t\tgoto validate_return_locked;\n\t\t}\n\n\t\ttag += tag_len;\n\t\topt_iter += tag_len;\n\t}\n\nvalidate_return_locked:\n\trcu_read_unlock();\nvalidate_return:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}\n\n \nvoid cipso_v4_error(struct sk_buff *skb, int error, u32 gateway)\n{\n\tunsigned char optbuf[sizeof(struct ip_options) + 40];\n\tstruct ip_options *opt = (struct ip_options *)optbuf;\n\tint res;\n\n\tif (ip_hdr(skb)->protocol == IPPROTO_ICMP || error != -EACCES)\n\t\treturn;\n\n\t \n\n\tmemset(opt, 0, sizeof(struct ip_options));\n\topt->optlen = ip_hdr(skb)->ihl*4 - sizeof(struct iphdr);\n\trcu_read_lock();\n\tres = __ip_options_compile(dev_net(skb->dev), opt, skb, NULL);\n\trcu_read_unlock();\n\n\tif (res)\n\t\treturn;\n\n\tif (gateway)\n\t\t__icmp_send(skb, ICMP_DEST_UNREACH, ICMP_NET_ANO, 0, opt);\n\telse\n\t\t__icmp_send(skb, ICMP_DEST_UNREACH, ICMP_HOST_ANO, 0, opt);\n}\n\n \nstatic int cipso_v4_genopt(unsigned char *buf, u32 buf_len,\n\t\t\t   const struct cipso_v4_doi *doi_def,\n\t\t\t   const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tu32 iter;\n\n\tif (buf_len <= CIPSO_V4_HDR_LEN)\n\t\treturn -ENOSPC;\n\n\t \n\titer = 0;\n\tdo {\n\t\tmemset(buf, 0, buf_len);\n\t\tswitch (doi_def->tags[iter]) {\n\t\tcase CIPSO_V4_TAG_RBITMAP:\n\t\t\tret_val = cipso_v4_gentag_rbm(doi_def,\n\t\t\t\t\t\t   secattr,\n\t\t\t\t\t\t   &buf[CIPSO_V4_HDR_LEN],\n\t\t\t\t\t\t   buf_len - CIPSO_V4_HDR_LEN);\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_ENUM:\n\t\t\tret_val = cipso_v4_gentag_enum(doi_def,\n\t\t\t\t\t\t   secattr,\n\t\t\t\t\t\t   &buf[CIPSO_V4_HDR_LEN],\n\t\t\t\t\t\t   buf_len - CIPSO_V4_HDR_LEN);\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_RANGE:\n\t\t\tret_val = cipso_v4_gentag_rng(doi_def,\n\t\t\t\t\t\t   secattr,\n\t\t\t\t\t\t   &buf[CIPSO_V4_HDR_LEN],\n\t\t\t\t\t\t   buf_len - CIPSO_V4_HDR_LEN);\n\t\t\tbreak;\n\t\tcase CIPSO_V4_TAG_LOCAL:\n\t\t\tret_val = cipso_v4_gentag_loc(doi_def,\n\t\t\t\t\t\t   secattr,\n\t\t\t\t\t\t   &buf[CIPSO_V4_HDR_LEN],\n\t\t\t\t\t\t   buf_len - CIPSO_V4_HDR_LEN);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\titer++;\n\t} while (ret_val < 0 &&\n\t\t iter < CIPSO_V4_TAG_MAXCNT &&\n\t\t doi_def->tags[iter] != CIPSO_V4_TAG_INVALID);\n\tif (ret_val < 0)\n\t\treturn ret_val;\n\tcipso_v4_gentag_hdr(doi_def, buf, ret_val);\n\treturn CIPSO_V4_HDR_LEN + ret_val;\n}\n\n \nint cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t  const struct cipso_v4_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options_rcu *old, *opt = NULL;\n\tstruct inet_sock *sk_inet;\n\tstruct inet_connection_sock *sk_conn;\n\n\t \n\tif (!sk)\n\t\treturn 0;\n\n\t \n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (!buf) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto socket_setattr_failure;\n\tbuf_len = ret_val;\n\n\t \n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (!opt) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tmemcpy(opt->opt.__data, buf, buf_len);\n\topt->opt.optlen = opt_len;\n\topt->opt.cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\n\tsk_inet = inet_sk(sk);\n\n\told = rcu_dereference_protected(sk_inet->inet_opt,\n\t\t\t\t\tlockdep_sock_is_held(sk));\n\tif (inet_test_bit(IS_ICSK, sk)) {\n\t\tsk_conn = inet_csk(sk);\n\t\tif (old)\n\t\t\tsk_conn->icsk_ext_hdr_len -= old->opt.optlen;\n\t\tsk_conn->icsk_ext_hdr_len += opt->opt.optlen;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n\trcu_assign_pointer(sk_inet->inet_opt, opt);\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\treturn 0;\n\nsocket_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}\n\n \nint cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options_rcu *opt = NULL;\n\tstruct inet_request_sock *req_inet;\n\n\t \n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (!buf) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\n\t \n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (!opt) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tmemcpy(opt->opt.__data, buf, buf_len);\n\topt->opt.optlen = opt_len;\n\topt->opt.cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\n\treq_inet = inet_rsk(req);\n\topt = xchg((__force struct ip_options_rcu **)&req_inet->ireq_opt, opt);\n\tif (opt)\n\t\tkfree_rcu(opt, rcu);\n\n\treturn 0;\n\nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}\n\n \nstatic int cipso_v4_delopt(struct ip_options_rcu __rcu **opt_ptr)\n{\n\tstruct ip_options_rcu *opt = rcu_dereference_protected(*opt_ptr, 1);\n\tint hdr_delta = 0;\n\n\tif (!opt || opt->opt.cipso == 0)\n\t\treturn 0;\n\tif (opt->opt.srr || opt->opt.rr || opt->opt.ts || opt->opt.router_alert) {\n\t\tu8 cipso_len;\n\t\tu8 cipso_off;\n\t\tunsigned char *cipso_ptr;\n\t\tint iter;\n\t\tint optlen_new;\n\n\t\tcipso_off = opt->opt.cipso - sizeof(struct iphdr);\n\t\tcipso_ptr = &opt->opt.__data[cipso_off];\n\t\tcipso_len = cipso_ptr[1];\n\n\t\tif (opt->opt.srr > opt->opt.cipso)\n\t\t\topt->opt.srr -= cipso_len;\n\t\tif (opt->opt.rr > opt->opt.cipso)\n\t\t\topt->opt.rr -= cipso_len;\n\t\tif (opt->opt.ts > opt->opt.cipso)\n\t\t\topt->opt.ts -= cipso_len;\n\t\tif (opt->opt.router_alert > opt->opt.cipso)\n\t\t\topt->opt.router_alert -= cipso_len;\n\t\topt->opt.cipso = 0;\n\n\t\tmemmove(cipso_ptr, cipso_ptr + cipso_len,\n\t\t\topt->opt.optlen - cipso_off - cipso_len);\n\n\t\t \n\t\titer = 0;\n\t\toptlen_new = 0;\n\t\twhile (iter < opt->opt.optlen)\n\t\t\tif (opt->opt.__data[iter] != IPOPT_NOP) {\n\t\t\t\titer += opt->opt.__data[iter + 1];\n\t\t\t\toptlen_new = iter;\n\t\t\t} else\n\t\t\t\titer++;\n\t\thdr_delta = opt->opt.optlen;\n\t\topt->opt.optlen = (optlen_new + 3) & ~3;\n\t\thdr_delta -= opt->opt.optlen;\n\t} else {\n\t\t \n\t\t*opt_ptr = NULL;\n\t\thdr_delta = opt->opt.optlen;\n\t\tkfree_rcu(opt, rcu);\n\t}\n\n\treturn hdr_delta;\n}\n\n \nvoid cipso_v4_sock_delattr(struct sock *sk)\n{\n\tstruct inet_sock *sk_inet;\n\tint hdr_delta;\n\n\tsk_inet = inet_sk(sk);\n\n\thdr_delta = cipso_v4_delopt(&sk_inet->inet_opt);\n\tif (inet_test_bit(IS_ICSK, sk) && hdr_delta > 0) {\n\t\tstruct inet_connection_sock *sk_conn = inet_csk(sk);\n\t\tsk_conn->icsk_ext_hdr_len -= hdr_delta;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n}\n\n \nvoid cipso_v4_req_delattr(struct request_sock *req)\n{\n\tcipso_v4_delopt(&inet_rsk(req)->ireq_opt);\n}\n\n \nint cipso_v4_getattr(const unsigned char *cipso,\n\t\t     struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -ENOMSG;\n\tu32 doi;\n\tstruct cipso_v4_doi *doi_def;\n\n\tif (cipso_v4_cache_check(cipso, cipso[1], secattr) == 0)\n\t\treturn 0;\n\n\tdoi = get_unaligned_be32(&cipso[2]);\n\trcu_read_lock();\n\tdoi_def = cipso_v4_doi_search(doi);\n\tif (!doi_def)\n\t\tgoto getattr_return;\n\t \n\tswitch (cipso[6]) {\n\tcase CIPSO_V4_TAG_RBITMAP:\n\t\tret_val = cipso_v4_parsetag_rbm(doi_def, &cipso[6], secattr);\n\t\tbreak;\n\tcase CIPSO_V4_TAG_ENUM:\n\t\tret_val = cipso_v4_parsetag_enum(doi_def, &cipso[6], secattr);\n\t\tbreak;\n\tcase CIPSO_V4_TAG_RANGE:\n\t\tret_val = cipso_v4_parsetag_rng(doi_def, &cipso[6], secattr);\n\t\tbreak;\n\tcase CIPSO_V4_TAG_LOCAL:\n\t\tret_val = cipso_v4_parsetag_loc(doi_def, &cipso[6], secattr);\n\t\tbreak;\n\t}\n\tif (ret_val == 0)\n\t\tsecattr->type = NETLBL_NLTYPE_CIPSOV4;\n\ngetattr_return:\n\trcu_read_unlock();\n\treturn ret_val;\n}\n\n \nint cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n\tstruct ip_options_rcu *opt;\n\tint res = -ENOMSG;\n\n\trcu_read_lock();\n\topt = rcu_dereference(inet_sk(sk)->inet_opt);\n\tif (opt && opt->opt.cipso)\n\t\tres = cipso_v4_getattr(opt->opt.__data +\n\t\t\t\t\t\topt->opt.cipso -\n\t\t\t\t\t\tsizeof(struct iphdr),\n\t\t\t\t       secattr);\n\trcu_read_unlock();\n\treturn res;\n}\n\n \nint cipso_v4_skbuff_setattr(struct sk_buff *skb,\n\t\t\t    const struct cipso_v4_doi *doi_def,\n\t\t\t    const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tstruct iphdr *iph;\n\tstruct ip_options *opt = &IPCB(skb)->opt;\n\tunsigned char buf[CIPSO_V4_OPT_LEN_MAX];\n\tu32 buf_len = CIPSO_V4_OPT_LEN_MAX;\n\tu32 opt_len;\n\tint len_delta;\n\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\treturn ret_val;\n\tbuf_len = ret_val;\n\topt_len = (buf_len + 3) & ~3;\n\n\t \n\n\tlen_delta = opt_len - opt->optlen;\n\t \n\tret_val = skb_cow(skb, skb_headroom(skb) + len_delta);\n\tif (ret_val < 0)\n\t\treturn ret_val;\n\n\tif (len_delta > 0) {\n\t\t \n\t\tiph = ip_hdr(skb);\n\t\tskb_push(skb, len_delta);\n\t\tmemmove((char *)iph - len_delta, iph, iph->ihl << 2);\n\t\tskb_reset_network_header(skb);\n\t\tiph = ip_hdr(skb);\n\t} else if (len_delta < 0) {\n\t\tiph = ip_hdr(skb);\n\t\tmemset(iph + 1, IPOPT_NOP, opt->optlen);\n\t} else\n\t\tiph = ip_hdr(skb);\n\n\tif (opt->optlen > 0)\n\t\tmemset(opt, 0, sizeof(*opt));\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\topt->is_changed = 1;\n\n\t \n\tmemcpy(iph + 1, buf, buf_len);\n\tif (opt_len > buf_len)\n\t\tmemset((char *)(iph + 1) + buf_len, 0, opt_len - buf_len);\n\tif (len_delta != 0) {\n\t\tiph->ihl = 5 + (opt_len >> 2);\n\t\tiph_set_totlen(iph, skb->len);\n\t}\n\tip_send_check(iph);\n\n\treturn 0;\n}\n\n \nint cipso_v4_skbuff_delattr(struct sk_buff *skb)\n{\n\tint ret_val;\n\tstruct iphdr *iph;\n\tstruct ip_options *opt = &IPCB(skb)->opt;\n\tunsigned char *cipso_ptr;\n\n\tif (opt->cipso == 0)\n\t\treturn 0;\n\n\t \n\tret_val = skb_cow(skb, skb_headroom(skb));\n\tif (ret_val < 0)\n\t\treturn ret_val;\n\n\t \n\n\tiph = ip_hdr(skb);\n\tcipso_ptr = (unsigned char *)iph + opt->cipso;\n\tmemset(cipso_ptr, IPOPT_NOOP, cipso_ptr[1]);\n\topt->cipso = 0;\n\topt->is_changed = 1;\n\n\tip_send_check(iph);\n\n\treturn 0;\n}\n\n \n\n \nstatic int __init cipso_v4_init(void)\n{\n\tint ret_val;\n\n\tret_val = cipso_v4_cache_init();\n\tif (ret_val != 0)\n\t\tpanic(\"Failed to initialize the CIPSO/IPv4 cache (%d)\\n\",\n\t\t      ret_val);\n\n\treturn 0;\n}\n\nsubsys_initcall(cipso_v4_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}