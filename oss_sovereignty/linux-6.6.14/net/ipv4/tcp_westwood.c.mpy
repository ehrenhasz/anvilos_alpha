{
  "module_name": "tcp_westwood.c",
  "hash_id": "6ee330270197a0470c7df626be855d7c75501fe107623b71fac121ead3a9c440",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/tcp_westwood.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/inet_diag.h>\n#include <net/tcp.h>\n\n \nstruct westwood {\n\tu32    bw_ns_est;         \n\tu32    bw_est;            \n\tu32    rtt_win_sx;        \n\tu32    bk;\n\tu32    snd_una;           \n\tu32    cumul_ack;\n\tu32    accounted;\n\tu32    rtt;\n\tu32    rtt_min;           \n\tu8     first_ack;         \n\tu8     reset_rtt_min;     \n};\n\n \n#define TCP_WESTWOOD_RTT_MIN   (HZ/20)\t \n#define TCP_WESTWOOD_INIT_RTT  (20*HZ)\t \n\n \nstatic void tcp_westwood_init(struct sock *sk)\n{\n\tstruct westwood *w = inet_csk_ca(sk);\n\n\tw->bk = 0;\n\tw->bw_ns_est = 0;\n\tw->bw_est = 0;\n\tw->accounted = 0;\n\tw->cumul_ack = 0;\n\tw->reset_rtt_min = 1;\n\tw->rtt_min = w->rtt = TCP_WESTWOOD_INIT_RTT;\n\tw->rtt_win_sx = tcp_jiffies32;\n\tw->snd_una = tcp_sk(sk)->snd_una;\n\tw->first_ack = 1;\n}\n\n \nstatic inline u32 westwood_do_filter(u32 a, u32 b)\n{\n\treturn ((7 * a) + b) >> 3;\n}\n\nstatic void westwood_filter(struct westwood *w, u32 delta)\n{\n\t \n\tif (w->bw_ns_est == 0 && w->bw_est == 0) {\n\t\tw->bw_ns_est = w->bk / delta;\n\t\tw->bw_est = w->bw_ns_est;\n\t} else {\n\t\tw->bw_ns_est = westwood_do_filter(w->bw_ns_est, w->bk / delta);\n\t\tw->bw_est = westwood_do_filter(w->bw_est, w->bw_ns_est);\n\t}\n}\n\n \nstatic void tcp_westwood_pkts_acked(struct sock *sk,\n\t\t\t\t    const struct ack_sample *sample)\n{\n\tstruct westwood *w = inet_csk_ca(sk);\n\n\tif (sample->rtt_us > 0)\n\t\tw->rtt = usecs_to_jiffies(sample->rtt_us);\n}\n\n \nstatic void westwood_update_window(struct sock *sk)\n{\n\tstruct westwood *w = inet_csk_ca(sk);\n\ts32 delta = tcp_jiffies32 - w->rtt_win_sx;\n\n\t \n\tif (w->first_ack) {\n\t\tw->snd_una = tcp_sk(sk)->snd_una;\n\t\tw->first_ack = 0;\n\t}\n\n\t \n\tif (w->rtt && delta > max_t(u32, w->rtt, TCP_WESTWOOD_RTT_MIN)) {\n\t\twestwood_filter(w, delta);\n\n\t\tw->bk = 0;\n\t\tw->rtt_win_sx = tcp_jiffies32;\n\t}\n}\n\nstatic inline void update_rtt_min(struct westwood *w)\n{\n\tif (w->reset_rtt_min) {\n\t\tw->rtt_min = w->rtt;\n\t\tw->reset_rtt_min = 0;\n\t} else\n\t\tw->rtt_min = min(w->rtt, w->rtt_min);\n}\n\n \nstatic inline void westwood_fast_bw(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct westwood *w = inet_csk_ca(sk);\n\n\twestwood_update_window(sk);\n\n\tw->bk += tp->snd_una - w->snd_una;\n\tw->snd_una = tp->snd_una;\n\tupdate_rtt_min(w);\n}\n\n \nstatic inline u32 westwood_acked_count(struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tstruct westwood *w = inet_csk_ca(sk);\n\n\tw->cumul_ack = tp->snd_una - w->snd_una;\n\n\t \n\tif (!w->cumul_ack) {\n\t\tw->accounted += tp->mss_cache;\n\t\tw->cumul_ack = tp->mss_cache;\n\t}\n\n\tif (w->cumul_ack > tp->mss_cache) {\n\t\t \n\t\tif (w->accounted >= w->cumul_ack) {\n\t\t\tw->accounted -= w->cumul_ack;\n\t\t\tw->cumul_ack = tp->mss_cache;\n\t\t} else {\n\t\t\tw->cumul_ack -= w->accounted;\n\t\t\tw->accounted = 0;\n\t\t}\n\t}\n\n\tw->snd_una = tp->snd_una;\n\n\treturn w->cumul_ack;\n}\n\n \nstatic u32 tcp_westwood_bw_rttmin(const struct sock *sk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct westwood *w = inet_csk_ca(sk);\n\n\treturn max_t(u32, (w->bw_est * w->rtt_min) / tp->mss_cache, 2);\n}\n\nstatic void tcp_westwood_ack(struct sock *sk, u32 ack_flags)\n{\n\tif (ack_flags & CA_ACK_SLOWPATH) {\n\t\tstruct westwood *w = inet_csk_ca(sk);\n\n\t\twestwood_update_window(sk);\n\t\tw->bk += westwood_acked_count(sk);\n\n\t\tupdate_rtt_min(w);\n\t\treturn;\n\t}\n\n\twestwood_fast_bw(sk);\n}\n\nstatic void tcp_westwood_event(struct sock *sk, enum tcp_ca_event event)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct westwood *w = inet_csk_ca(sk);\n\n\tswitch (event) {\n\tcase CA_EVENT_COMPLETE_CWR:\n\t\ttp->snd_ssthresh = tcp_westwood_bw_rttmin(sk);\n\t\ttcp_snd_cwnd_set(tp, tp->snd_ssthresh);\n\t\tbreak;\n\tcase CA_EVENT_LOSS:\n\t\ttp->snd_ssthresh = tcp_westwood_bw_rttmin(sk);\n\t\t \n\t\tw->reset_rtt_min = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\n \nstatic size_t tcp_westwood_info(struct sock *sk, u32 ext, int *attr,\n\t\t\t\tunion tcp_cc_info *info)\n{\n\tconst struct westwood *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tinfo->vegas.tcpv_enabled = 1;\n\t\tinfo->vegas.tcpv_rttcnt\t= 0;\n\t\tinfo->vegas.tcpv_rtt\t= jiffies_to_usecs(ca->rtt);\n\t\tinfo->vegas.tcpv_minrtt\t= jiffies_to_usecs(ca->rtt_min);\n\n\t\t*attr = INET_DIAG_VEGASINFO;\n\t\treturn sizeof(struct tcpvegas_info);\n\t}\n\treturn 0;\n}\n\nstatic struct tcp_congestion_ops tcp_westwood __read_mostly = {\n\t.init\t\t= tcp_westwood_init,\n\t.ssthresh\t= tcp_reno_ssthresh,\n\t.cong_avoid\t= tcp_reno_cong_avoid,\n\t.undo_cwnd      = tcp_reno_undo_cwnd,\n\t.cwnd_event\t= tcp_westwood_event,\n\t.in_ack_event\t= tcp_westwood_ack,\n\t.get_info\t= tcp_westwood_info,\n\t.pkts_acked\t= tcp_westwood_pkts_acked,\n\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"westwood\"\n};\n\nstatic int __init tcp_westwood_register(void)\n{\n\tBUILD_BUG_ON(sizeof(struct westwood) > ICSK_CA_PRIV_SIZE);\n\treturn tcp_register_congestion_control(&tcp_westwood);\n}\n\nstatic void __exit tcp_westwood_unregister(void)\n{\n\ttcp_unregister_congestion_control(&tcp_westwood);\n}\n\nmodule_init(tcp_westwood_register);\nmodule_exit(tcp_westwood_unregister);\n\nMODULE_AUTHOR(\"Stephen Hemminger, Angelo Dell'Aera\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"TCP Westwood+\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}