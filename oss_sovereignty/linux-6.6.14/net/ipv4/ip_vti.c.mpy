{
  "module_name": "ip_vti.c",
  "hash_id": "d1a0db11cbcb474810a5e411c2aff1ba4eb85c6245b6343824cf7d701a85d2b8",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv4/ip_vti.c",
  "human_readable_source": "\n \n\n \n\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/if_ether.h>\n#include <linux/icmpv6.h>\n\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/ip_tunnels.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\nstatic struct rtnl_link_ops vti_link_ops __read_mostly;\n\nstatic unsigned int vti_net_id __read_mostly;\nstatic int vti_tunnel_init(struct net_device *dev);\n\nstatic int vti_input(struct sk_buff *skb, int nexthdr, __be32 spi,\n\t\t     int encap_type, bool update_skb_dev)\n{\n\tstruct ip_tunnel *tunnel;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct ip_tunnel_net *itn = net_generic(net, vti_net_id);\n\n\ttunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,\n\t\t\t\t  iph->saddr, iph->daddr, 0);\n\tif (tunnel) {\n\t\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\t\tgoto drop;\n\n\t\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = tunnel;\n\n\t\tif (update_skb_dev)\n\t\t\tskb->dev = tunnel->dev;\n\n\t\treturn xfrm_input(skb, nexthdr, spi, encap_type);\n\t}\n\n\treturn -EINVAL;\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int vti_input_proto(struct sk_buff *skb, int nexthdr, __be32 spi,\n\t\t\t   int encap_type)\n{\n\treturn vti_input(skb, nexthdr, spi, encap_type, false);\n}\n\nstatic int vti_rcv(struct sk_buff *skb, __be32 spi, bool update_skb_dev)\n{\n\tXFRM_SPI_SKB_CB(skb)->family = AF_INET;\n\tXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);\n\n\treturn vti_input(skb, ip_hdr(skb)->protocol, spi, 0, update_skb_dev);\n}\n\nstatic int vti_rcv_proto(struct sk_buff *skb)\n{\n\treturn vti_rcv(skb, 0, false);\n}\n\nstatic int vti_rcv_cb(struct sk_buff *skb, int err)\n{\n\tunsigned short family;\n\tstruct net_device *dev;\n\tstruct xfrm_state *x;\n\tconst struct xfrm_mode *inner_mode;\n\tstruct ip_tunnel *tunnel = XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4;\n\tu32 orig_mark = skb->mark;\n\tint ret;\n\n\tif (!tunnel)\n\t\treturn 1;\n\n\tdev = tunnel->dev;\n\n\tif (err) {\n\t\tDEV_STATS_INC(dev, rx_errors);\n\t\tDEV_STATS_INC(dev, rx_dropped);\n\n\t\treturn 0;\n\t}\n\n\tx = xfrm_input_state(skb);\n\n\tinner_mode = &x->inner_mode;\n\n\tif (x->sel.family == AF_UNSPEC) {\n\t\tinner_mode = xfrm_ip2inner_mode(x, XFRM_MODE_SKB_CB(skb)->protocol);\n\t\tif (inner_mode == NULL) {\n\t\t\tXFRM_INC_STATS(dev_net(skb->dev),\n\t\t\t\t       LINUX_MIB_XFRMINSTATEMODEERROR);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfamily = inner_mode->family;\n\n\tskb->mark = be32_to_cpu(tunnel->parms.i_key);\n\tret = xfrm_policy_check(NULL, XFRM_POLICY_IN, skb, family);\n\tskb->mark = orig_mark;\n\n\tif (!ret)\n\t\treturn -EPERM;\n\n\tskb_scrub_packet(skb, !net_eq(tunnel->net, dev_net(skb->dev)));\n\tskb->dev = dev;\n\tdev_sw_netstats_rx_add(dev, skb->len);\n\n\treturn 0;\n}\n\nstatic bool vti_state_check(const struct xfrm_state *x, __be32 dst, __be32 src)\n{\n\txfrm_address_t *daddr = (xfrm_address_t *)&dst;\n\txfrm_address_t *saddr = (xfrm_address_t *)&src;\n\n\t \n\tif (!x || x->props.mode != XFRM_MODE_TUNNEL ||\n\t    x->props.family != AF_INET)\n\t\treturn false;\n\n\tif (!dst)\n\t\treturn xfrm_addr_equal(saddr, &x->props.saddr, AF_INET);\n\n\tif (!xfrm_state_addr_check(x, daddr, saddr, AF_INET))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic netdev_tx_t vti_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t\t    struct flowi *fl)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct ip_tunnel_parm *parms = &tunnel->parms;\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net_device *tdev;\t \n\tint pkt_len = skb->len;\n\tint err;\n\tint mtu;\n\n\tif (!dst) {\n\t\tswitch (skb->protocol) {\n\t\tcase htons(ETH_P_IP): {\n\t\t\tstruct rtable *rt;\n\n\t\t\tfl->u.ip4.flowi4_oif = dev->ifindex;\n\t\t\tfl->u.ip4.flowi4_flags |= FLOWI_FLAG_ANYSRC;\n\t\t\trt = __ip_route_output_key(dev_net(dev), &fl->u.ip4);\n\t\t\tif (IS_ERR(rt)) {\n\t\t\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\t\t\tgoto tx_error_icmp;\n\t\t\t}\n\t\t\tdst = &rt->dst;\n\t\t\tskb_dst_set(skb, dst);\n\t\t\tbreak;\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tfl->u.ip6.flowi6_oif = dev->ifindex;\n\t\t\tfl->u.ip6.flowi6_flags |= FLOWI_FLAG_ANYSRC;\n\t\t\tdst = ip6_route_output(dev_net(dev), NULL, &fl->u.ip6);\n\t\t\tif (dst->error) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tdst = NULL;\n\t\t\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\t\t\tgoto tx_error_icmp;\n\t\t\t}\n\t\t\tskb_dst_set(skb, dst);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\t\tgoto tx_error_icmp;\n\t\t}\n\t}\n\n\tdst_hold(dst);\n\tdst = xfrm_lookup_route(tunnel->net, dst, fl, NULL, 0);\n\tif (IS_ERR(dst)) {\n\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\tgoto tx_error_icmp;\n\t}\n\n\tif (dst->flags & DST_XFRM_QUEUE)\n\t\tgoto xmit;\n\n\tif (!vti_state_check(dst->xfrm, parms->iph.daddr, parms->iph.saddr)) {\n\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\tdst_release(dst);\n\t\tgoto tx_error_icmp;\n\t}\n\n\ttdev = dst->dev;\n\n\tif (tdev == dev) {\n\t\tdst_release(dst);\n\t\tDEV_STATS_INC(dev, collisions);\n\t\tgoto tx_error;\n\t}\n\n\tmtu = dst_mtu(dst);\n\tif (skb->len > mtu) {\n\t\tskb_dst_update_pmtu_no_confirm(skb, mtu);\n\t\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t\tif (!(ip_hdr(skb)->frag_off & htons(IP_DF)))\n\t\t\t\tgoto xmit;\n\t\t\ticmp_ndo_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\n\t\t\t\t      htonl(mtu));\n\t\t} else {\n\t\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\t\tmtu = IPV6_MIN_MTU;\n\n\t\t\ticmpv6_ndo_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\t}\n\n\t\tdst_release(dst);\n\t\tgoto tx_error;\n\t}\n\nxmit:\n\tskb_scrub_packet(skb, !net_eq(tunnel->net, dev_net(dev)));\n\tskb_dst_set(skb, dst);\n\tskb->dev = skb_dst(skb)->dev;\n\n\terr = dst_output(tunnel->net, skb->sk, skb);\n\tif (net_xmit_eval(err) == 0)\n\t\terr = pkt_len;\n\tiptunnel_xmit_stats(dev, err);\n\treturn NETDEV_TX_OK;\n\ntx_error_icmp:\n\tdst_link_failure(skb);\ntx_error:\n\tDEV_STATS_INC(dev, tx_errors);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic netdev_tx_t vti_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct flowi fl;\n\n\tif (!pskb_inet_may_pull(skb))\n\t\tgoto tx_err;\n\n\tmemset(&fl, 0, sizeof(fl));\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\n\t\txfrm_decode_session(skb, &fl, AF_INET);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tmemset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));\n\t\txfrm_decode_session(skb, &fl, AF_INET6);\n\t\tbreak;\n\tdefault:\n\t\tgoto tx_err;\n\t}\n\n\t \n\tfl.flowi_mark = be32_to_cpu(tunnel->parms.o_key);\n\n\treturn vti_xmit(skb, dev, &fl);\n\ntx_err:\n\tDEV_STATS_INC(dev, tx_errors);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int vti4_err(struct sk_buff *skb, u32 info)\n{\n\t__be32 spi;\n\t__u32 mark;\n\tstruct xfrm_state *x;\n\tstruct ip_tunnel *tunnel;\n\tstruct ip_esp_hdr *esph;\n\tstruct ip_auth_hdr *ah ;\n\tstruct ip_comp_hdr *ipch;\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\tint protocol = iph->protocol;\n\tstruct ip_tunnel_net *itn = net_generic(net, vti_net_id);\n\n\ttunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,\n\t\t\t\t  iph->daddr, iph->saddr, 0);\n\tif (!tunnel)\n\t\treturn -1;\n\n\tmark = be32_to_cpu(tunnel->parms.o_key);\n\n\tswitch (protocol) {\n\tcase IPPROTO_ESP:\n\t\tesph = (struct ip_esp_hdr *)(skb->data+(iph->ihl<<2));\n\t\tspi = esph->spi;\n\t\tbreak;\n\tcase IPPROTO_AH:\n\t\tah = (struct ip_auth_hdr *)(skb->data+(iph->ihl<<2));\n\t\tspi = ah->spi;\n\t\tbreak;\n\tcase IPPROTO_COMP:\n\t\tipch = (struct ip_comp_hdr *)(skb->data+(iph->ihl<<2));\n\t\tspi = htonl(ntohs(ipch->cpi));\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tswitch (icmp_hdr(skb)->type) {\n\tcase ICMP_DEST_UNREACH:\n\t\tif (icmp_hdr(skb)->code != ICMP_FRAG_NEEDED)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase ICMP_REDIRECT:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tx = xfrm_state_lookup(net, mark, (const xfrm_address_t *)&iph->daddr,\n\t\t\t      spi, protocol, AF_INET);\n\tif (!x)\n\t\treturn 0;\n\n\tif (icmp_hdr(skb)->type == ICMP_DEST_UNREACH)\n\t\tipv4_update_pmtu(skb, net, info, 0, protocol);\n\telse\n\t\tipv4_redirect(skb, net, 0, protocol);\n\txfrm_state_put(x);\n\n\treturn 0;\n}\n\nstatic int\nvti_tunnel_ctl(struct net_device *dev, struct ip_tunnel_parm *p, int cmd)\n{\n\tint err = 0;\n\n\tif (cmd == SIOCADDTUNNEL || cmd == SIOCCHGTUNNEL) {\n\t\tif (p->iph.version != 4 || p->iph.protocol != IPPROTO_IPIP ||\n\t\t    p->iph.ihl != 5)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!(p->i_flags & GRE_KEY))\n\t\tp->i_key = 0;\n\tif (!(p->o_flags & GRE_KEY))\n\t\tp->o_key = 0;\n\n\tp->i_flags = VTI_ISVTI;\n\n\terr = ip_tunnel_ctl(dev, p, cmd);\n\tif (err)\n\t\treturn err;\n\n\tif (cmd != SIOCDELTUNNEL) {\n\t\tp->i_flags |= GRE_KEY;\n\t\tp->o_flags |= GRE_KEY;\n\t}\n\treturn 0;\n}\n\nstatic const struct net_device_ops vti_netdev_ops = {\n\t.ndo_init\t= vti_tunnel_init,\n\t.ndo_uninit\t= ip_tunnel_uninit,\n\t.ndo_start_xmit\t= vti_tunnel_xmit,\n\t.ndo_siocdevprivate = ip_tunnel_siocdevprivate,\n\t.ndo_change_mtu\t= ip_tunnel_change_mtu,\n\t.ndo_get_stats64 = dev_get_tstats64,\n\t.ndo_get_iflink = ip_tunnel_get_iflink,\n\t.ndo_tunnel_ctl\t= vti_tunnel_ctl,\n};\n\nstatic void vti_tunnel_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t\t= &vti_netdev_ops;\n\tdev->header_ops\t\t= &ip_tunnel_header_ops;\n\tdev->type\t\t= ARPHRD_TUNNEL;\n\tip_tunnel_setup(dev, vti_net_id);\n}\n\nstatic int vti_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct iphdr *iph = &tunnel->parms.iph;\n\n\t__dev_addr_set(dev, &iph->saddr, 4);\n\tmemcpy(dev->broadcast, &iph->daddr, 4);\n\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->addr_len\t\t= 4;\n\tdev->features\t\t|= NETIF_F_LLTX;\n\tnetif_keep_dst(dev);\n\n\treturn ip_tunnel_init(dev);\n}\n\nstatic void __net_init vti_fb_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct iphdr *iph = &tunnel->parms.iph;\n\n\tiph->version\t\t= 4;\n\tiph->protocol\t\t= IPPROTO_IPIP;\n\tiph->ihl\t\t= 5;\n}\n\nstatic struct xfrm4_protocol vti_esp4_protocol __read_mostly = {\n\t.handler\t=\tvti_rcv_proto,\n\t.input_handler\t=\tvti_input_proto,\n\t.cb_handler\t=\tvti_rcv_cb,\n\t.err_handler\t=\tvti4_err,\n\t.priority\t=\t100,\n};\n\nstatic struct xfrm4_protocol vti_ah4_protocol __read_mostly = {\n\t.handler\t=\tvti_rcv_proto,\n\t.input_handler\t=\tvti_input_proto,\n\t.cb_handler\t=\tvti_rcv_cb,\n\t.err_handler\t=\tvti4_err,\n\t.priority\t=\t100,\n};\n\nstatic struct xfrm4_protocol vti_ipcomp4_protocol __read_mostly = {\n\t.handler\t=\tvti_rcv_proto,\n\t.input_handler\t=\tvti_input_proto,\n\t.cb_handler\t=\tvti_rcv_cb,\n\t.err_handler\t=\tvti4_err,\n\t.priority\t=\t100,\n};\n\n#if IS_ENABLED(CONFIG_INET_XFRM_TUNNEL)\nstatic int vti_rcv_tunnel(struct sk_buff *skb)\n{\n\tXFRM_SPI_SKB_CB(skb)->family = AF_INET;\n\tXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);\n\n\treturn vti_input(skb, IPPROTO_IPIP, ip_hdr(skb)->saddr, 0, false);\n}\n\nstatic struct xfrm_tunnel vti_ipip_handler __read_mostly = {\n\t.handler\t=\tvti_rcv_tunnel,\n\t.cb_handler\t=\tvti_rcv_cb,\n\t.err_handler\t=\tvti4_err,\n\t.priority\t=\t0,\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct xfrm_tunnel vti_ipip6_handler __read_mostly = {\n\t.handler\t=\tvti_rcv_tunnel,\n\t.cb_handler\t=\tvti_rcv_cb,\n\t.err_handler\t=\tvti4_err,\n\t.priority\t=\t0,\n};\n#endif\n#endif\n\nstatic int __net_init vti_init_net(struct net *net)\n{\n\tint err;\n\tstruct ip_tunnel_net *itn;\n\n\terr = ip_tunnel_init_net(net, vti_net_id, &vti_link_ops, \"ip_vti0\");\n\tif (err)\n\t\treturn err;\n\titn = net_generic(net, vti_net_id);\n\tif (itn->fb_tunnel_dev)\n\t\tvti_fb_tunnel_init(itn->fb_tunnel_dev);\n\treturn 0;\n}\n\nstatic void __net_exit vti_exit_batch_net(struct list_head *list_net)\n{\n\tip_tunnel_delete_nets(list_net, vti_net_id, &vti_link_ops);\n}\n\nstatic struct pernet_operations vti_net_ops = {\n\t.init = vti_init_net,\n\t.exit_batch = vti_exit_batch_net,\n\t.id   = &vti_net_id,\n\t.size = sizeof(struct ip_tunnel_net),\n};\n\nstatic int vti_tunnel_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn 0;\n}\n\nstatic void vti_netlink_parms(struct nlattr *data[],\n\t\t\t      struct ip_tunnel_parm *parms,\n\t\t\t      __u32 *fwmark)\n{\n\tmemset(parms, 0, sizeof(*parms));\n\n\tparms->iph.protocol = IPPROTO_IPIP;\n\n\tif (!data)\n\t\treturn;\n\n\tparms->i_flags = VTI_ISVTI;\n\n\tif (data[IFLA_VTI_LINK])\n\t\tparms->link = nla_get_u32(data[IFLA_VTI_LINK]);\n\n\tif (data[IFLA_VTI_IKEY])\n\t\tparms->i_key = nla_get_be32(data[IFLA_VTI_IKEY]);\n\n\tif (data[IFLA_VTI_OKEY])\n\t\tparms->o_key = nla_get_be32(data[IFLA_VTI_OKEY]);\n\n\tif (data[IFLA_VTI_LOCAL])\n\t\tparms->iph.saddr = nla_get_in_addr(data[IFLA_VTI_LOCAL]);\n\n\tif (data[IFLA_VTI_REMOTE])\n\t\tparms->iph.daddr = nla_get_in_addr(data[IFLA_VTI_REMOTE]);\n\n\tif (data[IFLA_VTI_FWMARK])\n\t\t*fwmark = nla_get_u32(data[IFLA_VTI_FWMARK]);\n}\n\nstatic int vti_newlink(struct net *src_net, struct net_device *dev,\n\t\t       struct nlattr *tb[], struct nlattr *data[],\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct ip_tunnel_parm parms;\n\t__u32 fwmark = 0;\n\n\tvti_netlink_parms(data, &parms, &fwmark);\n\treturn ip_tunnel_newlink(dev, tb, &parms, fwmark);\n}\n\nstatic int vti_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t  struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\t__u32 fwmark = t->fwmark;\n\tstruct ip_tunnel_parm p;\n\n\tvti_netlink_parms(data, &p, &fwmark);\n\treturn ip_tunnel_changelink(dev, tb, &p, fwmark);\n}\n\nstatic size_t vti_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t0;\n}\n\nstatic int vti_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_parm *p = &t->parms;\n\n\tif (nla_put_u32(skb, IFLA_VTI_LINK, p->link) ||\n\t    nla_put_be32(skb, IFLA_VTI_IKEY, p->i_key) ||\n\t    nla_put_be32(skb, IFLA_VTI_OKEY, p->o_key) ||\n\t    nla_put_in_addr(skb, IFLA_VTI_LOCAL, p->iph.saddr) ||\n\t    nla_put_in_addr(skb, IFLA_VTI_REMOTE, p->iph.daddr) ||\n\t    nla_put_u32(skb, IFLA_VTI_FWMARK, t->fwmark))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic const struct nla_policy vti_policy[IFLA_VTI_MAX + 1] = {\n\t[IFLA_VTI_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_VTI_IKEY]\t\t= { .type = NLA_U32 },\n\t[IFLA_VTI_OKEY]\t\t= { .type = NLA_U32 },\n\t[IFLA_VTI_LOCAL]\t= { .len = sizeof_field(struct iphdr, saddr) },\n\t[IFLA_VTI_REMOTE]\t= { .len = sizeof_field(struct iphdr, daddr) },\n\t[IFLA_VTI_FWMARK]\t= { .type = NLA_U32 },\n};\n\nstatic struct rtnl_link_ops vti_link_ops __read_mostly = {\n\t.kind\t\t= \"vti\",\n\t.maxtype\t= IFLA_VTI_MAX,\n\t.policy\t\t= vti_policy,\n\t.priv_size\t= sizeof(struct ip_tunnel),\n\t.setup\t\t= vti_tunnel_setup,\n\t.validate\t= vti_tunnel_validate,\n\t.newlink\t= vti_newlink,\n\t.changelink\t= vti_changelink,\n\t.dellink        = ip_tunnel_dellink,\n\t.get_size\t= vti_get_size,\n\t.fill_info\t= vti_fill_info,\n\t.get_link_net\t= ip_tunnel_get_link_net,\n};\n\nstatic int __init vti_init(void)\n{\n\tconst char *msg;\n\tint err;\n\n\tpr_info(\"IPv4 over IPsec tunneling driver\\n\");\n\n\tmsg = \"tunnel device\";\n\terr = register_pernet_device(&vti_net_ops);\n\tif (err < 0)\n\t\tgoto pernet_dev_failed;\n\n\tmsg = \"tunnel protocols\";\n\terr = xfrm4_protocol_register(&vti_esp4_protocol, IPPROTO_ESP);\n\tif (err < 0)\n\t\tgoto xfrm_proto_esp_failed;\n\terr = xfrm4_protocol_register(&vti_ah4_protocol, IPPROTO_AH);\n\tif (err < 0)\n\t\tgoto xfrm_proto_ah_failed;\n\terr = xfrm4_protocol_register(&vti_ipcomp4_protocol, IPPROTO_COMP);\n\tif (err < 0)\n\t\tgoto xfrm_proto_comp_failed;\n\n#if IS_ENABLED(CONFIG_INET_XFRM_TUNNEL)\n\tmsg = \"ipip tunnel\";\n\terr = xfrm4_tunnel_register(&vti_ipip_handler, AF_INET);\n\tif (err < 0)\n\t\tgoto xfrm_tunnel_ipip_failed;\n#if IS_ENABLED(CONFIG_IPV6)\n\terr = xfrm4_tunnel_register(&vti_ipip6_handler, AF_INET6);\n\tif (err < 0)\n\t\tgoto xfrm_tunnel_ipip6_failed;\n#endif\n#endif\n\n\tmsg = \"netlink interface\";\n\terr = rtnl_link_register(&vti_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\n\treturn err;\n\nrtnl_link_failed:\n#if IS_ENABLED(CONFIG_INET_XFRM_TUNNEL)\n#if IS_ENABLED(CONFIG_IPV6)\n\txfrm4_tunnel_deregister(&vti_ipip6_handler, AF_INET6);\nxfrm_tunnel_ipip6_failed:\n#endif\n\txfrm4_tunnel_deregister(&vti_ipip_handler, AF_INET);\nxfrm_tunnel_ipip_failed:\n#endif\n\txfrm4_protocol_deregister(&vti_ipcomp4_protocol, IPPROTO_COMP);\nxfrm_proto_comp_failed:\n\txfrm4_protocol_deregister(&vti_ah4_protocol, IPPROTO_AH);\nxfrm_proto_ah_failed:\n\txfrm4_protocol_deregister(&vti_esp4_protocol, IPPROTO_ESP);\nxfrm_proto_esp_failed:\n\tunregister_pernet_device(&vti_net_ops);\npernet_dev_failed:\n\tpr_err(\"vti init: failed to register %s\\n\", msg);\n\treturn err;\n}\n\nstatic void __exit vti_fini(void)\n{\n\trtnl_link_unregister(&vti_link_ops);\n#if IS_ENABLED(CONFIG_INET_XFRM_TUNNEL)\n#if IS_ENABLED(CONFIG_IPV6)\n\txfrm4_tunnel_deregister(&vti_ipip6_handler, AF_INET6);\n#endif\n\txfrm4_tunnel_deregister(&vti_ipip_handler, AF_INET);\n#endif\n\txfrm4_protocol_deregister(&vti_ipcomp4_protocol, IPPROTO_COMP);\n\txfrm4_protocol_deregister(&vti_ah4_protocol, IPPROTO_AH);\n\txfrm4_protocol_deregister(&vti_esp4_protocol, IPPROTO_ESP);\n\tunregister_pernet_device(&vti_net_ops);\n}\n\nmodule_init(vti_init);\nmodule_exit(vti_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(\"vti\");\nMODULE_ALIAS_NETDEV(\"ip_vti0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}