{
  "module_name": "conn_object.c",
  "hash_id": "698e1da8f26b6cb8295c6c9b4e9bba45764a5ac89faac1816b451968b0c49132",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/conn_object.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include \"ar-internal.h\"\n\n \nunsigned int __read_mostly rxrpc_connection_expiry = 10 * 60;\nunsigned int __read_mostly rxrpc_closed_conn_expiry = 10;\n\nstatic void rxrpc_clean_up_connection(struct work_struct *work);\nstatic void rxrpc_set_service_reap_timer(struct rxrpc_net *rxnet,\n\t\t\t\t\t unsigned long reap_at);\n\nvoid rxrpc_poke_conn(struct rxrpc_connection *conn, enum rxrpc_conn_trace why)\n{\n\tstruct rxrpc_local *local = conn->local;\n\tbool busy;\n\n\tif (WARN_ON_ONCE(!local))\n\t\treturn;\n\n\tspin_lock_bh(&local->lock);\n\tbusy = !list_empty(&conn->attend_link);\n\tif (!busy) {\n\t\trxrpc_get_connection(conn, why);\n\t\tlist_add_tail(&conn->attend_link, &local->conn_attend_q);\n\t}\n\tspin_unlock_bh(&local->lock);\n\trxrpc_wake_up_io_thread(local);\n}\n\nstatic void rxrpc_connection_timer(struct timer_list *timer)\n{\n\tstruct rxrpc_connection *conn =\n\t\tcontainer_of(timer, struct rxrpc_connection, timer);\n\n\trxrpc_poke_conn(conn, rxrpc_conn_get_poke_timer);\n}\n\n \nstruct rxrpc_connection *rxrpc_alloc_connection(struct rxrpc_net *rxnet,\n\t\t\t\t\t\tgfp_t gfp)\n{\n\tstruct rxrpc_connection *conn;\n\n\t_enter(\"\");\n\n\tconn = kzalloc(sizeof(struct rxrpc_connection), gfp);\n\tif (conn) {\n\t\tINIT_LIST_HEAD(&conn->cache_link);\n\t\ttimer_setup(&conn->timer, &rxrpc_connection_timer, 0);\n\t\tINIT_WORK(&conn->processor, rxrpc_process_connection);\n\t\tINIT_WORK(&conn->destructor, rxrpc_clean_up_connection);\n\t\tINIT_LIST_HEAD(&conn->proc_link);\n\t\tINIT_LIST_HEAD(&conn->link);\n\t\tmutex_init(&conn->security_lock);\n\t\tskb_queue_head_init(&conn->rx_queue);\n\t\tconn->rxnet = rxnet;\n\t\tconn->security = &rxrpc_no_security;\n\t\tspin_lock_init(&conn->state_lock);\n\t\tconn->debug_id = atomic_inc_return(&rxrpc_debug_id);\n\t\tconn->idle_timestamp = jiffies;\n\t}\n\n\t_leave(\" = %p{%d}\", conn, conn ? conn->debug_id : 0);\n\treturn conn;\n}\n\n \nstruct rxrpc_connection *rxrpc_find_client_connection_rcu(struct rxrpc_local *local,\n\t\t\t\t\t\t\t  struct sockaddr_rxrpc *srx,\n\t\t\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct rxrpc_connection *conn;\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tstruct rxrpc_peer *peer;\n\n\t_enter(\",%x\", sp->hdr.cid & RXRPC_CIDMASK);\n\n\t \n\tconn = idr_find(&local->conn_ids, sp->hdr.cid >> RXRPC_CIDSHIFT);\n\tif (!conn || refcount_read(&conn->ref) == 0) {\n\t\t_debug(\"no conn\");\n\t\tgoto not_found;\n\t}\n\n\tif (conn->proto.epoch != sp->hdr.epoch ||\n\t    conn->local != local)\n\t\tgoto not_found;\n\n\tpeer = conn->peer;\n\tswitch (srx->transport.family) {\n\tcase AF_INET:\n\t\tif (peer->srx.transport.sin.sin_port !=\n\t\t    srx->transport.sin.sin_port ||\n\t\t    peer->srx.transport.sin.sin_addr.s_addr !=\n\t\t    srx->transport.sin.sin_addr.s_addr)\n\t\t\tgoto not_found;\n\t\tbreak;\n#ifdef CONFIG_AF_RXRPC_IPV6\n\tcase AF_INET6:\n\t\tif (peer->srx.transport.sin6.sin6_port !=\n\t\t    srx->transport.sin6.sin6_port ||\n\t\t    memcmp(&peer->srx.transport.sin6.sin6_addr,\n\t\t\t   &srx->transport.sin6.sin6_addr,\n\t\t\t   sizeof(struct in6_addr)) != 0)\n\t\t\tgoto not_found;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tBUG();\n\t}\n\n\t_leave(\" = %p\", conn);\n\treturn conn;\n\nnot_found:\n\t_leave(\" = NULL\");\n\treturn NULL;\n}\n\n \nvoid __rxrpc_disconnect_call(struct rxrpc_connection *conn,\n\t\t\t     struct rxrpc_call *call)\n{\n\tstruct rxrpc_channel *chan =\n\t\t&conn->channels[call->cid & RXRPC_CHANNELMASK];\n\n\t_enter(\"%d,%x\", conn->debug_id, call->cid);\n\n\tif (chan->call == call) {\n\t\t \n\t\ttrace_rxrpc_disconnect_call(call);\n\t\tswitch (call->completion) {\n\t\tcase RXRPC_CALL_SUCCEEDED:\n\t\t\tchan->last_seq = call->rx_highest_seq;\n\t\t\tchan->last_type = RXRPC_PACKET_TYPE_ACK;\n\t\t\tbreak;\n\t\tcase RXRPC_CALL_LOCALLY_ABORTED:\n\t\t\tchan->last_abort = call->abort_code;\n\t\t\tchan->last_type = RXRPC_PACKET_TYPE_ABORT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tchan->last_abort = RX_CALL_DEAD;\n\t\t\tchan->last_type = RXRPC_PACKET_TYPE_ABORT;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->last_call = chan->call_id;\n\t\tchan->call_id = chan->call_counter;\n\t\tchan->call = NULL;\n\t}\n\n\t_leave(\"\");\n}\n\n \nvoid rxrpc_disconnect_call(struct rxrpc_call *call)\n{\n\tstruct rxrpc_connection *conn = call->conn;\n\n\tset_bit(RXRPC_CALL_DISCONNECTED, &call->flags);\n\trxrpc_see_call(call, rxrpc_call_see_disconnected);\n\n\tcall->peer->cong_ssthresh = call->cong_ssthresh;\n\n\tif (!hlist_unhashed(&call->error_link)) {\n\t\tspin_lock(&call->peer->lock);\n\t\thlist_del_init(&call->error_link);\n\t\tspin_unlock(&call->peer->lock);\n\t}\n\n\tif (rxrpc_is_client_call(call)) {\n\t\trxrpc_disconnect_client_call(call->bundle, call);\n\t} else {\n\t\t__rxrpc_disconnect_call(conn, call);\n\t\tconn->idle_timestamp = jiffies;\n\t\tif (atomic_dec_and_test(&conn->active))\n\t\t\trxrpc_set_service_reap_timer(conn->rxnet,\n\t\t\t\t\t\t     jiffies + rxrpc_connection_expiry * HZ);\n\t}\n\n\trxrpc_put_call(call, rxrpc_call_put_io_thread);\n}\n\n \nvoid rxrpc_queue_conn(struct rxrpc_connection *conn, enum rxrpc_conn_trace why)\n{\n\tif (atomic_read(&conn->active) >= 0 &&\n\t    rxrpc_queue_work(&conn->processor))\n\t\trxrpc_see_connection(conn, why);\n}\n\n \nvoid rxrpc_see_connection(struct rxrpc_connection *conn,\n\t\t\t  enum rxrpc_conn_trace why)\n{\n\tif (conn) {\n\t\tint r = refcount_read(&conn->ref);\n\n\t\ttrace_rxrpc_conn(conn->debug_id, r, why);\n\t}\n}\n\n \nstruct rxrpc_connection *rxrpc_get_connection(struct rxrpc_connection *conn,\n\t\t\t\t\t      enum rxrpc_conn_trace why)\n{\n\tint r;\n\n\t__refcount_inc(&conn->ref, &r);\n\ttrace_rxrpc_conn(conn->debug_id, r + 1, why);\n\treturn conn;\n}\n\n \nstruct rxrpc_connection *\nrxrpc_get_connection_maybe(struct rxrpc_connection *conn,\n\t\t\t   enum rxrpc_conn_trace why)\n{\n\tint r;\n\n\tif (conn) {\n\t\tif (__refcount_inc_not_zero(&conn->ref, &r))\n\t\t\ttrace_rxrpc_conn(conn->debug_id, r + 1, why);\n\t\telse\n\t\t\tconn = NULL;\n\t}\n\treturn conn;\n}\n\n \nstatic void rxrpc_set_service_reap_timer(struct rxrpc_net *rxnet,\n\t\t\t\t\t unsigned long reap_at)\n{\n\tif (rxnet->live)\n\t\ttimer_reduce(&rxnet->service_conn_reap_timer, reap_at);\n}\n\n \nstatic void rxrpc_rcu_free_connection(struct rcu_head *rcu)\n{\n\tstruct rxrpc_connection *conn =\n\t\tcontainer_of(rcu, struct rxrpc_connection, rcu);\n\tstruct rxrpc_net *rxnet = conn->rxnet;\n\n\t_enter(\"{%d,u=%d}\", conn->debug_id, refcount_read(&conn->ref));\n\n\ttrace_rxrpc_conn(conn->debug_id, refcount_read(&conn->ref),\n\t\t\t rxrpc_conn_free);\n\tkfree(conn);\n\n\tif (atomic_dec_and_test(&rxnet->nr_conns))\n\t\twake_up_var(&rxnet->nr_conns);\n}\n\n \nstatic void rxrpc_clean_up_connection(struct work_struct *work)\n{\n\tstruct rxrpc_connection *conn =\n\t\tcontainer_of(work, struct rxrpc_connection, destructor);\n\tstruct rxrpc_net *rxnet = conn->rxnet;\n\n\tASSERT(!conn->channels[0].call &&\n\t       !conn->channels[1].call &&\n\t       !conn->channels[2].call &&\n\t       !conn->channels[3].call);\n\tASSERT(list_empty(&conn->cache_link));\n\n\tdel_timer_sync(&conn->timer);\n\tcancel_work_sync(&conn->processor);  \n\tdel_timer_sync(&conn->timer);\n\n\twrite_lock(&rxnet->conn_lock);\n\tlist_del_init(&conn->proc_link);\n\twrite_unlock(&rxnet->conn_lock);\n\n\trxrpc_purge_queue(&conn->rx_queue);\n\n\trxrpc_kill_client_conn(conn);\n\n\tconn->security->clear(conn);\n\tkey_put(conn->key);\n\trxrpc_put_bundle(conn->bundle, rxrpc_bundle_put_conn);\n\trxrpc_put_peer(conn->peer, rxrpc_peer_put_conn);\n\trxrpc_put_local(conn->local, rxrpc_local_put_kill_conn);\n\n\t \n\trxrpc_purge_queue(&conn->rx_queue);\n\n\tcall_rcu(&conn->rcu, rxrpc_rcu_free_connection);\n}\n\n \nvoid rxrpc_put_connection(struct rxrpc_connection *conn,\n\t\t\t  enum rxrpc_conn_trace why)\n{\n\tunsigned int debug_id;\n\tbool dead;\n\tint r;\n\n\tif (!conn)\n\t\treturn;\n\n\tdebug_id = conn->debug_id;\n\tdead = __refcount_dec_and_test(&conn->ref, &r);\n\ttrace_rxrpc_conn(debug_id, r - 1, why);\n\tif (dead) {\n\t\tdel_timer(&conn->timer);\n\t\tcancel_work(&conn->processor);\n\n\t\tif (in_softirq() || work_busy(&conn->processor) ||\n\t\t    timer_pending(&conn->timer))\n\t\t\t \n\t\t\tschedule_work(&conn->destructor);\n\t\telse\n\t\t\trxrpc_clean_up_connection(&conn->destructor);\n\t}\n}\n\n \nvoid rxrpc_service_connection_reaper(struct work_struct *work)\n{\n\tstruct rxrpc_connection *conn, *_p;\n\tstruct rxrpc_net *rxnet =\n\t\tcontainer_of(work, struct rxrpc_net, service_conn_reaper);\n\tunsigned long expire_at, earliest, idle_timestamp, now;\n\tint active;\n\n\tLIST_HEAD(graveyard);\n\n\t_enter(\"\");\n\n\tnow = jiffies;\n\tearliest = now + MAX_JIFFY_OFFSET;\n\n\twrite_lock(&rxnet->conn_lock);\n\tlist_for_each_entry_safe(conn, _p, &rxnet->service_conns, link) {\n\t\tASSERTCMP(atomic_read(&conn->active), >=, 0);\n\t\tif (likely(atomic_read(&conn->active) > 0))\n\t\t\tcontinue;\n\t\tif (conn->state == RXRPC_CONN_SERVICE_PREALLOC)\n\t\t\tcontinue;\n\n\t\tif (rxnet->live && !conn->local->dead) {\n\t\t\tidle_timestamp = READ_ONCE(conn->idle_timestamp);\n\t\t\texpire_at = idle_timestamp + rxrpc_connection_expiry * HZ;\n\t\t\tif (conn->local->service_closed)\n\t\t\t\texpire_at = idle_timestamp + rxrpc_closed_conn_expiry * HZ;\n\n\t\t\t_debug(\"reap CONN %d { a=%d,t=%ld }\",\n\t\t\t       conn->debug_id, atomic_read(&conn->active),\n\t\t\t       (long)expire_at - (long)now);\n\n\t\t\tif (time_before(now, expire_at)) {\n\t\t\t\tif (time_before(expire_at, earliest))\n\t\t\t\t\tearliest = expire_at;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tactive = 0;\n\t\tif (!atomic_try_cmpxchg(&conn->active, &active, -1))\n\t\t\tcontinue;\n\t\trxrpc_see_connection(conn, rxrpc_conn_see_reap_service);\n\n\t\tif (rxrpc_conn_is_client(conn))\n\t\t\tBUG();\n\t\telse\n\t\t\trxrpc_unpublish_service_conn(conn);\n\n\t\tlist_move_tail(&conn->link, &graveyard);\n\t}\n\twrite_unlock(&rxnet->conn_lock);\n\n\tif (earliest != now + MAX_JIFFY_OFFSET) {\n\t\t_debug(\"reschedule reaper %ld\", (long)earliest - (long)now);\n\t\tASSERT(time_after(earliest, now));\n\t\trxrpc_set_service_reap_timer(rxnet, earliest);\n\t}\n\n\twhile (!list_empty(&graveyard)) {\n\t\tconn = list_entry(graveyard.next, struct rxrpc_connection,\n\t\t\t\t  link);\n\t\tlist_del_init(&conn->link);\n\n\t\tASSERTCMP(atomic_read(&conn->active), ==, -1);\n\t\trxrpc_put_connection(conn, rxrpc_conn_put_service_reaped);\n\t}\n\n\t_leave(\"\");\n}\n\n \nvoid rxrpc_destroy_all_connections(struct rxrpc_net *rxnet)\n{\n\tstruct rxrpc_connection *conn, *_p;\n\tbool leak = false;\n\n\t_enter(\"\");\n\n\tatomic_dec(&rxnet->nr_conns);\n\n\tdel_timer_sync(&rxnet->service_conn_reap_timer);\n\trxrpc_queue_work(&rxnet->service_conn_reaper);\n\tflush_workqueue(rxrpc_workqueue);\n\n\twrite_lock(&rxnet->conn_lock);\n\tlist_for_each_entry_safe(conn, _p, &rxnet->service_conns, link) {\n\t\tpr_err(\"AF_RXRPC: Leaked conn %p {%d}\\n\",\n\t\t       conn, refcount_read(&conn->ref));\n\t\tleak = true;\n\t}\n\twrite_unlock(&rxnet->conn_lock);\n\tBUG_ON(leak);\n\n\tASSERT(list_empty(&rxnet->conn_proc_list));\n\n\t \n\twait_var_event(&rxnet->nr_conns, !atomic_read(&rxnet->nr_conns));\n\t_leave(\"\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}