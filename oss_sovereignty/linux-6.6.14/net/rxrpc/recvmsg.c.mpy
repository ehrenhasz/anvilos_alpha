{
  "module_name": "recvmsg.c",
  "hash_id": "a8322953578dea88b81f1346d97bbde93eac7092e0df74d8195748f99d2fd508",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/recvmsg.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include \"ar-internal.h\"\n\n \nvoid rxrpc_notify_socket(struct rxrpc_call *call)\n{\n\tstruct rxrpc_sock *rx;\n\tstruct sock *sk;\n\n\t_enter(\"%d\", call->debug_id);\n\n\tif (!list_empty(&call->recvmsg_link))\n\t\treturn;\n\n\trcu_read_lock();\n\n\trx = rcu_dereference(call->socket);\n\tsk = &rx->sk;\n\tif (rx && sk->sk_state < RXRPC_CLOSE) {\n\t\tif (call->notify_rx) {\n\t\t\tspin_lock(&call->notify_lock);\n\t\t\tcall->notify_rx(sk, call, call->user_call_ID);\n\t\t\tspin_unlock(&call->notify_lock);\n\t\t} else {\n\t\t\tspin_lock(&rx->recvmsg_lock);\n\t\t\tif (list_empty(&call->recvmsg_link)) {\n\t\t\t\trxrpc_get_call(call, rxrpc_call_get_notify_socket);\n\t\t\t\tlist_add_tail(&call->recvmsg_link, &rx->recvmsg_q);\n\t\t\t}\n\t\t\tspin_unlock(&rx->recvmsg_lock);\n\n\t\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\t\t_debug(\"call %ps\", sk->sk_data_ready);\n\t\t\t\tsk->sk_data_ready(sk);\n\t\t\t}\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\t_leave(\"\");\n}\n\n \nstatic int rxrpc_recvmsg_term(struct rxrpc_call *call, struct msghdr *msg)\n{\n\tu32 tmp = 0;\n\tint ret;\n\n\tswitch (call->completion) {\n\tcase RXRPC_CALL_SUCCEEDED:\n\t\tret = 0;\n\t\tif (rxrpc_is_service_call(call))\n\t\t\tret = put_cmsg(msg, SOL_RXRPC, RXRPC_ACK, 0, &tmp);\n\t\tbreak;\n\tcase RXRPC_CALL_REMOTELY_ABORTED:\n\t\ttmp = call->abort_code;\n\t\tret = put_cmsg(msg, SOL_RXRPC, RXRPC_ABORT, 4, &tmp);\n\t\tbreak;\n\tcase RXRPC_CALL_LOCALLY_ABORTED:\n\t\ttmp = call->abort_code;\n\t\tret = put_cmsg(msg, SOL_RXRPC, RXRPC_ABORT, 4, &tmp);\n\t\tbreak;\n\tcase RXRPC_CALL_NETWORK_ERROR:\n\t\ttmp = -call->error;\n\t\tret = put_cmsg(msg, SOL_RXRPC, RXRPC_NET_ERROR, 4, &tmp);\n\t\tbreak;\n\tcase RXRPC_CALL_LOCAL_ERROR:\n\t\ttmp = -call->error;\n\t\tret = put_cmsg(msg, SOL_RXRPC, RXRPC_LOCAL_ERROR, 4, &tmp);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid terminal call state %u\\n\", call->completion);\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\ttrace_rxrpc_recvdata(call, rxrpc_recvmsg_terminal,\n\t\t\t     call->ackr_window - 1,\n\t\t\t     call->rx_pkt_offset, call->rx_pkt_len, ret);\n\treturn ret;\n}\n\n \nstatic void rxrpc_rotate_rx_window(struct rxrpc_call *call)\n{\n\tstruct rxrpc_skb_priv *sp;\n\tstruct sk_buff *skb;\n\trxrpc_serial_t serial;\n\trxrpc_seq_t old_consumed = call->rx_consumed, tseq;\n\tbool last;\n\tint acked;\n\n\t_enter(\"%d\", call->debug_id);\n\n\tskb = skb_dequeue(&call->recvmsg_queue);\n\trxrpc_see_skb(skb, rxrpc_skb_see_rotate);\n\n\tsp = rxrpc_skb(skb);\n\ttseq   = sp->hdr.seq;\n\tserial = sp->hdr.serial;\n\tlast   = sp->hdr.flags & RXRPC_LAST_PACKET;\n\n\t \n\tif (after(tseq, call->rx_consumed))\n\t\tsmp_store_release(&call->rx_consumed, tseq);\n\n\trxrpc_free_skb(skb, rxrpc_skb_put_rotate);\n\n\ttrace_rxrpc_receive(call, last ? rxrpc_receive_rotate_last : rxrpc_receive_rotate,\n\t\t\t    serial, call->rx_consumed);\n\n\tif (last)\n\t\tset_bit(RXRPC_CALL_RECVMSG_READ_ALL, &call->flags);\n\n\t \n\tacked = atomic_add_return(call->rx_consumed - old_consumed,\n\t\t\t\t  &call->ackr_nr_consumed);\n\tif (acked > 8 &&\n\t    !test_and_set_bit(RXRPC_CALL_RX_IS_IDLE, &call->flags))\n\t\trxrpc_poke_call(call, rxrpc_call_poke_idle);\n}\n\n \nstatic int rxrpc_verify_data(struct rxrpc_call *call, struct sk_buff *skb)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\n\tif (sp->flags & RXRPC_RX_VERIFIED)\n\t\treturn 0;\n\treturn call->security->verify_packet(call, skb);\n}\n\n \nstatic int rxrpc_recvmsg_data(struct socket *sock, struct rxrpc_call *call,\n\t\t\t      struct msghdr *msg, struct iov_iter *iter,\n\t\t\t      size_t len, int flags, size_t *_offset)\n{\n\tstruct rxrpc_skb_priv *sp;\n\tstruct sk_buff *skb;\n\trxrpc_seq_t seq = 0;\n\tsize_t remain;\n\tunsigned int rx_pkt_offset, rx_pkt_len;\n\tint copy, ret = -EAGAIN, ret2;\n\n\trx_pkt_offset = call->rx_pkt_offset;\n\trx_pkt_len = call->rx_pkt_len;\n\n\tif (rxrpc_call_has_failed(call)) {\n\t\tseq = call->ackr_window - 1;\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (test_bit(RXRPC_CALL_RECVMSG_READ_ALL, &call->flags)) {\n\t\tseq = call->ackr_window - 1;\n\t\tret = 1;\n\t\tgoto done;\n\t}\n\n\t \n\tskb = skb_peek(&call->recvmsg_queue);\n\twhile (skb) {\n\t\trxrpc_see_skb(skb, rxrpc_skb_see_recvmsg);\n\t\tsp = rxrpc_skb(skb);\n\t\tseq = sp->hdr.seq;\n\n\t\tif (!(flags & MSG_PEEK))\n\t\t\ttrace_rxrpc_receive(call, rxrpc_receive_front,\n\t\t\t\t\t    sp->hdr.serial, seq);\n\n\t\tif (msg)\n\t\t\tsock_recv_timestamp(msg, sock->sk, skb);\n\n\t\tif (rx_pkt_offset == 0) {\n\t\t\tret2 = rxrpc_verify_data(call, skb);\n\t\t\ttrace_rxrpc_recvdata(call, rxrpc_recvmsg_next, seq,\n\t\t\t\t\t     sp->offset, sp->len, ret2);\n\t\t\tif (ret2 < 0) {\n\t\t\t\tkdebug(\"verify = %d\", ret2);\n\t\t\t\tret = ret2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trx_pkt_offset = sp->offset;\n\t\t\trx_pkt_len = sp->len;\n\t\t} else {\n\t\t\ttrace_rxrpc_recvdata(call, rxrpc_recvmsg_cont, seq,\n\t\t\t\t\t     rx_pkt_offset, rx_pkt_len, 0);\n\t\t}\n\n\t\t \n\t\tremain = len - *_offset;\n\t\tcopy = rx_pkt_len;\n\t\tif (copy > remain)\n\t\t\tcopy = remain;\n\t\tif (copy > 0) {\n\t\t\tret2 = skb_copy_datagram_iter(skb, rx_pkt_offset, iter,\n\t\t\t\t\t\t      copy);\n\t\t\tif (ret2 < 0) {\n\t\t\t\tret = ret2;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\trx_pkt_offset += copy;\n\t\t\trx_pkt_len -= copy;\n\t\t\t*_offset += copy;\n\t\t}\n\n\t\tif (rx_pkt_len > 0) {\n\t\t\ttrace_rxrpc_recvdata(call, rxrpc_recvmsg_full, seq,\n\t\t\t\t\t     rx_pkt_offset, rx_pkt_len, 0);\n\t\t\tASSERTCMP(*_offset, ==, len);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (sp->hdr.flags & RXRPC_LAST_PACKET)\n\t\t\tret = 1;\n\t\trx_pkt_offset = 0;\n\t\trx_pkt_len = 0;\n\n\t\tskb = skb_peek_next(skb, &call->recvmsg_queue);\n\n\t\tif (!(flags & MSG_PEEK))\n\t\t\trxrpc_rotate_rx_window(call);\n\t}\n\nout:\n\tif (!(flags & MSG_PEEK)) {\n\t\tcall->rx_pkt_offset = rx_pkt_offset;\n\t\tcall->rx_pkt_len = rx_pkt_len;\n\t}\ndone:\n\ttrace_rxrpc_recvdata(call, rxrpc_recvmsg_data_return, seq,\n\t\t\t     rx_pkt_offset, rx_pkt_len, ret);\n\tif (ret == -EAGAIN)\n\t\tset_bit(RXRPC_CALL_RX_IS_IDLE, &call->flags);\n\treturn ret;\n}\n\n \nint rxrpc_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t  int flags)\n{\n\tstruct rxrpc_call *call;\n\tstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\n\tstruct list_head *l;\n\tunsigned int call_debug_id = 0;\n\tsize_t copied = 0;\n\tlong timeo;\n\tint ret;\n\n\tDEFINE_WAIT(wait);\n\n\ttrace_rxrpc_recvmsg(0, rxrpc_recvmsg_enter, 0);\n\n\tif (flags & (MSG_OOB | MSG_TRUNC))\n\t\treturn -EOPNOTSUPP;\n\n\ttimeo = sock_rcvtimeo(&rx->sk, flags & MSG_DONTWAIT);\n\ntry_again:\n\tlock_sock(&rx->sk);\n\n\t \n\tif (RB_EMPTY_ROOT(&rx->calls) &&\n\t    list_empty(&rx->recvmsg_q) &&\n\t    rx->sk.sk_state != RXRPC_SERVER_LISTENING) {\n\t\trelease_sock(&rx->sk);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (list_empty(&rx->recvmsg_q)) {\n\t\tret = -EWOULDBLOCK;\n\t\tif (timeo == 0) {\n\t\t\tcall = NULL;\n\t\t\tgoto error_no_call;\n\t\t}\n\n\t\trelease_sock(&rx->sk);\n\n\t\t \n\t\tprepare_to_wait_exclusive(sk_sleep(&rx->sk), &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tret = sock_error(&rx->sk);\n\t\tif (ret)\n\t\t\tgoto wait_error;\n\n\t\tif (list_empty(&rx->recvmsg_q)) {\n\t\t\tif (signal_pending(current))\n\t\t\t\tgoto wait_interrupted;\n\t\t\ttrace_rxrpc_recvmsg(0, rxrpc_recvmsg_wait, 0);\n\t\t\ttimeo = schedule_timeout(timeo);\n\t\t}\n\t\tfinish_wait(sk_sleep(&rx->sk), &wait);\n\t\tgoto try_again;\n\t}\n\n\t \n\tspin_lock(&rx->recvmsg_lock);\n\tl = rx->recvmsg_q.next;\n\tcall = list_entry(l, struct rxrpc_call, recvmsg_link);\n\n\tif (!rxrpc_call_is_complete(call) &&\n\t    skb_queue_empty(&call->recvmsg_queue)) {\n\t\tlist_del_init(&call->recvmsg_link);\n\t\tspin_unlock(&rx->recvmsg_lock);\n\t\trelease_sock(&rx->sk);\n\t\ttrace_rxrpc_recvmsg(call->debug_id, rxrpc_recvmsg_unqueue, 0);\n\t\trxrpc_put_call(call, rxrpc_call_put_recvmsg);\n\t\tgoto try_again;\n\t}\n\n\tif (!(flags & MSG_PEEK))\n\t\tlist_del_init(&call->recvmsg_link);\n\telse\n\t\trxrpc_get_call(call, rxrpc_call_get_recvmsg);\n\tspin_unlock(&rx->recvmsg_lock);\n\n\tcall_debug_id = call->debug_id;\n\ttrace_rxrpc_recvmsg(call_debug_id, rxrpc_recvmsg_dequeue, 0);\n\n\t \n\tif (!mutex_trylock(&call->user_mutex)) {\n\t\tret = -EWOULDBLOCK;\n\t\tif (flags & MSG_DONTWAIT)\n\t\t\tgoto error_requeue_call;\n\t\tret = -ERESTARTSYS;\n\t\tif (mutex_lock_interruptible(&call->user_mutex) < 0)\n\t\t\tgoto error_requeue_call;\n\t}\n\n\trelease_sock(&rx->sk);\n\n\tif (test_bit(RXRPC_CALL_RELEASED, &call->flags))\n\t\tBUG();\n\n\tif (test_bit(RXRPC_CALL_HAS_USERID, &call->flags)) {\n\t\tif (flags & MSG_CMSG_COMPAT) {\n\t\t\tunsigned int id32 = call->user_call_ID;\n\n\t\t\tret = put_cmsg(msg, SOL_RXRPC, RXRPC_USER_CALL_ID,\n\t\t\t\t       sizeof(unsigned int), &id32);\n\t\t} else {\n\t\t\tunsigned long idl = call->user_call_ID;\n\n\t\t\tret = put_cmsg(msg, SOL_RXRPC, RXRPC_USER_CALL_ID,\n\t\t\t\t       sizeof(unsigned long), &idl);\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock_call;\n\t}\n\n\tif (msg->msg_name && call->peer) {\n\t\tsize_t len = sizeof(call->dest_srx);\n\n\t\tmemcpy(msg->msg_name, &call->dest_srx, len);\n\t\tmsg->msg_namelen = len;\n\t}\n\n\tret = rxrpc_recvmsg_data(sock, call, msg, &msg->msg_iter, len,\n\t\t\t\t flags, &copied);\n\tif (ret == -EAGAIN)\n\t\tret = 0;\n\tif (ret == -EIO)\n\t\tgoto call_failed;\n\tif (ret < 0)\n\t\tgoto error_unlock_call;\n\n\tif (rxrpc_call_is_complete(call) &&\n\t    skb_queue_empty(&call->recvmsg_queue))\n\t\tgoto call_complete;\n\tif (rxrpc_call_has_failed(call))\n\t\tgoto call_failed;\n\n\tif (!skb_queue_empty(&call->recvmsg_queue))\n\t\trxrpc_notify_socket(call);\n\tgoto not_yet_complete;\n\ncall_failed:\n\trxrpc_purge_queue(&call->recvmsg_queue);\ncall_complete:\n\tret = rxrpc_recvmsg_term(call, msg);\n\tif (ret < 0)\n\t\tgoto error_unlock_call;\n\tif (!(flags & MSG_PEEK))\n\t\trxrpc_release_call(rx, call);\n\tmsg->msg_flags |= MSG_EOR;\n\tret = 1;\n\nnot_yet_complete:\n\tif (ret == 0)\n\t\tmsg->msg_flags |= MSG_MORE;\n\telse\n\t\tmsg->msg_flags &= ~MSG_MORE;\n\tret = copied;\n\nerror_unlock_call:\n\tmutex_unlock(&call->user_mutex);\n\trxrpc_put_call(call, rxrpc_call_put_recvmsg);\n\ttrace_rxrpc_recvmsg(call_debug_id, rxrpc_recvmsg_return, ret);\n\treturn ret;\n\nerror_requeue_call:\n\tif (!(flags & MSG_PEEK)) {\n\t\tspin_lock(&rx->recvmsg_lock);\n\t\tlist_add(&call->recvmsg_link, &rx->recvmsg_q);\n\t\tspin_unlock(&rx->recvmsg_lock);\n\t\ttrace_rxrpc_recvmsg(call_debug_id, rxrpc_recvmsg_requeue, 0);\n\t} else {\n\t\trxrpc_put_call(call, rxrpc_call_put_recvmsg);\n\t}\nerror_no_call:\n\trelease_sock(&rx->sk);\nerror_trace:\n\ttrace_rxrpc_recvmsg(call_debug_id, rxrpc_recvmsg_return, ret);\n\treturn ret;\n\nwait_interrupted:\n\tret = sock_intr_errno(timeo);\nwait_error:\n\tfinish_wait(sk_sleep(&rx->sk), &wait);\n\tcall = NULL;\n\tgoto error_trace;\n}\n\n \nint rxrpc_kernel_recv_data(struct socket *sock, struct rxrpc_call *call,\n\t\t\t   struct iov_iter *iter, size_t *_len,\n\t\t\t   bool want_more, u32 *_abort, u16 *_service)\n{\n\tsize_t offset = 0;\n\tint ret;\n\n\t_enter(\"{%d},%zu,%d\", call->debug_id, *_len, want_more);\n\n\tmutex_lock(&call->user_mutex);\n\n\tret = rxrpc_recvmsg_data(sock, call, NULL, iter, *_len, 0, &offset);\n\t*_len -= offset;\n\tif (ret == -EIO)\n\t\tgoto call_failed;\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (ret == 1) {\n\t\tif (iov_iter_count(iter) > 0)\n\t\t\tgoto short_data;\n\t\tif (!want_more)\n\t\t\tgoto read_phase_complete;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (!want_more)\n\t\tgoto excess_data;\n\tgoto out;\n\nread_phase_complete:\n\tret = 1;\nout:\n\tif (_service)\n\t\t*_service = call->dest_srx.srx_service;\n\tmutex_unlock(&call->user_mutex);\n\t_leave(\" = %d [%zu,%d]\", ret, iov_iter_count(iter), *_abort);\n\treturn ret;\n\nshort_data:\n\ttrace_rxrpc_abort(call->debug_id, rxrpc_recvmsg_short_data,\n\t\t\t  call->cid, call->call_id, call->rx_consumed,\n\t\t\t  0, -EBADMSG);\n\tret = -EBADMSG;\n\tgoto out;\nexcess_data:\n\ttrace_rxrpc_abort(call->debug_id, rxrpc_recvmsg_excess_data,\n\t\t\t  call->cid, call->call_id, call->rx_consumed,\n\t\t\t  0, -EMSGSIZE);\n\tret = -EMSGSIZE;\n\tgoto out;\ncall_failed:\n\t*_abort = call->abort_code;\n\tret = call->error;\n\tif (call->completion == RXRPC_CALL_SUCCEEDED) {\n\t\tret = 1;\n\t\tif (iov_iter_count(iter) > 0)\n\t\t\tret = -ECONNRESET;\n\t}\n\tgoto out;\n}\nEXPORT_SYMBOL(rxrpc_kernel_recv_data);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}