{
  "module_name": "rtt.c",
  "hash_id": "3f956df0989caacaa62497dc32b89c0fe0ea2ce2c14f007f289efe885a1c8be0",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/rtt.c",
  "human_readable_source": "\n \n\n#include <linux/net.h>\n#include \"ar-internal.h\"\n\n#define RXRPC_RTO_MAX\t((unsigned)(120 * HZ))\n#define RXRPC_TIMEOUT_INIT ((unsigned)(1*HZ))\t \n#define rxrpc_jiffies32 ((u32)jiffies)\t\t \n\nstatic u32 rxrpc_rto_min_us(struct rxrpc_peer *peer)\n{\n\treturn 200;\n}\n\nstatic u32 __rxrpc_set_rto(const struct rxrpc_peer *peer)\n{\n\treturn usecs_to_jiffies((peer->srtt_us >> 3) + peer->rttvar_us);\n}\n\nstatic u32 rxrpc_bound_rto(u32 rto)\n{\n\treturn min(rto, RXRPC_RTO_MAX);\n}\n\n \nstatic void rxrpc_rtt_estimator(struct rxrpc_peer *peer, long sample_rtt_us)\n{\n\tlong m = sample_rtt_us;  \n\tu32 srtt = peer->srtt_us;\n\n\t \n\tif (srtt != 0) {\n\t\tm -= (srtt >> 3);\t \n\t\tsrtt += m;\t\t \n\t\tif (m < 0) {\n\t\t\tm = -m;\t\t \n\t\t\tm -= (peer->mdev_us >> 2);    \n\t\t\t \n\t\t\tif (m > 0)\n\t\t\t\tm >>= 3;\n\t\t} else {\n\t\t\tm -= (peer->mdev_us >> 2);    \n\t\t}\n\n\t\tpeer->mdev_us += m;\t\t \n\t\tif (peer->mdev_us > peer->mdev_max_us) {\n\t\t\tpeer->mdev_max_us = peer->mdev_us;\n\t\t\tif (peer->mdev_max_us > peer->rttvar_us)\n\t\t\t\tpeer->rttvar_us = peer->mdev_max_us;\n\t\t}\n\t} else {\n\t\t \n\t\tsrtt = m << 3;\t\t \n\t\tpeer->mdev_us = m << 1;\t \n\t\tpeer->rttvar_us = max(peer->mdev_us, rxrpc_rto_min_us(peer));\n\t\tpeer->mdev_max_us = peer->rttvar_us;\n\t}\n\n\tpeer->srtt_us = max(1U, srtt);\n}\n\n \nstatic void rxrpc_set_rto(struct rxrpc_peer *peer)\n{\n\tu32 rto;\n\n\t \n\trto = __rxrpc_set_rto(peer);\n\n\t \n\n\t \n\tpeer->rto_j = rxrpc_bound_rto(rto);\n}\n\nstatic void rxrpc_ack_update_rtt(struct rxrpc_peer *peer, long rtt_us)\n{\n\tif (rtt_us < 0)\n\t\treturn;\n\n\t\n\trxrpc_rtt_estimator(peer, rtt_us);\n\trxrpc_set_rto(peer);\n\n\t \n\tpeer->backoff = 0;\n}\n\n \nvoid rxrpc_peer_add_rtt(struct rxrpc_call *call, enum rxrpc_rtt_rx_trace why,\n\t\t\tint rtt_slot,\n\t\t\trxrpc_serial_t send_serial, rxrpc_serial_t resp_serial,\n\t\t\tktime_t send_time, ktime_t resp_time)\n{\n\tstruct rxrpc_peer *peer = call->peer;\n\ts64 rtt_us;\n\n\trtt_us = ktime_to_us(ktime_sub(resp_time, send_time));\n\tif (rtt_us < 0)\n\t\treturn;\n\n\tspin_lock(&peer->rtt_input_lock);\n\trxrpc_ack_update_rtt(peer, rtt_us);\n\tif (peer->rtt_count < 3)\n\t\tpeer->rtt_count++;\n\tspin_unlock(&peer->rtt_input_lock);\n\n\ttrace_rxrpc_rtt_rx(call, why, rtt_slot, send_serial, resp_serial,\n\t\t\t   peer->srtt_us >> 3, peer->rto_j);\n}\n\n \nunsigned long rxrpc_get_rto_backoff(struct rxrpc_peer *peer, bool retrans)\n{\n\tu64 timo_j;\n\tu8 backoff = READ_ONCE(peer->backoff);\n\n\ttimo_j = peer->rto_j;\n\ttimo_j <<= backoff;\n\tif (retrans && timo_j * 2 <= RXRPC_RTO_MAX)\n\t\tWRITE_ONCE(peer->backoff, backoff + 1);\n\n\tif (timo_j < 1)\n\t\ttimo_j = 1;\n\n\treturn timo_j;\n}\n\nvoid rxrpc_peer_init_rtt(struct rxrpc_peer *peer)\n{\n\tpeer->rto_j\t= RXRPC_TIMEOUT_INIT;\n\tpeer->mdev_us\t= jiffies_to_usecs(RXRPC_TIMEOUT_INIT);\n\tpeer->backoff\t= 0;\n\t\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}