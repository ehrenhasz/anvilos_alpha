{
  "module_name": "conn_event.c",
  "hash_id": "9feef16241e15275b28195b37781a485d4ca7a62f7e088f85f61e939b5689dab",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/conn_event.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/errqueue.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include <net/ip.h>\n#include \"ar-internal.h\"\n\n \nstatic bool rxrpc_set_conn_aborted(struct rxrpc_connection *conn, struct sk_buff *skb,\n\t\t\t\t   s32 abort_code, int err,\n\t\t\t\t   enum rxrpc_call_completion compl)\n{\n\tbool aborted = false;\n\n\tif (conn->state != RXRPC_CONN_ABORTED) {\n\t\tspin_lock(&conn->state_lock);\n\t\tif (conn->state != RXRPC_CONN_ABORTED) {\n\t\t\tconn->abort_code = abort_code;\n\t\t\tconn->error\t = err;\n\t\t\tconn->completion = compl;\n\t\t\t \n\t\t\tsmp_store_release(&conn->state, RXRPC_CONN_ABORTED);\n\t\t\tset_bit(RXRPC_CONN_DONT_REUSE, &conn->flags);\n\t\t\tset_bit(RXRPC_CONN_EV_ABORT_CALLS, &conn->events);\n\t\t\taborted = true;\n\t\t}\n\t\tspin_unlock(&conn->state_lock);\n\t}\n\n\treturn aborted;\n}\n\n \nint rxrpc_abort_conn(struct rxrpc_connection *conn, struct sk_buff *skb,\n\t\t     s32 abort_code, int err, enum rxrpc_abort_reason why)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\n\tif (rxrpc_set_conn_aborted(conn, skb, abort_code, err,\n\t\t\t\t   RXRPC_CALL_LOCALLY_ABORTED)) {\n\t\ttrace_rxrpc_abort(0, why, sp->hdr.cid, sp->hdr.callNumber,\n\t\t\t\t  sp->hdr.seq, abort_code, err);\n\t\trxrpc_poke_conn(conn, rxrpc_conn_get_poke_abort);\n\t}\n\treturn -EPROTO;\n}\n\n \nstatic bool rxrpc_input_conn_abort(struct rxrpc_connection *conn,\n\t\t\t\t   struct sk_buff *skb)\n{\n\treturn rxrpc_set_conn_aborted(conn, skb, skb->priority, -ECONNABORTED,\n\t\t\t\t      RXRPC_CALL_REMOTELY_ABORTED);\n}\n\n \nvoid rxrpc_conn_retransmit_call(struct rxrpc_connection *conn,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tunsigned int channel)\n{\n\tstruct rxrpc_skb_priv *sp = skb ? rxrpc_skb(skb) : NULL;\n\tstruct rxrpc_channel *chan;\n\tstruct msghdr msg;\n\tstruct kvec iov[3];\n\tstruct {\n\t\tstruct rxrpc_wire_header whdr;\n\t\tunion {\n\t\t\t__be32 abort_code;\n\t\t\tstruct rxrpc_ackpacket ack;\n\t\t};\n\t} __attribute__((packed)) pkt;\n\tstruct rxrpc_ackinfo ack_info;\n\tsize_t len;\n\tint ret, ioc;\n\tu32 serial, mtu, call_id, padding;\n\n\t_enter(\"%d\", conn->debug_id);\n\n\tchan = &conn->channels[channel];\n\n\t \n\tcall_id = chan->last_call;\n\tif (skb && call_id != sp->hdr.callNumber)\n\t\treturn;\n\n\tmsg.msg_name\t= &conn->peer->srx.transport;\n\tmsg.msg_namelen\t= conn->peer->srx.transport_len;\n\tmsg.msg_control\t= NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags\t= 0;\n\n\tiov[0].iov_base\t= &pkt;\n\tiov[0].iov_len\t= sizeof(pkt.whdr);\n\tiov[1].iov_base\t= &padding;\n\tiov[1].iov_len\t= 3;\n\tiov[2].iov_base\t= &ack_info;\n\tiov[2].iov_len\t= sizeof(ack_info);\n\n\tserial = atomic_inc_return(&conn->serial);\n\n\tpkt.whdr.epoch\t\t= htonl(conn->proto.epoch);\n\tpkt.whdr.cid\t\t= htonl(conn->proto.cid | channel);\n\tpkt.whdr.callNumber\t= htonl(call_id);\n\tpkt.whdr.serial\t\t= htonl(serial);\n\tpkt.whdr.seq\t\t= 0;\n\tpkt.whdr.type\t\t= chan->last_type;\n\tpkt.whdr.flags\t\t= conn->out_clientflag;\n\tpkt.whdr.userStatus\t= 0;\n\tpkt.whdr.securityIndex\t= conn->security_ix;\n\tpkt.whdr._rsvd\t\t= 0;\n\tpkt.whdr.serviceId\t= htons(conn->service_id);\n\n\tlen = sizeof(pkt.whdr);\n\tswitch (chan->last_type) {\n\tcase RXRPC_PACKET_TYPE_ABORT:\n\t\tpkt.abort_code\t= htonl(chan->last_abort);\n\t\tiov[0].iov_len += sizeof(pkt.abort_code);\n\t\tlen += sizeof(pkt.abort_code);\n\t\tioc = 1;\n\t\tbreak;\n\n\tcase RXRPC_PACKET_TYPE_ACK:\n\t\tmtu = conn->peer->if_mtu;\n\t\tmtu -= conn->peer->hdrsize;\n\t\tpkt.ack.bufferSpace\t= 0;\n\t\tpkt.ack.maxSkew\t\t= htons(skb ? skb->priority : 0);\n\t\tpkt.ack.firstPacket\t= htonl(chan->last_seq + 1);\n\t\tpkt.ack.previousPacket\t= htonl(chan->last_seq);\n\t\tpkt.ack.serial\t\t= htonl(skb ? sp->hdr.serial : 0);\n\t\tpkt.ack.reason\t\t= skb ? RXRPC_ACK_DUPLICATE : RXRPC_ACK_IDLE;\n\t\tpkt.ack.nAcks\t\t= 0;\n\t\tack_info.rxMTU\t\t= htonl(rxrpc_rx_mtu);\n\t\tack_info.maxMTU\t\t= htonl(mtu);\n\t\tack_info.rwind\t\t= htonl(rxrpc_rx_window_size);\n\t\tack_info.jumbo_max\t= htonl(rxrpc_rx_jumbo_max);\n\t\tpkt.whdr.flags\t\t|= RXRPC_SLOW_START_OK;\n\t\tpadding\t\t\t= 0;\n\t\tiov[0].iov_len += sizeof(pkt.ack);\n\t\tlen += sizeof(pkt.ack) + 3 + sizeof(ack_info);\n\t\tioc = 3;\n\n\t\ttrace_rxrpc_tx_ack(chan->call_debug_id, serial,\n\t\t\t\t   ntohl(pkt.ack.firstPacket),\n\t\t\t\t   ntohl(pkt.ack.serial),\n\t\t\t\t   pkt.ack.reason, 0, rxrpc_rx_window_size);\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tret = kernel_sendmsg(conn->local->socket, &msg, iov, ioc, len);\n\tconn->peer->last_tx_at = ktime_get_seconds();\n\tif (ret < 0)\n\t\ttrace_rxrpc_tx_fail(chan->call_debug_id, serial, ret,\n\t\t\t\t    rxrpc_tx_point_call_final_resend);\n\telse\n\t\ttrace_rxrpc_tx_packet(chan->call_debug_id, &pkt.whdr,\n\t\t\t\t      rxrpc_tx_point_call_final_resend);\n\n\t_leave(\"\");\n}\n\n \nstatic void rxrpc_abort_calls(struct rxrpc_connection *conn)\n{\n\tstruct rxrpc_call *call;\n\tint i;\n\n\t_enter(\"{%d},%x\", conn->debug_id, conn->abort_code);\n\n\tfor (i = 0; i < RXRPC_MAXCALLS; i++) {\n\t\tcall = conn->channels[i].call;\n\t\tif (call)\n\t\t\trxrpc_set_call_completion(call,\n\t\t\t\t\t\t  conn->completion,\n\t\t\t\t\t\t  conn->abort_code,\n\t\t\t\t\t\t  conn->error);\n\t}\n\n\t_leave(\"\");\n}\n\n \nstatic void rxrpc_call_is_secure(struct rxrpc_call *call)\n{\n\tif (call && __rxrpc_call_state(call) == RXRPC_CALL_SERVER_SECURING) {\n\t\trxrpc_set_call_state(call, RXRPC_CALL_SERVER_RECV_REQUEST);\n\t\trxrpc_notify_socket(call);\n\t}\n}\n\n \nstatic int rxrpc_process_event(struct rxrpc_connection *conn,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tint ret;\n\n\tif (conn->state == RXRPC_CONN_ABORTED)\n\t\treturn -ECONNABORTED;\n\n\t_enter(\"{%d},{%u,%%%u},\", conn->debug_id, sp->hdr.type, sp->hdr.serial);\n\n\tswitch (sp->hdr.type) {\n\tcase RXRPC_PACKET_TYPE_CHALLENGE:\n\t\treturn conn->security->respond_to_challenge(conn, skb);\n\n\tcase RXRPC_PACKET_TYPE_RESPONSE:\n\t\tret = conn->security->verify_response(conn, skb);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = conn->security->init_connection_security(\n\t\t\tconn, conn->key->payload.data[0]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tspin_lock(&conn->state_lock);\n\t\tif (conn->state == RXRPC_CONN_SERVICE_CHALLENGING)\n\t\t\tconn->state = RXRPC_CONN_SERVICE;\n\t\tspin_unlock(&conn->state_lock);\n\n\t\tif (conn->state == RXRPC_CONN_SERVICE) {\n\t\t\t \n\t\t\tskb->mark = RXRPC_SKB_MARK_SERVICE_CONN_SECURED;\n\t\t\trxrpc_get_skb(skb, rxrpc_skb_get_conn_secured);\n\t\t\tskb_queue_head(&conn->local->rx_queue, skb);\n\t\t\trxrpc_wake_up_io_thread(conn->local);\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EPROTO;\n\t}\n}\n\n \nstatic void rxrpc_secure_connection(struct rxrpc_connection *conn)\n{\n\tif (conn->security->issue_challenge(conn) < 0)\n\t\trxrpc_abort_conn(conn, NULL, RX_CALL_DEAD, -ENOMEM,\n\t\t\t\t rxrpc_abort_nomem);\n}\n\n \nvoid rxrpc_process_delayed_final_acks(struct rxrpc_connection *conn, bool force)\n{\n\tunsigned long j = jiffies, next_j;\n\tunsigned int channel;\n\tbool set;\n\nagain:\n\tnext_j = j + LONG_MAX;\n\tset = false;\n\tfor (channel = 0; channel < RXRPC_MAXCALLS; channel++) {\n\t\tstruct rxrpc_channel *chan = &conn->channels[channel];\n\t\tunsigned long ack_at;\n\n\t\tif (!test_bit(RXRPC_CONN_FINAL_ACK_0 + channel, &conn->flags))\n\t\t\tcontinue;\n\n\t\tack_at = chan->final_ack_at;\n\t\tif (time_before(j, ack_at) && !force) {\n\t\t\tif (time_before(ack_at, next_j)) {\n\t\t\t\tnext_j = ack_at;\n\t\t\t\tset = true;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(RXRPC_CONN_FINAL_ACK_0 + channel,\n\t\t\t\t       &conn->flags))\n\t\t\trxrpc_conn_retransmit_call(conn, NULL, channel);\n\t}\n\n\tj = jiffies;\n\tif (time_before_eq(next_j, j))\n\t\tgoto again;\n\tif (set)\n\t\trxrpc_reduce_conn_timer(conn, next_j);\n}\n\n \nstatic void rxrpc_do_process_connection(struct rxrpc_connection *conn)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tif (test_and_clear_bit(RXRPC_CONN_EV_CHALLENGE, &conn->events))\n\t\trxrpc_secure_connection(conn);\n\n\t \n\twhile ((skb = skb_dequeue(&conn->rx_queue))) {\n\t\trxrpc_see_skb(skb, rxrpc_skb_see_conn_work);\n\t\tret = rxrpc_process_event(conn, skb);\n\t\tswitch (ret) {\n\t\tcase -ENOMEM:\n\t\tcase -EAGAIN:\n\t\t\tskb_queue_head(&conn->rx_queue, skb);\n\t\t\trxrpc_queue_conn(conn, rxrpc_conn_queue_retry_work);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trxrpc_free_skb(skb, rxrpc_skb_put_conn_work);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid rxrpc_process_connection(struct work_struct *work)\n{\n\tstruct rxrpc_connection *conn =\n\t\tcontainer_of(work, struct rxrpc_connection, processor);\n\n\trxrpc_see_connection(conn, rxrpc_conn_see_work);\n\n\tif (__rxrpc_use_local(conn->local, rxrpc_local_use_conn_work)) {\n\t\trxrpc_do_process_connection(conn);\n\t\trxrpc_unuse_local(conn->local, rxrpc_local_unuse_conn_work);\n\t}\n}\n\n \nstatic void rxrpc_post_packet_to_conn(struct rxrpc_connection *conn,\n\t\t\t\t      struct sk_buff *skb)\n{\n\t_enter(\"%p,%p\", conn, skb);\n\n\trxrpc_get_skb(skb, rxrpc_skb_get_conn_work);\n\tskb_queue_tail(&conn->rx_queue, skb);\n\trxrpc_queue_conn(conn, rxrpc_conn_queue_rx_work);\n}\n\n \nbool rxrpc_input_conn_packet(struct rxrpc_connection *conn, struct sk_buff *skb)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\n\tswitch (sp->hdr.type) {\n\tcase RXRPC_PACKET_TYPE_BUSY:\n\t\t \n\t\treturn true;\n\n\tcase RXRPC_PACKET_TYPE_ABORT:\n\t\tif (rxrpc_is_conn_aborted(conn))\n\t\t\treturn true;\n\t\trxrpc_input_conn_abort(conn, skb);\n\t\trxrpc_abort_calls(conn);\n\t\treturn true;\n\n\tcase RXRPC_PACKET_TYPE_CHALLENGE:\n\tcase RXRPC_PACKET_TYPE_RESPONSE:\n\t\tif (rxrpc_is_conn_aborted(conn)) {\n\t\t\tif (conn->completion == RXRPC_CALL_LOCALLY_ABORTED)\n\t\t\t\trxrpc_send_conn_abort(conn);\n\t\t\treturn true;\n\t\t}\n\t\trxrpc_post_packet_to_conn(conn, skb);\n\t\treturn true;\n\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn true;\n\t}\n}\n\n \nvoid rxrpc_input_conn_event(struct rxrpc_connection *conn, struct sk_buff *skb)\n{\n\tunsigned int loop;\n\n\tif (test_and_clear_bit(RXRPC_CONN_EV_ABORT_CALLS, &conn->events))\n\t\trxrpc_abort_calls(conn);\n\n\tswitch (skb->mark) {\n\tcase RXRPC_SKB_MARK_SERVICE_CONN_SECURED:\n\t\tif (conn->state != RXRPC_CONN_SERVICE)\n\t\t\tbreak;\n\n\t\tfor (loop = 0; loop < RXRPC_MAXCALLS; loop++)\n\t\t\trxrpc_call_is_secure(conn->channels[loop].call);\n\t\tbreak;\n\t}\n\n\t \n\tif (conn->flags & RXRPC_CONN_FINAL_ACK_MASK)\n\t\trxrpc_process_delayed_final_acks(conn, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}