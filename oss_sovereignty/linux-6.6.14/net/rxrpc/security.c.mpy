{
  "module_name": "security.c",
  "hash_id": "0b5b6d57cbb6f5a853a471d16a0fd5bb47b6a17aface38f0626985bffcf8420e",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/security.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/udp.h>\n#include <linux/crypto.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include <keys/rxrpc-type.h>\n#include \"ar-internal.h\"\n\nstatic const struct rxrpc_security *rxrpc_security_types[] = {\n\t[RXRPC_SECURITY_NONE]\t= &rxrpc_no_security,\n#ifdef CONFIG_RXKAD\n\t[RXRPC_SECURITY_RXKAD]\t= &rxkad,\n#endif\n};\n\nint __init rxrpc_init_security(void)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(rxrpc_security_types); i++) {\n\t\tif (rxrpc_security_types[i]) {\n\t\t\tret = rxrpc_security_types[i]->init();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto failed;\n\t\t}\n\t}\n\n\treturn 0;\n\nfailed:\n\tfor (i--; i >= 0; i--)\n\t\tif (rxrpc_security_types[i])\n\t\t\trxrpc_security_types[i]->exit();\n\treturn ret;\n}\n\nvoid rxrpc_exit_security(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rxrpc_security_types); i++)\n\t\tif (rxrpc_security_types[i])\n\t\t\trxrpc_security_types[i]->exit();\n}\n\n \nconst struct rxrpc_security *rxrpc_security_lookup(u8 security_index)\n{\n\tif (security_index >= ARRAY_SIZE(rxrpc_security_types))\n\t\treturn NULL;\n\treturn rxrpc_security_types[security_index];\n}\n\n \nint rxrpc_init_client_call_security(struct rxrpc_call *call)\n{\n\tconst struct rxrpc_security *sec = &rxrpc_no_security;\n\tstruct rxrpc_key_token *token;\n\tstruct key *key = call->key;\n\tint ret;\n\n\tif (!key)\n\t\tgoto found;\n\n\tret = key_validate(key);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (token = key->payload.data[0]; token; token = token->next) {\n\t\tsec = rxrpc_security_lookup(token->security_index);\n\t\tif (sec)\n\t\t\tgoto found;\n\t}\n\treturn -EKEYREJECTED;\n\nfound:\n\tcall->security = sec;\n\tcall->security_ix = sec->security_index;\n\treturn 0;\n}\n\n \nint rxrpc_init_client_conn_security(struct rxrpc_connection *conn)\n{\n\tstruct rxrpc_key_token *token;\n\tstruct key *key = conn->key;\n\tint ret = 0;\n\n\t_enter(\"{%d},{%x}\", conn->debug_id, key_serial(key));\n\n\tfor (token = key->payload.data[0]; token; token = token->next) {\n\t\tif (token->security_index == conn->security->security_index)\n\t\t\tgoto found;\n\t}\n\treturn -EKEYREJECTED;\n\nfound:\n\tmutex_lock(&conn->security_lock);\n\tif (conn->state == RXRPC_CONN_CLIENT_UNSECURED) {\n\t\tret = conn->security->init_connection_security(conn, token);\n\t\tif (ret == 0) {\n\t\t\tspin_lock(&conn->state_lock);\n\t\t\tif (conn->state == RXRPC_CONN_CLIENT_UNSECURED)\n\t\t\t\tconn->state = RXRPC_CONN_CLIENT;\n\t\t\tspin_unlock(&conn->state_lock);\n\t\t}\n\t}\n\tmutex_unlock(&conn->security_lock);\n\treturn ret;\n}\n\n \nconst struct rxrpc_security *rxrpc_get_incoming_security(struct rxrpc_sock *rx,\n\t\t\t\t\t\t\t struct sk_buff *skb)\n{\n\tconst struct rxrpc_security *sec;\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\n\t_enter(\"\");\n\n\tsec = rxrpc_security_lookup(sp->hdr.securityIndex);\n\tif (!sec) {\n\t\trxrpc_direct_abort(skb, rxrpc_abort_unsupported_security,\n\t\t\t\t   RX_INVALID_OPERATION, -EKEYREJECTED);\n\t\treturn NULL;\n\t}\n\n\tif (sp->hdr.securityIndex != RXRPC_SECURITY_NONE &&\n\t    !rx->securities) {\n\t\trxrpc_direct_abort(skb, rxrpc_abort_no_service_key,\n\t\t\t\t   sec->no_key_abort, -EKEYREJECTED);\n\t\treturn NULL;\n\t}\n\n\treturn sec;\n}\n\n \nstruct key *rxrpc_look_up_server_security(struct rxrpc_connection *conn,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  u32 kvno, u32 enctype)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tstruct rxrpc_sock *rx;\n\tstruct key *key = ERR_PTR(-EKEYREJECTED);\n\tkey_ref_t kref = NULL;\n\tchar kdesc[5 + 1 + 3 + 1 + 12 + 1 + 12 + 1];\n\tint ret;\n\n\t_enter(\"\");\n\n\tif (enctype)\n\t\tsprintf(kdesc, \"%u:%u:%u:%u\",\n\t\t\tsp->hdr.serviceId, sp->hdr.securityIndex, kvno, enctype);\n\telse if (kvno)\n\t\tsprintf(kdesc, \"%u:%u:%u\",\n\t\t\tsp->hdr.serviceId, sp->hdr.securityIndex, kvno);\n\telse\n\t\tsprintf(kdesc, \"%u:%u\",\n\t\t\tsp->hdr.serviceId, sp->hdr.securityIndex);\n\n\tread_lock(&conn->local->services_lock);\n\n\trx = conn->local->service;\n\tif (!rx)\n\t\tgoto out;\n\n\t \n\tkref = keyring_search(make_key_ref(rx->securities, 1UL),\n\t\t\t      &key_type_rxrpc_s, kdesc, true);\n\tif (IS_ERR(kref)) {\n\t\tkey = ERR_CAST(kref);\n\t\tgoto out;\n\t}\n\n\tkey = key_ref_to_ptr(kref);\n\n\tret = key_validate(key);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tread_unlock(&conn->local->services_lock);\n\treturn key;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}