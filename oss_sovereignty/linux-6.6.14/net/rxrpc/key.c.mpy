{
  "module_name": "key.c",
  "hash_id": "3e5631b4cceffe8cde9a564a60876eb6a24e2ffb322d65e847696c49b88b5de4",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/key.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <crypto/skcipher.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/key-type.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include <keys/rxrpc-type.h>\n#include <keys/user-type.h>\n#include \"ar-internal.h\"\n\nstatic int rxrpc_preparse(struct key_preparsed_payload *);\nstatic void rxrpc_free_preparse(struct key_preparsed_payload *);\nstatic void rxrpc_destroy(struct key *);\nstatic void rxrpc_describe(const struct key *, struct seq_file *);\nstatic long rxrpc_read(const struct key *, char *, size_t);\n\n \nstruct key_type key_type_rxrpc = {\n\t.name\t\t= \"rxrpc\",\n\t.flags\t\t= KEY_TYPE_NET_DOMAIN,\n\t.preparse\t= rxrpc_preparse,\n\t.free_preparse\t= rxrpc_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.destroy\t= rxrpc_destroy,\n\t.describe\t= rxrpc_describe,\n\t.read\t\t= rxrpc_read,\n};\nEXPORT_SYMBOL(key_type_rxrpc);\n\n \nstatic int rxrpc_preparse_xdr_rxkad(struct key_preparsed_payload *prep,\n\t\t\t\t    size_t datalen,\n\t\t\t\t    const __be32 *xdr, unsigned int toklen)\n{\n\tstruct rxrpc_key_token *token, **pptoken;\n\ttime64_t expiry;\n\tsize_t plen;\n\tu32 tktlen;\n\n\t_enter(\",{%x,%x,%x,%x},%u\",\n\t       ntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), ntohl(xdr[3]),\n\t       toklen);\n\n\tif (toklen <= 8 * 4)\n\t\treturn -EKEYREJECTED;\n\ttktlen = ntohl(xdr[7]);\n\t_debug(\"tktlen: %x\", tktlen);\n\tif (tktlen > AFSTOKEN_RK_TIX_MAX)\n\t\treturn -EKEYREJECTED;\n\tif (toklen < 8 * 4 + tktlen)\n\t\treturn -EKEYREJECTED;\n\n\tplen = sizeof(*token) + sizeof(*token->kad) + tktlen;\n\tprep->quotalen = datalen + plen;\n\n\tplen -= sizeof(*token);\n\ttoken = kzalloc(sizeof(*token), GFP_KERNEL);\n\tif (!token)\n\t\treturn -ENOMEM;\n\n\ttoken->kad = kzalloc(plen, GFP_KERNEL);\n\tif (!token->kad) {\n\t\tkfree(token);\n\t\treturn -ENOMEM;\n\t}\n\n\ttoken->security_index\t= RXRPC_SECURITY_RXKAD;\n\ttoken->kad->ticket_len\t= tktlen;\n\ttoken->kad->vice_id\t= ntohl(xdr[0]);\n\ttoken->kad->kvno\t= ntohl(xdr[1]);\n\ttoken->kad->start\t= ntohl(xdr[4]);\n\ttoken->kad->expiry\t= ntohl(xdr[5]);\n\ttoken->kad->primary_flag = ntohl(xdr[6]);\n\tmemcpy(&token->kad->session_key, &xdr[2], 8);\n\tmemcpy(&token->kad->ticket, &xdr[8], tktlen);\n\n\t_debug(\"SCIX: %u\", token->security_index);\n\t_debug(\"TLEN: %u\", token->kad->ticket_len);\n\t_debug(\"EXPY: %x\", token->kad->expiry);\n\t_debug(\"KVNO: %u\", token->kad->kvno);\n\t_debug(\"PRIM: %u\", token->kad->primary_flag);\n\t_debug(\"SKEY: %02x%02x%02x%02x%02x%02x%02x%02x\",\n\t       token->kad->session_key[0], token->kad->session_key[1],\n\t       token->kad->session_key[2], token->kad->session_key[3],\n\t       token->kad->session_key[4], token->kad->session_key[5],\n\t       token->kad->session_key[6], token->kad->session_key[7]);\n\tif (token->kad->ticket_len >= 8)\n\t\t_debug(\"TCKT: %02x%02x%02x%02x%02x%02x%02x%02x\",\n\t\t       token->kad->ticket[0], token->kad->ticket[1],\n\t\t       token->kad->ticket[2], token->kad->ticket[3],\n\t\t       token->kad->ticket[4], token->kad->ticket[5],\n\t\t       token->kad->ticket[6], token->kad->ticket[7]);\n\n\t \n\tprep->payload.data[1] = (void *)((unsigned long)prep->payload.data[1] + 1);\n\n\t \n\tfor (pptoken = (struct rxrpc_key_token **)&prep->payload.data[0];\n\t     *pptoken;\n\t     pptoken = &(*pptoken)->next)\n\t\tcontinue;\n\t*pptoken = token;\n\texpiry = rxrpc_u32_to_time64(token->kad->expiry);\n\tif (expiry < prep->expiry)\n\t\tprep->expiry = expiry;\n\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n \nstatic int rxrpc_preparse_xdr(struct key_preparsed_payload *prep)\n{\n\tconst __be32 *xdr = prep->data, *token, *p;\n\tconst char *cp;\n\tunsigned int len, paddedlen, loop, ntoken, toklen, sec_ix;\n\tsize_t datalen = prep->datalen;\n\tint ret, ret2;\n\n\t_enter(\",{%x,%x,%x,%x},%zu\",\n\t       ntohl(xdr[0]), ntohl(xdr[1]), ntohl(xdr[2]), ntohl(xdr[3]),\n\t       prep->datalen);\n\n\tif (datalen > AFSTOKEN_LENGTH_MAX)\n\t\tgoto not_xdr;\n\n\t \n\tif (datalen & 3)\n\t\tgoto not_xdr;\n\n\t \n\tif (ntohl(*xdr++) != 0)\n\t\tgoto not_xdr;\n\tdatalen -= 4;\n\n\t \n\tlen = ntohl(*xdr++);\n\tif (len < 1 || len > AFSTOKEN_CELL_MAX)\n\t\tgoto not_xdr;\n\tdatalen -= 4;\n\tpaddedlen = (len + 3) & ~3;\n\tif (paddedlen > datalen)\n\t\tgoto not_xdr;\n\n\tcp = (const char *) xdr;\n\tfor (loop = 0; loop < len; loop++)\n\t\tif (!isprint(cp[loop]))\n\t\t\tgoto not_xdr;\n\tfor (; loop < paddedlen; loop++)\n\t\tif (cp[loop])\n\t\t\tgoto not_xdr;\n\t_debug(\"cellname: [%u/%u] '%*.*s'\",\n\t       len, paddedlen, len, len, (const char *) xdr);\n\tdatalen -= paddedlen;\n\txdr += paddedlen >> 2;\n\n\t \n\tif (datalen < 12)\n\t\tgoto not_xdr;\n\tntoken = ntohl(*xdr++);\n\tdatalen -= 4;\n\t_debug(\"ntoken: %x\", ntoken);\n\tif (ntoken < 1 || ntoken > AFSTOKEN_MAX)\n\t\tgoto not_xdr;\n\n\t \n\tp = xdr;\n\tloop = ntoken;\n\tdo {\n\t\tif (datalen < 8)\n\t\t\tgoto not_xdr;\n\t\ttoklen = ntohl(*p++);\n\t\tsec_ix = ntohl(*p);\n\t\tdatalen -= 4;\n\t\t_debug(\"token: [%x/%zx] %x\", toklen, datalen, sec_ix);\n\t\tpaddedlen = (toklen + 3) & ~3;\n\t\tif (toklen < 20 || toklen > datalen || paddedlen > datalen)\n\t\t\tgoto not_xdr;\n\t\tdatalen -= paddedlen;\n\t\tp += paddedlen >> 2;\n\n\t} while (--loop > 0);\n\n\t_debug(\"remainder: %zu\", datalen);\n\tif (datalen != 0)\n\t\tgoto not_xdr;\n\n\t \n\tret = -EPROTONOSUPPORT;\n\tdo {\n\t\ttoklen = ntohl(*xdr++);\n\t\ttoken = xdr;\n\t\txdr += (toklen + 3) / 4;\n\n\t\tsec_ix = ntohl(*token++);\n\t\ttoklen -= 4;\n\n\t\t_debug(\"TOKEN type=%x len=%x\", sec_ix, toklen);\n\n\t\tswitch (sec_ix) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\tret2 = rxrpc_preparse_xdr_rxkad(prep, datalen, token, toklen);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret2 = -EPROTONOSUPPORT;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ret2) {\n\t\tcase 0:\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tbreak;\n\t\tcase -ENOPKG:\n\t\t\tif (ret != 0)\n\t\t\t\tret = -ENOPKG;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = ret2;\n\t\t\tgoto error;\n\t\t}\n\n\t} while (--ntoken > 0);\n\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nnot_xdr:\n\t_leave(\" = -EPROTO\");\n\treturn -EPROTO;\n}\n\n \nstatic int rxrpc_preparse(struct key_preparsed_payload *prep)\n{\n\tconst struct rxrpc_key_data_v1 *v1;\n\tstruct rxrpc_key_token *token, **pp;\n\ttime64_t expiry;\n\tsize_t plen;\n\tu32 kver;\n\tint ret;\n\n\t_enter(\"%zu\", prep->datalen);\n\n\t \n\tif (!prep->data && prep->datalen == 0)\n\t\treturn 0;\n\n\t \n\tif (prep->datalen > 7 * 4) {\n\t\tret = rxrpc_preparse_xdr(prep);\n\t\tif (ret != -EPROTO)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = -EINVAL;\n\tif (prep->datalen <= 4 || !prep->data)\n\t\tgoto error;\n\tmemcpy(&kver, prep->data, sizeof(kver));\n\tprep->data += sizeof(kver);\n\tprep->datalen -= sizeof(kver);\n\n\t_debug(\"KEY I/F VERSION: %u\", kver);\n\n\tret = -EKEYREJECTED;\n\tif (kver != 1)\n\t\tgoto error;\n\n\t \n\tret = -EINVAL;\n\tif (prep->datalen < sizeof(*v1))\n\t\tgoto error;\n\n\tv1 = prep->data;\n\tif (prep->datalen != sizeof(*v1) + v1->ticket_length)\n\t\tgoto error;\n\n\t_debug(\"SCIX: %u\", v1->security_index);\n\t_debug(\"TLEN: %u\", v1->ticket_length);\n\t_debug(\"EXPY: %x\", v1->expiry);\n\t_debug(\"KVNO: %u\", v1->kvno);\n\t_debug(\"SKEY: %02x%02x%02x%02x%02x%02x%02x%02x\",\n\t       v1->session_key[0], v1->session_key[1],\n\t       v1->session_key[2], v1->session_key[3],\n\t       v1->session_key[4], v1->session_key[5],\n\t       v1->session_key[6], v1->session_key[7]);\n\tif (v1->ticket_length >= 8)\n\t\t_debug(\"TCKT: %02x%02x%02x%02x%02x%02x%02x%02x\",\n\t\t       v1->ticket[0], v1->ticket[1],\n\t\t       v1->ticket[2], v1->ticket[3],\n\t\t       v1->ticket[4], v1->ticket[5],\n\t\t       v1->ticket[6], v1->ticket[7]);\n\n\tret = -EPROTONOSUPPORT;\n\tif (v1->security_index != RXRPC_SECURITY_RXKAD)\n\t\tgoto error;\n\n\tplen = sizeof(*token->kad) + v1->ticket_length;\n\tprep->quotalen = plen + sizeof(*token);\n\n\tret = -ENOMEM;\n\ttoken = kzalloc(sizeof(*token), GFP_KERNEL);\n\tif (!token)\n\t\tgoto error;\n\ttoken->kad = kzalloc(plen, GFP_KERNEL);\n\tif (!token->kad)\n\t\tgoto error_free;\n\n\ttoken->security_index\t\t= RXRPC_SECURITY_RXKAD;\n\ttoken->kad->ticket_len\t\t= v1->ticket_length;\n\ttoken->kad->expiry\t\t= v1->expiry;\n\ttoken->kad->kvno\t\t= v1->kvno;\n\tmemcpy(&token->kad->session_key, &v1->session_key, 8);\n\tmemcpy(&token->kad->ticket, v1->ticket, v1->ticket_length);\n\n\t \n\tprep->payload.data[1] = (void *)((unsigned long)prep->payload.data[1] + 1);\n\n\t \n\tpp = (struct rxrpc_key_token **)&prep->payload.data[0];\n\twhile (*pp)\n\t\tpp = &(*pp)->next;\n\t*pp = token;\n\texpiry = rxrpc_u32_to_time64(token->kad->expiry);\n\tif (expiry < prep->expiry)\n\t\tprep->expiry = expiry;\n\ttoken = NULL;\n\tret = 0;\n\nerror_free:\n\tkfree(token);\nerror:\n\treturn ret;\n}\n\n \nstatic void rxrpc_free_token_list(struct rxrpc_key_token *token)\n{\n\tstruct rxrpc_key_token *next;\n\n\tfor (; token; token = next) {\n\t\tnext = token->next;\n\t\tswitch (token->security_index) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\tkfree(token->kad);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unknown token type %x on rxrpc key\\n\",\n\t\t\t       token->security_index);\n\t\t\tBUG();\n\t\t}\n\n\t\tkfree(token);\n\t}\n}\n\n \nstatic void rxrpc_free_preparse(struct key_preparsed_payload *prep)\n{\n\trxrpc_free_token_list(prep->payload.data[0]);\n}\n\n \nstatic void rxrpc_destroy(struct key *key)\n{\n\trxrpc_free_token_list(key->payload.data[0]);\n}\n\n \nstatic void rxrpc_describe(const struct key *key, struct seq_file *m)\n{\n\tconst struct rxrpc_key_token *token;\n\tconst char *sep = \": \";\n\n\tseq_puts(m, key->description);\n\n\tfor (token = key->payload.data[0]; token; token = token->next) {\n\t\tseq_puts(m, sep);\n\n\t\tswitch (token->security_index) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\tseq_puts(m, \"ka\");\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tseq_printf(m, \"%u\", token->security_index);\n\t\t\tbreak;\n\t\t}\n\n\t\tsep = \" \";\n\t}\n}\n\n \nint rxrpc_request_key(struct rxrpc_sock *rx, sockptr_t optval, int optlen)\n{\n\tstruct key *key;\n\tchar *description;\n\n\t_enter(\"\");\n\n\tif (optlen <= 0 || optlen > PAGE_SIZE - 1 || rx->securities)\n\t\treturn -EINVAL;\n\n\tdescription = memdup_sockptr_nul(optval, optlen);\n\tif (IS_ERR(description))\n\t\treturn PTR_ERR(description);\n\n\tkey = request_key_net(&key_type_rxrpc, description, sock_net(&rx->sk), NULL);\n\tif (IS_ERR(key)) {\n\t\tkfree(description);\n\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\trx->key = key;\n\tkfree(description);\n\t_leave(\" = 0 [key %x]\", key->serial);\n\treturn 0;\n}\n\n \nint rxrpc_get_server_data_key(struct rxrpc_connection *conn,\n\t\t\t      const void *session_key,\n\t\t\t      time64_t expiry,\n\t\t\t      u32 kvno)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key *key;\n\tint ret;\n\n\tstruct {\n\t\tu32 kver;\n\t\tstruct rxrpc_key_data_v1 v1;\n\t} data;\n\n\t_enter(\"\");\n\n\tkey = key_alloc(&key_type_rxrpc, \"x\",\n\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred, 0,\n\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = -ENOMEM [alloc %ld]\", PTR_ERR(key));\n\t\treturn -ENOMEM;\n\t}\n\n\t_debug(\"key %d\", key_serial(key));\n\n\tdata.kver = 1;\n\tdata.v1.security_index = RXRPC_SECURITY_RXKAD;\n\tdata.v1.ticket_length = 0;\n\tdata.v1.expiry = rxrpc_time64_to_u32(expiry);\n\tdata.v1.kvno = 0;\n\n\tmemcpy(&data.v1.session_key, session_key, sizeof(data.v1.session_key));\n\n\tret = key_instantiate_and_link(key, &data, sizeof(data), NULL, NULL);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tconn->key = key;\n\t_leave(\" = 0 [%d]\", key_serial(key));\n\treturn 0;\n\nerror:\n\tkey_revoke(key);\n\tkey_put(key);\n\t_leave(\" = -ENOMEM [ins %d]\", ret);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(rxrpc_get_server_data_key);\n\n \nstruct key *rxrpc_get_null_key(const char *keyname)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key *key;\n\tint ret;\n\n\tkey = key_alloc(&key_type_rxrpc, keyname,\n\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\tKEY_POS_SEARCH, KEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(key))\n\t\treturn key;\n\n\tret = key_instantiate_and_link(key, NULL, 0, NULL, NULL);\n\tif (ret < 0) {\n\t\tkey_revoke(key);\n\t\tkey_put(key);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn key;\n}\nEXPORT_SYMBOL(rxrpc_get_null_key);\n\n \nstatic long rxrpc_read(const struct key *key,\n\t\t       char *buffer, size_t buflen)\n{\n\tconst struct rxrpc_key_token *token;\n\tsize_t size;\n\t__be32 *xdr, *oldxdr;\n\tu32 cnlen, toksize, ntoks, tok, zero;\n\tu16 toksizes[AFSTOKEN_MAX];\n\n\t_enter(\"\");\n\n\t \n\tif (memcmp(key->description, \"afs@\", 4) != 0)\n\t\treturn -EOPNOTSUPP;\n\tcnlen = strlen(key->description + 4);\n\n#define RND(X) (((X) + 3) & ~3)\n\n\t \n\tsize = 2 * 4;\t \n\tsize += RND(cnlen);\t \n\tsize += 1 * 4;\t \n\n\tntoks = 0;\n\tfor (token = key->payload.data[0]; token; token = token->next) {\n\t\ttoksize = 4;\t \n\n\t\tswitch (token->security_index) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\ttoksize += 8 * 4;\t \n\t\t\tif (!token->no_leak_key)\n\t\t\t\ttoksize += RND(token->kad->ticket_len);\n\t\t\tbreak;\n\n\t\tdefault:  \n\t\t\tpr_err(\"Unsupported key token type (%u)\\n\",\n\t\t\t       token->security_index);\n\t\t\treturn -ENOPKG;\n\t\t}\n\n\t\t_debug(\"token[%u]: toksize=%u\", ntoks, toksize);\n\t\tif (WARN_ON(toksize > AFSTOKEN_LENGTH_MAX))\n\t\t\treturn -EIO;\n\n\t\ttoksizes[ntoks++] = toksize;\n\t\tsize += toksize + 4;  \n\t}\n\n#undef RND\n\n\tif (!buffer || buflen < size)\n\t\treturn size;\n\n\txdr = (__be32 *)buffer;\n\tzero = 0;\n#define ENCODE(x)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\t*xdr++ = htonl(x);\t\t\\\n\t} while(0)\n#define ENCODE_DATA(l, s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tu32 _l = (l);\t\t\t\t\t\t\\\n\t\tENCODE(l);\t\t\t\t\t\t\\\n\t\tmemcpy(xdr, (s), _l);\t\t\t\t\t\\\n\t\tif (_l & 3)\t\t\t\t\t\t\\\n\t\t\tmemcpy((u8 *)xdr + _l, &zero, 4 - (_l & 3));\t\\\n\t\txdr += (_l + 3) >> 2;\t\t\t\t\t\\\n\t} while(0)\n#define ENCODE_BYTES(l, s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tu32 _l = (l);\t\t\t\t\t\t\\\n\t\tmemcpy(xdr, (s), _l);\t\t\t\t\t\\\n\t\tif (_l & 3)\t\t\t\t\t\t\\\n\t\t\tmemcpy((u8 *)xdr + _l, &zero, 4 - (_l & 3));\t\\\n\t\txdr += (_l + 3) >> 2;\t\t\t\t\t\\\n\t} while(0)\n#define ENCODE64(x)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\t__be64 y = cpu_to_be64(x);\t\t\\\n\t\tmemcpy(xdr, &y, 8);\t\t\t\\\n\t\txdr += 8 >> 2;\t\t\t\t\\\n\t} while(0)\n#define ENCODE_STR(s)\t\t\t\t\\\n\tdo {\t\t\t\t\t\\\n\t\tconst char *_s = (s);\t\t\\\n\t\tENCODE_DATA(strlen(_s), _s);\t\\\n\t} while(0)\n\n\tENCODE(0);\t\t\t\t\t \n\tENCODE_DATA(cnlen, key->description + 4);\t \n\tENCODE(ntoks);\n\n\ttok = 0;\n\tfor (token = key->payload.data[0]; token; token = token->next) {\n\t\ttoksize = toksizes[tok++];\n\t\tENCODE(toksize);\n\t\toldxdr = xdr;\n\t\tENCODE(token->security_index);\n\n\t\tswitch (token->security_index) {\n\t\tcase RXRPC_SECURITY_RXKAD:\n\t\t\tENCODE(token->kad->vice_id);\n\t\t\tENCODE(token->kad->kvno);\n\t\t\tENCODE_BYTES(8, token->kad->session_key);\n\t\t\tENCODE(token->kad->start);\n\t\t\tENCODE(token->kad->expiry);\n\t\t\tENCODE(token->kad->primary_flag);\n\t\t\tif (token->no_leak_key)\n\t\t\t\tENCODE(0);\n\t\t\telse\n\t\t\t\tENCODE_DATA(token->kad->ticket_len, token->kad->ticket);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"Unsupported key token type (%u)\\n\",\n\t\t\t       token->security_index);\n\t\t\treturn -ENOPKG;\n\t\t}\n\n\t\tif (WARN_ON((unsigned long)xdr - (unsigned long)oldxdr !=\n\t\t\t    toksize))\n\t\t\treturn -EIO;\n\t}\n\n#undef ENCODE_STR\n#undef ENCODE_DATA\n#undef ENCODE64\n#undef ENCODE\n\n\tif (WARN_ON(tok != ntoks))\n\t\treturn -EIO;\n\tif (WARN_ON((unsigned long)xdr - (unsigned long)buffer != size))\n\t\treturn -EIO;\n\t_leave(\" = %zu\", size);\n\treturn size;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}