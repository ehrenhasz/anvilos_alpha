{
  "module_name": "peer_event.c",
  "hash_id": "ba53f6bed839b265bcc4bfa7b7a20994b00ec037fd2a1a9349a45a8df1fd851f",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/peer_event.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/errqueue.h>\n#include <linux/udp.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/icmp.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include <net/ip.h>\n#include \"ar-internal.h\"\n\nstatic void rxrpc_store_error(struct rxrpc_peer *, struct sk_buff *);\nstatic void rxrpc_distribute_error(struct rxrpc_peer *, struct sk_buff *,\n\t\t\t\t   enum rxrpc_call_completion, int);\n\n \nstatic struct rxrpc_peer *rxrpc_lookup_peer_local_rcu(struct rxrpc_local *local,\n\t\t\t\t\t\t      const struct sk_buff *skb,\n\t\t\t\t\t\t      struct sockaddr_rxrpc *srx)\n{\n\tstruct sock_exterr_skb *serr = SKB_EXT_ERR(skb);\n\n\t_enter(\"\");\n\n\tmemset(srx, 0, sizeof(*srx));\n\tsrx->transport_type = local->srx.transport_type;\n\tsrx->transport_len = local->srx.transport_len;\n\tsrx->transport.family = local->srx.transport.family;\n\n\t \n\tswitch (srx->transport.family) {\n\tcase AF_INET:\n\t\tsrx->transport_len = sizeof(srx->transport.sin);\n\t\tsrx->transport.family = AF_INET;\n\t\tsrx->transport.sin.sin_port = serr->port;\n\t\tswitch (serr->ee.ee_origin) {\n\t\tcase SO_EE_ORIGIN_ICMP:\n\t\t\tmemcpy(&srx->transport.sin.sin_addr,\n\t\t\t       skb_network_header(skb) + serr->addr_offset,\n\t\t\t       sizeof(struct in_addr));\n\t\t\tbreak;\n\t\tcase SO_EE_ORIGIN_ICMP6:\n\t\t\tmemcpy(&srx->transport.sin.sin_addr,\n\t\t\t       skb_network_header(skb) + serr->addr_offset + 12,\n\t\t\t       sizeof(struct in_addr));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemcpy(&srx->transport.sin.sin_addr, &ip_hdr(skb)->saddr,\n\t\t\t       sizeof(struct in_addr));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n#ifdef CONFIG_AF_RXRPC_IPV6\n\tcase AF_INET6:\n\t\tswitch (serr->ee.ee_origin) {\n\t\tcase SO_EE_ORIGIN_ICMP6:\n\t\t\tsrx->transport.sin6.sin6_port = serr->port;\n\t\t\tmemcpy(&srx->transport.sin6.sin6_addr,\n\t\t\t       skb_network_header(skb) + serr->addr_offset,\n\t\t\t       sizeof(struct in6_addr));\n\t\t\tbreak;\n\t\tcase SO_EE_ORIGIN_ICMP:\n\t\t\tsrx->transport_len = sizeof(srx->transport.sin);\n\t\t\tsrx->transport.family = AF_INET;\n\t\t\tsrx->transport.sin.sin_port = serr->port;\n\t\t\tmemcpy(&srx->transport.sin.sin_addr,\n\t\t\t       skb_network_header(skb) + serr->addr_offset,\n\t\t\t       sizeof(struct in_addr));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemcpy(&srx->transport.sin6.sin6_addr,\n\t\t\t       &ipv6_hdr(skb)->saddr,\n\t\t\t       sizeof(struct in6_addr));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn rxrpc_lookup_peer_rcu(local, srx);\n}\n\n \nstatic void rxrpc_adjust_mtu(struct rxrpc_peer *peer, unsigned int mtu)\n{\n\t \n\tif (mtu > 0 && peer->if_mtu == 65535 && mtu < peer->if_mtu)\n\t\tpeer->if_mtu = mtu;\n\n\tif (mtu == 0) {\n\t\t \n\t\tmtu = peer->if_mtu;\n\t\tif (mtu > 1500) {\n\t\t\tmtu >>= 1;\n\t\t\tif (mtu < 1500)\n\t\t\t\tmtu = 1500;\n\t\t} else {\n\t\t\tmtu -= 100;\n\t\t\tif (mtu < peer->hdrsize)\n\t\t\t\tmtu = peer->hdrsize + 4;\n\t\t}\n\t}\n\n\tif (mtu < peer->mtu) {\n\t\tspin_lock(&peer->lock);\n\t\tpeer->mtu = mtu;\n\t\tpeer->maxdata = peer->mtu - peer->hdrsize;\n\t\tspin_unlock(&peer->lock);\n\t}\n}\n\n \nvoid rxrpc_input_error(struct rxrpc_local *local, struct sk_buff *skb)\n{\n\tstruct sock_exterr_skb *serr = SKB_EXT_ERR(skb);\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_peer *peer = NULL;\n\n\t_enter(\"L=%x\", local->debug_id);\n\n\tif (!skb->len && serr->ee.ee_origin == SO_EE_ORIGIN_TIMESTAMPING) {\n\t\t_leave(\"UDP empty message\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tpeer = rxrpc_lookup_peer_local_rcu(local, skb, &srx);\n\tif (peer && !rxrpc_get_peer_maybe(peer, rxrpc_peer_get_input_error))\n\t\tpeer = NULL;\n\trcu_read_unlock();\n\tif (!peer)\n\t\treturn;\n\n\ttrace_rxrpc_rx_icmp(peer, &serr->ee, &srx);\n\n\tif ((serr->ee.ee_origin == SO_EE_ORIGIN_ICMP &&\n\t     serr->ee.ee_type == ICMP_DEST_UNREACH &&\n\t     serr->ee.ee_code == ICMP_FRAG_NEEDED)) {\n\t\trxrpc_adjust_mtu(peer, serr->ee.ee_info);\n\t\tgoto out;\n\t}\n\n\trxrpc_store_error(peer, skb);\nout:\n\trxrpc_put_peer(peer, rxrpc_peer_put_input_error);\n}\n\n \nstatic void rxrpc_store_error(struct rxrpc_peer *peer, struct sk_buff *skb)\n{\n\tenum rxrpc_call_completion compl = RXRPC_CALL_NETWORK_ERROR;\n\tstruct sock_exterr_skb *serr = SKB_EXT_ERR(skb);\n\tstruct sock_extended_err *ee = &serr->ee;\n\tint err = ee->ee_errno;\n\n\t_enter(\"\");\n\n\tswitch (ee->ee_origin) {\n\tcase SO_EE_ORIGIN_NONE:\n\tcase SO_EE_ORIGIN_LOCAL:\n\t\tcompl = RXRPC_CALL_LOCAL_ERROR;\n\t\tbreak;\n\n\tcase SO_EE_ORIGIN_ICMP6:\n\t\tif (err == EACCES)\n\t\t\terr = EHOSTUNREACH;\n\t\tfallthrough;\n\tcase SO_EE_ORIGIN_ICMP:\n\tdefault:\n\t\tbreak;\n\t}\n\n\trxrpc_distribute_error(peer, skb, compl, err);\n}\n\n \nstatic void rxrpc_distribute_error(struct rxrpc_peer *peer, struct sk_buff *skb,\n\t\t\t\t   enum rxrpc_call_completion compl, int err)\n{\n\tstruct rxrpc_call *call;\n\tHLIST_HEAD(error_targets);\n\n\tspin_lock(&peer->lock);\n\thlist_move_list(&peer->error_targets, &error_targets);\n\n\twhile (!hlist_empty(&error_targets)) {\n\t\tcall = hlist_entry(error_targets.first,\n\t\t\t\t   struct rxrpc_call, error_link);\n\t\thlist_del_init(&call->error_link);\n\t\tspin_unlock(&peer->lock);\n\n\t\trxrpc_see_call(call, rxrpc_call_see_distribute_error);\n\t\trxrpc_set_call_completion(call, compl, 0, -err);\n\t\trxrpc_input_call_event(call, skb);\n\n\t\tspin_lock(&peer->lock);\n\t}\n\n\tspin_unlock(&peer->lock);\n}\n\n \nstatic void rxrpc_peer_keepalive_dispatch(struct rxrpc_net *rxnet,\n\t\t\t\t\t  struct list_head *collector,\n\t\t\t\t\t  time64_t base,\n\t\t\t\t\t  u8 cursor)\n{\n\tstruct rxrpc_peer *peer;\n\tconst u8 mask = ARRAY_SIZE(rxnet->peer_keepalive) - 1;\n\ttime64_t keepalive_at;\n\tbool use;\n\tint slot;\n\n\tspin_lock(&rxnet->peer_hash_lock);\n\n\twhile (!list_empty(collector)) {\n\t\tpeer = list_entry(collector->next,\n\t\t\t\t  struct rxrpc_peer, keepalive_link);\n\n\t\tlist_del_init(&peer->keepalive_link);\n\t\tif (!rxrpc_get_peer_maybe(peer, rxrpc_peer_get_keepalive))\n\t\t\tcontinue;\n\n\t\tuse = __rxrpc_use_local(peer->local, rxrpc_local_use_peer_keepalive);\n\t\tspin_unlock(&rxnet->peer_hash_lock);\n\n\t\tif (use) {\n\t\t\tkeepalive_at = peer->last_tx_at + RXRPC_KEEPALIVE_TIME;\n\t\t\tslot = keepalive_at - base;\n\t\t\t_debug(\"%02x peer %u t=%d {%pISp}\",\n\t\t\t       cursor, peer->debug_id, slot, &peer->srx.transport);\n\n\t\t\tif (keepalive_at <= base ||\n\t\t\t    keepalive_at > base + RXRPC_KEEPALIVE_TIME) {\n\t\t\t\trxrpc_send_keepalive(peer);\n\t\t\t\tslot = RXRPC_KEEPALIVE_TIME;\n\t\t\t}\n\n\t\t\t \n\t\t\tslot += cursor;\n\t\t\tslot &= mask;\n\t\t\tspin_lock(&rxnet->peer_hash_lock);\n\t\t\tlist_add_tail(&peer->keepalive_link,\n\t\t\t\t      &rxnet->peer_keepalive[slot & mask]);\n\t\t\tspin_unlock(&rxnet->peer_hash_lock);\n\t\t\trxrpc_unuse_local(peer->local, rxrpc_local_unuse_peer_keepalive);\n\t\t}\n\t\trxrpc_put_peer(peer, rxrpc_peer_put_keepalive);\n\t\tspin_lock(&rxnet->peer_hash_lock);\n\t}\n\n\tspin_unlock(&rxnet->peer_hash_lock);\n}\n\n \nvoid rxrpc_peer_keepalive_worker(struct work_struct *work)\n{\n\tstruct rxrpc_net *rxnet =\n\t\tcontainer_of(work, struct rxrpc_net, peer_keepalive_work);\n\tconst u8 mask = ARRAY_SIZE(rxnet->peer_keepalive) - 1;\n\ttime64_t base, now, delay;\n\tu8 cursor, stop;\n\tLIST_HEAD(collector);\n\n\tnow = ktime_get_seconds();\n\tbase = rxnet->peer_keepalive_base;\n\tcursor = rxnet->peer_keepalive_cursor;\n\t_enter(\"%lld,%u\", base - now, cursor);\n\n\tif (!rxnet->live)\n\t\treturn;\n\n\t \n\tspin_lock(&rxnet->peer_hash_lock);\n\tlist_splice_init(&rxnet->peer_keepalive_new, &collector);\n\n\tstop = cursor + ARRAY_SIZE(rxnet->peer_keepalive);\n\twhile (base <= now && (s8)(cursor - stop) < 0) {\n\t\tlist_splice_tail_init(&rxnet->peer_keepalive[cursor & mask],\n\t\t\t\t      &collector);\n\t\tbase++;\n\t\tcursor++;\n\t}\n\n\tbase = now;\n\tspin_unlock(&rxnet->peer_hash_lock);\n\n\trxnet->peer_keepalive_base = base;\n\trxnet->peer_keepalive_cursor = cursor;\n\trxrpc_peer_keepalive_dispatch(rxnet, &collector, base, cursor);\n\tASSERT(list_empty(&collector));\n\n\t \n\tcursor = rxnet->peer_keepalive_cursor;\n\tstop = cursor + RXRPC_KEEPALIVE_TIME - 1;\n\tfor (; (s8)(cursor - stop) < 0; cursor++) {\n\t\tif (!list_empty(&rxnet->peer_keepalive[cursor & mask]))\n\t\t\tbreak;\n\t\tbase++;\n\t}\n\n\tnow = ktime_get_seconds();\n\tdelay = base - now;\n\tif (delay < 1)\n\t\tdelay = 1;\n\tdelay *= HZ;\n\tif (rxnet->live)\n\t\ttimer_reduce(&rxnet->peer_keepalive_timer, jiffies + delay);\n\n\t_leave(\"\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}