{
  "module_name": "local_object.c",
  "hash_id": "e1178edc45ed057a61aded5ec5628877cd9d6b1aefd61fd3297f2d0b3af758e6",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/local_object.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/udp.h>\n#include <linux/ip.h>\n#include <linux/hashtable.h>\n#include <net/sock.h>\n#include <net/udp.h>\n#include <net/udp_tunnel.h>\n#include <net/af_rxrpc.h>\n#include \"ar-internal.h\"\n\nstatic void rxrpc_local_rcu(struct rcu_head *);\n\n \nstatic void rxrpc_encap_err_rcv(struct sock *sk, struct sk_buff *skb, int err,\n\t\t\t\t__be16 port, u32 info, u8 *payload)\n{\n\tif (ip_hdr(skb)->version == IPVERSION)\n\t\treturn ip_icmp_error(sk, skb, err, port, info, payload);\n\tif (IS_ENABLED(CONFIG_AF_RXRPC_IPV6))\n\t\treturn ipv6_icmp_error(sk, skb, err, port, info, payload);\n}\n\n \nvoid rxrpc_local_dont_fragment(const struct rxrpc_local *local, bool set)\n{\n\tif (set)\n\t\tip_sock_set_mtu_discover(local->socket->sk, IP_PMTUDISC_DO);\n\telse\n\t\tip_sock_set_mtu_discover(local->socket->sk, IP_PMTUDISC_DONT);\n}\n\n \nstatic long rxrpc_local_cmp_key(const struct rxrpc_local *local,\n\t\t\t\tconst struct sockaddr_rxrpc *srx)\n{\n\tlong diff;\n\n\tdiff = ((local->srx.transport_type - srx->transport_type) ?:\n\t\t(local->srx.transport_len - srx->transport_len) ?:\n\t\t(local->srx.transport.family - srx->transport.family));\n\tif (diff != 0)\n\t\treturn diff;\n\n\tswitch (srx->transport.family) {\n\tcase AF_INET:\n\t\t \n\t\treturn ((u16 __force)local->srx.transport.sin.sin_port -\n\t\t\t(u16 __force)srx->transport.sin.sin_port) ?:\n\t\t\tmemcmp(&local->srx.transport.sin.sin_addr,\n\t\t\t       &srx->transport.sin.sin_addr,\n\t\t\t       sizeof(struct in_addr));\n#ifdef CONFIG_AF_RXRPC_IPV6\n\tcase AF_INET6:\n\t\t \n\t\treturn ((u16 __force)local->srx.transport.sin6.sin6_port -\n\t\t\t(u16 __force)srx->transport.sin6.sin6_port) ?:\n\t\t\tmemcmp(&local->srx.transport.sin6.sin6_addr,\n\t\t\t       &srx->transport.sin6.sin6_addr,\n\t\t\t       sizeof(struct in6_addr));\n#endif\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic void rxrpc_client_conn_reap_timeout(struct timer_list *timer)\n{\n\tstruct rxrpc_local *local =\n\t\tcontainer_of(timer, struct rxrpc_local, client_conn_reap_timer);\n\n\tif (!local->kill_all_client_conns &&\n\t    test_and_set_bit(RXRPC_CLIENT_CONN_REAP_TIMER, &local->client_conn_flags))\n\t\trxrpc_wake_up_io_thread(local);\n}\n\n \nstatic struct rxrpc_local *rxrpc_alloc_local(struct net *net,\n\t\t\t\t\t     const struct sockaddr_rxrpc *srx)\n{\n\tstruct rxrpc_local *local;\n\tu32 tmp;\n\n\tlocal = kzalloc(sizeof(struct rxrpc_local), GFP_KERNEL);\n\tif (local) {\n\t\trefcount_set(&local->ref, 1);\n\t\tatomic_set(&local->active_users, 1);\n\t\tlocal->net = net;\n\t\tlocal->rxnet = rxrpc_net(net);\n\t\tINIT_HLIST_NODE(&local->link);\n\t\tinit_completion(&local->io_thread_ready);\n#ifdef CONFIG_AF_RXRPC_INJECT_RX_DELAY\n\t\tskb_queue_head_init(&local->rx_delay_queue);\n#endif\n\t\tskb_queue_head_init(&local->rx_queue);\n\t\tINIT_LIST_HEAD(&local->conn_attend_q);\n\t\tINIT_LIST_HEAD(&local->call_attend_q);\n\n\t\tlocal->client_bundles = RB_ROOT;\n\t\tspin_lock_init(&local->client_bundles_lock);\n\t\tlocal->kill_all_client_conns = false;\n\t\tINIT_LIST_HEAD(&local->idle_client_conns);\n\t\ttimer_setup(&local->client_conn_reap_timer,\n\t\t\t    rxrpc_client_conn_reap_timeout, 0);\n\n\t\tspin_lock_init(&local->lock);\n\t\trwlock_init(&local->services_lock);\n\t\tlocal->debug_id = atomic_inc_return(&rxrpc_debug_id);\n\t\tmemcpy(&local->srx, srx, sizeof(*srx));\n\t\tlocal->srx.srx_service = 0;\n\t\tidr_init(&local->conn_ids);\n\t\tget_random_bytes(&tmp, sizeof(tmp));\n\t\ttmp &= 0x3fffffff;\n\t\tif (tmp == 0)\n\t\t\ttmp = 1;\n\t\tidr_set_cursor(&local->conn_ids, tmp);\n\t\tINIT_LIST_HEAD(&local->new_client_calls);\n\t\tspin_lock_init(&local->client_call_lock);\n\n\t\ttrace_rxrpc_local(local->debug_id, rxrpc_local_new, 1, 1);\n\t}\n\n\t_leave(\" = %p\", local);\n\treturn local;\n}\n\n \nstatic int rxrpc_open_socket(struct rxrpc_local *local, struct net *net)\n{\n\tstruct udp_tunnel_sock_cfg tuncfg = {NULL};\n\tstruct sockaddr_rxrpc *srx = &local->srx;\n\tstruct udp_port_cfg udp_conf = {0};\n\tstruct task_struct *io_thread;\n\tstruct sock *usk;\n\tint ret;\n\n\t_enter(\"%p{%d,%d}\",\n\t       local, srx->transport_type, srx->transport.family);\n\n\tudp_conf.family = srx->transport.family;\n\tudp_conf.use_udp_checksums = true;\n\tif (udp_conf.family == AF_INET) {\n\t\tudp_conf.local_ip = srx->transport.sin.sin_addr;\n\t\tudp_conf.local_udp_port = srx->transport.sin.sin_port;\n#if IS_ENABLED(CONFIG_AF_RXRPC_IPV6)\n\t} else {\n\t\tudp_conf.local_ip6 = srx->transport.sin6.sin6_addr;\n\t\tudp_conf.local_udp_port = srx->transport.sin6.sin6_port;\n\t\tudp_conf.use_udp6_tx_checksums = true;\n\t\tudp_conf.use_udp6_rx_checksums = true;\n#endif\n\t}\n\tret = udp_sock_create(net, &udp_conf, &local->socket);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [socket]\", ret);\n\t\treturn ret;\n\t}\n\n\ttuncfg.encap_type = UDP_ENCAP_RXRPC;\n\ttuncfg.encap_rcv = rxrpc_encap_rcv;\n\ttuncfg.encap_err_rcv = rxrpc_encap_err_rcv;\n\ttuncfg.sk_user_data = local;\n\tsetup_udp_tunnel_sock(net, local->socket, &tuncfg);\n\n\t \n\tusk = local->socket->sk;\n\tusk->sk_error_report = rxrpc_error_report;\n\n\tswitch (srx->transport.family) {\n\tcase AF_INET6:\n\t\t \n\t\tip6_sock_set_recverr(usk);\n\n\t\t \n\t\tfallthrough;\n\tcase AF_INET:\n\t\t \n\t\tip_sock_set_recverr(usk);\n\n\t\t \n\t\trxrpc_local_dont_fragment(local, true);\n\n\t\t \n\t\tsock_enable_timestamps(usk);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\tio_thread = kthread_run(rxrpc_io_thread, local,\n\t\t\t\t\"krxrpcio/%u\", ntohs(udp_conf.local_udp_port));\n\tif (IS_ERR(io_thread)) {\n\t\tret = PTR_ERR(io_thread);\n\t\tgoto error_sock;\n\t}\n\n\twait_for_completion(&local->io_thread_ready);\n\tlocal->io_thread = io_thread;\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_sock:\n\tkernel_sock_shutdown(local->socket, SHUT_RDWR);\n\tlocal->socket->sk->sk_user_data = NULL;\n\tsock_release(local->socket);\n\tlocal->socket = NULL;\n\treturn ret;\n}\n\n \nstruct rxrpc_local *rxrpc_lookup_local(struct net *net,\n\t\t\t\t       const struct sockaddr_rxrpc *srx)\n{\n\tstruct rxrpc_local *local;\n\tstruct rxrpc_net *rxnet = rxrpc_net(net);\n\tstruct hlist_node *cursor;\n\tlong diff;\n\tint ret;\n\n\t_enter(\"{%d,%d,%pISp}\",\n\t       srx->transport_type, srx->transport.family, &srx->transport);\n\n\tmutex_lock(&rxnet->local_mutex);\n\n\thlist_for_each(cursor, &rxnet->local_endpoints) {\n\t\tlocal = hlist_entry(cursor, struct rxrpc_local, link);\n\n\t\tdiff = rxrpc_local_cmp_key(local, srx);\n\t\tif (diff != 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (srx->srx_service) {\n\t\t\tlocal = NULL;\n\t\t\tgoto addr_in_use;\n\t\t}\n\n\t\t \n\t\tif (!rxrpc_use_local(local, rxrpc_local_use_lookup))\n\t\t\tbreak;\n\n\t\tgoto found;\n\t}\n\n\tlocal = rxrpc_alloc_local(net, srx);\n\tif (!local)\n\t\tgoto nomem;\n\n\tret = rxrpc_open_socket(local, net);\n\tif (ret < 0)\n\t\tgoto sock_error;\n\n\tif (cursor) {\n\t\thlist_replace_rcu(cursor, &local->link);\n\t\tcursor->pprev = NULL;\n\t} else {\n\t\thlist_add_head_rcu(&local->link, &rxnet->local_endpoints);\n\t}\n\nfound:\n\tmutex_unlock(&rxnet->local_mutex);\n\t_leave(\" = %p\", local);\n\treturn local;\n\nnomem:\n\tret = -ENOMEM;\nsock_error:\n\tmutex_unlock(&rxnet->local_mutex);\n\tif (local)\n\t\tcall_rcu(&local->rcu, rxrpc_local_rcu);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n\naddr_in_use:\n\tmutex_unlock(&rxnet->local_mutex);\n\t_leave(\" = -EADDRINUSE\");\n\treturn ERR_PTR(-EADDRINUSE);\n}\n\n \nstruct rxrpc_local *rxrpc_get_local(struct rxrpc_local *local,\n\t\t\t\t    enum rxrpc_local_trace why)\n{\n\tint r, u;\n\n\tu = atomic_read(&local->active_users);\n\t__refcount_inc(&local->ref, &r);\n\ttrace_rxrpc_local(local->debug_id, why, r + 1, u);\n\treturn local;\n}\n\n \nstruct rxrpc_local *rxrpc_get_local_maybe(struct rxrpc_local *local,\n\t\t\t\t\t  enum rxrpc_local_trace why)\n{\n\tint r, u;\n\n\tif (local && __refcount_inc_not_zero(&local->ref, &r)) {\n\t\tu = atomic_read(&local->active_users);\n\t\ttrace_rxrpc_local(local->debug_id, why, r + 1, u);\n\t\treturn local;\n\t}\n\n\treturn NULL;\n}\n\n \nvoid rxrpc_put_local(struct rxrpc_local *local, enum rxrpc_local_trace why)\n{\n\tunsigned int debug_id;\n\tbool dead;\n\tint r, u;\n\n\tif (local) {\n\t\tdebug_id = local->debug_id;\n\n\t\tu = atomic_read(&local->active_users);\n\t\tdead = __refcount_dec_and_test(&local->ref, &r);\n\t\ttrace_rxrpc_local(debug_id, why, r, u);\n\n\t\tif (dead)\n\t\t\tcall_rcu(&local->rcu, rxrpc_local_rcu);\n\t}\n}\n\n \nstruct rxrpc_local *rxrpc_use_local(struct rxrpc_local *local,\n\t\t\t\t    enum rxrpc_local_trace why)\n{\n\tlocal = rxrpc_get_local_maybe(local, rxrpc_local_get_for_use);\n\tif (!local)\n\t\treturn NULL;\n\n\tif (!__rxrpc_use_local(local, why)) {\n\t\trxrpc_put_local(local, rxrpc_local_put_for_use);\n\t\treturn NULL;\n\t}\n\n\treturn local;\n}\n\n \nvoid rxrpc_unuse_local(struct rxrpc_local *local, enum rxrpc_local_trace why)\n{\n\tunsigned int debug_id;\n\tint r, u;\n\n\tif (local) {\n\t\tdebug_id = local->debug_id;\n\t\tr = refcount_read(&local->ref);\n\t\tu = atomic_dec_return(&local->active_users);\n\t\ttrace_rxrpc_local(debug_id, why, r, u);\n\t\tif (u == 0)\n\t\t\tkthread_stop(local->io_thread);\n\t}\n}\n\n \nvoid rxrpc_destroy_local(struct rxrpc_local *local)\n{\n\tstruct socket *socket = local->socket;\n\tstruct rxrpc_net *rxnet = local->rxnet;\n\n\t_enter(\"%d\", local->debug_id);\n\n\tlocal->dead = true;\n\n\tmutex_lock(&rxnet->local_mutex);\n\thlist_del_init_rcu(&local->link);\n\tmutex_unlock(&rxnet->local_mutex);\n\n\trxrpc_clean_up_local_conns(local);\n\trxrpc_service_connection_reaper(&rxnet->service_conn_reaper);\n\tASSERT(!local->service);\n\n\tif (socket) {\n\t\tlocal->socket = NULL;\n\t\tkernel_sock_shutdown(socket, SHUT_RDWR);\n\t\tsocket->sk->sk_user_data = NULL;\n\t\tsock_release(socket);\n\t}\n\n\t \n#ifdef CONFIG_AF_RXRPC_INJECT_RX_DELAY\n\trxrpc_purge_queue(&local->rx_delay_queue);\n#endif\n\trxrpc_purge_queue(&local->rx_queue);\n\trxrpc_purge_client_connections(local);\n}\n\n \nstatic void rxrpc_local_rcu(struct rcu_head *rcu)\n{\n\tstruct rxrpc_local *local = container_of(rcu, struct rxrpc_local, rcu);\n\n\trxrpc_see_local(local, rxrpc_local_free);\n\tkfree(local);\n}\n\n \nvoid rxrpc_destroy_all_locals(struct rxrpc_net *rxnet)\n{\n\tstruct rxrpc_local *local;\n\n\t_enter(\"\");\n\n\tflush_workqueue(rxrpc_workqueue);\n\n\tif (!hlist_empty(&rxnet->local_endpoints)) {\n\t\tmutex_lock(&rxnet->local_mutex);\n\t\thlist_for_each_entry(local, &rxnet->local_endpoints, link) {\n\t\t\tpr_err(\"AF_RXRPC: Leaked local %p {%d}\\n\",\n\t\t\t       local, refcount_read(&local->ref));\n\t\t}\n\t\tmutex_unlock(&rxnet->local_mutex);\n\t\tBUG();\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}