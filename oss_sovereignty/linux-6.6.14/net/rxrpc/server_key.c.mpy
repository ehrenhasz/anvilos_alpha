{
  "module_name": "server_key.c",
  "hash_id": "ccfbb3b3c3bf9a4414694f0739344fa10dc3f37387f32b173867b8fa071ece54",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/server_key.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <crypto/skcipher.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/key-type.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include <keys/rxrpc-type.h>\n#include <keys/user-type.h>\n#include \"ar-internal.h\"\n\nstatic int rxrpc_vet_description_s(const char *);\nstatic int rxrpc_preparse_s(struct key_preparsed_payload *);\nstatic void rxrpc_free_preparse_s(struct key_preparsed_payload *);\nstatic void rxrpc_destroy_s(struct key *);\nstatic void rxrpc_describe_s(const struct key *, struct seq_file *);\n\n \nstruct key_type key_type_rxrpc_s = {\n\t.name\t\t= \"rxrpc_s\",\n\t.flags\t\t= KEY_TYPE_NET_DOMAIN,\n\t.vet_description = rxrpc_vet_description_s,\n\t.preparse\t= rxrpc_preparse_s,\n\t.free_preparse\t= rxrpc_free_preparse_s,\n\t.instantiate\t= generic_key_instantiate,\n\t.destroy\t= rxrpc_destroy_s,\n\t.describe\t= rxrpc_describe_s,\n};\n\n \nstatic int rxrpc_vet_description_s(const char *desc)\n{\n\tunsigned long service, sec_class;\n\tchar *p;\n\n\tservice = simple_strtoul(desc, &p, 10);\n\tif (*p != ':' || service > 65535)\n\t\treturn -EINVAL;\n\tsec_class = simple_strtoul(p + 1, &p, 10);\n\tif ((*p && *p != ':') || sec_class < 1 || sec_class > 255)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int rxrpc_preparse_s(struct key_preparsed_payload *prep)\n{\n\tconst struct rxrpc_security *sec;\n\tunsigned int service, sec_class;\n\tint n;\n\n\t_enter(\"%zu\", prep->datalen);\n\n\tif (!prep->orig_description)\n\t\treturn -EINVAL;\n\n\tif (sscanf(prep->orig_description, \"%u:%u%n\", &service, &sec_class, &n) != 2)\n\t\treturn -EINVAL;\n\n\tsec = rxrpc_security_lookup(sec_class);\n\tif (!sec)\n\t\treturn -ENOPKG;\n\n\tprep->payload.data[1] = (struct rxrpc_security *)sec;\n\n\tif (!sec->preparse_server_key)\n\t\treturn -EINVAL;\n\n\treturn sec->preparse_server_key(prep);\n}\n\nstatic void rxrpc_free_preparse_s(struct key_preparsed_payload *prep)\n{\n\tconst struct rxrpc_security *sec = prep->payload.data[1];\n\n\tif (sec && sec->free_preparse_server_key)\n\t\tsec->free_preparse_server_key(prep);\n}\n\nstatic void rxrpc_destroy_s(struct key *key)\n{\n\tconst struct rxrpc_security *sec = key->payload.data[1];\n\n\tif (sec && sec->destroy_server_key)\n\t\tsec->destroy_server_key(key);\n}\n\nstatic void rxrpc_describe_s(const struct key *key, struct seq_file *m)\n{\n\tconst struct rxrpc_security *sec = key->payload.data[1];\n\n\tseq_puts(m, key->description);\n\tif (sec && sec->describe_server_key)\n\t\tsec->describe_server_key(key, m);\n}\n\n \nint rxrpc_server_keyring(struct rxrpc_sock *rx, sockptr_t optval, int optlen)\n{\n\tstruct key *key;\n\tchar *description;\n\n\t_enter(\"\");\n\n\tif (optlen <= 0 || optlen > PAGE_SIZE - 1)\n\t\treturn -EINVAL;\n\n\tdescription = memdup_sockptr_nul(optval, optlen);\n\tif (IS_ERR(description))\n\t\treturn PTR_ERR(description);\n\n\tkey = request_key(&key_type_keyring, description, NULL);\n\tif (IS_ERR(key)) {\n\t\tkfree(description);\n\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\trx->securities = key;\n\tkfree(description);\n\t_leave(\" = 0 [key %x]\", key->serial);\n\treturn 0;\n}\n\n \nint rxrpc_sock_set_security_keyring(struct sock *sk, struct key *keyring)\n{\n\tstruct rxrpc_sock *rx = rxrpc_sk(sk);\n\tint ret = 0;\n\n\tlock_sock(sk);\n\tif (rx->securities)\n\t\tret = -EINVAL;\n\telse if (rx->sk.sk_state != RXRPC_UNBOUND)\n\t\tret = -EISCONN;\n\telse\n\t\trx->securities = key_get(keyring);\n\trelease_sock(sk);\n\treturn ret;\n}\nEXPORT_SYMBOL(rxrpc_sock_set_security_keyring);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}