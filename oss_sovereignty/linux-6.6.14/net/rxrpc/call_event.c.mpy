{
  "module_name": "call_event.c",
  "hash_id": "35499de964ae700941ee51dc256d75894de9325d260df6cbef6b5af7b073c8e7",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/call_event.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/circ_buf.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/udp.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include \"ar-internal.h\"\n\n \nvoid rxrpc_propose_ping(struct rxrpc_call *call, u32 serial,\n\t\t\tenum rxrpc_propose_ack_trace why)\n{\n\tunsigned long now = jiffies;\n\tunsigned long ping_at = now + rxrpc_idle_ack_delay;\n\n\tif (time_before(ping_at, call->ping_at)) {\n\t\tWRITE_ONCE(call->ping_at, ping_at);\n\t\trxrpc_reduce_call_timer(call, ping_at, now,\n\t\t\t\t\trxrpc_timer_set_for_ping);\n\t\ttrace_rxrpc_propose_ack(call, why, RXRPC_ACK_PING, serial);\n\t}\n}\n\n \nvoid rxrpc_propose_delay_ACK(struct rxrpc_call *call, rxrpc_serial_t serial,\n\t\t\t     enum rxrpc_propose_ack_trace why)\n{\n\tunsigned long expiry = rxrpc_soft_ack_delay;\n\tunsigned long now = jiffies, ack_at;\n\n\tcall->ackr_serial = serial;\n\n\tif (rxrpc_soft_ack_delay < expiry)\n\t\texpiry = rxrpc_soft_ack_delay;\n\tif (call->peer->srtt_us != 0)\n\t\tack_at = usecs_to_jiffies(call->peer->srtt_us >> 3);\n\telse\n\t\tack_at = expiry;\n\n\tack_at += READ_ONCE(call->tx_backoff);\n\tack_at += now;\n\tif (time_before(ack_at, call->delay_ack_at)) {\n\t\tWRITE_ONCE(call->delay_ack_at, ack_at);\n\t\trxrpc_reduce_call_timer(call, ack_at, now,\n\t\t\t\t\trxrpc_timer_set_for_ack);\n\t}\n\n\ttrace_rxrpc_propose_ack(call, why, RXRPC_ACK_DELAY, serial);\n}\n\n \nvoid rxrpc_send_ACK(struct rxrpc_call *call, u8 ack_reason,\n\t\t    rxrpc_serial_t serial, enum rxrpc_propose_ack_trace why)\n{\n\tstruct rxrpc_txbuf *txb;\n\n\tif (test_bit(RXRPC_CALL_DISCONNECTED, &call->flags))\n\t\treturn;\n\n\trxrpc_inc_stat(call->rxnet, stat_tx_acks[ack_reason]);\n\n\ttxb = rxrpc_alloc_txbuf(call, RXRPC_PACKET_TYPE_ACK,\n\t\t\t\trcu_read_lock_held() ? GFP_ATOMIC | __GFP_NOWARN : GFP_NOFS);\n\tif (!txb) {\n\t\tkleave(\" = -ENOMEM\");\n\t\treturn;\n\t}\n\n\ttxb->ack_why\t\t= why;\n\ttxb->wire.seq\t\t= 0;\n\ttxb->wire.type\t\t= RXRPC_PACKET_TYPE_ACK;\n\ttxb->wire.flags\t\t|= RXRPC_SLOW_START_OK;\n\ttxb->ack.bufferSpace\t= 0;\n\ttxb->ack.maxSkew\t= 0;\n\ttxb->ack.firstPacket\t= 0;\n\ttxb->ack.previousPacket\t= 0;\n\ttxb->ack.serial\t\t= htonl(serial);\n\ttxb->ack.reason\t\t= ack_reason;\n\ttxb->ack.nAcks\t\t= 0;\n\n\ttrace_rxrpc_send_ack(call, why, ack_reason, serial);\n\trxrpc_send_ack_packet(call, txb);\n\trxrpc_put_txbuf(txb, rxrpc_txbuf_put_ack_tx);\n}\n\n \nstatic void rxrpc_congestion_timeout(struct rxrpc_call *call)\n{\n\tset_bit(RXRPC_CALL_RETRANS_TIMEOUT, &call->flags);\n}\n\n \nvoid rxrpc_resend(struct rxrpc_call *call, struct sk_buff *ack_skb)\n{\n\tstruct rxrpc_ackpacket *ack = NULL;\n\tstruct rxrpc_txbuf *txb;\n\tunsigned long resend_at;\n\trxrpc_seq_t transmitted = READ_ONCE(call->tx_transmitted);\n\tktime_t now, max_age, oldest, ack_ts;\n\tbool unacked = false;\n\tunsigned int i;\n\tLIST_HEAD(retrans_queue);\n\n\t_enter(\"{%d,%d}\", call->acks_hard_ack, call->tx_top);\n\n\tnow = ktime_get_real();\n\tmax_age = ktime_sub_us(now, jiffies_to_usecs(call->peer->rto_j));\n\toldest = now;\n\n\tif (list_empty(&call->tx_buffer))\n\t\tgoto no_resend;\n\n\tif (list_empty(&call->tx_buffer))\n\t\tgoto no_further_resend;\n\n\ttrace_rxrpc_resend(call, ack_skb);\n\ttxb = list_first_entry(&call->tx_buffer, struct rxrpc_txbuf, call_link);\n\n\t \n\tif (ack_skb) {\n\t\tack = (void *)ack_skb->data + sizeof(struct rxrpc_wire_header);\n\n\t\tfor (i = 0; i < ack->nAcks; i++) {\n\t\t\trxrpc_seq_t seq;\n\n\t\t\tif (ack->acks[i] & 1)\n\t\t\t\tcontinue;\n\t\t\tseq = ntohl(ack->firstPacket) + i;\n\t\t\tif (after(txb->seq, transmitted))\n\t\t\t\tbreak;\n\t\t\tif (after(txb->seq, seq))\n\t\t\t\tcontinue;  \n\t\t\tlist_for_each_entry_from(txb, &call->tx_buffer, call_link) {\n\t\t\t\tif (txb->seq == seq)\n\t\t\t\t\tgoto found_txb;\n\t\t\t}\n\t\t\tgoto no_further_resend;\n\n\t\tfound_txb:\n\t\t\tif (after(ntohl(txb->wire.serial), call->acks_highest_serial))\n\t\t\t\tcontinue;  \n\n\t\t\trxrpc_see_txbuf(txb, rxrpc_txbuf_see_unacked);\n\n\t\t\tif (list_empty(&txb->tx_link)) {\n\t\t\t\tlist_add_tail(&txb->tx_link, &retrans_queue);\n\t\t\t\tset_bit(RXRPC_TXBUF_RESENT, &txb->flags);\n\t\t\t}\n\n\t\t\ttrace_rxrpc_retransmit(call, txb->seq,\n\t\t\t\t\t       ktime_to_ns(ktime_sub(txb->last_sent,\n\t\t\t\t\t\t\t\t     max_age)));\n\n\t\t\tif (list_is_last(&txb->call_link, &call->tx_buffer))\n\t\t\t\tgoto no_further_resend;\n\t\t\ttxb = list_next_entry(txb, call_link);\n\t\t}\n\t}\n\n\t \n\tif (after_eq(READ_ONCE(call->acks_prev_seq), READ_ONCE(call->tx_transmitted)))\n\t\tgoto no_further_resend;\n\n\tlist_for_each_entry_from(txb, &call->tx_buffer, call_link) {\n\t\tif (before_eq(txb->seq, READ_ONCE(call->acks_prev_seq)))\n\t\t\tcontinue;\n\t\tif (after(txb->seq, READ_ONCE(call->tx_transmitted)))\n\t\t\tbreak;  \n\n\t\tif (ack && ack->reason == RXRPC_ACK_PING_RESPONSE &&\n\t\t    before(ntohl(txb->wire.serial), ntohl(ack->serial)))\n\t\t\tgoto do_resend;  \n\n\t\tif (ktime_after(txb->last_sent, max_age)) {\n\t\t\tif (ktime_before(txb->last_sent, oldest))\n\t\t\t\toldest = txb->last_sent;\n\t\t\tcontinue;\n\t\t}\n\n\tdo_resend:\n\t\tunacked = true;\n\t\tif (list_empty(&txb->tx_link)) {\n\t\t\tlist_add_tail(&txb->tx_link, &retrans_queue);\n\t\t\tset_bit(RXRPC_TXBUF_RESENT, &txb->flags);\n\t\t\trxrpc_inc_stat(call->rxnet, stat_tx_data_retrans);\n\t\t}\n\t}\n\nno_further_resend:\nno_resend:\n\tresend_at = nsecs_to_jiffies(ktime_to_ns(ktime_sub(now, oldest)));\n\tresend_at += jiffies + rxrpc_get_rto_backoff(call->peer,\n\t\t\t\t\t\t     !list_empty(&retrans_queue));\n\tWRITE_ONCE(call->resend_at, resend_at);\n\n\tif (unacked)\n\t\trxrpc_congestion_timeout(call);\n\n\t \n\tif (list_empty(&retrans_queue)) {\n\t\trxrpc_reduce_call_timer(call, resend_at, jiffies,\n\t\t\t\t\trxrpc_timer_set_for_resend);\n\t\tack_ts = ktime_sub(now, call->acks_latest_ts);\n\t\tif (ktime_to_us(ack_ts) < (call->peer->srtt_us >> 3))\n\t\t\tgoto out;\n\t\trxrpc_send_ACK(call, RXRPC_ACK_PING, 0,\n\t\t\t       rxrpc_propose_ack_ping_for_lost_ack);\n\t\tgoto out;\n\t}\n\n\t \n\twhile ((txb = list_first_entry_or_null(&retrans_queue,\n\t\t\t\t\t       struct rxrpc_txbuf, tx_link))) {\n\t\tlist_del_init(&txb->tx_link);\n\t\trxrpc_transmit_one(call, txb);\n\t}\n\nout:\n\t_leave(\"\");\n}\n\n \nstatic void rxrpc_begin_service_reply(struct rxrpc_call *call)\n{\n\tunsigned long now = jiffies;\n\n\trxrpc_set_call_state(call, RXRPC_CALL_SERVER_SEND_REPLY);\n\tWRITE_ONCE(call->delay_ack_at, now + MAX_JIFFY_OFFSET);\n\tif (call->ackr_reason == RXRPC_ACK_DELAY)\n\t\tcall->ackr_reason = 0;\n\ttrace_rxrpc_timer(call, rxrpc_timer_init_for_send_reply, now);\n}\n\n \nstatic void rxrpc_close_tx_phase(struct rxrpc_call *call)\n{\n\t_debug(\"________awaiting reply/ACK__________\");\n\n\tswitch (__rxrpc_call_state(call)) {\n\tcase RXRPC_CALL_CLIENT_SEND_REQUEST:\n\t\trxrpc_set_call_state(call, RXRPC_CALL_CLIENT_AWAIT_REPLY);\n\t\tbreak;\n\tcase RXRPC_CALL_SERVER_SEND_REPLY:\n\t\trxrpc_set_call_state(call, RXRPC_CALL_SERVER_AWAIT_ACK);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic bool rxrpc_tx_window_has_space(struct rxrpc_call *call)\n{\n\tunsigned int winsize = min_t(unsigned int, call->tx_winsize,\n\t\t\t\t     call->cong_cwnd + call->cong_extra);\n\trxrpc_seq_t window = call->acks_hard_ack, wtop = window + winsize;\n\trxrpc_seq_t tx_top = call->tx_top;\n\tint space;\n\n\tspace = wtop - tx_top;\n\treturn space > 0;\n}\n\n \nstatic void rxrpc_decant_prepared_tx(struct rxrpc_call *call)\n{\n\tstruct rxrpc_txbuf *txb;\n\n\tif (!test_bit(RXRPC_CALL_EXPOSED, &call->flags)) {\n\t\tif (list_empty(&call->tx_sendmsg))\n\t\t\treturn;\n\t\trxrpc_expose_client_call(call);\n\t}\n\n\twhile ((txb = list_first_entry_or_null(&call->tx_sendmsg,\n\t\t\t\t\t       struct rxrpc_txbuf, call_link))) {\n\t\tspin_lock(&call->tx_lock);\n\t\tlist_del(&txb->call_link);\n\t\tspin_unlock(&call->tx_lock);\n\n\t\tcall->tx_top = txb->seq;\n\t\tlist_add_tail(&txb->call_link, &call->tx_buffer);\n\n\t\tif (txb->wire.flags & RXRPC_LAST_PACKET)\n\t\t\trxrpc_close_tx_phase(call);\n\n\t\trxrpc_transmit_one(call, txb);\n\n\t\tif (!rxrpc_tx_window_has_space(call))\n\t\t\tbreak;\n\t}\n}\n\nstatic void rxrpc_transmit_some_data(struct rxrpc_call *call)\n{\n\tswitch (__rxrpc_call_state(call)) {\n\tcase RXRPC_CALL_SERVER_ACK_REQUEST:\n\t\tif (list_empty(&call->tx_sendmsg))\n\t\t\treturn;\n\t\trxrpc_begin_service_reply(call);\n\t\tfallthrough;\n\n\tcase RXRPC_CALL_SERVER_SEND_REPLY:\n\tcase RXRPC_CALL_CLIENT_SEND_REQUEST:\n\t\tif (!rxrpc_tx_window_has_space(call))\n\t\t\treturn;\n\t\tif (list_empty(&call->tx_sendmsg)) {\n\t\t\trxrpc_inc_stat(call->rxnet, stat_tx_data_underflow);\n\t\t\treturn;\n\t\t}\n\t\trxrpc_decant_prepared_tx(call);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\n \nstatic void rxrpc_send_initial_ping(struct rxrpc_call *call)\n{\n\tif (call->peer->rtt_count < 3 ||\n\t    ktime_before(ktime_add_ms(call->peer->rtt_last_req, 1000),\n\t\t\t ktime_get_real()))\n\t\trxrpc_send_ACK(call, RXRPC_ACK_PING, 0,\n\t\t\t       rxrpc_propose_ack_ping_for_params);\n}\n\n \nbool rxrpc_input_call_event(struct rxrpc_call *call, struct sk_buff *skb)\n{\n\tunsigned long now, next, t;\n\trxrpc_serial_t ackr_serial;\n\tbool resend = false, expired = false;\n\ts32 abort_code;\n\n\trxrpc_see_call(call, rxrpc_call_see_input);\n\n\t\n\t_enter(\"{%d,%s,%lx}\",\n\t       call->debug_id, rxrpc_call_states[__rxrpc_call_state(call)],\n\t       call->events);\n\n\tif (__rxrpc_call_is_complete(call))\n\t\tgoto out;\n\n\t \n\tabort_code = smp_load_acquire(&call->send_abort);\n\tif (abort_code) {\n\t\trxrpc_abort_call(call, 0, call->send_abort, call->send_abort_err,\n\t\t\t\t call->send_abort_why);\n\t\tgoto out;\n\t}\n\n\tif (skb && skb->mark == RXRPC_SKB_MARK_ERROR)\n\t\tgoto out;\n\n\t \n\tnow = jiffies;\n\tt = READ_ONCE(call->expect_rx_by);\n\tif (time_after_eq(now, t)) {\n\t\ttrace_rxrpc_timer(call, rxrpc_timer_exp_normal, now);\n\t\texpired = true;\n\t}\n\n\tt = READ_ONCE(call->expect_req_by);\n\tif (__rxrpc_call_state(call) == RXRPC_CALL_SERVER_RECV_REQUEST &&\n\t    time_after_eq(now, t)) {\n\t\ttrace_rxrpc_timer(call, rxrpc_timer_exp_idle, now);\n\t\texpired = true;\n\t}\n\n\tt = READ_ONCE(call->expect_term_by);\n\tif (time_after_eq(now, t)) {\n\t\ttrace_rxrpc_timer(call, rxrpc_timer_exp_hard, now);\n\t\texpired = true;\n\t}\n\n\tt = READ_ONCE(call->delay_ack_at);\n\tif (time_after_eq(now, t)) {\n\t\ttrace_rxrpc_timer(call, rxrpc_timer_exp_ack, now);\n\t\tcmpxchg(&call->delay_ack_at, t, now + MAX_JIFFY_OFFSET);\n\t\tackr_serial = xchg(&call->ackr_serial, 0);\n\t\trxrpc_send_ACK(call, RXRPC_ACK_DELAY, ackr_serial,\n\t\t\t       rxrpc_propose_ack_ping_for_lost_ack);\n\t}\n\n\tt = READ_ONCE(call->ack_lost_at);\n\tif (time_after_eq(now, t)) {\n\t\ttrace_rxrpc_timer(call, rxrpc_timer_exp_lost_ack, now);\n\t\tcmpxchg(&call->ack_lost_at, t, now + MAX_JIFFY_OFFSET);\n\t\tset_bit(RXRPC_CALL_EV_ACK_LOST, &call->events);\n\t}\n\n\tt = READ_ONCE(call->keepalive_at);\n\tif (time_after_eq(now, t)) {\n\t\ttrace_rxrpc_timer(call, rxrpc_timer_exp_keepalive, now);\n\t\tcmpxchg(&call->keepalive_at, t, now + MAX_JIFFY_OFFSET);\n\t\trxrpc_send_ACK(call, RXRPC_ACK_PING, 0,\n\t\t\t       rxrpc_propose_ack_ping_for_keepalive);\n\t}\n\n\tt = READ_ONCE(call->ping_at);\n\tif (time_after_eq(now, t)) {\n\t\ttrace_rxrpc_timer(call, rxrpc_timer_exp_ping, now);\n\t\tcmpxchg(&call->ping_at, t, now + MAX_JIFFY_OFFSET);\n\t\trxrpc_send_ACK(call, RXRPC_ACK_PING, 0,\n\t\t\t       rxrpc_propose_ack_ping_for_keepalive);\n\t}\n\n\tt = READ_ONCE(call->resend_at);\n\tif (time_after_eq(now, t)) {\n\t\ttrace_rxrpc_timer(call, rxrpc_timer_exp_resend, now);\n\t\tcmpxchg(&call->resend_at, t, now + MAX_JIFFY_OFFSET);\n\t\tresend = true;\n\t}\n\n\tif (skb)\n\t\trxrpc_input_call_packet(call, skb);\n\n\trxrpc_transmit_some_data(call);\n\n\tif (skb) {\n\t\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\n\t\tif (sp->hdr.type == RXRPC_PACKET_TYPE_ACK)\n\t\t\trxrpc_congestion_degrade(call);\n\t}\n\n\tif (test_and_clear_bit(RXRPC_CALL_EV_INITIAL_PING, &call->events))\n\t\trxrpc_send_initial_ping(call);\n\n\t \n\tif (expired) {\n\t\tif (test_bit(RXRPC_CALL_RX_HEARD, &call->flags) &&\n\t\t    (int)call->conn->hi_serial - (int)call->rx_serial > 0) {\n\t\t\ttrace_rxrpc_call_reset(call);\n\t\t\trxrpc_abort_call(call, 0, RX_CALL_DEAD, -ECONNRESET,\n\t\t\t\t\t rxrpc_abort_call_reset);\n\t\t} else {\n\t\t\trxrpc_abort_call(call, 0, RX_CALL_TIMEOUT, -ETIME,\n\t\t\t\t\t rxrpc_abort_call_timeout);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (test_and_clear_bit(RXRPC_CALL_EV_ACK_LOST, &call->events))\n\t\trxrpc_send_ACK(call, RXRPC_ACK_PING, 0,\n\t\t\t       rxrpc_propose_ack_ping_for_lost_ack);\n\n\tif (resend && __rxrpc_call_state(call) != RXRPC_CALL_CLIENT_RECV_REPLY)\n\t\trxrpc_resend(call, NULL);\n\n\tif (test_and_clear_bit(RXRPC_CALL_RX_IS_IDLE, &call->flags))\n\t\trxrpc_send_ACK(call, RXRPC_ACK_IDLE, 0,\n\t\t\t       rxrpc_propose_ack_rx_idle);\n\n\tif (call->ackr_nr_unacked > 2) {\n\t\tif (call->peer->rtt_count < 3)\n\t\t\trxrpc_send_ACK(call, RXRPC_ACK_PING, 0,\n\t\t\t\t       rxrpc_propose_ack_ping_for_rtt);\n\t\telse if (ktime_before(ktime_add_ms(call->peer->rtt_last_req, 1000),\n\t\t\t\t      ktime_get_real()))\n\t\t\trxrpc_send_ACK(call, RXRPC_ACK_PING, 0,\n\t\t\t\t       rxrpc_propose_ack_ping_for_old_rtt);\n\t\telse\n\t\t\trxrpc_send_ACK(call, RXRPC_ACK_IDLE, 0,\n\t\t\t\t       rxrpc_propose_ack_input_data);\n\t}\n\n\t \n\tif (!__rxrpc_call_is_complete(call)) {\n\t\tnext = call->expect_rx_by;\n\n#define set(T) { t = READ_ONCE(T); if (time_before(t, next)) next = t; }\n\n\t\tset(call->expect_req_by);\n\t\tset(call->expect_term_by);\n\t\tset(call->delay_ack_at);\n\t\tset(call->ack_lost_at);\n\t\tset(call->resend_at);\n\t\tset(call->keepalive_at);\n\t\tset(call->ping_at);\n\n\t\tnow = jiffies;\n\t\tif (time_after_eq(now, next))\n\t\t\trxrpc_poke_call(call, rxrpc_call_poke_timer_now);\n\n\t\trxrpc_reduce_call_timer(call, next, now, rxrpc_timer_restart);\n\t}\n\nout:\n\tif (__rxrpc_call_is_complete(call)) {\n\t\tdel_timer_sync(&call->timer);\n\t\tif (!test_bit(RXRPC_CALL_DISCONNECTED, &call->flags))\n\t\t\trxrpc_disconnect_call(call);\n\t\tif (call->security)\n\t\t\tcall->security->free_call_crypto(call);\n\t}\n\tif (call->acks_hard_ack != call->tx_bottom)\n\t\trxrpc_shrink_call_tx_buffer(call);\n\t_leave(\"\");\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}