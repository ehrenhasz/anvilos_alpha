{
  "module_name": "txbuf.c",
  "hash_id": "782c9610b5c51bdcf8ecc76bf4ceb2a6f78f8234f8941a2d73f4ef232a666888",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/txbuf.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include \"ar-internal.h\"\n\nstatic atomic_t rxrpc_txbuf_debug_ids;\natomic_t rxrpc_nr_txbuf;\n\n \nstruct rxrpc_txbuf *rxrpc_alloc_txbuf(struct rxrpc_call *call, u8 packet_type,\n\t\t\t\t      gfp_t gfp)\n{\n\tstruct rxrpc_txbuf *txb;\n\n\ttxb = kmalloc(sizeof(*txb), gfp);\n\tif (txb) {\n\t\tINIT_LIST_HEAD(&txb->call_link);\n\t\tINIT_LIST_HEAD(&txb->tx_link);\n\t\trefcount_set(&txb->ref, 1);\n\t\ttxb->call_debug_id\t= call->debug_id;\n\t\ttxb->debug_id\t\t= atomic_inc_return(&rxrpc_txbuf_debug_ids);\n\t\ttxb->space\t\t= sizeof(txb->data);\n\t\ttxb->len\t\t= 0;\n\t\ttxb->offset\t\t= 0;\n\t\ttxb->flags\t\t= 0;\n\t\ttxb->ack_why\t\t= 0;\n\t\ttxb->seq\t\t= call->tx_prepared + 1;\n\t\ttxb->wire.epoch\t\t= htonl(call->conn->proto.epoch);\n\t\ttxb->wire.cid\t\t= htonl(call->cid);\n\t\ttxb->wire.callNumber\t= htonl(call->call_id);\n\t\ttxb->wire.seq\t\t= htonl(txb->seq);\n\t\ttxb->wire.type\t\t= packet_type;\n\t\ttxb->wire.flags\t\t= call->conn->out_clientflag;\n\t\ttxb->wire.userStatus\t= 0;\n\t\ttxb->wire.securityIndex\t= call->security_ix;\n\t\ttxb->wire._rsvd\t\t= 0;\n\t\ttxb->wire.serviceId\t= htons(call->dest_srx.srx_service);\n\n\t\ttrace_rxrpc_txbuf(txb->debug_id,\n\t\t\t\t  txb->call_debug_id, txb->seq, 1,\n\t\t\t\t  packet_type == RXRPC_PACKET_TYPE_DATA ?\n\t\t\t\t  rxrpc_txbuf_alloc_data :\n\t\t\t\t  rxrpc_txbuf_alloc_ack);\n\t\tatomic_inc(&rxrpc_nr_txbuf);\n\t}\n\n\treturn txb;\n}\n\nvoid rxrpc_get_txbuf(struct rxrpc_txbuf *txb, enum rxrpc_txbuf_trace what)\n{\n\tint r;\n\n\t__refcount_inc(&txb->ref, &r);\n\ttrace_rxrpc_txbuf(txb->debug_id, txb->call_debug_id, txb->seq, r + 1, what);\n}\n\nvoid rxrpc_see_txbuf(struct rxrpc_txbuf *txb, enum rxrpc_txbuf_trace what)\n{\n\tint r = refcount_read(&txb->ref);\n\n\ttrace_rxrpc_txbuf(txb->debug_id, txb->call_debug_id, txb->seq, r, what);\n}\n\nstatic void rxrpc_free_txbuf(struct rcu_head *rcu)\n{\n\tstruct rxrpc_txbuf *txb = container_of(rcu, struct rxrpc_txbuf, rcu);\n\n\ttrace_rxrpc_txbuf(txb->debug_id, txb->call_debug_id, txb->seq, 0,\n\t\t\t  rxrpc_txbuf_free);\n\tkfree(txb);\n\tatomic_dec(&rxrpc_nr_txbuf);\n}\n\nvoid rxrpc_put_txbuf(struct rxrpc_txbuf *txb, enum rxrpc_txbuf_trace what)\n{\n\tunsigned int debug_id, call_debug_id;\n\trxrpc_seq_t seq;\n\tbool dead;\n\tint r;\n\n\tif (txb) {\n\t\tdebug_id = txb->debug_id;\n\t\tcall_debug_id = txb->call_debug_id;\n\t\tseq = txb->seq;\n\t\tdead = __refcount_dec_and_test(&txb->ref, &r);\n\t\ttrace_rxrpc_txbuf(debug_id, call_debug_id, seq, r - 1, what);\n\t\tif (dead)\n\t\t\tcall_rcu(&txb->rcu, rxrpc_free_txbuf);\n\t}\n}\n\n \nvoid rxrpc_shrink_call_tx_buffer(struct rxrpc_call *call)\n{\n\tstruct rxrpc_txbuf *txb;\n\trxrpc_seq_t hard_ack = smp_load_acquire(&call->acks_hard_ack);\n\tbool wake = false;\n\n\t_enter(\"%x/%x/%x\", call->tx_bottom, call->acks_hard_ack, call->tx_top);\n\n\twhile ((txb = list_first_entry_or_null(&call->tx_buffer,\n\t\t\t\t\t       struct rxrpc_txbuf, call_link))) {\n\t\thard_ack = smp_load_acquire(&call->acks_hard_ack);\n\t\tif (before(hard_ack, txb->seq))\n\t\t\tbreak;\n\n\t\tif (txb->seq != call->tx_bottom + 1)\n\t\t\trxrpc_see_txbuf(txb, rxrpc_txbuf_see_out_of_step);\n\t\tASSERTCMP(txb->seq, ==, call->tx_bottom + 1);\n\t\tsmp_store_release(&call->tx_bottom, call->tx_bottom + 1);\n\t\tlist_del_rcu(&txb->call_link);\n\n\t\ttrace_rxrpc_txqueue(call, rxrpc_txqueue_dequeue);\n\n\t\trxrpc_put_txbuf(txb, rxrpc_txbuf_put_rotated);\n\t\tif (after(call->acks_hard_ack, call->tx_bottom + 128))\n\t\t\twake = true;\n\t}\n\n\tif (wake)\n\t\twake_up(&call->waitq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}