{
  "module_name": "conn_service.c",
  "hash_id": "505a3cf2f6b1f349f8dbe083fb150dac62188a64be072f1738da654abe6bc987",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/conn_service.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"ar-internal.h\"\n\n \nstruct rxrpc_connection *rxrpc_find_service_conn_rcu(struct rxrpc_peer *peer,\n\t\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct rxrpc_connection *conn = NULL;\n\tstruct rxrpc_conn_proto k;\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tstruct rb_node *p;\n\tunsigned int seq = 0;\n\n\tk.epoch\t= sp->hdr.epoch;\n\tk.cid\t= sp->hdr.cid & RXRPC_CIDMASK;\n\n\tdo {\n\t\t \n\t\tread_seqbegin_or_lock(&peer->service_conn_lock, &seq);\n\n\t\tp = rcu_dereference_raw(peer->service_conns.rb_node);\n\t\twhile (p) {\n\t\t\tconn = rb_entry(p, struct rxrpc_connection, service_node);\n\n\t\t\tif (conn->proto.index_key < k.index_key)\n\t\t\t\tp = rcu_dereference_raw(p->rb_left);\n\t\t\telse if (conn->proto.index_key > k.index_key)\n\t\t\t\tp = rcu_dereference_raw(p->rb_right);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\tconn = NULL;\n\t\t}\n\t} while (need_seqretry(&peer->service_conn_lock, seq));\n\n\tdone_seqretry(&peer->service_conn_lock, seq);\n\t_leave(\" = %d\", conn ? conn->debug_id : -1);\n\treturn conn;\n}\n\n \nstatic void rxrpc_publish_service_conn(struct rxrpc_peer *peer,\n\t\t\t\t       struct rxrpc_connection *conn)\n{\n\tstruct rxrpc_connection *cursor = NULL;\n\tstruct rxrpc_conn_proto k = conn->proto;\n\tstruct rb_node **pp, *parent;\n\n\twrite_seqlock(&peer->service_conn_lock);\n\n\tpp = &peer->service_conns.rb_node;\n\tparent = NULL;\n\twhile (*pp) {\n\t\tparent = *pp;\n\t\tcursor = rb_entry(parent,\n\t\t\t\t  struct rxrpc_connection, service_node);\n\n\t\tif (cursor->proto.index_key < k.index_key)\n\t\t\tpp = &(*pp)->rb_left;\n\t\telse if (cursor->proto.index_key > k.index_key)\n\t\t\tpp = &(*pp)->rb_right;\n\t\telse\n\t\t\tgoto found_extant_conn;\n\t}\n\n\trb_link_node_rcu(&conn->service_node, parent, pp);\n\trb_insert_color(&conn->service_node, &peer->service_conns);\nconn_published:\n\tset_bit(RXRPC_CONN_IN_SERVICE_CONNS, &conn->flags);\n\twrite_sequnlock(&peer->service_conn_lock);\n\t_leave(\" = %d [new]\", conn->debug_id);\n\treturn;\n\nfound_extant_conn:\n\tif (refcount_read(&cursor->ref) == 0)\n\t\tgoto replace_old_connection;\n\twrite_sequnlock(&peer->service_conn_lock);\n\t \n\tBUG();\n\nreplace_old_connection:\n\t \n\t_debug(\"replace conn\");\n\trb_replace_node_rcu(&cursor->service_node,\n\t\t\t    &conn->service_node,\n\t\t\t    &peer->service_conns);\n\tclear_bit(RXRPC_CONN_IN_SERVICE_CONNS, &cursor->flags);\n\tgoto conn_published;\n}\n\n \nstruct rxrpc_connection *rxrpc_prealloc_service_connection(struct rxrpc_net *rxnet,\n\t\t\t\t\t\t\t   gfp_t gfp)\n{\n\tstruct rxrpc_connection *conn = rxrpc_alloc_connection(rxnet, gfp);\n\n\tif (conn) {\n\t\t \n\t\tconn->state = RXRPC_CONN_SERVICE_PREALLOC;\n\t\trefcount_set(&conn->ref, 2);\n\n\t\tatomic_inc(&rxnet->nr_conns);\n\t\twrite_lock(&rxnet->conn_lock);\n\t\tlist_add_tail(&conn->link, &rxnet->service_conns);\n\t\tlist_add_tail(&conn->proc_link, &rxnet->conn_proc_list);\n\t\twrite_unlock(&rxnet->conn_lock);\n\n\t\trxrpc_see_connection(conn, rxrpc_conn_new_service);\n\t}\n\n\treturn conn;\n}\n\n \nvoid rxrpc_new_incoming_connection(struct rxrpc_sock *rx,\n\t\t\t\t   struct rxrpc_connection *conn,\n\t\t\t\t   const struct rxrpc_security *sec,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\n\t_enter(\"\");\n\n\tconn->proto.epoch\t= sp->hdr.epoch;\n\tconn->proto.cid\t\t= sp->hdr.cid & RXRPC_CIDMASK;\n\tconn->orig_service_id\t= sp->hdr.serviceId;\n\tconn->service_id\t= sp->hdr.serviceId;\n\tconn->security_ix\t= sp->hdr.securityIndex;\n\tconn->out_clientflag\t= 0;\n\tconn->security\t\t= sec;\n\tif (conn->security_ix)\n\t\tconn->state\t= RXRPC_CONN_SERVICE_UNSECURED;\n\telse\n\t\tconn->state\t= RXRPC_CONN_SERVICE;\n\n\t \n\tif (sp->hdr.userStatus == RXRPC_USERSTATUS_SERVICE_UPGRADE &&\n\t    conn->service_id == rx->service_upgrade.from)\n\t\tconn->service_id = rx->service_upgrade.to;\n\n\tatomic_set(&conn->active, 1);\n\n\t \n\trxrpc_publish_service_conn(conn->peer, conn);\n}\n\n \nvoid rxrpc_unpublish_service_conn(struct rxrpc_connection *conn)\n{\n\tstruct rxrpc_peer *peer = conn->peer;\n\n\twrite_seqlock(&peer->service_conn_lock);\n\tif (test_and_clear_bit(RXRPC_CONN_IN_SERVICE_CONNS, &conn->flags))\n\t\trb_erase(&conn->service_node, &peer->service_conns);\n\twrite_sequnlock(&peer->service_conn_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}