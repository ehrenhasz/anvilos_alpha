{
  "module_name": "call_object.c",
  "hash_id": "b20ddfbb9409ca8efbf9939c65e665c0798db011b486416be66b1956e3849050",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/call_object.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/circ_buf.h>\n#include <linux/spinlock_types.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include \"ar-internal.h\"\n\nconst char *const rxrpc_call_states[NR__RXRPC_CALL_STATES] = {\n\t[RXRPC_CALL_UNINITIALISED]\t\t= \"Uninit  \",\n\t[RXRPC_CALL_CLIENT_AWAIT_CONN]\t\t= \"ClWtConn\",\n\t[RXRPC_CALL_CLIENT_SEND_REQUEST]\t= \"ClSndReq\",\n\t[RXRPC_CALL_CLIENT_AWAIT_REPLY]\t\t= \"ClAwtRpl\",\n\t[RXRPC_CALL_CLIENT_RECV_REPLY]\t\t= \"ClRcvRpl\",\n\t[RXRPC_CALL_SERVER_PREALLOC]\t\t= \"SvPrealc\",\n\t[RXRPC_CALL_SERVER_SECURING]\t\t= \"SvSecure\",\n\t[RXRPC_CALL_SERVER_RECV_REQUEST]\t= \"SvRcvReq\",\n\t[RXRPC_CALL_SERVER_ACK_REQUEST]\t\t= \"SvAckReq\",\n\t[RXRPC_CALL_SERVER_SEND_REPLY]\t\t= \"SvSndRpl\",\n\t[RXRPC_CALL_SERVER_AWAIT_ACK]\t\t= \"SvAwtACK\",\n\t[RXRPC_CALL_COMPLETE]\t\t\t= \"Complete\",\n};\n\nconst char *const rxrpc_call_completions[NR__RXRPC_CALL_COMPLETIONS] = {\n\t[RXRPC_CALL_SUCCEEDED]\t\t\t= \"Complete\",\n\t[RXRPC_CALL_REMOTELY_ABORTED]\t\t= \"RmtAbort\",\n\t[RXRPC_CALL_LOCALLY_ABORTED]\t\t= \"LocAbort\",\n\t[RXRPC_CALL_LOCAL_ERROR]\t\t= \"LocError\",\n\t[RXRPC_CALL_NETWORK_ERROR]\t\t= \"NetError\",\n};\n\nstruct kmem_cache *rxrpc_call_jar;\n\nstatic DEFINE_SEMAPHORE(rxrpc_call_limiter, 1000);\nstatic DEFINE_SEMAPHORE(rxrpc_kernel_call_limiter, 1000);\n\nvoid rxrpc_poke_call(struct rxrpc_call *call, enum rxrpc_call_poke_trace what)\n{\n\tstruct rxrpc_local *local = call->local;\n\tbool busy;\n\n\tif (!test_bit(RXRPC_CALL_DISCONNECTED, &call->flags)) {\n\t\tspin_lock_bh(&local->lock);\n\t\tbusy = !list_empty(&call->attend_link);\n\t\ttrace_rxrpc_poke_call(call, busy, what);\n\t\tif (!busy && !rxrpc_try_get_call(call, rxrpc_call_get_poke))\n\t\t\tbusy = true;\n\t\tif (!busy) {\n\t\t\tlist_add_tail(&call->attend_link, &local->call_attend_q);\n\t\t}\n\t\tspin_unlock_bh(&local->lock);\n\t\tif (!busy)\n\t\t\trxrpc_wake_up_io_thread(local);\n\t}\n}\n\nstatic void rxrpc_call_timer_expired(struct timer_list *t)\n{\n\tstruct rxrpc_call *call = from_timer(call, t, timer);\n\n\t_enter(\"%d\", call->debug_id);\n\n\tif (!__rxrpc_call_is_complete(call)) {\n\t\ttrace_rxrpc_timer_expired(call, jiffies);\n\t\trxrpc_poke_call(call, rxrpc_call_poke_timer);\n\t}\n}\n\nvoid rxrpc_reduce_call_timer(struct rxrpc_call *call,\n\t\t\t     unsigned long expire_at,\n\t\t\t     unsigned long now,\n\t\t\t     enum rxrpc_timer_trace why)\n{\n\ttrace_rxrpc_timer(call, why, now);\n\ttimer_reduce(&call->timer, expire_at);\n}\n\nstatic struct lock_class_key rxrpc_call_user_mutex_lock_class_key;\n\nstatic void rxrpc_destroy_call(struct work_struct *);\n\n \nstruct rxrpc_call *rxrpc_find_call_by_user_ID(struct rxrpc_sock *rx,\n\t\t\t\t\t      unsigned long user_call_ID)\n{\n\tstruct rxrpc_call *call;\n\tstruct rb_node *p;\n\n\t_enter(\"%p,%lx\", rx, user_call_ID);\n\n\tread_lock(&rx->call_lock);\n\n\tp = rx->calls.rb_node;\n\twhile (p) {\n\t\tcall = rb_entry(p, struct rxrpc_call, sock_node);\n\n\t\tif (user_call_ID < call->user_call_ID)\n\t\t\tp = p->rb_left;\n\t\telse if (user_call_ID > call->user_call_ID)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\tgoto found_extant_call;\n\t}\n\n\tread_unlock(&rx->call_lock);\n\t_leave(\" = NULL\");\n\treturn NULL;\n\nfound_extant_call:\n\trxrpc_get_call(call, rxrpc_call_get_sendmsg);\n\tread_unlock(&rx->call_lock);\n\t_leave(\" = %p [%d]\", call, refcount_read(&call->ref));\n\treturn call;\n}\n\n \nstruct rxrpc_call *rxrpc_alloc_call(struct rxrpc_sock *rx, gfp_t gfp,\n\t\t\t\t    unsigned int debug_id)\n{\n\tstruct rxrpc_call *call;\n\tstruct rxrpc_net *rxnet = rxrpc_net(sock_net(&rx->sk));\n\n\tcall = kmem_cache_zalloc(rxrpc_call_jar, gfp);\n\tif (!call)\n\t\treturn NULL;\n\n\tmutex_init(&call->user_mutex);\n\n\t \n\tif (rx->sk.sk_kern_sock)\n\t\tlockdep_set_class(&call->user_mutex,\n\t\t\t\t  &rxrpc_call_user_mutex_lock_class_key);\n\n\ttimer_setup(&call->timer, rxrpc_call_timer_expired, 0);\n\tINIT_WORK(&call->destroyer, rxrpc_destroy_call);\n\tINIT_LIST_HEAD(&call->link);\n\tINIT_LIST_HEAD(&call->wait_link);\n\tINIT_LIST_HEAD(&call->accept_link);\n\tINIT_LIST_HEAD(&call->recvmsg_link);\n\tINIT_LIST_HEAD(&call->sock_link);\n\tINIT_LIST_HEAD(&call->attend_link);\n\tINIT_LIST_HEAD(&call->tx_sendmsg);\n\tINIT_LIST_HEAD(&call->tx_buffer);\n\tskb_queue_head_init(&call->recvmsg_queue);\n\tskb_queue_head_init(&call->rx_oos_queue);\n\tinit_waitqueue_head(&call->waitq);\n\tspin_lock_init(&call->notify_lock);\n\tspin_lock_init(&call->tx_lock);\n\trefcount_set(&call->ref, 1);\n\tcall->debug_id = debug_id;\n\tcall->tx_total_len = -1;\n\tcall->next_rx_timo = 20 * HZ;\n\tcall->next_req_timo = 1 * HZ;\n\tcall->ackr_window = 1;\n\tcall->ackr_wtop = 1;\n\n\tmemset(&call->sock_node, 0xed, sizeof(call->sock_node));\n\n\tcall->rx_winsize = rxrpc_rx_window_size;\n\tcall->tx_winsize = 16;\n\n\tif (RXRPC_TX_SMSS > 2190)\n\t\tcall->cong_cwnd = 2;\n\telse if (RXRPC_TX_SMSS > 1095)\n\t\tcall->cong_cwnd = 3;\n\telse\n\t\tcall->cong_cwnd = 4;\n\tcall->cong_ssthresh = RXRPC_TX_MAX_WINDOW;\n\n\tcall->rxnet = rxnet;\n\tcall->rtt_avail = RXRPC_CALL_RTT_AVAIL_MASK;\n\tatomic_inc(&rxnet->nr_calls);\n\treturn call;\n}\n\n \nstatic struct rxrpc_call *rxrpc_alloc_client_call(struct rxrpc_sock *rx,\n\t\t\t\t\t\t  struct sockaddr_rxrpc *srx,\n\t\t\t\t\t\t  struct rxrpc_conn_parameters *cp,\n\t\t\t\t\t\t  struct rxrpc_call_params *p,\n\t\t\t\t\t\t  gfp_t gfp,\n\t\t\t\t\t\t  unsigned int debug_id)\n{\n\tstruct rxrpc_call *call;\n\tktime_t now;\n\tint ret;\n\n\t_enter(\"\");\n\n\tcall = rxrpc_alloc_call(rx, gfp, debug_id);\n\tif (!call)\n\t\treturn ERR_PTR(-ENOMEM);\n\tnow = ktime_get_real();\n\tcall->acks_latest_ts\t= now;\n\tcall->cong_tstamp\t= now;\n\tcall->dest_srx\t\t= *srx;\n\tcall->interruptibility\t= p->interruptibility;\n\tcall->tx_total_len\t= p->tx_total_len;\n\tcall->key\t\t= key_get(cp->key);\n\tcall->local\t\t= rxrpc_get_local(cp->local, rxrpc_local_get_call);\n\tcall->security_level\t= cp->security_level;\n\tif (p->kernel)\n\t\t__set_bit(RXRPC_CALL_KERNEL, &call->flags);\n\tif (cp->upgrade)\n\t\t__set_bit(RXRPC_CALL_UPGRADE, &call->flags);\n\tif (cp->exclusive)\n\t\t__set_bit(RXRPC_CALL_EXCLUSIVE, &call->flags);\n\n\tif (p->timeouts.normal)\n\t\tcall->next_rx_timo = min(msecs_to_jiffies(p->timeouts.normal), 1UL);\n\tif (p->timeouts.idle)\n\t\tcall->next_req_timo = min(msecs_to_jiffies(p->timeouts.idle), 1UL);\n\tif (p->timeouts.hard)\n\t\tcall->hard_timo = p->timeouts.hard * HZ;\n\n\tret = rxrpc_init_client_call_security(call);\n\tif (ret < 0) {\n\t\trxrpc_prefail_call(call, RXRPC_CALL_LOCAL_ERROR, ret);\n\t\trxrpc_put_call(call, rxrpc_call_put_discard_error);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trxrpc_set_call_state(call, RXRPC_CALL_CLIENT_AWAIT_CONN);\n\n\ttrace_rxrpc_call(call->debug_id, refcount_read(&call->ref),\n\t\t\t p->user_call_ID, rxrpc_call_new_client);\n\n\t_leave(\" = %p\", call);\n\treturn call;\n}\n\n \nvoid rxrpc_start_call_timer(struct rxrpc_call *call)\n{\n\tunsigned long now = jiffies;\n\tunsigned long j = now + MAX_JIFFY_OFFSET;\n\n\tcall->delay_ack_at = j;\n\tcall->ack_lost_at = j;\n\tcall->resend_at = j;\n\tcall->ping_at = j;\n\tcall->keepalive_at = j;\n\tcall->expect_rx_by = j;\n\tcall->expect_req_by = j;\n\tcall->expect_term_by = j + call->hard_timo;\n\tcall->timer.expires = now;\n}\n\n \nstatic struct semaphore *rxrpc_get_call_slot(struct rxrpc_call_params *p, gfp_t gfp)\n{\n\tstruct semaphore *limiter = &rxrpc_call_limiter;\n\n\tif (p->kernel)\n\t\tlimiter = &rxrpc_kernel_call_limiter;\n\tif (p->interruptibility == RXRPC_UNINTERRUPTIBLE) {\n\t\tdown(limiter);\n\t\treturn limiter;\n\t}\n\treturn down_interruptible(limiter) < 0 ? NULL : limiter;\n}\n\n \nstatic void rxrpc_put_call_slot(struct rxrpc_call *call)\n{\n\tstruct semaphore *limiter = &rxrpc_call_limiter;\n\n\tif (test_bit(RXRPC_CALL_KERNEL, &call->flags))\n\t\tlimiter = &rxrpc_kernel_call_limiter;\n\tup(limiter);\n}\n\n \nstatic int rxrpc_connect_call(struct rxrpc_call *call, gfp_t gfp)\n{\n\tstruct rxrpc_local *local = call->local;\n\tint ret = -ENOMEM;\n\n\t_enter(\"{%d,%lx},\", call->debug_id, call->user_call_ID);\n\n\tcall->peer = rxrpc_lookup_peer(local, &call->dest_srx, gfp);\n\tif (!call->peer)\n\t\tgoto error;\n\n\tret = rxrpc_look_up_bundle(call, gfp);\n\tif (ret < 0)\n\t\tgoto error;\n\n\ttrace_rxrpc_client(NULL, -1, rxrpc_client_queue_new_call);\n\trxrpc_get_call(call, rxrpc_call_get_io_thread);\n\tspin_lock(&local->client_call_lock);\n\tlist_add_tail(&call->wait_link, &local->new_client_calls);\n\tspin_unlock(&local->client_call_lock);\n\trxrpc_wake_up_io_thread(local);\n\treturn 0;\n\nerror:\n\t__set_bit(RXRPC_CALL_DISCONNECTED, &call->flags);\n\treturn ret;\n}\n\n \nstruct rxrpc_call *rxrpc_new_client_call(struct rxrpc_sock *rx,\n\t\t\t\t\t struct rxrpc_conn_parameters *cp,\n\t\t\t\t\t struct sockaddr_rxrpc *srx,\n\t\t\t\t\t struct rxrpc_call_params *p,\n\t\t\t\t\t gfp_t gfp,\n\t\t\t\t\t unsigned int debug_id)\n\t__releases(&rx->sk.sk_lock.slock)\n\t__acquires(&call->user_mutex)\n{\n\tstruct rxrpc_call *call, *xcall;\n\tstruct rxrpc_net *rxnet;\n\tstruct semaphore *limiter;\n\tstruct rb_node *parent, **pp;\n\tint ret;\n\n\t_enter(\"%p,%lx\", rx, p->user_call_ID);\n\n\tlimiter = rxrpc_get_call_slot(p, gfp);\n\tif (!limiter) {\n\t\trelease_sock(&rx->sk);\n\t\treturn ERR_PTR(-ERESTARTSYS);\n\t}\n\n\tcall = rxrpc_alloc_client_call(rx, srx, cp, p, gfp, debug_id);\n\tif (IS_ERR(call)) {\n\t\trelease_sock(&rx->sk);\n\t\tup(limiter);\n\t\t_leave(\" = %ld\", PTR_ERR(call));\n\t\treturn call;\n\t}\n\n\t \n\tmutex_lock(&call->user_mutex);\n\n\t \n\twrite_lock(&rx->call_lock);\n\n\tpp = &rx->calls.rb_node;\n\tparent = NULL;\n\twhile (*pp) {\n\t\tparent = *pp;\n\t\txcall = rb_entry(parent, struct rxrpc_call, sock_node);\n\n\t\tif (p->user_call_ID < xcall->user_call_ID)\n\t\t\tpp = &(*pp)->rb_left;\n\t\telse if (p->user_call_ID > xcall->user_call_ID)\n\t\t\tpp = &(*pp)->rb_right;\n\t\telse\n\t\t\tgoto error_dup_user_ID;\n\t}\n\n\trcu_assign_pointer(call->socket, rx);\n\tcall->user_call_ID = p->user_call_ID;\n\t__set_bit(RXRPC_CALL_HAS_USERID, &call->flags);\n\trxrpc_get_call(call, rxrpc_call_get_userid);\n\trb_link_node(&call->sock_node, parent, pp);\n\trb_insert_color(&call->sock_node, &rx->calls);\n\tlist_add(&call->sock_link, &rx->sock_calls);\n\n\twrite_unlock(&rx->call_lock);\n\n\trxnet = call->rxnet;\n\tspin_lock(&rxnet->call_lock);\n\tlist_add_tail_rcu(&call->link, &rxnet->calls);\n\tspin_unlock(&rxnet->call_lock);\n\n\t \n\trelease_sock(&rx->sk);\n\n\t \n\tret = rxrpc_connect_call(call, gfp);\n\tif (ret < 0)\n\t\tgoto error_attached_to_socket;\n\n\t_leave(\" = %p [new]\", call);\n\treturn call;\n\n\t \nerror_dup_user_ID:\n\twrite_unlock(&rx->call_lock);\n\trelease_sock(&rx->sk);\n\trxrpc_prefail_call(call, RXRPC_CALL_LOCAL_ERROR, -EEXIST);\n\ttrace_rxrpc_call(call->debug_id, refcount_read(&call->ref), 0,\n\t\t\t rxrpc_call_see_userid_exists);\n\tmutex_unlock(&call->user_mutex);\n\trxrpc_put_call(call, rxrpc_call_put_userid_exists);\n\t_leave(\" = -EEXIST\");\n\treturn ERR_PTR(-EEXIST);\n\n\t \nerror_attached_to_socket:\n\ttrace_rxrpc_call(call->debug_id, refcount_read(&call->ref), ret,\n\t\t\t rxrpc_call_see_connect_failed);\n\trxrpc_set_call_completion(call, RXRPC_CALL_LOCAL_ERROR, 0, ret);\n\t_leave(\" = c=%08x [err]\", call->debug_id);\n\treturn call;\n}\n\n \nvoid rxrpc_incoming_call(struct rxrpc_sock *rx,\n\t\t\t struct rxrpc_call *call,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct rxrpc_connection *conn = call->conn;\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tu32 chan;\n\n\t_enter(\",%d\", call->conn->debug_id);\n\n\trcu_assign_pointer(call->socket, rx);\n\tcall->call_id\t\t= sp->hdr.callNumber;\n\tcall->dest_srx.srx_service = sp->hdr.serviceId;\n\tcall->cid\t\t= sp->hdr.cid;\n\tcall->cong_tstamp\t= skb->tstamp;\n\n\t__set_bit(RXRPC_CALL_EXPOSED, &call->flags);\n\trxrpc_set_call_state(call, RXRPC_CALL_SERVER_SECURING);\n\n\tspin_lock(&conn->state_lock);\n\n\tswitch (conn->state) {\n\tcase RXRPC_CONN_SERVICE_UNSECURED:\n\tcase RXRPC_CONN_SERVICE_CHALLENGING:\n\t\trxrpc_set_call_state(call, RXRPC_CALL_SERVER_SECURING);\n\t\tbreak;\n\tcase RXRPC_CONN_SERVICE:\n\t\trxrpc_set_call_state(call, RXRPC_CALL_SERVER_RECV_REQUEST);\n\t\tbreak;\n\n\tcase RXRPC_CONN_ABORTED:\n\t\trxrpc_set_call_completion(call, conn->completion,\n\t\t\t\t\t  conn->abort_code, conn->error);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\trxrpc_get_call(call, rxrpc_call_get_io_thread);\n\n\t \n\tchan = sp->hdr.cid & RXRPC_CHANNELMASK;\n\tconn->channels[chan].call_counter = call->call_id;\n\tconn->channels[chan].call_id = call->call_id;\n\tconn->channels[chan].call = call;\n\tspin_unlock(&conn->state_lock);\n\n\tspin_lock(&conn->peer->lock);\n\thlist_add_head(&call->error_link, &conn->peer->error_targets);\n\tspin_unlock(&conn->peer->lock);\n\n\trxrpc_start_call_timer(call);\n\t_leave(\"\");\n}\n\n \nvoid rxrpc_see_call(struct rxrpc_call *call, enum rxrpc_call_trace why)\n{\n\tif (call) {\n\t\tint r = refcount_read(&call->ref);\n\n\t\ttrace_rxrpc_call(call->debug_id, r, 0, why);\n\t}\n}\n\nstruct rxrpc_call *rxrpc_try_get_call(struct rxrpc_call *call,\n\t\t\t\t      enum rxrpc_call_trace why)\n{\n\tint r;\n\n\tif (!call || !__refcount_inc_not_zero(&call->ref, &r))\n\t\treturn NULL;\n\ttrace_rxrpc_call(call->debug_id, r + 1, 0, why);\n\treturn call;\n}\n\n \nvoid rxrpc_get_call(struct rxrpc_call *call, enum rxrpc_call_trace why)\n{\n\tint r;\n\n\t__refcount_inc(&call->ref, &r);\n\ttrace_rxrpc_call(call->debug_id, r + 1, 0, why);\n}\n\n \nstatic void rxrpc_cleanup_ring(struct rxrpc_call *call)\n{\n\trxrpc_purge_queue(&call->recvmsg_queue);\n\trxrpc_purge_queue(&call->rx_oos_queue);\n}\n\n \nvoid rxrpc_release_call(struct rxrpc_sock *rx, struct rxrpc_call *call)\n{\n\tstruct rxrpc_connection *conn = call->conn;\n\tbool put = false, putu = false;\n\n\t_enter(\"{%d,%d}\", call->debug_id, refcount_read(&call->ref));\n\n\ttrace_rxrpc_call(call->debug_id, refcount_read(&call->ref),\n\t\t\t call->flags, rxrpc_call_see_release);\n\n\tif (test_and_set_bit(RXRPC_CALL_RELEASED, &call->flags))\n\t\tBUG();\n\n\trxrpc_put_call_slot(call);\n\n\t \n\tspin_lock(&rx->recvmsg_lock);\n\n\tif (!list_empty(&call->recvmsg_link)) {\n\t\t_debug(\"unlinking once-pending call %p { e=%lx f=%lx }\",\n\t\t       call, call->events, call->flags);\n\t\tlist_del(&call->recvmsg_link);\n\t\tput = true;\n\t}\n\n\t \n\tcall->recvmsg_link.next = NULL;\n\tcall->recvmsg_link.prev = NULL;\n\n\tspin_unlock(&rx->recvmsg_lock);\n\tif (put)\n\t\trxrpc_put_call(call, rxrpc_call_put_unnotify);\n\n\twrite_lock(&rx->call_lock);\n\n\tif (test_and_clear_bit(RXRPC_CALL_HAS_USERID, &call->flags)) {\n\t\trb_erase(&call->sock_node, &rx->calls);\n\t\tmemset(&call->sock_node, 0xdd, sizeof(call->sock_node));\n\t\tputu = true;\n\t}\n\n\tlist_del(&call->sock_link);\n\twrite_unlock(&rx->call_lock);\n\n\t_debug(\"RELEASE CALL %p (%d CONN %p)\", call, call->debug_id, conn);\n\n\tif (putu)\n\t\trxrpc_put_call(call, rxrpc_call_put_userid);\n\n\t_leave(\"\");\n}\n\n \nvoid rxrpc_release_calls_on_socket(struct rxrpc_sock *rx)\n{\n\tstruct rxrpc_call *call;\n\n\t_enter(\"%p\", rx);\n\n\twhile (!list_empty(&rx->to_be_accepted)) {\n\t\tcall = list_entry(rx->to_be_accepted.next,\n\t\t\t\t  struct rxrpc_call, accept_link);\n\t\tlist_del(&call->accept_link);\n\t\trxrpc_propose_abort(call, RX_CALL_DEAD, -ECONNRESET,\n\t\t\t\t    rxrpc_abort_call_sock_release_tba);\n\t\trxrpc_put_call(call, rxrpc_call_put_release_sock_tba);\n\t}\n\n\twhile (!list_empty(&rx->sock_calls)) {\n\t\tcall = list_entry(rx->sock_calls.next,\n\t\t\t\t  struct rxrpc_call, sock_link);\n\t\trxrpc_get_call(call, rxrpc_call_get_release_sock);\n\t\trxrpc_propose_abort(call, RX_CALL_DEAD, -ECONNRESET,\n\t\t\t\t    rxrpc_abort_call_sock_release);\n\t\trxrpc_release_call(rx, call);\n\t\trxrpc_put_call(call, rxrpc_call_put_release_sock);\n\t}\n\n\t_leave(\"\");\n}\n\n \nvoid rxrpc_put_call(struct rxrpc_call *call, enum rxrpc_call_trace why)\n{\n\tstruct rxrpc_net *rxnet = call->rxnet;\n\tunsigned int debug_id = call->debug_id;\n\tbool dead;\n\tint r;\n\n\tASSERT(call != NULL);\n\n\tdead = __refcount_dec_and_test(&call->ref, &r);\n\ttrace_rxrpc_call(debug_id, r - 1, 0, why);\n\tif (dead) {\n\t\tASSERTCMP(__rxrpc_call_state(call), ==, RXRPC_CALL_COMPLETE);\n\n\t\tif (!list_empty(&call->link)) {\n\t\t\tspin_lock(&rxnet->call_lock);\n\t\t\tlist_del_init(&call->link);\n\t\t\tspin_unlock(&rxnet->call_lock);\n\t\t}\n\n\t\trxrpc_cleanup_call(call);\n\t}\n}\n\n \nstatic void rxrpc_rcu_free_call(struct rcu_head *rcu)\n{\n\tstruct rxrpc_call *call = container_of(rcu, struct rxrpc_call, rcu);\n\tstruct rxrpc_net *rxnet = READ_ONCE(call->rxnet);\n\n\tkmem_cache_free(rxrpc_call_jar, call);\n\tif (atomic_dec_and_test(&rxnet->nr_calls))\n\t\twake_up_var(&rxnet->nr_calls);\n}\n\n \nstatic void rxrpc_destroy_call(struct work_struct *work)\n{\n\tstruct rxrpc_call *call = container_of(work, struct rxrpc_call, destroyer);\n\tstruct rxrpc_txbuf *txb;\n\n\tdel_timer_sync(&call->timer);\n\n\trxrpc_cleanup_ring(call);\n\twhile ((txb = list_first_entry_or_null(&call->tx_sendmsg,\n\t\t\t\t\t       struct rxrpc_txbuf, call_link))) {\n\t\tlist_del(&txb->call_link);\n\t\trxrpc_put_txbuf(txb, rxrpc_txbuf_put_cleaned);\n\t}\n\twhile ((txb = list_first_entry_or_null(&call->tx_buffer,\n\t\t\t\t\t       struct rxrpc_txbuf, call_link))) {\n\t\tlist_del(&txb->call_link);\n\t\trxrpc_put_txbuf(txb, rxrpc_txbuf_put_cleaned);\n\t}\n\n\trxrpc_put_txbuf(call->tx_pending, rxrpc_txbuf_put_cleaned);\n\trxrpc_put_connection(call->conn, rxrpc_conn_put_call);\n\trxrpc_deactivate_bundle(call->bundle);\n\trxrpc_put_bundle(call->bundle, rxrpc_bundle_put_call);\n\trxrpc_put_peer(call->peer, rxrpc_peer_put_call);\n\trxrpc_put_local(call->local, rxrpc_local_put_call);\n\tcall_rcu(&call->rcu, rxrpc_rcu_free_call);\n}\n\n \nvoid rxrpc_cleanup_call(struct rxrpc_call *call)\n{\n\tmemset(&call->sock_node, 0xcd, sizeof(call->sock_node));\n\n\tASSERTCMP(__rxrpc_call_state(call), ==, RXRPC_CALL_COMPLETE);\n\tASSERT(test_bit(RXRPC_CALL_RELEASED, &call->flags));\n\n\tdel_timer(&call->timer);\n\n\tif (rcu_read_lock_held())\n\t\t \n\t\tschedule_work(&call->destroyer);\n\telse\n\t\trxrpc_destroy_call(&call->destroyer);\n}\n\n \nvoid rxrpc_destroy_all_calls(struct rxrpc_net *rxnet)\n{\n\tstruct rxrpc_call *call;\n\n\t_enter(\"\");\n\n\tif (!list_empty(&rxnet->calls)) {\n\t\tspin_lock(&rxnet->call_lock);\n\n\t\twhile (!list_empty(&rxnet->calls)) {\n\t\t\tcall = list_entry(rxnet->calls.next,\n\t\t\t\t\t  struct rxrpc_call, link);\n\t\t\t_debug(\"Zapping call %p\", call);\n\n\t\t\trxrpc_see_call(call, rxrpc_call_see_zap);\n\t\t\tlist_del_init(&call->link);\n\n\t\t\tpr_err(\"Call %p still in use (%d,%s,%lx,%lx)!\\n\",\n\t\t\t       call, refcount_read(&call->ref),\n\t\t\t       rxrpc_call_states[__rxrpc_call_state(call)],\n\t\t\t       call->flags, call->events);\n\n\t\t\tspin_unlock(&rxnet->call_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&rxnet->call_lock);\n\t\t}\n\n\t\tspin_unlock(&rxnet->call_lock);\n\t}\n\n\tatomic_dec(&rxnet->nr_calls);\n\twait_var_event(&rxnet->nr_calls, !atomic_read(&rxnet->nr_calls));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}