{
  "module_name": "ar-internal.h",
  "hash_id": "3738be87d63db342122d09fada9ffabb91fdcd968064b241fe2945c650e75970",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/ar-internal.h",
  "human_readable_source": " \n \n\n#include <linux/atomic.h>\n#include <linux/seqlock.h>\n#include <linux/win_minmax.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include <keys/rxrpc-type.h>\n#include \"protocol.h\"\n\n#define FCRYPT_BSIZE 8\nstruct rxrpc_crypt {\n\tunion {\n\t\tu8\tx[FCRYPT_BSIZE];\n\t\t__be32\tn[2];\n\t};\n} __attribute__((aligned(8)));\n\n#define rxrpc_queue_work(WS)\tqueue_work(rxrpc_workqueue, (WS))\n#define rxrpc_queue_delayed_work(WS,D)\t\\\n\tqueue_delayed_work(rxrpc_workqueue, (WS), (D))\n\nstruct key_preparsed_payload;\nstruct rxrpc_connection;\nstruct rxrpc_txbuf;\n\n \nenum rxrpc_skb_mark {\n\tRXRPC_SKB_MARK_PACKET,\t\t \n\tRXRPC_SKB_MARK_ERROR,\t\t \n\tRXRPC_SKB_MARK_SERVICE_CONN_SECURED,  \n\tRXRPC_SKB_MARK_REJECT_BUSY,\t \n\tRXRPC_SKB_MARK_REJECT_ABORT,\t \n};\n\n \nenum {\n\tRXRPC_UNBOUND = 0,\n\tRXRPC_CLIENT_UNBOUND,\t\t \n\tRXRPC_CLIENT_BOUND,\t\t \n\tRXRPC_SERVER_BOUND,\t\t \n\tRXRPC_SERVER_BOUND2,\t\t \n\tRXRPC_SERVER_LISTENING,\t\t \n\tRXRPC_SERVER_LISTEN_DISABLED,\t \n\tRXRPC_CLOSE,\t\t\t \n};\n\n \nstruct rxrpc_net {\n\tstruct proc_dir_entry\t*proc_net;\t \n\tu32\t\t\tepoch;\t\t \n\tstruct list_head\tcalls;\t\t \n\tspinlock_t\t\tcall_lock;\t \n\tatomic_t\t\tnr_calls;\t \n\n\tatomic_t\t\tnr_conns;\n\tstruct list_head\tconn_proc_list;\t \n\tstruct list_head\tservice_conns;\t \n\trwlock_t\t\tconn_lock;\t \n\tstruct work_struct\tservice_conn_reaper;\n\tstruct timer_list\tservice_conn_reap_timer;\n\n\tbool\t\t\tlive;\n\n\tatomic_t\t\tnr_client_conns;\n\n\tstruct hlist_head\tlocal_endpoints;\n\tstruct mutex\t\tlocal_mutex;\t \n\n\tDECLARE_HASHTABLE\t(peer_hash, 10);\n\tspinlock_t\t\tpeer_hash_lock;\t \n\n#define RXRPC_KEEPALIVE_TIME 20  \n\tu8\t\t\tpeer_keepalive_cursor;\n\ttime64_t\t\tpeer_keepalive_base;\n\tstruct list_head\tpeer_keepalive[32];\n\tstruct list_head\tpeer_keepalive_new;\n\tstruct timer_list\tpeer_keepalive_timer;\n\tstruct work_struct\tpeer_keepalive_work;\n\n\tatomic_t\t\tstat_tx_data;\n\tatomic_t\t\tstat_tx_data_retrans;\n\tatomic_t\t\tstat_tx_data_send;\n\tatomic_t\t\tstat_tx_data_send_frag;\n\tatomic_t\t\tstat_tx_data_send_fail;\n\tatomic_t\t\tstat_tx_data_underflow;\n\tatomic_t\t\tstat_tx_data_cwnd_reset;\n\tatomic_t\t\tstat_rx_data;\n\tatomic_t\t\tstat_rx_data_reqack;\n\tatomic_t\t\tstat_rx_data_jumbo;\n\n\tatomic_t\t\tstat_tx_ack_fill;\n\tatomic_t\t\tstat_tx_ack_send;\n\tatomic_t\t\tstat_tx_ack_skip;\n\tatomic_t\t\tstat_tx_acks[256];\n\tatomic_t\t\tstat_rx_acks[256];\n\n\tatomic_t\t\tstat_why_req_ack[8];\n\n\tatomic_t\t\tstat_io_loop;\n};\n\n \nstruct rxrpc_backlog {\n\tunsigned short\t\tpeer_backlog_head;\n\tunsigned short\t\tpeer_backlog_tail;\n\tunsigned short\t\tconn_backlog_head;\n\tunsigned short\t\tconn_backlog_tail;\n\tunsigned short\t\tcall_backlog_head;\n\tunsigned short\t\tcall_backlog_tail;\n#define RXRPC_BACKLOG_MAX\t32\n\tstruct rxrpc_peer\t*peer_backlog[RXRPC_BACKLOG_MAX];\n\tstruct rxrpc_connection\t*conn_backlog[RXRPC_BACKLOG_MAX];\n\tstruct rxrpc_call\t*call_backlog[RXRPC_BACKLOG_MAX];\n};\n\n \nstruct rxrpc_sock {\n\t \n\tstruct sock\t\tsk;\n\trxrpc_notify_new_call_t\tnotify_new_call;  \n\trxrpc_discard_new_call_t discard_new_call;  \n\tstruct rxrpc_local\t*local;\t\t \n\tstruct rxrpc_backlog\t*backlog;\t \n\tspinlock_t\t\tincoming_lock;\t \n\tstruct list_head\tsock_calls;\t \n\tstruct list_head\tto_be_accepted;\t \n\tstruct list_head\trecvmsg_q;\t \n\tspinlock_t\t\trecvmsg_lock;\t \n\tstruct key\t\t*key;\t\t \n\tstruct key\t\t*securities;\t \n\tstruct rb_root\t\tcalls;\t\t \n\tunsigned long\t\tflags;\n#define RXRPC_SOCK_CONNECTED\t\t0\t \n\trwlock_t\t\tcall_lock;\t \n\tu32\t\t\tmin_sec_level;\t \n#define RXRPC_SECURITY_MAX\tRXRPC_SECURITY_ENCRYPT\n\tbool\t\t\texclusive;\t \n\tu16\t\t\tsecond_service;\t \n\tstruct {\n\t\t \n\t\tu16\t\tfrom;\t\t \n\t\tu16\t\tto;\t\t \n\t} service_upgrade;\n\tsa_family_t\t\tfamily;\t\t \n\tstruct sockaddr_rxrpc\tsrx;\t\t \n\tstruct sockaddr_rxrpc\tconnect_srx;\t \n};\n\n#define rxrpc_sk(__sk) container_of((__sk), struct rxrpc_sock, sk)\n\n \nstruct rxrpc_host_header {\n\tu32\t\tepoch;\t\t \n\tu32\t\tcid;\t\t \n\tu32\t\tcallNumber;\t \n\tu32\t\tseq;\t\t \n\tu32\t\tserial;\t\t \n\tu8\t\ttype;\t\t \n\tu8\t\tflags;\t\t \n\tu8\t\tuserStatus;\t \n\tu8\t\tsecurityIndex;\t \n\tunion {\n\t\tu16\t_rsvd;\t\t \n\t\tu16\tcksum;\t\t \n\t};\n\tu16\t\tserviceId;\t \n} __packed;\n\n \nstruct rxrpc_skb_priv {\n\tstruct rxrpc_connection *conn;\t \n\tu16\t\toffset;\t\t \n\tu16\t\tlen;\t\t \n\tu8\t\tflags;\n#define RXRPC_RX_VERIFIED\t0x01\n\n\tstruct rxrpc_host_header hdr;\t \n};\n\n#define rxrpc_skb(__skb) ((struct rxrpc_skb_priv *) &(__skb)->cb)\n\n \nstruct rxrpc_security {\n\tconst char\t\t*name;\t\t \n\tu8\t\t\tsecurity_index;\t \n\tu32\t\t\tno_key_abort;\t \n\n\t \n\tint (*init)(void);\n\n\t \n\tvoid (*exit)(void);\n\n\t \n\tint (*preparse_server_key)(struct key_preparsed_payload *);\n\n\t \n\tvoid (*free_preparse_server_key)(struct key_preparsed_payload *);\n\n\t \n\tvoid (*destroy_server_key)(struct key *);\n\n\t \n\tvoid (*describe_server_key)(const struct key *, struct seq_file *);\n\n\t \n\tint (*init_connection_security)(struct rxrpc_connection *,\n\t\t\t\t\tstruct rxrpc_key_token *);\n\n\t \n\tint (*how_much_data)(struct rxrpc_call *, size_t,\n\t\t\t     size_t *, size_t *, size_t *);\n\n\t \n\tint (*secure_packet)(struct rxrpc_call *, struct rxrpc_txbuf *);\n\n\t \n\tint (*verify_packet)(struct rxrpc_call *, struct sk_buff *);\n\n\t \n\tvoid (*free_call_crypto)(struct rxrpc_call *);\n\n\t \n\tint (*issue_challenge)(struct rxrpc_connection *);\n\n\t \n\tint (*respond_to_challenge)(struct rxrpc_connection *,\n\t\t\t\t    struct sk_buff *);\n\n\t \n\tint (*verify_response)(struct rxrpc_connection *,\n\t\t\t       struct sk_buff *);\n\n\t \n\tvoid (*clear)(struct rxrpc_connection *);\n};\n\n \nstruct rxrpc_local {\n\tstruct rcu_head\t\trcu;\n\tatomic_t\t\tactive_users;\t \n\trefcount_t\t\tref;\t\t \n\tstruct net\t\t*net;\t\t \n\tstruct rxrpc_net\t*rxnet;\t\t \n\tstruct hlist_node\tlink;\n\tstruct socket\t\t*socket;\t \n\tstruct task_struct\t*io_thread;\n\tstruct completion\tio_thread_ready;  \n\tstruct rxrpc_sock\t*service;\t \n#ifdef CONFIG_AF_RXRPC_INJECT_RX_DELAY\n\tstruct sk_buff_head\trx_delay_queue;\t \n#endif\n\tstruct sk_buff_head\trx_queue;\t \n\tstruct list_head\tconn_attend_q;\t \n\tstruct list_head\tcall_attend_q;\t \n\n\tstruct rb_root\t\tclient_bundles;\t \n\tspinlock_t\t\tclient_bundles_lock;  \n\tbool\t\t\tkill_all_client_conns;\n\tstruct list_head\tidle_client_conns;\n\tstruct timer_list\tclient_conn_reap_timer;\n\tunsigned long\t\tclient_conn_flags;\n#define RXRPC_CLIENT_CONN_REAP_TIMER\t0\t \n\n\tspinlock_t\t\tlock;\t\t \n\trwlock_t\t\tservices_lock;\t \n\tint\t\t\tdebug_id;\t \n\tbool\t\t\tdead;\n\tbool\t\t\tservice_closed;\t \n\tstruct idr\t\tconn_ids;\t \n\tstruct list_head\tnew_client_calls;  \n\tspinlock_t\t\tclient_call_lock;  \n\tstruct sockaddr_rxrpc\tsrx;\t\t \n};\n\n \nstruct rxrpc_peer {\n\tstruct rcu_head\t\trcu;\t\t \n\trefcount_t\t\tref;\n\tunsigned long\t\thash_key;\n\tstruct hlist_node\thash_link;\n\tstruct rxrpc_local\t*local;\n\tstruct hlist_head\terror_targets;\t \n\tstruct rb_root\t\tservice_conns;\t \n\tstruct list_head\tkeepalive_link;\t \n\ttime64_t\t\tlast_tx_at;\t \n\tseqlock_t\t\tservice_conn_lock;\n\tspinlock_t\t\tlock;\t\t \n\tunsigned int\t\tif_mtu;\t\t \n\tunsigned int\t\tmtu;\t\t \n\tunsigned int\t\tmaxdata;\t \n\tunsigned short\t\thdrsize;\t \n\tint\t\t\tdebug_id;\t \n\tstruct sockaddr_rxrpc\tsrx;\t\t \n\n\t \n#define RXRPC_RTT_CACHE_SIZE 32\n\tspinlock_t\t\trtt_input_lock;\t \n\tktime_t\t\t\trtt_last_req;\t \n\tunsigned int\t\trtt_count;\t \n\n\tu32\t\t\tsrtt_us;\t \n\tu32\t\t\tmdev_us;\t \n\tu32\t\t\tmdev_max_us;\t \n\tu32\t\t\trttvar_us;\t \n\tu32\t\t\trto_j;\t\t \n\tu8\t\t\tbackoff;\t \n\n\tu8\t\t\tcong_ssthresh;\t \n};\n\n \nstruct rxrpc_conn_proto {\n\tunion {\n\t\tstruct {\n\t\t\tu32\tepoch;\t\t \n\t\t\tu32\tcid;\t\t \n\t\t};\n\t\tu64\t\tindex_key;\n\t};\n};\n\nstruct rxrpc_conn_parameters {\n\tstruct rxrpc_local\t*local;\t\t \n\tstruct key\t\t*key;\t\t \n\tbool\t\t\texclusive;\t \n\tbool\t\t\tupgrade;\t \n\tu16\t\t\tservice_id;\t \n\tu32\t\t\tsecurity_level;\t \n};\n\n \nenum rxrpc_call_completion {\n\tRXRPC_CALL_SUCCEEDED,\t\t \n\tRXRPC_CALL_REMOTELY_ABORTED,\t \n\tRXRPC_CALL_LOCALLY_ABORTED,\t \n\tRXRPC_CALL_LOCAL_ERROR,\t\t \n\tRXRPC_CALL_NETWORK_ERROR,\t \n\tNR__RXRPC_CALL_COMPLETIONS\n};\n\n \nenum rxrpc_conn_flag {\n\tRXRPC_CONN_IN_SERVICE_CONNS,\t \n\tRXRPC_CONN_DONT_REUSE,\t\t \n\tRXRPC_CONN_PROBING_FOR_UPGRADE,\t \n\tRXRPC_CONN_FINAL_ACK_0,\t\t \n\tRXRPC_CONN_FINAL_ACK_1,\t\t \n\tRXRPC_CONN_FINAL_ACK_2,\t\t \n\tRXRPC_CONN_FINAL_ACK_3,\t\t \n};\n\n#define RXRPC_CONN_FINAL_ACK_MASK ((1UL << RXRPC_CONN_FINAL_ACK_0) |\t\\\n\t\t\t\t   (1UL << RXRPC_CONN_FINAL_ACK_1) |\t\\\n\t\t\t\t   (1UL << RXRPC_CONN_FINAL_ACK_2) |\t\\\n\t\t\t\t   (1UL << RXRPC_CONN_FINAL_ACK_3))\n\n \nenum rxrpc_conn_event {\n\tRXRPC_CONN_EV_CHALLENGE,\t \n\tRXRPC_CONN_EV_ABORT_CALLS,\t \n};\n\n \nenum rxrpc_conn_proto_state {\n\tRXRPC_CONN_UNUSED,\t\t \n\tRXRPC_CONN_CLIENT_UNSECURED,\t \n\tRXRPC_CONN_CLIENT,\t\t \n\tRXRPC_CONN_SERVICE_PREALLOC,\t \n\tRXRPC_CONN_SERVICE_UNSECURED,\t \n\tRXRPC_CONN_SERVICE_CHALLENGING,\t \n\tRXRPC_CONN_SERVICE,\t\t \n\tRXRPC_CONN_ABORTED,\t\t \n\tRXRPC_CONN__NR_STATES\n};\n\n \nstruct rxrpc_bundle {\n\tstruct rxrpc_local\t*local;\t\t \n\tstruct rxrpc_peer\t*peer;\t\t \n\tstruct key\t\t*key;\t\t \n\tconst struct rxrpc_security *security;\t \n\trefcount_t\t\tref;\n\tatomic_t\t\tactive;\t\t \n\tunsigned int\t\tdebug_id;\n\tu32\t\t\tsecurity_level;\t \n\tu16\t\t\tservice_id;\t \n\tbool\t\t\ttry_upgrade;\t \n\tbool\t\t\texclusive;\t \n\tbool\t\t\tupgrade;\t \n\tunsigned short\t\talloc_error;\t \n\tstruct rb_node\t\tlocal_node;\t \n\tstruct list_head\twaiting_calls;\t \n\tunsigned long\t\tavail_chans;\t \n\tstruct rxrpc_connection\t*conns[4];\t \n};\n\n \nstruct rxrpc_connection {\n\tstruct rxrpc_conn_proto\tproto;\n\tstruct rxrpc_local\t*local;\t\t \n\tstruct rxrpc_peer\t*peer;\t\t \n\tstruct rxrpc_net\t*rxnet;\t\t \n\tstruct key\t\t*key;\t\t \n\tstruct list_head\tattend_link;\t \n\n\trefcount_t\t\tref;\n\tatomic_t\t\tactive;\t\t \n\tstruct rcu_head\t\trcu;\n\tstruct list_head\tcache_link;\n\n\tunsigned char\t\tact_chans;\t \n\tstruct rxrpc_channel {\n\t\tunsigned long\t\tfinal_ack_at;\t \n\t\tstruct rxrpc_call\t*call;\t\t \n\t\tunsigned int\t\tcall_debug_id;\t \n\t\tu32\t\t\tcall_id;\t \n\t\tu32\t\t\tcall_counter;\t \n\t\tu32\t\t\tlast_call;\t \n\t\tu8\t\t\tlast_type;\t \n\t\tunion {\n\t\t\tu32\t\tlast_seq;\n\t\t\tu32\t\tlast_abort;\n\t\t};\n\t} channels[RXRPC_MAXCALLS];\n\n\tstruct timer_list\ttimer;\t\t \n\tstruct work_struct\tprocessor;\t \n\tstruct work_struct\tdestructor;\t \n\tstruct rxrpc_bundle\t*bundle;\t \n\tstruct rb_node\t\tservice_node;\t \n\tstruct list_head\tproc_link;\t \n\tstruct list_head\tlink;\t\t \n\tstruct sk_buff_head\trx_queue;\t \n\n\tstruct mutex\t\tsecurity_lock;\t \n\tconst struct rxrpc_security *security;\t \n\tunion {\n\t\tstruct {\n\t\t\tstruct crypto_sync_skcipher *cipher;\t \n\t\t\tstruct rxrpc_crypt csum_iv;\t \n\t\t\tu32\tnonce;\t\t \n\t\t} rxkad;\n\t};\n\tunsigned long\t\tflags;\n\tunsigned long\t\tevents;\n\tunsigned long\t\tidle_timestamp;\t \n\tspinlock_t\t\tstate_lock;\t \n\tenum rxrpc_conn_proto_state state;\t \n\tenum rxrpc_call_completion completion;\t \n\ts32\t\t\tabort_code;\t \n\tint\t\t\tdebug_id;\t \n\tatomic_t\t\tserial;\t\t \n\tunsigned int\t\thi_serial;\t \n\tu32\t\t\tservice_id;\t \n\tu32\t\t\tsecurity_level;\t \n\tu8\t\t\tsecurity_ix;\t \n\tu8\t\t\tout_clientflag;\t \n\tu8\t\t\tbundle_shift;\t \n\tbool\t\t\texclusive;\t \n\tbool\t\t\tupgrade;\t \n\tu16\t\t\torig_service_id;  \n\tshort\t\t\terror;\t\t \n};\n\nstatic inline bool rxrpc_to_server(const struct rxrpc_skb_priv *sp)\n{\n\treturn sp->hdr.flags & RXRPC_CLIENT_INITIATED;\n}\n\nstatic inline bool rxrpc_to_client(const struct rxrpc_skb_priv *sp)\n{\n\treturn !rxrpc_to_server(sp);\n}\n\n \nenum rxrpc_call_flag {\n\tRXRPC_CALL_RELEASED,\t\t \n\tRXRPC_CALL_HAS_USERID,\t\t \n\tRXRPC_CALL_IS_SERVICE,\t\t \n\tRXRPC_CALL_EXPOSED,\t\t \n\tRXRPC_CALL_RX_LAST,\t\t \n\tRXRPC_CALL_TX_LAST,\t\t \n\tRXRPC_CALL_TX_ALL_ACKED,\t \n\tRXRPC_CALL_SEND_PING,\t\t \n\tRXRPC_CALL_RETRANS_TIMEOUT,\t \n\tRXRPC_CALL_BEGAN_RX_TIMER,\t \n\tRXRPC_CALL_RX_HEARD,\t\t \n\tRXRPC_CALL_DISCONNECTED,\t \n\tRXRPC_CALL_KERNEL,\t\t \n\tRXRPC_CALL_UPGRADE,\t\t \n\tRXRPC_CALL_EXCLUSIVE,\t\t \n\tRXRPC_CALL_RX_IS_IDLE,\t\t \n\tRXRPC_CALL_RECVMSG_READ_ALL,\t \n};\n\n \nenum rxrpc_call_event {\n\tRXRPC_CALL_EV_ACK_LOST,\t\t \n\tRXRPC_CALL_EV_INITIAL_PING,\t \n};\n\n \nenum rxrpc_call_state {\n\tRXRPC_CALL_UNINITIALISED,\n\tRXRPC_CALL_CLIENT_AWAIT_CONN,\t \n\tRXRPC_CALL_CLIENT_SEND_REQUEST,\t \n\tRXRPC_CALL_CLIENT_AWAIT_REPLY,\t \n\tRXRPC_CALL_CLIENT_RECV_REPLY,\t \n\tRXRPC_CALL_SERVER_PREALLOC,\t \n\tRXRPC_CALL_SERVER_SECURING,\t \n\tRXRPC_CALL_SERVER_RECV_REQUEST,\t \n\tRXRPC_CALL_SERVER_ACK_REQUEST,\t \n\tRXRPC_CALL_SERVER_SEND_REPLY,\t \n\tRXRPC_CALL_SERVER_AWAIT_ACK,\t \n\tRXRPC_CALL_COMPLETE,\t\t \n\tNR__RXRPC_CALL_STATES\n};\n\n \nenum rxrpc_congest_mode {\n\tRXRPC_CALL_SLOW_START,\n\tRXRPC_CALL_CONGEST_AVOIDANCE,\n\tRXRPC_CALL_PACKET_LOSS,\n\tRXRPC_CALL_FAST_RETRANSMIT,\n\tNR__RXRPC_CONGEST_MODES\n};\n\n \nstruct rxrpc_call {\n\tstruct rcu_head\t\trcu;\n\tstruct rxrpc_connection\t*conn;\t\t \n\tstruct rxrpc_bundle\t*bundle;\t \n\tstruct rxrpc_peer\t*peer;\t\t \n\tstruct rxrpc_local\t*local;\t\t \n\tstruct rxrpc_sock __rcu\t*socket;\t \n\tstruct rxrpc_net\t*rxnet;\t\t \n\tstruct key\t\t*key;\t\t \n\tconst struct rxrpc_security *security;\t \n\tstruct mutex\t\tuser_mutex;\t \n\tstruct sockaddr_rxrpc\tdest_srx;\t \n\tunsigned long\t\tdelay_ack_at;\t \n\tunsigned long\t\tack_lost_at;\t \n\tunsigned long\t\tresend_at;\t \n\tunsigned long\t\tping_at;\t \n\tunsigned long\t\tkeepalive_at;\t \n\tunsigned long\t\texpect_rx_by;\t \n\tunsigned long\t\texpect_req_by;\t \n\tunsigned long\t\texpect_term_by;\t \n\tu32\t\t\tnext_rx_timo;\t \n\tu32\t\t\tnext_req_timo;\t \n\tu32\t\t\thard_timo;\t \n\tstruct timer_list\ttimer;\t\t \n\tstruct work_struct\tdestroyer;\t \n\trxrpc_notify_rx_t\tnotify_rx;\t \n\tstruct list_head\tlink;\t\t \n\tstruct list_head\twait_link;\t \n\tstruct hlist_node\terror_link;\t \n\tstruct list_head\taccept_link;\t \n\tstruct list_head\trecvmsg_link;\t \n\tstruct list_head\tsock_link;\t \n\tstruct rb_node\t\tsock_node;\t \n\tstruct list_head\tattend_link;\t \n\tstruct rxrpc_txbuf\t*tx_pending;\t \n\twait_queue_head_t\twaitq;\t\t \n\ts64\t\t\ttx_total_len;\t \n\tunsigned long\t\tuser_call_ID;\t \n\tunsigned long\t\tflags;\n\tunsigned long\t\tevents;\n\tspinlock_t\t\tnotify_lock;\t \n\tunsigned int\t\tsend_abort_why;  \n\ts32\t\t\tsend_abort;\t \n\tshort\t\t\tsend_abort_err;\t \n\trxrpc_seq_t\t\tsend_abort_seq;\t \n\ts32\t\t\tabort_code;\t \n\tint\t\t\terror;\t\t \n\tenum rxrpc_call_state\t_state;\t\t \n\tenum rxrpc_call_completion completion;\t \n\trefcount_t\t\tref;\n\tu8\t\t\tsecurity_ix;\t \n\tenum rxrpc_interruptibility interruptibility;  \n\tu32\t\t\tcall_id;\t \n\tu32\t\t\tcid;\t\t \n\tu32\t\t\tsecurity_level;\t \n\tint\t\t\tdebug_id;\t \n\tunsigned short\t\trx_pkt_offset;\t \n\tunsigned short\t\trx_pkt_len;\t \n\n\t \n\tspinlock_t\t\ttx_lock;\t \n\tstruct list_head\ttx_sendmsg;\t \n\tstruct list_head\ttx_buffer;\t \n\trxrpc_seq_t\t\ttx_bottom;\t \n\trxrpc_seq_t\t\ttx_transmitted;\t \n\trxrpc_seq_t\t\ttx_prepared;\t \n\trxrpc_seq_t\t\ttx_top;\t\t \n\tu16\t\t\ttx_backoff;\t \n\tu8\t\t\ttx_winsize;\t \n#define RXRPC_TX_MAX_WINDOW\t128\n\tktime_t\t\t\ttx_last_sent;\t \n\n\t \n\tstruct sk_buff_head\trecvmsg_queue;\t \n\tstruct sk_buff_head\trx_oos_queue;\t \n\n\trxrpc_seq_t\t\trx_highest_seq;\t \n\trxrpc_seq_t\t\trx_consumed;\t \n\trxrpc_serial_t\t\trx_serial;\t \n\tu8\t\t\trx_winsize;\t \n\n\t \n#define RXRPC_TX_SMSS\t\tRXRPC_JUMBO_DATALEN\n#define RXRPC_MIN_CWND\t\t(RXRPC_TX_SMSS > 2190 ? 2 : RXRPC_TX_SMSS > 1095 ? 3 : 4)\n\tu8\t\t\tcong_cwnd;\t \n\tu8\t\t\tcong_extra;\t \n\tu8\t\t\tcong_ssthresh;\t \n\tenum rxrpc_congest_mode\tcong_mode:8;\t \n\tu8\t\t\tcong_dup_acks;\t \n\tu8\t\t\tcong_cumul_acks;  \n\tktime_t\t\t\tcong_tstamp;\t \n\n\t \n\tu8\t\t\tackr_reason;\t \n\tu16\t\t\tackr_sack_base;\t \n\trxrpc_serial_t\t\tackr_serial;\t \n\trxrpc_seq_t\t\tackr_window;\t \n\trxrpc_seq_t\t\tackr_wtop;\t \n\tunsigned int\t\tackr_nr_unacked;  \n\tatomic_t\t\tackr_nr_consumed;  \n\tstruct {\n#define RXRPC_SACK_SIZE 256\n\t\t  \n\t\tu8\t\tackr_sack_table[RXRPC_SACK_SIZE];\n\t} __aligned(8);\n\n\t \n\trxrpc_serial_t\t\trtt_serial[4];\t \n\tktime_t\t\t\trtt_sent_at[4];\t \n\tunsigned long\t\trtt_avail;\t \n#define RXRPC_CALL_RTT_AVAIL_MASK\t0xf\n#define RXRPC_CALL_RTT_PEND_SHIFT\t8\n\n\t \n\tktime_t\t\t\tacks_latest_ts;\t \n\trxrpc_seq_t\t\tacks_first_seq;\t \n\trxrpc_seq_t\t\tacks_prev_seq;\t \n\trxrpc_seq_t\t\tacks_hard_ack;\t \n\trxrpc_seq_t\t\tacks_lowest_nak;  \n\trxrpc_serial_t\t\tacks_highest_serial;  \n};\n\n \nstruct rxrpc_ack_summary {\n\tu16\t\t\tnr_acks;\t\t \n\tu16\t\t\tnr_new_acks;\t\t \n\tu16\t\t\tnr_rot_new_acks;\t \n\tu8\t\t\tack_reason;\n\tbool\t\t\tsaw_nacks;\t\t \n\tbool\t\t\tnew_low_nack;\t\t \n\tbool\t\t\tretrans_timeo;\t\t \n\tu8\t\t\tflight_size;\t\t \n\t \n\tenum rxrpc_congest_mode\tmode:8;\n\tu8\t\t\tcwnd;\n\tu8\t\t\tssthresh;\n\tu8\t\t\tdup_acks;\n\tu8\t\t\tcumulative_acks;\n};\n\n \nenum rxrpc_command {\n\tRXRPC_CMD_SEND_DATA,\t\t \n\tRXRPC_CMD_SEND_ABORT,\t\t \n\tRXRPC_CMD_REJECT_BUSY,\t\t \n\tRXRPC_CMD_CHARGE_ACCEPT,\t \n};\n\nstruct rxrpc_call_params {\n\ts64\t\t\ttx_total_len;\t \n\tunsigned long\t\tuser_call_ID;\t \n\tstruct {\n\t\tu32\t\thard;\t\t \n\t\tu32\t\tidle;\t\t \n\t\tu32\t\tnormal;\t\t \n\t} timeouts;\n\tu8\t\t\tnr_timeouts;\t \n\tbool\t\t\tkernel;\t\t \n\tenum rxrpc_interruptibility interruptibility;  \n};\n\nstruct rxrpc_send_params {\n\tstruct rxrpc_call_params call;\n\tu32\t\t\tabort_code;\t \n\tenum rxrpc_command\tcommand : 8;\t \n\tbool\t\t\texclusive;\t \n\tbool\t\t\tupgrade;\t \n};\n\n \nstruct rxrpc_txbuf {\n\tstruct rcu_head\t\trcu;\n\tstruct list_head\tcall_link;\t \n\tstruct list_head\ttx_link;\t \n\tktime_t\t\t\tlast_sent;\t \n\trefcount_t\t\tref;\n\trxrpc_seq_t\t\tseq;\t\t \n\tunsigned int\t\tcall_debug_id;\n\tunsigned int\t\tdebug_id;\n\tunsigned int\t\tlen;\t\t \n\tunsigned int\t\tspace;\t\t \n\tunsigned int\t\toffset;\t\t \n\tunsigned long\t\tflags;\n#define RXRPC_TXBUF_LAST\t0\t\t \n#define RXRPC_TXBUF_RESENT\t1\t\t \n\tu8   ack_why;\t \n\tstruct {\n\t\t \n\t\tu8\t\tpad[64 - sizeof(struct rxrpc_wire_header)];\n\t\tstruct rxrpc_wire_header wire;\t \n\t\tunion {\n\t\t\tu8\tdata[RXRPC_JUMBO_DATALEN];  \n\t\t\tstruct {\n\t\t\t\tstruct rxrpc_ackpacket ack;\n\t\t\t\tDECLARE_FLEX_ARRAY(u8, acks);\n\t\t\t};\n\t\t};\n\t} __aligned(64);\n};\n\nstatic inline bool rxrpc_sending_to_server(const struct rxrpc_txbuf *txb)\n{\n\treturn txb->wire.flags & RXRPC_CLIENT_INITIATED;\n}\n\nstatic inline bool rxrpc_sending_to_client(const struct rxrpc_txbuf *txb)\n{\n\treturn !rxrpc_sending_to_server(txb);\n}\n\n#include <trace/events/rxrpc.h>\n\n \nextern atomic_t rxrpc_n_rx_skbs;\nextern struct workqueue_struct *rxrpc_workqueue;\n\n \nint rxrpc_service_prealloc(struct rxrpc_sock *, gfp_t);\nvoid rxrpc_discard_prealloc(struct rxrpc_sock *);\nbool rxrpc_new_incoming_call(struct rxrpc_local *local,\n\t\t\t     struct rxrpc_peer *peer,\n\t\t\t     struct rxrpc_connection *conn,\n\t\t\t     struct sockaddr_rxrpc *peer_srx,\n\t\t\t     struct sk_buff *skb);\nvoid rxrpc_accept_incoming_calls(struct rxrpc_local *);\nint rxrpc_user_charge_accept(struct rxrpc_sock *, unsigned long);\n\n \nvoid rxrpc_propose_ping(struct rxrpc_call *call, u32 serial,\n\t\t\tenum rxrpc_propose_ack_trace why);\nvoid rxrpc_send_ACK(struct rxrpc_call *, u8, rxrpc_serial_t, enum rxrpc_propose_ack_trace);\nvoid rxrpc_propose_delay_ACK(struct rxrpc_call *, rxrpc_serial_t,\n\t\t\t     enum rxrpc_propose_ack_trace);\nvoid rxrpc_shrink_call_tx_buffer(struct rxrpc_call *);\nvoid rxrpc_resend(struct rxrpc_call *call, struct sk_buff *ack_skb);\n\nvoid rxrpc_reduce_call_timer(struct rxrpc_call *call,\n\t\t\t     unsigned long expire_at,\n\t\t\t     unsigned long now,\n\t\t\t     enum rxrpc_timer_trace why);\n\nbool rxrpc_input_call_event(struct rxrpc_call *call, struct sk_buff *skb);\n\n \nextern const char *const rxrpc_call_states[];\nextern const char *const rxrpc_call_completions[];\nextern struct kmem_cache *rxrpc_call_jar;\n\nvoid rxrpc_poke_call(struct rxrpc_call *call, enum rxrpc_call_poke_trace what);\nstruct rxrpc_call *rxrpc_find_call_by_user_ID(struct rxrpc_sock *, unsigned long);\nstruct rxrpc_call *rxrpc_alloc_call(struct rxrpc_sock *, gfp_t, unsigned int);\nstruct rxrpc_call *rxrpc_new_client_call(struct rxrpc_sock *,\n\t\t\t\t\t struct rxrpc_conn_parameters *,\n\t\t\t\t\t struct sockaddr_rxrpc *,\n\t\t\t\t\t struct rxrpc_call_params *, gfp_t,\n\t\t\t\t\t unsigned int);\nvoid rxrpc_start_call_timer(struct rxrpc_call *call);\nvoid rxrpc_incoming_call(struct rxrpc_sock *, struct rxrpc_call *,\n\t\t\t struct sk_buff *);\nvoid rxrpc_release_call(struct rxrpc_sock *, struct rxrpc_call *);\nvoid rxrpc_release_calls_on_socket(struct rxrpc_sock *);\nvoid rxrpc_see_call(struct rxrpc_call *, enum rxrpc_call_trace);\nstruct rxrpc_call *rxrpc_try_get_call(struct rxrpc_call *, enum rxrpc_call_trace);\nvoid rxrpc_get_call(struct rxrpc_call *, enum rxrpc_call_trace);\nvoid rxrpc_put_call(struct rxrpc_call *, enum rxrpc_call_trace);\nvoid rxrpc_cleanup_call(struct rxrpc_call *);\nvoid rxrpc_destroy_all_calls(struct rxrpc_net *);\n\nstatic inline bool rxrpc_is_service_call(const struct rxrpc_call *call)\n{\n\treturn test_bit(RXRPC_CALL_IS_SERVICE, &call->flags);\n}\n\nstatic inline bool rxrpc_is_client_call(const struct rxrpc_call *call)\n{\n\treturn !rxrpc_is_service_call(call);\n}\n\n \nbool rxrpc_set_call_completion(struct rxrpc_call *call,\n\t\t\t       enum rxrpc_call_completion compl,\n\t\t\t       u32 abort_code,\n\t\t\t       int error);\nbool rxrpc_call_completed(struct rxrpc_call *call);\nbool rxrpc_abort_call(struct rxrpc_call *call, rxrpc_seq_t seq,\n\t\t      u32 abort_code, int error, enum rxrpc_abort_reason why);\nvoid rxrpc_prefail_call(struct rxrpc_call *call, enum rxrpc_call_completion compl,\n\t\t\tint error);\n\nstatic inline void rxrpc_set_call_state(struct rxrpc_call *call,\n\t\t\t\t\tenum rxrpc_call_state state)\n{\n\t \n\tsmp_store_release(&call->_state, state);\n\twake_up(&call->waitq);\n}\n\nstatic inline enum rxrpc_call_state __rxrpc_call_state(const struct rxrpc_call *call)\n{\n\treturn call->_state;  \n}\n\nstatic inline bool __rxrpc_call_is_complete(const struct rxrpc_call *call)\n{\n\treturn __rxrpc_call_state(call) == RXRPC_CALL_COMPLETE;\n}\n\nstatic inline enum rxrpc_call_state rxrpc_call_state(const struct rxrpc_call *call)\n{\n\t \n\treturn smp_load_acquire(&call->_state);\n}\n\nstatic inline bool rxrpc_call_is_complete(const struct rxrpc_call *call)\n{\n\treturn rxrpc_call_state(call) == RXRPC_CALL_COMPLETE;\n}\n\nstatic inline bool rxrpc_call_has_failed(const struct rxrpc_call *call)\n{\n\treturn rxrpc_call_is_complete(call) && call->completion != RXRPC_CALL_SUCCEEDED;\n}\n\n \nextern unsigned int rxrpc_reap_client_connections;\nextern unsigned long rxrpc_conn_idle_client_expiry;\nextern unsigned long rxrpc_conn_idle_client_fast_expiry;\n\nvoid rxrpc_purge_client_connections(struct rxrpc_local *local);\nstruct rxrpc_bundle *rxrpc_get_bundle(struct rxrpc_bundle *, enum rxrpc_bundle_trace);\nvoid rxrpc_put_bundle(struct rxrpc_bundle *, enum rxrpc_bundle_trace);\nint rxrpc_look_up_bundle(struct rxrpc_call *call, gfp_t gfp);\nvoid rxrpc_connect_client_calls(struct rxrpc_local *local);\nvoid rxrpc_expose_client_call(struct rxrpc_call *);\nvoid rxrpc_disconnect_client_call(struct rxrpc_bundle *, struct rxrpc_call *);\nvoid rxrpc_deactivate_bundle(struct rxrpc_bundle *bundle);\nvoid rxrpc_put_client_conn(struct rxrpc_connection *, enum rxrpc_conn_trace);\nvoid rxrpc_discard_expired_client_conns(struct rxrpc_local *local);\nvoid rxrpc_clean_up_local_conns(struct rxrpc_local *);\n\n \nvoid rxrpc_conn_retransmit_call(struct rxrpc_connection *conn, struct sk_buff *skb,\n\t\t\t\tunsigned int channel);\nint rxrpc_abort_conn(struct rxrpc_connection *conn, struct sk_buff *skb,\n\t\t     s32 abort_code, int err, enum rxrpc_abort_reason why);\nvoid rxrpc_process_connection(struct work_struct *);\nvoid rxrpc_process_delayed_final_acks(struct rxrpc_connection *, bool);\nbool rxrpc_input_conn_packet(struct rxrpc_connection *conn, struct sk_buff *skb);\nvoid rxrpc_input_conn_event(struct rxrpc_connection *conn, struct sk_buff *skb);\n\nstatic inline bool rxrpc_is_conn_aborted(const struct rxrpc_connection *conn)\n{\n\t \n\treturn smp_load_acquire(&conn->state) == RXRPC_CONN_ABORTED;\n}\n\n \nextern unsigned int rxrpc_connection_expiry;\nextern unsigned int rxrpc_closed_conn_expiry;\n\nvoid rxrpc_poke_conn(struct rxrpc_connection *conn, enum rxrpc_conn_trace why);\nstruct rxrpc_connection *rxrpc_alloc_connection(struct rxrpc_net *, gfp_t);\nstruct rxrpc_connection *rxrpc_find_client_connection_rcu(struct rxrpc_local *,\n\t\t\t\t\t\t\t  struct sockaddr_rxrpc *,\n\t\t\t\t\t\t\t  struct sk_buff *);\nvoid __rxrpc_disconnect_call(struct rxrpc_connection *, struct rxrpc_call *);\nvoid rxrpc_disconnect_call(struct rxrpc_call *);\nvoid rxrpc_kill_client_conn(struct rxrpc_connection *);\nvoid rxrpc_queue_conn(struct rxrpc_connection *, enum rxrpc_conn_trace);\nvoid rxrpc_see_connection(struct rxrpc_connection *, enum rxrpc_conn_trace);\nstruct rxrpc_connection *rxrpc_get_connection(struct rxrpc_connection *,\n\t\t\t\t\t      enum rxrpc_conn_trace);\nstruct rxrpc_connection *rxrpc_get_connection_maybe(struct rxrpc_connection *,\n\t\t\t\t\t\t    enum rxrpc_conn_trace);\nvoid rxrpc_put_connection(struct rxrpc_connection *, enum rxrpc_conn_trace);\nvoid rxrpc_service_connection_reaper(struct work_struct *);\nvoid rxrpc_destroy_all_connections(struct rxrpc_net *);\n\nstatic inline bool rxrpc_conn_is_client(const struct rxrpc_connection *conn)\n{\n\treturn conn->out_clientflag;\n}\n\nstatic inline bool rxrpc_conn_is_service(const struct rxrpc_connection *conn)\n{\n\treturn !rxrpc_conn_is_client(conn);\n}\n\nstatic inline void rxrpc_reduce_conn_timer(struct rxrpc_connection *conn,\n\t\t\t\t\t   unsigned long expire_at)\n{\n\ttimer_reduce(&conn->timer, expire_at);\n}\n\n \nstruct rxrpc_connection *rxrpc_find_service_conn_rcu(struct rxrpc_peer *,\n\t\t\t\t\t\t     struct sk_buff *);\nstruct rxrpc_connection *rxrpc_prealloc_service_connection(struct rxrpc_net *, gfp_t);\nvoid rxrpc_new_incoming_connection(struct rxrpc_sock *, struct rxrpc_connection *,\n\t\t\t\t   const struct rxrpc_security *, struct sk_buff *);\nvoid rxrpc_unpublish_service_conn(struct rxrpc_connection *);\n\n \nvoid rxrpc_congestion_degrade(struct rxrpc_call *);\nvoid rxrpc_input_call_packet(struct rxrpc_call *, struct sk_buff *);\nvoid rxrpc_implicit_end_call(struct rxrpc_call *, struct sk_buff *);\n\n \nint rxrpc_encap_rcv(struct sock *, struct sk_buff *);\nvoid rxrpc_error_report(struct sock *);\nbool rxrpc_direct_abort(struct sk_buff *skb, enum rxrpc_abort_reason why,\n\t\t\ts32 abort_code, int err);\nint rxrpc_io_thread(void *data);\nstatic inline void rxrpc_wake_up_io_thread(struct rxrpc_local *local)\n{\n\twake_up_process(local->io_thread);\n}\n\nstatic inline bool rxrpc_protocol_error(struct sk_buff *skb, enum rxrpc_abort_reason why)\n{\n\treturn rxrpc_direct_abort(skb, why, RX_PROTOCOL_ERROR, -EPROTO);\n}\n\n \nextern const struct rxrpc_security rxrpc_no_security;\n\n \nextern struct key_type key_type_rxrpc;\n\nint rxrpc_request_key(struct rxrpc_sock *, sockptr_t , int);\nint rxrpc_get_server_data_key(struct rxrpc_connection *, const void *, time64_t,\n\t\t\t      u32);\n\n \nvoid rxrpc_gen_version_string(void);\nvoid rxrpc_send_version_request(struct rxrpc_local *local,\n\t\t\t\tstruct rxrpc_host_header *hdr,\n\t\t\t\tstruct sk_buff *skb);\n\n \nvoid rxrpc_local_dont_fragment(const struct rxrpc_local *local, bool set);\nstruct rxrpc_local *rxrpc_lookup_local(struct net *, const struct sockaddr_rxrpc *);\nstruct rxrpc_local *rxrpc_get_local(struct rxrpc_local *, enum rxrpc_local_trace);\nstruct rxrpc_local *rxrpc_get_local_maybe(struct rxrpc_local *, enum rxrpc_local_trace);\nvoid rxrpc_put_local(struct rxrpc_local *, enum rxrpc_local_trace);\nstruct rxrpc_local *rxrpc_use_local(struct rxrpc_local *, enum rxrpc_local_trace);\nvoid rxrpc_unuse_local(struct rxrpc_local *, enum rxrpc_local_trace);\nvoid rxrpc_destroy_local(struct rxrpc_local *local);\nvoid rxrpc_destroy_all_locals(struct rxrpc_net *);\n\nstatic inline bool __rxrpc_use_local(struct rxrpc_local *local,\n\t\t\t\t     enum rxrpc_local_trace why)\n{\n\tint r, u;\n\n\tr = refcount_read(&local->ref);\n\tu = atomic_fetch_add_unless(&local->active_users, 1, 0);\n\ttrace_rxrpc_local(local->debug_id, why, r, u);\n\treturn u != 0;\n}\n\nstatic inline void rxrpc_see_local(struct rxrpc_local *local,\n\t\t\t\t   enum rxrpc_local_trace why)\n{\n\tint r, u;\n\n\tr = refcount_read(&local->ref);\n\tu = atomic_read(&local->active_users);\n\ttrace_rxrpc_local(local->debug_id, why, r, u);\n}\n\n \nextern unsigned int rxrpc_max_backlog __read_mostly;\nextern unsigned long rxrpc_soft_ack_delay;\nextern unsigned long rxrpc_idle_ack_delay;\nextern unsigned int rxrpc_rx_window_size;\nextern unsigned int rxrpc_rx_mtu;\nextern unsigned int rxrpc_rx_jumbo_max;\n#ifdef CONFIG_AF_RXRPC_INJECT_RX_DELAY\nextern unsigned long rxrpc_inject_rx_delay;\n#endif\n\n \nextern unsigned int rxrpc_net_id;\nextern struct pernet_operations rxrpc_net_ops;\n\nstatic inline struct rxrpc_net *rxrpc_net(struct net *net)\n{\n\treturn net_generic(net, rxrpc_net_id);\n}\n\n \nint rxrpc_send_ack_packet(struct rxrpc_call *call, struct rxrpc_txbuf *txb);\nint rxrpc_send_abort_packet(struct rxrpc_call *);\nint rxrpc_send_data_packet(struct rxrpc_call *, struct rxrpc_txbuf *);\nvoid rxrpc_send_conn_abort(struct rxrpc_connection *conn);\nvoid rxrpc_reject_packet(struct rxrpc_local *local, struct sk_buff *skb);\nvoid rxrpc_send_keepalive(struct rxrpc_peer *);\nvoid rxrpc_transmit_one(struct rxrpc_call *call, struct rxrpc_txbuf *txb);\n\n \nvoid rxrpc_input_error(struct rxrpc_local *, struct sk_buff *);\nvoid rxrpc_peer_keepalive_worker(struct work_struct *);\n\n \nstruct rxrpc_peer *rxrpc_lookup_peer_rcu(struct rxrpc_local *,\n\t\t\t\t\t const struct sockaddr_rxrpc *);\nstruct rxrpc_peer *rxrpc_lookup_peer(struct rxrpc_local *local,\n\t\t\t\t     struct sockaddr_rxrpc *srx, gfp_t gfp);\nstruct rxrpc_peer *rxrpc_alloc_peer(struct rxrpc_local *, gfp_t,\n\t\t\t\t    enum rxrpc_peer_trace);\nvoid rxrpc_new_incoming_peer(struct rxrpc_local *local, struct rxrpc_peer *peer);\nvoid rxrpc_destroy_all_peers(struct rxrpc_net *);\nstruct rxrpc_peer *rxrpc_get_peer(struct rxrpc_peer *, enum rxrpc_peer_trace);\nstruct rxrpc_peer *rxrpc_get_peer_maybe(struct rxrpc_peer *, enum rxrpc_peer_trace);\nvoid rxrpc_put_peer(struct rxrpc_peer *, enum rxrpc_peer_trace);\n\n \nextern const struct seq_operations rxrpc_call_seq_ops;\nextern const struct seq_operations rxrpc_connection_seq_ops;\nextern const struct seq_operations rxrpc_peer_seq_ops;\nextern const struct seq_operations rxrpc_local_seq_ops;\n\n \nvoid rxrpc_notify_socket(struct rxrpc_call *);\nint rxrpc_recvmsg(struct socket *, struct msghdr *, size_t, int);\n\n \nstatic inline int rxrpc_abort_eproto(struct rxrpc_call *call,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     s32 abort_code,\n\t\t\t\t     enum rxrpc_abort_reason why)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\n\trxrpc_abort_call(call, sp->hdr.seq, abort_code, -EPROTO, why);\n\treturn -EPROTO;\n}\n\n \nvoid rxrpc_peer_add_rtt(struct rxrpc_call *, enum rxrpc_rtt_rx_trace, int,\n\t\t\trxrpc_serial_t, rxrpc_serial_t, ktime_t, ktime_t);\nunsigned long rxrpc_get_rto_backoff(struct rxrpc_peer *, bool);\nvoid rxrpc_peer_init_rtt(struct rxrpc_peer *);\n\n \n#ifdef CONFIG_RXKAD\nextern const struct rxrpc_security rxkad;\n#endif\n\n \nint __init rxrpc_init_security(void);\nconst struct rxrpc_security *rxrpc_security_lookup(u8);\nvoid rxrpc_exit_security(void);\nint rxrpc_init_client_call_security(struct rxrpc_call *);\nint rxrpc_init_client_conn_security(struct rxrpc_connection *);\nconst struct rxrpc_security *rxrpc_get_incoming_security(struct rxrpc_sock *,\n\t\t\t\t\t\t\t struct sk_buff *);\nstruct key *rxrpc_look_up_server_security(struct rxrpc_connection *,\n\t\t\t\t\t  struct sk_buff *, u32, u32);\n\n \nbool rxrpc_propose_abort(struct rxrpc_call *call, s32 abort_code, int error,\n\t\t\t enum rxrpc_abort_reason why);\nint rxrpc_do_sendmsg(struct rxrpc_sock *, struct msghdr *, size_t);\n\n \nextern struct key_type key_type_rxrpc_s;\n\nint rxrpc_server_keyring(struct rxrpc_sock *, sockptr_t, int);\n\n \nvoid rxrpc_kernel_data_consumed(struct rxrpc_call *, struct sk_buff *);\nvoid rxrpc_new_skb(struct sk_buff *, enum rxrpc_skb_trace);\nvoid rxrpc_see_skb(struct sk_buff *, enum rxrpc_skb_trace);\nvoid rxrpc_eaten_skb(struct sk_buff *, enum rxrpc_skb_trace);\nvoid rxrpc_get_skb(struct sk_buff *, enum rxrpc_skb_trace);\nvoid rxrpc_free_skb(struct sk_buff *, enum rxrpc_skb_trace);\nvoid rxrpc_purge_queue(struct sk_buff_head *);\n\n \nint rxrpc_stats_show(struct seq_file *seq, void *v);\nint rxrpc_stats_clear(struct file *file, char *buf, size_t size);\n\n#define rxrpc_inc_stat(rxnet, s) atomic_inc(&(rxnet)->s)\n#define rxrpc_dec_stat(rxnet, s) atomic_dec(&(rxnet)->s)\n\n \n#ifdef CONFIG_SYSCTL\nextern int __init rxrpc_sysctl_init(void);\nextern void rxrpc_sysctl_exit(void);\n#else\nstatic inline int __init rxrpc_sysctl_init(void) { return 0; }\nstatic inline void rxrpc_sysctl_exit(void) {}\n#endif\n\n \nextern atomic_t rxrpc_nr_txbuf;\nstruct rxrpc_txbuf *rxrpc_alloc_txbuf(struct rxrpc_call *call, u8 packet_type,\n\t\t\t\t      gfp_t gfp);\nvoid rxrpc_get_txbuf(struct rxrpc_txbuf *txb, enum rxrpc_txbuf_trace what);\nvoid rxrpc_see_txbuf(struct rxrpc_txbuf *txb, enum rxrpc_txbuf_trace what);\nvoid rxrpc_put_txbuf(struct rxrpc_txbuf *txb, enum rxrpc_txbuf_trace what);\n\n \nint rxrpc_extract_addr_from_skb(struct sockaddr_rxrpc *, struct sk_buff *);\n\nstatic inline bool before(u32 seq1, u32 seq2)\n{\n        return (s32)(seq1 - seq2) < 0;\n}\nstatic inline bool before_eq(u32 seq1, u32 seq2)\n{\n        return (s32)(seq1 - seq2) <= 0;\n}\nstatic inline bool after(u32 seq1, u32 seq2)\n{\n        return (s32)(seq1 - seq2) > 0;\n}\nstatic inline bool after_eq(u32 seq1, u32 seq2)\n{\n        return (s32)(seq1 - seq2) >= 0;\n}\n\n \nextern unsigned int rxrpc_debug;\n\n#define dbgprintk(FMT,...) \\\n\tprintk(\"[%-6.6s] \"FMT\"\\n\", current->comm ,##__VA_ARGS__)\n\n#define kenter(FMT,...)\tdbgprintk(\"==> %s(\"FMT\")\",__func__ ,##__VA_ARGS__)\n#define kleave(FMT,...)\tdbgprintk(\"<== %s()\"FMT\"\",__func__ ,##__VA_ARGS__)\n#define kdebug(FMT,...)\tdbgprintk(\"    \"FMT ,##__VA_ARGS__)\n\n\n#if defined(__KDEBUG)\n#define _enter(FMT,...)\tkenter(FMT,##__VA_ARGS__)\n#define _leave(FMT,...)\tkleave(FMT,##__VA_ARGS__)\n#define _debug(FMT,...)\tkdebug(FMT,##__VA_ARGS__)\n\n#elif defined(CONFIG_AF_RXRPC_DEBUG)\n#define RXRPC_DEBUG_KENTER\t0x01\n#define RXRPC_DEBUG_KLEAVE\t0x02\n#define RXRPC_DEBUG_KDEBUG\t0x04\n\n#define _enter(FMT,...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (unlikely(rxrpc_debug & RXRPC_DEBUG_KENTER))\t\\\n\t\tkenter(FMT,##__VA_ARGS__);\t\t\\\n} while (0)\n\n#define _leave(FMT,...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (unlikely(rxrpc_debug & RXRPC_DEBUG_KLEAVE))\t\\\n\t\tkleave(FMT,##__VA_ARGS__);\t\t\\\n} while (0)\n\n#define _debug(FMT,...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tif (unlikely(rxrpc_debug & RXRPC_DEBUG_KDEBUG))\t\\\n\t\tkdebug(FMT,##__VA_ARGS__);\t\t\\\n} while (0)\n\n#else\n#define _enter(FMT,...)\tno_printk(\"==> %s(\"FMT\")\",__func__ ,##__VA_ARGS__)\n#define _leave(FMT,...)\tno_printk(\"<== %s()\"FMT\"\",__func__ ,##__VA_ARGS__)\n#define _debug(FMT,...)\tno_printk(\"    \"FMT ,##__VA_ARGS__)\n#endif\n\n \n#if 1 \n\n#define ASSERT(X)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (unlikely(!(X))) {\t\t\t\t\t\\\n\t\tpr_err(\"Assertion failed\\n\");\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n} while (0)\n\n#define ASSERTCMP(X, OP, Y)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t__typeof__(X) _x = (X);\t\t\t\t\t\t\\\n\t__typeof__(Y) _y = (__typeof__(X))(Y);\t\t\t\t\\\n\tif (unlikely(!(_x OP _y))) {\t\t\t\t\t\\\n\t\tpr_err(\"Assertion failed - %lu(0x%lx) %s %lu(0x%lx) is false\\n\", \\\n\t\t       (unsigned long)_x, (unsigned long)_x, #OP,\t\\\n\t\t       (unsigned long)_y, (unsigned long)_y);\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define ASSERTIF(C, X)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (unlikely((C) && !(X))) {\t\t\t\t\\\n\t\tpr_err(\"Assertion failed\\n\");\t\t\t\\\n\t\tBUG();\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n} while (0)\n\n#define ASSERTIFCMP(C, X, OP, Y)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\t__typeof__(X) _x = (X);\t\t\t\t\t\t\\\n\t__typeof__(Y) _y = (__typeof__(X))(Y);\t\t\t\t\\\n\tif (unlikely((C) && !(_x OP _y))) {\t\t\t\t\\\n\t\tpr_err(\"Assertion failed - %lu(0x%lx) %s %lu(0x%lx) is false\\n\", \\\n\t\t       (unsigned long)_x, (unsigned long)_x, #OP,\t\\\n\t\t       (unsigned long)_y, (unsigned long)_y);\t\t\\\n\t\tBUG();\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#else\n\n#define ASSERT(X)\t\t\t\t\\\ndo {\t\t\t\t\t\t\\\n} while (0)\n\n#define ASSERTCMP(X, OP, Y)\t\t\t\\\ndo {\t\t\t\t\t\t\\\n} while (0)\n\n#define ASSERTIF(C, X)\t\t\t\t\\\ndo {\t\t\t\t\t\t\\\n} while (0)\n\n#define ASSERTIFCMP(C, X, OP, Y)\t\t\\\ndo {\t\t\t\t\t\t\\\n} while (0)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}