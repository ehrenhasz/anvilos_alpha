{
  "module_name": "input.c",
  "hash_id": "49ce9856d7b851d9bb826074990295602c0710f7ef7f7cc8598088f6510b40f0",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/input.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"ar-internal.h\"\n\nstatic void rxrpc_proto_abort(struct rxrpc_call *call, rxrpc_seq_t seq,\n\t\t\t      enum rxrpc_abort_reason why)\n{\n\trxrpc_abort_call(call, seq, RX_PROTOCOL_ERROR, -EBADMSG, why);\n}\n\n \nstatic void rxrpc_congestion_management(struct rxrpc_call *call,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tstruct rxrpc_ack_summary *summary,\n\t\t\t\t\trxrpc_serial_t acked_serial)\n{\n\tenum rxrpc_congest_change change = rxrpc_cong_no_change;\n\tunsigned int cumulative_acks = call->cong_cumul_acks;\n\tunsigned int cwnd = call->cong_cwnd;\n\tbool resend = false;\n\n\tsummary->flight_size =\n\t\t(call->tx_top - call->acks_hard_ack) - summary->nr_acks;\n\n\tif (test_and_clear_bit(RXRPC_CALL_RETRANS_TIMEOUT, &call->flags)) {\n\t\tsummary->retrans_timeo = true;\n\t\tcall->cong_ssthresh = max_t(unsigned int,\n\t\t\t\t\t    summary->flight_size / 2, 2);\n\t\tcwnd = 1;\n\t\tif (cwnd >= call->cong_ssthresh &&\n\t\t    call->cong_mode == RXRPC_CALL_SLOW_START) {\n\t\t\tcall->cong_mode = RXRPC_CALL_CONGEST_AVOIDANCE;\n\t\t\tcall->cong_tstamp = skb->tstamp;\n\t\t\tcumulative_acks = 0;\n\t\t}\n\t}\n\n\tcumulative_acks += summary->nr_new_acks;\n\tcumulative_acks += summary->nr_rot_new_acks;\n\tif (cumulative_acks > 255)\n\t\tcumulative_acks = 255;\n\n\tsummary->mode = call->cong_mode;\n\tsummary->cwnd = call->cong_cwnd;\n\tsummary->ssthresh = call->cong_ssthresh;\n\tsummary->cumulative_acks = cumulative_acks;\n\tsummary->dup_acks = call->cong_dup_acks;\n\n\tswitch (call->cong_mode) {\n\tcase RXRPC_CALL_SLOW_START:\n\t\tif (summary->saw_nacks)\n\t\t\tgoto packet_loss_detected;\n\t\tif (summary->cumulative_acks > 0)\n\t\t\tcwnd += 1;\n\t\tif (cwnd >= call->cong_ssthresh) {\n\t\t\tcall->cong_mode = RXRPC_CALL_CONGEST_AVOIDANCE;\n\t\t\tcall->cong_tstamp = skb->tstamp;\n\t\t}\n\t\tgoto out;\n\n\tcase RXRPC_CALL_CONGEST_AVOIDANCE:\n\t\tif (summary->saw_nacks)\n\t\t\tgoto packet_loss_detected;\n\n\t\t \n\t\tif (call->peer->rtt_count == 0)\n\t\t\tgoto out;\n\t\tif (ktime_before(skb->tstamp,\n\t\t\t\t ktime_add_us(call->cong_tstamp,\n\t\t\t\t\t      call->peer->srtt_us >> 3)))\n\t\t\tgoto out_no_clear_ca;\n\t\tchange = rxrpc_cong_rtt_window_end;\n\t\tcall->cong_tstamp = skb->tstamp;\n\t\tif (cumulative_acks >= cwnd)\n\t\t\tcwnd++;\n\t\tgoto out;\n\n\tcase RXRPC_CALL_PACKET_LOSS:\n\t\tif (!summary->saw_nacks)\n\t\t\tgoto resume_normality;\n\n\t\tif (summary->new_low_nack) {\n\t\t\tchange = rxrpc_cong_new_low_nack;\n\t\t\tcall->cong_dup_acks = 1;\n\t\t\tif (call->cong_extra > 1)\n\t\t\t\tcall->cong_extra = 1;\n\t\t\tgoto send_extra_data;\n\t\t}\n\n\t\tcall->cong_dup_acks++;\n\t\tif (call->cong_dup_acks < 3)\n\t\t\tgoto send_extra_data;\n\n\t\tchange = rxrpc_cong_begin_retransmission;\n\t\tcall->cong_mode = RXRPC_CALL_FAST_RETRANSMIT;\n\t\tcall->cong_ssthresh = max_t(unsigned int,\n\t\t\t\t\t    summary->flight_size / 2, 2);\n\t\tcwnd = call->cong_ssthresh + 3;\n\t\tcall->cong_extra = 0;\n\t\tcall->cong_dup_acks = 0;\n\t\tresend = true;\n\t\tgoto out;\n\n\tcase RXRPC_CALL_FAST_RETRANSMIT:\n\t\tif (!summary->new_low_nack) {\n\t\t\tif (summary->nr_new_acks == 0)\n\t\t\t\tcwnd += 1;\n\t\t\tcall->cong_dup_acks++;\n\t\t\tif (call->cong_dup_acks == 2) {\n\t\t\t\tchange = rxrpc_cong_retransmit_again;\n\t\t\t\tcall->cong_dup_acks = 0;\n\t\t\t\tresend = true;\n\t\t\t}\n\t\t} else {\n\t\t\tchange = rxrpc_cong_progress;\n\t\t\tcwnd = call->cong_ssthresh;\n\t\t\tif (!summary->saw_nacks)\n\t\t\t\tgoto resume_normality;\n\t\t}\n\t\tgoto out;\n\n\tdefault:\n\t\tBUG();\n\t\tgoto out;\n\t}\n\nresume_normality:\n\tchange = rxrpc_cong_cleared_nacks;\n\tcall->cong_dup_acks = 0;\n\tcall->cong_extra = 0;\n\tcall->cong_tstamp = skb->tstamp;\n\tif (cwnd < call->cong_ssthresh)\n\t\tcall->cong_mode = RXRPC_CALL_SLOW_START;\n\telse\n\t\tcall->cong_mode = RXRPC_CALL_CONGEST_AVOIDANCE;\nout:\n\tcumulative_acks = 0;\nout_no_clear_ca:\n\tif (cwnd >= RXRPC_TX_MAX_WINDOW)\n\t\tcwnd = RXRPC_TX_MAX_WINDOW;\n\tcall->cong_cwnd = cwnd;\n\tcall->cong_cumul_acks = cumulative_acks;\n\ttrace_rxrpc_congest(call, summary, acked_serial, change);\n\tif (resend)\n\t\trxrpc_resend(call, skb);\n\treturn;\n\npacket_loss_detected:\n\tchange = rxrpc_cong_saw_nack;\n\tcall->cong_mode = RXRPC_CALL_PACKET_LOSS;\n\tcall->cong_dup_acks = 0;\n\tgoto send_extra_data;\n\nsend_extra_data:\n\t \n\tif (test_bit(RXRPC_CALL_TX_LAST, &call->flags) ||\n\t    summary->nr_acks != call->tx_top - call->acks_hard_ack) {\n\t\tcall->cong_extra++;\n\t\twake_up(&call->waitq);\n\t}\n\tgoto out_no_clear_ca;\n}\n\n \nvoid rxrpc_congestion_degrade(struct rxrpc_call *call)\n{\n\tktime_t rtt, now;\n\n\tif (call->cong_mode != RXRPC_CALL_SLOW_START &&\n\t    call->cong_mode != RXRPC_CALL_CONGEST_AVOIDANCE)\n\t\treturn;\n\tif (__rxrpc_call_state(call) == RXRPC_CALL_CLIENT_AWAIT_REPLY)\n\t\treturn;\n\n\trtt = ns_to_ktime(call->peer->srtt_us * (1000 / 8));\n\tnow = ktime_get_real();\n\tif (!ktime_before(ktime_add(call->tx_last_sent, rtt), now))\n\t\treturn;\n\n\ttrace_rxrpc_reset_cwnd(call, now);\n\trxrpc_inc_stat(call->rxnet, stat_tx_data_cwnd_reset);\n\tcall->tx_last_sent = now;\n\tcall->cong_mode = RXRPC_CALL_SLOW_START;\n\tcall->cong_ssthresh = max_t(unsigned int, call->cong_ssthresh,\n\t\t\t\t    call->cong_cwnd * 3 / 4);\n\tcall->cong_cwnd = max_t(unsigned int, call->cong_cwnd / 2, RXRPC_MIN_CWND);\n}\n\n \nstatic bool rxrpc_rotate_tx_window(struct rxrpc_call *call, rxrpc_seq_t to,\n\t\t\t\t   struct rxrpc_ack_summary *summary)\n{\n\tstruct rxrpc_txbuf *txb;\n\tbool rot_last = false;\n\n\tlist_for_each_entry_rcu(txb, &call->tx_buffer, call_link, false) {\n\t\tif (before_eq(txb->seq, call->acks_hard_ack))\n\t\t\tcontinue;\n\t\tsummary->nr_rot_new_acks++;\n\t\tif (test_bit(RXRPC_TXBUF_LAST, &txb->flags)) {\n\t\t\tset_bit(RXRPC_CALL_TX_LAST, &call->flags);\n\t\t\trot_last = true;\n\t\t}\n\t\tif (txb->seq == to)\n\t\t\tbreak;\n\t}\n\n\tif (rot_last)\n\t\tset_bit(RXRPC_CALL_TX_ALL_ACKED, &call->flags);\n\n\t_enter(\"%x,%x,%x,%d\", to, call->acks_hard_ack, call->tx_top, rot_last);\n\n\tif (call->acks_lowest_nak == call->acks_hard_ack) {\n\t\tcall->acks_lowest_nak = to;\n\t} else if (after(to, call->acks_lowest_nak)) {\n\t\tsummary->new_low_nack = true;\n\t\tcall->acks_lowest_nak = to;\n\t}\n\n\tsmp_store_release(&call->acks_hard_ack, to);\n\n\ttrace_rxrpc_txqueue(call, (rot_last ?\n\t\t\t\t   rxrpc_txqueue_rotate_last :\n\t\t\t\t   rxrpc_txqueue_rotate));\n\twake_up(&call->waitq);\n\treturn rot_last;\n}\n\n \nstatic void rxrpc_end_tx_phase(struct rxrpc_call *call, bool reply_begun,\n\t\t\t       enum rxrpc_abort_reason abort_why)\n{\n\tASSERT(test_bit(RXRPC_CALL_TX_LAST, &call->flags));\n\n\tswitch (__rxrpc_call_state(call)) {\n\tcase RXRPC_CALL_CLIENT_SEND_REQUEST:\n\tcase RXRPC_CALL_CLIENT_AWAIT_REPLY:\n\t\tif (reply_begun) {\n\t\t\trxrpc_set_call_state(call, RXRPC_CALL_CLIENT_RECV_REPLY);\n\t\t\ttrace_rxrpc_txqueue(call, rxrpc_txqueue_end);\n\t\t\tbreak;\n\t\t}\n\n\t\trxrpc_set_call_state(call, RXRPC_CALL_CLIENT_AWAIT_REPLY);\n\t\ttrace_rxrpc_txqueue(call, rxrpc_txqueue_await_reply);\n\t\tbreak;\n\n\tcase RXRPC_CALL_SERVER_AWAIT_ACK:\n\t\trxrpc_call_completed(call);\n\t\ttrace_rxrpc_txqueue(call, rxrpc_txqueue_end);\n\t\tbreak;\n\n\tdefault:\n\t\tkdebug(\"end_tx %s\", rxrpc_call_states[__rxrpc_call_state(call)]);\n\t\trxrpc_proto_abort(call, call->tx_top, abort_why);\n\t\tbreak;\n\t}\n}\n\n \nstatic bool rxrpc_receiving_reply(struct rxrpc_call *call)\n{\n\tstruct rxrpc_ack_summary summary = { 0 };\n\tunsigned long now, timo;\n\trxrpc_seq_t top = READ_ONCE(call->tx_top);\n\n\tif (call->ackr_reason) {\n\t\tnow = jiffies;\n\t\ttimo = now + MAX_JIFFY_OFFSET;\n\n\t\tWRITE_ONCE(call->delay_ack_at, timo);\n\t\ttrace_rxrpc_timer(call, rxrpc_timer_init_for_reply, now);\n\t}\n\n\tif (!test_bit(RXRPC_CALL_TX_LAST, &call->flags)) {\n\t\tif (!rxrpc_rotate_tx_window(call, top, &summary)) {\n\t\t\trxrpc_proto_abort(call, top, rxrpc_eproto_early_reply);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\trxrpc_end_tx_phase(call, true, rxrpc_eproto_unexpected_reply);\n\treturn true;\n}\n\n \nstatic void rxrpc_end_rx_phase(struct rxrpc_call *call, rxrpc_serial_t serial)\n{\n\trxrpc_seq_t whigh = READ_ONCE(call->rx_highest_seq);\n\n\t_enter(\"%d,%s\", call->debug_id, rxrpc_call_states[__rxrpc_call_state(call)]);\n\n\ttrace_rxrpc_receive(call, rxrpc_receive_end, 0, whigh);\n\n\tswitch (__rxrpc_call_state(call)) {\n\tcase RXRPC_CALL_CLIENT_RECV_REPLY:\n\t\trxrpc_propose_delay_ACK(call, serial, rxrpc_propose_ack_terminal_ack);\n\t\trxrpc_call_completed(call);\n\t\tbreak;\n\n\tcase RXRPC_CALL_SERVER_RECV_REQUEST:\n\t\trxrpc_set_call_state(call, RXRPC_CALL_SERVER_ACK_REQUEST);\n\t\tcall->expect_req_by = jiffies + MAX_JIFFY_OFFSET;\n\t\trxrpc_propose_delay_ACK(call, serial, rxrpc_propose_ack_processing_op);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rxrpc_input_update_ack_window(struct rxrpc_call *call,\n\t\t\t\t\t  rxrpc_seq_t window, rxrpc_seq_t wtop)\n{\n\tcall->ackr_window = window;\n\tcall->ackr_wtop = wtop;\n}\n\n \nstatic void rxrpc_input_queue_data(struct rxrpc_call *call, struct sk_buff *skb,\n\t\t\t\t   rxrpc_seq_t window, rxrpc_seq_t wtop,\n\t\t\t\t   enum rxrpc_receive_trace why)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tbool last = sp->hdr.flags & RXRPC_LAST_PACKET;\n\n\t__skb_queue_tail(&call->recvmsg_queue, skb);\n\trxrpc_input_update_ack_window(call, window, wtop);\n\ttrace_rxrpc_receive(call, last ? why + 1 : why, sp->hdr.serial, sp->hdr.seq);\n\tif (last)\n\t\trxrpc_end_rx_phase(call, sp->hdr.serial);\n}\n\n \nstatic void rxrpc_input_data_one(struct rxrpc_call *call, struct sk_buff *skb,\n\t\t\t\t bool *_notify)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tstruct sk_buff *oos;\n\trxrpc_serial_t serial = sp->hdr.serial;\n\tunsigned int sack = call->ackr_sack_base;\n\trxrpc_seq_t window = call->ackr_window;\n\trxrpc_seq_t wtop = call->ackr_wtop;\n\trxrpc_seq_t wlimit = window + call->rx_winsize - 1;\n\trxrpc_seq_t seq = sp->hdr.seq;\n\tbool last = sp->hdr.flags & RXRPC_LAST_PACKET;\n\tint ack_reason = -1;\n\n\trxrpc_inc_stat(call->rxnet, stat_rx_data);\n\tif (sp->hdr.flags & RXRPC_REQUEST_ACK)\n\t\trxrpc_inc_stat(call->rxnet, stat_rx_data_reqack);\n\tif (sp->hdr.flags & RXRPC_JUMBO_PACKET)\n\t\trxrpc_inc_stat(call->rxnet, stat_rx_data_jumbo);\n\n\tif (last) {\n\t\tif (test_and_set_bit(RXRPC_CALL_RX_LAST, &call->flags) &&\n\t\t    seq + 1 != wtop)\n\t\t\treturn rxrpc_proto_abort(call, seq, rxrpc_eproto_different_last);\n\t} else {\n\t\tif (test_bit(RXRPC_CALL_RX_LAST, &call->flags) &&\n\t\t    after_eq(seq, wtop)) {\n\t\t\tpr_warn(\"Packet beyond last: c=%x q=%x window=%x-%x wlimit=%x\\n\",\n\t\t\t\tcall->debug_id, seq, window, wtop, wlimit);\n\t\t\treturn rxrpc_proto_abort(call, seq, rxrpc_eproto_data_after_last);\n\t\t}\n\t}\n\n\tif (after(seq, call->rx_highest_seq))\n\t\tcall->rx_highest_seq = seq;\n\n\ttrace_rxrpc_rx_data(call->debug_id, seq, serial, sp->hdr.flags);\n\n\tif (before(seq, window)) {\n\t\tack_reason = RXRPC_ACK_DUPLICATE;\n\t\tgoto send_ack;\n\t}\n\tif (after(seq, wlimit)) {\n\t\tack_reason = RXRPC_ACK_EXCEEDS_WINDOW;\n\t\tgoto send_ack;\n\t}\n\n\t \n\tif (seq == window) {\n\t\tif (sp->hdr.flags & RXRPC_REQUEST_ACK)\n\t\t\tack_reason = RXRPC_ACK_REQUESTED;\n\t\t \n\t\telse if (!skb_queue_empty(&call->rx_oos_queue))\n\t\t\tack_reason = RXRPC_ACK_DELAY;\n\t\telse\n\t\t\tcall->ackr_nr_unacked++;\n\n\t\twindow++;\n\t\tif (after(window, wtop)) {\n\t\t\ttrace_rxrpc_sack(call, seq, sack, rxrpc_sack_none);\n\t\t\twtop = window;\n\t\t} else {\n\t\t\ttrace_rxrpc_sack(call, seq, sack, rxrpc_sack_advance);\n\t\t\tsack = (sack + 1) % RXRPC_SACK_SIZE;\n\t\t}\n\n\n\t\trxrpc_get_skb(skb, rxrpc_skb_get_to_recvmsg);\n\n\t\tspin_lock(&call->recvmsg_queue.lock);\n\t\trxrpc_input_queue_data(call, skb, window, wtop, rxrpc_receive_queue);\n\t\t*_notify = true;\n\n\t\twhile ((oos = skb_peek(&call->rx_oos_queue))) {\n\t\t\tstruct rxrpc_skb_priv *osp = rxrpc_skb(oos);\n\n\t\t\tif (after(osp->hdr.seq, window))\n\t\t\t\tbreak;\n\n\t\t\t__skb_unlink(oos, &call->rx_oos_queue);\n\t\t\tlast = osp->hdr.flags & RXRPC_LAST_PACKET;\n\t\t\tseq = osp->hdr.seq;\n\t\t\tcall->ackr_sack_table[sack] = 0;\n\t\t\ttrace_rxrpc_sack(call, seq, sack, rxrpc_sack_fill);\n\t\t\tsack = (sack + 1) % RXRPC_SACK_SIZE;\n\n\t\t\twindow++;\n\t\t\trxrpc_input_queue_data(call, oos, window, wtop,\n\t\t\t\t\t       rxrpc_receive_queue_oos);\n\t\t}\n\n\t\tspin_unlock(&call->recvmsg_queue.lock);\n\n\t\tcall->ackr_sack_base = sack;\n\t} else {\n\t\tunsigned int slot;\n\n\t\tack_reason = RXRPC_ACK_OUT_OF_SEQUENCE;\n\n\t\tslot = seq - window;\n\t\tsack = (sack + slot) % RXRPC_SACK_SIZE;\n\n\t\tif (call->ackr_sack_table[sack % RXRPC_SACK_SIZE]) {\n\t\t\tack_reason = RXRPC_ACK_DUPLICATE;\n\t\t\tgoto send_ack;\n\t\t}\n\n\t\tcall->ackr_sack_table[sack % RXRPC_SACK_SIZE] |= 1;\n\t\ttrace_rxrpc_sack(call, seq, sack, rxrpc_sack_oos);\n\n\t\tif (after(seq + 1, wtop)) {\n\t\t\twtop = seq + 1;\n\t\t\trxrpc_input_update_ack_window(call, window, wtop);\n\t\t}\n\n\t\tskb_queue_walk(&call->rx_oos_queue, oos) {\n\t\t\tstruct rxrpc_skb_priv *osp = rxrpc_skb(oos);\n\n\t\t\tif (after(osp->hdr.seq, seq)) {\n\t\t\t\trxrpc_get_skb(skb, rxrpc_skb_get_to_recvmsg_oos);\n\t\t\t\t__skb_queue_before(&call->rx_oos_queue, oos, skb);\n\t\t\t\tgoto oos_queued;\n\t\t\t}\n\t\t}\n\n\t\trxrpc_get_skb(skb, rxrpc_skb_get_to_recvmsg_oos);\n\t\t__skb_queue_tail(&call->rx_oos_queue, skb);\n\toos_queued:\n\t\ttrace_rxrpc_receive(call, last ? rxrpc_receive_oos_last : rxrpc_receive_oos,\n\t\t\t\t    sp->hdr.serial, sp->hdr.seq);\n\t}\n\nsend_ack:\n\tif (ack_reason >= 0)\n\t\trxrpc_send_ACK(call, ack_reason, serial,\n\t\t\t       rxrpc_propose_ack_input_data);\n\telse\n\t\trxrpc_propose_delay_ACK(call, serial,\n\t\t\t\t\trxrpc_propose_ack_input_data);\n}\n\n \nstatic bool rxrpc_input_split_jumbo(struct rxrpc_call *call, struct sk_buff *skb)\n{\n\tstruct rxrpc_jumbo_header jhdr;\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb), *jsp;\n\tstruct sk_buff *jskb;\n\tunsigned int offset = sizeof(struct rxrpc_wire_header);\n\tunsigned int len = skb->len - offset;\n\tbool notify = false;\n\n\twhile (sp->hdr.flags & RXRPC_JUMBO_PACKET) {\n\t\tif (len < RXRPC_JUMBO_SUBPKTLEN)\n\t\t\tgoto protocol_error;\n\t\tif (sp->hdr.flags & RXRPC_LAST_PACKET)\n\t\t\tgoto protocol_error;\n\t\tif (skb_copy_bits(skb, offset + RXRPC_JUMBO_DATALEN,\n\t\t\t\t  &jhdr, sizeof(jhdr)) < 0)\n\t\t\tgoto protocol_error;\n\n\t\tjskb = skb_clone(skb, GFP_NOFS);\n\t\tif (!jskb) {\n\t\t\tkdebug(\"couldn't clone\");\n\t\t\treturn false;\n\t\t}\n\t\trxrpc_new_skb(jskb, rxrpc_skb_new_jumbo_subpacket);\n\t\tjsp = rxrpc_skb(jskb);\n\t\tjsp->offset = offset;\n\t\tjsp->len = RXRPC_JUMBO_DATALEN;\n\t\trxrpc_input_data_one(call, jskb, &notify);\n\t\trxrpc_free_skb(jskb, rxrpc_skb_put_jumbo_subpacket);\n\n\t\tsp->hdr.flags = jhdr.flags;\n\t\tsp->hdr._rsvd = ntohs(jhdr._rsvd);\n\t\tsp->hdr.seq++;\n\t\tsp->hdr.serial++;\n\t\toffset += RXRPC_JUMBO_SUBPKTLEN;\n\t\tlen -= RXRPC_JUMBO_SUBPKTLEN;\n\t}\n\n\tsp->offset = offset;\n\tsp->len    = len;\n\trxrpc_input_data_one(call, skb, &notify);\n\tif (notify) {\n\t\ttrace_rxrpc_notify_socket(call->debug_id, sp->hdr.serial);\n\t\trxrpc_notify_socket(call);\n\t}\n\treturn true;\n\nprotocol_error:\n\treturn false;\n}\n\n \nstatic void rxrpc_input_data(struct rxrpc_call *call, struct sk_buff *skb)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\trxrpc_serial_t serial = sp->hdr.serial;\n\trxrpc_seq_t seq0 = sp->hdr.seq;\n\n\t_enter(\"{%x,%x,%x},{%u,%x}\",\n\t       call->ackr_window, call->ackr_wtop, call->rx_highest_seq,\n\t       skb->len, seq0);\n\n\tif (__rxrpc_call_is_complete(call))\n\t\treturn;\n\n\tswitch (__rxrpc_call_state(call)) {\n\tcase RXRPC_CALL_CLIENT_SEND_REQUEST:\n\tcase RXRPC_CALL_CLIENT_AWAIT_REPLY:\n\t\t \n\t\tif (!rxrpc_receiving_reply(call))\n\t\t\tgoto out_notify;\n\t\tbreak;\n\n\tcase RXRPC_CALL_SERVER_RECV_REQUEST: {\n\t\tunsigned long timo = READ_ONCE(call->next_req_timo);\n\t\tunsigned long now, expect_req_by;\n\n\t\tif (timo) {\n\t\t\tnow = jiffies;\n\t\t\texpect_req_by = now + timo;\n\t\t\tWRITE_ONCE(call->expect_req_by, expect_req_by);\n\t\t\trxrpc_reduce_call_timer(call, expect_req_by, now,\n\t\t\t\t\t\trxrpc_timer_set_for_idle);\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!rxrpc_input_split_jumbo(call, skb)) {\n\t\trxrpc_proto_abort(call, sp->hdr.seq, rxrpc_badmsg_bad_jumbo);\n\t\tgoto out_notify;\n\t}\n\treturn;\n\nout_notify:\n\ttrace_rxrpc_notify_socket(call->debug_id, serial);\n\trxrpc_notify_socket(call);\n\t_leave(\" [queued]\");\n}\n\n \nstatic void rxrpc_complete_rtt_probe(struct rxrpc_call *call,\n\t\t\t\t     ktime_t resp_time,\n\t\t\t\t     rxrpc_serial_t acked_serial,\n\t\t\t\t     rxrpc_serial_t ack_serial,\n\t\t\t\t     enum rxrpc_rtt_rx_trace type)\n{\n\trxrpc_serial_t orig_serial;\n\tunsigned long avail;\n\tktime_t sent_at;\n\tbool matched = false;\n\tint i;\n\n\tavail = READ_ONCE(call->rtt_avail);\n\tsmp_rmb();  \n\n\tfor (i = 0; i < ARRAY_SIZE(call->rtt_serial); i++) {\n\t\tif (!test_bit(i + RXRPC_CALL_RTT_PEND_SHIFT, &avail))\n\t\t\tcontinue;\n\n\t\tsent_at = call->rtt_sent_at[i];\n\t\torig_serial = call->rtt_serial[i];\n\n\t\tif (orig_serial == acked_serial) {\n\t\t\tclear_bit(i + RXRPC_CALL_RTT_PEND_SHIFT, &call->rtt_avail);\n\t\t\tsmp_mb();  \n\t\t\tset_bit(i, &call->rtt_avail);\n\t\t\trxrpc_peer_add_rtt(call, type, i, acked_serial, ack_serial,\n\t\t\t\t\t   sent_at, resp_time);\n\t\t\tmatched = true;\n\t\t}\n\n\t\t \n\t\tif (after(acked_serial, orig_serial)) {\n\t\t\ttrace_rxrpc_rtt_rx(call, rxrpc_rtt_rx_obsolete, i,\n\t\t\t\t\t   orig_serial, acked_serial, 0, 0);\n\t\t\tclear_bit(i + RXRPC_CALL_RTT_PEND_SHIFT, &call->rtt_avail);\n\t\t\tsmp_wmb();\n\t\t\tset_bit(i, &call->rtt_avail);\n\t\t}\n\t}\n\n\tif (!matched)\n\t\ttrace_rxrpc_rtt_rx(call, rxrpc_rtt_rx_lost, 9, 0, acked_serial, 0, 0);\n}\n\n \nstatic void rxrpc_input_ackinfo(struct rxrpc_call *call, struct sk_buff *skb,\n\t\t\t\tstruct rxrpc_ackinfo *ackinfo)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tstruct rxrpc_peer *peer;\n\tunsigned int mtu;\n\tbool wake = false;\n\tu32 rwind = ntohl(ackinfo->rwind);\n\n\tif (rwind > RXRPC_TX_MAX_WINDOW)\n\t\trwind = RXRPC_TX_MAX_WINDOW;\n\tif (call->tx_winsize != rwind) {\n\t\tif (rwind > call->tx_winsize)\n\t\t\twake = true;\n\t\ttrace_rxrpc_rx_rwind_change(call, sp->hdr.serial, rwind, wake);\n\t\tcall->tx_winsize = rwind;\n\t}\n\n\tif (call->cong_ssthresh > rwind)\n\t\tcall->cong_ssthresh = rwind;\n\n\tmtu = min(ntohl(ackinfo->rxMTU), ntohl(ackinfo->maxMTU));\n\n\tpeer = call->peer;\n\tif (mtu < peer->maxdata) {\n\t\tspin_lock(&peer->lock);\n\t\tpeer->maxdata = mtu;\n\t\tpeer->mtu = mtu + peer->hdrsize;\n\t\tspin_unlock(&peer->lock);\n\t}\n\n\tif (wake)\n\t\twake_up(&call->waitq);\n}\n\n \nstatic void rxrpc_input_soft_acks(struct rxrpc_call *call, u8 *acks,\n\t\t\t\t  rxrpc_seq_t seq, int nr_acks,\n\t\t\t\t  struct rxrpc_ack_summary *summary)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < nr_acks; i++) {\n\t\tif (acks[i] == RXRPC_ACK_TYPE_ACK) {\n\t\t\tsummary->nr_acks++;\n\t\t\tsummary->nr_new_acks++;\n\t\t} else {\n\t\t\tif (!summary->saw_nacks &&\n\t\t\t    call->acks_lowest_nak != seq + i) {\n\t\t\t\tcall->acks_lowest_nak = seq + i;\n\t\t\t\tsummary->new_low_nack = true;\n\t\t\t}\n\t\t\tsummary->saw_nacks = true;\n\t\t}\n\t}\n}\n\n \nstatic bool rxrpc_is_ack_valid(struct rxrpc_call *call,\n\t\t\t       rxrpc_seq_t first_pkt, rxrpc_seq_t prev_pkt)\n{\n\trxrpc_seq_t base = READ_ONCE(call->acks_first_seq);\n\n\tif (after(first_pkt, base))\n\t\treturn true;  \n\n\tif (before(first_pkt, base))\n\t\treturn false;  \n\n\tif (after_eq(prev_pkt, call->acks_prev_seq))\n\t\treturn true;  \n\n\t \n\tif (after_eq(prev_pkt, base + call->tx_winsize))\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic void rxrpc_input_ack(struct rxrpc_call *call, struct sk_buff *skb)\n{\n\tstruct rxrpc_ack_summary summary = { 0 };\n\tstruct rxrpc_ackpacket ack;\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tstruct rxrpc_ackinfo info;\n\trxrpc_serial_t ack_serial, acked_serial;\n\trxrpc_seq_t first_soft_ack, hard_ack, prev_pkt;\n\tint nr_acks, offset, ioffset;\n\n\t_enter(\"\");\n\n\toffset = sizeof(struct rxrpc_wire_header);\n\tif (skb_copy_bits(skb, offset, &ack, sizeof(ack)) < 0)\n\t\treturn rxrpc_proto_abort(call, 0, rxrpc_badmsg_short_ack);\n\toffset += sizeof(ack);\n\n\tack_serial = sp->hdr.serial;\n\tacked_serial = ntohl(ack.serial);\n\tfirst_soft_ack = ntohl(ack.firstPacket);\n\tprev_pkt = ntohl(ack.previousPacket);\n\thard_ack = first_soft_ack - 1;\n\tnr_acks = ack.nAcks;\n\tsummary.ack_reason = (ack.reason < RXRPC_ACK__INVALID ?\n\t\t\t      ack.reason : RXRPC_ACK__INVALID);\n\n\ttrace_rxrpc_rx_ack(call, ack_serial, acked_serial,\n\t\t\t   first_soft_ack, prev_pkt,\n\t\t\t   summary.ack_reason, nr_acks);\n\trxrpc_inc_stat(call->rxnet, stat_rx_acks[ack.reason]);\n\n\tif (acked_serial != 0) {\n\t\tswitch (ack.reason) {\n\t\tcase RXRPC_ACK_PING_RESPONSE:\n\t\t\trxrpc_complete_rtt_probe(call, skb->tstamp, acked_serial, ack_serial,\n\t\t\t\t\t\t rxrpc_rtt_rx_ping_response);\n\t\t\tbreak;\n\t\tcase RXRPC_ACK_REQUESTED:\n\t\t\trxrpc_complete_rtt_probe(call, skb->tstamp, acked_serial, ack_serial,\n\t\t\t\t\t\t rxrpc_rtt_rx_requested_ack);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trxrpc_complete_rtt_probe(call, skb->tstamp, acked_serial, ack_serial,\n\t\t\t\t\t\t rxrpc_rtt_rx_other_ack);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (unlikely(ack.reason == RXRPC_ACK_EXCEEDS_WINDOW) &&\n\t    first_soft_ack == 1 &&\n\t    prev_pkt == 0 &&\n\t    rxrpc_is_client_call(call)) {\n\t\trxrpc_set_call_completion(call, RXRPC_CALL_REMOTELY_ABORTED,\n\t\t\t\t\t  0, -ENETRESET);\n\t\tgoto send_response;\n\t}\n\n\t \n\tif (unlikely(ack.reason == RXRPC_ACK_OUT_OF_SEQUENCE) &&\n\t    first_soft_ack == 1 &&\n\t    prev_pkt == 0 &&\n\t    call->acks_hard_ack == 0 &&\n\t    rxrpc_is_client_call(call)) {\n\t\trxrpc_set_call_completion(call, RXRPC_CALL_REMOTELY_ABORTED,\n\t\t\t\t\t  0, -ENETRESET);\n\t\tgoto send_response;\n\t}\n\n\t \n\tif (!rxrpc_is_ack_valid(call, first_soft_ack, prev_pkt)) {\n\t\ttrace_rxrpc_rx_discard_ack(call->debug_id, ack_serial,\n\t\t\t\t\t   first_soft_ack, call->acks_first_seq,\n\t\t\t\t\t   prev_pkt, call->acks_prev_seq);\n\t\tgoto send_response;\n\t}\n\n\tinfo.rxMTU = 0;\n\tioffset = offset + nr_acks + 3;\n\tif (skb->len >= ioffset + sizeof(info) &&\n\t    skb_copy_bits(skb, ioffset, &info, sizeof(info)) < 0)\n\t\treturn rxrpc_proto_abort(call, 0, rxrpc_badmsg_short_ack_info);\n\n\tif (nr_acks > 0)\n\t\tskb_condense(skb);\n\n\tcall->acks_latest_ts = skb->tstamp;\n\tcall->acks_first_seq = first_soft_ack;\n\tcall->acks_prev_seq = prev_pkt;\n\n\tswitch (ack.reason) {\n\tcase RXRPC_ACK_PING:\n\t\tbreak;\n\tdefault:\n\t\tif (after(acked_serial, call->acks_highest_serial))\n\t\t\tcall->acks_highest_serial = acked_serial;\n\t\tbreak;\n\t}\n\n\t \n\tif (info.rxMTU)\n\t\trxrpc_input_ackinfo(call, skb, &info);\n\n\tif (first_soft_ack == 0)\n\t\treturn rxrpc_proto_abort(call, 0, rxrpc_eproto_ackr_zero);\n\n\t \n\tswitch (__rxrpc_call_state(call)) {\n\tcase RXRPC_CALL_CLIENT_SEND_REQUEST:\n\tcase RXRPC_CALL_CLIENT_AWAIT_REPLY:\n\tcase RXRPC_CALL_SERVER_SEND_REPLY:\n\tcase RXRPC_CALL_SERVER_AWAIT_ACK:\n\t\tbreak;\n\tdefault:\n\t\tgoto send_response;\n\t}\n\n\tif (before(hard_ack, call->acks_hard_ack) ||\n\t    after(hard_ack, call->tx_top))\n\t\treturn rxrpc_proto_abort(call, 0, rxrpc_eproto_ackr_outside_window);\n\tif (nr_acks > call->tx_top - hard_ack)\n\t\treturn rxrpc_proto_abort(call, 0, rxrpc_eproto_ackr_sack_overflow);\n\n\tif (after(hard_ack, call->acks_hard_ack)) {\n\t\tif (rxrpc_rotate_tx_window(call, hard_ack, &summary)) {\n\t\t\trxrpc_end_tx_phase(call, false, rxrpc_eproto_unexpected_ack);\n\t\t\tgoto send_response;\n\t\t}\n\t}\n\n\tif (nr_acks > 0) {\n\t\tif (offset > (int)skb->len - nr_acks)\n\t\t\treturn rxrpc_proto_abort(call, 0, rxrpc_eproto_ackr_short_sack);\n\t\trxrpc_input_soft_acks(call, skb->data + offset, first_soft_ack,\n\t\t\t\t      nr_acks, &summary);\n\t}\n\n\tif (test_bit(RXRPC_CALL_TX_LAST, &call->flags) &&\n\t    summary.nr_acks == call->tx_top - hard_ack &&\n\t    rxrpc_is_client_call(call))\n\t\trxrpc_propose_ping(call, ack_serial,\n\t\t\t\t   rxrpc_propose_ack_ping_for_lost_reply);\n\n\trxrpc_congestion_management(call, skb, &summary, acked_serial);\n\nsend_response:\n\tif (ack.reason == RXRPC_ACK_PING)\n\t\trxrpc_send_ACK(call, RXRPC_ACK_PING_RESPONSE, ack_serial,\n\t\t\t       rxrpc_propose_ack_respond_to_ping);\n\telse if (sp->hdr.flags & RXRPC_REQUEST_ACK)\n\t\trxrpc_send_ACK(call, RXRPC_ACK_REQUESTED, ack_serial,\n\t\t\t       rxrpc_propose_ack_respond_to_ack);\n}\n\n \nstatic void rxrpc_input_ackall(struct rxrpc_call *call, struct sk_buff *skb)\n{\n\tstruct rxrpc_ack_summary summary = { 0 };\n\n\tif (rxrpc_rotate_tx_window(call, call->tx_top, &summary))\n\t\trxrpc_end_tx_phase(call, false, rxrpc_eproto_unexpected_ackall);\n}\n\n \nstatic void rxrpc_input_abort(struct rxrpc_call *call, struct sk_buff *skb)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\n\ttrace_rxrpc_rx_abort(call, sp->hdr.serial, skb->priority);\n\n\trxrpc_set_call_completion(call, RXRPC_CALL_REMOTELY_ABORTED,\n\t\t\t\t  skb->priority, -ECONNABORTED);\n}\n\n \nvoid rxrpc_input_call_packet(struct rxrpc_call *call, struct sk_buff *skb)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tunsigned long timo;\n\n\t_enter(\"%p,%p\", call, skb);\n\n\tif (sp->hdr.serviceId != call->dest_srx.srx_service)\n\t\tcall->dest_srx.srx_service = sp->hdr.serviceId;\n\tif ((int)sp->hdr.serial - (int)call->rx_serial > 0)\n\t\tcall->rx_serial = sp->hdr.serial;\n\tif (!test_bit(RXRPC_CALL_RX_HEARD, &call->flags))\n\t\tset_bit(RXRPC_CALL_RX_HEARD, &call->flags);\n\n\ttimo = READ_ONCE(call->next_rx_timo);\n\tif (timo) {\n\t\tunsigned long now = jiffies, expect_rx_by;\n\n\t\texpect_rx_by = now + timo;\n\t\tWRITE_ONCE(call->expect_rx_by, expect_rx_by);\n\t\trxrpc_reduce_call_timer(call, expect_rx_by, now,\n\t\t\t\t\trxrpc_timer_set_for_normal);\n\t}\n\n\tswitch (sp->hdr.type) {\n\tcase RXRPC_PACKET_TYPE_DATA:\n\t\treturn rxrpc_input_data(call, skb);\n\n\tcase RXRPC_PACKET_TYPE_ACK:\n\t\treturn rxrpc_input_ack(call, skb);\n\n\tcase RXRPC_PACKET_TYPE_BUSY:\n\t\t \n\t\treturn;\n\n\tcase RXRPC_PACKET_TYPE_ABORT:\n\t\treturn rxrpc_input_abort(call, skb);\n\n\tcase RXRPC_PACKET_TYPE_ACKALL:\n\t\treturn rxrpc_input_ackall(call, skb);\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid rxrpc_implicit_end_call(struct rxrpc_call *call, struct sk_buff *skb)\n{\n\tswitch (__rxrpc_call_state(call)) {\n\tcase RXRPC_CALL_SERVER_AWAIT_ACK:\n\t\trxrpc_call_completed(call);\n\t\tfallthrough;\n\tcase RXRPC_CALL_COMPLETE:\n\t\tbreak;\n\tdefault:\n\t\trxrpc_abort_call(call, 0, RX_CALL_DEAD, -ESHUTDOWN,\n\t\t\t\t rxrpc_eproto_improper_term);\n\t\ttrace_rxrpc_improper_term(call);\n\t\tbreak;\n\t}\n\n\trxrpc_input_call_event(call, skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}