{
  "module_name": "io_thread.c",
  "hash_id": "ecafff12e54bef307e7506af2f42dc159bab2da0fd9c737253c0d0bbc4e0823d",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/io_thread.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"ar-internal.h\"\n\nstatic int rxrpc_input_packet_on_conn(struct rxrpc_connection *conn,\n\t\t\t\t      struct sockaddr_rxrpc *peer_srx,\n\t\t\t\t      struct sk_buff *skb);\n\n \nint rxrpc_encap_rcv(struct sock *udp_sk, struct sk_buff *skb)\n{\n\tstruct sk_buff_head *rx_queue;\n\tstruct rxrpc_local *local = rcu_dereference_sk_user_data(udp_sk);\n\n\tif (unlikely(!local)) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\tif (skb->tstamp == 0)\n\t\tskb->tstamp = ktime_get_real();\n\n\tskb->mark = RXRPC_SKB_MARK_PACKET;\n\trxrpc_new_skb(skb, rxrpc_skb_new_encap_rcv);\n\trx_queue = &local->rx_queue;\n#ifdef CONFIG_AF_RXRPC_INJECT_RX_DELAY\n\tif (rxrpc_inject_rx_delay ||\n\t    !skb_queue_empty(&local->rx_delay_queue)) {\n\t\tskb->tstamp = ktime_add_ms(skb->tstamp, rxrpc_inject_rx_delay);\n\t\trx_queue = &local->rx_delay_queue;\n\t}\n#endif\n\n\tskb_queue_tail(rx_queue, skb);\n\trxrpc_wake_up_io_thread(local);\n\treturn 0;\n}\n\n \nvoid rxrpc_error_report(struct sock *sk)\n{\n\tstruct rxrpc_local *local;\n\tstruct sk_buff *skb;\n\n\trcu_read_lock();\n\tlocal = rcu_dereference_sk_user_data(sk);\n\tif (unlikely(!local)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\twhile ((skb = skb_dequeue(&sk->sk_error_queue))) {\n\t\tskb->mark = RXRPC_SKB_MARK_ERROR;\n\t\trxrpc_new_skb(skb, rxrpc_skb_new_error_report);\n\t\tskb_queue_tail(&local->rx_queue, skb);\n\t}\n\n\trxrpc_wake_up_io_thread(local);\n\trcu_read_unlock();\n}\n\n \nbool rxrpc_direct_abort(struct sk_buff *skb, enum rxrpc_abort_reason why,\n\t\t\ts32 abort_code, int err)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\n\ttrace_rxrpc_abort(0, why, sp->hdr.cid, sp->hdr.callNumber, sp->hdr.seq,\n\t\t\t  abort_code, err);\n\tskb->mark = RXRPC_SKB_MARK_REJECT_ABORT;\n\tskb->priority = abort_code;\n\treturn false;\n}\n\nstatic bool rxrpc_bad_message(struct sk_buff *skb, enum rxrpc_abort_reason why)\n{\n\treturn rxrpc_direct_abort(skb, why, RX_PROTOCOL_ERROR, -EBADMSG);\n}\n\n#define just_discard true\n\n \nstatic bool rxrpc_input_version(struct rxrpc_local *local, struct sk_buff *skb)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tchar v;\n\n\t_enter(\"\");\n\n\trxrpc_see_skb(skb, rxrpc_skb_see_version);\n\tif (skb_copy_bits(skb, sizeof(struct rxrpc_wire_header), &v, 1) >= 0) {\n\t\tif (v == 0)\n\t\t\trxrpc_send_version_request(local, &sp->hdr, skb);\n\t}\n\n\treturn true;\n}\n\n \nstatic bool rxrpc_extract_header(struct rxrpc_skb_priv *sp,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct rxrpc_wire_header whdr;\n\n\t \n\tif (skb_copy_bits(skb, 0, &whdr, sizeof(whdr)) < 0)\n\t\treturn rxrpc_bad_message(skb, rxrpc_badmsg_short_hdr);\n\n\tmemset(sp, 0, sizeof(*sp));\n\tsp->hdr.epoch\t\t= ntohl(whdr.epoch);\n\tsp->hdr.cid\t\t= ntohl(whdr.cid);\n\tsp->hdr.callNumber\t= ntohl(whdr.callNumber);\n\tsp->hdr.seq\t\t= ntohl(whdr.seq);\n\tsp->hdr.serial\t\t= ntohl(whdr.serial);\n\tsp->hdr.flags\t\t= whdr.flags;\n\tsp->hdr.type\t\t= whdr.type;\n\tsp->hdr.userStatus\t= whdr.userStatus;\n\tsp->hdr.securityIndex\t= whdr.securityIndex;\n\tsp->hdr._rsvd\t\t= ntohs(whdr._rsvd);\n\tsp->hdr.serviceId\t= ntohs(whdr.serviceId);\n\treturn true;\n}\n\n \nstatic bool rxrpc_extract_abort(struct sk_buff *skb)\n{\n\t__be32 wtmp;\n\n\tif (skb_copy_bits(skb, sizeof(struct rxrpc_wire_header),\n\t\t\t  &wtmp, sizeof(wtmp)) < 0)\n\t\treturn false;\n\tskb->priority = ntohl(wtmp);\n\treturn true;\n}\n\n \nstatic bool rxrpc_input_packet(struct rxrpc_local *local, struct sk_buff **_skb)\n{\n\tstruct rxrpc_connection *conn;\n\tstruct sockaddr_rxrpc peer_srx;\n\tstruct rxrpc_skb_priv *sp;\n\tstruct rxrpc_peer *peer = NULL;\n\tstruct sk_buff *skb = *_skb;\n\tbool ret = false;\n\n\tskb_pull(skb, sizeof(struct udphdr));\n\n\tsp = rxrpc_skb(skb);\n\n\t \n\tif (!rxrpc_extract_header(sp, skb))\n\t\treturn just_discard;\n\n\tif (IS_ENABLED(CONFIG_AF_RXRPC_INJECT_LOSS)) {\n\t\tstatic int lose;\n\t\tif ((lose++ & 7) == 7) {\n\t\t\ttrace_rxrpc_rx_lose(sp);\n\t\t\treturn just_discard;\n\t\t}\n\t}\n\n\ttrace_rxrpc_rx_packet(sp);\n\n\tswitch (sp->hdr.type) {\n\tcase RXRPC_PACKET_TYPE_VERSION:\n\t\tif (rxrpc_to_client(sp))\n\t\t\treturn just_discard;\n\t\treturn rxrpc_input_version(local, skb);\n\n\tcase RXRPC_PACKET_TYPE_BUSY:\n\t\tif (rxrpc_to_server(sp))\n\t\t\treturn just_discard;\n\t\tfallthrough;\n\tcase RXRPC_PACKET_TYPE_ACK:\n\tcase RXRPC_PACKET_TYPE_ACKALL:\n\t\tif (sp->hdr.callNumber == 0)\n\t\t\treturn rxrpc_bad_message(skb, rxrpc_badmsg_zero_call);\n\t\tbreak;\n\tcase RXRPC_PACKET_TYPE_ABORT:\n\t\tif (!rxrpc_extract_abort(skb))\n\t\t\treturn just_discard;  \n\t\tbreak;\n\n\tcase RXRPC_PACKET_TYPE_DATA:\n\t\tif (sp->hdr.callNumber == 0)\n\t\t\treturn rxrpc_bad_message(skb, rxrpc_badmsg_zero_call);\n\t\tif (sp->hdr.seq == 0)\n\t\t\treturn rxrpc_bad_message(skb, rxrpc_badmsg_zero_seq);\n\n\t\t \n\t\tif (sp->hdr.securityIndex != 0) {\n\t\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\t\tif (!skb) {\n\t\t\t\trxrpc_eaten_skb(*_skb, rxrpc_skb_eaten_by_unshare_nomem);\n\t\t\t\t*_skb = NULL;\n\t\t\t\treturn just_discard;\n\t\t\t}\n\n\t\t\tif (skb != *_skb) {\n\t\t\t\trxrpc_eaten_skb(*_skb, rxrpc_skb_eaten_by_unshare);\n\t\t\t\t*_skb = skb;\n\t\t\t\trxrpc_new_skb(skb, rxrpc_skb_new_unshared);\n\t\t\t\tsp = rxrpc_skb(skb);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase RXRPC_PACKET_TYPE_CHALLENGE:\n\t\tif (rxrpc_to_server(sp))\n\t\t\treturn just_discard;\n\t\tbreak;\n\tcase RXRPC_PACKET_TYPE_RESPONSE:\n\t\tif (rxrpc_to_client(sp))\n\t\t\treturn just_discard;\n\t\tbreak;\n\n\t\t \n\tcase RXRPC_PACKET_TYPE_PARAMS:\n\tcase RXRPC_PACKET_TYPE_10:\n\tcase RXRPC_PACKET_TYPE_11:\n\t\treturn just_discard;\n\n\tdefault:\n\t\treturn rxrpc_bad_message(skb, rxrpc_badmsg_unsupported_packet);\n\t}\n\n\tif (sp->hdr.serviceId == 0)\n\t\treturn rxrpc_bad_message(skb, rxrpc_badmsg_zero_service);\n\n\tif (WARN_ON_ONCE(rxrpc_extract_addr_from_skb(&peer_srx, skb) < 0))\n\t\treturn just_discard;  \n\n\tif (peer_srx.transport.family != local->srx.transport.family &&\n\t    (peer_srx.transport.family == AF_INET &&\n\t     local->srx.transport.family != AF_INET6)) {\n\t\tpr_warn_ratelimited(\"AF_RXRPC: Protocol mismatch %u not %u\\n\",\n\t\t\t\t    peer_srx.transport.family,\n\t\t\t\t    local->srx.transport.family);\n\t\treturn just_discard;  \n\t}\n\n\tif (rxrpc_to_client(sp)) {\n\t\trcu_read_lock();\n\t\tconn = rxrpc_find_client_connection_rcu(local, &peer_srx, skb);\n\t\tconn = rxrpc_get_connection_maybe(conn, rxrpc_conn_get_call_input);\n\t\trcu_read_unlock();\n\t\tif (!conn)\n\t\t\treturn rxrpc_protocol_error(skb, rxrpc_eproto_no_client_conn);\n\n\t\tret = rxrpc_input_packet_on_conn(conn, &peer_srx, skb);\n\t\trxrpc_put_connection(conn, rxrpc_conn_put_call_input);\n\t\treturn ret;\n\t}\n\n\t \n\trcu_read_lock();\n\n\tpeer = rxrpc_lookup_peer_rcu(local, &peer_srx);\n\tif (!peer) {\n\t\trcu_read_unlock();\n\t\treturn rxrpc_new_incoming_call(local, NULL, NULL, &peer_srx, skb);\n\t}\n\n\tconn = rxrpc_find_service_conn_rcu(peer, skb);\n\tconn = rxrpc_get_connection_maybe(conn, rxrpc_conn_get_call_input);\n\tif (conn) {\n\t\trcu_read_unlock();\n\t\tret = rxrpc_input_packet_on_conn(conn, &peer_srx, skb);\n\t\trxrpc_put_connection(conn, rxrpc_conn_put_call_input);\n\t\treturn ret;\n\t}\n\n\tpeer = rxrpc_get_peer_maybe(peer, rxrpc_peer_get_input);\n\trcu_read_unlock();\n\n\tret = rxrpc_new_incoming_call(local, peer, NULL, &peer_srx, skb);\n\trxrpc_put_peer(peer, rxrpc_peer_put_input);\n\treturn ret;\n}\n\n \nstatic int rxrpc_input_packet_on_conn(struct rxrpc_connection *conn,\n\t\t\t\t      struct sockaddr_rxrpc *peer_srx,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tstruct rxrpc_channel *chan;\n\tstruct rxrpc_call *call = NULL;\n\tunsigned int channel;\n\tbool ret;\n\n\tif (sp->hdr.securityIndex != conn->security_ix)\n\t\treturn rxrpc_direct_abort(skb, rxrpc_eproto_wrong_security,\n\t\t\t\t\t  RXKADINCONSISTENCY, -EBADMSG);\n\n\tif (sp->hdr.serviceId != conn->service_id) {\n\t\tint old_id;\n\n\t\tif (!test_bit(RXRPC_CONN_PROBING_FOR_UPGRADE, &conn->flags))\n\t\t\treturn rxrpc_protocol_error(skb, rxrpc_eproto_reupgrade);\n\n\t\told_id = cmpxchg(&conn->service_id, conn->orig_service_id,\n\t\t\t\t sp->hdr.serviceId);\n\t\tif (old_id != conn->orig_service_id &&\n\t\t    old_id != sp->hdr.serviceId)\n\t\t\treturn rxrpc_protocol_error(skb, rxrpc_eproto_bad_upgrade);\n\t}\n\n\tif (after(sp->hdr.serial, conn->hi_serial))\n\t\tconn->hi_serial = sp->hdr.serial;\n\n\t \n\tif (sp->hdr.callNumber == 0)\n\t\treturn rxrpc_input_conn_packet(conn, skb);\n\n\t \n\tchannel = sp->hdr.cid & RXRPC_CHANNELMASK;\n\tchan = &conn->channels[channel];\n\n\t \n\tif (sp->hdr.callNumber < chan->last_call)\n\t\treturn just_discard;\n\n\tif (sp->hdr.callNumber == chan->last_call) {\n\t\tif (chan->call ||\n\t\t    sp->hdr.type == RXRPC_PACKET_TYPE_ABORT)\n\t\t\treturn just_discard;\n\n\t\t \n\t\tif (rxrpc_conn_is_service(conn) &&\n\t\t    chan->last_type == RXRPC_PACKET_TYPE_ACK)\n\t\t\treturn just_discard;\n\n\t\t \n\t\tif (sp->hdr.type == RXRPC_PACKET_TYPE_DATA)\n\t\t\ttrace_rxrpc_rx_data(chan->call_debug_id,\n\t\t\t\t\t    sp->hdr.seq,\n\t\t\t\t\t    sp->hdr.serial,\n\t\t\t\t\t    sp->hdr.flags);\n\t\trxrpc_conn_retransmit_call(conn, skb, channel);\n\t\treturn just_discard;\n\t}\n\n\tcall = rxrpc_try_get_call(chan->call, rxrpc_call_get_input);\n\n\tif (sp->hdr.callNumber > chan->call_id) {\n\t\tif (rxrpc_to_client(sp)) {\n\t\t\trxrpc_put_call(call, rxrpc_call_put_input);\n\t\t\treturn rxrpc_protocol_error(skb,\n\t\t\t\t\t\t    rxrpc_eproto_unexpected_implicit_end);\n\t\t}\n\n\t\tif (call) {\n\t\t\trxrpc_implicit_end_call(call, skb);\n\t\t\trxrpc_put_call(call, rxrpc_call_put_input);\n\t\t\tcall = NULL;\n\t\t}\n\t}\n\n\tif (!call) {\n\t\tif (rxrpc_to_client(sp))\n\t\t\treturn rxrpc_protocol_error(skb, rxrpc_eproto_no_client_call);\n\t\treturn rxrpc_new_incoming_call(conn->local, conn->peer, conn,\n\t\t\t\t\t       peer_srx, skb);\n\t}\n\n\tret = rxrpc_input_call_event(call, skb);\n\trxrpc_put_call(call, rxrpc_call_put_input);\n\treturn ret;\n}\n\n \nint rxrpc_io_thread(void *data)\n{\n\tstruct rxrpc_connection *conn;\n\tstruct sk_buff_head rx_queue;\n\tstruct rxrpc_local *local = data;\n\tstruct rxrpc_call *call;\n\tstruct sk_buff *skb;\n#ifdef CONFIG_AF_RXRPC_INJECT_RX_DELAY\n\tktime_t now;\n#endif\n\tbool should_stop;\n\n\tcomplete(&local->io_thread_ready);\n\n\tskb_queue_head_init(&rx_queue);\n\n\tset_user_nice(current, MIN_NICE);\n\n\tfor (;;) {\n\t\trxrpc_inc_stat(local->rxnet, stat_io_loop);\n\n\t\t \n\t\tconn = list_first_entry_or_null(&local->conn_attend_q,\n\t\t\t\t\t\tstruct rxrpc_connection,\n\t\t\t\t\t\tattend_link);\n\t\tif (conn) {\n\t\t\tspin_lock_bh(&local->lock);\n\t\t\tlist_del_init(&conn->attend_link);\n\t\t\tspin_unlock_bh(&local->lock);\n\n\t\t\trxrpc_input_conn_event(conn, NULL);\n\t\t\trxrpc_put_connection(conn, rxrpc_conn_put_poke);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_and_clear_bit(RXRPC_CLIENT_CONN_REAP_TIMER,\n\t\t\t\t       &local->client_conn_flags))\n\t\t\trxrpc_discard_expired_client_conns(local);\n\n\t\t \n\t\tif ((call = list_first_entry_or_null(&local->call_attend_q,\n\t\t\t\t\t\t     struct rxrpc_call,\n\t\t\t\t\t\t     attend_link))) {\n\t\t\tspin_lock_bh(&local->lock);\n\t\t\tlist_del_init(&call->attend_link);\n\t\t\tspin_unlock_bh(&local->lock);\n\n\t\t\ttrace_rxrpc_call_poked(call);\n\t\t\trxrpc_input_call_event(call, NULL);\n\t\t\trxrpc_put_call(call, rxrpc_call_put_poke);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&local->new_client_calls))\n\t\t\trxrpc_connect_client_calls(local);\n\n\t\t \n\t\tif ((skb = __skb_dequeue(&rx_queue))) {\n\t\t\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\t\t\tswitch (skb->mark) {\n\t\t\tcase RXRPC_SKB_MARK_PACKET:\n\t\t\t\tskb->priority = 0;\n\t\t\t\tif (!rxrpc_input_packet(local, &skb))\n\t\t\t\t\trxrpc_reject_packet(local, skb);\n\t\t\t\ttrace_rxrpc_rx_done(skb->mark, skb->priority);\n\t\t\t\trxrpc_free_skb(skb, rxrpc_skb_put_input);\n\t\t\t\tbreak;\n\t\t\tcase RXRPC_SKB_MARK_ERROR:\n\t\t\t\trxrpc_input_error(local, skb);\n\t\t\t\trxrpc_free_skb(skb, rxrpc_skb_put_error_report);\n\t\t\t\tbreak;\n\t\t\tcase RXRPC_SKB_MARK_SERVICE_CONN_SECURED:\n\t\t\t\trxrpc_input_conn_event(sp->conn, skb);\n\t\t\t\trxrpc_put_connection(sp->conn, rxrpc_conn_put_poke);\n\t\t\t\trxrpc_free_skb(skb, rxrpc_skb_put_conn_secured);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\trxrpc_free_skb(skb, rxrpc_skb_put_unknown);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n#ifdef CONFIG_AF_RXRPC_INJECT_RX_DELAY\n\t\tnow = ktime_get_real();\n\t\twhile ((skb = skb_peek(&local->rx_delay_queue))) {\n\t\t\tif (ktime_before(now, skb->tstamp))\n\t\t\t\tbreak;\n\t\t\tskb = skb_dequeue(&local->rx_delay_queue);\n\t\t\tskb_queue_tail(&local->rx_queue, skb);\n\t\t}\n#endif\n\n\t\tif (!skb_queue_empty(&local->rx_queue)) {\n\t\t\tspin_lock_irq(&local->rx_queue.lock);\n\t\t\tskb_queue_splice_tail_init(&local->rx_queue, &rx_queue);\n\t\t\tspin_unlock_irq(&local->rx_queue.lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tshould_stop = kthread_should_stop();\n\t\tif (!skb_queue_empty(&local->rx_queue) ||\n\t\t    !list_empty(&local->call_attend_q) ||\n\t\t    !list_empty(&local->conn_attend_q) ||\n\t\t    !list_empty(&local->new_client_calls) ||\n\t\t    test_bit(RXRPC_CLIENT_CONN_REAP_TIMER,\n\t\t\t     &local->client_conn_flags)) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_stop)\n\t\t\tbreak;\n\n#ifdef CONFIG_AF_RXRPC_INJECT_RX_DELAY\n\t\tskb = skb_peek(&local->rx_delay_queue);\n\t\tif (skb) {\n\t\t\tunsigned long timeout;\n\t\t\tktime_t tstamp = skb->tstamp;\n\t\t\tktime_t now = ktime_get_real();\n\t\t\ts64 delay_ns = ktime_to_ns(ktime_sub(tstamp, now));\n\n\t\t\tif (delay_ns <= 0) {\n\t\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttimeout = nsecs_to_jiffies(delay_ns);\n\t\t\ttimeout = max(timeout, 1UL);\n\t\t\tschedule_timeout(timeout);\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\tcontinue;\n\t\t}\n#endif\n\n\t\tschedule();\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\trxrpc_see_local(local, rxrpc_local_stop);\n\trxrpc_destroy_local(local);\n\tlocal->io_thread = NULL;\n\trxrpc_see_local(local, rxrpc_local_stopped);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}