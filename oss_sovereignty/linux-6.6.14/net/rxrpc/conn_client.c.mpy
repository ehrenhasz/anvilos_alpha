{
  "module_name": "conn_client.c",
  "hash_id": "29b2ffe5057fca855bf3d96b02c61aee74af71e643c9594bb3dbcd1bb3797ed0",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/conn_client.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/timer.h>\n#include <linux/sched/signal.h>\n\n#include \"ar-internal.h\"\n\n__read_mostly unsigned int rxrpc_reap_client_connections = 900;\n__read_mostly unsigned long rxrpc_conn_idle_client_expiry = 2 * 60 * HZ;\n__read_mostly unsigned long rxrpc_conn_idle_client_fast_expiry = 2 * HZ;\n\nstatic void rxrpc_activate_bundle(struct rxrpc_bundle *bundle)\n{\n\tatomic_inc(&bundle->active);\n}\n\n \nstatic void rxrpc_put_client_connection_id(struct rxrpc_local *local,\n\t\t\t\t\t   struct rxrpc_connection *conn)\n{\n\tidr_remove(&local->conn_ids, conn->proto.cid >> RXRPC_CIDSHIFT);\n}\n\n \nstatic void rxrpc_destroy_client_conn_ids(struct rxrpc_local *local)\n{\n\tstruct rxrpc_connection *conn;\n\tint id;\n\n\tif (!idr_is_empty(&local->conn_ids)) {\n\t\tidr_for_each_entry(&local->conn_ids, conn, id) {\n\t\t\tpr_err(\"AF_RXRPC: Leaked client conn %p {%d}\\n\",\n\t\t\t       conn, refcount_read(&conn->ref));\n\t\t}\n\t\tBUG();\n\t}\n\n\tidr_destroy(&local->conn_ids);\n}\n\n \nstatic struct rxrpc_bundle *rxrpc_alloc_bundle(struct rxrpc_call *call,\n\t\t\t\t\t       gfp_t gfp)\n{\n\tstatic atomic_t rxrpc_bundle_id;\n\tstruct rxrpc_bundle *bundle;\n\n\tbundle = kzalloc(sizeof(*bundle), gfp);\n\tif (bundle) {\n\t\tbundle->local\t\t= call->local;\n\t\tbundle->peer\t\t= rxrpc_get_peer(call->peer, rxrpc_peer_get_bundle);\n\t\tbundle->key\t\t= key_get(call->key);\n\t\tbundle->security\t= call->security;\n\t\tbundle->exclusive\t= test_bit(RXRPC_CALL_EXCLUSIVE, &call->flags);\n\t\tbundle->upgrade\t\t= test_bit(RXRPC_CALL_UPGRADE, &call->flags);\n\t\tbundle->service_id\t= call->dest_srx.srx_service;\n\t\tbundle->security_level\t= call->security_level;\n\t\tbundle->debug_id\t= atomic_inc_return(&rxrpc_bundle_id);\n\t\trefcount_set(&bundle->ref, 1);\n\t\tatomic_set(&bundle->active, 1);\n\t\tINIT_LIST_HEAD(&bundle->waiting_calls);\n\t\ttrace_rxrpc_bundle(bundle->debug_id, 1, rxrpc_bundle_new);\n\t}\n\treturn bundle;\n}\n\nstruct rxrpc_bundle *rxrpc_get_bundle(struct rxrpc_bundle *bundle,\n\t\t\t\t      enum rxrpc_bundle_trace why)\n{\n\tint r;\n\n\t__refcount_inc(&bundle->ref, &r);\n\ttrace_rxrpc_bundle(bundle->debug_id, r + 1, why);\n\treturn bundle;\n}\n\nstatic void rxrpc_free_bundle(struct rxrpc_bundle *bundle)\n{\n\ttrace_rxrpc_bundle(bundle->debug_id, refcount_read(&bundle->ref),\n\t\t\t   rxrpc_bundle_free);\n\trxrpc_put_peer(bundle->peer, rxrpc_peer_put_bundle);\n\tkey_put(bundle->key);\n\tkfree(bundle);\n}\n\nvoid rxrpc_put_bundle(struct rxrpc_bundle *bundle, enum rxrpc_bundle_trace why)\n{\n\tunsigned int id;\n\tbool dead;\n\tint r;\n\n\tif (bundle) {\n\t\tid = bundle->debug_id;\n\t\tdead = __refcount_dec_and_test(&bundle->ref, &r);\n\t\ttrace_rxrpc_bundle(id, r - 1, why);\n\t\tif (dead)\n\t\t\trxrpc_free_bundle(bundle);\n\t}\n}\n\n \nvoid rxrpc_purge_client_connections(struct rxrpc_local *local)\n{\n\trxrpc_destroy_client_conn_ids(local);\n}\n\n \nstatic struct rxrpc_connection *\nrxrpc_alloc_client_connection(struct rxrpc_bundle *bundle)\n{\n\tstruct rxrpc_connection *conn;\n\tstruct rxrpc_local *local = bundle->local;\n\tstruct rxrpc_net *rxnet = local->rxnet;\n\tint id;\n\n\t_enter(\"\");\n\n\tconn = rxrpc_alloc_connection(rxnet, GFP_ATOMIC | __GFP_NOWARN);\n\tif (!conn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tid = idr_alloc_cyclic(&local->conn_ids, conn, 1, 0x40000000,\n\t\t\t      GFP_ATOMIC | __GFP_NOWARN);\n\tif (id < 0) {\n\t\tkfree(conn);\n\t\treturn ERR_PTR(id);\n\t}\n\n\trefcount_set(&conn->ref, 1);\n\tconn->proto.cid\t\t= id << RXRPC_CIDSHIFT;\n\tconn->proto.epoch\t= local->rxnet->epoch;\n\tconn->out_clientflag\t= RXRPC_CLIENT_INITIATED;\n\tconn->bundle\t\t= rxrpc_get_bundle(bundle, rxrpc_bundle_get_client_conn);\n\tconn->local\t\t= rxrpc_get_local(bundle->local, rxrpc_local_get_client_conn);\n\tconn->peer\t\t= rxrpc_get_peer(bundle->peer, rxrpc_peer_get_client_conn);\n\tconn->key\t\t= key_get(bundle->key);\n\tconn->security\t\t= bundle->security;\n\tconn->exclusive\t\t= bundle->exclusive;\n\tconn->upgrade\t\t= bundle->upgrade;\n\tconn->orig_service_id\t= bundle->service_id;\n\tconn->security_level\t= bundle->security_level;\n\tconn->state\t\t= RXRPC_CONN_CLIENT_UNSECURED;\n\tconn->service_id\t= conn->orig_service_id;\n\n\tif (conn->security == &rxrpc_no_security)\n\t\tconn->state\t= RXRPC_CONN_CLIENT;\n\n\tatomic_inc(&rxnet->nr_conns);\n\twrite_lock(&rxnet->conn_lock);\n\tlist_add_tail(&conn->proc_link, &rxnet->conn_proc_list);\n\twrite_unlock(&rxnet->conn_lock);\n\n\trxrpc_see_connection(conn, rxrpc_conn_new_client);\n\n\tatomic_inc(&rxnet->nr_client_conns);\n\ttrace_rxrpc_client(conn, -1, rxrpc_client_alloc);\n\treturn conn;\n}\n\n \nstatic bool rxrpc_may_reuse_conn(struct rxrpc_connection *conn)\n{\n\tstruct rxrpc_net *rxnet;\n\tint id_cursor, id, distance, limit;\n\n\tif (!conn)\n\t\tgoto dont_reuse;\n\n\trxnet = conn->rxnet;\n\tif (test_bit(RXRPC_CONN_DONT_REUSE, &conn->flags))\n\t\tgoto dont_reuse;\n\n\tif ((conn->state != RXRPC_CONN_CLIENT_UNSECURED &&\n\t     conn->state != RXRPC_CONN_CLIENT) ||\n\t    conn->proto.epoch != rxnet->epoch)\n\t\tgoto mark_dont_reuse;\n\n\t \n\tid_cursor = idr_get_cursor(&conn->local->conn_ids);\n\tid = conn->proto.cid >> RXRPC_CIDSHIFT;\n\tdistance = id - id_cursor;\n\tif (distance < 0)\n\t\tdistance = -distance;\n\tlimit = max_t(unsigned long, atomic_read(&rxnet->nr_conns) * 4, 1024);\n\tif (distance > limit)\n\t\tgoto mark_dont_reuse;\n\n\treturn true;\n\nmark_dont_reuse:\n\tset_bit(RXRPC_CONN_DONT_REUSE, &conn->flags);\ndont_reuse:\n\treturn false;\n}\n\n \nint rxrpc_look_up_bundle(struct rxrpc_call *call, gfp_t gfp)\n{\n\tstruct rxrpc_bundle *bundle, *candidate;\n\tstruct rxrpc_local *local = call->local;\n\tstruct rb_node *p, **pp, *parent;\n\tlong diff;\n\tbool upgrade = test_bit(RXRPC_CALL_UPGRADE, &call->flags);\n\n\t_enter(\"{%px,%x,%u,%u}\",\n\t       call->peer, key_serial(call->key), call->security_level,\n\t       upgrade);\n\n\tif (test_bit(RXRPC_CALL_EXCLUSIVE, &call->flags)) {\n\t\tcall->bundle = rxrpc_alloc_bundle(call, gfp);\n\t\treturn call->bundle ? 0 : -ENOMEM;\n\t}\n\n\t \n\t_debug(\"search 1\");\n\tspin_lock(&local->client_bundles_lock);\n\tp = local->client_bundles.rb_node;\n\twhile (p) {\n\t\tbundle = rb_entry(p, struct rxrpc_bundle, local_node);\n\n#define cmp(X, Y) ((long)(X) - (long)(Y))\n\t\tdiff = (cmp(bundle->peer, call->peer) ?:\n\t\t\tcmp(bundle->key, call->key) ?:\n\t\t\tcmp(bundle->security_level, call->security_level) ?:\n\t\t\tcmp(bundle->upgrade, upgrade));\n#undef cmp\n\t\tif (diff < 0)\n\t\t\tp = p->rb_left;\n\t\telse if (diff > 0)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\tgoto found_bundle;\n\t}\n\tspin_unlock(&local->client_bundles_lock);\n\t_debug(\"not found\");\n\n\t \n\tcandidate = rxrpc_alloc_bundle(call, gfp);\n\tif (!candidate)\n\t\treturn -ENOMEM;\n\n\t_debug(\"search 2\");\n\tspin_lock(&local->client_bundles_lock);\n\tpp = &local->client_bundles.rb_node;\n\tparent = NULL;\n\twhile (*pp) {\n\t\tparent = *pp;\n\t\tbundle = rb_entry(parent, struct rxrpc_bundle, local_node);\n\n#define cmp(X, Y) ((long)(X) - (long)(Y))\n\t\tdiff = (cmp(bundle->peer, call->peer) ?:\n\t\t\tcmp(bundle->key, call->key) ?:\n\t\t\tcmp(bundle->security_level, call->security_level) ?:\n\t\t\tcmp(bundle->upgrade, upgrade));\n#undef cmp\n\t\tif (diff < 0)\n\t\t\tpp = &(*pp)->rb_left;\n\t\telse if (diff > 0)\n\t\t\tpp = &(*pp)->rb_right;\n\t\telse\n\t\t\tgoto found_bundle_free;\n\t}\n\n\t_debug(\"new bundle\");\n\trb_link_node(&candidate->local_node, parent, pp);\n\trb_insert_color(&candidate->local_node, &local->client_bundles);\n\tcall->bundle = rxrpc_get_bundle(candidate, rxrpc_bundle_get_client_call);\n\tspin_unlock(&local->client_bundles_lock);\n\t_leave(\" = B=%u [new]\", call->bundle->debug_id);\n\treturn 0;\n\nfound_bundle_free:\n\trxrpc_free_bundle(candidate);\nfound_bundle:\n\tcall->bundle = rxrpc_get_bundle(bundle, rxrpc_bundle_get_client_call);\n\trxrpc_activate_bundle(bundle);\n\tspin_unlock(&local->client_bundles_lock);\n\t_leave(\" = B=%u [found]\", call->bundle->debug_id);\n\treturn 0;\n}\n\n \nstatic bool rxrpc_add_conn_to_bundle(struct rxrpc_bundle *bundle,\n\t\t\t\t     unsigned int slot)\n{\n\tstruct rxrpc_connection *conn, *old;\n\tunsigned int shift = slot * RXRPC_MAXCALLS;\n\tunsigned int i;\n\n\told = bundle->conns[slot];\n\tif (old) {\n\t\tbundle->conns[slot] = NULL;\n\t\ttrace_rxrpc_client(old, -1, rxrpc_client_replace);\n\t\trxrpc_put_connection(old, rxrpc_conn_put_noreuse);\n\t}\n\n\tconn = rxrpc_alloc_client_connection(bundle);\n\tif (IS_ERR(conn)) {\n\t\tbundle->alloc_error = PTR_ERR(conn);\n\t\treturn false;\n\t}\n\n\trxrpc_activate_bundle(bundle);\n\tconn->bundle_shift = shift;\n\tbundle->conns[slot] = conn;\n\tfor (i = 0; i < RXRPC_MAXCALLS; i++)\n\t\tset_bit(shift + i, &bundle->avail_chans);\n\treturn true;\n}\n\n \nstatic bool rxrpc_bundle_has_space(struct rxrpc_bundle *bundle)\n{\n\tint slot = -1, i, usable;\n\n\t_enter(\"\");\n\n\tbundle->alloc_error = 0;\n\n\t \n\tusable = 0;\n\tfor (i = 0; i < ARRAY_SIZE(bundle->conns); i++) {\n\t\tif (rxrpc_may_reuse_conn(bundle->conns[i]))\n\t\t\tusable++;\n\t\telse if (slot == -1)\n\t\t\tslot = i;\n\t}\n\n\tif (!usable && bundle->upgrade)\n\t\tbundle->try_upgrade = true;\n\n\tif (!usable)\n\t\tgoto alloc_conn;\n\n\tif (!bundle->avail_chans &&\n\t    !bundle->try_upgrade &&\n\t    usable < ARRAY_SIZE(bundle->conns))\n\t\tgoto alloc_conn;\n\n\t_leave(\"\");\n\treturn usable;\n\nalloc_conn:\n\treturn slot >= 0 ? rxrpc_add_conn_to_bundle(bundle, slot) : false;\n}\n\n \nstatic void rxrpc_activate_one_channel(struct rxrpc_connection *conn,\n\t\t\t\t       unsigned int channel)\n{\n\tstruct rxrpc_channel *chan = &conn->channels[channel];\n\tstruct rxrpc_bundle *bundle = conn->bundle;\n\tstruct rxrpc_call *call = list_entry(bundle->waiting_calls.next,\n\t\t\t\t\t     struct rxrpc_call, wait_link);\n\tu32 call_id = chan->call_counter + 1;\n\n\t_enter(\"C=%x,%u\", conn->debug_id, channel);\n\n\tlist_del_init(&call->wait_link);\n\n\ttrace_rxrpc_client(conn, channel, rxrpc_client_chan_activate);\n\n\t \n\tclear_bit(RXRPC_CONN_FINAL_ACK_0 + channel, &conn->flags);\n\tclear_bit(conn->bundle_shift + channel, &bundle->avail_chans);\n\n\trxrpc_see_call(call, rxrpc_call_see_activate_client);\n\tcall->conn\t= rxrpc_get_connection(conn, rxrpc_conn_get_activate_call);\n\tcall->cid\t= conn->proto.cid | channel;\n\tcall->call_id\t= call_id;\n\tcall->dest_srx.srx_service = conn->service_id;\n\tcall->cong_ssthresh = call->peer->cong_ssthresh;\n\tif (call->cong_cwnd >= call->cong_ssthresh)\n\t\tcall->cong_mode = RXRPC_CALL_CONGEST_AVOIDANCE;\n\telse\n\t\tcall->cong_mode = RXRPC_CALL_SLOW_START;\n\n\tchan->call_id\t\t= call_id;\n\tchan->call_debug_id\t= call->debug_id;\n\tchan->call\t\t= call;\n\n\trxrpc_see_call(call, rxrpc_call_see_connected);\n\ttrace_rxrpc_connect_call(call);\n\tcall->tx_last_sent = ktime_get_real();\n\trxrpc_start_call_timer(call);\n\trxrpc_set_call_state(call, RXRPC_CALL_CLIENT_SEND_REQUEST);\n\twake_up(&call->waitq);\n}\n\n \nstatic void rxrpc_unidle_conn(struct rxrpc_connection *conn)\n{\n\tif (!list_empty(&conn->cache_link)) {\n\t\tlist_del_init(&conn->cache_link);\n\t\trxrpc_put_connection(conn, rxrpc_conn_put_unidle);\n\t}\n}\n\n \nstatic void rxrpc_activate_channels(struct rxrpc_bundle *bundle)\n{\n\tstruct rxrpc_connection *conn;\n\tunsigned long avail, mask;\n\tunsigned int channel, slot;\n\n\ttrace_rxrpc_client(NULL, -1, rxrpc_client_activate_chans);\n\n\tif (bundle->try_upgrade)\n\t\tmask = 1;\n\telse\n\t\tmask = ULONG_MAX;\n\n\twhile (!list_empty(&bundle->waiting_calls)) {\n\t\tavail = bundle->avail_chans & mask;\n\t\tif (!avail)\n\t\t\tbreak;\n\t\tchannel = __ffs(avail);\n\t\tclear_bit(channel, &bundle->avail_chans);\n\n\t\tslot = channel / RXRPC_MAXCALLS;\n\t\tconn = bundle->conns[slot];\n\t\tif (!conn)\n\t\t\tbreak;\n\n\t\tif (bundle->try_upgrade)\n\t\t\tset_bit(RXRPC_CONN_PROBING_FOR_UPGRADE, &conn->flags);\n\t\trxrpc_unidle_conn(conn);\n\n\t\tchannel &= (RXRPC_MAXCALLS - 1);\n\t\tconn->act_chans\t|= 1 << channel;\n\t\trxrpc_activate_one_channel(conn, channel);\n\t}\n}\n\n \nvoid rxrpc_connect_client_calls(struct rxrpc_local *local)\n{\n\tstruct rxrpc_call *call;\n\n\twhile ((call = list_first_entry_or_null(&local->new_client_calls,\n\t\t\t\t\t\tstruct rxrpc_call, wait_link))\n\t       ) {\n\t\tstruct rxrpc_bundle *bundle = call->bundle;\n\n\t\tspin_lock(&local->client_call_lock);\n\t\tlist_move_tail(&call->wait_link, &bundle->waiting_calls);\n\t\tspin_unlock(&local->client_call_lock);\n\n\t\tif (rxrpc_bundle_has_space(bundle))\n\t\t\trxrpc_activate_channels(bundle);\n\t}\n}\n\n \nvoid rxrpc_expose_client_call(struct rxrpc_call *call)\n{\n\tunsigned int channel = call->cid & RXRPC_CHANNELMASK;\n\tstruct rxrpc_connection *conn = call->conn;\n\tstruct rxrpc_channel *chan = &conn->channels[channel];\n\n\tif (!test_and_set_bit(RXRPC_CALL_EXPOSED, &call->flags)) {\n\t\t \n\t\tchan->call_counter++;\n\t\tif (chan->call_counter >= INT_MAX)\n\t\t\tset_bit(RXRPC_CONN_DONT_REUSE, &conn->flags);\n\t\ttrace_rxrpc_client(conn, channel, rxrpc_client_exposed);\n\n\t\tspin_lock(&call->peer->lock);\n\t\thlist_add_head(&call->error_link, &call->peer->error_targets);\n\t\tspin_unlock(&call->peer->lock);\n\t}\n}\n\n \nstatic void rxrpc_set_client_reap_timer(struct rxrpc_local *local)\n{\n\tif (!local->kill_all_client_conns) {\n\t\tunsigned long now = jiffies;\n\t\tunsigned long reap_at = now + rxrpc_conn_idle_client_expiry;\n\n\t\tif (local->rxnet->live)\n\t\t\ttimer_reduce(&local->client_conn_reap_timer, reap_at);\n\t}\n}\n\n \nvoid rxrpc_disconnect_client_call(struct rxrpc_bundle *bundle, struct rxrpc_call *call)\n{\n\tstruct rxrpc_connection *conn;\n\tstruct rxrpc_channel *chan = NULL;\n\tstruct rxrpc_local *local = bundle->local;\n\tunsigned int channel;\n\tbool may_reuse;\n\tu32 cid;\n\n\t_enter(\"c=%x\", call->debug_id);\n\n\t \n\tconn = call->conn;\n\tif (!conn) {\n\t\t_debug(\"call is waiting\");\n\t\tASSERTCMP(call->call_id, ==, 0);\n\t\tASSERT(!test_bit(RXRPC_CALL_EXPOSED, &call->flags));\n\t\tlist_del_init(&call->wait_link);\n\t\treturn;\n\t}\n\n\tcid = call->cid;\n\tchannel = cid & RXRPC_CHANNELMASK;\n\tchan = &conn->channels[channel];\n\ttrace_rxrpc_client(conn, channel, rxrpc_client_chan_disconnect);\n\n\tif (WARN_ON(chan->call != call))\n\t\treturn;\n\n\tmay_reuse = rxrpc_may_reuse_conn(conn);\n\n\t \n\tif (test_bit(RXRPC_CALL_EXPOSED, &call->flags)) {\n\t\t_debug(\"exposed %u,%u\", call->call_id, call->abort_code);\n\t\t__rxrpc_disconnect_call(conn, call);\n\n\t\tif (test_and_clear_bit(RXRPC_CONN_PROBING_FOR_UPGRADE, &conn->flags)) {\n\t\t\ttrace_rxrpc_client(conn, channel, rxrpc_client_to_active);\n\t\t\tbundle->try_upgrade = false;\n\t\t\tif (may_reuse)\n\t\t\t\trxrpc_activate_channels(bundle);\n\t\t}\n\t}\n\n\t \n\tif (may_reuse && !list_empty(&bundle->waiting_calls)) {\n\t\ttrace_rxrpc_client(conn, channel, rxrpc_client_chan_pass);\n\t\trxrpc_activate_one_channel(conn, channel);\n\t\treturn;\n\t}\n\n\t \n\tif (call->completion == RXRPC_CALL_SUCCEEDED &&\n\t    test_bit(RXRPC_CALL_EXPOSED, &call->flags)) {\n\t\tunsigned long final_ack_at = jiffies + 2;\n\n\t\tWRITE_ONCE(chan->final_ack_at, final_ack_at);\n\t\tsmp_wmb();  \n\t\tset_bit(RXRPC_CONN_FINAL_ACK_0 + channel, &conn->flags);\n\t\trxrpc_reduce_conn_timer(conn, final_ack_at);\n\t}\n\n\t \n\tchan->call = NULL;\n\tset_bit(conn->bundle_shift + channel, &conn->bundle->avail_chans);\n\tconn->act_chans\t&= ~(1 << channel);\n\n\t \n\tif (!conn->act_chans) {\n\t\ttrace_rxrpc_client(conn, channel, rxrpc_client_to_idle);\n\t\tconn->idle_timestamp = jiffies;\n\n\t\trxrpc_get_connection(conn, rxrpc_conn_get_idle);\n\t\tlist_move_tail(&conn->cache_link, &local->idle_client_conns);\n\n\t\trxrpc_set_client_reap_timer(local);\n\t}\n}\n\n \nstatic void rxrpc_unbundle_conn(struct rxrpc_connection *conn)\n{\n\tstruct rxrpc_bundle *bundle = conn->bundle;\n\tunsigned int bindex;\n\tint i;\n\n\t_enter(\"C=%x\", conn->debug_id);\n\n\tif (conn->flags & RXRPC_CONN_FINAL_ACK_MASK)\n\t\trxrpc_process_delayed_final_acks(conn, true);\n\n\tbindex = conn->bundle_shift / RXRPC_MAXCALLS;\n\tif (bundle->conns[bindex] == conn) {\n\t\t_debug(\"clear slot %u\", bindex);\n\t\tbundle->conns[bindex] = NULL;\n\t\tfor (i = 0; i < RXRPC_MAXCALLS; i++)\n\t\t\tclear_bit(conn->bundle_shift + i, &bundle->avail_chans);\n\t\trxrpc_put_client_connection_id(bundle->local, conn);\n\t\trxrpc_deactivate_bundle(bundle);\n\t\trxrpc_put_connection(conn, rxrpc_conn_put_unbundle);\n\t}\n}\n\n \nvoid rxrpc_deactivate_bundle(struct rxrpc_bundle *bundle)\n{\n\tstruct rxrpc_local *local;\n\tbool need_put = false;\n\n\tif (!bundle)\n\t\treturn;\n\n\tlocal = bundle->local;\n\tif (atomic_dec_and_lock(&bundle->active, &local->client_bundles_lock)) {\n\t\tif (!bundle->exclusive) {\n\t\t\t_debug(\"erase bundle\");\n\t\t\trb_erase(&bundle->local_node, &local->client_bundles);\n\t\t\tneed_put = true;\n\t\t}\n\n\t\tspin_unlock(&local->client_bundles_lock);\n\t\tif (need_put)\n\t\t\trxrpc_put_bundle(bundle, rxrpc_bundle_put_discard);\n\t}\n}\n\n \nvoid rxrpc_kill_client_conn(struct rxrpc_connection *conn)\n{\n\tstruct rxrpc_local *local = conn->local;\n\tstruct rxrpc_net *rxnet = local->rxnet;\n\n\t_enter(\"C=%x\", conn->debug_id);\n\n\ttrace_rxrpc_client(conn, -1, rxrpc_client_cleanup);\n\tatomic_dec(&rxnet->nr_client_conns);\n\n\trxrpc_put_client_connection_id(local, conn);\n}\n\n \nvoid rxrpc_discard_expired_client_conns(struct rxrpc_local *local)\n{\n\tstruct rxrpc_connection *conn;\n\tunsigned long expiry, conn_expires_at, now;\n\tunsigned int nr_conns;\n\n\t_enter(\"\");\n\n\t \n\tnr_conns = atomic_read(&local->rxnet->nr_client_conns);\n\nnext:\n\tconn = list_first_entry_or_null(&local->idle_client_conns,\n\t\t\t\t\tstruct rxrpc_connection, cache_link);\n\tif (!conn)\n\t\treturn;\n\n\tif (!local->kill_all_client_conns) {\n\t\t \n\t\texpiry = rxrpc_conn_idle_client_expiry;\n\t\tif (nr_conns > rxrpc_reap_client_connections)\n\t\t\texpiry = rxrpc_conn_idle_client_fast_expiry;\n\t\tif (conn->local->service_closed)\n\t\t\texpiry = rxrpc_closed_conn_expiry * HZ;\n\n\t\tconn_expires_at = conn->idle_timestamp + expiry;\n\n\t\tnow = READ_ONCE(jiffies);\n\t\tif (time_after(conn_expires_at, now))\n\t\t\tgoto not_yet_expired;\n\t}\n\n\tatomic_dec(&conn->active);\n\ttrace_rxrpc_client(conn, -1, rxrpc_client_discard);\n\tlist_del_init(&conn->cache_link);\n\n\trxrpc_unbundle_conn(conn);\n\t \n\trxrpc_put_connection(conn, rxrpc_conn_put_discard_idle);\n\n\tnr_conns--;\n\tgoto next;\n\nnot_yet_expired:\n\t \n\t_debug(\"not yet\");\n\tif (!local->kill_all_client_conns)\n\t\ttimer_reduce(&local->client_conn_reap_timer, conn_expires_at);\n\n\t_leave(\"\");\n}\n\n \nvoid rxrpc_clean_up_local_conns(struct rxrpc_local *local)\n{\n\tstruct rxrpc_connection *conn;\n\n\t_enter(\"\");\n\n\tlocal->kill_all_client_conns = true;\n\n\tdel_timer_sync(&local->client_conn_reap_timer);\n\n\twhile ((conn = list_first_entry_or_null(&local->idle_client_conns,\n\t\t\t\t\t\tstruct rxrpc_connection, cache_link))) {\n\t\tlist_del_init(&conn->cache_link);\n\t\tatomic_dec(&conn->active);\n\t\ttrace_rxrpc_client(conn, -1, rxrpc_client_discard);\n\t\trxrpc_unbundle_conn(conn);\n\t\trxrpc_put_connection(conn, rxrpc_conn_put_local_dead);\n\t}\n\n\t_leave(\" [culled]\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}