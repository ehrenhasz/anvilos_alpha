{
  "module_name": "output.c",
  "hash_id": "115e42e387be8606d3520b406537cb1d8001ee73c880563e8705d5a48f68c144",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/output.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/net.h>\n#include <linux/gfp.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include <net/udp.h>\n#include \"ar-internal.h\"\n\nextern int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len);\n\nstatic ssize_t do_udp_sendmsg(struct socket *socket, struct msghdr *msg, size_t len)\n{\n\tstruct sockaddr *sa = msg->msg_name;\n\tstruct sock *sk = socket->sk;\n\n\tif (IS_ENABLED(CONFIG_AF_RXRPC_IPV6)) {\n\t\tif (sa->sa_family == AF_INET6) {\n\t\t\tif (sk->sk_family != AF_INET6) {\n\t\t\t\tpr_warn(\"AF_INET6 address on AF_INET socket\\n\");\n\t\t\t\treturn -ENOPROTOOPT;\n\t\t\t}\n\t\t\treturn udpv6_sendmsg(sk, msg, len);\n\t\t}\n\t}\n\treturn udp_sendmsg(sk, msg, len);\n}\n\nstruct rxrpc_abort_buffer {\n\tstruct rxrpc_wire_header whdr;\n\t__be32 abort_code;\n};\n\nstatic const char rxrpc_keepalive_string[] = \"\";\n\n \nstatic void rxrpc_tx_backoff(struct rxrpc_call *call, int ret)\n{\n\tif (ret < 0) {\n\t\tu16 tx_backoff = READ_ONCE(call->tx_backoff);\n\n\t\tif (tx_backoff < HZ)\n\t\t\tWRITE_ONCE(call->tx_backoff, tx_backoff + 1);\n\t} else {\n\t\tWRITE_ONCE(call->tx_backoff, 0);\n\t}\n}\n\n \nstatic void rxrpc_set_keepalive(struct rxrpc_call *call)\n{\n\tunsigned long now = jiffies, keepalive_at = call->next_rx_timo / 6;\n\n\tkeepalive_at += now;\n\tWRITE_ONCE(call->keepalive_at, keepalive_at);\n\trxrpc_reduce_call_timer(call, keepalive_at, now,\n\t\t\t\trxrpc_timer_set_for_keepalive);\n}\n\n \nstatic size_t rxrpc_fill_out_ack(struct rxrpc_connection *conn,\n\t\t\t\t struct rxrpc_call *call,\n\t\t\t\t struct rxrpc_txbuf *txb,\n\t\t\t\t u16 *_rwind)\n{\n\tstruct rxrpc_ackinfo ackinfo;\n\tunsigned int qsize, sack, wrap, to;\n\trxrpc_seq_t window, wtop;\n\tint rsize;\n\tu32 mtu, jmax;\n\tu8 *ackp = txb->acks;\n\n\tcall->ackr_nr_unacked = 0;\n\tatomic_set(&call->ackr_nr_consumed, 0);\n\trxrpc_inc_stat(call->rxnet, stat_tx_ack_fill);\n\tclear_bit(RXRPC_CALL_RX_IS_IDLE, &call->flags);\n\n\twindow = call->ackr_window;\n\twtop   = call->ackr_wtop;\n\tsack   = call->ackr_sack_base % RXRPC_SACK_SIZE;\n\ttxb->ack.firstPacket = htonl(window);\n\ttxb->ack.nAcks = wtop - window;\n\n\tif (after(wtop, window)) {\n\t\twrap = RXRPC_SACK_SIZE - sack;\n\t\tto = min_t(unsigned int, txb->ack.nAcks, RXRPC_SACK_SIZE);\n\n\t\tif (sack + txb->ack.nAcks <= RXRPC_SACK_SIZE) {\n\t\t\tmemcpy(txb->acks, call->ackr_sack_table + sack, txb->ack.nAcks);\n\t\t} else {\n\t\t\tmemcpy(txb->acks, call->ackr_sack_table + sack, wrap);\n\t\t\tmemcpy(txb->acks + wrap, call->ackr_sack_table,\n\t\t\t       to - wrap);\n\t\t}\n\n\t\tackp += to;\n\t} else if (before(wtop, window)) {\n\t\tpr_warn(\"ack window backward %x %x\", window, wtop);\n\t} else if (txb->ack.reason == RXRPC_ACK_DELAY) {\n\t\ttxb->ack.reason = RXRPC_ACK_IDLE;\n\t}\n\n\tmtu = conn->peer->if_mtu;\n\tmtu -= conn->peer->hdrsize;\n\tjmax = rxrpc_rx_jumbo_max;\n\tqsize = (window - 1) - call->rx_consumed;\n\trsize = max_t(int, call->rx_winsize - qsize, 0);\n\t*_rwind = rsize;\n\tackinfo.rxMTU\t\t= htonl(rxrpc_rx_mtu);\n\tackinfo.maxMTU\t\t= htonl(mtu);\n\tackinfo.rwind\t\t= htonl(rsize);\n\tackinfo.jumbo_max\t= htonl(jmax);\n\n\t*ackp++ = 0;\n\t*ackp++ = 0;\n\t*ackp++ = 0;\n\tmemcpy(ackp, &ackinfo, sizeof(ackinfo));\n\treturn txb->ack.nAcks + 3 + sizeof(ackinfo);\n}\n\n \nstatic int rxrpc_begin_rtt_probe(struct rxrpc_call *call, rxrpc_serial_t serial,\n\t\t\t\t enum rxrpc_rtt_tx_trace why)\n{\n\tunsigned long avail = call->rtt_avail;\n\tint rtt_slot = 9;\n\n\tif (!(avail & RXRPC_CALL_RTT_AVAIL_MASK))\n\t\tgoto no_slot;\n\n\trtt_slot = __ffs(avail & RXRPC_CALL_RTT_AVAIL_MASK);\n\tif (!test_and_clear_bit(rtt_slot, &call->rtt_avail))\n\t\tgoto no_slot;\n\n\tcall->rtt_serial[rtt_slot] = serial;\n\tcall->rtt_sent_at[rtt_slot] = ktime_get_real();\n\tsmp_wmb();  \n\tset_bit(rtt_slot + RXRPC_CALL_RTT_PEND_SHIFT, &call->rtt_avail);\n\n\ttrace_rxrpc_rtt_tx(call, why, rtt_slot, serial);\n\treturn rtt_slot;\n\nno_slot:\n\ttrace_rxrpc_rtt_tx(call, rxrpc_rtt_tx_no_slot, rtt_slot, serial);\n\treturn -1;\n}\n\n \nstatic void rxrpc_cancel_rtt_probe(struct rxrpc_call *call,\n\t\t\t\t   rxrpc_serial_t serial, int rtt_slot)\n{\n\tif (rtt_slot != -1) {\n\t\tclear_bit(rtt_slot + RXRPC_CALL_RTT_PEND_SHIFT, &call->rtt_avail);\n\t\tsmp_wmb();  \n\t\tset_bit(rtt_slot, &call->rtt_avail);\n\t\ttrace_rxrpc_rtt_tx(call, rxrpc_rtt_tx_cancel, rtt_slot, serial);\n\t}\n}\n\n \nint rxrpc_send_ack_packet(struct rxrpc_call *call, struct rxrpc_txbuf *txb)\n{\n\tstruct rxrpc_connection *conn;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\trxrpc_serial_t serial;\n\tsize_t len, n;\n\tint ret, rtt_slot = -1;\n\tu16 rwind;\n\n\tif (test_bit(RXRPC_CALL_DISCONNECTED, &call->flags))\n\t\treturn -ECONNRESET;\n\n\tconn = call->conn;\n\n\tmsg.msg_name\t= &call->peer->srx.transport;\n\tmsg.msg_namelen\t= call->peer->srx.transport_len;\n\tmsg.msg_control\t= NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags\t= 0;\n\n\tif (txb->ack.reason == RXRPC_ACK_PING)\n\t\ttxb->wire.flags |= RXRPC_REQUEST_ACK;\n\n\tn = rxrpc_fill_out_ack(conn, call, txb, &rwind);\n\tif (n == 0)\n\t\treturn 0;\n\n\tiov[0].iov_base\t= &txb->wire;\n\tiov[0].iov_len\t= sizeof(txb->wire) + sizeof(txb->ack) + n;\n\tlen = iov[0].iov_len;\n\n\tserial = atomic_inc_return(&conn->serial);\n\ttxb->wire.serial = htonl(serial);\n\ttrace_rxrpc_tx_ack(call->debug_id, serial,\n\t\t\t   ntohl(txb->ack.firstPacket),\n\t\t\t   ntohl(txb->ack.serial), txb->ack.reason, txb->ack.nAcks,\n\t\t\t   rwind);\n\n\tif (txb->ack.reason == RXRPC_ACK_PING)\n\t\trtt_slot = rxrpc_begin_rtt_probe(call, serial, rxrpc_rtt_tx_ping);\n\n\trxrpc_inc_stat(call->rxnet, stat_tx_ack_send);\n\n\t \n\ttxb->ack.previousPacket\t= htonl(call->rx_highest_seq);\n\n\tiov_iter_kvec(&msg.msg_iter, WRITE, iov, 1, len);\n\tret = do_udp_sendmsg(conn->local->socket, &msg, len);\n\tcall->peer->last_tx_at = ktime_get_seconds();\n\tif (ret < 0) {\n\t\ttrace_rxrpc_tx_fail(call->debug_id, serial, ret,\n\t\t\t\t    rxrpc_tx_point_call_ack);\n\t} else {\n\t\ttrace_rxrpc_tx_packet(call->debug_id, &txb->wire,\n\t\t\t\t      rxrpc_tx_point_call_ack);\n\t\tif (txb->wire.flags & RXRPC_REQUEST_ACK)\n\t\t\tcall->peer->rtt_last_req = ktime_get_real();\n\t}\n\trxrpc_tx_backoff(call, ret);\n\n\tif (!__rxrpc_call_is_complete(call)) {\n\t\tif (ret < 0)\n\t\t\trxrpc_cancel_rtt_probe(call, serial, rtt_slot);\n\t\trxrpc_set_keepalive(call);\n\t}\n\n\treturn ret;\n}\n\n \nint rxrpc_send_abort_packet(struct rxrpc_call *call)\n{\n\tstruct rxrpc_connection *conn;\n\tstruct rxrpc_abort_buffer pkt;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\trxrpc_serial_t serial;\n\tint ret;\n\n\t \n\tif (rxrpc_is_client_call(call) &&\n\t    test_bit(RXRPC_CALL_TX_ALL_ACKED, &call->flags))\n\t\treturn 0;\n\n\tif (test_bit(RXRPC_CALL_DISCONNECTED, &call->flags))\n\t\treturn -ECONNRESET;\n\n\tconn = call->conn;\n\n\tmsg.msg_name\t= &call->peer->srx.transport;\n\tmsg.msg_namelen\t= call->peer->srx.transport_len;\n\tmsg.msg_control\t= NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags\t= 0;\n\n\tpkt.whdr.epoch\t\t= htonl(conn->proto.epoch);\n\tpkt.whdr.cid\t\t= htonl(call->cid);\n\tpkt.whdr.callNumber\t= htonl(call->call_id);\n\tpkt.whdr.seq\t\t= 0;\n\tpkt.whdr.type\t\t= RXRPC_PACKET_TYPE_ABORT;\n\tpkt.whdr.flags\t\t= conn->out_clientflag;\n\tpkt.whdr.userStatus\t= 0;\n\tpkt.whdr.securityIndex\t= call->security_ix;\n\tpkt.whdr._rsvd\t\t= 0;\n\tpkt.whdr.serviceId\t= htons(call->dest_srx.srx_service);\n\tpkt.abort_code\t\t= htonl(call->abort_code);\n\n\tiov[0].iov_base\t= &pkt;\n\tiov[0].iov_len\t= sizeof(pkt);\n\n\tserial = atomic_inc_return(&conn->serial);\n\tpkt.whdr.serial = htonl(serial);\n\n\tiov_iter_kvec(&msg.msg_iter, WRITE, iov, 1, sizeof(pkt));\n\tret = do_udp_sendmsg(conn->local->socket, &msg, sizeof(pkt));\n\tconn->peer->last_tx_at = ktime_get_seconds();\n\tif (ret < 0)\n\t\ttrace_rxrpc_tx_fail(call->debug_id, serial, ret,\n\t\t\t\t    rxrpc_tx_point_call_abort);\n\telse\n\t\ttrace_rxrpc_tx_packet(call->debug_id, &pkt.whdr,\n\t\t\t\t      rxrpc_tx_point_call_abort);\n\trxrpc_tx_backoff(call, ret);\n\treturn ret;\n}\n\n \nint rxrpc_send_data_packet(struct rxrpc_call *call, struct rxrpc_txbuf *txb)\n{\n\tenum rxrpc_req_ack_trace why;\n\tstruct rxrpc_connection *conn = call->conn;\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\trxrpc_serial_t serial;\n\tsize_t len;\n\tint ret, rtt_slot = -1;\n\n\t_enter(\"%x,{%d}\", txb->seq, txb->len);\n\n\t \n\tserial = atomic_inc_return(&conn->serial);\n\ttxb->wire.serial = htonl(serial);\n\n\tif (test_bit(RXRPC_CONN_PROBING_FOR_UPGRADE, &conn->flags) &&\n\t    txb->seq == 1)\n\t\ttxb->wire.userStatus = RXRPC_USERSTATUS_SERVICE_UPGRADE;\n\n\tiov[0].iov_base = &txb->wire;\n\tiov[0].iov_len = sizeof(txb->wire) + txb->len;\n\tlen = iov[0].iov_len;\n\tiov_iter_kvec(&msg.msg_iter, WRITE, iov, 1, len);\n\n\tmsg.msg_name = &call->peer->srx.transport;\n\tmsg.msg_namelen = call->peer->srx.transport_len;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags = 0;\n\n\t \n\tif (txb->wire.flags & RXRPC_REQUEST_ACK)\n\t\twhy = rxrpc_reqack_already_on;\n\telse if (test_bit(RXRPC_TXBUF_LAST, &txb->flags) && rxrpc_sending_to_client(txb))\n\t\twhy = rxrpc_reqack_no_srv_last;\n\telse if (test_and_clear_bit(RXRPC_CALL_EV_ACK_LOST, &call->events))\n\t\twhy = rxrpc_reqack_ack_lost;\n\telse if (test_bit(RXRPC_TXBUF_RESENT, &txb->flags))\n\t\twhy = rxrpc_reqack_retrans;\n\telse if (call->cong_mode == RXRPC_CALL_SLOW_START && call->cong_cwnd <= 2)\n\t\twhy = rxrpc_reqack_slow_start;\n\telse if (call->tx_winsize <= 2)\n\t\twhy = rxrpc_reqack_small_txwin;\n\telse if (call->peer->rtt_count < 3 && txb->seq & 1)\n\t\twhy = rxrpc_reqack_more_rtt;\n\telse if (ktime_before(ktime_add_ms(call->peer->rtt_last_req, 1000), ktime_get_real()))\n\t\twhy = rxrpc_reqack_old_rtt;\n\telse\n\t\tgoto dont_set_request_ack;\n\n\trxrpc_inc_stat(call->rxnet, stat_why_req_ack[why]);\n\ttrace_rxrpc_req_ack(call->debug_id, txb->seq, why);\n\tif (why != rxrpc_reqack_no_srv_last)\n\t\ttxb->wire.flags |= RXRPC_REQUEST_ACK;\ndont_set_request_ack:\n\n\tif (IS_ENABLED(CONFIG_AF_RXRPC_INJECT_LOSS)) {\n\t\tstatic int lose;\n\t\tif ((lose++ & 7) == 7) {\n\t\t\tret = 0;\n\t\t\ttrace_rxrpc_tx_data(call, txb->seq, serial,\n\t\t\t\t\t    txb->wire.flags,\n\t\t\t\t\t    test_bit(RXRPC_TXBUF_RESENT, &txb->flags),\n\t\t\t\t\t    true);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\ttrace_rxrpc_tx_data(call, txb->seq, serial, txb->wire.flags,\n\t\t\t    test_bit(RXRPC_TXBUF_RESENT, &txb->flags), false);\n\n\t \n\tcmpxchg(&call->tx_transmitted, txb->seq - 1, txb->seq);\n\n\t \n\tif (txb->len >= call->peer->maxdata)\n\t\tgoto send_fragmentable;\n\n\ttxb->last_sent = ktime_get_real();\n\tif (txb->wire.flags & RXRPC_REQUEST_ACK)\n\t\trtt_slot = rxrpc_begin_rtt_probe(call, serial, rxrpc_rtt_tx_data);\n\n\t \n\trxrpc_inc_stat(call->rxnet, stat_tx_data_send);\n\tret = do_udp_sendmsg(conn->local->socket, &msg, len);\n\tconn->peer->last_tx_at = ktime_get_seconds();\n\n\tif (ret < 0) {\n\t\trxrpc_inc_stat(call->rxnet, stat_tx_data_send_fail);\n\t\trxrpc_cancel_rtt_probe(call, serial, rtt_slot);\n\t\ttrace_rxrpc_tx_fail(call->debug_id, serial, ret,\n\t\t\t\t    rxrpc_tx_point_call_data_nofrag);\n\t} else {\n\t\ttrace_rxrpc_tx_packet(call->debug_id, &txb->wire,\n\t\t\t\t      rxrpc_tx_point_call_data_nofrag);\n\t}\n\n\trxrpc_tx_backoff(call, ret);\n\tif (ret == -EMSGSIZE)\n\t\tgoto send_fragmentable;\n\ndone:\n\tif (ret >= 0) {\n\t\tcall->tx_last_sent = txb->last_sent;\n\t\tif (txb->wire.flags & RXRPC_REQUEST_ACK) {\n\t\t\tcall->peer->rtt_last_req = txb->last_sent;\n\t\t\tif (call->peer->rtt_count > 1) {\n\t\t\t\tunsigned long nowj = jiffies, ack_lost_at;\n\n\t\t\t\tack_lost_at = rxrpc_get_rto_backoff(call->peer, false);\n\t\t\t\tack_lost_at += nowj;\n\t\t\t\tWRITE_ONCE(call->ack_lost_at, ack_lost_at);\n\t\t\t\trxrpc_reduce_call_timer(call, ack_lost_at, nowj,\n\t\t\t\t\t\t\trxrpc_timer_set_for_lost_ack);\n\t\t\t}\n\t\t}\n\n\t\tif (txb->seq == 1 &&\n\t\t    !test_and_set_bit(RXRPC_CALL_BEGAN_RX_TIMER,\n\t\t\t\t      &call->flags)) {\n\t\t\tunsigned long nowj = jiffies, expect_rx_by;\n\n\t\t\texpect_rx_by = nowj + call->next_rx_timo;\n\t\t\tWRITE_ONCE(call->expect_rx_by, expect_rx_by);\n\t\t\trxrpc_reduce_call_timer(call, expect_rx_by, nowj,\n\t\t\t\t\t\trxrpc_timer_set_for_normal);\n\t\t}\n\n\t\trxrpc_set_keepalive(call);\n\t} else {\n\t\t \n\t\tif (!test_and_set_bit(RXRPC_CALL_BEGAN_RX_TIMER, &call->flags))\n\t\t\trxrpc_set_call_completion(call, RXRPC_CALL_LOCAL_ERROR,\n\t\t\t\t\t\t  RX_USER_ABORT, ret);\n\t}\n\n\t_leave(\" = %d [%u]\", ret, call->peer->maxdata);\n\treturn ret;\n\nsend_fragmentable:\n\t \n\t_debug(\"send fragment\");\n\n\ttxb->last_sent = ktime_get_real();\n\tif (txb->wire.flags & RXRPC_REQUEST_ACK)\n\t\trtt_slot = rxrpc_begin_rtt_probe(call, serial, rxrpc_rtt_tx_data);\n\n\tswitch (conn->local->srx.transport.family) {\n\tcase AF_INET6:\n\tcase AF_INET:\n\t\trxrpc_local_dont_fragment(conn->local, false);\n\t\trxrpc_inc_stat(call->rxnet, stat_tx_data_send_frag);\n\t\tret = do_udp_sendmsg(conn->local->socket, &msg, len);\n\t\tconn->peer->last_tx_at = ktime_get_seconds();\n\n\t\trxrpc_local_dont_fragment(conn->local, true);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (ret < 0) {\n\t\trxrpc_inc_stat(call->rxnet, stat_tx_data_send_fail);\n\t\trxrpc_cancel_rtt_probe(call, serial, rtt_slot);\n\t\ttrace_rxrpc_tx_fail(call->debug_id, serial, ret,\n\t\t\t\t    rxrpc_tx_point_call_data_frag);\n\t} else {\n\t\ttrace_rxrpc_tx_packet(call->debug_id, &txb->wire,\n\t\t\t\t      rxrpc_tx_point_call_data_frag);\n\t}\n\trxrpc_tx_backoff(call, ret);\n\tgoto done;\n}\n\n \nvoid rxrpc_send_conn_abort(struct rxrpc_connection *conn)\n{\n\tstruct rxrpc_wire_header whdr;\n\tstruct msghdr msg;\n\tstruct kvec iov[2];\n\t__be32 word;\n\tsize_t len;\n\tu32 serial;\n\tint ret;\n\n\tmsg.msg_name\t= &conn->peer->srx.transport;\n\tmsg.msg_namelen\t= conn->peer->srx.transport_len;\n\tmsg.msg_control\t= NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags\t= 0;\n\n\twhdr.epoch\t= htonl(conn->proto.epoch);\n\twhdr.cid\t= htonl(conn->proto.cid);\n\twhdr.callNumber\t= 0;\n\twhdr.seq\t= 0;\n\twhdr.type\t= RXRPC_PACKET_TYPE_ABORT;\n\twhdr.flags\t= conn->out_clientflag;\n\twhdr.userStatus\t= 0;\n\twhdr.securityIndex = conn->security_ix;\n\twhdr._rsvd\t= 0;\n\twhdr.serviceId\t= htons(conn->service_id);\n\n\tword\t\t= htonl(conn->abort_code);\n\n\tiov[0].iov_base\t= &whdr;\n\tiov[0].iov_len\t= sizeof(whdr);\n\tiov[1].iov_base\t= &word;\n\tiov[1].iov_len\t= sizeof(word);\n\n\tlen = iov[0].iov_len + iov[1].iov_len;\n\n\tserial = atomic_inc_return(&conn->serial);\n\twhdr.serial = htonl(serial);\n\n\tiov_iter_kvec(&msg.msg_iter, WRITE, iov, 2, len);\n\tret = do_udp_sendmsg(conn->local->socket, &msg, len);\n\tif (ret < 0) {\n\t\ttrace_rxrpc_tx_fail(conn->debug_id, serial, ret,\n\t\t\t\t    rxrpc_tx_point_conn_abort);\n\t\t_debug(\"sendmsg failed: %d\", ret);\n\t\treturn;\n\t}\n\n\ttrace_rxrpc_tx_packet(conn->debug_id, &whdr, rxrpc_tx_point_conn_abort);\n\n\tconn->peer->last_tx_at = ktime_get_seconds();\n}\n\n \nvoid rxrpc_reject_packet(struct rxrpc_local *local, struct sk_buff *skb)\n{\n\tstruct rxrpc_wire_header whdr;\n\tstruct sockaddr_rxrpc srx;\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tstruct msghdr msg;\n\tstruct kvec iov[2];\n\tsize_t size;\n\t__be32 code;\n\tint ret, ioc;\n\n\trxrpc_see_skb(skb, rxrpc_skb_see_reject);\n\n\tiov[0].iov_base = &whdr;\n\tiov[0].iov_len = sizeof(whdr);\n\tiov[1].iov_base = &code;\n\tiov[1].iov_len = sizeof(code);\n\n\tmsg.msg_name = &srx.transport;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags = 0;\n\n\tmemset(&whdr, 0, sizeof(whdr));\n\n\tswitch (skb->mark) {\n\tcase RXRPC_SKB_MARK_REJECT_BUSY:\n\t\twhdr.type = RXRPC_PACKET_TYPE_BUSY;\n\t\tsize = sizeof(whdr);\n\t\tioc = 1;\n\t\tbreak;\n\tcase RXRPC_SKB_MARK_REJECT_ABORT:\n\t\twhdr.type = RXRPC_PACKET_TYPE_ABORT;\n\t\tcode = htonl(skb->priority);\n\t\tsize = sizeof(whdr) + sizeof(code);\n\t\tioc = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (rxrpc_extract_addr_from_skb(&srx, skb) == 0) {\n\t\tmsg.msg_namelen = srx.transport_len;\n\n\t\twhdr.epoch\t= htonl(sp->hdr.epoch);\n\t\twhdr.cid\t= htonl(sp->hdr.cid);\n\t\twhdr.callNumber\t= htonl(sp->hdr.callNumber);\n\t\twhdr.serviceId\t= htons(sp->hdr.serviceId);\n\t\twhdr.flags\t= sp->hdr.flags;\n\t\twhdr.flags\t^= RXRPC_CLIENT_INITIATED;\n\t\twhdr.flags\t&= RXRPC_CLIENT_INITIATED;\n\n\t\tiov_iter_kvec(&msg.msg_iter, WRITE, iov, ioc, size);\n\t\tret = do_udp_sendmsg(local->socket, &msg, size);\n\t\tif (ret < 0)\n\t\t\ttrace_rxrpc_tx_fail(local->debug_id, 0, ret,\n\t\t\t\t\t    rxrpc_tx_point_reject);\n\t\telse\n\t\t\ttrace_rxrpc_tx_packet(local->debug_id, &whdr,\n\t\t\t\t\t      rxrpc_tx_point_reject);\n\t}\n}\n\n \nvoid rxrpc_send_keepalive(struct rxrpc_peer *peer)\n{\n\tstruct rxrpc_wire_header whdr;\n\tstruct msghdr msg;\n\tstruct kvec iov[2];\n\tsize_t len;\n\tint ret;\n\n\t_enter(\"\");\n\n\tmsg.msg_name\t= &peer->srx.transport;\n\tmsg.msg_namelen\t= peer->srx.transport_len;\n\tmsg.msg_control\t= NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags\t= 0;\n\n\twhdr.epoch\t= htonl(peer->local->rxnet->epoch);\n\twhdr.cid\t= 0;\n\twhdr.callNumber\t= 0;\n\twhdr.seq\t= 0;\n\twhdr.serial\t= 0;\n\twhdr.type\t= RXRPC_PACKET_TYPE_VERSION;  \n\twhdr.flags\t= RXRPC_LAST_PACKET;\n\twhdr.userStatus\t= 0;\n\twhdr.securityIndex = 0;\n\twhdr._rsvd\t= 0;\n\twhdr.serviceId\t= 0;\n\n\tiov[0].iov_base\t= &whdr;\n\tiov[0].iov_len\t= sizeof(whdr);\n\tiov[1].iov_base\t= (char *)rxrpc_keepalive_string;\n\tiov[1].iov_len\t= sizeof(rxrpc_keepalive_string);\n\n\tlen = iov[0].iov_len + iov[1].iov_len;\n\n\tiov_iter_kvec(&msg.msg_iter, WRITE, iov, 2, len);\n\tret = do_udp_sendmsg(peer->local->socket, &msg, len);\n\tif (ret < 0)\n\t\ttrace_rxrpc_tx_fail(peer->debug_id, 0, ret,\n\t\t\t\t    rxrpc_tx_point_version_keepalive);\n\telse\n\t\ttrace_rxrpc_tx_packet(peer->debug_id, &whdr,\n\t\t\t\t      rxrpc_tx_point_version_keepalive);\n\n\tpeer->last_tx_at = ktime_get_seconds();\n\t_leave(\"\");\n}\n\n \nstatic inline void rxrpc_instant_resend(struct rxrpc_call *call,\n\t\t\t\t\tstruct rxrpc_txbuf *txb)\n{\n\tif (!__rxrpc_call_is_complete(call))\n\t\tkdebug(\"resend\");\n}\n\n \nvoid rxrpc_transmit_one(struct rxrpc_call *call, struct rxrpc_txbuf *txb)\n{\n\tint ret;\n\n\tret = rxrpc_send_data_packet(call, txb);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase -ENETUNREACH:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ECONNREFUSED:\n\t\t\trxrpc_set_call_completion(call, RXRPC_CALL_LOCAL_ERROR,\n\t\t\t\t\t\t  0, ret);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_debug(\"need instant resend %d\", ret);\n\t\t\trxrpc_instant_resend(call, txb);\n\t\t}\n\t} else {\n\t\tunsigned long now = jiffies;\n\t\tunsigned long resend_at = now + call->peer->rto_j;\n\n\t\tWRITE_ONCE(call->resend_at, resend_at);\n\t\trxrpc_reduce_call_timer(call, resend_at, now,\n\t\t\t\t\trxrpc_timer_set_for_send);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}