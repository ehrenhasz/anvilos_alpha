{
  "module_name": "proc.c",
  "hash_id": "c133e8494194986abf104963e31e151e1497c1f1a885c9b6e188a127e5418096",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/proc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include \"ar-internal.h\"\n\nstatic const char *const rxrpc_conn_states[RXRPC_CONN__NR_STATES] = {\n\t[RXRPC_CONN_UNUSED]\t\t\t= \"Unused  \",\n\t[RXRPC_CONN_CLIENT_UNSECURED]\t\t= \"ClUnsec \",\n\t[RXRPC_CONN_CLIENT]\t\t\t= \"Client  \",\n\t[RXRPC_CONN_SERVICE_PREALLOC]\t\t= \"SvPrealc\",\n\t[RXRPC_CONN_SERVICE_UNSECURED]\t\t= \"SvUnsec \",\n\t[RXRPC_CONN_SERVICE_CHALLENGING]\t= \"SvChall \",\n\t[RXRPC_CONN_SERVICE]\t\t\t= \"SvSecure\",\n\t[RXRPC_CONN_ABORTED]\t\t\t= \"Aborted \",\n};\n\n \nstatic void *rxrpc_call_seq_start(struct seq_file *seq, loff_t *_pos)\n\t__acquires(rcu)\n{\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_net(seq));\n\n\trcu_read_lock();\n\treturn seq_list_start_head_rcu(&rxnet->calls, *_pos);\n}\n\nstatic void *rxrpc_call_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_net(seq));\n\n\treturn seq_list_next_rcu(v, &rxnet->calls, pos);\n}\n\nstatic void rxrpc_call_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic int rxrpc_call_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct rxrpc_local *local;\n\tstruct rxrpc_call *call;\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_net(seq));\n\tenum rxrpc_call_state state;\n\tunsigned long timeout = 0;\n\trxrpc_seq_t acks_hard_ack;\n\tchar lbuff[50], rbuff[50];\n\n\tif (v == &rxnet->calls) {\n\t\tseq_puts(seq,\n\t\t\t \"Proto Local                                          \"\n\t\t\t \" Remote                                         \"\n\t\t\t \" SvID ConnID   CallID   End Use State    Abort   \"\n\t\t\t \" DebugId  TxSeq    TW RxSeq    RW RxSerial CW RxTimo\\n\");\n\t\treturn 0;\n\t}\n\n\tcall = list_entry(v, struct rxrpc_call, link);\n\n\tlocal = call->local;\n\tif (local)\n\t\tsprintf(lbuff, \"%pISpc\", &local->srx.transport);\n\telse\n\t\tstrcpy(lbuff, \"no_local\");\n\n\tsprintf(rbuff, \"%pISpc\", &call->dest_srx.transport);\n\n\tstate = rxrpc_call_state(call);\n\tif (state != RXRPC_CALL_SERVER_PREALLOC) {\n\t\ttimeout = READ_ONCE(call->expect_rx_by);\n\t\ttimeout -= jiffies;\n\t}\n\n\tacks_hard_ack = READ_ONCE(call->acks_hard_ack);\n\tseq_printf(seq,\n\t\t   \"UDP   %-47.47s %-47.47s %4x %08x %08x %s %3u\"\n\t\t   \" %-8.8s %08x %08x %08x %02x %08x %02x %08x %02x %06lx\\n\",\n\t\t   lbuff,\n\t\t   rbuff,\n\t\t   call->dest_srx.srx_service,\n\t\t   call->cid,\n\t\t   call->call_id,\n\t\t   rxrpc_is_service_call(call) ? \"Svc\" : \"Clt\",\n\t\t   refcount_read(&call->ref),\n\t\t   rxrpc_call_states[state],\n\t\t   call->abort_code,\n\t\t   call->debug_id,\n\t\t   acks_hard_ack, READ_ONCE(call->tx_top) - acks_hard_ack,\n\t\t   call->ackr_window, call->ackr_wtop - call->ackr_window,\n\t\t   call->rx_serial,\n\t\t   call->cong_cwnd,\n\t\t   timeout);\n\n\treturn 0;\n}\n\nconst struct seq_operations rxrpc_call_seq_ops = {\n\t.start  = rxrpc_call_seq_start,\n\t.next   = rxrpc_call_seq_next,\n\t.stop   = rxrpc_call_seq_stop,\n\t.show   = rxrpc_call_seq_show,\n};\n\n \nstatic void *rxrpc_connection_seq_start(struct seq_file *seq, loff_t *_pos)\n\t__acquires(rxnet->conn_lock)\n{\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_net(seq));\n\n\tread_lock(&rxnet->conn_lock);\n\treturn seq_list_start_head(&rxnet->conn_proc_list, *_pos);\n}\n\nstatic void *rxrpc_connection_seq_next(struct seq_file *seq, void *v,\n\t\t\t\t       loff_t *pos)\n{\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_net(seq));\n\n\treturn seq_list_next(v, &rxnet->conn_proc_list, pos);\n}\n\nstatic void rxrpc_connection_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rxnet->conn_lock)\n{\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_net(seq));\n\n\tread_unlock(&rxnet->conn_lock);\n}\n\nstatic int rxrpc_connection_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct rxrpc_connection *conn;\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_net(seq));\n\tconst char *state;\n\tchar lbuff[50], rbuff[50];\n\n\tif (v == &rxnet->conn_proc_list) {\n\t\tseq_puts(seq,\n\t\t\t \"Proto Local                                          \"\n\t\t\t \" Remote                                         \"\n\t\t\t \" SvID ConnID   End Ref Act State    Key     \"\n\t\t\t \" Serial   ISerial  CallId0  CallId1  CallId2  CallId3\\n\"\n\t\t\t );\n\t\treturn 0;\n\t}\n\n\tconn = list_entry(v, struct rxrpc_connection, proc_link);\n\tif (conn->state == RXRPC_CONN_SERVICE_PREALLOC) {\n\t\tstrcpy(lbuff, \"no_local\");\n\t\tstrcpy(rbuff, \"no_connection\");\n\t\tgoto print;\n\t}\n\n\tsprintf(lbuff, \"%pISpc\", &conn->local->srx.transport);\n\tsprintf(rbuff, \"%pISpc\", &conn->peer->srx.transport);\nprint:\n\tstate = rxrpc_is_conn_aborted(conn) ?\n\t\trxrpc_call_completions[conn->completion] :\n\t\trxrpc_conn_states[conn->state];\n\tseq_printf(seq,\n\t\t   \"UDP   %-47.47s %-47.47s %4x %08x %s %3u %3d\"\n\t\t   \" %s %08x %08x %08x %08x %08x %08x %08x\\n\",\n\t\t   lbuff,\n\t\t   rbuff,\n\t\t   conn->service_id,\n\t\t   conn->proto.cid,\n\t\t   rxrpc_conn_is_service(conn) ? \"Svc\" : \"Clt\",\n\t\t   refcount_read(&conn->ref),\n\t\t   atomic_read(&conn->active),\n\t\t   state,\n\t\t   key_serial(conn->key),\n\t\t   atomic_read(&conn->serial),\n\t\t   conn->hi_serial,\n\t\t   conn->channels[0].call_id,\n\t\t   conn->channels[1].call_id,\n\t\t   conn->channels[2].call_id,\n\t\t   conn->channels[3].call_id);\n\n\treturn 0;\n}\n\nconst struct seq_operations rxrpc_connection_seq_ops = {\n\t.start  = rxrpc_connection_seq_start,\n\t.next   = rxrpc_connection_seq_next,\n\t.stop   = rxrpc_connection_seq_stop,\n\t.show   = rxrpc_connection_seq_show,\n};\n\n \nstatic int rxrpc_peer_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct rxrpc_peer *peer;\n\ttime64_t now;\n\tchar lbuff[50], rbuff[50];\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"Proto Local                                          \"\n\t\t\t \" Remote                                         \"\n\t\t\t \" Use SST   MTU LastUse      RTT      RTO\\n\"\n\t\t\t );\n\t\treturn 0;\n\t}\n\n\tpeer = list_entry(v, struct rxrpc_peer, hash_link);\n\n\tsprintf(lbuff, \"%pISpc\", &peer->local->srx.transport);\n\n\tsprintf(rbuff, \"%pISpc\", &peer->srx.transport);\n\n\tnow = ktime_get_seconds();\n\tseq_printf(seq,\n\t\t   \"UDP   %-47.47s %-47.47s %3u\"\n\t\t   \" %3u %5u %6llus %8u %8u\\n\",\n\t\t   lbuff,\n\t\t   rbuff,\n\t\t   refcount_read(&peer->ref),\n\t\t   peer->cong_ssthresh,\n\t\t   peer->mtu,\n\t\t   now - peer->last_tx_at,\n\t\t   peer->srtt_us >> 3,\n\t\t   jiffies_to_usecs(peer->rto_j));\n\n\treturn 0;\n}\n\nstatic void *rxrpc_peer_seq_start(struct seq_file *seq, loff_t *_pos)\n\t__acquires(rcu)\n{\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_net(seq));\n\tunsigned int bucket, n;\n\tunsigned int shift = 32 - HASH_BITS(rxnet->peer_hash);\n\tvoid *p;\n\n\trcu_read_lock();\n\n\tif (*_pos >= UINT_MAX)\n\t\treturn NULL;\n\n\tn = *_pos & ((1U << shift) - 1);\n\tbucket = *_pos >> shift;\n\tfor (;;) {\n\t\tif (bucket >= HASH_SIZE(rxnet->peer_hash)) {\n\t\t\t*_pos = UINT_MAX;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (n == 0) {\n\t\t\tif (bucket == 0)\n\t\t\t\treturn SEQ_START_TOKEN;\n\t\t\t*_pos += 1;\n\t\t\tn++;\n\t\t}\n\n\t\tp = seq_hlist_start_rcu(&rxnet->peer_hash[bucket], n - 1);\n\t\tif (p)\n\t\t\treturn p;\n\t\tbucket++;\n\t\tn = 1;\n\t\t*_pos = (bucket << shift) | n;\n\t}\n}\n\nstatic void *rxrpc_peer_seq_next(struct seq_file *seq, void *v, loff_t *_pos)\n{\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_net(seq));\n\tunsigned int bucket, n;\n\tunsigned int shift = 32 - HASH_BITS(rxnet->peer_hash);\n\tvoid *p;\n\n\tif (*_pos >= UINT_MAX)\n\t\treturn NULL;\n\n\tbucket = *_pos >> shift;\n\n\tp = seq_hlist_next_rcu(v, &rxnet->peer_hash[bucket], _pos);\n\tif (p)\n\t\treturn p;\n\n\tfor (;;) {\n\t\tbucket++;\n\t\tn = 1;\n\t\t*_pos = (bucket << shift) | n;\n\n\t\tif (bucket >= HASH_SIZE(rxnet->peer_hash)) {\n\t\t\t*_pos = UINT_MAX;\n\t\t\treturn NULL;\n\t\t}\n\t\tif (n == 0) {\n\t\t\t*_pos += 1;\n\t\t\tn++;\n\t\t}\n\n\t\tp = seq_hlist_start_rcu(&rxnet->peer_hash[bucket], n - 1);\n\t\tif (p)\n\t\t\treturn p;\n\t}\n}\n\nstatic void rxrpc_peer_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\n\nconst struct seq_operations rxrpc_peer_seq_ops = {\n\t.start  = rxrpc_peer_seq_start,\n\t.next   = rxrpc_peer_seq_next,\n\t.stop   = rxrpc_peer_seq_stop,\n\t.show   = rxrpc_peer_seq_show,\n};\n\n \nstatic int rxrpc_local_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct rxrpc_local *local;\n\tchar lbuff[50];\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"Proto Local                                          \"\n\t\t\t \" Use Act RxQ\\n\");\n\t\treturn 0;\n\t}\n\n\tlocal = hlist_entry(v, struct rxrpc_local, link);\n\n\tsprintf(lbuff, \"%pISpc\", &local->srx.transport);\n\n\tseq_printf(seq,\n\t\t   \"UDP   %-47.47s %3u %3u %3u\\n\",\n\t\t   lbuff,\n\t\t   refcount_read(&local->ref),\n\t\t   atomic_read(&local->active_users),\n\t\t   local->rx_queue.qlen);\n\n\treturn 0;\n}\n\nstatic void *rxrpc_local_seq_start(struct seq_file *seq, loff_t *_pos)\n\t__acquires(rcu)\n{\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_net(seq));\n\tunsigned int n;\n\n\trcu_read_lock();\n\n\tif (*_pos >= UINT_MAX)\n\t\treturn NULL;\n\n\tn = *_pos;\n\tif (n == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\treturn seq_hlist_start_rcu(&rxnet->local_endpoints, n - 1);\n}\n\nstatic void *rxrpc_local_seq_next(struct seq_file *seq, void *v, loff_t *_pos)\n{\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_net(seq));\n\n\tif (*_pos >= UINT_MAX)\n\t\treturn NULL;\n\n\treturn seq_hlist_next_rcu(v, &rxnet->local_endpoints, _pos);\n}\n\nstatic void rxrpc_local_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nconst struct seq_operations rxrpc_local_seq_ops = {\n\t.start  = rxrpc_local_seq_start,\n\t.next   = rxrpc_local_seq_next,\n\t.stop   = rxrpc_local_seq_stop,\n\t.show   = rxrpc_local_seq_show,\n};\n\n \nint rxrpc_stats_show(struct seq_file *seq, void *v)\n{\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_single_net(seq));\n\n\tseq_printf(seq,\n\t\t   \"Data     : send=%u sendf=%u fail=%u\\n\",\n\t\t   atomic_read(&rxnet->stat_tx_data_send),\n\t\t   atomic_read(&rxnet->stat_tx_data_send_frag),\n\t\t   atomic_read(&rxnet->stat_tx_data_send_fail));\n\tseq_printf(seq,\n\t\t   \"Data-Tx  : nr=%u retrans=%u uf=%u cwr=%u\\n\",\n\t\t   atomic_read(&rxnet->stat_tx_data),\n\t\t   atomic_read(&rxnet->stat_tx_data_retrans),\n\t\t   atomic_read(&rxnet->stat_tx_data_underflow),\n\t\t   atomic_read(&rxnet->stat_tx_data_cwnd_reset));\n\tseq_printf(seq,\n\t\t   \"Data-Rx  : nr=%u reqack=%u jumbo=%u\\n\",\n\t\t   atomic_read(&rxnet->stat_rx_data),\n\t\t   atomic_read(&rxnet->stat_rx_data_reqack),\n\t\t   atomic_read(&rxnet->stat_rx_data_jumbo));\n\tseq_printf(seq,\n\t\t   \"Ack      : fill=%u send=%u skip=%u\\n\",\n\t\t   atomic_read(&rxnet->stat_tx_ack_fill),\n\t\t   atomic_read(&rxnet->stat_tx_ack_send),\n\t\t   atomic_read(&rxnet->stat_tx_ack_skip));\n\tseq_printf(seq,\n\t\t   \"Ack-Tx   : req=%u dup=%u oos=%u exw=%u nos=%u png=%u prs=%u dly=%u idl=%u\\n\",\n\t\t   atomic_read(&rxnet->stat_tx_acks[RXRPC_ACK_REQUESTED]),\n\t\t   atomic_read(&rxnet->stat_tx_acks[RXRPC_ACK_DUPLICATE]),\n\t\t   atomic_read(&rxnet->stat_tx_acks[RXRPC_ACK_OUT_OF_SEQUENCE]),\n\t\t   atomic_read(&rxnet->stat_tx_acks[RXRPC_ACK_EXCEEDS_WINDOW]),\n\t\t   atomic_read(&rxnet->stat_tx_acks[RXRPC_ACK_NOSPACE]),\n\t\t   atomic_read(&rxnet->stat_tx_acks[RXRPC_ACK_PING]),\n\t\t   atomic_read(&rxnet->stat_tx_acks[RXRPC_ACK_PING_RESPONSE]),\n\t\t   atomic_read(&rxnet->stat_tx_acks[RXRPC_ACK_DELAY]),\n\t\t   atomic_read(&rxnet->stat_tx_acks[RXRPC_ACK_IDLE]));\n\tseq_printf(seq,\n\t\t   \"Ack-Rx   : req=%u dup=%u oos=%u exw=%u nos=%u png=%u prs=%u dly=%u idl=%u\\n\",\n\t\t   atomic_read(&rxnet->stat_rx_acks[RXRPC_ACK_REQUESTED]),\n\t\t   atomic_read(&rxnet->stat_rx_acks[RXRPC_ACK_DUPLICATE]),\n\t\t   atomic_read(&rxnet->stat_rx_acks[RXRPC_ACK_OUT_OF_SEQUENCE]),\n\t\t   atomic_read(&rxnet->stat_rx_acks[RXRPC_ACK_EXCEEDS_WINDOW]),\n\t\t   atomic_read(&rxnet->stat_rx_acks[RXRPC_ACK_NOSPACE]),\n\t\t   atomic_read(&rxnet->stat_rx_acks[RXRPC_ACK_PING]),\n\t\t   atomic_read(&rxnet->stat_rx_acks[RXRPC_ACK_PING_RESPONSE]),\n\t\t   atomic_read(&rxnet->stat_rx_acks[RXRPC_ACK_DELAY]),\n\t\t   atomic_read(&rxnet->stat_rx_acks[RXRPC_ACK_IDLE]));\n\tseq_printf(seq,\n\t\t   \"Why-Req-A: acklost=%u already=%u mrtt=%u ortt=%u\\n\",\n\t\t   atomic_read(&rxnet->stat_why_req_ack[rxrpc_reqack_ack_lost]),\n\t\t   atomic_read(&rxnet->stat_why_req_ack[rxrpc_reqack_already_on]),\n\t\t   atomic_read(&rxnet->stat_why_req_ack[rxrpc_reqack_more_rtt]),\n\t\t   atomic_read(&rxnet->stat_why_req_ack[rxrpc_reqack_old_rtt]));\n\tseq_printf(seq,\n\t\t   \"Why-Req-A: nolast=%u retx=%u slows=%u smtxw=%u\\n\",\n\t\t   atomic_read(&rxnet->stat_why_req_ack[rxrpc_reqack_no_srv_last]),\n\t\t   atomic_read(&rxnet->stat_why_req_ack[rxrpc_reqack_retrans]),\n\t\t   atomic_read(&rxnet->stat_why_req_ack[rxrpc_reqack_slow_start]),\n\t\t   atomic_read(&rxnet->stat_why_req_ack[rxrpc_reqack_small_txwin]));\n\tseq_printf(seq,\n\t\t   \"Buffers  : txb=%u rxb=%u\\n\",\n\t\t   atomic_read(&rxrpc_nr_txbuf),\n\t\t   atomic_read(&rxrpc_n_rx_skbs));\n\tseq_printf(seq,\n\t\t   \"IO-thread: loops=%u\\n\",\n\t\t   atomic_read(&rxnet->stat_io_loop));\n\treturn 0;\n}\n\n \nint rxrpc_stats_clear(struct file *file, char *buf, size_t size)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct rxrpc_net *rxnet = rxrpc_net(seq_file_single_net(m));\n\n\tif (size > 1 || (size == 1 && buf[0] != '\\n'))\n\t\treturn -EINVAL;\n\n\tatomic_set(&rxnet->stat_tx_data, 0);\n\tatomic_set(&rxnet->stat_tx_data_retrans, 0);\n\tatomic_set(&rxnet->stat_tx_data_underflow, 0);\n\tatomic_set(&rxnet->stat_tx_data_cwnd_reset, 0);\n\tatomic_set(&rxnet->stat_tx_data_send, 0);\n\tatomic_set(&rxnet->stat_tx_data_send_frag, 0);\n\tatomic_set(&rxnet->stat_tx_data_send_fail, 0);\n\tatomic_set(&rxnet->stat_rx_data, 0);\n\tatomic_set(&rxnet->stat_rx_data_reqack, 0);\n\tatomic_set(&rxnet->stat_rx_data_jumbo, 0);\n\n\tatomic_set(&rxnet->stat_tx_ack_fill, 0);\n\tatomic_set(&rxnet->stat_tx_ack_send, 0);\n\tatomic_set(&rxnet->stat_tx_ack_skip, 0);\n\tmemset(&rxnet->stat_tx_acks, 0, sizeof(rxnet->stat_tx_acks));\n\tmemset(&rxnet->stat_rx_acks, 0, sizeof(rxnet->stat_rx_acks));\n\n\tmemset(&rxnet->stat_why_req_ack, 0, sizeof(rxnet->stat_why_req_ack));\n\n\tatomic_set(&rxnet->stat_io_loop, 0);\n\treturn size;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}