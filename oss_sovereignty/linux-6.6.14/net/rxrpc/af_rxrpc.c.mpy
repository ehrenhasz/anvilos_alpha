{
  "module_name": "af_rxrpc.c",
  "hash_id": "79cb83173dd57c4846bf569c3802e4765205a74497d092ddb753c026e31c2175",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/af_rxrpc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/random.h>\n#include <linux/poll.h>\n#include <linux/proc_fs.h>\n#include <linux/key-type.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#define CREATE_TRACE_POINTS\n#include \"ar-internal.h\"\n\nMODULE_DESCRIPTION(\"RxRPC network protocol\");\nMODULE_AUTHOR(\"Red Hat, Inc.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_RXRPC);\n\nunsigned int rxrpc_debug; \nmodule_param_named(debug, rxrpc_debug, uint, 0644);\nMODULE_PARM_DESC(debug, \"RxRPC debugging mask\");\n\nstatic struct proto rxrpc_proto;\nstatic const struct proto_ops rxrpc_rpc_ops;\n\n \natomic_t rxrpc_debug_id;\nEXPORT_SYMBOL(rxrpc_debug_id);\n\n \natomic_t rxrpc_n_rx_skbs;\n\nstruct workqueue_struct *rxrpc_workqueue;\n\nstatic void rxrpc_sock_destructor(struct sock *);\n\n \nstatic inline int rxrpc_writable(struct sock *sk)\n{\n\treturn refcount_read(&sk->sk_wmem_alloc) < (size_t) sk->sk_sndbuf;\n}\n\n \nstatic void rxrpc_write_space(struct sock *sk)\n{\n\t_enter(\"%p\", sk);\n\trcu_read_lock();\n\tif (rxrpc_writable(sk)) {\n\t\tstruct socket_wq *wq = rcu_dereference(sk->sk_wq);\n\n\t\tif (skwq_has_sleeper(wq))\n\t\t\twake_up_interruptible(&wq->wait);\n\t\tsk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic int rxrpc_validate_address(struct rxrpc_sock *rx,\n\t\t\t\t  struct sockaddr_rxrpc *srx,\n\t\t\t\t  int len)\n{\n\tunsigned int tail;\n\n\tif (len < sizeof(struct sockaddr_rxrpc))\n\t\treturn -EINVAL;\n\n\tif (srx->srx_family != AF_RXRPC)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (srx->transport_type != SOCK_DGRAM)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tlen -= offsetof(struct sockaddr_rxrpc, transport);\n\tif (srx->transport_len < sizeof(sa_family_t) ||\n\t    srx->transport_len > len)\n\t\treturn -EINVAL;\n\n\tswitch (srx->transport.family) {\n\tcase AF_INET:\n\t\tif (rx->family != AF_INET &&\n\t\t    rx->family != AF_INET6)\n\t\t\treturn -EAFNOSUPPORT;\n\t\tif (srx->transport_len < sizeof(struct sockaddr_in))\n\t\t\treturn -EINVAL;\n\t\ttail = offsetof(struct sockaddr_rxrpc, transport.sin.__pad);\n\t\tbreak;\n\n#ifdef CONFIG_AF_RXRPC_IPV6\n\tcase AF_INET6:\n\t\tif (rx->family != AF_INET6)\n\t\t\treturn -EAFNOSUPPORT;\n\t\tif (srx->transport_len < sizeof(struct sockaddr_in6))\n\t\t\treturn -EINVAL;\n\t\ttail = offsetof(struct sockaddr_rxrpc, transport) +\n\t\t\tsizeof(struct sockaddr_in6);\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\treturn -EAFNOSUPPORT;\n\t}\n\n\tif (tail < len)\n\t\tmemset((void *)srx + tail, 0, len - tail);\n\t_debug(\"INET: %pISp\", &srx->transport);\n\treturn 0;\n}\n\n \nstatic int rxrpc_bind(struct socket *sock, struct sockaddr *saddr, int len)\n{\n\tstruct sockaddr_rxrpc *srx = (struct sockaddr_rxrpc *)saddr;\n\tstruct rxrpc_local *local;\n\tstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\n\tu16 service_id;\n\tint ret;\n\n\t_enter(\"%p,%p,%d\", rx, saddr, len);\n\n\tret = rxrpc_validate_address(rx, srx, len);\n\tif (ret < 0)\n\t\tgoto error;\n\tservice_id = srx->srx_service;\n\n\tlock_sock(&rx->sk);\n\n\tswitch (rx->sk.sk_state) {\n\tcase RXRPC_UNBOUND:\n\t\trx->srx = *srx;\n\t\tlocal = rxrpc_lookup_local(sock_net(&rx->sk), &rx->srx);\n\t\tif (IS_ERR(local)) {\n\t\t\tret = PTR_ERR(local);\n\t\t\tgoto error_unlock;\n\t\t}\n\n\t\tif (service_id) {\n\t\t\twrite_lock(&local->services_lock);\n\t\t\tif (local->service)\n\t\t\t\tgoto service_in_use;\n\t\t\trx->local = local;\n\t\t\tlocal->service = rx;\n\t\t\twrite_unlock(&local->services_lock);\n\n\t\t\trx->sk.sk_state = RXRPC_SERVER_BOUND;\n\t\t} else {\n\t\t\trx->local = local;\n\t\t\trx->sk.sk_state = RXRPC_CLIENT_BOUND;\n\t\t}\n\t\tbreak;\n\n\tcase RXRPC_SERVER_BOUND:\n\t\tret = -EINVAL;\n\t\tif (service_id == 0)\n\t\t\tgoto error_unlock;\n\t\tret = -EADDRINUSE;\n\t\tif (service_id == rx->srx.srx_service)\n\t\t\tgoto error_unlock;\n\t\tret = -EINVAL;\n\t\tsrx->srx_service = rx->srx.srx_service;\n\t\tif (memcmp(srx, &rx->srx, sizeof(*srx)) != 0)\n\t\t\tgoto error_unlock;\n\t\trx->second_service = service_id;\n\t\trx->sk.sk_state = RXRPC_SERVER_BOUND2;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error_unlock;\n\t}\n\n\trelease_sock(&rx->sk);\n\t_leave(\" = 0\");\n\treturn 0;\n\nservice_in_use:\n\twrite_unlock(&local->services_lock);\n\trxrpc_unuse_local(local, rxrpc_local_unuse_bind);\n\trxrpc_put_local(local, rxrpc_local_put_bind);\n\tret = -EADDRINUSE;\nerror_unlock:\n\trelease_sock(&rx->sk);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstatic int rxrpc_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rxrpc_sock *rx = rxrpc_sk(sk);\n\tunsigned int max, old;\n\tint ret;\n\n\t_enter(\"%p,%d\", rx, backlog);\n\n\tlock_sock(&rx->sk);\n\n\tswitch (rx->sk.sk_state) {\n\tcase RXRPC_UNBOUND:\n\t\tret = -EADDRNOTAVAIL;\n\t\tbreak;\n\tcase RXRPC_SERVER_BOUND:\n\tcase RXRPC_SERVER_BOUND2:\n\t\tASSERT(rx->local != NULL);\n\t\tmax = READ_ONCE(rxrpc_max_backlog);\n\t\tret = -EINVAL;\n\t\tif (backlog == INT_MAX)\n\t\t\tbacklog = max;\n\t\telse if (backlog < 0 || backlog > max)\n\t\t\tbreak;\n\t\told = sk->sk_max_ack_backlog;\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tret = rxrpc_service_prealloc(rx, GFP_KERNEL);\n\t\tif (ret == 0)\n\t\t\trx->sk.sk_state = RXRPC_SERVER_LISTENING;\n\t\telse\n\t\t\tsk->sk_max_ack_backlog = old;\n\t\tbreak;\n\tcase RXRPC_SERVER_LISTENING:\n\t\tif (backlog == 0) {\n\t\t\trx->sk.sk_state = RXRPC_SERVER_LISTEN_DISABLED;\n\t\t\tsk->sk_max_ack_backlog = 0;\n\t\t\trxrpc_discard_prealloc(rx);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\n\trelease_sock(&rx->sk);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstruct rxrpc_call *rxrpc_kernel_begin_call(struct socket *sock,\n\t\t\t\t\t   struct sockaddr_rxrpc *srx,\n\t\t\t\t\t   struct key *key,\n\t\t\t\t\t   unsigned long user_call_ID,\n\t\t\t\t\t   s64 tx_total_len,\n\t\t\t\t\t   u32 hard_timeout,\n\t\t\t\t\t   gfp_t gfp,\n\t\t\t\t\t   rxrpc_notify_rx_t notify_rx,\n\t\t\t\t\t   bool upgrade,\n\t\t\t\t\t   enum rxrpc_interruptibility interruptibility,\n\t\t\t\t\t   unsigned int debug_id)\n{\n\tstruct rxrpc_conn_parameters cp;\n\tstruct rxrpc_call_params p;\n\tstruct rxrpc_call *call;\n\tstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\n\tint ret;\n\n\t_enter(\",,%x,%lx\", key_serial(key), user_call_ID);\n\n\tret = rxrpc_validate_address(rx, srx, sizeof(*srx));\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tlock_sock(&rx->sk);\n\n\tif (!key)\n\t\tkey = rx->key;\n\tif (key && !key->payload.data[0])\n\t\tkey = NULL;  \n\n\tmemset(&p, 0, sizeof(p));\n\tp.user_call_ID\t\t= user_call_ID;\n\tp.tx_total_len\t\t= tx_total_len;\n\tp.interruptibility\t= interruptibility;\n\tp.kernel\t\t= true;\n\tp.timeouts.hard\t\t= hard_timeout;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.local\t\t= rx->local;\n\tcp.key\t\t\t= key;\n\tcp.security_level\t= rx->min_sec_level;\n\tcp.exclusive\t\t= false;\n\tcp.upgrade\t\t= upgrade;\n\tcp.service_id\t\t= srx->srx_service;\n\tcall = rxrpc_new_client_call(rx, &cp, srx, &p, gfp, debug_id);\n\t \n\tif (!IS_ERR(call)) {\n\t\tcall->notify_rx = notify_rx;\n\t\tmutex_unlock(&call->user_mutex);\n\t}\n\n\t_leave(\" = %p\", call);\n\treturn call;\n}\nEXPORT_SYMBOL(rxrpc_kernel_begin_call);\n\n \nstatic void rxrpc_dummy_notify_rx(struct sock *sk, struct rxrpc_call *rxcall,\n\t\t\t\t  unsigned long call_user_ID)\n{\n}\n\n \nvoid rxrpc_kernel_shutdown_call(struct socket *sock, struct rxrpc_call *call)\n{\n\t_enter(\"%d{%d}\", call->debug_id, refcount_read(&call->ref));\n\n\tmutex_lock(&call->user_mutex);\n\tif (!test_bit(RXRPC_CALL_RELEASED, &call->flags)) {\n\t\trxrpc_release_call(rxrpc_sk(sock->sk), call);\n\n\t\t \n\t\tif (call->notify_rx) {\n\t\t\tspin_lock(&call->notify_lock);\n\t\t\tcall->notify_rx = rxrpc_dummy_notify_rx;\n\t\t\tspin_unlock(&call->notify_lock);\n\t\t}\n\t}\n\tmutex_unlock(&call->user_mutex);\n}\nEXPORT_SYMBOL(rxrpc_kernel_shutdown_call);\n\n \nvoid rxrpc_kernel_put_call(struct socket *sock, struct rxrpc_call *call)\n{\n\trxrpc_put_call(call, rxrpc_call_put_kernel);\n}\nEXPORT_SYMBOL(rxrpc_kernel_put_call);\n\n \nbool rxrpc_kernel_check_life(const struct socket *sock,\n\t\t\t     const struct rxrpc_call *call)\n{\n\tif (!rxrpc_call_is_complete(call))\n\t\treturn true;\n\tif (call->completion != RXRPC_CALL_SUCCEEDED)\n\t\treturn false;\n\treturn !skb_queue_empty(&call->recvmsg_queue);\n}\nEXPORT_SYMBOL(rxrpc_kernel_check_life);\n\n \nu32 rxrpc_kernel_get_epoch(struct socket *sock, struct rxrpc_call *call)\n{\n\treturn call->conn->proto.epoch;\n}\nEXPORT_SYMBOL(rxrpc_kernel_get_epoch);\n\n \nvoid rxrpc_kernel_new_call_notification(\n\tstruct socket *sock,\n\trxrpc_notify_new_call_t notify_new_call,\n\trxrpc_discard_new_call_t discard_new_call)\n{\n\tstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\n\n\trx->notify_new_call = notify_new_call;\n\trx->discard_new_call = discard_new_call;\n}\nEXPORT_SYMBOL(rxrpc_kernel_new_call_notification);\n\n \nvoid rxrpc_kernel_set_max_life(struct socket *sock, struct rxrpc_call *call,\n\t\t\t       unsigned long hard_timeout)\n{\n\tunsigned long now;\n\n\tmutex_lock(&call->user_mutex);\n\n\tnow = jiffies;\n\thard_timeout += now;\n\tWRITE_ONCE(call->expect_term_by, hard_timeout);\n\trxrpc_reduce_call_timer(call, hard_timeout, now, rxrpc_timer_set_for_hard);\n\n\tmutex_unlock(&call->user_mutex);\n}\nEXPORT_SYMBOL(rxrpc_kernel_set_max_life);\n\n \nstatic int rxrpc_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len, int flags)\n{\n\tstruct sockaddr_rxrpc *srx = (struct sockaddr_rxrpc *)addr;\n\tstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\n\tint ret;\n\n\t_enter(\"%p,%p,%d,%d\", rx, addr, addr_len, flags);\n\n\tret = rxrpc_validate_address(rx, srx, addr_len);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [bad addr]\", ret);\n\t\treturn ret;\n\t}\n\n\tlock_sock(&rx->sk);\n\n\tret = -EISCONN;\n\tif (test_bit(RXRPC_SOCK_CONNECTED, &rx->flags))\n\t\tgoto error;\n\n\tswitch (rx->sk.sk_state) {\n\tcase RXRPC_UNBOUND:\n\t\trx->sk.sk_state = RXRPC_CLIENT_UNBOUND;\n\t\tbreak;\n\tcase RXRPC_CLIENT_UNBOUND:\n\tcase RXRPC_CLIENT_BOUND:\n\t\tbreak;\n\tdefault:\n\t\tret = -EBUSY;\n\t\tgoto error;\n\t}\n\n\trx->connect_srx = *srx;\n\tset_bit(RXRPC_SOCK_CONNECTED, &rx->flags);\n\tret = 0;\n\nerror:\n\trelease_sock(&rx->sk);\n\treturn ret;\n}\n\n \nstatic int rxrpc_sendmsg(struct socket *sock, struct msghdr *m, size_t len)\n{\n\tstruct rxrpc_local *local;\n\tstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\n\tint ret;\n\n\t_enter(\",{%d},,%zu\", rx->sk.sk_state, len);\n\n\tif (m->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (m->msg_name) {\n\t\tret = rxrpc_validate_address(rx, m->msg_name, m->msg_namelen);\n\t\tif (ret < 0) {\n\t\t\t_leave(\" = %d [bad addr]\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tlock_sock(&rx->sk);\n\n\tswitch (rx->sk.sk_state) {\n\tcase RXRPC_UNBOUND:\n\tcase RXRPC_CLIENT_UNBOUND:\n\t\trx->srx.srx_family = AF_RXRPC;\n\t\trx->srx.srx_service = 0;\n\t\trx->srx.transport_type = SOCK_DGRAM;\n\t\trx->srx.transport.family = rx->family;\n\t\tswitch (rx->family) {\n\t\tcase AF_INET:\n\t\t\trx->srx.transport_len = sizeof(struct sockaddr_in);\n\t\t\tbreak;\n#ifdef CONFIG_AF_RXRPC_IPV6\n\t\tcase AF_INET6:\n\t\t\trx->srx.transport_len = sizeof(struct sockaddr_in6);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tret = -EAFNOSUPPORT;\n\t\t\tgoto error_unlock;\n\t\t}\n\t\tlocal = rxrpc_lookup_local(sock_net(sock->sk), &rx->srx);\n\t\tif (IS_ERR(local)) {\n\t\t\tret = PTR_ERR(local);\n\t\t\tgoto error_unlock;\n\t\t}\n\n\t\trx->local = local;\n\t\trx->sk.sk_state = RXRPC_CLIENT_BOUND;\n\t\tfallthrough;\n\n\tcase RXRPC_CLIENT_BOUND:\n\t\tif (!m->msg_name &&\n\t\t    test_bit(RXRPC_SOCK_CONNECTED, &rx->flags)) {\n\t\t\tm->msg_name = &rx->connect_srx;\n\t\t\tm->msg_namelen = sizeof(rx->connect_srx);\n\t\t}\n\t\tfallthrough;\n\tcase RXRPC_SERVER_BOUND:\n\tcase RXRPC_SERVER_LISTENING:\n\t\tret = rxrpc_do_sendmsg(rx, m, len);\n\t\t \n\t\tgoto out;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error_unlock;\n\t}\n\nerror_unlock:\n\trelease_sock(&rx->sk);\nout:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\nint rxrpc_sock_set_min_security_level(struct sock *sk, unsigned int val)\n{\n\tif (sk->sk_state != RXRPC_UNBOUND)\n\t\treturn -EISCONN;\n\tif (val > RXRPC_SECURITY_MAX)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\trxrpc_sk(sk)->min_sec_level = val;\n\trelease_sock(sk);\n\treturn 0;\n}\nEXPORT_SYMBOL(rxrpc_sock_set_min_security_level);\n\n \nstatic int rxrpc_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t    sockptr_t optval, unsigned int optlen)\n{\n\tstruct rxrpc_sock *rx = rxrpc_sk(sock->sk);\n\tunsigned int min_sec_level;\n\tu16 service_upgrade[2];\n\tint ret;\n\n\t_enter(\",%d,%d,,%d\", level, optname, optlen);\n\n\tlock_sock(&rx->sk);\n\tret = -EOPNOTSUPP;\n\n\tif (level == SOL_RXRPC) {\n\t\tswitch (optname) {\n\t\tcase RXRPC_EXCLUSIVE_CONNECTION:\n\t\t\tret = -EINVAL;\n\t\t\tif (optlen != 0)\n\t\t\t\tgoto error;\n\t\t\tret = -EISCONN;\n\t\t\tif (rx->sk.sk_state != RXRPC_UNBOUND)\n\t\t\t\tgoto error;\n\t\t\trx->exclusive = true;\n\t\t\tgoto success;\n\n\t\tcase RXRPC_SECURITY_KEY:\n\t\t\tret = -EINVAL;\n\t\t\tif (rx->key)\n\t\t\t\tgoto error;\n\t\t\tret = -EISCONN;\n\t\t\tif (rx->sk.sk_state != RXRPC_UNBOUND)\n\t\t\t\tgoto error;\n\t\t\tret = rxrpc_request_key(rx, optval, optlen);\n\t\t\tgoto error;\n\n\t\tcase RXRPC_SECURITY_KEYRING:\n\t\t\tret = -EINVAL;\n\t\t\tif (rx->key)\n\t\t\t\tgoto error;\n\t\t\tret = -EISCONN;\n\t\t\tif (rx->sk.sk_state != RXRPC_UNBOUND)\n\t\t\t\tgoto error;\n\t\t\tret = rxrpc_server_keyring(rx, optval, optlen);\n\t\t\tgoto error;\n\n\t\tcase RXRPC_MIN_SECURITY_LEVEL:\n\t\t\tret = -EINVAL;\n\t\t\tif (optlen != sizeof(unsigned int))\n\t\t\t\tgoto error;\n\t\t\tret = -EISCONN;\n\t\t\tif (rx->sk.sk_state != RXRPC_UNBOUND)\n\t\t\t\tgoto error;\n\t\t\tret = copy_from_sockptr(&min_sec_level, optval,\n\t\t\t\t       sizeof(unsigned int));\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tret = -EINVAL;\n\t\t\tif (min_sec_level > RXRPC_SECURITY_MAX)\n\t\t\t\tgoto error;\n\t\t\trx->min_sec_level = min_sec_level;\n\t\t\tgoto success;\n\n\t\tcase RXRPC_UPGRADEABLE_SERVICE:\n\t\t\tret = -EINVAL;\n\t\t\tif (optlen != sizeof(service_upgrade) ||\n\t\t\t    rx->service_upgrade.from != 0)\n\t\t\t\tgoto error;\n\t\t\tret = -EISCONN;\n\t\t\tif (rx->sk.sk_state != RXRPC_SERVER_BOUND2)\n\t\t\t\tgoto error;\n\t\t\tret = -EFAULT;\n\t\t\tif (copy_from_sockptr(service_upgrade, optval,\n\t\t\t\t\t   sizeof(service_upgrade)) != 0)\n\t\t\t\tgoto error;\n\t\t\tret = -EINVAL;\n\t\t\tif ((service_upgrade[0] != rx->srx.srx_service ||\n\t\t\t     service_upgrade[1] != rx->second_service) &&\n\t\t\t    (service_upgrade[0] != rx->second_service ||\n\t\t\t     service_upgrade[1] != rx->srx.srx_service))\n\t\t\t\tgoto error;\n\t\t\trx->service_upgrade.from = service_upgrade[0];\n\t\t\trx->service_upgrade.to = service_upgrade[1];\n\t\t\tgoto success;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nsuccess:\n\tret = 0;\nerror:\n\trelease_sock(&rx->sk);\n\treturn ret;\n}\n\n \nstatic int rxrpc_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t    char __user *optval, int __user *_optlen)\n{\n\tint optlen;\n\n\tif (level != SOL_RXRPC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (get_user(optlen, _optlen))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase RXRPC_SUPPORTED_CMSG:\n\t\tif (optlen < sizeof(int))\n\t\t\treturn -ETOOSMALL;\n\t\tif (put_user(RXRPC__SUPPORTED - 1, (int __user *)optval) ||\n\t\t    put_user(sizeof(int), _optlen))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic __poll_t rxrpc_poll(struct file *file, struct socket *sock,\n\t\t\t       poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rxrpc_sock *rx = rxrpc_sk(sk);\n\t__poll_t mask;\n\n\tsock_poll_wait(file, sock, wait);\n\tmask = 0;\n\n\t \n\tif (!list_empty(&rx->recvmsg_q))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\t \n\tif (rxrpc_writable(sk))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\n\treturn mask;\n}\n\n \nstatic int rxrpc_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct rxrpc_net *rxnet;\n\tstruct rxrpc_sock *rx;\n\tstruct sock *sk;\n\n\t_enter(\"%p,%d\", sock, protocol);\n\n\t \n\tif (protocol != PF_INET &&\n\t    IS_ENABLED(CONFIG_AF_RXRPC_IPV6) && protocol != PF_INET6)\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (sock->type != SOCK_DGRAM)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &rxrpc_rpc_ops;\n\tsock->state = SS_UNCONNECTED;\n\n\tsk = sk_alloc(net, PF_RXRPC, GFP_KERNEL, &rxrpc_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock_set_flag(sk, SOCK_RCU_FREE);\n\tsk->sk_state\t\t= RXRPC_UNBOUND;\n\tsk->sk_write_space\t= rxrpc_write_space;\n\tsk->sk_max_ack_backlog\t= 0;\n\tsk->sk_destruct\t\t= rxrpc_sock_destructor;\n\n\trx = rxrpc_sk(sk);\n\trx->family = protocol;\n\trx->calls = RB_ROOT;\n\n\tspin_lock_init(&rx->incoming_lock);\n\tINIT_LIST_HEAD(&rx->sock_calls);\n\tINIT_LIST_HEAD(&rx->to_be_accepted);\n\tINIT_LIST_HEAD(&rx->recvmsg_q);\n\tspin_lock_init(&rx->recvmsg_lock);\n\trwlock_init(&rx->call_lock);\n\tmemset(&rx->srx, 0, sizeof(rx->srx));\n\n\trxnet = rxrpc_net(sock_net(&rx->sk));\n\ttimer_reduce(&rxnet->peer_keepalive_timer, jiffies + 1);\n\n\t_leave(\" = 0 [%p]\", rx);\n\treturn 0;\n}\n\n \nstatic int rxrpc_shutdown(struct socket *sock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rxrpc_sock *rx = rxrpc_sk(sk);\n\tint ret = 0;\n\n\t_enter(\"%p,%d\", sk, flags);\n\n\tif (flags != SHUT_RDWR)\n\t\treturn -EOPNOTSUPP;\n\tif (sk->sk_state == RXRPC_CLOSE)\n\t\treturn -ESHUTDOWN;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state < RXRPC_CLOSE) {\n\t\tsk->sk_state = RXRPC_CLOSE;\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t} else {\n\t\tret = -ESHUTDOWN;\n\t}\n\n\trxrpc_discard_prealloc(rx);\n\n\trelease_sock(sk);\n\treturn ret;\n}\n\n \nstatic void rxrpc_sock_destructor(struct sock *sk)\n{\n\t_enter(\"%p\", sk);\n\n\trxrpc_purge_queue(&sk->sk_receive_queue);\n\n\tWARN_ON(refcount_read(&sk->sk_wmem_alloc));\n\tWARN_ON(!sk_unhashed(sk));\n\tWARN_ON(sk->sk_socket);\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tprintk(\"Attempt to release alive rxrpc socket: %p\\n\", sk);\n\t\treturn;\n\t}\n}\n\n \nstatic int rxrpc_release_sock(struct sock *sk)\n{\n\tstruct rxrpc_sock *rx = rxrpc_sk(sk);\n\n\t_enter(\"%p{%d,%d}\", sk, sk->sk_state, refcount_read(&sk->sk_refcnt));\n\n\t \n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\n\t \n\tswitch (sk->sk_state) {\n\tcase RXRPC_SERVER_BOUND:\n\tcase RXRPC_SERVER_BOUND2:\n\tcase RXRPC_SERVER_LISTENING:\n\tcase RXRPC_SERVER_LISTEN_DISABLED:\n\t\trx->local->service_closed = true;\n\t\tbreak;\n\t}\n\n\tsk->sk_state = RXRPC_CLOSE;\n\n\tif (rx->local && rx->local->service == rx) {\n\t\twrite_lock(&rx->local->services_lock);\n\t\trx->local->service = NULL;\n\t\twrite_unlock(&rx->local->services_lock);\n\t}\n\n\t \n\trxrpc_discard_prealloc(rx);\n\trxrpc_release_calls_on_socket(rx);\n\tflush_workqueue(rxrpc_workqueue);\n\trxrpc_purge_queue(&sk->sk_receive_queue);\n\n\trxrpc_unuse_local(rx->local, rxrpc_local_unuse_release_sock);\n\trxrpc_put_local(rx->local, rxrpc_local_put_release_sock);\n\trx->local = NULL;\n\tkey_put(rx->key);\n\trx->key = NULL;\n\tkey_put(rx->securities);\n\trx->securities = NULL;\n\tsock_put(sk);\n\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n \nstatic int rxrpc_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\t_enter(\"%p{%p}\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tsock->sk = NULL;\n\n\treturn rxrpc_release_sock(sk);\n}\n\n \nstatic const struct proto_ops rxrpc_rpc_ops = {\n\t.family\t\t= PF_RXRPC,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= rxrpc_release,\n\t.bind\t\t= rxrpc_bind,\n\t.connect\t= rxrpc_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.getname\t= sock_no_getname,\n\t.poll\t\t= rxrpc_poll,\n\t.ioctl\t\t= sock_no_ioctl,\n\t.listen\t\t= rxrpc_listen,\n\t.shutdown\t= rxrpc_shutdown,\n\t.setsockopt\t= rxrpc_setsockopt,\n\t.getsockopt\t= rxrpc_getsockopt,\n\t.sendmsg\t= rxrpc_sendmsg,\n\t.recvmsg\t= rxrpc_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n};\n\nstatic struct proto rxrpc_proto = {\n\t.name\t\t= \"RXRPC\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct rxrpc_sock),\n\t.max_header\t= sizeof(struct rxrpc_wire_header),\n};\n\nstatic const struct net_proto_family rxrpc_family_ops = {\n\t.family\t= PF_RXRPC,\n\t.create = rxrpc_create,\n\t.owner\t= THIS_MODULE,\n};\n\n \nstatic int __init af_rxrpc_init(void)\n{\n\tint ret = -1;\n\n\tBUILD_BUG_ON(sizeof(struct rxrpc_skb_priv) > sizeof_field(struct sk_buff, cb));\n\n\tret = -ENOMEM;\n\trxrpc_gen_version_string();\n\trxrpc_call_jar = kmem_cache_create(\n\t\t\"rxrpc_call_jar\", sizeof(struct rxrpc_call), 0,\n\t\tSLAB_HWCACHE_ALIGN, NULL);\n\tif (!rxrpc_call_jar) {\n\t\tpr_notice(\"Failed to allocate call jar\\n\");\n\t\tgoto error_call_jar;\n\t}\n\n\trxrpc_workqueue = alloc_ordered_workqueue(\"krxrpcd\", WQ_HIGHPRI | WQ_MEM_RECLAIM);\n\tif (!rxrpc_workqueue) {\n\t\tpr_notice(\"Failed to allocate work queue\\n\");\n\t\tgoto error_work_queue;\n\t}\n\n\tret = rxrpc_init_security();\n\tif (ret < 0) {\n\t\tpr_crit(\"Cannot initialise security\\n\");\n\t\tgoto error_security;\n\t}\n\n\tret = register_pernet_device(&rxrpc_net_ops);\n\tif (ret)\n\t\tgoto error_pernet;\n\n\tret = proto_register(&rxrpc_proto, 1);\n\tif (ret < 0) {\n\t\tpr_crit(\"Cannot register protocol\\n\");\n\t\tgoto error_proto;\n\t}\n\n\tret = sock_register(&rxrpc_family_ops);\n\tif (ret < 0) {\n\t\tpr_crit(\"Cannot register socket family\\n\");\n\t\tgoto error_sock;\n\t}\n\n\tret = register_key_type(&key_type_rxrpc);\n\tif (ret < 0) {\n\t\tpr_crit(\"Cannot register client key type\\n\");\n\t\tgoto error_key_type;\n\t}\n\n\tret = register_key_type(&key_type_rxrpc_s);\n\tif (ret < 0) {\n\t\tpr_crit(\"Cannot register server key type\\n\");\n\t\tgoto error_key_type_s;\n\t}\n\n\tret = rxrpc_sysctl_init();\n\tif (ret < 0) {\n\t\tpr_crit(\"Cannot register sysctls\\n\");\n\t\tgoto error_sysctls;\n\t}\n\n\treturn 0;\n\nerror_sysctls:\n\tunregister_key_type(&key_type_rxrpc_s);\nerror_key_type_s:\n\tunregister_key_type(&key_type_rxrpc);\nerror_key_type:\n\tsock_unregister(PF_RXRPC);\nerror_sock:\n\tproto_unregister(&rxrpc_proto);\nerror_proto:\n\tunregister_pernet_device(&rxrpc_net_ops);\nerror_pernet:\n\trxrpc_exit_security();\nerror_security:\n\tdestroy_workqueue(rxrpc_workqueue);\nerror_work_queue:\n\tkmem_cache_destroy(rxrpc_call_jar);\nerror_call_jar:\n\treturn ret;\n}\n\n \nstatic void __exit af_rxrpc_exit(void)\n{\n\t_enter(\"\");\n\trxrpc_sysctl_exit();\n\tunregister_key_type(&key_type_rxrpc_s);\n\tunregister_key_type(&key_type_rxrpc);\n\tsock_unregister(PF_RXRPC);\n\tproto_unregister(&rxrpc_proto);\n\tunregister_pernet_device(&rxrpc_net_ops);\n\tASSERTCMP(atomic_read(&rxrpc_n_rx_skbs), ==, 0);\n\n\t \n\trcu_barrier();\n\n\tdestroy_workqueue(rxrpc_workqueue);\n\trxrpc_exit_security();\n\tkmem_cache_destroy(rxrpc_call_jar);\n\t_leave(\"\");\n}\n\nmodule_init(af_rxrpc_init);\nmodule_exit(af_rxrpc_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}