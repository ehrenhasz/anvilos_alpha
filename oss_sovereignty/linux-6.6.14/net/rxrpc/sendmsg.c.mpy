{
  "module_name": "sendmsg.c",
  "hash_id": "28f9245b56e98d13cecff362d36ff047ac234ba3200857e83559d9ec0b6e7334",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/sendmsg.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/net.h>\n#include <linux/gfp.h>\n#include <linux/skbuff.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include \"ar-internal.h\"\n\n \nbool rxrpc_propose_abort(struct rxrpc_call *call, s32 abort_code, int error,\n\t\t\t enum rxrpc_abort_reason why)\n{\n\t_enter(\"{%d},%d,%d,%u\", call->debug_id, abort_code, error, why);\n\n\tif (!call->send_abort && !rxrpc_call_is_complete(call)) {\n\t\tcall->send_abort_why = why;\n\t\tcall->send_abort_err = error;\n\t\tcall->send_abort_seq = 0;\n\t\t \n\t\tsmp_store_release(&call->send_abort, abort_code);\n\t\trxrpc_poke_call(call, rxrpc_call_poke_abort);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic int rxrpc_wait_to_be_connected(struct rxrpc_call *call, long *timeo)\n{\n\tDECLARE_WAITQUEUE(myself, current);\n\tint ret = 0;\n\n\t_enter(\"%d\", call->debug_id);\n\n\tif (rxrpc_call_state(call) != RXRPC_CALL_CLIENT_AWAIT_CONN)\n\t\tgoto no_wait;\n\n\tadd_wait_queue_exclusive(&call->waitq, &myself);\n\n\tfor (;;) {\n\t\tswitch (call->interruptibility) {\n\t\tcase RXRPC_INTERRUPTIBLE:\n\t\tcase RXRPC_PREINTERRUPTIBLE:\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tbreak;\n\t\tcase RXRPC_UNINTERRUPTIBLE:\n\t\tdefault:\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rxrpc_call_state(call) != RXRPC_CALL_CLIENT_AWAIT_CONN)\n\t\t\tbreak;\n\t\tif ((call->interruptibility == RXRPC_INTERRUPTIBLE ||\n\t\t     call->interruptibility == RXRPC_PREINTERRUPTIBLE) &&\n\t\t    signal_pending(current)) {\n\t\t\tret = sock_intr_errno(*timeo);\n\t\t\tbreak;\n\t\t}\n\t\t*timeo = schedule_timeout(*timeo);\n\t}\n\n\tremove_wait_queue(&call->waitq, &myself);\n\t__set_current_state(TASK_RUNNING);\n\nno_wait:\n\tif (ret == 0 && rxrpc_call_is_complete(call))\n\t\tret = call->error;\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstatic bool rxrpc_check_tx_space(struct rxrpc_call *call, rxrpc_seq_t *_tx_win)\n{\n\tif (_tx_win)\n\t\t*_tx_win = call->tx_bottom;\n\treturn call->tx_prepared - call->tx_bottom < 256;\n}\n\n \nstatic int rxrpc_wait_for_tx_window_intr(struct rxrpc_sock *rx,\n\t\t\t\t\t struct rxrpc_call *call,\n\t\t\t\t\t long *timeo)\n{\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (rxrpc_check_tx_space(call, NULL))\n\t\t\treturn 0;\n\n\t\tif (rxrpc_call_is_complete(call))\n\t\t\treturn call->error;\n\n\t\tif (signal_pending(current))\n\t\t\treturn sock_intr_errno(*timeo);\n\n\t\ttrace_rxrpc_txqueue(call, rxrpc_txqueue_wait);\n\t\t*timeo = schedule_timeout(*timeo);\n\t}\n}\n\n \nstatic int rxrpc_wait_for_tx_window_waitall(struct rxrpc_sock *rx,\n\t\t\t\t\t    struct rxrpc_call *call)\n{\n\trxrpc_seq_t tx_start, tx_win;\n\tsigned long rtt, timeout;\n\n\trtt = READ_ONCE(call->peer->srtt_us) >> 3;\n\trtt = usecs_to_jiffies(rtt) * 2;\n\tif (rtt < 2)\n\t\trtt = 2;\n\n\ttimeout = rtt;\n\ttx_start = smp_load_acquire(&call->acks_hard_ack);\n\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\tif (rxrpc_check_tx_space(call, &tx_win))\n\t\t\treturn 0;\n\n\t\tif (rxrpc_call_is_complete(call))\n\t\t\treturn call->error;\n\n\t\tif (timeout == 0 &&\n\t\t    tx_win == tx_start && signal_pending(current))\n\t\t\treturn -EINTR;\n\n\t\tif (tx_win != tx_start) {\n\t\t\ttimeout = rtt;\n\t\t\ttx_start = tx_win;\n\t\t}\n\n\t\ttrace_rxrpc_txqueue(call, rxrpc_txqueue_wait);\n\t\ttimeout = schedule_timeout(timeout);\n\t}\n}\n\n \nstatic int rxrpc_wait_for_tx_window_nonintr(struct rxrpc_sock *rx,\n\t\t\t\t\t    struct rxrpc_call *call,\n\t\t\t\t\t    long *timeo)\n{\n\tfor (;;) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (rxrpc_check_tx_space(call, NULL))\n\t\t\treturn 0;\n\n\t\tif (rxrpc_call_is_complete(call))\n\t\t\treturn call->error;\n\n\t\ttrace_rxrpc_txqueue(call, rxrpc_txqueue_wait);\n\t\t*timeo = schedule_timeout(*timeo);\n\t}\n}\n\n \nstatic int rxrpc_wait_for_tx_window(struct rxrpc_sock *rx,\n\t\t\t\t    struct rxrpc_call *call,\n\t\t\t\t    long *timeo,\n\t\t\t\t    bool waitall)\n{\n\tDECLARE_WAITQUEUE(myself, current);\n\tint ret;\n\n\t_enter(\",{%u,%u,%u,%u}\",\n\t       call->tx_bottom, call->acks_hard_ack, call->tx_top, call->tx_winsize);\n\n\tadd_wait_queue(&call->waitq, &myself);\n\n\tswitch (call->interruptibility) {\n\tcase RXRPC_INTERRUPTIBLE:\n\t\tif (waitall)\n\t\t\tret = rxrpc_wait_for_tx_window_waitall(rx, call);\n\t\telse\n\t\t\tret = rxrpc_wait_for_tx_window_intr(rx, call, timeo);\n\t\tbreak;\n\tcase RXRPC_PREINTERRUPTIBLE:\n\tcase RXRPC_UNINTERRUPTIBLE:\n\tdefault:\n\t\tret = rxrpc_wait_for_tx_window_nonintr(rx, call, timeo);\n\t\tbreak;\n\t}\n\n\tremove_wait_queue(&call->waitq, &myself);\n\tset_current_state(TASK_RUNNING);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstatic void rxrpc_notify_end_tx(struct rxrpc_sock *rx, struct rxrpc_call *call,\n\t\t\t\trxrpc_notify_end_tx_t notify_end_tx)\n{\n\tif (notify_end_tx)\n\t\tnotify_end_tx(&rx->sk, call, call->user_call_ID);\n}\n\n \nstatic void rxrpc_queue_packet(struct rxrpc_sock *rx, struct rxrpc_call *call,\n\t\t\t       struct rxrpc_txbuf *txb,\n\t\t\t       rxrpc_notify_end_tx_t notify_end_tx)\n{\n\trxrpc_seq_t seq = txb->seq;\n\tbool last = test_bit(RXRPC_TXBUF_LAST, &txb->flags), poke;\n\n\trxrpc_inc_stat(call->rxnet, stat_tx_data);\n\n\tASSERTCMP(txb->seq, ==, call->tx_prepared + 1);\n\n\t \n\ttxb->last_sent = ktime_get_real();\n\n\tif (last)\n\t\ttrace_rxrpc_txqueue(call, rxrpc_txqueue_queue_last);\n\telse\n\t\ttrace_rxrpc_txqueue(call, rxrpc_txqueue_queue);\n\n\t \n\tspin_lock(&call->tx_lock);\n\tpoke = list_empty(&call->tx_sendmsg);\n\tlist_add_tail(&txb->call_link, &call->tx_sendmsg);\n\tcall->tx_prepared = seq;\n\tif (last)\n\t\trxrpc_notify_end_tx(rx, call, notify_end_tx);\n\tspin_unlock(&call->tx_lock);\n\n\tif (poke)\n\t\trxrpc_poke_call(call, rxrpc_call_poke_start);\n}\n\n \nstatic int rxrpc_send_data(struct rxrpc_sock *rx,\n\t\t\t   struct rxrpc_call *call,\n\t\t\t   struct msghdr *msg, size_t len,\n\t\t\t   rxrpc_notify_end_tx_t notify_end_tx,\n\t\t\t   bool *_dropped_lock)\n{\n\tstruct rxrpc_txbuf *txb;\n\tstruct sock *sk = &rx->sk;\n\tenum rxrpc_call_state state;\n\tlong timeo;\n\tbool more = msg->msg_flags & MSG_MORE;\n\tint ret, copied = 0;\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\n\tret = rxrpc_wait_to_be_connected(call, &timeo);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (call->conn->state == RXRPC_CONN_CLIENT_UNSECURED) {\n\t\tret = rxrpc_init_client_conn_security(call->conn);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tsk_clear_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\nreload:\n\tret = -EPIPE;\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto maybe_error;\n\tstate = rxrpc_call_state(call);\n\tret = -ESHUTDOWN;\n\tif (state >= RXRPC_CALL_COMPLETE)\n\t\tgoto maybe_error;\n\tret = -EPROTO;\n\tif (state != RXRPC_CALL_CLIENT_SEND_REQUEST &&\n\t    state != RXRPC_CALL_SERVER_ACK_REQUEST &&\n\t    state != RXRPC_CALL_SERVER_SEND_REPLY) {\n\t\t \n\t\ttrace_rxrpc_abort(call->debug_id, rxrpc_sendmsg_late_send,\n\t\t\t\t  call->cid, call->call_id, call->rx_consumed,\n\t\t\t\t  0, -EPROTO);\n\t\tgoto maybe_error;\n\t}\n\n\tret = -EMSGSIZE;\n\tif (call->tx_total_len != -1) {\n\t\tif (len - copied > call->tx_total_len)\n\t\t\tgoto maybe_error;\n\t\tif (!more && len - copied != call->tx_total_len)\n\t\t\tgoto maybe_error;\n\t}\n\n\ttxb = call->tx_pending;\n\tcall->tx_pending = NULL;\n\tif (txb)\n\t\trxrpc_see_txbuf(txb, rxrpc_txbuf_see_send_more);\n\n\tdo {\n\t\tif (!txb) {\n\t\t\tsize_t remain, bufsize, chunk, offset;\n\n\t\t\t_debug(\"alloc\");\n\n\t\t\tif (!rxrpc_check_tx_space(call, NULL))\n\t\t\t\tgoto wait_for_space;\n\n\t\t\t \n\t\t\tremain = more ? INT_MAX : msg_data_left(msg);\n\t\t\tret = call->conn->security->how_much_data(call, remain,\n\t\t\t\t\t\t\t\t  &bufsize, &chunk, &offset);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto maybe_error;\n\n\t\t\t_debug(\"SIZE: %zu/%zu @%zu\", chunk, bufsize, offset);\n\n\t\t\t \n\t\t\tret = -ENOMEM;\n\t\t\ttxb = rxrpc_alloc_txbuf(call, RXRPC_PACKET_TYPE_DATA,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!txb)\n\t\t\t\tgoto maybe_error;\n\n\t\t\ttxb->offset = offset;\n\t\t\ttxb->space -= offset;\n\t\t\ttxb->space = min_t(size_t, chunk, txb->space);\n\t\t}\n\n\t\t_debug(\"append\");\n\n\t\t \n\t\tif (msg_data_left(msg) > 0) {\n\t\t\tsize_t copy = min_t(size_t, txb->space, msg_data_left(msg));\n\n\t\t\t_debug(\"add %zu\", copy);\n\t\t\tif (!copy_from_iter_full(txb->data + txb->offset, copy,\n\t\t\t\t\t\t &msg->msg_iter))\n\t\t\t\tgoto efault;\n\t\t\t_debug(\"added\");\n\t\t\ttxb->space -= copy;\n\t\t\ttxb->len += copy;\n\t\t\ttxb->offset += copy;\n\t\t\tcopied += copy;\n\t\t\tif (call->tx_total_len != -1)\n\t\t\t\tcall->tx_total_len -= copy;\n\t\t}\n\n\t\t \n\t\tif (rxrpc_call_is_complete(call))\n\t\t\tgoto call_terminated;\n\n\t\t \n\t\tif (!txb->space ||\n\t\t    (msg_data_left(msg) == 0 && !more)) {\n\t\t\tif (msg_data_left(msg) == 0 && !more) {\n\t\t\t\ttxb->wire.flags |= RXRPC_LAST_PACKET;\n\t\t\t\t__set_bit(RXRPC_TXBUF_LAST, &txb->flags);\n\t\t\t}\n\t\t\telse if (call->tx_top - call->acks_hard_ack <\n\t\t\t\t call->tx_winsize)\n\t\t\t\ttxb->wire.flags |= RXRPC_MORE_PACKETS;\n\n\t\t\tret = call->security->secure_packet(call, txb);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\trxrpc_queue_packet(rx, call, txb, notify_end_tx);\n\t\t\ttxb = NULL;\n\t\t}\n\t} while (msg_data_left(msg) > 0);\n\nsuccess:\n\tret = copied;\n\tif (rxrpc_call_is_complete(call) &&\n\t    call->error < 0)\n\t\tret = call->error;\nout:\n\tcall->tx_pending = txb;\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\ncall_terminated:\n\trxrpc_put_txbuf(txb, rxrpc_txbuf_put_send_aborted);\n\t_leave(\" = %d\", call->error);\n\treturn call->error;\n\nmaybe_error:\n\tif (copied)\n\t\tgoto success;\n\tgoto out;\n\nefault:\n\tret = -EFAULT;\n\tgoto out;\n\nwait_for_space:\n\tret = -EAGAIN;\n\tif (msg->msg_flags & MSG_DONTWAIT)\n\t\tgoto maybe_error;\n\tmutex_unlock(&call->user_mutex);\n\t*_dropped_lock = true;\n\tret = rxrpc_wait_for_tx_window(rx, call, &timeo,\n\t\t\t\t       msg->msg_flags & MSG_WAITALL);\n\tif (ret < 0)\n\t\tgoto maybe_error;\n\tif (call->interruptibility == RXRPC_INTERRUPTIBLE) {\n\t\tif (mutex_lock_interruptible(&call->user_mutex) < 0) {\n\t\t\tret = sock_intr_errno(timeo);\n\t\t\tgoto maybe_error;\n\t\t}\n\t} else {\n\t\tmutex_lock(&call->user_mutex);\n\t}\n\t*_dropped_lock = false;\n\tgoto reload;\n}\n\n \nstatic int rxrpc_sendmsg_cmsg(struct msghdr *msg, struct rxrpc_send_params *p)\n{\n\tstruct cmsghdr *cmsg;\n\tbool got_user_ID = false;\n\tint len;\n\n\tif (msg->msg_controllen == 0)\n\t\treturn -EINVAL;\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\tif (!CMSG_OK(msg, cmsg))\n\t\t\treturn -EINVAL;\n\n\t\tlen = cmsg->cmsg_len - sizeof(struct cmsghdr);\n\t\t_debug(\"CMSG %d, %d, %d\",\n\t\t       cmsg->cmsg_level, cmsg->cmsg_type, len);\n\n\t\tif (cmsg->cmsg_level != SOL_RXRPC)\n\t\t\tcontinue;\n\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase RXRPC_USER_CALL_ID:\n\t\t\tif (msg->msg_flags & MSG_CMSG_COMPAT) {\n\t\t\t\tif (len != sizeof(u32))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tp->call.user_call_ID = *(u32 *)CMSG_DATA(cmsg);\n\t\t\t} else {\n\t\t\t\tif (len != sizeof(unsigned long))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tp->call.user_call_ID = *(unsigned long *)\n\t\t\t\t\tCMSG_DATA(cmsg);\n\t\t\t}\n\t\t\tgot_user_ID = true;\n\t\t\tbreak;\n\n\t\tcase RXRPC_ABORT:\n\t\t\tif (p->command != RXRPC_CMD_SEND_DATA)\n\t\t\t\treturn -EINVAL;\n\t\t\tp->command = RXRPC_CMD_SEND_ABORT;\n\t\t\tif (len != sizeof(p->abort_code))\n\t\t\t\treturn -EINVAL;\n\t\t\tp->abort_code = *(unsigned int *)CMSG_DATA(cmsg);\n\t\t\tif (p->abort_code == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase RXRPC_CHARGE_ACCEPT:\n\t\t\tif (p->command != RXRPC_CMD_SEND_DATA)\n\t\t\t\treturn -EINVAL;\n\t\t\tp->command = RXRPC_CMD_CHARGE_ACCEPT;\n\t\t\tif (len != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase RXRPC_EXCLUSIVE_CALL:\n\t\t\tp->exclusive = true;\n\t\t\tif (len != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase RXRPC_UPGRADE_SERVICE:\n\t\t\tp->upgrade = true;\n\t\t\tif (len != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase RXRPC_TX_LENGTH:\n\t\t\tif (p->call.tx_total_len != -1 || len != sizeof(__s64))\n\t\t\t\treturn -EINVAL;\n\t\t\tp->call.tx_total_len = *(__s64 *)CMSG_DATA(cmsg);\n\t\t\tif (p->call.tx_total_len < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase RXRPC_SET_CALL_TIMEOUT:\n\t\t\tif (len & 3 || len < 4 || len > 12)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemcpy(&p->call.timeouts, CMSG_DATA(cmsg), len);\n\t\t\tp->call.nr_timeouts = len / 4;\n\t\t\tif (p->call.timeouts.hard > INT_MAX / HZ)\n\t\t\t\treturn -ERANGE;\n\t\t\tif (p->call.nr_timeouts >= 2 && p->call.timeouts.idle > 60 * 60 * 1000)\n\t\t\t\treturn -ERANGE;\n\t\t\tif (p->call.nr_timeouts >= 3 && p->call.timeouts.normal > 60 * 60 * 1000)\n\t\t\t\treturn -ERANGE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!got_user_ID)\n\t\treturn -EINVAL;\n\tif (p->call.tx_total_len != -1 && p->command != RXRPC_CMD_SEND_DATA)\n\t\treturn -EINVAL;\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n \nstatic struct rxrpc_call *\nrxrpc_new_client_call_for_sendmsg(struct rxrpc_sock *rx, struct msghdr *msg,\n\t\t\t\t  struct rxrpc_send_params *p)\n\t__releases(&rx->sk.sk_lock.slock)\n\t__acquires(&call->user_mutex)\n{\n\tstruct rxrpc_conn_parameters cp;\n\tstruct rxrpc_call *call;\n\tstruct key *key;\n\n\tDECLARE_SOCKADDR(struct sockaddr_rxrpc *, srx, msg->msg_name);\n\n\t_enter(\"\");\n\n\tif (!msg->msg_name) {\n\t\trelease_sock(&rx->sk);\n\t\treturn ERR_PTR(-EDESTADDRREQ);\n\t}\n\n\tkey = rx->key;\n\tif (key && !rx->key->payload.data[0])\n\t\tkey = NULL;\n\n\tmemset(&cp, 0, sizeof(cp));\n\tcp.local\t\t= rx->local;\n\tcp.key\t\t\t= rx->key;\n\tcp.security_level\t= rx->min_sec_level;\n\tcp.exclusive\t\t= rx->exclusive | p->exclusive;\n\tcp.upgrade\t\t= p->upgrade;\n\tcp.service_id\t\t= srx->srx_service;\n\tcall = rxrpc_new_client_call(rx, &cp, srx, &p->call, GFP_KERNEL,\n\t\t\t\t     atomic_inc_return(&rxrpc_debug_id));\n\t \n\n\t_leave(\" = %p\\n\", call);\n\treturn call;\n}\n\n \nint rxrpc_do_sendmsg(struct rxrpc_sock *rx, struct msghdr *msg, size_t len)\n\t__releases(&rx->sk.sk_lock.slock)\n{\n\tstruct rxrpc_call *call;\n\tunsigned long now, j;\n\tbool dropped_lock = false;\n\tint ret;\n\n\tstruct rxrpc_send_params p = {\n\t\t.call.tx_total_len\t= -1,\n\t\t.call.user_call_ID\t= 0,\n\t\t.call.nr_timeouts\t= 0,\n\t\t.call.interruptibility\t= RXRPC_INTERRUPTIBLE,\n\t\t.abort_code\t\t= 0,\n\t\t.command\t\t= RXRPC_CMD_SEND_DATA,\n\t\t.exclusive\t\t= false,\n\t\t.upgrade\t\t= false,\n\t};\n\n\t_enter(\"\");\n\n\tret = rxrpc_sendmsg_cmsg(msg, &p);\n\tif (ret < 0)\n\t\tgoto error_release_sock;\n\n\tif (p.command == RXRPC_CMD_CHARGE_ACCEPT) {\n\t\tret = -EINVAL;\n\t\tif (rx->sk.sk_state != RXRPC_SERVER_LISTENING)\n\t\t\tgoto error_release_sock;\n\t\tret = rxrpc_user_charge_accept(rx, p.call.user_call_ID);\n\t\tgoto error_release_sock;\n\t}\n\n\tcall = rxrpc_find_call_by_user_ID(rx, p.call.user_call_ID);\n\tif (!call) {\n\t\tret = -EBADSLT;\n\t\tif (p.command != RXRPC_CMD_SEND_DATA)\n\t\t\tgoto error_release_sock;\n\t\tcall = rxrpc_new_client_call_for_sendmsg(rx, msg, &p);\n\t\t \n\t\tif (IS_ERR(call))\n\t\t\treturn PTR_ERR(call);\n\t\t \n\t\tp.call.nr_timeouts = 0;\n\t\tret = 0;\n\t\tif (rxrpc_call_is_complete(call))\n\t\t\tgoto out_put_unlock;\n\t} else {\n\t\tswitch (rxrpc_call_state(call)) {\n\t\tcase RXRPC_CALL_CLIENT_AWAIT_CONN:\n\t\tcase RXRPC_CALL_SERVER_SECURING:\n\t\t\tif (p.command == RXRPC_CMD_SEND_ABORT)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase RXRPC_CALL_UNINITIALISED:\n\t\tcase RXRPC_CALL_SERVER_PREALLOC:\n\t\t\trxrpc_put_call(call, rxrpc_call_put_sendmsg);\n\t\t\tret = -EBUSY;\n\t\t\tgoto error_release_sock;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tret = mutex_lock_interruptible(&call->user_mutex);\n\t\trelease_sock(&rx->sk);\n\t\tif (ret < 0) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tif (p.call.tx_total_len != -1) {\n\t\t\tret = -EINVAL;\n\t\t\tif (call->tx_total_len != -1 ||\n\t\t\t    call->tx_pending ||\n\t\t\t    call->tx_top != 0)\n\t\t\t\tgoto out_put_unlock;\n\t\t\tcall->tx_total_len = p.call.tx_total_len;\n\t\t}\n\t}\n\n\tswitch (p.call.nr_timeouts) {\n\tcase 3:\n\t\tj = msecs_to_jiffies(p.call.timeouts.normal);\n\t\tif (p.call.timeouts.normal > 0 && j == 0)\n\t\t\tj = 1;\n\t\tWRITE_ONCE(call->next_rx_timo, j);\n\t\tfallthrough;\n\tcase 2:\n\t\tj = msecs_to_jiffies(p.call.timeouts.idle);\n\t\tif (p.call.timeouts.idle > 0 && j == 0)\n\t\t\tj = 1;\n\t\tWRITE_ONCE(call->next_req_timo, j);\n\t\tfallthrough;\n\tcase 1:\n\t\tif (p.call.timeouts.hard > 0) {\n\t\t\tj = p.call.timeouts.hard * HZ;\n\t\t\tnow = jiffies;\n\t\t\tj += now;\n\t\t\tWRITE_ONCE(call->expect_term_by, j);\n\t\t\trxrpc_reduce_call_timer(call, j, now,\n\t\t\t\t\t\trxrpc_timer_set_for_hard);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (rxrpc_call_is_complete(call)) {\n\t\t \n\t\tret = -ESHUTDOWN;\n\t} else if (p.command == RXRPC_CMD_SEND_ABORT) {\n\t\trxrpc_propose_abort(call, p.abort_code, -ECONNABORTED,\n\t\t\t\t    rxrpc_abort_call_sendmsg);\n\t\tret = 0;\n\t} else if (p.command != RXRPC_CMD_SEND_DATA) {\n\t\tret = -EINVAL;\n\t} else {\n\t\tret = rxrpc_send_data(rx, call, msg, len, NULL, &dropped_lock);\n\t}\n\nout_put_unlock:\n\tif (!dropped_lock)\n\t\tmutex_unlock(&call->user_mutex);\nerror_put:\n\trxrpc_put_call(call, rxrpc_call_put_sendmsg);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\nerror_release_sock:\n\trelease_sock(&rx->sk);\n\treturn ret;\n}\n\n \nint rxrpc_kernel_send_data(struct socket *sock, struct rxrpc_call *call,\n\t\t\t   struct msghdr *msg, size_t len,\n\t\t\t   rxrpc_notify_end_tx_t notify_end_tx)\n{\n\tbool dropped_lock = false;\n\tint ret;\n\n\t_enter(\"{%d},\", call->debug_id);\n\n\tASSERTCMP(msg->msg_name, ==, NULL);\n\tASSERTCMP(msg->msg_control, ==, NULL);\n\n\tmutex_lock(&call->user_mutex);\n\n\tret = rxrpc_send_data(rxrpc_sk(sock->sk), call, msg, len,\n\t\t\t      notify_end_tx, &dropped_lock);\n\tif (ret == -ESHUTDOWN)\n\t\tret = call->error;\n\n\tif (!dropped_lock)\n\t\tmutex_unlock(&call->user_mutex);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(rxrpc_kernel_send_data);\n\n \nbool rxrpc_kernel_abort_call(struct socket *sock, struct rxrpc_call *call,\n\t\t\t     u32 abort_code, int error, enum rxrpc_abort_reason why)\n{\n\tbool aborted;\n\n\t_enter(\"{%d},%d,%d,%u\", call->debug_id, abort_code, error, why);\n\n\tmutex_lock(&call->user_mutex);\n\taborted = rxrpc_propose_abort(call, abort_code, error, why);\n\tmutex_unlock(&call->user_mutex);\n\treturn aborted;\n}\nEXPORT_SYMBOL(rxrpc_kernel_abort_call);\n\n \nvoid rxrpc_kernel_set_tx_length(struct socket *sock, struct rxrpc_call *call,\n\t\t\t\ts64 tx_total_len)\n{\n\tWARN_ON(call->tx_total_len != -1);\n\tcall->tx_total_len = tx_total_len;\n}\nEXPORT_SYMBOL(rxrpc_kernel_set_tx_length);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}