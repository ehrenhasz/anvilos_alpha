{
  "module_name": "rxkad.c",
  "hash_id": "bae26d2b38f264c8494f1b5375c5755168913ac931330fae8cbfbfe73217b7d3",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/rxkad.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <crypto/skcipher.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/udp.h>\n#include <linux/scatterlist.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/key-type.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include <keys/rxrpc-type.h>\n#include \"ar-internal.h\"\n\n#define RXKAD_VERSION\t\t\t2\n#define MAXKRB5TICKETLEN\t\t1024\n#define RXKAD_TKT_TYPE_KERBEROS_V5\t256\n#define ANAME_SZ\t\t\t40\t \n#define INST_SZ\t\t\t\t40\t \n#define REALM_SZ\t\t\t40\t \n#define SNAME_SZ\t\t\t40\t \n#define RXKAD_ALIGN\t\t\t8\n\nstruct rxkad_level1_hdr {\n\t__be32\tdata_size;\t \n};\n\nstruct rxkad_level2_hdr {\n\t__be32\tdata_size;\t \n\t__be32\tchecksum;\t \n};\n\nstatic int rxkad_prime_packet_security(struct rxrpc_connection *conn,\n\t\t\t\t       struct crypto_sync_skcipher *ci);\n\n \nstatic struct crypto_sync_skcipher *rxkad_ci;\nstatic struct skcipher_request *rxkad_ci_req;\nstatic DEFINE_MUTEX(rxkad_ci_mutex);\n\n \nstatic int rxkad_preparse_server_key(struct key_preparsed_payload *prep)\n{\n\tstruct crypto_skcipher *ci;\n\n\tif (prep->datalen != 8)\n\t\treturn -EINVAL;\n\n\tmemcpy(&prep->payload.data[2], prep->data, 8);\n\n\tci = crypto_alloc_skcipher(\"pcbc(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(ci)) {\n\t\t_leave(\" = %ld\", PTR_ERR(ci));\n\t\treturn PTR_ERR(ci);\n\t}\n\n\tif (crypto_skcipher_setkey(ci, prep->data, 8) < 0)\n\t\tBUG();\n\n\tprep->payload.data[0] = ci;\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\nstatic void rxkad_free_preparse_server_key(struct key_preparsed_payload *prep)\n{\n\n\tif (prep->payload.data[0])\n\t\tcrypto_free_skcipher(prep->payload.data[0]);\n}\n\nstatic void rxkad_destroy_server_key(struct key *key)\n{\n\tif (key->payload.data[0]) {\n\t\tcrypto_free_skcipher(key->payload.data[0]);\n\t\tkey->payload.data[0] = NULL;\n\t}\n}\n\n \nstatic int rxkad_init_connection_security(struct rxrpc_connection *conn,\n\t\t\t\t\t  struct rxrpc_key_token *token)\n{\n\tstruct crypto_sync_skcipher *ci;\n\tint ret;\n\n\t_enter(\"{%d},{%x}\", conn->debug_id, key_serial(conn->key));\n\n\tconn->security_ix = token->security_index;\n\n\tci = crypto_alloc_sync_skcipher(\"pcbc(fcrypt)\", 0, 0);\n\tif (IS_ERR(ci)) {\n\t\t_debug(\"no cipher\");\n\t\tret = PTR_ERR(ci);\n\t\tgoto error;\n\t}\n\n\tif (crypto_sync_skcipher_setkey(ci, token->kad->session_key,\n\t\t\t\t   sizeof(token->kad->session_key)) < 0)\n\t\tBUG();\n\n\tswitch (conn->security_level) {\n\tcase RXRPC_SECURITY_PLAIN:\n\tcase RXRPC_SECURITY_AUTH:\n\tcase RXRPC_SECURITY_ENCRYPT:\n\t\tbreak;\n\tdefault:\n\t\tret = -EKEYREJECTED;\n\t\tgoto error;\n\t}\n\n\tret = rxkad_prime_packet_security(conn, ci);\n\tif (ret < 0)\n\t\tgoto error_ci;\n\n\tconn->rxkad.cipher = ci;\n\treturn 0;\n\nerror_ci:\n\tcrypto_free_sync_skcipher(ci);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstatic int rxkad_how_much_data(struct rxrpc_call *call, size_t remain,\n\t\t\t       size_t *_buf_size, size_t *_data_size, size_t *_offset)\n{\n\tsize_t shdr, buf_size, chunk;\n\n\tswitch (call->conn->security_level) {\n\tdefault:\n\t\tbuf_size = chunk = min_t(size_t, remain, RXRPC_JUMBO_DATALEN);\n\t\tshdr = 0;\n\t\tgoto out;\n\tcase RXRPC_SECURITY_AUTH:\n\t\tshdr = sizeof(struct rxkad_level1_hdr);\n\t\tbreak;\n\tcase RXRPC_SECURITY_ENCRYPT:\n\t\tshdr = sizeof(struct rxkad_level2_hdr);\n\t\tbreak;\n\t}\n\n\tbuf_size = round_down(RXRPC_JUMBO_DATALEN, RXKAD_ALIGN);\n\n\tchunk = buf_size - shdr;\n\tif (remain < chunk)\n\t\tbuf_size = round_up(shdr + remain, RXKAD_ALIGN);\n\nout:\n\t*_buf_size = buf_size;\n\t*_data_size = chunk;\n\t*_offset = shdr;\n\treturn 0;\n}\n\n \nstatic int rxkad_prime_packet_security(struct rxrpc_connection *conn,\n\t\t\t\t       struct crypto_sync_skcipher *ci)\n{\n\tstruct skcipher_request *req;\n\tstruct rxrpc_key_token *token;\n\tstruct scatterlist sg;\n\tstruct rxrpc_crypt iv;\n\t__be32 *tmpbuf;\n\tsize_t tmpsize = 4 * sizeof(__be32);\n\n\t_enter(\"\");\n\n\tif (!conn->key)\n\t\treturn 0;\n\n\ttmpbuf = kmalloc(tmpsize, GFP_KERNEL);\n\tif (!tmpbuf)\n\t\treturn -ENOMEM;\n\n\treq = skcipher_request_alloc(&ci->base, GFP_NOFS);\n\tif (!req) {\n\t\tkfree(tmpbuf);\n\t\treturn -ENOMEM;\n\t}\n\n\ttoken = conn->key->payload.data[0];\n\tmemcpy(&iv, token->kad->session_key, sizeof(iv));\n\n\ttmpbuf[0] = htonl(conn->proto.epoch);\n\ttmpbuf[1] = htonl(conn->proto.cid);\n\ttmpbuf[2] = 0;\n\ttmpbuf[3] = htonl(conn->security_ix);\n\n\tsg_init_one(&sg, tmpbuf, tmpsize);\n\tskcipher_request_set_sync_tfm(req, ci);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sg, &sg, tmpsize, iv.x);\n\tcrypto_skcipher_encrypt(req);\n\tskcipher_request_free(req);\n\n\tmemcpy(&conn->rxkad.csum_iv, tmpbuf + 2, sizeof(conn->rxkad.csum_iv));\n\tkfree(tmpbuf);\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n \nstatic struct skcipher_request *rxkad_get_call_crypto(struct rxrpc_call *call)\n{\n\tstruct crypto_skcipher *tfm = &call->conn->rxkad.cipher->base;\n\n\treturn skcipher_request_alloc(tfm, GFP_NOFS);\n}\n\n \nstatic void rxkad_free_call_crypto(struct rxrpc_call *call)\n{\n}\n\n \nstatic int rxkad_secure_packet_auth(const struct rxrpc_call *call,\n\t\t\t\t    struct rxrpc_txbuf *txb,\n\t\t\t\t    struct skcipher_request *req)\n{\n\tstruct rxkad_level1_hdr *hdr = (void *)txb->data;\n\tstruct rxrpc_crypt iv;\n\tstruct scatterlist sg;\n\tsize_t pad;\n\tu16 check;\n\n\t_enter(\"\");\n\n\tcheck = txb->seq ^ ntohl(txb->wire.callNumber);\n\thdr->data_size = htonl((u32)check << 16 | txb->len);\n\n\ttxb->len += sizeof(struct rxkad_level1_hdr);\n\tpad = txb->len;\n\tpad = RXKAD_ALIGN - pad;\n\tpad &= RXKAD_ALIGN - 1;\n\tif (pad) {\n\t\tmemset(txb->data + txb->offset, 0, pad);\n\t\ttxb->len += pad;\n\t}\n\n\t \n\tmemset(&iv, 0, sizeof(iv));\n\n\tsg_init_one(&sg, txb->data, 8);\n\tskcipher_request_set_sync_tfm(req, call->conn->rxkad.cipher);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sg, &sg, 8, iv.x);\n\tcrypto_skcipher_encrypt(req);\n\tskcipher_request_zero(req);\n\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n \nstatic int rxkad_secure_packet_encrypt(const struct rxrpc_call *call,\n\t\t\t\t       struct rxrpc_txbuf *txb,\n\t\t\t\t       struct skcipher_request *req)\n{\n\tconst struct rxrpc_key_token *token;\n\tstruct rxkad_level2_hdr *rxkhdr = (void *)txb->data;\n\tstruct rxrpc_crypt iv;\n\tstruct scatterlist sg;\n\tsize_t pad;\n\tu16 check;\n\tint ret;\n\n\t_enter(\"\");\n\n\tcheck = txb->seq ^ ntohl(txb->wire.callNumber);\n\n\trxkhdr->data_size = htonl(txb->len | (u32)check << 16);\n\trxkhdr->checksum = 0;\n\n\ttxb->len += sizeof(struct rxkad_level2_hdr);\n\tpad = txb->len;\n\tpad = RXKAD_ALIGN - pad;\n\tpad &= RXKAD_ALIGN - 1;\n\tif (pad) {\n\t\tmemset(txb->data + txb->offset, 0, pad);\n\t\ttxb->len += pad;\n\t}\n\n\t \n\ttoken = call->conn->key->payload.data[0];\n\tmemcpy(&iv, token->kad->session_key, sizeof(iv));\n\n\tsg_init_one(&sg, txb->data, txb->len);\n\tskcipher_request_set_sync_tfm(req, call->conn->rxkad.cipher);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sg, &sg, txb->len, iv.x);\n\tret = crypto_skcipher_encrypt(req);\n\tskcipher_request_zero(req);\n\treturn ret;\n}\n\n \nstatic int rxkad_secure_packet(struct rxrpc_call *call, struct rxrpc_txbuf *txb)\n{\n\tstruct skcipher_request\t*req;\n\tstruct rxrpc_crypt iv;\n\tstruct scatterlist sg;\n\tunion {\n\t\t__be32 buf[2];\n\t} crypto __aligned(8);\n\tu32 x, y;\n\tint ret;\n\n\t_enter(\"{%d{%x}},{#%u},%u,\",\n\t       call->debug_id, key_serial(call->conn->key),\n\t       txb->seq, txb->len);\n\n\tif (!call->conn->rxkad.cipher)\n\t\treturn 0;\n\n\tret = key_validate(call->conn->key);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treq = rxkad_get_call_crypto(call);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(&iv, call->conn->rxkad.csum_iv.x, sizeof(iv));\n\n\t \n\tx = (ntohl(txb->wire.cid) & RXRPC_CHANNELMASK) << (32 - RXRPC_CIDSHIFT);\n\tx |= txb->seq & 0x3fffffff;\n\tcrypto.buf[0] = txb->wire.callNumber;\n\tcrypto.buf[1] = htonl(x);\n\n\tsg_init_one(&sg, crypto.buf, 8);\n\tskcipher_request_set_sync_tfm(req, call->conn->rxkad.cipher);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sg, &sg, 8, iv.x);\n\tcrypto_skcipher_encrypt(req);\n\tskcipher_request_zero(req);\n\n\ty = ntohl(crypto.buf[1]);\n\ty = (y >> 16) & 0xffff;\n\tif (y == 0)\n\t\ty = 1;  \n\ttxb->wire.cksum = htons(y);\n\n\tswitch (call->conn->security_level) {\n\tcase RXRPC_SECURITY_PLAIN:\n\t\tret = 0;\n\t\tbreak;\n\tcase RXRPC_SECURITY_AUTH:\n\t\tret = rxkad_secure_packet_auth(call, txb, req);\n\t\tbreak;\n\tcase RXRPC_SECURITY_ENCRYPT:\n\t\tret = rxkad_secure_packet_encrypt(call, txb, req);\n\t\tbreak;\n\tdefault:\n\t\tret = -EPERM;\n\t\tbreak;\n\t}\n\n\tskcipher_request_free(req);\n\t_leave(\" = %d [set %x]\", ret, y);\n\treturn ret;\n}\n\n \nstatic int rxkad_verify_packet_1(struct rxrpc_call *call, struct sk_buff *skb,\n\t\t\t\t rxrpc_seq_t seq,\n\t\t\t\t struct skcipher_request *req)\n{\n\tstruct rxkad_level1_hdr sechdr;\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tstruct rxrpc_crypt iv;\n\tstruct scatterlist sg[16];\n\tu32 data_size, buf;\n\tu16 check;\n\tint ret;\n\n\t_enter(\"\");\n\n\tif (sp->len < 8)\n\t\treturn rxrpc_abort_eproto(call, skb, RXKADSEALEDINCON,\n\t\t\t\t\t  rxkad_abort_1_short_header);\n\n\t \n\tsg_init_table(sg, ARRAY_SIZE(sg));\n\tret = skb_to_sgvec(skb, sg, sp->offset, 8);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\t \n\tmemset(&iv, 0, sizeof(iv));\n\n\tskcipher_request_set_sync_tfm(req, call->conn->rxkad.cipher);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, sg, sg, 8, iv.x);\n\tcrypto_skcipher_decrypt(req);\n\tskcipher_request_zero(req);\n\n\t \n\tif (skb_copy_bits(skb, sp->offset, &sechdr, sizeof(sechdr)) < 0)\n\t\treturn rxrpc_abort_eproto(call, skb, RXKADDATALEN,\n\t\t\t\t\t  rxkad_abort_1_short_encdata);\n\tsp->offset += sizeof(sechdr);\n\tsp->len    -= sizeof(sechdr);\n\n\tbuf = ntohl(sechdr.data_size);\n\tdata_size = buf & 0xffff;\n\n\tcheck = buf >> 16;\n\tcheck ^= seq ^ call->call_id;\n\tcheck &= 0xffff;\n\tif (check != 0)\n\t\treturn rxrpc_abort_eproto(call, skb, RXKADSEALEDINCON,\n\t\t\t\t\t  rxkad_abort_1_short_check);\n\tif (data_size > sp->len)\n\t\treturn rxrpc_abort_eproto(call, skb, RXKADDATALEN,\n\t\t\t\t\t  rxkad_abort_1_short_data);\n\tsp->len = data_size;\n\n\t_leave(\" = 0 [dlen=%x]\", data_size);\n\treturn 0;\n}\n\n \nstatic int rxkad_verify_packet_2(struct rxrpc_call *call, struct sk_buff *skb,\n\t\t\t\t rxrpc_seq_t seq,\n\t\t\t\t struct skcipher_request *req)\n{\n\tconst struct rxrpc_key_token *token;\n\tstruct rxkad_level2_hdr sechdr;\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tstruct rxrpc_crypt iv;\n\tstruct scatterlist _sg[4], *sg;\n\tu32 data_size, buf;\n\tu16 check;\n\tint nsg, ret;\n\n\t_enter(\",{%d}\", sp->len);\n\n\tif (sp->len < 8)\n\t\treturn rxrpc_abort_eproto(call, skb, RXKADSEALEDINCON,\n\t\t\t\t\t  rxkad_abort_2_short_header);\n\n\t \n\tsg = _sg;\n\tnsg = skb_shinfo(skb)->nr_frags + 1;\n\tif (nsg <= 4) {\n\t\tnsg = 4;\n\t} else {\n\t\tsg = kmalloc_array(nsg, sizeof(*sg), GFP_NOIO);\n\t\tif (!sg)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tsg_init_table(sg, nsg);\n\tret = skb_to_sgvec(skb, sg, sp->offset, sp->len);\n\tif (unlikely(ret < 0)) {\n\t\tif (sg != _sg)\n\t\t\tkfree(sg);\n\t\treturn ret;\n\t}\n\n\t \n\ttoken = call->conn->key->payload.data[0];\n\tmemcpy(&iv, token->kad->session_key, sizeof(iv));\n\n\tskcipher_request_set_sync_tfm(req, call->conn->rxkad.cipher);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, sg, sg, sp->len, iv.x);\n\tcrypto_skcipher_decrypt(req);\n\tskcipher_request_zero(req);\n\tif (sg != _sg)\n\t\tkfree(sg);\n\n\t \n\tif (skb_copy_bits(skb, sp->offset, &sechdr, sizeof(sechdr)) < 0)\n\t\treturn rxrpc_abort_eproto(call, skb, RXKADDATALEN,\n\t\t\t\t\t  rxkad_abort_2_short_len);\n\tsp->offset += sizeof(sechdr);\n\tsp->len    -= sizeof(sechdr);\n\n\tbuf = ntohl(sechdr.data_size);\n\tdata_size = buf & 0xffff;\n\n\tcheck = buf >> 16;\n\tcheck ^= seq ^ call->call_id;\n\tcheck &= 0xffff;\n\tif (check != 0)\n\t\treturn rxrpc_abort_eproto(call, skb, RXKADSEALEDINCON,\n\t\t\t\t\t  rxkad_abort_2_short_check);\n\n\tif (data_size > sp->len)\n\t\treturn rxrpc_abort_eproto(call, skb, RXKADDATALEN,\n\t\t\t\t\t  rxkad_abort_2_short_data);\n\n\tsp->len = data_size;\n\t_leave(\" = 0 [dlen=%x]\", data_size);\n\treturn 0;\n}\n\n \nstatic int rxkad_verify_packet(struct rxrpc_call *call, struct sk_buff *skb)\n{\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tstruct skcipher_request\t*req;\n\tstruct rxrpc_crypt iv;\n\tstruct scatterlist sg;\n\tunion {\n\t\t__be32 buf[2];\n\t} crypto __aligned(8);\n\trxrpc_seq_t seq = sp->hdr.seq;\n\tint ret;\n\tu16 cksum;\n\tu32 x, y;\n\n\t_enter(\"{%d{%x}},{#%u}\",\n\t       call->debug_id, key_serial(call->conn->key), seq);\n\n\tif (!call->conn->rxkad.cipher)\n\t\treturn 0;\n\n\treq = rxkad_get_call_crypto(call);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(&iv, call->conn->rxkad.csum_iv.x, sizeof(iv));\n\n\t \n\tx = (call->cid & RXRPC_CHANNELMASK) << (32 - RXRPC_CIDSHIFT);\n\tx |= seq & 0x3fffffff;\n\tcrypto.buf[0] = htonl(call->call_id);\n\tcrypto.buf[1] = htonl(x);\n\n\tsg_init_one(&sg, crypto.buf, 8);\n\tskcipher_request_set_sync_tfm(req, call->conn->rxkad.cipher);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sg, &sg, 8, iv.x);\n\tcrypto_skcipher_encrypt(req);\n\tskcipher_request_zero(req);\n\n\ty = ntohl(crypto.buf[1]);\n\tcksum = (y >> 16) & 0xffff;\n\tif (cksum == 0)\n\t\tcksum = 1;  \n\n\tif (cksum != sp->hdr.cksum) {\n\t\tret = rxrpc_abort_eproto(call, skb, RXKADSEALEDINCON,\n\t\t\t\t\t rxkad_abort_bad_checksum);\n\t\tgoto out;\n\t}\n\n\tswitch (call->conn->security_level) {\n\tcase RXRPC_SECURITY_PLAIN:\n\t\tret = 0;\n\t\tbreak;\n\tcase RXRPC_SECURITY_AUTH:\n\t\tret = rxkad_verify_packet_1(call, skb, seq, req);\n\t\tbreak;\n\tcase RXRPC_SECURITY_ENCRYPT:\n\t\tret = rxkad_verify_packet_2(call, skb, seq, req);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOANO;\n\t\tbreak;\n\t}\n\nout:\n\tskcipher_request_free(req);\n\treturn ret;\n}\n\n \nstatic int rxkad_issue_challenge(struct rxrpc_connection *conn)\n{\n\tstruct rxkad_challenge challenge;\n\tstruct rxrpc_wire_header whdr;\n\tstruct msghdr msg;\n\tstruct kvec iov[2];\n\tsize_t len;\n\tu32 serial;\n\tint ret;\n\n\t_enter(\"{%d}\", conn->debug_id);\n\n\tget_random_bytes(&conn->rxkad.nonce, sizeof(conn->rxkad.nonce));\n\n\tchallenge.version\t= htonl(2);\n\tchallenge.nonce\t\t= htonl(conn->rxkad.nonce);\n\tchallenge.min_level\t= htonl(0);\n\tchallenge.__padding\t= 0;\n\n\tmsg.msg_name\t= &conn->peer->srx.transport;\n\tmsg.msg_namelen\t= conn->peer->srx.transport_len;\n\tmsg.msg_control\t= NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags\t= 0;\n\n\twhdr.epoch\t= htonl(conn->proto.epoch);\n\twhdr.cid\t= htonl(conn->proto.cid);\n\twhdr.callNumber\t= 0;\n\twhdr.seq\t= 0;\n\twhdr.type\t= RXRPC_PACKET_TYPE_CHALLENGE;\n\twhdr.flags\t= conn->out_clientflag;\n\twhdr.userStatus\t= 0;\n\twhdr.securityIndex = conn->security_ix;\n\twhdr._rsvd\t= 0;\n\twhdr.serviceId\t= htons(conn->service_id);\n\n\tiov[0].iov_base\t= &whdr;\n\tiov[0].iov_len\t= sizeof(whdr);\n\tiov[1].iov_base\t= &challenge;\n\tiov[1].iov_len\t= sizeof(challenge);\n\n\tlen = iov[0].iov_len + iov[1].iov_len;\n\n\tserial = atomic_inc_return(&conn->serial);\n\twhdr.serial = htonl(serial);\n\n\tret = kernel_sendmsg(conn->local->socket, &msg, iov, 2, len);\n\tif (ret < 0) {\n\t\ttrace_rxrpc_tx_fail(conn->debug_id, serial, ret,\n\t\t\t\t    rxrpc_tx_point_rxkad_challenge);\n\t\treturn -EAGAIN;\n\t}\n\n\tconn->peer->last_tx_at = ktime_get_seconds();\n\ttrace_rxrpc_tx_packet(conn->debug_id, &whdr,\n\t\t\t      rxrpc_tx_point_rxkad_challenge);\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n \nstatic int rxkad_send_response(struct rxrpc_connection *conn,\n\t\t\t       struct rxrpc_host_header *hdr,\n\t\t\t       struct rxkad_response *resp,\n\t\t\t       const struct rxkad_key *s2)\n{\n\tstruct rxrpc_wire_header whdr;\n\tstruct msghdr msg;\n\tstruct kvec iov[3];\n\tsize_t len;\n\tu32 serial;\n\tint ret;\n\n\t_enter(\"\");\n\n\tmsg.msg_name\t= &conn->peer->srx.transport;\n\tmsg.msg_namelen\t= conn->peer->srx.transport_len;\n\tmsg.msg_control\t= NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_flags\t= 0;\n\n\tmemset(&whdr, 0, sizeof(whdr));\n\twhdr.epoch\t= htonl(hdr->epoch);\n\twhdr.cid\t= htonl(hdr->cid);\n\twhdr.type\t= RXRPC_PACKET_TYPE_RESPONSE;\n\twhdr.flags\t= conn->out_clientflag;\n\twhdr.securityIndex = hdr->securityIndex;\n\twhdr.serviceId\t= htons(hdr->serviceId);\n\n\tiov[0].iov_base\t= &whdr;\n\tiov[0].iov_len\t= sizeof(whdr);\n\tiov[1].iov_base\t= resp;\n\tiov[1].iov_len\t= sizeof(*resp);\n\tiov[2].iov_base\t= (void *)s2->ticket;\n\tiov[2].iov_len\t= s2->ticket_len;\n\n\tlen = iov[0].iov_len + iov[1].iov_len + iov[2].iov_len;\n\n\tserial = atomic_inc_return(&conn->serial);\n\twhdr.serial = htonl(serial);\n\n\trxrpc_local_dont_fragment(conn->local, false);\n\tret = kernel_sendmsg(conn->local->socket, &msg, iov, 3, len);\n\trxrpc_local_dont_fragment(conn->local, true);\n\tif (ret < 0) {\n\t\ttrace_rxrpc_tx_fail(conn->debug_id, serial, ret,\n\t\t\t\t    rxrpc_tx_point_rxkad_response);\n\t\treturn -EAGAIN;\n\t}\n\n\tconn->peer->last_tx_at = ktime_get_seconds();\n\t_leave(\" = 0\");\n\treturn 0;\n}\n\n \nstatic void rxkad_calc_response_checksum(struct rxkad_response *response)\n{\n\tu32 csum = 1000003;\n\tint loop;\n\tu8 *p = (u8 *) response;\n\n\tfor (loop = sizeof(*response); loop > 0; loop--)\n\t\tcsum = csum * 0x10204081 + *p++;\n\n\tresponse->encrypted.checksum = htonl(csum);\n}\n\n \nstatic int rxkad_encrypt_response(struct rxrpc_connection *conn,\n\t\t\t\t  struct rxkad_response *resp,\n\t\t\t\t  const struct rxkad_key *s2)\n{\n\tstruct skcipher_request *req;\n\tstruct rxrpc_crypt iv;\n\tstruct scatterlist sg[1];\n\n\treq = skcipher_request_alloc(&conn->rxkad.cipher->base, GFP_NOFS);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(&iv, s2->session_key, sizeof(iv));\n\n\tsg_init_table(sg, 1);\n\tsg_set_buf(sg, &resp->encrypted, sizeof(resp->encrypted));\n\tskcipher_request_set_sync_tfm(req, conn->rxkad.cipher);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, sg, sg, sizeof(resp->encrypted), iv.x);\n\tcrypto_skcipher_encrypt(req);\n\tskcipher_request_free(req);\n\treturn 0;\n}\n\n \nstatic int rxkad_respond_to_challenge(struct rxrpc_connection *conn,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tconst struct rxrpc_key_token *token;\n\tstruct rxkad_challenge challenge;\n\tstruct rxkad_response *resp;\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tu32 version, nonce, min_level;\n\tint ret = -EPROTO;\n\n\t_enter(\"{%d,%x}\", conn->debug_id, key_serial(conn->key));\n\n\tif (!conn->key)\n\t\treturn rxrpc_abort_conn(conn, skb, RX_PROTOCOL_ERROR, -EPROTO,\n\t\t\t\t\trxkad_abort_chall_no_key);\n\n\tret = key_validate(conn->key);\n\tif (ret < 0)\n\t\treturn rxrpc_abort_conn(conn, skb, RXKADEXPIRED, ret,\n\t\t\t\t\trxkad_abort_chall_key_expired);\n\n\tif (skb_copy_bits(skb, sizeof(struct rxrpc_wire_header),\n\t\t\t  &challenge, sizeof(challenge)) < 0)\n\t\treturn rxrpc_abort_conn(conn, skb, RXKADPACKETSHORT, -EPROTO,\n\t\t\t\t\trxkad_abort_chall_short);\n\n\tversion = ntohl(challenge.version);\n\tnonce = ntohl(challenge.nonce);\n\tmin_level = ntohl(challenge.min_level);\n\n\ttrace_rxrpc_rx_challenge(conn, sp->hdr.serial, version, nonce, min_level);\n\n\tif (version != RXKAD_VERSION)\n\t\treturn rxrpc_abort_conn(conn, skb, RXKADINCONSISTENCY, -EPROTO,\n\t\t\t\t\trxkad_abort_chall_version);\n\n\tif (conn->security_level < min_level)\n\t\treturn rxrpc_abort_conn(conn, skb, RXKADLEVELFAIL, -EACCES,\n\t\t\t\t\trxkad_abort_chall_level);\n\n\ttoken = conn->key->payload.data[0];\n\n\t \n\tresp = kzalloc(sizeof(struct rxkad_response), GFP_NOFS);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\tresp->version\t\t\t= htonl(RXKAD_VERSION);\n\tresp->encrypted.epoch\t\t= htonl(conn->proto.epoch);\n\tresp->encrypted.cid\t\t= htonl(conn->proto.cid);\n\tresp->encrypted.securityIndex\t= htonl(conn->security_ix);\n\tresp->encrypted.inc_nonce\t= htonl(nonce + 1);\n\tresp->encrypted.level\t\t= htonl(conn->security_level);\n\tresp->kvno\t\t\t= htonl(token->kad->kvno);\n\tresp->ticket_len\t\t= htonl(token->kad->ticket_len);\n\tresp->encrypted.call_id[0]\t= htonl(conn->channels[0].call_counter);\n\tresp->encrypted.call_id[1]\t= htonl(conn->channels[1].call_counter);\n\tresp->encrypted.call_id[2]\t= htonl(conn->channels[2].call_counter);\n\tresp->encrypted.call_id[3]\t= htonl(conn->channels[3].call_counter);\n\n\t \n\trxkad_calc_response_checksum(resp);\n\tret = rxkad_encrypt_response(conn, resp, token->kad);\n\tif (ret == 0)\n\t\tret = rxkad_send_response(conn, &sp->hdr, resp, token->kad);\n\tkfree(resp);\n\treturn ret;\n}\n\n \nstatic int rxkad_decrypt_ticket(struct rxrpc_connection *conn,\n\t\t\t\tstruct key *server_key,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tvoid *ticket, size_t ticket_len,\n\t\t\t\tstruct rxrpc_crypt *_session_key,\n\t\t\t\ttime64_t *_expiry)\n{\n\tstruct skcipher_request *req;\n\tstruct rxrpc_crypt iv, key;\n\tstruct scatterlist sg[1];\n\tstruct in_addr addr;\n\tunsigned int life;\n\ttime64_t issue, now;\n\tbool little_endian;\n\tu8 *p, *q, *name, *end;\n\n\t_enter(\"{%d},{%x}\", conn->debug_id, key_serial(server_key));\n\n\t*_expiry = 0;\n\n\tASSERT(server_key->payload.data[0] != NULL);\n\tASSERTCMP((unsigned long) ticket & 7UL, ==, 0);\n\n\tmemcpy(&iv, &server_key->payload.data[2], sizeof(iv));\n\n\treq = skcipher_request_alloc(server_key->payload.data[0], GFP_NOFS);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tsg_init_one(&sg[0], ticket, ticket_len);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, sg, sg, ticket_len, iv.x);\n\tcrypto_skcipher_decrypt(req);\n\tskcipher_request_free(req);\n\n\tp = ticket;\n\tend = p + ticket_len;\n\n#define Z(field, fieldl)\t\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tu8 *__str = p;\t\t\t\t\t\t\\\n\t\tq = memchr(p, 0, end - p);\t\t\t\t\\\n\t\tif (!q || q - p > field##_SZ)\t\t\t\t\\\n\t\t\treturn rxrpc_abort_conn(\t\t\t\\\n\t\t\t\tconn, skb, RXKADBADTICKET, -EPROTO,\t\\\n\t\t\t\trxkad_abort_resp_tkt_##fieldl);\t\t\\\n\t\tfor (; p < q; p++)\t\t\t\t\t\\\n\t\t\tif (!isprint(*p))\t\t\t\t\\\n\t\t\t\treturn rxrpc_abort_conn(\t\t\\\n\t\t\t\t\tconn, skb, RXKADBADTICKET, -EPROTO, \\\n\t\t\t\t\trxkad_abort_resp_tkt_##fieldl);\t\\\n\t\tp++;\t\t\t\t\t\t\t\\\n\t\t__str;\t\t\t\t\t\t\t\\\n\t})\n\n\t \n\t_debug(\"KIV FLAGS: %x\", *p);\n\tlittle_endian = *p & 1;\n\tp++;\n\n\t \n\tname = Z(ANAME, aname);\n\t_debug(\"KIV ANAME: %s\", name);\n\n\t \n\tname = Z(INST, inst);\n\t_debug(\"KIV INST : %s\", name);\n\n\t \n\tname = Z(REALM, realm);\n\t_debug(\"KIV REALM: %s\", name);\n\n\tif (end - p < 4 + 8 + 4 + 2)\n\t\treturn rxrpc_abort_conn(conn, skb, RXKADBADTICKET, -EPROTO,\n\t\t\t\t\trxkad_abort_resp_tkt_short);\n\n\t \n\tmemcpy(&addr, p, sizeof(addr));\n\tp += 4;\n\t_debug(\"KIV ADDR : %pI4\", &addr);\n\n\t \n\tmemcpy(&key, p, sizeof(key));\n\tp += 8;\n\t_debug(\"KIV KEY  : %08x %08x\", ntohl(key.n[0]), ntohl(key.n[1]));\n\tmemcpy(_session_key, &key, sizeof(key));\n\n\t \n\tlife = *p++ * 5 * 60;\n\t_debug(\"KIV LIFE : %u\", life);\n\n\t \n\tif (little_endian) {\n\t\t__le32 stamp;\n\t\tmemcpy(&stamp, p, 4);\n\t\tissue = rxrpc_u32_to_time64(le32_to_cpu(stamp));\n\t} else {\n\t\t__be32 stamp;\n\t\tmemcpy(&stamp, p, 4);\n\t\tissue = rxrpc_u32_to_time64(be32_to_cpu(stamp));\n\t}\n\tp += 4;\n\tnow = ktime_get_real_seconds();\n\t_debug(\"KIV ISSUE: %llx [%llx]\", issue, now);\n\n\t \n\tif (issue > now)\n\t\treturn rxrpc_abort_conn(conn, skb, RXKADNOAUTH, -EKEYREJECTED,\n\t\t\t\t\trxkad_abort_resp_tkt_future);\n\tif (issue < now - life)\n\t\treturn rxrpc_abort_conn(conn, skb, RXKADEXPIRED, -EKEYEXPIRED,\n\t\t\t\t\trxkad_abort_resp_tkt_expired);\n\n\t*_expiry = issue + life;\n\n\t \n\tname = Z(SNAME, sname);\n\t_debug(\"KIV SNAME: %s\", name);\n\n\t \n\tname = Z(INST, sinst);\n\t_debug(\"KIV SINST: %s\", name);\n\treturn 0;\n}\n\n \nstatic void rxkad_decrypt_response(struct rxrpc_connection *conn,\n\t\t\t\t   struct rxkad_response *resp,\n\t\t\t\t   const struct rxrpc_crypt *session_key)\n{\n\tstruct skcipher_request *req = rxkad_ci_req;\n\tstruct scatterlist sg[1];\n\tstruct rxrpc_crypt iv;\n\n\t_enter(\",,%08x%08x\",\n\t       ntohl(session_key->n[0]), ntohl(session_key->n[1]));\n\n\tmutex_lock(&rxkad_ci_mutex);\n\tif (crypto_sync_skcipher_setkey(rxkad_ci, session_key->x,\n\t\t\t\t\tsizeof(*session_key)) < 0)\n\t\tBUG();\n\n\tmemcpy(&iv, session_key, sizeof(iv));\n\n\tsg_init_table(sg, 1);\n\tsg_set_buf(sg, &resp->encrypted, sizeof(resp->encrypted));\n\tskcipher_request_set_sync_tfm(req, rxkad_ci);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, sg, sg, sizeof(resp->encrypted), iv.x);\n\tcrypto_skcipher_decrypt(req);\n\tskcipher_request_zero(req);\n\n\tmutex_unlock(&rxkad_ci_mutex);\n\n\t_leave(\"\");\n}\n\n \nstatic int rxkad_verify_response(struct rxrpc_connection *conn,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct rxkad_response *response;\n\tstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\n\tstruct rxrpc_crypt session_key;\n\tstruct key *server_key;\n\ttime64_t expiry;\n\tvoid *ticket;\n\tu32 version, kvno, ticket_len, level;\n\t__be32 csum;\n\tint ret, i;\n\n\t_enter(\"{%d}\", conn->debug_id);\n\n\tserver_key = rxrpc_look_up_server_security(conn, skb, 0, 0);\n\tif (IS_ERR(server_key)) {\n\t\tret = PTR_ERR(server_key);\n\t\tswitch (ret) {\n\t\tcase -ENOKEY:\n\t\t\treturn rxrpc_abort_conn(conn, skb, RXKADUNKNOWNKEY, ret,\n\t\t\t\t\t\trxkad_abort_resp_nokey);\n\t\tcase -EKEYEXPIRED:\n\t\t\treturn rxrpc_abort_conn(conn, skb, RXKADEXPIRED, ret,\n\t\t\t\t\t\trxkad_abort_resp_key_expired);\n\t\tdefault:\n\t\t\treturn rxrpc_abort_conn(conn, skb, RXKADNOAUTH, ret,\n\t\t\t\t\t\trxkad_abort_resp_key_rejected);\n\t\t}\n\t}\n\n\tret = -ENOMEM;\n\tresponse = kzalloc(sizeof(struct rxkad_response), GFP_NOFS);\n\tif (!response)\n\t\tgoto temporary_error;\n\n\tif (skb_copy_bits(skb, sizeof(struct rxrpc_wire_header),\n\t\t\t  response, sizeof(*response)) < 0) {\n\t\trxrpc_abort_conn(conn, skb, RXKADPACKETSHORT, -EPROTO,\n\t\t\t\t rxkad_abort_resp_short);\n\t\tgoto protocol_error;\n\t}\n\n\tversion = ntohl(response->version);\n\tticket_len = ntohl(response->ticket_len);\n\tkvno = ntohl(response->kvno);\n\n\ttrace_rxrpc_rx_response(conn, sp->hdr.serial, version, kvno, ticket_len);\n\n\tif (version != RXKAD_VERSION) {\n\t\trxrpc_abort_conn(conn, skb, RXKADINCONSISTENCY, -EPROTO,\n\t\t\t\t rxkad_abort_resp_version);\n\t\tgoto protocol_error;\n\t}\n\n\tif (ticket_len < 4 || ticket_len > MAXKRB5TICKETLEN) {\n\t\trxrpc_abort_conn(conn, skb, RXKADTICKETLEN, -EPROTO,\n\t\t\t\t rxkad_abort_resp_tkt_len);\n\t\tgoto protocol_error;\n\t}\n\n\tif (kvno >= RXKAD_TKT_TYPE_KERBEROS_V5) {\n\t\trxrpc_abort_conn(conn, skb, RXKADUNKNOWNKEY, -EPROTO,\n\t\t\t\t rxkad_abort_resp_unknown_tkt);\n\t\tgoto protocol_error;\n\t}\n\n\t \n\tret = -ENOMEM;\n\tticket = kmalloc(ticket_len, GFP_NOFS);\n\tif (!ticket)\n\t\tgoto temporary_error_free_resp;\n\n\tif (skb_copy_bits(skb, sizeof(struct rxrpc_wire_header) + sizeof(*response),\n\t\t\t  ticket, ticket_len) < 0) {\n\t\trxrpc_abort_conn(conn, skb, RXKADPACKETSHORT, -EPROTO,\n\t\t\t\t rxkad_abort_resp_short_tkt);\n\t\tgoto protocol_error;\n\t}\n\n\tret = rxkad_decrypt_ticket(conn, server_key, skb, ticket, ticket_len,\n\t\t\t\t   &session_key, &expiry);\n\tif (ret < 0)\n\t\tgoto temporary_error_free_ticket;\n\n\t \n\trxkad_decrypt_response(conn, response, &session_key);\n\n\tif (ntohl(response->encrypted.epoch) != conn->proto.epoch ||\n\t    ntohl(response->encrypted.cid) != conn->proto.cid ||\n\t    ntohl(response->encrypted.securityIndex) != conn->security_ix) {\n\t\trxrpc_abort_conn(conn, skb, RXKADSEALEDINCON, -EPROTO,\n\t\t\t\t rxkad_abort_resp_bad_param);\n\t\tgoto protocol_error_free;\n\t}\n\n\tcsum = response->encrypted.checksum;\n\tresponse->encrypted.checksum = 0;\n\trxkad_calc_response_checksum(response);\n\tif (response->encrypted.checksum != csum) {\n\t\trxrpc_abort_conn(conn, skb, RXKADSEALEDINCON, -EPROTO,\n\t\t\t\t rxkad_abort_resp_bad_checksum);\n\t\tgoto protocol_error_free;\n\t}\n\n\tfor (i = 0; i < RXRPC_MAXCALLS; i++) {\n\t\tu32 call_id = ntohl(response->encrypted.call_id[i]);\n\t\tu32 counter = READ_ONCE(conn->channels[i].call_counter);\n\n\t\tif (call_id > INT_MAX) {\n\t\t\trxrpc_abort_conn(conn, skb, RXKADSEALEDINCON, -EPROTO,\n\t\t\t\t\t rxkad_abort_resp_bad_callid);\n\t\t\tgoto protocol_error_free;\n\t\t}\n\n\t\tif (call_id < counter) {\n\t\t\trxrpc_abort_conn(conn, skb, RXKADSEALEDINCON, -EPROTO,\n\t\t\t\t\t rxkad_abort_resp_call_ctr);\n\t\t\tgoto protocol_error_free;\n\t\t}\n\n\t\tif (call_id > counter) {\n\t\t\tif (conn->channels[i].call) {\n\t\t\t\trxrpc_abort_conn(conn, skb, RXKADSEALEDINCON, -EPROTO,\n\t\t\t\t\t\t rxkad_abort_resp_call_state);\n\t\t\t\tgoto protocol_error_free;\n\t\t\t}\n\t\t\tconn->channels[i].call_counter = call_id;\n\t\t}\n\t}\n\n\tif (ntohl(response->encrypted.inc_nonce) != conn->rxkad.nonce + 1) {\n\t\trxrpc_abort_conn(conn, skb, RXKADOUTOFSEQUENCE, -EPROTO,\n\t\t\t\t rxkad_abort_resp_ooseq);\n\t\tgoto protocol_error_free;\n\t}\n\n\tlevel = ntohl(response->encrypted.level);\n\tif (level > RXRPC_SECURITY_ENCRYPT) {\n\t\trxrpc_abort_conn(conn, skb, RXKADLEVELFAIL, -EPROTO,\n\t\t\t\t rxkad_abort_resp_level);\n\t\tgoto protocol_error_free;\n\t}\n\tconn->security_level = level;\n\n\t \n\tret = rxrpc_get_server_data_key(conn, &session_key, expiry, kvno);\n\tif (ret < 0)\n\t\tgoto temporary_error_free_ticket;\n\n\tkfree(ticket);\n\tkfree(response);\n\t_leave(\" = 0\");\n\treturn 0;\n\nprotocol_error_free:\n\tkfree(ticket);\nprotocol_error:\n\tkfree(response);\n\tkey_put(server_key);\n\treturn -EPROTO;\n\ntemporary_error_free_ticket:\n\tkfree(ticket);\ntemporary_error_free_resp:\n\tkfree(response);\ntemporary_error:\n\t \n\tkey_put(server_key);\n\treturn ret;\n}\n\n \nstatic void rxkad_clear(struct rxrpc_connection *conn)\n{\n\t_enter(\"\");\n\n\tif (conn->rxkad.cipher)\n\t\tcrypto_free_sync_skcipher(conn->rxkad.cipher);\n}\n\n \nstatic int rxkad_init(void)\n{\n\tstruct crypto_sync_skcipher *tfm;\n\tstruct skcipher_request *req;\n\n\t \n\ttfm = crypto_alloc_sync_skcipher(\"pcbc(fcrypt)\", 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\treq = skcipher_request_alloc(&tfm->base, GFP_KERNEL);\n\tif (!req)\n\t\tgoto nomem_tfm;\n\n\trxkad_ci_req = req;\n\trxkad_ci = tfm;\n\treturn 0;\n\nnomem_tfm:\n\tcrypto_free_sync_skcipher(tfm);\n\treturn -ENOMEM;\n}\n\n \nstatic void rxkad_exit(void)\n{\n\tcrypto_free_sync_skcipher(rxkad_ci);\n\tskcipher_request_free(rxkad_ci_req);\n}\n\n \nconst struct rxrpc_security rxkad = {\n\t.name\t\t\t\t= \"rxkad\",\n\t.security_index\t\t\t= RXRPC_SECURITY_RXKAD,\n\t.no_key_abort\t\t\t= RXKADUNKNOWNKEY,\n\t.init\t\t\t\t= rxkad_init,\n\t.exit\t\t\t\t= rxkad_exit,\n\t.preparse_server_key\t\t= rxkad_preparse_server_key,\n\t.free_preparse_server_key\t= rxkad_free_preparse_server_key,\n\t.destroy_server_key\t\t= rxkad_destroy_server_key,\n\t.init_connection_security\t= rxkad_init_connection_security,\n\t.how_much_data\t\t\t= rxkad_how_much_data,\n\t.secure_packet\t\t\t= rxkad_secure_packet,\n\t.verify_packet\t\t\t= rxkad_verify_packet,\n\t.free_call_crypto\t\t= rxkad_free_call_crypto,\n\t.issue_challenge\t\t= rxkad_issue_challenge,\n\t.respond_to_challenge\t\t= rxkad_respond_to_challenge,\n\t.verify_response\t\t= rxkad_verify_response,\n\t.clear\t\t\t\t= rxkad_clear,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}