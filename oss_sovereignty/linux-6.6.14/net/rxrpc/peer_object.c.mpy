{
  "module_name": "peer_object.c",
  "hash_id": "4290808ba2511cb9096e65e66323ece125aa645cf691d51bd99f43bd02849037",
  "original_prompt": "Ingested from linux-6.6.14/net/rxrpc/peer_object.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/udp.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n#include <net/sock.h>\n#include <net/af_rxrpc.h>\n#include <net/ip.h>\n#include <net/route.h>\n#include <net/ip6_route.h>\n#include \"ar-internal.h\"\n\n \nstatic unsigned long rxrpc_peer_hash_key(struct rxrpc_local *local,\n\t\t\t\t\t const struct sockaddr_rxrpc *srx)\n{\n\tconst u16 *p;\n\tunsigned int i, size;\n\tunsigned long hash_key;\n\n\t_enter(\"\");\n\n\thash_key = (unsigned long)local / __alignof__(*local);\n\thash_key += srx->transport_type;\n\thash_key += srx->transport_len;\n\thash_key += srx->transport.family;\n\n\tswitch (srx->transport.family) {\n\tcase AF_INET:\n\t\thash_key += (u16 __force)srx->transport.sin.sin_port;\n\t\tsize = sizeof(srx->transport.sin.sin_addr);\n\t\tp = (u16 *)&srx->transport.sin.sin_addr;\n\t\tbreak;\n#ifdef CONFIG_AF_RXRPC_IPV6\n\tcase AF_INET6:\n\t\thash_key += (u16 __force)srx->transport.sin.sin_port;\n\t\tsize = sizeof(srx->transport.sin6.sin6_addr);\n\t\tp = (u16 *)&srx->transport.sin6.sin6_addr;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tWARN(1, \"AF_RXRPC: Unsupported transport address family\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < size; i += sizeof(*p), p++)\n\t\thash_key += *p;\n\n\t_leave(\" 0x%lx\", hash_key);\n\treturn hash_key;\n}\n\n \nstatic long rxrpc_peer_cmp_key(const struct rxrpc_peer *peer,\n\t\t\t       struct rxrpc_local *local,\n\t\t\t       const struct sockaddr_rxrpc *srx,\n\t\t\t       unsigned long hash_key)\n{\n\tlong diff;\n\n\tdiff = ((peer->hash_key - hash_key) ?:\n\t\t((unsigned long)peer->local - (unsigned long)local) ?:\n\t\t(peer->srx.transport_type - srx->transport_type) ?:\n\t\t(peer->srx.transport_len - srx->transport_len) ?:\n\t\t(peer->srx.transport.family - srx->transport.family));\n\tif (diff != 0)\n\t\treturn diff;\n\n\tswitch (srx->transport.family) {\n\tcase AF_INET:\n\t\treturn ((u16 __force)peer->srx.transport.sin.sin_port -\n\t\t\t(u16 __force)srx->transport.sin.sin_port) ?:\n\t\t\tmemcmp(&peer->srx.transport.sin.sin_addr,\n\t\t\t       &srx->transport.sin.sin_addr,\n\t\t\t       sizeof(struct in_addr));\n#ifdef CONFIG_AF_RXRPC_IPV6\n\tcase AF_INET6:\n\t\treturn ((u16 __force)peer->srx.transport.sin6.sin6_port -\n\t\t\t(u16 __force)srx->transport.sin6.sin6_port) ?:\n\t\t\tmemcmp(&peer->srx.transport.sin6.sin6_addr,\n\t\t\t       &srx->transport.sin6.sin6_addr,\n\t\t\t       sizeof(struct in6_addr));\n#endif\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n \nstatic struct rxrpc_peer *__rxrpc_lookup_peer_rcu(\n\tstruct rxrpc_local *local,\n\tconst struct sockaddr_rxrpc *srx,\n\tunsigned long hash_key)\n{\n\tstruct rxrpc_peer *peer;\n\tstruct rxrpc_net *rxnet = local->rxnet;\n\n\thash_for_each_possible_rcu(rxnet->peer_hash, peer, hash_link, hash_key) {\n\t\tif (rxrpc_peer_cmp_key(peer, local, srx, hash_key) == 0 &&\n\t\t    refcount_read(&peer->ref) > 0)\n\t\t\treturn peer;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct rxrpc_peer *rxrpc_lookup_peer_rcu(struct rxrpc_local *local,\n\t\t\t\t\t const struct sockaddr_rxrpc *srx)\n{\n\tstruct rxrpc_peer *peer;\n\tunsigned long hash_key = rxrpc_peer_hash_key(local, srx);\n\n\tpeer = __rxrpc_lookup_peer_rcu(local, srx, hash_key);\n\tif (peer)\n\t\t_leave(\" = %p {u=%d}\", peer, refcount_read(&peer->ref));\n\treturn peer;\n}\n\n \nstatic void rxrpc_assess_MTU_size(struct rxrpc_local *local,\n\t\t\t\t  struct rxrpc_peer *peer)\n{\n\tstruct net *net = local->net;\n\tstruct dst_entry *dst;\n\tstruct rtable *rt;\n\tstruct flowi fl;\n\tstruct flowi4 *fl4 = &fl.u.ip4;\n#ifdef CONFIG_AF_RXRPC_IPV6\n\tstruct flowi6 *fl6 = &fl.u.ip6;\n#endif\n\n\tpeer->if_mtu = 1500;\n\n\tmemset(&fl, 0, sizeof(fl));\n\tswitch (peer->srx.transport.family) {\n\tcase AF_INET:\n\t\trt = ip_route_output_ports(\n\t\t\tnet, fl4, NULL,\n\t\t\tpeer->srx.transport.sin.sin_addr.s_addr, 0,\n\t\t\thtons(7000), htons(7001), IPPROTO_UDP, 0, 0);\n\t\tif (IS_ERR(rt)) {\n\t\t\t_leave(\" [route err %ld]\", PTR_ERR(rt));\n\t\t\treturn;\n\t\t}\n\t\tdst = &rt->dst;\n\t\tbreak;\n\n#ifdef CONFIG_AF_RXRPC_IPV6\n\tcase AF_INET6:\n\t\tfl6->flowi6_iif = LOOPBACK_IFINDEX;\n\t\tfl6->flowi6_scope = RT_SCOPE_UNIVERSE;\n\t\tfl6->flowi6_proto = IPPROTO_UDP;\n\t\tmemcpy(&fl6->daddr, &peer->srx.transport.sin6.sin6_addr,\n\t\t       sizeof(struct in6_addr));\n\t\tfl6->fl6_dport = htons(7001);\n\t\tfl6->fl6_sport = htons(7000);\n\t\tdst = ip6_route_output(net, NULL, fl6);\n\t\tif (dst->error) {\n\t\t\t_leave(\" [route err %d]\", dst->error);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tBUG();\n\t}\n\n\tpeer->if_mtu = dst_mtu(dst);\n\tdst_release(dst);\n\n\t_leave(\" [if_mtu %u]\", peer->if_mtu);\n}\n\n \nstruct rxrpc_peer *rxrpc_alloc_peer(struct rxrpc_local *local, gfp_t gfp,\n\t\t\t\t    enum rxrpc_peer_trace why)\n{\n\tstruct rxrpc_peer *peer;\n\n\t_enter(\"\");\n\n\tpeer = kzalloc(sizeof(struct rxrpc_peer), gfp);\n\tif (peer) {\n\t\trefcount_set(&peer->ref, 1);\n\t\tpeer->local = rxrpc_get_local(local, rxrpc_local_get_peer);\n\t\tINIT_HLIST_HEAD(&peer->error_targets);\n\t\tpeer->service_conns = RB_ROOT;\n\t\tseqlock_init(&peer->service_conn_lock);\n\t\tspin_lock_init(&peer->lock);\n\t\tspin_lock_init(&peer->rtt_input_lock);\n\t\tpeer->debug_id = atomic_inc_return(&rxrpc_debug_id);\n\n\t\trxrpc_peer_init_rtt(peer);\n\n\t\tpeer->cong_ssthresh = RXRPC_TX_MAX_WINDOW;\n\t\ttrace_rxrpc_peer(peer->debug_id, 1, why);\n\t}\n\n\t_leave(\" = %p\", peer);\n\treturn peer;\n}\n\n \nstatic void rxrpc_init_peer(struct rxrpc_local *local, struct rxrpc_peer *peer,\n\t\t\t    unsigned long hash_key)\n{\n\tpeer->hash_key = hash_key;\n\trxrpc_assess_MTU_size(local, peer);\n\tpeer->mtu = peer->if_mtu;\n\tpeer->rtt_last_req = ktime_get_real();\n\n\tswitch (peer->srx.transport.family) {\n\tcase AF_INET:\n\t\tpeer->hdrsize = sizeof(struct iphdr);\n\t\tbreak;\n#ifdef CONFIG_AF_RXRPC_IPV6\n\tcase AF_INET6:\n\t\tpeer->hdrsize = sizeof(struct ipv6hdr);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tBUG();\n\t}\n\n\tswitch (peer->srx.transport_type) {\n\tcase SOCK_DGRAM:\n\t\tpeer->hdrsize += sizeof(struct udphdr);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tpeer->hdrsize += sizeof(struct rxrpc_wire_header);\n\tpeer->maxdata = peer->mtu - peer->hdrsize;\n}\n\n \nstatic struct rxrpc_peer *rxrpc_create_peer(struct rxrpc_local *local,\n\t\t\t\t\t    struct sockaddr_rxrpc *srx,\n\t\t\t\t\t    unsigned long hash_key,\n\t\t\t\t\t    gfp_t gfp)\n{\n\tstruct rxrpc_peer *peer;\n\n\t_enter(\"\");\n\n\tpeer = rxrpc_alloc_peer(local, gfp, rxrpc_peer_new_client);\n\tif (peer) {\n\t\tmemcpy(&peer->srx, srx, sizeof(*srx));\n\t\trxrpc_init_peer(local, peer, hash_key);\n\t}\n\n\t_leave(\" = %p\", peer);\n\treturn peer;\n}\n\nstatic void rxrpc_free_peer(struct rxrpc_peer *peer)\n{\n\ttrace_rxrpc_peer(peer->debug_id, 0, rxrpc_peer_free);\n\trxrpc_put_local(peer->local, rxrpc_local_put_peer);\n\tkfree_rcu(peer, rcu);\n}\n\n \nvoid rxrpc_new_incoming_peer(struct rxrpc_local *local, struct rxrpc_peer *peer)\n{\n\tstruct rxrpc_net *rxnet = local->rxnet;\n\tunsigned long hash_key;\n\n\thash_key = rxrpc_peer_hash_key(local, &peer->srx);\n\trxrpc_init_peer(local, peer, hash_key);\n\n\tspin_lock(&rxnet->peer_hash_lock);\n\thash_add_rcu(rxnet->peer_hash, &peer->hash_link, hash_key);\n\tlist_add_tail(&peer->keepalive_link, &rxnet->peer_keepalive_new);\n\tspin_unlock(&rxnet->peer_hash_lock);\n}\n\n \nstruct rxrpc_peer *rxrpc_lookup_peer(struct rxrpc_local *local,\n\t\t\t\t     struct sockaddr_rxrpc *srx, gfp_t gfp)\n{\n\tstruct rxrpc_peer *peer, *candidate;\n\tstruct rxrpc_net *rxnet = local->rxnet;\n\tunsigned long hash_key = rxrpc_peer_hash_key(local, srx);\n\n\t_enter(\"{%pISp}\", &srx->transport);\n\n\t \n\trcu_read_lock();\n\tpeer = __rxrpc_lookup_peer_rcu(local, srx, hash_key);\n\tif (peer && !rxrpc_get_peer_maybe(peer, rxrpc_peer_get_lookup_client))\n\t\tpeer = NULL;\n\trcu_read_unlock();\n\n\tif (!peer) {\n\t\t \n\t\tcandidate = rxrpc_create_peer(local, srx, hash_key, gfp);\n\t\tif (!candidate) {\n\t\t\t_leave(\" = NULL [nomem]\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock(&rxnet->peer_hash_lock);\n\n\t\t \n\t\tpeer = __rxrpc_lookup_peer_rcu(local, srx, hash_key);\n\t\tif (peer && !rxrpc_get_peer_maybe(peer, rxrpc_peer_get_lookup_client))\n\t\t\tpeer = NULL;\n\t\tif (!peer) {\n\t\t\thash_add_rcu(rxnet->peer_hash,\n\t\t\t\t     &candidate->hash_link, hash_key);\n\t\t\tlist_add_tail(&candidate->keepalive_link,\n\t\t\t\t      &rxnet->peer_keepalive_new);\n\t\t}\n\n\t\tspin_unlock(&rxnet->peer_hash_lock);\n\n\t\tif (peer)\n\t\t\trxrpc_free_peer(candidate);\n\t\telse\n\t\t\tpeer = candidate;\n\t}\n\n\t_leave(\" = %p {u=%d}\", peer, refcount_read(&peer->ref));\n\treturn peer;\n}\n\n \nstruct rxrpc_peer *rxrpc_get_peer(struct rxrpc_peer *peer, enum rxrpc_peer_trace why)\n{\n\tint r;\n\n\t__refcount_inc(&peer->ref, &r);\n\ttrace_rxrpc_peer(peer->debug_id, r + 1, why);\n\treturn peer;\n}\n\n \nstruct rxrpc_peer *rxrpc_get_peer_maybe(struct rxrpc_peer *peer,\n\t\t\t\t\tenum rxrpc_peer_trace why)\n{\n\tint r;\n\n\tif (peer) {\n\t\tif (__refcount_inc_not_zero(&peer->ref, &r))\n\t\t\ttrace_rxrpc_peer(peer->debug_id, r + 1, why);\n\t\telse\n\t\t\tpeer = NULL;\n\t}\n\treturn peer;\n}\n\n \nstatic void __rxrpc_put_peer(struct rxrpc_peer *peer)\n{\n\tstruct rxrpc_net *rxnet = peer->local->rxnet;\n\n\tASSERT(hlist_empty(&peer->error_targets));\n\n\tspin_lock(&rxnet->peer_hash_lock);\n\thash_del_rcu(&peer->hash_link);\n\tlist_del_init(&peer->keepalive_link);\n\tspin_unlock(&rxnet->peer_hash_lock);\n\n\trxrpc_free_peer(peer);\n}\n\n \nvoid rxrpc_put_peer(struct rxrpc_peer *peer, enum rxrpc_peer_trace why)\n{\n\tunsigned int debug_id;\n\tbool dead;\n\tint r;\n\n\tif (peer) {\n\t\tdebug_id = peer->debug_id;\n\t\tdead = __refcount_dec_and_test(&peer->ref, &r);\n\t\ttrace_rxrpc_peer(debug_id, r - 1, why);\n\t\tif (dead)\n\t\t\t__rxrpc_put_peer(peer);\n\t}\n}\n\n \nvoid rxrpc_destroy_all_peers(struct rxrpc_net *rxnet)\n{\n\tstruct rxrpc_peer *peer;\n\tint i;\n\n\tfor (i = 0; i < HASH_SIZE(rxnet->peer_hash); i++) {\n\t\tif (hlist_empty(&rxnet->peer_hash[i]))\n\t\t\tcontinue;\n\n\t\thlist_for_each_entry(peer, &rxnet->peer_hash[i], hash_link) {\n\t\t\tpr_err(\"Leaked peer %u {%u} %pISp\\n\",\n\t\t\t       peer->debug_id,\n\t\t\t       refcount_read(&peer->ref),\n\t\t\t       &peer->srx.transport);\n\t\t}\n\t}\n}\n\n \nvoid rxrpc_kernel_get_peer(struct socket *sock, struct rxrpc_call *call,\n\t\t\t   struct sockaddr_rxrpc *_srx)\n{\n\t*_srx = call->peer->srx;\n}\nEXPORT_SYMBOL(rxrpc_kernel_get_peer);\n\n \nbool rxrpc_kernel_get_srtt(struct socket *sock, struct rxrpc_call *call,\n\t\t\t   u32 *_srtt)\n{\n\tstruct rxrpc_peer *peer = call->peer;\n\n\tif (peer->rtt_count == 0) {\n\t\t*_srtt = 1000000;  \n\t\treturn false;\n\t}\n\n\t*_srtt = call->peer->srtt_us >> 3;\n\treturn true;\n}\nEXPORT_SYMBOL(rxrpc_kernel_get_srtt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}