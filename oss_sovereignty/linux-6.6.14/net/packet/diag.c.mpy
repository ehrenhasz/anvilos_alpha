{
  "module_name": "diag.c",
  "hash_id": "f543a37eba60584c07b3fb6e90e49247c8c289bf082a49a2750a7868f9c0bdbe",
  "original_prompt": "Ingested from linux-6.6.14/net/packet/diag.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/sock_diag.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/packet_diag.h>\n#include <linux/percpu.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n\n#include \"internal.h\"\n\nstatic int pdiag_put_info(const struct packet_sock *po, struct sk_buff *nlskb)\n{\n\tstruct packet_diag_info pinfo;\n\n\tpinfo.pdi_index = po->ifindex;\n\tpinfo.pdi_version = po->tp_version;\n\tpinfo.pdi_reserve = po->tp_reserve;\n\tpinfo.pdi_copy_thresh = po->copy_thresh;\n\tpinfo.pdi_tstamp = READ_ONCE(po->tp_tstamp);\n\n\tpinfo.pdi_flags = 0;\n\tif (packet_sock_flag(po, PACKET_SOCK_RUNNING))\n\t\tpinfo.pdi_flags |= PDI_RUNNING;\n\tif (packet_sock_flag(po, PACKET_SOCK_AUXDATA))\n\t\tpinfo.pdi_flags |= PDI_AUXDATA;\n\tif (packet_sock_flag(po, PACKET_SOCK_ORIGDEV))\n\t\tpinfo.pdi_flags |= PDI_ORIGDEV;\n\tif (READ_ONCE(po->vnet_hdr_sz))\n\t\tpinfo.pdi_flags |= PDI_VNETHDR;\n\tif (packet_sock_flag(po, PACKET_SOCK_TP_LOSS))\n\t\tpinfo.pdi_flags |= PDI_LOSS;\n\n\treturn nla_put(nlskb, PACKET_DIAG_INFO, sizeof(pinfo), &pinfo);\n}\n\nstatic int pdiag_put_mclist(const struct packet_sock *po, struct sk_buff *nlskb)\n{\n\tstruct nlattr *mca;\n\tstruct packet_mclist *ml;\n\n\tmca = nla_nest_start_noflag(nlskb, PACKET_DIAG_MCLIST);\n\tif (!mca)\n\t\treturn -EMSGSIZE;\n\n\trtnl_lock();\n\tfor (ml = po->mclist; ml; ml = ml->next) {\n\t\tstruct packet_diag_mclist *dml;\n\n\t\tdml = nla_reserve_nohdr(nlskb, sizeof(*dml));\n\t\tif (!dml) {\n\t\t\trtnl_unlock();\n\t\t\tnla_nest_cancel(nlskb, mca);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tdml->pdmc_index = ml->ifindex;\n\t\tdml->pdmc_type = ml->type;\n\t\tdml->pdmc_alen = ml->alen;\n\t\tdml->pdmc_count = ml->count;\n\t\tBUILD_BUG_ON(sizeof(dml->pdmc_addr) != sizeof(ml->addr));\n\t\tmemcpy(dml->pdmc_addr, ml->addr, sizeof(ml->addr));\n\t}\n\n\trtnl_unlock();\n\tnla_nest_end(nlskb, mca);\n\n\treturn 0;\n}\n\nstatic int pdiag_put_ring(struct packet_ring_buffer *ring, int ver, int nl_type,\n\t\tstruct sk_buff *nlskb)\n{\n\tstruct packet_diag_ring pdr;\n\n\tif (!ring->pg_vec)\n\t\treturn 0;\n\n\tpdr.pdr_block_size = ring->pg_vec_pages << PAGE_SHIFT;\n\tpdr.pdr_block_nr = ring->pg_vec_len;\n\tpdr.pdr_frame_size = ring->frame_size;\n\tpdr.pdr_frame_nr = ring->frame_max + 1;\n\n\tif (ver > TPACKET_V2) {\n\t\tpdr.pdr_retire_tmo = ring->prb_bdqc.retire_blk_tov;\n\t\tpdr.pdr_sizeof_priv = ring->prb_bdqc.blk_sizeof_priv;\n\t\tpdr.pdr_features = ring->prb_bdqc.feature_req_word;\n\t} else {\n\t\tpdr.pdr_retire_tmo = 0;\n\t\tpdr.pdr_sizeof_priv = 0;\n\t\tpdr.pdr_features = 0;\n\t}\n\n\treturn nla_put(nlskb, nl_type, sizeof(pdr), &pdr);\n}\n\nstatic int pdiag_put_rings_cfg(struct packet_sock *po, struct sk_buff *skb)\n{\n\tint ret;\n\n\tmutex_lock(&po->pg_vec_lock);\n\tret = pdiag_put_ring(&po->rx_ring, po->tp_version,\n\t\t\tPACKET_DIAG_RX_RING, skb);\n\tif (!ret)\n\t\tret = pdiag_put_ring(&po->tx_ring, po->tp_version,\n\t\t\t\tPACKET_DIAG_TX_RING, skb);\n\tmutex_unlock(&po->pg_vec_lock);\n\n\treturn ret;\n}\n\nstatic int pdiag_put_fanout(struct packet_sock *po, struct sk_buff *nlskb)\n{\n\tint ret = 0;\n\n\tmutex_lock(&fanout_mutex);\n\tif (po->fanout) {\n\t\tu32 val;\n\n\t\tval = (u32)po->fanout->id | ((u32)po->fanout->type << 16);\n\t\tret = nla_put_u32(nlskb, PACKET_DIAG_FANOUT, val);\n\t}\n\tmutex_unlock(&fanout_mutex);\n\n\treturn ret;\n}\n\nstatic int sk_diag_fill(struct sock *sk, struct sk_buff *skb,\n\t\t\tstruct packet_diag_req *req,\n\t\t\tbool may_report_filterinfo,\n\t\t\tstruct user_namespace *user_ns,\n\t\t\tu32 portid, u32 seq, u32 flags, int sk_ino)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct packet_diag_msg *rp;\n\tstruct packet_sock *po = pkt_sk(sk);\n\n\tnlh = nlmsg_put(skb, portid, seq, SOCK_DIAG_BY_FAMILY, sizeof(*rp), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\trp = nlmsg_data(nlh);\n\trp->pdiag_family = AF_PACKET;\n\trp->pdiag_type = sk->sk_type;\n\trp->pdiag_num = ntohs(READ_ONCE(po->num));\n\trp->pdiag_ino = sk_ino;\n\tsock_diag_save_cookie(sk, rp->pdiag_cookie);\n\n\tif ((req->pdiag_show & PACKET_SHOW_INFO) &&\n\t\t\tpdiag_put_info(po, skb))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->pdiag_show & PACKET_SHOW_INFO) &&\n\t    nla_put_u32(skb, PACKET_DIAG_UID,\n\t\t\tfrom_kuid_munged(user_ns, sock_i_uid(sk))))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->pdiag_show & PACKET_SHOW_MCLIST) &&\n\t\t\tpdiag_put_mclist(po, skb))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->pdiag_show & PACKET_SHOW_RING_CFG) &&\n\t\t\tpdiag_put_rings_cfg(po, skb))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->pdiag_show & PACKET_SHOW_FANOUT) &&\n\t\t\tpdiag_put_fanout(po, skb))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->pdiag_show & PACKET_SHOW_MEMINFO) &&\n\t    sock_diag_put_meminfo(sk, skb, PACKET_DIAG_MEMINFO))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->pdiag_show & PACKET_SHOW_FILTER) &&\n\t    sock_diag_put_filterinfo(may_report_filterinfo, sk, skb,\n\t\t\t\t     PACKET_DIAG_FILTER))\n\t\tgoto out_nlmsg_trim;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nout_nlmsg_trim:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int packet_diag_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint num = 0, s_num = cb->args[0];\n\tstruct packet_diag_req *req;\n\tstruct net *net;\n\tstruct sock *sk;\n\tbool may_report_filterinfo;\n\n\tnet = sock_net(skb->sk);\n\treq = nlmsg_data(cb->nlh);\n\tmay_report_filterinfo = netlink_net_capable(cb->skb, CAP_NET_ADMIN);\n\n\tmutex_lock(&net->packet.sklist_lock);\n\tsk_for_each(sk, &net->packet.sklist) {\n\t\tif (!net_eq(sock_net(sk), net))\n\t\t\tcontinue;\n\t\tif (num < s_num)\n\t\t\tgoto next;\n\n\t\tif (sk_diag_fill(sk, skb, req,\n\t\t\t\t may_report_filterinfo,\n\t\t\t\t sk_user_ns(NETLINK_CB(cb->skb).sk),\n\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t sock_i_ino(sk)) < 0)\n\t\t\tgoto done;\nnext:\n\t\tnum++;\n\t}\ndone:\n\tmutex_unlock(&net->packet.sklist_lock);\n\tcb->args[0] = num;\n\n\treturn skb->len;\n}\n\nstatic int packet_diag_handler_dump(struct sk_buff *skb, struct nlmsghdr *h)\n{\n\tint hdrlen = sizeof(struct packet_diag_req);\n\tstruct net *net = sock_net(skb->sk);\n\tstruct packet_diag_req *req;\n\n\tif (nlmsg_len(h) < hdrlen)\n\t\treturn -EINVAL;\n\n\treq = nlmsg_data(h);\n\t \n\tif (req->sdiag_protocol)\n\t\treturn -EINVAL;\n\n\tif (h->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = packet_diag_dump,\n\t\t};\n\t\treturn netlink_dump_start(net->diag_nlsk, skb, h, &c);\n\t} else\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic const struct sock_diag_handler packet_diag_handler = {\n\t.family = AF_PACKET,\n\t.dump = packet_diag_handler_dump,\n};\n\nstatic int __init packet_diag_init(void)\n{\n\treturn sock_diag_register(&packet_diag_handler);\n}\n\nstatic void __exit packet_diag_exit(void)\n{\n\tsock_diag_unregister(&packet_diag_handler);\n}\n\nmodule_init(packet_diag_init);\nmodule_exit(packet_diag_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 17  );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}