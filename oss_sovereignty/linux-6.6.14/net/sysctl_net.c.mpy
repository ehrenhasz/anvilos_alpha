{
  "module_name": "sysctl_net.c",
  "hash_id": "c260b2669c29414fc91d2c86a6ea08ef6f196e9f20c3a78193497d94c8080e69",
  "original_prompt": "Ingested from linux-6.6.14/net/sysctl_net.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/sysctl.h>\n#include <linux/nsproxy.h>\n\n#include <net/sock.h>\n\n#ifdef CONFIG_INET\n#include <net/ip.h>\n#endif\n\n#ifdef CONFIG_NET\n#include <linux/if_ether.h>\n#endif\n\nstatic struct ctl_table_set *\nnet_ctl_header_lookup(struct ctl_table_root *root)\n{\n\treturn &current->nsproxy->net_ns->sysctls;\n}\n\nstatic int is_seen(struct ctl_table_set *set)\n{\n\treturn &current->nsproxy->net_ns->sysctls == set;\n}\n\n \nstatic int net_ctl_permissions(struct ctl_table_header *head,\n\t\t\t       struct ctl_table *table)\n{\n\tstruct net *net = container_of(head->set, struct net, sysctls);\n\n\t \n\tif (ns_capable_noaudit(net->user_ns, CAP_NET_ADMIN)) {\n\t\tint mode = (table->mode >> 6) & 7;\n\t\treturn (mode << 6) | (mode << 3) | mode;\n\t}\n\n\treturn table->mode;\n}\n\nstatic void net_ctl_set_ownership(struct ctl_table_header *head,\n\t\t\t\t  struct ctl_table *table,\n\t\t\t\t  kuid_t *uid, kgid_t *gid)\n{\n\tstruct net *net = container_of(head->set, struct net, sysctls);\n\tkuid_t ns_root_uid;\n\tkgid_t ns_root_gid;\n\n\tns_root_uid = make_kuid(net->user_ns, 0);\n\tif (uid_valid(ns_root_uid))\n\t\t*uid = ns_root_uid;\n\n\tns_root_gid = make_kgid(net->user_ns, 0);\n\tif (gid_valid(ns_root_gid))\n\t\t*gid = ns_root_gid;\n}\n\nstatic struct ctl_table_root net_sysctl_root = {\n\t.lookup = net_ctl_header_lookup,\n\t.permissions = net_ctl_permissions,\n\t.set_ownership = net_ctl_set_ownership,\n};\n\nstatic int __net_init sysctl_net_init(struct net *net)\n{\n\tsetup_sysctl_set(&net->sysctls, &net_sysctl_root, is_seen);\n\treturn 0;\n}\n\nstatic void __net_exit sysctl_net_exit(struct net *net)\n{\n\tretire_sysctl_set(&net->sysctls);\n}\n\nstatic struct pernet_operations sysctl_pernet_ops = {\n\t.init = sysctl_net_init,\n\t.exit = sysctl_net_exit,\n};\n\nstatic struct ctl_table_header *net_header;\n__init int net_sysctl_init(void)\n{\n\tstatic struct ctl_table empty[1];\n\tint ret = -ENOMEM;\n\t \n\tnet_header = register_sysctl_sz(\"net\", empty, 0);\n\tif (!net_header)\n\t\tgoto out;\n\tret = register_pernet_subsys(&sysctl_pernet_ops);\n\tif (ret)\n\t\tgoto out1;\nout:\n\treturn ret;\nout1:\n\tunregister_sysctl_table(net_header);\n\tnet_header = NULL;\n\tgoto out;\n}\n\n \nstatic void ensure_safe_net_sysctl(struct net *net, const char *path,\n\t\t\t\t   struct ctl_table *table, size_t table_size)\n{\n\tstruct ctl_table *ent;\n\n\tpr_debug(\"Registering net sysctl (net %p): %s\\n\", net, path);\n\tent = table;\n\tfor (size_t i = 0; i < table_size && ent->procname; ent++, i++) {\n\t\tunsigned long addr;\n\t\tconst char *where;\n\n\t\tpr_debug(\"  procname=%s mode=%o proc_handler=%ps data=%p\\n\",\n\t\t\t ent->procname, ent->mode, ent->proc_handler, ent->data);\n\n\t\t \n\t\tif ((ent->mode & 0222) == 0) {\n\t\t\tpr_debug(\"    Not writable by anyone\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\taddr = (unsigned long)ent->data;\n\t\tif (is_module_address(addr))\n\t\t\twhere = \"module\";\n\t\telse if (is_kernel_core_data(addr))\n\t\t\twhere = \"kernel\";\n\t\telse\n\t\t\tcontinue;\n\n\t\t \n\t\tWARN(1, \"sysctl %s/%s: data points to %s global data: %ps\\n\",\n\t\t     path, ent->procname, where, ent->data);\n\n\t\t \n\t\tent->mode &= ~0222;\n\t}\n}\n\nstruct ctl_table_header *register_net_sysctl_sz(struct net *net,\n\t\t\t\t\t\tconst char *path,\n\t\t\t\t\t\tstruct ctl_table *table,\n\t\t\t\t\t\tsize_t table_size)\n{\n\tint count;\n\tstruct ctl_table *entry;\n\n\tif (!net_eq(net, &init_net))\n\t\tensure_safe_net_sysctl(net, path, table, table_size);\n\n\tentry = table;\n\tfor (count = 0 ; count < table_size && entry->procname; entry++, count++)\n\t\t;\n\n\treturn __register_sysctl_table(&net->sysctls, path, table, count);\n}\nEXPORT_SYMBOL_GPL(register_net_sysctl_sz);\n\nvoid unregister_net_sysctl_table(struct ctl_table_header *header)\n{\n\tunregister_sysctl_table(header);\n}\nEXPORT_SYMBOL_GPL(unregister_net_sysctl_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}