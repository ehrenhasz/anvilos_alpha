{
  "module_name": "scm.c",
  "hash_id": "6a2ca004b6062d824b860c230da5e7c02a5b5a7e3aef52083906ebbfb5cea435",
  "original_prompt": "Ingested from linux-6.6.14/net/unix/scm.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n#include <net/af_unix.h>\n#include <net/scm.h>\n#include <linux/init.h>\n#include <linux/io_uring.h>\n\n#include \"scm.h\"\n\nunsigned int unix_tot_inflight;\nEXPORT_SYMBOL(unix_tot_inflight);\n\nLIST_HEAD(gc_inflight_list);\nEXPORT_SYMBOL(gc_inflight_list);\n\nDEFINE_SPINLOCK(unix_gc_lock);\nEXPORT_SYMBOL(unix_gc_lock);\n\nstruct sock *unix_get_socket(struct file *filp)\n{\n\tstruct sock *u_sock = NULL;\n\tstruct inode *inode = file_inode(filp);\n\n\t \n\tif (S_ISSOCK(inode->i_mode) && !(filp->f_mode & FMODE_PATH)) {\n\t\tstruct socket *sock = SOCKET_I(inode);\n\t\tconst struct proto_ops *ops = READ_ONCE(sock->ops);\n\t\tstruct sock *s = sock->sk;\n\n\t\t \n\t\tif (s && ops && ops->family == PF_UNIX)\n\t\t\tu_sock = s;\n\t} else {\n\t\t \n\t\tu_sock = io_uring_get_socket(filp);\n\t}\n\treturn u_sock;\n}\nEXPORT_SYMBOL(unix_get_socket);\n\n \nvoid unix_inflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\t \n\t\tWRITE_ONCE(unix_tot_inflight, unix_tot_inflight + 1);\n\t}\n\tWRITE_ONCE(user->unix_inflight, user->unix_inflight + 1);\n\tspin_unlock(&unix_gc_lock);\n}\n\nvoid unix_notinflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tBUG_ON(!atomic_long_read(&u->inflight));\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\t \n\t\tWRITE_ONCE(unix_tot_inflight, unix_tot_inflight - 1);\n\t}\n\tWRITE_ONCE(user->unix_inflight, user->unix_inflight - 1);\n\tspin_unlock(&unix_gc_lock);\n}\n\n \nstatic inline bool too_many_unix_fds(struct task_struct *p)\n{\n\tstruct user_struct *user = current_user();\n\n\tif (unlikely(READ_ONCE(user->unix_inflight) > task_rlimit(p, RLIMIT_NOFILE)))\n\t\treturn !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN);\n\treturn false;\n}\n\nint unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\n\tif (too_many_unix_fds(current))\n\t\treturn -ETOOMANYREFS;\n\n\t \n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\tunix_inflight(scm->fp->user, scm->fp->fp[i]);\n\treturn 0;\n}\nEXPORT_SYMBOL(unix_attach_fds);\n\nvoid unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\n\tscm->fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\n\tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->user, scm->fp->fp[i]);\n}\nEXPORT_SYMBOL(unix_detach_fds);\n\nvoid unix_destruct_scm(struct sk_buff *skb)\n{\n\tstruct scm_cookie scm;\n\n\tmemset(&scm, 0, sizeof(scm));\n\tscm.pid  = UNIXCB(skb).pid;\n\tif (UNIXCB(skb).fp)\n\t\tunix_detach_fds(&scm, skb);\n\n\t \n\t \n\tscm_destroy(&scm);\n\tsock_wfree(skb);\n}\nEXPORT_SYMBOL(unix_destruct_scm);\n\nvoid io_uring_destruct_scm(struct sk_buff *skb)\n{\n\tunix_destruct_scm(skb);\n}\nEXPORT_SYMBOL(io_uring_destruct_scm);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}