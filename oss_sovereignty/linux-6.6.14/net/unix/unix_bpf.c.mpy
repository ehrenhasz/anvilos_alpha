{
  "module_name": "unix_bpf.c",
  "hash_id": "9917c8ce76f2c12aff2b36fff0b650738dde581054540598ca4b74402b41b872",
  "original_prompt": "Ingested from linux-6.6.14/net/unix/unix_bpf.c",
  "human_readable_source": "\n \n\n#include <linux/skmsg.h>\n#include <linux/bpf.h>\n#include <net/sock.h>\n#include <net/af_unix.h>\n\n#define unix_sk_has_data(__sk, __psock)\t\t\t\t\t\\\n\t\t({\t!skb_queue_empty(&__sk->sk_receive_queue) ||\t\\\n\t\t\t!skb_queue_empty(&__psock->ingress_skb) ||\t\\\n\t\t\t!list_empty(&__psock->ingress_msg);\t\t\\\n\t\t})\n\nstatic int unix_msg_wait_data(struct sock *sk, struct sk_psock *psock,\n\t\t\t      long timeo)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct unix_sock *u = unix_sk(sk);\n\tint ret = 0;\n\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\treturn 1;\n\n\tif (!timeo)\n\t\treturn ret;\n\n\tadd_wait_queue(sk_sleep(sk), &wait);\n\tsk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\tif (!unix_sk_has_data(sk, psock)) {\n\t\tmutex_unlock(&u->iolock);\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\t\tmutex_lock(&u->iolock);\n\t\tret = unix_sk_has_data(sk, psock);\n\t}\n\tsk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\treturn ret;\n}\n\nstatic int __unix_recvmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t  size_t len, int flags)\n{\n\tif (sk->sk_type == SOCK_DGRAM)\n\t\treturn __unix_dgram_recvmsg(sk, msg, len, flags);\n\telse\n\t\treturn __unix_stream_recvmsg(sk, msg, len, flags);\n}\n\nstatic int unix_bpf_recvmsg(struct sock *sk, struct msghdr *msg,\n\t\t\t    size_t len, int flags, int *addr_len)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sk_psock *psock;\n\tint copied;\n\n\tif (!len)\n\t\treturn 0;\n\n\tpsock = sk_psock_get(sk);\n\tif (unlikely(!psock))\n\t\treturn __unix_recvmsg(sk, msg, len, flags);\n\n\tmutex_lock(&u->iolock);\n\tif (!skb_queue_empty(&sk->sk_receive_queue) &&\n\t    sk_psock_queue_empty(psock)) {\n\t\tmutex_unlock(&u->iolock);\n\t\tsk_psock_put(sk, psock);\n\t\treturn __unix_recvmsg(sk, msg, len, flags);\n\t}\n\nmsg_bytes_ready:\n\tcopied = sk_msg_recvmsg(sk, psock, msg, len, flags);\n\tif (!copied) {\n\t\tlong timeo;\n\t\tint data;\n\n\t\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\t\tdata = unix_msg_wait_data(sk, psock, timeo);\n\t\tif (data) {\n\t\t\tif (!sk_psock_queue_empty(psock))\n\t\t\t\tgoto msg_bytes_ready;\n\t\t\tmutex_unlock(&u->iolock);\n\t\t\tsk_psock_put(sk, psock);\n\t\t\treturn __unix_recvmsg(sk, msg, len, flags);\n\t\t}\n\t\tcopied = -EAGAIN;\n\t}\n\tmutex_unlock(&u->iolock);\n\tsk_psock_put(sk, psock);\n\treturn copied;\n}\n\nstatic struct proto *unix_dgram_prot_saved __read_mostly;\nstatic DEFINE_SPINLOCK(unix_dgram_prot_lock);\nstatic struct proto unix_dgram_bpf_prot;\n\nstatic struct proto *unix_stream_prot_saved __read_mostly;\nstatic DEFINE_SPINLOCK(unix_stream_prot_lock);\nstatic struct proto unix_stream_bpf_prot;\n\nstatic void unix_dgram_bpf_rebuild_protos(struct proto *prot, const struct proto *base)\n{\n\t*prot        = *base;\n\tprot->close  = sock_map_close;\n\tprot->recvmsg = unix_bpf_recvmsg;\n\tprot->sock_is_readable = sk_msg_is_readable;\n}\n\nstatic void unix_stream_bpf_rebuild_protos(struct proto *prot,\n\t\t\t\t\t   const struct proto *base)\n{\n\t*prot        = *base;\n\tprot->close  = sock_map_close;\n\tprot->recvmsg = unix_bpf_recvmsg;\n\tprot->sock_is_readable = sk_msg_is_readable;\n\tprot->unhash  = sock_map_unhash;\n}\n\nstatic void unix_dgram_bpf_check_needs_rebuild(struct proto *ops)\n{\n\tif (unlikely(ops != smp_load_acquire(&unix_dgram_prot_saved))) {\n\t\tspin_lock_bh(&unix_dgram_prot_lock);\n\t\tif (likely(ops != unix_dgram_prot_saved)) {\n\t\t\tunix_dgram_bpf_rebuild_protos(&unix_dgram_bpf_prot, ops);\n\t\t\tsmp_store_release(&unix_dgram_prot_saved, ops);\n\t\t}\n\t\tspin_unlock_bh(&unix_dgram_prot_lock);\n\t}\n}\n\nstatic void unix_stream_bpf_check_needs_rebuild(struct proto *ops)\n{\n\tif (unlikely(ops != smp_load_acquire(&unix_stream_prot_saved))) {\n\t\tspin_lock_bh(&unix_stream_prot_lock);\n\t\tif (likely(ops != unix_stream_prot_saved)) {\n\t\t\tunix_stream_bpf_rebuild_protos(&unix_stream_bpf_prot, ops);\n\t\t\tsmp_store_release(&unix_stream_prot_saved, ops);\n\t\t}\n\t\tspin_unlock_bh(&unix_stream_prot_lock);\n\t}\n}\n\nint unix_dgram_bpf_update_proto(struct sock *sk, struct sk_psock *psock, bool restore)\n{\n\tif (sk->sk_type != SOCK_DGRAM)\n\t\treturn -EOPNOTSUPP;\n\n\tif (restore) {\n\t\tsk->sk_write_space = psock->saved_write_space;\n\t\tsock_replace_proto(sk, psock->sk_proto);\n\t\treturn 0;\n\t}\n\n\tunix_dgram_bpf_check_needs_rebuild(psock->sk_proto);\n\tsock_replace_proto(sk, &unix_dgram_bpf_prot);\n\treturn 0;\n}\n\nint unix_stream_bpf_update_proto(struct sock *sk, struct sk_psock *psock, bool restore)\n{\n\tstruct sock *sk_pair;\n\n\t \n\tif (restore) {\n\t\tsk->sk_write_space = psock->saved_write_space;\n\t\tsock_replace_proto(sk, psock->sk_proto);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!psock->sk_pair) {\n\t\tsk_pair = unix_peer(sk);\n\t\tsock_hold(sk_pair);\n\t\tpsock->sk_pair = sk_pair;\n\t}\n\n\tunix_stream_bpf_check_needs_rebuild(psock->sk_proto);\n\tsock_replace_proto(sk, &unix_stream_bpf_prot);\n\treturn 0;\n}\n\nvoid __init unix_bpf_build_proto(void)\n{\n\tunix_dgram_bpf_rebuild_protos(&unix_dgram_bpf_prot, &unix_dgram_proto);\n\tunix_stream_bpf_rebuild_protos(&unix_stream_bpf_prot, &unix_stream_proto);\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}