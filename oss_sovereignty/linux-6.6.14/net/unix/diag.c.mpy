{
  "module_name": "diag.c",
  "hash_id": "2c3f170960be794b80076a25d13e150d0e7ea5cf72dd587f5ebb2445ffa51d7d",
  "original_prompt": "Ingested from linux-6.6.14/net/unix/diag.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/sock_diag.h>\n#include <linux/unix_diag.h>\n#include <linux/skbuff.h>\n#include <linux/module.h>\n#include <linux/uidgid.h>\n#include <net/netlink.h>\n#include <net/af_unix.h>\n#include <net/tcp_states.h>\n#include <net/sock.h>\n\nstatic int sk_diag_dump_name(struct sock *sk, struct sk_buff *nlskb)\n{\n\t \n\tstruct unix_address *addr = smp_load_acquire(&unix_sk(sk)->addr);\n\n\tif (!addr)\n\t\treturn 0;\n\n\treturn nla_put(nlskb, UNIX_DIAG_NAME,\n\t\t       addr->len - offsetof(struct sockaddr_un, sun_path),\n\t\t       addr->name->sun_path);\n}\n\nstatic int sk_diag_dump_vfs(struct sock *sk, struct sk_buff *nlskb)\n{\n\tstruct dentry *dentry = unix_sk(sk)->path.dentry;\n\n\tif (dentry) {\n\t\tstruct unix_diag_vfs uv = {\n\t\t\t.udiag_vfs_ino = d_backing_inode(dentry)->i_ino,\n\t\t\t.udiag_vfs_dev = dentry->d_sb->s_dev,\n\t\t};\n\n\t\treturn nla_put(nlskb, UNIX_DIAG_VFS, sizeof(uv), &uv);\n\t}\n\n\treturn 0;\n}\n\nstatic int sk_diag_dump_peer(struct sock *sk, struct sk_buff *nlskb)\n{\n\tstruct sock *peer;\n\tint ino;\n\n\tpeer = unix_peer_get(sk);\n\tif (peer) {\n\t\tunix_state_lock(peer);\n\t\tino = sock_i_ino(peer);\n\t\tunix_state_unlock(peer);\n\t\tsock_put(peer);\n\n\t\treturn nla_put_u32(nlskb, UNIX_DIAG_PEER, ino);\n\t}\n\n\treturn 0;\n}\n\nstatic int sk_diag_dump_icons(struct sock *sk, struct sk_buff *nlskb)\n{\n\tstruct sk_buff *skb;\n\tstruct nlattr *attr;\n\tu32 *buf;\n\tint i;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tspin_lock(&sk->sk_receive_queue.lock);\n\n\t\tattr = nla_reserve(nlskb, UNIX_DIAG_ICONS,\n\t\t\t\t   sk->sk_receive_queue.qlen * sizeof(u32));\n\t\tif (!attr)\n\t\t\tgoto errout;\n\n\t\tbuf = nla_data(attr);\n\t\ti = 0;\n\t\tskb_queue_walk(&sk->sk_receive_queue, skb) {\n\t\t\tstruct sock *req, *peer;\n\n\t\t\treq = skb->sk;\n\t\t\t \n\t\t\tunix_state_lock_nested(req);\n\t\t\tpeer = unix_sk(req)->peer;\n\t\t\tbuf[i++] = (peer ? sock_i_ino(peer) : 0);\n\t\t\tunix_state_unlock(req);\n\t\t}\n\t\tspin_unlock(&sk->sk_receive_queue.lock);\n\t}\n\n\treturn 0;\n\nerrout:\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\treturn -EMSGSIZE;\n}\n\nstatic int sk_diag_show_rqlen(struct sock *sk, struct sk_buff *nlskb)\n{\n\tstruct unix_diag_rqlen rql;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\trql.udiag_rqueue = sk->sk_receive_queue.qlen;\n\t\trql.udiag_wqueue = sk->sk_max_ack_backlog;\n\t} else {\n\t\trql.udiag_rqueue = (u32) unix_inq_len(sk);\n\t\trql.udiag_wqueue = (u32) unix_outq_len(sk);\n\t}\n\n\treturn nla_put(nlskb, UNIX_DIAG_RQLEN, sizeof(rql), &rql);\n}\n\nstatic int sk_diag_dump_uid(struct sock *sk, struct sk_buff *nlskb,\n\t\t\t    struct user_namespace *user_ns)\n{\n\tuid_t uid = from_kuid_munged(user_ns, sock_i_uid(sk));\n\treturn nla_put(nlskb, UNIX_DIAG_UID, sizeof(uid_t), &uid);\n}\n\nstatic int sk_diag_fill(struct sock *sk, struct sk_buff *skb, struct unix_diag_req *req,\n\t\t\tstruct user_namespace *user_ns,\n\t\t\tu32 portid, u32 seq, u32 flags, int sk_ino)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct unix_diag_msg *rep;\n\n\tnlh = nlmsg_put(skb, portid, seq, SOCK_DIAG_BY_FAMILY, sizeof(*rep),\n\t\t\tflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\trep = nlmsg_data(nlh);\n\trep->udiag_family = AF_UNIX;\n\trep->udiag_type = sk->sk_type;\n\trep->udiag_state = sk->sk_state;\n\trep->pad = 0;\n\trep->udiag_ino = sk_ino;\n\tsock_diag_save_cookie(sk, rep->udiag_cookie);\n\n\tif ((req->udiag_show & UDIAG_SHOW_NAME) &&\n\t    sk_diag_dump_name(sk, skb))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->udiag_show & UDIAG_SHOW_VFS) &&\n\t    sk_diag_dump_vfs(sk, skb))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->udiag_show & UDIAG_SHOW_PEER) &&\n\t    sk_diag_dump_peer(sk, skb))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->udiag_show & UDIAG_SHOW_ICONS) &&\n\t    sk_diag_dump_icons(sk, skb))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->udiag_show & UDIAG_SHOW_RQLEN) &&\n\t    sk_diag_show_rqlen(sk, skb))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->udiag_show & UDIAG_SHOW_MEMINFO) &&\n\t    sock_diag_put_meminfo(sk, skb, UNIX_DIAG_MEMINFO))\n\t\tgoto out_nlmsg_trim;\n\n\tif (nla_put_u8(skb, UNIX_DIAG_SHUTDOWN, sk->sk_shutdown))\n\t\tgoto out_nlmsg_trim;\n\n\tif ((req->udiag_show & UDIAG_SHOW_UID) &&\n\t    sk_diag_dump_uid(sk, skb, user_ns))\n\t\tgoto out_nlmsg_trim;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nout_nlmsg_trim:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int sk_diag_dump(struct sock *sk, struct sk_buff *skb, struct unix_diag_req *req,\n\t\t\tstruct user_namespace *user_ns,\n\t\t\tu32 portid, u32 seq, u32 flags)\n{\n\tint sk_ino;\n\n\tunix_state_lock(sk);\n\tsk_ino = sock_i_ino(sk);\n\tunix_state_unlock(sk);\n\n\tif (!sk_ino)\n\t\treturn 0;\n\n\treturn sk_diag_fill(sk, skb, req, user_ns, portid, seq, flags, sk_ino);\n}\n\nstatic int unix_diag_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint num, s_num, slot, s_slot;\n\tstruct unix_diag_req *req;\n\n\treq = nlmsg_data(cb->nlh);\n\n\ts_slot = cb->args[0];\n\tnum = s_num = cb->args[1];\n\n\tfor (slot = s_slot; slot < UNIX_HASH_SIZE; s_num = 0, slot++) {\n\t\tstruct sock *sk;\n\n\t\tnum = 0;\n\t\tspin_lock(&net->unx.table.locks[slot]);\n\t\tsk_for_each(sk, &net->unx.table.buckets[slot]) {\n\t\t\tif (num < s_num)\n\t\t\t\tgoto next;\n\t\t\tif (!(req->udiag_states & (1 << sk->sk_state)))\n\t\t\t\tgoto next;\n\t\t\tif (sk_diag_dump(sk, skb, req, sk_user_ns(skb->sk),\n\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t cb->nlh->nlmsg_seq,\n\t\t\t\t\t NLM_F_MULTI) < 0) {\n\t\t\t\tspin_unlock(&net->unx.table.locks[slot]);\n\t\t\t\tgoto done;\n\t\t\t}\nnext:\n\t\t\tnum++;\n\t\t}\n\t\tspin_unlock(&net->unx.table.locks[slot]);\n\t}\ndone:\n\tcb->args[0] = slot;\n\tcb->args[1] = num;\n\n\treturn skb->len;\n}\n\nstatic struct sock *unix_lookup_by_ino(struct net *net, unsigned int ino)\n{\n\tstruct sock *sk;\n\tint i;\n\n\tfor (i = 0; i < UNIX_HASH_SIZE; i++) {\n\t\tspin_lock(&net->unx.table.locks[i]);\n\t\tsk_for_each(sk, &net->unx.table.buckets[i]) {\n\t\t\tif (ino == sock_i_ino(sk)) {\n\t\t\t\tsock_hold(sk);\n\t\t\t\tspin_unlock(&net->unx.table.locks[i]);\n\t\t\t\treturn sk;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&net->unx.table.locks[i]);\n\t}\n\treturn NULL;\n}\n\nstatic int unix_diag_get_exact(struct sk_buff *in_skb,\n\t\t\t       const struct nlmsghdr *nlh,\n\t\t\t       struct unix_diag_req *req)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tunsigned int extra_len;\n\tstruct sk_buff *rep;\n\tstruct sock *sk;\n\tint err;\n\n\terr = -EINVAL;\n\tif (req->udiag_ino == 0)\n\t\tgoto out_nosk;\n\n\tsk = unix_lookup_by_ino(net, req->udiag_ino);\n\terr = -ENOENT;\n\tif (sk == NULL)\n\t\tgoto out_nosk;\n\n\terr = sock_diag_check_cookie(sk, req->udiag_cookie);\n\tif (err)\n\t\tgoto out;\n\n\textra_len = 256;\nagain:\n\terr = -ENOMEM;\n\trep = nlmsg_new(sizeof(struct unix_diag_msg) + extra_len, GFP_KERNEL);\n\tif (!rep)\n\t\tgoto out;\n\n\terr = sk_diag_fill(sk, rep, req, sk_user_ns(NETLINK_CB(in_skb).sk),\n\t\t\t   NETLINK_CB(in_skb).portid,\n\t\t\t   nlh->nlmsg_seq, 0, req->udiag_ino);\n\tif (err < 0) {\n\t\tnlmsg_free(rep);\n\t\textra_len += 256;\n\t\tif (extra_len >= PAGE_SIZE)\n\t\t\tgoto out;\n\n\t\tgoto again;\n\t}\n\terr = nlmsg_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid);\n\nout:\n\tif (sk)\n\t\tsock_put(sk);\nout_nosk:\n\treturn err;\n}\n\nstatic int unix_diag_handler_dump(struct sk_buff *skb, struct nlmsghdr *h)\n{\n\tint hdrlen = sizeof(struct unix_diag_req);\n\n\tif (nlmsg_len(h) < hdrlen)\n\t\treturn -EINVAL;\n\n\tif (h->nlmsg_flags & NLM_F_DUMP) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = unix_diag_dump,\n\t\t};\n\t\treturn netlink_dump_start(sock_net(skb->sk)->diag_nlsk, skb, h, &c);\n\t} else\n\t\treturn unix_diag_get_exact(skb, h, nlmsg_data(h));\n}\n\nstatic const struct sock_diag_handler unix_diag_handler = {\n\t.family = AF_UNIX,\n\t.dump = unix_diag_handler_dump,\n};\n\nstatic int __init unix_diag_init(void)\n{\n\treturn sock_diag_register(&unix_diag_handler);\n}\n\nstatic void __exit unix_diag_exit(void)\n{\n\tsock_diag_unregister(&unix_diag_handler);\n}\n\nmodule_init(unix_diag_init);\nmodule_exit(unix_diag_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 1  );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}