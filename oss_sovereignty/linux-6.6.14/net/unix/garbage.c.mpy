{
  "module_name": "garbage.c",
  "hash_id": "48ee65d3175c13a403b29458de1b59a818488cac2a5e9a81f3fba3cc4d5d21a0",
  "original_prompt": "Ingested from linux-6.6.14/net/unix/garbage.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/un.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/file.h>\n#include <linux/proc_fs.h>\n#include <linux/mutex.h>\n#include <linux/wait.h>\n\n#include <net/sock.h>\n#include <net/af_unix.h>\n#include <net/scm.h>\n#include <net/tcp_states.h>\n\n#include \"scm.h\"\n\n \n\nstatic LIST_HEAD(gc_candidates);\nstatic DECLARE_WAIT_QUEUE_HEAD(unix_gc_wait);\n\nstatic void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),\n\t\t\t  struct sk_buff_head *hitlist)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *next;\n\n\tspin_lock(&x->sk_receive_queue.lock);\n\tskb_queue_walk_safe(&x->sk_receive_queue, skb, next) {\n\t\t \n\t\tif (UNIXCB(skb).fp) {\n\t\t\tbool hit = false;\n\t\t\t \n\t\t\tint nfd = UNIXCB(skb).fp->count;\n\t\t\tstruct file **fp = UNIXCB(skb).fp->fp;\n\n\t\t\twhile (nfd--) {\n\t\t\t\t \n\t\t\t\tstruct sock *sk = unix_get_socket(*fp++);\n\n\t\t\t\tif (sk) {\n\t\t\t\t\tstruct unix_sock *u = unix_sk(sk);\n\n\t\t\t\t\t \n\t\t\t\t\tif (test_bit(UNIX_GC_CANDIDATE, &u->gc_flags)) {\n\t\t\t\t\t\thit = true;\n\n\t\t\t\t\t\tfunc(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hit && hitlist != NULL) {\n\t\t\t\t__skb_unlink(skb, &x->sk_receive_queue);\n\t\t\t\t__skb_queue_tail(hitlist, skb);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&x->sk_receive_queue.lock);\n}\n\nstatic void scan_children(struct sock *x, void (*func)(struct unix_sock *),\n\t\t\t  struct sk_buff_head *hitlist)\n{\n\tif (x->sk_state != TCP_LISTEN) {\n\t\tscan_inflight(x, func, hitlist);\n\t} else {\n\t\tstruct sk_buff *skb;\n\t\tstruct sk_buff *next;\n\t\tstruct unix_sock *u;\n\t\tLIST_HEAD(embryos);\n\n\t\t \n\t\tspin_lock(&x->sk_receive_queue.lock);\n\t\tskb_queue_walk_safe(&x->sk_receive_queue, skb, next) {\n\t\t\tu = unix_sk(skb->sk);\n\n\t\t\t \n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &embryos);\n\t\t}\n\t\tspin_unlock(&x->sk_receive_queue.lock);\n\n\t\twhile (!list_empty(&embryos)) {\n\t\t\tu = list_entry(embryos.next, struct unix_sock, link);\n\t\t\tscan_inflight(&u->sk, func, hitlist);\n\t\t\tlist_del_init(&u->link);\n\t\t}\n\t}\n}\n\nstatic void dec_inflight(struct unix_sock *usk)\n{\n\tatomic_long_dec(&usk->inflight);\n}\n\nstatic void inc_inflight(struct unix_sock *usk)\n{\n\tatomic_long_inc(&usk->inflight);\n}\n\nstatic void inc_inflight_move_tail(struct unix_sock *u)\n{\n\tatomic_long_inc(&u->inflight);\n\t \n\tif (test_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags))\n\t\tlist_move_tail(&u->link, &gc_candidates);\n}\n\nstatic bool gc_in_progress;\n#define UNIX_INFLIGHT_TRIGGER_GC 16000\n\nvoid wait_for_unix_gc(void)\n{\n\t \n\tif (READ_ONCE(unix_tot_inflight) > UNIX_INFLIGHT_TRIGGER_GC &&\n\t    !READ_ONCE(gc_in_progress))\n\t\tunix_gc();\n\twait_event(unix_gc_wait, gc_in_progress == false);\n}\n\n \nvoid unix_gc(void)\n{\n\tstruct sk_buff *next_skb, *skb;\n\tstruct unix_sock *u;\n\tstruct unix_sock *next;\n\tstruct sk_buff_head hitlist;\n\tstruct list_head cursor;\n\tLIST_HEAD(not_cycle_list);\n\n\tspin_lock(&unix_gc_lock);\n\n\t \n\tif (gc_in_progress)\n\t\tgoto out;\n\n\t \n\tWRITE_ONCE(gc_in_progress, true);\n\n\t \n\tlist_for_each_entry_safe(u, next, &gc_inflight_list, link) {\n\t\tlong total_refs;\n\t\tlong inflight_refs;\n\n\t\ttotal_refs = file_count(u->sk.sk_socket->file);\n\t\tinflight_refs = atomic_long_read(&u->inflight);\n\n\t\tBUG_ON(inflight_refs < 1);\n\t\tBUG_ON(total_refs < inflight_refs);\n\t\tif (total_refs == inflight_refs) {\n\t\t\tlist_move_tail(&u->link, &gc_candidates);\n\t\t\t__set_bit(UNIX_GC_CANDIDATE, &u->gc_flags);\n\t\t\t__set_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(u, &gc_candidates, link)\n\t\tscan_children(&u->sk, dec_inflight, NULL);\n\n\t \n\tlist_add(&cursor, &gc_candidates);\n\twhile (cursor.next != &gc_candidates) {\n\t\tu = list_entry(cursor.next, struct unix_sock, link);\n\n\t\t \n\t\tlist_move(&cursor, &u->link);\n\n\t\tif (atomic_long_read(&u->inflight) > 0) {\n\t\t\tlist_move_tail(&u->link, &not_cycle_list);\n\t\t\t__clear_bit(UNIX_GC_MAYBE_CYCLE, &u->gc_flags);\n\t\t\tscan_children(&u->sk, inc_inflight_move_tail, NULL);\n\t\t}\n\t}\n\tlist_del(&cursor);\n\n\t \n\tskb_queue_head_init(&hitlist);\n\tlist_for_each_entry(u, &gc_candidates, link)\n\t\tscan_children(&u->sk, inc_inflight, &hitlist);\n\n\t \n\twhile (!list_empty(&not_cycle_list)) {\n\t\tu = list_entry(not_cycle_list.next, struct unix_sock, link);\n\t\t__clear_bit(UNIX_GC_CANDIDATE, &u->gc_flags);\n\t\tlist_move_tail(&u->link, &gc_inflight_list);\n\t}\n\n\tspin_unlock(&unix_gc_lock);\n\n\t \n\tskb_queue_walk_safe(&hitlist, skb, next_skb) {\n\t\tif (skb->destructor == io_uring_destruct_scm) {\n\t\t\t__skb_unlink(skb, &hitlist);\n\t\t\tskb_queue_tail(&skb->sk->sk_receive_queue, skb);\n\t\t}\n\t}\n\n\t \n\t__skb_queue_purge(&hitlist);\n\n\tspin_lock(&unix_gc_lock);\n\n\t \n\tlist_for_each_entry_safe(u, next, &gc_candidates, link)\n\t\tlist_move_tail(&u->link, &gc_inflight_list);\n\n\t \n\tBUG_ON(!list_empty(&gc_candidates));\n\n\t \n\tWRITE_ONCE(gc_in_progress, false);\n\n\twake_up(&unix_gc_wait);\n\n out:\n\tspin_unlock(&unix_gc_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}