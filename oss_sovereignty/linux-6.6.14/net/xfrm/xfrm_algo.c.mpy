{
  "module_name": "xfrm_algo.c",
  "hash_id": "8fae1b6f3df511d78ce6dc4dc02e7eb04a498508ce49e8c8239fb6552f85fe88",
  "original_prompt": "Ingested from linux-6.6.14/net/xfrm/xfrm_algo.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <crypto/skcipher.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/pfkeyv2.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <net/xfrm.h>\n#if IS_ENABLED(CONFIG_INET_ESP) || IS_ENABLED(CONFIG_INET6_ESP)\n#include <net/esp.h>\n#endif\n\n \nstatic struct xfrm_algo_desc aead_list[] = {\n{\n\t.name = \"rfc4106(gcm(aes))\",\n\n\t.uinfo = {\n\t\t.aead = {\n\t\t\t.geniv = \"seqiv\",\n\t\t\t.icv_truncbits = 64,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_AES_GCM_ICV8,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n{\n\t.name = \"rfc4106(gcm(aes))\",\n\n\t.uinfo = {\n\t\t.aead = {\n\t\t\t.geniv = \"seqiv\",\n\t\t\t.icv_truncbits = 96,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_AES_GCM_ICV12,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n{\n\t.name = \"rfc4106(gcm(aes))\",\n\n\t.uinfo = {\n\t\t.aead = {\n\t\t\t.geniv = \"seqiv\",\n\t\t\t.icv_truncbits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_AES_GCM_ICV16,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n{\n\t.name = \"rfc4309(ccm(aes))\",\n\n\t.uinfo = {\n\t\t.aead = {\n\t\t\t.geniv = \"seqiv\",\n\t\t\t.icv_truncbits = 64,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_AES_CCM_ICV8,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n{\n\t.name = \"rfc4309(ccm(aes))\",\n\n\t.uinfo = {\n\t\t.aead = {\n\t\t\t.geniv = \"seqiv\",\n\t\t\t.icv_truncbits = 96,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_AES_CCM_ICV12,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n{\n\t.name = \"rfc4309(ccm(aes))\",\n\n\t.uinfo = {\n\t\t.aead = {\n\t\t\t.geniv = \"seqiv\",\n\t\t\t.icv_truncbits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_AES_CCM_ICV16,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n{\n\t.name = \"rfc4543(gcm(aes))\",\n\n\t.uinfo = {\n\t\t.aead = {\n\t\t\t.geniv = \"seqiv\",\n\t\t\t.icv_truncbits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_NULL_AES_GMAC,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n{\n\t.name = \"rfc7539esp(chacha20,poly1305)\",\n\n\t.uinfo = {\n\t\t.aead = {\n\t\t\t.geniv = \"seqiv\",\n\t\t\t.icv_truncbits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 0,\n},\n};\n\nstatic struct xfrm_algo_desc aalg_list[] = {\n{\n\t.name = \"digest_null\",\n\n\t.uinfo = {\n\t\t.auth = {\n\t\t\t.icv_truncbits = 0,\n\t\t\t.icv_fullbits = 0,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_AALG_NULL,\n\t\t.sadb_alg_ivlen = 0,\n\t\t.sadb_alg_minbits = 0,\n\t\t.sadb_alg_maxbits = 0\n\t}\n},\n{\n\t.name = \"hmac(md5)\",\n\t.compat = \"md5\",\n\n\t.uinfo = {\n\t\t.auth = {\n\t\t\t.icv_truncbits = 96,\n\t\t\t.icv_fullbits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_AALG_MD5HMAC,\n\t\t.sadb_alg_ivlen = 0,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 128\n\t}\n},\n{\n\t.name = \"hmac(sha1)\",\n\t.compat = \"sha1\",\n\n\t.uinfo = {\n\t\t.auth = {\n\t\t\t.icv_truncbits = 96,\n\t\t\t.icv_fullbits = 160,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_AALG_SHA1HMAC,\n\t\t.sadb_alg_ivlen = 0,\n\t\t.sadb_alg_minbits = 160,\n\t\t.sadb_alg_maxbits = 160\n\t}\n},\n{\n\t.name = \"hmac(sha256)\",\n\t.compat = \"sha256\",\n\n\t.uinfo = {\n\t\t.auth = {\n\t\t\t.icv_truncbits = 96,\n\t\t\t.icv_fullbits = 256,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_AALG_SHA2_256HMAC,\n\t\t.sadb_alg_ivlen = 0,\n\t\t.sadb_alg_minbits = 256,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n{\n\t.name = \"hmac(sha384)\",\n\n\t.uinfo = {\n\t\t.auth = {\n\t\t\t.icv_truncbits = 192,\n\t\t\t.icv_fullbits = 384,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_AALG_SHA2_384HMAC,\n\t\t.sadb_alg_ivlen = 0,\n\t\t.sadb_alg_minbits = 384,\n\t\t.sadb_alg_maxbits = 384\n\t}\n},\n{\n\t.name = \"hmac(sha512)\",\n\n\t.uinfo = {\n\t\t.auth = {\n\t\t\t.icv_truncbits = 256,\n\t\t\t.icv_fullbits = 512,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_AALG_SHA2_512HMAC,\n\t\t.sadb_alg_ivlen = 0,\n\t\t.sadb_alg_minbits = 512,\n\t\t.sadb_alg_maxbits = 512\n\t}\n},\n{\n\t.name = \"hmac(rmd160)\",\n\t.compat = \"rmd160\",\n\n\t.uinfo = {\n\t\t.auth = {\n\t\t\t.icv_truncbits = 96,\n\t\t\t.icv_fullbits = 160,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_AALG_RIPEMD160HMAC,\n\t\t.sadb_alg_ivlen = 0,\n\t\t.sadb_alg_minbits = 160,\n\t\t.sadb_alg_maxbits = 160\n\t}\n},\n{\n\t.name = \"xcbc(aes)\",\n\n\t.uinfo = {\n\t\t.auth = {\n\t\t\t.icv_truncbits = 96,\n\t\t\t.icv_fullbits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_AALG_AES_XCBC_MAC,\n\t\t.sadb_alg_ivlen = 0,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 128\n\t}\n},\n{\n\t \n\t.name = \"cmac(aes)\",\n\n\t.uinfo = {\n\t\t.auth = {\n\t\t\t.icv_truncbits = 96,\n\t\t\t.icv_fullbits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 0,\n},\n{\n\t.name = \"hmac(sm3)\",\n\t.compat = \"sm3\",\n\n\t.uinfo = {\n\t\t.auth = {\n\t\t\t.icv_truncbits = 256,\n\t\t\t.icv_fullbits = 256,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_AALG_SM3_256HMAC,\n\t\t.sadb_alg_ivlen = 0,\n\t\t.sadb_alg_minbits = 256,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n};\n\nstatic struct xfrm_algo_desc ealg_list[] = {\n{\n\t.name = \"ecb(cipher_null)\",\n\t.compat = \"cipher_null\",\n\n\t.uinfo = {\n\t\t.encr = {\n\t\t\t.blockbits = 8,\n\t\t\t.defkeybits = 0,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id =\tSADB_EALG_NULL,\n\t\t.sadb_alg_ivlen = 0,\n\t\t.sadb_alg_minbits = 0,\n\t\t.sadb_alg_maxbits = 0\n\t}\n},\n{\n\t.name = \"cbc(des)\",\n\t.compat = \"des\",\n\n\t.uinfo = {\n\t\t.encr = {\n\t\t\t.geniv = \"echainiv\",\n\t\t\t.blockbits = 64,\n\t\t\t.defkeybits = 64,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_EALG_DESCBC,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 64,\n\t\t.sadb_alg_maxbits = 64\n\t}\n},\n{\n\t.name = \"cbc(des3_ede)\",\n\t.compat = \"des3_ede\",\n\n\t.uinfo = {\n\t\t.encr = {\n\t\t\t.geniv = \"echainiv\",\n\t\t\t.blockbits = 64,\n\t\t\t.defkeybits = 192,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_EALG_3DESCBC,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 192,\n\t\t.sadb_alg_maxbits = 192\n\t}\n},\n{\n\t.name = \"cbc(cast5)\",\n\t.compat = \"cast5\",\n\n\t.uinfo = {\n\t\t.encr = {\n\t\t\t.geniv = \"echainiv\",\n\t\t\t.blockbits = 64,\n\t\t\t.defkeybits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_CASTCBC,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 40,\n\t\t.sadb_alg_maxbits = 128\n\t}\n},\n{\n\t.name = \"cbc(blowfish)\",\n\t.compat = \"blowfish\",\n\n\t.uinfo = {\n\t\t.encr = {\n\t\t\t.geniv = \"echainiv\",\n\t\t\t.blockbits = 64,\n\t\t\t.defkeybits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_BLOWFISHCBC,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 40,\n\t\t.sadb_alg_maxbits = 448\n\t}\n},\n{\n\t.name = \"cbc(aes)\",\n\t.compat = \"aes\",\n\n\t.uinfo = {\n\t\t.encr = {\n\t\t\t.geniv = \"echainiv\",\n\t\t\t.blockbits = 128,\n\t\t\t.defkeybits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_AESCBC,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n{\n\t.name = \"cbc(serpent)\",\n\t.compat = \"serpent\",\n\n\t.uinfo = {\n\t\t.encr = {\n\t\t\t.geniv = \"echainiv\",\n\t\t\t.blockbits = 128,\n\t\t\t.defkeybits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_SERPENTCBC,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 256,\n\t}\n},\n{\n\t.name = \"cbc(camellia)\",\n\t.compat = \"camellia\",\n\n\t.uinfo = {\n\t\t.encr = {\n\t\t\t.geniv = \"echainiv\",\n\t\t\t.blockbits = 128,\n\t\t\t.defkeybits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_CAMELLIACBC,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n{\n\t.name = \"cbc(twofish)\",\n\t.compat = \"twofish\",\n\n\t.uinfo = {\n\t\t.encr = {\n\t\t\t.geniv = \"echainiv\",\n\t\t\t.blockbits = 128,\n\t\t\t.defkeybits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_TWOFISHCBC,\n\t\t.sadb_alg_ivlen = 8,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n{\n\t.name = \"rfc3686(ctr(aes))\",\n\n\t.uinfo = {\n\t\t.encr = {\n\t\t\t.geniv = \"seqiv\",\n\t\t\t.blockbits = 128,\n\t\t\t.defkeybits = 160,  \n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_AESCTR,\n\t\t.sadb_alg_ivlen\t= 8,\n\t\t.sadb_alg_minbits = 160,\n\t\t.sadb_alg_maxbits = 288\n\t}\n},\n{\n\t.name = \"cbc(sm4)\",\n\t.compat = \"sm4\",\n\n\t.uinfo = {\n\t\t.encr = {\n\t\t\t.geniv = \"echainiv\",\n\t\t\t.blockbits = 128,\n\t\t\t.defkeybits = 128,\n\t\t}\n\t},\n\n\t.pfkey_supported = 1,\n\n\t.desc = {\n\t\t.sadb_alg_id = SADB_X_EALG_SM4CBC,\n\t\t.sadb_alg_ivlen\t= 16,\n\t\t.sadb_alg_minbits = 128,\n\t\t.sadb_alg_maxbits = 256\n\t}\n},\n};\n\nstatic struct xfrm_algo_desc calg_list[] = {\n{\n\t.name = \"deflate\",\n\t.uinfo = {\n\t\t.comp = {\n\t\t\t.threshold = 90,\n\t\t}\n\t},\n\t.pfkey_supported = 1,\n\t.desc = { .sadb_alg_id = SADB_X_CALG_DEFLATE }\n},\n{\n\t.name = \"lzs\",\n\t.uinfo = {\n\t\t.comp = {\n\t\t\t.threshold = 90,\n\t\t}\n\t},\n\t.pfkey_supported = 1,\n\t.desc = { .sadb_alg_id = SADB_X_CALG_LZS }\n},\n{\n\t.name = \"lzjh\",\n\t.uinfo = {\n\t\t.comp = {\n\t\t\t.threshold = 50,\n\t\t}\n\t},\n\t.pfkey_supported = 1,\n\t.desc = { .sadb_alg_id = SADB_X_CALG_LZJH }\n},\n};\n\nstatic inline int aalg_entries(void)\n{\n\treturn ARRAY_SIZE(aalg_list);\n}\n\nstatic inline int ealg_entries(void)\n{\n\treturn ARRAY_SIZE(ealg_list);\n}\n\nstatic inline int calg_entries(void)\n{\n\treturn ARRAY_SIZE(calg_list);\n}\n\nstruct xfrm_algo_list {\n\tstruct xfrm_algo_desc *algs;\n\tint entries;\n\tu32 type;\n\tu32 mask;\n};\n\nstatic const struct xfrm_algo_list xfrm_aead_list = {\n\t.algs = aead_list,\n\t.entries = ARRAY_SIZE(aead_list),\n\t.type = CRYPTO_ALG_TYPE_AEAD,\n\t.mask = CRYPTO_ALG_TYPE_MASK,\n};\n\nstatic const struct xfrm_algo_list xfrm_aalg_list = {\n\t.algs = aalg_list,\n\t.entries = ARRAY_SIZE(aalg_list),\n\t.type = CRYPTO_ALG_TYPE_HASH,\n\t.mask = CRYPTO_ALG_TYPE_HASH_MASK,\n};\n\nstatic const struct xfrm_algo_list xfrm_ealg_list = {\n\t.algs = ealg_list,\n\t.entries = ARRAY_SIZE(ealg_list),\n\t.type = CRYPTO_ALG_TYPE_SKCIPHER,\n\t.mask = CRYPTO_ALG_TYPE_MASK,\n};\n\nstatic const struct xfrm_algo_list xfrm_calg_list = {\n\t.algs = calg_list,\n\t.entries = ARRAY_SIZE(calg_list),\n\t.type = CRYPTO_ALG_TYPE_COMPRESS,\n\t.mask = CRYPTO_ALG_TYPE_MASK,\n};\n\nstatic struct xfrm_algo_desc *xfrm_find_algo(\n\tconst struct xfrm_algo_list *algo_list,\n\tint match(const struct xfrm_algo_desc *entry, const void *data),\n\tconst void *data, int probe)\n{\n\tstruct xfrm_algo_desc *list = algo_list->algs;\n\tint i, status;\n\n\tfor (i = 0; i < algo_list->entries; i++) {\n\t\tif (!match(list + i, data))\n\t\t\tcontinue;\n\n\t\tif (list[i].available)\n\t\t\treturn &list[i];\n\n\t\tif (!probe)\n\t\t\tbreak;\n\n\t\tstatus = crypto_has_alg(list[i].name, algo_list->type,\n\t\t\t\t\talgo_list->mask);\n\t\tif (!status)\n\t\t\tbreak;\n\n\t\tlist[i].available = status;\n\t\treturn &list[i];\n\t}\n\treturn NULL;\n}\n\nstatic int xfrm_alg_id_match(const struct xfrm_algo_desc *entry,\n\t\t\t     const void *data)\n{\n\treturn entry->desc.sadb_alg_id == (unsigned long)data;\n}\n\nstruct xfrm_algo_desc *xfrm_aalg_get_byid(int alg_id)\n{\n\treturn xfrm_find_algo(&xfrm_aalg_list, xfrm_alg_id_match,\n\t\t\t      (void *)(unsigned long)alg_id, 1);\n}\nEXPORT_SYMBOL_GPL(xfrm_aalg_get_byid);\n\nstruct xfrm_algo_desc *xfrm_ealg_get_byid(int alg_id)\n{\n\treturn xfrm_find_algo(&xfrm_ealg_list, xfrm_alg_id_match,\n\t\t\t      (void *)(unsigned long)alg_id, 1);\n}\nEXPORT_SYMBOL_GPL(xfrm_ealg_get_byid);\n\nstruct xfrm_algo_desc *xfrm_calg_get_byid(int alg_id)\n{\n\treturn xfrm_find_algo(&xfrm_calg_list, xfrm_alg_id_match,\n\t\t\t      (void *)(unsigned long)alg_id, 1);\n}\nEXPORT_SYMBOL_GPL(xfrm_calg_get_byid);\n\nstatic int xfrm_alg_name_match(const struct xfrm_algo_desc *entry,\n\t\t\t       const void *data)\n{\n\tconst char *name = data;\n\n\treturn name && (!strcmp(name, entry->name) ||\n\t\t\t(entry->compat && !strcmp(name, entry->compat)));\n}\n\nstruct xfrm_algo_desc *xfrm_aalg_get_byname(const char *name, int probe)\n{\n\treturn xfrm_find_algo(&xfrm_aalg_list, xfrm_alg_name_match, name,\n\t\t\t      probe);\n}\nEXPORT_SYMBOL_GPL(xfrm_aalg_get_byname);\n\nstruct xfrm_algo_desc *xfrm_ealg_get_byname(const char *name, int probe)\n{\n\treturn xfrm_find_algo(&xfrm_ealg_list, xfrm_alg_name_match, name,\n\t\t\t      probe);\n}\nEXPORT_SYMBOL_GPL(xfrm_ealg_get_byname);\n\nstruct xfrm_algo_desc *xfrm_calg_get_byname(const char *name, int probe)\n{\n\treturn xfrm_find_algo(&xfrm_calg_list, xfrm_alg_name_match, name,\n\t\t\t      probe);\n}\nEXPORT_SYMBOL_GPL(xfrm_calg_get_byname);\n\nstruct xfrm_aead_name {\n\tconst char *name;\n\tint icvbits;\n};\n\nstatic int xfrm_aead_name_match(const struct xfrm_algo_desc *entry,\n\t\t\t\tconst void *data)\n{\n\tconst struct xfrm_aead_name *aead = data;\n\tconst char *name = aead->name;\n\n\treturn aead->icvbits == entry->uinfo.aead.icv_truncbits && name &&\n\t       !strcmp(name, entry->name);\n}\n\nstruct xfrm_algo_desc *xfrm_aead_get_byname(const char *name, int icv_len, int probe)\n{\n\tstruct xfrm_aead_name data = {\n\t\t.name = name,\n\t\t.icvbits = icv_len,\n\t};\n\n\treturn xfrm_find_algo(&xfrm_aead_list, xfrm_aead_name_match, &data,\n\t\t\t      probe);\n}\nEXPORT_SYMBOL_GPL(xfrm_aead_get_byname);\n\nstruct xfrm_algo_desc *xfrm_aalg_get_byidx(unsigned int idx)\n{\n\tif (idx >= aalg_entries())\n\t\treturn NULL;\n\n\treturn &aalg_list[idx];\n}\nEXPORT_SYMBOL_GPL(xfrm_aalg_get_byidx);\n\nstruct xfrm_algo_desc *xfrm_ealg_get_byidx(unsigned int idx)\n{\n\tif (idx >= ealg_entries())\n\t\treturn NULL;\n\n\treturn &ealg_list[idx];\n}\nEXPORT_SYMBOL_GPL(xfrm_ealg_get_byidx);\n\n \nvoid xfrm_probe_algs(void)\n{\n\tint i, status;\n\n\tBUG_ON(in_softirq());\n\n\tfor (i = 0; i < aalg_entries(); i++) {\n\t\tstatus = crypto_has_ahash(aalg_list[i].name, 0, 0);\n\t\tif (aalg_list[i].available != status)\n\t\t\taalg_list[i].available = status;\n\t}\n\n\tfor (i = 0; i < ealg_entries(); i++) {\n\t\tstatus = crypto_has_skcipher(ealg_list[i].name, 0, 0);\n\t\tif (ealg_list[i].available != status)\n\t\t\tealg_list[i].available = status;\n\t}\n\n\tfor (i = 0; i < calg_entries(); i++) {\n\t\tstatus = crypto_has_comp(calg_list[i].name, 0,\n\t\t\t\t\t CRYPTO_ALG_ASYNC);\n\t\tif (calg_list[i].available != status)\n\t\t\tcalg_list[i].available = status;\n\t}\n}\nEXPORT_SYMBOL_GPL(xfrm_probe_algs);\n\nint xfrm_count_pfkey_auth_supported(void)\n{\n\tint i, n;\n\n\tfor (i = 0, n = 0; i < aalg_entries(); i++)\n\t\tif (aalg_list[i].available && aalg_list[i].pfkey_supported)\n\t\t\tn++;\n\treturn n;\n}\nEXPORT_SYMBOL_GPL(xfrm_count_pfkey_auth_supported);\n\nint xfrm_count_pfkey_enc_supported(void)\n{\n\tint i, n;\n\n\tfor (i = 0, n = 0; i < ealg_entries(); i++)\n\t\tif (ealg_list[i].available && ealg_list[i].pfkey_supported)\n\t\t\tn++;\n\treturn n;\n}\nEXPORT_SYMBOL_GPL(xfrm_count_pfkey_enc_supported);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}