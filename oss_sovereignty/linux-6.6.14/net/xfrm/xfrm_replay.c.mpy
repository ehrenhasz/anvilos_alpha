{
  "module_name": "xfrm_replay.c",
  "hash_id": "b5094d02e1df0be6382bceb82047f805d57983d87826cfba910ddf558ca98a8a",
  "original_prompt": "Ingested from linux-6.6.14/net/xfrm/xfrm_replay.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <net/xfrm.h>\n\nu32 xfrm_replay_seqhi(struct xfrm_state *x, __be32 net_seq)\n{\n\tu32 seq, seq_hi, bottom;\n\tstruct xfrm_replay_state_esn *replay_esn = x->replay_esn;\n\n\tif (!(x->props.flags & XFRM_STATE_ESN))\n\t\treturn 0;\n\n\tseq = ntohl(net_seq);\n\tseq_hi = replay_esn->seq_hi;\n\tbottom = replay_esn->seq - replay_esn->replay_window + 1;\n\n\tif (likely(replay_esn->seq >= replay_esn->replay_window - 1)) {\n\t\t \n\t\tif (unlikely(seq < bottom))\n\t\t\tseq_hi++;\n\t} else {\n\t\t \n\t\tif (unlikely(seq >= bottom))\n\t\t\tseq_hi--;\n\t}\n\n\treturn seq_hi;\n}\nEXPORT_SYMBOL(xfrm_replay_seqhi);\n\nstatic void xfrm_replay_notify_bmp(struct xfrm_state *x, int event);\nstatic void xfrm_replay_notify_esn(struct xfrm_state *x, int event);\n\nvoid xfrm_replay_notify(struct xfrm_state *x, int event)\n{\n\tstruct km_event c;\n\t \n\n\tswitch (x->repl_mode) {\n\tcase XFRM_REPLAY_MODE_LEGACY:\n\t\tbreak;\n\tcase XFRM_REPLAY_MODE_BMP:\n\t\txfrm_replay_notify_bmp(x, event);\n\t\treturn;\n\tcase XFRM_REPLAY_MODE_ESN:\n\t\txfrm_replay_notify_esn(x, event);\n\t\treturn;\n\t}\n\n\tswitch (event) {\n\tcase XFRM_REPLAY_UPDATE:\n\t\tif (!x->replay_maxdiff ||\n\t\t    ((x->replay.seq - x->preplay.seq < x->replay_maxdiff) &&\n\t\t    (x->replay.oseq - x->preplay.oseq < x->replay_maxdiff))) {\n\t\t\tif (x->xflags & XFRM_TIME_DEFER)\n\t\t\t\tevent = XFRM_REPLAY_TIMEOUT;\n\t\t\telse\n\t\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\n\tcase XFRM_REPLAY_TIMEOUT:\n\t\tif (memcmp(&x->replay, &x->preplay,\n\t\t\t   sizeof(struct xfrm_replay_state)) == 0) {\n\t\t\tx->xflags |= XFRM_TIME_DEFER;\n\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tmemcpy(&x->preplay, &x->replay, sizeof(struct xfrm_replay_state));\n\tc.event = XFRM_MSG_NEWAE;\n\tc.data.aevent = event;\n\tkm_state_notify(x, &c);\n\n\tif (x->replay_maxage &&\n\t    !mod_timer(&x->rtimer, jiffies + x->replay_maxage))\n\t\tx->xflags &= ~XFRM_TIME_DEFER;\n}\n\nstatic int __xfrm_replay_overflow(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err = 0;\n\tstruct net *net = xs_net(x);\n\n\tif (x->type->flags & XFRM_TYPE_REPLAY_PROT) {\n\t\tXFRM_SKB_CB(skb)->seq.output.low = ++x->replay.oseq;\n\t\tXFRM_SKB_CB(skb)->seq.output.hi = 0;\n\t\tif (unlikely(x->replay.oseq == 0) &&\n\t\t    !(x->props.extra_flags & XFRM_SA_XFLAG_OSEQ_MAY_WRAP)) {\n\t\t\tx->replay.oseq--;\n\t\t\txfrm_audit_state_replay_overflow(x, skb);\n\t\t\terr = -EOVERFLOW;\n\n\t\t\treturn err;\n\t\t}\n\t\tif (xfrm_aevent_is_on(net))\n\t\t\txfrm_replay_notify(x, XFRM_REPLAY_UPDATE);\n\t}\n\n\treturn err;\n}\n\nstatic int xfrm_replay_check_legacy(struct xfrm_state *x,\n\t\t\t\t    struct sk_buff *skb, __be32 net_seq)\n{\n\tu32 diff;\n\tu32 seq = ntohl(net_seq);\n\n\tif (!x->props.replay_window)\n\t\treturn 0;\n\n\tif (unlikely(seq == 0))\n\t\tgoto err;\n\n\tif (likely(seq > x->replay.seq))\n\t\treturn 0;\n\n\tdiff = x->replay.seq - seq;\n\tif (diff >= x->props.replay_window) {\n\t\tx->stats.replay_window++;\n\t\tgoto err;\n\t}\n\n\tif (x->replay.bitmap & (1U << diff)) {\n\t\tx->stats.replay++;\n\t\tgoto err;\n\t}\n\treturn 0;\n\nerr:\n\txfrm_audit_state_replay(x, skb, net_seq);\n\treturn -EINVAL;\n}\n\nstatic void xfrm_replay_advance_bmp(struct xfrm_state *x, __be32 net_seq);\nstatic void xfrm_replay_advance_esn(struct xfrm_state *x, __be32 net_seq);\n\nvoid xfrm_replay_advance(struct xfrm_state *x, __be32 net_seq)\n{\n\tu32 diff, seq;\n\n\tswitch (x->repl_mode) {\n\tcase XFRM_REPLAY_MODE_LEGACY:\n\t\tbreak;\n\tcase XFRM_REPLAY_MODE_BMP:\n\t\treturn xfrm_replay_advance_bmp(x, net_seq);\n\tcase XFRM_REPLAY_MODE_ESN:\n\t\treturn xfrm_replay_advance_esn(x, net_seq);\n\t}\n\n\tif (!x->props.replay_window)\n\t\treturn;\n\n\tseq = ntohl(net_seq);\n\tif (seq > x->replay.seq) {\n\t\tdiff = seq - x->replay.seq;\n\t\tif (diff < x->props.replay_window)\n\t\t\tx->replay.bitmap = ((x->replay.bitmap) << diff) | 1;\n\t\telse\n\t\t\tx->replay.bitmap = 1;\n\t\tx->replay.seq = seq;\n\t} else {\n\t\tdiff = x->replay.seq - seq;\n\t\tx->replay.bitmap |= (1U << diff);\n\t}\n\n\tif (xfrm_aevent_is_on(xs_net(x)))\n\t\txfrm_replay_notify(x, XFRM_REPLAY_UPDATE);\n}\n\nstatic int xfrm_replay_overflow_bmp(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err = 0;\n\tstruct xfrm_replay_state_esn *replay_esn = x->replay_esn;\n\tstruct net *net = xs_net(x);\n\n\tif (x->type->flags & XFRM_TYPE_REPLAY_PROT) {\n\t\tXFRM_SKB_CB(skb)->seq.output.low = ++replay_esn->oseq;\n\t\tXFRM_SKB_CB(skb)->seq.output.hi = 0;\n\t\tif (unlikely(replay_esn->oseq == 0) &&\n\t\t    !(x->props.extra_flags & XFRM_SA_XFLAG_OSEQ_MAY_WRAP)) {\n\t\t\treplay_esn->oseq--;\n\t\t\txfrm_audit_state_replay_overflow(x, skb);\n\t\t\terr = -EOVERFLOW;\n\n\t\t\treturn err;\n\t\t}\n\t\tif (xfrm_aevent_is_on(net))\n\t\t\txfrm_replay_notify(x, XFRM_REPLAY_UPDATE);\n\t}\n\n\treturn err;\n}\n\nstatic int xfrm_replay_check_bmp(struct xfrm_state *x,\n\t\t\t\t struct sk_buff *skb, __be32 net_seq)\n{\n\tunsigned int bitnr, nr;\n\tstruct xfrm_replay_state_esn *replay_esn = x->replay_esn;\n\tu32 pos;\n\tu32 seq = ntohl(net_seq);\n\tu32 diff =  replay_esn->seq - seq;\n\n\tif (!replay_esn->replay_window)\n\t\treturn 0;\n\n\tif (unlikely(seq == 0))\n\t\tgoto err;\n\n\tif (likely(seq > replay_esn->seq))\n\t\treturn 0;\n\n\tif (diff >= replay_esn->replay_window) {\n\t\tx->stats.replay_window++;\n\t\tgoto err;\n\t}\n\n\tpos = (replay_esn->seq - 1) % replay_esn->replay_window;\n\n\tif (pos >= diff)\n\t\tbitnr = (pos - diff) % replay_esn->replay_window;\n\telse\n\t\tbitnr = replay_esn->replay_window - (diff - pos);\n\n\tnr = bitnr >> 5;\n\tbitnr = bitnr & 0x1F;\n\tif (replay_esn->bmp[nr] & (1U << bitnr))\n\t\tgoto err_replay;\n\n\treturn 0;\n\nerr_replay:\n\tx->stats.replay++;\nerr:\n\txfrm_audit_state_replay(x, skb, net_seq);\n\treturn -EINVAL;\n}\n\nstatic void xfrm_replay_advance_bmp(struct xfrm_state *x, __be32 net_seq)\n{\n\tunsigned int bitnr, nr, i;\n\tu32 diff;\n\tstruct xfrm_replay_state_esn *replay_esn = x->replay_esn;\n\tu32 seq = ntohl(net_seq);\n\tu32 pos;\n\n\tif (!replay_esn->replay_window)\n\t\treturn;\n\n\tpos = (replay_esn->seq - 1) % replay_esn->replay_window;\n\n\tif (seq > replay_esn->seq) {\n\t\tdiff = seq - replay_esn->seq;\n\n\t\tif (diff < replay_esn->replay_window) {\n\t\t\tfor (i = 1; i < diff; i++) {\n\t\t\t\tbitnr = (pos + i) % replay_esn->replay_window;\n\t\t\t\tnr = bitnr >> 5;\n\t\t\t\tbitnr = bitnr & 0x1F;\n\t\t\t\treplay_esn->bmp[nr] &=  ~(1U << bitnr);\n\t\t\t}\n\t\t} else {\n\t\t\tnr = (replay_esn->replay_window - 1) >> 5;\n\t\t\tfor (i = 0; i <= nr; i++)\n\t\t\t\treplay_esn->bmp[i] = 0;\n\t\t}\n\n\t\tbitnr = (pos + diff) % replay_esn->replay_window;\n\t\treplay_esn->seq = seq;\n\t} else {\n\t\tdiff = replay_esn->seq - seq;\n\n\t\tif (pos >= diff)\n\t\t\tbitnr = (pos - diff) % replay_esn->replay_window;\n\t\telse\n\t\t\tbitnr = replay_esn->replay_window - (diff - pos);\n\t}\n\n\tnr = bitnr >> 5;\n\tbitnr = bitnr & 0x1F;\n\treplay_esn->bmp[nr] |= (1U << bitnr);\n\n\tif (xfrm_aevent_is_on(xs_net(x)))\n\t\txfrm_replay_notify(x, XFRM_REPLAY_UPDATE);\n}\n\nstatic void xfrm_replay_notify_bmp(struct xfrm_state *x, int event)\n{\n\tstruct km_event c;\n\tstruct xfrm_replay_state_esn *replay_esn = x->replay_esn;\n\tstruct xfrm_replay_state_esn *preplay_esn = x->preplay_esn;\n\n\t \n\n\tswitch (event) {\n\tcase XFRM_REPLAY_UPDATE:\n\t\tif (!x->replay_maxdiff ||\n\t\t    ((replay_esn->seq - preplay_esn->seq < x->replay_maxdiff) &&\n\t\t    (replay_esn->oseq - preplay_esn->oseq\n\t\t     < x->replay_maxdiff))) {\n\t\t\tif (x->xflags & XFRM_TIME_DEFER)\n\t\t\t\tevent = XFRM_REPLAY_TIMEOUT;\n\t\t\telse\n\t\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\n\tcase XFRM_REPLAY_TIMEOUT:\n\t\tif (memcmp(x->replay_esn, x->preplay_esn,\n\t\t\t   xfrm_replay_state_esn_len(replay_esn)) == 0) {\n\t\t\tx->xflags |= XFRM_TIME_DEFER;\n\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tmemcpy(x->preplay_esn, x->replay_esn,\n\t       xfrm_replay_state_esn_len(replay_esn));\n\tc.event = XFRM_MSG_NEWAE;\n\tc.data.aevent = event;\n\tkm_state_notify(x, &c);\n\n\tif (x->replay_maxage &&\n\t    !mod_timer(&x->rtimer, jiffies + x->replay_maxage))\n\t\tx->xflags &= ~XFRM_TIME_DEFER;\n}\n\nstatic void xfrm_replay_notify_esn(struct xfrm_state *x, int event)\n{\n\tu32 seq_diff, oseq_diff;\n\tstruct km_event c;\n\tstruct xfrm_replay_state_esn *replay_esn = x->replay_esn;\n\tstruct xfrm_replay_state_esn *preplay_esn = x->preplay_esn;\n\n\t \n\n\tswitch (event) {\n\tcase XFRM_REPLAY_UPDATE:\n\t\tif (x->replay_maxdiff) {\n\t\t\tif (replay_esn->seq_hi == preplay_esn->seq_hi)\n\t\t\t\tseq_diff = replay_esn->seq - preplay_esn->seq;\n\t\t\telse\n\t\t\t\tseq_diff = ~preplay_esn->seq + replay_esn->seq\n\t\t\t\t\t   + 1;\n\n\t\t\tif (replay_esn->oseq_hi == preplay_esn->oseq_hi)\n\t\t\t\toseq_diff = replay_esn->oseq\n\t\t\t\t\t    - preplay_esn->oseq;\n\t\t\telse\n\t\t\t\toseq_diff = ~preplay_esn->oseq\n\t\t\t\t\t    + replay_esn->oseq + 1;\n\n\t\t\tif (seq_diff >= x->replay_maxdiff ||\n\t\t\t    oseq_diff >= x->replay_maxdiff)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (x->xflags & XFRM_TIME_DEFER)\n\t\t\tevent = XFRM_REPLAY_TIMEOUT;\n\t\telse\n\t\t\treturn;\n\n\t\tbreak;\n\n\tcase XFRM_REPLAY_TIMEOUT:\n\t\tif (memcmp(x->replay_esn, x->preplay_esn,\n\t\t\t   xfrm_replay_state_esn_len(replay_esn)) == 0) {\n\t\t\tx->xflags |= XFRM_TIME_DEFER;\n\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tmemcpy(x->preplay_esn, x->replay_esn,\n\t       xfrm_replay_state_esn_len(replay_esn));\n\tc.event = XFRM_MSG_NEWAE;\n\tc.data.aevent = event;\n\tkm_state_notify(x, &c);\n\n\tif (x->replay_maxage &&\n\t    !mod_timer(&x->rtimer, jiffies + x->replay_maxage))\n\t\tx->xflags &= ~XFRM_TIME_DEFER;\n}\n\nstatic int xfrm_replay_overflow_esn(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err = 0;\n\tstruct xfrm_replay_state_esn *replay_esn = x->replay_esn;\n\tstruct net *net = xs_net(x);\n\n\tif (x->type->flags & XFRM_TYPE_REPLAY_PROT) {\n\t\tXFRM_SKB_CB(skb)->seq.output.low = ++replay_esn->oseq;\n\t\tXFRM_SKB_CB(skb)->seq.output.hi = replay_esn->oseq_hi;\n\n\t\tif (unlikely(replay_esn->oseq == 0)) {\n\t\t\tXFRM_SKB_CB(skb)->seq.output.hi = ++replay_esn->oseq_hi;\n\n\t\t\tif (replay_esn->oseq_hi == 0) {\n\t\t\t\treplay_esn->oseq--;\n\t\t\t\treplay_esn->oseq_hi--;\n\t\t\t\txfrm_audit_state_replay_overflow(x, skb);\n\t\t\t\terr = -EOVERFLOW;\n\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tif (xfrm_aevent_is_on(net))\n\t\t\txfrm_replay_notify(x, XFRM_REPLAY_UPDATE);\n\t}\n\n\treturn err;\n}\n\nstatic int xfrm_replay_check_esn(struct xfrm_state *x,\n\t\t\t\t struct sk_buff *skb, __be32 net_seq)\n{\n\tunsigned int bitnr, nr;\n\tu32 diff;\n\tstruct xfrm_replay_state_esn *replay_esn = x->replay_esn;\n\tu32 pos;\n\tu32 seq = ntohl(net_seq);\n\tu32 wsize = replay_esn->replay_window;\n\tu32 top = replay_esn->seq;\n\tu32 bottom = top - wsize + 1;\n\n\tif (!wsize)\n\t\treturn 0;\n\n\tif (unlikely(seq == 0 && replay_esn->seq_hi == 0 &&\n\t\t     (replay_esn->seq < replay_esn->replay_window - 1)))\n\t\tgoto err;\n\n\tdiff = top - seq;\n\n\tif (likely(top >= wsize - 1)) {\n\t\t \n\t\tif (likely(seq > top) || seq < bottom)\n\t\t\treturn 0;\n\t} else {\n\t\t \n\t\tif (likely(seq > top && seq < bottom))\n\t\t\treturn 0;\n\t\tif (seq >= bottom)\n\t\t\tdiff = ~seq + top + 1;\n\t}\n\n\tif (diff >= replay_esn->replay_window) {\n\t\tx->stats.replay_window++;\n\t\tgoto err;\n\t}\n\n\tpos = (replay_esn->seq - 1) % replay_esn->replay_window;\n\n\tif (pos >= diff)\n\t\tbitnr = (pos - diff) % replay_esn->replay_window;\n\telse\n\t\tbitnr = replay_esn->replay_window - (diff - pos);\n\n\tnr = bitnr >> 5;\n\tbitnr = bitnr & 0x1F;\n\tif (replay_esn->bmp[nr] & (1U << bitnr))\n\t\tgoto err_replay;\n\n\treturn 0;\n\nerr_replay:\n\tx->stats.replay++;\nerr:\n\txfrm_audit_state_replay(x, skb, net_seq);\n\treturn -EINVAL;\n}\n\nint xfrm_replay_check(struct xfrm_state *x,\n\t\t      struct sk_buff *skb, __be32 net_seq)\n{\n\tswitch (x->repl_mode) {\n\tcase XFRM_REPLAY_MODE_LEGACY:\n\t\tbreak;\n\tcase XFRM_REPLAY_MODE_BMP:\n\t\treturn xfrm_replay_check_bmp(x, skb, net_seq);\n\tcase XFRM_REPLAY_MODE_ESN:\n\t\treturn xfrm_replay_check_esn(x, skb, net_seq);\n\t}\n\n\treturn xfrm_replay_check_legacy(x, skb, net_seq);\n}\n\nstatic int xfrm_replay_recheck_esn(struct xfrm_state *x,\n\t\t\t\t   struct sk_buff *skb, __be32 net_seq)\n{\n\tif (unlikely(XFRM_SKB_CB(skb)->seq.input.hi !=\n\t\t     htonl(xfrm_replay_seqhi(x, net_seq)))) {\n\t\t\tx->stats.replay_window++;\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn xfrm_replay_check_esn(x, skb, net_seq);\n}\n\nint xfrm_replay_recheck(struct xfrm_state *x,\n\t\t\tstruct sk_buff *skb, __be32 net_seq)\n{\n\tswitch (x->repl_mode) {\n\tcase XFRM_REPLAY_MODE_LEGACY:\n\t\tbreak;\n\tcase XFRM_REPLAY_MODE_BMP:\n\t\t \n\t\treturn xfrm_replay_check_bmp(x, skb, net_seq);\n\tcase XFRM_REPLAY_MODE_ESN:\n\t\treturn xfrm_replay_recheck_esn(x, skb, net_seq);\n\t}\n\n\treturn xfrm_replay_check_legacy(x, skb, net_seq);\n}\n\nstatic void xfrm_replay_advance_esn(struct xfrm_state *x, __be32 net_seq)\n{\n\tunsigned int bitnr, nr, i;\n\tint wrap;\n\tu32 diff, pos, seq, seq_hi;\n\tstruct xfrm_replay_state_esn *replay_esn = x->replay_esn;\n\n\tif (!replay_esn->replay_window)\n\t\treturn;\n\n\tseq = ntohl(net_seq);\n\tpos = (replay_esn->seq - 1) % replay_esn->replay_window;\n\tseq_hi = xfrm_replay_seqhi(x, net_seq);\n\twrap = seq_hi - replay_esn->seq_hi;\n\n\tif ((!wrap && seq > replay_esn->seq) || wrap > 0) {\n\t\tif (likely(!wrap))\n\t\t\tdiff = seq - replay_esn->seq;\n\t\telse\n\t\t\tdiff = ~replay_esn->seq + seq + 1;\n\n\t\tif (diff < replay_esn->replay_window) {\n\t\t\tfor (i = 1; i < diff; i++) {\n\t\t\t\tbitnr = (pos + i) % replay_esn->replay_window;\n\t\t\t\tnr = bitnr >> 5;\n\t\t\t\tbitnr = bitnr & 0x1F;\n\t\t\t\treplay_esn->bmp[nr] &=  ~(1U << bitnr);\n\t\t\t}\n\t\t} else {\n\t\t\tnr = (replay_esn->replay_window - 1) >> 5;\n\t\t\tfor (i = 0; i <= nr; i++)\n\t\t\t\treplay_esn->bmp[i] = 0;\n\t\t}\n\n\t\tbitnr = (pos + diff) % replay_esn->replay_window;\n\t\treplay_esn->seq = seq;\n\n\t\tif (unlikely(wrap > 0))\n\t\t\treplay_esn->seq_hi++;\n\t} else {\n\t\tdiff = replay_esn->seq - seq;\n\n\t\tif (pos >= diff)\n\t\t\tbitnr = (pos - diff) % replay_esn->replay_window;\n\t\telse\n\t\t\tbitnr = replay_esn->replay_window - (diff - pos);\n\t}\n\n\txfrm_dev_state_advance_esn(x);\n\n\tnr = bitnr >> 5;\n\tbitnr = bitnr & 0x1F;\n\treplay_esn->bmp[nr] |= (1U << bitnr);\n\n\tif (xfrm_aevent_is_on(xs_net(x)))\n\t\txfrm_replay_notify(x, XFRM_REPLAY_UPDATE);\n}\n\n#ifdef CONFIG_XFRM_OFFLOAD\nstatic int xfrm_replay_overflow_offload(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err = 0;\n\tstruct net *net = xs_net(x);\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\t__u32 oseq = x->replay.oseq;\n\n\tif (!xo)\n\t\treturn __xfrm_replay_overflow(x, skb);\n\n\tif (x->type->flags & XFRM_TYPE_REPLAY_PROT) {\n\t\tif (!skb_is_gso(skb)) {\n\t\t\tXFRM_SKB_CB(skb)->seq.output.low = ++oseq;\n\t\t\txo->seq.low = oseq;\n\t\t} else {\n\t\t\tXFRM_SKB_CB(skb)->seq.output.low = oseq + 1;\n\t\t\txo->seq.low = oseq + 1;\n\t\t\toseq += skb_shinfo(skb)->gso_segs;\n\t\t}\n\n\t\tXFRM_SKB_CB(skb)->seq.output.hi = 0;\n\t\txo->seq.hi = 0;\n\t\tif (unlikely(oseq < x->replay.oseq) &&\n\t\t    !(x->props.extra_flags & XFRM_SA_XFLAG_OSEQ_MAY_WRAP)) {\n\t\t\txfrm_audit_state_replay_overflow(x, skb);\n\t\t\terr = -EOVERFLOW;\n\n\t\t\treturn err;\n\t\t}\n\n\t\tx->replay.oseq = oseq;\n\n\t\tif (xfrm_aevent_is_on(net))\n\t\t\txfrm_replay_notify(x, XFRM_REPLAY_UPDATE);\n\t}\n\n\treturn err;\n}\n\nstatic int xfrm_replay_overflow_offload_bmp(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err = 0;\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tstruct xfrm_replay_state_esn *replay_esn = x->replay_esn;\n\tstruct net *net = xs_net(x);\n\t__u32 oseq = replay_esn->oseq;\n\n\tif (!xo)\n\t\treturn xfrm_replay_overflow_bmp(x, skb);\n\n\tif (x->type->flags & XFRM_TYPE_REPLAY_PROT) {\n\t\tif (!skb_is_gso(skb)) {\n\t\t\tXFRM_SKB_CB(skb)->seq.output.low = ++oseq;\n\t\t\txo->seq.low = oseq;\n\t\t} else {\n\t\t\tXFRM_SKB_CB(skb)->seq.output.low = oseq + 1;\n\t\t\txo->seq.low = oseq + 1;\n\t\t\toseq += skb_shinfo(skb)->gso_segs;\n\t\t}\n\n\t\tXFRM_SKB_CB(skb)->seq.output.hi = 0;\n\t\txo->seq.hi = 0;\n\t\tif (unlikely(oseq < replay_esn->oseq) &&\n\t\t    !(x->props.extra_flags & XFRM_SA_XFLAG_OSEQ_MAY_WRAP)) {\n\t\t\txfrm_audit_state_replay_overflow(x, skb);\n\t\t\terr = -EOVERFLOW;\n\n\t\t\treturn err;\n\t\t} else {\n\t\t\treplay_esn->oseq = oseq;\n\t\t}\n\n\t\tif (xfrm_aevent_is_on(net))\n\t\t\txfrm_replay_notify(x, XFRM_REPLAY_UPDATE);\n\t}\n\n\treturn err;\n}\n\nstatic int xfrm_replay_overflow_offload_esn(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err = 0;\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tstruct xfrm_replay_state_esn *replay_esn = x->replay_esn;\n\tstruct net *net = xs_net(x);\n\t__u32 oseq = replay_esn->oseq;\n\t__u32 oseq_hi = replay_esn->oseq_hi;\n\n\tif (!xo)\n\t\treturn xfrm_replay_overflow_esn(x, skb);\n\n\tif (x->type->flags & XFRM_TYPE_REPLAY_PROT) {\n\t\tif (!skb_is_gso(skb)) {\n\t\t\tXFRM_SKB_CB(skb)->seq.output.low = ++oseq;\n\t\t\tXFRM_SKB_CB(skb)->seq.output.hi = oseq_hi;\n\t\t\txo->seq.low = oseq;\n\t\t\txo->seq.hi = oseq_hi;\n\t\t} else {\n\t\t\tXFRM_SKB_CB(skb)->seq.output.low = oseq + 1;\n\t\t\tXFRM_SKB_CB(skb)->seq.output.hi = oseq_hi;\n\t\t\txo->seq.low = oseq + 1;\n\t\t\txo->seq.hi = oseq_hi;\n\t\t\toseq += skb_shinfo(skb)->gso_segs;\n\t\t}\n\n\t\tif (unlikely(xo->seq.low < replay_esn->oseq)) {\n\t\t\tXFRM_SKB_CB(skb)->seq.output.hi = ++oseq_hi;\n\t\t\txo->seq.hi = oseq_hi;\n\t\t\treplay_esn->oseq_hi = oseq_hi;\n\t\t\tif (replay_esn->oseq_hi == 0) {\n\t\t\t\treplay_esn->oseq--;\n\t\t\t\treplay_esn->oseq_hi--;\n\t\t\t\txfrm_audit_state_replay_overflow(x, skb);\n\t\t\t\terr = -EOVERFLOW;\n\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\treplay_esn->oseq = oseq;\n\n\t\tif (xfrm_aevent_is_on(net))\n\t\t\txfrm_replay_notify(x, XFRM_REPLAY_UPDATE);\n\t}\n\n\treturn err;\n}\n\nint xfrm_replay_overflow(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tswitch (x->repl_mode) {\n\tcase XFRM_REPLAY_MODE_LEGACY:\n\t\tbreak;\n\tcase XFRM_REPLAY_MODE_BMP:\n\t\treturn xfrm_replay_overflow_offload_bmp(x, skb);\n\tcase XFRM_REPLAY_MODE_ESN:\n\t\treturn xfrm_replay_overflow_offload_esn(x, skb);\n\t}\n\n\treturn xfrm_replay_overflow_offload(x, skb);\n}\n#else\nint xfrm_replay_overflow(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tswitch (x->repl_mode) {\n\tcase XFRM_REPLAY_MODE_LEGACY:\n\t\tbreak;\n\tcase XFRM_REPLAY_MODE_BMP:\n\t\treturn xfrm_replay_overflow_bmp(x, skb);\n\tcase XFRM_REPLAY_MODE_ESN:\n\t\treturn xfrm_replay_overflow_esn(x, skb);\n\t}\n\n\treturn __xfrm_replay_overflow(x, skb);\n}\n#endif\n\nint xfrm_init_replay(struct xfrm_state *x, struct netlink_ext_ack *extack)\n{\n\tstruct xfrm_replay_state_esn *replay_esn = x->replay_esn;\n\n\tif (replay_esn) {\n\t\tif (replay_esn->replay_window >\n\t\t    replay_esn->bmp_len * sizeof(__u32) * 8) {\n\t\t\tNL_SET_ERR_MSG(extack, \"ESN replay window is too large for the chosen bitmap size\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (x->props.flags & XFRM_STATE_ESN) {\n\t\t\tif (replay_esn->replay_window == 0) {\n\t\t\t\tNL_SET_ERR_MSG(extack, \"ESN replay window must be > 0\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tx->repl_mode = XFRM_REPLAY_MODE_ESN;\n\t\t} else {\n\t\t\tx->repl_mode = XFRM_REPLAY_MODE_BMP;\n\t\t}\n\t} else {\n\t\tx->repl_mode = XFRM_REPLAY_MODE_LEGACY;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(xfrm_init_replay);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}