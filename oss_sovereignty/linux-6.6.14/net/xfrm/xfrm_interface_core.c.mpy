{
  "module_name": "xfrm_interface_core.c",
  "hash_id": "78e094dc6151a250c4d60b5cffe18e9b6d51af281616d0dd8c95cb1392a87b98",
  "original_prompt": "Ingested from linux-6.6.14/net/xfrm/xfrm_interface_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/sockios.h>\n#include <linux/icmp.h>\n#include <linux/if.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_link.h>\n#include <linux/if_arp.h>\n#include <linux/icmpv6.h>\n#include <linux/init.h>\n#include <linux/route.h>\n#include <linux/rtnetlink.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n\n#include <linux/uaccess.h>\n#include <linux/atomic.h>\n\n#include <net/gso.h>\n#include <net/icmp.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/ip_tunnels.h>\n#include <net/addrconf.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/dst_metadata.h>\n#include <net/netns/generic.h>\n#include <linux/etherdevice.h>\n\nstatic int xfrmi_dev_init(struct net_device *dev);\nstatic void xfrmi_dev_setup(struct net_device *dev);\nstatic struct rtnl_link_ops xfrmi_link_ops __read_mostly;\nstatic unsigned int xfrmi_net_id __read_mostly;\nstatic const struct net_device_ops xfrmi_netdev_ops;\n\n#define XFRMI_HASH_BITS\t8\n#define XFRMI_HASH_SIZE\tBIT(XFRMI_HASH_BITS)\n\nstruct xfrmi_net {\n\t \n\tstruct xfrm_if __rcu *xfrmi[XFRMI_HASH_SIZE];\n\tstruct xfrm_if __rcu *collect_md_xfrmi;\n};\n\nstatic const struct nla_policy xfrm_lwt_policy[LWT_XFRM_MAX + 1] = {\n\t[LWT_XFRM_IF_ID]\t= NLA_POLICY_MIN(NLA_U32, 1),\n\t[LWT_XFRM_LINK]\t\t= NLA_POLICY_MIN(NLA_U32, 1),\n};\n\nstatic void xfrmi_destroy_state(struct lwtunnel_state *lwt)\n{\n}\n\nstatic int xfrmi_build_state(struct net *net, struct nlattr *nla,\n\t\t\t     unsigned int family, const void *cfg,\n\t\t\t     struct lwtunnel_state **ts,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[LWT_XFRM_MAX + 1];\n\tstruct lwtunnel_state *new_state;\n\tstruct xfrm_md_info *info;\n\tint ret;\n\n\tret = nla_parse_nested(tb, LWT_XFRM_MAX, nla, xfrm_lwt_policy, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!tb[LWT_XFRM_IF_ID]) {\n\t\tNL_SET_ERR_MSG(extack, \"if_id must be set\");\n\t\treturn -EINVAL;\n\t}\n\n\tnew_state = lwtunnel_state_alloc(sizeof(*info));\n\tif (!new_state) {\n\t\tNL_SET_ERR_MSG(extack, \"failed to create encap info\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_state->type = LWTUNNEL_ENCAP_XFRM;\n\n\tinfo = lwt_xfrm_info(new_state);\n\n\tinfo->if_id = nla_get_u32(tb[LWT_XFRM_IF_ID]);\n\n\tif (tb[LWT_XFRM_LINK])\n\t\tinfo->link = nla_get_u32(tb[LWT_XFRM_LINK]);\n\n\t*ts = new_state;\n\treturn 0;\n}\n\nstatic int xfrmi_fill_encap_info(struct sk_buff *skb,\n\t\t\t\t struct lwtunnel_state *lwt)\n{\n\tstruct xfrm_md_info *info = lwt_xfrm_info(lwt);\n\n\tif (nla_put_u32(skb, LWT_XFRM_IF_ID, info->if_id) ||\n\t    (info->link && nla_put_u32(skb, LWT_XFRM_LINK, info->link)))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int xfrmi_encap_nlsize(struct lwtunnel_state *lwtstate)\n{\n\treturn nla_total_size(sizeof(u32)) +  \n\t\tnla_total_size(sizeof(u32));  \n}\n\nstatic int xfrmi_encap_cmp(struct lwtunnel_state *a, struct lwtunnel_state *b)\n{\n\tstruct xfrm_md_info *a_info = lwt_xfrm_info(a);\n\tstruct xfrm_md_info *b_info = lwt_xfrm_info(b);\n\n\treturn memcmp(a_info, b_info, sizeof(*a_info));\n}\n\nstatic const struct lwtunnel_encap_ops xfrmi_encap_ops = {\n\t.build_state\t= xfrmi_build_state,\n\t.destroy_state\t= xfrmi_destroy_state,\n\t.fill_encap\t= xfrmi_fill_encap_info,\n\t.get_encap_size = xfrmi_encap_nlsize,\n\t.cmp_encap\t= xfrmi_encap_cmp,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#define for_each_xfrmi_rcu(start, xi) \\\n\tfor (xi = rcu_dereference(start); xi; xi = rcu_dereference(xi->next))\n\nstatic u32 xfrmi_hash(u32 if_id)\n{\n\treturn hash_32(if_id, XFRMI_HASH_BITS);\n}\n\nstatic struct xfrm_if *xfrmi_lookup(struct net *net, struct xfrm_state *x)\n{\n\tstruct xfrmi_net *xfrmn = net_generic(net, xfrmi_net_id);\n\tstruct xfrm_if *xi;\n\n\tfor_each_xfrmi_rcu(xfrmn->xfrmi[xfrmi_hash(x->if_id)], xi) {\n\t\tif (x->if_id == xi->p.if_id &&\n\t\t    (xi->dev->flags & IFF_UP))\n\t\t\treturn xi;\n\t}\n\n\txi = rcu_dereference(xfrmn->collect_md_xfrmi);\n\tif (xi && (xi->dev->flags & IFF_UP))\n\t\treturn xi;\n\n\treturn NULL;\n}\n\nstatic bool xfrmi_decode_session(struct sk_buff *skb,\n\t\t\t\t unsigned short family,\n\t\t\t\t struct xfrm_if_decode_session_result *res)\n{\n\tstruct net_device *dev;\n\tstruct xfrm_if *xi;\n\tint ifindex = 0;\n\n\tif (!secpath_exists(skb) || !skb->dev)\n\t\treturn false;\n\n\tswitch (family) {\n\tcase AF_INET6:\n\t\tifindex = inet6_sdif(skb);\n\t\tbreak;\n\tcase AF_INET:\n\t\tifindex = inet_sdif(skb);\n\t\tbreak;\n\t}\n\n\tif (ifindex) {\n\t\tstruct net *net = xs_net(xfrm_input_state(skb));\n\n\t\tdev = dev_get_by_index_rcu(net, ifindex);\n\t} else {\n\t\tdev = skb->dev;\n\t}\n\n\tif (!dev || !(dev->flags & IFF_UP))\n\t\treturn false;\n\tif (dev->netdev_ops != &xfrmi_netdev_ops)\n\t\treturn false;\n\n\txi = netdev_priv(dev);\n\tres->net = xi->net;\n\n\tif (xi->p.collect_md)\n\t\tres->if_id = xfrm_input_state(skb)->if_id;\n\telse\n\t\tres->if_id = xi->p.if_id;\n\treturn true;\n}\n\nstatic void xfrmi_link(struct xfrmi_net *xfrmn, struct xfrm_if *xi)\n{\n\tstruct xfrm_if __rcu **xip = &xfrmn->xfrmi[xfrmi_hash(xi->p.if_id)];\n\n\trcu_assign_pointer(xi->next , rtnl_dereference(*xip));\n\trcu_assign_pointer(*xip, xi);\n}\n\nstatic void xfrmi_unlink(struct xfrmi_net *xfrmn, struct xfrm_if *xi)\n{\n\tstruct xfrm_if __rcu **xip;\n\tstruct xfrm_if *iter;\n\n\tfor (xip = &xfrmn->xfrmi[xfrmi_hash(xi->p.if_id)];\n\t     (iter = rtnl_dereference(*xip)) != NULL;\n\t     xip = &iter->next) {\n\t\tif (xi == iter) {\n\t\t\trcu_assign_pointer(*xip, xi->next);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void xfrmi_dev_free(struct net_device *dev)\n{\n\tstruct xfrm_if *xi = netdev_priv(dev);\n\n\tgro_cells_destroy(&xi->gro_cells);\n\tfree_percpu(dev->tstats);\n}\n\nstatic int xfrmi_create(struct net_device *dev)\n{\n\tstruct xfrm_if *xi = netdev_priv(dev);\n\tstruct net *net = dev_net(dev);\n\tstruct xfrmi_net *xfrmn = net_generic(net, xfrmi_net_id);\n\tint err;\n\n\tdev->rtnl_link_ops = &xfrmi_link_ops;\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (xi->p.collect_md)\n\t\trcu_assign_pointer(xfrmn->collect_md_xfrmi, xi);\n\telse\n\t\txfrmi_link(xfrmn, xi);\n\n\treturn 0;\n\nout:\n\treturn err;\n}\n\nstatic struct xfrm_if *xfrmi_locate(struct net *net, struct xfrm_if_parms *p)\n{\n\tstruct xfrm_if __rcu **xip;\n\tstruct xfrm_if *xi;\n\tstruct xfrmi_net *xfrmn = net_generic(net, xfrmi_net_id);\n\n\tfor (xip = &xfrmn->xfrmi[xfrmi_hash(p->if_id)];\n\t     (xi = rtnl_dereference(*xip)) != NULL;\n\t     xip = &xi->next)\n\t\tif (xi->p.if_id == p->if_id)\n\t\t\treturn xi;\n\n\treturn NULL;\n}\n\nstatic void xfrmi_dev_uninit(struct net_device *dev)\n{\n\tstruct xfrm_if *xi = netdev_priv(dev);\n\tstruct xfrmi_net *xfrmn = net_generic(xi->net, xfrmi_net_id);\n\n\tif (xi->p.collect_md)\n\t\tRCU_INIT_POINTER(xfrmn->collect_md_xfrmi, NULL);\n\telse\n\t\txfrmi_unlink(xfrmn, xi);\n}\n\nstatic void xfrmi_scrub_packet(struct sk_buff *skb, bool xnet)\n{\n\tskb_clear_tstamp(skb);\n\tskb->pkt_type = PACKET_HOST;\n\tskb->skb_iif = 0;\n\tskb->ignore_df = 0;\n\tskb_dst_drop(skb);\n\tnf_reset_ct(skb);\n\tnf_reset_trace(skb);\n\n\tif (!xnet)\n\t\treturn;\n\n\tipvs_reset(skb);\n\tsecpath_reset(skb);\n\tskb_orphan(skb);\n\tskb->mark = 0;\n}\n\nstatic int xfrmi_input(struct sk_buff *skb, int nexthdr, __be32 spi,\n\t\t       int encap_type, unsigned short family)\n{\n\tstruct sec_path *sp;\n\n\tsp = skb_sec_path(skb);\n\tif (sp && (sp->len || sp->olen) &&\n\t    !xfrm_policy_check(NULL, XFRM_POLICY_IN, skb, family))\n\t\tgoto discard;\n\n\tXFRM_SPI_SKB_CB(skb)->family = family;\n\tif (family == AF_INET) {\n\t\tXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);\n\t\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;\n\t} else {\n\t\tXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct ipv6hdr, daddr);\n\t\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6 = NULL;\n\t}\n\n\treturn xfrm_input(skb, nexthdr, spi, encap_type);\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int xfrmi4_rcv(struct sk_buff *skb)\n{\n\treturn xfrmi_input(skb, ip_hdr(skb)->protocol, 0, 0, AF_INET);\n}\n\nstatic int xfrmi6_rcv(struct sk_buff *skb)\n{\n\treturn xfrmi_input(skb, skb_network_header(skb)[IP6CB(skb)->nhoff],\n\t\t\t   0, 0, AF_INET6);\n}\n\nstatic int xfrmi4_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type)\n{\n\treturn xfrmi_input(skb, nexthdr, spi, encap_type, AF_INET);\n}\n\nstatic int xfrmi6_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type)\n{\n\treturn xfrmi_input(skb, nexthdr, spi, encap_type, AF_INET6);\n}\n\nstatic int xfrmi_rcv_cb(struct sk_buff *skb, int err)\n{\n\tconst struct xfrm_mode *inner_mode;\n\tstruct net_device *dev;\n\tstruct xfrm_state *x;\n\tstruct xfrm_if *xi;\n\tbool xnet;\n\tint link;\n\n\tif (err && !secpath_exists(skb))\n\t\treturn 0;\n\n\tx = xfrm_input_state(skb);\n\n\txi = xfrmi_lookup(xs_net(x), x);\n\tif (!xi)\n\t\treturn 1;\n\n\tlink = skb->dev->ifindex;\n\tdev = xi->dev;\n\tskb->dev = dev;\n\n\tif (err) {\n\t\tDEV_STATS_INC(dev, rx_errors);\n\t\tDEV_STATS_INC(dev, rx_dropped);\n\n\t\treturn 0;\n\t}\n\n\txnet = !net_eq(xi->net, dev_net(skb->dev));\n\n\tif (xnet) {\n\t\tinner_mode = &x->inner_mode;\n\n\t\tif (x->sel.family == AF_UNSPEC) {\n\t\t\tinner_mode = xfrm_ip2inner_mode(x, XFRM_MODE_SKB_CB(skb)->protocol);\n\t\t\tif (inner_mode == NULL) {\n\t\t\t\tXFRM_INC_STATS(dev_net(skb->dev),\n\t\t\t\t\t       LINUX_MIB_XFRMINSTATEMODEERROR);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (!xfrm_policy_check(NULL, XFRM_POLICY_IN, skb,\n\t\t\t\t       inner_mode->family))\n\t\t\treturn -EPERM;\n\t}\n\n\txfrmi_scrub_packet(skb, xnet);\n\tif (xi->p.collect_md) {\n\t\tstruct metadata_dst *md_dst;\n\n\t\tmd_dst = metadata_dst_alloc(0, METADATA_XFRM, GFP_ATOMIC);\n\t\tif (!md_dst)\n\t\t\treturn -ENOMEM;\n\n\t\tmd_dst->u.xfrm_info.if_id = x->if_id;\n\t\tmd_dst->u.xfrm_info.link = link;\n\t\tskb_dst_set(skb, (struct dst_entry *)md_dst);\n\t}\n\tdev_sw_netstats_rx_add(dev, skb->len);\n\n\treturn 0;\n}\n\nstatic int\nxfrmi_xmit2(struct sk_buff *skb, struct net_device *dev, struct flowi *fl)\n{\n\tstruct xfrm_if *xi = netdev_priv(dev);\n\tstruct dst_entry *dst = skb_dst(skb);\n\tunsigned int length = skb->len;\n\tstruct net_device *tdev;\n\tstruct xfrm_state *x;\n\tint err = -1;\n\tu32 if_id;\n\tint mtu;\n\n\tif (xi->p.collect_md) {\n\t\tstruct xfrm_md_info *md_info = skb_xfrm_md_info(skb);\n\n\t\tif (unlikely(!md_info))\n\t\t\treturn -EINVAL;\n\n\t\tif_id = md_info->if_id;\n\t\tfl->flowi_oif = md_info->link;\n\t\tif (md_info->dst_orig) {\n\t\t\tstruct dst_entry *tmp_dst = dst;\n\n\t\t\tdst = md_info->dst_orig;\n\t\t\tskb_dst_set(skb, dst);\n\t\t\tmd_info->dst_orig = NULL;\n\t\t\tdst_release(tmp_dst);\n\t\t}\n\t} else {\n\t\tif_id = xi->p.if_id;\n\t}\n\n\tdst_hold(dst);\n\tdst = xfrm_lookup_with_ifid(xi->net, dst, fl, NULL, 0, if_id);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto tx_err_link_failure;\n\t}\n\n\tx = dst->xfrm;\n\tif (!x)\n\t\tgoto tx_err_link_failure;\n\n\tif (x->if_id != if_id)\n\t\tgoto tx_err_link_failure;\n\n\ttdev = dst->dev;\n\n\tif (tdev == dev) {\n\t\tDEV_STATS_INC(dev, collisions);\n\t\tnet_warn_ratelimited(\"%s: Local routing loop detected!\\n\",\n\t\t\t\t     dev->name);\n\t\tgoto tx_err_dst_release;\n\t}\n\n\tmtu = dst_mtu(dst);\n\tif ((!skb_is_gso(skb) && skb->len > mtu) ||\n\t    (skb_is_gso(skb) && !skb_gso_validate_network_len(skb, mtu))) {\n\t\tskb_dst_update_pmtu_no_confirm(skb, mtu);\n\n\t\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\t\tmtu = IPV6_MIN_MTU;\n\n\t\t\tif (skb->len > 1280)\n\t\t\t\ticmpv6_ndo_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\t\telse\n\t\t\t\tgoto xmit;\n\t\t} else {\n\t\t\tif (!(ip_hdr(skb)->frag_off & htons(IP_DF)))\n\t\t\t\tgoto xmit;\n\t\t\ticmp_ndo_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\n\t\t\t\t      htonl(mtu));\n\t\t}\n\n\t\tdst_release(dst);\n\t\treturn -EMSGSIZE;\n\t}\n\nxmit:\n\txfrmi_scrub_packet(skb, !net_eq(xi->net, dev_net(dev)));\n\tskb_dst_set(skb, dst);\n\tskb->dev = tdev;\n\n\terr = dst_output(xi->net, skb->sk, skb);\n\tif (net_xmit_eval(err) == 0) {\n\t\tdev_sw_netstats_tx_add(dev, 1, length);\n\t} else {\n\t\tDEV_STATS_INC(dev, tx_errors);\n\t\tDEV_STATS_INC(dev, tx_aborted_errors);\n\t}\n\n\treturn 0;\ntx_err_link_failure:\n\tDEV_STATS_INC(dev, tx_carrier_errors);\n\tdst_link_failure(skb);\ntx_err_dst_release:\n\tdst_release(dst);\n\treturn err;\n}\n\nstatic netdev_tx_t xfrmi_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct xfrm_if *xi = netdev_priv(dev);\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct flowi fl;\n\tint ret;\n\n\tmemset(&fl, 0, sizeof(fl));\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IPV6):\n\t\tmemset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));\n\t\txfrm_decode_session(skb, &fl, AF_INET6);\n\t\tif (!dst) {\n\t\t\tfl.u.ip6.flowi6_oif = dev->ifindex;\n\t\t\tfl.u.ip6.flowi6_flags |= FLOWI_FLAG_ANYSRC;\n\t\t\tdst = ip6_route_output(dev_net(dev), NULL, &fl.u.ip6);\n\t\t\tif (dst->error) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\t\t\tgoto tx_err;\n\t\t\t}\n\t\t\tskb_dst_set(skb, dst);\n\t\t}\n\t\tbreak;\n\tcase htons(ETH_P_IP):\n\t\tmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\n\t\txfrm_decode_session(skb, &fl, AF_INET);\n\t\tif (!dst) {\n\t\t\tstruct rtable *rt;\n\n\t\t\tfl.u.ip4.flowi4_oif = dev->ifindex;\n\t\t\tfl.u.ip4.flowi4_flags |= FLOWI_FLAG_ANYSRC;\n\t\t\trt = __ip_route_output_key(dev_net(dev), &fl.u.ip4);\n\t\t\tif (IS_ERR(rt)) {\n\t\t\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\t\t\tgoto tx_err;\n\t\t\t}\n\t\t\tskb_dst_set(skb, &rt->dst);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto tx_err;\n\t}\n\n\tfl.flowi_oif = xi->p.link;\n\n\tret = xfrmi_xmit2(skb, dev, &fl);\n\tif (ret < 0)\n\t\tgoto tx_err;\n\n\treturn NETDEV_TX_OK;\n\ntx_err:\n\tDEV_STATS_INC(dev, tx_errors);\n\tDEV_STATS_INC(dev, tx_dropped);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int xfrmi4_err(struct sk_buff *skb, u32 info)\n{\n\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\tstruct net *net = dev_net(skb->dev);\n\tint protocol = iph->protocol;\n\tstruct ip_comp_hdr *ipch;\n\tstruct ip_esp_hdr *esph;\n\tstruct ip_auth_hdr *ah ;\n\tstruct xfrm_state *x;\n\tstruct xfrm_if *xi;\n\t__be32 spi;\n\n\tswitch (protocol) {\n\tcase IPPROTO_ESP:\n\t\tesph = (struct ip_esp_hdr *)(skb->data+(iph->ihl<<2));\n\t\tspi = esph->spi;\n\t\tbreak;\n\tcase IPPROTO_AH:\n\t\tah = (struct ip_auth_hdr *)(skb->data+(iph->ihl<<2));\n\t\tspi = ah->spi;\n\t\tbreak;\n\tcase IPPROTO_COMP:\n\t\tipch = (struct ip_comp_hdr *)(skb->data+(iph->ihl<<2));\n\t\tspi = htonl(ntohs(ipch->cpi));\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tswitch (icmp_hdr(skb)->type) {\n\tcase ICMP_DEST_UNREACH:\n\t\tif (icmp_hdr(skb)->code != ICMP_FRAG_NEEDED)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase ICMP_REDIRECT:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tx = xfrm_state_lookup(net, skb->mark, (const xfrm_address_t *)&iph->daddr,\n\t\t\t      spi, protocol, AF_INET);\n\tif (!x)\n\t\treturn 0;\n\n\txi = xfrmi_lookup(net, x);\n\tif (!xi) {\n\t\txfrm_state_put(x);\n\t\treturn -1;\n\t}\n\n\tif (icmp_hdr(skb)->type == ICMP_DEST_UNREACH)\n\t\tipv4_update_pmtu(skb, net, info, 0, protocol);\n\telse\n\t\tipv4_redirect(skb, net, 0, protocol);\n\txfrm_state_put(x);\n\n\treturn 0;\n}\n\nstatic int xfrmi6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t    u8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *iph = (const struct ipv6hdr *)skb->data;\n\tstruct net *net = dev_net(skb->dev);\n\tint protocol = iph->nexthdr;\n\tstruct ip_comp_hdr *ipch;\n\tstruct ip_esp_hdr *esph;\n\tstruct ip_auth_hdr *ah;\n\tstruct xfrm_state *x;\n\tstruct xfrm_if *xi;\n\t__be32 spi;\n\n\tswitch (protocol) {\n\tcase IPPROTO_ESP:\n\t\tesph = (struct ip_esp_hdr *)(skb->data + offset);\n\t\tspi = esph->spi;\n\t\tbreak;\n\tcase IPPROTO_AH:\n\t\tah = (struct ip_auth_hdr *)(skb->data + offset);\n\t\tspi = ah->spi;\n\t\tbreak;\n\tcase IPPROTO_COMP:\n\t\tipch = (struct ip_comp_hdr *)(skb->data + offset);\n\t\tspi = htonl(ntohs(ipch->cpi));\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (type != ICMPV6_PKT_TOOBIG &&\n\t    type != NDISC_REDIRECT)\n\t\treturn 0;\n\n\tx = xfrm_state_lookup(net, skb->mark, (const xfrm_address_t *)&iph->daddr,\n\t\t\t      spi, protocol, AF_INET6);\n\tif (!x)\n\t\treturn 0;\n\n\txi = xfrmi_lookup(net, x);\n\tif (!xi) {\n\t\txfrm_state_put(x);\n\t\treturn -1;\n\t}\n\n\tif (type == NDISC_REDIRECT)\n\t\tip6_redirect(skb, net, skb->dev->ifindex, 0,\n\t\t\t     sock_net_uid(net, NULL));\n\telse\n\t\tip6_update_pmtu(skb, net, info, 0, 0, sock_net_uid(net, NULL));\n\txfrm_state_put(x);\n\n\treturn 0;\n}\n\nstatic int xfrmi_change(struct xfrm_if *xi, const struct xfrm_if_parms *p)\n{\n\tif (xi->p.link != p->link)\n\t\treturn -EINVAL;\n\n\txi->p.if_id = p->if_id;\n\n\treturn 0;\n}\n\nstatic int xfrmi_update(struct xfrm_if *xi, struct xfrm_if_parms *p)\n{\n\tstruct net *net = xi->net;\n\tstruct xfrmi_net *xfrmn = net_generic(net, xfrmi_net_id);\n\tint err;\n\n\txfrmi_unlink(xfrmn, xi);\n\tsynchronize_net();\n\terr = xfrmi_change(xi, p);\n\txfrmi_link(xfrmn, xi);\n\tnetdev_state_change(xi->dev);\n\treturn err;\n}\n\nstatic int xfrmi_get_iflink(const struct net_device *dev)\n{\n\tstruct xfrm_if *xi = netdev_priv(dev);\n\n\treturn xi->p.link;\n}\n\nstatic const struct net_device_ops xfrmi_netdev_ops = {\n\t.ndo_init\t= xfrmi_dev_init,\n\t.ndo_uninit\t= xfrmi_dev_uninit,\n\t.ndo_start_xmit = xfrmi_xmit,\n\t.ndo_get_stats64 = dev_get_tstats64,\n\t.ndo_get_iflink = xfrmi_get_iflink,\n};\n\nstatic void xfrmi_dev_setup(struct net_device *dev)\n{\n\tdev->netdev_ops \t= &xfrmi_netdev_ops;\n\tdev->header_ops\t\t= &ip_tunnel_header_ops;\n\tdev->type\t\t= ARPHRD_NONE;\n\tdev->mtu\t\t= ETH_DATA_LEN;\n\tdev->min_mtu\t\t= ETH_MIN_MTU;\n\tdev->max_mtu\t\t= IP_MAX_MTU;\n\tdev->flags \t\t= IFF_NOARP;\n\tdev->needs_free_netdev\t= true;\n\tdev->priv_destructor\t= xfrmi_dev_free;\n\tnetif_keep_dst(dev);\n\n\teth_broadcast_addr(dev->broadcast);\n}\n\n#define XFRMI_FEATURES (NETIF_F_SG |\t\t\\\n\t\t\tNETIF_F_FRAGLIST |\t\\\n\t\t\tNETIF_F_GSO_SOFTWARE |\t\\\n\t\t\tNETIF_F_HW_CSUM)\n\nstatic int xfrmi_dev_init(struct net_device *dev)\n{\n\tstruct xfrm_if *xi = netdev_priv(dev);\n\tstruct net_device *phydev = __dev_get_by_index(xi->net, xi->p.link);\n\tint err;\n\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\terr = gro_cells_init(&xi->gro_cells, dev);\n\tif (err) {\n\t\tfree_percpu(dev->tstats);\n\t\treturn err;\n\t}\n\n\tdev->features |= NETIF_F_LLTX;\n\tdev->features |= XFRMI_FEATURES;\n\tdev->hw_features |= XFRMI_FEATURES;\n\n\tif (phydev) {\n\t\tdev->needed_headroom = phydev->needed_headroom;\n\t\tdev->needed_tailroom = phydev->needed_tailroom;\n\n\t\tif (is_zero_ether_addr(dev->dev_addr))\n\t\t\teth_hw_addr_inherit(dev, phydev);\n\t\tif (is_zero_ether_addr(dev->broadcast))\n\t\t\tmemcpy(dev->broadcast, phydev->broadcast,\n\t\t\t       dev->addr_len);\n\t} else {\n\t\teth_hw_addr_random(dev);\n\t\teth_broadcast_addr(dev->broadcast);\n\t}\n\n\treturn 0;\n}\n\nstatic int xfrmi_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn 0;\n}\n\nstatic void xfrmi_netlink_parms(struct nlattr *data[],\n\t\t\t       struct xfrm_if_parms *parms)\n{\n\tmemset(parms, 0, sizeof(*parms));\n\n\tif (!data)\n\t\treturn;\n\n\tif (data[IFLA_XFRM_LINK])\n\t\tparms->link = nla_get_u32(data[IFLA_XFRM_LINK]);\n\n\tif (data[IFLA_XFRM_IF_ID])\n\t\tparms->if_id = nla_get_u32(data[IFLA_XFRM_IF_ID]);\n\n\tif (data[IFLA_XFRM_COLLECT_METADATA])\n\t\tparms->collect_md = true;\n}\n\nstatic int xfrmi_newlink(struct net *src_net, struct net_device *dev,\n\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct xfrm_if_parms p = {};\n\tstruct xfrm_if *xi;\n\tint err;\n\n\txfrmi_netlink_parms(data, &p);\n\tif (p.collect_md) {\n\t\tstruct xfrmi_net *xfrmn = net_generic(net, xfrmi_net_id);\n\n\t\tif (p.link || p.if_id) {\n\t\t\tNL_SET_ERR_MSG(extack, \"link and if_id must be zero\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rtnl_dereference(xfrmn->collect_md_xfrmi))\n\t\t\treturn -EEXIST;\n\n\t} else {\n\t\tif (!p.if_id) {\n\t\t\tNL_SET_ERR_MSG(extack, \"if_id must be non zero\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\txi = xfrmi_locate(net, &p);\n\t\tif (xi)\n\t\t\treturn -EEXIST;\n\t}\n\n\txi = netdev_priv(dev);\n\txi->p = p;\n\txi->net = net;\n\txi->dev = dev;\n\n\terr = xfrmi_create(dev);\n\treturn err;\n}\n\nstatic void xfrmi_dellink(struct net_device *dev, struct list_head *head)\n{\n\tunregister_netdevice_queue(dev, head);\n}\n\nstatic int xfrmi_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t   struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct xfrm_if *xi = netdev_priv(dev);\n\tstruct net *net = xi->net;\n\tstruct xfrm_if_parms p = {};\n\n\txfrmi_netlink_parms(data, &p);\n\tif (!p.if_id) {\n\t\tNL_SET_ERR_MSG(extack, \"if_id must be non zero\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (p.collect_md) {\n\t\tNL_SET_ERR_MSG(extack, \"collect_md can't be changed\");\n\t\treturn -EINVAL;\n\t}\n\n\txi = xfrmi_locate(net, &p);\n\tif (!xi) {\n\t\txi = netdev_priv(dev);\n\t} else {\n\t\tif (xi->dev != dev)\n\t\t\treturn -EEXIST;\n\t\tif (xi->p.collect_md) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"device can't be changed to collect_md\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn xfrmi_update(xi, &p);\n}\n\nstatic size_t xfrmi_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(0) +\n\t\t0;\n}\n\nstatic int xfrmi_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct xfrm_if *xi = netdev_priv(dev);\n\tstruct xfrm_if_parms *parm = &xi->p;\n\n\tif (nla_put_u32(skb, IFLA_XFRM_LINK, parm->link) ||\n\t    nla_put_u32(skb, IFLA_XFRM_IF_ID, parm->if_id) ||\n\t    (xi->p.collect_md && nla_put_flag(skb, IFLA_XFRM_COLLECT_METADATA)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic struct net *xfrmi_get_link_net(const struct net_device *dev)\n{\n\tstruct xfrm_if *xi = netdev_priv(dev);\n\n\treturn xi->net;\n}\n\nstatic const struct nla_policy xfrmi_policy[IFLA_XFRM_MAX + 1] = {\n\t[IFLA_XFRM_UNSPEC]\t\t= { .strict_start_type = IFLA_XFRM_COLLECT_METADATA },\n\t[IFLA_XFRM_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_XFRM_IF_ID]\t\t= { .type = NLA_U32 },\n\t[IFLA_XFRM_COLLECT_METADATA]\t= { .type = NLA_FLAG },\n};\n\nstatic struct rtnl_link_ops xfrmi_link_ops __read_mostly = {\n\t.kind\t\t= \"xfrm\",\n\t.maxtype\t= IFLA_XFRM_MAX,\n\t.policy\t\t= xfrmi_policy,\n\t.priv_size\t= sizeof(struct xfrm_if),\n\t.setup\t\t= xfrmi_dev_setup,\n\t.validate\t= xfrmi_validate,\n\t.newlink\t= xfrmi_newlink,\n\t.dellink\t= xfrmi_dellink,\n\t.changelink\t= xfrmi_changelink,\n\t.get_size\t= xfrmi_get_size,\n\t.fill_info\t= xfrmi_fill_info,\n\t.get_link_net\t= xfrmi_get_link_net,\n};\n\nstatic void __net_exit xfrmi_exit_batch_net(struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\tLIST_HEAD(list);\n\n\trtnl_lock();\n\tlist_for_each_entry(net, net_exit_list, exit_list) {\n\t\tstruct xfrmi_net *xfrmn = net_generic(net, xfrmi_net_id);\n\t\tstruct xfrm_if __rcu **xip;\n\t\tstruct xfrm_if *xi;\n\t\tint i;\n\n\t\tfor (i = 0; i < XFRMI_HASH_SIZE; i++) {\n\t\t\tfor (xip = &xfrmn->xfrmi[i];\n\t\t\t     (xi = rtnl_dereference(*xip)) != NULL;\n\t\t\t     xip = &xi->next)\n\t\t\t\tunregister_netdevice_queue(xi->dev, &list);\n\t\t}\n\t\txi = rtnl_dereference(xfrmn->collect_md_xfrmi);\n\t\tif (xi)\n\t\t\tunregister_netdevice_queue(xi->dev, &list);\n\t}\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations xfrmi_net_ops = {\n\t.exit_batch = xfrmi_exit_batch_net,\n\t.id   = &xfrmi_net_id,\n\t.size = sizeof(struct xfrmi_net),\n};\n\nstatic struct xfrm6_protocol xfrmi_esp6_protocol __read_mostly = {\n\t.handler\t=\txfrmi6_rcv,\n\t.input_handler\t=\txfrmi6_input,\n\t.cb_handler\t=\txfrmi_rcv_cb,\n\t.err_handler\t=\txfrmi6_err,\n\t.priority\t=\t10,\n};\n\nstatic struct xfrm6_protocol xfrmi_ah6_protocol __read_mostly = {\n\t.handler\t=\txfrm6_rcv,\n\t.input_handler\t=\txfrm_input,\n\t.cb_handler\t=\txfrmi_rcv_cb,\n\t.err_handler\t=\txfrmi6_err,\n\t.priority\t=\t10,\n};\n\nstatic struct xfrm6_protocol xfrmi_ipcomp6_protocol __read_mostly = {\n\t.handler\t=\txfrm6_rcv,\n\t.input_handler\t=\txfrm_input,\n\t.cb_handler\t=\txfrmi_rcv_cb,\n\t.err_handler\t=\txfrmi6_err,\n\t.priority\t=\t10,\n};\n\n#if IS_REACHABLE(CONFIG_INET6_XFRM_TUNNEL)\nstatic int xfrmi6_rcv_tunnel(struct sk_buff *skb)\n{\n\tconst xfrm_address_t *saddr;\n\t__be32 spi;\n\n\tsaddr = (const xfrm_address_t *)&ipv6_hdr(skb)->saddr;\n\tspi = xfrm6_tunnel_spi_lookup(dev_net(skb->dev), saddr);\n\n\treturn xfrm6_rcv_spi(skb, IPPROTO_IPV6, spi, NULL);\n}\n\nstatic struct xfrm6_tunnel xfrmi_ipv6_handler __read_mostly = {\n\t.handler\t=\txfrmi6_rcv_tunnel,\n\t.cb_handler\t=\txfrmi_rcv_cb,\n\t.err_handler\t=\txfrmi6_err,\n\t.priority\t=\t2,\n};\n\nstatic struct xfrm6_tunnel xfrmi_ip6ip_handler __read_mostly = {\n\t.handler\t=\txfrmi6_rcv_tunnel,\n\t.cb_handler\t=\txfrmi_rcv_cb,\n\t.err_handler\t=\txfrmi6_err,\n\t.priority\t=\t2,\n};\n#endif\n\nstatic struct xfrm4_protocol xfrmi_esp4_protocol __read_mostly = {\n\t.handler\t=\txfrmi4_rcv,\n\t.input_handler\t=\txfrmi4_input,\n\t.cb_handler\t=\txfrmi_rcv_cb,\n\t.err_handler\t=\txfrmi4_err,\n\t.priority\t=\t10,\n};\n\nstatic struct xfrm4_protocol xfrmi_ah4_protocol __read_mostly = {\n\t.handler\t=\txfrm4_rcv,\n\t.input_handler\t=\txfrm_input,\n\t.cb_handler\t=\txfrmi_rcv_cb,\n\t.err_handler\t=\txfrmi4_err,\n\t.priority\t=\t10,\n};\n\nstatic struct xfrm4_protocol xfrmi_ipcomp4_protocol __read_mostly = {\n\t.handler\t=\txfrm4_rcv,\n\t.input_handler\t=\txfrm_input,\n\t.cb_handler\t=\txfrmi_rcv_cb,\n\t.err_handler\t=\txfrmi4_err,\n\t.priority\t=\t10,\n};\n\n#if IS_REACHABLE(CONFIG_INET_XFRM_TUNNEL)\nstatic int xfrmi4_rcv_tunnel(struct sk_buff *skb)\n{\n\treturn xfrm4_rcv_spi(skb, IPPROTO_IPIP, ip_hdr(skb)->saddr);\n}\n\nstatic struct xfrm_tunnel xfrmi_ipip_handler __read_mostly = {\n\t.handler\t=\txfrmi4_rcv_tunnel,\n\t.cb_handler\t=\txfrmi_rcv_cb,\n\t.err_handler\t=\txfrmi4_err,\n\t.priority\t=\t3,\n};\n\nstatic struct xfrm_tunnel xfrmi_ipip6_handler __read_mostly = {\n\t.handler\t=\txfrmi4_rcv_tunnel,\n\t.cb_handler\t=\txfrmi_rcv_cb,\n\t.err_handler\t=\txfrmi4_err,\n\t.priority\t=\t2,\n};\n#endif\n\nstatic int __init xfrmi4_init(void)\n{\n\tint err;\n\n\terr = xfrm4_protocol_register(&xfrmi_esp4_protocol, IPPROTO_ESP);\n\tif (err < 0)\n\t\tgoto xfrm_proto_esp_failed;\n\terr = xfrm4_protocol_register(&xfrmi_ah4_protocol, IPPROTO_AH);\n\tif (err < 0)\n\t\tgoto xfrm_proto_ah_failed;\n\terr = xfrm4_protocol_register(&xfrmi_ipcomp4_protocol, IPPROTO_COMP);\n\tif (err < 0)\n\t\tgoto xfrm_proto_comp_failed;\n#if IS_REACHABLE(CONFIG_INET_XFRM_TUNNEL)\n\terr = xfrm4_tunnel_register(&xfrmi_ipip_handler, AF_INET);\n\tif (err < 0)\n\t\tgoto xfrm_tunnel_ipip_failed;\n\terr = xfrm4_tunnel_register(&xfrmi_ipip6_handler, AF_INET6);\n\tif (err < 0)\n\t\tgoto xfrm_tunnel_ipip6_failed;\n#endif\n\n\treturn 0;\n\n#if IS_REACHABLE(CONFIG_INET_XFRM_TUNNEL)\nxfrm_tunnel_ipip6_failed:\n\txfrm4_tunnel_deregister(&xfrmi_ipip_handler, AF_INET);\nxfrm_tunnel_ipip_failed:\n\txfrm4_protocol_deregister(&xfrmi_ipcomp4_protocol, IPPROTO_COMP);\n#endif\nxfrm_proto_comp_failed:\n\txfrm4_protocol_deregister(&xfrmi_ah4_protocol, IPPROTO_AH);\nxfrm_proto_ah_failed:\n\txfrm4_protocol_deregister(&xfrmi_esp4_protocol, IPPROTO_ESP);\nxfrm_proto_esp_failed:\n\treturn err;\n}\n\nstatic void xfrmi4_fini(void)\n{\n#if IS_REACHABLE(CONFIG_INET_XFRM_TUNNEL)\n\txfrm4_tunnel_deregister(&xfrmi_ipip6_handler, AF_INET6);\n\txfrm4_tunnel_deregister(&xfrmi_ipip_handler, AF_INET);\n#endif\n\txfrm4_protocol_deregister(&xfrmi_ipcomp4_protocol, IPPROTO_COMP);\n\txfrm4_protocol_deregister(&xfrmi_ah4_protocol, IPPROTO_AH);\n\txfrm4_protocol_deregister(&xfrmi_esp4_protocol, IPPROTO_ESP);\n}\n\nstatic int __init xfrmi6_init(void)\n{\n\tint err;\n\n\terr = xfrm6_protocol_register(&xfrmi_esp6_protocol, IPPROTO_ESP);\n\tif (err < 0)\n\t\tgoto xfrm_proto_esp_failed;\n\terr = xfrm6_protocol_register(&xfrmi_ah6_protocol, IPPROTO_AH);\n\tif (err < 0)\n\t\tgoto xfrm_proto_ah_failed;\n\terr = xfrm6_protocol_register(&xfrmi_ipcomp6_protocol, IPPROTO_COMP);\n\tif (err < 0)\n\t\tgoto xfrm_proto_comp_failed;\n#if IS_REACHABLE(CONFIG_INET6_XFRM_TUNNEL)\n\terr = xfrm6_tunnel_register(&xfrmi_ipv6_handler, AF_INET6);\n\tif (err < 0)\n\t\tgoto xfrm_tunnel_ipv6_failed;\n\terr = xfrm6_tunnel_register(&xfrmi_ip6ip_handler, AF_INET);\n\tif (err < 0)\n\t\tgoto xfrm_tunnel_ip6ip_failed;\n#endif\n\n\treturn 0;\n\n#if IS_REACHABLE(CONFIG_INET6_XFRM_TUNNEL)\nxfrm_tunnel_ip6ip_failed:\n\txfrm6_tunnel_deregister(&xfrmi_ipv6_handler, AF_INET6);\nxfrm_tunnel_ipv6_failed:\n\txfrm6_protocol_deregister(&xfrmi_ipcomp6_protocol, IPPROTO_COMP);\n#endif\nxfrm_proto_comp_failed:\n\txfrm6_protocol_deregister(&xfrmi_ah6_protocol, IPPROTO_AH);\nxfrm_proto_ah_failed:\n\txfrm6_protocol_deregister(&xfrmi_esp6_protocol, IPPROTO_ESP);\nxfrm_proto_esp_failed:\n\treturn err;\n}\n\nstatic void xfrmi6_fini(void)\n{\n#if IS_REACHABLE(CONFIG_INET6_XFRM_TUNNEL)\n\txfrm6_tunnel_deregister(&xfrmi_ip6ip_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrmi_ipv6_handler, AF_INET6);\n#endif\n\txfrm6_protocol_deregister(&xfrmi_ipcomp6_protocol, IPPROTO_COMP);\n\txfrm6_protocol_deregister(&xfrmi_ah6_protocol, IPPROTO_AH);\n\txfrm6_protocol_deregister(&xfrmi_esp6_protocol, IPPROTO_ESP);\n}\n\nstatic const struct xfrm_if_cb xfrm_if_cb = {\n\t.decode_session =\txfrmi_decode_session,\n};\n\nstatic int __init xfrmi_init(void)\n{\n\tconst char *msg;\n\tint err;\n\n\tpr_info(\"IPsec XFRM device driver\\n\");\n\n\tmsg = \"tunnel device\";\n\terr = register_pernet_device(&xfrmi_net_ops);\n\tif (err < 0)\n\t\tgoto pernet_dev_failed;\n\n\tmsg = \"xfrm4 protocols\";\n\terr = xfrmi4_init();\n\tif (err < 0)\n\t\tgoto xfrmi4_failed;\n\n\tmsg = \"xfrm6 protocols\";\n\terr = xfrmi6_init();\n\tif (err < 0)\n\t\tgoto xfrmi6_failed;\n\n\n\tmsg = \"netlink interface\";\n\terr = rtnl_link_register(&xfrmi_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\n\terr = register_xfrm_interface_bpf();\n\tif (err < 0)\n\t\tgoto kfunc_failed;\n\n\tlwtunnel_encap_add_ops(&xfrmi_encap_ops, LWTUNNEL_ENCAP_XFRM);\n\n\txfrm_if_register_cb(&xfrm_if_cb);\n\n\treturn err;\n\nkfunc_failed:\n\trtnl_link_unregister(&xfrmi_link_ops);\nrtnl_link_failed:\n\txfrmi6_fini();\nxfrmi6_failed:\n\txfrmi4_fini();\nxfrmi4_failed:\n\tunregister_pernet_device(&xfrmi_net_ops);\npernet_dev_failed:\n\tpr_err(\"xfrmi init: failed to register %s\\n\", msg);\n\treturn err;\n}\n\nstatic void __exit xfrmi_fini(void)\n{\n\txfrm_if_unregister_cb();\n\tlwtunnel_encap_del_ops(&xfrmi_encap_ops, LWTUNNEL_ENCAP_XFRM);\n\trtnl_link_unregister(&xfrmi_link_ops);\n\txfrmi4_fini();\n\txfrmi6_fini();\n\tunregister_pernet_device(&xfrmi_net_ops);\n}\n\nmodule_init(xfrmi_init);\nmodule_exit(xfrmi_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(\"xfrm\");\nMODULE_ALIAS_NETDEV(\"xfrm0\");\nMODULE_AUTHOR(\"Steffen Klassert\");\nMODULE_DESCRIPTION(\"XFRM virtual interface\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}