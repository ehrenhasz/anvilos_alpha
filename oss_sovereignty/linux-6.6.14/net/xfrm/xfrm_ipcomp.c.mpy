{
  "module_name": "xfrm_ipcomp.c",
  "hash_id": "9ba6229c086083189420a019fdcbfac4bddd1f3cead490246b522803665f168d",
  "original_prompt": "Ingested from linux-6.6.14/net/xfrm/xfrm_ipcomp.c",
  "human_readable_source": "\n \n\n#include <linux/crypto.h>\n#include <linux/err.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <linux/vmalloc.h>\n#include <net/ip.h>\n#include <net/ipcomp.h>\n#include <net/xfrm.h>\n\nstruct ipcomp_tfms {\n\tstruct list_head list;\n\tstruct crypto_comp * __percpu *tfms;\n\tint users;\n};\n\nstatic DEFINE_MUTEX(ipcomp_resource_mutex);\nstatic void * __percpu *ipcomp_scratches;\nstatic int ipcomp_scratch_users;\nstatic LIST_HEAD(ipcomp_tfms_list);\n\nstatic int ipcomp_decompress(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ipcomp_data *ipcd = x->data;\n\tconst int plen = skb->len;\n\tint dlen = IPCOMP_SCRATCH_SIZE;\n\tconst u8 *start = skb->data;\n\tu8 *scratch = *this_cpu_ptr(ipcomp_scratches);\n\tstruct crypto_comp *tfm = *this_cpu_ptr(ipcd->tfms);\n\tint err = crypto_comp_decompress(tfm, start, plen, scratch, &dlen);\n\tint len;\n\n\tif (err)\n\t\treturn err;\n\n\tif (dlen < (plen + sizeof(struct ip_comp_hdr)))\n\t\treturn -EINVAL;\n\n\tlen = dlen - plen;\n\tif (len > skb_tailroom(skb))\n\t\tlen = skb_tailroom(skb);\n\n\t__skb_put(skb, len);\n\n\tlen += plen;\n\tskb_copy_to_linear_data(skb, scratch, len);\n\n\twhile ((scratch += len, dlen -= len) > 0) {\n\t\tskb_frag_t *frag;\n\t\tstruct page *page;\n\n\t\tif (WARN_ON(skb_shinfo(skb)->nr_frags >= MAX_SKB_FRAGS))\n\t\t\treturn -EMSGSIZE;\n\n\t\tfrag = skb_shinfo(skb)->frags + skb_shinfo(skb)->nr_frags;\n\t\tpage = alloc_page(GFP_ATOMIC);\n\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tlen = PAGE_SIZE;\n\t\tif (dlen < len)\n\t\t\tlen = dlen;\n\n\t\tskb_frag_fill_page_desc(frag, page, 0, len);\n\t\tmemcpy(skb_frag_address(frag), scratch, len);\n\n\t\tskb->truesize += len;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\n\t\tskb_shinfo(skb)->nr_frags++;\n\t}\n\n\treturn 0;\n}\n\nint ipcomp_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint nexthdr;\n\tint err = -ENOMEM;\n\tstruct ip_comp_hdr *ipch;\n\n\tif (skb_linearize_cow(skb))\n\t\tgoto out;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t \n\tipch = (void *)skb->data;\n\tnexthdr = ipch->nexthdr;\n\n\tskb->transport_header = skb->network_header + sizeof(*ipch);\n\t__skb_pull(skb, sizeof(*ipch));\n\terr = ipcomp_decompress(x, skb);\n\tif (err)\n\t\tgoto out;\n\n\terr = nexthdr;\n\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ipcomp_input);\n\nstatic int ipcomp_compress(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ipcomp_data *ipcd = x->data;\n\tconst int plen = skb->len;\n\tint dlen = IPCOMP_SCRATCH_SIZE;\n\tu8 *start = skb->data;\n\tstruct crypto_comp *tfm;\n\tu8 *scratch;\n\tint err;\n\n\tlocal_bh_disable();\n\tscratch = *this_cpu_ptr(ipcomp_scratches);\n\ttfm = *this_cpu_ptr(ipcd->tfms);\n\terr = crypto_comp_compress(tfm, start, plen, scratch, &dlen);\n\tif (err)\n\t\tgoto out;\n\n\tif ((dlen + sizeof(struct ip_comp_hdr)) >= plen) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tmemcpy(start + sizeof(struct ip_comp_hdr), scratch, dlen);\n\tlocal_bh_enable();\n\n\tpskb_trim(skb, dlen + sizeof(struct ip_comp_hdr));\n\treturn 0;\n\nout:\n\tlocal_bh_enable();\n\treturn err;\n}\n\nint ipcomp_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err;\n\tstruct ip_comp_hdr *ipch;\n\tstruct ipcomp_data *ipcd = x->data;\n\n\tif (skb->len < ipcd->threshold) {\n\t\t \n\t\tgoto out_ok;\n\t}\n\n\tif (skb_linearize_cow(skb))\n\t\tgoto out_ok;\n\n\terr = ipcomp_compress(x, skb);\n\n\tif (err) {\n\t\tgoto out_ok;\n\t}\n\n\t \n\tipch = ip_comp_hdr(skb);\n\tipch->nexthdr = *skb_mac_header(skb);\n\tipch->flags = 0;\n\tipch->cpi = htons((u16 )ntohl(x->id.spi));\n\t*skb_mac_header(skb) = IPPROTO_COMP;\nout_ok:\n\tskb_push(skb, -skb_network_offset(skb));\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ipcomp_output);\n\nstatic void ipcomp_free_scratches(void)\n{\n\tint i;\n\tvoid * __percpu *scratches;\n\n\tif (--ipcomp_scratch_users)\n\t\treturn;\n\n\tscratches = ipcomp_scratches;\n\tif (!scratches)\n\t\treturn;\n\n\tfor_each_possible_cpu(i)\n\t\tvfree(*per_cpu_ptr(scratches, i));\n\n\tfree_percpu(scratches);\n\tipcomp_scratches = NULL;\n}\n\nstatic void * __percpu *ipcomp_alloc_scratches(void)\n{\n\tvoid * __percpu *scratches;\n\tint i;\n\n\tif (ipcomp_scratch_users++)\n\t\treturn ipcomp_scratches;\n\n\tscratches = alloc_percpu(void *);\n\tif (!scratches)\n\t\treturn NULL;\n\n\tipcomp_scratches = scratches;\n\n\tfor_each_possible_cpu(i) {\n\t\tvoid *scratch;\n\n\t\tscratch = vmalloc_node(IPCOMP_SCRATCH_SIZE, cpu_to_node(i));\n\t\tif (!scratch)\n\t\t\treturn NULL;\n\t\t*per_cpu_ptr(scratches, i) = scratch;\n\t}\n\n\treturn scratches;\n}\n\nstatic void ipcomp_free_tfms(struct crypto_comp * __percpu *tfms)\n{\n\tstruct ipcomp_tfms *pos;\n\tint cpu;\n\n\tlist_for_each_entry(pos, &ipcomp_tfms_list, list) {\n\t\tif (pos->tfms == tfms)\n\t\t\tbreak;\n\t}\n\n\tWARN_ON(list_entry_is_head(pos, &ipcomp_tfms_list, list));\n\n\tif (--pos->users)\n\t\treturn;\n\n\tlist_del(&pos->list);\n\tkfree(pos);\n\n\tif (!tfms)\n\t\treturn;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct crypto_comp *tfm = *per_cpu_ptr(tfms, cpu);\n\t\tcrypto_free_comp(tfm);\n\t}\n\tfree_percpu(tfms);\n}\n\nstatic struct crypto_comp * __percpu *ipcomp_alloc_tfms(const char *alg_name)\n{\n\tstruct ipcomp_tfms *pos;\n\tstruct crypto_comp * __percpu *tfms;\n\tint cpu;\n\n\n\tlist_for_each_entry(pos, &ipcomp_tfms_list, list) {\n\t\tstruct crypto_comp *tfm;\n\n\t\t \n\t\ttfm = this_cpu_read(*pos->tfms);\n\n\t\tif (!strcmp(crypto_comp_name(tfm), alg_name)) {\n\t\t\tpos->users++;\n\t\t\treturn pos->tfms;\n\t\t}\n\t}\n\n\tpos = kmalloc(sizeof(*pos), GFP_KERNEL);\n\tif (!pos)\n\t\treturn NULL;\n\n\tpos->users = 1;\n\tINIT_LIST_HEAD(&pos->list);\n\tlist_add(&pos->list, &ipcomp_tfms_list);\n\n\tpos->tfms = tfms = alloc_percpu(struct crypto_comp *);\n\tif (!tfms)\n\t\tgoto error;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct crypto_comp *tfm = crypto_alloc_comp(alg_name, 0,\n\t\t\t\t\t\t\t    CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(tfm))\n\t\t\tgoto error;\n\t\t*per_cpu_ptr(tfms, cpu) = tfm;\n\t}\n\n\treturn tfms;\n\nerror:\n\tipcomp_free_tfms(tfms);\n\treturn NULL;\n}\n\nstatic void ipcomp_free_data(struct ipcomp_data *ipcd)\n{\n\tif (ipcd->tfms)\n\t\tipcomp_free_tfms(ipcd->tfms);\n\tipcomp_free_scratches();\n}\n\nvoid ipcomp_destroy(struct xfrm_state *x)\n{\n\tstruct ipcomp_data *ipcd = x->data;\n\tif (!ipcd)\n\t\treturn;\n\txfrm_state_delete_tunnel(x);\n\tmutex_lock(&ipcomp_resource_mutex);\n\tipcomp_free_data(ipcd);\n\tmutex_unlock(&ipcomp_resource_mutex);\n\tkfree(ipcd);\n}\nEXPORT_SYMBOL_GPL(ipcomp_destroy);\n\nint ipcomp_init_state(struct xfrm_state *x, struct netlink_ext_ack *extack)\n{\n\tint err;\n\tstruct ipcomp_data *ipcd;\n\tstruct xfrm_algo_desc *calg_desc;\n\n\terr = -EINVAL;\n\tif (!x->calg) {\n\t\tNL_SET_ERR_MSG(extack, \"Missing required compression algorithm\");\n\t\tgoto out;\n\t}\n\n\tif (x->encap) {\n\t\tNL_SET_ERR_MSG(extack, \"IPComp is not compatible with encapsulation\");\n\t\tgoto out;\n\t}\n\n\terr = -ENOMEM;\n\tipcd = kzalloc(sizeof(*ipcd), GFP_KERNEL);\n\tif (!ipcd)\n\t\tgoto out;\n\n\tmutex_lock(&ipcomp_resource_mutex);\n\tif (!ipcomp_alloc_scratches())\n\t\tgoto error;\n\n\tipcd->tfms = ipcomp_alloc_tfms(x->calg->alg_name);\n\tif (!ipcd->tfms)\n\t\tgoto error;\n\tmutex_unlock(&ipcomp_resource_mutex);\n\n\tcalg_desc = xfrm_calg_get_byname(x->calg->alg_name, 0);\n\tBUG_ON(!calg_desc);\n\tipcd->threshold = calg_desc->uinfo.comp.threshold;\n\tx->data = ipcd;\n\terr = 0;\nout:\n\treturn err;\n\nerror:\n\tipcomp_free_data(ipcd);\n\tmutex_unlock(&ipcomp_resource_mutex);\n\tkfree(ipcd);\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(ipcomp_init_state);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"IP Payload Compression Protocol (IPComp) - RFC3173\");\nMODULE_AUTHOR(\"James Morris <jmorris@intercode.com.au>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}