{
  "module_name": "espintcp.c",
  "hash_id": "2af187bb92c4d576dd8aac1d1122b8b637d6c584c2929c9eabc1bd32cc736cd4",
  "original_prompt": "Ingested from linux-6.6.14/net/xfrm/espintcp.c",
  "human_readable_source": "\n#include <net/tcp.h>\n#include <net/strparser.h>\n#include <net/xfrm.h>\n#include <net/esp.h>\n#include <net/espintcp.h>\n#include <linux/skmsg.h>\n#include <net/inet_common.h>\n#include <trace/events/sock.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ipv6_stubs.h>\n#endif\n\nstatic void handle_nonesp(struct espintcp_ctx *ctx, struct sk_buff *skb,\n\t\t\t  struct sock *sk)\n{\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf ||\n\t    !sk_rmem_schedule(sk, skb, skb->truesize)) {\n\t\tXFRM_INC_STATS(sock_net(sk), LINUX_MIB_XFRMINERROR);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tskb_set_owner_r(skb, sk);\n\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tskb_queue_tail(&ctx->ike_queue, skb);\n\tctx->saved_data_ready(sk);\n}\n\nstatic void handle_esp(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct tcp_skb_cb *tcp_cb = (struct tcp_skb_cb *)skb->cb;\n\n\tskb_reset_transport_header(skb);\n\n\t \n\tmemmove(skb->cb, &tcp_cb->header, sizeof(tcp_cb->header));\n\n\trcu_read_lock();\n\tskb->dev = dev_get_by_index_rcu(sock_net(sk), skb->skb_iif);\n\tlocal_bh_disable();\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\tipv6_stub->xfrm6_rcv_encap(skb, IPPROTO_ESP, 0, TCP_ENCAP_ESPINTCP);\n\telse\n#endif\n\t\txfrm4_rcv_encap(skb, IPPROTO_ESP, 0, TCP_ENCAP_ESPINTCP);\n\tlocal_bh_enable();\n\trcu_read_unlock();\n}\n\nstatic void espintcp_rcv(struct strparser *strp, struct sk_buff *skb)\n{\n\tstruct espintcp_ctx *ctx = container_of(strp, struct espintcp_ctx,\n\t\t\t\t\t\tstrp);\n\tstruct strp_msg *rxm = strp_msg(skb);\n\tint len = rxm->full_len - 2;\n\tu32 nonesp_marker;\n\tint err;\n\n\t \n\tif (unlikely(len == 1)) {\n\t\tu8 data;\n\n\t\terr = skb_copy_bits(skb, rxm->offset + 2, &data, 1);\n\t\tif (err < 0) {\n\t\t\tXFRM_INC_STATS(sock_net(strp->sk), LINUX_MIB_XFRMINHDRERROR);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\n\t\tif (data == 0xff) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (unlikely(len <= sizeof(nonesp_marker))) {\n\t\tXFRM_INC_STATS(sock_net(strp->sk), LINUX_MIB_XFRMINHDRERROR);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\terr = skb_copy_bits(skb, rxm->offset + 2, &nonesp_marker,\n\t\t\t    sizeof(nonesp_marker));\n\tif (err < 0) {\n\t\tXFRM_INC_STATS(sock_net(strp->sk), LINUX_MIB_XFRMINHDRERROR);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tif (!pskb_pull(skb, rxm->offset + 2)) {\n\t\tXFRM_INC_STATS(sock_net(strp->sk), LINUX_MIB_XFRMINERROR);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (pskb_trim(skb, rxm->full_len - 2) != 0) {\n\t\tXFRM_INC_STATS(sock_net(strp->sk), LINUX_MIB_XFRMINERROR);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (nonesp_marker == 0)\n\t\thandle_nonesp(ctx, skb, strp->sk);\n\telse\n\t\thandle_esp(skb, strp->sk);\n}\n\nstatic int espintcp_parse(struct strparser *strp, struct sk_buff *skb)\n{\n\tstruct strp_msg *rxm = strp_msg(skb);\n\t__be16 blen;\n\tu16 len;\n\tint err;\n\n\tif (skb->len < rxm->offset + 2)\n\t\treturn 0;\n\n\terr = skb_copy_bits(skb, rxm->offset, &blen, sizeof(blen));\n\tif (err < 0)\n\t\treturn err;\n\n\tlen = be16_to_cpu(blen);\n\tif (len < 2)\n\t\treturn -EINVAL;\n\n\treturn len;\n}\n\nstatic int espintcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t    int flags, int *addr_len)\n{\n\tstruct espintcp_ctx *ctx = espintcp_getctx(sk);\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tint copied;\n\tint off = 0;\n\n\tskb = __skb_recv_datagram(sk, &ctx->ike_queue, flags, &off, &err);\n\tif (!skb) {\n\t\tif (err == -EAGAIN && sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tcopied = len;\n\tif (copied > skb->len)\n\t\tcopied = skb->len;\n\telse if (copied < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (unlikely(err)) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\n\tkfree_skb(skb);\n\treturn copied;\n}\n\nint espintcp_queue_out(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct espintcp_ctx *ctx = espintcp_getctx(sk);\n\n\tif (skb_queue_len(&ctx->out_queue) >= READ_ONCE(netdev_max_backlog))\n\t\treturn -ENOBUFS;\n\n\t__skb_queue_tail(&ctx->out_queue, skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(espintcp_queue_out);\n\n \n#define MAX_ESPINTCP_MSG (((1 << 16) - 1) - 2)\n\nstatic int espintcp_sendskb_locked(struct sock *sk, struct espintcp_msg *emsg,\n\t\t\t\t   int flags)\n{\n\tdo {\n\t\tint ret;\n\n\t\tret = skb_send_sock_locked(sk, emsg->skb,\n\t\t\t\t\t   emsg->offset, emsg->len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\temsg->len -= ret;\n\t\temsg->offset += ret;\n\t} while (emsg->len > 0);\n\n\tkfree_skb(emsg->skb);\n\tmemset(emsg, 0, sizeof(*emsg));\n\n\treturn 0;\n}\n\nstatic int espintcp_sendskmsg_locked(struct sock *sk,\n\t\t\t\t     struct espintcp_msg *emsg, int flags)\n{\n\tstruct msghdr msghdr = {\n\t\t.msg_flags = flags | MSG_SPLICE_PAGES | MSG_MORE,\n\t};\n\tstruct sk_msg *skmsg = &emsg->skmsg;\n\tbool more = flags & MSG_MORE;\n\tstruct scatterlist *sg;\n\tint done = 0;\n\tint ret;\n\n\tsg = &skmsg->sg.data[skmsg->sg.start];\n\tdo {\n\t\tstruct bio_vec bvec;\n\t\tsize_t size = sg->length - emsg->offset;\n\t\tint offset = sg->offset + emsg->offset;\n\t\tstruct page *p;\n\n\t\temsg->offset = 0;\n\n\t\tif (sg_is_last(sg) && !more)\n\t\t\tmsghdr.msg_flags &= ~MSG_MORE;\n\n\t\tp = sg_page(sg);\nretry:\n\t\tbvec_set_page(&bvec, p, size, offset);\n\t\tiov_iter_bvec(&msghdr.msg_iter, ITER_SOURCE, &bvec, 1, size);\n\t\tret = tcp_sendmsg_locked(sk, &msghdr, size);\n\t\tif (ret < 0) {\n\t\t\temsg->offset = offset - sg->offset;\n\t\t\tskmsg->sg.start += done;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (ret != size) {\n\t\t\toffset += ret;\n\t\t\tsize -= ret;\n\t\t\tgoto retry;\n\t\t}\n\n\t\tdone++;\n\t\tput_page(p);\n\t\tsk_mem_uncharge(sk, sg->length);\n\t\tsg = sg_next(sg);\n\t} while (sg);\n\n\tmemset(emsg, 0, sizeof(*emsg));\n\n\treturn 0;\n}\n\nstatic int espintcp_push_msgs(struct sock *sk, int flags)\n{\n\tstruct espintcp_ctx *ctx = espintcp_getctx(sk);\n\tstruct espintcp_msg *emsg = &ctx->partial;\n\tint err;\n\n\tif (!emsg->len)\n\t\treturn 0;\n\n\tif (ctx->tx_running)\n\t\treturn -EAGAIN;\n\tctx->tx_running = 1;\n\n\tif (emsg->skb)\n\t\terr = espintcp_sendskb_locked(sk, emsg, flags);\n\telse\n\t\terr = espintcp_sendskmsg_locked(sk, emsg, flags);\n\tif (err == -EAGAIN) {\n\t\tctx->tx_running = 0;\n\t\treturn flags & MSG_DONTWAIT ? -EAGAIN : 0;\n\t}\n\tif (!err)\n\t\tmemset(emsg, 0, sizeof(*emsg));\n\n\tctx->tx_running = 0;\n\n\treturn err;\n}\n\nint espintcp_push_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct espintcp_ctx *ctx = espintcp_getctx(sk);\n\tstruct espintcp_msg *emsg = &ctx->partial;\n\tunsigned int len;\n\tint offset;\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tkfree_skb(skb);\n\t\treturn -ECONNRESET;\n\t}\n\n\toffset = skb_transport_offset(skb);\n\tlen = skb->len - offset;\n\n\tespintcp_push_msgs(sk, 0);\n\n\tif (emsg->len) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOBUFS;\n\t}\n\n\tskb_set_owner_w(skb, sk);\n\n\temsg->offset = offset;\n\temsg->len = len;\n\temsg->skb = skb;\n\n\tespintcp_push_msgs(sk, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(espintcp_push_skb);\n\nstatic int espintcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size)\n{\n\tlong timeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\tstruct espintcp_ctx *ctx = espintcp_getctx(sk);\n\tstruct espintcp_msg *emsg = &ctx->partial;\n\tstruct iov_iter pfx_iter;\n\tstruct kvec pfx_iov = {};\n\tsize_t msglen = size + 2;\n\tchar buf[2] = {0};\n\tint err, end;\n\n\tif (msg->msg_flags & ~MSG_DONTWAIT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (size > MAX_ESPINTCP_MSG)\n\t\treturn -EMSGSIZE;\n\n\tif (msg->msg_controllen)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\terr = espintcp_push_msgs(sk, msg->msg_flags & MSG_DONTWAIT);\n\tif (err < 0) {\n\t\tif (err != -EAGAIN || !(msg->msg_flags & MSG_DONTWAIT))\n\t\t\terr = -ENOBUFS;\n\t\tgoto unlock;\n\t}\n\n\tsk_msg_init(&emsg->skmsg);\n\twhile (1) {\n\t\t \n\t\terr = sk_msg_alloc(sk, &emsg->skmsg, msglen, 0);\n\t\tif (!err)\n\t\t\tbreak;\n\n\t\terr = sk_stream_wait_memory(sk, &timeo);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\t*((__be16 *)buf) = cpu_to_be16(msglen);\n\tpfx_iov.iov_base = buf;\n\tpfx_iov.iov_len = sizeof(buf);\n\tiov_iter_kvec(&pfx_iter, ITER_SOURCE, &pfx_iov, 1, pfx_iov.iov_len);\n\n\terr = sk_msg_memcopy_from_iter(sk, &pfx_iter, &emsg->skmsg,\n\t\t\t\t       pfx_iov.iov_len);\n\tif (err < 0)\n\t\tgoto fail;\n\n\terr = sk_msg_memcopy_from_iter(sk, &msg->msg_iter, &emsg->skmsg, size);\n\tif (err < 0)\n\t\tgoto fail;\n\n\tend = emsg->skmsg.sg.end;\n\temsg->len = size;\n\tsk_msg_iter_var_prev(end);\n\tsg_mark_end(sk_msg_elem(&emsg->skmsg, end));\n\n\ttcp_rate_check_app_limited(sk);\n\n\terr = espintcp_push_msgs(sk, msg->msg_flags & MSG_DONTWAIT);\n\t \n\n\trelease_sock(sk);\n\n\treturn size;\n\nfail:\n\tsk_msg_free(sk, &emsg->skmsg);\n\tmemset(emsg, 0, sizeof(*emsg));\nunlock:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic struct proto espintcp_prot __ro_after_init;\nstatic struct proto_ops espintcp_ops __ro_after_init;\nstatic struct proto espintcp6_prot;\nstatic struct proto_ops espintcp6_ops;\nstatic DEFINE_MUTEX(tcpv6_prot_mutex);\n\nstatic void espintcp_data_ready(struct sock *sk)\n{\n\tstruct espintcp_ctx *ctx = espintcp_getctx(sk);\n\n\ttrace_sk_data_ready(sk);\n\n\tstrp_data_ready(&ctx->strp);\n}\n\nstatic void espintcp_tx_work(struct work_struct *work)\n{\n\tstruct espintcp_ctx *ctx = container_of(work,\n\t\t\t\t\t\tstruct espintcp_ctx, work);\n\tstruct sock *sk = ctx->strp.sk;\n\n\tlock_sock(sk);\n\tif (!ctx->tx_running)\n\t\tespintcp_push_msgs(sk, 0);\n\trelease_sock(sk);\n}\n\nstatic void espintcp_write_space(struct sock *sk)\n{\n\tstruct espintcp_ctx *ctx = espintcp_getctx(sk);\n\n\tschedule_work(&ctx->work);\n\tctx->saved_write_space(sk);\n}\n\nstatic void espintcp_destruct(struct sock *sk)\n{\n\tstruct espintcp_ctx *ctx = espintcp_getctx(sk);\n\n\tctx->saved_destruct(sk);\n\tkfree(ctx);\n}\n\nbool tcp_is_ulp_esp(struct sock *sk)\n{\n\treturn sk->sk_prot == &espintcp_prot || sk->sk_prot == &espintcp6_prot;\n}\nEXPORT_SYMBOL_GPL(tcp_is_ulp_esp);\n\nstatic void build_protos(struct proto *espintcp_prot,\n\t\t\t struct proto_ops *espintcp_ops,\n\t\t\t const struct proto *orig_prot,\n\t\t\t const struct proto_ops *orig_ops);\nstatic int espintcp_init_sk(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct strp_callbacks cb = {\n\t\t.rcv_msg = espintcp_rcv,\n\t\t.parse_msg = espintcp_parse,\n\t};\n\tstruct espintcp_ctx *ctx;\n\tint err;\n\n\t \n\tif (sk->sk_user_data)\n\t\treturn -EBUSY;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\terr = strp_init(&ctx->strp, sk, &cb);\n\tif (err)\n\t\tgoto free;\n\n\t__sk_dst_reset(sk);\n\n\tstrp_check_rcv(&ctx->strp);\n\tskb_queue_head_init(&ctx->ike_queue);\n\tskb_queue_head_init(&ctx->out_queue);\n\n\tif (sk->sk_family == AF_INET) {\n\t\tsk->sk_prot = &espintcp_prot;\n\t\tsk->sk_socket->ops = &espintcp_ops;\n\t} else {\n\t\tmutex_lock(&tcpv6_prot_mutex);\n\t\tif (!espintcp6_prot.recvmsg)\n\t\t\tbuild_protos(&espintcp6_prot, &espintcp6_ops, sk->sk_prot, sk->sk_socket->ops);\n\t\tmutex_unlock(&tcpv6_prot_mutex);\n\n\t\tsk->sk_prot = &espintcp6_prot;\n\t\tsk->sk_socket->ops = &espintcp6_ops;\n\t}\n\tctx->saved_data_ready = sk->sk_data_ready;\n\tctx->saved_write_space = sk->sk_write_space;\n\tctx->saved_destruct = sk->sk_destruct;\n\tsk->sk_data_ready = espintcp_data_ready;\n\tsk->sk_write_space = espintcp_write_space;\n\tsk->sk_destruct = espintcp_destruct;\n\trcu_assign_pointer(icsk->icsk_ulp_data, ctx);\n\tINIT_WORK(&ctx->work, espintcp_tx_work);\n\n\t \n\tsk->sk_allocation = GFP_ATOMIC;\n\tsk->sk_use_task_frag = false;\n\n\treturn 0;\n\nfree:\n\tkfree(ctx);\n\treturn err;\n}\n\nstatic void espintcp_release(struct sock *sk)\n{\n\tstruct espintcp_ctx *ctx = espintcp_getctx(sk);\n\tstruct sk_buff_head queue;\n\tstruct sk_buff *skb;\n\n\t__skb_queue_head_init(&queue);\n\tskb_queue_splice_init(&ctx->out_queue, &queue);\n\n\twhile ((skb = __skb_dequeue(&queue)))\n\t\tespintcp_push_skb(sk, skb);\n\n\ttcp_release_cb(sk);\n}\n\nstatic void espintcp_close(struct sock *sk, long timeout)\n{\n\tstruct espintcp_ctx *ctx = espintcp_getctx(sk);\n\tstruct espintcp_msg *emsg = &ctx->partial;\n\n\tstrp_stop(&ctx->strp);\n\n\tsk->sk_prot = &tcp_prot;\n\tbarrier();\n\n\tcancel_work_sync(&ctx->work);\n\tstrp_done(&ctx->strp);\n\n\tskb_queue_purge(&ctx->out_queue);\n\tskb_queue_purge(&ctx->ike_queue);\n\n\tif (emsg->len) {\n\t\tif (emsg->skb)\n\t\t\tkfree_skb(emsg->skb);\n\t\telse\n\t\t\tsk_msg_free(sk, &emsg->skmsg);\n\t}\n\n\ttcp_close(sk, timeout);\n}\n\nstatic __poll_t espintcp_poll(struct file *file, struct socket *sock,\n\t\t\t      poll_table *wait)\n{\n\t__poll_t mask = datagram_poll(file, sock, wait);\n\tstruct sock *sk = sock->sk;\n\tstruct espintcp_ctx *ctx = espintcp_getctx(sk);\n\n\tif (!skb_queue_empty(&ctx->ike_queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic void build_protos(struct proto *espintcp_prot,\n\t\t\t struct proto_ops *espintcp_ops,\n\t\t\t const struct proto *orig_prot,\n\t\t\t const struct proto_ops *orig_ops)\n{\n\tmemcpy(espintcp_prot, orig_prot, sizeof(struct proto));\n\tmemcpy(espintcp_ops, orig_ops, sizeof(struct proto_ops));\n\tespintcp_prot->sendmsg = espintcp_sendmsg;\n\tespintcp_prot->recvmsg = espintcp_recvmsg;\n\tespintcp_prot->close = espintcp_close;\n\tespintcp_prot->release_cb = espintcp_release;\n\tespintcp_ops->poll = espintcp_poll;\n}\n\nstatic struct tcp_ulp_ops espintcp_ulp __read_mostly = {\n\t.name = \"espintcp\",\n\t.owner = THIS_MODULE,\n\t.init = espintcp_init_sk,\n};\n\nvoid __init espintcp_init(void)\n{\n\tbuild_protos(&espintcp_prot, &espintcp_ops, &tcp_prot, &inet_stream_ops);\n\n\ttcp_register_ulp(&espintcp_ulp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}