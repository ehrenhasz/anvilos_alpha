{
  "module_name": "xfrm_compat.c",
  "hash_id": "f45b601ed5149a3ed97c7a25a1536bfe7fcf2b173bcd2ab21f7c3e5d39a82e12",
  "original_prompt": "Ingested from linux-6.6.14/net/xfrm/xfrm_compat.c",
  "human_readable_source": "\n \n#include <linux/compat.h>\n#include <linux/nospec.h>\n#include <linux/xfrm.h>\n#include <net/xfrm.h>\n\nstruct compat_xfrm_lifetime_cfg {\n\tcompat_u64 soft_byte_limit, hard_byte_limit;\n\tcompat_u64 soft_packet_limit, hard_packet_limit;\n\tcompat_u64 soft_add_expires_seconds, hard_add_expires_seconds;\n\tcompat_u64 soft_use_expires_seconds, hard_use_expires_seconds;\n};  \n\nstruct compat_xfrm_lifetime_cur {\n\tcompat_u64 bytes, packets, add_time, use_time;\n};  \n\nstruct compat_xfrm_userpolicy_info {\n\tstruct xfrm_selector sel;\n\tstruct compat_xfrm_lifetime_cfg lft;\n\tstruct compat_xfrm_lifetime_cur curlft;\n\t__u32 priority, index;\n\tu8 dir, action, flags, share;\n\t \n};\n\nstruct compat_xfrm_usersa_info {\n\tstruct xfrm_selector sel;\n\tstruct xfrm_id id;\n\txfrm_address_t saddr;\n\tstruct compat_xfrm_lifetime_cfg lft;\n\tstruct compat_xfrm_lifetime_cur curlft;\n\tstruct xfrm_stats stats;\n\t__u32 seq, reqid;\n\tu16 family;\n\tu8 mode, replay_window, flags;\n\t \n};\n\nstruct compat_xfrm_user_acquire {\n\tstruct xfrm_id id;\n\txfrm_address_t saddr;\n\tstruct xfrm_selector sel;\n\tstruct compat_xfrm_userpolicy_info policy;\n\t \n\t__u32 aalgos, ealgos, calgos, seq;\n};\n\nstruct compat_xfrm_userspi_info {\n\tstruct compat_xfrm_usersa_info info;\n\t \n\t__u32 min, max;\n};\n\nstruct compat_xfrm_user_expire {\n\tstruct compat_xfrm_usersa_info state;\n\t \n\tu8 hard;\n};\n\nstruct compat_xfrm_user_polexpire {\n\tstruct compat_xfrm_userpolicy_info pol;\n\t \n\tu8 hard;\n};\n\n#define XMSGSIZE(type) sizeof(struct type)\n\nstatic const int compat_msg_min[XFRM_NR_MSGTYPES] = {\n\t[XFRM_MSG_NEWSA       - XFRM_MSG_BASE] = XMSGSIZE(compat_xfrm_usersa_info),\n\t[XFRM_MSG_DELSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_id),\n\t[XFRM_MSG_GETSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_id),\n\t[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(compat_xfrm_userpolicy_info),\n\t[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = XMSGSIZE(compat_xfrm_userspi_info),\n\t[XFRM_MSG_ACQUIRE     - XFRM_MSG_BASE] = XMSGSIZE(compat_xfrm_user_acquire),\n\t[XFRM_MSG_EXPIRE      - XFRM_MSG_BASE] = XMSGSIZE(compat_xfrm_user_expire),\n\t[XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(compat_xfrm_userpolicy_info),\n\t[XFRM_MSG_UPDSA       - XFRM_MSG_BASE] = XMSGSIZE(compat_xfrm_usersa_info),\n\t[XFRM_MSG_POLEXPIRE   - XFRM_MSG_BASE] = XMSGSIZE(compat_xfrm_user_polexpire),\n\t[XFRM_MSG_FLUSHSA     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_flush),\n\t[XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = 0,\n\t[XFRM_MSG_NEWAE       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_aevent_id),\n\t[XFRM_MSG_GETAE       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_aevent_id),\n\t[XFRM_MSG_REPORT      - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_report),\n\t[XFRM_MSG_MIGRATE     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_NEWSADINFO  - XFRM_MSG_BASE] = sizeof(u32),\n\t[XFRM_MSG_GETSADINFO  - XFRM_MSG_BASE] = sizeof(u32),\n\t[XFRM_MSG_NEWSPDINFO  - XFRM_MSG_BASE] = sizeof(u32),\n\t[XFRM_MSG_GETSPDINFO  - XFRM_MSG_BASE] = sizeof(u32),\n\t[XFRM_MSG_MAPPING     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_mapping)\n};\n\nstatic const struct nla_policy compat_policy[XFRMA_MAX+1] = {\n\t[XFRMA_SA]\t\t= { .len = XMSGSIZE(compat_xfrm_usersa_info)},\n\t[XFRMA_POLICY]\t\t= { .len = XMSGSIZE(compat_xfrm_userpolicy_info)},\n\t[XFRMA_LASTUSED]\t= { .type = NLA_U64},\n\t[XFRMA_ALG_AUTH_TRUNC]\t= { .len = sizeof(struct xfrm_algo_auth)},\n\t[XFRMA_ALG_AEAD]\t= { .len = sizeof(struct xfrm_algo_aead) },\n\t[XFRMA_ALG_AUTH]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ALG_CRYPT]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ALG_COMP]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ENCAP]\t\t= { .len = sizeof(struct xfrm_encap_tmpl) },\n\t[XFRMA_TMPL]\t\t= { .len = sizeof(struct xfrm_user_tmpl) },\n\t[XFRMA_SEC_CTX]\t\t= { .len = sizeof(struct xfrm_user_sec_ctx) },\n\t[XFRMA_LTIME_VAL]\t= { .len = sizeof(struct xfrm_lifetime_cur) },\n\t[XFRMA_REPLAY_VAL]\t= { .len = sizeof(struct xfrm_replay_state) },\n\t[XFRMA_REPLAY_THRESH]\t= { .type = NLA_U32 },\n\t[XFRMA_ETIMER_THRESH]\t= { .type = NLA_U32 },\n\t[XFRMA_SRCADDR]\t\t= { .len = sizeof(xfrm_address_t) },\n\t[XFRMA_COADDR]\t\t= { .len = sizeof(xfrm_address_t) },\n\t[XFRMA_POLICY_TYPE]\t= { .len = sizeof(struct xfrm_userpolicy_type)},\n\t[XFRMA_MIGRATE]\t\t= { .len = sizeof(struct xfrm_user_migrate) },\n\t[XFRMA_KMADDRESS]\t= { .len = sizeof(struct xfrm_user_kmaddress) },\n\t[XFRMA_MARK]\t\t= { .len = sizeof(struct xfrm_mark) },\n\t[XFRMA_TFCPAD]\t\t= { .type = NLA_U32 },\n\t[XFRMA_REPLAY_ESN_VAL]\t= { .len = sizeof(struct xfrm_replay_state_esn) },\n\t[XFRMA_SA_EXTRA_FLAGS]\t= { .type = NLA_U32 },\n\t[XFRMA_PROTO]\t\t= { .type = NLA_U8 },\n\t[XFRMA_ADDRESS_FILTER]\t= { .len = sizeof(struct xfrm_address_filter) },\n\t[XFRMA_OFFLOAD_DEV]\t= { .len = sizeof(struct xfrm_user_offload) },\n\t[XFRMA_SET_MARK]\t= { .type = NLA_U32 },\n\t[XFRMA_SET_MARK_MASK]\t= { .type = NLA_U32 },\n\t[XFRMA_IF_ID]\t\t= { .type = NLA_U32 },\n\t[XFRMA_MTIMER_THRESH]\t= { .type = NLA_U32 },\n};\n\nstatic struct nlmsghdr *xfrm_nlmsg_put_compat(struct sk_buff *skb,\n\t\t\tconst struct nlmsghdr *nlh_src, u16 type)\n{\n\tint payload = compat_msg_min[type];\n\tint src_len = xfrm_msg_min[type];\n\tstruct nlmsghdr *nlh_dst;\n\n\t \n\tif (WARN_ON_ONCE(src_len < payload))\n\t\treturn ERR_PTR(-EMSGSIZE);\n\n\tnlh_dst = nlmsg_put(skb, nlh_src->nlmsg_pid, nlh_src->nlmsg_seq,\n\t\t\t    nlh_src->nlmsg_type, payload, nlh_src->nlmsg_flags);\n\tif (!nlh_dst)\n\t\treturn ERR_PTR(-EMSGSIZE);\n\n\tmemset(nlmsg_data(nlh_dst), 0, payload);\n\n\tswitch (nlh_src->nlmsg_type) {\n\t \n\tcase XFRM_MSG_DELSA:\n\tcase XFRM_MSG_DELPOLICY:\n\tcase XFRM_MSG_FLUSHSA:\n\tcase XFRM_MSG_FLUSHPOLICY:\n\tcase XFRM_MSG_NEWAE:\n\tcase XFRM_MSG_REPORT:\n\tcase XFRM_MSG_MIGRATE:\n\tcase XFRM_MSG_NEWSADINFO:\n\tcase XFRM_MSG_NEWSPDINFO:\n\tcase XFRM_MSG_MAPPING:\n\t\tWARN_ON_ONCE(src_len != payload);\n\t\tmemcpy(nlmsg_data(nlh_dst), nlmsg_data(nlh_src), src_len);\n\t\tbreak;\n\t \n\tcase XFRM_MSG_NEWSA:\n\tcase XFRM_MSG_NEWPOLICY:\n\tcase XFRM_MSG_UPDSA:\n\tcase XFRM_MSG_UPDPOLICY:\n\t\tWARN_ON_ONCE(src_len != payload + 4);\n\t\tmemcpy(nlmsg_data(nlh_dst), nlmsg_data(nlh_src), payload);\n\t\tbreak;\n\tcase XFRM_MSG_EXPIRE: {\n\t\tconst struct xfrm_user_expire *src_ue  = nlmsg_data(nlh_src);\n\t\tstruct compat_xfrm_user_expire *dst_ue = nlmsg_data(nlh_dst);\n\n\t\t \n\t\tmemcpy(dst_ue, src_ue, sizeof(dst_ue->state));\n\t\tdst_ue->hard = src_ue->hard;\n\t\tbreak;\n\t}\n\tcase XFRM_MSG_ACQUIRE: {\n\t\tconst struct xfrm_user_acquire *src_ua  = nlmsg_data(nlh_src);\n\t\tstruct compat_xfrm_user_acquire *dst_ua = nlmsg_data(nlh_dst);\n\n\t\tmemcpy(dst_ua, src_ua, offsetof(struct compat_xfrm_user_acquire, aalgos));\n\t\tdst_ua->aalgos = src_ua->aalgos;\n\t\tdst_ua->ealgos = src_ua->ealgos;\n\t\tdst_ua->calgos = src_ua->calgos;\n\t\tdst_ua->seq    = src_ua->seq;\n\t\tbreak;\n\t}\n\tcase XFRM_MSG_POLEXPIRE: {\n\t\tconst struct xfrm_user_polexpire *src_upe  = nlmsg_data(nlh_src);\n\t\tstruct compat_xfrm_user_polexpire *dst_upe = nlmsg_data(nlh_dst);\n\n\t\t \n\t\tmemcpy(dst_upe, src_upe, sizeof(dst_upe->pol));\n\t\tdst_upe->hard = src_upe->hard;\n\t\tbreak;\n\t}\n\tcase XFRM_MSG_ALLOCSPI: {\n\t\tconst struct xfrm_userspi_info *src_usi = nlmsg_data(nlh_src);\n\t\tstruct compat_xfrm_userspi_info *dst_usi = nlmsg_data(nlh_dst);\n\n\t\t \n\t\tmemcpy(dst_usi, src_usi, sizeof(src_usi->info));\n\t\tdst_usi->min = src_usi->min;\n\t\tdst_usi->max = src_usi->max;\n\t\tbreak;\n\t}\n\t \n\tcase XFRM_MSG_GETSA:\n\tcase XFRM_MSG_GETPOLICY:\n\tcase XFRM_MSG_GETAE:\n\tcase XFRM_MSG_GETSADINFO:\n\tcase XFRM_MSG_GETSPDINFO:\n\tdefault:\n\t\tpr_warn_once(\"unsupported nlmsg_type %d\\n\", nlh_src->nlmsg_type);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\treturn nlh_dst;\n}\n\nstatic int xfrm_nla_cpy(struct sk_buff *dst, const struct nlattr *src, int len)\n{\n\treturn nla_put(dst, src->nla_type, len, nla_data(src));\n}\n\nstatic int xfrm_xlate64_attr(struct sk_buff *dst, const struct nlattr *src)\n{\n\tswitch (src->nla_type) {\n\tcase XFRMA_PAD:\n\t\t \n\t\treturn 0;\n\tcase XFRMA_UNSPEC:\n\tcase XFRMA_ALG_AUTH:\n\tcase XFRMA_ALG_CRYPT:\n\tcase XFRMA_ALG_COMP:\n\tcase XFRMA_ENCAP:\n\tcase XFRMA_TMPL:\n\t\treturn xfrm_nla_cpy(dst, src, nla_len(src));\n\tcase XFRMA_SA:\n\t\treturn xfrm_nla_cpy(dst, src, XMSGSIZE(compat_xfrm_usersa_info));\n\tcase XFRMA_POLICY:\n\t\treturn xfrm_nla_cpy(dst, src, XMSGSIZE(compat_xfrm_userpolicy_info));\n\tcase XFRMA_SEC_CTX:\n\t\treturn xfrm_nla_cpy(dst, src, nla_len(src));\n\tcase XFRMA_LTIME_VAL:\n\t\treturn nla_put_64bit(dst, src->nla_type, nla_len(src),\n\t\t\tnla_data(src), XFRMA_PAD);\n\tcase XFRMA_REPLAY_VAL:\n\tcase XFRMA_REPLAY_THRESH:\n\tcase XFRMA_ETIMER_THRESH:\n\tcase XFRMA_SRCADDR:\n\tcase XFRMA_COADDR:\n\t\treturn xfrm_nla_cpy(dst, src, nla_len(src));\n\tcase XFRMA_LASTUSED:\n\t\treturn nla_put_64bit(dst, src->nla_type, nla_len(src),\n\t\t\tnla_data(src), XFRMA_PAD);\n\tcase XFRMA_POLICY_TYPE:\n\tcase XFRMA_MIGRATE:\n\tcase XFRMA_ALG_AEAD:\n\tcase XFRMA_KMADDRESS:\n\tcase XFRMA_ALG_AUTH_TRUNC:\n\tcase XFRMA_MARK:\n\tcase XFRMA_TFCPAD:\n\tcase XFRMA_REPLAY_ESN_VAL:\n\tcase XFRMA_SA_EXTRA_FLAGS:\n\tcase XFRMA_PROTO:\n\tcase XFRMA_ADDRESS_FILTER:\n\tcase XFRMA_OFFLOAD_DEV:\n\tcase XFRMA_SET_MARK:\n\tcase XFRMA_SET_MARK_MASK:\n\tcase XFRMA_IF_ID:\n\tcase XFRMA_MTIMER_THRESH:\n\t\treturn xfrm_nla_cpy(dst, src, nla_len(src));\n\tdefault:\n\t\tBUILD_BUG_ON(XFRMA_MAX != XFRMA_MTIMER_THRESH);\n\t\tpr_warn_once(\"unsupported nla_type %d\\n\", src->nla_type);\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic int xfrm_xlate64(struct sk_buff *dst, const struct nlmsghdr *nlh_src)\n{\n\tu16 type = nlh_src->nlmsg_type - XFRM_MSG_BASE;\n\tconst struct nlattr *nla, *attrs;\n\tstruct nlmsghdr *nlh_dst;\n\tint len, remaining;\n\n\tnlh_dst = xfrm_nlmsg_put_compat(dst, nlh_src, type);\n\tif (IS_ERR(nlh_dst))\n\t\treturn PTR_ERR(nlh_dst);\n\n\tattrs = nlmsg_attrdata(nlh_src, xfrm_msg_min[type]);\n\tlen = nlmsg_attrlen(nlh_src, xfrm_msg_min[type]);\n\n\tnla_for_each_attr(nla, attrs, len, remaining) {\n\t\tint err;\n\n\t\tswitch (nlh_src->nlmsg_type) {\n\t\tcase XFRM_MSG_NEWSPDINFO:\n\t\t\terr = xfrm_nla_cpy(dst, nla, nla_len(nla));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = xfrm_xlate64_attr(dst, nla);\n\t\t\tbreak;\n\t\t}\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnlmsg_end(dst, nlh_dst);\n\n\treturn 0;\n}\n\nstatic int xfrm_alloc_compat(struct sk_buff *skb, const struct nlmsghdr *nlh_src)\n{\n\tu16 type = nlh_src->nlmsg_type - XFRM_MSG_BASE;\n\tstruct sk_buff *new = NULL;\n\tint err;\n\n\tif (type >= ARRAY_SIZE(xfrm_msg_min)) {\n\t\tpr_warn_once(\"unsupported nlmsg_type %d\\n\", nlh_src->nlmsg_type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (skb_shinfo(skb)->frag_list == NULL) {\n\t\tnew = alloc_skb(skb->len + skb_tailroom(skb), GFP_ATOMIC);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tskb_shinfo(skb)->frag_list = new;\n\t}\n\n\terr = xfrm_xlate64(skb_shinfo(skb)->frag_list, nlh_src);\n\tif (err) {\n\t\tif (new) {\n\t\t\tkfree_skb(new);\n\t\t\tskb_shinfo(skb)->frag_list = NULL;\n\t\t}\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic size_t xfrm_user_rcv_calculate_len64(const struct nlmsghdr *src,\n\t\t\t\t\t    struct nlattr *attrs[XFRMA_MAX + 1],\n\t\t\t\t\t    int maxtype)\n{\n\tsize_t len = nlmsg_len(src);\n\n\tswitch (src->nlmsg_type) {\n\tcase XFRM_MSG_NEWSA:\n\tcase XFRM_MSG_NEWPOLICY:\n\tcase XFRM_MSG_ALLOCSPI:\n\tcase XFRM_MSG_ACQUIRE:\n\tcase XFRM_MSG_UPDPOLICY:\n\tcase XFRM_MSG_UPDSA:\n\t\tlen += 4;\n\t\tbreak;\n\tcase XFRM_MSG_EXPIRE:\n\tcase XFRM_MSG_POLEXPIRE:\n\t\tlen += 8;\n\t\tbreak;\n\tcase XFRM_MSG_NEWSPDINFO:\n\t\t \n\t\treturn len;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (WARN_ON_ONCE(maxtype))\n\t\treturn len;\n\n\tif (attrs[XFRMA_SA])\n\t\tlen += 4;\n\tif (attrs[XFRMA_POLICY])\n\t\tlen += 4;\n\n\t \n\n\treturn len;\n}\n\nstatic int xfrm_attr_cpy32(void *dst, size_t *pos, const struct nlattr *src,\n\t\t\t   size_t size, int copy_len, int payload)\n{\n\tstruct nlmsghdr *nlmsg = dst;\n\tstruct nlattr *nla;\n\n\t \n\tif (WARN_ON_ONCE(copy_len > payload))\n\t\tcopy_len = payload;\n\n\tif (size - *pos < nla_attr_size(payload))\n\t\treturn -ENOBUFS;\n\n\tnla = dst + *pos;\n\n\tmemcpy(nla, src, nla_attr_size(copy_len));\n\tnla->nla_len = nla_attr_size(payload);\n\t*pos += nla_attr_size(copy_len);\n\tnlmsg->nlmsg_len += nla->nla_len;\n\n\tmemset(dst + *pos, 0, payload - copy_len);\n\t*pos += payload - copy_len;\n\n\treturn 0;\n}\n\nstatic int xfrm_xlate32_attr(void *dst, const struct nlattr *nla,\n\t\t\t     size_t *pos, size_t size,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tint type = nla_type(nla);\n\tu16 pol_len32, pol_len64;\n\tint err;\n\n\tif (type > XFRMA_MAX) {\n\t\tBUILD_BUG_ON(XFRMA_MAX != XFRMA_MTIMER_THRESH);\n\t\tNL_SET_ERR_MSG(extack, \"Bad attribute\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\ttype = array_index_nospec(type, XFRMA_MAX + 1);\n\tif (nla_len(nla) < compat_policy[type].len) {\n\t\tNL_SET_ERR_MSG(extack, \"Attribute bad length\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpol_len32 = compat_policy[type].len;\n\tpol_len64 = xfrma_policy[type].len;\n\n\t \n\tif (pol_len32 != pol_len64) {\n\t\tif (nla_len(nla) != compat_policy[type].len) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Attribute bad length\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\terr = xfrm_attr_cpy32(dst, pos, nla, size, pol_len32, pol_len64);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn xfrm_attr_cpy32(dst, pos, nla, size, nla_len(nla), nla_len(nla));\n}\n\nstatic int xfrm_xlate32(struct nlmsghdr *dst, const struct nlmsghdr *src,\n\t\t\tstruct nlattr *attrs[XFRMA_MAX+1],\n\t\t\tsize_t size, u8 type, int maxtype,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tsize_t pos;\n\tint i;\n\n\tmemcpy(dst, src, NLMSG_HDRLEN);\n\tdst->nlmsg_len = NLMSG_HDRLEN + xfrm_msg_min[type];\n\tmemset(nlmsg_data(dst), 0, xfrm_msg_min[type]);\n\n\tswitch (src->nlmsg_type) {\n\t \n\tcase XFRM_MSG_DELSA:\n\tcase XFRM_MSG_GETSA:\n\tcase XFRM_MSG_DELPOLICY:\n\tcase XFRM_MSG_GETPOLICY:\n\tcase XFRM_MSG_FLUSHSA:\n\tcase XFRM_MSG_FLUSHPOLICY:\n\tcase XFRM_MSG_NEWAE:\n\tcase XFRM_MSG_GETAE:\n\tcase XFRM_MSG_REPORT:\n\tcase XFRM_MSG_MIGRATE:\n\tcase XFRM_MSG_NEWSADINFO:\n\tcase XFRM_MSG_GETSADINFO:\n\tcase XFRM_MSG_NEWSPDINFO:\n\tcase XFRM_MSG_GETSPDINFO:\n\tcase XFRM_MSG_MAPPING:\n\t\tmemcpy(nlmsg_data(dst), nlmsg_data(src), compat_msg_min[type]);\n\t\tbreak;\n\t \n\tcase XFRM_MSG_NEWSA:\n\tcase XFRM_MSG_NEWPOLICY:\n\tcase XFRM_MSG_UPDSA:\n\tcase XFRM_MSG_UPDPOLICY:\n\t\tmemcpy(nlmsg_data(dst), nlmsg_data(src), compat_msg_min[type]);\n\t\tbreak;\n\tcase XFRM_MSG_EXPIRE: {\n\t\tconst struct compat_xfrm_user_expire *src_ue = nlmsg_data(src);\n\t\tstruct xfrm_user_expire *dst_ue = nlmsg_data(dst);\n\n\t\t \n\t\tmemcpy(dst_ue, src_ue, sizeof(src_ue->state));\n\t\tdst_ue->hard = src_ue->hard;\n\t\tbreak;\n\t}\n\tcase XFRM_MSG_ACQUIRE: {\n\t\tconst struct compat_xfrm_user_acquire *src_ua = nlmsg_data(src);\n\t\tstruct xfrm_user_acquire *dst_ua = nlmsg_data(dst);\n\n\t\tmemcpy(dst_ua, src_ua, offsetof(struct compat_xfrm_user_acquire, aalgos));\n\t\tdst_ua->aalgos = src_ua->aalgos;\n\t\tdst_ua->ealgos = src_ua->ealgos;\n\t\tdst_ua->calgos = src_ua->calgos;\n\t\tdst_ua->seq    = src_ua->seq;\n\t\tbreak;\n\t}\n\tcase XFRM_MSG_POLEXPIRE: {\n\t\tconst struct compat_xfrm_user_polexpire *src_upe = nlmsg_data(src);\n\t\tstruct xfrm_user_polexpire *dst_upe = nlmsg_data(dst);\n\n\t\t \n\t\tmemcpy(dst_upe, src_upe, sizeof(src_upe->pol));\n\t\tdst_upe->hard = src_upe->hard;\n\t\tbreak;\n\t}\n\tcase XFRM_MSG_ALLOCSPI: {\n\t\tconst struct compat_xfrm_userspi_info *src_usi = nlmsg_data(src);\n\t\tstruct xfrm_userspi_info *dst_usi = nlmsg_data(dst);\n\n\t\t \n\t\tmemcpy(dst_usi, src_usi, sizeof(src_usi->info));\n\t\tdst_usi->min = src_usi->min;\n\t\tdst_usi->max = src_usi->max;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tNL_SET_ERR_MSG(extack, \"Unsupported message type\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tpos = dst->nlmsg_len;\n\n\tif (maxtype) {\n\t\t \n\t\tWARN_ON_ONCE(src->nlmsg_type != XFRM_MSG_NEWSPDINFO);\n\n\t\tfor (i = 1; i <= maxtype; i++) {\n\t\t\tint err;\n\n\t\t\tif (!attrs[i])\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\terr = xfrm_attr_cpy32(dst, &pos, attrs[i], size,\n\t\t\t\t\tnla_len(attrs[i]), nla_len(attrs[i]));\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfor (i = 1; i < XFRMA_MAX + 1; i++) {\n\t\tint err;\n\n\t\tif (i == XFRMA_PAD)\n\t\t\tcontinue;\n\n\t\tif (!attrs[i])\n\t\t\tcontinue;\n\n\t\terr = xfrm_xlate32_attr(dst, attrs[i], &pos, size, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct nlmsghdr *xfrm_user_rcv_msg_compat(const struct nlmsghdr *h32,\n\t\t\tint maxtype, const struct nla_policy *policy,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\t \n\tu16 type = h32->nlmsg_type - XFRM_MSG_BASE;\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tstruct nlmsghdr *h64;\n\tsize_t len;\n\tint err;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(xfrm_msg_min) != ARRAY_SIZE(compat_msg_min));\n\n\tif (type >= ARRAY_SIZE(xfrm_msg_min))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif ((h32->nlmsg_type == XFRM_MSG_GETSA ||\n\t     h32->nlmsg_type == XFRM_MSG_GETPOLICY) &&\n\t    (h32->nlmsg_flags & NLM_F_DUMP))\n\t\treturn NULL;\n\n\terr = nlmsg_parse_deprecated(h32, compat_msg_min[type], attrs,\n\t\t\tmaxtype ? : XFRMA_MAX, policy ? : compat_policy, extack);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tlen = xfrm_user_rcv_calculate_len64(h32, attrs, maxtype);\n\t \n\tif (len == nlmsg_len(h32))\n\t\treturn NULL;\n\n\tlen += NLMSG_HDRLEN;\n\th64 = kvmalloc(len, GFP_KERNEL);\n\tif (!h64)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = xfrm_xlate32(h64, h32, attrs, len, type, maxtype, extack);\n\tif (err < 0) {\n\t\tkvfree(h64);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn h64;\n}\n\nstatic int xfrm_user_policy_compat(u8 **pdata32, int optlen)\n{\n\tstruct compat_xfrm_userpolicy_info *p = (void *)*pdata32;\n\tu8 *src_templates, *dst_templates;\n\tu8 *data64;\n\n\tif (optlen < sizeof(*p))\n\t\treturn -EINVAL;\n\n\tdata64 = kmalloc_track_caller(optlen + 4, GFP_USER | __GFP_NOWARN);\n\tif (!data64)\n\t\treturn -ENOMEM;\n\n\tmemcpy(data64, *pdata32, sizeof(*p));\n\tmemset(data64 + sizeof(*p), 0, 4);\n\n\tsrc_templates = *pdata32 + sizeof(*p);\n\tdst_templates = data64 + sizeof(*p) + 4;\n\tmemcpy(dst_templates, src_templates, optlen - sizeof(*p));\n\n\tkfree(*pdata32);\n\t*pdata32 = data64;\n\treturn 0;\n}\n\nstatic struct xfrm_translator xfrm_translator = {\n\t.owner\t\t\t\t= THIS_MODULE,\n\t.alloc_compat\t\t\t= xfrm_alloc_compat,\n\t.rcv_msg_compat\t\t\t= xfrm_user_rcv_msg_compat,\n\t.xlate_user_policy_sockptr\t= xfrm_user_policy_compat,\n};\n\nstatic int __init xfrm_compat_init(void)\n{\n\treturn xfrm_register_translator(&xfrm_translator);\n}\n\nstatic void __exit xfrm_compat_exit(void)\n{\n\txfrm_unregister_translator(&xfrm_translator);\n}\n\nmodule_init(xfrm_compat_init);\nmodule_exit(xfrm_compat_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Dmitry Safonov\");\nMODULE_DESCRIPTION(\"XFRM 32-bit compatibility layer\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}