{
  "module_name": "xfrm_state.c",
  "hash_id": "bc6029647891930f17af8b8231b576ae94c6e5c6dab081cee7a80f20bae3841b",
  "original_prompt": "Ingested from linux-6.6.14/net/xfrm/xfrm_state.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <net/xfrm.h>\n#include <linux/pfkeyv2.h>\n#include <linux/ipsec.h>\n#include <linux/module.h>\n#include <linux/cache.h>\n#include <linux/audit.h>\n#include <linux/uaccess.h>\n#include <linux/ktime.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n\n#include <crypto/aead.h>\n\n#include \"xfrm_hash.h\"\n\n#define xfrm_state_deref_prot(table, net) \\\n\trcu_dereference_protected((table), lockdep_is_held(&(net)->xfrm.xfrm_state_lock))\n\nstatic void xfrm_state_gc_task(struct work_struct *work);\n\n \n\nstatic unsigned int xfrm_state_hashmax __read_mostly = 1 * 1024 * 1024;\nstatic struct kmem_cache *xfrm_state_cache __ro_after_init;\n\nstatic DECLARE_WORK(xfrm_state_gc_work, xfrm_state_gc_task);\nstatic HLIST_HEAD(xfrm_state_gc_list);\n\nstatic inline bool xfrm_state_hold_rcu(struct xfrm_state __rcu *x)\n{\n\treturn refcount_inc_not_zero(&x->refcnt);\n}\n\nstatic inline unsigned int xfrm_dst_hash(struct net *net,\n\t\t\t\t\t const xfrm_address_t *daddr,\n\t\t\t\t\t const xfrm_address_t *saddr,\n\t\t\t\t\t u32 reqid,\n\t\t\t\t\t unsigned short family)\n{\n\treturn __xfrm_dst_hash(daddr, saddr, reqid, family, net->xfrm.state_hmask);\n}\n\nstatic inline unsigned int xfrm_src_hash(struct net *net,\n\t\t\t\t\t const xfrm_address_t *daddr,\n\t\t\t\t\t const xfrm_address_t *saddr,\n\t\t\t\t\t unsigned short family)\n{\n\treturn __xfrm_src_hash(daddr, saddr, family, net->xfrm.state_hmask);\n}\n\nstatic inline unsigned int\nxfrm_spi_hash(struct net *net, const xfrm_address_t *daddr,\n\t      __be32 spi, u8 proto, unsigned short family)\n{\n\treturn __xfrm_spi_hash(daddr, spi, proto, family, net->xfrm.state_hmask);\n}\n\nstatic unsigned int xfrm_seq_hash(struct net *net, u32 seq)\n{\n\treturn __xfrm_seq_hash(seq, net->xfrm.state_hmask);\n}\n\n#define XFRM_STATE_INSERT(by, _n, _h, _type)                               \\\n\t{                                                                  \\\n\t\tstruct xfrm_state *_x = NULL;                              \\\n\t\t\t\t\t\t\t\t\t   \\\n\t\tif (_type != XFRM_DEV_OFFLOAD_PACKET) {                    \\\n\t\t\thlist_for_each_entry_rcu(_x, _h, by) {             \\\n\t\t\t\tif (_x->xso.type == XFRM_DEV_OFFLOAD_PACKET) \\\n\t\t\t\t\tcontinue;                          \\\n\t\t\t\tbreak;                                     \\\n\t\t\t}                                                  \\\n\t\t}                                                          \\\n\t\t\t\t\t\t\t\t\t   \\\n\t\tif (!_x || _x->xso.type == XFRM_DEV_OFFLOAD_PACKET)        \\\n\t\t\t      \\\n\t\t\thlist_add_head_rcu(_n, _h);                        \\\n\t\telse                                                       \\\n\t\t\thlist_add_before_rcu(_n, &_x->by);                 \\\n\t}\n\nstatic void xfrm_hash_transfer(struct hlist_head *list,\n\t\t\t       struct hlist_head *ndsttable,\n\t\t\t       struct hlist_head *nsrctable,\n\t\t\t       struct hlist_head *nspitable,\n\t\t\t       struct hlist_head *nseqtable,\n\t\t\t       unsigned int nhashmask)\n{\n\tstruct hlist_node *tmp;\n\tstruct xfrm_state *x;\n\n\thlist_for_each_entry_safe(x, tmp, list, bydst) {\n\t\tunsigned int h;\n\n\t\th = __xfrm_dst_hash(&x->id.daddr, &x->props.saddr,\n\t\t\t\t    x->props.reqid, x->props.family,\n\t\t\t\t    nhashmask);\n\t\tXFRM_STATE_INSERT(bydst, &x->bydst, ndsttable + h, x->xso.type);\n\n\t\th = __xfrm_src_hash(&x->id.daddr, &x->props.saddr,\n\t\t\t\t    x->props.family,\n\t\t\t\t    nhashmask);\n\t\tXFRM_STATE_INSERT(bysrc, &x->bysrc, nsrctable + h, x->xso.type);\n\n\t\tif (x->id.spi) {\n\t\t\th = __xfrm_spi_hash(&x->id.daddr, x->id.spi,\n\t\t\t\t\t    x->id.proto, x->props.family,\n\t\t\t\t\t    nhashmask);\n\t\t\tXFRM_STATE_INSERT(byspi, &x->byspi, nspitable + h,\n\t\t\t\t\t  x->xso.type);\n\t\t}\n\n\t\tif (x->km.seq) {\n\t\t\th = __xfrm_seq_hash(x->km.seq, nhashmask);\n\t\t\tXFRM_STATE_INSERT(byseq, &x->byseq, nseqtable + h,\n\t\t\t\t\t  x->xso.type);\n\t\t}\n\t}\n}\n\nstatic unsigned long xfrm_hash_new_size(unsigned int state_hmask)\n{\n\treturn ((state_hmask + 1) << 1) * sizeof(struct hlist_head);\n}\n\nstatic void xfrm_hash_resize(struct work_struct *work)\n{\n\tstruct net *net = container_of(work, struct net, xfrm.state_hash_work);\n\tstruct hlist_head *ndst, *nsrc, *nspi, *nseq, *odst, *osrc, *ospi, *oseq;\n\tunsigned long nsize, osize;\n\tunsigned int nhashmask, ohashmask;\n\tint i;\n\n\tnsize = xfrm_hash_new_size(net->xfrm.state_hmask);\n\tndst = xfrm_hash_alloc(nsize);\n\tif (!ndst)\n\t\treturn;\n\tnsrc = xfrm_hash_alloc(nsize);\n\tif (!nsrc) {\n\t\txfrm_hash_free(ndst, nsize);\n\t\treturn;\n\t}\n\tnspi = xfrm_hash_alloc(nsize);\n\tif (!nspi) {\n\t\txfrm_hash_free(ndst, nsize);\n\t\txfrm_hash_free(nsrc, nsize);\n\t\treturn;\n\t}\n\tnseq = xfrm_hash_alloc(nsize);\n\tif (!nseq) {\n\t\txfrm_hash_free(ndst, nsize);\n\t\txfrm_hash_free(nsrc, nsize);\n\t\txfrm_hash_free(nspi, nsize);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\twrite_seqcount_begin(&net->xfrm.xfrm_state_hash_generation);\n\n\tnhashmask = (nsize / sizeof(struct hlist_head)) - 1U;\n\todst = xfrm_state_deref_prot(net->xfrm.state_bydst, net);\n\tfor (i = net->xfrm.state_hmask; i >= 0; i--)\n\t\txfrm_hash_transfer(odst + i, ndst, nsrc, nspi, nseq, nhashmask);\n\n\tosrc = xfrm_state_deref_prot(net->xfrm.state_bysrc, net);\n\tospi = xfrm_state_deref_prot(net->xfrm.state_byspi, net);\n\toseq = xfrm_state_deref_prot(net->xfrm.state_byseq, net);\n\tohashmask = net->xfrm.state_hmask;\n\n\trcu_assign_pointer(net->xfrm.state_bydst, ndst);\n\trcu_assign_pointer(net->xfrm.state_bysrc, nsrc);\n\trcu_assign_pointer(net->xfrm.state_byspi, nspi);\n\trcu_assign_pointer(net->xfrm.state_byseq, nseq);\n\tnet->xfrm.state_hmask = nhashmask;\n\n\twrite_seqcount_end(&net->xfrm.xfrm_state_hash_generation);\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\n\tosize = (ohashmask + 1) * sizeof(struct hlist_head);\n\n\tsynchronize_rcu();\n\n\txfrm_hash_free(odst, osize);\n\txfrm_hash_free(osrc, osize);\n\txfrm_hash_free(ospi, osize);\n\txfrm_hash_free(oseq, osize);\n}\n\nstatic DEFINE_SPINLOCK(xfrm_state_afinfo_lock);\nstatic struct xfrm_state_afinfo __rcu *xfrm_state_afinfo[NPROTO];\n\nstatic DEFINE_SPINLOCK(xfrm_state_gc_lock);\n\nint __xfrm_state_delete(struct xfrm_state *x);\n\nint km_query(struct xfrm_state *x, struct xfrm_tmpl *t, struct xfrm_policy *pol);\nstatic bool km_is_alive(const struct km_event *c);\nvoid km_state_expired(struct xfrm_state *x, int hard, u32 portid);\n\nint xfrm_register_type(const struct xfrm_type *type, unsigned short family)\n{\n\tstruct xfrm_state_afinfo *afinfo = xfrm_state_get_afinfo(family);\n\tint err = 0;\n\n\tif (!afinfo)\n\t\treturn -EAFNOSUPPORT;\n\n#define X(afi, T, name) do {\t\t\t\\\n\t\tWARN_ON((afi)->type_ ## name);\t\\\n\t\t(afi)->type_ ## name = (T);\t\\\n\t} while (0)\n\n\tswitch (type->proto) {\n\tcase IPPROTO_COMP:\n\t\tX(afinfo, type, comp);\n\t\tbreak;\n\tcase IPPROTO_AH:\n\t\tX(afinfo, type, ah);\n\t\tbreak;\n\tcase IPPROTO_ESP:\n\t\tX(afinfo, type, esp);\n\t\tbreak;\n\tcase IPPROTO_IPIP:\n\t\tX(afinfo, type, ipip);\n\t\tbreak;\n\tcase IPPROTO_DSTOPTS:\n\t\tX(afinfo, type, dstopts);\n\t\tbreak;\n\tcase IPPROTO_ROUTING:\n\t\tX(afinfo, type, routing);\n\t\tbreak;\n\tcase IPPROTO_IPV6:\n\t\tX(afinfo, type, ipip6);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\terr = -EPROTONOSUPPORT;\n\t\tbreak;\n\t}\n#undef X\n\trcu_read_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_register_type);\n\nvoid xfrm_unregister_type(const struct xfrm_type *type, unsigned short family)\n{\n\tstruct xfrm_state_afinfo *afinfo = xfrm_state_get_afinfo(family);\n\n\tif (unlikely(afinfo == NULL))\n\t\treturn;\n\n#define X(afi, T, name) do {\t\t\t\t\\\n\t\tWARN_ON((afi)->type_ ## name != (T));\t\\\n\t\t(afi)->type_ ## name = NULL;\t\t\\\n\t} while (0)\n\n\tswitch (type->proto) {\n\tcase IPPROTO_COMP:\n\t\tX(afinfo, type, comp);\n\t\tbreak;\n\tcase IPPROTO_AH:\n\t\tX(afinfo, type, ah);\n\t\tbreak;\n\tcase IPPROTO_ESP:\n\t\tX(afinfo, type, esp);\n\t\tbreak;\n\tcase IPPROTO_IPIP:\n\t\tX(afinfo, type, ipip);\n\t\tbreak;\n\tcase IPPROTO_DSTOPTS:\n\t\tX(afinfo, type, dstopts);\n\t\tbreak;\n\tcase IPPROTO_ROUTING:\n\t\tX(afinfo, type, routing);\n\t\tbreak;\n\tcase IPPROTO_IPV6:\n\t\tX(afinfo, type, ipip6);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n#undef X\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(xfrm_unregister_type);\n\nstatic const struct xfrm_type *xfrm_get_type(u8 proto, unsigned short family)\n{\n\tconst struct xfrm_type *type = NULL;\n\tstruct xfrm_state_afinfo *afinfo;\n\tint modload_attempted = 0;\n\nretry:\n\tafinfo = xfrm_state_get_afinfo(family);\n\tif (unlikely(afinfo == NULL))\n\t\treturn NULL;\n\n\tswitch (proto) {\n\tcase IPPROTO_COMP:\n\t\ttype = afinfo->type_comp;\n\t\tbreak;\n\tcase IPPROTO_AH:\n\t\ttype = afinfo->type_ah;\n\t\tbreak;\n\tcase IPPROTO_ESP:\n\t\ttype = afinfo->type_esp;\n\t\tbreak;\n\tcase IPPROTO_IPIP:\n\t\ttype = afinfo->type_ipip;\n\t\tbreak;\n\tcase IPPROTO_DSTOPTS:\n\t\ttype = afinfo->type_dstopts;\n\t\tbreak;\n\tcase IPPROTO_ROUTING:\n\t\ttype = afinfo->type_routing;\n\t\tbreak;\n\tcase IPPROTO_IPV6:\n\t\ttype = afinfo->type_ipip6;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (unlikely(type && !try_module_get(type->owner)))\n\t\ttype = NULL;\n\n\trcu_read_unlock();\n\n\tif (!type && !modload_attempted) {\n\t\trequest_module(\"xfrm-type-%d-%d\", family, proto);\n\t\tmodload_attempted = 1;\n\t\tgoto retry;\n\t}\n\n\treturn type;\n}\n\nstatic void xfrm_put_type(const struct xfrm_type *type)\n{\n\tmodule_put(type->owner);\n}\n\nint xfrm_register_type_offload(const struct xfrm_type_offload *type,\n\t\t\t       unsigned short family)\n{\n\tstruct xfrm_state_afinfo *afinfo = xfrm_state_get_afinfo(family);\n\tint err = 0;\n\n\tif (unlikely(afinfo == NULL))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (type->proto) {\n\tcase IPPROTO_ESP:\n\t\tWARN_ON(afinfo->type_offload_esp);\n\t\tafinfo->type_offload_esp = type;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\terr = -EPROTONOSUPPORT;\n\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_register_type_offload);\n\nvoid xfrm_unregister_type_offload(const struct xfrm_type_offload *type,\n\t\t\t\t  unsigned short family)\n{\n\tstruct xfrm_state_afinfo *afinfo = xfrm_state_get_afinfo(family);\n\n\tif (unlikely(afinfo == NULL))\n\t\treturn;\n\n\tswitch (type->proto) {\n\tcase IPPROTO_ESP:\n\t\tWARN_ON(afinfo->type_offload_esp != type);\n\t\tafinfo->type_offload_esp = NULL;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(xfrm_unregister_type_offload);\n\nstatic const struct xfrm_type_offload *\nxfrm_get_type_offload(u8 proto, unsigned short family, bool try_load)\n{\n\tconst struct xfrm_type_offload *type = NULL;\n\tstruct xfrm_state_afinfo *afinfo;\n\nretry:\n\tafinfo = xfrm_state_get_afinfo(family);\n\tif (unlikely(afinfo == NULL))\n\t\treturn NULL;\n\n\tswitch (proto) {\n\tcase IPPROTO_ESP:\n\t\ttype = afinfo->type_offload_esp;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((type && !try_module_get(type->owner)))\n\t\ttype = NULL;\n\n\trcu_read_unlock();\n\n\tif (!type && try_load) {\n\t\trequest_module(\"xfrm-offload-%d-%d\", family, proto);\n\t\ttry_load = false;\n\t\tgoto retry;\n\t}\n\n\treturn type;\n}\n\nstatic void xfrm_put_type_offload(const struct xfrm_type_offload *type)\n{\n\tmodule_put(type->owner);\n}\n\nstatic const struct xfrm_mode xfrm4_mode_map[XFRM_MODE_MAX] = {\n\t[XFRM_MODE_BEET] = {\n\t\t.encap = XFRM_MODE_BEET,\n\t\t.flags = XFRM_MODE_FLAG_TUNNEL,\n\t\t.family = AF_INET,\n\t},\n\t[XFRM_MODE_TRANSPORT] = {\n\t\t.encap = XFRM_MODE_TRANSPORT,\n\t\t.family = AF_INET,\n\t},\n\t[XFRM_MODE_TUNNEL] = {\n\t\t.encap = XFRM_MODE_TUNNEL,\n\t\t.flags = XFRM_MODE_FLAG_TUNNEL,\n\t\t.family = AF_INET,\n\t},\n};\n\nstatic const struct xfrm_mode xfrm6_mode_map[XFRM_MODE_MAX] = {\n\t[XFRM_MODE_BEET] = {\n\t\t.encap = XFRM_MODE_BEET,\n\t\t.flags = XFRM_MODE_FLAG_TUNNEL,\n\t\t.family = AF_INET6,\n\t},\n\t[XFRM_MODE_ROUTEOPTIMIZATION] = {\n\t\t.encap = XFRM_MODE_ROUTEOPTIMIZATION,\n\t\t.family = AF_INET6,\n\t},\n\t[XFRM_MODE_TRANSPORT] = {\n\t\t.encap = XFRM_MODE_TRANSPORT,\n\t\t.family = AF_INET6,\n\t},\n\t[XFRM_MODE_TUNNEL] = {\n\t\t.encap = XFRM_MODE_TUNNEL,\n\t\t.flags = XFRM_MODE_FLAG_TUNNEL,\n\t\t.family = AF_INET6,\n\t},\n};\n\nstatic const struct xfrm_mode *xfrm_get_mode(unsigned int encap, int family)\n{\n\tconst struct xfrm_mode *mode;\n\n\tif (unlikely(encap >= XFRM_MODE_MAX))\n\t\treturn NULL;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tmode = &xfrm4_mode_map[encap];\n\t\tif (mode->family == family)\n\t\t\treturn mode;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tmode = &xfrm6_mode_map[encap];\n\t\tif (mode->family == family)\n\t\t\treturn mode;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nvoid xfrm_state_free(struct xfrm_state *x)\n{\n\tkmem_cache_free(xfrm_state_cache, x);\n}\nEXPORT_SYMBOL(xfrm_state_free);\n\nstatic void ___xfrm_state_destroy(struct xfrm_state *x)\n{\n\thrtimer_cancel(&x->mtimer);\n\tdel_timer_sync(&x->rtimer);\n\tkfree(x->aead);\n\tkfree(x->aalg);\n\tkfree(x->ealg);\n\tkfree(x->calg);\n\tkfree(x->encap);\n\tkfree(x->coaddr);\n\tkfree(x->replay_esn);\n\tkfree(x->preplay_esn);\n\tif (x->type_offload)\n\t\txfrm_put_type_offload(x->type_offload);\n\tif (x->type) {\n\t\tx->type->destructor(x);\n\t\txfrm_put_type(x->type);\n\t}\n\tif (x->xfrag.page)\n\t\tput_page(x->xfrag.page);\n\txfrm_dev_state_free(x);\n\tsecurity_xfrm_state_free(x);\n\txfrm_state_free(x);\n}\n\nstatic void xfrm_state_gc_task(struct work_struct *work)\n{\n\tstruct xfrm_state *x;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head gc_list;\n\n\tspin_lock_bh(&xfrm_state_gc_lock);\n\thlist_move_list(&xfrm_state_gc_list, &gc_list);\n\tspin_unlock_bh(&xfrm_state_gc_lock);\n\n\tsynchronize_rcu();\n\n\thlist_for_each_entry_safe(x, tmp, &gc_list, gclist)\n\t\t___xfrm_state_destroy(x);\n}\n\nstatic enum hrtimer_restart xfrm_timer_handler(struct hrtimer *me)\n{\n\tstruct xfrm_state *x = container_of(me, struct xfrm_state, mtimer);\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\ttime64_t now = ktime_get_real_seconds();\n\ttime64_t next = TIME64_MAX;\n\tint warn = 0;\n\tint err = 0;\n\n\tspin_lock(&x->lock);\n\txfrm_dev_state_update_curlft(x);\n\n\tif (x->km.state == XFRM_STATE_DEAD)\n\t\tgoto out;\n\tif (x->km.state == XFRM_STATE_EXPIRED)\n\t\tgoto expired;\n\tif (x->lft.hard_add_expires_seconds) {\n\t\ttime64_t tmo = x->lft.hard_add_expires_seconds +\n\t\t\tx->curlft.add_time - now;\n\t\tif (tmo <= 0) {\n\t\t\tif (x->xflags & XFRM_SOFT_EXPIRE) {\n\t\t\t\t \n\t\t\t\tx->curlft.add_time = now - x->saved_tmo - 1;\n\t\t\t\ttmo = x->lft.hard_add_expires_seconds - x->saved_tmo;\n\t\t\t} else\n\t\t\t\tgoto expired;\n\t\t}\n\t\tif (tmo < next)\n\t\t\tnext = tmo;\n\t}\n\tif (x->lft.hard_use_expires_seconds) {\n\t\ttime64_t tmo = x->lft.hard_use_expires_seconds +\n\t\t\t(READ_ONCE(x->curlft.use_time) ? : now) - now;\n\t\tif (tmo <= 0)\n\t\t\tgoto expired;\n\t\tif (tmo < next)\n\t\t\tnext = tmo;\n\t}\n\tif (x->km.dying)\n\t\tgoto resched;\n\tif (x->lft.soft_add_expires_seconds) {\n\t\ttime64_t tmo = x->lft.soft_add_expires_seconds +\n\t\t\tx->curlft.add_time - now;\n\t\tif (tmo <= 0) {\n\t\t\twarn = 1;\n\t\t\tx->xflags &= ~XFRM_SOFT_EXPIRE;\n\t\t} else if (tmo < next) {\n\t\t\tnext = tmo;\n\t\t\tx->xflags |= XFRM_SOFT_EXPIRE;\n\t\t\tx->saved_tmo = tmo;\n\t\t}\n\t}\n\tif (x->lft.soft_use_expires_seconds) {\n\t\ttime64_t tmo = x->lft.soft_use_expires_seconds +\n\t\t\t(READ_ONCE(x->curlft.use_time) ? : now) - now;\n\t\tif (tmo <= 0)\n\t\t\twarn = 1;\n\t\telse if (tmo < next)\n\t\t\tnext = tmo;\n\t}\n\n\tx->km.dying = warn;\n\tif (warn)\n\t\tkm_state_expired(x, 0, 0);\nresched:\n\tif (next != TIME64_MAX) {\n\t\thrtimer_forward_now(&x->mtimer, ktime_set(next, 0));\n\t\tret = HRTIMER_RESTART;\n\t}\n\n\tgoto out;\n\nexpired:\n\tif (x->km.state == XFRM_STATE_ACQ && x->id.spi == 0)\n\t\tx->km.state = XFRM_STATE_EXPIRED;\n\n\terr = __xfrm_state_delete(x);\n\tif (!err)\n\t\tkm_state_expired(x, 1, 0);\n\n\txfrm_audit_state_delete(x, err ? 0 : 1, true);\n\nout:\n\tspin_unlock(&x->lock);\n\treturn ret;\n}\n\nstatic void xfrm_replay_timer_handler(struct timer_list *t);\n\nstruct xfrm_state *xfrm_state_alloc(struct net *net)\n{\n\tstruct xfrm_state *x;\n\n\tx = kmem_cache_zalloc(xfrm_state_cache, GFP_ATOMIC);\n\n\tif (x) {\n\t\twrite_pnet(&x->xs_net, net);\n\t\trefcount_set(&x->refcnt, 1);\n\t\tatomic_set(&x->tunnel_users, 0);\n\t\tINIT_LIST_HEAD(&x->km.all);\n\t\tINIT_HLIST_NODE(&x->bydst);\n\t\tINIT_HLIST_NODE(&x->bysrc);\n\t\tINIT_HLIST_NODE(&x->byspi);\n\t\tINIT_HLIST_NODE(&x->byseq);\n\t\thrtimer_init(&x->mtimer, CLOCK_BOOTTIME, HRTIMER_MODE_ABS_SOFT);\n\t\tx->mtimer.function = xfrm_timer_handler;\n\t\ttimer_setup(&x->rtimer, xfrm_replay_timer_handler, 0);\n\t\tx->curlft.add_time = ktime_get_real_seconds();\n\t\tx->lft.soft_byte_limit = XFRM_INF;\n\t\tx->lft.soft_packet_limit = XFRM_INF;\n\t\tx->lft.hard_byte_limit = XFRM_INF;\n\t\tx->lft.hard_packet_limit = XFRM_INF;\n\t\tx->replay_maxage = 0;\n\t\tx->replay_maxdiff = 0;\n\t\tspin_lock_init(&x->lock);\n\t}\n\treturn x;\n}\nEXPORT_SYMBOL(xfrm_state_alloc);\n\nvoid __xfrm_state_destroy(struct xfrm_state *x, bool sync)\n{\n\tWARN_ON(x->km.state != XFRM_STATE_DEAD);\n\n\tif (sync) {\n\t\tsynchronize_rcu();\n\t\t___xfrm_state_destroy(x);\n\t} else {\n\t\tspin_lock_bh(&xfrm_state_gc_lock);\n\t\thlist_add_head(&x->gclist, &xfrm_state_gc_list);\n\t\tspin_unlock_bh(&xfrm_state_gc_lock);\n\t\tschedule_work(&xfrm_state_gc_work);\n\t}\n}\nEXPORT_SYMBOL(__xfrm_state_destroy);\n\nint __xfrm_state_delete(struct xfrm_state *x)\n{\n\tstruct net *net = xs_net(x);\n\tint err = -ESRCH;\n\n\tif (x->km.state != XFRM_STATE_DEAD) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\tspin_lock(&net->xfrm.xfrm_state_lock);\n\t\tlist_del(&x->km.all);\n\t\thlist_del_rcu(&x->bydst);\n\t\thlist_del_rcu(&x->bysrc);\n\t\tif (x->km.seq)\n\t\t\thlist_del_rcu(&x->byseq);\n\t\tif (x->id.spi)\n\t\t\thlist_del_rcu(&x->byspi);\n\t\tnet->xfrm.state_num--;\n\t\tspin_unlock(&net->xfrm.xfrm_state_lock);\n\n\t\tif (x->encap_sk)\n\t\t\tsock_put(rcu_dereference_raw(x->encap_sk));\n\n\t\txfrm_dev_state_delete(x);\n\n\t\t \n\t\txfrm_state_put(x);\n\t\terr = 0;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL(__xfrm_state_delete);\n\nint xfrm_state_delete(struct xfrm_state *x)\n{\n\tint err;\n\n\tspin_lock_bh(&x->lock);\n\terr = __xfrm_state_delete(x);\n\tspin_unlock_bh(&x->lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_state_delete);\n\n#ifdef CONFIG_SECURITY_NETWORK_XFRM\nstatic inline int\nxfrm_state_flush_secctx_check(struct net *net, u8 proto, bool task_valid)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i <= net->xfrm.state_hmask; i++) {\n\t\tstruct xfrm_state *x;\n\n\t\thlist_for_each_entry(x, net->xfrm.state_bydst+i, bydst) {\n\t\t\tif (xfrm_id_proto_match(x->id.proto, proto) &&\n\t\t\t   (err = security_xfrm_state_delete(x)) != 0) {\n\t\t\t\txfrm_audit_state_delete(x, 0, task_valid);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic inline int\nxfrm_dev_state_flush_secctx_check(struct net *net, struct net_device *dev, bool task_valid)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i <= net->xfrm.state_hmask; i++) {\n\t\tstruct xfrm_state *x;\n\t\tstruct xfrm_dev_offload *xso;\n\n\t\thlist_for_each_entry(x, net->xfrm.state_bydst+i, bydst) {\n\t\t\txso = &x->xso;\n\n\t\t\tif (xso->dev == dev &&\n\t\t\t   (err = security_xfrm_state_delete(x)) != 0) {\n\t\t\t\txfrm_audit_state_delete(x, 0, task_valid);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn err;\n}\n#else\nstatic inline int\nxfrm_state_flush_secctx_check(struct net *net, u8 proto, bool task_valid)\n{\n\treturn 0;\n}\n\nstatic inline int\nxfrm_dev_state_flush_secctx_check(struct net *net, struct net_device *dev, bool task_valid)\n{\n\treturn 0;\n}\n#endif\n\nint xfrm_state_flush(struct net *net, u8 proto, bool task_valid, bool sync)\n{\n\tint i, err = 0, cnt = 0;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\terr = xfrm_state_flush_secctx_check(net, proto, task_valid);\n\tif (err)\n\t\tgoto out;\n\n\terr = -ESRCH;\n\tfor (i = 0; i <= net->xfrm.state_hmask; i++) {\n\t\tstruct xfrm_state *x;\nrestart:\n\t\thlist_for_each_entry(x, net->xfrm.state_bydst+i, bydst) {\n\t\t\tif (!xfrm_state_kern(x) &&\n\t\t\t    xfrm_id_proto_match(x->id.proto, proto)) {\n\t\t\t\txfrm_state_hold(x);\n\t\t\t\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\n\t\t\t\terr = xfrm_state_delete(x);\n\t\t\t\txfrm_audit_state_delete(x, err ? 0 : 1,\n\t\t\t\t\t\t\ttask_valid);\n\t\t\t\tif (sync)\n\t\t\t\t\txfrm_state_put_sync(x);\n\t\t\t\telse\n\t\t\t\t\txfrm_state_put(x);\n\t\t\t\tif (!err)\n\t\t\t\t\tcnt++;\n\n\t\t\t\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\tif (cnt)\n\t\terr = 0;\n\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_state_flush);\n\nint xfrm_dev_state_flush(struct net *net, struct net_device *dev, bool task_valid)\n{\n\tint i, err = 0, cnt = 0;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\terr = xfrm_dev_state_flush_secctx_check(net, dev, task_valid);\n\tif (err)\n\t\tgoto out;\n\n\terr = -ESRCH;\n\tfor (i = 0; i <= net->xfrm.state_hmask; i++) {\n\t\tstruct xfrm_state *x;\n\t\tstruct xfrm_dev_offload *xso;\nrestart:\n\t\thlist_for_each_entry(x, net->xfrm.state_bydst+i, bydst) {\n\t\t\txso = &x->xso;\n\n\t\t\tif (!xfrm_state_kern(x) && xso->dev == dev) {\n\t\t\t\txfrm_state_hold(x);\n\t\t\t\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\n\t\t\t\terr = xfrm_state_delete(x);\n\t\t\t\txfrm_audit_state_delete(x, err ? 0 : 1,\n\t\t\t\t\t\t\ttask_valid);\n\t\t\t\txfrm_state_put(x);\n\t\t\t\tif (!err)\n\t\t\t\t\tcnt++;\n\n\t\t\t\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt)\n\t\terr = 0;\n\nout:\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_dev_state_flush);\n\nvoid xfrm_sad_getinfo(struct net *net, struct xfrmk_sadinfo *si)\n{\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\tsi->sadcnt = net->xfrm.state_num;\n\tsi->sadhcnt = net->xfrm.state_hmask + 1;\n\tsi->sadhmcnt = xfrm_state_hashmax;\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n}\nEXPORT_SYMBOL(xfrm_sad_getinfo);\n\nstatic void\n__xfrm4_init_tempsel(struct xfrm_selector *sel, const struct flowi *fl)\n{\n\tconst struct flowi4 *fl4 = &fl->u.ip4;\n\n\tsel->daddr.a4 = fl4->daddr;\n\tsel->saddr.a4 = fl4->saddr;\n\tsel->dport = xfrm_flowi_dport(fl, &fl4->uli);\n\tsel->dport_mask = htons(0xffff);\n\tsel->sport = xfrm_flowi_sport(fl, &fl4->uli);\n\tsel->sport_mask = htons(0xffff);\n\tsel->family = AF_INET;\n\tsel->prefixlen_d = 32;\n\tsel->prefixlen_s = 32;\n\tsel->proto = fl4->flowi4_proto;\n\tsel->ifindex = fl4->flowi4_oif;\n}\n\nstatic void\n__xfrm6_init_tempsel(struct xfrm_selector *sel, const struct flowi *fl)\n{\n\tconst struct flowi6 *fl6 = &fl->u.ip6;\n\n\t \n\t*(struct in6_addr *)&sel->daddr = fl6->daddr;\n\t*(struct in6_addr *)&sel->saddr = fl6->saddr;\n\tsel->dport = xfrm_flowi_dport(fl, &fl6->uli);\n\tsel->dport_mask = htons(0xffff);\n\tsel->sport = xfrm_flowi_sport(fl, &fl6->uli);\n\tsel->sport_mask = htons(0xffff);\n\tsel->family = AF_INET6;\n\tsel->prefixlen_d = 128;\n\tsel->prefixlen_s = 128;\n\tsel->proto = fl6->flowi6_proto;\n\tsel->ifindex = fl6->flowi6_oif;\n}\n\nstatic void\nxfrm_init_tempstate(struct xfrm_state *x, const struct flowi *fl,\n\t\t    const struct xfrm_tmpl *tmpl,\n\t\t    const xfrm_address_t *daddr, const xfrm_address_t *saddr,\n\t\t    unsigned short family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\t__xfrm4_init_tempsel(&x->sel, fl);\n\t\tbreak;\n\tcase AF_INET6:\n\t\t__xfrm6_init_tempsel(&x->sel, fl);\n\t\tbreak;\n\t}\n\n\tx->id = tmpl->id;\n\n\tswitch (tmpl->encap_family) {\n\tcase AF_INET:\n\t\tif (x->id.daddr.a4 == 0)\n\t\t\tx->id.daddr.a4 = daddr->a4;\n\t\tx->props.saddr = tmpl->saddr;\n\t\tif (x->props.saddr.a4 == 0)\n\t\t\tx->props.saddr.a4 = saddr->a4;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (ipv6_addr_any((struct in6_addr *)&x->id.daddr))\n\t\t\tmemcpy(&x->id.daddr, daddr, sizeof(x->sel.daddr));\n\t\tmemcpy(&x->props.saddr, &tmpl->saddr, sizeof(x->props.saddr));\n\t\tif (ipv6_addr_any((struct in6_addr *)&x->props.saddr))\n\t\t\tmemcpy(&x->props.saddr, saddr, sizeof(x->props.saddr));\n\t\tbreak;\n\t}\n\n\tx->props.mode = tmpl->mode;\n\tx->props.reqid = tmpl->reqid;\n\tx->props.family = tmpl->encap_family;\n}\n\nstatic struct xfrm_state *__xfrm_state_lookup_all(struct net *net, u32 mark,\n\t\t\t\t\t\t  const xfrm_address_t *daddr,\n\t\t\t\t\t\t  __be32 spi, u8 proto,\n\t\t\t\t\t\t  unsigned short family,\n\t\t\t\t\t\t  struct xfrm_dev_offload *xdo)\n{\n\tunsigned int h = xfrm_spi_hash(net, daddr, spi, proto, family);\n\tstruct xfrm_state *x;\n\n\thlist_for_each_entry_rcu(x, net->xfrm.state_byspi + h, byspi) {\n#ifdef CONFIG_XFRM_OFFLOAD\n\t\tif (xdo->type == XFRM_DEV_OFFLOAD_PACKET) {\n\t\t\tif (x->xso.type != XFRM_DEV_OFFLOAD_PACKET)\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (xdo->dev != x->xso.dev)\n\t\t\t\tcontinue;\n\t\t} else if (x->xso.type == XFRM_DEV_OFFLOAD_PACKET)\n\t\t\t \n\t\t\tcontinue;\n#endif\n\t\tif (x->props.family != family ||\n\t\t    x->id.spi       != spi ||\n\t\t    x->id.proto     != proto ||\n\t\t    !xfrm_addr_equal(&x->id.daddr, daddr, family))\n\t\t\tcontinue;\n\n\t\tif ((mark & x->mark.m) != x->mark.v)\n\t\t\tcontinue;\n\t\tif (!xfrm_state_hold_rcu(x))\n\t\t\tcontinue;\n\t\treturn x;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct xfrm_state *__xfrm_state_lookup(struct net *net, u32 mark,\n\t\t\t\t\t      const xfrm_address_t *daddr,\n\t\t\t\t\t      __be32 spi, u8 proto,\n\t\t\t\t\t      unsigned short family)\n{\n\tunsigned int h = xfrm_spi_hash(net, daddr, spi, proto, family);\n\tstruct xfrm_state *x;\n\n\thlist_for_each_entry_rcu(x, net->xfrm.state_byspi + h, byspi) {\n\t\tif (x->props.family != family ||\n\t\t    x->id.spi       != spi ||\n\t\t    x->id.proto     != proto ||\n\t\t    !xfrm_addr_equal(&x->id.daddr, daddr, family))\n\t\t\tcontinue;\n\n\t\tif ((mark & x->mark.m) != x->mark.v)\n\t\t\tcontinue;\n\t\tif (!xfrm_state_hold_rcu(x))\n\t\t\tcontinue;\n\t\treturn x;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct xfrm_state *__xfrm_state_lookup_byaddr(struct net *net, u32 mark,\n\t\t\t\t\t\t     const xfrm_address_t *daddr,\n\t\t\t\t\t\t     const xfrm_address_t *saddr,\n\t\t\t\t\t\t     u8 proto, unsigned short family)\n{\n\tunsigned int h = xfrm_src_hash(net, daddr, saddr, family);\n\tstruct xfrm_state *x;\n\n\thlist_for_each_entry_rcu(x, net->xfrm.state_bysrc + h, bysrc) {\n\t\tif (x->props.family != family ||\n\t\t    x->id.proto     != proto ||\n\t\t    !xfrm_addr_equal(&x->id.daddr, daddr, family) ||\n\t\t    !xfrm_addr_equal(&x->props.saddr, saddr, family))\n\t\t\tcontinue;\n\n\t\tif ((mark & x->mark.m) != x->mark.v)\n\t\t\tcontinue;\n\t\tif (!xfrm_state_hold_rcu(x))\n\t\t\tcontinue;\n\t\treturn x;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline struct xfrm_state *\n__xfrm_state_locate(struct xfrm_state *x, int use_spi, int family)\n{\n\tstruct net *net = xs_net(x);\n\tu32 mark = x->mark.v & x->mark.m;\n\n\tif (use_spi)\n\t\treturn __xfrm_state_lookup(net, mark, &x->id.daddr,\n\t\t\t\t\t   x->id.spi, x->id.proto, family);\n\telse\n\t\treturn __xfrm_state_lookup_byaddr(net, mark,\n\t\t\t\t\t\t  &x->id.daddr,\n\t\t\t\t\t\t  &x->props.saddr,\n\t\t\t\t\t\t  x->id.proto, family);\n}\n\nstatic void xfrm_hash_grow_check(struct net *net, int have_hash_collision)\n{\n\tif (have_hash_collision &&\n\t    (net->xfrm.state_hmask + 1) < xfrm_state_hashmax &&\n\t    net->xfrm.state_num > net->xfrm.state_hmask)\n\t\tschedule_work(&net->xfrm.state_hash_work);\n}\n\nstatic void xfrm_state_look_at(struct xfrm_policy *pol, struct xfrm_state *x,\n\t\t\t       const struct flowi *fl, unsigned short family,\n\t\t\t       struct xfrm_state **best, int *acq_in_progress,\n\t\t\t       int *error)\n{\n\t \n\tif (x->km.state == XFRM_STATE_VALID) {\n\t\tif ((x->sel.family &&\n\t\t     (x->sel.family != family ||\n\t\t      !xfrm_selector_match(&x->sel, fl, family))) ||\n\t\t    !security_xfrm_state_pol_flow_match(x, pol,\n\t\t\t\t\t\t\t&fl->u.__fl_common))\n\t\t\treturn;\n\n\t\tif (!*best ||\n\t\t    (*best)->km.dying > x->km.dying ||\n\t\t    ((*best)->km.dying == x->km.dying &&\n\t\t     (*best)->curlft.add_time < x->curlft.add_time))\n\t\t\t*best = x;\n\t} else if (x->km.state == XFRM_STATE_ACQ) {\n\t\t*acq_in_progress = 1;\n\t} else if (x->km.state == XFRM_STATE_ERROR ||\n\t\t   x->km.state == XFRM_STATE_EXPIRED) {\n\t\tif ((!x->sel.family ||\n\t\t     (x->sel.family == family &&\n\t\t      xfrm_selector_match(&x->sel, fl, family))) &&\n\t\t    security_xfrm_state_pol_flow_match(x, pol,\n\t\t\t\t\t\t       &fl->u.__fl_common))\n\t\t\t*error = -ESRCH;\n\t}\n}\n\nstruct xfrm_state *\nxfrm_state_find(const xfrm_address_t *daddr, const xfrm_address_t *saddr,\n\t\tconst struct flowi *fl, struct xfrm_tmpl *tmpl,\n\t\tstruct xfrm_policy *pol, int *err,\n\t\tunsigned short family, u32 if_id)\n{\n\tstatic xfrm_address_t saddr_wildcard = { };\n\tstruct net *net = xp_net(pol);\n\tunsigned int h, h_wildcard;\n\tstruct xfrm_state *x, *x0, *to_put;\n\tint acquire_in_progress = 0;\n\tint error = 0;\n\tstruct xfrm_state *best = NULL;\n\tu32 mark = pol->mark.v & pol->mark.m;\n\tunsigned short encap_family = tmpl->encap_family;\n\tunsigned int sequence;\n\tstruct km_event c;\n\n\tto_put = NULL;\n\n\tsequence = read_seqcount_begin(&net->xfrm.xfrm_state_hash_generation);\n\n\trcu_read_lock();\n\th = xfrm_dst_hash(net, daddr, saddr, tmpl->reqid, encap_family);\n\thlist_for_each_entry_rcu(x, net->xfrm.state_bydst + h, bydst) {\n#ifdef CONFIG_XFRM_OFFLOAD\n\t\tif (pol->xdo.type == XFRM_DEV_OFFLOAD_PACKET) {\n\t\t\tif (x->xso.type != XFRM_DEV_OFFLOAD_PACKET)\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (pol->xdo.dev != x->xso.dev)\n\t\t\t\tcontinue;\n\t\t} else if (x->xso.type == XFRM_DEV_OFFLOAD_PACKET)\n\t\t\t \n\t\t\tcontinue;\n#endif\n\t\tif (x->props.family == encap_family &&\n\t\t    x->props.reqid == tmpl->reqid &&\n\t\t    (mark & x->mark.m) == x->mark.v &&\n\t\t    x->if_id == if_id &&\n\t\t    !(x->props.flags & XFRM_STATE_WILDRECV) &&\n\t\t    xfrm_state_addr_check(x, daddr, saddr, encap_family) &&\n\t\t    tmpl->mode == x->props.mode &&\n\t\t    tmpl->id.proto == x->id.proto &&\n\t\t    (tmpl->id.spi == x->id.spi || !tmpl->id.spi))\n\t\t\txfrm_state_look_at(pol, x, fl, family,\n\t\t\t\t\t   &best, &acquire_in_progress, &error);\n\t}\n\tif (best || acquire_in_progress)\n\t\tgoto found;\n\n\th_wildcard = xfrm_dst_hash(net, daddr, &saddr_wildcard, tmpl->reqid, encap_family);\n\thlist_for_each_entry_rcu(x, net->xfrm.state_bydst + h_wildcard, bydst) {\n#ifdef CONFIG_XFRM_OFFLOAD\n\t\tif (pol->xdo.type == XFRM_DEV_OFFLOAD_PACKET) {\n\t\t\tif (x->xso.type != XFRM_DEV_OFFLOAD_PACKET)\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (pol->xdo.dev != x->xso.dev)\n\t\t\t\tcontinue;\n\t\t} else if (x->xso.type == XFRM_DEV_OFFLOAD_PACKET)\n\t\t\t \n\t\t\tcontinue;\n#endif\n\t\tif (x->props.family == encap_family &&\n\t\t    x->props.reqid == tmpl->reqid &&\n\t\t    (mark & x->mark.m) == x->mark.v &&\n\t\t    x->if_id == if_id &&\n\t\t    !(x->props.flags & XFRM_STATE_WILDRECV) &&\n\t\t    xfrm_addr_equal(&x->id.daddr, daddr, encap_family) &&\n\t\t    tmpl->mode == x->props.mode &&\n\t\t    tmpl->id.proto == x->id.proto &&\n\t\t    (tmpl->id.spi == x->id.spi || !tmpl->id.spi))\n\t\t\txfrm_state_look_at(pol, x, fl, family,\n\t\t\t\t\t   &best, &acquire_in_progress, &error);\n\t}\n\nfound:\n\tx = best;\n\tif (!x && !error && !acquire_in_progress) {\n\t\tif (tmpl->id.spi &&\n\t\t    (x0 = __xfrm_state_lookup_all(net, mark, daddr,\n\t\t\t\t\t\t  tmpl->id.spi, tmpl->id.proto,\n\t\t\t\t\t\t  encap_family,\n\t\t\t\t\t\t  &pol->xdo)) != NULL) {\n\t\t\tto_put = x0;\n\t\t\terror = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tc.net = net;\n\t\t \n\t\tif (!km_is_alive(&c)) {\n\t\t\terror = -ESRCH;\n\t\t\tgoto out;\n\t\t}\n\n\t\tx = xfrm_state_alloc(net);\n\t\tif (x == NULL) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\txfrm_init_tempstate(x, fl, tmpl, daddr, saddr, family);\n\t\tmemcpy(&x->mark, &pol->mark, sizeof(x->mark));\n\t\tx->if_id = if_id;\n\n\t\terror = security_xfrm_state_alloc_acquire(x, pol->security, fl->flowi_secid);\n\t\tif (error) {\n\t\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t\tto_put = x;\n\t\t\tx = NULL;\n\t\t\tgoto out;\n\t\t}\n#ifdef CONFIG_XFRM_OFFLOAD\n\t\tif (pol->xdo.type == XFRM_DEV_OFFLOAD_PACKET) {\n\t\t\tstruct xfrm_dev_offload *xdo = &pol->xdo;\n\t\t\tstruct xfrm_dev_offload *xso = &x->xso;\n\n\t\t\txso->type = XFRM_DEV_OFFLOAD_PACKET;\n\t\t\txso->dir = xdo->dir;\n\t\t\txso->dev = xdo->dev;\n\t\t\txso->real_dev = xdo->real_dev;\n\t\t\txso->flags = XFRM_DEV_OFFLOAD_FLAG_ACQ;\n\t\t\tnetdev_tracker_alloc(xso->dev, &xso->dev_tracker,\n\t\t\t\t\t     GFP_ATOMIC);\n\t\t\terror = xso->dev->xfrmdev_ops->xdo_dev_state_add(x, NULL);\n\t\t\tif (error) {\n\t\t\t\txso->dir = 0;\n\t\t\t\tnetdev_put(xso->dev, &xso->dev_tracker);\n\t\t\t\txso->dev = NULL;\n\t\t\t\txso->real_dev = NULL;\n\t\t\t\txso->type = XFRM_DEV_OFFLOAD_UNSPECIFIED;\n\t\t\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t\t\tto_put = x;\n\t\t\t\tx = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (km_query(x, tmpl, pol) == 0) {\n\t\t\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\t\t\tx->km.state = XFRM_STATE_ACQ;\n\t\t\tlist_add(&x->km.all, &net->xfrm.state_all);\n\t\t\tXFRM_STATE_INSERT(bydst, &x->bydst,\n\t\t\t\t\t  net->xfrm.state_bydst + h,\n\t\t\t\t\t  x->xso.type);\n\t\t\th = xfrm_src_hash(net, daddr, saddr, encap_family);\n\t\t\tXFRM_STATE_INSERT(bysrc, &x->bysrc,\n\t\t\t\t\t  net->xfrm.state_bysrc + h,\n\t\t\t\t\t  x->xso.type);\n\t\t\tif (x->id.spi) {\n\t\t\t\th = xfrm_spi_hash(net, &x->id.daddr, x->id.spi, x->id.proto, encap_family);\n\t\t\t\tXFRM_STATE_INSERT(byspi, &x->byspi,\n\t\t\t\t\t\t  net->xfrm.state_byspi + h,\n\t\t\t\t\t\t  x->xso.type);\n\t\t\t}\n\t\t\tif (x->km.seq) {\n\t\t\t\th = xfrm_seq_hash(net, x->km.seq);\n\t\t\t\tXFRM_STATE_INSERT(byseq, &x->byseq,\n\t\t\t\t\t\t  net->xfrm.state_byseq + h,\n\t\t\t\t\t\t  x->xso.type);\n\t\t\t}\n\t\t\tx->lft.hard_add_expires_seconds = net->xfrm.sysctl_acq_expires;\n\t\t\thrtimer_start(&x->mtimer,\n\t\t\t\t      ktime_set(net->xfrm.sysctl_acq_expires, 0),\n\t\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t\t\tnet->xfrm.state_num++;\n\t\t\txfrm_hash_grow_check(net, x->bydst.next != NULL);\n\t\t\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\t\t} else {\n#ifdef CONFIG_XFRM_OFFLOAD\n\t\t\tstruct xfrm_dev_offload *xso = &x->xso;\n\n\t\t\tif (xso->type == XFRM_DEV_OFFLOAD_PACKET) {\n\t\t\t\txfrm_dev_state_delete(x);\n\t\t\t\txfrm_dev_state_free(x);\n\t\t\t}\n#endif\n\t\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t\tto_put = x;\n\t\t\tx = NULL;\n\t\t\terror = -ESRCH;\n\t\t}\n\t}\nout:\n\tif (x) {\n\t\tif (!xfrm_state_hold_rcu(x)) {\n\t\t\t*err = -EAGAIN;\n\t\t\tx = NULL;\n\t\t}\n\t} else {\n\t\t*err = acquire_in_progress ? -EAGAIN : error;\n\t}\n\trcu_read_unlock();\n\tif (to_put)\n\t\txfrm_state_put(to_put);\n\n\tif (read_seqcount_retry(&net->xfrm.xfrm_state_hash_generation, sequence)) {\n\t\t*err = -EAGAIN;\n\t\tif (x) {\n\t\t\txfrm_state_put(x);\n\t\t\tx = NULL;\n\t\t}\n\t}\n\n\treturn x;\n}\n\nstruct xfrm_state *\nxfrm_stateonly_find(struct net *net, u32 mark, u32 if_id,\n\t\t    xfrm_address_t *daddr, xfrm_address_t *saddr,\n\t\t    unsigned short family, u8 mode, u8 proto, u32 reqid)\n{\n\tunsigned int h;\n\tstruct xfrm_state *rx = NULL, *x = NULL;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\th = xfrm_dst_hash(net, daddr, saddr, reqid, family);\n\thlist_for_each_entry(x, net->xfrm.state_bydst+h, bydst) {\n\t\tif (x->props.family == family &&\n\t\t    x->props.reqid == reqid &&\n\t\t    (mark & x->mark.m) == x->mark.v &&\n\t\t    x->if_id == if_id &&\n\t\t    !(x->props.flags & XFRM_STATE_WILDRECV) &&\n\t\t    xfrm_state_addr_check(x, daddr, saddr, family) &&\n\t\t    mode == x->props.mode &&\n\t\t    proto == x->id.proto &&\n\t\t    x->km.state == XFRM_STATE_VALID) {\n\t\t\trx = x;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rx)\n\t\txfrm_state_hold(rx);\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\n\n\treturn rx;\n}\nEXPORT_SYMBOL(xfrm_stateonly_find);\n\nstruct xfrm_state *xfrm_state_lookup_byspi(struct net *net, __be32 spi,\n\t\t\t\t\t      unsigned short family)\n{\n\tstruct xfrm_state *x;\n\tstruct xfrm_state_walk *w;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\tlist_for_each_entry(w, &net->xfrm.state_all, all) {\n\t\tx = container_of(w, struct xfrm_state, km);\n\t\tif (x->props.family != family ||\n\t\t\tx->id.spi != spi)\n\t\t\tcontinue;\n\n\t\txfrm_state_hold(x);\n\t\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\t\treturn x;\n\t}\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\treturn NULL;\n}\nEXPORT_SYMBOL(xfrm_state_lookup_byspi);\n\nstatic void __xfrm_state_insert(struct xfrm_state *x)\n{\n\tstruct net *net = xs_net(x);\n\tunsigned int h;\n\n\tlist_add(&x->km.all, &net->xfrm.state_all);\n\n\th = xfrm_dst_hash(net, &x->id.daddr, &x->props.saddr,\n\t\t\t  x->props.reqid, x->props.family);\n\tXFRM_STATE_INSERT(bydst, &x->bydst, net->xfrm.state_bydst + h,\n\t\t\t  x->xso.type);\n\n\th = xfrm_src_hash(net, &x->id.daddr, &x->props.saddr, x->props.family);\n\tXFRM_STATE_INSERT(bysrc, &x->bysrc, net->xfrm.state_bysrc + h,\n\t\t\t  x->xso.type);\n\n\tif (x->id.spi) {\n\t\th = xfrm_spi_hash(net, &x->id.daddr, x->id.spi, x->id.proto,\n\t\t\t\t  x->props.family);\n\n\t\tXFRM_STATE_INSERT(byspi, &x->byspi, net->xfrm.state_byspi + h,\n\t\t\t\t  x->xso.type);\n\t}\n\n\tif (x->km.seq) {\n\t\th = xfrm_seq_hash(net, x->km.seq);\n\n\t\tXFRM_STATE_INSERT(byseq, &x->byseq, net->xfrm.state_byseq + h,\n\t\t\t\t  x->xso.type);\n\t}\n\n\thrtimer_start(&x->mtimer, ktime_set(1, 0), HRTIMER_MODE_REL_SOFT);\n\tif (x->replay_maxage)\n\t\tmod_timer(&x->rtimer, jiffies + x->replay_maxage);\n\n\tnet->xfrm.state_num++;\n\n\txfrm_hash_grow_check(net, x->bydst.next != NULL);\n}\n\n \nstatic void __xfrm_state_bump_genids(struct xfrm_state *xnew)\n{\n\tstruct net *net = xs_net(xnew);\n\tunsigned short family = xnew->props.family;\n\tu32 reqid = xnew->props.reqid;\n\tstruct xfrm_state *x;\n\tunsigned int h;\n\tu32 mark = xnew->mark.v & xnew->mark.m;\n\tu32 if_id = xnew->if_id;\n\n\th = xfrm_dst_hash(net, &xnew->id.daddr, &xnew->props.saddr, reqid, family);\n\thlist_for_each_entry(x, net->xfrm.state_bydst+h, bydst) {\n\t\tif (x->props.family\t== family &&\n\t\t    x->props.reqid\t== reqid &&\n\t\t    x->if_id\t\t== if_id &&\n\t\t    (mark & x->mark.m) == x->mark.v &&\n\t\t    xfrm_addr_equal(&x->id.daddr, &xnew->id.daddr, family) &&\n\t\t    xfrm_addr_equal(&x->props.saddr, &xnew->props.saddr, family))\n\t\t\tx->genid++;\n\t}\n}\n\nvoid xfrm_state_insert(struct xfrm_state *x)\n{\n\tstruct net *net = xs_net(x);\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\t__xfrm_state_bump_genids(x);\n\t__xfrm_state_insert(x);\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n}\nEXPORT_SYMBOL(xfrm_state_insert);\n\n \nstatic struct xfrm_state *__find_acq_core(struct net *net,\n\t\t\t\t\t  const struct xfrm_mark *m,\n\t\t\t\t\t  unsigned short family, u8 mode,\n\t\t\t\t\t  u32 reqid, u32 if_id, u8 proto,\n\t\t\t\t\t  const xfrm_address_t *daddr,\n\t\t\t\t\t  const xfrm_address_t *saddr,\n\t\t\t\t\t  int create)\n{\n\tunsigned int h = xfrm_dst_hash(net, daddr, saddr, reqid, family);\n\tstruct xfrm_state *x;\n\tu32 mark = m->v & m->m;\n\n\thlist_for_each_entry(x, net->xfrm.state_bydst+h, bydst) {\n\t\tif (x->props.reqid  != reqid ||\n\t\t    x->props.mode   != mode ||\n\t\t    x->props.family != family ||\n\t\t    x->km.state     != XFRM_STATE_ACQ ||\n\t\t    x->id.spi       != 0 ||\n\t\t    x->id.proto\t    != proto ||\n\t\t    (mark & x->mark.m) != x->mark.v ||\n\t\t    !xfrm_addr_equal(&x->id.daddr, daddr, family) ||\n\t\t    !xfrm_addr_equal(&x->props.saddr, saddr, family))\n\t\t\tcontinue;\n\n\t\txfrm_state_hold(x);\n\t\treturn x;\n\t}\n\n\tif (!create)\n\t\treturn NULL;\n\n\tx = xfrm_state_alloc(net);\n\tif (likely(x)) {\n\t\tswitch (family) {\n\t\tcase AF_INET:\n\t\t\tx->sel.daddr.a4 = daddr->a4;\n\t\t\tx->sel.saddr.a4 = saddr->a4;\n\t\t\tx->sel.prefixlen_d = 32;\n\t\t\tx->sel.prefixlen_s = 32;\n\t\t\tx->props.saddr.a4 = saddr->a4;\n\t\t\tx->id.daddr.a4 = daddr->a4;\n\t\t\tbreak;\n\n\t\tcase AF_INET6:\n\t\t\tx->sel.daddr.in6 = daddr->in6;\n\t\t\tx->sel.saddr.in6 = saddr->in6;\n\t\t\tx->sel.prefixlen_d = 128;\n\t\t\tx->sel.prefixlen_s = 128;\n\t\t\tx->props.saddr.in6 = saddr->in6;\n\t\t\tx->id.daddr.in6 = daddr->in6;\n\t\t\tbreak;\n\t\t}\n\n\t\tx->km.state = XFRM_STATE_ACQ;\n\t\tx->id.proto = proto;\n\t\tx->props.family = family;\n\t\tx->props.mode = mode;\n\t\tx->props.reqid = reqid;\n\t\tx->if_id = if_id;\n\t\tx->mark.v = m->v;\n\t\tx->mark.m = m->m;\n\t\tx->lft.hard_add_expires_seconds = net->xfrm.sysctl_acq_expires;\n\t\txfrm_state_hold(x);\n\t\thrtimer_start(&x->mtimer,\n\t\t\t      ktime_set(net->xfrm.sysctl_acq_expires, 0),\n\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t\tlist_add(&x->km.all, &net->xfrm.state_all);\n\t\tXFRM_STATE_INSERT(bydst, &x->bydst, net->xfrm.state_bydst + h,\n\t\t\t\t  x->xso.type);\n\t\th = xfrm_src_hash(net, daddr, saddr, family);\n\t\tXFRM_STATE_INSERT(bysrc, &x->bysrc, net->xfrm.state_bysrc + h,\n\t\t\t\t  x->xso.type);\n\n\t\tnet->xfrm.state_num++;\n\n\t\txfrm_hash_grow_check(net, x->bydst.next != NULL);\n\t}\n\n\treturn x;\n}\n\nstatic struct xfrm_state *__xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq);\n\nint xfrm_state_add(struct xfrm_state *x)\n{\n\tstruct net *net = xs_net(x);\n\tstruct xfrm_state *x1, *to_put;\n\tint family;\n\tint err;\n\tu32 mark = x->mark.v & x->mark.m;\n\tint use_spi = xfrm_id_proto_match(x->id.proto, IPSEC_PROTO_ANY);\n\n\tfamily = x->props.family;\n\n\tto_put = NULL;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\n\tx1 = __xfrm_state_locate(x, use_spi, family);\n\tif (x1) {\n\t\tto_put = x1;\n\t\tx1 = NULL;\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (use_spi && x->km.seq) {\n\t\tx1 = __xfrm_find_acq_byseq(net, mark, x->km.seq);\n\t\tif (x1 && ((x1->id.proto != x->id.proto) ||\n\t\t    !xfrm_addr_equal(&x1->id.daddr, &x->id.daddr, family))) {\n\t\t\tto_put = x1;\n\t\t\tx1 = NULL;\n\t\t}\n\t}\n\n\tif (use_spi && !x1)\n\t\tx1 = __find_acq_core(net, &x->mark, family, x->props.mode,\n\t\t\t\t     x->props.reqid, x->if_id, x->id.proto,\n\t\t\t\t     &x->id.daddr, &x->props.saddr, 0);\n\n\t__xfrm_state_bump_genids(x);\n\t__xfrm_state_insert(x);\n\terr = 0;\n\nout:\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\n\tif (x1) {\n\t\txfrm_state_delete(x1);\n\t\txfrm_state_put(x1);\n\t}\n\n\tif (to_put)\n\t\txfrm_state_put(to_put);\n\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_state_add);\n\n#ifdef CONFIG_XFRM_MIGRATE\nstatic inline int clone_security(struct xfrm_state *x, struct xfrm_sec_ctx *security)\n{\n\tstruct xfrm_user_sec_ctx *uctx;\n\tint size = sizeof(*uctx) + security->ctx_len;\n\tint err;\n\n\tuctx = kmalloc(size, GFP_KERNEL);\n\tif (!uctx)\n\t\treturn -ENOMEM;\n\n\tuctx->exttype = XFRMA_SEC_CTX;\n\tuctx->len = size;\n\tuctx->ctx_doi = security->ctx_doi;\n\tuctx->ctx_alg = security->ctx_alg;\n\tuctx->ctx_len = security->ctx_len;\n\tmemcpy(uctx + 1, security->ctx_str, security->ctx_len);\n\terr = security_xfrm_state_alloc(x, uctx);\n\tkfree(uctx);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic struct xfrm_state *xfrm_state_clone(struct xfrm_state *orig,\n\t\t\t\t\t   struct xfrm_encap_tmpl *encap)\n{\n\tstruct net *net = xs_net(orig);\n\tstruct xfrm_state *x = xfrm_state_alloc(net);\n\tif (!x)\n\t\tgoto out;\n\n\tmemcpy(&x->id, &orig->id, sizeof(x->id));\n\tmemcpy(&x->sel, &orig->sel, sizeof(x->sel));\n\tmemcpy(&x->lft, &orig->lft, sizeof(x->lft));\n\tx->props.mode = orig->props.mode;\n\tx->props.replay_window = orig->props.replay_window;\n\tx->props.reqid = orig->props.reqid;\n\tx->props.family = orig->props.family;\n\tx->props.saddr = orig->props.saddr;\n\n\tif (orig->aalg) {\n\t\tx->aalg = xfrm_algo_auth_clone(orig->aalg);\n\t\tif (!x->aalg)\n\t\t\tgoto error;\n\t}\n\tx->props.aalgo = orig->props.aalgo;\n\n\tif (orig->aead) {\n\t\tx->aead = xfrm_algo_aead_clone(orig->aead);\n\t\tx->geniv = orig->geniv;\n\t\tif (!x->aead)\n\t\t\tgoto error;\n\t}\n\tif (orig->ealg) {\n\t\tx->ealg = xfrm_algo_clone(orig->ealg);\n\t\tif (!x->ealg)\n\t\t\tgoto error;\n\t}\n\tx->props.ealgo = orig->props.ealgo;\n\n\tif (orig->calg) {\n\t\tx->calg = xfrm_algo_clone(orig->calg);\n\t\tif (!x->calg)\n\t\t\tgoto error;\n\t}\n\tx->props.calgo = orig->props.calgo;\n\n\tif (encap || orig->encap) {\n\t\tif (encap)\n\t\t\tx->encap = kmemdup(encap, sizeof(*x->encap),\n\t\t\t\t\tGFP_KERNEL);\n\t\telse\n\t\t\tx->encap = kmemdup(orig->encap, sizeof(*x->encap),\n\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!x->encap)\n\t\t\tgoto error;\n\t}\n\n\tif (orig->security)\n\t\tif (clone_security(x, orig->security))\n\t\t\tgoto error;\n\n\tif (orig->coaddr) {\n\t\tx->coaddr = kmemdup(orig->coaddr, sizeof(*x->coaddr),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!x->coaddr)\n\t\t\tgoto error;\n\t}\n\n\tif (orig->replay_esn) {\n\t\tif (xfrm_replay_clone(x, orig))\n\t\t\tgoto error;\n\t}\n\n\tmemcpy(&x->mark, &orig->mark, sizeof(x->mark));\n\tmemcpy(&x->props.smark, &orig->props.smark, sizeof(x->props.smark));\n\n\tx->props.flags = orig->props.flags;\n\tx->props.extra_flags = orig->props.extra_flags;\n\n\tx->if_id = orig->if_id;\n\tx->tfcpad = orig->tfcpad;\n\tx->replay_maxdiff = orig->replay_maxdiff;\n\tx->replay_maxage = orig->replay_maxage;\n\tmemcpy(&x->curlft, &orig->curlft, sizeof(x->curlft));\n\tx->km.state = orig->km.state;\n\tx->km.seq = orig->km.seq;\n\tx->replay = orig->replay;\n\tx->preplay = orig->preplay;\n\tx->mapping_maxage = orig->mapping_maxage;\n\tx->lastused = orig->lastused;\n\tx->new_mapping = 0;\n\tx->new_mapping_sport = 0;\n\n\treturn x;\n\n error:\n\txfrm_state_put(x);\nout:\n\treturn NULL;\n}\n\nstruct xfrm_state *xfrm_migrate_state_find(struct xfrm_migrate *m, struct net *net,\n\t\t\t\t\t\tu32 if_id)\n{\n\tunsigned int h;\n\tstruct xfrm_state *x = NULL;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\n\tif (m->reqid) {\n\t\th = xfrm_dst_hash(net, &m->old_daddr, &m->old_saddr,\n\t\t\t\t  m->reqid, m->old_family);\n\t\thlist_for_each_entry(x, net->xfrm.state_bydst+h, bydst) {\n\t\t\tif (x->props.mode != m->mode ||\n\t\t\t    x->id.proto != m->proto)\n\t\t\t\tcontinue;\n\t\t\tif (m->reqid && x->props.reqid != m->reqid)\n\t\t\t\tcontinue;\n\t\t\tif (if_id != 0 && x->if_id != if_id)\n\t\t\t\tcontinue;\n\t\t\tif (!xfrm_addr_equal(&x->id.daddr, &m->old_daddr,\n\t\t\t\t\t     m->old_family) ||\n\t\t\t    !xfrm_addr_equal(&x->props.saddr, &m->old_saddr,\n\t\t\t\t\t     m->old_family))\n\t\t\t\tcontinue;\n\t\t\txfrm_state_hold(x);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\th = xfrm_src_hash(net, &m->old_daddr, &m->old_saddr,\n\t\t\t\t  m->old_family);\n\t\thlist_for_each_entry(x, net->xfrm.state_bysrc+h, bysrc) {\n\t\t\tif (x->props.mode != m->mode ||\n\t\t\t    x->id.proto != m->proto)\n\t\t\t\tcontinue;\n\t\t\tif (if_id != 0 && x->if_id != if_id)\n\t\t\t\tcontinue;\n\t\t\tif (!xfrm_addr_equal(&x->id.daddr, &m->old_daddr,\n\t\t\t\t\t     m->old_family) ||\n\t\t\t    !xfrm_addr_equal(&x->props.saddr, &m->old_saddr,\n\t\t\t\t\t     m->old_family))\n\t\t\t\tcontinue;\n\t\t\txfrm_state_hold(x);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\n\treturn x;\n}\nEXPORT_SYMBOL(xfrm_migrate_state_find);\n\nstruct xfrm_state *xfrm_state_migrate(struct xfrm_state *x,\n\t\t\t\t      struct xfrm_migrate *m,\n\t\t\t\t      struct xfrm_encap_tmpl *encap)\n{\n\tstruct xfrm_state *xc;\n\n\txc = xfrm_state_clone(x, encap);\n\tif (!xc)\n\t\treturn NULL;\n\n\txc->props.family = m->new_family;\n\n\tif (xfrm_init_state(xc) < 0)\n\t\tgoto error;\n\n\tmemcpy(&xc->id.daddr, &m->new_daddr, sizeof(xc->id.daddr));\n\tmemcpy(&xc->props.saddr, &m->new_saddr, sizeof(xc->props.saddr));\n\n\t \n\tif (xfrm_addr_equal(&x->id.daddr, &m->new_daddr, m->new_family)) {\n\t\t \n\t\txfrm_state_insert(xc);\n\t} else {\n\t\tif (xfrm_state_add(xc) < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn xc;\nerror:\n\txfrm_state_put(xc);\n\treturn NULL;\n}\nEXPORT_SYMBOL(xfrm_state_migrate);\n#endif\n\nint xfrm_state_update(struct xfrm_state *x)\n{\n\tstruct xfrm_state *x1, *to_put;\n\tint err;\n\tint use_spi = xfrm_id_proto_match(x->id.proto, IPSEC_PROTO_ANY);\n\tstruct net *net = xs_net(x);\n\n\tto_put = NULL;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\tx1 = __xfrm_state_locate(x, use_spi, x->props.family);\n\n\terr = -ESRCH;\n\tif (!x1)\n\t\tgoto out;\n\n\tif (xfrm_state_kern(x1)) {\n\t\tto_put = x1;\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (x1->km.state == XFRM_STATE_ACQ) {\n\t\t__xfrm_state_insert(x);\n\t\tx = NULL;\n\t}\n\terr = 0;\n\nout:\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\n\tif (to_put)\n\t\txfrm_state_put(to_put);\n\n\tif (err)\n\t\treturn err;\n\n\tif (!x) {\n\t\txfrm_state_delete(x1);\n\t\txfrm_state_put(x1);\n\t\treturn 0;\n\t}\n\n\terr = -EINVAL;\n\tspin_lock_bh(&x1->lock);\n\tif (likely(x1->km.state == XFRM_STATE_VALID)) {\n\t\tif (x->encap && x1->encap &&\n\t\t    x->encap->encap_type == x1->encap->encap_type)\n\t\t\tmemcpy(x1->encap, x->encap, sizeof(*x1->encap));\n\t\telse if (x->encap || x1->encap)\n\t\t\tgoto fail;\n\n\t\tif (x->coaddr && x1->coaddr) {\n\t\t\tmemcpy(x1->coaddr, x->coaddr, sizeof(*x1->coaddr));\n\t\t}\n\t\tif (!use_spi && memcmp(&x1->sel, &x->sel, sizeof(x1->sel)))\n\t\t\tmemcpy(&x1->sel, &x->sel, sizeof(x1->sel));\n\t\tmemcpy(&x1->lft, &x->lft, sizeof(x1->lft));\n\t\tx1->km.dying = 0;\n\n\t\thrtimer_start(&x1->mtimer, ktime_set(1, 0),\n\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t\tif (READ_ONCE(x1->curlft.use_time))\n\t\t\txfrm_state_check_expire(x1);\n\n\t\tif (x->props.smark.m || x->props.smark.v || x->if_id) {\n\t\t\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\n\t\t\tif (x->props.smark.m || x->props.smark.v)\n\t\t\t\tx1->props.smark = x->props.smark;\n\n\t\t\tif (x->if_id)\n\t\t\t\tx1->if_id = x->if_id;\n\n\t\t\t__xfrm_state_bump_genids(x1);\n\t\t\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\t\t}\n\n\t\terr = 0;\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t}\n\nfail:\n\tspin_unlock_bh(&x1->lock);\n\n\txfrm_state_put(x1);\n\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_state_update);\n\nint xfrm_state_check_expire(struct xfrm_state *x)\n{\n\txfrm_dev_state_update_curlft(x);\n\n\tif (!READ_ONCE(x->curlft.use_time))\n\t\tWRITE_ONCE(x->curlft.use_time, ktime_get_real_seconds());\n\n\tif (x->curlft.bytes >= x->lft.hard_byte_limit ||\n\t    x->curlft.packets >= x->lft.hard_packet_limit) {\n\t\tx->km.state = XFRM_STATE_EXPIRED;\n\t\thrtimer_start(&x->mtimer, 0, HRTIMER_MODE_REL_SOFT);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!x->km.dying &&\n\t    (x->curlft.bytes >= x->lft.soft_byte_limit ||\n\t     x->curlft.packets >= x->lft.soft_packet_limit)) {\n\t\tx->km.dying = 1;\n\t\tkm_state_expired(x, 0, 0);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(xfrm_state_check_expire);\n\nstruct xfrm_state *\nxfrm_state_lookup(struct net *net, u32 mark, const xfrm_address_t *daddr, __be32 spi,\n\t\t  u8 proto, unsigned short family)\n{\n\tstruct xfrm_state *x;\n\n\trcu_read_lock();\n\tx = __xfrm_state_lookup(net, mark, daddr, spi, proto, family);\n\trcu_read_unlock();\n\treturn x;\n}\nEXPORT_SYMBOL(xfrm_state_lookup);\n\nstruct xfrm_state *\nxfrm_state_lookup_byaddr(struct net *net, u32 mark,\n\t\t\t const xfrm_address_t *daddr, const xfrm_address_t *saddr,\n\t\t\t u8 proto, unsigned short family)\n{\n\tstruct xfrm_state *x;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\tx = __xfrm_state_lookup_byaddr(net, mark, daddr, saddr, proto, family);\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\treturn x;\n}\nEXPORT_SYMBOL(xfrm_state_lookup_byaddr);\n\nstruct xfrm_state *\nxfrm_find_acq(struct net *net, const struct xfrm_mark *mark, u8 mode, u32 reqid,\n\t      u32 if_id, u8 proto, const xfrm_address_t *daddr,\n\t      const xfrm_address_t *saddr, int create, unsigned short family)\n{\n\tstruct xfrm_state *x;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\tx = __find_acq_core(net, mark, family, mode, reqid, if_id, proto, daddr, saddr, create);\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\n\treturn x;\n}\nEXPORT_SYMBOL(xfrm_find_acq);\n\n#ifdef CONFIG_XFRM_SUB_POLICY\n#if IS_ENABLED(CONFIG_IPV6)\n \nstatic void\n__xfrm6_sort(void **dst, void **src, int n,\n\t     int (*cmp)(const void *p), int maxclass)\n{\n\tint count[XFRM_MAX_DEPTH] = { };\n\tint class[XFRM_MAX_DEPTH];\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tint c = cmp(src[i]);\n\n\t\tclass[i] = c;\n\t\tcount[c]++;\n\t}\n\n\tfor (i = 2; i < maxclass; i++)\n\t\tcount[i] += count[i - 1];\n\n\tfor (i = 0; i < n; i++) {\n\t\tdst[count[class[i] - 1]++] = src[i];\n\t\tsrc[i] = NULL;\n\t}\n}\n\n \nstatic int __xfrm6_state_sort_cmp(const void *p)\n{\n\tconst struct xfrm_state *v = p;\n\n\tswitch (v->props.mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\t\tif (v->id.proto != IPPROTO_AH)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 3;\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\tcase XFRM_MODE_ROUTEOPTIMIZATION:\n\tcase XFRM_MODE_IN_TRIGGER:\n\t\treturn 2;\n#endif\n\tcase XFRM_MODE_TUNNEL:\n\tcase XFRM_MODE_BEET:\n\t\treturn 4;\n\t}\n\treturn 5;\n}\n\n \nstatic int __xfrm6_tmpl_sort_cmp(const void *p)\n{\n\tconst struct xfrm_tmpl *v = p;\n\n\tswitch (v->mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\t\treturn 1;\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\tcase XFRM_MODE_ROUTEOPTIMIZATION:\n\tcase XFRM_MODE_IN_TRIGGER:\n\t\treturn 2;\n#endif\n\tcase XFRM_MODE_TUNNEL:\n\tcase XFRM_MODE_BEET:\n\t\treturn 3;\n\t}\n\treturn 4;\n}\n#else\nstatic inline int __xfrm6_state_sort_cmp(const void *p) { return 5; }\nstatic inline int __xfrm6_tmpl_sort_cmp(const void *p) { return 4; }\n\nstatic inline void\n__xfrm6_sort(void **dst, void **src, int n,\n\t     int (*cmp)(const void *p), int maxclass)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tdst[i] = src[i];\n}\n#endif  \n\nvoid\nxfrm_tmpl_sort(struct xfrm_tmpl **dst, struct xfrm_tmpl **src, int n,\n\t       unsigned short family)\n{\n\tint i;\n\n\tif (family == AF_INET6)\n\t\t__xfrm6_sort((void **)dst, (void **)src, n,\n\t\t\t     __xfrm6_tmpl_sort_cmp, 5);\n\telse\n\t\tfor (i = 0; i < n; i++)\n\t\t\tdst[i] = src[i];\n}\n\nvoid\nxfrm_state_sort(struct xfrm_state **dst, struct xfrm_state **src, int n,\n\t\tunsigned short family)\n{\n\tint i;\n\n\tif (family == AF_INET6)\n\t\t__xfrm6_sort((void **)dst, (void **)src, n,\n\t\t\t     __xfrm6_state_sort_cmp, 6);\n\telse\n\t\tfor (i = 0; i < n; i++)\n\t\t\tdst[i] = src[i];\n}\n#endif\n\n \n\nstatic struct xfrm_state *__xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq)\n{\n\tunsigned int h = xfrm_seq_hash(net, seq);\n\tstruct xfrm_state *x;\n\n\thlist_for_each_entry_rcu(x, net->xfrm.state_byseq + h, byseq) {\n\t\tif (x->km.seq == seq &&\n\t\t    (mark & x->mark.m) == x->mark.v &&\n\t\t    x->km.state == XFRM_STATE_ACQ) {\n\t\t\txfrm_state_hold(x);\n\t\t\treturn x;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq)\n{\n\tstruct xfrm_state *x;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\tx = __xfrm_find_acq_byseq(net, mark, seq);\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\treturn x;\n}\nEXPORT_SYMBOL(xfrm_find_acq_byseq);\n\nu32 xfrm_get_acqseq(void)\n{\n\tu32 res;\n\tstatic atomic_t acqseq;\n\n\tdo {\n\t\tres = atomic_inc_return(&acqseq);\n\t} while (!res);\n\n\treturn res;\n}\nEXPORT_SYMBOL(xfrm_get_acqseq);\n\nint verify_spi_info(u8 proto, u32 min, u32 max, struct netlink_ext_ack *extack)\n{\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\tcase IPPROTO_ESP:\n\t\tbreak;\n\n\tcase IPPROTO_COMP:\n\t\t \n\t\tif (max >= 0x10000) {\n\t\t\tNL_SET_ERR_MSG(extack, \"IPCOMP SPI must be <= 65535\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tNL_SET_ERR_MSG(extack, \"Invalid protocol, must be one of AH, ESP, IPCOMP\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (min > max) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid SPI range: min > max\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(verify_spi_info);\n\nint xfrm_alloc_spi(struct xfrm_state *x, u32 low, u32 high,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net *net = xs_net(x);\n\tunsigned int h;\n\tstruct xfrm_state *x0;\n\tint err = -ENOENT;\n\t__be32 minspi = htonl(low);\n\t__be32 maxspi = htonl(high);\n\t__be32 newspi = 0;\n\tu32 mark = x->mark.v & x->mark.m;\n\n\tspin_lock_bh(&x->lock);\n\tif (x->km.state == XFRM_STATE_DEAD) {\n\t\tNL_SET_ERR_MSG(extack, \"Target ACQUIRE is in DEAD state\");\n\t\tgoto unlock;\n\t}\n\n\terr = 0;\n\tif (x->id.spi)\n\t\tgoto unlock;\n\n\terr = -ENOENT;\n\n\tif (minspi == maxspi) {\n\t\tx0 = xfrm_state_lookup(net, mark, &x->id.daddr, minspi, x->id.proto, x->props.family);\n\t\tif (x0) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Requested SPI is already in use\");\n\t\t\txfrm_state_put(x0);\n\t\t\tgoto unlock;\n\t\t}\n\t\tnewspi = minspi;\n\t} else {\n\t\tu32 spi = 0;\n\t\tfor (h = 0; h < high-low+1; h++) {\n\t\t\tspi = get_random_u32_inclusive(low, high);\n\t\t\tx0 = xfrm_state_lookup(net, mark, &x->id.daddr, htonl(spi), x->id.proto, x->props.family);\n\t\t\tif (x0 == NULL) {\n\t\t\t\tnewspi = htonl(spi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txfrm_state_put(x0);\n\t\t}\n\t}\n\tif (newspi) {\n\t\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\t\tx->id.spi = newspi;\n\t\th = xfrm_spi_hash(net, &x->id.daddr, x->id.spi, x->id.proto, x->props.family);\n\t\tXFRM_STATE_INSERT(byspi, &x->byspi, net->xfrm.state_byspi + h,\n\t\t\t\t  x->xso.type);\n\t\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\n\t\terr = 0;\n\t} else {\n\t\tNL_SET_ERR_MSG(extack, \"No SPI available in the requested range\");\n\t}\n\nunlock:\n\tspin_unlock_bh(&x->lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_alloc_spi);\n\nstatic bool __xfrm_state_filter_match(struct xfrm_state *x,\n\t\t\t\t      struct xfrm_address_filter *filter)\n{\n\tif (filter) {\n\t\tif ((filter->family == AF_INET ||\n\t\t     filter->family == AF_INET6) &&\n\t\t    x->props.family != filter->family)\n\t\t\treturn false;\n\n\t\treturn addr_match(&x->props.saddr, &filter->saddr,\n\t\t\t\t  filter->splen) &&\n\t\t       addr_match(&x->id.daddr, &filter->daddr,\n\t\t\t\t  filter->dplen);\n\t}\n\treturn true;\n}\n\nint xfrm_state_walk(struct net *net, struct xfrm_state_walk *walk,\n\t\t    int (*func)(struct xfrm_state *, int, void*),\n\t\t    void *data)\n{\n\tstruct xfrm_state *state;\n\tstruct xfrm_state_walk *x;\n\tint err = 0;\n\n\tif (walk->seq != 0 && list_empty(&walk->all))\n\t\treturn 0;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\tif (list_empty(&walk->all))\n\t\tx = list_first_entry(&net->xfrm.state_all, struct xfrm_state_walk, all);\n\telse\n\t\tx = list_first_entry(&walk->all, struct xfrm_state_walk, all);\n\tlist_for_each_entry_from(x, &net->xfrm.state_all, all) {\n\t\tif (x->state == XFRM_STATE_DEAD)\n\t\t\tcontinue;\n\t\tstate = container_of(x, struct xfrm_state, km);\n\t\tif (!xfrm_id_proto_match(state->id.proto, walk->proto))\n\t\t\tcontinue;\n\t\tif (!__xfrm_state_filter_match(state, walk->filter))\n\t\t\tcontinue;\n\t\terr = func(state, walk->seq, data);\n\t\tif (err) {\n\t\t\tlist_move_tail(&walk->all, &x->all);\n\t\t\tgoto out;\n\t\t}\n\t\twalk->seq++;\n\t}\n\tif (walk->seq == 0) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\tlist_del_init(&walk->all);\nout:\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_state_walk);\n\nvoid xfrm_state_walk_init(struct xfrm_state_walk *walk, u8 proto,\n\t\t\t  struct xfrm_address_filter *filter)\n{\n\tINIT_LIST_HEAD(&walk->all);\n\twalk->proto = proto;\n\twalk->state = XFRM_STATE_DEAD;\n\twalk->seq = 0;\n\twalk->filter = filter;\n}\nEXPORT_SYMBOL(xfrm_state_walk_init);\n\nvoid xfrm_state_walk_done(struct xfrm_state_walk *walk, struct net *net)\n{\n\tkfree(walk->filter);\n\n\tif (list_empty(&walk->all))\n\t\treturn;\n\n\tspin_lock_bh(&net->xfrm.xfrm_state_lock);\n\tlist_del(&walk->all);\n\tspin_unlock_bh(&net->xfrm.xfrm_state_lock);\n}\nEXPORT_SYMBOL(xfrm_state_walk_done);\n\nstatic void xfrm_replay_timer_handler(struct timer_list *t)\n{\n\tstruct xfrm_state *x = from_timer(x, t, rtimer);\n\n\tspin_lock(&x->lock);\n\n\tif (x->km.state == XFRM_STATE_VALID) {\n\t\tif (xfrm_aevent_is_on(xs_net(x)))\n\t\t\txfrm_replay_notify(x, XFRM_REPLAY_TIMEOUT);\n\t\telse\n\t\t\tx->xflags |= XFRM_TIME_DEFER;\n\t}\n\n\tspin_unlock(&x->lock);\n}\n\nstatic LIST_HEAD(xfrm_km_list);\n\nvoid km_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tstruct xfrm_mgr *km;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(km, &xfrm_km_list, list)\n\t\tif (km->notify_policy)\n\t\t\tkm->notify_policy(xp, dir, c);\n\trcu_read_unlock();\n}\n\nvoid km_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct xfrm_mgr *km;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(km, &xfrm_km_list, list)\n\t\tif (km->notify)\n\t\t\tkm->notify(x, c);\n\trcu_read_unlock();\n}\n\nEXPORT_SYMBOL(km_policy_notify);\nEXPORT_SYMBOL(km_state_notify);\n\nvoid km_state_expired(struct xfrm_state *x, int hard, u32 portid)\n{\n\tstruct km_event c;\n\n\tc.data.hard = hard;\n\tc.portid = portid;\n\tc.event = XFRM_MSG_EXPIRE;\n\tkm_state_notify(x, &c);\n}\n\nEXPORT_SYMBOL(km_state_expired);\n \nint km_query(struct xfrm_state *x, struct xfrm_tmpl *t, struct xfrm_policy *pol)\n{\n\tint err = -EINVAL, acqret;\n\tstruct xfrm_mgr *km;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(km, &xfrm_km_list, list) {\n\t\tacqret = km->acquire(x, t, pol);\n\t\tif (!acqret)\n\t\t\terr = acqret;\n\t}\n\trcu_read_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL(km_query);\n\nstatic int __km_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport)\n{\n\tint err = -EINVAL;\n\tstruct xfrm_mgr *km;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(km, &xfrm_km_list, list) {\n\t\tif (km->new_mapping)\n\t\t\terr = km->new_mapping(x, ipaddr, sport);\n\t\tif (!err)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn err;\n}\n\nint km_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport)\n{\n\tint ret = 0;\n\n\tif (x->mapping_maxage) {\n\t\tif ((jiffies / HZ - x->new_mapping) > x->mapping_maxage ||\n\t\t    x->new_mapping_sport != sport) {\n\t\t\tx->new_mapping_sport = sport;\n\t\t\tx->new_mapping = jiffies / HZ;\n\t\t\tret = __km_new_mapping(x, ipaddr, sport);\n\t\t}\n\t} else {\n\t\tret = __km_new_mapping(x, ipaddr, sport);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(km_new_mapping);\n\nvoid km_policy_expired(struct xfrm_policy *pol, int dir, int hard, u32 portid)\n{\n\tstruct km_event c;\n\n\tc.data.hard = hard;\n\tc.portid = portid;\n\tc.event = XFRM_MSG_POLEXPIRE;\n\tkm_policy_notify(pol, dir, &c);\n}\nEXPORT_SYMBOL(km_policy_expired);\n\n#ifdef CONFIG_XFRM_MIGRATE\nint km_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t       const struct xfrm_migrate *m, int num_migrate,\n\t       const struct xfrm_kmaddress *k,\n\t       const struct xfrm_encap_tmpl *encap)\n{\n\tint err = -EINVAL;\n\tint ret;\n\tstruct xfrm_mgr *km;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(km, &xfrm_km_list, list) {\n\t\tif (km->migrate) {\n\t\t\tret = km->migrate(sel, dir, type, m, num_migrate, k,\n\t\t\t\t\t  encap);\n\t\t\tif (!ret)\n\t\t\t\terr = ret;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL(km_migrate);\n#endif\n\nint km_report(struct net *net, u8 proto, struct xfrm_selector *sel, xfrm_address_t *addr)\n{\n\tint err = -EINVAL;\n\tint ret;\n\tstruct xfrm_mgr *km;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(km, &xfrm_km_list, list) {\n\t\tif (km->report) {\n\t\t\tret = km->report(net, proto, sel, addr);\n\t\t\tif (!ret)\n\t\t\t\terr = ret;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL(km_report);\n\nstatic bool km_is_alive(const struct km_event *c)\n{\n\tstruct xfrm_mgr *km;\n\tbool is_alive = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(km, &xfrm_km_list, list) {\n\t\tif (km->is_alive && km->is_alive(c)) {\n\t\t\tis_alive = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn is_alive;\n}\n\n#if IS_ENABLED(CONFIG_XFRM_USER_COMPAT)\nstatic DEFINE_SPINLOCK(xfrm_translator_lock);\nstatic struct xfrm_translator __rcu *xfrm_translator;\n\nstruct xfrm_translator *xfrm_get_translator(void)\n{\n\tstruct xfrm_translator *xtr;\n\n\trcu_read_lock();\n\txtr = rcu_dereference(xfrm_translator);\n\tif (unlikely(!xtr))\n\t\tgoto out;\n\tif (!try_module_get(xtr->owner))\n\t\txtr = NULL;\nout:\n\trcu_read_unlock();\n\treturn xtr;\n}\nEXPORT_SYMBOL_GPL(xfrm_get_translator);\n\nvoid xfrm_put_translator(struct xfrm_translator *xtr)\n{\n\tmodule_put(xtr->owner);\n}\nEXPORT_SYMBOL_GPL(xfrm_put_translator);\n\nint xfrm_register_translator(struct xfrm_translator *xtr)\n{\n\tint err = 0;\n\n\tspin_lock_bh(&xfrm_translator_lock);\n\tif (unlikely(xfrm_translator != NULL))\n\t\terr = -EEXIST;\n\telse\n\t\trcu_assign_pointer(xfrm_translator, xtr);\n\tspin_unlock_bh(&xfrm_translator_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(xfrm_register_translator);\n\nint xfrm_unregister_translator(struct xfrm_translator *xtr)\n{\n\tint err = 0;\n\n\tspin_lock_bh(&xfrm_translator_lock);\n\tif (likely(xfrm_translator != NULL)) {\n\t\tif (rcu_access_pointer(xfrm_translator) != xtr)\n\t\t\terr = -EINVAL;\n\t\telse\n\t\t\tRCU_INIT_POINTER(xfrm_translator, NULL);\n\t}\n\tspin_unlock_bh(&xfrm_translator_lock);\n\tsynchronize_rcu();\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(xfrm_unregister_translator);\n#endif\n\nint xfrm_user_policy(struct sock *sk, int optname, sockptr_t optval, int optlen)\n{\n\tint err;\n\tu8 *data;\n\tstruct xfrm_mgr *km;\n\tstruct xfrm_policy *pol = NULL;\n\n\tif (sockptr_is_null(optval) && !optlen) {\n\t\txfrm_sk_policy_insert(sk, XFRM_POLICY_IN, NULL);\n\t\txfrm_sk_policy_insert(sk, XFRM_POLICY_OUT, NULL);\n\t\t__sk_dst_reset(sk);\n\t\treturn 0;\n\t}\n\n\tif (optlen <= 0 || optlen > PAGE_SIZE)\n\t\treturn -EMSGSIZE;\n\n\tdata = memdup_sockptr(optval, optlen);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (in_compat_syscall()) {\n\t\tstruct xfrm_translator *xtr = xfrm_get_translator();\n\n\t\tif (!xtr) {\n\t\t\tkfree(data);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\terr = xtr->xlate_user_policy_sockptr(&data, optlen);\n\t\txfrm_put_translator(xtr);\n\t\tif (err) {\n\t\t\tkfree(data);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = -EINVAL;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(km, &xfrm_km_list, list) {\n\t\tpol = km->compile_policy(sk, optname, data,\n\t\t\t\t\t optlen, &err);\n\t\tif (err >= 0)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (err >= 0) {\n\t\txfrm_sk_policy_insert(sk, err, pol);\n\t\txfrm_pol_put(pol);\n\t\t__sk_dst_reset(sk);\n\t\terr = 0;\n\t}\n\n\tkfree(data);\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_user_policy);\n\nstatic DEFINE_SPINLOCK(xfrm_km_lock);\n\nvoid xfrm_register_km(struct xfrm_mgr *km)\n{\n\tspin_lock_bh(&xfrm_km_lock);\n\tlist_add_tail_rcu(&km->list, &xfrm_km_list);\n\tspin_unlock_bh(&xfrm_km_lock);\n}\nEXPORT_SYMBOL(xfrm_register_km);\n\nvoid xfrm_unregister_km(struct xfrm_mgr *km)\n{\n\tspin_lock_bh(&xfrm_km_lock);\n\tlist_del_rcu(&km->list);\n\tspin_unlock_bh(&xfrm_km_lock);\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL(xfrm_unregister_km);\n\nint xfrm_state_register_afinfo(struct xfrm_state_afinfo *afinfo)\n{\n\tint err = 0;\n\n\tif (WARN_ON(afinfo->family >= NPROTO))\n\t\treturn -EAFNOSUPPORT;\n\n\tspin_lock_bh(&xfrm_state_afinfo_lock);\n\tif (unlikely(xfrm_state_afinfo[afinfo->family] != NULL))\n\t\terr = -EEXIST;\n\telse\n\t\trcu_assign_pointer(xfrm_state_afinfo[afinfo->family], afinfo);\n\tspin_unlock_bh(&xfrm_state_afinfo_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_state_register_afinfo);\n\nint xfrm_state_unregister_afinfo(struct xfrm_state_afinfo *afinfo)\n{\n\tint err = 0, family = afinfo->family;\n\n\tif (WARN_ON(family >= NPROTO))\n\t\treturn -EAFNOSUPPORT;\n\n\tspin_lock_bh(&xfrm_state_afinfo_lock);\n\tif (likely(xfrm_state_afinfo[afinfo->family] != NULL)) {\n\t\tif (rcu_access_pointer(xfrm_state_afinfo[family]) != afinfo)\n\t\t\terr = -EINVAL;\n\t\telse\n\t\t\tRCU_INIT_POINTER(xfrm_state_afinfo[afinfo->family], NULL);\n\t}\n\tspin_unlock_bh(&xfrm_state_afinfo_lock);\n\tsynchronize_rcu();\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_state_unregister_afinfo);\n\nstruct xfrm_state_afinfo *xfrm_state_afinfo_get_rcu(unsigned int family)\n{\n\tif (unlikely(family >= NPROTO))\n\t\treturn NULL;\n\n\treturn rcu_dereference(xfrm_state_afinfo[family]);\n}\nEXPORT_SYMBOL_GPL(xfrm_state_afinfo_get_rcu);\n\nstruct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned int family)\n{\n\tstruct xfrm_state_afinfo *afinfo;\n\tif (unlikely(family >= NPROTO))\n\t\treturn NULL;\n\trcu_read_lock();\n\tafinfo = rcu_dereference(xfrm_state_afinfo[family]);\n\tif (unlikely(!afinfo))\n\t\trcu_read_unlock();\n\treturn afinfo;\n}\n\nvoid xfrm_flush_gc(void)\n{\n\tflush_work(&xfrm_state_gc_work);\n}\nEXPORT_SYMBOL(xfrm_flush_gc);\n\n \nvoid xfrm_state_delete_tunnel(struct xfrm_state *x)\n{\n\tif (x->tunnel) {\n\t\tstruct xfrm_state *t = x->tunnel;\n\n\t\tif (atomic_read(&t->tunnel_users) == 2)\n\t\t\txfrm_state_delete(t);\n\t\tatomic_dec(&t->tunnel_users);\n\t\txfrm_state_put_sync(t);\n\t\tx->tunnel = NULL;\n\t}\n}\nEXPORT_SYMBOL(xfrm_state_delete_tunnel);\n\nu32 xfrm_state_mtu(struct xfrm_state *x, int mtu)\n{\n\tconst struct xfrm_type *type = READ_ONCE(x->type);\n\tstruct crypto_aead *aead;\n\tu32 blksize, net_adj = 0;\n\n\tif (x->km.state != XFRM_STATE_VALID ||\n\t    !type || type->proto != IPPROTO_ESP)\n\t\treturn mtu - x->props.header_len;\n\n\taead = x->data;\n\tblksize = ALIGN(crypto_aead_blocksize(aead), 4);\n\n\tswitch (x->props.mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\tcase XFRM_MODE_BEET:\n\t\tif (x->props.family == AF_INET)\n\t\t\tnet_adj = sizeof(struct iphdr);\n\t\telse if (x->props.family == AF_INET6)\n\t\t\tnet_adj = sizeof(struct ipv6hdr);\n\t\tbreak;\n\tcase XFRM_MODE_TUNNEL:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn ((mtu - x->props.header_len - crypto_aead_authsize(aead) -\n\t\t net_adj) & ~(blksize - 1)) + net_adj - 2;\n}\nEXPORT_SYMBOL_GPL(xfrm_state_mtu);\n\nint __xfrm_init_state(struct xfrm_state *x, bool init_replay, bool offload,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tconst struct xfrm_mode *inner_mode;\n\tconst struct xfrm_mode *outer_mode;\n\tint family = x->props.family;\n\tint err;\n\n\tif (family == AF_INET &&\n\t    READ_ONCE(xs_net(x)->ipv4.sysctl_ip_no_pmtu_disc))\n\t\tx->props.flags |= XFRM_STATE_NOPMTUDISC;\n\n\terr = -EPROTONOSUPPORT;\n\n\tif (x->sel.family != AF_UNSPEC) {\n\t\tinner_mode = xfrm_get_mode(x->props.mode, x->sel.family);\n\t\tif (inner_mode == NULL) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Requested mode not found\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!(inner_mode->flags & XFRM_MODE_FLAG_TUNNEL) &&\n\t\t    family != x->sel.family) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Only tunnel modes can accommodate a change of family\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tx->inner_mode = *inner_mode;\n\t} else {\n\t\tconst struct xfrm_mode *inner_mode_iaf;\n\t\tint iafamily = AF_INET;\n\n\t\tinner_mode = xfrm_get_mode(x->props.mode, x->props.family);\n\t\tif (inner_mode == NULL) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Requested mode not found\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tx->inner_mode = *inner_mode;\n\n\t\tif (x->props.family == AF_INET)\n\t\t\tiafamily = AF_INET6;\n\n\t\tinner_mode_iaf = xfrm_get_mode(x->props.mode, iafamily);\n\t\tif (inner_mode_iaf) {\n\t\t\tif (inner_mode_iaf->flags & XFRM_MODE_FLAG_TUNNEL)\n\t\t\t\tx->inner_mode_iaf = *inner_mode_iaf;\n\t\t}\n\t}\n\n\tx->type = xfrm_get_type(x->id.proto, family);\n\tif (x->type == NULL) {\n\t\tNL_SET_ERR_MSG(extack, \"Requested type not found\");\n\t\tgoto error;\n\t}\n\n\tx->type_offload = xfrm_get_type_offload(x->id.proto, family, offload);\n\n\terr = x->type->init_state(x, extack);\n\tif (err)\n\t\tgoto error;\n\n\touter_mode = xfrm_get_mode(x->props.mode, family);\n\tif (!outer_mode) {\n\t\tNL_SET_ERR_MSG(extack, \"Requested mode not found\");\n\t\terr = -EPROTONOSUPPORT;\n\t\tgoto error;\n\t}\n\n\tx->outer_mode = *outer_mode;\n\tif (init_replay) {\n\t\terr = xfrm_init_replay(x, extack);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\nerror:\n\treturn err;\n}\n\nEXPORT_SYMBOL(__xfrm_init_state);\n\nint xfrm_init_state(struct xfrm_state *x)\n{\n\tint err;\n\n\terr = __xfrm_init_state(x, true, false, NULL);\n\tif (!err)\n\t\tx->km.state = XFRM_STATE_VALID;\n\n\treturn err;\n}\n\nEXPORT_SYMBOL(xfrm_init_state);\n\nint __net_init xfrm_state_init(struct net *net)\n{\n\tunsigned int sz;\n\n\tif (net_eq(net, &init_net))\n\t\txfrm_state_cache = KMEM_CACHE(xfrm_state,\n\t\t\t\t\t      SLAB_HWCACHE_ALIGN | SLAB_PANIC);\n\n\tINIT_LIST_HEAD(&net->xfrm.state_all);\n\n\tsz = sizeof(struct hlist_head) * 8;\n\n\tnet->xfrm.state_bydst = xfrm_hash_alloc(sz);\n\tif (!net->xfrm.state_bydst)\n\t\tgoto out_bydst;\n\tnet->xfrm.state_bysrc = xfrm_hash_alloc(sz);\n\tif (!net->xfrm.state_bysrc)\n\t\tgoto out_bysrc;\n\tnet->xfrm.state_byspi = xfrm_hash_alloc(sz);\n\tif (!net->xfrm.state_byspi)\n\t\tgoto out_byspi;\n\tnet->xfrm.state_byseq = xfrm_hash_alloc(sz);\n\tif (!net->xfrm.state_byseq)\n\t\tgoto out_byseq;\n\tnet->xfrm.state_hmask = ((sz / sizeof(struct hlist_head)) - 1);\n\n\tnet->xfrm.state_num = 0;\n\tINIT_WORK(&net->xfrm.state_hash_work, xfrm_hash_resize);\n\tspin_lock_init(&net->xfrm.xfrm_state_lock);\n\tseqcount_spinlock_init(&net->xfrm.xfrm_state_hash_generation,\n\t\t\t       &net->xfrm.xfrm_state_lock);\n\treturn 0;\n\nout_byseq:\n\txfrm_hash_free(net->xfrm.state_byspi, sz);\nout_byspi:\n\txfrm_hash_free(net->xfrm.state_bysrc, sz);\nout_bysrc:\n\txfrm_hash_free(net->xfrm.state_bydst, sz);\nout_bydst:\n\treturn -ENOMEM;\n}\n\nvoid xfrm_state_fini(struct net *net)\n{\n\tunsigned int sz;\n\n\tflush_work(&net->xfrm.state_hash_work);\n\tflush_work(&xfrm_state_gc_work);\n\txfrm_state_flush(net, 0, false, true);\n\n\tWARN_ON(!list_empty(&net->xfrm.state_all));\n\n\tsz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head);\n\tWARN_ON(!hlist_empty(net->xfrm.state_byseq));\n\txfrm_hash_free(net->xfrm.state_byseq, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_byspi));\n\txfrm_hash_free(net->xfrm.state_byspi, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_bysrc));\n\txfrm_hash_free(net->xfrm.state_bysrc, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_bydst));\n\txfrm_hash_free(net->xfrm.state_bydst, sz);\n}\n\n#ifdef CONFIG_AUDITSYSCALL\nstatic void xfrm_audit_helper_sainfo(struct xfrm_state *x,\n\t\t\t\t     struct audit_buffer *audit_buf)\n{\n\tstruct xfrm_sec_ctx *ctx = x->security;\n\tu32 spi = ntohl(x->id.spi);\n\n\tif (ctx)\n\t\taudit_log_format(audit_buf, \" sec_alg=%u sec_doi=%u sec_obj=%s\",\n\t\t\t\t ctx->ctx_alg, ctx->ctx_doi, ctx->ctx_str);\n\n\tswitch (x->props.family) {\n\tcase AF_INET:\n\t\taudit_log_format(audit_buf, \" src=%pI4 dst=%pI4\",\n\t\t\t\t &x->props.saddr.a4, &x->id.daddr.a4);\n\t\tbreak;\n\tcase AF_INET6:\n\t\taudit_log_format(audit_buf, \" src=%pI6 dst=%pI6\",\n\t\t\t\t x->props.saddr.a6, x->id.daddr.a6);\n\t\tbreak;\n\t}\n\n\taudit_log_format(audit_buf, \" spi=%u(0x%x)\", spi, spi);\n}\n\nstatic void xfrm_audit_helper_pktinfo(struct sk_buff *skb, u16 family,\n\t\t\t\t      struct audit_buffer *audit_buf)\n{\n\tconst struct iphdr *iph4;\n\tconst struct ipv6hdr *iph6;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tiph4 = ip_hdr(skb);\n\t\taudit_log_format(audit_buf, \" src=%pI4 dst=%pI4\",\n\t\t\t\t &iph4->saddr, &iph4->daddr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tiph6 = ipv6_hdr(skb);\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \" src=%pI6 dst=%pI6 flowlbl=0x%x%02x%02x\",\n\t\t\t\t &iph6->saddr, &iph6->daddr,\n\t\t\t\t iph6->flow_lbl[0] & 0x0f,\n\t\t\t\t iph6->flow_lbl[1],\n\t\t\t\t iph6->flow_lbl[2]);\n\t\tbreak;\n\t}\n}\n\nvoid xfrm_audit_state_add(struct xfrm_state *x, int result, bool task_valid)\n{\n\tstruct audit_buffer *audit_buf;\n\n\taudit_buf = xfrm_audit_start(\"SAD-add\");\n\tif (audit_buf == NULL)\n\t\treturn;\n\txfrm_audit_helper_usrinfo(task_valid, audit_buf);\n\txfrm_audit_helper_sainfo(x, audit_buf);\n\taudit_log_format(audit_buf, \" res=%u\", result);\n\taudit_log_end(audit_buf);\n}\nEXPORT_SYMBOL_GPL(xfrm_audit_state_add);\n\nvoid xfrm_audit_state_delete(struct xfrm_state *x, int result, bool task_valid)\n{\n\tstruct audit_buffer *audit_buf;\n\n\taudit_buf = xfrm_audit_start(\"SAD-delete\");\n\tif (audit_buf == NULL)\n\t\treturn;\n\txfrm_audit_helper_usrinfo(task_valid, audit_buf);\n\txfrm_audit_helper_sainfo(x, audit_buf);\n\taudit_log_format(audit_buf, \" res=%u\", result);\n\taudit_log_end(audit_buf);\n}\nEXPORT_SYMBOL_GPL(xfrm_audit_state_delete);\n\nvoid xfrm_audit_state_replay_overflow(struct xfrm_state *x,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct audit_buffer *audit_buf;\n\tu32 spi;\n\n\taudit_buf = xfrm_audit_start(\"SA-replay-overflow\");\n\tif (audit_buf == NULL)\n\t\treturn;\n\txfrm_audit_helper_pktinfo(skb, x->props.family, audit_buf);\n\t \n\tspi = ntohl(x->id.spi);\n\taudit_log_format(audit_buf, \" spi=%u(0x%x)\", spi, spi);\n\taudit_log_end(audit_buf);\n}\nEXPORT_SYMBOL_GPL(xfrm_audit_state_replay_overflow);\n\nvoid xfrm_audit_state_replay(struct xfrm_state *x,\n\t\t\t     struct sk_buff *skb, __be32 net_seq)\n{\n\tstruct audit_buffer *audit_buf;\n\tu32 spi;\n\n\taudit_buf = xfrm_audit_start(\"SA-replayed-pkt\");\n\tif (audit_buf == NULL)\n\t\treturn;\n\txfrm_audit_helper_pktinfo(skb, x->props.family, audit_buf);\n\tspi = ntohl(x->id.spi);\n\taudit_log_format(audit_buf, \" spi=%u(0x%x) seqno=%u\",\n\t\t\t spi, spi, ntohl(net_seq));\n\taudit_log_end(audit_buf);\n}\nEXPORT_SYMBOL_GPL(xfrm_audit_state_replay);\n\nvoid xfrm_audit_state_notfound_simple(struct sk_buff *skb, u16 family)\n{\n\tstruct audit_buffer *audit_buf;\n\n\taudit_buf = xfrm_audit_start(\"SA-notfound\");\n\tif (audit_buf == NULL)\n\t\treturn;\n\txfrm_audit_helper_pktinfo(skb, family, audit_buf);\n\taudit_log_end(audit_buf);\n}\nEXPORT_SYMBOL_GPL(xfrm_audit_state_notfound_simple);\n\nvoid xfrm_audit_state_notfound(struct sk_buff *skb, u16 family,\n\t\t\t       __be32 net_spi, __be32 net_seq)\n{\n\tstruct audit_buffer *audit_buf;\n\tu32 spi;\n\n\taudit_buf = xfrm_audit_start(\"SA-notfound\");\n\tif (audit_buf == NULL)\n\t\treturn;\n\txfrm_audit_helper_pktinfo(skb, family, audit_buf);\n\tspi = ntohl(net_spi);\n\taudit_log_format(audit_buf, \" spi=%u(0x%x) seqno=%u\",\n\t\t\t spi, spi, ntohl(net_seq));\n\taudit_log_end(audit_buf);\n}\nEXPORT_SYMBOL_GPL(xfrm_audit_state_notfound);\n\nvoid xfrm_audit_state_icvfail(struct xfrm_state *x,\n\t\t\t      struct sk_buff *skb, u8 proto)\n{\n\tstruct audit_buffer *audit_buf;\n\t__be32 net_spi;\n\t__be32 net_seq;\n\n\taudit_buf = xfrm_audit_start(\"SA-icv-failure\");\n\tif (audit_buf == NULL)\n\t\treturn;\n\txfrm_audit_helper_pktinfo(skb, x->props.family, audit_buf);\n\tif (xfrm_parse_spi(skb, proto, &net_spi, &net_seq) == 0) {\n\t\tu32 spi = ntohl(net_spi);\n\t\taudit_log_format(audit_buf, \" spi=%u(0x%x) seqno=%u\",\n\t\t\t\t spi, spi, ntohl(net_seq));\n\t}\n\taudit_log_end(audit_buf);\n}\nEXPORT_SYMBOL_GPL(xfrm_audit_state_icvfail);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}