{
  "module_name": "xfrm_output.c",
  "hash_id": "72a2c124c2fb268b90ff42b71adb89e65ca4dc8bc9d3f6cf0651729156701532",
  "original_prompt": "Ingested from linux-6.6.14/net/xfrm/xfrm_output.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/netfilter.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <net/dst.h>\n#include <net/gso.h>\n#include <net/icmp.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ip6_route.h>\n#include <net/ipv6_stubs.h>\n#endif\n\n#include \"xfrm_inout.h\"\n\nstatic int xfrm_output2(struct net *net, struct sock *sk, struct sk_buff *skb);\nstatic int xfrm_inner_extract_output(struct xfrm_state *x, struct sk_buff *skb);\n\nstatic int xfrm_skb_check_space(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tint nhead = dst->header_len + LL_RESERVED_SPACE(dst->dev)\n\t\t- skb_headroom(skb);\n\tint ntail = dst->dev->needed_tailroom - skb_tailroom(skb);\n\n\tif (nhead <= 0) {\n\t\tif (ntail <= 0)\n\t\t\treturn 0;\n\t\tnhead = 0;\n\t} else if (ntail < 0)\n\t\tntail = 0;\n\n\treturn pskb_expand_head(skb, nhead, ntail, GFP_ATOMIC);\n}\n\n \n\nstatic struct dst_entry *skb_dst_pop(struct sk_buff *skb)\n{\n\tstruct dst_entry *child = dst_clone(xfrm_dst_child(skb_dst(skb)));\n\n\tskb_dst_drop(skb);\n\treturn child;\n}\n\n \nstatic int xfrm4_transport_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct iphdr *iph = ip_hdr(skb);\n\tint ihl = iph->ihl * 4;\n\n\tskb_set_inner_transport_header(skb, skb_transport_offset(skb));\n\n\tskb_set_network_header(skb, -x->props.header_len);\n\tskb->mac_header = skb->network_header +\n\t\t\t  offsetof(struct iphdr, protocol);\n\tskb->transport_header = skb->network_header + ihl;\n\t__skb_pull(skb, ihl);\n\tmemmove(skb_network_header(skb), iph, ihl);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\nstatic int mip6_rthdr_offset(struct sk_buff *skb, u8 **nexthdr, int type)\n{\n\tconst unsigned char *nh = skb_network_header(skb);\n\tunsigned int offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len;\n\tint found_rhdr = 0;\n\n\tpacket_len = skb_tail_pointer(skb) - nh;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\n\t\tswitch (**nexthdr) {\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tif (type == IPPROTO_ROUTING && offset + 3 <= packet_len) {\n\t\t\t\tstruct ipv6_rt_hdr *rt;\n\n\t\t\t\trt = (struct ipv6_rt_hdr *)(nh + offset);\n\t\t\t\tif (rt->type != 0)\n\t\t\t\t\treturn offset;\n\t\t\t}\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n\t\t\t \n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0) {\n\t\t\t\tnet_dbg_ratelimited(\"mip6: hao exists already, override\\n\");\n\t\t\t\treturn offset;\n\t\t\t}\n\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\toffset += ipv6_optlen(exthdr);\n\t\tif (offset > IPV6_MAXPLEN)\n\t\t\treturn -EINVAL;\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\n\treturn -EINVAL;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int xfrm6_hdr_offset(struct xfrm_state *x, struct sk_buff *skb, u8 **prevhdr)\n{\n\tswitch (x->type->proto) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\tcase IPPROTO_DSTOPTS:\n\tcase IPPROTO_ROUTING:\n\t\treturn mip6_rthdr_offset(skb, prevhdr, x->type->proto);\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ip6_find_1stfragopt(skb, prevhdr);\n}\n#endif\n\n \nstatic int xfrm6_transport_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct ipv6hdr *iph;\n\tu8 *prevhdr;\n\tint hdr_len;\n\n\tiph = ipv6_hdr(skb);\n\tskb_set_inner_transport_header(skb, skb_transport_offset(skb));\n\n\thdr_len = xfrm6_hdr_offset(x, skb, &prevhdr);\n\tif (hdr_len < 0)\n\t\treturn hdr_len;\n\tskb_set_mac_header(skb,\n\t\t\t   (prevhdr - x->props.header_len) - skb->data);\n\tskb_set_network_header(skb, -x->props.header_len);\n\tskb->transport_header = skb->network_header + hdr_len;\n\t__skb_pull(skb, hdr_len);\n\tmemmove(ipv6_hdr(skb), iph, hdr_len);\n\treturn 0;\n#else\n\tWARN_ON_ONCE(1);\n\treturn -EAFNOSUPPORT;\n#endif\n}\n\n \nstatic int xfrm6_ro_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct ipv6hdr *iph;\n\tu8 *prevhdr;\n\tint hdr_len;\n\n\tiph = ipv6_hdr(skb);\n\n\thdr_len = xfrm6_hdr_offset(x, skb, &prevhdr);\n\tif (hdr_len < 0)\n\t\treturn hdr_len;\n\tskb_set_mac_header(skb,\n\t\t\t   (prevhdr - x->props.header_len) - skb->data);\n\tskb_set_network_header(skb, -x->props.header_len);\n\tskb->transport_header = skb->network_header + hdr_len;\n\t__skb_pull(skb, hdr_len);\n\tmemmove(ipv6_hdr(skb), iph, hdr_len);\n\n\treturn 0;\n#else\n\tWARN_ON_ONCE(1);\n\treturn -EAFNOSUPPORT;\n#endif\n}\n\n \nstatic int xfrm4_beet_encap_add(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ip_beet_phdr *ph;\n\tstruct iphdr *top_iph;\n\tint hdrlen, optlen;\n\n\thdrlen = 0;\n\toptlen = XFRM_MODE_SKB_CB(skb)->optlen;\n\tif (unlikely(optlen))\n\t\thdrlen += IPV4_BEET_PHMAXLEN - (optlen & 4);\n\n\tskb_set_network_header(skb, -x->props.header_len - hdrlen +\n\t\t\t       (XFRM_MODE_SKB_CB(skb)->ihl - sizeof(*top_iph)));\n\tif (x->sel.family != AF_INET6)\n\t\tskb->network_header += IPV4_BEET_PHMAXLEN;\n\tskb->mac_header = skb->network_header +\n\t\t\t  offsetof(struct iphdr, protocol);\n\tskb->transport_header = skb->network_header + sizeof(*top_iph);\n\n\txfrm4_beet_make_header(skb);\n\n\tph = __skb_pull(skb, XFRM_MODE_SKB_CB(skb)->ihl - hdrlen);\n\n\ttop_iph = ip_hdr(skb);\n\n\tif (unlikely(optlen)) {\n\t\tif (WARN_ON(optlen < 0))\n\t\t\treturn -EINVAL;\n\n\t\tph->padlen = 4 - (optlen & 4);\n\t\tph->hdrlen = optlen / 8;\n\t\tph->nexthdr = top_iph->protocol;\n\t\tif (ph->padlen)\n\t\t\tmemset(ph + 1, IPOPT_NOP, ph->padlen);\n\n\t\ttop_iph->protocol = IPPROTO_BEETPH;\n\t\ttop_iph->ihl = sizeof(struct iphdr) / 4;\n\t}\n\n\ttop_iph->saddr = x->props.saddr.a4;\n\ttop_iph->daddr = x->id.daddr.a4;\n\n\treturn 0;\n}\n\n \nstatic int xfrm4_tunnel_encap_add(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tbool small_ipv6 = (skb->protocol == htons(ETH_P_IPV6)) && (skb->len <= IPV6_MIN_MTU);\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct iphdr *top_iph;\n\tint flags;\n\n\tskb_set_inner_network_header(skb, skb_network_offset(skb));\n\tskb_set_inner_transport_header(skb, skb_transport_offset(skb));\n\n\tskb_set_network_header(skb, -x->props.header_len);\n\tskb->mac_header = skb->network_header +\n\t\t\t  offsetof(struct iphdr, protocol);\n\tskb->transport_header = skb->network_header + sizeof(*top_iph);\n\ttop_iph = ip_hdr(skb);\n\n\ttop_iph->ihl = 5;\n\ttop_iph->version = 4;\n\n\ttop_iph->protocol = xfrm_af2proto(skb_dst(skb)->ops->family);\n\n\t \n\tif (x->props.extra_flags & XFRM_SA_XFLAG_DONT_ENCAP_DSCP)\n\t\ttop_iph->tos = 0;\n\telse\n\t\ttop_iph->tos = XFRM_MODE_SKB_CB(skb)->tos;\n\ttop_iph->tos = INET_ECN_encapsulate(top_iph->tos,\n\t\t\t\t\t    XFRM_MODE_SKB_CB(skb)->tos);\n\n\tflags = x->props.flags;\n\tif (flags & XFRM_STATE_NOECN)\n\t\tIP_ECN_clear(top_iph);\n\n\ttop_iph->frag_off = (flags & XFRM_STATE_NOPMTUDISC) || small_ipv6 ?\n\t\t0 : (XFRM_MODE_SKB_CB(skb)->frag_off & htons(IP_DF));\n\n\ttop_iph->ttl = ip4_dst_hoplimit(xfrm_dst_child(dst));\n\n\ttop_iph->saddr = x->props.saddr.a4;\n\ttop_iph->daddr = x->id.daddr.a4;\n\tip_select_ident(dev_net(dst->dev), skb, NULL);\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int xfrm6_tunnel_encap_add(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *top_iph;\n\tint dsfield;\n\n\tskb_set_inner_network_header(skb, skb_network_offset(skb));\n\tskb_set_inner_transport_header(skb, skb_transport_offset(skb));\n\n\tskb_set_network_header(skb, -x->props.header_len);\n\tskb->mac_header = skb->network_header +\n\t\t\t  offsetof(struct ipv6hdr, nexthdr);\n\tskb->transport_header = skb->network_header + sizeof(*top_iph);\n\ttop_iph = ipv6_hdr(skb);\n\n\ttop_iph->version = 6;\n\n\tmemcpy(top_iph->flow_lbl, XFRM_MODE_SKB_CB(skb)->flow_lbl,\n\t       sizeof(top_iph->flow_lbl));\n\ttop_iph->nexthdr = xfrm_af2proto(skb_dst(skb)->ops->family);\n\n\tif (x->props.extra_flags & XFRM_SA_XFLAG_DONT_ENCAP_DSCP)\n\t\tdsfield = 0;\n\telse\n\t\tdsfield = XFRM_MODE_SKB_CB(skb)->tos;\n\tdsfield = INET_ECN_encapsulate(dsfield, XFRM_MODE_SKB_CB(skb)->tos);\n\tif (x->props.flags & XFRM_STATE_NOECN)\n\t\tdsfield &= ~INET_ECN_MASK;\n\tipv6_change_dsfield(top_iph, 0, dsfield);\n\ttop_iph->hop_limit = ip6_dst_hoplimit(xfrm_dst_child(dst));\n\ttop_iph->saddr = *(struct in6_addr *)&x->props.saddr;\n\ttop_iph->daddr = *(struct in6_addr *)&x->id.daddr;\n\treturn 0;\n}\n\nstatic int xfrm6_beet_encap_add(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ipv6hdr *top_iph;\n\tstruct ip_beet_phdr *ph;\n\tint optlen, hdr_len;\n\n\thdr_len = 0;\n\toptlen = XFRM_MODE_SKB_CB(skb)->optlen;\n\tif (unlikely(optlen))\n\t\thdr_len += IPV4_BEET_PHMAXLEN - (optlen & 4);\n\n\tskb_set_network_header(skb, -x->props.header_len - hdr_len);\n\tif (x->sel.family != AF_INET6)\n\t\tskb->network_header += IPV4_BEET_PHMAXLEN;\n\tskb->mac_header = skb->network_header +\n\t\t\t  offsetof(struct ipv6hdr, nexthdr);\n\tskb->transport_header = skb->network_header + sizeof(*top_iph);\n\tph = __skb_pull(skb, XFRM_MODE_SKB_CB(skb)->ihl - hdr_len);\n\n\txfrm6_beet_make_header(skb);\n\n\ttop_iph = ipv6_hdr(skb);\n\tif (unlikely(optlen)) {\n\t\tif (WARN_ON(optlen < 0))\n\t\t\treturn -EINVAL;\n\n\t\tph->padlen = 4 - (optlen & 4);\n\t\tph->hdrlen = optlen / 8;\n\t\tph->nexthdr = top_iph->nexthdr;\n\t\tif (ph->padlen)\n\t\t\tmemset(ph + 1, IPOPT_NOP, ph->padlen);\n\n\t\ttop_iph->nexthdr = IPPROTO_BEETPH;\n\t}\n\n\ttop_iph->saddr = *(struct in6_addr *)&x->props.saddr;\n\ttop_iph->daddr = *(struct in6_addr *)&x->id.daddr;\n\treturn 0;\n}\n#endif\n\n \nstatic int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err;\n\n\terr = xfrm_inner_extract_output(x, skb);\n\tif (err)\n\t\treturn err;\n\n\tIPCB(skb)->flags |= IPSKB_XFRM_TUNNEL_SIZE;\n\tskb->protocol = htons(ETH_P_IP);\n\n\tswitch (x->props.mode) {\n\tcase XFRM_MODE_BEET:\n\t\treturn xfrm4_beet_encap_add(x, skb);\n\tcase XFRM_MODE_TUNNEL:\n\t\treturn xfrm4_tunnel_encap_add(x, skb);\n\t}\n\n\tWARN_ON_ONCE(1);\n\treturn -EOPNOTSUPP;\n}\n\nstatic int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tint err;\n\n\terr = xfrm_inner_extract_output(x, skb);\n\tif (err)\n\t\treturn err;\n\n\tskb->ignore_df = 1;\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\tswitch (x->props.mode) {\n\tcase XFRM_MODE_BEET:\n\t\treturn xfrm6_beet_encap_add(x, skb);\n\tcase XFRM_MODE_TUNNEL:\n\t\treturn xfrm6_tunnel_encap_add(x, skb);\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EOPNOTSUPP;\n\t}\n#endif\n\tWARN_ON_ONCE(1);\n\treturn -EAFNOSUPPORT;\n}\n\nstatic int xfrm_outer_mode_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tswitch (x->props.mode) {\n\tcase XFRM_MODE_BEET:\n\tcase XFRM_MODE_TUNNEL:\n\t\tif (x->props.family == AF_INET)\n\t\t\treturn xfrm4_prepare_output(x, skb);\n\t\tif (x->props.family == AF_INET6)\n\t\t\treturn xfrm6_prepare_output(x, skb);\n\t\tbreak;\n\tcase XFRM_MODE_TRANSPORT:\n\t\tif (x->props.family == AF_INET)\n\t\t\treturn xfrm4_transport_output(x, skb);\n\t\tif (x->props.family == AF_INET6)\n\t\t\treturn xfrm6_transport_output(x, skb);\n\t\tbreak;\n\tcase XFRM_MODE_ROUTEOPTIMIZATION:\n\t\tif (x->props.family == AF_INET6)\n\t\t\treturn xfrm6_ro_output(x, skb);\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\n#if IS_ENABLED(CONFIG_NET_PKTGEN)\nint pktgen_xfrm_outer_mode_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\treturn xfrm_outer_mode_output(x, skb);\n}\nEXPORT_SYMBOL_GPL(pktgen_xfrm_outer_mode_output);\n#endif\n\nstatic int xfrm_output_one(struct sk_buff *skb, int err)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct xfrm_state *x = dst->xfrm;\n\tstruct net *net = xs_net(x);\n\n\tif (err <= 0 || x->xso.type == XFRM_DEV_OFFLOAD_PACKET)\n\t\tgoto resume;\n\n\tdo {\n\t\terr = xfrm_skb_check_space(skb);\n\t\tif (err) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTERROR);\n\t\t\tgoto error_nolock;\n\t\t}\n\n\t\tskb->mark = xfrm_smark_get(skb->mark, x);\n\n\t\terr = xfrm_outer_mode_output(x, skb);\n\t\tif (err) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTSTATEMODEERROR);\n\t\t\tgoto error_nolock;\n\t\t}\n\n\t\tspin_lock_bh(&x->lock);\n\n\t\tif (unlikely(x->km.state != XFRM_STATE_VALID)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTSTATEINVALID);\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\terr = xfrm_state_check_expire(x);\n\t\tif (err) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTSTATEEXPIRED);\n\t\t\tgoto error;\n\t\t}\n\n\t\terr = xfrm_replay_overflow(x, skb);\n\t\tif (err) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTSTATESEQERROR);\n\t\t\tgoto error;\n\t\t}\n\n\t\tx->curlft.bytes += skb->len;\n\t\tx->curlft.packets++;\n\t\tx->lastused = ktime_get_real_seconds();\n\n\t\tspin_unlock_bh(&x->lock);\n\n\t\tskb_dst_force(skb);\n\t\tif (!skb_dst(skb)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTERROR);\n\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto error_nolock;\n\t\t}\n\n\t\tif (xfrm_offload(skb)) {\n\t\t\tx->type_offload->encap(x, skb);\n\t\t} else {\n\t\t\t \n\t\t\tskb->encapsulation = 0;\n\n\t\t\terr = x->type->output(x, skb);\n\t\t\tif (err == -EINPROGRESS)\n\t\t\t\tgoto out;\n\t\t}\n\nresume:\n\t\tif (err) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTSTATEPROTOERROR);\n\t\t\tgoto error_nolock;\n\t\t}\n\n\t\tdst = skb_dst_pop(skb);\n\t\tif (!dst) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTERROR);\n\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto error_nolock;\n\t\t}\n\t\tskb_dst_set(skb, dst);\n\t\tx = dst->xfrm;\n\t} while (x && !(x->outer_mode.flags & XFRM_MODE_FLAG_TUNNEL));\n\n\treturn 0;\n\nerror:\n\tspin_unlock_bh(&x->lock);\nerror_nolock:\n\tkfree_skb(skb);\nout:\n\treturn err;\n}\n\nint xfrm_output_resume(struct sock *sk, struct sk_buff *skb, int err)\n{\n\tstruct net *net = xs_net(skb_dst(skb)->xfrm);\n\n\twhile (likely((err = xfrm_output_one(skb, err)) == 0)) {\n\t\tnf_reset_ct(skb);\n\n\t\terr = skb_dst(skb)->ops->local_out(net, sk, skb);\n\t\tif (unlikely(err != 1))\n\t\t\tgoto out;\n\n\t\tif (!skb_dst(skb)->xfrm)\n\t\t\treturn dst_output(net, sk, skb);\n\n\t\terr = nf_hook(skb_dst(skb)->ops->family,\n\t\t\t      NF_INET_POST_ROUTING, net, sk, skb,\n\t\t\t      NULL, skb_dst(skb)->dev, xfrm_output2);\n\t\tif (unlikely(err != 1))\n\t\t\tgoto out;\n\t}\n\n\tif (err == -EINPROGRESS)\n\t\terr = 0;\n\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(xfrm_output_resume);\n\nstatic int xfrm_output2(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\treturn xfrm_output_resume(sk, skb, 1);\n}\n\nstatic int xfrm_output_gso(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sk_buff *segs, *nskb;\n\n\tBUILD_BUG_ON(sizeof(*IPCB(skb)) > SKB_GSO_CB_OFFSET);\n\tBUILD_BUG_ON(sizeof(*IP6CB(skb)) > SKB_GSO_CB_OFFSET);\n\tsegs = skb_gso_segment(skb, 0);\n\tkfree_skb(skb);\n\tif (IS_ERR(segs))\n\t\treturn PTR_ERR(segs);\n\tif (segs == NULL)\n\t\treturn -EINVAL;\n\n\tskb_list_walk_safe(segs, segs, nskb) {\n\t\tint err;\n\n\t\tskb_mark_not_on_list(segs);\n\t\terr = xfrm_output2(net, sk, segs);\n\n\t\tif (unlikely(err)) {\n\t\t\tkfree_skb_list(nskb);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void xfrm_get_inner_ipproto(struct sk_buff *skb, struct xfrm_state *x)\n{\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tconst struct ethhdr *eth;\n\n\tif (!xo)\n\t\treturn;\n\n\tif (x->outer_mode.encap == XFRM_MODE_TUNNEL) {\n\t\tswitch (x->outer_mode.family) {\n\t\tcase AF_INET:\n\t\t\txo->inner_ipproto = ip_hdr(skb)->protocol;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\txo->inner_ipproto = ipv6_hdr(skb)->nexthdr;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\treturn;\n\t}\n\n\t \n\tif (!skb->encapsulation)\n\t\treturn;\n\n\tif (skb->inner_protocol_type == ENCAP_TYPE_IPPROTO) {\n\t\txo->inner_ipproto = skb->inner_ipproto;\n\t\treturn;\n\t}\n\n\tif (skb->inner_protocol_type != ENCAP_TYPE_ETHER)\n\t\treturn;\n\n\teth = (struct ethhdr *)skb_inner_mac_header(skb);\n\n\tswitch (ntohs(eth->h_proto)) {\n\tcase ETH_P_IPV6:\n\t\txo->inner_ipproto = inner_ipv6_hdr(skb)->nexthdr;\n\t\tbreak;\n\tcase ETH_P_IP:\n\t\txo->inner_ipproto = inner_ip_hdr(skb)->protocol;\n\t\tbreak;\n\t}\n}\n\nint xfrm_output(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\tstruct xfrm_state *x = skb_dst(skb)->xfrm;\n\tint err;\n\n\tswitch (x->outer_mode.family) {\n\tcase AF_INET:\n\t\tmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\n\t\tIPCB(skb)->flags |= IPSKB_XFRM_TRANSFORMED;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tmemset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));\n\n\t\tIP6CB(skb)->flags |= IP6SKB_XFRM_TRANSFORMED;\n\t\tbreak;\n\t}\n\n\tif (x->xso.type == XFRM_DEV_OFFLOAD_PACKET) {\n\t\tif (!xfrm_dev_offload_ok(skb, x)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTERROR);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EHOSTUNREACH;\n\t\t}\n\n\t\treturn xfrm_output_resume(sk, skb, 0);\n\t}\n\n\tsecpath_reset(skb);\n\n\tif (xfrm_dev_offload_ok(skb, x)) {\n\t\tstruct sec_path *sp;\n\n\t\tsp = secpath_set(skb);\n\t\tif (!sp) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTERROR);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tsp->olen++;\n\t\tsp->xvec[sp->len++] = x;\n\t\txfrm_state_hold(x);\n\n\t\txfrm_get_inner_ipproto(skb, x);\n\t\tskb->encapsulation = 1;\n\n\t\tif (skb_is_gso(skb)) {\n\t\t\tif (skb->inner_protocol)\n\t\t\t\treturn xfrm_output_gso(net, sk, skb);\n\n\t\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_ESP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (x->xso.dev && x->xso.dev->features & NETIF_F_HW_ESP_TX_CSUM)\n\t\t\tgoto out;\n\t} else {\n\t\tif (skb_is_gso(skb))\n\t\t\treturn xfrm_output_gso(net, sk, skb);\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\terr = skb_checksum_help(skb);\n\t\tif (err) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTERROR);\n\t\t\tkfree_skb(skb);\n\t\t\treturn err;\n\t\t}\n\t}\n\nout:\n\treturn xfrm_output2(net, sk, skb);\n}\nEXPORT_SYMBOL_GPL(xfrm_output);\n\nstatic int xfrm4_tunnel_check_size(struct sk_buff *skb)\n{\n\tint mtu, ret = 0;\n\n\tif (IPCB(skb)->flags & IPSKB_XFRM_TUNNEL_SIZE)\n\t\tgoto out;\n\n\tif (!(ip_hdr(skb)->frag_off & htons(IP_DF)) || skb->ignore_df)\n\t\tgoto out;\n\n\tmtu = dst_mtu(skb_dst(skb));\n\tif ((!skb_is_gso(skb) && skb->len > mtu) ||\n\t    (skb_is_gso(skb) &&\n\t     !skb_gso_validate_network_len(skb, ip_skb_dst_mtu(skb->sk, skb)))) {\n\t\tskb->protocol = htons(ETH_P_IP);\n\n\t\tif (skb->sk)\n\t\t\txfrm_local_error(skb, mtu);\n\t\telse\n\t\t\ticmp_send(skb, ICMP_DEST_UNREACH,\n\t\t\t\t  ICMP_FRAG_NEEDED, htonl(mtu));\n\t\tret = -EMSGSIZE;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err;\n\n\tif (x->outer_mode.encap == XFRM_MODE_BEET &&\n\t    ip_is_fragment(ip_hdr(skb))) {\n\t\tnet_warn_ratelimited(\"BEET mode doesn't support inner IPv4 fragments\\n\");\n\t\treturn -EAFNOSUPPORT;\n\t}\n\n\terr = xfrm4_tunnel_check_size(skb);\n\tif (err)\n\t\treturn err;\n\n\tXFRM_MODE_SKB_CB(skb)->protocol = ip_hdr(skb)->protocol;\n\n\txfrm4_extract_header(skb);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int xfrm6_tunnel_check_size(struct sk_buff *skb)\n{\n\tint mtu, ret = 0;\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (skb->ignore_df)\n\t\tgoto out;\n\n\tmtu = dst_mtu(dst);\n\tif (mtu < IPV6_MIN_MTU)\n\t\tmtu = IPV6_MIN_MTU;\n\n\tif ((!skb_is_gso(skb) && skb->len > mtu) ||\n\t    (skb_is_gso(skb) &&\n\t     !skb_gso_validate_network_len(skb, ip6_skb_dst_mtu(skb)))) {\n\t\tskb->dev = dst->dev;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\t\tif (xfrm6_local_dontfrag(skb->sk))\n\t\t\tipv6_stub->xfrm6_local_rxpmtu(skb, mtu);\n\t\telse if (skb->sk)\n\t\t\txfrm_local_error(skb, mtu);\n\t\telse\n\t\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\tret = -EMSGSIZE;\n\t}\nout:\n\treturn ret;\n}\n#endif\n\nstatic int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tint err;\n\n\terr = xfrm6_tunnel_check_size(skb);\n\tif (err)\n\t\treturn err;\n\n\tXFRM_MODE_SKB_CB(skb)->protocol = ipv6_hdr(skb)->nexthdr;\n\n\txfrm6_extract_header(skb);\n\treturn 0;\n#else\n\tWARN_ON_ONCE(1);\n\treturn -EAFNOSUPPORT;\n#endif\n}\n\nstatic int xfrm_inner_extract_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\treturn xfrm4_extract_output(x, skb);\n\tcase htons(ETH_P_IPV6):\n\t\treturn xfrm6_extract_output(x, skb);\n\t}\n\n\treturn -EAFNOSUPPORT;\n}\n\nvoid xfrm_local_error(struct sk_buff *skb, int mtu)\n{\n\tunsigned int proto;\n\tstruct xfrm_state_afinfo *afinfo;\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\tproto = AF_INET;\n\telse if (skb->protocol == htons(ETH_P_IPV6) &&\n\t\t skb->sk->sk_family == AF_INET6)\n\t\tproto = AF_INET6;\n\telse\n\t\treturn;\n\n\tafinfo = xfrm_state_get_afinfo(proto);\n\tif (afinfo) {\n\t\tafinfo->local_error(skb, mtu);\n\t\trcu_read_unlock();\n\t}\n}\nEXPORT_SYMBOL_GPL(xfrm_local_error);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}