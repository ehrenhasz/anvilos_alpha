{
  "module_name": "xfrm_input.c",
  "hash_id": "7bdea2b01ac53b9182503aece2c395293eb29dd6c08b56c1930bb44cf41b2cd1",
  "original_prompt": "Ingested from linux-6.6.14/net/xfrm/xfrm_input.c",
  "human_readable_source": "\n \n\n#include <linux/bottom_half.h>\n#include <linux/cache.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/percpu.h>\n#include <net/dst.h>\n#include <net/ip.h>\n#include <net/xfrm.h>\n#include <net/ip_tunnels.h>\n#include <net/ip6_tunnel.h>\n#include <net/dst_metadata.h>\n\n#include \"xfrm_inout.h\"\n\nstruct xfrm_trans_tasklet {\n\tstruct work_struct work;\n\tspinlock_t queue_lock;\n\tstruct sk_buff_head queue;\n};\n\nstruct xfrm_trans_cb {\n\tunion {\n\t\tstruct inet_skb_parm\th4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct inet6_skb_parm\th6;\n#endif\n\t} header;\n\tint (*finish)(struct net *net, struct sock *sk, struct sk_buff *skb);\n\tstruct net *net;\n};\n\n#define XFRM_TRANS_SKB_CB(__skb) ((struct xfrm_trans_cb *)&((__skb)->cb[0]))\n\nstatic DEFINE_SPINLOCK(xfrm_input_afinfo_lock);\nstatic struct xfrm_input_afinfo const __rcu *xfrm_input_afinfo[2][AF_INET6 + 1];\n\nstatic struct gro_cells gro_cells;\nstatic struct net_device xfrm_napi_dev;\n\nstatic DEFINE_PER_CPU(struct xfrm_trans_tasklet, xfrm_trans_tasklet);\n\nint xfrm_input_register_afinfo(const struct xfrm_input_afinfo *afinfo)\n{\n\tint err = 0;\n\n\tif (WARN_ON(afinfo->family > AF_INET6))\n\t\treturn -EAFNOSUPPORT;\n\n\tspin_lock_bh(&xfrm_input_afinfo_lock);\n\tif (unlikely(xfrm_input_afinfo[afinfo->is_ipip][afinfo->family]))\n\t\terr = -EEXIST;\n\telse\n\t\trcu_assign_pointer(xfrm_input_afinfo[afinfo->is_ipip][afinfo->family], afinfo);\n\tspin_unlock_bh(&xfrm_input_afinfo_lock);\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_input_register_afinfo);\n\nint xfrm_input_unregister_afinfo(const struct xfrm_input_afinfo *afinfo)\n{\n\tint err = 0;\n\n\tspin_lock_bh(&xfrm_input_afinfo_lock);\n\tif (likely(xfrm_input_afinfo[afinfo->is_ipip][afinfo->family])) {\n\t\tif (unlikely(xfrm_input_afinfo[afinfo->is_ipip][afinfo->family] != afinfo))\n\t\t\terr = -EINVAL;\n\t\telse\n\t\t\tRCU_INIT_POINTER(xfrm_input_afinfo[afinfo->is_ipip][afinfo->family], NULL);\n\t}\n\tspin_unlock_bh(&xfrm_input_afinfo_lock);\n\tsynchronize_rcu();\n\treturn err;\n}\nEXPORT_SYMBOL(xfrm_input_unregister_afinfo);\n\nstatic const struct xfrm_input_afinfo *xfrm_input_get_afinfo(u8 family, bool is_ipip)\n{\n\tconst struct xfrm_input_afinfo *afinfo;\n\n\tif (WARN_ON_ONCE(family > AF_INET6))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tafinfo = rcu_dereference(xfrm_input_afinfo[is_ipip][family]);\n\tif (unlikely(!afinfo))\n\t\trcu_read_unlock();\n\treturn afinfo;\n}\n\nstatic int xfrm_rcv_cb(struct sk_buff *skb, unsigned int family, u8 protocol,\n\t\t       int err)\n{\n\tbool is_ipip = (protocol == IPPROTO_IPIP || protocol == IPPROTO_IPV6);\n\tconst struct xfrm_input_afinfo *afinfo;\n\tint ret;\n\n\tafinfo = xfrm_input_get_afinfo(family, is_ipip);\n\tif (!afinfo)\n\t\treturn -EAFNOSUPPORT;\n\n\tret = afinfo->callback(skb, protocol, err);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstruct sec_path *secpath_set(struct sk_buff *skb)\n{\n\tstruct sec_path *sp, *tmp = skb_ext_find(skb, SKB_EXT_SEC_PATH);\n\n\tsp = skb_ext_add(skb, SKB_EXT_SEC_PATH);\n\tif (!sp)\n\t\treturn NULL;\n\n\tif (tmp)  \n\t\treturn sp;\n\n\t \n\tmemset(sp->ovec, 0, sizeof(sp->ovec));\n\tsp->olen = 0;\n\tsp->len = 0;\n\tsp->verified_cnt = 0;\n\n\treturn sp;\n}\nEXPORT_SYMBOL(secpath_set);\n\n \n\nint xfrm_parse_spi(struct sk_buff *skb, u8 nexthdr, __be32 *spi, __be32 *seq)\n{\n\tint offset, offset_seq;\n\tint hlen;\n\n\tswitch (nexthdr) {\n\tcase IPPROTO_AH:\n\t\thlen = sizeof(struct ip_auth_hdr);\n\t\toffset = offsetof(struct ip_auth_hdr, spi);\n\t\toffset_seq = offsetof(struct ip_auth_hdr, seq_no);\n\t\tbreak;\n\tcase IPPROTO_ESP:\n\t\thlen = sizeof(struct ip_esp_hdr);\n\t\toffset = offsetof(struct ip_esp_hdr, spi);\n\t\toffset_seq = offsetof(struct ip_esp_hdr, seq_no);\n\t\tbreak;\n\tcase IPPROTO_COMP:\n\t\tif (!pskb_may_pull(skb, sizeof(struct ip_comp_hdr)))\n\t\t\treturn -EINVAL;\n\t\t*spi = htonl(ntohs(*(__be16 *)(skb_transport_header(skb) + 2)));\n\t\t*seq = 0;\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\tif (!pskb_may_pull(skb, hlen))\n\t\treturn -EINVAL;\n\n\t*spi = *(__be32 *)(skb_transport_header(skb) + offset);\n\t*seq = *(__be32 *)(skb_transport_header(skb) + offset_seq);\n\treturn 0;\n}\nEXPORT_SYMBOL(xfrm_parse_spi);\n\nstatic int xfrm4_remove_beet_encap(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct iphdr *iph;\n\tint optlen = 0;\n\tint err = -EINVAL;\n\n\tskb->protocol = htons(ETH_P_IP);\n\n\tif (unlikely(XFRM_MODE_SKB_CB(skb)->protocol == IPPROTO_BEETPH)) {\n\t\tstruct ip_beet_phdr *ph;\n\t\tint phlen;\n\n\t\tif (!pskb_may_pull(skb, sizeof(*ph)))\n\t\t\tgoto out;\n\n\t\tph = (struct ip_beet_phdr *)skb->data;\n\n\t\tphlen = sizeof(*ph) + ph->padlen;\n\t\toptlen = ph->hdrlen * 8 + (IPV4_BEET_PHMAXLEN - phlen);\n\t\tif (optlen < 0 || optlen & 3 || optlen > 250)\n\t\t\tgoto out;\n\n\t\tXFRM_MODE_SKB_CB(skb)->protocol = ph->nexthdr;\n\n\t\tif (!pskb_may_pull(skb, phlen))\n\t\t\tgoto out;\n\t\t__skb_pull(skb, phlen);\n\t}\n\n\tskb_push(skb, sizeof(*iph));\n\tskb_reset_network_header(skb);\n\tskb_mac_header_rebuild(skb);\n\n\txfrm4_beet_make_header(skb);\n\n\tiph = ip_hdr(skb);\n\n\tiph->ihl += optlen / 4;\n\tiph->tot_len = htons(skb->len);\n\tiph->daddr = x->sel.daddr.a4;\n\tiph->saddr = x->sel.saddr.a4;\n\tiph->check = 0;\n\tiph->check = ip_fast_csum(skb_network_header(skb), iph->ihl);\n\terr = 0;\nout:\n\treturn err;\n}\n\nstatic void ipip_ecn_decapsulate(struct sk_buff *skb)\n{\n\tstruct iphdr *inner_iph = ipip_hdr(skb);\n\n\tif (INET_ECN_is_ce(XFRM_MODE_SKB_CB(skb)->tos))\n\t\tIP_ECN_set_ce(inner_iph);\n}\n\nstatic int xfrm4_remove_tunnel_encap(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err = -EINVAL;\n\n\tskb->protocol = htons(ETH_P_IP);\n\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\tgoto out;\n\n\terr = skb_unclone(skb, GFP_ATOMIC);\n\tif (err)\n\t\tgoto out;\n\n\tif (x->props.flags & XFRM_STATE_DECAP_DSCP)\n\t\tipv4_copy_dscp(XFRM_MODE_SKB_CB(skb)->tos, ipip_hdr(skb));\n\tif (!(x->props.flags & XFRM_STATE_NOECN))\n\t\tipip_ecn_decapsulate(skb);\n\n\tskb_reset_network_header(skb);\n\tskb_mac_header_rebuild(skb);\n\tif (skb->mac_len)\n\t\teth_hdr(skb)->h_proto = skb->protocol;\n\n\terr = 0;\n\nout:\n\treturn err;\n}\n\nstatic void ipip6_ecn_decapsulate(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *inner_iph = ipipv6_hdr(skb);\n\n\tif (INET_ECN_is_ce(XFRM_MODE_SKB_CB(skb)->tos))\n\t\tIP6_ECN_set_ce(skb, inner_iph);\n}\n\nstatic int xfrm6_remove_tunnel_encap(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err = -EINVAL;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto out;\n\n\terr = skb_unclone(skb, GFP_ATOMIC);\n\tif (err)\n\t\tgoto out;\n\n\tif (x->props.flags & XFRM_STATE_DECAP_DSCP)\n\t\tipv6_copy_dscp(XFRM_MODE_SKB_CB(skb)->tos, ipipv6_hdr(skb));\n\tif (!(x->props.flags & XFRM_STATE_NOECN))\n\t\tipip6_ecn_decapsulate(skb);\n\n\tskb_reset_network_header(skb);\n\tskb_mac_header_rebuild(skb);\n\tif (skb->mac_len)\n\t\teth_hdr(skb)->h_proto = skb->protocol;\n\n\terr = 0;\n\nout:\n\treturn err;\n}\n\nstatic int xfrm6_remove_beet_encap(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ipv6hdr *ip6h;\n\tint size = sizeof(struct ipv6hdr);\n\tint err;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\terr = skb_cow_head(skb, size + skb->mac_len);\n\tif (err)\n\t\tgoto out;\n\n\t__skb_push(skb, size);\n\tskb_reset_network_header(skb);\n\tskb_mac_header_rebuild(skb);\n\n\txfrm6_beet_make_header(skb);\n\n\tip6h = ipv6_hdr(skb);\n\tip6h->payload_len = htons(skb->len - size);\n\tip6h->daddr = x->sel.daddr.in6;\n\tip6h->saddr = x->sel.saddr.in6;\n\terr = 0;\nout:\n\treturn err;\n}\n\n \nstatic int\nxfrm_inner_mode_encap_remove(struct xfrm_state *x,\n\t\t\t     struct sk_buff *skb)\n{\n\tswitch (x->props.mode) {\n\tcase XFRM_MODE_BEET:\n\t\tswitch (x->sel.family) {\n\t\tcase AF_INET:\n\t\t\treturn xfrm4_remove_beet_encap(x, skb);\n\t\tcase AF_INET6:\n\t\t\treturn xfrm6_remove_beet_encap(x, skb);\n\t\t}\n\t\tbreak;\n\tcase XFRM_MODE_TUNNEL:\n\t\tswitch (XFRM_MODE_SKB_CB(skb)->protocol) {\n\t\tcase IPPROTO_IPIP:\n\t\t\treturn xfrm4_remove_tunnel_encap(x, skb);\n\t\tcase IPPROTO_IPV6:\n\t\t\treturn xfrm6_remove_tunnel_encap(x, skb);\n\t\tbreak;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON_ONCE(1);\n\treturn -EOPNOTSUPP;\n}\n\nstatic int xfrm_prepare_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tswitch (x->props.family) {\n\tcase AF_INET:\n\t\txfrm4_extract_header(skb);\n\t\tbreak;\n\tcase AF_INET6:\n\t\txfrm6_extract_header(skb);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EAFNOSUPPORT;\n\t}\n\n\treturn xfrm_inner_mode_encap_remove(x, skb);\n}\n\n \nstatic int xfrm4_transport_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint ihl = skb->data - skb_transport_header(skb);\n\n\tif (skb->transport_header != skb->network_header) {\n\t\tmemmove(skb_transport_header(skb),\n\t\t\tskb_network_header(skb), ihl);\n\t\tskb->network_header = skb->transport_header;\n\t}\n\tip_hdr(skb)->tot_len = htons(skb->len + ihl);\n\tskb_reset_transport_header(skb);\n\treturn 0;\n}\n\nstatic int xfrm6_transport_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tint ihl = skb->data - skb_transport_header(skb);\n\n\tif (skb->transport_header != skb->network_header) {\n\t\tmemmove(skb_transport_header(skb),\n\t\t\tskb_network_header(skb), ihl);\n\t\tskb->network_header = skb->transport_header;\n\t}\n\tipv6_hdr(skb)->payload_len = htons(skb->len + ihl -\n\t\t\t\t\t   sizeof(struct ipv6hdr));\n\tskb_reset_transport_header(skb);\n\treturn 0;\n#else\n\tWARN_ON_ONCE(1);\n\treturn -EAFNOSUPPORT;\n#endif\n}\n\nstatic int xfrm_inner_mode_input(struct xfrm_state *x,\n\t\t\t\t struct sk_buff *skb)\n{\n\tswitch (x->props.mode) {\n\tcase XFRM_MODE_BEET:\n\tcase XFRM_MODE_TUNNEL:\n\t\treturn xfrm_prepare_input(x, skb);\n\tcase XFRM_MODE_TRANSPORT:\n\t\tif (x->props.family == AF_INET)\n\t\t\treturn xfrm4_transport_input(x, skb);\n\t\tif (x->props.family == AF_INET6)\n\t\t\treturn xfrm6_transport_input(x, skb);\n\t\tbreak;\n\tcase XFRM_MODE_ROUTEOPTIMIZATION:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nint xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type)\n{\n\tconst struct xfrm_state_afinfo *afinfo;\n\tstruct net *net = dev_net(skb->dev);\n\tint err;\n\t__be32 seq;\n\t__be32 seq_hi;\n\tstruct xfrm_state *x = NULL;\n\txfrm_address_t *daddr;\n\tu32 mark = skb->mark;\n\tunsigned int family = AF_UNSPEC;\n\tint decaps = 0;\n\tint async = 0;\n\tbool xfrm_gro = false;\n\tbool crypto_done = false;\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tstruct sec_path *sp;\n\n\tif (encap_type < 0) {\n\t\tx = xfrm_input_state(skb);\n\n\t\tif (unlikely(x->km.state != XFRM_STATE_VALID)) {\n\t\t\tif (x->km.state == XFRM_STATE_ACQ)\n\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMACQUIREERROR);\n\t\t\telse\n\t\t\t\tXFRM_INC_STATS(net,\n\t\t\t\t\t       LINUX_MIB_XFRMINSTATEINVALID);\n\n\t\t\tif (encap_type == -1)\n\t\t\t\tdev_put(skb->dev);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tfamily = x->props.family;\n\n\t\t \n\t\tif (encap_type == -1) {\n\t\t\tasync = 1;\n\t\t\tseq = XFRM_SKB_CB(skb)->seq.input.low;\n\t\t\tgoto resume;\n\t\t}\n\n\t\t \n\t\tencap_type = 0;\n\t\tseq = XFRM_SPI_SKB_CB(skb)->seq;\n\n\t\tif (xo && (xo->flags & CRYPTO_DONE)) {\n\t\t\tcrypto_done = true;\n\t\t\tfamily = XFRM_SPI_SKB_CB(skb)->family;\n\n\t\t\tif (!(xo->status & CRYPTO_SUCCESS)) {\n\t\t\t\tif (xo->status &\n\t\t\t\t    (CRYPTO_TRANSPORT_AH_AUTH_FAILED |\n\t\t\t\t     CRYPTO_TRANSPORT_ESP_AUTH_FAILED |\n\t\t\t\t     CRYPTO_TUNNEL_AH_AUTH_FAILED |\n\t\t\t\t     CRYPTO_TUNNEL_ESP_AUTH_FAILED)) {\n\n\t\t\t\t\txfrm_audit_state_icvfail(x, skb,\n\t\t\t\t\t\t\t\t x->type->proto);\n\t\t\t\t\tx->stats.integrity_failed++;\n\t\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEPROTOERROR);\n\t\t\t\t\tgoto drop;\n\t\t\t\t}\n\n\t\t\t\tif (xo->status & CRYPTO_INVALID_PROTOCOL) {\n\t\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEPROTOERROR);\n\t\t\t\t\tgoto drop;\n\t\t\t\t}\n\n\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINBUFFERERROR);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tif (xfrm_parse_spi(skb, nexthdr, &spi, &seq)) {\n\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\n\t\tgoto lock;\n\t}\n\n\tfamily = XFRM_SPI_SKB_CB(skb)->family;\n\n\t \n\tswitch (family) {\n\tcase AF_INET:\n\t\tif (XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4)\n\t\t\tmark = be32_to_cpu(XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4->parms.i_key);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6)\n\t\t\tmark = be32_to_cpu(XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6->parms.i_key);\n\t\tbreak;\n\t}\n\n\tsp = secpath_set(skb);\n\tif (!sp) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINERROR);\n\t\tgoto drop;\n\t}\n\n\tseq = 0;\n\tif (!spi && xfrm_parse_spi(skb, nexthdr, &spi, &seq)) {\n\t\tsecpath_reset(skb);\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR);\n\t\tgoto drop;\n\t}\n\n\tdaddr = (xfrm_address_t *)(skb_network_header(skb) +\n\t\t\t\t   XFRM_SPI_SKB_CB(skb)->daddroff);\n\tdo {\n\t\tsp = skb_sec_path(skb);\n\n\t\tif (sp->len == XFRM_MAX_DEPTH) {\n\t\t\tsecpath_reset(skb);\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINBUFFERERROR);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tx = xfrm_state_lookup(net, mark, daddr, spi, nexthdr, family);\n\t\tif (x == NULL) {\n\t\t\tsecpath_reset(skb);\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINNOSTATES);\n\t\t\txfrm_audit_state_notfound(skb, family, spi, seq);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tskb->mark = xfrm_smark_get(skb->mark, x);\n\n\t\tsp->xvec[sp->len++] = x;\n\n\t\tskb_dst_force(skb);\n\t\tif (!skb_dst(skb)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINERROR);\n\t\t\tgoto drop;\n\t\t}\n\nlock:\n\t\tspin_lock(&x->lock);\n\n\t\tif (unlikely(x->km.state != XFRM_STATE_VALID)) {\n\t\t\tif (x->km.state == XFRM_STATE_ACQ)\n\t\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMACQUIREERROR);\n\t\t\telse\n\t\t\t\tXFRM_INC_STATS(net,\n\t\t\t\t\t       LINUX_MIB_XFRMINSTATEINVALID);\n\t\t\tgoto drop_unlock;\n\t\t}\n\n\t\tif ((x->encap ? x->encap->encap_type : 0) != encap_type) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMISMATCH);\n\t\t\tgoto drop_unlock;\n\t\t}\n\n\t\tif (xfrm_replay_check(x, skb, seq)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATESEQERROR);\n\t\t\tgoto drop_unlock;\n\t\t}\n\n\t\tif (xfrm_state_check_expire(x)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEEXPIRED);\n\t\t\tgoto drop_unlock;\n\t\t}\n\n\t\tspin_unlock(&x->lock);\n\n\t\tif (xfrm_tunnel_check(skb, x, family)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMODEERROR);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tseq_hi = htonl(xfrm_replay_seqhi(x, seq));\n\n\t\tXFRM_SKB_CB(skb)->seq.input.low = seq;\n\t\tXFRM_SKB_CB(skb)->seq.input.hi = seq_hi;\n\n\t\tdev_hold(skb->dev);\n\n\t\tif (crypto_done)\n\t\t\tnexthdr = x->type_offload->input_tail(x, skb);\n\t\telse\n\t\t\tnexthdr = x->type->input(x, skb);\n\n\t\tif (nexthdr == -EINPROGRESS)\n\t\t\treturn 0;\nresume:\n\t\tdev_put(skb->dev);\n\n\t\tspin_lock(&x->lock);\n\t\tif (nexthdr < 0) {\n\t\t\tif (nexthdr == -EBADMSG) {\n\t\t\t\txfrm_audit_state_icvfail(x, skb,\n\t\t\t\t\t\t\t x->type->proto);\n\t\t\t\tx->stats.integrity_failed++;\n\t\t\t}\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEPROTOERROR);\n\t\t\tgoto drop_unlock;\n\t\t}\n\n\t\t \n\t\tencap_type = 0;\n\n\t\tif (xfrm_replay_recheck(x, skb, seq)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATESEQERROR);\n\t\t\tgoto drop_unlock;\n\t\t}\n\n\t\txfrm_replay_advance(x, seq);\n\n\t\tx->curlft.bytes += skb->len;\n\t\tx->curlft.packets++;\n\t\tx->lastused = ktime_get_real_seconds();\n\n\t\tspin_unlock(&x->lock);\n\n\t\tXFRM_MODE_SKB_CB(skb)->protocol = nexthdr;\n\n\t\tif (xfrm_inner_mode_input(x, skb)) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMODEERROR);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (x->outer_mode.flags & XFRM_MODE_FLAG_TUNNEL) {\n\t\t\tdecaps = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tdaddr = &x->id.daddr;\n\t\tfamily = x->props.family;\n\n\t\terr = xfrm_parse_spi(skb, nexthdr, &spi, &seq);\n\t\tif (err < 0) {\n\t\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINHDRERROR);\n\t\t\tgoto drop;\n\t\t}\n\t\tcrypto_done = false;\n\t} while (!err);\n\n\terr = xfrm_rcv_cb(skb, family, x->type->proto, 0);\n\tif (err)\n\t\tgoto drop;\n\n\tnf_reset_ct(skb);\n\n\tif (decaps) {\n\t\tsp = skb_sec_path(skb);\n\t\tif (sp)\n\t\t\tsp->olen = 0;\n\t\tif (skb_valid_dst(skb))\n\t\t\tskb_dst_drop(skb);\n\t\tgro_cells_receive(&gro_cells, skb);\n\t\treturn 0;\n\t} else {\n\t\txo = xfrm_offload(skb);\n\t\tif (xo)\n\t\t\txfrm_gro = xo->flags & XFRM_GRO;\n\n\t\terr = -EAFNOSUPPORT;\n\t\trcu_read_lock();\n\t\tafinfo = xfrm_state_afinfo_get_rcu(x->props.family);\n\t\tif (likely(afinfo))\n\t\t\terr = afinfo->transport_finish(skb, xfrm_gro || async);\n\t\trcu_read_unlock();\n\t\tif (xfrm_gro) {\n\t\t\tsp = skb_sec_path(skb);\n\t\t\tif (sp)\n\t\t\t\tsp->olen = 0;\n\t\t\tif (skb_valid_dst(skb))\n\t\t\t\tskb_dst_drop(skb);\n\t\t\tgro_cells_receive(&gro_cells, skb);\n\t\t\treturn err;\n\t\t}\n\n\t\treturn err;\n\t}\n\ndrop_unlock:\n\tspin_unlock(&x->lock);\ndrop:\n\txfrm_rcv_cb(skb, family, x && x->type ? x->type->proto : nexthdr, -1);\n\tkfree_skb(skb);\n\treturn 0;\n}\nEXPORT_SYMBOL(xfrm_input);\n\nint xfrm_input_resume(struct sk_buff *skb, int nexthdr)\n{\n\treturn xfrm_input(skb, nexthdr, 0, -1);\n}\nEXPORT_SYMBOL(xfrm_input_resume);\n\nstatic void xfrm_trans_reinject(struct work_struct *work)\n{\n\tstruct xfrm_trans_tasklet *trans = container_of(work, struct xfrm_trans_tasklet, work);\n\tstruct sk_buff_head queue;\n\tstruct sk_buff *skb;\n\n\t__skb_queue_head_init(&queue);\n\tspin_lock_bh(&trans->queue_lock);\n\tskb_queue_splice_init(&trans->queue, &queue);\n\tspin_unlock_bh(&trans->queue_lock);\n\n\tlocal_bh_disable();\n\twhile ((skb = __skb_dequeue(&queue)))\n\t\tXFRM_TRANS_SKB_CB(skb)->finish(XFRM_TRANS_SKB_CB(skb)->net,\n\t\t\t\t\t       NULL, skb);\n\tlocal_bh_enable();\n}\n\nint xfrm_trans_queue_net(struct net *net, struct sk_buff *skb,\n\t\t\t int (*finish)(struct net *, struct sock *,\n\t\t\t\t       struct sk_buff *))\n{\n\tstruct xfrm_trans_tasklet *trans;\n\n\ttrans = this_cpu_ptr(&xfrm_trans_tasklet);\n\n\tif (skb_queue_len(&trans->queue) >= READ_ONCE(netdev_max_backlog))\n\t\treturn -ENOBUFS;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_trans_cb) > sizeof(skb->cb));\n\n\tXFRM_TRANS_SKB_CB(skb)->finish = finish;\n\tXFRM_TRANS_SKB_CB(skb)->net = net;\n\tspin_lock_bh(&trans->queue_lock);\n\t__skb_queue_tail(&trans->queue, skb);\n\tspin_unlock_bh(&trans->queue_lock);\n\tschedule_work(&trans->work);\n\treturn 0;\n}\nEXPORT_SYMBOL(xfrm_trans_queue_net);\n\nint xfrm_trans_queue(struct sk_buff *skb,\n\t\t     int (*finish)(struct net *, struct sock *,\n\t\t\t\t   struct sk_buff *))\n{\n\treturn xfrm_trans_queue_net(dev_net(skb->dev), skb, finish);\n}\nEXPORT_SYMBOL(xfrm_trans_queue);\n\nvoid __init xfrm_input_init(void)\n{\n\tint err;\n\tint i;\n\n\tinit_dummy_netdev(&xfrm_napi_dev);\n\terr = gro_cells_init(&gro_cells, &xfrm_napi_dev);\n\tif (err)\n\t\tgro_cells.cells = NULL;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct xfrm_trans_tasklet *trans;\n\n\t\ttrans = &per_cpu(xfrm_trans_tasklet, i);\n\t\tspin_lock_init(&trans->queue_lock);\n\t\t__skb_queue_head_init(&trans->queue);\n\t\tINIT_WORK(&trans->work, xfrm_trans_reinject);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}