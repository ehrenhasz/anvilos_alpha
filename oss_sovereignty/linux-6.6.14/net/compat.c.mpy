{
  "module_name": "compat.c",
  "hash_id": "bcf2cc9bfee1717d1b9bb73239e2e2ee54f02c1b6684f8b6088dc94d296f42fb",
  "original_prompt": "Ingested from linux-6.6.14/net/compat.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/file.h>\n#include <linux/icmpv6.h>\n#include <linux/socket.h>\n#include <linux/syscalls.h>\n#include <linux/filter.h>\n#include <linux/compat.h>\n#include <linux/security.h>\n#include <linux/audit.h>\n#include <linux/export.h>\n\n#include <net/scm.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <linux/uaccess.h>\n#include <net/compat.h>\n\nint __get_compat_msghdr(struct msghdr *kmsg,\n\t\t\tstruct compat_msghdr *msg,\n\t\t\tstruct sockaddr __user **save_addr)\n{\n\tssize_t err;\n\n\tkmsg->msg_flags = msg->msg_flags;\n\tkmsg->msg_namelen = msg->msg_namelen;\n\n\tif (!msg->msg_name)\n\t\tkmsg->msg_namelen = 0;\n\n\tif (kmsg->msg_namelen < 0)\n\t\treturn -EINVAL;\n\n\tif (kmsg->msg_namelen > sizeof(struct sockaddr_storage))\n\t\tkmsg->msg_namelen = sizeof(struct sockaddr_storage);\n\n\tkmsg->msg_control_is_user = true;\n\tkmsg->msg_get_inq = 0;\n\tkmsg->msg_control_user = compat_ptr(msg->msg_control);\n\tkmsg->msg_controllen = msg->msg_controllen;\n\n\tif (save_addr)\n\t\t*save_addr = compat_ptr(msg->msg_name);\n\n\tif (msg->msg_name && kmsg->msg_namelen) {\n\t\tif (!save_addr) {\n\t\t\terr = move_addr_to_kernel(compat_ptr(msg->msg_name),\n\t\t\t\t\t\t  kmsg->msg_namelen,\n\t\t\t\t\t\t  kmsg->msg_name);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tkmsg->msg_name = NULL;\n\t\tkmsg->msg_namelen = 0;\n\t}\n\n\tif (msg->msg_iovlen > UIO_MAXIOV)\n\t\treturn -EMSGSIZE;\n\n\tkmsg->msg_iocb = NULL;\n\tkmsg->msg_ubuf = NULL;\n\treturn 0;\n}\n\nint get_compat_msghdr(struct msghdr *kmsg,\n\t\t      struct compat_msghdr __user *umsg,\n\t\t      struct sockaddr __user **save_addr,\n\t\t      struct iovec **iov)\n{\n\tstruct compat_msghdr msg;\n\tssize_t err;\n\n\tif (copy_from_user(&msg, umsg, sizeof(*umsg)))\n\t\treturn -EFAULT;\n\n\terr = __get_compat_msghdr(kmsg, &msg, save_addr);\n\tif (err)\n\t\treturn err;\n\n\terr = import_iovec(save_addr ? ITER_DEST : ITER_SOURCE,\n\t\t\t   compat_ptr(msg.msg_iov), msg.msg_iovlen,\n\t\t\t   UIO_FASTIOV, iov, &kmsg->msg_iter);\n\treturn err < 0 ? err : 0;\n}\n\n \n#define CMSG_COMPAT_ALIGN(len)\tALIGN((len), sizeof(s32))\n\n#define CMSG_COMPAT_DATA(cmsg)\t\t\t\t\\\n\t((void __user *)((char __user *)(cmsg) + sizeof(struct compat_cmsghdr)))\n#define CMSG_COMPAT_SPACE(len)\t\t\t\t\\\n\t(sizeof(struct compat_cmsghdr) + CMSG_COMPAT_ALIGN(len))\n#define CMSG_COMPAT_LEN(len)\t\t\t\t\\\n\t(sizeof(struct compat_cmsghdr) + (len))\n\n#define CMSG_COMPAT_FIRSTHDR(msg)\t\t\t\\\n\t(((msg)->msg_controllen) >= sizeof(struct compat_cmsghdr) ?\t\\\n\t (struct compat_cmsghdr __user *)((msg)->msg_control_user) :\t\\\n\t (struct compat_cmsghdr __user *)NULL)\n\n#define CMSG_COMPAT_OK(ucmlen, ucmsg, mhdr) \\\n\t((ucmlen) >= sizeof(struct compat_cmsghdr) && \\\n\t (ucmlen) <= (unsigned long) \\\n\t ((mhdr)->msg_controllen - \\\n\t  ((char __user *)(ucmsg) - (char __user *)(mhdr)->msg_control_user)))\n\nstatic inline struct compat_cmsghdr __user *cmsg_compat_nxthdr(struct msghdr *msg,\n\t\tstruct compat_cmsghdr __user *cmsg, int cmsg_len)\n{\n\tchar __user *ptr = (char __user *)cmsg + CMSG_COMPAT_ALIGN(cmsg_len);\n\tif ((unsigned long)(ptr + 1 - (char __user *)msg->msg_control_user) >\n\t\t\tmsg->msg_controllen)\n\t\treturn NULL;\n\treturn (struct compat_cmsghdr __user *)ptr;\n}\n\n \nint cmsghdr_from_user_compat_to_kern(struct msghdr *kmsg, struct sock *sk,\n\t\t\t       unsigned char *stackbuf, int stackbuf_size)\n{\n\tstruct compat_cmsghdr __user *ucmsg;\n\tstruct cmsghdr *kcmsg, *kcmsg_base;\n\tcompat_size_t ucmlen;\n\t__kernel_size_t kcmlen, tmp;\n\tint err = -EFAULT;\n\n\tBUILD_BUG_ON(sizeof(struct compat_cmsghdr) !=\n\t\t     CMSG_COMPAT_ALIGN(sizeof(struct compat_cmsghdr)));\n\n\tkcmlen = 0;\n\tkcmsg_base = kcmsg = (struct cmsghdr *)stackbuf;\n\tucmsg = CMSG_COMPAT_FIRSTHDR(kmsg);\n\twhile (ucmsg != NULL) {\n\t\tif (get_user(ucmlen, &ucmsg->cmsg_len))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (!CMSG_COMPAT_OK(ucmlen, ucmsg, kmsg))\n\t\t\treturn -EINVAL;\n\n\t\ttmp = ((ucmlen - sizeof(*ucmsg)) + sizeof(struct cmsghdr));\n\t\ttmp = CMSG_ALIGN(tmp);\n\t\tkcmlen += tmp;\n\t\tucmsg = cmsg_compat_nxthdr(kmsg, ucmsg, ucmlen);\n\t}\n\tif (kcmlen == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (kcmlen > stackbuf_size)\n\t\tkcmsg_base = kcmsg = sock_kmalloc(sk, kcmlen, GFP_KERNEL);\n\tif (kcmsg == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tmemset(kcmsg, 0, kcmlen);\n\tucmsg = CMSG_COMPAT_FIRSTHDR(kmsg);\n\twhile (ucmsg != NULL) {\n\t\tstruct compat_cmsghdr cmsg;\n\t\tif (copy_from_user(&cmsg, ucmsg, sizeof(cmsg)))\n\t\t\tgoto Efault;\n\t\tif (!CMSG_COMPAT_OK(cmsg.cmsg_len, ucmsg, kmsg))\n\t\t\tgoto Einval;\n\t\ttmp = ((cmsg.cmsg_len - sizeof(*ucmsg)) + sizeof(struct cmsghdr));\n\t\tif ((char *)kcmsg_base + kcmlen - (char *)kcmsg < CMSG_ALIGN(tmp))\n\t\t\tgoto Einval;\n\t\tkcmsg->cmsg_len = tmp;\n\t\tkcmsg->cmsg_level = cmsg.cmsg_level;\n\t\tkcmsg->cmsg_type = cmsg.cmsg_type;\n\t\ttmp = CMSG_ALIGN(tmp);\n\t\tif (copy_from_user(CMSG_DATA(kcmsg),\n\t\t\t\t   CMSG_COMPAT_DATA(ucmsg),\n\t\t\t\t   (cmsg.cmsg_len - sizeof(*ucmsg))))\n\t\t\tgoto Efault;\n\n\t\t \n\t\tkcmsg = (struct cmsghdr *)((char *)kcmsg + tmp);\n\t\tucmsg = cmsg_compat_nxthdr(kmsg, ucmsg, cmsg.cmsg_len);\n\t}\n\n\t \n\tif ((char *)kcmsg - (char *)kcmsg_base != kcmlen)\n\t\tgoto Einval;\n\n\t \n\tkmsg->msg_control_is_user = false;\n\tkmsg->msg_control = kcmsg_base;\n\tkmsg->msg_controllen = kcmlen;\n\treturn 0;\n\nEinval:\n\terr = -EINVAL;\nEfault:\n\tif (kcmsg_base != (struct cmsghdr *)stackbuf)\n\t\tsock_kfree_s(sk, kcmsg_base, kcmlen);\n\treturn err;\n}\n\nint put_cmsg_compat(struct msghdr *kmsg, int level, int type, int len, void *data)\n{\n\tstruct compat_cmsghdr __user *cm = (struct compat_cmsghdr __user *) kmsg->msg_control_user;\n\tstruct compat_cmsghdr cmhdr;\n\tstruct old_timeval32 ctv;\n\tstruct old_timespec32 cts[3];\n\tint cmlen;\n\n\tif (cm == NULL || kmsg->msg_controllen < sizeof(*cm)) {\n\t\tkmsg->msg_flags |= MSG_CTRUNC;\n\t\treturn 0;  \n\t}\n\n\tif (!COMPAT_USE_64BIT_TIME) {\n\t\tif (level == SOL_SOCKET && type == SO_TIMESTAMP_OLD) {\n\t\t\tstruct __kernel_old_timeval *tv = (struct __kernel_old_timeval *)data;\n\t\t\tctv.tv_sec = tv->tv_sec;\n\t\t\tctv.tv_usec = tv->tv_usec;\n\t\t\tdata = &ctv;\n\t\t\tlen = sizeof(ctv);\n\t\t}\n\t\tif (level == SOL_SOCKET &&\n\t\t    (type == SO_TIMESTAMPNS_OLD || type == SO_TIMESTAMPING_OLD)) {\n\t\t\tint count = type == SO_TIMESTAMPNS_OLD ? 1 : 3;\n\t\t\tint i;\n\t\t\tstruct __kernel_old_timespec *ts = data;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tcts[i].tv_sec = ts[i].tv_sec;\n\t\t\t\tcts[i].tv_nsec = ts[i].tv_nsec;\n\t\t\t}\n\t\t\tdata = &cts;\n\t\t\tlen = sizeof(cts[0]) * count;\n\t\t}\n\t}\n\n\tcmlen = CMSG_COMPAT_LEN(len);\n\tif (kmsg->msg_controllen < cmlen) {\n\t\tkmsg->msg_flags |= MSG_CTRUNC;\n\t\tcmlen = kmsg->msg_controllen;\n\t}\n\tcmhdr.cmsg_level = level;\n\tcmhdr.cmsg_type = type;\n\tcmhdr.cmsg_len = cmlen;\n\n\tif (copy_to_user(cm, &cmhdr, sizeof cmhdr))\n\t\treturn -EFAULT;\n\tif (copy_to_user(CMSG_COMPAT_DATA(cm), data, cmlen - sizeof(struct compat_cmsghdr)))\n\t\treturn -EFAULT;\n\tcmlen = CMSG_COMPAT_SPACE(len);\n\tif (kmsg->msg_controllen < cmlen)\n\t\tcmlen = kmsg->msg_controllen;\n\tkmsg->msg_control_user += cmlen;\n\tkmsg->msg_controllen -= cmlen;\n\treturn 0;\n}\n\nstatic int scm_max_fds_compat(struct msghdr *msg)\n{\n\tif (msg->msg_controllen <= sizeof(struct compat_cmsghdr))\n\t\treturn 0;\n\treturn (msg->msg_controllen - sizeof(struct compat_cmsghdr)) / sizeof(int);\n}\n\nvoid scm_detach_fds_compat(struct msghdr *msg, struct scm_cookie *scm)\n{\n\tstruct compat_cmsghdr __user *cm =\n\t\t(struct compat_cmsghdr __user *)msg->msg_control_user;\n\tunsigned int o_flags = (msg->msg_flags & MSG_CMSG_CLOEXEC) ? O_CLOEXEC : 0;\n\tint fdmax = min_t(int, scm_max_fds_compat(msg), scm->fp->count);\n\tint __user *cmsg_data = CMSG_COMPAT_DATA(cm);\n\tint err = 0, i;\n\n\tfor (i = 0; i < fdmax; i++) {\n\t\terr = receive_fd_user(scm->fp->fp[i], cmsg_data + i, o_flags);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\tif (i > 0) {\n\t\tint cmlen = CMSG_COMPAT_LEN(i * sizeof(int));\n\n\t\terr = put_user(SOL_SOCKET, &cm->cmsg_level);\n\t\tif (!err)\n\t\t\terr = put_user(SCM_RIGHTS, &cm->cmsg_type);\n\t\tif (!err)\n\t\t\terr = put_user(cmlen, &cm->cmsg_len);\n\t\tif (!err) {\n\t\t\tcmlen = CMSG_COMPAT_SPACE(i * sizeof(int));\n\t\t\tif (msg->msg_controllen < cmlen)\n\t\t\t\tcmlen = msg->msg_controllen;\n\t\t\tmsg->msg_control_user += cmlen;\n\t\t\tmsg->msg_controllen -= cmlen;\n\t\t}\n\t}\n\n\tif (i < scm->fp->count || (scm->fp->count && fdmax <= 0))\n\t\tmsg->msg_flags |= MSG_CTRUNC;\n\n\t \n\t__scm_destroy(scm);\n}\n\n \n#define AL(x) ((x) * sizeof(u32))\nstatic unsigned char nas[21] = {\n\tAL(0), AL(3), AL(3), AL(3), AL(2), AL(3),\n\tAL(3), AL(3), AL(4), AL(4), AL(4), AL(6),\n\tAL(6), AL(2), AL(5), AL(5), AL(3), AL(3),\n\tAL(4), AL(5), AL(4)\n};\n#undef AL\n\nstatic inline long __compat_sys_sendmsg(int fd,\n\t\t\t\t\tstruct compat_msghdr __user *msg,\n\t\t\t\t\tunsigned int flags)\n{\n\treturn __sys_sendmsg(fd, (struct user_msghdr __user *)msg,\n\t\t\t     flags | MSG_CMSG_COMPAT, false);\n}\n\nCOMPAT_SYSCALL_DEFINE3(sendmsg, int, fd, struct compat_msghdr __user *, msg,\n\t\t       unsigned int, flags)\n{\n\treturn __compat_sys_sendmsg(fd, msg, flags);\n}\n\nstatic inline long __compat_sys_sendmmsg(int fd,\n\t\t\t\t\t struct compat_mmsghdr __user *mmsg,\n\t\t\t\t\t unsigned int vlen, unsigned int flags)\n{\n\treturn __sys_sendmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t      flags | MSG_CMSG_COMPAT, false);\n}\n\nCOMPAT_SYSCALL_DEFINE4(sendmmsg, int, fd, struct compat_mmsghdr __user *, mmsg,\n\t\t       unsigned int, vlen, unsigned int, flags)\n{\n\treturn __compat_sys_sendmmsg(fd, mmsg, vlen, flags);\n}\n\nstatic inline long __compat_sys_recvmsg(int fd,\n\t\t\t\t\tstruct compat_msghdr __user *msg,\n\t\t\t\t\tunsigned int flags)\n{\n\treturn __sys_recvmsg(fd, (struct user_msghdr __user *)msg,\n\t\t\t     flags | MSG_CMSG_COMPAT, false);\n}\n\nCOMPAT_SYSCALL_DEFINE3(recvmsg, int, fd, struct compat_msghdr __user *, msg,\n\t\t       unsigned int, flags)\n{\n\treturn __compat_sys_recvmsg(fd, msg, flags);\n}\n\nstatic inline long __compat_sys_recvfrom(int fd, void __user *buf,\n\t\t\t\t\t compat_size_t len, unsigned int flags,\n\t\t\t\t\t struct sockaddr __user *addr,\n\t\t\t\t\t int __user *addrlen)\n{\n\treturn __sys_recvfrom(fd, buf, len, flags | MSG_CMSG_COMPAT, addr,\n\t\t\t      addrlen);\n}\n\nCOMPAT_SYSCALL_DEFINE4(recv, int, fd, void __user *, buf, compat_size_t, len, unsigned int, flags)\n{\n\treturn __compat_sys_recvfrom(fd, buf, len, flags, NULL, NULL);\n}\n\nCOMPAT_SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, buf, compat_size_t, len,\n\t\t       unsigned int, flags, struct sockaddr __user *, addr,\n\t\t       int __user *, addrlen)\n{\n\treturn __compat_sys_recvfrom(fd, buf, len, flags, addr, addrlen);\n}\n\nCOMPAT_SYSCALL_DEFINE5(recvmmsg_time64, int, fd, struct compat_mmsghdr __user *, mmsg,\n\t\t       unsigned int, vlen, unsigned int, flags,\n\t\t       struct __kernel_timespec __user *, timeout)\n{\n\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t      flags | MSG_CMSG_COMPAT, timeout, NULL);\n}\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nCOMPAT_SYSCALL_DEFINE5(recvmmsg_time32, int, fd, struct compat_mmsghdr __user *, mmsg,\n\t\t       unsigned int, vlen, unsigned int, flags,\n\t\t       struct old_timespec32 __user *, timeout)\n{\n\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t      flags | MSG_CMSG_COMPAT, NULL, timeout);\n}\n#endif\n\nCOMPAT_SYSCALL_DEFINE2(socketcall, int, call, u32 __user *, args)\n{\n\tu32 a[AUDITSC_ARGS];\n\tunsigned int len;\n\tu32 a0, a1;\n\tint ret;\n\n\tif (call < SYS_SOCKET || call > SYS_SENDMMSG)\n\t\treturn -EINVAL;\n\tlen = nas[call];\n\tif (len > sizeof(a))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(a, args, len))\n\t\treturn -EFAULT;\n\n\tret = audit_socketcall_compat(len / sizeof(a[0]), a);\n\tif (ret)\n\t\treturn ret;\n\n\ta0 = a[0];\n\ta1 = a[1];\n\n\tswitch (call) {\n\tcase SYS_SOCKET:\n\t\tret = __sys_socket(a0, a1, a[2]);\n\t\tbreak;\n\tcase SYS_BIND:\n\t\tret = __sys_bind(a0, compat_ptr(a1), a[2]);\n\t\tbreak;\n\tcase SYS_CONNECT:\n\t\tret = __sys_connect(a0, compat_ptr(a1), a[2]);\n\t\tbreak;\n\tcase SYS_LISTEN:\n\t\tret = __sys_listen(a0, a1);\n\t\tbreak;\n\tcase SYS_ACCEPT:\n\t\tret = __sys_accept4(a0, compat_ptr(a1), compat_ptr(a[2]), 0);\n\t\tbreak;\n\tcase SYS_GETSOCKNAME:\n\t\tret = __sys_getsockname(a0, compat_ptr(a1), compat_ptr(a[2]));\n\t\tbreak;\n\tcase SYS_GETPEERNAME:\n\t\tret = __sys_getpeername(a0, compat_ptr(a1), compat_ptr(a[2]));\n\t\tbreak;\n\tcase SYS_SOCKETPAIR:\n\t\tret = __sys_socketpair(a0, a1, a[2], compat_ptr(a[3]));\n\t\tbreak;\n\tcase SYS_SEND:\n\t\tret = __sys_sendto(a0, compat_ptr(a1), a[2], a[3], NULL, 0);\n\t\tbreak;\n\tcase SYS_SENDTO:\n\t\tret = __sys_sendto(a0, compat_ptr(a1), a[2], a[3],\n\t\t\t\t   compat_ptr(a[4]), a[5]);\n\t\tbreak;\n\tcase SYS_RECV:\n\t\tret = __compat_sys_recvfrom(a0, compat_ptr(a1), a[2], a[3],\n\t\t\t\t\t    NULL, NULL);\n\t\tbreak;\n\tcase SYS_RECVFROM:\n\t\tret = __compat_sys_recvfrom(a0, compat_ptr(a1), a[2], a[3],\n\t\t\t\t\t    compat_ptr(a[4]),\n\t\t\t\t\t    compat_ptr(a[5]));\n\t\tbreak;\n\tcase SYS_SHUTDOWN:\n\t\tret = __sys_shutdown(a0, a1);\n\t\tbreak;\n\tcase SYS_SETSOCKOPT:\n\t\tret = __sys_setsockopt(a0, a1, a[2], compat_ptr(a[3]), a[4]);\n\t\tbreak;\n\tcase SYS_GETSOCKOPT:\n\t\tret = __sys_getsockopt(a0, a1, a[2], compat_ptr(a[3]),\n\t\t\t\t       compat_ptr(a[4]));\n\t\tbreak;\n\tcase SYS_SENDMSG:\n\t\tret = __compat_sys_sendmsg(a0, compat_ptr(a1), a[2]);\n\t\tbreak;\n\tcase SYS_SENDMMSG:\n\t\tret = __compat_sys_sendmmsg(a0, compat_ptr(a1), a[2], a[3]);\n\t\tbreak;\n\tcase SYS_RECVMSG:\n\t\tret = __compat_sys_recvmsg(a0, compat_ptr(a1), a[2]);\n\t\tbreak;\n\tcase SYS_RECVMMSG:\n\t\tret = __sys_recvmmsg(a0, compat_ptr(a1), a[2],\n\t\t\t\t     a[3] | MSG_CMSG_COMPAT, NULL,\n\t\t\t\t     compat_ptr(a[4]));\n\t\tbreak;\n\tcase SYS_ACCEPT4:\n\t\tret = __sys_accept4(a0, compat_ptr(a1), compat_ptr(a[2]), a[3]);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}