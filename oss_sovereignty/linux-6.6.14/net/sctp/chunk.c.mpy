{
  "module_name": "chunk.c",
  "hash_id": "c5426ecc845e9cb198b46522dc67cc2b3ce730b74c7c3db51627d31dc049ded0",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/chunk.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\n \n\n \nstatic void sctp_datamsg_init(struct sctp_datamsg *msg)\n{\n\trefcount_set(&msg->refcnt, 1);\n\tmsg->send_failed = 0;\n\tmsg->send_error = 0;\n\tmsg->can_delay = 1;\n\tmsg->abandoned = 0;\n\tmsg->expires_at = 0;\n\tINIT_LIST_HEAD(&msg->chunks);\n}\n\n \nstatic struct sctp_datamsg *sctp_datamsg_new(gfp_t gfp)\n{\n\tstruct sctp_datamsg *msg;\n\tmsg = kmalloc(sizeof(struct sctp_datamsg), gfp);\n\tif (msg) {\n\t\tsctp_datamsg_init(msg);\n\t\tSCTP_DBG_OBJCNT_INC(datamsg);\n\t}\n\treturn msg;\n}\n\nvoid sctp_datamsg_free(struct sctp_datamsg *msg)\n{\n\tstruct sctp_chunk *chunk;\n\n\t \n\tlist_for_each_entry(chunk, &msg->chunks, frag_list)\n\t\tsctp_chunk_free(chunk);\n\n\tsctp_datamsg_put(msg);\n}\n\n \nstatic void sctp_datamsg_destroy(struct sctp_datamsg *msg)\n{\n\tstruct sctp_association *asoc = NULL;\n\tstruct list_head *pos, *temp;\n\tstruct sctp_chunk *chunk;\n\tstruct sctp_ulpevent *ev;\n\tint error, sent;\n\n\t \n\tlist_for_each_safe(pos, temp, &msg->chunks) {\n\t\tlist_del_init(pos);\n\t\tchunk = list_entry(pos, struct sctp_chunk, frag_list);\n\n\t\tif (!msg->send_failed) {\n\t\t\tsctp_chunk_put(chunk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tasoc = chunk->asoc;\n\t\terror = msg->send_error ?: asoc->outqueue.error;\n\t\tsent = chunk->has_tsn ? SCTP_DATA_SENT : SCTP_DATA_UNSENT;\n\n\t\tif (sctp_ulpevent_type_enabled(asoc->subscribe,\n\t\t\t\t\t       SCTP_SEND_FAILED)) {\n\t\t\tev = sctp_ulpevent_make_send_failed(asoc, chunk, sent,\n\t\t\t\t\t\t\t    error, GFP_ATOMIC);\n\t\t\tif (ev)\n\t\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, ev);\n\t\t}\n\n\t\tif (sctp_ulpevent_type_enabled(asoc->subscribe,\n\t\t\t\t\t       SCTP_SEND_FAILED_EVENT)) {\n\t\t\tev = sctp_ulpevent_make_send_failed_event(asoc, chunk,\n\t\t\t\t\t\t\t\t  sent, error,\n\t\t\t\t\t\t\t\t  GFP_ATOMIC);\n\t\t\tif (ev)\n\t\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, ev);\n\t\t}\n\n\t\tsctp_chunk_put(chunk);\n\t}\n\n\tSCTP_DBG_OBJCNT_DEC(datamsg);\n\tkfree(msg);\n}\n\n \nstatic void sctp_datamsg_hold(struct sctp_datamsg *msg)\n{\n\trefcount_inc(&msg->refcnt);\n}\n\n \nvoid sctp_datamsg_put(struct sctp_datamsg *msg)\n{\n\tif (refcount_dec_and_test(&msg->refcnt))\n\t\tsctp_datamsg_destroy(msg);\n}\n\n \nstatic void sctp_datamsg_assign(struct sctp_datamsg *msg, struct sctp_chunk *chunk)\n{\n\tsctp_datamsg_hold(msg);\n\tchunk->msg = msg;\n}\n\n\n \nstruct sctp_datamsg *sctp_datamsg_from_user(struct sctp_association *asoc,\n\t\t\t\t\t    struct sctp_sndrcvinfo *sinfo,\n\t\t\t\t\t    struct iov_iter *from)\n{\n\tsize_t len, first_len, max_data, remaining;\n\tsize_t msg_len = iov_iter_count(from);\n\tstruct sctp_shared_key *shkey = NULL;\n\tstruct list_head *pos, *temp;\n\tstruct sctp_chunk *chunk;\n\tstruct sctp_datamsg *msg;\n\tint err;\n\n\tmsg = sctp_datamsg_new(GFP_KERNEL);\n\tif (!msg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tif (asoc->peer.prsctp_capable && sinfo->sinfo_timetolive &&\n\t    (SCTP_PR_TTL_ENABLED(sinfo->sinfo_flags) ||\n\t     !SCTP_PR_POLICY(sinfo->sinfo_flags)))\n\t\tmsg->expires_at = jiffies +\n\t\t\t\t  msecs_to_jiffies(sinfo->sinfo_timetolive);\n\n\t \n\tmax_data = asoc->frag_point;\n\tif (unlikely(!max_data)) {\n\t\tmax_data = sctp_min_frag_point(sctp_sk(asoc->base.sk),\n\t\t\t\t\t       sctp_datachk_len(&asoc->stream));\n\t\tpr_warn_ratelimited(\"%s: asoc:%p frag_point is zero, forcing max_data to default minimum (%zu)\",\n\t\t\t\t    __func__, asoc, max_data);\n\t}\n\n\t \n\tif (sctp_auth_send_cid(SCTP_CID_DATA, asoc)) {\n\t\tstruct sctp_hmac *hmac_desc = sctp_auth_asoc_get_hmac(asoc);\n\n\t\tif (hmac_desc)\n\t\t\tmax_data -= SCTP_PAD4(sizeof(struct sctp_auth_chunk) +\n\t\t\t\t\t      hmac_desc->hmac_len);\n\n\t\tif (sinfo->sinfo_tsn &&\n\t\t    sinfo->sinfo_ssn != asoc->active_key_id) {\n\t\t\tshkey = sctp_auth_get_shkey(asoc, sinfo->sinfo_ssn);\n\t\t\tif (!shkey) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t} else {\n\t\t\tshkey = asoc->shkey;\n\t\t}\n\t}\n\n\t \n\tfirst_len = max_data;\n\n\t \n\tif (timer_pending(&asoc->timers[SCTP_EVENT_TIMEOUT_SACK]) &&\n\t    asoc->outqueue.out_qlen == 0 &&\n\t    list_empty(&asoc->outqueue.retransmit) &&\n\t    msg_len > max_data)\n\t\tfirst_len -= SCTP_PAD4(sizeof(struct sctp_sack_chunk));\n\n\t \n\tif (asoc->state < SCTP_STATE_COOKIE_ECHOED)\n\t\tfirst_len -= SCTP_ARBITRARY_COOKIE_ECHO_LEN;\n\n\t \n\tif (msg_len >= first_len) {\n\t\tmsg->can_delay = 0;\n\t\tif (msg_len > first_len)\n\t\t\tSCTP_INC_STATS(asoc->base.net,\n\t\t\t\t       SCTP_MIB_FRAGUSRMSGS);\n\t} else {\n\t\t \n\t\tfirst_len = msg_len;\n\t}\n\n\t \n\tfor (remaining = msg_len; remaining; remaining -= len) {\n\t\tu8 frag = SCTP_DATA_MIDDLE_FRAG;\n\n\t\tif (remaining == msg_len) {\n\t\t\t \n\t\t\tfrag |= SCTP_DATA_FIRST_FRAG;\n\t\t\tlen = first_len;\n\t\t} else {\n\t\t\t \n\t\t\tlen = max_data;\n\t\t}\n\n\t\tif (len >= remaining) {\n\t\t\t \n\t\t\tlen = remaining;\n\t\t\tfrag |= SCTP_DATA_LAST_FRAG;\n\n\t\t\t \n\t\t\tif ((sinfo->sinfo_flags & SCTP_EOF) ||\n\t\t\t    (sinfo->sinfo_flags & SCTP_SACK_IMMEDIATELY))\n\t\t\t\tfrag |= SCTP_DATA_SACK_IMM;\n\t\t}\n\n\t\tchunk = asoc->stream.si->make_datafrag(asoc, sinfo, len, frag,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!chunk) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout;\n\t\t}\n\n\t\terr = sctp_user_addto_chunk(chunk, len, from);\n\t\tif (err < 0)\n\t\t\tgoto errout_chunk_free;\n\n\t\tchunk->shkey = shkey;\n\n\t\t \n\t\t__skb_pull(chunk->skb, (__u8 *)chunk->chunk_hdr -\n\t\t\t\t       chunk->skb->data);\n\n\t\tsctp_datamsg_assign(msg, chunk);\n\t\tlist_add_tail(&chunk->frag_list, &msg->chunks);\n\t}\n\n\treturn msg;\n\nerrout_chunk_free:\n\tsctp_chunk_free(chunk);\n\nerrout:\n\tlist_for_each_safe(pos, temp, &msg->chunks) {\n\t\tlist_del_init(pos);\n\t\tchunk = list_entry(pos, struct sctp_chunk, frag_list);\n\t\tsctp_chunk_free(chunk);\n\t}\n\tsctp_datamsg_put(msg);\n\n\treturn ERR_PTR(err);\n}\n\n \nint sctp_chunk_abandoned(struct sctp_chunk *chunk)\n{\n\tif (!chunk->asoc->peer.prsctp_capable)\n\t\treturn 0;\n\n\tif (chunk->msg->abandoned)\n\t\treturn 1;\n\n\tif (!chunk->has_tsn &&\n\t    !(chunk->chunk_hdr->flags & SCTP_DATA_FIRST_FRAG))\n\t\treturn 0;\n\n\tif (SCTP_PR_TTL_ENABLED(chunk->sinfo.sinfo_flags) &&\n\t    time_after(jiffies, chunk->msg->expires_at)) {\n\t\tstruct sctp_stream_out *streamout =\n\t\t\tSCTP_SO(&chunk->asoc->stream,\n\t\t\t\tchunk->sinfo.sinfo_stream);\n\n\t\tif (chunk->sent_count) {\n\t\t\tchunk->asoc->abandoned_sent[SCTP_PR_INDEX(TTL)]++;\n\t\t\tstreamout->ext->abandoned_sent[SCTP_PR_INDEX(TTL)]++;\n\t\t} else {\n\t\t\tchunk->asoc->abandoned_unsent[SCTP_PR_INDEX(TTL)]++;\n\t\t\tstreamout->ext->abandoned_unsent[SCTP_PR_INDEX(TTL)]++;\n\t\t}\n\t\tchunk->msg->abandoned = 1;\n\t\treturn 1;\n\t} else if (SCTP_PR_RTX_ENABLED(chunk->sinfo.sinfo_flags) &&\n\t\t   chunk->sent_count > chunk->sinfo.sinfo_timetolive) {\n\t\tstruct sctp_stream_out *streamout =\n\t\t\tSCTP_SO(&chunk->asoc->stream,\n\t\t\t\tchunk->sinfo.sinfo_stream);\n\n\t\tchunk->asoc->abandoned_sent[SCTP_PR_INDEX(RTX)]++;\n\t\tstreamout->ext->abandoned_sent[SCTP_PR_INDEX(RTX)]++;\n\t\tchunk->msg->abandoned = 1;\n\t\treturn 1;\n\t} else if (!SCTP_PR_POLICY(chunk->sinfo.sinfo_flags) &&\n\t\t   chunk->msg->expires_at &&\n\t\t   time_after(jiffies, chunk->msg->expires_at)) {\n\t\tchunk->msg->abandoned = 1;\n\t\treturn 1;\n\t}\n\t \n\n\treturn 0;\n}\n\n \nvoid sctp_chunk_fail(struct sctp_chunk *chunk, int error)\n{\n\tchunk->msg->send_failed = 1;\n\tchunk->msg->send_error = error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}