{
  "module_name": "sysctl.c",
  "hash_id": "633a89edb39310311da085f5e686021be45522fbf51b097ece79950625ba240b",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/sysctl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <net/sctp/structs.h>\n#include <net/sctp/sctp.h>\n#include <linux/sysctl.h>\n\nstatic int timer_max = 86400000;  \nstatic int sack_timer_min = 1;\nstatic int sack_timer_max = 500;\nstatic int addr_scope_max = SCTP_SCOPE_POLICY_MAX;\nstatic int rwnd_scale_max = 16;\nstatic int rto_alpha_min = 0;\nstatic int rto_beta_min = 0;\nstatic int rto_alpha_max = 1000;\nstatic int rto_beta_max = 1000;\nstatic int pf_expose_max = SCTP_PF_EXPOSE_MAX;\nstatic int ps_retrans_max = SCTP_PS_RETRANS_MAX;\nstatic int udp_port_max = 65535;\n\nstatic unsigned long max_autoclose_min = 0;\nstatic unsigned long max_autoclose_max =\n\t(MAX_SCHEDULE_TIMEOUT / HZ > UINT_MAX)\n\t? UINT_MAX : MAX_SCHEDULE_TIMEOUT / HZ;\n\nstatic int proc_sctp_do_hmac_alg(struct ctl_table *ctl, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos);\nstatic int proc_sctp_do_rto_min(struct ctl_table *ctl, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos);\nstatic int proc_sctp_do_rto_max(struct ctl_table *ctl, int write, void *buffer,\n\t\t\t\tsize_t *lenp, loff_t *ppos);\nstatic int proc_sctp_do_udp_port(struct ctl_table *ctl, int write, void *buffer,\n\t\t\t\t size_t *lenp, loff_t *ppos);\nstatic int proc_sctp_do_alpha_beta(struct ctl_table *ctl, int write,\n\t\t\t\t   void *buffer, size_t *lenp, loff_t *ppos);\nstatic int proc_sctp_do_auth(struct ctl_table *ctl, int write,\n\t\t\t     void *buffer, size_t *lenp, loff_t *ppos);\nstatic int proc_sctp_do_probe_interval(struct ctl_table *ctl, int write,\n\t\t\t\t       void *buffer, size_t *lenp, loff_t *ppos);\n\nstatic struct ctl_table sctp_table[] = {\n\t{\n\t\t.procname\t= \"sctp_mem\",\n\t\t.data\t\t= &sysctl_sctp_mem,\n\t\t.maxlen\t\t= sizeof(sysctl_sctp_mem),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax\n\t},\n\t{\n\t\t.procname\t= \"sctp_rmem\",\n\t\t.data\t\t= &sysctl_sctp_rmem,\n\t\t.maxlen\t\t= sizeof(sysctl_sctp_rmem),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"sctp_wmem\",\n\t\t.data\t\t= &sysctl_sctp_wmem,\n\t\t.maxlen\t\t= sizeof(sysctl_sctp_wmem),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\n\t{   }\n};\n\n \n#define SCTP_RTO_MIN_IDX       0\n#define SCTP_RTO_MAX_IDX       1\n#define SCTP_PF_RETRANS_IDX    2\n#define SCTP_PS_RETRANS_IDX    3\n\nstatic struct ctl_table sctp_net_table[] = {\n\t[SCTP_RTO_MIN_IDX] = {\n\t\t.procname\t= \"rto_min\",\n\t\t.data\t\t= &init_net.sctp.rto_min,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_sctp_do_rto_min,\n\t\t.extra1         = SYSCTL_ONE,\n\t\t.extra2         = &init_net.sctp.rto_max\n\t},\n\t[SCTP_RTO_MAX_IDX] =  {\n\t\t.procname\t= \"rto_max\",\n\t\t.data\t\t= &init_net.sctp.rto_max,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_sctp_do_rto_max,\n\t\t.extra1         = &init_net.sctp.rto_min,\n\t\t.extra2         = &timer_max\n\t},\n\t[SCTP_PF_RETRANS_IDX] = {\n\t\t.procname\t= \"pf_retrans\",\n\t\t.data\t\t= &init_net.sctp.pf_retrans,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &init_net.sctp.ps_retrans,\n\t},\n\t[SCTP_PS_RETRANS_IDX] = {\n\t\t.procname\t= \"ps_retrans\",\n\t\t.data\t\t= &init_net.sctp.ps_retrans,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &init_net.sctp.pf_retrans,\n\t\t.extra2\t\t= &ps_retrans_max,\n\t},\n\t{\n\t\t.procname\t= \"rto_initial\",\n\t\t.data\t\t= &init_net.sctp.rto_initial,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1         = SYSCTL_ONE,\n\t\t.extra2         = &timer_max\n\t},\n\t{\n\t\t.procname\t= \"rto_alpha_exp_divisor\",\n\t\t.data\t\t= &init_net.sctp.rto_alpha,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_sctp_do_alpha_beta,\n\t\t.extra1\t\t= &rto_alpha_min,\n\t\t.extra2\t\t= &rto_alpha_max,\n\t},\n\t{\n\t\t.procname\t= \"rto_beta_exp_divisor\",\n\t\t.data\t\t= &init_net.sctp.rto_beta,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_sctp_do_alpha_beta,\n\t\t.extra1\t\t= &rto_beta_min,\n\t\t.extra2\t\t= &rto_beta_max,\n\t},\n\t{\n\t\t.procname\t= \"max_burst\",\n\t\t.data\t\t= &init_net.sctp.max_burst,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t},\n\t{\n\t\t.procname\t= \"cookie_preserve_enable\",\n\t\t.data\t\t= &init_net.sctp.cookie_preserve_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"cookie_hmac_alg\",\n\t\t.data\t\t= &init_net.sctp.sctp_hmac_alg,\n\t\t.maxlen\t\t= 8,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_sctp_do_hmac_alg,\n\t},\n\t{\n\t\t.procname\t= \"valid_cookie_life\",\n\t\t.data\t\t= &init_net.sctp.valid_cookie_life,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1         = SYSCTL_ONE,\n\t\t.extra2         = &timer_max\n\t},\n\t{\n\t\t.procname\t= \"sack_timeout\",\n\t\t.data\t\t= &init_net.sctp.sack_timeout,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1         = &sack_timer_min,\n\t\t.extra2         = &sack_timer_max,\n\t},\n\t{\n\t\t.procname\t= \"hb_interval\",\n\t\t.data\t\t= &init_net.sctp.hb_interval,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1         = SYSCTL_ONE,\n\t\t.extra2         = &timer_max\n\t},\n\t{\n\t\t.procname\t= \"association_max_retrans\",\n\t\t.data\t\t= &init_net.sctp.max_retrans_association,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t},\n\t{\n\t\t.procname\t= \"path_max_retrans\",\n\t\t.data\t\t= &init_net.sctp.max_retrans_path,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t},\n\t{\n\t\t.procname\t= \"max_init_retransmits\",\n\t\t.data\t\t= &init_net.sctp.max_retrans_init,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= SYSCTL_INT_MAX,\n\t},\n\t{\n\t\t.procname\t= \"sndbuf_policy\",\n\t\t.data\t\t= &init_net.sctp.sndbuf_policy,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"rcvbuf_policy\",\n\t\t.data\t\t= &init_net.sctp.rcvbuf_policy,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"default_auto_asconf\",\n\t\t.data\t\t= &init_net.sctp.default_auto_asconf,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"addip_enable\",\n\t\t.data\t\t= &init_net.sctp.addip_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"addip_noauth_enable\",\n\t\t.data\t\t= &init_net.sctp.addip_noauth,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"prsctp_enable\",\n\t\t.data\t\t= &init_net.sctp.prsctp_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"reconf_enable\",\n\t\t.data\t\t= &init_net.sctp.reconf_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"auth_enable\",\n\t\t.data\t\t= &init_net.sctp.auth_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_sctp_do_auth,\n\t},\n\t{\n\t\t.procname\t= \"intl_enable\",\n\t\t.data\t\t= &init_net.sctp.intl_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"ecn_enable\",\n\t\t.data\t\t= &init_net.sctp.ecn_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"plpmtud_probe_interval\",\n\t\t.data\t\t= &init_net.sctp.probe_interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_sctp_do_probe_interval,\n\t},\n\t{\n\t\t.procname\t= \"udp_port\",\n\t\t.data\t\t= &init_net.sctp.udp_port,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_sctp_do_udp_port,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &udp_port_max,\n\t},\n\t{\n\t\t.procname\t= \"encap_port\",\n\t\t.data\t\t= &init_net.sctp.encap_port,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &udp_port_max,\n\t},\n\t{\n\t\t.procname\t= \"addr_scope_policy\",\n\t\t.data\t\t= &init_net.sctp.scope_policy,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &addr_scope_max,\n\t},\n\t{\n\t\t.procname\t= \"rwnd_update_shift\",\n\t\t.data\t\t= &init_net.sctp.rwnd_upd_shift,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= &proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ONE,\n\t\t.extra2\t\t= &rwnd_scale_max,\n\t},\n\t{\n\t\t.procname\t= \"max_autoclose\",\n\t\t.data\t\t= &init_net.sctp.max_autoclose,\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= &proc_doulongvec_minmax,\n\t\t.extra1\t\t= &max_autoclose_min,\n\t\t.extra2\t\t= &max_autoclose_max,\n\t},\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\t{\n\t\t.procname\t= \"l3mdev_accept\",\n\t\t.data\t\t= &init_net.sctp.l3mdev_accept,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"pf_enable\",\n\t\t.data\t\t= &init_net.sctp.pf_enable,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"pf_expose\",\n\t\t.data\t\t= &init_net.sctp.pf_expose,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &pf_expose_max,\n\t},\n\n\t{   }\n};\n\nstatic int proc_sctp_do_hmac_alg(struct ctl_table *ctl, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct ctl_table tbl;\n\tbool changed = false;\n\tchar *none = \"none\";\n\tchar tmp[8] = {0};\n\tint ret;\n\n\tmemset(&tbl, 0, sizeof(struct ctl_table));\n\n\tif (write) {\n\t\ttbl.data = tmp;\n\t\ttbl.maxlen = sizeof(tmp);\n\t} else {\n\t\ttbl.data = net->sctp.sctp_hmac_alg ? : none;\n\t\ttbl.maxlen = strlen(tbl.data);\n\t}\n\n\tret = proc_dostring(&tbl, write, buffer, lenp, ppos);\n\tif (write && ret == 0) {\n#ifdef CONFIG_CRYPTO_MD5\n\t\tif (!strncmp(tmp, \"md5\", 3)) {\n\t\t\tnet->sctp.sctp_hmac_alg = \"md5\";\n\t\t\tchanged = true;\n\t\t}\n#endif\n#ifdef CONFIG_CRYPTO_SHA1\n\t\tif (!strncmp(tmp, \"sha1\", 4)) {\n\t\t\tnet->sctp.sctp_hmac_alg = \"sha1\";\n\t\t\tchanged = true;\n\t\t}\n#endif\n\t\tif (!strncmp(tmp, \"none\", 4)) {\n\t\t\tnet->sctp.sctp_hmac_alg = NULL;\n\t\t\tchanged = true;\n\t\t}\n\t\tif (!changed)\n\t\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int proc_sctp_do_rto_min(struct ctl_table *ctl, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tunsigned int min = *(unsigned int *) ctl->extra1;\n\tunsigned int max = *(unsigned int *) ctl->extra2;\n\tstruct ctl_table tbl;\n\tint ret, new_value;\n\n\tmemset(&tbl, 0, sizeof(struct ctl_table));\n\ttbl.maxlen = sizeof(unsigned int);\n\n\tif (write)\n\t\ttbl.data = &new_value;\n\telse\n\t\ttbl.data = &net->sctp.rto_min;\n\n\tret = proc_dointvec(&tbl, write, buffer, lenp, ppos);\n\tif (write && ret == 0) {\n\t\tif (new_value > max || new_value < min)\n\t\t\treturn -EINVAL;\n\n\t\tnet->sctp.rto_min = new_value;\n\t}\n\n\treturn ret;\n}\n\nstatic int proc_sctp_do_rto_max(struct ctl_table *ctl, int write,\n\t\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tunsigned int min = *(unsigned int *) ctl->extra1;\n\tunsigned int max = *(unsigned int *) ctl->extra2;\n\tstruct ctl_table tbl;\n\tint ret, new_value;\n\n\tmemset(&tbl, 0, sizeof(struct ctl_table));\n\ttbl.maxlen = sizeof(unsigned int);\n\n\tif (write)\n\t\ttbl.data = &new_value;\n\telse\n\t\ttbl.data = &net->sctp.rto_max;\n\n\tret = proc_dointvec(&tbl, write, buffer, lenp, ppos);\n\tif (write && ret == 0) {\n\t\tif (new_value > max || new_value < min)\n\t\t\treturn -EINVAL;\n\n\t\tnet->sctp.rto_max = new_value;\n\t}\n\n\treturn ret;\n}\n\nstatic int proc_sctp_do_alpha_beta(struct ctl_table *ctl, int write,\n\t\t\t\t   void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (write)\n\t\tpr_warn_once(\"Changing rto_alpha or rto_beta may lead to \"\n\t\t\t     \"suboptimal rtt/srtt estimations!\\n\");\n\n\treturn proc_dointvec_minmax(ctl, write, buffer, lenp, ppos);\n}\n\nstatic int proc_sctp_do_auth(struct ctl_table *ctl, int write,\n\t\t\t     void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct ctl_table tbl;\n\tint new_value, ret;\n\n\tmemset(&tbl, 0, sizeof(struct ctl_table));\n\ttbl.maxlen = sizeof(unsigned int);\n\n\tif (write)\n\t\ttbl.data = &new_value;\n\telse\n\t\ttbl.data = &net->sctp.auth_enable;\n\n\tret = proc_dointvec(&tbl, write, buffer, lenp, ppos);\n\tif (write && ret == 0) {\n\t\tstruct sock *sk = net->sctp.ctl_sock;\n\n\t\tnet->sctp.auth_enable = new_value;\n\t\t \n\t\tlock_sock(sk);\n\t\tsctp_sk(sk)->ep->auth_enable = new_value;\n\t\trelease_sock(sk);\n\t}\n\n\treturn ret;\n}\n\nstatic int proc_sctp_do_udp_port(struct ctl_table *ctl, int write,\n\t\t\t\t void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tunsigned int min = *(unsigned int *)ctl->extra1;\n\tunsigned int max = *(unsigned int *)ctl->extra2;\n\tstruct ctl_table tbl;\n\tint ret, new_value;\n\n\tmemset(&tbl, 0, sizeof(struct ctl_table));\n\ttbl.maxlen = sizeof(unsigned int);\n\n\tif (write)\n\t\ttbl.data = &new_value;\n\telse\n\t\ttbl.data = &net->sctp.udp_port;\n\n\tret = proc_dointvec(&tbl, write, buffer, lenp, ppos);\n\tif (write && ret == 0) {\n\t\tstruct sock *sk = net->sctp.ctl_sock;\n\n\t\tif (new_value > max || new_value < min)\n\t\t\treturn -EINVAL;\n\n\t\tnet->sctp.udp_port = new_value;\n\t\tsctp_udp_sock_stop(net);\n\t\tif (new_value) {\n\t\t\tret = sctp_udp_sock_start(net);\n\t\t\tif (ret)\n\t\t\t\tnet->sctp.udp_port = 0;\n\t\t}\n\n\t\t \n\t\tlock_sock(sk);\n\t\tsctp_sk(sk)->udp_port = htons(net->sctp.udp_port);\n\t\trelease_sock(sk);\n\t}\n\n\treturn ret;\n}\n\nstatic int proc_sctp_do_probe_interval(struct ctl_table *ctl, int write,\n\t\t\t\t       void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net = current->nsproxy->net_ns;\n\tstruct ctl_table tbl;\n\tint ret, new_value;\n\n\tmemset(&tbl, 0, sizeof(struct ctl_table));\n\ttbl.maxlen = sizeof(unsigned int);\n\n\tif (write)\n\t\ttbl.data = &new_value;\n\telse\n\t\ttbl.data = &net->sctp.probe_interval;\n\n\tret = proc_dointvec(&tbl, write, buffer, lenp, ppos);\n\tif (write && ret == 0) {\n\t\tif (new_value && new_value < SCTP_PROBE_TIMER_MIN)\n\t\t\treturn -EINVAL;\n\n\t\tnet->sctp.probe_interval = new_value;\n\t}\n\n\treturn ret;\n}\n\nint sctp_sysctl_net_register(struct net *net)\n{\n\tstruct ctl_table *table;\n\tint i;\n\n\ttable = kmemdup(sctp_net_table, sizeof(sctp_net_table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; table[i].data; i++)\n\t\ttable[i].data += (char *)(&net->sctp) - (char *)&init_net.sctp;\n\n\ttable[SCTP_RTO_MIN_IDX].extra2 = &net->sctp.rto_max;\n\ttable[SCTP_RTO_MAX_IDX].extra1 = &net->sctp.rto_min;\n\ttable[SCTP_PF_RETRANS_IDX].extra2 = &net->sctp.ps_retrans;\n\ttable[SCTP_PS_RETRANS_IDX].extra1 = &net->sctp.pf_retrans;\n\n\tnet->sctp.sysctl_header = register_net_sysctl_sz(net, \"net/sctp\",\n\t\t\t\t\t\t\t table,\n\t\t\t\t\t\t\t ARRAY_SIZE(sctp_net_table));\n\tif (net->sctp.sysctl_header == NULL) {\n\t\tkfree(table);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid sctp_sysctl_net_unregister(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = net->sctp.sysctl_header->ctl_table_arg;\n\tunregister_net_sysctl_table(net->sctp.sysctl_header);\n\tkfree(table);\n}\n\nstatic struct ctl_table_header *sctp_sysctl_header;\n\n \nvoid sctp_sysctl_register(void)\n{\n\tsctp_sysctl_header = register_net_sysctl(&init_net, \"net/sctp\", sctp_table);\n}\n\n \nvoid sctp_sysctl_unregister(void)\n{\n\tunregister_net_sysctl_table(sctp_sysctl_header);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}