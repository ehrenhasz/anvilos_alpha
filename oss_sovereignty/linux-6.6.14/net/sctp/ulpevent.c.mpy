{
  "module_name": "ulpevent.c",
  "hash_id": "a5058ec355ad61544de21e5a2cfde52eb2243f55ef1c56e2ff44ce4e2bd43a96",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/ulpevent.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <net/sctp/structs.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\nstatic void sctp_ulpevent_receive_data(struct sctp_ulpevent *event,\n\t\t\t\t       struct sctp_association *asoc);\nstatic void sctp_ulpevent_release_data(struct sctp_ulpevent *event);\nstatic void sctp_ulpevent_release_frag_data(struct sctp_ulpevent *event);\n\n\n \nstatic void sctp_ulpevent_init(struct sctp_ulpevent *event,\n\t\t\t       __u16 msg_flags,\n\t\t\t       unsigned int len)\n{\n\tmemset(event, 0, sizeof(struct sctp_ulpevent));\n\tevent->msg_flags = msg_flags;\n\tevent->rmem_len = len;\n}\n\n \nstatic struct sctp_ulpevent *sctp_ulpevent_new(int size, __u16 msg_flags,\n\t\t\t\t\t       gfp_t gfp)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(size, gfp);\n\tif (!skb)\n\t\tgoto fail;\n\n\tevent = sctp_skb2event(skb);\n\tsctp_ulpevent_init(event, msg_flags, skb->truesize);\n\n\treturn event;\n\nfail:\n\treturn NULL;\n}\n\n \nint sctp_ulpevent_is_notification(const struct sctp_ulpevent *event)\n{\n\treturn MSG_NOTIFICATION == (event->msg_flags & MSG_NOTIFICATION);\n}\n\n \nstatic inline void sctp_ulpevent_set_owner(struct sctp_ulpevent *event,\n\t\t\t\t\t   const struct sctp_association *asoc)\n{\n\tstruct sctp_chunk *chunk = event->chunk;\n\tstruct sk_buff *skb;\n\n\t \n\tsctp_association_hold((struct sctp_association *)asoc);\n\tskb = sctp_event2skb(event);\n\tevent->asoc = (struct sctp_association *)asoc;\n\tatomic_add(event->rmem_len, &event->asoc->rmem_alloc);\n\tsctp_skb_set_owner_r(skb, asoc->base.sk);\n\tif (chunk && chunk->head_skb && !chunk->head_skb->sk)\n\t\tchunk->head_skb->sk = asoc->base.sk;\n}\n\n \nstatic inline void sctp_ulpevent_release_owner(struct sctp_ulpevent *event)\n{\n\tstruct sctp_association *asoc = event->asoc;\n\n\tatomic_sub(event->rmem_len, &asoc->rmem_alloc);\n\tsctp_association_put(asoc);\n}\n\n \nstruct sctp_ulpevent  *sctp_ulpevent_make_assoc_change(\n\tconst struct sctp_association *asoc,\n\t__u16 flags, __u16 state, __u16 error, __u16 outbound,\n\t__u16 inbound, struct sctp_chunk *chunk, gfp_t gfp)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_assoc_change *sac;\n\tstruct sk_buff *skb;\n\n\t \n\tif (chunk) {\n\t\t \n\t\tskb = skb_copy_expand(chunk->skb,\n\t\t\t\t      sizeof(struct sctp_assoc_change), 0, gfp);\n\n\t\tif (!skb)\n\t\t\tgoto fail;\n\n\t\t \n\t\tevent = sctp_skb2event(skb);\n\t\tsctp_ulpevent_init(event, MSG_NOTIFICATION, skb->truesize);\n\n\t\t \n\t\tsac = skb_push(skb, sizeof(struct sctp_assoc_change));\n\n\t\t \n\t\tskb_trim(skb, sizeof(struct sctp_assoc_change) +\n\t\t\t ntohs(chunk->chunk_hdr->length) -\n\t\t\t sizeof(struct sctp_chunkhdr));\n\t} else {\n\t\tevent = sctp_ulpevent_new(sizeof(struct sctp_assoc_change),\n\t\t\t\t  MSG_NOTIFICATION, gfp);\n\t\tif (!event)\n\t\t\tgoto fail;\n\n\t\tskb = sctp_event2skb(event);\n\t\tsac = skb_put(skb, sizeof(struct sctp_assoc_change));\n\t}\n\n\t \n\tsac->sac_type = SCTP_ASSOC_CHANGE;\n\n\t \n\tsac->sac_state = state;\n\n\t \n\tsac->sac_flags = 0;\n\n\t \n\tsac->sac_length = skb->len;\n\n\t \n\tsac->sac_error = error;\n\n\t \n\tsac->sac_outbound_streams = outbound;\n\tsac->sac_inbound_streams = inbound;\n\n\t \n\tsctp_ulpevent_set_owner(event, asoc);\n\tsac->sac_assoc_id = sctp_assoc2id(asoc);\n\n\treturn event;\n\nfail:\n\treturn NULL;\n}\n\n \nstatic struct sctp_ulpevent *sctp_ulpevent_make_peer_addr_change(\n\tconst struct sctp_association *asoc,\n\tconst struct sockaddr_storage *aaddr,\n\tint flags, int state, int error, gfp_t gfp)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_paddr_change  *spc;\n\tstruct sk_buff *skb;\n\n\tevent = sctp_ulpevent_new(sizeof(struct sctp_paddr_change),\n\t\t\t\t  MSG_NOTIFICATION, gfp);\n\tif (!event)\n\t\tgoto fail;\n\n\tskb = sctp_event2skb(event);\n\tspc = skb_put(skb, sizeof(struct sctp_paddr_change));\n\n\t \n\tspc->spc_type = SCTP_PEER_ADDR_CHANGE;\n\n\t \n\tspc->spc_length = sizeof(struct sctp_paddr_change);\n\n\t \n\tspc->spc_flags = 0;\n\n\t \n\tspc->spc_state = state;\n\n\t \n\tspc->spc_error = error;\n\n\t \n\tsctp_ulpevent_set_owner(event, asoc);\n\tspc->spc_assoc_id = sctp_assoc2id(asoc);\n\n\t \n\tmemcpy(&spc->spc_aaddr, aaddr, sizeof(struct sockaddr_storage));\n\n\t \n\tsctp_get_pf_specific(asoc->base.sk->sk_family)->addr_to_user(\n\t\t\t\t\tsctp_sk(asoc->base.sk),\n\t\t\t\t\t(union sctp_addr *)&spc->spc_aaddr);\n\n\treturn event;\n\nfail:\n\treturn NULL;\n}\n\nvoid sctp_ulpevent_notify_peer_addr_change(struct sctp_transport *transport,\n\t\t\t\t\t   int state, int error)\n{\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sockaddr_storage addr;\n\tstruct sctp_ulpevent *event;\n\n\tif (asoc->state < SCTP_STATE_ESTABLISHED)\n\t\treturn;\n\n\tmemset(&addr, 0, sizeof(struct sockaddr_storage));\n\tmemcpy(&addr, &transport->ipaddr, transport->af_specific->sockaddr_len);\n\n\tevent = sctp_ulpevent_make_peer_addr_change(asoc, &addr, 0, state,\n\t\t\t\t\t\t    error, GFP_ATOMIC);\n\tif (event)\n\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, event);\n}\n\n \nstruct sctp_ulpevent *\nsctp_ulpevent_make_remote_error(const struct sctp_association *asoc,\n\t\t\t\tstruct sctp_chunk *chunk, __u16 flags,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct sctp_remote_error *sre;\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_errhdr *ch;\n\tstruct sk_buff *skb;\n\t__be16 cause;\n\tint elen;\n\n\tch = (struct sctp_errhdr *)(chunk->skb->data);\n\tcause = ch->cause;\n\telen = SCTP_PAD4(ntohs(ch->length)) - sizeof(*ch);\n\n\t \n\tskb_pull(chunk->skb, sizeof(*ch));\n\n\t \n\tskb = skb_copy_expand(chunk->skb, sizeof(*sre), 0, gfp);\n\n\t \n\tskb_pull(chunk->skb, elen);\n\tif (!skb)\n\t\tgoto fail;\n\n\t \n\tevent = sctp_skb2event(skb);\n\tsctp_ulpevent_init(event, MSG_NOTIFICATION, skb->truesize);\n\n\tsre = skb_push(skb, sizeof(*sre));\n\n\t \n\tskb_trim(skb, sizeof(*sre) + elen);\n\n\t \n\tmemset(sre, 0, sizeof(*sre));\n\tsre->sre_type = SCTP_REMOTE_ERROR;\n\tsre->sre_flags = 0;\n\tsre->sre_length = skb->len;\n\tsre->sre_error = cause;\n\tsctp_ulpevent_set_owner(event, asoc);\n\tsre->sre_assoc_id = sctp_assoc2id(asoc);\n\n\treturn event;\nfail:\n\treturn NULL;\n}\n\n \nstruct sctp_ulpevent *sctp_ulpevent_make_send_failed(\n\tconst struct sctp_association *asoc, struct sctp_chunk *chunk,\n\t__u16 flags, __u32 error, gfp_t gfp)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_send_failed *ssf;\n\tstruct sk_buff *skb;\n\n\t \n\tint len = ntohs(chunk->chunk_hdr->length);\n\n\t \n\tskb = skb_copy_expand(chunk->skb,\n\t\t\t      sizeof(struct sctp_send_failed),  \n\t\t\t      0,                                \n\t\t\t      gfp);\n\tif (!skb)\n\t\tgoto fail;\n\n\t \n\tskb_pull(skb, sctp_datachk_len(&asoc->stream));\n\tlen -= sctp_datachk_len(&asoc->stream);\n\n\t \n\tevent = sctp_skb2event(skb);\n\tsctp_ulpevent_init(event, MSG_NOTIFICATION, skb->truesize);\n\n\tssf = skb_push(skb, sizeof(struct sctp_send_failed));\n\n\t \n\tssf->ssf_type = SCTP_SEND_FAILED;\n\n\t \n\tssf->ssf_flags = flags;\n\n\t \n\tssf->ssf_length = sizeof(struct sctp_send_failed) + len;\n\tskb_trim(skb, ssf->ssf_length);\n\n\t \n\tssf->ssf_error = error;\n\n\t \n\tmemcpy(&ssf->ssf_info, &chunk->sinfo, sizeof(struct sctp_sndrcvinfo));\n\n\t \n\tssf->ssf_info.sinfo_flags = chunk->chunk_hdr->flags;\n\n\t \n\tsctp_ulpevent_set_owner(event, asoc);\n\tssf->ssf_assoc_id = sctp_assoc2id(asoc);\n\treturn event;\n\nfail:\n\treturn NULL;\n}\n\nstruct sctp_ulpevent *sctp_ulpevent_make_send_failed_event(\n\tconst struct sctp_association *asoc, struct sctp_chunk *chunk,\n\t__u16 flags, __u32 error, gfp_t gfp)\n{\n\tstruct sctp_send_failed_event *ssf;\n\tstruct sctp_ulpevent *event;\n\tstruct sk_buff *skb;\n\tint len;\n\n\tskb = skb_copy_expand(chunk->skb, sizeof(*ssf), 0, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sctp_datachk_len(&asoc->stream);\n\n\tskb_pull(skb, sctp_datachk_len(&asoc->stream));\n\tevent = sctp_skb2event(skb);\n\tsctp_ulpevent_init(event, MSG_NOTIFICATION, skb->truesize);\n\n\tssf = skb_push(skb, sizeof(*ssf));\n\tssf->ssf_type = SCTP_SEND_FAILED_EVENT;\n\tssf->ssf_flags = flags;\n\tssf->ssf_length = sizeof(*ssf) + len;\n\tskb_trim(skb, ssf->ssf_length);\n\tssf->ssf_error = error;\n\n\tssf->ssfe_info.snd_sid = chunk->sinfo.sinfo_stream;\n\tssf->ssfe_info.snd_ppid = chunk->sinfo.sinfo_ppid;\n\tssf->ssfe_info.snd_context = chunk->sinfo.sinfo_context;\n\tssf->ssfe_info.snd_assoc_id = chunk->sinfo.sinfo_assoc_id;\n\tssf->ssfe_info.snd_flags = chunk->chunk_hdr->flags;\n\n\tsctp_ulpevent_set_owner(event, asoc);\n\tssf->ssf_assoc_id = sctp_assoc2id(asoc);\n\n\treturn event;\n}\n\n \nstruct sctp_ulpevent *sctp_ulpevent_make_shutdown_event(\n\tconst struct sctp_association *asoc,\n\t__u16 flags, gfp_t gfp)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_shutdown_event *sse;\n\tstruct sk_buff *skb;\n\n\tevent = sctp_ulpevent_new(sizeof(struct sctp_shutdown_event),\n\t\t\t\t  MSG_NOTIFICATION, gfp);\n\tif (!event)\n\t\tgoto fail;\n\n\tskb = sctp_event2skb(event);\n\tsse = skb_put(skb, sizeof(struct sctp_shutdown_event));\n\n\t \n\tsse->sse_type = SCTP_SHUTDOWN_EVENT;\n\n\t \n\tsse->sse_flags = 0;\n\n\t \n\tsse->sse_length = sizeof(struct sctp_shutdown_event);\n\n\t \n\tsctp_ulpevent_set_owner(event, asoc);\n\tsse->sse_assoc_id = sctp_assoc2id(asoc);\n\n\treturn event;\n\nfail:\n\treturn NULL;\n}\n\n \nstruct sctp_ulpevent *sctp_ulpevent_make_adaptation_indication(\n\tconst struct sctp_association *asoc, gfp_t gfp)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_adaptation_event *sai;\n\tstruct sk_buff *skb;\n\n\tevent = sctp_ulpevent_new(sizeof(struct sctp_adaptation_event),\n\t\t\t\t  MSG_NOTIFICATION, gfp);\n\tif (!event)\n\t\tgoto fail;\n\n\tskb = sctp_event2skb(event);\n\tsai = skb_put(skb, sizeof(struct sctp_adaptation_event));\n\n\tsai->sai_type = SCTP_ADAPTATION_INDICATION;\n\tsai->sai_flags = 0;\n\tsai->sai_length = sizeof(struct sctp_adaptation_event);\n\tsai->sai_adaptation_ind = asoc->peer.adaptation_ind;\n\tsctp_ulpevent_set_owner(event, asoc);\n\tsai->sai_assoc_id = sctp_assoc2id(asoc);\n\n\treturn event;\n\nfail:\n\treturn NULL;\n}\n\n \nstruct sctp_ulpevent *sctp_ulpevent_make_rcvmsg(struct sctp_association *asoc,\n\t\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\t\tgfp_t gfp)\n{\n\tstruct sctp_ulpevent *event = NULL;\n\tstruct sk_buff *skb = chunk->skb;\n\tstruct sock *sk = asoc->base.sk;\n\tsize_t padding, datalen;\n\tint rx_count;\n\n\t \n\tif (asoc->ep->rcvbuf_policy)\n\t\trx_count = atomic_read(&asoc->rmem_alloc);\n\telse\n\t\trx_count = atomic_read(&sk->sk_rmem_alloc);\n\n\tdatalen = ntohs(chunk->chunk_hdr->length);\n\n\tif (rx_count >= sk->sk_rcvbuf || !sk_rmem_schedule(sk, skb, datalen))\n\t\tgoto fail;\n\n\t \n\tskb = skb_clone(chunk->skb, gfp);\n\tif (!skb)\n\t\tgoto fail;\n\n\t \n\tif (sctp_tsnmap_mark(&asoc->peer.tsn_map,\n\t\t\t     ntohl(chunk->subh.data_hdr->tsn),\n\t\t\t     chunk->transport))\n\t\tgoto fail_mark;\n\n\t \n\tpadding = SCTP_PAD4(datalen) - datalen;\n\n\t \n\tskb_trim(skb, chunk->chunk_end - padding - skb->data);\n\n\t \n\tevent = sctp_skb2event(skb);\n\n\t \n\tsctp_ulpevent_init(event, 0, skb->len + sizeof(struct sk_buff));\n\n\t \n\tsctp_chunk_hold(chunk);\n\tevent->chunk = chunk;\n\n\tsctp_ulpevent_receive_data(event, asoc);\n\n\tevent->stream = ntohs(chunk->subh.data_hdr->stream);\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\tevent->flags |= SCTP_UNORDERED;\n\t\tevent->cumtsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map);\n\t}\n\tevent->tsn = ntohl(chunk->subh.data_hdr->tsn);\n\tevent->msg_flags |= chunk->chunk_hdr->flags;\n\n\treturn event;\n\nfail_mark:\n\tkfree_skb(skb);\nfail:\n\treturn NULL;\n}\n\n \nstruct sctp_ulpevent *sctp_ulpevent_make_pdapi(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u32 indication, __u32 sid, __u32 seq,\n\t\t\t\t\t__u32 flags, gfp_t gfp)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_pdapi_event *pd;\n\tstruct sk_buff *skb;\n\n\tevent = sctp_ulpevent_new(sizeof(struct sctp_pdapi_event),\n\t\t\t\t  MSG_NOTIFICATION, gfp);\n\tif (!event)\n\t\tgoto fail;\n\n\tskb = sctp_event2skb(event);\n\tpd = skb_put(skb, sizeof(struct sctp_pdapi_event));\n\n\t \n\tpd->pdapi_type = SCTP_PARTIAL_DELIVERY_EVENT;\n\tpd->pdapi_flags = flags;\n\tpd->pdapi_stream = sid;\n\tpd->pdapi_seq = seq;\n\n\t \n\tpd->pdapi_length = sizeof(struct sctp_pdapi_event);\n\n\t \n\tpd->pdapi_indication = indication;\n\n\t \n\tsctp_ulpevent_set_owner(event, asoc);\n\tpd->pdapi_assoc_id = sctp_assoc2id(asoc);\n\n\treturn event;\nfail:\n\treturn NULL;\n}\n\nstruct sctp_ulpevent *sctp_ulpevent_make_authkey(\n\tconst struct sctp_association *asoc, __u16 key_id,\n\t__u32 indication, gfp_t gfp)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_authkey_event *ak;\n\tstruct sk_buff *skb;\n\n\tevent = sctp_ulpevent_new(sizeof(struct sctp_authkey_event),\n\t\t\t\t  MSG_NOTIFICATION, gfp);\n\tif (!event)\n\t\tgoto fail;\n\n\tskb = sctp_event2skb(event);\n\tak = skb_put(skb, sizeof(struct sctp_authkey_event));\n\n\tak->auth_type = SCTP_AUTHENTICATION_EVENT;\n\tak->auth_flags = 0;\n\tak->auth_length = sizeof(struct sctp_authkey_event);\n\n\tak->auth_keynumber = key_id;\n\tak->auth_altkeynumber = 0;\n\tak->auth_indication = indication;\n\n\t \n\tsctp_ulpevent_set_owner(event, asoc);\n\tak->auth_assoc_id = sctp_assoc2id(asoc);\n\n\treturn event;\nfail:\n\treturn NULL;\n}\n\n \nstruct sctp_ulpevent *sctp_ulpevent_make_sender_dry_event(\n\tconst struct sctp_association *asoc, gfp_t gfp)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_sender_dry_event *sdry;\n\tstruct sk_buff *skb;\n\n\tevent = sctp_ulpevent_new(sizeof(struct sctp_sender_dry_event),\n\t\t\t\t  MSG_NOTIFICATION, gfp);\n\tif (!event)\n\t\treturn NULL;\n\n\tskb = sctp_event2skb(event);\n\tsdry = skb_put(skb, sizeof(struct sctp_sender_dry_event));\n\n\tsdry->sender_dry_type = SCTP_SENDER_DRY_EVENT;\n\tsdry->sender_dry_flags = 0;\n\tsdry->sender_dry_length = sizeof(struct sctp_sender_dry_event);\n\tsctp_ulpevent_set_owner(event, asoc);\n\tsdry->sender_dry_assoc_id = sctp_assoc2id(asoc);\n\n\treturn event;\n}\n\nstruct sctp_ulpevent *sctp_ulpevent_make_stream_reset_event(\n\tconst struct sctp_association *asoc, __u16 flags, __u16 stream_num,\n\t__be16 *stream_list, gfp_t gfp)\n{\n\tstruct sctp_stream_reset_event *sreset;\n\tstruct sctp_ulpevent *event;\n\tstruct sk_buff *skb;\n\tint length, i;\n\n\tlength = sizeof(struct sctp_stream_reset_event) + 2 * stream_num;\n\tevent = sctp_ulpevent_new(length, MSG_NOTIFICATION, gfp);\n\tif (!event)\n\t\treturn NULL;\n\n\tskb = sctp_event2skb(event);\n\tsreset = skb_put(skb, length);\n\n\tsreset->strreset_type = SCTP_STREAM_RESET_EVENT;\n\tsreset->strreset_flags = flags;\n\tsreset->strreset_length = length;\n\tsctp_ulpevent_set_owner(event, asoc);\n\tsreset->strreset_assoc_id = sctp_assoc2id(asoc);\n\n\tfor (i = 0; i < stream_num; i++)\n\t\tsreset->strreset_stream_list[i] = ntohs(stream_list[i]);\n\n\treturn event;\n}\n\nstruct sctp_ulpevent *sctp_ulpevent_make_assoc_reset_event(\n\tconst struct sctp_association *asoc, __u16 flags, __u32 local_tsn,\n\t__u32 remote_tsn, gfp_t gfp)\n{\n\tstruct sctp_assoc_reset_event *areset;\n\tstruct sctp_ulpevent *event;\n\tstruct sk_buff *skb;\n\n\tevent = sctp_ulpevent_new(sizeof(struct sctp_assoc_reset_event),\n\t\t\t\t  MSG_NOTIFICATION, gfp);\n\tif (!event)\n\t\treturn NULL;\n\n\tskb = sctp_event2skb(event);\n\tareset = skb_put(skb, sizeof(struct sctp_assoc_reset_event));\n\n\tareset->assocreset_type = SCTP_ASSOC_RESET_EVENT;\n\tareset->assocreset_flags = flags;\n\tareset->assocreset_length = sizeof(struct sctp_assoc_reset_event);\n\tsctp_ulpevent_set_owner(event, asoc);\n\tareset->assocreset_assoc_id = sctp_assoc2id(asoc);\n\tareset->assocreset_local_tsn = local_tsn;\n\tareset->assocreset_remote_tsn = remote_tsn;\n\n\treturn event;\n}\n\nstruct sctp_ulpevent *sctp_ulpevent_make_stream_change_event(\n\tconst struct sctp_association *asoc, __u16 flags,\n\t__u32 strchange_instrms, __u32 strchange_outstrms, gfp_t gfp)\n{\n\tstruct sctp_stream_change_event *schange;\n\tstruct sctp_ulpevent *event;\n\tstruct sk_buff *skb;\n\n\tevent = sctp_ulpevent_new(sizeof(struct sctp_stream_change_event),\n\t\t\t\t  MSG_NOTIFICATION, gfp);\n\tif (!event)\n\t\treturn NULL;\n\n\tskb = sctp_event2skb(event);\n\tschange = skb_put(skb, sizeof(struct sctp_stream_change_event));\n\n\tschange->strchange_type = SCTP_STREAM_CHANGE_EVENT;\n\tschange->strchange_flags = flags;\n\tschange->strchange_length = sizeof(struct sctp_stream_change_event);\n\tsctp_ulpevent_set_owner(event, asoc);\n\tschange->strchange_assoc_id = sctp_assoc2id(asoc);\n\tschange->strchange_instrms = strchange_instrms;\n\tschange->strchange_outstrms = strchange_outstrms;\n\n\treturn event;\n}\n\n \n__u16 sctp_ulpevent_get_notification_type(const struct sctp_ulpevent *event)\n{\n\tunion sctp_notification *notification;\n\tstruct sk_buff *skb;\n\n\tskb = sctp_event2skb(event);\n\tnotification = (union sctp_notification *) skb->data;\n\treturn notification->sn_header.sn_type;\n}\n\n \nvoid sctp_ulpevent_read_sndrcvinfo(const struct sctp_ulpevent *event,\n\t\t\t\t   struct msghdr *msghdr)\n{\n\tstruct sctp_sndrcvinfo sinfo;\n\n\tif (sctp_ulpevent_is_notification(event))\n\t\treturn;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\tsinfo.sinfo_stream = event->stream;\n\tsinfo.sinfo_ssn = event->ssn;\n\tsinfo.sinfo_ppid = event->ppid;\n\tsinfo.sinfo_flags = event->flags;\n\tsinfo.sinfo_tsn = event->tsn;\n\tsinfo.sinfo_cumtsn = event->cumtsn;\n\tsinfo.sinfo_assoc_id = sctp_assoc2id(event->asoc);\n\t \n\tsinfo.sinfo_context = event->asoc->default_rcv_context;\n\t \n\tsinfo.sinfo_timetolive = 0;\n\n\tput_cmsg(msghdr, IPPROTO_SCTP, SCTP_SNDRCV,\n\t\t sizeof(sinfo), &sinfo);\n}\n\n \nvoid sctp_ulpevent_read_rcvinfo(const struct sctp_ulpevent *event,\n\t\t\t\tstruct msghdr *msghdr)\n{\n\tstruct sctp_rcvinfo rinfo;\n\n\tif (sctp_ulpevent_is_notification(event))\n\t\treturn;\n\n\tmemset(&rinfo, 0, sizeof(struct sctp_rcvinfo));\n\trinfo.rcv_sid = event->stream;\n\trinfo.rcv_ssn = event->ssn;\n\trinfo.rcv_ppid = event->ppid;\n\trinfo.rcv_flags = event->flags;\n\trinfo.rcv_tsn = event->tsn;\n\trinfo.rcv_cumtsn = event->cumtsn;\n\trinfo.rcv_assoc_id = sctp_assoc2id(event->asoc);\n\trinfo.rcv_context = event->asoc->default_rcv_context;\n\n\tput_cmsg(msghdr, IPPROTO_SCTP, SCTP_RCVINFO,\n\t\t sizeof(rinfo), &rinfo);\n}\n\n \nstatic void __sctp_ulpevent_read_nxtinfo(const struct sctp_ulpevent *event,\n\t\t\t\t\t struct msghdr *msghdr,\n\t\t\t\t\t const struct sk_buff *skb)\n{\n\tstruct sctp_nxtinfo nxtinfo;\n\n\tmemset(&nxtinfo, 0, sizeof(nxtinfo));\n\tnxtinfo.nxt_sid = event->stream;\n\tnxtinfo.nxt_ppid = event->ppid;\n\tnxtinfo.nxt_flags = event->flags;\n\tif (sctp_ulpevent_is_notification(event))\n\t\tnxtinfo.nxt_flags |= SCTP_NOTIFICATION;\n\tnxtinfo.nxt_length = skb->len;\n\tnxtinfo.nxt_assoc_id = sctp_assoc2id(event->asoc);\n\n\tput_cmsg(msghdr, IPPROTO_SCTP, SCTP_NXTINFO,\n\t\t sizeof(nxtinfo), &nxtinfo);\n}\n\nvoid sctp_ulpevent_read_nxtinfo(const struct sctp_ulpevent *event,\n\t\t\t\tstruct msghdr *msghdr,\n\t\t\t\tstruct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = sctp_skb_recv_datagram(sk, MSG_PEEK | MSG_DONTWAIT, &err);\n\tif (skb != NULL) {\n\t\t__sctp_ulpevent_read_nxtinfo(sctp_skb2event(skb),\n\t\t\t\t\t     msghdr, skb);\n\t\t \n\t\tkfree_skb(skb);\n\t}\n}\n\n \nstatic void sctp_ulpevent_receive_data(struct sctp_ulpevent *event,\n\t\t\t\t       struct sctp_association *asoc)\n{\n\tstruct sk_buff *skb, *frag;\n\n\tskb = sctp_event2skb(event);\n\t \n\tsctp_ulpevent_set_owner(event, asoc);\n\tsctp_assoc_rwnd_decrease(asoc, skb_headlen(skb));\n\n\tif (!skb->data_len)\n\t\treturn;\n\n\t \n\tskb_walk_frags(skb, frag)\n\t\tsctp_ulpevent_receive_data(sctp_skb2event(frag), asoc);\n}\n\n \nstatic void sctp_ulpevent_release_data(struct sctp_ulpevent *event)\n{\n\tstruct sk_buff *skb, *frag;\n\tunsigned int\tlen;\n\n\t \n\n\tskb = sctp_event2skb(event);\n\tlen = skb->len;\n\n\tif (!skb->data_len)\n\t\tgoto done;\n\n\t \n\tskb_walk_frags(skb, frag) {\n\t\t \n\t\tsctp_ulpevent_release_frag_data(sctp_skb2event(frag));\n\t}\n\ndone:\n\tsctp_assoc_rwnd_increase(event->asoc, len);\n\tsctp_chunk_put(event->chunk);\n\tsctp_ulpevent_release_owner(event);\n}\n\nstatic void sctp_ulpevent_release_frag_data(struct sctp_ulpevent *event)\n{\n\tstruct sk_buff *skb, *frag;\n\n\tskb = sctp_event2skb(event);\n\n\tif (!skb->data_len)\n\t\tgoto done;\n\n\t \n\tskb_walk_frags(skb, frag) {\n\t\t \n\t\tsctp_ulpevent_release_frag_data(sctp_skb2event(frag));\n\t}\n\ndone:\n\tsctp_chunk_put(event->chunk);\n\tsctp_ulpevent_release_owner(event);\n}\n\n \nvoid sctp_ulpevent_free(struct sctp_ulpevent *event)\n{\n\tif (sctp_ulpevent_is_notification(event))\n\t\tsctp_ulpevent_release_owner(event);\n\telse\n\t\tsctp_ulpevent_release_data(event);\n\n\tkfree_skb(sctp_event2skb(event));\n}\n\n \nunsigned int sctp_queue_purge_ulpevents(struct sk_buff_head *list)\n{\n\tstruct sk_buff *skb;\n\tunsigned int data_unread = 0;\n\n\twhile ((skb = skb_dequeue(list)) != NULL) {\n\t\tstruct sctp_ulpevent *event = sctp_skb2event(skb);\n\n\t\tif (!sctp_ulpevent_is_notification(event))\n\t\t\tdata_unread += skb->len;\n\n\t\tsctp_ulpevent_free(event);\n\t}\n\n\treturn data_unread;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}