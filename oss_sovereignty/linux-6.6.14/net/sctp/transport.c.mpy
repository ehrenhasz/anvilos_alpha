{
  "module_name": "transport.c",
  "hash_id": "34c81bd70dec85553af310f7d221fd6d6c2be160892e4812f869173fc4458172",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/transport.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/random.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\n \n\n \nstatic struct sctp_transport *sctp_transport_init(struct net *net,\n\t\t\t\t\t\t  struct sctp_transport *peer,\n\t\t\t\t\t\t  const union sctp_addr *addr,\n\t\t\t\t\t\t  gfp_t gfp)\n{\n\t \n\tpeer->af_specific = sctp_get_af_specific(addr->sa.sa_family);\n\tmemcpy(&peer->ipaddr, addr, peer->af_specific->sockaddr_len);\n\tmemset(&peer->saddr, 0, sizeof(union sctp_addr));\n\n\tpeer->sack_generation = 0;\n\n\t \n\tpeer->rto = msecs_to_jiffies(net->sctp.rto_initial);\n\n\tpeer->last_time_heard = 0;\n\tpeer->last_time_ecne_reduced = jiffies;\n\n\tpeer->param_flags = SPP_HB_DISABLE |\n\t\t\t    SPP_PMTUD_ENABLE |\n\t\t\t    SPP_SACKDELAY_ENABLE;\n\n\t \n\tpeer->pathmaxrxt  = net->sctp.max_retrans_path;\n\tpeer->pf_retrans  = net->sctp.pf_retrans;\n\n\tINIT_LIST_HEAD(&peer->transmitted);\n\tINIT_LIST_HEAD(&peer->send_ready);\n\tINIT_LIST_HEAD(&peer->transports);\n\n\ttimer_setup(&peer->T3_rtx_timer, sctp_generate_t3_rtx_event, 0);\n\ttimer_setup(&peer->hb_timer, sctp_generate_heartbeat_event, 0);\n\ttimer_setup(&peer->reconf_timer, sctp_generate_reconf_event, 0);\n\ttimer_setup(&peer->probe_timer, sctp_generate_probe_event, 0);\n\ttimer_setup(&peer->proto_unreach_timer,\n\t\t    sctp_generate_proto_unreach_event, 0);\n\n\t \n\tget_random_bytes(&peer->hb_nonce, sizeof(peer->hb_nonce));\n\n\trefcount_set(&peer->refcnt, 1);\n\n\treturn peer;\n}\n\n \nstruct sctp_transport *sctp_transport_new(struct net *net,\n\t\t\t\t\t  const union sctp_addr *addr,\n\t\t\t\t\t  gfp_t gfp)\n{\n\tstruct sctp_transport *transport;\n\n\ttransport = kzalloc(sizeof(*transport), gfp);\n\tif (!transport)\n\t\tgoto fail;\n\n\tif (!sctp_transport_init(net, transport, addr, gfp))\n\t\tgoto fail_init;\n\n\tSCTP_DBG_OBJCNT_INC(transport);\n\n\treturn transport;\n\nfail_init:\n\tkfree(transport);\n\nfail:\n\treturn NULL;\n}\n\n \nvoid sctp_transport_free(struct sctp_transport *transport)\n{\n\t \n\tif (del_timer(&transport->hb_timer))\n\t\tsctp_transport_put(transport);\n\n\t \n\tif (del_timer(&transport->T3_rtx_timer))\n\t\tsctp_transport_put(transport);\n\n\tif (del_timer(&transport->reconf_timer))\n\t\tsctp_transport_put(transport);\n\n\tif (del_timer(&transport->probe_timer))\n\t\tsctp_transport_put(transport);\n\n\t \n\tif (del_timer(&transport->proto_unreach_timer))\n\t\tsctp_transport_put(transport);\n\n\tsctp_transport_put(transport);\n}\n\nstatic void sctp_transport_destroy_rcu(struct rcu_head *head)\n{\n\tstruct sctp_transport *transport;\n\n\ttransport = container_of(head, struct sctp_transport, rcu);\n\n\tdst_release(transport->dst);\n\tkfree(transport);\n\tSCTP_DBG_OBJCNT_DEC(transport);\n}\n\n \nstatic void sctp_transport_destroy(struct sctp_transport *transport)\n{\n\tif (unlikely(refcount_read(&transport->refcnt))) {\n\t\tWARN(1, \"Attempt to destroy undead transport %p!\\n\", transport);\n\t\treturn;\n\t}\n\n\tsctp_packet_free(&transport->packet);\n\n\tif (transport->asoc)\n\t\tsctp_association_put(transport->asoc);\n\n\tcall_rcu(&transport->rcu, sctp_transport_destroy_rcu);\n}\n\n \nvoid sctp_transport_reset_t3_rtx(struct sctp_transport *transport)\n{\n\t \n\n\tif (!timer_pending(&transport->T3_rtx_timer))\n\t\tif (!mod_timer(&transport->T3_rtx_timer,\n\t\t\t       jiffies + transport->rto))\n\t\t\tsctp_transport_hold(transport);\n}\n\nvoid sctp_transport_reset_hb_timer(struct sctp_transport *transport)\n{\n\tunsigned long expires;\n\n\t \n\texpires = jiffies + sctp_transport_timeout(transport);\n\tif (!mod_timer(&transport->hb_timer,\n\t\t       expires + get_random_u32_below(transport->rto)))\n\t\tsctp_transport_hold(transport);\n}\n\nvoid sctp_transport_reset_reconf_timer(struct sctp_transport *transport)\n{\n\tif (!timer_pending(&transport->reconf_timer))\n\t\tif (!mod_timer(&transport->reconf_timer,\n\t\t\t       jiffies + transport->rto))\n\t\t\tsctp_transport_hold(transport);\n}\n\nvoid sctp_transport_reset_probe_timer(struct sctp_transport *transport)\n{\n\tif (!mod_timer(&transport->probe_timer,\n\t\t       jiffies + transport->probe_interval))\n\t\tsctp_transport_hold(transport);\n}\n\nvoid sctp_transport_reset_raise_timer(struct sctp_transport *transport)\n{\n\tif (!mod_timer(&transport->probe_timer,\n\t\t       jiffies + transport->probe_interval * 30))\n\t\tsctp_transport_hold(transport);\n}\n\n \nvoid sctp_transport_set_owner(struct sctp_transport *transport,\n\t\t\t      struct sctp_association *asoc)\n{\n\ttransport->asoc = asoc;\n\tsctp_association_hold(asoc);\n}\n\n \nvoid sctp_transport_pmtu(struct sctp_transport *transport, struct sock *sk)\n{\n\t \n\tif (!transport->dst || transport->dst->obsolete) {\n\t\tsctp_transport_dst_release(transport);\n\t\ttransport->af_specific->get_dst(transport, &transport->saddr,\n\t\t\t\t\t\t&transport->fl, sk);\n\t}\n\n\tif (transport->param_flags & SPP_PMTUD_DISABLE) {\n\t\tstruct sctp_association *asoc = transport->asoc;\n\n\t\tif (!transport->pathmtu && asoc && asoc->pathmtu)\n\t\t\ttransport->pathmtu = asoc->pathmtu;\n\t\tif (transport->pathmtu)\n\t\t\treturn;\n\t}\n\n\tif (transport->dst)\n\t\ttransport->pathmtu = sctp_dst_mtu(transport->dst);\n\telse\n\t\ttransport->pathmtu = SCTP_DEFAULT_MAXSEGMENT;\n\n\tsctp_transport_pl_update(transport);\n}\n\nvoid sctp_transport_pl_send(struct sctp_transport *t)\n{\n\tif (t->pl.probe_count < SCTP_MAX_PROBES)\n\t\tgoto out;\n\n\tt->pl.probe_count = 0;\n\tif (t->pl.state == SCTP_PL_BASE) {\n\t\tif (t->pl.probe_size == SCTP_BASE_PLPMTU) {  \n\t\t\tt->pl.state = SCTP_PL_ERROR;  \n\n\t\t\tt->pl.pmtu = SCTP_BASE_PLPMTU;\n\t\t\tt->pathmtu = t->pl.pmtu + sctp_transport_pl_hlen(t);\n\t\t\tsctp_assoc_sync_pmtu(t->asoc);\n\t\t}\n\t} else if (t->pl.state == SCTP_PL_SEARCH) {\n\t\tif (t->pl.pmtu == t->pl.probe_size) {  \n\t\t\tt->pl.state = SCTP_PL_BASE;   \n\t\t\tt->pl.probe_size = SCTP_BASE_PLPMTU;\n\t\t\tt->pl.probe_high = 0;\n\n\t\t\tt->pl.pmtu = SCTP_BASE_PLPMTU;\n\t\t\tt->pathmtu = t->pl.pmtu + sctp_transport_pl_hlen(t);\n\t\t\tsctp_assoc_sync_pmtu(t->asoc);\n\t\t} else {  \n\t\t\tt->pl.probe_high = t->pl.probe_size;\n\t\t\tt->pl.probe_size = t->pl.pmtu;\n\t\t}\n\t} else if (t->pl.state == SCTP_PL_COMPLETE) {\n\t\tif (t->pl.pmtu == t->pl.probe_size) {  \n\t\t\tt->pl.state = SCTP_PL_BASE;   \n\t\t\tt->pl.probe_size = SCTP_BASE_PLPMTU;\n\n\t\t\tt->pl.pmtu = SCTP_BASE_PLPMTU;\n\t\t\tt->pathmtu = t->pl.pmtu + sctp_transport_pl_hlen(t);\n\t\t\tsctp_assoc_sync_pmtu(t->asoc);\n\t\t}\n\t}\n\nout:\n\tpr_debug(\"%s: PLPMTUD: transport: %p, state: %d, pmtu: %d, size: %d, high: %d\\n\",\n\t\t __func__, t, t->pl.state, t->pl.pmtu, t->pl.probe_size, t->pl.probe_high);\n\tt->pl.probe_count++;\n}\n\nbool sctp_transport_pl_recv(struct sctp_transport *t)\n{\n\tpr_debug(\"%s: PLPMTUD: transport: %p, state: %d, pmtu: %d, size: %d, high: %d\\n\",\n\t\t __func__, t, t->pl.state, t->pl.pmtu, t->pl.probe_size, t->pl.probe_high);\n\n\tt->pl.pmtu = t->pl.probe_size;\n\tt->pl.probe_count = 0;\n\tif (t->pl.state == SCTP_PL_BASE) {\n\t\tt->pl.state = SCTP_PL_SEARCH;  \n\t\tt->pl.probe_size += SCTP_PL_BIG_STEP;\n\t} else if (t->pl.state == SCTP_PL_ERROR) {\n\t\tt->pl.state = SCTP_PL_SEARCH;  \n\n\t\tt->pl.pmtu = t->pl.probe_size;\n\t\tt->pathmtu = t->pl.pmtu + sctp_transport_pl_hlen(t);\n\t\tsctp_assoc_sync_pmtu(t->asoc);\n\t\tt->pl.probe_size += SCTP_PL_BIG_STEP;\n\t} else if (t->pl.state == SCTP_PL_SEARCH) {\n\t\tif (!t->pl.probe_high) {\n\t\t\tif (t->pl.probe_size < SCTP_MAX_PLPMTU) {\n\t\t\t\tt->pl.probe_size = min(t->pl.probe_size + SCTP_PL_BIG_STEP,\n\t\t\t\t\t\t       SCTP_MAX_PLPMTU);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tt->pl.probe_high = SCTP_MAX_PLPMTU;\n\t\t}\n\t\tt->pl.probe_size += SCTP_PL_MIN_STEP;\n\t\tif (t->pl.probe_size >= t->pl.probe_high) {\n\t\t\tt->pl.probe_high = 0;\n\t\t\tt->pl.state = SCTP_PL_COMPLETE;  \n\n\t\t\tt->pl.probe_size = t->pl.pmtu;\n\t\t\tt->pathmtu = t->pl.pmtu + sctp_transport_pl_hlen(t);\n\t\t\tsctp_assoc_sync_pmtu(t->asoc);\n\t\t\tsctp_transport_reset_raise_timer(t);\n\t\t}\n\t} else if (t->pl.state == SCTP_PL_COMPLETE) {\n\t\t \n\t\tt->pl.state = SCTP_PL_SEARCH;  \n\t\tt->pl.probe_size = min(t->pl.probe_size + SCTP_PL_MIN_STEP, SCTP_MAX_PLPMTU);\n\t}\n\n\treturn t->pl.state == SCTP_PL_COMPLETE;\n}\n\nstatic bool sctp_transport_pl_toobig(struct sctp_transport *t, u32 pmtu)\n{\n\tpr_debug(\"%s: PLPMTUD: transport: %p, state: %d, pmtu: %d, size: %d, ptb: %d\\n\",\n\t\t __func__, t, t->pl.state, t->pl.pmtu, t->pl.probe_size, pmtu);\n\n\tif (pmtu < SCTP_MIN_PLPMTU || pmtu >= t->pl.probe_size)\n\t\treturn false;\n\n\tif (t->pl.state == SCTP_PL_BASE) {\n\t\tif (pmtu >= SCTP_MIN_PLPMTU && pmtu < SCTP_BASE_PLPMTU) {\n\t\t\tt->pl.state = SCTP_PL_ERROR;  \n\n\t\t\tt->pl.pmtu = SCTP_BASE_PLPMTU;\n\t\t\tt->pathmtu = t->pl.pmtu + sctp_transport_pl_hlen(t);\n\t\t\treturn true;\n\t\t}\n\t} else if (t->pl.state == SCTP_PL_SEARCH) {\n\t\tif (pmtu >= SCTP_BASE_PLPMTU && pmtu < t->pl.pmtu) {\n\t\t\tt->pl.state = SCTP_PL_BASE;   \n\t\t\tt->pl.probe_size = SCTP_BASE_PLPMTU;\n\t\t\tt->pl.probe_count = 0;\n\n\t\t\tt->pl.probe_high = 0;\n\t\t\tt->pl.pmtu = SCTP_BASE_PLPMTU;\n\t\t\tt->pathmtu = t->pl.pmtu + sctp_transport_pl_hlen(t);\n\t\t\treturn true;\n\t\t} else if (pmtu > t->pl.pmtu && pmtu < t->pl.probe_size) {\n\t\t\tt->pl.probe_size = pmtu;\n\t\t\tt->pl.probe_count = 0;\n\t\t}\n\t} else if (t->pl.state == SCTP_PL_COMPLETE) {\n\t\tif (pmtu >= SCTP_BASE_PLPMTU && pmtu < t->pl.pmtu) {\n\t\t\tt->pl.state = SCTP_PL_BASE;   \n\t\t\tt->pl.probe_size = SCTP_BASE_PLPMTU;\n\t\t\tt->pl.probe_count = 0;\n\n\t\t\tt->pl.probe_high = 0;\n\t\t\tt->pl.pmtu = SCTP_BASE_PLPMTU;\n\t\t\tt->pathmtu = t->pl.pmtu + sctp_transport_pl_hlen(t);\n\t\t\tsctp_transport_reset_probe_timer(t);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool sctp_transport_update_pmtu(struct sctp_transport *t, u32 pmtu)\n{\n\tstruct sock *sk = t->asoc->base.sk;\n\tstruct dst_entry *dst;\n\tbool change = true;\n\n\tif (unlikely(pmtu < SCTP_DEFAULT_MINSEGMENT)) {\n\t\tpr_warn_ratelimited(\"%s: Reported pmtu %d too low, using default minimum of %d\\n\",\n\t\t\t\t    __func__, pmtu, SCTP_DEFAULT_MINSEGMENT);\n\t\t \n\t\tpmtu = SCTP_DEFAULT_MINSEGMENT;\n\t}\n\tpmtu = SCTP_TRUNC4(pmtu);\n\n\tif (sctp_transport_pl_enabled(t))\n\t\treturn sctp_transport_pl_toobig(t, pmtu - sctp_transport_pl_hlen(t));\n\n\tdst = sctp_transport_dst_check(t);\n\tif (dst) {\n\t\tstruct sctp_pf *pf = sctp_get_pf_specific(dst->ops->family);\n\t\tunion sctp_addr addr;\n\n\t\tpf->af->from_sk(&addr, sk);\n\t\tpf->to_sk_daddr(&t->ipaddr, sk);\n\t\tdst->ops->update_pmtu(dst, sk, NULL, pmtu, true);\n\t\tpf->to_sk_daddr(&addr, sk);\n\n\t\tdst = sctp_transport_dst_check(t);\n\t}\n\n\tif (!dst) {\n\t\tt->af_specific->get_dst(t, &t->saddr, &t->fl, sk);\n\t\tdst = t->dst;\n\t}\n\n\tif (dst) {\n\t\t \n\t\tpmtu = sctp_dst_mtu(dst);\n\t\tchange = t->pathmtu != pmtu;\n\t}\n\tt->pathmtu = pmtu;\n\n\treturn change;\n}\n\n \nvoid sctp_transport_route(struct sctp_transport *transport,\n\t\t\t  union sctp_addr *saddr, struct sctp_sock *opt)\n{\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sctp_af *af = transport->af_specific;\n\n\tsctp_transport_dst_release(transport);\n\taf->get_dst(transport, saddr, &transport->fl, sctp_opt2sk(opt));\n\n\tif (saddr)\n\t\tmemcpy(&transport->saddr, saddr, sizeof(union sctp_addr));\n\telse\n\t\taf->get_saddr(opt, transport, &transport->fl);\n\n\tsctp_transport_pmtu(transport, sctp_opt2sk(opt));\n\n\t \n\tif (transport->dst && asoc &&\n\t    (!asoc->peer.primary_path || transport == asoc->peer.active_path))\n\t\topt->pf->to_sk_saddr(&transport->saddr, asoc->base.sk);\n}\n\n \nint sctp_transport_hold(struct sctp_transport *transport)\n{\n\treturn refcount_inc_not_zero(&transport->refcnt);\n}\n\n \nvoid sctp_transport_put(struct sctp_transport *transport)\n{\n\tif (refcount_dec_and_test(&transport->refcnt))\n\t\tsctp_transport_destroy(transport);\n}\n\n \nvoid sctp_transport_update_rto(struct sctp_transport *tp, __u32 rtt)\n{\n\tif (unlikely(!tp->rto_pending))\n\t\t \n\t\tpr_debug(\"%s: rto_pending not set on transport %p!\\n\", __func__, tp);\n\n\tif (tp->rttvar || tp->srtt) {\n\t\tstruct net *net = tp->asoc->base.net;\n\t\t \n\n\t\t \n\t\ttp->rttvar = tp->rttvar - (tp->rttvar >> net->sctp.rto_beta)\n\t\t\t+ (((__u32)abs((__s64)tp->srtt - (__s64)rtt)) >> net->sctp.rto_beta);\n\t\ttp->srtt = tp->srtt - (tp->srtt >> net->sctp.rto_alpha)\n\t\t\t+ (rtt >> net->sctp.rto_alpha);\n\t} else {\n\t\t \n\t\ttp->srtt = rtt;\n\t\ttp->rttvar = rtt >> 1;\n\t}\n\n\t \n\tif (tp->rttvar == 0)\n\t\ttp->rttvar = SCTP_CLOCK_GRANULARITY;\n\n\t \n\ttp->rto = tp->srtt + (tp->rttvar << 2);\n\n\t \n\tif (tp->rto < tp->asoc->rto_min)\n\t\ttp->rto = tp->asoc->rto_min;\n\n\t \n\tif (tp->rto > tp->asoc->rto_max)\n\t\ttp->rto = tp->asoc->rto_max;\n\n\tsctp_max_rto(tp->asoc, tp);\n\ttp->rtt = rtt;\n\n\t \n\ttp->rto_pending = 0;\n\n\tpr_debug(\"%s: transport:%p, rtt:%d, srtt:%d rttvar:%d, rto:%ld\\n\",\n\t\t __func__, tp, rtt, tp->srtt, tp->rttvar, tp->rto);\n}\n\n \nvoid sctp_transport_raise_cwnd(struct sctp_transport *transport,\n\t\t\t       __u32 sack_ctsn, __u32 bytes_acked)\n{\n\tstruct sctp_association *asoc = transport->asoc;\n\t__u32 cwnd, ssthresh, flight_size, pba, pmtu;\n\n\tcwnd = transport->cwnd;\n\tflight_size = transport->flight_size;\n\n\t \n\tif (asoc->fast_recovery &&\n\t    TSN_lte(asoc->fast_recovery_exit, sack_ctsn))\n\t\tasoc->fast_recovery = 0;\n\n\tssthresh = transport->ssthresh;\n\tpba = transport->partial_bytes_acked;\n\tpmtu = transport->asoc->pathmtu;\n\n\tif (cwnd <= ssthresh) {\n\t\t \n\t\tif (asoc->fast_recovery)\n\t\t\treturn;\n\n\t\t \n\t\tif (flight_size < cwnd)\n\t\t\treturn;\n\n\t\tif (bytes_acked > pmtu)\n\t\t\tcwnd += pmtu;\n\t\telse\n\t\t\tcwnd += bytes_acked;\n\n\t\tpr_debug(\"%s: slow start: transport:%p, bytes_acked:%d, \"\n\t\t\t \"cwnd:%d, ssthresh:%d, flight_size:%d, pba:%d\\n\",\n\t\t\t __func__, transport, bytes_acked, cwnd, ssthresh,\n\t\t\t flight_size, pba);\n\t} else {\n\t\t \n\t\tpba += bytes_acked;\n\t\tif (pba > cwnd && flight_size < cwnd)\n\t\t\tpba = cwnd;\n\t\tif (pba >= cwnd && flight_size >= cwnd) {\n\t\t\tpba = pba - cwnd;\n\t\t\tcwnd += pmtu;\n\t\t}\n\n\t\tpr_debug(\"%s: congestion avoidance: transport:%p, \"\n\t\t\t \"bytes_acked:%d, cwnd:%d, ssthresh:%d, \"\n\t\t\t \"flight_size:%d, pba:%d\\n\", __func__,\n\t\t\t transport, bytes_acked, cwnd, ssthresh,\n\t\t\t flight_size, pba);\n\t}\n\n\ttransport->cwnd = cwnd;\n\ttransport->partial_bytes_acked = pba;\n}\n\n \nvoid sctp_transport_lower_cwnd(struct sctp_transport *transport,\n\t\t\t       enum sctp_lower_cwnd reason)\n{\n\tstruct sctp_association *asoc = transport->asoc;\n\n\tswitch (reason) {\n\tcase SCTP_LOWER_CWND_T3_RTX:\n\t\t \n\t\ttransport->ssthresh = max(transport->cwnd/2,\n\t\t\t\t\t  4*asoc->pathmtu);\n\t\ttransport->cwnd = asoc->pathmtu;\n\n\t\t \n\t\tasoc->fast_recovery = 0;\n\t\tbreak;\n\n\tcase SCTP_LOWER_CWND_FAST_RTX:\n\t\t \n\t\tif (asoc->fast_recovery)\n\t\t\treturn;\n\n\t\t \n\t\tasoc->fast_recovery = 1;\n\t\tasoc->fast_recovery_exit = asoc->next_tsn - 1;\n\n\t\ttransport->ssthresh = max(transport->cwnd/2,\n\t\t\t\t\t  4*asoc->pathmtu);\n\t\ttransport->cwnd = transport->ssthresh;\n\t\tbreak;\n\n\tcase SCTP_LOWER_CWND_ECNE:\n\t\t \n\t\tif (time_after(jiffies, transport->last_time_ecne_reduced +\n\t\t\t\t\ttransport->rtt)) {\n\t\t\ttransport->ssthresh = max(transport->cwnd/2,\n\t\t\t\t\t\t  4*asoc->pathmtu);\n\t\t\ttransport->cwnd = transport->ssthresh;\n\t\t\ttransport->last_time_ecne_reduced = jiffies;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_LOWER_CWND_INACTIVE:\n\t\t \n\t\ttransport->cwnd = max(transport->cwnd/2,\n\t\t\t\t\t 4*asoc->pathmtu);\n\t\t \n\t\ttransport->ssthresh = transport->cwnd;\n\t\tbreak;\n\t}\n\n\ttransport->partial_bytes_acked = 0;\n\n\tpr_debug(\"%s: transport:%p, reason:%d, cwnd:%d, ssthresh:%d\\n\",\n\t\t __func__, transport, reason, transport->cwnd,\n\t\t transport->ssthresh);\n}\n\n \n\nvoid sctp_transport_burst_limited(struct sctp_transport *t)\n{\n\tstruct sctp_association *asoc = t->asoc;\n\tu32 old_cwnd = t->cwnd;\n\tu32 max_burst_bytes;\n\n\tif (t->burst_limited || asoc->max_burst == 0)\n\t\treturn;\n\n\tmax_burst_bytes = t->flight_size + (asoc->max_burst * asoc->pathmtu);\n\tif (max_burst_bytes < old_cwnd) {\n\t\tt->cwnd = max_burst_bytes;\n\t\tt->burst_limited = old_cwnd;\n\t}\n}\n\n \nvoid sctp_transport_burst_reset(struct sctp_transport *t)\n{\n\tif (t->burst_limited) {\n\t\tt->cwnd = t->burst_limited;\n\t\tt->burst_limited = 0;\n\t}\n}\n\n \nunsigned long sctp_transport_timeout(struct sctp_transport *trans)\n{\n\t \n\tunsigned long timeout = trans->rto >> 1;\n\n\tif (trans->state != SCTP_UNCONFIRMED &&\n\t    trans->state != SCTP_PF)\n\t\ttimeout += trans->hbinterval;\n\n\treturn max_t(unsigned long, timeout, HZ / 5);\n}\n\n \nvoid sctp_transport_reset(struct sctp_transport *t)\n{\n\tstruct sctp_association *asoc = t->asoc;\n\n\t \n\tt->cwnd = min(4*asoc->pathmtu, max_t(__u32, 2*asoc->pathmtu, 4380));\n\tt->burst_limited = 0;\n\tt->ssthresh = asoc->peer.i.a_rwnd;\n\tt->rto = asoc->rto_initial;\n\tsctp_max_rto(asoc, t);\n\tt->rtt = 0;\n\tt->srtt = 0;\n\tt->rttvar = 0;\n\n\t \n\tt->partial_bytes_acked = 0;\n\tt->flight_size = 0;\n\tt->error_count = 0;\n\tt->rto_pending = 0;\n\tt->hb_sent = 0;\n\n\t \n\tt->cacc.changeover_active = 0;\n\tt->cacc.cycling_changeover = 0;\n\tt->cacc.next_tsn_at_change = 0;\n\tt->cacc.cacc_saw_newack = 0;\n}\n\n \nvoid sctp_transport_immediate_rtx(struct sctp_transport *t)\n{\n\t \n\tif (del_timer(&t->T3_rtx_timer))\n\t\tsctp_transport_put(t);\n\n\tsctp_retransmit(&t->asoc->outqueue, t, SCTP_RTXR_T3_RTX);\n\tif (!timer_pending(&t->T3_rtx_timer)) {\n\t\tif (!mod_timer(&t->T3_rtx_timer, jiffies + t->rto))\n\t\t\tsctp_transport_hold(t);\n\t}\n}\n\n \nvoid sctp_transport_dst_release(struct sctp_transport *t)\n{\n\tdst_release(t->dst);\n\tt->dst = NULL;\n\tt->dst_pending_confirm = 0;\n}\n\n \nvoid sctp_transport_dst_confirm(struct sctp_transport *t)\n{\n\tt->dst_pending_confirm = 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}