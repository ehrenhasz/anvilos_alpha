{
  "module_name": "stream_sched_prio.c",
  "hash_id": "6b992dab0ea4148ca6386aaa98dc59299fd60199a5e8075a9762b98616350e6d",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/stream_sched_prio.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/stream_sched.h>\n\n \n\nstatic void sctp_sched_prio_unsched_all(struct sctp_stream *stream);\n\nstatic struct sctp_stream_priorities *sctp_sched_prio_head_get(struct sctp_stream_priorities *p)\n{\n\tp->users++;\n\treturn p;\n}\n\nstatic void sctp_sched_prio_head_put(struct sctp_stream_priorities *p)\n{\n\tif (p && --p->users == 0)\n\t\tkfree(p);\n}\n\nstatic struct sctp_stream_priorities *sctp_sched_prio_new_head(\n\t\t\tstruct sctp_stream *stream, int prio, gfp_t gfp)\n{\n\tstruct sctp_stream_priorities *p;\n\n\tp = kmalloc(sizeof(*p), gfp);\n\tif (!p)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&p->prio_sched);\n\tINIT_LIST_HEAD(&p->active);\n\tp->next = NULL;\n\tp->prio = prio;\n\tp->users = 1;\n\n\treturn p;\n}\n\nstatic struct sctp_stream_priorities *sctp_sched_prio_get_head(\n\t\t\tstruct sctp_stream *stream, int prio, gfp_t gfp)\n{\n\tstruct sctp_stream_priorities *p;\n\tint i;\n\n\t \n\tlist_for_each_entry(p, &stream->prio_list, prio_sched) {\n\t\tif (p->prio == prio)\n\t\t\treturn sctp_sched_prio_head_get(p);\n\t\tif (p->prio > prio)\n\t\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0; i < stream->outcnt; i++) {\n\t\tif (!SCTP_SO(stream, i)->ext)\n\t\t\tcontinue;\n\n\t\tp = SCTP_SO(stream, i)->ext->prio_head;\n\t\tif (!p)\n\t\t\t \n\t\t\tbreak;\n\t\tif (p->prio == prio)\n\t\t\treturn sctp_sched_prio_head_get(p);\n\t}\n\n\t \n\treturn sctp_sched_prio_new_head(stream, prio, gfp);\n}\n\nstatic void sctp_sched_prio_next_stream(struct sctp_stream_priorities *p)\n{\n\tstruct list_head *pos;\n\n\tpos = p->next->prio_list.next;\n\tif (pos == &p->active)\n\t\tpos = pos->next;\n\tp->next = list_entry(pos, struct sctp_stream_out_ext, prio_list);\n}\n\nstatic bool sctp_sched_prio_unsched(struct sctp_stream_out_ext *soute)\n{\n\tbool scheduled = false;\n\n\tif (!list_empty(&soute->prio_list)) {\n\t\tstruct sctp_stream_priorities *prio_head = soute->prio_head;\n\n\t\t \n\t\tscheduled = true;\n\n\t\tif (prio_head->next == soute)\n\t\t\t \n\t\t\tsctp_sched_prio_next_stream(prio_head);\n\n\t\tlist_del_init(&soute->prio_list);\n\n\t\t \n\t\tif (list_empty(&prio_head->active)) {\n\t\t\tlist_del_init(&prio_head->prio_sched);\n\t\t\t \n\t\t\tprio_head->next = NULL;\n\t\t}\n\t}\n\n\treturn scheduled;\n}\n\nstatic void sctp_sched_prio_sched(struct sctp_stream *stream,\n\t\t\t\t  struct sctp_stream_out_ext *soute)\n{\n\tstruct sctp_stream_priorities *prio, *prio_head;\n\n\tprio_head = soute->prio_head;\n\n\t \n\tif (!list_empty(&soute->prio_list))\n\t\treturn;\n\n\t \n\tif (prio_head->next) {\n\t\tlist_add(&soute->prio_list, prio_head->next->prio_list.prev);\n\t\treturn;\n\t}\n\n\tlist_add(&soute->prio_list, &prio_head->active);\n\tprio_head->next = soute;\n\n\tlist_for_each_entry(prio, &stream->prio_list, prio_sched) {\n\t\tif (prio->prio > prio_head->prio) {\n\t\t\tlist_add(&prio_head->prio_sched, prio->prio_sched.prev);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlist_add_tail(&prio_head->prio_sched, &stream->prio_list);\n}\n\nstatic int sctp_sched_prio_set(struct sctp_stream *stream, __u16 sid,\n\t\t\t       __u16 prio, gfp_t gfp)\n{\n\tstruct sctp_stream_out *sout = SCTP_SO(stream, sid);\n\tstruct sctp_stream_out_ext *soute = sout->ext;\n\tstruct sctp_stream_priorities *prio_head, *old;\n\tbool reschedule = false;\n\n\told = soute->prio_head;\n\tif (old && old->prio == prio)\n\t\treturn 0;\n\n\tprio_head = sctp_sched_prio_get_head(stream, prio, gfp);\n\tif (!prio_head)\n\t\treturn -ENOMEM;\n\n\treschedule = sctp_sched_prio_unsched(soute);\n\tsoute->prio_head = prio_head;\n\tif (reschedule)\n\t\tsctp_sched_prio_sched(stream, soute);\n\n\tsctp_sched_prio_head_put(old);\n\treturn 0;\n}\n\nstatic int sctp_sched_prio_get(struct sctp_stream *stream, __u16 sid,\n\t\t\t       __u16 *value)\n{\n\t*value = SCTP_SO(stream, sid)->ext->prio_head->prio;\n\treturn 0;\n}\n\nstatic int sctp_sched_prio_init(struct sctp_stream *stream)\n{\n\tINIT_LIST_HEAD(&stream->prio_list);\n\n\treturn 0;\n}\n\nstatic int sctp_sched_prio_init_sid(struct sctp_stream *stream, __u16 sid,\n\t\t\t\t    gfp_t gfp)\n{\n\tINIT_LIST_HEAD(&SCTP_SO(stream, sid)->ext->prio_list);\n\treturn sctp_sched_prio_set(stream, sid, 0, gfp);\n}\n\nstatic void sctp_sched_prio_free_sid(struct sctp_stream *stream, __u16 sid)\n{\n\tsctp_sched_prio_head_put(SCTP_SO(stream, sid)->ext->prio_head);\n\tSCTP_SO(stream, sid)->ext->prio_head = NULL;\n}\n\nstatic void sctp_sched_prio_enqueue(struct sctp_outq *q,\n\t\t\t\t    struct sctp_datamsg *msg)\n{\n\tstruct sctp_stream *stream;\n\tstruct sctp_chunk *ch;\n\t__u16 sid;\n\n\tch = list_first_entry(&msg->chunks, struct sctp_chunk, frag_list);\n\tsid = sctp_chunk_stream_no(ch);\n\tstream = &q->asoc->stream;\n\tsctp_sched_prio_sched(stream, SCTP_SO(stream, sid)->ext);\n}\n\nstatic struct sctp_chunk *sctp_sched_prio_dequeue(struct sctp_outq *q)\n{\n\tstruct sctp_stream *stream = &q->asoc->stream;\n\tstruct sctp_stream_priorities *prio;\n\tstruct sctp_stream_out_ext *soute;\n\tstruct sctp_chunk *ch = NULL;\n\n\t \n\tif (list_empty(&q->out_chunk_list))\n\t\tgoto out;\n\n\t \n\tif (stream->out_curr) {\n\t\tsoute = stream->out_curr->ext;\n\t} else {\n\t\tprio = list_entry(stream->prio_list.next,\n\t\t\t\t  struct sctp_stream_priorities, prio_sched);\n\t\tsoute = prio->next;\n\t}\n\tch = list_entry(soute->outq.next, struct sctp_chunk, stream_list);\n\tsctp_sched_dequeue_common(q, ch);\n\nout:\n\treturn ch;\n}\n\nstatic void sctp_sched_prio_dequeue_done(struct sctp_outq *q,\n\t\t\t\t\t struct sctp_chunk *ch)\n{\n\tstruct sctp_stream_priorities *prio;\n\tstruct sctp_stream_out_ext *soute;\n\t__u16 sid;\n\n\t \n\tsid = sctp_chunk_stream_no(ch);\n\tsoute = SCTP_SO(&q->asoc->stream, sid)->ext;\n\tprio = soute->prio_head;\n\n\tsctp_sched_prio_next_stream(prio);\n\n\tif (list_empty(&soute->outq))\n\t\tsctp_sched_prio_unsched(soute);\n}\n\nstatic void sctp_sched_prio_sched_all(struct sctp_stream *stream)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_stream_out *sout;\n\tstruct sctp_chunk *ch;\n\n\tasoc = container_of(stream, struct sctp_association, stream);\n\tlist_for_each_entry(ch, &asoc->outqueue.out_chunk_list, list) {\n\t\t__u16 sid;\n\n\t\tsid = sctp_chunk_stream_no(ch);\n\t\tsout = SCTP_SO(stream, sid);\n\t\tif (sout->ext)\n\t\t\tsctp_sched_prio_sched(stream, sout->ext);\n\t}\n}\n\nstatic void sctp_sched_prio_unsched_all(struct sctp_stream *stream)\n{\n\tstruct sctp_stream_priorities *p, *tmp;\n\tstruct sctp_stream_out_ext *soute, *souttmp;\n\n\tlist_for_each_entry_safe(p, tmp, &stream->prio_list, prio_sched)\n\t\tlist_for_each_entry_safe(soute, souttmp, &p->active, prio_list)\n\t\t\tsctp_sched_prio_unsched(soute);\n}\n\nstatic struct sctp_sched_ops sctp_sched_prio = {\n\t.set = sctp_sched_prio_set,\n\t.get = sctp_sched_prio_get,\n\t.init = sctp_sched_prio_init,\n\t.init_sid = sctp_sched_prio_init_sid,\n\t.free_sid = sctp_sched_prio_free_sid,\n\t.enqueue = sctp_sched_prio_enqueue,\n\t.dequeue = sctp_sched_prio_dequeue,\n\t.dequeue_done = sctp_sched_prio_dequeue_done,\n\t.sched_all = sctp_sched_prio_sched_all,\n\t.unsched_all = sctp_sched_prio_unsched_all,\n};\n\nvoid sctp_sched_ops_prio_init(void)\n{\n\tsctp_sched_ops_register(SCTP_SS_PRIO, &sctp_sched_prio);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}