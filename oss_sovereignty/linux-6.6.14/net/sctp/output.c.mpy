{
  "module_name": "output.c",
  "hash_id": "42faadf1241fc1ab12f78223ebd6c5fec44aadd2fcf2a55734ca180da6603a04",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/output.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <net/inet_ecn.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/net_namespace.h>\n\n#include <linux/socket.h>  \n#include <net/sock.h>\n\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/checksum.h>\n\n \nstatic enum sctp_xmit __sctp_packet_append_chunk(struct sctp_packet *packet,\n\t\t\t\t\t\t struct sctp_chunk *chunk);\nstatic enum sctp_xmit sctp_packet_can_append_data(struct sctp_packet *packet,\n\t\t\t\t\t\t  struct sctp_chunk *chunk);\nstatic void sctp_packet_append_data(struct sctp_packet *packet,\n\t\t\t\t    struct sctp_chunk *chunk);\nstatic enum sctp_xmit sctp_packet_will_fit(struct sctp_packet *packet,\n\t\t\t\t\t   struct sctp_chunk *chunk,\n\t\t\t\t\t   u16 chunk_len);\n\nstatic void sctp_packet_reset(struct sctp_packet *packet)\n{\n\t \n\tpacket->size = packet->overhead;\n\n\tpacket->has_cookie_echo = 0;\n\tpacket->has_sack = 0;\n\tpacket->has_data = 0;\n\tpacket->has_auth = 0;\n\tpacket->ipfragok = 0;\n\tpacket->auth = NULL;\n}\n\n \nvoid sctp_packet_config(struct sctp_packet *packet, __u32 vtag,\n\t\t\tint ecn_capable)\n{\n\tstruct sctp_transport *tp = packet->transport;\n\tstruct sctp_association *asoc = tp->asoc;\n\tstruct sctp_sock *sp = NULL;\n\tstruct sock *sk;\n\n\tpr_debug(\"%s: packet:%p vtag:0x%x\\n\", __func__, packet, vtag);\n\tpacket->vtag = vtag;\n\n\t \n\tif (!sctp_packet_empty(packet))\n\t\treturn;\n\n\t \n\tpacket->max_size = tp->pathmtu;\n\n\tif (asoc) {\n\t\tsk = asoc->base.sk;\n\t\tsp = sctp_sk(sk);\n\t}\n\tpacket->overhead = sctp_mtu_payload(sp, 0, 0);\n\tpacket->size = packet->overhead;\n\n\tif (!asoc)\n\t\treturn;\n\n\t \n\tif (!sctp_transport_dst_check(tp)) {\n\t\tsctp_transport_route(tp, NULL, sp);\n\t\tif (asoc->param_flags & SPP_PMTUD_ENABLE)\n\t\t\tsctp_assoc_sync_pmtu(asoc);\n\t} else if (!sctp_transport_pl_enabled(tp) &&\n\t\t   asoc->param_flags & SPP_PMTUD_ENABLE) {\n\t\tif (!sctp_transport_pmtu_check(tp))\n\t\t\tsctp_assoc_sync_pmtu(asoc);\n\t}\n\n\tif (asoc->pmtu_pending) {\n\t\tif (asoc->param_flags & SPP_PMTUD_ENABLE)\n\t\t\tsctp_assoc_sync_pmtu(asoc);\n\t\tasoc->pmtu_pending = 0;\n\t}\n\n\t \n\tif (ecn_capable) {\n\t\tstruct sctp_chunk *chunk = sctp_get_ecne_prepend(asoc);\n\n\t\tif (chunk)\n\t\t\tsctp_packet_append_chunk(packet, chunk);\n\t}\n\n\tif (!tp->dst)\n\t\treturn;\n\n\t \n\trcu_read_lock();\n\tif (__sk_dst_get(sk) != tp->dst) {\n\t\tdst_hold(tp->dst);\n\t\tsk_setup_caps(sk, tp->dst);\n\t}\n\tpacket->max_size = sk_can_gso(sk) ? min(READ_ONCE(tp->dst->dev->gso_max_size),\n\t\t\t\t\t\tGSO_LEGACY_MAX_SIZE)\n\t\t\t\t\t  : asoc->pathmtu;\n\trcu_read_unlock();\n}\n\n \nvoid sctp_packet_init(struct sctp_packet *packet,\n\t\t      struct sctp_transport *transport,\n\t\t      __u16 sport, __u16 dport)\n{\n\tpr_debug(\"%s: packet:%p transport:%p\\n\", __func__, packet, transport);\n\n\tpacket->transport = transport;\n\tpacket->source_port = sport;\n\tpacket->destination_port = dport;\n\tINIT_LIST_HEAD(&packet->chunk_list);\n\t \n\tpacket->overhead = 0;\n\tsctp_packet_reset(packet);\n\tpacket->vtag = 0;\n}\n\n \nvoid sctp_packet_free(struct sctp_packet *packet)\n{\n\tstruct sctp_chunk *chunk, *tmp;\n\n\tpr_debug(\"%s: packet:%p\\n\", __func__, packet);\n\n\tlist_for_each_entry_safe(chunk, tmp, &packet->chunk_list, list) {\n\t\tlist_del_init(&chunk->list);\n\t\tsctp_chunk_free(chunk);\n\t}\n}\n\n \nenum sctp_xmit sctp_packet_transmit_chunk(struct sctp_packet *packet,\n\t\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t\t  int one_packet, gfp_t gfp)\n{\n\tenum sctp_xmit retval;\n\n\tpr_debug(\"%s: packet:%p size:%zu chunk:%p size:%d\\n\", __func__,\n\t\t packet, packet->size, chunk, chunk->skb ? chunk->skb->len : -1);\n\n\tswitch ((retval = (sctp_packet_append_chunk(packet, chunk)))) {\n\tcase SCTP_XMIT_PMTU_FULL:\n\t\tif (!packet->has_cookie_echo) {\n\t\t\tint error = 0;\n\n\t\t\terror = sctp_packet_transmit(packet, gfp);\n\t\t\tif (error < 0)\n\t\t\t\tchunk->skb->sk->sk_err = -error;\n\n\t\t\t \n\t\t\tif (!one_packet)\n\t\t\t\tretval = sctp_packet_append_chunk(packet,\n\t\t\t\t\t\t\t\t  chunk);\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_XMIT_RWND_FULL:\n\tcase SCTP_XMIT_OK:\n\tcase SCTP_XMIT_DELAY:\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n \nstatic enum sctp_xmit sctp_packet_bundle_pad(struct sctp_packet *pkt, struct sctp_chunk *chunk)\n{\n\tstruct sctp_transport *t = pkt->transport;\n\tstruct sctp_chunk *pad;\n\tint overhead = 0;\n\n\tif (!chunk->pmtu_probe)\n\t\treturn SCTP_XMIT_OK;\n\n\t \n\toverhead += sizeof(struct sctphdr) + sizeof(struct sctp_chunkhdr);\n\toverhead += sizeof(struct sctp_sender_hb_info) + sizeof(struct sctp_pad_chunk);\n\tpad = sctp_make_pad(t->asoc, t->pl.probe_size - overhead);\n\tif (!pad)\n\t\treturn SCTP_XMIT_DELAY;\n\n\tlist_add_tail(&pad->list, &pkt->chunk_list);\n\tpkt->size += SCTP_PAD4(ntohs(pad->chunk_hdr->length));\n\tchunk->transport = t;\n\n\treturn SCTP_XMIT_OK;\n}\n\n \nstatic enum sctp_xmit sctp_packet_bundle_auth(struct sctp_packet *pkt,\n\t\t\t\t\t      struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = pkt->transport->asoc;\n\tenum sctp_xmit retval = SCTP_XMIT_OK;\n\tstruct sctp_chunk *auth;\n\n\t \n\tif (!asoc)\n\t\treturn retval;\n\n\t \n\tif (chunk->chunk_hdr->type == SCTP_CID_AUTH || pkt->has_auth)\n\t\treturn retval;\n\n\t \n\tif (!chunk->auth)\n\t\treturn retval;\n\n\tauth = sctp_make_auth(asoc, chunk->shkey->key_id);\n\tif (!auth)\n\t\treturn retval;\n\n\tauth->shkey = chunk->shkey;\n\tsctp_auth_shkey_hold(auth->shkey);\n\n\tretval = __sctp_packet_append_chunk(pkt, auth);\n\n\tif (retval != SCTP_XMIT_OK)\n\t\tsctp_chunk_free(auth);\n\n\treturn retval;\n}\n\n \nstatic enum sctp_xmit sctp_packet_bundle_sack(struct sctp_packet *pkt,\n\t\t\t\t\t      struct sctp_chunk *chunk)\n{\n\tenum sctp_xmit retval = SCTP_XMIT_OK;\n\n\t \n\tif (sctp_chunk_is_data(chunk) && !pkt->has_sack &&\n\t    !pkt->has_cookie_echo) {\n\t\tstruct sctp_association *asoc;\n\t\tstruct timer_list *timer;\n\t\tasoc = pkt->transport->asoc;\n\t\ttimer = &asoc->timers[SCTP_EVENT_TIMEOUT_SACK];\n\n\t\t \n\t\tif (timer_pending(timer)) {\n\t\t\tstruct sctp_chunk *sack;\n\n\t\t\tif (pkt->transport->sack_generation !=\n\t\t\t    pkt->transport->asoc->peer.sack_generation)\n\t\t\t\treturn retval;\n\n\t\t\tasoc->a_rwnd = asoc->rwnd;\n\t\t\tsack = sctp_make_sack(asoc);\n\t\t\tif (sack) {\n\t\t\t\tretval = __sctp_packet_append_chunk(pkt, sack);\n\t\t\t\tif (retval != SCTP_XMIT_OK) {\n\t\t\t\t\tsctp_chunk_free(sack);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tSCTP_INC_STATS(asoc->base.net,\n\t\t\t\t\t       SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\tasoc->stats.octrlchunks++;\n\t\t\t\tasoc->peer.sack_needed = 0;\n\t\t\t\tif (del_timer(timer))\n\t\t\t\t\tsctp_association_put(asoc);\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn retval;\n}\n\n\n \nstatic enum sctp_xmit __sctp_packet_append_chunk(struct sctp_packet *packet,\n\t\t\t\t\t\t struct sctp_chunk *chunk)\n{\n\t__u16 chunk_len = SCTP_PAD4(ntohs(chunk->chunk_hdr->length));\n\tenum sctp_xmit retval = SCTP_XMIT_OK;\n\n\t \n\tretval = sctp_packet_will_fit(packet, chunk, chunk_len);\n\tif (retval != SCTP_XMIT_OK)\n\t\tgoto finish;\n\n\t \n\tswitch (chunk->chunk_hdr->type) {\n\tcase SCTP_CID_DATA:\n\tcase SCTP_CID_I_DATA:\n\t\t \n\t\tsctp_packet_append_data(packet, chunk);\n\t\t \n\t\tpacket->has_sack = 1;\n\t\t \n\t\tpacket->has_auth = 1;\n\t\t \n\t\tpacket->has_data = 1;\n\t\t \n\t\tchunk->sent_at = jiffies;\n\t\t \n\t\tchunk->sent_count++;\n\t\tbreak;\n\tcase SCTP_CID_COOKIE_ECHO:\n\t\tpacket->has_cookie_echo = 1;\n\t\tbreak;\n\n\tcase SCTP_CID_SACK:\n\t\tpacket->has_sack = 1;\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.osacks++;\n\t\tbreak;\n\n\tcase SCTP_CID_AUTH:\n\t\tpacket->has_auth = 1;\n\t\tpacket->auth = chunk;\n\t\tbreak;\n\t}\n\n\t \n\tlist_add_tail(&chunk->list, &packet->chunk_list);\n\tpacket->size += chunk_len;\n\tchunk->transport = packet->transport;\nfinish:\n\treturn retval;\n}\n\n \nenum sctp_xmit sctp_packet_append_chunk(struct sctp_packet *packet,\n\t\t\t\t\tstruct sctp_chunk *chunk)\n{\n\tenum sctp_xmit retval = SCTP_XMIT_OK;\n\n\tpr_debug(\"%s: packet:%p chunk:%p\\n\", __func__, packet, chunk);\n\n\t \n\tif (sctp_chunk_is_data(chunk)) {\n\t\tretval = sctp_packet_can_append_data(packet, chunk);\n\t\tif (retval != SCTP_XMIT_OK)\n\t\t\tgoto finish;\n\t}\n\n\t \n\tretval = sctp_packet_bundle_auth(packet, chunk);\n\tif (retval != SCTP_XMIT_OK)\n\t\tgoto finish;\n\n\t \n\tretval = sctp_packet_bundle_sack(packet, chunk);\n\tif (retval != SCTP_XMIT_OK)\n\t\tgoto finish;\n\n\tretval = __sctp_packet_append_chunk(packet, chunk);\n\tif (retval != SCTP_XMIT_OK)\n\t\tgoto finish;\n\n\tretval = sctp_packet_bundle_pad(packet, chunk);\n\nfinish:\n\treturn retval;\n}\n\nstatic void sctp_packet_gso_append(struct sk_buff *head, struct sk_buff *skb)\n{\n\tif (SCTP_OUTPUT_CB(head)->last == head)\n\t\tskb_shinfo(head)->frag_list = skb;\n\telse\n\t\tSCTP_OUTPUT_CB(head)->last->next = skb;\n\tSCTP_OUTPUT_CB(head)->last = skb;\n\n\thead->truesize += skb->truesize;\n\thead->data_len += skb->len;\n\thead->len += skb->len;\n\trefcount_add(skb->truesize, &head->sk->sk_wmem_alloc);\n\n\t__skb_header_release(skb);\n}\n\nstatic int sctp_packet_pack(struct sctp_packet *packet,\n\t\t\t    struct sk_buff *head, int gso, gfp_t gfp)\n{\n\tstruct sctp_transport *tp = packet->transport;\n\tstruct sctp_auth_chunk *auth = NULL;\n\tstruct sctp_chunk *chunk, *tmp;\n\tint pkt_count = 0, pkt_size;\n\tstruct sock *sk = head->sk;\n\tstruct sk_buff *nskb;\n\tint auth_len = 0;\n\n\tif (gso) {\n\t\tskb_shinfo(head)->gso_type = sk->sk_gso_type;\n\t\tSCTP_OUTPUT_CB(head)->last = head;\n\t} else {\n\t\tnskb = head;\n\t\tpkt_size = packet->size;\n\t\tgoto merge;\n\t}\n\n\tdo {\n\t\t \n\t\tpkt_size = packet->overhead;\n\t\tlist_for_each_entry_safe(chunk, tmp, &packet->chunk_list,\n\t\t\t\t\t list) {\n\t\t\tint padded = SCTP_PAD4(chunk->skb->len);\n\n\t\t\tif (chunk == packet->auth)\n\t\t\t\tauth_len = padded;\n\t\t\telse if (auth_len + padded + packet->overhead >\n\t\t\t\t tp->pathmtu)\n\t\t\t\treturn 0;\n\t\t\telse if (pkt_size + padded > tp->pathmtu)\n\t\t\t\tbreak;\n\t\t\tpkt_size += padded;\n\t\t}\n\t\tnskb = alloc_skb(pkt_size + MAX_HEADER, gfp);\n\t\tif (!nskb)\n\t\t\treturn 0;\n\t\tskb_reserve(nskb, packet->overhead + MAX_HEADER);\n\nmerge:\n\t\t \n\t\tpkt_size -= packet->overhead;\n\t\tlist_for_each_entry_safe(chunk, tmp, &packet->chunk_list, list) {\n\t\t\tint padding;\n\n\t\t\tlist_del_init(&chunk->list);\n\t\t\tif (sctp_chunk_is_data(chunk)) {\n\t\t\t\tif (!sctp_chunk_retransmitted(chunk) &&\n\t\t\t\t    !tp->rto_pending) {\n\t\t\t\t\tchunk->rtt_in_progress = 1;\n\t\t\t\t\ttp->rto_pending = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpadding = SCTP_PAD4(chunk->skb->len) - chunk->skb->len;\n\t\t\tif (padding)\n\t\t\t\tskb_put_zero(chunk->skb, padding);\n\n\t\t\tif (chunk == packet->auth)\n\t\t\t\tauth = (struct sctp_auth_chunk *)\n\t\t\t\t\t\t\tskb_tail_pointer(nskb);\n\n\t\t\tskb_put_data(nskb, chunk->skb->data, chunk->skb->len);\n\n\t\t\tpr_debug(\"*** Chunk:%p[%s] %s 0x%x, length:%d, chunk->skb->len:%d, rtt_in_progress:%d\\n\",\n\t\t\t\t chunk,\n\t\t\t\t sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\n\t\t\t\t chunk->has_tsn ? \"TSN\" : \"No TSN\",\n\t\t\t\t chunk->has_tsn ? ntohl(chunk->subh.data_hdr->tsn) : 0,\n\t\t\t\t ntohs(chunk->chunk_hdr->length), chunk->skb->len,\n\t\t\t\t chunk->rtt_in_progress);\n\n\t\t\tpkt_size -= SCTP_PAD4(chunk->skb->len);\n\n\t\t\tif (!sctp_chunk_is_data(chunk) && chunk != packet->auth)\n\t\t\t\tsctp_chunk_free(chunk);\n\n\t\t\tif (!pkt_size)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (auth) {\n\t\t\tsctp_auth_calculate_hmac(tp->asoc, nskb, auth,\n\t\t\t\t\t\t packet->auth->shkey, gfp);\n\t\t\t \n\t\t\tif (list_empty(&packet->chunk_list))\n\t\t\t\tsctp_chunk_free(packet->auth);\n\t\t\telse\n\t\t\t\tlist_add(&packet->auth->list,\n\t\t\t\t\t &packet->chunk_list);\n\t\t}\n\n\t\tif (gso)\n\t\t\tsctp_packet_gso_append(head, nskb);\n\n\t\tpkt_count++;\n\t} while (!list_empty(&packet->chunk_list));\n\n\tif (gso) {\n\t\tmemset(head->cb, 0, max(sizeof(struct inet_skb_parm),\n\t\t\t\t\tsizeof(struct inet6_skb_parm)));\n\t\tskb_shinfo(head)->gso_segs = pkt_count;\n\t\tskb_shinfo(head)->gso_size = GSO_BY_FRAGS;\n\t\tgoto chksum;\n\t}\n\n\tif (sctp_checksum_disable)\n\t\treturn 1;\n\n\tif (!(tp->dst->dev->features & NETIF_F_SCTP_CRC) ||\n\t    dst_xfrm(tp->dst) || packet->ipfragok || tp->encap_port) {\n\t\tstruct sctphdr *sh =\n\t\t\t(struct sctphdr *)skb_transport_header(head);\n\n\t\tsh->checksum = sctp_compute_cksum(head, 0);\n\t} else {\nchksum:\n\t\thead->ip_summed = CHECKSUM_PARTIAL;\n\t\thead->csum_not_inet = 1;\n\t\thead->csum_start = skb_transport_header(head) - head->head;\n\t\thead->csum_offset = offsetof(struct sctphdr, checksum);\n\t}\n\n\treturn pkt_count;\n}\n\n \nint sctp_packet_transmit(struct sctp_packet *packet, gfp_t gfp)\n{\n\tstruct sctp_transport *tp = packet->transport;\n\tstruct sctp_association *asoc = tp->asoc;\n\tstruct sctp_chunk *chunk, *tmp;\n\tint pkt_count, gso = 0;\n\tstruct sk_buff *head;\n\tstruct sctphdr *sh;\n\tstruct sock *sk;\n\n\tpr_debug(\"%s: packet:%p\\n\", __func__, packet);\n\tif (list_empty(&packet->chunk_list))\n\t\treturn 0;\n\tchunk = list_entry(packet->chunk_list.next, struct sctp_chunk, list);\n\tsk = chunk->skb->sk;\n\n\tif (packet->size > tp->pathmtu && !packet->ipfragok && !chunk->pmtu_probe) {\n\t\tif (tp->pl.state == SCTP_PL_ERROR) {  \n\t\t\tpacket->ipfragok = 1;\n\t\t} else {\n\t\t\tif (!sk_can_gso(sk)) {  \n\t\t\t\tpr_err_once(\"Trying to GSO but underlying device doesn't support it.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgso = 1;\n\t\t}\n\t}\n\n\t \n\thead = alloc_skb((gso ? packet->overhead : packet->size) +\n\t\t\t MAX_HEADER, gfp);\n\tif (!head)\n\t\tgoto out;\n\tskb_reserve(head, packet->overhead + MAX_HEADER);\n\tskb_set_owner_w(head, sk);\n\n\t \n\tsh = skb_push(head, sizeof(struct sctphdr));\n\tskb_reset_transport_header(head);\n\tsh->source = htons(packet->source_port);\n\tsh->dest = htons(packet->destination_port);\n\tsh->vtag = htonl(packet->vtag);\n\tsh->checksum = 0;\n\n\t \n\tif (!tp->dst) {\n\t\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\n\t\tkfree_skb(head);\n\t\tgoto out;\n\t}\n\n\t \n\tpkt_count = sctp_packet_pack(packet, head, gso, gfp);\n\tif (!pkt_count) {\n\t\tkfree_skb(head);\n\t\tgoto out;\n\t}\n\tpr_debug(\"***sctp_transmit_packet*** skb->len:%d\\n\", head->len);\n\n\t \n\tif (packet->has_data && sctp_state(asoc, ESTABLISHED) &&\n\t    asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\n\t\tstruct timer_list *timer =\n\t\t\t&asoc->timers[SCTP_EVENT_TIMEOUT_AUTOCLOSE];\n\t\tunsigned long timeout =\n\t\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE];\n\n\t\tif (!mod_timer(timer, jiffies + timeout))\n\t\t\tsctp_association_hold(asoc);\n\t}\n\n\t \n\ttp->af_specific->ecn_capable(sk);\n\tif (asoc) {\n\t\tasoc->stats.opackets += pkt_count;\n\t\tif (asoc->peer.last_sent_to != tp)\n\t\t\tasoc->peer.last_sent_to = tp;\n\t}\n\thead->ignore_df = packet->ipfragok;\n\tif (tp->dst_pending_confirm)\n\t\tskb_set_dst_pending_confirm(head, 1);\n\t \n\tif (tp->af_specific->sctp_xmit(head, tp) >= 0 &&\n\t    tp->dst_pending_confirm)\n\t\ttp->dst_pending_confirm = 0;\n\nout:\n\tlist_for_each_entry_safe(chunk, tmp, &packet->chunk_list, list) {\n\t\tlist_del_init(&chunk->list);\n\t\tif (!sctp_chunk_is_data(chunk))\n\t\t\tsctp_chunk_free(chunk);\n\t}\n\tsctp_packet_reset(packet);\n\treturn 0;\n}\n\n \n\n \nstatic enum sctp_xmit sctp_packet_can_append_data(struct sctp_packet *packet,\n\t\t\t\t\t\t  struct sctp_chunk *chunk)\n{\n\tsize_t datasize, rwnd, inflight, flight_size;\n\tstruct sctp_transport *transport = packet->transport;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sctp_outq *q = &asoc->outqueue;\n\n\t \n\n\trwnd = asoc->peer.rwnd;\n\tinflight = q->outstanding_bytes;\n\tflight_size = transport->flight_size;\n\n\tdatasize = sctp_data_size(chunk);\n\n\tif (datasize > rwnd && inflight > 0)\n\t\t \n\t\treturn SCTP_XMIT_RWND_FULL;\n\n\t \n\t \n\tif (chunk->fast_retransmit != SCTP_NEED_FRTX &&\n\t    flight_size >= transport->cwnd)\n\t\treturn SCTP_XMIT_RWND_FULL;\n\n\t \n\n\tif ((sctp_sk(asoc->base.sk)->nodelay || inflight == 0) &&\n\t    !asoc->force_delay)\n\t\t \n\t\treturn SCTP_XMIT_OK;\n\n\tif (!sctp_packet_empty(packet))\n\t\t \n\t\treturn SCTP_XMIT_OK;\n\n\tif (!sctp_state(asoc, ESTABLISHED))\n\t\treturn SCTP_XMIT_OK;\n\n\t \n\tif (chunk->skb->len + q->out_qlen > transport->pathmtu -\n\t    packet->overhead - sctp_datachk_len(&chunk->asoc->stream) - 4)\n\t\t \n\t\treturn SCTP_XMIT_OK;\n\n\t \n\tif (!chunk->msg->can_delay)\n\t\treturn SCTP_XMIT_OK;\n\n\t \n\treturn SCTP_XMIT_DELAY;\n}\n\n \nstatic void sctp_packet_append_data(struct sctp_packet *packet,\n\t\t\t\tstruct sctp_chunk *chunk)\n{\n\tstruct sctp_transport *transport = packet->transport;\n\tsize_t datasize = sctp_data_size(chunk);\n\tstruct sctp_association *asoc = transport->asoc;\n\tu32 rwnd = asoc->peer.rwnd;\n\n\t \n\ttransport->flight_size += datasize;\n\n\t \n\tasoc->outqueue.outstanding_bytes += datasize;\n\n\t \n\tif (datasize < rwnd)\n\t\trwnd -= datasize;\n\telse\n\t\trwnd = 0;\n\n\tasoc->peer.rwnd = rwnd;\n\tsctp_chunk_assign_tsn(chunk);\n\tasoc->stream.si->assign_number(chunk);\n}\n\nstatic enum sctp_xmit sctp_packet_will_fit(struct sctp_packet *packet,\n\t\t\t\t\t   struct sctp_chunk *chunk,\n\t\t\t\t\t   u16 chunk_len)\n{\n\tenum sctp_xmit retval = SCTP_XMIT_OK;\n\tsize_t psize, pmtu, maxsize;\n\n\t \n\tif ((packet->auth && chunk->shkey != packet->auth->shkey) ||\n\t    (!packet->auth && chunk->shkey &&\n\t     chunk->chunk_hdr->type != SCTP_CID_AUTH))\n\t\treturn SCTP_XMIT_PMTU_FULL;\n\n\tpsize = packet->size;\n\tif (packet->transport->asoc)\n\t\tpmtu = packet->transport->asoc->pathmtu;\n\telse\n\t\tpmtu = packet->transport->pathmtu;\n\n\t \n\tif (psize + chunk_len > pmtu) {\n\t\t \n\t\tif (sctp_packet_empty(packet) ||\n\t\t    (!packet->has_data && chunk->auth)) {\n\t\t\t \n\t\t\tpacket->ipfragok = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tmaxsize = pmtu - packet->overhead;\n\t\tif (packet->auth)\n\t\t\tmaxsize -= SCTP_PAD4(packet->auth->skb->len);\n\t\tif (chunk_len > maxsize)\n\t\t\tretval = SCTP_XMIT_PMTU_FULL;\n\n\t\t \n\t\tif (!sctp_chunk_is_data(chunk) && packet->has_data)\n\t\t\tretval = SCTP_XMIT_PMTU_FULL;\n\n\t\tif (psize + chunk_len > packet->max_size)\n\t\t\t \n\t\t\tretval = SCTP_XMIT_PMTU_FULL;\n\n\t\tif (!packet->transport->burst_limited &&\n\t\t    psize + chunk_len > (packet->transport->cwnd >> 1))\n\t\t\t \n\t\t\tretval = SCTP_XMIT_PMTU_FULL;\n\n\t\tif (packet->transport->burst_limited &&\n\t\t    psize + chunk_len > (packet->transport->burst_limited >> 1))\n\t\t\t \n\t\t\tretval = SCTP_XMIT_PMTU_FULL;\n\t\t \n\t}\n\nout:\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}