{
  "module_name": "socket.c",
  "hash_id": "9dc83e14d7e8cb034bbfe2cf80fde03db8a13e4b7d2852dd7e9ee76c59cdb42a",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/socket.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <crypto/hash.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/wait.h>\n#include <linux/time.h>\n#include <linux/sched/signal.h>\n#include <linux/ip.h>\n#include <linux/capability.h>\n#include <linux/fcntl.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/compat.h>\n#include <linux/rhashtable.h>\n\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/route.h>\n#include <net/ipv6.h>\n#include <net/inet_common.h>\n#include <net/busy_poll.h>\n#include <trace/events/sock.h>\n\n#include <linux/socket.h>  \n#include <linux/export.h>\n#include <net/sock.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/stream_sched.h>\n\n \nstatic bool sctp_writeable(const struct sock *sk);\nstatic void sctp_wfree(struct sk_buff *skb);\nstatic int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len);\nstatic int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p);\nstatic int sctp_wait_for_connect(struct sctp_association *, long *timeo_p);\nstatic int sctp_wait_for_accept(struct sock *sk, long timeo);\nstatic void sctp_wait_for_close(struct sock *sk, long timeo);\nstatic void sctp_destruct_sock(struct sock *sk);\nstatic struct sctp_af *sctp_sockaddr_af(struct sctp_sock *opt,\n\t\t\t\t\tunion sctp_addr *addr, int len);\nstatic int sctp_bindx_add(struct sock *, struct sockaddr *, int);\nstatic int sctp_bindx_rem(struct sock *, struct sockaddr *, int);\nstatic int sctp_send_asconf_add_ip(struct sock *, struct sockaddr *, int);\nstatic int sctp_send_asconf_del_ip(struct sock *, struct sockaddr *, int);\nstatic int sctp_send_asconf(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *chunk);\nstatic int sctp_do_bind(struct sock *, union sctp_addr *, int);\nstatic int sctp_autobind(struct sock *sk);\nstatic int sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t     struct sctp_association *assoc,\n\t\t\t     enum sctp_socket_type type);\n\nstatic unsigned long sctp_memory_pressure;\nstatic atomic_long_t sctp_memory_allocated;\nstatic DEFINE_PER_CPU(int, sctp_memory_per_cpu_fw_alloc);\nstruct percpu_counter sctp_sockets_allocated;\n\nstatic void sctp_enter_memory_pressure(struct sock *sk)\n{\n\tWRITE_ONCE(sctp_memory_pressure, 1);\n}\n\n\n \nstatic inline int sctp_wspace(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\treturn asoc->ep->sndbuf_policy ? sk->sk_sndbuf - asoc->sndbuf_used\n\t\t\t\t       : sk_stream_wspace(sk);\n}\n\n \nstatic inline void sctp_set_owner_w(struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\n\t \n\tsctp_association_hold(asoc);\n\n\tif (chunk->shkey)\n\t\tsctp_auth_shkey_hold(chunk->shkey);\n\n\tskb_set_owner_w(chunk->skb, sk);\n\n\tchunk->skb->destructor = sctp_wfree;\n\t \n\tskb_shinfo(chunk->skb)->destructor_arg = chunk;\n\n\trefcount_add(sizeof(struct sctp_chunk), &sk->sk_wmem_alloc);\n\tasoc->sndbuf_used += chunk->skb->truesize + sizeof(struct sctp_chunk);\n\tsk_wmem_queued_add(sk, chunk->skb->truesize + sizeof(struct sctp_chunk));\n\tsk_mem_charge(sk, chunk->skb->truesize);\n}\n\nstatic void sctp_clear_owner_w(struct sctp_chunk *chunk)\n{\n\tskb_orphan(chunk->skb);\n}\n\n#define traverse_and_process()\t\\\ndo {\t\t\t\t\\\n\tmsg = chunk->msg;\t\\\n\tif (msg == prev_msg)\t\\\n\t\tcontinue;\t\\\n\tlist_for_each_entry(c, &msg->chunks, frag_list) {\t\\\n\t\tif ((clear && asoc->base.sk == c->skb->sk) ||\t\\\n\t\t    (!clear && asoc->base.sk != c->skb->sk))\t\\\n\t\t\tcb(c);\t\\\n\t}\t\t\t\\\n\tprev_msg = msg;\t\t\\\n} while (0)\n\nstatic void sctp_for_each_tx_datachunk(struct sctp_association *asoc,\n\t\t\t\t       bool clear,\n\t\t\t\t       void (*cb)(struct sctp_chunk *))\n\n{\n\tstruct sctp_datamsg *msg, *prev_msg = NULL;\n\tstruct sctp_outq *q = &asoc->outqueue;\n\tstruct sctp_chunk *chunk, *c;\n\tstruct sctp_transport *t;\n\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list, transports)\n\t\tlist_for_each_entry(chunk, &t->transmitted, transmitted_list)\n\t\t\ttraverse_and_process();\n\n\tlist_for_each_entry(chunk, &q->retransmit, transmitted_list)\n\t\ttraverse_and_process();\n\n\tlist_for_each_entry(chunk, &q->sacked, transmitted_list)\n\t\ttraverse_and_process();\n\n\tlist_for_each_entry(chunk, &q->abandoned, transmitted_list)\n\t\ttraverse_and_process();\n\n\tlist_for_each_entry(chunk, &q->out_chunk_list, list)\n\t\ttraverse_and_process();\n}\n\nstatic void sctp_for_each_rx_skb(struct sctp_association *asoc, struct sock *sk,\n\t\t\t\t void (*cb)(struct sk_buff *, struct sock *))\n\n{\n\tstruct sk_buff *skb, *tmp;\n\n\tsctp_skb_for_each(skb, &asoc->ulpq.lobby, tmp)\n\t\tcb(skb, sk);\n\n\tsctp_skb_for_each(skb, &asoc->ulpq.reasm, tmp)\n\t\tcb(skb, sk);\n\n\tsctp_skb_for_each(skb, &asoc->ulpq.reasm_uo, tmp)\n\t\tcb(skb, sk);\n}\n\n \nstatic inline int sctp_verify_addr(struct sock *sk, union sctp_addr *addr,\n\t\t\t\t   int len)\n{\n\tstruct sctp_af *af;\n\n\t \n\taf = sctp_sockaddr_af(sctp_sk(sk), addr, len);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\t \n\tif (!af->addr_valid(addr, sctp_sk(sk), NULL))\n\t\treturn -EINVAL;\n\n\tif (!sctp_sk(sk)->pf->send_verify(sctp_sk(sk), (addr)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstruct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)\n{\n\tstruct sctp_association *asoc = NULL;\n\n\t \n\tif (!sctp_style(sk, UDP)) {\n\t\t \n\t\tif (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))\n\t\t\treturn NULL;\n\n\t\t \n\t\tif (!list_empty(&sctp_sk(sk)->ep->asocs))\n\t\t\tasoc = list_entry(sctp_sk(sk)->ep->asocs.next,\n\t\t\t\t\t  struct sctp_association, asocs);\n\t\treturn asoc;\n\t}\n\n\t \n\tif (id <= SCTP_ALL_ASSOC)\n\t\treturn NULL;\n\n\tspin_lock_bh(&sctp_assocs_id_lock);\n\tasoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);\n\tif (asoc && (asoc->base.sk != sk || asoc->base.dead))\n\t\tasoc = NULL;\n\tspin_unlock_bh(&sctp_assocs_id_lock);\n\n\treturn asoc;\n}\n\n \nstatic struct sctp_transport *sctp_addr_id2transport(struct sock *sk,\n\t\t\t\t\t      struct sockaddr_storage *addr,\n\t\t\t\t\t      sctp_assoc_t id)\n{\n\tstruct sctp_association *addr_asoc = NULL, *id_asoc = NULL;\n\tstruct sctp_af *af = sctp_get_af_specific(addr->ss_family);\n\tunion sctp_addr *laddr = (union sctp_addr *)addr;\n\tstruct sctp_transport *transport;\n\n\tif (!af || sctp_verify_addr(sk, laddr, af->sockaddr_len))\n\t\treturn NULL;\n\n\taddr_asoc = sctp_endpoint_lookup_assoc(sctp_sk(sk)->ep,\n\t\t\t\t\t       laddr,\n\t\t\t\t\t       &transport);\n\n\tif (!addr_asoc)\n\t\treturn NULL;\n\n\tid_asoc = sctp_id2assoc(sk, id);\n\tif (id_asoc && (id_asoc != addr_asoc))\n\t\treturn NULL;\n\n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sctp_sk(sk),\n\t\t\t\t\t\t(union sctp_addr *)addr);\n\n\treturn transport;\n}\n\n \nstatic int sctp_bind(struct sock *sk, struct sockaddr *addr, int addr_len)\n{\n\tint retval = 0;\n\n\tlock_sock(sk);\n\n\tpr_debug(\"%s: sk:%p, addr:%p, addr_len:%d\\n\", __func__, sk,\n\t\t addr, addr_len);\n\n\t \n\tif (!sctp_sk(sk)->ep->base.bind_addr.port)\n\t\tretval = sctp_do_bind(sk, (union sctp_addr *)addr,\n\t\t\t\t      addr_len);\n\telse\n\t\tretval = -EINVAL;\n\n\trelease_sock(sk);\n\n\treturn retval;\n}\n\nstatic int sctp_get_port_local(struct sock *, union sctp_addr *);\n\n \nstatic struct sctp_af *sctp_sockaddr_af(struct sctp_sock *opt,\n\t\t\t\t\tunion sctp_addr *addr, int len)\n{\n\tstruct sctp_af *af;\n\n\t \n\tif (len < sizeof (struct sockaddr))\n\t\treturn NULL;\n\n\tif (!opt->pf->af_supported(addr->sa.sa_family, opt))\n\t\treturn NULL;\n\n\tif (addr->sa.sa_family == AF_INET6) {\n\t\tif (len < SIN6_LEN_RFC2133)\n\t\t\treturn NULL;\n\t\t \n\t\tif (ipv6_addr_v4mapped(&addr->v6.sin6_addr) &&\n\t\t    !opt->pf->af_supported(AF_INET, opt))\n\t\t\treturn NULL;\n\t}\n\n\t \n\taf = sctp_get_af_specific(addr->sa.sa_family);\n\n\tif (len < af->sockaddr_len)\n\t\treturn NULL;\n\n\treturn af;\n}\n\nstatic void sctp_auto_asconf_init(struct sctp_sock *sp)\n{\n\tstruct net *net = sock_net(&sp->inet.sk);\n\n\tif (net->sctp.default_auto_asconf) {\n\t\tspin_lock_bh(&net->sctp.addr_wq_lock);\n\t\tlist_add_tail(&sp->auto_asconf_list, &net->sctp.auto_asconf_splist);\n\t\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n\t\tsp->do_auto_asconf = 1;\n\t}\n}\n\n \nstatic int sctp_do_bind(struct sock *sk, union sctp_addr *addr, int len)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tstruct sctp_af *af;\n\tunsigned short snum;\n\tint ret = 0;\n\n\t \n\taf = sctp_sockaddr_af(sp, addr, len);\n\tif (!af) {\n\t\tpr_debug(\"%s: sk:%p, newaddr:%p, len:%d EINVAL\\n\",\n\t\t\t __func__, sk, addr, len);\n\t\treturn -EINVAL;\n\t}\n\n\tsnum = ntohs(addr->v4.sin_port);\n\n\tpr_debug(\"%s: sk:%p, new addr:%pISc, port:%d, new port:%d, len:%d\\n\",\n\t\t __func__, sk, &addr->sa, bp->port, snum, len);\n\n\t \n\tif (!sp->pf->bind_verify(sp, addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\tif (bp->port) {\n\t\tif (!snum)\n\t\t\tsnum = bp->port;\n\t\telse if (snum != bp->port) {\n\t\t\tpr_debug(\"%s: new port %d doesn't match existing port \"\n\t\t\t\t \"%d\\n\", __func__, snum, bp->port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (snum && inet_port_requires_bind_service(net, snum) &&\n\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\t \n\tif (sctp_bind_addr_match(bp, addr, sp))\n\t\treturn -EINVAL;\n\n\t \n\taddr->v4.sin_port = htons(snum);\n\tif (sctp_get_port_local(sk, addr))\n\t\treturn -EADDRINUSE;\n\n\t \n\tif (!bp->port) {\n\t\tbp->port = inet_sk(sk)->inet_num;\n\t\tsctp_auto_asconf_init(sp);\n\t}\n\n\t \n\tret = sctp_add_bind_addr(bp, addr, af->sockaddr_len,\n\t\t\t\t SCTP_ADDR_SRC, GFP_ATOMIC);\n\n\tif (ret) {\n\t\tsctp_put_port(sk);\n\t\treturn ret;\n\t}\n\t \n\tinet_sk(sk)->inet_sport = htons(inet_sk(sk)->inet_num);\n\tsp->pf->to_sk_saddr(addr, sk);\n\n\treturn ret;\n}\n\n  \nstatic int sctp_send_asconf(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *chunk)\n{\n\tint retval = 0;\n\n\t \n\tif (asoc->addip_last_asconf) {\n\t\tlist_add_tail(&chunk->list, &asoc->addip_chunk_list);\n\t\tgoto out;\n\t}\n\n\t \n\tsctp_chunk_hold(chunk);\n\tretval = sctp_primitive_ASCONF(asoc->base.net, asoc, chunk);\n\tif (retval)\n\t\tsctp_chunk_free(chunk);\n\telse\n\t\tasoc->addip_last_asconf = chunk;\n\nout:\n\treturn retval;\n}\n\n \nstatic int sctp_bindx_add(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tint cnt;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tstruct sockaddr *sa_addr;\n\tstruct sctp_af *af;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\", __func__, sk,\n\t\t addrs, addrcnt);\n\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\t \n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_add;\n\t\t}\n\n\t\tretval = sctp_do_bind(sk, (union sctp_addr *)sa_addr,\n\t\t\t\t      af->sockaddr_len);\n\n\t\taddr_buf += af->sockaddr_len;\n\nerr_bindx_add:\n\t\tif (retval < 0) {\n\t\t\t \n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_rem(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n \nstatic int sctp_send_asconf_add_ip(struct sock\t\t*sk,\n\t\t\t\t   struct sockaddr\t*addrs,\n\t\t\t\t   int \t\t\taddrcnt)\n{\n\tstruct sctp_sock\t\t*sp;\n\tstruct sctp_endpoint\t\t*ep;\n\tstruct sctp_association\t\t*asoc;\n\tstruct sctp_bind_addr\t\t*bp;\n\tstruct sctp_chunk\t\t*chunk;\n\tstruct sctp_sockaddr_entry\t*laddr;\n\tunion sctp_addr\t\t\t*addr;\n\tunion sctp_addr\t\t\tsaveaddr;\n\tvoid\t\t\t\t*addr_buf;\n\tstruct sctp_af\t\t\t*af;\n\tstruct list_head\t\t*p;\n\tint \t\t\t\ti;\n\tint \t\t\t\tretval = 0;\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tif (!ep->asconf_enable)\n\t\treturn retval;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\",\n\t\t __func__, sk, addrs, addrcnt);\n\n\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\t\tif (!asoc->peer.asconf_capable)\n\t\t\tcontinue;\n\n\t\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_ADD_IP)\n\t\t\tcontinue;\n\n\t\tif (!sctp_state(asoc, ESTABLISHED))\n\t\t\tcontinue;\n\n\t\t \n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\taddr = addr_buf;\n\t\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\t\tif (!af) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (sctp_assoc_lookup_laddr(asoc, addr))\n\t\t\t\tbreak;\n\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (i < addrcnt)\n\t\t\tcontinue;\n\n\t\t \n\t\tbp = &asoc->base.bind_addr;\n\t\tp = bp->address_list.next;\n\t\tladdr = list_entry(p, struct sctp_sockaddr_entry, list);\n\t\tchunk = sctp_make_asconf_update_ip(asoc, &laddr->a, addrs,\n\t\t\t\t\t\t   addrcnt, SCTP_PARAM_ADD_IP);\n\t\tif (!chunk) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\taddr = addr_buf;\n\t\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\t\tmemcpy(&saveaddr, addr, af->sockaddr_len);\n\t\t\tretval = sctp_add_bind_addr(bp, &saveaddr,\n\t\t\t\t\t\t    sizeof(saveaddr),\n\t\t\t\t\t\t    SCTP_ADDR_NEW, GFP_ATOMIC);\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (asoc->src_out_of_asoc_ok) {\n\t\t\tstruct sctp_transport *trans;\n\n\t\t\tlist_for_each_entry(trans,\n\t\t\t    &asoc->peer.transport_addr_list, transports) {\n\t\t\t\ttrans->cwnd = min(4*asoc->pathmtu, max_t(__u32,\n\t\t\t\t    2*asoc->pathmtu, 4380));\n\t\t\t\ttrans->ssthresh = asoc->peer.i.a_rwnd;\n\t\t\t\ttrans->rto = asoc->rto_initial;\n\t\t\t\tsctp_max_rto(asoc, trans);\n\t\t\t\ttrans->rtt = trans->srtt = trans->rttvar = 0;\n\t\t\t\t \n\t\t\t\tsctp_transport_route(trans, NULL,\n\t\t\t\t\t\t     sctp_sk(asoc->base.sk));\n\t\t\t}\n\t\t}\n\t\tretval = sctp_send_asconf(asoc, chunk);\n\t}\n\nout:\n\treturn retval;\n}\n\n \nstatic int sctp_bindx_rem(struct sock *sk, struct sockaddr *addrs, int addrcnt)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tint cnt;\n\tstruct sctp_bind_addr *bp = &ep->base.bind_addr;\n\tint retval = 0;\n\tvoid *addr_buf;\n\tunion sctp_addr *sa_addr;\n\tstruct sctp_af *af;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\",\n\t\t __func__, sk, addrs, addrcnt);\n\n\taddr_buf = addrs;\n\tfor (cnt = 0; cnt < addrcnt; cnt++) {\n\t\t \n\t\tif (list_empty(&bp->address_list) ||\n\t\t    (sctp_list_single_entry(&bp->address_list))) {\n\t\t\tretval = -EBUSY;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa.sa_family);\n\t\tif (!af) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tif (!af->addr_valid(sa_addr, sp, NULL)) {\n\t\t\tretval = -EADDRNOTAVAIL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tif (sa_addr->v4.sin_port &&\n\t\t    sa_addr->v4.sin_port != htons(bp->port)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_bindx_rem;\n\t\t}\n\n\t\tif (!sa_addr->v4.sin_port)\n\t\t\tsa_addr->v4.sin_port = htons(bp->port);\n\n\t\t \n\t\tretval = sctp_del_bind_addr(bp, sa_addr);\n\n\t\taddr_buf += af->sockaddr_len;\nerr_bindx_rem:\n\t\tif (retval < 0) {\n\t\t\t \n\t\t\tif (cnt > 0)\n\t\t\t\tsctp_bindx_add(sk, addrs, cnt);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n \nstatic int sctp_send_asconf_del_ip(struct sock\t\t*sk,\n\t\t\t\t   struct sockaddr\t*addrs,\n\t\t\t\t   int\t\t\taddrcnt)\n{\n\tstruct sctp_sock\t*sp;\n\tstruct sctp_endpoint\t*ep;\n\tstruct sctp_association\t*asoc;\n\tstruct sctp_transport\t*transport;\n\tstruct sctp_bind_addr\t*bp;\n\tstruct sctp_chunk\t*chunk;\n\tunion sctp_addr\t\t*laddr;\n\tvoid\t\t\t*addr_buf;\n\tstruct sctp_af\t\t*af;\n\tstruct sctp_sockaddr_entry *saddr;\n\tint \t\t\ti;\n\tint \t\t\tretval = 0;\n\tint\t\t\tstored = 0;\n\n\tchunk = NULL;\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tif (!ep->asconf_enable)\n\t\treturn retval;\n\n\tpr_debug(\"%s: sk:%p, addrs:%p, addrcnt:%d\\n\",\n\t\t __func__, sk, addrs, addrcnt);\n\n\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\n\t\tif (!asoc->peer.asconf_capable)\n\t\t\tcontinue;\n\n\t\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_DEL_IP)\n\t\t\tcontinue;\n\n\t\tif (!sctp_state(asoc, ESTABLISHED))\n\t\t\tcontinue;\n\n\t\t \n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\tladdr = addr_buf;\n\t\t\taf = sctp_get_af_specific(laddr->v4.sin_family);\n\t\t\tif (!af) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!sctp_assoc_lookup_laddr(asoc, laddr))\n\t\t\t\tbreak;\n\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (i < addrcnt)\n\t\t\tcontinue;\n\n\t\t \n\t\tbp = &asoc->base.bind_addr;\n\t\tladdr = sctp_find_unmatch_addr(bp, (union sctp_addr *)addrs,\n\t\t\t\t\t       addrcnt, sp);\n\t\tif ((laddr == NULL) && (addrcnt == 1)) {\n\t\t\tif (asoc->asconf_addr_del_pending)\n\t\t\t\tcontinue;\n\t\t\tasoc->asconf_addr_del_pending =\n\t\t\t    kzalloc(sizeof(union sctp_addr), GFP_ATOMIC);\n\t\t\tif (asoc->asconf_addr_del_pending == NULL) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tasoc->asconf_addr_del_pending->sa.sa_family =\n\t\t\t\t    addrs->sa_family;\n\t\t\tasoc->asconf_addr_del_pending->v4.sin_port =\n\t\t\t\t    htons(bp->port);\n\t\t\tif (addrs->sa_family == AF_INET) {\n\t\t\t\tstruct sockaddr_in *sin;\n\n\t\t\t\tsin = (struct sockaddr_in *)addrs;\n\t\t\t\tasoc->asconf_addr_del_pending->v4.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\t} else if (addrs->sa_family == AF_INET6) {\n\t\t\t\tstruct sockaddr_in6 *sin6;\n\n\t\t\t\tsin6 = (struct sockaddr_in6 *)addrs;\n\t\t\t\tasoc->asconf_addr_del_pending->v6.sin6_addr = sin6->sin6_addr;\n\t\t\t}\n\n\t\t\tpr_debug(\"%s: keep the last address asoc:%p %pISc at %p\\n\",\n\t\t\t\t __func__, asoc, &asoc->asconf_addr_del_pending->sa,\n\t\t\t\t asoc->asconf_addr_del_pending);\n\n\t\t\tasoc->src_out_of_asoc_ok = 1;\n\t\t\tstored = 1;\n\t\t\tgoto skip_mkasconf;\n\t\t}\n\n\t\tif (laddr == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tchunk = sctp_make_asconf_update_ip(asoc, laddr, addrs, addrcnt,\n\t\t\t\t\t\t   SCTP_PARAM_DEL_IP);\n\t\tif (!chunk) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\nskip_mkasconf:\n\t\t \n\t\taddr_buf = addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\tladdr = addr_buf;\n\t\t\taf = sctp_get_af_specific(laddr->v4.sin_family);\n\t\t\tlist_for_each_entry(saddr, &bp->address_list, list) {\n\t\t\t\tif (sctp_cmp_addr_exact(&saddr->a, laddr))\n\t\t\t\t\tsaddr->state = SCTP_ADDR_DEL;\n\t\t\t}\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\tsctp_transport_route(transport, NULL,\n\t\t\t\t\t     sctp_sk(asoc->base.sk));\n\t\t}\n\n\t\tif (stored)\n\t\t\t \n\t\t\tcontinue;\n\t\tretval = sctp_send_asconf(asoc, chunk);\n\t}\nout:\n\treturn retval;\n}\n\n \nint sctp_asconf_mgmt(struct sctp_sock *sp, struct sctp_sockaddr_entry *addrw)\n{\n\tstruct sock *sk = sctp_opt2sk(sp);\n\tunion sctp_addr *addr;\n\tstruct sctp_af *af;\n\n\t \n\taddr = &addrw->a;\n\taddr->v4.sin_port = htons(sp->ep->base.bind_addr.port);\n\taf = sctp_get_af_specific(addr->sa.sa_family);\n\tif (!af)\n\t\treturn -EINVAL;\n\tif (sctp_verify_addr(sk, addr, af->sockaddr_len))\n\t\treturn -EINVAL;\n\n\tif (addrw->state == SCTP_ADDR_NEW)\n\t\treturn sctp_send_asconf_add_ip(sk, (struct sockaddr *)addr, 1);\n\telse\n\t\treturn sctp_send_asconf_del_ip(sk, (struct sockaddr *)addr, 1);\n}\n\n \nstatic int sctp_setsockopt_bindx(struct sock *sk, struct sockaddr *addrs,\n\t\t\t\t int addrs_size, int op)\n{\n\tint err;\n\tint addrcnt = 0;\n\tint walk_size = 0;\n\tstruct sockaddr *sa_addr;\n\tvoid *addr_buf = addrs;\n\tstruct sctp_af *af;\n\n\tpr_debug(\"%s: sk:%p addrs:%p addrs_size:%d opt:%d\\n\",\n\t\t __func__, sk, addr_buf, addrs_size, op);\n\n\tif (unlikely(addrs_size <= 0))\n\t\treturn -EINVAL;\n\n\t \n\twhile (walk_size < addrs_size) {\n\t\tif (walk_size + sizeof(sa_family_t) > addrs_size)\n\t\t\treturn -EINVAL;\n\n\t\tsa_addr = addr_buf;\n\t\taf = sctp_get_af_specific(sa_addr->sa_family);\n\n\t\t \n\t\tif (!af || (walk_size + af->sockaddr_len) > addrs_size)\n\t\t\treturn -EINVAL;\n\t\taddrcnt++;\n\t\taddr_buf += af->sockaddr_len;\n\t\twalk_size += af->sockaddr_len;\n\t}\n\n\t \n\tswitch (op) {\n\tcase SCTP_BINDX_ADD_ADDR:\n\t\t \n\t\terr = security_sctp_bind_connect(sk, SCTP_SOCKOPT_BINDX_ADD,\n\t\t\t\t\t\t addrs, addrs_size);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = sctp_bindx_add(sk, addrs, addrcnt);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn sctp_send_asconf_add_ip(sk, addrs, addrcnt);\n\tcase SCTP_BINDX_REM_ADDR:\n\t\terr = sctp_bindx_rem(sk, addrs, addrcnt);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn sctp_send_asconf_del_ip(sk, addrs, addrcnt);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sctp_bind_add(struct sock *sk, struct sockaddr *addrs,\n\t\tint addrlen)\n{\n\tint err;\n\n\tlock_sock(sk);\n\terr = sctp_setsockopt_bindx(sk, addrs, addrlen, SCTP_BINDX_ADD_ADDR);\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sctp_connect_new_asoc(struct sctp_endpoint *ep,\n\t\t\t\t const union sctp_addr *daddr,\n\t\t\t\t const struct sctp_initmsg *init,\n\t\t\t\t struct sctp_transport **tp)\n{\n\tstruct sctp_association *asoc;\n\tstruct sock *sk = ep->base.sk;\n\tstruct net *net = sock_net(sk);\n\tenum sctp_scope scope;\n\tint err;\n\n\tif (sctp_endpoint_is_peeled_off(ep, daddr))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!ep->base.bind_addr.port) {\n\t\tif (sctp_autobind(sk))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tif (inet_port_requires_bind_service(net, ep->base.bind_addr.port) &&\n\t\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\t\treturn -EACCES;\n\t}\n\n\tscope = sctp_scope(daddr);\n\tasoc = sctp_association_new(ep, sk, scope, GFP_KERNEL);\n\tif (!asoc)\n\t\treturn -ENOMEM;\n\n\terr = sctp_assoc_set_bind_addr_from_ep(asoc, scope, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto free;\n\n\t*tp = sctp_assoc_add_peer(asoc, daddr, GFP_KERNEL, SCTP_UNKNOWN);\n\tif (!*tp) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tif (!init)\n\t\treturn 0;\n\n\tif (init->sinit_num_ostreams) {\n\t\t__u16 outcnt = init->sinit_num_ostreams;\n\n\t\tasoc->c.sinit_num_ostreams = outcnt;\n\t\t \n\t\terr = sctp_stream_init(&asoc->stream, outcnt, 0, GFP_KERNEL);\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\n\tif (init->sinit_max_instreams)\n\t\tasoc->c.sinit_max_instreams = init->sinit_max_instreams;\n\n\tif (init->sinit_max_attempts)\n\t\tasoc->max_init_attempts = init->sinit_max_attempts;\n\n\tif (init->sinit_max_init_timeo)\n\t\tasoc->max_init_timeo =\n\t\t\tmsecs_to_jiffies(init->sinit_max_init_timeo);\n\n\treturn 0;\nfree:\n\tsctp_association_free(asoc);\n\treturn err;\n}\n\nstatic int sctp_connect_add_peer(struct sctp_association *asoc,\n\t\t\t\t union sctp_addr *daddr, int addr_len)\n{\n\tstruct sctp_endpoint *ep = asoc->ep;\n\tstruct sctp_association *old;\n\tstruct sctp_transport *t;\n\tint err;\n\n\terr = sctp_verify_addr(ep->base.sk, daddr, addr_len);\n\tif (err)\n\t\treturn err;\n\n\told = sctp_endpoint_lookup_assoc(ep, daddr, &t);\n\tif (old && old != asoc)\n\t\treturn old->state >= SCTP_STATE_ESTABLISHED ? -EISCONN\n\t\t\t\t\t\t\t    : -EALREADY;\n\n\tif (sctp_endpoint_is_peeled_off(ep, daddr))\n\t\treturn -EADDRNOTAVAIL;\n\n\tt = sctp_assoc_add_peer(asoc, daddr, GFP_KERNEL, SCTP_UNKNOWN);\n\tif (!t)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic int __sctp_connect(struct sock *sk, struct sockaddr *kaddrs,\n\t\t\t  int addrs_size, int flags, sctp_assoc_t *assoc_id)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tstruct sctp_transport *transport;\n\tstruct sctp_association *asoc;\n\tvoid *addr_buf = kaddrs;\n\tunion sctp_addr *daddr;\n\tstruct sctp_af *af;\n\tint walk_size, err;\n\tlong timeo;\n\n\tif (sctp_sstate(sk, ESTABLISHED) || sctp_sstate(sk, CLOSING) ||\n\t    (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING)))\n\t\treturn -EISCONN;\n\n\tdaddr = addr_buf;\n\taf = sctp_get_af_specific(daddr->sa.sa_family);\n\tif (!af || af->sockaddr_len > addrs_size)\n\t\treturn -EINVAL;\n\n\terr = sctp_verify_addr(sk, daddr, af->sockaddr_len);\n\tif (err)\n\t\treturn err;\n\n\tasoc = sctp_endpoint_lookup_assoc(ep, daddr, &transport);\n\tif (asoc)\n\t\treturn asoc->state >= SCTP_STATE_ESTABLISHED ? -EISCONN\n\t\t\t\t\t\t\t     : -EALREADY;\n\n\terr = sctp_connect_new_asoc(ep, daddr, NULL, &transport);\n\tif (err)\n\t\treturn err;\n\tasoc = transport->asoc;\n\n\taddr_buf += af->sockaddr_len;\n\twalk_size = af->sockaddr_len;\n\twhile (walk_size < addrs_size) {\n\t\terr = -EINVAL;\n\t\tif (walk_size + sizeof(sa_family_t) > addrs_size)\n\t\t\tgoto out_free;\n\n\t\tdaddr = addr_buf;\n\t\taf = sctp_get_af_specific(daddr->sa.sa_family);\n\t\tif (!af || af->sockaddr_len + walk_size > addrs_size)\n\t\t\tgoto out_free;\n\n\t\tif (asoc->peer.port != ntohs(daddr->v4.sin_port))\n\t\t\tgoto out_free;\n\n\t\terr = sctp_connect_add_peer(asoc, daddr, af->sockaddr_len);\n\t\tif (err)\n\t\t\tgoto out_free;\n\n\t\taddr_buf  += af->sockaddr_len;\n\t\twalk_size += af->sockaddr_len;\n\t}\n\n\t \n\tif (assoc_id) {\n\t\terr = sctp_assoc_set_id(asoc, GFP_KERNEL);\n\t\tif (err < 0)\n\t\t\tgoto out_free;\n\t}\n\n\terr = sctp_primitive_ASSOCIATE(sock_net(sk), asoc, NULL);\n\tif (err < 0)\n\t\tgoto out_free;\n\n\t \n\tinet_sk(sk)->inet_dport = htons(asoc->peer.port);\n\tsp->pf->to_sk_daddr(daddr, sk);\n\tsk->sk_err = 0;\n\n\tif (assoc_id)\n\t\t*assoc_id = asoc->assoc_id;\n\n\ttimeo = sock_sndtimeo(sk, flags & O_NONBLOCK);\n\treturn sctp_wait_for_connect(asoc, &timeo);\n\nout_free:\n\tpr_debug(\"%s: took out_free path with asoc:%p kaddrs:%p err:%d\\n\",\n\t\t __func__, asoc, kaddrs, err);\n\tsctp_association_free(asoc);\n\treturn err;\n}\n\n \nstatic int __sctp_setsockopt_connectx(struct sock *sk, struct sockaddr *kaddrs,\n\t\t\t\t      int addrs_size, sctp_assoc_t *assoc_id)\n{\n\tint err = 0, flags = 0;\n\n\tpr_debug(\"%s: sk:%p addrs:%p addrs_size:%d\\n\",\n\t\t __func__, sk, kaddrs, addrs_size);\n\n\t \n\tif (unlikely(addrs_size < sizeof(sa_family_t)))\n\t\treturn -EINVAL;\n\n\t \n\terr = security_sctp_bind_connect(sk, SCTP_SOCKOPT_CONNECTX,\n\t\t\t\t\t (struct sockaddr *)kaddrs,\n\t\t\t\t\t  addrs_size);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (sk->sk_socket->file)\n\t\tflags = sk->sk_socket->file->f_flags;\n\n\treturn __sctp_connect(sk, kaddrs, addrs_size, flags, assoc_id);\n}\n\n \nstatic int sctp_setsockopt_connectx_old(struct sock *sk,\n\t\t\t\t\tstruct sockaddr *kaddrs,\n\t\t\t\t\tint addrs_size)\n{\n\treturn __sctp_setsockopt_connectx(sk, kaddrs, addrs_size, NULL);\n}\n\n \nstatic int sctp_setsockopt_connectx(struct sock *sk,\n\t\t\t\t    struct sockaddr *kaddrs,\n\t\t\t\t    int addrs_size)\n{\n\tsctp_assoc_t assoc_id = 0;\n\tint err = 0;\n\n\terr = __sctp_setsockopt_connectx(sk, kaddrs, addrs_size, &assoc_id);\n\n\tif (err)\n\t\treturn err;\n\telse\n\t\treturn assoc_id;\n}\n\n \n#ifdef CONFIG_COMPAT\nstruct compat_sctp_getaddrs_old {\n\tsctp_assoc_t\tassoc_id;\n\ts32\t\taddr_num;\n\tcompat_uptr_t\taddrs;\t\t \n};\n#endif\n\nstatic int sctp_getsockopt_connectx3(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\tstruct sctp_getaddrs_old param;\n\tsctp_assoc_t assoc_id = 0;\n\tstruct sockaddr *kaddrs;\n\tint err = 0;\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sctp_getaddrs_old param32;\n\n\t\tif (len < sizeof(param32))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&param32, optval, sizeof(param32)))\n\t\t\treturn -EFAULT;\n\n\t\tparam.assoc_id = param32.assoc_id;\n\t\tparam.addr_num = param32.addr_num;\n\t\tparam.addrs = compat_ptr(param32.addrs);\n\t} else\n#endif\n\t{\n\t\tif (len < sizeof(param))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&param, optval, sizeof(param)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tkaddrs = memdup_user(param.addrs, param.addr_num);\n\tif (IS_ERR(kaddrs))\n\t\treturn PTR_ERR(kaddrs);\n\n\terr = __sctp_setsockopt_connectx(sk, kaddrs, param.addr_num, &assoc_id);\n\tkfree(kaddrs);\n\tif (err == 0 || err == -EINPROGRESS) {\n\t\tif (copy_to_user(optval, &assoc_id, sizeof(assoc_id)))\n\t\t\treturn -EFAULT;\n\t\tif (put_user(sizeof(assoc_id), optlen))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}\n\n \nstatic void sctp_close(struct sock *sk, long timeout)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *asoc;\n\tstruct list_head *pos, *temp;\n\tunsigned int data_was_unread;\n\n\tpr_debug(\"%s: sk:%p, timeout:%ld\\n\", __func__, sk, timeout);\n\n\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tinet_sk_set_state(sk, SCTP_SS_CLOSING);\n\n\tep = sctp_sk(sk)->ep;\n\n\t \n\tdata_was_unread = sctp_queue_purge_ulpevents(&sk->sk_receive_queue);\n\tdata_was_unread += sctp_queue_purge_ulpevents(&sctp_sk(sk)->pd_lobby);\n\n\t \n\tlist_for_each_safe(pos, temp, &ep->asocs) {\n\t\tasoc = list_entry(pos, struct sctp_association, asocs);\n\n\t\tif (sctp_style(sk, TCP)) {\n\t\t\t \n\t\t\tif (sctp_state(asoc, CLOSED)) {\n\t\t\t\tsctp_association_free(asoc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (data_was_unread || !skb_queue_empty(&asoc->ulpq.lobby) ||\n\t\t    !skb_queue_empty(&asoc->ulpq.reasm) ||\n\t\t    !skb_queue_empty(&asoc->ulpq.reasm_uo) ||\n\t\t    (sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime)) {\n\t\t\tstruct sctp_chunk *chunk;\n\n\t\t\tchunk = sctp_make_abort_user(asoc, NULL, 0);\n\t\t\tsctp_primitive_ABORT(net, asoc, chunk);\n\t\t} else\n\t\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t}\n\n\t \n\tif (sctp_style(sk, TCP) && timeout)\n\t\tsctp_wait_for_close(sk, timeout);\n\n\t \n\trelease_sock(sk);\n\n\t \n\tspin_lock_bh(&net->sctp.addr_wq_lock);\n\tbh_lock_sock_nested(sk);\n\n\t \n\tsock_hold(sk);\n\tsk_common_release(sk);\n\n\tbh_unlock_sock(sk);\n\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n\n\tsock_put(sk);\n\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}\n\n \nstatic int sctp_error(struct sock *sk, int flags, int err)\n{\n\tif (err == -EPIPE)\n\t\terr = sock_error(sk) ? : -EPIPE;\n\tif (err == -EPIPE && !(flags & MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE, current, 0);\n\treturn err;\n}\n\n \n \n\nstatic int sctp_msghdr_parse(const struct msghdr *msg,\n\t\t\t     struct sctp_cmsgs *cmsgs);\n\nstatic int sctp_sendmsg_parse(struct sock *sk, struct sctp_cmsgs *cmsgs,\n\t\t\t      struct sctp_sndrcvinfo *srinfo,\n\t\t\t      const struct msghdr *msg, size_t msg_len)\n{\n\t__u16 sflags;\n\tint err;\n\n\tif (sctp_sstate(sk, LISTENING) && sctp_style(sk, TCP))\n\t\treturn -EPIPE;\n\n\tif (msg_len > sk->sk_sndbuf)\n\t\treturn -EMSGSIZE;\n\n\tmemset(cmsgs, 0, sizeof(*cmsgs));\n\terr = sctp_msghdr_parse(msg, cmsgs);\n\tif (err) {\n\t\tpr_debug(\"%s: msghdr parse err:%x\\n\", __func__, err);\n\t\treturn err;\n\t}\n\n\tmemset(srinfo, 0, sizeof(*srinfo));\n\tif (cmsgs->srinfo) {\n\t\tsrinfo->sinfo_stream = cmsgs->srinfo->sinfo_stream;\n\t\tsrinfo->sinfo_flags = cmsgs->srinfo->sinfo_flags;\n\t\tsrinfo->sinfo_ppid = cmsgs->srinfo->sinfo_ppid;\n\t\tsrinfo->sinfo_context = cmsgs->srinfo->sinfo_context;\n\t\tsrinfo->sinfo_assoc_id = cmsgs->srinfo->sinfo_assoc_id;\n\t\tsrinfo->sinfo_timetolive = cmsgs->srinfo->sinfo_timetolive;\n\t}\n\n\tif (cmsgs->sinfo) {\n\t\tsrinfo->sinfo_stream = cmsgs->sinfo->snd_sid;\n\t\tsrinfo->sinfo_flags = cmsgs->sinfo->snd_flags;\n\t\tsrinfo->sinfo_ppid = cmsgs->sinfo->snd_ppid;\n\t\tsrinfo->sinfo_context = cmsgs->sinfo->snd_context;\n\t\tsrinfo->sinfo_assoc_id = cmsgs->sinfo->snd_assoc_id;\n\t}\n\n\tif (cmsgs->prinfo) {\n\t\tsrinfo->sinfo_timetolive = cmsgs->prinfo->pr_value;\n\t\tSCTP_PR_SET_POLICY(srinfo->sinfo_flags,\n\t\t\t\t   cmsgs->prinfo->pr_policy);\n\t}\n\n\tsflags = srinfo->sinfo_flags;\n\tif (!sflags && msg_len)\n\t\treturn 0;\n\n\tif (sctp_style(sk, TCP) && (sflags & (SCTP_EOF | SCTP_ABORT)))\n\t\treturn -EINVAL;\n\n\tif (((sflags & SCTP_EOF) && msg_len > 0) ||\n\t    (!(sflags & (SCTP_EOF | SCTP_ABORT)) && msg_len == 0))\n\t\treturn -EINVAL;\n\n\tif ((sflags & SCTP_ADDR_OVER) && !msg->msg_name)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sctp_sendmsg_new_asoc(struct sock *sk, __u16 sflags,\n\t\t\t\t struct sctp_cmsgs *cmsgs,\n\t\t\t\t union sctp_addr *daddr,\n\t\t\t\t struct sctp_transport **tp)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_association *asoc;\n\tstruct cmsghdr *cmsg;\n\t__be32 flowinfo = 0;\n\tstruct sctp_af *af;\n\tint err;\n\n\t*tp = NULL;\n\n\tif (sflags & (SCTP_EOF | SCTP_ABORT))\n\t\treturn -EINVAL;\n\n\tif (sctp_style(sk, TCP) && (sctp_sstate(sk, ESTABLISHED) ||\n\t\t\t\t    sctp_sstate(sk, CLOSING)))\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\taf = sctp_get_af_specific(daddr->sa.sa_family);\n\tif (!af)\n\t\treturn -EINVAL;\n\terr = security_sctp_bind_connect(sk, SCTP_SENDMSG_CONNECT,\n\t\t\t\t\t (struct sockaddr *)daddr,\n\t\t\t\t\t af->sockaddr_len);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = sctp_connect_new_asoc(ep, daddr, cmsgs->init, tp);\n\tif (err)\n\t\treturn err;\n\tasoc = (*tp)->asoc;\n\n\tif (!cmsgs->addrs_msg)\n\t\treturn 0;\n\n\tif (daddr->sa.sa_family == AF_INET6)\n\t\tflowinfo = daddr->v6.sin6_flowinfo;\n\n\t \n\tfor_each_cmsghdr(cmsg, cmsgs->addrs_msg) {\n\t\tunion sctp_addr _daddr;\n\t\tint dlen;\n\n\t\tif (cmsg->cmsg_level != IPPROTO_SCTP ||\n\t\t    (cmsg->cmsg_type != SCTP_DSTADDRV4 &&\n\t\t     cmsg->cmsg_type != SCTP_DSTADDRV6))\n\t\t\tcontinue;\n\n\t\tdaddr = &_daddr;\n\t\tmemset(daddr, 0, sizeof(*daddr));\n\t\tdlen = cmsg->cmsg_len - sizeof(struct cmsghdr);\n\t\tif (cmsg->cmsg_type == SCTP_DSTADDRV4) {\n\t\t\tif (dlen < sizeof(struct in_addr)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tdlen = sizeof(struct in_addr);\n\t\t\tdaddr->v4.sin_family = AF_INET;\n\t\t\tdaddr->v4.sin_port = htons(asoc->peer.port);\n\t\t\tmemcpy(&daddr->v4.sin_addr, CMSG_DATA(cmsg), dlen);\n\t\t} else {\n\t\t\tif (dlen < sizeof(struct in6_addr)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tdlen = sizeof(struct in6_addr);\n\t\t\tdaddr->v6.sin6_flowinfo = flowinfo;\n\t\t\tdaddr->v6.sin6_family = AF_INET6;\n\t\t\tdaddr->v6.sin6_port = htons(asoc->peer.port);\n\t\t\tmemcpy(&daddr->v6.sin6_addr, CMSG_DATA(cmsg), dlen);\n\t\t}\n\n\t\terr = sctp_connect_add_peer(asoc, daddr, sizeof(*daddr));\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\n\treturn 0;\n\nfree:\n\tsctp_association_free(asoc);\n\treturn err;\n}\n\nstatic int sctp_sendmsg_check_sflags(struct sctp_association *asoc,\n\t\t\t\t     __u16 sflags, struct msghdr *msg,\n\t\t\t\t     size_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\n\tif (sctp_state(asoc, CLOSED) && sctp_style(sk, TCP))\n\t\treturn -EPIPE;\n\n\tif ((sflags & SCTP_SENDALL) && sctp_style(sk, UDP) &&\n\t    !sctp_state(asoc, ESTABLISHED))\n\t\treturn 0;\n\n\tif (sflags & SCTP_EOF) {\n\t\tpr_debug(\"%s: shutting down association:%p\\n\", __func__, asoc);\n\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\n\t\treturn 0;\n\t}\n\n\tif (sflags & SCTP_ABORT) {\n\t\tstruct sctp_chunk *chunk;\n\n\t\tchunk = sctp_make_abort_user(asoc, msg, msg_len);\n\t\tif (!chunk)\n\t\t\treturn -ENOMEM;\n\n\t\tpr_debug(\"%s: aborting association:%p\\n\", __func__, asoc);\n\t\tsctp_primitive_ABORT(net, asoc, chunk);\n\t\tiov_iter_revert(&msg->msg_iter, msg_len);\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int sctp_sendmsg_to_asoc(struct sctp_association *asoc,\n\t\t\t\tstruct msghdr *msg, size_t msg_len,\n\t\t\t\tstruct sctp_transport *transport,\n\t\t\t\tstruct sctp_sndrcvinfo *sinfo)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_datamsg *datamsg;\n\tbool wait_connect = false;\n\tstruct sctp_chunk *chunk;\n\tlong timeo;\n\tint err;\n\n\tif (sinfo->sinfo_stream >= asoc->stream.outcnt) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (unlikely(!SCTP_SO(&asoc->stream, sinfo->sinfo_stream)->ext)) {\n\t\terr = sctp_stream_init_ext(&asoc->stream, sinfo->sinfo_stream);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tif (sp->disable_fragments && msg_len > asoc->frag_point) {\n\t\terr = -EMSGSIZE;\n\t\tgoto err;\n\t}\n\n\tif (asoc->pmtu_pending) {\n\t\tif (sp->param_flags & SPP_PMTUD_ENABLE)\n\t\t\tsctp_assoc_sync_pmtu(asoc);\n\t\tasoc->pmtu_pending = 0;\n\t}\n\n\tif (sctp_wspace(asoc) < (int)msg_len)\n\t\tsctp_prsctp_prune(asoc, sinfo, msg_len - sctp_wspace(asoc));\n\n\tif (sctp_wspace(asoc) <= 0 || !sk_wmem_schedule(sk, msg_len)) {\n\t\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\t\terr = sctp_wait_for_sndbuf(asoc, &timeo, msg_len);\n\t\tif (err)\n\t\t\tgoto err;\n\t\tif (unlikely(sinfo->sinfo_stream >= asoc->stream.outcnt)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (sctp_state(asoc, CLOSED)) {\n\t\terr = sctp_primitive_ASSOCIATE(net, asoc, NULL);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tif (asoc->ep->intl_enable) {\n\t\t\ttimeo = sock_sndtimeo(sk, 0);\n\t\t\terr = sctp_wait_for_connect(asoc, &timeo);\n\t\t\tif (err) {\n\t\t\t\terr = -ESRCH;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\twait_connect = true;\n\t\t}\n\n\t\tpr_debug(\"%s: we associated primitively\\n\", __func__);\n\t}\n\n\tdatamsg = sctp_datamsg_from_user(asoc, sinfo, &msg->msg_iter);\n\tif (IS_ERR(datamsg)) {\n\t\terr = PTR_ERR(datamsg);\n\t\tgoto err;\n\t}\n\n\tasoc->force_delay = !!(msg->msg_flags & MSG_MORE);\n\n\tlist_for_each_entry(chunk, &datamsg->chunks, frag_list) {\n\t\tsctp_chunk_hold(chunk);\n\t\tsctp_set_owner_w(chunk);\n\t\tchunk->transport = transport;\n\t}\n\n\terr = sctp_primitive_SEND(net, asoc, datamsg);\n\tif (err) {\n\t\tsctp_datamsg_free(datamsg);\n\t\tgoto err;\n\t}\n\n\tpr_debug(\"%s: we sent primitively\\n\", __func__);\n\n\tsctp_datamsg_put(datamsg);\n\n\tif (unlikely(wait_connect)) {\n\t\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\t\tsctp_wait_for_connect(asoc, &timeo);\n\t}\n\n\terr = msg_len;\n\nerr:\n\treturn err;\n}\n\nstatic union sctp_addr *sctp_sendmsg_get_daddr(struct sock *sk,\n\t\t\t\t\t       const struct msghdr *msg,\n\t\t\t\t\t       struct sctp_cmsgs *cmsgs)\n{\n\tunion sctp_addr *daddr = NULL;\n\tint err;\n\n\tif (!sctp_style(sk, UDP_HIGH_BANDWIDTH) && msg->msg_name) {\n\t\tint len = msg->msg_namelen;\n\n\t\tif (len > sizeof(*daddr))\n\t\t\tlen = sizeof(*daddr);\n\n\t\tdaddr = (union sctp_addr *)msg->msg_name;\n\n\t\terr = sctp_verify_addr(sk, daddr, len);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\treturn daddr;\n}\n\nstatic void sctp_sendmsg_update_sinfo(struct sctp_association *asoc,\n\t\t\t\t      struct sctp_sndrcvinfo *sinfo,\n\t\t\t\t      struct sctp_cmsgs *cmsgs)\n{\n\tif (!cmsgs->srinfo && !cmsgs->sinfo) {\n\t\tsinfo->sinfo_stream = asoc->default_stream;\n\t\tsinfo->sinfo_ppid = asoc->default_ppid;\n\t\tsinfo->sinfo_context = asoc->default_context;\n\t\tsinfo->sinfo_assoc_id = sctp_assoc2id(asoc);\n\n\t\tif (!cmsgs->prinfo)\n\t\t\tsinfo->sinfo_flags = asoc->default_flags;\n\t}\n\n\tif (!cmsgs->srinfo && !cmsgs->prinfo)\n\t\tsinfo->sinfo_timetolive = asoc->default_timetolive;\n\n\tif (cmsgs->authinfo) {\n\t\t \n\t\tsinfo->sinfo_tsn = 1;\n\t\tsinfo->sinfo_ssn = cmsgs->authinfo->auth_keynumber;\n\t}\n}\n\nstatic int sctp_sendmsg(struct sock *sk, struct msghdr *msg, size_t msg_len)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_transport *transport = NULL;\n\tstruct sctp_sndrcvinfo _sinfo, *sinfo;\n\tstruct sctp_association *asoc, *tmp;\n\tstruct sctp_cmsgs cmsgs;\n\tunion sctp_addr *daddr;\n\tbool new = false;\n\t__u16 sflags;\n\tint err;\n\n\t \n\terr = sctp_sendmsg_parse(sk, &cmsgs, &_sinfo, msg, msg_len);\n\tif (err)\n\t\tgoto out;\n\n\tsinfo  = &_sinfo;\n\tsflags = sinfo->sinfo_flags;\n\n\t \n\tdaddr = sctp_sendmsg_get_daddr(sk, msg, &cmsgs);\n\tif (IS_ERR(daddr)) {\n\t\terr = PTR_ERR(daddr);\n\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\n\t \n\tif ((sflags & SCTP_SENDALL) && sctp_style(sk, UDP)) {\n\t\tlist_for_each_entry_safe(asoc, tmp, &ep->asocs, asocs) {\n\t\t\terr = sctp_sendmsg_check_sflags(asoc, sflags, msg,\n\t\t\t\t\t\t\tmsg_len);\n\t\t\tif (err == 0)\n\t\t\t\tcontinue;\n\t\t\tif (err < 0)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tsctp_sendmsg_update_sinfo(asoc, sinfo, &cmsgs);\n\n\t\t\terr = sctp_sendmsg_to_asoc(asoc, msg, msg_len,\n\t\t\t\t\t\t   NULL, sinfo);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tiov_iter_revert(&msg->msg_iter, err);\n\t\t}\n\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (daddr) {\n\t\tasoc = sctp_endpoint_lookup_assoc(ep, daddr, &transport);\n\t\tif (asoc) {\n\t\t\terr = sctp_sendmsg_check_sflags(asoc, sflags, msg,\n\t\t\t\t\t\t\tmsg_len);\n\t\t\tif (err <= 0)\n\t\t\t\tgoto out_unlock;\n\t\t} else {\n\t\t\terr = sctp_sendmsg_new_asoc(sk, sflags, &cmsgs, daddr,\n\t\t\t\t\t\t    &transport);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tasoc = transport->asoc;\n\t\t\tnew = true;\n\t\t}\n\n\t\tif (!sctp_style(sk, TCP) && !(sflags & SCTP_ADDR_OVER))\n\t\t\ttransport = NULL;\n\t} else {\n\t\tasoc = sctp_id2assoc(sk, sinfo->sinfo_assoc_id);\n\t\tif (!asoc) {\n\t\t\terr = -EPIPE;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terr = sctp_sendmsg_check_sflags(asoc, sflags, msg, msg_len);\n\t\tif (err <= 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\t \n\tsctp_sendmsg_update_sinfo(asoc, sinfo, &cmsgs);\n\n\t \n\terr = sctp_sendmsg_to_asoc(asoc, msg, msg_len, transport, sinfo);\n\tif (err < 0 && err != -ESRCH && new)\n\t\tsctp_association_free(asoc);\n\nout_unlock:\n\trelease_sock(sk);\nout:\n\treturn sctp_error(sk, msg->msg_flags, err);\n}\n\n \nstatic int sctp_skb_pull(struct sk_buff *skb, int len)\n{\n\tstruct sk_buff *list;\n\tint skb_len = skb_headlen(skb);\n\tint rlen;\n\n\tif (len <= skb_len) {\n\t\t__skb_pull(skb, len);\n\t\treturn 0;\n\t}\n\tlen -= skb_len;\n\t__skb_pull(skb, skb_len);\n\n\tskb_walk_frags(skb, list) {\n\t\trlen = sctp_skb_pull(list, len);\n\t\tskb->len -= (len-rlen);\n\t\tskb->data_len -= (len-rlen);\n\n\t\tif (!rlen)\n\t\t\treturn 0;\n\n\t\tlen = rlen;\n\t}\n\n\treturn len;\n}\n\n \nstatic int sctp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\tint flags, int *addr_len)\n{\n\tstruct sctp_ulpevent *event = NULL;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sk_buff *skb, *head_skb;\n\tint copied;\n\tint err = 0;\n\tint skb_len;\n\n\tpr_debug(\"%s: sk:%p, msghdr:%p, len:%zd, flags:0x%x, addr_len:%p)\\n\",\n\t\t __func__, sk, msg, len, flags, addr_len);\n\n\tif (unlikely(flags & MSG_ERRQUEUE))\n\t\treturn inet_recv_error(sk, msg, len, addr_len);\n\n\tif (sk_can_busy_loop(sk) &&\n\t    skb_queue_empty_lockless(&sk->sk_receive_queue))\n\t\tsk_busy_loop(sk, flags & MSG_DONTWAIT);\n\n\tlock_sock(sk);\n\n\tif (sctp_style(sk, TCP) && !sctp_sstate(sk, ESTABLISHED) &&\n\t    !sctp_sstate(sk, CLOSING) && !sctp_sstate(sk, CLOSED)) {\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tskb = sctp_skb_recv_datagram(sk, flags, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\t \n\tskb_len = skb->len;\n\n\tcopied = skb_len;\n\tif (copied > len)\n\t\tcopied = len;\n\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\n\tevent = sctp_skb2event(skb);\n\n\tif (err)\n\t\tgoto out_free;\n\n\tif (event->chunk && event->chunk->head_skb)\n\t\thead_skb = event->chunk->head_skb;\n\telse\n\t\thead_skb = skb;\n\tsock_recv_cmsgs(msg, sk, head_skb);\n\tif (sctp_ulpevent_is_notification(event)) {\n\t\tmsg->msg_flags |= MSG_NOTIFICATION;\n\t\tsp->pf->event_msgname(event, msg->msg_name, addr_len);\n\t} else {\n\t\tsp->pf->skb_msgname(head_skb, msg->msg_name, addr_len);\n\t}\n\n\t \n\tif (sp->recvnxtinfo)\n\t\tsctp_ulpevent_read_nxtinfo(event, msg, sk);\n\t \n\tif (sp->recvrcvinfo)\n\t\tsctp_ulpevent_read_rcvinfo(event, msg);\n\t \n\tif (sctp_ulpevent_type_enabled(sp->subscribe, SCTP_DATA_IO_EVENT))\n\t\tsctp_ulpevent_read_sndrcvinfo(event, msg);\n\n\terr = copied;\n\n\t \n\tif (skb_len > copied) {\n\t\tmsg->msg_flags &= ~MSG_EOR;\n\t\tif (flags & MSG_PEEK)\n\t\t\tgoto out_free;\n\t\tsctp_skb_pull(skb, copied);\n\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\t\t \n\t\tif (!sctp_ulpevent_is_notification(event))\n\t\t\tsctp_assoc_rwnd_increase(event->asoc, copied);\n\t\tgoto out;\n\t} else if ((event->msg_flags & MSG_NOTIFICATION) ||\n\t\t   (event->msg_flags & MSG_EOR))\n\t\tmsg->msg_flags |= MSG_EOR;\n\telse\n\t\tmsg->msg_flags &= ~MSG_EOR;\n\nout_free:\n\tif (flags & MSG_PEEK) {\n\t\t \n\t\tkfree_skb(skb);\n\t} else {\n\t\t \n\t\tsctp_ulpevent_free(event);\n\t}\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n \nstatic int sctp_setsockopt_disable_fragments(struct sock *sk, int *val,\n\t\t\t\t\t     unsigned int optlen)\n{\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tsctp_sk(sk)->disable_fragments = (*val == 0) ? 0 : 1;\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_events(struct sock *sk, __u8 *sn_type,\n\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tint i;\n\n\tif (optlen > sizeof(struct sctp_event_subscribe))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < optlen; i++)\n\t\tsctp_ulpevent_type_set(&sp->subscribe, SCTP_SN_TYPE_BASE + i,\n\t\t\t\t       sn_type[i]);\n\n\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs)\n\t\tasoc->subscribe = sctp_sk(sk)->subscribe;\n\n\t \n\tif (sctp_ulpevent_type_enabled(sp->subscribe, SCTP_SENDER_DRY_EVENT)) {\n\t\tstruct sctp_ulpevent *event;\n\n\t\tasoc = sctp_id2assoc(sk, 0);\n\t\tif (asoc && sctp_outq_is_empty(&asoc->outqueue)) {\n\t\t\tevent = sctp_ulpevent_make_sender_dry_event(asoc,\n\t\t\t\t\tGFP_USER | __GFP_NOWARN);\n\t\t\tif (!event)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, event);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_autoclose(struct sock *sk, u32 *optval,\n\t\t\t\t     unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\n\t \n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\tif (optlen != sizeof(int))\n\t\treturn -EINVAL;\n\n\tsp->autoclose = *optval;\n\tif (sp->autoclose > net->sctp.max_autoclose)\n\t\tsp->autoclose = net->sctp.max_autoclose;\n\n\treturn 0;\n}\n\n \nstatic int sctp_apply_peer_addr_params(struct sctp_paddrparams *params,\n\t\t\t\t       struct sctp_transport   *trans,\n\t\t\t\t       struct sctp_association *asoc,\n\t\t\t\t       struct sctp_sock        *sp,\n\t\t\t\t       int                      hb_change,\n\t\t\t\t       int                      pmtud_change,\n\t\t\t\t       int                      sackdelay_change)\n{\n\tint error;\n\n\tif (params->spp_flags & SPP_HB_DEMAND && trans) {\n\t\terror = sctp_primitive_REQUESTHEARTBEAT(trans->asoc->base.net,\n\t\t\t\t\t\t\ttrans->asoc, trans);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t \n\tif (params->spp_flags & SPP_HB_ENABLE) {\n\n\t\t \n\t\tif (params->spp_flags & SPP_HB_TIME_IS_ZERO)\n\t\t\tparams->spp_hbinterval = 0;\n\n\t\tif (params->spp_hbinterval ||\n\t\t    (params->spp_flags & SPP_HB_TIME_IS_ZERO)) {\n\t\t\tif (trans) {\n\t\t\t\ttrans->hbinterval =\n\t\t\t\t    msecs_to_jiffies(params->spp_hbinterval);\n\t\t\t\tsctp_transport_reset_hb_timer(trans);\n\t\t\t} else if (asoc) {\n\t\t\t\tasoc->hbinterval =\n\t\t\t\t    msecs_to_jiffies(params->spp_hbinterval);\n\t\t\t} else {\n\t\t\t\tsp->hbinterval = params->spp_hbinterval;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hb_change) {\n\t\tif (trans) {\n\t\t\ttrans->param_flags =\n\t\t\t\t(trans->param_flags & ~SPP_HB) | hb_change;\n\t\t} else if (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\t(asoc->param_flags & ~SPP_HB) | hb_change;\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\t(sp->param_flags & ~SPP_HB) | hb_change;\n\t\t}\n\t}\n\n\t \n\tif ((params->spp_flags & SPP_PMTUD_DISABLE) && params->spp_pathmtu) {\n\t\tif (trans) {\n\t\t\ttrans->pathmtu = params->spp_pathmtu;\n\t\t\tsctp_assoc_sync_pmtu(asoc);\n\t\t} else if (asoc) {\n\t\t\tsctp_assoc_set_pmtu(asoc, params->spp_pathmtu);\n\t\t} else {\n\t\t\tsp->pathmtu = params->spp_pathmtu;\n\t\t}\n\t}\n\n\tif (pmtud_change) {\n\t\tif (trans) {\n\t\t\tint update = (trans->param_flags & SPP_PMTUD_DISABLE) &&\n\t\t\t\t(params->spp_flags & SPP_PMTUD_ENABLE);\n\t\t\ttrans->param_flags =\n\t\t\t\t(trans->param_flags & ~SPP_PMTUD) | pmtud_change;\n\t\t\tif (update) {\n\t\t\t\tsctp_transport_pmtu(trans, sctp_opt2sk(sp));\n\t\t\t\tsctp_assoc_sync_pmtu(asoc);\n\t\t\t}\n\t\t\tsctp_transport_pl_reset(trans);\n\t\t} else if (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\t(asoc->param_flags & ~SPP_PMTUD) | pmtud_change;\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\t(sp->param_flags & ~SPP_PMTUD) | pmtud_change;\n\t\t}\n\t}\n\n\t \n\tif ((params->spp_flags & SPP_SACKDELAY_ENABLE) && params->spp_sackdelay) {\n\t\tif (trans) {\n\t\t\ttrans->sackdelay =\n\t\t\t\tmsecs_to_jiffies(params->spp_sackdelay);\n\t\t} else if (asoc) {\n\t\t\tasoc->sackdelay =\n\t\t\t\tmsecs_to_jiffies(params->spp_sackdelay);\n\t\t} else {\n\t\t\tsp->sackdelay = params->spp_sackdelay;\n\t\t}\n\t}\n\n\tif (sackdelay_change) {\n\t\tif (trans) {\n\t\t\ttrans->param_flags =\n\t\t\t\t(trans->param_flags & ~SPP_SACKDELAY) |\n\t\t\t\tsackdelay_change;\n\t\t} else if (asoc) {\n\t\t\tasoc->param_flags =\n\t\t\t\t(asoc->param_flags & ~SPP_SACKDELAY) |\n\t\t\t\tsackdelay_change;\n\t\t} else {\n\t\t\tsp->param_flags =\n\t\t\t\t(sp->param_flags & ~SPP_SACKDELAY) |\n\t\t\t\tsackdelay_change;\n\t\t}\n\t}\n\n\t \n\tif (params->spp_pathmaxrxt) {\n\t\tif (trans) {\n\t\t\ttrans->pathmaxrxt = params->spp_pathmaxrxt;\n\t\t} else if (asoc) {\n\t\t\tasoc->pathmaxrxt = params->spp_pathmaxrxt;\n\t\t} else {\n\t\t\tsp->pathmaxrxt = params->spp_pathmaxrxt;\n\t\t}\n\t}\n\n\tif (params->spp_flags & SPP_IPV6_FLOWLABEL) {\n\t\tif (trans) {\n\t\t\tif (trans->ipaddr.sa.sa_family == AF_INET6) {\n\t\t\t\ttrans->flowlabel = params->spp_ipv6_flowlabel &\n\t\t\t\t\t\t   SCTP_FLOWLABEL_VAL_MASK;\n\t\t\t\ttrans->flowlabel |= SCTP_FLOWLABEL_SET_MASK;\n\t\t\t}\n\t\t} else if (asoc) {\n\t\t\tstruct sctp_transport *t;\n\n\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t\t    transports) {\n\t\t\t\tif (t->ipaddr.sa.sa_family != AF_INET6)\n\t\t\t\t\tcontinue;\n\t\t\t\tt->flowlabel = params->spp_ipv6_flowlabel &\n\t\t\t\t\t       SCTP_FLOWLABEL_VAL_MASK;\n\t\t\t\tt->flowlabel |= SCTP_FLOWLABEL_SET_MASK;\n\t\t\t}\n\t\t\tasoc->flowlabel = params->spp_ipv6_flowlabel &\n\t\t\t\t\t  SCTP_FLOWLABEL_VAL_MASK;\n\t\t\tasoc->flowlabel |= SCTP_FLOWLABEL_SET_MASK;\n\t\t} else if (sctp_opt2sk(sp)->sk_family == AF_INET6) {\n\t\t\tsp->flowlabel = params->spp_ipv6_flowlabel &\n\t\t\t\t\tSCTP_FLOWLABEL_VAL_MASK;\n\t\t\tsp->flowlabel |= SCTP_FLOWLABEL_SET_MASK;\n\t\t}\n\t}\n\n\tif (params->spp_flags & SPP_DSCP) {\n\t\tif (trans) {\n\t\t\ttrans->dscp = params->spp_dscp & SCTP_DSCP_VAL_MASK;\n\t\t\ttrans->dscp |= SCTP_DSCP_SET_MASK;\n\t\t} else if (asoc) {\n\t\t\tstruct sctp_transport *t;\n\n\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t\t    transports) {\n\t\t\t\tt->dscp = params->spp_dscp &\n\t\t\t\t\t  SCTP_DSCP_VAL_MASK;\n\t\t\t\tt->dscp |= SCTP_DSCP_SET_MASK;\n\t\t\t}\n\t\t\tasoc->dscp = params->spp_dscp & SCTP_DSCP_VAL_MASK;\n\t\t\tasoc->dscp |= SCTP_DSCP_SET_MASK;\n\t\t} else {\n\t\t\tsp->dscp = params->spp_dscp & SCTP_DSCP_VAL_MASK;\n\t\t\tsp->dscp |= SCTP_DSCP_SET_MASK;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_peer_addr_params(struct sock *sk,\n\t\t\t\t\t    struct sctp_paddrparams *params,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_transport   *trans = NULL;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\tint error;\n\tint hb_change, pmtud_change, sackdelay_change;\n\n\tif (optlen == ALIGN(offsetof(struct sctp_paddrparams,\n\t\t\t\t\t    spp_ipv6_flowlabel), 4)) {\n\t\tif (params->spp_flags & (SPP_DSCP | SPP_IPV6_FLOWLABEL))\n\t\t\treturn -EINVAL;\n\t} else if (optlen != sizeof(*params)) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thb_change        = params->spp_flags & SPP_HB;\n\tpmtud_change     = params->spp_flags & SPP_PMTUD;\n\tsackdelay_change = params->spp_flags & SPP_SACKDELAY;\n\n\tif (hb_change        == SPP_HB ||\n\t    pmtud_change     == SPP_PMTUD ||\n\t    sackdelay_change == SPP_SACKDELAY ||\n\t    params->spp_sackdelay > 500 ||\n\t    (params->spp_pathmtu &&\n\t     params->spp_pathmtu < SCTP_DEFAULT_MINSEGMENT))\n\t\treturn -EINVAL;\n\n\t \n\tif (!sctp_is_any(sk, (union sctp_addr *)&params->spp_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &params->spp_address,\n\t\t\t\t\t       params->spp_assoc_id);\n\t\tif (!trans)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tasoc = sctp_id2assoc(sk, params->spp_assoc_id);\n\tif (!asoc && params->spp_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t \n\tif (params->spp_flags & SPP_HB_DEMAND && !trans && !asoc)\n\t\treturn -EINVAL;\n\n\t \n\terror = sctp_apply_peer_addr_params(params, trans, asoc, sp,\n\t\t\t\t\t    hb_change, pmtud_change,\n\t\t\t\t\t    sackdelay_change);\n\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (!trans && asoc) {\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tsctp_apply_peer_addr_params(params, trans, asoc, sp,\n\t\t\t\t\t\t    hb_change, pmtud_change,\n\t\t\t\t\t\t    sackdelay_change);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline __u32 sctp_spp_sackdelay_enable(__u32 param_flags)\n{\n\treturn (param_flags & ~SPP_SACKDELAY) | SPP_SACKDELAY_ENABLE;\n}\n\nstatic inline __u32 sctp_spp_sackdelay_disable(__u32 param_flags)\n{\n\treturn (param_flags & ~SPP_SACKDELAY) | SPP_SACKDELAY_DISABLE;\n}\n\nstatic void sctp_apply_asoc_delayed_ack(struct sctp_sack_info *params,\n\t\t\t\t\tstruct sctp_association *asoc)\n{\n\tstruct sctp_transport *trans;\n\n\tif (params->sack_delay) {\n\t\tasoc->sackdelay = msecs_to_jiffies(params->sack_delay);\n\t\tasoc->param_flags =\n\t\t\tsctp_spp_sackdelay_enable(asoc->param_flags);\n\t}\n\tif (params->sack_freq == 1) {\n\t\tasoc->param_flags =\n\t\t\tsctp_spp_sackdelay_disable(asoc->param_flags);\n\t} else if (params->sack_freq > 1) {\n\t\tasoc->sackfreq = params->sack_freq;\n\t\tasoc->param_flags =\n\t\t\tsctp_spp_sackdelay_enable(asoc->param_flags);\n\t}\n\n\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t    transports) {\n\t\tif (params->sack_delay) {\n\t\t\ttrans->sackdelay = msecs_to_jiffies(params->sack_delay);\n\t\t\ttrans->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(trans->param_flags);\n\t\t}\n\t\tif (params->sack_freq == 1) {\n\t\t\ttrans->param_flags =\n\t\t\t\tsctp_spp_sackdelay_disable(trans->param_flags);\n\t\t} else if (params->sack_freq > 1) {\n\t\t\ttrans->sackfreq = params->sack_freq;\n\t\t\ttrans->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(trans->param_flags);\n\t\t}\n\t}\n}\n\n \nstatic int __sctp_setsockopt_delayed_ack(struct sock *sk,\n\t\t\t\t\t struct sctp_sack_info *params)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\n\t \n\tif (params->sack_delay > 500)\n\t\treturn -EINVAL;\n\n\t \n\tasoc = sctp_id2assoc(sk, params->sack_assoc_id);\n\tif (!asoc && params->sack_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tsctp_apply_asoc_delayed_ack(params, asoc);\n\n\t\treturn 0;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tparams->sack_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (params->sack_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    params->sack_assoc_id == SCTP_ALL_ASSOC) {\n\t\tif (params->sack_delay) {\n\t\t\tsp->sackdelay = params->sack_delay;\n\t\t\tsp->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(sp->param_flags);\n\t\t}\n\t\tif (params->sack_freq == 1) {\n\t\t\tsp->param_flags =\n\t\t\t\tsctp_spp_sackdelay_disable(sp->param_flags);\n\t\t} else if (params->sack_freq > 1) {\n\t\t\tsp->sackfreq = params->sack_freq;\n\t\t\tsp->param_flags =\n\t\t\t\tsctp_spp_sackdelay_enable(sp->param_flags);\n\t\t}\n\t}\n\n\tif (params->sack_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    params->sack_assoc_id == SCTP_ALL_ASSOC)\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs)\n\t\t\tsctp_apply_asoc_delayed_ack(params, asoc);\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_delayed_ack(struct sock *sk,\n\t\t\t\t       struct sctp_sack_info *params,\n\t\t\t\t       unsigned int optlen)\n{\n\tif (optlen == sizeof(struct sctp_assoc_value)) {\n\t\tstruct sctp_assoc_value *v = (struct sctp_assoc_value *)params;\n\t\tstruct sctp_sack_info p;\n\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of struct sctp_assoc_value in delayed_ack socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_sack_info instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\n\t\tp.sack_assoc_id = v->assoc_id;\n\t\tp.sack_delay = v->assoc_value;\n\t\tp.sack_freq = v->assoc_value ? 0 : 1;\n\t\treturn __sctp_setsockopt_delayed_ack(sk, &p);\n\t}\n\n\tif (optlen != sizeof(struct sctp_sack_info))\n\t\treturn -EINVAL;\n\tif (params->sack_delay == 0 && params->sack_freq == 0)\n\t\treturn 0;\n\treturn __sctp_setsockopt_delayed_ack(sk, params);\n}\n\n \nstatic int sctp_setsockopt_initmsg(struct sock *sk, struct sctp_initmsg *sinit,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen != sizeof(struct sctp_initmsg))\n\t\treturn -EINVAL;\n\n\tif (sinit->sinit_num_ostreams)\n\t\tsp->initmsg.sinit_num_ostreams = sinit->sinit_num_ostreams;\n\tif (sinit->sinit_max_instreams)\n\t\tsp->initmsg.sinit_max_instreams = sinit->sinit_max_instreams;\n\tif (sinit->sinit_max_attempts)\n\t\tsp->initmsg.sinit_max_attempts = sinit->sinit_max_attempts;\n\tif (sinit->sinit_max_init_timeo)\n\t\tsp->initmsg.sinit_max_init_timeo = sinit->sinit_max_init_timeo;\n\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_default_send_param(struct sock *sk,\n\t\t\t\t\t      struct sctp_sndrcvinfo *info,\n\t\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(*info))\n\t\treturn -EINVAL;\n\tif (info->sinfo_flags &\n\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t      SCTP_ABORT | SCTP_EOF))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, info->sinfo_assoc_id);\n\tif (!asoc && info->sinfo_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tasoc->default_stream = info->sinfo_stream;\n\t\tasoc->default_flags = info->sinfo_flags;\n\t\tasoc->default_ppid = info->sinfo_ppid;\n\t\tasoc->default_context = info->sinfo_context;\n\t\tasoc->default_timetolive = info->sinfo_timetolive;\n\n\t\treturn 0;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tinfo->sinfo_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (info->sinfo_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    info->sinfo_assoc_id == SCTP_ALL_ASSOC) {\n\t\tsp->default_stream = info->sinfo_stream;\n\t\tsp->default_flags = info->sinfo_flags;\n\t\tsp->default_ppid = info->sinfo_ppid;\n\t\tsp->default_context = info->sinfo_context;\n\t\tsp->default_timetolive = info->sinfo_timetolive;\n\t}\n\n\tif (info->sinfo_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    info->sinfo_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs) {\n\t\t\tasoc->default_stream = info->sinfo_stream;\n\t\t\tasoc->default_flags = info->sinfo_flags;\n\t\t\tasoc->default_ppid = info->sinfo_ppid;\n\t\t\tasoc->default_context = info->sinfo_context;\n\t\t\tasoc->default_timetolive = info->sinfo_timetolive;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_default_sndinfo(struct sock *sk,\n\t\t\t\t\t   struct sctp_sndinfo *info,\n\t\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(*info))\n\t\treturn -EINVAL;\n\tif (info->snd_flags &\n\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t      SCTP_ABORT | SCTP_EOF))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, info->snd_assoc_id);\n\tif (!asoc && info->snd_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tasoc->default_stream = info->snd_sid;\n\t\tasoc->default_flags = info->snd_flags;\n\t\tasoc->default_ppid = info->snd_ppid;\n\t\tasoc->default_context = info->snd_context;\n\n\t\treturn 0;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tinfo->snd_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (info->snd_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    info->snd_assoc_id == SCTP_ALL_ASSOC) {\n\t\tsp->default_stream = info->snd_sid;\n\t\tsp->default_flags = info->snd_flags;\n\t\tsp->default_ppid = info->snd_ppid;\n\t\tsp->default_context = info->snd_context;\n\t}\n\n\tif (info->snd_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    info->snd_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs) {\n\t\t\tasoc->default_stream = info->snd_sid;\n\t\t\tasoc->default_flags = info->snd_flags;\n\t\t\tasoc->default_ppid = info->snd_ppid;\n\t\t\tasoc->default_context = info->snd_context;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_primary_addr(struct sock *sk, struct sctp_prim *prim,\n\t\t\t\t\tunsigned int optlen)\n{\n\tstruct sctp_transport *trans;\n\tstruct sctp_af *af;\n\tint err;\n\n\tif (optlen != sizeof(struct sctp_prim))\n\t\treturn -EINVAL;\n\n\t \n\taf = sctp_get_af_specific(prim->ssp_addr.ss_family);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\terr = security_sctp_bind_connect(sk, SCTP_PRIMARY_ADDR,\n\t\t\t\t\t (struct sockaddr *)&prim->ssp_addr,\n\t\t\t\t\t af->sockaddr_len);\n\tif (err)\n\t\treturn err;\n\n\ttrans = sctp_addr_id2transport(sk, &prim->ssp_addr, prim->ssp_assoc_id);\n\tif (!trans)\n\t\treturn -EINVAL;\n\n\tsctp_assoc_set_primary(trans->asoc, trans);\n\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_nodelay(struct sock *sk, int *val,\n\t\t\t\t   unsigned int optlen)\n{\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tsctp_sk(sk)->nodelay = (*val == 0) ? 0 : 1;\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_rtoinfo(struct sock *sk,\n\t\t\t\t   struct sctp_rtoinfo *rtoinfo,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tunsigned long rto_min, rto_max;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen != sizeof (struct sctp_rtoinfo))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, rtoinfo->srto_assoc_id);\n\n\t \n\tif (!asoc && rtoinfo->srto_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\trto_max = rtoinfo->srto_max;\n\trto_min = rtoinfo->srto_min;\n\n\tif (rto_max)\n\t\trto_max = asoc ? msecs_to_jiffies(rto_max) : rto_max;\n\telse\n\t\trto_max = asoc ? asoc->rto_max : sp->rtoinfo.srto_max;\n\n\tif (rto_min)\n\t\trto_min = asoc ? msecs_to_jiffies(rto_min) : rto_min;\n\telse\n\t\trto_min = asoc ? asoc->rto_min : sp->rtoinfo.srto_min;\n\n\tif (rto_min > rto_max)\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tif (rtoinfo->srto_initial != 0)\n\t\t\tasoc->rto_initial =\n\t\t\t\tmsecs_to_jiffies(rtoinfo->srto_initial);\n\t\tasoc->rto_max = rto_max;\n\t\tasoc->rto_min = rto_min;\n\t} else {\n\t\t \n\t\tif (rtoinfo->srto_initial != 0)\n\t\t\tsp->rtoinfo.srto_initial = rtoinfo->srto_initial;\n\t\tsp->rtoinfo.srto_max = rto_max;\n\t\tsp->rtoinfo.srto_min = rto_min;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_associnfo(struct sock *sk,\n\t\t\t\t     struct sctp_assocparams *assocparams,\n\t\t\t\t     unsigned int optlen)\n{\n\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_assocparams))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, assocparams->sasoc_assoc_id);\n\n\tif (!asoc && assocparams->sasoc_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t \n\tif (asoc) {\n\t\tif (assocparams->sasoc_asocmaxrxt != 0) {\n\t\t\t__u32 path_sum = 0;\n\t\t\tint   paths = 0;\n\t\t\tstruct sctp_transport *peer_addr;\n\n\t\t\tlist_for_each_entry(peer_addr, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\t\tpath_sum += peer_addr->pathmaxrxt;\n\t\t\t\tpaths++;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (paths > 1 &&\n\t\t\t    assocparams->sasoc_asocmaxrxt > path_sum)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tasoc->max_retrans = assocparams->sasoc_asocmaxrxt;\n\t\t}\n\n\t\tif (assocparams->sasoc_cookie_life != 0)\n\t\t\tasoc->cookie_life =\n\t\t\t\tms_to_ktime(assocparams->sasoc_cookie_life);\n\t} else {\n\t\t \n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tif (assocparams->sasoc_asocmaxrxt != 0)\n\t\t\tsp->assocparams.sasoc_asocmaxrxt =\n\t\t\t\t\t\tassocparams->sasoc_asocmaxrxt;\n\t\tif (assocparams->sasoc_cookie_life != 0)\n\t\t\tsp->assocparams.sasoc_cookie_life =\n\t\t\t\t\t\tassocparams->sasoc_cookie_life;\n\t}\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_mappedv4(struct sock *sk, int *val,\n\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (*val)\n\t\tsp->v4mapped = 1;\n\telse\n\t\tsp->v4mapped = 0;\n\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_maxseg(struct sock *sk,\n\t\t\t\t  struct sctp_assoc_value *params,\n\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tsctp_assoc_t assoc_id;\n\tint val;\n\n\tif (optlen == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in maxseg socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tassoc_id = SCTP_FUTURE_ASSOC;\n\t\tval = *(int *)params;\n\t} else if (optlen == sizeof(struct sctp_assoc_value)) {\n\t\tassoc_id = params->assoc_id;\n\t\tval = params->assoc_value;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tasoc = sctp_id2assoc(sk, assoc_id);\n\tif (!asoc && assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (val) {\n\t\tint min_len, max_len;\n\t\t__u16 datasize = asoc ? sctp_datachk_len(&asoc->stream) :\n\t\t\t\t sizeof(struct sctp_data_chunk);\n\n\t\tmin_len = sctp_min_frag_point(sp, datasize);\n\t\tmax_len = SCTP_MAX_CHUNK_LEN - datasize;\n\n\t\tif (val < min_len || val > max_len)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (asoc) {\n\t\tasoc->user_frag = val;\n\t\tsctp_assoc_update_frag_point(asoc);\n\t} else {\n\t\tsp->user_frag = val;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int sctp_setsockopt_peer_primary_addr(struct sock *sk,\n\t\t\t\t\t     struct sctp_setpeerprim *prim,\n\t\t\t\t\t     unsigned int optlen)\n{\n\tstruct sctp_sock\t*sp;\n\tstruct sctp_association\t*asoc = NULL;\n\tstruct sctp_chunk\t*chunk;\n\tstruct sctp_af\t\t*af;\n\tint \t\t\terr;\n\n\tsp = sctp_sk(sk);\n\n\tif (!sp->ep->asconf_enable)\n\t\treturn -EPERM;\n\n\tif (optlen != sizeof(struct sctp_setpeerprim))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, prim->sspp_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tif (!asoc->peer.asconf_capable)\n\t\treturn -EPERM;\n\n\tif (asoc->peer.addip_disabled_mask & SCTP_PARAM_SET_PRIMARY)\n\t\treturn -EPERM;\n\n\tif (!sctp_state(asoc, ESTABLISHED))\n\t\treturn -ENOTCONN;\n\n\taf = sctp_get_af_specific(prim->sspp_addr.ss_family);\n\tif (!af)\n\t\treturn -EINVAL;\n\n\tif (!af->addr_valid((union sctp_addr *)&prim->sspp_addr, sp, NULL))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!sctp_assoc_lookup_laddr(asoc, (union sctp_addr *)&prim->sspp_addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\terr = security_sctp_bind_connect(sk, SCTP_SET_PEER_PRIMARY_ADDR,\n\t\t\t\t\t (struct sockaddr *)&prim->sspp_addr,\n\t\t\t\t\t af->sockaddr_len);\n\tif (err)\n\t\treturn err;\n\n\t \n\tchunk = sctp_make_asconf_set_prim(asoc,\n\t\t\t\t\t  (union sctp_addr *)&prim->sspp_addr);\n\tif (!chunk)\n\t\treturn -ENOMEM;\n\n\terr = sctp_send_asconf(asoc, chunk);\n\n\tpr_debug(\"%s: we set peer primary addr primitively\\n\", __func__);\n\n\treturn err;\n}\n\nstatic int sctp_setsockopt_adaptation_layer(struct sock *sk,\n\t\t\t\t\t    struct sctp_setadaptation *adapt,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tif (optlen != sizeof(struct sctp_setadaptation))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->adaptation_ind = adapt->ssb_adaptation_ind;\n\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_context(struct sock *sk,\n\t\t\t\t   struct sctp_assoc_value *params,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(struct sctp_assoc_value))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tasoc->default_rcv_context = params->assoc_value;\n\n\t\treturn 0;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tparams->assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (params->assoc_id == SCTP_FUTURE_ASSOC ||\n\t    params->assoc_id == SCTP_ALL_ASSOC)\n\t\tsp->default_rcv_context = params->assoc_value;\n\n\tif (params->assoc_id == SCTP_CURRENT_ASSOC ||\n\t    params->assoc_id == SCTP_ALL_ASSOC)\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs)\n\t\t\tasoc->default_rcv_context = params->assoc_value;\n\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_fragment_interleave(struct sock *sk, int *val,\n\t\t\t\t\t       unsigned int optlen)\n{\n\tif (optlen != sizeof(int))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->frag_interleave = !!*val;\n\n\tif (!sctp_sk(sk)->frag_interleave)\n\t\tsctp_sk(sk)->ep->intl_enable = 0;\n\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_partial_delivery_point(struct sock *sk, u32 *val,\n\t\t\t\t\t\t  unsigned int optlen)\n{\n\tif (optlen != sizeof(u32))\n\t\treturn -EINVAL;\n\n\t \n\tif (*val > (sk->sk_rcvbuf >> 1))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->pd_point = *val;\n\n\treturn 0;  \n}\n\n \nstatic int sctp_setsockopt_maxburst(struct sock *sk,\n\t\t\t\t    struct sctp_assoc_value *params,\n\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tsctp_assoc_t assoc_id;\n\tu32 assoc_value;\n\n\tif (optlen == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in max_burst socket option deprecated.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tassoc_id = SCTP_FUTURE_ASSOC;\n\t\tassoc_value = *((int *)params);\n\t} else if (optlen == sizeof(struct sctp_assoc_value)) {\n\t\tassoc_id = params->assoc_id;\n\t\tassoc_value = params->assoc_value;\n\t} else\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, assoc_id);\n\tif (!asoc && assoc_id > SCTP_ALL_ASSOC && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tasoc->max_burst = assoc_value;\n\n\t\treturn 0;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tassoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (assoc_id == SCTP_FUTURE_ASSOC || assoc_id == SCTP_ALL_ASSOC)\n\t\tsp->max_burst = assoc_value;\n\n\tif (assoc_id == SCTP_CURRENT_ASSOC || assoc_id == SCTP_ALL_ASSOC)\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs)\n\t\t\tasoc->max_burst = assoc_value;\n\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_auth_chunk(struct sock *sk,\n\t\t\t\t      struct sctp_authchunk *val,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen != sizeof(struct sctp_authchunk))\n\t\treturn -EINVAL;\n\n\tswitch (val->sauth_chunk) {\n\tcase SCTP_CID_INIT:\n\tcase SCTP_CID_INIT_ACK:\n\tcase SCTP_CID_SHUTDOWN_COMPLETE:\n\tcase SCTP_CID_AUTH:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn sctp_auth_ep_add_chunkid(ep, val->sauth_chunk);\n}\n\n \nstatic int sctp_setsockopt_hmac_ident(struct sock *sk,\n\t\t\t\t      struct sctp_hmacalgo *hmacs,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tu32 idents;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen < sizeof(struct sctp_hmacalgo))\n\t\treturn -EINVAL;\n\toptlen = min_t(unsigned int, optlen, sizeof(struct sctp_hmacalgo) +\n\t\t\t\t\t     SCTP_AUTH_NUM_HMACS * sizeof(u16));\n\n\tidents = hmacs->shmac_num_idents;\n\tif (idents == 0 || idents > SCTP_AUTH_NUM_HMACS ||\n\t    (idents * sizeof(u16)) > (optlen - sizeof(struct sctp_hmacalgo)))\n\t\treturn -EINVAL;\n\n\treturn sctp_auth_ep_set_hmacs(ep, hmacs);\n}\n\n \nstatic int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    struct sctp_authkey *authkey,\n\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_association *asoc;\n\tint ret = -EINVAL;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\t \n\toptlen = min_t(unsigned int, optlen, USHRT_MAX + sizeof(*authkey));\n\n\tif (authkey->sca_keylength > optlen - sizeof(*authkey))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tif (asoc) {\n\t\tret = sctp_auth_set_key(ep, asoc, authkey);\n\t\tgoto out;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tauthkey->sca_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (authkey->sca_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    authkey->sca_assoc_id == SCTP_ALL_ASSOC) {\n\t\tret = sctp_auth_set_key(ep, asoc, authkey);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\n\n\tif (authkey->sca_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    authkey->sca_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\t\t\tint res = sctp_auth_set_key(ep, asoc, authkey);\n\n\t\t\tif (res && !ret)\n\t\t\t\tret = res;\n\t\t}\n\t}\n\nout:\n\tmemzero_explicit(authkey, optlen);\n\treturn ret;\n}\n\n \nstatic int sctp_setsockopt_active_key(struct sock *sk,\n\t\t\t\t      struct sctp_authkeyid *val,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_association *asoc;\n\tint ret = 0;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, val->scact_assoc_id);\n\tif (!asoc && val->scact_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\treturn sctp_auth_set_active_key(ep, asoc, val->scact_keynumber);\n\n\tif (sctp_style(sk, TCP))\n\t\tval->scact_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (val->scact_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    val->scact_assoc_id == SCTP_ALL_ASSOC) {\n\t\tret = sctp_auth_set_active_key(ep, asoc, val->scact_keynumber);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (val->scact_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    val->scact_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\t\t\tint res = sctp_auth_set_active_key(ep, asoc,\n\t\t\t\t\t\t\t   val->scact_keynumber);\n\n\t\t\tif (res && !ret)\n\t\t\t\tret = res;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sctp_setsockopt_del_key(struct sock *sk,\n\t\t\t\t   struct sctp_authkeyid *val,\n\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_association *asoc;\n\tint ret = 0;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, val->scact_assoc_id);\n\tif (!asoc && val->scact_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\treturn sctp_auth_del_key_id(ep, asoc, val->scact_keynumber);\n\n\tif (sctp_style(sk, TCP))\n\t\tval->scact_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (val->scact_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    val->scact_assoc_id == SCTP_ALL_ASSOC) {\n\t\tret = sctp_auth_del_key_id(ep, asoc, val->scact_keynumber);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (val->scact_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    val->scact_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\t\t\tint res = sctp_auth_del_key_id(ep, asoc,\n\t\t\t\t\t\t       val->scact_keynumber);\n\n\t\t\tif (res && !ret)\n\t\t\t\tret = res;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sctp_setsockopt_deactivate_key(struct sock *sk,\n\t\t\t\t\t  struct sctp_authkeyid *val,\n\t\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_association *asoc;\n\tint ret = 0;\n\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, val->scact_assoc_id);\n\tif (!asoc && val->scact_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\treturn sctp_auth_deact_key_id(ep, asoc, val->scact_keynumber);\n\n\tif (sctp_style(sk, TCP))\n\t\tval->scact_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (val->scact_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    val->scact_assoc_id == SCTP_ALL_ASSOC) {\n\t\tret = sctp_auth_deact_key_id(ep, asoc, val->scact_keynumber);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (val->scact_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    val->scact_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &ep->asocs, asocs) {\n\t\t\tint res = sctp_auth_deact_key_id(ep, asoc,\n\t\t\t\t\t\t\t val->scact_keynumber);\n\n\t\t\tif (res && !ret)\n\t\t\t\tret = res;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sctp_setsockopt_auto_asconf(struct sock *sk, int *val,\n\t\t\t\t\tunsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (!sctp_is_ep_boundall(sk) && *val)\n\t\treturn -EINVAL;\n\tif ((*val && sp->do_auto_asconf) || (!*val && !sp->do_auto_asconf))\n\t\treturn 0;\n\n\tspin_lock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\tif (*val == 0 && sp->do_auto_asconf) {\n\t\tlist_del(&sp->auto_asconf_list);\n\t\tsp->do_auto_asconf = 0;\n\t} else if (*val && !sp->do_auto_asconf) {\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &sock_net(sk)->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t}\n\tspin_unlock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt_paddr_thresholds(struct sock *sk,\n\t\t\t\t\t    struct sctp_paddrthlds_v2 *val,\n\t\t\t\t\t    unsigned int optlen, bool v2)\n{\n\tstruct sctp_transport *trans;\n\tstruct sctp_association *asoc;\n\tint len;\n\n\tlen = v2 ? sizeof(*val) : sizeof(struct sctp_paddrthlds);\n\tif (optlen < len)\n\t\treturn -EINVAL;\n\n\tif (v2 && val->spt_pathpfthld > val->spt_pathcpthld)\n\t\treturn -EINVAL;\n\n\tif (!sctp_is_any(sk, (const union sctp_addr *)&val->spt_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &val->spt_address,\n\t\t\t\t\t       val->spt_assoc_id);\n\t\tif (!trans)\n\t\t\treturn -ENOENT;\n\n\t\tif (val->spt_pathmaxrxt)\n\t\t\ttrans->pathmaxrxt = val->spt_pathmaxrxt;\n\t\tif (v2)\n\t\t\ttrans->ps_retrans = val->spt_pathcpthld;\n\t\ttrans->pf_retrans = val->spt_pathpfthld;\n\n\t\treturn 0;\n\t}\n\n\tasoc = sctp_id2assoc(sk, val->spt_assoc_id);\n\tif (!asoc && val->spt_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\t    transports) {\n\t\t\tif (val->spt_pathmaxrxt)\n\t\t\t\ttrans->pathmaxrxt = val->spt_pathmaxrxt;\n\t\t\tif (v2)\n\t\t\t\ttrans->ps_retrans = val->spt_pathcpthld;\n\t\t\ttrans->pf_retrans = val->spt_pathpfthld;\n\t\t}\n\n\t\tif (val->spt_pathmaxrxt)\n\t\t\tasoc->pathmaxrxt = val->spt_pathmaxrxt;\n\t\tif (v2)\n\t\t\tasoc->ps_retrans = val->spt_pathcpthld;\n\t\tasoc->pf_retrans = val->spt_pathpfthld;\n\t} else {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tif (val->spt_pathmaxrxt)\n\t\t\tsp->pathmaxrxt = val->spt_pathmaxrxt;\n\t\tif (v2)\n\t\t\tsp->ps_retrans = val->spt_pathcpthld;\n\t\tsp->pf_retrans = val->spt_pathpfthld;\n\t}\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_recvrcvinfo(struct sock *sk, int *val,\n\t\t\t\t       unsigned int optlen)\n{\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->recvrcvinfo = (*val == 0) ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_recvnxtinfo(struct sock *sk, int *val,\n\t\t\t\t       unsigned int optlen)\n{\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->recvnxtinfo = (*val == 0) ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_pr_supported(struct sock *sk,\n\t\t\t\t\tstruct sctp_assoc_value *params,\n\t\t\t\t\tunsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(*params))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->ep->prsctp_enable = !!params->assoc_value;\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_default_prinfo(struct sock *sk,\n\t\t\t\t\t  struct sctp_default_prinfo *info,\n\t\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*info))\n\t\tgoto out;\n\n\tif (info->pr_policy & ~SCTP_PR_SCTP_MASK)\n\t\tgoto out;\n\n\tif (info->pr_policy == SCTP_PR_SCTP_NONE)\n\t\tinfo->pr_value = 0;\n\n\tasoc = sctp_id2assoc(sk, info->pr_assoc_id);\n\tif (!asoc && info->pr_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tretval = 0;\n\n\tif (asoc) {\n\t\tSCTP_PR_SET_POLICY(asoc->default_flags, info->pr_policy);\n\t\tasoc->default_timetolive = info->pr_value;\n\t\tgoto out;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tinfo->pr_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (info->pr_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    info->pr_assoc_id == SCTP_ALL_ASSOC) {\n\t\tSCTP_PR_SET_POLICY(sp->default_flags, info->pr_policy);\n\t\tsp->default_timetolive = info->pr_value;\n\t}\n\n\tif (info->pr_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    info->pr_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs) {\n\t\t\tSCTP_PR_SET_POLICY(asoc->default_flags,\n\t\t\t\t\t   info->pr_policy);\n\t\t\tasoc->default_timetolive = info->pr_value;\n\t\t}\n\t}\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_reconfig_supported(struct sock *sk,\n\t\t\t\t\t      struct sctp_assoc_value *params,\n\t\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*params))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tsctp_sk(sk)->ep->reconf_enable = !!params->assoc_value;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_enable_strreset(struct sock *sk,\n\t\t\t\t\t   struct sctp_assoc_value *params,\n\t\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*params))\n\t\tgoto out;\n\n\tif (params->assoc_value & (~SCTP_ENABLE_STRRESET_MASK))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tretval = 0;\n\n\tif (asoc) {\n\t\tasoc->strreset_enable = params->assoc_value;\n\t\tgoto out;\n\t}\n\n\tif (sctp_style(sk, TCP))\n\t\tparams->assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (params->assoc_id == SCTP_FUTURE_ASSOC ||\n\t    params->assoc_id == SCTP_ALL_ASSOC)\n\t\tep->strreset_enable = params->assoc_value;\n\n\tif (params->assoc_id == SCTP_CURRENT_ASSOC ||\n\t    params->assoc_id == SCTP_ALL_ASSOC)\n\t\tlist_for_each_entry(asoc, &ep->asocs, asocs)\n\t\t\tasoc->strreset_enable = params->assoc_value;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_reset_streams(struct sock *sk,\n\t\t\t\t\t struct sctp_reset_streams *params,\n\t\t\t\t\t unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\n\tif (optlen < sizeof(*params))\n\t\treturn -EINVAL;\n\t \n\toptlen = min_t(unsigned int, optlen, USHRT_MAX +\n\t\t\t\t\t     sizeof(__u16) * sizeof(*params));\n\n\tif (params->srs_number_streams * sizeof(__u16) >\n\t    optlen - sizeof(*params))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params->srs_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\treturn sctp_send_reset_streams(asoc, params);\n}\n\nstatic int sctp_setsockopt_reset_assoc(struct sock *sk, sctp_assoc_t *associd,\n\t\t\t\t       unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(*associd))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, *associd);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\treturn sctp_send_reset_assoc(asoc);\n}\n\nstatic int sctp_setsockopt_add_streams(struct sock *sk,\n\t\t\t\t       struct sctp_add_streams *params,\n\t\t\t\t       unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\n\tif (optlen != sizeof(*params))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params->sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\treturn sctp_send_add_streams(asoc, params);\n}\n\nstatic int sctp_setsockopt_scheduler(struct sock *sk,\n\t\t\t\t     struct sctp_assoc_value *params,\n\t\t\t\t     unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tint retval = 0;\n\n\tif (optlen < sizeof(*params))\n\t\treturn -EINVAL;\n\n\tif (params->assoc_value > SCTP_SS_MAX)\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\treturn sctp_sched_set_sched(asoc, params->assoc_value);\n\n\tif (sctp_style(sk, TCP))\n\t\tparams->assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (params->assoc_id == SCTP_FUTURE_ASSOC ||\n\t    params->assoc_id == SCTP_ALL_ASSOC)\n\t\tsp->default_ss = params->assoc_value;\n\n\tif (params->assoc_id == SCTP_CURRENT_ASSOC ||\n\t    params->assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs) {\n\t\t\tint ret = sctp_sched_set_sched(asoc,\n\t\t\t\t\t\t       params->assoc_value);\n\n\t\t\tif (ret && !retval)\n\t\t\t\tretval = ret;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_scheduler_value(struct sock *sk,\n\t\t\t\t\t   struct sctp_stream_value *params,\n\t\t\t\t\t   unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen < sizeof(*params))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_CURRENT_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tif (asoc) {\n\t\tretval = sctp_sched_set_value(asoc, params->stream_id,\n\t\t\t\t\t      params->stream_value, GFP_KERNEL);\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\n\tlist_for_each_entry(asoc, &sctp_sk(sk)->ep->asocs, asocs) {\n\t\tint ret = sctp_sched_set_value(asoc, params->stream_id,\n\t\t\t\t\t       params->stream_value,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (ret && !retval)  \n\t\t\tretval = ret;\n\t}\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_interleaving_supported(struct sock *sk,\n\t\t\t\t\t\t  struct sctp_assoc_value *p,\n\t\t\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\n\tif (optlen < sizeof(*p))\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, p->assoc_id);\n\tif (!asoc && p->assoc_id != SCTP_FUTURE_ASSOC && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (!sock_net(sk)->sctp.intl_enable || !sp->frag_interleave) {\n\t\treturn -EPERM;\n\t}\n\n\tsp->ep->intl_enable = !!p->assoc_value;\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_reuse_port(struct sock *sk, int *val,\n\t\t\t\t      unsigned int optlen)\n{\n\tif (!sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sctp_sk(sk)->ep->base.bind_addr.port)\n\t\treturn -EFAULT;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tsctp_sk(sk)->reuse = !!*val;\n\n\treturn 0;\n}\n\nstatic int sctp_assoc_ulpevent_type_set(struct sctp_event *param,\n\t\t\t\t\tstruct sctp_association *asoc)\n{\n\tstruct sctp_ulpevent *event;\n\n\tsctp_ulpevent_type_set(&asoc->subscribe, param->se_type, param->se_on);\n\n\tif (param->se_type == SCTP_SENDER_DRY_EVENT && param->se_on) {\n\t\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\t\tevent = sctp_ulpevent_make_sender_dry_event(asoc,\n\t\t\t\t\tGFP_USER | __GFP_NOWARN);\n\t\t\tif (!event)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, event);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_event(struct sock *sk, struct sctp_event *param,\n\t\t\t\t unsigned int optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tint retval = 0;\n\n\tif (optlen < sizeof(*param))\n\t\treturn -EINVAL;\n\n\tif (param->se_type < SCTP_SN_TYPE_BASE ||\n\t    param->se_type > SCTP_SN_TYPE_MAX)\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, param->se_assoc_id);\n\tif (!asoc && param->se_assoc_id > SCTP_ALL_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\treturn sctp_assoc_ulpevent_type_set(param, asoc);\n\n\tif (sctp_style(sk, TCP))\n\t\tparam->se_assoc_id = SCTP_FUTURE_ASSOC;\n\n\tif (param->se_assoc_id == SCTP_FUTURE_ASSOC ||\n\t    param->se_assoc_id == SCTP_ALL_ASSOC)\n\t\tsctp_ulpevent_type_set(&sp->subscribe,\n\t\t\t\t       param->se_type, param->se_on);\n\n\tif (param->se_assoc_id == SCTP_CURRENT_ASSOC ||\n\t    param->se_assoc_id == SCTP_ALL_ASSOC) {\n\t\tlist_for_each_entry(asoc, &sp->ep->asocs, asocs) {\n\t\t\tint ret = sctp_assoc_ulpevent_type_set(param, asoc);\n\n\t\t\tif (ret && !retval)\n\t\t\t\tretval = ret;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_asconf_supported(struct sock *sk,\n\t\t\t\t\t    struct sctp_assoc_value *params,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_endpoint *ep;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*params))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tep = sctp_sk(sk)->ep;\n\tep->asconf_enable = !!params->assoc_value;\n\n\tif (ep->asconf_enable && ep->auth_enable) {\n\t\tsctp_auth_ep_add_chunkid(ep, SCTP_CID_ASCONF);\n\t\tsctp_auth_ep_add_chunkid(ep, SCTP_CID_ASCONF_ACK);\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_auth_supported(struct sock *sk,\n\t\t\t\t\t  struct sctp_assoc_value *params,\n\t\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_endpoint *ep;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*params))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tep = sctp_sk(sk)->ep;\n\tif (params->assoc_value) {\n\t\tretval = sctp_auth_init(ep, GFP_KERNEL);\n\t\tif (retval)\n\t\t\tgoto out;\n\t\tif (ep->asconf_enable) {\n\t\t\tsctp_auth_ep_add_chunkid(ep, SCTP_CID_ASCONF);\n\t\t\tsctp_auth_ep_add_chunkid(ep, SCTP_CID_ASCONF_ACK);\n\t\t}\n\t}\n\n\tep->auth_enable = !!params->assoc_value;\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_ecn_supported(struct sock *sk,\n\t\t\t\t\t struct sctp_assoc_value *params,\n\t\t\t\t\t unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*params))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tsctp_sk(sk)->ep->ecn_enable = !!params->assoc_value;\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_pf_expose(struct sock *sk,\n\t\t\t\t     struct sctp_assoc_value *params,\n\t\t\t\t     unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tint retval = -EINVAL;\n\n\tif (optlen != sizeof(*params))\n\t\tgoto out;\n\n\tif (params->assoc_value > SCTP_PF_EXPOSE_MAX)\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params->assoc_id);\n\tif (!asoc && params->assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\tgoto out;\n\n\tif (asoc)\n\t\tasoc->pf_expose = params->assoc_value;\n\telse\n\t\tsctp_sk(sk)->pf_expose = params->assoc_value;\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_setsockopt_encap_port(struct sock *sk,\n\t\t\t\t      struct sctp_udpencaps *encap,\n\t\t\t\t      unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_transport *t;\n\t__be16 encap_port;\n\n\tif (optlen != sizeof(*encap))\n\t\treturn -EINVAL;\n\n\t \n\tencap_port = (__force __be16)encap->sue_port;\n\tif (!sctp_is_any(sk, (union sctp_addr *)&encap->sue_address)) {\n\t\tt = sctp_addr_id2transport(sk, &encap->sue_address,\n\t\t\t\t\t   encap->sue_assoc_id);\n\t\tif (!t)\n\t\t\treturn -EINVAL;\n\n\t\tt->encap_port = encap_port;\n\t\treturn 0;\n\t}\n\n\t \n\tasoc = sctp_id2assoc(sk, encap->sue_assoc_id);\n\tif (!asoc && encap->sue_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t \n\tif (asoc) {\n\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t    transports)\n\t\t\tt->encap_port = encap_port;\n\n\t\tasoc->encap_port = encap_port;\n\t\treturn 0;\n\t}\n\n\tsctp_sk(sk)->encap_port = encap_port;\n\treturn 0;\n}\n\nstatic int sctp_setsockopt_probe_interval(struct sock *sk,\n\t\t\t\t\t  struct sctp_probeinterval *params,\n\t\t\t\t\t  unsigned int optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_transport *t;\n\t__u32 probe_interval;\n\n\tif (optlen != sizeof(*params))\n\t\treturn -EINVAL;\n\n\tprobe_interval = params->spi_interval;\n\tif (probe_interval && probe_interval < SCTP_PROBE_TIMER_MIN)\n\t\treturn -EINVAL;\n\n\t \n\tif (!sctp_is_any(sk, (union sctp_addr *)&params->spi_address)) {\n\t\tt = sctp_addr_id2transport(sk, &params->spi_address,\n\t\t\t\t\t   params->spi_assoc_id);\n\t\tif (!t)\n\t\t\treturn -EINVAL;\n\n\t\tt->probe_interval = msecs_to_jiffies(probe_interval);\n\t\tsctp_transport_pl_reset(t);\n\t\treturn 0;\n\t}\n\n\t \n\tasoc = sctp_id2assoc(sk, params->spi_assoc_id);\n\tif (!asoc && params->spi_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t \n\tif (asoc) {\n\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list, transports) {\n\t\t\tt->probe_interval = msecs_to_jiffies(probe_interval);\n\t\t\tsctp_transport_pl_reset(t);\n\t\t}\n\n\t\tasoc->probe_interval = msecs_to_jiffies(probe_interval);\n\t\treturn 0;\n\t}\n\n\tsctp_sk(sk)->probe_interval = probe_interval;\n\treturn 0;\n}\n\n \nstatic int sctp_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   sockptr_t optval, unsigned int optlen)\n{\n\tvoid *kopt = NULL;\n\tint retval = 0;\n\n\tpr_debug(\"%s: sk:%p, optname:%d\\n\", __func__, sk, optname);\n\n\t \n\tif (level != SOL_SCTP) {\n\t\tstruct sctp_af *af = sctp_sk(sk)->pf->af;\n\n\t\treturn af->setsockopt(sk, level, optname, optval, optlen);\n\t}\n\n\tif (optlen > 0) {\n\t\t \n\t\toptlen = min_t(unsigned int, optlen,\n\t\t\t       PAGE_ALIGN(USHRT_MAX +\n\t\t\t\t\t  sizeof(__u16) * sizeof(struct sctp_reset_streams)));\n\t\tkopt = memdup_sockptr(optval, optlen);\n\t\tif (IS_ERR(kopt))\n\t\t\treturn PTR_ERR(kopt);\n\t}\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCTP_SOCKOPT_BINDX_ADD:\n\t\t \n\t\tretval = sctp_setsockopt_bindx(sk, kopt, optlen,\n\t\t\t\t\t       SCTP_BINDX_ADD_ADDR);\n\t\tbreak;\n\n\tcase SCTP_SOCKOPT_BINDX_REM:\n\t\t \n\t\tretval = sctp_setsockopt_bindx(sk, kopt, optlen,\n\t\t\t\t\t       SCTP_BINDX_REM_ADDR);\n\t\tbreak;\n\n\tcase SCTP_SOCKOPT_CONNECTX_OLD:\n\t\t \n\t\tretval = sctp_setsockopt_connectx_old(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_SOCKOPT_CONNECTX:\n\t\t \n\t\tretval = sctp_setsockopt_connectx(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_DISABLE_FRAGMENTS:\n\t\tretval = sctp_setsockopt_disable_fragments(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_EVENTS:\n\t\tretval = sctp_setsockopt_events(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_AUTOCLOSE:\n\t\tretval = sctp_setsockopt_autoclose(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_PEER_ADDR_PARAMS:\n\t\tretval = sctp_setsockopt_peer_addr_params(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_DELAYED_SACK:\n\t\tretval = sctp_setsockopt_delayed_ack(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_PARTIAL_DELIVERY_POINT:\n\t\tretval = sctp_setsockopt_partial_delivery_point(sk, kopt, optlen);\n\t\tbreak;\n\n\tcase SCTP_INITMSG:\n\t\tretval = sctp_setsockopt_initmsg(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SEND_PARAM:\n\t\tretval = sctp_setsockopt_default_send_param(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SNDINFO:\n\t\tretval = sctp_setsockopt_default_sndinfo(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_PRIMARY_ADDR:\n\t\tretval = sctp_setsockopt_primary_addr(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_SET_PEER_PRIMARY_ADDR:\n\t\tretval = sctp_setsockopt_peer_primary_addr(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_NODELAY:\n\t\tretval = sctp_setsockopt_nodelay(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_RTOINFO:\n\t\tretval = sctp_setsockopt_rtoinfo(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_ASSOCINFO:\n\t\tretval = sctp_setsockopt_associnfo(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_I_WANT_MAPPED_V4_ADDR:\n\t\tretval = sctp_setsockopt_mappedv4(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_MAXSEG:\n\t\tretval = sctp_setsockopt_maxseg(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_ADAPTATION_LAYER:\n\t\tretval = sctp_setsockopt_adaptation_layer(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_CONTEXT:\n\t\tretval = sctp_setsockopt_context(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_FRAGMENT_INTERLEAVE:\n\t\tretval = sctp_setsockopt_fragment_interleave(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_MAX_BURST:\n\t\tretval = sctp_setsockopt_maxburst(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_CHUNK:\n\t\tretval = sctp_setsockopt_auth_chunk(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_HMAC_IDENT:\n\t\tretval = sctp_setsockopt_hmac_ident(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_KEY:\n\t\tretval = sctp_setsockopt_auth_key(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_ACTIVE_KEY:\n\t\tretval = sctp_setsockopt_active_key(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_DELETE_KEY:\n\t\tretval = sctp_setsockopt_del_key(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_DEACTIVATE_KEY:\n\t\tretval = sctp_setsockopt_deactivate_key(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTO_ASCONF:\n\t\tretval = sctp_setsockopt_auto_asconf(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_THLDS:\n\t\tretval = sctp_setsockopt_paddr_thresholds(sk, kopt, optlen,\n\t\t\t\t\t\t\t  false);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_THLDS_V2:\n\t\tretval = sctp_setsockopt_paddr_thresholds(sk, kopt, optlen,\n\t\t\t\t\t\t\t  true);\n\t\tbreak;\n\tcase SCTP_RECVRCVINFO:\n\t\tretval = sctp_setsockopt_recvrcvinfo(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_RECVNXTINFO:\n\t\tretval = sctp_setsockopt_recvnxtinfo(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_PR_SUPPORTED:\n\t\tretval = sctp_setsockopt_pr_supported(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_PRINFO:\n\t\tretval = sctp_setsockopt_default_prinfo(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_RECONFIG_SUPPORTED:\n\t\tretval = sctp_setsockopt_reconfig_supported(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_ENABLE_STREAM_RESET:\n\t\tretval = sctp_setsockopt_enable_strreset(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_RESET_STREAMS:\n\t\tretval = sctp_setsockopt_reset_streams(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_RESET_ASSOC:\n\t\tretval = sctp_setsockopt_reset_assoc(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_ADD_STREAMS:\n\t\tretval = sctp_setsockopt_add_streams(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_STREAM_SCHEDULER:\n\t\tretval = sctp_setsockopt_scheduler(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_STREAM_SCHEDULER_VALUE:\n\t\tretval = sctp_setsockopt_scheduler_value(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_INTERLEAVING_SUPPORTED:\n\t\tretval = sctp_setsockopt_interleaving_supported(sk, kopt,\n\t\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_REUSE_PORT:\n\t\tretval = sctp_setsockopt_reuse_port(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_EVENT:\n\t\tretval = sctp_setsockopt_event(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_ASCONF_SUPPORTED:\n\t\tretval = sctp_setsockopt_asconf_supported(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_SUPPORTED:\n\t\tretval = sctp_setsockopt_auth_supported(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_ECN_SUPPORTED:\n\t\tretval = sctp_setsockopt_ecn_supported(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_EXPOSE_POTENTIALLY_FAILED_STATE:\n\t\tretval = sctp_setsockopt_pf_expose(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_REMOTE_UDP_ENCAPS_PORT:\n\t\tretval = sctp_setsockopt_encap_port(sk, kopt, optlen);\n\t\tbreak;\n\tcase SCTP_PLPMTUD_PROBE_INTERVAL:\n\t\tretval = sctp_setsockopt_probe_interval(sk, kopt, optlen);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\tkfree(kopt);\n\treturn retval;\n}\n\n \nstatic int sctp_connect(struct sock *sk, struct sockaddr *addr,\n\t\t\tint addr_len, int flags)\n{\n\tstruct sctp_af *af;\n\tint err = -EINVAL;\n\n\tlock_sock(sk);\n\tpr_debug(\"%s: sk:%p, sockaddr:%p, addr_len:%d\\n\", __func__, sk,\n\t\t addr, addr_len);\n\n\t \n\taf = sctp_get_af_specific(addr->sa_family);\n\tif (af && addr_len >= af->sockaddr_len)\n\t\terr = __sctp_connect(sk, addr, af->sockaddr_len, flags, NULL);\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nint sctp_inet_connect(struct socket *sock, struct sockaddr *uaddr,\n\t\t      int addr_len, int flags)\n{\n\tif (addr_len < sizeof(uaddr->sa_family))\n\t\treturn -EINVAL;\n\n\tif (uaddr->sa_family == AF_UNSPEC)\n\t\treturn -EOPNOTSUPP;\n\n\treturn sctp_connect(sock->sk, uaddr, addr_len, flags);\n}\n\n \nstatic int sctp_disconnect(struct sock *sk, int flags)\n{\n\treturn -EOPNOTSUPP;  \n}\n\n \nstatic struct sock *sctp_accept(struct sock *sk, int flags, int *err, bool kern)\n{\n\tstruct sctp_sock *sp;\n\tstruct sctp_endpoint *ep;\n\tstruct sock *newsk = NULL;\n\tstruct sctp_association *asoc;\n\tlong timeo;\n\tint error = 0;\n\n\tlock_sock(sk);\n\n\tsp = sctp_sk(sk);\n\tep = sp->ep;\n\n\tif (!sctp_style(sk, TCP)) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!sctp_sstate(sk, LISTENING)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\terror = sctp_wait_for_accept(sk, timeo);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tasoc = list_entry(ep->asocs.next, struct sctp_association, asocs);\n\n\tnewsk = sp->pf->create_accept_sk(sk, asoc, kern);\n\tif (!newsk) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\terror = sctp_sock_migrate(sk, newsk, asoc, SCTP_SOCKET_TCP);\n\tif (error) {\n\t\tsk_common_release(newsk);\n\t\tnewsk = NULL;\n\t}\n\nout:\n\trelease_sock(sk);\n\t*err = error;\n\treturn newsk;\n}\n\n \nstatic int sctp_ioctl(struct sock *sk, int cmd, int *karg)\n{\n\tint rc = -ENOTCONN;\n\n\tlock_sock(sk);\n\n\t \n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\tgoto out;\n\n\tswitch (cmd) {\n\tcase SIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\t*karg = 0;\n\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb != NULL) {\n\t\t\t \n\t\t\t*karg = skb->len;\n\t\t}\n\t\trc = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\trc = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n \nstatic int sctp_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_sock *sp;\n\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\n\tsp = sctp_sk(sk);\n\n\t \n\tswitch (sk->sk_type) {\n\tcase SOCK_SEQPACKET:\n\t\tsp->type = SCTP_SOCKET_UDP;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tsp->type = SCTP_SOCKET_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk->sk_gso_type = SKB_GSO_SCTP;\n\n\t \n\tsp->default_stream = 0;\n\tsp->default_ppid = 0;\n\tsp->default_flags = 0;\n\tsp->default_context = 0;\n\tsp->default_timetolive = 0;\n\n\tsp->default_rcv_context = 0;\n\tsp->max_burst = net->sctp.max_burst;\n\n\tsp->sctp_hmac_alg = net->sctp.sctp_hmac_alg;\n\n\t \n\tsp->initmsg.sinit_num_ostreams   = sctp_max_outstreams;\n\tsp->initmsg.sinit_max_instreams  = sctp_max_instreams;\n\tsp->initmsg.sinit_max_attempts   = net->sctp.max_retrans_init;\n\tsp->initmsg.sinit_max_init_timeo = net->sctp.rto_max;\n\n\t \n\tsp->rtoinfo.srto_initial = net->sctp.rto_initial;\n\tsp->rtoinfo.srto_max     = net->sctp.rto_max;\n\tsp->rtoinfo.srto_min     = net->sctp.rto_min;\n\n\t \n\tsp->assocparams.sasoc_asocmaxrxt = net->sctp.max_retrans_association;\n\tsp->assocparams.sasoc_number_peer_destinations = 0;\n\tsp->assocparams.sasoc_peer_rwnd = 0;\n\tsp->assocparams.sasoc_local_rwnd = 0;\n\tsp->assocparams.sasoc_cookie_life = net->sctp.valid_cookie_life;\n\n\t \n\tsp->subscribe = 0;\n\n\t \n\tsp->hbinterval  = net->sctp.hb_interval;\n\tsp->udp_port    = htons(net->sctp.udp_port);\n\tsp->encap_port  = htons(net->sctp.encap_port);\n\tsp->pathmaxrxt  = net->sctp.max_retrans_path;\n\tsp->pf_retrans  = net->sctp.pf_retrans;\n\tsp->ps_retrans  = net->sctp.ps_retrans;\n\tsp->pf_expose   = net->sctp.pf_expose;\n\tsp->pathmtu     = 0;  \n\tsp->sackdelay   = net->sctp.sack_timeout;\n\tsp->sackfreq\t= 2;\n\tsp->param_flags = SPP_HB_ENABLE |\n\t\t\t  SPP_PMTUD_ENABLE |\n\t\t\t  SPP_SACKDELAY_ENABLE;\n\tsp->default_ss = SCTP_SS_DEFAULT;\n\n\t \n\tsp->disable_fragments = 0;\n\n\t \n\tsp->nodelay           = 0;\n\n\tsp->recvrcvinfo = 0;\n\tsp->recvnxtinfo = 0;\n\n\t \n\tsp->v4mapped          = 1;\n\n\t \n\tsp->autoclose         = 0;\n\n\t \n\tsp->user_frag         = 0;\n\n\tsp->adaptation_ind = 0;\n\n\tsp->pf = sctp_get_pf_specific(sk->sk_family);\n\n\t \n\tatomic_set(&sp->pd_mode, 0);\n\tskb_queue_head_init(&sp->pd_lobby);\n\tsp->frag_interleave = 0;\n\tsp->probe_interval = net->sctp.probe_interval;\n\n\t \n\tsp->ep = sctp_endpoint_new(sk, GFP_KERNEL);\n\tif (!sp->ep)\n\t\treturn -ENOMEM;\n\n\tsp->hmac = NULL;\n\n\tsk->sk_destruct = sctp_destruct_sock;\n\n\tSCTP_DBG_OBJCNT_INC(sock);\n\n\tsk_sockets_allocated_inc(sk);\n\tsock_prot_inuse_add(net, sk->sk_prot, 1);\n\n\treturn 0;\n}\n\n \nstatic void sctp_destroy_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp;\n\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\n\t \n\tsp = sctp_sk(sk);\n\t \n\tif (sp->ep == NULL)\n\t\treturn;\n\n\tif (sp->do_auto_asconf) {\n\t\tsp->do_auto_asconf = 0;\n\t\tlist_del(&sp->auto_asconf_list);\n\t}\n\tsctp_endpoint_free(sp->ep);\n\tsk_sockets_allocated_dec(sk);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n}\n\n \nstatic void sctp_destruct_common(struct sock *sk)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t \n\tcrypto_free_shash(sp->hmac);\n}\n\nstatic void sctp_destruct_sock(struct sock *sk)\n{\n\tsctp_destruct_common(sk);\n\tinet_sock_destruct(sk);\n}\n\n \nstatic void sctp_shutdown(struct sock *sk, int how)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\n\tif (!sctp_style(sk, TCP))\n\t\treturn;\n\n\tep = sctp_sk(sk)->ep;\n\tif (how & SEND_SHUTDOWN && !list_empty(&ep->asocs)) {\n\t\tstruct sctp_association *asoc;\n\n\t\tinet_sk_set_state(sk, SCTP_SS_CLOSING);\n\t\tasoc = list_entry(ep->asocs.next,\n\t\t\t\t  struct sctp_association, asocs);\n\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t}\n}\n\nint sctp_get_sctp_info(struct sock *sk, struct sctp_association *asoc,\n\t\t       struct sctp_info *info)\n{\n\tstruct sctp_transport *prim;\n\tstruct list_head *pos;\n\tint mask;\n\n\tmemset(info, 0, sizeof(*info));\n\tif (!asoc) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tinfo->sctpi_s_autoclose = sp->autoclose;\n\t\tinfo->sctpi_s_adaptation_ind = sp->adaptation_ind;\n\t\tinfo->sctpi_s_pd_point = sp->pd_point;\n\t\tinfo->sctpi_s_nodelay = sp->nodelay;\n\t\tinfo->sctpi_s_disable_fragments = sp->disable_fragments;\n\t\tinfo->sctpi_s_v4mapped = sp->v4mapped;\n\t\tinfo->sctpi_s_frag_interleave = sp->frag_interleave;\n\t\tinfo->sctpi_s_type = sp->type;\n\n\t\treturn 0;\n\t}\n\n\tinfo->sctpi_tag = asoc->c.my_vtag;\n\tinfo->sctpi_state = asoc->state;\n\tinfo->sctpi_rwnd = asoc->a_rwnd;\n\tinfo->sctpi_unackdata = asoc->unack_data;\n\tinfo->sctpi_penddata = sctp_tsnmap_pending(&asoc->peer.tsn_map);\n\tinfo->sctpi_instrms = asoc->stream.incnt;\n\tinfo->sctpi_outstrms = asoc->stream.outcnt;\n\tlist_for_each(pos, &asoc->base.inqueue.in_chunk_list)\n\t\tinfo->sctpi_inqueue++;\n\tlist_for_each(pos, &asoc->outqueue.out_chunk_list)\n\t\tinfo->sctpi_outqueue++;\n\tinfo->sctpi_overall_error = asoc->overall_error_count;\n\tinfo->sctpi_max_burst = asoc->max_burst;\n\tinfo->sctpi_maxseg = asoc->frag_point;\n\tinfo->sctpi_peer_rwnd = asoc->peer.rwnd;\n\tinfo->sctpi_peer_tag = asoc->c.peer_vtag;\n\n\tmask = asoc->peer.intl_capable << 1;\n\tmask = (mask | asoc->peer.ecn_capable) << 1;\n\tmask = (mask | asoc->peer.ipv4_address) << 1;\n\tmask = (mask | asoc->peer.ipv6_address) << 1;\n\tmask = (mask | asoc->peer.reconf_capable) << 1;\n\tmask = (mask | asoc->peer.asconf_capable) << 1;\n\tmask = (mask | asoc->peer.prsctp_capable) << 1;\n\tmask = (mask | asoc->peer.auth_capable);\n\tinfo->sctpi_peer_capable = mask;\n\tmask = asoc->peer.sack_needed << 1;\n\tmask = (mask | asoc->peer.sack_generation) << 1;\n\tmask = (mask | asoc->peer.zero_window_announced);\n\tinfo->sctpi_peer_sack = mask;\n\n\tinfo->sctpi_isacks = asoc->stats.isacks;\n\tinfo->sctpi_osacks = asoc->stats.osacks;\n\tinfo->sctpi_opackets = asoc->stats.opackets;\n\tinfo->sctpi_ipackets = asoc->stats.ipackets;\n\tinfo->sctpi_rtxchunks = asoc->stats.rtxchunks;\n\tinfo->sctpi_outofseqtsns = asoc->stats.outofseqtsns;\n\tinfo->sctpi_idupchunks = asoc->stats.idupchunks;\n\tinfo->sctpi_gapcnt = asoc->stats.gapcnt;\n\tinfo->sctpi_ouodchunks = asoc->stats.ouodchunks;\n\tinfo->sctpi_iuodchunks = asoc->stats.iuodchunks;\n\tinfo->sctpi_oodchunks = asoc->stats.oodchunks;\n\tinfo->sctpi_iodchunks = asoc->stats.iodchunks;\n\tinfo->sctpi_octrlchunks = asoc->stats.octrlchunks;\n\tinfo->sctpi_ictrlchunks = asoc->stats.ictrlchunks;\n\n\tprim = asoc->peer.primary_path;\n\tmemcpy(&info->sctpi_p_address, &prim->ipaddr, sizeof(prim->ipaddr));\n\tinfo->sctpi_p_state = prim->state;\n\tinfo->sctpi_p_cwnd = prim->cwnd;\n\tinfo->sctpi_p_srtt = prim->srtt;\n\tinfo->sctpi_p_rto = jiffies_to_msecs(prim->rto);\n\tinfo->sctpi_p_hbinterval = prim->hbinterval;\n\tinfo->sctpi_p_pathmaxrxt = prim->pathmaxrxt;\n\tinfo->sctpi_p_sackdelay = jiffies_to_msecs(prim->sackdelay);\n\tinfo->sctpi_p_ssthresh = prim->ssthresh;\n\tinfo->sctpi_p_partial_bytes_acked = prim->partial_bytes_acked;\n\tinfo->sctpi_p_flight_size = prim->flight_size;\n\tinfo->sctpi_p_error = prim->error_count;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sctp_get_sctp_info);\n\n \nvoid sctp_transport_walk_start(struct rhashtable_iter *iter) __acquires(RCU)\n{\n\trhltable_walk_enter(&sctp_transport_hashtable, iter);\n\n\trhashtable_walk_start(iter);\n}\n\nvoid sctp_transport_walk_stop(struct rhashtable_iter *iter) __releases(RCU)\n{\n\trhashtable_walk_stop(iter);\n\trhashtable_walk_exit(iter);\n}\n\nstruct sctp_transport *sctp_transport_get_next(struct net *net,\n\t\t\t\t\t       struct rhashtable_iter *iter)\n{\n\tstruct sctp_transport *t;\n\n\tt = rhashtable_walk_next(iter);\n\tfor (; t; t = rhashtable_walk_next(iter)) {\n\t\tif (IS_ERR(t)) {\n\t\t\tif (PTR_ERR(t) == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!sctp_transport_hold(t))\n\t\t\tcontinue;\n\n\t\tif (net_eq(t->asoc->base.net, net) &&\n\t\t    t->asoc->peer.primary_path == t)\n\t\t\tbreak;\n\n\t\tsctp_transport_put(t);\n\t}\n\n\treturn t;\n}\n\nstruct sctp_transport *sctp_transport_get_idx(struct net *net,\n\t\t\t\t\t      struct rhashtable_iter *iter,\n\t\t\t\t\t      int pos)\n{\n\tstruct sctp_transport *t;\n\n\tif (!pos)\n\t\treturn SEQ_START_TOKEN;\n\n\twhile ((t = sctp_transport_get_next(net, iter)) && !IS_ERR(t)) {\n\t\tif (!--pos)\n\t\t\tbreak;\n\t\tsctp_transport_put(t);\n\t}\n\n\treturn t;\n}\n\nint sctp_for_each_endpoint(int (*cb)(struct sctp_endpoint *, void *),\n\t\t\t   void *p) {\n\tint err = 0;\n\tint hash = 0;\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_hashbucket *head;\n\n\tfor (head = sctp_ep_hashtable; hash < sctp_ep_hashsize;\n\t     hash++, head++) {\n\t\tread_lock_bh(&head->lock);\n\t\tsctp_for_each_hentry(ep, &head->chain) {\n\t\t\terr = cb(ep, p);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tread_unlock_bh(&head->lock);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sctp_for_each_endpoint);\n\nint sctp_transport_lookup_process(sctp_callback_t cb, struct net *net,\n\t\t\t\t  const union sctp_addr *laddr,\n\t\t\t\t  const union sctp_addr *paddr, void *p, int dif)\n{\n\tstruct sctp_transport *transport;\n\tstruct sctp_endpoint *ep;\n\tint err = -ENOENT;\n\n\trcu_read_lock();\n\ttransport = sctp_addrs_lookup_transport(net, laddr, paddr, dif, dif);\n\tif (!transport) {\n\t\trcu_read_unlock();\n\t\treturn err;\n\t}\n\tep = transport->asoc->ep;\n\tif (!sctp_endpoint_hold(ep)) {  \n\t\tsctp_transport_put(transport);\n\t\trcu_read_unlock();\n\t\treturn err;\n\t}\n\trcu_read_unlock();\n\n\terr = cb(ep, transport, p);\n\tsctp_endpoint_put(ep);\n\tsctp_transport_put(transport);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(sctp_transport_lookup_process);\n\nint sctp_transport_traverse_process(sctp_callback_t cb, sctp_callback_t cb_done,\n\t\t\t\t    struct net *net, int *pos, void *p)\n{\n\tstruct rhashtable_iter hti;\n\tstruct sctp_transport *tsp;\n\tstruct sctp_endpoint *ep;\n\tint ret;\n\nagain:\n\tret = 0;\n\tsctp_transport_walk_start(&hti);\n\n\ttsp = sctp_transport_get_idx(net, &hti, *pos + 1);\n\tfor (; !IS_ERR_OR_NULL(tsp); tsp = sctp_transport_get_next(net, &hti)) {\n\t\tep = tsp->asoc->ep;\n\t\tif (sctp_endpoint_hold(ep)) {  \n\t\t\tret = cb(ep, tsp, p);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tsctp_endpoint_put(ep);\n\t\t}\n\t\t(*pos)++;\n\t\tsctp_transport_put(tsp);\n\t}\n\tsctp_transport_walk_stop(&hti);\n\n\tif (ret) {\n\t\tif (cb_done && !cb_done(ep, tsp, p)) {\n\t\t\t(*pos)++;\n\t\t\tsctp_endpoint_put(ep);\n\t\t\tsctp_transport_put(tsp);\n\t\t\tgoto again;\n\t\t}\n\t\tsctp_endpoint_put(ep);\n\t\tsctp_transport_put(tsp);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sctp_transport_traverse_process);\n\n \nstatic int sctp_getsockopt_sctp_status(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_status status;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_transport *transport;\n\tsctp_assoc_t associd;\n\tint retval = 0;\n\n\tif (len < sizeof(status)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(status);\n\tif (copy_from_user(&status, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tassocid = status.sstat_assoc_id;\n\tasoc = sctp_id2assoc(sk, associd);\n\tif (!asoc) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttransport = asoc->peer.primary_path;\n\n\tstatus.sstat_assoc_id = sctp_assoc2id(asoc);\n\tstatus.sstat_state = sctp_assoc_to_state(asoc);\n\tstatus.sstat_rwnd =  asoc->peer.rwnd;\n\tstatus.sstat_unackdata = asoc->unack_data;\n\n\tstatus.sstat_penddata = sctp_tsnmap_pending(&asoc->peer.tsn_map);\n\tstatus.sstat_instrms = asoc->stream.incnt;\n\tstatus.sstat_outstrms = asoc->stream.outcnt;\n\tstatus.sstat_fragmentation_point = asoc->frag_point;\n\tstatus.sstat_primary.spinfo_assoc_id = sctp_assoc2id(transport->asoc);\n\tmemcpy(&status.sstat_primary.spinfo_address, &transport->ipaddr,\n\t\t\ttransport->af_specific->sockaddr_len);\n\t \n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sctp_sk(sk),\n\t\t(union sctp_addr *)&status.sstat_primary.spinfo_address);\n\tstatus.sstat_primary.spinfo_state = transport->state;\n\tstatus.sstat_primary.spinfo_cwnd = transport->cwnd;\n\tstatus.sstat_primary.spinfo_srtt = transport->srtt;\n\tstatus.sstat_primary.spinfo_rto = jiffies_to_msecs(transport->rto);\n\tstatus.sstat_primary.spinfo_mtu = transport->pathmtu;\n\n\tif (status.sstat_primary.spinfo_state == SCTP_UNKNOWN)\n\t\tstatus.sstat_primary.spinfo_state = SCTP_ACTIVE;\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"%s: len:%d, state:%d, rwnd:%d, assoc_id:%d\\n\",\n\t\t __func__, len, status.sstat_state, status.sstat_rwnd,\n\t\t status.sstat_assoc_id);\n\n\tif (copy_to_user(optval, &status, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\treturn retval;\n}\n\n\n \nstatic int sctp_getsockopt_peer_addr_info(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_paddrinfo pinfo;\n\tstruct sctp_transport *transport;\n\tint retval = 0;\n\n\tif (len < sizeof(pinfo)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(pinfo);\n\tif (copy_from_user(&pinfo, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\ttransport = sctp_addr_id2transport(sk, &pinfo.spinfo_address,\n\t\t\t\t\t   pinfo.spinfo_assoc_id);\n\tif (!transport) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (transport->state == SCTP_PF &&\n\t    transport->asoc->pf_expose == SCTP_PF_EXPOSE_DISABLE) {\n\t\tretval = -EACCES;\n\t\tgoto out;\n\t}\n\n\tpinfo.spinfo_assoc_id = sctp_assoc2id(transport->asoc);\n\tpinfo.spinfo_state = transport->state;\n\tpinfo.spinfo_cwnd = transport->cwnd;\n\tpinfo.spinfo_srtt = transport->srtt;\n\tpinfo.spinfo_rto = jiffies_to_msecs(transport->rto);\n\tpinfo.spinfo_mtu = transport->pathmtu;\n\n\tif (pinfo.spinfo_state == SCTP_UNKNOWN)\n\t\tpinfo.spinfo_state = SCTP_ACTIVE;\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(optval, &pinfo, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\treturn retval;\n}\n\n \nstatic int sctp_getsockopt_disable_fragments(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = (sctp_sk(sk)->disable_fragments == 1);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_events(struct sock *sk, int len, char __user *optval,\n\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_event_subscribe subscribe;\n\t__u8 *sn_type = (__u8 *)&subscribe;\n\tint i;\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\tif (len > sizeof(struct sctp_event_subscribe))\n\t\tlen = sizeof(struct sctp_event_subscribe);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < len; i++)\n\t\tsn_type[i] = sctp_ulpevent_type_enabled(sctp_sk(sk)->subscribe,\n\t\t\t\t\t\t\tSCTP_SN_TYPE_BASE + i);\n\n\tif (copy_to_user(optval, &subscribe, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_autoclose(struct sock *sk, int len, char __user *optval, int __user *optlen)\n{\n\t \n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\tlen = sizeof(int);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(sctp_sk(sk)->autoclose, (int __user *)optval))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nint sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\t \n\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n\t\treturn -EINVAL;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\t \n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t \n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t \n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sock->sk);\n\tsp->pf->copy_ip_options(sk, sock->sk);\n\n\t \n\terr = sctp_sock_migrate(sk, sock->sk, asoc,\n\t\t\t\tSCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\tif (err) {\n\t\tsock_release(sock);\n\t\tsock = NULL;\n\t}\n\n\t*sockp = sock;\n\n\treturn err;\n}\nEXPORT_SYMBOL(sctp_do_peeloff);\n\nstatic int sctp_getsockopt_peeloff_common(struct sock *sk, sctp_peeloff_arg_t *peeloff,\n\t\t\t\t\t  struct file **newfile, unsigned flags)\n{\n\tstruct socket *newsock;\n\tint retval;\n\n\tretval = sctp_do_peeloff(sk, peeloff->associd, &newsock);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t \n\tretval = get_unused_fd_flags(flags & SOCK_CLOEXEC);\n\tif (retval < 0) {\n\t\tsock_release(newsock);\n\t\tgoto out;\n\t}\n\n\t*newfile = sock_alloc_file(newsock, 0, NULL);\n\tif (IS_ERR(*newfile)) {\n\t\tput_unused_fd(retval);\n\t\tretval = PTR_ERR(*newfile);\n\t\t*newfile = NULL;\n\t\treturn retval;\n\t}\n\n\tpr_debug(\"%s: sk:%p, newsk:%p, sd:%d\\n\", __func__, sk, newsock->sk,\n\t\t retval);\n\n\tpeeloff->sd = retval;\n\n\tif (flags & SOCK_NONBLOCK)\n\t\t(*newfile)->f_flags |= O_NONBLOCK;\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_peeloff(struct sock *sk, int len, char __user *optval, int __user *optlen)\n{\n\tsctp_peeloff_arg_t peeloff;\n\tstruct file *newfile = NULL;\n\tint retval = 0;\n\n\tif (len < sizeof(sctp_peeloff_arg_t))\n\t\treturn -EINVAL;\n\tlen = sizeof(sctp_peeloff_arg_t);\n\tif (copy_from_user(&peeloff, optval, len))\n\t\treturn -EFAULT;\n\n\tretval = sctp_getsockopt_peeloff_common(sk, &peeloff, &newfile, 0);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t \n\tif (put_user(len, optlen)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\n\tif (copy_to_user(optval, &peeloff, len)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\tfd_install(retval, newfile);\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_peeloff_flags(struct sock *sk, int len,\n\t\t\t\t\t char __user *optval, int __user *optlen)\n{\n\tsctp_peeloff_flags_arg_t peeloff;\n\tstruct file *newfile = NULL;\n\tint retval = 0;\n\n\tif (len < sizeof(sctp_peeloff_flags_arg_t))\n\t\treturn -EINVAL;\n\tlen = sizeof(sctp_peeloff_flags_arg_t);\n\tif (copy_from_user(&peeloff, optval, len))\n\t\treturn -EFAULT;\n\n\tretval = sctp_getsockopt_peeloff_common(sk, &peeloff.p_arg,\n\t\t\t\t\t\t&newfile, peeloff.flags);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t \n\tif (put_user(len, optlen)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\n\tif (copy_to_user(optval, &peeloff, len)) {\n\t\tfput(newfile);\n\t\tput_unused_fd(retval);\n\t\treturn -EFAULT;\n\t}\n\tfd_install(retval, newfile);\nout:\n\treturn retval;\n}\n\n \nstatic int sctp_getsockopt_peer_addr_params(struct sock *sk, int len,\n\t\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_paddrparams  params;\n\tstruct sctp_transport   *trans = NULL;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\n\tif (len >= sizeof(params))\n\t\tlen = sizeof(params);\n\telse if (len >= ALIGN(offsetof(struct sctp_paddrparams,\n\t\t\t\t       spp_ipv6_flowlabel), 4))\n\t\tlen = ALIGN(offsetof(struct sctp_paddrparams,\n\t\t\t\t     spp_ipv6_flowlabel), 4);\n\telse\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&params, optval, len))\n\t\treturn -EFAULT;\n\n\t \n\tif (!sctp_is_any(sk, (union sctp_addr *)&params.spp_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &params.spp_address,\n\t\t\t\t\t       params.spp_assoc_id);\n\t\tif (!trans) {\n\t\t\tpr_debug(\"%s: failed no transport\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tasoc = sctp_id2assoc(sk, params.spp_assoc_id);\n\tif (!asoc && params.spp_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tpr_debug(\"%s: failed no association\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (trans) {\n\t\t \n\t\tparams.spp_hbinterval = jiffies_to_msecs(trans->hbinterval);\n\t\tparams.spp_pathmtu    = trans->pathmtu;\n\t\tparams.spp_pathmaxrxt = trans->pathmaxrxt;\n\t\tparams.spp_sackdelay  = jiffies_to_msecs(trans->sackdelay);\n\n\t\t \n\t\tparams.spp_flags      = trans->param_flags;\n\t\tif (trans->flowlabel & SCTP_FLOWLABEL_SET_MASK) {\n\t\t\tparams.spp_ipv6_flowlabel = trans->flowlabel &\n\t\t\t\t\t\t    SCTP_FLOWLABEL_VAL_MASK;\n\t\t\tparams.spp_flags |= SPP_IPV6_FLOWLABEL;\n\t\t}\n\t\tif (trans->dscp & SCTP_DSCP_SET_MASK) {\n\t\t\tparams.spp_dscp\t= trans->dscp & SCTP_DSCP_VAL_MASK;\n\t\t\tparams.spp_flags |= SPP_DSCP;\n\t\t}\n\t} else if (asoc) {\n\t\t \n\t\tparams.spp_hbinterval = jiffies_to_msecs(asoc->hbinterval);\n\t\tparams.spp_pathmtu    = asoc->pathmtu;\n\t\tparams.spp_pathmaxrxt = asoc->pathmaxrxt;\n\t\tparams.spp_sackdelay  = jiffies_to_msecs(asoc->sackdelay);\n\n\t\t \n\t\tparams.spp_flags      = asoc->param_flags;\n\t\tif (asoc->flowlabel & SCTP_FLOWLABEL_SET_MASK) {\n\t\t\tparams.spp_ipv6_flowlabel = asoc->flowlabel &\n\t\t\t\t\t\t    SCTP_FLOWLABEL_VAL_MASK;\n\t\t\tparams.spp_flags |= SPP_IPV6_FLOWLABEL;\n\t\t}\n\t\tif (asoc->dscp & SCTP_DSCP_SET_MASK) {\n\t\t\tparams.spp_dscp\t= asoc->dscp & SCTP_DSCP_VAL_MASK;\n\t\t\tparams.spp_flags |= SPP_DSCP;\n\t\t}\n\t} else {\n\t\t \n\t\tparams.spp_hbinterval = sp->hbinterval;\n\t\tparams.spp_pathmtu    = sp->pathmtu;\n\t\tparams.spp_sackdelay  = sp->sackdelay;\n\t\tparams.spp_pathmaxrxt = sp->pathmaxrxt;\n\n\t\t \n\t\tparams.spp_flags      = sp->param_flags;\n\t\tif (sp->flowlabel & SCTP_FLOWLABEL_SET_MASK) {\n\t\t\tparams.spp_ipv6_flowlabel = sp->flowlabel &\n\t\t\t\t\t\t    SCTP_FLOWLABEL_VAL_MASK;\n\t\t\tparams.spp_flags |= SPP_IPV6_FLOWLABEL;\n\t\t}\n\t\tif (sp->dscp & SCTP_DSCP_SET_MASK) {\n\t\t\tparams.spp_dscp\t= sp->dscp & SCTP_DSCP_VAL_MASK;\n\t\t\tparams.spp_flags |= SPP_DSCP;\n\t\t}\n\t}\n\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_delayed_ack(struct sock *sk, int len,\n\t\t\t\t\t    char __user *optval,\n\t\t\t\t\t    int __user *optlen)\n{\n\tstruct sctp_sack_info    params;\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_sock        *sp = sctp_sk(sk);\n\n\tif (len >= sizeof(struct sctp_sack_info)) {\n\t\tlen = sizeof(struct sctp_sack_info);\n\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else if (len == sizeof(struct sctp_assoc_value)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of struct sctp_assoc_value in delayed_ack socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_sack_info instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\t \n\tasoc = sctp_id2assoc(sk, params.sack_assoc_id);\n\tif (!asoc && params.sack_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\t \n\t\tif (asoc->param_flags & SPP_SACKDELAY_ENABLE) {\n\t\t\tparams.sack_delay = jiffies_to_msecs(asoc->sackdelay);\n\t\t\tparams.sack_freq = asoc->sackfreq;\n\n\t\t} else {\n\t\t\tparams.sack_delay = 0;\n\t\t\tparams.sack_freq = 1;\n\t\t}\n\t} else {\n\t\t \n\t\tif (sp->param_flags & SPP_SACKDELAY_ENABLE) {\n\t\t\tparams.sack_delay  = sp->sackdelay;\n\t\t\tparams.sack_freq = sp->sackfreq;\n\t\t} else {\n\t\t\tparams.sack_delay  = 0;\n\t\t\tparams.sack_freq = 1;\n\t\t}\n\t}\n\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_initmsg(struct sock *sk, int len, char __user *optval, int __user *optlen)\n{\n\tif (len < sizeof(struct sctp_initmsg))\n\t\treturn -EINVAL;\n\tlen = sizeof(struct sctp_initmsg);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &sctp_sk(sk)->initmsg, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n\nstatic int sctp_getsockopt_peer_addrs(struct sock *sk, int len,\n\t\t\t\t      char __user *optval, int __user *optlen)\n{\n\tstruct sctp_association *asoc;\n\tint cnt = 0;\n\tstruct sctp_getaddrs getaddrs;\n\tstruct sctp_transport *from;\n\tvoid __user *to;\n\tunion sctp_addr temp;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tint addrlen;\n\tsize_t space_left;\n\tint bytes_copied;\n\n\tif (len < sizeof(struct sctp_getaddrs))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&getaddrs, optval, sizeof(struct sctp_getaddrs)))\n\t\treturn -EFAULT;\n\n\t \n\tasoc = sctp_id2assoc(sk, getaddrs.assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tto = optval + offsetof(struct sctp_getaddrs, addrs);\n\tspace_left = len - offsetof(struct sctp_getaddrs, addrs);\n\n\tlist_for_each_entry(from, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\tmemcpy(&temp, &from->ipaddr, sizeof(temp));\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sp, &temp);\n\t\tif (space_left < addrlen)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_to_user(to, &temp, addrlen))\n\t\t\treturn -EFAULT;\n\t\tto += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t}\n\n\tif (put_user(cnt, &((struct sctp_getaddrs __user *)optval)->addr_num))\n\t\treturn -EFAULT;\n\tbytes_copied = ((char __user *)to) - optval;\n\tif (put_user(bytes_copied, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_copy_laddrs(struct sock *sk, __u16 port, void *to,\n\t\t\t    size_t space_left, int *bytes_copied)\n{\n\tstruct sctp_sockaddr_entry *addr;\n\tunion sctp_addr temp;\n\tint cnt = 0;\n\tint addrlen;\n\tstruct net *net = sock_net(sk);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(addr, &net->sctp.local_addr_list, list) {\n\t\tif (!addr->valid)\n\t\t\tcontinue;\n\n\t\tif ((PF_INET == sk->sk_family) &&\n\t\t    (AF_INET6 == addr->a.sa.sa_family))\n\t\t\tcontinue;\n\t\tif ((PF_INET6 == sk->sk_family) &&\n\t\t    inet_v6_ipv6only(sk) &&\n\t\t    (AF_INET == addr->a.sa.sa_family))\n\t\t\tcontinue;\n\t\tmemcpy(&temp, &addr->a, sizeof(temp));\n\t\tif (!temp.v4.sin_port)\n\t\t\ttemp.v4.sin_port = htons(port);\n\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sctp_sk(sk), &temp);\n\n\t\tif (space_left < addrlen) {\n\t\t\tcnt =  -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(to, &temp, addrlen);\n\n\t\tto += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t\t*bytes_copied += addrlen;\n\t}\n\trcu_read_unlock();\n\n\treturn cnt;\n}\n\n\nstatic int sctp_getsockopt_local_addrs(struct sock *sk, int len,\n\t\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sctp_bind_addr *bp;\n\tstruct sctp_association *asoc;\n\tint cnt = 0;\n\tstruct sctp_getaddrs getaddrs;\n\tstruct sctp_sockaddr_entry *addr;\n\tvoid __user *to;\n\tunion sctp_addr temp;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tint addrlen;\n\tint err = 0;\n\tsize_t space_left;\n\tint bytes_copied = 0;\n\tvoid *addrs;\n\tvoid *buf;\n\n\tif (len < sizeof(struct sctp_getaddrs))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&getaddrs, optval, sizeof(struct sctp_getaddrs)))\n\t\treturn -EFAULT;\n\n\t \n\tif (0 == getaddrs.assoc_id) {\n\t\tbp = &sctp_sk(sk)->ep->base.bind_addr;\n\t} else {\n\t\tasoc = sctp_id2assoc(sk, getaddrs.assoc_id);\n\t\tif (!asoc)\n\t\t\treturn -EINVAL;\n\t\tbp = &asoc->base.bind_addr;\n\t}\n\n\tto = optval + offsetof(struct sctp_getaddrs, addrs);\n\tspace_left = len - offsetof(struct sctp_getaddrs, addrs);\n\n\taddrs = kmalloc(space_left, GFP_USER | __GFP_NOWARN);\n\tif (!addrs)\n\t\treturn -ENOMEM;\n\n\t \n\tif (sctp_list_single_entry(&bp->address_list)) {\n\t\taddr = list_entry(bp->address_list.next,\n\t\t\t\t  struct sctp_sockaddr_entry, list);\n\t\tif (sctp_is_any(sk, &addr->a)) {\n\t\t\tcnt = sctp_copy_laddrs(sk, bp->port, addrs,\n\t\t\t\t\t\tspace_left, &bytes_copied);\n\t\t\tif (cnt < 0) {\n\t\t\t\terr = cnt;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto copy_getaddrs;\n\t\t}\n\t}\n\n\tbuf = addrs;\n\t \n\tlist_for_each_entry(addr, &bp->address_list, list) {\n\t\tmemcpy(&temp, &addr->a, sizeof(temp));\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sp, &temp);\n\t\tif (space_left < addrlen) {\n\t\t\terr =  -ENOMEM;  \n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(buf, &temp, addrlen);\n\t\tbuf += addrlen;\n\t\tbytes_copied += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t}\n\ncopy_getaddrs:\n\tif (copy_to_user(to, addrs, bytes_copied)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (put_user(cnt, &((struct sctp_getaddrs __user *)optval)->addr_num)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\t \n\tif (put_user(bytes_copied, optlen))\n\t\terr = -EFAULT;\nout:\n\tkfree(addrs);\n\treturn err;\n}\n\n \nstatic int sctp_getsockopt_primary_addr(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval, int __user *optlen)\n{\n\tstruct sctp_prim prim;\n\tstruct sctp_association *asoc;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (len < sizeof(struct sctp_prim))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_prim);\n\n\tif (copy_from_user(&prim, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, prim.ssp_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tif (!asoc->peer.primary_path)\n\t\treturn -ENOTCONN;\n\n\tmemcpy(&prim.ssp_addr, &asoc->peer.primary_path->ipaddr,\n\t\tasoc->peer.primary_path->af_specific->sockaddr_len);\n\n\tsctp_get_pf_specific(sk->sk_family)->addr_to_user(sp,\n\t\t\t(union sctp_addr *)&prim.ssp_addr);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &prim, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_adaptation_layer(struct sock *sk, int len,\n\t\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sctp_setadaptation adaptation;\n\n\tif (len < sizeof(struct sctp_setadaptation))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_setadaptation);\n\n\tadaptation.ssb_adaptation_ind = sctp_sk(sk)->adaptation_ind;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &adaptation, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_default_send_param(struct sock *sk,\n\t\t\t\t\tint len, char __user *optval,\n\t\t\t\t\tint __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_sndrcvinfo info;\n\n\tif (len < sizeof(info))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(info);\n\n\tif (copy_from_user(&info, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, info.sinfo_assoc_id);\n\tif (!asoc && info.sinfo_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tinfo.sinfo_stream = asoc->default_stream;\n\t\tinfo.sinfo_flags = asoc->default_flags;\n\t\tinfo.sinfo_ppid = asoc->default_ppid;\n\t\tinfo.sinfo_context = asoc->default_context;\n\t\tinfo.sinfo_timetolive = asoc->default_timetolive;\n\t} else {\n\t\tinfo.sinfo_stream = sp->default_stream;\n\t\tinfo.sinfo_flags = sp->default_flags;\n\t\tinfo.sinfo_ppid = sp->default_ppid;\n\t\tinfo.sinfo_context = sp->default_context;\n\t\tinfo.sinfo_timetolive = sp->default_timetolive;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &info, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_default_sndinfo(struct sock *sk, int len,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_sndinfo info;\n\n\tif (len < sizeof(info))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(info);\n\n\tif (copy_from_user(&info, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, info.snd_assoc_id);\n\tif (!asoc && info.snd_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tinfo.snd_sid = asoc->default_stream;\n\t\tinfo.snd_flags = asoc->default_flags;\n\t\tinfo.snd_ppid = asoc->default_ppid;\n\t\tinfo.snd_context = asoc->default_context;\n\t} else {\n\t\tinfo.snd_sid = sp->default_stream;\n\t\tinfo.snd_flags = sp->default_flags;\n\t\tinfo.snd_ppid = sp->default_ppid;\n\t\tinfo.snd_context = sp->default_context;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &info, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \n\nstatic int sctp_getsockopt_nodelay(struct sock *sk, int len,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = (sctp_sk(sk)->nodelay == 1);\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_rtoinfo(struct sock *sk, int len,\n\t\t\t\tchar __user *optval,\n\t\t\t\tint __user *optlen) {\n\tstruct sctp_rtoinfo rtoinfo;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof (struct sctp_rtoinfo))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_rtoinfo);\n\n\tif (copy_from_user(&rtoinfo, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, rtoinfo.srto_assoc_id);\n\n\tif (!asoc && rtoinfo.srto_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t \n\tif (asoc) {\n\t\trtoinfo.srto_initial = jiffies_to_msecs(asoc->rto_initial);\n\t\trtoinfo.srto_max = jiffies_to_msecs(asoc->rto_max);\n\t\trtoinfo.srto_min = jiffies_to_msecs(asoc->rto_min);\n\t} else {\n\t\t \n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\trtoinfo.srto_initial = sp->rtoinfo.srto_initial;\n\t\trtoinfo.srto_max = sp->rtoinfo.srto_max;\n\t\trtoinfo.srto_min = sp->rtoinfo.srto_min;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &rtoinfo, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_associnfo(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\n\tstruct sctp_assocparams assocparams;\n\tstruct sctp_association *asoc;\n\tstruct list_head *pos;\n\tint cnt = 0;\n\n\tif (len < sizeof (struct sctp_assocparams))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_assocparams);\n\n\tif (copy_from_user(&assocparams, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, assocparams.sasoc_assoc_id);\n\n\tif (!asoc && assocparams.sasoc_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t \n\tif (asoc) {\n\t\tassocparams.sasoc_asocmaxrxt = asoc->max_retrans;\n\t\tassocparams.sasoc_peer_rwnd = asoc->peer.rwnd;\n\t\tassocparams.sasoc_local_rwnd = asoc->a_rwnd;\n\t\tassocparams.sasoc_cookie_life = ktime_to_ms(asoc->cookie_life);\n\n\t\tlist_for_each(pos, &asoc->peer.transport_addr_list) {\n\t\t\tcnt++;\n\t\t}\n\n\t\tassocparams.sasoc_number_peer_destinations = cnt;\n\t} else {\n\t\t \n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tassocparams.sasoc_asocmaxrxt = sp->assocparams.sasoc_asocmaxrxt;\n\t\tassocparams.sasoc_peer_rwnd = sp->assocparams.sasoc_peer_rwnd;\n\t\tassocparams.sasoc_local_rwnd = sp->assocparams.sasoc_local_rwnd;\n\t\tassocparams.sasoc_cookie_life =\n\t\t\t\t\tsp->assocparams.sasoc_cookie_life;\n\t\tassocparams.sasoc_number_peer_destinations =\n\t\t\t\t\tsp->assocparams.\n\t\t\t\t\tsasoc_number_peer_destinations;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &assocparams, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_mappedv4(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tint val;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = sp->v4mapped;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_context(struct sock *sk, int len,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof(struct sctp_assoc_value))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_assoc_value);\n\n\tif (copy_from_user(&params, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tparams.assoc_value = asoc ? asoc->default_rcv_context\n\t\t\t\t  : sctp_sk(sk)->default_rcv_context;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_maxseg(struct sock *sk, int len,\n\t\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\n\tif (len == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in maxseg socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tparams.assoc_id = SCTP_FUTURE_ASSOC;\n\t} else if (len >= sizeof(struct sctp_assoc_value)) {\n\t\tlen = sizeof(struct sctp_assoc_value);\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc)\n\t\tparams.assoc_value = asoc->frag_point;\n\telse\n\t\tparams.assoc_value = sctp_sk(sk)->user_frag;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len == sizeof(int)) {\n\t\tif (copy_to_user(optval, &params.assoc_value, len))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_to_user(optval, &params, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_fragment_interleave(struct sock *sk, int len,\n\t\t\t\t\t       char __user *optval, int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\n\tval = sctp_sk(sk)->frag_interleave;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_partial_delivery_point(struct sock *sk, int len,\n\t\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t\t  int __user *optlen)\n{\n\tu32 val;\n\n\tif (len < sizeof(u32))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(u32);\n\n\tval = sctp_sk(sk)->pd_point;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_maxburst(struct sock *sk, int len,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\n\tif (len == sizeof(int)) {\n\t\tpr_warn_ratelimited(DEPRECATED\n\t\t\t\t    \"%s (pid %d) \"\n\t\t\t\t    \"Use of int in max_burst socket option.\\n\"\n\t\t\t\t    \"Use struct sctp_assoc_value instead\\n\",\n\t\t\t\t    current->comm, task_pid_nr(current));\n\t\tparams.assoc_id = SCTP_FUTURE_ASSOC;\n\t} else if (len >= sizeof(struct sctp_assoc_value)) {\n\t\tlen = sizeof(struct sctp_assoc_value);\n\t\tif (copy_from_user(&params, optval, len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tparams.assoc_value = asoc ? asoc->max_burst : sctp_sk(sk)->max_burst;\n\n\tif (len == sizeof(int)) {\n\t\tif (copy_to_user(optval, &params.assoc_value, len))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tif (copy_to_user(optval, &params, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int sctp_getsockopt_hmac_ident(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_hmacalgo  __user *p = (void __user *)optval;\n\tstruct sctp_hmac_algo_param *hmacs;\n\t__u16 data_len = 0;\n\tu32 num_idents;\n\tint i;\n\n\tif (!ep->auth_enable)\n\t\treturn -EACCES;\n\n\thmacs = ep->auth_hmacs_list;\n\tdata_len = ntohs(hmacs->param_hdr.length) -\n\t\t   sizeof(struct sctp_paramhdr);\n\n\tif (len < sizeof(struct sctp_hmacalgo) + data_len)\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_hmacalgo) + data_len;\n\tnum_idents = data_len / sizeof(u16);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_idents, &p->shmac_num_idents))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < num_idents; i++) {\n\t\t__u16 hmacid = ntohs(hmacs->hmac_ids[i]);\n\n\t\tif (copy_to_user(&p->shmac_idents[i], &hmacid, sizeof(__u16)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_active_key(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\n\tif (len < sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_authkeyid);\n\tif (copy_from_user(&val, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tif (!asoc->peer.auth_capable)\n\t\t\treturn -EACCES;\n\t\tval.scact_keynumber = asoc->active_key_id;\n\t} else {\n\t\tif (!ep->auth_enable)\n\t\t\treturn -EACCES;\n\t\tval.scact_keynumber = ep->active_key_id;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_peer_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks = 0;\n\tchar __user *to;\n\n\tif (len < sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tif (!asoc->peer.auth_capable)\n\t\treturn -EACCES;\n\n\tch = asoc->peer.peer_chunks;\n\tif (!ch)\n\t\tgoto num;\n\n\t \n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(struct sctp_paramhdr);\n\tif (len < num_chunks)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(to, ch->chunks, num_chunks))\n\t\treturn -EFAULT;\nnum:\n\tlen = sizeof(struct sctp_authchunks) + num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_local_auth_chunks(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct sctp_authchunks __user *p = (void __user *)optval;\n\tstruct sctp_authchunks val;\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunks_param *ch;\n\tu32    num_chunks = 0;\n\tchar __user *to;\n\n\tif (len < sizeof(struct sctp_authchunks))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&val, optval, sizeof(val)))\n\t\treturn -EFAULT;\n\n\tto = p->gauth_chunks;\n\tasoc = sctp_id2assoc(sk, val.gauth_assoc_id);\n\tif (!asoc && val.gauth_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tif (!asoc->peer.auth_capable)\n\t\t\treturn -EACCES;\n\t\tch = (struct sctp_chunks_param *)asoc->c.auth_chunks;\n\t} else {\n\t\tif (!ep->auth_enable)\n\t\t\treturn -EACCES;\n\t\tch = ep->auth_chunk_list;\n\t}\n\tif (!ch)\n\t\tgoto num;\n\n\tnum_chunks = ntohs(ch->param_hdr.length) - sizeof(struct sctp_paramhdr);\n\tif (len < sizeof(struct sctp_authchunks) + num_chunks)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(to, ch->chunks, num_chunks))\n\t\treturn -EFAULT;\nnum:\n\tlen = sizeof(struct sctp_authchunks) + num_chunks;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (put_user(num_chunks, &p->gauth_number_of_chunks))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_assoc_number(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tu32 val = 0;\n\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len < sizeof(u32))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(u32);\n\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tval++;\n\t}\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_auto_asconf(struct sock *sk, int len,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint val = 0;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tif (sctp_sk(sk)->do_auto_asconf && sctp_is_ep_boundall(sk))\n\t\tval = 1;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_assoc_ids(struct sock *sk, int len,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_association *asoc;\n\tstruct sctp_assoc_ids *ids;\n\tu32 num = 0;\n\n\tif (sctp_style(sk, TCP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (len < sizeof(struct sctp_assoc_ids))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tnum++;\n\t}\n\n\tif (len < sizeof(struct sctp_assoc_ids) + sizeof(sctp_assoc_t) * num)\n\t\treturn -EINVAL;\n\n\tlen = sizeof(struct sctp_assoc_ids) + sizeof(sctp_assoc_t) * num;\n\n\tids = kmalloc(len, GFP_USER | __GFP_NOWARN);\n\tif (unlikely(!ids))\n\t\treturn -ENOMEM;\n\n\tids->gaids_number_of_ids = num;\n\tnum = 0;\n\tlist_for_each_entry(asoc, &(sp->ep->asocs), asocs) {\n\t\tids->gaids_assoc_id[num++] = asoc->assoc_id;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, ids, len)) {\n\t\tkfree(ids);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(ids);\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_paddr_thresholds(struct sock *sk,\n\t\t\t\t\t    char __user *optval, int len,\n\t\t\t\t\t    int __user *optlen, bool v2)\n{\n\tstruct sctp_paddrthlds_v2 val;\n\tstruct sctp_transport *trans;\n\tstruct sctp_association *asoc;\n\tint min;\n\n\tmin = v2 ? sizeof(val) : sizeof(struct sctp_paddrthlds);\n\tif (len < min)\n\t\treturn -EINVAL;\n\tlen = min;\n\tif (copy_from_user(&val, optval, len))\n\t\treturn -EFAULT;\n\n\tif (!sctp_is_any(sk, (const union sctp_addr *)&val.spt_address)) {\n\t\ttrans = sctp_addr_id2transport(sk, &val.spt_address,\n\t\t\t\t\t       val.spt_assoc_id);\n\t\tif (!trans)\n\t\t\treturn -ENOENT;\n\n\t\tval.spt_pathmaxrxt = trans->pathmaxrxt;\n\t\tval.spt_pathpfthld = trans->pf_retrans;\n\t\tval.spt_pathcpthld = trans->ps_retrans;\n\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, val.spt_assoc_id);\n\tif (!asoc && val.spt_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\tval.spt_pathpfthld = asoc->pf_retrans;\n\t\tval.spt_pathmaxrxt = asoc->pathmaxrxt;\n\t\tval.spt_pathcpthld = asoc->ps_retrans;\n\t} else {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tval.spt_pathpfthld = sp->pf_retrans;\n\t\tval.spt_pathmaxrxt = sp->pathmaxrxt;\n\t\tval.spt_pathcpthld = sp->ps_retrans;\n\t}\n\nout:\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\n\t \n\tif (len < sizeof(sctp_assoc_t))\n\t\treturn -EINVAL;\n\n\t \n\tlen = min_t(size_t, len, sizeof(sas));\n\n\tif (copy_from_user(&sas, optval, len))\n\t\treturn -EFAULT;\n\n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\n\t \n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\n\t \n\tasoc->stats.max_obs_rto = asoc->rto_min;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tpr_debug(\"%s: len:%d, assoc_id:%d\\n\", __func__, len, sas.sas_assoc_id);\n\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_recvrcvinfo(struct sock *sk,\tint len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tint val = 0;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tif (sctp_sk(sk)->recvrcvinfo)\n\t\tval = 1;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_recvnxtinfo(struct sock *sk,\tint len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tint val = 0;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tif (sctp_sk(sk)->recvnxtinfo)\n\t\tval = 1;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_pr_supported(struct sock *sk, int len,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->peer.prsctp_capable\n\t\t\t\t  : sctp_sk(sk)->ep->prsctp_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_default_prinfo(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_default_prinfo info;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(info)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(info);\n\tif (copy_from_user(&info, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, info.pr_assoc_id);\n\tif (!asoc && info.pr_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (asoc) {\n\t\tinfo.pr_policy = SCTP_PR_POLICY(asoc->default_flags);\n\t\tinfo.pr_value = asoc->default_timetolive;\n\t} else {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\tinfo.pr_policy = SCTP_PR_POLICY(sp->default_flags);\n\t\tinfo.pr_value = sp->default_timetolive;\n\t}\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &info, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_pr_assocstatus(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_prstatus params;\n\tstruct sctp_association *asoc;\n\tint policy;\n\tint retval = -EINVAL;\n\n\tif (len < sizeof(params))\n\t\tgoto out;\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpolicy = params.sprstat_policy;\n\tif (!policy || (policy & ~(SCTP_PR_SCTP_MASK | SCTP_PR_SCTP_ALL)) ||\n\t    ((policy & SCTP_PR_SCTP_ALL) && (policy & SCTP_PR_SCTP_MASK)))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.sprstat_assoc_id);\n\tif (!asoc)\n\t\tgoto out;\n\n\tif (policy == SCTP_PR_SCTP_ALL) {\n\t\tparams.sprstat_abandoned_unsent = 0;\n\t\tparams.sprstat_abandoned_sent = 0;\n\t\tfor (policy = 0; policy <= SCTP_PR_INDEX(MAX); policy++) {\n\t\t\tparams.sprstat_abandoned_unsent +=\n\t\t\t\tasoc->abandoned_unsent[policy];\n\t\t\tparams.sprstat_abandoned_sent +=\n\t\t\t\tasoc->abandoned_sent[policy];\n\t\t}\n\t} else {\n\t\tparams.sprstat_abandoned_unsent =\n\t\t\tasoc->abandoned_unsent[__SCTP_PR_INDEX(policy)];\n\t\tparams.sprstat_abandoned_sent =\n\t\t\tasoc->abandoned_sent[__SCTP_PR_INDEX(policy)];\n\t}\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(optval, &params, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_pr_streamstatus(struct sock *sk, int len,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   int __user *optlen)\n{\n\tstruct sctp_stream_out_ext *streamoute;\n\tstruct sctp_association *asoc;\n\tstruct sctp_prstatus params;\n\tint retval = -EINVAL;\n\tint policy;\n\n\tif (len < sizeof(params))\n\t\tgoto out;\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tpolicy = params.sprstat_policy;\n\tif (!policy || (policy & ~(SCTP_PR_SCTP_MASK | SCTP_PR_SCTP_ALL)) ||\n\t    ((policy & SCTP_PR_SCTP_ALL) && (policy & SCTP_PR_SCTP_MASK)))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.sprstat_assoc_id);\n\tif (!asoc || params.sprstat_sid >= asoc->stream.outcnt)\n\t\tgoto out;\n\n\tstreamoute = SCTP_SO(&asoc->stream, params.sprstat_sid)->ext;\n\tif (!streamoute) {\n\t\t \n\t\tparams.sprstat_abandoned_unsent = 0;\n\t\tparams.sprstat_abandoned_sent = 0;\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\n\tif (policy == SCTP_PR_SCTP_ALL) {\n\t\tparams.sprstat_abandoned_unsent = 0;\n\t\tparams.sprstat_abandoned_sent = 0;\n\t\tfor (policy = 0; policy <= SCTP_PR_INDEX(MAX); policy++) {\n\t\t\tparams.sprstat_abandoned_unsent +=\n\t\t\t\tstreamoute->abandoned_unsent[policy];\n\t\t\tparams.sprstat_abandoned_sent +=\n\t\t\t\tstreamoute->abandoned_sent[policy];\n\t\t}\n\t} else {\n\t\tparams.sprstat_abandoned_unsent =\n\t\t\tstreamoute->abandoned_unsent[__SCTP_PR_INDEX(policy)];\n\t\tparams.sprstat_abandoned_sent =\n\t\t\tstreamoute->abandoned_sent[__SCTP_PR_INDEX(policy)];\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, &params, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_reconfig_supported(struct sock *sk, int len,\n\t\t\t\t\t      char __user *optval,\n\t\t\t\t\t      int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->peer.reconf_capable\n\t\t\t\t  : sctp_sk(sk)->ep->reconf_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_enable_strreset(struct sock *sk, int len,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->strreset_enable\n\t\t\t\t  : sctp_sk(sk)->ep->strreset_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_scheduler(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? sctp_sched_get_sched(asoc)\n\t\t\t\t  : sctp_sk(sk)->default_ss;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_scheduler_value(struct sock *sk, int len,\n\t\t\t\t\t   char __user *optval,\n\t\t\t\t\t   int __user *optlen)\n{\n\tstruct sctp_stream_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tretval = sctp_sched_get_value(asoc, params.stream_id,\n\t\t\t\t      &params.stream_value);\n\tif (retval)\n\t\tgoto out;\n\n\tif (put_user(len, optlen)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(optval, &params, len)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_interleaving_supported(struct sock *sk, int len,\n\t\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->peer.intl_capable\n\t\t\t\t  : sctp_sk(sk)->ep->intl_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_reuse_port(struct sock *sk, int len,\n\t\t\t\t      char __user *optval,\n\t\t\t\t      int __user *optlen)\n{\n\tint val;\n\n\tif (len < sizeof(int))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(int);\n\tval = sctp_sk(sk)->reuse;\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_event(struct sock *sk, int len, char __user *optval,\n\t\t\t\t int __user *optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_event param;\n\t__u16 subscribe;\n\n\tif (len < sizeof(param))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(param);\n\tif (copy_from_user(&param, optval, len))\n\t\treturn -EFAULT;\n\n\tif (param.se_type < SCTP_SN_TYPE_BASE ||\n\t    param.se_type > SCTP_SN_TYPE_MAX)\n\t\treturn -EINVAL;\n\n\tasoc = sctp_id2assoc(sk, param.se_assoc_id);\n\tif (!asoc && param.se_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\tsubscribe = asoc ? asoc->subscribe : sctp_sk(sk)->subscribe;\n\tparam.se_on = sctp_ulpevent_type_enabled(subscribe, param.se_type);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &param, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_asconf_supported(struct sock *sk, int len,\n\t\t\t\t\t    char __user *optval,\n\t\t\t\t\t    int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->peer.asconf_capable\n\t\t\t\t  : sctp_sk(sk)->ep->asconf_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_auth_supported(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->peer.auth_capable\n\t\t\t\t  : sctp_sk(sk)->ep->auth_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_ecn_supported(struct sock *sk, int len,\n\t\t\t\t\t char __user *optval,\n\t\t\t\t\t int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->peer.ecn_capable\n\t\t\t\t  : sctp_sk(sk)->ep->ecn_enable;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_pf_expose(struct sock *sk, int len,\n\t\t\t\t     char __user *optval,\n\t\t\t\t     int __user *optlen)\n{\n\tstruct sctp_assoc_value params;\n\tstruct sctp_association *asoc;\n\tint retval = -EFAULT;\n\n\tif (len < sizeof(params)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\tgoto out;\n\n\tasoc = sctp_id2assoc(sk, params.assoc_id);\n\tif (!asoc && params.assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.assoc_value = asoc ? asoc->pf_expose\n\t\t\t\t  : sctp_sk(sk)->pf_expose;\n\n\tif (put_user(len, optlen))\n\t\tgoto out;\n\n\tif (copy_to_user(optval, &params, len))\n\t\tgoto out;\n\n\tretval = 0;\n\nout:\n\treturn retval;\n}\n\nstatic int sctp_getsockopt_encap_port(struct sock *sk, int len,\n\t\t\t\t      char __user *optval, int __user *optlen)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_udpencaps encap;\n\tstruct sctp_transport *t;\n\t__be16 encap_port;\n\n\tif (len < sizeof(encap))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(encap);\n\tif (copy_from_user(&encap, optval, len))\n\t\treturn -EFAULT;\n\n\t \n\tif (!sctp_is_any(sk, (union sctp_addr *)&encap.sue_address)) {\n\t\tt = sctp_addr_id2transport(sk, &encap.sue_address,\n\t\t\t\t\t   encap.sue_assoc_id);\n\t\tif (!t) {\n\t\t\tpr_debug(\"%s: failed no transport\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tencap_port = t->encap_port;\n\t\tgoto out;\n\t}\n\n\t \n\tasoc = sctp_id2assoc(sk, encap.sue_assoc_id);\n\tif (!asoc && encap.sue_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tpr_debug(\"%s: failed no association\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (asoc) {\n\t\tencap_port = asoc->encap_port;\n\t\tgoto out;\n\t}\n\n\tencap_port = sctp_sk(sk)->encap_port;\n\nout:\n\tencap.sue_port = (__force uint16_t)encap_port;\n\tif (copy_to_user(optval, &encap, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt_probe_interval(struct sock *sk, int len,\n\t\t\t\t\t  char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct sctp_probeinterval params;\n\tstruct sctp_association *asoc;\n\tstruct sctp_transport *t;\n\t__u32 probe_interval;\n\n\tif (len < sizeof(params))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(params);\n\tif (copy_from_user(&params, optval, len))\n\t\treturn -EFAULT;\n\n\t \n\tif (!sctp_is_any(sk, (union sctp_addr *)&params.spi_address)) {\n\t\tt = sctp_addr_id2transport(sk, &params.spi_address,\n\t\t\t\t\t   params.spi_assoc_id);\n\t\tif (!t) {\n\t\t\tpr_debug(\"%s: failed no transport\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprobe_interval = jiffies_to_msecs(t->probe_interval);\n\t\tgoto out;\n\t}\n\n\t \n\tasoc = sctp_id2assoc(sk, params.spi_assoc_id);\n\tif (!asoc && params.spi_assoc_id != SCTP_FUTURE_ASSOC &&\n\t    sctp_style(sk, UDP)) {\n\t\tpr_debug(\"%s: failed no association\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (asoc) {\n\t\tprobe_interval = jiffies_to_msecs(asoc->probe_interval);\n\t\tgoto out;\n\t}\n\n\tprobe_interval = sctp_sk(sk)->probe_interval;\n\nout:\n\tparams.spi_interval = probe_interval;\n\tif (copy_to_user(optval, &params, len))\n\t\treturn -EFAULT;\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sctp_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tint retval = 0;\n\tint len;\n\n\tpr_debug(\"%s: sk:%p, optname:%d\\n\", __func__, sk, optname);\n\n\t \n\tif (level != SOL_SCTP) {\n\t\tstruct sctp_af *af = sctp_sk(sk)->pf->af;\n\n\t\tretval = af->getsockopt(sk, level, optname, optval, optlen);\n\t\treturn retval;\n\t}\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCTP_STATUS:\n\t\tretval = sctp_getsockopt_sctp_status(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DISABLE_FRAGMENTS:\n\t\tretval = sctp_getsockopt_disable_fragments(sk, len, optval,\n\t\t\t\t\t\t\t   optlen);\n\t\tbreak;\n\tcase SCTP_EVENTS:\n\t\tretval = sctp_getsockopt_events(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTOCLOSE:\n\t\tretval = sctp_getsockopt_autoclose(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_SOCKOPT_PEELOFF:\n\t\tretval = sctp_getsockopt_peeloff(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_SOCKOPT_PEELOFF_FLAGS:\n\t\tretval = sctp_getsockopt_peeloff_flags(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_PARAMS:\n\t\tretval = sctp_getsockopt_peer_addr_params(sk, len, optval,\n\t\t\t\t\t\t\t  optlen);\n\t\tbreak;\n\tcase SCTP_DELAYED_SACK:\n\t\tretval = sctp_getsockopt_delayed_ack(sk, len, optval,\n\t\t\t\t\t\t\t  optlen);\n\t\tbreak;\n\tcase SCTP_INITMSG:\n\t\tretval = sctp_getsockopt_initmsg(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_GET_PEER_ADDRS:\n\t\tretval = sctp_getsockopt_peer_addrs(sk, len, optval,\n\t\t\t\t\t\t    optlen);\n\t\tbreak;\n\tcase SCTP_GET_LOCAL_ADDRS:\n\t\tretval = sctp_getsockopt_local_addrs(sk, len, optval,\n\t\t\t\t\t\t     optlen);\n\t\tbreak;\n\tcase SCTP_SOCKOPT_CONNECTX3:\n\t\tretval = sctp_getsockopt_connectx3(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SEND_PARAM:\n\t\tretval = sctp_getsockopt_default_send_param(sk, len,\n\t\t\t\t\t\t\t    optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_SNDINFO:\n\t\tretval = sctp_getsockopt_default_sndinfo(sk, len,\n\t\t\t\t\t\t\t optval, optlen);\n\t\tbreak;\n\tcase SCTP_PRIMARY_ADDR:\n\t\tretval = sctp_getsockopt_primary_addr(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_NODELAY:\n\t\tretval = sctp_getsockopt_nodelay(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RTOINFO:\n\t\tretval = sctp_getsockopt_rtoinfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_ASSOCINFO:\n\t\tretval = sctp_getsockopt_associnfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_I_WANT_MAPPED_V4_ADDR:\n\t\tretval = sctp_getsockopt_mappedv4(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_MAXSEG:\n\t\tretval = sctp_getsockopt_maxseg(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_GET_PEER_ADDR_INFO:\n\t\tretval = sctp_getsockopt_peer_addr_info(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_ADAPTATION_LAYER:\n\t\tretval = sctp_getsockopt_adaptation_layer(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_CONTEXT:\n\t\tretval = sctp_getsockopt_context(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_FRAGMENT_INTERLEAVE:\n\t\tretval = sctp_getsockopt_fragment_interleave(sk, len, optval,\n\t\t\t\t\t\t\t     optlen);\n\t\tbreak;\n\tcase SCTP_PARTIAL_DELIVERY_POINT:\n\t\tretval = sctp_getsockopt_partial_delivery_point(sk, len, optval,\n\t\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_MAX_BURST:\n\t\tretval = sctp_getsockopt_maxburst(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_KEY:\n\tcase SCTP_AUTH_CHUNK:\n\tcase SCTP_AUTH_DELETE_KEY:\n\tcase SCTP_AUTH_DEACTIVATE_KEY:\n\t\tretval = -EOPNOTSUPP;\n\t\tbreak;\n\tcase SCTP_HMAC_IDENT:\n\t\tretval = sctp_getsockopt_hmac_ident(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_ACTIVE_KEY:\n\t\tretval = sctp_getsockopt_active_key(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_AUTH_CHUNKS:\n\t\tretval = sctp_getsockopt_peer_auth_chunks(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_LOCAL_AUTH_CHUNKS:\n\t\tretval = sctp_getsockopt_local_auth_chunks(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_GET_ASSOC_NUMBER:\n\t\tretval = sctp_getsockopt_assoc_number(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_GET_ASSOC_ID_LIST:\n\t\tretval = sctp_getsockopt_assoc_ids(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_AUTO_ASCONF:\n\t\tretval = sctp_getsockopt_auto_asconf(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_THLDS:\n\t\tretval = sctp_getsockopt_paddr_thresholds(sk, optval, len,\n\t\t\t\t\t\t\t  optlen, false);\n\t\tbreak;\n\tcase SCTP_PEER_ADDR_THLDS_V2:\n\t\tretval = sctp_getsockopt_paddr_thresholds(sk, optval, len,\n\t\t\t\t\t\t\t  optlen, true);\n\t\tbreak;\n\tcase SCTP_GET_ASSOC_STATS:\n\t\tretval = sctp_getsockopt_assoc_stats(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RECVRCVINFO:\n\t\tretval = sctp_getsockopt_recvrcvinfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_RECVNXTINFO:\n\t\tretval = sctp_getsockopt_recvnxtinfo(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PR_SUPPORTED:\n\t\tretval = sctp_getsockopt_pr_supported(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_DEFAULT_PRINFO:\n\t\tretval = sctp_getsockopt_default_prinfo(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_PR_ASSOC_STATUS:\n\t\tretval = sctp_getsockopt_pr_assocstatus(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_PR_STREAM_STATUS:\n\t\tretval = sctp_getsockopt_pr_streamstatus(sk, len, optval,\n\t\t\t\t\t\t\t optlen);\n\t\tbreak;\n\tcase SCTP_RECONFIG_SUPPORTED:\n\t\tretval = sctp_getsockopt_reconfig_supported(sk, len, optval,\n\t\t\t\t\t\t\t    optlen);\n\t\tbreak;\n\tcase SCTP_ENABLE_STREAM_RESET:\n\t\tretval = sctp_getsockopt_enable_strreset(sk, len, optval,\n\t\t\t\t\t\t\t optlen);\n\t\tbreak;\n\tcase SCTP_STREAM_SCHEDULER:\n\t\tretval = sctp_getsockopt_scheduler(sk, len, optval,\n\t\t\t\t\t\t   optlen);\n\t\tbreak;\n\tcase SCTP_STREAM_SCHEDULER_VALUE:\n\t\tretval = sctp_getsockopt_scheduler_value(sk, len, optval,\n\t\t\t\t\t\t\t optlen);\n\t\tbreak;\n\tcase SCTP_INTERLEAVING_SUPPORTED:\n\t\tretval = sctp_getsockopt_interleaving_supported(sk, len, optval,\n\t\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_REUSE_PORT:\n\t\tretval = sctp_getsockopt_reuse_port(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_EVENT:\n\t\tretval = sctp_getsockopt_event(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_ASCONF_SUPPORTED:\n\t\tretval = sctp_getsockopt_asconf_supported(sk, len, optval,\n\t\t\t\t\t\t\t  optlen);\n\t\tbreak;\n\tcase SCTP_AUTH_SUPPORTED:\n\t\tretval = sctp_getsockopt_auth_supported(sk, len, optval,\n\t\t\t\t\t\t\toptlen);\n\t\tbreak;\n\tcase SCTP_ECN_SUPPORTED:\n\t\tretval = sctp_getsockopt_ecn_supported(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_EXPOSE_POTENTIALLY_FAILED_STATE:\n\t\tretval = sctp_getsockopt_pf_expose(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_REMOTE_UDP_ENCAPS_PORT:\n\t\tretval = sctp_getsockopt_encap_port(sk, len, optval, optlen);\n\t\tbreak;\n\tcase SCTP_PLPMTUD_PROBE_INTERVAL:\n\t\tretval = sctp_getsockopt_probe_interval(sk, len, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn retval;\n}\n\nstatic bool sctp_bpf_bypass_getsockopt(int level, int optname)\n{\n\tif (level == SOL_SCTP) {\n\t\tswitch (optname) {\n\t\tcase SCTP_SOCKOPT_PEELOFF:\n\t\tcase SCTP_SOCKOPT_PEELOFF_FLAGS:\n\t\tcase SCTP_SOCKOPT_CONNECTX3:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int sctp_hash(struct sock *sk)\n{\n\t \n\treturn 0;\n}\n\nstatic void sctp_unhash(struct sock *sk)\n{\n\t \n}\n\n \nstatic struct sctp_bind_bucket *sctp_bucket_create(\n\tstruct sctp_bind_hashbucket *head, struct net *, unsigned short snum);\n\nstatic int sctp_get_port_local(struct sock *sk, union sctp_addr *addr)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tbool reuse = (sk->sk_reuse || sp->reuse);\n\tstruct sctp_bind_hashbucket *head;  \n\tstruct net *net = sock_net(sk);\n\tkuid_t uid = sock_i_uid(sk);\n\tstruct sctp_bind_bucket *pp;\n\tunsigned short snum;\n\tint ret;\n\n\tsnum = ntohs(addr->v4.sin_port);\n\n\tpr_debug(\"%s: begins, snum:%d\\n\", __func__, snum);\n\n\tif (snum == 0) {\n\t\t \n\t\tint low, high, remaining, index;\n\t\tunsigned int rover;\n\n\t\tinet_sk_get_local_port_range(sk, &low, &high);\n\t\tremaining = (high - low) + 1;\n\t\trover = get_random_u32_below(remaining) + low;\n\n\t\tdo {\n\t\t\trover++;\n\t\t\tif ((rover < low) || (rover > high))\n\t\t\t\trover = low;\n\t\t\tif (inet_is_local_reserved_port(net, rover))\n\t\t\t\tcontinue;\n\t\t\tindex = sctp_phashfn(net, rover);\n\t\t\thead = &sctp_port_hashtable[index];\n\t\t\tspin_lock_bh(&head->lock);\n\t\t\tsctp_for_each_hentry(pp, &head->chain)\n\t\t\t\tif ((pp->port == rover) &&\n\t\t\t\t    net_eq(net, pp->net))\n\t\t\t\t\tgoto next;\n\t\t\tbreak;\n\t\tnext:\n\t\t\tspin_unlock_bh(&head->lock);\n\t\t\tcond_resched();\n\t\t} while (--remaining > 0);\n\n\t\t \n\t\tret = 1;\n\t\tif (remaining <= 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tsnum = rover;\n\t} else {\n\t\t \n\t\thead = &sctp_port_hashtable[sctp_phashfn(net, snum)];\n\t\tspin_lock_bh(&head->lock);\n\t\tsctp_for_each_hentry(pp, &head->chain) {\n\t\t\tif ((pp->port == snum) && net_eq(pp->net, net))\n\t\t\t\tgoto pp_found;\n\t\t}\n\t}\n\tpp = NULL;\n\tgoto pp_not_found;\npp_found:\n\tif (!hlist_empty(&pp->owner)) {\n\t\t \n\t\tstruct sock *sk2;\n\n\t\tpr_debug(\"%s: found a possible match\\n\", __func__);\n\n\t\tif ((pp->fastreuse && reuse &&\n\t\t     sk->sk_state != SCTP_SS_LISTENING) ||\n\t\t    (pp->fastreuseport && sk->sk_reuseport &&\n\t\t     uid_eq(pp->fastuid, uid)))\n\t\t\tgoto success;\n\n\t\t \n\t\tsk_for_each_bound(sk2, &pp->owner) {\n\t\t\tint bound_dev_if2 = READ_ONCE(sk2->sk_bound_dev_if);\n\t\t\tstruct sctp_sock *sp2 = sctp_sk(sk2);\n\t\t\tstruct sctp_endpoint *ep2 = sp2->ep;\n\n\t\t\tif (sk == sk2 ||\n\t\t\t    (reuse && (sk2->sk_reuse || sp2->reuse) &&\n\t\t\t     sk2->sk_state != SCTP_SS_LISTENING) ||\n\t\t\t    (sk->sk_reuseport && sk2->sk_reuseport &&\n\t\t\t     uid_eq(uid, sock_i_uid(sk2))))\n\t\t\t\tcontinue;\n\n\t\t\tif ((!sk->sk_bound_dev_if || !bound_dev_if2 ||\n\t\t\t     sk->sk_bound_dev_if == bound_dev_if2) &&\n\t\t\t    sctp_bind_addr_conflict(&ep2->base.bind_addr,\n\t\t\t\t\t\t    addr, sp2, sp)) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto fail_unlock;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"%s: found a match\\n\", __func__);\n\t}\npp_not_found:\n\t \n\tret = 1;\n\tif (!pp && !(pp = sctp_bucket_create(head, net, snum)))\n\t\tgoto fail_unlock;\n\n\t \n\tif (hlist_empty(&pp->owner)) {\n\t\tif (reuse && sk->sk_state != SCTP_SS_LISTENING)\n\t\t\tpp->fastreuse = 1;\n\t\telse\n\t\t\tpp->fastreuse = 0;\n\n\t\tif (sk->sk_reuseport) {\n\t\t\tpp->fastreuseport = 1;\n\t\t\tpp->fastuid = uid;\n\t\t} else {\n\t\t\tpp->fastreuseport = 0;\n\t\t}\n\t} else {\n\t\tif (pp->fastreuse &&\n\t\t    (!reuse || sk->sk_state == SCTP_SS_LISTENING))\n\t\t\tpp->fastreuse = 0;\n\n\t\tif (pp->fastreuseport &&\n\t\t    (!sk->sk_reuseport || !uid_eq(pp->fastuid, uid)))\n\t\t\tpp->fastreuseport = 0;\n\t}\n\n\t \nsuccess:\n\tif (!sp->bind_hash) {\n\t\tinet_sk(sk)->inet_num = snum;\n\t\tsk_add_bind_node(sk, &pp->owner);\n\t\tsp->bind_hash = pp;\n\t}\n\tret = 0;\n\nfail_unlock:\n\tspin_unlock_bh(&head->lock);\n\treturn ret;\n}\n\n \nstatic int sctp_get_port(struct sock *sk, unsigned short snum)\n{\n\tunion sctp_addr addr;\n\tstruct sctp_af *af = sctp_sk(sk)->pf->af;\n\n\t \n\taf->from_sk(&addr, sk);\n\taddr.v4.sin_port = htons(snum);\n\n\t \n\treturn sctp_get_port_local(sk, &addr);\n}\n\n \nstatic int sctp_listen_start(struct sock *sk, int backlog)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_endpoint *ep = sp->ep;\n\tstruct crypto_shash *tfm = NULL;\n\tchar alg[32];\n\n\t \n\tif (!sp->hmac && sp->sctp_hmac_alg) {\n\t\tsprintf(alg, \"hmac(%s)\", sp->sctp_hmac_alg);\n\t\ttfm = crypto_alloc_shash(alg, 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\tnet_info_ratelimited(\"failed to load transform for %s: %ld\\n\",\n\t\t\t\t\t     sp->sctp_hmac_alg, PTR_ERR(tfm));\n\t\t\treturn -ENOSYS;\n\t\t}\n\t\tsctp_sk(sk)->hmac = tfm;\n\t}\n\n\t \n\tinet_sk_set_state(sk, SCTP_SS_LISTENING);\n\tif (!ep->base.bind_addr.port) {\n\t\tif (sctp_autobind(sk))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tif (sctp_get_port(sk, inet_sk(sk)->inet_num)) {\n\t\t\tinet_sk_set_state(sk, SCTP_SS_CLOSED);\n\t\t\treturn -EADDRINUSE;\n\t\t}\n\t}\n\n\tWRITE_ONCE(sk->sk_max_ack_backlog, backlog);\n\treturn sctp_hash_endpoint(ep);\n}\n\n \nint sctp_inet_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tint err = -EINVAL;\n\n\tif (unlikely(backlog < 0))\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\t \n\tif (sctp_style(sk, UDP_HIGH_BANDWIDTH))\n\t\tgoto out;\n\n\tif (sock->state != SS_UNCONNECTED)\n\t\tgoto out;\n\n\tif (!sctp_sstate(sk, LISTENING) && !sctp_sstate(sk, CLOSED))\n\t\tgoto out;\n\n\t \n\tif (!backlog) {\n\t\tif (sctp_sstate(sk, CLOSED))\n\t\t\tgoto out;\n\n\t\terr = 0;\n\t\tsctp_unhash_endpoint(ep);\n\t\tsk->sk_state = SCTP_SS_CLOSED;\n\t\tif (sk->sk_reuse || sctp_sk(sk)->reuse)\n\t\t\tsctp_sk(sk)->bind_hash->fastreuse = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sctp_sstate(sk, LISTENING))\n\t\tWRITE_ONCE(sk->sk_max_ack_backlog, backlog);\n\telse {\n\t\terr = sctp_listen_start(sk, backlog);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\n \n__poll_t sctp_poll(struct file *file, struct socket *sock, poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\t__poll_t mask;\n\n\tpoll_wait(file, sk_sleep(sk), wait);\n\n\tsock_rps_record_flow(sk);\n\n\t \n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\treturn (!list_empty(&sp->ep->asocs)) ?\n\t\t\t(EPOLLIN | EPOLLRDNORM) : 0;\n\n\tmask = 0;\n\n\t \n\tif (sk->sk_err || !skb_queue_empty_lockless(&sk->sk_error_queue))\n\t\tmask |= EPOLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? EPOLLPRI : 0);\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= EPOLLRDHUP | EPOLLIN | EPOLLRDNORM;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= EPOLLHUP;\n\n\t \n\tif (!skb_queue_empty_lockless(&sk->sk_receive_queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\t \n\tif (!sctp_style(sk, UDP) && sctp_sstate(sk, CLOSED))\n\t\treturn mask;\n\n\t \n\tif (sctp_writeable(sk)) {\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t} else {\n\t\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\t\t \n\t\tif (sctp_writeable(sk))\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t}\n\treturn mask;\n}\n\n \n\nstatic struct sctp_bind_bucket *sctp_bucket_create(\n\tstruct sctp_bind_hashbucket *head, struct net *net, unsigned short snum)\n{\n\tstruct sctp_bind_bucket *pp;\n\n\tpp = kmem_cache_alloc(sctp_bucket_cachep, GFP_ATOMIC);\n\tif (pp) {\n\t\tSCTP_DBG_OBJCNT_INC(bind_bucket);\n\t\tpp->port = snum;\n\t\tpp->fastreuse = 0;\n\t\tINIT_HLIST_HEAD(&pp->owner);\n\t\tpp->net = net;\n\t\thlist_add_head(&pp->node, &head->chain);\n\t}\n\treturn pp;\n}\n\n \nstatic void sctp_bucket_destroy(struct sctp_bind_bucket *pp)\n{\n\tif (pp && hlist_empty(&pp->owner)) {\n\t\t__hlist_del(&pp->node);\n\t\tkmem_cache_free(sctp_bucket_cachep, pp);\n\t\tSCTP_DBG_OBJCNT_DEC(bind_bucket);\n\t}\n}\n\n \nstatic inline void __sctp_put_port(struct sock *sk)\n{\n\tstruct sctp_bind_hashbucket *head =\n\t\t&sctp_port_hashtable[sctp_phashfn(sock_net(sk),\n\t\t\t\t\t\t  inet_sk(sk)->inet_num)];\n\tstruct sctp_bind_bucket *pp;\n\n\tspin_lock(&head->lock);\n\tpp = sctp_sk(sk)->bind_hash;\n\t__sk_del_bind_node(sk);\n\tsctp_sk(sk)->bind_hash = NULL;\n\tinet_sk(sk)->inet_num = 0;\n\tsctp_bucket_destroy(pp);\n\tspin_unlock(&head->lock);\n}\n\nvoid sctp_put_port(struct sock *sk)\n{\n\tlocal_bh_disable();\n\t__sctp_put_port(sk);\n\tlocal_bh_enable();\n}\n\n \nstatic int sctp_autobind(struct sock *sk)\n{\n\tunion sctp_addr autoaddr;\n\tstruct sctp_af *af;\n\t__be16 port;\n\n\t \n\taf = sctp_sk(sk)->pf->af;\n\n\tport = htons(inet_sk(sk)->inet_num);\n\taf->inaddr_any(&autoaddr, port);\n\n\treturn sctp_do_bind(sk, &autoaddr, af->sockaddr_len);\n}\n\n \nstatic int sctp_msghdr_parse(const struct msghdr *msg, struct sctp_cmsgs *cmsgs)\n{\n\tstruct msghdr *my_msg = (struct msghdr *)msg;\n\tstruct cmsghdr *cmsg;\n\n\tfor_each_cmsghdr(cmsg, my_msg) {\n\t\tif (!CMSG_OK(my_msg, cmsg))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (cmsg->cmsg_level != IPPROTO_SCTP)\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase SCTP_INIT:\n\t\t\t \n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_initmsg)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->init = CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tcase SCTP_SNDRCV:\n\t\t\t \n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_sndrcvinfo)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->srinfo = CMSG_DATA(cmsg);\n\n\t\t\tif (cmsgs->srinfo->sinfo_flags &\n\t\t\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t\t\t      SCTP_SACK_IMMEDIATELY | SCTP_SENDALL |\n\t\t\t      SCTP_PR_SCTP_MASK | SCTP_ABORT | SCTP_EOF))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\n\t\tcase SCTP_SNDINFO:\n\t\t\t \n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_sndinfo)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->sinfo = CMSG_DATA(cmsg);\n\n\t\t\tif (cmsgs->sinfo->snd_flags &\n\t\t\t    ~(SCTP_UNORDERED | SCTP_ADDR_OVER |\n\t\t\t      SCTP_SACK_IMMEDIATELY | SCTP_SENDALL |\n\t\t\t      SCTP_PR_SCTP_MASK | SCTP_ABORT | SCTP_EOF))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase SCTP_PRINFO:\n\t\t\t \n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_prinfo)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->prinfo = CMSG_DATA(cmsg);\n\t\t\tif (cmsgs->prinfo->pr_policy & ~SCTP_PR_SCTP_MASK)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (cmsgs->prinfo->pr_policy == SCTP_PR_SCTP_NONE)\n\t\t\t\tcmsgs->prinfo->pr_value = 0;\n\t\t\tbreak;\n\t\tcase SCTP_AUTHINFO:\n\t\t\t \n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct sctp_authinfo)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcmsgs->authinfo = CMSG_DATA(cmsg);\n\t\t\tbreak;\n\t\tcase SCTP_DSTADDRV4:\n\t\tcase SCTP_DSTADDRV6:\n\t\t\t \n\t\t\tcmsgs->addrs_msg = my_msg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sctp_wait_for_packet(struct sock *sk, int *err, long *timeo_p)\n{\n\tint error;\n\tDEFINE_WAIT(wait);\n\n\tprepare_to_wait_exclusive(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\t \n\terror = sock_error(sk);\n\tif (error)\n\t\tgoto out;\n\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tgoto ready;\n\n\t \n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out;\n\n\t \n\terror = -ENOTCONN;\n\n\t \n\tif (list_empty(&sctp_sk(sk)->ep->asocs) && !sctp_sstate(sk, LISTENING))\n\t\tgoto out;\n\n\t \n\tif (signal_pending(current))\n\t\tgoto interrupted;\n\n\t \n\trelease_sock(sk);\n\t*timeo_p = schedule_timeout(*timeo_p);\n\tlock_sock(sk);\n\nready:\n\tfinish_wait(sk_sleep(sk), &wait);\n\treturn 0;\n\ninterrupted:\n\terror = sock_intr_errno(*timeo_p);\n\nout:\n\tfinish_wait(sk_sleep(sk), &wait);\n\t*err = error;\n\treturn error;\n}\n\n \nstruct sk_buff *sctp_skb_recv_datagram(struct sock *sk, int flags, int *err)\n{\n\tint error;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\n\tpr_debug(\"%s: timeo:%ld, max:%ld\\n\", __func__, timeo,\n\t\t MAX_SCHEDULE_TIMEOUT);\n\n\tdo {\n\t\t \n\t\tif (flags & MSG_PEEK) {\n\t\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\t\tif (skb)\n\t\t\t\trefcount_inc(&skb->users);\n\t\t} else {\n\t\t\tskb = __skb_dequeue(&sk->sk_receive_queue);\n\t\t}\n\n\t\tif (skb)\n\t\t\treturn skb;\n\n\t\t \n\t\terror = sock_error(sk);\n\t\tif (error)\n\t\t\tgoto no_packet;\n\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\n\n\t\t \n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (sctp_wait_for_packet(sk, err, &timeo) == 0);\n\n\treturn NULL;\n\nno_packet:\n\t*err = error;\n\treturn NULL;\n}\n\n \nstatic void __sctp_write_space(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\tif (sctp_wspace(asoc) <= 0)\n\t\treturn;\n\n\tif (waitqueue_active(&asoc->wait))\n\t\twake_up_interruptible(&asoc->wait);\n\n\tif (sctp_writeable(sk)) {\n\t\tstruct socket_wq *wq;\n\n\t\trcu_read_lock();\n\t\twq = rcu_dereference(sk->sk_wq);\n\t\tif (wq) {\n\t\t\tif (waitqueue_active(&wq->wait))\n\t\t\t\twake_up_interruptible(&wq->wait);\n\n\t\t\t \n\t\t\tif (!(sk->sk_shutdown & SEND_SHUTDOWN))\n\t\t\t\tsock_wake_async(wq, SOCK_WAKE_SPACE, POLL_OUT);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic void sctp_wake_up_waiters(struct sock *sk,\n\t\t\t\t struct sctp_association *asoc)\n{\n\tstruct sctp_association *tmp = asoc;\n\n\t \n\tif (asoc->ep->sndbuf_policy)\n\t\treturn __sctp_write_space(asoc);\n\n\t \n\tif (asoc->base.dead)\n\t\treturn sctp_write_space(sk);\n\n\t \n\tfor (tmp = list_next_entry(tmp, asocs); 1;\n\t     tmp = list_next_entry(tmp, asocs)) {\n\t\t \n\t\tif (&tmp->asocs == &((sctp_sk(sk))->ep->asocs))\n\t\t\tcontinue;\n\t\t \n\t\t__sctp_write_space(tmp);\n\t\t \n\t\tif (tmp == asoc)\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void sctp_wfree(struct sk_buff *skb)\n{\n\tstruct sctp_chunk *chunk = skb_shinfo(skb)->destructor_arg;\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\n\tsk_mem_uncharge(sk, skb->truesize);\n\tsk_wmem_queued_add(sk, -(skb->truesize + sizeof(struct sctp_chunk)));\n\tasoc->sndbuf_used -= skb->truesize + sizeof(struct sctp_chunk);\n\tWARN_ON(refcount_sub_and_test(sizeof(struct sctp_chunk),\n\t\t\t\t      &sk->sk_wmem_alloc));\n\n\tif (chunk->shkey) {\n\t\tstruct sctp_shared_key *shkey = chunk->shkey;\n\n\t\t \n\t\tif (shkey->deactivated && !list_empty(&shkey->key_list) &&\n\t\t    refcount_read(&shkey->refcnt) == 2) {\n\t\t\tstruct sctp_ulpevent *ev;\n\n\t\t\tev = sctp_ulpevent_make_authkey(asoc, shkey->key_id,\n\t\t\t\t\t\t\tSCTP_AUTH_FREE_KEY,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (ev)\n\t\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, ev);\n\t\t}\n\t\tsctp_auth_shkey_release(chunk->shkey);\n\t}\n\n\tsock_wfree(skb);\n\tsctp_wake_up_waiters(sk, asoc);\n\n\tsctp_association_put(asoc);\n}\n\n \nvoid sctp_sock_rfree(struct sk_buff *skb)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct sctp_ulpevent *event = sctp_skb2event(skb);\n\n\tatomic_sub(event->rmem_len, &sk->sk_rmem_alloc);\n\n\t \n\tsk_mem_uncharge(sk, event->rmem_len);\n}\n\n\n \nstatic int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\tint err = 0;\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\n\t \n\tsctp_association_hold(asoc);\n\n\t \n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (asoc->base.dead)\n\t\t\tgoto do_dead;\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif ((int)msg_len <= sctp_wspace(asoc) &&\n\t\t    sk_wmem_schedule(sk, msg_len))\n\t\t\tbreak;\n\n\t\t \n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tlock_sock(sk);\n\t\tif (sk != asoc->base.sk)\n\t\t\tgoto do_error;\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t \n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_dead:\n\terr = -ESRCH;\n\tgoto out;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}\n\nvoid sctp_data_ready(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\ttrace_sk_data_ready(sk);\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (skwq_has_sleeper(wq))\n\t\twake_up_interruptible_sync_poll(&wq->wait, EPOLLIN |\n\t\t\t\t\t\tEPOLLRDNORM | EPOLLRDBAND);\n\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n\trcu_read_unlock();\n}\n\n \nvoid sctp_write_space(struct sock *sk)\n{\n\tstruct sctp_association *asoc;\n\n\t \n\tlist_for_each_entry(asoc, &((sctp_sk(sk))->ep->asocs), asocs) {\n\t\t__sctp_write_space(asoc);\n\t}\n}\n\n \nstatic bool sctp_writeable(const struct sock *sk)\n{\n\treturn READ_ONCE(sk->sk_sndbuf) > READ_ONCE(sk->sk_wmem_queued);\n}\n\n \nstatic int sctp_wait_for_connect(struct sctp_association *asoc, long *timeo_p)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld\\n\", __func__, asoc, *timeo_p);\n\n\t \n\tsctp_association_hold(asoc);\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\tbreak;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\n\t\tif (sctp_state(asoc, ESTABLISHED))\n\t\t\tbreak;\n\n\t\t \n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tlock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t \n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\tif (asoc->init_err_counter + 1 > asoc->max_init_attempts)\n\t\terr = -ETIMEDOUT;\n\telse\n\t\terr = -ECONNREFUSED;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EINPROGRESS;\n\tgoto out;\n}\n\nstatic int sctp_wait_for_accept(struct sock *sk, long timeo)\n{\n\tstruct sctp_endpoint *ep;\n\tint err = 0;\n\tDEFINE_WAIT(wait);\n\n\tep = sctp_sk(sk)->ep;\n\n\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(sk_sleep(sk), &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\n\t\tif (list_empty(&ep->asocs)) {\n\t\t\trelease_sock(sk);\n\t\t\ttimeo = schedule_timeout(timeo);\n\t\t\tlock_sock(sk);\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (!sctp_sstate(sk, LISTENING))\n\t\t\tbreak;\n\n\t\terr = 0;\n\t\tif (!list_empty(&ep->asocs))\n\t\t\tbreak;\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\terr = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t}\n\n\tfinish_wait(sk_sleep(sk), &wait);\n\n\treturn err;\n}\n\nstatic void sctp_wait_for_close(struct sock *sk, long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tdo {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tif (list_empty(&sctp_sk(sk)->ep->asocs))\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tlock_sock(sk);\n\t} while (!signal_pending(current) && timeout);\n\n\tfinish_wait(sk_sleep(sk), &wait);\n}\n\nstatic void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sk_buff *frag;\n\n\tif (!skb->data_len)\n\t\tgoto done;\n\n\t \n\tskb_walk_frags(skb, frag)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\n\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}\n\nvoid sctp_copy_sock(struct sock *newsk, struct sock *sk,\n\t\t    struct sctp_association *asoc)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct inet_sock *newinet;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tnewsk->sk_type = sk->sk_type;\n\tnewsk->sk_bound_dev_if = sk->sk_bound_dev_if;\n\tnewsk->sk_flags = sk->sk_flags;\n\tnewsk->sk_tsflags = sk->sk_tsflags;\n\tnewsk->sk_no_check_tx = sk->sk_no_check_tx;\n\tnewsk->sk_no_check_rx = sk->sk_no_check_rx;\n\tnewsk->sk_reuse = sk->sk_reuse;\n\tsctp_sk(newsk)->reuse = sp->reuse;\n\n\tnewsk->sk_shutdown = sk->sk_shutdown;\n\tnewsk->sk_destruct = sk->sk_destruct;\n\tnewsk->sk_family = sk->sk_family;\n\tnewsk->sk_protocol = IPPROTO_SCTP;\n\tnewsk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;\n\tnewsk->sk_sndbuf = sk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = sk->sk_rcvbuf;\n\tnewsk->sk_lingertime = sk->sk_lingertime;\n\tnewsk->sk_rcvtimeo = sk->sk_rcvtimeo;\n\tnewsk->sk_sndtimeo = sk->sk_sndtimeo;\n\tnewsk->sk_rxhash = sk->sk_rxhash;\n\n\tnewinet = inet_sk(newsk);\n\n\t \n\tnewinet->inet_sport = inet->inet_sport;\n\tnewinet->inet_saddr = inet->inet_saddr;\n\tnewinet->inet_rcv_saddr = inet->inet_rcv_saddr;\n\tnewinet->inet_dport = htons(asoc->peer.port);\n\tnewinet->pmtudisc = inet->pmtudisc;\n\tatomic_set(&newinet->inet_id, get_random_u16());\n\n\tnewinet->uc_ttl = inet->uc_ttl;\n\tinet_set_bit(MC_LOOP, newsk);\n\tnewinet->mc_ttl = 1;\n\tnewinet->mc_index = 0;\n\tnewinet->mc_list = NULL;\n\n\tif (newsk->sk_flags & SK_FLAGS_TIMESTAMP)\n\t\tnet_enable_timestamp();\n\n\t \n\tsecurity_sctp_sk_clone(asoc, sk, newsk);\n}\n\nstatic inline void sctp_copy_descendant(struct sock *sk_to,\n\t\t\t\t\tconst struct sock *sk_from)\n{\n\tsize_t ancestor_size = sizeof(struct inet_sock);\n\n\tancestor_size += sk_from->sk_prot->obj_size;\n\tancestor_size -= offsetof(struct sctp_sock, pd_lobby);\n\t__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);\n}\n\n \nstatic int sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,\n\t\t\t     struct sctp_association *assoc,\n\t\t\t     enum sctp_socket_type type)\n{\n\tstruct sctp_sock *oldsp = sctp_sk(oldsk);\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sctp_bind_bucket *pp;  \n\tstruct sctp_endpoint *newep = newsp->ep;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_bind_hashbucket *head;\n\tint err;\n\n\t \n\tnewsk->sk_sndbuf = oldsk->sk_sndbuf;\n\tnewsk->sk_rcvbuf = oldsk->sk_rcvbuf;\n\t \n\tsctp_copy_descendant(newsk, oldsk);\n\n\t \n\tnewsp->ep = newep;\n\tnewsp->hmac = NULL;\n\n\t \n\thead = &sctp_port_hashtable[sctp_phashfn(sock_net(oldsk),\n\t\t\t\t\t\t inet_sk(oldsk)->inet_num)];\n\tspin_lock_bh(&head->lock);\n\tpp = sctp_sk(oldsk)->bind_hash;\n\tsk_add_bind_node(newsk, &pp->owner);\n\tsctp_sk(newsk)->bind_hash = pp;\n\tinet_sk(newsk)->inet_num = inet_sk(oldsk)->inet_num;\n\tspin_unlock_bh(&head->lock);\n\n\t \n\terr = sctp_bind_addr_dup(&newsp->ep->base.bind_addr,\n\t\t\t\t &oldsp->ep->base.bind_addr, GFP_KERNEL);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (oldsp->ep->auth_hmacs) {\n\t\terr = sctp_auth_init_hmacs(newsp->ep, GFP_KERNEL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsctp_auto_asconf_init(newsp);\n\n\t \n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t \n\tatomic_set(&sctp_sk(newsk)->pd_mode, assoc->ulpq.pd_mode);\n\n\tif (atomic_read(&sctp_sk(oldsk)->pd_mode)) {\n\t\tstruct sk_buff_head *queue;\n\n\t\t \n\t\tif (assoc->ulpq.pd_mode) {\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t \n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk, NULL);\n\n\t}\n\n\tsctp_for_each_rx_skb(assoc, newsk, sctp_skb_set_owner_r_frag);\n\n\t \n\tnewsp->type = type;\n\n\t \n\tlock_sock_nested(newsk, SINGLE_DEPTH_NESTING);\n\tsctp_for_each_tx_datachunk(assoc, true, sctp_clear_owner_w);\n\tsctp_assoc_migrate(assoc, newsk);\n\tsctp_for_each_tx_datachunk(assoc, false, sctp_set_owner_w);\n\n\t \n\tif (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP)) {\n\t\tinet_sk_set_state(newsk, SCTP_SS_CLOSED);\n\t\tnewsk->sk_shutdown |= RCV_SHUTDOWN;\n\t} else {\n\t\tinet_sk_set_state(newsk, SCTP_SS_ESTABLISHED);\n\t}\n\n\trelease_sock(newsk);\n\n\treturn 0;\n}\n\n\n \nstruct proto sctp_prot = {\n\t.name        =\t\"SCTP\",\n\t.owner       =\tTHIS_MODULE,\n\t.close       =\tsctp_close,\n\t.disconnect  =\tsctp_disconnect,\n\t.accept      =\tsctp_accept,\n\t.ioctl       =\tsctp_ioctl,\n\t.init        =\tsctp_init_sock,\n\t.destroy     =\tsctp_destroy_sock,\n\t.shutdown    =\tsctp_shutdown,\n\t.setsockopt  =\tsctp_setsockopt,\n\t.getsockopt  =\tsctp_getsockopt,\n\t.bpf_bypass_getsockopt\t= sctp_bpf_bypass_getsockopt,\n\t.sendmsg     =\tsctp_sendmsg,\n\t.recvmsg     =\tsctp_recvmsg,\n\t.bind        =\tsctp_bind,\n\t.bind_add    =  sctp_bind_add,\n\t.backlog_rcv =\tsctp_backlog_rcv,\n\t.hash        =\tsctp_hash,\n\t.unhash      =\tsctp_unhash,\n\t.no_autobind =\ttrue,\n\t.obj_size    =  sizeof(struct sctp_sock),\n\t.useroffset  =  offsetof(struct sctp_sock, subscribe),\n\t.usersize    =  offsetof(struct sctp_sock, initmsg) -\n\t\t\t\toffsetof(struct sctp_sock, subscribe) +\n\t\t\t\tsizeof_field(struct sctp_sock, initmsg),\n\t.sysctl_mem  =  sysctl_sctp_mem,\n\t.sysctl_rmem =  sysctl_sctp_rmem,\n\t.sysctl_wmem =  sysctl_sctp_wmem,\n\t.memory_pressure = &sctp_memory_pressure,\n\t.enter_memory_pressure = sctp_enter_memory_pressure,\n\n\t.memory_allocated = &sctp_memory_allocated,\n\t.per_cpu_fw_alloc = &sctp_memory_per_cpu_fw_alloc,\n\n\t.sockets_allocated = &sctp_sockets_allocated,\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\n\nstatic void sctp_v6_destruct_sock(struct sock *sk)\n{\n\tsctp_destruct_common(sk);\n\tinet6_sock_destruct(sk);\n}\n\nstatic int sctp_v6_init_sock(struct sock *sk)\n{\n\tint ret = sctp_init_sock(sk);\n\n\tif (!ret)\n\t\tsk->sk_destruct = sctp_v6_destruct_sock;\n\n\treturn ret;\n}\n\nstruct proto sctpv6_prot = {\n\t.name\t\t= \"SCTPv6\",\n\t.owner\t\t= THIS_MODULE,\n\t.close\t\t= sctp_close,\n\t.disconnect\t= sctp_disconnect,\n\t.accept\t\t= sctp_accept,\n\t.ioctl\t\t= sctp_ioctl,\n\t.init\t\t= sctp_v6_init_sock,\n\t.destroy\t= sctp_destroy_sock,\n\t.shutdown\t= sctp_shutdown,\n\t.setsockopt\t= sctp_setsockopt,\n\t.getsockopt\t= sctp_getsockopt,\n\t.bpf_bypass_getsockopt\t= sctp_bpf_bypass_getsockopt,\n\t.sendmsg\t= sctp_sendmsg,\n\t.recvmsg\t= sctp_recvmsg,\n\t.bind\t\t= sctp_bind,\n\t.bind_add\t= sctp_bind_add,\n\t.backlog_rcv\t= sctp_backlog_rcv,\n\t.hash\t\t= sctp_hash,\n\t.unhash\t\t= sctp_unhash,\n\t.no_autobind\t= true,\n\t.obj_size\t= sizeof(struct sctp6_sock),\n\t.ipv6_pinfo_offset = offsetof(struct sctp6_sock, inet6),\n\t.useroffset\t= offsetof(struct sctp6_sock, sctp.subscribe),\n\t.usersize\t= offsetof(struct sctp6_sock, sctp.initmsg) -\n\t\t\t\toffsetof(struct sctp6_sock, sctp.subscribe) +\n\t\t\t\tsizeof_field(struct sctp6_sock, sctp.initmsg),\n\t.sysctl_mem\t= sysctl_sctp_mem,\n\t.sysctl_rmem\t= sysctl_sctp_rmem,\n\t.sysctl_wmem\t= sysctl_sctp_wmem,\n\t.memory_pressure = &sctp_memory_pressure,\n\t.enter_memory_pressure = sctp_enter_memory_pressure,\n\n\t.memory_allocated = &sctp_memory_allocated,\n\t.per_cpu_fw_alloc = &sctp_memory_per_cpu_fw_alloc,\n\n\t.sockets_allocated = &sctp_sockets_allocated,\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}