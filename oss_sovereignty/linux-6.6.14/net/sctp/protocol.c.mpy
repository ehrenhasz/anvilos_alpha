{
  "module_name": "protocol.c",
  "hash_id": "2bedf41b1d510e0be939b3f6ea85a6d175a00d55d2edaba7cc4a6139d87360bf",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/protocol.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/memblock.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <net/net_namespace.h>\n#include <net/protocol.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/route.h>\n#include <net/sctp/sctp.h>\n#include <net/addrconf.h>\n#include <net/inet_common.h>\n#include <net/inet_ecn.h>\n#include <net/udp_tunnel.h>\n\n#define MAX_SCTP_PORT_HASH_ENTRIES (64 * 1024)\n\n \nstruct sctp_globals sctp_globals __read_mostly;\n\nstruct idr sctp_assocs_id;\nDEFINE_SPINLOCK(sctp_assocs_id_lock);\n\nstatic struct sctp_pf *sctp_pf_inet6_specific;\nstatic struct sctp_pf *sctp_pf_inet_specific;\nstatic struct sctp_af *sctp_af_v4_specific;\nstatic struct sctp_af *sctp_af_v6_specific;\n\nstruct kmem_cache *sctp_chunk_cachep __read_mostly;\nstruct kmem_cache *sctp_bucket_cachep __read_mostly;\n\nlong sysctl_sctp_mem[3];\nint sysctl_sctp_rmem[3];\nint sysctl_sctp_wmem[3];\n\n \nstatic void sctp_v4_copy_addrlist(struct list_head *addrlist,\n\t\t\t\t  struct net_device *dev)\n{\n\tstruct in_device *in_dev;\n\tstruct in_ifaddr *ifa;\n\tstruct sctp_sockaddr_entry *addr;\n\n\trcu_read_lock();\n\tif ((in_dev = __in_dev_get_rcu(dev)) == NULL) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tin_dev_for_each_ifa_rcu(ifa, in_dev) {\n\t\t \n\t\taddr = kzalloc(sizeof(*addr), GFP_ATOMIC);\n\t\tif (addr) {\n\t\t\taddr->a.v4.sin_family = AF_INET;\n\t\t\taddr->a.v4.sin_addr.s_addr = ifa->ifa_local;\n\t\t\taddr->valid = 1;\n\t\t\tINIT_LIST_HEAD(&addr->list);\n\t\t\tlist_add_tail(&addr->list, addrlist);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n}\n\n \nstatic void sctp_get_local_addr_list(struct net *net)\n{\n\tstruct net_device *dev;\n\tstruct list_head *pos;\n\tstruct sctp_af *af;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tlist_for_each(pos, &sctp_address_families) {\n\t\t\taf = list_entry(pos, struct sctp_af, list);\n\t\t\taf->copy_addrlist(&net->sctp.local_addr_list, dev);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void sctp_free_local_addr_list(struct net *net)\n{\n\tstruct sctp_sockaddr_entry *addr;\n\tstruct list_head *pos, *temp;\n\n\tlist_for_each_safe(pos, temp, &net->sctp.local_addr_list) {\n\t\taddr = list_entry(pos, struct sctp_sockaddr_entry, list);\n\t\tlist_del(pos);\n\t\tkfree(addr);\n\t}\n}\n\n \nint sctp_copy_local_addr_list(struct net *net, struct sctp_bind_addr *bp,\n\t\t\t      enum sctp_scope scope, gfp_t gfp, int copy_flags)\n{\n\tstruct sctp_sockaddr_entry *addr;\n\tunion sctp_addr laddr;\n\tint error = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(addr, &net->sctp.local_addr_list, list) {\n\t\tif (!addr->valid)\n\t\t\tcontinue;\n\t\tif (!sctp_in_scope(net, &addr->a, scope))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (addr->a.sa.sa_family == AF_INET &&\n\t\t    (!(copy_flags & SCTP_ADDR4_ALLOWED) ||\n\t\t     !(copy_flags & SCTP_ADDR4_PEERSUPP)))\n\t\t\tcontinue;\n\t\tif (addr->a.sa.sa_family == AF_INET6 &&\n\t\t    (!(copy_flags & SCTP_ADDR6_ALLOWED) ||\n\t\t     !(copy_flags & SCTP_ADDR6_PEERSUPP)))\n\t\t\tcontinue;\n\n\t\tladdr = addr->a;\n\t\t \n\t\tladdr.v4.sin_port = htons(bp->port);\n\t\tif (sctp_bind_addr_state(bp, &laddr) != -1)\n\t\t\tcontinue;\n\n\t\terror = sctp_add_bind_addr(bp, &addr->a, sizeof(addr->a),\n\t\t\t\t\t   SCTP_ADDR_SRC, GFP_ATOMIC);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\treturn error;\n}\n\n \nstatic void sctp_v4_copy_ip_options(struct sock *sk, struct sock *newsk)\n{\n\tstruct inet_sock *newinet, *inet = inet_sk(sk);\n\tstruct ip_options_rcu *inet_opt, *newopt = NULL;\n\n\tnewinet = inet_sk(newsk);\n\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt) {\n\t\tnewopt = sock_kmalloc(newsk, sizeof(*inet_opt) +\n\t\t\t\t      inet_opt->opt.optlen, GFP_ATOMIC);\n\t\tif (newopt)\n\t\t\tmemcpy(newopt, inet_opt, sizeof(*inet_opt) +\n\t\t\t       inet_opt->opt.optlen);\n\t\telse\n\t\t\tpr_err(\"%s: Failed to copy ip options\\n\", __func__);\n\t}\n\tRCU_INIT_POINTER(newinet->inet_opt, newopt);\n\trcu_read_unlock();\n}\n\n \nstatic int sctp_v4_ip_options_len(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options_rcu *inet_opt;\n\tint len = 0;\n\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt)\n\t\tlen = inet_opt->opt.optlen;\n\n\trcu_read_unlock();\n\treturn len;\n}\n\n \nstatic void sctp_v4_from_skb(union sctp_addr *addr, struct sk_buff *skb,\n\t\t\t     int is_saddr)\n{\n\t \n\tstruct sctphdr *sh = sctp_hdr(skb);\n\tstruct sockaddr_in *sa = &addr->v4;\n\n\taddr->v4.sin_family = AF_INET;\n\n\tif (is_saddr) {\n\t\tsa->sin_port = sh->source;\n\t\tsa->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t} else {\n\t\tsa->sin_port = sh->dest;\n\t\tsa->sin_addr.s_addr = ip_hdr(skb)->daddr;\n\t}\n\tmemset(sa->sin_zero, 0, sizeof(sa->sin_zero));\n}\n\n \nstatic void sctp_v4_from_sk(union sctp_addr *addr, struct sock *sk)\n{\n\taddr->v4.sin_family = AF_INET;\n\taddr->v4.sin_port = 0;\n\taddr->v4.sin_addr.s_addr = inet_sk(sk)->inet_rcv_saddr;\n\tmemset(addr->v4.sin_zero, 0, sizeof(addr->v4.sin_zero));\n}\n\n \nstatic void sctp_v4_to_sk_saddr(union sctp_addr *addr, struct sock *sk)\n{\n\tinet_sk(sk)->inet_rcv_saddr = addr->v4.sin_addr.s_addr;\n}\n\n \nstatic void sctp_v4_to_sk_daddr(union sctp_addr *addr, struct sock *sk)\n{\n\tinet_sk(sk)->inet_daddr = addr->v4.sin_addr.s_addr;\n}\n\n \nstatic bool sctp_v4_from_addr_param(union sctp_addr *addr,\n\t\t\t\t    union sctp_addr_param *param,\n\t\t\t\t    __be16 port, int iif)\n{\n\tif (ntohs(param->v4.param_hdr.length) < sizeof(struct sctp_ipv4addr_param))\n\t\treturn false;\n\n\taddr->v4.sin_family = AF_INET;\n\taddr->v4.sin_port = port;\n\taddr->v4.sin_addr.s_addr = param->v4.addr.s_addr;\n\tmemset(addr->v4.sin_zero, 0, sizeof(addr->v4.sin_zero));\n\n\treturn true;\n}\n\n \nstatic int sctp_v4_to_addr_param(const union sctp_addr *addr,\n\t\t\t\t union sctp_addr_param *param)\n{\n\tint length = sizeof(struct sctp_ipv4addr_param);\n\n\tparam->v4.param_hdr.type = SCTP_PARAM_IPV4_ADDRESS;\n\tparam->v4.param_hdr.length = htons(length);\n\tparam->v4.addr.s_addr = addr->v4.sin_addr.s_addr;\n\n\treturn length;\n}\n\n \nstatic void sctp_v4_dst_saddr(union sctp_addr *saddr, struct flowi4 *fl4,\n\t\t\t      __be16 port)\n{\n\tsaddr->v4.sin_family = AF_INET;\n\tsaddr->v4.sin_port = port;\n\tsaddr->v4.sin_addr.s_addr = fl4->saddr;\n\tmemset(saddr->v4.sin_zero, 0, sizeof(saddr->v4.sin_zero));\n}\n\n \nstatic int sctp_v4_cmp_addr(const union sctp_addr *addr1,\n\t\t\t    const union sctp_addr *addr2)\n{\n\tif (addr1->sa.sa_family != addr2->sa.sa_family)\n\t\treturn 0;\n\tif (addr1->v4.sin_port != addr2->v4.sin_port)\n\t\treturn 0;\n\tif (addr1->v4.sin_addr.s_addr != addr2->v4.sin_addr.s_addr)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic void sctp_v4_inaddr_any(union sctp_addr *addr, __be16 port)\n{\n\taddr->v4.sin_family = AF_INET;\n\taddr->v4.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr->v4.sin_port = port;\n\tmemset(addr->v4.sin_zero, 0, sizeof(addr->v4.sin_zero));\n}\n\n \nstatic int sctp_v4_is_any(const union sctp_addr *addr)\n{\n\treturn htonl(INADDR_ANY) == addr->v4.sin_addr.s_addr;\n}\n\n \nstatic int sctp_v4_addr_valid(union sctp_addr *addr,\n\t\t\t      struct sctp_sock *sp,\n\t\t\t      const struct sk_buff *skb)\n{\n\t \n\tif (sp && ipv6_only_sock(sctp_opt2sk(sp)))\n\t\treturn 0;\n\n\t \n\tif (IS_IPV4_UNUSABLE_ADDRESS(addr->v4.sin_addr.s_addr))\n\t\treturn 0;\n\n\t \n\tif (skb && skb_rtable(skb)->rt_flags & RTCF_BROADCAST)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic int sctp_v4_available(union sctp_addr *addr, struct sctp_sock *sp)\n{\n\tstruct sock *sk = &sp->inet.sk;\n\tstruct net *net = sock_net(sk);\n\tint tb_id = RT_TABLE_LOCAL;\n\tint ret;\n\n\ttb_id = l3mdev_fib_table_by_index(net, sk->sk_bound_dev_if) ?: tb_id;\n\tret = inet_addr_type_table(net, addr->v4.sin_addr.s_addr, tb_id);\n\tif (addr->v4.sin_addr.s_addr != htonl(INADDR_ANY) &&\n\t   ret != RTN_LOCAL &&\n\t   !inet_test_bit(FREEBIND, sk) &&\n\t    !READ_ONCE(net->ipv4.sysctl_ip_nonlocal_bind))\n\t\treturn 0;\n\n\tif (ipv6_only_sock(sctp_opt2sk(sp)))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic enum sctp_scope sctp_v4_scope(union sctp_addr *addr)\n{\n\tenum sctp_scope retval;\n\n\t \n\tif (IS_IPV4_UNUSABLE_ADDRESS(addr->v4.sin_addr.s_addr)) {\n\t\tretval =  SCTP_SCOPE_UNUSABLE;\n\t} else if (ipv4_is_loopback(addr->v4.sin_addr.s_addr)) {\n\t\tretval = SCTP_SCOPE_LOOPBACK;\n\t} else if (ipv4_is_linklocal_169(addr->v4.sin_addr.s_addr)) {\n\t\tretval = SCTP_SCOPE_LINK;\n\t} else if (ipv4_is_private_10(addr->v4.sin_addr.s_addr) ||\n\t\t   ipv4_is_private_172(addr->v4.sin_addr.s_addr) ||\n\t\t   ipv4_is_private_192(addr->v4.sin_addr.s_addr) ||\n\t\t   ipv4_is_test_198(addr->v4.sin_addr.s_addr)) {\n\t\tretval = SCTP_SCOPE_PRIVATE;\n\t} else {\n\t\tretval = SCTP_SCOPE_GLOBAL;\n\t}\n\n\treturn retval;\n}\n\n \nstatic void sctp_v4_get_dst(struct sctp_transport *t, union sctp_addr *saddr,\n\t\t\t\tstruct flowi *fl, struct sock *sk)\n{\n\tstruct sctp_association *asoc = t->asoc;\n\tstruct rtable *rt;\n\tstruct flowi _fl;\n\tstruct flowi4 *fl4 = &_fl.u.ip4;\n\tstruct sctp_bind_addr *bp;\n\tstruct sctp_sockaddr_entry *laddr;\n\tstruct dst_entry *dst = NULL;\n\tunion sctp_addr *daddr = &t->ipaddr;\n\tunion sctp_addr dst_saddr;\n\t__u8 tos = inet_sk(sk)->tos;\n\n\tif (t->dscp & SCTP_DSCP_SET_MASK)\n\t\ttos = t->dscp & SCTP_DSCP_VAL_MASK;\n\tmemset(&_fl, 0x0, sizeof(_fl));\n\tfl4->daddr  = daddr->v4.sin_addr.s_addr;\n\tfl4->fl4_dport = daddr->v4.sin_port;\n\tfl4->flowi4_proto = IPPROTO_SCTP;\n\tif (asoc) {\n\t\tfl4->flowi4_tos = RT_TOS(tos);\n\t\tfl4->flowi4_scope = ip_sock_rt_scope(asoc->base.sk);\n\t\tfl4->flowi4_oif = asoc->base.sk->sk_bound_dev_if;\n\t\tfl4->fl4_sport = htons(asoc->base.bind_addr.port);\n\t}\n\tif (saddr) {\n\t\tfl4->saddr = saddr->v4.sin_addr.s_addr;\n\t\tif (!fl4->fl4_sport)\n\t\t\tfl4->fl4_sport = saddr->v4.sin_port;\n\t}\n\n\tpr_debug(\"%s: dst:%pI4, src:%pI4 - \", __func__, &fl4->daddr,\n\t\t &fl4->saddr);\n\n\trt = ip_route_output_key(sock_net(sk), fl4);\n\tif (!IS_ERR(rt)) {\n\t\tdst = &rt->dst;\n\t\tt->dst = dst;\n\t\tmemcpy(fl, &_fl, sizeof(_fl));\n\t}\n\n\t \n\tif (!asoc || saddr)\n\t\tgoto out;\n\n\tbp = &asoc->base.bind_addr;\n\n\tif (dst) {\n\t\t \n\t\tsctp_v4_dst_saddr(&dst_saddr, fl4, htons(bp->port));\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\t\tif (!laddr->valid || (laddr->state == SCTP_ADDR_DEL) ||\n\t\t\t    (laddr->state != SCTP_ADDR_SRC &&\n\t\t\t    !asoc->src_out_of_asoc_ok))\n\t\t\t\tcontinue;\n\t\t\tif (sctp_v4_cmp_addr(&dst_saddr, &laddr->a))\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\t \n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\tstruct net_device *odev;\n\n\t\tif (!laddr->valid)\n\t\t\tcontinue;\n\t\tif (laddr->state != SCTP_ADDR_SRC ||\n\t\t    AF_INET != laddr->a.sa.sa_family)\n\t\t\tcontinue;\n\n\t\tfl4->fl4_sport = laddr->a.v4.sin_port;\n\t\tflowi4_update_output(fl4, asoc->base.sk->sk_bound_dev_if,\n\t\t\t\t     daddr->v4.sin_addr.s_addr,\n\t\t\t\t     laddr->a.v4.sin_addr.s_addr);\n\n\t\trt = ip_route_output_key(sock_net(sk), fl4);\n\t\tif (IS_ERR(rt))\n\t\t\tcontinue;\n\n\t\t \n\t\todev = __ip_dev_find(sock_net(sk), laddr->a.v4.sin_addr.s_addr,\n\t\t\t\t     false);\n\t\tif (!odev || odev->ifindex != fl4->flowi4_oif) {\n\t\t\tif (!dst) {\n\t\t\t\tdst = &rt->dst;\n\t\t\t\tt->dst = dst;\n\t\t\t\tmemcpy(fl, &_fl, sizeof(_fl));\n\t\t\t} else {\n\t\t\t\tdst_release(&rt->dst);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tdst_release(dst);\n\t\tdst = &rt->dst;\n\t\tt->dst = dst;\n\t\tmemcpy(fl, &_fl, sizeof(_fl));\n\t\tbreak;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\nout:\n\tif (dst) {\n\t\tpr_debug(\"rt_dst:%pI4, rt_src:%pI4\\n\",\n\t\t\t &fl->u.ip4.daddr, &fl->u.ip4.saddr);\n\t} else {\n\t\tt->dst = NULL;\n\t\tpr_debug(\"no route\\n\");\n\t}\n}\n\n \nstatic void sctp_v4_get_saddr(struct sctp_sock *sk,\n\t\t\t      struct sctp_transport *t,\n\t\t\t      struct flowi *fl)\n{\n\tunion sctp_addr *saddr = &t->saddr;\n\tstruct rtable *rt = (struct rtable *)t->dst;\n\n\tif (rt) {\n\t\tsaddr->v4.sin_family = AF_INET;\n\t\tsaddr->v4.sin_addr.s_addr = fl->u.ip4.saddr;\n\t}\n}\n\n \nstatic int sctp_v4_skb_iif(const struct sk_buff *skb)\n{\n\treturn inet_iif(skb);\n}\n\nstatic int sctp_v4_skb_sdif(const struct sk_buff *skb)\n{\n\treturn inet_sdif(skb);\n}\n\n \nstatic int sctp_v4_is_ce(const struct sk_buff *skb)\n{\n\treturn INET_ECN_is_ce(ip_hdr(skb)->tos);\n}\n\n \nstatic struct sock *sctp_v4_create_accept_sk(struct sock *sk,\n\t\t\t\t\t     struct sctp_association *asoc,\n\t\t\t\t\t     bool kern)\n{\n\tstruct sock *newsk = sk_alloc(sock_net(sk), PF_INET, GFP_KERNEL,\n\t\t\tsk->sk_prot, kern);\n\tstruct inet_sock *newinet;\n\n\tif (!newsk)\n\t\tgoto out;\n\n\tsock_init_data(NULL, newsk);\n\n\tsctp_copy_sock(newsk, sk, asoc);\n\tsock_reset_flag(newsk, SOCK_ZAPPED);\n\n\tsctp_v4_copy_ip_options(sk, newsk);\n\n\tnewinet = inet_sk(newsk);\n\n\tnewinet->inet_daddr = asoc->peer.primary_addr.v4.sin_addr.s_addr;\n\n\tif (newsk->sk_prot->init(newsk)) {\n\t\tsk_common_release(newsk);\n\t\tnewsk = NULL;\n\t}\n\nout:\n\treturn newsk;\n}\n\nstatic int sctp_v4_addr_to_user(struct sctp_sock *sp, union sctp_addr *addr)\n{\n\t \n\tmemset(addr->v4.sin_zero, 0, sizeof(addr->v4.sin_zero));\n\treturn sizeof(struct sockaddr_in);\n}\n\n \nstatic void sctp_v4_seq_dump_addr(struct seq_file *seq, union sctp_addr *addr)\n{\n\tseq_printf(seq, \"%pI4 \", &addr->v4.sin_addr);\n}\n\nstatic void sctp_v4_ecn_capable(struct sock *sk)\n{\n\tINET_ECN_xmit(sk);\n}\n\nstatic void sctp_addr_wq_timeout_handler(struct timer_list *t)\n{\n\tstruct net *net = from_timer(net, t, sctp.addr_wq_timer);\n\tstruct sctp_sockaddr_entry *addrw, *temp;\n\tstruct sctp_sock *sp;\n\n\tspin_lock_bh(&net->sctp.addr_wq_lock);\n\n\tlist_for_each_entry_safe(addrw, temp, &net->sctp.addr_waitq, list) {\n\t\tpr_debug(\"%s: the first ent in wq:%p is addr:%pISc for cmd:%d at \"\n\t\t\t \"entry:%p\\n\", __func__, &net->sctp.addr_waitq, &addrw->a.sa,\n\t\t\t addrw->state, addrw);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t \n\t\t \n\t\tif (addrw->a.sa.sa_family == AF_INET6) {\n\t\t\tstruct in6_addr *in6;\n\n\t\t\tif (ipv6_addr_type(&addrw->a.v6.sin6_addr) &\n\t\t\t    IPV6_ADDR_LINKLOCAL)\n\t\t\t\tgoto free_next;\n\n\t\t\tin6 = (struct in6_addr *)&addrw->a.v6.sin6_addr;\n\t\t\tif (ipv6_chk_addr(net, in6, NULL, 0) == 0 &&\n\t\t\t    addrw->state == SCTP_ADDR_NEW) {\n\t\t\t\tunsigned long timeo_val;\n\n\t\t\t\tpr_debug(\"%s: this is on DAD, trying %d sec \"\n\t\t\t\t\t \"later\\n\", __func__,\n\t\t\t\t\t SCTP_ADDRESS_TICK_DELAY);\n\n\t\t\t\ttimeo_val = jiffies;\n\t\t\t\ttimeo_val += msecs_to_jiffies(SCTP_ADDRESS_TICK_DELAY);\n\t\t\t\tmod_timer(&net->sctp.addr_wq_timer, timeo_val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#endif\n\t\tlist_for_each_entry(sp, &net->sctp.auto_asconf_splist, auto_asconf_list) {\n\t\t\tstruct sock *sk;\n\n\t\t\tsk = sctp_opt2sk(sp);\n\t\t\t \n\t\t\tif (!sctp_is_ep_boundall(sk))\n\t\t\t\tcontinue;\n\t\t\tbh_lock_sock(sk);\n\t\t\tif (sctp_asconf_mgmt(sp, addrw) < 0)\n\t\t\t\tpr_debug(\"%s: sctp_asconf_mgmt failed\\n\", __func__);\n\t\t\tbh_unlock_sock(sk);\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\nfree_next:\n#endif\n\t\tlist_del(&addrw->list);\n\t\tkfree(addrw);\n\t}\n\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n}\n\nstatic void sctp_free_addr_wq(struct net *net)\n{\n\tstruct sctp_sockaddr_entry *addrw;\n\tstruct sctp_sockaddr_entry *temp;\n\n\tspin_lock_bh(&net->sctp.addr_wq_lock);\n\tdel_timer(&net->sctp.addr_wq_timer);\n\tlist_for_each_entry_safe(addrw, temp, &net->sctp.addr_waitq, list) {\n\t\tlist_del(&addrw->list);\n\t\tkfree(addrw);\n\t}\n\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n}\n\n \nstatic struct sctp_sockaddr_entry *sctp_addr_wq_lookup(struct net *net,\n\t\t\t\t\tstruct sctp_sockaddr_entry *addr)\n{\n\tstruct sctp_sockaddr_entry *addrw;\n\n\tlist_for_each_entry(addrw, &net->sctp.addr_waitq, list) {\n\t\tif (addrw->a.sa.sa_family != addr->a.sa.sa_family)\n\t\t\tcontinue;\n\t\tif (addrw->a.sa.sa_family == AF_INET) {\n\t\t\tif (addrw->a.v4.sin_addr.s_addr ==\n\t\t\t    addr->a.v4.sin_addr.s_addr)\n\t\t\t\treturn addrw;\n\t\t} else if (addrw->a.sa.sa_family == AF_INET6) {\n\t\t\tif (ipv6_addr_equal(&addrw->a.v6.sin6_addr,\n\t\t\t    &addr->a.v6.sin6_addr))\n\t\t\t\treturn addrw;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid sctp_addr_wq_mgmt(struct net *net, struct sctp_sockaddr_entry *addr, int cmd)\n{\n\tstruct sctp_sockaddr_entry *addrw;\n\tunsigned long timeo_val;\n\n\t \n\n\tspin_lock_bh(&net->sctp.addr_wq_lock);\n\t \n\taddrw = sctp_addr_wq_lookup(net, addr);\n\tif (addrw) {\n\t\tif (addrw->state != cmd) {\n\t\t\tpr_debug(\"%s: offsets existing entry for %d, addr:%pISc \"\n\t\t\t\t \"in wq:%p\\n\", __func__, addrw->state, &addrw->a.sa,\n\t\t\t\t &net->sctp.addr_waitq);\n\n\t\t\tlist_del(&addrw->list);\n\t\t\tkfree(addrw);\n\t\t}\n\t\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n\t\treturn;\n\t}\n\n\t \n\taddrw = kmemdup(addr, sizeof(struct sctp_sockaddr_entry), GFP_ATOMIC);\n\tif (addrw == NULL) {\n\t\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n\t\treturn;\n\t}\n\taddrw->state = cmd;\n\tlist_add_tail(&addrw->list, &net->sctp.addr_waitq);\n\n\tpr_debug(\"%s: add new entry for cmd:%d, addr:%pISc in wq:%p\\n\",\n\t\t __func__, addrw->state, &addrw->a.sa, &net->sctp.addr_waitq);\n\n\tif (!timer_pending(&net->sctp.addr_wq_timer)) {\n\t\ttimeo_val = jiffies;\n\t\ttimeo_val += msecs_to_jiffies(SCTP_ADDRESS_TICK_DELAY);\n\t\tmod_timer(&net->sctp.addr_wq_timer, timeo_val);\n\t}\n\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n}\n\n \nstatic int sctp_inetaddr_event(struct notifier_block *this, unsigned long ev,\n\t\t\t       void *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\tstruct sctp_sockaddr_entry *addr = NULL;\n\tstruct sctp_sockaddr_entry *temp;\n\tstruct net *net = dev_net(ifa->ifa_dev->dev);\n\tint found = 0;\n\n\tswitch (ev) {\n\tcase NETDEV_UP:\n\t\taddr = kzalloc(sizeof(*addr), GFP_ATOMIC);\n\t\tif (addr) {\n\t\t\taddr->a.v4.sin_family = AF_INET;\n\t\t\taddr->a.v4.sin_addr.s_addr = ifa->ifa_local;\n\t\t\taddr->valid = 1;\n\t\t\tspin_lock_bh(&net->sctp.local_addr_lock);\n\t\t\tlist_add_tail_rcu(&addr->list, &net->sctp.local_addr_list);\n\t\t\tsctp_addr_wq_mgmt(net, addr, SCTP_ADDR_NEW);\n\t\t\tspin_unlock_bh(&net->sctp.local_addr_lock);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tspin_lock_bh(&net->sctp.local_addr_lock);\n\t\tlist_for_each_entry_safe(addr, temp,\n\t\t\t\t\t&net->sctp.local_addr_list, list) {\n\t\t\tif (addr->a.sa.sa_family == AF_INET &&\n\t\t\t\t\taddr->a.v4.sin_addr.s_addr ==\n\t\t\t\t\tifa->ifa_local) {\n\t\t\t\tsctp_addr_wq_mgmt(net, addr, SCTP_ADDR_DEL);\n\t\t\t\tfound = 1;\n\t\t\t\taddr->valid = 0;\n\t\t\t\tlist_del_rcu(&addr->list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&net->sctp.local_addr_lock);\n\t\tif (found)\n\t\t\tkfree_rcu(addr, rcu);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic int sctp_ctl_sock_init(struct net *net)\n{\n\tint err;\n\tsa_family_t family = PF_INET;\n\n\tif (sctp_get_pf_specific(PF_INET6))\n\t\tfamily = PF_INET6;\n\n\terr = inet_ctl_sock_create(&net->sctp.ctl_sock, family,\n\t\t\t\t   SOCK_SEQPACKET, IPPROTO_SCTP, net);\n\n\t \n\tif (err < 0 && family == PF_INET6)\n\t\terr = inet_ctl_sock_create(&net->sctp.ctl_sock, AF_INET,\n\t\t\t\t\t   SOCK_SEQPACKET, IPPROTO_SCTP,\n\t\t\t\t\t   net);\n\n\tif (err < 0) {\n\t\tpr_err(\"Failed to create the SCTP control socket\\n\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int sctp_udp_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tSCTP_INPUT_CB(skb)->encap_port = udp_hdr(skb)->source;\n\n\tskb_set_transport_header(skb, sizeof(struct udphdr));\n\tsctp_rcv(skb);\n\treturn 0;\n}\n\nint sctp_udp_sock_start(struct net *net)\n{\n\tstruct udp_tunnel_sock_cfg tuncfg = {NULL};\n\tstruct udp_port_cfg udp_conf = {0};\n\tstruct socket *sock;\n\tint err;\n\n\tudp_conf.family = AF_INET;\n\tudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\n\tudp_conf.local_udp_port = htons(net->sctp.udp_port);\n\terr = udp_sock_create(net, &udp_conf, &sock);\n\tif (err) {\n\t\tpr_err(\"Failed to create the SCTP UDP tunneling v4 sock\\n\");\n\t\treturn err;\n\t}\n\n\ttuncfg.encap_type = 1;\n\ttuncfg.encap_rcv = sctp_udp_rcv;\n\ttuncfg.encap_err_lookup = sctp_udp_v4_err;\n\tsetup_udp_tunnel_sock(net, sock, &tuncfg);\n\tnet->sctp.udp4_sock = sock->sk;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tmemset(&udp_conf, 0, sizeof(udp_conf));\n\n\tudp_conf.family = AF_INET6;\n\tudp_conf.local_ip6 = in6addr_any;\n\tudp_conf.local_udp_port = htons(net->sctp.udp_port);\n\tudp_conf.use_udp6_rx_checksums = true;\n\tudp_conf.ipv6_v6only = true;\n\terr = udp_sock_create(net, &udp_conf, &sock);\n\tif (err) {\n\t\tpr_err(\"Failed to create the SCTP UDP tunneling v6 sock\\n\");\n\t\tudp_tunnel_sock_release(net->sctp.udp4_sock->sk_socket);\n\t\tnet->sctp.udp4_sock = NULL;\n\t\treturn err;\n\t}\n\n\ttuncfg.encap_type = 1;\n\ttuncfg.encap_rcv = sctp_udp_rcv;\n\ttuncfg.encap_err_lookup = sctp_udp_v6_err;\n\tsetup_udp_tunnel_sock(net, sock, &tuncfg);\n\tnet->sctp.udp6_sock = sock->sk;\n#endif\n\n\treturn 0;\n}\n\nvoid sctp_udp_sock_stop(struct net *net)\n{\n\tif (net->sctp.udp4_sock) {\n\t\tudp_tunnel_sock_release(net->sctp.udp4_sock->sk_socket);\n\t\tnet->sctp.udp4_sock = NULL;\n\t}\n\tif (net->sctp.udp6_sock) {\n\t\tudp_tunnel_sock_release(net->sctp.udp6_sock->sk_socket);\n\t\tnet->sctp.udp6_sock = NULL;\n\t}\n}\n\n \nint sctp_register_af(struct sctp_af *af)\n{\n\tswitch (af->sa_family) {\n\tcase AF_INET:\n\t\tif (sctp_af_v4_specific)\n\t\t\treturn 0;\n\t\tsctp_af_v4_specific = af;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (sctp_af_v6_specific)\n\t\t\treturn 0;\n\t\tsctp_af_v6_specific = af;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tINIT_LIST_HEAD(&af->list);\n\tlist_add_tail(&af->list, &sctp_address_families);\n\treturn 1;\n}\n\n \nstruct sctp_af *sctp_get_af_specific(sa_family_t family)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\treturn sctp_af_v4_specific;\n\tcase AF_INET6:\n\t\treturn sctp_af_v6_specific;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \nstatic void sctp_inet_msgname(char *msgname, int *addr_len)\n{\n\tstruct sockaddr_in *sin;\n\n\tsin = (struct sockaddr_in *)msgname;\n\t*addr_len = sizeof(struct sockaddr_in);\n\tsin->sin_family = AF_INET;\n\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n}\n\n \nstatic void sctp_inet_event_msgname(struct sctp_ulpevent *event, char *msgname,\n\t\t\t\t    int *addr_len)\n{\n\tstruct sockaddr_in *sin, *sinfrom;\n\n\tif (msgname) {\n\t\tstruct sctp_association *asoc;\n\n\t\tasoc = event->asoc;\n\t\tsctp_inet_msgname(msgname, addr_len);\n\t\tsin = (struct sockaddr_in *)msgname;\n\t\tsinfrom = &asoc->peer.primary_addr.v4;\n\t\tsin->sin_port = htons(asoc->peer.port);\n\t\tsin->sin_addr.s_addr = sinfrom->sin_addr.s_addr;\n\t}\n}\n\n \nstatic void sctp_inet_skb_msgname(struct sk_buff *skb, char *msgname, int *len)\n{\n\tif (msgname) {\n\t\tstruct sctphdr *sh = sctp_hdr(skb);\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msgname;\n\n\t\tsctp_inet_msgname(msgname, len);\n\t\tsin->sin_port = sh->source;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t}\n}\n\n \nstatic int sctp_inet_af_supported(sa_family_t family, struct sctp_sock *sp)\n{\n\t \n\treturn AF_INET == family;\n}\n\n \nstatic int sctp_inet_cmp_addr(const union sctp_addr *addr1,\n\t\t\t      const union sctp_addr *addr2,\n\t\t\t      struct sctp_sock *opt)\n{\n\t \n\tif (addr1->sa.sa_family != addr2->sa.sa_family)\n\t\treturn 0;\n\tif (htonl(INADDR_ANY) == addr1->v4.sin_addr.s_addr ||\n\t    htonl(INADDR_ANY) == addr2->v4.sin_addr.s_addr)\n\t\treturn 1;\n\tif (addr1->v4.sin_addr.s_addr == addr2->v4.sin_addr.s_addr)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int sctp_inet_bind_verify(struct sctp_sock *opt, union sctp_addr *addr)\n{\n\treturn sctp_v4_available(addr, opt);\n}\n\n \nstatic int sctp_inet_send_verify(struct sctp_sock *opt, union sctp_addr *addr)\n{\n\treturn 1;\n}\n\n \nstatic int sctp_inet_supported_addrs(const struct sctp_sock *opt,\n\t\t\t\t     __be16 *types)\n{\n\ttypes[0] = SCTP_PARAM_IPV4_ADDRESS;\n\treturn 1;\n}\n\n \nstatic inline int sctp_v4_xmit(struct sk_buff *skb, struct sctp_transport *t)\n{\n\tstruct dst_entry *dst = dst_clone(t->dst);\n\tstruct flowi4 *fl4 = &t->fl.u.ip4;\n\tstruct sock *sk = skb->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__u8 dscp = inet->tos;\n\t__be16 df = 0;\n\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI4, dst:%pI4\\n\", __func__, skb,\n\t\t skb->len, &fl4->saddr, &fl4->daddr);\n\n\tif (t->dscp & SCTP_DSCP_SET_MASK)\n\t\tdscp = t->dscp & SCTP_DSCP_VAL_MASK;\n\n\tinet->pmtudisc = t->param_flags & SPP_PMTUD_ENABLE ? IP_PMTUDISC_DO\n\t\t\t\t\t\t\t   : IP_PMTUDISC_DONT;\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\n\tif (!t->encap_port || !sctp_sk(sk)->udp_port) {\n\t\tskb_dst_set(skb, dst);\n\t\treturn __ip_queue_xmit(sk, skb, &t->fl, dscp);\n\t}\n\n\tif (skb_is_gso(skb))\n\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_UDP_TUNNEL_CSUM;\n\n\tif (ip_dont_fragment(sk, dst) && !skb->ignore_df)\n\t\tdf = htons(IP_DF);\n\n\tskb->encapsulation = 1;\n\tskb_reset_inner_mac_header(skb);\n\tskb_reset_inner_transport_header(skb);\n\tskb_set_inner_ipproto(skb, IPPROTO_SCTP);\n\tudp_tunnel_xmit_skb((struct rtable *)dst, sk, skb, fl4->saddr,\n\t\t\t    fl4->daddr, dscp, ip4_dst_hoplimit(dst), df,\n\t\t\t    sctp_sk(sk)->udp_port, t->encap_port, false, false);\n\treturn 0;\n}\n\nstatic struct sctp_af sctp_af_inet;\n\nstatic struct sctp_pf sctp_pf_inet = {\n\t.event_msgname = sctp_inet_event_msgname,\n\t.skb_msgname   = sctp_inet_skb_msgname,\n\t.af_supported  = sctp_inet_af_supported,\n\t.cmp_addr      = sctp_inet_cmp_addr,\n\t.bind_verify   = sctp_inet_bind_verify,\n\t.send_verify   = sctp_inet_send_verify,\n\t.supported_addrs = sctp_inet_supported_addrs,\n\t.create_accept_sk = sctp_v4_create_accept_sk,\n\t.addr_to_user  = sctp_v4_addr_to_user,\n\t.to_sk_saddr   = sctp_v4_to_sk_saddr,\n\t.to_sk_daddr   = sctp_v4_to_sk_daddr,\n\t.copy_ip_options = sctp_v4_copy_ip_options,\n\t.af            = &sctp_af_inet\n};\n\n \nstatic struct notifier_block sctp_inetaddr_notifier = {\n\t.notifier_call = sctp_inetaddr_event,\n};\n\n \nstatic const struct proto_ops inet_seqpacket_ops = {\n\t.family\t\t   = PF_INET,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet_release,\t \n\t.bind\t\t   = inet_bind,\n\t.connect\t   = sctp_inet_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = inet_accept,\n\t.getname\t   = inet_getname,\t \n\t.poll\t\t   = sctp_poll,\n\t.ioctl\t\t   = inet_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = sctp_inet_listen,\n\t.shutdown\t   = inet_shutdown,\t \n\t.setsockopt\t   = sock_common_setsockopt,  \n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = inet_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n};\n\n \nstatic struct inet_protosw sctp_seqpacket_protosw = {\n\t.type       = SOCK_SEQPACKET,\n\t.protocol   = IPPROTO_SCTP,\n\t.prot       = &sctp_prot,\n\t.ops        = &inet_seqpacket_ops,\n\t.flags      = SCTP_PROTOSW_FLAG\n};\nstatic struct inet_protosw sctp_stream_protosw = {\n\t.type       = SOCK_STREAM,\n\t.protocol   = IPPROTO_SCTP,\n\t.prot       = &sctp_prot,\n\t.ops        = &inet_seqpacket_ops,\n\t.flags      = SCTP_PROTOSW_FLAG\n};\n\nstatic int sctp4_rcv(struct sk_buff *skb)\n{\n\tSCTP_INPUT_CB(skb)->encap_port = 0;\n\treturn sctp_rcv(skb);\n}\n\n \nstatic const struct net_protocol sctp_protocol = {\n\t.handler     = sctp4_rcv,\n\t.err_handler = sctp_v4_err,\n\t.no_policy   = 1,\n\t.icmp_strict_tag_validation = 1,\n};\n\n \nstatic struct sctp_af sctp_af_inet = {\n\t.sa_family\t   = AF_INET,\n\t.sctp_xmit\t   = sctp_v4_xmit,\n\t.setsockopt\t   = ip_setsockopt,\n\t.getsockopt\t   = ip_getsockopt,\n\t.get_dst\t   = sctp_v4_get_dst,\n\t.get_saddr\t   = sctp_v4_get_saddr,\n\t.copy_addrlist\t   = sctp_v4_copy_addrlist,\n\t.from_skb\t   = sctp_v4_from_skb,\n\t.from_sk\t   = sctp_v4_from_sk,\n\t.from_addr_param   = sctp_v4_from_addr_param,\n\t.to_addr_param\t   = sctp_v4_to_addr_param,\n\t.cmp_addr\t   = sctp_v4_cmp_addr,\n\t.addr_valid\t   = sctp_v4_addr_valid,\n\t.inaddr_any\t   = sctp_v4_inaddr_any,\n\t.is_any\t\t   = sctp_v4_is_any,\n\t.available\t   = sctp_v4_available,\n\t.scope\t\t   = sctp_v4_scope,\n\t.skb_iif\t   = sctp_v4_skb_iif,\n\t.skb_sdif\t   = sctp_v4_skb_sdif,\n\t.is_ce\t\t   = sctp_v4_is_ce,\n\t.seq_dump_addr\t   = sctp_v4_seq_dump_addr,\n\t.ecn_capable\t   = sctp_v4_ecn_capable,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in),\n\t.ip_options_len\t   = sctp_v4_ip_options_len,\n};\n\nstruct sctp_pf *sctp_get_pf_specific(sa_family_t family)\n{\n\tswitch (family) {\n\tcase PF_INET:\n\t\treturn sctp_pf_inet_specific;\n\tcase PF_INET6:\n\t\treturn sctp_pf_inet6_specific;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \nint sctp_register_pf(struct sctp_pf *pf, sa_family_t family)\n{\n\tswitch (family) {\n\tcase PF_INET:\n\t\tif (sctp_pf_inet_specific)\n\t\t\treturn 0;\n\t\tsctp_pf_inet_specific = pf;\n\t\tbreak;\n\tcase PF_INET6:\n\t\tif (sctp_pf_inet6_specific)\n\t\t\treturn 0;\n\t\tsctp_pf_inet6_specific = pf;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic inline int init_sctp_mibs(struct net *net)\n{\n\tnet->sctp.sctp_statistics = alloc_percpu(struct sctp_mib);\n\tif (!net->sctp.sctp_statistics)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic inline void cleanup_sctp_mibs(struct net *net)\n{\n\tfree_percpu(net->sctp.sctp_statistics);\n}\n\nstatic void sctp_v4_pf_init(void)\n{\n\t \n\tsctp_register_pf(&sctp_pf_inet, PF_INET);\n\tsctp_register_af(&sctp_af_inet);\n}\n\nstatic void sctp_v4_pf_exit(void)\n{\n\tlist_del(&sctp_af_inet.list);\n}\n\nstatic int sctp_v4_protosw_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&sctp_prot, 1);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tinet_register_protosw(&sctp_seqpacket_protosw);\n\tinet_register_protosw(&sctp_stream_protosw);\n\n\treturn 0;\n}\n\nstatic void sctp_v4_protosw_exit(void)\n{\n\tinet_unregister_protosw(&sctp_stream_protosw);\n\tinet_unregister_protosw(&sctp_seqpacket_protosw);\n\tproto_unregister(&sctp_prot);\n}\n\nstatic int sctp_v4_add_protocol(void)\n{\n\t \n\tregister_inetaddr_notifier(&sctp_inetaddr_notifier);\n\n\t \n\tif (inet_add_protocol(&sctp_protocol, IPPROTO_SCTP) < 0)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic void sctp_v4_del_protocol(void)\n{\n\tinet_del_protocol(&sctp_protocol, IPPROTO_SCTP);\n\tunregister_inetaddr_notifier(&sctp_inetaddr_notifier);\n}\n\nstatic int __net_init sctp_defaults_init(struct net *net)\n{\n\tint status;\n\n\t \n\t \n\t \n\tnet->sctp.rto_initial\t\t\t= SCTP_RTO_INITIAL;\n\t \n\tnet->sctp.rto_min\t \t\t= SCTP_RTO_MIN;\n\t \n\tnet->sctp.rto_max \t\t\t= SCTP_RTO_MAX;\n\t \n\tnet->sctp.rto_alpha\t\t\t= SCTP_RTO_ALPHA;\n\t \n\tnet->sctp.rto_beta\t\t\t= SCTP_RTO_BETA;\n\n\t \n\tnet->sctp.valid_cookie_life\t\t= SCTP_DEFAULT_COOKIE_LIFE;\n\n\t \n\tnet->sctp.cookie_preserve_enable \t= 1;\n\n\t \n#if defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5)\n\tnet->sctp.sctp_hmac_alg\t\t\t= \"md5\";\n#elif defined (CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1)\n\tnet->sctp.sctp_hmac_alg\t\t\t= \"sha1\";\n#else\n\tnet->sctp.sctp_hmac_alg\t\t\t= NULL;\n#endif\n\n\t \n\tnet->sctp.max_burst\t\t\t= SCTP_DEFAULT_MAX_BURST;\n\n\t \n\tnet->sctp.ps_retrans = SCTP_PS_RETRANS_MAX;\n\n\t \n\tnet->sctp.pf_enable = 1;\n\n\t \n\tnet->sctp.pf_expose = SCTP_PF_EXPOSE_UNSET;\n\n\t \n\tnet->sctp.max_retrans_association\t= 10;\n\tnet->sctp.max_retrans_path\t\t= 5;\n\tnet->sctp.max_retrans_init\t\t= 8;\n\n\t \n\tnet->sctp.sndbuf_policy\t\t\t= 0;\n\n\t \n\tnet->sctp.rcvbuf_policy\t\t\t= 0;\n\n\t \n\tnet->sctp.hb_interval\t\t\t= SCTP_DEFAULT_TIMEOUT_HEARTBEAT;\n\n\t \n\tnet->sctp.sack_timeout\t\t\t= SCTP_DEFAULT_TIMEOUT_SACK;\n\n\t \n\tnet->sctp.addip_enable = 0;\n\tnet->sctp.addip_noauth = 0;\n\tnet->sctp.default_auto_asconf = 0;\n\n\t \n\tnet->sctp.prsctp_enable = 1;\n\n\t \n\tnet->sctp.reconf_enable = 0;\n\n\t \n\tnet->sctp.auth_enable = 0;\n\n\t \n\tnet->sctp.ecn_enable = 1;\n\n\t \n\tnet->sctp.udp_port = 0;\n\n\t \n\tnet->sctp.encap_port = 0;\n\n\t \n\tnet->sctp.scope_policy = SCTP_SCOPE_POLICY_ENABLE;\n\n\t \n\tnet->sctp.rwnd_upd_shift = SCTP_DEFAULT_RWND_SHIFT;\n\n\t \n\tnet->sctp.max_autoclose\t\t= INT_MAX / HZ;\n\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\tnet->sctp.l3mdev_accept = 1;\n#endif\n\n\tstatus = sctp_sysctl_net_register(net);\n\tif (status)\n\t\tgoto err_sysctl_register;\n\n\t \n\tstatus = init_sctp_mibs(net);\n\tif (status)\n\t\tgoto err_init_mibs;\n\n#ifdef CONFIG_PROC_FS\n\t \n\tstatus = sctp_proc_init(net);\n\tif (status)\n\t\tgoto err_init_proc;\n#endif\n\n\tsctp_dbg_objcnt_init(net);\n\n\t \n\tINIT_LIST_HEAD(&net->sctp.local_addr_list);\n\tspin_lock_init(&net->sctp.local_addr_lock);\n\tsctp_get_local_addr_list(net);\n\n\t \n\tINIT_LIST_HEAD(&net->sctp.addr_waitq);\n\tINIT_LIST_HEAD(&net->sctp.auto_asconf_splist);\n\tspin_lock_init(&net->sctp.addr_wq_lock);\n\tnet->sctp.addr_wq_timer.expires = 0;\n\ttimer_setup(&net->sctp.addr_wq_timer, sctp_addr_wq_timeout_handler, 0);\n\n\treturn 0;\n\n#ifdef CONFIG_PROC_FS\nerr_init_proc:\n\tcleanup_sctp_mibs(net);\n#endif\nerr_init_mibs:\n\tsctp_sysctl_net_unregister(net);\nerr_sysctl_register:\n\treturn status;\n}\n\nstatic void __net_exit sctp_defaults_exit(struct net *net)\n{\n\t \n\tsctp_free_addr_wq(net);\n\tsctp_free_local_addr_list(net);\n\n#ifdef CONFIG_PROC_FS\n\tremove_proc_subtree(\"sctp\", net->proc_net);\n\tnet->sctp.proc_net_sctp = NULL;\n#endif\n\tcleanup_sctp_mibs(net);\n\tsctp_sysctl_net_unregister(net);\n}\n\nstatic struct pernet_operations sctp_defaults_ops = {\n\t.init = sctp_defaults_init,\n\t.exit = sctp_defaults_exit,\n};\n\nstatic int __net_init sctp_ctrlsock_init(struct net *net)\n{\n\tint status;\n\n\t \n\tstatus = sctp_ctl_sock_init(net);\n\tif (status)\n\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");\n\n\treturn status;\n}\n\nstatic void __net_exit sctp_ctrlsock_exit(struct net *net)\n{\n\t \n\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n}\n\nstatic struct pernet_operations sctp_ctrlsock_ops = {\n\t.init = sctp_ctrlsock_init,\n\t.exit = sctp_ctrlsock_exit,\n};\n\n \nstatic __init int sctp_init(void)\n{\n\tunsigned long nr_pages = totalram_pages();\n\tunsigned long limit;\n\tunsigned long goal;\n\tint max_entry_order;\n\tint num_entries;\n\tint max_share;\n\tint status;\n\tint order;\n\tint i;\n\n\tsock_skb_cb_check_size(sizeof(struct sctp_ulpevent));\n\n\t \n\tstatus = -ENOBUFS;\n\tsctp_bucket_cachep = kmem_cache_create(\"sctp_bind_bucket\",\n\t\t\t\t\t       sizeof(struct sctp_bind_bucket),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_bucket_cachep)\n\t\tgoto out;\n\n\tsctp_chunk_cachep = kmem_cache_create(\"sctp_chunk\",\n\t\t\t\t\t       sizeof(struct sctp_chunk),\n\t\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t       NULL);\n\tif (!sctp_chunk_cachep)\n\t\tgoto err_chunk_cachep;\n\n\tstatus = percpu_counter_init(&sctp_sockets_allocated, 0, GFP_KERNEL);\n\tif (status)\n\t\tgoto err_percpu_counter_init;\n\n\t \n\n\t \n\tsctp_max_instreams    \t\t= SCTP_DEFAULT_INSTREAMS;\n\tsctp_max_outstreams   \t\t= SCTP_DEFAULT_OUTSTREAMS;\n\n\t \n\tidr_init(&sctp_assocs_id);\n\n\tlimit = nr_free_buffer_pages() / 8;\n\tlimit = max(limit, 128UL);\n\tsysctl_sctp_mem[0] = limit / 4 * 3;\n\tsysctl_sctp_mem[1] = limit;\n\tsysctl_sctp_mem[2] = sysctl_sctp_mem[0] * 2;\n\n\t \n\tlimit = (sysctl_sctp_mem[1]) << (PAGE_SHIFT - 7);\n\tmax_share = min(4UL*1024*1024, limit);\n\n\tsysctl_sctp_rmem[0] = PAGE_SIZE;  \n\tsysctl_sctp_rmem[1] = 1500 * SKB_TRUESIZE(1);\n\tsysctl_sctp_rmem[2] = max(sysctl_sctp_rmem[1], max_share);\n\n\tsysctl_sctp_wmem[0] = PAGE_SIZE;\n\tsysctl_sctp_wmem[1] = 16*1024;\n\tsysctl_sctp_wmem[2] = max(64*1024, max_share);\n\n\t \n\tif (nr_pages >= (128 * 1024))\n\t\tgoal = nr_pages >> (22 - PAGE_SHIFT);\n\telse\n\t\tgoal = nr_pages >> (24 - PAGE_SHIFT);\n\n\t \n\torder = get_order(goal);\n\n\t \n\tmax_entry_order = get_order(MAX_SCTP_PORT_HASH_ENTRIES *\n\t\t\t\t    sizeof(struct sctp_bind_hashbucket));\n\n\t \n\torder = min(order, max_entry_order);\n\n\t \n\tsctp_ep_hashsize = 64;\n\tsctp_ep_hashtable =\n\t\tkmalloc_array(64, sizeof(struct sctp_hashbucket), GFP_KERNEL);\n\tif (!sctp_ep_hashtable) {\n\t\tpr_err(\"Failed endpoint_hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_ehash_alloc;\n\t}\n\tfor (i = 0; i < sctp_ep_hashsize; i++) {\n\t\trwlock_init(&sctp_ep_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_ep_hashtable[i].chain);\n\t}\n\n\t \n\tdo {\n\t\tsctp_port_hashtable = (struct sctp_bind_hashbucket *)\n\t\t\t__get_free_pages(GFP_KERNEL | __GFP_NOWARN, order);\n\t} while (!sctp_port_hashtable && --order > 0);\n\n\tif (!sctp_port_hashtable) {\n\t\tpr_err(\"Failed bind hash alloc\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto err_bhash_alloc;\n\t}\n\n\t \n\tnum_entries = (1UL << order) * PAGE_SIZE /\n\t\t      sizeof(struct sctp_bind_hashbucket);\n\n\t \n\tsctp_port_hashsize = rounddown_pow_of_two(num_entries);\n\n\tfor (i = 0; i < sctp_port_hashsize; i++) {\n\t\tspin_lock_init(&sctp_port_hashtable[i].lock);\n\t\tINIT_HLIST_HEAD(&sctp_port_hashtable[i].chain);\n\t}\n\n\tstatus = sctp_transport_hashtable_init();\n\tif (status)\n\t\tgoto err_thash_alloc;\n\n\tpr_info(\"Hash tables configured (bind %d/%d)\\n\", sctp_port_hashsize,\n\t\tnum_entries);\n\n\tsctp_sysctl_register();\n\n\tINIT_LIST_HEAD(&sctp_address_families);\n\tsctp_v4_pf_init();\n\tsctp_v6_pf_init();\n\tsctp_sched_ops_init();\n\n\tstatus = register_pernet_subsys(&sctp_defaults_ops);\n\tif (status)\n\t\tgoto err_register_defaults;\n\n\tstatus = sctp_v4_protosw_init();\n\tif (status)\n\t\tgoto err_protosw_init;\n\n\tstatus = sctp_v6_protosw_init();\n\tif (status)\n\t\tgoto err_v6_protosw_init;\n\n\tstatus = register_pernet_subsys(&sctp_ctrlsock_ops);\n\tif (status)\n\t\tgoto err_register_ctrlsock;\n\n\tstatus = sctp_v4_add_protocol();\n\tif (status)\n\t\tgoto err_add_protocol;\n\n\t \n\tstatus = sctp_v6_add_protocol();\n\tif (status)\n\t\tgoto err_v6_add_protocol;\n\n\tif (sctp_offload_init() < 0)\n\t\tpr_crit(\"%s: Cannot add SCTP protocol offload\\n\", __func__);\n\nout:\n\treturn status;\nerr_v6_add_protocol:\n\tsctp_v4_del_protocol();\nerr_add_protocol:\n\tunregister_pernet_subsys(&sctp_ctrlsock_ops);\nerr_register_ctrlsock:\n\tsctp_v6_protosw_exit();\nerr_v6_protosw_init:\n\tsctp_v4_protosw_exit();\nerr_protosw_init:\n\tunregister_pernet_subsys(&sctp_defaults_ops);\nerr_register_defaults:\n\tsctp_v4_pf_exit();\n\tsctp_v6_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\nerr_bhash_alloc:\n\tsctp_transport_hashtable_destroy();\nerr_thash_alloc:\n\tkfree(sctp_ep_hashtable);\nerr_ehash_alloc:\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\nerr_percpu_counter_init:\n\tkmem_cache_destroy(sctp_chunk_cachep);\nerr_chunk_cachep:\n\tkmem_cache_destroy(sctp_bucket_cachep);\n\tgoto out;\n}\n\n \nstatic __exit void sctp_exit(void)\n{\n\t \n\n\t \n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\n\tunregister_pernet_subsys(&sctp_ctrlsock_ops);\n\n\t \n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\n\tunregister_pernet_subsys(&sctp_defaults_ops);\n\n\t \n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\n\tsctp_sysctl_unregister();\n\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tsctp_transport_hashtable_destroy();\n\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\n\trcu_barrier();  \n\n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}\n\nmodule_init(sctp_init);\nmodule_exit(sctp_exit);\n\n \nMODULE_ALIAS(\"net-pf-\" __stringify(PF_INET) \"-proto-132\");\nMODULE_ALIAS(\"net-pf-\" __stringify(PF_INET6) \"-proto-132\");\nMODULE_AUTHOR(\"Linux Kernel SCTP developers <linux-sctp@vger.kernel.org>\");\nMODULE_DESCRIPTION(\"Support for the SCTP protocol (RFC2960)\");\nmodule_param_named(no_checksums, sctp_checksum_disable, bool, 0644);\nMODULE_PARM_DESC(no_checksums, \"Disable checksums computing and verification\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}