{
  "module_name": "sm_make_chunk.c",
  "hash_id": "b52586eb200ea72d996c2307773569598beb0e92c843d62aaed66c8252c2df26",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/sm_make_chunk.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <crypto/hash.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n\n#include <linux/skbuff.h>\n#include <linux/random.h>\t \n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\nstatic struct sctp_chunk *sctp_make_control(const struct sctp_association *asoc,\n\t\t\t\t\t    __u8 type, __u8 flags, int paylen,\n\t\t\t\t\t    gfp_t gfp);\nstatic struct sctp_chunk *sctp_make_data(const struct sctp_association *asoc,\n\t\t\t\t\t __u8 flags, int paylen, gfp_t gfp);\nstatic struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,\n\t\t\t\t\t   __u8 type, __u8 flags, int paylen,\n\t\t\t\t\t   gfp_t gfp);\nstatic struct sctp_cookie_param *sctp_pack_cookie(\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *init_chunk,\n\t\t\t\t\tint *cookie_len,\n\t\t\t\t\tconst __u8 *raw_addrs, int addrs_len);\nstatic int sctp_process_param(struct sctp_association *asoc,\n\t\t\t      union sctp_params param,\n\t\t\t      const union sctp_addr *peer_addr,\n\t\t\t      gfp_t gfp);\nstatic void *sctp_addto_param(struct sctp_chunk *chunk, int len,\n\t\t\t      const void *data);\n\n \nstatic void sctp_control_release_owner(struct sk_buff *skb)\n{\n\tstruct sctp_chunk *chunk = skb_shinfo(skb)->destructor_arg;\n\n\tif (chunk->shkey) {\n\t\tstruct sctp_shared_key *shkey = chunk->shkey;\n\t\tstruct sctp_association *asoc = chunk->asoc;\n\n\t\t \n\t\tif (shkey->deactivated && !list_empty(&shkey->key_list) &&\n\t\t    refcount_read(&shkey->refcnt) == 2) {\n\t\t\tstruct sctp_ulpevent *ev;\n\n\t\t\tev = sctp_ulpevent_make_authkey(asoc, shkey->key_id,\n\t\t\t\t\t\t\tSCTP_AUTH_FREE_KEY,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (ev)\n\t\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, ev);\n\t\t}\n\t\tsctp_auth_shkey_release(chunk->shkey);\n\t}\n}\n\nstatic void sctp_control_set_owner_w(struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sk_buff *skb = chunk->skb;\n\n\t \n\tif (chunk->auth) {\n\t\tchunk->shkey = asoc->shkey;\n\t\tsctp_auth_shkey_hold(chunk->shkey);\n\t}\n\tskb->sk = asoc ? asoc->base.sk : NULL;\n\tskb_shinfo(skb)->destructor_arg = chunk;\n\tskb->destructor = sctp_control_release_owner;\n}\n\n \nint sctp_chunk_iif(const struct sctp_chunk *chunk)\n{\n\tstruct sk_buff *skb = chunk->skb;\n\n\treturn SCTP_INPUT_CB(skb)->af->skb_iif(skb);\n}\n\n \nstatic const struct sctp_paramhdr ecap_param = {\n\tSCTP_PARAM_ECN_CAPABLE,\n\tcpu_to_be16(sizeof(struct sctp_paramhdr)),\n};\nstatic const struct sctp_paramhdr prsctp_param = {\n\tSCTP_PARAM_FWD_TSN_SUPPORT,\n\tcpu_to_be16(sizeof(struct sctp_paramhdr)),\n};\n\n \nint sctp_init_cause(struct sctp_chunk *chunk, __be16 cause_code,\n\t\t    size_t paylen)\n{\n\tstruct sctp_errhdr err;\n\t__u16 len;\n\n\t \n\terr.cause = cause_code;\n\tlen = sizeof(err) + paylen;\n\terr.length = htons(len);\n\n\tif (skb_tailroom(chunk->skb) < len)\n\t\treturn -ENOSPC;\n\n\tchunk->subh.err_hdr = sctp_addto_chunk(chunk, sizeof(err), &err);\n\n\treturn 0;\n}\n\n \nstruct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,\n\t\t\t\t  const struct sctp_bind_addr *bp,\n\t\t\t\t  gfp_t gfp, int vparam_len)\n{\n\tstruct sctp_supported_ext_param ext_param;\n\tstruct sctp_adaptation_ind_param aiparam;\n\tstruct sctp_paramhdr *auth_chunks = NULL;\n\tstruct sctp_paramhdr *auth_hmacs = NULL;\n\tstruct sctp_supported_addrs_param sat;\n\tstruct sctp_endpoint *ep = asoc->ep;\n\tstruct sctp_chunk *retval = NULL;\n\tint num_types, addrs_len = 0;\n\tstruct sctp_inithdr init;\n\tunion sctp_params addrs;\n\tstruct sctp_sock *sp;\n\t__u8 extensions[5];\n\tsize_t chunksize;\n\t__be16 types[2];\n\tint num_ext = 0;\n\n\t \n\n\t \n\taddrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);\n\n\tinit.init_tag\t\t   = htonl(asoc->c.my_vtag);\n\tinit.a_rwnd\t\t   = htonl(asoc->rwnd);\n\tinit.num_outbound_streams  = htons(asoc->c.sinit_num_ostreams);\n\tinit.num_inbound_streams   = htons(asoc->c.sinit_max_instreams);\n\tinit.initial_tsn\t   = htonl(asoc->c.initial_tsn);\n\n\t \n\tsp = sctp_sk(asoc->base.sk);\n\tnum_types = sp->pf->supported_addrs(sp, types);\n\n\tchunksize = sizeof(init) + addrs_len;\n\tchunksize += SCTP_PAD4(SCTP_SAT_LEN(num_types));\n\n\tif (asoc->ep->ecn_enable)\n\t\tchunksize += sizeof(ecap_param);\n\n\tif (asoc->ep->prsctp_enable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\t \n\tif (asoc->ep->asconf_enable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (asoc->ep->reconf_enable) {\n\t\textensions[num_ext] = SCTP_CID_RECONF;\n\t\tnum_ext += 1;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tif (asoc->ep->intl_enable) {\n\t\textensions[num_ext] = SCTP_CID_I_DATA;\n\t\tnum_ext += 1;\n\t}\n\n\tchunksize += vparam_len;\n\n\t \n\tif (ep->auth_enable) {\n\t\t \n\t\tchunksize += sizeof(asoc->c.auth_random);\n\n\t\t \n\t\tauth_hmacs = (struct sctp_paramhdr *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += SCTP_PAD4(ntohs(auth_hmacs->length));\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\t \n\t\tauth_chunks = (struct sctp_paramhdr *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += SCTP_PAD4(ntohs(auth_chunks->length));\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\t \n\tif (num_ext)\n\t\tchunksize += SCTP_PAD4(sizeof(ext_param) + num_ext);\n\n\t \n\n\tretval = sctp_make_control(asoc, SCTP_CID_INIT, 0, chunksize, gfp);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(init), &init);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrs_len, addrs.v);\n\n\t \n\tsat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;\n\tsat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));\n\tsctp_addto_chunk(retval, sizeof(sat), &sat);\n\tsctp_addto_chunk(retval, num_types * sizeof(__u16), &types);\n\n\tif (asoc->ep->ecn_enable)\n\t\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\n\t \n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length = htons(sizeof(ext_param) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(ext_param), &ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\n\tif (asoc->ep->prsctp_enable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\t \n\tif (ep->auth_enable) {\n\t\tsctp_addto_chunk(retval, sizeof(asoc->c.auth_random),\n\t\t\t\t asoc->c.auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\nnodata:\n\tkfree(addrs.v);\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_init_ack(const struct sctp_association *asoc,\n\t\t\t\t      const struct sctp_chunk *chunk,\n\t\t\t\t      gfp_t gfp, int unkparam_len)\n{\n\tstruct sctp_supported_ext_param ext_param;\n\tstruct sctp_adaptation_ind_param aiparam;\n\tstruct sctp_paramhdr *auth_chunks = NULL;\n\tstruct sctp_paramhdr *auth_random = NULL;\n\tstruct sctp_paramhdr *auth_hmacs = NULL;\n\tstruct sctp_chunk *retval = NULL;\n\tstruct sctp_cookie_param *cookie;\n\tstruct sctp_inithdr initack;\n\tunion sctp_params addrs;\n\tstruct sctp_sock *sp;\n\t__u8 extensions[5];\n\tsize_t chunksize;\n\tint num_ext = 0;\n\tint cookie_len;\n\tint addrs_len;\n\n\t \n\taddrs = sctp_bind_addrs_to_raw(&asoc->base.bind_addr, &addrs_len, gfp);\n\n\tinitack.init_tag\t        = htonl(asoc->c.my_vtag);\n\tinitack.a_rwnd\t\t\t= htonl(asoc->rwnd);\n\tinitack.num_outbound_streams\t= htons(asoc->c.sinit_num_ostreams);\n\tinitack.num_inbound_streams\t= htons(asoc->c.sinit_max_instreams);\n\tinitack.initial_tsn\t\t= htonl(asoc->c.initial_tsn);\n\n\t \n\tcookie = sctp_pack_cookie(asoc->ep, asoc, chunk, &cookie_len,\n\t\t\t\t  addrs.v, addrs_len);\n\tif (!cookie)\n\t\tgoto nomem_cookie;\n\n\t \n\tsp = sctp_sk(asoc->base.sk);\n\tchunksize = sizeof(initack) + addrs_len + cookie_len + unkparam_len;\n\n\t \n\tif (asoc->peer.ecn_capable)\n\t\tchunksize += sizeof(ecap_param);\n\n\tif (asoc->peer.prsctp_capable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\tif (asoc->peer.asconf_capable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (asoc->peer.reconf_capable) {\n\t\textensions[num_ext] = SCTP_CID_RECONF;\n\t\tnum_ext += 1;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tif (asoc->peer.intl_capable) {\n\t\textensions[num_ext] = SCTP_CID_I_DATA;\n\t\tnum_ext += 1;\n\t}\n\n\tif (asoc->peer.auth_capable) {\n\t\tauth_random = (struct sctp_paramhdr *)asoc->c.auth_random;\n\t\tchunksize += ntohs(auth_random->length);\n\n\t\tauth_hmacs = (struct sctp_paramhdr *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += SCTP_PAD4(ntohs(auth_hmacs->length));\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\tauth_chunks = (struct sctp_paramhdr *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += SCTP_PAD4(ntohs(auth_chunks->length));\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\tif (num_ext)\n\t\tchunksize += SCTP_PAD4(sizeof(ext_param) + num_ext);\n\n\t \n\tretval = sctp_make_control(asoc, SCTP_CID_INIT_ACK, 0, chunksize, gfp);\n\tif (!retval)\n\t\tgoto nomem_chunk;\n\n\t \n\tif (chunk->transport)\n\t\tretval->transport =\n\t\t\tsctp_assoc_lookup_paddr(asoc,\n\t\t\t\t\t\t&chunk->transport->ipaddr);\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(initack), &initack);\n\tretval->param_hdr.v = sctp_addto_chunk(retval, addrs_len, addrs.v);\n\tsctp_addto_chunk(retval, cookie_len, cookie);\n\tif (asoc->peer.ecn_capable)\n\t\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length = htons(sizeof(ext_param) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(ext_param), &ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\tif (asoc->peer.prsctp_capable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\tif (asoc->peer.auth_capable) {\n\t\tsctp_addto_chunk(retval, ntohs(auth_random->length),\n\t\t\t\t auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\n\n\t \n\tretval->asoc = (struct sctp_association *) asoc;\n\nnomem_chunk:\n\tkfree(cookie);\nnomem_cookie:\n\tkfree(addrs.v);\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_cookie_echo(const struct sctp_association *asoc,\n\t\t\t\t\t const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tint cookie_len;\n\tvoid *cookie;\n\n\tcookie = asoc->peer.cookie;\n\tcookie_len = asoc->peer.cookie_len;\n\n\t \n\tretval = sctp_make_control(asoc, SCTP_CID_COOKIE_ECHO, 0,\n\t\t\t\t   cookie_len, GFP_ATOMIC);\n\tif (!retval)\n\t\tgoto nodata;\n\tretval->subh.cookie_hdr =\n\t\tsctp_addto_chunk(retval, cookie_len, cookie);\n\n\t \n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_cookie_ack(const struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_COOKIE_ACK, 0, 0, GFP_ATOMIC);\n\n\t \n\tif (retval && chunk && chunk->transport)\n\t\tretval->transport =\n\t\t\tsctp_assoc_lookup_paddr(asoc,\n\t\t\t\t\t\t&chunk->transport->ipaddr);\n\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_cwr(const struct sctp_association *asoc,\n\t\t\t\t const __u32 lowest_tsn,\n\t\t\t\t const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tstruct sctp_cwrhdr cwr;\n\n\tcwr.lowest_tsn = htonl(lowest_tsn);\n\tretval = sctp_make_control(asoc, SCTP_CID_ECN_CWR, 0,\n\t\t\t\t   sizeof(cwr), GFP_ATOMIC);\n\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.ecn_cwr_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(cwr), &cwr);\n\n\t \n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_ecne(const struct sctp_association *asoc,\n\t\t\t\t  const __u32 lowest_tsn)\n{\n\tstruct sctp_chunk *retval;\n\tstruct sctp_ecnehdr ecne;\n\n\tecne.lowest_tsn = htonl(lowest_tsn);\n\tretval = sctp_make_control(asoc, SCTP_CID_ECN_ECNE, 0,\n\t\t\t\t   sizeof(ecne), GFP_ATOMIC);\n\tif (!retval)\n\t\tgoto nodata;\n\tretval->subh.ecne_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(ecne), &ecne);\n\nnodata:\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_datafrag_empty(const struct sctp_association *asoc,\n\t\t\t\t\t    const struct sctp_sndrcvinfo *sinfo,\n\t\t\t\t\t    int len, __u8 flags, gfp_t gfp)\n{\n\tstruct sctp_chunk *retval;\n\tstruct sctp_datahdr dp;\n\n\t \n\tmemset(&dp, 0, sizeof(dp));\n\tdp.ppid = sinfo->sinfo_ppid;\n\tdp.stream = htons(sinfo->sinfo_stream);\n\n\t \n\tif (sinfo->sinfo_flags & SCTP_UNORDERED)\n\t\tflags |= SCTP_DATA_UNORDERED;\n\n\tretval = sctp_make_data(asoc, flags, sizeof(dp) + len, gfp);\n\tif (!retval)\n\t\treturn NULL;\n\n\tretval->subh.data_hdr = sctp_addto_chunk(retval, sizeof(dp), &dp);\n\tmemcpy(&retval->sinfo, sinfo, sizeof(struct sctp_sndrcvinfo));\n\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_sack(struct sctp_association *asoc)\n{\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sctp_gap_ack_block gabs[SCTP_MAX_GABS];\n\t__u16 num_gabs, num_dup_tsns;\n\tstruct sctp_transport *trans;\n\tstruct sctp_chunk *retval;\n\tstruct sctp_sackhdr sack;\n\t__u32 ctsn;\n\tint len;\n\n\tmemset(gabs, 0, sizeof(gabs));\n\tctsn = sctp_tsnmap_get_ctsn(map);\n\n\tpr_debug(\"%s: sackCTSNAck sent:0x%x\\n\", __func__, ctsn);\n\n\t \n\tnum_gabs = sctp_tsnmap_num_gabs(map, gabs);\n\tnum_dup_tsns = sctp_tsnmap_num_dups(map);\n\n\t \n\tsack.cum_tsn_ack\t    = htonl(ctsn);\n\tsack.a_rwnd \t\t    = htonl(asoc->a_rwnd);\n\tsack.num_gap_ack_blocks     = htons(num_gabs);\n\tsack.num_dup_tsns           = htons(num_dup_tsns);\n\n\tlen = sizeof(sack)\n\t\t+ sizeof(struct sctp_gap_ack_block) * num_gabs\n\t\t+ sizeof(__u32) * num_dup_tsns;\n\n\t \n\tretval = sctp_make_control(asoc, SCTP_CID_SACK, 0, len, GFP_ATOMIC);\n\tif (!retval)\n\t\tgoto nodata;\n\n\t \n\tretval->transport = asoc->peer.last_data_from;\n\n\tretval->subh.sack_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(sack), &sack);\n\n\t \n\tif (num_gabs)\n\t\tsctp_addto_chunk(retval, sizeof(__u32) * num_gabs,\n\t\t\t\t gabs);\n\n\t \n\tif (num_dup_tsns) {\n\t\tasoc->stats.idupchunks += num_dup_tsns;\n\t\tsctp_addto_chunk(retval, sizeof(__u32) * num_dup_tsns,\n\t\t\t\t sctp_tsnmap_get_dups(map));\n\t}\n\t \n\tif (++asoc->peer.sack_generation == 0) {\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\t    transports)\n\t\t\ttrans->sack_generation = 0;\n\t\tasoc->peer.sack_generation = 1;\n\t}\nnodata:\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_shutdown(const struct sctp_association *asoc,\n\t\t\t\t      const struct sctp_chunk *chunk)\n{\n\tstruct sctp_shutdownhdr shut;\n\tstruct sctp_chunk *retval;\n\t__u32 ctsn;\n\n\tctsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map);\n\tshut.cum_tsn_ack = htonl(ctsn);\n\n\tretval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN, 0,\n\t\t\t\t   sizeof(shut), GFP_ATOMIC);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.shutdown_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(shut), &shut);\n\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,\n\t\t\t\t\t  const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0,\n\t\t\t\t   GFP_ATOMIC);\n\n\t \n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_shutdown_complete(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\t__u8 flags = 0;\n\n\t \n\tflags |= asoc ? 0 : SCTP_CHUNK_FLAG_T;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_COMPLETE, flags,\n\t\t\t\t   0, GFP_ATOMIC);\n\n\t \n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_abort(const struct sctp_association *asoc,\n\t\t\t\t   const struct sctp_chunk *chunk,\n\t\t\t\t   const size_t hint)\n{\n\tstruct sctp_chunk *retval;\n\t__u8 flags = 0;\n\n\t \n\tif (!asoc) {\n\t\tif (chunk && chunk->chunk_hdr &&\n\t\t    chunk->chunk_hdr->type == SCTP_CID_INIT)\n\t\t\tflags = 0;\n\t\telse\n\t\t\tflags = SCTP_CHUNK_FLAG_T;\n\t}\n\n\tretval = sctp_make_control(asoc, SCTP_CID_ABORT, flags, hint,\n\t\t\t\t   GFP_ATOMIC);\n\n\t \n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_abort_no_data(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk,\n\t\t\t\t\t__u32 tsn)\n{\n\tstruct sctp_chunk *retval;\n\t__be32 payload;\n\n\tretval = sctp_make_abort(asoc, chunk,\n\t\t\t\t sizeof(struct sctp_errhdr) + sizeof(tsn));\n\n\tif (!retval)\n\t\tgoto no_mem;\n\n\t \n\tpayload = htonl(tsn);\n\tsctp_init_cause(retval, SCTP_ERROR_NO_DATA, sizeof(payload));\n\tsctp_addto_chunk(retval, sizeof(payload), (const void *)&payload);\n\n\t \n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nno_mem:\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_abort_user(const struct sctp_association *asoc,\n\t\t\t\t\tstruct msghdr *msg,\n\t\t\t\t\tsize_t paylen)\n{\n\tstruct sctp_chunk *retval;\n\tvoid *payload = NULL;\n\tint err;\n\n\tretval = sctp_make_abort(asoc, NULL,\n\t\t\t\t sizeof(struct sctp_errhdr) + paylen);\n\tif (!retval)\n\t\tgoto err_chunk;\n\n\tif (paylen) {\n\t\t \n\t\tpayload = kmalloc(paylen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto err_payload;\n\n\t\terr = memcpy_from_msg(payload, msg, paylen);\n\t\tif (err < 0)\n\t\t\tgoto err_copy;\n\t}\n\n\tsctp_init_cause(retval, SCTP_ERROR_USER_ABORT, paylen);\n\tsctp_addto_chunk(retval, paylen, payload);\n\n\tif (paylen)\n\t\tkfree(payload);\n\n\treturn retval;\n\nerr_copy:\n\tkfree(payload);\nerr_payload:\n\tsctp_chunk_free(retval);\n\tretval = NULL;\nerr_chunk:\n\treturn retval;\n}\n\n \nstatic void *sctp_addto_param(struct sctp_chunk *chunk, int len,\n\t\t\t      const void *data)\n{\n\tint chunklen = ntohs(chunk->chunk_hdr->length);\n\tvoid *target;\n\n\ttarget = skb_put(chunk->skb, len);\n\n\tif (data)\n\t\tmemcpy(target, data, len);\n\telse\n\t\tmemset(target, 0, len);\n\n\t \n\tchunk->chunk_hdr->length = htons(chunklen + len);\n\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\n\treturn target;\n}\n\n \nstruct sctp_chunk *sctp_make_abort_violation(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk,\n\t\t\t\t\tconst __u8 *payload,\n\t\t\t\t\tconst size_t paylen)\n{\n\tstruct sctp_chunk  *retval;\n\tstruct sctp_paramhdr phdr;\n\n\tretval = sctp_make_abort(asoc, chunk, sizeof(struct sctp_errhdr) +\n\t\t\t\t\t      paylen + sizeof(phdr));\n\tif (!retval)\n\t\tgoto end;\n\n\tsctp_init_cause(retval, SCTP_ERROR_PROTO_VIOLATION, paylen +\n\t\t\t\t\t\t\t    sizeof(phdr));\n\n\tphdr.type = htons(chunk->chunk_hdr->type);\n\tphdr.length = chunk->chunk_hdr->length;\n\tsctp_addto_chunk(retval, paylen, payload);\n\tsctp_addto_param(retval, sizeof(phdr), &phdr);\n\nend:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_violation_paramlen(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_paramhdr *param)\n{\n\tstatic const char error[] = \"The following parameter had invalid length:\";\n\tsize_t payload_len = sizeof(error) + sizeof(struct sctp_errhdr) +\n\t\t\t     sizeof(*param);\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_abort(asoc, chunk, payload_len);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tsctp_init_cause(retval, SCTP_ERROR_PROTO_VIOLATION,\n\t\t\tsizeof(error) + sizeof(*param));\n\tsctp_addto_chunk(retval, sizeof(error), error);\n\tsctp_addto_param(retval, sizeof(*param), param);\n\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_violation_max_retrans(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk)\n{\n\tstatic const char error[] = \"Association exceeded its max_retrans count\";\n\tsize_t payload_len = sizeof(error) + sizeof(struct sctp_errhdr);\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_abort(asoc, chunk, payload_len);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tsctp_init_cause(retval, SCTP_ERROR_PROTO_VIOLATION, sizeof(error));\n\tsctp_addto_chunk(retval, sizeof(error), error);\n\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_new_encap_port(const struct sctp_association *asoc,\n\t\t\t\t\t    const struct sctp_chunk *chunk)\n{\n\tstruct sctp_new_encap_port_hdr nep;\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_abort(asoc, chunk,\n\t\t\t\t sizeof(struct sctp_errhdr) + sizeof(nep));\n\tif (!retval)\n\t\tgoto nodata;\n\n\tsctp_init_cause(retval, SCTP_ERROR_NEW_ENCAP_PORT, sizeof(nep));\n\tnep.cur_port = SCTP_INPUT_CB(chunk->skb)->encap_port;\n\tnep.new_port = chunk->transport->encap_port;\n\tsctp_addto_chunk(retval, sizeof(nep), &nep);\n\nnodata:\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_heartbeat(const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_transport *transport,\n\t\t\t\t       __u32 probe_size)\n{\n\tstruct sctp_sender_hb_info hbinfo = {};\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_HEARTBEAT, 0,\n\t\t\t\t   sizeof(hbinfo), GFP_ATOMIC);\n\n\tif (!retval)\n\t\tgoto nodata;\n\n\thbinfo.param_hdr.type = SCTP_PARAM_HEARTBEAT_INFO;\n\thbinfo.param_hdr.length = htons(sizeof(hbinfo));\n\thbinfo.daddr = transport->ipaddr;\n\thbinfo.sent_at = jiffies;\n\thbinfo.hb_nonce = transport->hb_nonce;\n\thbinfo.probe_size = probe_size;\n\n\t \n\tretval->transport = (struct sctp_transport *) transport;\n\tretval->subh.hbs_hdr = sctp_addto_chunk(retval, sizeof(hbinfo),\n\t\t\t\t\t\t&hbinfo);\n\tretval->pmtu_probe = !!probe_size;\n\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_heartbeat_ack(const struct sctp_association *asoc,\n\t\t\t\t\t   const struct sctp_chunk *chunk,\n\t\t\t\t\t   const void *payload,\n\t\t\t\t\t   const size_t paylen)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval  = sctp_make_control(asoc, SCTP_CID_HEARTBEAT_ACK, 0, paylen,\n\t\t\t\t    GFP_ATOMIC);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.hbs_hdr = sctp_addto_chunk(retval, paylen, payload);\n\n\t \n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_pad(const struct sctp_association *asoc, int len)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_PAD, 0, len, GFP_ATOMIC);\n\tif (!retval)\n\t\treturn NULL;\n\n\tskb_put_zero(retval->skb, len);\n\tretval->chunk_hdr->length = htons(ntohs(retval->chunk_hdr->length) + len);\n\tretval->chunk_end = skb_tail_pointer(retval->skb);\n\n\treturn retval;\n}\n\n \nstatic struct sctp_chunk *sctp_make_op_error_space(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk,\n\t\t\t\t\tsize_t size)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_ERROR, 0,\n\t\t\t\t   sizeof(struct sctp_errhdr) + size,\n\t\t\t\t   GFP_ATOMIC);\n\tif (!retval)\n\t\tgoto nodata;\n\n\t \n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n\n \nstatic inline struct sctp_chunk *sctp_make_op_error_limited(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk)\n{\n\tsize_t size = SCTP_DEFAULT_MAXSEGMENT;\n\tstruct sctp_sock *sp = NULL;\n\n\tif (asoc) {\n\t\tsize = min_t(size_t, size, asoc->pathmtu);\n\t\tsp = sctp_sk(asoc->base.sk);\n\t}\n\n\tsize = sctp_mtu_payload(sp, size, sizeof(struct sctp_errhdr));\n\n\treturn sctp_make_op_error_space(asoc, chunk, size);\n}\n\n \nstruct sctp_chunk *sctp_make_op_error(const struct sctp_association *asoc,\n\t\t\t\t      const struct sctp_chunk *chunk,\n\t\t\t\t      __be16 cause_code, const void *payload,\n\t\t\t\t      size_t paylen, size_t reserve_tail)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_op_error_space(asoc, chunk, paylen + reserve_tail);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tsctp_init_cause(retval, cause_code, paylen + reserve_tail);\n\tsctp_addto_chunk(retval, paylen, payload);\n\tif (reserve_tail)\n\t\tsctp_addto_param(retval, reserve_tail, NULL);\n\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_auth(const struct sctp_association *asoc,\n\t\t\t\t  __u16 key_id)\n{\n\tstruct sctp_authhdr auth_hdr;\n\tstruct sctp_hmac *hmac_desc;\n\tstruct sctp_chunk *retval;\n\n\t \n\thmac_desc = sctp_auth_asoc_get_hmac(asoc);\n\tif (unlikely(!hmac_desc))\n\t\treturn NULL;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_AUTH, 0,\n\t\t\t\t   hmac_desc->hmac_len + sizeof(auth_hdr),\n\t\t\t\t   GFP_ATOMIC);\n\tif (!retval)\n\t\treturn NULL;\n\n\tauth_hdr.hmac_id = htons(hmac_desc->hmac_id);\n\tauth_hdr.shkey_id = htons(key_id);\n\n\tretval->subh.auth_hdr = sctp_addto_chunk(retval, sizeof(auth_hdr),\n\t\t\t\t\t\t &auth_hdr);\n\n\tskb_put_zero(retval->skb, hmac_desc->hmac_len);\n\n\t \n\tretval->chunk_hdr->length =\n\t\thtons(ntohs(retval->chunk_hdr->length) + hmac_desc->hmac_len);\n\tretval->chunk_end = skb_tail_pointer(retval->skb);\n\n\treturn retval;\n}\n\n\n \n\n \nstruct sctp_chunk *sctp_chunkify(struct sk_buff *skb,\n\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t struct sock *sk, gfp_t gfp)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);\n\n\tif (!retval)\n\t\tgoto nodata;\n\tif (!sk)\n\t\tpr_debug(\"%s: chunkifying skb:%p w/o an sk\\n\", __func__, skb);\n\n\tINIT_LIST_HEAD(&retval->list);\n\tretval->skb\t\t= skb;\n\tretval->asoc\t\t= (struct sctp_association *)asoc;\n\tretval->singleton\t= 1;\n\n\tretval->fast_retransmit = SCTP_CAN_FRTX;\n\n\t \n\tINIT_LIST_HEAD(&retval->transmitted_list);\n\tINIT_LIST_HEAD(&retval->frag_list);\n\tSCTP_DBG_OBJCNT_INC(chunk);\n\trefcount_set(&retval->refcnt, 1);\n\nnodata:\n\treturn retval;\n}\n\n \nvoid sctp_init_addrs(struct sctp_chunk *chunk, union sctp_addr *src,\n\t\t     union sctp_addr *dest)\n{\n\tmemcpy(&chunk->source, src, sizeof(union sctp_addr));\n\tmemcpy(&chunk->dest, dest, sizeof(union sctp_addr));\n}\n\n \nconst union sctp_addr *sctp_source(const struct sctp_chunk *chunk)\n{\n\t \n\tif (chunk->transport) {\n\t\treturn &chunk->transport->ipaddr;\n\t} else {\n\t\t \n\t\treturn &chunk->source;\n\t}\n}\n\n \nstatic struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,\n\t\t\t\t\t   __u8 type, __u8 flags, int paylen,\n\t\t\t\t\t   gfp_t gfp)\n{\n\tstruct sctp_chunkhdr *chunk_hdr;\n\tstruct sctp_chunk *retval;\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tint chunklen;\n\n\tchunklen = SCTP_PAD4(sizeof(*chunk_hdr) + paylen);\n\tif (chunklen > SCTP_MAX_CHUNK_LEN)\n\t\tgoto nodata;\n\n\t \n\tskb = alloc_skb(chunklen, gfp);\n\tif (!skb)\n\t\tgoto nodata;\n\n\t \n\tchunk_hdr = (struct sctp_chunkhdr *)skb_put(skb, sizeof(*chunk_hdr));\n\tchunk_hdr->type\t  = type;\n\tchunk_hdr->flags  = flags;\n\tchunk_hdr->length = htons(sizeof(*chunk_hdr));\n\n\tsk = asoc ? asoc->base.sk : NULL;\n\tretval = sctp_chunkify(skb, asoc, sk, gfp);\n\tif (!retval) {\n\t\tkfree_skb(skb);\n\t\tgoto nodata;\n\t}\n\n\tretval->chunk_hdr = chunk_hdr;\n\tretval->chunk_end = ((__u8 *)chunk_hdr) + sizeof(*chunk_hdr);\n\n\t \n\tif (sctp_auth_send_cid(type, asoc))\n\t\tretval->auth = 1;\n\n\treturn retval;\nnodata:\n\treturn NULL;\n}\n\nstatic struct sctp_chunk *sctp_make_data(const struct sctp_association *asoc,\n\t\t\t\t\t __u8 flags, int paylen, gfp_t gfp)\n{\n\treturn _sctp_make_chunk(asoc, SCTP_CID_DATA, flags, paylen, gfp);\n}\n\nstruct sctp_chunk *sctp_make_idata(const struct sctp_association *asoc,\n\t\t\t\t   __u8 flags, int paylen, gfp_t gfp)\n{\n\treturn _sctp_make_chunk(asoc, SCTP_CID_I_DATA, flags, paylen, gfp);\n}\n\nstatic struct sctp_chunk *sctp_make_control(const struct sctp_association *asoc,\n\t\t\t\t\t    __u8 type, __u8 flags, int paylen,\n\t\t\t\t\t    gfp_t gfp)\n{\n\tstruct sctp_chunk *chunk;\n\n\tchunk = _sctp_make_chunk(asoc, type, flags, paylen, gfp);\n\tif (chunk)\n\t\tsctp_control_set_owner_w(chunk);\n\n\treturn chunk;\n}\n\n \nstatic void sctp_chunk_destroy(struct sctp_chunk *chunk)\n{\n\tBUG_ON(!list_empty(&chunk->list));\n\tlist_del_init(&chunk->transmitted_list);\n\n\tconsume_skb(chunk->skb);\n\tconsume_skb(chunk->auth_chunk);\n\n\tSCTP_DBG_OBJCNT_DEC(chunk);\n\tkmem_cache_free(sctp_chunk_cachep, chunk);\n}\n\n \nvoid sctp_chunk_free(struct sctp_chunk *chunk)\n{\n\t \n\tif (chunk->msg)\n\t\tsctp_datamsg_put(chunk->msg);\n\n\tsctp_chunk_put(chunk);\n}\n\n \nvoid sctp_chunk_hold(struct sctp_chunk *ch)\n{\n\trefcount_inc(&ch->refcnt);\n}\n\n \nvoid sctp_chunk_put(struct sctp_chunk *ch)\n{\n\tif (refcount_dec_and_test(&ch->refcnt))\n\t\tsctp_chunk_destroy(ch);\n}\n\n \nvoid *sctp_addto_chunk(struct sctp_chunk *chunk, int len, const void *data)\n{\n\tint chunklen = ntohs(chunk->chunk_hdr->length);\n\tint padlen = SCTP_PAD4(chunklen) - chunklen;\n\tvoid *target;\n\n\tskb_put_zero(chunk->skb, padlen);\n\ttarget = skb_put_data(chunk->skb, data, len);\n\n\t \n\tchunk->chunk_hdr->length = htons(chunklen + padlen + len);\n\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\n\treturn target;\n}\n\n \nint sctp_user_addto_chunk(struct sctp_chunk *chunk, int len,\n\t\t\t  struct iov_iter *from)\n{\n\tvoid *target;\n\n\t \n\ttarget = skb_put(chunk->skb, len);\n\n\t \n\tif (!copy_from_iter_full(target, len, from))\n\t\treturn -EFAULT;\n\n\t \n\tchunk->chunk_hdr->length =\n\t\thtons(ntohs(chunk->chunk_hdr->length) + len);\n\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\n\treturn 0;\n}\n\n \nvoid sctp_chunk_assign_ssn(struct sctp_chunk *chunk)\n{\n\tstruct sctp_stream *stream;\n\tstruct sctp_chunk *lchunk;\n\tstruct sctp_datamsg *msg;\n\t__u16 ssn, sid;\n\n\tif (chunk->has_ssn)\n\t\treturn;\n\n\t \n\tsid = ntohs(chunk->subh.data_hdr->stream);\n\tstream = &chunk->asoc->stream;\n\n\t \n\tmsg = chunk->msg;\n\tlist_for_each_entry(lchunk, &msg->chunks, frag_list) {\n\t\tif (lchunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\t\tssn = 0;\n\t\t} else {\n\t\t\tif (lchunk->chunk_hdr->flags & SCTP_DATA_LAST_FRAG)\n\t\t\t\tssn = sctp_ssn_next(stream, out, sid);\n\t\t\telse\n\t\t\t\tssn = sctp_ssn_peek(stream, out, sid);\n\t\t}\n\n\t\tlchunk->subh.data_hdr->ssn = htons(ssn);\n\t\tlchunk->has_ssn = 1;\n\t}\n}\n\n \nvoid sctp_chunk_assign_tsn(struct sctp_chunk *chunk)\n{\n\tif (!chunk->has_tsn) {\n\t\t \n\t\tchunk->subh.data_hdr->tsn =\n\t\t\thtonl(sctp_association_get_next_tsn(chunk->asoc));\n\t\tchunk->has_tsn = 1;\n\t}\n}\n\n \nstruct sctp_association *sctp_make_temp_asoc(const struct sctp_endpoint *ep,\n\t\t\t\t\t     struct sctp_chunk *chunk,\n\t\t\t\t\t     gfp_t gfp)\n{\n\tstruct sctp_association *asoc;\n\tenum sctp_scope scope;\n\tstruct sk_buff *skb;\n\n\t \n\tscope = sctp_scope(sctp_source(chunk));\n\tasoc = sctp_association_new(ep, ep->base.sk, scope, gfp);\n\tif (!asoc)\n\t\tgoto nodata;\n\tasoc->temp = 1;\n\tskb = chunk->skb;\n\t \n\tSCTP_INPUT_CB(skb)->af->from_skb(&asoc->c.peer_addr, skb, 1);\n\nnodata:\n\treturn asoc;\n}\n\n \nstatic struct sctp_cookie_param *sctp_pack_cookie(\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *init_chunk,\n\t\t\t\t\tint *cookie_len, const __u8 *raw_addrs,\n\t\t\t\t\tint addrs_len)\n{\n\tstruct sctp_signed_cookie *cookie;\n\tstruct sctp_cookie_param *retval;\n\tint headersize, bodysize;\n\n\t \n\theadersize = sizeof(struct sctp_paramhdr) +\n\t\t     (sizeof(struct sctp_signed_cookie) -\n\t\t      sizeof(struct sctp_cookie));\n\tbodysize = sizeof(struct sctp_cookie)\n\t\t+ ntohs(init_chunk->chunk_hdr->length) + addrs_len;\n\n\t \n\tif (bodysize % SCTP_COOKIE_MULTIPLE)\n\t\tbodysize += SCTP_COOKIE_MULTIPLE\n\t\t\t- (bodysize % SCTP_COOKIE_MULTIPLE);\n\t*cookie_len = headersize + bodysize;\n\n\t \n\tretval = kzalloc(*cookie_len, GFP_ATOMIC);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tcookie = (struct sctp_signed_cookie *) retval->body;\n\n\t \n\tretval->p.type = SCTP_PARAM_STATE_COOKIE;\n\tretval->p.length = htons(*cookie_len);\n\n\t \n\tcookie->c = asoc->c;\n\t \n\tcookie->c.raw_addr_list_len = addrs_len;\n\n\t \n\tcookie->c.prsctp_capable = asoc->peer.prsctp_capable;\n\n\t \n\tcookie->c.adaptation_ind = asoc->peer.adaptation_ind;\n\n\t \n\tcookie->c.expiration = ktime_add(asoc->cookie_life,\n\t\t\t\t\t ktime_get_real());\n\n\t \n\tmemcpy(cookie + 1, init_chunk->chunk_hdr,\n\t       ntohs(init_chunk->chunk_hdr->length));\n\n\t \n\tmemcpy((__u8 *)(cookie + 1) +\n\t       ntohs(init_chunk->chunk_hdr->length), raw_addrs, addrs_len);\n\n\tif (sctp_sk(ep->base.sk)->hmac) {\n\t\tstruct crypto_shash *tfm = sctp_sk(ep->base.sk)->hmac;\n\t\tint err;\n\n\t\t \n\t\terr = crypto_shash_setkey(tfm, ep->secret_key,\n\t\t\t\t\t  sizeof(ep->secret_key)) ?:\n\t\t      crypto_shash_tfm_digest(tfm, (u8 *)&cookie->c, bodysize,\n\t\t\t\t\t      cookie->signature);\n\t\tif (err)\n\t\t\tgoto free_cookie;\n\t}\n\n\treturn retval;\n\nfree_cookie:\n\tkfree(retval);\nnodata:\n\t*cookie_len = 0;\n\treturn NULL;\n}\n\n \nstruct sctp_association *sctp_unpack_cookie(\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk, gfp_t gfp,\n\t\t\t\t\tint *error, struct sctp_chunk **errp)\n{\n\tstruct sctp_association *retval = NULL;\n\tint headersize, bodysize, fixed_size;\n\tstruct sctp_signed_cookie *cookie;\n\tstruct sk_buff *skb = chunk->skb;\n\tstruct sctp_cookie *bear_cookie;\n\t__u8 *digest = ep->digest;\n\tenum sctp_scope scope;\n\tunsigned int len;\n\tktime_t kt;\n\n\t \n\theadersize = sizeof(struct sctp_chunkhdr) +\n\t\t     (sizeof(struct sctp_signed_cookie) -\n\t\t      sizeof(struct sctp_cookie));\n\tbodysize = ntohs(chunk->chunk_hdr->length) - headersize;\n\tfixed_size = headersize + sizeof(struct sctp_cookie);\n\n\t \n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len < fixed_size + sizeof(struct sctp_chunkhdr))\n\t\tgoto malformed;\n\n\t \n\tif (bodysize % SCTP_COOKIE_MULTIPLE)\n\t\tgoto malformed;\n\n\t \n\tcookie = chunk->subh.cookie_hdr;\n\tbear_cookie = &cookie->c;\n\n\tif (!sctp_sk(ep->base.sk)->hmac)\n\t\tgoto no_hmac;\n\n\t \n\t{\n\t\tstruct crypto_shash *tfm = sctp_sk(ep->base.sk)->hmac;\n\t\tint err;\n\n\t\terr = crypto_shash_setkey(tfm, ep->secret_key,\n\t\t\t\t\t  sizeof(ep->secret_key)) ?:\n\t\t      crypto_shash_tfm_digest(tfm, (u8 *)bear_cookie, bodysize,\n\t\t\t\t\t      digest);\n\t\tif (err) {\n\t\t\t*error = -SCTP_IERROR_NOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (memcmp(digest, cookie->signature, SCTP_SIGNATURE_SIZE)) {\n\t\t*error = -SCTP_IERROR_BAD_SIG;\n\t\tgoto fail;\n\t}\n\nno_hmac:\n\t \n\tif (ntohl(chunk->sctp_hdr->vtag) != bear_cookie->my_vtag) {\n\t\t*error = -SCTP_IERROR_BAD_TAG;\n\t\tgoto fail;\n\t}\n\n\tif (chunk->sctp_hdr->source != bear_cookie->peer_addr.v4.sin_port ||\n\t    ntohs(chunk->sctp_hdr->dest) != bear_cookie->my_port) {\n\t\t*error = -SCTP_IERROR_BAD_PORTS;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (sock_flag(ep->base.sk, SOCK_TIMESTAMP))\n\t\tkt = skb_get_ktime(skb);\n\telse\n\t\tkt = ktime_get_real();\n\n\tif (!asoc && ktime_before(bear_cookie->expiration, kt)) {\n\t\tsuseconds_t usecs = ktime_to_us(ktime_sub(kt, bear_cookie->expiration));\n\t\t__be32 n = htonl(usecs);\n\n\t\t \n\t\t*errp = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t   SCTP_ERROR_STALE_COOKIE, &n,\n\t\t\t\t\t   sizeof(n), 0);\n\t\tif (*errp)\n\t\t\t*error = -SCTP_IERROR_STALE_COOKIE;\n\t\telse\n\t\t\t*error = -SCTP_IERROR_NOMEM;\n\n\t\tgoto fail;\n\t}\n\n\t \n\tscope = sctp_scope(sctp_source(chunk));\n\tretval = sctp_association_new(ep, ep->base.sk, scope, gfp);\n\tif (!retval) {\n\t\t*error = -SCTP_IERROR_NOMEM;\n\t\tgoto fail;\n\t}\n\n\t \n\tretval->peer.port = ntohs(chunk->sctp_hdr->source);\n\n\t \n\tmemcpy(&retval->c, bear_cookie, sizeof(*bear_cookie));\n\n\tif (sctp_assoc_set_bind_addr_from_cookie(retval, bear_cookie,\n\t\t\t\t\t\t GFP_ATOMIC) < 0) {\n\t\t*error = -SCTP_IERROR_NOMEM;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (list_empty(&retval->base.bind_addr.address_list)) {\n\t\tsctp_add_bind_addr(&retval->base.bind_addr, &chunk->dest,\n\t\t\t\t   sizeof(chunk->dest), SCTP_ADDR_SRC,\n\t\t\t\t   GFP_ATOMIC);\n\t}\n\n\tretval->next_tsn = retval->c.initial_tsn;\n\tretval->ctsn_ack_point = retval->next_tsn - 1;\n\tretval->addip_serial = retval->c.initial_tsn;\n\tretval->strreset_outseq = retval->c.initial_tsn;\n\tretval->adv_peer_ack_point = retval->ctsn_ack_point;\n\tretval->peer.prsctp_capable = retval->c.prsctp_capable;\n\tretval->peer.adaptation_ind = retval->c.adaptation_ind;\n\n\t \n\treturn retval;\n\nfail:\n\tif (retval)\n\t\tsctp_association_free(retval);\n\n\treturn NULL;\n\nmalformed:\n\t \n\t*error = -SCTP_IERROR_MALFORMED;\n\tgoto fail;\n}\n\n \n\nstruct __sctp_missing {\n\t__be32 num_missing;\n\t__be16 type;\n}  __packed;\n\n \nstatic int sctp_process_missing_param(const struct sctp_association *asoc,\n\t\t\t\t      enum sctp_param paramtype,\n\t\t\t\t      struct sctp_chunk *chunk,\n\t\t\t\t      struct sctp_chunk **errp)\n{\n\tstruct __sctp_missing report;\n\t__u16 len;\n\n\tlen = SCTP_PAD4(sizeof(report));\n\n\t \n\tif (!*errp)\n\t\t*errp = sctp_make_op_error_space(asoc, chunk, len);\n\n\tif (*errp) {\n\t\treport.num_missing = htonl(1);\n\t\treport.type = paramtype;\n\t\tsctp_init_cause(*errp, SCTP_ERROR_MISS_PARAM,\n\t\t\t\tsizeof(report));\n\t\tsctp_addto_chunk(*errp, sizeof(report), &report);\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic int sctp_process_inv_mandatory(const struct sctp_association *asoc,\n\t\t\t\t      struct sctp_chunk *chunk,\n\t\t\t\t      struct sctp_chunk **errp)\n{\n\t \n\n\tif (!*errp)\n\t\t*errp = sctp_make_op_error_space(asoc, chunk, 0);\n\n\tif (*errp)\n\t\tsctp_init_cause(*errp, SCTP_ERROR_INV_PARAM, 0);\n\n\t \n\treturn 0;\n}\n\nstatic int sctp_process_inv_paramlength(const struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_paramhdr *param,\n\t\t\t\t\tconst struct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **errp)\n{\n\t \n\tif (*errp)\n\t\tsctp_chunk_free(*errp);\n\n\t \n\t*errp = sctp_make_violation_paramlen(asoc, chunk, param);\n\n\treturn 0;\n}\n\n\n \nstatic int sctp_process_hn_param(const struct sctp_association *asoc,\n\t\t\t\t union sctp_params param,\n\t\t\t\t struct sctp_chunk *chunk,\n\t\t\t\t struct sctp_chunk **errp)\n{\n\t__u16 len = ntohs(param.p->length);\n\n\t \n\tif (*errp)\n\t\tsctp_chunk_free(*errp);\n\n\t*errp = sctp_make_op_error(asoc, chunk, SCTP_ERROR_DNS_FAILED,\n\t\t\t\t   param.v, len, 0);\n\n\t \n\treturn 0;\n}\n\nstatic int sctp_verify_ext_param(struct net *net,\n\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t union sctp_params param)\n{\n\t__u16 num_ext = ntohs(param.p->length) - sizeof(struct sctp_paramhdr);\n\tint have_asconf = 0;\n\tint have_auth = 0;\n\tint i;\n\n\tfor (i = 0; i < num_ext; i++) {\n\t\tswitch (param.ext->chunks[i]) {\n\t\tcase SCTP_CID_AUTH:\n\t\t\thave_auth = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_ASCONF:\n\t\tcase SCTP_CID_ASCONF_ACK:\n\t\t\thave_asconf = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (net->sctp.addip_noauth)\n\t\treturn 1;\n\n\tif (ep->asconf_enable && !have_auth && have_asconf)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void sctp_process_ext_param(struct sctp_association *asoc,\n\t\t\t\t   union sctp_params param)\n{\n\t__u16 num_ext = ntohs(param.p->length) - sizeof(struct sctp_paramhdr);\n\tint i;\n\n\tfor (i = 0; i < num_ext; i++) {\n\t\tswitch (param.ext->chunks[i]) {\n\t\tcase SCTP_CID_RECONF:\n\t\t\tif (asoc->ep->reconf_enable)\n\t\t\t\tasoc->peer.reconf_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_FWD_TSN:\n\t\t\tif (asoc->ep->prsctp_enable)\n\t\t\t\tasoc->peer.prsctp_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_AUTH:\n\t\t\t \n\t\t\tif (asoc->ep->auth_enable)\n\t\t\t\tasoc->peer.auth_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_ASCONF:\n\t\tcase SCTP_CID_ASCONF_ACK:\n\t\t\tif (asoc->ep->asconf_enable)\n\t\t\t\tasoc->peer.asconf_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_I_DATA:\n\t\t\tif (asoc->ep->intl_enable)\n\t\t\t\tasoc->peer.intl_capable = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic enum sctp_ierror sctp_process_unk_param(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tunion sctp_params param,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **errp)\n{\n\tint retval = SCTP_IERROR_NO_ERROR;\n\n\tswitch (param.p->type & SCTP_PARAM_ACTION_MASK) {\n\tcase SCTP_PARAM_ACTION_DISCARD:\n\t\tretval =  SCTP_IERROR_ERROR;\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_SKIP:\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_DISCARD_ERR:\n\t\tretval =  SCTP_IERROR_ERROR;\n\t\tfallthrough;\n\tcase SCTP_PARAM_ACTION_SKIP_ERR:\n\t\t \n\t\tif (!*errp) {\n\t\t\t*errp = sctp_make_op_error_limited(asoc, chunk);\n\t\t\tif (!*errp) {\n\t\t\t\t \n\t\t\t\tretval = SCTP_IERROR_NOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!sctp_init_cause(*errp, SCTP_ERROR_UNKNOWN_PARAM,\n\t\t\t\t     ntohs(param.p->length)))\n\t\t\tsctp_addto_chunk(*errp, ntohs(param.p->length),\n\t\t\t\t\t param.v);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n \nstatic enum sctp_ierror sctp_verify_param(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  union sctp_params param,\n\t\t\t\t\t  enum sctp_cid cid,\n\t\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t\t  struct sctp_chunk **err_chunk)\n{\n\tstruct sctp_hmac_algo_param *hmacs;\n\tint retval = SCTP_IERROR_NO_ERROR;\n\t__u16 n_elt, id = 0;\n\tint i;\n\n\t \n\n\tswitch (param.p->type) {\n\tcase SCTP_PARAM_IPV4_ADDRESS:\n\tcase SCTP_PARAM_IPV6_ADDRESS:\n\tcase SCTP_PARAM_COOKIE_PRESERVATIVE:\n\tcase SCTP_PARAM_SUPPORTED_ADDRESS_TYPES:\n\tcase SCTP_PARAM_STATE_COOKIE:\n\tcase SCTP_PARAM_HEARTBEAT_INFO:\n\tcase SCTP_PARAM_UNRECOGNIZED_PARAMETERS:\n\tcase SCTP_PARAM_ECN_CAPABLE:\n\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\tbreak;\n\n\tcase SCTP_PARAM_SUPPORTED_EXT:\n\t\tif (!sctp_verify_ext_param(net, ep, param))\n\t\t\treturn SCTP_IERROR_ABORT;\n\t\tbreak;\n\n\tcase SCTP_PARAM_SET_PRIMARY:\n\t\tif (!ep->asconf_enable)\n\t\t\tgoto unhandled;\n\n\t\tif (ntohs(param.p->length) < sizeof(struct sctp_addip_param) +\n\t\t\t\t\t     sizeof(struct sctp_paramhdr)) {\n\t\t\tsctp_process_inv_paramlength(asoc, param.p,\n\t\t\t\t\t\t     chunk, err_chunk);\n\t\t\tretval = SCTP_IERROR_ABORT;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_HOST_NAME_ADDRESS:\n\t\t \n\t\tsctp_process_hn_param(asoc, param, chunk, err_chunk);\n\t\tretval = SCTP_IERROR_ABORT;\n\t\tbreak;\n\n\tcase SCTP_PARAM_FWD_TSN_SUPPORT:\n\t\tif (ep->prsctp_enable)\n\t\t\tbreak;\n\t\tgoto unhandled;\n\n\tcase SCTP_PARAM_RANDOM:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto unhandled;\n\n\t\t \n\t\tif (SCTP_AUTH_RANDOM_LENGTH != ntohs(param.p->length) -\n\t\t\t\t\t       sizeof(struct sctp_paramhdr)) {\n\t\t\tsctp_process_inv_paramlength(asoc, param.p,\n\t\t\t\t\t\t     chunk, err_chunk);\n\t\t\tretval = SCTP_IERROR_ABORT;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_CHUNKS:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto unhandled;\n\n\t\t \n\t\tif (260 < ntohs(param.p->length)) {\n\t\t\tsctp_process_inv_paramlength(asoc, param.p,\n\t\t\t\t\t\t     chunk, err_chunk);\n\t\t\tretval = SCTP_IERROR_ABORT;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_HMAC_ALGO:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto unhandled;\n\n\t\thmacs = (struct sctp_hmac_algo_param *)param.p;\n\t\tn_elt = (ntohs(param.p->length) -\n\t\t\t sizeof(struct sctp_paramhdr)) >> 1;\n\n\t\t \n\t\tfor (i = 0; i < n_elt; i++) {\n\t\t\tid = ntohs(hmacs->hmac_ids[i]);\n\n\t\t\tif (id == SCTP_AUTH_HMAC_ID_SHA1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (id != SCTP_AUTH_HMAC_ID_SHA1) {\n\t\t\tsctp_process_inv_paramlength(asoc, param.p, chunk,\n\t\t\t\t\t\t     err_chunk);\n\t\t\tretval = SCTP_IERROR_ABORT;\n\t\t}\n\t\tbreak;\nunhandled:\n\tdefault:\n\t\tpr_debug(\"%s: unrecognized param:%d for chunk:%d\\n\",\n\t\t\t __func__, ntohs(param.p->type), cid);\n\n\t\tretval = sctp_process_unk_param(asoc, param, chunk, err_chunk);\n\t\tbreak;\n\t}\n\treturn retval;\n}\n\n \nint sctp_verify_init(struct net *net, const struct sctp_endpoint *ep,\n\t\t     const struct sctp_association *asoc, enum sctp_cid cid,\n\t\t     struct sctp_init_chunk *peer_init,\n\t\t     struct sctp_chunk *chunk, struct sctp_chunk **errp)\n{\n\tunion sctp_params param;\n\tbool has_cookie = false;\n\tint result;\n\n\t \n\tif (peer_init->init_hdr.num_outbound_streams == 0 ||\n\t    peer_init->init_hdr.num_inbound_streams == 0 ||\n\t    peer_init->init_hdr.init_tag == 0 ||\n\t    ntohl(peer_init->init_hdr.a_rwnd) < SCTP_DEFAULT_MINWINDOW)\n\t\treturn sctp_process_inv_mandatory(asoc, chunk, errp);\n\n\tsctp_walk_params(param, peer_init) {\n\t\tif (param.p->type == SCTP_PARAM_STATE_COOKIE)\n\t\t\thas_cookie = true;\n\t}\n\n\t \n\tif (param.v != (void *)chunk->chunk_end)\n\t\treturn sctp_process_inv_paramlength(asoc, param.p, chunk, errp);\n\n\t \n\tif ((SCTP_CID_INIT_ACK == cid) && !has_cookie)\n\t\treturn sctp_process_missing_param(asoc, SCTP_PARAM_STATE_COOKIE,\n\t\t\t\t\t\t  chunk, errp);\n\n\t \n\tsctp_walk_params(param, peer_init) {\n\t\tresult = sctp_verify_param(net, ep, asoc, param, cid,\n\t\t\t\t\t   chunk, errp);\n\t\tswitch (result) {\n\t\tcase SCTP_IERROR_ABORT:\n\t\tcase SCTP_IERROR_NOMEM:\n\t\t\treturn 0;\n\t\tcase SCTP_IERROR_ERROR:\n\t\t\treturn 1;\n\t\tcase SCTP_IERROR_NO_ERROR:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t}  \n\n\treturn 1;\n}\n\n \nint sctp_process_init(struct sctp_association *asoc, struct sctp_chunk *chunk,\n\t\t      const union sctp_addr *peer_addr,\n\t\t      struct sctp_init_chunk *peer_init, gfp_t gfp)\n{\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tunion sctp_params param;\n\tunion sctp_addr addr;\n\tstruct sctp_af *af;\n\tint src_match = 0;\n\n\t \n\n\t \n\tasoc->encap_port = SCTP_INPUT_CB(chunk->skb)->encap_port;\n\tif (!sctp_assoc_add_peer(asoc, peer_addr, gfp, SCTP_ACTIVE))\n\t\tgoto nomem;\n\n\tif (sctp_cmp_addr_exact(sctp_source(chunk), peer_addr))\n\t\tsrc_match = 1;\n\n\t \n\tsctp_walk_params(param, peer_init) {\n\t\tif (!src_match &&\n\t\t    (param.p->type == SCTP_PARAM_IPV4_ADDRESS ||\n\t\t     param.p->type == SCTP_PARAM_IPV6_ADDRESS)) {\n\t\t\taf = sctp_get_af_specific(param_type2af(param.p->type));\n\t\t\tif (!af->from_addr_param(&addr, param.addr,\n\t\t\t\t\t\t chunk->sctp_hdr->source, 0))\n\t\t\t\tcontinue;\n\t\t\tif (sctp_cmp_addr_exact(sctp_source(chunk), &addr))\n\t\t\t\tsrc_match = 1;\n\t\t}\n\n\t\tif (!sctp_process_param(asoc, param, peer_addr, gfp))\n\t\t\tgoto clean_up;\n\t}\n\n\t \n\tif (!src_match)\n\t\tgoto clean_up;\n\n\t \n\tif (asoc->peer.auth_capable && (!asoc->peer.peer_random ||\n\t\t\t\t\t!asoc->peer.peer_hmacs))\n\t\tasoc->peer.auth_capable = 0;\n\n\t \n\tif (!asoc->base.net->sctp.addip_noauth &&\n\t    (asoc->peer.asconf_capable && !asoc->peer.auth_capable)) {\n\t\tasoc->peer.addip_disabled_mask |= (SCTP_PARAM_ADD_IP |\n\t\t\t\t\t\t  SCTP_PARAM_DEL_IP |\n\t\t\t\t\t\t  SCTP_PARAM_SET_PRIMARY);\n\t\tasoc->peer.asconf_capable = 0;\n\t\tgoto clean_up;\n\t}\n\n\t \n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tif (transport->state == SCTP_UNKNOWN) {\n\t\t\tsctp_assoc_rm_peer(asoc, transport);\n\t\t}\n\t}\n\n\t \n\tasoc->peer.i.init_tag =\n\t\tntohl(peer_init->init_hdr.init_tag);\n\tasoc->peer.i.a_rwnd =\n\t\tntohl(peer_init->init_hdr.a_rwnd);\n\tasoc->peer.i.num_outbound_streams =\n\t\tntohs(peer_init->init_hdr.num_outbound_streams);\n\tasoc->peer.i.num_inbound_streams =\n\t\tntohs(peer_init->init_hdr.num_inbound_streams);\n\tasoc->peer.i.initial_tsn =\n\t\tntohl(peer_init->init_hdr.initial_tsn);\n\n\tasoc->strreset_inseq = asoc->peer.i.initial_tsn;\n\n\t \n\tif (asoc->c.sinit_num_ostreams  >\n\t    ntohs(peer_init->init_hdr.num_inbound_streams)) {\n\t\tasoc->c.sinit_num_ostreams =\n\t\t\tntohs(peer_init->init_hdr.num_inbound_streams);\n\t}\n\n\tif (asoc->c.sinit_max_instreams >\n\t    ntohs(peer_init->init_hdr.num_outbound_streams)) {\n\t\tasoc->c.sinit_max_instreams =\n\t\t\tntohs(peer_init->init_hdr.num_outbound_streams);\n\t}\n\n\t \n\tasoc->c.peer_vtag = asoc->peer.i.init_tag;\n\n\t \n\tasoc->peer.rwnd = asoc->peer.i.a_rwnd;\n\n\t \n\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\ttransport->ssthresh = asoc->peer.i.a_rwnd;\n\t}\n\n\t \n\tif (!sctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\n\t\t\t\tasoc->peer.i.initial_tsn, gfp))\n\t\tgoto clean_up;\n\n\t \n\n\tif (sctp_stream_init(&asoc->stream, asoc->c.sinit_num_ostreams,\n\t\t\t     asoc->c.sinit_max_instreams, gfp))\n\t\tgoto clean_up;\n\n\t \n\tsctp_assoc_update_frag_point(asoc);\n\n\tif (!asoc->temp && sctp_assoc_set_id(asoc, gfp))\n\t\tgoto clean_up;\n\n\t \n\tasoc->peer.addip_serial = asoc->peer.i.initial_tsn - 1;\n\treturn 1;\n\nclean_up:\n\t \n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tif (transport->state != SCTP_ACTIVE)\n\t\t\tsctp_assoc_rm_peer(asoc, transport);\n\t}\n\nnomem:\n\treturn 0;\n}\n\n\n \nstatic int sctp_process_param(struct sctp_association *asoc,\n\t\t\t      union sctp_params param,\n\t\t\t      const union sctp_addr *peer_addr,\n\t\t\t      gfp_t gfp)\n{\n\tstruct sctp_endpoint *ep = asoc->ep;\n\tunion sctp_addr_param *addr_param;\n\tstruct net *net = asoc->base.net;\n\tstruct sctp_transport *t;\n\tenum sctp_scope scope;\n\tunion sctp_addr addr;\n\tstruct sctp_af *af;\n\tint retval = 1, i;\n\tu32 stale;\n\t__u16 sat;\n\n\t \n\tswitch (param.p->type) {\n\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\tif (PF_INET6 != asoc->base.sk->sk_family)\n\t\t\tbreak;\n\t\tgoto do_addr_param;\n\n\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t \n\t\tif (ipv6_only_sock(asoc->base.sk))\n\t\t\tbreak;\ndo_addr_param:\n\t\taf = sctp_get_af_specific(param_type2af(param.p->type));\n\t\tif (!af->from_addr_param(&addr, param.addr, htons(asoc->peer.port), 0))\n\t\t\tbreak;\n\t\tscope = sctp_scope(peer_addr);\n\t\tif (sctp_in_scope(net, &addr, scope))\n\t\t\tif (!sctp_assoc_add_peer(asoc, &addr, gfp, SCTP_UNCONFIRMED))\n\t\t\t\treturn 0;\n\t\tbreak;\n\n\tcase SCTP_PARAM_COOKIE_PRESERVATIVE:\n\t\tif (!net->sctp.cookie_preserve_enable)\n\t\t\tbreak;\n\n\t\tstale = ntohl(param.life->lifespan_increment);\n\n\t\t \n\t\tasoc->cookie_life = ktime_add_ms(asoc->cookie_life, stale);\n\t\tbreak;\n\n\tcase SCTP_PARAM_SUPPORTED_ADDRESS_TYPES:\n\t\t \n\t\tasoc->peer.ipv4_address = 0;\n\t\tasoc->peer.ipv6_address = 0;\n\n\t\t \n\t\tif (peer_addr->sa.sa_family == AF_INET6)\n\t\t\tasoc->peer.ipv6_address = 1;\n\t\telse if (peer_addr->sa.sa_family == AF_INET)\n\t\t\tasoc->peer.ipv4_address = 1;\n\n\t\t \n\t\tsat = ntohs(param.p->length) - sizeof(struct sctp_paramhdr);\n\t\tif (sat)\n\t\t\tsat /= sizeof(__u16);\n\n\t\tfor (i = 0; i < sat; ++i) {\n\t\t\tswitch (param.sat->types[i]) {\n\t\t\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t\t\tasoc->peer.ipv4_address = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\t\t\tif (PF_INET6 == asoc->base.sk->sk_family)\n\t\t\t\t\tasoc->peer.ipv6_address = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:  \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_STATE_COOKIE:\n\t\tasoc->peer.cookie_len =\n\t\t\tntohs(param.p->length) - sizeof(struct sctp_paramhdr);\n\t\tkfree(asoc->peer.cookie);\n\t\tasoc->peer.cookie = kmemdup(param.cookie->body, asoc->peer.cookie_len, gfp);\n\t\tif (!asoc->peer.cookie)\n\t\t\tretval = 0;\n\t\tbreak;\n\n\tcase SCTP_PARAM_HEARTBEAT_INFO:\n\t\t \n\t\tbreak;\n\n\tcase SCTP_PARAM_UNRECOGNIZED_PARAMETERS:\n\t\t \n\t\tbreak;\n\n\tcase SCTP_PARAM_ECN_CAPABLE:\n\t\tif (asoc->ep->ecn_enable) {\n\t\t\tasoc->peer.ecn_capable = 1;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tgoto fall_through;\n\n\n\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\tasoc->peer.adaptation_ind = ntohl(param.aind->adaptation_ind);\n\t\tbreak;\n\n\tcase SCTP_PARAM_SET_PRIMARY:\n\t\tif (!ep->asconf_enable)\n\t\t\tgoto fall_through;\n\n\t\taddr_param = param.v + sizeof(struct sctp_addip_param);\n\n\t\taf = sctp_get_af_specific(param_type2af(addr_param->p.type));\n\t\tif (!af)\n\t\t\tbreak;\n\n\t\tif (!af->from_addr_param(&addr, addr_param,\n\t\t\t\t\t htons(asoc->peer.port), 0))\n\t\t\tbreak;\n\n\t\tif (!af->addr_valid(&addr, NULL, NULL))\n\t\t\tbreak;\n\n\t\tt = sctp_assoc_lookup_paddr(asoc, &addr);\n\t\tif (!t)\n\t\t\tbreak;\n\n\t\tsctp_assoc_set_primary(asoc, t);\n\t\tbreak;\n\n\tcase SCTP_PARAM_SUPPORTED_EXT:\n\t\tsctp_process_ext_param(asoc, param);\n\t\tbreak;\n\n\tcase SCTP_PARAM_FWD_TSN_SUPPORT:\n\t\tif (asoc->ep->prsctp_enable) {\n\t\t\tasoc->peer.prsctp_capable = 1;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tgoto fall_through;\n\n\tcase SCTP_PARAM_RANDOM:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fall_through;\n\n\t\t \n\t\tkfree(asoc->peer.peer_random);\n\t\tasoc->peer.peer_random = kmemdup(param.p,\n\t\t\t\t\t    ntohs(param.p->length), gfp);\n\t\tif (!asoc->peer.peer_random) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_HMAC_ALGO:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fall_through;\n\n\t\t \n\t\tkfree(asoc->peer.peer_hmacs);\n\t\tasoc->peer.peer_hmacs = kmemdup(param.p,\n\t\t\t\t\t    ntohs(param.p->length), gfp);\n\t\tif (!asoc->peer.peer_hmacs) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsctp_auth_asoc_set_default_hmac(asoc, param.hmac_algo);\n\t\tbreak;\n\n\tcase SCTP_PARAM_CHUNKS:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fall_through;\n\n\t\tkfree(asoc->peer.peer_chunks);\n\t\tasoc->peer.peer_chunks = kmemdup(param.p,\n\t\t\t\t\t    ntohs(param.p->length), gfp);\n\t\tif (!asoc->peer.peer_chunks)\n\t\t\tretval = 0;\n\t\tbreak;\nfall_through:\n\tdefault:\n\t\t \n\t\tpr_debug(\"%s: ignoring param:%d for association:%p.\\n\",\n\t\t\t __func__, ntohs(param.p->type), asoc);\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n \n__u32 sctp_generate_tag(const struct sctp_endpoint *ep)\n{\n\t \n\t__u32 x;\n\n\tdo {\n\t\tget_random_bytes(&x, sizeof(__u32));\n\t} while (x == 0);\n\n\treturn x;\n}\n\n \n__u32 sctp_generate_tsn(const struct sctp_endpoint *ep)\n{\n\t__u32 retval;\n\n\tget_random_bytes(&retval, sizeof(__u32));\n\treturn retval;\n}\n\n \nstatic struct sctp_chunk *sctp_make_asconf(struct sctp_association *asoc,\n\t\t\t\t\t   union sctp_addr *addr,\n\t\t\t\t\t   int vparam_len)\n{\n\tstruct sctp_addiphdr asconf;\n\tstruct sctp_chunk *retval;\n\tint length = sizeof(asconf) + vparam_len;\n\tunion sctp_addr_param addrparam;\n\tint addrlen;\n\tstruct sctp_af *af = sctp_get_af_specific(addr->v4.sin_family);\n\n\taddrlen = af->to_addr_param(addr, &addrparam);\n\tif (!addrlen)\n\t\treturn NULL;\n\tlength += addrlen;\n\n\t \n\tretval = sctp_make_control(asoc, SCTP_CID_ASCONF, 0, length,\n\t\t\t\t   GFP_ATOMIC);\n\tif (!retval)\n\t\treturn NULL;\n\n\tasconf.serial = htonl(asoc->addip_serial++);\n\n\tretval->subh.addip_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(asconf), &asconf);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrlen, &addrparam);\n\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_asconf_update_ip(struct sctp_association *asoc,\n\t\t\t\t\t      union sctp_addr *laddr,\n\t\t\t\t\t      struct sockaddr *addrs,\n\t\t\t\t\t      int addrcnt, __be16 flags)\n{\n\tunion sctp_addr_param addr_param;\n\tstruct sctp_addip_param\tparam;\n\tint paramlen = sizeof(param);\n\tstruct sctp_chunk *retval;\n\tint addr_param_len = 0;\n\tunion sctp_addr *addr;\n\tint totallen = 0, i;\n\tint del_pickup = 0;\n\tstruct sctp_af *af;\n\tvoid *addr_buf;\n\n\t \n\taddr_buf = addrs;\n\tfor (i = 0; i < addrcnt; i++) {\n\t\taddr = addr_buf;\n\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\taddr_param_len = af->to_addr_param(addr, &addr_param);\n\n\t\ttotallen += paramlen;\n\t\ttotallen += addr_param_len;\n\n\t\taddr_buf += af->sockaddr_len;\n\t\tif (asoc->asconf_addr_del_pending && !del_pickup) {\n\t\t\t \n\t\t\ttotallen += paramlen;\n\t\t\ttotallen += addr_param_len;\n\t\t\tdel_pickup = 1;\n\n\t\t\tpr_debug(\"%s: picked same-scope del_pending addr, \"\n\t\t\t\t \"totallen for all addresses is %d\\n\",\n\t\t\t\t __func__, totallen);\n\t\t}\n\t}\n\n\t \n\tretval = sctp_make_asconf(asoc, laddr, totallen);\n\tif (!retval)\n\t\treturn NULL;\n\n\t \n\taddr_buf = addrs;\n\tfor (i = 0; i < addrcnt; i++) {\n\t\taddr = addr_buf;\n\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\taddr_param_len = af->to_addr_param(addr, &addr_param);\n\t\tparam.param_hdr.type = flags;\n\t\tparam.param_hdr.length = htons(paramlen + addr_param_len);\n\t\tparam.crr_id = htonl(i);\n\n\t\tsctp_addto_chunk(retval, paramlen, &param);\n\t\tsctp_addto_chunk(retval, addr_param_len, &addr_param);\n\n\t\taddr_buf += af->sockaddr_len;\n\t}\n\tif (flags == SCTP_PARAM_ADD_IP && del_pickup) {\n\t\taddr = asoc->asconf_addr_del_pending;\n\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\taddr_param_len = af->to_addr_param(addr, &addr_param);\n\t\tparam.param_hdr.type = SCTP_PARAM_DEL_IP;\n\t\tparam.param_hdr.length = htons(paramlen + addr_param_len);\n\t\tparam.crr_id = htonl(i);\n\n\t\tsctp_addto_chunk(retval, paramlen, &param);\n\t\tsctp_addto_chunk(retval, addr_param_len, &addr_param);\n\t}\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_asconf_set_prim(struct sctp_association *asoc,\n\t\t\t\t\t     union sctp_addr *addr)\n{\n\tstruct sctp_af *af = sctp_get_af_specific(addr->v4.sin_family);\n\tunion sctp_addr_param addrparam;\n\tstruct sctp_addip_param\tparam;\n\tstruct sctp_chunk *retval;\n\tint len = sizeof(param);\n\tint addrlen;\n\n\taddrlen = af->to_addr_param(addr, &addrparam);\n\tif (!addrlen)\n\t\treturn NULL;\n\tlen += addrlen;\n\n\t \n\tretval = sctp_make_asconf(asoc, addr, len);\n\tif (!retval)\n\t\treturn NULL;\n\n\tparam.param_hdr.type = SCTP_PARAM_SET_PRIMARY;\n\tparam.param_hdr.length = htons(len);\n\tparam.crr_id = 0;\n\n\tsctp_addto_chunk(retval, sizeof(param), &param);\n\tsctp_addto_chunk(retval, addrlen, &addrparam);\n\n\treturn retval;\n}\n\n \nstatic struct sctp_chunk *sctp_make_asconf_ack(const struct sctp_association *asoc,\n\t\t\t\t\t       __u32 serial, int vparam_len)\n{\n\tstruct sctp_addiphdr asconf;\n\tstruct sctp_chunk *retval;\n\tint length = sizeof(asconf) + vparam_len;\n\n\t \n\tretval = sctp_make_control(asoc, SCTP_CID_ASCONF_ACK, 0, length,\n\t\t\t\t   GFP_ATOMIC);\n\tif (!retval)\n\t\treturn NULL;\n\n\tasconf.serial = htonl(serial);\n\n\tretval->subh.addip_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(asconf), &asconf);\n\n\treturn retval;\n}\n\n \nstatic void sctp_add_asconf_response(struct sctp_chunk *chunk, __be32 crr_id,\n\t\t\t\t     __be16 err_code,\n\t\t\t\t     struct sctp_addip_param *asconf_param)\n{\n\tstruct sctp_addip_param ack_param;\n\tstruct sctp_errhdr err_param;\n\tint asconf_param_len = 0;\n\tint err_param_len = 0;\n\t__be16 response_type;\n\n\tif (SCTP_ERROR_NO_ERROR == err_code) {\n\t\tresponse_type = SCTP_PARAM_SUCCESS_REPORT;\n\t} else {\n\t\tresponse_type = SCTP_PARAM_ERR_CAUSE;\n\t\terr_param_len = sizeof(err_param);\n\t\tif (asconf_param)\n\t\t\tasconf_param_len =\n\t\t\t\t ntohs(asconf_param->param_hdr.length);\n\t}\n\n\t \n\tack_param.param_hdr.type = response_type;\n\tack_param.param_hdr.length = htons(sizeof(ack_param) +\n\t\t\t\t\t   err_param_len +\n\t\t\t\t\t   asconf_param_len);\n\tack_param.crr_id = crr_id;\n\tsctp_addto_chunk(chunk, sizeof(ack_param), &ack_param);\n\n\tif (SCTP_ERROR_NO_ERROR == err_code)\n\t\treturn;\n\n\t \n\terr_param.cause = err_code;\n\terr_param.length = htons(err_param_len + asconf_param_len);\n\tsctp_addto_chunk(chunk, err_param_len, &err_param);\n\n\t \n\tif (asconf_param)\n\t\tsctp_addto_chunk(chunk, asconf_param_len, asconf_param);\n}\n\n \nstatic __be16 sctp_process_asconf_param(struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *asconf,\n\t\t\t\t\tstruct sctp_addip_param *asconf_param)\n{\n\tunion sctp_addr_param *addr_param;\n\tstruct sctp_transport *peer;\n\tunion sctp_addr\taddr;\n\tstruct sctp_af *af;\n\n\taddr_param = (void *)asconf_param + sizeof(*asconf_param);\n\n\tif (asconf_param->param_hdr.type != SCTP_PARAM_ADD_IP &&\n\t    asconf_param->param_hdr.type != SCTP_PARAM_DEL_IP &&\n\t    asconf_param->param_hdr.type != SCTP_PARAM_SET_PRIMARY)\n\t\treturn SCTP_ERROR_UNKNOWN_PARAM;\n\n\tswitch (addr_param->p.type) {\n\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\tif (!asoc->peer.ipv6_address)\n\t\t\treturn SCTP_ERROR_DNS_FAILED;\n\t\tbreak;\n\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\tif (!asoc->peer.ipv4_address)\n\t\t\treturn SCTP_ERROR_DNS_FAILED;\n\t\tbreak;\n\tdefault:\n\t\treturn SCTP_ERROR_DNS_FAILED;\n\t}\n\n\taf = sctp_get_af_specific(param_type2af(addr_param->p.type));\n\tif (unlikely(!af))\n\t\treturn SCTP_ERROR_DNS_FAILED;\n\n\tif (!af->from_addr_param(&addr, addr_param, htons(asoc->peer.port), 0))\n\t\treturn SCTP_ERROR_DNS_FAILED;\n\n\t \n\tif (!af->is_any(&addr) && !af->addr_valid(&addr, NULL, asconf->skb))\n\t\treturn SCTP_ERROR_DNS_FAILED;\n\n\tswitch (asconf_param->param_hdr.type) {\n\tcase SCTP_PARAM_ADD_IP:\n\t\t \n\t\tif (af->is_any(&addr))\n\t\t\tmemcpy(&addr, &asconf->source, sizeof(addr));\n\n\t\tif (security_sctp_bind_connect(asoc->ep->base.sk,\n\t\t\t\t\t       SCTP_PARAM_ADD_IP,\n\t\t\t\t\t       (struct sockaddr *)&addr,\n\t\t\t\t\t       af->sockaddr_len))\n\t\t\treturn SCTP_ERROR_REQ_REFUSED;\n\n\t\t \n\n\t\tpeer = sctp_assoc_add_peer(asoc, &addr, GFP_ATOMIC, SCTP_UNCONFIRMED);\n\t\tif (!peer)\n\t\t\treturn SCTP_ERROR_RSRC_LOW;\n\n\t\t \n\t\tsctp_transport_reset_hb_timer(peer);\n\t\tasoc->new_transport = peer;\n\t\tbreak;\n\tcase SCTP_PARAM_DEL_IP:\n\t\t \n\t\tif (asoc->peer.transport_count == 1)\n\t\t\treturn SCTP_ERROR_DEL_LAST_IP;\n\n\t\t \n\t\tif (sctp_cmp_addr_exact(&asconf->source, &addr))\n\t\t\treturn SCTP_ERROR_DEL_SRC_IP;\n\n\t\t \n\t\tif (af->is_any(&addr)) {\n\t\t\tsctp_assoc_set_primary(asoc, asconf->transport);\n\t\t\tsctp_assoc_del_nonprimary_peers(asoc,\n\t\t\t\t\t\t\tasconf->transport);\n\t\t\treturn SCTP_ERROR_NO_ERROR;\n\t\t}\n\n\t\t \n\t\tpeer = sctp_assoc_lookup_paddr(asoc, &addr);\n\t\tif (!peer)\n\t\t\treturn SCTP_ERROR_DNS_FAILED;\n\n\t\tsctp_assoc_rm_peer(asoc, peer);\n\t\tbreak;\n\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t \n\t\tif (af->is_any(&addr))\n\t\t\tmemcpy(&addr, sctp_source(asconf), sizeof(addr));\n\n\t\tif (security_sctp_bind_connect(asoc->ep->base.sk,\n\t\t\t\t\t       SCTP_PARAM_SET_PRIMARY,\n\t\t\t\t\t       (struct sockaddr *)&addr,\n\t\t\t\t\t       af->sockaddr_len))\n\t\t\treturn SCTP_ERROR_REQ_REFUSED;\n\n\t\tpeer = sctp_assoc_lookup_paddr(asoc, &addr);\n\t\tif (!peer)\n\t\t\treturn SCTP_ERROR_DNS_FAILED;\n\n\t\tsctp_assoc_set_primary(asoc, peer);\n\t\tbreak;\n\t}\n\n\treturn SCTP_ERROR_NO_ERROR;\n}\n\n \nbool sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t\tstruct sctp_chunk *chunk, bool addr_param_needed,\n\t\t\tstruct sctp_paramhdr **errp)\n{\n\tstruct sctp_addip_chunk *addip;\n\tbool addr_param_seen = false;\n\tunion sctp_params param;\n\n\taddip = (struct sctp_addip_chunk *)chunk->chunk_hdr;\n\tsctp_walk_params(param, addip) {\n\t\tsize_t length = ntohs(param.p->length);\n\n\t\t*errp = param.p;\n\t\tswitch (param.p->type) {\n\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t\tif (length != sizeof(struct sctp_ipv4addr_param))\n\t\t\t\treturn false;\n\t\t\t \n\t\t\tif (param.v != (addip + 1))\n\t\t\t\treturn false;\n\t\t\taddr_param_seen = true;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\t\tif (length != sizeof(struct sctp_ipv6addr_param))\n\t\t\t\treturn false;\n\t\t\tif (param.v != (addip + 1))\n\t\t\t\treturn false;\n\t\t\taddr_param_seen = true;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_PARAM_DEL_IP:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t\t \n\t\t\tif (addr_param_needed && !addr_param_seen)\n\t\t\t\treturn false;\n\t\t\tlength = ntohs(param.addip->param_hdr.length);\n\t\t\tif (length < sizeof(struct sctp_addip_param) +\n\t\t\t\t     sizeof(**errp))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\t\tif (length != sizeof(struct sctp_addip_param))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tif (addr_param_needed && !addr_param_seen)\n\t\treturn false;\n\tif (!addr_param_needed && addr_param_seen)\n\t\treturn false;\n\tif (param.v != chunk->chunk_end)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstruct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *asconf)\n{\n\tunion sctp_addr_param *addr_param;\n\tstruct sctp_addip_chunk *addip;\n\tstruct sctp_chunk *asconf_ack;\n\tbool all_param_pass = true;\n\tstruct sctp_addiphdr *hdr;\n\tint length = 0, chunk_len;\n\tunion sctp_params param;\n\t__be16 err_code;\n\t__u32 serial;\n\n\taddip = (struct sctp_addip_chunk *)asconf->chunk_hdr;\n\tchunk_len = ntohs(asconf->chunk_hdr->length) -\n\t\t    sizeof(struct sctp_chunkhdr);\n\thdr = (struct sctp_addiphdr *)asconf->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\t \n\tlength = sizeof(*hdr);\n\taddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\n\tchunk_len -= length;\n\n\t \n\tlength = ntohs(addr_param->p.length);\n\tchunk_len -= length;\n\n\t \n\tasconf_ack = sctp_make_asconf_ack(asoc, serial, chunk_len * 4);\n\tif (!asconf_ack)\n\t\tgoto done;\n\n\t \n\tsctp_walk_params(param, addip) {\n\t\t \n\t\tif (param.p->type == SCTP_PARAM_IPV4_ADDRESS ||\n\t\t    param.p->type == SCTP_PARAM_IPV6_ADDRESS)\n\t\t\tcontinue;\n\n\t\terr_code = sctp_process_asconf_param(asoc, asconf,\n\t\t\t\t\t\t     param.addip);\n\t\t \n\t\tif (err_code != SCTP_ERROR_NO_ERROR)\n\t\t\tall_param_pass = false;\n\t\tif (!all_param_pass)\n\t\t\tsctp_add_asconf_response(asconf_ack, param.addip->crr_id,\n\t\t\t\t\t\t err_code, param.addip);\n\n\t\t \n\t\tif (err_code == SCTP_ERROR_RSRC_LOW)\n\t\t\tgoto done;\n\t}\ndone:\n\tasoc->peer.addip_serial++;\n\n\t \n\tif (asconf_ack) {\n\t\tsctp_chunk_hold(asconf_ack);\n\t\tlist_add_tail(&asconf_ack->transmitted_list,\n\t\t\t      &asoc->asconf_ack_list);\n\t}\n\n\treturn asconf_ack;\n}\n\n \nstatic void sctp_asconf_param_success(struct sctp_association *asoc,\n\t\t\t\t      struct sctp_addip_param *asconf_param)\n{\n\tstruct sctp_bind_addr *bp = &asoc->base.bind_addr;\n\tunion sctp_addr_param *addr_param;\n\tstruct sctp_sockaddr_entry *saddr;\n\tstruct sctp_transport *transport;\n\tunion sctp_addr\taddr;\n\tstruct sctp_af *af;\n\n\taddr_param = (void *)asconf_param + sizeof(*asconf_param);\n\n\t \n\taf = sctp_get_af_specific(param_type2af(addr_param->p.type));\n\tif (!af->from_addr_param(&addr, addr_param, htons(bp->port), 0))\n\t\treturn;\n\n\tswitch (asconf_param->param_hdr.type) {\n\tcase SCTP_PARAM_ADD_IP:\n\t\t \n\t\tlocal_bh_disable();\n\t\tlist_for_each_entry(saddr, &bp->address_list, list) {\n\t\t\tif (sctp_cmp_addr_exact(&saddr->a, &addr))\n\t\t\t\tsaddr->state = SCTP_ADDR_SRC;\n\t\t}\n\t\tlocal_bh_enable();\n\t\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tsctp_transport_dst_release(transport);\n\t\t}\n\t\tbreak;\n\tcase SCTP_PARAM_DEL_IP:\n\t\tlocal_bh_disable();\n\t\tsctp_del_bind_addr(bp, &addr);\n\t\tif (asoc->asconf_addr_del_pending != NULL &&\n\t\t    sctp_cmp_addr_exact(asoc->asconf_addr_del_pending, &addr)) {\n\t\t\tkfree(asoc->asconf_addr_del_pending);\n\t\t\tasoc->asconf_addr_del_pending = NULL;\n\t\t}\n\t\tlocal_bh_enable();\n\t\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tsctp_transport_dst_release(transport);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic __be16 sctp_get_asconf_response(struct sctp_chunk *asconf_ack,\n\t\t\t\t       struct sctp_addip_param *asconf_param,\n\t\t\t\t       int no_err)\n{\n\tstruct sctp_addip_param\t*asconf_ack_param;\n\tstruct sctp_errhdr *err_param;\n\tint asconf_ack_len;\n\t__be16 err_code;\n\tint length;\n\n\tif (no_err)\n\t\terr_code = SCTP_ERROR_NO_ERROR;\n\telse\n\t\terr_code = SCTP_ERROR_REQ_REFUSED;\n\n\tasconf_ack_len = ntohs(asconf_ack->chunk_hdr->length) -\n\t\t\t sizeof(struct sctp_chunkhdr);\n\n\t \n\tlength = sizeof(struct sctp_addiphdr);\n\tasconf_ack_param = (struct sctp_addip_param *)(asconf_ack->skb->data +\n\t\t\t\t\t\t       length);\n\tasconf_ack_len -= length;\n\n\twhile (asconf_ack_len > 0) {\n\t\tif (asconf_ack_param->crr_id == asconf_param->crr_id) {\n\t\t\tswitch (asconf_ack_param->param_hdr.type) {\n\t\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\t\t\treturn SCTP_ERROR_NO_ERROR;\n\t\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\t\tlength = sizeof(*asconf_ack_param);\n\t\t\t\terr_param = (void *)asconf_ack_param + length;\n\t\t\t\tasconf_ack_len -= length;\n\t\t\t\tif (asconf_ack_len > 0)\n\t\t\t\t\treturn err_param->cause;\n\t\t\t\telse\n\t\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\n\t\tlength = ntohs(asconf_ack_param->param_hdr.length);\n\t\tasconf_ack_param = (void *)asconf_ack_param + length;\n\t\tasconf_ack_len -= length;\n\t}\n\n\treturn err_code;\n}\n\n \nint sctp_process_asconf_ack(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *asconf_ack)\n{\n\tstruct sctp_chunk *asconf = asoc->addip_last_asconf;\n\tstruct sctp_addip_param *asconf_param;\n\t__be16 err_code = SCTP_ERROR_NO_ERROR;\n\tunion sctp_addr_param *addr_param;\n\tint asconf_len = asconf->skb->len;\n\tint all_param_pass = 0;\n\tint length = 0;\n\tint no_err = 1;\n\tint retval = 0;\n\n\t \n\tlength = sizeof(struct sctp_addip_chunk);\n\taddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\n\tasconf_len -= length;\n\n\t \n\tlength = ntohs(addr_param->p.length);\n\tasconf_param = (void *)addr_param + length;\n\tasconf_len -= length;\n\n\t \n\tif (asconf_ack->skb->len == sizeof(struct sctp_addiphdr))\n\t\tall_param_pass = 1;\n\n\t \n\twhile (asconf_len > 0) {\n\t\tif (all_param_pass)\n\t\t\terr_code = SCTP_ERROR_NO_ERROR;\n\t\telse {\n\t\t\terr_code = sctp_get_asconf_response(asconf_ack,\n\t\t\t\t\t\t\t    asconf_param,\n\t\t\t\t\t\t\t    no_err);\n\t\t\tif (no_err && (SCTP_ERROR_NO_ERROR != err_code))\n\t\t\t\tno_err = 0;\n\t\t}\n\n\t\tswitch (err_code) {\n\t\tcase SCTP_ERROR_NO_ERROR:\n\t\t\tsctp_asconf_param_success(asoc, asconf_param);\n\t\t\tbreak;\n\n\t\tcase SCTP_ERROR_RSRC_LOW:\n\t\t\tretval = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_ERROR_UNKNOWN_PARAM:\n\t\t\t \n\t\t\tasoc->peer.addip_disabled_mask |=\n\t\t\t\tasconf_param->param_hdr.type;\n\t\t\tbreak;\n\n\t\tcase SCTP_ERROR_REQ_REFUSED:\n\t\tcase SCTP_ERROR_DEL_LAST_IP:\n\t\tcase SCTP_ERROR_DEL_SRC_IP:\n\t\tdefault:\n\t\t\t break;\n\t\t}\n\n\t\t \n\t\tlength = ntohs(asconf_param->param_hdr.length);\n\t\tasconf_param = (void *)asconf_param + length;\n\t\tasconf_len -= length;\n\t}\n\n\tif (no_err && asoc->src_out_of_asoc_ok) {\n\t\tasoc->src_out_of_asoc_ok = 0;\n\t\tsctp_transport_immediate_rtx(asoc->peer.primary_path);\n\t}\n\n\t \n\tlist_del_init(&asconf->transmitted_list);\n\tsctp_chunk_free(asconf);\n\tasoc->addip_last_asconf = NULL;\n\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_fwdtsn(const struct sctp_association *asoc,\n\t\t\t\t    __u32 new_cum_tsn, size_t nstreams,\n\t\t\t\t    struct sctp_fwdtsn_skip *skiplist)\n{\n\tstruct sctp_chunk *retval = NULL;\n\tstruct sctp_fwdtsn_hdr ftsn_hdr;\n\tstruct sctp_fwdtsn_skip skip;\n\tsize_t hint;\n\tint i;\n\n\thint = (nstreams + 1) * sizeof(__u32);\n\n\tretval = sctp_make_control(asoc, SCTP_CID_FWD_TSN, 0, hint, GFP_ATOMIC);\n\n\tif (!retval)\n\t\treturn NULL;\n\n\tftsn_hdr.new_cum_tsn = htonl(new_cum_tsn);\n\tretval->subh.fwdtsn_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(ftsn_hdr), &ftsn_hdr);\n\n\tfor (i = 0; i < nstreams; i++) {\n\t\tskip.stream = skiplist[i].stream;\n\t\tskip.ssn = skiplist[i].ssn;\n\t\tsctp_addto_chunk(retval, sizeof(skip), &skip);\n\t}\n\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_ifwdtsn(const struct sctp_association *asoc,\n\t\t\t\t     __u32 new_cum_tsn, size_t nstreams,\n\t\t\t\t     struct sctp_ifwdtsn_skip *skiplist)\n{\n\tstruct sctp_chunk *retval = NULL;\n\tstruct sctp_ifwdtsn_hdr ftsn_hdr;\n\tsize_t hint;\n\n\thint = (nstreams + 1) * sizeof(__u32);\n\n\tretval = sctp_make_control(asoc, SCTP_CID_I_FWD_TSN, 0, hint,\n\t\t\t\t   GFP_ATOMIC);\n\tif (!retval)\n\t\treturn NULL;\n\n\tftsn_hdr.new_cum_tsn = htonl(new_cum_tsn);\n\tretval->subh.ifwdtsn_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(ftsn_hdr), &ftsn_hdr);\n\n\tsctp_addto_chunk(retval, nstreams * sizeof(skiplist[0]), skiplist);\n\n\treturn retval;\n}\n\n \nstatic struct sctp_chunk *sctp_make_reconf(const struct sctp_association *asoc,\n\t\t\t\t\t   int length)\n{\n\tstruct sctp_reconf_chunk *reconf;\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_RECONF, 0, length,\n\t\t\t\t   GFP_ATOMIC);\n\tif (!retval)\n\t\treturn NULL;\n\n\treconf = (struct sctp_reconf_chunk *)retval->chunk_hdr;\n\tretval->param_hdr.v = (u8 *)(reconf + 1);\n\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_strreset_req(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 stream_num, __be16 *stream_list,\n\t\t\t\t\tbool out, bool in)\n{\n\t__u16 stream_len = stream_num * sizeof(__u16);\n\tstruct sctp_strreset_outreq outreq;\n\tstruct sctp_strreset_inreq inreq;\n\tstruct sctp_chunk *retval;\n\t__u16 outlen, inlen;\n\n\toutlen = (sizeof(outreq) + stream_len) * out;\n\tinlen = (sizeof(inreq) + stream_len) * in;\n\n\tretval = sctp_make_reconf(asoc, SCTP_PAD4(outlen) + SCTP_PAD4(inlen));\n\tif (!retval)\n\t\treturn NULL;\n\n\tif (outlen) {\n\t\toutreq.param_hdr.type = SCTP_PARAM_RESET_OUT_REQUEST;\n\t\toutreq.param_hdr.length = htons(outlen);\n\t\toutreq.request_seq = htonl(asoc->strreset_outseq);\n\t\toutreq.response_seq = htonl(asoc->strreset_inseq - 1);\n\t\toutreq.send_reset_at_tsn = htonl(asoc->next_tsn - 1);\n\n\t\tsctp_addto_chunk(retval, sizeof(outreq), &outreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\tif (inlen) {\n\t\tinreq.param_hdr.type = SCTP_PARAM_RESET_IN_REQUEST;\n\t\tinreq.param_hdr.length = htons(inlen);\n\t\tinreq.request_seq = htonl(asoc->strreset_outseq + out);\n\n\t\tsctp_addto_chunk(retval, sizeof(inreq), &inreq);\n\n\t\tif (stream_len)\n\t\t\tsctp_addto_chunk(retval, stream_len, stream_list);\n\t}\n\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_strreset_tsnreq(\n\t\t\t\t\tconst struct sctp_association *asoc)\n{\n\tstruct sctp_strreset_tsnreq tsnreq;\n\t__u16 length = sizeof(tsnreq);\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_reconf(asoc, length);\n\tif (!retval)\n\t\treturn NULL;\n\n\ttsnreq.param_hdr.type = SCTP_PARAM_RESET_TSN_REQUEST;\n\ttsnreq.param_hdr.length = htons(length);\n\ttsnreq.request_seq = htonl(asoc->strreset_outseq);\n\n\tsctp_addto_chunk(retval, sizeof(tsnreq), &tsnreq);\n\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_strreset_addstrm(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__u16 out, __u16 in)\n{\n\tstruct sctp_strreset_addstrm addstrm;\n\t__u16 size = sizeof(addstrm);\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_reconf(asoc, (!!out + !!in) * size);\n\tif (!retval)\n\t\treturn NULL;\n\n\tif (out) {\n\t\taddstrm.param_hdr.type = SCTP_PARAM_RESET_ADD_OUT_STREAMS;\n\t\taddstrm.param_hdr.length = htons(size);\n\t\taddstrm.number_of_streams = htons(out);\n\t\taddstrm.request_seq = htonl(asoc->strreset_outseq);\n\t\taddstrm.reserved = 0;\n\n\t\tsctp_addto_chunk(retval, size, &addstrm);\n\t}\n\n\tif (in) {\n\t\taddstrm.param_hdr.type = SCTP_PARAM_RESET_ADD_IN_STREAMS;\n\t\taddstrm.param_hdr.length = htons(size);\n\t\taddstrm.number_of_streams = htons(in);\n\t\taddstrm.request_seq = htonl(asoc->strreset_outseq + !!out);\n\t\taddstrm.reserved = 0;\n\n\t\tsctp_addto_chunk(retval, size, &addstrm);\n\t}\n\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_strreset_resp(const struct sctp_association *asoc,\n\t\t\t\t\t   __u32 result, __u32 sn)\n{\n\tstruct sctp_strreset_resp resp;\n\t__u16 length = sizeof(resp);\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_reconf(asoc, length);\n\tif (!retval)\n\t\treturn NULL;\n\n\tresp.param_hdr.type = SCTP_PARAM_RESET_RESPONSE;\n\tresp.param_hdr.length = htons(length);\n\tresp.response_seq = htonl(sn);\n\tresp.result = htonl(result);\n\n\tsctp_addto_chunk(retval, sizeof(resp), &resp);\n\n\treturn retval;\n}\n\n \nstruct sctp_chunk *sctp_make_strreset_tsnresp(struct sctp_association *asoc,\n\t\t\t\t\t      __u32 result, __u32 sn,\n\t\t\t\t\t      __u32 sender_tsn,\n\t\t\t\t\t      __u32 receiver_tsn)\n{\n\tstruct sctp_strreset_resptsn tsnresp;\n\t__u16 length = sizeof(tsnresp);\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_reconf(asoc, length);\n\tif (!retval)\n\t\treturn NULL;\n\n\ttsnresp.param_hdr.type = SCTP_PARAM_RESET_RESPONSE;\n\ttsnresp.param_hdr.length = htons(length);\n\n\ttsnresp.response_seq = htonl(sn);\n\ttsnresp.result = htonl(result);\n\ttsnresp.senders_next_tsn = htonl(sender_tsn);\n\ttsnresp.receivers_next_tsn = htonl(receiver_tsn);\n\n\tsctp_addto_chunk(retval, sizeof(tsnresp), &tsnresp);\n\n\treturn retval;\n}\n\nbool sctp_verify_reconf(const struct sctp_association *asoc,\n\t\t\tstruct sctp_chunk *chunk,\n\t\t\tstruct sctp_paramhdr **errp)\n{\n\tstruct sctp_reconf_chunk *hdr;\n\tunion sctp_params param;\n\t__be16 last = 0;\n\t__u16 cnt = 0;\n\n\thdr = (struct sctp_reconf_chunk *)chunk->chunk_hdr;\n\tsctp_walk_params(param, hdr) {\n\t\t__u16 length = ntohs(param.p->length);\n\n\t\t*errp = param.p;\n\t\tif (cnt++ > 2)\n\t\t\treturn false;\n\t\tswitch (param.p->type) {\n\t\tcase SCTP_PARAM_RESET_OUT_REQUEST:\n\t\t\tif (length < sizeof(struct sctp_strreset_outreq) ||\n\t\t\t    (last && last != SCTP_PARAM_RESET_RESPONSE &&\n\t\t\t     last != SCTP_PARAM_RESET_IN_REQUEST))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_RESET_IN_REQUEST:\n\t\t\tif (length < sizeof(struct sctp_strreset_inreq) ||\n\t\t\t    (last && last != SCTP_PARAM_RESET_OUT_REQUEST))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_RESET_RESPONSE:\n\t\t\tif ((length != sizeof(struct sctp_strreset_resp) &&\n\t\t\t     length != sizeof(struct sctp_strreset_resptsn)) ||\n\t\t\t    (last && last != SCTP_PARAM_RESET_RESPONSE &&\n\t\t\t     last != SCTP_PARAM_RESET_OUT_REQUEST))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_RESET_TSN_REQUEST:\n\t\t\tif (length !=\n\t\t\t    sizeof(struct sctp_strreset_tsnreq) || last)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_RESET_ADD_IN_STREAMS:\n\t\t\tif (length != sizeof(struct sctp_strreset_addstrm) ||\n\t\t\t    (last && last != SCTP_PARAM_RESET_ADD_OUT_STREAMS))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_RESET_ADD_OUT_STREAMS:\n\t\t\tif (length != sizeof(struct sctp_strreset_addstrm) ||\n\t\t\t    (last && last != SCTP_PARAM_RESET_ADD_IN_STREAMS))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\n\t\tlast = param.p->type;\n\t}\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}