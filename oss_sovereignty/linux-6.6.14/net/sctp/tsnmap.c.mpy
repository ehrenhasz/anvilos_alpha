{
  "module_name": "tsnmap.c",
  "hash_id": "054d44850553351bfa3cd5b4bc457c72f2f4d0a17898800356ab3a499eddeb16",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/tsnmap.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/bitmap.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\nstatic void sctp_tsnmap_update(struct sctp_tsnmap *map);\nstatic void sctp_tsnmap_find_gap_ack(unsigned long *map, __u16 off,\n\t\t\t\t     __u16 len, __u16 *start, __u16 *end);\nstatic int sctp_tsnmap_grow(struct sctp_tsnmap *map, u16 size);\n\n \nstruct sctp_tsnmap *sctp_tsnmap_init(struct sctp_tsnmap *map, __u16 len,\n\t\t\t\t     __u32 initial_tsn, gfp_t gfp)\n{\n\tif (!map->tsn_map) {\n\t\tmap->tsn_map = kzalloc(len>>3, gfp);\n\t\tif (map->tsn_map == NULL)\n\t\t\treturn NULL;\n\n\t\tmap->len = len;\n\t} else {\n\t\tbitmap_zero(map->tsn_map, map->len);\n\t}\n\n\t \n\tmap->base_tsn = initial_tsn;\n\tmap->cumulative_tsn_ack_point = initial_tsn - 1;\n\tmap->max_tsn_seen = map->cumulative_tsn_ack_point;\n\tmap->num_dup_tsns = 0;\n\n\treturn map;\n}\n\nvoid sctp_tsnmap_free(struct sctp_tsnmap *map)\n{\n\tmap->len = 0;\n\tkfree(map->tsn_map);\n}\n\n \nint sctp_tsnmap_check(const struct sctp_tsnmap *map, __u32 tsn)\n{\n\tu32 gap;\n\n\t \n\tif (TSN_lte(tsn, map->cumulative_tsn_ack_point))\n\t\treturn 1;\n\n\t \n\tif (!TSN_lt(tsn, map->base_tsn + SCTP_TSN_MAP_SIZE))\n\t\treturn -1;\n\n\t \n\tgap = tsn - map->base_tsn;\n\n\t \n\tif (gap < map->len && test_bit(gap, map->tsn_map))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n\n \nint sctp_tsnmap_mark(struct sctp_tsnmap *map, __u32 tsn,\n\t\t     struct sctp_transport *trans)\n{\n\tu16 gap;\n\n\tif (TSN_lt(tsn, map->base_tsn))\n\t\treturn 0;\n\n\tgap = tsn - map->base_tsn;\n\n\tif (gap >= map->len && !sctp_tsnmap_grow(map, gap + 1))\n\t\treturn -ENOMEM;\n\n\tif (!sctp_tsnmap_has_gap(map) && gap == 0) {\n\t\t \n\t\tmap->max_tsn_seen++;\n\t\tmap->cumulative_tsn_ack_point++;\n\t\tif (trans)\n\t\t\ttrans->sack_generation =\n\t\t\t\ttrans->asoc->peer.sack_generation;\n\t\tmap->base_tsn++;\n\t} else {\n\t\t \n\t\tif (TSN_lt(map->max_tsn_seen, tsn))\n\t\t\tmap->max_tsn_seen = tsn;\n\n\t\t \n\t\tset_bit(gap, map->tsn_map);\n\n\t\t \n\t\tsctp_tsnmap_update(map);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic void sctp_tsnmap_iter_init(const struct sctp_tsnmap *map,\n\t\t\t\t  struct sctp_tsnmap_iter *iter)\n{\n\t \n\titer->start = map->cumulative_tsn_ack_point + 1;\n}\n\n \nstatic int sctp_tsnmap_next_gap_ack(const struct sctp_tsnmap *map,\n\t\t\t\t    struct sctp_tsnmap_iter *iter,\n\t\t\t\t    __u16 *start, __u16 *end)\n{\n\tint ended = 0;\n\t__u16 start_ = 0, end_ = 0, offset;\n\n\t \n\tif (TSN_lte(map->max_tsn_seen, iter->start))\n\t\treturn 0;\n\n\toffset = iter->start - map->base_tsn;\n\tsctp_tsnmap_find_gap_ack(map->tsn_map, offset, map->len,\n\t\t\t\t &start_, &end_);\n\n\t \n\tif (start_ && !end_)\n\t\tend_ = map->len - 1;\n\n\t \n\tif (end_) {\n\t\t \n\t\t*start = start_ + 1;\n\t\t*end = end_ + 1;\n\n\t\t \n\t\titer->start = map->cumulative_tsn_ack_point + *end + 1;\n\t\tended = 1;\n\t}\n\n\treturn ended;\n}\n\n \nvoid sctp_tsnmap_skip(struct sctp_tsnmap *map, __u32 tsn)\n{\n\tu32 gap;\n\n\tif (TSN_lt(tsn, map->base_tsn))\n\t\treturn;\n\tif (!TSN_lt(tsn, map->base_tsn + SCTP_TSN_MAP_SIZE))\n\t\treturn;\n\n\t \n\tif (TSN_lt(map->max_tsn_seen, tsn))\n\t\tmap->max_tsn_seen = tsn;\n\n\tgap = tsn - map->base_tsn + 1;\n\n\tmap->base_tsn += gap;\n\tmap->cumulative_tsn_ack_point += gap;\n\tif (gap >= map->len) {\n\t\t \n\t\tbitmap_zero(map->tsn_map, map->len);\n\t} else {\n\t\t \n\t\tbitmap_shift_right(map->tsn_map, map->tsn_map, gap, map->len);\n\t\tsctp_tsnmap_update(map);\n\t}\n}\n\n \n\n \nstatic void sctp_tsnmap_update(struct sctp_tsnmap *map)\n{\n\tu16 len;\n\tunsigned long zero_bit;\n\n\n\tlen = map->max_tsn_seen - map->cumulative_tsn_ack_point;\n\tzero_bit = find_first_zero_bit(map->tsn_map, len);\n\tif (!zero_bit)\n\t\treturn;\t\t \n\n\tmap->base_tsn += zero_bit;\n\tmap->cumulative_tsn_ack_point += zero_bit;\n\n\tbitmap_shift_right(map->tsn_map, map->tsn_map, zero_bit, map->len);\n}\n\n \n__u16 sctp_tsnmap_pending(struct sctp_tsnmap *map)\n{\n\t__u32 cum_tsn = map->cumulative_tsn_ack_point;\n\t__u32 max_tsn = map->max_tsn_seen;\n\t__u32 base_tsn = map->base_tsn;\n\t__u16 pending_data;\n\tu32 gap;\n\n\tpending_data = max_tsn - cum_tsn;\n\tgap = max_tsn - base_tsn;\n\n\tif (gap == 0 || gap >= map->len)\n\t\tgoto out;\n\n\tpending_data -= bitmap_weight(map->tsn_map, gap + 1);\nout:\n\treturn pending_data;\n}\n\n \nstatic void sctp_tsnmap_find_gap_ack(unsigned long *map, __u16 off,\n\t\t\t\t     __u16 len, __u16 *start, __u16 *end)\n{\n\tint i = off;\n\n\t \n\n\t \n\n\t \n\ti = find_next_bit(map, len, off);\n\tif (i < len)\n\t\t*start = i;\n\n\t \n\tif (*start) {\n\t\t \n\t\ti = find_next_zero_bit(map, len, i);\n\t\tif (i < len)\n\t\t\t*end = i - 1;\n\t}\n}\n\n \nvoid sctp_tsnmap_renege(struct sctp_tsnmap *map, __u32 tsn)\n{\n\tu32 gap;\n\n\tif (TSN_lt(tsn, map->base_tsn))\n\t\treturn;\n\t \n\tif (!TSN_lt(tsn, map->base_tsn + map->len))\n\t\treturn;\n\n\tgap = tsn - map->base_tsn;\n\n\t \n\tclear_bit(gap, map->tsn_map);\n}\n\n \n__u16 sctp_tsnmap_num_gabs(struct sctp_tsnmap *map,\n\t\t\t   struct sctp_gap_ack_block *gabs)\n{\n\tstruct sctp_tsnmap_iter iter;\n\tint ngaps = 0;\n\n\t \n\tif (sctp_tsnmap_has_gap(map)) {\n\t\t__u16 start = 0, end = 0;\n\t\tsctp_tsnmap_iter_init(map, &iter);\n\t\twhile (sctp_tsnmap_next_gap_ack(map, &iter,\n\t\t\t\t\t\t&start,\n\t\t\t\t\t\t&end)) {\n\n\t\t\tgabs[ngaps].start = htons(start);\n\t\t\tgabs[ngaps].end = htons(end);\n\t\t\tngaps++;\n\t\t\tif (ngaps >= SCTP_MAX_GABS)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ngaps;\n}\n\nstatic int sctp_tsnmap_grow(struct sctp_tsnmap *map, u16 size)\n{\n\tunsigned long *new;\n\tunsigned long inc;\n\tu16  len;\n\n\tif (size > SCTP_TSN_MAP_SIZE)\n\t\treturn 0;\n\n\tinc = ALIGN((size - map->len), BITS_PER_LONG) + SCTP_TSN_MAP_INCREMENT;\n\tlen = min_t(u16, map->len + inc, SCTP_TSN_MAP_SIZE);\n\n\tnew = kzalloc(len>>3, GFP_ATOMIC);\n\tif (!new)\n\t\treturn 0;\n\n\tbitmap_copy(new, map->tsn_map,\n\t\tmap->max_tsn_seen - map->cumulative_tsn_ack_point);\n\tkfree(map->tsn_map);\n\tmap->tsn_map = new;\n\tmap->len = len;\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}