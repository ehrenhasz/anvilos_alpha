{
  "module_name": "ulpqueue.c",
  "hash_id": "ca3957b77434de32ad5295d1fe52fd9b2b8f186f0dee8abe38ee071ef40cf9e7",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/ulpqueue.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/busy_poll.h>\n#include <net/sctp/structs.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\n \nstatic struct sctp_ulpevent *sctp_ulpq_reasm(struct sctp_ulpq *ulpq,\n\t\t\t\t\t      struct sctp_ulpevent *);\nstatic struct sctp_ulpevent *sctp_ulpq_order(struct sctp_ulpq *,\n\t\t\t\t\t      struct sctp_ulpevent *);\nstatic void sctp_ulpq_reasm_drain(struct sctp_ulpq *ulpq);\n\n \n\n \nvoid sctp_ulpq_init(struct sctp_ulpq *ulpq, struct sctp_association *asoc)\n{\n\tmemset(ulpq, 0, sizeof(struct sctp_ulpq));\n\n\tulpq->asoc = asoc;\n\tskb_queue_head_init(&ulpq->reasm);\n\tskb_queue_head_init(&ulpq->reasm_uo);\n\tskb_queue_head_init(&ulpq->lobby);\n\tulpq->pd_mode  = 0;\n}\n\n\n \nvoid sctp_ulpq_flush(struct sctp_ulpq *ulpq)\n{\n\tstruct sk_buff *skb;\n\tstruct sctp_ulpevent *event;\n\n\twhile ((skb = __skb_dequeue(&ulpq->lobby)) != NULL) {\n\t\tevent = sctp_skb2event(skb);\n\t\tsctp_ulpevent_free(event);\n\t}\n\n\twhile ((skb = __skb_dequeue(&ulpq->reasm)) != NULL) {\n\t\tevent = sctp_skb2event(skb);\n\t\tsctp_ulpevent_free(event);\n\t}\n\n\twhile ((skb = __skb_dequeue(&ulpq->reasm_uo)) != NULL) {\n\t\tevent = sctp_skb2event(skb);\n\t\tsctp_ulpevent_free(event);\n\t}\n}\n\n \nvoid sctp_ulpq_free(struct sctp_ulpq *ulpq)\n{\n\tsctp_ulpq_flush(ulpq);\n}\n\n \nint sctp_ulpq_tail_data(struct sctp_ulpq *ulpq, struct sctp_chunk *chunk,\n\t\t\tgfp_t gfp)\n{\n\tstruct sk_buff_head temp;\n\tstruct sctp_ulpevent *event;\n\tint event_eor = 0;\n\n\t \n\tevent = sctp_ulpevent_make_rcvmsg(chunk->asoc, chunk, gfp);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tevent->ssn = ntohs(chunk->subh.data_hdr->ssn);\n\tevent->ppid = chunk->subh.data_hdr->ppid;\n\n\t \n\tevent = sctp_ulpq_reasm(ulpq, event);\n\n\t \n\tif (event) {\n\t\t \n\t\tskb_queue_head_init(&temp);\n\t\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\n\t\tif (event->msg_flags & MSG_EOR)\n\t\t\tevent = sctp_ulpq_order(ulpq, event);\n\t}\n\n\t \n\tif (event) {\n\t\tevent_eor = (event->msg_flags & MSG_EOR) ? 1 : 0;\n\t\tsctp_ulpq_tail_event(ulpq, &temp);\n\t}\n\n\treturn event_eor;\n}\n\n \n \nint sctp_clear_pd(struct sock *sk, struct sctp_association *asoc)\n{\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (atomic_dec_and_test(&sp->pd_mode)) {\n\t\t \n\t\tif (!skb_queue_empty(&sp->pd_lobby)) {\n\t\t\tskb_queue_splice_tail_init(&sp->pd_lobby,\n\t\t\t\t\t\t   &sk->sk_receive_queue);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!skb_queue_empty(&sp->pd_lobby) && asoc) {\n\t\t\tstruct sk_buff *skb, *tmp;\n\t\t\tstruct sctp_ulpevent *event;\n\n\t\t\tsctp_skb_for_each(skb, &sp->pd_lobby, tmp) {\n\t\t\t\tevent = sctp_skb2event(skb);\n\t\t\t\tif (event->asoc == asoc) {\n\t\t\t\t\t__skb_unlink(skb, &sp->pd_lobby);\n\t\t\t\t\t__skb_queue_tail(&sk->sk_receive_queue,\n\t\t\t\t\t\t\t skb);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void sctp_ulpq_set_pd(struct sctp_ulpq *ulpq)\n{\n\tstruct sctp_sock *sp = sctp_sk(ulpq->asoc->base.sk);\n\n\tatomic_inc(&sp->pd_mode);\n\tulpq->pd_mode = 1;\n}\n\n \nstatic int sctp_ulpq_clear_pd(struct sctp_ulpq *ulpq)\n{\n\tulpq->pd_mode = 0;\n\tsctp_ulpq_reasm_drain(ulpq);\n\treturn sctp_clear_pd(ulpq->asoc->base.sk, ulpq->asoc);\n}\n\nint sctp_ulpq_tail_event(struct sctp_ulpq *ulpq, struct sk_buff_head *skb_list)\n{\n\tstruct sock *sk = ulpq->asoc->base.sk;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_ulpevent *event;\n\tstruct sk_buff_head *queue;\n\tstruct sk_buff *skb;\n\tint clear_pd = 0;\n\n\tskb = __skb_peek(skb_list);\n\tevent = sctp_skb2event(skb);\n\n\t \n\tif (sk->sk_shutdown & RCV_SHUTDOWN &&\n\t    (sk->sk_shutdown & SEND_SHUTDOWN ||\n\t     !sctp_ulpevent_is_notification(event)))\n\t\tgoto out_free;\n\n\tif (!sctp_ulpevent_is_notification(event)) {\n\t\tsk_mark_napi_id(sk, skb);\n\t\tsk_incoming_cpu_update(sk);\n\t}\n\t \n\tif (!sctp_ulpevent_is_enabled(event, ulpq->asoc->subscribe))\n\t\tgoto out_free;\n\n\t \n\n\tif (atomic_read(&sp->pd_mode) == 0) {\n\t\tqueue = &sk->sk_receive_queue;\n\t} else {\n\t\tif (ulpq->pd_mode) {\n\t\t\t \n\t\t\tif ((event->msg_flags & MSG_NOTIFICATION) ||\n\t\t\t    (SCTP_DATA_NOT_FRAG ==\n\t\t\t\t    (event->msg_flags & SCTP_DATA_FRAG_MASK)))\n\t\t\t\tqueue = &sp->pd_lobby;\n\t\t\telse {\n\t\t\t\tclear_pd = event->msg_flags & MSG_EOR;\n\t\t\t\tqueue = &sk->sk_receive_queue;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (sp->frag_interleave)\n\t\t\t\tqueue = &sk->sk_receive_queue;\n\t\t\telse\n\t\t\t\tqueue = &sp->pd_lobby;\n\t\t}\n\t}\n\n\tskb_queue_splice_tail_init(skb_list, queue);\n\n\t \n\tif (clear_pd)\n\t\tsctp_ulpq_clear_pd(ulpq);\n\n\tif (queue == &sk->sk_receive_queue && !sp->data_ready_signalled) {\n\t\tif (!sock_owned_by_user(sk))\n\t\t\tsp->data_ready_signalled = 1;\n\t\tsk->sk_data_ready(sk);\n\t}\n\treturn 1;\n\nout_free:\n\tsctp_queue_purge_ulpevents(skb_list);\n\n\treturn 0;\n}\n\n \n\n \nstatic void sctp_ulpq_store_reasm(struct sctp_ulpq *ulpq,\n\t\t\t\t\t struct sctp_ulpevent *event)\n{\n\tstruct sk_buff *pos;\n\tstruct sctp_ulpevent *cevent;\n\t__u32 tsn, ctsn;\n\n\ttsn = event->tsn;\n\n\t \n\tpos = skb_peek_tail(&ulpq->reasm);\n\tif (!pos) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\t \n\tcevent = sctp_skb2event(pos);\n\tctsn = cevent->tsn;\n\tif (TSN_lt(ctsn, tsn)) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\t \n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\n\t\tif (TSN_lt(tsn, ctsn))\n\t\t\tbreak;\n\t}\n\n\t \n\t__skb_queue_before(&ulpq->reasm, pos, sctp_event2skb(event));\n\n}\n\n \nstruct sctp_ulpevent *sctp_make_reassembled_event(struct net *net,\n\t\t\t\t\t\t  struct sk_buff_head *queue,\n\t\t\t\t\t\t  struct sk_buff *f_frag,\n\t\t\t\t\t\t  struct sk_buff *l_frag)\n{\n\tstruct sk_buff *pos;\n\tstruct sk_buff *new = NULL;\n\tstruct sctp_ulpevent *event;\n\tstruct sk_buff *pnext, *last;\n\tstruct sk_buff *list = skb_shinfo(f_frag)->frag_list;\n\n\t \n\tif (f_frag == l_frag)\n\t\tpos = NULL;\n\telse\n\t\tpos = f_frag->next;\n\n\t \n\tfor (last = list; list; last = list, list = list->next)\n\t\t;\n\n\t \n\tif (last)\n\t\tlast->next = pos;\n\telse {\n\t\tif (skb_cloned(f_frag)) {\n\t\t\t \n\t\t\tnew = skb_copy(f_frag, GFP_ATOMIC);\n\t\t\tif (!new)\n\t\t\t\treturn NULL;\t \n\n\t\t\tsctp_skb_set_owner_r(new, f_frag->sk);\n\n\t\t\tskb_shinfo(new)->frag_list = pos;\n\t\t} else\n\t\t\tskb_shinfo(f_frag)->frag_list = pos;\n\t}\n\n\t \n\t__skb_unlink(f_frag, queue);\n\n\t \n\tif (new) {\n\t\tkfree_skb(f_frag);\n\t\tf_frag = new;\n\t}\n\n\twhile (pos) {\n\n\t\tpnext = pos->next;\n\n\t\t \n\t\tf_frag->len += pos->len;\n\t\tf_frag->data_len += pos->len;\n\n\t\t \n\t\t__skb_unlink(pos, queue);\n\n\t\t \n\t\tif (pos == l_frag)\n\t\t\tbreak;\n\t\tpos->next = pnext;\n\t\tpos = pnext;\n\t}\n\n\tevent = sctp_skb2event(f_frag);\n\tSCTP_INC_STATS(net, SCTP_MIB_REASMUSRMSGS);\n\n\treturn event;\n}\n\n\n \nstatic struct sctp_ulpevent *sctp_ulpq_retrieve_reassembled(struct sctp_ulpq *ulpq)\n{\n\tstruct sk_buff *pos;\n\tstruct sctp_ulpevent *cevent;\n\tstruct sk_buff *first_frag = NULL;\n\t__u32 ctsn, next_tsn;\n\tstruct sctp_ulpevent *retval = NULL;\n\tstruct sk_buff *pd_first = NULL;\n\tstruct sk_buff *pd_last = NULL;\n\tsize_t pd_len = 0;\n\tstruct sctp_association *asoc;\n\tu32 pd_point;\n\n\t \n\tnext_tsn = 0;\n\n\t \n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_FIRST_FRAG:\n\t\t\t \n\t\t\tif (skb_queue_is_first(&ulpq->reasm, pos)) {\n\t\t\t    pd_first = pos;\n\t\t\t    pd_last = pos;\n\t\t\t    pd_len = pos->len;\n\t\t\t} else {\n\t\t\t    pd_first = NULL;\n\t\t\t    pd_last = NULL;\n\t\t\t    pd_len = 0;\n\t\t\t}\n\n\t\t\tfirst_frag = pos;\n\t\t\tnext_tsn = ctsn + 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif ((first_frag) && (ctsn == next_tsn)) {\n\t\t\t\tnext_tsn++;\n\t\t\t\tif (pd_first) {\n\t\t\t\t    pd_last = pos;\n\t\t\t\t    pd_len += pos->len;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tfirst_frag = NULL;\n\t\t\tbreak;\n\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (first_frag && (ctsn == next_tsn))\n\t\t\t\tgoto found;\n\t\t\telse\n\t\t\t\tfirst_frag = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tasoc = ulpq->asoc;\n\tif (pd_first) {\n\t\t \n\t\tif (!sctp_sk(asoc->base.sk)->frag_interleave &&\n\t\t    atomic_read(&sctp_sk(asoc->base.sk)->pd_mode))\n\t\t\tgoto done;\n\n\t\tcevent = sctp_skb2event(pd_first);\n\t\tpd_point = sctp_sk(asoc->base.sk)->pd_point;\n\t\tif (pd_point && pd_point <= pd_len) {\n\t\t\tretval = sctp_make_reassembled_event(asoc->base.net,\n\t\t\t\t\t\t\t     &ulpq->reasm,\n\t\t\t\t\t\t\t     pd_first, pd_last);\n\t\t\tif (retval)\n\t\t\t\tsctp_ulpq_set_pd(ulpq);\n\t\t}\n\t}\ndone:\n\treturn retval;\nfound:\n\tretval = sctp_make_reassembled_event(ulpq->asoc->base.net,\n\t\t\t\t\t     &ulpq->reasm, first_frag, pos);\n\tif (retval)\n\t\tretval->msg_flags |= MSG_EOR;\n\tgoto done;\n}\n\n \nstatic struct sctp_ulpevent *sctp_ulpq_retrieve_partial(struct sctp_ulpq *ulpq)\n{\n\tstruct sk_buff *pos, *last_frag, *first_frag;\n\tstruct sctp_ulpevent *cevent;\n\t__u32 ctsn, next_tsn;\n\tint is_last;\n\tstruct sctp_ulpevent *retval;\n\n\t \n\n\tif (skb_queue_empty(&ulpq->reasm))\n\t\treturn NULL;\n\n\tlast_frag = first_frag = NULL;\n\tretval = NULL;\n\tnext_tsn = 0;\n\tis_last = 0;\n\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_FIRST_FRAG:\n\t\t\tif (!first_frag)\n\t\t\t\treturn NULL;\n\t\t\tgoto done;\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif (!first_frag) {\n\t\t\t\tfirst_frag = pos;\n\t\t\t\tnext_tsn = ctsn + 1;\n\t\t\t\tlast_frag = pos;\n\t\t\t} else if (next_tsn == ctsn) {\n\t\t\t\tnext_tsn++;\n\t\t\t\tlast_frag = pos;\n\t\t\t} else\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (!first_frag)\n\t\t\t\tfirst_frag = pos;\n\t\t\telse if (ctsn != next_tsn)\n\t\t\t\tgoto done;\n\t\t\tlast_frag = pos;\n\t\t\tis_last = 1;\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t \ndone:\n\tretval = sctp_make_reassembled_event(ulpq->asoc->base.net, &ulpq->reasm,\n\t\t\t\t\t     first_frag, last_frag);\n\tif (retval && is_last)\n\t\tretval->msg_flags |= MSG_EOR;\n\n\treturn retval;\n}\n\n\n \nstatic struct sctp_ulpevent *sctp_ulpq_reasm(struct sctp_ulpq *ulpq,\n\t\t\t\t\t\tstruct sctp_ulpevent *event)\n{\n\tstruct sctp_ulpevent *retval = NULL;\n\n\t \n\tif (SCTP_DATA_NOT_FRAG == (event->msg_flags & SCTP_DATA_FRAG_MASK)) {\n\t\tevent->msg_flags |= MSG_EOR;\n\t\treturn event;\n\t}\n\n\tsctp_ulpq_store_reasm(ulpq, event);\n\tif (!ulpq->pd_mode)\n\t\tretval = sctp_ulpq_retrieve_reassembled(ulpq);\n\telse {\n\t\t__u32 ctsn, ctsnap;\n\n\t\t \n\t\tctsn = event->tsn;\n\t\tctsnap = sctp_tsnmap_get_ctsn(&ulpq->asoc->peer.tsn_map);\n\t\tif (TSN_lte(ctsn, ctsnap))\n\t\t\tretval = sctp_ulpq_retrieve_partial(ulpq);\n\t}\n\n\treturn retval;\n}\n\n \nstatic struct sctp_ulpevent *sctp_ulpq_retrieve_first(struct sctp_ulpq *ulpq)\n{\n\tstruct sk_buff *pos, *last_frag, *first_frag;\n\tstruct sctp_ulpevent *cevent;\n\t__u32 ctsn, next_tsn;\n\tstruct sctp_ulpevent *retval;\n\n\t \n\n\tif (skb_queue_empty(&ulpq->reasm))\n\t\treturn NULL;\n\n\tlast_frag = first_frag = NULL;\n\tretval = NULL;\n\tnext_tsn = 0;\n\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\t\tctsn = cevent->tsn;\n\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_FIRST_FRAG:\n\t\t\tif (!first_frag) {\n\t\t\t\tfirst_frag = pos;\n\t\t\t\tnext_tsn = ctsn + 1;\n\t\t\t\tlast_frag = pos;\n\t\t\t} else\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif (!first_frag)\n\t\t\t\treturn NULL;\n\t\t\tif (ctsn == next_tsn) {\n\t\t\t\tnext_tsn++;\n\t\t\t\tlast_frag = pos;\n\t\t\t} else\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (!first_frag)\n\t\t\t\treturn NULL;\n\t\t\telse\n\t\t\t\tgoto done;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t \ndone:\n\tretval = sctp_make_reassembled_event(ulpq->asoc->base.net, &ulpq->reasm,\n\t\t\t\t\t     first_frag, last_frag);\n\treturn retval;\n}\n\n \nvoid sctp_ulpq_reasm_flushtsn(struct sctp_ulpq *ulpq, __u32 fwd_tsn)\n{\n\tstruct sk_buff *pos, *tmp;\n\tstruct sctp_ulpevent *event;\n\t__u32 tsn;\n\n\tif (skb_queue_empty(&ulpq->reasm))\n\t\treturn;\n\n\tskb_queue_walk_safe(&ulpq->reasm, pos, tmp) {\n\t\tevent = sctp_skb2event(pos);\n\t\ttsn = event->tsn;\n\n\t\t \n\t\tif (TSN_lte(tsn, fwd_tsn)) {\n\t\t\t__skb_unlink(pos, &ulpq->reasm);\n\t\t\tsctp_ulpevent_free(event);\n\t\t} else\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void sctp_ulpq_reasm_drain(struct sctp_ulpq *ulpq)\n{\n\tstruct sctp_ulpevent *event = NULL;\n\n\tif (skb_queue_empty(&ulpq->reasm))\n\t\treturn;\n\n\twhile ((event = sctp_ulpq_retrieve_reassembled(ulpq)) != NULL) {\n\t\tstruct sk_buff_head temp;\n\n\t\tskb_queue_head_init(&temp);\n\t\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\n\t\t \n\t\tif (event->msg_flags & MSG_EOR)\n\t\t\tevent = sctp_ulpq_order(ulpq, event);\n\n\t\t \n\t\tif (event)\n\t\t\tsctp_ulpq_tail_event(ulpq, &temp);\n\t}\n}\n\n\n \nstatic void sctp_ulpq_retrieve_ordered(struct sctp_ulpq *ulpq,\n\t\t\t\t\t      struct sctp_ulpevent *event)\n{\n\tstruct sk_buff_head *event_list;\n\tstruct sk_buff *pos, *tmp;\n\tstruct sctp_ulpevent *cevent;\n\tstruct sctp_stream *stream;\n\t__u16 sid, csid, cssn;\n\n\tsid = event->stream;\n\tstream  = &ulpq->asoc->stream;\n\n\tevent_list = (struct sk_buff_head *) sctp_event2skb(event)->prev;\n\n\t \n\tsctp_skb_for_each(pos, &ulpq->lobby, tmp) {\n\t\tcevent = (struct sctp_ulpevent *) pos->cb;\n\t\tcsid = cevent->stream;\n\t\tcssn = cevent->ssn;\n\n\t\t \n\t\tif (csid > sid)\n\t\t\tbreak;\n\n\t\t \n\t\tif (csid < sid)\n\t\t\tcontinue;\n\n\t\tif (cssn != sctp_ssn_peek(stream, in, sid))\n\t\t\tbreak;\n\n\t\t \n\t\tsctp_ssn_next(stream, in, sid);\n\n\t\t__skb_unlink(pos, &ulpq->lobby);\n\n\t\t \n\t\t__skb_queue_tail(event_list, pos);\n\t}\n}\n\n \nstatic void sctp_ulpq_store_ordered(struct sctp_ulpq *ulpq,\n\t\t\t\t\t   struct sctp_ulpevent *event)\n{\n\tstruct sk_buff *pos;\n\tstruct sctp_ulpevent *cevent;\n\t__u16 sid, csid;\n\t__u16 ssn, cssn;\n\n\tpos = skb_peek_tail(&ulpq->lobby);\n\tif (!pos) {\n\t\t__skb_queue_tail(&ulpq->lobby, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\tsid = event->stream;\n\tssn = event->ssn;\n\n\tcevent = (struct sctp_ulpevent *) pos->cb;\n\tcsid = cevent->stream;\n\tcssn = cevent->ssn;\n\tif (sid > csid) {\n\t\t__skb_queue_tail(&ulpq->lobby, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\tif ((sid == csid) && SSN_lt(cssn, ssn)) {\n\t\t__skb_queue_tail(&ulpq->lobby, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\t \n\tskb_queue_walk(&ulpq->lobby, pos) {\n\t\tcevent = (struct sctp_ulpevent *) pos->cb;\n\t\tcsid = cevent->stream;\n\t\tcssn = cevent->ssn;\n\n\t\tif (csid > sid)\n\t\t\tbreak;\n\t\tif (csid == sid && SSN_lt(ssn, cssn))\n\t\t\tbreak;\n\t}\n\n\n\t \n\t__skb_queue_before(&ulpq->lobby, pos, sctp_event2skb(event));\n}\n\nstatic struct sctp_ulpevent *sctp_ulpq_order(struct sctp_ulpq *ulpq,\n\t\t\t\t\t     struct sctp_ulpevent *event)\n{\n\t__u16 sid, ssn;\n\tstruct sctp_stream *stream;\n\n\t \n\tif (event->msg_flags & SCTP_DATA_UNORDERED)\n\t\treturn event;\n\n\t \n\tsid = event->stream;\n\tssn = event->ssn;\n\tstream  = &ulpq->asoc->stream;\n\n\t \n\tif (ssn != sctp_ssn_peek(stream, in, sid)) {\n\t\t \n\t\tsctp_ulpq_store_ordered(ulpq, event);\n\t\treturn NULL;\n\t}\n\n\t \n\tsctp_ssn_next(stream, in, sid);\n\n\t \n\tsctp_ulpq_retrieve_ordered(ulpq, event);\n\n\treturn event;\n}\n\n \nstatic void sctp_ulpq_reap_ordered(struct sctp_ulpq *ulpq, __u16 sid)\n{\n\tstruct sk_buff *pos, *tmp;\n\tstruct sctp_ulpevent *cevent;\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_stream *stream;\n\tstruct sk_buff_head temp;\n\tstruct sk_buff_head *lobby = &ulpq->lobby;\n\t__u16 csid, cssn;\n\n\tstream = &ulpq->asoc->stream;\n\n\t \n\tskb_queue_head_init(&temp);\n\tevent = NULL;\n\tsctp_skb_for_each(pos, lobby, tmp) {\n\t\tcevent = (struct sctp_ulpevent *) pos->cb;\n\t\tcsid = cevent->stream;\n\t\tcssn = cevent->ssn;\n\n\t\t \n\t\tif (csid > sid)\n\t\t\tbreak;\n\n\t\t \n\t\tif (csid < sid)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!SSN_lt(cssn, sctp_ssn_peek(stream, in, csid)))\n\t\t\tbreak;\n\n\t\t__skb_unlink(pos, lobby);\n\t\tif (!event)\n\t\t\t \n\t\t\tevent = sctp_skb2event(pos);\n\n\t\t \n\t\t__skb_queue_tail(&temp, pos);\n\t}\n\n\t \n\tif (event == NULL && pos != (struct sk_buff *)lobby) {\n\t\tcevent = (struct sctp_ulpevent *) pos->cb;\n\t\tcsid = cevent->stream;\n\t\tcssn = cevent->ssn;\n\n\t\tif (csid == sid && cssn == sctp_ssn_peek(stream, in, csid)) {\n\t\t\tsctp_ssn_next(stream, in, csid);\n\t\t\t__skb_unlink(pos, lobby);\n\t\t\t__skb_queue_tail(&temp, pos);\n\t\t\tevent = sctp_skb2event(pos);\n\t\t}\n\t}\n\n\t \n\tif (event) {\n\t\t \n\t\tsctp_ulpq_retrieve_ordered(ulpq, event);\n\t\tsctp_ulpq_tail_event(ulpq, &temp);\n\t}\n}\n\n \nvoid sctp_ulpq_skip(struct sctp_ulpq *ulpq, __u16 sid, __u16 ssn)\n{\n\tstruct sctp_stream *stream;\n\n\t \n\tstream  = &ulpq->asoc->stream;\n\n\t \n\tif (SSN_lt(ssn, sctp_ssn_peek(stream, in, sid)))\n\t\treturn;\n\n\t \n\tsctp_ssn_skip(stream, in, sid, ssn);\n\n\t \n\tsctp_ulpq_reap_ordered(ulpq, sid);\n}\n\n__u16 sctp_ulpq_renege_list(struct sctp_ulpq *ulpq, struct sk_buff_head *list,\n\t\t\t    __u16 needed)\n{\n\t__u16 freed = 0;\n\t__u32 tsn, last_tsn;\n\tstruct sk_buff *skb, *flist, *last;\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_tsnmap *tsnmap;\n\n\ttsnmap = &ulpq->asoc->peer.tsn_map;\n\n\twhile ((skb = skb_peek_tail(list)) != NULL) {\n\t\tevent = sctp_skb2event(skb);\n\t\ttsn = event->tsn;\n\n\t\t \n\t\tif (TSN_lte(tsn, sctp_tsnmap_get_ctsn(tsnmap)))\n\t\t\tbreak;\n\n\t\t \n\t\tfreed += skb_headlen(skb);\n\t\tflist = skb_shinfo(skb)->frag_list;\n\t\tfor (last = flist; flist; flist = flist->next) {\n\t\t\tlast = flist;\n\t\t\tfreed += skb_headlen(last);\n\t\t}\n\t\tif (last)\n\t\t\tlast_tsn = sctp_skb2event(last)->tsn;\n\t\telse\n\t\t\tlast_tsn = tsn;\n\n\t\t \n\t\t__skb_unlink(skb, list);\n\t\tsctp_ulpevent_free(event);\n\t\twhile (TSN_lte(tsn, last_tsn)) {\n\t\t\tsctp_tsnmap_renege(tsnmap, tsn);\n\t\t\ttsn++;\n\t\t}\n\t\tif (freed >= needed)\n\t\t\treturn freed;\n\t}\n\n\treturn freed;\n}\n\n \nstatic __u16 sctp_ulpq_renege_order(struct sctp_ulpq *ulpq, __u16 needed)\n{\n\treturn sctp_ulpq_renege_list(ulpq, &ulpq->lobby, needed);\n}\n\n \nstatic __u16 sctp_ulpq_renege_frags(struct sctp_ulpq *ulpq, __u16 needed)\n{\n\treturn sctp_ulpq_renege_list(ulpq, &ulpq->reasm, needed);\n}\n\n \nvoid sctp_ulpq_partial_delivery(struct sctp_ulpq *ulpq,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_association *asoc;\n\tstruct sctp_sock *sp;\n\t__u32 ctsn;\n\tstruct sk_buff *skb;\n\n\tasoc = ulpq->asoc;\n\tsp = sctp_sk(asoc->base.sk);\n\n\t \n\tif (ulpq->pd_mode)\n\t\treturn;\n\n\t \n\tskb = skb_peek(&asoc->ulpq.reasm);\n\tif (skb != NULL) {\n\t\tctsn = sctp_skb2event(skb)->tsn;\n\t\tif (!TSN_lte(ctsn, sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map)))\n\t\t\treturn;\n\t}\n\n\t \n\tif (sp->frag_interleave || atomic_read(&sp->pd_mode) == 0) {\n\t\t \n\t\tevent = sctp_ulpq_retrieve_first(ulpq);\n\t\t \n\t\tif (event) {\n\t\t\tstruct sk_buff_head temp;\n\n\t\t\tskb_queue_head_init(&temp);\n\t\t\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\t\t\tsctp_ulpq_tail_event(ulpq, &temp);\n\t\t\tsctp_ulpq_set_pd(ulpq);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nvoid sctp_ulpq_renege(struct sctp_ulpq *ulpq, struct sctp_chunk *chunk,\n\t\t      gfp_t gfp)\n{\n\tstruct sctp_association *asoc = ulpq->asoc;\n\t__u32 freed = 0;\n\t__u16 needed;\n\n\tneeded = ntohs(chunk->chunk_hdr->length) -\n\t\t sizeof(struct sctp_data_chunk);\n\n\tif (skb_queue_empty(&asoc->base.sk->sk_receive_queue)) {\n\t\tfreed = sctp_ulpq_renege_order(ulpq, needed);\n\t\tif (freed < needed)\n\t\t\tfreed += sctp_ulpq_renege_frags(ulpq, needed - freed);\n\t}\n\t \n\tif (sk_rmem_schedule(asoc->base.sk, chunk->skb, needed) &&\n\t    freed >= needed) {\n\t\tint retval = sctp_ulpq_tail_data(ulpq, chunk, gfp);\n\t\t \n\t\tif (retval <= 0)\n\t\t\tsctp_ulpq_partial_delivery(ulpq, gfp);\n\t\telse if (retval == 1)\n\t\t\tsctp_ulpq_reasm_drain(ulpq);\n\t}\n}\n\n \nvoid sctp_ulpq_abort_pd(struct sctp_ulpq *ulpq, gfp_t gfp)\n{\n\tstruct sctp_ulpevent *ev = NULL;\n\tstruct sctp_sock *sp;\n\tstruct sock *sk;\n\n\tif (!ulpq->pd_mode)\n\t\treturn;\n\n\tsk = ulpq->asoc->base.sk;\n\tsp = sctp_sk(sk);\n\tif (sctp_ulpevent_type_enabled(ulpq->asoc->subscribe,\n\t\t\t\t       SCTP_PARTIAL_DELIVERY_EVENT))\n\t\tev = sctp_ulpevent_make_pdapi(ulpq->asoc,\n\t\t\t\t\t      SCTP_PARTIAL_DELIVERY_ABORTED,\n\t\t\t\t\t      0, 0, 0, gfp);\n\tif (ev)\n\t\t__skb_queue_tail(&sk->sk_receive_queue, sctp_event2skb(ev));\n\n\t \n\tif ((sctp_ulpq_clear_pd(ulpq) || ev) && !sp->data_ready_signalled) {\n\t\tsp->data_ready_signalled = 1;\n\t\tsk->sk_data_ready(sk);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}