{
  "module_name": "sm_sideeffect.c",
  "hash_id": "fd684e8eff106e0da1d886cde8b0342b0944d2f2267aa40ac7ca066def42fd86",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/sm_sideeffect.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/skbuff.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <net/sock.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/stream_sched.h>\n\nstatic int sctp_cmd_interpreter(enum sctp_event_type event_type,\n\t\t\t\tunion sctp_subtype subtype,\n\t\t\t\tenum sctp_state state,\n\t\t\t\tstruct sctp_endpoint *ep,\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tvoid *event_arg,\n\t\t\t\tenum sctp_disposition status,\n\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\tgfp_t gfp);\nstatic int sctp_side_effects(enum sctp_event_type event_type,\n\t\t\t     union sctp_subtype subtype,\n\t\t\t     enum sctp_state state,\n\t\t\t     struct sctp_endpoint *ep,\n\t\t\t     struct sctp_association **asoc,\n\t\t\t     void *event_arg,\n\t\t\t     enum sctp_disposition status,\n\t\t\t     struct sctp_cmd_seq *commands,\n\t\t\t     gfp_t gfp);\n\n \n\n \nstatic void sctp_do_ecn_ce_work(struct sctp_association *asoc,\n\t\t\t\t__u32 lowest_tsn)\n{\n\t \n\n\tasoc->last_ecne_tsn = lowest_tsn;\n\tasoc->need_ecne = 1;\n}\n\n \n \nstatic struct sctp_chunk *sctp_do_ecn_ecne_work(struct sctp_association *asoc,\n\t\t\t\t\t\t__u32 lowest_tsn,\n\t\t\t\t\t\tstruct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *repl;\n\n\t \n\n\t \n\tif (TSN_lt(asoc->last_cwr_tsn, lowest_tsn)) {\n\t\tstruct sctp_transport *transport;\n\n\t\t \n\t\ttransport = sctp_assoc_lookup_tsn(asoc, lowest_tsn);\n\n\t\t \n\t\tif (transport)\n\t\t\tsctp_transport_lower_cwnd(transport,\n\t\t\t\t\t\t  SCTP_LOWER_CWND_ECNE);\n\t\tasoc->last_cwr_tsn = lowest_tsn;\n\t}\n\n\t \n\trepl = sctp_make_cwr(asoc, asoc->last_cwr_tsn, chunk);\n\n\t \n\treturn repl;\n}\n\n \nstatic void sctp_do_ecn_cwr_work(struct sctp_association *asoc,\n\t\t\t\t __u32 lowest_tsn)\n{\n\t \n\tasoc->need_ecne = 0;\n}\n\n \nstatic int sctp_gen_sack(struct sctp_association *asoc, int force,\n\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *trans = asoc->peer.last_data_from;\n\t__u32 ctsn, max_tsn_seen;\n\tstruct sctp_chunk *sack;\n\tint error = 0;\n\n\tif (force ||\n\t    (!trans && (asoc->param_flags & SPP_SACKDELAY_DISABLE)) ||\n\t    (trans && (trans->param_flags & SPP_SACKDELAY_DISABLE)))\n\t\tasoc->peer.sack_needed = 1;\n\n\tctsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map);\n\tmax_tsn_seen = sctp_tsnmap_get_max_tsn_seen(&asoc->peer.tsn_map);\n\n\t \n\tif (max_tsn_seen != ctsn)\n\t\tasoc->peer.sack_needed = 1;\n\n\t \n\tif (!asoc->peer.sack_needed) {\n\t\tasoc->peer.sack_cnt++;\n\n\t\t \n\t\tif (trans) {\n\t\t\t \n\t\t\tif (asoc->peer.sack_cnt >= trans->sackfreq - 1)\n\t\t\t\tasoc->peer.sack_needed = 1;\n\n\t\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] =\n\t\t\t\ttrans->sackdelay;\n\t\t} else {\n\t\t\t \n\t\t\tif (asoc->peer.sack_cnt >= asoc->sackfreq - 1)\n\t\t\t\tasoc->peer.sack_needed = 1;\n\n\t\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] =\n\t\t\t\tasoc->sackdelay;\n\t\t}\n\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\t} else {\n\t\t__u32 old_a_rwnd = asoc->a_rwnd;\n\n\t\tasoc->a_rwnd = asoc->rwnd;\n\t\tsack = sctp_make_sack(asoc);\n\t\tif (!sack) {\n\t\t\tasoc->a_rwnd = old_a_rwnd;\n\t\t\tgoto nomem;\n\t\t}\n\n\t\tasoc->peer.sack_needed = 0;\n\t\tasoc->peer.sack_cnt = 0;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(sack));\n\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\t}\n\n\treturn error;\nnomem:\n\terror = -ENOMEM;\n\treturn error;\n}\n\n \nvoid sctp_generate_t3_rtx_event(struct timer_list *t)\n{\n\tstruct sctp_transport *transport =\n\t\tfrom_timer(transport, t, T3_rtx_timer);\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tint error;\n\n\t \n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t \n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tsk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_transport_put(transport);\n}\n\n \nstatic void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tenum sctp_event_timeout timeout_type)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tint error = 0;\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\n\t\t \n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\t \n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\n\tif (error)\n\t\tsk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_association_put(asoc);\n}\n\nstatic void sctp_generate_t1_cookie_event(struct timer_list *t)\n{\n\tstruct sctp_association *asoc =\n\t\tfrom_timer(asoc, t, timers[SCTP_EVENT_TIMEOUT_T1_COOKIE]);\n\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T1_COOKIE);\n}\n\nstatic void sctp_generate_t1_init_event(struct timer_list *t)\n{\n\tstruct sctp_association *asoc =\n\t\tfrom_timer(asoc, t, timers[SCTP_EVENT_TIMEOUT_T1_INIT]);\n\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T1_INIT);\n}\n\nstatic void sctp_generate_t2_shutdown_event(struct timer_list *t)\n{\n\tstruct sctp_association *asoc =\n\t\tfrom_timer(asoc, t, timers[SCTP_EVENT_TIMEOUT_T2_SHUTDOWN]);\n\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T2_SHUTDOWN);\n}\n\nstatic void sctp_generate_t4_rto_event(struct timer_list *t)\n{\n\tstruct sctp_association *asoc =\n\t\tfrom_timer(asoc, t, timers[SCTP_EVENT_TIMEOUT_T4_RTO]);\n\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T4_RTO);\n}\n\nstatic void sctp_generate_t5_shutdown_guard_event(struct timer_list *t)\n{\n\tstruct sctp_association *asoc =\n\t\tfrom_timer(asoc, t,\n\t\t\t   timers[SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD]);\n\n\tsctp_generate_timeout_event(asoc,\n\t\t\t\t    SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD);\n\n}  \n\nstatic void sctp_generate_autoclose_event(struct timer_list *t)\n{\n\tstruct sctp_association *asoc =\n\t\tfrom_timer(asoc, t, timers[SCTP_EVENT_TIMEOUT_AUTOCLOSE]);\n\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_AUTOCLOSE);\n}\n\n \nvoid sctp_generate_heartbeat_event(struct timer_list *t)\n{\n\tstruct sctp_transport *transport = from_timer(transport, t, hb_timer);\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tu32 elapsed, timeout;\n\tint error = 0;\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t \n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\telapsed = jiffies - transport->last_time_sent;\n\ttimeout = sctp_transport_timeout(transport);\n\tif (elapsed < timeout) {\n\t\telapsed = timeout - elapsed;\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + elapsed))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tsk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_transport_put(transport);\n}\n\n \nvoid sctp_generate_proto_unreach_event(struct timer_list *t)\n{\n\tstruct sctp_transport *transport =\n\t\tfrom_timer(transport, t, proto_unreach_timer);\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t \n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_transport_put(transport);\n}\n\n  \nvoid sctp_generate_reconf_event(struct timer_list *t)\n{\n\tstruct sctp_transport *transport =\n\t\tfrom_timer(transport, t, reconf_timer);\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tint error = 0;\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t \n\t\tif (!mod_timer(&transport->reconf_timer, jiffies + (HZ / 20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (!asoc->strreset_chunk)\n\t\tgoto out_unlock;\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_RECONF),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tsk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_transport_put(transport);\n}\n\n \nvoid sctp_generate_probe_event(struct timer_list *t)\n{\n\tstruct sctp_transport *transport = from_timer(transport, t, probe_timer);\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tint error = 0;\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\t \n\t\tif (!mod_timer(&transport->probe_timer, jiffies + (HZ / 20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_PROBE),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tsk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_transport_put(transport);\n}\n\n \nstatic void sctp_generate_sack_event(struct timer_list *t)\n{\n\tstruct sctp_association *asoc =\n\t\tfrom_timer(asoc, t, timers[SCTP_EVENT_TIMEOUT_SACK]);\n\n\tsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_SACK);\n}\n\nsctp_timer_event_t *sctp_timer_events[SCTP_NUM_TIMEOUT_TYPES] = {\n\t[SCTP_EVENT_TIMEOUT_NONE] =\t\tNULL,\n\t[SCTP_EVENT_TIMEOUT_T1_COOKIE] =\tsctp_generate_t1_cookie_event,\n\t[SCTP_EVENT_TIMEOUT_T1_INIT] =\t\tsctp_generate_t1_init_event,\n\t[SCTP_EVENT_TIMEOUT_T2_SHUTDOWN] =\tsctp_generate_t2_shutdown_event,\n\t[SCTP_EVENT_TIMEOUT_T3_RTX] =\t\tNULL,\n\t[SCTP_EVENT_TIMEOUT_T4_RTO] =\t\tsctp_generate_t4_rto_event,\n\t[SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD] =\n\t\t\t\t\tsctp_generate_t5_shutdown_guard_event,\n\t[SCTP_EVENT_TIMEOUT_HEARTBEAT] =\tNULL,\n\t[SCTP_EVENT_TIMEOUT_RECONF] =\t\tNULL,\n\t[SCTP_EVENT_TIMEOUT_SACK] =\t\tsctp_generate_sack_event,\n\t[SCTP_EVENT_TIMEOUT_AUTOCLOSE] =\tsctp_generate_autoclose_event,\n};\n\n\n \nstatic void sctp_do_8_2_transport_strike(struct sctp_cmd_seq *commands,\n\t\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t\t struct sctp_transport *transport,\n\t\t\t\t\t int is_hb)\n{\n\t \n\t \n\tif (!is_hb) {\n\t\tasoc->overall_error_count++;\n\t\tif (transport->state != SCTP_INACTIVE)\n\t\t\ttransport->error_count++;\n\t } else if (transport->hb_sent) {\n\t\tif (transport->state != SCTP_UNCONFIRMED)\n\t\t\tasoc->overall_error_count++;\n\t\tif (transport->state != SCTP_INACTIVE)\n\t\t\ttransport->error_count++;\n\t}\n\n\t \n\tif (asoc->base.net->sctp.pf_enable &&\n\t    transport->state == SCTP_ACTIVE &&\n\t    transport->error_count < transport->pathmaxrxt &&\n\t    transport->error_count > transport->pf_retrans) {\n\n\t\tsctp_assoc_control_transport(asoc, transport,\n\t\t\t\t\t     SCTP_TRANSPORT_PF,\n\t\t\t\t\t     0);\n\n\t\t \n\t\tsctp_transport_reset_hb_timer(transport);\n\t}\n\n\tif (transport->state != SCTP_INACTIVE &&\n\t    (transport->error_count > transport->pathmaxrxt)) {\n\t\tpr_debug(\"%s: association:%p transport addr:%pISpc failed\\n\",\n\t\t\t __func__, asoc, &transport->ipaddr.sa);\n\n\t\tsctp_assoc_control_transport(asoc, transport,\n\t\t\t\t\t     SCTP_TRANSPORT_DOWN,\n\t\t\t\t\t     SCTP_FAILED_THRESHOLD);\n\t}\n\n\tif (transport->error_count > transport->ps_retrans &&\n\t    asoc->peer.primary_path == transport &&\n\t    asoc->peer.active_path != transport)\n\t\tsctp_assoc_set_primary(asoc, asoc->peer.active_path);\n\n\t \n\tif (!is_hb || transport->hb_sent) {\n\t\ttransport->rto = min((transport->rto * 2), transport->asoc->rto_max);\n\t\tsctp_max_rto(asoc, transport);\n\t}\n}\n\n \nstatic void sctp_cmd_init_failed(struct sctp_cmd_seq *commands,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t unsigned int error)\n{\n\tstruct sctp_ulpevent *event;\n\n\tevent = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_CANT_STR_ASSOC,\n\t\t\t\t\t\t(__u16)error, 0, 0, NULL,\n\t\t\t\t\t\tGFP_ATOMIC);\n\n\tif (event)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(event));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\t \n\tasoc->outqueue.error = error;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n}\n\n \nstatic void sctp_cmd_assoc_failed(struct sctp_cmd_seq *commands,\n\t\t\t\t  struct sctp_association *asoc,\n\t\t\t\t  enum sctp_event_type event_type,\n\t\t\t\t  union sctp_subtype subtype,\n\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t  unsigned int error)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sctp_chunk *abort;\n\n\t \n\tasoc->stream.si->abort_pd(&asoc->ulpq, GFP_ATOMIC);\n\n\tif (event_type == SCTP_EVENT_T_CHUNK && subtype.chunk == SCTP_CID_ABORT)\n\t\tevent = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_LOST,\n\t\t\t\t\t\t(__u16)error, 0, 0, chunk,\n\t\t\t\t\t\tGFP_ATOMIC);\n\telse\n\t\tevent = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_LOST,\n\t\t\t\t\t\t(__u16)error, 0, 0, NULL,\n\t\t\t\t\t\tGFP_ATOMIC);\n\tif (event)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(event));\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tabort = sctp_make_violation_max_retrans(asoc, chunk);\n\t\tif (abort)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\t \n\tasoc->outqueue.error = error;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n}\n\n \nstatic int sctp_cmd_process_init(struct sctp_cmd_seq *commands,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t struct sctp_chunk *chunk,\n\t\t\t\t struct sctp_init_chunk *peer_init,\n\t\t\t\t gfp_t gfp)\n{\n\tint error;\n\n\t \n\tif (!sctp_process_init(asoc, chunk, sctp_source(chunk), peer_init, gfp))\n\t\terror = -ENOMEM;\n\telse\n\t\terror = 0;\n\n\treturn error;\n}\n\n \nstatic void sctp_cmd_hb_timers_start(struct sctp_cmd_seq *cmds,\n\t\t\t\t     struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\n\t \n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list, transports)\n\t\tsctp_transport_reset_hb_timer(t);\n}\n\nstatic void sctp_cmd_hb_timers_stop(struct sctp_cmd_seq *cmds,\n\t\t\t\t    struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\n\t \n\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\tif (del_timer(&t->hb_timer))\n\t\t\tsctp_transport_put(t);\n\t}\n}\n\n \nstatic void sctp_cmd_t3_rtx_timers_stop(struct sctp_cmd_seq *cmds,\n\t\t\t\t\tstruct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\tif (del_timer(&t->T3_rtx_timer))\n\t\t\tsctp_transport_put(t);\n\t}\n}\n\n\n \nstatic void sctp_cmd_transport_on(struct sctp_cmd_seq *cmds,\n\t\t\t\t  struct sctp_association *asoc,\n\t\t\t\t  struct sctp_transport *t,\n\t\t\t\t  struct sctp_chunk *chunk)\n{\n\tstruct sctp_sender_hb_info *hbinfo;\n\tint was_unconfirmed = 0;\n\n\t \n\tt->error_count = 0;\n\n\t \n\tif (t->asoc->state < SCTP_STATE_SHUTDOWN_PENDING)\n\t\tt->asoc->overall_error_count = 0;\n\n\t \n\tt->hb_sent = 0;\n\n\t \n\tif ((t->state == SCTP_INACTIVE) || (t->state == SCTP_UNCONFIRMED)) {\n\t\twas_unconfirmed = 1;\n\t\tsctp_assoc_control_transport(asoc, t, SCTP_TRANSPORT_UP,\n\t\t\t\t\t     SCTP_HEARTBEAT_SUCCESS);\n\t}\n\n\tif (t->state == SCTP_PF)\n\t\tsctp_assoc_control_transport(asoc, t, SCTP_TRANSPORT_UP,\n\t\t\t\t\t     SCTP_HEARTBEAT_SUCCESS);\n\n\t \n\tif (t->dst)\n\t\tsctp_transport_dst_confirm(t);\n\n\t \n\tif (t->rto_pending == 0)\n\t\tt->rto_pending = 1;\n\n\thbinfo = (struct sctp_sender_hb_info *)chunk->skb->data;\n\tsctp_transport_update_rto(t, (jiffies - hbinfo->sent_at));\n\n\t \n\tsctp_transport_reset_hb_timer(t);\n\n\tif (was_unconfirmed && asoc->peer.transport_count == 1)\n\t\tsctp_transport_immediate_rtx(t);\n}\n\n\n \nstatic int sctp_cmd_process_sack(struct sctp_cmd_seq *cmds,\n\t\t\t\t struct sctp_association *asoc,\n\t\t\t\t struct sctp_chunk *chunk)\n{\n\tint err = 0;\n\n\tif (sctp_outq_sack(&asoc->outqueue, chunk)) {\n\t\t \n\t\terr = sctp_do_sm(asoc->base.net, SCTP_EVENT_T_OTHER,\n\t\t\t\t SCTP_ST_OTHER(SCTP_EVENT_NO_PENDING_TSN),\n\t\t\t\t asoc->state, asoc->ep, asoc, NULL,\n\t\t\t\t GFP_ATOMIC);\n\t}\n\n\treturn err;\n}\n\n \nstatic void sctp_cmd_setup_t2(struct sctp_cmd_seq *cmds,\n\t\t\t      struct sctp_association *asoc,\n\t\t\t      struct sctp_chunk *chunk)\n{\n\tstruct sctp_transport *t;\n\n\tif (chunk->transport)\n\t\tt = chunk->transport;\n\telse {\n\t\tt = sctp_assoc_choose_alter_transport(asoc,\n\t\t\t\t\t      asoc->shutdown_last_sent_to);\n\t\tchunk->transport = t;\n\t}\n\tasoc->shutdown_last_sent_to = t;\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T2_SHUTDOWN] = t->rto;\n}\n\n \nstatic void sctp_cmd_new_state(struct sctp_cmd_seq *cmds,\n\t\t\t       struct sctp_association *asoc,\n\t\t\t       enum sctp_state state)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\tasoc->state = state;\n\n\tpr_debug(\"%s: asoc:%p[%s]\\n\", __func__, asoc, sctp_state_tbl[state]);\n\n\tif (sctp_style(sk, TCP)) {\n\t\t \n\t\tif (sctp_state(asoc, ESTABLISHED) && sctp_sstate(sk, CLOSED))\n\t\t\tinet_sk_set_state(sk, SCTP_SS_ESTABLISHED);\n\n\t\t \n\t\tif (sctp_state(asoc, SHUTDOWN_RECEIVED) &&\n\t\t    sctp_sstate(sk, ESTABLISHED)) {\n\t\t\tinet_sk_set_state(sk, SCTP_SS_CLOSING);\n\t\t\tsk->sk_shutdown |= RCV_SHUTDOWN;\n\t\t}\n\t}\n\n\tif (sctp_state(asoc, COOKIE_WAIT)) {\n\t\t \n\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_INIT] =\n\t\t\t\t\t\tasoc->rto_initial;\n\t\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_COOKIE] =\n\t\t\t\t\t\tasoc->rto_initial;\n\t}\n\n\tif (sctp_state(asoc, ESTABLISHED)) {\n\t\tkfree(asoc->peer.cookie);\n\t\tasoc->peer.cookie = NULL;\n\t}\n\n\tif (sctp_state(asoc, ESTABLISHED) ||\n\t    sctp_state(asoc, CLOSED) ||\n\t    sctp_state(asoc, SHUTDOWN_RECEIVED)) {\n\t\t \n\t\tif (waitqueue_active(&asoc->wait))\n\t\t\twake_up_interruptible(&asoc->wait);\n\n\t\t \n\t\tif (!sctp_style(sk, UDP))\n\t\t\tsk->sk_state_change(sk);\n\t}\n\n\tif (sctp_state(asoc, SHUTDOWN_PENDING) &&\n\t    !sctp_outq_is_empty(&asoc->outqueue))\n\t\tsctp_outq_uncork(&asoc->outqueue, GFP_ATOMIC);\n}\n\n \nstatic void sctp_cmd_delete_tcb(struct sctp_cmd_seq *cmds,\n\t\t\t\tstruct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\t \n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING) &&\n\t    (!asoc->temp) && (sk->sk_shutdown != SHUTDOWN_MASK))\n\t\treturn;\n\n\tsctp_association_free(asoc);\n}\n\n \nstatic void sctp_cmd_setup_t4(struct sctp_cmd_seq *cmds,\n\t\t\t      struct sctp_association *asoc,\n\t\t\t      struct sctp_chunk *chunk)\n{\n\tstruct sctp_transport *t;\n\n\tt = sctp_assoc_choose_alter_transport(asoc, chunk->transport);\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T4_RTO] = t->rto;\n\tchunk->transport = t;\n}\n\n \nstatic void sctp_cmd_process_operr(struct sctp_cmd_seq *cmds,\n\t\t\t\t   struct sctp_association *asoc,\n\t\t\t\t   struct sctp_chunk *chunk)\n{\n\tstruct sctp_errhdr *err_hdr;\n\tstruct sctp_ulpevent *ev;\n\n\twhile (chunk->chunk_end > chunk->skb->data) {\n\t\terr_hdr = (struct sctp_errhdr *)(chunk->skb->data);\n\n\t\tev = sctp_ulpevent_make_remote_error(asoc, chunk, 0,\n\t\t\t\t\t\t     GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\treturn;\n\n\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, ev);\n\n\t\tswitch (err_hdr->cause) {\n\t\tcase SCTP_ERROR_UNKNOWN_CHUNK:\n\t\t{\n\t\t\tstruct sctp_chunkhdr *unk_chunk_hdr;\n\n\t\t\tunk_chunk_hdr = (struct sctp_chunkhdr *)(err_hdr + 1);\n\t\t\tswitch (unk_chunk_hdr->type) {\n\t\t\t \n\t\t\tcase SCTP_CID_ASCONF:\n\t\t\t\tif (asoc->peer.asconf_capable == 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tasoc->peer.asconf_capable = 0;\n\t\t\t\tsctp_add_cmd_sf(cmds, SCTP_CMD_TIMER_STOP,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void sctp_cmd_del_non_primary(struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\tstruct list_head *temp;\n\tstruct list_head *pos;\n\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\tt = list_entry(pos, struct sctp_transport, transports);\n\t\tif (!sctp_cmp_addr_exact(&t->ipaddr,\n\t\t\t\t\t &asoc->peer.primary_addr)) {\n\t\t\tsctp_assoc_rm_peer(asoc, t);\n\t\t}\n\t}\n}\n\n \nstatic void sctp_cmd_set_sk_err(struct sctp_association *asoc, int error)\n{\n\tstruct sock *sk = asoc->base.sk;\n\n\tif (!sctp_style(sk, UDP))\n\t\tsk->sk_err = error;\n}\n\n \nstatic void sctp_cmd_assoc_change(struct sctp_cmd_seq *commands,\n\t\t\t\t  struct sctp_association *asoc,\n\t\t\t\t  u8 state)\n{\n\tstruct sctp_ulpevent *ev;\n\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, state, 0,\n\t\t\t\t\t    asoc->c.sinit_num_ostreams,\n\t\t\t\t\t    asoc->c.sinit_max_instreams,\n\t\t\t\t\t    NULL, GFP_ATOMIC);\n\tif (ev)\n\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, ev);\n}\n\nstatic void sctp_cmd_peer_no_auth(struct sctp_cmd_seq *commands,\n\t\t\t\t  struct sctp_association *asoc)\n{\n\tstruct sctp_ulpevent *ev;\n\n\tev = sctp_ulpevent_make_authkey(asoc, 0, SCTP_AUTH_NO_AUTH, GFP_ATOMIC);\n\tif (ev)\n\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, ev);\n}\n\n \nstatic void sctp_cmd_adaptation_ind(struct sctp_cmd_seq *commands,\n\t\t\t\t    struct sctp_association *asoc)\n{\n\tstruct sctp_ulpevent *ev;\n\n\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\n\tif (ev)\n\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, ev);\n}\n\n\nstatic void sctp_cmd_t1_timer_update(struct sctp_association *asoc,\n\t\t\t\t     enum sctp_event_timeout timer,\n\t\t\t\t     char *name)\n{\n\tstruct sctp_transport *t;\n\n\tt = asoc->init_last_sent_to;\n\tasoc->init_err_counter++;\n\n\tif (t->init_sent_count > (asoc->init_cycle + 1)) {\n\t\tasoc->timeouts[timer] *= 2;\n\t\tif (asoc->timeouts[timer] > asoc->max_init_timeo) {\n\t\t\tasoc->timeouts[timer] = asoc->max_init_timeo;\n\t\t}\n\t\tasoc->init_cycle++;\n\n\t\tpr_debug(\"%s: T1[%s] timeout adjustment init_err_counter:%d\"\n\t\t\t \" cycle:%d timeout:%ld\\n\", __func__, name,\n\t\t\t asoc->init_err_counter, asoc->init_cycle,\n\t\t\t asoc->timeouts[timer]);\n\t}\n\n}\n\n \nstatic void sctp_cmd_send_msg(struct sctp_association *asoc,\n\t\t\t      struct sctp_datamsg *msg, gfp_t gfp)\n{\n\tstruct sctp_chunk *chunk;\n\n\tlist_for_each_entry(chunk, &msg->chunks, frag_list)\n\t\tsctp_outq_tail(&asoc->outqueue, chunk, gfp);\n\n\tasoc->outqueue.sched->enqueue(&asoc->outqueue, msg);\n}\n\n\n \n#define debug_pre_sfn() \\\n\tpr_debug(\"%s[pre-fn]: ep:%p, %s, %s, asoc:%p[%s], %s\\n\", __func__, \\\n\t\t ep, sctp_evttype_tbl[event_type], (*debug_fn)(subtype),   \\\n\t\t asoc, sctp_state_tbl[state], state_fn->name)\n\n#define debug_post_sfn() \\\n\tpr_debug(\"%s[post-fn]: asoc:%p, status:%s\\n\", __func__, asoc, \\\n\t\t sctp_status_tbl[status])\n\n#define debug_post_sfx() \\\n\tpr_debug(\"%s[post-sfx]: error:%d, asoc:%p[%s]\\n\", __func__, error, \\\n\t\t asoc, sctp_state_tbl[(asoc && sctp_id2assoc(ep->base.sk, \\\n\t\t sctp_assoc2id(asoc))) ? asoc->state : SCTP_STATE_CLOSED])\n\n \nint sctp_do_sm(struct net *net, enum sctp_event_type event_type,\n\t       union sctp_subtype subtype, enum sctp_state state,\n\t       struct sctp_endpoint *ep, struct sctp_association *asoc,\n\t       void *event_arg, gfp_t gfp)\n{\n\ttypedef const char *(printfn_t)(union sctp_subtype);\n\tstatic printfn_t *table[] = {\n\t\tNULL, sctp_cname, sctp_tname, sctp_oname, sctp_pname,\n\t};\n\tprintfn_t *debug_fn  __attribute__ ((unused)) = table[event_type];\n\tconst struct sctp_sm_table_entry *state_fn;\n\tstruct sctp_cmd_seq commands;\n\tenum sctp_disposition status;\n\tint error = 0;\n\n\t \n\tstate_fn = sctp_sm_lookup_event(net, event_type, state, subtype);\n\n\tsctp_init_cmd_seq(&commands);\n\n\tdebug_pre_sfn();\n\tstatus = state_fn->fn(net, ep, asoc, subtype, event_arg, &commands);\n\tdebug_post_sfn();\n\n\terror = sctp_side_effects(event_type, subtype, state,\n\t\t\t\t  ep, &asoc, event_arg, status,\n\t\t\t\t  &commands, gfp);\n\tdebug_post_sfx();\n\n\treturn error;\n}\n\n \nstatic int sctp_side_effects(enum sctp_event_type event_type,\n\t\t\t     union sctp_subtype subtype,\n\t\t\t     enum sctp_state state,\n\t\t\t     struct sctp_endpoint *ep,\n\t\t\t     struct sctp_association **asoc,\n\t\t\t     void *event_arg,\n\t\t\t     enum sctp_disposition status,\n\t\t\t     struct sctp_cmd_seq *commands,\n\t\t\t     gfp_t gfp)\n{\n\tint error;\n\n\t \n\tif (0 != (error = sctp_cmd_interpreter(event_type, subtype, state,\n\t\t\t\t\t       ep, *asoc,\n\t\t\t\t\t       event_arg, status,\n\t\t\t\t\t       commands, gfp)))\n\t\tgoto bail;\n\n\tswitch (status) {\n\tcase SCTP_DISPOSITION_DISCARD:\n\t\tpr_debug(\"%s: ignored sctp protocol event - state:%d, \"\n\t\t\t \"event_type:%d, event_id:%d\\n\", __func__, state,\n\t\t\t event_type, subtype.chunk);\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_NOMEM:\n\t\t \n\t\t \n\t\terror = -ENOMEM;\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_DELETE_TCB:\n\tcase SCTP_DISPOSITION_ABORT:\n\t\t \n\t\t*asoc = NULL;\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_CONSUME:\n\t\t \n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_VIOLATION:\n\t\tnet_err_ratelimited(\"protocol violation state %d chunkid %d\\n\",\n\t\t\t\t    state, subtype.chunk);\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_NOT_IMPL:\n\t\tpr_warn(\"unimplemented feature in state %d, event_type %d, event_id %d\\n\",\n\t\t\tstate, event_type, subtype.chunk);\n\t\tbreak;\n\n\tcase SCTP_DISPOSITION_BUG:\n\t\tpr_err(\"bug in state %d, event_type %d, event_id %d\\n\",\n\t\t       state, event_type, subtype.chunk);\n\t\tBUG();\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"impossible disposition %d in state %d, event_type %d, event_id %d\\n\",\n\t\t       status, state, event_type, subtype.chunk);\n\t\terror = status;\n\t\tif (error >= 0)\n\t\t\terror = -EINVAL;\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\nbail:\n\treturn error;\n}\n\n \n\n \nstatic int sctp_cmd_interpreter(enum sctp_event_type event_type,\n\t\t\t\tunion sctp_subtype subtype,\n\t\t\t\tenum sctp_state state,\n\t\t\t\tstruct sctp_endpoint *ep,\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tvoid *event_arg,\n\t\t\t\tenum sctp_disposition status,\n\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct sctp_sock *sp = sctp_sk(ep->base.sk);\n\tstruct sctp_chunk *chunk = NULL, *new_obj;\n\tstruct sctp_packet *packet;\n\tstruct sctp_sackhdr sackh;\n\tstruct timer_list *timer;\n\tstruct sctp_transport *t;\n\tunsigned long timeout;\n\tstruct sctp_cmd *cmd;\n\tint local_cork = 0;\n\tint error = 0;\n\tint force;\n\n\tif (SCTP_EVENT_T_TIMEOUT != event_type)\n\t\tchunk = event_arg;\n\n\t \n\twhile (NULL != (cmd = sctp_next_cmd(commands))) {\n\t\tswitch (cmd->verb) {\n\t\tcase SCTP_CMD_NOP:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_NEW_ASOC:\n\t\t\t \n\t\t\tif (local_cork) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tasoc = cmd->obj.asoc;\n\t\t\tBUG_ON(asoc->peer.primary_path == NULL);\n\t\t\tsctp_endpoint_add_asoc(ep, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PURGE_OUTQUEUE:\n\t\t       sctp_outq_teardown(&asoc->outqueue);\n\t\t       break;\n\n\t\tcase SCTP_CMD_DELETE_TCB:\n\t\t\tif (local_cork) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\t\t\t \n\t\t\tsctp_cmd_delete_tcb(commands, asoc);\n\t\t\tasoc = NULL;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_NEW_STATE:\n\t\t\t \n\t\t\tsctp_cmd_new_state(commands, asoc, cmd->obj.state);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_TSN:\n\t\t\t \n\t\t\terror = sctp_tsnmap_mark(&asoc->peer.tsn_map,\n\t\t\t\t\t\t cmd->obj.u32, NULL);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_FWDTSN:\n\t\t\tasoc->stream.si->report_ftsn(&asoc->ulpq, cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_FWDTSN:\n\t\t\tasoc->stream.si->handle_ftsn(&asoc->ulpq,\n\t\t\t\t\t\t     cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_SACK:\n\t\t\t \n\t\t\tforce = cmd->obj.i32;\n\t\t\terror = sctp_gen_sack(asoc, force, commands);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_SACK:\n\t\t\t \n\t\t\terror = sctp_cmd_process_sack(commands, asoc,\n\t\t\t\t\t\t      cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_INIT_ACK:\n\t\t\t \n\t\t\tnew_obj = sctp_make_init_ack(asoc, chunk, GFP_ATOMIC,\n\t\t\t\t\t\t     0);\n\t\t\tif (!new_obj) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(new_obj));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PEER_INIT:\n\t\t\t \n\t\t\terror = sctp_cmd_process_init(commands, asoc, chunk,\n\t\t\t\t\t\t      cmd->obj.init, gfp);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_COOKIE_ECHO:\n\t\t\t \n\t\t\tnew_obj = sctp_make_cookie_echo(asoc, chunk);\n\t\t\tif (!new_obj) {\n\t\t\t\tif (cmd->obj.chunk)\n\t\t\t\t\tsctp_chunk_free(cmd->obj.chunk);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(new_obj));\n\n\t\t\t \n\t\t\tif (cmd->obj.chunk)\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\t\tSCTP_CHUNK(cmd->obj.chunk));\n\n\t\t\tif (new_obj->transport) {\n\t\t\t\tnew_obj->transport->init_sent_count++;\n\t\t\t\tasoc->init_last_sent_to = new_obj->transport;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((asoc->peer.retran_path !=\n\t\t\t     asoc->peer.primary_path) &&\n\t\t\t    (asoc->init_err_counter > 0)) {\n\t\t\t\tsctp_add_cmd_sf(commands,\n\t\t\t\t\t\tSCTP_CMD_FORCE_PRIM_RETRAN,\n\t\t\t\t\t\tSCTP_NULL());\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_GEN_SHUTDOWN:\n\t\t\t \n\t\t\tasoc->overall_error_count = 0;\n\n\t\t\t \n\t\t\tnew_obj = sctp_make_shutdown(asoc, chunk);\n\t\t\tif (!new_obj) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(new_obj));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_CHUNK_ULP:\n\t\t\t \n\t\t\tpr_debug(\"%s: sm_sideff: chunk_up:%p, ulpq:%p\\n\",\n\t\t\t\t __func__, cmd->obj.chunk, &asoc->ulpq);\n\n\t\t\tasoc->stream.si->ulpevent_data(&asoc->ulpq,\n\t\t\t\t\t\t       cmd->obj.chunk,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_EVENT_ULP:\n\t\t\t \n\t\t\tpr_debug(\"%s: sm_sideff: event_up:%p, ulpq:%p\\n\",\n\t\t\t\t __func__, cmd->obj.ulpevent, &asoc->ulpq);\n\n\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq,\n\t\t\t\t\t\t       cmd->obj.ulpevent);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPLY:\n\t\t\t \n\t\t\tif (!asoc->outqueue.cork) {\n\t\t\t\tsctp_outq_cork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 1;\n\t\t\t}\n\t\t\t \n\t\t\tsctp_outq_tail(&asoc->outqueue, cmd->obj.chunk, gfp);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SEND_PKT:\n\t\t\t \n\t\t\tpacket = cmd->obj.packet;\n\t\t\tsctp_packet_transmit(packet, gfp);\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_T1_RETRAN:\n\t\t\t \n\t\t\tsctp_retransmit(&asoc->outqueue, cmd->obj.transport,\n\t\t\t\t\tSCTP_RTXR_T1_RTX);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_RETRAN:\n\t\t\t \n\t\t\tsctp_retransmit(&asoc->outqueue, cmd->obj.transport,\n\t\t\t\t\tSCTP_RTXR_T3_RTX);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ECN_CE:\n\t\t\t \n\t\t\tsctp_do_ecn_ce_work(asoc, cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ECN_ECNE:\n\t\t\t \n\t\t\tnew_obj = sctp_do_ecn_ecne_work(asoc, cmd->obj.u32,\n\t\t\t\t\t\t\tchunk);\n\t\t\tif (new_obj)\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\t\tSCTP_CHUNK(new_obj));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ECN_CWR:\n\t\t\t \n\t\t\tsctp_do_ecn_cwr_work(asoc, cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SETUP_T2:\n\t\t\tsctp_cmd_setup_t2(commands, asoc, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TIMER_START_ONCE:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\n\t\t\tif (timer_pending(timer))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\n\t\tcase SCTP_CMD_TIMER_START:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\t\t\ttimeout = asoc->timeouts[cmd->obj.to];\n\t\t\tBUG_ON(!timeout);\n\n\t\t\t \n\t\t\tif (!timer_pending(timer))\n\t\t\t\tsctp_association_hold(asoc);\n\t\t\ttimer_reduce(timer, jiffies + timeout);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TIMER_RESTART:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\t\t\ttimeout = asoc->timeouts[cmd->obj.to];\n\t\t\tif (!mod_timer(timer, jiffies + timeout))\n\t\t\t\tsctp_association_hold(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TIMER_STOP:\n\t\t\ttimer = &asoc->timers[cmd->obj.to];\n\t\t\tif (del_timer(timer))\n\t\t\t\tsctp_association_put(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_CHOOSE_TRANSPORT:\n\t\t\tchunk = cmd->obj.chunk;\n\t\t\tt = sctp_assoc_choose_alter_transport(asoc,\n\t\t\t\t\t\tasoc->init_last_sent_to);\n\t\t\tasoc->init_last_sent_to = t;\n\t\t\tchunk->transport = t;\n\t\t\tt->init_sent_count++;\n\t\t\t \n\t\t\tsctp_assoc_set_primary(asoc, t);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_RESTART:\n\t\t\t \n\t\t\tsctp_cmd_t1_timer_update(asoc,\n\t\t\t\t\t\tSCTP_EVENT_TIMEOUT_T1_INIT,\n\t\t\t\t\t\t\"INIT\");\n\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_COOKIEECHO_RESTART:\n\t\t\t \n\t\t\tsctp_cmd_t1_timer_update(asoc,\n\t\t\t\t\t\tSCTP_EVENT_TIMEOUT_T1_COOKIE,\n\t\t\t\t\t\t\"COOKIE\");\n\n\t\t\t \n\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t\ttransports) {\n\t\t\t\tsctp_retransmit_mark(&asoc->outqueue, t,\n\t\t\t\t\t    SCTP_RTXR_T1_RTX);\n\t\t\t}\n\n\t\t\tsctp_add_cmd_sf(commands,\n\t\t\t\t\tSCTP_CMD_TIMER_RESTART,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_FAILED:\n\t\t\tsctp_cmd_init_failed(commands, asoc, cmd->obj.u16);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ASSOC_FAILED:\n\t\t\tsctp_cmd_assoc_failed(commands, asoc, event_type,\n\t\t\t\t\t      subtype, chunk, cmd->obj.u16);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_COUNTER_INC:\n\t\t\tasoc->init_err_counter++;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_INIT_COUNTER_RESET:\n\t\t\tasoc->init_err_counter = 0;\n\t\t\tasoc->init_cycle = 0;\n\t\t\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\t\t\t    transports) {\n\t\t\t\tt->init_sent_count = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_DUP:\n\t\t\tsctp_tsnmap_mark_dup(&asoc->peer.tsn_map,\n\t\t\t\t\t     cmd->obj.u32);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_BAD_TAG:\n\t\t\tpr_debug(\"%s: vtag mismatch!\\n\", __func__);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_STRIKE:\n\t\t\t \n\t\t\tsctp_do_8_2_transport_strike(commands, asoc,\n\t\t\t\t\t\t    cmd->obj.transport, 0);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TRANSPORT_IDLE:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_transport_lower_cwnd(t, SCTP_LOWER_CWND_INACTIVE);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TRANSPORT_HB_SENT:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_do_8_2_transport_strike(commands, asoc,\n\t\t\t\t\t\t     t, 1);\n\t\t\tt->hb_sent = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_TRANSPORT_ON:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_cmd_transport_on(commands, asoc, t, chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_HB_TIMERS_START:\n\t\t\tsctp_cmd_hb_timers_start(commands, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_HB_TIMER_UPDATE:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_transport_reset_hb_timer(t);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_HB_TIMERS_STOP:\n\t\t\tsctp_cmd_hb_timers_stop(commands, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROBE_TIMER_UPDATE:\n\t\t\tt = cmd->obj.transport;\n\t\t\tsctp_transport_reset_probe_timer(t);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_REPORT_ERROR:\n\t\t\terror = cmd->obj.error;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_CTSN:\n\t\t\t \n\t\t\tsackh.cum_tsn_ack = cmd->obj.be32;\n\t\t\tsackh.a_rwnd = htonl(asoc->peer.rwnd +\n\t\t\t\t\t     asoc->outqueue.outstanding_bytes);\n\t\t\tsackh.num_gap_ack_blocks = 0;\n\t\t\tsackh.num_dup_tsns = 0;\n\t\t\tchunk->subh.sack_hdr = &sackh;\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK,\n\t\t\t\t\tSCTP_CHUNK(chunk));\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_DISCARD_PACKET:\n\t\t\t \n\t\t\tchunk->pdiscard = 1;\n\t\t\tif (asoc) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_RTO_PENDING:\n\t\t\tt = cmd->obj.transport;\n\t\t\tt->rto_pending = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PART_DELIVER:\n\t\t\tasoc->stream.si->start_pd(&asoc->ulpq, GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_RENEGE:\n\t\t\tasoc->stream.si->renege_events(&asoc->ulpq,\n\t\t\t\t\t\t       cmd->obj.chunk,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SETUP_T4:\n\t\t\tsctp_cmd_setup_t4(commands, asoc, cmd->obj.chunk);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_PROCESS_OPERR:\n\t\t\tsctp_cmd_process_operr(commands, asoc, chunk);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_CLEAR_INIT_TAG:\n\t\t\tasoc->peer.i.init_tag = 0;\n\t\t\tbreak;\n\t\tcase SCTP_CMD_DEL_NON_PRIMARY:\n\t\t\tsctp_cmd_del_non_primary(asoc);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_T3_RTX_TIMERS_STOP:\n\t\t\tsctp_cmd_t3_rtx_timers_stop(commands, asoc);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_FORCE_PRIM_RETRAN:\n\t\t\tt = asoc->peer.retran_path;\n\t\t\tasoc->peer.retran_path = asoc->peer.primary_path;\n\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);\n\t\t\tlocal_cork = 0;\n\t\t\tasoc->peer.retran_path = t;\n\t\t\tbreak;\n\t\tcase SCTP_CMD_SET_SK_ERR:\n\t\t\tsctp_cmd_set_sk_err(asoc, cmd->obj.error);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_ASSOC_CHANGE:\n\t\t\tsctp_cmd_assoc_change(commands, asoc,\n\t\t\t\t\t      cmd->obj.u8);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_ADAPTATION_IND:\n\t\t\tsctp_cmd_adaptation_ind(commands, asoc);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_PEER_NO_AUTH:\n\t\t\tsctp_cmd_peer_no_auth(commands, asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_ASSOC_SHKEY:\n\t\t\terror = sctp_auth_asoc_init_active_key(asoc,\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_UPDATE_INITTAG:\n\t\t\tasoc->peer.i.init_tag = cmd->obj.u32;\n\t\t\tbreak;\n\t\tcase SCTP_CMD_SEND_MSG:\n\t\t\tif (!asoc->outqueue.cork) {\n\t\t\t\tsctp_outq_cork(&asoc->outqueue);\n\t\t\t\tlocal_cork = 1;\n\t\t\t}\n\t\t\tsctp_cmd_send_msg(asoc, cmd->obj.msg, gfp);\n\t\t\tbreak;\n\t\tcase SCTP_CMD_PURGE_ASCONF_QUEUE:\n\t\t\tsctp_asconf_queue_teardown(asoc);\n\t\t\tbreak;\n\n\t\tcase SCTP_CMD_SET_ASOC:\n\t\t\tif (asoc && local_cork) {\n\t\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);\n\t\t\t\tlocal_cork = 0;\n\t\t\t}\n\t\t\tasoc = cmd->obj.asoc;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn(\"Impossible command: %u\\n\",\n\t\t\t\tcmd->verb);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (error) {\n\t\t\tcmd = sctp_next_cmd(commands);\n\t\t\twhile (cmd) {\n\t\t\t\tif (cmd->verb == SCTP_CMD_REPLY)\n\t\t\t\t\tsctp_chunk_free(cmd->obj.chunk);\n\t\t\t\tcmd = sctp_next_cmd(commands);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (asoc && SCTP_EVENT_T_CHUNK == event_type && chunk) {\n\t\tif (chunk->end_of_packet || chunk->singleton)\n\t\t\tsctp_outq_uncork(&asoc->outqueue, gfp);\n\t} else if (local_cork)\n\t\tsctp_outq_uncork(&asoc->outqueue, gfp);\n\n\tif (sp->data_ready_signalled)\n\t\tsp->data_ready_signalled = 0;\n\n\treturn error;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}