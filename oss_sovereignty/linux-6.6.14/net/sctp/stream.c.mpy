{
  "module_name": "stream.c",
  "hash_id": "7d2ac2e3b6d5a9f702cfb910d0ac8e718f0f4a70e288973ba912eee1d6291220",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/stream.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/stream_sched.h>\n\nstatic void sctp_stream_shrink_out(struct sctp_stream *stream, __u16 outcnt)\n{\n\tstruct sctp_association *asoc;\n\tstruct sctp_chunk *ch, *temp;\n\tstruct sctp_outq *outq;\n\n\tasoc = container_of(stream, struct sctp_association, stream);\n\toutq = &asoc->outqueue;\n\n\tlist_for_each_entry_safe(ch, temp, &outq->out_chunk_list, list) {\n\t\t__u16 sid = sctp_chunk_stream_no(ch);\n\n\t\tif (sid < outcnt)\n\t\t\tcontinue;\n\n\t\tsctp_sched_dequeue_common(outq, ch);\n\t\t \n\n\t\t \n\t\tsctp_chunk_fail(ch, (__force __u32)SCTP_ERROR_INV_STRM);\n\t\tif (asoc->peer.prsctp_capable &&\n\t\t    SCTP_PR_PRIO_ENABLED(ch->sinfo.sinfo_flags))\n\t\t\tasoc->sent_cnt_removable--;\n\n\t\tsctp_chunk_free(ch);\n\t}\n}\n\nstatic void sctp_stream_free_ext(struct sctp_stream *stream, __u16 sid)\n{\n\tstruct sctp_sched_ops *sched;\n\n\tif (!SCTP_SO(stream, sid)->ext)\n\t\treturn;\n\n\tsched = sctp_sched_ops_from_stream(stream);\n\tsched->free_sid(stream, sid);\n\tkfree(SCTP_SO(stream, sid)->ext);\n\tSCTP_SO(stream, sid)->ext = NULL;\n}\n\n \nstatic void sctp_stream_outq_migrate(struct sctp_stream *stream,\n\t\t\t\t     struct sctp_stream *new, __u16 outcnt)\n{\n\tint i;\n\n\tif (stream->outcnt > outcnt)\n\t\tsctp_stream_shrink_out(stream, outcnt);\n\n\tif (new) {\n\t\t \n\t\tfor (i = 0; i < outcnt; i++) {\n\t\t\tsctp_stream_free_ext(new, i);\n\t\t\tSCTP_SO(new, i)->ext = SCTP_SO(stream, i)->ext;\n\t\t\tSCTP_SO(stream, i)->ext = NULL;\n\t\t}\n\t}\n\n\tfor (i = outcnt; i < stream->outcnt; i++)\n\t\tsctp_stream_free_ext(stream, i);\n}\n\nstatic int sctp_stream_alloc_out(struct sctp_stream *stream, __u16 outcnt,\n\t\t\t\t gfp_t gfp)\n{\n\tint ret;\n\n\tif (outcnt <= stream->outcnt)\n\t\tgoto out;\n\n\tret = genradix_prealloc(&stream->out, outcnt, gfp);\n\tif (ret)\n\t\treturn ret;\n\nout:\n\tstream->outcnt = outcnt;\n\treturn 0;\n}\n\nstatic int sctp_stream_alloc_in(struct sctp_stream *stream, __u16 incnt,\n\t\t\t\tgfp_t gfp)\n{\n\tint ret;\n\n\tif (incnt <= stream->incnt)\n\t\tgoto out;\n\n\tret = genradix_prealloc(&stream->in, incnt, gfp);\n\tif (ret)\n\t\treturn ret;\n\nout:\n\tstream->incnt = incnt;\n\treturn 0;\n}\n\nint sctp_stream_init(struct sctp_stream *stream, __u16 outcnt, __u16 incnt,\n\t\t     gfp_t gfp)\n{\n\tstruct sctp_sched_ops *sched = sctp_sched_ops_from_stream(stream);\n\tint i, ret = 0;\n\n\tgfp |= __GFP_NOWARN;\n\n\t \n\tif (outcnt == stream->outcnt)\n\t\tgoto handle_in;\n\n\t \n\tsched->unsched_all(stream);\n\tsctp_stream_outq_migrate(stream, NULL, outcnt);\n\tsched->sched_all(stream);\n\n\tret = sctp_stream_alloc_out(stream, outcnt, gfp);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < stream->outcnt; i++)\n\t\tSCTP_SO(stream, i)->state = SCTP_STREAM_OPEN;\n\nhandle_in:\n\tsctp_stream_interleave_init(stream);\n\tif (!incnt)\n\t\treturn 0;\n\n\treturn sctp_stream_alloc_in(stream, incnt, gfp);\n}\n\nint sctp_stream_init_ext(struct sctp_stream *stream, __u16 sid)\n{\n\tstruct sctp_stream_out_ext *soute;\n\tint ret;\n\n\tsoute = kzalloc(sizeof(*soute), GFP_KERNEL);\n\tif (!soute)\n\t\treturn -ENOMEM;\n\tSCTP_SO(stream, sid)->ext = soute;\n\n\tret = sctp_sched_init_sid(stream, sid, GFP_KERNEL);\n\tif (ret) {\n\t\tkfree(SCTP_SO(stream, sid)->ext);\n\t\tSCTP_SO(stream, sid)->ext = NULL;\n\t}\n\n\treturn ret;\n}\n\nvoid sctp_stream_free(struct sctp_stream *stream)\n{\n\tstruct sctp_sched_ops *sched = sctp_sched_ops_from_stream(stream);\n\tint i;\n\n\tsched->unsched_all(stream);\n\tfor (i = 0; i < stream->outcnt; i++)\n\t\tsctp_stream_free_ext(stream, i);\n\tgenradix_free(&stream->out);\n\tgenradix_free(&stream->in);\n}\n\nvoid sctp_stream_clear(struct sctp_stream *stream)\n{\n\tint i;\n\n\tfor (i = 0; i < stream->outcnt; i++) {\n\t\tSCTP_SO(stream, i)->mid = 0;\n\t\tSCTP_SO(stream, i)->mid_uo = 0;\n\t}\n\n\tfor (i = 0; i < stream->incnt; i++)\n\t\tSCTP_SI(stream, i)->mid = 0;\n}\n\nvoid sctp_stream_update(struct sctp_stream *stream, struct sctp_stream *new)\n{\n\tstruct sctp_sched_ops *sched = sctp_sched_ops_from_stream(stream);\n\n\tsched->unsched_all(stream);\n\tsctp_stream_outq_migrate(stream, new, new->outcnt);\n\tsctp_stream_free(stream);\n\n\tstream->out = new->out;\n\tstream->in  = new->in;\n\tstream->outcnt = new->outcnt;\n\tstream->incnt  = new->incnt;\n\n\tsched->sched_all(stream);\n\n\tnew->out.tree.root = NULL;\n\tnew->in.tree.root  = NULL;\n\tnew->outcnt = 0;\n\tnew->incnt  = 0;\n}\n\nstatic int sctp_send_reconf(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *chunk)\n{\n\tint retval = 0;\n\n\tretval = sctp_primitive_RECONF(asoc->base.net, asoc, chunk);\n\tif (retval)\n\t\tsctp_chunk_free(chunk);\n\n\treturn retval;\n}\n\nstatic bool sctp_stream_outq_is_empty(struct sctp_stream *stream,\n\t\t\t\t      __u16 str_nums, __be16 *str_list)\n{\n\tstruct sctp_association *asoc;\n\t__u16 i;\n\n\tasoc = container_of(stream, struct sctp_association, stream);\n\tif (!asoc->outqueue.out_qlen)\n\t\treturn true;\n\n\tif (!str_nums)\n\t\treturn false;\n\n\tfor (i = 0; i < str_nums; i++) {\n\t\t__u16 sid = ntohs(str_list[i]);\n\n\t\tif (SCTP_SO(stream, sid)->ext &&\n\t\t    !list_empty(&SCTP_SO(stream, sid)->ext->outq))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint sctp_send_reset_streams(struct sctp_association *asoc,\n\t\t\t    struct sctp_reset_streams *params)\n{\n\tstruct sctp_stream *stream = &asoc->stream;\n\t__u16 i, str_nums, *str_list;\n\tstruct sctp_chunk *chunk;\n\tint retval = -EINVAL;\n\t__be16 *nstr_list;\n\tbool out, in;\n\n\tif (!asoc->peer.reconf_capable ||\n\t    !(asoc->strreset_enable & SCTP_ENABLE_RESET_STREAM_REQ)) {\n\t\tretval = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\n\tif (asoc->strreset_outstanding) {\n\t\tretval = -EINPROGRESS;\n\t\tgoto out;\n\t}\n\n\tout = params->srs_flags & SCTP_STREAM_RESET_OUTGOING;\n\tin  = params->srs_flags & SCTP_STREAM_RESET_INCOMING;\n\tif (!out && !in)\n\t\tgoto out;\n\n\tstr_nums = params->srs_number_streams;\n\tstr_list = params->srs_stream_list;\n\tif (str_nums) {\n\t\tint param_len = 0;\n\n\t\tif (out) {\n\t\t\tfor (i = 0; i < str_nums; i++)\n\t\t\t\tif (str_list[i] >= stream->outcnt)\n\t\t\t\t\tgoto out;\n\n\t\t\tparam_len = str_nums * sizeof(__u16) +\n\t\t\t\t    sizeof(struct sctp_strreset_outreq);\n\t\t}\n\n\t\tif (in) {\n\t\t\tfor (i = 0; i < str_nums; i++)\n\t\t\t\tif (str_list[i] >= stream->incnt)\n\t\t\t\t\tgoto out;\n\n\t\t\tparam_len += str_nums * sizeof(__u16) +\n\t\t\t\t     sizeof(struct sctp_strreset_inreq);\n\t\t}\n\n\t\tif (param_len > SCTP_MAX_CHUNK_LEN -\n\t\t\t\tsizeof(struct sctp_reconf_chunk))\n\t\t\tgoto out;\n\t}\n\n\tnstr_list = kcalloc(str_nums, sizeof(__be16), GFP_KERNEL);\n\tif (!nstr_list) {\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < str_nums; i++)\n\t\tnstr_list[i] = htons(str_list[i]);\n\n\tif (out && !sctp_stream_outq_is_empty(stream, str_nums, nstr_list)) {\n\t\tkfree(nstr_list);\n\t\tretval = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tchunk = sctp_make_strreset_req(asoc, str_nums, nstr_list, out, in);\n\n\tkfree(nstr_list);\n\n\tif (!chunk) {\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (out) {\n\t\tif (str_nums)\n\t\t\tfor (i = 0; i < str_nums; i++)\n\t\t\t\tSCTP_SO(stream, str_list[i])->state =\n\t\t\t\t\t\t       SCTP_STREAM_CLOSED;\n\t\telse\n\t\t\tfor (i = 0; i < stream->outcnt; i++)\n\t\t\t\tSCTP_SO(stream, i)->state = SCTP_STREAM_CLOSED;\n\t}\n\n\tasoc->strreset_chunk = chunk;\n\tsctp_chunk_hold(asoc->strreset_chunk);\n\n\tretval = sctp_send_reconf(asoc, chunk);\n\tif (retval) {\n\t\tsctp_chunk_put(asoc->strreset_chunk);\n\t\tasoc->strreset_chunk = NULL;\n\t\tif (!out)\n\t\t\tgoto out;\n\n\t\tif (str_nums)\n\t\t\tfor (i = 0; i < str_nums; i++)\n\t\t\t\tSCTP_SO(stream, str_list[i])->state =\n\t\t\t\t\t\t       SCTP_STREAM_OPEN;\n\t\telse\n\t\t\tfor (i = 0; i < stream->outcnt; i++)\n\t\t\t\tSCTP_SO(stream, i)->state = SCTP_STREAM_OPEN;\n\n\t\tgoto out;\n\t}\n\n\tasoc->strreset_outstanding = out + in;\n\nout:\n\treturn retval;\n}\n\nint sctp_send_reset_assoc(struct sctp_association *asoc)\n{\n\tstruct sctp_stream *stream = &asoc->stream;\n\tstruct sctp_chunk *chunk = NULL;\n\tint retval;\n\t__u16 i;\n\n\tif (!asoc->peer.reconf_capable ||\n\t    !(asoc->strreset_enable & SCTP_ENABLE_RESET_ASSOC_REQ))\n\t\treturn -ENOPROTOOPT;\n\n\tif (asoc->strreset_outstanding)\n\t\treturn -EINPROGRESS;\n\n\tif (!sctp_outq_is_empty(&asoc->outqueue))\n\t\treturn -EAGAIN;\n\n\tchunk = sctp_make_strreset_tsnreq(asoc);\n\tif (!chunk)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < stream->outcnt; i++)\n\t\tSCTP_SO(stream, i)->state = SCTP_STREAM_CLOSED;\n\n\tasoc->strreset_chunk = chunk;\n\tsctp_chunk_hold(asoc->strreset_chunk);\n\n\tretval = sctp_send_reconf(asoc, chunk);\n\tif (retval) {\n\t\tsctp_chunk_put(asoc->strreset_chunk);\n\t\tasoc->strreset_chunk = NULL;\n\n\t\tfor (i = 0; i < stream->outcnt; i++)\n\t\t\tSCTP_SO(stream, i)->state = SCTP_STREAM_OPEN;\n\n\t\treturn retval;\n\t}\n\n\tasoc->strreset_outstanding = 1;\n\n\treturn 0;\n}\n\nint sctp_send_add_streams(struct sctp_association *asoc,\n\t\t\t  struct sctp_add_streams *params)\n{\n\tstruct sctp_stream *stream = &asoc->stream;\n\tstruct sctp_chunk *chunk = NULL;\n\tint retval;\n\t__u32 outcnt, incnt;\n\t__u16 out, in;\n\n\tif (!asoc->peer.reconf_capable ||\n\t    !(asoc->strreset_enable & SCTP_ENABLE_CHANGE_ASSOC_REQ)) {\n\t\tretval = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\n\tif (asoc->strreset_outstanding) {\n\t\tretval = -EINPROGRESS;\n\t\tgoto out;\n\t}\n\n\tout = params->sas_outstrms;\n\tin  = params->sas_instrms;\n\toutcnt = stream->outcnt + out;\n\tincnt = stream->incnt + in;\n\tif (outcnt > SCTP_MAX_STREAM || incnt > SCTP_MAX_STREAM ||\n\t    (!out && !in)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (out) {\n\t\tretval = sctp_stream_alloc_out(stream, outcnt, GFP_KERNEL);\n\t\tif (retval)\n\t\t\tgoto out;\n\t}\n\n\tchunk = sctp_make_strreset_addstrm(asoc, out, in);\n\tif (!chunk) {\n\t\tretval = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tasoc->strreset_chunk = chunk;\n\tsctp_chunk_hold(asoc->strreset_chunk);\n\n\tretval = sctp_send_reconf(asoc, chunk);\n\tif (retval) {\n\t\tsctp_chunk_put(asoc->strreset_chunk);\n\t\tasoc->strreset_chunk = NULL;\n\t\tgoto out;\n\t}\n\n\tasoc->strreset_outstanding = !!out + !!in;\n\nout:\n\treturn retval;\n}\n\nstatic struct sctp_paramhdr *sctp_chunk_lookup_strreset_param(\n\t\t\tstruct sctp_association *asoc, __be32 resp_seq,\n\t\t\t__be16 type)\n{\n\tstruct sctp_chunk *chunk = asoc->strreset_chunk;\n\tstruct sctp_reconf_chunk *hdr;\n\tunion sctp_params param;\n\n\tif (!chunk)\n\t\treturn NULL;\n\n\thdr = (struct sctp_reconf_chunk *)chunk->chunk_hdr;\n\tsctp_walk_params(param, hdr) {\n\t\t \n\t\tstruct sctp_strreset_tsnreq *req = param.v;\n\n\t\tif ((!resp_seq || req->request_seq == resp_seq) &&\n\t\t    (!type || type == req->param_hdr.type))\n\t\t\treturn param.v;\n\t}\n\n\treturn NULL;\n}\n\nstatic void sctp_update_strreset_result(struct sctp_association *asoc,\n\t\t\t\t\t__u32 result)\n{\n\tasoc->strreset_result[1] = asoc->strreset_result[0];\n\tasoc->strreset_result[0] = result;\n}\n\nstruct sctp_chunk *sctp_process_strreset_outreq(\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tunion sctp_params param,\n\t\t\t\tstruct sctp_ulpevent **evp)\n{\n\tstruct sctp_strreset_outreq *outreq = param.v;\n\tstruct sctp_stream *stream = &asoc->stream;\n\t__u32 result = SCTP_STRRESET_DENIED;\n\t__be16 *str_p = NULL;\n\t__u32 request_seq;\n\t__u16 i, nums;\n\n\trequest_seq = ntohl(outreq->request_seq);\n\n\tif (ntohl(outreq->send_reset_at_tsn) >\n\t    sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map)) {\n\t\tresult = SCTP_STRRESET_IN_PROGRESS;\n\t\tgoto err;\n\t}\n\n\tif (TSN_lt(asoc->strreset_inseq, request_seq) ||\n\t    TSN_lt(request_seq, asoc->strreset_inseq - 2)) {\n\t\tresult = SCTP_STRRESET_ERR_BAD_SEQNO;\n\t\tgoto err;\n\t} else if (TSN_lt(request_seq, asoc->strreset_inseq)) {\n\t\ti = asoc->strreset_inseq - request_seq - 1;\n\t\tresult = asoc->strreset_result[i];\n\t\tgoto err;\n\t}\n\tasoc->strreset_inseq++;\n\n\t \n\tif (!(asoc->strreset_enable & SCTP_ENABLE_RESET_STREAM_REQ))\n\t\tgoto out;\n\n\tnums = (ntohs(param.p->length) - sizeof(*outreq)) / sizeof(__u16);\n\tstr_p = outreq->list_of_streams;\n\tfor (i = 0; i < nums; i++) {\n\t\tif (ntohs(str_p[i]) >= stream->incnt) {\n\t\t\tresult = SCTP_STRRESET_ERR_WRONG_SSN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (asoc->strreset_chunk) {\n\t\tif (!sctp_chunk_lookup_strreset_param(\n\t\t\t\tasoc, outreq->response_seq,\n\t\t\t\tSCTP_PARAM_RESET_IN_REQUEST)) {\n\t\t\t \n\t\t\tresult = SCTP_STRRESET_ERR_IN_PROGRESS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tasoc->strreset_outstanding--;\n\t\tasoc->strreset_outseq++;\n\n\t\tif (!asoc->strreset_outstanding) {\n\t\t\tstruct sctp_transport *t;\n\n\t\t\tt = asoc->strreset_chunk->transport;\n\t\t\tif (del_timer(&t->reconf_timer))\n\t\t\t\tsctp_transport_put(t);\n\n\t\t\tsctp_chunk_put(asoc->strreset_chunk);\n\t\t\tasoc->strreset_chunk = NULL;\n\t\t}\n\t}\n\n\tif (nums)\n\t\tfor (i = 0; i < nums; i++)\n\t\t\tSCTP_SI(stream, ntohs(str_p[i]))->mid = 0;\n\telse\n\t\tfor (i = 0; i < stream->incnt; i++)\n\t\t\tSCTP_SI(stream, i)->mid = 0;\n\n\tresult = SCTP_STRRESET_PERFORMED;\n\n\t*evp = sctp_ulpevent_make_stream_reset_event(asoc,\n\t\tSCTP_STREAM_RESET_INCOMING_SSN, nums, str_p, GFP_ATOMIC);\n\nout:\n\tsctp_update_strreset_result(asoc, result);\nerr:\n\treturn sctp_make_strreset_resp(asoc, result, request_seq);\n}\n\nstruct sctp_chunk *sctp_process_strreset_inreq(\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tunion sctp_params param,\n\t\t\t\tstruct sctp_ulpevent **evp)\n{\n\tstruct sctp_strreset_inreq *inreq = param.v;\n\tstruct sctp_stream *stream = &asoc->stream;\n\t__u32 result = SCTP_STRRESET_DENIED;\n\tstruct sctp_chunk *chunk = NULL;\n\t__u32 request_seq;\n\t__u16 i, nums;\n\t__be16 *str_p;\n\n\trequest_seq = ntohl(inreq->request_seq);\n\tif (TSN_lt(asoc->strreset_inseq, request_seq) ||\n\t    TSN_lt(request_seq, asoc->strreset_inseq - 2)) {\n\t\tresult = SCTP_STRRESET_ERR_BAD_SEQNO;\n\t\tgoto err;\n\t} else if (TSN_lt(request_seq, asoc->strreset_inseq)) {\n\t\ti = asoc->strreset_inseq - request_seq - 1;\n\t\tresult = asoc->strreset_result[i];\n\t\tif (result == SCTP_STRRESET_PERFORMED)\n\t\t\treturn NULL;\n\t\tgoto err;\n\t}\n\tasoc->strreset_inseq++;\n\n\tif (!(asoc->strreset_enable & SCTP_ENABLE_RESET_STREAM_REQ))\n\t\tgoto out;\n\n\tif (asoc->strreset_outstanding) {\n\t\tresult = SCTP_STRRESET_ERR_IN_PROGRESS;\n\t\tgoto out;\n\t}\n\n\tnums = (ntohs(param.p->length) - sizeof(*inreq)) / sizeof(__u16);\n\tstr_p = inreq->list_of_streams;\n\tfor (i = 0; i < nums; i++) {\n\t\tif (ntohs(str_p[i]) >= stream->outcnt) {\n\t\t\tresult = SCTP_STRRESET_ERR_WRONG_SSN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!sctp_stream_outq_is_empty(stream, nums, str_p)) {\n\t\tresult = SCTP_STRRESET_IN_PROGRESS;\n\t\tasoc->strreset_inseq--;\n\t\tgoto err;\n\t}\n\n\tchunk = sctp_make_strreset_req(asoc, nums, str_p, 1, 0);\n\tif (!chunk)\n\t\tgoto out;\n\n\tif (nums)\n\t\tfor (i = 0; i < nums; i++)\n\t\t\tSCTP_SO(stream, ntohs(str_p[i]))->state =\n\t\t\t\t\t       SCTP_STREAM_CLOSED;\n\telse\n\t\tfor (i = 0; i < stream->outcnt; i++)\n\t\t\tSCTP_SO(stream, i)->state = SCTP_STREAM_CLOSED;\n\n\tasoc->strreset_chunk = chunk;\n\tasoc->strreset_outstanding = 1;\n\tsctp_chunk_hold(asoc->strreset_chunk);\n\n\tresult = SCTP_STRRESET_PERFORMED;\n\nout:\n\tsctp_update_strreset_result(asoc, result);\nerr:\n\tif (!chunk)\n\t\tchunk =  sctp_make_strreset_resp(asoc, result, request_seq);\n\n\treturn chunk;\n}\n\nstruct sctp_chunk *sctp_process_strreset_tsnreq(\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tunion sctp_params param,\n\t\t\t\tstruct sctp_ulpevent **evp)\n{\n\t__u32 init_tsn = 0, next_tsn = 0, max_tsn_seen;\n\tstruct sctp_strreset_tsnreq *tsnreq = param.v;\n\tstruct sctp_stream *stream = &asoc->stream;\n\t__u32 result = SCTP_STRRESET_DENIED;\n\t__u32 request_seq;\n\t__u16 i;\n\n\trequest_seq = ntohl(tsnreq->request_seq);\n\tif (TSN_lt(asoc->strreset_inseq, request_seq) ||\n\t    TSN_lt(request_seq, asoc->strreset_inseq - 2)) {\n\t\tresult = SCTP_STRRESET_ERR_BAD_SEQNO;\n\t\tgoto err;\n\t} else if (TSN_lt(request_seq, asoc->strreset_inseq)) {\n\t\ti = asoc->strreset_inseq - request_seq - 1;\n\t\tresult = asoc->strreset_result[i];\n\t\tif (result == SCTP_STRRESET_PERFORMED) {\n\t\t\tnext_tsn = asoc->ctsn_ack_point + 1;\n\t\t\tinit_tsn =\n\t\t\t\tsctp_tsnmap_get_ctsn(&asoc->peer.tsn_map) + 1;\n\t\t}\n\t\tgoto err;\n\t}\n\n\tif (!sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tresult = SCTP_STRRESET_IN_PROGRESS;\n\t\tgoto err;\n\t}\n\n\tasoc->strreset_inseq++;\n\n\tif (!(asoc->strreset_enable & SCTP_ENABLE_RESET_ASSOC_REQ))\n\t\tgoto out;\n\n\tif (asoc->strreset_outstanding) {\n\t\tresult = SCTP_STRRESET_ERR_IN_PROGRESS;\n\t\tgoto out;\n\t}\n\n\t \n\tmax_tsn_seen = sctp_tsnmap_get_max_tsn_seen(&asoc->peer.tsn_map);\n\tasoc->stream.si->report_ftsn(&asoc->ulpq, max_tsn_seen);\n\n\t \n\tinit_tsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map) + (1 << 31);\n\tsctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\n\t\t\t init_tsn, GFP_ATOMIC);\n\n\t \n\tsctp_outq_free(&asoc->outqueue);\n\n\t \n\tnext_tsn = asoc->next_tsn;\n\tasoc->ctsn_ack_point = next_tsn - 1;\n\tasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\n\n\t \n\tfor (i = 0; i < stream->outcnt; i++) {\n\t\tSCTP_SO(stream, i)->mid = 0;\n\t\tSCTP_SO(stream, i)->mid_uo = 0;\n\t}\n\tfor (i = 0; i < stream->incnt; i++)\n\t\tSCTP_SI(stream, i)->mid = 0;\n\n\tresult = SCTP_STRRESET_PERFORMED;\n\n\t*evp = sctp_ulpevent_make_assoc_reset_event(asoc, 0, init_tsn,\n\t\t\t\t\t\t    next_tsn, GFP_ATOMIC);\n\nout:\n\tsctp_update_strreset_result(asoc, result);\nerr:\n\treturn sctp_make_strreset_tsnresp(asoc, result, request_seq,\n\t\t\t\t\t  next_tsn, init_tsn);\n}\n\nstruct sctp_chunk *sctp_process_strreset_addstrm_out(\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tunion sctp_params param,\n\t\t\t\tstruct sctp_ulpevent **evp)\n{\n\tstruct sctp_strreset_addstrm *addstrm = param.v;\n\tstruct sctp_stream *stream = &asoc->stream;\n\t__u32 result = SCTP_STRRESET_DENIED;\n\t__u32 request_seq, incnt;\n\t__u16 in, i;\n\n\trequest_seq = ntohl(addstrm->request_seq);\n\tif (TSN_lt(asoc->strreset_inseq, request_seq) ||\n\t    TSN_lt(request_seq, asoc->strreset_inseq - 2)) {\n\t\tresult = SCTP_STRRESET_ERR_BAD_SEQNO;\n\t\tgoto err;\n\t} else if (TSN_lt(request_seq, asoc->strreset_inseq)) {\n\t\ti = asoc->strreset_inseq - request_seq - 1;\n\t\tresult = asoc->strreset_result[i];\n\t\tgoto err;\n\t}\n\tasoc->strreset_inseq++;\n\n\tif (!(asoc->strreset_enable & SCTP_ENABLE_CHANGE_ASSOC_REQ))\n\t\tgoto out;\n\n\tin = ntohs(addstrm->number_of_streams);\n\tincnt = stream->incnt + in;\n\tif (!in || incnt > SCTP_MAX_STREAM)\n\t\tgoto out;\n\n\tif (sctp_stream_alloc_in(stream, incnt, GFP_ATOMIC))\n\t\tgoto out;\n\n\tif (asoc->strreset_chunk) {\n\t\tif (!sctp_chunk_lookup_strreset_param(\n\t\t\tasoc, 0, SCTP_PARAM_RESET_ADD_IN_STREAMS)) {\n\t\t\t \n\t\t\tresult = SCTP_STRRESET_ERR_IN_PROGRESS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tasoc->strreset_outstanding--;\n\t\tasoc->strreset_outseq++;\n\n\t\tif (!asoc->strreset_outstanding) {\n\t\t\tstruct sctp_transport *t;\n\n\t\t\tt = asoc->strreset_chunk->transport;\n\t\t\tif (del_timer(&t->reconf_timer))\n\t\t\t\tsctp_transport_put(t);\n\n\t\t\tsctp_chunk_put(asoc->strreset_chunk);\n\t\t\tasoc->strreset_chunk = NULL;\n\t\t}\n\t}\n\n\tstream->incnt = incnt;\n\n\tresult = SCTP_STRRESET_PERFORMED;\n\n\t*evp = sctp_ulpevent_make_stream_change_event(asoc,\n\t\t0, ntohs(addstrm->number_of_streams), 0, GFP_ATOMIC);\n\nout:\n\tsctp_update_strreset_result(asoc, result);\nerr:\n\treturn sctp_make_strreset_resp(asoc, result, request_seq);\n}\n\nstruct sctp_chunk *sctp_process_strreset_addstrm_in(\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tunion sctp_params param,\n\t\t\t\tstruct sctp_ulpevent **evp)\n{\n\tstruct sctp_strreset_addstrm *addstrm = param.v;\n\tstruct sctp_stream *stream = &asoc->stream;\n\t__u32 result = SCTP_STRRESET_DENIED;\n\tstruct sctp_chunk *chunk = NULL;\n\t__u32 request_seq, outcnt;\n\t__u16 out, i;\n\tint ret;\n\n\trequest_seq = ntohl(addstrm->request_seq);\n\tif (TSN_lt(asoc->strreset_inseq, request_seq) ||\n\t    TSN_lt(request_seq, asoc->strreset_inseq - 2)) {\n\t\tresult = SCTP_STRRESET_ERR_BAD_SEQNO;\n\t\tgoto err;\n\t} else if (TSN_lt(request_seq, asoc->strreset_inseq)) {\n\t\ti = asoc->strreset_inseq - request_seq - 1;\n\t\tresult = asoc->strreset_result[i];\n\t\tif (result == SCTP_STRRESET_PERFORMED)\n\t\t\treturn NULL;\n\t\tgoto err;\n\t}\n\tasoc->strreset_inseq++;\n\n\tif (!(asoc->strreset_enable & SCTP_ENABLE_CHANGE_ASSOC_REQ))\n\t\tgoto out;\n\n\tif (asoc->strreset_outstanding) {\n\t\tresult = SCTP_STRRESET_ERR_IN_PROGRESS;\n\t\tgoto out;\n\t}\n\n\tout = ntohs(addstrm->number_of_streams);\n\toutcnt = stream->outcnt + out;\n\tif (!out || outcnt > SCTP_MAX_STREAM)\n\t\tgoto out;\n\n\tret = sctp_stream_alloc_out(stream, outcnt, GFP_ATOMIC);\n\tif (ret)\n\t\tgoto out;\n\n\tchunk = sctp_make_strreset_addstrm(asoc, out, 0);\n\tif (!chunk)\n\t\tgoto out;\n\n\tasoc->strreset_chunk = chunk;\n\tasoc->strreset_outstanding = 1;\n\tsctp_chunk_hold(asoc->strreset_chunk);\n\n\tstream->outcnt = outcnt;\n\n\tresult = SCTP_STRRESET_PERFORMED;\n\nout:\n\tsctp_update_strreset_result(asoc, result);\nerr:\n\tif (!chunk)\n\t\tchunk = sctp_make_strreset_resp(asoc, result, request_seq);\n\n\treturn chunk;\n}\n\nstruct sctp_chunk *sctp_process_strreset_resp(\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tunion sctp_params param,\n\t\t\t\tstruct sctp_ulpevent **evp)\n{\n\tstruct sctp_stream *stream = &asoc->stream;\n\tstruct sctp_strreset_resp *resp = param.v;\n\tstruct sctp_transport *t;\n\t__u16 i, nums, flags = 0;\n\tstruct sctp_paramhdr *req;\n\t__u32 result;\n\n\treq = sctp_chunk_lookup_strreset_param(asoc, resp->response_seq, 0);\n\tif (!req)\n\t\treturn NULL;\n\n\tresult = ntohl(resp->result);\n\tif (result != SCTP_STRRESET_PERFORMED) {\n\t\t \n\t\tif (result == SCTP_STRRESET_IN_PROGRESS)\n\t\t\treturn NULL;\n\t\telse if (result == SCTP_STRRESET_DENIED)\n\t\t\tflags = SCTP_STREAM_RESET_DENIED;\n\t\telse\n\t\t\tflags = SCTP_STREAM_RESET_FAILED;\n\t}\n\n\tif (req->type == SCTP_PARAM_RESET_OUT_REQUEST) {\n\t\tstruct sctp_strreset_outreq *outreq;\n\t\t__be16 *str_p;\n\n\t\toutreq = (struct sctp_strreset_outreq *)req;\n\t\tstr_p = outreq->list_of_streams;\n\t\tnums = (ntohs(outreq->param_hdr.length) - sizeof(*outreq)) /\n\t\t       sizeof(__u16);\n\n\t\tif (result == SCTP_STRRESET_PERFORMED) {\n\t\t\tstruct sctp_stream_out *sout;\n\t\t\tif (nums) {\n\t\t\t\tfor (i = 0; i < nums; i++) {\n\t\t\t\t\tsout = SCTP_SO(stream, ntohs(str_p[i]));\n\t\t\t\t\tsout->mid = 0;\n\t\t\t\t\tsout->mid_uo = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < stream->outcnt; i++) {\n\t\t\t\t\tsout = SCTP_SO(stream, i);\n\t\t\t\t\tsout->mid = 0;\n\t\t\t\t\tsout->mid_uo = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tflags |= SCTP_STREAM_RESET_OUTGOING_SSN;\n\n\t\tfor (i = 0; i < stream->outcnt; i++)\n\t\t\tSCTP_SO(stream, i)->state = SCTP_STREAM_OPEN;\n\n\t\t*evp = sctp_ulpevent_make_stream_reset_event(asoc, flags,\n\t\t\tnums, str_p, GFP_ATOMIC);\n\t} else if (req->type == SCTP_PARAM_RESET_IN_REQUEST) {\n\t\tstruct sctp_strreset_inreq *inreq;\n\t\t__be16 *str_p;\n\n\t\t \n\t\tif (result == SCTP_STRRESET_PERFORMED)\n\t\t\treturn NULL;\n\n\t\tinreq = (struct sctp_strreset_inreq *)req;\n\t\tstr_p = inreq->list_of_streams;\n\t\tnums = (ntohs(inreq->param_hdr.length) - sizeof(*inreq)) /\n\t\t       sizeof(__u16);\n\n\t\tflags |= SCTP_STREAM_RESET_INCOMING_SSN;\n\n\t\t*evp = sctp_ulpevent_make_stream_reset_event(asoc, flags,\n\t\t\tnums, str_p, GFP_ATOMIC);\n\t} else if (req->type == SCTP_PARAM_RESET_TSN_REQUEST) {\n\t\tstruct sctp_strreset_resptsn *resptsn;\n\t\t__u32 stsn, rtsn;\n\n\t\t \n\t\tif (ntohs(param.p->length) != sizeof(*resptsn))\n\t\t\treturn NULL;\n\n\t\tresptsn = (struct sctp_strreset_resptsn *)resp;\n\t\tstsn = ntohl(resptsn->senders_next_tsn);\n\t\trtsn = ntohl(resptsn->receivers_next_tsn);\n\n\t\tif (result == SCTP_STRRESET_PERFORMED) {\n\t\t\t__u32 mtsn = sctp_tsnmap_get_max_tsn_seen(\n\t\t\t\t\t\t&asoc->peer.tsn_map);\n\t\t\tLIST_HEAD(temp);\n\n\t\t\tasoc->stream.si->report_ftsn(&asoc->ulpq, mtsn);\n\n\t\t\tsctp_tsnmap_init(&asoc->peer.tsn_map,\n\t\t\t\t\t SCTP_TSN_MAP_INITIAL,\n\t\t\t\t\t stsn, GFP_ATOMIC);\n\n\t\t\t \n\t\t\tlist_splice_init(&asoc->outqueue.out_chunk_list, &temp);\n\t\t\tsctp_outq_free(&asoc->outqueue);\n\t\t\tlist_splice_init(&temp, &asoc->outqueue.out_chunk_list);\n\n\t\t\tasoc->next_tsn = rtsn;\n\t\t\tasoc->ctsn_ack_point = asoc->next_tsn - 1;\n\t\t\tasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\n\n\t\t\tfor (i = 0; i < stream->outcnt; i++) {\n\t\t\t\tSCTP_SO(stream, i)->mid = 0;\n\t\t\t\tSCTP_SO(stream, i)->mid_uo = 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < stream->incnt; i++)\n\t\t\t\tSCTP_SI(stream, i)->mid = 0;\n\t\t}\n\n\t\tfor (i = 0; i < stream->outcnt; i++)\n\t\t\tSCTP_SO(stream, i)->state = SCTP_STREAM_OPEN;\n\n\t\t*evp = sctp_ulpevent_make_assoc_reset_event(asoc, flags,\n\t\t\tstsn, rtsn, GFP_ATOMIC);\n\t} else if (req->type == SCTP_PARAM_RESET_ADD_OUT_STREAMS) {\n\t\tstruct sctp_strreset_addstrm *addstrm;\n\t\t__u16 number;\n\n\t\taddstrm = (struct sctp_strreset_addstrm *)req;\n\t\tnums = ntohs(addstrm->number_of_streams);\n\t\tnumber = stream->outcnt - nums;\n\n\t\tif (result == SCTP_STRRESET_PERFORMED) {\n\t\t\tfor (i = number; i < stream->outcnt; i++)\n\t\t\t\tSCTP_SO(stream, i)->state = SCTP_STREAM_OPEN;\n\t\t} else {\n\t\t\tsctp_stream_shrink_out(stream, number);\n\t\t\tstream->outcnt = number;\n\t\t}\n\n\t\t*evp = sctp_ulpevent_make_stream_change_event(asoc, flags,\n\t\t\t0, nums, GFP_ATOMIC);\n\t} else if (req->type == SCTP_PARAM_RESET_ADD_IN_STREAMS) {\n\t\tstruct sctp_strreset_addstrm *addstrm;\n\n\t\t \n\t\tif (result == SCTP_STRRESET_PERFORMED)\n\t\t\treturn NULL;\n\n\t\taddstrm = (struct sctp_strreset_addstrm *)req;\n\t\tnums = ntohs(addstrm->number_of_streams);\n\n\t\t*evp = sctp_ulpevent_make_stream_change_event(asoc, flags,\n\t\t\tnums, 0, GFP_ATOMIC);\n\t}\n\n\tasoc->strreset_outstanding--;\n\tasoc->strreset_outseq++;\n\n\t \n\tif (!asoc->strreset_outstanding) {\n\t\tt = asoc->strreset_chunk->transport;\n\t\tif (del_timer(&t->reconf_timer))\n\t\t\tsctp_transport_put(t);\n\n\t\tsctp_chunk_put(asoc->strreset_chunk);\n\t\tasoc->strreset_chunk = NULL;\n\t}\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}