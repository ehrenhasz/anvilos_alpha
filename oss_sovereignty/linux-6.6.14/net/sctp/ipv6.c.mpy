{
  "module_name": "ipv6.c",
  "hash_id": "68f43b1fde61a9125569840f8d1e479b3d614da636ec910f481701cdb3f0238c",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/ipv6.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/ipsec.h>\n#include <linux/slab.h>\n\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n#include <linux/seq_file.h>\n\n#include <net/protocol.h>\n#include <net/ndisc.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/inet_common.h>\n#include <net/inet_ecn.h>\n#include <net/sctp/sctp.h>\n#include <net/udp_tunnel.h>\n\n#include <linux/uaccess.h>\n\nstatic inline int sctp_v6_addr_match_len(union sctp_addr *s1,\n\t\t\t\t\t union sctp_addr *s2);\nstatic void sctp_v6_to_addr(union sctp_addr *addr, struct in6_addr *saddr,\n\t\t\t      __be16 port);\nstatic int sctp_v6_cmp_addr(const union sctp_addr *addr1,\n\t\t\t    const union sctp_addr *addr2);\n\n \nstatic int sctp_inet6addr_event(struct notifier_block *this, unsigned long ev,\n\t\t\t\tvoid *ptr)\n{\n\tstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\n\tstruct sctp_sockaddr_entry *addr = NULL;\n\tstruct sctp_sockaddr_entry *temp;\n\tstruct net *net = dev_net(ifa->idev->dev);\n\tint found = 0;\n\n\tswitch (ev) {\n\tcase NETDEV_UP:\n\t\taddr = kzalloc(sizeof(*addr), GFP_ATOMIC);\n\t\tif (addr) {\n\t\t\taddr->a.v6.sin6_family = AF_INET6;\n\t\t\taddr->a.v6.sin6_addr = ifa->addr;\n\t\t\taddr->a.v6.sin6_scope_id = ifa->idev->dev->ifindex;\n\t\t\taddr->valid = 1;\n\t\t\tspin_lock_bh(&net->sctp.local_addr_lock);\n\t\t\tlist_add_tail_rcu(&addr->list, &net->sctp.local_addr_list);\n\t\t\tsctp_addr_wq_mgmt(net, addr, SCTP_ADDR_NEW);\n\t\t\tspin_unlock_bh(&net->sctp.local_addr_lock);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tspin_lock_bh(&net->sctp.local_addr_lock);\n\t\tlist_for_each_entry_safe(addr, temp,\n\t\t\t\t\t&net->sctp.local_addr_list, list) {\n\t\t\tif (addr->a.sa.sa_family == AF_INET6 &&\n\t\t\t    ipv6_addr_equal(&addr->a.v6.sin6_addr,\n\t\t\t\t\t    &ifa->addr) &&\n\t\t\t    addr->a.v6.sin6_scope_id == ifa->idev->dev->ifindex) {\n\t\t\t\tsctp_addr_wq_mgmt(net, addr, SCTP_ADDR_DEL);\n\t\t\t\tfound = 1;\n\t\t\t\taddr->valid = 0;\n\t\t\t\tlist_del_rcu(&addr->list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&net->sctp.local_addr_lock);\n\t\tif (found)\n\t\t\tkfree_rcu(addr, rcu);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block sctp_inet6addr_notifier = {\n\t.notifier_call = sctp_inet6addr_event,\n};\n\nstatic void sctp_v6_err_handle(struct sctp_transport *t, struct sk_buff *skb,\n\t\t\t       __u8 type, __u8 code, __u32 info)\n{\n\tstruct sctp_association *asoc = t->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct ipv6_pinfo *np;\n\tint err = 0;\n\n\tswitch (type) {\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tif (ip6_sk_accept_pmtu(sk))\n\t\t\tsctp_icmp_frag_needed(sk, asoc, t, info);\n\t\treturn;\n\tcase ICMPV6_PARAMPROB:\n\t\tif (ICMPV6_UNK_NEXTHDR == code) {\n\t\t\tsctp_icmp_proto_unreachable(sk, asoc, t);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase NDISC_REDIRECT:\n\t\tsctp_icmp_redirect(sk, t, skb);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnp = inet6_sk(sk);\n\ticmpv6_err_convert(type, code, &err);\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tsk->sk_err = err;\n\t\tsk_error_report(sk);\n\t} else {\n\t\tWRITE_ONCE(sk->sk_err_soft, err);\n\t}\n}\n\n \nstatic int sctp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sctp_transport *transport;\n\tstruct sctp_association *asoc;\n\t__u16 saveip, savesctp;\n\tstruct sock *sk;\n\n\t \n\tsaveip\t = skb->network_header;\n\tsavesctp = skb->transport_header;\n\tskb_reset_network_header(skb);\n\tskb_set_transport_header(skb, offset);\n\tsk = sctp_err_lookup(net, AF_INET6, skb, sctp_hdr(skb), &asoc, &transport);\n\t \n\tskb->network_header   = saveip;\n\tskb->transport_header = savesctp;\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev), ICMP6_MIB_INERRORS);\n\t\treturn -ENOENT;\n\t}\n\n\tsctp_v6_err_handle(transport, skb, type, code, ntohl(info));\n\tsctp_err_finish(sk, transport);\n\n\treturn 0;\n}\n\nint sctp_udp_v6_err(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sctp_association *asoc;\n\tstruct sctp_transport *t;\n\tstruct icmp6hdr *hdr;\n\t__u32 info = 0;\n\n\tskb->transport_header += sizeof(struct udphdr);\n\tsk = sctp_err_lookup(net, AF_INET6, skb, sctp_hdr(skb), &asoc, &t);\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev), ICMP6_MIB_INERRORS);\n\t\treturn -ENOENT;\n\t}\n\n\tskb->transport_header -= sizeof(struct udphdr);\n\thdr = (struct icmp6hdr *)(skb_network_header(skb) - sizeof(struct icmp6hdr));\n\tif (hdr->icmp6_type == NDISC_REDIRECT) {\n\t\t \n\t\tsctp_err_finish(sk, t);\n\t\treturn 0;\n\t}\n\tif (hdr->icmp6_type == ICMPV6_PKT_TOOBIG)\n\t\tinfo = ntohl(hdr->icmp6_mtu);\n\tsctp_v6_err_handle(t, skb, hdr->icmp6_type, hdr->icmp6_code, info);\n\n\tsctp_err_finish(sk, t);\n\treturn 1;\n}\n\nstatic int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *t)\n{\n\tstruct dst_entry *dst = dst_clone(t->dst);\n\tstruct flowi6 *fl6 = &t->fl.u.ip6;\n\tstruct sock *sk = skb->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t__u8 tclass = np->tclass;\n\t__be32 label;\n\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6->saddr, &fl6->daddr);\n\n\tif (t->dscp & SCTP_DSCP_SET_MASK)\n\t\ttclass = t->dscp & SCTP_DSCP_VAL_MASK;\n\n\tif (INET_ECN_is_capable(tclass))\n\t\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\n\tif (!(t->param_flags & SPP_PMTUD_ENABLE))\n\t\tskb->ignore_df = 1;\n\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\n\tif (!t->encap_port || !sctp_sk(sk)->udp_port) {\n\t\tint res;\n\n\t\tskb_dst_set(skb, dst);\n\t\trcu_read_lock();\n\t\tres = ip6_xmit(sk, skb, fl6, sk->sk_mark,\n\t\t\t       rcu_dereference(np->opt),\n\t\t\t       tclass, sk->sk_priority);\n\t\trcu_read_unlock();\n\t\treturn res;\n\t}\n\n\tif (skb_is_gso(skb))\n\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_UDP_TUNNEL_CSUM;\n\n\tskb->encapsulation = 1;\n\tskb_reset_inner_mac_header(skb);\n\tskb_reset_inner_transport_header(skb);\n\tskb_set_inner_ipproto(skb, IPPROTO_SCTP);\n\tlabel = ip6_make_flowlabel(sock_net(sk), skb, fl6->flowlabel, true, fl6);\n\n\treturn udp_tunnel6_xmit_skb(dst, sk, skb, NULL, &fl6->saddr,\n\t\t\t\t    &fl6->daddr, tclass, ip6_dst_hoplimit(dst),\n\t\t\t\t    label, sctp_sk(sk)->udp_port, t->encap_port, false);\n}\n\n \nstatic void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,\n\t\t\t    struct flowi *fl, struct sock *sk)\n{\n\tstruct sctp_association *asoc = t->asoc;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi _fl;\n\tstruct flowi6 *fl6 = &_fl.u.ip6;\n\tstruct sctp_bind_addr *bp;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sctp_sockaddr_entry *laddr;\n\tunion sctp_addr *daddr = &t->ipaddr;\n\tunion sctp_addr dst_saddr;\n\tstruct in6_addr *final_p, final;\n\tenum sctp_scope scope;\n\t__u8 matchlen = 0;\n\n\tmemset(&_fl, 0, sizeof(_fl));\n\tfl6->daddr = daddr->v6.sin6_addr;\n\tfl6->fl6_dport = daddr->v6.sin6_port;\n\tfl6->flowi6_proto = IPPROTO_SCTP;\n\tif (ipv6_addr_type(&daddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6->flowi6_oif = daddr->v6.sin6_scope_id;\n\telse if (asoc)\n\t\tfl6->flowi6_oif = asoc->base.sk->sk_bound_dev_if;\n\tif (t->flowlabel & SCTP_FLOWLABEL_SET_MASK)\n\t\tfl6->flowlabel = htonl(t->flowlabel & SCTP_FLOWLABEL_VAL_MASK);\n\n\tif (np->sndflow && (fl6->flowlabel & IPV6_FLOWLABEL_MASK)) {\n\t\tstruct ip6_flowlabel *flowlabel;\n\n\t\tflowlabel = fl6_sock_lookup(sk, fl6->flowlabel);\n\t\tif (IS_ERR(flowlabel))\n\t\t\tgoto out;\n\t\tfl6_sock_release(flowlabel);\n\t}\n\n\tpr_debug(\"%s: dst=%pI6 \", __func__, &fl6->daddr);\n\n\tif (asoc)\n\t\tfl6->fl6_sport = htons(asoc->base.bind_addr.port);\n\n\tif (saddr) {\n\t\tfl6->saddr = saddr->v6.sin6_addr;\n\t\tif (!fl6->fl6_sport)\n\t\t\tfl6->fl6_sport = saddr->v6.sin6_port;\n\n\t\tpr_debug(\"src=%pI6 - \", &fl6->saddr);\n\t}\n\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\n\tdst = ip6_dst_lookup_flow(sock_net(sk), sk, fl6, final_p);\n\tif (!asoc || saddr) {\n\t\tt->dst = dst;\n\t\tmemcpy(fl, &_fl, sizeof(_fl));\n\t\tgoto out;\n\t}\n\n\tbp = &asoc->base.bind_addr;\n\tscope = sctp_scope(daddr);\n\t \n\tif (!IS_ERR(dst)) {\n\t\t \n\t\tsctp_v6_to_addr(&dst_saddr, &fl6->saddr, htons(bp->port));\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\t\tif (!laddr->valid || laddr->state == SCTP_ADDR_DEL ||\n\t\t\t    (laddr->state != SCTP_ADDR_SRC &&\n\t\t\t     !asoc->src_out_of_asoc_ok))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif ((laddr->a.sa.sa_family == AF_INET6) &&\n\t\t\t    (sctp_v6_cmp_addr(&dst_saddr, &laddr->a))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tt->dst = dst;\n\t\t\t\tmemcpy(fl, &_fl, sizeof(_fl));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t\t \n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\n\t \n\trcu_read_lock();\n\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\tstruct dst_entry *bdst;\n\t\t__u8 bmatchlen;\n\n\t\tif (!laddr->valid ||\n\t\t    laddr->state != SCTP_ADDR_SRC ||\n\t\t    laddr->a.sa.sa_family != AF_INET6 ||\n\t\t    scope > sctp_scope(&laddr->a))\n\t\t\tcontinue;\n\n\t\tfl6->saddr = laddr->a.v6.sin6_addr;\n\t\tfl6->fl6_sport = laddr->a.v6.sin6_port;\n\t\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n\t\tbdst = ip6_dst_lookup_flow(sock_net(sk), sk, fl6, final_p);\n\n\t\tif (IS_ERR(bdst))\n\t\t\tcontinue;\n\n\t\tif (ipv6_chk_addr(dev_net(bdst->dev),\n\t\t\t\t  &laddr->a.v6.sin6_addr, bdst->dev, 1)) {\n\t\t\tif (!IS_ERR_OR_NULL(dst))\n\t\t\t\tdst_release(dst);\n\t\t\tdst = bdst;\n\t\t\tt->dst = dst;\n\t\t\tmemcpy(fl, &_fl, sizeof(_fl));\n\t\t\tbreak;\n\t\t}\n\n\t\tbmatchlen = sctp_v6_addr_match_len(daddr, &laddr->a);\n\t\tif (matchlen > bmatchlen) {\n\t\t\tdst_release(bdst);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!IS_ERR_OR_NULL(dst))\n\t\t\tdst_release(dst);\n\t\tdst = bdst;\n\t\tmatchlen = bmatchlen;\n\t\tt->dst = dst;\n\t\tmemcpy(fl, &_fl, sizeof(_fl));\n\t}\n\trcu_read_unlock();\n\nout:\n\tif (!IS_ERR_OR_NULL(dst)) {\n\t\tstruct rt6_info *rt;\n\n\t\trt = (struct rt6_info *)dst;\n\t\tt->dst_cookie = rt6_get_cookie(rt);\n\t\tpr_debug(\"rt6_dst:%pI6/%d rt6_src:%pI6\\n\",\n\t\t\t &rt->rt6i_dst.addr, rt->rt6i_dst.plen,\n\t\t\t &fl->u.ip6.saddr);\n\t} else {\n\t\tt->dst = NULL;\n\t\tpr_debug(\"no route\\n\");\n\t}\n}\n\n \nstatic inline int sctp_v6_addr_match_len(union sctp_addr *s1,\n\t\t\t\t\t union sctp_addr *s2)\n{\n\treturn ipv6_addr_diff(&s1->v6.sin6_addr, &s2->v6.sin6_addr);\n}\n\n \nstatic void sctp_v6_get_saddr(struct sctp_sock *sk,\n\t\t\t      struct sctp_transport *t,\n\t\t\t      struct flowi *fl)\n{\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tunion sctp_addr *saddr = &t->saddr;\n\n\tpr_debug(\"%s: asoc:%p dst:%p\\n\", __func__, t->asoc, t->dst);\n\n\tif (t->dst) {\n\t\tsaddr->v6.sin6_family = AF_INET6;\n\t\tsaddr->v6.sin6_addr = fl6->saddr;\n\t}\n}\n\n \nstatic void sctp_v6_copy_addrlist(struct list_head *addrlist,\n\t\t\t\t  struct net_device *dev)\n{\n\tstruct inet6_dev *in6_dev;\n\tstruct inet6_ifaddr *ifp;\n\tstruct sctp_sockaddr_entry *addr;\n\n\trcu_read_lock();\n\tif ((in6_dev = __in6_dev_get(dev)) == NULL) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tread_lock_bh(&in6_dev->lock);\n\tlist_for_each_entry(ifp, &in6_dev->addr_list, if_list) {\n\t\t \n\t\taddr = kzalloc(sizeof(*addr), GFP_ATOMIC);\n\t\tif (addr) {\n\t\t\taddr->a.v6.sin6_family = AF_INET6;\n\t\t\taddr->a.v6.sin6_addr = ifp->addr;\n\t\t\taddr->a.v6.sin6_scope_id = dev->ifindex;\n\t\t\taddr->valid = 1;\n\t\t\tINIT_LIST_HEAD(&addr->list);\n\t\t\tlist_add_tail(&addr->list, addrlist);\n\t\t}\n\t}\n\n\tread_unlock_bh(&in6_dev->lock);\n\trcu_read_unlock();\n}\n\n \nstatic void sctp_v6_copy_ip_options(struct sock *sk, struct sock *newsk)\n{\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\n\tnewnp = inet6_sk(newsk);\n\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tif (!opt)\n\t\t\tpr_err(\"%s: Failed to copy ip options\\n\", __func__);\n\t}\n\tRCU_INIT_POINTER(newnp->opt, opt);\n\trcu_read_unlock();\n}\n\n \nstatic int sctp_v6_ip_options_len(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tint len = 0;\n\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt)\n\t\tlen = opt->opt_flen + opt->opt_nflen;\n\n\trcu_read_unlock();\n\treturn len;\n}\n\n \nstatic void sctp_v6_from_skb(union sctp_addr *addr, struct sk_buff *skb,\n\t\t\t     int is_saddr)\n{\n\t \n\tstruct sctphdr *sh = sctp_hdr(skb);\n\tstruct sockaddr_in6 *sa = &addr->v6;\n\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_flowinfo = 0;  \n\taddr->v6.sin6_scope_id = ((struct inet6_skb_parm *)skb->cb)->iif;\n\n\tif (is_saddr) {\n\t\tsa->sin6_port = sh->source;\n\t\tsa->sin6_addr = ipv6_hdr(skb)->saddr;\n\t} else {\n\t\tsa->sin6_port = sh->dest;\n\t\tsa->sin6_addr = ipv6_hdr(skb)->daddr;\n\t}\n}\n\n \nstatic void sctp_v6_from_sk(union sctp_addr *addr, struct sock *sk)\n{\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_port = 0;\n\taddr->v6.sin6_addr = sk->sk_v6_rcv_saddr;\n}\n\n \nstatic void sctp_v6_to_sk_saddr(union sctp_addr *addr, struct sock *sk)\n{\n\tif (addr->sa.sa_family == AF_INET) {\n\t\tsk->sk_v6_rcv_saddr.s6_addr32[0] = 0;\n\t\tsk->sk_v6_rcv_saddr.s6_addr32[1] = 0;\n\t\tsk->sk_v6_rcv_saddr.s6_addr32[2] = htonl(0x0000ffff);\n\t\tsk->sk_v6_rcv_saddr.s6_addr32[3] =\n\t\t\taddr->v4.sin_addr.s_addr;\n\t} else {\n\t\tsk->sk_v6_rcv_saddr = addr->v6.sin6_addr;\n\t}\n}\n\n \nstatic void sctp_v6_to_sk_daddr(union sctp_addr *addr, struct sock *sk)\n{\n\tif (addr->sa.sa_family == AF_INET) {\n\t\tsk->sk_v6_daddr.s6_addr32[0] = 0;\n\t\tsk->sk_v6_daddr.s6_addr32[1] = 0;\n\t\tsk->sk_v6_daddr.s6_addr32[2] = htonl(0x0000ffff);\n\t\tsk->sk_v6_daddr.s6_addr32[3] = addr->v4.sin_addr.s_addr;\n\t} else {\n\t\tsk->sk_v6_daddr = addr->v6.sin6_addr;\n\t}\n}\n\n \nstatic bool sctp_v6_from_addr_param(union sctp_addr *addr,\n\t\t\t\t    union sctp_addr_param *param,\n\t\t\t\t    __be16 port, int iif)\n{\n\tif (ntohs(param->v6.param_hdr.length) < sizeof(struct sctp_ipv6addr_param))\n\t\treturn false;\n\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_port = port;\n\taddr->v6.sin6_flowinfo = 0;  \n\taddr->v6.sin6_addr = param->v6.addr;\n\taddr->v6.sin6_scope_id = iif;\n\n\treturn true;\n}\n\n \nstatic int sctp_v6_to_addr_param(const union sctp_addr *addr,\n\t\t\t\t union sctp_addr_param *param)\n{\n\tint length = sizeof(struct sctp_ipv6addr_param);\n\n\tparam->v6.param_hdr.type = SCTP_PARAM_IPV6_ADDRESS;\n\tparam->v6.param_hdr.length = htons(length);\n\tparam->v6.addr = addr->v6.sin6_addr;\n\n\treturn length;\n}\n\n \nstatic void sctp_v6_to_addr(union sctp_addr *addr, struct in6_addr *saddr,\n\t\t\t      __be16 port)\n{\n\taddr->sa.sa_family = AF_INET6;\n\taddr->v6.sin6_port = port;\n\taddr->v6.sin6_flowinfo = 0;\n\taddr->v6.sin6_addr = *saddr;\n\taddr->v6.sin6_scope_id = 0;\n}\n\nstatic int __sctp_v6_cmp_addr(const union sctp_addr *addr1,\n\t\t\t      const union sctp_addr *addr2)\n{\n\tif (addr1->sa.sa_family != addr2->sa.sa_family) {\n\t\tif (addr1->sa.sa_family == AF_INET &&\n\t\t    addr2->sa.sa_family == AF_INET6 &&\n\t\t    ipv6_addr_v4mapped(&addr2->v6.sin6_addr) &&\n\t\t    addr2->v6.sin6_addr.s6_addr32[3] ==\n\t\t    addr1->v4.sin_addr.s_addr)\n\t\t\treturn 1;\n\n\t\tif (addr2->sa.sa_family == AF_INET &&\n\t\t    addr1->sa.sa_family == AF_INET6 &&\n\t\t    ipv6_addr_v4mapped(&addr1->v6.sin6_addr) &&\n\t\t    addr1->v6.sin6_addr.s6_addr32[3] ==\n\t\t    addr2->v4.sin_addr.s_addr)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\tif (!ipv6_addr_equal(&addr1->v6.sin6_addr, &addr2->v6.sin6_addr))\n\t\treturn 0;\n\n\t \n\tif ((ipv6_addr_type(&addr1->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL) &&\n\t    addr1->v6.sin6_scope_id && addr2->v6.sin6_scope_id &&\n\t    addr1->v6.sin6_scope_id != addr2->v6.sin6_scope_id)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic int sctp_v6_cmp_addr(const union sctp_addr *addr1,\n\t\t\t    const union sctp_addr *addr2)\n{\n\treturn __sctp_v6_cmp_addr(addr1, addr2) &&\n\t       addr1->v6.sin6_port == addr2->v6.sin6_port;\n}\n\n \nstatic void sctp_v6_inaddr_any(union sctp_addr *addr, __be16 port)\n{\n\tmemset(addr, 0x00, sizeof(union sctp_addr));\n\taddr->v6.sin6_family = AF_INET6;\n\taddr->v6.sin6_port = port;\n}\n\n \nstatic int sctp_v6_is_any(const union sctp_addr *addr)\n{\n\treturn ipv6_addr_any(&addr->v6.sin6_addr);\n}\n\n \nstatic int sctp_v6_available(union sctp_addr *addr, struct sctp_sock *sp)\n{\n\tconst struct in6_addr *in6 = (const struct in6_addr *)&addr->v6.sin6_addr;\n\tstruct sock *sk = &sp->inet.sk;\n\tstruct net *net = sock_net(sk);\n\tstruct net_device *dev = NULL;\n\tint type;\n\n\ttype = ipv6_addr_type(in6);\n\tif (IPV6_ADDR_ANY == type)\n\t\treturn 1;\n\tif (type == IPV6_ADDR_MAPPED) {\n\t\tif (sp && ipv6_only_sock(sctp_opt2sk(sp)))\n\t\t\treturn 0;\n\t\tsctp_v6_map_v4(addr);\n\t\treturn sctp_get_af_specific(AF_INET)->available(addr, sp);\n\t}\n\tif (!(type & IPV6_ADDR_UNICAST))\n\t\treturn 0;\n\n\tif (sk->sk_bound_dev_if) {\n\t\tdev = dev_get_by_index_rcu(net, sk->sk_bound_dev_if);\n\t\tif (!dev)\n\t\t\treturn 0;\n\t}\n\n\treturn ipv6_can_nonlocal_bind(net, &sp->inet) ||\n\t       ipv6_chk_addr(net, in6, dev, 0);\n}\n\n \nstatic int sctp_v6_addr_valid(union sctp_addr *addr,\n\t\t\t      struct sctp_sock *sp,\n\t\t\t      const struct sk_buff *skb)\n{\n\tint ret = ipv6_addr_type(&addr->v6.sin6_addr);\n\n\t \n\tif (ret == IPV6_ADDR_MAPPED) {\n\t\t \n\t\tif (sp && ipv6_only_sock(sctp_opt2sk(sp)))\n\t\t\treturn 0;\n\t\tsctp_v6_map_v4(addr);\n\t\treturn sctp_get_af_specific(AF_INET)->addr_valid(addr, sp, skb);\n\t}\n\n\t \n\tif (!(ret & IPV6_ADDR_UNICAST))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic enum sctp_scope sctp_v6_scope(union sctp_addr *addr)\n{\n\tenum sctp_scope retval;\n\tint v6scope;\n\n\t \n\n\tv6scope = ipv6_addr_scope(&addr->v6.sin6_addr);\n\tswitch (v6scope) {\n\tcase IFA_HOST:\n\t\tretval = SCTP_SCOPE_LOOPBACK;\n\t\tbreak;\n\tcase IFA_LINK:\n\t\tretval = SCTP_SCOPE_LINK;\n\t\tbreak;\n\tcase IFA_SITE:\n\t\tretval = SCTP_SCOPE_PRIVATE;\n\t\tbreak;\n\tdefault:\n\t\tretval = SCTP_SCOPE_GLOBAL;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n \nstatic struct sock *sctp_v6_create_accept_sk(struct sock *sk,\n\t\t\t\t\t     struct sctp_association *asoc,\n\t\t\t\t\t     bool kern)\n{\n\tstruct sock *newsk;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct sctp6_sock *newsctp6sk;\n\n\tnewsk = sk_alloc(sock_net(sk), PF_INET6, GFP_KERNEL, sk->sk_prot, kern);\n\tif (!newsk)\n\t\tgoto out;\n\n\tsock_init_data(NULL, newsk);\n\n\tsctp_copy_sock(newsk, sk, asoc);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tnewsctp6sk = (struct sctp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newsctp6sk->inet6;\n\n\tsctp_sk(newsk)->v4mapped = sctp_sk(sk)->v4mapped;\n\n\tnewnp = inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\tnewnp->ipv6_mc_list = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\tsctp_v6_copy_ip_options(sk, newsk);\n\n\t \n\tsctp_v6_to_sk_daddr(&asoc->peer.primary_addr, newsk);\n\n\tnewsk->sk_v6_rcv_saddr = sk->sk_v6_rcv_saddr;\n\n\tif (newsk->sk_prot->init(newsk)) {\n\t\tsk_common_release(newsk);\n\t\tnewsk = NULL;\n\t}\n\nout:\n\treturn newsk;\n}\n\n \nstatic int sctp_v6_addr_to_user(struct sctp_sock *sp, union sctp_addr *addr)\n{\n\tif (sp->v4mapped) {\n\t\tif (addr->sa.sa_family == AF_INET)\n\t\t\tsctp_v4_map_v6(addr);\n\t} else {\n\t\tif (addr->sa.sa_family == AF_INET6 &&\n\t\t    ipv6_addr_v4mapped(&addr->v6.sin6_addr))\n\t\t\tsctp_v6_map_v4(addr);\n\t}\n\n\tif (addr->sa.sa_family == AF_INET) {\n\t\tmemset(addr->v4.sin_zero, 0, sizeof(addr->v4.sin_zero));\n\t\treturn sizeof(struct sockaddr_in);\n\t}\n\treturn sizeof(struct sockaddr_in6);\n}\n\n \nstatic int sctp_v6_skb_iif(const struct sk_buff *skb)\n{\n\treturn inet6_iif(skb);\n}\n\nstatic int sctp_v6_skb_sdif(const struct sk_buff *skb)\n{\n\treturn inet6_sdif(skb);\n}\n\n \nstatic int sctp_v6_is_ce(const struct sk_buff *skb)\n{\n\treturn *((__u32 *)(ipv6_hdr(skb))) & (__force __u32)htonl(1 << 20);\n}\n\n \nstatic void sctp_v6_seq_dump_addr(struct seq_file *seq, union sctp_addr *addr)\n{\n\tseq_printf(seq, \"%pI6 \", &addr->v6.sin6_addr);\n}\n\nstatic void sctp_v6_ecn_capable(struct sock *sk)\n{\n\tinet6_sk(sk)->tclass |= INET_ECN_ECT_0;\n}\n\n \nstatic void sctp_inet6_event_msgname(struct sctp_ulpevent *event,\n\t\t\t\t     char *msgname, int *addrlen)\n{\n\tunion sctp_addr *addr;\n\tstruct sctp_association *asoc;\n\tunion sctp_addr *paddr;\n\n\tif (!msgname)\n\t\treturn;\n\n\taddr = (union sctp_addr *)msgname;\n\tasoc = event->asoc;\n\tpaddr = &asoc->peer.primary_addr;\n\n\tif (paddr->sa.sa_family == AF_INET) {\n\t\taddr->v4.sin_family = AF_INET;\n\t\taddr->v4.sin_port = htons(asoc->peer.port);\n\t\taddr->v4.sin_addr = paddr->v4.sin_addr;\n\t} else {\n\t\taddr->v6.sin6_family = AF_INET6;\n\t\taddr->v6.sin6_flowinfo = 0;\n\t\tif (ipv6_addr_type(&paddr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\taddr->v6.sin6_scope_id = paddr->v6.sin6_scope_id;\n\t\telse\n\t\t\taddr->v6.sin6_scope_id = 0;\n\t\taddr->v6.sin6_port = htons(asoc->peer.port);\n\t\taddr->v6.sin6_addr = paddr->v6.sin6_addr;\n\t}\n\n\t*addrlen = sctp_v6_addr_to_user(sctp_sk(asoc->base.sk), addr);\n}\n\n \nstatic void sctp_inet6_skb_msgname(struct sk_buff *skb, char *msgname,\n\t\t\t\t   int *addr_len)\n{\n\tunion sctp_addr *addr;\n\tstruct sctphdr *sh;\n\n\tif (!msgname)\n\t\treturn;\n\n\taddr = (union sctp_addr *)msgname;\n\tsh = sctp_hdr(skb);\n\n\tif (ip_hdr(skb)->version == 4) {\n\t\taddr->v4.sin_family = AF_INET;\n\t\taddr->v4.sin_port = sh->source;\n\t\taddr->v4.sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t} else {\n\t\taddr->v6.sin6_family = AF_INET6;\n\t\taddr->v6.sin6_flowinfo = 0;\n\t\taddr->v6.sin6_port = sh->source;\n\t\taddr->v6.sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tif (ipv6_addr_type(&addr->v6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\taddr->v6.sin6_scope_id = sctp_v6_skb_iif(skb);\n\t\telse\n\t\t\taddr->v6.sin6_scope_id = 0;\n\t}\n\n\t*addr_len = sctp_v6_addr_to_user(sctp_sk(skb->sk), addr);\n}\n\n \nstatic int sctp_inet6_af_supported(sa_family_t family, struct sctp_sock *sp)\n{\n\tswitch (family) {\n\tcase AF_INET6:\n\t\treturn 1;\n\t \n\tcase AF_INET:\n\t\tif (!ipv6_only_sock(sctp_opt2sk(sp)))\n\t\t\treturn 1;\n\t\tfallthrough;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic int sctp_inet6_cmp_addr(const union sctp_addr *addr1,\n\t\t\t       const union sctp_addr *addr2,\n\t\t\t       struct sctp_sock *opt)\n{\n\tstruct sock *sk = sctp_opt2sk(opt);\n\tstruct sctp_af *af1, *af2;\n\n\taf1 = sctp_get_af_specific(addr1->sa.sa_family);\n\taf2 = sctp_get_af_specific(addr2->sa.sa_family);\n\n\tif (!af1 || !af2)\n\t\treturn 0;\n\n\t \n\tif (ipv6_only_sock(sk) && af1 != af2)\n\t\treturn 0;\n\n\t \n\tif (sctp_is_any(sk, addr1) || sctp_is_any(sk, addr2))\n\t\treturn 1;\n\n\tif (addr1->sa.sa_family == AF_INET && addr2->sa.sa_family == AF_INET)\n\t\treturn addr1->v4.sin_addr.s_addr == addr2->v4.sin_addr.s_addr;\n\n\treturn __sctp_v6_cmp_addr(addr1, addr2);\n}\n\n \nstatic int sctp_inet6_bind_verify(struct sctp_sock *opt, union sctp_addr *addr)\n{\n\tstruct sctp_af *af;\n\n\t \n\tif (addr->sa.sa_family != AF_INET6)\n\t\taf = sctp_get_af_specific(addr->sa.sa_family);\n\telse {\n\t\tint type = ipv6_addr_type(&addr->v6.sin6_addr);\n\t\tstruct net_device *dev;\n\n\t\tif (type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tstruct net *net;\n\t\t\tif (!addr->v6.sin6_scope_id)\n\t\t\t\treturn 0;\n\t\t\tnet = sock_net(&opt->inet.sk);\n\t\t\trcu_read_lock();\n\t\t\tdev = dev_get_by_index_rcu(net, addr->v6.sin6_scope_id);\n\t\t\tif (!dev || !(ipv6_can_nonlocal_bind(net, &opt->inet) ||\n\t\t\t\t      ipv6_chk_addr(net, &addr->v6.sin6_addr,\n\t\t\t\t\t\t    dev, 0))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\taf = opt->pf->af;\n\t}\n\treturn af->available(addr, opt);\n}\n\n \nstatic int sctp_inet6_send_verify(struct sctp_sock *opt, union sctp_addr *addr)\n{\n\tstruct sctp_af *af = NULL;\n\n\t \n\tif (addr->sa.sa_family != AF_INET6)\n\t\taf = sctp_get_af_specific(addr->sa.sa_family);\n\telse {\n\t\tint type = ipv6_addr_type(&addr->v6.sin6_addr);\n\t\tstruct net_device *dev;\n\n\t\tif (type & IPV6_ADDR_LINKLOCAL) {\n\t\t\tif (!addr->v6.sin6_scope_id)\n\t\t\t\treturn 0;\n\t\t\trcu_read_lock();\n\t\t\tdev = dev_get_by_index_rcu(sock_net(&opt->inet.sk),\n\t\t\t\t\t\t   addr->v6.sin6_scope_id);\n\t\t\trcu_read_unlock();\n\t\t\tif (!dev)\n\t\t\t\treturn 0;\n\t\t}\n\t\taf = opt->pf->af;\n\t}\n\n\treturn af != NULL;\n}\n\n \nstatic int sctp_inet6_supported_addrs(const struct sctp_sock *opt,\n\t\t\t\t      __be16 *types)\n{\n\ttypes[0] = SCTP_PARAM_IPV6_ADDRESS;\n\tif (!opt || !ipv6_only_sock(sctp_opt2sk(opt))) {\n\t\ttypes[1] = SCTP_PARAM_IPV4_ADDRESS;\n\t\treturn 2;\n\t}\n\treturn 1;\n}\n\n \nstatic int sctp_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\tint peer)\n{\n\tint rc;\n\n\trc = inet6_getname(sock, uaddr, peer);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = sctp_v6_addr_to_user(sctp_sk(sock->sk),\n\t\t\t\t\t  (union sctp_addr *)uaddr);\n\n\treturn rc;\n}\n\nstatic const struct proto_ops inet6_seqpacket_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = sctp_inet_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = inet_accept,\n\t.getname\t   = sctp_getname,\n\t.poll\t\t   = sctp_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = sctp_inet_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = inet_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t   = inet6_compat_ioctl,\n#endif\n};\n\nstatic struct inet_protosw sctpv6_seqpacket_protosw = {\n\t.type          = SOCK_SEQPACKET,\n\t.protocol      = IPPROTO_SCTP,\n\t.prot \t       = &sctpv6_prot,\n\t.ops           = &inet6_seqpacket_ops,\n\t.flags         = SCTP_PROTOSW_FLAG\n};\nstatic struct inet_protosw sctpv6_stream_protosw = {\n\t.type          = SOCK_STREAM,\n\t.protocol      = IPPROTO_SCTP,\n\t.prot \t       = &sctpv6_prot,\n\t.ops           = &inet6_seqpacket_ops,\n\t.flags         = SCTP_PROTOSW_FLAG,\n};\n\nstatic int sctp6_rcv(struct sk_buff *skb)\n{\n\tSCTP_INPUT_CB(skb)->encap_port = 0;\n\treturn sctp_rcv(skb) ? -1 : 0;\n}\n\nstatic const struct inet6_protocol sctpv6_protocol = {\n\t.handler      = sctp6_rcv,\n\t.err_handler  = sctp_v6_err,\n\t.flags        = INET6_PROTO_NOPOLICY | INET6_PROTO_FINAL,\n};\n\nstatic struct sctp_af sctp_af_inet6 = {\n\t.sa_family\t   = AF_INET6,\n\t.sctp_xmit\t   = sctp_v6_xmit,\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.get_dst\t   = sctp_v6_get_dst,\n\t.get_saddr\t   = sctp_v6_get_saddr,\n\t.copy_addrlist\t   = sctp_v6_copy_addrlist,\n\t.from_skb\t   = sctp_v6_from_skb,\n\t.from_sk\t   = sctp_v6_from_sk,\n\t.from_addr_param   = sctp_v6_from_addr_param,\n\t.to_addr_param\t   = sctp_v6_to_addr_param,\n\t.cmp_addr\t   = sctp_v6_cmp_addr,\n\t.scope\t\t   = sctp_v6_scope,\n\t.addr_valid\t   = sctp_v6_addr_valid,\n\t.inaddr_any\t   = sctp_v6_inaddr_any,\n\t.is_any\t\t   = sctp_v6_is_any,\n\t.available\t   = sctp_v6_available,\n\t.skb_iif\t   = sctp_v6_skb_iif,\n\t.skb_sdif\t   = sctp_v6_skb_sdif,\n\t.is_ce\t\t   = sctp_v6_is_ce,\n\t.seq_dump_addr\t   = sctp_v6_seq_dump_addr,\n\t.ecn_capable\t   = sctp_v6_ecn_capable,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.ip_options_len\t   = sctp_v6_ip_options_len,\n};\n\nstatic struct sctp_pf sctp_pf_inet6 = {\n\t.event_msgname = sctp_inet6_event_msgname,\n\t.skb_msgname   = sctp_inet6_skb_msgname,\n\t.af_supported  = sctp_inet6_af_supported,\n\t.cmp_addr      = sctp_inet6_cmp_addr,\n\t.bind_verify   = sctp_inet6_bind_verify,\n\t.send_verify   = sctp_inet6_send_verify,\n\t.supported_addrs = sctp_inet6_supported_addrs,\n\t.create_accept_sk = sctp_v6_create_accept_sk,\n\t.addr_to_user  = sctp_v6_addr_to_user,\n\t.to_sk_saddr   = sctp_v6_to_sk_saddr,\n\t.to_sk_daddr   = sctp_v6_to_sk_daddr,\n\t.copy_ip_options = sctp_v6_copy_ip_options,\n\t.af            = &sctp_af_inet6,\n};\n\n \nvoid sctp_v6_pf_init(void)\n{\n\t \n\tsctp_register_pf(&sctp_pf_inet6, PF_INET6);\n\n\t \n\tsctp_register_af(&sctp_af_inet6);\n}\n\nvoid sctp_v6_pf_exit(void)\n{\n\tlist_del(&sctp_af_inet6.list);\n}\n\n \nint sctp_v6_protosw_init(void)\n{\n\tint rc;\n\n\trc = proto_register(&sctpv6_prot, 1);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tinet6_register_protosw(&sctpv6_seqpacket_protosw);\n\tinet6_register_protosw(&sctpv6_stream_protosw);\n\n\treturn 0;\n}\n\nvoid sctp_v6_protosw_exit(void)\n{\n\tinet6_unregister_protosw(&sctpv6_seqpacket_protosw);\n\tinet6_unregister_protosw(&sctpv6_stream_protosw);\n\tproto_unregister(&sctpv6_prot);\n}\n\n\n \nint sctp_v6_add_protocol(void)\n{\n\t \n\tregister_inet6addr_notifier(&sctp_inet6addr_notifier);\n\n\tif (inet6_add_protocol(&sctpv6_protocol, IPPROTO_SCTP) < 0)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\n \nvoid sctp_v6_del_protocol(void)\n{\n\tinet6_del_protocol(&sctpv6_protocol, IPPROTO_SCTP);\n\tunregister_inet6addr_notifier(&sctp_inet6addr_notifier);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}