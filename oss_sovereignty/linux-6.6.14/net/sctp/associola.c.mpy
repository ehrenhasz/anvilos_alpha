{
  "module_name": "associola.c",
  "hash_id": "d710f42f0d547bc01160ae4c0bc544771d82f839703d80922cc92111c796df49",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/associola.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\n \nstatic void sctp_select_active_and_retran_path(struct sctp_association *asoc);\nstatic void sctp_assoc_bh_rcv(struct work_struct *work);\nstatic void sctp_assoc_free_asconf_acks(struct sctp_association *asoc);\nstatic void sctp_assoc_free_asconf_queue(struct sctp_association *asoc);\n\n \n\n \nstatic struct sctp_association *sctp_association_init(\n\t\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sock *sk,\n\t\t\t\t\tenum sctp_scope scope, gfp_t gfp)\n{\n\tstruct sctp_sock *sp;\n\tstruct sctp_paramhdr *p;\n\tint i;\n\n\t \n\tsp = sctp_sk((struct sock *)sk);\n\n\t \n\tasoc->ep = (struct sctp_endpoint *)ep;\n\tasoc->base.sk = (struct sock *)sk;\n\tasoc->base.net = sock_net(sk);\n\n\tsctp_endpoint_hold(asoc->ep);\n\tsock_hold(asoc->base.sk);\n\n\t \n\tasoc->base.type = SCTP_EP_TYPE_ASSOCIATION;\n\n\t \n\trefcount_set(&asoc->base.refcnt, 1);\n\n\t \n\tsctp_bind_addr_init(&asoc->base.bind_addr, ep->base.bind_addr.port);\n\n\tasoc->state = SCTP_STATE_CLOSED;\n\tasoc->cookie_life = ms_to_ktime(sp->assocparams.sasoc_cookie_life);\n\tasoc->user_frag = sp->user_frag;\n\n\t \n\tasoc->max_retrans = sp->assocparams.sasoc_asocmaxrxt;\n\tasoc->pf_retrans  = sp->pf_retrans;\n\tasoc->ps_retrans  = sp->ps_retrans;\n\tasoc->pf_expose   = sp->pf_expose;\n\n\tasoc->rto_initial = msecs_to_jiffies(sp->rtoinfo.srto_initial);\n\tasoc->rto_max = msecs_to_jiffies(sp->rtoinfo.srto_max);\n\tasoc->rto_min = msecs_to_jiffies(sp->rtoinfo.srto_min);\n\n\t \n\tasoc->hbinterval = msecs_to_jiffies(sp->hbinterval);\n\tasoc->probe_interval = msecs_to_jiffies(sp->probe_interval);\n\n\tasoc->encap_port = sp->encap_port;\n\n\t \n\tasoc->pathmaxrxt = sp->pathmaxrxt;\n\n\tasoc->flowlabel = sp->flowlabel;\n\tasoc->dscp = sp->dscp;\n\n\t \n\tasoc->sackdelay = msecs_to_jiffies(sp->sackdelay);\n\tasoc->sackfreq = sp->sackfreq;\n\n\t \n\tasoc->param_flags = sp->param_flags;\n\n\t \n\tasoc->max_burst = sp->max_burst;\n\n\tasoc->subscribe = sp->subscribe;\n\n\t \n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_COOKIE] = asoc->rto_initial;\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_INIT] = asoc->rto_initial;\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T2_SHUTDOWN] = asoc->rto_initial;\n\n\t \n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD]\n\t\t= 5 * asoc->rto_max;\n\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] = asoc->sackdelay;\n\tasoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE] = sp->autoclose * HZ;\n\n\t \n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i)\n\t\ttimer_setup(&asoc->timers[i], sctp_timer_events[i], 0);\n\n\t \n\tasoc->c.sinit_max_instreams = sp->initmsg.sinit_max_instreams;\n\tasoc->c.sinit_num_ostreams  = sp->initmsg.sinit_num_ostreams;\n\tasoc->max_init_attempts\t= sp->initmsg.sinit_max_attempts;\n\n\tasoc->max_init_timeo =\n\t\t msecs_to_jiffies(sp->initmsg.sinit_max_init_timeo);\n\n\t \n\tif ((sk->sk_rcvbuf/2) < SCTP_DEFAULT_MINWINDOW)\n\t\tasoc->rwnd = SCTP_DEFAULT_MINWINDOW;\n\telse\n\t\tasoc->rwnd = sk->sk_rcvbuf/2;\n\n\tasoc->a_rwnd = asoc->rwnd;\n\n\t \n\tasoc->peer.rwnd = SCTP_DEFAULT_MAXWINDOW;\n\n\t \n\tatomic_set(&asoc->rmem_alloc, 0);\n\n\tinit_waitqueue_head(&asoc->wait);\n\n\tasoc->c.my_vtag = sctp_generate_tag(ep);\n\tasoc->c.my_port = ep->base.bind_addr.port;\n\n\tasoc->c.initial_tsn = sctp_generate_tsn(ep);\n\n\tasoc->next_tsn = asoc->c.initial_tsn;\n\n\tasoc->ctsn_ack_point = asoc->next_tsn - 1;\n\tasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\n\tasoc->highest_sacked = asoc->ctsn_ack_point;\n\tasoc->last_cwr_tsn = asoc->ctsn_ack_point;\n\n\t \n\tasoc->addip_serial = asoc->c.initial_tsn;\n\tasoc->strreset_outseq = asoc->c.initial_tsn;\n\n\tINIT_LIST_HEAD(&asoc->addip_chunk_list);\n\tINIT_LIST_HEAD(&asoc->asconf_ack_list);\n\n\t \n\tINIT_LIST_HEAD(&asoc->peer.transport_addr_list);\n\n\t \n\tasoc->peer.sack_needed = 1;\n\tasoc->peer.sack_generation = 1;\n\n\t \n\tsctp_inq_init(&asoc->base.inqueue);\n\tsctp_inq_set_th_handler(&asoc->base.inqueue, sctp_assoc_bh_rcv);\n\n\t \n\tsctp_outq_init(asoc, &asoc->outqueue);\n\n\tsctp_ulpq_init(&asoc->ulpq, asoc);\n\n\tif (sctp_stream_init(&asoc->stream, asoc->c.sinit_num_ostreams, 0, gfp))\n\t\tgoto stream_free;\n\n\t \n\tasoc->pathmtu = sp->pathmtu;\n\tsctp_assoc_update_frag_point(asoc);\n\n\t \n\tasoc->peer.ipv4_address = 1;\n\tif (asoc->base.sk->sk_family == PF_INET6)\n\t\tasoc->peer.ipv6_address = 1;\n\tINIT_LIST_HEAD(&asoc->asocs);\n\n\tasoc->default_stream = sp->default_stream;\n\tasoc->default_ppid = sp->default_ppid;\n\tasoc->default_flags = sp->default_flags;\n\tasoc->default_context = sp->default_context;\n\tasoc->default_timetolive = sp->default_timetolive;\n\tasoc->default_rcv_context = sp->default_rcv_context;\n\n\t \n\tINIT_LIST_HEAD(&asoc->endpoint_shared_keys);\n\tif (sctp_auth_asoc_copy_shkeys(ep, asoc, gfp))\n\t\tgoto stream_free;\n\n\tasoc->active_key_id = ep->active_key_id;\n\tasoc->strreset_enable = ep->strreset_enable;\n\n\t \n\tif (ep->auth_hmacs_list)\n\t\tmemcpy(asoc->c.auth_hmacs, ep->auth_hmacs_list,\n\t\t\tntohs(ep->auth_hmacs_list->param_hdr.length));\n\tif (ep->auth_chunk_list)\n\t\tmemcpy(asoc->c.auth_chunks, ep->auth_chunk_list,\n\t\t\tntohs(ep->auth_chunk_list->param_hdr.length));\n\n\t \n\tp = (struct sctp_paramhdr *)asoc->c.auth_random;\n\tp->type = SCTP_PARAM_RANDOM;\n\tp->length = htons(sizeof(*p) + SCTP_AUTH_RANDOM_LENGTH);\n\tget_random_bytes(p+1, SCTP_AUTH_RANDOM_LENGTH);\n\n\treturn asoc;\n\nstream_free:\n\tsctp_stream_free(&asoc->stream);\n\tsock_put(asoc->base.sk);\n\tsctp_endpoint_put(asoc->ep);\n\treturn NULL;\n}\n\n \nstruct sctp_association *sctp_association_new(const struct sctp_endpoint *ep,\n\t\t\t\t\t      const struct sock *sk,\n\t\t\t\t\t      enum sctp_scope scope, gfp_t gfp)\n{\n\tstruct sctp_association *asoc;\n\n\tasoc = kzalloc(sizeof(*asoc), gfp);\n\tif (!asoc)\n\t\tgoto fail;\n\n\tif (!sctp_association_init(asoc, ep, sk, scope, gfp))\n\t\tgoto fail_init;\n\n\tSCTP_DBG_OBJCNT_INC(assoc);\n\n\tpr_debug(\"Created asoc %p\\n\", asoc);\n\n\treturn asoc;\n\nfail_init:\n\tkfree(asoc);\nfail:\n\treturn NULL;\n}\n\n \nvoid sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\n\t \n\tif (!list_empty(&asoc->asocs)) {\n\t\tlist_del(&asoc->asocs);\n\n\t\t \n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk_acceptq_removed(sk);\n\t}\n\n\t \n\tasoc->base.dead = true;\n\n\t \n\tsctp_outq_free(&asoc->outqueue);\n\n\t \n\tsctp_ulpq_free(&asoc->ulpq);\n\n\t \n\tsctp_inq_free(&asoc->base.inqueue);\n\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\n\t \n\tsctp_stream_free(&asoc->stream);\n\n\tif (asoc->strreset_chunk)\n\t\tsctp_chunk_free(asoc->strreset_chunk);\n\n\t \n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\n\t \n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\n\t \n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\n\t \n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_unhash_transport(transport);\n\t\tsctp_transport_free(transport);\n\t}\n\n\tasoc->peer.transport_count = 0;\n\n\tsctp_asconf_queue_teardown(asoc);\n\n\t \n\tkfree(asoc->asconf_addr_del_pending);\n\n\t \n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\n\t \n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\n\tsctp_association_put(asoc);\n}\n\n \nstatic void sctp_association_destroy(struct sctp_association *asoc)\n{\n\tif (unlikely(!asoc->base.dead)) {\n\t\tWARN(1, \"Attempt to destroy undead association %p!\\n\", asoc);\n\t\treturn;\n\t}\n\n\tsctp_endpoint_put(asoc->ep);\n\tsock_put(asoc->base.sk);\n\n\tif (asoc->assoc_id != 0) {\n\t\tspin_lock_bh(&sctp_assocs_id_lock);\n\t\tidr_remove(&sctp_assocs_id, asoc->assoc_id);\n\t\tspin_unlock_bh(&sctp_assocs_id_lock);\n\t}\n\n\tWARN_ON(atomic_read(&asoc->rmem_alloc));\n\n\tkfree_rcu(asoc, rcu);\n\tSCTP_DBG_OBJCNT_DEC(assoc);\n}\n\n \nvoid sctp_assoc_set_primary(struct sctp_association *asoc,\n\t\t\t    struct sctp_transport *transport)\n{\n\tint changeover = 0;\n\n\t \n\tif (asoc->peer.primary_path != NULL &&\n\t    asoc->peer.primary_path != transport)\n\t\tchangeover = 1 ;\n\n\tasoc->peer.primary_path = transport;\n\tsctp_ulpevent_notify_peer_addr_change(transport,\n\t\t\t\t\t      SCTP_ADDR_MADE_PRIM, 0);\n\n\t \n\tmemcpy(&asoc->peer.primary_addr, &transport->ipaddr,\n\t       sizeof(union sctp_addr));\n\n\t \n\tif ((transport->state == SCTP_ACTIVE) ||\n\t    (transport->state == SCTP_UNKNOWN))\n\t\tasoc->peer.active_path = transport;\n\n\t \n\tif (!asoc->outqueue.outstanding_bytes && !asoc->outqueue.out_qlen)\n\t\treturn;\n\n\tif (transport->cacc.changeover_active)\n\t\ttransport->cacc.cycling_changeover = changeover;\n\n\t \n\ttransport->cacc.changeover_active = changeover;\n\n\t \n\ttransport->cacc.next_tsn_at_change = asoc->next_tsn;\n}\n\n \nvoid sctp_assoc_rm_peer(struct sctp_association *asoc,\n\t\t\tstruct sctp_transport *peer)\n{\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos;\n\tstruct sctp_chunk *ch;\n\n\tpr_debug(\"%s: association:%p addr:%pISpc\\n\",\n\t\t __func__, asoc, &peer->ipaddr.sa);\n\n\t \n\tif (asoc->peer.retran_path == peer)\n\t\tsctp_assoc_update_retran_path(asoc);\n\n\t \n\tlist_del_rcu(&peer->transports);\n\t \n\tsctp_unhash_transport(peer);\n\n\t \n\tpos = asoc->peer.transport_addr_list.next;\n\ttransport = list_entry(pos, struct sctp_transport, transports);\n\n\t \n\tif (asoc->peer.primary_path == peer)\n\t\tsctp_assoc_set_primary(asoc, transport);\n\tif (asoc->peer.active_path == peer)\n\t\tasoc->peer.active_path = transport;\n\tif (asoc->peer.retran_path == peer)\n\t\tasoc->peer.retran_path = transport;\n\tif (asoc->peer.last_data_from == peer)\n\t\tasoc->peer.last_data_from = transport;\n\n\tif (asoc->strreset_chunk &&\n\t    asoc->strreset_chunk->transport == peer) {\n\t\tasoc->strreset_chunk->transport = transport;\n\t\tsctp_transport_reset_reconf_timer(transport);\n\t}\n\n\t \n\tif (asoc->init_last_sent_to == peer)\n\t\tasoc->init_last_sent_to = NULL;\n\n\t \n\tif (asoc->shutdown_last_sent_to == peer)\n\t\tasoc->shutdown_last_sent_to = NULL;\n\n\t \n\tif (asoc->addip_last_asconf &&\n\t    asoc->addip_last_asconf->transport == peer)\n\t\tasoc->addip_last_asconf->transport = NULL;\n\n\t \n\tif (!list_empty(&peer->transmitted)) {\n\t\tstruct sctp_transport *active = asoc->peer.active_path;\n\n\t\t \n\t\tlist_for_each_entry(ch, &peer->transmitted,\n\t\t\t\t\ttransmitted_list) {\n\t\t\tch->transport = NULL;\n\t\t\tch->rtt_in_progress = 0;\n\t\t}\n\n\t\tlist_splice_tail_init(&peer->transmitted,\n\t\t\t\t\t&active->transmitted);\n\n\t\t \n\t\tif (!timer_pending(&active->T3_rtx_timer))\n\t\t\tif (!mod_timer(&active->T3_rtx_timer,\n\t\t\t\t\tjiffies + active->rto))\n\t\t\t\tsctp_transport_hold(active);\n\t}\n\n\tlist_for_each_entry(ch, &asoc->outqueue.out_chunk_list, list)\n\t\tif (ch->transport == peer)\n\t\t\tch->transport = NULL;\n\n\tasoc->peer.transport_count--;\n\n\tsctp_ulpevent_notify_peer_addr_change(peer, SCTP_ADDR_REMOVED, 0);\n\tsctp_transport_free(peer);\n}\n\n \nstruct sctp_transport *sctp_assoc_add_peer(struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_addr *addr,\n\t\t\t\t\t   const gfp_t gfp,\n\t\t\t\t\t   const int peer_state)\n{\n\tstruct sctp_transport *peer;\n\tstruct sctp_sock *sp;\n\tunsigned short port;\n\n\tsp = sctp_sk(asoc->base.sk);\n\n\t \n\tport = ntohs(addr->v4.sin_port);\n\n\tpr_debug(\"%s: association:%p addr:%pISpc state:%d\\n\", __func__,\n\t\t asoc, &addr->sa, peer_state);\n\n\t \n\tif (0 == asoc->peer.port)\n\t\tasoc->peer.port = port;\n\n\t \n\tpeer = sctp_assoc_lookup_paddr(asoc, addr);\n\tif (peer) {\n\t\t \n\t\tif (peer->state == SCTP_UNKNOWN) {\n\t\t\tpeer->state = SCTP_ACTIVE;\n\t\t}\n\t\treturn peer;\n\t}\n\n\tpeer = sctp_transport_new(asoc->base.net, addr, gfp);\n\tif (!peer)\n\t\treturn NULL;\n\n\tsctp_transport_set_owner(peer, asoc);\n\n\t \n\tpeer->hbinterval = asoc->hbinterval;\n\tpeer->probe_interval = asoc->probe_interval;\n\n\tpeer->encap_port = asoc->encap_port;\n\n\t \n\tpeer->pathmaxrxt = asoc->pathmaxrxt;\n\n\t \n\tpeer->pf_retrans = asoc->pf_retrans;\n\t \n\tpeer->ps_retrans = asoc->ps_retrans;\n\n\t \n\tpeer->sackdelay = asoc->sackdelay;\n\tpeer->sackfreq = asoc->sackfreq;\n\n\tif (addr->sa.sa_family == AF_INET6) {\n\t\t__be32 info = addr->v6.sin6_flowinfo;\n\n\t\tif (info) {\n\t\t\tpeer->flowlabel = ntohl(info & IPV6_FLOWLABEL_MASK);\n\t\t\tpeer->flowlabel |= SCTP_FLOWLABEL_SET_MASK;\n\t\t} else {\n\t\t\tpeer->flowlabel = asoc->flowlabel;\n\t\t}\n\t}\n\tpeer->dscp = asoc->dscp;\n\n\t \n\tpeer->param_flags = asoc->param_flags;\n\n\t \n\tsctp_transport_route(peer, NULL, sp);\n\n\t \n\tsctp_assoc_set_pmtu(asoc, asoc->pathmtu ?\n\t\t\t\t  min_t(int, peer->pathmtu, asoc->pathmtu) :\n\t\t\t\t  peer->pathmtu);\n\n\tpeer->pmtu_pending = 0;\n\n\t \n\tsctp_packet_init(&peer->packet, peer, asoc->base.bind_addr.port,\n\t\t\t asoc->peer.port);\n\n\t \n\tpeer->cwnd = min(4*asoc->pathmtu, max_t(__u32, 2*asoc->pathmtu, 4380));\n\n\t \n\tpeer->ssthresh = SCTP_DEFAULT_MAXWINDOW;\n\n\tpeer->partial_bytes_acked = 0;\n\tpeer->flight_size = 0;\n\tpeer->burst_limited = 0;\n\n\t \n\tpeer->rto = asoc->rto_initial;\n\tsctp_max_rto(asoc, peer);\n\n\t \n\tpeer->state = peer_state;\n\n\t \n\tif (sctp_hash_transport(peer)) {\n\t\tsctp_transport_free(peer);\n\t\treturn NULL;\n\t}\n\n\tsctp_transport_pl_reset(peer);\n\n\t \n\tlist_add_tail_rcu(&peer->transports, &asoc->peer.transport_addr_list);\n\tasoc->peer.transport_count++;\n\n\tsctp_ulpevent_notify_peer_addr_change(peer, SCTP_ADDR_ADDED, 0);\n\n\t \n\tif (!asoc->peer.primary_path) {\n\t\tsctp_assoc_set_primary(asoc, peer);\n\t\tasoc->peer.retran_path = peer;\n\t}\n\n\tif (asoc->peer.active_path == asoc->peer.retran_path &&\n\t    peer->state != SCTP_UNCONFIRMED) {\n\t\tasoc->peer.retran_path = peer;\n\t}\n\n\treturn peer;\n}\n\n \nvoid sctp_assoc_del_peer(struct sctp_association *asoc,\n\t\t\t const union sctp_addr *addr)\n{\n\tstruct list_head\t*pos;\n\tstruct list_head\t*temp;\n\tstruct sctp_transport\t*transport;\n\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tif (sctp_cmp_addr_exact(addr, &transport->ipaddr)) {\n\t\t\t \n\t\t\tsctp_assoc_rm_peer(asoc, transport);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstruct sctp_transport *sctp_assoc_lookup_paddr(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_addr *address)\n{\n\tstruct sctp_transport *t;\n\n\t \n\n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\tif (sctp_cmp_addr_exact(address, &t->ipaddr))\n\t\t\treturn t;\n\t}\n\n\treturn NULL;\n}\n\n \nvoid sctp_assoc_del_nonprimary_peers(struct sctp_association *asoc,\n\t\t\t\t     struct sctp_transport *primary)\n{\n\tstruct sctp_transport\t*temp;\n\tstruct sctp_transport\t*t;\n\n\tlist_for_each_entry_safe(t, temp, &asoc->peer.transport_addr_list,\n\t\t\t\t transports) {\n\t\t \n\t\tif (t != primary)\n\t\t\tsctp_assoc_rm_peer(asoc, t);\n\t}\n}\n\n \nvoid sctp_assoc_control_transport(struct sctp_association *asoc,\n\t\t\t\t  struct sctp_transport *transport,\n\t\t\t\t  enum sctp_transport_cmd command,\n\t\t\t\t  sctp_sn_error_t error)\n{\n\tint spc_state = SCTP_ADDR_AVAILABLE;\n\tbool ulp_notify = true;\n\n\t \n\tswitch (command) {\n\tcase SCTP_TRANSPORT_UP:\n\t\t \n\t\tif (transport->state == SCTP_PF &&\n\t\t    asoc->pf_expose != SCTP_PF_EXPOSE_ENABLE)\n\t\t\tulp_notify = false;\n\t\telse if (transport->state == SCTP_UNCONFIRMED &&\n\t\t\t error == SCTP_HEARTBEAT_SUCCESS)\n\t\t\tspc_state = SCTP_ADDR_CONFIRMED;\n\n\t\ttransport->state = SCTP_ACTIVE;\n\t\tsctp_transport_pl_reset(transport);\n\t\tbreak;\n\n\tcase SCTP_TRANSPORT_DOWN:\n\t\t \n\t\tif (transport->state != SCTP_UNCONFIRMED) {\n\t\t\ttransport->state = SCTP_INACTIVE;\n\t\t\tsctp_transport_pl_reset(transport);\n\t\t\tspc_state = SCTP_ADDR_UNREACHABLE;\n\t\t} else {\n\t\t\tsctp_transport_dst_release(transport);\n\t\t\tulp_notify = false;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_TRANSPORT_PF:\n\t\ttransport->state = SCTP_PF;\n\t\tif (asoc->pf_expose != SCTP_PF_EXPOSE_ENABLE)\n\t\t\tulp_notify = false;\n\t\telse\n\t\t\tspc_state = SCTP_ADDR_POTENTIALLY_FAILED;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tif (ulp_notify)\n\t\tsctp_ulpevent_notify_peer_addr_change(transport,\n\t\t\t\t\t\t      spc_state, error);\n\n\t \n\tsctp_select_active_and_retran_path(asoc);\n}\n\n \nvoid sctp_association_hold(struct sctp_association *asoc)\n{\n\trefcount_inc(&asoc->base.refcnt);\n}\n\n \nvoid sctp_association_put(struct sctp_association *asoc)\n{\n\tif (refcount_dec_and_test(&asoc->base.refcnt))\n\t\tsctp_association_destroy(asoc);\n}\n\n \n__u32 sctp_association_get_next_tsn(struct sctp_association *asoc)\n{\n\t \n\t__u32 retval = asoc->next_tsn;\n\tasoc->next_tsn++;\n\tasoc->unack_data++;\n\n\treturn retval;\n}\n\n \nint sctp_cmp_addr_exact(const union sctp_addr *ss1,\n\t\t\tconst union sctp_addr *ss2)\n{\n\tstruct sctp_af *af;\n\n\taf = sctp_get_af_specific(ss1->sa.sa_family);\n\tif (unlikely(!af))\n\t\treturn 0;\n\n\treturn af->cmp_addr(ss1, ss2);\n}\n\n \nstruct sctp_chunk *sctp_get_ecne_prepend(struct sctp_association *asoc)\n{\n\tif (!asoc->need_ecne)\n\t\treturn NULL;\n\n\t \n\treturn sctp_make_ecne(asoc, asoc->last_ecne_tsn);\n}\n\n \nstruct sctp_transport *sctp_assoc_lookup_tsn(struct sctp_association *asoc,\n\t\t\t\t\t     __u32 tsn)\n{\n\tstruct sctp_transport *active;\n\tstruct sctp_transport *match;\n\tstruct sctp_transport *transport;\n\tstruct sctp_chunk *chunk;\n\t__be32 key = htonl(tsn);\n\n\tmatch = NULL;\n\n\t \n\n\t \n\n\tactive = asoc->peer.active_path;\n\n\tlist_for_each_entry(chunk, &active->transmitted,\n\t\t\ttransmitted_list) {\n\n\t\tif (key == chunk->subh.data_hdr->tsn) {\n\t\t\tmatch = active;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\n\t\tif (transport == active)\n\t\t\tcontinue;\n\t\tlist_for_each_entry(chunk, &transport->transmitted,\n\t\t\t\ttransmitted_list) {\n\t\t\tif (key == chunk->subh.data_hdr->tsn) {\n\t\t\t\tmatch = transport;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn match;\n}\n\n \nstatic void sctp_assoc_bh_rcv(struct work_struct *work)\n{\n\tstruct sctp_association *asoc =\n\t\tcontainer_of(work, struct sctp_association,\n\t\t\t     base.inqueue.immediate);\n\tstruct net *net = asoc->base.net;\n\tunion sctp_subtype subtype;\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_chunk *chunk;\n\tstruct sctp_inq *inqueue;\n\tint first_time = 1;\t \n\tint error = 0;\n\tint state;\n\n\t \n\tep = asoc->ep;\n\n\tinqueue = &asoc->base.inqueue;\n\tsctp_association_hold(asoc);\n\twhile (NULL != (chunk = sctp_inq_pop(inqueue))) {\n\t\tstate = asoc->state;\n\t\tsubtype = SCTP_ST_CHUNK(chunk->chunk_hdr->type);\n\n\t\t \n\t\tif (first_time && subtype.chunk == SCTP_CID_AUTH) {\n\t\t\tstruct sctp_chunkhdr *next_hdr;\n\n\t\t\tnext_hdr = sctp_inq_peek(inqueue);\n\t\t\tif (!next_hdr)\n\t\t\t\tgoto normal;\n\n\t\t\t \n\t\t\tif (next_hdr->type == SCTP_CID_COOKIE_ECHO) {\n\t\t\t\tchunk->auth_chunk = skb_clone(chunk->skb,\n\t\t\t\t\t\t\t      GFP_ATOMIC);\n\t\t\t\tchunk->auth = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\nnormal:\n\t\t \n\t\tif (sctp_auth_recv_cid(subtype.chunk, asoc) && !chunk->auth)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sctp_chunk_is_data(chunk))\n\t\t\tasoc->peer.last_data_from = chunk->transport;\n\t\telse {\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_INCTRLCHUNKS);\n\t\t\tasoc->stats.ictrlchunks++;\n\t\t\tif (chunk->chunk_hdr->type == SCTP_CID_SACK)\n\t\t\t\tasoc->stats.isacks++;\n\t\t}\n\n\t\tif (chunk->transport)\n\t\t\tchunk->transport->last_time_heard = ktime_get();\n\n\t\t \n\t\terror = sctp_do_sm(net, SCTP_EVENT_T_CHUNK, subtype,\n\t\t\t\t   state, ep, asoc, chunk, GFP_ATOMIC);\n\n\t\t \n\t\tif (asoc->base.dead)\n\t\t\tbreak;\n\n\t\t \n\t\tif (error && chunk)\n\t\t\tchunk->pdiscard = 1;\n\n\t\tif (first_time)\n\t\t\tfirst_time = 0;\n\t}\n\tsctp_association_put(asoc);\n}\n\n \nvoid sctp_assoc_migrate(struct sctp_association *assoc, struct sock *newsk)\n{\n\tstruct sctp_sock *newsp = sctp_sk(newsk);\n\tstruct sock *oldsk = assoc->base.sk;\n\n\t \n\tlist_del_init(&assoc->asocs);\n\n\t \n\tif (sctp_style(oldsk, TCP))\n\t\tsk_acceptq_removed(oldsk);\n\n\t \n\tsctp_endpoint_put(assoc->ep);\n\tsock_put(assoc->base.sk);\n\n\t \n\tassoc->ep = newsp->ep;\n\tsctp_endpoint_hold(assoc->ep);\n\n\t \n\tassoc->base.sk = newsk;\n\tsock_hold(assoc->base.sk);\n\n\t \n\tsctp_endpoint_add_asoc(newsp->ep, assoc);\n}\n\n \nint sctp_assoc_update(struct sctp_association *asoc,\n\t\t      struct sctp_association *new)\n{\n\tstruct sctp_transport *trans;\n\tstruct list_head *pos, *temp;\n\n\t \n\tasoc->c = new->c;\n\tasoc->peer.rwnd = new->peer.rwnd;\n\tasoc->peer.sack_needed = new->peer.sack_needed;\n\tasoc->peer.auth_capable = new->peer.auth_capable;\n\tasoc->peer.i = new->peer.i;\n\n\tif (!sctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\n\t\t\t      asoc->peer.i.initial_tsn, GFP_ATOMIC))\n\t\treturn -ENOMEM;\n\n\t \n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttrans = list_entry(pos, struct sctp_transport, transports);\n\t\tif (!sctp_assoc_lookup_paddr(new, &trans->ipaddr)) {\n\t\t\tsctp_assoc_rm_peer(asoc, trans);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (asoc->state >= SCTP_STATE_ESTABLISHED)\n\t\t\tsctp_transport_reset(trans);\n\t}\n\n\t \n\tif (asoc->state >= SCTP_STATE_ESTABLISHED) {\n\t\tasoc->next_tsn = new->next_tsn;\n\t\tasoc->ctsn_ack_point = new->ctsn_ack_point;\n\t\tasoc->adv_peer_ack_point = new->adv_peer_ack_point;\n\n\t\t \n\t\tsctp_stream_clear(&asoc->stream);\n\n\t\t \n\t\tsctp_ulpq_flush(&asoc->ulpq);\n\n\t\t \n\t\tasoc->overall_error_count = 0;\n\n\t} else {\n\t\t \n\t\tlist_for_each_entry(trans, &new->peer.transport_addr_list,\n\t\t\t\t    transports)\n\t\t\tif (!sctp_assoc_add_peer(asoc, &trans->ipaddr,\n\t\t\t\t\t\t GFP_ATOMIC, trans->state))\n\t\t\t\treturn -ENOMEM;\n\n\t\tasoc->ctsn_ack_point = asoc->next_tsn - 1;\n\t\tasoc->adv_peer_ack_point = asoc->ctsn_ack_point;\n\n\t\tif (sctp_state(asoc, COOKIE_WAIT))\n\t\t\tsctp_stream_update(&asoc->stream, &new->stream);\n\n\t\t \n\t\tif (sctp_assoc_set_id(asoc, GFP_ATOMIC))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tkfree(asoc->peer.peer_random);\n\tasoc->peer.peer_random = new->peer.peer_random;\n\tnew->peer.peer_random = NULL;\n\n\tkfree(asoc->peer.peer_chunks);\n\tasoc->peer.peer_chunks = new->peer.peer_chunks;\n\tnew->peer.peer_chunks = NULL;\n\n\tkfree(asoc->peer.peer_hmacs);\n\tasoc->peer.peer_hmacs = new->peer.peer_hmacs;\n\tnew->peer.peer_hmacs = NULL;\n\n\treturn sctp_auth_asoc_init_active_key(asoc, GFP_ATOMIC);\n}\n\n \nstatic u8 sctp_trans_score(const struct sctp_transport *trans)\n{\n\tswitch (trans->state) {\n\tcase SCTP_ACTIVE:\n\t\treturn 3;\t \n\tcase SCTP_UNKNOWN:\n\t\treturn 2;\n\tcase SCTP_PF:\n\t\treturn 1;\n\tdefault:  \n\t\treturn 0;\t \n\t}\n}\n\nstatic struct sctp_transport *sctp_trans_elect_tie(struct sctp_transport *trans1,\n\t\t\t\t\t\t   struct sctp_transport *trans2)\n{\n\tif (trans1->error_count > trans2->error_count) {\n\t\treturn trans2;\n\t} else if (trans1->error_count == trans2->error_count &&\n\t\t   ktime_after(trans2->last_time_heard,\n\t\t\t       trans1->last_time_heard)) {\n\t\treturn trans2;\n\t} else {\n\t\treturn trans1;\n\t}\n}\n\nstatic struct sctp_transport *sctp_trans_elect_best(struct sctp_transport *curr,\n\t\t\t\t\t\t    struct sctp_transport *best)\n{\n\tu8 score_curr, score_best;\n\n\tif (best == NULL || curr == best)\n\t\treturn curr;\n\n\tscore_curr = sctp_trans_score(curr);\n\tscore_best = sctp_trans_score(best);\n\n\t \n\tif (score_curr > score_best)\n\t\treturn curr;\n\telse if (score_curr == score_best)\n\t\treturn sctp_trans_elect_tie(best, curr);\n\telse\n\t\treturn best;\n}\n\nvoid sctp_assoc_update_retran_path(struct sctp_association *asoc)\n{\n\tstruct sctp_transport *trans = asoc->peer.retran_path;\n\tstruct sctp_transport *trans_next = NULL;\n\n\t \n\tif (asoc->peer.transport_count == 1)\n\t\treturn;\n\t \n\tif (asoc->peer.active_path == asoc->peer.retran_path &&\n\t    asoc->peer.active_path->state == SCTP_ACTIVE)\n\t\treturn;\n\n\t \n\tfor (trans = list_next_entry(trans, transports); 1;\n\t     trans = list_next_entry(trans, transports)) {\n\t\t \n\t\tif (&trans->transports == &asoc->peer.transport_addr_list)\n\t\t\tcontinue;\n\t\tif (trans->state == SCTP_UNCONFIRMED)\n\t\t\tcontinue;\n\t\ttrans_next = sctp_trans_elect_best(trans, trans_next);\n\t\t \n\t\tif (trans_next->state == SCTP_ACTIVE)\n\t\t\tbreak;\n\t\t \n\t\tif (trans == asoc->peer.retran_path)\n\t\t\tbreak;\n\t}\n\n\tasoc->peer.retran_path = trans_next;\n\n\tpr_debug(\"%s: association:%p updated new path to addr:%pISpc\\n\",\n\t\t __func__, asoc, &asoc->peer.retran_path->ipaddr.sa);\n}\n\nstatic void sctp_select_active_and_retran_path(struct sctp_association *asoc)\n{\n\tstruct sctp_transport *trans, *trans_pri = NULL, *trans_sec = NULL;\n\tstruct sctp_transport *trans_pf = NULL;\n\n\t \n\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t    transports) {\n\t\t \n\t\tif (trans->state == SCTP_INACTIVE ||\n\t\t    trans->state == SCTP_UNCONFIRMED)\n\t\t\tcontinue;\n\t\t \n\t\tif (trans->state == SCTP_PF) {\n\t\t\ttrans_pf = sctp_trans_elect_best(trans, trans_pf);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (trans_pri == NULL ||\n\t\t    ktime_after(trans->last_time_heard,\n\t\t\t\ttrans_pri->last_time_heard)) {\n\t\t\ttrans_sec = trans_pri;\n\t\t\ttrans_pri = trans;\n\t\t} else if (trans_sec == NULL ||\n\t\t\t   ktime_after(trans->last_time_heard,\n\t\t\t\t       trans_sec->last_time_heard)) {\n\t\t\ttrans_sec = trans;\n\t\t}\n\t}\n\n\t \n\tif ((asoc->peer.primary_path->state == SCTP_ACTIVE ||\n\t     asoc->peer.primary_path->state == SCTP_UNKNOWN) &&\n\t     asoc->peer.primary_path != trans_pri) {\n\t\ttrans_sec = trans_pri;\n\t\ttrans_pri = asoc->peer.primary_path;\n\t}\n\n\t \n\tif (trans_sec == NULL)\n\t\ttrans_sec = trans_pri;\n\n\t \n\tif (trans_pri == NULL) {\n\t\ttrans_pri = sctp_trans_elect_best(asoc->peer.active_path, trans_pf);\n\t\ttrans_sec = trans_pri;\n\t}\n\n\t \n\tasoc->peer.active_path = trans_pri;\n\tasoc->peer.retran_path = trans_sec;\n}\n\nstruct sctp_transport *\nsctp_assoc_choose_alter_transport(struct sctp_association *asoc,\n\t\t\t\t  struct sctp_transport *last_sent_to)\n{\n\t \n\tif (last_sent_to == NULL) {\n\t\treturn asoc->peer.active_path;\n\t} else {\n\t\tif (last_sent_to == asoc->peer.retran_path)\n\t\t\tsctp_assoc_update_retran_path(asoc);\n\n\t\treturn asoc->peer.retran_path;\n\t}\n}\n\nvoid sctp_assoc_update_frag_point(struct sctp_association *asoc)\n{\n\tint frag = sctp_mtu_payload(sctp_sk(asoc->base.sk), asoc->pathmtu,\n\t\t\t\t    sctp_datachk_len(&asoc->stream));\n\n\tif (asoc->user_frag)\n\t\tfrag = min_t(int, frag, asoc->user_frag);\n\n\tfrag = min_t(int, frag, SCTP_MAX_CHUNK_LEN -\n\t\t\t\tsctp_datachk_len(&asoc->stream));\n\n\tasoc->frag_point = SCTP_TRUNC4(frag);\n}\n\nvoid sctp_assoc_set_pmtu(struct sctp_association *asoc, __u32 pmtu)\n{\n\tif (asoc->pathmtu != pmtu) {\n\t\tasoc->pathmtu = pmtu;\n\t\tsctp_assoc_update_frag_point(asoc);\n\t}\n\n\tpr_debug(\"%s: asoc:%p, pmtu:%d, frag_point:%d\\n\", __func__, asoc,\n\t\t asoc->pathmtu, asoc->frag_point);\n}\n\n \nvoid sctp_assoc_sync_pmtu(struct sctp_association *asoc)\n{\n\tstruct sctp_transport *t;\n\t__u32 pmtu = 0;\n\n\tif (!asoc)\n\t\treturn;\n\n\t \n\tlist_for_each_entry(t, &asoc->peer.transport_addr_list, transports) {\n\t\tif (t->pmtu_pending && t->dst) {\n\t\t\tsctp_transport_update_pmtu(t,\n\t\t\t\t\t\t   atomic_read(&t->mtu_info));\n\t\t\tt->pmtu_pending = 0;\n\t\t}\n\t\tif (!pmtu || (t->pathmtu < pmtu))\n\t\t\tpmtu = t->pathmtu;\n\t}\n\n\tsctp_assoc_set_pmtu(asoc, pmtu);\n}\n\n \nstatic inline bool sctp_peer_needs_update(struct sctp_association *asoc)\n{\n\tstruct net *net = asoc->base.net;\n\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_ESTABLISHED:\n\tcase SCTP_STATE_SHUTDOWN_PENDING:\n\tcase SCTP_STATE_SHUTDOWN_RECEIVED:\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\tif ((asoc->rwnd > asoc->a_rwnd) &&\n\t\t    ((asoc->rwnd - asoc->a_rwnd) >= max_t(__u32,\n\t\t\t   (asoc->base.sk->sk_rcvbuf >> net->sctp.rwnd_upd_shift),\n\t\t\t   asoc->pathmtu)))\n\t\t\treturn true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\n \nvoid sctp_assoc_rwnd_increase(struct sctp_association *asoc, unsigned int len)\n{\n\tstruct sctp_chunk *sack;\n\tstruct timer_list *timer;\n\n\tif (asoc->rwnd_over) {\n\t\tif (asoc->rwnd_over >= len) {\n\t\t\tasoc->rwnd_over -= len;\n\t\t} else {\n\t\t\tasoc->rwnd += (len - asoc->rwnd_over);\n\t\t\tasoc->rwnd_over = 0;\n\t\t}\n\t} else {\n\t\tasoc->rwnd += len;\n\t}\n\n\t \n\tif (asoc->rwnd_press) {\n\t\tint change = min(asoc->pathmtu, asoc->rwnd_press);\n\t\tasoc->rwnd += change;\n\t\tasoc->rwnd_press -= change;\n\t}\n\n\tpr_debug(\"%s: asoc:%p rwnd increased by %d to (%u, %u) - %u\\n\",\n\t\t __func__, asoc, len, asoc->rwnd, asoc->rwnd_over,\n\t\t asoc->a_rwnd);\n\n\t \n\tif (sctp_peer_needs_update(asoc)) {\n\t\tasoc->a_rwnd = asoc->rwnd;\n\n\t\tpr_debug(\"%s: sending window update SACK- asoc:%p rwnd:%u \"\n\t\t\t \"a_rwnd:%u\\n\", __func__, asoc, asoc->rwnd,\n\t\t\t asoc->a_rwnd);\n\n\t\tsack = sctp_make_sack(asoc);\n\t\tif (!sack)\n\t\t\treturn;\n\n\t\tasoc->peer.sack_needed = 0;\n\n\t\tsctp_outq_tail(&asoc->outqueue, sack, GFP_ATOMIC);\n\n\t\t \n\t\ttimer = &asoc->timers[SCTP_EVENT_TIMEOUT_SACK];\n\t\tif (del_timer(timer))\n\t\t\tsctp_association_put(asoc);\n\t}\n}\n\n \nvoid sctp_assoc_rwnd_decrease(struct sctp_association *asoc, unsigned int len)\n{\n\tint rx_count;\n\tint over = 0;\n\n\tif (unlikely(!asoc->rwnd || asoc->rwnd_over))\n\t\tpr_debug(\"%s: association:%p has asoc->rwnd:%u, \"\n\t\t\t \"asoc->rwnd_over:%u!\\n\", __func__, asoc,\n\t\t\t asoc->rwnd, asoc->rwnd_over);\n\n\tif (asoc->ep->rcvbuf_policy)\n\t\trx_count = atomic_read(&asoc->rmem_alloc);\n\telse\n\t\trx_count = atomic_read(&asoc->base.sk->sk_rmem_alloc);\n\n\t \n\tif (rx_count >= asoc->base.sk->sk_rcvbuf)\n\t\tover = 1;\n\n\tif (asoc->rwnd >= len) {\n\t\tasoc->rwnd -= len;\n\t\tif (over) {\n\t\t\tasoc->rwnd_press += asoc->rwnd;\n\t\t\tasoc->rwnd = 0;\n\t\t}\n\t} else {\n\t\tasoc->rwnd_over += len - asoc->rwnd;\n\t\tasoc->rwnd = 0;\n\t}\n\n\tpr_debug(\"%s: asoc:%p rwnd decreased by %d to (%u, %u, %u)\\n\",\n\t\t __func__, asoc, len, asoc->rwnd, asoc->rwnd_over,\n\t\t asoc->rwnd_press);\n}\n\n \nint sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,\n\t\t\t\t     enum sctp_scope scope, gfp_t gfp)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint flags;\n\n\t \n\tflags = (PF_INET6 == sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;\n\tif (!inet_v6_ipv6only(sk))\n\t\tflags |= SCTP_ADDR4_ALLOWED;\n\tif (asoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (asoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\n\treturn sctp_bind_addr_copy(asoc->base.net,\n\t\t\t\t   &asoc->base.bind_addr,\n\t\t\t\t   &asoc->ep->base.bind_addr,\n\t\t\t\t   scope, gfp, flags);\n}\n\n \nint sctp_assoc_set_bind_addr_from_cookie(struct sctp_association *asoc,\n\t\t\t\t\t struct sctp_cookie *cookie,\n\t\t\t\t\t gfp_t gfp)\n{\n\tstruct sctp_init_chunk *peer_init = (struct sctp_init_chunk *)(cookie + 1);\n\tint var_size2 = ntohs(peer_init->chunk_hdr.length);\n\tint var_size3 = cookie->raw_addr_list_len;\n\t__u8 *raw = (__u8 *)peer_init + var_size2;\n\n\treturn sctp_raw_to_bind_addrs(&asoc->base.bind_addr, raw, var_size3,\n\t\t\t\t      asoc->ep->base.bind_addr.port, gfp);\n}\n\n \nint sctp_assoc_lookup_laddr(struct sctp_association *asoc,\n\t\t\t    const union sctp_addr *laddr)\n{\n\tint found = 0;\n\n\tif ((asoc->base.bind_addr.port == ntohs(laddr->v4.sin_port)) &&\n\t    sctp_bind_addr_match(&asoc->base.bind_addr, laddr,\n\t\t\t\t sctp_sk(asoc->base.sk)))\n\t\tfound = 1;\n\n\treturn found;\n}\n\n \nint sctp_assoc_set_id(struct sctp_association *asoc, gfp_t gfp)\n{\n\tbool preload = gfpflags_allow_blocking(gfp);\n\tint ret;\n\n\t \n\tif (asoc->assoc_id)\n\t\treturn 0;\n\n\tif (preload)\n\t\tidr_preload(gfp);\n\tspin_lock_bh(&sctp_assocs_id_lock);\n\t \n\tret = idr_alloc_cyclic(&sctp_assocs_id, asoc, SCTP_ALL_ASSOC + 1, 0,\n\t\t\t       GFP_NOWAIT);\n\tspin_unlock_bh(&sctp_assocs_id_lock);\n\tif (preload)\n\t\tidr_preload_end();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tasoc->assoc_id = (sctp_assoc_t)ret;\n\treturn 0;\n}\n\n \nstatic void sctp_assoc_free_asconf_queue(struct sctp_association *asoc)\n{\n\tstruct sctp_chunk *asconf;\n\tstruct sctp_chunk *tmp;\n\n\tlist_for_each_entry_safe(asconf, tmp, &asoc->addip_chunk_list, list) {\n\t\tlist_del_init(&asconf->list);\n\t\tsctp_chunk_free(asconf);\n\t}\n}\n\n \nstatic void sctp_assoc_free_asconf_acks(struct sctp_association *asoc)\n{\n\tstruct sctp_chunk *ack;\n\tstruct sctp_chunk *tmp;\n\n\tlist_for_each_entry_safe(ack, tmp, &asoc->asconf_ack_list,\n\t\t\t\ttransmitted_list) {\n\t\tlist_del_init(&ack->transmitted_list);\n\t\tsctp_chunk_free(ack);\n\t}\n}\n\n \nvoid sctp_assoc_clean_asconf_ack_cache(const struct sctp_association *asoc)\n{\n\tstruct sctp_chunk *ack;\n\tstruct sctp_chunk *tmp;\n\n\t \n\tlist_for_each_entry_safe(ack, tmp, &asoc->asconf_ack_list,\n\t\t\t\ttransmitted_list) {\n\t\tif (ack->subh.addip_hdr->serial ==\n\t\t\t\thtonl(asoc->peer.addip_serial))\n\t\t\tbreak;\n\n\t\tlist_del_init(&ack->transmitted_list);\n\t\tsctp_chunk_free(ack);\n\t}\n}\n\n \nstruct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n\n\t \n\tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n\t\tif (sctp_chunk_pending(ack))\n\t\t\tcontinue;\n\t\tif (ack->subh.addip_hdr->serial == serial) {\n\t\t\tsctp_chunk_hold(ack);\n\t\t\treturn ack;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nvoid sctp_asconf_queue_teardown(struct sctp_association *asoc)\n{\n\t \n\tsctp_assoc_free_asconf_acks(asoc);\n\n\t \n\tsctp_assoc_free_asconf_queue(asoc);\n\n\t \n\tif (asoc->addip_last_asconf)\n\t\tsctp_chunk_free(asoc->addip_last_asconf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}