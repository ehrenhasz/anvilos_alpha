{
  "module_name": "inqueue.c",
  "hash_id": "2f3bcd46efe43d8a31ffb1e8e648ddecd14bd174ccf6e8b8bfe502ee19daf28b",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/inqueue.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n\n \nvoid sctp_inq_init(struct sctp_inq *queue)\n{\n\tINIT_LIST_HEAD(&queue->in_chunk_list);\n\tqueue->in_progress = NULL;\n\n\t \n\tINIT_WORK(&queue->immediate, NULL);\n}\n\n \nvoid sctp_inq_free(struct sctp_inq *queue)\n{\n\tstruct sctp_chunk *chunk, *tmp;\n\n\t \n\tlist_for_each_entry_safe(chunk, tmp, &queue->in_chunk_list, list) {\n\t\tlist_del_init(&chunk->list);\n\t\tsctp_chunk_free(chunk);\n\t}\n\n\t \n\tif (queue->in_progress) {\n\t\tsctp_chunk_free(queue->in_progress);\n\t\tqueue->in_progress = NULL;\n\t}\n}\n\n \nvoid sctp_inq_push(struct sctp_inq *q, struct sctp_chunk *chunk)\n{\n\t \n\tif (chunk->rcvr->dead) {\n\t\tsctp_chunk_free(chunk);\n\t\treturn;\n\t}\n\n\t \n\tlist_add_tail(&chunk->list, &q->in_chunk_list);\n\tif (chunk->asoc)\n\t\tchunk->asoc->stats.ipackets++;\n\tq->immediate.func(&q->immediate);\n}\n\n \nstruct sctp_chunkhdr *sctp_inq_peek(struct sctp_inq *queue)\n{\n\tstruct sctp_chunk *chunk;\n\tstruct sctp_chunkhdr *ch = NULL;\n\n\tchunk = queue->in_progress;\n\t \n\tif (chunk->singleton ||\n\t    chunk->end_of_packet ||\n\t    chunk->pdiscard)\n\t\t    return NULL;\n\n\tch = (struct sctp_chunkhdr *)chunk->chunk_end;\n\n\treturn ch;\n}\n\n\n \nstruct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\n{\n\tstruct sctp_chunk *chunk;\n\tstruct sctp_chunkhdr *ch = NULL;\n\n\t \n\n\tchunk = queue->in_progress;\n\tif (chunk) {\n\t\t \n\t\tif (chunk->singleton ||\n\t\t    chunk->end_of_packet ||\n\t\t    chunk->pdiscard) {\n\t\t\tif (chunk->head_skb == chunk->skb) {\n\t\t\t\tchunk->skb = skb_shinfo(chunk->skb)->frag_list;\n\t\t\t\tgoto new_skb;\n\t\t\t}\n\t\t\tif (chunk->skb->next) {\n\t\t\t\tchunk->skb = chunk->skb->next;\n\t\t\t\tgoto new_skb;\n\t\t\t}\n\n\t\t\tif (chunk->head_skb)\n\t\t\t\tchunk->skb = chunk->head_skb;\n\t\t\tsctp_chunk_free(chunk);\n\t\t\tchunk = queue->in_progress = NULL;\n\t\t} else {\n\t\t\t \n\t\t\tch = (struct sctp_chunkhdr *)chunk->chunk_end;\n\t\t\t \n\t\t\tskb_pull(chunk->skb, chunk->chunk_end - chunk->skb->data);\n\t\t\t \n\t\t}\n\t}\n\n\t \n\tif (!chunk) {\n\t\tstruct list_head *entry;\n\nnext_chunk:\n\t\t \n\t\tentry = sctp_list_dequeue(&queue->in_chunk_list);\n\t\tif (!entry)\n\t\t\treturn NULL;\n\n\t\tchunk = list_entry(entry, struct sctp_chunk, list);\n\n\t\tif (skb_is_gso(chunk->skb) && skb_is_gso_sctp(chunk->skb)) {\n\t\t\t \n\t\t\tif (skb_shinfo(chunk->skb)->frag_list)\n\t\t\t\tchunk->head_skb = chunk->skb;\n\n\t\t\t \n\t\t\tif (chunk->head_skb && chunk->skb->data_len == chunk->skb->len)\n\t\t\t\tchunk->skb = skb_shinfo(chunk->skb)->frag_list;\n\n\t\t\tif (WARN_ON(!chunk->skb)) {\n\t\t\t\t__SCTP_INC_STATS(dev_net(chunk->skb->dev), SCTP_MIB_IN_PKT_DISCARDS);\n\t\t\t\tsctp_chunk_free(chunk);\n\t\t\t\tgoto next_chunk;\n\t\t\t}\n\t\t}\n\n\t\tif (chunk->asoc)\n\t\t\tsock_rps_save_rxhash(chunk->asoc->base.sk, chunk->skb);\n\n\t\tqueue->in_progress = chunk;\n\nnew_skb:\n\t\t \n\t\tch = (struct sctp_chunkhdr *)chunk->skb->data;\n\t\tchunk->singleton = 1;\n\t\tchunk->data_accepted = 0;\n\t\tchunk->pdiscard = 0;\n\t\tchunk->auth = 0;\n\t\tchunk->has_asconf = 0;\n\t\tchunk->end_of_packet = 0;\n\t\tif (chunk->head_skb) {\n\t\t\tstruct sctp_input_cb\n\t\t\t\t*cb = SCTP_INPUT_CB(chunk->skb),\n\t\t\t\t*head_cb = SCTP_INPUT_CB(chunk->head_skb);\n\n\t\t\tcb->chunk = head_cb->chunk;\n\t\t\tcb->af = head_cb->af;\n\t\t}\n\t}\n\n\tchunk->chunk_hdr = ch;\n\tchunk->chunk_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\tskb_pull(chunk->skb, sizeof(*ch));\n\tchunk->subh.v = NULL;  \n\n\tif (chunk->chunk_end + sizeof(*ch) <= skb_tail_pointer(chunk->skb)) {\n\t\t \n\t\tchunk->singleton = 0;\n\t} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\n\t\t \n\t\tchunk->pdiscard = 1;\n\t\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\t} else {\n\t\t \n\t\tchunk->end_of_packet = 1;\n\t}\n\n\tpr_debug(\"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\n\",\n\t\t chunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\n\t\t ntohs(chunk->chunk_hdr->length), chunk->skb->len);\n\n\treturn chunk;\n}\n\n \nvoid sctp_inq_set_th_handler(struct sctp_inq *q, work_func_t callback)\n{\n\tINIT_WORK(&q->immediate, callback);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}