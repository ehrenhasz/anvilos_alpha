{
  "module_name": "bind_addr.c",
  "hash_id": "5e04af251064b458aec693e6dc8496a7e91ac07f87c6345f0fb519c550989651",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/bind_addr.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <net/if_inet6.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\n \nstatic int sctp_copy_one_addr(struct net *net, struct sctp_bind_addr *dest,\n\t\t\t      union sctp_addr *addr, enum sctp_scope scope,\n\t\t\t      gfp_t gfp, int flags);\nstatic void sctp_bind_addr_clean(struct sctp_bind_addr *);\n\n \n\n \nint sctp_bind_addr_copy(struct net *net, struct sctp_bind_addr *dest,\n\t\t\tconst struct sctp_bind_addr *src,\n\t\t\tenum sctp_scope scope, gfp_t gfp,\n\t\t\tint flags)\n{\n\tstruct sctp_sockaddr_entry *addr;\n\tint error = 0;\n\n\t \n\tdest->port = src->port;\n\n\t \n\tlist_for_each_entry(addr, &src->address_list, list) {\n\t\terror = sctp_copy_one_addr(net, dest, &addr->a, scope,\n\t\t\t\t\t   gfp, flags);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (list_empty(&dest->address_list) && (SCTP_SCOPE_GLOBAL == scope)) {\n\t\tlist_for_each_entry(addr, &src->address_list, list) {\n\t\t\terror = sctp_copy_one_addr(net, dest, &addr->a,\n\t\t\t\t\t\t   SCTP_SCOPE_LINK, gfp,\n\t\t\t\t\t\t   flags);\n\t\t\tif (error < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (list_empty(&dest->address_list))\n\t\terror = -ENETUNREACH;\n\nout:\n\tif (error)\n\t\tsctp_bind_addr_clean(dest);\n\n\treturn error;\n}\n\n \nint sctp_bind_addr_dup(struct sctp_bind_addr *dest,\n\t\t\tconst struct sctp_bind_addr *src,\n\t\t\tgfp_t gfp)\n{\n\tstruct sctp_sockaddr_entry *addr;\n\tint error = 0;\n\n\t \n\tdest->port = src->port;\n\n\tlist_for_each_entry(addr, &src->address_list, list) {\n\t\terror = sctp_add_bind_addr(dest, &addr->a, sizeof(addr->a),\n\t\t\t\t\t   1, gfp);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}\n\n \nvoid sctp_bind_addr_init(struct sctp_bind_addr *bp, __u16 port)\n{\n\tINIT_LIST_HEAD(&bp->address_list);\n\tbp->port = port;\n}\n\n \nstatic void sctp_bind_addr_clean(struct sctp_bind_addr *bp)\n{\n\tstruct sctp_sockaddr_entry *addr, *temp;\n\n\t \n\tlist_for_each_entry_safe(addr, temp, &bp->address_list, list) {\n\t\tlist_del_rcu(&addr->list);\n\t\tkfree_rcu(addr, rcu);\n\t\tSCTP_DBG_OBJCNT_DEC(addr);\n\t}\n}\n\n \nvoid sctp_bind_addr_free(struct sctp_bind_addr *bp)\n{\n\t \n\tsctp_bind_addr_clean(bp);\n}\n\n \nint sctp_add_bind_addr(struct sctp_bind_addr *bp, union sctp_addr *new,\n\t\t       int new_size, __u8 addr_state, gfp_t gfp)\n{\n\tstruct sctp_sockaddr_entry *addr;\n\n\t \n\taddr = kzalloc(sizeof(*addr), gfp);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&addr->a, new, min_t(size_t, sizeof(*new), new_size));\n\n\t \n\tif (!addr->a.v4.sin_port)\n\t\taddr->a.v4.sin_port = htons(bp->port);\n\n\taddr->state = addr_state;\n\taddr->valid = 1;\n\n\tINIT_LIST_HEAD(&addr->list);\n\n\t \n\tlist_add_tail_rcu(&addr->list, &bp->address_list);\n\tSCTP_DBG_OBJCNT_INC(addr);\n\n\treturn 0;\n}\n\n \nint sctp_del_bind_addr(struct sctp_bind_addr *bp, union sctp_addr *del_addr)\n{\n\tstruct sctp_sockaddr_entry *addr, *temp;\n\tint found = 0;\n\n\t \n\tlist_for_each_entry_safe(addr, temp, &bp->address_list, list) {\n\t\tif (sctp_cmp_addr_exact(&addr->a, del_addr)) {\n\t\t\t \n\t\t\tfound = 1;\n\t\t\taddr->valid = 0;\n\t\t\tlist_del_rcu(&addr->list);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tkfree_rcu(addr, rcu);\n\t\tSCTP_DBG_OBJCNT_DEC(addr);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nunion sctp_params sctp_bind_addrs_to_raw(const struct sctp_bind_addr *bp,\n\t\t\t\t\t int *addrs_len,\n\t\t\t\t\t gfp_t gfp)\n{\n\tunion sctp_params addrparms;\n\tunion sctp_params retval;\n\tint addrparms_len;\n\tunion sctp_addr_param rawaddr;\n\tint len;\n\tstruct sctp_sockaddr_entry *addr;\n\tstruct list_head *pos;\n\tstruct sctp_af *af;\n\n\taddrparms_len = 0;\n\tlen = 0;\n\n\t \n\tlist_for_each(pos, &bp->address_list) {\n\t\tlen += sizeof(union sctp_addr_param);\n\t}\n\n\t \n\tif (len == sizeof(union sctp_addr_param)) {\n\t\tretval.v = NULL;\n\t\tgoto end_raw;\n\t}\n\n\tretval.v = kmalloc(len, gfp);\n\tif (!retval.v)\n\t\tgoto end_raw;\n\n\taddrparms = retval;\n\n\tlist_for_each_entry(addr, &bp->address_list, list) {\n\t\taf = sctp_get_af_specific(addr->a.v4.sin_family);\n\t\tlen = af->to_addr_param(&addr->a, &rawaddr);\n\t\tmemcpy(addrparms.v, &rawaddr, len);\n\t\taddrparms.v += len;\n\t\taddrparms_len += len;\n\t}\n\nend_raw:\n\t*addrs_len = addrparms_len;\n\treturn retval;\n}\n\n \nint sctp_raw_to_bind_addrs(struct sctp_bind_addr *bp, __u8 *raw_addr_list,\n\t\t\t   int addrs_len, __u16 port, gfp_t gfp)\n{\n\tunion sctp_addr_param *rawaddr;\n\tstruct sctp_paramhdr *param;\n\tunion sctp_addr addr;\n\tint retval = 0;\n\tint len;\n\tstruct sctp_af *af;\n\n\t \n\twhile (addrs_len) {\n\t\tparam = (struct sctp_paramhdr *)raw_addr_list;\n\t\trawaddr = (union sctp_addr_param *)raw_addr_list;\n\n\t\taf = sctp_get_af_specific(param_type2af(param->type));\n\t\tif (unlikely(!af) ||\n\t\t    !af->from_addr_param(&addr, rawaddr, htons(port), 0)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (sctp_bind_addr_state(bp, &addr) != -1)\n\t\t\tgoto next;\n\t\tretval = sctp_add_bind_addr(bp, &addr, sizeof(addr),\n\t\t\t\t\t    SCTP_ADDR_SRC, gfp);\n\t\tif (retval)\n\t\t\t \n\t\t\tgoto out_err;\n\nnext:\n\t\tlen = ntohs(param->length);\n\t\taddrs_len -= len;\n\t\traw_addr_list += len;\n\t}\n\n\treturn retval;\n\nout_err:\n\tif (retval)\n\t\tsctp_bind_addr_clean(bp);\n\n\treturn retval;\n}\n\n \n\n \nint sctp_bind_addr_match(struct sctp_bind_addr *bp,\n\t\t\t const union sctp_addr *addr,\n\t\t\t struct sctp_sock *opt)\n{\n\tstruct sctp_sockaddr_entry *laddr;\n\tint match = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\tif (!laddr->valid)\n\t\t\tcontinue;\n\t\tif (opt->pf->cmp_addr(&laddr->a, addr, opt)) {\n\t\t\tmatch = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn match;\n}\n\nint sctp_bind_addrs_check(struct sctp_sock *sp,\n\t\t\t  struct sctp_sock *sp2, int cnt2)\n{\n\tstruct sctp_bind_addr *bp2 = &sp2->ep->base.bind_addr;\n\tstruct sctp_bind_addr *bp = &sp->ep->base.bind_addr;\n\tstruct sctp_sockaddr_entry *laddr, *laddr2;\n\tbool exist = false;\n\tint cnt = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\tlist_for_each_entry_rcu(laddr2, &bp2->address_list, list) {\n\t\t\tif (sp->pf->af->cmp_addr(&laddr->a, &laddr2->a) &&\n\t\t\t    laddr->valid && laddr2->valid) {\n\t\t\t\texist = true;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tbreak;\nnext:\n\t\tcnt++;\n\t}\n\trcu_read_unlock();\n\n\treturn (cnt == cnt2) ? 0 : (exist ? -EEXIST : 1);\n}\n\n \nint sctp_bind_addr_conflict(struct sctp_bind_addr *bp,\n\t\t\t    const union sctp_addr *addr,\n\t\t\t    struct sctp_sock *bp_sp,\n\t\t\t    struct sctp_sock *addr_sp)\n{\n\tstruct sctp_sockaddr_entry *laddr;\n\tint conflict = 0;\n\tstruct sctp_sock *sp;\n\n\t \n\tif (sctp_opt2sk(bp_sp)->sk_family == AF_INET6)\n\t\tsp = bp_sp;\n\telse if (sctp_opt2sk(addr_sp)->sk_family == AF_INET6)\n\t\tsp = addr_sp;\n\telse\n\t\tsp = bp_sp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\tif (!laddr->valid)\n\t\t\tcontinue;\n\n\t\tconflict = sp->pf->cmp_addr(&laddr->a, addr, sp);\n\t\tif (conflict)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn conflict;\n}\n\n \nint sctp_bind_addr_state(const struct sctp_bind_addr *bp,\n\t\t\t const union sctp_addr *addr)\n{\n\tstruct sctp_sockaddr_entry *laddr;\n\tstruct sctp_af *af;\n\n\taf = sctp_get_af_specific(addr->sa.sa_family);\n\tif (unlikely(!af))\n\t\treturn -1;\n\n\tlist_for_each_entry_rcu(laddr, &bp->address_list, list) {\n\t\tif (!laddr->valid)\n\t\t\tcontinue;\n\t\tif (af->cmp_addr(&laddr->a, addr))\n\t\t\treturn laddr->state;\n\t}\n\n\treturn -1;\n}\n\n \nunion sctp_addr *sctp_find_unmatch_addr(struct sctp_bind_addr\t*bp,\n\t\t\t\t\tconst union sctp_addr\t*addrs,\n\t\t\t\t\tint\t\t\taddrcnt,\n\t\t\t\t\tstruct sctp_sock\t*opt)\n{\n\tstruct sctp_sockaddr_entry\t*laddr;\n\tunion sctp_addr\t\t\t*addr;\n\tvoid \t\t\t\t*addr_buf;\n\tstruct sctp_af\t\t\t*af;\n\tint\t\t\t\ti;\n\n\t \n\tlist_for_each_entry(laddr, &bp->address_list, list) {\n\t\taddr_buf = (union sctp_addr *)addrs;\n\t\tfor (i = 0; i < addrcnt; i++) {\n\t\t\taddr = addr_buf;\n\t\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\t\tif (!af)\n\t\t\t\tbreak;\n\n\t\t\tif (opt->pf->cmp_addr(&laddr->a, addr, opt))\n\t\t\t\tbreak;\n\n\t\t\taddr_buf += af->sockaddr_len;\n\t\t}\n\t\tif (i == addrcnt)\n\t\t\treturn &laddr->a;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int sctp_copy_one_addr(struct net *net, struct sctp_bind_addr *dest,\n\t\t\t      union sctp_addr *addr, enum sctp_scope scope,\n\t\t\t      gfp_t gfp, int flags)\n{\n\tint error = 0;\n\n\tif (sctp_is_any(NULL, addr)) {\n\t\terror = sctp_copy_local_addr_list(net, dest, scope, gfp, flags);\n\t} else if (sctp_in_scope(net, addr, scope)) {\n\t\t \n\t\tif ((((AF_INET == addr->sa.sa_family) &&\n\t\t      (flags & SCTP_ADDR4_ALLOWED) &&\n\t\t      (flags & SCTP_ADDR4_PEERSUPP))) ||\n\t\t    (((AF_INET6 == addr->sa.sa_family) &&\n\t\t      (flags & SCTP_ADDR6_ALLOWED) &&\n\t\t      (flags & SCTP_ADDR6_PEERSUPP))))\n\t\t\terror = sctp_add_bind_addr(dest, addr, sizeof(*addr),\n\t\t\t\t\t\t   SCTP_ADDR_SRC, gfp);\n\t}\n\n\treturn error;\n}\n\n \nint sctp_is_any(struct sock *sk, const union sctp_addr *addr)\n{\n\tunsigned short fam = 0;\n\tstruct sctp_af *af;\n\n\t \n\tif (addr->sa.sa_family != AF_UNSPEC)\n\t\tfam = addr->sa.sa_family;\n\telse if (sk)\n\t\tfam = sk->sk_family;\n\n\taf = sctp_get_af_specific(fam);\n\tif (!af)\n\t\treturn 0;\n\n\treturn af->is_any(addr);\n}\n\n \nint sctp_in_scope(struct net *net, const union sctp_addr *addr,\n\t\t  enum sctp_scope scope)\n{\n\tenum sctp_scope addr_scope = sctp_scope(addr);\n\n\t \n\tif (SCTP_SCOPE_UNUSABLE == addr_scope)\n\t\treturn 0;\n\t \n\tswitch (net->sctp.scope_policy) {\n\tcase SCTP_SCOPE_POLICY_DISABLE:\n\t\treturn 1;\n\tcase SCTP_SCOPE_POLICY_ENABLE:\n\t\tif (addr_scope <= scope)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase SCTP_SCOPE_POLICY_PRIVATE:\n\t\tif (addr_scope <= scope || SCTP_SCOPE_PRIVATE == addr_scope)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase SCTP_SCOPE_POLICY_LINK:\n\t\tif (addr_scope <= scope || SCTP_SCOPE_LINK == addr_scope)\n\t\t\treturn 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint sctp_is_ep_boundall(struct sock *sk)\n{\n\tstruct sctp_bind_addr *bp;\n\tstruct sctp_sockaddr_entry *addr;\n\n\tbp = &sctp_sk(sk)->ep->base.bind_addr;\n\tif (sctp_list_single_entry(&bp->address_list)) {\n\t\taddr = list_entry(bp->address_list.next,\n\t\t\t\t  struct sctp_sockaddr_entry, list);\n\t\tif (sctp_is_any(sk, &addr->a))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n\n \nenum sctp_scope sctp_scope(const union sctp_addr *addr)\n{\n\tstruct sctp_af *af;\n\n\taf = sctp_get_af_specific(addr->sa.sa_family);\n\tif (!af)\n\t\treturn SCTP_SCOPE_UNUSABLE;\n\n\treturn af->scope((union sctp_addr *)addr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}