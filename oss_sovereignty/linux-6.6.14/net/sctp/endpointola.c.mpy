{
  "module_name": "endpointola.c",
  "hash_id": "40b8f290b95af0dad097b6776031b5eef6303ae30346f2a4ed77b0fc0bc62247",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/endpointola.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/random.h>\t \n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\n \nstatic void sctp_endpoint_bh_rcv(struct work_struct *work);\n\n \nstatic struct sctp_endpoint *sctp_endpoint_init(struct sctp_endpoint *ep,\n\t\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\t\tgfp_t gfp)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_shared_key *null_key;\n\n\tep->digest = kzalloc(SCTP_SIGNATURE_SIZE, gfp);\n\tif (!ep->digest)\n\t\treturn NULL;\n\n\tep->asconf_enable = net->sctp.addip_enable;\n\tep->auth_enable = net->sctp.auth_enable;\n\tif (ep->auth_enable) {\n\t\tif (sctp_auth_init(ep, gfp))\n\t\t\tgoto nomem;\n\t\tif (ep->asconf_enable) {\n\t\t\tsctp_auth_ep_add_chunkid(ep, SCTP_CID_ASCONF);\n\t\t\tsctp_auth_ep_add_chunkid(ep, SCTP_CID_ASCONF_ACK);\n\t\t}\n\t}\n\n\t \n\t \n\tep->base.type = SCTP_EP_TYPE_SOCKET;\n\n\t \n\trefcount_set(&ep->base.refcnt, 1);\n\tep->base.dead = false;\n\n\t \n\tsctp_inq_init(&ep->base.inqueue);\n\n\t \n\tsctp_inq_set_th_handler(&ep->base.inqueue, sctp_endpoint_bh_rcv);\n\n\t \n\tsctp_bind_addr_init(&ep->base.bind_addr, 0);\n\n\t \n\tINIT_LIST_HEAD(&ep->asocs);\n\n\t \n\tep->sndbuf_policy = net->sctp.sndbuf_policy;\n\n\tsk->sk_data_ready = sctp_data_ready;\n\tsk->sk_write_space = sctp_write_space;\n\tsock_set_flag(sk, SOCK_USE_WRITE_QUEUE);\n\n\t \n\tep->rcvbuf_policy = net->sctp.rcvbuf_policy;\n\n\t \n\tget_random_bytes(ep->secret_key, sizeof(ep->secret_key));\n\n\t \n\tINIT_LIST_HEAD(&ep->endpoint_shared_keys);\n\tnull_key = sctp_auth_shkey_create(0, gfp);\n\tif (!null_key)\n\t\tgoto nomem_shkey;\n\n\tlist_add(&null_key->key_list, &ep->endpoint_shared_keys);\n\n\t \n\tep->prsctp_enable = net->sctp.prsctp_enable;\n\tep->reconf_enable = net->sctp.reconf_enable;\n\tep->ecn_enable = net->sctp.ecn_enable;\n\n\t \n\tep->base.sk = sk;\n\tep->base.net = sock_net(sk);\n\tsock_hold(ep->base.sk);\n\n\treturn ep;\n\nnomem_shkey:\n\tsctp_auth_free(ep);\nnomem:\n\tkfree(ep->digest);\n\treturn NULL;\n\n}\n\n \nstruct sctp_endpoint *sctp_endpoint_new(struct sock *sk, gfp_t gfp)\n{\n\tstruct sctp_endpoint *ep;\n\n\t \n\tep = kzalloc(sizeof(*ep), gfp);\n\tif (!ep)\n\t\tgoto fail;\n\n\tif (!sctp_endpoint_init(ep, sk, gfp))\n\t\tgoto fail_init;\n\n\tSCTP_DBG_OBJCNT_INC(ep);\n\treturn ep;\n\nfail_init:\n\tkfree(ep);\nfail:\n\treturn NULL;\n}\n\n \nvoid sctp_endpoint_add_asoc(struct sctp_endpoint *ep,\n\t\t\t    struct sctp_association *asoc)\n{\n\tstruct sock *sk = ep->base.sk;\n\n\t \n\tif (asoc->temp)\n\t\treturn;\n\n\t \n\tlist_add_tail(&asoc->asocs, &ep->asocs);\n\n\t \n\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\tsk_acceptq_added(sk);\n}\n\n \nvoid sctp_endpoint_free(struct sctp_endpoint *ep)\n{\n\tep->base.dead = true;\n\n\tinet_sk_set_state(ep->base.sk, SCTP_SS_CLOSED);\n\n\t \n\tsctp_unhash_endpoint(ep);\n\n\tsctp_endpoint_put(ep);\n}\n\n \nstatic void sctp_endpoint_destroy_rcu(struct rcu_head *head)\n{\n\tstruct sctp_endpoint *ep = container_of(head, struct sctp_endpoint, rcu);\n\tstruct sock *sk = ep->base.sk;\n\n\tsctp_sk(sk)->ep = NULL;\n\tsock_put(sk);\n\n\tkfree(ep);\n\tSCTP_DBG_OBJCNT_DEC(ep);\n}\n\nstatic void sctp_endpoint_destroy(struct sctp_endpoint *ep)\n{\n\tstruct sock *sk;\n\n\tif (unlikely(!ep->base.dead)) {\n\t\tWARN(1, \"Attempt to destroy undead endpoint %p!\\n\", ep);\n\t\treturn;\n\t}\n\n\t \n\tkfree(ep->digest);\n\n\t \n\tsctp_auth_destroy_keys(&ep->endpoint_shared_keys);\n\tsctp_auth_free(ep);\n\n\t \n\tsctp_inq_free(&ep->base.inqueue);\n\tsctp_bind_addr_free(&ep->base.bind_addr);\n\n\tmemset(ep->secret_key, 0, sizeof(ep->secret_key));\n\n\tsk = ep->base.sk;\n\t \n\tif (sctp_sk(sk)->bind_hash)\n\t\tsctp_put_port(sk);\n\n\tcall_rcu(&ep->rcu, sctp_endpoint_destroy_rcu);\n}\n\n \nint sctp_endpoint_hold(struct sctp_endpoint *ep)\n{\n\treturn refcount_inc_not_zero(&ep->base.refcnt);\n}\n\n \nvoid sctp_endpoint_put(struct sctp_endpoint *ep)\n{\n\tif (refcount_dec_and_test(&ep->base.refcnt))\n\t\tsctp_endpoint_destroy(ep);\n}\n\n \nstruct sctp_endpoint *sctp_endpoint_is_match(struct sctp_endpoint *ep,\n\t\t\t\t\t       struct net *net,\n\t\t\t\t\t       const union sctp_addr *laddr,\n\t\t\t\t\t       int dif, int sdif)\n{\n\tint bound_dev_if = READ_ONCE(ep->base.sk->sk_bound_dev_if);\n\tstruct sctp_endpoint *retval = NULL;\n\n\tif (net_eq(ep->base.net, net) &&\n\t    sctp_sk_bound_dev_eq(net, bound_dev_if, dif, sdif) &&\n\t    (htons(ep->base.bind_addr.port) == laddr->v4.sin_port)) {\n\t\tif (sctp_bind_addr_match(&ep->base.bind_addr, laddr,\n\t\t\t\t\t sctp_sk(ep->base.sk)))\n\t\t\tretval = ep;\n\t}\n\n\treturn retval;\n}\n\n \nstruct sctp_association *sctp_endpoint_lookup_assoc(\n\tconst struct sctp_endpoint *ep,\n\tconst union sctp_addr *paddr,\n\tstruct sctp_transport **transport)\n{\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_transport *t;\n\n\t*transport = NULL;\n\n\t \n\tif (!ep->base.bind_addr.port)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tt = sctp_epaddr_lookup_transport(ep, paddr);\n\tif (!t)\n\t\tgoto out;\n\n\t*transport = t;\n\tasoc = t->asoc;\nout:\n\trcu_read_unlock();\n\treturn asoc;\n}\n\n \nbool sctp_endpoint_is_peeled_off(struct sctp_endpoint *ep,\n\t\t\t\t const union sctp_addr *paddr)\n{\n\tint bound_dev_if = READ_ONCE(ep->base.sk->sk_bound_dev_if);\n\tstruct sctp_sockaddr_entry *addr;\n\tstruct net *net = ep->base.net;\n\tstruct sctp_bind_addr *bp;\n\n\tbp = &ep->base.bind_addr;\n\t \n\tlist_for_each_entry(addr, &bp->address_list, list) {\n\t\tif (sctp_has_association(net, &addr->a, paddr,\n\t\t\t\t\t bound_dev_if, bound_dev_if))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic void sctp_endpoint_bh_rcv(struct work_struct *work)\n{\n\tstruct sctp_endpoint *ep =\n\t\tcontainer_of(work, struct sctp_endpoint,\n\t\t\t     base.inqueue.immediate);\n\tstruct sctp_association *asoc;\n\tstruct sock *sk;\n\tstruct net *net;\n\tstruct sctp_transport *transport;\n\tstruct sctp_chunk *chunk;\n\tstruct sctp_inq *inqueue;\n\tunion sctp_subtype subtype;\n\tenum sctp_state state;\n\tint error = 0;\n\tint first_time = 1;\t \n\n\tif (ep->base.dead)\n\t\treturn;\n\n\tasoc = NULL;\n\tinqueue = &ep->base.inqueue;\n\tsk = ep->base.sk;\n\tnet = sock_net(sk);\n\n\twhile (NULL != (chunk = sctp_inq_pop(inqueue))) {\n\t\tsubtype = SCTP_ST_CHUNK(chunk->chunk_hdr->type);\n\n\t\t \n\t\tif (first_time && (subtype.chunk == SCTP_CID_AUTH)) {\n\t\t\tstruct sctp_chunkhdr *next_hdr;\n\n\t\t\tnext_hdr = sctp_inq_peek(inqueue);\n\t\t\tif (!next_hdr)\n\t\t\t\tgoto normal;\n\n\t\t\t \n\t\t\tif (next_hdr->type == SCTP_CID_COOKIE_ECHO) {\n\t\t\t\tchunk->auth_chunk = skb_clone(chunk->skb,\n\t\t\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tchunk->auth = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\nnormal:\n\t\t \n\t\tif (NULL == chunk->asoc) {\n\t\t\tasoc = sctp_endpoint_lookup_assoc(ep,\n\t\t\t\t\t\t\t  sctp_source(chunk),\n\t\t\t\t\t\t\t  &transport);\n\t\t\tchunk->asoc = asoc;\n\t\t\tchunk->transport = transport;\n\t\t}\n\n\t\tstate = asoc ? asoc->state : SCTP_STATE_CLOSED;\n\t\tif (sctp_auth_recv_cid(subtype.chunk, asoc) && !chunk->auth)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (asoc && sctp_chunk_is_data(chunk))\n\t\t\tasoc->peer.last_data_from = chunk->transport;\n\t\telse {\n\t\t\tSCTP_INC_STATS(ep->base.net, SCTP_MIB_INCTRLCHUNKS);\n\t\t\tif (asoc)\n\t\t\t\tasoc->stats.ictrlchunks++;\n\t\t}\n\n\t\tif (chunk->transport)\n\t\t\tchunk->transport->last_time_heard = ktime_get();\n\n\t\terror = sctp_do_sm(net, SCTP_EVENT_T_CHUNK, subtype, state,\n\t\t\t\t   ep, asoc, chunk, GFP_ATOMIC);\n\n\t\tif (error && chunk)\n\t\t\tchunk->pdiscard = 1;\n\n\t\t \n\t\tif (!sctp_sk(sk)->ep)\n\t\t\tbreak;\n\n\t\tif (first_time)\n\t\t\tfirst_time = 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}