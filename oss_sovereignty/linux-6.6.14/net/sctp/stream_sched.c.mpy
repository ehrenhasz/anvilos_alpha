{
  "module_name": "stream_sched.c",
  "hash_id": "9abeae4402b1805b527877050efdb79ef9fd73d49c511f7f2a70302a0afcec4f",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/stream_sched.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/stream_sched.h>\n\n \nstatic int sctp_sched_fcfs_set(struct sctp_stream *stream, __u16 sid,\n\t\t\t       __u16 value, gfp_t gfp)\n{\n\treturn 0;\n}\n\nstatic int sctp_sched_fcfs_get(struct sctp_stream *stream, __u16 sid,\n\t\t\t       __u16 *value)\n{\n\t*value = 0;\n\treturn 0;\n}\n\nstatic int sctp_sched_fcfs_init(struct sctp_stream *stream)\n{\n\treturn 0;\n}\n\nstatic int sctp_sched_fcfs_init_sid(struct sctp_stream *stream, __u16 sid,\n\t\t\t\t    gfp_t gfp)\n{\n\treturn 0;\n}\n\nstatic void sctp_sched_fcfs_free_sid(struct sctp_stream *stream, __u16 sid)\n{\n}\n\nstatic void sctp_sched_fcfs_enqueue(struct sctp_outq *q,\n\t\t\t\t    struct sctp_datamsg *msg)\n{\n}\n\nstatic struct sctp_chunk *sctp_sched_fcfs_dequeue(struct sctp_outq *q)\n{\n\tstruct sctp_stream *stream = &q->asoc->stream;\n\tstruct sctp_chunk *ch = NULL;\n\tstruct list_head *entry;\n\n\tif (list_empty(&q->out_chunk_list))\n\t\tgoto out;\n\n\tif (stream->out_curr) {\n\t\tch = list_entry(stream->out_curr->ext->outq.next,\n\t\t\t\tstruct sctp_chunk, stream_list);\n\t} else {\n\t\tentry = q->out_chunk_list.next;\n\t\tch = list_entry(entry, struct sctp_chunk, list);\n\t}\n\n\tsctp_sched_dequeue_common(q, ch);\n\nout:\n\treturn ch;\n}\n\nstatic void sctp_sched_fcfs_dequeue_done(struct sctp_outq *q,\n\t\t\t\t\t struct sctp_chunk *chunk)\n{\n}\n\nstatic void sctp_sched_fcfs_sched_all(struct sctp_stream *stream)\n{\n}\n\nstatic void sctp_sched_fcfs_unsched_all(struct sctp_stream *stream)\n{\n}\n\nstatic struct sctp_sched_ops sctp_sched_fcfs = {\n\t.set = sctp_sched_fcfs_set,\n\t.get = sctp_sched_fcfs_get,\n\t.init = sctp_sched_fcfs_init,\n\t.init_sid = sctp_sched_fcfs_init_sid,\n\t.free_sid = sctp_sched_fcfs_free_sid,\n\t.enqueue = sctp_sched_fcfs_enqueue,\n\t.dequeue = sctp_sched_fcfs_dequeue,\n\t.dequeue_done = sctp_sched_fcfs_dequeue_done,\n\t.sched_all = sctp_sched_fcfs_sched_all,\n\t.unsched_all = sctp_sched_fcfs_unsched_all,\n};\n\nstatic void sctp_sched_ops_fcfs_init(void)\n{\n\tsctp_sched_ops_register(SCTP_SS_FCFS, &sctp_sched_fcfs);\n}\n\n \n\nstatic struct sctp_sched_ops *sctp_sched_ops[SCTP_SS_MAX + 1];\n\nvoid sctp_sched_ops_register(enum sctp_sched_type sched,\n\t\t\t     struct sctp_sched_ops *sched_ops)\n{\n\tsctp_sched_ops[sched] = sched_ops;\n}\n\nvoid sctp_sched_ops_init(void)\n{\n\tsctp_sched_ops_fcfs_init();\n\tsctp_sched_ops_prio_init();\n\tsctp_sched_ops_rr_init();\n\tsctp_sched_ops_fc_init();\n\tsctp_sched_ops_wfq_init();\n}\n\nstatic void sctp_sched_free_sched(struct sctp_stream *stream)\n{\n\tstruct sctp_sched_ops *sched = sctp_sched_ops_from_stream(stream);\n\tstruct sctp_stream_out_ext *soute;\n\tint i;\n\n\tsched->unsched_all(stream);\n\tfor (i = 0; i < stream->outcnt; i++) {\n\t\tsoute = SCTP_SO(stream, i)->ext;\n\t\tif (!soute)\n\t\t\tcontinue;\n\t\tsched->free_sid(stream, i);\n\t\t \n\t\tmemset_after(soute, 0, outq);\n\t}\n}\n\nint sctp_sched_set_sched(struct sctp_association *asoc,\n\t\t\t enum sctp_sched_type sched)\n{\n\tstruct sctp_sched_ops *old = asoc->outqueue.sched;\n\tstruct sctp_datamsg *msg = NULL;\n\tstruct sctp_sched_ops *n;\n\tstruct sctp_chunk *ch;\n\tint i, ret = 0;\n\n\tif (sched > SCTP_SS_MAX)\n\t\treturn -EINVAL;\n\n\tn = sctp_sched_ops[sched];\n\tif (old == n)\n\t\treturn ret;\n\n\tif (old)\n\t\tsctp_sched_free_sched(&asoc->stream);\n\n\tasoc->outqueue.sched = n;\n\tn->init(&asoc->stream);\n\tfor (i = 0; i < asoc->stream.outcnt; i++) {\n\t\tif (!SCTP_SO(&asoc->stream, i)->ext)\n\t\t\tcontinue;\n\n\t\tret = n->init_sid(&asoc->stream, i, GFP_ATOMIC);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tlist_for_each_entry(ch, &asoc->outqueue.out_chunk_list, list) {\n\t\tif (ch->msg == msg)\n\t\t\tcontinue;\n\t\tmsg = ch->msg;\n\t\tn->enqueue(&asoc->outqueue, msg);\n\t}\n\n\treturn ret;\n\nerr:\n\tsctp_sched_free_sched(&asoc->stream);\n\tasoc->outqueue.sched = &sctp_sched_fcfs;  \n\n\treturn ret;\n}\n\nint sctp_sched_get_sched(struct sctp_association *asoc)\n{\n\tint i;\n\n\tfor (i = 0; i <= SCTP_SS_MAX; i++)\n\t\tif (asoc->outqueue.sched == sctp_sched_ops[i])\n\t\t\treturn i;\n\n\treturn 0;\n}\n\nint sctp_sched_set_value(struct sctp_association *asoc, __u16 sid,\n\t\t\t __u16 value, gfp_t gfp)\n{\n\tif (sid >= asoc->stream.outcnt)\n\t\treturn -EINVAL;\n\n\tif (!SCTP_SO(&asoc->stream, sid)->ext) {\n\t\tint ret;\n\n\t\tret = sctp_stream_init_ext(&asoc->stream, sid);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn asoc->outqueue.sched->set(&asoc->stream, sid, value, gfp);\n}\n\nint sctp_sched_get_value(struct sctp_association *asoc, __u16 sid,\n\t\t\t __u16 *value)\n{\n\tif (sid >= asoc->stream.outcnt)\n\t\treturn -EINVAL;\n\n\tif (!SCTP_SO(&asoc->stream, sid)->ext)\n\t\treturn 0;\n\n\treturn asoc->outqueue.sched->get(&asoc->stream, sid, value);\n}\n\nvoid sctp_sched_dequeue_done(struct sctp_outq *q, struct sctp_chunk *ch)\n{\n\tif (!list_is_last(&ch->frag_list, &ch->msg->chunks) &&\n\t    !q->asoc->peer.intl_capable) {\n\t\tstruct sctp_stream_out *sout;\n\t\t__u16 sid;\n\n\t\t \n\t\tsid = sctp_chunk_stream_no(ch);\n\t\tsout = SCTP_SO(&q->asoc->stream, sid);\n\t\tq->asoc->stream.out_curr = sout;\n\t\treturn;\n\t}\n\n\tq->asoc->stream.out_curr = NULL;\n\tq->sched->dequeue_done(q, ch);\n}\n\n \nvoid sctp_sched_dequeue_common(struct sctp_outq *q, struct sctp_chunk *ch)\n{\n\tlist_del_init(&ch->list);\n\tlist_del_init(&ch->stream_list);\n\tq->out_qlen -= ch->skb->len;\n}\n\nint sctp_sched_init_sid(struct sctp_stream *stream, __u16 sid, gfp_t gfp)\n{\n\tstruct sctp_sched_ops *sched = sctp_sched_ops_from_stream(stream);\n\tstruct sctp_stream_out_ext *ext = SCTP_SO(stream, sid)->ext;\n\n\tINIT_LIST_HEAD(&ext->outq);\n\treturn sched->init_sid(stream, sid, gfp);\n}\n\nstruct sctp_sched_ops *sctp_sched_ops_from_stream(struct sctp_stream *stream)\n{\n\tstruct sctp_association *asoc;\n\n\tasoc = container_of(stream, struct sctp_association, stream);\n\n\treturn asoc->outqueue.sched;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}