{
  "module_name": "diag.c",
  "hash_id": "6b8e38bcd5e0167f9ccbb8c47600009ecfc696450cfc770b5c2bc61f45c5192f",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/diag.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/inet_diag.h>\n#include <linux/sock_diag.h>\n#include <net/sctp/sctp.h>\n\nstatic void sctp_diag_get_info(struct sock *sk, struct inet_diag_msg *r,\n\t\t\t       void *info);\n\n \nstatic void inet_diag_msg_sctpasoc_fill(struct inet_diag_msg *r,\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tstruct sctp_association *asoc)\n{\n\tunion sctp_addr laddr, paddr;\n\tstruct dst_entry *dst;\n\tstruct timer_list *t3_rtx = &asoc->peer.primary_path->T3_rtx_timer;\n\n\tladdr = list_entry(asoc->base.bind_addr.address_list.next,\n\t\t\t   struct sctp_sockaddr_entry, list)->a;\n\tpaddr = asoc->peer.primary_path->ipaddr;\n\tdst = asoc->peer.primary_path->dst;\n\n\tr->idiag_family = sk->sk_family;\n\tr->id.idiag_sport = htons(asoc->base.bind_addr.port);\n\tr->id.idiag_dport = htons(asoc->peer.port);\n\tr->id.idiag_if = dst ? dst->dev->ifindex : 0;\n\tsock_diag_save_cookie(sk, r->id.idiag_cookie);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (sk->sk_family == AF_INET6) {\n\t\t*(struct in6_addr *)r->id.idiag_src = laddr.v6.sin6_addr;\n\t\t*(struct in6_addr *)r->id.idiag_dst = paddr.v6.sin6_addr;\n\t} else\n#endif\n\t{\n\t\tmemset(&r->id.idiag_src, 0, sizeof(r->id.idiag_src));\n\t\tmemset(&r->id.idiag_dst, 0, sizeof(r->id.idiag_dst));\n\n\t\tr->id.idiag_src[0] = laddr.v4.sin_addr.s_addr;\n\t\tr->id.idiag_dst[0] = paddr.v4.sin_addr.s_addr;\n\t}\n\n\tr->idiag_state = asoc->state;\n\tif (timer_pending(t3_rtx)) {\n\t\tr->idiag_timer = SCTP_EVENT_TIMEOUT_T3_RTX;\n\t\tr->idiag_retrans = asoc->rtx_data_chunks;\n\t\tr->idiag_expires = jiffies_to_msecs(t3_rtx->expires - jiffies);\n\t}\n}\n\nstatic int inet_diag_msg_sctpladdrs_fill(struct sk_buff *skb,\n\t\t\t\t\t struct list_head *address_list)\n{\n\tstruct sctp_sockaddr_entry *laddr;\n\tint addrlen = sizeof(struct sockaddr_storage);\n\tint addrcnt = 0;\n\tstruct nlattr *attr;\n\tvoid *info = NULL;\n\n\tlist_for_each_entry_rcu(laddr, address_list, list)\n\t\taddrcnt++;\n\n\tattr = nla_reserve(skb, INET_DIAG_LOCALS, addrlen * addrcnt);\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tinfo = nla_data(attr);\n\tlist_for_each_entry_rcu(laddr, address_list, list) {\n\t\tmemcpy(info, &laddr->a, sizeof(laddr->a));\n\t\tmemset(info + sizeof(laddr->a), 0, addrlen - sizeof(laddr->a));\n\t\tinfo += addrlen;\n\t}\n\n\treturn 0;\n}\n\nstatic int inet_diag_msg_sctpaddrs_fill(struct sk_buff *skb,\n\t\t\t\t\tstruct sctp_association *asoc)\n{\n\tint addrlen = sizeof(struct sockaddr_storage);\n\tstruct sctp_transport *from;\n\tstruct nlattr *attr;\n\tvoid *info = NULL;\n\n\tattr = nla_reserve(skb, INET_DIAG_PEERS,\n\t\t\t   addrlen * asoc->peer.transport_count);\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tinfo = nla_data(attr);\n\tlist_for_each_entry(from, &asoc->peer.transport_addr_list,\n\t\t\t    transports) {\n\t\tmemcpy(info, &from->ipaddr, sizeof(from->ipaddr));\n\t\tmemset(info + sizeof(from->ipaddr), 0,\n\t\t       addrlen - sizeof(from->ipaddr));\n\t\tinfo += addrlen;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int inet_sctp_diag_fill(struct sock *sk, struct sctp_association *asoc,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       const struct inet_diag_req_v2 *req,\n\t\t\t       struct user_namespace *user_ns,\n\t\t\t       int portid, u32 seq, u16 nlmsg_flags,\n\t\t\t       const struct nlmsghdr *unlh,\n\t\t\t       bool net_admin)\n{\n\tstruct sctp_endpoint *ep = sctp_sk(sk)->ep;\n\tstruct list_head *addr_list;\n\tstruct inet_diag_msg *r;\n\tstruct nlmsghdr  *nlh;\n\tint ext = req->idiag_ext;\n\tstruct sctp_infox infox;\n\tvoid *info = NULL;\n\n\tnlh = nlmsg_put(skb, portid, seq, unlh->nlmsg_type, sizeof(*r),\n\t\t\tnlmsg_flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tr = nlmsg_data(nlh);\n\tBUG_ON(!sk_fullsock(sk));\n\n\tr->idiag_timer = 0;\n\tr->idiag_retrans = 0;\n\tr->idiag_expires = 0;\n\tif (asoc) {\n\t\tinet_diag_msg_sctpasoc_fill(r, sk, asoc);\n\t} else {\n\t\tinet_diag_msg_common_fill(r, sk);\n\t\tr->idiag_state = sk->sk_state;\n\t}\n\n\tif (inet_diag_msg_attrs_fill(sk, skb, r, ext, user_ns, net_admin))\n\t\tgoto errout;\n\n\tif (ext & (1 << (INET_DIAG_SKMEMINFO - 1))) {\n\t\tu32 mem[SK_MEMINFO_VARS];\n\t\tint amt;\n\n\t\tif (asoc && asoc->ep->sndbuf_policy)\n\t\t\tamt = asoc->sndbuf_used;\n\t\telse\n\t\t\tamt = sk_wmem_alloc_get(sk);\n\t\tmem[SK_MEMINFO_WMEM_ALLOC] = amt;\n\t\tif (asoc && asoc->ep->rcvbuf_policy)\n\t\t\tamt = atomic_read(&asoc->rmem_alloc);\n\t\telse\n\t\t\tamt = sk_rmem_alloc_get(sk);\n\t\tmem[SK_MEMINFO_RMEM_ALLOC] = amt;\n\t\tmem[SK_MEMINFO_RCVBUF] = sk->sk_rcvbuf;\n\t\tmem[SK_MEMINFO_SNDBUF] = sk->sk_sndbuf;\n\t\tmem[SK_MEMINFO_FWD_ALLOC] = sk->sk_forward_alloc;\n\t\tmem[SK_MEMINFO_WMEM_QUEUED] = sk->sk_wmem_queued;\n\t\tmem[SK_MEMINFO_OPTMEM] = atomic_read(&sk->sk_omem_alloc);\n\t\tmem[SK_MEMINFO_BACKLOG] = READ_ONCE(sk->sk_backlog.len);\n\t\tmem[SK_MEMINFO_DROPS] = atomic_read(&sk->sk_drops);\n\n\t\tif (nla_put(skb, INET_DIAG_SKMEMINFO, sizeof(mem), &mem) < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif (ext & (1 << (INET_DIAG_INFO - 1))) {\n\t\tstruct nlattr *attr;\n\n\t\tattr = nla_reserve_64bit(skb, INET_DIAG_INFO,\n\t\t\t\t\t sizeof(struct sctp_info),\n\t\t\t\t\t INET_DIAG_PAD);\n\t\tif (!attr)\n\t\t\tgoto errout;\n\n\t\tinfo = nla_data(attr);\n\t}\n\tinfox.sctpinfo = (struct sctp_info *)info;\n\tinfox.asoc = asoc;\n\tsctp_diag_get_info(sk, r, &infox);\n\n\taddr_list = asoc ? &asoc->base.bind_addr.address_list\n\t\t\t : &ep->base.bind_addr.address_list;\n\tif (inet_diag_msg_sctpladdrs_fill(skb, addr_list))\n\t\tgoto errout;\n\n\tif (asoc && (ext & (1 << (INET_DIAG_CONG - 1))))\n\t\tif (nla_put_string(skb, INET_DIAG_CONG, \"reno\") < 0)\n\t\t\tgoto errout;\n\n\tif (asoc && inet_diag_msg_sctpaddrs_fill(skb, asoc))\n\t\tgoto errout;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nerrout:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\n \nstruct sctp_comm_param {\n\tstruct sk_buff *skb;\n\tstruct netlink_callback *cb;\n\tconst struct inet_diag_req_v2 *r;\n\tconst struct nlmsghdr *nlh;\n\tbool net_admin;\n};\n\nstatic size_t inet_assoc_attr_size(struct sctp_association *asoc)\n{\n\tint addrlen = sizeof(struct sockaddr_storage);\n\tint addrcnt = 0;\n\tstruct sctp_sockaddr_entry *laddr;\n\n\tlist_for_each_entry_rcu(laddr, &asoc->base.bind_addr.address_list,\n\t\t\t\tlist)\n\t\taddrcnt++;\n\n\treturn\t  nla_total_size(sizeof(struct sctp_info))\n\t\t+ nla_total_size(addrlen * asoc->peer.transport_count)\n\t\t+ nla_total_size(addrlen * addrcnt)\n\t\t+ nla_total_size(sizeof(struct inet_diag_msg))\n\t\t+ inet_diag_msg_attrs_size()\n\t\t+ nla_total_size(sizeof(struct inet_diag_meminfo))\n\t\t+ 64;\n}\n\nstatic int sctp_sock_dump_one(struct sctp_endpoint *ep, struct sctp_transport *tsp, void *p)\n{\n\tstruct sctp_association *assoc = tsp->asoc;\n\tstruct sctp_comm_param *commp = p;\n\tstruct sock *sk = ep->base.sk;\n\tconst struct inet_diag_req_v2 *req = commp->r;\n\tstruct sk_buff *skb = commp->skb;\n\tstruct sk_buff *rep;\n\tint err;\n\n\terr = sock_diag_check_cookie(sk, req->id.idiag_cookie);\n\tif (err)\n\t\treturn err;\n\n\trep = nlmsg_new(inet_assoc_attr_size(assoc), GFP_KERNEL);\n\tif (!rep)\n\t\treturn -ENOMEM;\n\n\tlock_sock(sk);\n\tif (ep != assoc->ep) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\terr = inet_sctp_diag_fill(sk, assoc, rep, req, sk_user_ns(NETLINK_CB(skb).sk),\n\t\t\t\t  NETLINK_CB(skb).portid, commp->nlh->nlmsg_seq, 0,\n\t\t\t\t  commp->nlh, commp->net_admin);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tgoto out;\n\t}\n\trelease_sock(sk);\n\n\treturn nlmsg_unicast(sock_net(skb->sk)->diag_nlsk, rep, NETLINK_CB(skb).portid);\n\nout:\n\trelease_sock(sk);\n\tkfree_skb(rep);\n\treturn err;\n}\n\nstatic int sctp_sock_dump(struct sctp_endpoint *ep, struct sctp_transport *tsp, void *p)\n{\n\tstruct sctp_comm_param *commp = p;\n\tstruct sock *sk = ep->base.sk;\n\tstruct sk_buff *skb = commp->skb;\n\tstruct netlink_callback *cb = commp->cb;\n\tconst struct inet_diag_req_v2 *r = commp->r;\n\tstruct sctp_association *assoc;\n\tint err = 0;\n\n\tlock_sock(sk);\n\tif (ep != tsp->asoc->ep)\n\t\tgoto release;\n\tlist_for_each_entry(assoc, &ep->asocs, asocs) {\n\t\tif (cb->args[4] < cb->args[1])\n\t\t\tgoto next;\n\n\t\tif (r->id.idiag_sport != htons(assoc->base.bind_addr.port) &&\n\t\t    r->id.idiag_sport)\n\t\t\tgoto next;\n\t\tif (r->id.idiag_dport != htons(assoc->peer.port) &&\n\t\t    r->id.idiag_dport)\n\t\t\tgoto next;\n\n\t\tif (!cb->args[3] &&\n\t\t    inet_sctp_diag_fill(sk, NULL, skb, r,\n\t\t\t\t\tsk_user_ns(NETLINK_CB(cb->skb).sk),\n\t\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq,\n\t\t\t\t\tNLM_F_MULTI, cb->nlh,\n\t\t\t\t\tcommp->net_admin) < 0) {\n\t\t\terr = 1;\n\t\t\tgoto release;\n\t\t}\n\t\tcb->args[3] = 1;\n\n\t\tif (inet_sctp_diag_fill(sk, assoc, skb, r,\n\t\t\t\t\tsk_user_ns(NETLINK_CB(cb->skb).sk),\n\t\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, 0, cb->nlh,\n\t\t\t\t\tcommp->net_admin) < 0) {\n\t\t\terr = 1;\n\t\t\tgoto release;\n\t\t}\nnext:\n\t\tcb->args[4]++;\n\t}\n\tcb->args[1] = 0;\n\tcb->args[3] = 0;\n\tcb->args[4] = 0;\nrelease:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int sctp_sock_filter(struct sctp_endpoint *ep, struct sctp_transport *tsp, void *p)\n{\n\tstruct sctp_comm_param *commp = p;\n\tstruct sock *sk = ep->base.sk;\n\tconst struct inet_diag_req_v2 *r = commp->r;\n\n\t \n\tif (!list_is_first(&tsp->asoc->asocs, &ep->asocs))\n\t\treturn 0;\n\n\tif (r->sdiag_family != AF_UNSPEC && sk->sk_family != r->sdiag_family)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int sctp_ep_dump(struct sctp_endpoint *ep, void *p)\n{\n\tstruct sctp_comm_param *commp = p;\n\tstruct sock *sk = ep->base.sk;\n\tstruct sk_buff *skb = commp->skb;\n\tstruct netlink_callback *cb = commp->cb;\n\tconst struct inet_diag_req_v2 *r = commp->r;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint err = 0;\n\n\tif (!net_eq(sock_net(sk), net))\n\t\tgoto out;\n\n\tif (cb->args[4] < cb->args[1])\n\t\tgoto next;\n\n\tif (!(r->idiag_states & TCPF_LISTEN) && !list_empty(&ep->asocs))\n\t\tgoto next;\n\n\tif (r->sdiag_family != AF_UNSPEC &&\n\t    sk->sk_family != r->sdiag_family)\n\t\tgoto next;\n\n\tif (r->id.idiag_sport != inet->inet_sport &&\n\t    r->id.idiag_sport)\n\t\tgoto next;\n\n\tif (r->id.idiag_dport != inet->inet_dport &&\n\t    r->id.idiag_dport)\n\t\tgoto next;\n\n\tif (inet_sctp_diag_fill(sk, NULL, skb, r,\n\t\t\t\tsk_user_ns(NETLINK_CB(cb->skb).sk),\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\tcb->nlh, commp->net_admin) < 0) {\n\t\terr = 2;\n\t\tgoto out;\n\t}\nnext:\n\tcb->args[4]++;\nout:\n\treturn err;\n}\n\n \nstatic void sctp_diag_get_info(struct sock *sk, struct inet_diag_msg *r,\n\t\t\t       void *info)\n{\n\tstruct sctp_infox *infox = (struct sctp_infox *)info;\n\n\tif (infox->asoc) {\n\t\tr->idiag_rqueue = atomic_read(&infox->asoc->rmem_alloc);\n\t\tr->idiag_wqueue = infox->asoc->sndbuf_used;\n\t} else {\n\t\tr->idiag_rqueue = READ_ONCE(sk->sk_ack_backlog);\n\t\tr->idiag_wqueue = READ_ONCE(sk->sk_max_ack_backlog);\n\t}\n\tif (infox->sctpinfo)\n\t\tsctp_get_sctp_info(sk, infox->asoc, infox->sctpinfo);\n}\n\nstatic int sctp_diag_dump_one(struct netlink_callback *cb,\n\t\t\t      const struct inet_diag_req_v2 *req)\n{\n\tstruct sk_buff *skb = cb->skb;\n\tstruct net *net = sock_net(skb->sk);\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tunion sctp_addr laddr, paddr;\n\tint dif = req->id.idiag_if;\n\tstruct sctp_comm_param commp = {\n\t\t.skb = skb,\n\t\t.r = req,\n\t\t.nlh = nlh,\n\t\t.net_admin = netlink_net_capable(skb, CAP_NET_ADMIN),\n\t};\n\n\tif (req->sdiag_family == AF_INET) {\n\t\tladdr.v4.sin_port = req->id.idiag_sport;\n\t\tladdr.v4.sin_addr.s_addr = req->id.idiag_src[0];\n\t\tladdr.v4.sin_family = AF_INET;\n\n\t\tpaddr.v4.sin_port = req->id.idiag_dport;\n\t\tpaddr.v4.sin_addr.s_addr = req->id.idiag_dst[0];\n\t\tpaddr.v4.sin_family = AF_INET;\n\t} else {\n\t\tladdr.v6.sin6_port = req->id.idiag_sport;\n\t\tmemcpy(&laddr.v6.sin6_addr, req->id.idiag_src,\n\t\t       sizeof(laddr.v6.sin6_addr));\n\t\tladdr.v6.sin6_family = AF_INET6;\n\n\t\tpaddr.v6.sin6_port = req->id.idiag_dport;\n\t\tmemcpy(&paddr.v6.sin6_addr, req->id.idiag_dst,\n\t\t       sizeof(paddr.v6.sin6_addr));\n\t\tpaddr.v6.sin6_family = AF_INET6;\n\t}\n\n\treturn sctp_transport_lookup_process(sctp_sock_dump_one,\n\t\t\t\t\t     net, &laddr, &paddr, &commp, dif);\n}\n\nstatic void sctp_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t   const struct inet_diag_req_v2 *r)\n{\n\tu32 idiag_states = r->idiag_states;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct sctp_comm_param commp = {\n\t\t.skb = skb,\n\t\t.cb = cb,\n\t\t.r = r,\n\t\t.net_admin = netlink_net_capable(cb->skb, CAP_NET_ADMIN),\n\t};\n\tint pos = cb->args[2];\n\n\t \n\tif (cb->args[0] == 0) {\n\t\tif (!(idiag_states & TCPF_LISTEN))\n\t\t\tgoto skip;\n\t\tif (sctp_for_each_endpoint(sctp_ep_dump, &commp))\n\t\t\tgoto done;\nskip:\n\t\tcb->args[0] = 1;\n\t\tcb->args[1] = 0;\n\t\tcb->args[4] = 0;\n\t}\n\n\t \n\tif (!(idiag_states & ~(TCPF_LISTEN | TCPF_CLOSE)))\n\t\tgoto done;\n\n\tsctp_transport_traverse_process(sctp_sock_filter, sctp_sock_dump,\n\t\t\t\t\tnet, &pos, &commp);\n\tcb->args[2] = pos;\n\ndone:\n\tcb->args[1] = cb->args[4];\n\tcb->args[4] = 0;\n}\n\nstatic const struct inet_diag_handler sctp_diag_handler = {\n\t.dump\t\t = sctp_diag_dump,\n\t.dump_one\t = sctp_diag_dump_one,\n\t.idiag_get_info  = sctp_diag_get_info,\n\t.idiag_type\t = IPPROTO_SCTP,\n\t.idiag_info_size = sizeof(struct sctp_info),\n};\n\nstatic int __init sctp_diag_init(void)\n{\n\treturn inet_diag_register(&sctp_diag_handler);\n}\n\nstatic void __exit sctp_diag_exit(void)\n{\n\tinet_diag_unregister(&sctp_diag_handler);\n}\n\nmodule_init(sctp_diag_init);\nmodule_exit(sctp_diag_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 2-132);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}