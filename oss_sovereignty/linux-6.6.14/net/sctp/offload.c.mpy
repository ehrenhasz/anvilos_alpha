{
  "module_name": "offload.c",
  "hash_id": "d86da4c1cbf26ec94c1b6f65e319a84a5e79e2642ccdc78a1e0a00a450411dd1",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/offload.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/kprobes.h>\n#include <linux/socket.h>\n#include <linux/sctp.h>\n#include <linux/proc_fs.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kfifo.h>\n#include <linux/time.h>\n#include <net/net_namespace.h>\n\n#include <linux/skbuff.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/checksum.h>\n#include <net/protocol.h>\n#include <net/gso.h>\n\nstatic __le32 sctp_gso_make_checksum(struct sk_buff *skb)\n{\n\tskb->ip_summed = CHECKSUM_NONE;\n\tskb->csum_not_inet = 0;\n\t \n\tSKB_GSO_CB(skb)->csum = (__force __wsum)~0;\n\tSKB_GSO_CB(skb)->csum_start = skb_headroom(skb) + skb->len;\n\treturn sctp_compute_cksum(skb, skb_transport_offset(skb));\n}\n\nstatic struct sk_buff *sctp_gso_segment(struct sk_buff *skb,\n\t\t\t\t\tnetdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct sctphdr *sh;\n\n\tif (!skb_is_gso_sctp(skb))\n\t\tgoto out;\n\n\tsh = sctp_hdr(skb);\n\tif (!pskb_may_pull(skb, sizeof(*sh)))\n\t\tgoto out;\n\n\t__skb_pull(skb, sizeof(*sh));\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t \n\t\tstruct skb_shared_info *pinfo = skb_shinfo(skb);\n\t\tstruct sk_buff *frag_iter;\n\n\t\tpinfo->gso_segs = 0;\n\t\tif (skb->len != skb->data_len) {\n\t\t\t \n\t\t\tpinfo->gso_segs++;\n\t\t}\n\n\t\tskb_walk_frags(skb, frag_iter)\n\t\t\tpinfo->gso_segs++;\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\tsegs = skb_segment(skb, (features | NETIF_F_HW_CSUM) & ~NETIF_F_SG);\n\tif (IS_ERR(segs))\n\t\tgoto out;\n\n\t \n\tif (!(features & NETIF_F_SCTP_CRC)) {\n\t\tfor (skb = segs; skb; skb = skb->next) {\n\t\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\t\tsh = sctp_hdr(skb);\n\t\t\t\tsh->checksum = sctp_gso_make_checksum(skb);\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn segs;\n}\n\nstatic const struct net_offload sctp_offload = {\n\t.callbacks = {\n\t\t.gso_segment = sctp_gso_segment,\n\t},\n};\n\nstatic const struct net_offload sctp6_offload = {\n\t.callbacks = {\n\t\t.gso_segment = sctp_gso_segment,\n\t},\n};\n\nint __init sctp_offload_init(void)\n{\n\tint ret;\n\n\tret = inet_add_offload(&sctp_offload, IPPROTO_SCTP);\n\tif (ret)\n\t\tgoto out;\n\n\tret = inet6_add_offload(&sctp6_offload, IPPROTO_SCTP);\n\tif (ret)\n\t\tgoto ipv4;\n\n\tcrc32c_csum_stub = &sctp_csum_ops;\n\treturn ret;\n\nipv4:\n\tinet_del_offload(&sctp_offload, IPPROTO_SCTP);\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}