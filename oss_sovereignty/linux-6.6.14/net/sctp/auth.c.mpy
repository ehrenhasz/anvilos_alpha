{
  "module_name": "auth.c",
  "hash_id": "cb955dd882b379023e3ae42e2af5c351f2e5fb49fb9472ca280cee6c856a32b7",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/auth.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/scatterlist.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/auth.h>\n\nstatic struct sctp_hmac sctp_hmac_list[SCTP_AUTH_NUM_HMACS] = {\n\t{\n\t\t \n\t\t.hmac_id = SCTP_AUTH_HMAC_ID_RESERVED_0,\n\t},\n\t{\n\t\t.hmac_id = SCTP_AUTH_HMAC_ID_SHA1,\n\t\t.hmac_name = \"hmac(sha1)\",\n\t\t.hmac_len = SCTP_SHA1_SIG_SIZE,\n\t},\n\t{\n\t\t \n\t\t.hmac_id = SCTP_AUTH_HMAC_ID_RESERVED_2,\n\t},\n#if IS_ENABLED(CONFIG_CRYPTO_SHA256)\n\t{\n\t\t.hmac_id = SCTP_AUTH_HMAC_ID_SHA256,\n\t\t.hmac_name = \"hmac(sha256)\",\n\t\t.hmac_len = SCTP_SHA256_SIG_SIZE,\n\t}\n#endif\n};\n\n\nvoid sctp_auth_key_put(struct sctp_auth_bytes *key)\n{\n\tif (!key)\n\t\treturn;\n\n\tif (refcount_dec_and_test(&key->refcnt)) {\n\t\tkfree_sensitive(key);\n\t\tSCTP_DBG_OBJCNT_DEC(keys);\n\t}\n}\n\n \nstatic struct sctp_auth_bytes *sctp_auth_create_key(__u32 key_len, gfp_t gfp)\n{\n\tstruct sctp_auth_bytes *key;\n\n\t \n\tif (key_len > (INT_MAX - sizeof(struct sctp_auth_bytes)))\n\t\treturn NULL;\n\n\t \n\tkey = kmalloc(sizeof(struct sctp_auth_bytes) + key_len, gfp);\n\tif (!key)\n\t\treturn NULL;\n\n\tkey->len = key_len;\n\trefcount_set(&key->refcnt, 1);\n\tSCTP_DBG_OBJCNT_INC(keys);\n\n\treturn key;\n}\n\n \nstruct sctp_shared_key *sctp_auth_shkey_create(__u16 key_id, gfp_t gfp)\n{\n\tstruct sctp_shared_key *new;\n\n\t \n\tnew = kzalloc(sizeof(struct sctp_shared_key), gfp);\n\tif (!new)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&new->key_list);\n\trefcount_set(&new->refcnt, 1);\n\tnew->key_id = key_id;\n\n\treturn new;\n}\n\n \nstatic void sctp_auth_shkey_destroy(struct sctp_shared_key *sh_key)\n{\n\tBUG_ON(!list_empty(&sh_key->key_list));\n\tsctp_auth_key_put(sh_key->key);\n\tsh_key->key = NULL;\n\tkfree(sh_key);\n}\n\nvoid sctp_auth_shkey_release(struct sctp_shared_key *sh_key)\n{\n\tif (refcount_dec_and_test(&sh_key->refcnt))\n\t\tsctp_auth_shkey_destroy(sh_key);\n}\n\nvoid sctp_auth_shkey_hold(struct sctp_shared_key *sh_key)\n{\n\trefcount_inc(&sh_key->refcnt);\n}\n\n \nvoid sctp_auth_destroy_keys(struct list_head *keys)\n{\n\tstruct sctp_shared_key *ep_key;\n\tstruct sctp_shared_key *tmp;\n\n\tif (list_empty(keys))\n\t\treturn;\n\n\tkey_for_each_safe(ep_key, tmp, keys) {\n\t\tlist_del_init(&ep_key->key_list);\n\t\tsctp_auth_shkey_release(ep_key);\n\t}\n}\n\n \nstatic int sctp_auth_compare_vectors(struct sctp_auth_bytes *vector1,\n\t\t\t      struct sctp_auth_bytes *vector2)\n{\n\tint diff;\n\tint i;\n\tconst __u8 *longer;\n\n\tdiff = vector1->len - vector2->len;\n\tif (diff) {\n\t\tlonger = (diff > 0) ? vector1->data : vector2->data;\n\n\t\t \n\t\tfor (i = 0; i < abs(diff); i++) {\n\t\t\tif (longer[i] != 0)\n\t\t\t\treturn diff;\n\t\t}\n\t}\n\n\t \n\treturn memcmp(vector1->data, vector2->data, vector1->len);\n}\n\n \nstatic struct sctp_auth_bytes *sctp_auth_make_key_vector(\n\t\t\tstruct sctp_random_param *random,\n\t\t\tstruct sctp_chunks_param *chunks,\n\t\t\tstruct sctp_hmac_algo_param *hmacs,\n\t\t\tgfp_t gfp)\n{\n\tstruct sctp_auth_bytes *new;\n\t__u32\tlen;\n\t__u32\toffset = 0;\n\t__u16\trandom_len, hmacs_len, chunks_len = 0;\n\n\trandom_len = ntohs(random->param_hdr.length);\n\thmacs_len = ntohs(hmacs->param_hdr.length);\n\tif (chunks)\n\t\tchunks_len = ntohs(chunks->param_hdr.length);\n\n\tlen = random_len + hmacs_len + chunks_len;\n\n\tnew = sctp_auth_create_key(len, gfp);\n\tif (!new)\n\t\treturn NULL;\n\n\tmemcpy(new->data, random, random_len);\n\toffset += random_len;\n\n\tif (chunks) {\n\t\tmemcpy(new->data + offset, chunks, chunks_len);\n\t\toffset += chunks_len;\n\t}\n\n\tmemcpy(new->data + offset, hmacs, hmacs_len);\n\n\treturn new;\n}\n\n\n \nstatic struct sctp_auth_bytes *sctp_auth_make_local_vector(\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    gfp_t gfp)\n{\n\treturn sctp_auth_make_key_vector(\n\t\t\t(struct sctp_random_param *)asoc->c.auth_random,\n\t\t\t(struct sctp_chunks_param *)asoc->c.auth_chunks,\n\t\t\t(struct sctp_hmac_algo_param *)asoc->c.auth_hmacs, gfp);\n}\n\n \nstatic struct sctp_auth_bytes *sctp_auth_make_peer_vector(\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    gfp_t gfp)\n{\n\treturn sctp_auth_make_key_vector(asoc->peer.peer_random,\n\t\t\t\t\t asoc->peer.peer_chunks,\n\t\t\t\t\t asoc->peer.peer_hmacs,\n\t\t\t\t\t gfp);\n}\n\n\n \nstatic struct sctp_auth_bytes *sctp_auth_asoc_set_secret(\n\t\t\tstruct sctp_shared_key *ep_key,\n\t\t\tstruct sctp_auth_bytes *first_vector,\n\t\t\tstruct sctp_auth_bytes *last_vector,\n\t\t\tgfp_t gfp)\n{\n\tstruct sctp_auth_bytes *secret;\n\t__u32 offset = 0;\n\t__u32 auth_len;\n\n\tauth_len = first_vector->len + last_vector->len;\n\tif (ep_key->key)\n\t\tauth_len += ep_key->key->len;\n\n\tsecret = sctp_auth_create_key(auth_len, gfp);\n\tif (!secret)\n\t\treturn NULL;\n\n\tif (ep_key->key) {\n\t\tmemcpy(secret->data, ep_key->key->data, ep_key->key->len);\n\t\toffset += ep_key->key->len;\n\t}\n\n\tmemcpy(secret->data + offset, first_vector->data, first_vector->len);\n\toffset += first_vector->len;\n\n\tmemcpy(secret->data + offset, last_vector->data, last_vector->len);\n\n\treturn secret;\n}\n\n \nstatic struct sctp_auth_bytes *sctp_auth_asoc_create_secret(\n\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t struct sctp_shared_key *ep_key,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct sctp_auth_bytes *local_key_vector;\n\tstruct sctp_auth_bytes *peer_key_vector;\n\tstruct sctp_auth_bytes\t*first_vector,\n\t\t\t\t*last_vector;\n\tstruct sctp_auth_bytes\t*secret = NULL;\n\tint\tcmp;\n\n\n\t \n\n\tlocal_key_vector = sctp_auth_make_local_vector(asoc, gfp);\n\tpeer_key_vector = sctp_auth_make_peer_vector(asoc, gfp);\n\n\tif (!peer_key_vector || !local_key_vector)\n\t\tgoto out;\n\n\t \n\tcmp = sctp_auth_compare_vectors(local_key_vector,\n\t\t\t\t\tpeer_key_vector);\n\tif (cmp < 0) {\n\t\tfirst_vector = local_key_vector;\n\t\tlast_vector = peer_key_vector;\n\t} else {\n\t\tfirst_vector = peer_key_vector;\n\t\tlast_vector = local_key_vector;\n\t}\n\n\tsecret = sctp_auth_asoc_set_secret(ep_key, first_vector, last_vector,\n\t\t\t\t\t    gfp);\nout:\n\tsctp_auth_key_put(local_key_vector);\n\tsctp_auth_key_put(peer_key_vector);\n\n\treturn secret;\n}\n\n \nint sctp_auth_asoc_copy_shkeys(const struct sctp_endpoint *ep,\n\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct sctp_shared_key *sh_key;\n\tstruct sctp_shared_key *new;\n\n\tBUG_ON(!list_empty(&asoc->endpoint_shared_keys));\n\n\tkey_for_each(sh_key, &ep->endpoint_shared_keys) {\n\t\tnew = sctp_auth_shkey_create(sh_key->key_id, gfp);\n\t\tif (!new)\n\t\t\tgoto nomem;\n\n\t\tnew->key = sh_key->key;\n\t\tsctp_auth_key_hold(new->key);\n\t\tlist_add(&new->key_list, &asoc->endpoint_shared_keys);\n\t}\n\n\treturn 0;\n\nnomem:\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\treturn -ENOMEM;\n}\n\n\n \nint sctp_auth_asoc_init_active_key(struct sctp_association *asoc, gfp_t gfp)\n{\n\tstruct sctp_auth_bytes\t*secret;\n\tstruct sctp_shared_key *ep_key;\n\tstruct sctp_chunk *chunk;\n\n\t \n\tif (!asoc->peer.auth_capable)\n\t\treturn 0;\n\n\t \n\tep_key = sctp_auth_get_shkey(asoc, asoc->active_key_id);\n\tBUG_ON(!ep_key);\n\n\tsecret = sctp_auth_asoc_create_secret(asoc, ep_key, gfp);\n\tif (!secret)\n\t\treturn -ENOMEM;\n\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tasoc->asoc_shared_key = secret;\n\tasoc->shkey = ep_key;\n\n\t \n\tlist_for_each_entry(chunk, &asoc->outqueue.out_chunk_list, list) {\n\t\tif (sctp_auth_send_cid(chunk->chunk_hdr->type, asoc)) {\n\t\t\tchunk->auth = 1;\n\t\t\tif (!chunk->shkey) {\n\t\t\t\tchunk->shkey = asoc->shkey;\n\t\t\t\tsctp_auth_shkey_hold(chunk->shkey);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n \nstruct sctp_shared_key *sctp_auth_get_shkey(\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t__u16 key_id)\n{\n\tstruct sctp_shared_key *key;\n\n\t \n\tkey_for_each(key, &asoc->endpoint_shared_keys) {\n\t\tif (key->key_id == key_id) {\n\t\t\tif (!key->deactivated)\n\t\t\t\treturn key;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nint sctp_auth_init_hmacs(struct sctp_endpoint *ep, gfp_t gfp)\n{\n\tstruct crypto_shash *tfm = NULL;\n\t__u16   id;\n\n\t \n\tif (ep->auth_hmacs)\n\t\treturn 0;\n\n\t \n\tep->auth_hmacs = kcalloc(SCTP_AUTH_NUM_HMACS,\n\t\t\t\t sizeof(struct crypto_shash *),\n\t\t\t\t gfp);\n\tif (!ep->auth_hmacs)\n\t\treturn -ENOMEM;\n\n\tfor (id = 0; id < SCTP_AUTH_NUM_HMACS; id++) {\n\n\t\t \n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ep->auth_hmacs[id])\n\t\t\tcontinue;\n\n\t\t \n\t\ttfm = crypto_alloc_shash(sctp_hmac_list[id].hmac_name, 0, 0);\n\t\tif (IS_ERR(tfm))\n\t\t\tgoto out_err;\n\n\t\tep->auth_hmacs[id] = tfm;\n\t}\n\n\treturn 0;\n\nout_err:\n\t \n\tsctp_auth_destroy_hmacs(ep->auth_hmacs);\n\tep->auth_hmacs = NULL;\n\treturn -ENOMEM;\n}\n\n \nvoid sctp_auth_destroy_hmacs(struct crypto_shash *auth_hmacs[])\n{\n\tint i;\n\n\tif (!auth_hmacs)\n\t\treturn;\n\n\tfor (i = 0; i < SCTP_AUTH_NUM_HMACS; i++) {\n\t\tcrypto_free_shash(auth_hmacs[i]);\n\t}\n\tkfree(auth_hmacs);\n}\n\n\nstruct sctp_hmac *sctp_auth_get_hmac(__u16 hmac_id)\n{\n\treturn &sctp_hmac_list[hmac_id];\n}\n\n \nstruct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)\n{\n\tstruct sctp_hmac_algo_param *hmacs;\n\t__u16 n_elt;\n\t__u16 id = 0;\n\tint i;\n\n\t \n\tif (asoc->default_hmac_id)\n\t\treturn &sctp_hmac_list[asoc->default_hmac_id];\n\n\t \n\thmacs = asoc->peer.peer_hmacs;\n\tif (!hmacs)\n\t\treturn NULL;\n\n\tn_elt = (ntohs(hmacs->param_hdr.length) -\n\t\t sizeof(struct sctp_paramhdr)) >> 1;\n\tfor (i = 0; i < n_elt; i++) {\n\t\tid = ntohs(hmacs->hmac_ids[i]);\n\n\t\t \n\t\tif (id > SCTP_AUTH_HMAC_ID_MAX ||\n\t\t    !sctp_hmac_list[id].hmac_name) {\n\t\t\tid = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (id == 0)\n\t\treturn NULL;\n\n\treturn &sctp_hmac_list[id];\n}\n\nstatic int __sctp_auth_find_hmacid(__be16 *hmacs, int n_elts, __be16 hmac_id)\n{\n\tint  found = 0;\n\tint  i;\n\n\tfor (i = 0; i < n_elts; i++) {\n\t\tif (hmac_id == hmacs[i]) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\n \nint sctp_auth_asoc_verify_hmac_id(const struct sctp_association *asoc,\n\t\t\t\t    __be16 hmac_id)\n{\n\tstruct sctp_hmac_algo_param *hmacs;\n\t__u16 n_elt;\n\n\tif (!asoc)\n\t\treturn 0;\n\n\thmacs = (struct sctp_hmac_algo_param *)asoc->c.auth_hmacs;\n\tn_elt = (ntohs(hmacs->param_hdr.length) -\n\t\t sizeof(struct sctp_paramhdr)) >> 1;\n\n\treturn __sctp_auth_find_hmacid(hmacs->hmac_ids, n_elt, hmac_id);\n}\n\n\n \nvoid sctp_auth_asoc_set_default_hmac(struct sctp_association *asoc,\n\t\t\t\t     struct sctp_hmac_algo_param *hmacs)\n{\n\tstruct sctp_endpoint *ep;\n\t__u16   id;\n\tint\ti;\n\tint\tn_params;\n\n\t \n\tif (asoc->default_hmac_id)\n\t\treturn;\n\n\tn_params = (ntohs(hmacs->param_hdr.length) -\n\t\t    sizeof(struct sctp_paramhdr)) >> 1;\n\tep = asoc->ep;\n\tfor (i = 0; i < n_params; i++) {\n\t\tid = ntohs(hmacs->hmac_ids[i]);\n\n\t\t \n\t\tif (id > SCTP_AUTH_HMAC_ID_MAX)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ep->auth_hmacs[id]) {\n\t\t\tasoc->default_hmac_id = id;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\n \nstatic int __sctp_auth_cid(enum sctp_cid chunk, struct sctp_chunks_param *param)\n{\n\tunsigned short len;\n\tint found = 0;\n\tint i;\n\n\tif (!param || param->param_hdr.length == 0)\n\t\treturn 0;\n\n\tlen = ntohs(param->param_hdr.length) - sizeof(struct sctp_paramhdr);\n\n\t \n\tfor (i = 0; !found && i < len; i++) {\n\t\tswitch (param->chunks[i]) {\n\t\tcase SCTP_CID_INIT:\n\t\tcase SCTP_CID_INIT_ACK:\n\t\tcase SCTP_CID_SHUTDOWN_COMPLETE:\n\t\tcase SCTP_CID_AUTH:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (param->chunks[i] == chunk)\n\t\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\n \nint sctp_auth_send_cid(enum sctp_cid chunk, const struct sctp_association *asoc)\n{\n\tif (!asoc)\n\t\treturn 0;\n\n\tif (!asoc->peer.auth_capable)\n\t\treturn 0;\n\n\treturn __sctp_auth_cid(chunk, asoc->peer.peer_chunks);\n}\n\n \nint sctp_auth_recv_cid(enum sctp_cid chunk, const struct sctp_association *asoc)\n{\n\tif (!asoc)\n\t\treturn 0;\n\n\tif (!asoc->peer.auth_capable)\n\t\treturn 0;\n\n\treturn __sctp_auth_cid(chunk,\n\t\t\t      (struct sctp_chunks_param *)asoc->c.auth_chunks);\n}\n\n \nvoid sctp_auth_calculate_hmac(const struct sctp_association *asoc,\n\t\t\t      struct sk_buff *skb, struct sctp_auth_chunk *auth,\n\t\t\t      struct sctp_shared_key *ep_key, gfp_t gfp)\n{\n\tstruct sctp_auth_bytes *asoc_key;\n\tstruct crypto_shash *tfm;\n\t__u16 key_id, hmac_id;\n\tunsigned char *end;\n\tint free_key = 0;\n\t__u8 *digest;\n\n\t \n\tkey_id = ntohs(auth->auth_hdr.shkey_id);\n\thmac_id = ntohs(auth->auth_hdr.hmac_id);\n\n\tif (key_id == asoc->active_key_id)\n\t\tasoc_key = asoc->asoc_shared_key;\n\telse {\n\t\t \n\t\tasoc_key = sctp_auth_asoc_create_secret(asoc, ep_key, gfp);\n\t\tif (!asoc_key)\n\t\t\treturn;\n\n\t\tfree_key = 1;\n\t}\n\n\t \n\tend = skb_tail_pointer(skb);\n\n\ttfm = asoc->ep->auth_hmacs[hmac_id];\n\n\tdigest = (u8 *)(&auth->auth_hdr + 1);\n\tif (crypto_shash_setkey(tfm, &asoc_key->data[0], asoc_key->len))\n\t\tgoto free;\n\n\tcrypto_shash_tfm_digest(tfm, (u8 *)auth, end - (unsigned char *)auth,\n\t\t\t\tdigest);\n\nfree:\n\tif (free_key)\n\t\tsctp_auth_key_put(asoc_key);\n}\n\n \n\n \nint sctp_auth_ep_add_chunkid(struct sctp_endpoint *ep, __u8 chunk_id)\n{\n\tstruct sctp_chunks_param *p = ep->auth_chunk_list;\n\t__u16 nchunks;\n\t__u16 param_len;\n\n\t \n\tif (__sctp_auth_cid(chunk_id, p))\n\t\treturn 0;\n\n\t \n\tparam_len = ntohs(p->param_hdr.length);\n\tnchunks = param_len - sizeof(struct sctp_paramhdr);\n\tif (nchunks == SCTP_NUM_CHUNK_TYPES)\n\t\treturn -EINVAL;\n\n\tp->chunks[nchunks] = chunk_id;\n\tp->param_hdr.length = htons(param_len + 1);\n\treturn 0;\n}\n\n \nint sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_hmacalgo *hmacs)\n{\n\tint has_sha1 = 0;\n\t__u16 id;\n\tint i;\n\n\t \n\tfor (i = 0; i < hmacs->shmac_num_idents; i++) {\n\t\tid = hmacs->shmac_idents[i];\n\n\t\tif (id > SCTP_AUTH_HMAC_ID_MAX)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (SCTP_AUTH_HMAC_ID_SHA1 == id)\n\t\t\thas_sha1 = 1;\n\n\t\tif (!sctp_hmac_list[id].hmac_name)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!has_sha1)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < hmacs->shmac_num_idents; i++)\n\t\tep->auth_hmacs_list->hmac_ids[i] =\n\t\t\t\thtons(hmacs->shmac_idents[i]);\n\tep->auth_hmacs_list->param_hdr.length =\n\t\t\thtons(sizeof(struct sctp_paramhdr) +\n\t\t\thmacs->shmac_num_idents * sizeof(__u16));\n\treturn 0;\n}\n\n \nint sctp_auth_set_key(struct sctp_endpoint *ep,\n\t\t      struct sctp_association *asoc,\n\t\t      struct sctp_authkey *auth_key)\n{\n\tstruct sctp_shared_key *cur_key, *shkey;\n\tstruct sctp_auth_bytes *key;\n\tstruct list_head *sh_keys;\n\tint replace = 0;\n\n\t \n\tif (asoc) {\n\t\tif (!asoc->peer.auth_capable)\n\t\t\treturn -EACCES;\n\t\tsh_keys = &asoc->endpoint_shared_keys;\n\t} else {\n\t\tif (!ep->auth_enable)\n\t\t\treturn -EACCES;\n\t\tsh_keys = &ep->endpoint_shared_keys;\n\t}\n\n\tkey_for_each(shkey, sh_keys) {\n\t\tif (shkey->key_id == auth_key->sca_keynumber) {\n\t\t\treplace = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcur_key = sctp_auth_shkey_create(auth_key->sca_keynumber, GFP_KERNEL);\n\tif (!cur_key)\n\t\treturn -ENOMEM;\n\n\t \n\tkey = sctp_auth_create_key(auth_key->sca_keylength, GFP_KERNEL);\n\tif (!key) {\n\t\tkfree(cur_key);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(key->data, &auth_key->sca_key[0], auth_key->sca_keylength);\n\tcur_key->key = key;\n\n\tif (!replace) {\n\t\tlist_add(&cur_key->key_list, sh_keys);\n\t\treturn 0;\n\t}\n\n\tlist_del_init(&shkey->key_list);\n\tlist_add(&cur_key->key_list, sh_keys);\n\n\tif (asoc && asoc->active_key_id == auth_key->sca_keynumber &&\n\t    sctp_auth_asoc_init_active_key(asoc, GFP_KERNEL)) {\n\t\tlist_del_init(&cur_key->key_list);\n\t\tsctp_auth_shkey_release(cur_key);\n\t\tlist_add(&shkey->key_list, sh_keys);\n\t\treturn -ENOMEM;\n\t}\n\n\tsctp_auth_shkey_release(shkey);\n\treturn 0;\n}\n\nint sctp_auth_set_active_key(struct sctp_endpoint *ep,\n\t\t\t     struct sctp_association *asoc,\n\t\t\t     __u16  key_id)\n{\n\tstruct sctp_shared_key *key;\n\tstruct list_head *sh_keys;\n\tint found = 0;\n\n\t \n\tif (asoc) {\n\t\tif (!asoc->peer.auth_capable)\n\t\t\treturn -EACCES;\n\t\tsh_keys = &asoc->endpoint_shared_keys;\n\t} else {\n\t\tif (!ep->auth_enable)\n\t\t\treturn -EACCES;\n\t\tsh_keys = &ep->endpoint_shared_keys;\n\t}\n\n\tkey_for_each(key, sh_keys) {\n\t\tif (key->key_id == key_id) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found || key->deactivated)\n\t\treturn -EINVAL;\n\n\tif (asoc) {\n\t\t__u16  active_key_id = asoc->active_key_id;\n\n\t\tasoc->active_key_id = key_id;\n\t\tif (sctp_auth_asoc_init_active_key(asoc, GFP_KERNEL)) {\n\t\t\tasoc->active_key_id = active_key_id;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else\n\t\tep->active_key_id = key_id;\n\n\treturn 0;\n}\n\nint sctp_auth_del_key_id(struct sctp_endpoint *ep,\n\t\t\t struct sctp_association *asoc,\n\t\t\t __u16  key_id)\n{\n\tstruct sctp_shared_key *key;\n\tstruct list_head *sh_keys;\n\tint found = 0;\n\n\t \n\tif (asoc) {\n\t\tif (!asoc->peer.auth_capable)\n\t\t\treturn -EACCES;\n\t\tif (asoc->active_key_id == key_id)\n\t\t\treturn -EINVAL;\n\n\t\tsh_keys = &asoc->endpoint_shared_keys;\n\t} else {\n\t\tif (!ep->auth_enable)\n\t\t\treturn -EACCES;\n\t\tif (ep->active_key_id == key_id)\n\t\t\treturn -EINVAL;\n\n\t\tsh_keys = &ep->endpoint_shared_keys;\n\t}\n\n\tkey_for_each(key, sh_keys) {\n\t\tif (key->key_id == key_id) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\t \n\tlist_del_init(&key->key_list);\n\tsctp_auth_shkey_release(key);\n\n\treturn 0;\n}\n\nint sctp_auth_deact_key_id(struct sctp_endpoint *ep,\n\t\t\t   struct sctp_association *asoc, __u16  key_id)\n{\n\tstruct sctp_shared_key *key;\n\tstruct list_head *sh_keys;\n\tint found = 0;\n\n\t \n\tif (asoc) {\n\t\tif (!asoc->peer.auth_capable)\n\t\t\treturn -EACCES;\n\t\tif (asoc->active_key_id == key_id)\n\t\t\treturn -EINVAL;\n\n\t\tsh_keys = &asoc->endpoint_shared_keys;\n\t} else {\n\t\tif (!ep->auth_enable)\n\t\t\treturn -EACCES;\n\t\tif (ep->active_key_id == key_id)\n\t\t\treturn -EINVAL;\n\n\t\tsh_keys = &ep->endpoint_shared_keys;\n\t}\n\n\tkey_for_each(key, sh_keys) {\n\t\tif (key->key_id == key_id) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\t \n\tif (asoc && !list_empty(&key->key_list) &&\n\t    refcount_read(&key->refcnt) == 1) {\n\t\tstruct sctp_ulpevent *ev;\n\n\t\tev = sctp_ulpevent_make_authkey(asoc, key->key_id,\n\t\t\t\t\t\tSCTP_AUTH_FREE_KEY, GFP_KERNEL);\n\t\tif (ev)\n\t\t\tasoc->stream.si->enqueue_event(&asoc->ulpq, ev);\n\t}\n\n\tkey->deactivated = 1;\n\n\treturn 0;\n}\n\nint sctp_auth_init(struct sctp_endpoint *ep, gfp_t gfp)\n{\n\tint err = -ENOMEM;\n\n\t \n\tif (!ep->auth_hmacs_list) {\n\t\tstruct sctp_hmac_algo_param *auth_hmacs;\n\n\t\tauth_hmacs = kzalloc(struct_size(auth_hmacs, hmac_ids,\n\t\t\t\t\t\t SCTP_AUTH_NUM_HMACS), gfp);\n\t\tif (!auth_hmacs)\n\t\t\tgoto nomem;\n\t\t \n\t\tauth_hmacs->param_hdr.type = SCTP_PARAM_HMAC_ALGO;\n\t\tauth_hmacs->param_hdr.length =\n\t\t\t\thtons(sizeof(struct sctp_paramhdr) + 2);\n\t\tauth_hmacs->hmac_ids[0] = htons(SCTP_AUTH_HMAC_ID_SHA1);\n\t\tep->auth_hmacs_list = auth_hmacs;\n\t}\n\n\tif (!ep->auth_chunk_list) {\n\t\tstruct sctp_chunks_param *auth_chunks;\n\n\t\tauth_chunks = kzalloc(sizeof(*auth_chunks) +\n\t\t\t\t      SCTP_NUM_CHUNK_TYPES, gfp);\n\t\tif (!auth_chunks)\n\t\t\tgoto nomem;\n\t\t \n\t\tauth_chunks->param_hdr.type = SCTP_PARAM_CHUNKS;\n\t\tauth_chunks->param_hdr.length =\n\t\t\t\thtons(sizeof(struct sctp_paramhdr));\n\t\tep->auth_chunk_list = auth_chunks;\n\t}\n\n\t \n\terr = sctp_auth_init_hmacs(ep, gfp);\n\tif (err)\n\t\tgoto nomem;\n\n\treturn 0;\n\nnomem:\n\t \n\tkfree(ep->auth_hmacs_list);\n\tkfree(ep->auth_chunk_list);\n\tep->auth_hmacs_list = NULL;\n\tep->auth_chunk_list = NULL;\n\treturn err;\n}\n\nvoid sctp_auth_free(struct sctp_endpoint *ep)\n{\n\tkfree(ep->auth_hmacs_list);\n\tkfree(ep->auth_chunk_list);\n\tep->auth_hmacs_list = NULL;\n\tep->auth_chunk_list = NULL;\n\tsctp_auth_destroy_hmacs(ep->auth_hmacs);\n\tep->auth_hmacs = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}