{
  "module_name": "sm_statefuns.c",
  "hash_id": "242048b0313533071ca9cf90f8c2c7bd6e596cf9415c6c80d79ecea1b32810d5",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/sm_statefuns.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/inet_ecn.h>\n#include <linux/skbuff.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/structs.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/sctp.h>\n\nstatic struct sctp_packet *sctp_abort_pkt_new(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tconst void *payload, size_t paylen);\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t struct sctp_cmd_seq *commands);\nstatic struct sctp_packet *sctp_ootb_pkt_new(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk);\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       struct sctp_cmd_seq *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk);\nstatic enum sctp_disposition sctp_sf_do_5_2_6_stale(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\nstatic enum sctp_disposition sctp_sf_shut_8_4_5(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\nstatic enum sctp_disposition sctp_sf_tabort_8_4_8(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\nstatic enum sctp_disposition sctp_sf_new_encap_port(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk);\n\nstatic enum sctp_disposition sctp_stop_t1_and_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\t__be16 error, int sk_err,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_transport *transport);\n\nstatic enum sctp_disposition sctp_sf_abort_violation(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tconst __u8 *payload,\n\t\t\t\t\tconst size_t paylen);\n\nstatic enum sctp_disposition sctp_sf_violation_chunklen(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_disposition sctp_sf_violation_paramlen(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg, void *ext,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_disposition sctp_sf_violation_ctsn(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_disposition sctp_sf_violation_chunk(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_ierror sctp_sf_authenticate(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk);\n\nstatic enum sctp_disposition __sctp_sf_do_9_1_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands);\n\nstatic enum sctp_disposition\n__sctp_sf_do_9_2_reshutack(struct net *net, const struct sctp_endpoint *ep,\n\t\t\t   const struct sctp_association *asoc,\n\t\t\t   const union sctp_subtype type, void *arg,\n\t\t\t   struct sctp_cmd_seq *commands);\n\n \nstatic inline bool sctp_chunk_length_valid(struct sctp_chunk *chunk,\n\t\t\t\t\t   __u16 required_length)\n{\n\t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n\n\t \n\tif (unlikely(chunk->pdiscard))\n\t\treturn false;\n\tif (unlikely(chunk_length < required_length))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic inline bool sctp_err_chunk_valid(struct sctp_chunk *chunk)\n{\n\tstruct sctp_errhdr *err;\n\n\tsctp_walk_errors(err, chunk->chunk_hdr);\n\n\treturn (void *)err == (void *)chunk->chunk_end;\n}\n\n \n\n \nenum sctp_disposition sctp_sf_do_4_C(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const union sctp_subtype type,\n\t\t\t\t     void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t \n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n \nenum sctp_disposition sctp_sf_do_5_1B_init(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg, *repl, *err_chunk;\n\tstruct sctp_unrecognized_param *unk_param;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_packet *packet;\n\tint len;\n\n\t \n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t \n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (sctp_sstate(ep->base.sk, CLOSING))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t \n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (struct sctp_init_chunk *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t \n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(struct sctp_chunkhdr),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(struct sctp_chunkhdr));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t \n\tchunk->subh.init_hdr = (struct sctp_inithdr *)chunk->skb->data;\n\n\t \n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(struct sctp_inithdr));\n\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\t \n\tif (security_sctp_assoc_request(new_asoc, chunk->skb)) {\n\t\tsctp_association_free(new_asoc);\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\t\t     sctp_scope(sctp_source(chunk)),\n\t\t\t\t\t     GFP_ATOMIC) < 0)\n\t\tgoto nomem_init;\n\n\t \n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (struct sctp_init_chunk *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t \n\n\t \n\tlen = 0;\n\tif (err_chunk)\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t      sizeof(struct sctp_chunkhdr);\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t \n\tif (err_chunk) {\n\t\t \n\t\tunk_param = (struct sctp_unrecognized_param *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(struct sctp_chunkhdr));\n\t\t \n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t\tsctp_chunk_free(err_chunk);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nenum sctp_disposition sctp_sf_do_5_1C_ack(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_init_chunk *initchunk;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_initack_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t \n\tchunk->subh.init_hdr = (struct sctp_inithdr *)chunk->skb->data;\n\n\t \n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (struct sctp_init_chunk *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\n\t\tenum sctp_error error = SCTP_ERROR_NO_RESOURCE;\n\n\t\t \n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(struct sctp_chunkhdr),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(struct sctp_chunkhdr));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\terror = SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED,\n\t\t\t\t\t\tasoc, chunk->transport);\n\t}\n\n\t \n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(struct sctp_inithdr));\n\n\tinitchunk = (struct sctp_init_chunk *)chunk->chunk_hdr;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PEER_INIT,\n\t\t\tSCTP_PEER_INIT(initchunk));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_ECHOED));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_SHKEY, SCTP_NULL());\n\n\t \n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_COOKIE_ECHO,\n\t\t\tSCTP_CHUNK(err_chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\nstatic bool sctp_auth_chunk_verify(struct net *net, struct sctp_chunk *chunk,\n\t\t\t\t   const struct sctp_association *asoc)\n{\n\tstruct sctp_chunk auth;\n\n\tif (!chunk->auth_chunk)\n\t\treturn true;\n\n\t \n\n\t \n\tif (!net->sctp.auth_enable || !asoc->peer.auth_capable)\n\t\treturn false;\n\n\t \n\tauth.skb = chunk->auth_chunk;\n\tauth.asoc = chunk->asoc;\n\tauth.sctp_hdr = chunk->sctp_hdr;\n\tauth.chunk_hdr = (struct sctp_chunkhdr *)\n\t\t\t\tskb_push(chunk->auth_chunk,\n\t\t\t\t\t sizeof(struct sctp_chunkhdr));\n\tskb_pull(chunk->auth_chunk, sizeof(struct sctp_chunkhdr));\n\tauth.transport = chunk->transport;\n\n\treturn sctp_sf_authenticate(asoc, &auth) == SCTP_IERROR_NO_ERROR;\n}\n\n \nenum sctp_disposition sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const union sctp_subtype type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_ulpevent *ev, *ai_ev = NULL, *auth_ev = NULL;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_init_chunk *peer_init;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *err_chk_p;\n\tstruct sctp_chunk *repl;\n\tstruct sock *sk;\n\tint error = 0;\n\n\tif (asoc && !sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t \n\tsk = ep->base.sk;\n\tif (!sctp_sstate(sk, LISTENING) ||\n\t    (sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t \n\tchunk->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\t sizeof(struct sctp_chunkhdr)))\n\t\tgoto nomem;\n\n\t \n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t \n\tif (!new_asoc) {\n\t\t \n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\tif (security_sctp_assoc_request(new_asoc, chunk->head_skb ?: chunk->skb)) {\n\t\tsctp_association_free(new_asoc);\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t \n\t \n\tpeer_init = (struct sctp_init_chunk *)(chunk->subh.cookie_hdr + 1);\n\tif (!sctp_process_init(new_asoc, chunk,\n\t\t\t       &chunk->subh.cookie_hdr->c.peer_addr,\n\t\t\t       peer_init, GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t \n\terror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\n\tif (error)\n\t\tgoto nomem_init;\n\n\tif (!sctp_auth_chunk_verify(net, chunk, new_asoc)) {\n\t\tsctp_association_free(new_asoc);\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t \n\tev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t \n\tif (new_asoc->peer.adaptation_ind) {\n\t\tai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!ai_ev)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\tif (!new_asoc->peer.auth_capable) {\n\t\tauth_ev = sctp_ulpevent_make_authkey(new_asoc, 0,\n\t\t\t\t\t\t     SCTP_AUTH_NO_AUTH,\n\t\t\t\t\t\t     GFP_ATOMIC);\n\t\tif (!auth_ev)\n\t\t\tgoto nomem_authev;\n\t}\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\tif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t \n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\tif (auth_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(auth_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_authev:\n\tsctp_ulpevent_free(ai_ev);\nnomem_aiev:\n\tsctp_ulpevent_free(ev);\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nenum sctp_disposition sctp_sf_do_5_1E_ca(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const union sctp_subtype type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (security_sctp_assoc_established((struct sctp_association *)asoc,\n\t\t\t\t\t    chunk->head_skb ?: chunk->skb))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ACTIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t \n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_UP,\n\t\t\t\t\t     0, asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\n\tif (!ev)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t \n\tif (asoc->peer.adaptation_ind) {\n\t\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\tif (!asoc->peer.auth_capable) {\n\t\tev = sctp_ulpevent_make_authkey(asoc, 0, SCTP_AUTH_NO_AUTH,\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nstatic enum sctp_disposition sctp_sf_heartbeat(\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\tstruct sctp_chunk *reply;\n\n\t \n\treply = sctp_make_heartbeat(asoc, transport, 0);\n\tif (!reply)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_RTO_PENDING,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_sendbeat_8_3(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\t \n\n\tif (transport->param_flags & SPP_HB_ENABLE) {\n\t\tif (SCTP_DISPOSITION_NOMEM ==\n\t\t\t\tsctp_sf_heartbeat(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands))\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_IDLE,\n\t\t\tSCTP_TRANSPORT(transport));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMER_UPDATE,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_send_reconf(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = arg;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\tsctp_chunk_hold(asoc->strreset_chunk);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\tSCTP_CHUNK(asoc->strreset_chunk));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_send_probe(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const union sctp_subtype type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *)arg;\n\tstruct sctp_chunk *reply;\n\n\tif (!sctp_transport_pl_enabled(transport))\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\tsctp_transport_pl_send(transport);\n\treply = sctp_make_heartbeat(asoc, transport, transport->pl.probe_size);\n\tif (!reply)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROBE_TIMER_UPDATE,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_beat_8_3(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const union sctp_subtype type,\n\t\t\t\t       void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_paramhdr *param_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tsize_t paylen = 0;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t     sizeof(struct sctp_heartbeat_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t \n\tchunk->subh.hb_hdr = (struct sctp_heartbeathdr *)chunk->skb->data;\n\tparam_hdr = (struct sctp_paramhdr *)chunk->subh.hb_hdr;\n\tpaylen = ntohs(chunk->chunk_hdr->length) - sizeof(struct sctp_chunkhdr);\n\n\tif (ntohs(param_hdr->length) > paylen)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  param_hdr, commands);\n\n\tif (!pskb_pull(chunk->skb, paylen))\n\t\tgoto nomem;\n\n\treply = sctp_make_heartbeat_ack(asoc, chunk, param_hdr, paylen);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nenum sctp_disposition sctp_sf_backbeat_8_3(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_sender_hb_info *hbinfo;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_transport *link;\n\tunsigned long max_interval;\n\tunion sctp_addr from_addr;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr) +\n\t\t\t\t\t    sizeof(*hbinfo)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thbinfo = (struct sctp_sender_hb_info *)chunk->skb->data;\n\t \n\tif (ntohs(hbinfo->param_hdr.length) != sizeof(*hbinfo))\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tfrom_addr = hbinfo->daddr;\n\tlink = sctp_assoc_lookup_paddr(asoc, &from_addr);\n\n\t \n\tif (unlikely(!link)) {\n\t\tif (from_addr.sa.sa_family == AF_INET6) {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI6\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v6.sin6_addr);\n\t\t} else {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI4\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v4.sin_addr.s_addr);\n\t\t}\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t \n\tif (hbinfo->hb_nonce != link->hb_nonce)\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tif (hbinfo->probe_size) {\n\t\tif (hbinfo->probe_size != link->pl.probe_size ||\n\t\t    !sctp_transport_pl_enabled(link))\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t\tif (sctp_transport_pl_recv(link))\n\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\t\treturn sctp_sf_send_probe(net, ep, asoc, type, link, commands);\n\t}\n\n\tmax_interval = link->hbinterval + link->rto;\n\n\t \n\tif (time_after(hbinfo->sent_at, jiffies) ||\n\t    time_after(jiffies, hbinfo->sent_at + max_interval)) {\n\t\tpr_debug(\"%s: HEARTBEAT ACK with invalid timestamp received \"\n\t\t\t \"for transport:%p\\n\", __func__, link);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_ON, SCTP_TRANSPORT(link));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nstatic int sctp_sf_send_restart_abort(struct net *net, union sctp_addr *ssa,\n\t\t\t\t      struct sctp_chunk *init,\n\t\t\t\t      struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_af *af = sctp_get_af_specific(ssa->v4.sin_family);\n\tunion sctp_addr_param *addrparm;\n\tstruct sctp_errhdr *errhdr;\n\tchar buffer[sizeof(*errhdr) + sizeof(*addrparm)];\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_packet *pkt;\n\tint len;\n\n\t \n\terrhdr = (struct sctp_errhdr *)buffer;\n\taddrparm = (union sctp_addr_param *)(errhdr + 1);\n\n\t \n\tlen = af->to_addr_param(ssa, addrparm);\n\tlen += sizeof(*errhdr);\n\n\terrhdr->cause = SCTP_ERROR_RESTART;\n\terrhdr->length = htons(len);\n\n\t \n\tep = sctp_sk(net->sctp.ctl_sock)->ep;\n\n\t \n\tpkt = sctp_abort_pkt_new(net, ep, NULL, init, errhdr, len);\n\n\tif (!pkt)\n\t\tgoto out;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(pkt));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\nout:\n\t \n\treturn 0;\n}\n\nstatic bool list_has_sctp_addr(const struct list_head *list,\n\t\t\t       union sctp_addr *ipaddr)\n{\n\tstruct sctp_transport *addr;\n\n\tlist_for_each_entry(addr, list, transports) {\n\t\tif (sctp_cmp_addr_exact(ipaddr, &addr->ipaddr))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n \nstatic int sctp_sf_check_restart_addrs(const struct sctp_association *new_asoc,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *init,\n\t\t\t\t       struct sctp_cmd_seq *commands)\n{\n\tstruct net *net = new_asoc->base.net;\n\tstruct sctp_transport *new_addr;\n\tint ret = 1;\n\n\t \n\n\t \n\tlist_for_each_entry(new_addr, &new_asoc->peer.transport_addr_list,\n\t\t\t    transports) {\n\t\tif (!list_has_sctp_addr(&asoc->peer.transport_addr_list,\n\t\t\t\t\t&new_addr->ipaddr)) {\n\t\t\tsctp_sf_send_restart_abort(net, &new_addr->ipaddr, init,\n\t\t\t\t\t\t   commands);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\treturn ret;\n}\n\n \nstatic void sctp_tietags_populate(struct sctp_association *new_asoc,\n\t\t\t\t  const struct sctp_association *asoc)\n{\n\tswitch (asoc->state) {\n\n\t \n\n\tcase SCTP_STATE_COOKIE_WAIT:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = 0;\n\t\tbreak;\n\n\tcase SCTP_STATE_COOKIE_ECHOED:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = asoc->c.peer_vtag;\n\t\tbreak;\n\n\t \n\tdefault:\n\t\tnew_asoc->c.my_ttag   = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag = asoc->c.peer_vtag;\n\t\tbreak;\n\t}\n\n\t \n\tnew_asoc->rwnd                  = asoc->rwnd;\n\tnew_asoc->c.sinit_num_ostreams  = asoc->c.sinit_num_ostreams;\n\tnew_asoc->c.sinit_max_instreams = asoc->c.sinit_max_instreams;\n\tnew_asoc->c.initial_tsn         = asoc->c.initial_tsn;\n}\n\n \nstatic char sctp_tietags_compare(struct sctp_association *new_asoc,\n\t\t\t\t const struct sctp_association *asoc)\n{\n\t \n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag != new_asoc->c.peer_vtag) &&\n\t    (asoc->c.my_vtag == new_asoc->c.my_ttag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_ttag))\n\t\treturn 'A';\n\n\t \n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    ((asoc->c.peer_vtag != new_asoc->c.peer_vtag) ||\n\t     (0 == asoc->c.peer_vtag))) {\n\t\treturn 'B';\n\t}\n\n\t \n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag))\n\t\treturn 'D';\n\n\t \n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag) &&\n\t    (0 == new_asoc->c.my_ttag) &&\n\t    (0 == new_asoc->c.peer_ttag))\n\t\treturn 'C';\n\n\t \n\treturn 'E';\n}\n\n \nstatic enum sctp_disposition sctp_sf_do_unexpected_init(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg, *repl, *err_chunk;\n\tstruct sctp_unrecognized_param *unk_param;\n\tstruct sctp_association *new_asoc;\n\tenum sctp_disposition retval;\n\tstruct sctp_packet *packet;\n\tint len;\n\n\t \n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\tif (SCTP_INPUT_CB(chunk->skb)->encap_port != chunk->transport->encap_port)\n\t\treturn sctp_sf_new_encap_port(net, ep, asoc, type, arg, commands);\n\n\t \n\tchunk->subh.init_hdr = (struct sctp_inithdr *)chunk->skb->data;\n\n\t \n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(struct sctp_inithdr));\n\n\t \n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (struct sctp_init_chunk *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t \n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(struct sctp_chunkhdr),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(struct sctp_chunkhdr));\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\tretval = SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t \n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\t \n\tif (security_sctp_assoc_request(new_asoc, chunk->skb)) {\n\t\tsctp_association_free(new_asoc);\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\tsctp_scope(sctp_source(chunk)), GFP_ATOMIC) < 0)\n\t\tgoto nomem;\n\n\t \n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (struct sctp_init_chunk *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t \n\tif (!sctp_state(asoc, COOKIE_WAIT)) {\n\t\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk,\n\t\t\t\t\t\t commands)) {\n\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\tgoto nomem_retval;\n\t\t}\n\t}\n\n\tsctp_tietags_populate(new_asoc, asoc);\n\n\t \n\n\t \n\tlen = 0;\n\tif (err_chunk) {\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t      sizeof(struct sctp_chunkhdr);\n\t}\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t \n\tif (err_chunk) {\n\t\t \n\t\tunk_param = (struct sctp_unrecognized_param *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(struct sctp_chunkhdr));\n\t\t \n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\treturn retval;\n\nnomem:\n\tretval = SCTP_DISPOSITION_NOMEM;\nnomem_retval:\n\tif (new_asoc)\n\t\tsctp_association_free(new_asoc);\ncleanup:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn retval;\n}\n\n \nenum sctp_disposition sctp_sf_do_5_2_1_siminit(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t \n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n \nenum sctp_disposition sctp_sf_do_5_2_2_dupinit(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t \n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n\n \nenum sctp_disposition sctp_sf_do_5_2_3_initack(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t \n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep)\n\t\treturn sctp_sf_ootb(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n}\n\nstatic int sctp_sf_do_assoc_update(struct sctp_association *asoc,\n\t\t\t\t   struct sctp_association *new,\n\t\t\t\t   struct sctp_cmd_seq *cmds)\n{\n\tstruct net *net = asoc->base.net;\n\tstruct sctp_chunk *abort;\n\n\tif (!sctp_assoc_update(asoc, new))\n\t\treturn 0;\n\n\tabort = sctp_make_abort(asoc, NULL, sizeof(struct sctp_errhdr));\n\tif (abort) {\n\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\tsctp_add_cmd_sf(cmds, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\t}\n\tsctp_add_cmd_sf(cmds, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(ECONNABORTED));\n\tsctp_add_cmd_sf(cmds, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_RSRC_LOW));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn -ENOMEM;\n}\n\n \nstatic enum sctp_disposition sctp_sf_do_dupcook_a(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_init_chunk *peer_init;\n\tenum sctp_disposition disposition;\n\tstruct sctp_ulpevent *ev;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_chunk *err;\n\n\t \n\tpeer_init = (struct sctp_init_chunk *)(chunk->subh.cookie_hdr + 1);\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\tif (sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC))\n\t\tgoto nomem;\n\n\tif (!sctp_auth_chunk_verify(net, chunk, new_asoc))\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t \n\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk, commands))\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\t \n\tif (sctp_state(asoc, SHUTDOWN_ACK_SENT)) {\n\t\tdisposition = __sctp_sf_do_9_2_reshutack(net, ep, asoc,\n\t\t\t\t\t\t\t SCTP_ST_CHUNK(chunk->chunk_hdr->type),\n\t\t\t\t\t\t\t chunk, commands);\n\t\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\t\tgoto nomem;\n\n\t\terr = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t SCTP_ERROR_COOKIE_IN_SHUTDOWN,\n\t\t\t\t\t NULL, 0, 0);\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_OUTQUEUE, SCTP_NULL());\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_ASCONF_QUEUE, SCTP_NULL());\n\n\t \n\tif (sctp_sf_do_assoc_update((struct sctp_association *)asoc, new_asoc, commands))\n\t\tgoto nomem;\n\n\trepl = sctp_make_cookie_ack(asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t \n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_RESTART, 0,\n\t\t\t\t\t     asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\tif ((sctp_state(asoc, SHUTDOWN_PENDING) ||\n\t     sctp_state(asoc, SHUTDOWN_SENT)) &&\n\t    (sctp_sstate(asoc->base.sk, CLOSING) ||\n\t     sock_flag(asoc->base.sk, SOCK_DEAD))) {\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t\treturn sctp_sf_do_9_2_start_shutdown(net, ep, asoc,\n\t\t\t\t\t\t     SCTP_ST_CHUNK(0), repl,\n\t\t\t\t\t\t     commands);\n\t} else {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \n \nstatic enum sctp_disposition sctp_sf_do_dupcook_b(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_init_chunk *peer_init;\n\tstruct sctp_chunk *repl;\n\n\t \n\tpeer_init = (struct sctp_init_chunk *)(chunk->subh.cookie_hdr + 1);\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\tif (sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC))\n\t\tgoto nomem;\n\n\tif (!sctp_auth_chunk_verify(net, chunk, new_asoc))\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tif (asoc->state < SCTP_STATE_ESTABLISHED)\n\t\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\t \n\tif (sctp_sf_do_assoc_update((struct sctp_association *)asoc, new_asoc, commands))\n\t\tgoto nomem;\n\n\trepl = sctp_make_cookie_ack(asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t \n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_CHANGE, SCTP_U8(SCTP_COMM_UP));\n\n\t \n\tif (asoc->peer.adaptation_ind)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ADAPTATION_IND, SCTP_NULL());\n\n\tif (!asoc->peer.auth_capable)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PEER_NO_AUTH, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \n \nstatic enum sctp_disposition sctp_sf_do_dupcook_c(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\t \n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n \n \nstatic enum sctp_disposition sctp_sf_do_dupcook_d(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_ulpevent *ev = NULL, *ai_ev = NULL, *auth_ev = NULL;\n\tstruct sctp_chunk *repl;\n\n\t \n\n\tif (!sctp_auth_chunk_verify(net, chunk, asoc))\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t \n\tif (asoc->state < SCTP_STATE_ESTABLISHED) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START,\n\t\t\t\tSCTP_NULL());\n\n\t\t \n\t\tev = sctp_ulpevent_make_assoc_change(asoc, 0,\n\t\t\t\t\t     SCTP_COMM_UP, 0,\n\t\t\t\t\t     asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\t \n\t\tif (asoc->peer.adaptation_ind) {\n\t\t\tai_ev = sctp_ulpevent_make_adaptation_indication(asoc,\n\t\t\t\t\t\t\t\t GFP_ATOMIC);\n\t\t\tif (!ai_ev)\n\t\t\t\tgoto nomem;\n\n\t\t}\n\n\t\tif (!asoc->peer.auth_capable) {\n\t\t\tauth_ev = sctp_ulpevent_make_authkey(asoc, 0,\n\t\t\t\t\t\t\t     SCTP_AUTH_NO_AUTH,\n\t\t\t\t\t\t\t     GFP_ATOMIC);\n\t\t\tif (!auth_ev)\n\t\t\t\tgoto nomem;\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\tif (auth_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(auth_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\tif (auth_ev)\n\t\tsctp_ulpevent_free(auth_ev);\n\tif (ai_ev)\n\t\tsctp_ulpevent_free(ai_ev);\n\tif (ev)\n\t\tsctp_ulpevent_free(ev);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nenum sctp_disposition sctp_sf_do_5_2_4_dupcook(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_chunk *chunk = arg;\n\tenum sctp_disposition retval;\n\tstruct sctp_chunk *err_chk_p;\n\tint error = 0;\n\tchar action;\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr))) {\n\t\tif (!sctp_vtag_verify(chunk, asoc))\n\t\t\tasoc = NULL;\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg, commands);\n\t}\n\n\t \n\tchunk->subh.cookie_hdr = (struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(struct sctp_chunkhdr)))\n\t\tgoto nomem;\n\n\t \n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t \n\tif (!new_asoc) {\n\t\t \n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\t \n\tif (security_sctp_assoc_request(new_asoc, chunk->head_skb ?: chunk->skb)) {\n\t\tsctp_association_free(new_asoc);\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t \n\tnew_asoc->temp = 1;\n\n\t \n\taction = sctp_tietags_compare(new_asoc, asoc);\n\n\tswitch (action) {\n\tcase 'A':  \n\t\tretval = sctp_sf_do_dupcook_a(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'B':  \n\t\tretval = sctp_sf_do_dupcook_b(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'C':  \n\t\tretval = sctp_sf_do_dupcook_c(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'D':  \n\t\tretval = sctp_sf_do_dupcook_d(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tdefault:  \n\t\tretval = sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tbreak;\n\t}\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC,\n\t\t\t SCTP_ASOC((struct sctp_association *)asoc));\n\n\treturn retval;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nenum sctp_disposition sctp_sf_shutdown_pending_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_err_chunk_valid(chunk))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n \nenum sctp_disposition sctp_sf_shutdown_sent_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_err_chunk_valid(chunk))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n \nenum sctp_disposition sctp_sf_shutdown_ack_sent_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t \n\treturn sctp_sf_shutdown_sent_abort(net, ep, asoc, type, arg, commands);\n}\n\n \nenum sctp_disposition sctp_sf_cookie_echoed_err(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_errhdr *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_operr_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t \n\t \n\tsctp_walk_errors(err, chunk->chunk_hdr) {\n\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause)\n\t\t\treturn sctp_sf_do_5_2_6_stale(net, ep, asoc, type,\n\t\t\t\t\t\t\targ, commands);\n\t}\n\n\t \n\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n\n \nstatic enum sctp_disposition sctp_sf_do_5_2_6_stale(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tint attempts = asoc->init_err_counter + 1;\n\tstruct sctp_chunk *chunk = arg, *reply;\n\tstruct sctp_cookie_preserve_param bht;\n\tstruct sctp_bind_addr *bp;\n\tstruct sctp_errhdr *err;\n\tu32 stale;\n\n\tif (attempts > asoc->max_init_attempts) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_STALE_COOKIE));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\terr = (struct sctp_errhdr *)(chunk->skb->data);\n\n\t \n\tstale = ntohl(*(__be32 *)((u8 *)err + sizeof(*err)));\n\tstale = (stale * 2) / 1000;\n\n\tbht.param_hdr.type = SCTP_PARAM_COOKIE_PRESERVATIVE;\n\tbht.param_hdr.length = htons(sizeof(bht));\n\tbht.lifespan_increment = htonl(stale);\n\n\t \n\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\treply = sctp_make_init(asoc, bp, GFP_ATOMIC, sizeof(bht));\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_addto_chunk(reply, sizeof(bht), &bht);\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_CLEAR_INIT_TAG, SCTP_NULL());\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_DEL_NON_PRIMARY, SCTP_NULL());\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_T1_RETRAN,\n\t\t\tSCTP_TRANSPORT(asoc->peer.primary_path));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_INC, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nenum sctp_disposition sctp_sf_do_9_1_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_err_chunk_valid(chunk))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\nstatic enum sctp_disposition __sctp_sf_do_9_1_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\n\t \n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr))\n\t\terror = ((struct sctp_errhdr *)chunk->skb->data)->cause;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(ECONNRESET));\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED, SCTP_PERR(error));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n \nenum sctp_disposition sctp_sf_cookie_wait_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_abort_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr))\n\t\terror = ((struct sctp_errhdr *)chunk->skb->data)->cause;\n\n\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED, asoc,\n\t\t\t\t      chunk->transport);\n}\n\n \nenum sctp_disposition sctp_sf_cookie_wait_icmp_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\treturn sctp_stop_t1_and_abort(net, commands, SCTP_ERROR_NO_ERROR,\n\t\t\t\t      ENOPROTOOPT, asoc,\n\t\t\t\t      (struct sctp_transport *)arg);\n}\n\n \nenum sctp_disposition sctp_sf_cookie_echoed_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t \n\treturn sctp_sf_cookie_wait_abort(net, ep, asoc, type, arg, commands);\n}\n\n \nstatic enum sctp_disposition sctp_stop_t1_and_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\t__be16 error, int sk_err,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_transport *transport)\n{\n\tpr_debug(\"%s: ABORT received (INIT)\\n\", __func__);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(sk_err));\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(error));\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n \nenum sctp_disposition sctp_sf_do_9_2_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tenum sctp_disposition disposition;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_shutdownhdr *sdh;\n\tstruct sctp_ulpevent *ev;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t \n\tsdh = (struct sctp_shutdownhdr *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(*sdh));\n\tchunk->subh.shutdown_hdr = sdh;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t \n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t \n\tev = sctp_ulpevent_make_shutdown_event(asoc, 0, GFP_ATOMIC);\n\tif (!ev) {\n\t\tdisposition = SCTP_DISPOSITION_NOMEM;\n\t\tgoto out;\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_RECEIVED));\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_shutdown_ack(net, ep, asoc, type,\n\t\t\t\t\t\t\t  arg, commands);\n\t}\n\n\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\tgoto out;\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(chunk->subh.shutdown_hdr->cum_tsn_ack));\n\nout:\n\treturn disposition;\n}\n\n \nenum sctp_disposition sctp_sf_do_9_2_shut_ctsn(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_shutdownhdr *sdh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tsdh = (struct sctp_shutdownhdr *)chunk->skb->data;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t \n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(sdh->cum_tsn_ack));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nstatic enum sctp_disposition\n__sctp_sf_do_9_2_reshutack(struct net *net, const struct sctp_endpoint *ep,\n\t\t\t   const struct sctp_association *asoc,\n\t\t\t   const union sctp_subtype type, void *arg,\n\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t \n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (NULL == reply)\n\t\tgoto nomem;\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\nenum sctp_disposition\nsctp_sf_do_9_2_reshutack(struct net *net, const struct sctp_endpoint *ep,\n\t\t\t const struct sctp_association *asoc,\n\t\t\t const union sctp_subtype type, void *arg,\n\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_init_chunk)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_2_reshutack(net, ep, asoc, type, arg, commands);\n}\n\n \nenum sctp_disposition sctp_sf_do_ecn_cwr(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const union sctp_subtype type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_cwrhdr *cwr;\n\tu32 lowest_tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_ecne_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcwr = (struct sctp_cwrhdr *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(*cwr));\n\n\tlowest_tsn = ntohl(cwr->lowest_tsn);\n\n\t \n\tif (TSN_lte(asoc->last_ecne_tsn, lowest_tsn)) {\n\t\t \n\t\tsctp_add_cmd_sf(commands,\n\t\t\t\tSCTP_CMD_ECN_CWR,\n\t\t\t\tSCTP_U32(lowest_tsn));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_do_ecne(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const union sctp_subtype type,\n\t\t\t\t      void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ecnehdr *ecne;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_ecne_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tecne = (struct sctp_ecnehdr *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(*ecne));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_ECNE,\n\t\t\tSCTP_U32(ntohl(ecne->lowest_tsn)));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_eat_data_6_2(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tunion sctp_arg force = SCTP_NOFORCE();\n\tstruct sctp_chunk *chunk = arg;\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sctp_datachk_len(&asoc->stream)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands);\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\t\tbreak;\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_noforce;\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_force;\n\tcase SCTP_IERROR_NO_DATA:\n\t\treturn SCTP_DISPOSITION_ABORT;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t\t\t       (u8 *)chunk->subh.data_hdr,\n\t\t\t\t\t       sctp_datahdr_len(&asoc->stream));\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_SACK_IMM)\n\t\tforce = SCTP_FORCE();\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t \n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_force:\n\t \n\t \n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_DISCARD;\n\ndiscard_noforce:\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n \nenum sctp_disposition sctp_sf_eat_data_fast_4_4(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sctp_datachk_len(&asoc->stream)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands);\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tbreak;\n\tcase SCTP_IERROR_NO_DATA:\n\t\treturn SCTP_DISPOSITION_ABORT;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t\t\t       (u8 *)chunk->subh.data_hdr,\n\t\t\t\t\t       sctp_datahdr_len(&asoc->stream));\n\tdefault:\n\t\tBUG();\n\t}\n\n\t \n\n\t \n\tif (chunk->end_of_packet) {\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_eat_sack_6_2(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_sackhdr *sackh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_sack_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t \n\tsackh = sctp_sm_pull_sack(chunk);\n\t \n\tif (!sackh)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tchunk->subh.sack_hdr = sackh;\n\tctsn = ntohl(sackh->cum_tsn_ack);\n\n\t \n\tif (TSN_lte(asoc->next_tsn, ctsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\ttrace_sctp_probe(ep, asoc, chunk);\n\n\t \n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK, SCTP_CHUNK(chunk));\n\n\t \n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nstatic enum sctp_disposition sctp_sf_tabort_8_4_8(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\tif (!packet)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t \n\tabort = sctp_make_abort(asoc, chunk, 0);\n\tif (!abort) {\n\t\tsctp_ootb_pkt_free(packet);\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\t}\n\n\t \n\tif (sctp_test_T_bit(abort))\n\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t \n\tabort->skb->sk = ep->base.sk;\n\n\tsctp_packet_append_chunk(packet, abort);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(packet));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nstatic enum sctp_disposition sctp_sf_new_encap_port(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\tif (!packet)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tabort = sctp_make_new_encap_port(asoc, chunk);\n\tif (!abort) {\n\t\tsctp_ootb_pkt_free(packet);\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\t}\n\n\tabort->skb->sk = ep->base.sk;\n\n\tsctp_packet_append_chunk(packet, abort);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_operr_notify(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_errhdr *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_operr_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\tsctp_walk_errors(err, chunk->chunk_hdr);\n\tif ((void *)err != (void *)chunk->chunk_end)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err, commands);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_OPERR,\n\t\t\tSCTP_CHUNK(chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_do_9_2_final(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t \n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem;\n\n\t \n\treply = sctp_make_shutdown_complete(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem_chunk;\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_chunk:\n\tsctp_ulpevent_free(ev);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nenum sctp_disposition sctp_sf_ootb(struct net *net,\n\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t   void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tstruct sctp_chunkhdr *ch;\n\tstruct sctp_errhdr *err;\n\tint ootb_cookie_ack = 0;\n\tint ootb_shut_ack = 0;\n\t__u8 *ch_end;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\tif (asoc && !sctp_vtag_verify(chunk, asoc))\n\t\tasoc = NULL;\n\n\tch = (struct sctp_chunkhdr *)chunk->chunk_hdr;\n\tdo {\n\t\t \n\t\tif (ntohs(ch->length) < sizeof(*ch))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\t \n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\t \n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\n\t\t \n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t \n\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tch = (struct sctp_chunkhdr *)ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}\n\n \nstatic enum sctp_disposition sctp_sf_shut_8_4_5(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *shut;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\tif (!packet)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t \n\tshut = sctp_make_shutdown_complete(asoc, chunk);\n\tif (!shut) {\n\t\tsctp_ootb_pkt_free(packet);\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\t}\n\n\t \n\tif (sctp_test_T_bit(shut))\n\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t \n\tshut->skb->sk = ep->base.sk;\n\n\tsctp_packet_append_chunk(packet, shut);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t \n\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n\n \nenum sctp_disposition sctp_sf_do_8_5_1_E_sa(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\tasoc = NULL;\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t \n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\treturn sctp_sf_shut_8_4_5(net, ep, NULL, type, arg, commands);\n}\n\n \nenum sctp_disposition sctp_sf_do_asconf(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_paramhdr *err_param = NULL;\n\tstruct sctp_chunk *asconf_ack = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_addiphdr *hdr;\n\t__u32 serial;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_addip_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t \n\tif (!asoc->peer.asconf_capable ||\n\t    (!net->sctp.addip_noauth && !chunk->auth))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\thdr = (struct sctp_addiphdr *)chunk->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\t \n\tif (!sctp_verify_asconf(asoc, chunk, true, &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err_param, commands);\n\n\t \n\tif (serial == asoc->peer.addip_serial + 1) {\n\t\t \n\t\tif (!chunk->has_asconf)\n\t\t\tsctp_assoc_clean_asconf_ack_cache(asoc);\n\n\t\t \n\t\tasconf_ack = sctp_process_asconf((struct sctp_association *)\n\t\t\t\t\t\t asoc, chunk);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t} else if (serial < asoc->peer.addip_serial + 1) {\n\t\t \n\t\tasconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t\t \n\t\tasconf_ack->transport = NULL;\n\t} else {\n\t\t \n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t \n\tasconf_ack->dest = chunk->source;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack));\n\tif (asoc->new_transport) {\n\t\tsctp_sf_heartbeat(ep, asoc, type, asoc->new_transport, commands);\n\t\t((struct sctp_association *)asoc)->new_transport = NULL;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\nstatic enum sctp_disposition sctp_send_next_asconf(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tstruct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *asconf;\n\tstruct list_head *entry;\n\n\tif (list_empty(&asoc->addip_chunk_list))\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\n\tentry = asoc->addip_chunk_list.next;\n\tasconf = list_entry(entry, struct sctp_chunk, list);\n\n\tlist_del_init(entry);\n\tsctp_chunk_hold(asconf);\n\tasoc->addip_last_asconf = asconf;\n\n\treturn sctp_sf_do_prm_asconf(net, ep, asoc, type, asconf, commands);\n}\n\n \nenum sctp_disposition sctp_sf_do_asconf_ack(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *last_asconf = asoc->addip_last_asconf;\n\tstruct sctp_paramhdr *err_param = NULL;\n\tstruct sctp_chunk *asconf_ack = arg;\n\tstruct sctp_addiphdr *addip_hdr;\n\t__u32 sent_serial, rcvd_serial;\n\tstruct sctp_chunk *abort;\n\n\tif (!sctp_vtag_verify(asconf_ack, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t \n\tif (!sctp_chunk_length_valid(asconf_ack,\n\t\t\t\t     sizeof(struct sctp_addip_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t \n\tif (!asoc->peer.asconf_capable ||\n\t    (!net->sctp.addip_noauth && !asconf_ack->auth))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\taddip_hdr = (struct sctp_addiphdr *)asconf_ack->skb->data;\n\trcvd_serial = ntohl(addip_hdr->serial);\n\n\t \n\tif (!sctp_verify_asconf(asoc, asconf_ack, false, &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t   (void *)err_param, commands);\n\n\tif (last_asconf) {\n\t\taddip_hdr = last_asconf->subh.addip_hdr;\n\t\tsent_serial = ntohl(addip_hdr->serial);\n\t} else {\n\t\tsent_serial = asoc->addip_serial - 1;\n\t}\n\n\t \n\tif (ADDIP_SERIAL_gte(rcvd_serial, sent_serial + 1) &&\n\t    !(asoc->addip_last_asconf)) {\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(struct sctp_errhdr));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_ASCONF_ACK, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\tif ((rcvd_serial == sent_serial) && asoc->addip_last_asconf) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\t\tif (!sctp_process_asconf_ack((struct sctp_association *)asoc,\n\t\t\t\t\t     asconf_ack))\n\t\t\treturn sctp_send_next_asconf(net, ep,\n\t\t\t\t\t(struct sctp_association *)asoc,\n\t\t\t\t\t\t\ttype, commands);\n\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(struct sctp_errhdr));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n \nenum sctp_disposition sctp_sf_do_reconf(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_paramhdr *err_param = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_reconf_chunk *hdr;\n\tunion sctp_params param;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(*hdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tif (!sctp_verify_reconf(asoc, chunk, &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err_param, commands);\n\n\thdr = (struct sctp_reconf_chunk *)chunk->chunk_hdr;\n\tsctp_walk_params(param, hdr) {\n\t\tstruct sctp_chunk *reply = NULL;\n\t\tstruct sctp_ulpevent *ev = NULL;\n\n\t\tif (param.p->type == SCTP_PARAM_RESET_OUT_REQUEST)\n\t\t\treply = sctp_process_strreset_outreq(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_IN_REQUEST)\n\t\t\treply = sctp_process_strreset_inreq(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_TSN_REQUEST)\n\t\t\treply = sctp_process_strreset_tsnreq(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_ADD_OUT_STREAMS)\n\t\t\treply = sctp_process_strreset_addstrm_out(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_ADD_IN_STREAMS)\n\t\t\treply = sctp_process_strreset_addstrm_in(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\t\telse if (param.p->type == SCTP_PARAM_RESET_RESPONSE)\n\t\t\treply = sctp_process_strreset_resp(\n\t\t\t\t(struct sctp_association *)asoc, param, &ev);\n\n\t\tif (ev)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\t\tSCTP_ULPEVENT(ev));\n\n\t\tif (reply)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(reply));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_eat_fwd_tsn(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!asoc->peer.prsctp_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sctp_ftsnchk_len(&asoc->stream)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t \n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto discard_noforce;\n\n\tif (!asoc->stream.si->validate_ftsn(chunk))\n\t\tgoto discard_noforce;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sctp_ftsnhdr_len(&asoc->stream))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t \n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_NOFORCE());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_noforce:\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\nenum sctp_disposition sctp_sf_eat_fwd_tsn_fast(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!asoc->peer.prsctp_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sctp_ftsnchk_len(&asoc->stream)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t \n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto gen_shutdown;\n\n\tif (!asoc->stream.si->validate_ftsn(chunk))\n\t\tgoto gen_shutdown;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sctp_ftsnhdr_len(&asoc->stream))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t \ngen_shutdown:\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nstatic enum sctp_ierror sctp_sf_authenticate(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk)\n{\n\tstruct sctp_shared_key *sh_key = NULL;\n\tstruct sctp_authhdr *auth_hdr;\n\t__u8 *save_digest, *digest;\n\tstruct sctp_hmac *hmac;\n\tunsigned int sig_len;\n\t__u16 key_id;\n\n\t \n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\tchunk->subh.auth_hdr = auth_hdr;\n\tskb_pull(chunk->skb, sizeof(*auth_hdr));\n\n\t \n\tif (!sctp_auth_asoc_verify_hmac_id(asoc, auth_hdr->hmac_id))\n\t\treturn SCTP_IERROR_AUTH_BAD_HMAC;\n\n\t \n\tkey_id = ntohs(auth_hdr->shkey_id);\n\tif (key_id != asoc->active_key_id) {\n\t\tsh_key = sctp_auth_get_shkey(asoc, key_id);\n\t\tif (!sh_key)\n\t\t\treturn SCTP_IERROR_AUTH_BAD_KEYID;\n\t}\n\n\t \n\tsig_len = ntohs(chunk->chunk_hdr->length) -\n\t\t  sizeof(struct sctp_auth_chunk);\n\thmac = sctp_auth_get_hmac(ntohs(auth_hdr->hmac_id));\n\tif (sig_len != hmac->hmac_len)\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\n\t \n\tdigest = (u8 *)(auth_hdr + 1);\n\tskb_pull(chunk->skb, sig_len);\n\n\tsave_digest = kmemdup(digest, sig_len, GFP_ATOMIC);\n\tif (!save_digest)\n\t\tgoto nomem;\n\n\tmemset(digest, 0, sig_len);\n\n\tsctp_auth_calculate_hmac(asoc, chunk->skb,\n\t\t\t\t (struct sctp_auth_chunk *)chunk->chunk_hdr,\n\t\t\t\t sh_key, GFP_ATOMIC);\n\n\t \n\tif (memcmp(save_digest, digest, sig_len)) {\n\t\tkfree(save_digest);\n\t\treturn SCTP_IERROR_BAD_SIG;\n\t}\n\n\tkfree(save_digest);\n\tchunk->auth = 1;\n\n\treturn SCTP_IERROR_NO_ERROR;\nnomem:\n\treturn SCTP_IERROR_NOMEM;\n}\n\nenum sctp_disposition sctp_sf_eat_auth(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const union sctp_subtype type,\n\t\t\t\t       void *arg, struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_authhdr *auth_hdr;\n\tstruct sctp_chunk *err_chunk;\n\tenum sctp_ierror error;\n\n\t \n\tif (!asoc->peer.auth_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_auth_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\terror = sctp_sf_authenticate(asoc, chunk);\n\tswitch (error) {\n\tcase SCTP_IERROR_AUTH_BAD_HMAC:\n\t\t \n\t\terr_chunk = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t       SCTP_ERROR_UNSUP_HMAC,\n\t\t\t\t\t       &auth_hdr->hmac_id,\n\t\t\t\t\t       sizeof(__u16), 0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\tfallthrough;\n\tcase SCTP_IERROR_AUTH_BAD_KEYID:\n\tcase SCTP_IERROR_BAD_SIG:\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcase SCTP_IERROR_NOMEM:\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tdefault:\t\t\t \n\t\tbreak;\n\t}\n\n\tif (asoc->active_key_id != ntohs(auth_hdr->shkey_id)) {\n\t\tstruct sctp_ulpevent *ev;\n\n\t\tev = sctp_ulpevent_make_authkey(asoc, ntohs(auth_hdr->shkey_id),\n\t\t\t\t    SCTP_AUTH_NEW_KEY, GFP_ATOMIC);\n\n\t\tif (!ev)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_unk_chunk(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *unk_chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_chunkhdr *hdr;\n\n\tpr_debug(\"%s: processing unknown chunk id:%d\\n\", __func__, type.chunk);\n\n\tif (!sctp_vtag_verify(unk_chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(unk_chunk, sizeof(*hdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tswitch (type.chunk & SCTP_CID_ACTION_MASK) {\n\tcase SCTP_CID_ACTION_DISCARD:\n\t\t \n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tcase SCTP_CID_ACTION_DISCARD_ERR:\n\t\t \n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       SCTP_PAD4(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\n\t\t \n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\tcase SCTP_CID_ACTION_SKIP:\n\t\t \n\t\treturn SCTP_DISPOSITION_DISCARD;\n\tcase SCTP_CID_ACTION_SKIP_ERR:\n\t\t \n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       SCTP_PAD4(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\t \n\t\treturn SCTP_DISPOSITION_CONSUME;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n \nenum sctp_disposition sctp_sf_discard_chunk(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (asoc && !sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tpr_debug(\"%s: chunk:%d is discarded\\n\", __func__, type.chunk);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n \nenum sctp_disposition sctp_sf_pdiscard(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const union sctp_subtype type,\n\t\t\t\t       void *arg, struct sctp_cmd_seq *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_IN_PKT_DISCARDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n\n \nenum sctp_disposition sctp_sf_violation(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t \n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_chunkhdr)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\treturn SCTP_DISPOSITION_VIOLATION;\n}\n\n \nstatic enum sctp_disposition sctp_sf_abort_violation(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands,\n\t\t\t\t\tconst __u8 *payload,\n\t\t\t\t\tconst size_t paylen)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk =  arg;\n\tstruct sctp_chunk *abort = NULL;\n\n\t \n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t \n\tabort = sctp_make_abort_violation(asoc, chunk, payload, paylen);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tif (asoc) {\n\t\t \n\t\tif (chunk->chunk_hdr->type == SCTP_CID_INIT_ACK &&\n\t\t    !asoc->peer.i.init_tag) {\n\t\t\tstruct sctp_initack_chunk *initack;\n\n\t\t\tinitack = (struct sctp_initack_chunk *)chunk->chunk_hdr;\n\t\t\tif (!sctp_chunk_length_valid(chunk, sizeof(*initack)))\n\t\t\t\tabort->chunk_hdr->flags |= SCTP_CHUNK_FLAG_T;\n\t\t\telse {\n\t\t\t\tunsigned int inittag;\n\n\t\t\t\tinittag = ntohl(initack->init_hdr.init_tag);\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_INITTAG,\n\t\t\t\t\t\tSCTP_U32(inittag));\n\t\t\t}\n\t\t}\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\tif (asoc->state <= SCTP_STATE_COOKIE_ECHOED) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t}\n\t} else {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\t\tif (!packet)\n\t\t\tgoto nomem_pkt;\n\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t}\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\n\nnomem_pkt:\n\tsctp_chunk_free(abort);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nstatic enum sctp_disposition sctp_sf_violation_chunklen(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstatic const char err_str[] = \"The following chunk had invalid length:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t       sizeof(err_str));\n}\n\n \nstatic enum sctp_disposition sctp_sf_violation_paramlen(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg, void *ext,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_paramhdr *param = ext;\n\tstruct sctp_chunk *abort = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t \n\tabort = sctp_make_violation_paramlen(asoc, chunk, param);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nstatic enum sctp_disposition sctp_sf_violation_ctsn(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstatic const char err_str[] = \"The cumulative tsn ack beyond the max tsn currently sent:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t       sizeof(err_str));\n}\n\n \nstatic enum sctp_disposition sctp_sf_violation_chunk(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstatic const char err_str[] = \"The following chunk violates protocol:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t       sizeof(err_str));\n}\n \n \nenum sctp_disposition sctp_sf_do_prm_asoc(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_association *my_asoc;\n\tstruct sctp_chunk *repl;\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\n\t \n\n\trepl = sctp_make_init(asoc, &asoc->base.bind_addr, GFP_ATOMIC, 0);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\tSCTP_CHUNK(repl));\n\n\t \n\tmy_asoc = (struct sctp_association *)asoc;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(my_asoc));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nenum sctp_disposition sctp_sf_do_prm_send(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_datamsg *msg = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_MSG, SCTP_DATAMSG(msg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_do_9_2_prm_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tenum sctp_disposition disposition;\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    arg, commands);\n\t}\n\n\treturn disposition;\n}\n\n \nenum sctp_disposition sctp_sf_do_9_1_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t \n\tstruct sctp_chunk *abort = arg;\n\n\tif (abort)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\t \n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n \nenum sctp_disposition sctp_sf_error_closed(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR, SCTP_ERROR(-EINVAL));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_error_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR,\n\t\t\tSCTP_ERROR(-ESHUTDOWN));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_cookie_wait_prm_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n \nenum sctp_disposition sctp_sf_cookie_echoed_prm_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t \n\treturn sctp_sf_cookie_wait_prm_shutdown(net, ep, asoc, type, arg, commands);\n}\n\n \nenum sctp_disposition sctp_sf_cookie_wait_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *abort = arg;\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tif (abort)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\n\t \n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n \nenum sctp_disposition sctp_sf_cookie_echoed_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t \n\treturn sctp_sf_cookie_wait_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n \nenum sctp_disposition sctp_sf_shutdown_pending_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n \nenum sctp_disposition sctp_sf_shutdown_sent_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n \nenum sctp_disposition sctp_sf_shutdown_ack_sent_prm_abort(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\t \n\treturn sctp_sf_shutdown_sent_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n \nenum sctp_disposition sctp_sf_do_prm_requestheartbeat(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tif (SCTP_DISPOSITION_NOMEM == sctp_sf_heartbeat(ep, asoc, type,\n\t\t\t\t      (struct sctp_transport *)arg, commands))\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\tSCTP_TRANSPORT(arg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_do_prm_asconf(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(chunk));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_do_prm_reconf(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const union sctp_subtype type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(chunk));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_ignore_primitive(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tpr_debug(\"%s: primitive type:%d is ignored\\n\", __func__,\n\t\t type.primitive);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n \n\n \nenum sctp_disposition sctp_sf_do_no_pending_tsn(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_ulpevent *event;\n\n\tevent = sctp_ulpevent_make_sender_dry_event(asoc, GFP_ATOMIC);\n\tif (!event)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(event));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_do_9_2_start_shutdown(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *reply;\n\n\t \n\treply = sctp_make_shutdown(asoc, arg);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_SENT));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nenum sctp_disposition sctp_sf_do_9_2_shutdown_ack(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\n\t \n\tif (chunk) {\n\t\tif (!sctp_vtag_verify(chunk, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg,\n\t\t\t\t\t\tcommands);\n\n\t\t \n\t\tif (!sctp_chunk_length_valid(\n\t\t\t\tchunk, sizeof(struct sctp_shutdown_chunk)))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type,\n\t\t\t\t\t\t\t  arg, commands);\n\t}\n\n\t \n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_ACK_SENT));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nenum sctp_disposition sctp_sf_ignore_other(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tpr_debug(\"%s: the event other type:%d is ignored\\n\",\n\t\t __func__, type.other);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n \n\n \nenum sctp_disposition sctp_sf_do_6_3_3_rtx(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_transport *transport = arg;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T3_RTX_EXPIREDS);\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tif (asoc->peer.zero_window_announced &&\n\t\t    asoc->state == SCTP_STATE_SHUTDOWN_PENDING) {\n\t\t\t \n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START_ONCE,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t\t \n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t\t}\n\t}\n\n\t \n\n\t \n\n\t \n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_RETRAN, SCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_do_6_2_sack(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  struct sctp_cmd_seq *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_DELAY_SACK_EXPIREDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_t1_init_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tint attempts = asoc->init_err_counter + 1;\n\tstruct sctp_chunk *repl = NULL;\n\tstruct sctp_bind_addr *bp;\n\n\tpr_debug(\"%s: timer T1 expired (INIT)\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_INIT_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\t\trepl = sctp_make_init(asoc, bp, GFP_ATOMIC, 0);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tpr_debug(\"%s: giving up on INIT, attempts:%d \"\n\t\t\t \"max_init_attempts:%d\\n\", __func__, attempts,\n\t\t\t asoc->max_init_attempts);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_t1_cookie_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tint attempts = asoc->init_err_counter + 1;\n\tstruct sctp_chunk *repl = NULL;\n\n\tpr_debug(\"%s: timer T1 expired (COOKIE-ECHO)\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_COOKIE_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\trepl = sctp_make_cookie_echo(asoc, NULL);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_COOKIEECHO_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_t2_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tpr_debug(\"%s: timer T2 expired\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T2_SHUTDOWN_EXPIREDS);\n\n\t((struct sctp_association *)asoc)->shutdown_retries++;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\treply = sctp_make_shutdown(asoc, NULL);\n\t\tbreak;\n\n\tcase SCTP_STATE_SHUTDOWN_ACK_SENT:\n\t\treply = sctp_make_shutdown_ack(asoc, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tif (!reply)\n\t\tgoto nomem;\n\n\t \n\tif (asoc->shutdown_last_sent_to)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(asoc->shutdown_last_sent_to));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nenum sctp_disposition sctp_sf_t4_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *chunk = asoc->addip_last_asconf;\n\tstruct sctp_transport *transport = chunk->transport;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T4_RTO_EXPIREDS);\n\n\t \n\tif (transport)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\n\t \n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\t \n\n\t \n\tsctp_chunk_hold(asoc->addip_last_asconf);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\tSCTP_CHUNK(asoc->addip_last_asconf));\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \nenum sctp_disposition sctp_sf_t5_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tpr_debug(\"%s: timer T5 expired\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);\n\n\treply = sctp_make_abort(asoc, NULL, 0);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ETIMEDOUT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n \nenum sctp_disposition sctp_sf_autoclose_timer_expire(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst union sctp_subtype type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tstruct sctp_cmd_seq *commands)\n{\n\tenum sctp_disposition disposition;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_AUTOCLOSE_EXPIREDS);\n\n\t \n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    NULL, commands);\n\t}\n\n\treturn disposition;\n}\n\n \n\n \nenum sctp_disposition sctp_sf_not_impl(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const union sctp_subtype type,\n\t\t\t\t       void *arg, struct sctp_cmd_seq *commands)\n{\n\treturn SCTP_DISPOSITION_NOT_IMPL;\n}\n\n \nenum sctp_disposition sctp_sf_bug(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  const union sctp_subtype type,\n\t\t\t\t  void *arg, struct sctp_cmd_seq *commands)\n{\n\treturn SCTP_DISPOSITION_BUG;\n}\n\n \nenum sctp_disposition sctp_sf_timer_ignore(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const union sctp_subtype type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   struct sctp_cmd_seq *commands)\n{\n\tpr_debug(\"%s: timer %d ignored\\n\", __func__, type.chunk);\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n \n\n \nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk)\n{\n\tstruct sctp_sackhdr *sack;\n\t__u16 num_dup_tsns;\n\tunsigned int len;\n\t__u16 num_blocks;\n\n\t \n\tsack = (struct sctp_sackhdr *) chunk->skb->data;\n\n\tnum_blocks = ntohs(sack->num_gap_ack_blocks);\n\tnum_dup_tsns = ntohs(sack->num_dup_tsns);\n\tlen = sizeof(struct sctp_sackhdr);\n\tlen += (num_blocks + num_dup_tsns) * sizeof(__u32);\n\tif (len > chunk->skb->len)\n\t\treturn NULL;\n\n\tskb_pull(chunk->skb, len);\n\n\treturn sack;\n}\n\n \nstatic struct sctp_packet *sctp_abort_pkt_new(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tconst void *payload, size_t paylen)\n{\n\tstruct sctp_packet *packet;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t \n\t\tabort = sctp_make_abort(asoc, chunk, paylen);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t \n\t\tsctp_addto_chunk(abort, paylen, payload);\n\n\t\t \n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t}\n\n\treturn packet;\n}\n\n \nstatic struct sctp_packet *sctp_ootb_pkt_new(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_transport *transport;\n\tstruct sctp_packet *packet;\n\t__u16 sport, dport;\n\t__u32 vtag;\n\n\t \n\tsport = ntohs(chunk->sctp_hdr->dest);\n\tdport = ntohs(chunk->sctp_hdr->source);\n\n\t \n\tif (asoc) {\n\t\t \n\t\tswitch (chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT:\n\t\tcase SCTP_CID_INIT_ACK:\n\t\t{\n\t\t\tstruct sctp_initack_chunk *initack;\n\n\t\t\tinitack = (struct sctp_initack_chunk *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(initack->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = asoc->peer.i.init_tag;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tswitch (chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT:\n\t\t{\n\t\t\tstruct sctp_init_chunk *init;\n\n\t\t\tinit = (struct sctp_init_chunk *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(init->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = ntohl(chunk->sctp_hdr->vtag);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\ttransport = sctp_transport_new(net, sctp_source(chunk), GFP_ATOMIC);\n\tif (!transport)\n\t\tgoto nomem;\n\n\ttransport->encap_port = SCTP_INPUT_CB(chunk->skb)->encap_port;\n\n\t \n\tsctp_transport_route(transport, (union sctp_addr *)&chunk->dest,\n\t\t\t     sctp_sk(net->sctp.ctl_sock));\n\n\tpacket = &transport->packet;\n\tsctp_packet_init(packet, transport, sport, dport);\n\tsctp_packet_config(packet, vtag, 0);\n\n\treturn packet;\n\nnomem:\n\treturn NULL;\n}\n\n \nvoid sctp_ootb_pkt_free(struct sctp_packet *packet)\n{\n\tsctp_transport_free(packet->transport);\n}\n\n \nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       struct sctp_cmd_seq *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk)\n{\n\tstruct sctp_packet *packet;\n\n\tif (err_chunk) {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\t\tif (packet) {\n\t\t\tstruct sctp_signed_cookie *cookie;\n\n\t\t\t \n\t\t\tcookie = chunk->subh.cookie_hdr;\n\t\t\tpacket->vtag = cookie->c.peer_vtag;\n\n\t\t\t \n\t\t\terr_chunk->skb->sk = ep->base.sk;\n\t\t\tsctp_packet_append_chunk(packet, err_chunk);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t} else\n\t\t\tsctp_chunk_free (err_chunk);\n\t}\n}\n\n\n \nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t struct sctp_cmd_seq *commands)\n{\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_datahdr *data_hdr;\n\tstruct sctp_chunk *err;\n\tenum sctp_verb deliver;\n\tsize_t datalen;\n\t__u32 tsn;\n\tint tmp;\n\n\tdata_hdr = (struct sctp_datahdr *)chunk->skb->data;\n\tchunk->subh.data_hdr = data_hdr;\n\tskb_pull(chunk->skb, sctp_datahdr_len(&asoc->stream));\n\n\ttsn = ntohl(data_hdr->tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t \n\n\t \n\n\tif (asoc->peer.ecn_capable && !chunk->ecn_ce_done) {\n\t\tstruct sctp_af *af = SCTP_INPUT_CB(chunk->skb)->af;\n\t\tchunk->ecn_ce_done = 1;\n\n\t\tif (af->is_ce(sctp_gso_headskb(chunk->skb))) {\n\t\t\t \n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_CE,\n\t\t\t\t\tSCTP_U32(tsn));\n\t\t}\n\t}\n\n\ttmp = sctp_tsnmap_check(&asoc->peer.tsn_map, tsn);\n\tif (tmp < 0) {\n\t\t \n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.outofseqtsns++;\n\t\treturn SCTP_IERROR_HIGH_TSN;\n\t} else if (tmp > 0) {\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_DUP, SCTP_U32(tsn));\n\t\treturn SCTP_IERROR_DUP_TSN;\n\t}\n\n\t \n\n\t \n\tdatalen = ntohs(chunk->chunk_hdr->length);\n\tdatalen -= sctp_datachk_len(&asoc->stream);\n\n\tdeliver = SCTP_CMD_CHUNK_ULP;\n\n\t \n\tif ((datalen >= asoc->rwnd) && (!asoc->ulpq.pd_mode)) {\n\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PART_DELIVER, SCTP_NULL());\n\t}\n\n\t \n\tif ((!chunk->data_accepted) && (!asoc->rwnd || asoc->rwnd_over ||\n\t    (datalen > asoc->rwnd + asoc->frag_point))) {\n\n\t\t \n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: reneging for tsn:%u\\n\", __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t} else {\n\t\t\tpr_debug(\"%s: discard tsn:%u len:%zu, rwnd:%d\\n\",\n\t\t\t\t __func__, tsn, datalen, asoc->rwnd);\n\n\t\t\treturn SCTP_IERROR_IGNORE_TSN;\n\t\t}\n\t}\n\n\t \n\tif (sk_under_memory_pressure(sk)) {\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: under pressure, reneging for tsn:%u\\n\",\n\t\t\t\t __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t}\n\t}\n\n\t \n\tif (unlikely(0 == datalen)) {\n\t\terr = sctp_make_abort_no_data(asoc, chunk, tsn);\n\t\tif (err) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\t}\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_DATA));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_IERROR_NO_DATA;\n\t}\n\n\tchunk->data_accepted = 1;\n\n\t \n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INUNORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iuodchunks++;\n\t} else {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iodchunks++;\n\t}\n\n\t \n\tif (ntohs(data_hdr->stream) >= asoc->stream.incnt) {\n\t\t \n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_TSN, SCTP_U32(tsn));\n\n\t\terr = sctp_make_op_error(asoc, chunk, SCTP_ERROR_INV_STRM,\n\t\t\t\t\t &data_hdr->stream,\n\t\t\t\t\t sizeof(data_hdr->stream),\n\t\t\t\t\t sizeof(u16));\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\treturn SCTP_IERROR_BAD_STREAM;\n\t}\n\n\t \n\tif (!asoc->stream.si->validate_data(chunk))\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\n\t \n\tsctp_add_cmd_sf(commands, deliver, SCTP_CHUNK(chunk));\n\n\treturn SCTP_IERROR_NO_ERROR;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}