{
  "module_name": "outqueue.c",
  "hash_id": "7d98b8af89e9d1986753dff8cd2be9a01b923a15cd04969da196148064364039",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/outqueue.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/list.h>    \n#include <linux/socket.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <net/sock.h>\t   \n\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/stream_sched.h>\n#include <trace/events/sctp.h>\n\n \nstatic int sctp_acked(struct sctp_sackhdr *sack, __u32 tsn);\nstatic void sctp_check_transmitted(struct sctp_outq *q,\n\t\t\t\t   struct list_head *transmitted_queue,\n\t\t\t\t   struct sctp_transport *transport,\n\t\t\t\t   union sctp_addr *saddr,\n\t\t\t\t   struct sctp_sackhdr *sack,\n\t\t\t\t   __u32 *highest_new_tsn);\n\nstatic void sctp_mark_missing(struct sctp_outq *q,\n\t\t\t      struct list_head *transmitted_queue,\n\t\t\t      struct sctp_transport *transport,\n\t\t\t      __u32 highest_new_tsn,\n\t\t\t      int count_of_newacks);\n\nstatic void sctp_outq_flush(struct sctp_outq *q, int rtx_timeout, gfp_t gfp);\n\n \nstatic inline void sctp_outq_head_data(struct sctp_outq *q,\n\t\t\t\t       struct sctp_chunk *ch)\n{\n\tstruct sctp_stream_out_ext *oute;\n\t__u16 stream;\n\n\tlist_add(&ch->list, &q->out_chunk_list);\n\tq->out_qlen += ch->skb->len;\n\n\tstream = sctp_chunk_stream_no(ch);\n\toute = SCTP_SO(&q->asoc->stream, stream)->ext;\n\tlist_add(&ch->stream_list, &oute->outq);\n}\n\n \nstatic inline struct sctp_chunk *sctp_outq_dequeue_data(struct sctp_outq *q)\n{\n\treturn q->sched->dequeue(q);\n}\n\n \nstatic inline void sctp_outq_tail_data(struct sctp_outq *q,\n\t\t\t\t       struct sctp_chunk *ch)\n{\n\tstruct sctp_stream_out_ext *oute;\n\t__u16 stream;\n\n\tlist_add_tail(&ch->list, &q->out_chunk_list);\n\tq->out_qlen += ch->skb->len;\n\n\tstream = sctp_chunk_stream_no(ch);\n\toute = SCTP_SO(&q->asoc->stream, stream)->ext;\n\tlist_add_tail(&ch->stream_list, &oute->outq);\n}\n\n \nstatic inline int sctp_cacc_skip_3_1_d(struct sctp_transport *primary,\n\t\t\t\t       struct sctp_transport *transport,\n\t\t\t\t       int count_of_newacks)\n{\n\tif (count_of_newacks >= 2 && transport != primary)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic inline int sctp_cacc_skip_3_1_f(struct sctp_transport *transport,\n\t\t\t\t       int count_of_newacks)\n{\n\tif (count_of_newacks < 2 &&\n\t\t\t(transport && !transport->cacc.cacc_saw_newack))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic inline int sctp_cacc_skip_3_1(struct sctp_transport *primary,\n\t\t\t\t     struct sctp_transport *transport,\n\t\t\t\t     int count_of_newacks)\n{\n\tif (!primary->cacc.cycling_changeover) {\n\t\tif (sctp_cacc_skip_3_1_d(primary, transport, count_of_newacks))\n\t\t\treturn 1;\n\t\tif (sctp_cacc_skip_3_1_f(transport, count_of_newacks))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n \nstatic inline int sctp_cacc_skip_3_2(struct sctp_transport *primary, __u32 tsn)\n{\n\tif (primary->cacc.cycling_changeover &&\n\t    TSN_lt(tsn, primary->cacc.next_tsn_at_change))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic inline int sctp_cacc_skip(struct sctp_transport *primary,\n\t\t\t\t struct sctp_transport *transport,\n\t\t\t\t int count_of_newacks,\n\t\t\t\t __u32 tsn)\n{\n\tif (primary->cacc.changeover_active &&\n\t    (sctp_cacc_skip_3_1(primary, transport, count_of_newacks) ||\n\t     sctp_cacc_skip_3_2(primary, tsn)))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nvoid sctp_outq_init(struct sctp_association *asoc, struct sctp_outq *q)\n{\n\tmemset(q, 0, sizeof(struct sctp_outq));\n\n\tq->asoc = asoc;\n\tINIT_LIST_HEAD(&q->out_chunk_list);\n\tINIT_LIST_HEAD(&q->control_chunk_list);\n\tINIT_LIST_HEAD(&q->retransmit);\n\tINIT_LIST_HEAD(&q->sacked);\n\tINIT_LIST_HEAD(&q->abandoned);\n\tsctp_sched_set_sched(asoc, sctp_sk(asoc->base.sk)->default_ss);\n}\n\n \nstatic void __sctp_outq_teardown(struct sctp_outq *q)\n{\n\tstruct sctp_transport *transport;\n\tstruct list_head *lchunk, *temp;\n\tstruct sctp_chunk *chunk, *tmp;\n\n\t \n\tlist_for_each_entry(transport, &q->asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\twhile ((lchunk = sctp_list_dequeue(&transport->transmitted)) != NULL) {\n\t\t\tchunk = list_entry(lchunk, struct sctp_chunk,\n\t\t\t\t\t   transmitted_list);\n\t\t\t \n\t\t\tsctp_chunk_fail(chunk, q->error);\n\t\t\tsctp_chunk_free(chunk);\n\t\t}\n\t}\n\n\t \n\tlist_for_each_safe(lchunk, temp, &q->sacked) {\n\t\tlist_del_init(lchunk);\n\t\tchunk = list_entry(lchunk, struct sctp_chunk,\n\t\t\t\t   transmitted_list);\n\t\tsctp_chunk_fail(chunk, q->error);\n\t\tsctp_chunk_free(chunk);\n\t}\n\n\t \n\tlist_for_each_safe(lchunk, temp, &q->retransmit) {\n\t\tlist_del_init(lchunk);\n\t\tchunk = list_entry(lchunk, struct sctp_chunk,\n\t\t\t\t   transmitted_list);\n\t\tsctp_chunk_fail(chunk, q->error);\n\t\tsctp_chunk_free(chunk);\n\t}\n\n\t \n\tlist_for_each_safe(lchunk, temp, &q->abandoned) {\n\t\tlist_del_init(lchunk);\n\t\tchunk = list_entry(lchunk, struct sctp_chunk,\n\t\t\t\t   transmitted_list);\n\t\tsctp_chunk_fail(chunk, q->error);\n\t\tsctp_chunk_free(chunk);\n\t}\n\n\t \n\twhile ((chunk = sctp_outq_dequeue_data(q)) != NULL) {\n\t\tsctp_sched_dequeue_done(q, chunk);\n\n\t\t \n\t\tsctp_chunk_fail(chunk, q->error);\n\t\tsctp_chunk_free(chunk);\n\t}\n\n\t \n\tlist_for_each_entry_safe(chunk, tmp, &q->control_chunk_list, list) {\n\t\tlist_del_init(&chunk->list);\n\t\tsctp_chunk_free(chunk);\n\t}\n}\n\nvoid sctp_outq_teardown(struct sctp_outq *q)\n{\n\t__sctp_outq_teardown(q);\n\tsctp_outq_init(q->asoc, q);\n}\n\n \nvoid sctp_outq_free(struct sctp_outq *q)\n{\n\t \n\t__sctp_outq_teardown(q);\n}\n\n \nvoid sctp_outq_tail(struct sctp_outq *q, struct sctp_chunk *chunk, gfp_t gfp)\n{\n\tstruct net *net = q->asoc->base.net;\n\n\tpr_debug(\"%s: outq:%p, chunk:%p[%s]\\n\", __func__, q, chunk,\n\t\t chunk && chunk->chunk_hdr ?\n\t\t sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)) :\n\t\t \"illegal chunk\");\n\n\t \n\tif (sctp_chunk_is_data(chunk)) {\n\t\tpr_debug(\"%s: outqueueing: outq:%p, chunk:%p[%s])\\n\",\n\t\t\t __func__, q, chunk, chunk && chunk->chunk_hdr ?\n\t\t\t sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)) :\n\t\t\t \"illegal chunk\");\n\n\t\tsctp_outq_tail_data(q, chunk);\n\t\tif (chunk->asoc->peer.prsctp_capable &&\n\t\t    SCTP_PR_PRIO_ENABLED(chunk->sinfo.sinfo_flags))\n\t\t\tchunk->asoc->sent_cnt_removable++;\n\t\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED)\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTUNORDERCHUNKS);\n\t\telse\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTORDERCHUNKS);\n\t} else {\n\t\tlist_add_tail(&chunk->list, &q->control_chunk_list);\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t}\n\n\tif (!q->cork)\n\t\tsctp_outq_flush(q, 0, gfp);\n}\n\n \nstatic void sctp_insert_list(struct list_head *head, struct list_head *new)\n{\n\tstruct list_head *pos;\n\tstruct sctp_chunk *nchunk, *lchunk;\n\t__u32 ntsn, ltsn;\n\tint done = 0;\n\n\tnchunk = list_entry(new, struct sctp_chunk, transmitted_list);\n\tntsn = ntohl(nchunk->subh.data_hdr->tsn);\n\n\tlist_for_each(pos, head) {\n\t\tlchunk = list_entry(pos, struct sctp_chunk, transmitted_list);\n\t\tltsn = ntohl(lchunk->subh.data_hdr->tsn);\n\t\tif (TSN_lt(ntsn, ltsn)) {\n\t\t\tlist_add(new, pos->prev);\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!done)\n\t\tlist_add_tail(new, head);\n}\n\nstatic int sctp_prsctp_prune_sent(struct sctp_association *asoc,\n\t\t\t\t  struct sctp_sndrcvinfo *sinfo,\n\t\t\t\t  struct list_head *queue, int msg_len)\n{\n\tstruct sctp_chunk *chk, *temp;\n\n\tlist_for_each_entry_safe(chk, temp, queue, transmitted_list) {\n\t\tstruct sctp_stream_out *streamout;\n\n\t\tif (!chk->msg->abandoned &&\n\t\t    (!SCTP_PR_PRIO_ENABLED(chk->sinfo.sinfo_flags) ||\n\t\t     chk->sinfo.sinfo_timetolive <= sinfo->sinfo_timetolive))\n\t\t\tcontinue;\n\n\t\tchk->msg->abandoned = 1;\n\t\tlist_del_init(&chk->transmitted_list);\n\t\tsctp_insert_list(&asoc->outqueue.abandoned,\n\t\t\t\t &chk->transmitted_list);\n\n\t\tstreamout = SCTP_SO(&asoc->stream, chk->sinfo.sinfo_stream);\n\t\tasoc->sent_cnt_removable--;\n\t\tasoc->abandoned_sent[SCTP_PR_INDEX(PRIO)]++;\n\t\tstreamout->ext->abandoned_sent[SCTP_PR_INDEX(PRIO)]++;\n\n\t\tif (queue != &asoc->outqueue.retransmit &&\n\t\t    !chk->tsn_gap_acked) {\n\t\t\tif (chk->transport)\n\t\t\t\tchk->transport->flight_size -=\n\t\t\t\t\t\tsctp_data_size(chk);\n\t\t\tasoc->outqueue.outstanding_bytes -= sctp_data_size(chk);\n\t\t}\n\n\t\tmsg_len -= chk->skb->truesize + sizeof(struct sctp_chunk);\n\t\tif (msg_len <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn msg_len;\n}\n\nstatic int sctp_prsctp_prune_unsent(struct sctp_association *asoc,\n\t\t\t\t    struct sctp_sndrcvinfo *sinfo, int msg_len)\n{\n\tstruct sctp_outq *q = &asoc->outqueue;\n\tstruct sctp_chunk *chk, *temp;\n\tstruct sctp_stream_out *sout;\n\n\tq->sched->unsched_all(&asoc->stream);\n\n\tlist_for_each_entry_safe(chk, temp, &q->out_chunk_list, list) {\n\t\tif (!chk->msg->abandoned &&\n\t\t    (!(chk->chunk_hdr->flags & SCTP_DATA_FIRST_FRAG) ||\n\t\t     !SCTP_PR_PRIO_ENABLED(chk->sinfo.sinfo_flags) ||\n\t\t     chk->sinfo.sinfo_timetolive <= sinfo->sinfo_timetolive))\n\t\t\tcontinue;\n\n\t\tchk->msg->abandoned = 1;\n\t\tsctp_sched_dequeue_common(q, chk);\n\t\tasoc->sent_cnt_removable--;\n\t\tasoc->abandoned_unsent[SCTP_PR_INDEX(PRIO)]++;\n\n\t\tsout = SCTP_SO(&asoc->stream, chk->sinfo.sinfo_stream);\n\t\tsout->ext->abandoned_unsent[SCTP_PR_INDEX(PRIO)]++;\n\n\t\t \n\t\tif (asoc->stream.out_curr == sout &&\n\t\t    list_is_last(&chk->frag_list, &chk->msg->chunks))\n\t\t\tasoc->stream.out_curr = NULL;\n\n\t\tmsg_len -= chk->skb->truesize + sizeof(struct sctp_chunk);\n\t\tsctp_chunk_free(chk);\n\t\tif (msg_len <= 0)\n\t\t\tbreak;\n\t}\n\n\tq->sched->sched_all(&asoc->stream);\n\n\treturn msg_len;\n}\n\n \nvoid sctp_prsctp_prune(struct sctp_association *asoc,\n\t\t       struct sctp_sndrcvinfo *sinfo, int msg_len)\n{\n\tstruct sctp_transport *transport;\n\n\tif (!asoc->peer.prsctp_capable || !asoc->sent_cnt_removable)\n\t\treturn;\n\n\tmsg_len = sctp_prsctp_prune_sent(asoc, sinfo,\n\t\t\t\t\t &asoc->outqueue.retransmit,\n\t\t\t\t\t msg_len);\n\tif (msg_len <= 0)\n\t\treturn;\n\n\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t    transports) {\n\t\tmsg_len = sctp_prsctp_prune_sent(asoc, sinfo,\n\t\t\t\t\t\t &transport->transmitted,\n\t\t\t\t\t\t msg_len);\n\t\tif (msg_len <= 0)\n\t\t\treturn;\n\t}\n\n\tsctp_prsctp_prune_unsent(asoc, sinfo, msg_len);\n}\n\n \nvoid sctp_retransmit_mark(struct sctp_outq *q,\n\t\t\t  struct sctp_transport *transport,\n\t\t\t  __u8 reason)\n{\n\tstruct list_head *lchunk, *ltemp;\n\tstruct sctp_chunk *chunk;\n\n\t \n\tlist_for_each_safe(lchunk, ltemp, &transport->transmitted) {\n\t\tchunk = list_entry(lchunk, struct sctp_chunk,\n\t\t\t\t   transmitted_list);\n\n\t\t \n\t\tif (sctp_chunk_abandoned(chunk)) {\n\t\t\tlist_del_init(lchunk);\n\t\t\tsctp_insert_list(&q->abandoned, lchunk);\n\n\t\t\t \n\t\t\tif (!chunk->tsn_gap_acked) {\n\t\t\t\tif (chunk->transport)\n\t\t\t\t\tchunk->transport->flight_size -=\n\t\t\t\t\t\t\tsctp_data_size(chunk);\n\t\t\t\tq->outstanding_bytes -= sctp_data_size(chunk);\n\t\t\t\tq->asoc->peer.rwnd += sctp_data_size(chunk);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((reason == SCTP_RTXR_FAST_RTX  &&\n\t\t\t    (chunk->fast_retransmit == SCTP_NEED_FRTX)) ||\n\t\t    (reason != SCTP_RTXR_FAST_RTX  && !chunk->tsn_gap_acked)) {\n\t\t\t \n\t\t\tq->asoc->peer.rwnd += sctp_data_size(chunk);\n\t\t\tq->outstanding_bytes -= sctp_data_size(chunk);\n\t\t\tif (chunk->transport)\n\t\t\t\ttransport->flight_size -= sctp_data_size(chunk);\n\n\t\t\t \n\t\t\tchunk->tsn_missing_report = 0;\n\n\t\t\t \n\t\t\tif (chunk->rtt_in_progress) {\n\t\t\t\tchunk->rtt_in_progress = 0;\n\t\t\t\ttransport->rto_pending = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tlist_del_init(lchunk);\n\t\t\tsctp_insert_list(&q->retransmit, lchunk);\n\t\t}\n\t}\n\n\tpr_debug(\"%s: transport:%p, reason:%d, cwnd:%d, ssthresh:%d, \"\n\t\t \"flight_size:%d, pba:%d\\n\", __func__, transport, reason,\n\t\t transport->cwnd, transport->ssthresh, transport->flight_size,\n\t\t transport->partial_bytes_acked);\n}\n\n \nvoid sctp_retransmit(struct sctp_outq *q, struct sctp_transport *transport,\n\t\t     enum sctp_retransmit_reason reason)\n{\n\tstruct net *net = q->asoc->base.net;\n\n\tswitch (reason) {\n\tcase SCTP_RTXR_T3_RTX:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_T3_RETRANSMITS);\n\t\tsctp_transport_lower_cwnd(transport, SCTP_LOWER_CWND_T3_RTX);\n\t\t \n\t\tif (transport == transport->asoc->peer.retran_path)\n\t\t\tsctp_assoc_update_retran_path(transport->asoc);\n\t\ttransport->asoc->rtx_data_chunks +=\n\t\t\ttransport->asoc->unack_data;\n\t\tif (transport->pl.state == SCTP_PL_COMPLETE &&\n\t\t    transport->asoc->unack_data)\n\t\t\tsctp_transport_reset_probe_timer(transport);\n\t\tbreak;\n\tcase SCTP_RTXR_FAST_RTX:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_FAST_RETRANSMITS);\n\t\tsctp_transport_lower_cwnd(transport, SCTP_LOWER_CWND_FAST_RTX);\n\t\tq->fast_rtx = 1;\n\t\tbreak;\n\tcase SCTP_RTXR_PMTUD:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_PMTUD_RETRANSMITS);\n\t\tbreak;\n\tcase SCTP_RTXR_T1_RTX:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_T1_RETRANSMITS);\n\t\ttransport->asoc->init_retries++;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsctp_retransmit_mark(q, transport, reason);\n\n\t \n\tif (reason == SCTP_RTXR_T3_RTX)\n\t\tq->asoc->stream.si->generate_ftsn(q, q->asoc->ctsn_ack_point);\n\n\t \n\tif (reason != SCTP_RTXR_FAST_RTX)\n\t\tsctp_outq_flush(q,   1, GFP_ATOMIC);\n}\n\n \nstatic int __sctp_outq_flush_rtx(struct sctp_outq *q, struct sctp_packet *pkt,\n\t\t\t\t int rtx_timeout, int *start_timer, gfp_t gfp)\n{\n\tstruct sctp_transport *transport = pkt->transport;\n\tstruct sctp_chunk *chunk, *chunk1;\n\tstruct list_head *lqueue;\n\tenum sctp_xmit status;\n\tint error = 0;\n\tint timer = 0;\n\tint done = 0;\n\tint fast_rtx;\n\n\tlqueue = &q->retransmit;\n\tfast_rtx = q->fast_rtx;\n\n\t \n\tlist_for_each_entry_safe(chunk, chunk1, lqueue, transmitted_list) {\n\t\t \n\t\tif (sctp_chunk_abandoned(chunk)) {\n\t\t\tlist_del_init(&chunk->transmitted_list);\n\t\t\tsctp_insert_list(&q->abandoned,\n\t\t\t\t\t &chunk->transmitted_list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (chunk->tsn_gap_acked) {\n\t\t\tlist_move_tail(&chunk->transmitted_list,\n\t\t\t\t       &transport->transmitted);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (fast_rtx && !chunk->fast_retransmit)\n\t\t\tcontinue;\n\nredo:\n\t\t \n\t\tstatus = sctp_packet_append_chunk(pkt, chunk);\n\n\t\tswitch (status) {\n\t\tcase SCTP_XMIT_PMTU_FULL:\n\t\t\tif (!pkt->has_data && !pkt->has_cookie_echo) {\n\t\t\t\t \n\t\t\t\tsctp_packet_transmit(pkt, gfp);\n\t\t\t\tgoto redo;\n\t\t\t}\n\n\t\t\t \n\t\t\terror = sctp_packet_transmit(pkt, gfp);\n\n\t\t\t \n\t\t\tif (rtx_timeout || fast_rtx)\n\t\t\t\tdone = 1;\n\t\t\telse\n\t\t\t\tgoto redo;\n\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase SCTP_XMIT_RWND_FULL:\n\t\t\t \n\t\t\terror = sctp_packet_transmit(pkt, gfp);\n\n\t\t\t \n\t\t\tdone = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_XMIT_DELAY:\n\t\t\t \n\t\t\terror = sctp_packet_transmit(pkt, gfp);\n\n\t\t\t \n\t\t\tdone = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tlist_move_tail(&chunk->transmitted_list,\n\t\t\t\t       &transport->transmitted);\n\n\t\t\t \n\t\t\tif (chunk->fast_retransmit == SCTP_NEED_FRTX)\n\t\t\t\tchunk->fast_retransmit = SCTP_DONT_FRTX;\n\n\t\t\tq->asoc->stats.rtxchunks++;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!error && !timer)\n\t\t\ttimer = 1;\n\n\t\tif (done)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (rtx_timeout || fast_rtx) {\n\t\tlist_for_each_entry(chunk1, lqueue, transmitted_list) {\n\t\t\tif (chunk1->fast_retransmit == SCTP_NEED_FRTX)\n\t\t\t\tchunk1->fast_retransmit = SCTP_DONT_FRTX;\n\t\t}\n\t}\n\n\t*start_timer = timer;\n\n\t \n\tif (fast_rtx)\n\t\tq->fast_rtx = 0;\n\n\treturn error;\n}\n\n \nvoid sctp_outq_uncork(struct sctp_outq *q, gfp_t gfp)\n{\n\tif (q->cork)\n\t\tq->cork = 0;\n\n\tsctp_outq_flush(q, 0, gfp);\n}\n\nstatic int sctp_packet_singleton(struct sctp_transport *transport,\n\t\t\t\t struct sctp_chunk *chunk, gfp_t gfp)\n{\n\tconst struct sctp_association *asoc = transport->asoc;\n\tconst __u16 sport = asoc->base.bind_addr.port;\n\tconst __u16 dport = asoc->peer.port;\n\tconst __u32 vtag = asoc->peer.i.init_tag;\n\tstruct sctp_packet singleton;\n\n\tsctp_packet_init(&singleton, transport, sport, dport);\n\tsctp_packet_config(&singleton, vtag, 0);\n\tif (sctp_packet_append_chunk(&singleton, chunk) != SCTP_XMIT_OK) {\n\t\tlist_del_init(&chunk->list);\n\t\tsctp_chunk_free(chunk);\n\t\treturn -ENOMEM;\n\t}\n\treturn sctp_packet_transmit(&singleton, gfp);\n}\n\n \nstruct sctp_flush_ctx {\n\tstruct sctp_outq *q;\n\t \n\tstruct sctp_transport *transport;\n\t \n\tstruct list_head transport_list;\n\tstruct sctp_association *asoc;\n\t \n\tstruct sctp_packet *packet;\n\tgfp_t gfp;\n};\n\n \nstatic void sctp_outq_select_transport(struct sctp_flush_ctx *ctx,\n\t\t\t\t       struct sctp_chunk *chunk)\n{\n\tstruct sctp_transport *new_transport = chunk->transport;\n\n\tif (!new_transport) {\n\t\tif (!sctp_chunk_is_data(chunk)) {\n\t\t\t \n\t\t\tif (ctx->transport && sctp_cmp_addr_exact(&chunk->dest,\n\t\t\t\t\t\t\t&ctx->transport->ipaddr))\n\t\t\t\tnew_transport = ctx->transport;\n\t\t\telse\n\t\t\t\tnew_transport = sctp_assoc_lookup_paddr(ctx->asoc,\n\t\t\t\t\t\t\t\t  &chunk->dest);\n\t\t}\n\n\t\t \n\t\tif (!new_transport)\n\t\t\tnew_transport = ctx->asoc->peer.active_path;\n\t} else {\n\t\t__u8 type;\n\n\t\tswitch (new_transport->state) {\n\t\tcase SCTP_INACTIVE:\n\t\tcase SCTP_UNCONFIRMED:\n\t\tcase SCTP_PF:\n\t\t\t \n\t\t\ttype = chunk->chunk_hdr->type;\n\t\t\tif (type != SCTP_CID_HEARTBEAT &&\n\t\t\t    type != SCTP_CID_HEARTBEAT_ACK &&\n\t\t\t    type != SCTP_CID_ASCONF_ACK)\n\t\t\t\tnew_transport = ctx->asoc->peer.active_path;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (new_transport != ctx->transport) {\n\t\tctx->transport = new_transport;\n\t\tctx->packet = &ctx->transport->packet;\n\n\t\tif (list_empty(&ctx->transport->send_ready))\n\t\t\tlist_add_tail(&ctx->transport->send_ready,\n\t\t\t\t      &ctx->transport_list);\n\n\t\tsctp_packet_config(ctx->packet,\n\t\t\t\t   ctx->asoc->peer.i.init_tag,\n\t\t\t\t   ctx->asoc->peer.ecn_capable);\n\t\t \n\t\tsctp_transport_burst_limited(ctx->transport);\n\t}\n}\n\nstatic void sctp_outq_flush_ctrl(struct sctp_flush_ctx *ctx)\n{\n\tstruct sctp_chunk *chunk, *tmp;\n\tenum sctp_xmit status;\n\tint one_packet, error;\n\n\tlist_for_each_entry_safe(chunk, tmp, &ctx->q->control_chunk_list, list) {\n\t\tone_packet = 0;\n\n\t\t \n\t\tif (ctx->asoc->src_out_of_asoc_ok &&\n\t\t    chunk->chunk_hdr->type != SCTP_CID_ASCONF)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&chunk->list);\n\n\t\t \n\t\tsctp_outq_select_transport(ctx, chunk);\n\n\t\tswitch (chunk->chunk_hdr->type) {\n\t\t \n\t\tcase SCTP_CID_INIT:\n\t\tcase SCTP_CID_INIT_ACK:\n\t\tcase SCTP_CID_SHUTDOWN_COMPLETE:\n\t\t\terror = sctp_packet_singleton(ctx->transport, chunk,\n\t\t\t\t\t\t      ctx->gfp);\n\t\t\tif (error < 0) {\n\t\t\t\tctx->asoc->base.sk->sk_err = -error;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tctx->asoc->stats.octrlchunks++;\n\t\t\tbreak;\n\n\t\tcase SCTP_CID_ABORT:\n\t\t\tif (sctp_test_T_bit(chunk))\n\t\t\t\tctx->packet->vtag = ctx->asoc->c.my_vtag;\n\t\t\tfallthrough;\n\n\t\t \n\t\tcase SCTP_CID_HEARTBEAT_ACK:\n\t\tcase SCTP_CID_SHUTDOWN_ACK:\n\t\tcase SCTP_CID_COOKIE_ACK:\n\t\tcase SCTP_CID_COOKIE_ECHO:\n\t\tcase SCTP_CID_ERROR:\n\t\tcase SCTP_CID_ECN_CWR:\n\t\tcase SCTP_CID_ASCONF_ACK:\n\t\t\tone_packet = 1;\n\t\t\tfallthrough;\n\n\t\tcase SCTP_CID_HEARTBEAT:\n\t\t\tif (chunk->pmtu_probe) {\n\t\t\t\terror = sctp_packet_singleton(ctx->transport,\n\t\t\t\t\t\t\t      chunk, ctx->gfp);\n\t\t\t\tif (!error)\n\t\t\t\t\tctx->asoc->stats.octrlchunks++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase SCTP_CID_SACK:\n\t\tcase SCTP_CID_SHUTDOWN:\n\t\tcase SCTP_CID_ECN_ECNE:\n\t\tcase SCTP_CID_ASCONF:\n\t\tcase SCTP_CID_FWD_TSN:\n\t\tcase SCTP_CID_I_FWD_TSN:\n\t\tcase SCTP_CID_RECONF:\n\t\t\tstatus = sctp_packet_transmit_chunk(ctx->packet, chunk,\n\t\t\t\t\t\t\t    one_packet, ctx->gfp);\n\t\t\tif (status != SCTP_XMIT_OK) {\n\t\t\t\t \n\t\t\t\tlist_add(&chunk->list, &ctx->q->control_chunk_list);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tctx->asoc->stats.octrlchunks++;\n\t\t\t \n\t\t\tif (chunk->chunk_hdr->type == SCTP_CID_FWD_TSN ||\n\t\t\t    chunk->chunk_hdr->type == SCTP_CID_I_FWD_TSN) {\n\t\t\t\tsctp_transport_reset_t3_rtx(ctx->transport);\n\t\t\t\tctx->transport->last_time_sent = jiffies;\n\t\t\t}\n\n\t\t\tif (chunk == ctx->asoc->strreset_chunk)\n\t\t\t\tsctp_transport_reset_reconf_timer(ctx->transport);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tBUG();\n\t\t}\n\t}\n}\n\n \nstatic bool sctp_outq_flush_rtx(struct sctp_flush_ctx *ctx,\n\t\t\t\tint rtx_timeout)\n{\n\tint error, start_timer = 0;\n\n\tif (ctx->asoc->peer.retran_path->state == SCTP_UNCONFIRMED)\n\t\treturn false;\n\n\tif (ctx->transport != ctx->asoc->peer.retran_path) {\n\t\t \n\t\tctx->transport = ctx->asoc->peer.retran_path;\n\t\tctx->packet = &ctx->transport->packet;\n\n\t\tif (list_empty(&ctx->transport->send_ready))\n\t\t\tlist_add_tail(&ctx->transport->send_ready,\n\t\t\t\t      &ctx->transport_list);\n\n\t\tsctp_packet_config(ctx->packet, ctx->asoc->peer.i.init_tag,\n\t\t\t\t   ctx->asoc->peer.ecn_capable);\n\t}\n\n\terror = __sctp_outq_flush_rtx(ctx->q, ctx->packet, rtx_timeout,\n\t\t\t\t      &start_timer, ctx->gfp);\n\tif (error < 0)\n\t\tctx->asoc->base.sk->sk_err = -error;\n\n\tif (start_timer) {\n\t\tsctp_transport_reset_t3_rtx(ctx->transport);\n\t\tctx->transport->last_time_sent = jiffies;\n\t}\n\n\t \n\tif (ctx->packet->has_cookie_echo)\n\t\treturn false;\n\n\t \n\tif (!list_empty(&ctx->q->retransmit))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void sctp_outq_flush_data(struct sctp_flush_ctx *ctx,\n\t\t\t\t int rtx_timeout)\n{\n\tstruct sctp_chunk *chunk;\n\tenum sctp_xmit status;\n\n\t \n\tswitch (ctx->asoc->state) {\n\tcase SCTP_STATE_COOKIE_ECHOED:\n\t\t \n\t\tif (!ctx->packet || !ctx->packet->has_cookie_echo)\n\t\t\treturn;\n\n\t\tfallthrough;\n\tcase SCTP_STATE_ESTABLISHED:\n\tcase SCTP_STATE_SHUTDOWN_PENDING:\n\tcase SCTP_STATE_SHUTDOWN_RECEIVED:\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (!list_empty(&ctx->q->retransmit) &&\n\t    !sctp_outq_flush_rtx(ctx, rtx_timeout))\n\t\treturn;\n\n\t \n\tif (ctx->transport)\n\t\tsctp_transport_burst_limited(ctx->transport);\n\n\t \n\twhile ((chunk = sctp_outq_dequeue_data(ctx->q)) != NULL) {\n\t\t__u32 sid = ntohs(chunk->subh.data_hdr->stream);\n\t\t__u8 stream_state = SCTP_SO(&ctx->asoc->stream, sid)->state;\n\n\t\t \n\t\tif (sctp_chunk_abandoned(chunk)) {\n\t\t\tsctp_sched_dequeue_done(ctx->q, chunk);\n\t\t\tsctp_chunk_fail(chunk, 0);\n\t\t\tsctp_chunk_free(chunk);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stream_state == SCTP_STREAM_CLOSED) {\n\t\t\tsctp_outq_head_data(ctx->q, chunk);\n\t\t\tbreak;\n\t\t}\n\n\t\tsctp_outq_select_transport(ctx, chunk);\n\n\t\tpr_debug(\"%s: outq:%p, chunk:%p[%s], tx-tsn:0x%x skb->head:%p skb->users:%d\\n\",\n\t\t\t __func__, ctx->q, chunk, chunk && chunk->chunk_hdr ?\n\t\t\t sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)) :\n\t\t\t \"illegal chunk\", ntohl(chunk->subh.data_hdr->tsn),\n\t\t\t chunk->skb ? chunk->skb->head : NULL, chunk->skb ?\n\t\t\t refcount_read(&chunk->skb->users) : -1);\n\n\t\t \n\t\tstatus = sctp_packet_transmit_chunk(ctx->packet, chunk, 0,\n\t\t\t\t\t\t    ctx->gfp);\n\t\tif (status != SCTP_XMIT_OK) {\n\t\t\t \n\t\t\tpr_debug(\"%s: could not transmit tsn:0x%x, status:%d\\n\",\n\t\t\t\t __func__, ntohl(chunk->subh.data_hdr->tsn),\n\t\t\t\t status);\n\n\t\t\tsctp_outq_head_data(ctx->q, chunk);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ctx->asoc->state == SCTP_STATE_SHUTDOWN_PENDING)\n\t\t\tchunk->chunk_hdr->flags |= SCTP_DATA_SACK_IMM;\n\t\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED)\n\t\t\tctx->asoc->stats.ouodchunks++;\n\t\telse\n\t\t\tctx->asoc->stats.oodchunks++;\n\n\t\t \n\t\tsctp_sched_dequeue_done(ctx->q, chunk);\n\n\t\tlist_add_tail(&chunk->transmitted_list,\n\t\t\t      &ctx->transport->transmitted);\n\n\t\tsctp_transport_reset_t3_rtx(ctx->transport);\n\t\tctx->transport->last_time_sent = jiffies;\n\n\t\t \n\t\tif (ctx->packet->has_cookie_echo)\n\t\t\tbreak;\n\t}\n}\n\nstatic void sctp_outq_flush_transports(struct sctp_flush_ctx *ctx)\n{\n\tstruct sock *sk = ctx->asoc->base.sk;\n\tstruct list_head *ltransport;\n\tstruct sctp_packet *packet;\n\tstruct sctp_transport *t;\n\tint error = 0;\n\n\twhile ((ltransport = sctp_list_dequeue(&ctx->transport_list)) != NULL) {\n\t\tt = list_entry(ltransport, struct sctp_transport, send_ready);\n\t\tpacket = &t->packet;\n\t\tif (!sctp_packet_empty(packet)) {\n\t\t\trcu_read_lock();\n\t\t\tif (t->dst && __sk_dst_get(sk) != t->dst) {\n\t\t\t\tdst_hold(t->dst);\n\t\t\t\tsk_setup_caps(sk, t->dst);\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\terror = sctp_packet_transmit(packet, ctx->gfp);\n\t\t\tif (error < 0)\n\t\t\t\tctx->q->asoc->base.sk->sk_err = -error;\n\t\t}\n\n\t\t \n\t\tsctp_transport_burst_reset(t);\n\t}\n}\n\n \n\nstatic void sctp_outq_flush(struct sctp_outq *q, int rtx_timeout, gfp_t gfp)\n{\n\tstruct sctp_flush_ctx ctx = {\n\t\t.q = q,\n\t\t.transport = NULL,\n\t\t.transport_list = LIST_HEAD_INIT(ctx.transport_list),\n\t\t.asoc = q->asoc,\n\t\t.packet = NULL,\n\t\t.gfp = gfp,\n\t};\n\n\t \n\n\tsctp_outq_flush_ctrl(&ctx);\n\n\tif (q->asoc->src_out_of_asoc_ok)\n\t\tgoto sctp_flush_out;\n\n\tsctp_outq_flush_data(&ctx, rtx_timeout);\n\nsctp_flush_out:\n\n\tsctp_outq_flush_transports(&ctx);\n}\n\n \nstatic void sctp_sack_update_unack_data(struct sctp_association *assoc,\n\t\t\t\t\tstruct sctp_sackhdr *sack)\n{\n\tunion sctp_sack_variable *frags;\n\t__u16 unack_data;\n\tint i;\n\n\tunack_data = assoc->next_tsn - assoc->ctsn_ack_point - 1;\n\n\tfrags = (union sctp_sack_variable *)(sack + 1);\n\tfor (i = 0; i < ntohs(sack->num_gap_ack_blocks); i++) {\n\t\tunack_data -= ((ntohs(frags[i].gab.end) -\n\t\t\t\tntohs(frags[i].gab.start) + 1));\n\t}\n\n\tassoc->unack_data = unack_data;\n}\n\n \nint sctp_outq_sack(struct sctp_outq *q, struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = q->asoc;\n\tstruct sctp_sackhdr *sack = chunk->subh.sack_hdr;\n\tstruct sctp_transport *transport;\n\tstruct sctp_chunk *tchunk = NULL;\n\tstruct list_head *lchunk, *transport_list, *temp;\n\t__u32 sack_ctsn, ctsn, tsn;\n\t__u32 highest_tsn, highest_new_tsn;\n\t__u32 sack_a_rwnd;\n\tunsigned int outstanding;\n\tstruct sctp_transport *primary = asoc->peer.primary_path;\n\tint count_of_newacks = 0;\n\tint gap_ack_blocks;\n\tu8 accum_moved = 0;\n\n\t \n\ttransport_list = &asoc->peer.transport_addr_list;\n\n\t \n\tif (trace_sctp_probe_path_enabled()) {\n\t\tlist_for_each_entry(transport, transport_list, transports)\n\t\t\ttrace_sctp_probe_path(transport, asoc);\n\t}\n\n\tsack_ctsn = ntohl(sack->cum_tsn_ack);\n\tgap_ack_blocks = ntohs(sack->num_gap_ack_blocks);\n\tasoc->stats.gapcnt += gap_ack_blocks;\n\t \n\tif (primary->cacc.changeover_active) {\n\t\tu8 clear_cycling = 0;\n\n\t\tif (TSN_lte(primary->cacc.next_tsn_at_change, sack_ctsn)) {\n\t\t\tprimary->cacc.changeover_active = 0;\n\t\t\tclear_cycling = 1;\n\t\t}\n\n\t\tif (clear_cycling || gap_ack_blocks) {\n\t\t\tlist_for_each_entry(transport, transport_list,\n\t\t\t\t\ttransports) {\n\t\t\t\tif (clear_cycling)\n\t\t\t\t\ttransport->cacc.cycling_changeover = 0;\n\t\t\t\tif (gap_ack_blocks)\n\t\t\t\t\ttransport->cacc.cacc_saw_newack = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\thighest_tsn = sack_ctsn;\n\tif (gap_ack_blocks) {\n\t\tunion sctp_sack_variable *frags =\n\t\t\t(union sctp_sack_variable *)(sack + 1);\n\n\t\thighest_tsn += ntohs(frags[gap_ack_blocks - 1].gab.end);\n\t}\n\n\tif (TSN_lt(asoc->highest_sacked, highest_tsn))\n\t\tasoc->highest_sacked = highest_tsn;\n\n\thighest_new_tsn = sack_ctsn;\n\n\t \n\tsctp_check_transmitted(q, &q->retransmit, NULL, NULL, sack, &highest_new_tsn);\n\n\t \n\tlist_for_each_entry(transport, transport_list, transports) {\n\t\tsctp_check_transmitted(q, &transport->transmitted,\n\t\t\t\t       transport, &chunk->source, sack,\n\t\t\t\t       &highest_new_tsn);\n\t\t \n\t\tif (transport->cacc.cacc_saw_newack)\n\t\t\tcount_of_newacks++;\n\t}\n\n\t \n\tif (TSN_lt(asoc->ctsn_ack_point, sack_ctsn)) {\n\t\tasoc->ctsn_ack_point = sack_ctsn;\n\t\taccum_moved = 1;\n\t}\n\n\tif (gap_ack_blocks) {\n\n\t\tif (asoc->fast_recovery && accum_moved)\n\t\t\thighest_new_tsn = highest_tsn;\n\n\t\tlist_for_each_entry(transport, transport_list, transports)\n\t\t\tsctp_mark_missing(q, &transport->transmitted, transport,\n\t\t\t\t\t  highest_new_tsn, count_of_newacks);\n\t}\n\n\t \n\tsctp_sack_update_unack_data(asoc, sack);\n\n\tctsn = asoc->ctsn_ack_point;\n\n\t \n\tlist_for_each_safe(lchunk, temp, &q->sacked) {\n\t\ttchunk = list_entry(lchunk, struct sctp_chunk,\n\t\t\t\t    transmitted_list);\n\t\ttsn = ntohl(tchunk->subh.data_hdr->tsn);\n\t\tif (TSN_lte(tsn, ctsn)) {\n\t\t\tlist_del_init(&tchunk->transmitted_list);\n\t\t\tif (asoc->peer.prsctp_capable &&\n\t\t\t    SCTP_PR_PRIO_ENABLED(chunk->sinfo.sinfo_flags))\n\t\t\t\tasoc->sent_cnt_removable--;\n\t\t\tsctp_chunk_free(tchunk);\n\t\t}\n\t}\n\n\t \n\n\tsack_a_rwnd = ntohl(sack->a_rwnd);\n\tasoc->peer.zero_window_announced = !sack_a_rwnd;\n\toutstanding = q->outstanding_bytes;\n\n\tif (outstanding < sack_a_rwnd)\n\t\tsack_a_rwnd -= outstanding;\n\telse\n\t\tsack_a_rwnd = 0;\n\n\tasoc->peer.rwnd = sack_a_rwnd;\n\n\tasoc->stream.si->generate_ftsn(q, sack_ctsn);\n\n\tpr_debug(\"%s: sack cumulative tsn ack:0x%x\\n\", __func__, sack_ctsn);\n\tpr_debug(\"%s: cumulative tsn ack of assoc:%p is 0x%x, \"\n\t\t \"advertised peer ack point:0x%x\\n\", __func__, asoc, ctsn,\n\t\t asoc->adv_peer_ack_point);\n\n\treturn sctp_outq_is_empty(q);\n}\n\n \nint sctp_outq_is_empty(const struct sctp_outq *q)\n{\n\treturn q->out_qlen == 0 && q->outstanding_bytes == 0 &&\n\t       list_empty(&q->retransmit);\n}\n\n \n\n \nstatic void sctp_check_transmitted(struct sctp_outq *q,\n\t\t\t\t   struct list_head *transmitted_queue,\n\t\t\t\t   struct sctp_transport *transport,\n\t\t\t\t   union sctp_addr *saddr,\n\t\t\t\t   struct sctp_sackhdr *sack,\n\t\t\t\t   __u32 *highest_new_tsn_in_sack)\n{\n\tstruct list_head *lchunk;\n\tstruct sctp_chunk *tchunk;\n\tstruct list_head tlist;\n\t__u32 tsn;\n\t__u32 sack_ctsn;\n\t__u32 rtt;\n\t__u8 restart_timer = 0;\n\tint bytes_acked = 0;\n\tint migrate_bytes = 0;\n\tbool forward_progress = false;\n\n\tsack_ctsn = ntohl(sack->cum_tsn_ack);\n\n\tINIT_LIST_HEAD(&tlist);\n\n\t \n\twhile (NULL != (lchunk = sctp_list_dequeue(transmitted_queue))) {\n\t\ttchunk = list_entry(lchunk, struct sctp_chunk,\n\t\t\t\t    transmitted_list);\n\n\t\tif (sctp_chunk_abandoned(tchunk)) {\n\t\t\t \n\t\t\tsctp_insert_list(&q->abandoned, lchunk);\n\n\t\t\t \n\t\t\tif (transmitted_queue != &q->retransmit &&\n\t\t\t    !tchunk->tsn_gap_acked) {\n\t\t\t\tif (tchunk->transport)\n\t\t\t\t\ttchunk->transport->flight_size -=\n\t\t\t\t\t\t\tsctp_data_size(tchunk);\n\t\t\t\tq->outstanding_bytes -= sctp_data_size(tchunk);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\ttsn = ntohl(tchunk->subh.data_hdr->tsn);\n\t\tif (sctp_acked(sack, tsn)) {\n\t\t\t \n\t\t\tif (transport && !tchunk->tsn_gap_acked) {\n\t\t\t\t \n\t\t\t\tif (!sctp_chunk_retransmitted(tchunk) &&\n\t\t\t\t    tchunk->rtt_in_progress) {\n\t\t\t\t\ttchunk->rtt_in_progress = 0;\n\t\t\t\t\trtt = jiffies - tchunk->sent_at;\n\t\t\t\t\tsctp_transport_update_rto(transport,\n\t\t\t\t\t\t\t\t  rtt);\n\t\t\t\t}\n\n\t\t\t\tif (TSN_lte(tsn, sack_ctsn)) {\n\t\t\t\t\t \n\t\t\t\t\tif (sack->num_gap_ack_blocks &&\n\t\t\t\t\t    q->asoc->peer.primary_path->cacc.\n\t\t\t\t\t    changeover_active)\n\t\t\t\t\t\ttransport->cacc.cacc_saw_newack\n\t\t\t\t\t\t\t= 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!tchunk->tsn_gap_acked) {\n\t\t\t\ttchunk->tsn_gap_acked = 1;\n\t\t\t\tif (TSN_lt(*highest_new_tsn_in_sack, tsn))\n\t\t\t\t\t*highest_new_tsn_in_sack = tsn;\n\t\t\t\tbytes_acked += sctp_data_size(tchunk);\n\t\t\t\tif (!tchunk->transport)\n\t\t\t\t\tmigrate_bytes += sctp_data_size(tchunk);\n\t\t\t\tforward_progress = true;\n\t\t\t}\n\n\t\t\tif (TSN_lte(tsn, sack_ctsn)) {\n\t\t\t\t \n\t\t\t\trestart_timer = 1;\n\t\t\t\tforward_progress = true;\n\n\t\t\t\tlist_add_tail(&tchunk->transmitted_list,\n\t\t\t\t\t      &q->sacked);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tlist_add_tail(lchunk, &tlist);\n\t\t\t}\n\t\t} else {\n\t\t\tif (tchunk->tsn_gap_acked) {\n\t\t\t\tpr_debug(\"%s: receiver reneged on data TSN:0x%x\\n\",\n\t\t\t\t\t __func__, tsn);\n\n\t\t\t\ttchunk->tsn_gap_acked = 0;\n\n\t\t\t\tif (tchunk->transport)\n\t\t\t\t\tbytes_acked -= sctp_data_size(tchunk);\n\n\t\t\t\t \n\t\t\t\trestart_timer = 1;\n\t\t\t}\n\n\t\t\tlist_add_tail(lchunk, &tlist);\n\t\t}\n\t}\n\n\tif (transport) {\n\t\tif (bytes_acked) {\n\t\t\tstruct sctp_association *asoc = transport->asoc;\n\n\t\t\t \n\t\t\tbytes_acked -= migrate_bytes;\n\n\t\t\t \n\t\t\ttransport->error_count = 0;\n\t\t\ttransport->asoc->overall_error_count = 0;\n\t\t\tforward_progress = true;\n\n\t\t\t \n\t\t\tif (asoc->state == SCTP_STATE_SHUTDOWN_PENDING &&\n\t\t\t    del_timer(&asoc->timers\n\t\t\t\t[SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD]))\n\t\t\t\t\tsctp_association_put(asoc);\n\n\t\t\t \n\t\t\tif ((transport->state == SCTP_INACTIVE ||\n\t\t\t     transport->state == SCTP_UNCONFIRMED) &&\n\t\t\t    sctp_cmp_addr_exact(&transport->ipaddr, saddr)) {\n\t\t\t\tsctp_assoc_control_transport(\n\t\t\t\t\ttransport->asoc,\n\t\t\t\t\ttransport,\n\t\t\t\t\tSCTP_TRANSPORT_UP,\n\t\t\t\t\tSCTP_RECEIVED_SACK);\n\t\t\t}\n\n\t\t\tsctp_transport_raise_cwnd(transport, sack_ctsn,\n\t\t\t\t\t\t  bytes_acked);\n\n\t\t\ttransport->flight_size -= bytes_acked;\n\t\t\tif (transport->flight_size == 0)\n\t\t\t\ttransport->partial_bytes_acked = 0;\n\t\t\tq->outstanding_bytes -= bytes_acked + migrate_bytes;\n\t\t} else {\n\t\t\t \n\t\t\tif (!q->asoc->peer.rwnd &&\n\t\t\t    !list_empty(&tlist) &&\n\t\t\t    (sack_ctsn+2 == q->asoc->next_tsn) &&\n\t\t\t    q->asoc->state < SCTP_STATE_SHUTDOWN_PENDING) {\n\t\t\t\tpr_debug(\"%s: sack received for zero window \"\n\t\t\t\t\t \"probe:%u\\n\", __func__, sack_ctsn);\n\n\t\t\t\tq->asoc->overall_error_count = 0;\n\t\t\t\ttransport->error_count = 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!transport->flight_size) {\n\t\t\tif (del_timer(&transport->T3_rtx_timer))\n\t\t\t\tsctp_transport_put(transport);\n\t\t} else if (restart_timer) {\n\t\t\tif (!mod_timer(&transport->T3_rtx_timer,\n\t\t\t\t       jiffies + transport->rto))\n\t\t\t\tsctp_transport_hold(transport);\n\t\t}\n\n\t\tif (forward_progress) {\n\t\t\tif (transport->dst)\n\t\t\t\tsctp_transport_dst_confirm(transport);\n\t\t}\n\t}\n\n\tlist_splice(&tlist, transmitted_queue);\n}\n\n \nstatic void sctp_mark_missing(struct sctp_outq *q,\n\t\t\t      struct list_head *transmitted_queue,\n\t\t\t      struct sctp_transport *transport,\n\t\t\t      __u32 highest_new_tsn_in_sack,\n\t\t\t      int count_of_newacks)\n{\n\tstruct sctp_chunk *chunk;\n\t__u32 tsn;\n\tchar do_fast_retransmit = 0;\n\tstruct sctp_association *asoc = q->asoc;\n\tstruct sctp_transport *primary = asoc->peer.primary_path;\n\n\tlist_for_each_entry(chunk, transmitted_queue, transmitted_list) {\n\n\t\ttsn = ntohl(chunk->subh.data_hdr->tsn);\n\n\t\t \n\t\tif (chunk->fast_retransmit == SCTP_CAN_FRTX &&\n\t\t    !chunk->tsn_gap_acked &&\n\t\t    TSN_lt(tsn, highest_new_tsn_in_sack)) {\n\n\t\t\t \n\t\t\tif (!transport || !sctp_cacc_skip(primary,\n\t\t\t\t\t\tchunk->transport,\n\t\t\t\t\t\tcount_of_newacks, tsn)) {\n\t\t\t\tchunk->tsn_missing_report++;\n\n\t\t\t\tpr_debug(\"%s: tsn:0x%x missing counter:%d\\n\",\n\t\t\t\t\t __func__, tsn, chunk->tsn_missing_report);\n\t\t\t}\n\t\t}\n\t\t \n\n\t\tif (chunk->tsn_missing_report >= 3) {\n\t\t\tchunk->fast_retransmit = SCTP_NEED_FRTX;\n\t\t\tdo_fast_retransmit = 1;\n\t\t}\n\t}\n\n\tif (transport) {\n\t\tif (do_fast_retransmit)\n\t\t\tsctp_retransmit(q, transport, SCTP_RTXR_FAST_RTX);\n\n\t\tpr_debug(\"%s: transport:%p, cwnd:%d, ssthresh:%d, \"\n\t\t\t \"flight_size:%d, pba:%d\\n\",  __func__, transport,\n\t\t\t transport->cwnd, transport->ssthresh,\n\t\t\t transport->flight_size, transport->partial_bytes_acked);\n\t}\n}\n\n \nstatic int sctp_acked(struct sctp_sackhdr *sack, __u32 tsn)\n{\n\t__u32 ctsn = ntohl(sack->cum_tsn_ack);\n\tunion sctp_sack_variable *frags;\n\t__u16 tsn_offset, blocks;\n\tint i;\n\n\tif (TSN_lte(tsn, ctsn))\n\t\tgoto pass;\n\n\t \n\n\tfrags = (union sctp_sack_variable *)(sack + 1);\n\tblocks = ntohs(sack->num_gap_ack_blocks);\n\ttsn_offset = tsn - ctsn;\n\tfor (i = 0; i < blocks; ++i) {\n\t\tif (tsn_offset >= ntohs(frags[i].gab.start) &&\n\t\t    tsn_offset <= ntohs(frags[i].gab.end))\n\t\t\tgoto pass;\n\t}\n\n\treturn 0;\npass:\n\treturn 1;\n}\n\nstatic inline int sctp_get_skip_pos(struct sctp_fwdtsn_skip *skiplist,\n\t\t\t\t    int nskips, __be16 stream)\n{\n\tint i;\n\n\tfor (i = 0; i < nskips; i++) {\n\t\tif (skiplist[i].stream == stream)\n\t\t\treturn i;\n\t}\n\treturn i;\n}\n\n \nvoid sctp_generate_fwdtsn(struct sctp_outq *q, __u32 ctsn)\n{\n\tstruct sctp_association *asoc = q->asoc;\n\tstruct sctp_chunk *ftsn_chunk = NULL;\n\tstruct sctp_fwdtsn_skip ftsn_skip_arr[10];\n\tint nskips = 0;\n\tint skip_pos = 0;\n\t__u32 tsn;\n\tstruct sctp_chunk *chunk;\n\tstruct list_head *lchunk, *temp;\n\n\tif (!asoc->peer.prsctp_capable)\n\t\treturn;\n\n\t \n\tif (TSN_lt(asoc->adv_peer_ack_point, ctsn))\n\t\tasoc->adv_peer_ack_point = ctsn;\n\n\t \n\tlist_for_each_safe(lchunk, temp, &q->abandoned) {\n\t\tchunk = list_entry(lchunk, struct sctp_chunk,\n\t\t\t\t\ttransmitted_list);\n\t\ttsn = ntohl(chunk->subh.data_hdr->tsn);\n\n\t\t \n\t\tif (TSN_lte(tsn, ctsn)) {\n\t\t\tlist_del_init(lchunk);\n\t\t\tsctp_chunk_free(chunk);\n\t\t} else {\n\t\t\tif (TSN_lte(tsn, asoc->adv_peer_ack_point+1)) {\n\t\t\t\tasoc->adv_peer_ack_point = tsn;\n\t\t\t\tif (chunk->chunk_hdr->flags &\n\t\t\t\t\t SCTP_DATA_UNORDERED)\n\t\t\t\t\tcontinue;\n\t\t\t\tskip_pos = sctp_get_skip_pos(&ftsn_skip_arr[0],\n\t\t\t\t\t\tnskips,\n\t\t\t\t\t\tchunk->subh.data_hdr->stream);\n\t\t\t\tftsn_skip_arr[skip_pos].stream =\n\t\t\t\t\tchunk->subh.data_hdr->stream;\n\t\t\t\tftsn_skip_arr[skip_pos].ssn =\n\t\t\t\t\t chunk->subh.data_hdr->ssn;\n\t\t\t\tif (skip_pos == nskips)\n\t\t\t\t\tnskips++;\n\t\t\t\tif (nskips == 10)\n\t\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (asoc->adv_peer_ack_point > ctsn)\n\t\tftsn_chunk = sctp_make_fwdtsn(asoc, asoc->adv_peer_ack_point,\n\t\t\t\t\t      nskips, &ftsn_skip_arr[0]);\n\n\tif (ftsn_chunk) {\n\t\tlist_add_tail(&ftsn_chunk->list, &q->control_chunk_list);\n\t\tSCTP_INC_STATS(asoc->base.net, SCTP_MIB_OUTCTRLCHUNKS);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}