{
  "module_name": "input.c",
  "hash_id": "91b27193dd8d043657e4dd1c1908def82b592b7dc96934788a26df7b21f682c4",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/input.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/list.h>  \n#include <linux/socket.h>\n#include <linux/ip.h>\n#include <linux/time.h>  \n#include <linux/slab.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/snmp.h>\n#include <net/sock.h>\n#include <net/xfrm.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/checksum.h>\n#include <net/net_namespace.h>\n#include <linux/rhashtable.h>\n#include <net/sock_reuseport.h>\n\n \nstatic int sctp_rcv_ootb(struct sk_buff *);\nstatic struct sctp_association *__sctp_rcv_lookup(struct net *net,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const union sctp_addr *paddr,\n\t\t\t\t      const union sctp_addr *laddr,\n\t\t\t\t      struct sctp_transport **transportp,\n\t\t\t\t      int dif, int sdif);\nstatic struct sctp_endpoint *__sctp_rcv_lookup_endpoint(\n\t\t\t\t\tstruct net *net, struct sk_buff *skb,\n\t\t\t\t\tconst union sctp_addr *laddr,\n\t\t\t\t\tconst union sctp_addr *daddr,\n\t\t\t\t\tint dif, int sdif);\nstatic struct sctp_association *__sctp_lookup_association(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst union sctp_addr *local,\n\t\t\t\t\tconst union sctp_addr *peer,\n\t\t\t\t\tstruct sctp_transport **pt,\n\t\t\t\t\tint dif, int sdif);\n\nstatic int sctp_add_backlog(struct sock *sk, struct sk_buff *skb);\n\n\n \nstatic inline int sctp_rcv_checksum(struct net *net, struct sk_buff *skb)\n{\n\tstruct sctphdr *sh = sctp_hdr(skb);\n\t__le32 cmp = sh->checksum;\n\t__le32 val = sctp_compute_cksum(skb, 0);\n\n\tif (val != cmp) {\n\t\t \n\t\t__SCTP_INC_STATS(net, SCTP_MIB_CHECKSUMERRORS);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nint sctp_rcv(struct sk_buff *skb)\n{\n\tstruct sock *sk;\n\tstruct sctp_association *asoc;\n\tstruct sctp_endpoint *ep = NULL;\n\tstruct sctp_ep_common *rcvr;\n\tstruct sctp_transport *transport = NULL;\n\tstruct sctp_chunk *chunk;\n\tunion sctp_addr src;\n\tunion sctp_addr dest;\n\tint family;\n\tstruct sctp_af *af;\n\tstruct net *net = dev_net(skb->dev);\n\tbool is_gso = skb_is_gso(skb) && skb_is_gso_sctp(skb);\n\tint dif, sdif;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t__SCTP_INC_STATS(net, SCTP_MIB_INSCTPPACKS);\n\n\t \n\tif (skb->len < sizeof(struct sctphdr) + sizeof(struct sctp_chunkhdr) +\n\t\t       skb_transport_offset(skb))\n\t\tgoto discard_it;\n\n\t \n\tif ((!is_gso && skb_linearize(skb)) ||\n\t    !pskb_may_pull(skb, sizeof(struct sctphdr)))\n\t\tgoto discard_it;\n\n\t \n\t__skb_pull(skb, skb_transport_offset(skb));\n\n\tskb->csum_valid = 0;  \n\tif (skb_csum_unnecessary(skb))\n\t\t__skb_decr_checksum_unnecessary(skb);\n\telse if (!sctp_checksum_disable &&\n\t\t !is_gso &&\n\t\t sctp_rcv_checksum(net, skb) < 0)\n\t\tgoto discard_it;\n\tskb->csum_valid = 1;\n\n\t__skb_pull(skb, sizeof(struct sctphdr));\n\n\tfamily = ipver2af(ip_hdr(skb)->version);\n\taf = sctp_get_af_specific(family);\n\tif (unlikely(!af))\n\t\tgoto discard_it;\n\tSCTP_INPUT_CB(skb)->af = af;\n\n\t \n\taf->from_skb(&src, skb, 1);\n\taf->from_skb(&dest, skb, 0);\n\tdif = af->skb_iif(skb);\n\tsdif = af->skb_sdif(skb);\n\n\t \n\tif (!af->addr_valid(&src, NULL, skb) ||\n\t    !af->addr_valid(&dest, NULL, skb))\n\t\tgoto discard_it;\n\n\tasoc = __sctp_rcv_lookup(net, skb, &src, &dest, &transport, dif, sdif);\n\n\tif (!asoc)\n\t\tep = __sctp_rcv_lookup_endpoint(net, skb, &dest, &src, dif, sdif);\n\n\t \n\trcvr = asoc ? &asoc->base : &ep->base;\n\tsk = rcvr->sk;\n\n\t \n\tif (!asoc) {\n\t\tif (sctp_rcv_ootb(skb)) {\n\t\t\t__SCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\t\tgoto discard_release;\n\t\t}\n\t}\n\n\tif (!xfrm_policy_check(sk, XFRM_POLICY_IN, skb, family))\n\t\tgoto discard_release;\n\tnf_reset_ct(skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard_release;\n\n\t \n\tchunk = sctp_chunkify(skb, asoc, sk, GFP_ATOMIC);\n\tif (!chunk)\n\t\tgoto discard_release;\n\tSCTP_INPUT_CB(skb)->chunk = chunk;\n\n\t \n\tchunk->rcvr = rcvr;\n\n\t \n\tchunk->sctp_hdr = sctp_hdr(skb);\n\n\t \n\tsctp_init_addrs(chunk, &src, &dest);\n\n\t \n\tchunk->transport = transport;\n\n\t \n\tbh_lock_sock(sk);\n\n\tif (sk != rcvr->sk) {\n\t\t \n\t\tbh_unlock_sock(sk);\n\t\tsk = rcvr->sk;\n\t\tbh_lock_sock(sk);\n\t}\n\n\tif (sock_owned_by_user(sk) || !sctp_newsk_ready(sk)) {\n\t\tif (sctp_add_backlog(sk, skb)) {\n\t\t\tbh_unlock_sock(sk);\n\t\t\tsctp_chunk_free(chunk);\n\t\t\tskb = NULL;  \n\t\t\tgoto discard_release;\n\t\t}\n\t\t__SCTP_INC_STATS(net, SCTP_MIB_IN_PKT_BACKLOG);\n\t} else {\n\t\t__SCTP_INC_STATS(net, SCTP_MIB_IN_PKT_SOFTIRQ);\n\t\tsctp_inq_push(&chunk->rcvr->inqueue, chunk);\n\t}\n\n\tbh_unlock_sock(sk);\n\n\t \n\tif (transport)\n\t\tsctp_transport_put(transport);\n\telse\n\t\tsctp_endpoint_put(ep);\n\n\treturn 0;\n\ndiscard_it:\n\t__SCTP_INC_STATS(net, SCTP_MIB_IN_PKT_DISCARDS);\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_release:\n\t \n\tif (transport)\n\t\tsctp_transport_put(transport);\n\telse\n\t\tsctp_endpoint_put(ep);\n\n\tgoto discard_it;\n}\n\n \nint sctp_backlog_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sctp_chunk *chunk = SCTP_INPUT_CB(skb)->chunk;\n\tstruct sctp_inq *inqueue = &chunk->rcvr->inqueue;\n\tstruct sctp_transport *t = chunk->transport;\n\tstruct sctp_ep_common *rcvr = NULL;\n\tint backloged = 0;\n\n\trcvr = chunk->rcvr;\n\n\t \n\tif (rcvr->dead) {\n\t\tsctp_chunk_free(chunk);\n\t\tgoto done;\n\t}\n\n\tif (unlikely(rcvr->sk != sk)) {\n\t\t \n\n\t\tsk = rcvr->sk;\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(sk);\n\n\t\tif (sock_owned_by_user(sk) || !sctp_newsk_ready(sk)) {\n\t\t\tif (sk_add_backlog(sk, skb, READ_ONCE(sk->sk_rcvbuf)))\n\t\t\t\tsctp_chunk_free(chunk);\n\t\t\telse\n\t\t\t\tbackloged = 1;\n\t\t} else\n\t\t\tsctp_inq_push(inqueue, chunk);\n\n\t\tbh_unlock_sock(sk);\n\t\tlocal_bh_enable();\n\n\t\t \n\t\tif (backloged)\n\t\t\treturn 0;\n\t} else {\n\t\tif (!sctp_newsk_ready(sk)) {\n\t\t\tif (!sk_add_backlog(sk, skb, READ_ONCE(sk->sk_rcvbuf)))\n\t\t\t\treturn 0;\n\t\t\tsctp_chunk_free(chunk);\n\t\t} else {\n\t\t\tsctp_inq_push(inqueue, chunk);\n\t\t}\n\t}\n\ndone:\n\t \n\tif (SCTP_EP_TYPE_ASSOCIATION == rcvr->type)\n\t\tsctp_transport_put(t);\n\telse if (SCTP_EP_TYPE_SOCKET == rcvr->type)\n\t\tsctp_endpoint_put(sctp_ep(rcvr));\n\telse\n\t\tBUG();\n\n\treturn 0;\n}\n\nstatic int sctp_add_backlog(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sctp_chunk *chunk = SCTP_INPUT_CB(skb)->chunk;\n\tstruct sctp_transport *t = chunk->transport;\n\tstruct sctp_ep_common *rcvr = chunk->rcvr;\n\tint ret;\n\n\tret = sk_add_backlog(sk, skb, READ_ONCE(sk->sk_rcvbuf));\n\tif (!ret) {\n\t\t \n\t\tif (SCTP_EP_TYPE_ASSOCIATION == rcvr->type)\n\t\t\tsctp_transport_hold(t);\n\t\telse if (SCTP_EP_TYPE_SOCKET == rcvr->type)\n\t\t\tsctp_endpoint_hold(sctp_ep(rcvr));\n\t\telse\n\t\t\tBUG();\n\t}\n\treturn ret;\n\n}\n\n \nvoid sctp_icmp_frag_needed(struct sock *sk, struct sctp_association *asoc,\n\t\t\t   struct sctp_transport *t, __u32 pmtu)\n{\n\tif (!t ||\n\t    (t->pathmtu <= pmtu &&\n\t     t->pl.probe_size + sctp_transport_pl_hlen(t) <= pmtu))\n\t\treturn;\n\n\tif (sock_owned_by_user(sk)) {\n\t\tatomic_set(&t->mtu_info, pmtu);\n\t\tasoc->pmtu_pending = 1;\n\t\tt->pmtu_pending = 1;\n\t\treturn;\n\t}\n\n\tif (!(t->param_flags & SPP_PMTUD_ENABLE))\n\t\t \n\t\treturn;\n\n\t \n\tif (!sctp_transport_update_pmtu(t, pmtu))\n\t\treturn;\n\n\t \n\tsctp_assoc_sync_pmtu(asoc);\n\n\t \n\tsctp_retransmit(&asoc->outqueue, t, SCTP_RTXR_PMTUD);\n}\n\nvoid sctp_icmp_redirect(struct sock *sk, struct sctp_transport *t,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct dst_entry *dst;\n\n\tif (sock_owned_by_user(sk) || !t)\n\t\treturn;\n\tdst = sctp_transport_dst_check(t);\n\tif (dst)\n\t\tdst->ops->redirect(dst, sk, skb);\n}\n\n \nvoid sctp_icmp_proto_unreachable(struct sock *sk,\n\t\t\t   struct sctp_association *asoc,\n\t\t\t   struct sctp_transport *t)\n{\n\tif (sock_owned_by_user(sk)) {\n\t\tif (timer_pending(&t->proto_unreach_timer))\n\t\t\treturn;\n\t\telse {\n\t\t\tif (!mod_timer(&t->proto_unreach_timer,\n\t\t\t\t\t\tjiffies + (HZ/20)))\n\t\t\t\tsctp_transport_hold(t);\n\t\t}\n\t} else {\n\t\tstruct net *net = sock_net(sk);\n\n\t\tpr_debug(\"%s: unrecognized next header type \"\n\t\t\t \"encountered!\\n\", __func__);\n\n\t\tif (del_timer(&t->proto_unreach_timer))\n\t\t\tsctp_transport_put(t);\n\n\t\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t\t   asoc->state, asoc->ep, asoc, t,\n\t\t\t   GFP_ATOMIC);\n\t}\n}\n\n \nstruct sock *sctp_err_lookup(struct net *net, int family, struct sk_buff *skb,\n\t\t\t     struct sctphdr *sctphdr,\n\t\t\t     struct sctp_association **app,\n\t\t\t     struct sctp_transport **tpp)\n{\n\tstruct sctp_init_chunk *chunkhdr, _chunkhdr;\n\tunion sctp_addr saddr;\n\tunion sctp_addr daddr;\n\tstruct sctp_af *af;\n\tstruct sock *sk = NULL;\n\tstruct sctp_association *asoc;\n\tstruct sctp_transport *transport = NULL;\n\t__u32 vtag = ntohl(sctphdr->vtag);\n\tint sdif = inet_sdif(skb);\n\tint dif = inet_iif(skb);\n\n\t*app = NULL; *tpp = NULL;\n\n\taf = sctp_get_af_specific(family);\n\tif (unlikely(!af)) {\n\t\treturn NULL;\n\t}\n\n\t \n\taf->from_skb(&saddr, skb, 1);\n\taf->from_skb(&daddr, skb, 0);\n\n\t \n\tasoc = __sctp_lookup_association(net, &saddr, &daddr, &transport, dif, sdif);\n\tif (!asoc)\n\t\treturn NULL;\n\n\tsk = asoc->base.sk;\n\n\t \n\tif (vtag == 0) {\n\t\t \n\t\tchunkhdr = skb_header_pointer(skb, skb_transport_offset(skb) +\n\t\t\t\t\t      sizeof(struct sctphdr),\n\t\t\t\t\t      sizeof(struct sctp_chunkhdr) +\n\t\t\t\t\t      sizeof(__be32), &_chunkhdr);\n\t\tif (!chunkhdr ||\n\t\t    chunkhdr->chunk_hdr.type != SCTP_CID_INIT ||\n\t\t    ntohl(chunkhdr->init_hdr.init_tag) != asoc->c.my_vtag)\n\t\t\tgoto out;\n\n\t} else if (vtag != asoc->c.peer_vtag) {\n\t\tgoto out;\n\t}\n\n\tbh_lock_sock(sk);\n\n\t \n\tif (sock_owned_by_user(sk))\n\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\t*app = asoc;\n\t*tpp = transport;\n\treturn sk;\n\nout:\n\tsctp_transport_put(transport);\n\treturn NULL;\n}\n\n \nvoid sctp_err_finish(struct sock *sk, struct sctp_transport *t)\n\t__releases(&((__sk)->sk_lock.slock))\n{\n\tbh_unlock_sock(sk);\n\tsctp_transport_put(t);\n}\n\nstatic void sctp_v4_err_handle(struct sctp_transport *t, struct sk_buff *skb,\n\t\t\t       __u8 type, __u8 code, __u32 info)\n{\n\tstruct sctp_association *asoc = t->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\n\tswitch (type) {\n\tcase ICMP_PARAMETERPROB:\n\t\terr = EPROTO;\n\t\tbreak;\n\tcase ICMP_DEST_UNREACH:\n\t\tif (code > NR_ICMP_UNREACH)\n\t\t\treturn;\n\t\tif (code == ICMP_FRAG_NEEDED) {\n\t\t\tsctp_icmp_frag_needed(sk, asoc, t, SCTP_TRUNC4(info));\n\t\t\treturn;\n\t\t}\n\t\tif (code == ICMP_PROT_UNREACH) {\n\t\t\tsctp_icmp_proto_unreachable(sk, asoc, t);\n\t\t\treturn;\n\t\t}\n\t\terr = icmp_err_convert[code].errno;\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\tif (code == ICMP_EXC_FRAGTIME)\n\t\t\treturn;\n\n\t\terr = EHOSTUNREACH;\n\t\tbreak;\n\tcase ICMP_REDIRECT:\n\t\tsctp_icmp_redirect(sk, t, skb);\n\t\treturn;\n\tdefault:\n\t\treturn;\n\t}\n\tif (!sock_owned_by_user(sk) && inet_test_bit(RECVERR, sk)) {\n\t\tsk->sk_err = err;\n\t\tsk_error_report(sk);\n\t} else {   \n\t\tWRITE_ONCE(sk->sk_err_soft, err);\n\t}\n}\n\n \nint sctp_v4_err(struct sk_buff *skb, __u32 info)\n{\n\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sctp_transport *transport;\n\tstruct sctp_association *asoc;\n\t__u16 saveip, savesctp;\n\tstruct sock *sk;\n\n\t \n\tsaveip = skb->network_header;\n\tsavesctp = skb->transport_header;\n\tskb_reset_network_header(skb);\n\tskb_set_transport_header(skb, iph->ihl * 4);\n\tsk = sctp_err_lookup(net, AF_INET, skb, sctp_hdr(skb), &asoc, &transport);\n\t \n\tskb->network_header = saveip;\n\tskb->transport_header = savesctp;\n\tif (!sk) {\n\t\t__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);\n\t\treturn -ENOENT;\n\t}\n\n\tsctp_v4_err_handle(transport, skb, type, code, info);\n\tsctp_err_finish(sk, transport);\n\n\treturn 0;\n}\n\nint sctp_udp_v4_err(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sctp_association *asoc;\n\tstruct sctp_transport *t;\n\tstruct icmphdr *hdr;\n\t__u32 info = 0;\n\n\tskb->transport_header += sizeof(struct udphdr);\n\tsk = sctp_err_lookup(net, AF_INET, skb, sctp_hdr(skb), &asoc, &t);\n\tif (!sk) {\n\t\t__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);\n\t\treturn -ENOENT;\n\t}\n\n\tskb->transport_header -= sizeof(struct udphdr);\n\thdr = (struct icmphdr *)(skb_network_header(skb) - sizeof(struct icmphdr));\n\tif (hdr->type == ICMP_REDIRECT) {\n\t\t \n\t\tsctp_err_finish(sk, t);\n\t\treturn 0;\n\t}\n\tif (hdr->type == ICMP_DEST_UNREACH && hdr->code == ICMP_FRAG_NEEDED)\n\t\tinfo = ntohs(hdr->un.frag.mtu);\n\tsctp_v4_err_handle(t, skb, hdr->type, hdr->code, info);\n\n\tsctp_err_finish(sk, t);\n\treturn 1;\n}\n\n \nstatic int sctp_rcv_ootb(struct sk_buff *skb)\n{\n\tstruct sctp_chunkhdr *ch, _ch;\n\tint ch_end, offset = 0;\n\n\t \n\tdo {\n\t\t \n\t\tif (offset + sizeof(_ch) > skb->len)\n\t\t\tbreak;\n\n\t\tch = skb_header_pointer(skb, offset, sizeof(*ch), &_ch);\n\n\t\t \n\t\tif (!ch || ntohs(ch->length) < sizeof(_ch))\n\t\t\tbreak;\n\n\t\tch_end = offset + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb->len)\n\t\t\tbreak;\n\n\t\t \n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\tgoto discard;\n\n\t\t \n\t\tif (SCTP_CID_SHUTDOWN_COMPLETE == ch->type)\n\t\t\tgoto discard;\n\n\t\t \n\t\tif (SCTP_CID_INIT == ch->type && (void *)ch != skb->data)\n\t\t\tgoto discard;\n\n\t\toffset = ch_end;\n\t} while (ch_end < skb->len);\n\n\treturn 0;\n\ndiscard:\n\treturn 1;\n}\n\n \nstatic int __sctp_hash_endpoint(struct sctp_endpoint *ep)\n{\n\tstruct sock *sk = ep->base.sk;\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_hashbucket *head;\n\n\tep->hashent = sctp_ep_hashfn(net, ep->base.bind_addr.port);\n\thead = &sctp_ep_hashtable[ep->hashent];\n\n\tif (sk->sk_reuseport) {\n\t\tbool any = sctp_is_ep_boundall(sk);\n\t\tstruct sctp_endpoint *ep2;\n\t\tstruct list_head *list;\n\t\tint cnt = 0, err = 1;\n\n\t\tlist_for_each(list, &ep->base.bind_addr.address_list)\n\t\t\tcnt++;\n\n\t\tsctp_for_each_hentry(ep2, &head->chain) {\n\t\t\tstruct sock *sk2 = ep2->base.sk;\n\n\t\t\tif (!net_eq(sock_net(sk2), net) || sk2 == sk ||\n\t\t\t    !uid_eq(sock_i_uid(sk2), sock_i_uid(sk)) ||\n\t\t\t    !sk2->sk_reuseport)\n\t\t\t\tcontinue;\n\n\t\t\terr = sctp_bind_addrs_check(sctp_sk(sk2),\n\t\t\t\t\t\t    sctp_sk(sk), cnt);\n\t\t\tif (!err) {\n\t\t\t\terr = reuseport_add_sock(sk, sk2, any);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbreak;\n\t\t\t} else if (err < 0) {\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tif (err) {\n\t\t\terr = reuseport_alloc(sk, any);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\twrite_lock(&head->lock);\n\thlist_add_head(&ep->node, &head->chain);\n\twrite_unlock(&head->lock);\n\treturn 0;\n}\n\n \nint sctp_hash_endpoint(struct sctp_endpoint *ep)\n{\n\tint err;\n\n\tlocal_bh_disable();\n\terr = __sctp_hash_endpoint(ep);\n\tlocal_bh_enable();\n\n\treturn err;\n}\n\n \nstatic void __sctp_unhash_endpoint(struct sctp_endpoint *ep)\n{\n\tstruct sock *sk = ep->base.sk;\n\tstruct sctp_hashbucket *head;\n\n\tep->hashent = sctp_ep_hashfn(sock_net(sk), ep->base.bind_addr.port);\n\n\thead = &sctp_ep_hashtable[ep->hashent];\n\n\tif (rcu_access_pointer(sk->sk_reuseport_cb))\n\t\treuseport_detach_sock(sk);\n\n\twrite_lock(&head->lock);\n\thlist_del_init(&ep->node);\n\twrite_unlock(&head->lock);\n}\n\n \nvoid sctp_unhash_endpoint(struct sctp_endpoint *ep)\n{\n\tlocal_bh_disable();\n\t__sctp_unhash_endpoint(ep);\n\tlocal_bh_enable();\n}\n\nstatic inline __u32 sctp_hashfn(const struct net *net, __be16 lport,\n\t\t\t\tconst union sctp_addr *paddr, __u32 seed)\n{\n\t__u32 addr;\n\n\tif (paddr->sa.sa_family == AF_INET6)\n\t\taddr = jhash(&paddr->v6.sin6_addr, 16, seed);\n\telse\n\t\taddr = (__force __u32)paddr->v4.sin_addr.s_addr;\n\n\treturn  jhash_3words(addr, ((__force __u32)paddr->v4.sin_port) << 16 |\n\t\t\t     (__force __u32)lport, net_hash_mix(net), seed);\n}\n\n \nstatic struct sctp_endpoint *__sctp_rcv_lookup_endpoint(\n\t\t\t\t\tstruct net *net, struct sk_buff *skb,\n\t\t\t\t\tconst union sctp_addr *laddr,\n\t\t\t\t\tconst union sctp_addr *paddr,\n\t\t\t\t\tint dif, int sdif)\n{\n\tstruct sctp_hashbucket *head;\n\tstruct sctp_endpoint *ep;\n\tstruct sock *sk;\n\t__be16 lport;\n\tint hash;\n\n\tlport = laddr->v4.sin_port;\n\thash = sctp_ep_hashfn(net, ntohs(lport));\n\thead = &sctp_ep_hashtable[hash];\n\tread_lock(&head->lock);\n\tsctp_for_each_hentry(ep, &head->chain) {\n\t\tif (sctp_endpoint_is_match(ep, net, laddr, dif, sdif))\n\t\t\tgoto hit;\n\t}\n\n\tep = sctp_sk(net->sctp.ctl_sock)->ep;\n\nhit:\n\tsk = ep->base.sk;\n\tif (sk->sk_reuseport) {\n\t\t__u32 phash = sctp_hashfn(net, lport, paddr, 0);\n\n\t\tsk = reuseport_select_sock(sk, phash, skb,\n\t\t\t\t\t   sizeof(struct sctphdr));\n\t\tif (sk)\n\t\t\tep = sctp_sk(sk)->ep;\n\t}\n\tsctp_endpoint_hold(ep);\n\tread_unlock(&head->lock);\n\treturn ep;\n}\n\n \nstruct sctp_hash_cmp_arg {\n\tconst union sctp_addr\t*paddr;\n\tconst struct net\t*net;\n\t__be16\t\t\tlport;\n};\n\nstatic inline int sctp_hash_cmp(struct rhashtable_compare_arg *arg,\n\t\t\t\tconst void *ptr)\n{\n\tstruct sctp_transport *t = (struct sctp_transport *)ptr;\n\tconst struct sctp_hash_cmp_arg *x = arg->key;\n\tint err = 1;\n\n\tif (!sctp_cmp_addr_exact(&t->ipaddr, x->paddr))\n\t\treturn err;\n\tif (!sctp_transport_hold(t))\n\t\treturn err;\n\n\tif (!net_eq(t->asoc->base.net, x->net))\n\t\tgoto out;\n\tif (x->lport != htons(t->asoc->base.bind_addr.port))\n\t\tgoto out;\n\n\terr = 0;\nout:\n\tsctp_transport_put(t);\n\treturn err;\n}\n\nstatic inline __u32 sctp_hash_obj(const void *data, u32 len, u32 seed)\n{\n\tconst struct sctp_transport *t = data;\n\n\treturn sctp_hashfn(t->asoc->base.net,\n\t\t\t   htons(t->asoc->base.bind_addr.port),\n\t\t\t   &t->ipaddr, seed);\n}\n\nstatic inline __u32 sctp_hash_key(const void *data, u32 len, u32 seed)\n{\n\tconst struct sctp_hash_cmp_arg *x = data;\n\n\treturn sctp_hashfn(x->net, x->lport, x->paddr, seed);\n}\n\nstatic const struct rhashtable_params sctp_hash_params = {\n\t.head_offset\t\t= offsetof(struct sctp_transport, node),\n\t.hashfn\t\t\t= sctp_hash_key,\n\t.obj_hashfn\t\t= sctp_hash_obj,\n\t.obj_cmpfn\t\t= sctp_hash_cmp,\n\t.automatic_shrinking\t= true,\n};\n\nint sctp_transport_hashtable_init(void)\n{\n\treturn rhltable_init(&sctp_transport_hashtable, &sctp_hash_params);\n}\n\nvoid sctp_transport_hashtable_destroy(void)\n{\n\trhltable_destroy(&sctp_transport_hashtable);\n}\n\nint sctp_hash_transport(struct sctp_transport *t)\n{\n\tstruct sctp_transport *transport;\n\tstruct rhlist_head *tmp, *list;\n\tstruct sctp_hash_cmp_arg arg;\n\tint err;\n\n\tif (t->asoc->temp)\n\t\treturn 0;\n\n\targ.net   = t->asoc->base.net;\n\targ.paddr = &t->ipaddr;\n\targ.lport = htons(t->asoc->base.bind_addr.port);\n\n\trcu_read_lock();\n\tlist = rhltable_lookup(&sctp_transport_hashtable, &arg,\n\t\t\t       sctp_hash_params);\n\n\trhl_for_each_entry_rcu(transport, tmp, list, node)\n\t\tif (transport->asoc->ep == t->asoc->ep) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -EEXIST;\n\t\t}\n\trcu_read_unlock();\n\n\terr = rhltable_insert_key(&sctp_transport_hashtable, &arg,\n\t\t\t\t  &t->node, sctp_hash_params);\n\tif (err)\n\t\tpr_err_once(\"insert transport fail, errno %d\\n\", err);\n\n\treturn err;\n}\n\nvoid sctp_unhash_transport(struct sctp_transport *t)\n{\n\tif (t->asoc->temp)\n\t\treturn;\n\n\trhltable_remove(&sctp_transport_hashtable, &t->node,\n\t\t\tsctp_hash_params);\n}\n\nbool sctp_sk_bound_dev_eq(struct net *net, int bound_dev_if, int dif, int sdif)\n{\n\tbool l3mdev_accept = true;\n\n#if IS_ENABLED(CONFIG_NET_L3_MASTER_DEV)\n\tl3mdev_accept = !!READ_ONCE(net->sctp.l3mdev_accept);\n#endif\n\treturn inet_bound_dev_eq(l3mdev_accept, bound_dev_if, dif, sdif);\n}\n\n \nstruct sctp_transport *sctp_addrs_lookup_transport(\n\t\t\t\tstruct net *net,\n\t\t\t\tconst union sctp_addr *laddr,\n\t\t\t\tconst union sctp_addr *paddr,\n\t\t\t\tint dif, int sdif)\n{\n\tstruct rhlist_head *tmp, *list;\n\tstruct sctp_transport *t;\n\tint bound_dev_if;\n\tstruct sctp_hash_cmp_arg arg = {\n\t\t.paddr = paddr,\n\t\t.net   = net,\n\t\t.lport = laddr->v4.sin_port,\n\t};\n\n\tlist = rhltable_lookup(&sctp_transport_hashtable, &arg,\n\t\t\t       sctp_hash_params);\n\n\trhl_for_each_entry_rcu(t, tmp, list, node) {\n\t\tif (!sctp_transport_hold(t))\n\t\t\tcontinue;\n\n\t\tbound_dev_if = READ_ONCE(t->asoc->base.sk->sk_bound_dev_if);\n\t\tif (sctp_sk_bound_dev_eq(net, bound_dev_if, dif, sdif) &&\n\t\t    sctp_bind_addr_match(&t->asoc->base.bind_addr,\n\t\t\t\t\t laddr, sctp_sk(t->asoc->base.sk)))\n\t\t\treturn t;\n\t\tsctp_transport_put(t);\n\t}\n\n\treturn NULL;\n}\n\n \nstruct sctp_transport *sctp_epaddr_lookup_transport(\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst union sctp_addr *paddr)\n{\n\tstruct rhlist_head *tmp, *list;\n\tstruct sctp_transport *t;\n\tstruct sctp_hash_cmp_arg arg = {\n\t\t.paddr = paddr,\n\t\t.net   = ep->base.net,\n\t\t.lport = htons(ep->base.bind_addr.port),\n\t};\n\n\tlist = rhltable_lookup(&sctp_transport_hashtable, &arg,\n\t\t\t       sctp_hash_params);\n\n\trhl_for_each_entry_rcu(t, tmp, list, node)\n\t\tif (ep == t->asoc->ep)\n\t\t\treturn t;\n\n\treturn NULL;\n}\n\n \nstatic struct sctp_association *__sctp_lookup_association(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst union sctp_addr *local,\n\t\t\t\t\tconst union sctp_addr *peer,\n\t\t\t\t\tstruct sctp_transport **pt,\n\t\t\t\t\tint dif, int sdif)\n{\n\tstruct sctp_transport *t;\n\tstruct sctp_association *asoc = NULL;\n\n\tt = sctp_addrs_lookup_transport(net, local, peer, dif, sdif);\n\tif (!t)\n\t\tgoto out;\n\n\tasoc = t->asoc;\n\t*pt = t;\n\nout:\n\treturn asoc;\n}\n\n \nstatic\nstruct sctp_association *sctp_lookup_association(struct net *net,\n\t\t\t\t\t\t const union sctp_addr *laddr,\n\t\t\t\t\t\t const union sctp_addr *paddr,\n\t\t\t\t\t\t struct sctp_transport **transportp,\n\t\t\t\t\t\t int dif, int sdif)\n{\n\tstruct sctp_association *asoc;\n\n\trcu_read_lock();\n\tasoc = __sctp_lookup_association(net, laddr, paddr, transportp, dif, sdif);\n\trcu_read_unlock();\n\n\treturn asoc;\n}\n\n \nbool sctp_has_association(struct net *net,\n\t\t\t  const union sctp_addr *laddr,\n\t\t\t  const union sctp_addr *paddr,\n\t\t\t  int dif, int sdif)\n{\n\tstruct sctp_transport *transport;\n\n\tif (sctp_lookup_association(net, laddr, paddr, &transport, dif, sdif)) {\n\t\tsctp_transport_put(transport);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic struct sctp_association *__sctp_rcv_init_lookup(struct net *net,\n\tstruct sk_buff *skb,\n\tconst union sctp_addr *laddr, struct sctp_transport **transportp,\n\tint dif, int sdif)\n{\n\tstruct sctp_association *asoc;\n\tunion sctp_addr addr;\n\tunion sctp_addr *paddr = &addr;\n\tstruct sctphdr *sh = sctp_hdr(skb);\n\tunion sctp_params params;\n\tstruct sctp_init_chunk *init;\n\tstruct sctp_af *af;\n\n\t \n\n\t \n\tinit = (struct sctp_init_chunk *)skb->data;\n\n\t \n\tsctp_walk_params(params, init) {\n\n\t\t \n\t\taf = sctp_get_af_specific(param_type2af(params.p->type));\n\t\tif (!af)\n\t\t\tcontinue;\n\n\t\tif (!af->from_addr_param(paddr, params.addr, sh->source, 0))\n\t\t\tcontinue;\n\n\t\tasoc = __sctp_lookup_association(net, laddr, paddr, transportp, dif, sdif);\n\t\tif (asoc)\n\t\t\treturn asoc;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct sctp_association *__sctp_rcv_asconf_lookup(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tstruct sctp_chunkhdr *ch,\n\t\t\t\t\tconst union sctp_addr *laddr,\n\t\t\t\t\t__be16 peer_port,\n\t\t\t\t\tstruct sctp_transport **transportp,\n\t\t\t\t\tint dif, int sdif)\n{\n\tstruct sctp_addip_chunk *asconf = (struct sctp_addip_chunk *)ch;\n\tstruct sctp_af *af;\n\tunion sctp_addr_param *param;\n\tunion sctp_addr paddr;\n\n\tif (ntohs(ch->length) < sizeof(*asconf) + sizeof(struct sctp_paramhdr))\n\t\treturn NULL;\n\n\t \n\tparam = (union sctp_addr_param *)(asconf + 1);\n\n\taf = sctp_get_af_specific(param_type2af(param->p.type));\n\tif (unlikely(!af))\n\t\treturn NULL;\n\n\tif (!af->from_addr_param(&paddr, param, peer_port, 0))\n\t\treturn NULL;\n\n\treturn __sctp_lookup_association(net, laddr, &paddr, transportp, dif, sdif);\n}\n\n\n \nstatic struct sctp_association *__sctp_rcv_walk_lookup(struct net *net,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const union sctp_addr *laddr,\n\t\t\t\t      struct sctp_transport **transportp,\n\t\t\t\t      int dif, int sdif)\n{\n\tstruct sctp_association *asoc = NULL;\n\tstruct sctp_chunkhdr *ch;\n\tint have_auth = 0;\n\tunsigned int chunk_num = 1;\n\t__u8 *ch_end;\n\n\t \n\tch = (struct sctp_chunkhdr *)skb->data;\n\tdo {\n\t\t \n\t\tif (ntohs(ch->length) < sizeof(*ch))\n\t\t\tbreak;\n\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\tbreak;\n\n\t\tswitch (ch->type) {\n\t\tcase SCTP_CID_AUTH:\n\t\t\thave_auth = chunk_num;\n\t\t\tbreak;\n\n\t\tcase SCTP_CID_COOKIE_ECHO:\n\t\t\t \n\t\t\tif (have_auth == 1 && chunk_num == 2)\n\t\t\t\treturn NULL;\n\t\t\tbreak;\n\n\t\tcase SCTP_CID_ASCONF:\n\t\t\tif (have_auth || net->sctp.addip_noauth)\n\t\t\t\tasoc = __sctp_rcv_asconf_lookup(\n\t\t\t\t\t\tnet, ch, laddr,\n\t\t\t\t\t\tsctp_hdr(skb)->source,\n\t\t\t\t\t\ttransportp, dif, sdif);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (asoc)\n\t\t\tbreak;\n\n\t\tch = (struct sctp_chunkhdr *)ch_end;\n\t\tchunk_num++;\n\t} while (ch_end + sizeof(*ch) < skb_tail_pointer(skb));\n\n\treturn asoc;\n}\n\n \nstatic struct sctp_association *__sctp_rcv_lookup_harder(struct net *net,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const union sctp_addr *laddr,\n\t\t\t\t      struct sctp_transport **transportp,\n\t\t\t\t      int dif, int sdif)\n{\n\tstruct sctp_chunkhdr *ch;\n\n\t \n\tif (skb_is_gso(skb) && skb_is_gso_sctp(skb))\n\t\treturn NULL;\n\n\tch = (struct sctp_chunkhdr *)skb->data;\n\n\t \n\tif (SCTP_PAD4(ntohs(ch->length)) > skb->len)\n\t\treturn NULL;\n\n\t \n\tif (ch->type == SCTP_CID_INIT || ch->type == SCTP_CID_INIT_ACK)\n\t\treturn __sctp_rcv_init_lookup(net, skb, laddr, transportp, dif, sdif);\n\n\treturn __sctp_rcv_walk_lookup(net, skb, laddr, transportp, dif, sdif);\n}\n\n \nstatic struct sctp_association *__sctp_rcv_lookup(struct net *net,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      const union sctp_addr *paddr,\n\t\t\t\t      const union sctp_addr *laddr,\n\t\t\t\t      struct sctp_transport **transportp,\n\t\t\t\t      int dif, int sdif)\n{\n\tstruct sctp_association *asoc;\n\n\tasoc = __sctp_lookup_association(net, laddr, paddr, transportp, dif, sdif);\n\tif (asoc)\n\t\tgoto out;\n\n\t \n\tasoc = __sctp_rcv_lookup_harder(net, skb, laddr, transportp, dif, sdif);\n\tif (asoc)\n\t\tgoto out;\n\n\tif (paddr->sa.sa_family == AF_INET)\n\t\tpr_debug(\"sctp: asoc not found for src:%pI4:%d dst:%pI4:%d\\n\",\n\t\t\t &laddr->v4.sin_addr, ntohs(laddr->v4.sin_port),\n\t\t\t &paddr->v4.sin_addr, ntohs(paddr->v4.sin_port));\n\telse\n\t\tpr_debug(\"sctp: asoc not found for src:%pI6:%d dst:%pI6:%d\\n\",\n\t\t\t &laddr->v6.sin6_addr, ntohs(laddr->v6.sin6_port),\n\t\t\t &paddr->v6.sin6_addr, ntohs(paddr->v6.sin6_port));\n\nout:\n\treturn asoc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}