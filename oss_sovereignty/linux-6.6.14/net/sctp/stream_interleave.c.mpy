{
  "module_name": "stream_interleave.c",
  "hash_id": "e5128f19c32507cd5dab748babcac61e4e632e3309c954d577df53ba58f7bc2d",
  "original_prompt": "Ingested from linux-6.6.14/net/sctp/stream_interleave.c",
  "human_readable_source": "\n \n\n#include <net/busy_poll.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/ulpevent.h>\n#include <linux/sctp.h>\n\nstatic struct sctp_chunk *sctp_make_idatafrag_empty(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_sndrcvinfo *sinfo,\n\t\t\t\t\tint len, __u8 flags, gfp_t gfp)\n{\n\tstruct sctp_chunk *retval;\n\tstruct sctp_idatahdr dp;\n\n\tmemset(&dp, 0, sizeof(dp));\n\tdp.stream = htons(sinfo->sinfo_stream);\n\n\tif (sinfo->sinfo_flags & SCTP_UNORDERED)\n\t\tflags |= SCTP_DATA_UNORDERED;\n\n\tretval = sctp_make_idata(asoc, flags, sizeof(dp) + len, gfp);\n\tif (!retval)\n\t\treturn NULL;\n\n\tretval->subh.idata_hdr = sctp_addto_chunk(retval, sizeof(dp), &dp);\n\tmemcpy(&retval->sinfo, sinfo, sizeof(struct sctp_sndrcvinfo));\n\n\treturn retval;\n}\n\nstatic void sctp_chunk_assign_mid(struct sctp_chunk *chunk)\n{\n\tstruct sctp_stream *stream;\n\tstruct sctp_chunk *lchunk;\n\t__u32 cfsn = 0;\n\t__u16 sid;\n\n\tif (chunk->has_mid)\n\t\treturn;\n\n\tsid = sctp_chunk_stream_no(chunk);\n\tstream = &chunk->asoc->stream;\n\n\tlist_for_each_entry(lchunk, &chunk->msg->chunks, frag_list) {\n\t\tstruct sctp_idatahdr *hdr;\n\t\t__u32 mid;\n\n\t\tlchunk->has_mid = 1;\n\n\t\thdr = lchunk->subh.idata_hdr;\n\n\t\tif (lchunk->chunk_hdr->flags & SCTP_DATA_FIRST_FRAG)\n\t\t\thdr->ppid = lchunk->sinfo.sinfo_ppid;\n\t\telse\n\t\t\thdr->fsn = htonl(cfsn++);\n\n\t\tif (lchunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\t\tmid = lchunk->chunk_hdr->flags & SCTP_DATA_LAST_FRAG ?\n\t\t\t\tsctp_mid_uo_next(stream, out, sid) :\n\t\t\t\tsctp_mid_uo_peek(stream, out, sid);\n\t\t} else {\n\t\t\tmid = lchunk->chunk_hdr->flags & SCTP_DATA_LAST_FRAG ?\n\t\t\t\tsctp_mid_next(stream, out, sid) :\n\t\t\t\tsctp_mid_peek(stream, out, sid);\n\t\t}\n\t\thdr->mid = htonl(mid);\n\t}\n}\n\nstatic bool sctp_validate_data(struct sctp_chunk *chunk)\n{\n\tstruct sctp_stream *stream;\n\t__u16 sid, ssn;\n\n\tif (chunk->chunk_hdr->type != SCTP_CID_DATA)\n\t\treturn false;\n\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED)\n\t\treturn true;\n\n\tstream = &chunk->asoc->stream;\n\tsid = sctp_chunk_stream_no(chunk);\n\tssn = ntohs(chunk->subh.data_hdr->ssn);\n\n\treturn !SSN_lt(ssn, sctp_ssn_peek(stream, in, sid));\n}\n\nstatic bool sctp_validate_idata(struct sctp_chunk *chunk)\n{\n\tstruct sctp_stream *stream;\n\t__u32 mid;\n\t__u16 sid;\n\n\tif (chunk->chunk_hdr->type != SCTP_CID_I_DATA)\n\t\treturn false;\n\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED)\n\t\treturn true;\n\n\tstream = &chunk->asoc->stream;\n\tsid = sctp_chunk_stream_no(chunk);\n\tmid = ntohl(chunk->subh.idata_hdr->mid);\n\n\treturn !MID_lt(mid, sctp_mid_peek(stream, in, sid));\n}\n\nstatic void sctp_intl_store_reasm(struct sctp_ulpq *ulpq,\n\t\t\t\t  struct sctp_ulpevent *event)\n{\n\tstruct sctp_ulpevent *cevent;\n\tstruct sk_buff *pos, *loc;\n\n\tpos = skb_peek_tail(&ulpq->reasm);\n\tif (!pos) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\tcevent = sctp_skb2event(pos);\n\n\tif (event->stream == cevent->stream &&\n\t    event->mid == cevent->mid &&\n\t    (cevent->msg_flags & SCTP_DATA_FIRST_FRAG ||\n\t     (!(event->msg_flags & SCTP_DATA_FIRST_FRAG) &&\n\t      event->fsn > cevent->fsn))) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\tif ((event->stream == cevent->stream &&\n\t     MID_lt(cevent->mid, event->mid)) ||\n\t    event->stream > cevent->stream) {\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\tloc = NULL;\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\n\t\tif (event->stream < cevent->stream ||\n\t\t    (event->stream == cevent->stream &&\n\t\t     MID_lt(event->mid, cevent->mid))) {\n\t\t\tloc = pos;\n\t\t\tbreak;\n\t\t}\n\t\tif (event->stream == cevent->stream &&\n\t\t    event->mid == cevent->mid &&\n\t\t    !(cevent->msg_flags & SCTP_DATA_FIRST_FRAG) &&\n\t\t    (event->msg_flags & SCTP_DATA_FIRST_FRAG ||\n\t\t     event->fsn < cevent->fsn)) {\n\t\t\tloc = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!loc)\n\t\t__skb_queue_tail(&ulpq->reasm, sctp_event2skb(event));\n\telse\n\t\t__skb_queue_before(&ulpq->reasm, loc, sctp_event2skb(event));\n}\n\nstatic struct sctp_ulpevent *sctp_intl_retrieve_partial(\n\t\t\t\t\t\tstruct sctp_ulpq *ulpq,\n\t\t\t\t\t\tstruct sctp_ulpevent *event)\n{\n\tstruct sk_buff *first_frag = NULL;\n\tstruct sk_buff *last_frag = NULL;\n\tstruct sctp_ulpevent *retval;\n\tstruct sctp_stream_in *sin;\n\tstruct sk_buff *pos;\n\t__u32 next_fsn = 0;\n\tint is_last = 0;\n\n\tsin = sctp_stream_in(&ulpq->asoc->stream, event->stream);\n\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tstruct sctp_ulpevent *cevent = sctp_skb2event(pos);\n\n\t\tif (cevent->stream < event->stream)\n\t\t\tcontinue;\n\n\t\tif (cevent->stream > event->stream ||\n\t\t    cevent->mid != sin->mid)\n\t\t\tbreak;\n\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_FIRST_FRAG:\n\t\t\tgoto out;\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif (!first_frag) {\n\t\t\t\tif (cevent->fsn == sin->fsn) {\n\t\t\t\t\tfirst_frag = pos;\n\t\t\t\t\tlast_frag = pos;\n\t\t\t\t\tnext_fsn = cevent->fsn + 1;\n\t\t\t\t}\n\t\t\t} else if (cevent->fsn == next_fsn) {\n\t\t\t\tlast_frag = pos;\n\t\t\t\tnext_fsn++;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (!first_frag) {\n\t\t\t\tif (cevent->fsn == sin->fsn) {\n\t\t\t\t\tfirst_frag = pos;\n\t\t\t\t\tlast_frag = pos;\n\t\t\t\t\tnext_fsn = 0;\n\t\t\t\t\tis_last = 1;\n\t\t\t\t}\n\t\t\t} else if (cevent->fsn == next_fsn) {\n\t\t\t\tlast_frag = pos;\n\t\t\t\tnext_fsn = 0;\n\t\t\t\tis_last = 1;\n\t\t\t}\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (!first_frag)\n\t\treturn NULL;\n\n\tretval = sctp_make_reassembled_event(ulpq->asoc->base.net, &ulpq->reasm,\n\t\t\t\t\t     first_frag, last_frag);\n\tif (retval) {\n\t\tsin->fsn = next_fsn;\n\t\tif (is_last) {\n\t\t\tretval->msg_flags |= MSG_EOR;\n\t\t\tsin->pd_mode = 0;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nstatic struct sctp_ulpevent *sctp_intl_retrieve_reassembled(\n\t\t\t\t\t\tstruct sctp_ulpq *ulpq,\n\t\t\t\t\t\tstruct sctp_ulpevent *event)\n{\n\tstruct sctp_association *asoc = ulpq->asoc;\n\tstruct sk_buff *pos, *first_frag = NULL;\n\tstruct sctp_ulpevent *retval = NULL;\n\tstruct sk_buff *pd_first = NULL;\n\tstruct sk_buff *pd_last = NULL;\n\tstruct sctp_stream_in *sin;\n\t__u32 next_fsn = 0;\n\t__u32 pd_point = 0;\n\t__u32 pd_len = 0;\n\t__u32 mid = 0;\n\n\tsin = sctp_stream_in(&ulpq->asoc->stream, event->stream);\n\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tstruct sctp_ulpevent *cevent = sctp_skb2event(pos);\n\n\t\tif (cevent->stream < event->stream)\n\t\t\tcontinue;\n\t\tif (cevent->stream > event->stream)\n\t\t\tbreak;\n\n\t\tif (MID_lt(cevent->mid, event->mid))\n\t\t\tcontinue;\n\t\tif (MID_lt(event->mid, cevent->mid))\n\t\t\tbreak;\n\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_FIRST_FRAG:\n\t\t\tif (cevent->mid == sin->mid) {\n\t\t\t\tpd_first = pos;\n\t\t\t\tpd_last = pos;\n\t\t\t\tpd_len = pos->len;\n\t\t\t}\n\n\t\t\tfirst_frag = pos;\n\t\t\tnext_fsn = 0;\n\t\t\tmid = cevent->mid;\n\t\t\tbreak;\n\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif (first_frag && cevent->mid == mid &&\n\t\t\t    cevent->fsn == next_fsn) {\n\t\t\t\tnext_fsn++;\n\t\t\t\tif (pd_first) {\n\t\t\t\t\tpd_last = pos;\n\t\t\t\t\tpd_len += pos->len;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfirst_frag = NULL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (first_frag && cevent->mid == mid &&\n\t\t\t    cevent->fsn == next_fsn)\n\t\t\t\tgoto found;\n\t\t\telse\n\t\t\t\tfirst_frag = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!pd_first)\n\t\tgoto out;\n\n\tpd_point = sctp_sk(asoc->base.sk)->pd_point;\n\tif (pd_point && pd_point <= pd_len) {\n\t\tretval = sctp_make_reassembled_event(asoc->base.net,\n\t\t\t\t\t\t     &ulpq->reasm,\n\t\t\t\t\t\t     pd_first, pd_last);\n\t\tif (retval) {\n\t\t\tsin->fsn = next_fsn;\n\t\t\tsin->pd_mode = 1;\n\t\t}\n\t}\n\tgoto out;\n\nfound:\n\tretval = sctp_make_reassembled_event(asoc->base.net, &ulpq->reasm,\n\t\t\t\t\t     first_frag, pos);\n\tif (retval)\n\t\tretval->msg_flags |= MSG_EOR;\n\nout:\n\treturn retval;\n}\n\nstatic struct sctp_ulpevent *sctp_intl_reasm(struct sctp_ulpq *ulpq,\n\t\t\t\t\t     struct sctp_ulpevent *event)\n{\n\tstruct sctp_ulpevent *retval = NULL;\n\tstruct sctp_stream_in *sin;\n\n\tif (SCTP_DATA_NOT_FRAG == (event->msg_flags & SCTP_DATA_FRAG_MASK)) {\n\t\tevent->msg_flags |= MSG_EOR;\n\t\treturn event;\n\t}\n\n\tsctp_intl_store_reasm(ulpq, event);\n\n\tsin = sctp_stream_in(&ulpq->asoc->stream, event->stream);\n\tif (sin->pd_mode && event->mid == sin->mid &&\n\t    event->fsn == sin->fsn)\n\t\tretval = sctp_intl_retrieve_partial(ulpq, event);\n\n\tif (!retval)\n\t\tretval = sctp_intl_retrieve_reassembled(ulpq, event);\n\n\treturn retval;\n}\n\nstatic void sctp_intl_store_ordered(struct sctp_ulpq *ulpq,\n\t\t\t\t    struct sctp_ulpevent *event)\n{\n\tstruct sctp_ulpevent *cevent;\n\tstruct sk_buff *pos, *loc;\n\n\tpos = skb_peek_tail(&ulpq->lobby);\n\tif (!pos) {\n\t\t__skb_queue_tail(&ulpq->lobby, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\tcevent = (struct sctp_ulpevent *)pos->cb;\n\tif (event->stream == cevent->stream &&\n\t    MID_lt(cevent->mid, event->mid)) {\n\t\t__skb_queue_tail(&ulpq->lobby, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\tif (event->stream > cevent->stream) {\n\t\t__skb_queue_tail(&ulpq->lobby, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\tloc = NULL;\n\tskb_queue_walk(&ulpq->lobby, pos) {\n\t\tcevent = (struct sctp_ulpevent *)pos->cb;\n\n\t\tif (cevent->stream > event->stream) {\n\t\t\tloc = pos;\n\t\t\tbreak;\n\t\t}\n\t\tif (cevent->stream == event->stream &&\n\t\t    MID_lt(event->mid, cevent->mid)) {\n\t\t\tloc = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!loc)\n\t\t__skb_queue_tail(&ulpq->lobby, sctp_event2skb(event));\n\telse\n\t\t__skb_queue_before(&ulpq->lobby, loc, sctp_event2skb(event));\n}\n\nstatic void sctp_intl_retrieve_ordered(struct sctp_ulpq *ulpq,\n\t\t\t\t       struct sctp_ulpevent *event)\n{\n\tstruct sk_buff_head *event_list;\n\tstruct sctp_stream *stream;\n\tstruct sk_buff *pos, *tmp;\n\t__u16 sid = event->stream;\n\n\tstream  = &ulpq->asoc->stream;\n\tevent_list = (struct sk_buff_head *)sctp_event2skb(event)->prev;\n\n\tsctp_skb_for_each(pos, &ulpq->lobby, tmp) {\n\t\tstruct sctp_ulpevent *cevent = (struct sctp_ulpevent *)pos->cb;\n\n\t\tif (cevent->stream > sid)\n\t\t\tbreak;\n\n\t\tif (cevent->stream < sid)\n\t\t\tcontinue;\n\n\t\tif (cevent->mid != sctp_mid_peek(stream, in, sid))\n\t\t\tbreak;\n\n\t\tsctp_mid_next(stream, in, sid);\n\n\t\t__skb_unlink(pos, &ulpq->lobby);\n\n\t\t__skb_queue_tail(event_list, pos);\n\t}\n}\n\nstatic struct sctp_ulpevent *sctp_intl_order(struct sctp_ulpq *ulpq,\n\t\t\t\t\t     struct sctp_ulpevent *event)\n{\n\tstruct sctp_stream *stream;\n\t__u16 sid;\n\n\tstream  = &ulpq->asoc->stream;\n\tsid = event->stream;\n\n\tif (event->mid != sctp_mid_peek(stream, in, sid)) {\n\t\tsctp_intl_store_ordered(ulpq, event);\n\t\treturn NULL;\n\t}\n\n\tsctp_mid_next(stream, in, sid);\n\n\tsctp_intl_retrieve_ordered(ulpq, event);\n\n\treturn event;\n}\n\nstatic int sctp_enqueue_event(struct sctp_ulpq *ulpq,\n\t\t\t      struct sk_buff_head *skb_list)\n{\n\tstruct sock *sk = ulpq->asoc->base.sk;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct sctp_ulpevent *event;\n\tstruct sk_buff *skb;\n\n\tskb = __skb_peek(skb_list);\n\tevent = sctp_skb2event(skb);\n\n\tif (sk->sk_shutdown & RCV_SHUTDOWN &&\n\t    (sk->sk_shutdown & SEND_SHUTDOWN ||\n\t     !sctp_ulpevent_is_notification(event)))\n\t\tgoto out_free;\n\n\tif (!sctp_ulpevent_is_notification(event)) {\n\t\tsk_mark_napi_id(sk, skb);\n\t\tsk_incoming_cpu_update(sk);\n\t}\n\n\tif (!sctp_ulpevent_is_enabled(event, ulpq->asoc->subscribe))\n\t\tgoto out_free;\n\n\tskb_queue_splice_tail_init(skb_list,\n\t\t\t\t   &sk->sk_receive_queue);\n\n\tif (!sp->data_ready_signalled) {\n\t\tsp->data_ready_signalled = 1;\n\t\tsk->sk_data_ready(sk);\n\t}\n\n\treturn 1;\n\nout_free:\n\tsctp_queue_purge_ulpevents(skb_list);\n\n\treturn 0;\n}\n\nstatic void sctp_intl_store_reasm_uo(struct sctp_ulpq *ulpq,\n\t\t\t\t     struct sctp_ulpevent *event)\n{\n\tstruct sctp_ulpevent *cevent;\n\tstruct sk_buff *pos;\n\n\tpos = skb_peek_tail(&ulpq->reasm_uo);\n\tif (!pos) {\n\t\t__skb_queue_tail(&ulpq->reasm_uo, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\tcevent = sctp_skb2event(pos);\n\n\tif (event->stream == cevent->stream &&\n\t    event->mid == cevent->mid &&\n\t    (cevent->msg_flags & SCTP_DATA_FIRST_FRAG ||\n\t     (!(event->msg_flags & SCTP_DATA_FIRST_FRAG) &&\n\t      event->fsn > cevent->fsn))) {\n\t\t__skb_queue_tail(&ulpq->reasm_uo, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\tif ((event->stream == cevent->stream &&\n\t     MID_lt(cevent->mid, event->mid)) ||\n\t    event->stream > cevent->stream) {\n\t\t__skb_queue_tail(&ulpq->reasm_uo, sctp_event2skb(event));\n\t\treturn;\n\t}\n\n\tskb_queue_walk(&ulpq->reasm_uo, pos) {\n\t\tcevent = sctp_skb2event(pos);\n\n\t\tif (event->stream < cevent->stream ||\n\t\t    (event->stream == cevent->stream &&\n\t\t     MID_lt(event->mid, cevent->mid)))\n\t\t\tbreak;\n\n\t\tif (event->stream == cevent->stream &&\n\t\t    event->mid == cevent->mid &&\n\t\t    !(cevent->msg_flags & SCTP_DATA_FIRST_FRAG) &&\n\t\t    (event->msg_flags & SCTP_DATA_FIRST_FRAG ||\n\t\t     event->fsn < cevent->fsn))\n\t\t\tbreak;\n\t}\n\n\t__skb_queue_before(&ulpq->reasm_uo, pos, sctp_event2skb(event));\n}\n\nstatic struct sctp_ulpevent *sctp_intl_retrieve_partial_uo(\n\t\t\t\t\t\tstruct sctp_ulpq *ulpq,\n\t\t\t\t\t\tstruct sctp_ulpevent *event)\n{\n\tstruct sk_buff *first_frag = NULL;\n\tstruct sk_buff *last_frag = NULL;\n\tstruct sctp_ulpevent *retval;\n\tstruct sctp_stream_in *sin;\n\tstruct sk_buff *pos;\n\t__u32 next_fsn = 0;\n\tint is_last = 0;\n\n\tsin = sctp_stream_in(&ulpq->asoc->stream, event->stream);\n\n\tskb_queue_walk(&ulpq->reasm_uo, pos) {\n\t\tstruct sctp_ulpevent *cevent = sctp_skb2event(pos);\n\n\t\tif (cevent->stream < event->stream)\n\t\t\tcontinue;\n\t\tif (cevent->stream > event->stream)\n\t\t\tbreak;\n\n\t\tif (MID_lt(cevent->mid, sin->mid_uo))\n\t\t\tcontinue;\n\t\tif (MID_lt(sin->mid_uo, cevent->mid))\n\t\t\tbreak;\n\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_FIRST_FRAG:\n\t\t\tgoto out;\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif (!first_frag) {\n\t\t\t\tif (cevent->fsn == sin->fsn_uo) {\n\t\t\t\t\tfirst_frag = pos;\n\t\t\t\t\tlast_frag = pos;\n\t\t\t\t\tnext_fsn = cevent->fsn + 1;\n\t\t\t\t}\n\t\t\t} else if (cevent->fsn == next_fsn) {\n\t\t\t\tlast_frag = pos;\n\t\t\t\tnext_fsn++;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (!first_frag) {\n\t\t\t\tif (cevent->fsn == sin->fsn_uo) {\n\t\t\t\t\tfirst_frag = pos;\n\t\t\t\t\tlast_frag = pos;\n\t\t\t\t\tnext_fsn = 0;\n\t\t\t\t\tis_last = 1;\n\t\t\t\t}\n\t\t\t} else if (cevent->fsn == next_fsn) {\n\t\t\t\tlast_frag = pos;\n\t\t\t\tnext_fsn = 0;\n\t\t\t\tis_last = 1;\n\t\t\t}\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (!first_frag)\n\t\treturn NULL;\n\n\tretval = sctp_make_reassembled_event(ulpq->asoc->base.net,\n\t\t\t\t\t     &ulpq->reasm_uo, first_frag,\n\t\t\t\t\t     last_frag);\n\tif (retval) {\n\t\tsin->fsn_uo = next_fsn;\n\t\tif (is_last) {\n\t\t\tretval->msg_flags |= MSG_EOR;\n\t\t\tsin->pd_mode_uo = 0;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nstatic struct sctp_ulpevent *sctp_intl_retrieve_reassembled_uo(\n\t\t\t\t\t\tstruct sctp_ulpq *ulpq,\n\t\t\t\t\t\tstruct sctp_ulpevent *event)\n{\n\tstruct sctp_association *asoc = ulpq->asoc;\n\tstruct sk_buff *pos, *first_frag = NULL;\n\tstruct sctp_ulpevent *retval = NULL;\n\tstruct sk_buff *pd_first = NULL;\n\tstruct sk_buff *pd_last = NULL;\n\tstruct sctp_stream_in *sin;\n\t__u32 next_fsn = 0;\n\t__u32 pd_point = 0;\n\t__u32 pd_len = 0;\n\t__u32 mid = 0;\n\n\tsin = sctp_stream_in(&ulpq->asoc->stream, event->stream);\n\n\tskb_queue_walk(&ulpq->reasm_uo, pos) {\n\t\tstruct sctp_ulpevent *cevent = sctp_skb2event(pos);\n\n\t\tif (cevent->stream < event->stream)\n\t\t\tcontinue;\n\t\tif (cevent->stream > event->stream)\n\t\t\tbreak;\n\n\t\tif (MID_lt(cevent->mid, event->mid))\n\t\t\tcontinue;\n\t\tif (MID_lt(event->mid, cevent->mid))\n\t\t\tbreak;\n\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_FIRST_FRAG:\n\t\t\tif (!sin->pd_mode_uo) {\n\t\t\t\tsin->mid_uo = cevent->mid;\n\t\t\t\tpd_first = pos;\n\t\t\t\tpd_last = pos;\n\t\t\t\tpd_len = pos->len;\n\t\t\t}\n\n\t\t\tfirst_frag = pos;\n\t\t\tnext_fsn = 0;\n\t\t\tmid = cevent->mid;\n\t\t\tbreak;\n\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif (first_frag && cevent->mid == mid &&\n\t\t\t    cevent->fsn == next_fsn) {\n\t\t\t\tnext_fsn++;\n\t\t\t\tif (pd_first) {\n\t\t\t\t\tpd_last = pos;\n\t\t\t\t\tpd_len += pos->len;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfirst_frag = NULL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (first_frag && cevent->mid == mid &&\n\t\t\t    cevent->fsn == next_fsn)\n\t\t\t\tgoto found;\n\t\t\telse\n\t\t\t\tfirst_frag = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!pd_first)\n\t\tgoto out;\n\n\tpd_point = sctp_sk(asoc->base.sk)->pd_point;\n\tif (pd_point && pd_point <= pd_len) {\n\t\tretval = sctp_make_reassembled_event(asoc->base.net,\n\t\t\t\t\t\t     &ulpq->reasm_uo,\n\t\t\t\t\t\t     pd_first, pd_last);\n\t\tif (retval) {\n\t\t\tsin->fsn_uo = next_fsn;\n\t\t\tsin->pd_mode_uo = 1;\n\t\t}\n\t}\n\tgoto out;\n\nfound:\n\tretval = sctp_make_reassembled_event(asoc->base.net, &ulpq->reasm_uo,\n\t\t\t\t\t     first_frag, pos);\n\tif (retval)\n\t\tretval->msg_flags |= MSG_EOR;\n\nout:\n\treturn retval;\n}\n\nstatic struct sctp_ulpevent *sctp_intl_reasm_uo(struct sctp_ulpq *ulpq,\n\t\t\t\t\t\tstruct sctp_ulpevent *event)\n{\n\tstruct sctp_ulpevent *retval = NULL;\n\tstruct sctp_stream_in *sin;\n\n\tif (SCTP_DATA_NOT_FRAG == (event->msg_flags & SCTP_DATA_FRAG_MASK)) {\n\t\tevent->msg_flags |= MSG_EOR;\n\t\treturn event;\n\t}\n\n\tsctp_intl_store_reasm_uo(ulpq, event);\n\n\tsin = sctp_stream_in(&ulpq->asoc->stream, event->stream);\n\tif (sin->pd_mode_uo && event->mid == sin->mid_uo &&\n\t    event->fsn == sin->fsn_uo)\n\t\tretval = sctp_intl_retrieve_partial_uo(ulpq, event);\n\n\tif (!retval)\n\t\tretval = sctp_intl_retrieve_reassembled_uo(ulpq, event);\n\n\treturn retval;\n}\n\nstatic struct sctp_ulpevent *sctp_intl_retrieve_first_uo(struct sctp_ulpq *ulpq)\n{\n\tstruct sctp_stream_in *csin, *sin = NULL;\n\tstruct sk_buff *first_frag = NULL;\n\tstruct sk_buff *last_frag = NULL;\n\tstruct sctp_ulpevent *retval;\n\tstruct sk_buff *pos;\n\t__u32 next_fsn = 0;\n\t__u16 sid = 0;\n\n\tskb_queue_walk(&ulpq->reasm_uo, pos) {\n\t\tstruct sctp_ulpevent *cevent = sctp_skb2event(pos);\n\n\t\tcsin = sctp_stream_in(&ulpq->asoc->stream, cevent->stream);\n\t\tif (csin->pd_mode_uo)\n\t\t\tcontinue;\n\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_FIRST_FRAG:\n\t\t\tif (first_frag)\n\t\t\t\tgoto out;\n\t\t\tfirst_frag = pos;\n\t\t\tlast_frag = pos;\n\t\t\tnext_fsn = 0;\n\t\t\tsin = csin;\n\t\t\tsid = cevent->stream;\n\t\t\tsin->mid_uo = cevent->mid;\n\t\t\tbreak;\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif (!first_frag)\n\t\t\t\tbreak;\n\t\t\tif (cevent->stream == sid &&\n\t\t\t    cevent->mid == sin->mid_uo &&\n\t\t\t    cevent->fsn == next_fsn) {\n\t\t\t\tnext_fsn++;\n\t\t\t\tlast_frag = pos;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (first_frag)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!first_frag)\n\t\treturn NULL;\n\nout:\n\tretval = sctp_make_reassembled_event(ulpq->asoc->base.net,\n\t\t\t\t\t     &ulpq->reasm_uo, first_frag,\n\t\t\t\t\t     last_frag);\n\tif (retval) {\n\t\tsin->fsn_uo = next_fsn;\n\t\tsin->pd_mode_uo = 1;\n\t}\n\n\treturn retval;\n}\n\nstatic int sctp_ulpevent_idata(struct sctp_ulpq *ulpq,\n\t\t\t       struct sctp_chunk *chunk, gfp_t gfp)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sk_buff_head temp;\n\tint event_eor = 0;\n\n\tevent = sctp_ulpevent_make_rcvmsg(chunk->asoc, chunk, gfp);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tevent->mid = ntohl(chunk->subh.idata_hdr->mid);\n\tif (event->msg_flags & SCTP_DATA_FIRST_FRAG)\n\t\tevent->ppid = chunk->subh.idata_hdr->ppid;\n\telse\n\t\tevent->fsn = ntohl(chunk->subh.idata_hdr->fsn);\n\n\tif (!(event->msg_flags & SCTP_DATA_UNORDERED)) {\n\t\tevent = sctp_intl_reasm(ulpq, event);\n\t\tif (event) {\n\t\t\tskb_queue_head_init(&temp);\n\t\t\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\n\t\t\tif (event->msg_flags & MSG_EOR)\n\t\t\t\tevent = sctp_intl_order(ulpq, event);\n\t\t}\n\t} else {\n\t\tevent = sctp_intl_reasm_uo(ulpq, event);\n\t\tif (event) {\n\t\t\tskb_queue_head_init(&temp);\n\t\t\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\t\t}\n\t}\n\n\tif (event) {\n\t\tevent_eor = (event->msg_flags & MSG_EOR) ? 1 : 0;\n\t\tsctp_enqueue_event(ulpq, &temp);\n\t}\n\n\treturn event_eor;\n}\n\nstatic struct sctp_ulpevent *sctp_intl_retrieve_first(struct sctp_ulpq *ulpq)\n{\n\tstruct sctp_stream_in *csin, *sin = NULL;\n\tstruct sk_buff *first_frag = NULL;\n\tstruct sk_buff *last_frag = NULL;\n\tstruct sctp_ulpevent *retval;\n\tstruct sk_buff *pos;\n\t__u32 next_fsn = 0;\n\t__u16 sid = 0;\n\n\tskb_queue_walk(&ulpq->reasm, pos) {\n\t\tstruct sctp_ulpevent *cevent = sctp_skb2event(pos);\n\n\t\tcsin = sctp_stream_in(&ulpq->asoc->stream, cevent->stream);\n\t\tif (csin->pd_mode)\n\t\t\tcontinue;\n\n\t\tswitch (cevent->msg_flags & SCTP_DATA_FRAG_MASK) {\n\t\tcase SCTP_DATA_FIRST_FRAG:\n\t\t\tif (first_frag)\n\t\t\t\tgoto out;\n\t\t\tif (cevent->mid == csin->mid) {\n\t\t\t\tfirst_frag = pos;\n\t\t\t\tlast_frag = pos;\n\t\t\t\tnext_fsn = 0;\n\t\t\t\tsin = csin;\n\t\t\t\tsid = cevent->stream;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCTP_DATA_MIDDLE_FRAG:\n\t\t\tif (!first_frag)\n\t\t\t\tbreak;\n\t\t\tif (cevent->stream == sid &&\n\t\t\t    cevent->mid == sin->mid &&\n\t\t\t    cevent->fsn == next_fsn) {\n\t\t\t\tnext_fsn++;\n\t\t\t\tlast_frag = pos;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SCTP_DATA_LAST_FRAG:\n\t\t\tif (first_frag)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!first_frag)\n\t\treturn NULL;\n\nout:\n\tretval = sctp_make_reassembled_event(ulpq->asoc->base.net,\n\t\t\t\t\t     &ulpq->reasm, first_frag,\n\t\t\t\t\t     last_frag);\n\tif (retval) {\n\t\tsin->fsn = next_fsn;\n\t\tsin->pd_mode = 1;\n\t}\n\n\treturn retval;\n}\n\nstatic void sctp_intl_start_pd(struct sctp_ulpq *ulpq, gfp_t gfp)\n{\n\tstruct sctp_ulpevent *event;\n\tstruct sk_buff_head temp;\n\n\tif (!skb_queue_empty(&ulpq->reasm)) {\n\t\tdo {\n\t\t\tevent = sctp_intl_retrieve_first(ulpq);\n\t\t\tif (event) {\n\t\t\t\tskb_queue_head_init(&temp);\n\t\t\t\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\t\t\t\tsctp_enqueue_event(ulpq, &temp);\n\t\t\t}\n\t\t} while (event);\n\t}\n\n\tif (!skb_queue_empty(&ulpq->reasm_uo)) {\n\t\tdo {\n\t\t\tevent = sctp_intl_retrieve_first_uo(ulpq);\n\t\t\tif (event) {\n\t\t\t\tskb_queue_head_init(&temp);\n\t\t\t\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\t\t\t\tsctp_enqueue_event(ulpq, &temp);\n\t\t\t}\n\t\t} while (event);\n\t}\n}\n\nstatic void sctp_renege_events(struct sctp_ulpq *ulpq, struct sctp_chunk *chunk,\n\t\t\t       gfp_t gfp)\n{\n\tstruct sctp_association *asoc = ulpq->asoc;\n\t__u32 freed = 0;\n\t__u16 needed;\n\n\tneeded = ntohs(chunk->chunk_hdr->length) -\n\t\t sizeof(struct sctp_idata_chunk);\n\n\tif (skb_queue_empty(&asoc->base.sk->sk_receive_queue)) {\n\t\tfreed = sctp_ulpq_renege_list(ulpq, &ulpq->lobby, needed);\n\t\tif (freed < needed)\n\t\t\tfreed += sctp_ulpq_renege_list(ulpq, &ulpq->reasm,\n\t\t\t\t\t\t       needed);\n\t\tif (freed < needed)\n\t\t\tfreed += sctp_ulpq_renege_list(ulpq, &ulpq->reasm_uo,\n\t\t\t\t\t\t       needed);\n\t}\n\n\tif (freed >= needed && sctp_ulpevent_idata(ulpq, chunk, gfp) <= 0)\n\t\tsctp_intl_start_pd(ulpq, gfp);\n}\n\nstatic void sctp_intl_stream_abort_pd(struct sctp_ulpq *ulpq, __u16 sid,\n\t\t\t\t      __u32 mid, __u16 flags, gfp_t gfp)\n{\n\tstruct sock *sk = ulpq->asoc->base.sk;\n\tstruct sctp_ulpevent *ev = NULL;\n\n\tif (!sctp_ulpevent_type_enabled(ulpq->asoc->subscribe,\n\t\t\t\t\tSCTP_PARTIAL_DELIVERY_EVENT))\n\t\treturn;\n\n\tev = sctp_ulpevent_make_pdapi(ulpq->asoc, SCTP_PARTIAL_DELIVERY_ABORTED,\n\t\t\t\t      sid, mid, flags, gfp);\n\tif (ev) {\n\t\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\t\t__skb_queue_tail(&sk->sk_receive_queue, sctp_event2skb(ev));\n\n\t\tif (!sp->data_ready_signalled) {\n\t\t\tsp->data_ready_signalled = 1;\n\t\t\tsk->sk_data_ready(sk);\n\t\t}\n\t}\n}\n\nstatic void sctp_intl_reap_ordered(struct sctp_ulpq *ulpq, __u16 sid)\n{\n\tstruct sctp_stream *stream = &ulpq->asoc->stream;\n\tstruct sctp_ulpevent *cevent, *event = NULL;\n\tstruct sk_buff_head *lobby = &ulpq->lobby;\n\tstruct sk_buff *pos, *tmp;\n\tstruct sk_buff_head temp;\n\t__u16 csid;\n\t__u32 cmid;\n\n\tskb_queue_head_init(&temp);\n\tsctp_skb_for_each(pos, lobby, tmp) {\n\t\tcevent = (struct sctp_ulpevent *)pos->cb;\n\t\tcsid = cevent->stream;\n\t\tcmid = cevent->mid;\n\n\t\tif (csid > sid)\n\t\t\tbreak;\n\n\t\tif (csid < sid)\n\t\t\tcontinue;\n\n\t\tif (!MID_lt(cmid, sctp_mid_peek(stream, in, csid)))\n\t\t\tbreak;\n\n\t\t__skb_unlink(pos, lobby);\n\t\tif (!event)\n\t\t\tevent = sctp_skb2event(pos);\n\n\t\t__skb_queue_tail(&temp, pos);\n\t}\n\n\tif (!event && pos != (struct sk_buff *)lobby) {\n\t\tcevent = (struct sctp_ulpevent *)pos->cb;\n\t\tcsid = cevent->stream;\n\t\tcmid = cevent->mid;\n\n\t\tif (csid == sid && cmid == sctp_mid_peek(stream, in, csid)) {\n\t\t\tsctp_mid_next(stream, in, csid);\n\t\t\t__skb_unlink(pos, lobby);\n\t\t\t__skb_queue_tail(&temp, pos);\n\t\t\tevent = sctp_skb2event(pos);\n\t\t}\n\t}\n\n\tif (event) {\n\t\tsctp_intl_retrieve_ordered(ulpq, event);\n\t\tsctp_enqueue_event(ulpq, &temp);\n\t}\n}\n\nstatic void sctp_intl_abort_pd(struct sctp_ulpq *ulpq, gfp_t gfp)\n{\n\tstruct sctp_stream *stream = &ulpq->asoc->stream;\n\t__u16 sid;\n\n\tfor (sid = 0; sid < stream->incnt; sid++) {\n\t\tstruct sctp_stream_in *sin = SCTP_SI(stream, sid);\n\t\t__u32 mid;\n\n\t\tif (sin->pd_mode_uo) {\n\t\t\tsin->pd_mode_uo = 0;\n\n\t\t\tmid = sin->mid_uo;\n\t\t\tsctp_intl_stream_abort_pd(ulpq, sid, mid, 0x1, gfp);\n\t\t}\n\n\t\tif (sin->pd_mode) {\n\t\t\tsin->pd_mode = 0;\n\n\t\t\tmid = sin->mid;\n\t\t\tsctp_intl_stream_abort_pd(ulpq, sid, mid, 0, gfp);\n\t\t\tsctp_mid_skip(stream, in, sid, mid);\n\n\t\t\tsctp_intl_reap_ordered(ulpq, sid);\n\t\t}\n\t}\n\n\t \n\tsctp_ulpq_flush(ulpq);\n}\n\nstatic inline int sctp_get_skip_pos(struct sctp_ifwdtsn_skip *skiplist,\n\t\t\t\t    int nskips, __be16 stream, __u8 flags)\n{\n\tint i;\n\n\tfor (i = 0; i < nskips; i++)\n\t\tif (skiplist[i].stream == stream &&\n\t\t    skiplist[i].flags == flags)\n\t\t\treturn i;\n\n\treturn i;\n}\n\n#define SCTP_FTSN_U_BIT\t0x1\nstatic void sctp_generate_iftsn(struct sctp_outq *q, __u32 ctsn)\n{\n\tstruct sctp_ifwdtsn_skip ftsn_skip_arr[10];\n\tstruct sctp_association *asoc = q->asoc;\n\tstruct sctp_chunk *ftsn_chunk = NULL;\n\tstruct list_head *lchunk, *temp;\n\tint nskips = 0, skip_pos;\n\tstruct sctp_chunk *chunk;\n\t__u32 tsn;\n\n\tif (!asoc->peer.prsctp_capable)\n\t\treturn;\n\n\tif (TSN_lt(asoc->adv_peer_ack_point, ctsn))\n\t\tasoc->adv_peer_ack_point = ctsn;\n\n\tlist_for_each_safe(lchunk, temp, &q->abandoned) {\n\t\tchunk = list_entry(lchunk, struct sctp_chunk, transmitted_list);\n\t\ttsn = ntohl(chunk->subh.data_hdr->tsn);\n\n\t\tif (TSN_lte(tsn, ctsn)) {\n\t\t\tlist_del_init(lchunk);\n\t\t\tsctp_chunk_free(chunk);\n\t\t} else if (TSN_lte(tsn, asoc->adv_peer_ack_point + 1)) {\n\t\t\t__be16 sid = chunk->subh.idata_hdr->stream;\n\t\t\t__be32 mid = chunk->subh.idata_hdr->mid;\n\t\t\t__u8 flags = 0;\n\n\t\t\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED)\n\t\t\t\tflags |= SCTP_FTSN_U_BIT;\n\n\t\t\tasoc->adv_peer_ack_point = tsn;\n\t\t\tskip_pos = sctp_get_skip_pos(&ftsn_skip_arr[0], nskips,\n\t\t\t\t\t\t     sid, flags);\n\t\t\tftsn_skip_arr[skip_pos].stream = sid;\n\t\t\tftsn_skip_arr[skip_pos].reserved = 0;\n\t\t\tftsn_skip_arr[skip_pos].flags = flags;\n\t\t\tftsn_skip_arr[skip_pos].mid = mid;\n\t\t\tif (skip_pos == nskips)\n\t\t\t\tnskips++;\n\t\t\tif (nskips == 10)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (asoc->adv_peer_ack_point > ctsn)\n\t\tftsn_chunk = sctp_make_ifwdtsn(asoc, asoc->adv_peer_ack_point,\n\t\t\t\t\t       nskips, &ftsn_skip_arr[0]);\n\n\tif (ftsn_chunk) {\n\t\tlist_add_tail(&ftsn_chunk->list, &q->control_chunk_list);\n\t\tSCTP_INC_STATS(asoc->base.net, SCTP_MIB_OUTCTRLCHUNKS);\n\t}\n}\n\n#define _sctp_walk_ifwdtsn(pos, chunk, end) \\\n\tfor (pos = (void *)(chunk->subh.ifwdtsn_hdr + 1); \\\n\t     (void *)pos <= (void *)(chunk->subh.ifwdtsn_hdr + 1) + (end) - \\\n\t\t\t    sizeof(struct sctp_ifwdtsn_skip); pos++)\n\n#define sctp_walk_ifwdtsn(pos, ch) \\\n\t_sctp_walk_ifwdtsn((pos), (ch), ntohs((ch)->chunk_hdr->length) - \\\n\t\t\t\t\tsizeof(struct sctp_ifwdtsn_chunk))\n\nstatic bool sctp_validate_fwdtsn(struct sctp_chunk *chunk)\n{\n\tstruct sctp_fwdtsn_skip *skip;\n\t__u16 incnt;\n\n\tif (chunk->chunk_hdr->type != SCTP_CID_FWD_TSN)\n\t\treturn false;\n\n\tincnt = chunk->asoc->stream.incnt;\n\tsctp_walk_fwdtsn(skip, chunk)\n\t\tif (ntohs(skip->stream) >= incnt)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool sctp_validate_iftsn(struct sctp_chunk *chunk)\n{\n\tstruct sctp_ifwdtsn_skip *skip;\n\t__u16 incnt;\n\n\tif (chunk->chunk_hdr->type != SCTP_CID_I_FWD_TSN)\n\t\treturn false;\n\n\tincnt = chunk->asoc->stream.incnt;\n\tsctp_walk_ifwdtsn(skip, chunk)\n\t\tif (ntohs(skip->stream) >= incnt)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic void sctp_report_fwdtsn(struct sctp_ulpq *ulpq, __u32 ftsn)\n{\n\t \n\tsctp_tsnmap_skip(&ulpq->asoc->peer.tsn_map, ftsn);\n\t \n\tsctp_ulpq_reasm_flushtsn(ulpq, ftsn);\n\t \n\tsctp_ulpq_abort_pd(ulpq, GFP_ATOMIC);\n}\n\nstatic void sctp_intl_reasm_flushtsn(struct sctp_ulpq *ulpq, __u32 ftsn)\n{\n\tstruct sk_buff *pos, *tmp;\n\n\tskb_queue_walk_safe(&ulpq->reasm, pos, tmp) {\n\t\tstruct sctp_ulpevent *event = sctp_skb2event(pos);\n\t\t__u32 tsn = event->tsn;\n\n\t\tif (TSN_lte(tsn, ftsn)) {\n\t\t\t__skb_unlink(pos, &ulpq->reasm);\n\t\t\tsctp_ulpevent_free(event);\n\t\t}\n\t}\n\n\tskb_queue_walk_safe(&ulpq->reasm_uo, pos, tmp) {\n\t\tstruct sctp_ulpevent *event = sctp_skb2event(pos);\n\t\t__u32 tsn = event->tsn;\n\n\t\tif (TSN_lte(tsn, ftsn)) {\n\t\t\t__skb_unlink(pos, &ulpq->reasm_uo);\n\t\t\tsctp_ulpevent_free(event);\n\t\t}\n\t}\n}\n\nstatic void sctp_report_iftsn(struct sctp_ulpq *ulpq, __u32 ftsn)\n{\n\t \n\tsctp_tsnmap_skip(&ulpq->asoc->peer.tsn_map, ftsn);\n\t \n\tsctp_intl_reasm_flushtsn(ulpq, ftsn);\n\t \n\tif (ftsn == sctp_tsnmap_get_max_tsn_seen(&ulpq->asoc->peer.tsn_map))\n\t\tsctp_intl_abort_pd(ulpq, GFP_ATOMIC);\n}\n\nstatic void sctp_handle_fwdtsn(struct sctp_ulpq *ulpq, struct sctp_chunk *chunk)\n{\n\tstruct sctp_fwdtsn_skip *skip;\n\n\t \n\tsctp_walk_fwdtsn(skip, chunk)\n\t\tsctp_ulpq_skip(ulpq, ntohs(skip->stream), ntohs(skip->ssn));\n}\n\nstatic void sctp_intl_skip(struct sctp_ulpq *ulpq, __u16 sid, __u32 mid,\n\t\t\t   __u8 flags)\n{\n\tstruct sctp_stream_in *sin = sctp_stream_in(&ulpq->asoc->stream, sid);\n\tstruct sctp_stream *stream  = &ulpq->asoc->stream;\n\n\tif (flags & SCTP_FTSN_U_BIT) {\n\t\tif (sin->pd_mode_uo && MID_lt(sin->mid_uo, mid)) {\n\t\t\tsin->pd_mode_uo = 0;\n\t\t\tsctp_intl_stream_abort_pd(ulpq, sid, mid, 0x1,\n\t\t\t\t\t\t  GFP_ATOMIC);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (MID_lt(mid, sctp_mid_peek(stream, in, sid)))\n\t\treturn;\n\n\tif (sin->pd_mode) {\n\t\tsin->pd_mode = 0;\n\t\tsctp_intl_stream_abort_pd(ulpq, sid, mid, 0x0, GFP_ATOMIC);\n\t}\n\n\tsctp_mid_skip(stream, in, sid, mid);\n\n\tsctp_intl_reap_ordered(ulpq, sid);\n}\n\nstatic void sctp_handle_iftsn(struct sctp_ulpq *ulpq, struct sctp_chunk *chunk)\n{\n\tstruct sctp_ifwdtsn_skip *skip;\n\n\t \n\tsctp_walk_ifwdtsn(skip, chunk)\n\t\tsctp_intl_skip(ulpq, ntohs(skip->stream),\n\t\t\t       ntohl(skip->mid), skip->flags);\n}\n\nstatic int do_ulpq_tail_event(struct sctp_ulpq *ulpq, struct sctp_ulpevent *event)\n{\n\tstruct sk_buff_head temp;\n\n\tskb_queue_head_init(&temp);\n\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\treturn sctp_ulpq_tail_event(ulpq, &temp);\n}\n\nstatic struct sctp_stream_interleave sctp_stream_interleave_0 = {\n\t.data_chunk_len\t\t= sizeof(struct sctp_data_chunk),\n\t.ftsn_chunk_len\t\t= sizeof(struct sctp_fwdtsn_chunk),\n\t \n\t.make_datafrag\t\t= sctp_make_datafrag_empty,\n\t.assign_number\t\t= sctp_chunk_assign_ssn,\n\t.validate_data\t\t= sctp_validate_data,\n\t.ulpevent_data\t\t= sctp_ulpq_tail_data,\n\t.enqueue_event\t\t= do_ulpq_tail_event,\n\t.renege_events\t\t= sctp_ulpq_renege,\n\t.start_pd\t\t= sctp_ulpq_partial_delivery,\n\t.abort_pd\t\t= sctp_ulpq_abort_pd,\n\t \n\t.generate_ftsn\t\t= sctp_generate_fwdtsn,\n\t.validate_ftsn\t\t= sctp_validate_fwdtsn,\n\t.report_ftsn\t\t= sctp_report_fwdtsn,\n\t.handle_ftsn\t\t= sctp_handle_fwdtsn,\n};\n\nstatic int do_sctp_enqueue_event(struct sctp_ulpq *ulpq,\n\t\t\t\t struct sctp_ulpevent *event)\n{\n\tstruct sk_buff_head temp;\n\n\tskb_queue_head_init(&temp);\n\t__skb_queue_tail(&temp, sctp_event2skb(event));\n\treturn sctp_enqueue_event(ulpq, &temp);\n}\n\nstatic struct sctp_stream_interleave sctp_stream_interleave_1 = {\n\t.data_chunk_len\t\t= sizeof(struct sctp_idata_chunk),\n\t.ftsn_chunk_len\t\t= sizeof(struct sctp_ifwdtsn_chunk),\n\t \n\t.make_datafrag\t\t= sctp_make_idatafrag_empty,\n\t.assign_number\t\t= sctp_chunk_assign_mid,\n\t.validate_data\t\t= sctp_validate_idata,\n\t.ulpevent_data\t\t= sctp_ulpevent_idata,\n\t.enqueue_event\t\t= do_sctp_enqueue_event,\n\t.renege_events\t\t= sctp_renege_events,\n\t.start_pd\t\t= sctp_intl_start_pd,\n\t.abort_pd\t\t= sctp_intl_abort_pd,\n\t \n\t.generate_ftsn\t\t= sctp_generate_iftsn,\n\t.validate_ftsn\t\t= sctp_validate_iftsn,\n\t.report_ftsn\t\t= sctp_report_iftsn,\n\t.handle_ftsn\t\t= sctp_handle_iftsn,\n};\n\nvoid sctp_stream_interleave_init(struct sctp_stream *stream)\n{\n\tstruct sctp_association *asoc;\n\n\tasoc = container_of(stream, struct sctp_association, stream);\n\tstream->si = asoc->peer.intl_capable ? &sctp_stream_interleave_1\n\t\t\t\t\t     : &sctp_stream_interleave_0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}