{
  "module_name": "stats.c",
  "hash_id": "d2d368840e8a9342c8093c181be59b2a07ecb4c52b25fc59e87346c3ecb2c427",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/stats.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/rcupdate.h>\n\n#include <trace/events/sunrpc.h>\n\n#include \"netns.h\"\n\n#define RPCDBG_FACILITY\tRPCDBG_MISC\n\n \nstatic int rpc_proc_show(struct seq_file *seq, void *v) {\n\tconst struct rpc_stat\t*statp = seq->private;\n\tconst struct rpc_program *prog = statp->program;\n\tunsigned int i, j;\n\n\tseq_printf(seq,\n\t\t\"net %u %u %u %u\\n\",\n\t\t\tstatp->netcnt,\n\t\t\tstatp->netudpcnt,\n\t\t\tstatp->nettcpcnt,\n\t\t\tstatp->nettcpconn);\n\tseq_printf(seq,\n\t\t\"rpc %u %u %u\\n\",\n\t\t\tstatp->rpccnt,\n\t\t\tstatp->rpcretrans,\n\t\t\tstatp->rpcauthrefresh);\n\n\tfor (i = 0; i < prog->nrvers; i++) {\n\t\tconst struct rpc_version *vers = prog->version[i];\n\t\tif (!vers)\n\t\t\tcontinue;\n\t\tseq_printf(seq, \"proc%u %u\",\n\t\t\t\t\tvers->number, vers->nrprocs);\n\t\tfor (j = 0; j < vers->nrprocs; j++)\n\t\t\tseq_printf(seq, \" %u\", vers->counts[j]);\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn 0;\n}\n\nstatic int rpc_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, rpc_proc_show, pde_data(inode));\n}\n\nstatic const struct proc_ops rpc_proc_ops = {\n\t.proc_open\t= rpc_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n};\n\n \nvoid svc_seq_show(struct seq_file *seq, const struct svc_stat *statp)\n{\n\tconst struct svc_program *prog = statp->program;\n\tconst struct svc_version *vers;\n\tunsigned int i, j, k;\n\tunsigned long count;\n\n\tseq_printf(seq,\n\t\t\"net %u %u %u %u\\n\",\n\t\t\tstatp->netcnt,\n\t\t\tstatp->netudpcnt,\n\t\t\tstatp->nettcpcnt,\n\t\t\tstatp->nettcpconn);\n\tseq_printf(seq,\n\t\t\"rpc %u %u %u %u %u\\n\",\n\t\t\tstatp->rpccnt,\n\t\t\tstatp->rpcbadfmt+statp->rpcbadauth+statp->rpcbadclnt,\n\t\t\tstatp->rpcbadfmt,\n\t\t\tstatp->rpcbadauth,\n\t\t\tstatp->rpcbadclnt);\n\n\tfor (i = 0; i < prog->pg_nvers; i++) {\n\t\tvers = prog->pg_vers[i];\n\t\tif (!vers)\n\t\t\tcontinue;\n\t\tseq_printf(seq, \"proc%d %u\", i, vers->vs_nproc);\n\t\tfor (j = 0; j < vers->vs_nproc; j++) {\n\t\t\tcount = 0;\n\t\t\tfor_each_possible_cpu(k)\n\t\t\t\tcount += per_cpu(vers->vs_count[j], k);\n\t\t\tseq_printf(seq, \" %lu\", count);\n\t\t}\n\t\tseq_putc(seq, '\\n');\n\t}\n}\nEXPORT_SYMBOL_GPL(svc_seq_show);\n\n \nstruct rpc_iostats *rpc_alloc_iostats(struct rpc_clnt *clnt)\n{\n\tstruct rpc_iostats *stats;\n\tint i;\n\n\tstats = kcalloc(clnt->cl_maxproc, sizeof(*stats), GFP_KERNEL);\n\tif (stats) {\n\t\tfor (i = 0; i < clnt->cl_maxproc; i++)\n\t\t\tspin_lock_init(&stats[i].om_lock);\n\t}\n\treturn stats;\n}\nEXPORT_SYMBOL_GPL(rpc_alloc_iostats);\n\n \nvoid rpc_free_iostats(struct rpc_iostats *stats)\n{\n\tkfree(stats);\n}\nEXPORT_SYMBOL_GPL(rpc_free_iostats);\n\n \nvoid rpc_count_iostats_metrics(const struct rpc_task *task,\n\t\t\t       struct rpc_iostats *op_metrics)\n{\n\tstruct rpc_rqst *req = task->tk_rqstp;\n\tktime_t backlog, execute, now;\n\n\tif (!op_metrics || !req)\n\t\treturn;\n\n\tnow = ktime_get();\n\tspin_lock(&op_metrics->om_lock);\n\n\top_metrics->om_ops++;\n\t \n\top_metrics->om_ntrans += max(req->rq_ntrans, 1);\n\top_metrics->om_timeouts += task->tk_timeouts;\n\n\top_metrics->om_bytes_sent += req->rq_xmit_bytes_sent;\n\top_metrics->om_bytes_recv += req->rq_reply_bytes_recvd;\n\n\tbacklog = 0;\n\tif (ktime_to_ns(req->rq_xtime)) {\n\t\tbacklog = ktime_sub(req->rq_xtime, task->tk_start);\n\t\top_metrics->om_queue = ktime_add(op_metrics->om_queue, backlog);\n\t}\n\n\top_metrics->om_rtt = ktime_add(op_metrics->om_rtt, req->rq_rtt);\n\n\texecute = ktime_sub(now, task->tk_start);\n\top_metrics->om_execute = ktime_add(op_metrics->om_execute, execute);\n\tif (task->tk_status < 0)\n\t\top_metrics->om_error_status++;\n\n\tspin_unlock(&op_metrics->om_lock);\n\n\ttrace_rpc_stats_latency(req->rq_task, backlog, req->rq_rtt, execute);\n}\nEXPORT_SYMBOL_GPL(rpc_count_iostats_metrics);\n\n \nvoid rpc_count_iostats(const struct rpc_task *task, struct rpc_iostats *stats)\n{\n\trpc_count_iostats_metrics(task,\n\t\t\t\t  &stats[task->tk_msg.rpc_proc->p_statidx]);\n}\nEXPORT_SYMBOL_GPL(rpc_count_iostats);\n\nstatic void _print_name(struct seq_file *seq, unsigned int op,\n\t\t\tconst struct rpc_procinfo *procs)\n{\n\tif (procs[op].p_name)\n\t\tseq_printf(seq, \"\\t%12s: \", procs[op].p_name);\n\telse if (op == 0)\n\t\tseq_printf(seq, \"\\t        NULL: \");\n\telse\n\t\tseq_printf(seq, \"\\t%12u: \", op);\n}\n\nstatic void _add_rpc_iostats(struct rpc_iostats *a, struct rpc_iostats *b)\n{\n\ta->om_ops += b->om_ops;\n\ta->om_ntrans += b->om_ntrans;\n\ta->om_timeouts += b->om_timeouts;\n\ta->om_bytes_sent += b->om_bytes_sent;\n\ta->om_bytes_recv += b->om_bytes_recv;\n\ta->om_queue = ktime_add(a->om_queue, b->om_queue);\n\ta->om_rtt = ktime_add(a->om_rtt, b->om_rtt);\n\ta->om_execute = ktime_add(a->om_execute, b->om_execute);\n\ta->om_error_status += b->om_error_status;\n}\n\nstatic void _print_rpc_iostats(struct seq_file *seq, struct rpc_iostats *stats,\n\t\t\t       int op, const struct rpc_procinfo *procs)\n{\n\t_print_name(seq, op, procs);\n\tseq_printf(seq, \"%lu %lu %lu %llu %llu %llu %llu %llu %lu\\n\",\n\t\t   stats->om_ops,\n\t\t   stats->om_ntrans,\n\t\t   stats->om_timeouts,\n\t\t   stats->om_bytes_sent,\n\t\t   stats->om_bytes_recv,\n\t\t   ktime_to_ms(stats->om_queue),\n\t\t   ktime_to_ms(stats->om_rtt),\n\t\t   ktime_to_ms(stats->om_execute),\n\t\t   stats->om_error_status);\n}\n\nstatic int do_print_stats(struct rpc_clnt *clnt, struct rpc_xprt *xprt, void *seqv)\n{\n\tstruct seq_file *seq = seqv;\n\n\txprt->ops->print_stats(xprt, seq);\n\treturn 0;\n}\n\nvoid rpc_clnt_show_stats(struct seq_file *seq, struct rpc_clnt *clnt)\n{\n\tunsigned int op, maxproc = clnt->cl_maxproc;\n\n\tif (!clnt->cl_metrics)\n\t\treturn;\n\n\tseq_printf(seq, \"\\tRPC iostats version: %s  \", RPC_IOSTATS_VERS);\n\tseq_printf(seq, \"p/v: %u/%u (%s)\\n\",\n\t\t\tclnt->cl_prog, clnt->cl_vers, clnt->cl_program->name);\n\n\trpc_clnt_iterate_for_each_xprt(clnt, do_print_stats, seq);\n\n\tseq_printf(seq, \"\\tper-op statistics\\n\");\n\tfor (op = 0; op < maxproc; op++) {\n\t\tstruct rpc_iostats stats = {};\n\t\tstruct rpc_clnt *next = clnt;\n\t\tdo {\n\t\t\t_add_rpc_iostats(&stats, &next->cl_metrics[op]);\n\t\t\tif (next == next->cl_parent)\n\t\t\t\tbreak;\n\t\t\tnext = next->cl_parent;\n\t\t} while (next);\n\t\t_print_rpc_iostats(seq, &stats, op, clnt->cl_procinfo);\n\t}\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_show_stats);\n\n \nstatic inline struct proc_dir_entry *\ndo_register(struct net *net, const char *name, void *data,\n\t    const struct proc_ops *proc_ops)\n{\n\tstruct sunrpc_net *sn;\n\n\tdprintk(\"RPC:       registering /proc/net/rpc/%s\\n\", name);\n\tsn = net_generic(net, sunrpc_net_id);\n\treturn proc_create_data(name, 0, sn->proc_net_rpc, proc_ops, data);\n}\n\nstruct proc_dir_entry *\nrpc_proc_register(struct net *net, struct rpc_stat *statp)\n{\n\treturn do_register(net, statp->program->name, statp, &rpc_proc_ops);\n}\nEXPORT_SYMBOL_GPL(rpc_proc_register);\n\nvoid\nrpc_proc_unregister(struct net *net, const char *name)\n{\n\tstruct sunrpc_net *sn;\n\n\tsn = net_generic(net, sunrpc_net_id);\n\tremove_proc_entry(name, sn->proc_net_rpc);\n}\nEXPORT_SYMBOL_GPL(rpc_proc_unregister);\n\nstruct proc_dir_entry *\nsvc_proc_register(struct net *net, struct svc_stat *statp, const struct proc_ops *proc_ops)\n{\n\treturn do_register(net, statp->program->pg_name, statp, proc_ops);\n}\nEXPORT_SYMBOL_GPL(svc_proc_register);\n\nvoid\nsvc_proc_unregister(struct net *net, const char *name)\n{\n\tstruct sunrpc_net *sn;\n\n\tsn = net_generic(net, sunrpc_net_id);\n\tremove_proc_entry(name, sn->proc_net_rpc);\n}\nEXPORT_SYMBOL_GPL(svc_proc_unregister);\n\nint rpc_proc_init(struct net *net)\n{\n\tstruct sunrpc_net *sn;\n\n\tdprintk(\"RPC:       registering /proc/net/rpc\\n\");\n\tsn = net_generic(net, sunrpc_net_id);\n\tsn->proc_net_rpc = proc_mkdir(\"rpc\", net->proc_net);\n\tif (sn->proc_net_rpc == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid rpc_proc_exit(struct net *net)\n{\n\tdprintk(\"RPC:       unregistering /proc/net/rpc\\n\");\n\tremove_proc_entry(\"rpc\", net->proc_net);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}