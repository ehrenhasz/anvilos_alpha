{
  "module_name": "auth_tls.c",
  "hash_id": "00d3f3a89c0818ea0b8adefc496a84e4c68feec3f185903aa2c8c137160150c9",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth_tls.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic const char *starttls_token = \"STARTTLS\";\nstatic const size_t starttls_len = 8;\n\nstatic struct rpc_auth tls_auth;\nstatic struct rpc_cred tls_cred;\n\nstatic void tls_encode_probe(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t     const void *obj)\n{\n}\n\nstatic int tls_decode_probe(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t    void *obj)\n{\n\treturn 0;\n}\n\nstatic const struct rpc_procinfo rpcproc_tls_probe = {\n\t.p_encode\t= tls_encode_probe,\n\t.p_decode\t= tls_decode_probe,\n};\n\nstatic void rpc_tls_probe_call_prepare(struct rpc_task *task, void *data)\n{\n\ttask->tk_flags &= ~RPC_TASK_NO_RETRANS_TIMEOUT;\n\trpc_call_start(task);\n}\n\nstatic void rpc_tls_probe_call_done(struct rpc_task *task, void *data)\n{\n}\n\nstatic const struct rpc_call_ops rpc_tls_probe_ops = {\n\t.rpc_call_prepare\t= rpc_tls_probe_call_prepare,\n\t.rpc_call_done\t\t= rpc_tls_probe_call_done,\n};\n\nstatic int tls_probe(struct rpc_clnt *clnt)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &rpcproc_tls_probe,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client\t= clnt,\n\t\t.rpc_message\t= &msg,\n\t\t.rpc_op_cred\t= &tls_cred,\n\t\t.callback_ops\t= &rpc_tls_probe_ops,\n\t\t.flags\t\t= RPC_TASK_SOFT | RPC_TASK_SOFTCONN,\n\t};\n\tstruct rpc_task\t*task;\n\tint status;\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = task->tk_status;\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic struct rpc_auth *tls_create(const struct rpc_auth_create_args *args,\n\t\t\t\t   struct rpc_clnt *clnt)\n{\n\trefcount_inc(&tls_auth.au_count);\n\treturn &tls_auth;\n}\n\nstatic void tls_destroy(struct rpc_auth *auth)\n{\n}\n\nstatic struct rpc_cred *tls_lookup_cred(struct rpc_auth *auth,\n\t\t\t\t\tstruct auth_cred *acred, int flags)\n{\n\treturn get_rpccred(&tls_cred);\n}\n\nstatic void tls_destroy_cred(struct rpc_cred *cred)\n{\n}\n\nstatic int tls_match(struct auth_cred *acred, struct rpc_cred *cred, int taskflags)\n{\n\treturn 1;\n}\n\nstatic int tls_marshal(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 * XDR_UNIT);\n\tif (!p)\n\t\treturn -EMSGSIZE;\n\t \n\t*p++ = rpc_auth_tls;\n\t*p++ = xdr_zero;\n\t \n\t*p++ = rpc_auth_null;\n\t*p   = xdr_zero;\n\treturn 0;\n}\n\nstatic int tls_refresh(struct rpc_task *task)\n{\n\tset_bit(RPCAUTH_CRED_UPTODATE, &task->tk_rqstp->rq_cred->cr_flags);\n\treturn 0;\n}\n\nstatic int tls_validate(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\tvoid *str;\n\n\tp = xdr_inline_decode(xdr, XDR_UNIT);\n\tif (!p)\n\t\treturn -EIO;\n\tif (*p != rpc_auth_null)\n\t\treturn -EIO;\n\tif (xdr_stream_decode_opaque_inline(xdr, &str, starttls_len) != starttls_len)\n\t\treturn -EPROTONOSUPPORT;\n\tif (memcmp(str, starttls_token, starttls_len))\n\t\treturn -EPROTONOSUPPORT;\n\treturn 0;\n}\n\nconst struct rpc_authops authtls_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.au_flavor\t= RPC_AUTH_TLS,\n\t.au_name\t= \"NULL\",\n\t.create\t\t= tls_create,\n\t.destroy\t= tls_destroy,\n\t.lookup_cred\t= tls_lookup_cred,\n\t.ping\t\t= tls_probe,\n};\n\nstatic struct rpc_auth tls_auth = {\n\t.au_cslack\t= NUL_CALLSLACK,\n\t.au_rslack\t= NUL_REPLYSLACK,\n\t.au_verfsize\t= NUL_REPLYSLACK,\n\t.au_ralign\t= NUL_REPLYSLACK,\n\t.au_ops\t\t= &authtls_ops,\n\t.au_flavor\t= RPC_AUTH_TLS,\n\t.au_count\t= REFCOUNT_INIT(1),\n};\n\nstatic const struct rpc_credops tls_credops = {\n\t.cr_name\t= \"AUTH_TLS\",\n\t.crdestroy\t= tls_destroy_cred,\n\t.crmatch\t= tls_match,\n\t.crmarshal\t= tls_marshal,\n\t.crwrap_req\t= rpcauth_wrap_req_encode,\n\t.crrefresh\t= tls_refresh,\n\t.crvalidate\t= tls_validate,\n\t.crunwrap_resp\t= rpcauth_unwrap_resp_decode,\n};\n\nstatic struct rpc_cred tls_cred = {\n\t.cr_lru\t\t= LIST_HEAD_INIT(tls_cred.cr_lru),\n\t.cr_auth\t= &tls_auth,\n\t.cr_ops\t\t= &tls_credops,\n\t.cr_count\t= REFCOUNT_INIT(2),\n\t.cr_flags\t= 1UL << RPCAUTH_CRED_UPTODATE,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}