{
  "module_name": "xprtsock.c",
  "hash_id": "5ba4dd724aed9d8b94b564bb3d10d7d7aa675fed8ccd96a348221196f70a7eea",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/xprtsock.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/mm.h>\n#include <linux/un.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/file.h>\n#ifdef CONFIG_SUNRPC_BACKCHANNEL\n#include <linux/sunrpc/bc_xprt.h>\n#endif\n\n#include <net/sock.h>\n#include <net/checksum.h>\n#include <net/udp.h>\n#include <net/tcp.h>\n#include <net/tls_prot.h>\n#include <net/handshake.h>\n\n#include <linux/bvec.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/sched/mm.h>\n\n#include <trace/events/sock.h>\n#include <trace/events/sunrpc.h>\n\n#include \"socklib.h\"\n#include \"sunrpc.h\"\n\nstatic void xs_close(struct rpc_xprt *xprt);\nstatic void xs_set_srcport(struct sock_xprt *transport, struct socket *sock);\nstatic void xs_tcp_set_socket_timeouts(struct rpc_xprt *xprt,\n\t\tstruct socket *sock);\n\n \nstatic unsigned int xprt_udp_slot_table_entries = RPC_DEF_SLOT_TABLE;\nstatic unsigned int xprt_tcp_slot_table_entries = RPC_MIN_SLOT_TABLE;\nstatic unsigned int xprt_max_tcp_slot_table_entries = RPC_MAX_SLOT_TABLE;\n\nstatic unsigned int xprt_min_resvport = RPC_DEF_MIN_RESVPORT;\nstatic unsigned int xprt_max_resvport = RPC_DEF_MAX_RESVPORT;\n\n#define XS_TCP_LINGER_TO\t(15U * HZ)\nstatic unsigned int xs_tcp_fin_timeout __read_mostly = XS_TCP_LINGER_TO;\n\n \n\nstatic unsigned int min_slot_table_size = RPC_MIN_SLOT_TABLE;\nstatic unsigned int max_slot_table_size = RPC_MAX_SLOT_TABLE;\nstatic unsigned int max_tcp_slot_table_limit = RPC_MAX_SLOT_TABLE_LIMIT;\nstatic unsigned int xprt_min_resvport_limit = RPC_MIN_RESVPORT;\nstatic unsigned int xprt_max_resvport_limit = RPC_MAX_RESVPORT;\n\nstatic struct ctl_table_header *sunrpc_table_header;\n\nstatic struct xprt_class xs_local_transport;\nstatic struct xprt_class xs_udp_transport;\nstatic struct xprt_class xs_tcp_transport;\nstatic struct xprt_class xs_tcp_tls_transport;\nstatic struct xprt_class xs_bc_tcp_transport;\n\n \nstatic struct ctl_table xs_tunables_table[] = {\n\t{\n\t\t.procname\t= \"udp_slot_table_entries\",\n\t\t.data\t\t= &xprt_udp_slot_table_entries,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_slot_table_size,\n\t\t.extra2\t\t= &max_slot_table_size\n\t},\n\t{\n\t\t.procname\t= \"tcp_slot_table_entries\",\n\t\t.data\t\t= &xprt_tcp_slot_table_entries,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_slot_table_size,\n\t\t.extra2\t\t= &max_slot_table_size\n\t},\n\t{\n\t\t.procname\t= \"tcp_max_slot_table_entries\",\n\t\t.data\t\t= &xprt_max_tcp_slot_table_entries,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_slot_table_size,\n\t\t.extra2\t\t= &max_tcp_slot_table_limit\n\t},\n\t{\n\t\t.procname\t= \"min_resvport\",\n\t\t.data\t\t= &xprt_min_resvport,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &xprt_min_resvport_limit,\n\t\t.extra2\t\t= &xprt_max_resvport_limit\n\t},\n\t{\n\t\t.procname\t= \"max_resvport\",\n\t\t.data\t\t= &xprt_max_resvport,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &xprt_min_resvport_limit,\n\t\t.extra2\t\t= &xprt_max_resvport_limit\n\t},\n\t{\n\t\t.procname\t= \"tcp_fin_timeout\",\n\t\t.data\t\t= &xs_tcp_fin_timeout,\n\t\t.maxlen\t\t= sizeof(xs_tcp_fin_timeout),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{ },\n};\n\n \n#define XS_BIND_TO\t\t(60U * HZ)\n\n \n#define XS_UDP_REEST_TO\t\t(2U * HZ)\n\n \n#define XS_TCP_INIT_REEST_TO\t(3U * HZ)\n\n \n#define XS_IDLE_DISC_TO\t\t(5U * 60 * HZ)\n\n \n#define XS_TLS_HANDSHAKE_TO\t(10U * HZ)\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n# undef  RPC_DEBUG_DATA\n# define RPCDBG_FACILITY\tRPCDBG_TRANS\n#endif\n\n#ifdef RPC_DEBUG_DATA\nstatic void xs_pktdump(char *msg, u32 *packet, unsigned int count)\n{\n\tu8 *buf = (u8 *) packet;\n\tint j;\n\n\tdprintk(\"RPC:       %s\\n\", msg);\n\tfor (j = 0; j < count && j < 128; j += 4) {\n\t\tif (!(j & 31)) {\n\t\t\tif (j)\n\t\t\t\tdprintk(\"\\n\");\n\t\t\tdprintk(\"0x%04x \", j);\n\t\t}\n\t\tdprintk(\"%02x%02x%02x%02x \",\n\t\t\tbuf[j], buf[j+1], buf[j+2], buf[j+3]);\n\t}\n\tdprintk(\"\\n\");\n}\n#else\nstatic inline void xs_pktdump(char *msg, u32 *packet, unsigned int count)\n{\n\t \n}\n#endif\n\nstatic inline struct rpc_xprt *xprt_from_sock(struct sock *sk)\n{\n\treturn (struct rpc_xprt *) sk->sk_user_data;\n}\n\nstatic inline struct sockaddr *xs_addr(struct rpc_xprt *xprt)\n{\n\treturn (struct sockaddr *) &xprt->addr;\n}\n\nstatic inline struct sockaddr_un *xs_addr_un(struct rpc_xprt *xprt)\n{\n\treturn (struct sockaddr_un *) &xprt->addr;\n}\n\nstatic inline struct sockaddr_in *xs_addr_in(struct rpc_xprt *xprt)\n{\n\treturn (struct sockaddr_in *) &xprt->addr;\n}\n\nstatic inline struct sockaddr_in6 *xs_addr_in6(struct rpc_xprt *xprt)\n{\n\treturn (struct sockaddr_in6 *) &xprt->addr;\n}\n\nstatic void xs_format_common_peer_addresses(struct rpc_xprt *xprt)\n{\n\tstruct sockaddr *sap = xs_addr(xprt);\n\tstruct sockaddr_in6 *sin6;\n\tstruct sockaddr_in *sin;\n\tstruct sockaddr_un *sun;\n\tchar buf[128];\n\n\tswitch (sap->sa_family) {\n\tcase AF_LOCAL:\n\t\tsun = xs_addr_un(xprt);\n\t\tif (sun->sun_path[0]) {\n\t\t\tstrscpy(buf, sun->sun_path, sizeof(buf));\n\t\t} else {\n\t\t\tbuf[0] = '@';\n\t\t\tstrscpy(buf+1, sun->sun_path+1, sizeof(buf)-1);\n\t\t}\n\t\txprt->address_strings[RPC_DISPLAY_ADDR] =\n\t\t\t\t\t\tkstrdup(buf, GFP_KERNEL);\n\t\tbreak;\n\tcase AF_INET:\n\t\t(void)rpc_ntop(sap, buf, sizeof(buf));\n\t\txprt->address_strings[RPC_DISPLAY_ADDR] =\n\t\t\t\t\t\tkstrdup(buf, GFP_KERNEL);\n\t\tsin = xs_addr_in(xprt);\n\t\tsnprintf(buf, sizeof(buf), \"%08x\", ntohl(sin->sin_addr.s_addr));\n\t\tbreak;\n\tcase AF_INET6:\n\t\t(void)rpc_ntop(sap, buf, sizeof(buf));\n\t\txprt->address_strings[RPC_DISPLAY_ADDR] =\n\t\t\t\t\t\tkstrdup(buf, GFP_KERNEL);\n\t\tsin6 = xs_addr_in6(xprt);\n\t\tsnprintf(buf, sizeof(buf), \"%pi6\", &sin6->sin6_addr);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\txprt->address_strings[RPC_DISPLAY_HEX_ADDR] = kstrdup(buf, GFP_KERNEL);\n}\n\nstatic void xs_format_common_peer_ports(struct rpc_xprt *xprt)\n{\n\tstruct sockaddr *sap = xs_addr(xprt);\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"%u\", rpc_get_port(sap));\n\txprt->address_strings[RPC_DISPLAY_PORT] = kstrdup(buf, GFP_KERNEL);\n\n\tsnprintf(buf, sizeof(buf), \"%4hx\", rpc_get_port(sap));\n\txprt->address_strings[RPC_DISPLAY_HEX_PORT] = kstrdup(buf, GFP_KERNEL);\n}\n\nstatic void xs_format_peer_addresses(struct rpc_xprt *xprt,\n\t\t\t\t     const char *protocol,\n\t\t\t\t     const char *netid)\n{\n\txprt->address_strings[RPC_DISPLAY_PROTO] = protocol;\n\txprt->address_strings[RPC_DISPLAY_NETID] = netid;\n\txs_format_common_peer_addresses(xprt);\n\txs_format_common_peer_ports(xprt);\n}\n\nstatic void xs_update_peer_port(struct rpc_xprt *xprt)\n{\n\tkfree(xprt->address_strings[RPC_DISPLAY_HEX_PORT]);\n\tkfree(xprt->address_strings[RPC_DISPLAY_PORT]);\n\n\txs_format_common_peer_ports(xprt);\n}\n\nstatic void xs_free_peer_addresses(struct rpc_xprt *xprt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < RPC_DISPLAY_MAX; i++)\n\t\tswitch (i) {\n\t\tcase RPC_DISPLAY_PROTO:\n\t\tcase RPC_DISPLAY_NETID:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tkfree(xprt->address_strings[i]);\n\t\t}\n}\n\nstatic size_t\nxs_alloc_sparse_pages(struct xdr_buf *buf, size_t want, gfp_t gfp)\n{\n\tsize_t i,n;\n\n\tif (!want || !(buf->flags & XDRBUF_SPARSE_PAGES))\n\t\treturn want;\n\tn = (buf->page_base + want + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tfor (i = 0; i < n; i++) {\n\t\tif (buf->pages[i])\n\t\t\tcontinue;\n\t\tbuf->bvec[i].bv_page = buf->pages[i] = alloc_page(gfp);\n\t\tif (!buf->pages[i]) {\n\t\t\ti *= PAGE_SIZE;\n\t\t\treturn i > buf->page_base ? i - buf->page_base : 0;\n\t\t}\n\t}\n\treturn want;\n}\n\nstatic int\nxs_sock_process_cmsg(struct socket *sock, struct msghdr *msg,\n\t\t     struct cmsghdr *cmsg, int ret)\n{\n\tu8 content_type = tls_get_record_type(sock->sk, cmsg);\n\tu8 level, description;\n\n\tswitch (content_type) {\n\tcase 0:\n\t\tbreak;\n\tcase TLS_RECORD_TYPE_DATA:\n\t\t \n\t\tmsg->msg_flags &= ~MSG_EOR;\n\t\tbreak;\n\tcase TLS_RECORD_TYPE_ALERT:\n\t\ttls_alert_recv(sock->sk, msg, &level, &description);\n\t\tret = (level == TLS_ALERT_LEVEL_FATAL) ?\n\t\t\t-EACCES : -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret = -EAGAIN;\n\t}\n\treturn ret;\n}\n\nstatic int\nxs_sock_recv_cmsg(struct socket *sock, struct msghdr *msg, int flags)\n{\n\tunion {\n\t\tstruct cmsghdr\tcmsg;\n\t\tu8\t\tbuf[CMSG_SPACE(sizeof(u8))];\n\t} u;\n\tint ret;\n\n\tmsg->msg_control = &u;\n\tmsg->msg_controllen = sizeof(u);\n\tret = sock_recvmsg(sock, msg, flags);\n\tif (msg->msg_controllen != sizeof(u))\n\t\tret = xs_sock_process_cmsg(sock, msg, &u.cmsg, ret);\n\treturn ret;\n}\n\nstatic ssize_t\nxs_sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags, size_t seek)\n{\n\tssize_t ret;\n\tif (seek != 0)\n\t\tiov_iter_advance(&msg->msg_iter, seek);\n\tret = xs_sock_recv_cmsg(sock, msg, flags);\n\treturn ret > 0 ? ret + seek : ret;\n}\n\nstatic ssize_t\nxs_read_kvec(struct socket *sock, struct msghdr *msg, int flags,\n\t\tstruct kvec *kvec, size_t count, size_t seek)\n{\n\tiov_iter_kvec(&msg->msg_iter, ITER_DEST, kvec, 1, count);\n\treturn xs_sock_recvmsg(sock, msg, flags, seek);\n}\n\nstatic ssize_t\nxs_read_bvec(struct socket *sock, struct msghdr *msg, int flags,\n\t\tstruct bio_vec *bvec, unsigned long nr, size_t count,\n\t\tsize_t seek)\n{\n\tiov_iter_bvec(&msg->msg_iter, ITER_DEST, bvec, nr, count);\n\treturn xs_sock_recvmsg(sock, msg, flags, seek);\n}\n\nstatic ssize_t\nxs_read_discard(struct socket *sock, struct msghdr *msg, int flags,\n\t\tsize_t count)\n{\n\tiov_iter_discard(&msg->msg_iter, ITER_DEST, count);\n\treturn xs_sock_recv_cmsg(sock, msg, flags);\n}\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE\nstatic void\nxs_flush_bvec(const struct bio_vec *bvec, size_t count, size_t seek)\n{\n\tstruct bvec_iter bi = {\n\t\t.bi_size = count,\n\t};\n\tstruct bio_vec bv;\n\n\tbvec_iter_advance(bvec, &bi, seek & PAGE_MASK);\n\tfor_each_bvec(bv, bvec, bi, bi)\n\t\tflush_dcache_page(bv.bv_page);\n}\n#else\nstatic inline void\nxs_flush_bvec(const struct bio_vec *bvec, size_t count, size_t seek)\n{\n}\n#endif\n\nstatic ssize_t\nxs_read_xdr_buf(struct socket *sock, struct msghdr *msg, int flags,\n\t\tstruct xdr_buf *buf, size_t count, size_t seek, size_t *read)\n{\n\tsize_t want, seek_init = seek, offset = 0;\n\tssize_t ret;\n\n\twant = min_t(size_t, count, buf->head[0].iov_len);\n\tif (seek < want) {\n\t\tret = xs_read_kvec(sock, msg, flags, &buf->head[0], want, seek);\n\t\tif (ret <= 0)\n\t\t\tgoto sock_err;\n\t\toffset += ret;\n\t\tif (offset == count || msg->msg_flags & (MSG_EOR|MSG_TRUNC))\n\t\t\tgoto out;\n\t\tif (ret != want)\n\t\t\tgoto out;\n\t\tseek = 0;\n\t} else {\n\t\tseek -= want;\n\t\toffset += want;\n\t}\n\n\twant = xs_alloc_sparse_pages(\n\t\tbuf, min_t(size_t, count - offset, buf->page_len),\n\t\tGFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tif (seek < want) {\n\t\tret = xs_read_bvec(sock, msg, flags, buf->bvec,\n\t\t\t\txdr_buf_pagecount(buf),\n\t\t\t\twant + buf->page_base,\n\t\t\t\tseek + buf->page_base);\n\t\tif (ret <= 0)\n\t\t\tgoto sock_err;\n\t\txs_flush_bvec(buf->bvec, ret, seek + buf->page_base);\n\t\tret -= buf->page_base;\n\t\toffset += ret;\n\t\tif (offset == count || msg->msg_flags & (MSG_EOR|MSG_TRUNC))\n\t\t\tgoto out;\n\t\tif (ret != want)\n\t\t\tgoto out;\n\t\tseek = 0;\n\t} else {\n\t\tseek -= want;\n\t\toffset += want;\n\t}\n\n\twant = min_t(size_t, count - offset, buf->tail[0].iov_len);\n\tif (seek < want) {\n\t\tret = xs_read_kvec(sock, msg, flags, &buf->tail[0], want, seek);\n\t\tif (ret <= 0)\n\t\t\tgoto sock_err;\n\t\toffset += ret;\n\t\tif (offset == count || msg->msg_flags & (MSG_EOR|MSG_TRUNC))\n\t\t\tgoto out;\n\t\tif (ret != want)\n\t\t\tgoto out;\n\t} else if (offset < seek_init)\n\t\toffset = seek_init;\n\tret = -EMSGSIZE;\nout:\n\t*read = offset - seek_init;\n\treturn ret;\nsock_err:\n\toffset += seek;\n\tgoto out;\n}\n\nstatic void\nxs_read_header(struct sock_xprt *transport, struct xdr_buf *buf)\n{\n\tif (!transport->recv.copied) {\n\t\tif (buf->head[0].iov_len >= transport->recv.offset)\n\t\t\tmemcpy(buf->head[0].iov_base,\n\t\t\t\t\t&transport->recv.xid,\n\t\t\t\t\ttransport->recv.offset);\n\t\ttransport->recv.copied = transport->recv.offset;\n\t}\n}\n\nstatic bool\nxs_read_stream_request_done(struct sock_xprt *transport)\n{\n\treturn transport->recv.fraghdr & cpu_to_be32(RPC_LAST_STREAM_FRAGMENT);\n}\n\nstatic void\nxs_read_stream_check_eor(struct sock_xprt *transport,\n\t\tstruct msghdr *msg)\n{\n\tif (xs_read_stream_request_done(transport))\n\t\tmsg->msg_flags |= MSG_EOR;\n}\n\nstatic ssize_t\nxs_read_stream_request(struct sock_xprt *transport, struct msghdr *msg,\n\t\tint flags, struct rpc_rqst *req)\n{\n\tstruct xdr_buf *buf = &req->rq_private_buf;\n\tsize_t want, read;\n\tssize_t ret;\n\n\txs_read_header(transport, buf);\n\n\twant = transport->recv.len - transport->recv.offset;\n\tif (want != 0) {\n\t\tret = xs_read_xdr_buf(transport->sock, msg, flags, buf,\n\t\t\t\ttransport->recv.copied + want,\n\t\t\t\ttransport->recv.copied,\n\t\t\t\t&read);\n\t\ttransport->recv.offset += read;\n\t\ttransport->recv.copied += read;\n\t}\n\n\tif (transport->recv.offset == transport->recv.len)\n\t\txs_read_stream_check_eor(transport, msg);\n\n\tif (want == 0)\n\t\treturn 0;\n\n\tswitch (ret) {\n\tdefault:\n\t\tbreak;\n\tcase -EFAULT:\n\tcase -EMSGSIZE:\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\treturn read;\n\tcase 0:\n\t\treturn -ESHUTDOWN;\n\t}\n\treturn ret < 0 ? ret : read;\n}\n\nstatic size_t\nxs_read_stream_headersize(bool isfrag)\n{\n\tif (isfrag)\n\t\treturn sizeof(__be32);\n\treturn 3 * sizeof(__be32);\n}\n\nstatic ssize_t\nxs_read_stream_header(struct sock_xprt *transport, struct msghdr *msg,\n\t\tint flags, size_t want, size_t seek)\n{\n\tstruct kvec kvec = {\n\t\t.iov_base = &transport->recv.fraghdr,\n\t\t.iov_len = want,\n\t};\n\treturn xs_read_kvec(transport->sock, msg, flags, &kvec, want, seek);\n}\n\n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\nstatic ssize_t\nxs_read_stream_call(struct sock_xprt *transport, struct msghdr *msg, int flags)\n{\n\tstruct rpc_xprt *xprt = &transport->xprt;\n\tstruct rpc_rqst *req;\n\tssize_t ret;\n\n\t \n\tif (!xprt->bc_serv)\n\t\treturn -ESHUTDOWN;\n\n\t \n\treq = xprt_lookup_bc_request(xprt, transport->recv.xid);\n\tif (!req) {\n\t\tprintk(KERN_WARNING \"Callback slot table overflowed\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\tif (transport->recv.copied && !req->rq_private_buf.len)\n\t\treturn -ESHUTDOWN;\n\n\tret = xs_read_stream_request(transport, msg, flags, req);\n\tif (msg->msg_flags & (MSG_EOR|MSG_TRUNC))\n\t\txprt_complete_bc_request(req, transport->recv.copied);\n\telse\n\t\treq->rq_private_buf.len = transport->recv.copied;\n\n\treturn ret;\n}\n#else  \nstatic ssize_t\nxs_read_stream_call(struct sock_xprt *transport, struct msghdr *msg, int flags)\n{\n\treturn -ESHUTDOWN;\n}\n#endif  \n\nstatic ssize_t\nxs_read_stream_reply(struct sock_xprt *transport, struct msghdr *msg, int flags)\n{\n\tstruct rpc_xprt *xprt = &transport->xprt;\n\tstruct rpc_rqst *req;\n\tssize_t ret = 0;\n\n\t \n\tspin_lock(&xprt->queue_lock);\n\treq = xprt_lookup_rqst(xprt, transport->recv.xid);\n\tif (!req || (transport->recv.copied && !req->rq_private_buf.len)) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tgoto out;\n\t}\n\txprt_pin_rqst(req);\n\tspin_unlock(&xprt->queue_lock);\n\n\tret = xs_read_stream_request(transport, msg, flags, req);\n\n\tspin_lock(&xprt->queue_lock);\n\tif (msg->msg_flags & (MSG_EOR|MSG_TRUNC))\n\t\txprt_complete_rqst(req->rq_task, transport->recv.copied);\n\telse\n\t\treq->rq_private_buf.len = transport->recv.copied;\n\txprt_unpin_rqst(req);\nout:\n\tspin_unlock(&xprt->queue_lock);\n\treturn ret;\n}\n\nstatic ssize_t\nxs_read_stream(struct sock_xprt *transport, int flags)\n{\n\tstruct msghdr msg = { 0 };\n\tsize_t want, read = 0;\n\tssize_t ret = 0;\n\n\tif (transport->recv.len == 0) {\n\t\twant = xs_read_stream_headersize(transport->recv.copied != 0);\n\t\tret = xs_read_stream_header(transport, &msg, flags, want,\n\t\t\t\ttransport->recv.offset);\n\t\tif (ret <= 0)\n\t\t\tgoto out_err;\n\t\ttransport->recv.offset = ret;\n\t\tif (transport->recv.offset != want)\n\t\t\treturn transport->recv.offset;\n\t\ttransport->recv.len = be32_to_cpu(transport->recv.fraghdr) &\n\t\t\tRPC_FRAGMENT_SIZE_MASK;\n\t\ttransport->recv.offset -= sizeof(transport->recv.fraghdr);\n\t\tread = ret;\n\t}\n\n\tswitch (be32_to_cpu(transport->recv.calldir)) {\n\tdefault:\n\t\tmsg.msg_flags |= MSG_TRUNC;\n\t\tbreak;\n\tcase RPC_CALL:\n\t\tret = xs_read_stream_call(transport, &msg, flags);\n\t\tbreak;\n\tcase RPC_REPLY:\n\t\tret = xs_read_stream_reply(transport, &msg, flags);\n\t}\n\tif (msg.msg_flags & MSG_TRUNC) {\n\t\ttransport->recv.calldir = cpu_to_be32(-1);\n\t\ttransport->recv.copied = -1;\n\t}\n\tif (ret < 0)\n\t\tgoto out_err;\n\tread += ret;\n\tif (transport->recv.offset < transport->recv.len) {\n\t\tif (!(msg.msg_flags & MSG_TRUNC))\n\t\t\treturn read;\n\t\tmsg.msg_flags = 0;\n\t\tret = xs_read_discard(transport->sock, &msg, flags,\n\t\t\t\ttransport->recv.len - transport->recv.offset);\n\t\tif (ret <= 0)\n\t\t\tgoto out_err;\n\t\ttransport->recv.offset += ret;\n\t\tread += ret;\n\t\tif (transport->recv.offset != transport->recv.len)\n\t\t\treturn read;\n\t}\n\tif (xs_read_stream_request_done(transport)) {\n\t\ttrace_xs_stream_read_request(transport);\n\t\ttransport->recv.copied = 0;\n\t}\n\ttransport->recv.offset = 0;\n\ttransport->recv.len = 0;\n\treturn read;\nout_err:\n\treturn ret != 0 ? ret : -ESHUTDOWN;\n}\n\nstatic __poll_t xs_poll_socket(struct sock_xprt *transport)\n{\n\treturn transport->sock->ops->poll(transport->file, transport->sock,\n\t\t\tNULL);\n}\n\nstatic bool xs_poll_socket_readable(struct sock_xprt *transport)\n{\n\t__poll_t events = xs_poll_socket(transport);\n\n\treturn (events & (EPOLLIN | EPOLLRDNORM)) && !(events & EPOLLRDHUP);\n}\n\nstatic void xs_poll_check_readable(struct sock_xprt *transport)\n{\n\n\tclear_bit(XPRT_SOCK_DATA_READY, &transport->sock_state);\n\tif (test_bit(XPRT_SOCK_IGNORE_RECV, &transport->sock_state))\n\t\treturn;\n\tif (!xs_poll_socket_readable(transport))\n\t\treturn;\n\tif (!test_and_set_bit(XPRT_SOCK_DATA_READY, &transport->sock_state))\n\t\tqueue_work(xprtiod_workqueue, &transport->recv_worker);\n}\n\nstatic void xs_stream_data_receive(struct sock_xprt *transport)\n{\n\tsize_t read = 0;\n\tssize_t ret = 0;\n\n\tmutex_lock(&transport->recv_mutex);\n\tif (transport->sock == NULL)\n\t\tgoto out;\n\tfor (;;) {\n\t\tret = xs_read_stream(transport, MSG_DONTWAIT);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tread += ret;\n\t\tcond_resched();\n\t}\n\tif (ret == -ESHUTDOWN)\n\t\tkernel_sock_shutdown(transport->sock, SHUT_RDWR);\n\telse if (ret == -EACCES)\n\t\txprt_wake_pending_tasks(&transport->xprt, -EACCES);\n\telse\n\t\txs_poll_check_readable(transport);\nout:\n\tmutex_unlock(&transport->recv_mutex);\n\ttrace_xs_stream_read_data(&transport->xprt, ret, read);\n}\n\nstatic void xs_stream_data_receive_workfn(struct work_struct *work)\n{\n\tstruct sock_xprt *transport =\n\t\tcontainer_of(work, struct sock_xprt, recv_worker);\n\tunsigned int pflags = memalloc_nofs_save();\n\n\txs_stream_data_receive(transport);\n\tmemalloc_nofs_restore(pflags);\n}\n\nstatic void\nxs_stream_reset_connect(struct sock_xprt *transport)\n{\n\ttransport->recv.offset = 0;\n\ttransport->recv.len = 0;\n\ttransport->recv.copied = 0;\n\ttransport->xmit.offset = 0;\n}\n\nstatic void\nxs_stream_start_connect(struct sock_xprt *transport)\n{\n\ttransport->xprt.stat.connect_count++;\n\ttransport->xprt.stat.connect_start = jiffies;\n}\n\n#define XS_SENDMSG_FLAGS\t(MSG_DONTWAIT | MSG_NOSIGNAL)\n\n \nstatic int xs_nospace(struct rpc_rqst *req, struct sock_xprt *transport)\n{\n\tstruct rpc_xprt *xprt = &transport->xprt;\n\tstruct sock *sk = transport->inet;\n\tint ret = -EAGAIN;\n\n\ttrace_rpc_socket_nospace(req, transport);\n\n\t \n\tspin_lock(&xprt->transport_lock);\n\n\t \n\tif (xprt_connected(xprt)) {\n\t\t \n\t\tset_bit(XPRT_SOCK_NOSPACE, &transport->sock_state);\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\tsk->sk_write_pending++;\n\t\txprt_wait_for_buffer_space(xprt);\n\t} else\n\t\tret = -ENOTCONN;\n\n\tspin_unlock(&xprt->transport_lock);\n\treturn ret;\n}\n\nstatic int xs_sock_nospace(struct rpc_rqst *req)\n{\n\tstruct sock_xprt *transport =\n\t\tcontainer_of(req->rq_xprt, struct sock_xprt, xprt);\n\tstruct sock *sk = transport->inet;\n\tint ret = -EAGAIN;\n\n\tlock_sock(sk);\n\tif (!sock_writeable(sk))\n\t\tret = xs_nospace(req, transport);\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int xs_stream_nospace(struct rpc_rqst *req, bool vm_wait)\n{\n\tstruct sock_xprt *transport =\n\t\tcontainer_of(req->rq_xprt, struct sock_xprt, xprt);\n\tstruct sock *sk = transport->inet;\n\tint ret = -EAGAIN;\n\n\tif (vm_wait)\n\t\treturn -ENOBUFS;\n\tlock_sock(sk);\n\tif (!sk_stream_memory_free(sk))\n\t\tret = xs_nospace(req, transport);\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int xs_stream_prepare_request(struct rpc_rqst *req, struct xdr_buf *buf)\n{\n\treturn xdr_alloc_bvec(buf, rpc_task_gfp_mask());\n}\n\n \nstatic bool\nxs_send_request_was_aborted(struct sock_xprt *transport, struct rpc_rqst *req)\n{\n\treturn transport->xmit.offset != 0 && req->rq_bytes_sent == 0;\n}\n\n \nstatic rpc_fraghdr\nxs_stream_record_marker(struct xdr_buf *xdr)\n{\n\tif (!xdr->len)\n\t\treturn 0;\n\treturn cpu_to_be32(RPC_LAST_STREAM_FRAGMENT | (u32)xdr->len);\n}\n\n \nstatic int xs_local_send_request(struct rpc_rqst *req)\n{\n\tstruct rpc_xprt *xprt = req->rq_xprt;\n\tstruct sock_xprt *transport =\n\t\t\t\tcontainer_of(xprt, struct sock_xprt, xprt);\n\tstruct xdr_buf *xdr = &req->rq_snd_buf;\n\trpc_fraghdr rm = xs_stream_record_marker(xdr);\n\tunsigned int msglen = rm ? req->rq_slen + sizeof(rm) : req->rq_slen;\n\tstruct msghdr msg = {\n\t\t.msg_flags\t= XS_SENDMSG_FLAGS,\n\t};\n\tbool vm_wait;\n\tunsigned int sent;\n\tint status;\n\n\t \n\tif (xs_send_request_was_aborted(transport, req)) {\n\t\txprt_force_disconnect(xprt);\n\t\treturn -ENOTCONN;\n\t}\n\n\txs_pktdump(\"packet data:\",\n\t\t\treq->rq_svec->iov_base, req->rq_svec->iov_len);\n\n\tvm_wait = sk_stream_is_writeable(transport->inet) ? true : false;\n\n\treq->rq_xtime = ktime_get();\n\tstatus = xprt_sock_sendmsg(transport->sock, &msg, xdr,\n\t\t\t\t   transport->xmit.offset, rm, &sent);\n\tdprintk(\"RPC:       %s(%u) = %d\\n\",\n\t\t\t__func__, xdr->len - transport->xmit.offset, status);\n\n\tif (likely(sent > 0) || status == 0) {\n\t\ttransport->xmit.offset += sent;\n\t\treq->rq_bytes_sent = transport->xmit.offset;\n\t\tif (likely(req->rq_bytes_sent >= msglen)) {\n\t\t\treq->rq_xmit_bytes_sent += transport->xmit.offset;\n\t\t\ttransport->xmit.offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tstatus = -EAGAIN;\n\t\tvm_wait = false;\n\t}\n\n\tswitch (status) {\n\tcase -EAGAIN:\n\t\tstatus = xs_stream_nospace(req, vm_wait);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"RPC:       sendmsg returned unrecognized error %d\\n\",\n\t\t\t-status);\n\t\tfallthrough;\n\tcase -EPIPE:\n\t\txprt_force_disconnect(xprt);\n\t\tstatus = -ENOTCONN;\n\t}\n\n\treturn status;\n}\n\n \nstatic int xs_udp_send_request(struct rpc_rqst *req)\n{\n\tstruct rpc_xprt *xprt = req->rq_xprt;\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\tstruct xdr_buf *xdr = &req->rq_snd_buf;\n\tstruct msghdr msg = {\n\t\t.msg_name\t= xs_addr(xprt),\n\t\t.msg_namelen\t= xprt->addrlen,\n\t\t.msg_flags\t= XS_SENDMSG_FLAGS,\n\t};\n\tunsigned int sent;\n\tint status;\n\n\txs_pktdump(\"packet data:\",\n\t\t\t\treq->rq_svec->iov_base,\n\t\t\t\treq->rq_svec->iov_len);\n\n\tif (!xprt_bound(xprt))\n\t\treturn -ENOTCONN;\n\n\tif (!xprt_request_get_cong(xprt, req))\n\t\treturn -EBADSLT;\n\n\tstatus = xdr_alloc_bvec(xdr, rpc_task_gfp_mask());\n\tif (status < 0)\n\t\treturn status;\n\treq->rq_xtime = ktime_get();\n\tstatus = xprt_sock_sendmsg(transport->sock, &msg, xdr, 0, 0, &sent);\n\n\tdprintk(\"RPC:       xs_udp_send_request(%u) = %d\\n\",\n\t\t\txdr->len, status);\n\n\t \n\tif (status == -EPERM)\n\t\tgoto process_status;\n\n\tif (status == -EAGAIN && sock_writeable(transport->inet))\n\t\tstatus = -ENOBUFS;\n\n\tif (sent > 0 || status == 0) {\n\t\treq->rq_xmit_bytes_sent += sent;\n\t\tif (sent >= req->rq_slen)\n\t\t\treturn 0;\n\t\t \n\t\tstatus = -EAGAIN;\n\t}\n\nprocess_status:\n\tswitch (status) {\n\tcase -ENOTSOCK:\n\t\tstatus = -ENOTCONN;\n\t\t \n\t\tbreak;\n\tcase -EAGAIN:\n\t\tstatus = xs_sock_nospace(req);\n\t\tbreak;\n\tcase -ENETUNREACH:\n\tcase -ENOBUFS:\n\tcase -EPIPE:\n\tcase -ECONNREFUSED:\n\tcase -EPERM:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"RPC:       sendmsg returned unrecognized error %d\\n\",\n\t\t\t-status);\n\t}\n\n\treturn status;\n}\n\n \nstatic int xs_tcp_send_request(struct rpc_rqst *req)\n{\n\tstruct rpc_xprt *xprt = req->rq_xprt;\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\tstruct xdr_buf *xdr = &req->rq_snd_buf;\n\trpc_fraghdr rm = xs_stream_record_marker(xdr);\n\tunsigned int msglen = rm ? req->rq_slen + sizeof(rm) : req->rq_slen;\n\tstruct msghdr msg = {\n\t\t.msg_flags\t= XS_SENDMSG_FLAGS,\n\t};\n\tbool vm_wait;\n\tunsigned int sent;\n\tint status;\n\n\t \n\tif (xs_send_request_was_aborted(transport, req)) {\n\t\tif (transport->sock != NULL)\n\t\t\tkernel_sock_shutdown(transport->sock, SHUT_RDWR);\n\t\treturn -ENOTCONN;\n\t}\n\tif (!transport->inet)\n\t\treturn -ENOTCONN;\n\n\txs_pktdump(\"packet data:\",\n\t\t\t\treq->rq_svec->iov_base,\n\t\t\t\treq->rq_svec->iov_len);\n\n\tif (test_bit(XPRT_SOCK_UPD_TIMEOUT, &transport->sock_state))\n\t\txs_tcp_set_socket_timeouts(xprt, transport->sock);\n\n\txs_set_srcport(transport, transport->sock);\n\n\t \n\treq->rq_xtime = ktime_get();\n\ttcp_sock_set_cork(transport->inet, true);\n\n\tvm_wait = sk_stream_is_writeable(transport->inet) ? true : false;\n\n\tdo {\n\t\tstatus = xprt_sock_sendmsg(transport->sock, &msg, xdr,\n\t\t\t\t\t   transport->xmit.offset, rm, &sent);\n\n\t\tdprintk(\"RPC:       xs_tcp_send_request(%u) = %d\\n\",\n\t\t\t\txdr->len - transport->xmit.offset, status);\n\n\t\t \n\t\ttransport->xmit.offset += sent;\n\t\treq->rq_bytes_sent = transport->xmit.offset;\n\t\tif (likely(req->rq_bytes_sent >= msglen)) {\n\t\t\treq->rq_xmit_bytes_sent += transport->xmit.offset;\n\t\t\ttransport->xmit.offset = 0;\n\t\t\tif (atomic_long_read(&xprt->xmit_queuelen) == 1)\n\t\t\t\ttcp_sock_set_cork(transport->inet, false);\n\t\t\treturn 0;\n\t\t}\n\n\t\tWARN_ON_ONCE(sent == 0 && status == 0);\n\n\t\tif (sent > 0)\n\t\t\tvm_wait = false;\n\n\t} while (status == 0);\n\n\tswitch (status) {\n\tcase -ENOTSOCK:\n\t\tstatus = -ENOTCONN;\n\t\t \n\t\tbreak;\n\tcase -EAGAIN:\n\t\tstatus = xs_stream_nospace(req, vm_wait);\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ECONNREFUSED:\n\tcase -ENOTCONN:\n\tcase -EADDRINUSE:\n\tcase -ENOBUFS:\n\tcase -EPIPE:\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"RPC:       sendmsg returned unrecognized error %d\\n\",\n\t\t\t-status);\n\t}\n\n\treturn status;\n}\n\nstatic void xs_save_old_callbacks(struct sock_xprt *transport, struct sock *sk)\n{\n\ttransport->old_data_ready = sk->sk_data_ready;\n\ttransport->old_state_change = sk->sk_state_change;\n\ttransport->old_write_space = sk->sk_write_space;\n\ttransport->old_error_report = sk->sk_error_report;\n}\n\nstatic void xs_restore_old_callbacks(struct sock_xprt *transport, struct sock *sk)\n{\n\tsk->sk_data_ready = transport->old_data_ready;\n\tsk->sk_state_change = transport->old_state_change;\n\tsk->sk_write_space = transport->old_write_space;\n\tsk->sk_error_report = transport->old_error_report;\n}\n\nstatic void xs_sock_reset_state_flags(struct rpc_xprt *xprt)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\n\tclear_bit(XPRT_SOCK_DATA_READY, &transport->sock_state);\n\tclear_bit(XPRT_SOCK_WAKE_ERROR, &transport->sock_state);\n\tclear_bit(XPRT_SOCK_WAKE_WRITE, &transport->sock_state);\n\tclear_bit(XPRT_SOCK_WAKE_DISCONNECT, &transport->sock_state);\n\tclear_bit(XPRT_SOCK_NOSPACE, &transport->sock_state);\n}\n\nstatic void xs_run_error_worker(struct sock_xprt *transport, unsigned int nr)\n{\n\tset_bit(nr, &transport->sock_state);\n\tqueue_work(xprtiod_workqueue, &transport->error_worker);\n}\n\nstatic void xs_sock_reset_connection_flags(struct rpc_xprt *xprt)\n{\n\txprt->connect_cookie++;\n\tsmp_mb__before_atomic();\n\tclear_bit(XPRT_CLOSE_WAIT, &xprt->state);\n\tclear_bit(XPRT_CLOSING, &xprt->state);\n\txs_sock_reset_state_flags(xprt);\n\tsmp_mb__after_atomic();\n}\n\n \nstatic void xs_error_report(struct sock *sk)\n{\n\tstruct sock_xprt *transport;\n\tstruct rpc_xprt *xprt;\n\n\tif (!(xprt = xprt_from_sock(sk)))\n\t\treturn;\n\n\ttransport = container_of(xprt, struct sock_xprt, xprt);\n\ttransport->xprt_err = -sk->sk_err;\n\tif (transport->xprt_err == 0)\n\t\treturn;\n\tdprintk(\"RPC:       xs_error_report client %p, error=%d...\\n\",\n\t\t\txprt, -transport->xprt_err);\n\ttrace_rpc_socket_error(xprt, sk->sk_socket, transport->xprt_err);\n\n\t \n\tsmp_mb__before_atomic();\n\txs_run_error_worker(transport, XPRT_SOCK_WAKE_ERROR);\n}\n\nstatic void xs_reset_transport(struct sock_xprt *transport)\n{\n\tstruct socket *sock = transport->sock;\n\tstruct sock *sk = transport->inet;\n\tstruct rpc_xprt *xprt = &transport->xprt;\n\tstruct file *filp = transport->file;\n\n\tif (sk == NULL)\n\t\treturn;\n\t \n\tif (!(current->flags & PF_WQ_WORKER)) {\n\t\tWARN_ON_ONCE(1);\n\t\tset_bit(XPRT_CLOSE_WAIT, &xprt->state);\n\t\treturn;\n\t}\n\n\tif (atomic_read(&transport->xprt.swapper))\n\t\tsk_clear_memalloc(sk);\n\n\ttls_handshake_cancel(sk);\n\n\tkernel_sock_shutdown(sock, SHUT_RDWR);\n\n\tmutex_lock(&transport->recv_mutex);\n\tlock_sock(sk);\n\ttransport->inet = NULL;\n\ttransport->sock = NULL;\n\ttransport->file = NULL;\n\n\tsk->sk_user_data = NULL;\n\n\txs_restore_old_callbacks(transport, sk);\n\txprt_clear_connected(xprt);\n\txs_sock_reset_connection_flags(xprt);\n\t \n\txs_stream_reset_connect(transport);\n\trelease_sock(sk);\n\tmutex_unlock(&transport->recv_mutex);\n\n\ttrace_rpc_socket_close(xprt, sock);\n\t__fput_sync(filp);\n\n\txprt_disconnect_done(xprt);\n}\n\n \nstatic void xs_close(struct rpc_xprt *xprt)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\n\tdprintk(\"RPC:       xs_close xprt %p\\n\", xprt);\n\n\tif (transport->sock)\n\t\ttls_handshake_close(transport->sock);\n\txs_reset_transport(transport);\n\txprt->reestablish_timeout = 0;\n}\n\nstatic void xs_inject_disconnect(struct rpc_xprt *xprt)\n{\n\tdprintk(\"RPC:       injecting transport disconnect on xprt=%p\\n\",\n\t\txprt);\n\txprt_disconnect_done(xprt);\n}\n\nstatic void xs_xprt_free(struct rpc_xprt *xprt)\n{\n\txs_free_peer_addresses(xprt);\n\txprt_free(xprt);\n}\n\n \nstatic void xs_destroy(struct rpc_xprt *xprt)\n{\n\tstruct sock_xprt *transport = container_of(xprt,\n\t\t\tstruct sock_xprt, xprt);\n\tdprintk(\"RPC:       xs_destroy xprt %p\\n\", xprt);\n\n\tcancel_delayed_work_sync(&transport->connect_worker);\n\txs_close(xprt);\n\tcancel_work_sync(&transport->recv_worker);\n\tcancel_work_sync(&transport->error_worker);\n\txs_xprt_free(xprt);\n\tmodule_put(THIS_MODULE);\n}\n\n \nstatic void xs_udp_data_read_skb(struct rpc_xprt *xprt,\n\t\tstruct sock *sk,\n\t\tstruct sk_buff *skb)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_rqst *rovr;\n\tint repsize, copied;\n\tu32 _xid;\n\t__be32 *xp;\n\n\trepsize = skb->len;\n\tif (repsize < 4) {\n\t\tdprintk(\"RPC:       impossible RPC reply size %d!\\n\", repsize);\n\t\treturn;\n\t}\n\n\t \n\txp = skb_header_pointer(skb, 0, sizeof(_xid), &_xid);\n\tif (xp == NULL)\n\t\treturn;\n\n\t \n\tspin_lock(&xprt->queue_lock);\n\trovr = xprt_lookup_rqst(xprt, *xp);\n\tif (!rovr)\n\t\tgoto out_unlock;\n\txprt_pin_rqst(rovr);\n\txprt_update_rtt(rovr->rq_task);\n\tspin_unlock(&xprt->queue_lock);\n\ttask = rovr->rq_task;\n\n\tif ((copied = rovr->rq_private_buf.buflen) > repsize)\n\t\tcopied = repsize;\n\n\t \n\tif (csum_partial_copy_to_xdr(&rovr->rq_private_buf, skb)) {\n\t\tspin_lock(&xprt->queue_lock);\n\t\t__UDPX_INC_STATS(sk, UDP_MIB_INERRORS);\n\t\tgoto out_unpin;\n\t}\n\n\n\tspin_lock(&xprt->transport_lock);\n\txprt_adjust_cwnd(xprt, task, copied);\n\tspin_unlock(&xprt->transport_lock);\n\tspin_lock(&xprt->queue_lock);\n\txprt_complete_rqst(task, copied);\n\t__UDPX_INC_STATS(sk, UDP_MIB_INDATAGRAMS);\nout_unpin:\n\txprt_unpin_rqst(rovr);\n out_unlock:\n\tspin_unlock(&xprt->queue_lock);\n}\n\nstatic void xs_udp_data_receive(struct sock_xprt *transport)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tint err;\n\n\tmutex_lock(&transport->recv_mutex);\n\tsk = transport->inet;\n\tif (sk == NULL)\n\t\tgoto out;\n\tfor (;;) {\n\t\tskb = skb_recv_udp(sk, MSG_DONTWAIT, &err);\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\t\txs_udp_data_read_skb(&transport->xprt, sk, skb);\n\t\tconsume_skb(skb);\n\t\tcond_resched();\n\t}\n\txs_poll_check_readable(transport);\nout:\n\tmutex_unlock(&transport->recv_mutex);\n}\n\nstatic void xs_udp_data_receive_workfn(struct work_struct *work)\n{\n\tstruct sock_xprt *transport =\n\t\tcontainer_of(work, struct sock_xprt, recv_worker);\n\tunsigned int pflags = memalloc_nofs_save();\n\n\txs_udp_data_receive(transport);\n\tmemalloc_nofs_restore(pflags);\n}\n\n \nstatic void xs_data_ready(struct sock *sk)\n{\n\tstruct rpc_xprt *xprt;\n\n\ttrace_sk_data_ready(sk);\n\n\txprt = xprt_from_sock(sk);\n\tif (xprt != NULL) {\n\t\tstruct sock_xprt *transport = container_of(xprt,\n\t\t\t\tstruct sock_xprt, xprt);\n\n\t\ttrace_xs_data_ready(xprt);\n\n\t\ttransport->old_data_ready(sk);\n\n\t\tif (test_bit(XPRT_SOCK_IGNORE_RECV, &transport->sock_state))\n\t\t\treturn;\n\n\t\t \n\t\tif (xprt->reestablish_timeout)\n\t\t\txprt->reestablish_timeout = 0;\n\t\tif (!test_and_set_bit(XPRT_SOCK_DATA_READY, &transport->sock_state))\n\t\t\tqueue_work(xprtiod_workqueue, &transport->recv_worker);\n\t}\n}\n\n \nstatic void xs_tcp_force_close(struct rpc_xprt *xprt)\n{\n\txprt_force_disconnect(xprt);\n}\n\n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\nstatic size_t xs_tcp_bc_maxpayload(struct rpc_xprt *xprt)\n{\n\treturn PAGE_SIZE;\n}\n#endif  \n\n \nstatic void xs_local_state_change(struct sock *sk)\n{\n\tstruct rpc_xprt *xprt;\n\tstruct sock_xprt *transport;\n\n\tif (!(xprt = xprt_from_sock(sk)))\n\t\treturn;\n\ttransport = container_of(xprt, struct sock_xprt, xprt);\n\tif (sk->sk_shutdown & SHUTDOWN_MASK) {\n\t\tclear_bit(XPRT_CONNECTED, &xprt->state);\n\t\t \n\t\txs_run_error_worker(transport, XPRT_SOCK_WAKE_DISCONNECT);\n\t}\n}\n\n \nstatic void xs_tcp_state_change(struct sock *sk)\n{\n\tstruct rpc_xprt *xprt;\n\tstruct sock_xprt *transport;\n\n\tif (!(xprt = xprt_from_sock(sk)))\n\t\treturn;\n\tdprintk(\"RPC:       xs_tcp_state_change client %p...\\n\", xprt);\n\tdprintk(\"RPC:       state %x conn %d dead %d zapped %d sk_shutdown %d\\n\",\n\t\t\tsk->sk_state, xprt_connected(xprt),\n\t\t\tsock_flag(sk, SOCK_DEAD),\n\t\t\tsock_flag(sk, SOCK_ZAPPED),\n\t\t\tsk->sk_shutdown);\n\n\ttransport = container_of(xprt, struct sock_xprt, xprt);\n\ttrace_rpc_socket_state_change(xprt, sk->sk_socket);\n\tswitch (sk->sk_state) {\n\tcase TCP_ESTABLISHED:\n\t\tif (!xprt_test_and_set_connected(xprt)) {\n\t\t\txprt->connect_cookie++;\n\t\t\tclear_bit(XPRT_SOCK_CONNECTING, &transport->sock_state);\n\t\t\txprt_clear_connecting(xprt);\n\n\t\t\txprt->stat.connect_count++;\n\t\t\txprt->stat.connect_time += (long)jiffies -\n\t\t\t\t\t\t   xprt->stat.connect_start;\n\t\t\txs_run_error_worker(transport, XPRT_SOCK_WAKE_PENDING);\n\t\t}\n\t\tbreak;\n\tcase TCP_FIN_WAIT1:\n\t\t \n\t\txprt->connect_cookie++;\n\t\txprt->reestablish_timeout = 0;\n\t\tset_bit(XPRT_CLOSING, &xprt->state);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(XPRT_CONNECTED, &xprt->state);\n\t\tclear_bit(XPRT_CLOSE_WAIT, &xprt->state);\n\t\tsmp_mb__after_atomic();\n\t\tbreak;\n\tcase TCP_CLOSE_WAIT:\n\t\t \n\t\txprt->connect_cookie++;\n\t\tclear_bit(XPRT_CONNECTED, &xprt->state);\n\t\txs_run_error_worker(transport, XPRT_SOCK_WAKE_DISCONNECT);\n\t\tfallthrough;\n\tcase TCP_CLOSING:\n\t\t \n\t\tif (xprt->reestablish_timeout < XS_TCP_INIT_REEST_TO)\n\t\t\txprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;\n\t\tbreak;\n\tcase TCP_LAST_ACK:\n\t\tset_bit(XPRT_CLOSING, &xprt->state);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(XPRT_CONNECTED, &xprt->state);\n\t\tsmp_mb__after_atomic();\n\t\tbreak;\n\tcase TCP_CLOSE:\n\t\tif (test_and_clear_bit(XPRT_SOCK_CONNECTING,\n\t\t\t\t\t&transport->sock_state))\n\t\t\txprt_clear_connecting(xprt);\n\t\tclear_bit(XPRT_CLOSING, &xprt->state);\n\t\t \n\t\txs_run_error_worker(transport, XPRT_SOCK_WAKE_DISCONNECT);\n\t}\n}\n\nstatic void xs_write_space(struct sock *sk)\n{\n\tstruct sock_xprt *transport;\n\tstruct rpc_xprt *xprt;\n\n\tif (!sk->sk_socket)\n\t\treturn;\n\tclear_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\n\tif (unlikely(!(xprt = xprt_from_sock(sk))))\n\t\treturn;\n\ttransport = container_of(xprt, struct sock_xprt, xprt);\n\tif (!test_and_clear_bit(XPRT_SOCK_NOSPACE, &transport->sock_state))\n\t\treturn;\n\txs_run_error_worker(transport, XPRT_SOCK_WAKE_WRITE);\n\tsk->sk_write_pending--;\n}\n\n \nstatic void xs_udp_write_space(struct sock *sk)\n{\n\t \n\tif (sock_writeable(sk))\n\t\txs_write_space(sk);\n}\n\n \nstatic void xs_tcp_write_space(struct sock *sk)\n{\n\t \n\tif (sk_stream_is_writeable(sk))\n\t\txs_write_space(sk);\n}\n\nstatic void xs_udp_do_set_buffer_size(struct rpc_xprt *xprt)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\tstruct sock *sk = transport->inet;\n\n\tif (transport->rcvsize) {\n\t\tsk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\tsk->sk_rcvbuf = transport->rcvsize * xprt->max_reqs * 2;\n\t}\n\tif (transport->sndsize) {\n\t\tsk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\tsk->sk_sndbuf = transport->sndsize * xprt->max_reqs * 2;\n\t\tsk->sk_write_space(sk);\n\t}\n}\n\n \nstatic void xs_udp_set_buffer_size(struct rpc_xprt *xprt, size_t sndsize, size_t rcvsize)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\n\ttransport->sndsize = 0;\n\tif (sndsize)\n\t\ttransport->sndsize = sndsize + 1024;\n\ttransport->rcvsize = 0;\n\tif (rcvsize)\n\t\ttransport->rcvsize = rcvsize + 1024;\n\n\txs_udp_do_set_buffer_size(xprt);\n}\n\n \nstatic void xs_udp_timer(struct rpc_xprt *xprt, struct rpc_task *task)\n{\n\tspin_lock(&xprt->transport_lock);\n\txprt_adjust_cwnd(xprt, task, -ETIMEDOUT);\n\tspin_unlock(&xprt->transport_lock);\n}\n\nstatic int xs_get_random_port(void)\n{\n\tunsigned short min = xprt_min_resvport, max = xprt_max_resvport;\n\tunsigned short range;\n\tunsigned short rand;\n\n\tif (max < min)\n\t\treturn -EADDRINUSE;\n\trange = max - min + 1;\n\trand = get_random_u32_below(range);\n\treturn rand + min;\n}\n\nstatic unsigned short xs_sock_getport(struct socket *sock)\n{\n\tstruct sockaddr_storage buf;\n\tunsigned short port = 0;\n\n\tif (kernel_getsockname(sock, (struct sockaddr *)&buf) < 0)\n\t\tgoto out;\n\tswitch (buf.ss_family) {\n\tcase AF_INET6:\n\t\tport = ntohs(((struct sockaddr_in6 *)&buf)->sin6_port);\n\t\tbreak;\n\tcase AF_INET:\n\t\tport = ntohs(((struct sockaddr_in *)&buf)->sin_port);\n\t}\nout:\n\treturn port;\n}\n\n \nstatic void xs_set_port(struct rpc_xprt *xprt, unsigned short port)\n{\n\tdprintk(\"RPC:       setting port for xprt %p to %u\\n\", xprt, port);\n\n\trpc_set_port(xs_addr(xprt), port);\n\txs_update_peer_port(xprt);\n}\n\nstatic void xs_set_srcport(struct sock_xprt *transport, struct socket *sock)\n{\n\tif (transport->srcport == 0 && transport->xprt.reuseport)\n\t\ttransport->srcport = xs_sock_getport(sock);\n}\n\nstatic int xs_get_srcport(struct sock_xprt *transport)\n{\n\tint port = transport->srcport;\n\n\tif (port == 0 && transport->xprt.resvport)\n\t\tport = xs_get_random_port();\n\treturn port;\n}\n\nstatic unsigned short xs_sock_srcport(struct rpc_xprt *xprt)\n{\n\tstruct sock_xprt *sock = container_of(xprt, struct sock_xprt, xprt);\n\tunsigned short ret = 0;\n\tmutex_lock(&sock->recv_mutex);\n\tif (sock->sock)\n\t\tret = xs_sock_getport(sock->sock);\n\tmutex_unlock(&sock->recv_mutex);\n\treturn ret;\n}\n\nstatic int xs_sock_srcaddr(struct rpc_xprt *xprt, char *buf, size_t buflen)\n{\n\tstruct sock_xprt *sock = container_of(xprt, struct sock_xprt, xprt);\n\tunion {\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_storage st;\n\t} saddr;\n\tint ret = -ENOTCONN;\n\n\tmutex_lock(&sock->recv_mutex);\n\tif (sock->sock) {\n\t\tret = kernel_getsockname(sock->sock, &saddr.sa);\n\t\tif (ret >= 0)\n\t\t\tret = snprintf(buf, buflen, \"%pISc\", &saddr.sa);\n\t}\n\tmutex_unlock(&sock->recv_mutex);\n\treturn ret;\n}\n\nstatic unsigned short xs_next_srcport(struct sock_xprt *transport, unsigned short port)\n{\n\tif (transport->srcport != 0)\n\t\ttransport->srcport = 0;\n\tif (!transport->xprt.resvport)\n\t\treturn 0;\n\tif (port <= xprt_min_resvport || port > xprt_max_resvport)\n\t\treturn xprt_max_resvport;\n\treturn --port;\n}\nstatic int xs_bind(struct sock_xprt *transport, struct socket *sock)\n{\n\tstruct sockaddr_storage myaddr;\n\tint err, nloop = 0;\n\tint port = xs_get_srcport(transport);\n\tunsigned short last;\n\n\t \n\tif (port <= 0)\n\t\treturn port;\n\n\tmemcpy(&myaddr, &transport->srcaddr, transport->xprt.addrlen);\n\tdo {\n\t\trpc_set_port((struct sockaddr *)&myaddr, port);\n\t\terr = kernel_bind(sock, (struct sockaddr *)&myaddr,\n\t\t\t\ttransport->xprt.addrlen);\n\t\tif (err == 0) {\n\t\t\tif (transport->xprt.reuseport)\n\t\t\t\ttransport->srcport = port;\n\t\t\tbreak;\n\t\t}\n\t\tlast = port;\n\t\tport = xs_next_srcport(transport, port);\n\t\tif (port > last)\n\t\t\tnloop++;\n\t} while (err == -EADDRINUSE && nloop != 2);\n\n\tif (myaddr.ss_family == AF_INET)\n\t\tdprintk(\"RPC:       %s %pI4:%u: %s (%d)\\n\", __func__,\n\t\t\t\t&((struct sockaddr_in *)&myaddr)->sin_addr,\n\t\t\t\tport, err ? \"failed\" : \"ok\", err);\n\telse\n\t\tdprintk(\"RPC:       %s %pI6:%u: %s (%d)\\n\", __func__,\n\t\t\t\t&((struct sockaddr_in6 *)&myaddr)->sin6_addr,\n\t\t\t\tport, err ? \"failed\" : \"ok\", err);\n\treturn err;\n}\n\n \nstatic void xs_local_rpcbind(struct rpc_task *task)\n{\n\txprt_set_bound(task->tk_xprt);\n}\n\nstatic void xs_local_set_port(struct rpc_xprt *xprt, unsigned short port)\n{\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key xs_key[3];\nstatic struct lock_class_key xs_slock_key[3];\n\nstatic inline void xs_reclassify_socketu(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tsock_lock_init_class_and_name(sk, \"slock-AF_LOCAL-RPC\",\n\t\t&xs_slock_key[0], \"sk_lock-AF_LOCAL-RPC\", &xs_key[0]);\n}\n\nstatic inline void xs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-RPC\",\n\t\t&xs_slock_key[1], \"sk_lock-AF_INET-RPC\", &xs_key[1]);\n}\n\nstatic inline void xs_reclassify_socket6(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-RPC\",\n\t\t&xs_slock_key[2], \"sk_lock-AF_INET6-RPC\", &xs_key[2]);\n}\n\nstatic inline void xs_reclassify_socket(int family, struct socket *sock)\n{\n\tif (WARN_ON_ONCE(!sock_allow_reclassification(sock->sk)))\n\t\treturn;\n\n\tswitch (family) {\n\tcase AF_LOCAL:\n\t\txs_reclassify_socketu(sock);\n\t\tbreak;\n\tcase AF_INET:\n\t\txs_reclassify_socket4(sock);\n\t\tbreak;\n\tcase AF_INET6:\n\t\txs_reclassify_socket6(sock);\n\t\tbreak;\n\t}\n}\n#else\nstatic inline void xs_reclassify_socket(int family, struct socket *sock)\n{\n}\n#endif\n\nstatic void xs_dummy_setup_socket(struct work_struct *work)\n{\n}\n\nstatic struct socket *xs_create_sock(struct rpc_xprt *xprt,\n\t\tstruct sock_xprt *transport, int family, int type,\n\t\tint protocol, bool reuseport)\n{\n\tstruct file *filp;\n\tstruct socket *sock;\n\tint err;\n\n\terr = __sock_create(xprt->xprt_net, family, type, protocol, &sock, 1);\n\tif (err < 0) {\n\t\tdprintk(\"RPC:       can't create %d transport socket (%d).\\n\",\n\t\t\t\tprotocol, -err);\n\t\tgoto out;\n\t}\n\txs_reclassify_socket(family, sock);\n\n\tif (reuseport)\n\t\tsock_set_reuseport(sock->sk);\n\n\terr = xs_bind(transport, sock);\n\tif (err) {\n\t\tsock_release(sock);\n\t\tgoto out;\n\t}\n\n\tfilp = sock_alloc_file(sock, O_NONBLOCK, NULL);\n\tif (IS_ERR(filp))\n\t\treturn ERR_CAST(filp);\n\ttransport->file = filp;\n\n\treturn sock;\nout:\n\treturn ERR_PTR(err);\n}\n\nstatic int xs_local_finish_connecting(struct rpc_xprt *xprt,\n\t\t\t\t      struct socket *sock)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt,\n\t\t\t\t\t\t\t\t\txprt);\n\n\tif (!transport->inet) {\n\t\tstruct sock *sk = sock->sk;\n\n\t\tlock_sock(sk);\n\n\t\txs_save_old_callbacks(transport, sk);\n\n\t\tsk->sk_user_data = xprt;\n\t\tsk->sk_data_ready = xs_data_ready;\n\t\tsk->sk_write_space = xs_udp_write_space;\n\t\tsk->sk_state_change = xs_local_state_change;\n\t\tsk->sk_error_report = xs_error_report;\n\t\tsk->sk_use_task_frag = false;\n\n\t\txprt_clear_connected(xprt);\n\n\t\t \n\t\ttransport->sock = sock;\n\t\ttransport->inet = sk;\n\n\t\trelease_sock(sk);\n\t}\n\n\txs_stream_start_connect(transport);\n\n\treturn kernel_connect(sock, xs_addr(xprt), xprt->addrlen, 0);\n}\n\n \nstatic int xs_local_setup_socket(struct sock_xprt *transport)\n{\n\tstruct rpc_xprt *xprt = &transport->xprt;\n\tstruct file *filp;\n\tstruct socket *sock;\n\tint status;\n\n\tstatus = __sock_create(xprt->xprt_net, AF_LOCAL,\n\t\t\t\t\tSOCK_STREAM, 0, &sock, 1);\n\tif (status < 0) {\n\t\tdprintk(\"RPC:       can't create AF_LOCAL \"\n\t\t\t\"transport socket (%d).\\n\", -status);\n\t\tgoto out;\n\t}\n\txs_reclassify_socket(AF_LOCAL, sock);\n\n\tfilp = sock_alloc_file(sock, O_NONBLOCK, NULL);\n\tif (IS_ERR(filp)) {\n\t\tstatus = PTR_ERR(filp);\n\t\tgoto out;\n\t}\n\ttransport->file = filp;\n\n\tdprintk(\"RPC:       worker connecting xprt %p via AF_LOCAL to %s\\n\",\n\t\t\txprt, xprt->address_strings[RPC_DISPLAY_ADDR]);\n\n\tstatus = xs_local_finish_connecting(xprt, sock);\n\ttrace_rpc_socket_connect(xprt, sock, status);\n\tswitch (status) {\n\tcase 0:\n\t\tdprintk(\"RPC:       xprt %p connected to %s\\n\",\n\t\t\t\txprt, xprt->address_strings[RPC_DISPLAY_ADDR]);\n\t\txprt->stat.connect_count++;\n\t\txprt->stat.connect_time += (long)jiffies -\n\t\t\t\t\t   xprt->stat.connect_start;\n\t\txprt_set_connected(xprt);\n\t\tbreak;\n\tcase -ENOBUFS:\n\t\tbreak;\n\tcase -ENOENT:\n\t\tdprintk(\"RPC:       xprt %p: socket %s does not exist\\n\",\n\t\t\t\txprt, xprt->address_strings[RPC_DISPLAY_ADDR]);\n\t\tbreak;\n\tcase -ECONNREFUSED:\n\t\tdprintk(\"RPC:       xprt %p: connection refused for %s\\n\",\n\t\t\t\txprt, xprt->address_strings[RPC_DISPLAY_ADDR]);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s: unhandled error (%d) connecting to %s\\n\",\n\t\t\t\t__func__, -status,\n\t\t\t\txprt->address_strings[RPC_DISPLAY_ADDR]);\n\t}\n\nout:\n\txprt_clear_connecting(xprt);\n\txprt_wake_pending_tasks(xprt, status);\n\treturn status;\n}\n\nstatic void xs_local_connect(struct rpc_xprt *xprt, struct rpc_task *task)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\tint ret;\n\n\tif (transport->file)\n\t\tgoto force_disconnect;\n\n\tif (RPC_IS_ASYNC(task)) {\n\t\t \n\t\trpc_task_set_rpc_status(task, -ENOTCONN);\n\t\tgoto out_wake;\n\t}\n\tret = xs_local_setup_socket(transport);\n\tif (ret && !RPC_IS_SOFTCONN(task))\n\t\tmsleep_interruptible(15000);\n\treturn;\nforce_disconnect:\n\txprt_force_disconnect(xprt);\nout_wake:\n\txprt_clear_connecting(xprt);\n\txprt_wake_pending_tasks(xprt, -ENOTCONN);\n}\n\n#if IS_ENABLED(CONFIG_SUNRPC_SWAP)\n \nstatic void xs_set_memalloc(struct rpc_xprt *xprt)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt,\n\t\t\txprt);\n\n\t \n\tif (!transport->inet)\n\t\treturn;\n\tif (atomic_read(&xprt->swapper))\n\t\tsk_set_memalloc(transport->inet);\n}\n\n \nstatic int\nxs_enable_swap(struct rpc_xprt *xprt)\n{\n\tstruct sock_xprt *xs = container_of(xprt, struct sock_xprt, xprt);\n\n\tmutex_lock(&xs->recv_mutex);\n\tif (atomic_inc_return(&xprt->swapper) == 1 &&\n\t    xs->inet)\n\t\tsk_set_memalloc(xs->inet);\n\tmutex_unlock(&xs->recv_mutex);\n\treturn 0;\n}\n\n \nstatic void\nxs_disable_swap(struct rpc_xprt *xprt)\n{\n\tstruct sock_xprt *xs = container_of(xprt, struct sock_xprt, xprt);\n\n\tmutex_lock(&xs->recv_mutex);\n\tif (atomic_dec_and_test(&xprt->swapper) &&\n\t    xs->inet)\n\t\tsk_clear_memalloc(xs->inet);\n\tmutex_unlock(&xs->recv_mutex);\n}\n#else\nstatic void xs_set_memalloc(struct rpc_xprt *xprt)\n{\n}\n\nstatic int\nxs_enable_swap(struct rpc_xprt *xprt)\n{\n\treturn -EINVAL;\n}\n\nstatic void\nxs_disable_swap(struct rpc_xprt *xprt)\n{\n}\n#endif\n\nstatic void xs_udp_finish_connecting(struct rpc_xprt *xprt, struct socket *sock)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\n\tif (!transport->inet) {\n\t\tstruct sock *sk = sock->sk;\n\n\t\tlock_sock(sk);\n\n\t\txs_save_old_callbacks(transport, sk);\n\n\t\tsk->sk_user_data = xprt;\n\t\tsk->sk_data_ready = xs_data_ready;\n\t\tsk->sk_write_space = xs_udp_write_space;\n\t\tsk->sk_use_task_frag = false;\n\n\t\txprt_set_connected(xprt);\n\n\t\t \n\t\ttransport->sock = sock;\n\t\ttransport->inet = sk;\n\n\t\txs_set_memalloc(xprt);\n\n\t\trelease_sock(sk);\n\t}\n\txs_udp_do_set_buffer_size(xprt);\n\n\txprt->stat.connect_start = jiffies;\n}\n\nstatic void xs_udp_setup_socket(struct work_struct *work)\n{\n\tstruct sock_xprt *transport =\n\t\tcontainer_of(work, struct sock_xprt, connect_worker.work);\n\tstruct rpc_xprt *xprt = &transport->xprt;\n\tstruct socket *sock;\n\tint status = -EIO;\n\tunsigned int pflags = current->flags;\n\n\tif (atomic_read(&xprt->swapper))\n\t\tcurrent->flags |= PF_MEMALLOC;\n\tsock = xs_create_sock(xprt, transport,\n\t\t\txs_addr(xprt)->sa_family, SOCK_DGRAM,\n\t\t\tIPPROTO_UDP, false);\n\tif (IS_ERR(sock))\n\t\tgoto out;\n\n\tdprintk(\"RPC:       worker connecting xprt %p via %s to \"\n\t\t\t\t\"%s (port %s)\\n\", xprt,\n\t\t\txprt->address_strings[RPC_DISPLAY_PROTO],\n\t\t\txprt->address_strings[RPC_DISPLAY_ADDR],\n\t\t\txprt->address_strings[RPC_DISPLAY_PORT]);\n\n\txs_udp_finish_connecting(xprt, sock);\n\ttrace_rpc_socket_connect(xprt, sock, 0);\n\tstatus = 0;\nout:\n\txprt_clear_connecting(xprt);\n\txprt_unlock_connect(xprt, transport);\n\txprt_wake_pending_tasks(xprt, status);\n\tcurrent_restore_flags(pflags, PF_MEMALLOC);\n}\n\n \nstatic void xs_tcp_shutdown(struct rpc_xprt *xprt)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\tstruct socket *sock = transport->sock;\n\tint skst = transport->inet ? transport->inet->sk_state : TCP_CLOSE;\n\n\tif (sock == NULL)\n\t\treturn;\n\tif (!xprt->reuseport) {\n\t\txs_close(xprt);\n\t\treturn;\n\t}\n\tswitch (skst) {\n\tcase TCP_FIN_WAIT1:\n\tcase TCP_FIN_WAIT2:\n\tcase TCP_LAST_ACK:\n\t\tbreak;\n\tcase TCP_ESTABLISHED:\n\tcase TCP_CLOSE_WAIT:\n\t\tkernel_sock_shutdown(sock, SHUT_RDWR);\n\t\ttrace_rpc_socket_shutdown(xprt, sock);\n\t\tbreak;\n\tdefault:\n\t\txs_reset_transport(transport);\n\t}\n}\n\nstatic void xs_tcp_set_socket_timeouts(struct rpc_xprt *xprt,\n\t\tstruct socket *sock)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\tstruct net *net = sock_net(sock->sk);\n\tunsigned long connect_timeout;\n\tunsigned long syn_retries;\n\tunsigned int keepidle;\n\tunsigned int keepcnt;\n\tunsigned int timeo;\n\tunsigned long t;\n\n\tspin_lock(&xprt->transport_lock);\n\tkeepidle = DIV_ROUND_UP(xprt->timeout->to_initval, HZ);\n\tkeepcnt = xprt->timeout->to_retries + 1;\n\ttimeo = jiffies_to_msecs(xprt->timeout->to_initval) *\n\t\t(xprt->timeout->to_retries + 1);\n\tclear_bit(XPRT_SOCK_UPD_TIMEOUT, &transport->sock_state);\n\tspin_unlock(&xprt->transport_lock);\n\n\t \n\tsock_set_keepalive(sock->sk);\n\ttcp_sock_set_keepidle(sock->sk, keepidle);\n\ttcp_sock_set_keepintvl(sock->sk, keepidle);\n\ttcp_sock_set_keepcnt(sock->sk, keepcnt);\n\n\t \n\ttcp_sock_set_user_timeout(sock->sk, timeo);\n\n\t \n\tconnect_timeout = max_t(unsigned long,\n\t\t\t\tDIV_ROUND_UP(xprt->connect_timeout, HZ), 1);\n\tsyn_retries = max_t(unsigned long,\n\t\t\t    READ_ONCE(net->ipv4.sysctl_tcp_syn_retries), 1);\n\tfor (t = 0; t <= syn_retries && (1UL << t) < connect_timeout; t++)\n\t\t;\n\tif (t <= syn_retries)\n\t\ttcp_sock_set_syncnt(sock->sk, t - 1);\n}\n\nstatic void xs_tcp_do_set_connect_timeout(struct rpc_xprt *xprt,\n\t\t\t\t\t  unsigned long connect_timeout)\n{\n\tstruct sock_xprt *transport =\n\t\tcontainer_of(xprt, struct sock_xprt, xprt);\n\tstruct rpc_timeout to;\n\tunsigned long initval;\n\n\tmemcpy(&to, xprt->timeout, sizeof(to));\n\t \n\tinitval = max_t(unsigned long, connect_timeout, XS_TCP_INIT_REEST_TO);\n\tto.to_initval = initval;\n\tto.to_maxval = initval;\n\tto.to_retries = 0;\n\tmemcpy(&transport->tcp_timeout, &to, sizeof(transport->tcp_timeout));\n\txprt->timeout = &transport->tcp_timeout;\n\txprt->connect_timeout = connect_timeout;\n}\n\nstatic void xs_tcp_set_connect_timeout(struct rpc_xprt *xprt,\n\t\tunsigned long connect_timeout,\n\t\tunsigned long reconnect_timeout)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\n\tspin_lock(&xprt->transport_lock);\n\tif (reconnect_timeout < xprt->max_reconnect_timeout)\n\t\txprt->max_reconnect_timeout = reconnect_timeout;\n\tif (connect_timeout < xprt->connect_timeout)\n\t\txs_tcp_do_set_connect_timeout(xprt, connect_timeout);\n\tset_bit(XPRT_SOCK_UPD_TIMEOUT, &transport->sock_state);\n\tspin_unlock(&xprt->transport_lock);\n}\n\nstatic int xs_tcp_finish_connecting(struct rpc_xprt *xprt, struct socket *sock)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\n\tif (!transport->inet) {\n\t\tstruct sock *sk = sock->sk;\n\n\t\t \n\t\tif (xs_addr(xprt)->sa_family == PF_INET6) {\n\t\t\tip6_sock_set_addr_preferences(sk,\n\t\t\t\tIPV6_PREFER_SRC_PUBLIC);\n\t\t}\n\n\t\txs_tcp_set_socket_timeouts(xprt, sock);\n\t\ttcp_sock_set_nodelay(sk);\n\n\t\tlock_sock(sk);\n\n\t\txs_save_old_callbacks(transport, sk);\n\n\t\tsk->sk_user_data = xprt;\n\t\tsk->sk_data_ready = xs_data_ready;\n\t\tsk->sk_state_change = xs_tcp_state_change;\n\t\tsk->sk_write_space = xs_tcp_write_space;\n\t\tsk->sk_error_report = xs_error_report;\n\t\tsk->sk_use_task_frag = false;\n\n\t\t \n\t\tsock_reset_flag(sk, SOCK_LINGER);\n\n\t\txprt_clear_connected(xprt);\n\n\t\t \n\t\ttransport->sock = sock;\n\t\ttransport->inet = sk;\n\n\t\trelease_sock(sk);\n\t}\n\n\tif (!xprt_bound(xprt))\n\t\treturn -ENOTCONN;\n\n\txs_set_memalloc(xprt);\n\n\txs_stream_start_connect(transport);\n\n\t \n\tset_bit(XPRT_SOCK_CONNECTING, &transport->sock_state);\n\treturn kernel_connect(sock, xs_addr(xprt), xprt->addrlen, O_NONBLOCK);\n}\n\n \nstatic void xs_tcp_setup_socket(struct work_struct *work)\n{\n\tstruct sock_xprt *transport =\n\t\tcontainer_of(work, struct sock_xprt, connect_worker.work);\n\tstruct socket *sock = transport->sock;\n\tstruct rpc_xprt *xprt = &transport->xprt;\n\tint status;\n\tunsigned int pflags = current->flags;\n\n\tif (atomic_read(&xprt->swapper))\n\t\tcurrent->flags |= PF_MEMALLOC;\n\n\tif (xprt_connected(xprt))\n\t\tgoto out;\n\tif (test_and_clear_bit(XPRT_SOCK_CONNECT_SENT,\n\t\t\t       &transport->sock_state) ||\n\t    !sock) {\n\t\txs_reset_transport(transport);\n\t\tsock = xs_create_sock(xprt, transport, xs_addr(xprt)->sa_family,\n\t\t\t\t      SOCK_STREAM, IPPROTO_TCP, true);\n\t\tif (IS_ERR(sock)) {\n\t\t\txprt_wake_pending_tasks(xprt, PTR_ERR(sock));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdprintk(\"RPC:       worker connecting xprt %p via %s to \"\n\t\t\t\t\"%s (port %s)\\n\", xprt,\n\t\t\txprt->address_strings[RPC_DISPLAY_PROTO],\n\t\t\txprt->address_strings[RPC_DISPLAY_ADDR],\n\t\t\txprt->address_strings[RPC_DISPLAY_PORT]);\n\n\tstatus = xs_tcp_finish_connecting(xprt, sock);\n\ttrace_rpc_socket_connect(xprt, sock, status);\n\tdprintk(\"RPC:       %p connect status %d connected %d sock state %d\\n\",\n\t\t\txprt, -status, xprt_connected(xprt),\n\t\t\tsock->sk->sk_state);\n\tswitch (status) {\n\tcase 0:\n\tcase -EINPROGRESS:\n\t\t \n\t\tset_bit(XPRT_SOCK_CONNECT_SENT, &transport->sock_state);\n\t\tif (xprt->reestablish_timeout < XS_TCP_INIT_REEST_TO)\n\t\t\txprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;\n\t\tfallthrough;\n\tcase -EALREADY:\n\t\tgoto out_unlock;\n\tcase -EADDRNOTAVAIL:\n\t\t \n\t\ttransport->srcport = 0;\n\t\tstatus = -EAGAIN;\n\t\tbreak;\n\tcase -EINVAL:\n\t\t \n\tcase -ECONNREFUSED:\n\tcase -ECONNRESET:\n\tcase -ENETDOWN:\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -EADDRINUSE:\n\tcase -ENOBUFS:\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"%s: connect returned unhandled error %d\\n\",\n\t\t\t__func__, status);\n\t\tstatus = -EAGAIN;\n\t}\n\n\t \n\txprt_wake_pending_tasks(xprt, status);\n\txs_tcp_force_close(xprt);\nout:\n\txprt_clear_connecting(xprt);\nout_unlock:\n\txprt_unlock_connect(xprt, transport);\n\tcurrent_restore_flags(pflags, PF_MEMALLOC);\n}\n\n \nstatic int xs_tcp_tls_finish_connecting(struct rpc_xprt *lower_xprt,\n\t\t\t\t\tstruct sock_xprt *upper_transport)\n{\n\tstruct sock_xprt *lower_transport =\n\t\t\tcontainer_of(lower_xprt, struct sock_xprt, xprt);\n\tstruct rpc_xprt *upper_xprt = &upper_transport->xprt;\n\n\tif (!upper_transport->inet) {\n\t\tstruct socket *sock = lower_transport->sock;\n\t\tstruct sock *sk = sock->sk;\n\n\t\t \n\t\tif (xs_addr(upper_xprt)->sa_family == PF_INET6)\n\t\t\tip6_sock_set_addr_preferences(sk, IPV6_PREFER_SRC_PUBLIC);\n\n\t\txs_tcp_set_socket_timeouts(upper_xprt, sock);\n\t\ttcp_sock_set_nodelay(sk);\n\n\t\tlock_sock(sk);\n\n\t\t \n\t\tupper_transport->old_data_ready = lower_transport->old_data_ready;\n\t\tupper_transport->old_state_change = lower_transport->old_state_change;\n\t\tupper_transport->old_write_space = lower_transport->old_write_space;\n\t\tupper_transport->old_error_report = lower_transport->old_error_report;\n\t\tsk->sk_user_data = upper_xprt;\n\n\t\t \n\t\tsock_reset_flag(sk, SOCK_LINGER);\n\n\t\txprt_clear_connected(upper_xprt);\n\n\t\tupper_transport->sock = sock;\n\t\tupper_transport->inet = sk;\n\t\tupper_transport->file = lower_transport->file;\n\n\t\trelease_sock(sk);\n\n\t\t \n\t\tmutex_lock(&lower_transport->recv_mutex);\n\t\tlower_transport->inet = NULL;\n\t\tlower_transport->sock = NULL;\n\t\tlower_transport->file = NULL;\n\n\t\txprt_clear_connected(lower_xprt);\n\t\txs_sock_reset_connection_flags(lower_xprt);\n\t\txs_stream_reset_connect(lower_transport);\n\t\tmutex_unlock(&lower_transport->recv_mutex);\n\t}\n\n\tif (!xprt_bound(upper_xprt))\n\t\treturn -ENOTCONN;\n\n\txs_set_memalloc(upper_xprt);\n\n\tif (!xprt_test_and_set_connected(upper_xprt)) {\n\t\tupper_xprt->connect_cookie++;\n\t\tclear_bit(XPRT_SOCK_CONNECTING, &upper_transport->sock_state);\n\t\txprt_clear_connecting(upper_xprt);\n\n\t\tupper_xprt->stat.connect_count++;\n\t\tupper_xprt->stat.connect_time += (long)jiffies -\n\t\t\t\t\t   upper_xprt->stat.connect_start;\n\t\txs_run_error_worker(upper_transport, XPRT_SOCK_WAKE_PENDING);\n\t}\n\treturn 0;\n}\n\n \nstatic void xs_tls_handshake_done(void *data, int status, key_serial_t peerid)\n{\n\tstruct rpc_xprt *lower_xprt = data;\n\tstruct sock_xprt *lower_transport =\n\t\t\t\tcontainer_of(lower_xprt, struct sock_xprt, xprt);\n\n\tlower_transport->xprt_err = status ? -EACCES : 0;\n\tcomplete(&lower_transport->handshake_done);\n\txprt_put(lower_xprt);\n}\n\nstatic int xs_tls_handshake_sync(struct rpc_xprt *lower_xprt, struct xprtsec_parms *xprtsec)\n{\n\tstruct sock_xprt *lower_transport =\n\t\t\t\tcontainer_of(lower_xprt, struct sock_xprt, xprt);\n\tstruct tls_handshake_args args = {\n\t\t.ta_sock\t= lower_transport->sock,\n\t\t.ta_done\t= xs_tls_handshake_done,\n\t\t.ta_data\t= xprt_get(lower_xprt),\n\t\t.ta_peername\t= lower_xprt->servername,\n\t};\n\tstruct sock *sk = lower_transport->inet;\n\tint rc;\n\n\tinit_completion(&lower_transport->handshake_done);\n\tset_bit(XPRT_SOCK_IGNORE_RECV, &lower_transport->sock_state);\n\tlower_transport->xprt_err = -ETIMEDOUT;\n\tswitch (xprtsec->policy) {\n\tcase RPC_XPRTSEC_TLS_ANON:\n\t\trc = tls_client_hello_anon(&args, GFP_KERNEL);\n\t\tif (rc)\n\t\t\tgoto out_put_xprt;\n\t\tbreak;\n\tcase RPC_XPRTSEC_TLS_X509:\n\t\targs.ta_my_cert = xprtsec->cert_serial;\n\t\targs.ta_my_privkey = xprtsec->privkey_serial;\n\t\trc = tls_client_hello_x509(&args, GFP_KERNEL);\n\t\tif (rc)\n\t\t\tgoto out_put_xprt;\n\t\tbreak;\n\tdefault:\n\t\trc = -EACCES;\n\t\tgoto out_put_xprt;\n\t}\n\n\trc = wait_for_completion_interruptible_timeout(&lower_transport->handshake_done,\n\t\t\t\t\t\t       XS_TLS_HANDSHAKE_TO);\n\tif (rc <= 0) {\n\t\tif (!tls_handshake_cancel(sk)) {\n\t\t\tif (rc == 0)\n\t\t\t\trc = -ETIMEDOUT;\n\t\t\tgoto out_put_xprt;\n\t\t}\n\t}\n\n\trc = lower_transport->xprt_err;\n\nout:\n\txs_stream_reset_connect(lower_transport);\n\tclear_bit(XPRT_SOCK_IGNORE_RECV, &lower_transport->sock_state);\n\treturn rc;\n\nout_put_xprt:\n\txprt_put(lower_xprt);\n\tgoto out;\n}\n\n \nstatic void xs_tcp_tls_setup_socket(struct work_struct *work)\n{\n\tstruct sock_xprt *upper_transport =\n\t\tcontainer_of(work, struct sock_xprt, connect_worker.work);\n\tstruct rpc_clnt *upper_clnt = upper_transport->clnt;\n\tstruct rpc_xprt *upper_xprt = &upper_transport->xprt;\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= upper_xprt->xprt_net,\n\t\t.protocol\t= upper_xprt->prot,\n\t\t.address\t= (struct sockaddr *)&upper_xprt->addr,\n\t\t.addrsize\t= upper_xprt->addrlen,\n\t\t.timeout\t= upper_clnt->cl_timeout,\n\t\t.servername\t= upper_xprt->servername,\n\t\t.program\t= upper_clnt->cl_program,\n\t\t.prognumber\t= upper_clnt->cl_prog,\n\t\t.version\t= upper_clnt->cl_vers,\n\t\t.authflavor\t= RPC_AUTH_TLS,\n\t\t.cred\t\t= upper_clnt->cl_cred,\n\t\t.xprtsec\t= {\n\t\t\t.policy\t\t= RPC_XPRTSEC_NONE,\n\t\t},\n\t};\n\tunsigned int pflags = current->flags;\n\tstruct rpc_clnt *lower_clnt;\n\tstruct rpc_xprt *lower_xprt;\n\tint status;\n\n\tif (atomic_read(&upper_xprt->swapper))\n\t\tcurrent->flags |= PF_MEMALLOC;\n\n\txs_stream_start_connect(upper_transport);\n\n\t \n\tlower_clnt = rpc_create(&args);\n\tif (IS_ERR(lower_clnt)) {\n\t\ttrace_rpc_tls_unavailable(upper_clnt, upper_xprt);\n\t\tclear_bit(XPRT_SOCK_CONNECTING, &upper_transport->sock_state);\n\t\txprt_clear_connecting(upper_xprt);\n\t\txprt_wake_pending_tasks(upper_xprt, PTR_ERR(lower_clnt));\n\t\txs_run_error_worker(upper_transport, XPRT_SOCK_WAKE_PENDING);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\trcu_read_lock();\n\tlower_xprt = rcu_dereference(lower_clnt->cl_xprt);\n\trcu_read_unlock();\n\n\tif (wait_on_bit_lock(&lower_xprt->state, XPRT_LOCKED, TASK_KILLABLE))\n\t\tgoto out_unlock;\n\n\tstatus = xs_tls_handshake_sync(lower_xprt, &upper_xprt->xprtsec);\n\tif (status) {\n\t\ttrace_rpc_tls_not_started(upper_clnt, upper_xprt);\n\t\tgoto out_close;\n\t}\n\n\tstatus = xs_tcp_tls_finish_connecting(lower_xprt, upper_transport);\n\tif (status)\n\t\tgoto out_close;\n\txprt_release_write(lower_xprt, NULL);\n\n\ttrace_rpc_socket_connect(upper_xprt, upper_transport->sock, 0);\n\tif (!xprt_test_and_set_connected(upper_xprt)) {\n\t\tupper_xprt->connect_cookie++;\n\t\tclear_bit(XPRT_SOCK_CONNECTING, &upper_transport->sock_state);\n\t\txprt_clear_connecting(upper_xprt);\n\n\t\tupper_xprt->stat.connect_count++;\n\t\tupper_xprt->stat.connect_time += (long)jiffies -\n\t\t\t\t\t   upper_xprt->stat.connect_start;\n\t\txs_run_error_worker(upper_transport, XPRT_SOCK_WAKE_PENDING);\n\t}\n\trpc_shutdown_client(lower_clnt);\n\nout_unlock:\n\tcurrent_restore_flags(pflags, PF_MEMALLOC);\n\tupper_transport->clnt = NULL;\n\txprt_unlock_connect(upper_xprt, upper_transport);\n\treturn;\n\nout_close:\n\txprt_release_write(lower_xprt, NULL);\n\trpc_shutdown_client(lower_clnt);\n\n\t \n\txprt_wake_pending_tasks(upper_xprt, status);\n\txs_tcp_force_close(upper_xprt);\n\txprt_clear_connecting(upper_xprt);\n\tgoto out_unlock;\n}\n\n \nstatic void xs_connect(struct rpc_xprt *xprt, struct rpc_task *task)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\tunsigned long delay = 0;\n\n\tWARN_ON_ONCE(!xprt_lock_connect(xprt, task, transport));\n\n\tif (transport->sock != NULL) {\n\t\tdprintk(\"RPC:       xs_connect delayed xprt %p for %lu \"\n\t\t\t\"seconds\\n\", xprt, xprt->reestablish_timeout / HZ);\n\n\t\tdelay = xprt_reconnect_delay(xprt);\n\t\txprt_reconnect_backoff(xprt, XS_TCP_INIT_REEST_TO);\n\n\t} else\n\t\tdprintk(\"RPC:       xs_connect scheduled xprt %p\\n\", xprt);\n\n\ttransport->clnt = task->tk_client;\n\tqueue_delayed_work(xprtiod_workqueue,\n\t\t\t&transport->connect_worker,\n\t\t\tdelay);\n}\n\nstatic void xs_wake_disconnect(struct sock_xprt *transport)\n{\n\tif (test_and_clear_bit(XPRT_SOCK_WAKE_DISCONNECT, &transport->sock_state))\n\t\txs_tcp_force_close(&transport->xprt);\n}\n\nstatic void xs_wake_write(struct sock_xprt *transport)\n{\n\tif (test_and_clear_bit(XPRT_SOCK_WAKE_WRITE, &transport->sock_state))\n\t\txprt_write_space(&transport->xprt);\n}\n\nstatic void xs_wake_error(struct sock_xprt *transport)\n{\n\tint sockerr;\n\n\tif (!test_bit(XPRT_SOCK_WAKE_ERROR, &transport->sock_state))\n\t\treturn;\n\tmutex_lock(&transport->recv_mutex);\n\tif (transport->sock == NULL)\n\t\tgoto out;\n\tif (!test_and_clear_bit(XPRT_SOCK_WAKE_ERROR, &transport->sock_state))\n\t\tgoto out;\n\tsockerr = xchg(&transport->xprt_err, 0);\n\tif (sockerr < 0)\n\t\txprt_wake_pending_tasks(&transport->xprt, sockerr);\nout:\n\tmutex_unlock(&transport->recv_mutex);\n}\n\nstatic void xs_wake_pending(struct sock_xprt *transport)\n{\n\tif (test_and_clear_bit(XPRT_SOCK_WAKE_PENDING, &transport->sock_state))\n\t\txprt_wake_pending_tasks(&transport->xprt, -EAGAIN);\n}\n\nstatic void xs_error_handle(struct work_struct *work)\n{\n\tstruct sock_xprt *transport = container_of(work,\n\t\t\tstruct sock_xprt, error_worker);\n\n\txs_wake_disconnect(transport);\n\txs_wake_write(transport);\n\txs_wake_error(transport);\n\txs_wake_pending(transport);\n}\n\n \nstatic void xs_local_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)\n{\n\tlong idle_time = 0;\n\n\tif (xprt_connected(xprt))\n\t\tidle_time = (long)(jiffies - xprt->last_used) / HZ;\n\n\tseq_printf(seq, \"\\txprt:\\tlocal %lu %lu %lu %ld %lu %lu %lu \"\n\t\t\t\"%llu %llu %lu %llu %llu\\n\",\n\t\t\txprt->stat.bind_count,\n\t\t\txprt->stat.connect_count,\n\t\t\txprt->stat.connect_time / HZ,\n\t\t\tidle_time,\n\t\t\txprt->stat.sends,\n\t\t\txprt->stat.recvs,\n\t\t\txprt->stat.bad_xids,\n\t\t\txprt->stat.req_u,\n\t\t\txprt->stat.bklog_u,\n\t\t\txprt->stat.max_slots,\n\t\t\txprt->stat.sending_u,\n\t\t\txprt->stat.pending_u);\n}\n\n \nstatic void xs_udp_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\n\tseq_printf(seq, \"\\txprt:\\tudp %u %lu %lu %lu %lu %llu %llu \"\n\t\t\t\"%lu %llu %llu\\n\",\n\t\t\ttransport->srcport,\n\t\t\txprt->stat.bind_count,\n\t\t\txprt->stat.sends,\n\t\t\txprt->stat.recvs,\n\t\t\txprt->stat.bad_xids,\n\t\t\txprt->stat.req_u,\n\t\t\txprt->stat.bklog_u,\n\t\t\txprt->stat.max_slots,\n\t\t\txprt->stat.sending_u,\n\t\t\txprt->stat.pending_u);\n}\n\n \nstatic void xs_tcp_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)\n{\n\tstruct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);\n\tlong idle_time = 0;\n\n\tif (xprt_connected(xprt))\n\t\tidle_time = (long)(jiffies - xprt->last_used) / HZ;\n\n\tseq_printf(seq, \"\\txprt:\\ttcp %u %lu %lu %lu %ld %lu %lu %lu \"\n\t\t\t\"%llu %llu %lu %llu %llu\\n\",\n\t\t\ttransport->srcport,\n\t\t\txprt->stat.bind_count,\n\t\t\txprt->stat.connect_count,\n\t\t\txprt->stat.connect_time / HZ,\n\t\t\tidle_time,\n\t\t\txprt->stat.sends,\n\t\t\txprt->stat.recvs,\n\t\t\txprt->stat.bad_xids,\n\t\t\txprt->stat.req_u,\n\t\t\txprt->stat.bklog_u,\n\t\t\txprt->stat.max_slots,\n\t\t\txprt->stat.sending_u,\n\t\t\txprt->stat.pending_u);\n}\n\n \nstatic int bc_malloc(struct rpc_task *task)\n{\n\tstruct rpc_rqst *rqst = task->tk_rqstp;\n\tsize_t size = rqst->rq_callsize;\n\tstruct page *page;\n\tstruct rpc_buffer *buf;\n\n\tif (size > PAGE_SIZE - sizeof(struct rpc_buffer)) {\n\t\tWARN_ONCE(1, \"xprtsock: large bc buffer request (size %zu)\\n\",\n\t\t\t  size);\n\t\treturn -EINVAL;\n\t}\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tbuf = page_address(page);\n\tbuf->len = PAGE_SIZE;\n\n\trqst->rq_buffer = buf->data;\n\trqst->rq_rbuffer = (char *)rqst->rq_buffer + rqst->rq_callsize;\n\treturn 0;\n}\n\n \nstatic void bc_free(struct rpc_task *task)\n{\n\tvoid *buffer = task->tk_rqstp->rq_buffer;\n\tstruct rpc_buffer *buf;\n\n\tbuf = container_of(buffer, struct rpc_buffer, data);\n\tfree_page((unsigned long)buf);\n}\n\nstatic int bc_sendto(struct rpc_rqst *req)\n{\n\tstruct xdr_buf *xdr = &req->rq_snd_buf;\n\tstruct sock_xprt *transport =\n\t\t\tcontainer_of(req->rq_xprt, struct sock_xprt, xprt);\n\tstruct msghdr msg = {\n\t\t.msg_flags\t= 0,\n\t};\n\trpc_fraghdr marker = cpu_to_be32(RPC_LAST_STREAM_FRAGMENT |\n\t\t\t\t\t (u32)xdr->len);\n\tunsigned int sent = 0;\n\tint err;\n\n\treq->rq_xtime = ktime_get();\n\terr = xdr_alloc_bvec(xdr, rpc_task_gfp_mask());\n\tif (err < 0)\n\t\treturn err;\n\terr = xprt_sock_sendmsg(transport->sock, &msg, xdr, 0, marker, &sent);\n\txdr_free_bvec(xdr);\n\tif (err < 0 || sent != (xdr->len + sizeof(marker)))\n\t\treturn -EAGAIN;\n\treturn sent;\n}\n\n \nstatic int bc_send_request(struct rpc_rqst *req)\n{\n\tstruct svc_xprt\t*xprt;\n\tint len;\n\n\t \n\txprt = req->rq_xprt->bc_xprt;\n\n\t \n\tmutex_lock(&xprt->xpt_mutex);\n\tif (test_bit(XPT_DEAD, &xprt->xpt_flags))\n\t\tlen = -ENOTCONN;\n\telse\n\t\tlen = bc_sendto(req);\n\tmutex_unlock(&xprt->xpt_mutex);\n\n\tif (len > 0)\n\t\tlen = 0;\n\n\treturn len;\n}\n\n \n\nstatic void bc_close(struct rpc_xprt *xprt)\n{\n\txprt_disconnect_done(xprt);\n}\n\n \n\nstatic void bc_destroy(struct rpc_xprt *xprt)\n{\n\tdprintk(\"RPC:       bc_destroy xprt %p\\n\", xprt);\n\n\txs_xprt_free(xprt);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic const struct rpc_xprt_ops xs_local_ops = {\n\t.reserve_xprt\t\t= xprt_reserve_xprt,\n\t.release_xprt\t\t= xprt_release_xprt,\n\t.alloc_slot\t\t= xprt_alloc_slot,\n\t.free_slot\t\t= xprt_free_slot,\n\t.rpcbind\t\t= xs_local_rpcbind,\n\t.set_port\t\t= xs_local_set_port,\n\t.connect\t\t= xs_local_connect,\n\t.buf_alloc\t\t= rpc_malloc,\n\t.buf_free\t\t= rpc_free,\n\t.prepare_request\t= xs_stream_prepare_request,\n\t.send_request\t\t= xs_local_send_request,\n\t.wait_for_reply_request\t= xprt_wait_for_reply_request_def,\n\t.close\t\t\t= xs_close,\n\t.destroy\t\t= xs_destroy,\n\t.print_stats\t\t= xs_local_print_stats,\n\t.enable_swap\t\t= xs_enable_swap,\n\t.disable_swap\t\t= xs_disable_swap,\n};\n\nstatic const struct rpc_xprt_ops xs_udp_ops = {\n\t.set_buffer_size\t= xs_udp_set_buffer_size,\n\t.reserve_xprt\t\t= xprt_reserve_xprt_cong,\n\t.release_xprt\t\t= xprt_release_xprt_cong,\n\t.alloc_slot\t\t= xprt_alloc_slot,\n\t.free_slot\t\t= xprt_free_slot,\n\t.rpcbind\t\t= rpcb_getport_async,\n\t.set_port\t\t= xs_set_port,\n\t.connect\t\t= xs_connect,\n\t.get_srcaddr\t\t= xs_sock_srcaddr,\n\t.get_srcport\t\t= xs_sock_srcport,\n\t.buf_alloc\t\t= rpc_malloc,\n\t.buf_free\t\t= rpc_free,\n\t.send_request\t\t= xs_udp_send_request,\n\t.wait_for_reply_request\t= xprt_wait_for_reply_request_rtt,\n\t.timer\t\t\t= xs_udp_timer,\n\t.release_request\t= xprt_release_rqst_cong,\n\t.close\t\t\t= xs_close,\n\t.destroy\t\t= xs_destroy,\n\t.print_stats\t\t= xs_udp_print_stats,\n\t.enable_swap\t\t= xs_enable_swap,\n\t.disable_swap\t\t= xs_disable_swap,\n\t.inject_disconnect\t= xs_inject_disconnect,\n};\n\nstatic const struct rpc_xprt_ops xs_tcp_ops = {\n\t.reserve_xprt\t\t= xprt_reserve_xprt,\n\t.release_xprt\t\t= xprt_release_xprt,\n\t.alloc_slot\t\t= xprt_alloc_slot,\n\t.free_slot\t\t= xprt_free_slot,\n\t.rpcbind\t\t= rpcb_getport_async,\n\t.set_port\t\t= xs_set_port,\n\t.connect\t\t= xs_connect,\n\t.get_srcaddr\t\t= xs_sock_srcaddr,\n\t.get_srcport\t\t= xs_sock_srcport,\n\t.buf_alloc\t\t= rpc_malloc,\n\t.buf_free\t\t= rpc_free,\n\t.prepare_request\t= xs_stream_prepare_request,\n\t.send_request\t\t= xs_tcp_send_request,\n\t.wait_for_reply_request\t= xprt_wait_for_reply_request_def,\n\t.close\t\t\t= xs_tcp_shutdown,\n\t.destroy\t\t= xs_destroy,\n\t.set_connect_timeout\t= xs_tcp_set_connect_timeout,\n\t.print_stats\t\t= xs_tcp_print_stats,\n\t.enable_swap\t\t= xs_enable_swap,\n\t.disable_swap\t\t= xs_disable_swap,\n\t.inject_disconnect\t= xs_inject_disconnect,\n#ifdef CONFIG_SUNRPC_BACKCHANNEL\n\t.bc_setup\t\t= xprt_setup_bc,\n\t.bc_maxpayload\t\t= xs_tcp_bc_maxpayload,\n\t.bc_num_slots\t\t= xprt_bc_max_slots,\n\t.bc_free_rqst\t\t= xprt_free_bc_rqst,\n\t.bc_destroy\t\t= xprt_destroy_bc,\n#endif\n};\n\n \n\nstatic const struct rpc_xprt_ops bc_tcp_ops = {\n\t.reserve_xprt\t\t= xprt_reserve_xprt,\n\t.release_xprt\t\t= xprt_release_xprt,\n\t.alloc_slot\t\t= xprt_alloc_slot,\n\t.free_slot\t\t= xprt_free_slot,\n\t.buf_alloc\t\t= bc_malloc,\n\t.buf_free\t\t= bc_free,\n\t.send_request\t\t= bc_send_request,\n\t.wait_for_reply_request\t= xprt_wait_for_reply_request_def,\n\t.close\t\t\t= bc_close,\n\t.destroy\t\t= bc_destroy,\n\t.print_stats\t\t= xs_tcp_print_stats,\n\t.enable_swap\t\t= xs_enable_swap,\n\t.disable_swap\t\t= xs_disable_swap,\n\t.inject_disconnect\t= xs_inject_disconnect,\n};\n\nstatic int xs_init_anyaddr(const int family, struct sockaddr *sap)\n{\n\tstatic const struct sockaddr_in sin = {\n\t\t.sin_family\t\t= AF_INET,\n\t\t.sin_addr.s_addr\t= htonl(INADDR_ANY),\n\t};\n\tstatic const struct sockaddr_in6 sin6 = {\n\t\t.sin6_family\t\t= AF_INET6,\n\t\t.sin6_addr\t\t= IN6ADDR_ANY_INIT,\n\t};\n\n\tswitch (family) {\n\tcase AF_LOCAL:\n\t\tbreak;\n\tcase AF_INET:\n\t\tmemcpy(sap, &sin, sizeof(sin));\n\t\tbreak;\n\tcase AF_INET6:\n\t\tmemcpy(sap, &sin6, sizeof(sin6));\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"RPC:       %s: Bad address family\\n\", __func__);\n\t\treturn -EAFNOSUPPORT;\n\t}\n\treturn 0;\n}\n\nstatic struct rpc_xprt *xs_setup_xprt(struct xprt_create *args,\n\t\t\t\t      unsigned int slot_table_size,\n\t\t\t\t      unsigned int max_slot_table_size)\n{\n\tstruct rpc_xprt *xprt;\n\tstruct sock_xprt *new;\n\n\tif (args->addrlen > sizeof(xprt->addr)) {\n\t\tdprintk(\"RPC:       xs_setup_xprt: address too large\\n\");\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\txprt = xprt_alloc(args->net, sizeof(*new), slot_table_size,\n\t\t\tmax_slot_table_size);\n\tif (xprt == NULL) {\n\t\tdprintk(\"RPC:       xs_setup_xprt: couldn't allocate \"\n\t\t\t\t\"rpc_xprt\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnew = container_of(xprt, struct sock_xprt, xprt);\n\tmutex_init(&new->recv_mutex);\n\tmemcpy(&xprt->addr, args->dstaddr, args->addrlen);\n\txprt->addrlen = args->addrlen;\n\tif (args->srcaddr)\n\t\tmemcpy(&new->srcaddr, args->srcaddr, args->addrlen);\n\telse {\n\t\tint err;\n\t\terr = xs_init_anyaddr(args->dstaddr->sa_family,\n\t\t\t\t\t(struct sockaddr *)&new->srcaddr);\n\t\tif (err != 0) {\n\t\t\txprt_free(xprt);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\treturn xprt;\n}\n\nstatic const struct rpc_timeout xs_local_default_timeout = {\n\t.to_initval = 10 * HZ,\n\t.to_maxval = 10 * HZ,\n\t.to_retries = 2,\n};\n\n \nstatic struct rpc_xprt *xs_setup_local(struct xprt_create *args)\n{\n\tstruct sockaddr_un *sun = (struct sockaddr_un *)args->dstaddr;\n\tstruct sock_xprt *transport;\n\tstruct rpc_xprt *xprt;\n\tstruct rpc_xprt *ret;\n\n\txprt = xs_setup_xprt(args, xprt_tcp_slot_table_entries,\n\t\t\txprt_max_tcp_slot_table_entries);\n\tif (IS_ERR(xprt))\n\t\treturn xprt;\n\ttransport = container_of(xprt, struct sock_xprt, xprt);\n\n\txprt->prot = 0;\n\txprt->xprt_class = &xs_local_transport;\n\txprt->max_payload = RPC_MAX_FRAGMENT_SIZE;\n\n\txprt->bind_timeout = XS_BIND_TO;\n\txprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;\n\txprt->idle_timeout = XS_IDLE_DISC_TO;\n\n\txprt->ops = &xs_local_ops;\n\txprt->timeout = &xs_local_default_timeout;\n\n\tINIT_WORK(&transport->recv_worker, xs_stream_data_receive_workfn);\n\tINIT_WORK(&transport->error_worker, xs_error_handle);\n\tINIT_DELAYED_WORK(&transport->connect_worker, xs_dummy_setup_socket);\n\n\tswitch (sun->sun_family) {\n\tcase AF_LOCAL:\n\t\tif (sun->sun_path[0] != '/' && sun->sun_path[0] != '\\0') {\n\t\t\tdprintk(\"RPC:       bad AF_LOCAL address: %s\\n\",\n\t\t\t\t\tsun->sun_path);\n\t\t\tret = ERR_PTR(-EINVAL);\n\t\t\tgoto out_err;\n\t\t}\n\t\txprt_set_bound(xprt);\n\t\txs_format_peer_addresses(xprt, \"local\", RPCBIND_NETID_LOCAL);\n\t\tbreak;\n\tdefault:\n\t\tret = ERR_PTR(-EAFNOSUPPORT);\n\t\tgoto out_err;\n\t}\n\n\tdprintk(\"RPC:       set up xprt to %s via AF_LOCAL\\n\",\n\t\t\txprt->address_strings[RPC_DISPLAY_ADDR]);\n\n\tif (try_module_get(THIS_MODULE))\n\t\treturn xprt;\n\tret = ERR_PTR(-EINVAL);\nout_err:\n\txs_xprt_free(xprt);\n\treturn ret;\n}\n\nstatic const struct rpc_timeout xs_udp_default_timeout = {\n\t.to_initval = 5 * HZ,\n\t.to_maxval = 30 * HZ,\n\t.to_increment = 5 * HZ,\n\t.to_retries = 5,\n};\n\n \nstatic struct rpc_xprt *xs_setup_udp(struct xprt_create *args)\n{\n\tstruct sockaddr *addr = args->dstaddr;\n\tstruct rpc_xprt *xprt;\n\tstruct sock_xprt *transport;\n\tstruct rpc_xprt *ret;\n\n\txprt = xs_setup_xprt(args, xprt_udp_slot_table_entries,\n\t\t\txprt_udp_slot_table_entries);\n\tif (IS_ERR(xprt))\n\t\treturn xprt;\n\ttransport = container_of(xprt, struct sock_xprt, xprt);\n\n\txprt->prot = IPPROTO_UDP;\n\txprt->xprt_class = &xs_udp_transport;\n\t \n\txprt->max_payload = (1U << 16) - (MAX_HEADER << 3);\n\n\txprt->bind_timeout = XS_BIND_TO;\n\txprt->reestablish_timeout = XS_UDP_REEST_TO;\n\txprt->idle_timeout = XS_IDLE_DISC_TO;\n\n\txprt->ops = &xs_udp_ops;\n\n\txprt->timeout = &xs_udp_default_timeout;\n\n\tINIT_WORK(&transport->recv_worker, xs_udp_data_receive_workfn);\n\tINIT_WORK(&transport->error_worker, xs_error_handle);\n\tINIT_DELAYED_WORK(&transport->connect_worker, xs_udp_setup_socket);\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tif (((struct sockaddr_in *)addr)->sin_port != htons(0))\n\t\t\txprt_set_bound(xprt);\n\n\t\txs_format_peer_addresses(xprt, \"udp\", RPCBIND_NETID_UDP);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (((struct sockaddr_in6 *)addr)->sin6_port != htons(0))\n\t\t\txprt_set_bound(xprt);\n\n\t\txs_format_peer_addresses(xprt, \"udp\", RPCBIND_NETID_UDP6);\n\t\tbreak;\n\tdefault:\n\t\tret = ERR_PTR(-EAFNOSUPPORT);\n\t\tgoto out_err;\n\t}\n\n\tif (xprt_bound(xprt))\n\t\tdprintk(\"RPC:       set up xprt to %s (port %s) via %s\\n\",\n\t\t\t\txprt->address_strings[RPC_DISPLAY_ADDR],\n\t\t\t\txprt->address_strings[RPC_DISPLAY_PORT],\n\t\t\t\txprt->address_strings[RPC_DISPLAY_PROTO]);\n\telse\n\t\tdprintk(\"RPC:       set up xprt to %s (autobind) via %s\\n\",\n\t\t\t\txprt->address_strings[RPC_DISPLAY_ADDR],\n\t\t\t\txprt->address_strings[RPC_DISPLAY_PROTO]);\n\n\tif (try_module_get(THIS_MODULE))\n\t\treturn xprt;\n\tret = ERR_PTR(-EINVAL);\nout_err:\n\txs_xprt_free(xprt);\n\treturn ret;\n}\n\nstatic const struct rpc_timeout xs_tcp_default_timeout = {\n\t.to_initval = 60 * HZ,\n\t.to_maxval = 60 * HZ,\n\t.to_retries = 2,\n};\n\n \nstatic struct rpc_xprt *xs_setup_tcp(struct xprt_create *args)\n{\n\tstruct sockaddr *addr = args->dstaddr;\n\tstruct rpc_xprt *xprt;\n\tstruct sock_xprt *transport;\n\tstruct rpc_xprt *ret;\n\tunsigned int max_slot_table_size = xprt_max_tcp_slot_table_entries;\n\n\tif (args->flags & XPRT_CREATE_INFINITE_SLOTS)\n\t\tmax_slot_table_size = RPC_MAX_SLOT_TABLE_LIMIT;\n\n\txprt = xs_setup_xprt(args, xprt_tcp_slot_table_entries,\n\t\t\tmax_slot_table_size);\n\tif (IS_ERR(xprt))\n\t\treturn xprt;\n\ttransport = container_of(xprt, struct sock_xprt, xprt);\n\n\txprt->prot = IPPROTO_TCP;\n\txprt->xprt_class = &xs_tcp_transport;\n\txprt->max_payload = RPC_MAX_FRAGMENT_SIZE;\n\n\txprt->bind_timeout = XS_BIND_TO;\n\txprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;\n\txprt->idle_timeout = XS_IDLE_DISC_TO;\n\n\txprt->ops = &xs_tcp_ops;\n\txprt->timeout = &xs_tcp_default_timeout;\n\n\txprt->max_reconnect_timeout = xprt->timeout->to_maxval;\n\tif (args->reconnect_timeout)\n\t\txprt->max_reconnect_timeout = args->reconnect_timeout;\n\n\txprt->connect_timeout = xprt->timeout->to_initval *\n\t\t(xprt->timeout->to_retries + 1);\n\tif (args->connect_timeout)\n\t\txs_tcp_do_set_connect_timeout(xprt, args->connect_timeout);\n\n\tINIT_WORK(&transport->recv_worker, xs_stream_data_receive_workfn);\n\tINIT_WORK(&transport->error_worker, xs_error_handle);\n\tINIT_DELAYED_WORK(&transport->connect_worker, xs_tcp_setup_socket);\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tif (((struct sockaddr_in *)addr)->sin_port != htons(0))\n\t\t\txprt_set_bound(xprt);\n\n\t\txs_format_peer_addresses(xprt, \"tcp\", RPCBIND_NETID_TCP);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (((struct sockaddr_in6 *)addr)->sin6_port != htons(0))\n\t\t\txprt_set_bound(xprt);\n\n\t\txs_format_peer_addresses(xprt, \"tcp\", RPCBIND_NETID_TCP6);\n\t\tbreak;\n\tdefault:\n\t\tret = ERR_PTR(-EAFNOSUPPORT);\n\t\tgoto out_err;\n\t}\n\n\tif (xprt_bound(xprt))\n\t\tdprintk(\"RPC:       set up xprt to %s (port %s) via %s\\n\",\n\t\t\t\txprt->address_strings[RPC_DISPLAY_ADDR],\n\t\t\t\txprt->address_strings[RPC_DISPLAY_PORT],\n\t\t\t\txprt->address_strings[RPC_DISPLAY_PROTO]);\n\telse\n\t\tdprintk(\"RPC:       set up xprt to %s (autobind) via %s\\n\",\n\t\t\t\txprt->address_strings[RPC_DISPLAY_ADDR],\n\t\t\t\txprt->address_strings[RPC_DISPLAY_PROTO]);\n\n\tif (try_module_get(THIS_MODULE))\n\t\treturn xprt;\n\tret = ERR_PTR(-EINVAL);\nout_err:\n\txs_xprt_free(xprt);\n\treturn ret;\n}\n\n \nstatic struct rpc_xprt *xs_setup_tcp_tls(struct xprt_create *args)\n{\n\tstruct sockaddr *addr = args->dstaddr;\n\tstruct rpc_xprt *xprt;\n\tstruct sock_xprt *transport;\n\tstruct rpc_xprt *ret;\n\tunsigned int max_slot_table_size = xprt_max_tcp_slot_table_entries;\n\n\tif (args->flags & XPRT_CREATE_INFINITE_SLOTS)\n\t\tmax_slot_table_size = RPC_MAX_SLOT_TABLE_LIMIT;\n\n\txprt = xs_setup_xprt(args, xprt_tcp_slot_table_entries,\n\t\t\t     max_slot_table_size);\n\tif (IS_ERR(xprt))\n\t\treturn xprt;\n\ttransport = container_of(xprt, struct sock_xprt, xprt);\n\n\txprt->prot = IPPROTO_TCP;\n\txprt->xprt_class = &xs_tcp_transport;\n\txprt->max_payload = RPC_MAX_FRAGMENT_SIZE;\n\n\txprt->bind_timeout = XS_BIND_TO;\n\txprt->reestablish_timeout = XS_TCP_INIT_REEST_TO;\n\txprt->idle_timeout = XS_IDLE_DISC_TO;\n\n\txprt->ops = &xs_tcp_ops;\n\txprt->timeout = &xs_tcp_default_timeout;\n\n\txprt->max_reconnect_timeout = xprt->timeout->to_maxval;\n\txprt->connect_timeout = xprt->timeout->to_initval *\n\t\t(xprt->timeout->to_retries + 1);\n\n\tINIT_WORK(&transport->recv_worker, xs_stream_data_receive_workfn);\n\tINIT_WORK(&transport->error_worker, xs_error_handle);\n\n\tswitch (args->xprtsec.policy) {\n\tcase RPC_XPRTSEC_TLS_ANON:\n\tcase RPC_XPRTSEC_TLS_X509:\n\t\txprt->xprtsec = args->xprtsec;\n\t\tINIT_DELAYED_WORK(&transport->connect_worker,\n\t\t\t\t  xs_tcp_tls_setup_socket);\n\t\tbreak;\n\tdefault:\n\t\tret = ERR_PTR(-EACCES);\n\t\tgoto out_err;\n\t}\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tif (((struct sockaddr_in *)addr)->sin_port != htons(0))\n\t\t\txprt_set_bound(xprt);\n\n\t\txs_format_peer_addresses(xprt, \"tcp\", RPCBIND_NETID_TCP);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (((struct sockaddr_in6 *)addr)->sin6_port != htons(0))\n\t\t\txprt_set_bound(xprt);\n\n\t\txs_format_peer_addresses(xprt, \"tcp\", RPCBIND_NETID_TCP6);\n\t\tbreak;\n\tdefault:\n\t\tret = ERR_PTR(-EAFNOSUPPORT);\n\t\tgoto out_err;\n\t}\n\n\tif (xprt_bound(xprt))\n\t\tdprintk(\"RPC:       set up xprt to %s (port %s) via %s\\n\",\n\t\t\txprt->address_strings[RPC_DISPLAY_ADDR],\n\t\t\txprt->address_strings[RPC_DISPLAY_PORT],\n\t\t\txprt->address_strings[RPC_DISPLAY_PROTO]);\n\telse\n\t\tdprintk(\"RPC:       set up xprt to %s (autobind) via %s\\n\",\n\t\t\txprt->address_strings[RPC_DISPLAY_ADDR],\n\t\t\txprt->address_strings[RPC_DISPLAY_PROTO]);\n\n\tif (try_module_get(THIS_MODULE))\n\t\treturn xprt;\n\tret = ERR_PTR(-EINVAL);\nout_err:\n\txs_xprt_free(xprt);\n\treturn ret;\n}\n\n \nstatic struct rpc_xprt *xs_setup_bc_tcp(struct xprt_create *args)\n{\n\tstruct sockaddr *addr = args->dstaddr;\n\tstruct rpc_xprt *xprt;\n\tstruct sock_xprt *transport;\n\tstruct svc_sock *bc_sock;\n\tstruct rpc_xprt *ret;\n\n\txprt = xs_setup_xprt(args, xprt_tcp_slot_table_entries,\n\t\t\txprt_tcp_slot_table_entries);\n\tif (IS_ERR(xprt))\n\t\treturn xprt;\n\ttransport = container_of(xprt, struct sock_xprt, xprt);\n\n\txprt->prot = IPPROTO_TCP;\n\txprt->xprt_class = &xs_bc_tcp_transport;\n\txprt->max_payload = RPC_MAX_FRAGMENT_SIZE;\n\txprt->timeout = &xs_tcp_default_timeout;\n\n\t \n\txprt_set_bound(xprt);\n\txprt->bind_timeout = 0;\n\txprt->reestablish_timeout = 0;\n\txprt->idle_timeout = 0;\n\n\txprt->ops = &bc_tcp_ops;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\txs_format_peer_addresses(xprt, \"tcp\",\n\t\t\t\t\t RPCBIND_NETID_TCP);\n\t\tbreak;\n\tcase AF_INET6:\n\t\txs_format_peer_addresses(xprt, \"tcp\",\n\t\t\t\t   RPCBIND_NETID_TCP6);\n\t\tbreak;\n\tdefault:\n\t\tret = ERR_PTR(-EAFNOSUPPORT);\n\t\tgoto out_err;\n\t}\n\n\tdprintk(\"RPC:       set up xprt to %s (port %s) via %s\\n\",\n\t\t\txprt->address_strings[RPC_DISPLAY_ADDR],\n\t\t\txprt->address_strings[RPC_DISPLAY_PORT],\n\t\t\txprt->address_strings[RPC_DISPLAY_PROTO]);\n\n\t \n\txprt_get(xprt);\n\targs->bc_xprt->xpt_bc_xprt = xprt;\n\txprt->bc_xprt = args->bc_xprt;\n\tbc_sock = container_of(args->bc_xprt, struct svc_sock, sk_xprt);\n\ttransport->sock = bc_sock->sk_sock;\n\ttransport->inet = bc_sock->sk_sk;\n\n\t \n\txprt_set_connected(xprt);\n\n\tif (try_module_get(THIS_MODULE))\n\t\treturn xprt;\n\n\targs->bc_xprt->xpt_bc_xprt = NULL;\n\targs->bc_xprt->xpt_bc_xps = NULL;\n\txprt_put(xprt);\n\tret = ERR_PTR(-EINVAL);\nout_err:\n\txs_xprt_free(xprt);\n\treturn ret;\n}\n\nstatic struct xprt_class\txs_local_transport = {\n\t.list\t\t= LIST_HEAD_INIT(xs_local_transport.list),\n\t.name\t\t= \"named UNIX socket\",\n\t.owner\t\t= THIS_MODULE,\n\t.ident\t\t= XPRT_TRANSPORT_LOCAL,\n\t.setup\t\t= xs_setup_local,\n\t.netid\t\t= { \"\" },\n};\n\nstatic struct xprt_class\txs_udp_transport = {\n\t.list\t\t= LIST_HEAD_INIT(xs_udp_transport.list),\n\t.name\t\t= \"udp\",\n\t.owner\t\t= THIS_MODULE,\n\t.ident\t\t= XPRT_TRANSPORT_UDP,\n\t.setup\t\t= xs_setup_udp,\n\t.netid\t\t= { \"udp\", \"udp6\", \"\" },\n};\n\nstatic struct xprt_class\txs_tcp_transport = {\n\t.list\t\t= LIST_HEAD_INIT(xs_tcp_transport.list),\n\t.name\t\t= \"tcp\",\n\t.owner\t\t= THIS_MODULE,\n\t.ident\t\t= XPRT_TRANSPORT_TCP,\n\t.setup\t\t= xs_setup_tcp,\n\t.netid\t\t= { \"tcp\", \"tcp6\", \"\" },\n};\n\nstatic struct xprt_class\txs_tcp_tls_transport = {\n\t.list\t\t= LIST_HEAD_INIT(xs_tcp_tls_transport.list),\n\t.name\t\t= \"tcp-with-tls\",\n\t.owner\t\t= THIS_MODULE,\n\t.ident\t\t= XPRT_TRANSPORT_TCP_TLS,\n\t.setup\t\t= xs_setup_tcp_tls,\n\t.netid\t\t= { \"tcp\", \"tcp6\", \"\" },\n};\n\nstatic struct xprt_class\txs_bc_tcp_transport = {\n\t.list\t\t= LIST_HEAD_INIT(xs_bc_tcp_transport.list),\n\t.name\t\t= \"tcp NFSv4.1 backchannel\",\n\t.owner\t\t= THIS_MODULE,\n\t.ident\t\t= XPRT_TRANSPORT_BC_TCP,\n\t.setup\t\t= xs_setup_bc_tcp,\n\t.netid\t\t= { \"\" },\n};\n\n \nint init_socket_xprt(void)\n{\n\tif (!sunrpc_table_header)\n\t\tsunrpc_table_header = register_sysctl(\"sunrpc\", xs_tunables_table);\n\n\txprt_register_transport(&xs_local_transport);\n\txprt_register_transport(&xs_udp_transport);\n\txprt_register_transport(&xs_tcp_transport);\n\txprt_register_transport(&xs_tcp_tls_transport);\n\txprt_register_transport(&xs_bc_tcp_transport);\n\n\treturn 0;\n}\n\n \nvoid cleanup_socket_xprt(void)\n{\n\tif (sunrpc_table_header) {\n\t\tunregister_sysctl_table(sunrpc_table_header);\n\t\tsunrpc_table_header = NULL;\n\t}\n\n\txprt_unregister_transport(&xs_local_transport);\n\txprt_unregister_transport(&xs_udp_transport);\n\txprt_unregister_transport(&xs_tcp_transport);\n\txprt_unregister_transport(&xs_tcp_tls_transport);\n\txprt_unregister_transport(&xs_bc_tcp_transport);\n}\n\nstatic int param_set_portnr(const char *val, const struct kernel_param *kp)\n{\n\treturn param_set_uint_minmax(val, kp,\n\t\t\tRPC_MIN_RESVPORT,\n\t\t\tRPC_MAX_RESVPORT);\n}\n\nstatic const struct kernel_param_ops param_ops_portnr = {\n\t.set = param_set_portnr,\n\t.get = param_get_uint,\n};\n\n#define param_check_portnr(name, p) \\\n\t__param_check(name, p, unsigned int);\n\nmodule_param_named(min_resvport, xprt_min_resvport, portnr, 0644);\nmodule_param_named(max_resvport, xprt_max_resvport, portnr, 0644);\n\nstatic int param_set_slot_table_size(const char *val,\n\t\t\t\t     const struct kernel_param *kp)\n{\n\treturn param_set_uint_minmax(val, kp,\n\t\t\tRPC_MIN_SLOT_TABLE,\n\t\t\tRPC_MAX_SLOT_TABLE);\n}\n\nstatic const struct kernel_param_ops param_ops_slot_table_size = {\n\t.set = param_set_slot_table_size,\n\t.get = param_get_uint,\n};\n\n#define param_check_slot_table_size(name, p) \\\n\t__param_check(name, p, unsigned int);\n\nstatic int param_set_max_slot_table_size(const char *val,\n\t\t\t\t     const struct kernel_param *kp)\n{\n\treturn param_set_uint_minmax(val, kp,\n\t\t\tRPC_MIN_SLOT_TABLE,\n\t\t\tRPC_MAX_SLOT_TABLE_LIMIT);\n}\n\nstatic const struct kernel_param_ops param_ops_max_slot_table_size = {\n\t.set = param_set_max_slot_table_size,\n\t.get = param_get_uint,\n};\n\n#define param_check_max_slot_table_size(name, p) \\\n\t__param_check(name, p, unsigned int);\n\nmodule_param_named(tcp_slot_table_entries, xprt_tcp_slot_table_entries,\n\t\t   slot_table_size, 0644);\nmodule_param_named(tcp_max_slot_table_entries, xprt_max_tcp_slot_table_entries,\n\t\t   max_slot_table_size, 0644);\nmodule_param_named(udp_slot_table_entries, xprt_udp_slot_table_entries,\n\t\t   slot_table_size, 0644);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}