{
  "module_name": "auth_unix.c",
  "hash_id": "a087eee3af1373c964e2740235afd784599e8334c621dcf60553e97424cf1dbb",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth_unix.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/mempool.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/user_namespace.h>\n\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n# define RPCDBG_FACILITY\tRPCDBG_AUTH\n#endif\n\nstatic struct rpc_auth\t\tunix_auth;\nstatic const struct rpc_credops\tunix_credops;\nstatic mempool_t\t\t*unix_pool;\n\nstatic struct rpc_auth *\nunx_create(const struct rpc_auth_create_args *args, struct rpc_clnt *clnt)\n{\n\trefcount_inc(&unix_auth.au_count);\n\treturn &unix_auth;\n}\n\nstatic void\nunx_destroy(struct rpc_auth *auth)\n{\n}\n\n \nstatic struct rpc_cred *unx_lookup_cred(struct rpc_auth *auth,\n\t\t\t\t\tstruct auth_cred *acred, int flags)\n{\n\tstruct rpc_cred *ret;\n\n\tret = kmalloc(sizeof(*ret), rpc_task_gfp_mask());\n\tif (!ret) {\n\t\tif (!(flags & RPCAUTH_LOOKUP_ASYNC))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tret = mempool_alloc(unix_pool, GFP_NOWAIT);\n\t\tif (!ret)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\trpcauth_init_cred(ret, acred, auth, &unix_credops);\n\tret->cr_flags = 1UL << RPCAUTH_CRED_UPTODATE;\n\treturn ret;\n}\n\nstatic void\nunx_free_cred_callback(struct rcu_head *head)\n{\n\tstruct rpc_cred *rpc_cred = container_of(head, struct rpc_cred, cr_rcu);\n\n\tput_cred(rpc_cred->cr_cred);\n\tmempool_free(rpc_cred, unix_pool);\n}\n\nstatic void\nunx_destroy_cred(struct rpc_cred *cred)\n{\n\tcall_rcu(&cred->cr_rcu, unx_free_cred_callback);\n}\n\n \nstatic int\nunx_match(struct auth_cred *acred, struct rpc_cred *cred, int flags)\n{\n\tunsigned int groups = 0;\n\tunsigned int i;\n\n\tif (cred->cr_cred == acred->cred)\n\t\treturn 1;\n\n\tif (!uid_eq(cred->cr_cred->fsuid, acred->cred->fsuid) || !gid_eq(cred->cr_cred->fsgid, acred->cred->fsgid))\n\t\treturn 0;\n\n\tif (acred->cred->group_info != NULL)\n\t\tgroups = acred->cred->group_info->ngroups;\n\tif (groups > UNX_NGROUPS)\n\t\tgroups = UNX_NGROUPS;\n\tif (cred->cr_cred->group_info == NULL)\n\t\treturn groups == 0;\n\tif (groups != cred->cr_cred->group_info->ngroups)\n\t\treturn 0;\n\n\tfor (i = 0; i < groups ; i++)\n\t\tif (!gid_eq(cred->cr_cred->group_info->gid[i], acred->cred->group_info->gid[i]))\n\t\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int\nunx_marshal(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tstruct rpc_clnt\t*clnt = task->tk_client;\n\tstruct rpc_cred\t*cred = task->tk_rqstp->rq_cred;\n\t__be32\t\t*p, *cred_len, *gidarr_len;\n\tint\t\ti;\n\tstruct group_info *gi = cred->cr_cred->group_info;\n\tstruct user_namespace *userns = clnt->cl_cred ?\n\t\tclnt->cl_cred->user_ns : &init_user_ns;\n\n\t \n\n\tp = xdr_reserve_space(xdr, 3 * sizeof(*p));\n\tif (!p)\n\t\tgoto marshal_failed;\n\t*p++ = rpc_auth_unix;\n\tcred_len = p++;\n\t*p++ = xdr_zero;\t \n\tif (xdr_stream_encode_opaque(xdr, clnt->cl_nodename,\n\t\t\t\t     clnt->cl_nodelen) < 0)\n\t\tgoto marshal_failed;\n\tp = xdr_reserve_space(xdr, 3 * sizeof(*p));\n\tif (!p)\n\t\tgoto marshal_failed;\n\t*p++ = cpu_to_be32(from_kuid_munged(userns, cred->cr_cred->fsuid));\n\t*p++ = cpu_to_be32(from_kgid_munged(userns, cred->cr_cred->fsgid));\n\n\tgidarr_len = p++;\n\tif (gi)\n\t\tfor (i = 0; i < UNX_NGROUPS && i < gi->ngroups; i++)\n\t\t\t*p++ = cpu_to_be32(from_kgid_munged(userns, gi->gid[i]));\n\t*gidarr_len = cpu_to_be32(p - gidarr_len - 1);\n\t*cred_len = cpu_to_be32((p - cred_len - 1) << 2);\n\tp = xdr_reserve_space(xdr, (p - gidarr_len - 1) << 2);\n\tif (!p)\n\t\tgoto marshal_failed;\n\n\t \n\n\tp = xdr_reserve_space(xdr, 2 * sizeof(*p));\n\tif (!p)\n\t\tgoto marshal_failed;\n\t*p++ = rpc_auth_null;\n\t*p   = xdr_zero;\n\n\treturn 0;\n\nmarshal_failed:\n\treturn -EMSGSIZE;\n}\n\n \nstatic int\nunx_refresh(struct rpc_task *task)\n{\n\tset_bit(RPCAUTH_CRED_UPTODATE, &task->tk_rqstp->rq_cred->cr_flags);\n\treturn 0;\n}\n\nstatic int\nunx_validate(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tstruct rpc_auth *auth = task->tk_rqstp->rq_cred->cr_auth;\n\t__be32 *p;\n\tu32 size;\n\n\tp = xdr_inline_decode(xdr, 2 * sizeof(*p));\n\tif (!p)\n\t\treturn -EIO;\n\tswitch (*p++) {\n\tcase rpc_auth_null:\n\tcase rpc_auth_unix:\n\tcase rpc_auth_short:\n\t\tbreak;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\tsize = be32_to_cpup(p);\n\tif (size > RPC_MAX_AUTH_SIZE)\n\t\treturn -EIO;\n\tp = xdr_inline_decode(xdr, size);\n\tif (!p)\n\t\treturn -EIO;\n\n\tauth->au_verfsize = XDR_QUADLEN(size) + 2;\n\tauth->au_rslack = XDR_QUADLEN(size) + 2;\n\tauth->au_ralign = XDR_QUADLEN(size) + 2;\n\treturn 0;\n}\n\nint __init rpc_init_authunix(void)\n{\n\tunix_pool = mempool_create_kmalloc_pool(16, sizeof(struct rpc_cred));\n\treturn unix_pool ? 0 : -ENOMEM;\n}\n\nvoid rpc_destroy_authunix(void)\n{\n\tmempool_destroy(unix_pool);\n}\n\nconst struct rpc_authops authunix_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.au_flavor\t= RPC_AUTH_UNIX,\n\t.au_name\t= \"UNIX\",\n\t.create\t\t= unx_create,\n\t.destroy\t= unx_destroy,\n\t.lookup_cred\t= unx_lookup_cred,\n};\n\nstatic\nstruct rpc_auth\t\tunix_auth = {\n\t.au_cslack\t= UNX_CALLSLACK,\n\t.au_rslack\t= NUL_REPLYSLACK,\n\t.au_verfsize\t= NUL_REPLYSLACK,\n\t.au_ops\t\t= &authunix_ops,\n\t.au_flavor\t= RPC_AUTH_UNIX,\n\t.au_count\t= REFCOUNT_INIT(1),\n};\n\nstatic\nconst struct rpc_credops unix_credops = {\n\t.cr_name\t= \"AUTH_UNIX\",\n\t.crdestroy\t= unx_destroy_cred,\n\t.crmatch\t= unx_match,\n\t.crmarshal\t= unx_marshal,\n\t.crwrap_req\t= rpcauth_wrap_req_encode,\n\t.crrefresh\t= unx_refresh,\n\t.crvalidate\t= unx_validate,\n\t.crunwrap_resp\t= rpcauth_unwrap_resp_decode,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}