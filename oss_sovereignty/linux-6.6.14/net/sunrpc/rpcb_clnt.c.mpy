{
  "module_name": "rpcb_clnt.c",
  "hash_id": "e66135677f33339eb8143b684e6060680d8cf3030f29b4d5b62e0d8c166b0b97",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/rpcb_clnt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/un.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <net/ipv6.h>\n\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/xprtsock.h>\n\n#include <trace/events/sunrpc.h>\n\n#include \"netns.h\"\n\n#define RPCBIND_SOCK_PATHNAME\t\"/var/run/rpcbind.sock\"\n#define RPCBIND_SOCK_ABSTRACT_NAME \"\\0/run/rpcbind.sock\"\n\n#define RPCBIND_PROGRAM\t\t(100000u)\n#define RPCBIND_PORT\t\t(111u)\n\n#define RPCBVERS_2\t\t(2u)\n#define RPCBVERS_3\t\t(3u)\n#define RPCBVERS_4\t\t(4u)\n\nenum {\n\tRPCBPROC_NULL,\n\tRPCBPROC_SET,\n\tRPCBPROC_UNSET,\n\tRPCBPROC_GETPORT,\n\tRPCBPROC_GETADDR = 3,\t\t \n\tRPCBPROC_DUMP,\n\tRPCBPROC_CALLIT,\n\tRPCBPROC_BCAST = 5,\t\t \n\tRPCBPROC_GETTIME,\n\tRPCBPROC_UADDR2TADDR,\n\tRPCBPROC_TADDR2UADDR,\n\tRPCBPROC_GETVERSADDR,\n\tRPCBPROC_INDIRECT,\n\tRPCBPROC_GETADDRLIST,\n\tRPCBPROC_GETSTAT,\n};\n\n \n#define RPCB_OWNER_STRING\t\"0\"\n#define RPCB_MAXOWNERLEN\tsizeof(RPCB_OWNER_STRING)\n\n \n#define RPCB_program_sz\t\t(1)\n#define RPCB_version_sz\t\t(1)\n#define RPCB_protocol_sz\t(1)\n#define RPCB_port_sz\t\t(1)\n#define RPCB_boolean_sz\t\t(1)\n\n#define RPCB_netid_sz\t\t(1 + XDR_QUADLEN(RPCBIND_MAXNETIDLEN))\n#define RPCB_addr_sz\t\t(1 + XDR_QUADLEN(RPCBIND_MAXUADDRLEN))\n#define RPCB_ownerstring_sz\t(1 + XDR_QUADLEN(RPCB_MAXOWNERLEN))\n\n \n#define RPCB_mappingargs_sz\t(RPCB_program_sz + RPCB_version_sz + \\\n\t\t\t\tRPCB_protocol_sz + RPCB_port_sz)\n#define RPCB_getaddrargs_sz\t(RPCB_program_sz + RPCB_version_sz + \\\n\t\t\t\tRPCB_netid_sz + RPCB_addr_sz + \\\n\t\t\t\tRPCB_ownerstring_sz)\n\n#define RPCB_getportres_sz\tRPCB_port_sz\n#define RPCB_setres_sz\t\tRPCB_boolean_sz\n\n \n#define RPCB_getaddrres_sz\tRPCB_addr_sz\n\nstatic void\t\t\trpcb_getport_done(struct rpc_task *, void *);\nstatic void\t\t\trpcb_map_release(void *data);\nstatic const struct rpc_program\trpcb_program;\n\nstruct rpcbind_args {\n\tstruct rpc_xprt *\tr_xprt;\n\n\tu32\t\t\tr_prog;\n\tu32\t\t\tr_vers;\n\tu32\t\t\tr_prot;\n\tunsigned short\t\tr_port;\n\tconst char *\t\tr_netid;\n\tconst char *\t\tr_addr;\n\tconst char *\t\tr_owner;\n\n\tint\t\t\tr_status;\n};\n\nstatic const struct rpc_procinfo rpcb_procedures2[];\nstatic const struct rpc_procinfo rpcb_procedures3[];\nstatic const struct rpc_procinfo rpcb_procedures4[];\n\nstruct rpcb_info {\n\tu32\t\t\trpc_vers;\n\tconst struct rpc_procinfo *rpc_proc;\n};\n\nstatic const struct rpcb_info rpcb_next_version[];\nstatic const struct rpcb_info rpcb_next_version6[];\n\nstatic const struct rpc_call_ops rpcb_getport_ops = {\n\t.rpc_call_done\t\t= rpcb_getport_done,\n\t.rpc_release\t\t= rpcb_map_release,\n};\n\nstatic void rpcb_wake_rpcbind_waiters(struct rpc_xprt *xprt, int status)\n{\n\txprt_clear_binding(xprt);\n\trpc_wake_up_status(&xprt->binding, status);\n}\n\nstatic void rpcb_map_release(void *data)\n{\n\tstruct rpcbind_args *map = data;\n\n\trpcb_wake_rpcbind_waiters(map->r_xprt, map->r_status);\n\txprt_put(map->r_xprt);\n\tkfree(map->r_addr);\n\tkfree(map);\n}\n\nstatic int rpcb_get_local(struct net *net)\n{\n\tint cnt;\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tspin_lock(&sn->rpcb_clnt_lock);\n\tif (sn->rpcb_users)\n\t\tsn->rpcb_users++;\n\tcnt = sn->rpcb_users;\n\tspin_unlock(&sn->rpcb_clnt_lock);\n\n\treturn cnt;\n}\n\nvoid rpcb_put_local(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct rpc_clnt *clnt = sn->rpcb_local_clnt;\n\tstruct rpc_clnt *clnt4 = sn->rpcb_local_clnt4;\n\tint shutdown = 0;\n\n\tspin_lock(&sn->rpcb_clnt_lock);\n\tif (sn->rpcb_users) {\n\t\tif (--sn->rpcb_users == 0) {\n\t\t\tsn->rpcb_local_clnt = NULL;\n\t\t\tsn->rpcb_local_clnt4 = NULL;\n\t\t}\n\t\tshutdown = !sn->rpcb_users;\n\t}\n\tspin_unlock(&sn->rpcb_clnt_lock);\n\n\tif (shutdown) {\n\t\t \n\t\tif (clnt4)\n\t\t\trpc_shutdown_client(clnt4);\n\t\tif (clnt)\n\t\t\trpc_shutdown_client(clnt);\n\t}\n}\n\nstatic void rpcb_set_local(struct net *net, struct rpc_clnt *clnt,\n\t\t\tstruct rpc_clnt *clnt4,\n\t\t\tbool is_af_local)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\t \n\tsn->rpcb_local_clnt = clnt;\n\tsn->rpcb_local_clnt4 = clnt4;\n\tsn->rpcb_is_af_local = is_af_local ? 1 : 0;\n\tsmp_wmb();\n\tsn->rpcb_users = 1;\n}\n\n \n# define SUN_LEN(ptr) (offsetof(struct sockaddr_un, sun_path)\t\t\\\n\t\t      + 1 + strlen((ptr)->sun_path + 1))\n\n \nstatic int rpcb_create_af_local(struct net *net,\n\t\t\t\tconst struct sockaddr_un *addr)\n{\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= net,\n\t\t.protocol\t= XPRT_TRANSPORT_LOCAL,\n\t\t.address\t= (struct sockaddr *)addr,\n\t\t.addrsize\t= SUN_LEN(addr),\n\t\t.servername\t= \"localhost\",\n\t\t.program\t= &rpcb_program,\n\t\t.version\t= RPCBVERS_2,\n\t\t.authflavor\t= RPC_AUTH_NULL,\n\t\t.cred\t\t= current_cred(),\n\t\t \n\t\t.flags\t\t= RPC_CLNT_CREATE_NO_IDLE_TIMEOUT,\n\t};\n\tstruct rpc_clnt *clnt, *clnt4;\n\tint result = 0;\n\n\t \n\tclnt = rpc_create(&args);\n\tif (IS_ERR(clnt)) {\n\t\tresult = PTR_ERR(clnt);\n\t\tgoto out;\n\t}\n\n\tclnt4 = rpc_bind_new_program(clnt, &rpcb_program, RPCBVERS_4);\n\tif (IS_ERR(clnt4))\n\t\tclnt4 = NULL;\n\n\trpcb_set_local(net, clnt, clnt4, true);\n\nout:\n\treturn result;\n}\n\nstatic int rpcb_create_local_abstract(struct net *net)\n{\n\tstatic const struct sockaddr_un rpcb_localaddr_abstract = {\n\t\t.sun_family\t\t= AF_LOCAL,\n\t\t.sun_path\t\t= RPCBIND_SOCK_ABSTRACT_NAME,\n\t};\n\n\treturn rpcb_create_af_local(net, &rpcb_localaddr_abstract);\n}\n\nstatic int rpcb_create_local_unix(struct net *net)\n{\n\tstatic const struct sockaddr_un rpcb_localaddr_unix = {\n\t\t.sun_family\t\t= AF_LOCAL,\n\t\t.sun_path\t\t= RPCBIND_SOCK_PATHNAME,\n\t};\n\n\treturn rpcb_create_af_local(net, &rpcb_localaddr_unix);\n}\n\n \nstatic int rpcb_create_local_net(struct net *net)\n{\n\tstatic const struct sockaddr_in rpcb_inaddr_loopback = {\n\t\t.sin_family\t\t= AF_INET,\n\t\t.sin_addr.s_addr\t= htonl(INADDR_LOOPBACK),\n\t\t.sin_port\t\t= htons(RPCBIND_PORT),\n\t};\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= net,\n\t\t.protocol\t= XPRT_TRANSPORT_TCP,\n\t\t.address\t= (struct sockaddr *)&rpcb_inaddr_loopback,\n\t\t.addrsize\t= sizeof(rpcb_inaddr_loopback),\n\t\t.servername\t= \"localhost\",\n\t\t.program\t= &rpcb_program,\n\t\t.version\t= RPCBVERS_2,\n\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t.cred\t\t= current_cred(),\n\t\t.flags\t\t= RPC_CLNT_CREATE_NOPING,\n\t};\n\tstruct rpc_clnt *clnt, *clnt4;\n\tint result = 0;\n\n\tclnt = rpc_create(&args);\n\tif (IS_ERR(clnt)) {\n\t\tresult = PTR_ERR(clnt);\n\t\tgoto out;\n\t}\n\n\t \n\tclnt4 = rpc_bind_new_program(clnt, &rpcb_program, RPCBVERS_4);\n\tif (IS_ERR(clnt4))\n\t\tclnt4 = NULL;\n\n\trpcb_set_local(net, clnt, clnt4, false);\n\nout:\n\treturn result;\n}\n\n \nint rpcb_create_local(struct net *net)\n{\n\tstatic DEFINE_MUTEX(rpcb_create_local_mutex);\n\tint result = 0;\n\n\tif (rpcb_get_local(net))\n\t\treturn result;\n\n\tmutex_lock(&rpcb_create_local_mutex);\n\tif (rpcb_get_local(net))\n\t\tgoto out;\n\n\tif (rpcb_create_local_abstract(net) != 0 &&\n\t    rpcb_create_local_unix(net) != 0)\n\t\tresult = rpcb_create_local_net(net);\n\nout:\n\tmutex_unlock(&rpcb_create_local_mutex);\n\treturn result;\n}\n\nstatic struct rpc_clnt *rpcb_create(struct net *net, const char *nodename,\n\t\t\t\t    const char *hostname,\n\t\t\t\t    struct sockaddr *srvaddr, size_t salen,\n\t\t\t\t    int proto, u32 version,\n\t\t\t\t    const struct cred *cred,\n\t\t\t\t    const struct rpc_timeout *timeo)\n{\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= net,\n\t\t.protocol\t= proto,\n\t\t.address\t= srvaddr,\n\t\t.addrsize\t= salen,\n\t\t.timeout\t= timeo,\n\t\t.servername\t= hostname,\n\t\t.nodename\t= nodename,\n\t\t.program\t= &rpcb_program,\n\t\t.version\t= version,\n\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t.cred\t\t= cred,\n\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING |\n\t\t\t\t\tRPC_CLNT_CREATE_NONPRIVPORT),\n\t};\n\n\tswitch (srvaddr->sa_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)srvaddr)->sin_port = htons(RPCBIND_PORT);\n\t\tbreak;\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)srvaddr)->sin6_port = htons(RPCBIND_PORT);\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EAFNOSUPPORT);\n\t}\n\n\treturn rpc_create(&args);\n}\n\nstatic int rpcb_register_call(struct sunrpc_net *sn, struct rpc_clnt *clnt, struct rpc_message *msg, bool is_set)\n{\n\tint flags = RPC_TASK_NOCONNECT;\n\tint error, result = 0;\n\n\tif (is_set || !sn->rpcb_is_af_local)\n\t\tflags = RPC_TASK_SOFTCONN;\n\tmsg->rpc_resp = &result;\n\n\terror = rpc_call_sync(clnt, msg, flags);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (!result)\n\t\treturn -EACCES;\n\treturn 0;\n}\n\n \nint rpcb_register(struct net *net, u32 prog, u32 vers, int prot, unsigned short port)\n{\n\tstruct rpcbind_args map = {\n\t\t.r_prog\t\t= prog,\n\t\t.r_vers\t\t= vers,\n\t\t.r_prot\t\t= prot,\n\t\t.r_port\t\t= port,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &map,\n\t};\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tbool is_set = false;\n\n\ttrace_pmap_register(prog, vers, prot, port);\n\n\tmsg.rpc_proc = &rpcb_procedures2[RPCBPROC_UNSET];\n\tif (port != 0) {\n\t\tmsg.rpc_proc = &rpcb_procedures2[RPCBPROC_SET];\n\t\tis_set = true;\n\t}\n\n\treturn rpcb_register_call(sn, sn->rpcb_local_clnt, &msg, is_set);\n}\n\n \nstatic int rpcb_register_inet4(struct sunrpc_net *sn,\n\t\t\t       const struct sockaddr *sap,\n\t\t\t       struct rpc_message *msg)\n{\n\tconst struct sockaddr_in *sin = (const struct sockaddr_in *)sap;\n\tstruct rpcbind_args *map = msg->rpc_argp;\n\tunsigned short port = ntohs(sin->sin_port);\n\tbool is_set = false;\n\tint result;\n\n\tmap->r_addr = rpc_sockaddr2uaddr(sap, GFP_KERNEL);\n\n\tmsg->rpc_proc = &rpcb_procedures4[RPCBPROC_UNSET];\n\tif (port != 0) {\n\t\tmsg->rpc_proc = &rpcb_procedures4[RPCBPROC_SET];\n\t\tis_set = true;\n\t}\n\n\tresult = rpcb_register_call(sn, sn->rpcb_local_clnt4, msg, is_set);\n\tkfree(map->r_addr);\n\treturn result;\n}\n\n \nstatic int rpcb_register_inet6(struct sunrpc_net *sn,\n\t\t\t       const struct sockaddr *sap,\n\t\t\t       struct rpc_message *msg)\n{\n\tconst struct sockaddr_in6 *sin6 = (const struct sockaddr_in6 *)sap;\n\tstruct rpcbind_args *map = msg->rpc_argp;\n\tunsigned short port = ntohs(sin6->sin6_port);\n\tbool is_set = false;\n\tint result;\n\n\tmap->r_addr = rpc_sockaddr2uaddr(sap, GFP_KERNEL);\n\n\tmsg->rpc_proc = &rpcb_procedures4[RPCBPROC_UNSET];\n\tif (port != 0) {\n\t\tmsg->rpc_proc = &rpcb_procedures4[RPCBPROC_SET];\n\t\tis_set = true;\n\t}\n\n\tresult = rpcb_register_call(sn, sn->rpcb_local_clnt4, msg, is_set);\n\tkfree(map->r_addr);\n\treturn result;\n}\n\nstatic int rpcb_unregister_all_protofamilies(struct sunrpc_net *sn,\n\t\t\t\t\t     struct rpc_message *msg)\n{\n\tstruct rpcbind_args *map = msg->rpc_argp;\n\n\ttrace_rpcb_unregister(map->r_prog, map->r_vers, map->r_netid);\n\n\tmap->r_addr = \"\";\n\tmsg->rpc_proc = &rpcb_procedures4[RPCBPROC_UNSET];\n\n\treturn rpcb_register_call(sn, sn->rpcb_local_clnt4, msg, false);\n}\n\n \nint rpcb_v4_register(struct net *net, const u32 program, const u32 version,\n\t\t     const struct sockaddr *address, const char *netid)\n{\n\tstruct rpcbind_args map = {\n\t\t.r_prog\t\t= program,\n\t\t.r_vers\t\t= version,\n\t\t.r_netid\t= netid,\n\t\t.r_owner\t= RPCB_OWNER_STRING,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_argp\t= &map,\n\t};\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tif (sn->rpcb_local_clnt4 == NULL)\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (address == NULL)\n\t\treturn rpcb_unregister_all_protofamilies(sn, &msg);\n\n\ttrace_rpcb_register(map.r_prog, map.r_vers, map.r_addr, map.r_netid);\n\n\tswitch (address->sa_family) {\n\tcase AF_INET:\n\t\treturn rpcb_register_inet4(sn, address, &msg);\n\tcase AF_INET6:\n\t\treturn rpcb_register_inet6(sn, address, &msg);\n\t}\n\n\treturn -EAFNOSUPPORT;\n}\n\nstatic struct rpc_task *rpcb_call_async(struct rpc_clnt *rpcb_clnt,\n\t\tstruct rpcbind_args *map, const struct rpc_procinfo *proc)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = proc,\n\t\t.rpc_argp = map,\n\t\t.rpc_resp = map,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = rpcb_clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &rpcb_getport_ops,\n\t\t.callback_data = map,\n\t\t.flags = RPC_TASK_ASYNC | RPC_TASK_SOFTCONN,\n\t};\n\n\treturn rpc_run_task(&task_setup_data);\n}\n\n \nstatic struct rpc_clnt *rpcb_find_transport_owner(struct rpc_clnt *clnt)\n{\n\tstruct rpc_clnt *parent = clnt->cl_parent;\n\tstruct rpc_xprt_switch *xps = rcu_access_pointer(clnt->cl_xpi.xpi_xpswitch);\n\n\twhile (parent != clnt) {\n\t\tif (rcu_access_pointer(parent->cl_xpi.xpi_xpswitch) != xps)\n\t\t\tbreak;\n\t\tif (clnt->cl_autobind)\n\t\t\tbreak;\n\t\tclnt = parent;\n\t\tparent = parent->cl_parent;\n\t}\n\treturn clnt;\n}\n\n \nvoid rpcb_getport_async(struct rpc_task *task)\n{\n\tstruct rpc_clnt *clnt;\n\tconst struct rpc_procinfo *proc;\n\tu32 bind_version;\n\tstruct rpc_xprt *xprt;\n\tstruct rpc_clnt\t*rpcb_clnt;\n\tstruct rpcbind_args *map;\n\tstruct rpc_task\t*child;\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr *sap = (struct sockaddr *)&addr;\n\tsize_t salen;\n\tint status;\n\n\trcu_read_lock();\n\tclnt = rpcb_find_transport_owner(task->tk_client);\n\trcu_read_unlock();\n\txprt = xprt_get(task->tk_xprt);\n\n\t \n\trpc_sleep_on_timeout(&xprt->binding, task,\n\t\t\tNULL, jiffies + xprt->bind_timeout);\n\n\tif (xprt_test_and_set_binding(xprt)) {\n\t\txprt_put(xprt);\n\t\treturn;\n\t}\n\n\t \n\tif (xprt_bound(xprt)) {\n\t\tstatus = 0;\n\t\tgoto bailout_nofree;\n\t}\n\n\t \n\tsalen = rpc_peeraddr(clnt, sap, sizeof(addr));\n\n\t \n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\tproc = rpcb_next_version[xprt->bind_index].rpc_proc;\n\t\tbind_version = rpcb_next_version[xprt->bind_index].rpc_vers;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tproc = rpcb_next_version6[xprt->bind_index].rpc_proc;\n\t\tbind_version = rpcb_next_version6[xprt->bind_index].rpc_vers;\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EAFNOSUPPORT;\n\t\tgoto bailout_nofree;\n\t}\n\tif (proc == NULL) {\n\t\txprt->bind_index = 0;\n\t\tstatus = -EPFNOSUPPORT;\n\t\tgoto bailout_nofree;\n\t}\n\n\ttrace_rpcb_getport(clnt, task, bind_version);\n\n\trpcb_clnt = rpcb_create(xprt->xprt_net,\n\t\t\t\tclnt->cl_nodename,\n\t\t\t\txprt->servername, sap, salen,\n\t\t\t\txprt->prot, bind_version,\n\t\t\t\tclnt->cl_cred,\n\t\t\t\ttask->tk_client->cl_timeout);\n\tif (IS_ERR(rpcb_clnt)) {\n\t\tstatus = PTR_ERR(rpcb_clnt);\n\t\tgoto bailout_nofree;\n\t}\n\n\tmap = kzalloc(sizeof(struct rpcbind_args), rpc_task_gfp_mask());\n\tif (!map) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bailout_release_client;\n\t}\n\tmap->r_prog = clnt->cl_prog;\n\tmap->r_vers = clnt->cl_vers;\n\tmap->r_prot = xprt->prot;\n\tmap->r_port = 0;\n\tmap->r_xprt = xprt;\n\tmap->r_status = -EIO;\n\n\tswitch (bind_version) {\n\tcase RPCBVERS_4:\n\tcase RPCBVERS_3:\n\t\tmap->r_netid = xprt->address_strings[RPC_DISPLAY_NETID];\n\t\tmap->r_addr = rpc_sockaddr2uaddr(sap, rpc_task_gfp_mask());\n\t\tif (!map->r_addr) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto bailout_free_args;\n\t\t}\n\t\tmap->r_owner = \"\";\n\t\tbreak;\n\tcase RPCBVERS_2:\n\t\tmap->r_addr = NULL;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tchild = rpcb_call_async(rpcb_clnt, map, proc);\n\trpc_release_client(rpcb_clnt);\n\tif (IS_ERR(child)) {\n\t\t \n\t\treturn;\n\t}\n\n\txprt->stat.bind_count++;\n\trpc_put_task(child);\n\treturn;\n\nbailout_free_args:\n\tkfree(map);\nbailout_release_client:\n\trpc_release_client(rpcb_clnt);\nbailout_nofree:\n\trpcb_wake_rpcbind_waiters(xprt, status);\n\ttask->tk_status = status;\n\txprt_put(xprt);\n}\nEXPORT_SYMBOL_GPL(rpcb_getport_async);\n\n \nstatic void rpcb_getport_done(struct rpc_task *child, void *data)\n{\n\tstruct rpcbind_args *map = data;\n\tstruct rpc_xprt *xprt = map->r_xprt;\n\n\tmap->r_status = child->tk_status;\n\n\t \n\tif (map->r_status == -EIO)\n\t\tmap->r_status = -EPROTONOSUPPORT;\n\n\t \n\tif (map->r_status == -EPROTONOSUPPORT)\n\t\txprt->bind_index++;\n\n\tif (map->r_status < 0) {\n\t\t \n\t\tmap->r_port = 0;\n\n\t} else if (map->r_port == 0) {\n\t\t \n\t\tmap->r_status = -EACCES;\n\t} else {\n\t\t \n\t\tmap->r_status = 0;\n\t}\n\n\ttrace_rpcb_setport(child, map->r_status, map->r_port);\n\txprt->ops->set_port(xprt, map->r_port);\n\tif (map->r_port)\n\t\txprt_set_bound(xprt);\n}\n\n \n\nstatic void rpcb_enc_mapping(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t     const void *data)\n{\n\tconst struct rpcbind_args *rpcb = data;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, RPCB_mappingargs_sz << 2);\n\t*p++ = cpu_to_be32(rpcb->r_prog);\n\t*p++ = cpu_to_be32(rpcb->r_vers);\n\t*p++ = cpu_to_be32(rpcb->r_prot);\n\t*p   = cpu_to_be32(rpcb->r_port);\n}\n\nstatic int rpcb_dec_getport(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t    void *data)\n{\n\tstruct rpcbind_args *rpcb = data;\n\tunsigned long port;\n\t__be32 *p;\n\n\trpcb->r_port = 0;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tport = be32_to_cpup(p);\n\tif (unlikely(port > USHRT_MAX))\n\t\treturn -EIO;\n\n\trpcb->r_port = port;\n\treturn 0;\n}\n\nstatic int rpcb_dec_set(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\tvoid *data)\n{\n\tunsigned int *boolp = data;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\t*boolp = 0;\n\tif (*p != xdr_zero)\n\t\t*boolp = 1;\n\treturn 0;\n}\n\nstatic void encode_rpcb_string(struct xdr_stream *xdr, const char *string,\n\t\t\t       const u32 maxstrlen)\n{\n\t__be32 *p;\n\tu32 len;\n\n\tlen = strlen(string);\n\tWARN_ON_ONCE(len > maxstrlen);\n\tif (len > maxstrlen)\n\t\t \n\t\tlen = maxstrlen;\n\tp = xdr_reserve_space(xdr, 4 + len);\n\txdr_encode_opaque(p, string, len);\n}\n\nstatic void rpcb_enc_getaddr(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t     const void *data)\n{\n\tconst struct rpcbind_args *rpcb = data;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, (RPCB_program_sz + RPCB_version_sz) << 2);\n\t*p++ = cpu_to_be32(rpcb->r_prog);\n\t*p = cpu_to_be32(rpcb->r_vers);\n\n\tencode_rpcb_string(xdr, rpcb->r_netid, RPCBIND_MAXNETIDLEN);\n\tencode_rpcb_string(xdr, rpcb->r_addr, RPCBIND_MAXUADDRLEN);\n\tencode_rpcb_string(xdr, rpcb->r_owner, RPCB_MAXOWNERLEN);\n}\n\nstatic int rpcb_dec_getaddr(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t    void *data)\n{\n\tstruct rpcbind_args *rpcb = data;\n\tstruct sockaddr_storage address;\n\tstruct sockaddr *sap = (struct sockaddr *)&address;\n\t__be32 *p;\n\tu32 len;\n\n\trpcb->r_port = 0;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_fail;\n\tlen = be32_to_cpup(p);\n\n\t \n\tif (len == 0)\n\t\treturn 0;\n\n\tif (unlikely(len > RPCBIND_MAXUADDRLEN))\n\t\tgoto out_fail;\n\n\tp = xdr_inline_decode(xdr, len);\n\tif (unlikely(p == NULL))\n\t\tgoto out_fail;\n\n\tif (rpc_uaddr2sockaddr(req->rq_xprt->xprt_net, (char *)p, len,\n\t\t\t\tsap, sizeof(address)) == 0)\n\t\tgoto out_fail;\n\trpcb->r_port = rpc_get_port(sap);\n\n\treturn 0;\n\nout_fail:\n\treturn -EIO;\n}\n\n \n\nstatic const struct rpc_procinfo rpcb_procedures2[] = {\n\t[RPCBPROC_SET] = {\n\t\t.p_proc\t\t= RPCBPROC_SET,\n\t\t.p_encode\t= rpcb_enc_mapping,\n\t\t.p_decode\t= rpcb_dec_set,\n\t\t.p_arglen\t= RPCB_mappingargs_sz,\n\t\t.p_replen\t= RPCB_setres_sz,\n\t\t.p_statidx\t= RPCBPROC_SET,\n\t\t.p_timer\t= 0,\n\t\t.p_name\t\t= \"SET\",\n\t},\n\t[RPCBPROC_UNSET] = {\n\t\t.p_proc\t\t= RPCBPROC_UNSET,\n\t\t.p_encode\t= rpcb_enc_mapping,\n\t\t.p_decode\t= rpcb_dec_set,\n\t\t.p_arglen\t= RPCB_mappingargs_sz,\n\t\t.p_replen\t= RPCB_setres_sz,\n\t\t.p_statidx\t= RPCBPROC_UNSET,\n\t\t.p_timer\t= 0,\n\t\t.p_name\t\t= \"UNSET\",\n\t},\n\t[RPCBPROC_GETPORT] = {\n\t\t.p_proc\t\t= RPCBPROC_GETPORT,\n\t\t.p_encode\t= rpcb_enc_mapping,\n\t\t.p_decode\t= rpcb_dec_getport,\n\t\t.p_arglen\t= RPCB_mappingargs_sz,\n\t\t.p_replen\t= RPCB_getportres_sz,\n\t\t.p_statidx\t= RPCBPROC_GETPORT,\n\t\t.p_timer\t= 0,\n\t\t.p_name\t\t= \"GETPORT\",\n\t},\n};\n\nstatic const struct rpc_procinfo rpcb_procedures3[] = {\n\t[RPCBPROC_SET] = {\n\t\t.p_proc\t\t= RPCBPROC_SET,\n\t\t.p_encode\t= rpcb_enc_getaddr,\n\t\t.p_decode\t= rpcb_dec_set,\n\t\t.p_arglen\t= RPCB_getaddrargs_sz,\n\t\t.p_replen\t= RPCB_setres_sz,\n\t\t.p_statidx\t= RPCBPROC_SET,\n\t\t.p_timer\t= 0,\n\t\t.p_name\t\t= \"SET\",\n\t},\n\t[RPCBPROC_UNSET] = {\n\t\t.p_proc\t\t= RPCBPROC_UNSET,\n\t\t.p_encode\t= rpcb_enc_getaddr,\n\t\t.p_decode\t= rpcb_dec_set,\n\t\t.p_arglen\t= RPCB_getaddrargs_sz,\n\t\t.p_replen\t= RPCB_setres_sz,\n\t\t.p_statidx\t= RPCBPROC_UNSET,\n\t\t.p_timer\t= 0,\n\t\t.p_name\t\t= \"UNSET\",\n\t},\n\t[RPCBPROC_GETADDR] = {\n\t\t.p_proc\t\t= RPCBPROC_GETADDR,\n\t\t.p_encode\t= rpcb_enc_getaddr,\n\t\t.p_decode\t= rpcb_dec_getaddr,\n\t\t.p_arglen\t= RPCB_getaddrargs_sz,\n\t\t.p_replen\t= RPCB_getaddrres_sz,\n\t\t.p_statidx\t= RPCBPROC_GETADDR,\n\t\t.p_timer\t= 0,\n\t\t.p_name\t\t= \"GETADDR\",\n\t},\n};\n\nstatic const struct rpc_procinfo rpcb_procedures4[] = {\n\t[RPCBPROC_SET] = {\n\t\t.p_proc\t\t= RPCBPROC_SET,\n\t\t.p_encode\t= rpcb_enc_getaddr,\n\t\t.p_decode\t= rpcb_dec_set,\n\t\t.p_arglen\t= RPCB_getaddrargs_sz,\n\t\t.p_replen\t= RPCB_setres_sz,\n\t\t.p_statidx\t= RPCBPROC_SET,\n\t\t.p_timer\t= 0,\n\t\t.p_name\t\t= \"SET\",\n\t},\n\t[RPCBPROC_UNSET] = {\n\t\t.p_proc\t\t= RPCBPROC_UNSET,\n\t\t.p_encode\t= rpcb_enc_getaddr,\n\t\t.p_decode\t= rpcb_dec_set,\n\t\t.p_arglen\t= RPCB_getaddrargs_sz,\n\t\t.p_replen\t= RPCB_setres_sz,\n\t\t.p_statidx\t= RPCBPROC_UNSET,\n\t\t.p_timer\t= 0,\n\t\t.p_name\t\t= \"UNSET\",\n\t},\n\t[RPCBPROC_GETADDR] = {\n\t\t.p_proc\t\t= RPCBPROC_GETADDR,\n\t\t.p_encode\t= rpcb_enc_getaddr,\n\t\t.p_decode\t= rpcb_dec_getaddr,\n\t\t.p_arglen\t= RPCB_getaddrargs_sz,\n\t\t.p_replen\t= RPCB_getaddrres_sz,\n\t\t.p_statidx\t= RPCBPROC_GETADDR,\n\t\t.p_timer\t= 0,\n\t\t.p_name\t\t= \"GETADDR\",\n\t},\n};\n\nstatic const struct rpcb_info rpcb_next_version[] = {\n\t{\n\t\t.rpc_vers\t= RPCBVERS_2,\n\t\t.rpc_proc\t= &rpcb_procedures2[RPCBPROC_GETPORT],\n\t},\n\t{\n\t\t.rpc_proc\t= NULL,\n\t},\n};\n\nstatic const struct rpcb_info rpcb_next_version6[] = {\n\t{\n\t\t.rpc_vers\t= RPCBVERS_4,\n\t\t.rpc_proc\t= &rpcb_procedures4[RPCBPROC_GETADDR],\n\t},\n\t{\n\t\t.rpc_vers\t= RPCBVERS_3,\n\t\t.rpc_proc\t= &rpcb_procedures3[RPCBPROC_GETADDR],\n\t},\n\t{\n\t\t.rpc_proc\t= NULL,\n\t},\n};\n\nstatic unsigned int rpcb_version2_counts[ARRAY_SIZE(rpcb_procedures2)];\nstatic const struct rpc_version rpcb_version2 = {\n\t.number\t\t= RPCBVERS_2,\n\t.nrprocs\t= ARRAY_SIZE(rpcb_procedures2),\n\t.procs\t\t= rpcb_procedures2,\n\t.counts\t\t= rpcb_version2_counts,\n};\n\nstatic unsigned int rpcb_version3_counts[ARRAY_SIZE(rpcb_procedures3)];\nstatic const struct rpc_version rpcb_version3 = {\n\t.number\t\t= RPCBVERS_3,\n\t.nrprocs\t= ARRAY_SIZE(rpcb_procedures3),\n\t.procs\t\t= rpcb_procedures3,\n\t.counts\t\t= rpcb_version3_counts,\n};\n\nstatic unsigned int rpcb_version4_counts[ARRAY_SIZE(rpcb_procedures4)];\nstatic const struct rpc_version rpcb_version4 = {\n\t.number\t\t= RPCBVERS_4,\n\t.nrprocs\t= ARRAY_SIZE(rpcb_procedures4),\n\t.procs\t\t= rpcb_procedures4,\n\t.counts\t\t= rpcb_version4_counts,\n};\n\nstatic const struct rpc_version *rpcb_version[] = {\n\tNULL,\n\tNULL,\n\t&rpcb_version2,\n\t&rpcb_version3,\n\t&rpcb_version4\n};\n\nstatic struct rpc_stat rpcb_stats;\n\nstatic const struct rpc_program rpcb_program = {\n\t.name\t\t= \"rpcbind\",\n\t.number\t\t= RPCBIND_PROGRAM,\n\t.nrvers\t\t= ARRAY_SIZE(rpcb_version),\n\t.version\t= rpcb_version,\n\t.stats\t\t= &rpcb_stats,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}