{
  "module_name": "backchannel.c",
  "hash_id": "aa0edb1c2e8d9073bd220d4d5d08b576ea5738ea13daeab4bc83dd833aa71160",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/xprtrdma/backchannel.c",
  "human_readable_source": "\n \n\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svc_rdma.h>\n\n#include \"xprt_rdma.h\"\n#include <trace/events/rpcrdma.h>\n\n#undef RPCRDMA_BACKCHANNEL_DEBUG\n\n \nint xprt_rdma_bc_setup(struct rpc_xprt *xprt, unsigned int reqs)\n{\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\n\tr_xprt->rx_buf.rb_bc_srv_max_requests = RPCRDMA_BACKWARD_WRS >> 1;\n\ttrace_xprtrdma_cb_setup(r_xprt, reqs);\n\treturn 0;\n}\n\n \nsize_t xprt_rdma_bc_maxpayload(struct rpc_xprt *xprt)\n{\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\tstruct rpcrdma_ep *ep = r_xprt->rx_ep;\n\tsize_t maxmsg;\n\n\tmaxmsg = min_t(unsigned int, ep->re_inline_send, ep->re_inline_recv);\n\tmaxmsg = min_t(unsigned int, maxmsg, PAGE_SIZE);\n\treturn maxmsg - RPCRDMA_HDRLEN_MIN;\n}\n\nunsigned int xprt_rdma_bc_max_slots(struct rpc_xprt *xprt)\n{\n\treturn RPCRDMA_BACKWARD_WRS >> 1;\n}\n\nstatic int rpcrdma_bc_marshal_reply(struct rpc_rqst *rqst)\n{\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(rqst->rq_xprt);\n\tstruct rpcrdma_req *req = rpcr_to_rdmar(rqst);\n\t__be32 *p;\n\n\trpcrdma_set_xdrlen(&req->rl_hdrbuf, 0);\n\txdr_init_encode(&req->rl_stream, &req->rl_hdrbuf,\n\t\t\trdmab_data(req->rl_rdmabuf), rqst);\n\n\tp = xdr_reserve_space(&req->rl_stream, 28);\n\tif (unlikely(!p))\n\t\treturn -EIO;\n\t*p++ = rqst->rq_xid;\n\t*p++ = rpcrdma_version;\n\t*p++ = cpu_to_be32(r_xprt->rx_buf.rb_bc_srv_max_requests);\n\t*p++ = rdma_msg;\n\t*p++ = xdr_zero;\n\t*p++ = xdr_zero;\n\t*p = xdr_zero;\n\n\tif (rpcrdma_prepare_send_sges(r_xprt, req, RPCRDMA_HDRLEN_MIN,\n\t\t\t\t      &rqst->rq_snd_buf, rpcrdma_noch_pullup))\n\t\treturn -EIO;\n\n\ttrace_xprtrdma_cb_reply(r_xprt, rqst);\n\treturn 0;\n}\n\n \nint xprt_rdma_bc_send_reply(struct rpc_rqst *rqst)\n{\n\tstruct rpc_xprt *xprt = rqst->rq_xprt;\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\tstruct rpcrdma_req *req = rpcr_to_rdmar(rqst);\n\tint rc;\n\n\tif (!xprt_connected(xprt))\n\t\treturn -ENOTCONN;\n\n\tif (!xprt_request_get_cong(xprt, rqst))\n\t\treturn -EBADSLT;\n\n\trc = rpcrdma_bc_marshal_reply(rqst);\n\tif (rc < 0)\n\t\tgoto failed_marshal;\n\n\tif (frwr_send(r_xprt, req))\n\t\tgoto drop_connection;\n\treturn 0;\n\nfailed_marshal:\n\tif (rc != -ENOTCONN)\n\t\treturn rc;\ndrop_connection:\n\txprt_rdma_close(xprt);\n\treturn -ENOTCONN;\n}\n\n \nvoid xprt_rdma_bc_destroy(struct rpc_xprt *xprt, unsigned int reqs)\n{\n\tstruct rpc_rqst *rqst, *tmp;\n\n\tspin_lock(&xprt->bc_pa_lock);\n\tlist_for_each_entry_safe(rqst, tmp, &xprt->bc_pa_list, rq_bc_pa_list) {\n\t\tlist_del(&rqst->rq_bc_pa_list);\n\t\tspin_unlock(&xprt->bc_pa_lock);\n\n\t\trpcrdma_req_destroy(rpcr_to_rdmar(rqst));\n\n\t\tspin_lock(&xprt->bc_pa_lock);\n\t}\n\tspin_unlock(&xprt->bc_pa_lock);\n}\n\n \nvoid xprt_rdma_bc_free_rqst(struct rpc_rqst *rqst)\n{\n\tstruct rpcrdma_req *req = rpcr_to_rdmar(rqst);\n\tstruct rpcrdma_rep *rep = req->rl_reply;\n\tstruct rpc_xprt *xprt = rqst->rq_xprt;\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\n\trpcrdma_rep_put(&r_xprt->rx_buf, rep);\n\treq->rl_reply = NULL;\n\n\tspin_lock(&xprt->bc_pa_lock);\n\tlist_add_tail(&rqst->rq_bc_pa_list, &xprt->bc_pa_list);\n\tspin_unlock(&xprt->bc_pa_lock);\n\txprt_put(xprt);\n}\n\nstatic struct rpc_rqst *rpcrdma_bc_rqst_get(struct rpcrdma_xprt *r_xprt)\n{\n\tstruct rpc_xprt *xprt = &r_xprt->rx_xprt;\n\tstruct rpcrdma_req *req;\n\tstruct rpc_rqst *rqst;\n\tsize_t size;\n\n\tspin_lock(&xprt->bc_pa_lock);\n\trqst = list_first_entry_or_null(&xprt->bc_pa_list, struct rpc_rqst,\n\t\t\t\t\trq_bc_pa_list);\n\tif (!rqst)\n\t\tgoto create_req;\n\tlist_del(&rqst->rq_bc_pa_list);\n\tspin_unlock(&xprt->bc_pa_lock);\n\treturn rqst;\n\ncreate_req:\n\tspin_unlock(&xprt->bc_pa_lock);\n\n\t \n\tif (xprt->bc_alloc_count >= RPCRDMA_BACKWARD_WRS)\n\t\treturn NULL;\n\n\tsize = min_t(size_t, r_xprt->rx_ep->re_inline_recv, PAGE_SIZE);\n\treq = rpcrdma_req_create(r_xprt, size);\n\tif (!req)\n\t\treturn NULL;\n\tif (rpcrdma_req_setup(r_xprt, req)) {\n\t\trpcrdma_req_destroy(req);\n\t\treturn NULL;\n\t}\n\n\txprt->bc_alloc_count++;\n\trqst = &req->rl_slot;\n\trqst->rq_xprt = xprt;\n\t__set_bit(RPC_BC_PA_IN_USE, &rqst->rq_bc_pa_state);\n\txdr_buf_init(&rqst->rq_snd_buf, rdmab_data(req->rl_sendbuf), size);\n\treturn rqst;\n}\n\n \nvoid rpcrdma_bc_receive_call(struct rpcrdma_xprt *r_xprt,\n\t\t\t     struct rpcrdma_rep *rep)\n{\n\tstruct rpc_xprt *xprt = &r_xprt->rx_xprt;\n\tstruct svc_serv *bc_serv;\n\tstruct rpcrdma_req *req;\n\tstruct rpc_rqst *rqst;\n\tstruct xdr_buf *buf;\n\tsize_t size;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(&rep->rr_stream, 0);\n\tsize = xdr_stream_remaining(&rep->rr_stream);\n\n#ifdef RPCRDMA_BACKCHANNEL_DEBUG\n\tpr_info(\"RPC:       %s: callback XID %08x, length=%u\\n\",\n\t\t__func__, be32_to_cpup(p), size);\n\tpr_info(\"RPC:       %s: %*ph\\n\", __func__, size, p);\n#endif\n\n\trqst = rpcrdma_bc_rqst_get(r_xprt);\n\tif (!rqst)\n\t\tgoto out_overflow;\n\n\trqst->rq_reply_bytes_recvd = 0;\n\trqst->rq_xid = *p;\n\n\trqst->rq_private_buf.len = size;\n\n\tbuf = &rqst->rq_rcv_buf;\n\tmemset(buf, 0, sizeof(*buf));\n\tbuf->head[0].iov_base = p;\n\tbuf->head[0].iov_len = size;\n\tbuf->len = size;\n\n\t \n\treq = rpcr_to_rdmar(rqst);\n\treq->rl_reply = rep;\n\ttrace_xprtrdma_cb_call(r_xprt, rqst);\n\n\t \n\tbc_serv = xprt->bc_serv;\n\txprt_get(xprt);\n\tspin_lock(&bc_serv->sv_cb_lock);\n\tlist_add(&rqst->rq_bc_list, &bc_serv->sv_cb_list);\n\tspin_unlock(&bc_serv->sv_cb_lock);\n\n\twake_up(&bc_serv->sv_cb_waitq);\n\n\tr_xprt->rx_stats.bcall_count++;\n\treturn;\n\nout_overflow:\n\tpr_warn(\"RPC/RDMA backchannel overflow\\n\");\n\txprt_force_disconnect(xprt);\n\t \n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}