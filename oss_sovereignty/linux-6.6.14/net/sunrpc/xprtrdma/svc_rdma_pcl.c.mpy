{
  "module_name": "svc_rdma_pcl.c",
  "hash_id": "cacac0dd98c8ababd8c2274b5b464b61c80b5b4d881c6b7d30f074d0c635eb23",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/xprtrdma/svc_rdma_pcl.c",
  "human_readable_source": "\n \n\n#include <linux/sunrpc/svc_rdma.h>\n#include <linux/sunrpc/rpc_rdma.h>\n\n#include \"xprt_rdma.h\"\n#include <trace/events/rpcrdma.h>\n\n \nvoid pcl_free(struct svc_rdma_pcl *pcl)\n{\n\twhile (!list_empty(&pcl->cl_chunks)) {\n\t\tstruct svc_rdma_chunk *chunk;\n\n\t\tchunk = pcl_first_chunk(pcl);\n\t\tlist_del(&chunk->ch_list);\n\t\tkfree(chunk);\n\t}\n}\n\nstatic struct svc_rdma_chunk *pcl_alloc_chunk(u32 segcount, u32 position)\n{\n\tstruct svc_rdma_chunk *chunk;\n\n\tchunk = kmalloc(struct_size(chunk, ch_segments, segcount), GFP_KERNEL);\n\tif (!chunk)\n\t\treturn NULL;\n\n\tchunk->ch_position = position;\n\tchunk->ch_length = 0;\n\tchunk->ch_payload_length = 0;\n\tchunk->ch_segcount = 0;\n\treturn chunk;\n}\n\nstatic struct svc_rdma_chunk *\npcl_lookup_position(struct svc_rdma_pcl *pcl, u32 position)\n{\n\tstruct svc_rdma_chunk *pos;\n\n\tpcl_for_each_chunk(pos, pcl) {\n\t\tif (pos->ch_position == position)\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstatic void pcl_insert_position(struct svc_rdma_pcl *pcl,\n\t\t\t\tstruct svc_rdma_chunk *chunk)\n{\n\tstruct svc_rdma_chunk *pos;\n\n\tpcl_for_each_chunk(pos, pcl) {\n\t\tif (pos->ch_position > chunk->ch_position)\n\t\t\tbreak;\n\t}\n\t__list_add(&chunk->ch_list, pos->ch_list.prev, &pos->ch_list);\n\tpcl->cl_count++;\n}\n\nstatic void pcl_set_read_segment(const struct svc_rdma_recv_ctxt *rctxt,\n\t\t\t\t struct svc_rdma_chunk *chunk,\n\t\t\t\t u32 handle, u32 length, u64 offset)\n{\n\tstruct svc_rdma_segment *segment;\n\n\tsegment = &chunk->ch_segments[chunk->ch_segcount];\n\tsegment->rs_handle = handle;\n\tsegment->rs_length = length;\n\tsegment->rs_offset = offset;\n\n\ttrace_svcrdma_decode_rseg(&rctxt->rc_cid, chunk, segment);\n\n\tchunk->ch_length += length;\n\tchunk->ch_segcount++;\n}\n\n \nbool pcl_alloc_call(struct svc_rdma_recv_ctxt *rctxt, __be32 *p)\n{\n\tstruct svc_rdma_pcl *pcl = &rctxt->rc_call_pcl;\n\tunsigned int i, segcount = pcl->cl_count;\n\n\tpcl->cl_count = 0;\n\tfor (i = 0; i < segcount; i++) {\n\t\tstruct svc_rdma_chunk *chunk;\n\t\tu32 position, handle, length;\n\t\tu64 offset;\n\n\t\tp++;\t \n\t\tp = xdr_decode_read_segment(p, &position, &handle,\n\t\t\t\t\t    &length, &offset);\n\t\tif (position != 0)\n\t\t\tcontinue;\n\n\t\tif (pcl_is_empty(pcl)) {\n\t\t\tchunk = pcl_alloc_chunk(segcount, position);\n\t\t\tif (!chunk)\n\t\t\t\treturn false;\n\t\t\tpcl_insert_position(pcl, chunk);\n\t\t} else {\n\t\t\tchunk = list_first_entry(&pcl->cl_chunks,\n\t\t\t\t\t\t struct svc_rdma_chunk,\n\t\t\t\t\t\t ch_list);\n\t\t}\n\n\t\tpcl_set_read_segment(rctxt, chunk, handle, length, offset);\n\t}\n\n\treturn true;\n}\n\n \nbool pcl_alloc_read(struct svc_rdma_recv_ctxt *rctxt, __be32 *p)\n{\n\tstruct svc_rdma_pcl *pcl = &rctxt->rc_read_pcl;\n\tunsigned int i, segcount = pcl->cl_count;\n\n\tpcl->cl_count = 0;\n\tfor (i = 0; i < segcount; i++) {\n\t\tstruct svc_rdma_chunk *chunk;\n\t\tu32 position, handle, length;\n\t\tu64 offset;\n\n\t\tp++;\t \n\t\tp = xdr_decode_read_segment(p, &position, &handle,\n\t\t\t\t\t    &length, &offset);\n\t\tif (position == 0)\n\t\t\tcontinue;\n\n\t\tchunk = pcl_lookup_position(pcl, position);\n\t\tif (!chunk) {\n\t\t\tchunk = pcl_alloc_chunk(segcount, position);\n\t\t\tif (!chunk)\n\t\t\t\treturn false;\n\t\t\tpcl_insert_position(pcl, chunk);\n\t\t}\n\n\t\tpcl_set_read_segment(rctxt, chunk, handle, length, offset);\n\t}\n\n\treturn true;\n}\n\n \nbool pcl_alloc_write(struct svc_rdma_recv_ctxt *rctxt,\n\t\t     struct svc_rdma_pcl *pcl, __be32 *p)\n{\n\tstruct svc_rdma_segment *segment;\n\tstruct svc_rdma_chunk *chunk;\n\tunsigned int i, j;\n\tu32 segcount;\n\n\tfor (i = 0; i < pcl->cl_count; i++) {\n\t\tp++;\t \n\t\tsegcount = be32_to_cpup(p++);\n\n\t\tchunk = pcl_alloc_chunk(segcount, 0);\n\t\tif (!chunk)\n\t\t\treturn false;\n\t\tlist_add_tail(&chunk->ch_list, &pcl->cl_chunks);\n\n\t\tfor (j = 0; j < segcount; j++) {\n\t\t\tsegment = &chunk->ch_segments[j];\n\t\t\tp = xdr_decode_rdma_segment(p, &segment->rs_handle,\n\t\t\t\t\t\t    &segment->rs_length,\n\t\t\t\t\t\t    &segment->rs_offset);\n\t\t\ttrace_svcrdma_decode_wseg(&rctxt->rc_cid, chunk, j);\n\n\t\t\tchunk->ch_length += segment->rs_length;\n\t\t\tchunk->ch_segcount++;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int pcl_process_region(const struct xdr_buf *xdr,\n\t\t\t      unsigned int offset, unsigned int length,\n\t\t\t      int (*actor)(const struct xdr_buf *, void *),\n\t\t\t      void *data)\n{\n\tstruct xdr_buf subbuf;\n\n\tif (!length)\n\t\treturn 0;\n\tif (xdr_buf_subsegment(xdr, &subbuf, offset, length))\n\t\treturn -EMSGSIZE;\n\treturn actor(&subbuf, data);\n}\n\n \nint pcl_process_nonpayloads(const struct svc_rdma_pcl *pcl,\n\t\t\t    const struct xdr_buf *xdr,\n\t\t\t    int (*actor)(const struct xdr_buf *, void *),\n\t\t\t    void *data)\n{\n\tstruct svc_rdma_chunk *chunk, *next;\n\tunsigned int start;\n\tint ret;\n\n\tchunk = pcl_first_chunk(pcl);\n\n\t \n\tif (!chunk || !chunk->ch_payload_length)\n\t\treturn actor(xdr, data);\n\n\t \n\tret = pcl_process_region(xdr, 0, chunk->ch_position, actor, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\twhile ((next = pcl_next_chunk(pcl, chunk))) {\n\t\tif (!next->ch_payload_length)\n\t\t\tbreak;\n\n\t\tstart = pcl_chunk_end_offset(chunk);\n\t\tret = pcl_process_region(xdr, start, next->ch_position - start,\n\t\t\t\t\t actor, data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tchunk = next;\n\t}\n\n\t \n\tstart = pcl_chunk_end_offset(chunk);\n\tret = pcl_process_region(xdr, start, xdr->len - start, actor, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}