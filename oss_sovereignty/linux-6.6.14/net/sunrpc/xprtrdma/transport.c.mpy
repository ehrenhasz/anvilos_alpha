{
  "module_name": "transport.c",
  "hash_id": "3057e77b0aa6ad99a777b5273f5fccfe53c69c6aae555509f266afb65d98ee28",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/xprtrdma/transport.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/smp.h>\n\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svc_rdma.h>\n\n#include \"xprt_rdma.h\"\n#include <trace/events/rpcrdma.h>\n\n \n\nstatic unsigned int xprt_rdma_slot_table_entries = RPCRDMA_DEF_SLOT_TABLE;\nunsigned int xprt_rdma_max_inline_read = RPCRDMA_DEF_INLINE;\nunsigned int xprt_rdma_max_inline_write = RPCRDMA_DEF_INLINE;\nunsigned int xprt_rdma_memreg_strategy\t\t= RPCRDMA_FRWR;\nint xprt_rdma_pad_optimize;\nstatic struct xprt_class xprt_rdma;\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n\nstatic unsigned int min_slot_table_size = RPCRDMA_MIN_SLOT_TABLE;\nstatic unsigned int max_slot_table_size = RPCRDMA_MAX_SLOT_TABLE;\nstatic unsigned int min_inline_size = RPCRDMA_MIN_INLINE;\nstatic unsigned int max_inline_size = RPCRDMA_MAX_INLINE;\nstatic unsigned int max_padding = PAGE_SIZE;\nstatic unsigned int min_memreg = RPCRDMA_BOUNCEBUFFERS;\nstatic unsigned int max_memreg = RPCRDMA_LAST - 1;\nstatic unsigned int dummy;\n\nstatic struct ctl_table_header *sunrpc_table_header;\n\nstatic struct ctl_table xr_tunables_table[] = {\n\t{\n\t\t.procname\t= \"rdma_slot_table_entries\",\n\t\t.data\t\t= &xprt_rdma_slot_table_entries,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_slot_table_size,\n\t\t.extra2\t\t= &max_slot_table_size\n\t},\n\t{\n\t\t.procname\t= \"rdma_max_inline_read\",\n\t\t.data\t\t= &xprt_rdma_max_inline_read,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_inline_size,\n\t\t.extra2\t\t= &max_inline_size,\n\t},\n\t{\n\t\t.procname\t= \"rdma_max_inline_write\",\n\t\t.data\t\t= &xprt_rdma_max_inline_write,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_inline_size,\n\t\t.extra2\t\t= &max_inline_size,\n\t},\n\t{\n\t\t.procname\t= \"rdma_inline_write_padding\",\n\t\t.data\t\t= &dummy,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= &max_padding,\n\t},\n\t{\n\t\t.procname\t= \"rdma_memreg_strategy\",\n\t\t.data\t\t= &xprt_rdma_memreg_strategy,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &min_memreg,\n\t\t.extra2\t\t= &max_memreg,\n\t},\n\t{\n\t\t.procname\t= \"rdma_pad_optimize\",\n\t\t.data\t\t= &xprt_rdma_pad_optimize,\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ },\n};\n\n#endif\n\nstatic const struct rpc_xprt_ops xprt_rdma_procs;\n\nstatic void\nxprt_rdma_format_addresses4(struct rpc_xprt *xprt, struct sockaddr *sap)\n{\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)sap;\n\tchar buf[20];\n\n\tsnprintf(buf, sizeof(buf), \"%08x\", ntohl(sin->sin_addr.s_addr));\n\txprt->address_strings[RPC_DISPLAY_HEX_ADDR] = kstrdup(buf, GFP_KERNEL);\n\n\txprt->address_strings[RPC_DISPLAY_NETID] = RPCBIND_NETID_RDMA;\n}\n\nstatic void\nxprt_rdma_format_addresses6(struct rpc_xprt *xprt, struct sockaddr *sap)\n{\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tchar buf[40];\n\n\tsnprintf(buf, sizeof(buf), \"%pi6\", &sin6->sin6_addr);\n\txprt->address_strings[RPC_DISPLAY_HEX_ADDR] = kstrdup(buf, GFP_KERNEL);\n\n\txprt->address_strings[RPC_DISPLAY_NETID] = RPCBIND_NETID_RDMA6;\n}\n\nvoid\nxprt_rdma_format_addresses(struct rpc_xprt *xprt, struct sockaddr *sap)\n{\n\tchar buf[128];\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\txprt_rdma_format_addresses4(xprt, sap);\n\t\tbreak;\n\tcase AF_INET6:\n\t\txprt_rdma_format_addresses6(xprt, sap);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"rpcrdma: Unrecognized address family\\n\");\n\t\treturn;\n\t}\n\n\t(void)rpc_ntop(sap, buf, sizeof(buf));\n\txprt->address_strings[RPC_DISPLAY_ADDR] = kstrdup(buf, GFP_KERNEL);\n\n\tsnprintf(buf, sizeof(buf), \"%u\", rpc_get_port(sap));\n\txprt->address_strings[RPC_DISPLAY_PORT] = kstrdup(buf, GFP_KERNEL);\n\n\tsnprintf(buf, sizeof(buf), \"%4hx\", rpc_get_port(sap));\n\txprt->address_strings[RPC_DISPLAY_HEX_PORT] = kstrdup(buf, GFP_KERNEL);\n\n\txprt->address_strings[RPC_DISPLAY_PROTO] = \"rdma\";\n}\n\nvoid\nxprt_rdma_free_addresses(struct rpc_xprt *xprt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < RPC_DISPLAY_MAX; i++)\n\t\tswitch (i) {\n\t\tcase RPC_DISPLAY_PROTO:\n\t\tcase RPC_DISPLAY_NETID:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tkfree(xprt->address_strings[i]);\n\t\t}\n}\n\n \nstatic void\nxprt_rdma_connect_worker(struct work_struct *work)\n{\n\tstruct rpcrdma_xprt *r_xprt = container_of(work, struct rpcrdma_xprt,\n\t\t\t\t\t\t   rx_connect_worker.work);\n\tstruct rpc_xprt *xprt = &r_xprt->rx_xprt;\n\tunsigned int pflags = current->flags;\n\tint rc;\n\n\tif (atomic_read(&xprt->swapper))\n\t\tcurrent->flags |= PF_MEMALLOC;\n\trc = rpcrdma_xprt_connect(r_xprt);\n\txprt_clear_connecting(xprt);\n\tif (!rc) {\n\t\txprt->connect_cookie++;\n\t\txprt->stat.connect_count++;\n\t\txprt->stat.connect_time += (long)jiffies -\n\t\t\t\t\t   xprt->stat.connect_start;\n\t\txprt_set_connected(xprt);\n\t\trc = -EAGAIN;\n\t} else\n\t\trpcrdma_xprt_disconnect(r_xprt);\n\txprt_unlock_connect(xprt, r_xprt);\n\txprt_wake_pending_tasks(xprt, rc);\n\tcurrent_restore_flags(pflags, PF_MEMALLOC);\n}\n\n \nstatic void\nxprt_rdma_inject_disconnect(struct rpc_xprt *xprt)\n{\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\n\ttrace_xprtrdma_op_inject_dsc(r_xprt);\n\trdma_disconnect(r_xprt->rx_ep->re_id);\n}\n\n \nstatic void\nxprt_rdma_destroy(struct rpc_xprt *xprt)\n{\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\n\tcancel_delayed_work_sync(&r_xprt->rx_connect_worker);\n\n\trpcrdma_xprt_disconnect(r_xprt);\n\trpcrdma_buffer_destroy(&r_xprt->rx_buf);\n\n\txprt_rdma_free_addresses(xprt);\n\txprt_free(xprt);\n\n\tmodule_put(THIS_MODULE);\n}\n\n \nstatic const struct rpc_timeout xprt_rdma_default_timeout = {\n\t.to_initval = 60 * HZ,\n\t.to_maxval = 60 * HZ,\n};\n\n \nstatic struct rpc_xprt *\nxprt_setup_rdma(struct xprt_create *args)\n{\n\tstruct rpc_xprt *xprt;\n\tstruct rpcrdma_xprt *new_xprt;\n\tstruct sockaddr *sap;\n\tint rc;\n\n\tif (args->addrlen > sizeof(xprt->addr))\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn ERR_PTR(-EIO);\n\n\txprt = xprt_alloc(args->net, sizeof(struct rpcrdma_xprt), 0,\n\t\t\t  xprt_rdma_slot_table_entries);\n\tif (!xprt) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\txprt->timeout = &xprt_rdma_default_timeout;\n\txprt->connect_timeout = xprt->timeout->to_initval;\n\txprt->max_reconnect_timeout = xprt->timeout->to_maxval;\n\txprt->bind_timeout = RPCRDMA_BIND_TO;\n\txprt->reestablish_timeout = RPCRDMA_INIT_REEST_TO;\n\txprt->idle_timeout = RPCRDMA_IDLE_DISC_TO;\n\n\txprt->resvport = 0;\t\t \n\txprt->ops = &xprt_rdma_procs;\n\n\t \n\tsap = args->dstaddr;\n\n\t \n\txprt->prot = IPPROTO_TCP;\n\txprt->xprt_class = &xprt_rdma;\n\txprt->addrlen = args->addrlen;\n\tmemcpy(&xprt->addr, sap, xprt->addrlen);\n\n\tif (rpc_get_port(sap))\n\t\txprt_set_bound(xprt);\n\txprt_rdma_format_addresses(xprt, sap);\n\n\tnew_xprt = rpcx_to_rdmax(xprt);\n\trc = rpcrdma_buffer_create(new_xprt);\n\tif (rc) {\n\t\txprt_rdma_free_addresses(xprt);\n\t\txprt_free(xprt);\n\t\tmodule_put(THIS_MODULE);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\tINIT_DELAYED_WORK(&new_xprt->rx_connect_worker,\n\t\t\t  xprt_rdma_connect_worker);\n\n\txprt->max_payload = RPCRDMA_MAX_DATA_SEGS << PAGE_SHIFT;\n\n\treturn xprt;\n}\n\n \nvoid xprt_rdma_close(struct rpc_xprt *xprt)\n{\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\n\trpcrdma_xprt_disconnect(r_xprt);\n\n\txprt->reestablish_timeout = 0;\n\t++xprt->connect_cookie;\n\txprt_disconnect_done(xprt);\n}\n\n \nstatic void\nxprt_rdma_set_port(struct rpc_xprt *xprt, u16 port)\n{\n\tstruct sockaddr *sap = (struct sockaddr *)&xprt->addr;\n\tchar buf[8];\n\n\trpc_set_port(sap, port);\n\n\tkfree(xprt->address_strings[RPC_DISPLAY_PORT]);\n\tsnprintf(buf, sizeof(buf), \"%u\", port);\n\txprt->address_strings[RPC_DISPLAY_PORT] = kstrdup(buf, GFP_KERNEL);\n\n\tkfree(xprt->address_strings[RPC_DISPLAY_HEX_PORT]);\n\tsnprintf(buf, sizeof(buf), \"%4hx\", port);\n\txprt->address_strings[RPC_DISPLAY_HEX_PORT] = kstrdup(buf, GFP_KERNEL);\n}\n\n \nstatic void\nxprt_rdma_timer(struct rpc_xprt *xprt, struct rpc_task *task)\n{\n\txprt_force_disconnect(xprt);\n}\n\n \nstatic void xprt_rdma_set_connect_timeout(struct rpc_xprt *xprt,\n\t\t\t\t\t  unsigned long connect_timeout,\n\t\t\t\t\t  unsigned long reconnect_timeout)\n{\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\n\ttrace_xprtrdma_op_set_cto(r_xprt, connect_timeout, reconnect_timeout);\n\n\tspin_lock(&xprt->transport_lock);\n\n\tif (connect_timeout < xprt->connect_timeout) {\n\t\tstruct rpc_timeout to;\n\t\tunsigned long initval;\n\n\t\tto = *xprt->timeout;\n\t\tinitval = connect_timeout;\n\t\tif (initval < RPCRDMA_INIT_REEST_TO << 1)\n\t\t\tinitval = RPCRDMA_INIT_REEST_TO << 1;\n\t\tto.to_initval = initval;\n\t\tto.to_maxval = initval;\n\t\tr_xprt->rx_timeout = to;\n\t\txprt->timeout = &r_xprt->rx_timeout;\n\t\txprt->connect_timeout = connect_timeout;\n\t}\n\n\tif (reconnect_timeout < xprt->max_reconnect_timeout)\n\t\txprt->max_reconnect_timeout = reconnect_timeout;\n\n\tspin_unlock(&xprt->transport_lock);\n}\n\n \nstatic void\nxprt_rdma_connect(struct rpc_xprt *xprt, struct rpc_task *task)\n{\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\tstruct rpcrdma_ep *ep = r_xprt->rx_ep;\n\tunsigned long delay;\n\n\tWARN_ON_ONCE(!xprt_lock_connect(xprt, task, r_xprt));\n\n\tdelay = 0;\n\tif (ep && ep->re_connect_status != 0) {\n\t\tdelay = xprt_reconnect_delay(xprt);\n\t\txprt_reconnect_backoff(xprt, RPCRDMA_INIT_REEST_TO);\n\t}\n\ttrace_xprtrdma_op_connect(r_xprt, delay);\n\tqueue_delayed_work(system_long_wq, &r_xprt->rx_connect_worker, delay);\n}\n\n \nstatic void\nxprt_rdma_alloc_slot(struct rpc_xprt *xprt, struct rpc_task *task)\n{\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\tstruct rpcrdma_req *req;\n\n\treq = rpcrdma_buffer_get(&r_xprt->rx_buf);\n\tif (!req)\n\t\tgoto out_sleep;\n\ttask->tk_rqstp = &req->rl_slot;\n\ttask->tk_status = 0;\n\treturn;\n\nout_sleep:\n\ttask->tk_status = -ENOMEM;\n\txprt_add_backlog(xprt, task);\n}\n\n \nstatic void\nxprt_rdma_free_slot(struct rpc_xprt *xprt, struct rpc_rqst *rqst)\n{\n\tstruct rpcrdma_xprt *r_xprt =\n\t\tcontainer_of(xprt, struct rpcrdma_xprt, rx_xprt);\n\n\trpcrdma_reply_put(&r_xprt->rx_buf, rpcr_to_rdmar(rqst));\n\tif (!xprt_wake_up_backlog(xprt, rqst)) {\n\t\tmemset(rqst, 0, sizeof(*rqst));\n\t\trpcrdma_buffer_put(&r_xprt->rx_buf, rpcr_to_rdmar(rqst));\n\t}\n}\n\nstatic bool rpcrdma_check_regbuf(struct rpcrdma_xprt *r_xprt,\n\t\t\t\t struct rpcrdma_regbuf *rb, size_t size,\n\t\t\t\t gfp_t flags)\n{\n\tif (unlikely(rdmab_length(rb) < size)) {\n\t\tif (!rpcrdma_regbuf_realloc(rb, size, flags))\n\t\t\treturn false;\n\t\tr_xprt->rx_stats.hardway_register_count += size;\n\t}\n\treturn true;\n}\n\n \nstatic int\nxprt_rdma_allocate(struct rpc_task *task)\n{\n\tstruct rpc_rqst *rqst = task->tk_rqstp;\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(rqst->rq_xprt);\n\tstruct rpcrdma_req *req = rpcr_to_rdmar(rqst);\n\tgfp_t flags = rpc_task_gfp_mask();\n\n\tif (!rpcrdma_check_regbuf(r_xprt, req->rl_sendbuf, rqst->rq_callsize,\n\t\t\t\t  flags))\n\t\tgoto out_fail;\n\tif (!rpcrdma_check_regbuf(r_xprt, req->rl_recvbuf, rqst->rq_rcvsize,\n\t\t\t\t  flags))\n\t\tgoto out_fail;\n\n\trqst->rq_buffer = rdmab_data(req->rl_sendbuf);\n\trqst->rq_rbuffer = rdmab_data(req->rl_recvbuf);\n\treturn 0;\n\nout_fail:\n\treturn -ENOMEM;\n}\n\n \nstatic void\nxprt_rdma_free(struct rpc_task *task)\n{\n\tstruct rpc_rqst *rqst = task->tk_rqstp;\n\tstruct rpcrdma_req *req = rpcr_to_rdmar(rqst);\n\n\tif (unlikely(!list_empty(&req->rl_registered))) {\n\t\ttrace_xprtrdma_mrs_zap(task);\n\t\tfrwr_unmap_sync(rpcx_to_rdmax(rqst->rq_xprt), req);\n\t}\n\n\t \n}\n\n \nstatic int\nxprt_rdma_send_request(struct rpc_rqst *rqst)\n{\n\tstruct rpc_xprt *xprt = rqst->rq_xprt;\n\tstruct rpcrdma_req *req = rpcr_to_rdmar(rqst);\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\tint rc = 0;\n\n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\n\tif (unlikely(!rqst->rq_buffer))\n\t\treturn xprt_rdma_bc_send_reply(rqst);\n#endif\t \n\n\tif (!xprt_connected(xprt))\n\t\treturn -ENOTCONN;\n\n\tif (!xprt_request_get_cong(xprt, rqst))\n\t\treturn -EBADSLT;\n\n\trc = rpcrdma_marshal_req(r_xprt, rqst);\n\tif (rc < 0)\n\t\tgoto failed_marshal;\n\n\t \n\tif (rqst->rq_connect_cookie == xprt->connect_cookie)\n\t\tgoto drop_connection;\n\trqst->rq_xtime = ktime_get();\n\n\tif (frwr_send(r_xprt, req))\n\t\tgoto drop_connection;\n\n\trqst->rq_xmit_bytes_sent += rqst->rq_snd_buf.len;\n\n\t \n\tif (!rpc_reply_expected(rqst->rq_task))\n\t\tgoto drop_connection;\n\treturn 0;\n\nfailed_marshal:\n\tif (rc != -ENOTCONN)\n\t\treturn rc;\ndrop_connection:\n\txprt_rdma_close(xprt);\n\treturn -ENOTCONN;\n}\n\nvoid xprt_rdma_print_stats(struct rpc_xprt *xprt, struct seq_file *seq)\n{\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\tlong idle_time = 0;\n\n\tif (xprt_connected(xprt))\n\t\tidle_time = (long)(jiffies - xprt->last_used) / HZ;\n\n\tseq_puts(seq, \"\\txprt:\\trdma \");\n\tseq_printf(seq, \"%u %lu %lu %lu %ld %lu %lu %lu %llu %llu \",\n\t\t   0,\t \n\t\t   xprt->stat.bind_count,\n\t\t   xprt->stat.connect_count,\n\t\t   xprt->stat.connect_time / HZ,\n\t\t   idle_time,\n\t\t   xprt->stat.sends,\n\t\t   xprt->stat.recvs,\n\t\t   xprt->stat.bad_xids,\n\t\t   xprt->stat.req_u,\n\t\t   xprt->stat.bklog_u);\n\tseq_printf(seq, \"%lu %lu %lu %llu %llu %llu %llu %lu %lu %lu %lu \",\n\t\t   r_xprt->rx_stats.read_chunk_count,\n\t\t   r_xprt->rx_stats.write_chunk_count,\n\t\t   r_xprt->rx_stats.reply_chunk_count,\n\t\t   r_xprt->rx_stats.total_rdma_request,\n\t\t   r_xprt->rx_stats.total_rdma_reply,\n\t\t   r_xprt->rx_stats.pullup_copy_count,\n\t\t   r_xprt->rx_stats.fixup_copy_count,\n\t\t   r_xprt->rx_stats.hardway_register_count,\n\t\t   r_xprt->rx_stats.failed_marshal_count,\n\t\t   r_xprt->rx_stats.bad_reply_count,\n\t\t   r_xprt->rx_stats.nomsg_call_count);\n\tseq_printf(seq, \"%lu %lu %lu %lu %lu %lu\\n\",\n\t\t   r_xprt->rx_stats.mrs_recycled,\n\t\t   r_xprt->rx_stats.mrs_orphaned,\n\t\t   r_xprt->rx_stats.mrs_allocated,\n\t\t   r_xprt->rx_stats.local_inv_needed,\n\t\t   r_xprt->rx_stats.empty_sendctx_q,\n\t\t   r_xprt->rx_stats.reply_waits_for_send);\n}\n\nstatic int\nxprt_rdma_enable_swap(struct rpc_xprt *xprt)\n{\n\treturn 0;\n}\n\nstatic void\nxprt_rdma_disable_swap(struct rpc_xprt *xprt)\n{\n}\n\n \n\nstatic const struct rpc_xprt_ops xprt_rdma_procs = {\n\t.reserve_xprt\t\t= xprt_reserve_xprt_cong,\n\t.release_xprt\t\t= xprt_release_xprt_cong,  \n\t.alloc_slot\t\t= xprt_rdma_alloc_slot,\n\t.free_slot\t\t= xprt_rdma_free_slot,\n\t.release_request\t= xprt_release_rqst_cong,        \n\t.wait_for_reply_request\t= xprt_wait_for_reply_request_def,  \n\t.timer\t\t\t= xprt_rdma_timer,\n\t.rpcbind\t\t= rpcb_getport_async,\t \n\t.set_port\t\t= xprt_rdma_set_port,\n\t.connect\t\t= xprt_rdma_connect,\n\t.buf_alloc\t\t= xprt_rdma_allocate,\n\t.buf_free\t\t= xprt_rdma_free,\n\t.send_request\t\t= xprt_rdma_send_request,\n\t.close\t\t\t= xprt_rdma_close,\n\t.destroy\t\t= xprt_rdma_destroy,\n\t.set_connect_timeout\t= xprt_rdma_set_connect_timeout,\n\t.print_stats\t\t= xprt_rdma_print_stats,\n\t.enable_swap\t\t= xprt_rdma_enable_swap,\n\t.disable_swap\t\t= xprt_rdma_disable_swap,\n\t.inject_disconnect\t= xprt_rdma_inject_disconnect,\n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\n\t.bc_setup\t\t= xprt_rdma_bc_setup,\n\t.bc_maxpayload\t\t= xprt_rdma_bc_maxpayload,\n\t.bc_num_slots\t\t= xprt_rdma_bc_max_slots,\n\t.bc_free_rqst\t\t= xprt_rdma_bc_free_rqst,\n\t.bc_destroy\t\t= xprt_rdma_bc_destroy,\n#endif\n};\n\nstatic struct xprt_class xprt_rdma = {\n\t.list\t\t\t= LIST_HEAD_INIT(xprt_rdma.list),\n\t.name\t\t\t= \"rdma\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.ident\t\t\t= XPRT_TRANSPORT_RDMA,\n\t.setup\t\t\t= xprt_setup_rdma,\n\t.netid\t\t\t= { \"rdma\", \"rdma6\", \"\" },\n};\n\nvoid xprt_rdma_cleanup(void)\n{\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n\tif (sunrpc_table_header) {\n\t\tunregister_sysctl_table(sunrpc_table_header);\n\t\tsunrpc_table_header = NULL;\n\t}\n#endif\n\n\txprt_unregister_transport(&xprt_rdma);\n\txprt_unregister_transport(&xprt_rdma_bc);\n}\n\nint xprt_rdma_init(void)\n{\n\tint rc;\n\n\trc = xprt_register_transport(&xprt_rdma);\n\tif (rc)\n\t\treturn rc;\n\n\trc = xprt_register_transport(&xprt_rdma_bc);\n\tif (rc) {\n\t\txprt_unregister_transport(&xprt_rdma);\n\t\treturn rc;\n\t}\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n\tif (!sunrpc_table_header)\n\t\tsunrpc_table_header = register_sysctl(\"sunrpc\", xr_tunables_table);\n#endif\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}