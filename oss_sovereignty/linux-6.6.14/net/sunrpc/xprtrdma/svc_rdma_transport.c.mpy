{
  "module_name": "svc_rdma_transport.c",
  "hash_id": "56a6bd6aef252be3a9a69b1806b7fedc58fff86d5628c94b7f6df1b79780d54f",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/xprtrdma/svc_rdma_transport.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/export.h>\n\n#include <rdma/ib_verbs.h>\n#include <rdma/rdma_cm.h>\n#include <rdma/rw.h>\n\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/debug.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svc_rdma.h>\n\n#include \"xprt_rdma.h\"\n#include <trace/events/rpcrdma.h>\n\n#define RPCDBG_FACILITY\tRPCDBG_SVCXPRT\n\nstatic struct svcxprt_rdma *svc_rdma_create_xprt(struct svc_serv *serv,\n\t\t\t\t\t\t struct net *net, int node);\nstatic struct svc_xprt *svc_rdma_create(struct svc_serv *serv,\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tstruct sockaddr *sa, int salen,\n\t\t\t\t\tint flags);\nstatic struct svc_xprt *svc_rdma_accept(struct svc_xprt *xprt);\nstatic void svc_rdma_detach(struct svc_xprt *xprt);\nstatic void svc_rdma_free(struct svc_xprt *xprt);\nstatic int svc_rdma_has_wspace(struct svc_xprt *xprt);\nstatic void svc_rdma_kill_temp_xprt(struct svc_xprt *);\n\nstatic const struct svc_xprt_ops svc_rdma_ops = {\n\t.xpo_create = svc_rdma_create,\n\t.xpo_recvfrom = svc_rdma_recvfrom,\n\t.xpo_sendto = svc_rdma_sendto,\n\t.xpo_result_payload = svc_rdma_result_payload,\n\t.xpo_release_ctxt = svc_rdma_release_ctxt,\n\t.xpo_detach = svc_rdma_detach,\n\t.xpo_free = svc_rdma_free,\n\t.xpo_has_wspace = svc_rdma_has_wspace,\n\t.xpo_accept = svc_rdma_accept,\n\t.xpo_kill_temp_xprt = svc_rdma_kill_temp_xprt,\n};\n\nstruct svc_xprt_class svc_rdma_class = {\n\t.xcl_name = \"rdma\",\n\t.xcl_owner = THIS_MODULE,\n\t.xcl_ops = &svc_rdma_ops,\n\t.xcl_max_payload = RPCSVC_MAXPAYLOAD_RDMA,\n\t.xcl_ident = XPRT_TRANSPORT_RDMA,\n};\n\n \nstatic void qp_event_handler(struct ib_event *event, void *context)\n{\n\tstruct svc_xprt *xprt = context;\n\n\ttrace_svcrdma_qp_error(event, (struct sockaddr *)&xprt->xpt_remote);\n\tswitch (event->event) {\n\t \n\tcase IB_EVENT_PATH_MIG:\n\tcase IB_EVENT_COMM_EST:\n\tcase IB_EVENT_SQ_DRAINED:\n\tcase IB_EVENT_QP_LAST_WQE_REACHED:\n\t\tbreak;\n\n\t \n\tcase IB_EVENT_PATH_MIG_ERR:\n\tcase IB_EVENT_QP_FATAL:\n\tcase IB_EVENT_QP_REQ_ERR:\n\tcase IB_EVENT_QP_ACCESS_ERR:\n\tcase IB_EVENT_DEVICE_FATAL:\n\tdefault:\n\t\tsvc_xprt_deferred_close(xprt);\n\t\tbreak;\n\t}\n}\n\nstatic struct svcxprt_rdma *svc_rdma_create_xprt(struct svc_serv *serv,\n\t\t\t\t\t\t struct net *net, int node)\n{\n\tstruct svcxprt_rdma *cma_xprt;\n\n\tcma_xprt = kzalloc_node(sizeof(*cma_xprt), GFP_KERNEL, node);\n\tif (!cma_xprt)\n\t\treturn NULL;\n\n\tsvc_xprt_init(net, &svc_rdma_class, &cma_xprt->sc_xprt, serv);\n\tINIT_LIST_HEAD(&cma_xprt->sc_accept_q);\n\tINIT_LIST_HEAD(&cma_xprt->sc_rq_dto_q);\n\tinit_llist_head(&cma_xprt->sc_send_ctxts);\n\tinit_llist_head(&cma_xprt->sc_recv_ctxts);\n\tinit_llist_head(&cma_xprt->sc_rw_ctxts);\n\tinit_waitqueue_head(&cma_xprt->sc_send_wait);\n\n\tspin_lock_init(&cma_xprt->sc_lock);\n\tspin_lock_init(&cma_xprt->sc_rq_dto_lock);\n\tspin_lock_init(&cma_xprt->sc_send_lock);\n\tspin_lock_init(&cma_xprt->sc_rw_ctxt_lock);\n\n\t \n\tset_bit(XPT_CONG_CTRL, &cma_xprt->sc_xprt.xpt_flags);\n\n\treturn cma_xprt;\n}\n\nstatic void\nsvc_rdma_parse_connect_private(struct svcxprt_rdma *newxprt,\n\t\t\t       struct rdma_conn_param *param)\n{\n\tconst struct rpcrdma_connect_private *pmsg = param->private_data;\n\n\tif (pmsg &&\n\t    pmsg->cp_magic == rpcrdma_cmp_magic &&\n\t    pmsg->cp_version == RPCRDMA_CMP_VERSION) {\n\t\tnewxprt->sc_snd_w_inv = pmsg->cp_flags &\n\t\t\t\t\tRPCRDMA_CMP_F_SND_W_INV_OK;\n\n\t\tdprintk(\"svcrdma: client send_size %u, recv_size %u \"\n\t\t\t\"remote inv %ssupported\\n\",\n\t\t\trpcrdma_decode_buffer_size(pmsg->cp_send_size),\n\t\t\trpcrdma_decode_buffer_size(pmsg->cp_recv_size),\n\t\t\tnewxprt->sc_snd_w_inv ? \"\" : \"un\");\n\t}\n}\n\n \nstatic void handle_connect_req(struct rdma_cm_id *new_cma_id,\n\t\t\t       struct rdma_conn_param *param)\n{\n\tstruct svcxprt_rdma *listen_xprt = new_cma_id->context;\n\tstruct svcxprt_rdma *newxprt;\n\tstruct sockaddr *sa;\n\n\tnewxprt = svc_rdma_create_xprt(listen_xprt->sc_xprt.xpt_server,\n\t\t\t\t       listen_xprt->sc_xprt.xpt_net,\n\t\t\t\t       ibdev_to_node(new_cma_id->device));\n\tif (!newxprt)\n\t\treturn;\n\tnewxprt->sc_cm_id = new_cma_id;\n\tnew_cma_id->context = newxprt;\n\tsvc_rdma_parse_connect_private(newxprt, param);\n\n\t \n\tnewxprt->sc_ord = param->initiator_depth;\n\n\tsa = (struct sockaddr *)&newxprt->sc_cm_id->route.addr.dst_addr;\n\tnewxprt->sc_xprt.xpt_remotelen = svc_addr_len(sa);\n\tmemcpy(&newxprt->sc_xprt.xpt_remote, sa,\n\t       newxprt->sc_xprt.xpt_remotelen);\n\tsnprintf(newxprt->sc_xprt.xpt_remotebuf,\n\t\t sizeof(newxprt->sc_xprt.xpt_remotebuf) - 1, \"%pISc\", sa);\n\n\t \n\trpc_set_port((struct sockaddr *)&newxprt->sc_xprt.xpt_remote, 0);\n\n\tsa = (struct sockaddr *)&newxprt->sc_cm_id->route.addr.src_addr;\n\tsvc_xprt_set_local(&newxprt->sc_xprt, sa, svc_addr_len(sa));\n\n\t \n\tspin_lock(&listen_xprt->sc_lock);\n\tlist_add_tail(&newxprt->sc_accept_q, &listen_xprt->sc_accept_q);\n\tspin_unlock(&listen_xprt->sc_lock);\n\n\tset_bit(XPT_CONN, &listen_xprt->sc_xprt.xpt_flags);\n\tsvc_xprt_enqueue(&listen_xprt->sc_xprt);\n}\n\n \nstatic int svc_rdma_listen_handler(struct rdma_cm_id *cma_id,\n\t\t\t\t   struct rdma_cm_event *event)\n{\n\tswitch (event->event) {\n\tcase RDMA_CM_EVENT_CONNECT_REQUEST:\n\t\thandle_connect_req(cma_id, &event->param.conn);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int svc_rdma_cma_handler(struct rdma_cm_id *cma_id,\n\t\t\t\tstruct rdma_cm_event *event)\n{\n\tstruct svcxprt_rdma *rdma = cma_id->context;\n\tstruct svc_xprt *xprt = &rdma->sc_xprt;\n\n\tswitch (event->event) {\n\tcase RDMA_CM_EVENT_ESTABLISHED:\n\t\tclear_bit(RDMAXPRT_CONN_PENDING, &rdma->sc_flags);\n\n\t\t \n\t\tsvc_xprt_enqueue(xprt);\n\t\tbreak;\n\tcase RDMA_CM_EVENT_DISCONNECTED:\n\tcase RDMA_CM_EVENT_DEVICE_REMOVAL:\n\t\tsvc_xprt_deferred_close(xprt);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic struct svc_xprt *svc_rdma_create(struct svc_serv *serv,\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tstruct sockaddr *sa, int salen,\n\t\t\t\t\tint flags)\n{\n\tstruct rdma_cm_id *listen_id;\n\tstruct svcxprt_rdma *cma_xprt;\n\tint ret;\n\n\tif (sa->sa_family != AF_INET && sa->sa_family != AF_INET6)\n\t\treturn ERR_PTR(-EAFNOSUPPORT);\n\tcma_xprt = svc_rdma_create_xprt(serv, net, NUMA_NO_NODE);\n\tif (!cma_xprt)\n\t\treturn ERR_PTR(-ENOMEM);\n\tset_bit(XPT_LISTENER, &cma_xprt->sc_xprt.xpt_flags);\n\tstrcpy(cma_xprt->sc_xprt.xpt_remotebuf, \"listener\");\n\n\tlisten_id = rdma_create_id(net, svc_rdma_listen_handler, cma_xprt,\n\t\t\t\t   RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(listen_id)) {\n\t\tret = PTR_ERR(listen_id);\n\t\tgoto err0;\n\t}\n\n\t \n#if IS_ENABLED(CONFIG_IPV6)\n\tret = rdma_set_afonly(listen_id, 1);\n\tif (ret)\n\t\tgoto err1;\n#endif\n\tret = rdma_bind_addr(listen_id, sa);\n\tif (ret)\n\t\tgoto err1;\n\tcma_xprt->sc_cm_id = listen_id;\n\n\tret = rdma_listen(listen_id, RPCRDMA_LISTEN_BACKLOG);\n\tif (ret)\n\t\tgoto err1;\n\n\t \n\tsa = (struct sockaddr *)&cma_xprt->sc_cm_id->route.addr.src_addr;\n\tsvc_xprt_set_local(&cma_xprt->sc_xprt, sa, salen);\n\n\treturn &cma_xprt->sc_xprt;\n\n err1:\n\trdma_destroy_id(listen_id);\n err0:\n\tkfree(cma_xprt);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic struct svc_xprt *svc_rdma_accept(struct svc_xprt *xprt)\n{\n\tstruct svcxprt_rdma *listen_rdma;\n\tstruct svcxprt_rdma *newxprt = NULL;\n\tstruct rdma_conn_param conn_param;\n\tstruct rpcrdma_connect_private pmsg;\n\tstruct ib_qp_init_attr qp_attr;\n\tunsigned int ctxts, rq_depth;\n\tstruct ib_device *dev;\n\tint ret = 0;\n\tRPC_IFDEBUG(struct sockaddr *sap);\n\n\tlisten_rdma = container_of(xprt, struct svcxprt_rdma, sc_xprt);\n\tclear_bit(XPT_CONN, &xprt->xpt_flags);\n\t \n\tspin_lock(&listen_rdma->sc_lock);\n\tif (!list_empty(&listen_rdma->sc_accept_q)) {\n\t\tnewxprt = list_entry(listen_rdma->sc_accept_q.next,\n\t\t\t\t     struct svcxprt_rdma, sc_accept_q);\n\t\tlist_del_init(&newxprt->sc_accept_q);\n\t}\n\tif (!list_empty(&listen_rdma->sc_accept_q))\n\t\tset_bit(XPT_CONN, &listen_rdma->sc_xprt.xpt_flags);\n\tspin_unlock(&listen_rdma->sc_lock);\n\tif (!newxprt)\n\t\treturn NULL;\n\n\tdev = newxprt->sc_cm_id->device;\n\tnewxprt->sc_port_num = newxprt->sc_cm_id->port_num;\n\n\t \n\t \n\tnewxprt->sc_max_send_sges = 3;\n\t \n\tnewxprt->sc_max_send_sges += (svcrdma_max_req_size / PAGE_SIZE) + 1;\n\tif (newxprt->sc_max_send_sges > dev->attrs.max_send_sge)\n\t\tnewxprt->sc_max_send_sges = dev->attrs.max_send_sge;\n\tnewxprt->sc_max_req_size = svcrdma_max_req_size;\n\tnewxprt->sc_max_requests = svcrdma_max_requests;\n\tnewxprt->sc_max_bc_requests = svcrdma_max_bc_requests;\n\tnewxprt->sc_recv_batch = RPCRDMA_MAX_RECV_BATCH;\n\trq_depth = newxprt->sc_max_requests + newxprt->sc_max_bc_requests +\n\t\t   newxprt->sc_recv_batch;\n\tif (rq_depth > dev->attrs.max_qp_wr) {\n\t\tpr_warn(\"svcrdma: reducing receive depth to %d\\n\",\n\t\t\tdev->attrs.max_qp_wr);\n\t\trq_depth = dev->attrs.max_qp_wr;\n\t\tnewxprt->sc_recv_batch = 1;\n\t\tnewxprt->sc_max_requests = rq_depth - 2;\n\t\tnewxprt->sc_max_bc_requests = 2;\n\t}\n\tnewxprt->sc_fc_credits = cpu_to_be32(newxprt->sc_max_requests);\n\tctxts = rdma_rw_mr_factor(dev, newxprt->sc_port_num, RPCSVC_MAXPAGES);\n\tctxts *= newxprt->sc_max_requests;\n\tnewxprt->sc_sq_depth = rq_depth + ctxts;\n\tif (newxprt->sc_sq_depth > dev->attrs.max_qp_wr) {\n\t\tpr_warn(\"svcrdma: reducing send depth to %d\\n\",\n\t\t\tdev->attrs.max_qp_wr);\n\t\tnewxprt->sc_sq_depth = dev->attrs.max_qp_wr;\n\t}\n\tatomic_set(&newxprt->sc_sq_avail, newxprt->sc_sq_depth);\n\n\tnewxprt->sc_pd = ib_alloc_pd(dev, 0);\n\tif (IS_ERR(newxprt->sc_pd)) {\n\t\ttrace_svcrdma_pd_err(newxprt, PTR_ERR(newxprt->sc_pd));\n\t\tgoto errout;\n\t}\n\tnewxprt->sc_sq_cq = ib_alloc_cq_any(dev, newxprt, newxprt->sc_sq_depth,\n\t\t\t\t\t    IB_POLL_WORKQUEUE);\n\tif (IS_ERR(newxprt->sc_sq_cq))\n\t\tgoto errout;\n\tnewxprt->sc_rq_cq =\n\t\tib_alloc_cq_any(dev, newxprt, rq_depth, IB_POLL_WORKQUEUE);\n\tif (IS_ERR(newxprt->sc_rq_cq))\n\t\tgoto errout;\n\n\tmemset(&qp_attr, 0, sizeof qp_attr);\n\tqp_attr.event_handler = qp_event_handler;\n\tqp_attr.qp_context = &newxprt->sc_xprt;\n\tqp_attr.port_num = newxprt->sc_port_num;\n\tqp_attr.cap.max_rdma_ctxs = ctxts;\n\tqp_attr.cap.max_send_wr = newxprt->sc_sq_depth - ctxts;\n\tqp_attr.cap.max_recv_wr = rq_depth;\n\tqp_attr.cap.max_send_sge = newxprt->sc_max_send_sges;\n\tqp_attr.cap.max_recv_sge = 1;\n\tqp_attr.sq_sig_type = IB_SIGNAL_REQ_WR;\n\tqp_attr.qp_type = IB_QPT_RC;\n\tqp_attr.send_cq = newxprt->sc_sq_cq;\n\tqp_attr.recv_cq = newxprt->sc_rq_cq;\n\tdprintk(\"svcrdma: newxprt->sc_cm_id=%p, newxprt->sc_pd=%p\\n\",\n\t\tnewxprt->sc_cm_id, newxprt->sc_pd);\n\tdprintk(\"    cap.max_send_wr = %d, cap.max_recv_wr = %d\\n\",\n\t\tqp_attr.cap.max_send_wr, qp_attr.cap.max_recv_wr);\n\tdprintk(\"    cap.max_send_sge = %d, cap.max_recv_sge = %d\\n\",\n\t\tqp_attr.cap.max_send_sge, qp_attr.cap.max_recv_sge);\n\n\tret = rdma_create_qp(newxprt->sc_cm_id, newxprt->sc_pd, &qp_attr);\n\tif (ret) {\n\t\ttrace_svcrdma_qp_err(newxprt, ret);\n\t\tgoto errout;\n\t}\n\tnewxprt->sc_qp = newxprt->sc_cm_id->qp;\n\n\tif (!(dev->attrs.device_cap_flags & IB_DEVICE_MEM_MGT_EXTENSIONS))\n\t\tnewxprt->sc_snd_w_inv = false;\n\tif (!rdma_protocol_iwarp(dev, newxprt->sc_port_num) &&\n\t    !rdma_ib_or_roce(dev, newxprt->sc_port_num)) {\n\t\ttrace_svcrdma_fabric_err(newxprt, -EINVAL);\n\t\tgoto errout;\n\t}\n\n\tif (!svc_rdma_post_recvs(newxprt))\n\t\tgoto errout;\n\n\t \n\tpmsg.cp_magic = rpcrdma_cmp_magic;\n\tpmsg.cp_version = RPCRDMA_CMP_VERSION;\n\tpmsg.cp_flags = 0;\n\tpmsg.cp_send_size = pmsg.cp_recv_size =\n\t\trpcrdma_encode_buffer_size(newxprt->sc_max_req_size);\n\n\t \n\tset_bit(RDMAXPRT_CONN_PENDING, &newxprt->sc_flags);\n\tmemset(&conn_param, 0, sizeof conn_param);\n\tconn_param.responder_resources = 0;\n\tconn_param.initiator_depth = min_t(int, newxprt->sc_ord,\n\t\t\t\t\t   dev->attrs.max_qp_init_rd_atom);\n\tif (!conn_param.initiator_depth) {\n\t\tret = -EINVAL;\n\t\ttrace_svcrdma_initdepth_err(newxprt, ret);\n\t\tgoto errout;\n\t}\n\tconn_param.private_data = &pmsg;\n\tconn_param.private_data_len = sizeof(pmsg);\n\trdma_lock_handler(newxprt->sc_cm_id);\n\tnewxprt->sc_cm_id->event_handler = svc_rdma_cma_handler;\n\tret = rdma_accept(newxprt->sc_cm_id, &conn_param);\n\trdma_unlock_handler(newxprt->sc_cm_id);\n\tif (ret) {\n\t\ttrace_svcrdma_accept_err(newxprt, ret);\n\t\tgoto errout;\n\t}\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n\tdprintk(\"svcrdma: new connection %p accepted:\\n\", newxprt);\n\tsap = (struct sockaddr *)&newxprt->sc_cm_id->route.addr.src_addr;\n\tdprintk(\"    local address   : %pIS:%u\\n\", sap, rpc_get_port(sap));\n\tsap = (struct sockaddr *)&newxprt->sc_cm_id->route.addr.dst_addr;\n\tdprintk(\"    remote address  : %pIS:%u\\n\", sap, rpc_get_port(sap));\n\tdprintk(\"    max_sge         : %d\\n\", newxprt->sc_max_send_sges);\n\tdprintk(\"    sq_depth        : %d\\n\", newxprt->sc_sq_depth);\n\tdprintk(\"    rdma_rw_ctxs    : %d\\n\", ctxts);\n\tdprintk(\"    max_requests    : %d\\n\", newxprt->sc_max_requests);\n\tdprintk(\"    ord             : %d\\n\", conn_param.initiator_depth);\n#endif\n\n\treturn &newxprt->sc_xprt;\n\n errout:\n\t \n\tsvc_xprt_get(&newxprt->sc_xprt);\n\tif (newxprt->sc_qp && !IS_ERR(newxprt->sc_qp))\n\t\tib_destroy_qp(newxprt->sc_qp);\n\trdma_destroy_id(newxprt->sc_cm_id);\n\t \n\tsvc_xprt_put(&newxprt->sc_xprt);\n\treturn NULL;\n}\n\nstatic void svc_rdma_detach(struct svc_xprt *xprt)\n{\n\tstruct svcxprt_rdma *rdma =\n\t\tcontainer_of(xprt, struct svcxprt_rdma, sc_xprt);\n\n\trdma_disconnect(rdma->sc_cm_id);\n}\n\nstatic void __svc_rdma_free(struct work_struct *work)\n{\n\tstruct svcxprt_rdma *rdma =\n\t\tcontainer_of(work, struct svcxprt_rdma, sc_work);\n\n\t \n\tif (rdma->sc_qp && !IS_ERR(rdma->sc_qp))\n\t\tib_drain_qp(rdma->sc_qp);\n\n\tsvc_rdma_flush_recv_queues(rdma);\n\n\tsvc_rdma_destroy_rw_ctxts(rdma);\n\tsvc_rdma_send_ctxts_destroy(rdma);\n\tsvc_rdma_recv_ctxts_destroy(rdma);\n\n\t \n\tif (rdma->sc_qp && !IS_ERR(rdma->sc_qp))\n\t\tib_destroy_qp(rdma->sc_qp);\n\n\tif (rdma->sc_sq_cq && !IS_ERR(rdma->sc_sq_cq))\n\t\tib_free_cq(rdma->sc_sq_cq);\n\n\tif (rdma->sc_rq_cq && !IS_ERR(rdma->sc_rq_cq))\n\t\tib_free_cq(rdma->sc_rq_cq);\n\n\tif (rdma->sc_pd && !IS_ERR(rdma->sc_pd))\n\t\tib_dealloc_pd(rdma->sc_pd);\n\n\t \n\trdma_destroy_id(rdma->sc_cm_id);\n\n\tkfree(rdma);\n}\n\nstatic void svc_rdma_free(struct svc_xprt *xprt)\n{\n\tstruct svcxprt_rdma *rdma =\n\t\tcontainer_of(xprt, struct svcxprt_rdma, sc_xprt);\n\n\tINIT_WORK(&rdma->sc_work, __svc_rdma_free);\n\tschedule_work(&rdma->sc_work);\n}\n\nstatic int svc_rdma_has_wspace(struct svc_xprt *xprt)\n{\n\tstruct svcxprt_rdma *rdma =\n\t\tcontainer_of(xprt, struct svcxprt_rdma, sc_xprt);\n\n\t \n\tif (waitqueue_active(&rdma->sc_send_wait))\n\t\treturn 0;\n\n\t \n\treturn 1;\n}\n\nstatic void svc_rdma_kill_temp_xprt(struct svc_xprt *xprt)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}