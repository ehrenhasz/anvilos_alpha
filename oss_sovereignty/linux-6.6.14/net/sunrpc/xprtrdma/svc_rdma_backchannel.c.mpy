{
  "module_name": "svc_rdma_backchannel.c",
  "hash_id": "1acf6257905f0c0596f9a3e6e323b3e857d0c06572a38bcaddbf6268ba835f1f",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/xprtrdma/svc_rdma_backchannel.c",
  "human_readable_source": "\n \n\n#include <linux/sunrpc/svc_rdma.h>\n\n#include \"xprt_rdma.h\"\n#include <trace/events/rpcrdma.h>\n\n \nvoid svc_rdma_handle_bc_reply(struct svc_rqst *rqstp,\n\t\t\t      struct svc_rdma_recv_ctxt *rctxt)\n{\n\tstruct svc_xprt *sxprt = rqstp->rq_xprt;\n\tstruct rpc_xprt *xprt = sxprt->xpt_bc_xprt;\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\tstruct xdr_buf *rcvbuf = &rqstp->rq_arg;\n\tstruct kvec *dst, *src = &rcvbuf->head[0];\n\t__be32 *rdma_resp = rctxt->rc_recv_buf;\n\tstruct rpc_rqst *req;\n\tu32 credits;\n\n\tspin_lock(&xprt->queue_lock);\n\treq = xprt_lookup_rqst(xprt, *rdma_resp);\n\tif (!req)\n\t\tgoto out_unlock;\n\n\tdst = &req->rq_private_buf.head[0];\n\tmemcpy(&req->rq_private_buf, &req->rq_rcv_buf, sizeof(struct xdr_buf));\n\tif (dst->iov_len < src->iov_len)\n\t\tgoto out_unlock;\n\tmemcpy(dst->iov_base, src->iov_base, src->iov_len);\n\txprt_pin_rqst(req);\n\tspin_unlock(&xprt->queue_lock);\n\n\tcredits = be32_to_cpup(rdma_resp + 2);\n\tif (credits == 0)\n\t\tcredits = 1;\t \n\telse if (credits > r_xprt->rx_buf.rb_bc_max_requests)\n\t\tcredits = r_xprt->rx_buf.rb_bc_max_requests;\n\tspin_lock(&xprt->transport_lock);\n\txprt->cwnd = credits << RPC_CWNDSHIFT;\n\tspin_unlock(&xprt->transport_lock);\n\n\tspin_lock(&xprt->queue_lock);\n\txprt_complete_rqst(req->rq_task, rcvbuf->len);\n\txprt_unpin_rqst(req);\n\trcvbuf->len = 0;\n\nout_unlock:\n\tspin_unlock(&xprt->queue_lock);\n}\n\n \nstatic int svc_rdma_bc_sendto(struct svcxprt_rdma *rdma,\n\t\t\t      struct rpc_rqst *rqst,\n\t\t\t      struct svc_rdma_send_ctxt *sctxt)\n{\n\tstruct svc_rdma_recv_ctxt *rctxt;\n\tint ret;\n\n\trctxt = svc_rdma_recv_ctxt_get(rdma);\n\tif (!rctxt)\n\t\treturn -EIO;\n\n\tret = svc_rdma_map_reply_msg(rdma, sctxt, rctxt, &rqst->rq_snd_buf);\n\tsvc_rdma_recv_ctxt_put(rdma, rctxt);\n\tif (ret < 0)\n\t\treturn -EIO;\n\n\t \n\tget_page(virt_to_page(rqst->rq_buffer));\n\tsctxt->sc_send_wr.opcode = IB_WR_SEND;\n\treturn svc_rdma_send(rdma, sctxt);\n}\n\n \nstatic int\nxprt_rdma_bc_allocate(struct rpc_task *task)\n{\n\tstruct rpc_rqst *rqst = task->tk_rqstp;\n\tsize_t size = rqst->rq_callsize;\n\tstruct page *page;\n\n\tif (size > PAGE_SIZE) {\n\t\tWARN_ONCE(1, \"svcrdma: large bc buffer request (size %zu)\\n\",\n\t\t\t  size);\n\t\treturn -EINVAL;\n\t}\n\n\tpage = alloc_page(GFP_NOIO | __GFP_NOWARN);\n\tif (!page)\n\t\treturn -ENOMEM;\n\trqst->rq_buffer = page_address(page);\n\n\trqst->rq_rbuffer = kmalloc(rqst->rq_rcvsize, GFP_NOIO | __GFP_NOWARN);\n\tif (!rqst->rq_rbuffer) {\n\t\tput_page(page);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void\nxprt_rdma_bc_free(struct rpc_task *task)\n{\n\tstruct rpc_rqst *rqst = task->tk_rqstp;\n\n\tput_page(virt_to_page(rqst->rq_buffer));\n\tkfree(rqst->rq_rbuffer);\n}\n\nstatic int\nrpcrdma_bc_send_request(struct svcxprt_rdma *rdma, struct rpc_rqst *rqst)\n{\n\tstruct rpc_xprt *xprt = rqst->rq_xprt;\n\tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n\tstruct svc_rdma_send_ctxt *ctxt;\n\t__be32 *p;\n\tint rc;\n\n\tctxt = svc_rdma_send_ctxt_get(rdma);\n\tif (!ctxt)\n\t\tgoto drop_connection;\n\n\tp = xdr_reserve_space(&ctxt->sc_stream, RPCRDMA_HDRLEN_MIN);\n\tif (!p)\n\t\tgoto put_ctxt;\n\t*p++ = rqst->rq_xid;\n\t*p++ = rpcrdma_version;\n\t*p++ = cpu_to_be32(r_xprt->rx_buf.rb_bc_max_requests);\n\t*p++ = rdma_msg;\n\t*p++ = xdr_zero;\n\t*p++ = xdr_zero;\n\t*p   = xdr_zero;\n\n\trqst->rq_xtime = ktime_get();\n\trc = svc_rdma_bc_sendto(rdma, rqst, ctxt);\n\tif (rc)\n\t\tgoto put_ctxt;\n\treturn 0;\n\nput_ctxt:\n\tsvc_rdma_send_ctxt_put(rdma, ctxt);\n\ndrop_connection:\n\treturn -ENOTCONN;\n}\n\n \nstatic int xprt_rdma_bc_send_request(struct rpc_rqst *rqst)\n{\n\tstruct svc_xprt *sxprt = rqst->rq_xprt->bc_xprt;\n\tstruct svcxprt_rdma *rdma =\n\t\tcontainer_of(sxprt, struct svcxprt_rdma, sc_xprt);\n\tint ret;\n\n\tif (test_bit(XPT_DEAD, &sxprt->xpt_flags))\n\t\treturn -ENOTCONN;\n\n\tret = rpcrdma_bc_send_request(rdma, rqst);\n\tif (ret == -ENOTCONN)\n\t\tsvc_xprt_close(sxprt);\n\treturn ret;\n}\n\nstatic void\nxprt_rdma_bc_close(struct rpc_xprt *xprt)\n{\n\txprt_disconnect_done(xprt);\n\txprt->cwnd = RPC_CWNDSHIFT;\n}\n\nstatic void\nxprt_rdma_bc_put(struct rpc_xprt *xprt)\n{\n\txprt_rdma_free_addresses(xprt);\n\txprt_free(xprt);\n}\n\nstatic const struct rpc_xprt_ops xprt_rdma_bc_procs = {\n\t.reserve_xprt\t\t= xprt_reserve_xprt_cong,\n\t.release_xprt\t\t= xprt_release_xprt_cong,\n\t.alloc_slot\t\t= xprt_alloc_slot,\n\t.free_slot\t\t= xprt_free_slot,\n\t.release_request\t= xprt_release_rqst_cong,\n\t.buf_alloc\t\t= xprt_rdma_bc_allocate,\n\t.buf_free\t\t= xprt_rdma_bc_free,\n\t.send_request\t\t= xprt_rdma_bc_send_request,\n\t.wait_for_reply_request\t= xprt_wait_for_reply_request_def,\n\t.close\t\t\t= xprt_rdma_bc_close,\n\t.destroy\t\t= xprt_rdma_bc_put,\n\t.print_stats\t\t= xprt_rdma_print_stats\n};\n\nstatic const struct rpc_timeout xprt_rdma_bc_timeout = {\n\t.to_initval = 60 * HZ,\n\t.to_maxval = 60 * HZ,\n};\n\n \nstatic struct rpc_xprt *\nxprt_setup_rdma_bc(struct xprt_create *args)\n{\n\tstruct rpc_xprt *xprt;\n\tstruct rpcrdma_xprt *new_xprt;\n\n\tif (args->addrlen > sizeof(xprt->addr))\n\t\treturn ERR_PTR(-EBADF);\n\n\txprt = xprt_alloc(args->net, sizeof(*new_xprt),\n\t\t\t  RPCRDMA_MAX_BC_REQUESTS,\n\t\t\t  RPCRDMA_MAX_BC_REQUESTS);\n\tif (!xprt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\txprt->timeout = &xprt_rdma_bc_timeout;\n\txprt_set_bound(xprt);\n\txprt_set_connected(xprt);\n\txprt->bind_timeout = 0;\n\txprt->reestablish_timeout = 0;\n\txprt->idle_timeout = 0;\n\n\txprt->prot = XPRT_TRANSPORT_BC_RDMA;\n\txprt->ops = &xprt_rdma_bc_procs;\n\n\tmemcpy(&xprt->addr, args->dstaddr, args->addrlen);\n\txprt->addrlen = args->addrlen;\n\txprt_rdma_format_addresses(xprt, (struct sockaddr *)&xprt->addr);\n\txprt->resvport = 0;\n\n\txprt->max_payload = xprt_rdma_max_inline_read;\n\n\tnew_xprt = rpcx_to_rdmax(xprt);\n\tnew_xprt->rx_buf.rb_bc_max_requests = xprt->max_reqs;\n\n\txprt_get(xprt);\n\targs->bc_xprt->xpt_bc_xprt = xprt;\n\txprt->bc_xprt = args->bc_xprt;\n\n\t \n\txprt_get(xprt);\n\treturn xprt;\n}\n\nstruct xprt_class xprt_rdma_bc = {\n\t.list\t\t\t= LIST_HEAD_INIT(xprt_rdma_bc.list),\n\t.name\t\t\t= \"rdma backchannel\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.ident\t\t\t= XPRT_TRANSPORT_BC_RDMA,\n\t.setup\t\t\t= xprt_setup_rdma_bc,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}