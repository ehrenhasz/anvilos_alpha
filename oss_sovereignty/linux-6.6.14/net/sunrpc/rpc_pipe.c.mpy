{
  "module_name": "rpc_pipe.c",
  "hash_id": "6275ee187b0d643355a42018557d42858f1e47ce282a023ae98ceb2127af7b81",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/rpc_pipe.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs_context.h>\n#include <linux/namei.h>\n#include <linux/fsnotify.h>\n#include <linux/kernel.h>\n#include <linux/rcupdate.h>\n#include <linux/utsname.h>\n\n#include <asm/ioctls.h>\n#include <linux/poll.h>\n#include <linux/wait.h>\n#include <linux/seq_file.h>\n\n#include <linux/sunrpc/clnt.h>\n#include <linux/workqueue.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/cache.h>\n#include <linux/nsproxy.h>\n#include <linux/notifier.h>\n\n#include \"netns.h\"\n#include \"sunrpc.h\"\n\n#define RPCDBG_FACILITY RPCDBG_DEBUG\n\n#define NET_NAME(net)\t((net == &init_net) ? \" (init_net)\" : \"\")\n\nstatic struct file_system_type rpc_pipe_fs_type;\nstatic const struct rpc_pipe_ops gssd_dummy_pipe_ops;\n\nstatic struct kmem_cache *rpc_inode_cachep __read_mostly;\n\n#define RPC_UPCALL_TIMEOUT (30*HZ)\n\nstatic BLOCKING_NOTIFIER_HEAD(rpc_pipefs_notifier_list);\n\nint rpc_pipefs_notifier_register(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&rpc_pipefs_notifier_list, nb);\n}\nEXPORT_SYMBOL_GPL(rpc_pipefs_notifier_register);\n\nvoid rpc_pipefs_notifier_unregister(struct notifier_block *nb)\n{\n\tblocking_notifier_chain_unregister(&rpc_pipefs_notifier_list, nb);\n}\nEXPORT_SYMBOL_GPL(rpc_pipefs_notifier_unregister);\n\nstatic void rpc_purge_list(wait_queue_head_t *waitq, struct list_head *head,\n\t\tvoid (*destroy_msg)(struct rpc_pipe_msg *), int err)\n{\n\tstruct rpc_pipe_msg *msg;\n\n\tif (list_empty(head))\n\t\treturn;\n\tdo {\n\t\tmsg = list_entry(head->next, struct rpc_pipe_msg, list);\n\t\tlist_del_init(&msg->list);\n\t\tmsg->errno = err;\n\t\tdestroy_msg(msg);\n\t} while (!list_empty(head));\n\n\tif (waitq)\n\t\twake_up(waitq);\n}\n\nstatic void\nrpc_timeout_upcall_queue(struct work_struct *work)\n{\n\tLIST_HEAD(free_list);\n\tstruct rpc_pipe *pipe =\n\t\tcontainer_of(work, struct rpc_pipe, queue_timeout.work);\n\tvoid (*destroy_msg)(struct rpc_pipe_msg *);\n\tstruct dentry *dentry;\n\n\tspin_lock(&pipe->lock);\n\tdestroy_msg = pipe->ops->destroy_msg;\n\tif (pipe->nreaders == 0) {\n\t\tlist_splice_init(&pipe->pipe, &free_list);\n\t\tpipe->pipelen = 0;\n\t}\n\tdentry = dget(pipe->dentry);\n\tspin_unlock(&pipe->lock);\n\trpc_purge_list(dentry ? &RPC_I(d_inode(dentry))->waitq : NULL,\n\t\t\t&free_list, destroy_msg, -ETIMEDOUT);\n\tdput(dentry);\n}\n\nssize_t rpc_pipe_generic_upcall(struct file *filp, struct rpc_pipe_msg *msg,\n\t\t\t\tchar __user *dst, size_t buflen)\n{\n\tchar *data = (char *)msg->data + msg->copied;\n\tsize_t mlen = min(msg->len - msg->copied, buflen);\n\tunsigned long left;\n\n\tleft = copy_to_user(dst, data, mlen);\n\tif (left == mlen) {\n\t\tmsg->errno = -EFAULT;\n\t\treturn -EFAULT;\n\t}\n\n\tmlen -= left;\n\tmsg->copied += mlen;\n\tmsg->errno = 0;\n\treturn mlen;\n}\nEXPORT_SYMBOL_GPL(rpc_pipe_generic_upcall);\n\n \nint\nrpc_queue_upcall(struct rpc_pipe *pipe, struct rpc_pipe_msg *msg)\n{\n\tint res = -EPIPE;\n\tstruct dentry *dentry;\n\n\tspin_lock(&pipe->lock);\n\tif (pipe->nreaders) {\n\t\tlist_add_tail(&msg->list, &pipe->pipe);\n\t\tpipe->pipelen += msg->len;\n\t\tres = 0;\n\t} else if (pipe->flags & RPC_PIPE_WAIT_FOR_OPEN) {\n\t\tif (list_empty(&pipe->pipe))\n\t\t\tqueue_delayed_work(rpciod_workqueue,\n\t\t\t\t\t&pipe->queue_timeout,\n\t\t\t\t\tRPC_UPCALL_TIMEOUT);\n\t\tlist_add_tail(&msg->list, &pipe->pipe);\n\t\tpipe->pipelen += msg->len;\n\t\tres = 0;\n\t}\n\tdentry = dget(pipe->dentry);\n\tspin_unlock(&pipe->lock);\n\tif (dentry) {\n\t\twake_up(&RPC_I(d_inode(dentry))->waitq);\n\t\tdput(dentry);\n\t}\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(rpc_queue_upcall);\n\nstatic inline void\nrpc_inode_setowner(struct inode *inode, void *private)\n{\n\tRPC_I(inode)->private = private;\n}\n\nstatic void\nrpc_close_pipes(struct inode *inode)\n{\n\tstruct rpc_pipe *pipe = RPC_I(inode)->pipe;\n\tint need_release;\n\tLIST_HEAD(free_list);\n\n\tinode_lock(inode);\n\tspin_lock(&pipe->lock);\n\tneed_release = pipe->nreaders != 0 || pipe->nwriters != 0;\n\tpipe->nreaders = 0;\n\tlist_splice_init(&pipe->in_upcall, &free_list);\n\tlist_splice_init(&pipe->pipe, &free_list);\n\tpipe->pipelen = 0;\n\tpipe->dentry = NULL;\n\tspin_unlock(&pipe->lock);\n\trpc_purge_list(&RPC_I(inode)->waitq, &free_list, pipe->ops->destroy_msg, -EPIPE);\n\tpipe->nwriters = 0;\n\tif (need_release && pipe->ops->release_pipe)\n\t\tpipe->ops->release_pipe(inode);\n\tcancel_delayed_work_sync(&pipe->queue_timeout);\n\trpc_inode_setowner(inode, NULL);\n\tRPC_I(inode)->pipe = NULL;\n\tinode_unlock(inode);\n}\n\nstatic struct inode *\nrpc_alloc_inode(struct super_block *sb)\n{\n\tstruct rpc_inode *rpci;\n\trpci = alloc_inode_sb(sb, rpc_inode_cachep, GFP_KERNEL);\n\tif (!rpci)\n\t\treturn NULL;\n\treturn &rpci->vfs_inode;\n}\n\nstatic void\nrpc_free_inode(struct inode *inode)\n{\n\tkmem_cache_free(rpc_inode_cachep, RPC_I(inode));\n}\n\nstatic int\nrpc_pipe_open(struct inode *inode, struct file *filp)\n{\n\tstruct rpc_pipe *pipe;\n\tint first_open;\n\tint res = -ENXIO;\n\n\tinode_lock(inode);\n\tpipe = RPC_I(inode)->pipe;\n\tif (pipe == NULL)\n\t\tgoto out;\n\tfirst_open = pipe->nreaders == 0 && pipe->nwriters == 0;\n\tif (first_open && pipe->ops->open_pipe) {\n\t\tres = pipe->ops->open_pipe(inode);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\tif (filp->f_mode & FMODE_READ)\n\t\tpipe->nreaders++;\n\tif (filp->f_mode & FMODE_WRITE)\n\t\tpipe->nwriters++;\n\tres = 0;\nout:\n\tinode_unlock(inode);\n\treturn res;\n}\n\nstatic int\nrpc_pipe_release(struct inode *inode, struct file *filp)\n{\n\tstruct rpc_pipe *pipe;\n\tstruct rpc_pipe_msg *msg;\n\tint last_close;\n\n\tinode_lock(inode);\n\tpipe = RPC_I(inode)->pipe;\n\tif (pipe == NULL)\n\t\tgoto out;\n\tmsg = filp->private_data;\n\tif (msg != NULL) {\n\t\tspin_lock(&pipe->lock);\n\t\tmsg->errno = -EAGAIN;\n\t\tlist_del_init(&msg->list);\n\t\tspin_unlock(&pipe->lock);\n\t\tpipe->ops->destroy_msg(msg);\n\t}\n\tif (filp->f_mode & FMODE_WRITE)\n\t\tpipe->nwriters --;\n\tif (filp->f_mode & FMODE_READ) {\n\t\tpipe->nreaders --;\n\t\tif (pipe->nreaders == 0) {\n\t\t\tLIST_HEAD(free_list);\n\t\t\tspin_lock(&pipe->lock);\n\t\t\tlist_splice_init(&pipe->pipe, &free_list);\n\t\t\tpipe->pipelen = 0;\n\t\t\tspin_unlock(&pipe->lock);\n\t\t\trpc_purge_list(&RPC_I(inode)->waitq, &free_list,\n\t\t\t\t\tpipe->ops->destroy_msg, -EAGAIN);\n\t\t}\n\t}\n\tlast_close = pipe->nwriters == 0 && pipe->nreaders == 0;\n\tif (last_close && pipe->ops->release_pipe)\n\t\tpipe->ops->release_pipe(inode);\nout:\n\tinode_unlock(inode);\n\treturn 0;\n}\n\nstatic ssize_t\nrpc_pipe_read(struct file *filp, char __user *buf, size_t len, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct rpc_pipe *pipe;\n\tstruct rpc_pipe_msg *msg;\n\tint res = 0;\n\n\tinode_lock(inode);\n\tpipe = RPC_I(inode)->pipe;\n\tif (pipe == NULL) {\n\t\tres = -EPIPE;\n\t\tgoto out_unlock;\n\t}\n\tmsg = filp->private_data;\n\tif (msg == NULL) {\n\t\tspin_lock(&pipe->lock);\n\t\tif (!list_empty(&pipe->pipe)) {\n\t\t\tmsg = list_entry(pipe->pipe.next,\n\t\t\t\t\tstruct rpc_pipe_msg,\n\t\t\t\t\tlist);\n\t\t\tlist_move(&msg->list, &pipe->in_upcall);\n\t\t\tpipe->pipelen -= msg->len;\n\t\t\tfilp->private_data = msg;\n\t\t\tmsg->copied = 0;\n\t\t}\n\t\tspin_unlock(&pipe->lock);\n\t\tif (msg == NULL)\n\t\t\tgoto out_unlock;\n\t}\n\t \n\tres = pipe->ops->upcall(filp, msg, buf, len);\n\tif (res < 0 || msg->len == msg->copied) {\n\t\tfilp->private_data = NULL;\n\t\tspin_lock(&pipe->lock);\n\t\tlist_del_init(&msg->list);\n\t\tspin_unlock(&pipe->lock);\n\t\tpipe->ops->destroy_msg(msg);\n\t}\nout_unlock:\n\tinode_unlock(inode);\n\treturn res;\n}\n\nstatic ssize_t\nrpc_pipe_write(struct file *filp, const char __user *buf, size_t len, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(filp);\n\tint res;\n\n\tinode_lock(inode);\n\tres = -EPIPE;\n\tif (RPC_I(inode)->pipe != NULL)\n\t\tres = RPC_I(inode)->pipe->ops->downcall(filp, buf, len);\n\tinode_unlock(inode);\n\treturn res;\n}\n\nstatic __poll_t\nrpc_pipe_poll(struct file *filp, struct poll_table_struct *wait)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct rpc_inode *rpci = RPC_I(inode);\n\t__poll_t mask = EPOLLOUT | EPOLLWRNORM;\n\n\tpoll_wait(filp, &rpci->waitq, wait);\n\n\tinode_lock(inode);\n\tif (rpci->pipe == NULL)\n\t\tmask |= EPOLLERR | EPOLLHUP;\n\telse if (filp->private_data || !list_empty(&rpci->pipe->pipe))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tinode_unlock(inode);\n\treturn mask;\n}\n\nstatic long\nrpc_pipe_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct rpc_pipe *pipe;\n\tint len;\n\n\tswitch (cmd) {\n\tcase FIONREAD:\n\t\tinode_lock(inode);\n\t\tpipe = RPC_I(inode)->pipe;\n\t\tif (pipe == NULL) {\n\t\t\tinode_unlock(inode);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tspin_lock(&pipe->lock);\n\t\tlen = pipe->pipelen;\n\t\tif (filp->private_data) {\n\t\t\tstruct rpc_pipe_msg *msg;\n\t\t\tmsg = filp->private_data;\n\t\t\tlen += msg->len - msg->copied;\n\t\t}\n\t\tspin_unlock(&pipe->lock);\n\t\tinode_unlock(inode);\n\t\treturn put_user(len, (int __user *)arg);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct file_operations rpc_pipe_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= rpc_pipe_read,\n\t.write\t\t= rpc_pipe_write,\n\t.poll\t\t= rpc_pipe_poll,\n\t.unlocked_ioctl\t= rpc_pipe_ioctl,\n\t.open\t\t= rpc_pipe_open,\n\t.release\t= rpc_pipe_release,\n};\n\nstatic int\nrpc_show_info(struct seq_file *m, void *v)\n{\n\tstruct rpc_clnt *clnt = m->private;\n\n\trcu_read_lock();\n\tseq_printf(m, \"RPC server: %s\\n\",\n\t\t\trcu_dereference(clnt->cl_xprt)->servername);\n\tseq_printf(m, \"service: %s (%d) version %d\\n\", clnt->cl_program->name,\n\t\t\tclnt->cl_prog, clnt->cl_vers);\n\tseq_printf(m, \"address: %s\\n\", rpc_peeraddr2str(clnt, RPC_DISPLAY_ADDR));\n\tseq_printf(m, \"protocol: %s\\n\", rpc_peeraddr2str(clnt, RPC_DISPLAY_PROTO));\n\tseq_printf(m, \"port: %s\\n\", rpc_peeraddr2str(clnt, RPC_DISPLAY_PORT));\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic int\nrpc_info_open(struct inode *inode, struct file *file)\n{\n\tstruct rpc_clnt *clnt = NULL;\n\tint ret = single_open(file, rpc_show_info, NULL);\n\n\tif (!ret) {\n\t\tstruct seq_file *m = file->private_data;\n\n\t\tspin_lock(&file->f_path.dentry->d_lock);\n\t\tif (!d_unhashed(file->f_path.dentry))\n\t\t\tclnt = RPC_I(inode)->private;\n\t\tif (clnt != NULL && refcount_inc_not_zero(&clnt->cl_count)) {\n\t\t\tspin_unlock(&file->f_path.dentry->d_lock);\n\t\t\tm->private = clnt;\n\t\t} else {\n\t\t\tspin_unlock(&file->f_path.dentry->d_lock);\n\t\t\tsingle_release(inode, file);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int\nrpc_info_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct rpc_clnt *clnt = (struct rpc_clnt *)m->private;\n\n\tif (clnt)\n\t\trpc_release_client(clnt);\n\treturn single_release(inode, file);\n}\n\nstatic const struct file_operations rpc_info_operations = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= rpc_info_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= rpc_info_release,\n};\n\n\n \nstruct rpc_filelist {\n\tconst char *name;\n\tconst struct file_operations *i_fop;\n\tumode_t mode;\n};\n\nstatic struct inode *\nrpc_get_inode(struct super_block *sb, umode_t mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode_set_ctime_current(inode);\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinode->i_op = &simple_dir_inode_operations;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn inode;\n}\n\nstatic int __rpc_create_common(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode,\n\t\t\t       const struct file_operations *i_fop,\n\t\t\t       void *private)\n{\n\tstruct inode *inode;\n\n\td_drop(dentry);\n\tinode = rpc_get_inode(dir->i_sb, mode);\n\tif (!inode)\n\t\tgoto out_err;\n\tinode->i_ino = iunique(dir->i_sb, 100);\n\tif (i_fop)\n\t\tinode->i_fop = i_fop;\n\tif (private)\n\t\trpc_inode_setowner(inode, private);\n\td_add(dentry, inode);\n\treturn 0;\nout_err:\n\tprintk(KERN_WARNING \"%s: %s failed to allocate inode for dentry %pd\\n\",\n\t\t\t__FILE__, __func__, dentry);\n\tdput(dentry);\n\treturn -ENOMEM;\n}\n\nstatic int __rpc_create(struct inode *dir, struct dentry *dentry,\n\t\t\tumode_t mode,\n\t\t\tconst struct file_operations *i_fop,\n\t\t\tvoid *private)\n{\n\tint err;\n\n\terr = __rpc_create_common(dir, dentry, S_IFREG | mode, i_fop, private);\n\tif (err)\n\t\treturn err;\n\tfsnotify_create(dir, dentry);\n\treturn 0;\n}\n\nstatic int __rpc_mkdir(struct inode *dir, struct dentry *dentry,\n\t\t       umode_t mode,\n\t\t       const struct file_operations *i_fop,\n\t\t       void *private)\n{\n\tint err;\n\n\terr = __rpc_create_common(dir, dentry, S_IFDIR | mode, i_fop, private);\n\tif (err)\n\t\treturn err;\n\tinc_nlink(dir);\n\tfsnotify_mkdir(dir, dentry);\n\treturn 0;\n}\n\nstatic void\ninit_pipe(struct rpc_pipe *pipe)\n{\n\tpipe->nreaders = 0;\n\tpipe->nwriters = 0;\n\tINIT_LIST_HEAD(&pipe->in_upcall);\n\tINIT_LIST_HEAD(&pipe->in_downcall);\n\tINIT_LIST_HEAD(&pipe->pipe);\n\tpipe->pipelen = 0;\n\tINIT_DELAYED_WORK(&pipe->queue_timeout,\n\t\t\t    rpc_timeout_upcall_queue);\n\tpipe->ops = NULL;\n\tspin_lock_init(&pipe->lock);\n\tpipe->dentry = NULL;\n}\n\nvoid rpc_destroy_pipe_data(struct rpc_pipe *pipe)\n{\n\tkfree(pipe);\n}\nEXPORT_SYMBOL_GPL(rpc_destroy_pipe_data);\n\nstruct rpc_pipe *rpc_mkpipe_data(const struct rpc_pipe_ops *ops, int flags)\n{\n\tstruct rpc_pipe *pipe;\n\n\tpipe = kzalloc(sizeof(struct rpc_pipe), GFP_KERNEL);\n\tif (!pipe)\n\t\treturn ERR_PTR(-ENOMEM);\n\tinit_pipe(pipe);\n\tpipe->ops = ops;\n\tpipe->flags = flags;\n\treturn pipe;\n}\nEXPORT_SYMBOL_GPL(rpc_mkpipe_data);\n\nstatic int __rpc_mkpipe_dentry(struct inode *dir, struct dentry *dentry,\n\t\t\t       umode_t mode,\n\t\t\t       const struct file_operations *i_fop,\n\t\t\t       void *private,\n\t\t\t       struct rpc_pipe *pipe)\n{\n\tstruct rpc_inode *rpci;\n\tint err;\n\n\terr = __rpc_create_common(dir, dentry, S_IFIFO | mode, i_fop, private);\n\tif (err)\n\t\treturn err;\n\trpci = RPC_I(d_inode(dentry));\n\trpci->private = private;\n\trpci->pipe = pipe;\n\tfsnotify_create(dir, dentry);\n\treturn 0;\n}\n\nstatic int __rpc_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint ret;\n\n\tdget(dentry);\n\tret = simple_rmdir(dir, dentry);\n\td_drop(dentry);\n\tif (!ret)\n\t\tfsnotify_rmdir(dir, dentry);\n\tdput(dentry);\n\treturn ret;\n}\n\nstatic int __rpc_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tint ret;\n\n\tdget(dentry);\n\tret = simple_unlink(dir, dentry);\n\td_drop(dentry);\n\tif (!ret)\n\t\tfsnotify_unlink(dir, dentry);\n\tdput(dentry);\n\treturn ret;\n}\n\nstatic int __rpc_rmpipe(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\trpc_close_pipes(inode);\n\treturn __rpc_unlink(dir, dentry);\n}\n\nstatic struct dentry *__rpc_lookup_create_exclusive(struct dentry *parent,\n\t\t\t\t\t  const char *name)\n{\n\tstruct qstr q = QSTR_INIT(name, strlen(name));\n\tstruct dentry *dentry = d_hash_and_lookup(parent, &q);\n\tif (!dentry) {\n\t\tdentry = d_alloc(parent, &q);\n\t\tif (!dentry)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (d_really_is_negative(dentry))\n\t\treturn dentry;\n\tdput(dentry);\n\treturn ERR_PTR(-EEXIST);\n}\n\n \nstatic void __rpc_depopulate(struct dentry *parent,\n\t\t\t     const struct rpc_filelist *files,\n\t\t\t     int start, int eof)\n{\n\tstruct inode *dir = d_inode(parent);\n\tstruct dentry *dentry;\n\tstruct qstr name;\n\tint i;\n\n\tfor (i = start; i < eof; i++) {\n\t\tname.name = files[i].name;\n\t\tname.len = strlen(files[i].name);\n\t\tdentry = d_hash_and_lookup(parent, &name);\n\n\t\tif (dentry == NULL)\n\t\t\tcontinue;\n\t\tif (d_really_is_negative(dentry))\n\t\t\tgoto next;\n\t\tswitch (d_inode(dentry)->i_mode & S_IFMT) {\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\tcase S_IFREG:\n\t\t\t\t__rpc_unlink(dir, dentry);\n\t\t\t\tbreak;\n\t\t\tcase S_IFDIR:\n\t\t\t\t__rpc_rmdir(dir, dentry);\n\t\t}\nnext:\n\t\tdput(dentry);\n\t}\n}\n\nstatic void rpc_depopulate(struct dentry *parent,\n\t\t\t   const struct rpc_filelist *files,\n\t\t\t   int start, int eof)\n{\n\tstruct inode *dir = d_inode(parent);\n\n\tinode_lock_nested(dir, I_MUTEX_CHILD);\n\t__rpc_depopulate(parent, files, start, eof);\n\tinode_unlock(dir);\n}\n\nstatic int rpc_populate(struct dentry *parent,\n\t\t\tconst struct rpc_filelist *files,\n\t\t\tint start, int eof,\n\t\t\tvoid *private)\n{\n\tstruct inode *dir = d_inode(parent);\n\tstruct dentry *dentry;\n\tint i, err;\n\n\tinode_lock(dir);\n\tfor (i = start; i < eof; i++) {\n\t\tdentry = __rpc_lookup_create_exclusive(parent, files[i].name);\n\t\terr = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry))\n\t\t\tgoto out_bad;\n\t\tswitch (files[i].mode & S_IFMT) {\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\tcase S_IFREG:\n\t\t\t\terr = __rpc_create(dir, dentry,\n\t\t\t\t\t\tfiles[i].mode,\n\t\t\t\t\t\tfiles[i].i_fop,\n\t\t\t\t\t\tprivate);\n\t\t\t\tbreak;\n\t\t\tcase S_IFDIR:\n\t\t\t\terr = __rpc_mkdir(dir, dentry,\n\t\t\t\t\t\tfiles[i].mode,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tprivate);\n\t\t}\n\t\tif (err != 0)\n\t\t\tgoto out_bad;\n\t}\n\tinode_unlock(dir);\n\treturn 0;\nout_bad:\n\t__rpc_depopulate(parent, files, start, eof);\n\tinode_unlock(dir);\n\tprintk(KERN_WARNING \"%s: %s failed to populate directory %pd\\n\",\n\t\t\t__FILE__, __func__, parent);\n\treturn err;\n}\n\nstatic struct dentry *rpc_mkdir_populate(struct dentry *parent,\n\t\tconst char *name, umode_t mode, void *private,\n\t\tint (*populate)(struct dentry *, void *), void *args_populate)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir = d_inode(parent);\n\tint error;\n\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tdentry = __rpc_lookup_create_exclusive(parent, name);\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\terror = __rpc_mkdir(dir, dentry, mode, NULL, private);\n\tif (error != 0)\n\t\tgoto out_err;\n\tif (populate != NULL) {\n\t\terror = populate(dentry, args_populate);\n\t\tif (error)\n\t\t\tgoto err_rmdir;\n\t}\nout:\n\tinode_unlock(dir);\n\treturn dentry;\nerr_rmdir:\n\t__rpc_rmdir(dir, dentry);\nout_err:\n\tdentry = ERR_PTR(error);\n\tgoto out;\n}\n\nstatic int rpc_rmdir_depopulate(struct dentry *dentry,\n\t\tvoid (*depopulate)(struct dentry *))\n{\n\tstruct dentry *parent;\n\tstruct inode *dir;\n\tint error;\n\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tif (depopulate != NULL)\n\t\tdepopulate(dentry);\n\terror = __rpc_rmdir(dir, dentry);\n\tinode_unlock(dir);\n\tdput(parent);\n\treturn error;\n}\n\n \nstruct dentry *rpc_mkpipe_dentry(struct dentry *parent, const char *name,\n\t\t\t\t void *private, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir = d_inode(parent);\n\tumode_t umode = S_IFIFO | 0600;\n\tint err;\n\n\tif (pipe->ops->upcall == NULL)\n\t\tumode &= ~0444;\n\tif (pipe->ops->downcall == NULL)\n\t\tumode &= ~0222;\n\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tdentry = __rpc_lookup_create_exclusive(parent, name);\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\terr = __rpc_mkpipe_dentry(dir, dentry, umode, &rpc_pipe_fops,\n\t\t\t\t  private, pipe);\n\tif (err)\n\t\tgoto out_err;\nout:\n\tinode_unlock(dir);\n\treturn dentry;\nout_err:\n\tdentry = ERR_PTR(err);\n\tprintk(KERN_WARNING \"%s: %s() failed to create pipe %pd/%s (errno = %d)\\n\",\n\t\t\t__FILE__, __func__, parent, name,\n\t\t\terr);\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(rpc_mkpipe_dentry);\n\n \nint\nrpc_unlink(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\tstruct inode *dir;\n\tint error = 0;\n\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\terror = __rpc_rmpipe(dir, dentry);\n\tinode_unlock(dir);\n\tdput(parent);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(rpc_unlink);\n\n \nvoid rpc_init_pipe_dir_head(struct rpc_pipe_dir_head *pdh)\n{\n\tINIT_LIST_HEAD(&pdh->pdh_entries);\n\tpdh->pdh_dentry = NULL;\n}\nEXPORT_SYMBOL_GPL(rpc_init_pipe_dir_head);\n\n \nvoid rpc_init_pipe_dir_object(struct rpc_pipe_dir_object *pdo,\n\t\tconst struct rpc_pipe_dir_object_ops *pdo_ops,\n\t\tvoid *pdo_data)\n{\n\tINIT_LIST_HEAD(&pdo->pdo_head);\n\tpdo->pdo_ops = pdo_ops;\n\tpdo->pdo_data = pdo_data;\n}\nEXPORT_SYMBOL_GPL(rpc_init_pipe_dir_object);\n\nstatic int\nrpc_add_pipe_dir_object_locked(struct net *net,\n\t\tstruct rpc_pipe_dir_head *pdh,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tint ret = 0;\n\n\tif (pdh->pdh_dentry)\n\t\tret = pdo->pdo_ops->create(pdh->pdh_dentry, pdo);\n\tif (ret == 0)\n\t\tlist_add_tail(&pdo->pdo_head, &pdh->pdh_entries);\n\treturn ret;\n}\n\nstatic void\nrpc_remove_pipe_dir_object_locked(struct net *net,\n\t\tstruct rpc_pipe_dir_head *pdh,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tif (pdh->pdh_dentry)\n\t\tpdo->pdo_ops->destroy(pdh->pdh_dentry, pdo);\n\tlist_del_init(&pdo->pdo_head);\n}\n\n \nint\nrpc_add_pipe_dir_object(struct net *net,\n\t\tstruct rpc_pipe_dir_head *pdh,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tint ret = 0;\n\n\tif (list_empty(&pdo->pdo_head)) {\n\t\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\t\tmutex_lock(&sn->pipefs_sb_lock);\n\t\tret = rpc_add_pipe_dir_object_locked(net, pdh, pdo);\n\t\tmutex_unlock(&sn->pipefs_sb_lock);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rpc_add_pipe_dir_object);\n\n \nvoid\nrpc_remove_pipe_dir_object(struct net *net,\n\t\tstruct rpc_pipe_dir_head *pdh,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tif (!list_empty(&pdo->pdo_head)) {\n\t\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\t\tmutex_lock(&sn->pipefs_sb_lock);\n\t\trpc_remove_pipe_dir_object_locked(net, pdh, pdo);\n\t\tmutex_unlock(&sn->pipefs_sb_lock);\n\t}\n}\nEXPORT_SYMBOL_GPL(rpc_remove_pipe_dir_object);\n\n \nstruct rpc_pipe_dir_object *\nrpc_find_or_alloc_pipe_dir_object(struct net *net,\n\t\tstruct rpc_pipe_dir_head *pdh,\n\t\tint (*match)(struct rpc_pipe_dir_object *, void *),\n\t\tstruct rpc_pipe_dir_object *(*alloc)(void *),\n\t\tvoid *data)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct rpc_pipe_dir_object *pdo;\n\n\tmutex_lock(&sn->pipefs_sb_lock);\n\tlist_for_each_entry(pdo, &pdh->pdh_entries, pdo_head) {\n\t\tif (!match(pdo, data))\n\t\t\tcontinue;\n\t\tgoto out;\n\t}\n\tpdo = alloc(data);\n\tif (!pdo)\n\t\tgoto out;\n\trpc_add_pipe_dir_object_locked(net, pdh, pdo);\nout:\n\tmutex_unlock(&sn->pipefs_sb_lock);\n\treturn pdo;\n}\nEXPORT_SYMBOL_GPL(rpc_find_or_alloc_pipe_dir_object);\n\nstatic void\nrpc_create_pipe_dir_objects(struct rpc_pipe_dir_head *pdh)\n{\n\tstruct rpc_pipe_dir_object *pdo;\n\tstruct dentry *dir = pdh->pdh_dentry;\n\n\tlist_for_each_entry(pdo, &pdh->pdh_entries, pdo_head)\n\t\tpdo->pdo_ops->create(dir, pdo);\n}\n\nstatic void\nrpc_destroy_pipe_dir_objects(struct rpc_pipe_dir_head *pdh)\n{\n\tstruct rpc_pipe_dir_object *pdo;\n\tstruct dentry *dir = pdh->pdh_dentry;\n\n\tlist_for_each_entry(pdo, &pdh->pdh_entries, pdo_head)\n\t\tpdo->pdo_ops->destroy(dir, pdo);\n}\n\nenum {\n\tRPCAUTH_info,\n\tRPCAUTH_EOF\n};\n\nstatic const struct rpc_filelist authfiles[] = {\n\t[RPCAUTH_info] = {\n\t\t.name = \"info\",\n\t\t.i_fop = &rpc_info_operations,\n\t\t.mode = S_IFREG | 0400,\n\t},\n};\n\nstatic int rpc_clntdir_populate(struct dentry *dentry, void *private)\n{\n\treturn rpc_populate(dentry,\n\t\t\t    authfiles, RPCAUTH_info, RPCAUTH_EOF,\n\t\t\t    private);\n}\n\nstatic void rpc_clntdir_depopulate(struct dentry *dentry)\n{\n\trpc_depopulate(dentry, authfiles, RPCAUTH_info, RPCAUTH_EOF);\n}\n\n \nstruct dentry *rpc_create_client_dir(struct dentry *dentry,\n\t\t\t\t   const char *name,\n\t\t\t\t   struct rpc_clnt *rpc_client)\n{\n\tstruct dentry *ret;\n\n\tret = rpc_mkdir_populate(dentry, name, 0555, NULL,\n\t\t\t\t rpc_clntdir_populate, rpc_client);\n\tif (!IS_ERR(ret)) {\n\t\trpc_client->cl_pipedir_objects.pdh_dentry = ret;\n\t\trpc_create_pipe_dir_objects(&rpc_client->cl_pipedir_objects);\n\t}\n\treturn ret;\n}\n\n \nint rpc_remove_client_dir(struct rpc_clnt *rpc_client)\n{\n\tstruct dentry *dentry = rpc_client->cl_pipedir_objects.pdh_dentry;\n\n\tif (dentry == NULL)\n\t\treturn 0;\n\trpc_destroy_pipe_dir_objects(&rpc_client->cl_pipedir_objects);\n\trpc_client->cl_pipedir_objects.pdh_dentry = NULL;\n\treturn rpc_rmdir_depopulate(dentry, rpc_clntdir_depopulate);\n}\n\nstatic const struct rpc_filelist cache_pipefs_files[3] = {\n\t[0] = {\n\t\t.name = \"channel\",\n\t\t.i_fop = &cache_file_operations_pipefs,\n\t\t.mode = S_IFREG | 0600,\n\t},\n\t[1] = {\n\t\t.name = \"content\",\n\t\t.i_fop = &content_file_operations_pipefs,\n\t\t.mode = S_IFREG | 0400,\n\t},\n\t[2] = {\n\t\t.name = \"flush\",\n\t\t.i_fop = &cache_flush_operations_pipefs,\n\t\t.mode = S_IFREG | 0600,\n\t},\n};\n\nstatic int rpc_cachedir_populate(struct dentry *dentry, void *private)\n{\n\treturn rpc_populate(dentry,\n\t\t\t    cache_pipefs_files, 0, 3,\n\t\t\t    private);\n}\n\nstatic void rpc_cachedir_depopulate(struct dentry *dentry)\n{\n\trpc_depopulate(dentry, cache_pipefs_files, 0, 3);\n}\n\nstruct dentry *rpc_create_cache_dir(struct dentry *parent, const char *name,\n\t\t\t\t    umode_t umode, struct cache_detail *cd)\n{\n\treturn rpc_mkdir_populate(parent, name, umode, NULL,\n\t\t\trpc_cachedir_populate, cd);\n}\n\nvoid rpc_remove_cache_dir(struct dentry *dentry)\n{\n\trpc_rmdir_depopulate(dentry, rpc_cachedir_depopulate);\n}\n\n \nstatic const struct super_operations s_ops = {\n\t.alloc_inode\t= rpc_alloc_inode,\n\t.free_inode\t= rpc_free_inode,\n\t.statfs\t\t= simple_statfs,\n};\n\n#define RPCAUTH_GSSMAGIC 0x67596969\n\n \nenum {\n\tRPCAUTH_lockd,\n\tRPCAUTH_mount,\n\tRPCAUTH_nfs,\n\tRPCAUTH_portmap,\n\tRPCAUTH_statd,\n\tRPCAUTH_nfsd4_cb,\n\tRPCAUTH_cache,\n\tRPCAUTH_nfsd,\n\tRPCAUTH_gssd,\n\tRPCAUTH_RootEOF\n};\n\nstatic const struct rpc_filelist files[] = {\n\t[RPCAUTH_lockd] = {\n\t\t.name = \"lockd\",\n\t\t.mode = S_IFDIR | 0555,\n\t},\n\t[RPCAUTH_mount] = {\n\t\t.name = \"mount\",\n\t\t.mode = S_IFDIR | 0555,\n\t},\n\t[RPCAUTH_nfs] = {\n\t\t.name = \"nfs\",\n\t\t.mode = S_IFDIR | 0555,\n\t},\n\t[RPCAUTH_portmap] = {\n\t\t.name = \"portmap\",\n\t\t.mode = S_IFDIR | 0555,\n\t},\n\t[RPCAUTH_statd] = {\n\t\t.name = \"statd\",\n\t\t.mode = S_IFDIR | 0555,\n\t},\n\t[RPCAUTH_nfsd4_cb] = {\n\t\t.name = \"nfsd4_cb\",\n\t\t.mode = S_IFDIR | 0555,\n\t},\n\t[RPCAUTH_cache] = {\n\t\t.name = \"cache\",\n\t\t.mode = S_IFDIR | 0555,\n\t},\n\t[RPCAUTH_nfsd] = {\n\t\t.name = \"nfsd\",\n\t\t.mode = S_IFDIR | 0555,\n\t},\n\t[RPCAUTH_gssd] = {\n\t\t.name = \"gssd\",\n\t\t.mode = S_IFDIR | 0555,\n\t},\n};\n\n \nstruct dentry *rpc_d_lookup_sb(const struct super_block *sb,\n\t\t\t       const unsigned char *dir_name)\n{\n\tstruct qstr dir = QSTR_INIT(dir_name, strlen(dir_name));\n\treturn d_hash_and_lookup(sb->s_root, &dir);\n}\nEXPORT_SYMBOL_GPL(rpc_d_lookup_sb);\n\nint rpc_pipefs_init_net(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tsn->gssd_dummy = rpc_mkpipe_data(&gssd_dummy_pipe_ops, 0);\n\tif (IS_ERR(sn->gssd_dummy))\n\t\treturn PTR_ERR(sn->gssd_dummy);\n\n\tmutex_init(&sn->pipefs_sb_lock);\n\tsn->pipe_version = -1;\n\treturn 0;\n}\n\nvoid rpc_pipefs_exit_net(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\trpc_destroy_pipe_data(sn->gssd_dummy);\n}\n\n \nstruct super_block *rpc_get_sb_net(const struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tmutex_lock(&sn->pipefs_sb_lock);\n\tif (sn->pipefs_sb)\n\t\treturn sn->pipefs_sb;\n\tmutex_unlock(&sn->pipefs_sb_lock);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(rpc_get_sb_net);\n\nvoid rpc_put_sb_net(const struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tWARN_ON(sn->pipefs_sb == NULL);\n\tmutex_unlock(&sn->pipefs_sb_lock);\n}\nEXPORT_SYMBOL_GPL(rpc_put_sb_net);\n\nstatic const struct rpc_filelist gssd_dummy_clnt_dir[] = {\n\t[0] = {\n\t\t.name = \"clntXX\",\n\t\t.mode = S_IFDIR | 0555,\n\t},\n};\n\nstatic ssize_t\ndummy_downcall(struct file *filp, const char __user *src, size_t len)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct rpc_pipe_ops gssd_dummy_pipe_ops = {\n\t.upcall\t\t= rpc_pipe_generic_upcall,\n\t.downcall\t= dummy_downcall,\n};\n\n \nstatic int\nrpc_dummy_info_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"RPC server: %s\\n\", utsname()->nodename);\n\tseq_printf(m, \"service: foo (1) version 0\\n\");\n\tseq_printf(m, \"address: 127.0.0.1\\n\");\n\tseq_printf(m, \"protocol: tcp\\n\");\n\tseq_printf(m, \"port: 0\\n\");\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(rpc_dummy_info);\n\nstatic const struct rpc_filelist gssd_dummy_info_file[] = {\n\t[0] = {\n\t\t.name = \"info\",\n\t\t.i_fop = &rpc_dummy_info_fops,\n\t\t.mode = S_IFREG | 0400,\n\t},\n};\n\n \nstatic struct dentry *\nrpc_gssd_dummy_populate(struct dentry *root, struct rpc_pipe *pipe_data)\n{\n\tint ret = 0;\n\tstruct dentry *gssd_dentry;\n\tstruct dentry *clnt_dentry = NULL;\n\tstruct dentry *pipe_dentry = NULL;\n\tstruct qstr q = QSTR_INIT(files[RPCAUTH_gssd].name,\n\t\t\t\t  strlen(files[RPCAUTH_gssd].name));\n\n\t \n\tgssd_dentry = d_hash_and_lookup(root, &q);\n\tif (!gssd_dentry)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tret = rpc_populate(gssd_dentry, gssd_dummy_clnt_dir, 0, 1, NULL);\n\tif (ret) {\n\t\tpipe_dentry = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tq.name = gssd_dummy_clnt_dir[0].name;\n\tq.len = strlen(gssd_dummy_clnt_dir[0].name);\n\tclnt_dentry = d_hash_and_lookup(gssd_dentry, &q);\n\tif (!clnt_dentry) {\n\t\t__rpc_depopulate(gssd_dentry, gssd_dummy_clnt_dir, 0, 1);\n\t\tpipe_dentry = ERR_PTR(-ENOENT);\n\t\tgoto out;\n\t}\n\n\tret = rpc_populate(clnt_dentry, gssd_dummy_info_file, 0, 1, NULL);\n\tif (ret) {\n\t\t__rpc_depopulate(gssd_dentry, gssd_dummy_clnt_dir, 0, 1);\n\t\tpipe_dentry = ERR_PTR(ret);\n\t\tgoto out;\n\t}\n\n\tpipe_dentry = rpc_mkpipe_dentry(clnt_dentry, \"gssd\", NULL, pipe_data);\n\tif (IS_ERR(pipe_dentry)) {\n\t\t__rpc_depopulate(clnt_dentry, gssd_dummy_info_file, 0, 1);\n\t\t__rpc_depopulate(gssd_dentry, gssd_dummy_clnt_dir, 0, 1);\n\t}\nout:\n\tdput(clnt_dentry);\n\tdput(gssd_dentry);\n\treturn pipe_dentry;\n}\n\nstatic void\nrpc_gssd_dummy_depopulate(struct dentry *pipe_dentry)\n{\n\tstruct dentry *clnt_dir = pipe_dentry->d_parent;\n\tstruct dentry *gssd_dir = clnt_dir->d_parent;\n\n\tdget(pipe_dentry);\n\t__rpc_rmpipe(d_inode(clnt_dir), pipe_dentry);\n\t__rpc_depopulate(clnt_dir, gssd_dummy_info_file, 0, 1);\n\t__rpc_depopulate(gssd_dir, gssd_dummy_clnt_dir, 0, 1);\n\tdput(pipe_dentry);\n}\n\nstatic int\nrpc_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct inode *inode;\n\tstruct dentry *root, *gssd_dentry;\n\tstruct net *net = sb->s_fs_info;\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tint err;\n\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic = RPCAUTH_GSSMAGIC;\n\tsb->s_op = &s_ops;\n\tsb->s_d_op = &simple_dentry_operations;\n\tsb->s_time_gran = 1;\n\n\tinode = rpc_get_inode(sb, S_IFDIR | 0555);\n\tsb->s_root = root = d_make_root(inode);\n\tif (!root)\n\t\treturn -ENOMEM;\n\tif (rpc_populate(root, files, RPCAUTH_lockd, RPCAUTH_RootEOF, NULL))\n\t\treturn -ENOMEM;\n\n\tgssd_dentry = rpc_gssd_dummy_populate(root, sn->gssd_dummy);\n\tif (IS_ERR(gssd_dentry)) {\n\t\t__rpc_depopulate(root, files, RPCAUTH_lockd, RPCAUTH_RootEOF);\n\t\treturn PTR_ERR(gssd_dentry);\n\t}\n\n\tdprintk(\"RPC:       sending pipefs MOUNT notification for net %x%s\\n\",\n\t\tnet->ns.inum, NET_NAME(net));\n\tmutex_lock(&sn->pipefs_sb_lock);\n\tsn->pipefs_sb = sb;\n\terr = blocking_notifier_call_chain(&rpc_pipefs_notifier_list,\n\t\t\t\t\t   RPC_PIPEFS_MOUNT,\n\t\t\t\t\t   sb);\n\tif (err)\n\t\tgoto err_depopulate;\n\tmutex_unlock(&sn->pipefs_sb_lock);\n\treturn 0;\n\nerr_depopulate:\n\trpc_gssd_dummy_depopulate(gssd_dentry);\n\tblocking_notifier_call_chain(&rpc_pipefs_notifier_list,\n\t\t\t\t\t   RPC_PIPEFS_UMOUNT,\n\t\t\t\t\t   sb);\n\tsn->pipefs_sb = NULL;\n\t__rpc_depopulate(root, files, RPCAUTH_lockd, RPCAUTH_RootEOF);\n\tmutex_unlock(&sn->pipefs_sb_lock);\n\treturn err;\n}\n\nbool\ngssd_running(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct rpc_pipe *pipe = sn->gssd_dummy;\n\n\treturn pipe->nreaders || pipe->nwriters;\n}\nEXPORT_SYMBOL_GPL(gssd_running);\n\nstatic int rpc_fs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_keyed(fc, rpc_fill_super, get_net(fc->net_ns));\n}\n\nstatic void rpc_fs_free_fc(struct fs_context *fc)\n{\n\tif (fc->s_fs_info)\n\t\tput_net(fc->s_fs_info);\n}\n\nstatic const struct fs_context_operations rpc_fs_context_ops = {\n\t.free\t\t= rpc_fs_free_fc,\n\t.get_tree\t= rpc_fs_get_tree,\n};\n\nstatic int rpc_init_fs_context(struct fs_context *fc)\n{\n\tput_user_ns(fc->user_ns);\n\tfc->user_ns = get_user_ns(fc->net_ns->user_ns);\n\tfc->ops = &rpc_fs_context_ops;\n\treturn 0;\n}\n\nstatic void rpc_kill_sb(struct super_block *sb)\n{\n\tstruct net *net = sb->s_fs_info;\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tmutex_lock(&sn->pipefs_sb_lock);\n\tif (sn->pipefs_sb != sb) {\n\t\tmutex_unlock(&sn->pipefs_sb_lock);\n\t\tgoto out;\n\t}\n\tsn->pipefs_sb = NULL;\n\tdprintk(\"RPC:       sending pipefs UMOUNT notification for net %x%s\\n\",\n\t\tnet->ns.inum, NET_NAME(net));\n\tblocking_notifier_call_chain(&rpc_pipefs_notifier_list,\n\t\t\t\t\t   RPC_PIPEFS_UMOUNT,\n\t\t\t\t\t   sb);\n\tmutex_unlock(&sn->pipefs_sb_lock);\nout:\n\tkill_litter_super(sb);\n\tput_net(net);\n}\n\nstatic struct file_system_type rpc_pipe_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"rpc_pipefs\",\n\t.init_fs_context = rpc_init_fs_context,\n\t.kill_sb\t= rpc_kill_sb,\n};\nMODULE_ALIAS_FS(\"rpc_pipefs\");\nMODULE_ALIAS(\"rpc_pipefs\");\n\nstatic void\ninit_once(void *foo)\n{\n\tstruct rpc_inode *rpci = (struct rpc_inode *) foo;\n\n\tinode_init_once(&rpci->vfs_inode);\n\trpci->private = NULL;\n\trpci->pipe = NULL;\n\tinit_waitqueue_head(&rpci->waitq);\n}\n\nint register_rpc_pipefs(void)\n{\n\tint err;\n\n\trpc_inode_cachep = kmem_cache_create(\"rpc_inode_cache\",\n\t\t\t\tsizeof(struct rpc_inode),\n\t\t\t\t0, (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\tinit_once);\n\tif (!rpc_inode_cachep)\n\t\treturn -ENOMEM;\n\terr = rpc_clients_notifier_register();\n\tif (err)\n\t\tgoto err_notifier;\n\terr = register_filesystem(&rpc_pipe_fs_type);\n\tif (err)\n\t\tgoto err_register;\n\treturn 0;\n\nerr_register:\n\trpc_clients_notifier_unregister();\nerr_notifier:\n\tkmem_cache_destroy(rpc_inode_cachep);\n\treturn err;\n}\n\nvoid unregister_rpc_pipefs(void)\n{\n\trpc_clients_notifier_unregister();\n\tunregister_filesystem(&rpc_pipe_fs_type);\n\tkmem_cache_destroy(rpc_inode_cachep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}