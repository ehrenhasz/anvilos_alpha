{
  "module_name": "svcauth.c",
  "hash_id": "55509167152ae5f5b5fe2d933f317d5fae07893de86c633f3cecff269ff21e77",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/svcauth.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/sunrpc/types.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svcauth.h>\n#include <linux/err.h>\n#include <linux/hash.h>\n\n#include <trace/events/sunrpc.h>\n\n#include \"sunrpc.h\"\n\n#define RPCDBG_FACILITY\tRPCDBG_AUTH\n\n\n \nextern struct auth_ops svcauth_null;\nextern struct auth_ops svcauth_unix;\nextern struct auth_ops svcauth_tls;\n\nstatic struct auth_ops __rcu *authtab[RPC_AUTH_MAXFLAVOR] = {\n\t[RPC_AUTH_NULL] = (struct auth_ops __force __rcu *)&svcauth_null,\n\t[RPC_AUTH_UNIX] = (struct auth_ops __force __rcu *)&svcauth_unix,\n\t[RPC_AUTH_TLS]  = (struct auth_ops __force __rcu *)&svcauth_tls,\n};\n\nstatic struct auth_ops *\nsvc_get_auth_ops(rpc_authflavor_t flavor)\n{\n\tstruct auth_ops\t\t*aops;\n\n\tif (flavor >= RPC_AUTH_MAXFLAVOR)\n\t\treturn NULL;\n\trcu_read_lock();\n\taops = rcu_dereference(authtab[flavor]);\n\tif (aops != NULL && !try_module_get(aops->owner))\n\t\taops = NULL;\n\trcu_read_unlock();\n\treturn aops;\n}\n\nstatic void\nsvc_put_auth_ops(struct auth_ops *aops)\n{\n\tmodule_put(aops->owner);\n}\n\n \nenum svc_auth_status svc_authenticate(struct svc_rqst *rqstp)\n{\n\tstruct auth_ops *aops;\n\tu32 flavor;\n\n\trqstp->rq_auth_stat = rpc_auth_ok;\n\n\t \n\tif (xdr_stream_decode_u32(&rqstp->rq_arg_stream, &flavor) < 0)\n\t\treturn SVC_GARBAGE;\n\n\taops = svc_get_auth_ops(flavor);\n\tif (aops == NULL) {\n\t\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\t\treturn SVC_DENIED;\n\t}\n\n\trqstp->rq_auth_slack = 0;\n\tinit_svc_cred(&rqstp->rq_cred);\n\n\trqstp->rq_authop = aops;\n\treturn aops->accept(rqstp);\n}\nEXPORT_SYMBOL_GPL(svc_authenticate);\n\n \nenum svc_auth_status svc_set_client(struct svc_rqst *rqstp)\n{\n\trqstp->rq_client = NULL;\n\treturn rqstp->rq_authop->set_client(rqstp);\n}\nEXPORT_SYMBOL_GPL(svc_set_client);\n\n \nint svc_authorise(struct svc_rqst *rqstp)\n{\n\tstruct auth_ops *aops = rqstp->rq_authop;\n\tint rv = 0;\n\n\trqstp->rq_authop = NULL;\n\n\tif (aops) {\n\t\trv = aops->release(rqstp);\n\t\tsvc_put_auth_ops(aops);\n\t}\n\treturn rv;\n}\n\nint\nsvc_auth_register(rpc_authflavor_t flavor, struct auth_ops *aops)\n{\n\tstruct auth_ops *old;\n\tint rv = -EINVAL;\n\n\tif (flavor < RPC_AUTH_MAXFLAVOR) {\n\t\told = cmpxchg((struct auth_ops ** __force)&authtab[flavor], NULL, aops);\n\t\tif (old == NULL || old == aops)\n\t\t\trv = 0;\n\t}\n\treturn rv;\n}\nEXPORT_SYMBOL_GPL(svc_auth_register);\n\nvoid\nsvc_auth_unregister(rpc_authflavor_t flavor)\n{\n\tif (flavor < RPC_AUTH_MAXFLAVOR)\n\t\trcu_assign_pointer(authtab[flavor], NULL);\n}\nEXPORT_SYMBOL_GPL(svc_auth_unregister);\n\n \n\n#define\tDN_HASHBITS\t6\n#define\tDN_HASHMAX\t(1<<DN_HASHBITS)\n\nstatic struct hlist_head\tauth_domain_table[DN_HASHMAX];\nstatic DEFINE_SPINLOCK(auth_domain_lock);\n\nstatic void auth_domain_release(struct kref *kref)\n\t__releases(&auth_domain_lock)\n{\n\tstruct auth_domain *dom = container_of(kref, struct auth_domain, ref);\n\n\thlist_del_rcu(&dom->hash);\n\tdom->flavour->domain_release(dom);\n\tspin_unlock(&auth_domain_lock);\n}\n\nvoid auth_domain_put(struct auth_domain *dom)\n{\n\tkref_put_lock(&dom->ref, auth_domain_release, &auth_domain_lock);\n}\nEXPORT_SYMBOL_GPL(auth_domain_put);\n\nstruct auth_domain *\nauth_domain_lookup(char *name, struct auth_domain *new)\n{\n\tstruct auth_domain *hp;\n\tstruct hlist_head *head;\n\n\thead = &auth_domain_table[hash_str(name, DN_HASHBITS)];\n\n\tspin_lock(&auth_domain_lock);\n\n\thlist_for_each_entry(hp, head, hash) {\n\t\tif (strcmp(hp->name, name)==0) {\n\t\t\tkref_get(&hp->ref);\n\t\t\tspin_unlock(&auth_domain_lock);\n\t\t\treturn hp;\n\t\t}\n\t}\n\tif (new)\n\t\thlist_add_head_rcu(&new->hash, head);\n\tspin_unlock(&auth_domain_lock);\n\treturn new;\n}\nEXPORT_SYMBOL_GPL(auth_domain_lookup);\n\nstruct auth_domain *auth_domain_find(char *name)\n{\n\tstruct auth_domain *hp;\n\tstruct hlist_head *head;\n\n\thead = &auth_domain_table[hash_str(name, DN_HASHBITS)];\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(hp, head, hash) {\n\t\tif (strcmp(hp->name, name)==0) {\n\t\t\tif (!kref_get_unless_zero(&hp->ref))\n\t\t\t\thp = NULL;\n\t\t\trcu_read_unlock();\n\t\t\treturn hp;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(auth_domain_find);\n\n \n\nvoid auth_domain_cleanup(void)\n{\n\tint h;\n\tstruct auth_domain *hp;\n\n\tfor (h = 0; h < DN_HASHMAX; h++)\n\t\thlist_for_each_entry(hp, &auth_domain_table[h], hash)\n\t\t\tpr_warn(\"svc: domain %s still present at module unload.\\n\",\n\t\t\t\thp->name);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}