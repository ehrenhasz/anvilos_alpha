{
  "module_name": "svc.c",
  "hash_id": "65c2032235812e10872a75303f5317f11673cf92e139f78e8d55aaa7fe36a2cc",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/svc.c",
  "human_readable_source": "\n \n\n#include <linux/linkage.h>\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n\n#include <linux/sunrpc/types.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/bc_xprt.h>\n\n#include <trace/events/sunrpc.h>\n\n#include \"fail.h\"\n\n#define RPCDBG_FACILITY\tRPCDBG_SVCDSP\n\nstatic void svc_unregister(const struct svc_serv *serv, struct net *net);\n\n#define SVC_POOL_DEFAULT\tSVC_POOL_GLOBAL\n\n \nenum {\n\tSVC_POOL_AUTO = -1,\t \n\tSVC_POOL_GLOBAL,\t \n\tSVC_POOL_PERCPU,\t \n\tSVC_POOL_PERNODE\t \n};\n\n \n\nstruct svc_pool_map {\n\tint count;\t\t\t \n\tint mode;\t\t\t \n\tunsigned int npools;\n\tunsigned int *pool_to;\t\t \n\tunsigned int *to_pool;\t\t \n};\n\nstatic struct svc_pool_map svc_pool_map = {\n\t.mode = SVC_POOL_DEFAULT\n};\n\nstatic DEFINE_MUTEX(svc_pool_map_mutex); \n\nstatic int\nparam_set_pool_mode(const char *val, const struct kernel_param *kp)\n{\n\tint *ip = (int *)kp->arg;\n\tstruct svc_pool_map *m = &svc_pool_map;\n\tint err;\n\n\tmutex_lock(&svc_pool_map_mutex);\n\n\terr = -EBUSY;\n\tif (m->count)\n\t\tgoto out;\n\n\terr = 0;\n\tif (!strncmp(val, \"auto\", 4))\n\t\t*ip = SVC_POOL_AUTO;\n\telse if (!strncmp(val, \"global\", 6))\n\t\t*ip = SVC_POOL_GLOBAL;\n\telse if (!strncmp(val, \"percpu\", 6))\n\t\t*ip = SVC_POOL_PERCPU;\n\telse if (!strncmp(val, \"pernode\", 7))\n\t\t*ip = SVC_POOL_PERNODE;\n\telse\n\t\terr = -EINVAL;\n\nout:\n\tmutex_unlock(&svc_pool_map_mutex);\n\treturn err;\n}\n\nstatic int\nparam_get_pool_mode(char *buf, const struct kernel_param *kp)\n{\n\tint *ip = (int *)kp->arg;\n\n\tswitch (*ip)\n\t{\n\tcase SVC_POOL_AUTO:\n\t\treturn sysfs_emit(buf, \"auto\\n\");\n\tcase SVC_POOL_GLOBAL:\n\t\treturn sysfs_emit(buf, \"global\\n\");\n\tcase SVC_POOL_PERCPU:\n\t\treturn sysfs_emit(buf, \"percpu\\n\");\n\tcase SVC_POOL_PERNODE:\n\t\treturn sysfs_emit(buf, \"pernode\\n\");\n\tdefault:\n\t\treturn sysfs_emit(buf, \"%d\\n\", *ip);\n\t}\n}\n\nmodule_param_call(pool_mode, param_set_pool_mode, param_get_pool_mode,\n\t\t &svc_pool_map.mode, 0644);\n\n \nstatic int\nsvc_pool_map_choose_mode(void)\n{\n\tunsigned int node;\n\n\tif (nr_online_nodes > 1) {\n\t\t \n\t\treturn SVC_POOL_PERNODE;\n\t}\n\n\tnode = first_online_node;\n\tif (nr_cpus_node(node) > 2) {\n\t\t \n\t\treturn SVC_POOL_PERCPU;\n\t}\n\n\t \n\treturn SVC_POOL_GLOBAL;\n}\n\n \nstatic int\nsvc_pool_map_alloc_arrays(struct svc_pool_map *m, unsigned int maxpools)\n{\n\tm->to_pool = kcalloc(maxpools, sizeof(unsigned int), GFP_KERNEL);\n\tif (!m->to_pool)\n\t\tgoto fail;\n\tm->pool_to = kcalloc(maxpools, sizeof(unsigned int), GFP_KERNEL);\n\tif (!m->pool_to)\n\t\tgoto fail_free;\n\n\treturn 0;\n\nfail_free:\n\tkfree(m->to_pool);\n\tm->to_pool = NULL;\nfail:\n\treturn -ENOMEM;\n}\n\n \nstatic int\nsvc_pool_map_init_percpu(struct svc_pool_map *m)\n{\n\tunsigned int maxpools = nr_cpu_ids;\n\tunsigned int pidx = 0;\n\tunsigned int cpu;\n\tint err;\n\n\terr = svc_pool_map_alloc_arrays(m, maxpools);\n\tif (err)\n\t\treturn err;\n\n\tfor_each_online_cpu(cpu) {\n\t\tBUG_ON(pidx >= maxpools);\n\t\tm->to_pool[cpu] = pidx;\n\t\tm->pool_to[pidx] = cpu;\n\t\tpidx++;\n\t}\n\t \n\n\treturn pidx;\n};\n\n\n \nstatic int\nsvc_pool_map_init_pernode(struct svc_pool_map *m)\n{\n\tunsigned int maxpools = nr_node_ids;\n\tunsigned int pidx = 0;\n\tunsigned int node;\n\tint err;\n\n\terr = svc_pool_map_alloc_arrays(m, maxpools);\n\tif (err)\n\t\treturn err;\n\n\tfor_each_node_with_cpus(node) {\n\t\t \n\t\tBUG_ON(pidx > maxpools);\n\t\tm->to_pool[node] = pidx;\n\t\tm->pool_to[pidx] = node;\n\t\tpidx++;\n\t}\n\t \n\n\treturn pidx;\n}\n\n\n \nstatic unsigned int\nsvc_pool_map_get(void)\n{\n\tstruct svc_pool_map *m = &svc_pool_map;\n\tint npools = -1;\n\n\tmutex_lock(&svc_pool_map_mutex);\n\n\tif (m->count++) {\n\t\tmutex_unlock(&svc_pool_map_mutex);\n\t\tWARN_ON_ONCE(m->npools <= 1);\n\t\treturn m->npools;\n\t}\n\n\tif (m->mode == SVC_POOL_AUTO)\n\t\tm->mode = svc_pool_map_choose_mode();\n\n\tswitch (m->mode) {\n\tcase SVC_POOL_PERCPU:\n\t\tnpools = svc_pool_map_init_percpu(m);\n\t\tbreak;\n\tcase SVC_POOL_PERNODE:\n\t\tnpools = svc_pool_map_init_pernode(m);\n\t\tbreak;\n\t}\n\n\tif (npools <= 0) {\n\t\t \n\t\tnpools = 1;\n\t\tm->mode = SVC_POOL_GLOBAL;\n\t}\n\tm->npools = npools;\n\n\tif (npools == 1)\n\t\t \n\t\tm->count--;\n\n\tmutex_unlock(&svc_pool_map_mutex);\n\treturn npools;\n}\n\n \nstatic void\nsvc_pool_map_put(int npools)\n{\n\tstruct svc_pool_map *m = &svc_pool_map;\n\n\tif (npools <= 1)\n\t\treturn;\n\tmutex_lock(&svc_pool_map_mutex);\n\n\tif (!--m->count) {\n\t\tkfree(m->to_pool);\n\t\tm->to_pool = NULL;\n\t\tkfree(m->pool_to);\n\t\tm->pool_to = NULL;\n\t\tm->npools = 0;\n\t}\n\n\tmutex_unlock(&svc_pool_map_mutex);\n}\n\nstatic int svc_pool_map_get_node(unsigned int pidx)\n{\n\tconst struct svc_pool_map *m = &svc_pool_map;\n\n\tif (m->count) {\n\t\tif (m->mode == SVC_POOL_PERCPU)\n\t\t\treturn cpu_to_node(m->pool_to[pidx]);\n\t\tif (m->mode == SVC_POOL_PERNODE)\n\t\t\treturn m->pool_to[pidx];\n\t}\n\treturn NUMA_NO_NODE;\n}\n \nstatic inline void\nsvc_pool_map_set_cpumask(struct task_struct *task, unsigned int pidx)\n{\n\tstruct svc_pool_map *m = &svc_pool_map;\n\tunsigned int node = m->pool_to[pidx];\n\n\t \n\tWARN_ON_ONCE(m->count == 0);\n\tif (m->count == 0)\n\t\treturn;\n\n\tswitch (m->mode) {\n\tcase SVC_POOL_PERCPU:\n\t{\n\t\tset_cpus_allowed_ptr(task, cpumask_of(node));\n\t\tbreak;\n\t}\n\tcase SVC_POOL_PERNODE:\n\t{\n\t\tset_cpus_allowed_ptr(task, cpumask_of_node(node));\n\t\tbreak;\n\t}\n\t}\n}\n\n \nstruct svc_pool *svc_pool_for_cpu(struct svc_serv *serv)\n{\n\tstruct svc_pool_map *m = &svc_pool_map;\n\tint cpu = raw_smp_processor_id();\n\tunsigned int pidx = 0;\n\n\tif (serv->sv_nrpools <= 1)\n\t\treturn serv->sv_pools;\n\n\tswitch (m->mode) {\n\tcase SVC_POOL_PERCPU:\n\t\tpidx = m->to_pool[cpu];\n\t\tbreak;\n\tcase SVC_POOL_PERNODE:\n\t\tpidx = m->to_pool[cpu_to_node(cpu)];\n\t\tbreak;\n\t}\n\n\treturn &serv->sv_pools[pidx % serv->sv_nrpools];\n}\n\nint svc_rpcb_setup(struct svc_serv *serv, struct net *net)\n{\n\tint err;\n\n\terr = rpcb_create_local(net);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsvc_unregister(serv, net);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(svc_rpcb_setup);\n\nvoid svc_rpcb_cleanup(struct svc_serv *serv, struct net *net)\n{\n\tsvc_unregister(serv, net);\n\trpcb_put_local(net);\n}\nEXPORT_SYMBOL_GPL(svc_rpcb_cleanup);\n\nstatic int svc_uses_rpcbind(struct svc_serv *serv)\n{\n\tstruct svc_program\t*progp;\n\tunsigned int\t\ti;\n\n\tfor (progp = serv->sv_program; progp; progp = progp->pg_next) {\n\t\tfor (i = 0; i < progp->pg_nvers; i++) {\n\t\t\tif (progp->pg_vers[i] == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (!progp->pg_vers[i]->vs_hidden)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint svc_bind(struct svc_serv *serv, struct net *net)\n{\n\tif (!svc_uses_rpcbind(serv))\n\t\treturn 0;\n\treturn svc_rpcb_setup(serv, net);\n}\nEXPORT_SYMBOL_GPL(svc_bind);\n\n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\nstatic void\n__svc_init_bc(struct svc_serv *serv)\n{\n\tINIT_LIST_HEAD(&serv->sv_cb_list);\n\tspin_lock_init(&serv->sv_cb_lock);\n\tinit_waitqueue_head(&serv->sv_cb_waitq);\n}\n#else\nstatic void\n__svc_init_bc(struct svc_serv *serv)\n{\n}\n#endif\n\n \nstatic struct svc_serv *\n__svc_create(struct svc_program *prog, unsigned int bufsize, int npools,\n\t     int (*threadfn)(void *data))\n{\n\tstruct svc_serv\t*serv;\n\tunsigned int vers;\n\tunsigned int xdrsize;\n\tunsigned int i;\n\n\tif (!(serv = kzalloc(sizeof(*serv), GFP_KERNEL)))\n\t\treturn NULL;\n\tserv->sv_name      = prog->pg_name;\n\tserv->sv_program   = prog;\n\tkref_init(&serv->sv_refcnt);\n\tserv->sv_stats     = prog->pg_stats;\n\tif (bufsize > RPCSVC_MAXPAYLOAD)\n\t\tbufsize = RPCSVC_MAXPAYLOAD;\n\tserv->sv_max_payload = bufsize? bufsize : 4096;\n\tserv->sv_max_mesg  = roundup(serv->sv_max_payload + PAGE_SIZE, PAGE_SIZE);\n\tserv->sv_threadfn = threadfn;\n\txdrsize = 0;\n\twhile (prog) {\n\t\tprog->pg_lovers = prog->pg_nvers-1;\n\t\tfor (vers=0; vers<prog->pg_nvers ; vers++)\n\t\t\tif (prog->pg_vers[vers]) {\n\t\t\t\tprog->pg_hivers = vers;\n\t\t\t\tif (prog->pg_lovers > vers)\n\t\t\t\t\tprog->pg_lovers = vers;\n\t\t\t\tif (prog->pg_vers[vers]->vs_xdrsize > xdrsize)\n\t\t\t\t\txdrsize = prog->pg_vers[vers]->vs_xdrsize;\n\t\t\t}\n\t\tprog = prog->pg_next;\n\t}\n\tserv->sv_xdrsize   = xdrsize;\n\tINIT_LIST_HEAD(&serv->sv_tempsocks);\n\tINIT_LIST_HEAD(&serv->sv_permsocks);\n\ttimer_setup(&serv->sv_temptimer, NULL, 0);\n\tspin_lock_init(&serv->sv_lock);\n\n\t__svc_init_bc(serv);\n\n\tserv->sv_nrpools = npools;\n\tserv->sv_pools =\n\t\tkcalloc(serv->sv_nrpools, sizeof(struct svc_pool),\n\t\t\tGFP_KERNEL);\n\tif (!serv->sv_pools) {\n\t\tkfree(serv);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < serv->sv_nrpools; i++) {\n\t\tstruct svc_pool *pool = &serv->sv_pools[i];\n\n\t\tdprintk(\"svc: initialising pool %u for %s\\n\",\n\t\t\t\ti, serv->sv_name);\n\n\t\tpool->sp_id = i;\n\t\tINIT_LIST_HEAD(&pool->sp_sockets);\n\t\tINIT_LIST_HEAD(&pool->sp_all_threads);\n\t\tspin_lock_init(&pool->sp_lock);\n\n\t\tpercpu_counter_init(&pool->sp_messages_arrived, 0, GFP_KERNEL);\n\t\tpercpu_counter_init(&pool->sp_sockets_queued, 0, GFP_KERNEL);\n\t\tpercpu_counter_init(&pool->sp_threads_woken, 0, GFP_KERNEL);\n\t}\n\n\treturn serv;\n}\n\n \nstruct svc_serv *svc_create(struct svc_program *prog, unsigned int bufsize,\n\t\t\t    int (*threadfn)(void *data))\n{\n\treturn __svc_create(prog, bufsize, 1, threadfn);\n}\nEXPORT_SYMBOL_GPL(svc_create);\n\n \nstruct svc_serv *svc_create_pooled(struct svc_program *prog,\n\t\t\t\t   unsigned int bufsize,\n\t\t\t\t   int (*threadfn)(void *data))\n{\n\tstruct svc_serv *serv;\n\tunsigned int npools = svc_pool_map_get();\n\n\tserv = __svc_create(prog, bufsize, npools, threadfn);\n\tif (!serv)\n\t\tgoto out_err;\n\treturn serv;\nout_err:\n\tsvc_pool_map_put(npools);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(svc_create_pooled);\n\n \nvoid\nsvc_destroy(struct kref *ref)\n{\n\tstruct svc_serv *serv = container_of(ref, struct svc_serv, sv_refcnt);\n\tunsigned int i;\n\n\tdprintk(\"svc: svc_destroy(%s)\\n\", serv->sv_program->pg_name);\n\ttimer_shutdown_sync(&serv->sv_temptimer);\n\n\t \n\tBUG_ON(!list_empty(&serv->sv_permsocks));\n\tBUG_ON(!list_empty(&serv->sv_tempsocks));\n\n\tcache_clean_deferred(serv);\n\n\tsvc_pool_map_put(serv->sv_nrpools);\n\n\tfor (i = 0; i < serv->sv_nrpools; i++) {\n\t\tstruct svc_pool *pool = &serv->sv_pools[i];\n\n\t\tpercpu_counter_destroy(&pool->sp_messages_arrived);\n\t\tpercpu_counter_destroy(&pool->sp_sockets_queued);\n\t\tpercpu_counter_destroy(&pool->sp_threads_woken);\n\t}\n\tkfree(serv->sv_pools);\n\tkfree(serv);\n}\nEXPORT_SYMBOL_GPL(svc_destroy);\n\nstatic bool\nsvc_init_buffer(struct svc_rqst *rqstp, unsigned int size, int node)\n{\n\tunsigned long pages, ret;\n\n\t \n\tif (svc_is_backchannel(rqstp))\n\t\treturn true;\n\n\tpages = size / PAGE_SIZE + 1;  \n\tWARN_ON_ONCE(pages > RPCSVC_MAXPAGES);\n\tif (pages > RPCSVC_MAXPAGES)\n\t\tpages = RPCSVC_MAXPAGES;\n\n\tret = alloc_pages_bulk_array_node(GFP_KERNEL, node, pages,\n\t\t\t\t\t  rqstp->rq_pages);\n\treturn ret == pages;\n}\n\n \nstatic void\nsvc_release_buffer(struct svc_rqst *rqstp)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rqstp->rq_pages); i++)\n\t\tif (rqstp->rq_pages[i])\n\t\t\tput_page(rqstp->rq_pages[i]);\n}\n\nstruct svc_rqst *\nsvc_rqst_alloc(struct svc_serv *serv, struct svc_pool *pool, int node)\n{\n\tstruct svc_rqst\t*rqstp;\n\n\trqstp = kzalloc_node(sizeof(*rqstp), GFP_KERNEL, node);\n\tif (!rqstp)\n\t\treturn rqstp;\n\n\tfolio_batch_init(&rqstp->rq_fbatch);\n\n\t__set_bit(RQ_BUSY, &rqstp->rq_flags);\n\trqstp->rq_server = serv;\n\trqstp->rq_pool = pool;\n\n\trqstp->rq_scratch_page = alloc_pages_node(node, GFP_KERNEL, 0);\n\tif (!rqstp->rq_scratch_page)\n\t\tgoto out_enomem;\n\n\trqstp->rq_argp = kmalloc_node(serv->sv_xdrsize, GFP_KERNEL, node);\n\tif (!rqstp->rq_argp)\n\t\tgoto out_enomem;\n\n\trqstp->rq_resp = kmalloc_node(serv->sv_xdrsize, GFP_KERNEL, node);\n\tif (!rqstp->rq_resp)\n\t\tgoto out_enomem;\n\n\tif (!svc_init_buffer(rqstp, serv->sv_max_mesg, node))\n\t\tgoto out_enomem;\n\n\treturn rqstp;\nout_enomem:\n\tsvc_rqst_free(rqstp);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(svc_rqst_alloc);\n\nstatic struct svc_rqst *\nsvc_prepare_thread(struct svc_serv *serv, struct svc_pool *pool, int node)\n{\n\tstruct svc_rqst\t*rqstp;\n\n\trqstp = svc_rqst_alloc(serv, pool, node);\n\tif (!rqstp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsvc_get(serv);\n\tspin_lock_bh(&serv->sv_lock);\n\tserv->sv_nrthreads += 1;\n\tspin_unlock_bh(&serv->sv_lock);\n\n\tspin_lock_bh(&pool->sp_lock);\n\tpool->sp_nrthreads++;\n\tlist_add_rcu(&rqstp->rq_all, &pool->sp_all_threads);\n\tspin_unlock_bh(&pool->sp_lock);\n\treturn rqstp;\n}\n\n \nvoid svc_pool_wake_idle_thread(struct svc_pool *pool)\n{\n\tstruct svc_rqst\t*rqstp;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(rqstp, &pool->sp_all_threads, rq_all) {\n\t\tif (test_and_set_bit(RQ_BUSY, &rqstp->rq_flags))\n\t\t\tcontinue;\n\n\t\tWRITE_ONCE(rqstp->rq_qtime, ktime_get());\n\t\twake_up_process(rqstp->rq_task);\n\t\trcu_read_unlock();\n\t\tpercpu_counter_inc(&pool->sp_threads_woken);\n\t\ttrace_svc_wake_up(rqstp->rq_task->pid);\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\n\tset_bit(SP_CONGESTED, &pool->sp_flags);\n}\n\nstatic struct svc_pool *\nsvc_pool_next(struct svc_serv *serv, struct svc_pool *pool, unsigned int *state)\n{\n\treturn pool ? pool : &serv->sv_pools[(*state)++ % serv->sv_nrpools];\n}\n\nstatic struct task_struct *\nsvc_pool_victim(struct svc_serv *serv, struct svc_pool *pool, unsigned int *state)\n{\n\tunsigned int i;\n\tstruct task_struct *task = NULL;\n\n\tif (pool != NULL) {\n\t\tspin_lock_bh(&pool->sp_lock);\n\t} else {\n\t\tfor (i = 0; i < serv->sv_nrpools; i++) {\n\t\t\tpool = &serv->sv_pools[--(*state) % serv->sv_nrpools];\n\t\t\tspin_lock_bh(&pool->sp_lock);\n\t\t\tif (!list_empty(&pool->sp_all_threads))\n\t\t\t\tgoto found_pool;\n\t\t\tspin_unlock_bh(&pool->sp_lock);\n\t\t}\n\t\treturn NULL;\n\t}\n\nfound_pool:\n\tif (!list_empty(&pool->sp_all_threads)) {\n\t\tstruct svc_rqst *rqstp;\n\n\t\trqstp = list_entry(pool->sp_all_threads.next, struct svc_rqst, rq_all);\n\t\tset_bit(RQ_VICTIM, &rqstp->rq_flags);\n\t\tlist_del_rcu(&rqstp->rq_all);\n\t\ttask = rqstp->rq_task;\n\t}\n\tspin_unlock_bh(&pool->sp_lock);\n\treturn task;\n}\n\nstatic int\nsvc_start_kthreads(struct svc_serv *serv, struct svc_pool *pool, int nrservs)\n{\n\tstruct svc_rqst\t*rqstp;\n\tstruct task_struct *task;\n\tstruct svc_pool *chosen_pool;\n\tunsigned int state = serv->sv_nrthreads-1;\n\tint node;\n\n\tdo {\n\t\tnrservs--;\n\t\tchosen_pool = svc_pool_next(serv, pool, &state);\n\t\tnode = svc_pool_map_get_node(chosen_pool->sp_id);\n\n\t\trqstp = svc_prepare_thread(serv, chosen_pool, node);\n\t\tif (IS_ERR(rqstp))\n\t\t\treturn PTR_ERR(rqstp);\n\t\ttask = kthread_create_on_node(serv->sv_threadfn, rqstp,\n\t\t\t\t\t      node, \"%s\", serv->sv_name);\n\t\tif (IS_ERR(task)) {\n\t\t\tsvc_exit_thread(rqstp);\n\t\t\treturn PTR_ERR(task);\n\t\t}\n\n\t\trqstp->rq_task = task;\n\t\tif (serv->sv_nrpools > 1)\n\t\t\tsvc_pool_map_set_cpumask(task, chosen_pool->sp_id);\n\n\t\tsvc_sock_update_bufs(serv);\n\t\twake_up_process(task);\n\t} while (nrservs > 0);\n\n\treturn 0;\n}\n\nstatic int\nsvc_stop_kthreads(struct svc_serv *serv, struct svc_pool *pool, int nrservs)\n{\n\tstruct svc_rqst\t*rqstp;\n\tstruct task_struct *task;\n\tunsigned int state = serv->sv_nrthreads-1;\n\n\tdo {\n\t\ttask = svc_pool_victim(serv, pool, &state);\n\t\tif (task == NULL)\n\t\t\tbreak;\n\t\trqstp = kthread_data(task);\n\t\t \n\t\tif (kthread_stop(task) == -EINTR)\n\t\t\tsvc_exit_thread(rqstp);\n\t\tnrservs++;\n\t} while (nrservs < 0);\n\treturn 0;\n}\n\n \nint\nsvc_set_num_threads(struct svc_serv *serv, struct svc_pool *pool, int nrservs)\n{\n\tif (pool == NULL) {\n\t\tnrservs -= serv->sv_nrthreads;\n\t} else {\n\t\tspin_lock_bh(&pool->sp_lock);\n\t\tnrservs -= pool->sp_nrthreads;\n\t\tspin_unlock_bh(&pool->sp_lock);\n\t}\n\n\tif (nrservs > 0)\n\t\treturn svc_start_kthreads(serv, pool, nrservs);\n\tif (nrservs < 0)\n\t\treturn svc_stop_kthreads(serv, pool, nrservs);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(svc_set_num_threads);\n\n \nbool svc_rqst_replace_page(struct svc_rqst *rqstp, struct page *page)\n{\n\tstruct page **begin = rqstp->rq_pages;\n\tstruct page **end = &rqstp->rq_pages[RPCSVC_MAXPAGES];\n\n\tif (unlikely(rqstp->rq_next_page < begin || rqstp->rq_next_page > end)) {\n\t\ttrace_svc_replace_page_err(rqstp);\n\t\treturn false;\n\t}\n\n\tif (*rqstp->rq_next_page) {\n\t\tif (!folio_batch_add(&rqstp->rq_fbatch,\n\t\t\t\tpage_folio(*rqstp->rq_next_page)))\n\t\t\t__folio_batch_release(&rqstp->rq_fbatch);\n\t}\n\n\tget_page(page);\n\t*(rqstp->rq_next_page++) = page;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(svc_rqst_replace_page);\n\n \nvoid svc_rqst_release_pages(struct svc_rqst *rqstp)\n{\n\tint i, count = rqstp->rq_next_page - rqstp->rq_respages;\n\n\tif (count) {\n\t\trelease_pages(rqstp->rq_respages, count);\n\t\tfor (i = 0; i < count; i++)\n\t\t\trqstp->rq_respages[i] = NULL;\n\t}\n}\n\n \nvoid\nsvc_rqst_free(struct svc_rqst *rqstp)\n{\n\tfolio_batch_release(&rqstp->rq_fbatch);\n\tsvc_release_buffer(rqstp);\n\tif (rqstp->rq_scratch_page)\n\t\tput_page(rqstp->rq_scratch_page);\n\tkfree(rqstp->rq_resp);\n\tkfree(rqstp->rq_argp);\n\tkfree(rqstp->rq_auth_data);\n\tkfree_rcu(rqstp, rq_rcu_head);\n}\nEXPORT_SYMBOL_GPL(svc_rqst_free);\n\nvoid\nsvc_exit_thread(struct svc_rqst *rqstp)\n{\n\tstruct svc_serv\t*serv = rqstp->rq_server;\n\tstruct svc_pool\t*pool = rqstp->rq_pool;\n\n\tspin_lock_bh(&pool->sp_lock);\n\tpool->sp_nrthreads--;\n\tif (!test_and_set_bit(RQ_VICTIM, &rqstp->rq_flags))\n\t\tlist_del_rcu(&rqstp->rq_all);\n\tspin_unlock_bh(&pool->sp_lock);\n\n\tspin_lock_bh(&serv->sv_lock);\n\tserv->sv_nrthreads -= 1;\n\tspin_unlock_bh(&serv->sv_lock);\n\tsvc_sock_update_bufs(serv);\n\n\tsvc_rqst_free(rqstp);\n\n\tsvc_put(serv);\n}\nEXPORT_SYMBOL_GPL(svc_exit_thread);\n\n \nstatic int __svc_rpcb_register4(struct net *net, const u32 program,\n\t\t\t\tconst u32 version,\n\t\t\t\tconst unsigned short protocol,\n\t\t\t\tconst unsigned short port)\n{\n\tconst struct sockaddr_in sin = {\n\t\t.sin_family\t\t= AF_INET,\n\t\t.sin_addr.s_addr\t= htonl(INADDR_ANY),\n\t\t.sin_port\t\t= htons(port),\n\t};\n\tconst char *netid;\n\tint error;\n\n\tswitch (protocol) {\n\tcase IPPROTO_UDP:\n\t\tnetid = RPCBIND_NETID_UDP;\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tnetid = RPCBIND_NETID_TCP;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\terror = rpcb_v4_register(net, program, version,\n\t\t\t\t\t(const struct sockaddr *)&sin, netid);\n\n\t \n\tif (error == -EPROTONOSUPPORT)\n\t\terror = rpcb_register(net, program, version, protocol, port);\n\n\treturn error;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nstatic int __svc_rpcb_register6(struct net *net, const u32 program,\n\t\t\t\tconst u32 version,\n\t\t\t\tconst unsigned short protocol,\n\t\t\t\tconst unsigned short port)\n{\n\tconst struct sockaddr_in6 sin6 = {\n\t\t.sin6_family\t\t= AF_INET6,\n\t\t.sin6_addr\t\t= IN6ADDR_ANY_INIT,\n\t\t.sin6_port\t\t= htons(port),\n\t};\n\tconst char *netid;\n\tint error;\n\n\tswitch (protocol) {\n\tcase IPPROTO_UDP:\n\t\tnetid = RPCBIND_NETID_UDP6;\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tnetid = RPCBIND_NETID_TCP6;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\terror = rpcb_v4_register(net, program, version,\n\t\t\t\t\t(const struct sockaddr *)&sin6, netid);\n\n\t \n\tif (error == -EPROTONOSUPPORT)\n\t\terror = -EAFNOSUPPORT;\n\n\treturn error;\n}\n#endif\t \n\n \nstatic int __svc_register(struct net *net, const char *progname,\n\t\t\t  const u32 program, const u32 version,\n\t\t\t  const int family,\n\t\t\t  const unsigned short protocol,\n\t\t\t  const unsigned short port)\n{\n\tint error = -EAFNOSUPPORT;\n\n\tswitch (family) {\n\tcase PF_INET:\n\t\terror = __svc_rpcb_register4(net, program, version,\n\t\t\t\t\t\tprotocol, port);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase PF_INET6:\n\t\terror = __svc_rpcb_register6(net, program, version,\n\t\t\t\t\t\tprotocol, port);\n#endif\n\t}\n\n\ttrace_svc_register(progname, version, family, protocol, port, error);\n\treturn error;\n}\n\nint svc_rpcbind_set_version(struct net *net,\n\t\t\t    const struct svc_program *progp,\n\t\t\t    u32 version, int family,\n\t\t\t    unsigned short proto,\n\t\t\t    unsigned short port)\n{\n\treturn __svc_register(net, progp->pg_name, progp->pg_prog,\n\t\t\t\tversion, family, proto, port);\n\n}\nEXPORT_SYMBOL_GPL(svc_rpcbind_set_version);\n\nint svc_generic_rpcbind_set(struct net *net,\n\t\t\t    const struct svc_program *progp,\n\t\t\t    u32 version, int family,\n\t\t\t    unsigned short proto,\n\t\t\t    unsigned short port)\n{\n\tconst struct svc_version *vers = progp->pg_vers[version];\n\tint error;\n\n\tif (vers == NULL)\n\t\treturn 0;\n\n\tif (vers->vs_hidden) {\n\t\ttrace_svc_noregister(progp->pg_name, version, proto,\n\t\t\t\t     port, family, 0);\n\t\treturn 0;\n\t}\n\n\t \n\tif (vers->vs_need_cong_ctrl && proto == IPPROTO_UDP)\n\t\treturn 0;\n\n\terror = svc_rpcbind_set_version(net, progp, version,\n\t\t\t\t\tfamily, proto, port);\n\n\treturn (vers->vs_rpcb_optnl) ? 0 : error;\n}\nEXPORT_SYMBOL_GPL(svc_generic_rpcbind_set);\n\n \nint svc_register(const struct svc_serv *serv, struct net *net,\n\t\t const int family, const unsigned short proto,\n\t\t const unsigned short port)\n{\n\tstruct svc_program\t*progp;\n\tunsigned int\t\ti;\n\tint\t\t\terror = 0;\n\n\tWARN_ON_ONCE(proto == 0 && port == 0);\n\tif (proto == 0 && port == 0)\n\t\treturn -EINVAL;\n\n\tfor (progp = serv->sv_program; progp; progp = progp->pg_next) {\n\t\tfor (i = 0; i < progp->pg_nvers; i++) {\n\n\t\t\terror = progp->pg_rpcbind_set(net, progp, i,\n\t\t\t\t\tfamily, proto, port);\n\t\t\tif (error < 0) {\n\t\t\t\tprintk(KERN_WARNING \"svc: failed to register \"\n\t\t\t\t\t\"%sv%u RPC service (errno %d).\\n\",\n\t\t\t\t\tprogp->pg_name, i, -error);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn error;\n}\n\n \nstatic void __svc_unregister(struct net *net, const u32 program, const u32 version,\n\t\t\t     const char *progname)\n{\n\tint error;\n\n\terror = rpcb_v4_register(net, program, version, NULL, \"\");\n\n\t \n\tif (error == -EPROTONOSUPPORT)\n\t\terror = rpcb_register(net, program, version, 0, 0);\n\n\ttrace_svc_unregister(progname, version, error);\n}\n\n \nstatic void svc_unregister(const struct svc_serv *serv, struct net *net)\n{\n\tstruct sighand_struct *sighand;\n\tstruct svc_program *progp;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tclear_thread_flag(TIF_SIGPENDING);\n\n\tfor (progp = serv->sv_program; progp; progp = progp->pg_next) {\n\t\tfor (i = 0; i < progp->pg_nvers; i++) {\n\t\t\tif (progp->pg_vers[i] == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (progp->pg_vers[i]->vs_hidden)\n\t\t\t\tcontinue;\n\t\t\t__svc_unregister(net, progp->pg_prog, i, progp->pg_name);\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tsighand = rcu_dereference(current->sighand);\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\trecalc_sigpending();\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n\trcu_read_unlock();\n}\n\n \n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\nstatic __printf(2, 3)\nvoid svc_printk(struct svc_rqst *rqstp, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tchar \tbuf[RPC_MAX_ADDRBUFLEN];\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tdprintk(\"svc: %s: %pV\", svc_print_addr(rqstp, buf, sizeof(buf)), &vaf);\n\n\tva_end(args);\n}\n#else\nstatic __printf(2,3) void svc_printk(struct svc_rqst *rqstp, const char *fmt, ...) {}\n#endif\n\n__be32\nsvc_generic_init_request(struct svc_rqst *rqstp,\n\t\tconst struct svc_program *progp,\n\t\tstruct svc_process_info *ret)\n{\n\tconst struct svc_version *versp = NULL;\t \n\tconst struct svc_procedure *procp = NULL;\n\n\tif (rqstp->rq_vers >= progp->pg_nvers )\n\t\tgoto err_bad_vers;\n\tversp = progp->pg_vers[rqstp->rq_vers];\n\tif (!versp)\n\t\tgoto err_bad_vers;\n\n\t \n\tif (versp->vs_need_cong_ctrl && rqstp->rq_xprt &&\n\t    !test_bit(XPT_CONG_CTRL, &rqstp->rq_xprt->xpt_flags))\n\t\tgoto err_bad_vers;\n\n\tif (rqstp->rq_proc >= versp->vs_nproc)\n\t\tgoto err_bad_proc;\n\trqstp->rq_procinfo = procp = &versp->vs_proc[rqstp->rq_proc];\n\tif (!procp)\n\t\tgoto err_bad_proc;\n\n\t \n\tmemset(rqstp->rq_argp, 0, procp->pc_argzero);\n\tmemset(rqstp->rq_resp, 0, procp->pc_ressize);\n\n\t \n\tthis_cpu_inc(versp->vs_count[rqstp->rq_proc]);\n\n\tret->dispatch = versp->vs_dispatch;\n\treturn rpc_success;\nerr_bad_vers:\n\tret->mismatch.lovers = progp->pg_lovers;\n\tret->mismatch.hivers = progp->pg_hivers;\n\treturn rpc_prog_mismatch;\nerr_bad_proc:\n\treturn rpc_proc_unavail;\n}\nEXPORT_SYMBOL_GPL(svc_generic_init_request);\n\n \nstatic int\nsvc_process_common(struct svc_rqst *rqstp)\n{\n\tstruct xdr_stream\t*xdr = &rqstp->rq_res_stream;\n\tstruct svc_program\t*progp;\n\tconst struct svc_procedure *procp = NULL;\n\tstruct svc_serv\t\t*serv = rqstp->rq_server;\n\tstruct svc_process_info process;\n\tenum svc_auth_status\tauth_res;\n\tunsigned int\t\taoffset;\n\tint\t\t\trc;\n\t__be32\t\t\t*p;\n\n\t \n\tset_bit(RQ_SPLICE_OK, &rqstp->rq_flags);\n\t \n\tset_bit(RQ_USEDEFERRAL, &rqstp->rq_flags);\n\tclear_bit(RQ_DROPME, &rqstp->rq_flags);\n\n\t \n\tsvcxdr_init_encode(rqstp);\n\txdr_stream_encode_be32(xdr, rqstp->rq_xid);\n\txdr_stream_encode_be32(xdr, rpc_reply);\n\n\tp = xdr_inline_decode(&rqstp->rq_arg_stream, XDR_UNIT * 4);\n\tif (unlikely(!p))\n\t\tgoto err_short_len;\n\tif (*p++ != cpu_to_be32(RPC_VERSION))\n\t\tgoto err_bad_rpc;\n\n\txdr_stream_encode_be32(xdr, rpc_msg_accepted);\n\n\trqstp->rq_prog = be32_to_cpup(p++);\n\trqstp->rq_vers = be32_to_cpup(p++);\n\trqstp->rq_proc = be32_to_cpup(p);\n\n\tfor (progp = serv->sv_program; progp; progp = progp->pg_next)\n\t\tif (rqstp->rq_prog == progp->pg_prog)\n\t\t\tbreak;\n\n\t \n\tauth_res = svc_authenticate(rqstp);\n\t \n\tif (auth_res == SVC_OK && progp)\n\t\tauth_res = progp->pg_authenticate(rqstp);\n\ttrace_svc_authenticate(rqstp, auth_res);\n\tswitch (auth_res) {\n\tcase SVC_OK:\n\t\tbreak;\n\tcase SVC_GARBAGE:\n\t\tgoto err_garbage_args;\n\tcase SVC_SYSERR:\n\t\tgoto err_system_err;\n\tcase SVC_DENIED:\n\t\tgoto err_bad_auth;\n\tcase SVC_CLOSE:\n\t\tgoto close;\n\tcase SVC_DROP:\n\t\tgoto dropit;\n\tcase SVC_COMPLETE:\n\t\tgoto sendit;\n\tdefault:\n\t\tpr_warn_once(\"Unexpected svc_auth_status (%d)\\n\", auth_res);\n\t\tgoto err_system_err;\n\t}\n\n\tif (progp == NULL)\n\t\tgoto err_bad_prog;\n\n\tswitch (progp->pg_init_request(rqstp, progp, &process)) {\n\tcase rpc_success:\n\t\tbreak;\n\tcase rpc_prog_unavail:\n\t\tgoto err_bad_prog;\n\tcase rpc_prog_mismatch:\n\t\tgoto err_bad_vers;\n\tcase rpc_proc_unavail:\n\t\tgoto err_bad_proc;\n\t}\n\n\tprocp = rqstp->rq_procinfo;\n\t \n\tif (!procp || !procp->pc_func)\n\t\tgoto err_bad_proc;\n\n\t \n\tserv->sv_stats->rpccnt++;\n\ttrace_svc_process(rqstp, progp->pg_name);\n\n\taoffset = xdr_stream_pos(xdr);\n\n\t \n\tif (procp->pc_xdrressize)\n\t\tsvc_reserve_auth(rqstp, procp->pc_xdrressize<<2);\n\n\t \n\trc = process.dispatch(rqstp);\n\tif (procp->pc_release)\n\t\tprocp->pc_release(rqstp);\n\txdr_finish_decode(xdr);\n\n\tif (!rc)\n\t\tgoto dropit;\n\tif (rqstp->rq_auth_stat != rpc_auth_ok)\n\t\tgoto err_bad_auth;\n\n\tif (*rqstp->rq_accept_statp != rpc_success)\n\t\txdr_truncate_encode(xdr, aoffset);\n\n\tif (procp->pc_encode == NULL)\n\t\tgoto dropit;\n\n sendit:\n\tif (svc_authorise(rqstp))\n\t\tgoto close_xprt;\n\treturn 1;\t\t \n\n dropit:\n\tsvc_authorise(rqstp);\t \n\tdprintk(\"svc: svc_process dropit\\n\");\n\treturn 0;\n\n close:\n\tsvc_authorise(rqstp);\nclose_xprt:\n\tif (rqstp->rq_xprt && test_bit(XPT_TEMP, &rqstp->rq_xprt->xpt_flags))\n\t\tsvc_xprt_close(rqstp->rq_xprt);\n\tdprintk(\"svc: svc_process close\\n\");\n\treturn 0;\n\nerr_short_len:\n\tsvc_printk(rqstp, \"short len %u, dropping request\\n\",\n\t\t   rqstp->rq_arg.len);\n\tgoto close_xprt;\n\nerr_bad_rpc:\n\tserv->sv_stats->rpcbadfmt++;\n\txdr_stream_encode_u32(xdr, RPC_MSG_DENIED);\n\txdr_stream_encode_u32(xdr, RPC_MISMATCH);\n\t \n\txdr_stream_encode_u32(xdr, RPC_VERSION);\n\txdr_stream_encode_u32(xdr, RPC_VERSION);\n\treturn 1;\t \n\nerr_bad_auth:\n\tdprintk(\"svc: authentication failed (%d)\\n\",\n\t\tbe32_to_cpu(rqstp->rq_auth_stat));\n\tserv->sv_stats->rpcbadauth++;\n\t \n\txdr_truncate_encode(xdr, XDR_UNIT * 2);\n\txdr_stream_encode_u32(xdr, RPC_MSG_DENIED);\n\txdr_stream_encode_u32(xdr, RPC_AUTH_ERROR);\n\txdr_stream_encode_be32(xdr, rqstp->rq_auth_stat);\n\tgoto sendit;\n\nerr_bad_prog:\n\tdprintk(\"svc: unknown program %d\\n\", rqstp->rq_prog);\n\tserv->sv_stats->rpcbadfmt++;\n\t*rqstp->rq_accept_statp = rpc_prog_unavail;\n\tgoto sendit;\n\nerr_bad_vers:\n\tsvc_printk(rqstp, \"unknown version (%d for prog %d, %s)\\n\",\n\t\t       rqstp->rq_vers, rqstp->rq_prog, progp->pg_name);\n\n\tserv->sv_stats->rpcbadfmt++;\n\t*rqstp->rq_accept_statp = rpc_prog_mismatch;\n\n\t \n\txdr_stream_encode_u32(xdr, process.mismatch.lovers);\n\txdr_stream_encode_u32(xdr, process.mismatch.hivers);\n\tgoto sendit;\n\nerr_bad_proc:\n\tsvc_printk(rqstp, \"unknown procedure (%d)\\n\", rqstp->rq_proc);\n\n\tserv->sv_stats->rpcbadfmt++;\n\t*rqstp->rq_accept_statp = rpc_proc_unavail;\n\tgoto sendit;\n\nerr_garbage_args:\n\tsvc_printk(rqstp, \"failed to decode RPC header\\n\");\n\n\tserv->sv_stats->rpcbadfmt++;\n\t*rqstp->rq_accept_statp = rpc_garbage_args;\n\tgoto sendit;\n\nerr_system_err:\n\tserv->sv_stats->rpcbadfmt++;\n\t*rqstp->rq_accept_statp = rpc_system_err;\n\tgoto sendit;\n}\n\n \nvoid svc_process(struct svc_rqst *rqstp)\n{\n\tstruct kvec\t\t*resv = &rqstp->rq_res.head[0];\n\t__be32 *p;\n\n#if IS_ENABLED(CONFIG_FAIL_SUNRPC)\n\tif (!fail_sunrpc.ignore_server_disconnect &&\n\t    should_fail(&fail_sunrpc.attr, 1))\n\t\tsvc_xprt_deferred_close(rqstp->rq_xprt);\n#endif\n\n\t \n\trqstp->rq_next_page = &rqstp->rq_respages[1];\n\tresv->iov_base = page_address(rqstp->rq_respages[0]);\n\tresv->iov_len = 0;\n\trqstp->rq_res.pages = rqstp->rq_next_page;\n\trqstp->rq_res.len = 0;\n\trqstp->rq_res.page_base = 0;\n\trqstp->rq_res.page_len = 0;\n\trqstp->rq_res.buflen = PAGE_SIZE;\n\trqstp->rq_res.tail[0].iov_base = NULL;\n\trqstp->rq_res.tail[0].iov_len = 0;\n\n\tsvcxdr_init_decode(rqstp);\n\tp = xdr_inline_decode(&rqstp->rq_arg_stream, XDR_UNIT * 2);\n\tif (unlikely(!p))\n\t\tgoto out_drop;\n\trqstp->rq_xid = *p++;\n\tif (unlikely(*p != rpc_call))\n\t\tgoto out_baddir;\n\n\tif (!svc_process_common(rqstp))\n\t\tgoto out_drop;\n\tsvc_send(rqstp);\n\treturn;\n\nout_baddir:\n\tsvc_printk(rqstp, \"bad direction 0x%08x, dropping request\\n\",\n\t\t   be32_to_cpu(*p));\n\trqstp->rq_server->sv_stats->rpcbadfmt++;\nout_drop:\n\tsvc_drop(rqstp);\n}\n\n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\n \nint\nbc_svc_process(struct svc_serv *serv, struct rpc_rqst *req,\n\t       struct svc_rqst *rqstp)\n{\n\tstruct rpc_task *task;\n\tint proc_error;\n\tint error;\n\n\tdprintk(\"svc: %s(%p)\\n\", __func__, req);\n\n\t \n\trqstp->rq_xid = req->rq_xid;\n\trqstp->rq_prot = req->rq_xprt->prot;\n\trqstp->rq_server = serv;\n\trqstp->rq_bc_net = req->rq_xprt->xprt_net;\n\n\trqstp->rq_addrlen = sizeof(req->rq_xprt->addr);\n\tmemcpy(&rqstp->rq_addr, &req->rq_xprt->addr, rqstp->rq_addrlen);\n\tmemcpy(&rqstp->rq_arg, &req->rq_rcv_buf, sizeof(rqstp->rq_arg));\n\tmemcpy(&rqstp->rq_res, &req->rq_snd_buf, sizeof(rqstp->rq_res));\n\n\t \n\trqstp->rq_arg.len = req->rq_private_buf.len;\n\tif (rqstp->rq_arg.len <= rqstp->rq_arg.head[0].iov_len) {\n\t\trqstp->rq_arg.head[0].iov_len = rqstp->rq_arg.len;\n\t\trqstp->rq_arg.page_len = 0;\n\t} else if (rqstp->rq_arg.len <= rqstp->rq_arg.head[0].iov_len +\n\t\t\trqstp->rq_arg.page_len)\n\t\trqstp->rq_arg.page_len = rqstp->rq_arg.len -\n\t\t\trqstp->rq_arg.head[0].iov_len;\n\telse\n\t\trqstp->rq_arg.len = rqstp->rq_arg.head[0].iov_len +\n\t\t\trqstp->rq_arg.page_len;\n\n\t \n\trqstp->rq_res.head[0].iov_len = 0;\n\n\t \n\tsvcxdr_init_decode(rqstp);\n\tif (!xdr_inline_decode(&rqstp->rq_arg_stream, XDR_UNIT * 2)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tproc_error = svc_process_common(rqstp);\n\n\tatomic_dec(&req->rq_xprt->bc_slot_count);\n\tif (!proc_error) {\n\t\t \n\t\txprt_free_bc_request(req);\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tmemcpy(&req->rq_snd_buf, &rqstp->rq_res, sizeof(req->rq_snd_buf));\n\ttask = rpc_run_bc_task(req);\n\tif (IS_ERR(task)) {\n\t\terror = PTR_ERR(task);\n\t\tgoto out;\n\t}\n\n\tWARN_ON_ONCE(atomic_read(&task->tk_count) != 1);\n\terror = task->tk_status;\n\trpc_put_task(task);\n\nout:\n\tdprintk(\"svc: %s(), error=%d\\n\", __func__, error);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(bc_svc_process);\n#endif  \n\n \nu32 svc_max_payload(const struct svc_rqst *rqstp)\n{\n\tu32 max = rqstp->rq_xprt->xpt_class->xcl_max_payload;\n\n\tif (rqstp->rq_server->sv_max_payload < max)\n\t\tmax = rqstp->rq_server->sv_max_payload;\n\treturn max;\n}\nEXPORT_SYMBOL_GPL(svc_max_payload);\n\n \nconst char *svc_proc_name(const struct svc_rqst *rqstp)\n{\n\tif (rqstp && rqstp->rq_procinfo)\n\t\treturn rqstp->rq_procinfo->pc_name;\n\treturn \"unknown\";\n}\n\n\n \nint svc_encode_result_payload(struct svc_rqst *rqstp, unsigned int offset,\n\t\t\t      unsigned int length)\n{\n\treturn rqstp->rq_xprt->xpt_ops->xpo_result_payload(rqstp, offset,\n\t\t\t\t\t\t\t   length);\n}\nEXPORT_SYMBOL_GPL(svc_encode_result_payload);\n\n \nunsigned int svc_fill_write_vector(struct svc_rqst *rqstp,\n\t\t\t\t   struct xdr_buf *payload)\n{\n\tstruct page **pages = payload->pages;\n\tstruct kvec *first = payload->head;\n\tstruct kvec *vec = rqstp->rq_vec;\n\tsize_t total = payload->len;\n\tunsigned int i;\n\n\t \n\ti = 0;\n\tif (first->iov_len) {\n\t\tvec[i].iov_base = first->iov_base;\n\t\tvec[i].iov_len = min_t(size_t, total, first->iov_len);\n\t\ttotal -= vec[i].iov_len;\n\t\t++i;\n\t}\n\n\twhile (total) {\n\t\tvec[i].iov_base = page_address(*pages);\n\t\tvec[i].iov_len = min_t(size_t, total, PAGE_SIZE);\n\t\ttotal -= vec[i].iov_len;\n\t\t++i;\n\t\t++pages;\n\t}\n\n\tWARN_ON_ONCE(i > ARRAY_SIZE(rqstp->rq_vec));\n\treturn i;\n}\nEXPORT_SYMBOL_GPL(svc_fill_write_vector);\n\n \nchar *svc_fill_symlink_pathname(struct svc_rqst *rqstp, struct kvec *first,\n\t\t\t\tvoid *p, size_t total)\n{\n\tsize_t len, remaining;\n\tchar *result, *dst;\n\n\tresult = kmalloc(total + 1, GFP_KERNEL);\n\tif (!result)\n\t\treturn ERR_PTR(-ESERVERFAULT);\n\n\tdst = result;\n\tremaining = total;\n\n\tlen = min_t(size_t, total, first->iov_len);\n\tif (len) {\n\t\tmemcpy(dst, first->iov_base, len);\n\t\tdst += len;\n\t\tremaining -= len;\n\t}\n\n\tif (remaining) {\n\t\tlen = min_t(size_t, remaining, PAGE_SIZE);\n\t\tmemcpy(dst, p, len);\n\t\tdst += len;\n\t}\n\n\t*dst = '\\0';\n\n\t \n\tif (strlen(result) != total) {\n\t\tkfree(result);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(svc_fill_symlink_pathname);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}