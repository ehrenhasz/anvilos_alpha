{
  "module_name": "sysctl.c",
  "hash_id": "7c2e57af276d8d339155d40257808ce0fa28e10b85df2aefc7cf87343dd241dd",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/sysctl.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/linkage.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n\n#include <linux/uaccess.h>\n#include <linux/sunrpc/types.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/svc_xprt.h>\n\n#include \"netns.h\"\n\n \nunsigned int\trpc_debug;\nEXPORT_SYMBOL_GPL(rpc_debug);\n\nunsigned int\tnfs_debug;\nEXPORT_SYMBOL_GPL(nfs_debug);\n\nunsigned int\tnfsd_debug;\nEXPORT_SYMBOL_GPL(nfsd_debug);\n\nunsigned int\tnlm_debug;\nEXPORT_SYMBOL_GPL(nlm_debug);\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n\nstatic int proc_do_xprt(struct ctl_table *table, int write,\n\t\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tchar tmpbuf[256];\n\tssize_t len;\n\n\tif (write || *ppos) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\tlen = svc_print_xprts(tmpbuf, sizeof(tmpbuf));\n\tlen = memory_read_from_buffer(buffer, *lenp, ppos, tmpbuf, len);\n\n\tif (len < 0) {\n\t\t*lenp = 0;\n\t\treturn -EINVAL;\n\t}\n\t*lenp = len;\n\treturn 0;\n}\n\nstatic int\nproc_dodebug(struct ctl_table *table, int write, void *buffer, size_t *lenp,\n\t     loff_t *ppos)\n{\n\tchar\t\ttmpbuf[20], *s = NULL;\n\tchar *p;\n\tunsigned int\tvalue;\n\tsize_t\t\tleft, len;\n\n\tif ((*ppos && !write) || !*lenp) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tleft = *lenp;\n\n\tif (write) {\n\t\tp = buffer;\n\t\twhile (left && isspace(*p)) {\n\t\t\tleft--;\n\t\t\tp++;\n\t\t}\n\t\tif (!left)\n\t\t\tgoto done;\n\n\t\tif (left > sizeof(tmpbuf) - 1)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(tmpbuf, p, left);\n\t\ttmpbuf[left] = '\\0';\n\n\t\tvalue = simple_strtol(tmpbuf, &s, 0);\n\t\tif (s) {\n\t\t\tleft -= (s - tmpbuf);\n\t\t\tif (left && !isspace(*s))\n\t\t\t\treturn -EINVAL;\n\t\t\twhile (left && isspace(*s)) {\n\t\t\t\tleft--;\n\t\t\t\ts++;\n\t\t\t}\n\t\t} else\n\t\t\tleft = 0;\n\t\t*(unsigned int *) table->data = value;\n\t\t \n\t\tif (strcmp(table->procname, \"rpc_debug\") == 0)\n\t\t\trpc_show_tasks(&init_net);\n\t} else {\n\t\tlen = sprintf(tmpbuf, \"0x%04x\", *(unsigned int *) table->data);\n\t\tif (len > left)\n\t\t\tlen = left;\n\t\tmemcpy(buffer, tmpbuf, len);\n\t\tif ((left -= len) > 0) {\n\t\t\t*((char *)buffer + len) = '\\n';\n\t\t\tleft--;\n\t\t}\n\t}\n\ndone:\n\t*lenp -= left;\n\t*ppos += *lenp;\n\treturn 0;\n}\n\nstatic struct ctl_table_header *sunrpc_table_header;\n\nstatic struct ctl_table debug_table[] = {\n\t{\n\t\t.procname\t= \"rpc_debug\",\n\t\t.data\t\t= &rpc_debug,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dodebug\n\t},\n\t{\n\t\t.procname\t= \"nfs_debug\",\n\t\t.data\t\t= &nfs_debug,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dodebug\n\t},\n\t{\n\t\t.procname\t= \"nfsd_debug\",\n\t\t.data\t\t= &nfsd_debug,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dodebug\n\t},\n\t{\n\t\t.procname\t= \"nlm_debug\",\n\t\t.data\t\t= &nlm_debug,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dodebug\n\t},\n\t{\n\t\t.procname\t= \"transports\",\n\t\t.maxlen\t\t= 256,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_xprt,\n\t},\n\t{ }\n};\n\nvoid\nrpc_register_sysctl(void)\n{\n\tif (!sunrpc_table_header)\n\t\tsunrpc_table_header = register_sysctl(\"sunrpc\", debug_table);\n}\n\nvoid\nrpc_unregister_sysctl(void)\n{\n\tif (sunrpc_table_header) {\n\t\tunregister_sysctl_table(sunrpc_table_header);\n\t\tsunrpc_table_header = NULL;\n\t}\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}