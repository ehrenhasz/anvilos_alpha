{
  "module_name": "auth.c",
  "hash_id": "f959a4a36e1f2f71ae2d9d2da3945ab8ba6037db07e3ccbf483ba4fe4bcbe1c0",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/cred.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/hash.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/spinlock.h>\n\n#include <trace/events/sunrpc.h>\n\n#define RPC_CREDCACHE_DEFAULT_HASHBITS\t(4)\nstruct rpc_cred_cache {\n\tstruct hlist_head\t*hashtable;\n\tunsigned int\t\thashbits;\n\tspinlock_t\t\tlock;\n};\n\nstatic unsigned int auth_hashbits = RPC_CREDCACHE_DEFAULT_HASHBITS;\n\nstatic const struct rpc_authops __rcu *auth_flavors[RPC_AUTH_MAXFLAVOR] = {\n\t[RPC_AUTH_NULL] = (const struct rpc_authops __force __rcu *)&authnull_ops,\n\t[RPC_AUTH_UNIX] = (const struct rpc_authops __force __rcu *)&authunix_ops,\n\t[RPC_AUTH_TLS]  = (const struct rpc_authops __force __rcu *)&authtls_ops,\n};\n\nstatic LIST_HEAD(cred_unused);\nstatic unsigned long number_cred_unused;\n\nstatic struct cred machine_cred = {\n\t.usage = ATOMIC_INIT(1),\n};\n\n \nconst struct cred *rpc_machine_cred(void)\n{\n\treturn &machine_cred;\n}\nEXPORT_SYMBOL_GPL(rpc_machine_cred);\n\n#define MAX_HASHTABLE_BITS (14)\nstatic int param_set_hashtbl_sz(const char *val, const struct kernel_param *kp)\n{\n\tunsigned long num;\n\tunsigned int nbits;\n\tint ret;\n\n\tif (!val)\n\t\tgoto out_inval;\n\tret = kstrtoul(val, 0, &num);\n\tif (ret)\n\t\tgoto out_inval;\n\tnbits = fls(num - 1);\n\tif (nbits > MAX_HASHTABLE_BITS || nbits < 2)\n\t\tgoto out_inval;\n\t*(unsigned int *)kp->arg = nbits;\n\treturn 0;\nout_inval:\n\treturn -EINVAL;\n}\n\nstatic int param_get_hashtbl_sz(char *buffer, const struct kernel_param *kp)\n{\n\tunsigned int nbits;\n\n\tnbits = *(unsigned int *)kp->arg;\n\treturn sprintf(buffer, \"%u\\n\", 1U << nbits);\n}\n\n#define param_check_hashtbl_sz(name, p) __param_check(name, p, unsigned int);\n\nstatic const struct kernel_param_ops param_ops_hashtbl_sz = {\n\t.set = param_set_hashtbl_sz,\n\t.get = param_get_hashtbl_sz,\n};\n\nmodule_param_named(auth_hashtable_size, auth_hashbits, hashtbl_sz, 0644);\nMODULE_PARM_DESC(auth_hashtable_size, \"RPC credential cache hashtable size\");\n\nstatic unsigned long auth_max_cred_cachesize = ULONG_MAX;\nmodule_param(auth_max_cred_cachesize, ulong, 0644);\nMODULE_PARM_DESC(auth_max_cred_cachesize, \"RPC credential maximum total cache size\");\n\nstatic u32\npseudoflavor_to_flavor(u32 flavor) {\n\tif (flavor > RPC_AUTH_MAXFLAVOR)\n\t\treturn RPC_AUTH_GSS;\n\treturn flavor;\n}\n\nint\nrpcauth_register(const struct rpc_authops *ops)\n{\n\tconst struct rpc_authops *old;\n\trpc_authflavor_t flavor;\n\n\tif ((flavor = ops->au_flavor) >= RPC_AUTH_MAXFLAVOR)\n\t\treturn -EINVAL;\n\told = cmpxchg((const struct rpc_authops ** __force)&auth_flavors[flavor], NULL, ops);\n\tif (old == NULL || old == ops)\n\t\treturn 0;\n\treturn -EPERM;\n}\nEXPORT_SYMBOL_GPL(rpcauth_register);\n\nint\nrpcauth_unregister(const struct rpc_authops *ops)\n{\n\tconst struct rpc_authops *old;\n\trpc_authflavor_t flavor;\n\n\tif ((flavor = ops->au_flavor) >= RPC_AUTH_MAXFLAVOR)\n\t\treturn -EINVAL;\n\n\told = cmpxchg((const struct rpc_authops ** __force)&auth_flavors[flavor], ops, NULL);\n\tif (old == ops || old == NULL)\n\t\treturn 0;\n\treturn -EPERM;\n}\nEXPORT_SYMBOL_GPL(rpcauth_unregister);\n\nstatic const struct rpc_authops *\nrpcauth_get_authops(rpc_authflavor_t flavor)\n{\n\tconst struct rpc_authops *ops;\n\n\tif (flavor >= RPC_AUTH_MAXFLAVOR)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tops = rcu_dereference(auth_flavors[flavor]);\n\tif (ops == NULL) {\n\t\trcu_read_unlock();\n\t\trequest_module(\"rpc-auth-%u\", flavor);\n\t\trcu_read_lock();\n\t\tops = rcu_dereference(auth_flavors[flavor]);\n\t\tif (ops == NULL)\n\t\t\tgoto out;\n\t}\n\tif (!try_module_get(ops->owner))\n\t\tops = NULL;\nout:\n\trcu_read_unlock();\n\treturn ops;\n}\n\nstatic void\nrpcauth_put_authops(const struct rpc_authops *ops)\n{\n\tmodule_put(ops->owner);\n}\n\n \nrpc_authflavor_t\nrpcauth_get_pseudoflavor(rpc_authflavor_t flavor, struct rpcsec_gss_info *info)\n{\n\tconst struct rpc_authops *ops = rpcauth_get_authops(flavor);\n\trpc_authflavor_t pseudoflavor;\n\n\tif (!ops)\n\t\treturn RPC_AUTH_MAXFLAVOR;\n\tpseudoflavor = flavor;\n\tif (ops->info2flavor != NULL)\n\t\tpseudoflavor = ops->info2flavor(info);\n\n\trpcauth_put_authops(ops);\n\treturn pseudoflavor;\n}\nEXPORT_SYMBOL_GPL(rpcauth_get_pseudoflavor);\n\n \nint\nrpcauth_get_gssinfo(rpc_authflavor_t pseudoflavor, struct rpcsec_gss_info *info)\n{\n\trpc_authflavor_t flavor = pseudoflavor_to_flavor(pseudoflavor);\n\tconst struct rpc_authops *ops;\n\tint result;\n\n\tops = rpcauth_get_authops(flavor);\n\tif (ops == NULL)\n\t\treturn -ENOENT;\n\n\tresult = -ENOENT;\n\tif (ops->flavor2info != NULL)\n\t\tresult = ops->flavor2info(pseudoflavor, info);\n\n\trpcauth_put_authops(ops);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(rpcauth_get_gssinfo);\n\nstruct rpc_auth *\nrpcauth_create(const struct rpc_auth_create_args *args, struct rpc_clnt *clnt)\n{\n\tstruct rpc_auth\t*auth = ERR_PTR(-EINVAL);\n\tconst struct rpc_authops *ops;\n\tu32 flavor = pseudoflavor_to_flavor(args->pseudoflavor);\n\n\tops = rpcauth_get_authops(flavor);\n\tif (ops == NULL)\n\t\tgoto out;\n\n\tauth = ops->create(args, clnt);\n\n\trpcauth_put_authops(ops);\n\tif (IS_ERR(auth))\n\t\treturn auth;\n\tif (clnt->cl_auth)\n\t\trpcauth_release(clnt->cl_auth);\n\tclnt->cl_auth = auth;\n\nout:\n\treturn auth;\n}\nEXPORT_SYMBOL_GPL(rpcauth_create);\n\nvoid\nrpcauth_release(struct rpc_auth *auth)\n{\n\tif (!refcount_dec_and_test(&auth->au_count))\n\t\treturn;\n\tauth->au_ops->destroy(auth);\n}\n\nstatic DEFINE_SPINLOCK(rpc_credcache_lock);\n\n \nstatic bool\nrpcauth_unhash_cred_locked(struct rpc_cred *cred)\n{\n\tif (!test_and_clear_bit(RPCAUTH_CRED_HASHED, &cred->cr_flags))\n\t\treturn false;\n\thlist_del_rcu(&cred->cr_hash);\n\treturn true;\n}\n\nstatic bool\nrpcauth_unhash_cred(struct rpc_cred *cred)\n{\n\tspinlock_t *cache_lock;\n\tbool ret;\n\n\tif (!test_bit(RPCAUTH_CRED_HASHED, &cred->cr_flags))\n\t\treturn false;\n\tcache_lock = &cred->cr_auth->au_credcache->lock;\n\tspin_lock(cache_lock);\n\tret = rpcauth_unhash_cred_locked(cred);\n\tspin_unlock(cache_lock);\n\treturn ret;\n}\n\n \nint\nrpcauth_init_credcache(struct rpc_auth *auth)\n{\n\tstruct rpc_cred_cache *new;\n\tunsigned int hashsize;\n\n\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\tgoto out_nocache;\n\tnew->hashbits = auth_hashbits;\n\thashsize = 1U << new->hashbits;\n\tnew->hashtable = kcalloc(hashsize, sizeof(new->hashtable[0]), GFP_KERNEL);\n\tif (!new->hashtable)\n\t\tgoto out_nohashtbl;\n\tspin_lock_init(&new->lock);\n\tauth->au_credcache = new;\n\treturn 0;\nout_nohashtbl:\n\tkfree(new);\nout_nocache:\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(rpcauth_init_credcache);\n\nchar *\nrpcauth_stringify_acceptor(struct rpc_cred *cred)\n{\n\tif (!cred->cr_ops->crstringify_acceptor)\n\t\treturn NULL;\n\treturn cred->cr_ops->crstringify_acceptor(cred);\n}\nEXPORT_SYMBOL_GPL(rpcauth_stringify_acceptor);\n\n \nstatic inline\nvoid rpcauth_destroy_credlist(struct list_head *head)\n{\n\tstruct rpc_cred *cred;\n\n\twhile (!list_empty(head)) {\n\t\tcred = list_entry(head->next, struct rpc_cred, cr_lru);\n\t\tlist_del_init(&cred->cr_lru);\n\t\tput_rpccred(cred);\n\t}\n}\n\nstatic void\nrpcauth_lru_add_locked(struct rpc_cred *cred)\n{\n\tif (!list_empty(&cred->cr_lru))\n\t\treturn;\n\tnumber_cred_unused++;\n\tlist_add_tail(&cred->cr_lru, &cred_unused);\n}\n\nstatic void\nrpcauth_lru_add(struct rpc_cred *cred)\n{\n\tif (!list_empty(&cred->cr_lru))\n\t\treturn;\n\tspin_lock(&rpc_credcache_lock);\n\trpcauth_lru_add_locked(cred);\n\tspin_unlock(&rpc_credcache_lock);\n}\n\nstatic void\nrpcauth_lru_remove_locked(struct rpc_cred *cred)\n{\n\tif (list_empty(&cred->cr_lru))\n\t\treturn;\n\tnumber_cred_unused--;\n\tlist_del_init(&cred->cr_lru);\n}\n\nstatic void\nrpcauth_lru_remove(struct rpc_cred *cred)\n{\n\tif (list_empty(&cred->cr_lru))\n\t\treturn;\n\tspin_lock(&rpc_credcache_lock);\n\trpcauth_lru_remove_locked(cred);\n\tspin_unlock(&rpc_credcache_lock);\n}\n\n \nvoid\nrpcauth_clear_credcache(struct rpc_cred_cache *cache)\n{\n\tLIST_HEAD(free);\n\tstruct hlist_head *head;\n\tstruct rpc_cred\t*cred;\n\tunsigned int hashsize = 1U << cache->hashbits;\n\tint\t\ti;\n\n\tspin_lock(&rpc_credcache_lock);\n\tspin_lock(&cache->lock);\n\tfor (i = 0; i < hashsize; i++) {\n\t\thead = &cache->hashtable[i];\n\t\twhile (!hlist_empty(head)) {\n\t\t\tcred = hlist_entry(head->first, struct rpc_cred, cr_hash);\n\t\t\trpcauth_unhash_cred_locked(cred);\n\t\t\t \n\t\t\trpcauth_lru_remove_locked(cred);\n\t\t\tlist_add_tail(&cred->cr_lru, &free);\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n\tspin_unlock(&rpc_credcache_lock);\n\trpcauth_destroy_credlist(&free);\n}\n\n \nvoid\nrpcauth_destroy_credcache(struct rpc_auth *auth)\n{\n\tstruct rpc_cred_cache *cache = auth->au_credcache;\n\n\tif (cache) {\n\t\tauth->au_credcache = NULL;\n\t\trpcauth_clear_credcache(cache);\n\t\tkfree(cache->hashtable);\n\t\tkfree(cache);\n\t}\n}\nEXPORT_SYMBOL_GPL(rpcauth_destroy_credcache);\n\n\n#define RPC_AUTH_EXPIRY_MORATORIUM (60 * HZ)\n\n \nstatic long\nrpcauth_prune_expired(struct list_head *free, int nr_to_scan)\n{\n\tstruct rpc_cred *cred, *next;\n\tunsigned long expired = jiffies - RPC_AUTH_EXPIRY_MORATORIUM;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(cred, next, &cred_unused, cr_lru) {\n\n\t\tif (nr_to_scan-- == 0)\n\t\t\tbreak;\n\t\tif (refcount_read(&cred->cr_count) > 1) {\n\t\t\trpcauth_lru_remove_locked(cred);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (time_in_range(cred->cr_expire, expired, jiffies))\n\t\t\tcontinue;\n\t\tif (!rpcauth_unhash_cred(cred))\n\t\t\tcontinue;\n\n\t\trpcauth_lru_remove_locked(cred);\n\t\tfreed++;\n\t\tlist_add_tail(&cred->cr_lru, free);\n\t}\n\treturn freed ? freed : SHRINK_STOP;\n}\n\nstatic unsigned long\nrpcauth_cache_do_shrink(int nr_to_scan)\n{\n\tLIST_HEAD(free);\n\tunsigned long freed;\n\n\tspin_lock(&rpc_credcache_lock);\n\tfreed = rpcauth_prune_expired(&free, nr_to_scan);\n\tspin_unlock(&rpc_credcache_lock);\n\trpcauth_destroy_credlist(&free);\n\n\treturn freed;\n}\n\n \nstatic unsigned long\nrpcauth_cache_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n\n{\n\tif ((sc->gfp_mask & GFP_KERNEL) != GFP_KERNEL)\n\t\treturn SHRINK_STOP;\n\n\t \n\tif (list_empty(&cred_unused))\n\t\treturn SHRINK_STOP;\n\n\treturn rpcauth_cache_do_shrink(sc->nr_to_scan);\n}\n\nstatic unsigned long\nrpcauth_cache_shrink_count(struct shrinker *shrink, struct shrink_control *sc)\n\n{\n\treturn number_cred_unused * sysctl_vfs_cache_pressure / 100;\n}\n\nstatic void\nrpcauth_cache_enforce_limit(void)\n{\n\tunsigned long diff;\n\tunsigned int nr_to_scan;\n\n\tif (number_cred_unused <= auth_max_cred_cachesize)\n\t\treturn;\n\tdiff = number_cred_unused - auth_max_cred_cachesize;\n\tnr_to_scan = 100;\n\tif (diff < nr_to_scan)\n\t\tnr_to_scan = diff;\n\trpcauth_cache_do_shrink(nr_to_scan);\n}\n\n \nstruct rpc_cred *\nrpcauth_lookup_credcache(struct rpc_auth *auth, struct auth_cred * acred,\n\t\tint flags, gfp_t gfp)\n{\n\tLIST_HEAD(free);\n\tstruct rpc_cred_cache *cache = auth->au_credcache;\n\tstruct rpc_cred\t*cred = NULL,\n\t\t\t*entry, *new;\n\tunsigned int nr;\n\n\tnr = auth->au_ops->hash_cred(acred, cache->hashbits);\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(entry, &cache->hashtable[nr], cr_hash) {\n\t\tif (!entry->cr_ops->crmatch(acred, entry, flags))\n\t\t\tcontinue;\n\t\tcred = get_rpccred(entry);\n\t\tif (cred)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (cred != NULL)\n\t\tgoto found;\n\n\tnew = auth->au_ops->crcreate(auth, acred, flags, gfp);\n\tif (IS_ERR(new)) {\n\t\tcred = new;\n\t\tgoto out;\n\t}\n\n\tspin_lock(&cache->lock);\n\thlist_for_each_entry(entry, &cache->hashtable[nr], cr_hash) {\n\t\tif (!entry->cr_ops->crmatch(acred, entry, flags))\n\t\t\tcontinue;\n\t\tcred = get_rpccred(entry);\n\t\tif (cred)\n\t\t\tbreak;\n\t}\n\tif (cred == NULL) {\n\t\tcred = new;\n\t\tset_bit(RPCAUTH_CRED_HASHED, &cred->cr_flags);\n\t\trefcount_inc(&cred->cr_count);\n\t\thlist_add_head_rcu(&cred->cr_hash, &cache->hashtable[nr]);\n\t} else\n\t\tlist_add_tail(&new->cr_lru, &free);\n\tspin_unlock(&cache->lock);\n\trpcauth_cache_enforce_limit();\nfound:\n\tif (test_bit(RPCAUTH_CRED_NEW, &cred->cr_flags) &&\n\t    cred->cr_ops->cr_init != NULL &&\n\t    !(flags & RPCAUTH_LOOKUP_NEW)) {\n\t\tint res = cred->cr_ops->cr_init(auth, cred);\n\t\tif (res < 0) {\n\t\t\tput_rpccred(cred);\n\t\t\tcred = ERR_PTR(res);\n\t\t}\n\t}\n\trpcauth_destroy_credlist(&free);\nout:\n\treturn cred;\n}\nEXPORT_SYMBOL_GPL(rpcauth_lookup_credcache);\n\nstruct rpc_cred *\nrpcauth_lookupcred(struct rpc_auth *auth, int flags)\n{\n\tstruct auth_cred acred;\n\tstruct rpc_cred *ret;\n\tconst struct cred *cred = current_cred();\n\n\tmemset(&acred, 0, sizeof(acred));\n\tacred.cred = cred;\n\tret = auth->au_ops->lookup_cred(auth, &acred, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rpcauth_lookupcred);\n\nvoid\nrpcauth_init_cred(struct rpc_cred *cred, const struct auth_cred *acred,\n\t\t  struct rpc_auth *auth, const struct rpc_credops *ops)\n{\n\tINIT_HLIST_NODE(&cred->cr_hash);\n\tINIT_LIST_HEAD(&cred->cr_lru);\n\trefcount_set(&cred->cr_count, 1);\n\tcred->cr_auth = auth;\n\tcred->cr_flags = 0;\n\tcred->cr_ops = ops;\n\tcred->cr_expire = jiffies;\n\tcred->cr_cred = get_cred(acred->cred);\n}\nEXPORT_SYMBOL_GPL(rpcauth_init_cred);\n\nstatic struct rpc_cred *\nrpcauth_bind_root_cred(struct rpc_task *task, int lookupflags)\n{\n\tstruct rpc_auth *auth = task->tk_client->cl_auth;\n\tstruct auth_cred acred = {\n\t\t.cred = get_task_cred(&init_task),\n\t};\n\tstruct rpc_cred *ret;\n\n\tif (RPC_IS_ASYNC(task))\n\t\tlookupflags |= RPCAUTH_LOOKUP_ASYNC;\n\tret = auth->au_ops->lookup_cred(auth, &acred, lookupflags);\n\tput_cred(acred.cred);\n\treturn ret;\n}\n\nstatic struct rpc_cred *\nrpcauth_bind_machine_cred(struct rpc_task *task, int lookupflags)\n{\n\tstruct rpc_auth *auth = task->tk_client->cl_auth;\n\tstruct auth_cred acred = {\n\t\t.principal = task->tk_client->cl_principal,\n\t\t.cred = init_task.cred,\n\t};\n\n\tif (!acred.principal)\n\t\treturn NULL;\n\tif (RPC_IS_ASYNC(task))\n\t\tlookupflags |= RPCAUTH_LOOKUP_ASYNC;\n\treturn auth->au_ops->lookup_cred(auth, &acred, lookupflags);\n}\n\nstatic struct rpc_cred *\nrpcauth_bind_new_cred(struct rpc_task *task, int lookupflags)\n{\n\tstruct rpc_auth *auth = task->tk_client->cl_auth;\n\n\treturn rpcauth_lookupcred(auth, lookupflags);\n}\n\nstatic int\nrpcauth_bindcred(struct rpc_task *task, const struct cred *cred, int flags)\n{\n\tstruct rpc_rqst *req = task->tk_rqstp;\n\tstruct rpc_cred *new = NULL;\n\tint lookupflags = 0;\n\tstruct rpc_auth *auth = task->tk_client->cl_auth;\n\tstruct auth_cred acred = {\n\t\t.cred = cred,\n\t};\n\n\tif (flags & RPC_TASK_ASYNC)\n\t\tlookupflags |= RPCAUTH_LOOKUP_NEW | RPCAUTH_LOOKUP_ASYNC;\n\tif (task->tk_op_cred)\n\t\t \n\t\tnew = get_rpccred(task->tk_op_cred);\n\telse if (cred != NULL && cred != &machine_cred)\n\t\tnew = auth->au_ops->lookup_cred(auth, &acred, lookupflags);\n\telse if (cred == &machine_cred)\n\t\tnew = rpcauth_bind_machine_cred(task, lookupflags);\n\n\t \n\tif (new)\n\t\t;\n\telse if (cred == &machine_cred)\n\t\tnew = rpcauth_bind_root_cred(task, lookupflags);\n\telse if (flags & RPC_TASK_NULLCREDS)\n\t\tnew = authnull_ops.lookup_cred(NULL, NULL, 0);\n\telse\n\t\tnew = rpcauth_bind_new_cred(task, lookupflags);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\tput_rpccred(req->rq_cred);\n\treq->rq_cred = new;\n\treturn 0;\n}\n\nvoid\nput_rpccred(struct rpc_cred *cred)\n{\n\tif (cred == NULL)\n\t\treturn;\n\trcu_read_lock();\n\tif (refcount_dec_and_test(&cred->cr_count))\n\t\tgoto destroy;\n\tif (refcount_read(&cred->cr_count) != 1 ||\n\t    !test_bit(RPCAUTH_CRED_HASHED, &cred->cr_flags))\n\t\tgoto out;\n\tif (test_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags) != 0) {\n\t\tcred->cr_expire = jiffies;\n\t\trpcauth_lru_add(cred);\n\t\t \n\t\tif (unlikely(!test_bit(RPCAUTH_CRED_HASHED, &cred->cr_flags)))\n\t\t\trpcauth_lru_remove(cred);\n\t} else if (rpcauth_unhash_cred(cred)) {\n\t\trpcauth_lru_remove(cred);\n\t\tif (refcount_dec_and_test(&cred->cr_count))\n\t\t\tgoto destroy;\n\t}\nout:\n\trcu_read_unlock();\n\treturn;\ndestroy:\n\trcu_read_unlock();\n\tcred->cr_ops->crdestroy(cred);\n}\nEXPORT_SYMBOL_GPL(put_rpccred);\n\n \nint rpcauth_marshcred(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tconst struct rpc_credops *ops = task->tk_rqstp->rq_cred->cr_ops;\n\n\treturn ops->crmarshal(task, xdr);\n}\n\n \nint rpcauth_wrap_req_encode(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tkxdreproc_t encode = task->tk_msg.rpc_proc->p_encode;\n\n\tencode(task->tk_rqstp, xdr, task->tk_msg.rpc_argp);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rpcauth_wrap_req_encode);\n\n \nint rpcauth_wrap_req(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tconst struct rpc_credops *ops = task->tk_rqstp->rq_cred->cr_ops;\n\n\treturn ops->crwrap_req(task, xdr);\n}\n\n \nint\nrpcauth_checkverf(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tconst struct rpc_credops *ops = task->tk_rqstp->rq_cred->cr_ops;\n\n\treturn ops->crvalidate(task, xdr);\n}\n\n \nint\nrpcauth_unwrap_resp_decode(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tkxdrdproc_t decode = task->tk_msg.rpc_proc->p_decode;\n\n\treturn decode(task->tk_rqstp, xdr, task->tk_msg.rpc_resp);\n}\nEXPORT_SYMBOL_GPL(rpcauth_unwrap_resp_decode);\n\n \nint\nrpcauth_unwrap_resp(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tconst struct rpc_credops *ops = task->tk_rqstp->rq_cred->cr_ops;\n\n\treturn ops->crunwrap_resp(task, xdr);\n}\n\nbool\nrpcauth_xmit_need_reencode(struct rpc_task *task)\n{\n\tstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\n\n\tif (!cred || !cred->cr_ops->crneed_reencode)\n\t\treturn false;\n\treturn cred->cr_ops->crneed_reencode(task);\n}\n\nint\nrpcauth_refreshcred(struct rpc_task *task)\n{\n\tstruct rpc_cred\t*cred;\n\tint err;\n\n\tcred = task->tk_rqstp->rq_cred;\n\tif (cred == NULL) {\n\t\terr = rpcauth_bindcred(task, task->tk_msg.rpc_cred, task->tk_flags);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tcred = task->tk_rqstp->rq_cred;\n\t}\n\n\terr = cred->cr_ops->crrefresh(task);\nout:\n\tif (err < 0)\n\t\ttask->tk_status = err;\n\treturn err;\n}\n\nvoid\nrpcauth_invalcred(struct rpc_task *task)\n{\n\tstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\n\n\tif (cred)\n\t\tclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\n}\n\nint\nrpcauth_uptodatecred(struct rpc_task *task)\n{\n\tstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\n\n\treturn cred == NULL ||\n\t\ttest_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags) != 0;\n}\n\nstatic struct shrinker rpc_cred_shrinker = {\n\t.count_objects = rpcauth_cache_shrink_count,\n\t.scan_objects = rpcauth_cache_shrink_scan,\n\t.seeks = DEFAULT_SEEKS,\n};\n\nint __init rpcauth_init_module(void)\n{\n\tint err;\n\n\terr = rpc_init_authunix();\n\tif (err < 0)\n\t\tgoto out1;\n\terr = register_shrinker(&rpc_cred_shrinker, \"sunrpc_cred\");\n\tif (err < 0)\n\t\tgoto out2;\n\treturn 0;\nout2:\n\trpc_destroy_authunix();\nout1:\n\treturn err;\n}\n\nvoid rpcauth_remove_module(void)\n{\n\trpc_destroy_authunix();\n\tunregister_shrinker(&rpc_cred_shrinker);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}