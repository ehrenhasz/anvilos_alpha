{
  "module_name": "socklib.c",
  "hash_id": "42e96adb9ac0397b6e1fbfa677b62c31b51e0f28c6287239d39c156345f23dff",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/socklib.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/netdevice.h>\n#include <linux/gfp.h>\n#include <linux/skbuff.h>\n#include <linux/types.h>\n#include <linux/pagemap.h>\n#include <linux/udp.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/export.h>\n\n#include \"socklib.h\"\n\n \nstruct xdr_skb_reader {\n\tstruct sk_buff\t*skb;\n\tunsigned int\toffset;\n\tsize_t\t\tcount;\n\t__wsum\t\tcsum;\n};\n\ntypedef size_t (*xdr_skb_read_actor)(struct xdr_skb_reader *desc, void *to,\n\t\t\t\t     size_t len);\n\n \nstatic size_t\nxdr_skb_read_bits(struct xdr_skb_reader *desc, void *to, size_t len)\n{\n\tif (len > desc->count)\n\t\tlen = desc->count;\n\tif (unlikely(skb_copy_bits(desc->skb, desc->offset, to, len)))\n\t\treturn 0;\n\tdesc->count -= len;\n\tdesc->offset += len;\n\treturn len;\n}\n\n \nstatic size_t xdr_skb_read_and_csum_bits(struct xdr_skb_reader *desc, void *to, size_t len)\n{\n\tunsigned int pos;\n\t__wsum csum2;\n\n\tif (len > desc->count)\n\t\tlen = desc->count;\n\tpos = desc->offset;\n\tcsum2 = skb_copy_and_csum_bits(desc->skb, pos, to, len);\n\tdesc->csum = csum_block_add(desc->csum, csum2, pos);\n\tdesc->count -= len;\n\tdesc->offset += len;\n\treturn len;\n}\n\n \nstatic ssize_t\nxdr_partial_copy_from_skb(struct xdr_buf *xdr, unsigned int base, struct xdr_skb_reader *desc, xdr_skb_read_actor copy_actor)\n{\n\tstruct page\t**ppage = xdr->pages;\n\tunsigned int\tlen, pglen = xdr->page_len;\n\tssize_t\t\tcopied = 0;\n\tsize_t\t\tret;\n\n\tlen = xdr->head[0].iov_len;\n\tif (base < len) {\n\t\tlen -= base;\n\t\tret = copy_actor(desc, (char *)xdr->head[0].iov_base + base, len);\n\t\tcopied += ret;\n\t\tif (ret != len || !desc->count)\n\t\t\tgoto out;\n\t\tbase = 0;\n\t} else\n\t\tbase -= len;\n\n\tif (unlikely(pglen == 0))\n\t\tgoto copy_tail;\n\tif (unlikely(base >= pglen)) {\n\t\tbase -= pglen;\n\t\tgoto copy_tail;\n\t}\n\tif (base || xdr->page_base) {\n\t\tpglen -= base;\n\t\tbase += xdr->page_base;\n\t\tppage += base >> PAGE_SHIFT;\n\t\tbase &= ~PAGE_MASK;\n\t}\n\tdo {\n\t\tchar *kaddr;\n\n\t\t \n\t\tif ((xdr->flags & XDRBUF_SPARSE_PAGES) && *ppage == NULL) {\n\t\t\t*ppage = alloc_page(GFP_NOWAIT | __GFP_NOWARN);\n\t\t\tif (unlikely(*ppage == NULL)) {\n\t\t\t\tif (copied == 0)\n\t\t\t\t\tcopied = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tlen = PAGE_SIZE;\n\t\tkaddr = kmap_atomic(*ppage);\n\t\tif (base) {\n\t\t\tlen -= base;\n\t\t\tif (pglen < len)\n\t\t\t\tlen = pglen;\n\t\t\tret = copy_actor(desc, kaddr + base, len);\n\t\t\tbase = 0;\n\t\t} else {\n\t\t\tif (pglen < len)\n\t\t\t\tlen = pglen;\n\t\t\tret = copy_actor(desc, kaddr, len);\n\t\t}\n\t\tflush_dcache_page(*ppage);\n\t\tkunmap_atomic(kaddr);\n\t\tcopied += ret;\n\t\tif (ret != len || !desc->count)\n\t\t\tgoto out;\n\t\tppage++;\n\t} while ((pglen -= len) != 0);\ncopy_tail:\n\tlen = xdr->tail[0].iov_len;\n\tif (base < len)\n\t\tcopied += copy_actor(desc, (char *)xdr->tail[0].iov_base + base, len - base);\nout:\n\treturn copied;\n}\n\n \nint csum_partial_copy_to_xdr(struct xdr_buf *xdr, struct sk_buff *skb)\n{\n\tstruct xdr_skb_reader\tdesc;\n\n\tdesc.skb = skb;\n\tdesc.offset = 0;\n\tdesc.count = skb->len - desc.offset;\n\n\tif (skb_csum_unnecessary(skb))\n\t\tgoto no_checksum;\n\n\tdesc.csum = csum_partial(skb->data, desc.offset, skb->csum);\n\tif (xdr_partial_copy_from_skb(xdr, 0, &desc, xdr_skb_read_and_csum_bits) < 0)\n\t\treturn -1;\n\tif (desc.offset != skb->len) {\n\t\t__wsum csum2;\n\t\tcsum2 = skb_checksum(skb, desc.offset, skb->len - desc.offset, 0);\n\t\tdesc.csum = csum_block_add(desc.csum, csum2, desc.offset);\n\t}\n\tif (desc.count)\n\t\treturn -1;\n\tif (csum_fold(desc.csum))\n\t\treturn -1;\n\tif (unlikely(skb->ip_summed == CHECKSUM_COMPLETE) &&\n\t    !skb->csum_complete_sw)\n\t\tnetdev_rx_csum_fault(skb->dev, skb);\n\treturn 0;\nno_checksum:\n\tif (xdr_partial_copy_from_skb(xdr, 0, &desc, xdr_skb_read_bits) < 0)\n\t\treturn -1;\n\tif (desc.count)\n\t\treturn -1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(csum_partial_copy_to_xdr);\n\nstatic inline int xprt_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t       size_t seek)\n{\n\tif (seek)\n\t\tiov_iter_advance(&msg->msg_iter, seek);\n\treturn sock_sendmsg(sock, msg);\n}\n\nstatic int xprt_send_kvec(struct socket *sock, struct msghdr *msg,\n\t\t\t  struct kvec *vec, size_t seek)\n{\n\tiov_iter_kvec(&msg->msg_iter, ITER_SOURCE, vec, 1, vec->iov_len);\n\treturn xprt_sendmsg(sock, msg, seek);\n}\n\nstatic int xprt_send_pagedata(struct socket *sock, struct msghdr *msg,\n\t\t\t      struct xdr_buf *xdr, size_t base)\n{\n\tiov_iter_bvec(&msg->msg_iter, ITER_SOURCE, xdr->bvec, xdr_buf_pagecount(xdr),\n\t\t      xdr->page_len + xdr->page_base);\n\treturn xprt_sendmsg(sock, msg, base + xdr->page_base);\n}\n\n \nstatic int xprt_send_rm_and_kvec(struct socket *sock, struct msghdr *msg,\n\t\t\t\t rpc_fraghdr marker, struct kvec *vec,\n\t\t\t\t size_t base)\n{\n\tstruct kvec iov[2] = {\n\t\t[0] = {\n\t\t\t.iov_base\t= &marker,\n\t\t\t.iov_len\t= sizeof(marker)\n\t\t},\n\t\t[1] = *vec,\n\t};\n\tsize_t len = iov[0].iov_len + iov[1].iov_len;\n\n\tiov_iter_kvec(&msg->msg_iter, ITER_SOURCE, iov, 2, len);\n\treturn xprt_sendmsg(sock, msg, base);\n}\n\n \nint xprt_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t      struct xdr_buf *xdr, unsigned int base,\n\t\t      rpc_fraghdr marker, unsigned int *sent_p)\n{\n\tunsigned int rmsize = marker ? sizeof(marker) : 0;\n\tunsigned int remainder = rmsize + xdr->len - base;\n\tunsigned int want;\n\tint err = 0;\n\n\t*sent_p = 0;\n\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tmsg->msg_flags |= MSG_MORE;\n\twant = xdr->head[0].iov_len + rmsize;\n\tif (base < want) {\n\t\tunsigned int len = want - base;\n\n\t\tremainder -= len;\n\t\tif (remainder == 0)\n\t\t\tmsg->msg_flags &= ~MSG_MORE;\n\t\tif (rmsize)\n\t\t\terr = xprt_send_rm_and_kvec(sock, msg, marker,\n\t\t\t\t\t\t    &xdr->head[0], base);\n\t\telse\n\t\t\terr = xprt_send_kvec(sock, msg, &xdr->head[0], base);\n\t\tif (remainder == 0 || err != len)\n\t\t\tgoto out;\n\t\t*sent_p += err;\n\t\tbase = 0;\n\t} else {\n\t\tbase -= want;\n\t}\n\n\tif (base < xdr->page_len) {\n\t\tunsigned int len = xdr->page_len - base;\n\n\t\tremainder -= len;\n\t\tif (remainder == 0)\n\t\t\tmsg->msg_flags &= ~MSG_MORE;\n\t\terr = xprt_send_pagedata(sock, msg, xdr, base);\n\t\tif (remainder == 0 || err != len)\n\t\t\tgoto out;\n\t\t*sent_p += err;\n\t\tbase = 0;\n\t} else {\n\t\tbase -= xdr->page_len;\n\t}\n\n\tif (base >= xdr->tail[0].iov_len)\n\t\treturn 0;\n\tmsg->msg_flags &= ~MSG_MORE;\n\terr = xprt_send_kvec(sock, msg, &xdr->tail[0], base);\nout:\n\tif (err > 0) {\n\t\t*sent_p += err;\n\t\terr = 0;\n\t}\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}