{
  "module_name": "addr.c",
  "hash_id": "d4cd1770e1077e316619440aa6314dff91a1f3526f13b8e4f82d8baaed212b54",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/addr.c",
  "human_readable_source": "\n \n\n#include <net/ipv6.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#if IS_ENABLED(CONFIG_IPV6)\n\nstatic size_t rpc_ntop6_noscopeid(const struct sockaddr *sap,\n\t\t\t\t  char *buf, const int buflen)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tconst struct in6_addr *addr = &sin6->sin6_addr;\n\n\t \n\tif (ipv6_addr_any(addr))\n\t\treturn snprintf(buf, buflen, \"::\");\n\n\t \n\tif (ipv6_addr_loopback(addr))\n\t\treturn snprintf(buf, buflen, \"::1\");\n\n\t \n\tif (ipv6_addr_v4mapped(addr))\n\t\treturn snprintf(buf, buflen, \"::ffff:%pI4\",\n\t\t\t\t\t&addr->s6_addr32[3]);\n\n\t \n\treturn snprintf(buf, buflen, \"%pI6c\", addr);\n}\n\nstatic size_t rpc_ntop6(const struct sockaddr *sap,\n\t\t\tchar *buf, const size_t buflen)\n{\n\tconst struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tchar scopebuf[IPV6_SCOPE_ID_LEN];\n\tsize_t len;\n\tint rc;\n\n\tlen = rpc_ntop6_noscopeid(sap, buf, buflen);\n\tif (unlikely(len == 0))\n\t\treturn len;\n\n\tif (!(ipv6_addr_type(&sin6->sin6_addr) & IPV6_ADDR_LINKLOCAL))\n\t\treturn len;\n\tif (sin6->sin6_scope_id == 0)\n\t\treturn len;\n\n\trc = snprintf(scopebuf, sizeof(scopebuf), \"%c%u\",\n\t\t\tIPV6_SCOPE_DELIMITER, sin6->sin6_scope_id);\n\tif (unlikely((size_t)rc >= sizeof(scopebuf)))\n\t\treturn 0;\n\n\tlen += rc;\n\tif (unlikely(len >= buflen))\n\t\treturn 0;\n\n\tstrcat(buf, scopebuf);\n\treturn len;\n}\n\n#else\t \n\nstatic size_t rpc_ntop6_noscopeid(const struct sockaddr *sap,\n\t\t\t\t  char *buf, const int buflen)\n{\n\treturn 0;\n}\n\nstatic size_t rpc_ntop6(const struct sockaddr *sap,\n\t\t\tchar *buf, const size_t buflen)\n{\n\treturn 0;\n}\n\n#endif\t \n\nstatic int rpc_ntop4(const struct sockaddr *sap,\n\t\t     char *buf, const size_t buflen)\n{\n\tconst struct sockaddr_in *sin = (struct sockaddr_in *)sap;\n\n\treturn snprintf(buf, buflen, \"%pI4\", &sin->sin_addr);\n}\n\n \nsize_t rpc_ntop(const struct sockaddr *sap, char *buf, const size_t buflen)\n{\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\treturn rpc_ntop4(sap, buf, buflen);\n\tcase AF_INET6:\n\t\treturn rpc_ntop6(sap, buf, buflen);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rpc_ntop);\n\nstatic size_t rpc_pton4(const char *buf, const size_t buflen,\n\t\t\tstruct sockaddr *sap, const size_t salen)\n{\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)sap;\n\tu8 *addr = (u8 *)&sin->sin_addr.s_addr;\n\n\tif (buflen > INET_ADDRSTRLEN || salen < sizeof(struct sockaddr_in))\n\t\treturn 0;\n\n\tmemset(sap, 0, sizeof(struct sockaddr_in));\n\n\tif (in4_pton(buf, buflen, addr, '\\0', NULL) == 0)\n\t\treturn 0;\n\n\tsin->sin_family = AF_INET;\n\treturn sizeof(struct sockaddr_in);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int rpc_parse_scope_id(struct net *net, const char *buf,\n\t\t\t      const size_t buflen, const char *delim,\n\t\t\t      struct sockaddr_in6 *sin6)\n{\n\tchar p[IPV6_SCOPE_ID_LEN + 1];\n\tsize_t len;\n\tu32 scope_id = 0;\n\tstruct net_device *dev;\n\n\tif ((buf + buflen) == delim)\n\t\treturn 1;\n\n\tif (*delim != IPV6_SCOPE_DELIMITER)\n\t\treturn 0;\n\n\tif (!(ipv6_addr_type(&sin6->sin6_addr) & IPV6_ADDR_LINKLOCAL))\n\t\treturn 0;\n\n\tlen = (buf + buflen) - delim - 1;\n\tif (len > IPV6_SCOPE_ID_LEN)\n\t\treturn 0;\n\n\tmemcpy(p, delim + 1, len);\n\tp[len] = 0;\n\n\tdev = dev_get_by_name(net, p);\n\tif (dev != NULL) {\n\t\tscope_id = dev->ifindex;\n\t\tdev_put(dev);\n\t} else {\n\t\tif (kstrtou32(p, 10, &scope_id) != 0)\n\t\t\treturn 0;\n\t}\n\n\tsin6->sin6_scope_id = scope_id;\n\treturn 1;\n}\n\nstatic size_t rpc_pton6(struct net *net, const char *buf, const size_t buflen,\n\t\t\tstruct sockaddr *sap, const size_t salen)\n{\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sap;\n\tu8 *addr = (u8 *)&sin6->sin6_addr.in6_u;\n\tconst char *delim;\n\n\tif (buflen > (INET6_ADDRSTRLEN + IPV6_SCOPE_ID_LEN) ||\n\t    salen < sizeof(struct sockaddr_in6))\n\t\treturn 0;\n\n\tmemset(sap, 0, sizeof(struct sockaddr_in6));\n\n\tif (in6_pton(buf, buflen, addr, IPV6_SCOPE_DELIMITER, &delim) == 0)\n\t\treturn 0;\n\n\tif (!rpc_parse_scope_id(net, buf, buflen, delim, sin6))\n\t\treturn 0;\n\n\tsin6->sin6_family = AF_INET6;\n\treturn sizeof(struct sockaddr_in6);\n}\n#else\nstatic size_t rpc_pton6(struct net *net, const char *buf, const size_t buflen,\n\t\t\tstruct sockaddr *sap, const size_t salen)\n{\n\treturn 0;\n}\n#endif\n\n \nsize_t rpc_pton(struct net *net, const char *buf, const size_t buflen,\n\t\tstruct sockaddr *sap, const size_t salen)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < buflen; i++)\n\t\tif (buf[i] == ':')\n\t\t\treturn rpc_pton6(net, buf, buflen, sap, salen);\n\treturn rpc_pton4(buf, buflen, sap, salen);\n}\nEXPORT_SYMBOL_GPL(rpc_pton);\n\n \nchar *rpc_sockaddr2uaddr(const struct sockaddr *sap, gfp_t gfp_flags)\n{\n\tchar portbuf[RPCBIND_MAXUADDRPLEN];\n\tchar addrbuf[RPCBIND_MAXUADDRLEN];\n\tunsigned short port;\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\tif (rpc_ntop4(sap, addrbuf, sizeof(addrbuf)) == 0)\n\t\t\treturn NULL;\n\t\tport = ntohs(((struct sockaddr_in *)sap)->sin_port);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (rpc_ntop6_noscopeid(sap, addrbuf, sizeof(addrbuf)) == 0)\n\t\t\treturn NULL;\n\t\tport = ntohs(((struct sockaddr_in6 *)sap)->sin6_port);\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tif (snprintf(portbuf, sizeof(portbuf),\n\t\t     \".%u.%u\", port >> 8, port & 0xff) > (int)sizeof(portbuf))\n\t\treturn NULL;\n\n\tif (strlcat(addrbuf, portbuf, sizeof(addrbuf)) > sizeof(addrbuf))\n\t\treturn NULL;\n\n\treturn kstrdup(addrbuf, gfp_flags);\n}\n\n \nsize_t rpc_uaddr2sockaddr(struct net *net, const char *uaddr,\n\t\t\t  const size_t uaddr_len, struct sockaddr *sap,\n\t\t\t  const size_t salen)\n{\n\tchar *c, buf[RPCBIND_MAXUADDRLEN + sizeof('\\0')];\n\tu8 portlo, porthi;\n\tunsigned short port;\n\n\tif (uaddr_len > RPCBIND_MAXUADDRLEN)\n\t\treturn 0;\n\n\tmemcpy(buf, uaddr, uaddr_len);\n\n\tbuf[uaddr_len] = '\\0';\n\tc = strrchr(buf, '.');\n\tif (unlikely(c == NULL))\n\t\treturn 0;\n\tif (unlikely(kstrtou8(c + 1, 10, &portlo) != 0))\n\t\treturn 0;\n\n\t*c = '\\0';\n\tc = strrchr(buf, '.');\n\tif (unlikely(c == NULL))\n\t\treturn 0;\n\tif (unlikely(kstrtou8(c + 1, 10, &porthi) != 0))\n\t\treturn 0;\n\n\tport = (unsigned short)((porthi << 8) | portlo);\n\n\t*c = '\\0';\n\tif (rpc_pton(net, buf, strlen(buf), sap, salen) == 0)\n\t\treturn 0;\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\t((struct sockaddr_in *)sap)->sin_port = htons(port);\n\t\treturn sizeof(struct sockaddr_in);\n\tcase AF_INET6:\n\t\t((struct sockaddr_in6 *)sap)->sin6_port = htons(port);\n\t\treturn sizeof(struct sockaddr_in6);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rpc_uaddr2sockaddr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}