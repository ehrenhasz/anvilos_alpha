{
  "module_name": "clnt.c",
  "hash_id": "2749c403bc958c2fec19685df8bfe19190556051bff722380ee7f4cf81f75b77",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/clnt.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/rcupdate.h>\n#include <linux/utsname.h>\n#include <linux/workqueue.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/un.h>\n\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <trace/events/sunrpc.h>\n\n#include \"sunrpc.h\"\n#include \"sysfs.h\"\n#include \"netns.h\"\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n# define RPCDBG_FACILITY\tRPCDBG_CALL\n#endif\n\n \n\nstatic DECLARE_WAIT_QUEUE_HEAD(destroy_wait);\n\n\nstatic void\tcall_start(struct rpc_task *task);\nstatic void\tcall_reserve(struct rpc_task *task);\nstatic void\tcall_reserveresult(struct rpc_task *task);\nstatic void\tcall_allocate(struct rpc_task *task);\nstatic void\tcall_encode(struct rpc_task *task);\nstatic void\tcall_decode(struct rpc_task *task);\nstatic void\tcall_bind(struct rpc_task *task);\nstatic void\tcall_bind_status(struct rpc_task *task);\nstatic void\tcall_transmit(struct rpc_task *task);\nstatic void\tcall_status(struct rpc_task *task);\nstatic void\tcall_transmit_status(struct rpc_task *task);\nstatic void\tcall_refresh(struct rpc_task *task);\nstatic void\tcall_refreshresult(struct rpc_task *task);\nstatic void\tcall_connect(struct rpc_task *task);\nstatic void\tcall_connect_status(struct rpc_task *task);\n\nstatic int\trpc_encode_header(struct rpc_task *task,\n\t\t\t\t  struct xdr_stream *xdr);\nstatic int\trpc_decode_header(struct rpc_task *task,\n\t\t\t\t  struct xdr_stream *xdr);\nstatic int\trpc_ping(struct rpc_clnt *clnt);\nstatic int\trpc_ping_noreply(struct rpc_clnt *clnt);\nstatic void\trpc_check_timeout(struct rpc_task *task);\n\nstatic void rpc_register_client(struct rpc_clnt *clnt)\n{\n\tstruct net *net = rpc_net_ns(clnt);\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tspin_lock(&sn->rpc_client_lock);\n\tlist_add(&clnt->cl_clients, &sn->all_clients);\n\tspin_unlock(&sn->rpc_client_lock);\n}\n\nstatic void rpc_unregister_client(struct rpc_clnt *clnt)\n{\n\tstruct net *net = rpc_net_ns(clnt);\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tspin_lock(&sn->rpc_client_lock);\n\tlist_del(&clnt->cl_clients);\n\tspin_unlock(&sn->rpc_client_lock);\n}\n\nstatic void __rpc_clnt_remove_pipedir(struct rpc_clnt *clnt)\n{\n\trpc_remove_client_dir(clnt);\n}\n\nstatic void rpc_clnt_remove_pipedir(struct rpc_clnt *clnt)\n{\n\tstruct net *net = rpc_net_ns(clnt);\n\tstruct super_block *pipefs_sb;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tif (pipefs_sb == clnt->pipefs_sb)\n\t\t\t__rpc_clnt_remove_pipedir(clnt);\n\t\trpc_put_sb_net(net);\n\t}\n}\n\nstatic struct dentry *rpc_setup_pipedir_sb(struct super_block *sb,\n\t\t\t\t    struct rpc_clnt *clnt)\n{\n\tstatic uint32_t clntid;\n\tconst char *dir_name = clnt->cl_program->pipe_dir_name;\n\tchar name[15];\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, dir_name);\n\tif (dir == NULL) {\n\t\tpr_info(\"RPC: pipefs directory doesn't exist: %s\\n\", dir_name);\n\t\treturn dir;\n\t}\n\tfor (;;) {\n\t\tsnprintf(name, sizeof(name), \"clnt%x\", (unsigned int)clntid++);\n\t\tname[sizeof(name) - 1] = '\\0';\n\t\tdentry = rpc_create_client_dir(dir, name, clnt);\n\t\tif (!IS_ERR(dentry))\n\t\t\tbreak;\n\t\tif (dentry == ERR_PTR(-EEXIST))\n\t\t\tcontinue;\n\t\tprintk(KERN_INFO \"RPC: Couldn't create pipefs entry\"\n\t\t\t\t\" %s/%s, error %ld\\n\",\n\t\t\t\tdir_name, name, PTR_ERR(dentry));\n\t\tbreak;\n\t}\n\tdput(dir);\n\treturn dentry;\n}\n\nstatic int\nrpc_setup_pipedir(struct super_block *pipefs_sb, struct rpc_clnt *clnt)\n{\n\tstruct dentry *dentry;\n\n\tclnt->pipefs_sb = pipefs_sb;\n\n\tif (clnt->cl_program->pipe_dir_name != NULL) {\n\t\tdentry = rpc_setup_pipedir_sb(pipefs_sb, clnt);\n\t\tif (IS_ERR(dentry))\n\t\t\treturn PTR_ERR(dentry);\n\t}\n\treturn 0;\n}\n\nstatic int rpc_clnt_skip_event(struct rpc_clnt *clnt, unsigned long event)\n{\n\tif (clnt->cl_program->pipe_dir_name == NULL)\n\t\treturn 1;\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tif (clnt->cl_pipedir_objects.pdh_dentry != NULL)\n\t\t\treturn 1;\n\t\tif (refcount_read(&clnt->cl_count) == 0)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (clnt->cl_pipedir_objects.pdh_dentry == NULL)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int __rpc_clnt_handle_event(struct rpc_clnt *clnt, unsigned long event,\n\t\t\t\t   struct super_block *sb)\n{\n\tstruct dentry *dentry;\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = rpc_setup_pipedir_sb(sb, clnt);\n\t\tif (!dentry)\n\t\t\treturn -ENOENT;\n\t\tif (IS_ERR(dentry))\n\t\t\treturn PTR_ERR(dentry);\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\t__rpc_clnt_remove_pipedir(clnt);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s: unknown event: %ld\\n\", __func__, event);\n\t\treturn -ENOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int __rpc_pipefs_event(struct rpc_clnt *clnt, unsigned long event,\n\t\t\t\tstruct super_block *sb)\n{\n\tint error = 0;\n\n\tfor (;; clnt = clnt->cl_parent) {\n\t\tif (!rpc_clnt_skip_event(clnt, event))\n\t\t\terror = __rpc_clnt_handle_event(clnt, event, sb);\n\t\tif (error || clnt == clnt->cl_parent)\n\t\t\tbreak;\n\t}\n\treturn error;\n}\n\nstatic struct rpc_clnt *rpc_get_client_for_event(struct net *net, int event)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct rpc_clnt *clnt;\n\n\tspin_lock(&sn->rpc_client_lock);\n\tlist_for_each_entry(clnt, &sn->all_clients, cl_clients) {\n\t\tif (rpc_clnt_skip_event(clnt, event))\n\t\t\tcontinue;\n\t\tspin_unlock(&sn->rpc_client_lock);\n\t\treturn clnt;\n\t}\n\tspin_unlock(&sn->rpc_client_lock);\n\treturn NULL;\n}\n\nstatic int rpc_pipefs_event(struct notifier_block *nb, unsigned long event,\n\t\t\t    void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct rpc_clnt *clnt;\n\tint error = 0;\n\n\twhile ((clnt = rpc_get_client_for_event(sb->s_fs_info, event))) {\n\t\terror = __rpc_pipefs_event(clnt, event, sb);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\treturn error;\n}\n\nstatic struct notifier_block rpc_clients_block = {\n\t.notifier_call\t= rpc_pipefs_event,\n\t.priority\t= SUNRPC_PIPEFS_RPC_PRIO,\n};\n\nint rpc_clients_notifier_register(void)\n{\n\treturn rpc_pipefs_notifier_register(&rpc_clients_block);\n}\n\nvoid rpc_clients_notifier_unregister(void)\n{\n\treturn rpc_pipefs_notifier_unregister(&rpc_clients_block);\n}\n\nstatic struct rpc_xprt *rpc_clnt_set_transport(struct rpc_clnt *clnt,\n\t\tstruct rpc_xprt *xprt,\n\t\tconst struct rpc_timeout *timeout)\n{\n\tstruct rpc_xprt *old;\n\n\tspin_lock(&clnt->cl_lock);\n\told = rcu_dereference_protected(clnt->cl_xprt,\n\t\t\tlockdep_is_held(&clnt->cl_lock));\n\n\tif (!xprt_bound(xprt))\n\t\tclnt->cl_autobind = 1;\n\n\tclnt->cl_timeout = timeout;\n\trcu_assign_pointer(clnt->cl_xprt, xprt);\n\tspin_unlock(&clnt->cl_lock);\n\n\treturn old;\n}\n\nstatic void rpc_clnt_set_nodename(struct rpc_clnt *clnt, const char *nodename)\n{\n\tclnt->cl_nodelen = strlcpy(clnt->cl_nodename,\n\t\t\tnodename, sizeof(clnt->cl_nodename));\n}\n\nstatic int rpc_client_register(struct rpc_clnt *clnt,\n\t\t\t       rpc_authflavor_t pseudoflavor,\n\t\t\t       const char *client_name)\n{\n\tstruct rpc_auth_create_args auth_args = {\n\t\t.pseudoflavor = pseudoflavor,\n\t\t.target_name = client_name,\n\t};\n\tstruct rpc_auth *auth;\n\tstruct net *net = rpc_net_ns(clnt);\n\tstruct super_block *pipefs_sb;\n\tint err;\n\n\trpc_clnt_debugfs_register(clnt);\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\terr = rpc_setup_pipedir(pipefs_sb, clnt);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\trpc_register_client(clnt);\n\tif (pipefs_sb)\n\t\trpc_put_sb_net(net);\n\n\tauth = rpcauth_create(&auth_args, clnt);\n\tif (IS_ERR(auth)) {\n\t\tdprintk(\"RPC:       Couldn't create auth handle (flavor %u)\\n\",\n\t\t\t\tpseudoflavor);\n\t\terr = PTR_ERR(auth);\n\t\tgoto err_auth;\n\t}\n\treturn 0;\nerr_auth:\n\tpipefs_sb = rpc_get_sb_net(net);\n\trpc_unregister_client(clnt);\n\t__rpc_clnt_remove_pipedir(clnt);\nout:\n\tif (pipefs_sb)\n\t\trpc_put_sb_net(net);\n\trpc_sysfs_client_destroy(clnt);\n\trpc_clnt_debugfs_unregister(clnt);\n\treturn err;\n}\n\nstatic DEFINE_IDA(rpc_clids);\n\nvoid rpc_cleanup_clids(void)\n{\n\tida_destroy(&rpc_clids);\n}\n\nstatic int rpc_alloc_clid(struct rpc_clnt *clnt)\n{\n\tint clid;\n\n\tclid = ida_alloc(&rpc_clids, GFP_KERNEL);\n\tif (clid < 0)\n\t\treturn clid;\n\tclnt->cl_clid = clid;\n\treturn 0;\n}\n\nstatic void rpc_free_clid(struct rpc_clnt *clnt)\n{\n\tida_free(&rpc_clids, clnt->cl_clid);\n}\n\nstatic struct rpc_clnt * rpc_new_client(const struct rpc_create_args *args,\n\t\tstruct rpc_xprt_switch *xps,\n\t\tstruct rpc_xprt *xprt,\n\t\tstruct rpc_clnt *parent)\n{\n\tconst struct rpc_program *program = args->program;\n\tconst struct rpc_version *version;\n\tstruct rpc_clnt *clnt = NULL;\n\tconst struct rpc_timeout *timeout;\n\tconst char *nodename = args->nodename;\n\tint err;\n\n\terr = rpciod_up();\n\tif (err)\n\t\tgoto out_no_rpciod;\n\n\terr = -EINVAL;\n\tif (args->version >= program->nrvers)\n\t\tgoto out_err;\n\tversion = program->version[args->version];\n\tif (version == NULL)\n\t\tgoto out_err;\n\n\terr = -ENOMEM;\n\tclnt = kzalloc(sizeof(*clnt), GFP_KERNEL);\n\tif (!clnt)\n\t\tgoto out_err;\n\tclnt->cl_parent = parent ? : clnt;\n\tclnt->cl_xprtsec = args->xprtsec;\n\n\terr = rpc_alloc_clid(clnt);\n\tif (err)\n\t\tgoto out_no_clid;\n\n\tclnt->cl_cred\t  = get_cred(args->cred);\n\tclnt->cl_procinfo = version->procs;\n\tclnt->cl_maxproc  = version->nrprocs;\n\tclnt->cl_prog     = args->prognumber ? : program->number;\n\tclnt->cl_vers     = version->number;\n\tclnt->cl_stats    = program->stats;\n\tclnt->cl_metrics  = rpc_alloc_iostats(clnt);\n\trpc_init_pipe_dir_head(&clnt->cl_pipedir_objects);\n\terr = -ENOMEM;\n\tif (clnt->cl_metrics == NULL)\n\t\tgoto out_no_stats;\n\tclnt->cl_program  = program;\n\tINIT_LIST_HEAD(&clnt->cl_tasks);\n\tspin_lock_init(&clnt->cl_lock);\n\n\ttimeout = xprt->timeout;\n\tif (args->timeout != NULL) {\n\t\tmemcpy(&clnt->cl_timeout_default, args->timeout,\n\t\t\t\tsizeof(clnt->cl_timeout_default));\n\t\ttimeout = &clnt->cl_timeout_default;\n\t}\n\n\trpc_clnt_set_transport(clnt, xprt, timeout);\n\txprt->main = true;\n\txprt_iter_init(&clnt->cl_xpi, xps);\n\txprt_switch_put(xps);\n\n\tclnt->cl_rtt = &clnt->cl_rtt_default;\n\trpc_init_rtt(&clnt->cl_rtt_default, clnt->cl_timeout->to_initval);\n\n\trefcount_set(&clnt->cl_count, 1);\n\n\tif (nodename == NULL)\n\t\tnodename = utsname()->nodename;\n\t \n\trpc_clnt_set_nodename(clnt, nodename);\n\n\trpc_sysfs_client_setup(clnt, xps, rpc_net_ns(clnt));\n\terr = rpc_client_register(clnt, args->authflavor, args->client_name);\n\tif (err)\n\t\tgoto out_no_path;\n\tif (parent)\n\t\trefcount_inc(&parent->cl_count);\n\n\ttrace_rpc_clnt_new(clnt, xprt, args);\n\treturn clnt;\n\nout_no_path:\n\trpc_free_iostats(clnt->cl_metrics);\nout_no_stats:\n\tput_cred(clnt->cl_cred);\n\trpc_free_clid(clnt);\nout_no_clid:\n\tkfree(clnt);\nout_err:\n\trpciod_down();\nout_no_rpciod:\n\txprt_switch_put(xps);\n\txprt_put(xprt);\n\ttrace_rpc_clnt_new_err(program->name, args->servername, err);\n\treturn ERR_PTR(err);\n}\n\nstatic struct rpc_clnt *rpc_create_xprt(struct rpc_create_args *args,\n\t\t\t\t\tstruct rpc_xprt *xprt)\n{\n\tstruct rpc_clnt *clnt = NULL;\n\tstruct rpc_xprt_switch *xps;\n\n\tif (args->bc_xprt && args->bc_xprt->xpt_bc_xps) {\n\t\tWARN_ON_ONCE(!(args->protocol & XPRT_TRANSPORT_BC));\n\t\txps = args->bc_xprt->xpt_bc_xps;\n\t\txprt_switch_get(xps);\n\t} else {\n\t\txps = xprt_switch_alloc(xprt, GFP_KERNEL);\n\t\tif (xps == NULL) {\n\t\t\txprt_put(xprt);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tif (xprt->bc_xprt) {\n\t\t\txprt_switch_get(xps);\n\t\t\txprt->bc_xprt->xpt_bc_xps = xps;\n\t\t}\n\t}\n\tclnt = rpc_new_client(args, xps, xprt, NULL);\n\tif (IS_ERR(clnt))\n\t\treturn clnt;\n\n\tif (!(args->flags & RPC_CLNT_CREATE_NOPING)) {\n\t\tint err = rpc_ping(clnt);\n\t\tif (err != 0) {\n\t\t\trpc_shutdown_client(clnt);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t} else if (args->flags & RPC_CLNT_CREATE_CONNECTED) {\n\t\tint err = rpc_ping_noreply(clnt);\n\t\tif (err != 0) {\n\t\t\trpc_shutdown_client(clnt);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tclnt->cl_softrtry = 1;\n\tif (args->flags & (RPC_CLNT_CREATE_HARDRTRY|RPC_CLNT_CREATE_SOFTERR)) {\n\t\tclnt->cl_softrtry = 0;\n\t\tif (args->flags & RPC_CLNT_CREATE_SOFTERR)\n\t\t\tclnt->cl_softerr = 1;\n\t}\n\n\tif (args->flags & RPC_CLNT_CREATE_AUTOBIND)\n\t\tclnt->cl_autobind = 1;\n\tif (args->flags & RPC_CLNT_CREATE_NO_RETRANS_TIMEOUT)\n\t\tclnt->cl_noretranstimeo = 1;\n\tif (args->flags & RPC_CLNT_CREATE_DISCRTRY)\n\t\tclnt->cl_discrtry = 1;\n\tif (!(args->flags & RPC_CLNT_CREATE_QUIET))\n\t\tclnt->cl_chatty = 1;\n\n\treturn clnt;\n}\n\n \nstruct rpc_clnt *rpc_create(struct rpc_create_args *args)\n{\n\tstruct rpc_xprt *xprt;\n\tstruct xprt_create xprtargs = {\n\t\t.net = args->net,\n\t\t.ident = args->protocol,\n\t\t.srcaddr = args->saddress,\n\t\t.dstaddr = args->address,\n\t\t.addrlen = args->addrsize,\n\t\t.servername = args->servername,\n\t\t.bc_xprt = args->bc_xprt,\n\t\t.xprtsec = args->xprtsec,\n\t\t.connect_timeout = args->connect_timeout,\n\t\t.reconnect_timeout = args->reconnect_timeout,\n\t};\n\tchar servername[48];\n\tstruct rpc_clnt *clnt;\n\tint i;\n\n\tif (args->bc_xprt) {\n\t\tWARN_ON_ONCE(!(args->protocol & XPRT_TRANSPORT_BC));\n\t\txprt = args->bc_xprt->xpt_bc_xprt;\n\t\tif (xprt) {\n\t\t\txprt_get(xprt);\n\t\t\treturn rpc_create_xprt(args, xprt);\n\t\t}\n\t}\n\n\tif (args->flags & RPC_CLNT_CREATE_INFINITE_SLOTS)\n\t\txprtargs.flags |= XPRT_CREATE_INFINITE_SLOTS;\n\tif (args->flags & RPC_CLNT_CREATE_NO_IDLE_TIMEOUT)\n\t\txprtargs.flags |= XPRT_CREATE_NO_IDLE_TIMEOUT;\n\t \n\tif (xprtargs.servername == NULL) {\n\t\tstruct sockaddr_un *sun =\n\t\t\t\t(struct sockaddr_un *)args->address;\n\t\tstruct sockaddr_in *sin =\n\t\t\t\t(struct sockaddr_in *)args->address;\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t\t(struct sockaddr_in6 *)args->address;\n\n\t\tservername[0] = '\\0';\n\t\tswitch (args->address->sa_family) {\n\t\tcase AF_LOCAL:\n\t\t\tif (sun->sun_path[0])\n\t\t\t\tsnprintf(servername, sizeof(servername), \"%s\",\n\t\t\t\t\t sun->sun_path);\n\t\t\telse\n\t\t\t\tsnprintf(servername, sizeof(servername), \"@%s\",\n\t\t\t\t\t sun->sun_path+1);\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\tsnprintf(servername, sizeof(servername), \"%pI4\",\n\t\t\t\t &sin->sin_addr.s_addr);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\tsnprintf(servername, sizeof(servername), \"%pI6\",\n\t\t\t\t &sin6->sin6_addr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\txprtargs.servername = servername;\n\t}\n\n\txprt = xprt_create_transport(&xprtargs);\n\tif (IS_ERR(xprt))\n\t\treturn (struct rpc_clnt *)xprt;\n\n\t \n\txprt->resvport = 1;\n\tif (args->flags & RPC_CLNT_CREATE_NONPRIVPORT)\n\t\txprt->resvport = 0;\n\txprt->reuseport = 0;\n\tif (args->flags & RPC_CLNT_CREATE_REUSEPORT)\n\t\txprt->reuseport = 1;\n\n\tclnt = rpc_create_xprt(args, xprt);\n\tif (IS_ERR(clnt) || args->nconnect <= 1)\n\t\treturn clnt;\n\n\tfor (i = 0; i < args->nconnect - 1; i++) {\n\t\tif (rpc_clnt_add_xprt(clnt, &xprtargs, NULL, NULL) < 0)\n\t\t\tbreak;\n\t}\n\treturn clnt;\n}\nEXPORT_SYMBOL_GPL(rpc_create);\n\n \nstatic struct rpc_clnt *__rpc_clone_client(struct rpc_create_args *args,\n\t\t\t\t\t   struct rpc_clnt *clnt)\n{\n\tstruct rpc_xprt_switch *xps;\n\tstruct rpc_xprt *xprt;\n\tstruct rpc_clnt *new;\n\tint err;\n\n\terr = -ENOMEM;\n\trcu_read_lock();\n\txprt = xprt_get(rcu_dereference(clnt->cl_xprt));\n\txps = xprt_switch_get(rcu_dereference(clnt->cl_xpi.xpi_xpswitch));\n\trcu_read_unlock();\n\tif (xprt == NULL || xps == NULL) {\n\t\txprt_put(xprt);\n\t\txprt_switch_put(xps);\n\t\tgoto out_err;\n\t}\n\targs->servername = xprt->servername;\n\targs->nodename = clnt->cl_nodename;\n\n\tnew = rpc_new_client(args, xps, xprt, clnt);\n\tif (IS_ERR(new))\n\t\treturn new;\n\n\t \n\tnew->cl_autobind = 0;\n\tnew->cl_softrtry = clnt->cl_softrtry;\n\tnew->cl_softerr = clnt->cl_softerr;\n\tnew->cl_noretranstimeo = clnt->cl_noretranstimeo;\n\tnew->cl_discrtry = clnt->cl_discrtry;\n\tnew->cl_chatty = clnt->cl_chatty;\n\tnew->cl_principal = clnt->cl_principal;\n\tnew->cl_max_connect = clnt->cl_max_connect;\n\treturn new;\n\nout_err:\n\ttrace_rpc_clnt_clone_err(clnt, err);\n\treturn ERR_PTR(err);\n}\n\n \nstruct rpc_clnt *rpc_clone_client(struct rpc_clnt *clnt)\n{\n\tstruct rpc_create_args args = {\n\t\t.program\t= clnt->cl_program,\n\t\t.prognumber\t= clnt->cl_prog,\n\t\t.version\t= clnt->cl_vers,\n\t\t.authflavor\t= clnt->cl_auth->au_flavor,\n\t\t.cred\t\t= clnt->cl_cred,\n\t};\n\treturn __rpc_clone_client(&args, clnt);\n}\nEXPORT_SYMBOL_GPL(rpc_clone_client);\n\n \nstruct rpc_clnt *\nrpc_clone_client_set_auth(struct rpc_clnt *clnt, rpc_authflavor_t flavor)\n{\n\tstruct rpc_create_args args = {\n\t\t.program\t= clnt->cl_program,\n\t\t.prognumber\t= clnt->cl_prog,\n\t\t.version\t= clnt->cl_vers,\n\t\t.authflavor\t= flavor,\n\t\t.cred\t\t= clnt->cl_cred,\n\t};\n\treturn __rpc_clone_client(&args, clnt);\n}\nEXPORT_SYMBOL_GPL(rpc_clone_client_set_auth);\n\n \nint rpc_switch_client_transport(struct rpc_clnt *clnt,\n\t\tstruct xprt_create *args,\n\t\tconst struct rpc_timeout *timeout)\n{\n\tconst struct rpc_timeout *old_timeo;\n\trpc_authflavor_t pseudoflavor;\n\tstruct rpc_xprt_switch *xps, *oldxps;\n\tstruct rpc_xprt *xprt, *old;\n\tstruct rpc_clnt *parent;\n\tint err;\n\n\targs->xprtsec = clnt->cl_xprtsec;\n\txprt = xprt_create_transport(args);\n\tif (IS_ERR(xprt))\n\t\treturn PTR_ERR(xprt);\n\n\txps = xprt_switch_alloc(xprt, GFP_KERNEL);\n\tif (xps == NULL) {\n\t\txprt_put(xprt);\n\t\treturn -ENOMEM;\n\t}\n\n\tpseudoflavor = clnt->cl_auth->au_flavor;\n\n\told_timeo = clnt->cl_timeout;\n\told = rpc_clnt_set_transport(clnt, xprt, timeout);\n\toldxps = xprt_iter_xchg_switch(&clnt->cl_xpi, xps);\n\n\trpc_unregister_client(clnt);\n\t__rpc_clnt_remove_pipedir(clnt);\n\trpc_sysfs_client_destroy(clnt);\n\trpc_clnt_debugfs_unregister(clnt);\n\n\t \n\tparent = clnt->cl_parent;\n\tclnt->cl_parent = clnt;\n\n\t \n\terr = rpc_client_register(clnt, pseudoflavor, NULL);\n\tif (err)\n\t\tgoto out_revert;\n\n\tsynchronize_rcu();\n\tif (parent != clnt)\n\t\trpc_release_client(parent);\n\txprt_switch_put(oldxps);\n\txprt_put(old);\n\ttrace_rpc_clnt_replace_xprt(clnt);\n\treturn 0;\n\nout_revert:\n\txps = xprt_iter_xchg_switch(&clnt->cl_xpi, oldxps);\n\trpc_clnt_set_transport(clnt, old, old_timeo);\n\tclnt->cl_parent = parent;\n\trpc_client_register(clnt, pseudoflavor, NULL);\n\txprt_switch_put(xps);\n\txprt_put(xprt);\n\ttrace_rpc_clnt_replace_xprt_err(clnt);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rpc_switch_client_transport);\n\nstatic\nint _rpc_clnt_xprt_iter_init(struct rpc_clnt *clnt, struct rpc_xprt_iter *xpi,\n\t\t\t     void func(struct rpc_xprt_iter *xpi, struct rpc_xprt_switch *xps))\n{\n\tstruct rpc_xprt_switch *xps;\n\n\trcu_read_lock();\n\txps = xprt_switch_get(rcu_dereference(clnt->cl_xpi.xpi_xpswitch));\n\trcu_read_unlock();\n\tif (xps == NULL)\n\t\treturn -EAGAIN;\n\tfunc(xpi, xps);\n\txprt_switch_put(xps);\n\treturn 0;\n}\n\nstatic\nint rpc_clnt_xprt_iter_init(struct rpc_clnt *clnt, struct rpc_xprt_iter *xpi)\n{\n\treturn _rpc_clnt_xprt_iter_init(clnt, xpi, xprt_iter_init_listall);\n}\n\nstatic\nint rpc_clnt_xprt_iter_offline_init(struct rpc_clnt *clnt,\n\t\t\t\t    struct rpc_xprt_iter *xpi)\n{\n\treturn _rpc_clnt_xprt_iter_init(clnt, xpi, xprt_iter_init_listoffline);\n}\n\n \nint rpc_clnt_iterate_for_each_xprt(struct rpc_clnt *clnt,\n\t\tint (*fn)(struct rpc_clnt *, struct rpc_xprt *, void *),\n\t\tvoid *data)\n{\n\tstruct rpc_xprt_iter xpi;\n\tint ret;\n\n\tret = rpc_clnt_xprt_iter_init(clnt, &xpi);\n\tif (ret)\n\t\treturn ret;\n\tfor (;;) {\n\t\tstruct rpc_xprt *xprt = xprt_iter_get_next(&xpi);\n\n\t\tif (!xprt)\n\t\t\tbreak;\n\t\tret = fn(clnt, xprt, data);\n\t\txprt_put(xprt);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\txprt_iter_destroy(&xpi);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_iterate_for_each_xprt);\n\n \nvoid rpc_killall_tasks(struct rpc_clnt *clnt)\n{\n\tstruct rpc_task\t*rovr;\n\n\n\tif (list_empty(&clnt->cl_tasks))\n\t\treturn;\n\n\t \n\ttrace_rpc_clnt_killall(clnt);\n\tspin_lock(&clnt->cl_lock);\n\tlist_for_each_entry(rovr, &clnt->cl_tasks, tk_task)\n\t\trpc_signal_task(rovr);\n\tspin_unlock(&clnt->cl_lock);\n}\nEXPORT_SYMBOL_GPL(rpc_killall_tasks);\n\n \nunsigned long rpc_cancel_tasks(struct rpc_clnt *clnt, int error,\n\t\t\t       bool (*fnmatch)(const struct rpc_task *,\n\t\t\t\t\t       const void *),\n\t\t\t       const void *data)\n{\n\tstruct rpc_task *task;\n\tunsigned long count = 0;\n\n\tif (list_empty(&clnt->cl_tasks))\n\t\treturn 0;\n\t \n\tspin_lock(&clnt->cl_lock);\n\tlist_for_each_entry(task, &clnt->cl_tasks, tk_task) {\n\t\tif (!RPC_IS_ACTIVATED(task))\n\t\t\tcontinue;\n\t\tif (!fnmatch(task, data))\n\t\t\tcontinue;\n\t\trpc_task_try_cancel(task, error);\n\t\tcount++;\n\t}\n\tspin_unlock(&clnt->cl_lock);\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(rpc_cancel_tasks);\n\nstatic int rpc_clnt_disconnect_xprt(struct rpc_clnt *clnt,\n\t\t\t\t    struct rpc_xprt *xprt, void *dummy)\n{\n\tif (xprt_connected(xprt))\n\t\txprt_force_disconnect(xprt);\n\treturn 0;\n}\n\nvoid rpc_clnt_disconnect(struct rpc_clnt *clnt)\n{\n\trpc_clnt_iterate_for_each_xprt(clnt, rpc_clnt_disconnect_xprt, NULL);\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_disconnect);\n\n \nvoid rpc_shutdown_client(struct rpc_clnt *clnt)\n{\n\tmight_sleep();\n\n\ttrace_rpc_clnt_shutdown(clnt);\n\n\twhile (!list_empty(&clnt->cl_tasks)) {\n\t\trpc_killall_tasks(clnt);\n\t\twait_event_timeout(destroy_wait,\n\t\t\tlist_empty(&clnt->cl_tasks), 1*HZ);\n\t}\n\n\trpc_release_client(clnt);\n}\nEXPORT_SYMBOL_GPL(rpc_shutdown_client);\n\n \nstatic void rpc_free_client_work(struct work_struct *work)\n{\n\tstruct rpc_clnt *clnt = container_of(work, struct rpc_clnt, cl_work);\n\n\ttrace_rpc_clnt_free(clnt);\n\n\t \n\trpc_sysfs_client_destroy(clnt);\n\trpc_clnt_debugfs_unregister(clnt);\n\trpc_free_clid(clnt);\n\trpc_clnt_remove_pipedir(clnt);\n\txprt_put(rcu_dereference_raw(clnt->cl_xprt));\n\n\tkfree(clnt);\n\trpciod_down();\n}\nstatic struct rpc_clnt *\nrpc_free_client(struct rpc_clnt *clnt)\n{\n\tstruct rpc_clnt *parent = NULL;\n\n\ttrace_rpc_clnt_release(clnt);\n\tif (clnt->cl_parent != clnt)\n\t\tparent = clnt->cl_parent;\n\trpc_unregister_client(clnt);\n\trpc_free_iostats(clnt->cl_metrics);\n\tclnt->cl_metrics = NULL;\n\txprt_iter_destroy(&clnt->cl_xpi);\n\tput_cred(clnt->cl_cred);\n\n\tINIT_WORK(&clnt->cl_work, rpc_free_client_work);\n\tschedule_work(&clnt->cl_work);\n\treturn parent;\n}\n\n \nstatic struct rpc_clnt *\nrpc_free_auth(struct rpc_clnt *clnt)\n{\n\t \n\tif (clnt->cl_auth != NULL) {\n\t\trpcauth_release(clnt->cl_auth);\n\t\tclnt->cl_auth = NULL;\n\t}\n\tif (refcount_dec_and_test(&clnt->cl_count))\n\t\treturn rpc_free_client(clnt);\n\treturn NULL;\n}\n\n \nvoid\nrpc_release_client(struct rpc_clnt *clnt)\n{\n\tdo {\n\t\tif (list_empty(&clnt->cl_tasks))\n\t\t\twake_up(&destroy_wait);\n\t\tif (refcount_dec_not_one(&clnt->cl_count))\n\t\t\tbreak;\n\t\tclnt = rpc_free_auth(clnt);\n\t} while (clnt != NULL);\n}\nEXPORT_SYMBOL_GPL(rpc_release_client);\n\n \nstruct rpc_clnt *rpc_bind_new_program(struct rpc_clnt *old,\n\t\t\t\t      const struct rpc_program *program,\n\t\t\t\t      u32 vers)\n{\n\tstruct rpc_create_args args = {\n\t\t.program\t= program,\n\t\t.prognumber\t= program->number,\n\t\t.version\t= vers,\n\t\t.authflavor\t= old->cl_auth->au_flavor,\n\t\t.cred\t\t= old->cl_cred,\n\t};\n\tstruct rpc_clnt *clnt;\n\tint err;\n\n\tclnt = __rpc_clone_client(&args, old);\n\tif (IS_ERR(clnt))\n\t\tgoto out;\n\terr = rpc_ping(clnt);\n\tif (err != 0) {\n\t\trpc_shutdown_client(clnt);\n\t\tclnt = ERR_PTR(err);\n\t}\nout:\n\treturn clnt;\n}\nEXPORT_SYMBOL_GPL(rpc_bind_new_program);\n\nstruct rpc_xprt *\nrpc_task_get_xprt(struct rpc_clnt *clnt, struct rpc_xprt *xprt)\n{\n\tstruct rpc_xprt_switch *xps;\n\n\tif (!xprt)\n\t\treturn NULL;\n\trcu_read_lock();\n\txps = rcu_dereference(clnt->cl_xpi.xpi_xpswitch);\n\tatomic_long_inc(&xps->xps_queuelen);\n\trcu_read_unlock();\n\tatomic_long_inc(&xprt->queuelen);\n\n\treturn xprt;\n}\n\nstatic void\nrpc_task_release_xprt(struct rpc_clnt *clnt, struct rpc_xprt *xprt)\n{\n\tstruct rpc_xprt_switch *xps;\n\n\tatomic_long_dec(&xprt->queuelen);\n\trcu_read_lock();\n\txps = rcu_dereference(clnt->cl_xpi.xpi_xpswitch);\n\tatomic_long_dec(&xps->xps_queuelen);\n\trcu_read_unlock();\n\n\txprt_put(xprt);\n}\n\nvoid rpc_task_release_transport(struct rpc_task *task)\n{\n\tstruct rpc_xprt *xprt = task->tk_xprt;\n\n\tif (xprt) {\n\t\ttask->tk_xprt = NULL;\n\t\tif (task->tk_client)\n\t\t\trpc_task_release_xprt(task->tk_client, xprt);\n\t\telse\n\t\t\txprt_put(xprt);\n\t}\n}\nEXPORT_SYMBOL_GPL(rpc_task_release_transport);\n\nvoid rpc_task_release_client(struct rpc_task *task)\n{\n\tstruct rpc_clnt *clnt = task->tk_client;\n\n\trpc_task_release_transport(task);\n\tif (clnt != NULL) {\n\t\t \n\t\tspin_lock(&clnt->cl_lock);\n\t\tlist_del(&task->tk_task);\n\t\tspin_unlock(&clnt->cl_lock);\n\t\ttask->tk_client = NULL;\n\n\t\trpc_release_client(clnt);\n\t}\n}\n\nstatic struct rpc_xprt *\nrpc_task_get_first_xprt(struct rpc_clnt *clnt)\n{\n\tstruct rpc_xprt *xprt;\n\n\trcu_read_lock();\n\txprt = xprt_get(rcu_dereference(clnt->cl_xprt));\n\trcu_read_unlock();\n\treturn rpc_task_get_xprt(clnt, xprt);\n}\n\nstatic struct rpc_xprt *\nrpc_task_get_next_xprt(struct rpc_clnt *clnt)\n{\n\treturn rpc_task_get_xprt(clnt, xprt_iter_get_next(&clnt->cl_xpi));\n}\n\nstatic\nvoid rpc_task_set_transport(struct rpc_task *task, struct rpc_clnt *clnt)\n{\n\tif (task->tk_xprt) {\n\t\tif (!(test_bit(XPRT_OFFLINE, &task->tk_xprt->state) &&\n\t\t      (task->tk_flags & RPC_TASK_MOVEABLE)))\n\t\t\treturn;\n\t\txprt_release(task);\n\t\txprt_put(task->tk_xprt);\n\t}\n\tif (task->tk_flags & RPC_TASK_NO_ROUND_ROBIN)\n\t\ttask->tk_xprt = rpc_task_get_first_xprt(clnt);\n\telse\n\t\ttask->tk_xprt = rpc_task_get_next_xprt(clnt);\n}\n\nstatic\nvoid rpc_task_set_client(struct rpc_task *task, struct rpc_clnt *clnt)\n{\n\trpc_task_set_transport(task, clnt);\n\ttask->tk_client = clnt;\n\trefcount_inc(&clnt->cl_count);\n\tif (clnt->cl_softrtry)\n\t\ttask->tk_flags |= RPC_TASK_SOFT;\n\tif (clnt->cl_softerr)\n\t\ttask->tk_flags |= RPC_TASK_TIMEOUT;\n\tif (clnt->cl_noretranstimeo)\n\t\ttask->tk_flags |= RPC_TASK_NO_RETRANS_TIMEOUT;\n\t \n\tspin_lock(&clnt->cl_lock);\n\tlist_add_tail(&task->tk_task, &clnt->cl_tasks);\n\tspin_unlock(&clnt->cl_lock);\n}\n\nstatic void\nrpc_task_set_rpc_message(struct rpc_task *task, const struct rpc_message *msg)\n{\n\tif (msg != NULL) {\n\t\ttask->tk_msg.rpc_proc = msg->rpc_proc;\n\t\ttask->tk_msg.rpc_argp = msg->rpc_argp;\n\t\ttask->tk_msg.rpc_resp = msg->rpc_resp;\n\t\ttask->tk_msg.rpc_cred = msg->rpc_cred;\n\t\tif (!(task->tk_flags & RPC_TASK_CRED_NOREF))\n\t\t\tget_cred(task->tk_msg.rpc_cred);\n\t}\n}\n\n \nstatic void\nrpc_default_callback(struct rpc_task *task, void *data)\n{\n}\n\nstatic const struct rpc_call_ops rpc_default_ops = {\n\t.rpc_call_done = rpc_default_callback,\n};\n\n \nstruct rpc_task *rpc_run_task(const struct rpc_task_setup *task_setup_data)\n{\n\tstruct rpc_task *task;\n\n\ttask = rpc_new_task(task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn task;\n\n\tif (!RPC_IS_ASYNC(task))\n\t\ttask->tk_flags |= RPC_TASK_CRED_NOREF;\n\n\trpc_task_set_client(task, task_setup_data->rpc_client);\n\trpc_task_set_rpc_message(task, task_setup_data->rpc_message);\n\n\tif (task->tk_action == NULL)\n\t\trpc_call_start(task);\n\n\tatomic_inc(&task->tk_count);\n\trpc_execute(task);\n\treturn task;\n}\nEXPORT_SYMBOL_GPL(rpc_run_task);\n\n \nint rpc_call_sync(struct rpc_clnt *clnt, const struct rpc_message *msg, int flags)\n{\n\tstruct rpc_task\t*task;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = msg,\n\t\t.callback_ops = &rpc_default_ops,\n\t\t.flags = flags,\n\t};\n\tint status;\n\n\tWARN_ON_ONCE(flags & RPC_TASK_ASYNC);\n\tif (flags & RPC_TASK_ASYNC) {\n\t\trpc_release_calldata(task_setup_data.callback_ops,\n\t\t\ttask_setup_data.callback_data);\n\t\treturn -EINVAL;\n\t}\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = task->tk_status;\n\trpc_put_task(task);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(rpc_call_sync);\n\n \nint\nrpc_call_async(struct rpc_clnt *clnt, const struct rpc_message *msg, int flags,\n\t       const struct rpc_call_ops *tk_ops, void *data)\n{\n\tstruct rpc_task\t*task;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = msg,\n\t\t.callback_ops = tk_ops,\n\t\t.callback_data = data,\n\t\t.flags = flags|RPC_TASK_ASYNC,\n\t};\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\trpc_put_task(task);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rpc_call_async);\n\n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\nstatic void call_bc_encode(struct rpc_task *task);\n\n \nstruct rpc_task *rpc_run_bc_task(struct rpc_rqst *req)\n{\n\tstruct rpc_task *task;\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.callback_ops = &rpc_default_ops,\n\t\t.flags = RPC_TASK_SOFTCONN |\n\t\t\tRPC_TASK_NO_RETRANS_TIMEOUT,\n\t};\n\n\tdprintk(\"RPC: rpc_run_bc_task req= %p\\n\", req);\n\t \n\ttask = rpc_new_task(&task_setup_data);\n\tif (IS_ERR(task)) {\n\t\txprt_free_bc_request(req);\n\t\treturn task;\n\t}\n\n\txprt_init_bc_request(req, task);\n\n\ttask->tk_action = call_bc_encode;\n\tatomic_inc(&task->tk_count);\n\tWARN_ON_ONCE(atomic_read(&task->tk_count) != 2);\n\trpc_execute(task);\n\n\tdprintk(\"RPC: rpc_run_bc_task: task= %p\\n\", task);\n\treturn task;\n}\n#endif  \n\n \nvoid rpc_prepare_reply_pages(struct rpc_rqst *req, struct page **pages,\n\t\t\t     unsigned int base, unsigned int len,\n\t\t\t     unsigned int hdrsize)\n{\n\thdrsize += RPC_REPHDRSIZE + req->rq_cred->cr_auth->au_ralign;\n\n\txdr_inline_pages(&req->rq_rcv_buf, hdrsize << 2, pages, base, len);\n\ttrace_rpc_xdr_reply_pages(req->rq_task, &req->rq_rcv_buf);\n}\nEXPORT_SYMBOL_GPL(rpc_prepare_reply_pages);\n\nvoid\nrpc_call_start(struct rpc_task *task)\n{\n\ttask->tk_action = call_start;\n}\nEXPORT_SYMBOL_GPL(rpc_call_start);\n\n \nsize_t rpc_peeraddr(struct rpc_clnt *clnt, struct sockaddr *buf, size_t bufsize)\n{\n\tsize_t bytes;\n\tstruct rpc_xprt *xprt;\n\n\trcu_read_lock();\n\txprt = rcu_dereference(clnt->cl_xprt);\n\n\tbytes = xprt->addrlen;\n\tif (bytes > bufsize)\n\t\tbytes = bufsize;\n\tmemcpy(buf, &xprt->addr, bytes);\n\trcu_read_unlock();\n\n\treturn bytes;\n}\nEXPORT_SYMBOL_GPL(rpc_peeraddr);\n\n \nconst char *rpc_peeraddr2str(struct rpc_clnt *clnt,\n\t\t\t     enum rpc_display_format_t format)\n{\n\tstruct rpc_xprt *xprt;\n\n\txprt = rcu_dereference(clnt->cl_xprt);\n\n\tif (xprt->address_strings[format] != NULL)\n\t\treturn xprt->address_strings[format];\n\telse\n\t\treturn \"unprintable\";\n}\nEXPORT_SYMBOL_GPL(rpc_peeraddr2str);\n\nstatic const struct sockaddr_in rpc_inaddr_loopback = {\n\t.sin_family\t\t= AF_INET,\n\t.sin_addr.s_addr\t= htonl(INADDR_ANY),\n};\n\nstatic const struct sockaddr_in6 rpc_in6addr_loopback = {\n\t.sin6_family\t\t= AF_INET6,\n\t.sin6_addr\t\t= IN6ADDR_ANY_INIT,\n};\n\n \nstatic int rpc_sockname(struct net *net, struct sockaddr *sap, size_t salen,\n\t\t\tstruct sockaddr *buf)\n{\n\tstruct socket *sock;\n\tint err;\n\n\terr = __sock_create(net, sap->sa_family,\n\t\t\t\tSOCK_DGRAM, IPPROTO_UDP, &sock, 1);\n\tif (err < 0) {\n\t\tdprintk(\"RPC:       can't create UDP socket (%d)\\n\", err);\n\t\tgoto out;\n\t}\n\n\tswitch (sap->sa_family) {\n\tcase AF_INET:\n\t\terr = kernel_bind(sock,\n\t\t\t\t(struct sockaddr *)&rpc_inaddr_loopback,\n\t\t\t\tsizeof(rpc_inaddr_loopback));\n\t\tbreak;\n\tcase AF_INET6:\n\t\terr = kernel_bind(sock,\n\t\t\t\t(struct sockaddr *)&rpc_in6addr_loopback,\n\t\t\t\tsizeof(rpc_in6addr_loopback));\n\t\tbreak;\n\tdefault:\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto out_release;\n\t}\n\tif (err < 0) {\n\t\tdprintk(\"RPC:       can't bind UDP socket (%d)\\n\", err);\n\t\tgoto out_release;\n\t}\n\n\terr = kernel_connect(sock, sap, salen, 0);\n\tif (err < 0) {\n\t\tdprintk(\"RPC:       can't connect UDP socket (%d)\\n\", err);\n\t\tgoto out_release;\n\t}\n\n\terr = kernel_getsockname(sock, buf);\n\tif (err < 0) {\n\t\tdprintk(\"RPC:       getsockname failed (%d)\\n\", err);\n\t\tgoto out_release;\n\t}\n\n\terr = 0;\n\tif (buf->sa_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)buf;\n\t\tsin6->sin6_scope_id = 0;\n\t}\n\tdprintk(\"RPC:       %s succeeded\\n\", __func__);\n\nout_release:\n\tsock_release(sock);\nout:\n\treturn err;\n}\n\n \nstatic int rpc_anyaddr(int family, struct sockaddr *buf, size_t buflen)\n{\n\tswitch (family) {\n\tcase AF_INET:\n\t\tif (buflen < sizeof(rpc_inaddr_loopback))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(buf, &rpc_inaddr_loopback,\n\t\t\t\tsizeof(rpc_inaddr_loopback));\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (buflen < sizeof(rpc_in6addr_loopback))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(buf, &rpc_in6addr_loopback,\n\t\t\t\tsizeof(rpc_in6addr_loopback));\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"RPC:       %s: address family not supported\\n\",\n\t\t\t__func__);\n\t\treturn -EAFNOSUPPORT;\n\t}\n\tdprintk(\"RPC:       %s: succeeded\\n\", __func__);\n\treturn 0;\n}\n\n \nint rpc_localaddr(struct rpc_clnt *clnt, struct sockaddr *buf, size_t buflen)\n{\n\tstruct sockaddr_storage address;\n\tstruct sockaddr *sap = (struct sockaddr *)&address;\n\tstruct rpc_xprt *xprt;\n\tstruct net *net;\n\tsize_t salen;\n\tint err;\n\n\trcu_read_lock();\n\txprt = rcu_dereference(clnt->cl_xprt);\n\tsalen = xprt->addrlen;\n\tmemcpy(sap, &xprt->addr, salen);\n\tnet = get_net(xprt->xprt_net);\n\trcu_read_unlock();\n\n\trpc_set_port(sap, 0);\n\terr = rpc_sockname(net, sap, salen, buf);\n\tput_net(net);\n\tif (err != 0)\n\t\t \n\t\treturn rpc_anyaddr(sap->sa_family, buf, buflen);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rpc_localaddr);\n\nvoid\nrpc_setbufsize(struct rpc_clnt *clnt, unsigned int sndsize, unsigned int rcvsize)\n{\n\tstruct rpc_xprt *xprt;\n\n\trcu_read_lock();\n\txprt = rcu_dereference(clnt->cl_xprt);\n\tif (xprt->ops->set_buffer_size)\n\t\txprt->ops->set_buffer_size(xprt, sndsize, rcvsize);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(rpc_setbufsize);\n\n \nstruct net *rpc_net_ns(struct rpc_clnt *clnt)\n{\n\tstruct net *ret;\n\n\trcu_read_lock();\n\tret = rcu_dereference(clnt->cl_xprt)->xprt_net;\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rpc_net_ns);\n\n \nsize_t rpc_max_payload(struct rpc_clnt *clnt)\n{\n\tsize_t ret;\n\n\trcu_read_lock();\n\tret = rcu_dereference(clnt->cl_xprt)->max_payload;\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rpc_max_payload);\n\n \nsize_t rpc_max_bc_payload(struct rpc_clnt *clnt)\n{\n\tstruct rpc_xprt *xprt;\n\tsize_t ret;\n\n\trcu_read_lock();\n\txprt = rcu_dereference(clnt->cl_xprt);\n\tret = xprt->ops->bc_maxpayload(xprt);\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rpc_max_bc_payload);\n\nunsigned int rpc_num_bc_slots(struct rpc_clnt *clnt)\n{\n\tstruct rpc_xprt *xprt;\n\tunsigned int ret;\n\n\trcu_read_lock();\n\txprt = rcu_dereference(clnt->cl_xprt);\n\tret = xprt->ops->bc_num_slots(xprt);\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rpc_num_bc_slots);\n\n \nvoid rpc_force_rebind(struct rpc_clnt *clnt)\n{\n\tif (clnt->cl_autobind) {\n\t\trcu_read_lock();\n\t\txprt_clear_bound(rcu_dereference(clnt->cl_xprt));\n\t\trcu_read_unlock();\n\t}\n}\nEXPORT_SYMBOL_GPL(rpc_force_rebind);\n\nstatic int\n__rpc_restart_call(struct rpc_task *task, void (*action)(struct rpc_task *))\n{\n\ttask->tk_status = 0;\n\ttask->tk_rpc_status = 0;\n\ttask->tk_action = action;\n\treturn 1;\n}\n\n \nint\nrpc_restart_call(struct rpc_task *task)\n{\n\treturn __rpc_restart_call(task, call_start);\n}\nEXPORT_SYMBOL_GPL(rpc_restart_call);\n\n \nint\nrpc_restart_call_prepare(struct rpc_task *task)\n{\n\tif (task->tk_ops->rpc_call_prepare != NULL)\n\t\treturn __rpc_restart_call(task, rpc_prepare_task);\n\treturn rpc_restart_call(task);\n}\nEXPORT_SYMBOL_GPL(rpc_restart_call_prepare);\n\nconst char\n*rpc_proc_name(const struct rpc_task *task)\n{\n\tconst struct rpc_procinfo *proc = task->tk_msg.rpc_proc;\n\n\tif (proc) {\n\t\tif (proc->p_name)\n\t\t\treturn proc->p_name;\n\t\telse\n\t\t\treturn \"NULL\";\n\t} else\n\t\treturn \"no proc\";\n}\n\nstatic void\n__rpc_call_rpcerror(struct rpc_task *task, int tk_status, int rpc_status)\n{\n\ttrace_rpc_call_rpcerror(task, tk_status, rpc_status);\n\trpc_task_set_rpc_status(task, rpc_status);\n\trpc_exit(task, tk_status);\n}\n\nstatic void\nrpc_call_rpcerror(struct rpc_task *task, int status)\n{\n\t__rpc_call_rpcerror(task, status, status);\n}\n\n \nstatic void\ncall_start(struct rpc_task *task)\n{\n\tstruct rpc_clnt\t*clnt = task->tk_client;\n\tint idx = task->tk_msg.rpc_proc->p_statidx;\n\n\ttrace_rpc_request(task);\n\n\tif (task->tk_client->cl_shutdown) {\n\t\trpc_call_rpcerror(task, -EIO);\n\t\treturn;\n\t}\n\n\t \n\tif (clnt->cl_program->version[clnt->cl_vers])\n\t\tclnt->cl_program->version[clnt->cl_vers]->counts[idx]++;\n\tclnt->cl_stats->rpccnt++;\n\ttask->tk_action = call_reserve;\n\trpc_task_set_transport(task, clnt);\n}\n\n \nstatic void\ncall_reserve(struct rpc_task *task)\n{\n\ttask->tk_status  = 0;\n\ttask->tk_action  = call_reserveresult;\n\txprt_reserve(task);\n}\n\nstatic void call_retry_reserve(struct rpc_task *task);\n\n \nstatic void\ncall_reserveresult(struct rpc_task *task)\n{\n\tint status = task->tk_status;\n\n\t \n\ttask->tk_status = 0;\n\tif (status >= 0) {\n\t\tif (task->tk_rqstp) {\n\t\t\ttask->tk_action = call_refresh;\n\t\t\treturn;\n\t\t}\n\n\t\trpc_call_rpcerror(task, -EIO);\n\t\treturn;\n\t}\n\n\tswitch (status) {\n\tcase -ENOMEM:\n\t\trpc_delay(task, HZ >> 2);\n\t\tfallthrough;\n\tcase -EAGAIN:\t \n\t\ttask->tk_action = call_retry_reserve;\n\t\treturn;\n\tdefault:\n\t\trpc_call_rpcerror(task, status);\n\t}\n}\n\n \nstatic void\ncall_retry_reserve(struct rpc_task *task)\n{\n\ttask->tk_status  = 0;\n\ttask->tk_action  = call_reserveresult;\n\txprt_retry_reserve(task);\n}\n\n \nstatic void\ncall_refresh(struct rpc_task *task)\n{\n\ttask->tk_action = call_refreshresult;\n\ttask->tk_status = 0;\n\ttask->tk_client->cl_stats->rpcauthrefresh++;\n\trpcauth_refreshcred(task);\n}\n\n \nstatic void\ncall_refreshresult(struct rpc_task *task)\n{\n\tint status = task->tk_status;\n\n\ttask->tk_status = 0;\n\ttask->tk_action = call_refresh;\n\tswitch (status) {\n\tcase 0:\n\t\tif (rpcauth_uptodatecred(task)) {\n\t\t\ttask->tk_action = call_allocate;\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tfallthrough;\n\tcase -ETIMEDOUT:\n\t\trpc_delay(task, 3*HZ);\n\t\tfallthrough;\n\tcase -EAGAIN:\n\t\tstatus = -EACCES;\n\t\tfallthrough;\n\tcase -EKEYEXPIRED:\n\t\tif (!task->tk_cred_retry)\n\t\t\tbreak;\n\t\ttask->tk_cred_retry--;\n\t\ttrace_rpc_retry_refresh_status(task);\n\t\treturn;\n\tcase -ENOMEM:\n\t\trpc_delay(task, HZ >> 4);\n\t\treturn;\n\t}\n\ttrace_rpc_refresh_status(task);\n\trpc_call_rpcerror(task, status);\n}\n\n \nstatic void\ncall_allocate(struct rpc_task *task)\n{\n\tconst struct rpc_auth *auth = task->tk_rqstp->rq_cred->cr_auth;\n\tstruct rpc_rqst *req = task->tk_rqstp;\n\tstruct rpc_xprt *xprt = req->rq_xprt;\n\tconst struct rpc_procinfo *proc = task->tk_msg.rpc_proc;\n\tint status;\n\n\ttask->tk_status = 0;\n\ttask->tk_action = call_encode;\n\n\tif (req->rq_buffer)\n\t\treturn;\n\n\tif (proc->p_proc != 0) {\n\t\tBUG_ON(proc->p_arglen == 0);\n\t\tif (proc->p_decode != NULL)\n\t\t\tBUG_ON(proc->p_replen == 0);\n\t}\n\n\t \n\treq->rq_callsize = RPC_CALLHDRSIZE + (auth->au_cslack << 1) +\n\t\t\t   proc->p_arglen;\n\treq->rq_callsize <<= 2;\n\t \n\treq->rq_rcvsize = RPC_REPHDRSIZE + auth->au_rslack + \\\n\t\t\tmax_t(size_t, proc->p_replen, 2);\n\treq->rq_rcvsize <<= 2;\n\n\tstatus = xprt->ops->buf_alloc(task);\n\ttrace_rpc_buf_alloc(task, status);\n\tif (status == 0)\n\t\treturn;\n\tif (status != -ENOMEM) {\n\t\trpc_call_rpcerror(task, status);\n\t\treturn;\n\t}\n\n\tif (RPC_IS_ASYNC(task) || !fatal_signal_pending(current)) {\n\t\ttask->tk_action = call_allocate;\n\t\trpc_delay(task, HZ>>4);\n\t\treturn;\n\t}\n\n\trpc_call_rpcerror(task, -ERESTARTSYS);\n}\n\nstatic int\nrpc_task_need_encode(struct rpc_task *task)\n{\n\treturn test_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate) == 0 &&\n\t\t(!(task->tk_flags & RPC_TASK_SENT) ||\n\t\t !(task->tk_flags & RPC_TASK_NO_RETRANS_TIMEOUT) ||\n\t\t xprt_request_need_retransmit(task));\n}\n\nstatic void\nrpc_xdr_encode(struct rpc_task *task)\n{\n\tstruct rpc_rqst\t*req = task->tk_rqstp;\n\tstruct xdr_stream xdr;\n\n\txdr_buf_init(&req->rq_snd_buf,\n\t\t     req->rq_buffer,\n\t\t     req->rq_callsize);\n\txdr_buf_init(&req->rq_rcv_buf,\n\t\t     req->rq_rbuffer,\n\t\t     req->rq_rcvsize);\n\n\treq->rq_reply_bytes_recvd = 0;\n\treq->rq_snd_buf.head[0].iov_len = 0;\n\txdr_init_encode(&xdr, &req->rq_snd_buf,\n\t\t\treq->rq_snd_buf.head[0].iov_base, req);\n\tif (rpc_encode_header(task, &xdr))\n\t\treturn;\n\n\ttask->tk_status = rpcauth_wrap_req(task, &xdr);\n}\n\n \nstatic void\ncall_encode(struct rpc_task *task)\n{\n\tif (!rpc_task_need_encode(task))\n\t\tgoto out;\n\n\t \n\txprt_request_dequeue_xprt(task);\n\t \n\trpc_xdr_encode(task);\n\t \n\tif (task->tk_status == 0 && rpc_reply_expected(task))\n\t\ttask->tk_status = xprt_request_enqueue_receive(task);\n\t \n\tif (task->tk_status != 0) {\n\t\t \n\t\tswitch (task->tk_status) {\n\t\tcase -EAGAIN:\n\t\tcase -ENOMEM:\n\t\t\trpc_delay(task, HZ >> 4);\n\t\t\tbreak;\n\t\tcase -EKEYEXPIRED:\n\t\t\tif (!task->tk_cred_retry) {\n\t\t\t\trpc_call_rpcerror(task, task->tk_status);\n\t\t\t} else {\n\t\t\t\ttask->tk_action = call_refresh;\n\t\t\t\ttask->tk_cred_retry--;\n\t\t\t\ttrace_rpc_retry_refresh_status(task);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trpc_call_rpcerror(task, task->tk_status);\n\t\t}\n\t\treturn;\n\t}\n\n\txprt_request_enqueue_transmit(task);\nout:\n\ttask->tk_action = call_transmit;\n\t \n\tif (!xprt_bound(task->tk_xprt))\n\t\ttask->tk_action = call_bind;\n\telse if (!xprt_connected(task->tk_xprt))\n\t\ttask->tk_action = call_connect;\n}\n\n \nstatic bool\nrpc_task_transmitted(struct rpc_task *task)\n{\n\treturn !test_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate);\n}\n\nstatic void\nrpc_task_handle_transmitted(struct rpc_task *task)\n{\n\txprt_end_transmit(task);\n\ttask->tk_action = call_transmit_status;\n}\n\n \nstatic void\ncall_bind(struct rpc_task *task)\n{\n\tstruct rpc_xprt *xprt = task->tk_rqstp->rq_xprt;\n\n\tif (rpc_task_transmitted(task)) {\n\t\trpc_task_handle_transmitted(task);\n\t\treturn;\n\t}\n\n\tif (xprt_bound(xprt)) {\n\t\ttask->tk_action = call_connect;\n\t\treturn;\n\t}\n\n\ttask->tk_action = call_bind_status;\n\tif (!xprt_prepare_transmit(task))\n\t\treturn;\n\n\txprt->ops->rpcbind(task);\n}\n\n \nstatic void\ncall_bind_status(struct rpc_task *task)\n{\n\tstruct rpc_xprt *xprt = task->tk_rqstp->rq_xprt;\n\tint status = -EIO;\n\n\tif (rpc_task_transmitted(task)) {\n\t\trpc_task_handle_transmitted(task);\n\t\treturn;\n\t}\n\n\tif (task->tk_status >= 0)\n\t\tgoto out_next;\n\tif (xprt_bound(xprt)) {\n\t\ttask->tk_status = 0;\n\t\tgoto out_next;\n\t}\n\n\tswitch (task->tk_status) {\n\tcase -ENOMEM:\n\t\trpc_delay(task, HZ >> 2);\n\t\tgoto retry_timeout;\n\tcase -EACCES:\n\t\ttrace_rpcb_prog_unavail_err(task);\n\t\t \n\t\tif (task->tk_msg.rpc_proc->p_proc == 0) {\n\t\t\tstatus = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\trpc_delay(task, 3*HZ);\n\t\tgoto retry_timeout;\n\tcase -ENOBUFS:\n\t\trpc_delay(task, HZ >> 2);\n\t\tgoto retry_timeout;\n\tcase -EAGAIN:\n\t\tgoto retry_timeout;\n\tcase -ETIMEDOUT:\n\t\ttrace_rpcb_timeout_err(task);\n\t\tgoto retry_timeout;\n\tcase -EPFNOSUPPORT:\n\t\t \n\t\ttrace_rpcb_bind_version_err(task);\n\t\tbreak;\n\tcase -EPROTONOSUPPORT:\n\t\ttrace_rpcb_bind_version_err(task);\n\t\tgoto retry_timeout;\n\tcase -ECONNREFUSED:\t\t \n\tcase -ECONNRESET:\n\tcase -ECONNABORTED:\n\tcase -ENOTCONN:\n\tcase -EHOSTDOWN:\n\tcase -ENETDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EPIPE:\n\t\ttrace_rpcb_unreachable_err(task);\n\t\tif (!RPC_IS_SOFTCONN(task)) {\n\t\t\trpc_delay(task, 5*HZ);\n\t\t\tgoto retry_timeout;\n\t\t}\n\t\tstatus = task->tk_status;\n\t\tbreak;\n\tdefault:\n\t\ttrace_rpcb_unrecognized_err(task);\n\t}\n\n\trpc_call_rpcerror(task, status);\n\treturn;\nout_next:\n\ttask->tk_action = call_connect;\n\treturn;\nretry_timeout:\n\ttask->tk_status = 0;\n\ttask->tk_action = call_bind;\n\trpc_check_timeout(task);\n}\n\n \nstatic void\ncall_connect(struct rpc_task *task)\n{\n\tstruct rpc_xprt *xprt = task->tk_rqstp->rq_xprt;\n\n\tif (rpc_task_transmitted(task)) {\n\t\trpc_task_handle_transmitted(task);\n\t\treturn;\n\t}\n\n\tif (xprt_connected(xprt)) {\n\t\ttask->tk_action = call_transmit;\n\t\treturn;\n\t}\n\n\ttask->tk_action = call_connect_status;\n\tif (task->tk_status < 0)\n\t\treturn;\n\tif (task->tk_flags & RPC_TASK_NOCONNECT) {\n\t\trpc_call_rpcerror(task, -ENOTCONN);\n\t\treturn;\n\t}\n\tif (!xprt_prepare_transmit(task))\n\t\treturn;\n\txprt_connect(task);\n}\n\n \nstatic void\ncall_connect_status(struct rpc_task *task)\n{\n\tstruct rpc_xprt *xprt = task->tk_rqstp->rq_xprt;\n\tstruct rpc_clnt *clnt = task->tk_client;\n\tint status = task->tk_status;\n\n\tif (rpc_task_transmitted(task)) {\n\t\trpc_task_handle_transmitted(task);\n\t\treturn;\n\t}\n\n\ttrace_rpc_connect_status(task);\n\n\tif (task->tk_status == 0) {\n\t\tclnt->cl_stats->netreconn++;\n\t\tgoto out_next;\n\t}\n\tif (xprt_connected(xprt)) {\n\t\ttask->tk_status = 0;\n\t\tgoto out_next;\n\t}\n\n\ttask->tk_status = 0;\n\tswitch (status) {\n\tcase -ECONNREFUSED:\n\tcase -ECONNRESET:\n\t\t \n\t\tif (RPC_IS_SOFTCONN(task))\n\t\t\tbreak;\n\t\tif (clnt->cl_autobind) {\n\t\t\trpc_force_rebind(clnt);\n\t\t\tgoto out_retry;\n\t\t}\n\t\tfallthrough;\n\tcase -ECONNABORTED:\n\tcase -ENETDOWN:\n\tcase -ENETUNREACH:\n\tcase -EHOSTUNREACH:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\t\txprt_conditional_disconnect(task->tk_rqstp->rq_xprt,\n\t\t\t\t\t    task->tk_rqstp->rq_connect_cookie);\n\t\tif (RPC_IS_SOFTCONN(task))\n\t\t\tbreak;\n\t\t \n\t\trpc_delay(task, 3*HZ);\n\t\tfallthrough;\n\tcase -EADDRINUSE:\n\tcase -ENOTCONN:\n\tcase -EAGAIN:\n\tcase -ETIMEDOUT:\n\t\tif (!(task->tk_flags & RPC_TASK_NO_ROUND_ROBIN) &&\n\t\t    (task->tk_flags & RPC_TASK_MOVEABLE) &&\n\t\t    test_bit(XPRT_REMOVE, &xprt->state)) {\n\t\t\tstruct rpc_xprt *saved = task->tk_xprt;\n\t\t\tstruct rpc_xprt_switch *xps;\n\n\t\t\trcu_read_lock();\n\t\t\txps = xprt_switch_get(rcu_dereference(clnt->cl_xpi.xpi_xpswitch));\n\t\t\trcu_read_unlock();\n\t\t\tif (xps->xps_nxprts > 1) {\n\t\t\t\tlong value;\n\n\t\t\t\txprt_release(task);\n\t\t\t\tvalue = atomic_long_dec_return(&xprt->queuelen);\n\t\t\t\tif (value == 0)\n\t\t\t\t\trpc_xprt_switch_remove_xprt(xps, saved,\n\t\t\t\t\t\t\t\t    true);\n\t\t\t\txprt_put(saved);\n\t\t\t\ttask->tk_xprt = NULL;\n\t\t\t\ttask->tk_action = call_start;\n\t\t\t}\n\t\t\txprt_switch_put(xps);\n\t\t\tif (!task->tk_xprt)\n\t\t\t\treturn;\n\t\t}\n\t\tgoto out_retry;\n\tcase -ENOBUFS:\n\t\trpc_delay(task, HZ >> 2);\n\t\tgoto out_retry;\n\t}\n\trpc_call_rpcerror(task, status);\n\treturn;\nout_next:\n\ttask->tk_action = call_transmit;\n\treturn;\nout_retry:\n\t \n\ttask->tk_action = call_bind;\n\trpc_check_timeout(task);\n}\n\n \nstatic void\ncall_transmit(struct rpc_task *task)\n{\n\tif (rpc_task_transmitted(task)) {\n\t\trpc_task_handle_transmitted(task);\n\t\treturn;\n\t}\n\n\ttask->tk_action = call_transmit_status;\n\tif (!xprt_prepare_transmit(task))\n\t\treturn;\n\ttask->tk_status = 0;\n\tif (test_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate)) {\n\t\tif (!xprt_connected(task->tk_xprt)) {\n\t\t\ttask->tk_status = -ENOTCONN;\n\t\t\treturn;\n\t\t}\n\t\txprt_transmit(task);\n\t}\n\txprt_end_transmit(task);\n}\n\n \nstatic void\ncall_transmit_status(struct rpc_task *task)\n{\n\ttask->tk_action = call_status;\n\n\t \n\tif (rpc_task_transmitted(task)) {\n\t\ttask->tk_status = 0;\n\t\txprt_request_wait_receive(task);\n\t\treturn;\n\t}\n\n\tswitch (task->tk_status) {\n\tdefault:\n\t\tbreak;\n\tcase -EBADMSG:\n\t\ttask->tk_status = 0;\n\t\ttask->tk_action = call_encode;\n\t\tbreak;\n\t\t \n\tcase -ENOMEM:\n\tcase -ENOBUFS:\n\t\trpc_delay(task, HZ>>2);\n\t\tfallthrough;\n\tcase -EBADSLT:\n\tcase -EAGAIN:\n\t\ttask->tk_action = call_transmit;\n\t\ttask->tk_status = 0;\n\t\tbreak;\n\tcase -ECONNREFUSED:\n\tcase -EHOSTDOWN:\n\tcase -ENETDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EPERM:\n\t\tif (RPC_IS_SOFTCONN(task)) {\n\t\t\tif (!task->tk_msg.rpc_proc->p_proc)\n\t\t\t\ttrace_xprt_ping(task->tk_xprt,\n\t\t\t\t\t\ttask->tk_status);\n\t\t\trpc_call_rpcerror(task, task->tk_status);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase -ECONNRESET:\n\tcase -ECONNABORTED:\n\tcase -EADDRINUSE:\n\tcase -ENOTCONN:\n\tcase -EPIPE:\n\t\ttask->tk_action = call_bind;\n\t\ttask->tk_status = 0;\n\t\tbreak;\n\t}\n\trpc_check_timeout(task);\n}\n\n#if defined(CONFIG_SUNRPC_BACKCHANNEL)\nstatic void call_bc_transmit(struct rpc_task *task);\nstatic void call_bc_transmit_status(struct rpc_task *task);\n\nstatic void\ncall_bc_encode(struct rpc_task *task)\n{\n\txprt_request_enqueue_transmit(task);\n\ttask->tk_action = call_bc_transmit;\n}\n\n \nstatic void\ncall_bc_transmit(struct rpc_task *task)\n{\n\ttask->tk_action = call_bc_transmit_status;\n\tif (test_bit(RPC_TASK_NEED_XMIT, &task->tk_runstate)) {\n\t\tif (!xprt_prepare_transmit(task))\n\t\t\treturn;\n\t\ttask->tk_status = 0;\n\t\txprt_transmit(task);\n\t}\n\txprt_end_transmit(task);\n}\n\nstatic void\ncall_bc_transmit_status(struct rpc_task *task)\n{\n\tstruct rpc_rqst *req = task->tk_rqstp;\n\n\tif (rpc_task_transmitted(task))\n\t\ttask->tk_status = 0;\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\t \n\tcase -ENETDOWN:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -ECONNRESET:\n\tcase -ECONNREFUSED:\n\tcase -EADDRINUSE:\n\tcase -ENOTCONN:\n\tcase -EPIPE:\n\t\tbreak;\n\tcase -ENOMEM:\n\tcase -ENOBUFS:\n\t\trpc_delay(task, HZ>>2);\n\t\tfallthrough;\n\tcase -EBADSLT:\n\tcase -EAGAIN:\n\t\ttask->tk_status = 0;\n\t\ttask->tk_action = call_bc_transmit;\n\t\treturn;\n\tcase -ETIMEDOUT:\n\t\t \n\t\tprintk(KERN_NOTICE \"RPC: Could not send backchannel reply \"\n\t\t\t\"error: %d\\n\", task->tk_status);\n\t\txprt_conditional_disconnect(req->rq_xprt,\n\t\t\treq->rq_connect_cookie);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tprintk(KERN_NOTICE \"RPC: Could not send backchannel reply \"\n\t\t\t\"error: %d\\n\", task->tk_status);\n\t\tbreak;\n\t}\n\ttask->tk_action = rpc_exit_task;\n}\n#endif  \n\n \nstatic void\ncall_status(struct rpc_task *task)\n{\n\tstruct rpc_clnt\t*clnt = task->tk_client;\n\tint\t\tstatus;\n\n\tif (!task->tk_msg.rpc_proc->p_proc)\n\t\ttrace_xprt_ping(task->tk_xprt, task->tk_status);\n\n\tstatus = task->tk_status;\n\tif (status >= 0) {\n\t\ttask->tk_action = call_decode;\n\t\treturn;\n\t}\n\n\ttrace_rpc_call_status(task);\n\ttask->tk_status = 0;\n\tswitch(status) {\n\tcase -EHOSTDOWN:\n\tcase -ENETDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EPERM:\n\t\tif (RPC_IS_SOFTCONN(task))\n\t\t\tgoto out_exit;\n\t\t \n\t\trpc_delay(task, 3*HZ);\n\t\tfallthrough;\n\tcase -ETIMEDOUT:\n\t\tbreak;\n\tcase -ECONNREFUSED:\n\tcase -ECONNRESET:\n\tcase -ECONNABORTED:\n\tcase -ENOTCONN:\n\t\trpc_force_rebind(clnt);\n\t\tbreak;\n\tcase -EADDRINUSE:\n\t\trpc_delay(task, 3*HZ);\n\t\tfallthrough;\n\tcase -EPIPE:\n\tcase -EAGAIN:\n\t\tbreak;\n\tcase -ENFILE:\n\tcase -ENOBUFS:\n\tcase -ENOMEM:\n\t\trpc_delay(task, HZ>>2);\n\t\tbreak;\n\tcase -EIO:\n\t\t \n\t\tgoto out_exit;\n\tdefault:\n\t\tif (clnt->cl_chatty)\n\t\t\tprintk(\"%s: RPC call returned error %d\\n\",\n\t\t\t       clnt->cl_program->name, -status);\n\t\tgoto out_exit;\n\t}\n\ttask->tk_action = call_encode;\n\trpc_check_timeout(task);\n\treturn;\nout_exit:\n\trpc_call_rpcerror(task, status);\n}\n\nstatic bool\nrpc_check_connected(const struct rpc_rqst *req)\n{\n\t \n\tif (!req || !req->rq_xprt)\n\t\treturn true;\n\treturn xprt_connected(req->rq_xprt);\n}\n\nstatic void\nrpc_check_timeout(struct rpc_task *task)\n{\n\tstruct rpc_clnt\t*clnt = task->tk_client;\n\n\tif (RPC_SIGNALLED(task))\n\t\treturn;\n\n\tif (xprt_adjust_timeout(task->tk_rqstp) == 0)\n\t\treturn;\n\n\ttrace_rpc_timeout_status(task);\n\ttask->tk_timeouts++;\n\n\tif (RPC_IS_SOFTCONN(task) && !rpc_check_connected(task->tk_rqstp)) {\n\t\trpc_call_rpcerror(task, -ETIMEDOUT);\n\t\treturn;\n\t}\n\n\tif (RPC_IS_SOFT(task)) {\n\t\t \n\t\tif ((task->tk_flags & RPC_TASK_NO_RETRANS_TIMEOUT) &&\n\t\t    rpc_check_connected(task->tk_rqstp))\n\t\t\treturn;\n\n\t\tif (clnt->cl_chatty) {\n\t\t\tpr_notice_ratelimited(\n\t\t\t\t\"%s: server %s not responding, timed out\\n\",\n\t\t\t\tclnt->cl_program->name,\n\t\t\t\ttask->tk_xprt->servername);\n\t\t}\n\t\tif (task->tk_flags & RPC_TASK_TIMEOUT)\n\t\t\trpc_call_rpcerror(task, -ETIMEDOUT);\n\t\telse\n\t\t\t__rpc_call_rpcerror(task, -EIO, -ETIMEDOUT);\n\t\treturn;\n\t}\n\n\tif (!(task->tk_flags & RPC_CALL_MAJORSEEN)) {\n\t\ttask->tk_flags |= RPC_CALL_MAJORSEEN;\n\t\tif (clnt->cl_chatty) {\n\t\t\tpr_notice_ratelimited(\n\t\t\t\t\"%s: server %s not responding, still trying\\n\",\n\t\t\t\tclnt->cl_program->name,\n\t\t\t\ttask->tk_xprt->servername);\n\t\t}\n\t}\n\trpc_force_rebind(clnt);\n\t \n\trpcauth_invalcred(task);\n}\n\n \nstatic void\ncall_decode(struct rpc_task *task)\n{\n\tstruct rpc_clnt\t*clnt = task->tk_client;\n\tstruct rpc_rqst\t*req = task->tk_rqstp;\n\tstruct xdr_stream xdr;\n\tint err;\n\n\tif (!task->tk_msg.rpc_proc->p_decode) {\n\t\ttask->tk_action = rpc_exit_task;\n\t\treturn;\n\t}\n\n\tif (task->tk_flags & RPC_CALL_MAJORSEEN) {\n\t\tif (clnt->cl_chatty) {\n\t\t\tpr_notice_ratelimited(\"%s: server %s OK\\n\",\n\t\t\t\tclnt->cl_program->name,\n\t\t\t\ttask->tk_xprt->servername);\n\t\t}\n\t\ttask->tk_flags &= ~RPC_CALL_MAJORSEEN;\n\t}\n\n\t \n\terr = -EAGAIN;\n\tif (!req->rq_reply_bytes_recvd)\n\t\tgoto out;\n\n\t \n\tsmp_rmb();\n\n\treq->rq_rcv_buf.len = req->rq_private_buf.len;\n\ttrace_rpc_xdr_recvfrom(task, &req->rq_rcv_buf);\n\n\t \n\tWARN_ON(memcmp(&req->rq_rcv_buf, &req->rq_private_buf,\n\t\t\t\tsizeof(req->rq_rcv_buf)) != 0);\n\n\txdr_init_decode(&xdr, &req->rq_rcv_buf,\n\t\t\treq->rq_rcv_buf.head[0].iov_base, req);\n\terr = rpc_decode_header(task, &xdr);\nout:\n\tswitch (err) {\n\tcase 0:\n\t\ttask->tk_action = rpc_exit_task;\n\t\ttask->tk_status = rpcauth_unwrap_resp(task, &xdr);\n\t\txdr_finish_decode(&xdr);\n\t\treturn;\n\tcase -EAGAIN:\n\t\ttask->tk_status = 0;\n\t\tif (task->tk_client->cl_discrtry)\n\t\t\txprt_conditional_disconnect(req->rq_xprt,\n\t\t\t\t\t\t    req->rq_connect_cookie);\n\t\ttask->tk_action = call_encode;\n\t\trpc_check_timeout(task);\n\t\tbreak;\n\tcase -EKEYREJECTED:\n\t\ttask->tk_action = call_reserve;\n\t\trpc_check_timeout(task);\n\t\trpcauth_invalcred(task);\n\t\t \n\t\txprt_release(task);\n\t}\n}\n\nstatic int\nrpc_encode_header(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tstruct rpc_clnt *clnt = task->tk_client;\n\tstruct rpc_rqst\t*req = task->tk_rqstp;\n\t__be32 *p;\n\tint error;\n\n\terror = -EMSGSIZE;\n\tp = xdr_reserve_space(xdr, RPC_CALLHDRSIZE << 2);\n\tif (!p)\n\t\tgoto out_fail;\n\t*p++ = req->rq_xid;\n\t*p++ = rpc_call;\n\t*p++ = cpu_to_be32(RPC_VERSION);\n\t*p++ = cpu_to_be32(clnt->cl_prog);\n\t*p++ = cpu_to_be32(clnt->cl_vers);\n\t*p   = cpu_to_be32(task->tk_msg.rpc_proc->p_proc);\n\n\terror = rpcauth_marshcred(task, xdr);\n\tif (error < 0)\n\t\tgoto out_fail;\n\treturn 0;\nout_fail:\n\ttrace_rpc_bad_callhdr(task);\n\trpc_call_rpcerror(task, error);\n\treturn error;\n}\n\nstatic noinline int\nrpc_decode_header(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tstruct rpc_clnt *clnt = task->tk_client;\n\tint error;\n\t__be32 *p;\n\n\t \n\tif (task->tk_rqstp->rq_rcv_buf.len & 3)\n\t\tgoto out_unparsable;\n\n\tp = xdr_inline_decode(xdr, 3 * sizeof(*p));\n\tif (!p)\n\t\tgoto out_unparsable;\n\tp++;\t \n\tif (*p++ != rpc_reply)\n\t\tgoto out_unparsable;\n\tif (*p++ != rpc_msg_accepted)\n\t\tgoto out_msg_denied;\n\n\terror = rpcauth_checkverf(task, xdr);\n\tif (error)\n\t\tgoto out_verifier;\n\n\tp = xdr_inline_decode(xdr, sizeof(*p));\n\tif (!p)\n\t\tgoto out_unparsable;\n\tswitch (*p) {\n\tcase rpc_success:\n\t\treturn 0;\n\tcase rpc_prog_unavail:\n\t\ttrace_rpc__prog_unavail(task);\n\t\terror = -EPFNOSUPPORT;\n\t\tgoto out_err;\n\tcase rpc_prog_mismatch:\n\t\ttrace_rpc__prog_mismatch(task);\n\t\terror = -EPROTONOSUPPORT;\n\t\tgoto out_err;\n\tcase rpc_proc_unavail:\n\t\ttrace_rpc__proc_unavail(task);\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_err;\n\tcase rpc_garbage_args:\n\tcase rpc_system_err:\n\t\ttrace_rpc__garbage_args(task);\n\t\terror = -EIO;\n\t\tbreak;\n\tdefault:\n\t\tgoto out_unparsable;\n\t}\n\nout_garbage:\n\tclnt->cl_stats->rpcgarbage++;\n\tif (task->tk_garb_retry) {\n\t\ttask->tk_garb_retry--;\n\t\ttask->tk_action = call_encode;\n\t\treturn -EAGAIN;\n\t}\nout_err:\n\trpc_call_rpcerror(task, error);\n\treturn error;\n\nout_unparsable:\n\ttrace_rpc__unparsable(task);\n\terror = -EIO;\n\tgoto out_garbage;\n\nout_verifier:\n\ttrace_rpc_bad_verifier(task);\n\tswitch (error) {\n\tcase -EPROTONOSUPPORT:\n\t\tgoto out_err;\n\tcase -EACCES:\n\t\t \n\t\tfallthrough;\n\tdefault:\n\t\tgoto out_garbage;\n\t}\n\nout_msg_denied:\n\terror = -EACCES;\n\tp = xdr_inline_decode(xdr, sizeof(*p));\n\tif (!p)\n\t\tgoto out_unparsable;\n\tswitch (*p++) {\n\tcase rpc_auth_error:\n\t\tbreak;\n\tcase rpc_mismatch:\n\t\ttrace_rpc__mismatch(task);\n\t\terror = -EPROTONOSUPPORT;\n\t\tgoto out_err;\n\tdefault:\n\t\tgoto out_unparsable;\n\t}\n\n\tp = xdr_inline_decode(xdr, sizeof(*p));\n\tif (!p)\n\t\tgoto out_unparsable;\n\tswitch (*p++) {\n\tcase rpc_autherr_rejectedcred:\n\tcase rpc_autherr_rejectedverf:\n\tcase rpcsec_gsserr_credproblem:\n\tcase rpcsec_gsserr_ctxproblem:\n\t\trpcauth_invalcred(task);\n\t\tif (!task->tk_cred_retry)\n\t\t\tbreak;\n\t\ttask->tk_cred_retry--;\n\t\ttrace_rpc__stale_creds(task);\n\t\treturn -EKEYREJECTED;\n\tcase rpc_autherr_badcred:\n\tcase rpc_autherr_badverf:\n\t\t \n\t\tif (!task->tk_garb_retry)\n\t\t\tbreak;\n\t\ttask->tk_garb_retry--;\n\t\ttrace_rpc__bad_creds(task);\n\t\ttask->tk_action = call_encode;\n\t\treturn -EAGAIN;\n\tcase rpc_autherr_tooweak:\n\t\ttrace_rpc__auth_tooweak(task);\n\t\tpr_warn(\"RPC: server %s requires stronger authentication.\\n\",\n\t\t\ttask->tk_xprt->servername);\n\t\tbreak;\n\tdefault:\n\t\tgoto out_unparsable;\n\t}\n\tgoto out_err;\n}\n\nstatic void rpcproc_encode_null(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\tconst void *obj)\n{\n}\n\nstatic int rpcproc_decode_null(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\tvoid *obj)\n{\n\treturn 0;\n}\n\nstatic const struct rpc_procinfo rpcproc_null = {\n\t.p_encode = rpcproc_encode_null,\n\t.p_decode = rpcproc_decode_null,\n};\n\nstatic const struct rpc_procinfo rpcproc_null_noreply = {\n\t.p_encode = rpcproc_encode_null,\n};\n\nstatic void\nrpc_null_call_prepare(struct rpc_task *task, void *data)\n{\n\ttask->tk_flags &= ~RPC_TASK_NO_RETRANS_TIMEOUT;\n\trpc_call_start(task);\n}\n\nstatic const struct rpc_call_ops rpc_null_ops = {\n\t.rpc_call_prepare = rpc_null_call_prepare,\n\t.rpc_call_done = rpc_default_callback,\n};\n\nstatic\nstruct rpc_task *rpc_call_null_helper(struct rpc_clnt *clnt,\n\t\tstruct rpc_xprt *xprt, struct rpc_cred *cred, int flags,\n\t\tconst struct rpc_call_ops *ops, void *data)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &rpcproc_null,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_xprt = xprt,\n\t\t.rpc_message = &msg,\n\t\t.rpc_op_cred = cred,\n\t\t.callback_ops = ops ?: &rpc_null_ops,\n\t\t.callback_data = data,\n\t\t.flags = flags | RPC_TASK_SOFT | RPC_TASK_SOFTCONN |\n\t\t\t RPC_TASK_NULLCREDS,\n\t};\n\n\treturn rpc_run_task(&task_setup_data);\n}\n\nstruct rpc_task *rpc_call_null(struct rpc_clnt *clnt, struct rpc_cred *cred, int flags)\n{\n\treturn rpc_call_null_helper(clnt, NULL, cred, flags, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(rpc_call_null);\n\nstatic int rpc_ping(struct rpc_clnt *clnt)\n{\n\tstruct rpc_task\t*task;\n\tint status;\n\n\tif (clnt->cl_auth->au_ops->ping)\n\t\treturn clnt->cl_auth->au_ops->ping(clnt);\n\n\ttask = rpc_call_null_helper(clnt, NULL, NULL, 0, NULL, NULL);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = task->tk_status;\n\trpc_put_task(task);\n\treturn status;\n}\n\nstatic int rpc_ping_noreply(struct rpc_clnt *clnt)\n{\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &rpcproc_null_noreply,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &rpc_null_ops,\n\t\t.flags = RPC_TASK_SOFT | RPC_TASK_SOFTCONN | RPC_TASK_NULLCREDS,\n\t};\n\tstruct rpc_task\t*task;\n\tint status;\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = task->tk_status;\n\trpc_put_task(task);\n\treturn status;\n}\n\nstruct rpc_cb_add_xprt_calldata {\n\tstruct rpc_xprt_switch *xps;\n\tstruct rpc_xprt *xprt;\n};\n\nstatic void rpc_cb_add_xprt_done(struct rpc_task *task, void *calldata)\n{\n\tstruct rpc_cb_add_xprt_calldata *data = calldata;\n\n\tif (task->tk_status == 0)\n\t\trpc_xprt_switch_add_xprt(data->xps, data->xprt);\n}\n\nstatic void rpc_cb_add_xprt_release(void *calldata)\n{\n\tstruct rpc_cb_add_xprt_calldata *data = calldata;\n\n\txprt_put(data->xprt);\n\txprt_switch_put(data->xps);\n\tkfree(data);\n}\n\nstatic const struct rpc_call_ops rpc_cb_add_xprt_call_ops = {\n\t.rpc_call_prepare = rpc_null_call_prepare,\n\t.rpc_call_done = rpc_cb_add_xprt_done,\n\t.rpc_release = rpc_cb_add_xprt_release,\n};\n\n \nint rpc_clnt_test_and_add_xprt(struct rpc_clnt *clnt,\n\t\tstruct rpc_xprt_switch *xps, struct rpc_xprt *xprt,\n\t\tvoid *in_max_connect)\n{\n\tstruct rpc_cb_add_xprt_calldata *data;\n\tstruct rpc_task *task;\n\tint max_connect = clnt->cl_max_connect;\n\n\tif (in_max_connect)\n\t\tmax_connect = *(int *)in_max_connect;\n\tif (xps->xps_nunique_destaddr_xprts + 1 > max_connect) {\n\t\trcu_read_lock();\n\t\tpr_warn(\"SUNRPC: reached max allowed number (%d) did not add \"\n\t\t\t\"transport to server: %s\\n\", max_connect,\n\t\t\trpc_peeraddr2str(clnt, RPC_DISPLAY_ADDR));\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->xps = xprt_switch_get(xps);\n\tdata->xprt = xprt_get(xprt);\n\tif (rpc_xprt_switch_has_addr(data->xps, (struct sockaddr *)&xprt->addr)) {\n\t\trpc_cb_add_xprt_release(data);\n\t\tgoto success;\n\t}\n\n\ttask = rpc_call_null_helper(clnt, xprt, NULL, RPC_TASK_ASYNC,\n\t\t\t&rpc_cb_add_xprt_call_ops, data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\n\tdata->xps->xps_nunique_destaddr_xprts++;\n\trpc_put_task(task);\nsuccess:\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_test_and_add_xprt);\n\nstatic int rpc_clnt_add_xprt_helper(struct rpc_clnt *clnt,\n\t\t\t\t    struct rpc_xprt *xprt,\n\t\t\t\t    struct rpc_add_xprt_test *data)\n{\n\tstruct rpc_task *task;\n\tint status = -EADDRINUSE;\n\n\t \n\ttask = rpc_call_null_helper(clnt, xprt, NULL, 0, NULL, NULL);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\n\tstatus = task->tk_status;\n\trpc_put_task(task);\n\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tdata->add_xprt_test(clnt, xprt, data->data);\n\n\treturn 0;\n}\n\n \nint rpc_clnt_setup_test_and_add_xprt(struct rpc_clnt *clnt,\n\t\t\t\t     struct rpc_xprt_switch *xps,\n\t\t\t\t     struct rpc_xprt *xprt,\n\t\t\t\t     void *data)\n{\n\tint status = -EADDRINUSE;\n\n\txprt = xprt_get(xprt);\n\txprt_switch_get(xps);\n\n\tif (rpc_xprt_switch_has_addr(xps, (struct sockaddr *)&xprt->addr))\n\t\tgoto out_err;\n\n\tstatus = rpc_clnt_add_xprt_helper(clnt, xprt, data);\n\tif (status < 0)\n\t\tgoto out_err;\n\n\tstatus = 1;\nout_err:\n\txprt_put(xprt);\n\txprt_switch_put(xps);\n\tif (status < 0)\n\t\tpr_info(\"RPC:   rpc_clnt_test_xprt failed: %d addr %s not \"\n\t\t\t\"added\\n\", status,\n\t\t\txprt->address_strings[RPC_DISPLAY_ADDR]);\n\t \n\treturn status;\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_setup_test_and_add_xprt);\n\n \nint rpc_clnt_add_xprt(struct rpc_clnt *clnt,\n\t\tstruct xprt_create *xprtargs,\n\t\tint (*setup)(struct rpc_clnt *,\n\t\t\tstruct rpc_xprt_switch *,\n\t\t\tstruct rpc_xprt *,\n\t\t\tvoid *),\n\t\tvoid *data)\n{\n\tstruct rpc_xprt_switch *xps;\n\tstruct rpc_xprt *xprt;\n\tunsigned long connect_timeout;\n\tunsigned long reconnect_timeout;\n\tunsigned char resvport, reuseport;\n\tint ret = 0, ident;\n\n\trcu_read_lock();\n\txps = xprt_switch_get(rcu_dereference(clnt->cl_xpi.xpi_xpswitch));\n\txprt = xprt_iter_xprt(&clnt->cl_xpi);\n\tif (xps == NULL || xprt == NULL) {\n\t\trcu_read_unlock();\n\t\txprt_switch_put(xps);\n\t\treturn -EAGAIN;\n\t}\n\tresvport = xprt->resvport;\n\treuseport = xprt->reuseport;\n\tconnect_timeout = xprt->connect_timeout;\n\treconnect_timeout = xprt->max_reconnect_timeout;\n\tident = xprt->xprt_class->ident;\n\trcu_read_unlock();\n\n\tif (!xprtargs->ident)\n\t\txprtargs->ident = ident;\n\txprtargs->xprtsec = clnt->cl_xprtsec;\n\txprt = xprt_create_transport(xprtargs);\n\tif (IS_ERR(xprt)) {\n\t\tret = PTR_ERR(xprt);\n\t\tgoto out_put_switch;\n\t}\n\txprt->resvport = resvport;\n\txprt->reuseport = reuseport;\n\n\tif (xprtargs->connect_timeout)\n\t\tconnect_timeout = xprtargs->connect_timeout;\n\tif (xprtargs->reconnect_timeout)\n\t\treconnect_timeout = xprtargs->reconnect_timeout;\n\tif (xprt->ops->set_connect_timeout != NULL)\n\t\txprt->ops->set_connect_timeout(xprt,\n\t\t\t\tconnect_timeout,\n\t\t\t\treconnect_timeout);\n\n\trpc_xprt_switch_set_roundrobin(xps);\n\tif (setup) {\n\t\tret = setup(clnt, xps, xprt, data);\n\t\tif (ret != 0)\n\t\t\tgoto out_put_xprt;\n\t}\n\trpc_xprt_switch_add_xprt(xps, xprt);\nout_put_xprt:\n\txprt_put(xprt);\nout_put_switch:\n\txprt_switch_put(xps);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_add_xprt);\n\nstatic int rpc_xprt_probe_trunked(struct rpc_clnt *clnt,\n\t\t\t\t  struct rpc_xprt *xprt,\n\t\t\t\t  struct rpc_add_xprt_test *data)\n{\n\tstruct rpc_xprt_switch *xps;\n\tstruct rpc_xprt *main_xprt;\n\tint status = 0;\n\n\txprt_get(xprt);\n\n\trcu_read_lock();\n\tmain_xprt = xprt_get(rcu_dereference(clnt->cl_xprt));\n\txps = xprt_switch_get(rcu_dereference(clnt->cl_xpi.xpi_xpswitch));\n\tstatus = rpc_cmp_addr_port((struct sockaddr *)&xprt->addr,\n\t\t\t\t   (struct sockaddr *)&main_xprt->addr);\n\trcu_read_unlock();\n\txprt_put(main_xprt);\n\tif (status || !test_bit(XPRT_OFFLINE, &xprt->state))\n\t\tgoto out;\n\n\tstatus = rpc_clnt_add_xprt_helper(clnt, xprt, data);\nout:\n\txprt_put(xprt);\n\txprt_switch_put(xps);\n\treturn status;\n}\n\n \nvoid rpc_clnt_probe_trunked_xprts(struct rpc_clnt *clnt,\n\t\t\t\t  struct rpc_add_xprt_test *data)\n{\n\tstruct rpc_xprt_iter xpi;\n\tint ret;\n\n\tret = rpc_clnt_xprt_iter_offline_init(clnt, &xpi);\n\tif (ret)\n\t\treturn;\n\tfor (;;) {\n\t\tstruct rpc_xprt *xprt = xprt_iter_get_next(&xpi);\n\n\t\tif (!xprt)\n\t\t\tbreak;\n\t\tret = rpc_xprt_probe_trunked(clnt, xprt, data);\n\t\txprt_put(xprt);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\txprt_iter_rewind(&xpi);\n\t}\n\txprt_iter_destroy(&xpi);\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_probe_trunked_xprts);\n\nstatic int rpc_xprt_offline(struct rpc_clnt *clnt,\n\t\t\t    struct rpc_xprt *xprt,\n\t\t\t    void *data)\n{\n\tstruct rpc_xprt *main_xprt;\n\tstruct rpc_xprt_switch *xps;\n\tint err = 0;\n\n\txprt_get(xprt);\n\n\trcu_read_lock();\n\tmain_xprt = xprt_get(rcu_dereference(clnt->cl_xprt));\n\txps = xprt_switch_get(rcu_dereference(clnt->cl_xpi.xpi_xpswitch));\n\terr = rpc_cmp_addr_port((struct sockaddr *)&xprt->addr,\n\t\t\t\t(struct sockaddr *)&main_xprt->addr);\n\trcu_read_unlock();\n\txprt_put(main_xprt);\n\tif (err)\n\t\tgoto out;\n\n\tif (wait_on_bit_lock(&xprt->state, XPRT_LOCKED, TASK_KILLABLE)) {\n\t\terr = -EINTR;\n\t\tgoto out;\n\t}\n\txprt_set_offline_locked(xprt, xps);\n\n\txprt_release_write(xprt, NULL);\nout:\n\txprt_put(xprt);\n\txprt_switch_put(xps);\n\treturn err;\n}\n\n \nvoid rpc_clnt_manage_trunked_xprts(struct rpc_clnt *clnt)\n{\n\trpc_clnt_iterate_for_each_xprt(clnt, rpc_xprt_offline, NULL);\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_manage_trunked_xprts);\n\nstruct connect_timeout_data {\n\tunsigned long connect_timeout;\n\tunsigned long reconnect_timeout;\n};\n\nstatic int\nrpc_xprt_set_connect_timeout(struct rpc_clnt *clnt,\n\t\tstruct rpc_xprt *xprt,\n\t\tvoid *data)\n{\n\tstruct connect_timeout_data *timeo = data;\n\n\tif (xprt->ops->set_connect_timeout)\n\t\txprt->ops->set_connect_timeout(xprt,\n\t\t\t\ttimeo->connect_timeout,\n\t\t\t\ttimeo->reconnect_timeout);\n\treturn 0;\n}\n\nvoid\nrpc_set_connect_timeout(struct rpc_clnt *clnt,\n\t\tunsigned long connect_timeout,\n\t\tunsigned long reconnect_timeout)\n{\n\tstruct connect_timeout_data timeout = {\n\t\t.connect_timeout = connect_timeout,\n\t\t.reconnect_timeout = reconnect_timeout,\n\t};\n\trpc_clnt_iterate_for_each_xprt(clnt,\n\t\t\trpc_xprt_set_connect_timeout,\n\t\t\t&timeout);\n}\nEXPORT_SYMBOL_GPL(rpc_set_connect_timeout);\n\nvoid rpc_clnt_xprt_switch_put(struct rpc_clnt *clnt)\n{\n\trcu_read_lock();\n\txprt_switch_put(rcu_dereference(clnt->cl_xpi.xpi_xpswitch));\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_xprt_switch_put);\n\nvoid rpc_clnt_xprt_set_online(struct rpc_clnt *clnt, struct rpc_xprt *xprt)\n{\n\tstruct rpc_xprt_switch *xps;\n\n\trcu_read_lock();\n\txps = rcu_dereference(clnt->cl_xpi.xpi_xpswitch);\n\trcu_read_unlock();\n\txprt_set_online_locked(xprt, xps);\n}\n\nvoid rpc_clnt_xprt_switch_add_xprt(struct rpc_clnt *clnt, struct rpc_xprt *xprt)\n{\n\tif (rpc_clnt_xprt_switch_has_addr(clnt,\n\t\t(const struct sockaddr *)&xprt->addr)) {\n\t\treturn rpc_clnt_xprt_set_online(clnt, xprt);\n\t}\n\trcu_read_lock();\n\trpc_xprt_switch_add_xprt(rcu_dereference(clnt->cl_xpi.xpi_xpswitch),\n\t\t\t\t xprt);\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_xprt_switch_add_xprt);\n\nvoid rpc_clnt_xprt_switch_remove_xprt(struct rpc_clnt *clnt, struct rpc_xprt *xprt)\n{\n\tstruct rpc_xprt_switch *xps;\n\n\trcu_read_lock();\n\txps = rcu_dereference(clnt->cl_xpi.xpi_xpswitch);\n\trpc_xprt_switch_remove_xprt(rcu_dereference(clnt->cl_xpi.xpi_xpswitch),\n\t\t\t\t    xprt, 0);\n\txps->xps_nunique_destaddr_xprts--;\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_xprt_switch_remove_xprt);\n\nbool rpc_clnt_xprt_switch_has_addr(struct rpc_clnt *clnt,\n\t\t\t\t   const struct sockaddr *sap)\n{\n\tstruct rpc_xprt_switch *xps;\n\tbool ret;\n\n\trcu_read_lock();\n\txps = rcu_dereference(clnt->cl_xpi.xpi_xpswitch);\n\tret = rpc_xprt_switch_has_addr(xps, sap);\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_xprt_switch_has_addr);\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\nstatic void rpc_show_header(void)\n{\n\tprintk(KERN_INFO \"-pid- flgs status -client- --rqstp- \"\n\t\t\"-timeout ---ops--\\n\");\n}\n\nstatic void rpc_show_task(const struct rpc_clnt *clnt,\n\t\t\t  const struct rpc_task *task)\n{\n\tconst char *rpc_waitq = \"none\";\n\n\tif (RPC_IS_QUEUED(task))\n\t\trpc_waitq = rpc_qname(task->tk_waitqueue);\n\n\tprintk(KERN_INFO \"%5u %04x %6d %8p %8p %8ld %8p %sv%u %s a:%ps q:%s\\n\",\n\t\ttask->tk_pid, task->tk_flags, task->tk_status,\n\t\tclnt, task->tk_rqstp, rpc_task_timeout(task), task->tk_ops,\n\t\tclnt->cl_program->name, clnt->cl_vers, rpc_proc_name(task),\n\t\ttask->tk_action, rpc_waitq);\n}\n\nvoid rpc_show_tasks(struct net *net)\n{\n\tstruct rpc_clnt *clnt;\n\tstruct rpc_task *task;\n\tint header = 0;\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tspin_lock(&sn->rpc_client_lock);\n\tlist_for_each_entry(clnt, &sn->all_clients, cl_clients) {\n\t\tspin_lock(&clnt->cl_lock);\n\t\tlist_for_each_entry(task, &clnt->cl_tasks, tk_task) {\n\t\t\tif (!header) {\n\t\t\t\trpc_show_header();\n\t\t\t\theader++;\n\t\t\t}\n\t\t\trpc_show_task(clnt, task);\n\t\t}\n\t\tspin_unlock(&clnt->cl_lock);\n\t}\n\tspin_unlock(&sn->rpc_client_lock);\n}\n#endif\n\n#if IS_ENABLED(CONFIG_SUNRPC_SWAP)\nstatic int\nrpc_clnt_swap_activate_callback(struct rpc_clnt *clnt,\n\t\tstruct rpc_xprt *xprt,\n\t\tvoid *dummy)\n{\n\treturn xprt_enable_swap(xprt);\n}\n\nint\nrpc_clnt_swap_activate(struct rpc_clnt *clnt)\n{\n\twhile (clnt != clnt->cl_parent)\n\t\tclnt = clnt->cl_parent;\n\tif (atomic_inc_return(&clnt->cl_swapper) == 1)\n\t\treturn rpc_clnt_iterate_for_each_xprt(clnt,\n\t\t\t\trpc_clnt_swap_activate_callback, NULL);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_swap_activate);\n\nstatic int\nrpc_clnt_swap_deactivate_callback(struct rpc_clnt *clnt,\n\t\tstruct rpc_xprt *xprt,\n\t\tvoid *dummy)\n{\n\txprt_disable_swap(xprt);\n\treturn 0;\n}\n\nvoid\nrpc_clnt_swap_deactivate(struct rpc_clnt *clnt)\n{\n\twhile (clnt != clnt->cl_parent)\n\t\tclnt = clnt->cl_parent;\n\tif (atomic_dec_if_positive(&clnt->cl_swapper) == 0)\n\t\trpc_clnt_iterate_for_each_xprt(clnt,\n\t\t\t\trpc_clnt_swap_deactivate_callback, NULL);\n}\nEXPORT_SYMBOL_GPL(rpc_clnt_swap_deactivate);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}