{
  "module_name": "gss_krb5_keys.c",
  "hash_id": "12c8936f35c230831cbc313a6990815b0382eb9501d1ba6dbcda9bc72ddc6be7",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth_gss/gss_krb5_keys.c",
  "human_readable_source": " \n\n \n\n#include <crypto/skcipher.h>\n#include <linux/err.h>\n#include <linux/types.h>\n#include <linux/sunrpc/gss_krb5.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/lcm.h>\n#include <crypto/hash.h>\n#include <kunit/visibility.h>\n\n#include \"gss_krb5_internal.h\"\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n# define RPCDBG_FACILITY        RPCDBG_AUTH\n#endif\n\n \nVISIBLE_IF_KUNIT\nvoid krb5_nfold(u32 inbits, const u8 *in, u32 outbits, u8 *out)\n{\n\tunsigned long ulcm;\n\tint byte, i, msbit;\n\n\t \n\n\tinbits >>= 3;\n\toutbits >>= 3;\n\n\t \n\tulcm = lcm(inbits, outbits);\n\n\t \n\n\tmemset(out, 0, outbits);\n\tbyte = 0;\n\n\t \n\tfor (i = ulcm-1; i >= 0; i--) {\n\t\t \n\t\tmsbit = (\n\t\t\t \n\t\t\t ((inbits << 3) - 1)\n\t\t\t  \n\t\t\t + (((inbits << 3) + 13) * (i/inbits))\n\t\t\t  \n\t\t\t + ((inbits - (i % inbits)) << 3)\n\t\t\t ) % (inbits << 3);\n\n\t\t \n\t\tbyte += (((in[((inbits - 1) - (msbit >> 3)) % inbits] << 8)|\n\t\t\t\t  (in[((inbits) - (msbit >> 3)) % inbits]))\n\t\t\t\t >> ((msbit & 7) + 1)) & 0xff;\n\n\t\t \n\t\tbyte += out[i % outbits];\n\t\tout[i % outbits] = byte & 0xff;\n\n\t\t \n\t\tbyte >>= 8;\n\n\t}\n\n\t \n\tif (byte) {\n\t\tfor (i = outbits - 1; i >= 0; i--) {\n\t\t\t \n\t\t\tbyte += out[i];\n\t\t\tout[i] = byte & 0xff;\n\n\t\t\t \n\t\t\tbyte >>= 8;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_IF_KUNIT(krb5_nfold);\n\n \nstatic int krb5_DK(const struct gss_krb5_enctype *gk5e,\n\t\t   const struct xdr_netobj *inkey, u8 *rawkey,\n\t\t   const struct xdr_netobj *in_constant, gfp_t gfp_mask)\n{\n\tsize_t blocksize, keybytes, keylength, n;\n\tunsigned char *inblockdata, *outblockdata;\n\tstruct xdr_netobj inblock, outblock;\n\tstruct crypto_sync_skcipher *cipher;\n\tint ret = -EINVAL;\n\n\tkeybytes = gk5e->keybytes;\n\tkeylength = gk5e->keylength;\n\n\tif (inkey->len != keylength)\n\t\tgoto err_return;\n\n\tcipher = crypto_alloc_sync_skcipher(gk5e->encrypt_name, 0, 0);\n\tif (IS_ERR(cipher))\n\t\tgoto err_return;\n\tblocksize = crypto_sync_skcipher_blocksize(cipher);\n\tif (crypto_sync_skcipher_setkey(cipher, inkey->data, inkey->len))\n\t\tgoto err_return;\n\n\tret = -ENOMEM;\n\tinblockdata = kmalloc(blocksize, gfp_mask);\n\tif (inblockdata == NULL)\n\t\tgoto err_free_cipher;\n\n\toutblockdata = kmalloc(blocksize, gfp_mask);\n\tif (outblockdata == NULL)\n\t\tgoto err_free_in;\n\n\tinblock.data = (char *) inblockdata;\n\tinblock.len = blocksize;\n\n\toutblock.data = (char *) outblockdata;\n\toutblock.len = blocksize;\n\n\t \n\n\tif (in_constant->len == inblock.len) {\n\t\tmemcpy(inblock.data, in_constant->data, inblock.len);\n\t} else {\n\t\tkrb5_nfold(in_constant->len * 8, in_constant->data,\n\t\t\t   inblock.len * 8, inblock.data);\n\t}\n\n\t \n\n\tn = 0;\n\twhile (n < keybytes) {\n\t\tkrb5_encrypt(cipher, NULL, inblock.data, outblock.data,\n\t\t\t     inblock.len);\n\n\t\tif ((keybytes - n) <= outblock.len) {\n\t\t\tmemcpy(rawkey + n, outblock.data, (keybytes - n));\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(rawkey + n, outblock.data, outblock.len);\n\t\tmemcpy(inblock.data, outblock.data, outblock.len);\n\t\tn += outblock.len;\n\t}\n\n\tret = 0;\n\n\tkfree_sensitive(outblockdata);\nerr_free_in:\n\tkfree_sensitive(inblockdata);\nerr_free_cipher:\n\tcrypto_free_sync_skcipher(cipher);\nerr_return:\n\treturn ret;\n}\n\n \nstatic int krb5_random_to_key_v2(const struct gss_krb5_enctype *gk5e,\n\t\t\t\t struct xdr_netobj *randombits,\n\t\t\t\t struct xdr_netobj *key)\n{\n\tint ret = -EINVAL;\n\n\tif (key->len != 16 && key->len != 32) {\n\t\tdprintk(\"%s: key->len is %d\\n\", __func__, key->len);\n\t\tgoto err_out;\n\t}\n\tif (randombits->len != 16 && randombits->len != 32) {\n\t\tdprintk(\"%s: randombits->len is %d\\n\",\n\t\t\t__func__, randombits->len);\n\t\tgoto err_out;\n\t}\n\tif (randombits->len != key->len) {\n\t\tdprintk(\"%s: randombits->len is %d, key->len is %d\\n\",\n\t\t\t__func__, randombits->len, key->len);\n\t\tgoto err_out;\n\t}\n\tmemcpy(key->data, randombits->data, key->len);\n\tret = 0;\nerr_out:\n\treturn ret;\n}\n\n \nint krb5_derive_key_v2(const struct gss_krb5_enctype *gk5e,\n\t\t       const struct xdr_netobj *inkey,\n\t\t       struct xdr_netobj *outkey,\n\t\t       const struct xdr_netobj *label,\n\t\t       gfp_t gfp_mask)\n{\n\tstruct xdr_netobj inblock;\n\tint ret;\n\n\tinblock.len = gk5e->keybytes;\n\tinblock.data = kmalloc(inblock.len, gfp_mask);\n\tif (!inblock.data)\n\t\treturn -ENOMEM;\n\n\tret = krb5_DK(gk5e, inkey, inblock.data, label, gfp_mask);\n\tif (!ret)\n\t\tret = krb5_random_to_key_v2(gk5e, &inblock, outkey);\n\n\tkfree_sensitive(inblock.data);\n\treturn ret;\n}\n\n \nstatic int\nkrb5_cmac_Ki(struct crypto_shash *tfm, const struct xdr_netobj *constant,\n\t     u32 outlen, u32 count, struct xdr_netobj *step)\n{\n\t__be32 k = cpu_to_be32(outlen * 8);\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\t__be32 i = cpu_to_be32(count);\n\tu8 zero = 0;\n\tint ret;\n\n\tdesc->tfm = tfm;\n\tret = crypto_shash_init(desc);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = crypto_shash_update(desc, step->data, step->len);\n\tif (ret)\n\t\tgoto out_err;\n\tret = crypto_shash_update(desc, (u8 *)&i, sizeof(i));\n\tif (ret)\n\t\tgoto out_err;\n\tret = crypto_shash_update(desc, constant->data, constant->len);\n\tif (ret)\n\t\tgoto out_err;\n\tret = crypto_shash_update(desc, &zero, sizeof(zero));\n\tif (ret)\n\t\tgoto out_err;\n\tret = crypto_shash_update(desc, (u8 *)&k, sizeof(k));\n\tif (ret)\n\t\tgoto out_err;\n\tret = crypto_shash_final(desc, step->data);\n\tif (ret)\n\t\tgoto out_err;\n\nout_err:\n\tshash_desc_zero(desc);\n\treturn ret;\n}\n\n \nint\nkrb5_kdf_feedback_cmac(const struct gss_krb5_enctype *gk5e,\n\t\t       const struct xdr_netobj *inkey,\n\t\t       struct xdr_netobj *outkey,\n\t\t       const struct xdr_netobj *constant,\n\t\t       gfp_t gfp_mask)\n{\n\tstruct xdr_netobj step = { .data = NULL };\n\tstruct xdr_netobj DR = { .data = NULL };\n\tunsigned int blocksize, offset;\n\tstruct crypto_shash *tfm;\n\tint n, count, ret;\n\n\t \n\ttfm = crypto_alloc_shash(gk5e->cksum_name, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out;\n\t}\n\tret = crypto_shash_setkey(tfm, inkey->data, inkey->len);\n\tif (ret)\n\t\tgoto out_free_tfm;\n\n\tblocksize = crypto_shash_digestsize(tfm);\n\tn = (outkey->len + blocksize - 1) / blocksize;\n\n\t \n\tret = -ENOMEM;\n\tstep.len = blocksize;\n\tstep.data = kzalloc(step.len, gfp_mask);\n\tif (!step.data)\n\t\tgoto out_free_tfm;\n\n\tDR.len = blocksize * n;\n\tDR.data = kmalloc(DR.len, gfp_mask);\n\tif (!DR.data)\n\t\tgoto out_free_tfm;\n\n\t \n\tfor (offset = 0, count = 1; count <= n; count++) {\n\t\tret = krb5_cmac_Ki(tfm, constant, outkey->len, count, &step);\n\t\tif (ret)\n\t\t\tgoto out_free_tfm;\n\n\t\tmemcpy(DR.data + offset, step.data, blocksize);\n\t\toffset += blocksize;\n\t}\n\n\t \n\tmemcpy(outkey->data, DR.data, outkey->len);\n\tret = 0;\n\nout_free_tfm:\n\tcrypto_free_shash(tfm);\nout:\n\tkfree_sensitive(step.data);\n\tkfree_sensitive(DR.data);\n\treturn ret;\n}\n\n \nstatic int\nkrb5_hmac_K1(struct crypto_shash *tfm, const struct xdr_netobj *label,\n\t     u32 outlen, struct xdr_netobj *K1)\n{\n\t__be32 k = cpu_to_be32(outlen * 8);\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\t__be32 one = cpu_to_be32(1);\n\tu8 zero = 0;\n\tint ret;\n\n\tdesc->tfm = tfm;\n\tret = crypto_shash_init(desc);\n\tif (ret)\n\t\tgoto out_err;\n\tret = crypto_shash_update(desc, (u8 *)&one, sizeof(one));\n\tif (ret)\n\t\tgoto out_err;\n\tret = crypto_shash_update(desc, label->data, label->len);\n\tif (ret)\n\t\tgoto out_err;\n\tret = crypto_shash_update(desc, &zero, sizeof(zero));\n\tif (ret)\n\t\tgoto out_err;\n\tret = crypto_shash_update(desc, (u8 *)&k, sizeof(k));\n\tif (ret)\n\t\tgoto out_err;\n\tret = crypto_shash_final(desc, K1->data);\n\tif (ret)\n\t\tgoto out_err;\n\nout_err:\n\tshash_desc_zero(desc);\n\treturn ret;\n}\n\n \nint\nkrb5_kdf_hmac_sha2(const struct gss_krb5_enctype *gk5e,\n\t\t   const struct xdr_netobj *inkey,\n\t\t   struct xdr_netobj *outkey,\n\t\t   const struct xdr_netobj *label,\n\t\t   gfp_t gfp_mask)\n{\n\tstruct crypto_shash *tfm;\n\tstruct xdr_netobj K1 = {\n\t\t.data = NULL,\n\t};\n\tint ret;\n\n\t \n\ttfm = crypto_alloc_shash(gk5e->cksum_name, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out;\n\t}\n\tret = crypto_shash_setkey(tfm, inkey->data, inkey->len);\n\tif (ret)\n\t\tgoto out_free_tfm;\n\n\tK1.len = crypto_shash_digestsize(tfm);\n\tK1.data = kmalloc(K1.len, gfp_mask);\n\tif (!K1.data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_tfm;\n\t}\n\n\tret = krb5_hmac_K1(tfm, label, outkey->len, &K1);\n\tif (ret)\n\t\tgoto out_free_tfm;\n\n\t \n\tmemcpy(outkey->data, K1.data, outkey->len);\n\nout_free_tfm:\n\tkfree_sensitive(K1.data);\n\tcrypto_free_shash(tfm);\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}