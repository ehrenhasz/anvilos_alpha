{
  "module_name": "gss_rpc_upcall.c",
  "hash_id": "55451b489e90715c31a2417a8a8e5a164d5672b49bba6e557beca58a61d6220e",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth_gss/gss_rpc_upcall.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/un.h>\n\n#include <linux/sunrpc/svcauth.h>\n#include \"gss_rpc_upcall.h\"\n\n#define GSSPROXY_SOCK_PATHNAME\t\"/var/run/gssproxy.sock\"\n\n#define GSSPROXY_PROGRAM\t(400112u)\n#define GSSPROXY_VERS_1\t\t(1u)\n\n \n\nenum {\n\tGSSX_NULL = 0,\t \n        GSSX_INDICATE_MECHS = 1,\n        GSSX_GET_CALL_CONTEXT = 2,\n        GSSX_IMPORT_AND_CANON_NAME = 3,\n        GSSX_EXPORT_CRED = 4,\n        GSSX_IMPORT_CRED = 5,\n        GSSX_ACQUIRE_CRED = 6,\n        GSSX_STORE_CRED = 7,\n        GSSX_INIT_SEC_CONTEXT = 8,\n        GSSX_ACCEPT_SEC_CONTEXT = 9,\n        GSSX_RELEASE_HANDLE = 10,\n        GSSX_GET_MIC = 11,\n        GSSX_VERIFY = 12,\n        GSSX_WRAP = 13,\n        GSSX_UNWRAP = 14,\n        GSSX_WRAP_SIZE_LIMIT = 15,\n};\n\n#define PROC(proc, name)\t\t\t\t\\\n[GSSX_##proc] = {\t\t\t\t\t\\\n\t.p_proc   = GSSX_##proc,\t\t\t\\\n\t.p_encode = gssx_enc_##name,\t\\\n\t.p_decode = gssx_dec_##name,\t\\\n\t.p_arglen = GSSX_ARG_##name##_sz,\t\t\\\n\t.p_replen = GSSX_RES_##name##_sz, \t\t\\\n\t.p_statidx = GSSX_##proc,\t\t\t\\\n\t.p_name   = #proc,\t\t\t\t\\\n}\n\nstatic const struct rpc_procinfo gssp_procedures[] = {\n\tPROC(INDICATE_MECHS, indicate_mechs),\n        PROC(GET_CALL_CONTEXT, get_call_context),\n        PROC(IMPORT_AND_CANON_NAME, import_and_canon_name),\n        PROC(EXPORT_CRED, export_cred),\n        PROC(IMPORT_CRED, import_cred),\n        PROC(ACQUIRE_CRED, acquire_cred),\n        PROC(STORE_CRED, store_cred),\n        PROC(INIT_SEC_CONTEXT, init_sec_context),\n        PROC(ACCEPT_SEC_CONTEXT, accept_sec_context),\n        PROC(RELEASE_HANDLE, release_handle),\n        PROC(GET_MIC, get_mic),\n        PROC(VERIFY, verify),\n        PROC(WRAP, wrap),\n        PROC(UNWRAP, unwrap),\n        PROC(WRAP_SIZE_LIMIT, wrap_size_limit),\n};\n\n\n\n \n\nstatic const struct rpc_program gssp_program;\n\nstatic int gssp_rpc_create(struct net *net, struct rpc_clnt **_clnt)\n{\n\tstatic const struct sockaddr_un gssp_localaddr = {\n\t\t.sun_family\t\t= AF_LOCAL,\n\t\t.sun_path\t\t= GSSPROXY_SOCK_PATHNAME,\n\t};\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= net,\n\t\t.protocol\t= XPRT_TRANSPORT_LOCAL,\n\t\t.address\t= (struct sockaddr *)&gssp_localaddr,\n\t\t.addrsize\t= sizeof(gssp_localaddr),\n\t\t.servername\t= \"localhost\",\n\t\t.program\t= &gssp_program,\n\t\t.version\t= GSSPROXY_VERS_1,\n\t\t.authflavor\t= RPC_AUTH_NULL,\n\t\t \n\t\t.flags\t\t= RPC_CLNT_CREATE_NOPING |\n\t\t\t\t  RPC_CLNT_CREATE_CONNECTED |\n\t\t\t\t  RPC_CLNT_CREATE_NO_IDLE_TIMEOUT\n\t};\n\tstruct rpc_clnt *clnt;\n\tint result = 0;\n\n\tclnt = rpc_create(&args);\n\tif (IS_ERR(clnt)) {\n\t\tdprintk(\"RPC:       failed to create AF_LOCAL gssproxy \"\n\t\t\t\t\"client (errno %ld).\\n\", PTR_ERR(clnt));\n\t\tresult = PTR_ERR(clnt);\n\t\t*_clnt = NULL;\n\t\tgoto out;\n\t}\n\n\tdprintk(\"RPC:       created new gssp local client (gssp_local_clnt: \"\n\t\t\t\"%p)\\n\", clnt);\n\t*_clnt = clnt;\n\nout:\n\treturn result;\n}\n\nvoid init_gssp_clnt(struct sunrpc_net *sn)\n{\n\tmutex_init(&sn->gssp_lock);\n\tsn->gssp_clnt = NULL;\n}\n\nint set_gssp_clnt(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct rpc_clnt *clnt;\n\tint ret;\n\n\tmutex_lock(&sn->gssp_lock);\n\tret = gssp_rpc_create(net, &clnt);\n\tif (!ret) {\n\t\tif (sn->gssp_clnt)\n\t\t\trpc_shutdown_client(sn->gssp_clnt);\n\t\tsn->gssp_clnt = clnt;\n\t}\n\tmutex_unlock(&sn->gssp_lock);\n\treturn ret;\n}\n\nvoid clear_gssp_clnt(struct sunrpc_net *sn)\n{\n\tmutex_lock(&sn->gssp_lock);\n\tif (sn->gssp_clnt) {\n\t\trpc_shutdown_client(sn->gssp_clnt);\n\t\tsn->gssp_clnt = NULL;\n\t}\n\tmutex_unlock(&sn->gssp_lock);\n}\n\nstatic struct rpc_clnt *get_gssp_clnt(struct sunrpc_net *sn)\n{\n\tstruct rpc_clnt *clnt;\n\n\tmutex_lock(&sn->gssp_lock);\n\tclnt = sn->gssp_clnt;\n\tif (clnt)\n\t\trefcount_inc(&clnt->cl_count);\n\tmutex_unlock(&sn->gssp_lock);\n\treturn clnt;\n}\n\nstatic int gssp_call(struct net *net, struct rpc_message *msg)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct rpc_clnt *clnt;\n\tint status;\n\n\tclnt = get_gssp_clnt(sn);\n\tif (!clnt)\n\t\treturn -EIO;\n\tstatus = rpc_call_sync(clnt, msg, 0);\n\tif (status < 0) {\n\t\tdprintk(\"gssp: rpc_call returned error %d\\n\", -status);\n\t\tswitch (status) {\n\t\tcase -EPROTONOSUPPORT:\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\tcase -ECONNREFUSED:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ENOTCONN:\n\t\t\tstatus = -EAGAIN;\n\t\t\tbreak;\n\t\tcase -ERESTARTSYS:\n\t\t\tif (signalled ())\n\t\t\t\tstatus = -EINTR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\trpc_release_client(clnt);\n\treturn status;\n}\n\nstatic void gssp_free_receive_pages(struct gssx_arg_accept_sec_context *arg)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < arg->npages && arg->pages[i]; i++)\n\t\t__free_page(arg->pages[i]);\n\n\tkfree(arg->pages);\n}\n\nstatic int gssp_alloc_receive_pages(struct gssx_arg_accept_sec_context *arg)\n{\n\tunsigned int i;\n\n\targ->npages = DIV_ROUND_UP(NGROUPS_MAX * 4, PAGE_SIZE);\n\targ->pages = kcalloc(arg->npages, sizeof(struct page *), GFP_KERNEL);\n\tif (!arg->pages)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < arg->npages; i++) {\n\t\targ->pages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!arg->pages[i]) {\n\t\t\tgssp_free_receive_pages(arg);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic char *gssp_stringify(struct xdr_netobj *netobj)\n{\n\treturn kmemdup_nul(netobj->data, netobj->len, GFP_KERNEL);\n}\n\nstatic void gssp_hostbased_service(char **principal)\n{\n\tchar *c;\n\n\tif (!*principal)\n\t\treturn;\n\n\t \n\tc = strchr(*principal, '@');\n\tif (c) {\n\t\t*c = '\\0';\n\n\t\t \n\t\tc = strchr(*principal, '/');\n\t\tif (c)\n\t\t\t*c = '@';\n\t}\n\tif (!c) {\n\t\t \n\t\tkfree(*principal);\n\t\t*principal = NULL;\n\t}\n}\n\n \n\n \n#define GSSX_MAX_OUT_HANDLE\t128\n#define GSSX_MAX_SRC_PRINC\t256\n#define GSSX_KMEMBUF (GSSX_max_output_handle_sz + \\\n\t\t\tGSSX_max_oid_sz + \\\n\t\t\tGSSX_max_princ_sz + \\\n\t\t\tsizeof(struct svc_cred))\n\nint gssp_accept_sec_context_upcall(struct net *net,\n\t\t\t\tstruct gssp_upcall_data *data)\n{\n\tstruct gssx_ctx ctxh = {\n\t\t.state = data->in_handle\n\t};\n\tstruct gssx_arg_accept_sec_context arg = {\n\t\t.input_token = data->in_token,\n\t};\n\tstruct gssx_ctx rctxh = {\n\t\t \n\t\t.exported_context_token.len = GSSX_max_output_handle_sz,\n\t\t.mech.len = GSS_OID_MAX_LEN,\n\t\t.targ_name.display_name.len = GSSX_max_princ_sz,\n\t\t.src_name.display_name.len = GSSX_max_princ_sz\n\t};\n\tstruct gssx_res_accept_sec_context res = {\n\t\t.context_handle = &rctxh,\n\t\t.output_token = &data->out_token\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &gssp_procedures[GSSX_ACCEPT_SEC_CONTEXT],\n\t\t.rpc_argp = &arg,\n\t\t.rpc_resp = &res,\n\t\t.rpc_cred = NULL,  \n\t};\n\tstruct xdr_netobj client_name = { 0 , NULL };\n\tstruct xdr_netobj target_name = { 0, NULL };\n\tint ret;\n\n\tif (data->in_handle.len != 0)\n\t\targ.context_handle = &ctxh;\n\tres.output_token->len = GSSX_max_output_token_sz;\n\n\tret = gssp_alloc_receive_pages(&arg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gssp_call(net, &msg);\n\n\tgssp_free_receive_pages(&arg);\n\n\t \n\tdata->major_status = res.status.major_status;\n\tdata->minor_status = res.status.minor_status;\n\tif (res.context_handle) {\n\t\tdata->out_handle = rctxh.exported_context_token;\n\t\tdata->mech_oid.len = rctxh.mech.len;\n\t\tif (rctxh.mech.data) {\n\t\t\tmemcpy(data->mech_oid.data, rctxh.mech.data,\n\t\t\t\t\t\tdata->mech_oid.len);\n\t\t\tkfree(rctxh.mech.data);\n\t\t}\n\t\tclient_name = rctxh.src_name.display_name;\n\t\ttarget_name = rctxh.targ_name.display_name;\n\t}\n\n\tif (res.options.count == 1) {\n\t\tgssx_buffer *value = &res.options.data[0].value;\n\t\t \n\t\tif (value->len == 1) {\n\t\t\t \n\t\t\tdata->creds = *(struct svc_cred *)value->data;\n\t\t\tdata->found_creds = 1;\n\t\t}\n\t\t \n\t\tkfree(value->data);\n\t}\n\n\tif (res.options.count != 0) {\n\t\tkfree(res.options.data);\n\t}\n\n\t \n\tif (data->found_creds) {\n\t\tif (client_name.data) {\n\t\t\tdata->creds.cr_raw_principal =\n\t\t\t\t\tgssp_stringify(&client_name);\n\t\t\tdata->creds.cr_principal =\n\t\t\t\t\tgssp_stringify(&client_name);\n\t\t\tgssp_hostbased_service(&data->creds.cr_principal);\n\t\t}\n\t\tif (target_name.data) {\n\t\t\tdata->creds.cr_targ_princ =\n\t\t\t\t\tgssp_stringify(&target_name);\n\t\t\tgssp_hostbased_service(&data->creds.cr_targ_princ);\n\t\t}\n\t}\n\tkfree(client_name.data);\n\tkfree(target_name.data);\n\n\treturn ret;\n}\n\nvoid gssp_free_upcall_data(struct gssp_upcall_data *data)\n{\n\tkfree(data->in_handle.data);\n\tkfree(data->out_handle.data);\n\tkfree(data->out_token.data);\n\tfree_svc_cred(&data->creds);\n}\n\n \nstatic unsigned int gssp_version1_counts[ARRAY_SIZE(gssp_procedures)];\nstatic const struct rpc_version gssp_version1 = {\n\t.number\t\t= GSSPROXY_VERS_1,\n\t.nrprocs\t= ARRAY_SIZE(gssp_procedures),\n\t.procs\t\t= gssp_procedures,\n\t.counts\t\t= gssp_version1_counts,\n};\n\nstatic const struct rpc_version *gssp_version[] = {\n\tNULL,\n\t&gssp_version1,\n};\n\nstatic struct rpc_stat gssp_stats;\n\nstatic const struct rpc_program gssp_program = {\n\t.name\t\t= \"gssproxy\",\n\t.number\t\t= GSSPROXY_PROGRAM,\n\t.nrvers\t\t= ARRAY_SIZE(gssp_version),\n\t.version\t= gssp_version,\n\t.stats\t\t= &gssp_stats,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}