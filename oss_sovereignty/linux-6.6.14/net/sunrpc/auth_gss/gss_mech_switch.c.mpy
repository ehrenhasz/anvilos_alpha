{
  "module_name": "gss_mech_switch.c",
  "hash_id": "41ade45a8bc467183224806d1c38b09ca54c48cf34b441f4ec41feae7acaeb6a",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth_gss/gss_mech_switch.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/oid_registry.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/gss_asn1.h>\n#include <linux/sunrpc/auth_gss.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/sunrpc/gss_err.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/clnt.h>\n#include <trace/events/rpcgss.h>\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n# define RPCDBG_FACILITY        RPCDBG_AUTH\n#endif\n\nstatic LIST_HEAD(registered_mechs);\nstatic DEFINE_SPINLOCK(registered_mechs_lock);\n\nstatic void\ngss_mech_free(struct gss_api_mech *gm)\n{\n\tstruct pf_desc *pf;\n\tint i;\n\n\tfor (i = 0; i < gm->gm_pf_num; i++) {\n\t\tpf = &gm->gm_pfs[i];\n\t\tif (pf->domain)\n\t\t\tauth_domain_put(pf->domain);\n\t\tkfree(pf->auth_domain_name);\n\t\tpf->auth_domain_name = NULL;\n\t}\n}\n\nstatic inline char *\nmake_auth_domain_name(char *name)\n{\n\tstatic char\t*prefix = \"gss/\";\n\tchar\t\t*new;\n\n\tnew = kmalloc(strlen(name) + strlen(prefix) + 1, GFP_KERNEL);\n\tif (new) {\n\t\tstrcpy(new, prefix);\n\t\tstrcat(new, name);\n\t}\n\treturn new;\n}\n\nstatic int\ngss_mech_svc_setup(struct gss_api_mech *gm)\n{\n\tstruct auth_domain *dom;\n\tstruct pf_desc *pf;\n\tint i, status;\n\n\tfor (i = 0; i < gm->gm_pf_num; i++) {\n\t\tpf = &gm->gm_pfs[i];\n\t\tpf->auth_domain_name = make_auth_domain_name(pf->name);\n\t\tstatus = -ENOMEM;\n\t\tif (pf->auth_domain_name == NULL)\n\t\t\tgoto out;\n\t\tdom = svcauth_gss_register_pseudoflavor(\n\t\t\tpf->pseudoflavor, pf->auth_domain_name);\n\t\tif (IS_ERR(dom)) {\n\t\t\tstatus = PTR_ERR(dom);\n\t\t\tgoto out;\n\t\t}\n\t\tpf->domain = dom;\n\t}\n\treturn 0;\nout:\n\tgss_mech_free(gm);\n\treturn status;\n}\n\n \nint gss_mech_register(struct gss_api_mech *gm)\n{\n\tint status;\n\n\tstatus = gss_mech_svc_setup(gm);\n\tif (status)\n\t\treturn status;\n\tspin_lock(&registered_mechs_lock);\n\tlist_add_rcu(&gm->gm_list, &registered_mechs);\n\tspin_unlock(&registered_mechs_lock);\n\tdprintk(\"RPC:       registered gss mechanism %s\\n\", gm->gm_name);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gss_mech_register);\n\n \nvoid gss_mech_unregister(struct gss_api_mech *gm)\n{\n\tspin_lock(&registered_mechs_lock);\n\tlist_del_rcu(&gm->gm_list);\n\tspin_unlock(&registered_mechs_lock);\n\tdprintk(\"RPC:       unregistered gss mechanism %s\\n\", gm->gm_name);\n\tgss_mech_free(gm);\n}\nEXPORT_SYMBOL_GPL(gss_mech_unregister);\n\nstruct gss_api_mech *gss_mech_get(struct gss_api_mech *gm)\n{\n\t__module_get(gm->gm_owner);\n\treturn gm;\n}\nEXPORT_SYMBOL(gss_mech_get);\n\nstatic struct gss_api_mech *\n_gss_mech_get_by_name(const char *name)\n{\n\tstruct gss_api_mech\t*pos, *gm = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &registered_mechs, gm_list) {\n\t\tif (0 == strcmp(name, pos->gm_name)) {\n\t\t\tif (try_module_get(pos->gm_owner))\n\t\t\t\tgm = pos;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn gm;\n\n}\n\nstruct gss_api_mech * gss_mech_get_by_name(const char *name)\n{\n\tstruct gss_api_mech *gm = NULL;\n\n\tgm = _gss_mech_get_by_name(name);\n\tif (!gm) {\n\t\trequest_module(\"rpc-auth-gss-%s\", name);\n\t\tgm = _gss_mech_get_by_name(name);\n\t}\n\treturn gm;\n}\n\nstruct gss_api_mech *gss_mech_get_by_OID(struct rpcsec_gss_oid *obj)\n{\n\tstruct gss_api_mech\t*pos, *gm = NULL;\n\tchar buf[32];\n\n\tif (sprint_oid(obj->data, obj->len, buf, sizeof(buf)) < 0)\n\t\treturn NULL;\n\trequest_module(\"rpc-auth-gss-%s\", buf);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &registered_mechs, gm_list) {\n\t\tif (obj->len == pos->gm_oid.len) {\n\t\t\tif (0 == memcmp(obj->data, pos->gm_oid.data, obj->len)) {\n\t\t\t\tif (try_module_get(pos->gm_owner))\n\t\t\t\t\tgm = pos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (!gm)\n\t\ttrace_rpcgss_oid_to_mech(buf);\n\treturn gm;\n}\n\nstatic inline int\nmech_supports_pseudoflavor(struct gss_api_mech *gm, u32 pseudoflavor)\n{\n\tint i;\n\n\tfor (i = 0; i < gm->gm_pf_num; i++) {\n\t\tif (gm->gm_pfs[i].pseudoflavor == pseudoflavor)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic struct gss_api_mech *_gss_mech_get_by_pseudoflavor(u32 pseudoflavor)\n{\n\tstruct gss_api_mech *gm = NULL, *pos;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &registered_mechs, gm_list) {\n\t\tif (!mech_supports_pseudoflavor(pos, pseudoflavor))\n\t\t\tcontinue;\n\t\tif (try_module_get(pos->gm_owner))\n\t\t\tgm = pos;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn gm;\n}\n\nstruct gss_api_mech *\ngss_mech_get_by_pseudoflavor(u32 pseudoflavor)\n{\n\tstruct gss_api_mech *gm;\n\n\tgm = _gss_mech_get_by_pseudoflavor(pseudoflavor);\n\n\tif (!gm) {\n\t\trequest_module(\"rpc-auth-gss-%u\", pseudoflavor);\n\t\tgm = _gss_mech_get_by_pseudoflavor(pseudoflavor);\n\t}\n\treturn gm;\n}\n\n \nrpc_authflavor_t gss_svc_to_pseudoflavor(struct gss_api_mech *gm, u32 qop,\n\t\t\t\t\t u32 service)\n{\n\tint i;\n\n\tfor (i = 0; i < gm->gm_pf_num; i++) {\n\t\tif (gm->gm_pfs[i].qop == qop &&\n\t\t    gm->gm_pfs[i].service == service) {\n\t\t\treturn gm->gm_pfs[i].pseudoflavor;\n\t\t}\n\t}\n\treturn RPC_AUTH_MAXFLAVOR;\n}\n\n \nrpc_authflavor_t gss_mech_info2flavor(struct rpcsec_gss_info *info)\n{\n\trpc_authflavor_t pseudoflavor;\n\tstruct gss_api_mech *gm;\n\n\tgm = gss_mech_get_by_OID(&info->oid);\n\tif (gm == NULL)\n\t\treturn RPC_AUTH_MAXFLAVOR;\n\n\tpseudoflavor = gss_svc_to_pseudoflavor(gm, info->qop, info->service);\n\n\tgss_mech_put(gm);\n\treturn pseudoflavor;\n}\n\n \nint gss_mech_flavor2info(rpc_authflavor_t pseudoflavor,\n\t\t\t struct rpcsec_gss_info *info)\n{\n\tstruct gss_api_mech *gm;\n\tint i;\n\n\tgm = gss_mech_get_by_pseudoflavor(pseudoflavor);\n\tif (gm == NULL)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < gm->gm_pf_num; i++) {\n\t\tif (gm->gm_pfs[i].pseudoflavor == pseudoflavor) {\n\t\t\tmemcpy(info->oid.data, gm->gm_oid.data, gm->gm_oid.len);\n\t\t\tinfo->oid.len = gm->gm_oid.len;\n\t\t\tinfo->qop = gm->gm_pfs[i].qop;\n\t\t\tinfo->service = gm->gm_pfs[i].service;\n\t\t\tgss_mech_put(gm);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tgss_mech_put(gm);\n\treturn -ENOENT;\n}\n\nu32\ngss_pseudoflavor_to_service(struct gss_api_mech *gm, u32 pseudoflavor)\n{\n\tint i;\n\n\tfor (i = 0; i < gm->gm_pf_num; i++) {\n\t\tif (gm->gm_pfs[i].pseudoflavor == pseudoflavor)\n\t\t\treturn gm->gm_pfs[i].service;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(gss_pseudoflavor_to_service);\n\nbool\ngss_pseudoflavor_to_datatouch(struct gss_api_mech *gm, u32 pseudoflavor)\n{\n\tint i;\n\n\tfor (i = 0; i < gm->gm_pf_num; i++) {\n\t\tif (gm->gm_pfs[i].pseudoflavor == pseudoflavor)\n\t\t\treturn gm->gm_pfs[i].datatouch;\n\t}\n\treturn false;\n}\n\nchar *\ngss_service_to_auth_domain_name(struct gss_api_mech *gm, u32 service)\n{\n\tint i;\n\n\tfor (i = 0; i < gm->gm_pf_num; i++) {\n\t\tif (gm->gm_pfs[i].service == service)\n\t\t\treturn gm->gm_pfs[i].auth_domain_name;\n\t}\n\treturn NULL;\n}\n\nvoid\ngss_mech_put(struct gss_api_mech * gm)\n{\n\tif (gm)\n\t\tmodule_put(gm->gm_owner);\n}\nEXPORT_SYMBOL(gss_mech_put);\n\n \nint\ngss_import_sec_context(const void *input_token, size_t bufsize,\n\t\t       struct gss_api_mech\t*mech,\n\t\t       struct gss_ctx\t\t**ctx_id,\n\t\t       time64_t\t\t\t*endtime,\n\t\t       gfp_t gfp_mask)\n{\n\tif (!(*ctx_id = kzalloc(sizeof(**ctx_id), gfp_mask)))\n\t\treturn -ENOMEM;\n\t(*ctx_id)->mech_type = gss_mech_get(mech);\n\n\treturn mech->gm_ops->gss_import_sec_context(input_token, bufsize,\n\t\t\t\t\t\t*ctx_id, endtime, gfp_mask);\n}\n\n \n\nu32\ngss_get_mic(struct gss_ctx\t*context_handle,\n\t    struct xdr_buf\t*message,\n\t    struct xdr_netobj\t*mic_token)\n{\n\t return context_handle->mech_type->gm_ops\n\t\t->gss_get_mic(context_handle,\n\t\t\t      message,\n\t\t\t      mic_token);\n}\n\n \n\nu32\ngss_verify_mic(struct gss_ctx\t\t*context_handle,\n\t       struct xdr_buf\t\t*message,\n\t       struct xdr_netobj\t*mic_token)\n{\n\treturn context_handle->mech_type->gm_ops\n\t\t->gss_verify_mic(context_handle,\n\t\t\t\t message,\n\t\t\t\t mic_token);\n}\n\n \nu32\ngss_wrap(struct gss_ctx\t*ctx_id,\n\t int\t\toffset,\n\t struct xdr_buf\t*buf,\n\t struct page\t**inpages)\n{\n\treturn ctx_id->mech_type->gm_ops\n\t\t->gss_wrap(ctx_id, offset, buf, inpages);\n}\n\nu32\ngss_unwrap(struct gss_ctx\t*ctx_id,\n\t   int\t\t\toffset,\n\t   int\t\t\tlen,\n\t   struct xdr_buf\t*buf)\n{\n\treturn ctx_id->mech_type->gm_ops\n\t\t->gss_unwrap(ctx_id, offset, len, buf);\n}\n\n\n \n\nu32\ngss_delete_sec_context(struct gss_ctx\t**context_handle)\n{\n\tdprintk(\"RPC:       gss_delete_sec_context deleting %p\\n\",\n\t\t\t*context_handle);\n\n\tif (!*context_handle)\n\t\treturn GSS_S_NO_CONTEXT;\n\tif ((*context_handle)->internal_ctx_id)\n\t\t(*context_handle)->mech_type->gm_ops\n\t\t\t->gss_delete_sec_context((*context_handle)\n\t\t\t\t\t\t\t->internal_ctx_id);\n\tgss_mech_put((*context_handle)->mech_type);\n\tkfree(*context_handle);\n\t*context_handle=NULL;\n\treturn GSS_S_COMPLETE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}