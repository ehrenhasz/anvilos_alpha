{
  "module_name": "gss_generic_token.c",
  "hash_id": "2e1e18fc369428a0627614e1df1e5b4425c837c6164e297b45159cdfece9d293",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth_gss/gss_generic_token.c",
  "human_readable_source": " \n\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/gss_asn1.h>\n\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n# define RPCDBG_FACILITY        RPCDBG_AUTH\n#endif\n\n\n \n#define TWRITE_STR(ptr, str, len) \\\n\tmemcpy((ptr), (char *) (str), (len)); \\\n\t(ptr) += (len);\n\n \n\n \n\nstatic int\nder_length_size( int length)\n{\n\tif (length < (1<<7))\n\t\treturn 1;\n\telse if (length < (1<<8))\n\t\treturn 2;\n#if (SIZEOF_INT == 2)\n\telse\n\t\treturn 3;\n#else\n\telse if (length < (1<<16))\n\t\treturn 3;\n\telse if (length < (1<<24))\n\t\treturn 4;\n\telse\n\t\treturn 5;\n#endif\n}\n\nstatic void\nder_write_length(unsigned char **buf, int length)\n{\n\tif (length < (1<<7)) {\n\t\t*(*buf)++ = (unsigned char) length;\n\t} else {\n\t\t*(*buf)++ = (unsigned char) (der_length_size(length)+127);\n#if (SIZEOF_INT > 2)\n\t\tif (length >= (1<<24))\n\t\t\t*(*buf)++ = (unsigned char) (length>>24);\n\t\tif (length >= (1<<16))\n\t\t\t*(*buf)++ = (unsigned char) ((length>>16)&0xff);\n#endif\n\t\tif (length >= (1<<8))\n\t\t\t*(*buf)++ = (unsigned char) ((length>>8)&0xff);\n\t\t*(*buf)++ = (unsigned char) (length&0xff);\n\t}\n}\n\n \n\nstatic int\nder_read_length(unsigned char **buf, int *bufsize)\n{\n\tunsigned char sf;\n\tint ret;\n\n\tif (*bufsize < 1)\n\t\treturn -1;\n\tsf = *(*buf)++;\n\t(*bufsize)--;\n\tif (sf & 0x80) {\n\t\tif ((sf &= 0x7f) > ((*bufsize)-1))\n\t\t\treturn -1;\n\t\tif (sf > SIZEOF_INT)\n\t\t\treturn -1;\n\t\tret = 0;\n\t\tfor (; sf; sf--) {\n\t\t\tret = (ret<<8) + (*(*buf)++);\n\t\t\t(*bufsize)--;\n\t\t}\n\t} else {\n\t\tret = sf;\n\t}\n\n\treturn ret;\n}\n\n \n\nint\ng_token_size(struct xdr_netobj *mech, unsigned int body_size)\n{\n\t \n\tbody_size += 2 + (int) mech->len;          \n\treturn 1 + der_length_size(body_size) + body_size;\n}\n\nEXPORT_SYMBOL_GPL(g_token_size);\n\n \n\nvoid\ng_make_token_header(struct xdr_netobj *mech, int body_size, unsigned char **buf)\n{\n\t*(*buf)++ = 0x60;\n\tder_write_length(buf, 2 + mech->len + body_size);\n\t*(*buf)++ = 0x06;\n\t*(*buf)++ = (unsigned char) mech->len;\n\tTWRITE_STR(*buf, mech->data, ((int) mech->len));\n}\n\nEXPORT_SYMBOL_GPL(g_make_token_header);\n\n \nu32\ng_verify_token_header(struct xdr_netobj *mech, int *body_size,\n\t\t      unsigned char **buf_in, int toksize)\n{\n\tunsigned char *buf = *buf_in;\n\tint seqsize;\n\tstruct xdr_netobj toid;\n\tint ret = 0;\n\n\tif ((toksize-=1) < 0)\n\t\treturn G_BAD_TOK_HEADER;\n\tif (*buf++ != 0x60)\n\t\treturn G_BAD_TOK_HEADER;\n\n\tif ((seqsize = der_read_length(&buf, &toksize)) < 0)\n\t\treturn G_BAD_TOK_HEADER;\n\n\tif (seqsize != toksize)\n\t\treturn G_BAD_TOK_HEADER;\n\n\tif ((toksize-=1) < 0)\n\t\treturn G_BAD_TOK_HEADER;\n\tif (*buf++ != 0x06)\n\t\treturn G_BAD_TOK_HEADER;\n\n\tif ((toksize-=1) < 0)\n\t\treturn G_BAD_TOK_HEADER;\n\ttoid.len = *buf++;\n\n\tif ((toksize-=toid.len) < 0)\n\t\treturn G_BAD_TOK_HEADER;\n\ttoid.data = buf;\n\tbuf+=toid.len;\n\n\tif (! g_OID_equal(&toid, mech))\n\t\tret = G_WRONG_MECH;\n\n    \n\n\tif ((toksize-=2) < 0)\n\t\treturn G_BAD_TOK_HEADER;\n\n\tif (ret)\n\t\treturn ret;\n\n\t*buf_in = buf;\n\t*body_size = toksize;\n\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(g_verify_token_header);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}