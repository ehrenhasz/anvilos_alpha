{
  "module_name": "gss_krb5_unseal.c",
  "hash_id": "c477a5d88b1f7113ec154adb2cf8b2553cb624a7fcc4585fec0280f8afeb2529",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth_gss/gss_krb5_unseal.c",
  "human_readable_source": " \n\n \n\n \n\n#include <crypto/algapi.h>\n#include <linux/types.h>\n#include <linux/jiffies.h>\n#include <linux/sunrpc/gss_krb5.h>\n#include <linux/crypto.h>\n\n#include \"gss_krb5_internal.h\"\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n# define RPCDBG_FACILITY        RPCDBG_AUTH\n#endif\n\nu32\ngss_krb5_verify_mic_v2(struct krb5_ctx *ctx, struct xdr_buf *message_buffer,\n\t\t       struct xdr_netobj *read_token)\n{\n\tstruct crypto_ahash *tfm = ctx->initiate ?\n\t\t\t\t   ctx->acceptor_sign : ctx->initiator_sign;\n\tchar cksumdata[GSS_KRB5_MAX_CKSUM_LEN];\n\tstruct xdr_netobj cksumobj = {\n\t\t.len\t= ctx->gk5e->cksumlength,\n\t\t.data\t= cksumdata,\n\t};\n\tu8 *ptr = read_token->data;\n\t__be16 be16_ptr;\n\ttime64_t now;\n\tu8 flags;\n\tint i;\n\n\tdprintk(\"RPC:       %s\\n\", __func__);\n\n\tmemcpy(&be16_ptr, (char *) ptr, 2);\n\tif (be16_to_cpu(be16_ptr) != KG2_TOK_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tflags = ptr[2];\n\tif ((!ctx->initiate && (flags & KG2_TOKEN_FLAG_SENTBYACCEPTOR)) ||\n\t    (ctx->initiate && !(flags & KG2_TOKEN_FLAG_SENTBYACCEPTOR)))\n\t\treturn GSS_S_BAD_SIG;\n\n\tif (flags & KG2_TOKEN_FLAG_SEALED) {\n\t\tdprintk(\"%s: token has unexpected sealed flag\\n\", __func__);\n\t\treturn GSS_S_FAILURE;\n\t}\n\n\tfor (i = 3; i < 8; i++)\n\t\tif (ptr[i] != 0xff)\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tif (gss_krb5_checksum(tfm, ptr, GSS_KRB5_TOK_HDR_LEN,\n\t\t\t      message_buffer, 0, &cksumobj))\n\t\treturn GSS_S_FAILURE;\n\n\tif (memcmp(cksumobj.data, ptr + GSS_KRB5_TOK_HDR_LEN,\n\t\t\t\tctx->gk5e->cksumlength))\n\t\treturn GSS_S_BAD_SIG;\n\n\t \n\tnow = ktime_get_real_seconds();\n\tif (now > ctx->endtime)\n\t\treturn GSS_S_CONTEXT_EXPIRED;\n\n\t \n\n\treturn GSS_S_COMPLETE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}