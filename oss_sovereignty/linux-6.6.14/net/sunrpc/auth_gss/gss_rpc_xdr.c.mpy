{
  "module_name": "gss_rpc_xdr.c",
  "hash_id": "72efd0454f71578eb6461439f032d923fc085f529b193e8ad2aa59f8e88898a1",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth_gss/gss_rpc_xdr.c",
  "human_readable_source": "\n \n\n#include <linux/sunrpc/svcauth.h>\n#include \"gss_rpc_xdr.h\"\n\nstatic int gssx_enc_bool(struct xdr_stream *xdr, int v)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOSPC;\n\t*p = v ? xdr_one : xdr_zero;\n\treturn 0;\n}\n\nstatic int gssx_dec_bool(struct xdr_stream *xdr, u32 *v)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOSPC;\n\t*v = be32_to_cpu(*p);\n\treturn 0;\n}\n\nstatic int gssx_enc_buffer(struct xdr_stream *xdr,\n\t\t\t   const gssx_buffer *buf)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(u32) + buf->len);\n\tif (!p)\n\t\treturn -ENOSPC;\n\txdr_encode_opaque(p, buf->data, buf->len);\n\treturn 0;\n}\n\nstatic int gssx_enc_in_token(struct xdr_stream *xdr,\n\t\t\t     const struct gssp_in_token *in)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn -ENOSPC;\n\t*p = cpu_to_be32(in->page_len);\n\n\t \n\txdr_write_pages(xdr, in->pages, in->page_base, in->page_len);\n\n\treturn 0;\n}\n\n\nstatic int gssx_dec_buffer(struct xdr_stream *xdr,\n\t\t\t   gssx_buffer *buf)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOSPC;\n\n\tlength = be32_to_cpup(p);\n\tp = xdr_inline_decode(xdr, length);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOSPC;\n\n\tif (buf->len == 0) {\n\t\t \n\t\treturn 0;\n\t}\n\tif (length > buf->len)\n\t\treturn -ENOSPC;\n\n\tif (!buf->data) {\n\t\tbuf->data = kmemdup(p, length, GFP_KERNEL);\n\t\tif (!buf->data)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tmemcpy(buf->data, p, length);\n\t}\n\tbuf->len = length;\n\treturn 0;\n}\n\nstatic int gssx_enc_option(struct xdr_stream *xdr,\n\t\t\t   struct gssx_option *opt)\n{\n\tint err;\n\n\terr = gssx_enc_buffer(xdr, &opt->option);\n\tif (err)\n\t\treturn err;\n\terr = gssx_enc_buffer(xdr, &opt->value);\n\treturn err;\n}\n\nstatic int gssx_dec_option(struct xdr_stream *xdr,\n\t\t\t   struct gssx_option *opt)\n{\n\tint err;\n\n\terr = gssx_dec_buffer(xdr, &opt->option);\n\tif (err)\n\t\treturn err;\n\terr = gssx_dec_buffer(xdr, &opt->value);\n\treturn err;\n}\n\nstatic int dummy_enc_opt_array(struct xdr_stream *xdr,\n\t\t\t\tconst struct gssx_option_array *oa)\n{\n\t__be32 *p;\n\n\tif (oa->count != 0)\n\t\treturn -EINVAL;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn -ENOSPC;\n\t*p = 0;\n\n\treturn 0;\n}\n\nstatic int dummy_dec_opt_array(struct xdr_stream *xdr,\n\t\t\t\tstruct gssx_option_array *oa)\n{\n\tstruct gssx_option dummy;\n\tu32 count, i;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOSPC;\n\tcount = be32_to_cpup(p++);\n\tmemset(&dummy, 0, sizeof(dummy));\n\tfor (i = 0; i < count; i++) {\n\t\tgssx_dec_option(xdr, &dummy);\n\t}\n\n\toa->count = 0;\n\toa->data = NULL;\n\treturn 0;\n}\n\nstatic int get_host_u32(struct xdr_stream *xdr, u32 *res)\n{\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (!p)\n\t\treturn -EINVAL;\n\t \n\tmemcpy(res, p, sizeof(u32));\n\treturn 0;\n}\n\nstatic int gssx_dec_linux_creds(struct xdr_stream *xdr,\n\t\t\t\tstruct svc_cred *creds)\n{\n\tu32 length;\n\t__be32 *p;\n\tu32 tmp;\n\tu32 N;\n\tint i, err;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOSPC;\n\n\tlength = be32_to_cpup(p);\n\n\tif (length > (3 + NGROUPS_MAX) * sizeof(u32))\n\t\treturn -ENOSPC;\n\n\t \n\terr = get_host_u32(xdr, &tmp);\n\tif (err)\n\t\treturn err;\n\tcreds->cr_uid = make_kuid(&init_user_ns, tmp);\n\n\t \n\terr = get_host_u32(xdr, &tmp);\n\tif (err)\n\t\treturn err;\n\tcreds->cr_gid = make_kgid(&init_user_ns, tmp);\n\n\t \n\terr = get_host_u32(xdr, &tmp);\n\tif (err)\n\t\treturn err;\n\tN = tmp;\n\tif ((3 + N) * sizeof(u32) != length)\n\t\treturn -EINVAL;\n\tcreds->cr_group_info = groups_alloc(N);\n\tif (creds->cr_group_info == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < N; i++) {\n\t\tkgid_t kgid;\n\t\terr = get_host_u32(xdr, &tmp);\n\t\tif (err)\n\t\t\tgoto out_free_groups;\n\t\terr = -EINVAL;\n\t\tkgid = make_kgid(&init_user_ns, tmp);\n\t\tif (!gid_valid(kgid))\n\t\t\tgoto out_free_groups;\n\t\tcreds->cr_group_info->gid[i] = kgid;\n\t}\n\tgroups_sort(creds->cr_group_info);\n\n\treturn 0;\nout_free_groups:\n\tgroups_free(creds->cr_group_info);\n\treturn err;\n}\n\nstatic int gssx_dec_option_array(struct xdr_stream *xdr,\n\t\t\t\t struct gssx_option_array *oa)\n{\n\tstruct svc_cred *creds;\n\tu32 count, i;\n\t__be32 *p;\n\tint err;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOSPC;\n\tcount = be32_to_cpup(p++);\n\tif (!count)\n\t\treturn 0;\n\n\t \n\toa->count = 1;\n\n\toa->data = kmalloc(sizeof(struct gssx_option), GFP_KERNEL);\n\tif (!oa->data)\n\t\treturn -ENOMEM;\n\n\tcreds = kzalloc(sizeof(struct svc_cred), GFP_KERNEL);\n\tif (!creds) {\n\t\tkfree(oa->data);\n\t\treturn -ENOMEM;\n\t}\n\n\toa->data[0].option.data = CREDS_VALUE;\n\toa->data[0].option.len = sizeof(CREDS_VALUE);\n\toa->data[0].value.data = (void *)creds;\n\toa->data[0].value.len = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgssx_buffer dummy = { 0, NULL };\n\t\tu32 length;\n\n\t\t \n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn -ENOSPC;\n\n\t\tlength = be32_to_cpup(p);\n\t\tp = xdr_inline_decode(xdr, length);\n\t\tif (unlikely(p == NULL))\n\t\t\treturn -ENOSPC;\n\n\t\tif (length == sizeof(CREDS_VALUE) &&\n\t\t    memcmp(p, CREDS_VALUE, sizeof(CREDS_VALUE)) == 0) {\n\t\t\t \n\t\t\terr = gssx_dec_linux_creds(xdr, creds);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\toa->data[0].value.len = 1;  \n\t\t} else {\n\t\t\t \n\t\t\terr = gssx_dec_buffer(xdr, &dummy);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int gssx_dec_status(struct xdr_stream *xdr,\n\t\t\t   struct gssx_status *status)\n{\n\t__be32 *p;\n\tint err;\n\n\t \n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOSPC;\n\tp = xdr_decode_hyper(p, &status->major_status);\n\n\t \n\terr = gssx_dec_buffer(xdr, &status->mech);\n\tif (err)\n\t\treturn err;\n\n\t \n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOSPC;\n\tp = xdr_decode_hyper(p, &status->minor_status);\n\n\t \n\terr = gssx_dec_buffer(xdr, &status->major_status_string);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_dec_buffer(xdr, &status->minor_status_string);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_dec_buffer(xdr, &status->server_ctx);\n\tif (err)\n\t\treturn err;\n\n\t \n\t \n\terr = dummy_dec_opt_array(xdr, &status->options);\n\n\treturn err;\n}\n\nstatic int gssx_enc_call_ctx(struct xdr_stream *xdr,\n\t\t\t     const struct gssx_call_ctx *ctx)\n{\n\tstruct gssx_option opt;\n\t__be32 *p;\n\tint err;\n\n\t \n\terr = gssx_enc_buffer(xdr, &ctx->locale);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_buffer(xdr, &ctx->server_ctx);\n\tif (err)\n\t\treturn err;\n\n\t \n\t \n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(2);\n\n\t \n\topt.option.data = LUCID_OPTION;\n\topt.option.len = sizeof(LUCID_OPTION);\n\topt.value.data = LUCID_VALUE;\n\topt.value.len = sizeof(LUCID_VALUE);\n\terr = gssx_enc_option(xdr, &opt);\n\n\t \n\topt.option.data = CREDS_OPTION;\n\topt.option.len = sizeof(CREDS_OPTION);\n\topt.value.data = CREDS_VALUE;\n\topt.value.len = sizeof(CREDS_VALUE);\n\terr = gssx_enc_option(xdr, &opt);\n\n\treturn err;\n}\n\nstatic int gssx_dec_name_attr(struct xdr_stream *xdr,\n\t\t\t     struct gssx_name_attr *attr)\n{\n\tint err;\n\n\t \n\terr = gssx_dec_buffer(xdr, &attr->attr);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_dec_buffer(xdr, &attr->value);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = dummy_dec_opt_array(xdr, &attr->extensions);\n\n\treturn err;\n}\n\nstatic int dummy_enc_nameattr_array(struct xdr_stream *xdr,\n\t\t\t\t    struct gssx_name_attr_array *naa)\n{\n\t__be32 *p;\n\n\tif (naa->count != 0)\n\t\treturn -EINVAL;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn -ENOSPC;\n\t*p = 0;\n\n\treturn 0;\n}\n\nstatic int dummy_dec_nameattr_array(struct xdr_stream *xdr,\n\t\t\t\t    struct gssx_name_attr_array *naa)\n{\n\tstruct gssx_name_attr dummy = { .attr = {.len = 0} };\n\tu32 count, i;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOSPC;\n\tcount = be32_to_cpup(p++);\n\tfor (i = 0; i < count; i++) {\n\t\tgssx_dec_name_attr(xdr, &dummy);\n\t}\n\n\tnaa->count = 0;\n\tnaa->data = NULL;\n\treturn 0;\n}\n\nstatic struct xdr_netobj zero_netobj = {};\n\nstatic struct gssx_name_attr_array zero_name_attr_array = {};\n\nstatic struct gssx_option_array zero_option_array = {};\n\nstatic int gssx_enc_name(struct xdr_stream *xdr,\n\t\t\t struct gssx_name *name)\n{\n\tint err;\n\n\t \n\terr = gssx_enc_buffer(xdr, &name->display_name);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_buffer(xdr, &zero_netobj);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_buffer(xdr, &zero_netobj);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_buffer(xdr, &zero_netobj);\n\tif (err)\n\t\treturn err;\n\n\t \n\t \n\terr = dummy_enc_nameattr_array(xdr, &zero_name_attr_array);\n\tif (err)\n\t\treturn err;\n\n\t \n\t \n\terr = dummy_enc_opt_array(xdr, &zero_option_array);\n\n\treturn err;\n}\n\n\nstatic int gssx_dec_name(struct xdr_stream *xdr,\n\t\t\t struct gssx_name *name)\n{\n\tstruct xdr_netobj dummy_netobj = { .len = 0 };\n\tstruct gssx_name_attr_array dummy_name_attr_array = { .count = 0 };\n\tstruct gssx_option_array dummy_option_array = { .count = 0 };\n\tint err;\n\n\t \n\terr = gssx_dec_buffer(xdr, &name->display_name);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_dec_buffer(xdr, &dummy_netobj);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_dec_buffer(xdr, &dummy_netobj);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_dec_buffer(xdr, &dummy_netobj);\n\tif (err)\n\t\treturn err;\n\n\t \n\t \n\terr = dummy_dec_nameattr_array(xdr, &dummy_name_attr_array);\n\tif (err)\n\t\treturn err;\n\n\t \n\t \n\terr = dummy_dec_opt_array(xdr, &dummy_option_array);\n\n\treturn err;\n}\n\nstatic int dummy_enc_credel_array(struct xdr_stream *xdr,\n\t\t\t\t  struct gssx_cred_element_array *cea)\n{\n\t__be32 *p;\n\n\tif (cea->count != 0)\n\t\treturn -EINVAL;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn -ENOSPC;\n\t*p = 0;\n\n\treturn 0;\n}\n\nstatic int gssx_enc_cred(struct xdr_stream *xdr,\n\t\t\t struct gssx_cred *cred)\n{\n\tint err;\n\n\t \n\terr = gssx_enc_name(xdr, &cred->desired_name);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = dummy_enc_credel_array(xdr, &cred->elements);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_buffer(xdr, &cred->cred_handle_reference);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_bool(xdr, cred->needs_release);\n\n\treturn err;\n}\n\nstatic int gssx_enc_ctx(struct xdr_stream *xdr,\n\t\t\tstruct gssx_ctx *ctx)\n{\n\t__be32 *p;\n\tint err;\n\n\t \n\terr = gssx_enc_buffer(xdr, &ctx->exported_context_token);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_buffer(xdr, &ctx->state);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_bool(xdr, ctx->need_release);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_buffer(xdr, &ctx->mech);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_name(xdr, &ctx->src_name);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_name(xdr, &ctx->targ_name);\n\tif (err)\n\t\treturn err;\n\n\t \n\tp = xdr_reserve_space(xdr, 8+8);\n\tif (!p)\n\t\treturn -ENOSPC;\n\tp = xdr_encode_hyper(p, ctx->lifetime);\n\n\t \n\tp = xdr_encode_hyper(p, ctx->ctx_flags);\n\n\t \n\terr = gssx_enc_bool(xdr, ctx->locally_initiated);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_bool(xdr, ctx->open);\n\tif (err)\n\t\treturn err;\n\n\t \n\t \n\terr = dummy_enc_opt_array(xdr, &ctx->options);\n\n\treturn err;\n}\n\nstatic int gssx_dec_ctx(struct xdr_stream *xdr,\n\t\t\tstruct gssx_ctx *ctx)\n{\n\t__be32 *p;\n\tint err;\n\n\t \n\terr = gssx_dec_buffer(xdr, &ctx->exported_context_token);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_dec_buffer(xdr, &ctx->state);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_dec_bool(xdr, &ctx->need_release);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_dec_buffer(xdr, &ctx->mech);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_dec_name(xdr, &ctx->src_name);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_dec_name(xdr, &ctx->targ_name);\n\tif (err)\n\t\treturn err;\n\n\t \n\tp = xdr_inline_decode(xdr, 8+8);\n\tif (unlikely(p == NULL))\n\t\treturn -ENOSPC;\n\tp = xdr_decode_hyper(p, &ctx->lifetime);\n\n\t \n\tp = xdr_decode_hyper(p, &ctx->ctx_flags);\n\n\t \n\terr = gssx_dec_bool(xdr, &ctx->locally_initiated);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_dec_bool(xdr, &ctx->open);\n\tif (err)\n\t\treturn err;\n\n\t \n\t \n\terr = dummy_dec_opt_array(xdr, &ctx->options);\n\n\treturn err;\n}\n\nstatic int gssx_enc_cb(struct xdr_stream *xdr, struct gssx_cb *cb)\n{\n\t__be32 *p;\n\tint err;\n\n\t \n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p)\n\t\treturn -ENOSPC;\n\tp = xdr_encode_hyper(p, cb->initiator_addrtype);\n\n\t \n\terr = gssx_enc_buffer(xdr, &cb->initiator_address);\n\tif (err)\n\t\treturn err;\n\n\t \n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p)\n\t\treturn -ENOSPC;\n\tp = xdr_encode_hyper(p, cb->acceptor_addrtype);\n\n\t \n\terr = gssx_enc_buffer(xdr, &cb->acceptor_address);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = gssx_enc_buffer(xdr, &cb->application_data);\n\n\treturn err;\n}\n\nvoid gssx_enc_accept_sec_context(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t const void *data)\n{\n\tconst struct gssx_arg_accept_sec_context *arg = data;\n\tint err;\n\n\terr = gssx_enc_call_ctx(xdr, &arg->call_ctx);\n\tif (err)\n\t\tgoto done;\n\n\t \n\tif (arg->context_handle)\n\t\terr = gssx_enc_ctx(xdr, arg->context_handle);\n\telse\n\t\terr = gssx_enc_bool(xdr, 0);\n\tif (err)\n\t\tgoto done;\n\n\t \n\tif (arg->cred_handle)\n\t\terr = gssx_enc_cred(xdr, arg->cred_handle);\n\telse\n\t\terr = gssx_enc_bool(xdr, 0);\n\tif (err)\n\t\tgoto done;\n\n\t \n\terr = gssx_enc_in_token(xdr, &arg->input_token);\n\tif (err)\n\t\tgoto done;\n\n\t \n\tif (arg->input_cb)\n\t\terr = gssx_enc_cb(xdr, arg->input_cb);\n\telse\n\t\terr = gssx_enc_bool(xdr, 0);\n\tif (err)\n\t\tgoto done;\n\n\terr = gssx_enc_bool(xdr, arg->ret_deleg_cred);\n\tif (err)\n\t\tgoto done;\n\n\t \n\t \n\terr = dummy_enc_opt_array(xdr, &arg->options);\n\n\txdr_inline_pages(&req->rq_rcv_buf,\n\t\tPAGE_SIZE/2  ,\n\t\targ->pages, 0  , arg->npages * PAGE_SIZE);\ndone:\n\tif (err)\n\t\tdprintk(\"RPC:       gssx_enc_accept_sec_context: %d\\n\", err);\n}\n\nint gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tvoid *data)\n{\n\tstruct gssx_res_accept_sec_context *res = data;\n\tu32 value_follows;\n\tint err;\n\tstruct page *scratch;\n\n\tscratch = alloc_page(GFP_KERNEL);\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\txdr_set_scratch_page(xdr, scratch);\n\n\t \n\terr = gssx_dec_status(xdr, &res->status);\n\tif (err)\n\t\tgoto out_free;\n\n\t \n\terr = gssx_dec_bool(xdr, &value_follows);\n\tif (err)\n\t\tgoto out_free;\n\tif (value_follows) {\n\t\terr = gssx_dec_ctx(xdr, res->context_handle);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t} else {\n\t\tres->context_handle = NULL;\n\t}\n\n\t \n\terr = gssx_dec_bool(xdr, &value_follows);\n\tif (err)\n\t\tgoto out_free;\n\tif (value_follows) {\n\t\terr = gssx_dec_buffer(xdr, res->output_token);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t} else {\n\t\tres->output_token = NULL;\n\t}\n\n\t \n\terr = gssx_dec_bool(xdr, &value_follows);\n\tif (err)\n\t\tgoto out_free;\n\tif (value_follows) {\n\t\t \n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\t \n\terr = gssx_dec_option_array(xdr, &res->options);\n\nout_free:\n\t__free_page(scratch);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}