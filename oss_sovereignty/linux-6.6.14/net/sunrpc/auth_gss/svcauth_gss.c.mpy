{
  "module_name": "svcauth_gss.c",
  "hash_id": "ebe4c18c1625da9dfc3131628fac56fd3768a6b98118f7cbd618da3614926b23",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth_gss/svcauth_gss.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/pagemap.h>\n#include <linux/user_namespace.h>\n\n#include <linux/sunrpc/auth_gss.h>\n#include <linux/sunrpc/gss_err.h>\n#include <linux/sunrpc/svcauth.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/sunrpc/cache.h>\n#include <linux/sunrpc/gss_krb5.h>\n\n#include <trace/events/rpcgss.h>\n\n#include \"gss_rpc_upcall.h\"\n\n \n#define GSS_MAX_CKSUMSIZE (GSS_KRB5_TOK_HDR_LEN + GSS_KRB5_MAX_CKSUM_LEN)\n\n \n#define GSS_SCRATCH_SIZE GSS_MAX_CKSUMSIZE\n\nstruct gss_svc_data {\n\t \n\tstruct rpc_gss_wire_cred\tclcred;\n\tu32\t\t\t\tgsd_databody_offset;\n\tstruct rsc\t\t\t*rsci;\n\n\t \n\t__be32\t\t\t\tgsd_seq_num;\n\tu8\t\t\t\tgsd_scratch[GSS_SCRATCH_SIZE];\n};\n\n \n\nstatic int netobj_equal(struct xdr_netobj *a, struct xdr_netobj *b)\n{\n\treturn a->len == b->len && 0 == memcmp(a->data, b->data, a->len);\n}\n\n#define\tRSI_HASHBITS\t6\n#define\tRSI_HASHMAX\t(1<<RSI_HASHBITS)\n\nstruct rsi {\n\tstruct cache_head\th;\n\tstruct xdr_netobj\tin_handle, in_token;\n\tstruct xdr_netobj\tout_handle, out_token;\n\tint\t\t\tmajor_status, minor_status;\n\tstruct rcu_head\t\trcu_head;\n};\n\nstatic struct rsi *rsi_update(struct cache_detail *cd, struct rsi *new, struct rsi *old);\nstatic struct rsi *rsi_lookup(struct cache_detail *cd, struct rsi *item);\n\nstatic void rsi_free(struct rsi *rsii)\n{\n\tkfree(rsii->in_handle.data);\n\tkfree(rsii->in_token.data);\n\tkfree(rsii->out_handle.data);\n\tkfree(rsii->out_token.data);\n}\n\nstatic void rsi_free_rcu(struct rcu_head *head)\n{\n\tstruct rsi *rsii = container_of(head, struct rsi, rcu_head);\n\n\trsi_free(rsii);\n\tkfree(rsii);\n}\n\nstatic void rsi_put(struct kref *ref)\n{\n\tstruct rsi *rsii = container_of(ref, struct rsi, h.ref);\n\n\tcall_rcu(&rsii->rcu_head, rsi_free_rcu);\n}\n\nstatic inline int rsi_hash(struct rsi *item)\n{\n\treturn hash_mem(item->in_handle.data, item->in_handle.len, RSI_HASHBITS)\n\t     ^ hash_mem(item->in_token.data, item->in_token.len, RSI_HASHBITS);\n}\n\nstatic int rsi_match(struct cache_head *a, struct cache_head *b)\n{\n\tstruct rsi *item = container_of(a, struct rsi, h);\n\tstruct rsi *tmp = container_of(b, struct rsi, h);\n\treturn netobj_equal(&item->in_handle, &tmp->in_handle) &&\n\t       netobj_equal(&item->in_token, &tmp->in_token);\n}\n\nstatic int dup_to_netobj(struct xdr_netobj *dst, char *src, int len)\n{\n\tdst->len = len;\n\tdst->data = (len ? kmemdup(src, len, GFP_KERNEL) : NULL);\n\tif (len && !dst->data)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic inline int dup_netobj(struct xdr_netobj *dst, struct xdr_netobj *src)\n{\n\treturn dup_to_netobj(dst, src->data, src->len);\n}\n\nstatic void rsi_init(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct rsi *new = container_of(cnew, struct rsi, h);\n\tstruct rsi *item = container_of(citem, struct rsi, h);\n\n\tnew->out_handle.data = NULL;\n\tnew->out_handle.len = 0;\n\tnew->out_token.data = NULL;\n\tnew->out_token.len = 0;\n\tnew->in_handle.len = item->in_handle.len;\n\titem->in_handle.len = 0;\n\tnew->in_token.len = item->in_token.len;\n\titem->in_token.len = 0;\n\tnew->in_handle.data = item->in_handle.data;\n\titem->in_handle.data = NULL;\n\tnew->in_token.data = item->in_token.data;\n\titem->in_token.data = NULL;\n}\n\nstatic void update_rsi(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct rsi *new = container_of(cnew, struct rsi, h);\n\tstruct rsi *item = container_of(citem, struct rsi, h);\n\n\tBUG_ON(new->out_handle.data || new->out_token.data);\n\tnew->out_handle.len = item->out_handle.len;\n\titem->out_handle.len = 0;\n\tnew->out_token.len = item->out_token.len;\n\titem->out_token.len = 0;\n\tnew->out_handle.data = item->out_handle.data;\n\titem->out_handle.data = NULL;\n\tnew->out_token.data = item->out_token.data;\n\titem->out_token.data = NULL;\n\n\tnew->major_status = item->major_status;\n\tnew->minor_status = item->minor_status;\n}\n\nstatic struct cache_head *rsi_alloc(void)\n{\n\tstruct rsi *rsii = kmalloc(sizeof(*rsii), GFP_KERNEL);\n\tif (rsii)\n\t\treturn &rsii->h;\n\telse\n\t\treturn NULL;\n}\n\nstatic int rsi_upcall(struct cache_detail *cd, struct cache_head *h)\n{\n\treturn sunrpc_cache_pipe_upcall_timeout(cd, h);\n}\n\nstatic void rsi_request(struct cache_detail *cd,\n\t\t       struct cache_head *h,\n\t\t       char **bpp, int *blen)\n{\n\tstruct rsi *rsii = container_of(h, struct rsi, h);\n\n\tqword_addhex(bpp, blen, rsii->in_handle.data, rsii->in_handle.len);\n\tqword_addhex(bpp, blen, rsii->in_token.data, rsii->in_token.len);\n\t(*bpp)[-1] = '\\n';\n\tWARN_ONCE(*blen < 0,\n\t\t  \"RPCSEC/GSS credential too large - please use gssproxy\\n\");\n}\n\nstatic int rsi_parse(struct cache_detail *cd,\n\t\t    char *mesg, int mlen)\n{\n\t \n\tchar *buf = mesg;\n\tchar *ep;\n\tint len;\n\tstruct rsi rsii, *rsip = NULL;\n\ttime64_t expiry;\n\tint status = -EINVAL;\n\n\tmemset(&rsii, 0, sizeof(rsii));\n\t \n\tlen = qword_get(&mesg, buf, mlen);\n\tif (len < 0)\n\t\tgoto out;\n\tstatus = -ENOMEM;\n\tif (dup_to_netobj(&rsii.in_handle, buf, len))\n\t\tgoto out;\n\n\t \n\tlen = qword_get(&mesg, buf, mlen);\n\tstatus = -EINVAL;\n\tif (len < 0)\n\t\tgoto out;\n\tstatus = -ENOMEM;\n\tif (dup_to_netobj(&rsii.in_token, buf, len))\n\t\tgoto out;\n\n\trsip = rsi_lookup(cd, &rsii);\n\tif (!rsip)\n\t\tgoto out;\n\n\trsii.h.flags = 0;\n\t \n\tstatus = get_expiry(&mesg, &expiry);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = -EINVAL;\n\t \n\tlen = qword_get(&mesg, buf, mlen);\n\tif (len <= 0)\n\t\tgoto out;\n\trsii.major_status = simple_strtoul(buf, &ep, 10);\n\tif (*ep)\n\t\tgoto out;\n\tlen = qword_get(&mesg, buf, mlen);\n\tif (len <= 0)\n\t\tgoto out;\n\trsii.minor_status = simple_strtoul(buf, &ep, 10);\n\tif (*ep)\n\t\tgoto out;\n\n\t \n\tlen = qword_get(&mesg, buf, mlen);\n\tif (len < 0)\n\t\tgoto out;\n\tstatus = -ENOMEM;\n\tif (dup_to_netobj(&rsii.out_handle, buf, len))\n\t\tgoto out;\n\n\t \n\tlen = qword_get(&mesg, buf, mlen);\n\tstatus = -EINVAL;\n\tif (len < 0)\n\t\tgoto out;\n\tstatus = -ENOMEM;\n\tif (dup_to_netobj(&rsii.out_token, buf, len))\n\t\tgoto out;\n\trsii.h.expiry_time = expiry;\n\trsip = rsi_update(cd, &rsii, rsip);\n\tstatus = 0;\nout:\n\trsi_free(&rsii);\n\tif (rsip)\n\t\tcache_put(&rsip->h, cd);\n\telse\n\t\tstatus = -ENOMEM;\n\treturn status;\n}\n\nstatic const struct cache_detail rsi_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= RSI_HASHMAX,\n\t.name           = \"auth.rpcsec.init\",\n\t.cache_put      = rsi_put,\n\t.cache_upcall\t= rsi_upcall,\n\t.cache_request  = rsi_request,\n\t.cache_parse    = rsi_parse,\n\t.match\t\t= rsi_match,\n\t.init\t\t= rsi_init,\n\t.update\t\t= update_rsi,\n\t.alloc\t\t= rsi_alloc,\n};\n\nstatic struct rsi *rsi_lookup(struct cache_detail *cd, struct rsi *item)\n{\n\tstruct cache_head *ch;\n\tint hash = rsi_hash(item);\n\n\tch = sunrpc_cache_lookup_rcu(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct rsi, h);\n\telse\n\t\treturn NULL;\n}\n\nstatic struct rsi *rsi_update(struct cache_detail *cd, struct rsi *new, struct rsi *old)\n{\n\tstruct cache_head *ch;\n\tint hash = rsi_hash(new);\n\n\tch = sunrpc_cache_update(cd, &new->h,\n\t\t\t\t &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct rsi, h);\n\telse\n\t\treturn NULL;\n}\n\n\n \n\n#define\tRSC_HASHBITS\t10\n#define\tRSC_HASHMAX\t(1<<RSC_HASHBITS)\n\n#define GSS_SEQ_WIN\t128\n\nstruct gss_svc_seq_data {\n\t \n\tu32\t\t\tsd_max;\n\t \n\tunsigned long\t\tsd_win[GSS_SEQ_WIN/BITS_PER_LONG];\n\tspinlock_t\t\tsd_lock;\n};\n\nstruct rsc {\n\tstruct cache_head\th;\n\tstruct xdr_netobj\thandle;\n\tstruct svc_cred\t\tcred;\n\tstruct gss_svc_seq_data\tseqdata;\n\tstruct gss_ctx\t\t*mechctx;\n\tstruct rcu_head\t\trcu_head;\n};\n\nstatic struct rsc *rsc_update(struct cache_detail *cd, struct rsc *new, struct rsc *old);\nstatic struct rsc *rsc_lookup(struct cache_detail *cd, struct rsc *item);\n\nstatic void rsc_free(struct rsc *rsci)\n{\n\tkfree(rsci->handle.data);\n\tif (rsci->mechctx)\n\t\tgss_delete_sec_context(&rsci->mechctx);\n\tfree_svc_cred(&rsci->cred);\n}\n\nstatic void rsc_free_rcu(struct rcu_head *head)\n{\n\tstruct rsc *rsci = container_of(head, struct rsc, rcu_head);\n\n\tkfree(rsci->handle.data);\n\tkfree(rsci);\n}\n\nstatic void rsc_put(struct kref *ref)\n{\n\tstruct rsc *rsci = container_of(ref, struct rsc, h.ref);\n\n\tif (rsci->mechctx)\n\t\tgss_delete_sec_context(&rsci->mechctx);\n\tfree_svc_cred(&rsci->cred);\n\tcall_rcu(&rsci->rcu_head, rsc_free_rcu);\n}\n\nstatic inline int\nrsc_hash(struct rsc *rsci)\n{\n\treturn hash_mem(rsci->handle.data, rsci->handle.len, RSC_HASHBITS);\n}\n\nstatic int\nrsc_match(struct cache_head *a, struct cache_head *b)\n{\n\tstruct rsc *new = container_of(a, struct rsc, h);\n\tstruct rsc *tmp = container_of(b, struct rsc, h);\n\n\treturn netobj_equal(&new->handle, &tmp->handle);\n}\n\nstatic void\nrsc_init(struct cache_head *cnew, struct cache_head *ctmp)\n{\n\tstruct rsc *new = container_of(cnew, struct rsc, h);\n\tstruct rsc *tmp = container_of(ctmp, struct rsc, h);\n\n\tnew->handle.len = tmp->handle.len;\n\ttmp->handle.len = 0;\n\tnew->handle.data = tmp->handle.data;\n\ttmp->handle.data = NULL;\n\tnew->mechctx = NULL;\n\tinit_svc_cred(&new->cred);\n}\n\nstatic void\nupdate_rsc(struct cache_head *cnew, struct cache_head *ctmp)\n{\n\tstruct rsc *new = container_of(cnew, struct rsc, h);\n\tstruct rsc *tmp = container_of(ctmp, struct rsc, h);\n\n\tnew->mechctx = tmp->mechctx;\n\ttmp->mechctx = NULL;\n\tmemset(&new->seqdata, 0, sizeof(new->seqdata));\n\tspin_lock_init(&new->seqdata.sd_lock);\n\tnew->cred = tmp->cred;\n\tinit_svc_cred(&tmp->cred);\n}\n\nstatic struct cache_head *\nrsc_alloc(void)\n{\n\tstruct rsc *rsci = kmalloc(sizeof(*rsci), GFP_KERNEL);\n\tif (rsci)\n\t\treturn &rsci->h;\n\telse\n\t\treturn NULL;\n}\n\nstatic int rsc_upcall(struct cache_detail *cd, struct cache_head *h)\n{\n\treturn -EINVAL;\n}\n\nstatic int rsc_parse(struct cache_detail *cd,\n\t\t     char *mesg, int mlen)\n{\n\t \n\tchar *buf = mesg;\n\tint id;\n\tint len, rv;\n\tstruct rsc rsci, *rscp = NULL;\n\ttime64_t expiry;\n\tint status = -EINVAL;\n\tstruct gss_api_mech *gm = NULL;\n\n\tmemset(&rsci, 0, sizeof(rsci));\n\t \n\tlen = qword_get(&mesg, buf, mlen);\n\tif (len < 0) goto out;\n\tstatus = -ENOMEM;\n\tif (dup_to_netobj(&rsci.handle, buf, len))\n\t\tgoto out;\n\n\trsci.h.flags = 0;\n\t \n\tstatus = get_expiry(&mesg, &expiry);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = -EINVAL;\n\trscp = rsc_lookup(cd, &rsci);\n\tif (!rscp)\n\t\tgoto out;\n\n\t \n\trv = get_int(&mesg, &id);\n\tif (rv == -EINVAL)\n\t\tgoto out;\n\tif (rv == -ENOENT)\n\t\tset_bit(CACHE_NEGATIVE, &rsci.h.flags);\n\telse {\n\t\tint N, i;\n\n\t\t \n\t\t \n\t\trsci.cred.cr_uid = make_kuid(current_user_ns(), id);\n\n\t\t \n\t\tif (get_int(&mesg, &id))\n\t\t\tgoto out;\n\t\trsci.cred.cr_gid = make_kgid(current_user_ns(), id);\n\n\t\t \n\t\tif (get_int(&mesg, &N))\n\t\t\tgoto out;\n\t\tif (N < 0 || N > NGROUPS_MAX)\n\t\t\tgoto out;\n\t\tstatus = -ENOMEM;\n\t\trsci.cred.cr_group_info = groups_alloc(N);\n\t\tif (rsci.cred.cr_group_info == NULL)\n\t\t\tgoto out;\n\n\t\t \n\t\tstatus = -EINVAL;\n\t\tfor (i=0; i<N; i++) {\n\t\t\tkgid_t kgid;\n\t\t\tif (get_int(&mesg, &id))\n\t\t\t\tgoto out;\n\t\t\tkgid = make_kgid(current_user_ns(), id);\n\t\t\tif (!gid_valid(kgid))\n\t\t\t\tgoto out;\n\t\t\trsci.cred.cr_group_info->gid[i] = kgid;\n\t\t}\n\t\tgroups_sort(rsci.cred.cr_group_info);\n\n\t\t \n\t\tlen = qword_get(&mesg, buf, mlen);\n\t\tif (len < 0)\n\t\t\tgoto out;\n\t\tgm = rsci.cred.cr_gss_mech = gss_mech_get_by_name(buf);\n\t\tstatus = -EOPNOTSUPP;\n\t\tif (!gm)\n\t\t\tgoto out;\n\n\t\tstatus = -EINVAL;\n\t\t \n\t\tlen = qword_get(&mesg, buf, mlen);\n\t\tif (len < 0)\n\t\t\tgoto out;\n\t\tstatus = gss_import_sec_context(buf, len, gm, &rsci.mechctx,\n\t\t\t\t\t\tNULL, GFP_KERNEL);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\t \n\t\tlen = qword_get(&mesg, buf, mlen);\n\t\tif (len > 0) {\n\t\t\trsci.cred.cr_principal = kstrdup(buf, GFP_KERNEL);\n\t\t\tif (!rsci.cred.cr_principal) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t}\n\trsci.h.expiry_time = expiry;\n\trscp = rsc_update(cd, &rsci, rscp);\n\tstatus = 0;\nout:\n\trsc_free(&rsci);\n\tif (rscp)\n\t\tcache_put(&rscp->h, cd);\n\telse\n\t\tstatus = -ENOMEM;\n\treturn status;\n}\n\nstatic const struct cache_detail rsc_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= RSC_HASHMAX,\n\t.name\t\t= \"auth.rpcsec.context\",\n\t.cache_put\t= rsc_put,\n\t.cache_upcall\t= rsc_upcall,\n\t.cache_parse\t= rsc_parse,\n\t.match\t\t= rsc_match,\n\t.init\t\t= rsc_init,\n\t.update\t\t= update_rsc,\n\t.alloc\t\t= rsc_alloc,\n};\n\nstatic struct rsc *rsc_lookup(struct cache_detail *cd, struct rsc *item)\n{\n\tstruct cache_head *ch;\n\tint hash = rsc_hash(item);\n\n\tch = sunrpc_cache_lookup_rcu(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct rsc, h);\n\telse\n\t\treturn NULL;\n}\n\nstatic struct rsc *rsc_update(struct cache_detail *cd, struct rsc *new, struct rsc *old)\n{\n\tstruct cache_head *ch;\n\tint hash = rsc_hash(new);\n\n\tch = sunrpc_cache_update(cd, &new->h,\n\t\t\t\t &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct rsc, h);\n\telse\n\t\treturn NULL;\n}\n\n\nstatic struct rsc *\ngss_svc_searchbyctx(struct cache_detail *cd, struct xdr_netobj *handle)\n{\n\tstruct rsc rsci;\n\tstruct rsc *found;\n\n\tmemset(&rsci, 0, sizeof(rsci));\n\tif (dup_to_netobj(&rsci.handle, handle->data, handle->len))\n\t\treturn NULL;\n\tfound = rsc_lookup(cd, &rsci);\n\trsc_free(&rsci);\n\tif (!found)\n\t\treturn NULL;\n\tif (cache_check(cd, &found->h, NULL))\n\t\treturn NULL;\n\treturn found;\n}\n\n \nstatic bool gss_check_seq_num(const struct svc_rqst *rqstp, struct rsc *rsci,\n\t\t\t      u32 seq_num)\n{\n\tstruct gss_svc_seq_data *sd = &rsci->seqdata;\n\tbool result = false;\n\n\tspin_lock(&sd->sd_lock);\n\tif (seq_num > sd->sd_max) {\n\t\tif (seq_num >= sd->sd_max + GSS_SEQ_WIN) {\n\t\t\tmemset(sd->sd_win, 0, sizeof(sd->sd_win));\n\t\t\tsd->sd_max = seq_num;\n\t\t} else while (sd->sd_max < seq_num) {\n\t\t\tsd->sd_max++;\n\t\t\t__clear_bit(sd->sd_max % GSS_SEQ_WIN, sd->sd_win);\n\t\t}\n\t\t__set_bit(seq_num % GSS_SEQ_WIN, sd->sd_win);\n\t\tgoto ok;\n\t} else if (seq_num + GSS_SEQ_WIN <= sd->sd_max) {\n\t\tgoto toolow;\n\t}\n\tif (__test_and_set_bit(seq_num % GSS_SEQ_WIN, sd->sd_win))\n\t\tgoto alreadyseen;\n\nok:\n\tresult = true;\nout:\n\tspin_unlock(&sd->sd_lock);\n\treturn result;\n\ntoolow:\n\ttrace_rpcgss_svc_seqno_low(rqstp, seq_num,\n\t\t\t\t   sd->sd_max - GSS_SEQ_WIN,\n\t\t\t\t   sd->sd_max);\n\tgoto out;\nalreadyseen:\n\ttrace_rpcgss_svc_seqno_seen(rqstp, seq_num);\n\tgoto out;\n}\n\n \nstatic int\nsvcauth_gss_verify_header(struct svc_rqst *rqstp, struct rsc *rsci,\n\t\t\t  __be32 *rpcstart, struct rpc_gss_wire_cred *gc)\n{\n\tstruct xdr_stream\t*xdr = &rqstp->rq_arg_stream;\n\tstruct gss_ctx\t\t*ctx_id = rsci->mechctx;\n\tu32\t\t\tflavor, maj_stat;\n\tstruct xdr_buf\t\trpchdr;\n\tstruct xdr_netobj\tchecksum;\n\tstruct kvec\t\tiov;\n\n\t \n\tiov.iov_base = rpcstart;\n\tiov.iov_len = (u8 *)xdr->p - (u8 *)rpcstart;\n\txdr_buf_from_iov(&iov, &rpchdr);\n\n\t \n\tif (xdr_stream_decode_opaque_auth(xdr, &flavor,\n\t\t\t\t\t  (void **)&checksum.data,\n\t\t\t\t\t  &checksum.len) < 0) {\n\t\trqstp->rq_auth_stat = rpc_autherr_badverf;\n\t\treturn SVC_DENIED;\n\t}\n\tif (flavor != RPC_AUTH_GSS) {\n\t\trqstp->rq_auth_stat = rpc_autherr_badverf;\n\t\treturn SVC_DENIED;\n\t}\n\n\tif (rqstp->rq_deferred)\n\t\treturn SVC_OK;\n\tmaj_stat = gss_verify_mic(ctx_id, &rpchdr, &checksum);\n\tif (maj_stat != GSS_S_COMPLETE) {\n\t\ttrace_rpcgss_svc_mic(rqstp, maj_stat);\n\t\trqstp->rq_auth_stat = rpcsec_gsserr_credproblem;\n\t\treturn SVC_DENIED;\n\t}\n\n\tif (gc->gc_seq > MAXSEQ) {\n\t\ttrace_rpcgss_svc_seqno_large(rqstp, gc->gc_seq);\n\t\trqstp->rq_auth_stat = rpcsec_gsserr_ctxproblem;\n\t\treturn SVC_DENIED;\n\t}\n\tif (!gss_check_seq_num(rqstp, rsci, gc->gc_seq))\n\t\treturn SVC_DROP;\n\treturn SVC_OK;\n}\n\n \nstatic bool\nsvcauth_gss_encode_verf(struct svc_rqst *rqstp, struct gss_ctx *ctx_id, u32 seq)\n{\n\tstruct gss_svc_data\t*gsd = rqstp->rq_auth_data;\n\tu32\t\t\tmaj_stat;\n\tstruct xdr_buf\t\tverf_data;\n\tstruct xdr_netobj\tchecksum;\n\tstruct kvec\t\tiov;\n\n\tgsd->gsd_seq_num = cpu_to_be32(seq);\n\tiov.iov_base = &gsd->gsd_seq_num;\n\tiov.iov_len = XDR_UNIT;\n\txdr_buf_from_iov(&iov, &verf_data);\n\n\tchecksum.data = gsd->gsd_scratch;\n\tmaj_stat = gss_get_mic(ctx_id, &verf_data, &checksum);\n\tif (maj_stat != GSS_S_COMPLETE)\n\t\tgoto bad_mic;\n\n\treturn xdr_stream_encode_opaque_auth(&rqstp->rq_res_stream, RPC_AUTH_GSS,\n\t\t\t\t\t     checksum.data, checksum.len) > 0;\n\nbad_mic:\n\ttrace_rpcgss_svc_get_mic(rqstp, maj_stat);\n\treturn false;\n}\n\nstruct gss_domain {\n\tstruct auth_domain\th;\n\tu32\t\t\tpseudoflavor;\n};\n\nstatic struct auth_domain *\nfind_gss_auth_domain(struct gss_ctx *ctx, u32 svc)\n{\n\tchar *name;\n\n\tname = gss_service_to_auth_domain_name(ctx->mech_type, svc);\n\tif (!name)\n\t\treturn NULL;\n\treturn auth_domain_find(name);\n}\n\nstatic struct auth_ops svcauthops_gss;\n\nu32 svcauth_gss_flavor(struct auth_domain *dom)\n{\n\tstruct gss_domain *gd = container_of(dom, struct gss_domain, h);\n\n\treturn gd->pseudoflavor;\n}\n\nEXPORT_SYMBOL_GPL(svcauth_gss_flavor);\n\nstruct auth_domain *\nsvcauth_gss_register_pseudoflavor(u32 pseudoflavor, char * name)\n{\n\tstruct gss_domain\t*new;\n\tstruct auth_domain\t*test;\n\tint\t\t\tstat = -ENOMEM;\n\n\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\tgoto out;\n\tkref_init(&new->h.ref);\n\tnew->h.name = kstrdup(name, GFP_KERNEL);\n\tif (!new->h.name)\n\t\tgoto out_free_dom;\n\tnew->h.flavour = &svcauthops_gss;\n\tnew->pseudoflavor = pseudoflavor;\n\n\ttest = auth_domain_lookup(name, &new->h);\n\tif (test != &new->h) {\n\t\tpr_warn(\"svc: duplicate registration of gss pseudo flavour %s.\\n\",\n\t\t\tname);\n\t\tstat = -EADDRINUSE;\n\t\tauth_domain_put(test);\n\t\tgoto out_free_name;\n\t}\n\treturn test;\n\nout_free_name:\n\tkfree(new->h.name);\nout_free_dom:\n\tkfree(new);\nout:\n\treturn ERR_PTR(stat);\n}\nEXPORT_SYMBOL_GPL(svcauth_gss_register_pseudoflavor);\n\n \nstatic noinline_for_stack int\nsvcauth_gss_unwrap_integ(struct svc_rqst *rqstp, u32 seq, struct gss_ctx *ctx)\n{\n\tstruct gss_svc_data *gsd = rqstp->rq_auth_data;\n\tstruct xdr_stream *xdr = &rqstp->rq_arg_stream;\n\tu32 len, offset, seq_num, maj_stat;\n\tstruct xdr_buf *buf = xdr->buf;\n\tstruct xdr_buf databody_integ;\n\tstruct xdr_netobj checksum;\n\n\t \n\tclear_bit(RQ_SPLICE_OK, &rqstp->rq_flags);\n\n\t \n\tif (rqstp->rq_deferred)\n\t\treturn 0;\n\n\tif (xdr_stream_decode_u32(xdr, &len) < 0)\n\t\tgoto unwrap_failed;\n\tif (len & 3)\n\t\tgoto unwrap_failed;\n\toffset = xdr_stream_pos(xdr);\n\tif (xdr_buf_subsegment(buf, &databody_integ, offset, len))\n\t\tgoto unwrap_failed;\n\n\t \n\n\toffset += len;\n\tif (xdr_decode_word(buf, offset, &checksum.len))\n\t\tgoto unwrap_failed;\n\tif (checksum.len > sizeof(gsd->gsd_scratch))\n\t\tgoto unwrap_failed;\n\tchecksum.data = gsd->gsd_scratch;\n\tif (read_bytes_from_xdr_buf(buf, offset + XDR_UNIT, checksum.data,\n\t\t\t\t    checksum.len))\n\t\tgoto unwrap_failed;\n\n\tmaj_stat = gss_verify_mic(ctx, &databody_integ, &checksum);\n\tif (maj_stat != GSS_S_COMPLETE)\n\t\tgoto bad_mic;\n\n\t \n\tif (xdr_stream_decode_u32(xdr, &seq_num) < 0)\n\t\tgoto unwrap_failed;\n\tif (seq_num != seq)\n\t\tgoto bad_seqno;\n\n\txdr_truncate_decode(xdr, XDR_UNIT + checksum.len);\n\treturn 0;\n\nunwrap_failed:\n\ttrace_rpcgss_svc_unwrap_failed(rqstp);\n\treturn -EINVAL;\nbad_seqno:\n\ttrace_rpcgss_svc_seqno_bad(rqstp, seq, seq_num);\n\treturn -EINVAL;\nbad_mic:\n\ttrace_rpcgss_svc_mic(rqstp, maj_stat);\n\treturn -EINVAL;\n}\n\n \nstatic noinline_for_stack int\nsvcauth_gss_unwrap_priv(struct svc_rqst *rqstp, u32 seq, struct gss_ctx *ctx)\n{\n\tstruct xdr_stream *xdr = &rqstp->rq_arg_stream;\n\tu32 len, maj_stat, seq_num, offset;\n\tstruct xdr_buf *buf = xdr->buf;\n\tunsigned int saved_len;\n\n\tclear_bit(RQ_SPLICE_OK, &rqstp->rq_flags);\n\n\tif (xdr_stream_decode_u32(xdr, &len) < 0)\n\t\tgoto unwrap_failed;\n\tif (rqstp->rq_deferred) {\n\t\t \n\t\tgoto out_seq;\n\t}\n\tif (len > xdr_stream_remaining(xdr))\n\t\tgoto unwrap_failed;\n\toffset = xdr_stream_pos(xdr);\n\n\tsaved_len = buf->len;\n\tmaj_stat = gss_unwrap(ctx, offset, offset + len, buf);\n\tif (maj_stat != GSS_S_COMPLETE)\n\t\tgoto bad_unwrap;\n\txdr->nwords -= XDR_QUADLEN(saved_len - buf->len);\n\nout_seq:\n\t \n\tif (xdr_stream_decode_u32(xdr, &seq_num) < 0)\n\t\tgoto unwrap_failed;\n\tif (seq_num != seq)\n\t\tgoto bad_seqno;\n\treturn 0;\n\nunwrap_failed:\n\ttrace_rpcgss_svc_unwrap_failed(rqstp);\n\treturn -EINVAL;\nbad_seqno:\n\ttrace_rpcgss_svc_seqno_bad(rqstp, seq, seq_num);\n\treturn -EINVAL;\nbad_unwrap:\n\ttrace_rpcgss_svc_unwrap(rqstp, maj_stat);\n\treturn -EINVAL;\n}\n\nstatic enum svc_auth_status\nsvcauth_gss_set_client(struct svc_rqst *rqstp)\n{\n\tstruct gss_svc_data *svcdata = rqstp->rq_auth_data;\n\tstruct rsc *rsci = svcdata->rsci;\n\tstruct rpc_gss_wire_cred *gc = &svcdata->clcred;\n\tint stat;\n\n\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\n\t \n\trqstp->rq_gssclient = find_gss_auth_domain(rsci->mechctx, gc->gc_svc);\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn SVC_DENIED;\n\tstat = svcauth_unix_set_client(rqstp);\n\tif (stat == SVC_DROP || stat == SVC_CLOSE)\n\t\treturn stat;\n\n\trqstp->rq_auth_stat = rpc_auth_ok;\n\treturn SVC_OK;\n}\n\nstatic bool\nsvcauth_gss_proc_init_verf(struct cache_detail *cd, struct svc_rqst *rqstp,\n\t\t\t   struct xdr_netobj *out_handle, int *major_status,\n\t\t\t   u32 seq_num)\n{\n\tstruct xdr_stream *xdr = &rqstp->rq_res_stream;\n\tstruct rsc *rsci;\n\tbool rc;\n\n\tif (*major_status != GSS_S_COMPLETE)\n\t\tgoto null_verifier;\n\trsci = gss_svc_searchbyctx(cd, out_handle);\n\tif (rsci == NULL) {\n\t\t*major_status = GSS_S_NO_CONTEXT;\n\t\tgoto null_verifier;\n\t}\n\n\trc = svcauth_gss_encode_verf(rqstp, rsci->mechctx, seq_num);\n\tcache_put(&rsci->h, cd);\n\treturn rc;\n\nnull_verifier:\n\treturn xdr_stream_encode_opaque_auth(xdr, RPC_AUTH_NULL, NULL, 0) > 0;\n}\n\nstatic void gss_free_in_token_pages(struct gssp_in_token *in_token)\n{\n\tu32 inlen;\n\tint i;\n\n\ti = 0;\n\tinlen = in_token->page_len;\n\twhile (inlen) {\n\t\tif (in_token->pages[i])\n\t\t\tput_page(in_token->pages[i]);\n\t\tinlen -= inlen > PAGE_SIZE ? PAGE_SIZE : inlen;\n\t}\n\n\tkfree(in_token->pages);\n\tin_token->pages = NULL;\n}\n\nstatic int gss_read_proxy_verf(struct svc_rqst *rqstp,\n\t\t\t       struct rpc_gss_wire_cred *gc,\n\t\t\t       struct xdr_netobj *in_handle,\n\t\t\t       struct gssp_in_token *in_token)\n{\n\tstruct xdr_stream *xdr = &rqstp->rq_arg_stream;\n\tunsigned int length, pgto_offs, pgfrom_offs;\n\tint pages, i, pgto, pgfrom;\n\tsize_t to_offs, from_offs;\n\tu32 inlen;\n\n\tif (dup_netobj(in_handle, &gc->gc_ctx))\n\t\treturn SVC_CLOSE;\n\n\t \n\tif (xdr_stream_decode_u32(xdr, &inlen) < 0)\n\t\tgoto out_denied_free;\n\tif (inlen > xdr_stream_remaining(xdr))\n\t\tgoto out_denied_free;\n\n\tpages = DIV_ROUND_UP(inlen, PAGE_SIZE);\n\tin_token->pages = kcalloc(pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!in_token->pages)\n\t\tgoto out_denied_free;\n\tin_token->page_base = 0;\n\tin_token->page_len = inlen;\n\tfor (i = 0; i < pages; i++) {\n\t\tin_token->pages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!in_token->pages[i]) {\n\t\t\tgss_free_in_token_pages(in_token);\n\t\t\tgoto out_denied_free;\n\t\t}\n\t}\n\n\tlength = min_t(unsigned int, inlen, (char *)xdr->end - (char *)xdr->p);\n\tmemcpy(page_address(in_token->pages[0]), xdr->p, length);\n\tinlen -= length;\n\n\tto_offs = length;\n\tfrom_offs = rqstp->rq_arg.page_base;\n\twhile (inlen) {\n\t\tpgto = to_offs >> PAGE_SHIFT;\n\t\tpgfrom = from_offs >> PAGE_SHIFT;\n\t\tpgto_offs = to_offs & ~PAGE_MASK;\n\t\tpgfrom_offs = from_offs & ~PAGE_MASK;\n\n\t\tlength = min_t(unsigned int, inlen,\n\t\t\t min_t(unsigned int, PAGE_SIZE - pgto_offs,\n\t\t\t       PAGE_SIZE - pgfrom_offs));\n\t\tmemcpy(page_address(in_token->pages[pgto]) + pgto_offs,\n\t\t       page_address(rqstp->rq_arg.pages[pgfrom]) + pgfrom_offs,\n\t\t       length);\n\n\t\tto_offs += length;\n\t\tfrom_offs += length;\n\t\tinlen -= length;\n\t}\n\treturn 0;\n\nout_denied_free:\n\tkfree(in_handle->data);\n\treturn SVC_DENIED;\n}\n\n \nstatic bool\nsvcxdr_encode_gss_init_res(struct xdr_stream *xdr,\n\t\t\t   struct xdr_netobj *handle,\n\t\t\t   struct xdr_netobj *gss_token,\n\t\t\t   unsigned int major_status,\n\t\t\t   unsigned int minor_status, u32 seq_num)\n{\n\tif (xdr_stream_encode_opaque(xdr, handle->data, handle->len) < 0)\n\t\treturn false;\n\tif (xdr_stream_encode_u32(xdr, major_status) < 0)\n\t\treturn false;\n\tif (xdr_stream_encode_u32(xdr, minor_status) < 0)\n\t\treturn false;\n\tif (xdr_stream_encode_u32(xdr, seq_num) < 0)\n\t\treturn false;\n\tif (xdr_stream_encode_opaque(xdr, gss_token->data, gss_token->len) < 0)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic int\nsvcauth_gss_legacy_init(struct svc_rqst *rqstp,\n\t\t\tstruct rpc_gss_wire_cred *gc)\n{\n\tstruct xdr_stream *xdr = &rqstp->rq_arg_stream;\n\tstruct rsi *rsip, rsikey;\n\t__be32 *p;\n\tu32 len;\n\tint ret;\n\tstruct sunrpc_net *sn = net_generic(SVC_NET(rqstp), sunrpc_net_id);\n\n\tmemset(&rsikey, 0, sizeof(rsikey));\n\tif (dup_netobj(&rsikey.in_handle, &gc->gc_ctx))\n\t\treturn SVC_CLOSE;\n\n\t \n\tif (xdr_stream_decode_u32(xdr, &len) < 0) {\n\t\tkfree(rsikey.in_handle.data);\n\t\treturn SVC_DENIED;\n\t}\n\tp = xdr_inline_decode(xdr, len);\n\tif (!p) {\n\t\tkfree(rsikey.in_handle.data);\n\t\treturn SVC_DENIED;\n\t}\n\trsikey.in_token.data = kmalloc(len, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(rsikey.in_token.data)) {\n\t\tkfree(rsikey.in_handle.data);\n\t\treturn SVC_CLOSE;\n\t}\n\tmemcpy(rsikey.in_token.data, p, len);\n\trsikey.in_token.len = len;\n\n\t \n\trsip = rsi_lookup(sn->rsi_cache, &rsikey);\n\trsi_free(&rsikey);\n\tif (!rsip)\n\t\treturn SVC_CLOSE;\n\tif (cache_check(sn->rsi_cache, &rsip->h, &rqstp->rq_chandle) < 0)\n\t\t \n\t\treturn SVC_CLOSE;\n\n\tret = SVC_CLOSE;\n\tif (!svcauth_gss_proc_init_verf(sn->rsc_cache, rqstp, &rsip->out_handle,\n\t\t\t\t\t&rsip->major_status, GSS_SEQ_WIN))\n\t\tgoto out;\n\tif (!svcxdr_set_accept_stat(rqstp))\n\t\tgoto out;\n\tif (!svcxdr_encode_gss_init_res(&rqstp->rq_res_stream, &rsip->out_handle,\n\t\t\t\t\t&rsip->out_token, rsip->major_status,\n\t\t\t\t\trsip->minor_status, GSS_SEQ_WIN))\n\t\tgoto out;\n\n\tret = SVC_COMPLETE;\nout:\n\tcache_put(&rsip->h, sn->rsi_cache);\n\treturn ret;\n}\n\nstatic int gss_proxy_save_rsc(struct cache_detail *cd,\n\t\t\t\tstruct gssp_upcall_data *ud,\n\t\t\t\tuint64_t *handle)\n{\n\tstruct rsc rsci, *rscp = NULL;\n\tstatic atomic64_t ctxhctr;\n\tlong long ctxh;\n\tstruct gss_api_mech *gm = NULL;\n\ttime64_t expiry;\n\tint status;\n\n\tmemset(&rsci, 0, sizeof(rsci));\n\t \n\tstatus = -ENOMEM;\n\t \n\tctxh = atomic64_inc_return(&ctxhctr);\n\n\t \n\t*handle = ctxh;\n\n\t \n\tif (dup_to_netobj(&rsci.handle, (char *)handle, sizeof(uint64_t)))\n\t\tgoto out;\n\trscp = rsc_lookup(cd, &rsci);\n\tif (!rscp)\n\t\tgoto out;\n\n\t \n\tif (!ud->found_creds) {\n\t\t \n\t\tgoto out;\n\t} else {\n\t\tstruct timespec64 boot;\n\n\t\t \n\t\trsci.cred = ud->creds;\n\t\tmemset(&ud->creds, 0, sizeof(struct svc_cred));\n\n\t\tstatus = -EOPNOTSUPP;\n\t\t \n\t\tgm = gss_mech_get_by_OID(&ud->mech_oid);\n\t\tif (!gm)\n\t\t\tgoto out;\n\t\trsci.cred.cr_gss_mech = gm;\n\n\t\tstatus = -EINVAL;\n\t\t \n\t\tstatus = gss_import_sec_context(ud->out_handle.data,\n\t\t\t\t\t\tud->out_handle.len,\n\t\t\t\t\t\tgm, &rsci.mechctx,\n\t\t\t\t\t\t&expiry, GFP_KERNEL);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tgetboottime64(&boot);\n\t\texpiry -= boot.tv_sec;\n\t}\n\n\trsci.h.expiry_time = expiry;\n\trscp = rsc_update(cd, &rsci, rscp);\n\tstatus = 0;\nout:\n\trsc_free(&rsci);\n\tif (rscp)\n\t\tcache_put(&rscp->h, cd);\n\telse\n\t\tstatus = -ENOMEM;\n\treturn status;\n}\n\nstatic int svcauth_gss_proxy_init(struct svc_rqst *rqstp,\n\t\t\t\t  struct rpc_gss_wire_cred *gc)\n{\n\tstruct xdr_netobj cli_handle;\n\tstruct gssp_upcall_data ud;\n\tuint64_t handle;\n\tint status;\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tmemset(&ud, 0, sizeof(ud));\n\tret = gss_read_proxy_verf(rqstp, gc, &ud.in_handle, &ud.in_token);\n\tif (ret)\n\t\treturn ret;\n\n\tret = SVC_CLOSE;\n\n\t \n\tstatus = gssp_accept_sec_context_upcall(net, &ud);\n\tif (status)\n\t\tgoto out;\n\n\ttrace_rpcgss_svc_accept_upcall(rqstp, ud.major_status, ud.minor_status);\n\n\tswitch (ud.major_status) {\n\tcase GSS_S_CONTINUE_NEEDED:\n\t\tcli_handle = ud.out_handle;\n\t\tbreak;\n\tcase GSS_S_COMPLETE:\n\t\tstatus = gss_proxy_save_rsc(sn->rsc_cache, &ud, &handle);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tcli_handle.data = (u8 *)&handle;\n\t\tcli_handle.len = sizeof(handle);\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif (!svcauth_gss_proc_init_verf(sn->rsc_cache, rqstp, &cli_handle,\n\t\t\t\t\t&ud.major_status, GSS_SEQ_WIN))\n\t\tgoto out;\n\tif (!svcxdr_set_accept_stat(rqstp))\n\t\tgoto out;\n\tif (!svcxdr_encode_gss_init_res(&rqstp->rq_res_stream, &cli_handle,\n\t\t\t\t\t&ud.out_token, ud.major_status,\n\t\t\t\t\tud.minor_status, GSS_SEQ_WIN))\n\t\tgoto out;\n\n\tret = SVC_COMPLETE;\nout:\n\tgss_free_in_token_pages(&ud.in_token);\n\tgssp_free_upcall_data(&ud);\n\treturn ret;\n}\n\n \nstatic int set_gss_proxy(struct net *net, int type)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tint ret;\n\n\tWARN_ON_ONCE(type != 0 && type != 1);\n\tret = cmpxchg(&sn->use_gss_proxy, -1, type);\n\tif (ret != -1 && ret != type)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic bool use_gss_proxy(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\t \n\tif (sn->use_gss_proxy == -1)\n\t\tset_gss_proxy(net, 0);\n\treturn sn->use_gss_proxy;\n}\n\nstatic noinline_for_stack int\nsvcauth_gss_proc_init(struct svc_rqst *rqstp, struct rpc_gss_wire_cred *gc)\n{\n\tstruct xdr_stream *xdr = &rqstp->rq_arg_stream;\n\tu32 flavor, len;\n\tvoid *body;\n\n\t \n\tif (xdr_stream_decode_opaque_auth(xdr, &flavor, &body, &len) < 0)\n\t\treturn SVC_GARBAGE;\n\tif (flavor != RPC_AUTH_NULL || len != 0) {\n\t\trqstp->rq_auth_stat = rpc_autherr_badverf;\n\t\treturn SVC_DENIED;\n\t}\n\n\tif (gc->gc_proc == RPC_GSS_PROC_INIT && gc->gc_ctx.len != 0) {\n\t\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\t\treturn SVC_DENIED;\n\t}\n\n\tif (!use_gss_proxy(SVC_NET(rqstp)))\n\t\treturn svcauth_gss_legacy_init(rqstp, gc);\n\treturn svcauth_gss_proxy_init(rqstp, gc);\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic ssize_t write_gssp(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct net *net = pde_data(file_inode(file));\n\tchar tbuf[20];\n\tunsigned long i;\n\tint res;\n\n\tif (*ppos || count > sizeof(tbuf)-1)\n\t\treturn -EINVAL;\n\tif (copy_from_user(tbuf, buf, count))\n\t\treturn -EFAULT;\n\n\ttbuf[count] = 0;\n\tres = kstrtoul(tbuf, 0, &i);\n\tif (res)\n\t\treturn res;\n\tif (i != 1)\n\t\treturn -EINVAL;\n\tres = set_gssp_clnt(net);\n\tif (res)\n\t\treturn res;\n\tres = set_gss_proxy(net, 1);\n\tif (res)\n\t\treturn res;\n\treturn count;\n}\n\nstatic ssize_t read_gssp(struct file *file, char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct net *net = pde_data(file_inode(file));\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tunsigned long p = *ppos;\n\tchar tbuf[10];\n\tsize_t len;\n\n\tsnprintf(tbuf, sizeof(tbuf), \"%d\\n\", sn->use_gss_proxy);\n\tlen = strlen(tbuf);\n\tif (p >= len)\n\t\treturn 0;\n\tlen -= p;\n\tif (len > count)\n\t\tlen = count;\n\tif (copy_to_user(buf, (void *)(tbuf+p), len))\n\t\treturn -EFAULT;\n\t*ppos += len;\n\treturn len;\n}\n\nstatic const struct proc_ops use_gss_proxy_proc_ops = {\n\t.proc_open\t= nonseekable_open,\n\t.proc_write\t= write_gssp,\n\t.proc_read\t= read_gssp,\n};\n\nstatic int create_use_gss_proxy_proc_entry(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct proc_dir_entry **p = &sn->use_gssp_proc;\n\n\tsn->use_gss_proxy = -1;\n\t*p = proc_create_data(\"use-gss-proxy\", S_IFREG | 0600,\n\t\t\t      sn->proc_net_rpc,\n\t\t\t      &use_gss_proxy_proc_ops, net);\n\tif (!*p)\n\t\treturn -ENOMEM;\n\tinit_gssp_clnt(sn);\n\treturn 0;\n}\n\nstatic void destroy_use_gss_proxy_proc_entry(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tif (sn->use_gssp_proc) {\n\t\tremove_proc_entry(\"use-gss-proxy\", sn->proc_net_rpc);\n\t\tclear_gssp_clnt(sn);\n\t}\n}\n\nstatic ssize_t read_gss_krb5_enctypes(struct file *file, char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct rpcsec_gss_oid oid = {\n\t\t.len\t= 9,\n\t\t.data\t= \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\",\n\t};\n\tstruct gss_api_mech *mech;\n\tssize_t ret;\n\n\tmech = gss_mech_get_by_OID(&oid);\n\tif (!mech)\n\t\treturn 0;\n\tif (!mech->gm_upcall_enctypes) {\n\t\tgss_mech_put(mech);\n\t\treturn 0;\n\t}\n\n\tret = simple_read_from_buffer(buf, count, ppos,\n\t\t\t\t      mech->gm_upcall_enctypes,\n\t\t\t\t      strlen(mech->gm_upcall_enctypes));\n\tgss_mech_put(mech);\n\treturn ret;\n}\n\nstatic const struct proc_ops gss_krb5_enctypes_proc_ops = {\n\t.proc_open\t= nonseekable_open,\n\t.proc_read\t= read_gss_krb5_enctypes,\n};\n\nstatic int create_krb5_enctypes_proc_entry(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tsn->gss_krb5_enctypes =\n\t\tproc_create_data(\"gss_krb5_enctypes\", S_IFREG | 0444,\n\t\t\t\t sn->proc_net_rpc, &gss_krb5_enctypes_proc_ops,\n\t\t\t\t net);\n\treturn sn->gss_krb5_enctypes ? 0 : -ENOMEM;\n}\n\nstatic void destroy_krb5_enctypes_proc_entry(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tif (sn->gss_krb5_enctypes)\n\t\tremove_proc_entry(\"gss_krb5_enctypes\", sn->proc_net_rpc);\n}\n\n#else  \n\nstatic int create_use_gss_proxy_proc_entry(struct net *net)\n{\n\treturn 0;\n}\n\nstatic void destroy_use_gss_proxy_proc_entry(struct net *net) {}\n\nstatic int create_krb5_enctypes_proc_entry(struct net *net)\n{\n\treturn 0;\n}\n\nstatic void destroy_krb5_enctypes_proc_entry(struct net *net) {}\n\n#endif  \n\n \nstatic bool\nsvcauth_gss_decode_credbody(struct xdr_stream *xdr,\n\t\t\t    struct rpc_gss_wire_cred *gc,\n\t\t\t    __be32 **rpcstart)\n{\n\tssize_t handle_len;\n\tu32 body_len;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, XDR_UNIT);\n\tif (!p)\n\t\treturn false;\n\t \n\t*rpcstart = p - 7;\n\tbody_len = be32_to_cpup(p);\n\tif (body_len > RPC_MAX_AUTH_SIZE)\n\t\treturn false;\n\n\t \n\tif (xdr_stream_decode_u32(xdr, &gc->gc_v) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &gc->gc_proc) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &gc->gc_seq) < 0)\n\t\treturn false;\n\tif (xdr_stream_decode_u32(xdr, &gc->gc_svc) < 0)\n\t\treturn false;\n\thandle_len = xdr_stream_decode_opaque_inline(xdr,\n\t\t\t\t\t\t     (void **)&gc->gc_ctx.data,\n\t\t\t\t\t\t     body_len);\n\tif (handle_len < 0)\n\t\treturn false;\n\tif (body_len != XDR_UNIT * 5 + xdr_align_size(handle_len))\n\t\treturn false;\n\n\tgc->gc_ctx.len = handle_len;\n\treturn true;\n}\n\n \nstatic enum svc_auth_status\nsvcauth_gss_accept(struct svc_rqst *rqstp)\n{\n\tstruct gss_svc_data *svcdata = rqstp->rq_auth_data;\n\t__be32\t\t*rpcstart;\n\tstruct rpc_gss_wire_cred *gc;\n\tstruct rsc\t*rsci = NULL;\n\tint\t\tret;\n\tstruct sunrpc_net *sn = net_generic(SVC_NET(rqstp), sunrpc_net_id);\n\n\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\tif (!svcdata)\n\t\tsvcdata = kmalloc(sizeof(*svcdata), GFP_KERNEL);\n\tif (!svcdata)\n\t\tgoto auth_err;\n\trqstp->rq_auth_data = svcdata;\n\tsvcdata->gsd_databody_offset = 0;\n\tsvcdata->rsci = NULL;\n\tgc = &svcdata->clcred;\n\n\tif (!svcauth_gss_decode_credbody(&rqstp->rq_arg_stream, gc, &rpcstart))\n\t\tgoto auth_err;\n\tif (gc->gc_v != RPC_GSS_VERSION)\n\t\tgoto auth_err;\n\n\tswitch (gc->gc_proc) {\n\tcase RPC_GSS_PROC_INIT:\n\tcase RPC_GSS_PROC_CONTINUE_INIT:\n\t\tif (rqstp->rq_proc != 0)\n\t\t\tgoto auth_err;\n\t\treturn svcauth_gss_proc_init(rqstp, gc);\n\tcase RPC_GSS_PROC_DESTROY:\n\t\tif (rqstp->rq_proc != 0)\n\t\t\tgoto auth_err;\n\t\tfallthrough;\n\tcase RPC_GSS_PROC_DATA:\n\t\trqstp->rq_auth_stat = rpcsec_gsserr_credproblem;\n\t\trsci = gss_svc_searchbyctx(sn->rsc_cache, &gc->gc_ctx);\n\t\tif (!rsci)\n\t\t\tgoto auth_err;\n\t\tswitch (svcauth_gss_verify_header(rqstp, rsci, rpcstart, gc)) {\n\t\tcase SVC_OK:\n\t\t\tbreak;\n\t\tcase SVC_DENIED:\n\t\t\tgoto auth_err;\n\t\tcase SVC_DROP:\n\t\t\tgoto drop;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (rqstp->rq_proc != 0)\n\t\t\tgoto auth_err;\n\t\trqstp->rq_auth_stat = rpc_autherr_rejectedcred;\n\t\tgoto auth_err;\n\t}\n\n\t \n\tswitch (gc->gc_proc) {\n\tcase RPC_GSS_PROC_DESTROY:\n\t\tif (!svcauth_gss_encode_verf(rqstp, rsci->mechctx, gc->gc_seq))\n\t\t\tgoto auth_err;\n\t\tif (!svcxdr_set_accept_stat(rqstp))\n\t\t\tgoto auth_err;\n\t\t \n\t\tsunrpc_cache_unhash(sn->rsc_cache, &rsci->h);\n\t\tgoto complete;\n\tcase RPC_GSS_PROC_DATA:\n\t\trqstp->rq_auth_stat = rpcsec_gsserr_ctxproblem;\n\t\tif (!svcauth_gss_encode_verf(rqstp, rsci->mechctx, gc->gc_seq))\n\t\t\tgoto auth_err;\n\t\tif (!svcxdr_set_accept_stat(rqstp))\n\t\t\tgoto auth_err;\n\t\tsvcdata->gsd_databody_offset = xdr_stream_pos(&rqstp->rq_res_stream);\n\t\trqstp->rq_cred = rsci->cred;\n\t\tget_group_info(rsci->cred.cr_group_info);\n\t\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\t\tswitch (gc->gc_svc) {\n\t\tcase RPC_GSS_SVC_NONE:\n\t\t\tbreak;\n\t\tcase RPC_GSS_SVC_INTEGRITY:\n\t\t\t \n\t\t\txdr_reserve_space(&rqstp->rq_res_stream, XDR_UNIT * 2);\n\t\t\tif (svcauth_gss_unwrap_integ(rqstp, gc->gc_seq,\n\t\t\t\t\t\t     rsci->mechctx))\n\t\t\t\tgoto garbage_args;\n\t\t\tsvcxdr_set_auth_slack(rqstp, RPC_MAX_AUTH_SIZE);\n\t\t\tbreak;\n\t\tcase RPC_GSS_SVC_PRIVACY:\n\t\t\t \n\t\t\txdr_reserve_space(&rqstp->rq_res_stream, XDR_UNIT * 2);\n\t\t\tif (svcauth_gss_unwrap_priv(rqstp, gc->gc_seq,\n\t\t\t\t\t\t    rsci->mechctx))\n\t\t\t\tgoto garbage_args;\n\t\t\tsvcxdr_set_auth_slack(rqstp, RPC_MAX_AUTH_SIZE * 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto auth_err;\n\t\t}\n\t\tsvcdata->rsci = rsci;\n\t\tcache_get(&rsci->h);\n\t\trqstp->rq_cred.cr_flavor = gss_svc_to_pseudoflavor(\n\t\t\t\t\trsci->mechctx->mech_type,\n\t\t\t\t\tGSS_C_QOP_DEFAULT,\n\t\t\t\t\tgc->gc_svc);\n\t\tret = SVC_OK;\n\t\ttrace_rpcgss_svc_authenticate(rqstp, gc);\n\t\tgoto out;\n\t}\ngarbage_args:\n\tret = SVC_GARBAGE;\n\tgoto out;\nauth_err:\n\txdr_truncate_encode(&rqstp->rq_res_stream, XDR_UNIT * 2);\n\tret = SVC_DENIED;\n\tgoto out;\ncomplete:\n\tret = SVC_COMPLETE;\n\tgoto out;\ndrop:\n\tret = SVC_CLOSE;\nout:\n\tif (rsci)\n\t\tcache_put(&rsci->h, sn->rsc_cache);\n\treturn ret;\n}\n\nstatic u32\nsvcauth_gss_prepare_to_wrap(struct svc_rqst *rqstp, struct gss_svc_data *gsd)\n{\n\tu32 offset;\n\n\t \n\toffset = gsd->gsd_databody_offset;\n\tgsd->gsd_databody_offset = 0;\n\n\t \n\tif (rqstp->rq_auth_stat != rpc_auth_ok)\n\t\treturn 0;\n\n\t \n\tif (*rqstp->rq_accept_statp != rpc_success)\n\t\treturn 0;\n\n\treturn offset;\n}\n\n \nstatic int svcauth_gss_wrap_integ(struct svc_rqst *rqstp)\n{\n\tstruct gss_svc_data *gsd = rqstp->rq_auth_data;\n\tstruct xdr_stream *xdr = &rqstp->rq_res_stream;\n\tstruct rpc_gss_wire_cred *gc = &gsd->clcred;\n\tstruct xdr_buf *buf = xdr->buf;\n\tstruct xdr_buf databody_integ;\n\tstruct xdr_netobj checksum;\n\tu32 offset, maj_stat;\n\n\toffset = svcauth_gss_prepare_to_wrap(rqstp, gsd);\n\tif (!offset)\n\t\tgoto out;\n\n\tif (xdr_buf_subsegment(buf, &databody_integ, offset + XDR_UNIT,\n\t\t\t       buf->len - offset - XDR_UNIT))\n\t\tgoto wrap_failed;\n\t \n\tif (xdr_encode_word(buf, offset, databody_integ.len))\n\t\tgoto wrap_failed;\n\tif (xdr_encode_word(buf, offset + XDR_UNIT, gc->gc_seq))\n\t\tgoto wrap_failed;\n\n\tchecksum.data = gsd->gsd_scratch;\n\tmaj_stat = gss_get_mic(gsd->rsci->mechctx, &databody_integ, &checksum);\n\tif (maj_stat != GSS_S_COMPLETE)\n\t\tgoto bad_mic;\n\n\tif (xdr_stream_encode_opaque(xdr, checksum.data, checksum.len) < 0)\n\t\tgoto wrap_failed;\n\txdr_commit_encode(xdr);\n\nout:\n\treturn 0;\n\nbad_mic:\n\ttrace_rpcgss_svc_get_mic(rqstp, maj_stat);\n\treturn -EINVAL;\nwrap_failed:\n\ttrace_rpcgss_svc_wrap_failed(rqstp);\n\treturn -EINVAL;\n}\n\n \nstatic int svcauth_gss_wrap_priv(struct svc_rqst *rqstp)\n{\n\tstruct gss_svc_data *gsd = rqstp->rq_auth_data;\n\tstruct rpc_gss_wire_cred *gc = &gsd->clcred;\n\tstruct xdr_buf *buf = &rqstp->rq_res;\n\tstruct kvec *head = buf->head;\n\tstruct kvec *tail = buf->tail;\n\tu32 offset, pad, maj_stat;\n\t__be32 *p;\n\n\toffset = svcauth_gss_prepare_to_wrap(rqstp, gsd);\n\tif (!offset)\n\t\treturn 0;\n\n\t \n\tif (xdr_encode_word(buf, offset + XDR_UNIT, gc->gc_seq))\n\t\tgoto wrap_failed;\n\n\t \n\tif (tail->iov_base) {\n\t\tif (tail->iov_base >= head->iov_base + PAGE_SIZE)\n\t\t\tgoto wrap_failed;\n\t\tif (tail->iov_base < head->iov_base)\n\t\t\tgoto wrap_failed;\n\t\tif (tail->iov_len + head->iov_len\n\t\t\t\t+ 2 * RPC_MAX_AUTH_SIZE > PAGE_SIZE)\n\t\t\tgoto wrap_failed;\n\t\tmemmove(tail->iov_base + RPC_MAX_AUTH_SIZE, tail->iov_base,\n\t\t\ttail->iov_len);\n\t\ttail->iov_base += RPC_MAX_AUTH_SIZE;\n\t}\n\t \n\tif (!tail->iov_base) {\n\t\tif (head->iov_len + 2 * RPC_MAX_AUTH_SIZE > PAGE_SIZE)\n\t\t\tgoto wrap_failed;\n\t\ttail->iov_base = head->iov_base\n\t\t\t+ head->iov_len + RPC_MAX_AUTH_SIZE;\n\t\ttail->iov_len = 0;\n\t}\n\n\tmaj_stat = gss_wrap(gsd->rsci->mechctx, offset + XDR_UNIT, buf,\n\t\t\t    buf->pages);\n\tif (maj_stat != GSS_S_COMPLETE)\n\t\tgoto bad_wrap;\n\n\t \n\tif (xdr_encode_word(buf, offset, buf->len - offset - XDR_UNIT))\n\t\tgoto wrap_failed;\n\tpad = xdr_pad_size(buf->len - offset - XDR_UNIT);\n\tp = (__be32 *)(tail->iov_base + tail->iov_len);\n\tmemset(p, 0, pad);\n\ttail->iov_len += pad;\n\tbuf->len += pad;\n\n\treturn 0;\nwrap_failed:\n\ttrace_rpcgss_svc_wrap_failed(rqstp);\n\treturn -EINVAL;\nbad_wrap:\n\ttrace_rpcgss_svc_wrap(rqstp, maj_stat);\n\treturn -ENOMEM;\n}\n\n \nstatic int\nsvcauth_gss_release(struct svc_rqst *rqstp)\n{\n\tstruct sunrpc_net *sn = net_generic(SVC_NET(rqstp), sunrpc_net_id);\n\tstruct gss_svc_data *gsd = rqstp->rq_auth_data;\n\tstruct rpc_gss_wire_cred *gc;\n\tint stat;\n\n\tif (!gsd)\n\t\tgoto out;\n\tgc = &gsd->clcred;\n\tif (gc->gc_proc != RPC_GSS_PROC_DATA)\n\t\tgoto out;\n\n\tswitch (gc->gc_svc) {\n\tcase RPC_GSS_SVC_NONE:\n\t\tbreak;\n\tcase RPC_GSS_SVC_INTEGRITY:\n\t\tstat = svcauth_gss_wrap_integ(rqstp);\n\t\tif (stat)\n\t\t\tgoto out_err;\n\t\tbreak;\n\tcase RPC_GSS_SVC_PRIVACY:\n\t\tstat = svcauth_gss_wrap_priv(rqstp);\n\t\tif (stat)\n\t\t\tgoto out_err;\n\t\tbreak;\n\t \n\t}\n\nout:\n\tstat = 0;\nout_err:\n\tif (rqstp->rq_client)\n\t\tauth_domain_put(rqstp->rq_client);\n\trqstp->rq_client = NULL;\n\tif (rqstp->rq_gssclient)\n\t\tauth_domain_put(rqstp->rq_gssclient);\n\trqstp->rq_gssclient = NULL;\n\tif (rqstp->rq_cred.cr_group_info)\n\t\tput_group_info(rqstp->rq_cred.cr_group_info);\n\trqstp->rq_cred.cr_group_info = NULL;\n\tif (gsd && gsd->rsci) {\n\t\tcache_put(&gsd->rsci->h, sn->rsc_cache);\n\t\tgsd->rsci = NULL;\n\t}\n\treturn stat;\n}\n\nstatic void\nsvcauth_gss_domain_release_rcu(struct rcu_head *head)\n{\n\tstruct auth_domain *dom = container_of(head, struct auth_domain, rcu_head);\n\tstruct gss_domain *gd = container_of(dom, struct gss_domain, h);\n\n\tkfree(dom->name);\n\tkfree(gd);\n}\n\nstatic void\nsvcauth_gss_domain_release(struct auth_domain *dom)\n{\n\tcall_rcu(&dom->rcu_head, svcauth_gss_domain_release_rcu);\n}\n\nstatic struct auth_ops svcauthops_gss = {\n\t.name\t\t= \"rpcsec_gss\",\n\t.owner\t\t= THIS_MODULE,\n\t.flavour\t= RPC_AUTH_GSS,\n\t.accept\t\t= svcauth_gss_accept,\n\t.release\t= svcauth_gss_release,\n\t.domain_release = svcauth_gss_domain_release,\n\t.set_client\t= svcauth_gss_set_client,\n};\n\nstatic int rsi_cache_create_net(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct cache_detail *cd;\n\tint err;\n\n\tcd = cache_create_net(&rsi_cache_template, net);\n\tif (IS_ERR(cd))\n\t\treturn PTR_ERR(cd);\n\terr = cache_register_net(cd, net);\n\tif (err) {\n\t\tcache_destroy_net(cd, net);\n\t\treturn err;\n\t}\n\tsn->rsi_cache = cd;\n\treturn 0;\n}\n\nstatic void rsi_cache_destroy_net(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct cache_detail *cd = sn->rsi_cache;\n\n\tsn->rsi_cache = NULL;\n\tcache_purge(cd);\n\tcache_unregister_net(cd, net);\n\tcache_destroy_net(cd, net);\n}\n\nstatic int rsc_cache_create_net(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct cache_detail *cd;\n\tint err;\n\n\tcd = cache_create_net(&rsc_cache_template, net);\n\tif (IS_ERR(cd))\n\t\treturn PTR_ERR(cd);\n\terr = cache_register_net(cd, net);\n\tif (err) {\n\t\tcache_destroy_net(cd, net);\n\t\treturn err;\n\t}\n\tsn->rsc_cache = cd;\n\treturn 0;\n}\n\nstatic void rsc_cache_destroy_net(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct cache_detail *cd = sn->rsc_cache;\n\n\tsn->rsc_cache = NULL;\n\tcache_purge(cd);\n\tcache_unregister_net(cd, net);\n\tcache_destroy_net(cd, net);\n}\n\nint\ngss_svc_init_net(struct net *net)\n{\n\tint rv;\n\n\trv = rsc_cache_create_net(net);\n\tif (rv)\n\t\treturn rv;\n\trv = rsi_cache_create_net(net);\n\tif (rv)\n\t\tgoto out1;\n\trv = create_use_gss_proxy_proc_entry(net);\n\tif (rv)\n\t\tgoto out2;\n\n\trv = create_krb5_enctypes_proc_entry(net);\n\tif (rv)\n\t\tgoto out3;\n\n\treturn 0;\n\nout3:\n\tdestroy_use_gss_proxy_proc_entry(net);\nout2:\n\trsi_cache_destroy_net(net);\nout1:\n\trsc_cache_destroy_net(net);\n\treturn rv;\n}\n\nvoid\ngss_svc_shutdown_net(struct net *net)\n{\n\tdestroy_krb5_enctypes_proc_entry(net);\n\tdestroy_use_gss_proxy_proc_entry(net);\n\trsi_cache_destroy_net(net);\n\trsc_cache_destroy_net(net);\n}\n\nint\ngss_svc_init(void)\n{\n\treturn svc_auth_register(RPC_AUTH_GSS, &svcauthops_gss);\n}\n\nvoid\ngss_svc_shutdown(void)\n{\n\tsvc_auth_unregister(RPC_AUTH_GSS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}