{
  "module_name": "gss_krb5_wrap.c",
  "hash_id": "12f25c5d40c0aee26e6e89688b0882812bc461cb431d9d7956030f2071a95b80",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth_gss/gss_krb5_wrap.c",
  "human_readable_source": " \n\n#include <crypto/skcipher.h>\n#include <linux/types.h>\n#include <linux/jiffies.h>\n#include <linux/sunrpc/gss_krb5.h>\n#include <linux/pagemap.h>\n\n#include \"gss_krb5_internal.h\"\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n# define RPCDBG_FACILITY\tRPCDBG_AUTH\n#endif\n\n \n#define LOCAL_BUF_LEN 32u\n\nstatic void rotate_buf_a_little(struct xdr_buf *buf, unsigned int shift)\n{\n\tchar head[LOCAL_BUF_LEN];\n\tchar tmp[LOCAL_BUF_LEN];\n\tunsigned int this_len, i;\n\n\tBUG_ON(shift > LOCAL_BUF_LEN);\n\n\tread_bytes_from_xdr_buf(buf, 0, head, shift);\n\tfor (i = 0; i + shift < buf->len; i += LOCAL_BUF_LEN) {\n\t\tthis_len = min(LOCAL_BUF_LEN, buf->len - (i + shift));\n\t\tread_bytes_from_xdr_buf(buf, i+shift, tmp, this_len);\n\t\twrite_bytes_to_xdr_buf(buf, i, tmp, this_len);\n\t}\n\twrite_bytes_to_xdr_buf(buf, buf->len - shift, head, shift);\n}\n\nstatic void _rotate_left(struct xdr_buf *buf, unsigned int shift)\n{\n\tint shifted = 0;\n\tint this_shift;\n\n\tshift %= buf->len;\n\twhile (shifted < shift) {\n\t\tthis_shift = min(shift - shifted, LOCAL_BUF_LEN);\n\t\trotate_buf_a_little(buf, this_shift);\n\t\tshifted += this_shift;\n\t}\n}\n\nstatic void rotate_left(u32 base, struct xdr_buf *buf, unsigned int shift)\n{\n\tstruct xdr_buf subbuf;\n\n\txdr_buf_subsegment(buf, &subbuf, base, buf->len - base);\n\t_rotate_left(&subbuf, shift);\n}\n\nu32\ngss_krb5_wrap_v2(struct krb5_ctx *kctx, int offset,\n\t\t struct xdr_buf *buf, struct page **pages)\n{\n\tu8\t\t*ptr;\n\ttime64_t\tnow;\n\tu8\t\tflags = 0x00;\n\t__be16\t\t*be16ptr;\n\t__be64\t\t*be64ptr;\n\tu32\t\terr;\n\n\tdprintk(\"RPC:       %s\\n\", __func__);\n\n\t \n\tif (xdr_extend_head(buf, offset, GSS_KRB5_TOK_HDR_LEN))\n\t\treturn GSS_S_FAILURE;\n\n\t \n\tptr = buf->head[0].iov_base + offset;\n\t*ptr++ = (unsigned char) ((KG2_TOK_WRAP>>8) & 0xff);\n\t*ptr++ = (unsigned char) (KG2_TOK_WRAP & 0xff);\n\n\tif ((kctx->flags & KRB5_CTX_FLAG_INITIATOR) == 0)\n\t\tflags |= KG2_TOKEN_FLAG_SENTBYACCEPTOR;\n\tif ((kctx->flags & KRB5_CTX_FLAG_ACCEPTOR_SUBKEY) != 0)\n\t\tflags |= KG2_TOKEN_FLAG_ACCEPTORSUBKEY;\n\t \n\tflags |= KG2_TOKEN_FLAG_SEALED;\n\n\t*ptr++ = flags;\n\t*ptr++ = 0xff;\n\tbe16ptr = (__be16 *)ptr;\n\n\t*be16ptr++ = 0;\n\t \n\t*be16ptr++ = 0;\n\n\tbe64ptr = (__be64 *)be16ptr;\n\t*be64ptr = cpu_to_be64(atomic64_fetch_inc(&kctx->seq_send64));\n\n\terr = (*kctx->gk5e->encrypt)(kctx, offset, buf, pages);\n\tif (err)\n\t\treturn err;\n\n\tnow = ktime_get_real_seconds();\n\treturn (kctx->endtime < now) ? GSS_S_CONTEXT_EXPIRED : GSS_S_COMPLETE;\n}\n\nu32\ngss_krb5_unwrap_v2(struct krb5_ctx *kctx, int offset, int len,\n\t\t   struct xdr_buf *buf, unsigned int *slack,\n\t\t   unsigned int *align)\n{\n\ttime64_t\tnow;\n\tu8\t\t*ptr;\n\tu8\t\tflags = 0x00;\n\tu16\t\tec, rrc;\n\tint\t\terr;\n\tu32\t\theadskip, tailskip;\n\tu8\t\tdecrypted_hdr[GSS_KRB5_TOK_HDR_LEN];\n\tunsigned int\tmovelen;\n\n\n\tdprintk(\"RPC:       %s\\n\", __func__);\n\n\tptr = buf->head[0].iov_base + offset;\n\n\tif (be16_to_cpu(*((__be16 *)ptr)) != KG2_TOK_WRAP)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tflags = ptr[2];\n\tif ((!kctx->initiate && (flags & KG2_TOKEN_FLAG_SENTBYACCEPTOR)) ||\n\t    (kctx->initiate && !(flags & KG2_TOKEN_FLAG_SENTBYACCEPTOR)))\n\t\treturn GSS_S_BAD_SIG;\n\n\tif ((flags & KG2_TOKEN_FLAG_SEALED) == 0) {\n\t\tdprintk(\"%s: token missing expected sealed flag\\n\", __func__);\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\n\tif (ptr[3] != 0xff)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tec = be16_to_cpup((__be16 *)(ptr + 4));\n\trrc = be16_to_cpup((__be16 *)(ptr + 6));\n\n\t \n\n\tif (rrc != 0)\n\t\trotate_left(offset + 16, buf, rrc);\n\n\terr = (*kctx->gk5e->decrypt)(kctx, offset, len, buf,\n\t\t\t\t     &headskip, &tailskip);\n\tif (err)\n\t\treturn GSS_S_FAILURE;\n\n\t \n\terr = read_bytes_from_xdr_buf(buf,\n\t\t\t\tlen - GSS_KRB5_TOK_HDR_LEN - tailskip,\n\t\t\t\tdecrypted_hdr, GSS_KRB5_TOK_HDR_LEN);\n\tif (err) {\n\t\tdprintk(\"%s: error %u getting decrypted_hdr\\n\", __func__, err);\n\t\treturn GSS_S_FAILURE;\n\t}\n\tif (memcmp(ptr, decrypted_hdr, 6)\n\t\t\t\t|| memcmp(ptr + 8, decrypted_hdr + 8, 8)) {\n\t\tdprintk(\"%s: token hdr, plaintext hdr mismatch!\\n\", __func__);\n\t\treturn GSS_S_FAILURE;\n\t}\n\n\t \n\n\t \n\tnow = ktime_get_real_seconds();\n\tif (now > kctx->endtime)\n\t\treturn GSS_S_CONTEXT_EXPIRED;\n\n\t \n\tmovelen = min_t(unsigned int, buf->head[0].iov_len, len);\n\tmovelen -= offset + GSS_KRB5_TOK_HDR_LEN + headskip;\n\tBUG_ON(offset + GSS_KRB5_TOK_HDR_LEN + headskip + movelen >\n\t\t\t\t\t\t\tbuf->head[0].iov_len);\n\tmemmove(ptr, ptr + GSS_KRB5_TOK_HDR_LEN + headskip, movelen);\n\tbuf->head[0].iov_len -= GSS_KRB5_TOK_HDR_LEN + headskip;\n\tbuf->len = len - (GSS_KRB5_TOK_HDR_LEN + headskip);\n\n\t \n\txdr_buf_trim(buf, ec + GSS_KRB5_TOK_HDR_LEN + tailskip);\n\n\t*align = XDR_QUADLEN(GSS_KRB5_TOK_HDR_LEN + headskip);\n\t*slack = *align + XDR_QUADLEN(ec + GSS_KRB5_TOK_HDR_LEN + tailskip);\n\treturn GSS_S_COMPLETE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}