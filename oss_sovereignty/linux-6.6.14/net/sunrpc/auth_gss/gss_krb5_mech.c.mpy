{
  "module_name": "gss_krb5_mech.c",
  "hash_id": "e344d7be19b487f64b02d7b1e03ae81b65f227bac9130d807e95115538676028",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth_gss/gss_krb5_mech.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include <crypto/skcipher.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/gss_krb5.h>\n#include <linux/sunrpc/xdr.h>\n#include <kunit/visibility.h>\n\n#include \"auth_gss_internal.h\"\n#include \"gss_krb5_internal.h\"\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n# define RPCDBG_FACILITY\tRPCDBG_AUTH\n#endif\n\nstatic struct gss_api_mech gss_kerberos_mech;\n\nstatic const struct gss_krb5_enctype supported_gss_krb5_enctypes[] = {\n#if defined(CONFIG_RPCSEC_GSS_KRB5_ENCTYPES_AES_SHA1)\n\t \n\t{\n\t  .etype = ENCTYPE_AES128_CTS_HMAC_SHA1_96,\n\t  .ctype = CKSUMTYPE_HMAC_SHA1_96_AES128,\n\t  .name = \"aes128-cts\",\n\t  .encrypt_name = \"cts(cbc(aes))\",\n\t  .aux_cipher = \"cbc(aes)\",\n\t  .cksum_name = \"hmac(sha1)\",\n\t  .derive_key = krb5_derive_key_v2,\n\t  .encrypt = gss_krb5_aes_encrypt,\n\t  .decrypt = gss_krb5_aes_decrypt,\n\n\t  .get_mic = gss_krb5_get_mic_v2,\n\t  .verify_mic = gss_krb5_verify_mic_v2,\n\t  .wrap = gss_krb5_wrap_v2,\n\t  .unwrap = gss_krb5_unwrap_v2,\n\n\t  .signalg = -1,\n\t  .sealalg = -1,\n\t  .keybytes = 16,\n\t  .keylength = BITS2OCTETS(128),\n\t  .Kc_length = BITS2OCTETS(128),\n\t  .Ke_length = BITS2OCTETS(128),\n\t  .Ki_length = BITS2OCTETS(128),\n\t  .cksumlength = BITS2OCTETS(96),\n\t  .keyed_cksum = 1,\n\t},\n\t \n\t{\n\t  .etype = ENCTYPE_AES256_CTS_HMAC_SHA1_96,\n\t  .ctype = CKSUMTYPE_HMAC_SHA1_96_AES256,\n\t  .name = \"aes256-cts\",\n\t  .encrypt_name = \"cts(cbc(aes))\",\n\t  .aux_cipher = \"cbc(aes)\",\n\t  .cksum_name = \"hmac(sha1)\",\n\t  .derive_key = krb5_derive_key_v2,\n\t  .encrypt = gss_krb5_aes_encrypt,\n\t  .decrypt = gss_krb5_aes_decrypt,\n\n\t  .get_mic = gss_krb5_get_mic_v2,\n\t  .verify_mic = gss_krb5_verify_mic_v2,\n\t  .wrap = gss_krb5_wrap_v2,\n\t  .unwrap = gss_krb5_unwrap_v2,\n\n\t  .signalg = -1,\n\t  .sealalg = -1,\n\t  .keybytes = 32,\n\t  .keylength = BITS2OCTETS(256),\n\t  .Kc_length = BITS2OCTETS(256),\n\t  .Ke_length = BITS2OCTETS(256),\n\t  .Ki_length = BITS2OCTETS(256),\n\t  .cksumlength = BITS2OCTETS(96),\n\t  .keyed_cksum = 1,\n\t},\n#endif\n\n#if defined(CONFIG_RPCSEC_GSS_KRB5_ENCTYPES_CAMELLIA)\n\t \n\t{\n\t\t.etype\t\t= ENCTYPE_CAMELLIA128_CTS_CMAC,\n\t\t.ctype\t\t= CKSUMTYPE_CMAC_CAMELLIA128,\n\t\t.name\t\t= \"camellia128-cts-cmac\",\n\t\t.encrypt_name\t= \"cts(cbc(camellia))\",\n\t\t.aux_cipher\t= \"cbc(camellia)\",\n\t\t.cksum_name\t= \"cmac(camellia)\",\n\t\t.cksumlength\t= BITS2OCTETS(128),\n\t\t.keyed_cksum\t= 1,\n\t\t.keylength\t= BITS2OCTETS(128),\n\t\t.Kc_length\t= BITS2OCTETS(128),\n\t\t.Ke_length\t= BITS2OCTETS(128),\n\t\t.Ki_length\t= BITS2OCTETS(128),\n\n\t\t.derive_key\t= krb5_kdf_feedback_cmac,\n\t\t.encrypt\t= gss_krb5_aes_encrypt,\n\t\t.decrypt\t= gss_krb5_aes_decrypt,\n\n\t\t.get_mic\t= gss_krb5_get_mic_v2,\n\t\t.verify_mic\t= gss_krb5_verify_mic_v2,\n\t\t.wrap\t\t= gss_krb5_wrap_v2,\n\t\t.unwrap\t\t= gss_krb5_unwrap_v2,\n\t},\n\t \n\t{\n\t\t.etype\t\t= ENCTYPE_CAMELLIA256_CTS_CMAC,\n\t\t.ctype\t\t= CKSUMTYPE_CMAC_CAMELLIA256,\n\t\t.name\t\t= \"camellia256-cts-cmac\",\n\t\t.encrypt_name\t= \"cts(cbc(camellia))\",\n\t\t.aux_cipher\t= \"cbc(camellia)\",\n\t\t.cksum_name\t= \"cmac(camellia)\",\n\t\t.cksumlength\t= BITS2OCTETS(128),\n\t\t.keyed_cksum\t= 1,\n\t\t.keylength\t= BITS2OCTETS(256),\n\t\t.Kc_length\t= BITS2OCTETS(256),\n\t\t.Ke_length\t= BITS2OCTETS(256),\n\t\t.Ki_length\t= BITS2OCTETS(256),\n\n\t\t.derive_key\t= krb5_kdf_feedback_cmac,\n\t\t.encrypt\t= gss_krb5_aes_encrypt,\n\t\t.decrypt\t= gss_krb5_aes_decrypt,\n\n\t\t.get_mic\t= gss_krb5_get_mic_v2,\n\t\t.verify_mic\t= gss_krb5_verify_mic_v2,\n\t\t.wrap\t\t= gss_krb5_wrap_v2,\n\t\t.unwrap\t\t= gss_krb5_unwrap_v2,\n\t},\n#endif\n\n#if defined(CONFIG_RPCSEC_GSS_KRB5_ENCTYPES_AES_SHA2)\n\t \n\t{\n\t\t.etype\t\t= ENCTYPE_AES128_CTS_HMAC_SHA256_128,\n\t\t.ctype\t\t= CKSUMTYPE_HMAC_SHA256_128_AES128,\n\t\t.name\t\t= \"aes128-cts-hmac-sha256-128\",\n\t\t.encrypt_name\t= \"cts(cbc(aes))\",\n\t\t.aux_cipher\t= \"cbc(aes)\",\n\t\t.cksum_name\t= \"hmac(sha256)\",\n\t\t.cksumlength\t= BITS2OCTETS(128),\n\t\t.keyed_cksum\t= 1,\n\t\t.keylength\t= BITS2OCTETS(128),\n\t\t.Kc_length\t= BITS2OCTETS(128),\n\t\t.Ke_length\t= BITS2OCTETS(128),\n\t\t.Ki_length\t= BITS2OCTETS(128),\n\n\t\t.derive_key\t= krb5_kdf_hmac_sha2,\n\t\t.encrypt\t= krb5_etm_encrypt,\n\t\t.decrypt\t= krb5_etm_decrypt,\n\n\t\t.get_mic\t= gss_krb5_get_mic_v2,\n\t\t.verify_mic\t= gss_krb5_verify_mic_v2,\n\t\t.wrap\t\t= gss_krb5_wrap_v2,\n\t\t.unwrap\t\t= gss_krb5_unwrap_v2,\n\t},\n\t \n\t{\n\t\t.etype\t\t= ENCTYPE_AES256_CTS_HMAC_SHA384_192,\n\t\t.ctype\t\t= CKSUMTYPE_HMAC_SHA384_192_AES256,\n\t\t.name\t\t= \"aes256-cts-hmac-sha384-192\",\n\t\t.encrypt_name\t= \"cts(cbc(aes))\",\n\t\t.aux_cipher\t= \"cbc(aes)\",\n\t\t.cksum_name\t= \"hmac(sha384)\",\n\t\t.cksumlength\t= BITS2OCTETS(192),\n\t\t.keyed_cksum\t= 1,\n\t\t.keylength\t= BITS2OCTETS(256),\n\t\t.Kc_length\t= BITS2OCTETS(192),\n\t\t.Ke_length\t= BITS2OCTETS(256),\n\t\t.Ki_length\t= BITS2OCTETS(192),\n\n\t\t.derive_key\t= krb5_kdf_hmac_sha2,\n\t\t.encrypt\t= krb5_etm_encrypt,\n\t\t.decrypt\t= krb5_etm_decrypt,\n\n\t\t.get_mic\t= gss_krb5_get_mic_v2,\n\t\t.verify_mic\t= gss_krb5_verify_mic_v2,\n\t\t.wrap\t\t= gss_krb5_wrap_v2,\n\t\t.unwrap\t\t= gss_krb5_unwrap_v2,\n\t},\n#endif\n};\n\n \nstatic char gss_krb5_enctype_priority_list[64];\n\nstatic void gss_krb5_prepare_enctype_priority_list(void)\n{\n\tstatic const u32 gss_krb5_enctypes[] = {\n#if defined(CONFIG_RPCSEC_GSS_KRB5_ENCTYPES_AES_SHA2)\n\t\tENCTYPE_AES256_CTS_HMAC_SHA384_192,\n\t\tENCTYPE_AES128_CTS_HMAC_SHA256_128,\n#endif\n#if defined(CONFIG_RPCSEC_GSS_KRB5_ENCTYPES_CAMELLIA)\n\t\tENCTYPE_CAMELLIA256_CTS_CMAC,\n\t\tENCTYPE_CAMELLIA128_CTS_CMAC,\n#endif\n#if defined(CONFIG_RPCSEC_GSS_KRB5_ENCTYPES_AES_SHA1)\n\t\tENCTYPE_AES256_CTS_HMAC_SHA1_96,\n\t\tENCTYPE_AES128_CTS_HMAC_SHA1_96,\n#endif\n\t};\n\tsize_t total, i;\n\tchar buf[16];\n\tchar *sep;\n\tint n;\n\n\tsep = \"\";\n\tgss_krb5_enctype_priority_list[0] = '\\0';\n\tfor (total = 0, i = 0; i < ARRAY_SIZE(gss_krb5_enctypes); i++) {\n\t\tn = sprintf(buf, \"%s%u\", sep, gss_krb5_enctypes[i]);\n\t\tif (n < 0)\n\t\t\tbreak;\n\t\tif (total + n >= sizeof(gss_krb5_enctype_priority_list))\n\t\t\tbreak;\n\t\tstrcat(gss_krb5_enctype_priority_list, buf);\n\t\tsep = \",\";\n\t\ttotal += n;\n\t}\n}\n\n \nVISIBLE_IF_KUNIT\nconst struct gss_krb5_enctype *gss_krb5_lookup_enctype(u32 etype)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(supported_gss_krb5_enctypes); i++)\n\t\tif (supported_gss_krb5_enctypes[i].etype == etype)\n\t\t\treturn &supported_gss_krb5_enctypes[i];\n\treturn NULL;\n}\nEXPORT_SYMBOL_IF_KUNIT(gss_krb5_lookup_enctype);\n\nstatic struct crypto_sync_skcipher *\ngss_krb5_alloc_cipher_v2(const char *cname, const struct xdr_netobj *key)\n{\n\tstruct crypto_sync_skcipher *tfm;\n\n\ttfm = crypto_alloc_sync_skcipher(cname, 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn NULL;\n\tif (crypto_sync_skcipher_setkey(tfm, key->data, key->len)) {\n\t\tcrypto_free_sync_skcipher(tfm);\n\t\treturn NULL;\n\t}\n\treturn tfm;\n}\n\nstatic struct crypto_ahash *\ngss_krb5_alloc_hash_v2(struct krb5_ctx *kctx, const struct xdr_netobj *key)\n{\n\tstruct crypto_ahash *tfm;\n\n\ttfm = crypto_alloc_ahash(kctx->gk5e->cksum_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm))\n\t\treturn NULL;\n\tif (crypto_ahash_setkey(tfm, key->data, key->len)) {\n\t\tcrypto_free_ahash(tfm);\n\t\treturn NULL;\n\t}\n\treturn tfm;\n}\n\nstatic int\ngss_krb5_import_ctx_v2(struct krb5_ctx *ctx, gfp_t gfp_mask)\n{\n\tstruct xdr_netobj keyin = {\n\t\t.len\t= ctx->gk5e->keylength,\n\t\t.data\t= ctx->Ksess,\n\t};\n\tstruct xdr_netobj keyout;\n\tint ret = -EINVAL;\n\n\tkeyout.data = kmalloc(GSS_KRB5_MAX_KEYLEN, gfp_mask);\n\tif (!keyout.data)\n\t\treturn -ENOMEM;\n\n\t \n\tkeyout.len = ctx->gk5e->Ke_length;\n\tif (krb5_derive_key(ctx, &keyin, &keyout, KG_USAGE_INITIATOR_SEAL,\n\t\t\t    KEY_USAGE_SEED_ENCRYPTION, gfp_mask))\n\t\tgoto out;\n\tctx->initiator_enc = gss_krb5_alloc_cipher_v2(ctx->gk5e->encrypt_name,\n\t\t\t\t\t\t      &keyout);\n\tif (ctx->initiator_enc == NULL)\n\t\tgoto out;\n\tif (ctx->gk5e->aux_cipher) {\n\t\tctx->initiator_enc_aux =\n\t\t\tgss_krb5_alloc_cipher_v2(ctx->gk5e->aux_cipher,\n\t\t\t\t\t\t &keyout);\n\t\tif (ctx->initiator_enc_aux == NULL)\n\t\t\tgoto out_free;\n\t}\n\n\t \n\tif (krb5_derive_key(ctx, &keyin, &keyout, KG_USAGE_ACCEPTOR_SEAL,\n\t\t\t    KEY_USAGE_SEED_ENCRYPTION, gfp_mask))\n\t\tgoto out_free;\n\tctx->acceptor_enc = gss_krb5_alloc_cipher_v2(ctx->gk5e->encrypt_name,\n\t\t\t\t\t\t     &keyout);\n\tif (ctx->acceptor_enc == NULL)\n\t\tgoto out_free;\n\tif (ctx->gk5e->aux_cipher) {\n\t\tctx->acceptor_enc_aux =\n\t\t\tgss_krb5_alloc_cipher_v2(ctx->gk5e->aux_cipher,\n\t\t\t\t\t\t &keyout);\n\t\tif (ctx->acceptor_enc_aux == NULL)\n\t\t\tgoto out_free;\n\t}\n\n\t \n\tkeyout.len = ctx->gk5e->Kc_length;\n\tif (krb5_derive_key(ctx, &keyin, &keyout, KG_USAGE_INITIATOR_SIGN,\n\t\t\t    KEY_USAGE_SEED_CHECKSUM, gfp_mask))\n\t\tgoto out_free;\n\tctx->initiator_sign = gss_krb5_alloc_hash_v2(ctx, &keyout);\n\tif (ctx->initiator_sign == NULL)\n\t\tgoto out_free;\n\n\t \n\tif (krb5_derive_key(ctx, &keyin, &keyout, KG_USAGE_ACCEPTOR_SIGN,\n\t\t\t    KEY_USAGE_SEED_CHECKSUM, gfp_mask))\n\t\tgoto out_free;\n\tctx->acceptor_sign = gss_krb5_alloc_hash_v2(ctx, &keyout);\n\tif (ctx->acceptor_sign == NULL)\n\t\tgoto out_free;\n\n\t \n\tkeyout.len = ctx->gk5e->Ki_length;\n\tif (krb5_derive_key(ctx, &keyin, &keyout, KG_USAGE_INITIATOR_SEAL,\n\t\t\t    KEY_USAGE_SEED_INTEGRITY, gfp_mask))\n\t\tgoto out_free;\n\tctx->initiator_integ = gss_krb5_alloc_hash_v2(ctx, &keyout);\n\tif (ctx->initiator_integ == NULL)\n\t\tgoto out_free;\n\n\t \n\tif (krb5_derive_key(ctx, &keyin, &keyout, KG_USAGE_ACCEPTOR_SEAL,\n\t\t\t    KEY_USAGE_SEED_INTEGRITY, gfp_mask))\n\t\tgoto out_free;\n\tctx->acceptor_integ = gss_krb5_alloc_hash_v2(ctx, &keyout);\n\tif (ctx->acceptor_integ == NULL)\n\t\tgoto out_free;\n\n\tret = 0;\nout:\n\tkfree_sensitive(keyout.data);\n\treturn ret;\n\nout_free:\n\tcrypto_free_ahash(ctx->acceptor_integ);\n\tcrypto_free_ahash(ctx->initiator_integ);\n\tcrypto_free_ahash(ctx->acceptor_sign);\n\tcrypto_free_ahash(ctx->initiator_sign);\n\tcrypto_free_sync_skcipher(ctx->acceptor_enc_aux);\n\tcrypto_free_sync_skcipher(ctx->acceptor_enc);\n\tcrypto_free_sync_skcipher(ctx->initiator_enc_aux);\n\tcrypto_free_sync_skcipher(ctx->initiator_enc);\n\tgoto out;\n}\n\nstatic int\ngss_import_v2_context(const void *p, const void *end, struct krb5_ctx *ctx,\n\t\tgfp_t gfp_mask)\n{\n\tu64 seq_send64;\n\tint keylen;\n\tu32 time32;\n\n\tp = simple_get_bytes(p, end, &ctx->flags, sizeof(ctx->flags));\n\tif (IS_ERR(p))\n\t\tgoto out_err;\n\tctx->initiate = ctx->flags & KRB5_CTX_FLAG_INITIATOR;\n\n\tp = simple_get_bytes(p, end, &time32, sizeof(time32));\n\tif (IS_ERR(p))\n\t\tgoto out_err;\n\t \n\tctx->endtime = (time64_t)time32;\n\tp = simple_get_bytes(p, end, &seq_send64, sizeof(seq_send64));\n\tif (IS_ERR(p))\n\t\tgoto out_err;\n\tatomic64_set(&ctx->seq_send64, seq_send64);\n\t \n\tatomic_set(&ctx->seq_send, seq_send64);\n\tif (seq_send64 != atomic_read(&ctx->seq_send)) {\n\t\tdprintk(\"%s: seq_send64 %llx, seq_send %x overflow?\\n\", __func__,\n\t\t\tseq_send64, atomic_read(&ctx->seq_send));\n\t\tp = ERR_PTR(-EINVAL);\n\t\tgoto out_err;\n\t}\n\tp = simple_get_bytes(p, end, &ctx->enctype, sizeof(ctx->enctype));\n\tif (IS_ERR(p))\n\t\tgoto out_err;\n\tctx->gk5e = gss_krb5_lookup_enctype(ctx->enctype);\n\tif (ctx->gk5e == NULL) {\n\t\tdprintk(\"gss_kerberos_mech: unsupported krb5 enctype %u\\n\",\n\t\t\tctx->enctype);\n\t\tp = ERR_PTR(-EINVAL);\n\t\tgoto out_err;\n\t}\n\tkeylen = ctx->gk5e->keylength;\n\n\tp = simple_get_bytes(p, end, ctx->Ksess, keylen);\n\tif (IS_ERR(p))\n\t\tgoto out_err;\n\n\tif (p != end) {\n\t\tp = ERR_PTR(-EINVAL);\n\t\tgoto out_err;\n\t}\n\n\tctx->mech_used.data = kmemdup(gss_kerberos_mech.gm_oid.data,\n\t\t\t\t      gss_kerberos_mech.gm_oid.len, gfp_mask);\n\tif (unlikely(ctx->mech_used.data == NULL)) {\n\t\tp = ERR_PTR(-ENOMEM);\n\t\tgoto out_err;\n\t}\n\tctx->mech_used.len = gss_kerberos_mech.gm_oid.len;\n\n\treturn gss_krb5_import_ctx_v2(ctx, gfp_mask);\n\nout_err:\n\treturn PTR_ERR(p);\n}\n\nstatic int\ngss_krb5_import_sec_context(const void *p, size_t len, struct gss_ctx *ctx_id,\n\t\t\t    time64_t *endtime, gfp_t gfp_mask)\n{\n\tconst void *end = (const void *)((const char *)p + len);\n\tstruct  krb5_ctx *ctx;\n\tint ret;\n\n\tctx = kzalloc(sizeof(*ctx), gfp_mask);\n\tif (ctx == NULL)\n\t\treturn -ENOMEM;\n\n\tret = gss_import_v2_context(p, end, ctx, gfp_mask);\n\tmemzero_explicit(&ctx->Ksess, sizeof(ctx->Ksess));\n\tif (ret) {\n\t\tkfree(ctx);\n\t\treturn ret;\n\t}\n\n\tctx_id->internal_ctx_id = ctx;\n\tif (endtime)\n\t\t*endtime = ctx->endtime;\n\treturn 0;\n}\n\nstatic void\ngss_krb5_delete_sec_context(void *internal_ctx)\n{\n\tstruct krb5_ctx *kctx = internal_ctx;\n\n\tcrypto_free_sync_skcipher(kctx->seq);\n\tcrypto_free_sync_skcipher(kctx->enc);\n\tcrypto_free_sync_skcipher(kctx->acceptor_enc);\n\tcrypto_free_sync_skcipher(kctx->initiator_enc);\n\tcrypto_free_sync_skcipher(kctx->acceptor_enc_aux);\n\tcrypto_free_sync_skcipher(kctx->initiator_enc_aux);\n\tcrypto_free_ahash(kctx->acceptor_sign);\n\tcrypto_free_ahash(kctx->initiator_sign);\n\tcrypto_free_ahash(kctx->acceptor_integ);\n\tcrypto_free_ahash(kctx->initiator_integ);\n\tkfree(kctx->mech_used.data);\n\tkfree(kctx);\n}\n\n \nstatic u32 gss_krb5_get_mic(struct gss_ctx *gctx, struct xdr_buf *text,\n\t\t\t    struct xdr_netobj *token)\n{\n\tstruct krb5_ctx *kctx = gctx->internal_ctx_id;\n\n\treturn kctx->gk5e->get_mic(kctx, text, token);\n}\n\n \nstatic u32 gss_krb5_verify_mic(struct gss_ctx *gctx,\n\t\t\t       struct xdr_buf *message_buffer,\n\t\t\t       struct xdr_netobj *read_token)\n{\n\tstruct krb5_ctx *kctx = gctx->internal_ctx_id;\n\n\treturn kctx->gk5e->verify_mic(kctx, message_buffer, read_token);\n}\n\n \nstatic u32 gss_krb5_wrap(struct gss_ctx *gctx, int offset,\n\t\t\t struct xdr_buf *buf, struct page **pages)\n{\n\tstruct krb5_ctx\t*kctx = gctx->internal_ctx_id;\n\n\treturn kctx->gk5e->wrap(kctx, offset, buf, pages);\n}\n\n \nstatic u32 gss_krb5_unwrap(struct gss_ctx *gctx, int offset,\n\t\t\t   int len, struct xdr_buf *buf)\n{\n\tstruct krb5_ctx\t*kctx = gctx->internal_ctx_id;\n\n\treturn kctx->gk5e->unwrap(kctx, offset, len, buf,\n\t\t\t\t  &gctx->slack, &gctx->align);\n}\n\nstatic const struct gss_api_ops gss_kerberos_ops = {\n\t.gss_import_sec_context\t= gss_krb5_import_sec_context,\n\t.gss_get_mic\t\t= gss_krb5_get_mic,\n\t.gss_verify_mic\t\t= gss_krb5_verify_mic,\n\t.gss_wrap\t\t= gss_krb5_wrap,\n\t.gss_unwrap\t\t= gss_krb5_unwrap,\n\t.gss_delete_sec_context\t= gss_krb5_delete_sec_context,\n};\n\nstatic struct pf_desc gss_kerberos_pfs[] = {\n\t[0] = {\n\t\t.pseudoflavor = RPC_AUTH_GSS_KRB5,\n\t\t.qop = GSS_C_QOP_DEFAULT,\n\t\t.service = RPC_GSS_SVC_NONE,\n\t\t.name = \"krb5\",\n\t},\n\t[1] = {\n\t\t.pseudoflavor = RPC_AUTH_GSS_KRB5I,\n\t\t.qop = GSS_C_QOP_DEFAULT,\n\t\t.service = RPC_GSS_SVC_INTEGRITY,\n\t\t.name = \"krb5i\",\n\t\t.datatouch = true,\n\t},\n\t[2] = {\n\t\t.pseudoflavor = RPC_AUTH_GSS_KRB5P,\n\t\t.qop = GSS_C_QOP_DEFAULT,\n\t\t.service = RPC_GSS_SVC_PRIVACY,\n\t\t.name = \"krb5p\",\n\t\t.datatouch = true,\n\t},\n};\n\nMODULE_ALIAS(\"rpc-auth-gss-krb5\");\nMODULE_ALIAS(\"rpc-auth-gss-krb5i\");\nMODULE_ALIAS(\"rpc-auth-gss-krb5p\");\nMODULE_ALIAS(\"rpc-auth-gss-390003\");\nMODULE_ALIAS(\"rpc-auth-gss-390004\");\nMODULE_ALIAS(\"rpc-auth-gss-390005\");\nMODULE_ALIAS(\"rpc-auth-gss-1.2.840.113554.1.2.2\");\n\nstatic struct gss_api_mech gss_kerberos_mech = {\n\t.gm_name\t= \"krb5\",\n\t.gm_owner\t= THIS_MODULE,\n\t.gm_oid\t\t= { 9, \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\" },\n\t.gm_ops\t\t= &gss_kerberos_ops,\n\t.gm_pf_num\t= ARRAY_SIZE(gss_kerberos_pfs),\n\t.gm_pfs\t\t= gss_kerberos_pfs,\n\t.gm_upcall_enctypes = gss_krb5_enctype_priority_list,\n};\n\nstatic int __init init_kerberos_module(void)\n{\n\tint status;\n\n\tgss_krb5_prepare_enctype_priority_list();\n\tstatus = gss_mech_register(&gss_kerberos_mech);\n\tif (status)\n\t\tprintk(\"Failed to register kerberos gss mechanism!\\n\");\n\treturn status;\n}\n\nstatic void __exit cleanup_kerberos_module(void)\n{\n\tgss_mech_unregister(&gss_kerberos_mech);\n}\n\nMODULE_LICENSE(\"GPL\");\nmodule_init(init_kerberos_module);\nmodule_exit(cleanup_kerberos_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}