{
  "module_name": "auth_gss.c",
  "hash_id": "533f654736fa6877261314c379963c6f69658e2722bb6229b24790180d6f31a6",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/auth_gss/auth_gss.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/auth_gss.h>\n#include <linux/sunrpc/gss_krb5.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/sunrpc/gss_err.h>\n#include <linux/workqueue.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/uaccess.h>\n#include <linux/hashtable.h>\n\n#include \"auth_gss_internal.h\"\n#include \"../netns.h\"\n\n#include <trace/events/rpcgss.h>\n\nstatic const struct rpc_authops authgss_ops;\n\nstatic const struct rpc_credops gss_credops;\nstatic const struct rpc_credops gss_nullops;\n\n#define GSS_RETRY_EXPIRED 5\nstatic unsigned int gss_expired_cred_retry_delay = GSS_RETRY_EXPIRED;\n\n#define GSS_KEY_EXPIRE_TIMEO 240\nstatic unsigned int gss_key_expire_timeo = GSS_KEY_EXPIRE_TIMEO;\n\n#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)\n# define RPCDBG_FACILITY\tRPCDBG_AUTH\n#endif\n\n \n#define GSS_KRB5_MAX_SLACK_NEEDED\t\t\t\t\t\\\n\t(GSS_KRB5_TOK_HDR_LEN\t\t \t\t\\\n\t+ GSS_KRB5_MAX_CKSUM_LEN\t \t\\\n\t+ GSS_KRB5_MAX_BLOCKSIZE\t \t\t\\\n\t+ GSS_KRB5_MAX_BLOCKSIZE\t \t\t\\\n\t+ GSS_KRB5_TOK_HDR_LEN\t\t \t\\\n\t+ GSS_KRB5_MAX_CKSUM_LEN\t \t\t\\\n\t+ XDR_UNIT * 2\t\t\t \t\t\\\n\t+ GSS_KRB5_TOK_HDR_LEN\t\t\t\t\t\t\\\n\t+ GSS_KRB5_MAX_CKSUM_LEN)\n\n#define GSS_CRED_SLACK\t\t(RPC_MAX_AUTH_SIZE * 2)\n \n#define GSS_VERF_SLACK\t\t100\n\nstatic DEFINE_HASHTABLE(gss_auth_hash_table, 4);\nstatic DEFINE_SPINLOCK(gss_auth_hash_lock);\n\nstruct gss_pipe {\n\tstruct rpc_pipe_dir_object pdo;\n\tstruct rpc_pipe *pipe;\n\tstruct rpc_clnt *clnt;\n\tconst char *name;\n\tstruct kref kref;\n};\n\nstruct gss_auth {\n\tstruct kref kref;\n\tstruct hlist_node hash;\n\tstruct rpc_auth rpc_auth;\n\tstruct gss_api_mech *mech;\n\tenum rpc_gss_svc service;\n\tstruct rpc_clnt *client;\n\tstruct net\t*net;\n\tnetns_tracker\tns_tracker;\n\t \n\tstruct gss_pipe *gss_pipe[2];\n\tconst char *target_name;\n};\n\n \nstatic DEFINE_SPINLOCK(pipe_version_lock);\nstatic struct rpc_wait_queue pipe_version_rpc_waitqueue;\nstatic DECLARE_WAIT_QUEUE_HEAD(pipe_version_waitqueue);\nstatic void gss_put_auth(struct gss_auth *gss_auth);\n\nstatic void gss_free_ctx(struct gss_cl_ctx *);\nstatic const struct rpc_pipe_ops gss_upcall_ops_v0;\nstatic const struct rpc_pipe_ops gss_upcall_ops_v1;\n\nstatic inline struct gss_cl_ctx *\ngss_get_ctx(struct gss_cl_ctx *ctx)\n{\n\trefcount_inc(&ctx->count);\n\treturn ctx;\n}\n\nstatic inline void\ngss_put_ctx(struct gss_cl_ctx *ctx)\n{\n\tif (refcount_dec_and_test(&ctx->count))\n\t\tgss_free_ctx(ctx);\n}\n\n \nstatic void\ngss_cred_set_ctx(struct rpc_cred *cred, struct gss_cl_ctx *ctx)\n{\n\tstruct gss_cred *gss_cred = container_of(cred, struct gss_cred, gc_base);\n\n\tif (!test_bit(RPCAUTH_CRED_NEW, &cred->cr_flags))\n\t\treturn;\n\tgss_get_ctx(ctx);\n\trcu_assign_pointer(gss_cred->gc_ctx, ctx);\n\tset_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\n\tsmp_mb__before_atomic();\n\tclear_bit(RPCAUTH_CRED_NEW, &cred->cr_flags);\n}\n\nstatic struct gss_cl_ctx *\ngss_cred_get_ctx(struct rpc_cred *cred)\n{\n\tstruct gss_cred *gss_cred = container_of(cred, struct gss_cred, gc_base);\n\tstruct gss_cl_ctx *ctx = NULL;\n\n\trcu_read_lock();\n\tctx = rcu_dereference(gss_cred->gc_ctx);\n\tif (ctx)\n\t\tgss_get_ctx(ctx);\n\trcu_read_unlock();\n\treturn ctx;\n}\n\nstatic struct gss_cl_ctx *\ngss_alloc_context(void)\n{\n\tstruct gss_cl_ctx *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (ctx != NULL) {\n\t\tctx->gc_proc = RPC_GSS_PROC_DATA;\n\t\tctx->gc_seq = 1;\t \n\t\tspin_lock_init(&ctx->gc_seq_lock);\n\t\trefcount_set(&ctx->count,1);\n\t}\n\treturn ctx;\n}\n\n#define GSSD_MIN_TIMEOUT (60 * 60)\nstatic const void *\ngss_fill_context(const void *p, const void *end, struct gss_cl_ctx *ctx, struct gss_api_mech *gm)\n{\n\tconst void *q;\n\tunsigned int seclen;\n\tunsigned int timeout;\n\tunsigned long now = jiffies;\n\tu32 window_size;\n\tint ret;\n\n\t \n\tp = simple_get_bytes(p, end, &timeout, sizeof(timeout));\n\tif (IS_ERR(p))\n\t\tgoto err;\n\tif (timeout == 0)\n\t\ttimeout = GSSD_MIN_TIMEOUT;\n\tctx->gc_expiry = now + ((unsigned long)timeout * HZ);\n\t \n\tp = simple_get_bytes(p, end, &window_size, sizeof(window_size));\n\tif (IS_ERR(p))\n\t\tgoto err;\n\tctx->gc_win = window_size;\n\t \n\tif (ctx->gc_win == 0) {\n\t\t \n\t\tp = simple_get_bytes(p, end, &ret, sizeof(ret));\n\t\tif (!IS_ERR(p))\n\t\t\tp = (ret == -EKEYEXPIRED) ? ERR_PTR(-EKEYEXPIRED) :\n\t\t\t\t\t\t    ERR_PTR(-EACCES);\n\t\tgoto err;\n\t}\n\t \n\tp = simple_get_netobj(p, end, &ctx->gc_wire_ctx);\n\tif (IS_ERR(p))\n\t\tgoto err;\n\t \n\tp  = simple_get_bytes(p, end, &seclen, sizeof(seclen));\n\tif (IS_ERR(p))\n\t\tgoto err;\n\tq = (const void *)((const char *)p + seclen);\n\tif (unlikely(q > end || q < p)) {\n\t\tp = ERR_PTR(-EFAULT);\n\t\tgoto err;\n\t}\n\tret = gss_import_sec_context(p, seclen, gm, &ctx->gc_gss_ctx, NULL, GFP_KERNEL);\n\tif (ret < 0) {\n\t\ttrace_rpcgss_import_ctx(ret);\n\t\tp = ERR_PTR(ret);\n\t\tgoto err;\n\t}\n\n\t \n\tif (q == end) {\n\t\tp = q;\n\t\tgoto done;\n\t}\n\n\t \n\tp = simple_get_netobj(q, end, &ctx->gc_acceptor);\n\tif (IS_ERR(p))\n\t\tgoto err;\ndone:\n\ttrace_rpcgss_context(window_size, ctx->gc_expiry, now, timeout,\n\t\t\t     ctx->gc_acceptor.len, ctx->gc_acceptor.data);\nerr:\n\treturn p;\n}\n\n \n#define UPCALL_BUF_LEN\t256\n\nstruct gss_upcall_msg {\n\trefcount_t count;\n\tkuid_t\tuid;\n\tconst char *service_name;\n\tstruct rpc_pipe_msg msg;\n\tstruct list_head list;\n\tstruct gss_auth *auth;\n\tstruct rpc_pipe *pipe;\n\tstruct rpc_wait_queue rpc_waitqueue;\n\twait_queue_head_t waitqueue;\n\tstruct gss_cl_ctx *ctx;\n\tchar databuf[UPCALL_BUF_LEN];\n};\n\nstatic int get_pipe_version(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tint ret;\n\n\tspin_lock(&pipe_version_lock);\n\tif (sn->pipe_version >= 0) {\n\t\tatomic_inc(&sn->pipe_users);\n\t\tret = sn->pipe_version;\n\t} else\n\t\tret = -EAGAIN;\n\tspin_unlock(&pipe_version_lock);\n\treturn ret;\n}\n\nstatic void put_pipe_version(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tif (atomic_dec_and_lock(&sn->pipe_users, &pipe_version_lock)) {\n\t\tsn->pipe_version = -1;\n\t\tspin_unlock(&pipe_version_lock);\n\t}\n}\n\nstatic void\ngss_release_msg(struct gss_upcall_msg *gss_msg)\n{\n\tstruct net *net = gss_msg->auth->net;\n\tif (!refcount_dec_and_test(&gss_msg->count))\n\t\treturn;\n\tput_pipe_version(net);\n\tBUG_ON(!list_empty(&gss_msg->list));\n\tif (gss_msg->ctx != NULL)\n\t\tgss_put_ctx(gss_msg->ctx);\n\trpc_destroy_wait_queue(&gss_msg->rpc_waitqueue);\n\tgss_put_auth(gss_msg->auth);\n\tkfree_const(gss_msg->service_name);\n\tkfree(gss_msg);\n}\n\nstatic struct gss_upcall_msg *\n__gss_find_upcall(struct rpc_pipe *pipe, kuid_t uid, const struct gss_auth *auth)\n{\n\tstruct gss_upcall_msg *pos;\n\tlist_for_each_entry(pos, &pipe->in_downcall, list) {\n\t\tif (!uid_eq(pos->uid, uid))\n\t\t\tcontinue;\n\t\tif (pos->auth->service != auth->service)\n\t\t\tcontinue;\n\t\trefcount_inc(&pos->count);\n\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\n \nstatic inline struct gss_upcall_msg *\ngss_add_msg(struct gss_upcall_msg *gss_msg)\n{\n\tstruct rpc_pipe *pipe = gss_msg->pipe;\n\tstruct gss_upcall_msg *old;\n\n\tspin_lock(&pipe->lock);\n\told = __gss_find_upcall(pipe, gss_msg->uid, gss_msg->auth);\n\tif (old == NULL) {\n\t\trefcount_inc(&gss_msg->count);\n\t\tlist_add(&gss_msg->list, &pipe->in_downcall);\n\t} else\n\t\tgss_msg = old;\n\tspin_unlock(&pipe->lock);\n\treturn gss_msg;\n}\n\nstatic void\n__gss_unhash_msg(struct gss_upcall_msg *gss_msg)\n{\n\tlist_del_init(&gss_msg->list);\n\trpc_wake_up_status(&gss_msg->rpc_waitqueue, gss_msg->msg.errno);\n\twake_up_all(&gss_msg->waitqueue);\n\trefcount_dec(&gss_msg->count);\n}\n\nstatic void\ngss_unhash_msg(struct gss_upcall_msg *gss_msg)\n{\n\tstruct rpc_pipe *pipe = gss_msg->pipe;\n\n\tif (list_empty(&gss_msg->list))\n\t\treturn;\n\tspin_lock(&pipe->lock);\n\tif (!list_empty(&gss_msg->list))\n\t\t__gss_unhash_msg(gss_msg);\n\tspin_unlock(&pipe->lock);\n}\n\nstatic void\ngss_handle_downcall_result(struct gss_cred *gss_cred, struct gss_upcall_msg *gss_msg)\n{\n\tswitch (gss_msg->msg.errno) {\n\tcase 0:\n\t\tif (gss_msg->ctx == NULL)\n\t\t\tbreak;\n\t\tclear_bit(RPCAUTH_CRED_NEGATIVE, &gss_cred->gc_base.cr_flags);\n\t\tgss_cred_set_ctx(&gss_cred->gc_base, gss_msg->ctx);\n\t\tbreak;\n\tcase -EKEYEXPIRED:\n\t\tset_bit(RPCAUTH_CRED_NEGATIVE, &gss_cred->gc_base.cr_flags);\n\t}\n\tgss_cred->gc_upcall_timestamp = jiffies;\n\tgss_cred->gc_upcall = NULL;\n\trpc_wake_up_status(&gss_msg->rpc_waitqueue, gss_msg->msg.errno);\n}\n\nstatic void\ngss_upcall_callback(struct rpc_task *task)\n{\n\tstruct gss_cred *gss_cred = container_of(task->tk_rqstp->rq_cred,\n\t\t\tstruct gss_cred, gc_base);\n\tstruct gss_upcall_msg *gss_msg = gss_cred->gc_upcall;\n\tstruct rpc_pipe *pipe = gss_msg->pipe;\n\n\tspin_lock(&pipe->lock);\n\tgss_handle_downcall_result(gss_cred, gss_msg);\n\tspin_unlock(&pipe->lock);\n\ttask->tk_status = gss_msg->msg.errno;\n\tgss_release_msg(gss_msg);\n}\n\nstatic void gss_encode_v0_msg(struct gss_upcall_msg *gss_msg,\n\t\t\t      const struct cred *cred)\n{\n\tstruct user_namespace *userns = cred->user_ns;\n\n\tuid_t uid = from_kuid_munged(userns, gss_msg->uid);\n\tmemcpy(gss_msg->databuf, &uid, sizeof(uid));\n\tgss_msg->msg.data = gss_msg->databuf;\n\tgss_msg->msg.len = sizeof(uid);\n\n\tBUILD_BUG_ON(sizeof(uid) > sizeof(gss_msg->databuf));\n}\n\nstatic ssize_t\ngss_v0_upcall(struct file *file, struct rpc_pipe_msg *msg,\n\t\tchar __user *buf, size_t buflen)\n{\n\tstruct gss_upcall_msg *gss_msg = container_of(msg,\n\t\t\t\t\t\t      struct gss_upcall_msg,\n\t\t\t\t\t\t      msg);\n\tif (msg->copied == 0)\n\t\tgss_encode_v0_msg(gss_msg, file->f_cred);\n\treturn rpc_pipe_generic_upcall(file, msg, buf, buflen);\n}\n\nstatic int gss_encode_v1_msg(struct gss_upcall_msg *gss_msg,\n\t\t\t\tconst char *service_name,\n\t\t\t\tconst char *target_name,\n\t\t\t\tconst struct cred *cred)\n{\n\tstruct user_namespace *userns = cred->user_ns;\n\tstruct gss_api_mech *mech = gss_msg->auth->mech;\n\tchar *p = gss_msg->databuf;\n\tsize_t buflen = sizeof(gss_msg->databuf);\n\tint len;\n\n\tlen = scnprintf(p, buflen, \"mech=%s uid=%d\", mech->gm_name,\n\t\t\tfrom_kuid_munged(userns, gss_msg->uid));\n\tbuflen -= len;\n\tp += len;\n\tgss_msg->msg.len = len;\n\n\t \n\tif (target_name) {\n\t\tlen = scnprintf(p, buflen, \" target=%s\", target_name);\n\t\tbuflen -= len;\n\t\tp += len;\n\t\tgss_msg->msg.len += len;\n\t}\n\n\t \n\tif (service_name) {\n\t\tchar *c = strchr(service_name, '@');\n\n\t\tif (!c)\n\t\t\tlen = scnprintf(p, buflen, \" service=%s\",\n\t\t\t\t\tservice_name);\n\t\telse\n\t\t\tlen = scnprintf(p, buflen,\n\t\t\t\t\t\" service=%.*s srchost=%s\",\n\t\t\t\t\t(int)(c - service_name),\n\t\t\t\t\tservice_name, c + 1);\n\t\tbuflen -= len;\n\t\tp += len;\n\t\tgss_msg->msg.len += len;\n\t}\n\n\tif (mech->gm_upcall_enctypes) {\n\t\tlen = scnprintf(p, buflen, \" enctypes=%s\",\n\t\t\t\tmech->gm_upcall_enctypes);\n\t\tbuflen -= len;\n\t\tp += len;\n\t\tgss_msg->msg.len += len;\n\t}\n\ttrace_rpcgss_upcall_msg(gss_msg->databuf);\n\tlen = scnprintf(p, buflen, \"\\n\");\n\tif (len == 0)\n\t\tgoto out_overflow;\n\tgss_msg->msg.len += len;\n\tgss_msg->msg.data = gss_msg->databuf;\n\treturn 0;\nout_overflow:\n\tWARN_ON_ONCE(1);\n\treturn -ENOMEM;\n}\n\nstatic ssize_t\ngss_v1_upcall(struct file *file, struct rpc_pipe_msg *msg,\n\t\tchar __user *buf, size_t buflen)\n{\n\tstruct gss_upcall_msg *gss_msg = container_of(msg,\n\t\t\t\t\t\t      struct gss_upcall_msg,\n\t\t\t\t\t\t      msg);\n\tint err;\n\tif (msg->copied == 0) {\n\t\terr = gss_encode_v1_msg(gss_msg,\n\t\t\t\t\tgss_msg->service_name,\n\t\t\t\t\tgss_msg->auth->target_name,\n\t\t\t\t\tfile->f_cred);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn rpc_pipe_generic_upcall(file, msg, buf, buflen);\n}\n\nstatic struct gss_upcall_msg *\ngss_alloc_msg(struct gss_auth *gss_auth,\n\t\tkuid_t uid, const char *service_name)\n{\n\tstruct gss_upcall_msg *gss_msg;\n\tint vers;\n\tint err = -ENOMEM;\n\n\tgss_msg = kzalloc(sizeof(*gss_msg), GFP_KERNEL);\n\tif (gss_msg == NULL)\n\t\tgoto err;\n\tvers = get_pipe_version(gss_auth->net);\n\terr = vers;\n\tif (err < 0)\n\t\tgoto err_free_msg;\n\tgss_msg->pipe = gss_auth->gss_pipe[vers]->pipe;\n\tINIT_LIST_HEAD(&gss_msg->list);\n\trpc_init_wait_queue(&gss_msg->rpc_waitqueue, \"RPCSEC_GSS upcall waitq\");\n\tinit_waitqueue_head(&gss_msg->waitqueue);\n\trefcount_set(&gss_msg->count, 1);\n\tgss_msg->uid = uid;\n\tgss_msg->auth = gss_auth;\n\tkref_get(&gss_auth->kref);\n\tif (service_name) {\n\t\tgss_msg->service_name = kstrdup_const(service_name, GFP_KERNEL);\n\t\tif (!gss_msg->service_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_put_pipe_version;\n\t\t}\n\t}\n\treturn gss_msg;\nerr_put_pipe_version:\n\tput_pipe_version(gss_auth->net);\nerr_free_msg:\n\tkfree(gss_msg);\nerr:\n\treturn ERR_PTR(err);\n}\n\nstatic struct gss_upcall_msg *\ngss_setup_upcall(struct gss_auth *gss_auth, struct rpc_cred *cred)\n{\n\tstruct gss_cred *gss_cred = container_of(cred,\n\t\t\tstruct gss_cred, gc_base);\n\tstruct gss_upcall_msg *gss_new, *gss_msg;\n\tkuid_t uid = cred->cr_cred->fsuid;\n\n\tgss_new = gss_alloc_msg(gss_auth, uid, gss_cred->gc_principal);\n\tif (IS_ERR(gss_new))\n\t\treturn gss_new;\n\tgss_msg = gss_add_msg(gss_new);\n\tif (gss_msg == gss_new) {\n\t\tint res;\n\t\trefcount_inc(&gss_msg->count);\n\t\tres = rpc_queue_upcall(gss_new->pipe, &gss_new->msg);\n\t\tif (res) {\n\t\t\tgss_unhash_msg(gss_new);\n\t\t\trefcount_dec(&gss_msg->count);\n\t\t\tgss_release_msg(gss_new);\n\t\t\tgss_msg = ERR_PTR(res);\n\t\t}\n\t} else\n\t\tgss_release_msg(gss_new);\n\treturn gss_msg;\n}\n\nstatic void warn_gssd(void)\n{\n\tdprintk(\"AUTH_GSS upcall failed. Please check user daemon is running.\\n\");\n}\n\nstatic inline int\ngss_refresh_upcall(struct rpc_task *task)\n{\n\tstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\n\tstruct gss_auth *gss_auth = container_of(cred->cr_auth,\n\t\t\tstruct gss_auth, rpc_auth);\n\tstruct gss_cred *gss_cred = container_of(cred,\n\t\t\tstruct gss_cred, gc_base);\n\tstruct gss_upcall_msg *gss_msg;\n\tstruct rpc_pipe *pipe;\n\tint err = 0;\n\n\tgss_msg = gss_setup_upcall(gss_auth, cred);\n\tif (PTR_ERR(gss_msg) == -EAGAIN) {\n\t\t \n\t\twarn_gssd();\n\t\trpc_sleep_on_timeout(&pipe_version_rpc_waitqueue,\n\t\t\t\ttask, NULL, jiffies + (15 * HZ));\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\tif (IS_ERR(gss_msg)) {\n\t\terr = PTR_ERR(gss_msg);\n\t\tgoto out;\n\t}\n\tpipe = gss_msg->pipe;\n\tspin_lock(&pipe->lock);\n\tif (gss_cred->gc_upcall != NULL)\n\t\trpc_sleep_on(&gss_cred->gc_upcall->rpc_waitqueue, task, NULL);\n\telse if (gss_msg->ctx == NULL && gss_msg->msg.errno >= 0) {\n\t\tgss_cred->gc_upcall = gss_msg;\n\t\t \n\t\trefcount_inc(&gss_msg->count);\n\t\trpc_sleep_on(&gss_msg->rpc_waitqueue, task, gss_upcall_callback);\n\t} else {\n\t\tgss_handle_downcall_result(gss_cred, gss_msg);\n\t\terr = gss_msg->msg.errno;\n\t}\n\tspin_unlock(&pipe->lock);\n\tgss_release_msg(gss_msg);\nout:\n\ttrace_rpcgss_upcall_result(from_kuid(&init_user_ns,\n\t\t\t\t\t     cred->cr_cred->fsuid), err);\n\treturn err;\n}\n\nstatic inline int\ngss_create_upcall(struct gss_auth *gss_auth, struct gss_cred *gss_cred)\n{\n\tstruct net *net = gss_auth->net;\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct rpc_pipe *pipe;\n\tstruct rpc_cred *cred = &gss_cred->gc_base;\n\tstruct gss_upcall_msg *gss_msg;\n\tDEFINE_WAIT(wait);\n\tint err;\n\nretry:\n\terr = 0;\n\t \n\tif (!gssd_running(net)) {\n\t\twarn_gssd();\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\tgss_msg = gss_setup_upcall(gss_auth, cred);\n\tif (PTR_ERR(gss_msg) == -EAGAIN) {\n\t\terr = wait_event_interruptible_timeout(pipe_version_waitqueue,\n\t\t\t\tsn->pipe_version >= 0, 15 * HZ);\n\t\tif (sn->pipe_version < 0) {\n\t\t\twarn_gssd();\n\t\t\terr = -EACCES;\n\t\t}\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tgoto retry;\n\t}\n\tif (IS_ERR(gss_msg)) {\n\t\terr = PTR_ERR(gss_msg);\n\t\tgoto out;\n\t}\n\tpipe = gss_msg->pipe;\n\tfor (;;) {\n\t\tprepare_to_wait(&gss_msg->waitqueue, &wait, TASK_KILLABLE);\n\t\tspin_lock(&pipe->lock);\n\t\tif (gss_msg->ctx != NULL || gss_msg->msg.errno < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&pipe->lock);\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto out_intr;\n\t\t}\n\t\tschedule();\n\t}\n\tif (gss_msg->ctx) {\n\t\ttrace_rpcgss_ctx_init(gss_cred);\n\t\tgss_cred_set_ctx(cred, gss_msg->ctx);\n\t} else {\n\t\terr = gss_msg->msg.errno;\n\t}\n\tspin_unlock(&pipe->lock);\nout_intr:\n\tfinish_wait(&gss_msg->waitqueue, &wait);\n\tgss_release_msg(gss_msg);\nout:\n\ttrace_rpcgss_upcall_result(from_kuid(&init_user_ns,\n\t\t\t\t\t     cred->cr_cred->fsuid), err);\n\treturn err;\n}\n\nstatic struct gss_upcall_msg *\ngss_find_downcall(struct rpc_pipe *pipe, kuid_t uid)\n{\n\tstruct gss_upcall_msg *pos;\n\tlist_for_each_entry(pos, &pipe->in_downcall, list) {\n\t\tif (!uid_eq(pos->uid, uid))\n\t\t\tcontinue;\n\t\tif (!rpc_msg_is_inflight(&pos->msg))\n\t\t\tcontinue;\n\t\trefcount_inc(&pos->count);\n\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\n#define MSG_BUF_MAXSIZE 1024\n\nstatic ssize_t\ngss_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\n{\n\tconst void *p, *end;\n\tvoid *buf;\n\tstruct gss_upcall_msg *gss_msg;\n\tstruct rpc_pipe *pipe = RPC_I(file_inode(filp))->pipe;\n\tstruct gss_cl_ctx *ctx;\n\tuid_t id;\n\tkuid_t uid;\n\tssize_t err = -EFBIG;\n\n\tif (mlen > MSG_BUF_MAXSIZE)\n\t\tgoto out;\n\terr = -ENOMEM;\n\tbuf = kmalloc(mlen, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\terr = -EFAULT;\n\tif (copy_from_user(buf, src, mlen))\n\t\tgoto err;\n\n\tend = (const void *)((char *)buf + mlen);\n\tp = simple_get_bytes(buf, end, &id, sizeof(id));\n\tif (IS_ERR(p)) {\n\t\terr = PTR_ERR(p);\n\t\tgoto err;\n\t}\n\n\tuid = make_kuid(current_user_ns(), id);\n\tif (!uid_valid(uid)) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = -ENOMEM;\n\tctx = gss_alloc_context();\n\tif (ctx == NULL)\n\t\tgoto err;\n\n\terr = -ENOENT;\n\t \n\tspin_lock(&pipe->lock);\n\tgss_msg = gss_find_downcall(pipe, uid);\n\tif (gss_msg == NULL) {\n\t\tspin_unlock(&pipe->lock);\n\t\tgoto err_put_ctx;\n\t}\n\tlist_del_init(&gss_msg->list);\n\tspin_unlock(&pipe->lock);\n\n\tp = gss_fill_context(p, end, ctx, gss_msg->auth->mech);\n\tif (IS_ERR(p)) {\n\t\terr = PTR_ERR(p);\n\t\tswitch (err) {\n\t\tcase -EACCES:\n\t\tcase -EKEYEXPIRED:\n\t\t\tgss_msg->msg.errno = err;\n\t\t\terr = mlen;\n\t\t\tbreak;\n\t\tcase -EFAULT:\n\t\tcase -ENOMEM:\n\t\tcase -EINVAL:\n\t\tcase -ENOSYS:\n\t\t\tgss_msg->msg.errno = -EAGAIN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_CRIT \"%s: bad return from \"\n\t\t\t\t\"gss_fill_context: %zd\\n\", __func__, err);\n\t\t\tgss_msg->msg.errno = -EIO;\n\t\t}\n\t\tgoto err_release_msg;\n\t}\n\tgss_msg->ctx = gss_get_ctx(ctx);\n\terr = mlen;\n\nerr_release_msg:\n\tspin_lock(&pipe->lock);\n\t__gss_unhash_msg(gss_msg);\n\tspin_unlock(&pipe->lock);\n\tgss_release_msg(gss_msg);\nerr_put_ctx:\n\tgss_put_ctx(ctx);\nerr:\n\tkfree(buf);\nout:\n\treturn err;\n}\n\nstatic int gss_pipe_open(struct inode *inode, int new_version)\n{\n\tstruct net *net = inode->i_sb->s_fs_info;\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tint ret = 0;\n\n\tspin_lock(&pipe_version_lock);\n\tif (sn->pipe_version < 0) {\n\t\t \n\t\tsn->pipe_version = new_version;\n\t\trpc_wake_up(&pipe_version_rpc_waitqueue);\n\t\twake_up(&pipe_version_waitqueue);\n\t} else if (sn->pipe_version != new_version) {\n\t\t \n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\tatomic_inc(&sn->pipe_users);\nout:\n\tspin_unlock(&pipe_version_lock);\n\treturn ret;\n\n}\n\nstatic int gss_pipe_open_v0(struct inode *inode)\n{\n\treturn gss_pipe_open(inode, 0);\n}\n\nstatic int gss_pipe_open_v1(struct inode *inode)\n{\n\treturn gss_pipe_open(inode, 1);\n}\n\nstatic void\ngss_pipe_release(struct inode *inode)\n{\n\tstruct net *net = inode->i_sb->s_fs_info;\n\tstruct rpc_pipe *pipe = RPC_I(inode)->pipe;\n\tstruct gss_upcall_msg *gss_msg;\n\nrestart:\n\tspin_lock(&pipe->lock);\n\tlist_for_each_entry(gss_msg, &pipe->in_downcall, list) {\n\n\t\tif (!list_empty(&gss_msg->msg.list))\n\t\t\tcontinue;\n\t\tgss_msg->msg.errno = -EPIPE;\n\t\trefcount_inc(&gss_msg->count);\n\t\t__gss_unhash_msg(gss_msg);\n\t\tspin_unlock(&pipe->lock);\n\t\tgss_release_msg(gss_msg);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&pipe->lock);\n\n\tput_pipe_version(net);\n}\n\nstatic void\ngss_pipe_destroy_msg(struct rpc_pipe_msg *msg)\n{\n\tstruct gss_upcall_msg *gss_msg = container_of(msg, struct gss_upcall_msg, msg);\n\n\tif (msg->errno < 0) {\n\t\trefcount_inc(&gss_msg->count);\n\t\tgss_unhash_msg(gss_msg);\n\t\tif (msg->errno == -ETIMEDOUT)\n\t\t\twarn_gssd();\n\t\tgss_release_msg(gss_msg);\n\t}\n\tgss_release_msg(gss_msg);\n}\n\nstatic void gss_pipe_dentry_destroy(struct dentry *dir,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tstruct gss_pipe *gss_pipe = pdo->pdo_data;\n\tstruct rpc_pipe *pipe = gss_pipe->pipe;\n\n\tif (pipe->dentry != NULL) {\n\t\trpc_unlink(pipe->dentry);\n\t\tpipe->dentry = NULL;\n\t}\n}\n\nstatic int gss_pipe_dentry_create(struct dentry *dir,\n\t\tstruct rpc_pipe_dir_object *pdo)\n{\n\tstruct gss_pipe *p = pdo->pdo_data;\n\tstruct dentry *dentry;\n\n\tdentry = rpc_mkpipe_dentry(dir, p->name, p->clnt, p->pipe);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tp->pipe->dentry = dentry;\n\treturn 0;\n}\n\nstatic const struct rpc_pipe_dir_object_ops gss_pipe_dir_object_ops = {\n\t.create = gss_pipe_dentry_create,\n\t.destroy = gss_pipe_dentry_destroy,\n};\n\nstatic struct gss_pipe *gss_pipe_alloc(struct rpc_clnt *clnt,\n\t\tconst char *name,\n\t\tconst struct rpc_pipe_ops *upcall_ops)\n{\n\tstruct gss_pipe *p;\n\tint err = -ENOMEM;\n\n\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\tgoto err;\n\tp->pipe = rpc_mkpipe_data(upcall_ops, RPC_PIPE_WAIT_FOR_OPEN);\n\tif (IS_ERR(p->pipe)) {\n\t\terr = PTR_ERR(p->pipe);\n\t\tgoto err_free_gss_pipe;\n\t}\n\tp->name = name;\n\tp->clnt = clnt;\n\tkref_init(&p->kref);\n\trpc_init_pipe_dir_object(&p->pdo,\n\t\t\t&gss_pipe_dir_object_ops,\n\t\t\tp);\n\treturn p;\nerr_free_gss_pipe:\n\tkfree(p);\nerr:\n\treturn ERR_PTR(err);\n}\n\nstruct gss_alloc_pdo {\n\tstruct rpc_clnt *clnt;\n\tconst char *name;\n\tconst struct rpc_pipe_ops *upcall_ops;\n};\n\nstatic int gss_pipe_match_pdo(struct rpc_pipe_dir_object *pdo, void *data)\n{\n\tstruct gss_pipe *gss_pipe;\n\tstruct gss_alloc_pdo *args = data;\n\n\tif (pdo->pdo_ops != &gss_pipe_dir_object_ops)\n\t\treturn 0;\n\tgss_pipe = container_of(pdo, struct gss_pipe, pdo);\n\tif (strcmp(gss_pipe->name, args->name) != 0)\n\t\treturn 0;\n\tif (!kref_get_unless_zero(&gss_pipe->kref))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic struct rpc_pipe_dir_object *gss_pipe_alloc_pdo(void *data)\n{\n\tstruct gss_pipe *gss_pipe;\n\tstruct gss_alloc_pdo *args = data;\n\n\tgss_pipe = gss_pipe_alloc(args->clnt, args->name, args->upcall_ops);\n\tif (!IS_ERR(gss_pipe))\n\t\treturn &gss_pipe->pdo;\n\treturn NULL;\n}\n\nstatic struct gss_pipe *gss_pipe_get(struct rpc_clnt *clnt,\n\t\tconst char *name,\n\t\tconst struct rpc_pipe_ops *upcall_ops)\n{\n\tstruct net *net = rpc_net_ns(clnt);\n\tstruct rpc_pipe_dir_object *pdo;\n\tstruct gss_alloc_pdo args = {\n\t\t.clnt = clnt,\n\t\t.name = name,\n\t\t.upcall_ops = upcall_ops,\n\t};\n\n\tpdo = rpc_find_or_alloc_pipe_dir_object(net,\n\t\t\t&clnt->cl_pipedir_objects,\n\t\t\tgss_pipe_match_pdo,\n\t\t\tgss_pipe_alloc_pdo,\n\t\t\t&args);\n\tif (pdo != NULL)\n\t\treturn container_of(pdo, struct gss_pipe, pdo);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic void __gss_pipe_free(struct gss_pipe *p)\n{\n\tstruct rpc_clnt *clnt = p->clnt;\n\tstruct net *net = rpc_net_ns(clnt);\n\n\trpc_remove_pipe_dir_object(net,\n\t\t\t&clnt->cl_pipedir_objects,\n\t\t\t&p->pdo);\n\trpc_destroy_pipe_data(p->pipe);\n\tkfree(p);\n}\n\nstatic void __gss_pipe_release(struct kref *kref)\n{\n\tstruct gss_pipe *p = container_of(kref, struct gss_pipe, kref);\n\n\t__gss_pipe_free(p);\n}\n\nstatic void gss_pipe_free(struct gss_pipe *p)\n{\n\tif (p != NULL)\n\t\tkref_put(&p->kref, __gss_pipe_release);\n}\n\n \nstatic struct gss_auth *\ngss_create_new(const struct rpc_auth_create_args *args, struct rpc_clnt *clnt)\n{\n\trpc_authflavor_t flavor = args->pseudoflavor;\n\tstruct gss_auth *gss_auth;\n\tstruct gss_pipe *gss_pipe;\n\tstruct rpc_auth * auth;\n\tint err = -ENOMEM;  \n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn ERR_PTR(err);\n\tif (!(gss_auth = kmalloc(sizeof(*gss_auth), GFP_KERNEL)))\n\t\tgoto out_dec;\n\tINIT_HLIST_NODE(&gss_auth->hash);\n\tgss_auth->target_name = NULL;\n\tif (args->target_name) {\n\t\tgss_auth->target_name = kstrdup(args->target_name, GFP_KERNEL);\n\t\tif (gss_auth->target_name == NULL)\n\t\t\tgoto err_free;\n\t}\n\tgss_auth->client = clnt;\n\tgss_auth->net = get_net_track(rpc_net_ns(clnt), &gss_auth->ns_tracker,\n\t\t\t\t      GFP_KERNEL);\n\terr = -EINVAL;\n\tgss_auth->mech = gss_mech_get_by_pseudoflavor(flavor);\n\tif (!gss_auth->mech)\n\t\tgoto err_put_net;\n\tgss_auth->service = gss_pseudoflavor_to_service(gss_auth->mech, flavor);\n\tif (gss_auth->service == 0)\n\t\tgoto err_put_mech;\n\tif (!gssd_running(gss_auth->net))\n\t\tgoto err_put_mech;\n\tauth = &gss_auth->rpc_auth;\n\tauth->au_cslack = GSS_CRED_SLACK >> 2;\n\tBUILD_BUG_ON(GSS_KRB5_MAX_SLACK_NEEDED > RPC_MAX_AUTH_SIZE);\n\tauth->au_rslack = GSS_KRB5_MAX_SLACK_NEEDED >> 2;\n\tauth->au_verfsize = GSS_VERF_SLACK >> 2;\n\tauth->au_ralign = GSS_VERF_SLACK >> 2;\n\t__set_bit(RPCAUTH_AUTH_UPDATE_SLACK, &auth->au_flags);\n\tauth->au_ops = &authgss_ops;\n\tauth->au_flavor = flavor;\n\tif (gss_pseudoflavor_to_datatouch(gss_auth->mech, flavor))\n\t\t__set_bit(RPCAUTH_AUTH_DATATOUCH, &auth->au_flags);\n\trefcount_set(&auth->au_count, 1);\n\tkref_init(&gss_auth->kref);\n\n\terr = rpcauth_init_credcache(auth);\n\tif (err)\n\t\tgoto err_put_mech;\n\t \n\tgss_pipe = gss_pipe_get(clnt, \"gssd\", &gss_upcall_ops_v1);\n\tif (IS_ERR(gss_pipe)) {\n\t\terr = PTR_ERR(gss_pipe);\n\t\tgoto err_destroy_credcache;\n\t}\n\tgss_auth->gss_pipe[1] = gss_pipe;\n\n\tgss_pipe = gss_pipe_get(clnt, gss_auth->mech->gm_name,\n\t\t\t&gss_upcall_ops_v0);\n\tif (IS_ERR(gss_pipe)) {\n\t\terr = PTR_ERR(gss_pipe);\n\t\tgoto err_destroy_pipe_1;\n\t}\n\tgss_auth->gss_pipe[0] = gss_pipe;\n\n\treturn gss_auth;\nerr_destroy_pipe_1:\n\tgss_pipe_free(gss_auth->gss_pipe[1]);\nerr_destroy_credcache:\n\trpcauth_destroy_credcache(auth);\nerr_put_mech:\n\tgss_mech_put(gss_auth->mech);\nerr_put_net:\n\tput_net_track(gss_auth->net, &gss_auth->ns_tracker);\nerr_free:\n\tkfree(gss_auth->target_name);\n\tkfree(gss_auth);\nout_dec:\n\tmodule_put(THIS_MODULE);\n\ttrace_rpcgss_createauth(flavor, err);\n\treturn ERR_PTR(err);\n}\n\nstatic void\ngss_free(struct gss_auth *gss_auth)\n{\n\tgss_pipe_free(gss_auth->gss_pipe[0]);\n\tgss_pipe_free(gss_auth->gss_pipe[1]);\n\tgss_mech_put(gss_auth->mech);\n\tput_net_track(gss_auth->net, &gss_auth->ns_tracker);\n\tkfree(gss_auth->target_name);\n\n\tkfree(gss_auth);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic void\ngss_free_callback(struct kref *kref)\n{\n\tstruct gss_auth *gss_auth = container_of(kref, struct gss_auth, kref);\n\n\tgss_free(gss_auth);\n}\n\nstatic void\ngss_put_auth(struct gss_auth *gss_auth)\n{\n\tkref_put(&gss_auth->kref, gss_free_callback);\n}\n\nstatic void\ngss_destroy(struct rpc_auth *auth)\n{\n\tstruct gss_auth *gss_auth = container_of(auth,\n\t\t\tstruct gss_auth, rpc_auth);\n\n\tif (hash_hashed(&gss_auth->hash)) {\n\t\tspin_lock(&gss_auth_hash_lock);\n\t\thash_del(&gss_auth->hash);\n\t\tspin_unlock(&gss_auth_hash_lock);\n\t}\n\n\tgss_pipe_free(gss_auth->gss_pipe[0]);\n\tgss_auth->gss_pipe[0] = NULL;\n\tgss_pipe_free(gss_auth->gss_pipe[1]);\n\tgss_auth->gss_pipe[1] = NULL;\n\trpcauth_destroy_credcache(auth);\n\n\tgss_put_auth(gss_auth);\n}\n\n \nstatic struct gss_auth *\ngss_auth_find_or_add_hashed(const struct rpc_auth_create_args *args,\n\t\tstruct rpc_clnt *clnt,\n\t\tstruct gss_auth *new)\n{\n\tstruct gss_auth *gss_auth;\n\tunsigned long hashval = (unsigned long)clnt;\n\n\tspin_lock(&gss_auth_hash_lock);\n\thash_for_each_possible(gss_auth_hash_table,\n\t\t\tgss_auth,\n\t\t\thash,\n\t\t\thashval) {\n\t\tif (gss_auth->client != clnt)\n\t\t\tcontinue;\n\t\tif (gss_auth->rpc_auth.au_flavor != args->pseudoflavor)\n\t\t\tcontinue;\n\t\tif (gss_auth->target_name != args->target_name) {\n\t\t\tif (gss_auth->target_name == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (args->target_name == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(gss_auth->target_name, args->target_name))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (!refcount_inc_not_zero(&gss_auth->rpc_auth.au_count))\n\t\t\tcontinue;\n\t\tgoto out;\n\t}\n\tif (new)\n\t\thash_add(gss_auth_hash_table, &new->hash, hashval);\n\tgss_auth = new;\nout:\n\tspin_unlock(&gss_auth_hash_lock);\n\treturn gss_auth;\n}\n\nstatic struct gss_auth *\ngss_create_hashed(const struct rpc_auth_create_args *args,\n\t\t  struct rpc_clnt *clnt)\n{\n\tstruct gss_auth *gss_auth;\n\tstruct gss_auth *new;\n\n\tgss_auth = gss_auth_find_or_add_hashed(args, clnt, NULL);\n\tif (gss_auth != NULL)\n\t\tgoto out;\n\tnew = gss_create_new(args, clnt);\n\tif (IS_ERR(new))\n\t\treturn new;\n\tgss_auth = gss_auth_find_or_add_hashed(args, clnt, new);\n\tif (gss_auth != new)\n\t\tgss_destroy(&new->rpc_auth);\nout:\n\treturn gss_auth;\n}\n\nstatic struct rpc_auth *\ngss_create(const struct rpc_auth_create_args *args, struct rpc_clnt *clnt)\n{\n\tstruct gss_auth *gss_auth;\n\tstruct rpc_xprt_switch *xps = rcu_access_pointer(clnt->cl_xpi.xpi_xpswitch);\n\n\twhile (clnt != clnt->cl_parent) {\n\t\tstruct rpc_clnt *parent = clnt->cl_parent;\n\t\t \n\t\tif (rcu_access_pointer(parent->cl_xpi.xpi_xpswitch) != xps)\n\t\t\tbreak;\n\t\tclnt = parent;\n\t}\n\n\tgss_auth = gss_create_hashed(args, clnt);\n\tif (IS_ERR(gss_auth))\n\t\treturn ERR_CAST(gss_auth);\n\treturn &gss_auth->rpc_auth;\n}\n\nstatic struct gss_cred *\ngss_dup_cred(struct gss_auth *gss_auth, struct gss_cred *gss_cred)\n{\n\tstruct gss_cred *new;\n\n\t \n\tnew = kzalloc(sizeof(*gss_cred), GFP_KERNEL);\n\tif (new) {\n\t\tstruct auth_cred acred = {\n\t\t\t.cred = gss_cred->gc_base.cr_cred,\n\t\t};\n\t\tstruct gss_cl_ctx *ctx =\n\t\t\trcu_dereference_protected(gss_cred->gc_ctx, 1);\n\n\t\trpcauth_init_cred(&new->gc_base, &acred,\n\t\t\t\t&gss_auth->rpc_auth,\n\t\t\t\t&gss_nullops);\n\t\tnew->gc_base.cr_flags = 1UL << RPCAUTH_CRED_UPTODATE;\n\t\tnew->gc_service = gss_cred->gc_service;\n\t\tnew->gc_principal = gss_cred->gc_principal;\n\t\tkref_get(&gss_auth->kref);\n\t\trcu_assign_pointer(new->gc_ctx, ctx);\n\t\tgss_get_ctx(ctx);\n\t}\n\treturn new;\n}\n\n \nstatic void\ngss_send_destroy_context(struct rpc_cred *cred)\n{\n\tstruct gss_cred *gss_cred = container_of(cred, struct gss_cred, gc_base);\n\tstruct gss_auth *gss_auth = container_of(cred->cr_auth, struct gss_auth, rpc_auth);\n\tstruct gss_cl_ctx *ctx = rcu_dereference_protected(gss_cred->gc_ctx, 1);\n\tstruct gss_cred *new;\n\tstruct rpc_task *task;\n\n\tnew = gss_dup_cred(gss_auth, gss_cred);\n\tif (new) {\n\t\tctx->gc_proc = RPC_GSS_PROC_DESTROY;\n\n\t\ttrace_rpcgss_ctx_destroy(gss_cred);\n\t\ttask = rpc_call_null(gss_auth->client, &new->gc_base,\n\t\t\t\t     RPC_TASK_ASYNC);\n\t\tif (!IS_ERR(task))\n\t\t\trpc_put_task(task);\n\n\t\tput_rpccred(&new->gc_base);\n\t}\n}\n\n \nstatic void\ngss_do_free_ctx(struct gss_cl_ctx *ctx)\n{\n\tgss_delete_sec_context(&ctx->gc_gss_ctx);\n\tkfree(ctx->gc_wire_ctx.data);\n\tkfree(ctx->gc_acceptor.data);\n\tkfree(ctx);\n}\n\nstatic void\ngss_free_ctx_callback(struct rcu_head *head)\n{\n\tstruct gss_cl_ctx *ctx = container_of(head, struct gss_cl_ctx, gc_rcu);\n\tgss_do_free_ctx(ctx);\n}\n\nstatic void\ngss_free_ctx(struct gss_cl_ctx *ctx)\n{\n\tcall_rcu(&ctx->gc_rcu, gss_free_ctx_callback);\n}\n\nstatic void\ngss_free_cred(struct gss_cred *gss_cred)\n{\n\tkfree(gss_cred);\n}\n\nstatic void\ngss_free_cred_callback(struct rcu_head *head)\n{\n\tstruct gss_cred *gss_cred = container_of(head, struct gss_cred, gc_base.cr_rcu);\n\tgss_free_cred(gss_cred);\n}\n\nstatic void\ngss_destroy_nullcred(struct rpc_cred *cred)\n{\n\tstruct gss_cred *gss_cred = container_of(cred, struct gss_cred, gc_base);\n\tstruct gss_auth *gss_auth = container_of(cred->cr_auth, struct gss_auth, rpc_auth);\n\tstruct gss_cl_ctx *ctx = rcu_dereference_protected(gss_cred->gc_ctx, 1);\n\n\tRCU_INIT_POINTER(gss_cred->gc_ctx, NULL);\n\tput_cred(cred->cr_cred);\n\tcall_rcu(&cred->cr_rcu, gss_free_cred_callback);\n\tif (ctx)\n\t\tgss_put_ctx(ctx);\n\tgss_put_auth(gss_auth);\n}\n\nstatic void\ngss_destroy_cred(struct rpc_cred *cred)\n{\n\tif (test_and_clear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags) != 0)\n\t\tgss_send_destroy_context(cred);\n\tgss_destroy_nullcred(cred);\n}\n\nstatic int\ngss_hash_cred(struct auth_cred *acred, unsigned int hashbits)\n{\n\treturn hash_64(from_kuid(&init_user_ns, acred->cred->fsuid), hashbits);\n}\n\n \nstatic struct rpc_cred *gss_lookup_cred(struct rpc_auth *auth,\n\t\t\t\t\tstruct auth_cred *acred, int flags)\n{\n\treturn rpcauth_lookup_credcache(auth, acred, flags,\n\t\t\t\t\trpc_task_gfp_mask());\n}\n\nstatic struct rpc_cred *\ngss_create_cred(struct rpc_auth *auth, struct auth_cred *acred, int flags, gfp_t gfp)\n{\n\tstruct gss_auth *gss_auth = container_of(auth, struct gss_auth, rpc_auth);\n\tstruct gss_cred\t*cred = NULL;\n\tint err = -ENOMEM;\n\n\tif (!(cred = kzalloc(sizeof(*cred), gfp)))\n\t\tgoto out_err;\n\n\trpcauth_init_cred(&cred->gc_base, acred, auth, &gss_credops);\n\t \n\tcred->gc_base.cr_flags = 1UL << RPCAUTH_CRED_NEW;\n\tcred->gc_service = gss_auth->service;\n\tcred->gc_principal = acred->principal;\n\tkref_get(&gss_auth->kref);\n\treturn &cred->gc_base;\n\nout_err:\n\treturn ERR_PTR(err);\n}\n\nstatic int\ngss_cred_init(struct rpc_auth *auth, struct rpc_cred *cred)\n{\n\tstruct gss_auth *gss_auth = container_of(auth, struct gss_auth, rpc_auth);\n\tstruct gss_cred *gss_cred = container_of(cred,struct gss_cred, gc_base);\n\tint err;\n\n\tdo {\n\t\terr = gss_create_upcall(gss_auth, gss_cred);\n\t} while (err == -EAGAIN);\n\treturn err;\n}\n\nstatic char *\ngss_stringify_acceptor(struct rpc_cred *cred)\n{\n\tchar *string = NULL;\n\tstruct gss_cred *gss_cred = container_of(cred, struct gss_cred, gc_base);\n\tstruct gss_cl_ctx *ctx;\n\tunsigned int len;\n\tstruct xdr_netobj *acceptor;\n\n\trcu_read_lock();\n\tctx = rcu_dereference(gss_cred->gc_ctx);\n\tif (!ctx)\n\t\tgoto out;\n\n\tlen = ctx->gc_acceptor.len;\n\trcu_read_unlock();\n\n\t \n\tif (!len)\n\t\treturn NULL;\nrealloc:\n\tstring = kmalloc(len + 1, GFP_KERNEL);\n\tif (!string)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tctx = rcu_dereference(gss_cred->gc_ctx);\n\n\t \n\tif (!ctx || !ctx->gc_acceptor.len) {\n\t\tkfree(string);\n\t\tstring = NULL;\n\t\tgoto out;\n\t}\n\n\tacceptor = &ctx->gc_acceptor;\n\n\t \n\tif (len < acceptor->len) {\n\t\tlen = acceptor->len;\n\t\trcu_read_unlock();\n\t\tkfree(string);\n\t\tgoto realloc;\n\t}\n\n\tmemcpy(string, acceptor->data, acceptor->len);\n\tstring[acceptor->len] = '\\0';\nout:\n\trcu_read_unlock();\n\treturn string;\n}\n\n \nstatic int\ngss_key_timeout(struct rpc_cred *rc)\n{\n\tstruct gss_cred *gss_cred = container_of(rc, struct gss_cred, gc_base);\n\tstruct gss_cl_ctx *ctx;\n\tunsigned long timeout = jiffies + (gss_key_expire_timeo * HZ);\n\tint ret = 0;\n\n\trcu_read_lock();\n\tctx = rcu_dereference(gss_cred->gc_ctx);\n\tif (!ctx || time_after(timeout, ctx->gc_expiry))\n\t\tret = -EACCES;\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic int\ngss_match(struct auth_cred *acred, struct rpc_cred *rc, int flags)\n{\n\tstruct gss_cred *gss_cred = container_of(rc, struct gss_cred, gc_base);\n\tstruct gss_cl_ctx *ctx;\n\tint ret;\n\n\tif (test_bit(RPCAUTH_CRED_NEW, &rc->cr_flags))\n\t\tgoto out;\n\t \n\trcu_read_lock();\n\tctx = rcu_dereference(gss_cred->gc_ctx);\n\tif (!ctx || time_after(jiffies, ctx->gc_expiry)) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\tif (!test_bit(RPCAUTH_CRED_UPTODATE, &rc->cr_flags))\n\t\treturn 0;\nout:\n\tif (acred->principal != NULL) {\n\t\tif (gss_cred->gc_principal == NULL)\n\t\t\treturn 0;\n\t\tret = strcmp(acred->principal, gss_cred->gc_principal) == 0;\n\t} else {\n\t\tif (gss_cred->gc_principal != NULL)\n\t\t\treturn 0;\n\t\tret = uid_eq(rc->cr_cred->fsuid, acred->cred->fsuid);\n\t}\n\treturn ret;\n}\n\n \nstatic int gss_marshal(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tstruct rpc_rqst *req = task->tk_rqstp;\n\tstruct rpc_cred *cred = req->rq_cred;\n\tstruct gss_cred\t*gss_cred = container_of(cred, struct gss_cred,\n\t\t\t\t\t\t gc_base);\n\tstruct gss_cl_ctx\t*ctx = gss_cred_get_ctx(cred);\n\t__be32\t\t*p, *cred_len;\n\tu32             maj_stat = 0;\n\tstruct xdr_netobj mic;\n\tstruct kvec\tiov;\n\tstruct xdr_buf\tverf_buf;\n\tint status;\n\n\t \n\n\tp = xdr_reserve_space(xdr, 7 * sizeof(*p) +\n\t\t\t      ctx->gc_wire_ctx.len);\n\tif (!p)\n\t\tgoto marshal_failed;\n\t*p++ = rpc_auth_gss;\n\tcred_len = p++;\n\n\tspin_lock(&ctx->gc_seq_lock);\n\treq->rq_seqno = (ctx->gc_seq < MAXSEQ) ? ctx->gc_seq++ : MAXSEQ;\n\tspin_unlock(&ctx->gc_seq_lock);\n\tif (req->rq_seqno == MAXSEQ)\n\t\tgoto expired;\n\ttrace_rpcgss_seqno(task);\n\n\t*p++ = cpu_to_be32(RPC_GSS_VERSION);\n\t*p++ = cpu_to_be32(ctx->gc_proc);\n\t*p++ = cpu_to_be32(req->rq_seqno);\n\t*p++ = cpu_to_be32(gss_cred->gc_service);\n\tp = xdr_encode_netobj(p, &ctx->gc_wire_ctx);\n\t*cred_len = cpu_to_be32((p - (cred_len + 1)) << 2);\n\n\t \n\n\t \n\tiov.iov_base = req->rq_snd_buf.head[0].iov_base;\n\tiov.iov_len = (u8 *)p - (u8 *)iov.iov_base;\n\txdr_buf_from_iov(&iov, &verf_buf);\n\n\tp = xdr_reserve_space(xdr, sizeof(*p));\n\tif (!p)\n\t\tgoto marshal_failed;\n\t*p++ = rpc_auth_gss;\n\tmic.data = (u8 *)(p + 1);\n\tmaj_stat = gss_get_mic(ctx->gc_gss_ctx, &verf_buf, &mic);\n\tif (maj_stat == GSS_S_CONTEXT_EXPIRED)\n\t\tgoto expired;\n\telse if (maj_stat != 0)\n\t\tgoto bad_mic;\n\tif (xdr_stream_encode_opaque_inline(xdr, (void **)&p, mic.len) < 0)\n\t\tgoto marshal_failed;\n\tstatus = 0;\nout:\n\tgss_put_ctx(ctx);\n\treturn status;\nexpired:\n\tclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\n\tstatus = -EKEYEXPIRED;\n\tgoto out;\nmarshal_failed:\n\tstatus = -EMSGSIZE;\n\tgoto out;\nbad_mic:\n\ttrace_rpcgss_get_mic(task, maj_stat);\n\tstatus = -EIO;\n\tgoto out;\n}\n\nstatic int gss_renew_cred(struct rpc_task *task)\n{\n\tstruct rpc_cred *oldcred = task->tk_rqstp->rq_cred;\n\tstruct gss_cred *gss_cred = container_of(oldcred,\n\t\t\t\t\t\t struct gss_cred,\n\t\t\t\t\t\t gc_base);\n\tstruct rpc_auth *auth = oldcred->cr_auth;\n\tstruct auth_cred acred = {\n\t\t.cred = oldcred->cr_cred,\n\t\t.principal = gss_cred->gc_principal,\n\t};\n\tstruct rpc_cred *new;\n\n\tnew = gss_lookup_cred(auth, &acred, RPCAUTH_LOOKUP_NEW);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\ttask->tk_rqstp->rq_cred = new;\n\tput_rpccred(oldcred);\n\treturn 0;\n}\n\nstatic int gss_cred_is_negative_entry(struct rpc_cred *cred)\n{\n\tif (test_bit(RPCAUTH_CRED_NEGATIVE, &cred->cr_flags)) {\n\t\tunsigned long now = jiffies;\n\t\tunsigned long begin, expire;\n\t\tstruct gss_cred *gss_cred;\n\n\t\tgss_cred = container_of(cred, struct gss_cred, gc_base);\n\t\tbegin = gss_cred->gc_upcall_timestamp;\n\t\texpire = begin + gss_expired_cred_retry_delay * HZ;\n\n\t\tif (time_in_range_open(now, begin, expire))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int\ngss_refresh(struct rpc_task *task)\n{\n\tstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\n\tint ret = 0;\n\n\tif (gss_cred_is_negative_entry(cred))\n\t\treturn -EKEYEXPIRED;\n\n\tif (!test_bit(RPCAUTH_CRED_NEW, &cred->cr_flags) &&\n\t\t\t!test_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags)) {\n\t\tret = gss_renew_cred(task);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tcred = task->tk_rqstp->rq_cred;\n\t}\n\n\tif (test_bit(RPCAUTH_CRED_NEW, &cred->cr_flags))\n\t\tret = gss_refresh_upcall(task);\nout:\n\treturn ret;\n}\n\n \nstatic int\ngss_refresh_null(struct rpc_task *task)\n{\n\treturn 0;\n}\n\nstatic int\ngss_validate(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\n\tstruct gss_cl_ctx *ctx = gss_cred_get_ctx(cred);\n\t__be32\t\t*p, *seq = NULL;\n\tstruct kvec\tiov;\n\tstruct xdr_buf\tverf_buf;\n\tstruct xdr_netobj mic;\n\tu32\t\tlen, maj_stat;\n\tint\t\tstatus;\n\n\tp = xdr_inline_decode(xdr, 2 * sizeof(*p));\n\tif (!p)\n\t\tgoto validate_failed;\n\tif (*p++ != rpc_auth_gss)\n\t\tgoto validate_failed;\n\tlen = be32_to_cpup(p);\n\tif (len > RPC_MAX_AUTH_SIZE)\n\t\tgoto validate_failed;\n\tp = xdr_inline_decode(xdr, len);\n\tif (!p)\n\t\tgoto validate_failed;\n\n\tseq = kmalloc(4, GFP_KERNEL);\n\tif (!seq)\n\t\tgoto validate_failed;\n\t*seq = cpu_to_be32(task->tk_rqstp->rq_seqno);\n\tiov.iov_base = seq;\n\tiov.iov_len = 4;\n\txdr_buf_from_iov(&iov, &verf_buf);\n\tmic.data = (u8 *)p;\n\tmic.len = len;\n\tmaj_stat = gss_verify_mic(ctx->gc_gss_ctx, &verf_buf, &mic);\n\tif (maj_stat == GSS_S_CONTEXT_EXPIRED)\n\t\tclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\n\tif (maj_stat)\n\t\tgoto bad_mic;\n\n\t \n\tif (test_bit(RPCAUTH_AUTH_UPDATE_SLACK, &cred->cr_auth->au_flags))\n\t\tcred->cr_auth->au_verfsize = XDR_QUADLEN(len) + 2;\n\tstatus = 0;\nout:\n\tgss_put_ctx(ctx);\n\tkfree(seq);\n\treturn status;\n\nvalidate_failed:\n\tstatus = -EIO;\n\tgoto out;\nbad_mic:\n\ttrace_rpcgss_verify_mic(task, maj_stat);\n\tstatus = -EACCES;\n\tgoto out;\n}\n\nstatic noinline_for_stack int\ngss_wrap_req_integ(struct rpc_cred *cred, struct gss_cl_ctx *ctx,\n\t\t   struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tstruct rpc_rqst *rqstp = task->tk_rqstp;\n\tstruct xdr_buf integ_buf, *snd_buf = &rqstp->rq_snd_buf;\n\tstruct xdr_netobj mic;\n\t__be32 *p, *integ_len;\n\tu32 offset, maj_stat;\n\n\tp = xdr_reserve_space(xdr, 2 * sizeof(*p));\n\tif (!p)\n\t\tgoto wrap_failed;\n\tinteg_len = p++;\n\t*p = cpu_to_be32(rqstp->rq_seqno);\n\n\tif (rpcauth_wrap_req_encode(task, xdr))\n\t\tgoto wrap_failed;\n\n\toffset = (u8 *)p - (u8 *)snd_buf->head[0].iov_base;\n\tif (xdr_buf_subsegment(snd_buf, &integ_buf,\n\t\t\t\toffset, snd_buf->len - offset))\n\t\tgoto wrap_failed;\n\t*integ_len = cpu_to_be32(integ_buf.len);\n\n\tp = xdr_reserve_space(xdr, 0);\n\tif (!p)\n\t\tgoto wrap_failed;\n\tmic.data = (u8 *)(p + 1);\n\tmaj_stat = gss_get_mic(ctx->gc_gss_ctx, &integ_buf, &mic);\n\tif (maj_stat == GSS_S_CONTEXT_EXPIRED)\n\t\tclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\n\telse if (maj_stat)\n\t\tgoto bad_mic;\n\t \n\tif (xdr_stream_encode_opaque_inline(xdr, (void **)&p, mic.len) < 0)\n\t\tgoto wrap_failed;\n\treturn 0;\nwrap_failed:\n\treturn -EMSGSIZE;\nbad_mic:\n\ttrace_rpcgss_get_mic(task, maj_stat);\n\treturn -EIO;\n}\n\nstatic void\npriv_release_snd_buf(struct rpc_rqst *rqstp)\n{\n\tint i;\n\n\tfor (i=0; i < rqstp->rq_enc_pages_num; i++)\n\t\t__free_page(rqstp->rq_enc_pages[i]);\n\tkfree(rqstp->rq_enc_pages);\n\trqstp->rq_release_snd_buf = NULL;\n}\n\nstatic int\nalloc_enc_pages(struct rpc_rqst *rqstp)\n{\n\tstruct xdr_buf *snd_buf = &rqstp->rq_snd_buf;\n\tint first, last, i;\n\n\tif (rqstp->rq_release_snd_buf)\n\t\trqstp->rq_release_snd_buf(rqstp);\n\n\tif (snd_buf->page_len == 0) {\n\t\trqstp->rq_enc_pages_num = 0;\n\t\treturn 0;\n\t}\n\n\tfirst = snd_buf->page_base >> PAGE_SHIFT;\n\tlast = (snd_buf->page_base + snd_buf->page_len - 1) >> PAGE_SHIFT;\n\trqstp->rq_enc_pages_num = last - first + 1 + 1;\n\trqstp->rq_enc_pages\n\t\t= kmalloc_array(rqstp->rq_enc_pages_num,\n\t\t\t\tsizeof(struct page *),\n\t\t\t\tGFP_KERNEL);\n\tif (!rqstp->rq_enc_pages)\n\t\tgoto out;\n\tfor (i=0; i < rqstp->rq_enc_pages_num; i++) {\n\t\trqstp->rq_enc_pages[i] = alloc_page(GFP_KERNEL);\n\t\tif (rqstp->rq_enc_pages[i] == NULL)\n\t\t\tgoto out_free;\n\t}\n\trqstp->rq_release_snd_buf = priv_release_snd_buf;\n\treturn 0;\nout_free:\n\trqstp->rq_enc_pages_num = i;\n\tpriv_release_snd_buf(rqstp);\nout:\n\treturn -EAGAIN;\n}\n\nstatic noinline_for_stack int\ngss_wrap_req_priv(struct rpc_cred *cred, struct gss_cl_ctx *ctx,\n\t\t  struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tstruct rpc_rqst *rqstp = task->tk_rqstp;\n\tstruct xdr_buf\t*snd_buf = &rqstp->rq_snd_buf;\n\tu32\t\tpad, offset, maj_stat;\n\tint\t\tstatus;\n\t__be32\t\t*p, *opaque_len;\n\tstruct page\t**inpages;\n\tint\t\tfirst;\n\tstruct kvec\t*iov;\n\n\tstatus = -EIO;\n\tp = xdr_reserve_space(xdr, 2 * sizeof(*p));\n\tif (!p)\n\t\tgoto wrap_failed;\n\topaque_len = p++;\n\t*p = cpu_to_be32(rqstp->rq_seqno);\n\n\tif (rpcauth_wrap_req_encode(task, xdr))\n\t\tgoto wrap_failed;\n\n\tstatus = alloc_enc_pages(rqstp);\n\tif (unlikely(status))\n\t\tgoto wrap_failed;\n\tfirst = snd_buf->page_base >> PAGE_SHIFT;\n\tinpages = snd_buf->pages + first;\n\tsnd_buf->pages = rqstp->rq_enc_pages;\n\tsnd_buf->page_base -= first << PAGE_SHIFT;\n\t \n\tif (snd_buf->page_len || snd_buf->tail[0].iov_len) {\n\t\tchar *tmp;\n\n\t\ttmp = page_address(rqstp->rq_enc_pages[rqstp->rq_enc_pages_num - 1]);\n\t\tmemcpy(tmp, snd_buf->tail[0].iov_base, snd_buf->tail[0].iov_len);\n\t\tsnd_buf->tail[0].iov_base = tmp;\n\t}\n\toffset = (u8 *)p - (u8 *)snd_buf->head[0].iov_base;\n\tmaj_stat = gss_wrap(ctx->gc_gss_ctx, offset, snd_buf, inpages);\n\t \n\tif (unlikely(snd_buf->len > snd_buf->buflen))\n\t\tgoto wrap_failed;\n\t \n\tif (maj_stat == GSS_S_CONTEXT_EXPIRED)\n\t\tclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\n\telse if (maj_stat)\n\t\tgoto bad_wrap;\n\n\t*opaque_len = cpu_to_be32(snd_buf->len - offset);\n\t \n\tif (snd_buf->page_len || snd_buf->tail[0].iov_len)\n\t\tiov = snd_buf->tail;\n\telse\n\t\tiov = snd_buf->head;\n\tp = iov->iov_base + iov->iov_len;\n\tpad = xdr_pad_size(snd_buf->len - offset);\n\tmemset(p, 0, pad);\n\tiov->iov_len += pad;\n\tsnd_buf->len += pad;\n\n\treturn 0;\nwrap_failed:\n\treturn status;\nbad_wrap:\n\ttrace_rpcgss_wrap(task, maj_stat);\n\treturn -EIO;\n}\n\nstatic int gss_wrap_req(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tstruct rpc_cred *cred = task->tk_rqstp->rq_cred;\n\tstruct gss_cred\t*gss_cred = container_of(cred, struct gss_cred,\n\t\t\tgc_base);\n\tstruct gss_cl_ctx *ctx = gss_cred_get_ctx(cred);\n\tint status;\n\n\tstatus = -EIO;\n\tif (ctx->gc_proc != RPC_GSS_PROC_DATA) {\n\t\t \n\t\tstatus = rpcauth_wrap_req_encode(task, xdr);\n\t\tgoto out;\n\t}\n\tswitch (gss_cred->gc_service) {\n\tcase RPC_GSS_SVC_NONE:\n\t\tstatus = rpcauth_wrap_req_encode(task, xdr);\n\t\tbreak;\n\tcase RPC_GSS_SVC_INTEGRITY:\n\t\tstatus = gss_wrap_req_integ(cred, ctx, task, xdr);\n\t\tbreak;\n\tcase RPC_GSS_SVC_PRIVACY:\n\t\tstatus = gss_wrap_req_priv(cred, ctx, task, xdr);\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EIO;\n\t}\nout:\n\tgss_put_ctx(ctx);\n\treturn status;\n}\n\n \nstatic void gss_update_rslack(struct rpc_task *task, struct rpc_cred *cred,\n\t\t\t      unsigned int before, unsigned int after)\n{\n\tstruct rpc_auth *auth = cred->cr_auth;\n\n\tif (test_and_clear_bit(RPCAUTH_AUTH_UPDATE_SLACK, &auth->au_flags)) {\n\t\tauth->au_ralign = auth->au_verfsize + before;\n\t\tauth->au_rslack = auth->au_verfsize + after;\n\t\ttrace_rpcgss_update_slack(task, auth);\n\t}\n}\n\nstatic int\ngss_unwrap_resp_auth(struct rpc_task *task, struct rpc_cred *cred)\n{\n\tgss_update_rslack(task, cred, 0, 0);\n\treturn 0;\n}\n\n \nstatic noinline_for_stack int\ngss_unwrap_resp_integ(struct rpc_task *task, struct rpc_cred *cred,\n\t\t      struct gss_cl_ctx *ctx, struct rpc_rqst *rqstp,\n\t\t      struct xdr_stream *xdr)\n{\n\tstruct xdr_buf gss_data, *rcv_buf = &rqstp->rq_rcv_buf;\n\tu32 len, offset, seqno, maj_stat;\n\tstruct xdr_netobj mic;\n\tint ret;\n\n\tret = -EIO;\n\tmic.data = NULL;\n\n\t \n\tif (xdr_stream_decode_u32(xdr, &len))\n\t\tgoto unwrap_failed;\n\tif (len & 3)\n\t\tgoto unwrap_failed;\n\toffset = rcv_buf->len - xdr_stream_remaining(xdr);\n\tif (xdr_stream_decode_u32(xdr, &seqno))\n\t\tgoto unwrap_failed;\n\tif (seqno != rqstp->rq_seqno)\n\t\tgoto bad_seqno;\n\tif (xdr_buf_subsegment(rcv_buf, &gss_data, offset, len))\n\t\tgoto unwrap_failed;\n\n\t \n\n\t \n\toffset += len;\n\tif (xdr_decode_word(rcv_buf, offset, &len))\n\t\tgoto unwrap_failed;\n\toffset += sizeof(__be32);\n\tif (offset + len > rcv_buf->len)\n\t\tgoto unwrap_failed;\n\tmic.len = len;\n\tmic.data = kmalloc(len, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(mic.data))\n\t\tgoto unwrap_failed;\n\tif (read_bytes_from_xdr_buf(rcv_buf, offset, mic.data, mic.len))\n\t\tgoto unwrap_failed;\n\n\tmaj_stat = gss_verify_mic(ctx->gc_gss_ctx, &gss_data, &mic);\n\tif (maj_stat == GSS_S_CONTEXT_EXPIRED)\n\t\tclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\n\tif (maj_stat != GSS_S_COMPLETE)\n\t\tgoto bad_mic;\n\n\tgss_update_rslack(task, cred, 2, 2 + 1 + XDR_QUADLEN(mic.len));\n\tret = 0;\n\nout:\n\tkfree(mic.data);\n\treturn ret;\n\nunwrap_failed:\n\ttrace_rpcgss_unwrap_failed(task);\n\tgoto out;\nbad_seqno:\n\ttrace_rpcgss_bad_seqno(task, rqstp->rq_seqno, seqno);\n\tgoto out;\nbad_mic:\n\ttrace_rpcgss_verify_mic(task, maj_stat);\n\tgoto out;\n}\n\nstatic noinline_for_stack int\ngss_unwrap_resp_priv(struct rpc_task *task, struct rpc_cred *cred,\n\t\t     struct gss_cl_ctx *ctx, struct rpc_rqst *rqstp,\n\t\t     struct xdr_stream *xdr)\n{\n\tstruct xdr_buf *rcv_buf = &rqstp->rq_rcv_buf;\n\tstruct kvec *head = rqstp->rq_rcv_buf.head;\n\tu32 offset, opaque_len, maj_stat;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 2 * sizeof(*p));\n\tif (unlikely(!p))\n\t\tgoto unwrap_failed;\n\topaque_len = be32_to_cpup(p++);\n\toffset = (u8 *)(p) - (u8 *)head->iov_base;\n\tif (offset + opaque_len > rcv_buf->len)\n\t\tgoto unwrap_failed;\n\n\tmaj_stat = gss_unwrap(ctx->gc_gss_ctx, offset,\n\t\t\t      offset + opaque_len, rcv_buf);\n\tif (maj_stat == GSS_S_CONTEXT_EXPIRED)\n\t\tclear_bit(RPCAUTH_CRED_UPTODATE, &cred->cr_flags);\n\tif (maj_stat != GSS_S_COMPLETE)\n\t\tgoto bad_unwrap;\n\t \n\tif (be32_to_cpup(p++) != rqstp->rq_seqno)\n\t\tgoto bad_seqno;\n\n\t \n\txdr_init_decode(xdr, rcv_buf, p, rqstp);\n\n\tgss_update_rslack(task, cred, 2 + ctx->gc_gss_ctx->align,\n\t\t\t  2 + ctx->gc_gss_ctx->slack);\n\n\treturn 0;\nunwrap_failed:\n\ttrace_rpcgss_unwrap_failed(task);\n\treturn -EIO;\nbad_seqno:\n\ttrace_rpcgss_bad_seqno(task, rqstp->rq_seqno, be32_to_cpup(--p));\n\treturn -EIO;\nbad_unwrap:\n\ttrace_rpcgss_unwrap(task, maj_stat);\n\treturn -EIO;\n}\n\nstatic bool\ngss_seq_is_newer(u32 new, u32 old)\n{\n\treturn (s32)(new - old) > 0;\n}\n\nstatic bool\ngss_xmit_need_reencode(struct rpc_task *task)\n{\n\tstruct rpc_rqst *req = task->tk_rqstp;\n\tstruct rpc_cred *cred = req->rq_cred;\n\tstruct gss_cl_ctx *ctx = gss_cred_get_ctx(cred);\n\tu32 win, seq_xmit = 0;\n\tbool ret = true;\n\n\tif (!ctx)\n\t\tgoto out;\n\n\tif (gss_seq_is_newer(req->rq_seqno, READ_ONCE(ctx->gc_seq)))\n\t\tgoto out_ctx;\n\n\tseq_xmit = READ_ONCE(ctx->gc_seq_xmit);\n\twhile (gss_seq_is_newer(req->rq_seqno, seq_xmit)) {\n\t\tu32 tmp = seq_xmit;\n\n\t\tseq_xmit = cmpxchg(&ctx->gc_seq_xmit, tmp, req->rq_seqno);\n\t\tif (seq_xmit == tmp) {\n\t\t\tret = false;\n\t\t\tgoto out_ctx;\n\t\t}\n\t}\n\n\twin = ctx->gc_win;\n\tif (win > 0)\n\t\tret = !gss_seq_is_newer(req->rq_seqno, seq_xmit - win);\n\nout_ctx:\n\tgss_put_ctx(ctx);\nout:\n\ttrace_rpcgss_need_reencode(task, seq_xmit, ret);\n\treturn ret;\n}\n\nstatic int\ngss_unwrap_resp(struct rpc_task *task, struct xdr_stream *xdr)\n{\n\tstruct rpc_rqst *rqstp = task->tk_rqstp;\n\tstruct rpc_cred *cred = rqstp->rq_cred;\n\tstruct gss_cred *gss_cred = container_of(cred, struct gss_cred,\n\t\t\tgc_base);\n\tstruct gss_cl_ctx *ctx = gss_cred_get_ctx(cred);\n\tint status = -EIO;\n\n\tif (ctx->gc_proc != RPC_GSS_PROC_DATA)\n\t\tgoto out_decode;\n\tswitch (gss_cred->gc_service) {\n\tcase RPC_GSS_SVC_NONE:\n\t\tstatus = gss_unwrap_resp_auth(task, cred);\n\t\tbreak;\n\tcase RPC_GSS_SVC_INTEGRITY:\n\t\tstatus = gss_unwrap_resp_integ(task, cred, ctx, rqstp, xdr);\n\t\tbreak;\n\tcase RPC_GSS_SVC_PRIVACY:\n\t\tstatus = gss_unwrap_resp_priv(task, cred, ctx, rqstp, xdr);\n\t\tbreak;\n\t}\n\tif (status)\n\t\tgoto out;\n\nout_decode:\n\tstatus = rpcauth_unwrap_resp_decode(task, xdr);\nout:\n\tgss_put_ctx(ctx);\n\treturn status;\n}\n\nstatic const struct rpc_authops authgss_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.au_flavor\t= RPC_AUTH_GSS,\n\t.au_name\t= \"RPCSEC_GSS\",\n\t.create\t\t= gss_create,\n\t.destroy\t= gss_destroy,\n\t.hash_cred\t= gss_hash_cred,\n\t.lookup_cred\t= gss_lookup_cred,\n\t.crcreate\t= gss_create_cred,\n\t.info2flavor\t= gss_mech_info2flavor,\n\t.flavor2info\t= gss_mech_flavor2info,\n};\n\nstatic const struct rpc_credops gss_credops = {\n\t.cr_name\t\t= \"AUTH_GSS\",\n\t.crdestroy\t\t= gss_destroy_cred,\n\t.cr_init\t\t= gss_cred_init,\n\t.crmatch\t\t= gss_match,\n\t.crmarshal\t\t= gss_marshal,\n\t.crrefresh\t\t= gss_refresh,\n\t.crvalidate\t\t= gss_validate,\n\t.crwrap_req\t\t= gss_wrap_req,\n\t.crunwrap_resp\t\t= gss_unwrap_resp,\n\t.crkey_timeout\t\t= gss_key_timeout,\n\t.crstringify_acceptor\t= gss_stringify_acceptor,\n\t.crneed_reencode\t= gss_xmit_need_reencode,\n};\n\nstatic const struct rpc_credops gss_nullops = {\n\t.cr_name\t\t= \"AUTH_GSS\",\n\t.crdestroy\t\t= gss_destroy_nullcred,\n\t.crmatch\t\t= gss_match,\n\t.crmarshal\t\t= gss_marshal,\n\t.crrefresh\t\t= gss_refresh_null,\n\t.crvalidate\t\t= gss_validate,\n\t.crwrap_req\t\t= gss_wrap_req,\n\t.crunwrap_resp\t\t= gss_unwrap_resp,\n\t.crstringify_acceptor\t= gss_stringify_acceptor,\n};\n\nstatic const struct rpc_pipe_ops gss_upcall_ops_v0 = {\n\t.upcall\t\t= gss_v0_upcall,\n\t.downcall\t= gss_pipe_downcall,\n\t.destroy_msg\t= gss_pipe_destroy_msg,\n\t.open_pipe\t= gss_pipe_open_v0,\n\t.release_pipe\t= gss_pipe_release,\n};\n\nstatic const struct rpc_pipe_ops gss_upcall_ops_v1 = {\n\t.upcall\t\t= gss_v1_upcall,\n\t.downcall\t= gss_pipe_downcall,\n\t.destroy_msg\t= gss_pipe_destroy_msg,\n\t.open_pipe\t= gss_pipe_open_v1,\n\t.release_pipe\t= gss_pipe_release,\n};\n\nstatic __net_init int rpcsec_gss_init_net(struct net *net)\n{\n\treturn gss_svc_init_net(net);\n}\n\nstatic __net_exit void rpcsec_gss_exit_net(struct net *net)\n{\n\tgss_svc_shutdown_net(net);\n}\n\nstatic struct pernet_operations rpcsec_gss_net_ops = {\n\t.init = rpcsec_gss_init_net,\n\t.exit = rpcsec_gss_exit_net,\n};\n\n \nstatic int __init init_rpcsec_gss(void)\n{\n\tint err = 0;\n\n\terr = rpcauth_register(&authgss_ops);\n\tif (err)\n\t\tgoto out;\n\terr = gss_svc_init();\n\tif (err)\n\t\tgoto out_unregister;\n\terr = register_pernet_subsys(&rpcsec_gss_net_ops);\n\tif (err)\n\t\tgoto out_svc_exit;\n\trpc_init_wait_queue(&pipe_version_rpc_waitqueue, \"gss pipe version\");\n\treturn 0;\nout_svc_exit:\n\tgss_svc_shutdown();\nout_unregister:\n\trpcauth_unregister(&authgss_ops);\nout:\n\treturn err;\n}\n\nstatic void __exit exit_rpcsec_gss(void)\n{\n\tunregister_pernet_subsys(&rpcsec_gss_net_ops);\n\tgss_svc_shutdown();\n\trpcauth_unregister(&authgss_ops);\n\trcu_barrier();  \n}\n\nMODULE_ALIAS(\"rpc-auth-6\");\nMODULE_LICENSE(\"GPL\");\nmodule_param_named(expired_cred_retry_delay,\n\t\t   gss_expired_cred_retry_delay,\n\t\t   uint, 0644);\nMODULE_PARM_DESC(expired_cred_retry_delay, \"Timeout (in seconds) until \"\n\t\t\"the RPC engine retries an expired credential\");\n\nmodule_param_named(key_expire_timeo,\n\t\t   gss_key_expire_timeo,\n\t\t   uint, 0644);\nMODULE_PARM_DESC(key_expire_timeo, \"Time (in seconds) at the end of a \"\n\t\t\"credential keys lifetime where the NFS layer cleans up \"\n\t\t\"prior to key expiration\");\n\nmodule_init(init_rpcsec_gss)\nmodule_exit(exit_rpcsec_gss)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}