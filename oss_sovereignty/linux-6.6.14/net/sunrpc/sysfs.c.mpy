{
  "module_name": "sysfs.c",
  "hash_id": "f0c630707461b6be2c1197e3673c6ebf9b5d7ed40a03cbd277632729796687a8",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/sysfs.c",
  "human_readable_source": "\n \n#include <linux/sunrpc/clnt.h>\n#include <linux/kobject.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/xprtsock.h>\n\n#include \"sysfs.h\"\n\nstruct xprt_addr {\n\tconst char *addr;\n\tstruct rcu_head rcu;\n};\n\nstatic void free_xprt_addr(struct rcu_head *head)\n{\n\tstruct xprt_addr *addr = container_of(head, struct xprt_addr, rcu);\n\n\tkfree(addr->addr);\n\tkfree(addr);\n}\n\nstatic struct kset *rpc_sunrpc_kset;\nstatic struct kobject *rpc_sunrpc_client_kobj, *rpc_sunrpc_xprt_switch_kobj;\n\nstatic void rpc_sysfs_object_release(struct kobject *kobj)\n{\n\tkfree(kobj);\n}\n\nstatic const struct kobj_ns_type_operations *\nrpc_sysfs_object_child_ns_type(const struct kobject *kobj)\n{\n\treturn &net_ns_type_operations;\n}\n\nstatic const struct kobj_type rpc_sysfs_object_type = {\n\t.release = rpc_sysfs_object_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.child_ns_type = rpc_sysfs_object_child_ns_type,\n};\n\nstatic struct kobject *rpc_sysfs_object_alloc(const char *name,\n\t\t\t\t\t      struct kset *kset,\n\t\t\t\t\t      struct kobject *parent)\n{\n\tstruct kobject *kobj;\n\n\tkobj = kzalloc(sizeof(*kobj), GFP_KERNEL);\n\tif (kobj) {\n\t\tkobj->kset = kset;\n\t\tif (kobject_init_and_add(kobj, &rpc_sysfs_object_type,\n\t\t\t\t\t parent, \"%s\", name) == 0)\n\t\t\treturn kobj;\n\t\tkobject_put(kobj);\n\t}\n\treturn NULL;\n}\n\nstatic inline struct rpc_xprt *\nrpc_sysfs_xprt_kobj_get_xprt(struct kobject *kobj)\n{\n\tstruct rpc_sysfs_xprt *x = container_of(kobj,\n\t\tstruct rpc_sysfs_xprt, kobject);\n\n\treturn xprt_get(x->xprt);\n}\n\nstatic inline struct rpc_xprt_switch *\nrpc_sysfs_xprt_kobj_get_xprt_switch(struct kobject *kobj)\n{\n\tstruct rpc_sysfs_xprt *x = container_of(kobj,\n\t\tstruct rpc_sysfs_xprt, kobject);\n\n\treturn xprt_switch_get(x->xprt_switch);\n}\n\nstatic inline struct rpc_xprt_switch *\nrpc_sysfs_xprt_switch_kobj_get_xprt(struct kobject *kobj)\n{\n\tstruct rpc_sysfs_xprt_switch *x = container_of(kobj,\n\t\tstruct rpc_sysfs_xprt_switch, kobject);\n\n\treturn xprt_switch_get(x->xprt_switch);\n}\n\nstatic ssize_t rpc_sysfs_xprt_dstaddr_show(struct kobject *kobj,\n\t\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct rpc_xprt *xprt = rpc_sysfs_xprt_kobj_get_xprt(kobj);\n\tssize_t ret;\n\n\tif (!xprt) {\n\t\tret = sprintf(buf, \"<closed>\\n\");\n\t\tgoto out;\n\t}\n\tret = sprintf(buf, \"%s\\n\", xprt->address_strings[RPC_DISPLAY_ADDR]);\n\txprt_put(xprt);\nout:\n\treturn ret;\n}\n\nstatic ssize_t rpc_sysfs_xprt_srcaddr_show(struct kobject *kobj,\n\t\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct rpc_xprt *xprt = rpc_sysfs_xprt_kobj_get_xprt(kobj);\n\tsize_t buflen = PAGE_SIZE;\n\tssize_t ret;\n\n\tif (!xprt || !xprt_connected(xprt)) {\n\t\tret = sprintf(buf, \"<closed>\\n\");\n\t} else if (xprt->ops->get_srcaddr) {\n\t\tret = xprt->ops->get_srcaddr(xprt, buf, buflen);\n\t\tif (ret > 0) {\n\t\t\tif (ret < buflen - 1) {\n\t\t\t\tbuf[ret] = '\\n';\n\t\t\t\tret++;\n\t\t\t\tbuf[ret] = '\\0';\n\t\t\t}\n\t\t} else\n\t\t\tret = sprintf(buf, \"<closed>\\n\");\n\t} else\n\t\tret = sprintf(buf, \"<not a socket>\\n\");\n\txprt_put(xprt);\n\treturn ret;\n}\n\nstatic ssize_t rpc_sysfs_xprt_info_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct rpc_xprt *xprt = rpc_sysfs_xprt_kobj_get_xprt(kobj);\n\tunsigned short srcport = 0;\n\tsize_t buflen = PAGE_SIZE;\n\tssize_t ret;\n\n\tif (!xprt || !xprt_connected(xprt)) {\n\t\tret = sprintf(buf, \"<closed>\\n\");\n\t\tgoto out;\n\t}\n\n\tif (xprt->ops->get_srcport)\n\t\tsrcport = xprt->ops->get_srcport(xprt);\n\n\tret = snprintf(buf, buflen,\n\t\t       \"last_used=%lu\\ncur_cong=%lu\\ncong_win=%lu\\n\"\n\t\t       \"max_num_slots=%u\\nmin_num_slots=%u\\nnum_reqs=%u\\n\"\n\t\t       \"binding_q_len=%u\\nsending_q_len=%u\\npending_q_len=%u\\n\"\n\t\t       \"backlog_q_len=%u\\nmain_xprt=%d\\nsrc_port=%u\\n\"\n\t\t       \"tasks_queuelen=%ld\\ndst_port=%s\\n\",\n\t\t       xprt->last_used, xprt->cong, xprt->cwnd, xprt->max_reqs,\n\t\t       xprt->min_reqs, xprt->num_reqs, xprt->binding.qlen,\n\t\t       xprt->sending.qlen, xprt->pending.qlen,\n\t\t       xprt->backlog.qlen, xprt->main, srcport,\n\t\t       atomic_long_read(&xprt->queuelen),\n\t\t       xprt->address_strings[RPC_DISPLAY_PORT]);\nout:\n\txprt_put(xprt);\n\treturn ret;\n}\n\nstatic ssize_t rpc_sysfs_xprt_state_show(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct rpc_xprt *xprt = rpc_sysfs_xprt_kobj_get_xprt(kobj);\n\tssize_t ret;\n\tint locked, connected, connecting, close_wait, bound, binding,\n\t    closing, congested, cwnd_wait, write_space, offline, remove;\n\n\tif (!(xprt && xprt->state)) {\n\t\tret = sprintf(buf, \"state=CLOSED\\n\");\n\t} else {\n\t\tlocked = test_bit(XPRT_LOCKED, &xprt->state);\n\t\tconnected = test_bit(XPRT_CONNECTED, &xprt->state);\n\t\tconnecting = test_bit(XPRT_CONNECTING, &xprt->state);\n\t\tclose_wait = test_bit(XPRT_CLOSE_WAIT, &xprt->state);\n\t\tbound = test_bit(XPRT_BOUND, &xprt->state);\n\t\tbinding = test_bit(XPRT_BINDING, &xprt->state);\n\t\tclosing = test_bit(XPRT_CLOSING, &xprt->state);\n\t\tcongested = test_bit(XPRT_CONGESTED, &xprt->state);\n\t\tcwnd_wait = test_bit(XPRT_CWND_WAIT, &xprt->state);\n\t\twrite_space = test_bit(XPRT_WRITE_SPACE, &xprt->state);\n\t\toffline = test_bit(XPRT_OFFLINE, &xprt->state);\n\t\tremove = test_bit(XPRT_REMOVE, &xprt->state);\n\n\t\tret = sprintf(buf, \"state=%s %s %s %s %s %s %s %s %s %s %s %s\\n\",\n\t\t\t      locked ? \"LOCKED\" : \"\",\n\t\t\t      connected ? \"CONNECTED\" : \"\",\n\t\t\t      connecting ? \"CONNECTING\" : \"\",\n\t\t\t      close_wait ? \"CLOSE_WAIT\" : \"\",\n\t\t\t      bound ? \"BOUND\" : \"\",\n\t\t\t      binding ? \"BOUNDING\" : \"\",\n\t\t\t      closing ? \"CLOSING\" : \"\",\n\t\t\t      congested ? \"CONGESTED\" : \"\",\n\t\t\t      cwnd_wait ? \"CWND_WAIT\" : \"\",\n\t\t\t      write_space ? \"WRITE_SPACE\" : \"\",\n\t\t\t      offline ? \"OFFLINE\" : \"\",\n\t\t\t      remove ? \"REMOVE\" : \"\");\n\t}\n\n\txprt_put(xprt);\n\treturn ret;\n}\n\nstatic ssize_t rpc_sysfs_xprt_switch_info_show(struct kobject *kobj,\n\t\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct rpc_xprt_switch *xprt_switch =\n\t\trpc_sysfs_xprt_switch_kobj_get_xprt(kobj);\n\tssize_t ret;\n\n\tif (!xprt_switch)\n\t\treturn 0;\n\tret = sprintf(buf, \"num_xprts=%u\\nnum_active=%u\\n\"\n\t\t      \"num_unique_destaddr=%u\\nqueue_len=%ld\\n\",\n\t\t      xprt_switch->xps_nxprts, xprt_switch->xps_nactive,\n\t\t      xprt_switch->xps_nunique_destaddr_xprts,\n\t\t      atomic_long_read(&xprt_switch->xps_queuelen));\n\txprt_switch_put(xprt_switch);\n\treturn ret;\n}\n\nstatic ssize_t rpc_sysfs_xprt_dstaddr_store(struct kobject *kobj,\n\t\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct rpc_xprt *xprt = rpc_sysfs_xprt_kobj_get_xprt(kobj);\n\tstruct sockaddr *saddr;\n\tchar *dst_addr;\n\tint port;\n\tstruct xprt_addr *saved_addr;\n\tsize_t buf_len;\n\n\tif (!xprt)\n\t\treturn 0;\n\tif (!(xprt->xprt_class->ident == XPRT_TRANSPORT_TCP ||\n\t      xprt->xprt_class->ident == XPRT_TRANSPORT_TCP_TLS ||\n\t      xprt->xprt_class->ident == XPRT_TRANSPORT_RDMA)) {\n\t\txprt_put(xprt);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (wait_on_bit_lock(&xprt->state, XPRT_LOCKED, TASK_KILLABLE)) {\n\t\tcount = -EINTR;\n\t\tgoto out_put;\n\t}\n\tsaddr = (struct sockaddr *)&xprt->addr;\n\tport = rpc_get_port(saddr);\n\n\t \n\tbuf_len = strcspn(buf, \"\\n\");\n\n\tdst_addr = kstrndup(buf, buf_len, GFP_KERNEL);\n\tif (!dst_addr)\n\t\tgoto out_err;\n\tsaved_addr = kzalloc(sizeof(*saved_addr), GFP_KERNEL);\n\tif (!saved_addr)\n\t\tgoto out_err_free;\n\tsaved_addr->addr =\n\t\trcu_dereference_raw(xprt->address_strings[RPC_DISPLAY_ADDR]);\n\trcu_assign_pointer(xprt->address_strings[RPC_DISPLAY_ADDR], dst_addr);\n\tcall_rcu(&saved_addr->rcu, free_xprt_addr);\n\txprt->addrlen = rpc_pton(xprt->xprt_net, buf, buf_len, saddr,\n\t\t\t\t sizeof(*saddr));\n\trpc_set_port(saddr, port);\n\n\txprt_force_disconnect(xprt);\nout:\n\txprt_release_write(xprt, NULL);\nout_put:\n\txprt_put(xprt);\n\treturn count;\nout_err_free:\n\tkfree(dst_addr);\nout_err:\n\tcount = -ENOMEM;\n\tgoto out;\n}\n\nstatic ssize_t rpc_sysfs_xprt_state_change(struct kobject *kobj,\n\t\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct rpc_xprt *xprt = rpc_sysfs_xprt_kobj_get_xprt(kobj);\n\tint offline = 0, online = 0, remove = 0;\n\tstruct rpc_xprt_switch *xps = rpc_sysfs_xprt_kobj_get_xprt_switch(kobj);\n\n\tif (!xprt || !xps) {\n\t\tcount = 0;\n\t\tgoto out_put;\n\t}\n\n\tif (!strncmp(buf, \"offline\", 7))\n\t\toffline = 1;\n\telse if (!strncmp(buf, \"online\", 6))\n\t\tonline = 1;\n\telse if (!strncmp(buf, \"remove\", 6))\n\t\tremove = 1;\n\telse {\n\t\tcount = -EINVAL;\n\t\tgoto out_put;\n\t}\n\n\tif (wait_on_bit_lock(&xprt->state, XPRT_LOCKED, TASK_KILLABLE)) {\n\t\tcount = -EINTR;\n\t\tgoto out_put;\n\t}\n\tif (xprt->main) {\n\t\tcount = -EINVAL;\n\t\tgoto release_tasks;\n\t}\n\tif (offline) {\n\t\txprt_set_offline_locked(xprt, xps);\n\t} else if (online) {\n\t\txprt_set_online_locked(xprt, xps);\n\t} else if (remove) {\n\t\tif (test_bit(XPRT_OFFLINE, &xprt->state))\n\t\t\txprt_delete_locked(xprt, xps);\n\t\telse\n\t\t\tcount = -EINVAL;\n\t}\n\nrelease_tasks:\n\txprt_release_write(xprt, NULL);\nout_put:\n\txprt_put(xprt);\n\txprt_switch_put(xps);\n\treturn count;\n}\n\nint rpc_sysfs_init(void)\n{\n\trpc_sunrpc_kset = kset_create_and_add(\"sunrpc\", NULL, kernel_kobj);\n\tif (!rpc_sunrpc_kset)\n\t\treturn -ENOMEM;\n\trpc_sunrpc_client_kobj =\n\t\trpc_sysfs_object_alloc(\"rpc-clients\", rpc_sunrpc_kset, NULL);\n\tif (!rpc_sunrpc_client_kobj)\n\t\tgoto err_client;\n\trpc_sunrpc_xprt_switch_kobj =\n\t\trpc_sysfs_object_alloc(\"xprt-switches\", rpc_sunrpc_kset, NULL);\n\tif (!rpc_sunrpc_xprt_switch_kobj)\n\t\tgoto err_switch;\n\treturn 0;\nerr_switch:\n\tkobject_put(rpc_sunrpc_client_kobj);\n\trpc_sunrpc_client_kobj = NULL;\nerr_client:\n\tkset_unregister(rpc_sunrpc_kset);\n\trpc_sunrpc_kset = NULL;\n\treturn -ENOMEM;\n}\n\nstatic void rpc_sysfs_client_release(struct kobject *kobj)\n{\n\tstruct rpc_sysfs_client *c;\n\n\tc = container_of(kobj, struct rpc_sysfs_client, kobject);\n\tkfree(c);\n}\n\nstatic void rpc_sysfs_xprt_switch_release(struct kobject *kobj)\n{\n\tstruct rpc_sysfs_xprt_switch *xprt_switch;\n\n\txprt_switch = container_of(kobj, struct rpc_sysfs_xprt_switch, kobject);\n\tkfree(xprt_switch);\n}\n\nstatic void rpc_sysfs_xprt_release(struct kobject *kobj)\n{\n\tstruct rpc_sysfs_xprt *xprt;\n\n\txprt = container_of(kobj, struct rpc_sysfs_xprt, kobject);\n\tkfree(xprt);\n}\n\nstatic const void *rpc_sysfs_client_namespace(const struct kobject *kobj)\n{\n\treturn container_of(kobj, struct rpc_sysfs_client, kobject)->net;\n}\n\nstatic const void *rpc_sysfs_xprt_switch_namespace(const struct kobject *kobj)\n{\n\treturn container_of(kobj, struct rpc_sysfs_xprt_switch, kobject)->net;\n}\n\nstatic const void *rpc_sysfs_xprt_namespace(const struct kobject *kobj)\n{\n\treturn container_of(kobj, struct rpc_sysfs_xprt,\n\t\t\t    kobject)->xprt->xprt_net;\n}\n\nstatic struct kobj_attribute rpc_sysfs_xprt_dstaddr = __ATTR(dstaddr,\n\t0644, rpc_sysfs_xprt_dstaddr_show, rpc_sysfs_xprt_dstaddr_store);\n\nstatic struct kobj_attribute rpc_sysfs_xprt_srcaddr = __ATTR(srcaddr,\n\t0644, rpc_sysfs_xprt_srcaddr_show, NULL);\n\nstatic struct kobj_attribute rpc_sysfs_xprt_info = __ATTR(xprt_info,\n\t0444, rpc_sysfs_xprt_info_show, NULL);\n\nstatic struct kobj_attribute rpc_sysfs_xprt_change_state = __ATTR(xprt_state,\n\t0644, rpc_sysfs_xprt_state_show, rpc_sysfs_xprt_state_change);\n\nstatic struct attribute *rpc_sysfs_xprt_attrs[] = {\n\t&rpc_sysfs_xprt_dstaddr.attr,\n\t&rpc_sysfs_xprt_srcaddr.attr,\n\t&rpc_sysfs_xprt_info.attr,\n\t&rpc_sysfs_xprt_change_state.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(rpc_sysfs_xprt);\n\nstatic struct kobj_attribute rpc_sysfs_xprt_switch_info =\n\t__ATTR(xprt_switch_info, 0444, rpc_sysfs_xprt_switch_info_show, NULL);\n\nstatic struct attribute *rpc_sysfs_xprt_switch_attrs[] = {\n\t&rpc_sysfs_xprt_switch_info.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(rpc_sysfs_xprt_switch);\n\nstatic const struct kobj_type rpc_sysfs_client_type = {\n\t.release = rpc_sysfs_client_release,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.namespace = rpc_sysfs_client_namespace,\n};\n\nstatic const struct kobj_type rpc_sysfs_xprt_switch_type = {\n\t.release = rpc_sysfs_xprt_switch_release,\n\t.default_groups = rpc_sysfs_xprt_switch_groups,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.namespace = rpc_sysfs_xprt_switch_namespace,\n};\n\nstatic const struct kobj_type rpc_sysfs_xprt_type = {\n\t.release = rpc_sysfs_xprt_release,\n\t.default_groups = rpc_sysfs_xprt_groups,\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.namespace = rpc_sysfs_xprt_namespace,\n};\n\nvoid rpc_sysfs_exit(void)\n{\n\tkobject_put(rpc_sunrpc_client_kobj);\n\tkobject_put(rpc_sunrpc_xprt_switch_kobj);\n\tkset_unregister(rpc_sunrpc_kset);\n}\n\nstatic struct rpc_sysfs_client *rpc_sysfs_client_alloc(struct kobject *parent,\n\t\t\t\t\t\t       struct net *net,\n\t\t\t\t\t\t       int clid)\n{\n\tstruct rpc_sysfs_client *p;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p) {\n\t\tp->net = net;\n\t\tp->kobject.kset = rpc_sunrpc_kset;\n\t\tif (kobject_init_and_add(&p->kobject, &rpc_sysfs_client_type,\n\t\t\t\t\t parent, \"clnt-%d\", clid) == 0)\n\t\t\treturn p;\n\t\tkobject_put(&p->kobject);\n\t}\n\treturn NULL;\n}\n\nstatic struct rpc_sysfs_xprt_switch *\nrpc_sysfs_xprt_switch_alloc(struct kobject *parent,\n\t\t\t    struct rpc_xprt_switch *xprt_switch,\n\t\t\t    struct net *net,\n\t\t\t    gfp_t gfp_flags)\n{\n\tstruct rpc_sysfs_xprt_switch *p;\n\n\tp = kzalloc(sizeof(*p), gfp_flags);\n\tif (p) {\n\t\tp->net = net;\n\t\tp->kobject.kset = rpc_sunrpc_kset;\n\t\tif (kobject_init_and_add(&p->kobject,\n\t\t\t\t\t &rpc_sysfs_xprt_switch_type,\n\t\t\t\t\t parent, \"switch-%d\",\n\t\t\t\t\t xprt_switch->xps_id) == 0)\n\t\t\treturn p;\n\t\tkobject_put(&p->kobject);\n\t}\n\treturn NULL;\n}\n\nstatic struct rpc_sysfs_xprt *rpc_sysfs_xprt_alloc(struct kobject *parent,\n\t\t\t\t\t\t   struct rpc_xprt *xprt,\n\t\t\t\t\t\t   gfp_t gfp_flags)\n{\n\tstruct rpc_sysfs_xprt *p;\n\n\tp = kzalloc(sizeof(*p), gfp_flags);\n\tif (!p)\n\t\tgoto out;\n\tp->kobject.kset = rpc_sunrpc_kset;\n\tif (kobject_init_and_add(&p->kobject, &rpc_sysfs_xprt_type,\n\t\t\t\t parent, \"xprt-%d-%s\", xprt->id,\n\t\t\t\t xprt->address_strings[RPC_DISPLAY_PROTO]) == 0)\n\t\treturn p;\n\tkobject_put(&p->kobject);\nout:\n\treturn NULL;\n}\n\nvoid rpc_sysfs_client_setup(struct rpc_clnt *clnt,\n\t\t\t    struct rpc_xprt_switch *xprt_switch,\n\t\t\t    struct net *net)\n{\n\tstruct rpc_sysfs_client *rpc_client;\n\tstruct rpc_sysfs_xprt_switch *xswitch =\n\t\t(struct rpc_sysfs_xprt_switch *)xprt_switch->xps_sysfs;\n\n\tif (!xswitch)\n\t\treturn;\n\n\trpc_client = rpc_sysfs_client_alloc(rpc_sunrpc_client_kobj,\n\t\t\t\t\t    net, clnt->cl_clid);\n\tif (rpc_client) {\n\t\tchar name[] = \"switch\";\n\t\tint ret;\n\n\t\tclnt->cl_sysfs = rpc_client;\n\t\trpc_client->clnt = clnt;\n\t\trpc_client->xprt_switch = xprt_switch;\n\t\tkobject_uevent(&rpc_client->kobject, KOBJ_ADD);\n\t\tret = sysfs_create_link_nowarn(&rpc_client->kobject,\n\t\t\t\t\t       &xswitch->kobject, name);\n\t\tif (ret)\n\t\t\tpr_warn(\"can't create link to %s in sysfs (%d)\\n\",\n\t\t\t\tname, ret);\n\t}\n}\n\nvoid rpc_sysfs_xprt_switch_setup(struct rpc_xprt_switch *xprt_switch,\n\t\t\t\t struct rpc_xprt *xprt,\n\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct rpc_sysfs_xprt_switch *rpc_xprt_switch;\n\tstruct net *net;\n\n\tif (xprt_switch->xps_net)\n\t\tnet = xprt_switch->xps_net;\n\telse\n\t\tnet = xprt->xprt_net;\n\trpc_xprt_switch =\n\t\trpc_sysfs_xprt_switch_alloc(rpc_sunrpc_xprt_switch_kobj,\n\t\t\t\t\t    xprt_switch, net, gfp_flags);\n\tif (rpc_xprt_switch) {\n\t\txprt_switch->xps_sysfs = rpc_xprt_switch;\n\t\trpc_xprt_switch->xprt_switch = xprt_switch;\n\t\trpc_xprt_switch->xprt = xprt;\n\t\tkobject_uevent(&rpc_xprt_switch->kobject, KOBJ_ADD);\n\t} else {\n\t\txprt_switch->xps_sysfs = NULL;\n\t}\n}\n\nvoid rpc_sysfs_xprt_setup(struct rpc_xprt_switch *xprt_switch,\n\t\t\t  struct rpc_xprt *xprt,\n\t\t\t  gfp_t gfp_flags)\n{\n\tstruct rpc_sysfs_xprt *rpc_xprt;\n\tstruct rpc_sysfs_xprt_switch *switch_obj =\n\t\t(struct rpc_sysfs_xprt_switch *)xprt_switch->xps_sysfs;\n\n\tif (!switch_obj)\n\t\treturn;\n\n\trpc_xprt = rpc_sysfs_xprt_alloc(&switch_obj->kobject, xprt, gfp_flags);\n\tif (rpc_xprt) {\n\t\txprt->xprt_sysfs = rpc_xprt;\n\t\trpc_xprt->xprt = xprt;\n\t\trpc_xprt->xprt_switch = xprt_switch;\n\t\tkobject_uevent(&rpc_xprt->kobject, KOBJ_ADD);\n\t}\n}\n\nvoid rpc_sysfs_client_destroy(struct rpc_clnt *clnt)\n{\n\tstruct rpc_sysfs_client *rpc_client = clnt->cl_sysfs;\n\n\tif (rpc_client) {\n\t\tchar name[] = \"switch\";\n\n\t\tsysfs_remove_link(&rpc_client->kobject, name);\n\t\tkobject_uevent(&rpc_client->kobject, KOBJ_REMOVE);\n\t\tkobject_del(&rpc_client->kobject);\n\t\tkobject_put(&rpc_client->kobject);\n\t\tclnt->cl_sysfs = NULL;\n\t}\n}\n\nvoid rpc_sysfs_xprt_switch_destroy(struct rpc_xprt_switch *xprt_switch)\n{\n\tstruct rpc_sysfs_xprt_switch *rpc_xprt_switch = xprt_switch->xps_sysfs;\n\n\tif (rpc_xprt_switch) {\n\t\tkobject_uevent(&rpc_xprt_switch->kobject, KOBJ_REMOVE);\n\t\tkobject_del(&rpc_xprt_switch->kobject);\n\t\tkobject_put(&rpc_xprt_switch->kobject);\n\t\txprt_switch->xps_sysfs = NULL;\n\t}\n}\n\nvoid rpc_sysfs_xprt_destroy(struct rpc_xprt *xprt)\n{\n\tstruct rpc_sysfs_xprt *rpc_xprt = xprt->xprt_sysfs;\n\n\tif (rpc_xprt) {\n\t\tkobject_uevent(&rpc_xprt->kobject, KOBJ_REMOVE);\n\t\tkobject_del(&rpc_xprt->kobject);\n\t\tkobject_put(&rpc_xprt->kobject);\n\t\txprt->xprt_sysfs = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}