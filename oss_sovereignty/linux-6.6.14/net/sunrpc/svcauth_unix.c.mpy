{
  "module_name": "svcauth_unix.c",
  "hash_id": "400be8a2feaa684b8b2abc8f1e1133a6e05bccc2bdce700bc868df7c549062c2",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/svcauth_unix.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/sunrpc/types.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/svcauth.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/hash.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/kernel.h>\n#include <linux/user_namespace.h>\n#include <trace/events/sunrpc.h>\n\n#define RPCDBG_FACILITY\tRPCDBG_AUTH\n\n#include \"netns.h\"\n\n \n\n\nstruct unix_domain {\n\tstruct auth_domain\th;\n\t \n};\n\nextern struct auth_ops svcauth_null;\nextern struct auth_ops svcauth_unix;\nextern struct auth_ops svcauth_tls;\n\nstatic void svcauth_unix_domain_release_rcu(struct rcu_head *head)\n{\n\tstruct auth_domain *dom = container_of(head, struct auth_domain, rcu_head);\n\tstruct unix_domain *ud = container_of(dom, struct unix_domain, h);\n\n\tkfree(dom->name);\n\tkfree(ud);\n}\n\nstatic void svcauth_unix_domain_release(struct auth_domain *dom)\n{\n\tcall_rcu(&dom->rcu_head, svcauth_unix_domain_release_rcu);\n}\n\nstruct auth_domain *unix_domain_find(char *name)\n{\n\tstruct auth_domain *rv;\n\tstruct unix_domain *new = NULL;\n\n\trv = auth_domain_find(name);\n\twhile(1) {\n\t\tif (rv) {\n\t\t\tif (new && rv != &new->h)\n\t\t\t\tsvcauth_unix_domain_release(&new->h);\n\n\t\t\tif (rv->flavour != &svcauth_unix) {\n\t\t\t\tauth_domain_put(rv);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn rv;\n\t\t}\n\n\t\tnew = kmalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (new == NULL)\n\t\t\treturn NULL;\n\t\tkref_init(&new->h.ref);\n\t\tnew->h.name = kstrdup(name, GFP_KERNEL);\n\t\tif (new->h.name == NULL) {\n\t\t\tkfree(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew->h.flavour = &svcauth_unix;\n\t\trv = auth_domain_lookup(name, &new->h);\n\t}\n}\nEXPORT_SYMBOL_GPL(unix_domain_find);\n\n\n \n#define\tIP_HASHBITS\t8\n#define\tIP_HASHMAX\t(1<<IP_HASHBITS)\n\nstruct ip_map {\n\tstruct cache_head\th;\n\tchar\t\t\tm_class[8];  \n\tstruct in6_addr\t\tm_addr;\n\tstruct unix_domain\t*m_client;\n\tstruct rcu_head\t\tm_rcu;\n};\n\nstatic void ip_map_put(struct kref *kref)\n{\n\tstruct cache_head *item = container_of(kref, struct cache_head, ref);\n\tstruct ip_map *im = container_of(item, struct ip_map,h);\n\n\tif (test_bit(CACHE_VALID, &item->flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &item->flags))\n\t\tauth_domain_put(&im->m_client->h);\n\tkfree_rcu(im, m_rcu);\n}\n\nstatic inline int hash_ip6(const struct in6_addr *ip)\n{\n\treturn hash_32(ipv6_addr_hash(ip), IP_HASHBITS);\n}\nstatic int ip_map_match(struct cache_head *corig, struct cache_head *cnew)\n{\n\tstruct ip_map *orig = container_of(corig, struct ip_map, h);\n\tstruct ip_map *new = container_of(cnew, struct ip_map, h);\n\treturn strcmp(orig->m_class, new->m_class) == 0 &&\n\t       ipv6_addr_equal(&orig->m_addr, &new->m_addr);\n}\nstatic void ip_map_init(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct ip_map *new = container_of(cnew, struct ip_map, h);\n\tstruct ip_map *item = container_of(citem, struct ip_map, h);\n\n\tstrcpy(new->m_class, item->m_class);\n\tnew->m_addr = item->m_addr;\n}\nstatic void update(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct ip_map *new = container_of(cnew, struct ip_map, h);\n\tstruct ip_map *item = container_of(citem, struct ip_map, h);\n\n\tkref_get(&item->m_client->h.ref);\n\tnew->m_client = item->m_client;\n}\nstatic struct cache_head *ip_map_alloc(void)\n{\n\tstruct ip_map *i = kmalloc(sizeof(*i), GFP_KERNEL);\n\tif (i)\n\t\treturn &i->h;\n\telse\n\t\treturn NULL;\n}\n\nstatic int ip_map_upcall(struct cache_detail *cd, struct cache_head *h)\n{\n\treturn sunrpc_cache_pipe_upcall(cd, h);\n}\n\nstatic void ip_map_request(struct cache_detail *cd,\n\t\t\t\t  struct cache_head *h,\n\t\t\t\t  char **bpp, int *blen)\n{\n\tchar text_addr[40];\n\tstruct ip_map *im = container_of(h, struct ip_map, h);\n\n\tif (ipv6_addr_v4mapped(&(im->m_addr))) {\n\t\tsnprintf(text_addr, 20, \"%pI4\", &im->m_addr.s6_addr32[3]);\n\t} else {\n\t\tsnprintf(text_addr, 40, \"%pI6\", &im->m_addr);\n\t}\n\tqword_add(bpp, blen, im->m_class);\n\tqword_add(bpp, blen, text_addr);\n\t(*bpp)[-1] = '\\n';\n}\n\nstatic struct ip_map *__ip_map_lookup(struct cache_detail *cd, char *class, struct in6_addr *addr);\nstatic int __ip_map_update(struct cache_detail *cd, struct ip_map *ipm, struct unix_domain *udom, time64_t expiry);\n\nstatic int ip_map_parse(struct cache_detail *cd,\n\t\t\t  char *mesg, int mlen)\n{\n\t \n\t \n\tchar *buf = mesg;\n\tint len;\n\tchar class[8];\n\tunion {\n\t\tstruct sockaddr\t\tsa;\n\t\tstruct sockaddr_in\ts4;\n\t\tstruct sockaddr_in6\ts6;\n\t} address;\n\tstruct sockaddr_in6 sin6;\n\tint err;\n\n\tstruct ip_map *ipmp;\n\tstruct auth_domain *dom;\n\ttime64_t expiry;\n\n\tif (mesg[mlen-1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\t \n\tlen = qword_get(&mesg, class, sizeof(class));\n\tif (len <= 0) return -EINVAL;\n\n\t \n\tlen = qword_get(&mesg, buf, mlen);\n\tif (len <= 0) return -EINVAL;\n\n\tif (rpc_pton(cd->net, buf, len, &address.sa, sizeof(address)) == 0)\n\t\treturn -EINVAL;\n\tswitch (address.sa.sa_family) {\n\tcase AF_INET:\n\t\t \n\t\tsin6.sin6_family = AF_INET6;\n\t\tipv6_addr_set_v4mapped(address.s4.sin_addr.s_addr,\n\t\t\t\t&sin6.sin6_addr);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tmemcpy(&sin6, &address.s6, sizeof(sin6));\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = get_expiry(&mesg, &expiry);\n\tif (err)\n\t\treturn err;\n\n\t \n\tlen = qword_get(&mesg, buf, mlen);\n\tif (len < 0) return -EINVAL;\n\n\tif (len) {\n\t\tdom = unix_domain_find(buf);\n\t\tif (dom == NULL)\n\t\t\treturn -ENOENT;\n\t} else\n\t\tdom = NULL;\n\n\t \n\tipmp = __ip_map_lookup(cd, class, &sin6.sin6_addr);\n\tif (ipmp) {\n\t\terr = __ip_map_update(cd, ipmp,\n\t\t\t     container_of(dom, struct unix_domain, h),\n\t\t\t     expiry);\n\t} else\n\t\terr = -ENOMEM;\n\n\tif (dom)\n\t\tauth_domain_put(dom);\n\n\tcache_flush();\n\treturn err;\n}\n\nstatic int ip_map_show(struct seq_file *m,\n\t\t       struct cache_detail *cd,\n\t\t       struct cache_head *h)\n{\n\tstruct ip_map *im;\n\tstruct in6_addr addr;\n\tchar *dom = \"-no-domain-\";\n\n\tif (h == NULL) {\n\t\tseq_puts(m, \"#class IP domain\\n\");\n\t\treturn 0;\n\t}\n\tim = container_of(h, struct ip_map, h);\n\t \n\taddr = im->m_addr;\n\n\tif (test_bit(CACHE_VALID, &h->flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &h->flags))\n\t\tdom = im->m_client->h.name;\n\n\tif (ipv6_addr_v4mapped(&addr)) {\n\t\tseq_printf(m, \"%s %pI4 %s\\n\",\n\t\t\tim->m_class, &addr.s6_addr32[3], dom);\n\t} else {\n\t\tseq_printf(m, \"%s %pI6 %s\\n\", im->m_class, &addr, dom);\n\t}\n\treturn 0;\n}\n\n\nstatic struct ip_map *__ip_map_lookup(struct cache_detail *cd, char *class,\n\t\tstruct in6_addr *addr)\n{\n\tstruct ip_map ip;\n\tstruct cache_head *ch;\n\n\tstrcpy(ip.m_class, class);\n\tip.m_addr = *addr;\n\tch = sunrpc_cache_lookup_rcu(cd, &ip.h,\n\t\t\t\t     hash_str(class, IP_HASHBITS) ^\n\t\t\t\t     hash_ip6(addr));\n\n\tif (ch)\n\t\treturn container_of(ch, struct ip_map, h);\n\telse\n\t\treturn NULL;\n}\n\nstatic int __ip_map_update(struct cache_detail *cd, struct ip_map *ipm,\n\t\tstruct unix_domain *udom, time64_t expiry)\n{\n\tstruct ip_map ip;\n\tstruct cache_head *ch;\n\n\tip.m_client = udom;\n\tip.h.flags = 0;\n\tif (!udom)\n\t\tset_bit(CACHE_NEGATIVE, &ip.h.flags);\n\tip.h.expiry_time = expiry;\n\tch = sunrpc_cache_update(cd, &ip.h, &ipm->h,\n\t\t\t\t hash_str(ipm->m_class, IP_HASHBITS) ^\n\t\t\t\t hash_ip6(&ipm->m_addr));\n\tif (!ch)\n\t\treturn -ENOMEM;\n\tcache_put(ch, cd);\n\treturn 0;\n}\n\nvoid svcauth_unix_purge(struct net *net)\n{\n\tstruct sunrpc_net *sn;\n\n\tsn = net_generic(net, sunrpc_net_id);\n\tcache_purge(sn->ip_map_cache);\n}\nEXPORT_SYMBOL_GPL(svcauth_unix_purge);\n\nstatic inline struct ip_map *\nip_map_cached_get(struct svc_xprt *xprt)\n{\n\tstruct ip_map *ipm = NULL;\n\tstruct sunrpc_net *sn;\n\n\tif (test_bit(XPT_CACHE_AUTH, &xprt->xpt_flags)) {\n\t\tspin_lock(&xprt->xpt_lock);\n\t\tipm = xprt->xpt_auth_cache;\n\t\tif (ipm != NULL) {\n\t\t\tsn = net_generic(xprt->xpt_net, sunrpc_net_id);\n\t\t\tif (cache_is_expired(sn->ip_map_cache, &ipm->h)) {\n\t\t\t\t \n\t\t\t\txprt->xpt_auth_cache = NULL;\n\t\t\t\tspin_unlock(&xprt->xpt_lock);\n\t\t\t\tcache_put(&ipm->h, sn->ip_map_cache);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcache_get(&ipm->h);\n\t\t}\n\t\tspin_unlock(&xprt->xpt_lock);\n\t}\n\treturn ipm;\n}\n\nstatic inline void\nip_map_cached_put(struct svc_xprt *xprt, struct ip_map *ipm)\n{\n\tif (test_bit(XPT_CACHE_AUTH, &xprt->xpt_flags)) {\n\t\tspin_lock(&xprt->xpt_lock);\n\t\tif (xprt->xpt_auth_cache == NULL) {\n\t\t\t \n\t\t\txprt->xpt_auth_cache = ipm;\n\t\t\tipm = NULL;\n\t\t}\n\t\tspin_unlock(&xprt->xpt_lock);\n\t}\n\tif (ipm) {\n\t\tstruct sunrpc_net *sn;\n\n\t\tsn = net_generic(xprt->xpt_net, sunrpc_net_id);\n\t\tcache_put(&ipm->h, sn->ip_map_cache);\n\t}\n}\n\nvoid\nsvcauth_unix_info_release(struct svc_xprt *xpt)\n{\n\tstruct ip_map *ipm;\n\n\tipm = xpt->xpt_auth_cache;\n\tif (ipm != NULL) {\n\t\tstruct sunrpc_net *sn;\n\n\t\tsn = net_generic(xpt->xpt_net, sunrpc_net_id);\n\t\tcache_put(&ipm->h, sn->ip_map_cache);\n\t}\n}\n\n \n#define\tGID_HASHBITS\t8\n#define\tGID_HASHMAX\t(1<<GID_HASHBITS)\n\nstruct unix_gid {\n\tstruct cache_head\th;\n\tkuid_t\t\t\tuid;\n\tstruct group_info\t*gi;\n\tstruct rcu_head\t\trcu;\n};\n\nstatic int unix_gid_hash(kuid_t uid)\n{\n\treturn hash_long(from_kuid(&init_user_ns, uid), GID_HASHBITS);\n}\n\nstatic void unix_gid_free(struct rcu_head *rcu)\n{\n\tstruct unix_gid *ug = container_of(rcu, struct unix_gid, rcu);\n\tstruct cache_head *item = &ug->h;\n\n\tif (test_bit(CACHE_VALID, &item->flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &item->flags))\n\t\tput_group_info(ug->gi);\n\tkfree(ug);\n}\n\nstatic void unix_gid_put(struct kref *kref)\n{\n\tstruct cache_head *item = container_of(kref, struct cache_head, ref);\n\tstruct unix_gid *ug = container_of(item, struct unix_gid, h);\n\n\tcall_rcu(&ug->rcu, unix_gid_free);\n}\n\nstatic int unix_gid_match(struct cache_head *corig, struct cache_head *cnew)\n{\n\tstruct unix_gid *orig = container_of(corig, struct unix_gid, h);\n\tstruct unix_gid *new = container_of(cnew, struct unix_gid, h);\n\treturn uid_eq(orig->uid, new->uid);\n}\nstatic void unix_gid_init(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct unix_gid *new = container_of(cnew, struct unix_gid, h);\n\tstruct unix_gid *item = container_of(citem, struct unix_gid, h);\n\tnew->uid = item->uid;\n}\nstatic void unix_gid_update(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct unix_gid *new = container_of(cnew, struct unix_gid, h);\n\tstruct unix_gid *item = container_of(citem, struct unix_gid, h);\n\n\tget_group_info(item->gi);\n\tnew->gi = item->gi;\n}\nstatic struct cache_head *unix_gid_alloc(void)\n{\n\tstruct unix_gid *g = kmalloc(sizeof(*g), GFP_KERNEL);\n\tif (g)\n\t\treturn &g->h;\n\telse\n\t\treturn NULL;\n}\n\nstatic int unix_gid_upcall(struct cache_detail *cd, struct cache_head *h)\n{\n\treturn sunrpc_cache_pipe_upcall_timeout(cd, h);\n}\n\nstatic void unix_gid_request(struct cache_detail *cd,\n\t\t\t     struct cache_head *h,\n\t\t\t     char **bpp, int *blen)\n{\n\tchar tuid[20];\n\tstruct unix_gid *ug = container_of(h, struct unix_gid, h);\n\n\tsnprintf(tuid, 20, \"%u\", from_kuid(&init_user_ns, ug->uid));\n\tqword_add(bpp, blen, tuid);\n\t(*bpp)[-1] = '\\n';\n}\n\nstatic struct unix_gid *unix_gid_lookup(struct cache_detail *cd, kuid_t uid);\n\nstatic int unix_gid_parse(struct cache_detail *cd,\n\t\t\tchar *mesg, int mlen)\n{\n\t \n\tint id;\n\tkuid_t uid;\n\tint gids;\n\tint rv;\n\tint i;\n\tint err;\n\ttime64_t expiry;\n\tstruct unix_gid ug, *ugp;\n\n\tif (mesg[mlen - 1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\trv = get_int(&mesg, &id);\n\tif (rv)\n\t\treturn -EINVAL;\n\tuid = make_kuid(current_user_ns(), id);\n\tug.uid = uid;\n\n\terr = get_expiry(&mesg, &expiry);\n\tif (err)\n\t\treturn err;\n\n\trv = get_int(&mesg, &gids);\n\tif (rv || gids < 0 || gids > 8192)\n\t\treturn -EINVAL;\n\n\tug.gi = groups_alloc(gids);\n\tif (!ug.gi)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0 ; i < gids ; i++) {\n\t\tint gid;\n\t\tkgid_t kgid;\n\t\trv = get_int(&mesg, &gid);\n\t\terr = -EINVAL;\n\t\tif (rv)\n\t\t\tgoto out;\n\t\tkgid = make_kgid(current_user_ns(), gid);\n\t\tif (!gid_valid(kgid))\n\t\t\tgoto out;\n\t\tug.gi->gid[i] = kgid;\n\t}\n\n\tgroups_sort(ug.gi);\n\tugp = unix_gid_lookup(cd, uid);\n\tif (ugp) {\n\t\tstruct cache_head *ch;\n\t\tug.h.flags = 0;\n\t\tug.h.expiry_time = expiry;\n\t\tch = sunrpc_cache_update(cd,\n\t\t\t\t\t &ug.h, &ugp->h,\n\t\t\t\t\t unix_gid_hash(uid));\n\t\tif (!ch)\n\t\t\terr = -ENOMEM;\n\t\telse {\n\t\t\terr = 0;\n\t\t\tcache_put(ch, cd);\n\t\t}\n\t} else\n\t\terr = -ENOMEM;\n out:\n\tif (ug.gi)\n\t\tput_group_info(ug.gi);\n\treturn err;\n}\n\nstatic int unix_gid_show(struct seq_file *m,\n\t\t\t struct cache_detail *cd,\n\t\t\t struct cache_head *h)\n{\n\tstruct user_namespace *user_ns = m->file->f_cred->user_ns;\n\tstruct unix_gid *ug;\n\tint i;\n\tint glen;\n\n\tif (h == NULL) {\n\t\tseq_puts(m, \"#uid cnt: gids...\\n\");\n\t\treturn 0;\n\t}\n\tug = container_of(h, struct unix_gid, h);\n\tif (test_bit(CACHE_VALID, &h->flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &h->flags))\n\t\tglen = ug->gi->ngroups;\n\telse\n\t\tglen = 0;\n\n\tseq_printf(m, \"%u %d:\", from_kuid_munged(user_ns, ug->uid), glen);\n\tfor (i = 0; i < glen; i++)\n\t\tseq_printf(m, \" %d\", from_kgid_munged(user_ns, ug->gi->gid[i]));\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}\n\nstatic const struct cache_detail unix_gid_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= GID_HASHMAX,\n\t.name\t\t= \"auth.unix.gid\",\n\t.cache_put\t= unix_gid_put,\n\t.cache_upcall\t= unix_gid_upcall,\n\t.cache_request\t= unix_gid_request,\n\t.cache_parse\t= unix_gid_parse,\n\t.cache_show\t= unix_gid_show,\n\t.match\t\t= unix_gid_match,\n\t.init\t\t= unix_gid_init,\n\t.update\t\t= unix_gid_update,\n\t.alloc\t\t= unix_gid_alloc,\n};\n\nint unix_gid_cache_create(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct cache_detail *cd;\n\tint err;\n\n\tcd = cache_create_net(&unix_gid_cache_template, net);\n\tif (IS_ERR(cd))\n\t\treturn PTR_ERR(cd);\n\terr = cache_register_net(cd, net);\n\tif (err) {\n\t\tcache_destroy_net(cd, net);\n\t\treturn err;\n\t}\n\tsn->unix_gid_cache = cd;\n\treturn 0;\n}\n\nvoid unix_gid_cache_destroy(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct cache_detail *cd = sn->unix_gid_cache;\n\n\tsn->unix_gid_cache = NULL;\n\tcache_purge(cd);\n\tcache_unregister_net(cd, net);\n\tcache_destroy_net(cd, net);\n}\n\nstatic struct unix_gid *unix_gid_lookup(struct cache_detail *cd, kuid_t uid)\n{\n\tstruct unix_gid ug;\n\tstruct cache_head *ch;\n\n\tug.uid = uid;\n\tch = sunrpc_cache_lookup_rcu(cd, &ug.h, unix_gid_hash(uid));\n\tif (ch)\n\t\treturn container_of(ch, struct unix_gid, h);\n\telse\n\t\treturn NULL;\n}\n\nstatic struct group_info *unix_gid_find(kuid_t uid, struct svc_rqst *rqstp)\n{\n\tstruct unix_gid *ug;\n\tstruct group_info *gi;\n\tint ret;\n\tstruct sunrpc_net *sn = net_generic(rqstp->rq_xprt->xpt_net,\n\t\t\t\t\t    sunrpc_net_id);\n\n\tug = unix_gid_lookup(sn->unix_gid_cache, uid);\n\tif (!ug)\n\t\treturn ERR_PTR(-EAGAIN);\n\tret = cache_check(sn->unix_gid_cache, &ug->h, &rqstp->rq_chandle);\n\tswitch (ret) {\n\tcase -ENOENT:\n\t\treturn ERR_PTR(-ENOENT);\n\tcase -ETIMEDOUT:\n\t\treturn ERR_PTR(-ESHUTDOWN);\n\tcase 0:\n\t\tgi = get_group_info(ug->gi);\n\t\tcache_put(&ug->h, sn->unix_gid_cache);\n\t\treturn gi;\n\tdefault:\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n}\n\nenum svc_auth_status\nsvcauth_unix_set_client(struct svc_rqst *rqstp)\n{\n\tstruct sockaddr_in *sin;\n\tstruct sockaddr_in6 *sin6, sin6_storage;\n\tstruct ip_map *ipm;\n\tstruct group_info *gi;\n\tstruct svc_cred *cred = &rqstp->rq_cred;\n\tstruct svc_xprt *xprt = rqstp->rq_xprt;\n\tstruct net *net = xprt->xpt_net;\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\n\tswitch (rqstp->rq_addr.ss_family) {\n\tcase AF_INET:\n\t\tsin = svc_addr_in(rqstp);\n\t\tsin6 = &sin6_storage;\n\t\tipv6_addr_set_v4mapped(sin->sin_addr.s_addr, &sin6->sin6_addr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsin6 = svc_addr_in6(rqstp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\trqstp->rq_client = NULL;\n\tif (rqstp->rq_proc == 0)\n\t\tgoto out;\n\n\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\tipm = ip_map_cached_get(xprt);\n\tif (ipm == NULL)\n\t\tipm = __ip_map_lookup(sn->ip_map_cache, rqstp->rq_server->sv_program->pg_class,\n\t\t\t\t    &sin6->sin6_addr);\n\n\tif (ipm == NULL)\n\t\treturn SVC_DENIED;\n\n\tswitch (cache_check(sn->ip_map_cache, &ipm->h, &rqstp->rq_chandle)) {\n\t\tdefault:\n\t\t\tBUG();\n\t\tcase -ETIMEDOUT:\n\t\t\treturn SVC_CLOSE;\n\t\tcase -EAGAIN:\n\t\t\treturn SVC_DROP;\n\t\tcase -ENOENT:\n\t\t\treturn SVC_DENIED;\n\t\tcase 0:\n\t\t\trqstp->rq_client = &ipm->m_client->h;\n\t\t\tkref_get(&rqstp->rq_client->ref);\n\t\t\tip_map_cached_put(xprt, ipm);\n\t\t\tbreak;\n\t}\n\n\tgi = unix_gid_find(cred->cr_uid, rqstp);\n\tswitch (PTR_ERR(gi)) {\n\tcase -EAGAIN:\n\t\treturn SVC_DROP;\n\tcase -ESHUTDOWN:\n\t\treturn SVC_CLOSE;\n\tcase -ENOENT:\n\t\tbreak;\n\tdefault:\n\t\tput_group_info(cred->cr_group_info);\n\t\tcred->cr_group_info = gi;\n\t}\n\nout:\n\trqstp->rq_auth_stat = rpc_auth_ok;\n\treturn SVC_OK;\n}\nEXPORT_SYMBOL_GPL(svcauth_unix_set_client);\n\n \nstatic enum svc_auth_status\nsvcauth_null_accept(struct svc_rqst *rqstp)\n{\n\tstruct xdr_stream *xdr = &rqstp->rq_arg_stream;\n\tstruct svc_cred\t*cred = &rqstp->rq_cred;\n\tu32 flavor, len;\n\tvoid *body;\n\n\t \n\tif (xdr_stream_decode_u32(xdr, &len) < 0)\n\t\treturn SVC_GARBAGE;\n\tif (len != 0) {\n\t\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\t\treturn SVC_DENIED;\n\t}\n\n\t \n\tif (xdr_stream_decode_opaque_auth(xdr, &flavor, &body, &len) < 0)\n\t\treturn SVC_GARBAGE;\n\tif (flavor != RPC_AUTH_NULL || len != 0) {\n\t\trqstp->rq_auth_stat = rpc_autherr_badverf;\n\t\treturn SVC_DENIED;\n\t}\n\n\t \n\tcred->cr_uid = INVALID_UID;\n\tcred->cr_gid = INVALID_GID;\n\tcred->cr_group_info = groups_alloc(0);\n\tif (cred->cr_group_info == NULL)\n\t\treturn SVC_CLOSE;  \n\n\tif (xdr_stream_encode_opaque_auth(&rqstp->rq_res_stream,\n\t\t\t\t\t  RPC_AUTH_NULL, NULL, 0) < 0)\n\t\treturn SVC_CLOSE;\n\tif (!svcxdr_set_accept_stat(rqstp))\n\t\treturn SVC_CLOSE;\n\n\trqstp->rq_cred.cr_flavor = RPC_AUTH_NULL;\n\treturn SVC_OK;\n}\n\nstatic int\nsvcauth_null_release(struct svc_rqst *rqstp)\n{\n\tif (rqstp->rq_client)\n\t\tauth_domain_put(rqstp->rq_client);\n\trqstp->rq_client = NULL;\n\tif (rqstp->rq_cred.cr_group_info)\n\t\tput_group_info(rqstp->rq_cred.cr_group_info);\n\trqstp->rq_cred.cr_group_info = NULL;\n\n\treturn 0;  \n}\n\n\nstruct auth_ops svcauth_null = {\n\t.name\t\t= \"null\",\n\t.owner\t\t= THIS_MODULE,\n\t.flavour\t= RPC_AUTH_NULL,\n\t.accept\t\t= svcauth_null_accept,\n\t.release\t= svcauth_null_release,\n\t.set_client\t= svcauth_unix_set_client,\n};\n\n\n \nstatic enum svc_auth_status\nsvcauth_tls_accept(struct svc_rqst *rqstp)\n{\n\tstruct xdr_stream *xdr = &rqstp->rq_arg_stream;\n\tstruct svc_cred\t*cred = &rqstp->rq_cred;\n\tstruct svc_xprt *xprt = rqstp->rq_xprt;\n\tu32 flavor, len;\n\tvoid *body;\n\t__be32 *p;\n\n\t \n\tif (xdr_stream_decode_u32(xdr, &len) < 0)\n\t\treturn SVC_GARBAGE;\n\tif (len != 0) {\n\t\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\t\treturn SVC_DENIED;\n\t}\n\n\t \n\tif (xdr_stream_decode_opaque_auth(xdr, &flavor, &body, &len) < 0)\n\t\treturn SVC_GARBAGE;\n\tif (flavor != RPC_AUTH_NULL || len != 0) {\n\t\trqstp->rq_auth_stat = rpc_autherr_badverf;\n\t\treturn SVC_DENIED;\n\t}\n\n\t \n\tif (rqstp->rq_proc != 0) {\n\t\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\t\treturn SVC_DENIED;\n\t}\n\n\t \n\tcred->cr_uid = INVALID_UID;\n\tcred->cr_gid = INVALID_GID;\n\tcred->cr_group_info = groups_alloc(0);\n\tif (cred->cr_group_info == NULL)\n\t\treturn SVC_CLOSE;\n\n\tif (xprt->xpt_ops->xpo_handshake) {\n\t\tp = xdr_reserve_space(&rqstp->rq_res_stream, XDR_UNIT * 2 + 8);\n\t\tif (!p)\n\t\t\treturn SVC_CLOSE;\n\t\ttrace_svc_tls_start(xprt);\n\t\t*p++ = rpc_auth_null;\n\t\t*p++ = cpu_to_be32(8);\n\t\tmemcpy(p, \"STARTTLS\", 8);\n\n\t\tset_bit(XPT_HANDSHAKE, &xprt->xpt_flags);\n\t\tsvc_xprt_enqueue(xprt);\n\t} else {\n\t\ttrace_svc_tls_unavailable(xprt);\n\t\tif (xdr_stream_encode_opaque_auth(&rqstp->rq_res_stream,\n\t\t\t\t\t\t  RPC_AUTH_NULL, NULL, 0) < 0)\n\t\t\treturn SVC_CLOSE;\n\t}\n\tif (!svcxdr_set_accept_stat(rqstp))\n\t\treturn SVC_CLOSE;\n\n\trqstp->rq_cred.cr_flavor = RPC_AUTH_TLS;\n\treturn SVC_OK;\n}\n\nstruct auth_ops svcauth_tls = {\n\t.name\t\t= \"tls\",\n\t.owner\t\t= THIS_MODULE,\n\t.flavour\t= RPC_AUTH_TLS,\n\t.accept\t\t= svcauth_tls_accept,\n\t.release\t= svcauth_null_release,\n\t.set_client\t= svcauth_unix_set_client,\n};\n\n\n \nstatic enum svc_auth_status\nsvcauth_unix_accept(struct svc_rqst *rqstp)\n{\n\tstruct xdr_stream *xdr = &rqstp->rq_arg_stream;\n\tstruct svc_cred\t*cred = &rqstp->rq_cred;\n\tstruct user_namespace *userns;\n\tu32 flavor, len, i;\n\tvoid *body;\n\t__be32 *p;\n\n\t \n\tp = xdr_inline_decode(xdr, XDR_UNIT * 3);\n\tif (!p)\n\t\treturn SVC_GARBAGE;\n\tlen = be32_to_cpup(p + 2);\n\tif (len > RPC_MAX_MACHINENAME)\n\t\treturn SVC_GARBAGE;\n\tif (!xdr_inline_decode(xdr, len))\n\t\treturn SVC_GARBAGE;\n\n\t \n\tuserns = (rqstp->rq_xprt && rqstp->rq_xprt->xpt_cred) ?\n\t\trqstp->rq_xprt->xpt_cred->user_ns : &init_user_ns;\n\tif (xdr_stream_decode_u32(xdr, &i) < 0)\n\t\treturn SVC_GARBAGE;\n\tcred->cr_uid = make_kuid(userns, i);\n\tif (xdr_stream_decode_u32(xdr, &i) < 0)\n\t\treturn SVC_GARBAGE;\n\tcred->cr_gid = make_kgid(userns, i);\n\n\tif (xdr_stream_decode_u32(xdr, &len) < 0)\n\t\treturn SVC_GARBAGE;\n\tif (len > UNX_NGROUPS)\n\t\tgoto badcred;\n\tp = xdr_inline_decode(xdr, XDR_UNIT * len);\n\tif (!p)\n\t\treturn SVC_GARBAGE;\n\tcred->cr_group_info = groups_alloc(len);\n\tif (cred->cr_group_info == NULL)\n\t\treturn SVC_CLOSE;\n\tfor (i = 0; i < len; i++) {\n\t\tkgid_t kgid = make_kgid(userns, be32_to_cpup(p++));\n\t\tcred->cr_group_info->gid[i] = kgid;\n\t}\n\tgroups_sort(cred->cr_group_info);\n\n\t \n\tif (xdr_stream_decode_opaque_auth(xdr, &flavor, &body, &len) < 0)\n\t\treturn SVC_GARBAGE;\n\tif (flavor != RPC_AUTH_NULL || len != 0) {\n\t\trqstp->rq_auth_stat = rpc_autherr_badverf;\n\t\treturn SVC_DENIED;\n\t}\n\n\tif (xdr_stream_encode_opaque_auth(&rqstp->rq_res_stream,\n\t\t\t\t\t  RPC_AUTH_NULL, NULL, 0) < 0)\n\t\treturn SVC_CLOSE;\n\tif (!svcxdr_set_accept_stat(rqstp))\n\t\treturn SVC_CLOSE;\n\n\trqstp->rq_cred.cr_flavor = RPC_AUTH_UNIX;\n\treturn SVC_OK;\n\nbadcred:\n\trqstp->rq_auth_stat = rpc_autherr_badcred;\n\treturn SVC_DENIED;\n}\n\nstatic int\nsvcauth_unix_release(struct svc_rqst *rqstp)\n{\n\t \n\tif (rqstp->rq_client)\n\t\tauth_domain_put(rqstp->rq_client);\n\trqstp->rq_client = NULL;\n\tif (rqstp->rq_cred.cr_group_info)\n\t\tput_group_info(rqstp->rq_cred.cr_group_info);\n\trqstp->rq_cred.cr_group_info = NULL;\n\n\treturn 0;\n}\n\n\nstruct auth_ops svcauth_unix = {\n\t.name\t\t= \"unix\",\n\t.owner\t\t= THIS_MODULE,\n\t.flavour\t= RPC_AUTH_UNIX,\n\t.accept\t\t= svcauth_unix_accept,\n\t.release\t= svcauth_unix_release,\n\t.domain_release\t= svcauth_unix_domain_release,\n\t.set_client\t= svcauth_unix_set_client,\n};\n\nstatic const struct cache_detail ip_map_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= IP_HASHMAX,\n\t.name\t\t= \"auth.unix.ip\",\n\t.cache_put\t= ip_map_put,\n\t.cache_upcall\t= ip_map_upcall,\n\t.cache_request\t= ip_map_request,\n\t.cache_parse\t= ip_map_parse,\n\t.cache_show\t= ip_map_show,\n\t.match\t\t= ip_map_match,\n\t.init\t\t= ip_map_init,\n\t.update\t\t= update,\n\t.alloc\t\t= ip_map_alloc,\n};\n\nint ip_map_cache_create(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct cache_detail *cd;\n\tint err;\n\n\tcd = cache_create_net(&ip_map_cache_template, net);\n\tif (IS_ERR(cd))\n\t\treturn PTR_ERR(cd);\n\terr = cache_register_net(cd, net);\n\tif (err) {\n\t\tcache_destroy_net(cd, net);\n\t\treturn err;\n\t}\n\tsn->ip_map_cache = cd;\n\treturn 0;\n}\n\nvoid ip_map_cache_destroy(struct net *net)\n{\n\tstruct sunrpc_net *sn = net_generic(net, sunrpc_net_id);\n\tstruct cache_detail *cd = sn->ip_map_cache;\n\n\tsn->ip_map_cache = NULL;\n\tcache_purge(cd);\n\tcache_unregister_net(cd, net);\n\tcache_destroy_net(cd, net);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}