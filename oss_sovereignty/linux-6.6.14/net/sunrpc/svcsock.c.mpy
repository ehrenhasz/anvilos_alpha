{
  "module_name": "svcsock.c",
  "hash_id": "3846ee5481278a3f675b42cb8f268a53b4f0778bc37f310163a548ccacfe9ff9",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/svcsock.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/unistd.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/file.h>\n#include <linux/freezer.h>\n#include <linux/bvec.h>\n\n#include <net/sock.h>\n#include <net/checksum.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/udp.h>\n#include <net/tcp.h>\n#include <net/tcp_states.h>\n#include <net/tls_prot.h>\n#include <net/handshake.h>\n#include <linux/uaccess.h>\n#include <linux/highmem.h>\n#include <asm/ioctls.h>\n#include <linux/key.h>\n\n#include <linux/sunrpc/types.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/xprt.h>\n\n#include <trace/events/sock.h>\n#include <trace/events/sunrpc.h>\n\n#include \"socklib.h\"\n#include \"sunrpc.h\"\n\n#define RPCDBG_FACILITY\tRPCDBG_SVCXPRT\n\n \nenum {\n\tSVC_HANDSHAKE_TO\t= 5U * HZ\n};\n\nstatic struct svc_sock *svc_setup_socket(struct svc_serv *, struct socket *,\n\t\t\t\t\t int flags);\nstatic int\t\tsvc_udp_recvfrom(struct svc_rqst *);\nstatic int\t\tsvc_udp_sendto(struct svc_rqst *);\nstatic void\t\tsvc_sock_detach(struct svc_xprt *);\nstatic void\t\tsvc_tcp_sock_detach(struct svc_xprt *);\nstatic void\t\tsvc_sock_free(struct svc_xprt *);\n\nstatic struct svc_xprt *svc_create_socket(struct svc_serv *, int,\n\t\t\t\t\t  struct net *, struct sockaddr *,\n\t\t\t\t\t  int, int);\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key svc_key[2];\nstatic struct lock_class_key svc_slock_key[2];\n\nstatic void svc_reclassify_socket(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (WARN_ON_ONCE(!sock_allow_reclassification(sk)))\n\t\treturn;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-NFSD\",\n\t\t\t\t\t      &svc_slock_key[0],\n\t\t\t\t\t      \"sk_xprt.xpt_lock-AF_INET-NFSD\",\n\t\t\t\t\t      &svc_key[0]);\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-NFSD\",\n\t\t\t\t\t      &svc_slock_key[1],\n\t\t\t\t\t      \"sk_xprt.xpt_lock-AF_INET6-NFSD\",\n\t\t\t\t\t      &svc_key[1]);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n}\n#else\nstatic void svc_reclassify_socket(struct socket *sock)\n{\n}\n#endif\n\n \nstatic void svc_tcp_release_ctxt(struct svc_xprt *xprt, void *ctxt)\n{\n}\n\n \nstatic void svc_udp_release_ctxt(struct svc_xprt *xprt, void *ctxt)\n{\n\tstruct sk_buff *skb = ctxt;\n\n\tif (skb)\n\t\tconsume_skb(skb);\n}\n\nunion svc_pktinfo_u {\n\tstruct in_pktinfo pkti;\n\tstruct in6_pktinfo pkti6;\n};\n#define SVC_PKTINFO_SPACE \\\n\tCMSG_SPACE(sizeof(union svc_pktinfo_u))\n\nstatic void svc_set_cmsg_data(struct svc_rqst *rqstp, struct cmsghdr *cmh)\n{\n\tstruct svc_sock *svsk =\n\t\tcontainer_of(rqstp->rq_xprt, struct svc_sock, sk_xprt);\n\tswitch (svsk->sk_sk->sk_family) {\n\tcase AF_INET: {\n\t\t\tstruct in_pktinfo *pki = CMSG_DATA(cmh);\n\n\t\t\tcmh->cmsg_level = SOL_IP;\n\t\t\tcmh->cmsg_type = IP_PKTINFO;\n\t\t\tpki->ipi_ifindex = 0;\n\t\t\tpki->ipi_spec_dst.s_addr =\n\t\t\t\t svc_daddr_in(rqstp)->sin_addr.s_addr;\n\t\t\tcmh->cmsg_len = CMSG_LEN(sizeof(*pki));\n\t\t}\n\t\tbreak;\n\n\tcase AF_INET6: {\n\t\t\tstruct in6_pktinfo *pki = CMSG_DATA(cmh);\n\t\t\tstruct sockaddr_in6 *daddr = svc_daddr_in6(rqstp);\n\n\t\t\tcmh->cmsg_level = SOL_IPV6;\n\t\t\tcmh->cmsg_type = IPV6_PKTINFO;\n\t\t\tpki->ipi6_ifindex = daddr->sin6_scope_id;\n\t\t\tpki->ipi6_addr = daddr->sin6_addr;\n\t\t\tcmh->cmsg_len = CMSG_LEN(sizeof(*pki));\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int svc_sock_result_payload(struct svc_rqst *rqstp, unsigned int offset,\n\t\t\t\t   unsigned int length)\n{\n\treturn 0;\n}\n\n \nstatic int svc_one_sock_name(struct svc_sock *svsk, char *buf, int remaining)\n{\n\tconst struct sock *sk = svsk->sk_sk;\n\tconst char *proto_name = sk->sk_protocol == IPPROTO_UDP ?\n\t\t\t\t\t\t\t\"udp\" : \"tcp\";\n\tint len;\n\n\tswitch (sk->sk_family) {\n\tcase PF_INET:\n\t\tlen = snprintf(buf, remaining, \"ipv4 %s %pI4 %d\\n\",\n\t\t\t\tproto_name,\n\t\t\t\t&inet_sk(sk)->inet_rcv_saddr,\n\t\t\t\tinet_sk(sk)->inet_num);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase PF_INET6:\n\t\tlen = snprintf(buf, remaining, \"ipv6 %s %pI6 %d\\n\",\n\t\t\t\tproto_name,\n\t\t\t\t&sk->sk_v6_rcv_saddr,\n\t\t\t\tinet_sk(sk)->inet_num);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tlen = snprintf(buf, remaining, \"*unknown-%d*\\n\",\n\t\t\t\tsk->sk_family);\n\t}\n\n\tif (len >= remaining) {\n\t\t*buf = '\\0';\n\t\treturn -ENAMETOOLONG;\n\t}\n\treturn len;\n}\n\nstatic int\nsvc_tcp_sock_process_cmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t  struct cmsghdr *cmsg, int ret)\n{\n\tu8 content_type = tls_get_record_type(sock->sk, cmsg);\n\tu8 level, description;\n\n\tswitch (content_type) {\n\tcase 0:\n\t\tbreak;\n\tcase TLS_RECORD_TYPE_DATA:\n\t\t \n\t\tmsg->msg_flags &= ~MSG_EOR;\n\t\tbreak;\n\tcase TLS_RECORD_TYPE_ALERT:\n\t\ttls_alert_recv(sock->sk, msg, &level, &description);\n\t\tret = (level == TLS_ALERT_LEVEL_FATAL) ?\n\t\t\t-ENOTCONN : -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret = -EAGAIN;\n\t}\n\treturn ret;\n}\n\nstatic int\nsvc_tcp_sock_recv_cmsg(struct svc_sock *svsk, struct msghdr *msg)\n{\n\tunion {\n\t\tstruct cmsghdr\tcmsg;\n\t\tu8\t\tbuf[CMSG_SPACE(sizeof(u8))];\n\t} u;\n\tstruct socket *sock = svsk->sk_sock;\n\tint ret;\n\n\tmsg->msg_control = &u;\n\tmsg->msg_controllen = sizeof(u);\n\tret = sock_recvmsg(sock, msg, MSG_DONTWAIT);\n\tif (unlikely(msg->msg_controllen != sizeof(u)))\n\t\tret = svc_tcp_sock_process_cmsg(sock, msg, &u.cmsg, ret);\n\treturn ret;\n}\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE\nstatic void svc_flush_bvec(const struct bio_vec *bvec, size_t size, size_t seek)\n{\n\tstruct bvec_iter bi = {\n\t\t.bi_size\t= size + seek,\n\t};\n\tstruct bio_vec bv;\n\n\tbvec_iter_advance(bvec, &bi, seek & PAGE_MASK);\n\tfor_each_bvec(bv, bvec, bi, bi)\n\t\tflush_dcache_page(bv.bv_page);\n}\n#else\nstatic inline void svc_flush_bvec(const struct bio_vec *bvec, size_t size,\n\t\t\t\t  size_t seek)\n{\n}\n#endif\n\n \nstatic ssize_t svc_tcp_read_msg(struct svc_rqst *rqstp, size_t buflen,\n\t\t\t\tsize_t seek)\n{\n\tstruct svc_sock *svsk =\n\t\tcontainer_of(rqstp->rq_xprt, struct svc_sock, sk_xprt);\n\tstruct bio_vec *bvec = rqstp->rq_bvec;\n\tstruct msghdr msg = { NULL };\n\tunsigned int i;\n\tssize_t len;\n\tsize_t t;\n\n\tclear_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\n\n\tfor (i = 0, t = 0; t < buflen; i++, t += PAGE_SIZE)\n\t\tbvec_set_page(&bvec[i], rqstp->rq_pages[i], PAGE_SIZE, 0);\n\trqstp->rq_respages = &rqstp->rq_pages[i];\n\trqstp->rq_next_page = rqstp->rq_respages + 1;\n\n\tiov_iter_bvec(&msg.msg_iter, ITER_DEST, bvec, i, buflen);\n\tif (seek) {\n\t\tiov_iter_advance(&msg.msg_iter, seek);\n\t\tbuflen -= seek;\n\t}\n\tlen = svc_tcp_sock_recv_cmsg(svsk, &msg);\n\tif (len > 0)\n\t\tsvc_flush_bvec(bvec, len, seek);\n\n\t \n\tif (len == buflen)\n\t\tset_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\n\n\treturn len;\n}\n\n \nstatic void svc_sock_setbufsize(struct svc_sock *svsk, unsigned int nreqs)\n{\n\tunsigned int max_mesg = svsk->sk_xprt.xpt_server->sv_max_mesg;\n\tstruct socket *sock = svsk->sk_sock;\n\n\tnreqs = min(nreqs, INT_MAX / 2 / max_mesg);\n\n\tlock_sock(sock->sk);\n\tsock->sk->sk_sndbuf = nreqs * max_mesg * 2;\n\tsock->sk->sk_rcvbuf = nreqs * max_mesg * 2;\n\tsock->sk->sk_write_space(sock->sk);\n\trelease_sock(sock->sk);\n}\n\nstatic void svc_sock_secure_port(struct svc_rqst *rqstp)\n{\n\tif (svc_port_is_privileged(svc_addr(rqstp)))\n\t\tset_bit(RQ_SECURE, &rqstp->rq_flags);\n\telse\n\t\tclear_bit(RQ_SECURE, &rqstp->rq_flags);\n}\n\n \nstatic void svc_data_ready(struct sock *sk)\n{\n\tstruct svc_sock\t*svsk = (struct svc_sock *)sk->sk_user_data;\n\n\ttrace_sk_data_ready(sk);\n\n\tif (svsk) {\n\t\t \n\t\trmb();\n\t\tsvsk->sk_odata(sk);\n\t\ttrace_svcsock_data_ready(&svsk->sk_xprt, 0);\n\t\tif (test_bit(XPT_HANDSHAKE, &svsk->sk_xprt.xpt_flags))\n\t\t\treturn;\n\t\tif (!test_and_set_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags))\n\t\t\tsvc_xprt_enqueue(&svsk->sk_xprt);\n\t}\n}\n\n \nstatic void svc_write_space(struct sock *sk)\n{\n\tstruct svc_sock\t*svsk = (struct svc_sock *)(sk->sk_user_data);\n\n\tif (svsk) {\n\t\t \n\t\trmb();\n\t\ttrace_svcsock_write_space(&svsk->sk_xprt, 0);\n\t\tsvsk->sk_owspace(sk);\n\t\tsvc_xprt_enqueue(&svsk->sk_xprt);\n\t}\n}\n\nstatic int svc_tcp_has_wspace(struct svc_xprt *xprt)\n{\n\tstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\n\n\tif (test_bit(XPT_LISTENER, &xprt->xpt_flags))\n\t\treturn 1;\n\treturn !test_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);\n}\n\nstatic void svc_tcp_kill_temp_xprt(struct svc_xprt *xprt)\n{\n\tstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\n\n\tsock_no_linger(svsk->sk_sock->sk);\n}\n\n \nstatic void svc_tcp_handshake_done(void *data, int status, key_serial_t peerid)\n{\n\tstruct svc_xprt *xprt = data;\n\tstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\n\n\tif (!status) {\n\t\tif (peerid != TLS_NO_PEERID)\n\t\t\tset_bit(XPT_PEER_AUTH, &xprt->xpt_flags);\n\t\tset_bit(XPT_TLS_SESSION, &xprt->xpt_flags);\n\t}\n\tclear_bit(XPT_HANDSHAKE, &xprt->xpt_flags);\n\tcomplete_all(&svsk->sk_handshake_done);\n}\n\n \nstatic void svc_tcp_handshake(struct svc_xprt *xprt)\n{\n\tstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\n\tstruct sock *sk = svsk->sk_sock->sk;\n\tstruct tls_handshake_args args = {\n\t\t.ta_sock\t= svsk->sk_sock,\n\t\t.ta_done\t= svc_tcp_handshake_done,\n\t\t.ta_data\t= xprt,\n\t};\n\tint ret;\n\n\ttrace_svc_tls_upcall(xprt);\n\n\tclear_bit(XPT_TLS_SESSION, &xprt->xpt_flags);\n\tinit_completion(&svsk->sk_handshake_done);\n\n\tret = tls_server_hello_x509(&args, GFP_KERNEL);\n\tif (ret) {\n\t\ttrace_svc_tls_not_started(xprt);\n\t\tgoto out_failed;\n\t}\n\n\tret = wait_for_completion_interruptible_timeout(&svsk->sk_handshake_done,\n\t\t\t\t\t\t\tSVC_HANDSHAKE_TO);\n\tif (ret <= 0) {\n\t\tif (tls_handshake_cancel(sk)) {\n\t\t\ttrace_svc_tls_timed_out(xprt);\n\t\t\tgoto out_close;\n\t\t}\n\t}\n\n\tif (!test_bit(XPT_TLS_SESSION, &xprt->xpt_flags)) {\n\t\ttrace_svc_tls_unavailable(xprt);\n\t\tgoto out_close;\n\t}\n\n\t \n\tset_bit(XPT_DATA, &xprt->xpt_flags);\n\tsvc_xprt_enqueue(xprt);\n\treturn;\n\nout_close:\n\tset_bit(XPT_CLOSE, &xprt->xpt_flags);\nout_failed:\n\tclear_bit(XPT_HANDSHAKE, &xprt->xpt_flags);\n\tset_bit(XPT_DATA, &xprt->xpt_flags);\n\tsvc_xprt_enqueue(xprt);\n}\n\n \nstatic int svc_udp_get_dest_address4(struct svc_rqst *rqstp,\n\t\t\t\t     struct cmsghdr *cmh)\n{\n\tstruct in_pktinfo *pki = CMSG_DATA(cmh);\n\tstruct sockaddr_in *daddr = svc_daddr_in(rqstp);\n\n\tif (cmh->cmsg_type != IP_PKTINFO)\n\t\treturn 0;\n\n\tdaddr->sin_family = AF_INET;\n\tdaddr->sin_addr.s_addr = pki->ipi_spec_dst.s_addr;\n\treturn 1;\n}\n\n \nstatic int svc_udp_get_dest_address6(struct svc_rqst *rqstp,\n\t\t\t\t     struct cmsghdr *cmh)\n{\n\tstruct in6_pktinfo *pki = CMSG_DATA(cmh);\n\tstruct sockaddr_in6 *daddr = svc_daddr_in6(rqstp);\n\n\tif (cmh->cmsg_type != IPV6_PKTINFO)\n\t\treturn 0;\n\n\tdaddr->sin6_family = AF_INET6;\n\tdaddr->sin6_addr = pki->ipi6_addr;\n\tdaddr->sin6_scope_id = pki->ipi6_ifindex;\n\treturn 1;\n}\n\n \nstatic int svc_udp_get_dest_address(struct svc_rqst *rqstp,\n\t\t\t\t    struct cmsghdr *cmh)\n{\n\tswitch (cmh->cmsg_level) {\n\tcase SOL_IP:\n\t\treturn svc_udp_get_dest_address4(rqstp, cmh);\n\tcase SOL_IPV6:\n\t\treturn svc_udp_get_dest_address6(rqstp, cmh);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int svc_udp_recvfrom(struct svc_rqst *rqstp)\n{\n\tstruct svc_sock\t*svsk =\n\t\tcontainer_of(rqstp->rq_xprt, struct svc_sock, sk_xprt);\n\tstruct svc_serv\t*serv = svsk->sk_xprt.xpt_server;\n\tstruct sk_buff\t*skb;\n\tunion {\n\t\tstruct cmsghdr\thdr;\n\t\tlong\t\tall[SVC_PKTINFO_SPACE / sizeof(long)];\n\t} buffer;\n\tstruct cmsghdr *cmh = &buffer.hdr;\n\tstruct msghdr msg = {\n\t\t.msg_name = svc_addr(rqstp),\n\t\t.msg_control = cmh,\n\t\t.msg_controllen = sizeof(buffer),\n\t\t.msg_flags = MSG_DONTWAIT,\n\t};\n\tsize_t len;\n\tint err;\n\n\tif (test_and_clear_bit(XPT_CHNGBUF, &svsk->sk_xprt.xpt_flags))\n\t     \n\t    svc_sock_setbufsize(svsk, serv->sv_nrthreads + 3);\n\n\tclear_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\n\terr = kernel_recvmsg(svsk->sk_sock, &msg, NULL,\n\t\t\t     0, 0, MSG_PEEK | MSG_DONTWAIT);\n\tif (err < 0)\n\t\tgoto out_recv_err;\n\tskb = skb_recv_udp(svsk->sk_sk, MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto out_recv_err;\n\n\tlen = svc_addr_len(svc_addr(rqstp));\n\trqstp->rq_addrlen = len;\n\tif (skb->tstamp == 0) {\n\t\tskb->tstamp = ktime_get_real();\n\t\t \n\t}\n\tsock_write_timestamp(svsk->sk_sk, skb->tstamp);\n\tset_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);  \n\n\tlen = skb->len;\n\trqstp->rq_arg.len = len;\n\ttrace_svcsock_udp_recv(&svsk->sk_xprt, len);\n\n\trqstp->rq_prot = IPPROTO_UDP;\n\n\tif (!svc_udp_get_dest_address(rqstp, cmh))\n\t\tgoto out_cmsg_err;\n\trqstp->rq_daddrlen = svc_addr_len(svc_daddr(rqstp));\n\n\tif (skb_is_nonlinear(skb)) {\n\t\t \n\t\tlocal_bh_disable();\n\t\tif (csum_partial_copy_to_xdr(&rqstp->rq_arg, skb))\n\t\t\tgoto out_bh_enable;\n\t\tlocal_bh_enable();\n\t\tconsume_skb(skb);\n\t} else {\n\t\t \n\t\trqstp->rq_arg.head[0].iov_base = skb->data;\n\t\trqstp->rq_arg.head[0].iov_len = len;\n\t\tif (skb_checksum_complete(skb))\n\t\t\tgoto out_free;\n\t\trqstp->rq_xprt_ctxt = skb;\n\t}\n\n\trqstp->rq_arg.page_base = 0;\n\tif (len <= rqstp->rq_arg.head[0].iov_len) {\n\t\trqstp->rq_arg.head[0].iov_len = len;\n\t\trqstp->rq_arg.page_len = 0;\n\t\trqstp->rq_respages = rqstp->rq_pages+1;\n\t} else {\n\t\trqstp->rq_arg.page_len = len - rqstp->rq_arg.head[0].iov_len;\n\t\trqstp->rq_respages = rqstp->rq_pages + 1 +\n\t\t\tDIV_ROUND_UP(rqstp->rq_arg.page_len, PAGE_SIZE);\n\t}\n\trqstp->rq_next_page = rqstp->rq_respages+1;\n\n\tif (serv->sv_stats)\n\t\tserv->sv_stats->netudpcnt++;\n\n\tsvc_sock_secure_port(rqstp);\n\tsvc_xprt_received(rqstp->rq_xprt);\n\treturn len;\n\nout_recv_err:\n\tif (err != -EAGAIN) {\n\t\t \n\t\tset_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\n\t}\n\ttrace_svcsock_udp_recv_err(&svsk->sk_xprt, err);\n\tgoto out_clear_busy;\nout_cmsg_err:\n\tnet_warn_ratelimited(\"svc: received unknown control message %d/%d; dropping RPC reply datagram\\n\",\n\t\t\t     cmh->cmsg_level, cmh->cmsg_type);\n\tgoto out_free;\nout_bh_enable:\n\tlocal_bh_enable();\nout_free:\n\tkfree_skb(skb);\nout_clear_busy:\n\tsvc_xprt_received(rqstp->rq_xprt);\n\treturn 0;\n}\n\n \nstatic int svc_udp_sendto(struct svc_rqst *rqstp)\n{\n\tstruct svc_xprt *xprt = rqstp->rq_xprt;\n\tstruct svc_sock\t*svsk = container_of(xprt, struct svc_sock, sk_xprt);\n\tstruct xdr_buf *xdr = &rqstp->rq_res;\n\tunion {\n\t\tstruct cmsghdr\thdr;\n\t\tlong\t\tall[SVC_PKTINFO_SPACE / sizeof(long)];\n\t} buffer;\n\tstruct cmsghdr *cmh = &buffer.hdr;\n\tstruct msghdr msg = {\n\t\t.msg_name\t= &rqstp->rq_addr,\n\t\t.msg_namelen\t= rqstp->rq_addrlen,\n\t\t.msg_control\t= cmh,\n\t\t.msg_flags\t= MSG_SPLICE_PAGES,\n\t\t.msg_controllen\t= sizeof(buffer),\n\t};\n\tunsigned int count;\n\tint err;\n\n\tsvc_udp_release_ctxt(xprt, rqstp->rq_xprt_ctxt);\n\trqstp->rq_xprt_ctxt = NULL;\n\n\tsvc_set_cmsg_data(rqstp, cmh);\n\n\tmutex_lock(&xprt->xpt_mutex);\n\n\tif (svc_xprt_is_dead(xprt))\n\t\tgoto out_notconn;\n\n\tcount = xdr_buf_to_bvec(rqstp->rq_bvec,\n\t\t\t\tARRAY_SIZE(rqstp->rq_bvec), xdr);\n\n\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, rqstp->rq_bvec,\n\t\t      count, 0);\n\terr = sock_sendmsg(svsk->sk_sock, &msg);\n\tif (err == -ECONNREFUSED) {\n\t\t \n\t\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, rqstp->rq_bvec,\n\t\t\t      count, 0);\n\t\terr = sock_sendmsg(svsk->sk_sock, &msg);\n\t}\n\n\ttrace_svcsock_udp_send(xprt, err);\n\n\tmutex_unlock(&xprt->xpt_mutex);\n\treturn err;\n\nout_notconn:\n\tmutex_unlock(&xprt->xpt_mutex);\n\treturn -ENOTCONN;\n}\n\nstatic int svc_udp_has_wspace(struct svc_xprt *xprt)\n{\n\tstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\n\tstruct svc_serv\t*serv = xprt->xpt_server;\n\tunsigned long required;\n\n\t \n\tset_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);\n\trequired = atomic_read(&svsk->sk_xprt.xpt_reserved) + serv->sv_max_mesg;\n\tif (required*2 > sock_wspace(svsk->sk_sk))\n\t\treturn 0;\n\tclear_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);\n\treturn 1;\n}\n\nstatic struct svc_xprt *svc_udp_accept(struct svc_xprt *xprt)\n{\n\tBUG();\n\treturn NULL;\n}\n\nstatic void svc_udp_kill_temp_xprt(struct svc_xprt *xprt)\n{\n}\n\nstatic struct svc_xprt *svc_udp_create(struct svc_serv *serv,\n\t\t\t\t       struct net *net,\n\t\t\t\t       struct sockaddr *sa, int salen,\n\t\t\t\t       int flags)\n{\n\treturn svc_create_socket(serv, IPPROTO_UDP, net, sa, salen, flags);\n}\n\nstatic const struct svc_xprt_ops svc_udp_ops = {\n\t.xpo_create = svc_udp_create,\n\t.xpo_recvfrom = svc_udp_recvfrom,\n\t.xpo_sendto = svc_udp_sendto,\n\t.xpo_result_payload = svc_sock_result_payload,\n\t.xpo_release_ctxt = svc_udp_release_ctxt,\n\t.xpo_detach = svc_sock_detach,\n\t.xpo_free = svc_sock_free,\n\t.xpo_has_wspace = svc_udp_has_wspace,\n\t.xpo_accept = svc_udp_accept,\n\t.xpo_kill_temp_xprt = svc_udp_kill_temp_xprt,\n};\n\nstatic struct svc_xprt_class svc_udp_class = {\n\t.xcl_name = \"udp\",\n\t.xcl_owner = THIS_MODULE,\n\t.xcl_ops = &svc_udp_ops,\n\t.xcl_max_payload = RPCSVC_MAXPAYLOAD_UDP,\n\t.xcl_ident = XPRT_TRANSPORT_UDP,\n};\n\nstatic void svc_udp_init(struct svc_sock *svsk, struct svc_serv *serv)\n{\n\tsvc_xprt_init(sock_net(svsk->sk_sock->sk), &svc_udp_class,\n\t\t      &svsk->sk_xprt, serv);\n\tclear_bit(XPT_CACHE_AUTH, &svsk->sk_xprt.xpt_flags);\n\tsvsk->sk_sk->sk_data_ready = svc_data_ready;\n\tsvsk->sk_sk->sk_write_space = svc_write_space;\n\n\t \n\tsvc_sock_setbufsize(svsk, 3);\n\n\t \n\tset_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\n\tset_bit(XPT_CHNGBUF, &svsk->sk_xprt.xpt_flags);\n\n\t \n\tswitch (svsk->sk_sk->sk_family) {\n\tcase AF_INET:\n\t\tip_sock_set_pktinfo(svsk->sk_sock->sk);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tip6_sock_set_recvpktinfo(svsk->sk_sock->sk);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n \nstatic void svc_tcp_listen_data_ready(struct sock *sk)\n{\n\tstruct svc_sock\t*svsk = (struct svc_sock *)sk->sk_user_data;\n\n\ttrace_sk_data_ready(sk);\n\n\t \n\tif (sk->sk_state != TCP_LISTEN)\n\t\treturn;\n\n\tif (svsk) {\n\t\t \n\t\trmb();\n\t\tsvsk->sk_odata(sk);\n\t\tset_bit(XPT_CONN, &svsk->sk_xprt.xpt_flags);\n\t\tsvc_xprt_enqueue(&svsk->sk_xprt);\n\t}\n}\n\n \nstatic void svc_tcp_state_change(struct sock *sk)\n{\n\tstruct svc_sock\t*svsk = (struct svc_sock *)sk->sk_user_data;\n\n\tif (svsk) {\n\t\t \n\t\trmb();\n\t\tsvsk->sk_ostate(sk);\n\t\ttrace_svcsock_tcp_state(&svsk->sk_xprt, svsk->sk_sock);\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tsvc_xprt_deferred_close(&svsk->sk_xprt);\n\t}\n}\n\n \nstatic struct svc_xprt *svc_tcp_accept(struct svc_xprt *xprt)\n{\n\tstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr\t*sin = (struct sockaddr *) &addr;\n\tstruct svc_serv\t*serv = svsk->sk_xprt.xpt_server;\n\tstruct socket\t*sock = svsk->sk_sock;\n\tstruct socket\t*newsock;\n\tstruct svc_sock\t*newsvsk;\n\tint\t\terr, slen;\n\n\tif (!sock)\n\t\treturn NULL;\n\n\tclear_bit(XPT_CONN, &svsk->sk_xprt.xpt_flags);\n\terr = kernel_accept(sock, &newsock, O_NONBLOCK);\n\tif (err < 0) {\n\t\tif (err != -EAGAIN)\n\t\t\ttrace_svcsock_accept_err(xprt, serv->sv_name, err);\n\t\treturn NULL;\n\t}\n\tif (IS_ERR(sock_alloc_file(newsock, O_NONBLOCK, NULL)))\n\t\treturn NULL;\n\n\tset_bit(XPT_CONN, &svsk->sk_xprt.xpt_flags);\n\n\terr = kernel_getpeername(newsock, sin);\n\tif (err < 0) {\n\t\ttrace_svcsock_getpeername_err(xprt, serv->sv_name, err);\n\t\tgoto failed;\t\t \n\t}\n\tslen = err;\n\n\t \n\tnewsock->sk->sk_state_change = svsk->sk_ostate;\n\tnewsock->sk->sk_data_ready = svsk->sk_odata;\n\tnewsock->sk->sk_write_space = svsk->sk_owspace;\n\n\t \n\tnewsock->sk->sk_sndtimeo = HZ*30;\n\n\tnewsvsk = svc_setup_socket(serv, newsock,\n\t\t\t\t (SVC_SOCK_ANONYMOUS | SVC_SOCK_TEMPORARY));\n\tif (IS_ERR(newsvsk))\n\t\tgoto failed;\n\tsvc_xprt_set_remote(&newsvsk->sk_xprt, sin, slen);\n\terr = kernel_getsockname(newsock, sin);\n\tslen = err;\n\tif (unlikely(err < 0))\n\t\tslen = offsetof(struct sockaddr, sa_data);\n\tsvc_xprt_set_local(&newsvsk->sk_xprt, sin, slen);\n\n\tif (sock_is_loopback(newsock->sk))\n\t\tset_bit(XPT_LOCAL, &newsvsk->sk_xprt.xpt_flags);\n\telse\n\t\tclear_bit(XPT_LOCAL, &newsvsk->sk_xprt.xpt_flags);\n\tif (serv->sv_stats)\n\t\tserv->sv_stats->nettcpconn++;\n\n\treturn &newsvsk->sk_xprt;\n\nfailed:\n\tsockfd_put(newsock);\n\treturn NULL;\n}\n\nstatic size_t svc_tcp_restore_pages(struct svc_sock *svsk,\n\t\t\t\t    struct svc_rqst *rqstp)\n{\n\tsize_t len = svsk->sk_datalen;\n\tunsigned int i, npages;\n\n\tif (!len)\n\t\treturn 0;\n\tnpages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tfor (i = 0; i < npages; i++) {\n\t\tif (rqstp->rq_pages[i] != NULL)\n\t\t\tput_page(rqstp->rq_pages[i]);\n\t\tBUG_ON(svsk->sk_pages[i] == NULL);\n\t\trqstp->rq_pages[i] = svsk->sk_pages[i];\n\t\tsvsk->sk_pages[i] = NULL;\n\t}\n\trqstp->rq_arg.head[0].iov_base = page_address(rqstp->rq_pages[0]);\n\treturn len;\n}\n\nstatic void svc_tcp_save_pages(struct svc_sock *svsk, struct svc_rqst *rqstp)\n{\n\tunsigned int i, len, npages;\n\n\tif (svsk->sk_datalen == 0)\n\t\treturn;\n\tlen = svsk->sk_datalen;\n\tnpages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tfor (i = 0; i < npages; i++) {\n\t\tsvsk->sk_pages[i] = rqstp->rq_pages[i];\n\t\trqstp->rq_pages[i] = NULL;\n\t}\n}\n\nstatic void svc_tcp_clear_pages(struct svc_sock *svsk)\n{\n\tunsigned int i, len, npages;\n\n\tif (svsk->sk_datalen == 0)\n\t\tgoto out;\n\tlen = svsk->sk_datalen;\n\tnpages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tfor (i = 0; i < npages; i++) {\n\t\tif (svsk->sk_pages[i] == NULL) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tcontinue;\n\t\t}\n\t\tput_page(svsk->sk_pages[i]);\n\t\tsvsk->sk_pages[i] = NULL;\n\t}\nout:\n\tsvsk->sk_tcplen = 0;\n\tsvsk->sk_datalen = 0;\n}\n\n \nstatic ssize_t svc_tcp_read_marker(struct svc_sock *svsk,\n\t\t\t\t   struct svc_rqst *rqstp)\n{\n\tssize_t want, len;\n\n\t \n\tif (svsk->sk_tcplen < sizeof(rpc_fraghdr)) {\n\t\tstruct msghdr\tmsg = { NULL };\n\t\tstruct kvec\tiov;\n\n\t\twant = sizeof(rpc_fraghdr) - svsk->sk_tcplen;\n\t\tiov.iov_base = ((char *)&svsk->sk_marker) + svsk->sk_tcplen;\n\t\tiov.iov_len  = want;\n\t\tiov_iter_kvec(&msg.msg_iter, ITER_DEST, &iov, 1, want);\n\t\tlen = svc_tcp_sock_recv_cmsg(svsk, &msg);\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\tsvsk->sk_tcplen += len;\n\t\tif (len < want) {\n\t\t\t \n\t\t\tgoto err_short;\n\t\t}\n\t\ttrace_svcsock_marker(&svsk->sk_xprt, svsk->sk_marker);\n\t\tif (svc_sock_reclen(svsk) + svsk->sk_datalen >\n\t\t    svsk->sk_xprt.xpt_server->sv_max_mesg)\n\t\t\tgoto err_too_large;\n\t}\n\treturn svc_sock_reclen(svsk);\n\nerr_too_large:\n\tnet_notice_ratelimited(\"svc: %s %s RPC fragment too large: %d\\n\",\n\t\t\t       __func__, svsk->sk_xprt.xpt_server->sv_name,\n\t\t\t       svc_sock_reclen(svsk));\n\tsvc_xprt_deferred_close(&svsk->sk_xprt);\nerr_short:\n\treturn -EAGAIN;\n}\n\nstatic int receive_cb_reply(struct svc_sock *svsk, struct svc_rqst *rqstp)\n{\n\tstruct rpc_xprt *bc_xprt = svsk->sk_xprt.xpt_bc_xprt;\n\tstruct rpc_rqst *req = NULL;\n\tstruct kvec *src, *dst;\n\t__be32 *p = (__be32 *)rqstp->rq_arg.head[0].iov_base;\n\t__be32 xid;\n\t__be32 calldir;\n\n\txid = *p++;\n\tcalldir = *p;\n\n\tif (!bc_xprt)\n\t\treturn -EAGAIN;\n\tspin_lock(&bc_xprt->queue_lock);\n\treq = xprt_lookup_rqst(bc_xprt, xid);\n\tif (!req)\n\t\tgoto unlock_notfound;\n\n\tmemcpy(&req->rq_private_buf, &req->rq_rcv_buf, sizeof(struct xdr_buf));\n\t \n\tdst = &req->rq_private_buf.head[0];\n\tsrc = &rqstp->rq_arg.head[0];\n\tif (dst->iov_len < src->iov_len)\n\t\tgoto unlock_eagain;  \n\tmemcpy(dst->iov_base, src->iov_base, src->iov_len);\n\txprt_complete_rqst(req->rq_task, rqstp->rq_arg.len);\n\trqstp->rq_arg.len = 0;\n\tspin_unlock(&bc_xprt->queue_lock);\n\treturn 0;\nunlock_notfound:\n\tprintk(KERN_NOTICE\n\t\t\"%s: Got unrecognized reply: \"\n\t\t\"calldir 0x%x xpt_bc_xprt %p xid %08x\\n\",\n\t\t__func__, ntohl(calldir),\n\t\tbc_xprt, ntohl(xid));\nunlock_eagain:\n\tspin_unlock(&bc_xprt->queue_lock);\n\treturn -EAGAIN;\n}\n\nstatic void svc_tcp_fragment_received(struct svc_sock *svsk)\n{\n\t \n\tsvsk->sk_tcplen = 0;\n\tsvsk->sk_marker = xdr_zero;\n\n\tsmp_wmb();\n\ttcp_set_rcvlowat(svsk->sk_sk, 1);\n}\n\n \nstatic int svc_tcp_recvfrom(struct svc_rqst *rqstp)\n{\n\tstruct svc_sock\t*svsk =\n\t\tcontainer_of(rqstp->rq_xprt, struct svc_sock, sk_xprt);\n\tstruct svc_serv\t*serv = svsk->sk_xprt.xpt_server;\n\tsize_t want, base;\n\tssize_t len;\n\t__be32 *p;\n\t__be32 calldir;\n\n\tclear_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\n\tlen = svc_tcp_read_marker(svsk, rqstp);\n\tif (len < 0)\n\t\tgoto error;\n\n\tbase = svc_tcp_restore_pages(svsk, rqstp);\n\twant = len - (svsk->sk_tcplen - sizeof(rpc_fraghdr));\n\tlen = svc_tcp_read_msg(rqstp, base + want, base);\n\tif (len >= 0) {\n\t\ttrace_svcsock_tcp_recv(&svsk->sk_xprt, len);\n\t\tsvsk->sk_tcplen += len;\n\t\tsvsk->sk_datalen += len;\n\t}\n\tif (len != want || !svc_sock_final_rec(svsk))\n\t\tgoto err_incomplete;\n\tif (svsk->sk_datalen < 8)\n\t\tgoto err_nuts;\n\n\trqstp->rq_arg.len = svsk->sk_datalen;\n\trqstp->rq_arg.page_base = 0;\n\tif (rqstp->rq_arg.len <= rqstp->rq_arg.head[0].iov_len) {\n\t\trqstp->rq_arg.head[0].iov_len = rqstp->rq_arg.len;\n\t\trqstp->rq_arg.page_len = 0;\n\t} else\n\t\trqstp->rq_arg.page_len = rqstp->rq_arg.len - rqstp->rq_arg.head[0].iov_len;\n\n\trqstp->rq_xprt_ctxt   = NULL;\n\trqstp->rq_prot\t      = IPPROTO_TCP;\n\tif (test_bit(XPT_LOCAL, &svsk->sk_xprt.xpt_flags))\n\t\tset_bit(RQ_LOCAL, &rqstp->rq_flags);\n\telse\n\t\tclear_bit(RQ_LOCAL, &rqstp->rq_flags);\n\n\tp = (__be32 *)rqstp->rq_arg.head[0].iov_base;\n\tcalldir = p[1];\n\tif (calldir)\n\t\tlen = receive_cb_reply(svsk, rqstp);\n\n\t \n\tsvsk->sk_datalen = 0;\n\tsvc_tcp_fragment_received(svsk);\n\n\tif (len < 0)\n\t\tgoto error;\n\n\tsvc_xprt_copy_addrs(rqstp, &svsk->sk_xprt);\n\tif (serv->sv_stats)\n\t\tserv->sv_stats->nettcpcnt++;\n\n\tsvc_sock_secure_port(rqstp);\n\tsvc_xprt_received(rqstp->rq_xprt);\n\treturn rqstp->rq_arg.len;\n\nerr_incomplete:\n\tsvc_tcp_save_pages(svsk, rqstp);\n\tif (len < 0 && len != -EAGAIN)\n\t\tgoto err_delete;\n\tif (len == want)\n\t\tsvc_tcp_fragment_received(svsk);\n\telse {\n\t\t \n\t\ttcp_set_rcvlowat(svsk->sk_sk,\n\t\t\t\t svc_sock_reclen(svsk) - svsk->sk_tcplen);\n\n\t\ttrace_svcsock_tcp_recv_short(&svsk->sk_xprt,\n\t\t\t\tsvc_sock_reclen(svsk),\n\t\t\t\tsvsk->sk_tcplen - sizeof(rpc_fraghdr));\n\t}\n\tgoto err_noclose;\nerror:\n\tif (len != -EAGAIN)\n\t\tgoto err_delete;\n\ttrace_svcsock_tcp_recv_eagain(&svsk->sk_xprt, 0);\n\tgoto err_noclose;\nerr_nuts:\n\tsvsk->sk_datalen = 0;\nerr_delete:\n\ttrace_svcsock_tcp_recv_err(&svsk->sk_xprt, len);\n\tsvc_xprt_deferred_close(&svsk->sk_xprt);\nerr_noclose:\n\tsvc_xprt_received(rqstp->rq_xprt);\n\treturn 0;\t \n}\n\n \nstatic int svc_tcp_sendmsg(struct svc_sock *svsk, struct svc_rqst *rqstp,\n\t\t\t   rpc_fraghdr marker, unsigned int *sentp)\n{\n\tstruct msghdr msg = {\n\t\t.msg_flags\t= MSG_SPLICE_PAGES,\n\t};\n\tunsigned int count;\n\tvoid *buf;\n\tint ret;\n\n\t*sentp = 0;\n\n\t \n\tbuf = page_frag_alloc(&svsk->sk_frag_cache, sizeof(marker),\n\t\t\t      GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tmemcpy(buf, &marker, sizeof(marker));\n\tbvec_set_virt(rqstp->rq_bvec, buf, sizeof(marker));\n\n\tcount = xdr_buf_to_bvec(rqstp->rq_bvec + 1,\n\t\t\t\tARRAY_SIZE(rqstp->rq_bvec) - 1, &rqstp->rq_res);\n\n\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, rqstp->rq_bvec,\n\t\t      1 + count, sizeof(marker) + rqstp->rq_res.len);\n\tret = sock_sendmsg(svsk->sk_sock, &msg);\n\tif (ret < 0)\n\t\treturn ret;\n\t*sentp += ret;\n\treturn 0;\n}\n\n \nstatic int svc_tcp_sendto(struct svc_rqst *rqstp)\n{\n\tstruct svc_xprt *xprt = rqstp->rq_xprt;\n\tstruct svc_sock\t*svsk = container_of(xprt, struct svc_sock, sk_xprt);\n\tstruct xdr_buf *xdr = &rqstp->rq_res;\n\trpc_fraghdr marker = cpu_to_be32(RPC_LAST_STREAM_FRAGMENT |\n\t\t\t\t\t (u32)xdr->len);\n\tunsigned int sent;\n\tint err;\n\n\tsvc_tcp_release_ctxt(xprt, rqstp->rq_xprt_ctxt);\n\trqstp->rq_xprt_ctxt = NULL;\n\n\tmutex_lock(&xprt->xpt_mutex);\n\tif (svc_xprt_is_dead(xprt))\n\t\tgoto out_notconn;\n\terr = svc_tcp_sendmsg(svsk, rqstp, marker, &sent);\n\ttrace_svcsock_tcp_send(xprt, err < 0 ? (long)err : sent);\n\tif (err < 0 || sent != (xdr->len + sizeof(marker)))\n\t\tgoto out_close;\n\tmutex_unlock(&xprt->xpt_mutex);\n\treturn sent;\n\nout_notconn:\n\tmutex_unlock(&xprt->xpt_mutex);\n\treturn -ENOTCONN;\nout_close:\n\tpr_notice(\"rpc-srv/tcp: %s: %s %d when sending %d bytes - shutting down socket\\n\",\n\t\t  xprt->xpt_server->sv_name,\n\t\t  (err < 0) ? \"got error\" : \"sent\",\n\t\t  (err < 0) ? err : sent, xdr->len);\n\tsvc_xprt_deferred_close(xprt);\n\tmutex_unlock(&xprt->xpt_mutex);\n\treturn -EAGAIN;\n}\n\nstatic struct svc_xprt *svc_tcp_create(struct svc_serv *serv,\n\t\t\t\t       struct net *net,\n\t\t\t\t       struct sockaddr *sa, int salen,\n\t\t\t\t       int flags)\n{\n\treturn svc_create_socket(serv, IPPROTO_TCP, net, sa, salen, flags);\n}\n\nstatic const struct svc_xprt_ops svc_tcp_ops = {\n\t.xpo_create = svc_tcp_create,\n\t.xpo_recvfrom = svc_tcp_recvfrom,\n\t.xpo_sendto = svc_tcp_sendto,\n\t.xpo_result_payload = svc_sock_result_payload,\n\t.xpo_release_ctxt = svc_tcp_release_ctxt,\n\t.xpo_detach = svc_tcp_sock_detach,\n\t.xpo_free = svc_sock_free,\n\t.xpo_has_wspace = svc_tcp_has_wspace,\n\t.xpo_accept = svc_tcp_accept,\n\t.xpo_kill_temp_xprt = svc_tcp_kill_temp_xprt,\n\t.xpo_handshake = svc_tcp_handshake,\n};\n\nstatic struct svc_xprt_class svc_tcp_class = {\n\t.xcl_name = \"tcp\",\n\t.xcl_owner = THIS_MODULE,\n\t.xcl_ops = &svc_tcp_ops,\n\t.xcl_max_payload = RPCSVC_MAXPAYLOAD_TCP,\n\t.xcl_ident = XPRT_TRANSPORT_TCP,\n};\n\nvoid svc_init_xprt_sock(void)\n{\n\tsvc_reg_xprt_class(&svc_tcp_class);\n\tsvc_reg_xprt_class(&svc_udp_class);\n}\n\nvoid svc_cleanup_xprt_sock(void)\n{\n\tsvc_unreg_xprt_class(&svc_tcp_class);\n\tsvc_unreg_xprt_class(&svc_udp_class);\n}\n\nstatic void svc_tcp_init(struct svc_sock *svsk, struct svc_serv *serv)\n{\n\tstruct sock\t*sk = svsk->sk_sk;\n\n\tsvc_xprt_init(sock_net(svsk->sk_sock->sk), &svc_tcp_class,\n\t\t      &svsk->sk_xprt, serv);\n\tset_bit(XPT_CACHE_AUTH, &svsk->sk_xprt.xpt_flags);\n\tset_bit(XPT_CONG_CTRL, &svsk->sk_xprt.xpt_flags);\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tstrcpy(svsk->sk_xprt.xpt_remotebuf, \"listener\");\n\t\tset_bit(XPT_LISTENER, &svsk->sk_xprt.xpt_flags);\n\t\tsk->sk_data_ready = svc_tcp_listen_data_ready;\n\t\tset_bit(XPT_CONN, &svsk->sk_xprt.xpt_flags);\n\t} else {\n\t\tsk->sk_state_change = svc_tcp_state_change;\n\t\tsk->sk_data_ready = svc_data_ready;\n\t\tsk->sk_write_space = svc_write_space;\n\n\t\tsvsk->sk_marker = xdr_zero;\n\t\tsvsk->sk_tcplen = 0;\n\t\tsvsk->sk_datalen = 0;\n\t\tmemset(&svsk->sk_pages[0], 0, sizeof(svsk->sk_pages));\n\n\t\ttcp_sock_set_nodelay(sk);\n\n\t\tset_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\n\t\tswitch (sk->sk_state) {\n\t\tcase TCP_SYN_RECV:\n\t\tcase TCP_ESTABLISHED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsvc_xprt_deferred_close(&svsk->sk_xprt);\n\t\t}\n\t}\n}\n\nvoid svc_sock_update_bufs(struct svc_serv *serv)\n{\n\t \n\tstruct svc_sock *svsk;\n\n\tspin_lock_bh(&serv->sv_lock);\n\tlist_for_each_entry(svsk, &serv->sv_permsocks, sk_xprt.xpt_list)\n\t\tset_bit(XPT_CHNGBUF, &svsk->sk_xprt.xpt_flags);\n\tspin_unlock_bh(&serv->sv_lock);\n}\nEXPORT_SYMBOL_GPL(svc_sock_update_bufs);\n\n \nstatic struct svc_sock *svc_setup_socket(struct svc_serv *serv,\n\t\t\t\t\t\tstruct socket *sock,\n\t\t\t\t\t\tint flags)\n{\n\tstruct svc_sock\t*svsk;\n\tstruct sock\t*inet;\n\tint\t\tpmap_register = !(flags & SVC_SOCK_ANONYMOUS);\n\n\tsvsk = kzalloc(sizeof(*svsk), GFP_KERNEL);\n\tif (!svsk)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinet = sock->sk;\n\n\tif (pmap_register) {\n\t\tint err;\n\n\t\terr = svc_register(serv, sock_net(sock->sk), inet->sk_family,\n\t\t\t\t     inet->sk_protocol,\n\t\t\t\t     ntohs(inet_sk(inet)->inet_sport));\n\t\tif (err < 0) {\n\t\t\tkfree(svsk);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\t}\n\n\tsvsk->sk_sock = sock;\n\tsvsk->sk_sk = inet;\n\tsvsk->sk_ostate = inet->sk_state_change;\n\tsvsk->sk_odata = inet->sk_data_ready;\n\tsvsk->sk_owspace = inet->sk_write_space;\n\t \n\twmb();\n\tinet->sk_user_data = svsk;\n\n\t \n\tif (sock->type == SOCK_DGRAM)\n\t\tsvc_udp_init(svsk, serv);\n\telse\n\t\tsvc_tcp_init(svsk, serv);\n\n\ttrace_svcsock_new(svsk, sock);\n\treturn svsk;\n}\n\n \nint svc_addsock(struct svc_serv *serv, struct net *net, const int fd,\n\t\tchar *name_return, const size_t len, const struct cred *cred)\n{\n\tint err = 0;\n\tstruct socket *so = sockfd_lookup(fd, &err);\n\tstruct svc_sock *svsk = NULL;\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr *sin = (struct sockaddr *)&addr;\n\tint salen;\n\n\tif (!so)\n\t\treturn err;\n\terr = -EINVAL;\n\tif (sock_net(so->sk) != net)\n\t\tgoto out;\n\terr = -EAFNOSUPPORT;\n\tif ((so->sk->sk_family != PF_INET) && (so->sk->sk_family != PF_INET6))\n\t\tgoto out;\n\terr =  -EPROTONOSUPPORT;\n\tif (so->sk->sk_protocol != IPPROTO_TCP &&\n\t    so->sk->sk_protocol != IPPROTO_UDP)\n\t\tgoto out;\n\terr = -EISCONN;\n\tif (so->state > SS_UNCONNECTED)\n\t\tgoto out;\n\terr = -ENOENT;\n\tif (!try_module_get(THIS_MODULE))\n\t\tgoto out;\n\tsvsk = svc_setup_socket(serv, so, SVC_SOCK_DEFAULTS);\n\tif (IS_ERR(svsk)) {\n\t\tmodule_put(THIS_MODULE);\n\t\terr = PTR_ERR(svsk);\n\t\tgoto out;\n\t}\n\tsalen = kernel_getsockname(svsk->sk_sock, sin);\n\tif (salen >= 0)\n\t\tsvc_xprt_set_local(&svsk->sk_xprt, sin, salen);\n\tsvsk->sk_xprt.xpt_cred = get_cred(cred);\n\tsvc_add_new_perm_xprt(serv, &svsk->sk_xprt);\n\treturn svc_one_sock_name(svsk, name_return, len);\nout:\n\tsockfd_put(so);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(svc_addsock);\n\n \nstatic struct svc_xprt *svc_create_socket(struct svc_serv *serv,\n\t\t\t\t\t  int protocol,\n\t\t\t\t\t  struct net *net,\n\t\t\t\t\t  struct sockaddr *sin, int len,\n\t\t\t\t\t  int flags)\n{\n\tstruct svc_sock\t*svsk;\n\tstruct socket\t*sock;\n\tint\t\terror;\n\tint\t\ttype;\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr *newsin = (struct sockaddr *)&addr;\n\tint\t\tnewlen;\n\tint\t\tfamily;\n\n\tif (protocol != IPPROTO_UDP && protocol != IPPROTO_TCP) {\n\t\tprintk(KERN_WARNING \"svc: only UDP and TCP \"\n\t\t\t\t\"sockets supported\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\ttype = (protocol == IPPROTO_UDP)? SOCK_DGRAM : SOCK_STREAM;\n\tswitch (sin->sa_family) {\n\tcase AF_INET6:\n\t\tfamily = PF_INET6;\n\t\tbreak;\n\tcase AF_INET:\n\t\tfamily = PF_INET;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\terror = __sock_create(net, family, type, protocol, &sock, 1);\n\tif (error < 0)\n\t\treturn ERR_PTR(error);\n\n\tsvc_reclassify_socket(sock);\n\n\t \n\tif (family == PF_INET6)\n\t\tip6_sock_set_v6only(sock->sk);\n\tif (type == SOCK_STREAM)\n\t\tsock->sk->sk_reuse = SK_CAN_REUSE;  \n\terror = kernel_bind(sock, sin, len);\n\tif (error < 0)\n\t\tgoto bummer;\n\n\terror = kernel_getsockname(sock, newsin);\n\tif (error < 0)\n\t\tgoto bummer;\n\tnewlen = error;\n\n\tif (protocol == IPPROTO_TCP) {\n\t\tif ((error = kernel_listen(sock, 64)) < 0)\n\t\t\tgoto bummer;\n\t}\n\n\tsvsk = svc_setup_socket(serv, sock, flags);\n\tif (IS_ERR(svsk)) {\n\t\terror = PTR_ERR(svsk);\n\t\tgoto bummer;\n\t}\n\tsvc_xprt_set_local(&svsk->sk_xprt, newsin, newlen);\n\treturn (struct svc_xprt *)svsk;\nbummer:\n\tsock_release(sock);\n\treturn ERR_PTR(error);\n}\n\n \nstatic void svc_sock_detach(struct svc_xprt *xprt)\n{\n\tstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\n\tstruct sock *sk = svsk->sk_sk;\n\n\t \n\tlock_sock(sk);\n\tsk->sk_state_change = svsk->sk_ostate;\n\tsk->sk_data_ready = svsk->sk_odata;\n\tsk->sk_write_space = svsk->sk_owspace;\n\tsk->sk_user_data = NULL;\n\trelease_sock(sk);\n}\n\n \nstatic void svc_tcp_sock_detach(struct svc_xprt *xprt)\n{\n\tstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\n\n\ttls_handshake_close(svsk->sk_sock);\n\n\tsvc_sock_detach(xprt);\n\n\tif (!test_bit(XPT_LISTENER, &xprt->xpt_flags)) {\n\t\tsvc_tcp_clear_pages(svsk);\n\t\tkernel_sock_shutdown(svsk->sk_sock, SHUT_RDWR);\n\t}\n}\n\n \nstatic void svc_sock_free(struct svc_xprt *xprt)\n{\n\tstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\n\tstruct page_frag_cache *pfc = &svsk->sk_frag_cache;\n\tstruct socket *sock = svsk->sk_sock;\n\n\ttrace_svcsock_free(svsk, sock);\n\n\ttls_handshake_cancel(sock->sk);\n\tif (sock->file)\n\t\tsockfd_put(sock);\n\telse\n\t\tsock_release(sock);\n\tif (pfc->va)\n\t\t__page_frag_cache_drain(virt_to_head_page(pfc->va),\n\t\t\t\t\tpfc->pagecnt_bias);\n\tkfree(svsk);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}