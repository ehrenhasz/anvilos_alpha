{
  "module_name": "xdr.c",
  "hash_id": "ea1839234e74dcc8477709299202e35f615866821929f54794b900c8aa227ded",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/xdr.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/errno.h>\n#include <linux/sunrpc/xdr.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/bvec.h>\n#include <trace/events/sunrpc.h>\n\nstatic void _copy_to_pages(struct page **, size_t, const char *, size_t);\n\n\n \n__be32 *\nxdr_encode_netobj(__be32 *p, const struct xdr_netobj *obj)\n{\n\tunsigned int\tquadlen = XDR_QUADLEN(obj->len);\n\n\tp[quadlen] = 0;\t\t \n\t*p++ = cpu_to_be32(obj->len);\n\tmemcpy(p, obj->data, obj->len);\n\treturn p + XDR_QUADLEN(obj->len);\n}\nEXPORT_SYMBOL_GPL(xdr_encode_netobj);\n\n__be32 *\nxdr_decode_netobj(__be32 *p, struct xdr_netobj *obj)\n{\n\tunsigned int\tlen;\n\n\tif ((len = be32_to_cpu(*p++)) > XDR_MAX_NETOBJ)\n\t\treturn NULL;\n\tobj->len  = len;\n\tobj->data = (u8 *) p;\n\treturn p + XDR_QUADLEN(len);\n}\nEXPORT_SYMBOL_GPL(xdr_decode_netobj);\n\n \n__be32 *xdr_encode_opaque_fixed(__be32 *p, const void *ptr, unsigned int nbytes)\n{\n\tif (likely(nbytes != 0)) {\n\t\tunsigned int quadlen = XDR_QUADLEN(nbytes);\n\t\tunsigned int padding = (quadlen << 2) - nbytes;\n\n\t\tif (ptr != NULL)\n\t\t\tmemcpy(p, ptr, nbytes);\n\t\tif (padding != 0)\n\t\t\tmemset((char *)p + nbytes, 0, padding);\n\t\tp += quadlen;\n\t}\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(xdr_encode_opaque_fixed);\n\n \n__be32 *xdr_encode_opaque(__be32 *p, const void *ptr, unsigned int nbytes)\n{\n\t*p++ = cpu_to_be32(nbytes);\n\treturn xdr_encode_opaque_fixed(p, ptr, nbytes);\n}\nEXPORT_SYMBOL_GPL(xdr_encode_opaque);\n\n__be32 *\nxdr_encode_string(__be32 *p, const char *string)\n{\n\treturn xdr_encode_array(p, string, strlen(string));\n}\nEXPORT_SYMBOL_GPL(xdr_encode_string);\n\n__be32 *\nxdr_decode_string_inplace(__be32 *p, char **sp,\n\t\t\t  unsigned int *lenp, unsigned int maxlen)\n{\n\tu32 len;\n\n\tlen = be32_to_cpu(*p++);\n\tif (len > maxlen)\n\t\treturn NULL;\n\t*lenp = len;\n\t*sp = (char *) p;\n\treturn p + XDR_QUADLEN(len);\n}\nEXPORT_SYMBOL_GPL(xdr_decode_string_inplace);\n\n \nvoid xdr_terminate_string(const struct xdr_buf *buf, const u32 len)\n{\n\tchar *kaddr;\n\n\tkaddr = kmap_atomic(buf->pages[0]);\n\tkaddr[buf->page_base + len] = '\\0';\n\tkunmap_atomic(kaddr);\n}\nEXPORT_SYMBOL_GPL(xdr_terminate_string);\n\nsize_t xdr_buf_pagecount(const struct xdr_buf *buf)\n{\n\tif (!buf->page_len)\n\t\treturn 0;\n\treturn (buf->page_base + buf->page_len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n}\n\nint\nxdr_alloc_bvec(struct xdr_buf *buf, gfp_t gfp)\n{\n\tsize_t i, n = xdr_buf_pagecount(buf);\n\n\tif (n != 0 && buf->bvec == NULL) {\n\t\tbuf->bvec = kmalloc_array(n, sizeof(buf->bvec[0]), gfp);\n\t\tif (!buf->bvec)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tbvec_set_page(&buf->bvec[i], buf->pages[i], PAGE_SIZE,\n\t\t\t\t      0);\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid\nxdr_free_bvec(struct xdr_buf *buf)\n{\n\tkfree(buf->bvec);\n\tbuf->bvec = NULL;\n}\n\n \nunsigned int xdr_buf_to_bvec(struct bio_vec *bvec, unsigned int bvec_size,\n\t\t\t     const struct xdr_buf *xdr)\n{\n\tconst struct kvec *head = xdr->head;\n\tconst struct kvec *tail = xdr->tail;\n\tunsigned int count = 0;\n\n\tif (head->iov_len) {\n\t\tbvec_set_virt(bvec++, head->iov_base, head->iov_len);\n\t\t++count;\n\t}\n\n\tif (xdr->page_len) {\n\t\tunsigned int offset, len, remaining;\n\t\tstruct page **pages = xdr->pages;\n\n\t\toffset = offset_in_page(xdr->page_base);\n\t\tremaining = xdr->page_len;\n\t\twhile (remaining > 0) {\n\t\t\tlen = min_t(unsigned int, remaining,\n\t\t\t\t    PAGE_SIZE - offset);\n\t\t\tbvec_set_page(bvec++, *pages++, len, offset);\n\t\t\tremaining -= len;\n\t\t\toffset = 0;\n\t\t\tif (unlikely(++count > bvec_size))\n\t\t\t\tgoto bvec_overflow;\n\t\t}\n\t}\n\n\tif (tail->iov_len) {\n\t\tbvec_set_virt(bvec, tail->iov_base, tail->iov_len);\n\t\tif (unlikely(++count > bvec_size))\n\t\t\tgoto bvec_overflow;\n\t}\n\n\treturn count;\n\nbvec_overflow:\n\tpr_warn_once(\"%s: bio_vec array overflow\\n\", __func__);\n\treturn count - 1;\n}\n\n \nvoid\nxdr_inline_pages(struct xdr_buf *xdr, unsigned int offset,\n\t\t struct page **pages, unsigned int base, unsigned int len)\n{\n\tstruct kvec *head = xdr->head;\n\tstruct kvec *tail = xdr->tail;\n\tchar *buf = (char *)head->iov_base;\n\tunsigned int buflen = head->iov_len;\n\n\thead->iov_len  = offset;\n\n\txdr->pages = pages;\n\txdr->page_base = base;\n\txdr->page_len = len;\n\n\ttail->iov_base = buf + offset;\n\ttail->iov_len = buflen - offset;\n\txdr->buflen += len;\n}\nEXPORT_SYMBOL_GPL(xdr_inline_pages);\n\n \n\n \nstatic void\n_shift_data_left_pages(struct page **pages, size_t pgto_base,\n\t\t\tsize_t pgfrom_base, size_t len)\n{\n\tstruct page **pgfrom, **pgto;\n\tchar *vfrom, *vto;\n\tsize_t copy;\n\n\tBUG_ON(pgfrom_base <= pgto_base);\n\n\tif (!len)\n\t\treturn;\n\n\tpgto = pages + (pgto_base >> PAGE_SHIFT);\n\tpgfrom = pages + (pgfrom_base >> PAGE_SHIFT);\n\n\tpgto_base &= ~PAGE_MASK;\n\tpgfrom_base &= ~PAGE_MASK;\n\n\tdo {\n\t\tif (pgto_base >= PAGE_SIZE) {\n\t\t\tpgto_base = 0;\n\t\t\tpgto++;\n\t\t}\n\t\tif (pgfrom_base >= PAGE_SIZE){\n\t\t\tpgfrom_base = 0;\n\t\t\tpgfrom++;\n\t\t}\n\n\t\tcopy = len;\n\t\tif (copy > (PAGE_SIZE - pgto_base))\n\t\t\tcopy = PAGE_SIZE - pgto_base;\n\t\tif (copy > (PAGE_SIZE - pgfrom_base))\n\t\t\tcopy = PAGE_SIZE - pgfrom_base;\n\n\t\tvto = kmap_atomic(*pgto);\n\t\tif (*pgto != *pgfrom) {\n\t\t\tvfrom = kmap_atomic(*pgfrom);\n\t\t\tmemcpy(vto + pgto_base, vfrom + pgfrom_base, copy);\n\t\t\tkunmap_atomic(vfrom);\n\t\t} else\n\t\t\tmemmove(vto + pgto_base, vto + pgfrom_base, copy);\n\t\tflush_dcache_page(*pgto);\n\t\tkunmap_atomic(vto);\n\n\t\tpgto_base += copy;\n\t\tpgfrom_base += copy;\n\n\t} while ((len -= copy) != 0);\n}\n\n \nstatic void\n_shift_data_right_pages(struct page **pages, size_t pgto_base,\n\t\tsize_t pgfrom_base, size_t len)\n{\n\tstruct page **pgfrom, **pgto;\n\tchar *vfrom, *vto;\n\tsize_t copy;\n\n\tBUG_ON(pgto_base <= pgfrom_base);\n\n\tif (!len)\n\t\treturn;\n\n\tpgto_base += len;\n\tpgfrom_base += len;\n\n\tpgto = pages + (pgto_base >> PAGE_SHIFT);\n\tpgfrom = pages + (pgfrom_base >> PAGE_SHIFT);\n\n\tpgto_base &= ~PAGE_MASK;\n\tpgfrom_base &= ~PAGE_MASK;\n\n\tdo {\n\t\t \n\t\tif (pgto_base == 0) {\n\t\t\tpgto_base = PAGE_SIZE;\n\t\t\tpgto--;\n\t\t}\n\t\tif (pgfrom_base == 0) {\n\t\t\tpgfrom_base = PAGE_SIZE;\n\t\t\tpgfrom--;\n\t\t}\n\n\t\tcopy = len;\n\t\tif (copy > pgto_base)\n\t\t\tcopy = pgto_base;\n\t\tif (copy > pgfrom_base)\n\t\t\tcopy = pgfrom_base;\n\t\tpgto_base -= copy;\n\t\tpgfrom_base -= copy;\n\n\t\tvto = kmap_atomic(*pgto);\n\t\tif (*pgto != *pgfrom) {\n\t\t\tvfrom = kmap_atomic(*pgfrom);\n\t\t\tmemcpy(vto + pgto_base, vfrom + pgfrom_base, copy);\n\t\t\tkunmap_atomic(vfrom);\n\t\t} else\n\t\t\tmemmove(vto + pgto_base, vto + pgfrom_base, copy);\n\t\tflush_dcache_page(*pgto);\n\t\tkunmap_atomic(vto);\n\n\t} while ((len -= copy) != 0);\n}\n\n \nstatic void\n_copy_to_pages(struct page **pages, size_t pgbase, const char *p, size_t len)\n{\n\tstruct page **pgto;\n\tchar *vto;\n\tsize_t copy;\n\n\tif (!len)\n\t\treturn;\n\n\tpgto = pages + (pgbase >> PAGE_SHIFT);\n\tpgbase &= ~PAGE_MASK;\n\n\tfor (;;) {\n\t\tcopy = PAGE_SIZE - pgbase;\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tvto = kmap_atomic(*pgto);\n\t\tmemcpy(vto + pgbase, p, copy);\n\t\tkunmap_atomic(vto);\n\n\t\tlen -= copy;\n\t\tif (len == 0)\n\t\t\tbreak;\n\n\t\tpgbase += copy;\n\t\tif (pgbase == PAGE_SIZE) {\n\t\t\tflush_dcache_page(*pgto);\n\t\t\tpgbase = 0;\n\t\t\tpgto++;\n\t\t}\n\t\tp += copy;\n\t}\n\tflush_dcache_page(*pgto);\n}\n\n \nvoid\n_copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\n{\n\tstruct page **pgfrom;\n\tchar *vfrom;\n\tsize_t copy;\n\n\tif (!len)\n\t\treturn;\n\n\tpgfrom = pages + (pgbase >> PAGE_SHIFT);\n\tpgbase &= ~PAGE_MASK;\n\n\tdo {\n\t\tcopy = PAGE_SIZE - pgbase;\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\n\t\tvfrom = kmap_atomic(*pgfrom);\n\t\tmemcpy(p, vfrom + pgbase, copy);\n\t\tkunmap_atomic(vfrom);\n\n\t\tpgbase += copy;\n\t\tif (pgbase == PAGE_SIZE) {\n\t\t\tpgbase = 0;\n\t\t\tpgfrom++;\n\t\t}\n\t\tp += copy;\n\n\t} while ((len -= copy) != 0);\n}\nEXPORT_SYMBOL_GPL(_copy_from_pages);\n\nstatic void xdr_buf_iov_zero(const struct kvec *iov, unsigned int base,\n\t\t\t     unsigned int len)\n{\n\tif (base >= iov->iov_len)\n\t\treturn;\n\tif (len > iov->iov_len - base)\n\t\tlen = iov->iov_len - base;\n\tmemset(iov->iov_base + base, 0, len);\n}\n\n \nstatic void xdr_buf_pages_zero(const struct xdr_buf *buf, unsigned int pgbase,\n\t\t\t       unsigned int len)\n{\n\tstruct page **pages = buf->pages;\n\tstruct page **page;\n\tchar *vpage;\n\tunsigned int zero;\n\n\tif (!len)\n\t\treturn;\n\tif (pgbase >= buf->page_len) {\n\t\txdr_buf_iov_zero(buf->tail, pgbase - buf->page_len, len);\n\t\treturn;\n\t}\n\tif (pgbase + len > buf->page_len) {\n\t\txdr_buf_iov_zero(buf->tail, 0, pgbase + len - buf->page_len);\n\t\tlen = buf->page_len - pgbase;\n\t}\n\n\tpgbase += buf->page_base;\n\n\tpage = pages + (pgbase >> PAGE_SHIFT);\n\tpgbase &= ~PAGE_MASK;\n\n\tdo {\n\t\tzero = PAGE_SIZE - pgbase;\n\t\tif (zero > len)\n\t\t\tzero = len;\n\n\t\tvpage = kmap_atomic(*page);\n\t\tmemset(vpage + pgbase, 0, zero);\n\t\tkunmap_atomic(vpage);\n\n\t\tflush_dcache_page(*page);\n\t\tpgbase = 0;\n\t\tpage++;\n\n\t} while ((len -= zero) != 0);\n}\n\nstatic unsigned int xdr_buf_pages_fill_sparse(const struct xdr_buf *buf,\n\t\t\t\t\t      unsigned int buflen, gfp_t gfp)\n{\n\tunsigned int i, npages, pagelen;\n\n\tif (!(buf->flags & XDRBUF_SPARSE_PAGES))\n\t\treturn buflen;\n\tif (buflen <= buf->head->iov_len)\n\t\treturn buflen;\n\tpagelen = buflen - buf->head->iov_len;\n\tif (pagelen > buf->page_len)\n\t\tpagelen = buf->page_len;\n\tnpages = (pagelen + buf->page_base + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tfor (i = 0; i < npages; i++) {\n\t\tif (!buf->pages[i])\n\t\t\tcontinue;\n\t\tbuf->pages[i] = alloc_page(gfp);\n\t\tif (likely(buf->pages[i]))\n\t\t\tcontinue;\n\t\tbuflen -= pagelen;\n\t\tpagelen = i << PAGE_SHIFT;\n\t\tif (pagelen > buf->page_base)\n\t\t\tbuflen += pagelen - buf->page_base;\n\t\tbreak;\n\t}\n\treturn buflen;\n}\n\nstatic void xdr_buf_try_expand(struct xdr_buf *buf, unsigned int len)\n{\n\tstruct kvec *head = buf->head;\n\tstruct kvec *tail = buf->tail;\n\tunsigned int sum = head->iov_len + buf->page_len + tail->iov_len;\n\tunsigned int free_space, newlen;\n\n\tif (sum > buf->len) {\n\t\tfree_space = min_t(unsigned int, sum - buf->len, len);\n\t\tnewlen = xdr_buf_pages_fill_sparse(buf, buf->len + free_space,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tfree_space = newlen - buf->len;\n\t\tbuf->len = newlen;\n\t\tlen -= free_space;\n\t\tif (!len)\n\t\t\treturn;\n\t}\n\n\tif (buf->buflen > sum) {\n\t\t \n\t\tfree_space = min_t(unsigned int, buf->buflen - sum, len);\n\t\ttail->iov_len += free_space;\n\t\tbuf->len += free_space;\n\t}\n}\n\nstatic void xdr_buf_tail_copy_right(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tconst struct kvec *tail = buf->tail;\n\tunsigned int to = base + shift;\n\n\tif (to >= tail->iov_len)\n\t\treturn;\n\tif (len + to > tail->iov_len)\n\t\tlen = tail->iov_len - to;\n\tmemmove(tail->iov_base + to, tail->iov_base + base, len);\n}\n\nstatic void xdr_buf_pages_copy_right(const struct xdr_buf *buf,\n\t\t\t\t     unsigned int base, unsigned int len,\n\t\t\t\t     unsigned int shift)\n{\n\tconst struct kvec *tail = buf->tail;\n\tunsigned int to = base + shift;\n\tunsigned int pglen = 0;\n\tunsigned int talen = 0, tato = 0;\n\n\tif (base >= buf->page_len)\n\t\treturn;\n\tif (len > buf->page_len - base)\n\t\tlen = buf->page_len - base;\n\tif (to >= buf->page_len) {\n\t\ttato = to - buf->page_len;\n\t\tif (tail->iov_len >= len + tato)\n\t\t\ttalen = len;\n\t\telse if (tail->iov_len > tato)\n\t\t\ttalen = tail->iov_len - tato;\n\t} else if (len + to >= buf->page_len) {\n\t\tpglen = buf->page_len - to;\n\t\ttalen = len - pglen;\n\t\tif (talen > tail->iov_len)\n\t\t\ttalen = tail->iov_len;\n\t} else\n\t\tpglen = len;\n\n\t_copy_from_pages(tail->iov_base + tato, buf->pages,\n\t\t\t buf->page_base + base + pglen, talen);\n\t_shift_data_right_pages(buf->pages, buf->page_base + to,\n\t\t\t\tbuf->page_base + base, pglen);\n}\n\nstatic void xdr_buf_head_copy_right(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tconst struct kvec *head = buf->head;\n\tconst struct kvec *tail = buf->tail;\n\tunsigned int to = base + shift;\n\tunsigned int pglen = 0, pgto = 0;\n\tunsigned int talen = 0, tato = 0;\n\n\tif (base >= head->iov_len)\n\t\treturn;\n\tif (len > head->iov_len - base)\n\t\tlen = head->iov_len - base;\n\tif (to >= buf->page_len + head->iov_len) {\n\t\ttato = to - buf->page_len - head->iov_len;\n\t\ttalen = len;\n\t} else if (to >= head->iov_len) {\n\t\tpgto = to - head->iov_len;\n\t\tpglen = len;\n\t\tif (pgto + pglen > buf->page_len) {\n\t\t\ttalen = pgto + pglen - buf->page_len;\n\t\t\tpglen -= talen;\n\t\t}\n\t} else {\n\t\tpglen = len - to;\n\t\tif (pglen > buf->page_len) {\n\t\t\ttalen = pglen - buf->page_len;\n\t\t\tpglen = buf->page_len;\n\t\t}\n\t}\n\n\tlen -= talen;\n\tbase += len;\n\tif (talen + tato > tail->iov_len)\n\t\ttalen = tail->iov_len > tato ? tail->iov_len - tato : 0;\n\tmemcpy(tail->iov_base + tato, head->iov_base + base, talen);\n\n\tlen -= pglen;\n\tbase -= pglen;\n\t_copy_to_pages(buf->pages, buf->page_base + pgto, head->iov_base + base,\n\t\t       pglen);\n\n\tbase -= len;\n\tmemmove(head->iov_base + to, head->iov_base + base, len);\n}\n\nstatic void xdr_buf_tail_shift_right(const struct xdr_buf *buf,\n\t\t\t\t     unsigned int base, unsigned int len,\n\t\t\t\t     unsigned int shift)\n{\n\tconst struct kvec *tail = buf->tail;\n\n\tif (base >= tail->iov_len || !shift || !len)\n\t\treturn;\n\txdr_buf_tail_copy_right(buf, base, len, shift);\n}\n\nstatic void xdr_buf_pages_shift_right(const struct xdr_buf *buf,\n\t\t\t\t      unsigned int base, unsigned int len,\n\t\t\t\t      unsigned int shift)\n{\n\tif (!shift || !len)\n\t\treturn;\n\tif (base >= buf->page_len) {\n\t\txdr_buf_tail_shift_right(buf, base - buf->page_len, len, shift);\n\t\treturn;\n\t}\n\tif (base + len > buf->page_len)\n\t\txdr_buf_tail_shift_right(buf, 0, base + len - buf->page_len,\n\t\t\t\t\t shift);\n\txdr_buf_pages_copy_right(buf, base, len, shift);\n}\n\nstatic void xdr_buf_head_shift_right(const struct xdr_buf *buf,\n\t\t\t\t     unsigned int base, unsigned int len,\n\t\t\t\t     unsigned int shift)\n{\n\tconst struct kvec *head = buf->head;\n\n\tif (!shift)\n\t\treturn;\n\tif (base >= head->iov_len) {\n\t\txdr_buf_pages_shift_right(buf, head->iov_len - base, len,\n\t\t\t\t\t  shift);\n\t\treturn;\n\t}\n\tif (base + len > head->iov_len)\n\t\txdr_buf_pages_shift_right(buf, 0, base + len - head->iov_len,\n\t\t\t\t\t  shift);\n\txdr_buf_head_copy_right(buf, base, len, shift);\n}\n\nstatic void xdr_buf_tail_copy_left(const struct xdr_buf *buf, unsigned int base,\n\t\t\t\t   unsigned int len, unsigned int shift)\n{\n\tconst struct kvec *tail = buf->tail;\n\n\tif (base >= tail->iov_len)\n\t\treturn;\n\tif (len > tail->iov_len - base)\n\t\tlen = tail->iov_len - base;\n\t \n\tif (shift > buf->page_len + base) {\n\t\tconst struct kvec *head = buf->head;\n\t\tunsigned int hdto =\n\t\t\thead->iov_len + buf->page_len + base - shift;\n\t\tunsigned int hdlen = len;\n\n\t\tif (WARN_ONCE(shift > head->iov_len + buf->page_len + base,\n\t\t\t      \"SUNRPC: Misaligned data.\\n\"))\n\t\t\treturn;\n\t\tif (hdto + hdlen > head->iov_len)\n\t\t\thdlen = head->iov_len - hdto;\n\t\tmemcpy(head->iov_base + hdto, tail->iov_base + base, hdlen);\n\t\tbase += hdlen;\n\t\tlen -= hdlen;\n\t\tif (!len)\n\t\t\treturn;\n\t}\n\t \n\tif (shift > base) {\n\t\tunsigned int pgto = buf->page_len + base - shift;\n\t\tunsigned int pglen = len;\n\n\t\tif (pgto + pglen > buf->page_len)\n\t\t\tpglen = buf->page_len - pgto;\n\t\t_copy_to_pages(buf->pages, buf->page_base + pgto,\n\t\t\t       tail->iov_base + base, pglen);\n\t\tbase += pglen;\n\t\tlen -= pglen;\n\t\tif (!len)\n\t\t\treturn;\n\t}\n\tmemmove(tail->iov_base + base - shift, tail->iov_base + base, len);\n}\n\nstatic void xdr_buf_pages_copy_left(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tunsigned int pgto;\n\n\tif (base >= buf->page_len)\n\t\treturn;\n\tif (len > buf->page_len - base)\n\t\tlen = buf->page_len - base;\n\t \n\tif (shift > base) {\n\t\tconst struct kvec *head = buf->head;\n\t\tunsigned int hdto = head->iov_len + base - shift;\n\t\tunsigned int hdlen = len;\n\n\t\tif (WARN_ONCE(shift > head->iov_len + base,\n\t\t\t      \"SUNRPC: Misaligned data.\\n\"))\n\t\t\treturn;\n\t\tif (hdto + hdlen > head->iov_len)\n\t\t\thdlen = head->iov_len - hdto;\n\t\t_copy_from_pages(head->iov_base + hdto, buf->pages,\n\t\t\t\t buf->page_base + base, hdlen);\n\t\tbase += hdlen;\n\t\tlen -= hdlen;\n\t\tif (!len)\n\t\t\treturn;\n\t}\n\tpgto = base - shift;\n\t_shift_data_left_pages(buf->pages, buf->page_base + pgto,\n\t\t\t       buf->page_base + base, len);\n}\n\nstatic void xdr_buf_tail_shift_left(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tif (!shift || !len)\n\t\treturn;\n\txdr_buf_tail_copy_left(buf, base, len, shift);\n}\n\nstatic void xdr_buf_pages_shift_left(const struct xdr_buf *buf,\n\t\t\t\t     unsigned int base, unsigned int len,\n\t\t\t\t     unsigned int shift)\n{\n\tif (!shift || !len)\n\t\treturn;\n\tif (base >= buf->page_len) {\n\t\txdr_buf_tail_shift_left(buf, base - buf->page_len, len, shift);\n\t\treturn;\n\t}\n\txdr_buf_pages_copy_left(buf, base, len, shift);\n\tlen += base;\n\tif (len <= buf->page_len)\n\t\treturn;\n\txdr_buf_tail_copy_left(buf, 0, len - buf->page_len, shift);\n}\n\nstatic void xdr_buf_head_shift_left(const struct xdr_buf *buf,\n\t\t\t\t    unsigned int base, unsigned int len,\n\t\t\t\t    unsigned int shift)\n{\n\tconst struct kvec *head = buf->head;\n\tunsigned int bytes;\n\n\tif (!shift || !len)\n\t\treturn;\n\n\tif (shift > base) {\n\t\tbytes = (shift - base);\n\t\tif (bytes >= len)\n\t\t\treturn;\n\t\tbase += bytes;\n\t\tlen -= bytes;\n\t}\n\n\tif (base < head->iov_len) {\n\t\tbytes = min_t(unsigned int, len, head->iov_len - base);\n\t\tmemmove(head->iov_base + (base - shift),\n\t\t\thead->iov_base + base, bytes);\n\t\tbase += bytes;\n\t\tlen -= bytes;\n\t}\n\txdr_buf_pages_shift_left(buf, base - head->iov_len, len, shift);\n}\n\n \nstatic unsigned int xdr_shrink_bufhead(struct xdr_buf *buf, unsigned int len)\n{\n\tstruct kvec *head = buf->head;\n\tunsigned int shift, buflen = max(buf->len, len);\n\n\tWARN_ON_ONCE(len > head->iov_len);\n\tif (head->iov_len > buflen) {\n\t\tbuf->buflen -= head->iov_len - buflen;\n\t\thead->iov_len = buflen;\n\t}\n\tif (len >= head->iov_len)\n\t\treturn 0;\n\tshift = head->iov_len - len;\n\txdr_buf_try_expand(buf, shift);\n\txdr_buf_head_shift_right(buf, len, buflen - len, shift);\n\thead->iov_len = len;\n\tbuf->buflen -= shift;\n\tbuf->len -= shift;\n\treturn shift;\n}\n\n \nstatic unsigned int xdr_shrink_pagelen(struct xdr_buf *buf, unsigned int len)\n{\n\tunsigned int shift, buflen = buf->len - buf->head->iov_len;\n\n\tWARN_ON_ONCE(len > buf->page_len);\n\tif (buf->head->iov_len >= buf->len || len > buflen)\n\t\tbuflen = len;\n\tif (buf->page_len > buflen) {\n\t\tbuf->buflen -= buf->page_len - buflen;\n\t\tbuf->page_len = buflen;\n\t}\n\tif (len >= buf->page_len)\n\t\treturn 0;\n\tshift = buf->page_len - len;\n\txdr_buf_try_expand(buf, shift);\n\txdr_buf_pages_shift_right(buf, len, buflen - len, shift);\n\tbuf->page_len = len;\n\tbuf->len -= shift;\n\tbuf->buflen -= shift;\n\treturn shift;\n}\n\n \nunsigned int xdr_stream_pos(const struct xdr_stream *xdr)\n{\n\treturn (unsigned int)(XDR_QUADLEN(xdr->buf->len) - xdr->nwords) << 2;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_pos);\n\nstatic void xdr_stream_set_pos(struct xdr_stream *xdr, unsigned int pos)\n{\n\tunsigned int blen = xdr->buf->len;\n\n\txdr->nwords = blen > pos ? XDR_QUADLEN(blen) - XDR_QUADLEN(pos) : 0;\n}\n\nstatic void xdr_stream_page_set_pos(struct xdr_stream *xdr, unsigned int pos)\n{\n\txdr_stream_set_pos(xdr, pos + xdr->buf->head[0].iov_len);\n}\n\n \nunsigned int xdr_page_pos(const struct xdr_stream *xdr)\n{\n\tunsigned int pos = xdr_stream_pos(xdr);\n\n\tWARN_ON(pos < xdr->buf->head[0].iov_len);\n\treturn pos - xdr->buf->head[0].iov_len;\n}\nEXPORT_SYMBOL_GPL(xdr_page_pos);\n\n \nvoid xdr_init_encode(struct xdr_stream *xdr, struct xdr_buf *buf, __be32 *p,\n\t\t     struct rpc_rqst *rqst)\n{\n\tstruct kvec *iov = buf->head;\n\tint scratch_len = buf->buflen - buf->page_len - buf->tail[0].iov_len;\n\n\txdr_reset_scratch_buffer(xdr);\n\tBUG_ON(scratch_len < 0);\n\txdr->buf = buf;\n\txdr->iov = iov;\n\txdr->p = (__be32 *)((char *)iov->iov_base + iov->iov_len);\n\txdr->end = (__be32 *)((char *)iov->iov_base + scratch_len);\n\tBUG_ON(iov->iov_len > scratch_len);\n\n\tif (p != xdr->p && p != NULL) {\n\t\tsize_t len;\n\n\t\tBUG_ON(p < xdr->p || p > xdr->end);\n\t\tlen = (char *)p - (char *)xdr->p;\n\t\txdr->p = p;\n\t\tbuf->len += len;\n\t\tiov->iov_len += len;\n\t}\n\txdr->rqst = rqst;\n}\nEXPORT_SYMBOL_GPL(xdr_init_encode);\n\n \nvoid xdr_init_encode_pages(struct xdr_stream *xdr, struct xdr_buf *buf,\n\t\t\t   struct page **pages, struct rpc_rqst *rqst)\n{\n\txdr_reset_scratch_buffer(xdr);\n\n\txdr->buf = buf;\n\txdr->page_ptr = pages;\n\txdr->iov = NULL;\n\txdr->p = page_address(*pages);\n\txdr->end = (void *)xdr->p + min_t(u32, buf->buflen, PAGE_SIZE);\n\txdr->rqst = rqst;\n}\nEXPORT_SYMBOL_GPL(xdr_init_encode_pages);\n\n \nvoid __xdr_commit_encode(struct xdr_stream *xdr)\n{\n\tsize_t shift = xdr->scratch.iov_len;\n\tvoid *page;\n\n\tpage = page_address(*xdr->page_ptr);\n\tmemcpy(xdr->scratch.iov_base, page, shift);\n\tmemmove(page, page + shift, (void *)xdr->p - page);\n\txdr_reset_scratch_buffer(xdr);\n}\nEXPORT_SYMBOL_GPL(__xdr_commit_encode);\n\n \nstatic noinline __be32 *xdr_get_next_encode_buffer(struct xdr_stream *xdr,\n\t\t\t\t\t\t   size_t nbytes)\n{\n\tint space_left;\n\tint frag1bytes, frag2bytes;\n\tvoid *p;\n\n\tif (nbytes > PAGE_SIZE)\n\t\tgoto out_overflow;  \n\tif (xdr->buf->len + nbytes > xdr->buf->buflen)\n\t\tgoto out_overflow;  \n\tfrag1bytes = (xdr->end - xdr->p) << 2;\n\tfrag2bytes = nbytes - frag1bytes;\n\tif (xdr->iov)\n\t\txdr->iov->iov_len += frag1bytes;\n\telse\n\t\txdr->buf->page_len += frag1bytes;\n\txdr->page_ptr++;\n\txdr->iov = NULL;\n\n\t \n\txdr_set_scratch_buffer(xdr, xdr->p, frag1bytes);\n\n\t \n\tp = page_address(*xdr->page_ptr);\n\txdr->p = p + frag2bytes;\n\tspace_left = xdr->buf->buflen - xdr->buf->len;\n\tif (space_left - frag1bytes >= PAGE_SIZE)\n\t\txdr->end = p + PAGE_SIZE;\n\telse\n\t\txdr->end = p + space_left - frag1bytes;\n\n\txdr->buf->page_len += frag2bytes;\n\txdr->buf->len += nbytes;\n\treturn p;\nout_overflow:\n\ttrace_rpc_xdr_overflow(xdr, nbytes);\n\treturn NULL;\n}\n\n \n__be32 * xdr_reserve_space(struct xdr_stream *xdr, size_t nbytes)\n{\n\t__be32 *p = xdr->p;\n\t__be32 *q;\n\n\txdr_commit_encode(xdr);\n\t \n\tnbytes += 3;\n\tnbytes &= ~3;\n\tq = p + (nbytes >> 2);\n\tif (unlikely(q > xdr->end || q < p))\n\t\treturn xdr_get_next_encode_buffer(xdr, nbytes);\n\txdr->p = q;\n\tif (xdr->iov)\n\t\txdr->iov->iov_len += nbytes;\n\telse\n\t\txdr->buf->page_len += nbytes;\n\txdr->buf->len += nbytes;\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(xdr_reserve_space);\n\n \nint xdr_reserve_space_vec(struct xdr_stream *xdr, size_t nbytes)\n{\n\tsize_t thislen;\n\t__be32 *p;\n\n\t \n\tif (xdr->iov == xdr->buf->head) {\n\t\txdr->iov = NULL;\n\t\txdr->end = xdr->p;\n\t}\n\n\t \n\twhile (nbytes) {\n\t\tthislen = xdr->buf->page_len % PAGE_SIZE;\n\t\tthislen = min_t(size_t, nbytes, PAGE_SIZE - thislen);\n\n\t\tp = xdr_reserve_space(xdr, thislen);\n\t\tif (!p)\n\t\t\treturn -EMSGSIZE;\n\n\t\tnbytes -= thislen;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xdr_reserve_space_vec);\n\n \nvoid xdr_truncate_encode(struct xdr_stream *xdr, size_t len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tstruct kvec *head = buf->head;\n\tstruct kvec *tail = buf->tail;\n\tint fraglen;\n\tint new;\n\n\tif (len > buf->len) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\txdr_commit_encode(xdr);\n\n\tfraglen = min_t(int, buf->len - len, tail->iov_len);\n\ttail->iov_len -= fraglen;\n\tbuf->len -= fraglen;\n\tif (tail->iov_len) {\n\t\txdr->p = tail->iov_base + tail->iov_len;\n\t\tWARN_ON_ONCE(!xdr->end);\n\t\tWARN_ON_ONCE(!xdr->iov);\n\t\treturn;\n\t}\n\tWARN_ON_ONCE(fraglen);\n\tfraglen = min_t(int, buf->len - len, buf->page_len);\n\tbuf->page_len -= fraglen;\n\tbuf->len -= fraglen;\n\n\tnew = buf->page_base + buf->page_len;\n\n\txdr->page_ptr = buf->pages + (new >> PAGE_SHIFT);\n\n\tif (buf->page_len) {\n\t\txdr->p = page_address(*xdr->page_ptr);\n\t\txdr->end = (void *)xdr->p + PAGE_SIZE;\n\t\txdr->p = (void *)xdr->p + (new % PAGE_SIZE);\n\t\tWARN_ON_ONCE(xdr->iov);\n\t\treturn;\n\t}\n\tif (fraglen)\n\t\txdr->end = head->iov_base + head->iov_len;\n\t \n\txdr->page_ptr--;\n\thead->iov_len = len;\n\tbuf->len = len;\n\txdr->p = head->iov_base + head->iov_len;\n\txdr->iov = buf->head;\n}\nEXPORT_SYMBOL(xdr_truncate_encode);\n\n \nvoid xdr_truncate_decode(struct xdr_stream *xdr, size_t len)\n{\n\tunsigned int nbytes = xdr_align_size(len);\n\n\txdr->buf->len -= nbytes;\n\txdr->nwords -= XDR_QUADLEN(nbytes);\n}\nEXPORT_SYMBOL_GPL(xdr_truncate_decode);\n\n \nint xdr_restrict_buflen(struct xdr_stream *xdr, int newbuflen)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tint left_in_this_buf = (void *)xdr->end - (void *)xdr->p;\n\tint end_offset = buf->len + left_in_this_buf;\n\n\tif (newbuflen < 0 || newbuflen < buf->len)\n\t\treturn -1;\n\tif (newbuflen > buf->buflen)\n\t\treturn 0;\n\tif (newbuflen < end_offset)\n\t\txdr->end = (void *)xdr->end + newbuflen - end_offset;\n\tbuf->buflen = newbuflen;\n\treturn 0;\n}\nEXPORT_SYMBOL(xdr_restrict_buflen);\n\n \nvoid xdr_write_pages(struct xdr_stream *xdr, struct page **pages, unsigned int base,\n\t\t unsigned int len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tstruct kvec *tail = buf->tail;\n\n\tbuf->pages = pages;\n\tbuf->page_base = base;\n\tbuf->page_len = len;\n\n\ttail->iov_base = xdr->p;\n\ttail->iov_len = 0;\n\txdr->iov = tail;\n\n\tif (len & 3) {\n\t\tunsigned int pad = 4 - (len & 3);\n\n\t\tBUG_ON(xdr->p >= xdr->end);\n\t\ttail->iov_base = (char *)xdr->p + (len & 3);\n\t\ttail->iov_len += pad;\n\t\tlen += pad;\n\t\t*xdr->p++ = 0;\n\t}\n\tbuf->buflen += len;\n\tbuf->len += len;\n}\nEXPORT_SYMBOL_GPL(xdr_write_pages);\n\nstatic unsigned int xdr_set_iov(struct xdr_stream *xdr, struct kvec *iov,\n\t\t\t\tunsigned int base, unsigned int len)\n{\n\tif (len > iov->iov_len)\n\t\tlen = iov->iov_len;\n\tif (unlikely(base > len))\n\t\tbase = len;\n\txdr->p = (__be32*)(iov->iov_base + base);\n\txdr->end = (__be32*)(iov->iov_base + len);\n\txdr->iov = iov;\n\txdr->page_ptr = NULL;\n\treturn len - base;\n}\n\nstatic unsigned int xdr_set_tail_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\n\txdr_stream_set_pos(xdr, base + buf->page_len + buf->head->iov_len);\n\treturn xdr_set_iov(xdr, buf->tail, base, len);\n}\n\nstatic void xdr_stream_unmap_current_page(struct xdr_stream *xdr)\n{\n\tif (xdr->page_kaddr) {\n\t\tkunmap_local(xdr->page_kaddr);\n\t\txdr->page_kaddr = NULL;\n\t}\n}\n\nstatic unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen)\n\t\treturn 0;\n\telse\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\txdr_stream_unmap_current_page(xdr);\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\n\tif (PageHighMem(*xdr->page_ptr)) {\n\t\txdr->page_kaddr = kmap_local_page(*xdr->page_ptr);\n\t\tkaddr = xdr->page_kaddr;\n\t} else\n\t\tkaddr = page_address(*xdr->page_ptr);\n\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}\n\nstatic void xdr_set_page(struct xdr_stream *xdr, unsigned int base,\n\t\t\t unsigned int len)\n{\n\tif (xdr_set_page_base(xdr, base, len) == 0) {\n\t\tbase -= xdr->buf->page_len;\n\t\txdr_set_tail_base(xdr, base, len);\n\t}\n}\n\nstatic void xdr_set_next_page(struct xdr_stream *xdr)\n{\n\tunsigned int newbase;\n\n\tnewbase = (1 + xdr->page_ptr - xdr->buf->pages) << PAGE_SHIFT;\n\tnewbase -= xdr->buf->page_base;\n\tif (newbase < xdr->buf->page_len)\n\t\txdr_set_page_base(xdr, newbase, xdr_stream_remaining(xdr));\n\telse\n\t\txdr_set_tail_base(xdr, 0, xdr_stream_remaining(xdr));\n}\n\nstatic bool xdr_set_next_buffer(struct xdr_stream *xdr)\n{\n\tif (xdr->page_ptr != NULL)\n\t\txdr_set_next_page(xdr);\n\telse if (xdr->iov == xdr->buf->head)\n\t\txdr_set_page(xdr, 0, xdr_stream_remaining(xdr));\n\treturn xdr->p != xdr->end;\n}\n\n \nvoid xdr_init_decode(struct xdr_stream *xdr, struct xdr_buf *buf, __be32 *p,\n\t\t     struct rpc_rqst *rqst)\n{\n\txdr->buf = buf;\n\txdr->page_kaddr = NULL;\n\txdr_reset_scratch_buffer(xdr);\n\txdr->nwords = XDR_QUADLEN(buf->len);\n\tif (xdr_set_iov(xdr, buf->head, 0, buf->len) == 0 &&\n\t    xdr_set_page_base(xdr, 0, buf->len) == 0)\n\t\txdr_set_iov(xdr, buf->tail, 0, buf->len);\n\tif (p != NULL && p > xdr->p && xdr->end >= p) {\n\t\txdr->nwords -= p - xdr->p;\n\t\txdr->p = p;\n\t}\n\txdr->rqst = rqst;\n}\nEXPORT_SYMBOL_GPL(xdr_init_decode);\n\n \nvoid xdr_init_decode_pages(struct xdr_stream *xdr, struct xdr_buf *buf,\n\t\t\t   struct page **pages, unsigned int len)\n{\n\tmemset(buf, 0, sizeof(*buf));\n\tbuf->pages =  pages;\n\tbuf->page_len =  len;\n\tbuf->buflen =  len;\n\tbuf->len = len;\n\txdr_init_decode(xdr, buf, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(xdr_init_decode_pages);\n\n \nvoid xdr_finish_decode(struct xdr_stream *xdr)\n{\n\txdr_stream_unmap_current_page(xdr);\n}\nEXPORT_SYMBOL(xdr_finish_decode);\n\nstatic __be32 * __xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes)\n{\n\tunsigned int nwords = XDR_QUADLEN(nbytes);\n\t__be32 *p = xdr->p;\n\t__be32 *q = p + nwords;\n\n\tif (unlikely(nwords > xdr->nwords || q > xdr->end || q < p))\n\t\treturn NULL;\n\txdr->p = q;\n\txdr->nwords -= nwords;\n\treturn p;\n}\n\nstatic __be32 *xdr_copy_to_scratch(struct xdr_stream *xdr, size_t nbytes)\n{\n\t__be32 *p;\n\tchar *cpdest = xdr->scratch.iov_base;\n\tsize_t cplen = (char *)xdr->end - (char *)xdr->p;\n\n\tif (nbytes > xdr->scratch.iov_len)\n\t\tgoto out_overflow;\n\tp = __xdr_inline_decode(xdr, cplen);\n\tif (p == NULL)\n\t\treturn NULL;\n\tmemcpy(cpdest, p, cplen);\n\tif (!xdr_set_next_buffer(xdr))\n\t\tgoto out_overflow;\n\tcpdest += cplen;\n\tnbytes -= cplen;\n\tp = __xdr_inline_decode(xdr, nbytes);\n\tif (p == NULL)\n\t\treturn NULL;\n\tmemcpy(cpdest, p, nbytes);\n\treturn xdr->scratch.iov_base;\nout_overflow:\n\ttrace_rpc_xdr_overflow(xdr, nbytes);\n\treturn NULL;\n}\n\n \n__be32 * xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes)\n{\n\t__be32 *p;\n\n\tif (unlikely(nbytes == 0))\n\t\treturn xdr->p;\n\tif (xdr->p == xdr->end && !xdr_set_next_buffer(xdr))\n\t\tgoto out_overflow;\n\tp = __xdr_inline_decode(xdr, nbytes);\n\tif (p != NULL)\n\t\treturn p;\n\treturn xdr_copy_to_scratch(xdr, nbytes);\nout_overflow:\n\ttrace_rpc_xdr_overflow(xdr, nbytes);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(xdr_inline_decode);\n\nstatic void xdr_realign_pages(struct xdr_stream *xdr)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tstruct kvec *iov = buf->head;\n\tunsigned int cur = xdr_stream_pos(xdr);\n\tunsigned int copied;\n\n\t \n\tif (iov->iov_len > cur) {\n\t\tcopied = xdr_shrink_bufhead(buf, cur);\n\t\ttrace_rpc_xdr_alignment(xdr, cur, copied);\n\t\txdr_set_page(xdr, 0, buf->page_len);\n\t}\n}\n\nstatic unsigned int xdr_align_pages(struct xdr_stream *xdr, unsigned int len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tunsigned int nwords = XDR_QUADLEN(len);\n\tunsigned int copied;\n\n\tif (xdr->nwords == 0)\n\t\treturn 0;\n\n\txdr_realign_pages(xdr);\n\tif (nwords > xdr->nwords) {\n\t\tnwords = xdr->nwords;\n\t\tlen = nwords << 2;\n\t}\n\tif (buf->page_len <= len)\n\t\tlen = buf->page_len;\n\telse if (nwords < xdr->nwords) {\n\t\t \n\t\tcopied = xdr_shrink_pagelen(buf, len);\n\t\ttrace_rpc_xdr_alignment(xdr, len, copied);\n\t}\n\treturn len;\n}\n\n \nunsigned int xdr_read_pages(struct xdr_stream *xdr, unsigned int len)\n{\n\tunsigned int nwords = XDR_QUADLEN(len);\n\tunsigned int base, end, pglen;\n\n\tpglen = xdr_align_pages(xdr, nwords << 2);\n\tif (pglen == 0)\n\t\treturn 0;\n\n\tbase = (nwords << 2) - pglen;\n\tend = xdr_stream_remaining(xdr) - pglen;\n\n\txdr_set_tail_base(xdr, base, end);\n\treturn len <= pglen ? len : pglen;\n}\nEXPORT_SYMBOL_GPL(xdr_read_pages);\n\n \nvoid xdr_set_pagelen(struct xdr_stream *xdr, unsigned int len)\n{\n\tstruct xdr_buf *buf = xdr->buf;\n\tsize_t remaining = xdr_stream_remaining(xdr);\n\tsize_t base = 0;\n\n\tif (len < buf->page_len) {\n\t\tbase = buf->page_len - len;\n\t\txdr_shrink_pagelen(buf, len);\n\t} else {\n\t\txdr_buf_head_shift_right(buf, xdr_stream_pos(xdr),\n\t\t\t\t\t buf->page_len, remaining);\n\t\tif (len > buf->page_len)\n\t\t\txdr_buf_try_expand(buf, len - buf->page_len);\n\t}\n\txdr_set_tail_base(xdr, base, remaining);\n}\nEXPORT_SYMBOL_GPL(xdr_set_pagelen);\n\n \nvoid xdr_enter_page(struct xdr_stream *xdr, unsigned int len)\n{\n\tlen = xdr_align_pages(xdr, len);\n\t \n\tif (len != 0)\n\t\txdr_set_page_base(xdr, 0, len);\n}\nEXPORT_SYMBOL_GPL(xdr_enter_page);\n\nstatic const struct kvec empty_iov = {.iov_base = NULL, .iov_len = 0};\n\nvoid xdr_buf_from_iov(const struct kvec *iov, struct xdr_buf *buf)\n{\n\tbuf->head[0] = *iov;\n\tbuf->tail[0] = empty_iov;\n\tbuf->page_len = 0;\n\tbuf->buflen = buf->len = iov->iov_len;\n}\nEXPORT_SYMBOL_GPL(xdr_buf_from_iov);\n\n \nint xdr_buf_subsegment(const struct xdr_buf *buf, struct xdr_buf *subbuf,\n\t\t       unsigned int base, unsigned int len)\n{\n\tsubbuf->buflen = subbuf->len = len;\n\tif (base < buf->head[0].iov_len) {\n\t\tsubbuf->head[0].iov_base = buf->head[0].iov_base + base;\n\t\tsubbuf->head[0].iov_len = min_t(unsigned int, len,\n\t\t\t\t\t\tbuf->head[0].iov_len - base);\n\t\tlen -= subbuf->head[0].iov_len;\n\t\tbase = 0;\n\t} else {\n\t\tbase -= buf->head[0].iov_len;\n\t\tsubbuf->head[0].iov_base = buf->head[0].iov_base;\n\t\tsubbuf->head[0].iov_len = 0;\n\t}\n\n\tif (base < buf->page_len) {\n\t\tsubbuf->page_len = min(buf->page_len - base, len);\n\t\tbase += buf->page_base;\n\t\tsubbuf->page_base = base & ~PAGE_MASK;\n\t\tsubbuf->pages = &buf->pages[base >> PAGE_SHIFT];\n\t\tlen -= subbuf->page_len;\n\t\tbase = 0;\n\t} else {\n\t\tbase -= buf->page_len;\n\t\tsubbuf->pages = buf->pages;\n\t\tsubbuf->page_base = 0;\n\t\tsubbuf->page_len = 0;\n\t}\n\n\tif (base < buf->tail[0].iov_len) {\n\t\tsubbuf->tail[0].iov_base = buf->tail[0].iov_base + base;\n\t\tsubbuf->tail[0].iov_len = min_t(unsigned int, len,\n\t\t\t\t\t\tbuf->tail[0].iov_len - base);\n\t\tlen -= subbuf->tail[0].iov_len;\n\t\tbase = 0;\n\t} else {\n\t\tbase -= buf->tail[0].iov_len;\n\t\tsubbuf->tail[0].iov_base = buf->tail[0].iov_base;\n\t\tsubbuf->tail[0].iov_len = 0;\n\t}\n\n\tif (base || len)\n\t\treturn -1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xdr_buf_subsegment);\n\n \nbool xdr_stream_subsegment(struct xdr_stream *xdr, struct xdr_buf *subbuf,\n\t\t\t   unsigned int nbytes)\n{\n\tunsigned int start = xdr_stream_pos(xdr);\n\tunsigned int remaining, len;\n\n\t \n\tif (xdr_buf_subsegment(xdr->buf, subbuf, start, nbytes))\n\t\treturn false;\n\n\t \n\tfor (remaining = nbytes; remaining;) {\n\t\tif (xdr->p == xdr->end && !xdr_set_next_buffer(xdr))\n\t\t\treturn false;\n\n\t\tlen = (char *)xdr->end - (char *)xdr->p;\n\t\tif (remaining <= len) {\n\t\t\txdr->p = (__be32 *)((char *)xdr->p +\n\t\t\t\t\t(remaining + xdr_pad_size(nbytes)));\n\t\t\tbreak;\n\t\t}\n\n\t\txdr->p = (__be32 *)((char *)xdr->p + len);\n\t\txdr->end = xdr->p;\n\t\tremaining -= len;\n\t}\n\n\txdr_stream_set_pos(xdr, start + nbytes);\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_subsegment);\n\n \nunsigned int xdr_stream_move_subsegment(struct xdr_stream *xdr, unsigned int offset,\n\t\t\t\t\tunsigned int target, unsigned int length)\n{\n\tstruct xdr_buf buf;\n\tunsigned int shift;\n\n\tif (offset < target) {\n\t\tshift = target - offset;\n\t\tif (xdr_buf_subsegment(xdr->buf, &buf, offset, shift + length) < 0)\n\t\t\treturn 0;\n\t\txdr_buf_head_shift_right(&buf, 0, length, shift);\n\t} else if (offset > target) {\n\t\tshift = offset - target;\n\t\tif (xdr_buf_subsegment(xdr->buf, &buf, target, shift + length) < 0)\n\t\t\treturn 0;\n\t\txdr_buf_head_shift_left(&buf, shift, length, shift);\n\t}\n\treturn length;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_move_subsegment);\n\n \nunsigned int xdr_stream_zero(struct xdr_stream *xdr, unsigned int offset,\n\t\t\t     unsigned int length)\n{\n\tstruct xdr_buf buf;\n\n\tif (xdr_buf_subsegment(xdr->buf, &buf, offset, length) < 0)\n\t\treturn 0;\n\tif (buf.head[0].iov_len)\n\t\txdr_buf_iov_zero(buf.head, 0, buf.head[0].iov_len);\n\tif (buf.page_len > 0)\n\t\txdr_buf_pages_zero(&buf, 0, buf.page_len);\n\tif (buf.tail[0].iov_len)\n\t\txdr_buf_iov_zero(buf.tail, 0, buf.tail[0].iov_len);\n\treturn length;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_zero);\n\n \nvoid xdr_buf_trim(struct xdr_buf *buf, unsigned int len)\n{\n\tsize_t cur;\n\tunsigned int trim = len;\n\n\tif (buf->tail[0].iov_len) {\n\t\tcur = min_t(size_t, buf->tail[0].iov_len, trim);\n\t\tbuf->tail[0].iov_len -= cur;\n\t\ttrim -= cur;\n\t\tif (!trim)\n\t\t\tgoto fix_len;\n\t}\n\n\tif (buf->page_len) {\n\t\tcur = min_t(unsigned int, buf->page_len, trim);\n\t\tbuf->page_len -= cur;\n\t\ttrim -= cur;\n\t\tif (!trim)\n\t\t\tgoto fix_len;\n\t}\n\n\tif (buf->head[0].iov_len) {\n\t\tcur = min_t(size_t, buf->head[0].iov_len, trim);\n\t\tbuf->head[0].iov_len -= cur;\n\t\ttrim -= cur;\n\t}\nfix_len:\n\tbuf->len -= (len - trim);\n}\nEXPORT_SYMBOL_GPL(xdr_buf_trim);\n\nstatic void __read_bytes_from_xdr_buf(const struct xdr_buf *subbuf,\n\t\t\t\t      void *obj, unsigned int len)\n{\n\tunsigned int this_len;\n\n\tthis_len = min_t(unsigned int, len, subbuf->head[0].iov_len);\n\tmemcpy(obj, subbuf->head[0].iov_base, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->page_len);\n\t_copy_from_pages(obj, subbuf->pages, subbuf->page_base, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->tail[0].iov_len);\n\tmemcpy(obj, subbuf->tail[0].iov_base, this_len);\n}\n\n \nint read_bytes_from_xdr_buf(const struct xdr_buf *buf, unsigned int base,\n\t\t\t    void *obj, unsigned int len)\n{\n\tstruct xdr_buf subbuf;\n\tint status;\n\n\tstatus = xdr_buf_subsegment(buf, &subbuf, base, len);\n\tif (status != 0)\n\t\treturn status;\n\t__read_bytes_from_xdr_buf(&subbuf, obj, len);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(read_bytes_from_xdr_buf);\n\nstatic void __write_bytes_to_xdr_buf(const struct xdr_buf *subbuf,\n\t\t\t\t     void *obj, unsigned int len)\n{\n\tunsigned int this_len;\n\n\tthis_len = min_t(unsigned int, len, subbuf->head[0].iov_len);\n\tmemcpy(subbuf->head[0].iov_base, obj, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->page_len);\n\t_copy_to_pages(subbuf->pages, subbuf->page_base, obj, this_len);\n\tlen -= this_len;\n\tobj += this_len;\n\tthis_len = min_t(unsigned int, len, subbuf->tail[0].iov_len);\n\tmemcpy(subbuf->tail[0].iov_base, obj, this_len);\n}\n\n \nint write_bytes_to_xdr_buf(const struct xdr_buf *buf, unsigned int base,\n\t\t\t   void *obj, unsigned int len)\n{\n\tstruct xdr_buf subbuf;\n\tint status;\n\n\tstatus = xdr_buf_subsegment(buf, &subbuf, base, len);\n\tif (status != 0)\n\t\treturn status;\n\t__write_bytes_to_xdr_buf(&subbuf, obj, len);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(write_bytes_to_xdr_buf);\n\nint xdr_decode_word(const struct xdr_buf *buf, unsigned int base, u32 *obj)\n{\n\t__be32\traw;\n\tint\tstatus;\n\n\tstatus = read_bytes_from_xdr_buf(buf, base, &raw, sizeof(*obj));\n\tif (status)\n\t\treturn status;\n\t*obj = be32_to_cpu(raw);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xdr_decode_word);\n\nint xdr_encode_word(const struct xdr_buf *buf, unsigned int base, u32 obj)\n{\n\t__be32\traw = cpu_to_be32(obj);\n\n\treturn write_bytes_to_xdr_buf(buf, base, &raw, sizeof(obj));\n}\nEXPORT_SYMBOL_GPL(xdr_encode_word);\n\n \nstatic int xdr_xcode_array2(const struct xdr_buf *buf, unsigned int base,\n\t\t\t    struct xdr_array2_desc *desc, int encode)\n{\n\tchar *elem = NULL, *c;\n\tunsigned int copied = 0, todo, avail_here;\n\tstruct page **ppages = NULL;\n\tint err;\n\n\tif (encode) {\n\t\tif (xdr_encode_word(buf, base, desc->array_len) != 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (xdr_decode_word(buf, base, &desc->array_len) != 0 ||\n\t\t    desc->array_len > desc->array_maxlen ||\n\t\t    (unsigned long) base + 4 + desc->array_len *\n\t\t\t\t    desc->elem_size > buf->len)\n\t\t\treturn -EINVAL;\n\t}\n\tbase += 4;\n\n\tif (!desc->xcode)\n\t\treturn 0;\n\n\ttodo = desc->array_len * desc->elem_size;\n\n\t \n\tif (todo && base < buf->head->iov_len) {\n\t\tc = buf->head->iov_base + base;\n\t\tavail_here = min_t(unsigned int, todo,\n\t\t\t\t   buf->head->iov_len - base);\n\t\ttodo -= avail_here;\n\n\t\twhile (avail_here >= desc->elem_size) {\n\t\t\terr = desc->xcode(desc, c);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tc += desc->elem_size;\n\t\t\tavail_here -= desc->elem_size;\n\t\t}\n\t\tif (avail_here) {\n\t\t\tif (!elem) {\n\t\t\t\telem = kmalloc(desc->elem_size, GFP_KERNEL);\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tif (!elem)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (encode) {\n\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tmemcpy(c, elem, avail_here);\n\t\t\t} else\n\t\t\t\tmemcpy(elem, c, avail_here);\n\t\t\tcopied = avail_here;\n\t\t}\n\t\tbase = buf->head->iov_len;   \n\t}\n\n\t \n\tbase -= buf->head->iov_len;\n\tif (todo && base < buf->page_len) {\n\t\tunsigned int avail_page;\n\n\t\tavail_here = min(todo, buf->page_len - base);\n\t\ttodo -= avail_here;\n\n\t\tbase += buf->page_base;\n\t\tppages = buf->pages + (base >> PAGE_SHIFT);\n\t\tbase &= ~PAGE_MASK;\n\t\tavail_page = min_t(unsigned int, PAGE_SIZE - base,\n\t\t\t\t\tavail_here);\n\t\tc = kmap(*ppages) + base;\n\n\t\twhile (avail_here) {\n\t\t\tavail_here -= avail_page;\n\t\t\tif (copied || avail_page < desc->elem_size) {\n\t\t\t\tunsigned int l = min(avail_page,\n\t\t\t\t\tdesc->elem_size - copied);\n\t\t\t\tif (!elem) {\n\t\t\t\t\telem = kmalloc(desc->elem_size,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tif (!elem)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (encode) {\n\t\t\t\t\tif (!copied) {\n\t\t\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(c, elem + copied, l);\n\t\t\t\t\tcopied += l;\n\t\t\t\t\tif (copied == desc->elem_size)\n\t\t\t\t\t\tcopied = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(elem + copied, c, l);\n\t\t\t\t\tcopied += l;\n\t\t\t\t\tif (copied == desc->elem_size) {\n\t\t\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\tcopied = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tavail_page -= l;\n\t\t\t\tc += l;\n\t\t\t}\n\t\t\twhile (avail_page >= desc->elem_size) {\n\t\t\t\terr = desc->xcode(desc, c);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tc += desc->elem_size;\n\t\t\t\tavail_page -= desc->elem_size;\n\t\t\t}\n\t\t\tif (avail_page) {\n\t\t\t\tunsigned int l = min(avail_page,\n\t\t\t\t\t    desc->elem_size - copied);\n\t\t\t\tif (!elem) {\n\t\t\t\t\telem = kmalloc(desc->elem_size,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tif (!elem)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (encode) {\n\t\t\t\t\tif (!copied) {\n\t\t\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(c, elem + copied, l);\n\t\t\t\t\tcopied += l;\n\t\t\t\t\tif (copied == desc->elem_size)\n\t\t\t\t\t\tcopied = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(elem + copied, c, l);\n\t\t\t\t\tcopied += l;\n\t\t\t\t\tif (copied == desc->elem_size) {\n\t\t\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t\tcopied = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (avail_here) {\n\t\t\t\tkunmap(*ppages);\n\t\t\t\tppages++;\n\t\t\t\tc = kmap(*ppages);\n\t\t\t}\n\n\t\t\tavail_page = min(avail_here,\n\t\t\t\t (unsigned int) PAGE_SIZE);\n\t\t}\n\t\tbase = buf->page_len;   \n\t}\n\n\t \n\tbase -= buf->page_len;\n\tif (todo) {\n\t\tc = buf->tail->iov_base + base;\n\t\tif (copied) {\n\t\t\tunsigned int l = desc->elem_size - copied;\n\n\t\t\tif (encode)\n\t\t\t\tmemcpy(c, elem + copied, l);\n\t\t\telse {\n\t\t\t\tmemcpy(elem + copied, c, l);\n\t\t\t\terr = desc->xcode(desc, elem);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttodo -= l;\n\t\t\tc += l;\n\t\t}\n\t\twhile (todo) {\n\t\t\terr = desc->xcode(desc, c);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tc += desc->elem_size;\n\t\t\ttodo -= desc->elem_size;\n\t\t}\n\t}\n\terr = 0;\n\nout:\n\tkfree(elem);\n\tif (ppages)\n\t\tkunmap(*ppages);\n\treturn err;\n}\n\nint xdr_decode_array2(const struct xdr_buf *buf, unsigned int base,\n\t\t      struct xdr_array2_desc *desc)\n{\n\tif (base >= buf->len)\n\t\treturn -EINVAL;\n\n\treturn xdr_xcode_array2(buf, base, desc, 0);\n}\nEXPORT_SYMBOL_GPL(xdr_decode_array2);\n\nint xdr_encode_array2(const struct xdr_buf *buf, unsigned int base,\n\t\t      struct xdr_array2_desc *desc)\n{\n\tif ((unsigned long) base + 4 + desc->array_len * desc->elem_size >\n\t    buf->head->iov_len + buf->page_len + buf->tail->iov_len)\n\t\treturn -EINVAL;\n\n\treturn xdr_xcode_array2(buf, base, desc, 1);\n}\nEXPORT_SYMBOL_GPL(xdr_encode_array2);\n\nint xdr_process_buf(const struct xdr_buf *buf, unsigned int offset,\n\t\t    unsigned int len,\n\t\t    int (*actor)(struct scatterlist *, void *), void *data)\n{\n\tint i, ret = 0;\n\tunsigned int page_len, thislen, page_offset;\n\tstruct scatterlist      sg[1];\n\n\tsg_init_table(sg, 1);\n\n\tif (offset >= buf->head[0].iov_len) {\n\t\toffset -= buf->head[0].iov_len;\n\t} else {\n\t\tthislen = buf->head[0].iov_len - offset;\n\t\tif (thislen > len)\n\t\t\tthislen = len;\n\t\tsg_set_buf(sg, buf->head[0].iov_base + offset, thislen);\n\t\tret = actor(sg, data);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\toffset = 0;\n\t\tlen -= thislen;\n\t}\n\tif (len == 0)\n\t\tgoto out;\n\n\tif (offset >= buf->page_len) {\n\t\toffset -= buf->page_len;\n\t} else {\n\t\tpage_len = buf->page_len - offset;\n\t\tif (page_len > len)\n\t\t\tpage_len = len;\n\t\tlen -= page_len;\n\t\tpage_offset = (offset + buf->page_base) & (PAGE_SIZE - 1);\n\t\ti = (offset + buf->page_base) >> PAGE_SHIFT;\n\t\tthislen = PAGE_SIZE - page_offset;\n\t\tdo {\n\t\t\tif (thislen > page_len)\n\t\t\t\tthislen = page_len;\n\t\t\tsg_set_page(sg, buf->pages[i], thislen, page_offset);\n\t\t\tret = actor(sg, data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tpage_len -= thislen;\n\t\t\ti++;\n\t\t\tpage_offset = 0;\n\t\t\tthislen = PAGE_SIZE;\n\t\t} while (page_len != 0);\n\t\toffset = 0;\n\t}\n\tif (len == 0)\n\t\tgoto out;\n\tif (offset < buf->tail[0].iov_len) {\n\t\tthislen = buf->tail[0].iov_len - offset;\n\t\tif (thislen > len)\n\t\t\tthislen = len;\n\t\tsg_set_buf(sg, buf->tail[0].iov_base + offset, thislen);\n\t\tret = actor(sg, data);\n\t\tlen -= thislen;\n\t}\n\tif (len != 0)\n\t\tret = -EINVAL;\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_process_buf);\n\n \nssize_t xdr_stream_decode_opaque(struct xdr_stream *xdr, void *ptr, size_t size)\n{\n\tssize_t ret;\n\tvoid *p;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &p, size);\n\tif (ret <= 0)\n\t\treturn ret;\n\tmemcpy(ptr, p, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_opaque);\n\n \nssize_t xdr_stream_decode_opaque_dup(struct xdr_stream *xdr, void **ptr,\n\t\tsize_t maxlen, gfp_t gfp_flags)\n{\n\tssize_t ret;\n\tvoid *p;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &p, maxlen);\n\tif (ret > 0) {\n\t\t*ptr = kmemdup(p, ret, gfp_flags);\n\t\tif (*ptr != NULL)\n\t\t\treturn ret;\n\t\tret = -ENOMEM;\n\t}\n\t*ptr = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_opaque_dup);\n\n \nssize_t xdr_stream_decode_string(struct xdr_stream *xdr, char *str, size_t size)\n{\n\tssize_t ret;\n\tvoid *p;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &p, size);\n\tif (ret > 0) {\n\t\tmemcpy(str, p, ret);\n\t\tstr[ret] = '\\0';\n\t\treturn strlen(str);\n\t}\n\t*str = '\\0';\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_string);\n\n \nssize_t xdr_stream_decode_string_dup(struct xdr_stream *xdr, char **str,\n\t\tsize_t maxlen, gfp_t gfp_flags)\n{\n\tvoid *p;\n\tssize_t ret;\n\n\tret = xdr_stream_decode_opaque_inline(xdr, &p, maxlen);\n\tif (ret > 0) {\n\t\tchar *s = kmemdup_nul(p, ret, gfp_flags);\n\t\tif (s != NULL) {\n\t\t\t*str = s;\n\t\t\treturn strlen(s);\n\t\t}\n\t\tret = -ENOMEM;\n\t}\n\t*str = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_string_dup);\n\n \nssize_t xdr_stream_decode_opaque_auth(struct xdr_stream *xdr, u32 *flavor,\n\t\t\t\t      void **body, unsigned int *body_len)\n{\n\tssize_t ret, len;\n\n\tlen = xdr_stream_decode_u32(xdr, flavor);\n\tif (unlikely(len < 0))\n\t\treturn len;\n\tret = xdr_stream_decode_opaque_inline(xdr, body, RPC_MAX_AUTH_SIZE);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\t*body_len = ret;\n\treturn len + ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_decode_opaque_auth);\n\n \nssize_t xdr_stream_encode_opaque_auth(struct xdr_stream *xdr, u32 flavor,\n\t\t\t\t      void *body, unsigned int body_len)\n{\n\tssize_t ret, len;\n\n\tif (unlikely(body_len > RPC_MAX_AUTH_SIZE))\n\t\treturn -EMSGSIZE;\n\tlen = xdr_stream_encode_u32(xdr, flavor);\n\tif (unlikely(len < 0))\n\t\treturn len;\n\tret = xdr_stream_encode_opaque(xdr, body, body_len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\treturn len + ret;\n}\nEXPORT_SYMBOL_GPL(xdr_stream_encode_opaque_auth);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}