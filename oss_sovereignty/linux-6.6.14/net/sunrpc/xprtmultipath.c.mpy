{
  "module_name": "xprtmultipath.c",
  "hash_id": "9600cf2ad96727ff7612d9c080c0d37f32b254de3186b3521160c801bab24df4",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/xprtmultipath.c",
  "human_readable_source": "\n \n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/xprtmultipath.h>\n\n#include \"sysfs.h\"\n\ntypedef struct rpc_xprt *(*xprt_switch_find_xprt_t)(struct rpc_xprt_switch *xps,\n\t\tconst struct rpc_xprt *cur);\n\nstatic const struct rpc_xprt_iter_ops rpc_xprt_iter_singular;\nstatic const struct rpc_xprt_iter_ops rpc_xprt_iter_roundrobin;\nstatic const struct rpc_xprt_iter_ops rpc_xprt_iter_listall;\nstatic const struct rpc_xprt_iter_ops rpc_xprt_iter_listoffline;\n\nstatic void xprt_switch_add_xprt_locked(struct rpc_xprt_switch *xps,\n\t\tstruct rpc_xprt *xprt)\n{\n\tif (unlikely(xprt_get(xprt) == NULL))\n\t\treturn;\n\tlist_add_tail_rcu(&xprt->xprt_switch, &xps->xps_xprt_list);\n\tsmp_wmb();\n\tif (xps->xps_nxprts == 0)\n\t\txps->xps_net = xprt->xprt_net;\n\txps->xps_nxprts++;\n\txps->xps_nactive++;\n}\n\n \nvoid rpc_xprt_switch_add_xprt(struct rpc_xprt_switch *xps,\n\t\tstruct rpc_xprt *xprt)\n{\n\tif (xprt == NULL)\n\t\treturn;\n\tspin_lock(&xps->xps_lock);\n\tif (xps->xps_net == xprt->xprt_net || xps->xps_net == NULL)\n\t\txprt_switch_add_xprt_locked(xps, xprt);\n\tspin_unlock(&xps->xps_lock);\n\trpc_sysfs_xprt_setup(xps, xprt, GFP_KERNEL);\n}\n\nstatic void xprt_switch_remove_xprt_locked(struct rpc_xprt_switch *xps,\n\t\tstruct rpc_xprt *xprt, bool offline)\n{\n\tif (unlikely(xprt == NULL))\n\t\treturn;\n\tif (!test_bit(XPRT_OFFLINE, &xprt->state) && offline)\n\t\txps->xps_nactive--;\n\txps->xps_nxprts--;\n\tif (xps->xps_nxprts == 0)\n\t\txps->xps_net = NULL;\n\tsmp_wmb();\n\tlist_del_rcu(&xprt->xprt_switch);\n}\n\n \nvoid rpc_xprt_switch_remove_xprt(struct rpc_xprt_switch *xps,\n\t\tstruct rpc_xprt *xprt, bool offline)\n{\n\tspin_lock(&xps->xps_lock);\n\txprt_switch_remove_xprt_locked(xps, xprt, offline);\n\tspin_unlock(&xps->xps_lock);\n\txprt_put(xprt);\n}\n\nstatic DEFINE_IDA(rpc_xprtswitch_ids);\n\nvoid xprt_multipath_cleanup_ids(void)\n{\n\tida_destroy(&rpc_xprtswitch_ids);\n}\n\nstatic int xprt_switch_alloc_id(struct rpc_xprt_switch *xps, gfp_t gfp_flags)\n{\n\tint id;\n\n\tid = ida_alloc(&rpc_xprtswitch_ids, gfp_flags);\n\tif (id < 0)\n\t\treturn id;\n\n\txps->xps_id = id;\n\treturn 0;\n}\n\nstatic void xprt_switch_free_id(struct rpc_xprt_switch *xps)\n{\n\tida_free(&rpc_xprtswitch_ids, xps->xps_id);\n}\n\n \nstruct rpc_xprt_switch *xprt_switch_alloc(struct rpc_xprt *xprt,\n\t\tgfp_t gfp_flags)\n{\n\tstruct rpc_xprt_switch *xps;\n\n\txps = kmalloc(sizeof(*xps), gfp_flags);\n\tif (xps != NULL) {\n\t\tspin_lock_init(&xps->xps_lock);\n\t\tkref_init(&xps->xps_kref);\n\t\txprt_switch_alloc_id(xps, gfp_flags);\n\t\txps->xps_nxprts = xps->xps_nactive = 0;\n\t\tatomic_long_set(&xps->xps_queuelen, 0);\n\t\txps->xps_net = NULL;\n\t\tINIT_LIST_HEAD(&xps->xps_xprt_list);\n\t\txps->xps_iter_ops = &rpc_xprt_iter_singular;\n\t\trpc_sysfs_xprt_switch_setup(xps, xprt, gfp_flags);\n\t\txprt_switch_add_xprt_locked(xps, xprt);\n\t\txps->xps_nunique_destaddr_xprts = 1;\n\t\trpc_sysfs_xprt_setup(xps, xprt, gfp_flags);\n\t}\n\n\treturn xps;\n}\n\nstatic void xprt_switch_free_entries(struct rpc_xprt_switch *xps)\n{\n\tspin_lock(&xps->xps_lock);\n\twhile (!list_empty(&xps->xps_xprt_list)) {\n\t\tstruct rpc_xprt *xprt;\n\n\t\txprt = list_first_entry(&xps->xps_xprt_list,\n\t\t\t\tstruct rpc_xprt, xprt_switch);\n\t\txprt_switch_remove_xprt_locked(xps, xprt, true);\n\t\tspin_unlock(&xps->xps_lock);\n\t\txprt_put(xprt);\n\t\tspin_lock(&xps->xps_lock);\n\t}\n\tspin_unlock(&xps->xps_lock);\n}\n\nstatic void xprt_switch_free(struct kref *kref)\n{\n\tstruct rpc_xprt_switch *xps = container_of(kref,\n\t\t\tstruct rpc_xprt_switch, xps_kref);\n\n\txprt_switch_free_entries(xps);\n\trpc_sysfs_xprt_switch_destroy(xps);\n\txprt_switch_free_id(xps);\n\tkfree_rcu(xps, xps_rcu);\n}\n\n \nstruct rpc_xprt_switch *xprt_switch_get(struct rpc_xprt_switch *xps)\n{\n\tif (xps != NULL && kref_get_unless_zero(&xps->xps_kref))\n\t\treturn xps;\n\treturn NULL;\n}\n\n \nvoid xprt_switch_put(struct rpc_xprt_switch *xps)\n{\n\tif (xps != NULL)\n\t\tkref_put(&xps->xps_kref, xprt_switch_free);\n}\n\n \nvoid rpc_xprt_switch_set_roundrobin(struct rpc_xprt_switch *xps)\n{\n\tif (READ_ONCE(xps->xps_iter_ops) != &rpc_xprt_iter_roundrobin)\n\t\tWRITE_ONCE(xps->xps_iter_ops, &rpc_xprt_iter_roundrobin);\n}\n\nstatic\nconst struct rpc_xprt_iter_ops *xprt_iter_ops(const struct rpc_xprt_iter *xpi)\n{\n\tif (xpi->xpi_ops != NULL)\n\t\treturn xpi->xpi_ops;\n\treturn rcu_dereference(xpi->xpi_xpswitch)->xps_iter_ops;\n}\n\nstatic\nvoid xprt_iter_no_rewind(struct rpc_xprt_iter *xpi)\n{\n}\n\nstatic\nvoid xprt_iter_default_rewind(struct rpc_xprt_iter *xpi)\n{\n\tWRITE_ONCE(xpi->xpi_cursor, NULL);\n}\n\nstatic\nbool xprt_is_active(const struct rpc_xprt *xprt)\n{\n\treturn (kref_read(&xprt->kref) != 0 &&\n\t\t!test_bit(XPRT_OFFLINE, &xprt->state));\n}\n\nstatic\nstruct rpc_xprt *xprt_switch_find_first_entry(struct list_head *head)\n{\n\tstruct rpc_xprt *pos;\n\n\tlist_for_each_entry_rcu(pos, head, xprt_switch) {\n\t\tif (xprt_is_active(pos))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstatic\nstruct rpc_xprt *xprt_switch_find_first_entry_offline(struct list_head *head)\n{\n\tstruct rpc_xprt *pos;\n\n\tlist_for_each_entry_rcu(pos, head, xprt_switch) {\n\t\tif (!xprt_is_active(pos))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstatic\nstruct rpc_xprt *xprt_iter_first_entry(struct rpc_xprt_iter *xpi)\n{\n\tstruct rpc_xprt_switch *xps = rcu_dereference(xpi->xpi_xpswitch);\n\n\tif (xps == NULL)\n\t\treturn NULL;\n\treturn xprt_switch_find_first_entry(&xps->xps_xprt_list);\n}\n\nstatic\nstruct rpc_xprt *_xprt_switch_find_current_entry(struct list_head *head,\n\t\t\t\t\t\t const struct rpc_xprt *cur,\n\t\t\t\t\t\t bool find_active)\n{\n\tstruct rpc_xprt *pos;\n\tbool found = false;\n\n\tlist_for_each_entry_rcu(pos, head, xprt_switch) {\n\t\tif (cur == pos)\n\t\t\tfound = true;\n\t\tif (found && ((find_active && xprt_is_active(pos)) ||\n\t\t\t      (!find_active && !xprt_is_active(pos))))\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\nstatic\nstruct rpc_xprt *xprt_switch_find_current_entry(struct list_head *head,\n\t\t\t\t\t\tconst struct rpc_xprt *cur)\n{\n\treturn _xprt_switch_find_current_entry(head, cur, true);\n}\n\nstatic\nstruct rpc_xprt * _xprt_iter_current_entry(struct rpc_xprt_iter *xpi,\n\t\tstruct rpc_xprt *first_entry(struct list_head *head),\n\t\tstruct rpc_xprt *current_entry(struct list_head *head,\n\t\t\t\t\t       const struct rpc_xprt *cur))\n{\n\tstruct rpc_xprt_switch *xps = rcu_dereference(xpi->xpi_xpswitch);\n\tstruct list_head *head;\n\n\tif (xps == NULL)\n\t\treturn NULL;\n\thead = &xps->xps_xprt_list;\n\tif (xpi->xpi_cursor == NULL || xps->xps_nxprts < 2)\n\t\treturn first_entry(head);\n\treturn current_entry(head, xpi->xpi_cursor);\n}\n\nstatic\nstruct rpc_xprt *xprt_iter_current_entry(struct rpc_xprt_iter *xpi)\n{\n\treturn _xprt_iter_current_entry(xpi, xprt_switch_find_first_entry,\n\t\t\txprt_switch_find_current_entry);\n}\n\nstatic\nstruct rpc_xprt *xprt_switch_find_current_entry_offline(struct list_head *head,\n\t\tconst struct rpc_xprt *cur)\n{\n\treturn _xprt_switch_find_current_entry(head, cur, false);\n}\n\nstatic\nstruct rpc_xprt *xprt_iter_current_entry_offline(struct rpc_xprt_iter *xpi)\n{\n\treturn _xprt_iter_current_entry(xpi,\n\t\t\txprt_switch_find_first_entry_offline,\n\t\t\txprt_switch_find_current_entry_offline);\n}\n\nbool rpc_xprt_switch_has_addr(struct rpc_xprt_switch *xps,\n\t\t\t      const struct sockaddr *sap)\n{\n\tstruct list_head *head;\n\tstruct rpc_xprt *pos;\n\n\tif (xps == NULL || sap == NULL)\n\t\treturn false;\n\n\thead = &xps->xps_xprt_list;\n\tlist_for_each_entry_rcu(pos, head, xprt_switch) {\n\t\tif (rpc_cmp_addr_port(sap, (struct sockaddr *)&pos->addr)) {\n\t\t\tpr_info(\"RPC:   addr %s already in xprt switch\\n\",\n\t\t\t\tpos->address_strings[RPC_DISPLAY_ADDR]);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic\nstruct rpc_xprt *xprt_switch_find_next_entry(struct list_head *head,\n\t\tconst struct rpc_xprt *cur, bool check_active)\n{\n\tstruct rpc_xprt *pos, *prev = NULL;\n\tbool found = false;\n\n\tlist_for_each_entry_rcu(pos, head, xprt_switch) {\n\t\tif (cur == prev)\n\t\t\tfound = true;\n\t\t \n\t\tif (found && ((check_active && xprt_is_active(pos)) ||\n\t\t\t      (!check_active && !xprt_is_active(pos))))\n\t\t\treturn pos;\n\t\tprev = pos;\n\t}\n\treturn NULL;\n}\n\nstatic\nstruct rpc_xprt *xprt_switch_set_next_cursor(struct rpc_xprt_switch *xps,\n\t\tstruct rpc_xprt **cursor,\n\t\txprt_switch_find_xprt_t find_next)\n{\n\tstruct rpc_xprt *pos, *old;\n\n\told = smp_load_acquire(cursor);\n\tpos = find_next(xps, old);\n\tsmp_store_release(cursor, pos);\n\treturn pos;\n}\n\nstatic\nstruct rpc_xprt *xprt_iter_next_entry_multiple(struct rpc_xprt_iter *xpi,\n\t\txprt_switch_find_xprt_t find_next)\n{\n\tstruct rpc_xprt_switch *xps = rcu_dereference(xpi->xpi_xpswitch);\n\n\tif (xps == NULL)\n\t\treturn NULL;\n\treturn xprt_switch_set_next_cursor(xps, &xpi->xpi_cursor, find_next);\n}\n\nstatic\nstruct rpc_xprt *__xprt_switch_find_next_entry_roundrobin(struct list_head *head,\n\t\tconst struct rpc_xprt *cur)\n{\n\tstruct rpc_xprt *ret;\n\n\tret = xprt_switch_find_next_entry(head, cur, true);\n\tif (ret != NULL)\n\t\treturn ret;\n\treturn xprt_switch_find_first_entry(head);\n}\n\nstatic\nstruct rpc_xprt *xprt_switch_find_next_entry_roundrobin(struct rpc_xprt_switch *xps,\n\t\tconst struct rpc_xprt *cur)\n{\n\tstruct list_head *head = &xps->xps_xprt_list;\n\tstruct rpc_xprt *xprt;\n\tunsigned int nactive;\n\n\tfor (;;) {\n\t\tunsigned long xprt_queuelen, xps_queuelen;\n\n\t\txprt = __xprt_switch_find_next_entry_roundrobin(head, cur);\n\t\tif (!xprt)\n\t\t\tbreak;\n\t\txprt_queuelen = atomic_long_read(&xprt->queuelen);\n\t\txps_queuelen = atomic_long_read(&xps->xps_queuelen);\n\t\tnactive = READ_ONCE(xps->xps_nactive);\n\t\t \n\t\tif (xprt_queuelen * nactive <= xps_queuelen)\n\t\t\tbreak;\n\t\tcur = xprt;\n\t}\n\treturn xprt;\n}\n\nstatic\nstruct rpc_xprt *xprt_iter_next_entry_roundrobin(struct rpc_xprt_iter *xpi)\n{\n\treturn xprt_iter_next_entry_multiple(xpi,\n\t\t\txprt_switch_find_next_entry_roundrobin);\n}\n\nstatic\nstruct rpc_xprt *xprt_switch_find_next_entry_all(struct rpc_xprt_switch *xps,\n\t\tconst struct rpc_xprt *cur)\n{\n\treturn xprt_switch_find_next_entry(&xps->xps_xprt_list, cur, true);\n}\n\nstatic\nstruct rpc_xprt *xprt_switch_find_next_entry_offline(struct rpc_xprt_switch *xps,\n\t\tconst struct rpc_xprt *cur)\n{\n\treturn xprt_switch_find_next_entry(&xps->xps_xprt_list, cur, false);\n}\n\nstatic\nstruct rpc_xprt *xprt_iter_next_entry_all(struct rpc_xprt_iter *xpi)\n{\n\treturn xprt_iter_next_entry_multiple(xpi,\n\t\t\txprt_switch_find_next_entry_all);\n}\n\nstatic\nstruct rpc_xprt *xprt_iter_next_entry_offline(struct rpc_xprt_iter *xpi)\n{\n\treturn xprt_iter_next_entry_multiple(xpi,\n\t\t\txprt_switch_find_next_entry_offline);\n}\n\n \nvoid xprt_iter_rewind(struct rpc_xprt_iter *xpi)\n{\n\trcu_read_lock();\n\txprt_iter_ops(xpi)->xpi_rewind(xpi);\n\trcu_read_unlock();\n}\n\nstatic void __xprt_iter_init(struct rpc_xprt_iter *xpi,\n\t\tstruct rpc_xprt_switch *xps,\n\t\tconst struct rpc_xprt_iter_ops *ops)\n{\n\trcu_assign_pointer(xpi->xpi_xpswitch, xprt_switch_get(xps));\n\txpi->xpi_cursor = NULL;\n\txpi->xpi_ops = ops;\n}\n\n \nvoid xprt_iter_init(struct rpc_xprt_iter *xpi,\n\t\tstruct rpc_xprt_switch *xps)\n{\n\t__xprt_iter_init(xpi, xps, NULL);\n}\n\n \nvoid xprt_iter_init_listall(struct rpc_xprt_iter *xpi,\n\t\tstruct rpc_xprt_switch *xps)\n{\n\t__xprt_iter_init(xpi, xps, &rpc_xprt_iter_listall);\n}\n\nvoid xprt_iter_init_listoffline(struct rpc_xprt_iter *xpi,\n\t\tstruct rpc_xprt_switch *xps)\n{\n\t__xprt_iter_init(xpi, xps, &rpc_xprt_iter_listoffline);\n}\n\n \nstruct rpc_xprt_switch *xprt_iter_xchg_switch(struct rpc_xprt_iter *xpi,\n\t\tstruct rpc_xprt_switch *newswitch)\n{\n\tstruct rpc_xprt_switch __rcu *oldswitch;\n\n\t \n\toldswitch = xchg(&xpi->xpi_xpswitch, RCU_INITIALIZER(newswitch));\n\tif (newswitch != NULL)\n\t\txprt_iter_rewind(xpi);\n\treturn rcu_dereference_protected(oldswitch, true);\n}\n\n \nvoid xprt_iter_destroy(struct rpc_xprt_iter *xpi)\n{\n\txprt_switch_put(xprt_iter_xchg_switch(xpi, NULL));\n}\n\n \nstruct rpc_xprt *xprt_iter_xprt(struct rpc_xprt_iter *xpi)\n{\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\treturn xprt_iter_ops(xpi)->xpi_xprt(xpi);\n}\n\nstatic\nstruct rpc_xprt *xprt_iter_get_helper(struct rpc_xprt_iter *xpi,\n\t\tstruct rpc_xprt *(*fn)(struct rpc_xprt_iter *))\n{\n\tstruct rpc_xprt *ret;\n\n\tdo {\n\t\tret = fn(xpi);\n\t\tif (ret == NULL)\n\t\t\tbreak;\n\t\tret = xprt_get(ret);\n\t} while (ret == NULL);\n\treturn ret;\n}\n\n \nstruct rpc_xprt *xprt_iter_get_xprt(struct rpc_xprt_iter *xpi)\n{\n\tstruct rpc_xprt *xprt;\n\n\trcu_read_lock();\n\txprt = xprt_iter_get_helper(xpi, xprt_iter_ops(xpi)->xpi_xprt);\n\trcu_read_unlock();\n\treturn xprt;\n}\n\n \nstruct rpc_xprt *xprt_iter_get_next(struct rpc_xprt_iter *xpi)\n{\n\tstruct rpc_xprt *xprt;\n\n\trcu_read_lock();\n\txprt = xprt_iter_get_helper(xpi, xprt_iter_ops(xpi)->xpi_next);\n\trcu_read_unlock();\n\treturn xprt;\n}\n\n \nstatic\nconst struct rpc_xprt_iter_ops rpc_xprt_iter_singular = {\n\t.xpi_rewind = xprt_iter_no_rewind,\n\t.xpi_xprt = xprt_iter_first_entry,\n\t.xpi_next = xprt_iter_first_entry,\n};\n\n \nstatic\nconst struct rpc_xprt_iter_ops rpc_xprt_iter_roundrobin = {\n\t.xpi_rewind = xprt_iter_default_rewind,\n\t.xpi_xprt = xprt_iter_current_entry,\n\t.xpi_next = xprt_iter_next_entry_roundrobin,\n};\n\n \nstatic\nconst struct rpc_xprt_iter_ops rpc_xprt_iter_listall = {\n\t.xpi_rewind = xprt_iter_default_rewind,\n\t.xpi_xprt = xprt_iter_current_entry,\n\t.xpi_next = xprt_iter_next_entry_all,\n};\n\nstatic\nconst struct rpc_xprt_iter_ops rpc_xprt_iter_listoffline = {\n\t.xpi_rewind = xprt_iter_default_rewind,\n\t.xpi_xprt = xprt_iter_current_entry_offline,\n\t.xpi_next = xprt_iter_next_entry_offline,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}