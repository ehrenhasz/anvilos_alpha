{
  "module_name": "debugfs.c",
  "hash_id": "ee51a3163a0395e73e18504043df63ae19de1a81dfe3977177a47b991cfa2bc6",
  "original_prompt": "Ingested from linux-6.6.14/net/sunrpc/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n\n#include \"netns.h\"\n#include \"fail.h\"\n\nstatic struct dentry *topdir;\nstatic struct dentry *rpc_clnt_dir;\nstatic struct dentry *rpc_xprt_dir;\n\nstatic int\ntasks_show(struct seq_file *f, void *v)\n{\n\tu32 xid = 0;\n\tstruct rpc_task *task = v;\n\tstruct rpc_clnt *clnt = task->tk_client;\n\tconst char *rpc_waitq = \"none\";\n\n\tif (RPC_IS_QUEUED(task))\n\t\trpc_waitq = rpc_qname(task->tk_waitqueue);\n\n\tif (task->tk_rqstp)\n\t\txid = be32_to_cpu(task->tk_rqstp->rq_xid);\n\n\tseq_printf(f, \"%5u %04x %6d 0x%x 0x%x %8ld %ps %sv%u %s a:%ps q:%s\\n\",\n\t\ttask->tk_pid, task->tk_flags, task->tk_status,\n\t\tclnt->cl_clid, xid, rpc_task_timeout(task), task->tk_ops,\n\t\tclnt->cl_program->name, clnt->cl_vers, rpc_proc_name(task),\n\t\ttask->tk_action, rpc_waitq);\n\treturn 0;\n}\n\nstatic void *\ntasks_start(struct seq_file *f, loff_t *ppos)\n\t__acquires(&clnt->cl_lock)\n{\n\tstruct rpc_clnt *clnt = f->private;\n\tloff_t pos = *ppos;\n\tstruct rpc_task *task;\n\n\tspin_lock(&clnt->cl_lock);\n\tlist_for_each_entry(task, &clnt->cl_tasks, tk_task)\n\t\tif (pos-- == 0)\n\t\t\treturn task;\n\treturn NULL;\n}\n\nstatic void *\ntasks_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\tstruct rpc_clnt *clnt = f->private;\n\tstruct rpc_task *task = v;\n\tstruct list_head *next = task->tk_task.next;\n\n\t++*pos;\n\n\t \n\tif (next == &clnt->cl_tasks)\n\t\treturn NULL;\n\treturn list_entry(next, struct rpc_task, tk_task);\n}\n\nstatic void\ntasks_stop(struct seq_file *f, void *v)\n\t__releases(&clnt->cl_lock)\n{\n\tstruct rpc_clnt *clnt = f->private;\n\tspin_unlock(&clnt->cl_lock);\n}\n\nstatic const struct seq_operations tasks_seq_operations = {\n\t.start\t= tasks_start,\n\t.next\t= tasks_next,\n\t.stop\t= tasks_stop,\n\t.show\t= tasks_show,\n};\n\nstatic int tasks_open(struct inode *inode, struct file *filp)\n{\n\tint ret = seq_open(filp, &tasks_seq_operations);\n\tif (!ret) {\n\t\tstruct seq_file *seq = filp->private_data;\n\t\tstruct rpc_clnt *clnt = seq->private = inode->i_private;\n\n\t\tif (!refcount_inc_not_zero(&clnt->cl_count)) {\n\t\t\tseq_release(inode, filp);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int\ntasks_release(struct inode *inode, struct file *filp)\n{\n\tstruct seq_file *seq = filp->private_data;\n\tstruct rpc_clnt *clnt = seq->private;\n\n\trpc_release_client(clnt);\n\treturn seq_release(inode, filp);\n}\n\nstatic const struct file_operations tasks_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= tasks_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tasks_release,\n};\n\nstatic int do_xprt_debugfs(struct rpc_clnt *clnt, struct rpc_xprt *xprt, void *numv)\n{\n\tint len;\n\tchar name[24];  \n\tchar link[9];  \n\tint *nump = numv;\n\n\tif (IS_ERR_OR_NULL(xprt->debugfs))\n\t\treturn 0;\n\tlen = snprintf(name, sizeof(name), \"../../rpc_xprt/%s\",\n\t\t       xprt->debugfs->d_name.name);\n\tif (len >= sizeof(name))\n\t\treturn -1;\n\tif (*nump == 0)\n\t\tstrcpy(link, \"xprt\");\n\telse {\n\t\tlen = snprintf(link, sizeof(link), \"xprt%d\", *nump);\n\t\tif (len >= sizeof(link))\n\t\t\treturn -1;\n\t}\n\tdebugfs_create_symlink(link, clnt->cl_debugfs, name);\n\t(*nump)++;\n\treturn 0;\n}\n\nvoid\nrpc_clnt_debugfs_register(struct rpc_clnt *clnt)\n{\n\tint len;\n\tchar name[9];  \n\tint xprtnum = 0;\n\n\tlen = snprintf(name, sizeof(name), \"%x\", clnt->cl_clid);\n\tif (len >= sizeof(name))\n\t\treturn;\n\n\t \n\tclnt->cl_debugfs = debugfs_create_dir(name, rpc_clnt_dir);\n\n\t \n\tdebugfs_create_file(\"tasks\", S_IFREG | 0400, clnt->cl_debugfs, clnt,\n\t\t\t    &tasks_fops);\n\n\trpc_clnt_iterate_for_each_xprt(clnt, do_xprt_debugfs, &xprtnum);\n}\n\nvoid\nrpc_clnt_debugfs_unregister(struct rpc_clnt *clnt)\n{\n\tdebugfs_remove_recursive(clnt->cl_debugfs);\n\tclnt->cl_debugfs = NULL;\n}\n\nstatic int\nxprt_info_show(struct seq_file *f, void *v)\n{\n\tstruct rpc_xprt *xprt = f->private;\n\n\tseq_printf(f, \"netid: %s\\n\", xprt->address_strings[RPC_DISPLAY_NETID]);\n\tseq_printf(f, \"addr:  %s\\n\", xprt->address_strings[RPC_DISPLAY_ADDR]);\n\tseq_printf(f, \"port:  %s\\n\", xprt->address_strings[RPC_DISPLAY_PORT]);\n\tseq_printf(f, \"state: 0x%lx\\n\", xprt->state);\n\treturn 0;\n}\n\nstatic int\nxprt_info_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\tstruct rpc_xprt *xprt = inode->i_private;\n\n\tret = single_open(filp, xprt_info_show, xprt);\n\n\tif (!ret) {\n\t\tif (!xprt_get(xprt)) {\n\t\t\tsingle_release(inode, filp);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int\nxprt_info_release(struct inode *inode, struct file *filp)\n{\n\tstruct rpc_xprt *xprt = inode->i_private;\n\n\txprt_put(xprt);\n\treturn single_release(inode, filp);\n}\n\nstatic const struct file_operations xprt_info_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= xprt_info_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= xprt_info_release,\n};\n\nvoid\nrpc_xprt_debugfs_register(struct rpc_xprt *xprt)\n{\n\tint len, id;\n\tstatic atomic_t\tcur_id;\n\tchar\t\tname[9];  \n\n\tid = (unsigned int)atomic_inc_return(&cur_id);\n\n\tlen = snprintf(name, sizeof(name), \"%x\", id);\n\tif (len >= sizeof(name))\n\t\treturn;\n\n\t \n\txprt->debugfs = debugfs_create_dir(name, rpc_xprt_dir);\n\n\t \n\tdebugfs_create_file(\"info\", S_IFREG | 0400, xprt->debugfs, xprt,\n\t\t\t    &xprt_info_fops);\n}\n\nvoid\nrpc_xprt_debugfs_unregister(struct rpc_xprt *xprt)\n{\n\tdebugfs_remove_recursive(xprt->debugfs);\n\txprt->debugfs = NULL;\n}\n\n#if IS_ENABLED(CONFIG_FAIL_SUNRPC)\nstruct fail_sunrpc_attr fail_sunrpc = {\n\t.attr\t\t\t= FAULT_ATTR_INITIALIZER,\n};\nEXPORT_SYMBOL_GPL(fail_sunrpc);\n\nstatic void fail_sunrpc_init(void)\n{\n\tstruct dentry *dir;\n\n\tdir = fault_create_debugfs_attr(\"fail_sunrpc\", NULL,\n\t\t\t\t\t&fail_sunrpc.attr);\n\n\tdebugfs_create_bool(\"ignore-client-disconnect\", S_IFREG | 0600, dir,\n\t\t\t    &fail_sunrpc.ignore_client_disconnect);\n\n\tdebugfs_create_bool(\"ignore-server-disconnect\", S_IFREG | 0600, dir,\n\t\t\t    &fail_sunrpc.ignore_server_disconnect);\n\n\tdebugfs_create_bool(\"ignore-cache-wait\", S_IFREG | 0600, dir,\n\t\t\t    &fail_sunrpc.ignore_cache_wait);\n}\n#else\nstatic void fail_sunrpc_init(void)\n{\n}\n#endif\n\nvoid __exit\nsunrpc_debugfs_exit(void)\n{\n\tdebugfs_remove_recursive(topdir);\n\ttopdir = NULL;\n\trpc_clnt_dir = NULL;\n\trpc_xprt_dir = NULL;\n}\n\nvoid __init\nsunrpc_debugfs_init(void)\n{\n\ttopdir = debugfs_create_dir(\"sunrpc\", NULL);\n\n\trpc_clnt_dir = debugfs_create_dir(\"rpc_clnt\", topdir);\n\n\trpc_xprt_dir = debugfs_create_dir(\"rpc_xprt\", topdir);\n\n\tfail_sunrpc_init();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}