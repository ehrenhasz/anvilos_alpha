{
  "module_name": "exthdrs_core.c",
  "hash_id": "35334e26f826b2b67e44975ddd3be6d1c3682d5bf2570eb291dc4fbb6d80936c",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/exthdrs_core.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <net/ipv6.h>\n\n \n\nbool ipv6_ext_hdr(u8 nexthdr)\n{\n\t \n\treturn   (nexthdr == NEXTHDR_HOP)\t||\n\t\t (nexthdr == NEXTHDR_ROUTING)\t||\n\t\t (nexthdr == NEXTHDR_FRAGMENT)\t||\n\t\t (nexthdr == NEXTHDR_AUTH)\t||\n\t\t (nexthdr == NEXTHDR_NONE)\t||\n\t\t (nexthdr == NEXTHDR_DEST);\n}\nEXPORT_SYMBOL(ipv6_ext_hdr);\n\n \n\nint ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp,\n\t\t     __be16 *frag_offp)\n{\n\tu8 nexthdr = *nexthdrp;\n\n\t*frag_offp = 0;\n\n\twhile (ipv6_ext_hdr(nexthdr)) {\n\t\tstruct ipv6_opt_hdr _hdr, *hp;\n\t\tint hdrlen;\n\n\t\tif (nexthdr == NEXTHDR_NONE)\n\t\t\treturn -1;\n\t\thp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\n\t\tif (!hp)\n\t\t\treturn -1;\n\t\tif (nexthdr == NEXTHDR_FRAGMENT) {\n\t\t\t__be16 _frag_off, *fp;\n\t\t\tfp = skb_header_pointer(skb,\n\t\t\t\t\t\tstart+offsetof(struct frag_hdr,\n\t\t\t\t\t\t\t       frag_off),\n\t\t\t\t\t\tsizeof(_frag_off),\n\t\t\t\t\t\t&_frag_off);\n\t\t\tif (!fp)\n\t\t\t\treturn -1;\n\n\t\t\t*frag_offp = *fp;\n\t\t\tif (ntohs(*frag_offp) & ~0x7)\n\t\t\t\tbreak;\n\t\t\thdrlen = 8;\n\t\t} else if (nexthdr == NEXTHDR_AUTH)\n\t\t\thdrlen = ipv6_authlen(hp);\n\t\telse\n\t\t\thdrlen = ipv6_optlen(hp);\n\n\t\tnexthdr = hp->nexthdr;\n\t\tstart += hdrlen;\n\t}\n\n\t*nexthdrp = nexthdr;\n\treturn start;\n}\nEXPORT_SYMBOL(ipv6_skip_exthdr);\n\nint ipv6_find_tlv(const struct sk_buff *skb, int offset, int type)\n{\n\tconst unsigned char *nh = skb_network_header(skb);\n\tint packet_len = skb_tail_pointer(skb) - skb_network_header(skb);\n\tstruct ipv6_opt_hdr *hdr;\n\tint len;\n\n\tif (offset + 2 > packet_len)\n\t\tgoto bad;\n\thdr = (struct ipv6_opt_hdr *)(nh + offset);\n\tlen = ((hdr->hdrlen + 1) << 3);\n\n\tif (offset + len > packet_len)\n\t\tgoto bad;\n\n\toffset += 2;\n\tlen -= 2;\n\n\twhile (len > 0) {\n\t\tint opttype = nh[offset];\n\t\tint optlen;\n\n\t\tif (opttype == type)\n\t\t\treturn offset;\n\n\t\tswitch (opttype) {\n\t\tcase IPV6_TLV_PAD1:\n\t\t\toptlen = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len < 2)\n\t\t\t\tgoto bad;\n\t\t\toptlen = nh[offset + 1] + 2;\n\t\t\tif (optlen > len)\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\t}\n\t\toffset += optlen;\n\t\tlen -= optlen;\n\t}\n\t \n bad:\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(ipv6_find_tlv);\n\n \nint ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,\n\t\t  int target, unsigned short *fragoff, int *flags)\n{\n\tunsigned int start = skb_network_offset(skb) + sizeof(struct ipv6hdr);\n\tu8 nexthdr = ipv6_hdr(skb)->nexthdr;\n\tbool found;\n\n\tif (fragoff)\n\t\t*fragoff = 0;\n\n\tif (*offset) {\n\t\tstruct ipv6hdr _ip6, *ip6;\n\n\t\tip6 = skb_header_pointer(skb, *offset, sizeof(_ip6), &_ip6);\n\t\tif (!ip6 || (ip6->version != 6))\n\t\t\treturn -EBADMSG;\n\t\tstart = *offset + sizeof(struct ipv6hdr);\n\t\tnexthdr = ip6->nexthdr;\n\t}\n\n\tdo {\n\t\tstruct ipv6_opt_hdr _hdr, *hp;\n\t\tunsigned int hdrlen;\n\t\tfound = (nexthdr == target);\n\n\t\tif ((!ipv6_ext_hdr(nexthdr)) || nexthdr == NEXTHDR_NONE) {\n\t\t\tif (target < 0 || found)\n\t\t\t\tbreak;\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\thp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\n\t\tif (!hp)\n\t\t\treturn -EBADMSG;\n\n\t\tif (nexthdr == NEXTHDR_ROUTING) {\n\t\t\tstruct ipv6_rt_hdr _rh, *rh;\n\n\t\t\trh = skb_header_pointer(skb, start, sizeof(_rh),\n\t\t\t\t\t\t&_rh);\n\t\t\tif (!rh)\n\t\t\t\treturn -EBADMSG;\n\n\t\t\tif (flags && (*flags & IP6_FH_F_SKIP_RH) &&\n\t\t\t    rh->segments_left == 0)\n\t\t\t\tfound = false;\n\t\t}\n\n\t\tif (nexthdr == NEXTHDR_FRAGMENT) {\n\t\t\tunsigned short _frag_off;\n\t\t\t__be16 *fp;\n\n\t\t\tif (flags)\t \n\t\t\t\t*flags |= IP6_FH_F_FRAG;\n\t\t\tfp = skb_header_pointer(skb,\n\t\t\t\t\t\tstart+offsetof(struct frag_hdr,\n\t\t\t\t\t\t\t       frag_off),\n\t\t\t\t\t\tsizeof(_frag_off),\n\t\t\t\t\t\t&_frag_off);\n\t\t\tif (!fp)\n\t\t\t\treturn -EBADMSG;\n\n\t\t\t_frag_off = ntohs(*fp) & ~0x7;\n\t\t\tif (_frag_off) {\n\t\t\t\tif (target < 0 &&\n\t\t\t\t    ((!ipv6_ext_hdr(hp->nexthdr)) ||\n\t\t\t\t     hp->nexthdr == NEXTHDR_NONE)) {\n\t\t\t\t\tif (fragoff)\n\t\t\t\t\t\t*fragoff = _frag_off;\n\t\t\t\t\treturn hp->nexthdr;\n\t\t\t\t}\n\t\t\t\tif (!found)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t\tif (fragoff)\n\t\t\t\t\t*fragoff = _frag_off;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thdrlen = 8;\n\t\t} else if (nexthdr == NEXTHDR_AUTH) {\n\t\t\tif (flags && (*flags & IP6_FH_F_AUTH) && (target < 0))\n\t\t\t\tbreak;\n\t\t\thdrlen = ipv6_authlen(hp);\n\t\t} else\n\t\t\thdrlen = ipv6_optlen(hp);\n\n\t\tif (!found) {\n\t\t\tnexthdr = hp->nexthdr;\n\t\t\tstart += hdrlen;\n\t\t}\n\t} while (!found);\n\n\t*offset = start;\n\treturn nexthdr;\n}\nEXPORT_SYMBOL(ipv6_find_hdr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}