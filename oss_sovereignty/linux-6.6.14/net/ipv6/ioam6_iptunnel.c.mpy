{
  "module_name": "ioam6_iptunnel.c",
  "hash_id": "7694ac7cd232064c3094d0496682288022027298b6eac54444c3420905f7f1fc",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ioam6_iptunnel.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/ioam6.h>\n#include <linux/ioam6_iptunnel.h>\n#include <net/dst.h>\n#include <net/sock.h>\n#include <net/lwtunnel.h>\n#include <net/ioam6.h>\n#include <net/netlink.h>\n#include <net/ipv6.h>\n#include <net/dst_cache.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n\n#define IOAM6_MASK_SHORT_FIELDS 0xff100000\n#define IOAM6_MASK_WIDE_FIELDS 0xe00000\n\nstruct ioam6_lwt_encap {\n\tstruct ipv6_hopopt_hdr eh;\n\tu8 pad[2];\t\t\t \n\tstruct ioam6_hdr ioamh;\n\tstruct ioam6_trace_hdr traceh;\n} __packed;\n\nstruct ioam6_lwt_freq {\n\tu32 k;\n\tu32 n;\n};\n\nstruct ioam6_lwt {\n\tstruct dst_cache cache;\n\tstruct ioam6_lwt_freq freq;\n\tatomic_t pkt_cnt;\n\tu8 mode;\n\tstruct in6_addr tundst;\n\tstruct ioam6_lwt_encap\ttuninfo;\n};\n\nstatic struct netlink_range_validation freq_range = {\n\t.min = IOAM6_IPTUNNEL_FREQ_MIN,\n\t.max = IOAM6_IPTUNNEL_FREQ_MAX,\n};\n\nstatic struct ioam6_lwt *ioam6_lwt_state(struct lwtunnel_state *lwt)\n{\n\treturn (struct ioam6_lwt *)lwt->data;\n}\n\nstatic struct ioam6_lwt_encap *ioam6_lwt_info(struct lwtunnel_state *lwt)\n{\n\treturn &ioam6_lwt_state(lwt)->tuninfo;\n}\n\nstatic struct ioam6_trace_hdr *ioam6_lwt_trace(struct lwtunnel_state *lwt)\n{\n\treturn &(ioam6_lwt_state(lwt)->tuninfo.traceh);\n}\n\nstatic const struct nla_policy ioam6_iptunnel_policy[IOAM6_IPTUNNEL_MAX + 1] = {\n\t[IOAM6_IPTUNNEL_FREQ_K] = NLA_POLICY_FULL_RANGE(NLA_U32, &freq_range),\n\t[IOAM6_IPTUNNEL_FREQ_N] = NLA_POLICY_FULL_RANGE(NLA_U32, &freq_range),\n\t[IOAM6_IPTUNNEL_MODE]\t= NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\t   IOAM6_IPTUNNEL_MODE_MIN,\n\t\t\t\t\t\t   IOAM6_IPTUNNEL_MODE_MAX),\n\t[IOAM6_IPTUNNEL_DST]\t= NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr)),\n\t[IOAM6_IPTUNNEL_TRACE]\t= NLA_POLICY_EXACT_LEN(sizeof(struct ioam6_trace_hdr)),\n};\n\nstatic bool ioam6_validate_trace_hdr(struct ioam6_trace_hdr *trace)\n{\n\tu32 fields;\n\n\tif (!trace->type_be32 || !trace->remlen ||\n\t    trace->remlen > IOAM6_TRACE_DATA_SIZE_MAX / 4 ||\n\t    trace->type.bit12 | trace->type.bit13 | trace->type.bit14 |\n\t    trace->type.bit15 | trace->type.bit16 | trace->type.bit17 |\n\t    trace->type.bit18 | trace->type.bit19 | trace->type.bit20 |\n\t    trace->type.bit21)\n\t\treturn false;\n\n\ttrace->nodelen = 0;\n\tfields = be32_to_cpu(trace->type_be32);\n\n\ttrace->nodelen += hweight32(fields & IOAM6_MASK_SHORT_FIELDS)\n\t\t\t\t* (sizeof(__be32) / 4);\n\ttrace->nodelen += hweight32(fields & IOAM6_MASK_WIDE_FIELDS)\n\t\t\t\t* (sizeof(__be64) / 4);\n\n\treturn true;\n}\n\nstatic int ioam6_build_state(struct net *net, struct nlattr *nla,\n\t\t\t     unsigned int family, const void *cfg,\n\t\t\t     struct lwtunnel_state **ts,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IOAM6_IPTUNNEL_MAX + 1];\n\tstruct ioam6_lwt_encap *tuninfo;\n\tstruct ioam6_trace_hdr *trace;\n\tstruct lwtunnel_state *lwt;\n\tstruct ioam6_lwt *ilwt;\n\tint len_aligned, err;\n\tu32 freq_k, freq_n;\n\tu8 mode;\n\n\tif (family != AF_INET6)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested(tb, IOAM6_IPTUNNEL_MAX, nla,\n\t\t\t       ioam6_iptunnel_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif ((!tb[IOAM6_IPTUNNEL_FREQ_K] && tb[IOAM6_IPTUNNEL_FREQ_N]) ||\n\t    (tb[IOAM6_IPTUNNEL_FREQ_K] && !tb[IOAM6_IPTUNNEL_FREQ_N])) {\n\t\tNL_SET_ERR_MSG(extack, \"freq: missing parameter\");\n\t\treturn -EINVAL;\n\t} else if (!tb[IOAM6_IPTUNNEL_FREQ_K] && !tb[IOAM6_IPTUNNEL_FREQ_N]) {\n\t\tfreq_k = IOAM6_IPTUNNEL_FREQ_MIN;\n\t\tfreq_n = IOAM6_IPTUNNEL_FREQ_MIN;\n\t} else {\n\t\tfreq_k = nla_get_u32(tb[IOAM6_IPTUNNEL_FREQ_K]);\n\t\tfreq_n = nla_get_u32(tb[IOAM6_IPTUNNEL_FREQ_N]);\n\n\t\tif (freq_k > freq_n) {\n\t\t\tNL_SET_ERR_MSG(extack, \"freq: k > n is forbidden\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!tb[IOAM6_IPTUNNEL_MODE])\n\t\tmode = IOAM6_IPTUNNEL_MODE_INLINE;\n\telse\n\t\tmode = nla_get_u8(tb[IOAM6_IPTUNNEL_MODE]);\n\n\tif (!tb[IOAM6_IPTUNNEL_DST] && mode != IOAM6_IPTUNNEL_MODE_INLINE) {\n\t\tNL_SET_ERR_MSG(extack, \"this mode needs a tunnel destination\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tb[IOAM6_IPTUNNEL_TRACE]) {\n\t\tNL_SET_ERR_MSG(extack, \"missing trace\");\n\t\treturn -EINVAL;\n\t}\n\n\ttrace = nla_data(tb[IOAM6_IPTUNNEL_TRACE]);\n\tif (!ioam6_validate_trace_hdr(trace)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IOAM6_IPTUNNEL_TRACE],\n\t\t\t\t    \"invalid trace validation\");\n\t\treturn -EINVAL;\n\t}\n\n\tlen_aligned = ALIGN(trace->remlen * 4, 8);\n\tlwt = lwtunnel_state_alloc(sizeof(*ilwt) + len_aligned);\n\tif (!lwt)\n\t\treturn -ENOMEM;\n\n\tilwt = ioam6_lwt_state(lwt);\n\terr = dst_cache_init(&ilwt->cache, GFP_ATOMIC);\n\tif (err) {\n\t\tkfree(lwt);\n\t\treturn err;\n\t}\n\n\tatomic_set(&ilwt->pkt_cnt, 0);\n\tilwt->freq.k = freq_k;\n\tilwt->freq.n = freq_n;\n\n\tilwt->mode = mode;\n\tif (tb[IOAM6_IPTUNNEL_DST])\n\t\tilwt->tundst = nla_get_in6_addr(tb[IOAM6_IPTUNNEL_DST]);\n\n\ttuninfo = ioam6_lwt_info(lwt);\n\ttuninfo->eh.hdrlen = ((sizeof(*tuninfo) + len_aligned) >> 3) - 1;\n\ttuninfo->pad[0] = IPV6_TLV_PADN;\n\ttuninfo->ioamh.type = IOAM6_TYPE_PREALLOC;\n\ttuninfo->ioamh.opt_type = IPV6_TLV_IOAM;\n\ttuninfo->ioamh.opt_len = sizeof(tuninfo->ioamh) - 2 + sizeof(*trace)\n\t\t\t\t\t+ trace->remlen * 4;\n\n\tmemcpy(&tuninfo->traceh, trace, sizeof(*trace));\n\n\tif (len_aligned - trace->remlen * 4) {\n\t\ttuninfo->traceh.data[trace->remlen * 4] = IPV6_TLV_PADN;\n\t\ttuninfo->traceh.data[trace->remlen * 4 + 1] = 2;\n\t}\n\n\tlwt->type = LWTUNNEL_ENCAP_IOAM6;\n\tlwt->flags |= LWTUNNEL_STATE_OUTPUT_REDIRECT;\n\n\t*ts = lwt;\n\n\treturn 0;\n}\n\nstatic int ioam6_do_fill(struct net *net, struct sk_buff *skb)\n{\n\tstruct ioam6_trace_hdr *trace;\n\tstruct ioam6_namespace *ns;\n\n\ttrace = (struct ioam6_trace_hdr *)(skb_transport_header(skb)\n\t\t\t\t\t   + sizeof(struct ipv6_hopopt_hdr) + 2\n\t\t\t\t\t   + sizeof(struct ioam6_hdr));\n\n\tns = ioam6_namespace(net, trace->namespace_id);\n\tif (ns)\n\t\tioam6_fill_trace_data(skb, ns, trace, false);\n\n\treturn 0;\n}\n\nstatic int ioam6_do_inline(struct net *net, struct sk_buff *skb,\n\t\t\t   struct ioam6_lwt_encap *tuninfo)\n{\n\tstruct ipv6hdr *oldhdr, *hdr;\n\tint hdrlen, err;\n\n\thdrlen = (tuninfo->eh.hdrlen + 1) << 3;\n\n\terr = skb_cow_head(skb, hdrlen + skb->mac_len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\toldhdr = ipv6_hdr(skb);\n\tskb_pull(skb, sizeof(*oldhdr));\n\tskb_postpull_rcsum(skb, skb_network_header(skb), sizeof(*oldhdr));\n\n\tskb_push(skb, sizeof(*oldhdr) + hdrlen);\n\tskb_reset_network_header(skb);\n\tskb_mac_header_rebuild(skb);\n\n\thdr = ipv6_hdr(skb);\n\tmemmove(hdr, oldhdr, sizeof(*oldhdr));\n\ttuninfo->eh.nexthdr = hdr->nexthdr;\n\n\tskb_set_transport_header(skb, sizeof(*hdr));\n\tskb_postpush_rcsum(skb, hdr, sizeof(*hdr) + hdrlen);\n\n\tmemcpy(skb_transport_header(skb), (u8 *)tuninfo, hdrlen);\n\n\thdr->nexthdr = NEXTHDR_HOP;\n\thdr->payload_len = cpu_to_be16(skb->len - sizeof(*hdr));\n\n\treturn ioam6_do_fill(net, skb);\n}\n\nstatic int ioam6_do_encap(struct net *net, struct sk_buff *skb,\n\t\t\t  struct ioam6_lwt_encap *tuninfo,\n\t\t\t  struct in6_addr *tundst)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *hdr, *inner_hdr;\n\tint hdrlen, len, err;\n\n\thdrlen = (tuninfo->eh.hdrlen + 1) << 3;\n\tlen = sizeof(*hdr) + hdrlen;\n\n\terr = skb_cow_head(skb, len + skb->mac_len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tinner_hdr = ipv6_hdr(skb);\n\n\tskb_push(skb, len);\n\tskb_reset_network_header(skb);\n\tskb_mac_header_rebuild(skb);\n\tskb_set_transport_header(skb, sizeof(*hdr));\n\n\ttuninfo->eh.nexthdr = NEXTHDR_IPV6;\n\tmemcpy(skb_transport_header(skb), (u8 *)tuninfo, hdrlen);\n\n\thdr = ipv6_hdr(skb);\n\tmemcpy(hdr, inner_hdr, sizeof(*hdr));\n\n\thdr->nexthdr = NEXTHDR_HOP;\n\thdr->payload_len = cpu_to_be16(skb->len - sizeof(*hdr));\n\thdr->daddr = *tundst;\n\tipv6_dev_get_saddr(net, dst->dev, &hdr->daddr,\n\t\t\t   IPV6_PREFER_SRC_PUBLIC, &hdr->saddr);\n\n\tskb_postpush_rcsum(skb, hdr, len);\n\n\treturn ioam6_do_fill(net, skb);\n}\n\nstatic int ioam6_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct in6_addr orig_daddr;\n\tstruct ioam6_lwt *ilwt;\n\tint err = -EINVAL;\n\tu32 pkt_cnt;\n\n\tif (skb->protocol != htons(ETH_P_IPV6))\n\t\tgoto drop;\n\n\tilwt = ioam6_lwt_state(dst->lwtstate);\n\n\t \n\tpkt_cnt = atomic_fetch_inc(&ilwt->pkt_cnt);\n\tif (pkt_cnt % ilwt->freq.n >= ilwt->freq.k)\n\t\tgoto out;\n\n\torig_daddr = ipv6_hdr(skb)->daddr;\n\n\tswitch (ilwt->mode) {\n\tcase IOAM6_IPTUNNEL_MODE_INLINE:\ndo_inline:\n\t\t \n\t\tif (ipv6_hdr(skb)->nexthdr == NEXTHDR_HOP)\n\t\t\tgoto out;\n\n\t\terr = ioam6_do_inline(net, skb, &ilwt->tuninfo);\n\t\tif (unlikely(err))\n\t\t\tgoto drop;\n\n\t\tbreak;\n\tcase IOAM6_IPTUNNEL_MODE_ENCAP:\ndo_encap:\n\t\t \n\t\terr = ioam6_do_encap(net, skb, &ilwt->tuninfo, &ilwt->tundst);\n\t\tif (unlikely(err))\n\t\t\tgoto drop;\n\n\t\tbreak;\n\tcase IOAM6_IPTUNNEL_MODE_AUTO:\n\t\t \n\t\tif (!skb->dev)\n\t\t\tgoto do_inline;\n\n\t\tgoto do_encap;\n\tdefault:\n\t\tgoto drop;\n\t}\n\n\terr = skb_cow_head(skb, LL_RESERVED_SPACE(dst->dev));\n\tif (unlikely(err))\n\t\tgoto drop;\n\n\tif (!ipv6_addr_equal(&orig_daddr, &ipv6_hdr(skb)->daddr)) {\n\t\tpreempt_disable();\n\t\tdst = dst_cache_get(&ilwt->cache);\n\t\tpreempt_enable();\n\n\t\tif (unlikely(!dst)) {\n\t\t\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\t\t\tstruct flowi6 fl6;\n\n\t\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\t\tfl6.daddr = hdr->daddr;\n\t\t\tfl6.saddr = hdr->saddr;\n\t\t\tfl6.flowlabel = ip6_flowinfo(hdr);\n\t\t\tfl6.flowi6_mark = skb->mark;\n\t\t\tfl6.flowi6_proto = hdr->nexthdr;\n\n\t\t\tdst = ip6_route_output(net, NULL, &fl6);\n\t\t\tif (dst->error) {\n\t\t\t\terr = dst->error;\n\t\t\t\tdst_release(dst);\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\tpreempt_disable();\n\t\t\tdst_cache_set_ip6(&ilwt->cache, dst, &fl6.saddr);\n\t\t\tpreempt_enable();\n\t\t}\n\n\t\tskb_dst_drop(skb);\n\t\tskb_dst_set(skb, dst);\n\n\t\treturn dst_output(net, sk, skb);\n\t}\nout:\n\treturn dst->lwtstate->orig_output(net, sk, skb);\ndrop:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic void ioam6_destroy_state(struct lwtunnel_state *lwt)\n{\n\tdst_cache_destroy(&ioam6_lwt_state(lwt)->cache);\n}\n\nstatic int ioam6_fill_encap_info(struct sk_buff *skb,\n\t\t\t\t struct lwtunnel_state *lwtstate)\n{\n\tstruct ioam6_lwt *ilwt = ioam6_lwt_state(lwtstate);\n\tint err;\n\n\terr = nla_put_u32(skb, IOAM6_IPTUNNEL_FREQ_K, ilwt->freq.k);\n\tif (err)\n\t\tgoto ret;\n\n\terr = nla_put_u32(skb, IOAM6_IPTUNNEL_FREQ_N, ilwt->freq.n);\n\tif (err)\n\t\tgoto ret;\n\n\terr = nla_put_u8(skb, IOAM6_IPTUNNEL_MODE, ilwt->mode);\n\tif (err)\n\t\tgoto ret;\n\n\tif (ilwt->mode != IOAM6_IPTUNNEL_MODE_INLINE) {\n\t\terr = nla_put_in6_addr(skb, IOAM6_IPTUNNEL_DST, &ilwt->tundst);\n\t\tif (err)\n\t\t\tgoto ret;\n\t}\n\n\terr = nla_put(skb, IOAM6_IPTUNNEL_TRACE, sizeof(ilwt->tuninfo.traceh),\n\t\t      &ilwt->tuninfo.traceh);\nret:\n\treturn err;\n}\n\nstatic int ioam6_encap_nlsize(struct lwtunnel_state *lwtstate)\n{\n\tstruct ioam6_lwt *ilwt = ioam6_lwt_state(lwtstate);\n\tint nlsize;\n\n\tnlsize = nla_total_size(sizeof(ilwt->freq.k)) +\n\t\t  nla_total_size(sizeof(ilwt->freq.n)) +\n\t\t  nla_total_size(sizeof(ilwt->mode)) +\n\t\t  nla_total_size(sizeof(ilwt->tuninfo.traceh));\n\n\tif (ilwt->mode != IOAM6_IPTUNNEL_MODE_INLINE)\n\t\tnlsize += nla_total_size(sizeof(ilwt->tundst));\n\n\treturn nlsize;\n}\n\nstatic int ioam6_encap_cmp(struct lwtunnel_state *a, struct lwtunnel_state *b)\n{\n\tstruct ioam6_trace_hdr *trace_a = ioam6_lwt_trace(a);\n\tstruct ioam6_trace_hdr *trace_b = ioam6_lwt_trace(b);\n\tstruct ioam6_lwt *ilwt_a = ioam6_lwt_state(a);\n\tstruct ioam6_lwt *ilwt_b = ioam6_lwt_state(b);\n\n\treturn (ilwt_a->freq.k != ilwt_b->freq.k ||\n\t\tilwt_a->freq.n != ilwt_b->freq.n ||\n\t\tilwt_a->mode != ilwt_b->mode ||\n\t\t(ilwt_a->mode != IOAM6_IPTUNNEL_MODE_INLINE &&\n\t\t !ipv6_addr_equal(&ilwt_a->tundst, &ilwt_b->tundst)) ||\n\t\ttrace_a->namespace_id != trace_b->namespace_id);\n}\n\nstatic const struct lwtunnel_encap_ops ioam6_iptun_ops = {\n\t.build_state\t\t= ioam6_build_state,\n\t.destroy_state\t\t= ioam6_destroy_state,\n\t.output\t\t= ioam6_output,\n\t.fill_encap\t\t= ioam6_fill_encap_info,\n\t.get_encap_size\t= ioam6_encap_nlsize,\n\t.cmp_encap\t\t= ioam6_encap_cmp,\n\t.owner\t\t\t= THIS_MODULE,\n};\n\nint __init ioam6_iptunnel_init(void)\n{\n\treturn lwtunnel_encap_add_ops(&ioam6_iptun_ops, LWTUNNEL_ENCAP_IOAM6);\n}\n\nvoid ioam6_iptunnel_exit(void)\n{\n\tlwtunnel_encap_del_ops(&ioam6_iptun_ops, LWTUNNEL_ENCAP_IOAM6);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}