{
  "module_name": "ip6_udp_tunnel.c",
  "hash_id": "ffcc7f4d4f2140691b89db121f34e8dbef181d3bedc3ac13a1d87bac47ba6836",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ip6_udp_tunnel.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/socket.h>\n#include <linux/udp.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/in6.h>\n#include <net/udp.h>\n#include <net/udp_tunnel.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/ip6_tunnel.h>\n#include <net/ip6_checksum.h>\n\nint udp_sock_create6(struct net *net, struct udp_port_cfg *cfg,\n\t\t     struct socket **sockp)\n{\n\tstruct sockaddr_in6 udp6_addr = {};\n\tint err;\n\tstruct socket *sock = NULL;\n\n\terr = sock_create_kern(net, AF_INET6, SOCK_DGRAM, 0, &sock);\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (cfg->ipv6_v6only) {\n\t\terr = ip6_sock_set_v6only(sock->sk);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\tif (cfg->bind_ifindex) {\n\t\terr = sock_bindtoindex(sock->sk, cfg->bind_ifindex, true);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\tudp6_addr.sin6_family = AF_INET6;\n\tmemcpy(&udp6_addr.sin6_addr, &cfg->local_ip6,\n\t       sizeof(udp6_addr.sin6_addr));\n\tudp6_addr.sin6_port = cfg->local_udp_port;\n\terr = kernel_bind(sock, (struct sockaddr *)&udp6_addr,\n\t\t\t  sizeof(udp6_addr));\n\tif (err < 0)\n\t\tgoto error;\n\n\tif (cfg->peer_udp_port) {\n\t\tmemset(&udp6_addr, 0, sizeof(udp6_addr));\n\t\tudp6_addr.sin6_family = AF_INET6;\n\t\tmemcpy(&udp6_addr.sin6_addr, &cfg->peer_ip6,\n\t\t       sizeof(udp6_addr.sin6_addr));\n\t\tudp6_addr.sin6_port = cfg->peer_udp_port;\n\t\terr = kernel_connect(sock,\n\t\t\t\t     (struct sockaddr *)&udp6_addr,\n\t\t\t\t     sizeof(udp6_addr), 0);\n\t}\n\tif (err < 0)\n\t\tgoto error;\n\n\tudp_set_no_check6_tx(sock->sk, !cfg->use_udp6_tx_checksums);\n\tudp_set_no_check6_rx(sock->sk, !cfg->use_udp6_rx_checksums);\n\n\t*sockp = sock;\n\treturn 0;\n\nerror:\n\tif (sock) {\n\t\tkernel_sock_shutdown(sock, SHUT_RDWR);\n\t\tsock_release(sock);\n\t}\n\t*sockp = NULL;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(udp_sock_create6);\n\nint udp_tunnel6_xmit_skb(struct dst_entry *dst, struct sock *sk,\n\t\t\t struct sk_buff *skb,\n\t\t\t struct net_device *dev, struct in6_addr *saddr,\n\t\t\t struct in6_addr *daddr,\n\t\t\t __u8 prio, __u8 ttl, __be32 label,\n\t\t\t __be16 src_port, __be16 dst_port, bool nocheck)\n{\n\tstruct udphdr *uh;\n\tstruct ipv6hdr *ip6h;\n\n\t__skb_push(skb, sizeof(*uh));\n\tskb_reset_transport_header(skb);\n\tuh = udp_hdr(skb);\n\n\tuh->dest = dst_port;\n\tuh->source = src_port;\n\n\tuh->len = htons(skb->len);\n\n\tskb_dst_set(skb, dst);\n\n\tudp6_set_csum(nocheck, skb, saddr, daddr, skb->len);\n\n\t__skb_push(skb, sizeof(*ip6h));\n\tskb_reset_network_header(skb);\n\tip6h\t\t  = ipv6_hdr(skb);\n\tip6_flow_hdr(ip6h, prio, label);\n\tip6h->payload_len = htons(skb->len);\n\tip6h->nexthdr     = IPPROTO_UDP;\n\tip6h->hop_limit   = ttl;\n\tip6h->daddr\t  = *daddr;\n\tip6h->saddr\t  = *saddr;\n\n\tip6tunnel_xmit(sk, skb, dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(udp_tunnel6_xmit_skb);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}