{
  "module_name": "addrconf.c",
  "hash_id": "f3613370cc668b9e7c7f2492727a875a252c1c0e53804701ff2b3701ad35cf39",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/addrconf.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_addr.h>\n#include <linux/if_arp.h>\n#include <linux/if_arcnet.h>\n#include <linux/if_infiniband.h>\n#include <linux/route.h>\n#include <linux/inetdevice.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n#include <linux/capability.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/string.h>\n#include <linux/hash.h>\n\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/6lowpan.h>\n#include <net/firewire.h>\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/ndisc.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/tcp.h>\n#include <net/ip.h>\n#include <net/netlink.h>\n#include <net/pkt_sched.h>\n#include <net/l3mdev.h>\n#include <linux/if_tunnel.h>\n#include <linux/rtnetlink.h>\n#include <linux/netconf.h>\n#include <linux/random.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/ioam6.h>\n\n#define\tINFINITY_LIFE_TIME\t0xFFFFFFFF\n\n#define IPV6_MAX_STRLEN \\\n\tsizeof(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")\n\nstatic inline u32 cstamp_delta(unsigned long cstamp)\n{\n\treturn (cstamp - INITIAL_JIFFIES) * 100UL / HZ;\n}\n\nstatic inline s32 rfc3315_s14_backoff_init(s32 irt)\n{\n\t \n\tu64 tmp = get_random_u32_inclusive(900000, 1100000) * (u64)irt;\n\tdo_div(tmp, 1000000);\n\treturn (s32)tmp;\n}\n\nstatic inline s32 rfc3315_s14_backoff_update(s32 rt, s32 mrt)\n{\n\t \n\tu64 tmp = get_random_u32_inclusive(1900000, 2100000) * (u64)rt;\n\tdo_div(tmp, 1000000);\n\tif ((s32)tmp > mrt) {\n\t\t \n\t\ttmp = get_random_u32_inclusive(900000, 1100000) * (u64)mrt;\n\t\tdo_div(tmp, 1000000);\n\t}\n\treturn (s32)tmp;\n}\n\n#ifdef CONFIG_SYSCTL\nstatic int addrconf_sysctl_register(struct inet6_dev *idev);\nstatic void addrconf_sysctl_unregister(struct inet6_dev *idev);\n#else\nstatic inline int addrconf_sysctl_register(struct inet6_dev *idev)\n{\n\treturn 0;\n}\n\nstatic inline void addrconf_sysctl_unregister(struct inet6_dev *idev)\n{\n}\n#endif\n\nstatic void ipv6_gen_rnd_iid(struct in6_addr *addr);\n\nstatic int ipv6_generate_eui64(u8 *eui, struct net_device *dev);\nstatic int ipv6_count_addresses(const struct inet6_dev *idev);\nstatic int ipv6_generate_stable_address(struct in6_addr *addr,\n\t\t\t\t\tu8 dad_count,\n\t\t\t\t\tconst struct inet6_dev *idev);\n\n#define IN6_ADDR_HSIZE_SHIFT\t8\n#define IN6_ADDR_HSIZE\t\t(1 << IN6_ADDR_HSIZE_SHIFT)\n\nstatic void addrconf_verify(struct net *net);\nstatic void addrconf_verify_rtnl(struct net *net);\n\nstatic struct workqueue_struct *addrconf_wq;\n\nstatic void addrconf_join_anycast(struct inet6_ifaddr *ifp);\nstatic void addrconf_leave_anycast(struct inet6_ifaddr *ifp);\n\nstatic void addrconf_type_change(struct net_device *dev,\n\t\t\t\t unsigned long event);\nstatic int addrconf_ifdown(struct net_device *dev, bool unregister);\n\nstatic struct fib6_info *addrconf_get_prefix_route(const struct in6_addr *pfx,\n\t\t\t\t\t\t  int plen,\n\t\t\t\t\t\t  const struct net_device *dev,\n\t\t\t\t\t\t  u32 flags, u32 noflags,\n\t\t\t\t\t\t  bool no_gw);\n\nstatic void addrconf_dad_start(struct inet6_ifaddr *ifp);\nstatic void addrconf_dad_work(struct work_struct *w);\nstatic void addrconf_dad_completed(struct inet6_ifaddr *ifp, bool bump_id,\n\t\t\t\t   bool send_na);\nstatic void addrconf_dad_run(struct inet6_dev *idev, bool restart);\nstatic void addrconf_rs_timer(struct timer_list *t);\nstatic void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifa);\nstatic void ipv6_ifa_notify(int event, struct inet6_ifaddr *ifa);\n\nstatic void inet6_prefix_notify(int event, struct inet6_dev *idev,\n\t\t\t\tstruct prefix_info *pinfo);\n\nstatic struct ipv6_devconf ipv6_devconf __read_mostly = {\n\t.forwarding\t\t= 0,\n\t.hop_limit\t\t= IPV6_DEFAULT_HOPLIMIT,\n\t.mtu6\t\t\t= IPV6_MIN_MTU,\n\t.accept_ra\t\t= 1,\n\t.accept_redirects\t= 1,\n\t.autoconf\t\t= 1,\n\t.force_mld_version\t= 0,\n\t.mldv1_unsolicited_report_interval = 10 * HZ,\n\t.mldv2_unsolicited_report_interval = HZ,\n\t.dad_transmits\t\t= 1,\n\t.rtr_solicits\t\t= MAX_RTR_SOLICITATIONS,\n\t.rtr_solicit_interval\t= RTR_SOLICITATION_INTERVAL,\n\t.rtr_solicit_max_interval = RTR_SOLICITATION_MAX_INTERVAL,\n\t.rtr_solicit_delay\t= MAX_RTR_SOLICITATION_DELAY,\n\t.use_tempaddr\t\t= 0,\n\t.temp_valid_lft\t\t= TEMP_VALID_LIFETIME,\n\t.temp_prefered_lft\t= TEMP_PREFERRED_LIFETIME,\n\t.regen_max_retry\t= REGEN_MAX_RETRY,\n\t.max_desync_factor\t= MAX_DESYNC_FACTOR,\n\t.max_addresses\t\t= IPV6_MAX_ADDRESSES,\n\t.accept_ra_defrtr\t= 1,\n\t.ra_defrtr_metric\t= IP6_RT_PRIO_USER,\n\t.accept_ra_from_local\t= 0,\n\t.accept_ra_min_hop_limit= 1,\n\t.accept_ra_min_lft\t= 0,\n\t.accept_ra_pinfo\t= 1,\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\t.accept_ra_rtr_pref\t= 1,\n\t.rtr_probe_interval\t= 60 * HZ,\n#ifdef CONFIG_IPV6_ROUTE_INFO\n\t.accept_ra_rt_info_min_plen = 0,\n\t.accept_ra_rt_info_max_plen = 0,\n#endif\n#endif\n\t.proxy_ndp\t\t= 0,\n\t.accept_source_route\t= 0,\t \n\t.disable_ipv6\t\t= 0,\n\t.accept_dad\t\t= 0,\n\t.suppress_frag_ndisc\t= 1,\n\t.accept_ra_mtu\t\t= 1,\n\t.stable_secret\t\t= {\n\t\t.initialized = false,\n\t},\n\t.use_oif_addrs_only\t= 0,\n\t.ignore_routes_with_linkdown = 0,\n\t.keep_addr_on_down\t= 0,\n\t.seg6_enabled\t\t= 0,\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\t.seg6_require_hmac\t= 0,\n#endif\n\t.enhanced_dad           = 1,\n\t.addr_gen_mode\t\t= IN6_ADDR_GEN_MODE_EUI64,\n\t.disable_policy\t\t= 0,\n\t.rpl_seg_enabled\t= 0,\n\t.ioam6_enabled\t\t= 0,\n\t.ioam6_id               = IOAM6_DEFAULT_IF_ID,\n\t.ioam6_id_wide\t\t= IOAM6_DEFAULT_IF_ID_WIDE,\n\t.ndisc_evict_nocarrier\t= 1,\n};\n\nstatic struct ipv6_devconf ipv6_devconf_dflt __read_mostly = {\n\t.forwarding\t\t= 0,\n\t.hop_limit\t\t= IPV6_DEFAULT_HOPLIMIT,\n\t.mtu6\t\t\t= IPV6_MIN_MTU,\n\t.accept_ra\t\t= 1,\n\t.accept_redirects\t= 1,\n\t.autoconf\t\t= 1,\n\t.force_mld_version\t= 0,\n\t.mldv1_unsolicited_report_interval = 10 * HZ,\n\t.mldv2_unsolicited_report_interval = HZ,\n\t.dad_transmits\t\t= 1,\n\t.rtr_solicits\t\t= MAX_RTR_SOLICITATIONS,\n\t.rtr_solicit_interval\t= RTR_SOLICITATION_INTERVAL,\n\t.rtr_solicit_max_interval = RTR_SOLICITATION_MAX_INTERVAL,\n\t.rtr_solicit_delay\t= MAX_RTR_SOLICITATION_DELAY,\n\t.use_tempaddr\t\t= 0,\n\t.temp_valid_lft\t\t= TEMP_VALID_LIFETIME,\n\t.temp_prefered_lft\t= TEMP_PREFERRED_LIFETIME,\n\t.regen_max_retry\t= REGEN_MAX_RETRY,\n\t.max_desync_factor\t= MAX_DESYNC_FACTOR,\n\t.max_addresses\t\t= IPV6_MAX_ADDRESSES,\n\t.accept_ra_defrtr\t= 1,\n\t.ra_defrtr_metric\t= IP6_RT_PRIO_USER,\n\t.accept_ra_from_local\t= 0,\n\t.accept_ra_min_hop_limit= 1,\n\t.accept_ra_min_lft\t= 0,\n\t.accept_ra_pinfo\t= 1,\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\t.accept_ra_rtr_pref\t= 1,\n\t.rtr_probe_interval\t= 60 * HZ,\n#ifdef CONFIG_IPV6_ROUTE_INFO\n\t.accept_ra_rt_info_min_plen = 0,\n\t.accept_ra_rt_info_max_plen = 0,\n#endif\n#endif\n\t.proxy_ndp\t\t= 0,\n\t.accept_source_route\t= 0,\t \n\t.disable_ipv6\t\t= 0,\n\t.accept_dad\t\t= 1,\n\t.suppress_frag_ndisc\t= 1,\n\t.accept_ra_mtu\t\t= 1,\n\t.stable_secret\t\t= {\n\t\t.initialized = false,\n\t},\n\t.use_oif_addrs_only\t= 0,\n\t.ignore_routes_with_linkdown = 0,\n\t.keep_addr_on_down\t= 0,\n\t.seg6_enabled\t\t= 0,\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\t.seg6_require_hmac\t= 0,\n#endif\n\t.enhanced_dad           = 1,\n\t.addr_gen_mode\t\t= IN6_ADDR_GEN_MODE_EUI64,\n\t.disable_policy\t\t= 0,\n\t.rpl_seg_enabled\t= 0,\n\t.ioam6_enabled\t\t= 0,\n\t.ioam6_id               = IOAM6_DEFAULT_IF_ID,\n\t.ioam6_id_wide\t\t= IOAM6_DEFAULT_IF_ID_WIDE,\n\t.ndisc_evict_nocarrier\t= 1,\n};\n\n \nstatic inline bool addrconf_link_ready(const struct net_device *dev)\n{\n\treturn netif_oper_up(dev) && !qdisc_tx_is_noop(dev);\n}\n\nstatic void addrconf_del_rs_timer(struct inet6_dev *idev)\n{\n\tif (del_timer(&idev->rs_timer))\n\t\t__in6_dev_put(idev);\n}\n\nstatic void addrconf_del_dad_work(struct inet6_ifaddr *ifp)\n{\n\tif (cancel_delayed_work(&ifp->dad_work))\n\t\t__in6_ifa_put(ifp);\n}\n\nstatic void addrconf_mod_rs_timer(struct inet6_dev *idev,\n\t\t\t\t  unsigned long when)\n{\n\tif (!mod_timer(&idev->rs_timer, jiffies + when))\n\t\tin6_dev_hold(idev);\n}\n\nstatic void addrconf_mod_dad_work(struct inet6_ifaddr *ifp,\n\t\t\t\t   unsigned long delay)\n{\n\tin6_ifa_hold(ifp);\n\tif (mod_delayed_work(addrconf_wq, &ifp->dad_work, delay))\n\t\tin6_ifa_put(ifp);\n}\n\nstatic int snmp6_alloc_dev(struct inet6_dev *idev)\n{\n\tint i;\n\n\tidev->stats.ipv6 = alloc_percpu_gfp(struct ipstats_mib, GFP_KERNEL_ACCOUNT);\n\tif (!idev->stats.ipv6)\n\t\tgoto err_ip;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct ipstats_mib *addrconf_stats;\n\t\taddrconf_stats = per_cpu_ptr(idev->stats.ipv6, i);\n\t\tu64_stats_init(&addrconf_stats->syncp);\n\t}\n\n\n\tidev->stats.icmpv6dev = kzalloc(sizeof(struct icmpv6_mib_device),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!idev->stats.icmpv6dev)\n\t\tgoto err_icmp;\n\tidev->stats.icmpv6msgdev = kzalloc(sizeof(struct icmpv6msg_mib_device),\n\t\t\t\t\t   GFP_KERNEL_ACCOUNT);\n\tif (!idev->stats.icmpv6msgdev)\n\t\tgoto err_icmpmsg;\n\n\treturn 0;\n\nerr_icmpmsg:\n\tkfree(idev->stats.icmpv6dev);\nerr_icmp:\n\tfree_percpu(idev->stats.ipv6);\nerr_ip:\n\treturn -ENOMEM;\n}\n\nstatic struct inet6_dev *ipv6_add_dev(struct net_device *dev)\n{\n\tstruct inet6_dev *ndev;\n\tint err = -ENOMEM;\n\n\tASSERT_RTNL();\n\n\tif (dev->mtu < IPV6_MIN_MTU && dev != blackhole_netdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tndev = kzalloc(sizeof(*ndev), GFP_KERNEL_ACCOUNT);\n\tif (!ndev)\n\t\treturn ERR_PTR(err);\n\n\trwlock_init(&ndev->lock);\n\tndev->dev = dev;\n\tINIT_LIST_HEAD(&ndev->addr_list);\n\ttimer_setup(&ndev->rs_timer, addrconf_rs_timer, 0);\n\tmemcpy(&ndev->cnf, dev_net(dev)->ipv6.devconf_dflt, sizeof(ndev->cnf));\n\n\tif (ndev->cnf.stable_secret.initialized)\n\t\tndev->cnf.addr_gen_mode = IN6_ADDR_GEN_MODE_STABLE_PRIVACY;\n\n\tndev->cnf.mtu6 = dev->mtu;\n\tndev->ra_mtu = 0;\n\tndev->nd_parms = neigh_parms_alloc(dev, &nd_tbl);\n\tif (!ndev->nd_parms) {\n\t\tkfree(ndev);\n\t\treturn ERR_PTR(err);\n\t}\n\tif (ndev->cnf.forwarding)\n\t\tdev_disable_lro(dev);\n\t \n\tnetdev_hold(dev, &ndev->dev_tracker, GFP_KERNEL);\n\n\tif (snmp6_alloc_dev(ndev) < 0) {\n\t\tnetdev_dbg(dev, \"%s: cannot allocate memory for statistics\\n\",\n\t\t\t   __func__);\n\t\tneigh_parms_release(&nd_tbl, ndev->nd_parms);\n\t\tnetdev_put(dev, &ndev->dev_tracker);\n\t\tkfree(ndev);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tif (dev != blackhole_netdev) {\n\t\tif (snmp6_register_dev(ndev) < 0) {\n\t\t\tnetdev_dbg(dev, \"%s: cannot create /proc/net/dev_snmp6/%s\\n\",\n\t\t\t\t   __func__, dev->name);\n\t\t\tgoto err_release;\n\t\t}\n\t}\n\t \n\trefcount_set(&ndev->refcnt, 1);\n\n\tif (dev->flags & (IFF_NOARP | IFF_LOOPBACK))\n\t\tndev->cnf.accept_dad = -1;\n\n#if IS_ENABLED(CONFIG_IPV6_SIT)\n\tif (dev->type == ARPHRD_SIT && (dev->priv_flags & IFF_ISATAP)) {\n\t\tpr_info(\"%s: Disabled Multicast RS\\n\", dev->name);\n\t\tndev->cnf.rtr_solicits = 0;\n\t}\n#endif\n\n\tINIT_LIST_HEAD(&ndev->tempaddr_list);\n\tndev->desync_factor = U32_MAX;\n\tif ((dev->flags&IFF_LOOPBACK) ||\n\t    dev->type == ARPHRD_TUNNEL ||\n\t    dev->type == ARPHRD_TUNNEL6 ||\n\t    dev->type == ARPHRD_SIT ||\n\t    dev->type == ARPHRD_NONE) {\n\t\tndev->cnf.use_tempaddr = -1;\n\t}\n\n\tndev->token = in6addr_any;\n\n\tif (netif_running(dev) && addrconf_link_ready(dev))\n\t\tndev->if_flags |= IF_READY;\n\n\tipv6_mc_init_dev(ndev);\n\tndev->tstamp = jiffies;\n\tif (dev != blackhole_netdev) {\n\t\terr = addrconf_sysctl_register(ndev);\n\t\tif (err) {\n\t\t\tipv6_mc_destroy_dev(ndev);\n\t\t\tsnmp6_unregister_dev(ndev);\n\t\t\tgoto err_release;\n\t\t}\n\t}\n\t \n\trcu_assign_pointer(dev->ip6_ptr, ndev);\n\n\tif (dev != blackhole_netdev) {\n\t\t \n\t\tipv6_dev_mc_inc(dev, &in6addr_interfacelocal_allnodes);\n\n\t\t \n\t\tipv6_dev_mc_inc(dev, &in6addr_linklocal_allnodes);\n\n\t\t \n\t\tif (ndev->cnf.forwarding && (dev->flags & IFF_MULTICAST))\n\t\t\tipv6_dev_mc_inc(dev, &in6addr_linklocal_allrouters);\n\t}\n\treturn ndev;\n\nerr_release:\n\tneigh_parms_release(&nd_tbl, ndev->nd_parms);\n\tndev->dead = 1;\n\tin6_dev_finish_destroy(ndev);\n\treturn ERR_PTR(err);\n}\n\nstatic struct inet6_dev *ipv6_find_idev(struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\n\tASSERT_RTNL();\n\n\tidev = __in6_dev_get(dev);\n\tif (!idev) {\n\t\tidev = ipv6_add_dev(dev);\n\t\tif (IS_ERR(idev))\n\t\t\treturn idev;\n\t}\n\n\tif (dev->flags&IFF_UP)\n\t\tipv6_mc_up(idev);\n\treturn idev;\n}\n\nstatic int inet6_netconf_msgsize_devconf(int type)\n{\n\tint size =  NLMSG_ALIGN(sizeof(struct netconfmsg))\n\t\t    + nla_total_size(4);\t \n\tbool all = false;\n\n\tif (type == NETCONFA_ALL)\n\t\tall = true;\n\n\tif (all || type == NETCONFA_FORWARDING)\n\t\tsize += nla_total_size(4);\n#ifdef CONFIG_IPV6_MROUTE\n\tif (all || type == NETCONFA_MC_FORWARDING)\n\t\tsize += nla_total_size(4);\n#endif\n\tif (all || type == NETCONFA_PROXY_NEIGH)\n\t\tsize += nla_total_size(4);\n\n\tif (all || type == NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN)\n\t\tsize += nla_total_size(4);\n\n\treturn size;\n}\n\nstatic int inet6_netconf_fill_devconf(struct sk_buff *skb, int ifindex,\n\t\t\t\t      struct ipv6_devconf *devconf, u32 portid,\n\t\t\t\t      u32 seq, int event, unsigned int flags,\n\t\t\t\t      int type)\n{\n\tstruct nlmsghdr  *nlh;\n\tstruct netconfmsg *ncm;\n\tbool all = false;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct netconfmsg),\n\t\t\tflags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tif (type == NETCONFA_ALL)\n\t\tall = true;\n\n\tncm = nlmsg_data(nlh);\n\tncm->ncm_family = AF_INET6;\n\n\tif (nla_put_s32(skb, NETCONFA_IFINDEX, ifindex) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (!devconf)\n\t\tgoto out;\n\n\tif ((all || type == NETCONFA_FORWARDING) &&\n\t    nla_put_s32(skb, NETCONFA_FORWARDING, devconf->forwarding) < 0)\n\t\tgoto nla_put_failure;\n#ifdef CONFIG_IPV6_MROUTE\n\tif ((all || type == NETCONFA_MC_FORWARDING) &&\n\t    nla_put_s32(skb, NETCONFA_MC_FORWARDING,\n\t\t\tatomic_read(&devconf->mc_forwarding)) < 0)\n\t\tgoto nla_put_failure;\n#endif\n\tif ((all || type == NETCONFA_PROXY_NEIGH) &&\n\t    nla_put_s32(skb, NETCONFA_PROXY_NEIGH, devconf->proxy_ndp) < 0)\n\t\tgoto nla_put_failure;\n\n\tif ((all || type == NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN) &&\n\t    nla_put_s32(skb, NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\tdevconf->ignore_routes_with_linkdown) < 0)\n\t\tgoto nla_put_failure;\n\nout:\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nvoid inet6_netconf_notify_devconf(struct net *net, int event, int type,\n\t\t\t\t  int ifindex, struct ipv6_devconf *devconf)\n{\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(inet6_netconf_msgsize_devconf(type), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet6_netconf_fill_devconf(skb, ifindex, devconf, 0, 0,\n\t\t\t\t\t event, 0, type);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV6_NETCONF, NULL, GFP_KERNEL);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_IPV6_NETCONF, err);\n}\n\nstatic const struct nla_policy devconf_ipv6_policy[NETCONFA_MAX+1] = {\n\t[NETCONFA_IFINDEX]\t= { .len = sizeof(int) },\n\t[NETCONFA_FORWARDING]\t= { .len = sizeof(int) },\n\t[NETCONFA_PROXY_NEIGH]\t= { .len = sizeof(int) },\n\t[NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN]\t= { .len = sizeof(int) },\n};\n\nstatic int inet6_netconf_valid_get_req(struct sk_buff *skb,\n\t\t\t\t       const struct nlmsghdr *nlh,\n\t\t\t\t       struct nlattr **tb,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tint i, err;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(struct netconfmsg))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid header for netconf get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(struct netconfmsg),\n\t\t\t\t\t      tb, NETCONFA_MAX,\n\t\t\t\t\t      devconf_ipv6_policy, extack);\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(struct netconfmsg),\n\t\t\t\t\t    tb, NETCONFA_MAX,\n\t\t\t\t\t    devconf_ipv6_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <= NETCONFA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase NETCONFA_IFINDEX:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported attribute in netconf get request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int inet6_netconf_get_devconf(struct sk_buff *in_skb,\n\t\t\t\t     struct nlmsghdr *nlh,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[NETCONFA_MAX+1];\n\tstruct inet6_dev *in6_dev = NULL;\n\tstruct net_device *dev = NULL;\n\tstruct sk_buff *skb;\n\tstruct ipv6_devconf *devconf;\n\tint ifindex;\n\tint err;\n\n\terr = inet6_netconf_valid_get_req(in_skb, nlh, tb, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NETCONFA_IFINDEX])\n\t\treturn -EINVAL;\n\n\terr = -EINVAL;\n\tifindex = nla_get_s32(tb[NETCONFA_IFINDEX]);\n\tswitch (ifindex) {\n\tcase NETCONFA_IFINDEX_ALL:\n\t\tdevconf = net->ipv6.devconf_all;\n\t\tbreak;\n\tcase NETCONFA_IFINDEX_DEFAULT:\n\t\tdevconf = net->ipv6.devconf_dflt;\n\t\tbreak;\n\tdefault:\n\t\tdev = dev_get_by_index(net, ifindex);\n\t\tif (!dev)\n\t\t\treturn -EINVAL;\n\t\tin6_dev = in6_dev_get(dev);\n\t\tif (!in6_dev)\n\t\t\tgoto errout;\n\t\tdevconf = &in6_dev->cnf;\n\t\tbreak;\n\t}\n\n\terr = -ENOBUFS;\n\tskb = nlmsg_new(inet6_netconf_msgsize_devconf(NETCONFA_ALL), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet6_netconf_fill_devconf(skb, ifindex, devconf,\n\t\t\t\t\t NETLINK_CB(in_skb).portid,\n\t\t\t\t\t nlh->nlmsg_seq, RTM_NEWNETCONF, 0,\n\t\t\t\t\t NETCONFA_ALL);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\tif (in6_dev)\n\t\tin6_dev_put(in6_dev);\n\tdev_put(dev);\n\treturn err;\n}\n\nstatic int inet6_netconf_dump_devconf(struct sk_buff *skb,\n\t\t\t\t      struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tint h, s_h;\n\tint idx, s_idx;\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\tstruct hlist_head *head;\n\n\tif (cb->strict_check) {\n\t\tstruct netlink_ext_ack *extack = cb->extack;\n\t\tstruct netconfmsg *ncm;\n\n\t\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ncm))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid header for netconf dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (nlmsg_attrlen(nlh, sizeof(*ncm))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid data after header in netconf dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ts_h = cb->args[0];\n\ts_idx = idx = cb->args[1];\n\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\trcu_read_lock();\n\t\tcb->seq = atomic_read(&net->ipv6.dev_addr_genid) ^\n\t\t\t  net->dev_base_seq;\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tidev = __in6_dev_get(dev);\n\t\t\tif (!idev)\n\t\t\t\tgoto cont;\n\n\t\t\tif (inet6_netconf_fill_devconf(skb, dev->ifindex,\n\t\t\t\t\t\t       &idev->cnf,\n\t\t\t\t\t\t       NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t       nlh->nlmsg_seq,\n\t\t\t\t\t\t       RTM_NEWNETCONF,\n\t\t\t\t\t\t       NLM_F_MULTI,\n\t\t\t\t\t\t       NETCONFA_ALL) < 0) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (h == NETDEV_HASHENTRIES) {\n\t\tif (inet6_netconf_fill_devconf(skb, NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t       net->ipv6.devconf_all,\n\t\t\t\t\t       NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       nlh->nlmsg_seq,\n\t\t\t\t\t       RTM_NEWNETCONF, NLM_F_MULTI,\n\t\t\t\t\t       NETCONFA_ALL) < 0)\n\t\t\tgoto done;\n\t\telse\n\t\t\th++;\n\t}\n\tif (h == NETDEV_HASHENTRIES + 1) {\n\t\tif (inet6_netconf_fill_devconf(skb, NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t\t       net->ipv6.devconf_dflt,\n\t\t\t\t\t       NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       nlh->nlmsg_seq,\n\t\t\t\t\t       RTM_NEWNETCONF, NLM_F_MULTI,\n\t\t\t\t\t       NETCONFA_ALL) < 0)\n\t\t\tgoto done;\n\t\telse\n\t\t\th++;\n\t}\ndone:\n\tcb->args[0] = h;\n\tcb->args[1] = idx;\n\n\treturn skb->len;\n}\n\n#ifdef CONFIG_SYSCTL\nstatic void dev_forward_change(struct inet6_dev *idev)\n{\n\tstruct net_device *dev;\n\tstruct inet6_ifaddr *ifa;\n\tLIST_HEAD(tmp_addr_list);\n\n\tif (!idev)\n\t\treturn;\n\tdev = idev->dev;\n\tif (idev->cnf.forwarding)\n\t\tdev_disable_lro(dev);\n\tif (dev->flags & IFF_MULTICAST) {\n\t\tif (idev->cnf.forwarding) {\n\t\t\tipv6_dev_mc_inc(dev, &in6addr_linklocal_allrouters);\n\t\t\tipv6_dev_mc_inc(dev, &in6addr_interfacelocal_allrouters);\n\t\t\tipv6_dev_mc_inc(dev, &in6addr_sitelocal_allrouters);\n\t\t} else {\n\t\t\tipv6_dev_mc_dec(dev, &in6addr_linklocal_allrouters);\n\t\t\tipv6_dev_mc_dec(dev, &in6addr_interfacelocal_allrouters);\n\t\t\tipv6_dev_mc_dec(dev, &in6addr_sitelocal_allrouters);\n\t\t}\n\t}\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifa, &idev->addr_list, if_list) {\n\t\tif (ifa->flags&IFA_F_TENTATIVE)\n\t\t\tcontinue;\n\t\tlist_add_tail(&ifa->if_list_aux, &tmp_addr_list);\n\t}\n\tread_unlock_bh(&idev->lock);\n\n\twhile (!list_empty(&tmp_addr_list)) {\n\t\tifa = list_first_entry(&tmp_addr_list,\n\t\t\t\t       struct inet6_ifaddr, if_list_aux);\n\t\tlist_del(&ifa->if_list_aux);\n\t\tif (idev->cnf.forwarding)\n\t\t\taddrconf_join_anycast(ifa);\n\t\telse\n\t\t\taddrconf_leave_anycast(ifa);\n\t}\n\n\tinet6_netconf_notify_devconf(dev_net(dev), RTM_NEWNETCONF,\n\t\t\t\t     NETCONFA_FORWARDING,\n\t\t\t\t     dev->ifindex, &idev->cnf);\n}\n\n\nstatic void addrconf_forward_change(struct net *net, __s32 newf)\n{\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\n\tfor_each_netdev(net, dev) {\n\t\tidev = __in6_dev_get(dev);\n\t\tif (idev) {\n\t\t\tint changed = (!idev->cnf.forwarding) ^ (!newf);\n\t\t\tidev->cnf.forwarding = newf;\n\t\t\tif (changed)\n\t\t\t\tdev_forward_change(idev);\n\t\t}\n\t}\n}\n\nstatic int addrconf_fixup_forwarding(struct ctl_table *table, int *p, int newf)\n{\n\tstruct net *net;\n\tint old;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tnet = (struct net *)table->extra2;\n\told = *p;\n\t*p = newf;\n\n\tif (p == &net->ipv6.devconf_dflt->forwarding) {\n\t\tif ((!newf) ^ (!old))\n\t\t\tinet6_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t     NETCONFA_FORWARDING,\n\t\t\t\t\t\t     NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t\t\t     net->ipv6.devconf_dflt);\n\t\trtnl_unlock();\n\t\treturn 0;\n\t}\n\n\tif (p == &net->ipv6.devconf_all->forwarding) {\n\t\tint old_dflt = net->ipv6.devconf_dflt->forwarding;\n\n\t\tnet->ipv6.devconf_dflt->forwarding = newf;\n\t\tif ((!newf) ^ (!old_dflt))\n\t\t\tinet6_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t     NETCONFA_FORWARDING,\n\t\t\t\t\t\t     NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t\t\t     net->ipv6.devconf_dflt);\n\n\t\taddrconf_forward_change(net, newf);\n\t\tif ((!newf) ^ (!old))\n\t\t\tinet6_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t     NETCONFA_FORWARDING,\n\t\t\t\t\t\t     NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t\t     net->ipv6.devconf_all);\n\t} else if ((!newf) ^ (!old))\n\t\tdev_forward_change((struct inet6_dev *)table->extra1);\n\trtnl_unlock();\n\n\tif (newf)\n\t\trt6_purge_dflt_routers(net);\n\treturn 1;\n}\n\nstatic void addrconf_linkdown_change(struct net *net, __s32 newf)\n{\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\n\tfor_each_netdev(net, dev) {\n\t\tidev = __in6_dev_get(dev);\n\t\tif (idev) {\n\t\t\tint changed = (!idev->cnf.ignore_routes_with_linkdown) ^ (!newf);\n\n\t\t\tidev->cnf.ignore_routes_with_linkdown = newf;\n\t\t\tif (changed)\n\t\t\t\tinet6_netconf_notify_devconf(dev_net(dev),\n\t\t\t\t\t\t\t     RTM_NEWNETCONF,\n\t\t\t\t\t\t\t     NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\t\t\t\t\t     dev->ifindex,\n\t\t\t\t\t\t\t     &idev->cnf);\n\t\t}\n\t}\n}\n\nstatic int addrconf_fixup_linkdown(struct ctl_table *table, int *p, int newf)\n{\n\tstruct net *net;\n\tint old;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tnet = (struct net *)table->extra2;\n\told = *p;\n\t*p = newf;\n\n\tif (p == &net->ipv6.devconf_dflt->ignore_routes_with_linkdown) {\n\t\tif ((!newf) ^ (!old))\n\t\t\tinet6_netconf_notify_devconf(net,\n\t\t\t\t\t\t     RTM_NEWNETCONF,\n\t\t\t\t\t\t     NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\t\t\t\t     NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t\t\t     net->ipv6.devconf_dflt);\n\t\trtnl_unlock();\n\t\treturn 0;\n\t}\n\n\tif (p == &net->ipv6.devconf_all->ignore_routes_with_linkdown) {\n\t\tnet->ipv6.devconf_dflt->ignore_routes_with_linkdown = newf;\n\t\taddrconf_linkdown_change(net, newf);\n\t\tif ((!newf) ^ (!old))\n\t\t\tinet6_netconf_notify_devconf(net,\n\t\t\t\t\t\t     RTM_NEWNETCONF,\n\t\t\t\t\t\t     NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\t\t\t\t     NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t\t     net->ipv6.devconf_all);\n\t}\n\trtnl_unlock();\n\n\treturn 1;\n}\n\n#endif\n\n \nvoid inet6_ifa_finish_destroy(struct inet6_ifaddr *ifp)\n{\n\tWARN_ON(!hlist_unhashed(&ifp->addr_lst));\n\n#ifdef NET_REFCNT_DEBUG\n\tpr_debug(\"%s\\n\", __func__);\n#endif\n\n\tin6_dev_put(ifp->idev);\n\n\tif (cancel_delayed_work(&ifp->dad_work))\n\t\tpr_notice(\"delayed DAD work was pending while freeing ifa=%p\\n\",\n\t\t\t  ifp);\n\n\tif (ifp->state != INET6_IFADDR_STATE_DEAD) {\n\t\tpr_warn(\"Freeing alive inet6 address %p\\n\", ifp);\n\t\treturn;\n\t}\n\n\tkfree_rcu(ifp, rcu);\n}\n\nstatic void\nipv6_link_dev_addr(struct inet6_dev *idev, struct inet6_ifaddr *ifp)\n{\n\tstruct list_head *p;\n\tint ifp_scope = ipv6_addr_src_scope(&ifp->addr);\n\n\t \n\tlist_for_each(p, &idev->addr_list) {\n\t\tstruct inet6_ifaddr *ifa\n\t\t\t= list_entry(p, struct inet6_ifaddr, if_list);\n\t\tif (ifp_scope >= ipv6_addr_src_scope(&ifa->addr))\n\t\t\tbreak;\n\t}\n\n\tlist_add_tail_rcu(&ifp->if_list, p);\n}\n\nstatic u32 inet6_addr_hash(const struct net *net, const struct in6_addr *addr)\n{\n\tu32 val = ipv6_addr_hash(addr) ^ net_hash_mix(net);\n\n\treturn hash_32(val, IN6_ADDR_HSIZE_SHIFT);\n}\n\nstatic bool ipv6_chk_same_addr(struct net *net, const struct in6_addr *addr,\n\t\t\t       struct net_device *dev, unsigned int hash)\n{\n\tstruct inet6_ifaddr *ifp;\n\n\thlist_for_each_entry(ifp, &net->ipv6.inet6_addr_lst[hash], addr_lst) {\n\t\tif (ipv6_addr_equal(&ifp->addr, addr)) {\n\t\t\tif (!dev || ifp->idev->dev == dev)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int ipv6_add_addr_hash(struct net_device *dev, struct inet6_ifaddr *ifa)\n{\n\tstruct net *net = dev_net(dev);\n\tunsigned int hash = inet6_addr_hash(net, &ifa->addr);\n\tint err = 0;\n\n\tspin_lock_bh(&net->ipv6.addrconf_hash_lock);\n\n\t \n\tif (ipv6_chk_same_addr(net, &ifa->addr, dev, hash)) {\n\t\tnetdev_dbg(dev, \"ipv6_add_addr: already assigned\\n\");\n\t\terr = -EEXIST;\n\t} else {\n\t\thlist_add_head_rcu(&ifa->addr_lst, &net->ipv6.inet6_addr_lst[hash]);\n\t}\n\n\tspin_unlock_bh(&net->ipv6.addrconf_hash_lock);\n\n\treturn err;\n}\n\n \n\nstatic struct inet6_ifaddr *\nipv6_add_addr(struct inet6_dev *idev, struct ifa6_config *cfg,\n\t      bool can_block, struct netlink_ext_ack *extack)\n{\n\tgfp_t gfp_flags = can_block ? GFP_KERNEL : GFP_ATOMIC;\n\tint addr_type = ipv6_addr_type(cfg->pfx);\n\tstruct net *net = dev_net(idev->dev);\n\tstruct inet6_ifaddr *ifa = NULL;\n\tstruct fib6_info *f6i = NULL;\n\tint err = 0;\n\n\tif (addr_type == IPV6_ADDR_ANY) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid address\");\n\t\treturn ERR_PTR(-EADDRNOTAVAIL);\n\t} else if (addr_type & IPV6_ADDR_MULTICAST &&\n\t\t   !(cfg->ifa_flags & IFA_F_MCAUTOJOIN)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot assign multicast address without \\\"IFA_F_MCAUTOJOIN\\\" flag\");\n\t\treturn ERR_PTR(-EADDRNOTAVAIL);\n\t} else if (!(idev->dev->flags & IFF_LOOPBACK) &&\n\t\t   !netif_is_l3_master(idev->dev) &&\n\t\t   addr_type & IPV6_ADDR_LOOPBACK) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot assign loopback address on this device\");\n\t\treturn ERR_PTR(-EADDRNOTAVAIL);\n\t}\n\n\tif (idev->dead) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"device is going away\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (idev->cnf.disable_ipv6) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"IPv6 is disabled on this device\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\t \n\tif (can_block) {\n\t\tstruct in6_validator_info i6vi = {\n\t\t\t.i6vi_addr = *cfg->pfx,\n\t\t\t.i6vi_dev = idev,\n\t\t\t.extack = extack,\n\t\t};\n\n\t\terr = inet6addr_validator_notifier_call_chain(NETDEV_UP, &i6vi);\n\t\terr = notifier_to_errno(err);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tifa = kzalloc(sizeof(*ifa), gfp_flags | __GFP_ACCOUNT);\n\tif (!ifa) {\n\t\terr = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tf6i = addrconf_f6i_alloc(net, idev, cfg->pfx, false, gfp_flags, extack);\n\tif (IS_ERR(f6i)) {\n\t\terr = PTR_ERR(f6i);\n\t\tf6i = NULL;\n\t\tgoto out;\n\t}\n\n\tneigh_parms_data_state_setall(idev->nd_parms);\n\n\tifa->addr = *cfg->pfx;\n\tif (cfg->peer_pfx)\n\t\tifa->peer_addr = *cfg->peer_pfx;\n\n\tspin_lock_init(&ifa->lock);\n\tINIT_DELAYED_WORK(&ifa->dad_work, addrconf_dad_work);\n\tINIT_HLIST_NODE(&ifa->addr_lst);\n\tifa->scope = cfg->scope;\n\tifa->prefix_len = cfg->plen;\n\tifa->rt_priority = cfg->rt_priority;\n\tifa->flags = cfg->ifa_flags;\n\tifa->ifa_proto = cfg->ifa_proto;\n\t \n\tif (!(cfg->ifa_flags & IFA_F_NODAD))\n\t\tifa->flags |= IFA_F_TENTATIVE;\n\tifa->valid_lft = cfg->valid_lft;\n\tifa->prefered_lft = cfg->preferred_lft;\n\tifa->cstamp = ifa->tstamp = jiffies;\n\tifa->tokenized = false;\n\n\tifa->rt = f6i;\n\n\tifa->idev = idev;\n\tin6_dev_hold(idev);\n\n\t \n\trefcount_set(&ifa->refcnt, 1);\n\n\trcu_read_lock();\n\n\terr = ipv6_add_addr_hash(idev->dev, ifa);\n\tif (err < 0) {\n\t\trcu_read_unlock();\n\t\tgoto out;\n\t}\n\n\twrite_lock_bh(&idev->lock);\n\n\t \n\tipv6_link_dev_addr(idev, ifa);\n\n\tif (ifa->flags&IFA_F_TEMPORARY) {\n\t\tlist_add(&ifa->tmp_list, &idev->tempaddr_list);\n\t\tin6_ifa_hold(ifa);\n\t}\n\n\tin6_ifa_hold(ifa);\n\twrite_unlock_bh(&idev->lock);\n\n\trcu_read_unlock();\n\n\tinet6addr_notifier_call_chain(NETDEV_UP, ifa);\nout:\n\tif (unlikely(err < 0)) {\n\t\tfib6_info_release(f6i);\n\n\t\tif (ifa) {\n\t\t\tif (ifa->idev)\n\t\t\t\tin6_dev_put(ifa->idev);\n\t\t\tkfree(ifa);\n\t\t}\n\t\tifa = ERR_PTR(err);\n\t}\n\n\treturn ifa;\n}\n\nenum cleanup_prefix_rt_t {\n\tCLEANUP_PREFIX_RT_NOP,     \n\tCLEANUP_PREFIX_RT_DEL,     \n\tCLEANUP_PREFIX_RT_EXPIRE,  \n};\n\n \nstatic enum cleanup_prefix_rt_t\ncheck_cleanup_prefix_route(struct inet6_ifaddr *ifp, unsigned long *expires)\n{\n\tstruct inet6_ifaddr *ifa;\n\tstruct inet6_dev *idev = ifp->idev;\n\tunsigned long lifetime;\n\tenum cleanup_prefix_rt_t action = CLEANUP_PREFIX_RT_DEL;\n\n\t*expires = jiffies;\n\n\tlist_for_each_entry(ifa, &idev->addr_list, if_list) {\n\t\tif (ifa == ifp)\n\t\t\tcontinue;\n\t\tif (ifa->prefix_len != ifp->prefix_len ||\n\t\t    !ipv6_prefix_equal(&ifa->addr, &ifp->addr,\n\t\t\t\t       ifp->prefix_len))\n\t\t\tcontinue;\n\t\tif (ifa->flags & (IFA_F_PERMANENT | IFA_F_NOPREFIXROUTE))\n\t\t\treturn CLEANUP_PREFIX_RT_NOP;\n\n\t\taction = CLEANUP_PREFIX_RT_EXPIRE;\n\n\t\tspin_lock(&ifa->lock);\n\n\t\tlifetime = addrconf_timeout_fixup(ifa->valid_lft, HZ);\n\t\t \n\t\tif (time_before(*expires, ifa->tstamp + lifetime * HZ))\n\t\t\t*expires = ifa->tstamp + lifetime * HZ;\n\t\tspin_unlock(&ifa->lock);\n\t}\n\n\treturn action;\n}\n\nstatic void\ncleanup_prefix_route(struct inet6_ifaddr *ifp, unsigned long expires,\n\t\t     bool del_rt, bool del_peer)\n{\n\tstruct fib6_info *f6i;\n\n\tf6i = addrconf_get_prefix_route(del_peer ? &ifp->peer_addr : &ifp->addr,\n\t\t\t\t\tifp->prefix_len,\n\t\t\t\t\tifp->idev->dev, 0, RTF_DEFAULT, true);\n\tif (f6i) {\n\t\tif (del_rt)\n\t\t\tip6_del_rt(dev_net(ifp->idev->dev), f6i, false);\n\t\telse {\n\t\t\tif (!(f6i->fib6_flags & RTF_EXPIRES))\n\t\t\t\tfib6_set_expires(f6i, expires);\n\t\t\tfib6_info_release(f6i);\n\t\t}\n\t}\n}\n\n\n \n\nstatic void ipv6_del_addr(struct inet6_ifaddr *ifp)\n{\n\tenum cleanup_prefix_rt_t action = CLEANUP_PREFIX_RT_NOP;\n\tstruct net *net = dev_net(ifp->idev->dev);\n\tunsigned long expires;\n\tint state;\n\n\tASSERT_RTNL();\n\n\tspin_lock_bh(&ifp->lock);\n\tstate = ifp->state;\n\tifp->state = INET6_IFADDR_STATE_DEAD;\n\tspin_unlock_bh(&ifp->lock);\n\n\tif (state == INET6_IFADDR_STATE_DEAD)\n\t\tgoto out;\n\n\tspin_lock_bh(&net->ipv6.addrconf_hash_lock);\n\thlist_del_init_rcu(&ifp->addr_lst);\n\tspin_unlock_bh(&net->ipv6.addrconf_hash_lock);\n\n\twrite_lock_bh(&ifp->idev->lock);\n\n\tif (ifp->flags&IFA_F_TEMPORARY) {\n\t\tlist_del(&ifp->tmp_list);\n\t\tif (ifp->ifpub) {\n\t\t\tin6_ifa_put(ifp->ifpub);\n\t\t\tifp->ifpub = NULL;\n\t\t}\n\t\t__in6_ifa_put(ifp);\n\t}\n\n\tif (ifp->flags & IFA_F_PERMANENT && !(ifp->flags & IFA_F_NOPREFIXROUTE))\n\t\taction = check_cleanup_prefix_route(ifp, &expires);\n\n\tlist_del_rcu(&ifp->if_list);\n\t__in6_ifa_put(ifp);\n\n\twrite_unlock_bh(&ifp->idev->lock);\n\n\taddrconf_del_dad_work(ifp);\n\n\tipv6_ifa_notify(RTM_DELADDR, ifp);\n\n\tinet6addr_notifier_call_chain(NETDEV_DOWN, ifp);\n\n\tif (action != CLEANUP_PREFIX_RT_NOP) {\n\t\tcleanup_prefix_route(ifp, expires,\n\t\t\taction == CLEANUP_PREFIX_RT_DEL, false);\n\t}\n\n\t \n\trt6_remove_prefsrc(ifp);\nout:\n\tin6_ifa_put(ifp);\n}\n\nstatic int ipv6_create_tempaddr(struct inet6_ifaddr *ifp, bool block)\n{\n\tstruct inet6_dev *idev = ifp->idev;\n\tunsigned long tmp_tstamp, age;\n\tunsigned long regen_advance;\n\tunsigned long now = jiffies;\n\ts32 cnf_temp_preferred_lft;\n\tstruct inet6_ifaddr *ift;\n\tstruct ifa6_config cfg;\n\tlong max_desync_factor;\n\tstruct in6_addr addr;\n\tint ret = 0;\n\n\twrite_lock_bh(&idev->lock);\n\nretry:\n\tin6_dev_hold(idev);\n\tif (idev->cnf.use_tempaddr <= 0) {\n\t\twrite_unlock_bh(&idev->lock);\n\t\tpr_info(\"%s: use_tempaddr is disabled\\n\", __func__);\n\t\tin6_dev_put(idev);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tspin_lock_bh(&ifp->lock);\n\tif (ifp->regen_count++ >= idev->cnf.regen_max_retry) {\n\t\tidev->cnf.use_tempaddr = -1;\t \n\t\tspin_unlock_bh(&ifp->lock);\n\t\twrite_unlock_bh(&idev->lock);\n\t\tpr_warn(\"%s: regeneration time exceeded - disabled temporary address support\\n\",\n\t\t\t__func__);\n\t\tin6_dev_put(idev);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\tin6_ifa_hold(ifp);\n\tmemcpy(addr.s6_addr, ifp->addr.s6_addr, 8);\n\tipv6_gen_rnd_iid(&addr);\n\n\tage = (now - ifp->tstamp) / HZ;\n\n\tregen_advance = idev->cnf.regen_max_retry *\n\t\t\tidev->cnf.dad_transmits *\n\t\t\tmax(NEIGH_VAR(idev->nd_parms, RETRANS_TIME), HZ/100) / HZ;\n\n\t \n\tcnf_temp_preferred_lft = READ_ONCE(idev->cnf.temp_prefered_lft);\n\tmax_desync_factor = min_t(long,\n\t\t\t\t  idev->cnf.max_desync_factor,\n\t\t\t\t  cnf_temp_preferred_lft - regen_advance);\n\n\tif (unlikely(idev->desync_factor > max_desync_factor)) {\n\t\tif (max_desync_factor > 0) {\n\t\t\tget_random_bytes(&idev->desync_factor,\n\t\t\t\t\t sizeof(idev->desync_factor));\n\t\t\tidev->desync_factor %= max_desync_factor;\n\t\t} else {\n\t\t\tidev->desync_factor = 0;\n\t\t}\n\t}\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.valid_lft = min_t(__u32, ifp->valid_lft,\n\t\t\t      idev->cnf.temp_valid_lft + age);\n\tcfg.preferred_lft = cnf_temp_preferred_lft + age - idev->desync_factor;\n\tcfg.preferred_lft = min_t(__u32, ifp->prefered_lft, cfg.preferred_lft);\n\n\tcfg.plen = ifp->prefix_len;\n\ttmp_tstamp = ifp->tstamp;\n\tspin_unlock_bh(&ifp->lock);\n\n\twrite_unlock_bh(&idev->lock);\n\n\t \n\tage = (now - tmp_tstamp + ADDRCONF_TIMER_FUZZ_MINUS) / HZ;\n\tif (cfg.preferred_lft <= regen_advance + age) {\n\t\tin6_ifa_put(ifp);\n\t\tin6_dev_put(idev);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tcfg.ifa_flags = IFA_F_TEMPORARY;\n\t \n\tif (ifp->flags & IFA_F_OPTIMISTIC)\n\t\tcfg.ifa_flags |= IFA_F_OPTIMISTIC;\n\n\tcfg.pfx = &addr;\n\tcfg.scope = ipv6_addr_scope(cfg.pfx);\n\n\tift = ipv6_add_addr(idev, &cfg, block, NULL);\n\tif (IS_ERR(ift)) {\n\t\tin6_ifa_put(ifp);\n\t\tin6_dev_put(idev);\n\t\tpr_info(\"%s: retry temporary address regeneration\\n\", __func__);\n\t\twrite_lock_bh(&idev->lock);\n\t\tgoto retry;\n\t}\n\n\tspin_lock_bh(&ift->lock);\n\tift->ifpub = ifp;\n\tift->cstamp = now;\n\tift->tstamp = tmp_tstamp;\n\tspin_unlock_bh(&ift->lock);\n\n\taddrconf_dad_start(ift);\n\tin6_ifa_put(ift);\n\tin6_dev_put(idev);\nout:\n\treturn ret;\n}\n\n \nenum {\n\tIPV6_SADDR_RULE_INIT = 0,\n\tIPV6_SADDR_RULE_LOCAL,\n\tIPV6_SADDR_RULE_SCOPE,\n\tIPV6_SADDR_RULE_PREFERRED,\n#ifdef CONFIG_IPV6_MIP6\n\tIPV6_SADDR_RULE_HOA,\n#endif\n\tIPV6_SADDR_RULE_OIF,\n\tIPV6_SADDR_RULE_LABEL,\n\tIPV6_SADDR_RULE_PRIVACY,\n\tIPV6_SADDR_RULE_ORCHID,\n\tIPV6_SADDR_RULE_PREFIX,\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\tIPV6_SADDR_RULE_NOT_OPTIMISTIC,\n#endif\n\tIPV6_SADDR_RULE_MAX\n};\n\nstruct ipv6_saddr_score {\n\tint\t\t\trule;\n\tint\t\t\taddr_type;\n\tstruct inet6_ifaddr\t*ifa;\n\tDECLARE_BITMAP(scorebits, IPV6_SADDR_RULE_MAX);\n\tint\t\t\tscopedist;\n\tint\t\t\tmatchlen;\n};\n\nstruct ipv6_saddr_dst {\n\tconst struct in6_addr *addr;\n\tint ifindex;\n\tint scope;\n\tint label;\n\tunsigned int prefs;\n};\n\nstatic inline int ipv6_saddr_preferred(int type)\n{\n\tif (type & (IPV6_ADDR_MAPPED|IPV6_ADDR_COMPATv4|IPV6_ADDR_LOOPBACK))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic bool ipv6_use_optimistic_addr(struct net *net,\n\t\t\t\t     struct inet6_dev *idev)\n{\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\tif (!idev)\n\t\treturn false;\n\tif (!net->ipv6.devconf_all->optimistic_dad && !idev->cnf.optimistic_dad)\n\t\treturn false;\n\tif (!net->ipv6.devconf_all->use_optimistic && !idev->cnf.use_optimistic)\n\t\treturn false;\n\n\treturn true;\n#else\n\treturn false;\n#endif\n}\n\nstatic bool ipv6_allow_optimistic_dad(struct net *net,\n\t\t\t\t      struct inet6_dev *idev)\n{\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\tif (!idev)\n\t\treturn false;\n\tif (!net->ipv6.devconf_all->optimistic_dad && !idev->cnf.optimistic_dad)\n\t\treturn false;\n\n\treturn true;\n#else\n\treturn false;\n#endif\n}\n\nstatic int ipv6_get_saddr_eval(struct net *net,\n\t\t\t       struct ipv6_saddr_score *score,\n\t\t\t       struct ipv6_saddr_dst *dst,\n\t\t\t       int i)\n{\n\tint ret;\n\n\tif (i <= score->rule) {\n\t\tswitch (i) {\n\t\tcase IPV6_SADDR_RULE_SCOPE:\n\t\t\tret = score->scopedist;\n\t\t\tbreak;\n\t\tcase IPV6_SADDR_RULE_PREFIX:\n\t\t\tret = score->matchlen;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = !!test_bit(i, score->scorebits);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tswitch (i) {\n\tcase IPV6_SADDR_RULE_INIT:\n\t\t \n\t\tret = !!score->ifa;\n\t\tbreak;\n\tcase IPV6_SADDR_RULE_LOCAL:\n\t\t \n\t\tret = ipv6_addr_equal(&score->ifa->addr, dst->addr);\n\t\tbreak;\n\tcase IPV6_SADDR_RULE_SCOPE:\n\t\t \n\t\tret = __ipv6_addr_src_scope(score->addr_type);\n\t\tif (ret >= dst->scope)\n\t\t\tret = -ret;\n\t\telse\n\t\t\tret -= 128;\t \n\t\tscore->scopedist = ret;\n\t\tbreak;\n\tcase IPV6_SADDR_RULE_PREFERRED:\n\t    {\n\t\t \n\t\tu8 avoid = IFA_F_DEPRECATED;\n\n\t\tif (!ipv6_use_optimistic_addr(net, score->ifa->idev))\n\t\t\tavoid |= IFA_F_OPTIMISTIC;\n\t\tret = ipv6_saddr_preferred(score->addr_type) ||\n\t\t      !(score->ifa->flags & avoid);\n\t\tbreak;\n\t    }\n#ifdef CONFIG_IPV6_MIP6\n\tcase IPV6_SADDR_RULE_HOA:\n\t    {\n\t\t \n\t\tint prefhome = !(dst->prefs & IPV6_PREFER_SRC_COA);\n\t\tret = !(score->ifa->flags & IFA_F_HOMEADDRESS) ^ prefhome;\n\t\tbreak;\n\t    }\n#endif\n\tcase IPV6_SADDR_RULE_OIF:\n\t\t \n\t\tret = (!dst->ifindex ||\n\t\t       dst->ifindex == score->ifa->idev->dev->ifindex);\n\t\tbreak;\n\tcase IPV6_SADDR_RULE_LABEL:\n\t\t \n\t\tret = ipv6_addr_label(net,\n\t\t\t\t      &score->ifa->addr, score->addr_type,\n\t\t\t\t      score->ifa->idev->dev->ifindex) == dst->label;\n\t\tbreak;\n\tcase IPV6_SADDR_RULE_PRIVACY:\n\t    {\n\t\t \n\t\tint preftmp = dst->prefs & (IPV6_PREFER_SRC_PUBLIC|IPV6_PREFER_SRC_TMP) ?\n\t\t\t\t!!(dst->prefs & IPV6_PREFER_SRC_TMP) :\n\t\t\t\tscore->ifa->idev->cnf.use_tempaddr >= 2;\n\t\tret = (!(score->ifa->flags & IFA_F_TEMPORARY)) ^ preftmp;\n\t\tbreak;\n\t    }\n\tcase IPV6_SADDR_RULE_ORCHID:\n\t\t \n\t\tret = !(ipv6_addr_orchid(&score->ifa->addr) ^\n\t\t\tipv6_addr_orchid(dst->addr));\n\t\tbreak;\n\tcase IPV6_SADDR_RULE_PREFIX:\n\t\t \n\t\tret = ipv6_addr_diff(&score->ifa->addr, dst->addr);\n\t\tif (ret > score->ifa->prefix_len)\n\t\t\tret = score->ifa->prefix_len;\n\t\tscore->matchlen = ret;\n\t\tbreak;\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\tcase IPV6_SADDR_RULE_NOT_OPTIMISTIC:\n\t\t \n\t\tret = !(score->ifa->flags & IFA_F_OPTIMISTIC);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = 0;\n\t}\n\n\tif (ret)\n\t\t__set_bit(i, score->scorebits);\n\tscore->rule = i;\nout:\n\treturn ret;\n}\n\nstatic int __ipv6_dev_get_saddr(struct net *net,\n\t\t\t\tstruct ipv6_saddr_dst *dst,\n\t\t\t\tstruct inet6_dev *idev,\n\t\t\t\tstruct ipv6_saddr_score *scores,\n\t\t\t\tint hiscore_idx)\n{\n\tstruct ipv6_saddr_score *score = &scores[1 - hiscore_idx], *hiscore = &scores[hiscore_idx];\n\n\tlist_for_each_entry_rcu(score->ifa, &idev->addr_list, if_list) {\n\t\tint i;\n\n\t\t \n\t\tif ((score->ifa->flags & IFA_F_TENTATIVE) &&\n\t\t    (!(score->ifa->flags & IFA_F_OPTIMISTIC)))\n\t\t\tcontinue;\n\n\t\tscore->addr_type = __ipv6_addr_type(&score->ifa->addr);\n\n\t\tif (unlikely(score->addr_type == IPV6_ADDR_ANY ||\n\t\t\t     score->addr_type & IPV6_ADDR_MULTICAST)) {\n\t\t\tnet_dbg_ratelimited(\"ADDRCONF: unspecified / multicast address assigned as unicast address on %s\",\n\t\t\t\t\t    idev->dev->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tscore->rule = -1;\n\t\tbitmap_zero(score->scorebits, IPV6_SADDR_RULE_MAX);\n\n\t\tfor (i = 0; i < IPV6_SADDR_RULE_MAX; i++) {\n\t\t\tint minihiscore, miniscore;\n\n\t\t\tminihiscore = ipv6_get_saddr_eval(net, hiscore, dst, i);\n\t\t\tminiscore = ipv6_get_saddr_eval(net, score, dst, i);\n\n\t\t\tif (minihiscore > miniscore) {\n\t\t\t\tif (i == IPV6_SADDR_RULE_SCOPE &&\n\t\t\t\t    score->scopedist > 0) {\n\t\t\t\t\t \n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if (minihiscore < miniscore) {\n\t\t\t\tswap(hiscore, score);\n\t\t\t\thiscore_idx = 1 - hiscore_idx;\n\n\t\t\t\t \n\t\t\t\tscore->ifa = hiscore->ifa;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn hiscore_idx;\n}\n\nstatic int ipv6_get_saddr_master(struct net *net,\n\t\t\t\t const struct net_device *dst_dev,\n\t\t\t\t const struct net_device *master,\n\t\t\t\t struct ipv6_saddr_dst *dst,\n\t\t\t\t struct ipv6_saddr_score *scores,\n\t\t\t\t int hiscore_idx)\n{\n\tstruct inet6_dev *idev;\n\n\tidev = __in6_dev_get(dst_dev);\n\tif (idev)\n\t\thiscore_idx = __ipv6_dev_get_saddr(net, dst, idev,\n\t\t\t\t\t\t   scores, hiscore_idx);\n\n\tidev = __in6_dev_get(master);\n\tif (idev)\n\t\thiscore_idx = __ipv6_dev_get_saddr(net, dst, idev,\n\t\t\t\t\t\t   scores, hiscore_idx);\n\n\treturn hiscore_idx;\n}\n\nint ipv6_dev_get_saddr(struct net *net, const struct net_device *dst_dev,\n\t\t       const struct in6_addr *daddr, unsigned int prefs,\n\t\t       struct in6_addr *saddr)\n{\n\tstruct ipv6_saddr_score scores[2], *hiscore;\n\tstruct ipv6_saddr_dst dst;\n\tstruct inet6_dev *idev;\n\tstruct net_device *dev;\n\tint dst_type;\n\tbool use_oif_addr = false;\n\tint hiscore_idx = 0;\n\tint ret = 0;\n\n\tdst_type = __ipv6_addr_type(daddr);\n\tdst.addr = daddr;\n\tdst.ifindex = dst_dev ? dst_dev->ifindex : 0;\n\tdst.scope = __ipv6_addr_src_scope(dst_type);\n\tdst.label = ipv6_addr_label(net, daddr, dst_type, dst.ifindex);\n\tdst.prefs = prefs;\n\n\tscores[hiscore_idx].rule = -1;\n\tscores[hiscore_idx].ifa = NULL;\n\n\trcu_read_lock();\n\n\t \n\tif (dst_dev) {\n\t\tidev = __in6_dev_get(dst_dev);\n\t\tif ((dst_type & IPV6_ADDR_MULTICAST) ||\n\t\t    dst.scope <= IPV6_ADDR_SCOPE_LINKLOCAL ||\n\t\t    (idev && idev->cnf.use_oif_addrs_only)) {\n\t\t\tuse_oif_addr = true;\n\t\t}\n\t}\n\n\tif (use_oif_addr) {\n\t\tif (idev)\n\t\t\thiscore_idx = __ipv6_dev_get_saddr(net, &dst, idev, scores, hiscore_idx);\n\t} else {\n\t\tconst struct net_device *master;\n\t\tint master_idx = 0;\n\n\t\t \n\t\tmaster = l3mdev_master_dev_rcu(dst_dev);\n\t\tif (master) {\n\t\t\tmaster_idx = master->ifindex;\n\n\t\t\thiscore_idx = ipv6_get_saddr_master(net, dst_dev,\n\t\t\t\t\t\t\t    master, &dst,\n\t\t\t\t\t\t\t    scores, hiscore_idx);\n\n\t\t\tif (scores[hiscore_idx].ifa)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tfor_each_netdev_rcu(net, dev) {\n\t\t\t \n\t\t\tif (l3mdev_master_ifindex_rcu(dev) != master_idx)\n\t\t\t\tcontinue;\n\t\t\tidev = __in6_dev_get(dev);\n\t\t\tif (!idev)\n\t\t\t\tcontinue;\n\t\t\thiscore_idx = __ipv6_dev_get_saddr(net, &dst, idev, scores, hiscore_idx);\n\t\t}\n\t}\n\nout:\n\thiscore = &scores[hiscore_idx];\n\tif (!hiscore->ifa)\n\t\tret = -EADDRNOTAVAIL;\n\telse\n\t\t*saddr = hiscore->ifa->addr;\n\n\trcu_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL(ipv6_dev_get_saddr);\n\nstatic int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,\n\t\t\t      u32 banned_flags)\n{\n\tstruct inet6_ifaddr *ifp;\n\tint err = -EADDRNOTAVAIL;\n\n\tlist_for_each_entry_reverse(ifp, &idev->addr_list, if_list) {\n\t\tif (ifp->scope > IFA_LINK)\n\t\t\tbreak;\n\t\tif (ifp->scope == IFA_LINK &&\n\t\t    !(ifp->flags & banned_flags)) {\n\t\t\t*addr = ifp->addr;\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\nint ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,\n\t\t    u32 banned_flags)\n{\n\tstruct inet6_dev *idev;\n\tint err = -EADDRNOTAVAIL;\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(dev);\n\tif (idev) {\n\t\tread_lock_bh(&idev->lock);\n\t\terr = __ipv6_get_lladdr(idev, addr, banned_flags);\n\t\tread_unlock_bh(&idev->lock);\n\t}\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic int ipv6_count_addresses(const struct inet6_dev *idev)\n{\n\tconst struct inet6_ifaddr *ifp;\n\tint cnt = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ifp, &idev->addr_list, if_list)\n\t\tcnt++;\n\trcu_read_unlock();\n\treturn cnt;\n}\n\nint ipv6_chk_addr(struct net *net, const struct in6_addr *addr,\n\t\t  const struct net_device *dev, int strict)\n{\n\treturn ipv6_chk_addr_and_flags(net, addr, dev, !dev,\n\t\t\t\t       strict, IFA_F_TENTATIVE);\n}\nEXPORT_SYMBOL(ipv6_chk_addr);\n\n \nstatic struct net_device *\n__ipv6_chk_addr_and_flags(struct net *net, const struct in6_addr *addr,\n\t\t\t  const struct net_device *dev, bool skip_dev_check,\n\t\t\t  int strict, u32 banned_flags)\n{\n\tunsigned int hash = inet6_addr_hash(net, addr);\n\tstruct net_device *l3mdev, *ndev;\n\tstruct inet6_ifaddr *ifp;\n\tu32 ifp_flags;\n\n\trcu_read_lock();\n\n\tl3mdev = l3mdev_master_dev_rcu(dev);\n\tif (skip_dev_check)\n\t\tdev = NULL;\n\n\thlist_for_each_entry_rcu(ifp, &net->ipv6.inet6_addr_lst[hash], addr_lst) {\n\t\tndev = ifp->idev->dev;\n\n\t\tif (l3mdev_master_dev_rcu(ndev) != l3mdev)\n\t\t\tcontinue;\n\n\t\t \n\t\tifp_flags = (ifp->flags&IFA_F_OPTIMISTIC)\n\t\t\t    ? (ifp->flags&~IFA_F_TENTATIVE)\n\t\t\t    : ifp->flags;\n\t\tif (ipv6_addr_equal(&ifp->addr, addr) &&\n\t\t    !(ifp_flags&banned_flags) &&\n\t\t    (!dev || ndev == dev ||\n\t\t     !(ifp->scope&(IFA_LINK|IFA_HOST) || strict))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn ndev;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn NULL;\n}\n\nint ipv6_chk_addr_and_flags(struct net *net, const struct in6_addr *addr,\n\t\t\t    const struct net_device *dev, bool skip_dev_check,\n\t\t\t    int strict, u32 banned_flags)\n{\n\treturn __ipv6_chk_addr_and_flags(net, addr, dev, skip_dev_check,\n\t\t\t\t\t strict, banned_flags) ? 1 : 0;\n}\nEXPORT_SYMBOL(ipv6_chk_addr_and_flags);\n\n\n \nbool ipv6_chk_custom_prefix(const struct in6_addr *addr,\n\tconst unsigned int prefix_len, struct net_device *dev)\n{\n\tconst struct inet6_ifaddr *ifa;\n\tconst struct inet6_dev *idev;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(dev);\n\tif (idev) {\n\t\tlist_for_each_entry_rcu(ifa, &idev->addr_list, if_list) {\n\t\t\tret = ipv6_prefix_equal(addr, &ifa->addr, prefix_len);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ipv6_chk_custom_prefix);\n\nint ipv6_chk_prefix(const struct in6_addr *addr, struct net_device *dev)\n{\n\tconst struct inet6_ifaddr *ifa;\n\tconst struct inet6_dev *idev;\n\tint\tonlink;\n\n\tonlink = 0;\n\trcu_read_lock();\n\tidev = __in6_dev_get(dev);\n\tif (idev) {\n\t\tlist_for_each_entry_rcu(ifa, &idev->addr_list, if_list) {\n\t\t\tonlink = ipv6_prefix_equal(addr, &ifa->addr,\n\t\t\t\t\t\t   ifa->prefix_len);\n\t\t\tif (onlink)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn onlink;\n}\nEXPORT_SYMBOL(ipv6_chk_prefix);\n\n \nstruct net_device *ipv6_dev_find(struct net *net, const struct in6_addr *addr,\n\t\t\t\t struct net_device *dev)\n{\n\treturn __ipv6_chk_addr_and_flags(net, addr, dev, !dev, 1,\n\t\t\t\t\t IFA_F_TENTATIVE);\n}\nEXPORT_SYMBOL(ipv6_dev_find);\n\nstruct inet6_ifaddr *ipv6_get_ifaddr(struct net *net, const struct in6_addr *addr,\n\t\t\t\t     struct net_device *dev, int strict)\n{\n\tunsigned int hash = inet6_addr_hash(net, addr);\n\tstruct inet6_ifaddr *ifp, *result = NULL;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(ifp, &net->ipv6.inet6_addr_lst[hash], addr_lst) {\n\t\tif (ipv6_addr_equal(&ifp->addr, addr)) {\n\t\t\tif (!dev || ifp->idev->dev == dev ||\n\t\t\t    !(ifp->scope&(IFA_LINK|IFA_HOST) || strict)) {\n\t\t\t\tresult = ifp;\n\t\t\t\tin6_ifa_hold(ifp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn result;\n}\n\n \n\nstatic void addrconf_dad_stop(struct inet6_ifaddr *ifp, int dad_failed)\n{\n\tif (dad_failed)\n\t\tifp->flags |= IFA_F_DADFAILED;\n\n\tif (ifp->flags&IFA_F_TEMPORARY) {\n\t\tstruct inet6_ifaddr *ifpub;\n\t\tspin_lock_bh(&ifp->lock);\n\t\tifpub = ifp->ifpub;\n\t\tif (ifpub) {\n\t\t\tin6_ifa_hold(ifpub);\n\t\t\tspin_unlock_bh(&ifp->lock);\n\t\t\tipv6_create_tempaddr(ifpub, true);\n\t\t\tin6_ifa_put(ifpub);\n\t\t} else {\n\t\t\tspin_unlock_bh(&ifp->lock);\n\t\t}\n\t\tipv6_del_addr(ifp);\n\t} else if (ifp->flags&IFA_F_PERMANENT || !dad_failed) {\n\t\tspin_lock_bh(&ifp->lock);\n\t\taddrconf_del_dad_work(ifp);\n\t\tifp->flags |= IFA_F_TENTATIVE;\n\t\tif (dad_failed)\n\t\t\tifp->flags &= ~IFA_F_OPTIMISTIC;\n\t\tspin_unlock_bh(&ifp->lock);\n\t\tif (dad_failed)\n\t\t\tipv6_ifa_notify(0, ifp);\n\t\tin6_ifa_put(ifp);\n\t} else {\n\t\tipv6_del_addr(ifp);\n\t}\n}\n\nstatic int addrconf_dad_end(struct inet6_ifaddr *ifp)\n{\n\tint err = -ENOENT;\n\n\tspin_lock_bh(&ifp->lock);\n\tif (ifp->state == INET6_IFADDR_STATE_DAD) {\n\t\tifp->state = INET6_IFADDR_STATE_POSTDAD;\n\t\terr = 0;\n\t}\n\tspin_unlock_bh(&ifp->lock);\n\n\treturn err;\n}\n\nvoid addrconf_dad_failure(struct sk_buff *skb, struct inet6_ifaddr *ifp)\n{\n\tstruct inet6_dev *idev = ifp->idev;\n\tstruct net *net = dev_net(idev->dev);\n\n\tif (addrconf_dad_end(ifp)) {\n\t\tin6_ifa_put(ifp);\n\t\treturn;\n\t}\n\n\tnet_info_ratelimited(\"%s: IPv6 duplicate address %pI6c used by %pM detected!\\n\",\n\t\t\t     ifp->idev->dev->name, &ifp->addr, eth_hdr(skb)->h_source);\n\n\tspin_lock_bh(&ifp->lock);\n\n\tif (ifp->flags & IFA_F_STABLE_PRIVACY) {\n\t\tstruct in6_addr new_addr;\n\t\tstruct inet6_ifaddr *ifp2;\n\t\tint retries = ifp->stable_privacy_retry + 1;\n\t\tstruct ifa6_config cfg = {\n\t\t\t.pfx = &new_addr,\n\t\t\t.plen = ifp->prefix_len,\n\t\t\t.ifa_flags = ifp->flags,\n\t\t\t.valid_lft = ifp->valid_lft,\n\t\t\t.preferred_lft = ifp->prefered_lft,\n\t\t\t.scope = ifp->scope,\n\t\t};\n\n\t\tif (retries > net->ipv6.sysctl.idgen_retries) {\n\t\t\tnet_info_ratelimited(\"%s: privacy stable address generation failed because of DAD conflicts!\\n\",\n\t\t\t\t\t     ifp->idev->dev->name);\n\t\t\tgoto errdad;\n\t\t}\n\n\t\tnew_addr = ifp->addr;\n\t\tif (ipv6_generate_stable_address(&new_addr, retries,\n\t\t\t\t\t\t idev))\n\t\t\tgoto errdad;\n\n\t\tspin_unlock_bh(&ifp->lock);\n\n\t\tif (idev->cnf.max_addresses &&\n\t\t    ipv6_count_addresses(idev) >=\n\t\t    idev->cnf.max_addresses)\n\t\t\tgoto lock_errdad;\n\n\t\tnet_info_ratelimited(\"%s: generating new stable privacy address because of DAD conflict\\n\",\n\t\t\t\t     ifp->idev->dev->name);\n\n\t\tifp2 = ipv6_add_addr(idev, &cfg, false, NULL);\n\t\tif (IS_ERR(ifp2))\n\t\t\tgoto lock_errdad;\n\n\t\tspin_lock_bh(&ifp2->lock);\n\t\tifp2->stable_privacy_retry = retries;\n\t\tifp2->state = INET6_IFADDR_STATE_PREDAD;\n\t\tspin_unlock_bh(&ifp2->lock);\n\n\t\taddrconf_mod_dad_work(ifp2, net->ipv6.sysctl.idgen_delay);\n\t\tin6_ifa_put(ifp2);\nlock_errdad:\n\t\tspin_lock_bh(&ifp->lock);\n\t}\n\nerrdad:\n\t \n\tifp->state = INET6_IFADDR_STATE_ERRDAD;\n\tspin_unlock_bh(&ifp->lock);\n\n\taddrconf_mod_dad_work(ifp, 0);\n\tin6_ifa_put(ifp);\n}\n\n \nvoid addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr)\n{\n\tstruct in6_addr maddr;\n\n\tif (dev->flags&(IFF_LOOPBACK|IFF_NOARP))\n\t\treturn;\n\n\taddrconf_addr_solict_mult(addr, &maddr);\n\tipv6_dev_mc_inc(dev, &maddr);\n}\n\n \nvoid addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr)\n{\n\tstruct in6_addr maddr;\n\n\tif (idev->dev->flags&(IFF_LOOPBACK|IFF_NOARP))\n\t\treturn;\n\n\taddrconf_addr_solict_mult(addr, &maddr);\n\t__ipv6_dev_mc_dec(idev, &maddr);\n}\n\n \nstatic void addrconf_join_anycast(struct inet6_ifaddr *ifp)\n{\n\tstruct in6_addr addr;\n\n\tif (ifp->prefix_len >= 127)  \n\t\treturn;\n\tipv6_addr_prefix(&addr, &ifp->addr, ifp->prefix_len);\n\tif (ipv6_addr_any(&addr))\n\t\treturn;\n\t__ipv6_dev_ac_inc(ifp->idev, &addr);\n}\n\n \nstatic void addrconf_leave_anycast(struct inet6_ifaddr *ifp)\n{\n\tstruct in6_addr addr;\n\n\tif (ifp->prefix_len >= 127)  \n\t\treturn;\n\tipv6_addr_prefix(&addr, &ifp->addr, ifp->prefix_len);\n\tif (ipv6_addr_any(&addr))\n\t\treturn;\n\t__ipv6_dev_ac_dec(ifp->idev, &addr);\n}\n\nstatic int addrconf_ifid_6lowpan(u8 *eui, struct net_device *dev)\n{\n\tswitch (dev->addr_len) {\n\tcase ETH_ALEN:\n\t\tmemcpy(eui, dev->dev_addr, 3);\n\t\teui[3] = 0xFF;\n\t\teui[4] = 0xFE;\n\t\tmemcpy(eui + 5, dev->dev_addr + 3, 3);\n\t\tbreak;\n\tcase EUI64_ADDR_LEN:\n\t\tmemcpy(eui, dev->dev_addr, EUI64_ADDR_LEN);\n\t\teui[0] ^= 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int addrconf_ifid_ieee1394(u8 *eui, struct net_device *dev)\n{\n\tconst union fwnet_hwaddr *ha;\n\n\tif (dev->addr_len != FWNET_ALEN)\n\t\treturn -1;\n\n\tha = (const union fwnet_hwaddr *)dev->dev_addr;\n\n\tmemcpy(eui, &ha->uc.uniq_id, sizeof(ha->uc.uniq_id));\n\teui[0] ^= 2;\n\treturn 0;\n}\n\nstatic int addrconf_ifid_arcnet(u8 *eui, struct net_device *dev)\n{\n\t \n\tif (dev->addr_len != ARCNET_ALEN)\n\t\treturn -1;\n\tmemset(eui, 0, 7);\n\teui[7] = *(u8 *)dev->dev_addr;\n\treturn 0;\n}\n\nstatic int addrconf_ifid_infiniband(u8 *eui, struct net_device *dev)\n{\n\tif (dev->addr_len != INFINIBAND_ALEN)\n\t\treturn -1;\n\tmemcpy(eui, dev->dev_addr + 12, 8);\n\teui[0] |= 2;\n\treturn 0;\n}\n\nstatic int __ipv6_isatap_ifid(u8 *eui, __be32 addr)\n{\n\tif (addr == 0)\n\t\treturn -1;\n\teui[0] = (ipv4_is_zeronet(addr) || ipv4_is_private_10(addr) ||\n\t\t  ipv4_is_loopback(addr) || ipv4_is_linklocal_169(addr) ||\n\t\t  ipv4_is_private_172(addr) || ipv4_is_test_192(addr) ||\n\t\t  ipv4_is_anycast_6to4(addr) || ipv4_is_private_192(addr) ||\n\t\t  ipv4_is_test_198(addr) || ipv4_is_multicast(addr) ||\n\t\t  ipv4_is_lbcast(addr)) ? 0x00 : 0x02;\n\teui[1] = 0;\n\teui[2] = 0x5E;\n\teui[3] = 0xFE;\n\tmemcpy(eui + 4, &addr, 4);\n\treturn 0;\n}\n\nstatic int addrconf_ifid_sit(u8 *eui, struct net_device *dev)\n{\n\tif (dev->priv_flags & IFF_ISATAP)\n\t\treturn __ipv6_isatap_ifid(eui, *(__be32 *)dev->dev_addr);\n\treturn -1;\n}\n\nstatic int addrconf_ifid_gre(u8 *eui, struct net_device *dev)\n{\n\treturn __ipv6_isatap_ifid(eui, *(__be32 *)dev->dev_addr);\n}\n\nstatic int addrconf_ifid_ip6tnl(u8 *eui, struct net_device *dev)\n{\n\tmemcpy(eui, dev->perm_addr, 3);\n\tmemcpy(eui + 5, dev->perm_addr + 3, 3);\n\teui[3] = 0xFF;\n\teui[4] = 0xFE;\n\teui[0] ^= 2;\n\treturn 0;\n}\n\nstatic int ipv6_generate_eui64(u8 *eui, struct net_device *dev)\n{\n\tswitch (dev->type) {\n\tcase ARPHRD_ETHER:\n\tcase ARPHRD_FDDI:\n\t\treturn addrconf_ifid_eui48(eui, dev);\n\tcase ARPHRD_ARCNET:\n\t\treturn addrconf_ifid_arcnet(eui, dev);\n\tcase ARPHRD_INFINIBAND:\n\t\treturn addrconf_ifid_infiniband(eui, dev);\n\tcase ARPHRD_SIT:\n\t\treturn addrconf_ifid_sit(eui, dev);\n\tcase ARPHRD_IPGRE:\n\tcase ARPHRD_TUNNEL:\n\t\treturn addrconf_ifid_gre(eui, dev);\n\tcase ARPHRD_6LOWPAN:\n\t\treturn addrconf_ifid_6lowpan(eui, dev);\n\tcase ARPHRD_IEEE1394:\n\t\treturn addrconf_ifid_ieee1394(eui, dev);\n\tcase ARPHRD_TUNNEL6:\n\tcase ARPHRD_IP6GRE:\n\tcase ARPHRD_RAWIP:\n\t\treturn addrconf_ifid_ip6tnl(eui, dev);\n\t}\n\treturn -1;\n}\n\nstatic int ipv6_inherit_eui64(u8 *eui, struct inet6_dev *idev)\n{\n\tint err = -1;\n\tstruct inet6_ifaddr *ifp;\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry_reverse(ifp, &idev->addr_list, if_list) {\n\t\tif (ifp->scope > IFA_LINK)\n\t\t\tbreak;\n\t\tif (ifp->scope == IFA_LINK && !(ifp->flags&IFA_F_TENTATIVE)) {\n\t\t\tmemcpy(eui, ifp->addr.s6_addr+8, 8);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock_bh(&idev->lock);\n\treturn err;\n}\n\n \n\nstatic void ipv6_gen_rnd_iid(struct in6_addr *addr)\n{\nregen:\n\tget_random_bytes(&addr->s6_addr[8], 8);\n\n\t \n\n\t \n\tif (!(addr->s6_addr32[2] | addr->s6_addr32[3]))\n\t\tgoto regen;\n\n\t \n\tif (ntohl(addr->s6_addr32[2]) == 0x02005eff &&\n\t    (ntohl(addr->s6_addr32[3]) & 0Xff000000) == 0xfe000000)\n\t\tgoto regen;\n\n\t \n\tif (ntohl(addr->s6_addr32[2]) == 0xfdffffff &&\n\t    ntohl(addr->s6_addr32[3]) >= 0Xffffff80)\n\t\tgoto regen;\n}\n\n \n\nstatic void\naddrconf_prefix_route(struct in6_addr *pfx, int plen, u32 metric,\n\t\t      struct net_device *dev, unsigned long expires,\n\t\t      u32 flags, gfp_t gfp_flags)\n{\n\tstruct fib6_config cfg = {\n\t\t.fc_table = l3mdev_fib_table(dev) ? : RT6_TABLE_PREFIX,\n\t\t.fc_metric = metric ? : IP6_RT_PRIO_ADDRCONF,\n\t\t.fc_ifindex = dev->ifindex,\n\t\t.fc_expires = expires,\n\t\t.fc_dst_len = plen,\n\t\t.fc_flags = RTF_UP | flags,\n\t\t.fc_nlinfo.nl_net = dev_net(dev),\n\t\t.fc_protocol = RTPROT_KERNEL,\n\t\t.fc_type = RTN_UNICAST,\n\t};\n\n\tcfg.fc_dst = *pfx;\n\n\t \n#if IS_ENABLED(CONFIG_IPV6_SIT)\n\tif (dev->type == ARPHRD_SIT && (dev->flags & IFF_POINTOPOINT))\n\t\tcfg.fc_flags |= RTF_NONEXTHOP;\n#endif\n\n\tip6_route_add(&cfg, gfp_flags, NULL);\n}\n\n\nstatic struct fib6_info *addrconf_get_prefix_route(const struct in6_addr *pfx,\n\t\t\t\t\t\t  int plen,\n\t\t\t\t\t\t  const struct net_device *dev,\n\t\t\t\t\t\t  u32 flags, u32 noflags,\n\t\t\t\t\t\t  bool no_gw)\n{\n\tstruct fib6_node *fn;\n\tstruct fib6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tu32 tb_id = l3mdev_fib_table(dev) ? : RT6_TABLE_PREFIX;\n\n\ttable = fib6_get_table(dev_net(dev), tb_id);\n\tif (!table)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tfn = fib6_locate(&table->tb6_root, pfx, plen, NULL, 0, true);\n\tif (!fn)\n\t\tgoto out;\n\n\tfor_each_fib6_node_rt_rcu(fn) {\n\t\t \n\t\tif (rt->nh)\n\t\t\tcontinue;\n\n\t\tif (rt->fib6_nh->fib_nh_dev->ifindex != dev->ifindex)\n\t\t\tcontinue;\n\t\tif (no_gw && rt->fib6_nh->fib_nh_gw_family)\n\t\t\tcontinue;\n\t\tif ((rt->fib6_flags & flags) != flags)\n\t\t\tcontinue;\n\t\tif ((rt->fib6_flags & noflags) != 0)\n\t\t\tcontinue;\n\t\tif (!fib6_info_hold_safe(rt))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\nout:\n\trcu_read_unlock();\n\treturn rt;\n}\n\n\n \n\nstatic void addrconf_add_mroute(struct net_device *dev)\n{\n\tstruct fib6_config cfg = {\n\t\t.fc_table = l3mdev_fib_table(dev) ? : RT6_TABLE_LOCAL,\n\t\t.fc_metric = IP6_RT_PRIO_ADDRCONF,\n\t\t.fc_ifindex = dev->ifindex,\n\t\t.fc_dst_len = 8,\n\t\t.fc_flags = RTF_UP,\n\t\t.fc_type = RTN_MULTICAST,\n\t\t.fc_nlinfo.nl_net = dev_net(dev),\n\t\t.fc_protocol = RTPROT_KERNEL,\n\t};\n\n\tipv6_addr_set(&cfg.fc_dst, htonl(0xFF000000), 0, 0, 0);\n\n\tip6_route_add(&cfg, GFP_KERNEL, NULL);\n}\n\nstatic struct inet6_dev *addrconf_add_dev(struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\n\tASSERT_RTNL();\n\n\tidev = ipv6_find_idev(dev);\n\tif (IS_ERR(idev))\n\t\treturn idev;\n\n\tif (idev->cnf.disable_ipv6)\n\t\treturn ERR_PTR(-EACCES);\n\n\t \n\tif (!(dev->flags & IFF_LOOPBACK) && !netif_is_l3_master(dev))\n\t\taddrconf_add_mroute(dev);\n\n\treturn idev;\n}\n\nstatic void manage_tempaddrs(struct inet6_dev *idev,\n\t\t\t     struct inet6_ifaddr *ifp,\n\t\t\t     __u32 valid_lft, __u32 prefered_lft,\n\t\t\t     bool create, unsigned long now)\n{\n\tu32 flags;\n\tstruct inet6_ifaddr *ift;\n\n\tread_lock_bh(&idev->lock);\n\t \n\tlist_for_each_entry(ift, &idev->tempaddr_list, tmp_list) {\n\t\tint age, max_valid, max_prefered;\n\n\t\tif (ifp != ift->ifpub)\n\t\t\tcontinue;\n\n\t\t \n\t\tage = (now - ift->cstamp) / HZ;\n\t\tmax_valid = idev->cnf.temp_valid_lft - age;\n\t\tif (max_valid < 0)\n\t\t\tmax_valid = 0;\n\n\t\tmax_prefered = idev->cnf.temp_prefered_lft -\n\t\t\t       idev->desync_factor - age;\n\t\tif (max_prefered < 0)\n\t\t\tmax_prefered = 0;\n\n\t\tif (valid_lft > max_valid)\n\t\t\tvalid_lft = max_valid;\n\n\t\tif (prefered_lft > max_prefered)\n\t\t\tprefered_lft = max_prefered;\n\n\t\tspin_lock(&ift->lock);\n\t\tflags = ift->flags;\n\t\tift->valid_lft = valid_lft;\n\t\tift->prefered_lft = prefered_lft;\n\t\tift->tstamp = now;\n\t\tif (prefered_lft > 0)\n\t\t\tift->flags &= ~IFA_F_DEPRECATED;\n\n\t\tspin_unlock(&ift->lock);\n\t\tif (!(flags&IFA_F_TENTATIVE))\n\t\t\tipv6_ifa_notify(0, ift);\n\t}\n\n\t \n\tif (list_empty(&idev->tempaddr_list) && (valid_lft || prefered_lft))\n\t\tcreate = true;\n\n\tif (create && idev->cnf.use_tempaddr > 0) {\n\t\t \n\t\tread_unlock_bh(&idev->lock);\n\t\tipv6_create_tempaddr(ifp, false);\n\t} else {\n\t\tread_unlock_bh(&idev->lock);\n\t}\n}\n\nstatic bool is_addr_mode_generate_stable(struct inet6_dev *idev)\n{\n\treturn idev->cnf.addr_gen_mode == IN6_ADDR_GEN_MODE_STABLE_PRIVACY ||\n\t       idev->cnf.addr_gen_mode == IN6_ADDR_GEN_MODE_RANDOM;\n}\n\nint addrconf_prefix_rcv_add_addr(struct net *net, struct net_device *dev,\n\t\t\t\t const struct prefix_info *pinfo,\n\t\t\t\t struct inet6_dev *in6_dev,\n\t\t\t\t const struct in6_addr *addr, int addr_type,\n\t\t\t\t u32 addr_flags, bool sllao, bool tokenized,\n\t\t\t\t __u32 valid_lft, u32 prefered_lft)\n{\n\tstruct inet6_ifaddr *ifp = ipv6_get_ifaddr(net, addr, dev, 1);\n\tint create = 0, update_lft = 0;\n\n\tif (!ifp && valid_lft) {\n\t\tint max_addresses = in6_dev->cnf.max_addresses;\n\t\tstruct ifa6_config cfg = {\n\t\t\t.pfx = addr,\n\t\t\t.plen = pinfo->prefix_len,\n\t\t\t.ifa_flags = addr_flags,\n\t\t\t.valid_lft = valid_lft,\n\t\t\t.preferred_lft = prefered_lft,\n\t\t\t.scope = addr_type & IPV6_ADDR_SCOPE_MASK,\n\t\t\t.ifa_proto = IFAPROT_KERNEL_RA\n\t\t};\n\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\t\tif ((net->ipv6.devconf_all->optimistic_dad ||\n\t\t     in6_dev->cnf.optimistic_dad) &&\n\t\t    !net->ipv6.devconf_all->forwarding && sllao)\n\t\t\tcfg.ifa_flags |= IFA_F_OPTIMISTIC;\n#endif\n\n\t\t \n\t\tif (!max_addresses ||\n\t\t    ipv6_count_addresses(in6_dev) < max_addresses)\n\t\t\tifp = ipv6_add_addr(in6_dev, &cfg, false, NULL);\n\n\t\tif (IS_ERR_OR_NULL(ifp))\n\t\t\treturn -1;\n\n\t\tcreate = 1;\n\t\tspin_lock_bh(&ifp->lock);\n\t\tifp->flags |= IFA_F_MANAGETEMPADDR;\n\t\tifp->cstamp = jiffies;\n\t\tifp->tokenized = tokenized;\n\t\tspin_unlock_bh(&ifp->lock);\n\t\taddrconf_dad_start(ifp);\n\t}\n\n\tif (ifp) {\n\t\tu32 flags;\n\t\tunsigned long now;\n\t\tu32 stored_lft;\n\n\t\t \n\t\tspin_lock_bh(&ifp->lock);\n\t\tnow = jiffies;\n\t\tif (ifp->valid_lft > (now - ifp->tstamp) / HZ)\n\t\t\tstored_lft = ifp->valid_lft - (now - ifp->tstamp) / HZ;\n\t\telse\n\t\t\tstored_lft = 0;\n\t\tif (!create && stored_lft) {\n\t\t\tconst u32 minimum_lft = min_t(u32,\n\t\t\t\tstored_lft, MIN_VALID_LIFETIME);\n\t\t\tvalid_lft = max(valid_lft, minimum_lft);\n\n\t\t\t \n\t\t\tupdate_lft = 1;\n\t\t}\n\n\t\tif (update_lft) {\n\t\t\tifp->valid_lft = valid_lft;\n\t\t\tifp->prefered_lft = prefered_lft;\n\t\t\tifp->tstamp = now;\n\t\t\tflags = ifp->flags;\n\t\t\tifp->flags &= ~IFA_F_DEPRECATED;\n\t\t\tspin_unlock_bh(&ifp->lock);\n\n\t\t\tif (!(flags&IFA_F_TENTATIVE))\n\t\t\t\tipv6_ifa_notify(0, ifp);\n\t\t} else\n\t\t\tspin_unlock_bh(&ifp->lock);\n\n\t\tmanage_tempaddrs(in6_dev, ifp, valid_lft, prefered_lft,\n\t\t\t\t create, now);\n\n\t\tin6_ifa_put(ifp);\n\t\taddrconf_verify(net);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(addrconf_prefix_rcv_add_addr);\n\nvoid addrconf_prefix_rcv(struct net_device *dev, u8 *opt, int len, bool sllao)\n{\n\tstruct prefix_info *pinfo;\n\t__u32 valid_lft;\n\t__u32 prefered_lft;\n\tint addr_type, err;\n\tu32 addr_flags = 0;\n\tstruct inet6_dev *in6_dev;\n\tstruct net *net = dev_net(dev);\n\n\tpinfo = (struct prefix_info *) opt;\n\n\tif (len < sizeof(struct prefix_info)) {\n\t\tnetdev_dbg(dev, \"addrconf: prefix option too short\\n\");\n\t\treturn;\n\t}\n\n\t \n\n\taddr_type = ipv6_addr_type(&pinfo->prefix);\n\n\tif (addr_type & (IPV6_ADDR_MULTICAST|IPV6_ADDR_LINKLOCAL))\n\t\treturn;\n\n\tvalid_lft = ntohl(pinfo->valid);\n\tprefered_lft = ntohl(pinfo->prefered);\n\n\tif (prefered_lft > valid_lft) {\n\t\tnet_warn_ratelimited(\"addrconf: prefix option has invalid lifetime\\n\");\n\t\treturn;\n\t}\n\n\tin6_dev = in6_dev_get(dev);\n\n\tif (!in6_dev) {\n\t\tnet_dbg_ratelimited(\"addrconf: device %s not configured\\n\",\n\t\t\t\t    dev->name);\n\t\treturn;\n\t}\n\n\tif (valid_lft != 0 && valid_lft < in6_dev->cnf.accept_ra_min_lft)\n\t\tgoto put;\n\n\t \n\n\tif (pinfo->onlink) {\n\t\tstruct fib6_info *rt;\n\t\tunsigned long rt_expires;\n\n\t\t \n\t\tif (HZ > USER_HZ)\n\t\t\trt_expires = addrconf_timeout_fixup(valid_lft, HZ);\n\t\telse\n\t\t\trt_expires = addrconf_timeout_fixup(valid_lft, USER_HZ);\n\n\t\tif (addrconf_finite_timeout(rt_expires))\n\t\t\trt_expires *= HZ;\n\n\t\trt = addrconf_get_prefix_route(&pinfo->prefix,\n\t\t\t\t\t       pinfo->prefix_len,\n\t\t\t\t\t       dev,\n\t\t\t\t\t       RTF_ADDRCONF | RTF_PREFIX_RT,\n\t\t\t\t\t       RTF_DEFAULT, true);\n\n\t\tif (rt) {\n\t\t\t \n\t\t\tif (valid_lft == 0) {\n\t\t\t\tip6_del_rt(net, rt, false);\n\t\t\t\trt = NULL;\n\t\t\t} else if (addrconf_finite_timeout(rt_expires)) {\n\t\t\t\t \n\t\t\t\tfib6_set_expires(rt, jiffies + rt_expires);\n\t\t\t} else {\n\t\t\t\tfib6_clean_expires(rt);\n\t\t\t}\n\t\t} else if (valid_lft) {\n\t\t\tclock_t expires = 0;\n\t\t\tint flags = RTF_ADDRCONF | RTF_PREFIX_RT;\n\t\t\tif (addrconf_finite_timeout(rt_expires)) {\n\t\t\t\t \n\t\t\t\tflags |= RTF_EXPIRES;\n\t\t\t\texpires = jiffies_to_clock_t(rt_expires);\n\t\t\t}\n\t\t\taddrconf_prefix_route(&pinfo->prefix, pinfo->prefix_len,\n\t\t\t\t\t      0, dev, expires, flags,\n\t\t\t\t\t      GFP_ATOMIC);\n\t\t}\n\t\tfib6_info_release(rt);\n\t}\n\n\t \n\n\tif (pinfo->autoconf && in6_dev->cnf.autoconf) {\n\t\tstruct in6_addr addr;\n\t\tbool tokenized = false, dev_addr_generated = false;\n\n\t\tif (pinfo->prefix_len == 64) {\n\t\t\tmemcpy(&addr, &pinfo->prefix, 8);\n\n\t\t\tif (!ipv6_addr_any(&in6_dev->token)) {\n\t\t\t\tread_lock_bh(&in6_dev->lock);\n\t\t\t\tmemcpy(addr.s6_addr + 8,\n\t\t\t\t       in6_dev->token.s6_addr + 8, 8);\n\t\t\t\tread_unlock_bh(&in6_dev->lock);\n\t\t\t\ttokenized = true;\n\t\t\t} else if (is_addr_mode_generate_stable(in6_dev) &&\n\t\t\t\t   !ipv6_generate_stable_address(&addr, 0,\n\t\t\t\t\t\t\t\t in6_dev)) {\n\t\t\t\taddr_flags |= IFA_F_STABLE_PRIVACY;\n\t\t\t\tgoto ok;\n\t\t\t} else if (ipv6_generate_eui64(addr.s6_addr + 8, dev) &&\n\t\t\t\t   ipv6_inherit_eui64(addr.s6_addr + 8, in6_dev)) {\n\t\t\t\tgoto put;\n\t\t\t} else {\n\t\t\t\tdev_addr_generated = true;\n\t\t\t}\n\t\t\tgoto ok;\n\t\t}\n\t\tnet_dbg_ratelimited(\"IPv6 addrconf: prefix with wrong length %d\\n\",\n\t\t\t\t    pinfo->prefix_len);\n\t\tgoto put;\n\nok:\n\t\terr = addrconf_prefix_rcv_add_addr(net, dev, pinfo, in6_dev,\n\t\t\t\t\t\t   &addr, addr_type,\n\t\t\t\t\t\t   addr_flags, sllao,\n\t\t\t\t\t\t   tokenized, valid_lft,\n\t\t\t\t\t\t   prefered_lft);\n\t\tif (err)\n\t\t\tgoto put;\n\n\t\t \n\t\tndisc_ops_prefix_rcv_add_addr(net, dev, pinfo, in6_dev, &addr,\n\t\t\t\t\t      addr_type, addr_flags, sllao,\n\t\t\t\t\t      tokenized, valid_lft,\n\t\t\t\t\t      prefered_lft,\n\t\t\t\t\t      dev_addr_generated);\n\t}\n\tinet6_prefix_notify(RTM_NEWPREFIX, in6_dev, pinfo);\nput:\n\tin6_dev_put(in6_dev);\n}\n\nstatic int addrconf_set_sit_dstaddr(struct net *net, struct net_device *dev,\n\t\tstruct in6_ifreq *ireq)\n{\n\tstruct ip_tunnel_parm p = { };\n\tint err;\n\n\tif (!(ipv6_addr_type(&ireq->ifr6_addr) & IPV6_ADDR_COMPATv4))\n\t\treturn -EADDRNOTAVAIL;\n\n\tp.iph.daddr = ireq->ifr6_addr.s6_addr32[3];\n\tp.iph.version = 4;\n\tp.iph.ihl = 5;\n\tp.iph.protocol = IPPROTO_IPV6;\n\tp.iph.ttl = 64;\n\n\tif (!dev->netdev_ops->ndo_tunnel_ctl)\n\t\treturn -EOPNOTSUPP;\n\terr = dev->netdev_ops->ndo_tunnel_ctl(dev, &p, SIOCADDTUNNEL);\n\tif (err)\n\t\treturn err;\n\n\tdev = __dev_get_by_name(net, p.name);\n\tif (!dev)\n\t\treturn -ENOBUFS;\n\treturn dev_open(dev, NULL);\n}\n\n \nint addrconf_set_dstaddr(struct net *net, void __user *arg)\n{\n\tstruct net_device *dev;\n\tstruct in6_ifreq ireq;\n\tint err = -ENODEV;\n\n\tif (!IS_ENABLED(CONFIG_IPV6_SIT))\n\t\treturn -ENODEV;\n\tif (copy_from_user(&ireq, arg, sizeof(struct in6_ifreq)))\n\t\treturn -EFAULT;\n\n\trtnl_lock();\n\tdev = __dev_get_by_index(net, ireq.ifr6_ifindex);\n\tif (dev && dev->type == ARPHRD_SIT)\n\t\terr = addrconf_set_sit_dstaddr(net, dev, &ireq);\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int ipv6_mc_config(struct sock *sk, bool join,\n\t\t\t  const struct in6_addr *addr, int ifindex)\n{\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tlock_sock(sk);\n\tif (join)\n\t\tret = ipv6_sock_mc_join(sk, ifindex, addr);\n\telse\n\t\tret = ipv6_sock_mc_drop(sk, ifindex, addr);\n\trelease_sock(sk);\n\n\treturn ret;\n}\n\n \nstatic int inet6_addr_add(struct net *net, int ifindex,\n\t\t\t  struct ifa6_config *cfg,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct inet6_ifaddr *ifp;\n\tstruct inet6_dev *idev;\n\tstruct net_device *dev;\n\tunsigned long timeout;\n\tclock_t expires;\n\tu32 flags;\n\n\tASSERT_RTNL();\n\n\tif (cfg->plen > 128) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid prefix length\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!cfg->valid_lft || cfg->preferred_lft > cfg->valid_lft) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"address lifetime invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->ifa_flags & IFA_F_MANAGETEMPADDR && cfg->plen != 64) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"address with \\\"mngtmpaddr\\\" flag must have a prefix length of 64\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tidev = addrconf_add_dev(dev);\n\tif (IS_ERR(idev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"IPv6 is disabled on this device\");\n\t\treturn PTR_ERR(idev);\n\t}\n\n\tif (cfg->ifa_flags & IFA_F_MCAUTOJOIN) {\n\t\tint ret = ipv6_mc_config(net->ipv6.mc_autojoin_sk,\n\t\t\t\t\t true, cfg->pfx, ifindex);\n\n\t\tif (ret < 0) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Multicast auto join failed\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcfg->scope = ipv6_addr_scope(cfg->pfx);\n\n\ttimeout = addrconf_timeout_fixup(cfg->valid_lft, HZ);\n\tif (addrconf_finite_timeout(timeout)) {\n\t\texpires = jiffies_to_clock_t(timeout * HZ);\n\t\tcfg->valid_lft = timeout;\n\t\tflags = RTF_EXPIRES;\n\t} else {\n\t\texpires = 0;\n\t\tflags = 0;\n\t\tcfg->ifa_flags |= IFA_F_PERMANENT;\n\t}\n\n\ttimeout = addrconf_timeout_fixup(cfg->preferred_lft, HZ);\n\tif (addrconf_finite_timeout(timeout)) {\n\t\tif (timeout == 0)\n\t\t\tcfg->ifa_flags |= IFA_F_DEPRECATED;\n\t\tcfg->preferred_lft = timeout;\n\t}\n\n\tifp = ipv6_add_addr(idev, cfg, true, extack);\n\tif (!IS_ERR(ifp)) {\n\t\tif (!(cfg->ifa_flags & IFA_F_NOPREFIXROUTE)) {\n\t\t\taddrconf_prefix_route(&ifp->addr, ifp->prefix_len,\n\t\t\t\t\t      ifp->rt_priority, dev, expires,\n\t\t\t\t\t      flags, GFP_KERNEL);\n\t\t}\n\n\t\t \n\t\tif (!(ifp->flags & (IFA_F_OPTIMISTIC | IFA_F_NODAD)))\n\t\t\tipv6_ifa_notify(0, ifp);\n\t\t \n\t\taddrconf_dad_start(ifp);\n\t\tif (cfg->ifa_flags & IFA_F_MANAGETEMPADDR)\n\t\t\tmanage_tempaddrs(idev, ifp, cfg->valid_lft,\n\t\t\t\t\t cfg->preferred_lft, true, jiffies);\n\t\tin6_ifa_put(ifp);\n\t\taddrconf_verify_rtnl(net);\n\t\treturn 0;\n\t} else if (cfg->ifa_flags & IFA_F_MCAUTOJOIN) {\n\t\tipv6_mc_config(net->ipv6.mc_autojoin_sk, false,\n\t\t\t       cfg->pfx, ifindex);\n\t}\n\n\treturn PTR_ERR(ifp);\n}\n\nstatic int inet6_addr_del(struct net *net, int ifindex, u32 ifa_flags,\n\t\t\t  const struct in6_addr *pfx, unsigned int plen,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct inet6_ifaddr *ifp;\n\tstruct inet6_dev *idev;\n\tstruct net_device *dev;\n\n\tif (plen > 128) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid prefix length\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = __dev_get_by_index(net, ifindex);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unable to find the interface\");\n\t\treturn -ENODEV;\n\t}\n\n\tidev = __in6_dev_get(dev);\n\tif (!idev) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"IPv6 is disabled on this device\");\n\t\treturn -ENXIO;\n\t}\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifp, &idev->addr_list, if_list) {\n\t\tif (ifp->prefix_len == plen &&\n\t\t    ipv6_addr_equal(pfx, &ifp->addr)) {\n\t\t\tin6_ifa_hold(ifp);\n\t\t\tread_unlock_bh(&idev->lock);\n\n\t\t\tif (!(ifp->flags & IFA_F_TEMPORARY) &&\n\t\t\t    (ifa_flags & IFA_F_MANAGETEMPADDR))\n\t\t\t\tmanage_tempaddrs(idev, ifp, 0, 0, false,\n\t\t\t\t\t\t jiffies);\n\t\t\tipv6_del_addr(ifp);\n\t\t\taddrconf_verify_rtnl(net);\n\t\t\tif (ipv6_addr_is_multicast(pfx)) {\n\t\t\t\tipv6_mc_config(net->ipv6.mc_autojoin_sk,\n\t\t\t\t\t       false, pfx, dev->ifindex);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tread_unlock_bh(&idev->lock);\n\n\tNL_SET_ERR_MSG_MOD(extack, \"address not found\");\n\treturn -EADDRNOTAVAIL;\n}\n\n\nint addrconf_add_ifaddr(struct net *net, void __user *arg)\n{\n\tstruct ifa6_config cfg = {\n\t\t.ifa_flags = IFA_F_PERMANENT,\n\t\t.preferred_lft = INFINITY_LIFE_TIME,\n\t\t.valid_lft = INFINITY_LIFE_TIME,\n\t};\n\tstruct in6_ifreq ireq;\n\tint err;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&ireq, arg, sizeof(struct in6_ifreq)))\n\t\treturn -EFAULT;\n\n\tcfg.pfx = &ireq.ifr6_addr;\n\tcfg.plen = ireq.ifr6_prefixlen;\n\n\trtnl_lock();\n\terr = inet6_addr_add(net, ireq.ifr6_ifindex, &cfg, NULL);\n\trtnl_unlock();\n\treturn err;\n}\n\nint addrconf_del_ifaddr(struct net *net, void __user *arg)\n{\n\tstruct in6_ifreq ireq;\n\tint err;\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&ireq, arg, sizeof(struct in6_ifreq)))\n\t\treturn -EFAULT;\n\n\trtnl_lock();\n\terr = inet6_addr_del(net, ireq.ifr6_ifindex, 0, &ireq.ifr6_addr,\n\t\t\t     ireq.ifr6_prefixlen, NULL);\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic void add_addr(struct inet6_dev *idev, const struct in6_addr *addr,\n\t\t     int plen, int scope, u8 proto)\n{\n\tstruct inet6_ifaddr *ifp;\n\tstruct ifa6_config cfg = {\n\t\t.pfx = addr,\n\t\t.plen = plen,\n\t\t.ifa_flags = IFA_F_PERMANENT,\n\t\t.valid_lft = INFINITY_LIFE_TIME,\n\t\t.preferred_lft = INFINITY_LIFE_TIME,\n\t\t.scope = scope,\n\t\t.ifa_proto = proto\n\t};\n\n\tifp = ipv6_add_addr(idev, &cfg, true, NULL);\n\tif (!IS_ERR(ifp)) {\n\t\tspin_lock_bh(&ifp->lock);\n\t\tifp->flags &= ~IFA_F_TENTATIVE;\n\t\tspin_unlock_bh(&ifp->lock);\n\t\trt_genid_bump_ipv6(dev_net(idev->dev));\n\t\tipv6_ifa_notify(RTM_NEWADDR, ifp);\n\t\tin6_ifa_put(ifp);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_IPV6_SIT) || IS_ENABLED(CONFIG_NET_IPGRE) || IS_ENABLED(CONFIG_IPV6_GRE)\nstatic void add_v4_addrs(struct inet6_dev *idev)\n{\n\tstruct in6_addr addr;\n\tstruct net_device *dev;\n\tstruct net *net = dev_net(idev->dev);\n\tint scope, plen, offset = 0;\n\tu32 pflags = 0;\n\n\tASSERT_RTNL();\n\n\tmemset(&addr, 0, sizeof(struct in6_addr));\n\t \n\tif (idev->dev->addr_len == sizeof(struct in6_addr))\n\t\toffset = sizeof(struct in6_addr) - 4;\n\tmemcpy(&addr.s6_addr32[3], idev->dev->dev_addr + offset, 4);\n\n\tif (!(idev->dev->flags & IFF_POINTOPOINT) && idev->dev->type == ARPHRD_SIT) {\n\t\tscope = IPV6_ADDR_COMPATv4;\n\t\tplen = 96;\n\t\tpflags |= RTF_NONEXTHOP;\n\t} else {\n\t\tif (idev->cnf.addr_gen_mode == IN6_ADDR_GEN_MODE_NONE)\n\t\t\treturn;\n\n\t\taddr.s6_addr32[0] = htonl(0xfe800000);\n\t\tscope = IFA_LINK;\n\t\tplen = 64;\n\t}\n\n\tif (addr.s6_addr32[3]) {\n\t\tadd_addr(idev, &addr, plen, scope, IFAPROT_UNSPEC);\n\t\taddrconf_prefix_route(&addr, plen, 0, idev->dev, 0, pflags,\n\t\t\t\t      GFP_KERNEL);\n\t\treturn;\n\t}\n\n\tfor_each_netdev(net, dev) {\n\t\tstruct in_device *in_dev = __in_dev_get_rtnl(dev);\n\t\tif (in_dev && (dev->flags & IFF_UP)) {\n\t\t\tstruct in_ifaddr *ifa;\n\t\t\tint flag = scope;\n\n\t\t\tin_dev_for_each_ifa_rtnl(ifa, in_dev) {\n\t\t\t\taddr.s6_addr32[3] = ifa->ifa_local;\n\n\t\t\t\tif (ifa->ifa_scope == RT_SCOPE_LINK)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ifa->ifa_scope >= RT_SCOPE_HOST) {\n\t\t\t\t\tif (idev->dev->flags&IFF_POINTOPOINT)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tflag |= IFA_HOST;\n\t\t\t\t}\n\n\t\t\t\tadd_addr(idev, &addr, plen, flag,\n\t\t\t\t\t IFAPROT_UNSPEC);\n\t\t\t\taddrconf_prefix_route(&addr, plen, 0, idev->dev,\n\t\t\t\t\t\t      0, pflags, GFP_KERNEL);\n\t\t\t}\n\t\t}\n\t}\n}\n#endif\n\nstatic void init_loopback(struct net_device *dev)\n{\n\tstruct inet6_dev  *idev;\n\n\t \n\n\tASSERT_RTNL();\n\n\tidev = ipv6_find_idev(dev);\n\tif (IS_ERR(idev)) {\n\t\tpr_debug(\"%s: add_dev failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tadd_addr(idev, &in6addr_loopback, 128, IFA_HOST, IFAPROT_KERNEL_LO);\n}\n\nvoid addrconf_add_linklocal(struct inet6_dev *idev,\n\t\t\t    const struct in6_addr *addr, u32 flags)\n{\n\tstruct ifa6_config cfg = {\n\t\t.pfx = addr,\n\t\t.plen = 64,\n\t\t.ifa_flags = flags | IFA_F_PERMANENT,\n\t\t.valid_lft = INFINITY_LIFE_TIME,\n\t\t.preferred_lft = INFINITY_LIFE_TIME,\n\t\t.scope = IFA_LINK,\n\t\t.ifa_proto = IFAPROT_KERNEL_LL\n\t};\n\tstruct inet6_ifaddr *ifp;\n\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\tif ((dev_net(idev->dev)->ipv6.devconf_all->optimistic_dad ||\n\t     idev->cnf.optimistic_dad) &&\n\t    !dev_net(idev->dev)->ipv6.devconf_all->forwarding)\n\t\tcfg.ifa_flags |= IFA_F_OPTIMISTIC;\n#endif\n\n\tifp = ipv6_add_addr(idev, &cfg, true, NULL);\n\tif (!IS_ERR(ifp)) {\n\t\taddrconf_prefix_route(&ifp->addr, ifp->prefix_len, 0, idev->dev,\n\t\t\t\t      0, 0, GFP_ATOMIC);\n\t\taddrconf_dad_start(ifp);\n\t\tin6_ifa_put(ifp);\n\t}\n}\nEXPORT_SYMBOL_GPL(addrconf_add_linklocal);\n\nstatic bool ipv6_reserved_interfaceid(struct in6_addr address)\n{\n\tif ((address.s6_addr32[2] | address.s6_addr32[3]) == 0)\n\t\treturn true;\n\n\tif (address.s6_addr32[2] == htonl(0x02005eff) &&\n\t    ((address.s6_addr32[3] & htonl(0xfe000000)) == htonl(0xfe000000)))\n\t\treturn true;\n\n\tif (address.s6_addr32[2] == htonl(0xfdffffff) &&\n\t    ((address.s6_addr32[3] & htonl(0xffffff80)) == htonl(0xffffff80)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int ipv6_generate_stable_address(struct in6_addr *address,\n\t\t\t\t\tu8 dad_count,\n\t\t\t\t\tconst struct inet6_dev *idev)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tstatic __u32 digest[SHA1_DIGEST_WORDS];\n\tstatic __u32 workspace[SHA1_WORKSPACE_WORDS];\n\n\tstatic union {\n\t\tchar __data[SHA1_BLOCK_SIZE];\n\t\tstruct {\n\t\t\tstruct in6_addr secret;\n\t\t\t__be32 prefix[2];\n\t\t\tunsigned char hwaddr[MAX_ADDR_LEN];\n\t\t\tu8 dad_count;\n\t\t} __packed;\n\t} data;\n\n\tstruct in6_addr secret;\n\tstruct in6_addr temp;\n\tstruct net *net = dev_net(idev->dev);\n\n\tBUILD_BUG_ON(sizeof(data.__data) != sizeof(data));\n\n\tif (idev->cnf.stable_secret.initialized)\n\t\tsecret = idev->cnf.stable_secret.secret;\n\telse if (net->ipv6.devconf_dflt->stable_secret.initialized)\n\t\tsecret = net->ipv6.devconf_dflt->stable_secret.secret;\n\telse\n\t\treturn -1;\n\nretry:\n\tspin_lock_bh(&lock);\n\n\tsha1_init(digest);\n\tmemset(&data, 0, sizeof(data));\n\tmemset(workspace, 0, sizeof(workspace));\n\tmemcpy(data.hwaddr, idev->dev->perm_addr, idev->dev->addr_len);\n\tdata.prefix[0] = address->s6_addr32[0];\n\tdata.prefix[1] = address->s6_addr32[1];\n\tdata.secret = secret;\n\tdata.dad_count = dad_count;\n\n\tsha1_transform(digest, data.__data, workspace);\n\n\ttemp = *address;\n\ttemp.s6_addr32[2] = (__force __be32)digest[0];\n\ttemp.s6_addr32[3] = (__force __be32)digest[1];\n\n\tspin_unlock_bh(&lock);\n\n\tif (ipv6_reserved_interfaceid(temp)) {\n\t\tdad_count++;\n\t\tif (dad_count > dev_net(idev->dev)->ipv6.sysctl.idgen_retries)\n\t\t\treturn -1;\n\t\tgoto retry;\n\t}\n\n\t*address = temp;\n\treturn 0;\n}\n\nstatic void ipv6_gen_mode_random_init(struct inet6_dev *idev)\n{\n\tstruct ipv6_stable_secret *s = &idev->cnf.stable_secret;\n\n\tif (s->initialized)\n\t\treturn;\n\ts = &idev->cnf.stable_secret;\n\tget_random_bytes(&s->secret, sizeof(s->secret));\n\ts->initialized = true;\n}\n\nstatic void addrconf_addr_gen(struct inet6_dev *idev, bool prefix_route)\n{\n\tstruct in6_addr addr;\n\n\t \n\tif (netif_is_l3_master(idev->dev))\n\t\treturn;\n\n\t \n\tif (idev->dev->priv_flags & IFF_NO_ADDRCONF)\n\t\treturn;\n\n\tipv6_addr_set(&addr, htonl(0xFE800000), 0, 0, 0);\n\n\tswitch (idev->cnf.addr_gen_mode) {\n\tcase IN6_ADDR_GEN_MODE_RANDOM:\n\t\tipv6_gen_mode_random_init(idev);\n\t\tfallthrough;\n\tcase IN6_ADDR_GEN_MODE_STABLE_PRIVACY:\n\t\tif (!ipv6_generate_stable_address(&addr, 0, idev))\n\t\t\taddrconf_add_linklocal(idev, &addr,\n\t\t\t\t\t       IFA_F_STABLE_PRIVACY);\n\t\telse if (prefix_route)\n\t\t\taddrconf_prefix_route(&addr, 64, 0, idev->dev,\n\t\t\t\t\t      0, 0, GFP_KERNEL);\n\t\tbreak;\n\tcase IN6_ADDR_GEN_MODE_EUI64:\n\t\t \n\t\tif (ipv6_generate_eui64(addr.s6_addr + 8, idev->dev) == 0)\n\t\t\taddrconf_add_linklocal(idev, &addr, 0);\n\t\telse if (prefix_route)\n\t\t\taddrconf_prefix_route(&addr, 64, 0, idev->dev,\n\t\t\t\t\t      0, 0, GFP_KERNEL);\n\t\tbreak;\n\tcase IN6_ADDR_GEN_MODE_NONE:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic void addrconf_dev_config(struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\n\tASSERT_RTNL();\n\n\tif ((dev->type != ARPHRD_ETHER) &&\n\t    (dev->type != ARPHRD_FDDI) &&\n\t    (dev->type != ARPHRD_ARCNET) &&\n\t    (dev->type != ARPHRD_INFINIBAND) &&\n\t    (dev->type != ARPHRD_IEEE1394) &&\n\t    (dev->type != ARPHRD_TUNNEL6) &&\n\t    (dev->type != ARPHRD_6LOWPAN) &&\n\t    (dev->type != ARPHRD_TUNNEL) &&\n\t    (dev->type != ARPHRD_NONE) &&\n\t    (dev->type != ARPHRD_RAWIP)) {\n\t\t \n\t\tidev = __in6_dev_get(dev);\n\t\tif (!IS_ERR_OR_NULL(idev) && dev->flags & IFF_UP &&\n\t\t    dev->flags & IFF_MULTICAST)\n\t\t\tipv6_mc_up(idev);\n\t\treturn;\n\t}\n\n\tidev = addrconf_add_dev(dev);\n\tif (IS_ERR(idev))\n\t\treturn;\n\n\t \n\tif (dev->type == ARPHRD_NONE &&\n\t    idev->cnf.addr_gen_mode == IN6_ADDR_GEN_MODE_EUI64)\n\t\tidev->cnf.addr_gen_mode = IN6_ADDR_GEN_MODE_RANDOM;\n\n\taddrconf_addr_gen(idev, false);\n}\n\n#if IS_ENABLED(CONFIG_IPV6_SIT)\nstatic void addrconf_sit_config(struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\n\tASSERT_RTNL();\n\n\t \n\n\tidev = ipv6_find_idev(dev);\n\tif (IS_ERR(idev)) {\n\t\tpr_debug(\"%s: add_dev failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (dev->priv_flags & IFF_ISATAP) {\n\t\taddrconf_addr_gen(idev, false);\n\t\treturn;\n\t}\n\n\tadd_v4_addrs(idev);\n\n\tif (dev->flags&IFF_POINTOPOINT)\n\t\taddrconf_add_mroute(dev);\n}\n#endif\n\n#if IS_ENABLED(CONFIG_NET_IPGRE) || IS_ENABLED(CONFIG_IPV6_GRE)\nstatic void addrconf_gre_config(struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\n\tASSERT_RTNL();\n\n\tidev = ipv6_find_idev(dev);\n\tif (IS_ERR(idev)) {\n\t\tpr_debug(\"%s: add_dev failed\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (dev->type == ARPHRD_ETHER) {\n\t\taddrconf_addr_gen(idev, true);\n\t\treturn;\n\t}\n\n\tadd_v4_addrs(idev);\n\n\tif (dev->flags & IFF_POINTOPOINT)\n\t\taddrconf_add_mroute(dev);\n}\n#endif\n\nstatic void addrconf_init_auto_addrs(struct net_device *dev)\n{\n\tswitch (dev->type) {\n#if IS_ENABLED(CONFIG_IPV6_SIT)\n\tcase ARPHRD_SIT:\n\t\taddrconf_sit_config(dev);\n\t\tbreak;\n#endif\n#if IS_ENABLED(CONFIG_NET_IPGRE) || IS_ENABLED(CONFIG_IPV6_GRE)\n\tcase ARPHRD_IP6GRE:\n\tcase ARPHRD_IPGRE:\n\t\taddrconf_gre_config(dev);\n\t\tbreak;\n#endif\n\tcase ARPHRD_LOOPBACK:\n\t\tinit_loopback(dev);\n\t\tbreak;\n\n\tdefault:\n\t\taddrconf_dev_config(dev);\n\t\tbreak;\n\t}\n}\n\nstatic int fixup_permanent_addr(struct net *net,\n\t\t\t\tstruct inet6_dev *idev,\n\t\t\t\tstruct inet6_ifaddr *ifp)\n{\n\t \n\tif (!ifp->rt || !ifp->rt->fib6_node) {\n\t\tstruct fib6_info *f6i, *prev;\n\n\t\tf6i = addrconf_f6i_alloc(net, idev, &ifp->addr, false,\n\t\t\t\t\t GFP_ATOMIC, NULL);\n\t\tif (IS_ERR(f6i))\n\t\t\treturn PTR_ERR(f6i);\n\n\t\t \n\t\tspin_lock(&ifp->lock);\n\t\tprev = ifp->rt;\n\t\tifp->rt = f6i;\n\t\tspin_unlock(&ifp->lock);\n\n\t\tfib6_info_release(prev);\n\t}\n\n\tif (!(ifp->flags & IFA_F_NOPREFIXROUTE)) {\n\t\taddrconf_prefix_route(&ifp->addr, ifp->prefix_len,\n\t\t\t\t      ifp->rt_priority, idev->dev, 0, 0,\n\t\t\t\t      GFP_ATOMIC);\n\t}\n\n\tif (ifp->state == INET6_IFADDR_STATE_PREDAD)\n\t\taddrconf_dad_start(ifp);\n\n\treturn 0;\n}\n\nstatic void addrconf_permanent_addr(struct net *net, struct net_device *dev)\n{\n\tstruct inet6_ifaddr *ifp, *tmp;\n\tstruct inet6_dev *idev;\n\n\tidev = __in6_dev_get(dev);\n\tif (!idev)\n\t\treturn;\n\n\twrite_lock_bh(&idev->lock);\n\n\tlist_for_each_entry_safe(ifp, tmp, &idev->addr_list, if_list) {\n\t\tif ((ifp->flags & IFA_F_PERMANENT) &&\n\t\t    fixup_permanent_addr(net, idev, ifp) < 0) {\n\t\t\twrite_unlock_bh(&idev->lock);\n\t\t\tin6_ifa_hold(ifp);\n\t\t\tipv6_del_addr(ifp);\n\t\t\twrite_lock_bh(&idev->lock);\n\n\t\t\tnet_info_ratelimited(\"%s: Failed to add prefix route for address %pI6c; dropping\\n\",\n\t\t\t\t\t     idev->dev->name, &ifp->addr);\n\t\t}\n\t}\n\n\twrite_unlock_bh(&idev->lock);\n}\n\nstatic int addrconf_notify(struct notifier_block *this, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_change_info *change_info;\n\tstruct netdev_notifier_changeupper_info *info;\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\tstruct net *net = dev_net(dev);\n\tint run_pending = 0;\n\tint err;\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\tif (!idev && dev->mtu >= IPV6_MIN_MTU) {\n\t\t\tidev = ipv6_add_dev(dev);\n\t\t\tif (IS_ERR(idev))\n\t\t\t\treturn notifier_from_errno(PTR_ERR(idev));\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_CHANGEMTU:\n\t\t \n\t\tif (dev->mtu < IPV6_MIN_MTU) {\n\t\t\taddrconf_ifdown(dev, dev != net->loopback_dev);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (idev) {\n\t\t\trt6_mtu_change(dev, dev->mtu);\n\t\t\tidev->cnf.mtu6 = dev->mtu;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tidev = ipv6_add_dev(dev);\n\t\tif (IS_ERR(idev))\n\t\t\tbreak;\n\n\t\t \n\t\tif (!(idev->if_flags & IF_READY))\n\t\t\tbreak;\n\n\t\trun_pending = 1;\n\t\tfallthrough;\n\tcase NETDEV_UP:\n\tcase NETDEV_CHANGE:\n\t\tif (idev && idev->cnf.disable_ipv6)\n\t\t\tbreak;\n\n\t\tif (dev->priv_flags & IFF_NO_ADDRCONF) {\n\t\t\tif (event == NETDEV_UP && !IS_ERR_OR_NULL(idev) &&\n\t\t\t    dev->flags & IFF_UP && dev->flags & IFF_MULTICAST)\n\t\t\t\tipv6_mc_up(idev);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (event == NETDEV_UP) {\n\t\t\t \n\t\t\taddrconf_permanent_addr(net, dev);\n\n\t\t\tif (!addrconf_link_ready(dev)) {\n\t\t\t\t \n\t\t\t\tpr_debug(\"ADDRCONF(NETDEV_UP): %s: link is not ready\\n\",\n\t\t\t\t\t dev->name);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!idev && dev->mtu >= IPV6_MIN_MTU)\n\t\t\t\tidev = ipv6_add_dev(dev);\n\n\t\t\tif (!IS_ERR_OR_NULL(idev)) {\n\t\t\t\tidev->if_flags |= IF_READY;\n\t\t\t\trun_pending = 1;\n\t\t\t}\n\t\t} else if (event == NETDEV_CHANGE) {\n\t\t\tif (!addrconf_link_ready(dev)) {\n\t\t\t\t \n\t\t\t\trt6_sync_down_dev(dev, event);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!IS_ERR_OR_NULL(idev)) {\n\t\t\t\tif (idev->if_flags & IF_READY) {\n\t\t\t\t\t \n\t\t\t\t\tipv6_mc_up(idev);\n\t\t\t\t\tchange_info = ptr;\n\t\t\t\t\tif (change_info->flags_changed & IFF_NOARP)\n\t\t\t\t\t\taddrconf_dad_run(idev, true);\n\t\t\t\t\trt6_sync_up(dev, RTNH_F_LINKDOWN);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tidev->if_flags |= IF_READY;\n\t\t\t}\n\n\t\t\tpr_debug(\"ADDRCONF(NETDEV_CHANGE): %s: link becomes ready\\n\",\n\t\t\t\t dev->name);\n\n\t\t\trun_pending = 1;\n\t\t}\n\n\t\taddrconf_init_auto_addrs(dev);\n\n\t\tif (!IS_ERR_OR_NULL(idev)) {\n\t\t\tif (run_pending)\n\t\t\t\taddrconf_dad_run(idev, false);\n\n\t\t\t \n\t\t\trt6_sync_up(dev, RTNH_F_DEAD);\n\n\t\t\t \n\t\t\tif (idev->cnf.mtu6 != dev->mtu &&\n\t\t\t    dev->mtu >= IPV6_MIN_MTU) {\n\t\t\t\trt6_mtu_change(dev, dev->mtu);\n\t\t\t\tidev->cnf.mtu6 = dev->mtu;\n\t\t\t}\n\t\t\tidev->tstamp = jiffies;\n\t\t\tinet6_ifinfo_notify(RTM_NEWLINK, idev);\n\n\t\t\t \n\t\t\tif (dev->mtu < IPV6_MIN_MTU)\n\t\t\t\taddrconf_ifdown(dev, dev != net->loopback_dev);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\tcase NETDEV_UNREGISTER:\n\t\t \n\t\taddrconf_ifdown(dev, event != NETDEV_DOWN);\n\t\tbreak;\n\n\tcase NETDEV_CHANGENAME:\n\t\tif (idev) {\n\t\t\tsnmp6_unregister_dev(idev);\n\t\t\taddrconf_sysctl_unregister(idev);\n\t\t\terr = addrconf_sysctl_register(idev);\n\t\t\tif (err)\n\t\t\t\treturn notifier_from_errno(err);\n\t\t\terr = snmp6_register_dev(idev);\n\t\t\tif (err) {\n\t\t\t\taddrconf_sysctl_unregister(idev);\n\t\t\t\treturn notifier_from_errno(err);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\tcase NETDEV_POST_TYPE_CHANGE:\n\t\tif (idev)\n\t\t\taddrconf_type_change(dev, event);\n\t\tbreak;\n\n\tcase NETDEV_CHANGEUPPER:\n\t\tinfo = ptr;\n\n\t\t \n\t\tif (info->upper_dev && netif_is_l3_master(info->upper_dev))\n\t\t\taddrconf_ifdown(dev, false);\n\t}\n\n\treturn NOTIFY_OK;\n}\n\n \nstatic struct notifier_block ipv6_dev_notf = {\n\t.notifier_call = addrconf_notify,\n\t.priority = ADDRCONF_NOTIFY_PRIORITY,\n};\n\nstatic void addrconf_type_change(struct net_device *dev, unsigned long event)\n{\n\tstruct inet6_dev *idev;\n\tASSERT_RTNL();\n\n\tidev = __in6_dev_get(dev);\n\n\tif (event == NETDEV_POST_TYPE_CHANGE)\n\t\tipv6_mc_remap(idev);\n\telse if (event == NETDEV_PRE_TYPE_CHANGE)\n\t\tipv6_mc_unmap(idev);\n}\n\nstatic bool addr_is_local(const struct in6_addr *addr)\n{\n\treturn ipv6_addr_type(addr) &\n\t\t(IPV6_ADDR_LINKLOCAL | IPV6_ADDR_LOOPBACK);\n}\n\nstatic int addrconf_ifdown(struct net_device *dev, bool unregister)\n{\n\tunsigned long event = unregister ? NETDEV_UNREGISTER : NETDEV_DOWN;\n\tstruct net *net = dev_net(dev);\n\tstruct inet6_dev *idev;\n\tstruct inet6_ifaddr *ifa;\n\tLIST_HEAD(tmp_addr_list);\n\tbool keep_addr = false;\n\tbool was_ready;\n\tint state, i;\n\n\tASSERT_RTNL();\n\n\trt6_disable_ip(dev, event);\n\n\tidev = __in6_dev_get(dev);\n\tif (!idev)\n\t\treturn -ENODEV;\n\n\t \n\tif (unregister) {\n\t\tidev->dead = 1;\n\n\t\t \n\t\tRCU_INIT_POINTER(dev->ip6_ptr, NULL);\n\n\t\t \n\t\tsnmp6_unregister_dev(idev);\n\n\t}\n\n\t \n\tif (!unregister && !idev->cnf.disable_ipv6) {\n\t\t \n\t\tint _keep_addr = net->ipv6.devconf_all->keep_addr_on_down;\n\n\t\tif (!_keep_addr)\n\t\t\t_keep_addr = idev->cnf.keep_addr_on_down;\n\n\t\tkeep_addr = (_keep_addr > 0);\n\t}\n\n\t \n\tfor (i = 0; i < IN6_ADDR_HSIZE; i++) {\n\t\tstruct hlist_head *h = &net->ipv6.inet6_addr_lst[i];\n\n\t\tspin_lock_bh(&net->ipv6.addrconf_hash_lock);\nrestart:\n\t\thlist_for_each_entry_rcu(ifa, h, addr_lst) {\n\t\t\tif (ifa->idev == idev) {\n\t\t\t\taddrconf_del_dad_work(ifa);\n\t\t\t\t \n\t\t\t\tif (!keep_addr ||\n\t\t\t\t    !(ifa->flags & IFA_F_PERMANENT) ||\n\t\t\t\t    addr_is_local(&ifa->addr)) {\n\t\t\t\t\thlist_del_init_rcu(&ifa->addr_lst);\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&net->ipv6.addrconf_hash_lock);\n\t}\n\n\twrite_lock_bh(&idev->lock);\n\n\taddrconf_del_rs_timer(idev);\n\n\t \n\twas_ready = idev->if_flags & IF_READY;\n\tif (!unregister)\n\t\tidev->if_flags &= ~(IF_RS_SENT|IF_RA_RCVD|IF_READY);\n\n\t \n\twhile (!list_empty(&idev->tempaddr_list)) {\n\t\tifa = list_first_entry(&idev->tempaddr_list,\n\t\t\t\t       struct inet6_ifaddr, tmp_list);\n\t\tlist_del(&ifa->tmp_list);\n\t\twrite_unlock_bh(&idev->lock);\n\t\tspin_lock_bh(&ifa->lock);\n\n\t\tif (ifa->ifpub) {\n\t\t\tin6_ifa_put(ifa->ifpub);\n\t\t\tifa->ifpub = NULL;\n\t\t}\n\t\tspin_unlock_bh(&ifa->lock);\n\t\tin6_ifa_put(ifa);\n\t\twrite_lock_bh(&idev->lock);\n\t}\n\n\tlist_for_each_entry(ifa, &idev->addr_list, if_list)\n\t\tlist_add_tail(&ifa->if_list_aux, &tmp_addr_list);\n\twrite_unlock_bh(&idev->lock);\n\n\twhile (!list_empty(&tmp_addr_list)) {\n\t\tstruct fib6_info *rt = NULL;\n\t\tbool keep;\n\n\t\tifa = list_first_entry(&tmp_addr_list,\n\t\t\t\t       struct inet6_ifaddr, if_list_aux);\n\t\tlist_del(&ifa->if_list_aux);\n\n\t\taddrconf_del_dad_work(ifa);\n\n\t\tkeep = keep_addr && (ifa->flags & IFA_F_PERMANENT) &&\n\t\t\t!addr_is_local(&ifa->addr);\n\n\t\tspin_lock_bh(&ifa->lock);\n\n\t\tif (keep) {\n\t\t\t \n\t\t\tstate = INET6_IFADDR_STATE_DEAD;\n\t\t\tifa->state = INET6_IFADDR_STATE_PREDAD;\n\t\t\tif (!(ifa->flags & IFA_F_NODAD))\n\t\t\t\tifa->flags |= IFA_F_TENTATIVE;\n\n\t\t\trt = ifa->rt;\n\t\t\tifa->rt = NULL;\n\t\t} else {\n\t\t\tstate = ifa->state;\n\t\t\tifa->state = INET6_IFADDR_STATE_DEAD;\n\t\t}\n\n\t\tspin_unlock_bh(&ifa->lock);\n\n\t\tif (rt)\n\t\t\tip6_del_rt(net, rt, false);\n\n\t\tif (state != INET6_IFADDR_STATE_DEAD) {\n\t\t\t__ipv6_ifa_notify(RTM_DELADDR, ifa);\n\t\t\tinet6addr_notifier_call_chain(NETDEV_DOWN, ifa);\n\t\t} else {\n\t\t\tif (idev->cnf.forwarding)\n\t\t\t\taddrconf_leave_anycast(ifa);\n\t\t\taddrconf_leave_solict(ifa->idev, &ifa->addr);\n\t\t}\n\n\t\tif (!keep) {\n\t\t\twrite_lock_bh(&idev->lock);\n\t\t\tlist_del_rcu(&ifa->if_list);\n\t\t\twrite_unlock_bh(&idev->lock);\n\t\t\tin6_ifa_put(ifa);\n\t\t}\n\t}\n\n\t \n\tif (unregister) {\n\t\tipv6_ac_destroy_dev(idev);\n\t\tipv6_mc_destroy_dev(idev);\n\t} else if (was_ready) {\n\t\tipv6_mc_down(idev);\n\t}\n\n\tidev->tstamp = jiffies;\n\tidev->ra_mtu = 0;\n\n\t \n\tif (unregister) {\n\t\taddrconf_sysctl_unregister(idev);\n\t\tneigh_parms_release(&nd_tbl, idev->nd_parms);\n\t\tneigh_ifdown(&nd_tbl, dev);\n\t\tin6_dev_put(idev);\n\t}\n\treturn 0;\n}\n\nstatic void addrconf_rs_timer(struct timer_list *t)\n{\n\tstruct inet6_dev *idev = from_timer(idev, t, rs_timer);\n\tstruct net_device *dev = idev->dev;\n\tstruct in6_addr lladdr;\n\n\twrite_lock(&idev->lock);\n\tif (idev->dead || !(idev->if_flags & IF_READY))\n\t\tgoto out;\n\n\tif (!ipv6_accept_ra(idev))\n\t\tgoto out;\n\n\t \n\tif (idev->if_flags & IF_RA_RCVD)\n\t\tgoto out;\n\n\tif (idev->rs_probes++ < idev->cnf.rtr_solicits || idev->cnf.rtr_solicits < 0) {\n\t\twrite_unlock(&idev->lock);\n\t\tif (!ipv6_get_lladdr(dev, &lladdr, IFA_F_TENTATIVE))\n\t\t\tndisc_send_rs(dev, &lladdr,\n\t\t\t\t      &in6addr_linklocal_allrouters);\n\t\telse\n\t\t\tgoto put;\n\n\t\twrite_lock(&idev->lock);\n\t\tidev->rs_interval = rfc3315_s14_backoff_update(\n\t\t\tidev->rs_interval, idev->cnf.rtr_solicit_max_interval);\n\t\t \n\t\taddrconf_mod_rs_timer(idev, (idev->rs_probes ==\n\t\t\t\t\t     idev->cnf.rtr_solicits) ?\n\t\t\t\t      idev->cnf.rtr_solicit_delay :\n\t\t\t\t      idev->rs_interval);\n\t} else {\n\t\t \n\t\tpr_debug(\"%s: no IPv6 routers present\\n\", idev->dev->name);\n\t}\n\nout:\n\twrite_unlock(&idev->lock);\nput:\n\tin6_dev_put(idev);\n}\n\n \nstatic void addrconf_dad_kick(struct inet6_ifaddr *ifp)\n{\n\tunsigned long rand_num;\n\tstruct inet6_dev *idev = ifp->idev;\n\tu64 nonce;\n\n\tif (ifp->flags & IFA_F_OPTIMISTIC)\n\t\trand_num = 0;\n\telse\n\t\trand_num = get_random_u32_below(idev->cnf.rtr_solicit_delay ? : 1);\n\n\tnonce = 0;\n\tif (idev->cnf.enhanced_dad ||\n\t    dev_net(idev->dev)->ipv6.devconf_all->enhanced_dad) {\n\t\tdo\n\t\t\tget_random_bytes(&nonce, 6);\n\t\twhile (nonce == 0);\n\t}\n\tifp->dad_nonce = nonce;\n\tifp->dad_probes = idev->cnf.dad_transmits;\n\taddrconf_mod_dad_work(ifp, rand_num);\n}\n\nstatic void addrconf_dad_begin(struct inet6_ifaddr *ifp)\n{\n\tstruct inet6_dev *idev = ifp->idev;\n\tstruct net_device *dev = idev->dev;\n\tbool bump_id, notify = false;\n\tstruct net *net;\n\n\taddrconf_join_solict(dev, &ifp->addr);\n\n\tread_lock_bh(&idev->lock);\n\tspin_lock(&ifp->lock);\n\tif (ifp->state == INET6_IFADDR_STATE_DEAD)\n\t\tgoto out;\n\n\tnet = dev_net(dev);\n\tif (dev->flags&(IFF_NOARP|IFF_LOOPBACK) ||\n\t    (net->ipv6.devconf_all->accept_dad < 1 &&\n\t     idev->cnf.accept_dad < 1) ||\n\t    !(ifp->flags&IFA_F_TENTATIVE) ||\n\t    ifp->flags & IFA_F_NODAD) {\n\t\tbool send_na = false;\n\n\t\tif (ifp->flags & IFA_F_TENTATIVE &&\n\t\t    !(ifp->flags & IFA_F_OPTIMISTIC))\n\t\t\tsend_na = true;\n\t\tbump_id = ifp->flags & IFA_F_TENTATIVE;\n\t\tifp->flags &= ~(IFA_F_TENTATIVE|IFA_F_OPTIMISTIC|IFA_F_DADFAILED);\n\t\tspin_unlock(&ifp->lock);\n\t\tread_unlock_bh(&idev->lock);\n\n\t\taddrconf_dad_completed(ifp, bump_id, send_na);\n\t\treturn;\n\t}\n\n\tif (!(idev->if_flags & IF_READY)) {\n\t\tspin_unlock(&ifp->lock);\n\t\tread_unlock_bh(&idev->lock);\n\t\t \n\t\tin6_ifa_hold(ifp);\n\t\taddrconf_dad_stop(ifp, 0);\n\t\treturn;\n\t}\n\n\t \n\tif (ifp->flags & IFA_F_OPTIMISTIC) {\n\t\tip6_ins_rt(net, ifp->rt);\n\t\tif (ipv6_use_optimistic_addr(net, idev)) {\n\t\t\t \n\t\t\tnotify = true;\n\t\t}\n\t}\n\n\taddrconf_dad_kick(ifp);\nout:\n\tspin_unlock(&ifp->lock);\n\tread_unlock_bh(&idev->lock);\n\tif (notify)\n\t\tipv6_ifa_notify(RTM_NEWADDR, ifp);\n}\n\nstatic void addrconf_dad_start(struct inet6_ifaddr *ifp)\n{\n\tbool begin_dad = false;\n\n\tspin_lock_bh(&ifp->lock);\n\tif (ifp->state != INET6_IFADDR_STATE_DEAD) {\n\t\tifp->state = INET6_IFADDR_STATE_PREDAD;\n\t\tbegin_dad = true;\n\t}\n\tspin_unlock_bh(&ifp->lock);\n\n\tif (begin_dad)\n\t\taddrconf_mod_dad_work(ifp, 0);\n}\n\nstatic void addrconf_dad_work(struct work_struct *w)\n{\n\tstruct inet6_ifaddr *ifp = container_of(to_delayed_work(w),\n\t\t\t\t\t\tstruct inet6_ifaddr,\n\t\t\t\t\t\tdad_work);\n\tstruct inet6_dev *idev = ifp->idev;\n\tbool bump_id, disable_ipv6 = false;\n\tstruct in6_addr mcaddr;\n\n\tenum {\n\t\tDAD_PROCESS,\n\t\tDAD_BEGIN,\n\t\tDAD_ABORT,\n\t} action = DAD_PROCESS;\n\n\trtnl_lock();\n\n\tspin_lock_bh(&ifp->lock);\n\tif (ifp->state == INET6_IFADDR_STATE_PREDAD) {\n\t\taction = DAD_BEGIN;\n\t\tifp->state = INET6_IFADDR_STATE_DAD;\n\t} else if (ifp->state == INET6_IFADDR_STATE_ERRDAD) {\n\t\taction = DAD_ABORT;\n\t\tifp->state = INET6_IFADDR_STATE_POSTDAD;\n\n\t\tif ((dev_net(idev->dev)->ipv6.devconf_all->accept_dad > 1 ||\n\t\t     idev->cnf.accept_dad > 1) &&\n\t\t    !idev->cnf.disable_ipv6 &&\n\t\t    !(ifp->flags & IFA_F_STABLE_PRIVACY)) {\n\t\t\tstruct in6_addr addr;\n\n\t\t\taddr.s6_addr32[0] = htonl(0xfe800000);\n\t\t\taddr.s6_addr32[1] = 0;\n\n\t\t\tif (!ipv6_generate_eui64(addr.s6_addr + 8, idev->dev) &&\n\t\t\t    ipv6_addr_equal(&ifp->addr, &addr)) {\n\t\t\t\t \n\t\t\t\tidev->cnf.disable_ipv6 = 1;\n\n\t\t\t\tpr_info(\"%s: IPv6 being disabled!\\n\",\n\t\t\t\t\tifp->idev->dev->name);\n\t\t\t\tdisable_ipv6 = true;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&ifp->lock);\n\n\tif (action == DAD_BEGIN) {\n\t\taddrconf_dad_begin(ifp);\n\t\tgoto out;\n\t} else if (action == DAD_ABORT) {\n\t\tin6_ifa_hold(ifp);\n\t\taddrconf_dad_stop(ifp, 1);\n\t\tif (disable_ipv6)\n\t\t\taddrconf_ifdown(idev->dev, false);\n\t\tgoto out;\n\t}\n\n\tif (!ifp->dad_probes && addrconf_dad_end(ifp))\n\t\tgoto out;\n\n\twrite_lock_bh(&idev->lock);\n\tif (idev->dead || !(idev->if_flags & IF_READY)) {\n\t\twrite_unlock_bh(&idev->lock);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&ifp->lock);\n\tif (ifp->state == INET6_IFADDR_STATE_DEAD) {\n\t\tspin_unlock(&ifp->lock);\n\t\twrite_unlock_bh(&idev->lock);\n\t\tgoto out;\n\t}\n\n\tif (ifp->dad_probes == 0) {\n\t\tbool send_na = false;\n\n\t\t \n\n\t\tif (ifp->flags & IFA_F_TENTATIVE &&\n\t\t    !(ifp->flags & IFA_F_OPTIMISTIC))\n\t\t\tsend_na = true;\n\t\tbump_id = ifp->flags & IFA_F_TENTATIVE;\n\t\tifp->flags &= ~(IFA_F_TENTATIVE|IFA_F_OPTIMISTIC|IFA_F_DADFAILED);\n\t\tspin_unlock(&ifp->lock);\n\t\twrite_unlock_bh(&idev->lock);\n\n\t\taddrconf_dad_completed(ifp, bump_id, send_na);\n\n\t\tgoto out;\n\t}\n\n\tifp->dad_probes--;\n\taddrconf_mod_dad_work(ifp,\n\t\t\t      max(NEIGH_VAR(ifp->idev->nd_parms, RETRANS_TIME),\n\t\t\t\t  HZ/100));\n\tspin_unlock(&ifp->lock);\n\twrite_unlock_bh(&idev->lock);\n\n\t \n\taddrconf_addr_solict_mult(&ifp->addr, &mcaddr);\n\tndisc_send_ns(ifp->idev->dev, &ifp->addr, &mcaddr, &in6addr_any,\n\t\t      ifp->dad_nonce);\nout:\n\tin6_ifa_put(ifp);\n\trtnl_unlock();\n}\n\n \nstatic bool ipv6_lonely_lladdr(struct inet6_ifaddr *ifp)\n{\n\tstruct inet6_ifaddr *ifpiter;\n\tstruct inet6_dev *idev = ifp->idev;\n\n\tlist_for_each_entry_reverse(ifpiter, &idev->addr_list, if_list) {\n\t\tif (ifpiter->scope > IFA_LINK)\n\t\t\tbreak;\n\t\tif (ifp != ifpiter && ifpiter->scope == IFA_LINK &&\n\t\t    (ifpiter->flags & (IFA_F_PERMANENT|IFA_F_TENTATIVE|\n\t\t\t\t       IFA_F_OPTIMISTIC|IFA_F_DADFAILED)) ==\n\t\t    IFA_F_PERMANENT)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void addrconf_dad_completed(struct inet6_ifaddr *ifp, bool bump_id,\n\t\t\t\t   bool send_na)\n{\n\tstruct net_device *dev = ifp->idev->dev;\n\tstruct in6_addr lladdr;\n\tbool send_rs, send_mld;\n\n\taddrconf_del_dad_work(ifp);\n\n\t \n\n\tipv6_ifa_notify(RTM_NEWADDR, ifp);\n\n\t \n\n\tread_lock_bh(&ifp->idev->lock);\n\tsend_mld = ifp->scope == IFA_LINK && ipv6_lonely_lladdr(ifp);\n\tsend_rs = send_mld &&\n\t\t  ipv6_accept_ra(ifp->idev) &&\n\t\t  ifp->idev->cnf.rtr_solicits != 0 &&\n\t\t  (dev->flags & IFF_LOOPBACK) == 0 &&\n\t\t  (dev->type != ARPHRD_TUNNEL) &&\n\t\t  !netif_is_team_port(dev);\n\tread_unlock_bh(&ifp->idev->lock);\n\n\t \n\tif (send_mld)\n\t\tipv6_mc_dad_complete(ifp->idev);\n\n\t \n\tif (send_na &&\n\t    (ifp->idev->cnf.ndisc_notify ||\n\t     dev_net(dev)->ipv6.devconf_all->ndisc_notify)) {\n\t\tndisc_send_na(dev, &in6addr_linklocal_allnodes, &ifp->addr,\n\t\t\t        !!ifp->idev->cnf.forwarding,\n\t\t\t        false,   true,\n\t\t\t        true);\n\t}\n\n\tif (send_rs) {\n\t\t \n\t\tif (ipv6_get_lladdr(dev, &lladdr, IFA_F_TENTATIVE))\n\t\t\treturn;\n\t\tndisc_send_rs(dev, &lladdr, &in6addr_linklocal_allrouters);\n\n\t\twrite_lock_bh(&ifp->idev->lock);\n\t\tspin_lock(&ifp->lock);\n\t\tifp->idev->rs_interval = rfc3315_s14_backoff_init(\n\t\t\tifp->idev->cnf.rtr_solicit_interval);\n\t\tifp->idev->rs_probes = 1;\n\t\tifp->idev->if_flags |= IF_RS_SENT;\n\t\taddrconf_mod_rs_timer(ifp->idev, ifp->idev->rs_interval);\n\t\tspin_unlock(&ifp->lock);\n\t\twrite_unlock_bh(&ifp->idev->lock);\n\t}\n\n\tif (bump_id)\n\t\trt_genid_bump_ipv6(dev_net(dev));\n\n\t \n\tif (ifp->flags & IFA_F_TEMPORARY)\n\t\taddrconf_verify_rtnl(dev_net(dev));\n}\n\nstatic void addrconf_dad_run(struct inet6_dev *idev, bool restart)\n{\n\tstruct inet6_ifaddr *ifp;\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifp, &idev->addr_list, if_list) {\n\t\tspin_lock(&ifp->lock);\n\t\tif ((ifp->flags & IFA_F_TENTATIVE &&\n\t\t     ifp->state == INET6_IFADDR_STATE_DAD) || restart) {\n\t\t\tif (restart)\n\t\t\t\tifp->state = INET6_IFADDR_STATE_PREDAD;\n\t\t\taddrconf_dad_kick(ifp);\n\t\t}\n\t\tspin_unlock(&ifp->lock);\n\t}\n\tread_unlock_bh(&idev->lock);\n}\n\n#ifdef CONFIG_PROC_FS\nstruct if6_iter_state {\n\tstruct seq_net_private p;\n\tint bucket;\n\tint offset;\n};\n\nstatic struct inet6_ifaddr *if6_get_first(struct seq_file *seq, loff_t pos)\n{\n\tstruct if6_iter_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct inet6_ifaddr *ifa = NULL;\n\tint p = 0;\n\n\t \n\tif (pos == 0) {\n\t\tstate->bucket = 0;\n\t\tstate->offset = 0;\n\t}\n\n\tfor (; state->bucket < IN6_ADDR_HSIZE; ++state->bucket) {\n\t\thlist_for_each_entry_rcu(ifa, &net->ipv6.inet6_addr_lst[state->bucket],\n\t\t\t\t\t addr_lst) {\n\t\t\t \n\t\t\tif (p < state->offset) {\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn ifa;\n\t\t}\n\n\t\t \n\t\tstate->offset = 0;\n\t\tp = 0;\n\t}\n\treturn NULL;\n}\n\nstatic struct inet6_ifaddr *if6_get_next(struct seq_file *seq,\n\t\t\t\t\t struct inet6_ifaddr *ifa)\n{\n\tstruct if6_iter_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\n\thlist_for_each_entry_continue_rcu(ifa, addr_lst) {\n\t\tstate->offset++;\n\t\treturn ifa;\n\t}\n\n\tstate->offset = 0;\n\twhile (++state->bucket < IN6_ADDR_HSIZE) {\n\t\thlist_for_each_entry_rcu(ifa,\n\t\t\t\t     &net->ipv6.inet6_addr_lst[state->bucket], addr_lst) {\n\t\t\treturn ifa;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void *if6_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn if6_get_first(seq, *pos);\n}\n\nstatic void *if6_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct inet6_ifaddr *ifa;\n\n\tifa = if6_get_next(seq, v);\n\t++*pos;\n\treturn ifa;\n}\n\nstatic void if6_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic int if6_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct inet6_ifaddr *ifp = (struct inet6_ifaddr *)v;\n\tseq_printf(seq, \"%pi6 %02x %02x %02x %02x %8s\\n\",\n\t\t   &ifp->addr,\n\t\t   ifp->idev->dev->ifindex,\n\t\t   ifp->prefix_len,\n\t\t   ifp->scope,\n\t\t   (u8) ifp->flags,\n\t\t   ifp->idev->dev->name);\n\treturn 0;\n}\n\nstatic const struct seq_operations if6_seq_ops = {\n\t.start\t= if6_seq_start,\n\t.next\t= if6_seq_next,\n\t.show\t= if6_seq_show,\n\t.stop\t= if6_seq_stop,\n};\n\nstatic int __net_init if6_proc_net_init(struct net *net)\n{\n\tif (!proc_create_net(\"if_inet6\", 0444, net->proc_net, &if6_seq_ops,\n\t\t\tsizeof(struct if6_iter_state)))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void __net_exit if6_proc_net_exit(struct net *net)\n{\n\tremove_proc_entry(\"if_inet6\", net->proc_net);\n}\n\nstatic struct pernet_operations if6_proc_net_ops = {\n\t.init = if6_proc_net_init,\n\t.exit = if6_proc_net_exit,\n};\n\nint __init if6_proc_init(void)\n{\n\treturn register_pernet_subsys(&if6_proc_net_ops);\n}\n\nvoid if6_proc_exit(void)\n{\n\tunregister_pernet_subsys(&if6_proc_net_ops);\n}\n#endif\t \n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n \nint ipv6_chk_home_addr(struct net *net, const struct in6_addr *addr)\n{\n\tunsigned int hash = inet6_addr_hash(net, addr);\n\tstruct inet6_ifaddr *ifp = NULL;\n\tint ret = 0;\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(ifp, &net->ipv6.inet6_addr_lst[hash], addr_lst) {\n\t\tif (ipv6_addr_equal(&ifp->addr, addr) &&\n\t\t    (ifp->flags & IFA_F_HOMEADDRESS)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n#endif\n\n \nint ipv6_chk_rpl_srh_loop(struct net *net, const struct in6_addr *segs,\n\t\t\t  unsigned char nsegs)\n{\n\tconst struct in6_addr *addr;\n\tint i, ret = 0, found = 0;\n\tstruct inet6_ifaddr *ifp;\n\tbool separated = false;\n\tunsigned int hash;\n\tbool hash_found;\n\n\trcu_read_lock();\n\tfor (i = 0; i < nsegs; i++) {\n\t\taddr = &segs[i];\n\t\thash = inet6_addr_hash(net, addr);\n\n\t\thash_found = false;\n\t\thlist_for_each_entry_rcu(ifp, &net->ipv6.inet6_addr_lst[hash], addr_lst) {\n\n\t\t\tif (ipv6_addr_equal(&ifp->addr, addr)) {\n\t\t\t\thash_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (hash_found) {\n\t\t\tif (found > 1 && separated) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tseparated = false;\n\t\t\tfound++;\n\t\t} else {\n\t\t\tseparated = true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n \n\nstatic void addrconf_verify_rtnl(struct net *net)\n{\n\tunsigned long now, next, next_sec, next_sched;\n\tstruct inet6_ifaddr *ifp;\n\tint i;\n\n\tASSERT_RTNL();\n\n\trcu_read_lock_bh();\n\tnow = jiffies;\n\tnext = round_jiffies_up(now + ADDR_CHECK_FREQUENCY);\n\n\tcancel_delayed_work(&net->ipv6.addr_chk_work);\n\n\tfor (i = 0; i < IN6_ADDR_HSIZE; i++) {\nrestart:\n\t\thlist_for_each_entry_rcu_bh(ifp, &net->ipv6.inet6_addr_lst[i], addr_lst) {\n\t\t\tunsigned long age;\n\n\t\t\t \n\t\t\tif ((ifp->flags & IFA_F_PERMANENT) &&\n\t\t\t    (ifp->prefered_lft == INFINITY_LIFE_TIME))\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock(&ifp->lock);\n\t\t\t \n\t\t\tage = (now - ifp->tstamp + ADDRCONF_TIMER_FUZZ_MINUS) / HZ;\n\n\t\t\tif ((ifp->flags&IFA_F_TEMPORARY) &&\n\t\t\t    !(ifp->flags&IFA_F_TENTATIVE) &&\n\t\t\t    ifp->prefered_lft != INFINITY_LIFE_TIME &&\n\t\t\t    !ifp->regen_count && ifp->ifpub) {\n\t\t\t\t \n\n\t\t\t\tunsigned long regen_advance = ifp->idev->cnf.regen_max_retry *\n\t\t\t\t\tifp->idev->cnf.dad_transmits *\n\t\t\t\t\tmax(NEIGH_VAR(ifp->idev->nd_parms, RETRANS_TIME), HZ/100) / HZ;\n\n\t\t\t\tif (age + regen_advance >= ifp->prefered_lft) {\n\t\t\t\t\tstruct inet6_ifaddr *ifpub = ifp->ifpub;\n\t\t\t\t\tif (time_before(ifp->tstamp + ifp->prefered_lft * HZ, next))\n\t\t\t\t\t\tnext = ifp->tstamp + ifp->prefered_lft * HZ;\n\n\t\t\t\t\tifp->regen_count++;\n\t\t\t\t\tin6_ifa_hold(ifp);\n\t\t\t\t\tin6_ifa_hold(ifpub);\n\t\t\t\t\tspin_unlock(&ifp->lock);\n\n\t\t\t\t\tspin_lock(&ifpub->lock);\n\t\t\t\t\tifpub->regen_count = 0;\n\t\t\t\t\tspin_unlock(&ifpub->lock);\n\t\t\t\t\trcu_read_unlock_bh();\n\t\t\t\t\tipv6_create_tempaddr(ifpub, true);\n\t\t\t\t\tin6_ifa_put(ifpub);\n\t\t\t\t\tin6_ifa_put(ifp);\n\t\t\t\t\trcu_read_lock_bh();\n\t\t\t\t\tgoto restart;\n\t\t\t\t} else if (time_before(ifp->tstamp + ifp->prefered_lft * HZ - regen_advance * HZ, next))\n\t\t\t\t\tnext = ifp->tstamp + ifp->prefered_lft * HZ - regen_advance * HZ;\n\t\t\t}\n\n\t\t\tif (ifp->valid_lft != INFINITY_LIFE_TIME &&\n\t\t\t    age >= ifp->valid_lft) {\n\t\t\t\tspin_unlock(&ifp->lock);\n\t\t\t\tin6_ifa_hold(ifp);\n\t\t\t\trcu_read_unlock_bh();\n\t\t\t\tipv6_del_addr(ifp);\n\t\t\t\trcu_read_lock_bh();\n\t\t\t\tgoto restart;\n\t\t\t} else if (ifp->prefered_lft == INFINITY_LIFE_TIME) {\n\t\t\t\tspin_unlock(&ifp->lock);\n\t\t\t\tcontinue;\n\t\t\t} else if (age >= ifp->prefered_lft) {\n\t\t\t\t \n\t\t\t\tint deprecate = 0;\n\n\t\t\t\tif (!(ifp->flags&IFA_F_DEPRECATED)) {\n\t\t\t\t\tdeprecate = 1;\n\t\t\t\t\tifp->flags |= IFA_F_DEPRECATED;\n\t\t\t\t}\n\n\t\t\t\tif ((ifp->valid_lft != INFINITY_LIFE_TIME) &&\n\t\t\t\t    (time_before(ifp->tstamp + ifp->valid_lft * HZ, next)))\n\t\t\t\t\tnext = ifp->tstamp + ifp->valid_lft * HZ;\n\n\t\t\t\tspin_unlock(&ifp->lock);\n\n\t\t\t\tif (deprecate) {\n\t\t\t\t\tin6_ifa_hold(ifp);\n\n\t\t\t\t\tipv6_ifa_notify(0, ifp);\n\t\t\t\t\tin6_ifa_put(ifp);\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (time_before(ifp->tstamp + ifp->prefered_lft * HZ, next))\n\t\t\t\t\tnext = ifp->tstamp + ifp->prefered_lft * HZ;\n\t\t\t\tspin_unlock(&ifp->lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tnext_sec = round_jiffies_up(next);\n\tnext_sched = next;\n\n\t \n\tif (time_before(next_sec, next + ADDRCONF_TIMER_FUZZ))\n\t\tnext_sched = next_sec;\n\n\t \n\tif (time_before(next_sched, jiffies + ADDRCONF_TIMER_FUZZ_MAX))\n\t\tnext_sched = jiffies + ADDRCONF_TIMER_FUZZ_MAX;\n\n\tpr_debug(\"now = %lu, schedule = %lu, rounded schedule = %lu => %lu\\n\",\n\t\t now, next, next_sec, next_sched);\n\tmod_delayed_work(addrconf_wq, &net->ipv6.addr_chk_work, next_sched - now);\n\trcu_read_unlock_bh();\n}\n\nstatic void addrconf_verify_work(struct work_struct *w)\n{\n\tstruct net *net = container_of(to_delayed_work(w), struct net,\n\t\t\t\t       ipv6.addr_chk_work);\n\n\trtnl_lock();\n\taddrconf_verify_rtnl(net);\n\trtnl_unlock();\n}\n\nstatic void addrconf_verify(struct net *net)\n{\n\tmod_delayed_work(addrconf_wq, &net->ipv6.addr_chk_work, 0);\n}\n\nstatic struct in6_addr *extract_addr(struct nlattr *addr, struct nlattr *local,\n\t\t\t\t     struct in6_addr **peer_pfx)\n{\n\tstruct in6_addr *pfx = NULL;\n\n\t*peer_pfx = NULL;\n\n\tif (addr)\n\t\tpfx = nla_data(addr);\n\n\tif (local) {\n\t\tif (pfx && nla_memcmp(local, pfx, sizeof(*pfx)))\n\t\t\t*peer_pfx = pfx;\n\t\tpfx = nla_data(local);\n\t}\n\n\treturn pfx;\n}\n\nstatic const struct nla_policy ifa_ipv6_policy[IFA_MAX+1] = {\n\t[IFA_ADDRESS]\t\t= { .len = sizeof(struct in6_addr) },\n\t[IFA_LOCAL]\t\t= { .len = sizeof(struct in6_addr) },\n\t[IFA_CACHEINFO]\t\t= { .len = sizeof(struct ifa_cacheinfo) },\n\t[IFA_FLAGS]\t\t= { .len = sizeof(u32) },\n\t[IFA_RT_PRIORITY]\t= { .len = sizeof(u32) },\n\t[IFA_TARGET_NETNSID]\t= { .type = NLA_S32 },\n\t[IFA_PROTO]\t\t= { .type = NLA_U8 },\n};\n\nstatic int\ninet6_rtm_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifaddrmsg *ifm;\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct in6_addr *pfx, *peer_pfx;\n\tu32 ifa_flags;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFA_MAX,\n\t\t\t\t     ifa_ipv6_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tifm = nlmsg_data(nlh);\n\tpfx = extract_addr(tb[IFA_ADDRESS], tb[IFA_LOCAL], &peer_pfx);\n\tif (!pfx)\n\t\treturn -EINVAL;\n\n\tifa_flags = tb[IFA_FLAGS] ? nla_get_u32(tb[IFA_FLAGS]) : ifm->ifa_flags;\n\n\t \n\tifa_flags &= IFA_F_MANAGETEMPADDR;\n\n\treturn inet6_addr_del(net, ifm->ifa_index, ifa_flags, pfx,\n\t\t\t      ifm->ifa_prefixlen, extack);\n}\n\nstatic int modify_prefix_route(struct inet6_ifaddr *ifp,\n\t\t\t       unsigned long expires, u32 flags,\n\t\t\t       bool modify_peer)\n{\n\tstruct fib6_info *f6i;\n\tu32 prio;\n\n\tf6i = addrconf_get_prefix_route(modify_peer ? &ifp->peer_addr : &ifp->addr,\n\t\t\t\t\tifp->prefix_len,\n\t\t\t\t\tifp->idev->dev, 0, RTF_DEFAULT, true);\n\tif (!f6i)\n\t\treturn -ENOENT;\n\n\tprio = ifp->rt_priority ? : IP6_RT_PRIO_ADDRCONF;\n\tif (f6i->fib6_metric != prio) {\n\t\t \n\t\tip6_del_rt(dev_net(ifp->idev->dev), f6i, false);\n\n\t\t \n\t\taddrconf_prefix_route(modify_peer ? &ifp->peer_addr : &ifp->addr,\n\t\t\t\t      ifp->prefix_len,\n\t\t\t\t      ifp->rt_priority, ifp->idev->dev,\n\t\t\t\t      expires, flags, GFP_KERNEL);\n\t} else {\n\t\tif (!expires)\n\t\t\tfib6_clean_expires(f6i);\n\t\telse\n\t\t\tfib6_set_expires(f6i, expires);\n\n\t\tfib6_info_release(f6i);\n\t}\n\n\treturn 0;\n}\n\nstatic int inet6_addr_modify(struct net *net, struct inet6_ifaddr *ifp,\n\t\t\t     struct ifa6_config *cfg)\n{\n\tu32 flags;\n\tclock_t expires;\n\tunsigned long timeout;\n\tbool was_managetempaddr;\n\tbool had_prefixroute;\n\tbool new_peer = false;\n\n\tASSERT_RTNL();\n\n\tif (!cfg->valid_lft || cfg->preferred_lft > cfg->valid_lft)\n\t\treturn -EINVAL;\n\n\tif (cfg->ifa_flags & IFA_F_MANAGETEMPADDR &&\n\t    (ifp->flags & IFA_F_TEMPORARY || ifp->prefix_len != 64))\n\t\treturn -EINVAL;\n\n\tif (!(ifp->flags & IFA_F_TENTATIVE) || ifp->flags & IFA_F_DADFAILED)\n\t\tcfg->ifa_flags &= ~IFA_F_OPTIMISTIC;\n\n\ttimeout = addrconf_timeout_fixup(cfg->valid_lft, HZ);\n\tif (addrconf_finite_timeout(timeout)) {\n\t\texpires = jiffies_to_clock_t(timeout * HZ);\n\t\tcfg->valid_lft = timeout;\n\t\tflags = RTF_EXPIRES;\n\t} else {\n\t\texpires = 0;\n\t\tflags = 0;\n\t\tcfg->ifa_flags |= IFA_F_PERMANENT;\n\t}\n\n\ttimeout = addrconf_timeout_fixup(cfg->preferred_lft, HZ);\n\tif (addrconf_finite_timeout(timeout)) {\n\t\tif (timeout == 0)\n\t\t\tcfg->ifa_flags |= IFA_F_DEPRECATED;\n\t\tcfg->preferred_lft = timeout;\n\t}\n\n\tif (cfg->peer_pfx &&\n\t    memcmp(&ifp->peer_addr, cfg->peer_pfx, sizeof(struct in6_addr))) {\n\t\tif (!ipv6_addr_any(&ifp->peer_addr))\n\t\t\tcleanup_prefix_route(ifp, expires, true, true);\n\t\tnew_peer = true;\n\t}\n\n\tspin_lock_bh(&ifp->lock);\n\twas_managetempaddr = ifp->flags & IFA_F_MANAGETEMPADDR;\n\thad_prefixroute = ifp->flags & IFA_F_PERMANENT &&\n\t\t\t  !(ifp->flags & IFA_F_NOPREFIXROUTE);\n\tifp->flags &= ~(IFA_F_DEPRECATED | IFA_F_PERMANENT | IFA_F_NODAD |\n\t\t\tIFA_F_HOMEADDRESS | IFA_F_MANAGETEMPADDR |\n\t\t\tIFA_F_NOPREFIXROUTE);\n\tifp->flags |= cfg->ifa_flags;\n\tifp->tstamp = jiffies;\n\tifp->valid_lft = cfg->valid_lft;\n\tifp->prefered_lft = cfg->preferred_lft;\n\tifp->ifa_proto = cfg->ifa_proto;\n\n\tif (cfg->rt_priority && cfg->rt_priority != ifp->rt_priority)\n\t\tifp->rt_priority = cfg->rt_priority;\n\n\tif (new_peer)\n\t\tifp->peer_addr = *cfg->peer_pfx;\n\n\tspin_unlock_bh(&ifp->lock);\n\tif (!(ifp->flags&IFA_F_TENTATIVE))\n\t\tipv6_ifa_notify(0, ifp);\n\n\tif (!(cfg->ifa_flags & IFA_F_NOPREFIXROUTE)) {\n\t\tint rc = -ENOENT;\n\n\t\tif (had_prefixroute)\n\t\t\trc = modify_prefix_route(ifp, expires, flags, false);\n\n\t\t \n\t\tif (rc == -ENOENT) {\n\t\t\taddrconf_prefix_route(&ifp->addr, ifp->prefix_len,\n\t\t\t\t\t      ifp->rt_priority, ifp->idev->dev,\n\t\t\t\t\t      expires, flags, GFP_KERNEL);\n\t\t}\n\n\t\tif (had_prefixroute && !ipv6_addr_any(&ifp->peer_addr))\n\t\t\trc = modify_prefix_route(ifp, expires, flags, true);\n\n\t\tif (rc == -ENOENT && !ipv6_addr_any(&ifp->peer_addr)) {\n\t\t\taddrconf_prefix_route(&ifp->peer_addr, ifp->prefix_len,\n\t\t\t\t\t      ifp->rt_priority, ifp->idev->dev,\n\t\t\t\t\t      expires, flags, GFP_KERNEL);\n\t\t}\n\t} else if (had_prefixroute) {\n\t\tenum cleanup_prefix_rt_t action;\n\t\tunsigned long rt_expires;\n\n\t\twrite_lock_bh(&ifp->idev->lock);\n\t\taction = check_cleanup_prefix_route(ifp, &rt_expires);\n\t\twrite_unlock_bh(&ifp->idev->lock);\n\n\t\tif (action != CLEANUP_PREFIX_RT_NOP) {\n\t\t\tcleanup_prefix_route(ifp, rt_expires,\n\t\t\t\taction == CLEANUP_PREFIX_RT_DEL, false);\n\t\t}\n\t}\n\n\tif (was_managetempaddr || ifp->flags & IFA_F_MANAGETEMPADDR) {\n\t\tif (was_managetempaddr &&\n\t\t    !(ifp->flags & IFA_F_MANAGETEMPADDR)) {\n\t\t\tcfg->valid_lft = 0;\n\t\t\tcfg->preferred_lft = 0;\n\t\t}\n\t\tmanage_tempaddrs(ifp->idev, ifp, cfg->valid_lft,\n\t\t\t\t cfg->preferred_lft, !was_managetempaddr,\n\t\t\t\t jiffies);\n\t}\n\n\taddrconf_verify_rtnl(net);\n\n\treturn 0;\n}\n\nstatic int\ninet6_rtm_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifaddrmsg *ifm;\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct in6_addr *peer_pfx;\n\tstruct inet6_ifaddr *ifa;\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\tstruct ifa6_config cfg;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFA_MAX,\n\t\t\t\t     ifa_ipv6_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\n\tifm = nlmsg_data(nlh);\n\tcfg.pfx = extract_addr(tb[IFA_ADDRESS], tb[IFA_LOCAL], &peer_pfx);\n\tif (!cfg.pfx)\n\t\treturn -EINVAL;\n\n\tcfg.peer_pfx = peer_pfx;\n\tcfg.plen = ifm->ifa_prefixlen;\n\tif (tb[IFA_RT_PRIORITY])\n\t\tcfg.rt_priority = nla_get_u32(tb[IFA_RT_PRIORITY]);\n\n\tif (tb[IFA_PROTO])\n\t\tcfg.ifa_proto = nla_get_u8(tb[IFA_PROTO]);\n\n\tcfg.valid_lft = INFINITY_LIFE_TIME;\n\tcfg.preferred_lft = INFINITY_LIFE_TIME;\n\n\tif (tb[IFA_CACHEINFO]) {\n\t\tstruct ifa_cacheinfo *ci;\n\n\t\tci = nla_data(tb[IFA_CACHEINFO]);\n\t\tcfg.valid_lft = ci->ifa_valid;\n\t\tcfg.preferred_lft = ci->ifa_prefered;\n\t}\n\n\tdev =  __dev_get_by_index(net, ifm->ifa_index);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unable to find the interface\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (tb[IFA_FLAGS])\n\t\tcfg.ifa_flags = nla_get_u32(tb[IFA_FLAGS]);\n\telse\n\t\tcfg.ifa_flags = ifm->ifa_flags;\n\n\t \n\tcfg.ifa_flags &= IFA_F_NODAD | IFA_F_HOMEADDRESS |\n\t\t\t IFA_F_MANAGETEMPADDR | IFA_F_NOPREFIXROUTE |\n\t\t\t IFA_F_MCAUTOJOIN | IFA_F_OPTIMISTIC;\n\n\tidev = ipv6_find_idev(dev);\n\tif (IS_ERR(idev))\n\t\treturn PTR_ERR(idev);\n\n\tif (!ipv6_allow_optimistic_dad(net, idev))\n\t\tcfg.ifa_flags &= ~IFA_F_OPTIMISTIC;\n\n\tif (cfg.ifa_flags & IFA_F_NODAD &&\n\t    cfg.ifa_flags & IFA_F_OPTIMISTIC) {\n\t\tNL_SET_ERR_MSG(extack, \"IFA_F_NODAD and IFA_F_OPTIMISTIC are mutually exclusive\");\n\t\treturn -EINVAL;\n\t}\n\n\tifa = ipv6_get_ifaddr(net, cfg.pfx, dev, 1);\n\tif (!ifa) {\n\t\t \n\t\treturn inet6_addr_add(net, ifm->ifa_index, &cfg, extack);\n\t}\n\n\tif (nlh->nlmsg_flags & NLM_F_EXCL ||\n\t    !(nlh->nlmsg_flags & NLM_F_REPLACE)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"address already assigned\");\n\t\terr = -EEXIST;\n\t} else {\n\t\terr = inet6_addr_modify(net, ifa, &cfg);\n\t}\n\n\tin6_ifa_put(ifa);\n\n\treturn err;\n}\n\nstatic void put_ifaddrmsg(struct nlmsghdr *nlh, u8 prefixlen, u32 flags,\n\t\t\t  u8 scope, int ifindex)\n{\n\tstruct ifaddrmsg *ifm;\n\n\tifm = nlmsg_data(nlh);\n\tifm->ifa_family = AF_INET6;\n\tifm->ifa_prefixlen = prefixlen;\n\tifm->ifa_flags = flags;\n\tifm->ifa_scope = scope;\n\tifm->ifa_index = ifindex;\n}\n\nstatic int put_cacheinfo(struct sk_buff *skb, unsigned long cstamp,\n\t\t\t unsigned long tstamp, u32 preferred, u32 valid)\n{\n\tstruct ifa_cacheinfo ci;\n\n\tci.cstamp = cstamp_delta(cstamp);\n\tci.tstamp = cstamp_delta(tstamp);\n\tci.ifa_prefered = preferred;\n\tci.ifa_valid = valid;\n\n\treturn nla_put(skb, IFA_CACHEINFO, sizeof(ci), &ci);\n}\n\nstatic inline int rt_scope(int ifa_scope)\n{\n\tif (ifa_scope & IFA_HOST)\n\t\treturn RT_SCOPE_HOST;\n\telse if (ifa_scope & IFA_LINK)\n\t\treturn RT_SCOPE_LINK;\n\telse if (ifa_scope & IFA_SITE)\n\t\treturn RT_SCOPE_SITE;\n\telse\n\t\treturn RT_SCOPE_UNIVERSE;\n}\n\nstatic inline int inet6_ifaddr_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifaddrmsg))\n\t       + nla_total_size(16)  \n\t       + nla_total_size(16)  \n\t       + nla_total_size(sizeof(struct ifa_cacheinfo))\n\t       + nla_total_size(4)   \n\t       + nla_total_size(1)   \n\t       + nla_total_size(4)   ;\n}\n\nenum addr_type_t {\n\tUNICAST_ADDR,\n\tMULTICAST_ADDR,\n\tANYCAST_ADDR,\n};\n\nstruct inet6_fill_args {\n\tu32 portid;\n\tu32 seq;\n\tint event;\n\tunsigned int flags;\n\tint netnsid;\n\tint ifindex;\n\tenum addr_type_t type;\n};\n\nstatic int inet6_fill_ifaddr(struct sk_buff *skb, struct inet6_ifaddr *ifa,\n\t\t\t     struct inet6_fill_args *args)\n{\n\tstruct nlmsghdr  *nlh;\n\tu32 preferred, valid;\n\n\tnlh = nlmsg_put(skb, args->portid, args->seq, args->event,\n\t\t\tsizeof(struct ifaddrmsg), args->flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tput_ifaddrmsg(nlh, ifa->prefix_len, ifa->flags, rt_scope(ifa->scope),\n\t\t      ifa->idev->dev->ifindex);\n\n\tif (args->netnsid >= 0 &&\n\t    nla_put_s32(skb, IFA_TARGET_NETNSID, args->netnsid))\n\t\tgoto error;\n\n\tspin_lock_bh(&ifa->lock);\n\tif (!((ifa->flags&IFA_F_PERMANENT) &&\n\t      (ifa->prefered_lft == INFINITY_LIFE_TIME))) {\n\t\tpreferred = ifa->prefered_lft;\n\t\tvalid = ifa->valid_lft;\n\t\tif (preferred != INFINITY_LIFE_TIME) {\n\t\t\tlong tval = (jiffies - ifa->tstamp)/HZ;\n\t\t\tif (preferred > tval)\n\t\t\t\tpreferred -= tval;\n\t\t\telse\n\t\t\t\tpreferred = 0;\n\t\t\tif (valid != INFINITY_LIFE_TIME) {\n\t\t\t\tif (valid > tval)\n\t\t\t\t\tvalid -= tval;\n\t\t\t\telse\n\t\t\t\t\tvalid = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tpreferred = INFINITY_LIFE_TIME;\n\t\tvalid = INFINITY_LIFE_TIME;\n\t}\n\tspin_unlock_bh(&ifa->lock);\n\n\tif (!ipv6_addr_any(&ifa->peer_addr)) {\n\t\tif (nla_put_in6_addr(skb, IFA_LOCAL, &ifa->addr) < 0 ||\n\t\t    nla_put_in6_addr(skb, IFA_ADDRESS, &ifa->peer_addr) < 0)\n\t\t\tgoto error;\n\t} else\n\t\tif (nla_put_in6_addr(skb, IFA_ADDRESS, &ifa->addr) < 0)\n\t\t\tgoto error;\n\n\tif (ifa->rt_priority &&\n\t    nla_put_u32(skb, IFA_RT_PRIORITY, ifa->rt_priority))\n\t\tgoto error;\n\n\tif (put_cacheinfo(skb, ifa->cstamp, ifa->tstamp, preferred, valid) < 0)\n\t\tgoto error;\n\n\tif (nla_put_u32(skb, IFA_FLAGS, ifa->flags) < 0)\n\t\tgoto error;\n\n\tif (ifa->ifa_proto &&\n\t    nla_put_u8(skb, IFA_PROTO, ifa->ifa_proto))\n\t\tgoto error;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nerror:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int inet6_fill_ifmcaddr(struct sk_buff *skb, struct ifmcaddr6 *ifmca,\n\t\t\t       struct inet6_fill_args *args)\n{\n\tstruct nlmsghdr  *nlh;\n\tu8 scope = RT_SCOPE_UNIVERSE;\n\tint ifindex = ifmca->idev->dev->ifindex;\n\n\tif (ipv6_addr_scope(&ifmca->mca_addr) & IFA_SITE)\n\t\tscope = RT_SCOPE_SITE;\n\n\tnlh = nlmsg_put(skb, args->portid, args->seq, args->event,\n\t\t\tsizeof(struct ifaddrmsg), args->flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tif (args->netnsid >= 0 &&\n\t    nla_put_s32(skb, IFA_TARGET_NETNSID, args->netnsid)) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tput_ifaddrmsg(nlh, 128, IFA_F_PERMANENT, scope, ifindex);\n\tif (nla_put_in6_addr(skb, IFA_MULTICAST, &ifmca->mca_addr) < 0 ||\n\t    put_cacheinfo(skb, ifmca->mca_cstamp, ifmca->mca_tstamp,\n\t\t\t  INFINITY_LIFE_TIME, INFINITY_LIFE_TIME) < 0) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int inet6_fill_ifacaddr(struct sk_buff *skb, struct ifacaddr6 *ifaca,\n\t\t\t       struct inet6_fill_args *args)\n{\n\tstruct net_device *dev = fib6_info_nh_dev(ifaca->aca_rt);\n\tint ifindex = dev ? dev->ifindex : 1;\n\tstruct nlmsghdr  *nlh;\n\tu8 scope = RT_SCOPE_UNIVERSE;\n\n\tif (ipv6_addr_scope(&ifaca->aca_addr) & IFA_SITE)\n\t\tscope = RT_SCOPE_SITE;\n\n\tnlh = nlmsg_put(skb, args->portid, args->seq, args->event,\n\t\t\tsizeof(struct ifaddrmsg), args->flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tif (args->netnsid >= 0 &&\n\t    nla_put_s32(skb, IFA_TARGET_NETNSID, args->netnsid)) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tput_ifaddrmsg(nlh, 128, IFA_F_PERMANENT, scope, ifindex);\n\tif (nla_put_in6_addr(skb, IFA_ANYCAST, &ifaca->aca_addr) < 0 ||\n\t    put_cacheinfo(skb, ifaca->aca_cstamp, ifaca->aca_tstamp,\n\t\t\t  INFINITY_LIFE_TIME, INFINITY_LIFE_TIME) < 0) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\n \nstatic int in6_dump_addrs(struct inet6_dev *idev, struct sk_buff *skb,\n\t\t\t  struct netlink_callback *cb, int s_ip_idx,\n\t\t\t  struct inet6_fill_args *fillargs)\n{\n\tstruct ifmcaddr6 *ifmca;\n\tstruct ifacaddr6 *ifaca;\n\tint ip_idx = 0;\n\tint err = 1;\n\n\tread_lock_bh(&idev->lock);\n\tswitch (fillargs->type) {\n\tcase UNICAST_ADDR: {\n\t\tstruct inet6_ifaddr *ifa;\n\t\tfillargs->event = RTM_NEWADDR;\n\n\t\t \n\t\tlist_for_each_entry(ifa, &idev->addr_list, if_list) {\n\t\t\tif (ip_idx < s_ip_idx)\n\t\t\t\tgoto next;\n\t\t\terr = inet6_fill_ifaddr(skb, ifa, fillargs);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\nnext:\n\t\t\tip_idx++;\n\t\t}\n\t\tbreak;\n\t}\n\tcase MULTICAST_ADDR:\n\t\tread_unlock_bh(&idev->lock);\n\t\tfillargs->event = RTM_GETMULTICAST;\n\n\t\t \n\t\tfor (ifmca = rtnl_dereference(idev->mc_list);\n\t\t     ifmca;\n\t\t     ifmca = rtnl_dereference(ifmca->next), ip_idx++) {\n\t\t\tif (ip_idx < s_ip_idx)\n\t\t\t\tcontinue;\n\t\t\terr = inet6_fill_ifmcaddr(skb, ifmca, fillargs);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tread_lock_bh(&idev->lock);\n\t\tbreak;\n\tcase ANYCAST_ADDR:\n\t\tfillargs->event = RTM_GETANYCAST;\n\t\t \n\t\tfor (ifaca = idev->ac_list; ifaca;\n\t\t     ifaca = ifaca->aca_next, ip_idx++) {\n\t\t\tif (ip_idx < s_ip_idx)\n\t\t\t\tcontinue;\n\t\t\terr = inet6_fill_ifacaddr(skb, ifaca, fillargs);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tread_unlock_bh(&idev->lock);\n\tcb->args[2] = ip_idx;\n\treturn err;\n}\n\nstatic int inet6_valid_dump_ifaddr_req(const struct nlmsghdr *nlh,\n\t\t\t\t       struct inet6_fill_args *fillargs,\n\t\t\t\t       struct net **tgt_net, struct sock *sk,\n\t\t\t\t       struct netlink_callback *cb)\n{\n\tstruct netlink_ext_ack *extack = cb->extack;\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct ifaddrmsg *ifm;\n\tint err, i;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifm))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid header for address dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifa_prefixlen || ifm->ifa_flags || ifm->ifa_scope) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid values in header for address dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tfillargs->ifindex = ifm->ifa_index;\n\tif (fillargs->ifindex) {\n\t\tcb->answer_flags |= NLM_F_DUMP_FILTERED;\n\t\tfillargs->flags |= NLM_F_DUMP_FILTERED;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*ifm), tb, IFA_MAX,\n\t\t\t\t\t    ifa_ipv6_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i <= IFA_MAX; ++i) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tif (i == IFA_TARGET_NETNSID) {\n\t\t\tstruct net *net;\n\n\t\t\tfillargs->netnsid = nla_get_s32(tb[i]);\n\t\t\tnet = rtnl_get_net_ns_capable(sk, fillargs->netnsid);\n\t\t\tif (IS_ERR(net)) {\n\t\t\t\tfillargs->netnsid = -1;\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid target network namespace id\");\n\t\t\t\treturn PTR_ERR(net);\n\t\t\t}\n\t\t\t*tgt_net = net;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported attribute in dump request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int inet6_dump_addr(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t   enum addr_type_t type)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct inet6_fill_args fillargs = {\n\t\t.portid = NETLINK_CB(cb->skb).portid,\n\t\t.seq = cb->nlh->nlmsg_seq,\n\t\t.flags = NLM_F_MULTI,\n\t\t.netnsid = -1,\n\t\t.type = type,\n\t};\n\tstruct net *tgt_net = sock_net(skb->sk);\n\tint idx, s_idx, s_ip_idx;\n\tint h, s_h;\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\tstruct hlist_head *head;\n\tint err = 0;\n\n\ts_h = cb->args[0];\n\ts_idx = idx = cb->args[1];\n\ts_ip_idx = cb->args[2];\n\n\tif (cb->strict_check) {\n\t\terr = inet6_valid_dump_ifaddr_req(nlh, &fillargs, &tgt_net,\n\t\t\t\t\t\t  skb->sk, cb);\n\t\tif (err < 0)\n\t\t\tgoto put_tgt_net;\n\n\t\terr = 0;\n\t\tif (fillargs.ifindex) {\n\t\t\tdev = __dev_get_by_index(tgt_net, fillargs.ifindex);\n\t\t\tif (!dev) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto put_tgt_net;\n\t\t\t}\n\t\t\tidev = __in6_dev_get(dev);\n\t\t\tif (idev) {\n\t\t\t\terr = in6_dump_addrs(idev, skb, cb, s_ip_idx,\n\t\t\t\t\t\t     &fillargs);\n\t\t\t\tif (err > 0)\n\t\t\t\t\terr = 0;\n\t\t\t}\n\t\t\tgoto put_tgt_net;\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tcb->seq = atomic_read(&tgt_net->ipv6.dev_addr_genid) ^ tgt_net->dev_base_seq;\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &tgt_net->dev_index_head[h];\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tif (h > s_h || idx > s_idx)\n\t\t\t\ts_ip_idx = 0;\n\t\t\tidev = __in6_dev_get(dev);\n\t\t\tif (!idev)\n\t\t\t\tgoto cont;\n\n\t\t\tif (in6_dump_addrs(idev, skb, cb, s_ip_idx,\n\t\t\t\t\t   &fillargs) < 0)\n\t\t\t\tgoto done;\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\ndone:\n\trcu_read_unlock();\n\tcb->args[0] = h;\n\tcb->args[1] = idx;\nput_tgt_net:\n\tif (fillargs.netnsid >= 0)\n\t\tput_net(tgt_net);\n\n\treturn skb->len ? : err;\n}\n\nstatic int inet6_dump_ifaddr(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tenum addr_type_t type = UNICAST_ADDR;\n\n\treturn inet6_dump_addr(skb, cb, type);\n}\n\nstatic int inet6_dump_ifmcaddr(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tenum addr_type_t type = MULTICAST_ADDR;\n\n\treturn inet6_dump_addr(skb, cb, type);\n}\n\n\nstatic int inet6_dump_ifacaddr(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tenum addr_type_t type = ANYCAST_ADDR;\n\n\treturn inet6_dump_addr(skb, cb, type);\n}\n\nstatic int inet6_rtm_valid_getaddr_req(struct sk_buff *skb,\n\t\t\t\t       const struct nlmsghdr *nlh,\n\t\t\t\t       struct nlattr **tb,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct ifaddrmsg *ifm;\n\tint i, err;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifm))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid header for get address request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(*ifm), tb, IFA_MAX,\n\t\t\t\t\t      ifa_ipv6_policy, extack);\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifa_prefixlen || ifm->ifa_flags || ifm->ifa_scope) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid values in header for get address request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*ifm), tb, IFA_MAX,\n\t\t\t\t\t    ifa_ipv6_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <= IFA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase IFA_TARGET_NETNSID:\n\t\tcase IFA_ADDRESS:\n\t\tcase IFA_LOCAL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported attribute in get address request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int inet6_rtm_getaddr(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *tgt_net = sock_net(in_skb->sk);\n\tstruct inet6_fill_args fillargs = {\n\t\t.portid = NETLINK_CB(in_skb).portid,\n\t\t.seq = nlh->nlmsg_seq,\n\t\t.event = RTM_NEWADDR,\n\t\t.flags = 0,\n\t\t.netnsid = -1,\n\t};\n\tstruct ifaddrmsg *ifm;\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct in6_addr *addr = NULL, *peer;\n\tstruct net_device *dev = NULL;\n\tstruct inet6_ifaddr *ifa;\n\tstruct sk_buff *skb;\n\tint err;\n\n\terr = inet6_rtm_valid_getaddr_req(in_skb, nlh, tb, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFA_TARGET_NETNSID]) {\n\t\tfillargs.netnsid = nla_get_s32(tb[IFA_TARGET_NETNSID]);\n\n\t\ttgt_net = rtnl_get_net_ns_capable(NETLINK_CB(in_skb).sk,\n\t\t\t\t\t\t  fillargs.netnsid);\n\t\tif (IS_ERR(tgt_net))\n\t\t\treturn PTR_ERR(tgt_net);\n\t}\n\n\taddr = extract_addr(tb[IFA_ADDRESS], tb[IFA_LOCAL], &peer);\n\tif (!addr)\n\t\treturn -EINVAL;\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifa_index)\n\t\tdev = dev_get_by_index(tgt_net, ifm->ifa_index);\n\n\tifa = ipv6_get_ifaddr(tgt_net, addr, dev, 1);\n\tif (!ifa) {\n\t\terr = -EADDRNOTAVAIL;\n\t\tgoto errout;\n\t}\n\n\tskb = nlmsg_new(inet6_ifaddr_msgsize(), GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout_ifa;\n\t}\n\n\terr = inet6_fill_ifaddr(skb, ifa, &fillargs);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout_ifa;\n\t}\n\terr = rtnl_unicast(skb, tgt_net, NETLINK_CB(in_skb).portid);\nerrout_ifa:\n\tin6_ifa_put(ifa);\nerrout:\n\tdev_put(dev);\n\tif (fillargs.netnsid >= 0)\n\t\tput_net(tgt_net);\n\n\treturn err;\n}\n\nstatic void inet6_ifa_notify(int event, struct inet6_ifaddr *ifa)\n{\n\tstruct sk_buff *skb;\n\tstruct net *net = dev_net(ifa->idev->dev);\n\tstruct inet6_fill_args fillargs = {\n\t\t.portid = 0,\n\t\t.seq = 0,\n\t\t.event = event,\n\t\t.flags = 0,\n\t\t.netnsid = -1,\n\t};\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(inet6_ifaddr_msgsize(), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet6_fill_ifaddr(skb, ifa, &fillargs);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV6_IFADDR, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV6_IFADDR, err);\n}\n\nstatic inline void ipv6_store_devconf(struct ipv6_devconf *cnf,\n\t\t\t\t__s32 *array, int bytes)\n{\n\tBUG_ON(bytes < (DEVCONF_MAX * 4));\n\n\tmemset(array, 0, bytes);\n\tarray[DEVCONF_FORWARDING] = cnf->forwarding;\n\tarray[DEVCONF_HOPLIMIT] = cnf->hop_limit;\n\tarray[DEVCONF_MTU6] = cnf->mtu6;\n\tarray[DEVCONF_ACCEPT_RA] = cnf->accept_ra;\n\tarray[DEVCONF_ACCEPT_REDIRECTS] = cnf->accept_redirects;\n\tarray[DEVCONF_AUTOCONF] = cnf->autoconf;\n\tarray[DEVCONF_DAD_TRANSMITS] = cnf->dad_transmits;\n\tarray[DEVCONF_RTR_SOLICITS] = cnf->rtr_solicits;\n\tarray[DEVCONF_RTR_SOLICIT_INTERVAL] =\n\t\tjiffies_to_msecs(cnf->rtr_solicit_interval);\n\tarray[DEVCONF_RTR_SOLICIT_MAX_INTERVAL] =\n\t\tjiffies_to_msecs(cnf->rtr_solicit_max_interval);\n\tarray[DEVCONF_RTR_SOLICIT_DELAY] =\n\t\tjiffies_to_msecs(cnf->rtr_solicit_delay);\n\tarray[DEVCONF_FORCE_MLD_VERSION] = cnf->force_mld_version;\n\tarray[DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL] =\n\t\tjiffies_to_msecs(cnf->mldv1_unsolicited_report_interval);\n\tarray[DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL] =\n\t\tjiffies_to_msecs(cnf->mldv2_unsolicited_report_interval);\n\tarray[DEVCONF_USE_TEMPADDR] = cnf->use_tempaddr;\n\tarray[DEVCONF_TEMP_VALID_LFT] = cnf->temp_valid_lft;\n\tarray[DEVCONF_TEMP_PREFERED_LFT] = cnf->temp_prefered_lft;\n\tarray[DEVCONF_REGEN_MAX_RETRY] = cnf->regen_max_retry;\n\tarray[DEVCONF_MAX_DESYNC_FACTOR] = cnf->max_desync_factor;\n\tarray[DEVCONF_MAX_ADDRESSES] = cnf->max_addresses;\n\tarray[DEVCONF_ACCEPT_RA_DEFRTR] = cnf->accept_ra_defrtr;\n\tarray[DEVCONF_RA_DEFRTR_METRIC] = cnf->ra_defrtr_metric;\n\tarray[DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT] = cnf->accept_ra_min_hop_limit;\n\tarray[DEVCONF_ACCEPT_RA_PINFO] = cnf->accept_ra_pinfo;\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\tarray[DEVCONF_ACCEPT_RA_RTR_PREF] = cnf->accept_ra_rtr_pref;\n\tarray[DEVCONF_RTR_PROBE_INTERVAL] =\n\t\tjiffies_to_msecs(cnf->rtr_probe_interval);\n#ifdef CONFIG_IPV6_ROUTE_INFO\n\tarray[DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN] = cnf->accept_ra_rt_info_min_plen;\n\tarray[DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN] = cnf->accept_ra_rt_info_max_plen;\n#endif\n#endif\n\tarray[DEVCONF_PROXY_NDP] = cnf->proxy_ndp;\n\tarray[DEVCONF_ACCEPT_SOURCE_ROUTE] = cnf->accept_source_route;\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\tarray[DEVCONF_OPTIMISTIC_DAD] = cnf->optimistic_dad;\n\tarray[DEVCONF_USE_OPTIMISTIC] = cnf->use_optimistic;\n#endif\n#ifdef CONFIG_IPV6_MROUTE\n\tarray[DEVCONF_MC_FORWARDING] = atomic_read(&cnf->mc_forwarding);\n#endif\n\tarray[DEVCONF_DISABLE_IPV6] = cnf->disable_ipv6;\n\tarray[DEVCONF_ACCEPT_DAD] = cnf->accept_dad;\n\tarray[DEVCONF_FORCE_TLLAO] = cnf->force_tllao;\n\tarray[DEVCONF_NDISC_NOTIFY] = cnf->ndisc_notify;\n\tarray[DEVCONF_SUPPRESS_FRAG_NDISC] = cnf->suppress_frag_ndisc;\n\tarray[DEVCONF_ACCEPT_RA_FROM_LOCAL] = cnf->accept_ra_from_local;\n\tarray[DEVCONF_ACCEPT_RA_MTU] = cnf->accept_ra_mtu;\n\tarray[DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN] = cnf->ignore_routes_with_linkdown;\n\t \n\tarray[DEVCONF_USE_OIF_ADDRS_ONLY] = cnf->use_oif_addrs_only;\n\tarray[DEVCONF_DROP_UNICAST_IN_L2_MULTICAST] = cnf->drop_unicast_in_l2_multicast;\n\tarray[DEVCONF_DROP_UNSOLICITED_NA] = cnf->drop_unsolicited_na;\n\tarray[DEVCONF_KEEP_ADDR_ON_DOWN] = cnf->keep_addr_on_down;\n\tarray[DEVCONF_SEG6_ENABLED] = cnf->seg6_enabled;\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\tarray[DEVCONF_SEG6_REQUIRE_HMAC] = cnf->seg6_require_hmac;\n#endif\n\tarray[DEVCONF_ENHANCED_DAD] = cnf->enhanced_dad;\n\tarray[DEVCONF_ADDR_GEN_MODE] = cnf->addr_gen_mode;\n\tarray[DEVCONF_DISABLE_POLICY] = cnf->disable_policy;\n\tarray[DEVCONF_NDISC_TCLASS] = cnf->ndisc_tclass;\n\tarray[DEVCONF_RPL_SEG_ENABLED] = cnf->rpl_seg_enabled;\n\tarray[DEVCONF_IOAM6_ENABLED] = cnf->ioam6_enabled;\n\tarray[DEVCONF_IOAM6_ID] = cnf->ioam6_id;\n\tarray[DEVCONF_IOAM6_ID_WIDE] = cnf->ioam6_id_wide;\n\tarray[DEVCONF_NDISC_EVICT_NOCARRIER] = cnf->ndisc_evict_nocarrier;\n\tarray[DEVCONF_ACCEPT_UNTRACKED_NA] = cnf->accept_untracked_na;\n\tarray[DEVCONF_ACCEPT_RA_MIN_LFT] = cnf->accept_ra_min_lft;\n}\n\nstatic inline size_t inet6_ifla6_size(void)\n{\n\treturn nla_total_size(4)  \n\t     + nla_total_size(sizeof(struct ifla_cacheinfo))\n\t     + nla_total_size(DEVCONF_MAX * 4)  \n\t     + nla_total_size(IPSTATS_MIB_MAX * 8)  \n\t     + nla_total_size(ICMP6_MIB_MAX * 8)  \n\t     + nla_total_size(sizeof(struct in6_addr))  \n\t     + nla_total_size(1)  \n\t     + nla_total_size(4)  \n\t     + 0;\n}\n\nstatic inline size_t inet6_if_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\n\t       + nla_total_size(IFNAMSIZ)  \n\t       + nla_total_size(MAX_ADDR_LEN)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(1)  \n\t       + nla_total_size(inet6_ifla6_size());  \n}\n\nstatic inline void __snmp6_fill_statsdev(u64 *stats, atomic_long_t *mib,\n\t\t\t\t\tint bytes)\n{\n\tint i;\n\tint pad = bytes - sizeof(u64) * ICMP6_MIB_MAX;\n\tBUG_ON(pad < 0);\n\n\t \n\tput_unaligned(ICMP6_MIB_MAX, &stats[0]);\n\tfor (i = 1; i < ICMP6_MIB_MAX; i++)\n\t\tput_unaligned(atomic_long_read(&mib[i]), &stats[i]);\n\n\tmemset(&stats[ICMP6_MIB_MAX], 0, pad);\n}\n\nstatic inline void __snmp6_fill_stats64(u64 *stats, void __percpu *mib,\n\t\t\t\t\tint bytes, size_t syncpoff)\n{\n\tint i, c;\n\tu64 buff[IPSTATS_MIB_MAX];\n\tint pad = bytes - sizeof(u64) * IPSTATS_MIB_MAX;\n\n\tBUG_ON(pad < 0);\n\n\tmemset(buff, 0, sizeof(buff));\n\tbuff[0] = IPSTATS_MIB_MAX;\n\n\tfor_each_possible_cpu(c) {\n\t\tfor (i = 1; i < IPSTATS_MIB_MAX; i++)\n\t\t\tbuff[i] += snmp_get_cpu_field64(mib, c, i, syncpoff);\n\t}\n\n\tmemcpy(stats, buff, IPSTATS_MIB_MAX * sizeof(u64));\n\tmemset(&stats[IPSTATS_MIB_MAX], 0, pad);\n}\n\nstatic void snmp6_fill_stats(u64 *stats, struct inet6_dev *idev, int attrtype,\n\t\t\t     int bytes)\n{\n\tswitch (attrtype) {\n\tcase IFLA_INET6_STATS:\n\t\t__snmp6_fill_stats64(stats, idev->stats.ipv6, bytes,\n\t\t\t\t     offsetof(struct ipstats_mib, syncp));\n\t\tbreak;\n\tcase IFLA_INET6_ICMP6STATS:\n\t\t__snmp6_fill_statsdev(stats, idev->stats.icmpv6dev->mibs, bytes);\n\t\tbreak;\n\t}\n}\n\nstatic int inet6_fill_ifla6_attrs(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\t\t  u32 ext_filter_mask)\n{\n\tstruct nlattr *nla;\n\tstruct ifla_cacheinfo ci;\n\n\tif (nla_put_u32(skb, IFLA_INET6_FLAGS, idev->if_flags))\n\t\tgoto nla_put_failure;\n\tci.max_reasm_len = IPV6_MAXPLEN;\n\tci.tstamp = cstamp_delta(idev->tstamp);\n\tci.reachable_time = jiffies_to_msecs(idev->nd_parms->reachable_time);\n\tci.retrans_time = jiffies_to_msecs(NEIGH_VAR(idev->nd_parms, RETRANS_TIME));\n\tif (nla_put(skb, IFLA_INET6_CACHEINFO, sizeof(ci), &ci))\n\t\tgoto nla_put_failure;\n\tnla = nla_reserve(skb, IFLA_INET6_CONF, DEVCONF_MAX * sizeof(s32));\n\tif (!nla)\n\t\tgoto nla_put_failure;\n\tipv6_store_devconf(&idev->cnf, nla_data(nla), nla_len(nla));\n\n\t \n\n\tif (ext_filter_mask & RTEXT_FILTER_SKIP_STATS)\n\t\treturn 0;\n\n\tnla = nla_reserve(skb, IFLA_INET6_STATS, IPSTATS_MIB_MAX * sizeof(u64));\n\tif (!nla)\n\t\tgoto nla_put_failure;\n\tsnmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_STATS, nla_len(nla));\n\n\tnla = nla_reserve(skb, IFLA_INET6_ICMP6STATS, ICMP6_MIB_MAX * sizeof(u64));\n\tif (!nla)\n\t\tgoto nla_put_failure;\n\tsnmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_ICMP6STATS, nla_len(nla));\n\n\tnla = nla_reserve(skb, IFLA_INET6_TOKEN, sizeof(struct in6_addr));\n\tif (!nla)\n\t\tgoto nla_put_failure;\n\tread_lock_bh(&idev->lock);\n\tmemcpy(nla_data(nla), idev->token.s6_addr, nla_len(nla));\n\tread_unlock_bh(&idev->lock);\n\n\tif (nla_put_u8(skb, IFLA_INET6_ADDR_GEN_MODE, idev->cnf.addr_gen_mode))\n\t\tgoto nla_put_failure;\n\n\tif (idev->ra_mtu &&\n\t    nla_put_u32(skb, IFLA_INET6_RA_MTU, idev->ra_mtu))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic size_t inet6_get_link_af_size(const struct net_device *dev,\n\t\t\t\t     u32 ext_filter_mask)\n{\n\tif (!__in6_dev_get(dev))\n\t\treturn 0;\n\n\treturn inet6_ifla6_size();\n}\n\nstatic int inet6_fill_link_af(struct sk_buff *skb, const struct net_device *dev,\n\t\t\t      u32 ext_filter_mask)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\n\tif (!idev)\n\t\treturn -ENODATA;\n\n\tif (inet6_fill_ifla6_attrs(skb, idev, ext_filter_mask) < 0)\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int inet6_set_iftoken(struct inet6_dev *idev, struct in6_addr *token,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct inet6_ifaddr *ifp;\n\tstruct net_device *dev = idev->dev;\n\tbool clear_token, update_rs = false;\n\tstruct in6_addr ll_addr;\n\n\tASSERT_RTNL();\n\n\tif (!token)\n\t\treturn -EINVAL;\n\n\tif (dev->flags & IFF_LOOPBACK) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Device is loopback\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->flags & IFF_NOARP) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Device does not do neighbour discovery\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ipv6_accept_ra(idev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Router advertisement is disabled on device\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (idev->cnf.rtr_solicits == 0) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Router solicitation is disabled on device\");\n\t\treturn -EINVAL;\n\t}\n\n\twrite_lock_bh(&idev->lock);\n\n\tBUILD_BUG_ON(sizeof(token->s6_addr) != 16);\n\tmemcpy(idev->token.s6_addr + 8, token->s6_addr + 8, 8);\n\n\twrite_unlock_bh(&idev->lock);\n\n\tclear_token = ipv6_addr_any(token);\n\tif (clear_token)\n\t\tgoto update_lft;\n\n\tif (!idev->dead && (idev->if_flags & IF_READY) &&\n\t    !ipv6_get_lladdr(dev, &ll_addr, IFA_F_TENTATIVE |\n\t\t\t     IFA_F_OPTIMISTIC)) {\n\t\t \n\t\tndisc_send_rs(dev, &ll_addr, &in6addr_linklocal_allrouters);\n\t\tupdate_rs = true;\n\t}\n\nupdate_lft:\n\twrite_lock_bh(&idev->lock);\n\n\tif (update_rs) {\n\t\tidev->if_flags |= IF_RS_SENT;\n\t\tidev->rs_interval = rfc3315_s14_backoff_init(\n\t\t\tidev->cnf.rtr_solicit_interval);\n\t\tidev->rs_probes = 1;\n\t\taddrconf_mod_rs_timer(idev, idev->rs_interval);\n\t}\n\n\t \n\tlist_for_each_entry(ifp, &idev->addr_list, if_list) {\n\t\tspin_lock(&ifp->lock);\n\t\tif (ifp->tokenized) {\n\t\t\tifp->valid_lft = 0;\n\t\t\tifp->prefered_lft = 0;\n\t\t}\n\t\tspin_unlock(&ifp->lock);\n\t}\n\n\twrite_unlock_bh(&idev->lock);\n\tinet6_ifinfo_notify(RTM_NEWLINK, idev);\n\taddrconf_verify_rtnl(dev_net(dev));\n\treturn 0;\n}\n\nstatic const struct nla_policy inet6_af_policy[IFLA_INET6_MAX + 1] = {\n\t[IFLA_INET6_ADDR_GEN_MODE]\t= { .type = NLA_U8 },\n\t[IFLA_INET6_TOKEN]\t\t= { .len = sizeof(struct in6_addr) },\n\t[IFLA_INET6_RA_MTU]\t\t= { .type = NLA_REJECT,\n\t\t\t\t\t    .reject_message =\n\t\t\t\t\t\t\"IFLA_INET6_RA_MTU can not be set\" },\n};\n\nstatic int check_addr_gen_mode(int mode)\n{\n\tif (mode != IN6_ADDR_GEN_MODE_EUI64 &&\n\t    mode != IN6_ADDR_GEN_MODE_NONE &&\n\t    mode != IN6_ADDR_GEN_MODE_STABLE_PRIVACY &&\n\t    mode != IN6_ADDR_GEN_MODE_RANDOM)\n\t\treturn -EINVAL;\n\treturn 1;\n}\n\nstatic int check_stable_privacy(struct inet6_dev *idev, struct net *net,\n\t\t\t\tint mode)\n{\n\tif (mode == IN6_ADDR_GEN_MODE_STABLE_PRIVACY &&\n\t    !idev->cnf.stable_secret.initialized &&\n\t    !net->ipv6.devconf_dflt->stable_secret.initialized)\n\t\treturn -EINVAL;\n\treturn 1;\n}\n\nstatic int inet6_validate_link_af(const struct net_device *dev,\n\t\t\t\t  const struct nlattr *nla,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_INET6_MAX + 1];\n\tstruct inet6_dev *idev = NULL;\n\tint err;\n\n\tif (dev) {\n\t\tidev = __in6_dev_get(dev);\n\t\tif (!idev)\n\t\t\treturn -EAFNOSUPPORT;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, IFLA_INET6_MAX, nla,\n\t\t\t\t\t  inet6_af_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IFLA_INET6_TOKEN] && !tb[IFLA_INET6_ADDR_GEN_MODE])\n\t\treturn -EINVAL;\n\n\tif (tb[IFLA_INET6_ADDR_GEN_MODE]) {\n\t\tu8 mode = nla_get_u8(tb[IFLA_INET6_ADDR_GEN_MODE]);\n\n\t\tif (check_addr_gen_mode(mode) < 0)\n\t\t\treturn -EINVAL;\n\t\tif (dev && check_stable_privacy(idev, dev_net(dev), mode) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int inet6_set_link_af(struct net_device *dev, const struct nlattr *nla,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\tstruct nlattr *tb[IFLA_INET6_MAX + 1];\n\tint err;\n\n\tif (!idev)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (nla_parse_nested_deprecated(tb, IFLA_INET6_MAX, nla, NULL, NULL) < 0)\n\t\treturn -EINVAL;\n\n\tif (tb[IFLA_INET6_TOKEN]) {\n\t\terr = inet6_set_iftoken(idev, nla_data(tb[IFLA_INET6_TOKEN]),\n\t\t\t\t\textack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_INET6_ADDR_GEN_MODE]) {\n\t\tu8 mode = nla_get_u8(tb[IFLA_INET6_ADDR_GEN_MODE]);\n\n\t\tidev->cnf.addr_gen_mode = mode;\n\t}\n\n\treturn 0;\n}\n\nstatic int inet6_fill_ifinfo(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\t     u32 portid, u32 seq, int event, unsigned int flags)\n{\n\tstruct net_device *dev = idev->dev;\n\tstruct ifinfomsg *hdr;\n\tstruct nlmsghdr *nlh;\n\tvoid *protoinfo;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*hdr), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\thdr = nlmsg_data(nlh);\n\thdr->ifi_family = AF_INET6;\n\thdr->__ifi_pad = 0;\n\thdr->ifi_type = dev->type;\n\thdr->ifi_index = dev->ifindex;\n\thdr->ifi_flags = dev_get_flags(dev);\n\thdr->ifi_change = 0;\n\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\n\t    (dev->addr_len &&\n\t     nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||\n\t    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||\n\t    (dev->ifindex != dev_get_iflink(dev) &&\n\t     nla_put_u32(skb, IFLA_LINK, dev_get_iflink(dev))) ||\n\t    nla_put_u8(skb, IFLA_OPERSTATE,\n\t\t       netif_running(dev) ? dev->operstate : IF_OPER_DOWN))\n\t\tgoto nla_put_failure;\n\tprotoinfo = nla_nest_start_noflag(skb, IFLA_PROTINFO);\n\tif (!protoinfo)\n\t\tgoto nla_put_failure;\n\n\tif (inet6_fill_ifla6_attrs(skb, idev, 0) < 0)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, protoinfo);\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int inet6_valid_dump_ifinfo(const struct nlmsghdr *nlh,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ifinfomsg *ifm;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifm))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid header for link dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nlmsg_attrlen(nlh, sizeof(*ifm))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid data after header\");\n\t\treturn -EINVAL;\n\t}\n\n\tifm = nlmsg_data(nlh);\n\tif (ifm->__ifi_pad || ifm->ifi_type || ifm->ifi_flags ||\n\t    ifm->ifi_change || ifm->ifi_index) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid values in header for dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int inet6_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint h, s_h;\n\tint idx = 0, s_idx;\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\tstruct hlist_head *head;\n\n\t \n\tif (cb->strict_check) {\n\t\tint err = inet6_valid_dump_ifinfo(cb->nlh, cb->extack);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\ts_h = cb->args[0];\n\ts_idx = cb->args[1];\n\n\trcu_read_lock();\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\thlist_for_each_entry_rcu(dev, head, index_hlist) {\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\tidev = __in6_dev_get(dev);\n\t\t\tif (!idev)\n\t\t\t\tgoto cont;\n\t\t\tif (inet6_fill_ifinfo(skb, idev,\n\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t      cb->nlh->nlmsg_seq,\n\t\t\t\t\t      RTM_NEWLINK, NLM_F_MULTI) < 0)\n\t\t\t\tgoto out;\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n\tcb->args[1] = idx;\n\tcb->args[0] = h;\n\n\treturn skb->len;\n}\n\nvoid inet6_ifinfo_notify(int event, struct inet6_dev *idev)\n{\n\tstruct sk_buff *skb;\n\tstruct net *net = dev_net(idev->dev);\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(inet6_if_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet6_fill_ifinfo(skb, idev, 0, 0, event, 0);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV6_IFINFO, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV6_IFINFO, err);\n}\n\nstatic inline size_t inet6_prefix_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct prefixmsg))\n\t       + nla_total_size(sizeof(struct in6_addr))\n\t       + nla_total_size(sizeof(struct prefix_cacheinfo));\n}\n\nstatic int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\t     struct prefix_info *pinfo, u32 portid, u32 seq,\n\t\t\t     int event, unsigned int flags)\n{\n\tstruct prefixmsg *pmsg;\n\tstruct nlmsghdr *nlh;\n\tstruct prefix_cacheinfo\tci;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*pmsg), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tpmsg = nlmsg_data(nlh);\n\tpmsg->prefix_family = AF_INET6;\n\tpmsg->prefix_pad1 = 0;\n\tpmsg->prefix_pad2 = 0;\n\tpmsg->prefix_ifindex = idev->dev->ifindex;\n\tpmsg->prefix_len = pinfo->prefix_len;\n\tpmsg->prefix_type = pinfo->type;\n\tpmsg->prefix_pad3 = 0;\n\tpmsg->prefix_flags = pinfo->flags;\n\n\tif (nla_put(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix))\n\t\tgoto nla_put_failure;\n\tci.preferred_time = ntohl(pinfo->prefered);\n\tci.valid_time = ntohl(pinfo->valid);\n\tif (nla_put(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))\n\t\tgoto nla_put_failure;\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic void inet6_prefix_notify(int event, struct inet6_dev *idev,\n\t\t\t struct prefix_info *pinfo)\n{\n\tstruct sk_buff *skb;\n\tstruct net *net = dev_net(idev->dev);\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(inet6_prefix_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = inet6_fill_prefix(skb, idev, pinfo, 0, 0, event, 0);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV6_PREFIX, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV6_PREFIX, err);\n}\n\nstatic void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)\n{\n\tstruct net *net = dev_net(ifp->idev->dev);\n\n\tif (event)\n\t\tASSERT_RTNL();\n\n\tinet6_ifa_notify(event ? : RTM_NEWADDR, ifp);\n\n\tswitch (event) {\n\tcase RTM_NEWADDR:\n\t\t \n\t\tif (ifp->rt && !rcu_access_pointer(ifp->rt->fib6_node)) {\n\t\t\tip6_ins_rt(net, ifp->rt);\n\t\t} else if (!ifp->rt && (ifp->idev->dev->flags & IFF_UP)) {\n\t\t\tpr_warn(\"BUG: Address %pI6c on device %s is missing its host route.\\n\",\n\t\t\t\t&ifp->addr, ifp->idev->dev->name);\n\t\t}\n\n\t\tif (ifp->idev->cnf.forwarding)\n\t\t\taddrconf_join_anycast(ifp);\n\t\tif (!ipv6_addr_any(&ifp->peer_addr))\n\t\t\taddrconf_prefix_route(&ifp->peer_addr, 128,\n\t\t\t\t\t      ifp->rt_priority, ifp->idev->dev,\n\t\t\t\t\t      0, 0, GFP_ATOMIC);\n\t\tbreak;\n\tcase RTM_DELADDR:\n\t\tif (ifp->idev->cnf.forwarding)\n\t\t\taddrconf_leave_anycast(ifp);\n\t\taddrconf_leave_solict(ifp->idev, &ifp->addr);\n\t\tif (!ipv6_addr_any(&ifp->peer_addr)) {\n\t\t\tstruct fib6_info *rt;\n\n\t\t\trt = addrconf_get_prefix_route(&ifp->peer_addr, 128,\n\t\t\t\t\t\t       ifp->idev->dev, 0, 0,\n\t\t\t\t\t\t       false);\n\t\t\tif (rt)\n\t\t\t\tip6_del_rt(net, rt, false);\n\t\t}\n\t\tif (ifp->rt) {\n\t\t\tip6_del_rt(net, ifp->rt, false);\n\t\t\tifp->rt = NULL;\n\t\t}\n\t\trt_genid_bump_ipv6(net);\n\t\tbreak;\n\t}\n\tatomic_inc(&net->ipv6.dev_addr_genid);\n}\n\nstatic void ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)\n{\n\tif (likely(ifp->idev->dead == 0))\n\t\t__ipv6_ifa_notify(event, ifp);\n}\n\n#ifdef CONFIG_SYSCTL\n\nstatic int addrconf_sysctl_forward(struct ctl_table *ctl, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = ctl->data;\n\tint val = *valp;\n\tloff_t pos = *ppos;\n\tstruct ctl_table lctl;\n\tint ret;\n\n\t \n\tlctl = *ctl;\n\tlctl.data = &val;\n\n\tret = proc_dointvec(&lctl, write, buffer, lenp, ppos);\n\n\tif (write)\n\t\tret = addrconf_fixup_forwarding(ctl, valp, val);\n\tif (ret)\n\t\t*ppos = pos;\n\treturn ret;\n}\n\nstatic int addrconf_sysctl_mtu(struct ctl_table *ctl, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct inet6_dev *idev = ctl->extra1;\n\tint min_mtu = IPV6_MIN_MTU;\n\tstruct ctl_table lctl;\n\n\tlctl = *ctl;\n\tlctl.extra1 = &min_mtu;\n\tlctl.extra2 = idev ? &idev->dev->mtu : NULL;\n\n\treturn proc_dointvec_minmax(&lctl, write, buffer, lenp, ppos);\n}\n\nstatic void dev_disable_change(struct inet6_dev *idev)\n{\n\tstruct netdev_notifier_info info;\n\n\tif (!idev || !idev->dev)\n\t\treturn;\n\n\tnetdev_notifier_info_init(&info, idev->dev);\n\tif (idev->cnf.disable_ipv6)\n\t\taddrconf_notify(NULL, NETDEV_DOWN, &info);\n\telse\n\t\taddrconf_notify(NULL, NETDEV_UP, &info);\n}\n\nstatic void addrconf_disable_change(struct net *net, __s32 newf)\n{\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\n\tfor_each_netdev(net, dev) {\n\t\tidev = __in6_dev_get(dev);\n\t\tif (idev) {\n\t\t\tint changed = (!idev->cnf.disable_ipv6) ^ (!newf);\n\t\t\tidev->cnf.disable_ipv6 = newf;\n\t\t\tif (changed)\n\t\t\t\tdev_disable_change(idev);\n\t\t}\n\t}\n}\n\nstatic int addrconf_disable_ipv6(struct ctl_table *table, int *p, int newf)\n{\n\tstruct net *net;\n\tint old;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tnet = (struct net *)table->extra2;\n\told = *p;\n\t*p = newf;\n\n\tif (p == &net->ipv6.devconf_dflt->disable_ipv6) {\n\t\trtnl_unlock();\n\t\treturn 0;\n\t}\n\n\tif (p == &net->ipv6.devconf_all->disable_ipv6) {\n\t\tnet->ipv6.devconf_dflt->disable_ipv6 = newf;\n\t\taddrconf_disable_change(net, newf);\n\t} else if ((!newf) ^ (!old))\n\t\tdev_disable_change((struct inet6_dev *)table->extra1);\n\n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic int addrconf_sysctl_disable(struct ctl_table *ctl, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = ctl->data;\n\tint val = *valp;\n\tloff_t pos = *ppos;\n\tstruct ctl_table lctl;\n\tint ret;\n\n\t \n\tlctl = *ctl;\n\tlctl.data = &val;\n\n\tret = proc_dointvec(&lctl, write, buffer, lenp, ppos);\n\n\tif (write)\n\t\tret = addrconf_disable_ipv6(ctl, valp, val);\n\tif (ret)\n\t\t*ppos = pos;\n\treturn ret;\n}\n\nstatic int addrconf_sysctl_proxy_ndp(struct ctl_table *ctl, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = ctl->data;\n\tint ret;\n\tint old, new;\n\n\told = *valp;\n\tret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\tnew = *valp;\n\n\tif (write && old != new) {\n\t\tstruct net *net = ctl->extra2;\n\n\t\tif (!rtnl_trylock())\n\t\t\treturn restart_syscall();\n\n\t\tif (valp == &net->ipv6.devconf_dflt->proxy_ndp)\n\t\t\tinet6_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t     NETCONFA_PROXY_NEIGH,\n\t\t\t\t\t\t     NETCONFA_IFINDEX_DEFAULT,\n\t\t\t\t\t\t     net->ipv6.devconf_dflt);\n\t\telse if (valp == &net->ipv6.devconf_all->proxy_ndp)\n\t\t\tinet6_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t     NETCONFA_PROXY_NEIGH,\n\t\t\t\t\t\t     NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t\t     net->ipv6.devconf_all);\n\t\telse {\n\t\t\tstruct inet6_dev *idev = ctl->extra1;\n\n\t\t\tinet6_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t     NETCONFA_PROXY_NEIGH,\n\t\t\t\t\t\t     idev->dev->ifindex,\n\t\t\t\t\t\t     &idev->cnf);\n\t\t}\n\t\trtnl_unlock();\n\t}\n\n\treturn ret;\n}\n\nstatic int addrconf_sysctl_addr_gen_mode(struct ctl_table *ctl, int write,\n\t\t\t\t\t void *buffer, size_t *lenp,\n\t\t\t\t\t loff_t *ppos)\n{\n\tint ret = 0;\n\tu32 new_val;\n\tstruct inet6_dev *idev = (struct inet6_dev *)ctl->extra1;\n\tstruct net *net = (struct net *)ctl->extra2;\n\tstruct ctl_table tmp = {\n\t\t.data = &new_val,\n\t\t.maxlen = sizeof(new_val),\n\t\t.mode = ctl->mode,\n\t};\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tnew_val = *((u32 *)ctl->data);\n\n\tret = proc_douintvec(&tmp, write, buffer, lenp, ppos);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tif (write) {\n\t\tif (check_addr_gen_mode(new_val) < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (idev) {\n\t\t\tif (check_stable_privacy(idev, net, new_val) < 0) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (idev->cnf.addr_gen_mode != new_val) {\n\t\t\t\tidev->cnf.addr_gen_mode = new_val;\n\t\t\t\taddrconf_init_auto_addrs(idev->dev);\n\t\t\t}\n\t\t} else if (&net->ipv6.devconf_all->addr_gen_mode == ctl->data) {\n\t\t\tstruct net_device *dev;\n\n\t\t\tnet->ipv6.devconf_dflt->addr_gen_mode = new_val;\n\t\t\tfor_each_netdev(net, dev) {\n\t\t\t\tidev = __in6_dev_get(dev);\n\t\t\t\tif (idev &&\n\t\t\t\t    idev->cnf.addr_gen_mode != new_val) {\n\t\t\t\t\tidev->cnf.addr_gen_mode = new_val;\n\t\t\t\t\taddrconf_init_auto_addrs(idev->dev);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t*((u32 *)ctl->data) = new_val;\n\t}\n\nout:\n\trtnl_unlock();\n\n\treturn ret;\n}\n\nstatic int addrconf_sysctl_stable_secret(struct ctl_table *ctl, int write,\n\t\t\t\t\t void *buffer, size_t *lenp,\n\t\t\t\t\t loff_t *ppos)\n{\n\tint err;\n\tstruct in6_addr addr;\n\tchar str[IPV6_MAX_STRLEN];\n\tstruct ctl_table lctl = *ctl;\n\tstruct net *net = ctl->extra2;\n\tstruct ipv6_stable_secret *secret = ctl->data;\n\n\tif (&net->ipv6.devconf_all->stable_secret == ctl->data)\n\t\treturn -EIO;\n\n\tlctl.maxlen = IPV6_MAX_STRLEN;\n\tlctl.data = str;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tif (!write && !secret->initialized) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\terr = snprintf(str, sizeof(str), \"%pI6\", &secret->secret);\n\tif (err >= sizeof(str)) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\terr = proc_dostring(&lctl, write, buffer, lenp, ppos);\n\tif (err || !write)\n\t\tgoto out;\n\n\tif (in6_pton(str, -1, addr.in6_u.u6_addr8, -1, NULL) != 1) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tsecret->initialized = true;\n\tsecret->secret = addr;\n\n\tif (&net->ipv6.devconf_dflt->stable_secret == ctl->data) {\n\t\tstruct net_device *dev;\n\n\t\tfor_each_netdev(net, dev) {\n\t\t\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\n\t\t\tif (idev) {\n\t\t\t\tidev->cnf.addr_gen_mode =\n\t\t\t\t\tIN6_ADDR_GEN_MODE_STABLE_PRIVACY;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct inet6_dev *idev = ctl->extra1;\n\n\t\tidev->cnf.addr_gen_mode = IN6_ADDR_GEN_MODE_STABLE_PRIVACY;\n\t}\n\nout:\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstatic\nint addrconf_sysctl_ignore_routes_with_linkdown(struct ctl_table *ctl,\n\t\t\t\t\t\tint write, void *buffer,\n\t\t\t\t\t\tsize_t *lenp,\n\t\t\t\t\t\tloff_t *ppos)\n{\n\tint *valp = ctl->data;\n\tint val = *valp;\n\tloff_t pos = *ppos;\n\tstruct ctl_table lctl;\n\tint ret;\n\n\t \n\tlctl = *ctl;\n\tlctl.data = &val;\n\n\tret = proc_dointvec(&lctl, write, buffer, lenp, ppos);\n\n\tif (write)\n\t\tret = addrconf_fixup_linkdown(ctl, valp, val);\n\tif (ret)\n\t\t*ppos = pos;\n\treturn ret;\n}\n\nstatic\nvoid addrconf_set_nopolicy(struct rt6_info *rt, int action)\n{\n\tif (rt) {\n\t\tif (action)\n\t\t\trt->dst.flags |= DST_NOPOLICY;\n\t\telse\n\t\t\trt->dst.flags &= ~DST_NOPOLICY;\n\t}\n}\n\nstatic\nvoid addrconf_disable_policy_idev(struct inet6_dev *idev, int val)\n{\n\tstruct inet6_ifaddr *ifa;\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifa, &idev->addr_list, if_list) {\n\t\tspin_lock(&ifa->lock);\n\t\tif (ifa->rt) {\n\t\t\t \n\t\t\tstruct fib6_nh *nh = ifa->rt->fib6_nh;\n\t\t\tint cpu;\n\n\t\t\trcu_read_lock();\n\t\t\tifa->rt->dst_nopolicy = val ? true : false;\n\t\t\tif (nh->rt6i_pcpu) {\n\t\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\t\tstruct rt6_info **rtp;\n\n\t\t\t\t\trtp = per_cpu_ptr(nh->rt6i_pcpu, cpu);\n\t\t\t\t\taddrconf_set_nopolicy(*rtp, val);\n\t\t\t\t}\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\t\tspin_unlock(&ifa->lock);\n\t}\n\tread_unlock_bh(&idev->lock);\n}\n\nstatic\nint addrconf_disable_policy(struct ctl_table *ctl, int *valp, int val)\n{\n\tstruct inet6_dev *idev;\n\tstruct net *net;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\t*valp = val;\n\n\tnet = (struct net *)ctl->extra2;\n\tif (valp == &net->ipv6.devconf_dflt->disable_policy) {\n\t\trtnl_unlock();\n\t\treturn 0;\n\t}\n\n\tif (valp == &net->ipv6.devconf_all->disable_policy)  {\n\t\tstruct net_device *dev;\n\n\t\tfor_each_netdev(net, dev) {\n\t\t\tidev = __in6_dev_get(dev);\n\t\t\tif (idev)\n\t\t\t\taddrconf_disable_policy_idev(idev, val);\n\t\t}\n\t} else {\n\t\tidev = (struct inet6_dev *)ctl->extra1;\n\t\taddrconf_disable_policy_idev(idev, val);\n\t}\n\n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic int addrconf_sysctl_disable_policy(struct ctl_table *ctl, int write,\n\t\t\t\t   void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint *valp = ctl->data;\n\tint val = *valp;\n\tloff_t pos = *ppos;\n\tstruct ctl_table lctl;\n\tint ret;\n\n\tlctl = *ctl;\n\tlctl.data = &val;\n\tret = proc_dointvec(&lctl, write, buffer, lenp, ppos);\n\n\tif (write && (*valp != val))\n\t\tret = addrconf_disable_policy(ctl, valp, val);\n\n\tif (ret)\n\t\t*ppos = pos;\n\n\treturn ret;\n}\n\nstatic int minus_one = -1;\nstatic const int two_five_five = 255;\nstatic u32 ioam6_if_id_max = U16_MAX;\n\nstatic const struct ctl_table addrconf_sysctl[] = {\n\t{\n\t\t.procname\t= \"forwarding\",\n\t\t.data\t\t= &ipv6_devconf.forwarding,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= addrconf_sysctl_forward,\n\t},\n\t{\n\t\t.procname\t= \"hop_limit\",\n\t\t.data\t\t= &ipv6_devconf.hop_limit,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= (void *)SYSCTL_ONE,\n\t\t.extra2\t\t= (void *)&two_five_five,\n\t},\n\t{\n\t\t.procname\t= \"mtu\",\n\t\t.data\t\t= &ipv6_devconf.mtu6,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= addrconf_sysctl_mtu,\n\t},\n\t{\n\t\t.procname\t= \"accept_ra\",\n\t\t.data\t\t= &ipv6_devconf.accept_ra,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"accept_redirects\",\n\t\t.data\t\t= &ipv6_devconf.accept_redirects,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"autoconf\",\n\t\t.data\t\t= &ipv6_devconf.autoconf,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"dad_transmits\",\n\t\t.data\t\t= &ipv6_devconf.dad_transmits,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"router_solicitations\",\n\t\t.data\t\t= &ipv6_devconf.rtr_solicits,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= &minus_one,\n\t},\n\t{\n\t\t.procname\t= \"router_solicitation_interval\",\n\t\t.data\t\t= &ipv6_devconf.rtr_solicit_interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"router_solicitation_max_interval\",\n\t\t.data\t\t= &ipv6_devconf.rtr_solicit_max_interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"router_solicitation_delay\",\n\t\t.data\t\t= &ipv6_devconf.rtr_solicit_delay,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"force_mld_version\",\n\t\t.data\t\t= &ipv6_devconf.force_mld_version,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"mldv1_unsolicited_report_interval\",\n\t\t.data\t\t=\n\t\t\t&ipv6_devconf.mldv1_unsolicited_report_interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_ms_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"mldv2_unsolicited_report_interval\",\n\t\t.data\t\t=\n\t\t\t&ipv6_devconf.mldv2_unsolicited_report_interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_ms_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"use_tempaddr\",\n\t\t.data\t\t= &ipv6_devconf.use_tempaddr,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"temp_valid_lft\",\n\t\t.data\t\t= &ipv6_devconf.temp_valid_lft,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"temp_prefered_lft\",\n\t\t.data\t\t= &ipv6_devconf.temp_prefered_lft,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"regen_max_retry\",\n\t\t.data\t\t= &ipv6_devconf.regen_max_retry,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"max_desync_factor\",\n\t\t.data\t\t= &ipv6_devconf.max_desync_factor,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"max_addresses\",\n\t\t.data\t\t= &ipv6_devconf.max_addresses,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"accept_ra_defrtr\",\n\t\t.data\t\t= &ipv6_devconf.accept_ra_defrtr,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"ra_defrtr_metric\",\n\t\t.data\t\t= &ipv6_devconf.ra_defrtr_metric,\n\t\t.maxlen\t\t= sizeof(u32),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_douintvec_minmax,\n\t\t.extra1\t\t= (void *)SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"accept_ra_min_hop_limit\",\n\t\t.data\t\t= &ipv6_devconf.accept_ra_min_hop_limit,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"accept_ra_min_lft\",\n\t\t.data\t\t= &ipv6_devconf.accept_ra_min_lft,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"accept_ra_pinfo\",\n\t\t.data\t\t= &ipv6_devconf.accept_ra_pinfo,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\t{\n\t\t.procname\t= \"accept_ra_rtr_pref\",\n\t\t.data\t\t= &ipv6_devconf.accept_ra_rtr_pref,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"router_probe_interval\",\n\t\t.data\t\t= &ipv6_devconf.rtr_probe_interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n#ifdef CONFIG_IPV6_ROUTE_INFO\n\t{\n\t\t.procname\t= \"accept_ra_rt_info_min_plen\",\n\t\t.data\t\t= &ipv6_devconf.accept_ra_rt_info_min_plen,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"accept_ra_rt_info_max_plen\",\n\t\t.data\t\t= &ipv6_devconf.accept_ra_rt_info_max_plen,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#endif\n\t{\n\t\t.procname\t= \"proxy_ndp\",\n\t\t.data\t\t= &ipv6_devconf.proxy_ndp,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= addrconf_sysctl_proxy_ndp,\n\t},\n\t{\n\t\t.procname\t= \"accept_source_route\",\n\t\t.data\t\t= &ipv6_devconf.accept_source_route,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\t{\n\t\t.procname\t= \"optimistic_dad\",\n\t\t.data\t\t= &ipv6_devconf.optimistic_dad,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler   = proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"use_optimistic\",\n\t\t.data\t\t= &ipv6_devconf.use_optimistic,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n#ifdef CONFIG_IPV6_MROUTE\n\t{\n\t\t.procname\t= \"mc_forwarding\",\n\t\t.data\t\t= &ipv6_devconf.mc_forwarding,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname\t= \"disable_ipv6\",\n\t\t.data\t\t= &ipv6_devconf.disable_ipv6,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= addrconf_sysctl_disable,\n\t},\n\t{\n\t\t.procname\t= \"accept_dad\",\n\t\t.data\t\t= &ipv6_devconf.accept_dad,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"force_tllao\",\n\t\t.data\t\t= &ipv6_devconf.force_tllao,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"ndisc_notify\",\n\t\t.data\t\t= &ipv6_devconf.ndisc_notify,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"suppress_frag_ndisc\",\n\t\t.data\t\t= &ipv6_devconf.suppress_frag_ndisc,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec\n\t},\n\t{\n\t\t.procname\t= \"accept_ra_from_local\",\n\t\t.data\t\t= &ipv6_devconf.accept_ra_from_local,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"accept_ra_mtu\",\n\t\t.data\t\t= &ipv6_devconf.accept_ra_mtu,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"stable_secret\",\n\t\t.data\t\t= &ipv6_devconf.stable_secret,\n\t\t.maxlen\t\t= IPV6_MAX_STRLEN,\n\t\t.mode\t\t= 0600,\n\t\t.proc_handler\t= addrconf_sysctl_stable_secret,\n\t},\n\t{\n\t\t.procname\t= \"use_oif_addrs_only\",\n\t\t.data\t\t= &ipv6_devconf.use_oif_addrs_only,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"ignore_routes_with_linkdown\",\n\t\t.data\t\t= &ipv6_devconf.ignore_routes_with_linkdown,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= addrconf_sysctl_ignore_routes_with_linkdown,\n\t},\n\t{\n\t\t.procname\t= \"drop_unicast_in_l2_multicast\",\n\t\t.data\t\t= &ipv6_devconf.drop_unicast_in_l2_multicast,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"drop_unsolicited_na\",\n\t\t.data\t\t= &ipv6_devconf.drop_unsolicited_na,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"keep_addr_on_down\",\n\t\t.data\t\t= &ipv6_devconf.keep_addr_on_down,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\n\t},\n\t{\n\t\t.procname\t= \"seg6_enabled\",\n\t\t.data\t\t= &ipv6_devconf.seg6_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\t{\n\t\t.procname\t= \"seg6_require_hmac\",\n\t\t.data\t\t= &ipv6_devconf.seg6_require_hmac,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n#endif\n\t{\n\t\t.procname       = \"enhanced_dad\",\n\t\t.data           = &ipv6_devconf.enhanced_dad,\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"addr_gen_mode\",\n\t\t.data\t\t= &ipv6_devconf.addr_gen_mode,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= addrconf_sysctl_addr_gen_mode,\n\t},\n\t{\n\t\t.procname       = \"disable_policy\",\n\t\t.data           = &ipv6_devconf.disable_policy,\n\t\t.maxlen         = sizeof(int),\n\t\t.mode           = 0644,\n\t\t.proc_handler   = addrconf_sysctl_disable_policy,\n\t},\n\t{\n\t\t.procname\t= \"ndisc_tclass\",\n\t\t.data\t\t= &ipv6_devconf.ndisc_tclass,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= (void *)SYSCTL_ZERO,\n\t\t.extra2\t\t= (void *)&two_five_five,\n\t},\n\t{\n\t\t.procname\t= \"rpl_seg_enabled\",\n\t\t.data\t\t= &ipv6_devconf.rpl_seg_enabled,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"ioam6_enabled\",\n\t\t.data\t\t= &ipv6_devconf.ioam6_enabled,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= (void *)SYSCTL_ZERO,\n\t\t.extra2\t\t= (void *)SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"ioam6_id\",\n\t\t.data\t\t= &ipv6_devconf.ioam6_id,\n\t\t.maxlen\t\t= sizeof(u32),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_douintvec_minmax,\n\t\t.extra1\t\t= (void *)SYSCTL_ZERO,\n\t\t.extra2\t\t= (void *)&ioam6_if_id_max,\n\t},\n\t{\n\t\t.procname\t= \"ioam6_id_wide\",\n\t\t.data\t\t= &ipv6_devconf.ioam6_id_wide,\n\t\t.maxlen\t\t= sizeof(u32),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_douintvec,\n\t},\n\t{\n\t\t.procname\t= \"ndisc_evict_nocarrier\",\n\t\t.data\t\t= &ipv6_devconf.ndisc_evict_nocarrier,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= (void *)SYSCTL_ZERO,\n\t\t.extra2\t\t= (void *)SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"accept_untracked_na\",\n\t\t.data\t\t= &ipv6_devconf.accept_untracked_na,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{\n\t\t \n\t}\n};\n\nstatic int __addrconf_sysctl_register(struct net *net, char *dev_name,\n\t\tstruct inet6_dev *idev, struct ipv6_devconf *p)\n{\n\tint i, ifindex;\n\tstruct ctl_table *table;\n\tchar path[sizeof(\"net/ipv6/conf/\") + IFNAMSIZ];\n\n\ttable = kmemdup(addrconf_sysctl, sizeof(addrconf_sysctl), GFP_KERNEL_ACCOUNT);\n\tif (!table)\n\t\tgoto out;\n\n\tfor (i = 0; table[i].data; i++) {\n\t\ttable[i].data += (char *)p - (char *)&ipv6_devconf;\n\t\t \n\t\tif (!table[i].extra1 && !table[i].extra2) {\n\t\t\ttable[i].extra1 = idev;  \n\t\t\ttable[i].extra2 = net;\n\t\t}\n\t}\n\n\tsnprintf(path, sizeof(path), \"net/ipv6/conf/%s\", dev_name);\n\n\tp->sysctl_header = register_net_sysctl_sz(net, path, table,\n\t\t\t\t\t\t  ARRAY_SIZE(addrconf_sysctl));\n\tif (!p->sysctl_header)\n\t\tgoto free;\n\n\tif (!strcmp(dev_name, \"all\"))\n\t\tifindex = NETCONFA_IFINDEX_ALL;\n\telse if (!strcmp(dev_name, \"default\"))\n\t\tifindex = NETCONFA_IFINDEX_DEFAULT;\n\telse\n\t\tifindex = idev->dev->ifindex;\n\tinet6_netconf_notify_devconf(net, RTM_NEWNETCONF, NETCONFA_ALL,\n\t\t\t\t     ifindex, p);\n\treturn 0;\n\nfree:\n\tkfree(table);\nout:\n\treturn -ENOBUFS;\n}\n\nstatic void __addrconf_sysctl_unregister(struct net *net,\n\t\t\t\t\t struct ipv6_devconf *p, int ifindex)\n{\n\tstruct ctl_table *table;\n\n\tif (!p->sysctl_header)\n\t\treturn;\n\n\ttable = p->sysctl_header->ctl_table_arg;\n\tunregister_net_sysctl_table(p->sysctl_header);\n\tp->sysctl_header = NULL;\n\tkfree(table);\n\n\tinet6_netconf_notify_devconf(net, RTM_DELNETCONF, 0, ifindex, NULL);\n}\n\nstatic int addrconf_sysctl_register(struct inet6_dev *idev)\n{\n\tint err;\n\n\tif (!sysctl_dev_name_is_allowed(idev->dev->name))\n\t\treturn -EINVAL;\n\n\terr = neigh_sysctl_register(idev->dev, idev->nd_parms,\n\t\t\t\t    &ndisc_ifinfo_sysctl_change);\n\tif (err)\n\t\treturn err;\n\terr = __addrconf_sysctl_register(dev_net(idev->dev), idev->dev->name,\n\t\t\t\t\t idev, &idev->cnf);\n\tif (err)\n\t\tneigh_sysctl_unregister(idev->nd_parms);\n\n\treturn err;\n}\n\nstatic void addrconf_sysctl_unregister(struct inet6_dev *idev)\n{\n\t__addrconf_sysctl_unregister(dev_net(idev->dev), &idev->cnf,\n\t\t\t\t     idev->dev->ifindex);\n\tneigh_sysctl_unregister(idev->nd_parms);\n}\n\n\n#endif\n\nstatic int __net_init addrconf_init_net(struct net *net)\n{\n\tint err = -ENOMEM;\n\tstruct ipv6_devconf *all, *dflt;\n\n\tspin_lock_init(&net->ipv6.addrconf_hash_lock);\n\tINIT_DEFERRABLE_WORK(&net->ipv6.addr_chk_work, addrconf_verify_work);\n\tnet->ipv6.inet6_addr_lst = kcalloc(IN6_ADDR_HSIZE,\n\t\t\t\t\t   sizeof(struct hlist_head),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!net->ipv6.inet6_addr_lst)\n\t\tgoto err_alloc_addr;\n\n\tall = kmemdup(&ipv6_devconf, sizeof(ipv6_devconf), GFP_KERNEL);\n\tif (!all)\n\t\tgoto err_alloc_all;\n\n\tdflt = kmemdup(&ipv6_devconf_dflt, sizeof(ipv6_devconf_dflt), GFP_KERNEL);\n\tif (!dflt)\n\t\tgoto err_alloc_dflt;\n\n\tif (!net_eq(net, &init_net)) {\n\t\tswitch (net_inherit_devconf()) {\n\t\tcase 1:   \n\t\t\tmemcpy(all, init_net.ipv6.devconf_all,\n\t\t\t       sizeof(ipv6_devconf));\n\t\t\tmemcpy(dflt, init_net.ipv6.devconf_dflt,\n\t\t\t       sizeof(ipv6_devconf_dflt));\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tmemcpy(all, current->nsproxy->net_ns->ipv6.devconf_all,\n\t\t\t       sizeof(ipv6_devconf));\n\t\t\tmemcpy(dflt,\n\t\t\t       current->nsproxy->net_ns->ipv6.devconf_dflt,\n\t\t\t       sizeof(ipv6_devconf_dflt));\n\t\t\tbreak;\n\t\tcase 0:\n\t\tcase 2:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tdflt->autoconf = ipv6_defaults.autoconf;\n\tdflt->disable_ipv6 = ipv6_defaults.disable_ipv6;\n\n\tdflt->stable_secret.initialized = false;\n\tall->stable_secret.initialized = false;\n\n\tnet->ipv6.devconf_all = all;\n\tnet->ipv6.devconf_dflt = dflt;\n\n#ifdef CONFIG_SYSCTL\n\terr = __addrconf_sysctl_register(net, \"all\", NULL, all);\n\tif (err < 0)\n\t\tgoto err_reg_all;\n\n\terr = __addrconf_sysctl_register(net, \"default\", NULL, dflt);\n\tif (err < 0)\n\t\tgoto err_reg_dflt;\n#endif\n\treturn 0;\n\n#ifdef CONFIG_SYSCTL\nerr_reg_dflt:\n\t__addrconf_sysctl_unregister(net, all, NETCONFA_IFINDEX_ALL);\nerr_reg_all:\n\tkfree(dflt);\n\tnet->ipv6.devconf_dflt = NULL;\n#endif\nerr_alloc_dflt:\n\tkfree(all);\n\tnet->ipv6.devconf_all = NULL;\nerr_alloc_all:\n\tkfree(net->ipv6.inet6_addr_lst);\nerr_alloc_addr:\n\treturn err;\n}\n\nstatic void __net_exit addrconf_exit_net(struct net *net)\n{\n\tint i;\n\n#ifdef CONFIG_SYSCTL\n\t__addrconf_sysctl_unregister(net, net->ipv6.devconf_dflt,\n\t\t\t\t     NETCONFA_IFINDEX_DEFAULT);\n\t__addrconf_sysctl_unregister(net, net->ipv6.devconf_all,\n\t\t\t\t     NETCONFA_IFINDEX_ALL);\n#endif\n\tkfree(net->ipv6.devconf_dflt);\n\tnet->ipv6.devconf_dflt = NULL;\n\tkfree(net->ipv6.devconf_all);\n\tnet->ipv6.devconf_all = NULL;\n\n\tcancel_delayed_work_sync(&net->ipv6.addr_chk_work);\n\t \n\tfor (i = 0; i < IN6_ADDR_HSIZE; i++)\n\t\tWARN_ON_ONCE(!hlist_empty(&net->ipv6.inet6_addr_lst[i]));\n\n\tkfree(net->ipv6.inet6_addr_lst);\n\tnet->ipv6.inet6_addr_lst = NULL;\n}\n\nstatic struct pernet_operations addrconf_ops = {\n\t.init = addrconf_init_net,\n\t.exit = addrconf_exit_net,\n};\n\nstatic struct rtnl_af_ops inet6_ops __read_mostly = {\n\t.family\t\t  = AF_INET6,\n\t.fill_link_af\t  = inet6_fill_link_af,\n\t.get_link_af_size = inet6_get_link_af_size,\n\t.validate_link_af = inet6_validate_link_af,\n\t.set_link_af\t  = inet6_set_link_af,\n};\n\n \n\nint __init addrconf_init(void)\n{\n\tstruct inet6_dev *idev;\n\tint err;\n\n\terr = ipv6_addr_label_init();\n\tif (err < 0) {\n\t\tpr_crit(\"%s: cannot initialize default policy table: %d\\n\",\n\t\t\t__func__, err);\n\t\tgoto out;\n\t}\n\n\terr = register_pernet_subsys(&addrconf_ops);\n\tif (err < 0)\n\t\tgoto out_addrlabel;\n\n\taddrconf_wq = create_workqueue(\"ipv6_addrconf\");\n\tif (!addrconf_wq) {\n\t\terr = -ENOMEM;\n\t\tgoto out_nowq;\n\t}\n\n\trtnl_lock();\n\tidev = ipv6_add_dev(blackhole_netdev);\n\trtnl_unlock();\n\tif (IS_ERR(idev)) {\n\t\terr = PTR_ERR(idev);\n\t\tgoto errlo;\n\t}\n\n\tip6_route_init_special_entries();\n\n\tregister_netdevice_notifier(&ipv6_dev_notf);\n\n\taddrconf_verify(&init_net);\n\n\trtnl_af_register(&inet6_ops);\n\n\terr = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_GETLINK,\n\t\t\t\t   NULL, inet6_dump_ifinfo, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_NEWADDR,\n\t\t\t\t   inet6_rtm_newaddr, NULL, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\terr = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_DELADDR,\n\t\t\t\t   inet6_rtm_deladdr, NULL, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\terr = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_GETADDR,\n\t\t\t\t   inet6_rtm_getaddr, inet6_dump_ifaddr,\n\t\t\t\t   RTNL_FLAG_DOIT_UNLOCKED);\n\tif (err < 0)\n\t\tgoto errout;\n\terr = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_GETMULTICAST,\n\t\t\t\t   NULL, inet6_dump_ifmcaddr, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\terr = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_GETANYCAST,\n\t\t\t\t   NULL, inet6_dump_ifacaddr, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\terr = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_GETNETCONF,\n\t\t\t\t   inet6_netconf_get_devconf,\n\t\t\t\t   inet6_netconf_dump_devconf,\n\t\t\t\t   RTNL_FLAG_DOIT_UNLOCKED);\n\tif (err < 0)\n\t\tgoto errout;\n\terr = ipv6_addr_label_rtnl_register();\n\tif (err < 0)\n\t\tgoto errout;\n\n\treturn 0;\nerrout:\n\trtnl_unregister_all(PF_INET6);\n\trtnl_af_unregister(&inet6_ops);\n\tunregister_netdevice_notifier(&ipv6_dev_notf);\nerrlo:\n\tdestroy_workqueue(addrconf_wq);\nout_nowq:\n\tunregister_pernet_subsys(&addrconf_ops);\nout_addrlabel:\n\tipv6_addr_label_cleanup();\nout:\n\treturn err;\n}\n\nvoid addrconf_cleanup(void)\n{\n\tstruct net_device *dev;\n\n\tunregister_netdevice_notifier(&ipv6_dev_notf);\n\tunregister_pernet_subsys(&addrconf_ops);\n\tipv6_addr_label_cleanup();\n\n\trtnl_af_unregister(&inet6_ops);\n\n\trtnl_lock();\n\n\t \n\tfor_each_netdev(&init_net, dev) {\n\t\tif (__in6_dev_get(dev) == NULL)\n\t\t\tcontinue;\n\t\taddrconf_ifdown(dev, true);\n\t}\n\taddrconf_ifdown(init_net.loopback_dev, true);\n\n\trtnl_unlock();\n\n\tdestroy_workqueue(addrconf_wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}