{
  "module_name": "netfilter.c",
  "hash_id": "1237cbed1f43b46bfef7765938fa7498cc5e583e3057f64b85175561c100de09",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ipv6.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/export.h>\n#include <net/addrconf.h>\n#include <net/dst.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/xfrm.h>\n#include <net/netfilter/nf_queue.h>\n#include <net/netfilter/nf_conntrack_bridge.h>\n#include <net/netfilter/ipv6/nf_defrag_ipv6.h>\n#include \"../bridge/br_private.h\"\n\nint ip6_route_me_harder(struct net *net, struct sock *sk_partial, struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct sock *sk = sk_to_full_sk(sk_partial);\n\tstruct net_device *dev = skb_dst(skb)->dev;\n\tstruct flow_keys flkeys;\n\tunsigned int hh_len;\n\tstruct dst_entry *dst;\n\tint strict = (ipv6_addr_type(&iph->daddr) &\n\t\t      (IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL));\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_l3mdev = l3mdev_master_ifindex(dev),\n\t\t.flowi6_mark = skb->mark,\n\t\t.flowi6_uid = sock_net_uid(net, sk),\n\t\t.daddr = iph->daddr,\n\t\t.saddr = iph->saddr,\n\t};\n\tint err;\n\n\tif (sk && sk->sk_bound_dev_if)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\telse if (strict)\n\t\tfl6.flowi6_oif = dev->ifindex;\n\n\tfib6_rules_early_flow_dissect(net, skb, &fl6, &flkeys);\n\tdst = ip6_route_output(net, sk, &fl6);\n\terr = dst->error;\n\tif (err) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTNOROUTES);\n\t\tnet_dbg_ratelimited(\"ip6_route_me_harder: No more route\\n\");\n\t\tdst_release(dst);\n\t\treturn err;\n\t}\n\n\t \n\tskb_dst_drop(skb);\n\n\tskb_dst_set(skb, dst);\n\n#ifdef CONFIG_XFRM\n\tif (!(IP6CB(skb)->flags & IP6SKB_XFRM_TRANSFORMED) &&\n\t    xfrm_decode_session(skb, flowi6_to_flowi(&fl6), AF_INET6) == 0) {\n\t\tskb_dst_set(skb, NULL);\n\t\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), sk, 0);\n\t\tif (IS_ERR(dst))\n\t\t\treturn PTR_ERR(dst);\n\t\tskb_dst_set(skb, dst);\n\t}\n#endif\n\n\t \n\thh_len = skb_dst(skb)->dev->hard_header_len;\n\tif (skb_headroom(skb) < hh_len &&\n\t    pskb_expand_head(skb, HH_DATA_ALIGN(hh_len - skb_headroom(skb)),\n\t\t\t     0, GFP_ATOMIC))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ip6_route_me_harder);\n\nstatic int nf_ip6_reroute(struct sk_buff *skb,\n\t\t\t  const struct nf_queue_entry *entry)\n{\n\tstruct ip6_rt_info *rt_info = nf_queue_entry_reroute(entry);\n\n\tif (entry->state.hook == NF_INET_LOCAL_OUT) {\n\t\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\t\tif (!ipv6_addr_equal(&iph->daddr, &rt_info->daddr) ||\n\t\t    !ipv6_addr_equal(&iph->saddr, &rt_info->saddr) ||\n\t\t    skb->mark != rt_info->mark)\n\t\t\treturn ip6_route_me_harder(entry->state.net, entry->state.sk, skb);\n\t}\n\treturn 0;\n}\n\nint __nf_ip6_route(struct net *net, struct dst_entry **dst,\n\t\t   struct flowi *fl, bool strict)\n{\n\tstatic const struct ipv6_pinfo fake_pinfo;\n\tstatic const struct inet_sock fake_sk = {\n\t\t \n\t\t.sk.sk_bound_dev_if = 1,\n\t\t.pinet6 = (struct ipv6_pinfo *) &fake_pinfo,\n\t};\n\tconst void *sk = strict ? &fake_sk : NULL;\n\tstruct dst_entry *result;\n\tint err;\n\n\tresult = ip6_route_output(net, sk, &fl->u.ip6);\n\terr = result->error;\n\tif (err)\n\t\tdst_release(result);\n\telse\n\t\t*dst = result;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__nf_ip6_route);\n\nint br_ip6_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,\n\t\t    struct nf_bridge_frag_data *data,\n\t\t    int (*output)(struct net *, struct sock *sk,\n\t\t\t\t  const struct nf_bridge_frag_data *data,\n\t\t\t\t  struct sk_buff *))\n{\n\tint frag_max_size = BR_INPUT_SKB_CB(skb)->frag_max_size;\n\tbool mono_delivery_time = skb->mono_delivery_time;\n\tktime_t tstamp = skb->tstamp;\n\tstruct ip6_frag_state state;\n\tu8 *prevhdr, nexthdr = 0;\n\tunsigned int mtu, hlen;\n\tint hroom, err = 0;\n\t__be32 frag_id;\n\n\terr = ip6_find_1stfragopt(skb, &prevhdr);\n\tif (err < 0)\n\t\tgoto blackhole;\n\thlen = err;\n\tnexthdr = *prevhdr;\n\n\tmtu = skb->dev->mtu;\n\tif (frag_max_size > mtu ||\n\t    frag_max_size < IPV6_MIN_MTU)\n\t\tgoto blackhole;\n\n\tmtu = frag_max_size;\n\tif (mtu < hlen + sizeof(struct frag_hdr) + 8)\n\t\tgoto blackhole;\n\tmtu -= hlen + sizeof(struct frag_hdr);\n\n\tfrag_id = ipv6_select_ident(net, &ipv6_hdr(skb)->daddr,\n\t\t\t\t    &ipv6_hdr(skb)->saddr);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    (err = skb_checksum_help(skb)))\n\t\tgoto blackhole;\n\n\throom = LL_RESERVED_SPACE(skb->dev);\n\tif (skb_has_frag_list(skb)) {\n\t\tunsigned int first_len = skb_pagelen(skb);\n\t\tstruct ip6_fraglist_iter iter;\n\t\tstruct sk_buff *frag2;\n\n\t\tif (first_len - hlen > mtu ||\n\t\t    skb_headroom(skb) < (hroom + sizeof(struct frag_hdr)))\n\t\t\tgoto blackhole;\n\n\t\tif (skb_cloned(skb))\n\t\t\tgoto slow_path;\n\n\t\tskb_walk_frags(skb, frag2) {\n\t\t\tif (frag2->len > mtu ||\n\t\t\t    skb_headroom(frag2) < (hlen + hroom + sizeof(struct frag_hdr)))\n\t\t\t\tgoto blackhole;\n\n\t\t\t \n\t\t\tif (skb_shared(frag2))\n\t\t\t\tgoto slow_path;\n\t\t}\n\n\t\terr = ip6_fraglist_init(skb, hlen, prevhdr, nexthdr, frag_id,\n\t\t\t\t\t&iter);\n\t\tif (err < 0)\n\t\t\tgoto blackhole;\n\n\t\tfor (;;) {\n\t\t\t \n\t\t\tif (iter.frag)\n\t\t\t\tip6_fraglist_prepare(skb, &iter);\n\n\t\t\tskb_set_delivery_time(skb, tstamp, mono_delivery_time);\n\t\t\terr = output(net, sk, data, skb);\n\t\t\tif (err || !iter.frag)\n\t\t\t\tbreak;\n\n\t\t\tskb = ip6_fraglist_next(&iter);\n\t\t}\n\n\t\tkfree(iter.tmp_hdr);\n\t\tif (!err)\n\t\t\treturn 0;\n\n\t\tkfree_skb_list(iter.frag);\n\t\treturn err;\n\t}\nslow_path:\n\t \n\tip6_frag_init(skb, hlen, mtu, skb->dev->needed_tailroom,\n\t\t      LL_RESERVED_SPACE(skb->dev), prevhdr, nexthdr, frag_id,\n\t\t      &state);\n\n\twhile (state.left > 0) {\n\t\tstruct sk_buff *skb2;\n\n\t\tskb2 = ip6_frag_next(skb, &state);\n\t\tif (IS_ERR(skb2)) {\n\t\t\terr = PTR_ERR(skb2);\n\t\t\tgoto blackhole;\n\t\t}\n\n\t\tskb_set_delivery_time(skb2, tstamp, mono_delivery_time);\n\t\terr = output(net, sk, data, skb2);\n\t\tif (err)\n\t\t\tgoto blackhole;\n\t}\n\tconsume_skb(skb);\n\treturn err;\n\nblackhole:\n\tkfree_skb(skb);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(br_ip6_fragment);\n\nstatic const struct nf_ipv6_ops ipv6ops = {\n#if IS_MODULE(CONFIG_IPV6)\n\t.chk_addr\t\t= ipv6_chk_addr,\n\t.route_me_harder\t= ip6_route_me_harder,\n\t.dev_get_saddr\t\t= ipv6_dev_get_saddr,\n\t.route\t\t\t= __nf_ip6_route,\n#if IS_ENABLED(CONFIG_SYN_COOKIES)\n\t.cookie_init_sequence\t= __cookie_v6_init_sequence,\n\t.cookie_v6_check\t= __cookie_v6_check,\n#endif\n#endif\n\t.route_input\t\t= ip6_route_input,\n\t.fragment\t\t= ip6_fragment,\n\t.reroute\t\t= nf_ip6_reroute,\n#if IS_MODULE(CONFIG_IPV6)\n\t.br_fragment\t\t= br_ip6_fragment,\n#endif\n};\n\nint __init ipv6_netfilter_init(void)\n{\n\tRCU_INIT_POINTER(nf_ipv6_ops, &ipv6ops);\n\treturn 0;\n}\n\n \nvoid ipv6_netfilter_fini(void)\n{\n\tRCU_INIT_POINTER(nf_ipv6_ops, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}