{
  "module_name": "icmp.c",
  "hash_id": "991e41eda389dc200e24e611ac1c9d3bb2192997957332692715d0461c9e3e72",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/icmp.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/netfilter.h>\n#include <linux/slab.h>\n\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/icmpv6.h>\n\n#include <net/ip.h>\n#include <net/sock.h>\n\n#include <net/ipv6.h>\n#include <net/ip6_checksum.h>\n#include <net/ping.h>\n#include <net/protocol.h>\n#include <net/raw.h>\n#include <net/rawv6.h>\n#include <net/seg6.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/icmp.h>\n#include <net/xfrm.h>\n#include <net/inet_common.h>\n#include <net/dsfield.h>\n#include <net/l3mdev.h>\n\n#include <linux/uaccess.h>\n\nstatic DEFINE_PER_CPU(struct sock *, ipv6_icmp_sk);\n\nstatic int icmpv6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\t \n\tstruct icmp6hdr *icmp6 = (struct icmp6hdr *) (skb->data + offset);\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (type == ICMPV6_PKT_TOOBIG)\n\t\tip6_update_pmtu(skb, net, info, skb->dev->ifindex, 0, sock_net_uid(net, NULL));\n\telse if (type == NDISC_REDIRECT)\n\t\tip6_redirect(skb, net, skb->dev->ifindex, 0,\n\t\t\t     sock_net_uid(net, NULL));\n\n\tif (!(type & ICMPV6_INFOMSG_MASK))\n\t\tif (icmp6->icmp6_type == ICMPV6_ECHO_REQUEST)\n\t\t\tping_err(skb, offset, ntohl(info));\n\n\treturn 0;\n}\n\nstatic int icmpv6_rcv(struct sk_buff *skb);\n\nstatic const struct inet6_protocol icmpv6_protocol = {\n\t.handler\t=\ticmpv6_rcv,\n\t.err_handler\t=\ticmpv6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\n \nstatic struct sock *icmpv6_xmit_lock(struct net *net)\n{\n\tstruct sock *sk;\n\n\tsk = this_cpu_read(ipv6_icmp_sk);\n\tif (unlikely(!spin_trylock(&sk->sk_lock.slock))) {\n\t\t \n\t\treturn NULL;\n\t}\n\tsock_net_set(sk, net);\n\treturn sk;\n}\n\nstatic void icmpv6_xmit_unlock(struct sock *sk)\n{\n\tsock_net_set(sk, &init_net);\n\tspin_unlock(&sk->sk_lock.slock);\n}\n\n \n\nstatic bool is_ineligible(const struct sk_buff *skb)\n{\n\tint ptr = (u8 *)(ipv6_hdr(skb) + 1) - skb->data;\n\tint len = skb->len - ptr;\n\t__u8 nexthdr = ipv6_hdr(skb)->nexthdr;\n\t__be16 frag_off;\n\n\tif (len < 0)\n\t\treturn true;\n\n\tptr = ipv6_skip_exthdr(skb, ptr, &nexthdr, &frag_off);\n\tif (ptr < 0)\n\t\treturn false;\n\tif (nexthdr == IPPROTO_ICMPV6) {\n\t\tu8 _type, *tp;\n\t\ttp = skb_header_pointer(skb,\n\t\t\tptr+offsetof(struct icmp6hdr, icmp6_type),\n\t\t\tsizeof(_type), &_type);\n\n\t\t \n\t\tif (!tp && frag_off != 0)\n\t\t\treturn false;\n\t\telse if (!tp || !(*tp & ICMPV6_INFOMSG_MASK))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool icmpv6_mask_allow(struct net *net, int type)\n{\n\tif (type > ICMPV6_MSG_MAX)\n\t\treturn true;\n\n\t \n\tif (!test_bit(type, net->ipv6.sysctl.icmpv6_ratemask))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool icmpv6_global_allow(struct net *net, int type)\n{\n\tif (icmpv6_mask_allow(net, type))\n\t\treturn true;\n\n\tif (icmp_global_allow())\n\t\treturn true;\n\n\t__ICMP_INC_STATS(net, ICMP_MIB_RATELIMITGLOBAL);\n\treturn false;\n}\n\n \nstatic bool icmpv6_xrlim_allow(struct sock *sk, u8 type,\n\t\t\t       struct flowi6 *fl6)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct dst_entry *dst;\n\tbool res = false;\n\n\tif (icmpv6_mask_allow(net, type))\n\t\treturn true;\n\n\t \n\tdst = ip6_route_output(net, sk, fl6);\n\tif (dst->error) {\n\t\tIP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t      IPSTATS_MIB_OUTNOROUTES);\n\t} else if (dst->dev && (dst->dev->flags&IFF_LOOPBACK)) {\n\t\tres = true;\n\t} else {\n\t\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\t\tint tmo = net->ipv6.sysctl.icmpv6_time;\n\t\tstruct inet_peer *peer;\n\n\t\t \n\t\tif (rt->rt6i_dst.plen < 128)\n\t\t\ttmo >>= ((128 - rt->rt6i_dst.plen)>>5);\n\n\t\tpeer = inet_getpeer_v6(net->ipv6.peers, &fl6->daddr, 1);\n\t\tres = inet_peer_xrlim_allow(peer, tmo);\n\t\tif (peer)\n\t\t\tinet_putpeer(peer);\n\t}\n\tif (!res)\n\t\t__ICMP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\t  ICMP6_MIB_RATELIMITHOST);\n\tdst_release(dst);\n\treturn res;\n}\n\nstatic bool icmpv6_rt_has_prefsrc(struct sock *sk, u8 type,\n\t\t\t\t  struct flowi6 *fl6)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct dst_entry *dst;\n\tbool res = false;\n\n\tdst = ip6_route_output(net, sk, fl6);\n\tif (!dst->error) {\n\t\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\t\tstruct in6_addr prefsrc;\n\n\t\trt6_get_prefsrc(rt, &prefsrc);\n\t\tres = !ipv6_addr_any(&prefsrc);\n\t}\n\tdst_release(dst);\n\treturn res;\n}\n\n \n\nstatic bool opt_unrec(struct sk_buff *skb, __u32 offset)\n{\n\tu8 _optval, *op;\n\n\toffset += skb_network_offset(skb);\n\top = skb_header_pointer(skb, offset, sizeof(_optval), &_optval);\n\tif (!op)\n\t\treturn true;\n\treturn (*op & 0xC0) == 0x80;\n}\n\nvoid icmpv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\tstruct icmp6hdr *thdr, int len)\n{\n\tstruct sk_buff *skb;\n\tstruct icmp6hdr *icmp6h;\n\n\tskb = skb_peek(&sk->sk_write_queue);\n\tif (!skb)\n\t\treturn;\n\n\ticmp6h = icmp6_hdr(skb);\n\tmemcpy(icmp6h, thdr, sizeof(struct icmp6hdr));\n\ticmp6h->icmp6_cksum = 0;\n\n\tif (skb_queue_len(&sk->sk_write_queue) == 1) {\n\t\tskb->csum = csum_partial(icmp6h,\n\t\t\t\t\tsizeof(struct icmp6hdr), skb->csum);\n\t\ticmp6h->icmp6_cksum = csum_ipv6_magic(&fl6->saddr,\n\t\t\t\t\t\t      &fl6->daddr,\n\t\t\t\t\t\t      len, fl6->flowi6_proto,\n\t\t\t\t\t\t      skb->csum);\n\t} else {\n\t\t__wsum tmp_csum = 0;\n\n\t\tskb_queue_walk(&sk->sk_write_queue, skb) {\n\t\t\ttmp_csum = csum_add(tmp_csum, skb->csum);\n\t\t}\n\n\t\ttmp_csum = csum_partial(icmp6h,\n\t\t\t\t\tsizeof(struct icmp6hdr), tmp_csum);\n\t\ticmp6h->icmp6_cksum = csum_ipv6_magic(&fl6->saddr,\n\t\t\t\t\t\t      &fl6->daddr,\n\t\t\t\t\t\t      len, fl6->flowi6_proto,\n\t\t\t\t\t\t      tmp_csum);\n\t}\n\tip6_push_pending_frames(sk);\n}\n\nstruct icmpv6_msg {\n\tstruct sk_buff\t*skb;\n\tint\t\toffset;\n\tuint8_t\t\ttype;\n};\n\nstatic int icmpv6_getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb)\n{\n\tstruct icmpv6_msg *msg = (struct icmpv6_msg *) from;\n\tstruct sk_buff *org_skb = msg->skb;\n\t__wsum csum;\n\n\tcsum = skb_copy_and_csum_bits(org_skb, msg->offset + offset,\n\t\t\t\t      to, len);\n\tskb->csum = csum_block_add(skb->csum, csum, odd);\n\tif (!(msg->type & ICMPV6_INFOMSG_MASK))\n\t\tnf_ct_attach(skb, org_skb);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\nstatic void mip6_addr_swap(struct sk_buff *skb, const struct inet6_skb_parm *opt)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct ipv6_destopt_hao *hao;\n\tint off;\n\n\tif (opt->dsthao) {\n\t\toff = ipv6_find_tlv(skb, opt->dsthao, IPV6_TLV_HAO);\n\t\tif (likely(off >= 0)) {\n\t\t\thao = (struct ipv6_destopt_hao *)\n\t\t\t\t\t(skb_network_header(skb) + off);\n\t\t\tswap(iph->saddr, hao->addr);\n\t\t}\n\t}\n}\n#else\nstatic inline void mip6_addr_swap(struct sk_buff *skb, const struct inet6_skb_parm *opt) {}\n#endif\n\nstatic struct dst_entry *icmpv6_route_lookup(struct net *net,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     struct sock *sk,\n\t\t\t\t\t     struct flowi6 *fl6)\n{\n\tstruct dst_entry *dst, *dst2;\n\tstruct flowi6 fl2;\n\tint err;\n\n\terr = ip6_dst_lookup(net, sk, &dst, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t \n\tif (!READ_ONCE(net->ipv6.sysctl.icmpv6_error_anycast_as_unicast) &&\n\t    ipv6_anycast_destination(dst, &fl6->daddr)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: acast source\\n\");\n\t\tdst_release(dst);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tdst2 = dst;\n\n\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(fl6), sk, 0);\n\tif (!IS_ERR(dst)) {\n\t\tif (dst != dst2)\n\t\t\treturn dst;\n\t} else {\n\t\tif (PTR_ERR(dst) == -EPERM)\n\t\t\tdst = NULL;\n\t\telse\n\t\t\treturn dst;\n\t}\n\n\terr = xfrm_decode_session_reverse(skb, flowi6_to_flowi(&fl2), AF_INET6);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\terr = ip6_dst_lookup(net, sk, &dst2, &fl2);\n\tif (err)\n\t\tgoto relookup_failed;\n\n\tdst2 = xfrm_lookup(net, dst2, flowi6_to_flowi(&fl2), sk, XFRM_LOOKUP_ICMP);\n\tif (!IS_ERR(dst2)) {\n\t\tdst_release(dst);\n\t\tdst = dst2;\n\t} else {\n\t\terr = PTR_ERR(dst2);\n\t\tif (err == -EPERM) {\n\t\t\tdst_release(dst);\n\t\t\treturn dst2;\n\t\t} else\n\t\t\tgoto relookup_failed;\n\t}\n\nrelookup_failed:\n\tif (dst)\n\t\treturn dst;\n\treturn ERR_PTR(err);\n}\n\nstatic struct net_device *icmp6_dev(const struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\n\t \n\tif (unlikely(dev->ifindex == LOOPBACK_IFINDEX || netif_is_l3_master(skb->dev))) {\n\t\tconst struct rt6_info *rt6 = skb_rt6_info(skb);\n\n\t\t \n\t\tif (rt6 && rt6->rt6i_idev)\n\t\t\tdev = rt6->rt6i_idev->dev;\n\t}\n\n\treturn dev;\n}\n\nstatic int icmp6_iif(const struct sk_buff *skb)\n{\n\treturn icmp6_dev(skb)->ifindex;\n}\n\n \nvoid icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info,\n\t\tconst struct in6_addr *force_saddr,\n\t\tconst struct inet6_skb_parm *parm)\n{\n\tstruct inet6_dev *idev = NULL;\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct sock *sk;\n\tstruct net *net;\n\tstruct ipv6_pinfo *np;\n\tconst struct in6_addr *saddr = NULL;\n\tstruct dst_entry *dst;\n\tstruct icmp6hdr tmp_hdr;\n\tstruct flowi6 fl6;\n\tstruct icmpv6_msg msg;\n\tstruct ipcm6_cookie ipc6;\n\tint iif = 0;\n\tint addr_type = 0;\n\tint len;\n\tu32 mark;\n\n\tif ((u8 *)hdr < skb->head ||\n\t    (skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb))\n\t\treturn;\n\n\tif (!skb->dev)\n\t\treturn;\n\tnet = dev_net(skb->dev);\n\tmark = IP6_REPLY_MARK(net, skb->mark);\n\t \n\taddr_type = ipv6_addr_type(&hdr->daddr);\n\n\tif (ipv6_chk_addr(net, &hdr->daddr, skb->dev, 0) ||\n\t    ipv6_chk_acast_addr_src(net, skb->dev, &hdr->daddr))\n\t\tsaddr = &hdr->daddr;\n\n\t \n\n\tif (addr_type & IPV6_ADDR_MULTICAST || skb->pkt_type != PACKET_HOST) {\n\t\tif (type != ICMPV6_PKT_TOOBIG &&\n\t\t    !(type == ICMPV6_PARAMPROB &&\n\t\t      code == ICMPV6_UNK_OPTION &&\n\t\t      (opt_unrec(skb, info))))\n\t\t\treturn;\n\n\t\tsaddr = NULL;\n\t}\n\n\taddr_type = ipv6_addr_type(&hdr->saddr);\n\n\t \n\n\tif (__ipv6_addr_needs_scope_id(addr_type)) {\n\t\tiif = icmp6_iif(skb);\n\t} else {\n\t\t \n\t\tiif = l3mdev_master_ifindex(skb->dev);\n\t}\n\n\t \n\tif ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\treturn;\n\t}\n\n\t \n\tif (is_ineligible(skb)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: no reply to icmp error [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\treturn;\n\t}\n\n\t \n\tlocal_bh_disable();\n\n\t \n\tif (!(skb->dev->flags & IFF_LOOPBACK) && !icmpv6_global_allow(net, type))\n\t\tgoto out_bh_enable;\n\n\tmip6_addr_swap(skb, parm);\n\n\tsk = icmpv6_xmit_lock(net);\n\tif (!sk)\n\t\tgoto out_bh_enable;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_ICMPV6;\n\tfl6.daddr = hdr->saddr;\n\tif (force_saddr)\n\t\tsaddr = force_saddr;\n\tif (saddr) {\n\t\tfl6.saddr = *saddr;\n\t} else if (!icmpv6_rt_has_prefsrc(sk, type, &fl6)) {\n\t\t \n\t\tstruct net_device *in_netdev;\n\n\t\tin_netdev = dev_get_by_index(net, parm->iif);\n\t\tif (in_netdev) {\n\t\t\tipv6_dev_get_saddr(net, in_netdev, &fl6.daddr,\n\t\t\t\t\t   inet6_sk(sk)->srcprefs,\n\t\t\t\t\t   &fl6.saddr);\n\t\t\tdev_put(in_netdev);\n\t\t}\n\t}\n\tfl6.flowi6_mark = mark;\n\tfl6.flowi6_oif = iif;\n\tfl6.fl6_icmp_type = type;\n\tfl6.fl6_icmp_code = code;\n\tfl6.flowi6_uid = sock_net_uid(net, NULL);\n\tfl6.mp_hash = rt6_multipath_hash(net, &fl6, skb, NULL);\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi_common(&fl6));\n\n\tnp = inet6_sk(sk);\n\n\tif (!icmpv6_xrlim_allow(sk, type, &fl6))\n\t\tgoto out;\n\n\ttmp_hdr.icmp6_type = type;\n\ttmp_hdr.icmp6_code = code;\n\ttmp_hdr.icmp6_cksum = 0;\n\ttmp_hdr.icmp6_pointer = htonl(info);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tipcm6_init_sk(&ipc6, np);\n\tipc6.sockc.mark = mark;\n\tfl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);\n\n\tdst = icmpv6_route_lookup(net, skb, sk, &fl6);\n\tif (IS_ERR(dst))\n\t\tgoto out;\n\n\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tmsg.skb = skb;\n\tmsg.offset = skb_network_offset(skb);\n\tmsg.type = type;\n\n\tlen = skb->len - msg.offset;\n\tlen = min_t(unsigned int, len, IPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(struct icmp6hdr));\n\tif (len < 0) {\n\t\tnet_dbg_ratelimited(\"icmp: len problem [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);\n\t\tgoto out_dst_release;\n\t}\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(skb->dev);\n\n\tif (ip6_append_data(sk, icmpv6_getfrag, &msg,\n\t\t\t    len + sizeof(struct icmp6hdr),\n\t\t\t    sizeof(struct icmp6hdr),\n\t\t\t    &ipc6, &fl6, (struct rt6_info *)dst,\n\t\t\t    MSG_DONTWAIT)) {\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS);\n\t\tip6_flush_pending_frames(sk);\n\t} else {\n\t\ticmpv6_push_pending_frames(sk, &fl6, &tmp_hdr,\n\t\t\t\t\t   len + sizeof(struct icmp6hdr));\n\t}\n\trcu_read_unlock();\nout_dst_release:\n\tdst_release(dst);\nout:\n\ticmpv6_xmit_unlock(sk);\nout_bh_enable:\n\tlocal_bh_enable();\n}\nEXPORT_SYMBOL(icmp6_send);\n\n \nvoid icmpv6_param_prob_reason(struct sk_buff *skb, u8 code, int pos,\n\t\t\t      enum skb_drop_reason reason)\n{\n\ticmp6_send(skb, ICMPV6_PARAMPROB, code, pos, NULL, IP6CB(skb));\n\tkfree_skb_reason(skb, reason);\n}\n\n \nint ip6_err_gen_icmpv6_unreach(struct sk_buff *skb, int nhs, int type,\n\t\t\t       unsigned int data_len)\n{\n\tstruct in6_addr temp_saddr;\n\tstruct rt6_info *rt;\n\tstruct sk_buff *skb2;\n\tu32 info = 0;\n\n\tif (!pskb_may_pull(skb, nhs + sizeof(struct ipv6hdr) + 8))\n\t\treturn 1;\n\n\t \n\tif (data_len < 128 || (data_len & 7) || skb->len < data_len)\n\t\tdata_len = 0;\n\n\tskb2 = data_len ? skb_copy(skb, GFP_ATOMIC) : skb_clone(skb, GFP_ATOMIC);\n\n\tif (!skb2)\n\t\treturn 1;\n\n\tskb_dst_drop(skb2);\n\tskb_pull(skb2, nhs);\n\tskb_reset_network_header(skb2);\n\n\trt = rt6_lookup(dev_net(skb->dev), &ipv6_hdr(skb2)->saddr, NULL, 0,\n\t\t\tskb, 0);\n\n\tif (rt && rt->dst.dev)\n\t\tskb2->dev = rt->dst.dev;\n\n\tipv6_addr_set_v4mapped(ip_hdr(skb)->saddr, &temp_saddr);\n\n\tif (data_len) {\n\t\t \n\t\t__skb_push(skb2, nhs);\n\t\tskb_reset_network_header(skb2);\n\t\tmemmove(skb2->data, skb2->data + nhs, data_len - nhs);\n\t\tmemset(skb2->data + data_len - nhs, 0, nhs);\n\t\t \n\t\tinfo = (data_len/8) << 24;\n\t}\n\tif (type == ICMP_TIME_EXCEEDED)\n\t\ticmp6_send(skb2, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT,\n\t\t\t   info, &temp_saddr, IP6CB(skb2));\n\telse\n\t\ticmp6_send(skb2, ICMPV6_DEST_UNREACH, ICMPV6_ADDR_UNREACH,\n\t\t\t   info, &temp_saddr, IP6CB(skb2));\n\tif (rt)\n\t\tip6_rt_put(rt);\n\n\tkfree_skb(skb2);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ip6_err_gen_icmpv6_unreach);\n\nstatic enum skb_drop_reason icmpv6_echo_reply(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tstruct inet6_dev *idev;\n\tstruct ipv6_pinfo *np;\n\tconst struct in6_addr *saddr = NULL;\n\tstruct icmp6hdr *icmph = icmp6_hdr(skb);\n\tstruct icmp6hdr tmp_hdr;\n\tstruct flowi6 fl6;\n\tstruct icmpv6_msg msg;\n\tstruct dst_entry *dst;\n\tstruct ipcm6_cookie ipc6;\n\tu32 mark = IP6_REPLY_MARK(net, skb->mark);\n\tSKB_DR(reason);\n\tbool acast;\n\tu8 type;\n\n\tif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr) &&\n\t    net->ipv6.sysctl.icmpv6_echo_ignore_multicast)\n\t\treturn reason;\n\n\tsaddr = &ipv6_hdr(skb)->daddr;\n\n\tacast = ipv6_anycast_destination(skb_dst(skb), saddr);\n\tif (acast && net->ipv6.sysctl.icmpv6_echo_ignore_anycast)\n\t\treturn reason;\n\n\tif (!ipv6_unicast_destination(skb) &&\n\t    !(net->ipv6.sysctl.anycast_src_echo_reply && acast))\n\t\tsaddr = NULL;\n\n\tif (icmph->icmp6_type == ICMPV6_EXT_ECHO_REQUEST)\n\t\ttype = ICMPV6_EXT_ECHO_REPLY;\n\telse\n\t\ttype = ICMPV6_ECHO_REPLY;\n\n\tmemcpy(&tmp_hdr, icmph, sizeof(tmp_hdr));\n\ttmp_hdr.icmp6_type = type;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tif (net->ipv6.sysctl.flowlabel_reflect & FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES)\n\t\tfl6.flowlabel = ip6_flowlabel(ipv6_hdr(skb));\n\n\tfl6.flowi6_proto = IPPROTO_ICMPV6;\n\tfl6.daddr = ipv6_hdr(skb)->saddr;\n\tif (saddr)\n\t\tfl6.saddr = *saddr;\n\tfl6.flowi6_oif = icmp6_iif(skb);\n\tfl6.fl6_icmp_type = type;\n\tfl6.flowi6_mark = mark;\n\tfl6.flowi6_uid = sock_net_uid(net, NULL);\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi_common(&fl6));\n\n\tlocal_bh_disable();\n\tsk = icmpv6_xmit_lock(net);\n\tif (!sk)\n\t\tgoto out_bh_enable;\n\tnp = inet6_sk(sk);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tif (ip6_dst_lookup(net, sk, &dst, &fl6))\n\t\tgoto out;\n\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), sk, 0);\n\tif (IS_ERR(dst))\n\t\tgoto out;\n\n\t \n\tif ((!(skb->dev->flags & IFF_LOOPBACK) && !icmpv6_global_allow(net, ICMPV6_ECHO_REPLY)) ||\n\t    !icmpv6_xrlim_allow(sk, ICMPV6_ECHO_REPLY, &fl6))\n\t\tgoto out_dst_release;\n\n\tidev = __in6_dev_get(skb->dev);\n\n\tmsg.skb = skb;\n\tmsg.offset = 0;\n\tmsg.type = type;\n\n\tipcm6_init_sk(&ipc6, np);\n\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\tipc6.tclass = ipv6_get_dsfield(ipv6_hdr(skb));\n\tipc6.sockc.mark = mark;\n\n\tif (icmph->icmp6_type == ICMPV6_EXT_ECHO_REQUEST)\n\t\tif (!icmp_build_probe(skb, (struct icmphdr *)&tmp_hdr))\n\t\t\tgoto out_dst_release;\n\n\tif (ip6_append_data(sk, icmpv6_getfrag, &msg,\n\t\t\t    skb->len + sizeof(struct icmp6hdr),\n\t\t\t    sizeof(struct icmp6hdr), &ipc6, &fl6,\n\t\t\t    (struct rt6_info *)dst, MSG_DONTWAIT)) {\n\t\t__ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS);\n\t\tip6_flush_pending_frames(sk);\n\t} else {\n\t\ticmpv6_push_pending_frames(sk, &fl6, &tmp_hdr,\n\t\t\t\t\t   skb->len + sizeof(struct icmp6hdr));\n\t\treason = SKB_CONSUMED;\n\t}\nout_dst_release:\n\tdst_release(dst);\nout:\n\ticmpv6_xmit_unlock(sk);\nout_bh_enable:\n\tlocal_bh_enable();\n\treturn reason;\n}\n\nenum skb_drop_reason icmpv6_notify(struct sk_buff *skb, u8 type,\n\t\t\t\t   u8 code, __be32 info)\n{\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct inet6_protocol *ipprot;\n\tenum skb_drop_reason reason;\n\tint inner_offset;\n\t__be16 frag_off;\n\tu8 nexthdr;\n\n\treason = pskb_may_pull_reason(skb, sizeof(struct ipv6hdr));\n\tif (reason != SKB_NOT_DROPPED_YET)\n\t\tgoto out;\n\n\tseg6_icmp_srh(skb, opt);\n\n\tnexthdr = ((struct ipv6hdr *)skb->data)->nexthdr;\n\tif (ipv6_ext_hdr(nexthdr)) {\n\t\t \n\t\tinner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr),\n\t\t\t\t\t\t&nexthdr, &frag_off);\n\t\tif (inner_offset < 0) {\n\t\t\tSKB_DR_SET(reason, IPV6_BAD_EXTHDR);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tinner_offset = sizeof(struct ipv6hdr);\n\t}\n\n\t \n\treason = pskb_may_pull_reason(skb, inner_offset + 8);\n\tif (reason != SKB_NOT_DROPPED_YET)\n\t\tgoto out;\n\n\t \n\n\tipprot = rcu_dereference(inet6_protos[nexthdr]);\n\tif (ipprot && ipprot->err_handler)\n\t\tipprot->err_handler(skb, opt, type, code, inner_offset, info);\n\n\traw6_icmp_error(skb, nexthdr, type, code, inner_offset, info);\n\treturn SKB_CONSUMED;\n\nout:\n\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev), ICMP6_MIB_INERRORS);\n\treturn reason;\n}\n\n \n\nstatic int icmpv6_rcv(struct sk_buff *skb)\n{\n\tenum skb_drop_reason reason = SKB_DROP_REASON_NOT_SPECIFIED;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct net_device *dev = icmp6_dev(skb);\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct icmp6hdr *hdr;\n\tu8 type;\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tstruct sec_path *sp = skb_sec_path(skb);\n\t\tint nh;\n\n\t\tif (!(sp && sp->xvec[sp->len - 1]->props.flags &\n\t\t\t\t XFRM_STATE_ICMP)) {\n\t\t\treason = SKB_DROP_REASON_XFRM_POLICY;\n\t\t\tgoto drop_no_count;\n\t\t}\n\n\t\tif (!pskb_may_pull(skb, sizeof(*hdr) + sizeof(struct ipv6hdr)))\n\t\t\tgoto drop_no_count;\n\n\t\tnh = skb_network_offset(skb);\n\t\tskb_set_network_header(skb, sizeof(*hdr));\n\n\t\tif (!xfrm6_policy_check_reverse(NULL, XFRM_POLICY_IN,\n\t\t\t\t\t\tskb)) {\n\t\t\treason = SKB_DROP_REASON_XFRM_POLICY;\n\t\t\tgoto drop_no_count;\n\t\t}\n\n\t\tskb_set_network_header(skb, nh);\n\t}\n\n\t__ICMP6_INC_STATS(dev_net(dev), idev, ICMP6_MIB_INMSGS);\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\n\tif (skb_checksum_validate(skb, IPPROTO_ICMPV6, ip6_compute_pseudo)) {\n\t\tnet_dbg_ratelimited(\"ICMPv6 checksum failed [%pI6c > %pI6c]\\n\",\n\t\t\t\t    saddr, daddr);\n\t\tgoto csum_error;\n\t}\n\n\tif (!pskb_pull(skb, sizeof(*hdr)))\n\t\tgoto discard_it;\n\n\thdr = icmp6_hdr(skb);\n\n\ttype = hdr->icmp6_type;\n\n\tICMP6MSGIN_INC_STATS(dev_net(dev), idev, type);\n\n\tswitch (type) {\n\tcase ICMPV6_ECHO_REQUEST:\n\t\tif (!net->ipv6.sysctl.icmpv6_echo_ignore_all)\n\t\t\treason = icmpv6_echo_reply(skb);\n\t\tbreak;\n\tcase ICMPV6_EXT_ECHO_REQUEST:\n\t\tif (!net->ipv6.sysctl.icmpv6_echo_ignore_all &&\n\t\t    READ_ONCE(net->ipv4.sysctl_icmp_echo_enable_probe))\n\t\t\treason = icmpv6_echo_reply(skb);\n\t\tbreak;\n\n\tcase ICMPV6_ECHO_REPLY:\n\t\treason = ping_rcv(skb);\n\t\tbreak;\n\n\tcase ICMPV6_EXT_ECHO_REPLY:\n\t\treason = ping_rcv(skb);\n\t\tbreak;\n\n\tcase ICMPV6_PKT_TOOBIG:\n\t\t \n\t\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\t\tgoto discard_it;\n\t\thdr = icmp6_hdr(skb);\n\n\t\t \n\t\tfallthrough;\n\tcase ICMPV6_DEST_UNREACH:\n\tcase ICMPV6_TIME_EXCEED:\n\tcase ICMPV6_PARAMPROB:\n\t\treason = icmpv6_notify(skb, type, hdr->icmp6_code,\n\t\t\t\t       hdr->icmp6_mtu);\n\t\tbreak;\n\n\tcase NDISC_ROUTER_SOLICITATION:\n\tcase NDISC_ROUTER_ADVERTISEMENT:\n\tcase NDISC_NEIGHBOUR_SOLICITATION:\n\tcase NDISC_NEIGHBOUR_ADVERTISEMENT:\n\tcase NDISC_REDIRECT:\n\t\treason = ndisc_rcv(skb);\n\t\tbreak;\n\n\tcase ICMPV6_MGM_QUERY:\n\t\tigmp6_event_query(skb);\n\t\treturn 0;\n\n\tcase ICMPV6_MGM_REPORT:\n\t\tigmp6_event_report(skb);\n\t\treturn 0;\n\n\tcase ICMPV6_MGM_REDUCTION:\n\tcase ICMPV6_NI_QUERY:\n\tcase ICMPV6_NI_REPLY:\n\tcase ICMPV6_MLD2_REPORT:\n\tcase ICMPV6_DHAAD_REQUEST:\n\tcase ICMPV6_DHAAD_REPLY:\n\tcase ICMPV6_MOBILE_PREFIX_SOL:\n\tcase ICMPV6_MOBILE_PREFIX_ADV:\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tif (type & ICMPV6_INFOMSG_MASK)\n\t\t\tbreak;\n\n\t\tnet_dbg_ratelimited(\"icmpv6: msg of unknown type [%pI6c > %pI6c]\\n\",\n\t\t\t\t    saddr, daddr);\n\n\t\t \n\n\t\treason = icmpv6_notify(skb, type, hdr->icmp6_code,\n\t\t\t\t       hdr->icmp6_mtu);\n\t}\n\n\t \n\tif (reason)\n\t\tkfree_skb_reason(skb, reason);\n\telse\n\t\tconsume_skb(skb);\n\n\treturn 0;\n\ncsum_error:\n\treason = SKB_DROP_REASON_ICMP_CSUM;\n\t__ICMP6_INC_STATS(dev_net(dev), idev, ICMP6_MIB_CSUMERRORS);\ndiscard_it:\n\t__ICMP6_INC_STATS(dev_net(dev), idev, ICMP6_MIB_INERRORS);\ndrop_no_count:\n\tkfree_skb_reason(skb, reason);\n\treturn 0;\n}\n\nvoid icmpv6_flow_init(const struct sock *sk, struct flowi6 *fl6, u8 type,\n\t\t      const struct in6_addr *saddr,\n\t\t      const struct in6_addr *daddr, int oif)\n{\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->saddr = *saddr;\n\tfl6->daddr = *daddr;\n\tfl6->flowi6_proto\t= IPPROTO_ICMPV6;\n\tfl6->fl6_icmp_type\t= type;\n\tfl6->fl6_icmp_code\t= 0;\n\tfl6->flowi6_oif\t\t= oif;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi_common(fl6));\n}\n\nint __init icmpv6_init(void)\n{\n\tstruct sock *sk;\n\tint err, i;\n\n\tfor_each_possible_cpu(i) {\n\t\terr = inet_ctl_sock_create(&sk, PF_INET6,\n\t\t\t\t\t   SOCK_RAW, IPPROTO_ICMPV6, &init_net);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"Failed to initialize the ICMP6 control socket (err %d)\\n\",\n\t\t\t       err);\n\t\t\treturn err;\n\t\t}\n\n\t\tper_cpu(ipv6_icmp_sk, i) = sk;\n\n\t\t \n\t\tsk->sk_sndbuf = 2 * SKB_TRUESIZE(64 * 1024);\n\t}\n\n\terr = -EAGAIN;\n\tif (inet6_add_protocol(&icmpv6_protocol, IPPROTO_ICMPV6) < 0)\n\t\tgoto fail;\n\n\terr = inet6_register_icmp_sender(icmp6_send);\n\tif (err)\n\t\tgoto sender_reg_err;\n\treturn 0;\n\nsender_reg_err:\n\tinet6_del_protocol(&icmpv6_protocol, IPPROTO_ICMPV6);\nfail:\n\tpr_err(\"Failed to register ICMP6 protocol\\n\");\n\treturn err;\n}\n\nvoid icmpv6_cleanup(void)\n{\n\tinet6_unregister_icmp_sender(icmp6_send);\n\tinet6_del_protocol(&icmpv6_protocol, IPPROTO_ICMPV6);\n}\n\n\nstatic const struct icmp6_err {\n\tint err;\n\tint fatal;\n} tab_unreach[] = {\n\t{\t \n\t\t.err\t= ENETUNREACH,\n\t\t.fatal\t= 0,\n\t},\n\t{\t \n\t\t.err\t= EACCES,\n\t\t.fatal\t= 1,\n\t},\n\t{\t \n\t\t.err\t= EHOSTUNREACH,\n\t\t.fatal\t= 0,\n\t},\n\t{\t \n\t\t.err\t= EHOSTUNREACH,\n\t\t.fatal\t= 0,\n\t},\n\t{\t \n\t\t.err\t= ECONNREFUSED,\n\t\t.fatal\t= 1,\n\t},\n\t{\t \n\t\t.err\t= EACCES,\n\t\t.fatal\t= 1,\n\t},\n\t{\t \n\t\t.err\t= EACCES,\n\t\t.fatal\t= 1,\n\t},\n};\n\nint icmpv6_err_convert(u8 type, u8 code, int *err)\n{\n\tint fatal = 0;\n\n\t*err = EPROTO;\n\n\tswitch (type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tfatal = 1;\n\t\tif (code < ARRAY_SIZE(tab_unreach)) {\n\t\t\t*err  = tab_unreach[code].err;\n\t\t\tfatal = tab_unreach[code].fatal;\n\t\t}\n\t\tbreak;\n\n\tcase ICMPV6_PKT_TOOBIG:\n\t\t*err = EMSGSIZE;\n\t\tbreak;\n\n\tcase ICMPV6_PARAMPROB:\n\t\t*err = EPROTO;\n\t\tfatal = 1;\n\t\tbreak;\n\n\tcase ICMPV6_TIME_EXCEED:\n\t\t*err = EHOSTUNREACH;\n\t\tbreak;\n\t}\n\n\treturn fatal;\n}\nEXPORT_SYMBOL(icmpv6_err_convert);\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table ipv6_icmp_table_template[] = {\n\t{\n\t\t.procname\t= \"ratelimit\",\n\t\t.data\t\t= &init_net.ipv6.sysctl.icmpv6_time,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_ms_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"echo_ignore_all\",\n\t\t.data\t\t= &init_net.ipv6.sysctl.icmpv6_echo_ignore_all,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler = proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"echo_ignore_multicast\",\n\t\t.data\t\t= &init_net.ipv6.sysctl.icmpv6_echo_ignore_multicast,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler = proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"echo_ignore_anycast\",\n\t\t.data\t\t= &init_net.ipv6.sysctl.icmpv6_echo_ignore_anycast,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler = proc_dou8vec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"ratemask\",\n\t\t.data\t\t= &init_net.ipv6.sysctl.icmpv6_ratemask_ptr,\n\t\t.maxlen\t\t= ICMPV6_MSG_MAX + 1,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler = proc_do_large_bitmap,\n\t},\n\t{\n\t\t.procname\t= \"error_anycast_as_unicast\",\n\t\t.data\t\t= &init_net.ipv6.sysctl.icmpv6_error_anycast_as_unicast,\n\t\t.maxlen\t\t= sizeof(u8),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dou8vec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{ },\n};\n\nstruct ctl_table * __net_init ipv6_icmp_sysctl_init(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = kmemdup(ipv6_icmp_table_template,\n\t\t\tsizeof(ipv6_icmp_table_template),\n\t\t\tGFP_KERNEL);\n\n\tif (table) {\n\t\ttable[0].data = &net->ipv6.sysctl.icmpv6_time;\n\t\ttable[1].data = &net->ipv6.sysctl.icmpv6_echo_ignore_all;\n\t\ttable[2].data = &net->ipv6.sysctl.icmpv6_echo_ignore_multicast;\n\t\ttable[3].data = &net->ipv6.sysctl.icmpv6_echo_ignore_anycast;\n\t\ttable[4].data = &net->ipv6.sysctl.icmpv6_ratemask_ptr;\n\t\ttable[5].data = &net->ipv6.sysctl.icmpv6_error_anycast_as_unicast;\n\t}\n\treturn table;\n}\n\nsize_t ipv6_icmp_sysctl_table_size(void)\n{\n\treturn ARRAY_SIZE(ipv6_icmp_table_template);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}