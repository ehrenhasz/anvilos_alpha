{
  "module_name": "ip6_tunnel.c",
  "hash_id": "10e99c7207d6b7e1c9b937f3b4ffbcb6dd94499dd556d29c36d85fb1301155e3",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ip6_tunnel.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/sockios.h>\n#include <linux/icmp.h>\n#include <linux/if.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/icmpv6.h>\n#include <linux/init.h>\n#include <linux/route.h>\n#include <linux/rtnetlink.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n#include <linux/etherdevice.h>\n\n#include <linux/uaccess.h>\n#include <linux/atomic.h>\n\n#include <net/icmp.h>\n#include <net/ip.h>\n#include <net/ip_tunnels.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/ip6_tunnel.h>\n#include <net/xfrm.h>\n#include <net/dsfield.h>\n#include <net/inet_ecn.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/dst_metadata.h>\n\nMODULE_AUTHOR(\"Ville Nuorvala\");\nMODULE_DESCRIPTION(\"IPv6 tunneling device\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(\"ip6tnl\");\nMODULE_ALIAS_NETDEV(\"ip6tnl0\");\n\n#define IP6_TUNNEL_HASH_SIZE_SHIFT  5\n#define IP6_TUNNEL_HASH_SIZE (1 << IP6_TUNNEL_HASH_SIZE_SHIFT)\n\nstatic bool log_ecn_error = true;\nmodule_param(log_ecn_error, bool, 0644);\nMODULE_PARM_DESC(log_ecn_error, \"Log packets received with corrupted ECN\");\n\nstatic u32 HASH(const struct in6_addr *addr1, const struct in6_addr *addr2)\n{\n\tu32 hash = ipv6_addr_hash(addr1) ^ ipv6_addr_hash(addr2);\n\n\treturn hash_32(hash, IP6_TUNNEL_HASH_SIZE_SHIFT);\n}\n\nstatic int ip6_tnl_dev_init(struct net_device *dev);\nstatic void ip6_tnl_dev_setup(struct net_device *dev);\nstatic struct rtnl_link_ops ip6_link_ops __read_mostly;\n\nstatic unsigned int ip6_tnl_net_id __read_mostly;\nstruct ip6_tnl_net {\n\t \n\tstruct net_device *fb_tnl_dev;\n\t \n\tstruct ip6_tnl __rcu *tnls_r_l[IP6_TUNNEL_HASH_SIZE];\n\tstruct ip6_tnl __rcu *tnls_wc[1];\n\tstruct ip6_tnl __rcu **tnls[2];\n\tstruct ip6_tnl __rcu *collect_md_tun;\n};\n\nstatic inline int ip6_tnl_mpls_supported(void)\n{\n\treturn IS_ENABLED(CONFIG_MPLS);\n}\n\n#define for_each_ip6_tunnel_rcu(start) \\\n\tfor (t = rcu_dereference(start); t; t = rcu_dereference(t->next))\n\n \n\nstatic struct ip6_tnl *\nip6_tnl_lookup(struct net *net, int link,\n\t       const struct in6_addr *remote, const struct in6_addr *local)\n{\n\tunsigned int hash = HASH(remote, local);\n\tstruct ip6_tnl *t, *cand = NULL;\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\tstruct in6_addr any;\n\n\tfor_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {\n\t\tif (!ipv6_addr_equal(local, &t->parms.laddr) ||\n\t\t    !ipv6_addr_equal(remote, &t->parms.raddr) ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (link == t->parms.link)\n\t\t\treturn t;\n\t\telse\n\t\t\tcand = t;\n\t}\n\n\tmemset(&any, 0, sizeof(any));\n\thash = HASH(&any, local);\n\tfor_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {\n\t\tif (!ipv6_addr_equal(local, &t->parms.laddr) ||\n\t\t    !ipv6_addr_any(&t->parms.raddr) ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (link == t->parms.link)\n\t\t\treturn t;\n\t\telse if (!cand)\n\t\t\tcand = t;\n\t}\n\n\thash = HASH(remote, &any);\n\tfor_each_ip6_tunnel_rcu(ip6n->tnls_r_l[hash]) {\n\t\tif (!ipv6_addr_equal(remote, &t->parms.raddr) ||\n\t\t    !ipv6_addr_any(&t->parms.laddr) ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (link == t->parms.link)\n\t\t\treturn t;\n\t\telse if (!cand)\n\t\t\tcand = t;\n\t}\n\n\tif (cand)\n\t\treturn cand;\n\n\tt = rcu_dereference(ip6n->collect_md_tun);\n\tif (t && t->dev->flags & IFF_UP)\n\t\treturn t;\n\n\tt = rcu_dereference(ip6n->tnls_wc[0]);\n\tif (t && (t->dev->flags & IFF_UP))\n\t\treturn t;\n\n\treturn NULL;\n}\n\n \n\nstatic struct ip6_tnl __rcu **\nip6_tnl_bucket(struct ip6_tnl_net *ip6n, const struct __ip6_tnl_parm *p)\n{\n\tconst struct in6_addr *remote = &p->raddr;\n\tconst struct in6_addr *local = &p->laddr;\n\tunsigned int h = 0;\n\tint prio = 0;\n\n\tif (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {\n\t\tprio = 1;\n\t\th = HASH(remote, local);\n\t}\n\treturn &ip6n->tnls[prio][h];\n}\n\n \n\nstatic void\nip6_tnl_link(struct ip6_tnl_net *ip6n, struct ip6_tnl *t)\n{\n\tstruct ip6_tnl __rcu **tp = ip6_tnl_bucket(ip6n, &t->parms);\n\n\tif (t->parms.collect_md)\n\t\trcu_assign_pointer(ip6n->collect_md_tun, t);\n\trcu_assign_pointer(t->next , rtnl_dereference(*tp));\n\trcu_assign_pointer(*tp, t);\n}\n\n \n\nstatic void\nip6_tnl_unlink(struct ip6_tnl_net *ip6n, struct ip6_tnl *t)\n{\n\tstruct ip6_tnl __rcu **tp;\n\tstruct ip6_tnl *iter;\n\n\tif (t->parms.collect_md)\n\t\trcu_assign_pointer(ip6n->collect_md_tun, NULL);\n\n\tfor (tp = ip6_tnl_bucket(ip6n, &t->parms);\n\t     (iter = rtnl_dereference(*tp)) != NULL;\n\t     tp = &iter->next) {\n\t\tif (t == iter) {\n\t\t\trcu_assign_pointer(*tp, t->next);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ip6_dev_free(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\n\tgro_cells_destroy(&t->gro_cells);\n\tdst_cache_destroy(&t->dst_cache);\n\tfree_percpu(dev->tstats);\n}\n\nstatic int ip6_tnl_create2(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\tint err;\n\n\tdev->rtnl_link_ops = &ip6_link_ops;\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\tgoto out;\n\n\tstrcpy(t->parms.name, dev->name);\n\n\tip6_tnl_link(ip6n, t);\n\treturn 0;\n\nout:\n\treturn err;\n}\n\n \n\nstatic struct ip6_tnl *ip6_tnl_create(struct net *net, struct __ip6_tnl_parm *p)\n{\n\tstruct net_device *dev;\n\tstruct ip6_tnl *t;\n\tchar name[IFNAMSIZ];\n\tint err = -E2BIG;\n\n\tif (p->name[0]) {\n\t\tif (!dev_valid_name(p->name))\n\t\t\tgoto failed;\n\t\tstrscpy(name, p->name, IFNAMSIZ);\n\t} else {\n\t\tsprintf(name, \"ip6tnl%%d\");\n\t}\n\terr = -ENOMEM;\n\tdev = alloc_netdev(sizeof(*t), name, NET_NAME_UNKNOWN,\n\t\t\t   ip6_tnl_dev_setup);\n\tif (!dev)\n\t\tgoto failed;\n\n\tdev_net_set(dev, net);\n\n\tt = netdev_priv(dev);\n\tt->parms = *p;\n\tt->net = dev_net(dev);\n\terr = ip6_tnl_create2(dev);\n\tif (err < 0)\n\t\tgoto failed_free;\n\n\treturn t;\n\nfailed_free:\n\tfree_netdev(dev);\nfailed:\n\treturn ERR_PTR(err);\n}\n\n \n\nstatic struct ip6_tnl *ip6_tnl_locate(struct net *net,\n\t\tstruct __ip6_tnl_parm *p, int create)\n{\n\tconst struct in6_addr *remote = &p->raddr;\n\tconst struct in6_addr *local = &p->laddr;\n\tstruct ip6_tnl __rcu **tp;\n\tstruct ip6_tnl *t;\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tfor (tp = ip6_tnl_bucket(ip6n, p);\n\t     (t = rtnl_dereference(*tp)) != NULL;\n\t     tp = &t->next) {\n\t\tif (ipv6_addr_equal(local, &t->parms.laddr) &&\n\t\t    ipv6_addr_equal(remote, &t->parms.raddr) &&\n\t\t    p->link == t->parms.link) {\n\t\t\tif (create)\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\n\t\t\treturn t;\n\t\t}\n\t}\n\tif (!create)\n\t\treturn ERR_PTR(-ENODEV);\n\treturn ip6_tnl_create(net, p);\n}\n\n \n\nstatic void\nip6_tnl_dev_uninit(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net *net = t->net;\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tif (dev == ip6n->fb_tnl_dev)\n\t\tRCU_INIT_POINTER(ip6n->tnls_wc[0], NULL);\n\telse\n\t\tip6_tnl_unlink(ip6n, t);\n\tdst_cache_reset(&t->dst_cache);\n\tnetdev_put(dev, &t->dev_tracker);\n}\n\n \n\n__u16 ip6_tnl_parse_tlv_enc_lim(struct sk_buff *skb, __u8 *raw)\n{\n\tconst struct ipv6hdr *ipv6h = (const struct ipv6hdr *)raw;\n\tunsigned int nhoff = raw - skb->data;\n\tunsigned int off = nhoff + sizeof(*ipv6h);\n\tu8 nexthdr = ipv6h->nexthdr;\n\n\twhile (ipv6_ext_hdr(nexthdr) && nexthdr != NEXTHDR_NONE) {\n\t\tstruct ipv6_opt_hdr *hdr;\n\t\tu16 optlen;\n\n\t\tif (!pskb_may_pull(skb, off + sizeof(*hdr)))\n\t\t\tbreak;\n\n\t\thdr = (struct ipv6_opt_hdr *)(skb->data + off);\n\t\tif (nexthdr == NEXTHDR_FRAGMENT) {\n\t\t\toptlen = 8;\n\t\t} else if (nexthdr == NEXTHDR_AUTH) {\n\t\t\toptlen = ipv6_authlen(hdr);\n\t\t} else {\n\t\t\toptlen = ipv6_optlen(hdr);\n\t\t}\n\n\t\tif (!pskb_may_pull(skb, off + optlen))\n\t\t\tbreak;\n\n\t\thdr = (struct ipv6_opt_hdr *)(skb->data + off);\n\t\tif (nexthdr == NEXTHDR_FRAGMENT) {\n\t\t\tstruct frag_hdr *frag_hdr = (struct frag_hdr *)hdr;\n\n\t\t\tif (frag_hdr->frag_off)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (nexthdr == NEXTHDR_DEST) {\n\t\t\tu16 i = 2;\n\n\t\t\twhile (1) {\n\t\t\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\n\t\t\t\t \n\t\t\t\tif (i + sizeof(*tel) > optlen)\n\t\t\t\t\tbreak;\n\n\t\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *)(skb->data + off + i);\n\t\t\t\t \n\t\t\t\tif (tel->type == IPV6_TLV_TNL_ENCAP_LIMIT &&\n\t\t\t\t    tel->length == 1)\n\t\t\t\t\treturn i + off - nhoff;\n\t\t\t\t \n\t\t\t\tif (tel->type)\n\t\t\t\t\ti += tel->length + 2;\n\t\t\t\telse\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tnexthdr = hdr->nexthdr;\n\t\toff += optlen;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ip6_tnl_parse_tlv_enc_lim);\n\n \nstatic int\nip6_tnl_err(struct sk_buff *skb, __u8 ipproto, struct inet6_skb_parm *opt,\n\t    u8 *type, u8 *code, int *msg, __u32 *info, int offset)\n{\n\tconst struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb->data;\n\tstruct net *net = dev_net(skb->dev);\n\tu8 rel_type = ICMPV6_DEST_UNREACH;\n\tu8 rel_code = ICMPV6_ADDR_UNREACH;\n\t__u32 rel_info = 0;\n\tstruct ip6_tnl *t;\n\tint err = -ENOENT;\n\tint rel_msg = 0;\n\tu8 tproto;\n\t__u16 len;\n\n\t \n\n\trcu_read_lock();\n\tt = ip6_tnl_lookup(dev_net(skb->dev), skb->dev->ifindex, &ipv6h->daddr, &ipv6h->saddr);\n\tif (!t)\n\t\tgoto out;\n\n\ttproto = READ_ONCE(t->parms.proto);\n\tif (tproto != ipproto && tproto != 0)\n\t\tgoto out;\n\n\terr = 0;\n\n\tswitch (*type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\trel_msg = 1;\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif ((*code) == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t\trel_msg = 1;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB: {\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 teli;\n\n\t\tteli = 0;\n\t\tif ((*code) == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == *info - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t\trel_msg = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ICMPV6_PKT_TOOBIG: {\n\t\t__u32 mtu;\n\n\t\tip6_update_pmtu(skb, net, htonl(*info), 0, 0,\n\t\t\t\tsock_net_uid(net, NULL));\n\t\tmtu = *info - offset;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tlen = sizeof(*ipv6h) + ntohs(ipv6h->payload_len);\n\t\tif (len > mtu) {\n\t\t\trel_type = ICMPV6_PKT_TOOBIG;\n\t\t\trel_code = 0;\n\t\t\trel_info = mtu;\n\t\t\trel_msg = 1;\n\t\t}\n\t\tbreak;\n\t}\n\tcase NDISC_REDIRECT:\n\t\tip6_redirect(skb, net, skb->dev->ifindex, 0,\n\t\t\t     sock_net_uid(net, NULL));\n\t\tbreak;\n\t}\n\n\t*type = rel_type;\n\t*code = rel_code;\n\t*info = rel_info;\n\t*msg = rel_msg;\n\nout:\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic int\nip4ip6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t   u8 type, u8 code, int offset, __be32 info)\n{\n\t__u32 rel_info = ntohl(info);\n\tconst struct iphdr *eiph;\n\tstruct sk_buff *skb2;\n\tint err, rel_msg = 0;\n\tu8 rel_type = type;\n\tu8 rel_code = code;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\n\terr = ip6_tnl_err(skb, IPPROTO_IPIP, opt, &rel_type, &rel_code,\n\t\t\t  &rel_msg, &rel_info, offset);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (rel_msg == 0)\n\t\treturn 0;\n\n\tswitch (rel_type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tif (rel_code != ICMPV6_ADDR_UNREACH)\n\t\t\treturn 0;\n\t\trel_type = ICMP_DEST_UNREACH;\n\t\trel_code = ICMP_HOST_UNREACH;\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tif (rel_code != 0)\n\t\t\treturn 0;\n\t\trel_type = ICMP_DEST_UNREACH;\n\t\trel_code = ICMP_FRAG_NEEDED;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (!pskb_may_pull(skb, offset + sizeof(struct iphdr)))\n\t\treturn 0;\n\n\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb2)\n\t\treturn 0;\n\n\tskb_dst_drop(skb2);\n\n\tskb_pull(skb2, offset);\n\tskb_reset_network_header(skb2);\n\teiph = ip_hdr(skb2);\n\n\t \n\trt = ip_route_output_ports(dev_net(skb->dev), &fl4, NULL, eiph->saddr,\n\t\t\t\t   0, 0, 0, IPPROTO_IPIP, RT_TOS(eiph->tos), 0);\n\tif (IS_ERR(rt))\n\t\tgoto out;\n\n\tskb2->dev = rt->dst.dev;\n\tip_rt_put(rt);\n\n\t \n\tif (rt->rt_flags & RTCF_LOCAL) {\n\t\trt = ip_route_output_ports(dev_net(skb->dev), &fl4, NULL,\n\t\t\t\t\t   eiph->daddr, eiph->saddr, 0, 0,\n\t\t\t\t\t   IPPROTO_IPIP, RT_TOS(eiph->tos), 0);\n\t\tif (IS_ERR(rt) || rt->dst.dev->type != ARPHRD_TUNNEL6) {\n\t\t\tif (!IS_ERR(rt))\n\t\t\t\tip_rt_put(rt);\n\t\t\tgoto out;\n\t\t}\n\t\tskb_dst_set(skb2, &rt->dst);\n\t} else {\n\t\tif (ip_route_input(skb2, eiph->daddr, eiph->saddr, eiph->tos,\n\t\t\t\t   skb2->dev) ||\n\t\t    skb_dst(skb2)->dev->type != ARPHRD_TUNNEL6)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (rel_type == ICMP_DEST_UNREACH && rel_code == ICMP_FRAG_NEEDED) {\n\t\tif (rel_info > dst_mtu(skb_dst(skb2)))\n\t\t\tgoto out;\n\n\t\tskb_dst_update_pmtu_no_confirm(skb2, rel_info);\n\t}\n\n\ticmp_send(skb2, rel_type, rel_code, htonl(rel_info));\n\nout:\n\tkfree_skb(skb2);\n\treturn 0;\n}\n\nstatic int\nip6ip6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t   u8 type, u8 code, int offset, __be32 info)\n{\n\t__u32 rel_info = ntohl(info);\n\tint err, rel_msg = 0;\n\tu8 rel_type = type;\n\tu8 rel_code = code;\n\n\terr = ip6_tnl_err(skb, IPPROTO_IPV6, opt, &rel_type, &rel_code,\n\t\t\t  &rel_msg, &rel_info, offset);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (rel_msg && pskb_may_pull(skb, offset + sizeof(struct ipv6hdr))) {\n\t\tstruct rt6_info *rt;\n\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\n\t\tif (!skb2)\n\t\t\treturn 0;\n\n\t\tskb_dst_drop(skb2);\n\t\tskb_pull(skb2, offset);\n\t\tskb_reset_network_header(skb2);\n\n\t\t \n\t\trt = rt6_lookup(dev_net(skb->dev), &ipv6_hdr(skb2)->saddr,\n\t\t\t\tNULL, 0, skb2, 0);\n\n\t\tif (rt && rt->dst.dev)\n\t\t\tskb2->dev = rt->dst.dev;\n\n\t\ticmpv6_send(skb2, rel_type, rel_code, rel_info);\n\n\t\tip6_rt_put(rt);\n\n\t\tkfree_skb(skb2);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmplsip6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t    u8 type, u8 code, int offset, __be32 info)\n{\n\t__u32 rel_info = ntohl(info);\n\tint err, rel_msg = 0;\n\tu8 rel_type = type;\n\tu8 rel_code = code;\n\n\terr = ip6_tnl_err(skb, IPPROTO_MPLS, opt, &rel_type, &rel_code,\n\t\t\t  &rel_msg, &rel_info, offset);\n\treturn err;\n}\n\nstatic int ip4ip6_dscp_ecn_decapsulate(const struct ip6_tnl *t,\n\t\t\t\t       const struct ipv6hdr *ipv6h,\n\t\t\t\t       struct sk_buff *skb)\n{\n\t__u8 dsfield = ipv6_get_dsfield(ipv6h) & ~INET_ECN_MASK;\n\n\tif (t->parms.flags & IP6_TNL_F_RCV_DSCP_COPY)\n\t\tipv4_change_dsfield(ip_hdr(skb), INET_ECN_MASK, dsfield);\n\n\treturn IP6_ECN_decapsulate(ipv6h, skb);\n}\n\nstatic int ip6ip6_dscp_ecn_decapsulate(const struct ip6_tnl *t,\n\t\t\t\t       const struct ipv6hdr *ipv6h,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tif (t->parms.flags & IP6_TNL_F_RCV_DSCP_COPY)\n\t\tipv6_copy_dscp(ipv6_get_dsfield(ipv6h), ipv6_hdr(skb));\n\n\treturn IP6_ECN_decapsulate(ipv6h, skb);\n}\n\nstatic inline int mplsip6_dscp_ecn_decapsulate(const struct ip6_tnl *t,\n\t\t\t\t\t       const struct ipv6hdr *ipv6h,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\t \n\treturn 0;\n}\n\n__u32 ip6_tnl_get_cap(struct ip6_tnl *t,\n\t\t\t     const struct in6_addr *laddr,\n\t\t\t     const struct in6_addr *raddr)\n{\n\tstruct __ip6_tnl_parm *p = &t->parms;\n\tint ltype = ipv6_addr_type(laddr);\n\tint rtype = ipv6_addr_type(raddr);\n\t__u32 flags = 0;\n\n\tif (ltype == IPV6_ADDR_ANY || rtype == IPV6_ADDR_ANY) {\n\t\tflags = IP6_TNL_F_CAP_PER_PACKET;\n\t} else if (ltype & (IPV6_ADDR_UNICAST|IPV6_ADDR_MULTICAST) &&\n\t\t   rtype & (IPV6_ADDR_UNICAST|IPV6_ADDR_MULTICAST) &&\n\t\t   !((ltype|rtype) & IPV6_ADDR_LOOPBACK) &&\n\t\t   (!((ltype|rtype) & IPV6_ADDR_LINKLOCAL) || p->link)) {\n\t\tif (ltype&IPV6_ADDR_UNICAST)\n\t\t\tflags |= IP6_TNL_F_CAP_XMIT;\n\t\tif (rtype&IPV6_ADDR_UNICAST)\n\t\t\tflags |= IP6_TNL_F_CAP_RCV;\n\t}\n\treturn flags;\n}\nEXPORT_SYMBOL(ip6_tnl_get_cap);\n\n \nint ip6_tnl_rcv_ctl(struct ip6_tnl *t,\n\t\t\t\t  const struct in6_addr *laddr,\n\t\t\t\t  const struct in6_addr *raddr)\n{\n\tstruct __ip6_tnl_parm *p = &t->parms;\n\tint ret = 0;\n\tstruct net *net = t->net;\n\n\tif ((p->flags & IP6_TNL_F_CAP_RCV) ||\n\t    ((p->flags & IP6_TNL_F_CAP_PER_PACKET) &&\n\t     (ip6_tnl_get_cap(t, laddr, raddr) & IP6_TNL_F_CAP_RCV))) {\n\t\tstruct net_device *ldev = NULL;\n\n\t\tif (p->link)\n\t\t\tldev = dev_get_by_index_rcu(net, p->link);\n\n\t\tif ((ipv6_addr_is_multicast(laddr) ||\n\t\t     likely(ipv6_chk_addr_and_flags(net, laddr, ldev, false,\n\t\t\t\t\t\t    0, IFA_F_TENTATIVE))) &&\n\t\t    ((p->flags & IP6_TNL_F_ALLOW_LOCAL_REMOTE) ||\n\t\t     likely(!ipv6_chk_addr_and_flags(net, raddr, ldev, true,\n\t\t\t\t\t\t     0, IFA_F_TENTATIVE))))\n\t\t\tret = 1;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ip6_tnl_rcv_ctl);\n\nstatic int __ip6_tnl_rcv(struct ip6_tnl *tunnel, struct sk_buff *skb,\n\t\t\t const struct tnl_ptk_info *tpi,\n\t\t\t struct metadata_dst *tun_dst,\n\t\t\t int (*dscp_ecn_decapsulate)(const struct ip6_tnl *t,\n\t\t\t\t\t\tconst struct ipv6hdr *ipv6h,\n\t\t\t\t\t\tstruct sk_buff *skb),\n\t\t\t bool log_ecn_err)\n{\n\tconst struct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tint err;\n\n\tif ((!(tpi->flags & TUNNEL_CSUM) &&\n\t     (tunnel->parms.i_flags & TUNNEL_CSUM)) ||\n\t    ((tpi->flags & TUNNEL_CSUM) &&\n\t     !(tunnel->parms.i_flags & TUNNEL_CSUM))) {\n\t\tDEV_STATS_INC(tunnel->dev, rx_crc_errors);\n\t\tDEV_STATS_INC(tunnel->dev, rx_errors);\n\t\tgoto drop;\n\t}\n\n\tif (tunnel->parms.i_flags & TUNNEL_SEQ) {\n\t\tif (!(tpi->flags & TUNNEL_SEQ) ||\n\t\t    (tunnel->i_seqno &&\n\t\t     (s32)(ntohl(tpi->seq) - tunnel->i_seqno) < 0)) {\n\t\t\tDEV_STATS_INC(tunnel->dev, rx_fifo_errors);\n\t\t\tDEV_STATS_INC(tunnel->dev, rx_errors);\n\t\t\tgoto drop;\n\t\t}\n\t\ttunnel->i_seqno = ntohl(tpi->seq) + 1;\n\t}\n\n\tskb->protocol = tpi->proto;\n\n\t \n\tif (tunnel->dev->type == ARPHRD_ETHER) {\n\t\tif (!pskb_may_pull(skb, ETH_HLEN)) {\n\t\t\tDEV_STATS_INC(tunnel->dev, rx_length_errors);\n\t\t\tDEV_STATS_INC(tunnel->dev, rx_errors);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tipv6h = ipv6_hdr(skb);\n\t\tskb->protocol = eth_type_trans(skb, tunnel->dev);\n\t\tskb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);\n\t} else {\n\t\tskb->dev = tunnel->dev;\n\t\tskb_reset_mac_header(skb);\n\t}\n\n\tskb_reset_network_header(skb);\n\tmemset(skb->cb, 0, sizeof(struct inet6_skb_parm));\n\n\t__skb_tunnel_rx(skb, tunnel->dev, tunnel->net);\n\n\terr = dscp_ecn_decapsulate(tunnel, ipv6h, skb);\n\tif (unlikely(err)) {\n\t\tif (log_ecn_err)\n\t\t\tnet_info_ratelimited(\"non-ECT from %pI6 with DS=%#x\\n\",\n\t\t\t\t\t     &ipv6h->saddr,\n\t\t\t\t\t     ipv6_get_dsfield(ipv6h));\n\t\tif (err > 1) {\n\t\t\tDEV_STATS_INC(tunnel->dev, rx_frame_errors);\n\t\t\tDEV_STATS_INC(tunnel->dev, rx_errors);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tdev_sw_netstats_rx_add(tunnel->dev, skb->len);\n\n\tskb_scrub_packet(skb, !net_eq(tunnel->net, dev_net(tunnel->dev)));\n\n\tif (tun_dst)\n\t\tskb_dst_set(skb, (struct dst_entry *)tun_dst);\n\n\tgro_cells_receive(&tunnel->gro_cells, skb);\n\treturn 0;\n\ndrop:\n\tif (tun_dst)\n\t\tdst_release((struct dst_entry *)tun_dst);\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nint ip6_tnl_rcv(struct ip6_tnl *t, struct sk_buff *skb,\n\t\tconst struct tnl_ptk_info *tpi,\n\t\tstruct metadata_dst *tun_dst,\n\t\tbool log_ecn_err)\n{\n\tint (*dscp_ecn_decapsulate)(const struct ip6_tnl *t,\n\t\t\t\t    const struct ipv6hdr *ipv6h,\n\t\t\t\t    struct sk_buff *skb);\n\n\tdscp_ecn_decapsulate = ip6ip6_dscp_ecn_decapsulate;\n\tif (tpi->proto == htons(ETH_P_IP))\n\t\tdscp_ecn_decapsulate = ip4ip6_dscp_ecn_decapsulate;\n\n\treturn __ip6_tnl_rcv(t, skb, tpi, tun_dst, dscp_ecn_decapsulate,\n\t\t\t     log_ecn_err);\n}\nEXPORT_SYMBOL(ip6_tnl_rcv);\n\nstatic const struct tnl_ptk_info tpi_v6 = {\n\t \n\t.proto = htons(ETH_P_IPV6),\n};\n\nstatic const struct tnl_ptk_info tpi_v4 = {\n\t \n\t.proto = htons(ETH_P_IP),\n};\n\nstatic const struct tnl_ptk_info tpi_mpls = {\n\t \n\t.proto = htons(ETH_P_MPLS_UC),\n};\n\nstatic int ipxip6_rcv(struct sk_buff *skb, u8 ipproto,\n\t\t      const struct tnl_ptk_info *tpi,\n\t\t      int (*dscp_ecn_decapsulate)(const struct ip6_tnl *t,\n\t\t\t\t\t\t  const struct ipv6hdr *ipv6h,\n\t\t\t\t\t\t  struct sk_buff *skb))\n{\n\tstruct ip6_tnl *t;\n\tconst struct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tstruct metadata_dst *tun_dst = NULL;\n\tint ret = -1;\n\n\trcu_read_lock();\n\tt = ip6_tnl_lookup(dev_net(skb->dev), skb->dev->ifindex, &ipv6h->saddr, &ipv6h->daddr);\n\n\tif (t) {\n\t\tu8 tproto = READ_ONCE(t->parms.proto);\n\n\t\tif (tproto != ipproto && tproto != 0)\n\t\t\tgoto drop;\n\t\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\t\tgoto drop;\n\t\tipv6h = ipv6_hdr(skb);\n\t\tif (!ip6_tnl_rcv_ctl(t, &ipv6h->daddr, &ipv6h->saddr))\n\t\t\tgoto drop;\n\t\tif (iptunnel_pull_header(skb, 0, tpi->proto, false))\n\t\t\tgoto drop;\n\t\tif (t->parms.collect_md) {\n\t\t\ttun_dst = ipv6_tun_rx_dst(skb, 0, 0, 0);\n\t\t\tif (!tun_dst)\n\t\t\t\tgoto drop;\n\t\t}\n\t\tret = __ip6_tnl_rcv(t, skb, tpi, tun_dst, dscp_ecn_decapsulate,\n\t\t\t\t    log_ecn_error);\n\t}\n\n\trcu_read_unlock();\n\n\treturn ret;\n\ndrop:\n\trcu_read_unlock();\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int ip4ip6_rcv(struct sk_buff *skb)\n{\n\treturn ipxip6_rcv(skb, IPPROTO_IPIP, &tpi_v4,\n\t\t\t  ip4ip6_dscp_ecn_decapsulate);\n}\n\nstatic int ip6ip6_rcv(struct sk_buff *skb)\n{\n\treturn ipxip6_rcv(skb, IPPROTO_IPV6, &tpi_v6,\n\t\t\t  ip6ip6_dscp_ecn_decapsulate);\n}\n\nstatic int mplsip6_rcv(struct sk_buff *skb)\n{\n\treturn ipxip6_rcv(skb, IPPROTO_MPLS, &tpi_mpls,\n\t\t\t  mplsip6_dscp_ecn_decapsulate);\n}\n\nstruct ipv6_tel_txoption {\n\tstruct ipv6_txoptions ops;\n\t__u8 dst_opt[8];\n};\n\nstatic void init_tel_txopt(struct ipv6_tel_txoption *opt, __u8 encap_limit)\n{\n\tmemset(opt, 0, sizeof(struct ipv6_tel_txoption));\n\n\topt->dst_opt[2] = IPV6_TLV_TNL_ENCAP_LIMIT;\n\topt->dst_opt[3] = 1;\n\topt->dst_opt[4] = encap_limit;\n\topt->dst_opt[5] = IPV6_TLV_PADN;\n\topt->dst_opt[6] = 1;\n\n\topt->ops.dst1opt = (struct ipv6_opt_hdr *) opt->dst_opt;\n\topt->ops.opt_nflen = 8;\n}\n\n \n\nstatic inline bool\nip6_tnl_addr_conflict(const struct ip6_tnl *t, const struct ipv6hdr *hdr)\n{\n\treturn ipv6_addr_equal(&t->parms.raddr, &hdr->saddr);\n}\n\nint ip6_tnl_xmit_ctl(struct ip6_tnl *t,\n\t\t     const struct in6_addr *laddr,\n\t\t     const struct in6_addr *raddr)\n{\n\tstruct __ip6_tnl_parm *p = &t->parms;\n\tint ret = 0;\n\tstruct net *net = t->net;\n\n\tif (t->parms.collect_md)\n\t\treturn 1;\n\n\tif ((p->flags & IP6_TNL_F_CAP_XMIT) ||\n\t    ((p->flags & IP6_TNL_F_CAP_PER_PACKET) &&\n\t     (ip6_tnl_get_cap(t, laddr, raddr) & IP6_TNL_F_CAP_XMIT))) {\n\t\tstruct net_device *ldev = NULL;\n\n\t\trcu_read_lock();\n\t\tif (p->link)\n\t\t\tldev = dev_get_by_index_rcu(net, p->link);\n\n\t\tif (unlikely(!ipv6_chk_addr_and_flags(net, laddr, ldev, false,\n\t\t\t\t\t\t      0, IFA_F_TENTATIVE)))\n\t\t\tpr_warn_ratelimited(\"%s xmit: Local address not yet configured!\\n\",\n\t\t\t\t\t    p->name);\n\t\telse if (!(p->flags & IP6_TNL_F_ALLOW_LOCAL_REMOTE) &&\n\t\t\t !ipv6_addr_is_multicast(raddr) &&\n\t\t\t unlikely(ipv6_chk_addr_and_flags(net, raddr, ldev,\n\t\t\t\t\t\t\t  true, 0, IFA_F_TENTATIVE)))\n\t\t\tpr_warn_ratelimited(\"%s xmit: Routing loop! Remote address found on this node!\\n\",\n\t\t\t\t\t    p->name);\n\t\telse\n\t\t\tret = 1;\n\t\trcu_read_unlock();\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ip6_tnl_xmit_ctl);\n\n \n\nint ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev, __u8 dsfield,\n\t\t struct flowi6 *fl6, int encap_limit, __u32 *pmtu,\n\t\t __u8 proto)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net *net = t->net;\n\tstruct ipv6hdr *ipv6h;\n\tstruct ipv6_tel_txoption opt;\n\tstruct dst_entry *dst = NULL, *ndst = NULL;\n\tstruct net_device *tdev;\n\tint mtu;\n\tunsigned int eth_hlen = t->dev->type == ARPHRD_ETHER ? ETH_HLEN : 0;\n\tunsigned int psh_hlen = sizeof(struct ipv6hdr) + t->encap_hlen;\n\tunsigned int max_headroom = psh_hlen;\n\t__be16 payload_protocol;\n\tbool use_cache = false;\n\tu8 hop_limit;\n\tint err = -1;\n\n\tpayload_protocol = skb_protocol(skb, true);\n\n\tif (t->parms.collect_md) {\n\t\thop_limit = skb_tunnel_info(skb)->key.ttl;\n\t\tgoto route_lookup;\n\t} else {\n\t\thop_limit = t->parms.hop_limit;\n\t}\n\n\t \n\tif (ipv6_addr_any(&t->parms.raddr)) {\n\t\tif (payload_protocol == htons(ETH_P_IPV6)) {\n\t\t\tstruct in6_addr *addr6;\n\t\t\tstruct neighbour *neigh;\n\t\t\tint addr_type;\n\n\t\t\tif (!skb_dst(skb))\n\t\t\t\tgoto tx_err_link_failure;\n\n\t\t\tneigh = dst_neigh_lookup(skb_dst(skb),\n\t\t\t\t\t\t &ipv6_hdr(skb)->daddr);\n\t\t\tif (!neigh)\n\t\t\t\tgoto tx_err_link_failure;\n\n\t\t\taddr6 = (struct in6_addr *)&neigh->primary_key;\n\t\t\taddr_type = ipv6_addr_type(addr6);\n\n\t\t\tif (addr_type == IPV6_ADDR_ANY)\n\t\t\t\taddr6 = &ipv6_hdr(skb)->daddr;\n\n\t\t\tmemcpy(&fl6->daddr, addr6, sizeof(fl6->daddr));\n\t\t\tneigh_release(neigh);\n\t\t} else if (payload_protocol == htons(ETH_P_IP)) {\n\t\t\tconst struct rtable *rt = skb_rtable(skb);\n\n\t\t\tif (!rt)\n\t\t\t\tgoto tx_err_link_failure;\n\n\t\t\tif (rt->rt_gw_family == AF_INET6)\n\t\t\t\tmemcpy(&fl6->daddr, &rt->rt_gw6, sizeof(fl6->daddr));\n\t\t}\n\t} else if (t->parms.proto != 0 && !(t->parms.flags &\n\t\t\t\t\t    (IP6_TNL_F_USE_ORIG_TCLASS |\n\t\t\t\t\t     IP6_TNL_F_USE_ORIG_FWMARK))) {\n\t\t \n\t\tuse_cache = true;\n\t}\n\n\tif (use_cache)\n\t\tdst = dst_cache_get(&t->dst_cache);\n\n\tif (!ip6_tnl_xmit_ctl(t, &fl6->saddr, &fl6->daddr))\n\t\tgoto tx_err_link_failure;\n\n\tif (!dst) {\nroute_lookup:\n\t\t \n\t\tfl6->flowlabel = ip6_make_flowinfo(dsfield, fl6->flowlabel);\n\n\t\tdst = ip6_route_output(net, NULL, fl6);\n\n\t\tif (dst->error)\n\t\t\tgoto tx_err_link_failure;\n\t\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(fl6), NULL, 0);\n\t\tif (IS_ERR(dst)) {\n\t\t\terr = PTR_ERR(dst);\n\t\t\tdst = NULL;\n\t\t\tgoto tx_err_link_failure;\n\t\t}\n\t\tif (t->parms.collect_md && ipv6_addr_any(&fl6->saddr) &&\n\t\t    ipv6_dev_get_saddr(net, ip6_dst_idev(dst)->dev,\n\t\t\t\t       &fl6->daddr, 0, &fl6->saddr))\n\t\t\tgoto tx_err_link_failure;\n\t\tndst = dst;\n\t}\n\n\ttdev = dst->dev;\n\n\tif (tdev == dev) {\n\t\tDEV_STATS_INC(dev, collisions);\n\t\tnet_warn_ratelimited(\"%s: Local routing loop detected!\\n\",\n\t\t\t\t     t->parms.name);\n\t\tgoto tx_err_dst_release;\n\t}\n\tmtu = dst_mtu(dst) - eth_hlen - psh_hlen - t->tun_hlen;\n\tif (encap_limit >= 0) {\n\t\tmax_headroom += 8;\n\t\tmtu -= 8;\n\t}\n\tmtu = max(mtu, skb->protocol == htons(ETH_P_IPV6) ?\n\t\t       IPV6_MIN_MTU : IPV4_MIN_MTU);\n\n\tskb_dst_update_pmtu_no_confirm(skb, mtu);\n\tif (skb->len - t->tun_hlen - eth_hlen > mtu && !skb_is_gso(skb)) {\n\t\t*pmtu = mtu;\n\t\terr = -EMSGSIZE;\n\t\tgoto tx_err_dst_release;\n\t}\n\n\tif (t->err_count > 0) {\n\t\tif (time_before(jiffies,\n\t\t\t\tt->err_time + IP6TUNNEL_ERR_TIMEO)) {\n\t\t\tt->err_count--;\n\n\t\t\tdst_link_failure(skb);\n\t\t} else {\n\t\t\tt->err_count = 0;\n\t\t}\n\t}\n\n\tskb_scrub_packet(skb, !net_eq(t->net, dev_net(dev)));\n\n\t \n\tmax_headroom += LL_RESERVED_SPACE(tdev);\n\n\tif (skb_headroom(skb) < max_headroom || skb_shared(skb) ||\n\t    (skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\n\t\tstruct sk_buff *new_skb;\n\n\t\tnew_skb = skb_realloc_headroom(skb, max_headroom);\n\t\tif (!new_skb)\n\t\t\tgoto tx_err_dst_release;\n\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(new_skb, skb->sk);\n\t\tconsume_skb(skb);\n\t\tskb = new_skb;\n\t}\n\n\tif (t->parms.collect_md) {\n\t\tif (t->encap.type != TUNNEL_ENCAP_NONE)\n\t\t\tgoto tx_err_dst_release;\n\t} else {\n\t\tif (use_cache && ndst)\n\t\t\tdst_cache_set_ip6(&t->dst_cache, ndst, &fl6->saddr);\n\t}\n\tskb_dst_set(skb, dst);\n\n\tif (hop_limit == 0) {\n\t\tif (payload_protocol == htons(ETH_P_IP))\n\t\t\thop_limit = ip_hdr(skb)->ttl;\n\t\telse if (payload_protocol == htons(ETH_P_IPV6))\n\t\t\thop_limit = ipv6_hdr(skb)->hop_limit;\n\t\telse\n\t\t\thop_limit = ip6_dst_hoplimit(dst);\n\t}\n\n\t \n\tmax_headroom = LL_RESERVED_SPACE(dst->dev) + sizeof(struct ipv6hdr)\n\t\t\t+ dst->header_len + t->hlen;\n\tif (max_headroom > READ_ONCE(dev->needed_headroom))\n\t\tWRITE_ONCE(dev->needed_headroom, max_headroom);\n\n\terr = ip6_tnl_encap(skb, t, &proto, fl6);\n\tif (err)\n\t\treturn err;\n\n\tif (encap_limit >= 0) {\n\t\tinit_tel_txopt(&opt, encap_limit);\n\t\tipv6_push_frag_opts(skb, &opt.ops, &proto);\n\t}\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tipv6h = ipv6_hdr(skb);\n\tip6_flow_hdr(ipv6h, dsfield,\n\t\t     ip6_make_flowlabel(net, skb, fl6->flowlabel, true, fl6));\n\tipv6h->hop_limit = hop_limit;\n\tipv6h->nexthdr = proto;\n\tipv6h->saddr = fl6->saddr;\n\tipv6h->daddr = fl6->daddr;\n\tip6tunnel_xmit(NULL, skb, dev);\n\treturn 0;\ntx_err_link_failure:\n\tDEV_STATS_INC(dev, tx_carrier_errors);\n\tdst_link_failure(skb);\ntx_err_dst_release:\n\tdst_release(dst);\n\treturn err;\n}\nEXPORT_SYMBOL(ip6_tnl_xmit);\n\nstatic inline int\nipxip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\tu8 protocol)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct ipv6hdr *ipv6h;\n\tconst struct iphdr  *iph;\n\tint encap_limit = -1;\n\t__u16 offset;\n\tstruct flowi6 fl6;\n\t__u8 dsfield, orig_dsfield;\n\t__u32 mtu;\n\tu8 tproto;\n\tint err;\n\n\ttproto = READ_ONCE(t->parms.proto);\n\tif (tproto != protocol && tproto != 0)\n\t\treturn -1;\n\n\tif (t->parms.collect_md) {\n\t\tstruct ip_tunnel_info *tun_info;\n\t\tconst struct ip_tunnel_key *key;\n\n\t\ttun_info = skb_tunnel_info(skb);\n\t\tif (unlikely(!tun_info || !(tun_info->mode & IP_TUNNEL_INFO_TX) ||\n\t\t\t     ip_tunnel_info_af(tun_info) != AF_INET6))\n\t\t\treturn -1;\n\t\tkey = &tun_info->key;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = protocol;\n\t\tfl6.saddr = key->u.ipv6.src;\n\t\tfl6.daddr = key->u.ipv6.dst;\n\t\tfl6.flowlabel = key->label;\n\t\tdsfield =  key->tos;\n\t\tswitch (protocol) {\n\t\tcase IPPROTO_IPIP:\n\t\t\tiph = ip_hdr(skb);\n\t\t\torig_dsfield = ipv4_get_dsfield(iph);\n\t\t\tbreak;\n\t\tcase IPPROTO_IPV6:\n\t\t\tipv6h = ipv6_hdr(skb);\n\t\t\torig_dsfield = ipv6_get_dsfield(ipv6h);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\torig_dsfield = dsfield;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\n\t\t\tencap_limit = t->parms.encap_limit;\n\t\tif (protocol == IPPROTO_IPV6) {\n\t\t\toffset = ip6_tnl_parse_tlv_enc_lim(skb,\n\t\t\t\t\t\tskb_network_header(skb));\n\t\t\t \n\t\t\tif (offset > 0) {\n\t\t\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\n\t\t\t\ttel = (void *)&skb_network_header(skb)[offset];\n\t\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\t\ticmpv6_ndo_send(skb, ICMPV6_PARAMPROB,\n\t\t\t\t\t\t\tICMPV6_HDR_FIELD, offset + 2);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tencap_limit = tel->encap_limit - 1;\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(&fl6, &t->fl.u.ip6, sizeof(fl6));\n\t\tfl6.flowi6_proto = protocol;\n\n\t\tif (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)\n\t\t\tfl6.flowi6_mark = skb->mark;\n\t\telse\n\t\t\tfl6.flowi6_mark = t->parms.fwmark;\n\t\tswitch (protocol) {\n\t\tcase IPPROTO_IPIP:\n\t\t\tiph = ip_hdr(skb);\n\t\t\torig_dsfield = ipv4_get_dsfield(iph);\n\t\t\tif (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)\n\t\t\t\tdsfield = orig_dsfield;\n\t\t\telse\n\t\t\t\tdsfield = ip6_tclass(t->parms.flowinfo);\n\t\t\tbreak;\n\t\tcase IPPROTO_IPV6:\n\t\t\tipv6h = ipv6_hdr(skb);\n\t\t\torig_dsfield = ipv6_get_dsfield(ipv6h);\n\t\t\tif (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)\n\t\t\t\tdsfield = orig_dsfield;\n\t\t\telse\n\t\t\t\tdsfield = ip6_tclass(t->parms.flowinfo);\n\t\t\tif (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)\n\t\t\t\tfl6.flowlabel |= ip6_flowlabel(ipv6h);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\torig_dsfield = dsfield = ip6_tclass(t->parms.flowinfo);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfl6.flowi6_uid = sock_net_uid(dev_net(dev), NULL);\n\tdsfield = INET_ECN_encapsulate(dsfield, orig_dsfield);\n\n\tif (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))\n\t\treturn -1;\n\n\tskb_set_inner_ipproto(skb, protocol);\n\n\terr = ip6_tnl_xmit(skb, dev, dsfield, &fl6, encap_limit, &mtu,\n\t\t\t   protocol);\n\tif (err != 0) {\n\t\t \n\t\tif (err == -EMSGSIZE)\n\t\t\tswitch (protocol) {\n\t\t\tcase IPPROTO_IPIP:\n\t\t\t\ticmp_ndo_send(skb, ICMP_DEST_UNREACH,\n\t\t\t\t\t      ICMP_FRAG_NEEDED, htonl(mtu));\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_IPV6:\n\t\t\t\ticmpv6_ndo_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic netdev_tx_t\nip6_tnl_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tu8 ipproto;\n\tint ret;\n\n\tif (!pskb_inet_may_pull(skb))\n\t\tgoto tx_err;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tipproto = IPPROTO_IPIP;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tif (ip6_tnl_addr_conflict(t, ipv6_hdr(skb)))\n\t\t\tgoto tx_err;\n\t\tipproto = IPPROTO_IPV6;\n\t\tbreak;\n\tcase htons(ETH_P_MPLS_UC):\n\t\tipproto = IPPROTO_MPLS;\n\t\tbreak;\n\tdefault:\n\t\tgoto tx_err;\n\t}\n\n\tret = ipxip6_tnl_xmit(skb, dev, ipproto);\n\tif (ret < 0)\n\t\tgoto tx_err;\n\n\treturn NETDEV_TX_OK;\n\ntx_err:\n\tDEV_STATS_INC(dev, tx_errors);\n\tDEV_STATS_INC(dev, tx_dropped);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ip6_tnl_link_config(struct ip6_tnl *t)\n{\n\tstruct net_device *dev = t->dev;\n\tstruct net_device *tdev = NULL;\n\tstruct __ip6_tnl_parm *p = &t->parms;\n\tstruct flowi6 *fl6 = &t->fl.u.ip6;\n\tint t_hlen;\n\tint mtu;\n\n\t__dev_addr_set(dev, &p->laddr, sizeof(struct in6_addr));\n\tmemcpy(dev->broadcast, &p->raddr, sizeof(struct in6_addr));\n\n\t \n\tfl6->saddr = p->laddr;\n\tfl6->daddr = p->raddr;\n\tfl6->flowi6_oif = p->link;\n\tfl6->flowlabel = 0;\n\n\tif (!(p->flags&IP6_TNL_F_USE_ORIG_TCLASS))\n\t\tfl6->flowlabel |= IPV6_TCLASS_MASK & p->flowinfo;\n\tif (!(p->flags&IP6_TNL_F_USE_ORIG_FLOWLABEL))\n\t\tfl6->flowlabel |= IPV6_FLOWLABEL_MASK & p->flowinfo;\n\n\tp->flags &= ~(IP6_TNL_F_CAP_XMIT|IP6_TNL_F_CAP_RCV|IP6_TNL_F_CAP_PER_PACKET);\n\tp->flags |= ip6_tnl_get_cap(t, &p->laddr, &p->raddr);\n\n\tif (p->flags&IP6_TNL_F_CAP_XMIT && p->flags&IP6_TNL_F_CAP_RCV)\n\t\tdev->flags |= IFF_POINTOPOINT;\n\telse\n\t\tdev->flags &= ~IFF_POINTOPOINT;\n\n\tt->tun_hlen = 0;\n\tt->hlen = t->encap_hlen + t->tun_hlen;\n\tt_hlen = t->hlen + sizeof(struct ipv6hdr);\n\n\tif (p->flags & IP6_TNL_F_CAP_XMIT) {\n\t\tint strict = (ipv6_addr_type(&p->raddr) &\n\t\t\t      (IPV6_ADDR_MULTICAST|IPV6_ADDR_LINKLOCAL));\n\n\t\tstruct rt6_info *rt = rt6_lookup(t->net,\n\t\t\t\t\t\t &p->raddr, &p->laddr,\n\t\t\t\t\t\t p->link, NULL, strict);\n\t\tif (rt) {\n\t\t\ttdev = rt->dst.dev;\n\t\t\tip6_rt_put(rt);\n\t\t}\n\n\t\tif (!tdev && p->link)\n\t\t\ttdev = __dev_get_by_index(t->net, p->link);\n\n\t\tif (tdev) {\n\t\t\tdev->hard_header_len = tdev->hard_header_len + t_hlen;\n\t\t\tmtu = min_t(unsigned int, tdev->mtu, IP6_MAX_MTU);\n\n\t\t\tmtu = mtu - t_hlen;\n\t\t\tif (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\n\t\t\t\tmtu -= 8;\n\n\t\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\t\tmtu = IPV6_MIN_MTU;\n\t\t\tWRITE_ONCE(dev->mtu, mtu);\n\t\t}\n\t}\n}\n\n \n\nstatic void\nip6_tnl_change(struct ip6_tnl *t, const struct __ip6_tnl_parm *p)\n{\n\tt->parms.laddr = p->laddr;\n\tt->parms.raddr = p->raddr;\n\tt->parms.flags = p->flags;\n\tt->parms.hop_limit = p->hop_limit;\n\tt->parms.encap_limit = p->encap_limit;\n\tt->parms.flowinfo = p->flowinfo;\n\tt->parms.link = p->link;\n\tt->parms.proto = p->proto;\n\tt->parms.fwmark = p->fwmark;\n\tdst_cache_reset(&t->dst_cache);\n\tip6_tnl_link_config(t);\n}\n\nstatic void ip6_tnl_update(struct ip6_tnl *t, struct __ip6_tnl_parm *p)\n{\n\tstruct net *net = t->net;\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tip6_tnl_unlink(ip6n, t);\n\tsynchronize_net();\n\tip6_tnl_change(t, p);\n\tip6_tnl_link(ip6n, t);\n\tnetdev_state_change(t->dev);\n}\n\nstatic void ip6_tnl0_update(struct ip6_tnl *t, struct __ip6_tnl_parm *p)\n{\n\t \n\tt->parms.proto = p->proto;\n\tnetdev_state_change(t->dev);\n}\n\nstatic void\nip6_tnl_parm_from_user(struct __ip6_tnl_parm *p, const struct ip6_tnl_parm *u)\n{\n\tp->laddr = u->laddr;\n\tp->raddr = u->raddr;\n\tp->flags = u->flags;\n\tp->hop_limit = u->hop_limit;\n\tp->encap_limit = u->encap_limit;\n\tp->flowinfo = u->flowinfo;\n\tp->link = u->link;\n\tp->proto = u->proto;\n\tmemcpy(p->name, u->name, sizeof(u->name));\n}\n\nstatic void\nip6_tnl_parm_to_user(struct ip6_tnl_parm *u, const struct __ip6_tnl_parm *p)\n{\n\tu->laddr = p->laddr;\n\tu->raddr = p->raddr;\n\tu->flags = p->flags;\n\tu->hop_limit = p->hop_limit;\n\tu->encap_limit = p->encap_limit;\n\tu->flowinfo = p->flowinfo;\n\tu->link = p->link;\n\tu->proto = p->proto;\n\tmemcpy(u->name, p->name, sizeof(u->name));\n}\n\n \n\nstatic int\nip6_tnl_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t       void __user *data, int cmd)\n{\n\tint err = 0;\n\tstruct ip6_tnl_parm p;\n\tstruct __ip6_tnl_parm p1;\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net *net = t->net;\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tmemset(&p1, 0, sizeof(p1));\n\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n\t\tif (dev == ip6n->fb_tnl_dev) {\n\t\t\tif (copy_from_user(&p, data, sizeof(p))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tip6_tnl_parm_from_user(&p1, &p);\n\t\t\tt = ip6_tnl_locate(net, &p1, 0);\n\t\t\tif (IS_ERR(t))\n\t\t\t\tt = netdev_priv(dev);\n\t\t} else {\n\t\t\tmemset(&p, 0, sizeof(p));\n\t\t}\n\t\tip6_tnl_parm_to_user(&p, &t->parms);\n\t\tif (copy_to_user(data, &p, sizeof(p)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&p, data, sizeof(p)))\n\t\t\tbreak;\n\t\terr = -EINVAL;\n\t\tif (p.proto != IPPROTO_IPV6 && p.proto != IPPROTO_IPIP &&\n\t\t    p.proto != 0)\n\t\t\tbreak;\n\t\tip6_tnl_parm_from_user(&p1, &p);\n\t\tt = ip6_tnl_locate(net, &p1, cmd == SIOCADDTUNNEL);\n\t\tif (cmd == SIOCCHGTUNNEL) {\n\t\t\tif (!IS_ERR(t)) {\n\t\t\t\tif (t->dev != dev) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tt = netdev_priv(dev);\n\t\t\tif (dev == ip6n->fb_tnl_dev)\n\t\t\t\tip6_tnl0_update(t, &p1);\n\t\t\telse\n\t\t\t\tip6_tnl_update(t, &p1);\n\t\t}\n\t\tif (!IS_ERR(t)) {\n\t\t\terr = 0;\n\t\t\tip6_tnl_parm_to_user(&p, &t->parms);\n\t\t\tif (copy_to_user(data, &p, sizeof(p)))\n\t\t\t\terr = -EFAULT;\n\n\t\t} else {\n\t\t\terr = PTR_ERR(t);\n\t\t}\n\t\tbreak;\n\tcase SIOCDELTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\n\t\tif (dev == ip6n->fb_tnl_dev) {\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(&p, data, sizeof(p)))\n\t\t\t\tbreak;\n\t\t\terr = -ENOENT;\n\t\t\tip6_tnl_parm_from_user(&p1, &p);\n\t\t\tt = ip6_tnl_locate(net, &p1, 0);\n\t\t\tif (IS_ERR(t))\n\t\t\t\tbreak;\n\t\t\terr = -EPERM;\n\t\t\tif (t->dev == ip6n->fb_tnl_dev)\n\t\t\t\tbreak;\n\t\t\tdev = t->dev;\n\t\t}\n\t\terr = 0;\n\t\tunregister_netdevice(dev);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\n \n\nint ip6_tnl_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct ip6_tnl *tnl = netdev_priv(dev);\n\n\tif (tnl->parms.proto == IPPROTO_IPV6) {\n\t\tif (new_mtu < IPV6_MIN_MTU)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (new_mtu < ETH_MIN_MTU)\n\t\t\treturn -EINVAL;\n\t}\n\tif (tnl->parms.proto == IPPROTO_IPV6 || tnl->parms.proto == 0) {\n\t\tif (new_mtu > IP6_MAX_MTU - dev->hard_header_len)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (new_mtu > IP_MAX_MTU - dev->hard_header_len)\n\t\t\treturn -EINVAL;\n\t}\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\nEXPORT_SYMBOL(ip6_tnl_change_mtu);\n\nint ip6_tnl_get_iflink(const struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\n\treturn t->parms.link;\n}\nEXPORT_SYMBOL(ip6_tnl_get_iflink);\n\nint ip6_tnl_encap_add_ops(const struct ip6_tnl_encap_ops *ops,\n\t\t\t  unsigned int num)\n{\n\tif (num >= MAX_IPTUN_ENCAP_OPS)\n\t\treturn -ERANGE;\n\n\treturn !cmpxchg((const struct ip6_tnl_encap_ops **)\n\t\t\t&ip6tun_encaps[num],\n\t\t\tNULL, ops) ? 0 : -1;\n}\nEXPORT_SYMBOL(ip6_tnl_encap_add_ops);\n\nint ip6_tnl_encap_del_ops(const struct ip6_tnl_encap_ops *ops,\n\t\t\t  unsigned int num)\n{\n\tint ret;\n\n\tif (num >= MAX_IPTUN_ENCAP_OPS)\n\t\treturn -ERANGE;\n\n\tret = (cmpxchg((const struct ip6_tnl_encap_ops **)\n\t\t       &ip6tun_encaps[num],\n\t\t       ops, NULL) == ops) ? 0 : -1;\n\n\tsynchronize_net();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ip6_tnl_encap_del_ops);\n\nint ip6_tnl_encap_setup(struct ip6_tnl *t,\n\t\t\tstruct ip_tunnel_encap *ipencap)\n{\n\tint hlen;\n\n\tmemset(&t->encap, 0, sizeof(t->encap));\n\n\thlen = ip6_encap_hlen(ipencap);\n\tif (hlen < 0)\n\t\treturn hlen;\n\n\tt->encap.type = ipencap->type;\n\tt->encap.sport = ipencap->sport;\n\tt->encap.dport = ipencap->dport;\n\tt->encap.flags = ipencap->flags;\n\n\tt->encap_hlen = hlen;\n\tt->hlen = t->encap_hlen + t->tun_hlen;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ip6_tnl_encap_setup);\n\nstatic const struct net_device_ops ip6_tnl_netdev_ops = {\n\t.ndo_init\t= ip6_tnl_dev_init,\n\t.ndo_uninit\t= ip6_tnl_dev_uninit,\n\t.ndo_start_xmit = ip6_tnl_start_xmit,\n\t.ndo_siocdevprivate = ip6_tnl_siocdevprivate,\n\t.ndo_change_mtu = ip6_tnl_change_mtu,\n\t.ndo_get_stats64 = dev_get_tstats64,\n\t.ndo_get_iflink = ip6_tnl_get_iflink,\n};\n\n#define IPXIPX_FEATURES (NETIF_F_SG |\t\t\\\n\t\t\t NETIF_F_FRAGLIST |\t\\\n\t\t\t NETIF_F_HIGHDMA |\t\\\n\t\t\t NETIF_F_GSO_SOFTWARE |\t\\\n\t\t\t NETIF_F_HW_CSUM)\n\n \n\nstatic void ip6_tnl_dev_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &ip6_tnl_netdev_ops;\n\tdev->header_ops = &ip_tunnel_header_ops;\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = ip6_dev_free;\n\n\tdev->type = ARPHRD_TUNNEL6;\n\tdev->flags |= IFF_NOARP;\n\tdev->addr_len = sizeof(struct in6_addr);\n\tdev->features |= NETIF_F_LLTX;\n\tnetif_keep_dst(dev);\n\n\tdev->features\t\t|= IPXIPX_FEATURES;\n\tdev->hw_features\t|= IPXIPX_FEATURES;\n\n\t \n\tdev->addr_assign_type = NET_ADDR_RANDOM;\n\teth_random_addr(dev->perm_addr);\n}\n\n\n \n\nstatic inline int\nip6_tnl_dev_init_gen(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tint ret;\n\tint t_hlen;\n\n\tt->dev = dev;\n\tt->net = dev_net(dev);\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\tret = dst_cache_init(&t->dst_cache, GFP_KERNEL);\n\tif (ret)\n\t\tgoto free_stats;\n\n\tret = gro_cells_init(&t->gro_cells, dev);\n\tif (ret)\n\t\tgoto destroy_dst;\n\n\tt->tun_hlen = 0;\n\tt->hlen = t->encap_hlen + t->tun_hlen;\n\tt_hlen = t->hlen + sizeof(struct ipv6hdr);\n\n\tdev->type = ARPHRD_TUNNEL6;\n\tdev->hard_header_len = LL_MAX_HEADER + t_hlen;\n\tdev->mtu = ETH_DATA_LEN - t_hlen;\n\tif (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\n\t\tdev->mtu -= 8;\n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = IP6_MAX_MTU - dev->hard_header_len;\n\n\tnetdev_hold(dev, &t->dev_tracker, GFP_KERNEL);\n\treturn 0;\n\ndestroy_dst:\n\tdst_cache_destroy(&t->dst_cache);\nfree_stats:\n\tfree_percpu(dev->tstats);\n\tdev->tstats = NULL;\n\n\treturn ret;\n}\n\n \n\nstatic int ip6_tnl_dev_init(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tint err = ip6_tnl_dev_init_gen(dev);\n\n\tif (err)\n\t\treturn err;\n\tip6_tnl_link_config(t);\n\tif (t->parms.collect_md)\n\t\tnetif_keep_dst(dev);\n\treturn 0;\n}\n\n \n\nstatic int __net_init ip6_fb_tnl_dev_init(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tt->parms.proto = IPPROTO_IPV6;\n\n\trcu_assign_pointer(ip6n->tnls_wc[0], t);\n\treturn 0;\n}\n\nstatic int ip6_tnl_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tu8 proto;\n\n\tif (!data || !data[IFLA_IPTUN_PROTO])\n\t\treturn 0;\n\n\tproto = nla_get_u8(data[IFLA_IPTUN_PROTO]);\n\tif (proto != IPPROTO_IPV6 &&\n\t    proto != IPPROTO_IPIP &&\n\t    proto != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void ip6_tnl_netlink_parms(struct nlattr *data[],\n\t\t\t\t  struct __ip6_tnl_parm *parms)\n{\n\tmemset(parms, 0, sizeof(*parms));\n\n\tif (!data)\n\t\treturn;\n\n\tif (data[IFLA_IPTUN_LINK])\n\t\tparms->link = nla_get_u32(data[IFLA_IPTUN_LINK]);\n\n\tif (data[IFLA_IPTUN_LOCAL])\n\t\tparms->laddr = nla_get_in6_addr(data[IFLA_IPTUN_LOCAL]);\n\n\tif (data[IFLA_IPTUN_REMOTE])\n\t\tparms->raddr = nla_get_in6_addr(data[IFLA_IPTUN_REMOTE]);\n\n\tif (data[IFLA_IPTUN_TTL])\n\t\tparms->hop_limit = nla_get_u8(data[IFLA_IPTUN_TTL]);\n\n\tif (data[IFLA_IPTUN_ENCAP_LIMIT])\n\t\tparms->encap_limit = nla_get_u8(data[IFLA_IPTUN_ENCAP_LIMIT]);\n\n\tif (data[IFLA_IPTUN_FLOWINFO])\n\t\tparms->flowinfo = nla_get_be32(data[IFLA_IPTUN_FLOWINFO]);\n\n\tif (data[IFLA_IPTUN_FLAGS])\n\t\tparms->flags = nla_get_u32(data[IFLA_IPTUN_FLAGS]);\n\n\tif (data[IFLA_IPTUN_PROTO])\n\t\tparms->proto = nla_get_u8(data[IFLA_IPTUN_PROTO]);\n\n\tif (data[IFLA_IPTUN_COLLECT_METADATA])\n\t\tparms->collect_md = true;\n\n\tif (data[IFLA_IPTUN_FWMARK])\n\t\tparms->fwmark = nla_get_u32(data[IFLA_IPTUN_FWMARK]);\n}\n\nstatic int ip6_tnl_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t   struct nlattr *tb[], struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\tstruct ip_tunnel_encap ipencap;\n\tstruct ip6_tnl *nt, *t;\n\tint err;\n\n\tnt = netdev_priv(dev);\n\n\tif (ip_tunnel_netlink_encap_parms(data, &ipencap)) {\n\t\terr = ip6_tnl_encap_setup(nt, &ipencap);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tip6_tnl_netlink_parms(data, &nt->parms);\n\n\tif (nt->parms.collect_md) {\n\t\tif (rtnl_dereference(ip6n->collect_md_tun))\n\t\t\treturn -EEXIST;\n\t} else {\n\t\tt = ip6_tnl_locate(net, &nt->parms, 0);\n\t\tif (!IS_ERR(t))\n\t\t\treturn -EEXIST;\n\t}\n\n\terr = ip6_tnl_create2(dev);\n\tif (!err && tb[IFLA_MTU])\n\t\tip6_tnl_change_mtu(dev, nla_get_u32(tb[IFLA_MTU]));\n\n\treturn err;\n}\n\nstatic int ip6_tnl_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t      struct nlattr *data[],\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct __ip6_tnl_parm p;\n\tstruct net *net = t->net;\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\tstruct ip_tunnel_encap ipencap;\n\n\tif (dev == ip6n->fb_tnl_dev)\n\t\treturn -EINVAL;\n\n\tif (ip_tunnel_netlink_encap_parms(data, &ipencap)) {\n\t\tint err = ip6_tnl_encap_setup(t, &ipencap);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tip6_tnl_netlink_parms(data, &p);\n\tif (p.collect_md)\n\t\treturn -EINVAL;\n\n\tt = ip6_tnl_locate(net, &p, 0);\n\tif (!IS_ERR(t)) {\n\t\tif (t->dev != dev)\n\t\t\treturn -EEXIST;\n\t} else\n\t\tt = netdev_priv(dev);\n\n\tip6_tnl_update(t, &p);\n\treturn 0;\n}\n\nstatic void ip6_tnl_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\n\tif (dev != ip6n->fb_tnl_dev)\n\t\tunregister_netdevice_queue(dev, head);\n}\n\nstatic size_t ip6_tnl_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(sizeof(struct in6_addr)) +\n\t\t \n\t\tnla_total_size(sizeof(struct in6_addr)) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(0) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t0;\n}\n\nstatic int ip6_tnl_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ip6_tnl *tunnel = netdev_priv(dev);\n\tstruct __ip6_tnl_parm *parm = &tunnel->parms;\n\n\tif (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||\n\t    nla_put_in6_addr(skb, IFLA_IPTUN_LOCAL, &parm->laddr) ||\n\t    nla_put_in6_addr(skb, IFLA_IPTUN_REMOTE, &parm->raddr) ||\n\t    nla_put_u8(skb, IFLA_IPTUN_TTL, parm->hop_limit) ||\n\t    nla_put_u8(skb, IFLA_IPTUN_ENCAP_LIMIT, parm->encap_limit) ||\n\t    nla_put_be32(skb, IFLA_IPTUN_FLOWINFO, parm->flowinfo) ||\n\t    nla_put_u32(skb, IFLA_IPTUN_FLAGS, parm->flags) ||\n\t    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->proto) ||\n\t    nla_put_u32(skb, IFLA_IPTUN_FWMARK, parm->fwmark))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(skb, IFLA_IPTUN_ENCAP_TYPE, tunnel->encap.type) ||\n\t    nla_put_be16(skb, IFLA_IPTUN_ENCAP_SPORT, tunnel->encap.sport) ||\n\t    nla_put_be16(skb, IFLA_IPTUN_ENCAP_DPORT, tunnel->encap.dport) ||\n\t    nla_put_u16(skb, IFLA_IPTUN_ENCAP_FLAGS, tunnel->encap.flags))\n\t\tgoto nla_put_failure;\n\n\tif (parm->collect_md)\n\t\tif (nla_put_flag(skb, IFLA_IPTUN_COLLECT_METADATA))\n\t\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstruct net *ip6_tnl_get_link_net(const struct net_device *dev)\n{\n\tstruct ip6_tnl *tunnel = netdev_priv(dev);\n\n\treturn tunnel->net;\n}\nEXPORT_SYMBOL(ip6_tnl_get_link_net);\n\nstatic const struct nla_policy ip6_tnl_policy[IFLA_IPTUN_MAX + 1] = {\n\t[IFLA_IPTUN_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_IPTUN_LOCAL]\t\t= { .len = sizeof(struct in6_addr) },\n\t[IFLA_IPTUN_REMOTE]\t\t= { .len = sizeof(struct in6_addr) },\n\t[IFLA_IPTUN_TTL]\t\t= { .type = NLA_U8 },\n\t[IFLA_IPTUN_ENCAP_LIMIT]\t= { .type = NLA_U8 },\n\t[IFLA_IPTUN_FLOWINFO]\t\t= { .type = NLA_U32 },\n\t[IFLA_IPTUN_FLAGS]\t\t= { .type = NLA_U32 },\n\t[IFLA_IPTUN_PROTO]\t\t= { .type = NLA_U8 },\n\t[IFLA_IPTUN_ENCAP_TYPE]\t\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_ENCAP_FLAGS]\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_ENCAP_SPORT]\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_ENCAP_DPORT]\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_COLLECT_METADATA]\t= { .type = NLA_FLAG },\n\t[IFLA_IPTUN_FWMARK]\t\t= { .type = NLA_U32 },\n};\n\nstatic struct rtnl_link_ops ip6_link_ops __read_mostly = {\n\t.kind\t\t= \"ip6tnl\",\n\t.maxtype\t= IFLA_IPTUN_MAX,\n\t.policy\t\t= ip6_tnl_policy,\n\t.priv_size\t= sizeof(struct ip6_tnl),\n\t.setup\t\t= ip6_tnl_dev_setup,\n\t.validate\t= ip6_tnl_validate,\n\t.newlink\t= ip6_tnl_newlink,\n\t.changelink\t= ip6_tnl_changelink,\n\t.dellink\t= ip6_tnl_dellink,\n\t.get_size\t= ip6_tnl_get_size,\n\t.fill_info\t= ip6_tnl_fill_info,\n\t.get_link_net\t= ip6_tnl_get_link_net,\n};\n\nstatic struct xfrm6_tunnel ip4ip6_handler __read_mostly = {\n\t.handler\t= ip4ip6_rcv,\n\t.err_handler\t= ip4ip6_err,\n\t.priority\t=\t1,\n};\n\nstatic struct xfrm6_tunnel ip6ip6_handler __read_mostly = {\n\t.handler\t= ip6ip6_rcv,\n\t.err_handler\t= ip6ip6_err,\n\t.priority\t=\t1,\n};\n\nstatic struct xfrm6_tunnel mplsip6_handler __read_mostly = {\n\t.handler\t= mplsip6_rcv,\n\t.err_handler\t= mplsip6_err,\n\t.priority\t=\t1,\n};\n\nstatic void __net_exit ip6_tnl_destroy_tunnels(struct net *net, struct list_head *list)\n{\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\tstruct net_device *dev, *aux;\n\tint h;\n\tstruct ip6_tnl *t;\n\n\tfor_each_netdev_safe(net, dev, aux)\n\t\tif (dev->rtnl_link_ops == &ip6_link_ops)\n\t\t\tunregister_netdevice_queue(dev, list);\n\n\tfor (h = 0; h < IP6_TUNNEL_HASH_SIZE; h++) {\n\t\tt = rtnl_dereference(ip6n->tnls_r_l[h]);\n\t\twhile (t) {\n\t\t\t \n\t\t\tif (!net_eq(dev_net(t->dev), net))\n\t\t\t\tunregister_netdevice_queue(t->dev, list);\n\t\t\tt = rtnl_dereference(t->next);\n\t\t}\n\t}\n\n\tt = rtnl_dereference(ip6n->tnls_wc[0]);\n\twhile (t) {\n\t\t \n\t\tif (!net_eq(dev_net(t->dev), net))\n\t\t\tunregister_netdevice_queue(t->dev, list);\n\t\tt = rtnl_dereference(t->next);\n\t}\n}\n\nstatic int __net_init ip6_tnl_init_net(struct net *net)\n{\n\tstruct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n\tstruct ip6_tnl *t = NULL;\n\tint err;\n\n\tip6n->tnls[0] = ip6n->tnls_wc;\n\tip6n->tnls[1] = ip6n->tnls_r_l;\n\n\tif (!net_has_fallback_tunnels(net))\n\t\treturn 0;\n\terr = -ENOMEM;\n\tip6n->fb_tnl_dev = alloc_netdev(sizeof(struct ip6_tnl), \"ip6tnl0\",\n\t\t\t\t\tNET_NAME_UNKNOWN, ip6_tnl_dev_setup);\n\n\tif (!ip6n->fb_tnl_dev)\n\t\tgoto err_alloc_dev;\n\tdev_net_set(ip6n->fb_tnl_dev, net);\n\tip6n->fb_tnl_dev->rtnl_link_ops = &ip6_link_ops;\n\t \n\tip6n->fb_tnl_dev->features |= NETIF_F_NETNS_LOCAL;\n\n\terr = ip6_fb_tnl_dev_init(ip6n->fb_tnl_dev);\n\tif (err < 0)\n\t\tgoto err_register;\n\n\terr = register_netdev(ip6n->fb_tnl_dev);\n\tif (err < 0)\n\t\tgoto err_register;\n\n\tt = netdev_priv(ip6n->fb_tnl_dev);\n\n\tstrcpy(t->parms.name, ip6n->fb_tnl_dev->name);\n\treturn 0;\n\nerr_register:\n\tfree_netdev(ip6n->fb_tnl_dev);\nerr_alloc_dev:\n\treturn err;\n}\n\nstatic void __net_exit ip6_tnl_exit_batch_net(struct list_head *net_list)\n{\n\tstruct net *net;\n\tLIST_HEAD(list);\n\n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list)\n\t\tip6_tnl_destroy_tunnels(net, &list);\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations ip6_tnl_net_ops = {\n\t.init = ip6_tnl_init_net,\n\t.exit_batch = ip6_tnl_exit_batch_net,\n\t.id   = &ip6_tnl_net_id,\n\t.size = sizeof(struct ip6_tnl_net),\n};\n\n \n\nstatic int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\n\tif (!ipv6_mod_enabled())\n\t\treturn -EOPNOTSUPP;\n\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto out_pernet;\n\n\terr = xfrm6_tunnel_register(&ip4ip6_handler, AF_INET);\n\tif (err < 0) {\n\t\tpr_err(\"%s: can't register ip4ip6\\n\", __func__);\n\t\tgoto out_ip4ip6;\n\t}\n\n\terr = xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6);\n\tif (err < 0) {\n\t\tpr_err(\"%s: can't register ip6ip6\\n\", __func__);\n\t\tgoto out_ip6ip6;\n\t}\n\n\tif (ip6_tnl_mpls_supported()) {\n\t\terr = xfrm6_tunnel_register(&mplsip6_handler, AF_MPLS);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"%s: can't register mplsip6\\n\", __func__);\n\t\t\tgoto out_mplsip6;\n\t\t}\n\t}\n\n\terr = rtnl_link_register(&ip6_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\n\treturn 0;\n\nrtnl_link_failed:\n\tif (ip6_tnl_mpls_supported())\n\t\txfrm6_tunnel_deregister(&mplsip6_handler, AF_MPLS);\nout_mplsip6:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nout_ip6ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout_ip4ip6:\n\tunregister_pernet_device(&ip6_tnl_net_ops);\nout_pernet:\n\treturn err;\n}\n\n \n\nstatic void __exit ip6_tunnel_cleanup(void)\n{\n\trtnl_link_unregister(&ip6_link_ops);\n\tif (xfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET))\n\t\tpr_info(\"%s: can't deregister ip4ip6\\n\", __func__);\n\n\tif (xfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6))\n\t\tpr_info(\"%s: can't deregister ip6ip6\\n\", __func__);\n\n\tif (ip6_tnl_mpls_supported() &&\n\t    xfrm6_tunnel_deregister(&mplsip6_handler, AF_MPLS))\n\t\tpr_info(\"%s: can't deregister mplsip6\\n\", __func__);\n\tunregister_pernet_device(&ip6_tnl_net_ops);\n}\n\nmodule_init(ip6_tunnel_init);\nmodule_exit(ip6_tunnel_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}