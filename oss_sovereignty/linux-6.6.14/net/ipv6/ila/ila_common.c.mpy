{
  "module_name": "ila_common.c",
  "hash_id": "7df3889df8eae1799bf576e558faddf3d069177e5d52bcc4ea231feb0cbb7507",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ila/ila_common.c",
  "human_readable_source": "#include <linux/errno.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n#include <net/checksum.h>\n#include <net/ip.h>\n#include <net/ip6_fib.h>\n#include <net/lwtunnel.h>\n#include <net/protocol.h>\n#include <uapi/linux/ila.h>\n#include \"ila.h\"\n\nvoid ila_init_saved_csum(struct ila_params *p)\n{\n\tif (!p->locator_match.v64)\n\t\treturn;\n\n\tp->csum_diff = compute_csum_diff8(\n\t\t\t\t(__be32 *)&p->locator,\n\t\t\t\t(__be32 *)&p->locator_match);\n}\n\nstatic __wsum get_csum_diff_iaddr(struct ila_addr *iaddr, struct ila_params *p)\n{\n\tif (p->locator_match.v64)\n\t\treturn p->csum_diff;\n\telse\n\t\treturn compute_csum_diff8((__be32 *)&p->locator,\n\t\t\t\t\t  (__be32 *)&iaddr->loc);\n}\n\nstatic __wsum get_csum_diff(struct ipv6hdr *ip6h, struct ila_params *p)\n{\n\treturn get_csum_diff_iaddr(ila_a2i(&ip6h->daddr), p);\n}\n\nstatic void ila_csum_do_neutral_fmt(struct ila_addr *iaddr,\n\t\t\t\t    struct ila_params *p)\n{\n\t__sum16 *adjust = (__force __sum16 *)&iaddr->ident.v16[3];\n\t__wsum diff, fval;\n\n\tdiff = get_csum_diff_iaddr(iaddr, p);\n\n\tfval = (__force __wsum)(ila_csum_neutral_set(iaddr->ident) ?\n\t\t\tCSUM_NEUTRAL_FLAG : ~CSUM_NEUTRAL_FLAG);\n\n\tdiff = csum_add(diff, fval);\n\n\t*adjust = ~csum_fold(csum_add(diff, csum_unfold(*adjust)));\n\n\t \n\tiaddr->ident.csum_neutral ^= 1;\n}\n\nstatic void ila_csum_do_neutral_nofmt(struct ila_addr *iaddr,\n\t\t\t\t      struct ila_params *p)\n{\n\t__sum16 *adjust = (__force __sum16 *)&iaddr->ident.v16[3];\n\t__wsum diff;\n\n\tdiff = get_csum_diff_iaddr(iaddr, p);\n\n\t*adjust = ~csum_fold(csum_add(diff, csum_unfold(*adjust)));\n}\n\nstatic void ila_csum_adjust_transport(struct sk_buff *skb,\n\t\t\t\t      struct ila_params *p)\n{\n\tsize_t nhoff = sizeof(struct ipv6hdr);\n\tstruct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t__wsum diff;\n\n\tswitch (ip6h->nexthdr) {\n\tcase NEXTHDR_TCP:\n\t\tif (likely(pskb_may_pull(skb, nhoff + sizeof(struct tcphdr)))) {\n\t\t\tstruct tcphdr *th = (struct tcphdr *)\n\t\t\t\t\t(skb_network_header(skb) + nhoff);\n\n\t\t\tdiff = get_csum_diff(ip6h, p);\n\t\t\tinet_proto_csum_replace_by_diff(&th->check, skb,\n\t\t\t\t\t\t\tdiff, true);\n\t\t}\n\t\tbreak;\n\tcase NEXTHDR_UDP:\n\t\tif (likely(pskb_may_pull(skb, nhoff + sizeof(struct udphdr)))) {\n\t\t\tstruct udphdr *uh = (struct udphdr *)\n\t\t\t\t\t(skb_network_header(skb) + nhoff);\n\n\t\t\tif (uh->check || skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\t\tdiff = get_csum_diff(ip6h, p);\n\t\t\t\tinet_proto_csum_replace_by_diff(&uh->check, skb,\n\t\t\t\t\t\t\t\tdiff, true);\n\t\t\t\tif (!uh->check)\n\t\t\t\t\tuh->check = CSUM_MANGLED_0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NEXTHDR_ICMP:\n\t\tif (likely(pskb_may_pull(skb,\n\t\t\t\t\t nhoff + sizeof(struct icmp6hdr)))) {\n\t\t\tstruct icmp6hdr *ih = (struct icmp6hdr *)\n\t\t\t\t\t(skb_network_header(skb) + nhoff);\n\n\t\t\tdiff = get_csum_diff(ip6h, p);\n\t\t\tinet_proto_csum_replace_by_diff(&ih->icmp6_cksum, skb,\n\t\t\t\t\t\t\tdiff, true);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid ila_update_ipv6_locator(struct sk_buff *skb, struct ila_params *p,\n\t\t\t     bool sir2ila)\n{\n\tstruct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tstruct ila_addr *iaddr = ila_a2i(&ip6h->daddr);\n\n\tswitch (p->csum_mode) {\n\tcase ILA_CSUM_ADJUST_TRANSPORT:\n\t\tila_csum_adjust_transport(skb, p);\n\t\tbreak;\n\tcase ILA_CSUM_NEUTRAL_MAP:\n\t\tif (sir2ila) {\n\t\t\tif (WARN_ON(ila_csum_neutral_set(iaddr->ident))) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!ila_csum_neutral_set(iaddr->ident)) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tila_csum_do_neutral_fmt(iaddr, p);\n\t\tbreak;\n\tcase ILA_CSUM_NEUTRAL_MAP_AUTO:\n\t\tila_csum_do_neutral_nofmt(iaddr, p);\n\t\tbreak;\n\tcase ILA_CSUM_NO_ACTION:\n\t\tbreak;\n\t}\n\n\t \n\tiaddr->loc = p->locator;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}