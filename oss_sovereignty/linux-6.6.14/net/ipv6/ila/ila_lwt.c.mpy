{
  "module_name": "ila_lwt.c",
  "hash_id": "75d16d7198cf50fdf13c2f89233c4007156ef312b4dcb56328b72ea0ff77e7cb",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ila/ila_lwt.c",
  "human_readable_source": "\n#include <linux/errno.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n#include <net/checksum.h>\n#include <net/dst_cache.h>\n#include <net/ip.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n#include <net/lwtunnel.h>\n#include <net/protocol.h>\n#include <uapi/linux/ila.h>\n#include \"ila.h\"\n\nstruct ila_lwt {\n\tstruct ila_params p;\n\tstruct dst_cache dst_cache;\n\tu32 connected : 1;\n\tu32 lwt_output : 1;\n};\n\nstatic inline struct ila_lwt *ila_lwt_lwtunnel(\n\tstruct lwtunnel_state *lwt)\n{\n\treturn (struct ila_lwt *)lwt->data;\n}\n\nstatic inline struct ila_params *ila_params_lwtunnel(\n\tstruct lwtunnel_state *lwt)\n{\n\treturn &ila_lwt_lwtunnel(lwt)->p;\n}\n\nstatic int ila_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dst_entry *orig_dst = skb_dst(skb);\n\tstruct rt6_info *rt = (struct rt6_info *)orig_dst;\n\tstruct ila_lwt *ilwt = ila_lwt_lwtunnel(orig_dst->lwtstate);\n\tstruct dst_entry *dst;\n\tint err = -EINVAL;\n\n\tif (skb->protocol != htons(ETH_P_IPV6))\n\t\tgoto drop;\n\n\tif (ilwt->lwt_output)\n\t\tila_update_ipv6_locator(skb,\n\t\t\t\t\tila_params_lwtunnel(orig_dst->lwtstate),\n\t\t\t\t\ttrue);\n\n\tif (rt->rt6i_flags & (RTF_GATEWAY | RTF_CACHE)) {\n\t\t \n\t\treturn orig_dst->lwtstate->orig_output(net, sk, skb);\n\t}\n\n\tdst = dst_cache_get(&ilwt->dst_cache);\n\tif (unlikely(!dst)) {\n\t\tstruct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t\tstruct flowi6 fl6;\n\n\t\t \n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_oif = orig_dst->dev->ifindex;\n\t\tfl6.flowi6_iif = LOOPBACK_IFINDEX;\n\t\tfl6.daddr = *rt6_nexthop((struct rt6_info *)orig_dst,\n\t\t\t\t\t &ip6h->daddr);\n\n\t\tdst = ip6_route_output(net, NULL, &fl6);\n\t\tif (dst->error) {\n\t\t\terr = -EHOSTUNREACH;\n\t\t\tdst_release(dst);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);\n\t\tif (IS_ERR(dst)) {\n\t\t\terr = PTR_ERR(dst);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (ilwt->connected)\n\t\t\tdst_cache_set_ip6(&ilwt->dst_cache, dst, &fl6.saddr);\n\t}\n\n\tskb_dst_set(skb, dst);\n\treturn dst_output(net, sk, skb);\n\ndrop:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int ila_input(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ila_lwt *ilwt = ila_lwt_lwtunnel(dst->lwtstate);\n\n\tif (skb->protocol != htons(ETH_P_IPV6))\n\t\tgoto drop;\n\n\tif (!ilwt->lwt_output)\n\t\tila_update_ipv6_locator(skb,\n\t\t\t\t\tila_params_lwtunnel(dst->lwtstate),\n\t\t\t\t\tfalse);\n\n\treturn dst->lwtstate->orig_input(skb);\n\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic const struct nla_policy ila_nl_policy[ILA_ATTR_MAX + 1] = {\n\t[ILA_ATTR_LOCATOR] = { .type = NLA_U64, },\n\t[ILA_ATTR_CSUM_MODE] = { .type = NLA_U8, },\n\t[ILA_ATTR_IDENT_TYPE] = { .type = NLA_U8, },\n\t[ILA_ATTR_HOOK_TYPE] = { .type = NLA_U8, },\n};\n\nstatic int ila_build_state(struct net *net, struct nlattr *nla,\n\t\t\t   unsigned int family, const void *cfg,\n\t\t\t   struct lwtunnel_state **ts,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ila_lwt *ilwt;\n\tstruct ila_params *p;\n\tstruct nlattr *tb[ILA_ATTR_MAX + 1];\n\tstruct lwtunnel_state *newts;\n\tconst struct fib6_config *cfg6 = cfg;\n\tstruct ila_addr *iaddr;\n\tu8 ident_type = ILA_ATYPE_USE_FORMAT;\n\tu8 hook_type = ILA_HOOK_ROUTE_OUTPUT;\n\tu8 csum_mode = ILA_CSUM_NO_ACTION;\n\tbool lwt_output = true;\n\tu8 eff_ident_type;\n\tint ret;\n\n\tif (family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested_deprecated(tb, ILA_ATTR_MAX, nla,\n\t\t\t\t\t  ila_nl_policy, extack);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!tb[ILA_ATTR_LOCATOR])\n\t\treturn -EINVAL;\n\n\tiaddr = (struct ila_addr *)&cfg6->fc_dst;\n\n\tif (tb[ILA_ATTR_IDENT_TYPE])\n\t\tident_type = nla_get_u8(tb[ILA_ATTR_IDENT_TYPE]);\n\n\tif (ident_type == ILA_ATYPE_USE_FORMAT) {\n\t\t \n\n\t\tif (cfg6->fc_dst_len < 8 * sizeof(struct ila_locator) + 3) {\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\teff_ident_type = iaddr->ident.type;\n\t} else {\n\t\teff_ident_type = ident_type;\n\t}\n\n\tswitch (eff_ident_type) {\n\tcase ILA_ATYPE_IID:\n\t\t \n\t\treturn -EINVAL;\n\tcase ILA_ATYPE_LUID:\n\t\tbreak;\n\tcase ILA_ATYPE_VIRT_V4:\n\tcase ILA_ATYPE_VIRT_UNI_V6:\n\tcase ILA_ATYPE_VIRT_MULTI_V6:\n\tcase ILA_ATYPE_NONLOCAL_ADDR:\n\t\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[ILA_ATTR_HOOK_TYPE])\n\t\thook_type = nla_get_u8(tb[ILA_ATTR_HOOK_TYPE]);\n\n\tswitch (hook_type) {\n\tcase ILA_HOOK_ROUTE_OUTPUT:\n\t\tlwt_output = true;\n\t\tbreak;\n\tcase ILA_HOOK_ROUTE_INPUT:\n\t\tlwt_output = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[ILA_ATTR_CSUM_MODE])\n\t\tcsum_mode = nla_get_u8(tb[ILA_ATTR_CSUM_MODE]);\n\n\tif (csum_mode == ILA_CSUM_NEUTRAL_MAP &&\n\t    ila_csum_neutral_set(iaddr->ident)) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tnewts = lwtunnel_state_alloc(sizeof(*ilwt));\n\tif (!newts)\n\t\treturn -ENOMEM;\n\n\tilwt = ila_lwt_lwtunnel(newts);\n\tret = dst_cache_init(&ilwt->dst_cache, GFP_ATOMIC);\n\tif (ret) {\n\t\tkfree(newts);\n\t\treturn ret;\n\t}\n\n\tilwt->lwt_output = !!lwt_output;\n\n\tp = ila_params_lwtunnel(newts);\n\n\tp->csum_mode = csum_mode;\n\tp->ident_type = ident_type;\n\tp->locator.v64 = (__force __be64)nla_get_u64(tb[ILA_ATTR_LOCATOR]);\n\n\t \n\tp->locator_match = iaddr->loc;\n\n\tila_init_saved_csum(p);\n\n\tnewts->type = LWTUNNEL_ENCAP_ILA;\n\tnewts->flags |= LWTUNNEL_STATE_OUTPUT_REDIRECT |\n\t\t\tLWTUNNEL_STATE_INPUT_REDIRECT;\n\n\tif (cfg6->fc_dst_len == 8 * sizeof(struct in6_addr))\n\t\tilwt->connected = 1;\n\n\t*ts = newts;\n\n\treturn 0;\n}\n\nstatic void ila_destroy_state(struct lwtunnel_state *lwt)\n{\n\tdst_cache_destroy(&ila_lwt_lwtunnel(lwt)->dst_cache);\n}\n\nstatic int ila_fill_encap_info(struct sk_buff *skb,\n\t\t\t       struct lwtunnel_state *lwtstate)\n{\n\tstruct ila_params *p = ila_params_lwtunnel(lwtstate);\n\tstruct ila_lwt *ilwt = ila_lwt_lwtunnel(lwtstate);\n\n\tif (nla_put_u64_64bit(skb, ILA_ATTR_LOCATOR, (__force u64)p->locator.v64,\n\t\t\t      ILA_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, ILA_ATTR_CSUM_MODE, (__force u8)p->csum_mode))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, ILA_ATTR_IDENT_TYPE, (__force u8)p->ident_type))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, ILA_ATTR_HOOK_TYPE,\n\t\t       ilwt->lwt_output ? ILA_HOOK_ROUTE_OUTPUT :\n\t\t\t\t\t  ILA_HOOK_ROUTE_INPUT))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int ila_encap_nlsize(struct lwtunnel_state *lwtstate)\n{\n\treturn nla_total_size_64bit(sizeof(u64)) +  \n\t       nla_total_size(sizeof(u8)) +         \n\t       nla_total_size(sizeof(u8)) +         \n\t       nla_total_size(sizeof(u8)) +         \n\t       0;\n}\n\nstatic int ila_encap_cmp(struct lwtunnel_state *a, struct lwtunnel_state *b)\n{\n\tstruct ila_params *a_p = ila_params_lwtunnel(a);\n\tstruct ila_params *b_p = ila_params_lwtunnel(b);\n\n\treturn (a_p->locator.v64 != b_p->locator.v64);\n}\n\nstatic const struct lwtunnel_encap_ops ila_encap_ops = {\n\t.build_state = ila_build_state,\n\t.destroy_state = ila_destroy_state,\n\t.output = ila_output,\n\t.input = ila_input,\n\t.fill_encap = ila_fill_encap_info,\n\t.get_encap_size = ila_encap_nlsize,\n\t.cmp_encap = ila_encap_cmp,\n\t.owner = THIS_MODULE,\n};\n\nint ila_lwt_init(void)\n{\n\treturn lwtunnel_encap_add_ops(&ila_encap_ops, LWTUNNEL_ENCAP_ILA);\n}\n\nvoid ila_lwt_fini(void)\n{\n\tlwtunnel_encap_del_ops(&ila_encap_ops, LWTUNNEL_ENCAP_ILA);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}