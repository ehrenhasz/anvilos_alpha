{
  "module_name": "ila_xlat.c",
  "hash_id": "fbd1ac30a243f98afdf416cfa2041862b23d9fed2ce91f45aec89a407d1b80e1",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ila/ila_xlat.c",
  "human_readable_source": "\n#include <linux/jhash.h>\n#include <linux/netfilter.h>\n#include <linux/rcupdate.h>\n#include <linux/rhashtable.h>\n#include <linux/vmalloc.h>\n#include <net/genetlink.h>\n#include <net/netns/generic.h>\n#include <uapi/linux/genetlink.h>\n#include \"ila.h\"\n\nstruct ila_xlat_params {\n\tstruct ila_params ip;\n\tint ifindex;\n};\n\nstruct ila_map {\n\tstruct ila_xlat_params xp;\n\tstruct rhash_head node;\n\tstruct ila_map __rcu *next;\n\tstruct rcu_head rcu;\n};\n\n#define MAX_LOCKS 1024\n#define\tLOCKS_PER_CPU 10\n\nstatic int alloc_ila_locks(struct ila_net *ilan)\n{\n\treturn alloc_bucket_spinlocks(&ilan->xlat.locks, &ilan->xlat.locks_mask,\n\t\t\t\t      MAX_LOCKS, LOCKS_PER_CPU,\n\t\t\t\t      GFP_KERNEL);\n}\n\nstatic u32 hashrnd __read_mostly;\nstatic __always_inline void __ila_hash_secret_init(void)\n{\n\tnet_get_random_once(&hashrnd, sizeof(hashrnd));\n}\n\nstatic inline u32 ila_locator_hash(struct ila_locator loc)\n{\n\tu32 *v = (u32 *)loc.v32;\n\n\t__ila_hash_secret_init();\n\treturn jhash_2words(v[0], v[1], hashrnd);\n}\n\nstatic inline spinlock_t *ila_get_lock(struct ila_net *ilan,\n\t\t\t\t       struct ila_locator loc)\n{\n\treturn &ilan->xlat.locks[ila_locator_hash(loc) & ilan->xlat.locks_mask];\n}\n\nstatic inline int ila_cmp_wildcards(struct ila_map *ila,\n\t\t\t\t    struct ila_addr *iaddr, int ifindex)\n{\n\treturn (ila->xp.ifindex && ila->xp.ifindex != ifindex);\n}\n\nstatic inline int ila_cmp_params(struct ila_map *ila,\n\t\t\t\t struct ila_xlat_params *xp)\n{\n\treturn (ila->xp.ifindex != xp->ifindex);\n}\n\nstatic int ila_cmpfn(struct rhashtable_compare_arg *arg,\n\t\t     const void *obj)\n{\n\tconst struct ila_map *ila = obj;\n\n\treturn (ila->xp.ip.locator_match.v64 != *(__be64 *)arg->key);\n}\n\nstatic inline int ila_order(struct ila_map *ila)\n{\n\tint score = 0;\n\n\tif (ila->xp.ifindex)\n\t\tscore += 1 << 1;\n\n\treturn score;\n}\n\nstatic const struct rhashtable_params rht_params = {\n\t.nelem_hint = 1024,\n\t.head_offset = offsetof(struct ila_map, node),\n\t.key_offset = offsetof(struct ila_map, xp.ip.locator_match),\n\t.key_len = sizeof(u64),  \n\t.max_size = 1048576,\n\t.min_size = 256,\n\t.automatic_shrinking = true,\n\t.obj_cmpfn = ila_cmpfn,\n};\n\nstatic int parse_nl_config(struct genl_info *info,\n\t\t\t   struct ila_xlat_params *xp)\n{\n\tmemset(xp, 0, sizeof(*xp));\n\n\tif (info->attrs[ILA_ATTR_LOCATOR])\n\t\txp->ip.locator.v64 = (__force __be64)nla_get_u64(\n\t\t\tinfo->attrs[ILA_ATTR_LOCATOR]);\n\n\tif (info->attrs[ILA_ATTR_LOCATOR_MATCH])\n\t\txp->ip.locator_match.v64 = (__force __be64)nla_get_u64(\n\t\t\tinfo->attrs[ILA_ATTR_LOCATOR_MATCH]);\n\n\tif (info->attrs[ILA_ATTR_CSUM_MODE])\n\t\txp->ip.csum_mode = nla_get_u8(info->attrs[ILA_ATTR_CSUM_MODE]);\n\telse\n\t\txp->ip.csum_mode = ILA_CSUM_NO_ACTION;\n\n\tif (info->attrs[ILA_ATTR_IDENT_TYPE])\n\t\txp->ip.ident_type = nla_get_u8(\n\t\t\t\tinfo->attrs[ILA_ATTR_IDENT_TYPE]);\n\telse\n\t\txp->ip.ident_type = ILA_ATYPE_USE_FORMAT;\n\n\tif (info->attrs[ILA_ATTR_IFINDEX])\n\t\txp->ifindex = nla_get_s32(info->attrs[ILA_ATTR_IFINDEX]);\n\n\treturn 0;\n}\n\n \nstatic inline struct ila_map *ila_lookup_wildcards(struct ila_addr *iaddr,\n\t\t\t\t\t\t   int ifindex,\n\t\t\t\t\t\t   struct ila_net *ilan)\n{\n\tstruct ila_map *ila;\n\n\tila = rhashtable_lookup_fast(&ilan->xlat.rhash_table, &iaddr->loc,\n\t\t\t\t     rht_params);\n\twhile (ila) {\n\t\tif (!ila_cmp_wildcards(ila, iaddr, ifindex))\n\t\t\treturn ila;\n\t\tila = rcu_access_pointer(ila->next);\n\t}\n\n\treturn NULL;\n}\n\n \nstatic inline struct ila_map *ila_lookup_by_params(struct ila_xlat_params *xp,\n\t\t\t\t\t\t   struct ila_net *ilan)\n{\n\tstruct ila_map *ila;\n\n\tila = rhashtable_lookup_fast(&ilan->xlat.rhash_table,\n\t\t\t\t     &xp->ip.locator_match,\n\t\t\t\t     rht_params);\n\twhile (ila) {\n\t\tif (!ila_cmp_params(ila, xp))\n\t\t\treturn ila;\n\t\tila = rcu_access_pointer(ila->next);\n\t}\n\n\treturn NULL;\n}\n\nstatic inline void ila_release(struct ila_map *ila)\n{\n\tkfree_rcu(ila, rcu);\n}\n\nstatic void ila_free_node(struct ila_map *ila)\n{\n\tstruct ila_map *next;\n\n\t \n\twhile (ila) {\n\t\tnext = rcu_access_pointer(ila->next);\n\t\tila_release(ila);\n\t\tila = next;\n\t}\n}\n\nstatic void ila_free_cb(void *ptr, void *arg)\n{\n\tila_free_node((struct ila_map *)ptr);\n}\n\nstatic int ila_xlat_addr(struct sk_buff *skb, bool sir2ila);\n\nstatic unsigned int\nila_nf_input(void *priv,\n\t     struct sk_buff *skb,\n\t     const struct nf_hook_state *state)\n{\n\tila_xlat_addr(skb, false);\n\treturn NF_ACCEPT;\n}\n\nstatic const struct nf_hook_ops ila_nf_hook_ops[] = {\n\t{\n\t\t.hook = ila_nf_input,\n\t\t.pf = NFPROTO_IPV6,\n\t\t.hooknum = NF_INET_PRE_ROUTING,\n\t\t.priority = -1,\n\t},\n};\n\nstatic int ila_add_mapping(struct net *net, struct ila_xlat_params *xp)\n{\n\tstruct ila_net *ilan = net_generic(net, ila_net_id);\n\tstruct ila_map *ila, *head;\n\tspinlock_t *lock = ila_get_lock(ilan, xp->ip.locator_match);\n\tint err = 0, order;\n\n\tif (!ilan->xlat.hooks_registered) {\n\t\t \n\t\terr = nf_register_net_hooks(net, ila_nf_hook_ops,\n\t\t\t\t\t    ARRAY_SIZE(ila_nf_hook_ops));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tilan->xlat.hooks_registered = true;\n\t}\n\n\tila = kzalloc(sizeof(*ila), GFP_KERNEL);\n\tif (!ila)\n\t\treturn -ENOMEM;\n\n\tila_init_saved_csum(&xp->ip);\n\n\tila->xp = *xp;\n\n\torder = ila_order(ila);\n\n\tspin_lock(lock);\n\n\thead = rhashtable_lookup_fast(&ilan->xlat.rhash_table,\n\t\t\t\t      &xp->ip.locator_match,\n\t\t\t\t      rht_params);\n\tif (!head) {\n\t\t \n\t\terr = rhashtable_lookup_insert_fast(&ilan->xlat.rhash_table,\n\t\t\t\t\t\t    &ila->node, rht_params);\n\t} else {\n\t\tstruct ila_map *tila = head, *prev = NULL;\n\n\t\tdo {\n\t\t\tif (!ila_cmp_params(tila, xp)) {\n\t\t\t\terr = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (order > ila_order(tila))\n\t\t\t\tbreak;\n\n\t\t\tprev = tila;\n\t\t\ttila = rcu_dereference_protected(tila->next,\n\t\t\t\tlockdep_is_held(lock));\n\t\t} while (tila);\n\n\t\tif (prev) {\n\t\t\t \n\t\t\tRCU_INIT_POINTER(ila->next, tila);\n\t\t\trcu_assign_pointer(prev->next, ila);\n\t\t} else {\n\t\t\t \n\t\t\tRCU_INIT_POINTER(ila->next, head);\n\t\t\terr = rhashtable_replace_fast(&ilan->xlat.rhash_table,\n\t\t\t\t\t\t      &head->node,\n\t\t\t\t\t\t      &ila->node, rht_params);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(lock);\n\n\tif (err)\n\t\tkfree(ila);\n\n\treturn err;\n}\n\nstatic int ila_del_mapping(struct net *net, struct ila_xlat_params *xp)\n{\n\tstruct ila_net *ilan = net_generic(net, ila_net_id);\n\tstruct ila_map *ila, *head, *prev;\n\tspinlock_t *lock = ila_get_lock(ilan, xp->ip.locator_match);\n\tint err = -ENOENT;\n\n\tspin_lock(lock);\n\n\thead = rhashtable_lookup_fast(&ilan->xlat.rhash_table,\n\t\t\t\t      &xp->ip.locator_match, rht_params);\n\tila = head;\n\n\tprev = NULL;\n\n\twhile (ila) {\n\t\tif (ila_cmp_params(ila, xp)) {\n\t\t\tprev = ila;\n\t\t\tila = rcu_dereference_protected(ila->next,\n\t\t\t\t\t\t\tlockdep_is_held(lock));\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = 0;\n\n\t\tif (prev) {\n\t\t\t \n\t\t\trcu_assign_pointer(prev->next, ila->next);\n\t\t} else {\n\t\t\t \n\t\t\thead = rcu_dereference_protected(ila->next,\n\t\t\t\t\t\t\t lockdep_is_held(lock));\n\t\t\tif (head) {\n\t\t\t\t \n\t\t\t\terr = rhashtable_replace_fast(\n\t\t\t\t\t&ilan->xlat.rhash_table, &ila->node,\n\t\t\t\t\t&head->node, rht_params);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\terr = rhashtable_remove_fast(\n\t\t\t\t\t\t&ilan->xlat.rhash_table,\n\t\t\t\t\t\t&ila->node, rht_params);\n\t\t\t}\n\t\t}\n\n\t\tila_release(ila);\n\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock(lock);\n\n\treturn err;\n}\n\nint ila_xlat_nl_cmd_add_mapping(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct ila_xlat_params p;\n\tint err;\n\n\terr = parse_nl_config(info, &p);\n\tif (err)\n\t\treturn err;\n\n\treturn ila_add_mapping(net, &p);\n}\n\nint ila_xlat_nl_cmd_del_mapping(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct ila_xlat_params xp;\n\tint err;\n\n\terr = parse_nl_config(info, &xp);\n\tif (err)\n\t\treturn err;\n\n\tila_del_mapping(net, &xp);\n\n\treturn 0;\n}\n\nstatic inline spinlock_t *lock_from_ila_map(struct ila_net *ilan,\n\t\t\t\t\t    struct ila_map *ila)\n{\n\treturn ila_get_lock(ilan, ila->xp.ip.locator_match);\n}\n\nint ila_xlat_nl_cmd_flush(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct ila_net *ilan = net_generic(net, ila_net_id);\n\tstruct rhashtable_iter iter;\n\tstruct ila_map *ila;\n\tspinlock_t *lock;\n\tint ret = 0;\n\n\trhashtable_walk_enter(&ilan->xlat.rhash_table, &iter);\n\trhashtable_walk_start(&iter);\n\n\tfor (;;) {\n\t\tila = rhashtable_walk_next(&iter);\n\n\t\tif (IS_ERR(ila)) {\n\t\t\tif (PTR_ERR(ila) == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tret = PTR_ERR(ila);\n\t\t\tgoto done;\n\t\t} else if (!ila) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlock = lock_from_ila_map(ilan, ila);\n\n\t\tspin_lock(lock);\n\n\t\tret = rhashtable_remove_fast(&ilan->xlat.rhash_table,\n\t\t\t\t\t     &ila->node, rht_params);\n\t\tif (!ret)\n\t\t\tila_free_node(ila);\n\n\t\tspin_unlock(lock);\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ndone:\n\trhashtable_walk_stop(&iter);\n\trhashtable_walk_exit(&iter);\n\treturn ret;\n}\n\nstatic int ila_fill_info(struct ila_map *ila, struct sk_buff *msg)\n{\n\tif (nla_put_u64_64bit(msg, ILA_ATTR_LOCATOR,\n\t\t\t      (__force u64)ila->xp.ip.locator.v64,\n\t\t\t      ILA_ATTR_PAD) ||\n\t    nla_put_u64_64bit(msg, ILA_ATTR_LOCATOR_MATCH,\n\t\t\t      (__force u64)ila->xp.ip.locator_match.v64,\n\t\t\t      ILA_ATTR_PAD) ||\n\t    nla_put_s32(msg, ILA_ATTR_IFINDEX, ila->xp.ifindex) ||\n\t    nla_put_u8(msg, ILA_ATTR_CSUM_MODE, ila->xp.ip.csum_mode) ||\n\t    nla_put_u8(msg, ILA_ATTR_IDENT_TYPE, ila->xp.ip.ident_type))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int ila_dump_info(struct ila_map *ila,\n\t\t\t u32 portid, u32 seq, u32 flags,\n\t\t\t struct sk_buff *skb, u8 cmd)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, portid, seq, &ila_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tif (ila_fill_info(ila, skb) < 0)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nint ila_xlat_nl_cmd_get_mapping(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct ila_net *ilan = net_generic(net, ila_net_id);\n\tstruct sk_buff *msg;\n\tstruct ila_xlat_params xp;\n\tstruct ila_map *ila;\n\tint ret;\n\n\tret = parse_nl_config(info, &xp);\n\tif (ret)\n\t\treturn ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\trcu_read_lock();\n\n\tret = -ESRCH;\n\tila = ila_lookup_by_params(&xp, ilan);\n\tif (ila) {\n\t\tret = ila_dump_info(ila,\n\t\t\t\t    info->snd_portid,\n\t\t\t\t    info->snd_seq, 0, msg,\n\t\t\t\t    info->genlhdr->cmd);\n\t}\n\n\trcu_read_unlock();\n\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\treturn genlmsg_reply(msg, info);\n\nout_free:\n\tnlmsg_free(msg);\n\treturn ret;\n}\n\nstruct ila_dump_iter {\n\tstruct rhashtable_iter rhiter;\n\tint skip;\n};\n\nint ila_xlat_nl_dump_start(struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(cb->skb->sk);\n\tstruct ila_net *ilan = net_generic(net, ila_net_id);\n\tstruct ila_dump_iter *iter;\n\n\titer = kmalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\trhashtable_walk_enter(&ilan->xlat.rhash_table, &iter->rhiter);\n\n\titer->skip = 0;\n\tcb->args[0] = (long)iter;\n\n\treturn 0;\n}\n\nint ila_xlat_nl_dump_done(struct netlink_callback *cb)\n{\n\tstruct ila_dump_iter *iter = (struct ila_dump_iter *)cb->args[0];\n\n\trhashtable_walk_exit(&iter->rhiter);\n\n\tkfree(iter);\n\n\treturn 0;\n}\n\nint ila_xlat_nl_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct ila_dump_iter *iter = (struct ila_dump_iter *)cb->args[0];\n\tstruct rhashtable_iter *rhiter = &iter->rhiter;\n\tint skip = iter->skip;\n\tstruct ila_map *ila;\n\tint ret;\n\n\trhashtable_walk_start(rhiter);\n\n\t \n\tila = rhashtable_walk_peek(rhiter);\n\n\tif (ila && !IS_ERR(ila) && skip) {\n\t\t \n\n\t\twhile (ila && skip) {\n\t\t\t \n\t\t\tila = rcu_access_pointer(ila->next);\n\t\t\tskip--;\n\t\t}\n\t}\n\n\tskip = 0;\n\n\tfor (;;) {\n\t\tif (IS_ERR(ila)) {\n\t\t\tret = PTR_ERR(ila);\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\t \n\n\t\t\t\tgoto out_ret;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (!ila) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\twhile (ila) {\n\t\t\tret =  ila_dump_info(ila, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t     cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t     skb, ILA_CMD_GET);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tskip++;\n\t\t\tila = rcu_access_pointer(ila->next);\n\t\t}\n\n\t\tskip = 0;\n\t\tila = rhashtable_walk_next(rhiter);\n\t}\n\nout:\n\titer->skip = skip;\n\tret = (skb->len ? : ret);\n\nout_ret:\n\trhashtable_walk_stop(rhiter);\n\treturn ret;\n}\n\nint ila_xlat_init_net(struct net *net)\n{\n\tstruct ila_net *ilan = net_generic(net, ila_net_id);\n\tint err;\n\n\terr = alloc_ila_locks(ilan);\n\tif (err)\n\t\treturn err;\n\n\terr = rhashtable_init(&ilan->xlat.rhash_table, &rht_params);\n\tif (err) {\n\t\tfree_bucket_spinlocks(ilan->xlat.locks);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid ila_xlat_exit_net(struct net *net)\n{\n\tstruct ila_net *ilan = net_generic(net, ila_net_id);\n\n\trhashtable_free_and_destroy(&ilan->xlat.rhash_table, ila_free_cb, NULL);\n\n\tfree_bucket_spinlocks(ilan->xlat.locks);\n\n\tif (ilan->xlat.hooks_registered)\n\t\tnf_unregister_net_hooks(net, ila_nf_hook_ops,\n\t\t\t\t\tARRAY_SIZE(ila_nf_hook_ops));\n}\n\nstatic int ila_xlat_addr(struct sk_buff *skb, bool sir2ila)\n{\n\tstruct ila_map *ila;\n\tstruct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct ila_net *ilan = net_generic(net, ila_net_id);\n\tstruct ila_addr *iaddr = ila_a2i(&ip6h->daddr);\n\n\t \n\n\t \n\n\trcu_read_lock();\n\n\tila = ila_lookup_wildcards(iaddr, skb->dev->ifindex, ilan);\n\tif (ila)\n\t\tila_update_ipv6_locator(skb, &ila->xp.ip, sir2ila);\n\n\trcu_read_unlock();\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}