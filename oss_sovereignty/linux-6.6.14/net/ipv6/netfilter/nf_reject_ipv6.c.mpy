{
  "module_name": "nf_reject_ipv6.c",
  "hash_id": "d03452fd14fce33d4bd2a575252bfc158d5bc435ded43d3e139db35b1ea8821c",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/nf_reject_ipv6.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_checksum.h>\n#include <net/netfilter/ipv6/nf_reject.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_bridge.h>\n\nstatic bool nf_reject_v6_csum_ok(struct sk_buff *skb, int hook)\n{\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tint thoff;\n\t__be16 fo;\n\tu8 proto = ip6h->nexthdr;\n\n\tif (skb_csum_unnecessary(skb))\n\t\treturn true;\n\n\tif (ip6h->payload_len &&\n\t    pskb_trim_rcsum(skb, ntohs(ip6h->payload_len) + sizeof(*ip6h)))\n\t\treturn false;\n\n\tip6h = ipv6_hdr(skb);\n\tthoff = ipv6_skip_exthdr(skb, ((u8*)(ip6h+1) - skb->data), &proto, &fo);\n\tif (thoff < 0 || thoff >= skb->len || (fo & htons(~0x7)) != 0)\n\t\treturn false;\n\n\tif (!nf_reject_verify_csum(skb, thoff, proto))\n\t\treturn true;\n\n\treturn nf_ip6_checksum(skb, hook, thoff, proto) == 0;\n}\n\nstatic int nf_reject_ip6hdr_validate(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *hdr;\n\tu32 pkt_len;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\treturn 0;\n\n\thdr = ipv6_hdr(skb);\n\tif (hdr->version != 6)\n\t\treturn 0;\n\n\tpkt_len = ntohs(hdr->payload_len);\n\tif (pkt_len + sizeof(struct ipv6hdr) > skb->len)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstruct sk_buff *nf_reject_skb_v6_tcp_reset(struct net *net,\n\t\t\t\t\t   struct sk_buff *oldskb,\n\t\t\t\t\t   const struct net_device *dev,\n\t\t\t\t\t   int hook)\n{\n\tstruct sk_buff *nskb;\n\tconst struct tcphdr *oth;\n\tstruct tcphdr _oth;\n\tunsigned int otcplen;\n\tstruct ipv6hdr *nip6h;\n\n\tif (!nf_reject_ip6hdr_validate(oldskb))\n\t\treturn NULL;\n\n\toth = nf_reject_ip6_tcphdr_get(oldskb, &_oth, &otcplen, hook);\n\tif (!oth)\n\t\treturn NULL;\n\n\tnskb = alloc_skb(sizeof(struct ipv6hdr) + sizeof(struct tcphdr) +\n\t\t\t LL_MAX_HEADER, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn NULL;\n\n\tnskb->dev = (struct net_device *)dev;\n\n\tskb_reserve(nskb, LL_MAX_HEADER);\n\tnip6h = nf_reject_ip6hdr_put(nskb, oldskb, IPPROTO_TCP,\n\t\t\t\t     net->ipv6.devconf_all->hop_limit);\n\tnf_reject_ip6_tcphdr_put(nskb, oldskb, oth, otcplen);\n\tnip6h->payload_len = htons(nskb->len - sizeof(struct ipv6hdr));\n\n\treturn nskb;\n}\nEXPORT_SYMBOL_GPL(nf_reject_skb_v6_tcp_reset);\n\nstruct sk_buff *nf_reject_skb_v6_unreach(struct net *net,\n\t\t\t\t\t struct sk_buff *oldskb,\n\t\t\t\t\t const struct net_device *dev,\n\t\t\t\t\t int hook, u8 code)\n{\n\tstruct sk_buff *nskb;\n\tstruct ipv6hdr *nip6h;\n\tstruct icmp6hdr *icmp6h;\n\tunsigned int len;\n\n\tif (!nf_reject_ip6hdr_validate(oldskb))\n\t\treturn NULL;\n\n\t \n\tlen = min_t(unsigned int, 1220, oldskb->len);\n\n\tif (!pskb_may_pull(oldskb, len))\n\t\treturn NULL;\n\n\tif (!nf_reject_v6_csum_ok(oldskb, hook))\n\t\treturn NULL;\n\n\tnskb = alloc_skb(sizeof(struct ipv6hdr) + sizeof(struct icmp6hdr) +\n\t\t\t LL_MAX_HEADER + len, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn NULL;\n\n\tnskb->dev = (struct net_device *)dev;\n\n\tskb_reserve(nskb, LL_MAX_HEADER);\n\tnip6h = nf_reject_ip6hdr_put(nskb, oldskb, IPPROTO_ICMPV6,\n\t\t\t\t     net->ipv6.devconf_all->hop_limit);\n\n\tskb_reset_transport_header(nskb);\n\ticmp6h = skb_put_zero(nskb, sizeof(struct icmp6hdr));\n\ticmp6h->icmp6_type = ICMPV6_DEST_UNREACH;\n\ticmp6h->icmp6_code = code;\n\n\tskb_put_data(nskb, skb_network_header(oldskb), len);\n\tnip6h->payload_len = htons(nskb->len - sizeof(struct ipv6hdr));\n\n\ticmp6h->icmp6_cksum =\n\t\tcsum_ipv6_magic(&nip6h->saddr, &nip6h->daddr,\n\t\t\t\tnskb->len - sizeof(struct ipv6hdr),\n\t\t\t\tIPPROTO_ICMPV6,\n\t\t\t\tcsum_partial(icmp6h,\n\t\t\t\t\t     nskb->len - sizeof(struct ipv6hdr),\n\t\t\t\t\t     0));\n\n\treturn nskb;\n}\nEXPORT_SYMBOL_GPL(nf_reject_skb_v6_unreach);\n\nconst struct tcphdr *nf_reject_ip6_tcphdr_get(struct sk_buff *oldskb,\n\t\t\t\t\t      struct tcphdr *otcph,\n\t\t\t\t\t      unsigned int *otcplen, int hook)\n{\n\tconst struct ipv6hdr *oip6h = ipv6_hdr(oldskb);\n\tu8 proto;\n\t__be16 frag_off;\n\tint tcphoff;\n\n\tproto = oip6h->nexthdr;\n\ttcphoff = ipv6_skip_exthdr(oldskb, ((u8 *)(oip6h + 1) - oldskb->data),\n\t\t\t\t   &proto, &frag_off);\n\n\tif ((tcphoff < 0) || (tcphoff > oldskb->len)) {\n\t\tpr_debug(\"Cannot get TCP header.\\n\");\n\t\treturn NULL;\n\t}\n\n\t*otcplen = oldskb->len - tcphoff;\n\n\t \n\tif (proto != IPPROTO_TCP || *otcplen < sizeof(struct tcphdr)) {\n\t\tpr_debug(\"proto(%d) != IPPROTO_TCP or too short (len = %d)\\n\",\n\t\t\t proto, *otcplen);\n\t\treturn NULL;\n\t}\n\n\totcph = skb_header_pointer(oldskb, tcphoff, sizeof(struct tcphdr),\n\t\t\t\t   otcph);\n\tif (otcph == NULL)\n\t\treturn NULL;\n\n\t \n\tif (otcph->rst) {\n\t\tpr_debug(\"RST is set\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tif (nf_ip6_checksum(oldskb, hook, tcphoff, IPPROTO_TCP)) {\n\t\tpr_debug(\"TCP checksum is invalid\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn otcph;\n}\nEXPORT_SYMBOL_GPL(nf_reject_ip6_tcphdr_get);\n\nstruct ipv6hdr *nf_reject_ip6hdr_put(struct sk_buff *nskb,\n\t\t\t\t     const struct sk_buff *oldskb,\n\t\t\t\t     __u8 protocol, int hoplimit)\n{\n\tstruct ipv6hdr *ip6h;\n\tconst struct ipv6hdr *oip6h = ipv6_hdr(oldskb);\n#define DEFAULT_TOS_VALUE\t0x0U\n\tconst __u8 tclass = DEFAULT_TOS_VALUE;\n\n\tskb_put(nskb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(nskb);\n\tip6h = ipv6_hdr(nskb);\n\tip6_flow_hdr(ip6h, tclass, 0);\n\tip6h->hop_limit = hoplimit;\n\tip6h->nexthdr = protocol;\n\tip6h->saddr = oip6h->daddr;\n\tip6h->daddr = oip6h->saddr;\n\n\tnskb->protocol = htons(ETH_P_IPV6);\n\n\treturn ip6h;\n}\nEXPORT_SYMBOL_GPL(nf_reject_ip6hdr_put);\n\nvoid nf_reject_ip6_tcphdr_put(struct sk_buff *nskb,\n\t\t\t      const struct sk_buff *oldskb,\n\t\t\t      const struct tcphdr *oth, unsigned int otcplen)\n{\n\tstruct tcphdr *tcph;\n\tint needs_ack;\n\n\tskb_reset_transport_header(nskb);\n\ttcph = skb_put(nskb, sizeof(struct tcphdr));\n\t \n\ttcph->doff = sizeof(struct tcphdr)/4;\n\ttcph->source = oth->dest;\n\ttcph->dest = oth->source;\n\n\tif (oth->ack) {\n\t\tneeds_ack = 0;\n\t\ttcph->seq = oth->ack_seq;\n\t\ttcph->ack_seq = 0;\n\t} else {\n\t\tneeds_ack = 1;\n\t\ttcph->ack_seq = htonl(ntohl(oth->seq) + oth->syn + oth->fin +\n\t\t\t\t      otcplen - (oth->doff<<2));\n\t\ttcph->seq = 0;\n\t}\n\n\t \n\t((u_int8_t *)tcph)[13] = 0;\n\ttcph->rst = 1;\n\ttcph->ack = needs_ack;\n\ttcph->window = 0;\n\ttcph->urg_ptr = 0;\n\ttcph->check = 0;\n\n\t \n\ttcph->check = csum_ipv6_magic(&ipv6_hdr(nskb)->saddr,\n\t\t\t\t      &ipv6_hdr(nskb)->daddr,\n\t\t\t\t      sizeof(struct tcphdr), IPPROTO_TCP,\n\t\t\t\t      csum_partial(tcph,\n\t\t\t\t\t\t   sizeof(struct tcphdr), 0));\n}\nEXPORT_SYMBOL_GPL(nf_reject_ip6_tcphdr_put);\n\nstatic int nf_reject6_fill_skb_dst(struct sk_buff *skb_in)\n{\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi fl;\n\n\tmemset(&fl, 0, sizeof(struct flowi));\n\tfl.u.ip6.daddr = ipv6_hdr(skb_in)->saddr;\n\tnf_ip6_route(dev_net(skb_in->dev), &dst, &fl, false);\n\tif (!dst)\n\t\treturn -1;\n\n\tskb_dst_set(skb_in, dst);\n\treturn 0;\n}\n\nvoid nf_send_reset6(struct net *net, struct sock *sk, struct sk_buff *oldskb,\n\t\t    int hook)\n{\n\tstruct sk_buff *nskb;\n\tstruct tcphdr _otcph;\n\tconst struct tcphdr *otcph;\n\tunsigned int otcplen, hh_len;\n\tconst struct ipv6hdr *oip6h = ipv6_hdr(oldskb);\n\tstruct ipv6hdr *ip6h;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi6 fl6;\n\n\tif ((!(ipv6_addr_type(&oip6h->saddr) & IPV6_ADDR_UNICAST)) ||\n\t    (!(ipv6_addr_type(&oip6h->daddr) & IPV6_ADDR_UNICAST))) {\n\t\tpr_debug(\"addr is not unicast.\\n\");\n\t\treturn;\n\t}\n\n\totcph = nf_reject_ip6_tcphdr_get(oldskb, &_otcph, &otcplen, hook);\n\tif (!otcph)\n\t\treturn;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tfl6.saddr = oip6h->daddr;\n\tfl6.daddr = oip6h->saddr;\n\tfl6.fl6_sport = otcph->dest;\n\tfl6.fl6_dport = otcph->source;\n\n\tif (hook == NF_INET_PRE_ROUTING || hook == NF_INET_INGRESS) {\n\t\tnf_ip6_route(net, &dst, flowi6_to_flowi(&fl6), false);\n\t\tif (!dst)\n\t\t\treturn;\n\t\tskb_dst_set(oldskb, dst);\n\t}\n\n\tfl6.flowi6_oif = l3mdev_master_ifindex(skb_dst(oldskb)->dev);\n\tfl6.flowi6_mark = IP6_REPLY_MARK(net, oldskb->mark);\n\tsecurity_skb_classify_flow(oldskb, flowi6_to_flowi_common(&fl6));\n\tdst = ip6_route_output(net, NULL, &fl6);\n\tif (dst->error) {\n\t\tdst_release(dst);\n\t\treturn;\n\t}\n\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);\n\tif (IS_ERR(dst))\n\t\treturn;\n\n\thh_len = (dst->dev->hard_header_len + 15)&~15;\n\tnskb = alloc_skb(hh_len + 15 + dst->header_len + sizeof(struct ipv6hdr)\n\t\t\t + sizeof(struct tcphdr) + dst->trailer_len,\n\t\t\t GFP_ATOMIC);\n\n\tif (!nskb) {\n\t\tnet_dbg_ratelimited(\"cannot alloc skb\\n\");\n\t\tdst_release(dst);\n\t\treturn;\n\t}\n\n\tskb_dst_set(nskb, dst);\n\n\tnskb->mark = fl6.flowi6_mark;\n\n\tskb_reserve(nskb, hh_len + dst->header_len);\n\tip6h = nf_reject_ip6hdr_put(nskb, oldskb, IPPROTO_TCP,\n\t\t\t\t    ip6_dst_hoplimit(dst));\n\tnf_reject_ip6_tcphdr_put(nskb, oldskb, otcph, otcplen);\n\n\tnf_ct_attach(nskb, oldskb);\n\tnf_ct_set_closing(skb_nfct(oldskb));\n\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\n\t \n\tif (nf_bridge_info_exists(oldskb)) {\n\t\tstruct ethhdr *oeth = eth_hdr(oldskb);\n\t\tstruct net_device *br_indev;\n\n\t\tbr_indev = nf_bridge_get_physindev(oldskb, net);\n\t\tif (!br_indev) {\n\t\t\tkfree_skb(nskb);\n\t\t\treturn;\n\t\t}\n\n\t\tnskb->dev = br_indev;\n\t\tnskb->protocol = htons(ETH_P_IPV6);\n\t\tip6h->payload_len = htons(sizeof(struct tcphdr));\n\t\tif (dev_hard_header(nskb, nskb->dev, ntohs(nskb->protocol),\n\t\t\t\t    oeth->h_source, oeth->h_dest, nskb->len) < 0) {\n\t\t\tkfree_skb(nskb);\n\t\t\treturn;\n\t\t}\n\t\tdev_queue_xmit(nskb);\n\t} else\n#endif\n\t\tip6_local_out(net, sk, nskb);\n}\nEXPORT_SYMBOL_GPL(nf_send_reset6);\n\nstatic bool reject6_csum_ok(struct sk_buff *skb, int hook)\n{\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tint thoff;\n\t__be16 fo;\n\tu8 proto;\n\n\tif (skb_csum_unnecessary(skb))\n\t\treturn true;\n\n\tproto = ip6h->nexthdr;\n\tthoff = ipv6_skip_exthdr(skb, ((u8 *)(ip6h + 1) - skb->data), &proto, &fo);\n\n\tif (thoff < 0 || thoff >= skb->len || (fo & htons(~0x7)) != 0)\n\t\treturn false;\n\n\tif (!nf_reject_verify_csum(skb, thoff, proto))\n\t\treturn true;\n\n\treturn nf_ip6_checksum(skb, hook, thoff, proto) == 0;\n}\n\nvoid nf_send_unreach6(struct net *net, struct sk_buff *skb_in,\n\t\t      unsigned char code, unsigned int hooknum)\n{\n\tif (!reject6_csum_ok(skb_in, hooknum))\n\t\treturn;\n\n\tif (hooknum == NF_INET_LOCAL_OUT && skb_in->dev == NULL)\n\t\tskb_in->dev = net->loopback_dev;\n\n\tif ((hooknum == NF_INET_PRE_ROUTING || hooknum == NF_INET_INGRESS) &&\n\t    nf_reject6_fill_skb_dst(skb_in) < 0)\n\t\treturn;\n\n\ticmpv6_send(skb_in, ICMPV6_DEST_UNREACH, code, 0);\n}\nEXPORT_SYMBOL_GPL(nf_send_unreach6);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}