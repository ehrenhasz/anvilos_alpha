{
  "module_name": "ip6t_rt.c",
  "hash_id": "40698df7e7a5d31931794ccd09f3bdaa611710e4e881a758ff8944278ca4201e",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/ip6t_rt.c",
  "human_readable_source": "\n \n\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ipv6.h>\n#include <linux/types.h>\n#include <net/checksum.h>\n#include <net/ipv6.h>\n\n#include <asm/byteorder.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <linux/netfilter_ipv6/ip6t_rt.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Xtables: IPv6 Routing Header match\");\nMODULE_AUTHOR(\"Andras Kis-Szabo <kisza@sch.bme.hu>\");\n\n \nstatic inline bool\nsegsleft_match(u_int32_t min, u_int32_t max, u_int32_t id, bool invert)\n{\n\treturn (id >= min && id <= max) ^ invert;\n}\n\nstatic bool rt_mt6(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tstruct ipv6_rt_hdr _route;\n\tconst struct ipv6_rt_hdr *rh;\n\tconst struct ip6t_rt *rtinfo = par->matchinfo;\n\tunsigned int temp;\n\tunsigned int ptr = 0;\n\tunsigned int hdrlen = 0;\n\tbool ret = false;\n\tstruct in6_addr _addr;\n\tconst struct in6_addr *ap;\n\tint err;\n\n\terr = ipv6_find_hdr(skb, &ptr, NEXTHDR_ROUTING, NULL, NULL);\n\tif (err < 0) {\n\t\tif (err != -ENOENT)\n\t\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\n\trh = skb_header_pointer(skb, ptr, sizeof(_route), &_route);\n\tif (rh == NULL) {\n\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\n\thdrlen = ipv6_optlen(rh);\n\tif (skb->len - ptr < hdrlen) {\n\t\t \n\t\treturn false;\n\t}\n\n\tret = (segsleft_match(rtinfo->segsleft[0], rtinfo->segsleft[1],\n\t\t\t      rh->segments_left,\n\t\t\t      !!(rtinfo->invflags & IP6T_RT_INV_SGS))) &&\n\t      (!(rtinfo->flags & IP6T_RT_LEN) ||\n\t       ((rtinfo->hdrlen == hdrlen) ^\n\t\t!!(rtinfo->invflags & IP6T_RT_INV_LEN))) &&\n\t      (!(rtinfo->flags & IP6T_RT_TYP) ||\n\t       ((rtinfo->rt_type == rh->type) ^\n\t\t!!(rtinfo->invflags & IP6T_RT_INV_TYP)));\n\n\tif (ret && (rtinfo->flags & IP6T_RT_RES)) {\n\t\tconst u_int32_t *rp;\n\t\tu_int32_t _reserved;\n\t\trp = skb_header_pointer(skb,\n\t\t\t\t\tptr + offsetof(struct rt0_hdr,\n\t\t\t\t\t\t       reserved),\n\t\t\t\t\tsizeof(_reserved),\n\t\t\t\t\t&_reserved);\n\t\tif (!rp) {\n\t\t\tpar->hotdrop = true;\n\t\t\treturn false;\n\t\t}\n\n\t\tret = (*rp == 0);\n\t}\n\n\tif (!(rtinfo->flags & IP6T_RT_FST)) {\n\t\treturn ret;\n\t} else if (rtinfo->flags & IP6T_RT_FST_NSTRICT) {\n\t\tif (rtinfo->addrnr > (unsigned int)((hdrlen - 8) / 16)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tunsigned int i = 0;\n\n\t\t\tfor (temp = 0;\n\t\t\t     temp < (unsigned int)((hdrlen - 8) / 16);\n\t\t\t     temp++) {\n\t\t\t\tap = skb_header_pointer(skb,\n\t\t\t\t\t\t\tptr\n\t\t\t\t\t\t\t+ sizeof(struct rt0_hdr)\n\t\t\t\t\t\t\t+ temp * sizeof(_addr),\n\t\t\t\t\t\t\tsizeof(_addr),\n\t\t\t\t\t\t\t&_addr);\n\n\t\t\t\tif (ap == NULL) {\n\t\t\t\t\tpar->hotdrop = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (ipv6_addr_equal(ap, &rtinfo->addrs[i]))\n\t\t\t\t\ti++;\n\t\t\t\tif (i == rtinfo->addrnr)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == rtinfo->addrnr)\n\t\t\t\treturn ret;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (rtinfo->addrnr > (unsigned int)((hdrlen - 8) / 16)) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tfor (temp = 0; temp < rtinfo->addrnr; temp++) {\n\t\t\t\tap = skb_header_pointer(skb,\n\t\t\t\t\t\t\tptr\n\t\t\t\t\t\t\t+ sizeof(struct rt0_hdr)\n\t\t\t\t\t\t\t+ temp * sizeof(_addr),\n\t\t\t\t\t\t\tsizeof(_addr),\n\t\t\t\t\t\t\t&_addr);\n\t\t\t\tif (ap == NULL) {\n\t\t\t\t\tpar->hotdrop = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (!ipv6_addr_equal(ap, &rtinfo->addrs[temp]))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (temp == rtinfo->addrnr &&\n\t\t\t    temp == (unsigned int)((hdrlen - 8) / 16))\n\t\t\t\treturn ret;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int rt_mt6_check(const struct xt_mtchk_param *par)\n{\n\tconst struct ip6t_rt *rtinfo = par->matchinfo;\n\n\tif (rtinfo->invflags & ~IP6T_RT_INV_MASK) {\n\t\tpr_debug(\"unknown flags %X\\n\", rtinfo->invflags);\n\t\treturn -EINVAL;\n\t}\n\tif ((rtinfo->flags & (IP6T_RT_RES | IP6T_RT_FST_MASK)) &&\n\t    (!(rtinfo->flags & IP6T_RT_TYP) ||\n\t     (rtinfo->rt_type != 0) ||\n\t     (rtinfo->invflags & IP6T_RT_INV_TYP))) {\n\t\tpr_debug(\"`--rt-type 0' required before `--rt-0-*'\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct xt_match rt_mt6_reg __read_mostly = {\n\t.name\t\t= \"rt\",\n\t.family\t\t= NFPROTO_IPV6,\n\t.match\t\t= rt_mt6,\n\t.matchsize\t= sizeof(struct ip6t_rt),\n\t.checkentry\t= rt_mt6_check,\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init rt_mt6_init(void)\n{\n\treturn xt_register_match(&rt_mt6_reg);\n}\n\nstatic void __exit rt_mt6_exit(void)\n{\n\txt_unregister_match(&rt_mt6_reg);\n}\n\nmodule_init(rt_mt6_init);\nmodule_exit(rt_mt6_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}