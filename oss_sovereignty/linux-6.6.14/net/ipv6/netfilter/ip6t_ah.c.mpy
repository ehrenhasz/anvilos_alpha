{
  "module_name": "ip6t_ah.c",
  "hash_id": "6bf21383c22c6cf24c9714dc82615a426ddbf3c2727d759dedcfba54c865de42",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/ip6t_ah.c",
  "human_readable_source": "\n \n\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/types.h>\n#include <net/checksum.h>\n#include <net/ipv6.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <linux/netfilter_ipv6/ip6t_ah.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Xtables: IPv6 IPsec-AH match\");\nMODULE_AUTHOR(\"Andras Kis-Szabo <kisza@sch.bme.hu>\");\n\n \nstatic inline bool\nspi_match(u_int32_t min, u_int32_t max, u_int32_t spi, bool invert)\n{\n\tbool r;\n\n\tpr_debug(\"spi_match:%c 0x%x <= 0x%x <= 0x%x\\n\",\n\t\t invert ? '!' : ' ', min, spi, max);\n\tr = (spi >= min && spi <= max) ^ invert;\n\tpr_debug(\" result %s\\n\", r ? \"PASS\" : \"FAILED\");\n\treturn r;\n}\n\nstatic bool ah_mt6(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tstruct ip_auth_hdr _ah;\n\tconst struct ip_auth_hdr *ah;\n\tconst struct ip6t_ah *ahinfo = par->matchinfo;\n\tunsigned int ptr = 0;\n\tunsigned int hdrlen = 0;\n\tint err;\n\n\terr = ipv6_find_hdr(skb, &ptr, NEXTHDR_AUTH, NULL, NULL);\n\tif (err < 0) {\n\t\tif (err != -ENOENT)\n\t\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\n\tah = skb_header_pointer(skb, ptr, sizeof(_ah), &_ah);\n\tif (ah == NULL) {\n\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\n\thdrlen = ipv6_authlen(ah);\n\n\tpr_debug(\"IPv6 AH LEN %u %u \", hdrlen, ah->hdrlen);\n\tpr_debug(\"RES %04X \", ah->reserved);\n\tpr_debug(\"SPI %u %08X\\n\", ntohl(ah->spi), ntohl(ah->spi));\n\n\tpr_debug(\"IPv6 AH spi %02X \",\n\t\t spi_match(ahinfo->spis[0], ahinfo->spis[1],\n\t\t\t   ntohl(ah->spi),\n\t\t\t   !!(ahinfo->invflags & IP6T_AH_INV_SPI)));\n\tpr_debug(\"len %02X %04X %02X \",\n\t\t ahinfo->hdrlen, hdrlen,\n\t\t (!ahinfo->hdrlen ||\n\t\t  (ahinfo->hdrlen == hdrlen) ^\n\t\t  !!(ahinfo->invflags & IP6T_AH_INV_LEN)));\n\tpr_debug(\"res %02X %04X %02X\\n\",\n\t\t ahinfo->hdrres, ah->reserved,\n\t\t !(ahinfo->hdrres && ah->reserved));\n\n\treturn spi_match(ahinfo->spis[0], ahinfo->spis[1],\n\t\t\t  ntohl(ah->spi),\n\t\t\t  !!(ahinfo->invflags & IP6T_AH_INV_SPI)) &&\n\t\t(!ahinfo->hdrlen ||\n\t\t (ahinfo->hdrlen == hdrlen) ^\n\t\t !!(ahinfo->invflags & IP6T_AH_INV_LEN)) &&\n\t\t!(ahinfo->hdrres && ah->reserved);\n}\n\nstatic int ah_mt6_check(const struct xt_mtchk_param *par)\n{\n\tconst struct ip6t_ah *ahinfo = par->matchinfo;\n\n\tif (ahinfo->invflags & ~IP6T_AH_INV_MASK) {\n\t\tpr_debug(\"unknown flags %X\\n\", ahinfo->invflags);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic struct xt_match ah_mt6_reg __read_mostly = {\n\t.name\t\t= \"ah\",\n\t.family\t\t= NFPROTO_IPV6,\n\t.match\t\t= ah_mt6,\n\t.matchsize\t= sizeof(struct ip6t_ah),\n\t.checkentry\t= ah_mt6_check,\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init ah_mt6_init(void)\n{\n\treturn xt_register_match(&ah_mt6_reg);\n}\n\nstatic void __exit ah_mt6_exit(void)\n{\n\txt_unregister_match(&ah_mt6_reg);\n}\n\nmodule_init(ah_mt6_init);\nmodule_exit(ah_mt6_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}