{
  "module_name": "nf_defrag_ipv6_hooks.c",
  "hash_id": "dc0cf2d0686b886f820c4714eba38c9b8437b6e128bf9bc317cf1abcf69e323f",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/ipv6.h>\n#include <linux/in6.h>\n#include <linux/netfilter.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/icmp.h>\n#include <linux/rcupdate.h>\n#include <linux/sysctl.h>\n#include <net/ipv6_frag.h>\n\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_bridge.h>\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#include <net/netfilter/nf_conntrack.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <net/netfilter/nf_conntrack_l4proto.h>\n#include <net/netfilter/nf_conntrack_core.h>\n#include <net/netfilter/ipv6/nf_conntrack_ipv6.h>\n#endif\n#include <net/netfilter/nf_conntrack_zones.h>\n#include <net/netfilter/ipv6/nf_defrag_ipv6.h>\n\nstatic DEFINE_MUTEX(defrag6_mutex);\n\nstatic enum ip6_defrag_users nf_ct6_defrag_user(unsigned int hooknum,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tu16 zone_id = NF_CT_DEFAULT_ZONE_ID;\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (skb_nfct(skb)) {\n\t\tenum ip_conntrack_info ctinfo;\n\t\tconst struct nf_conn *ct = nf_ct_get(skb, &ctinfo);\n\n\t\tzone_id = nf_ct_zone_id(nf_ct_zone(ct), CTINFO2DIR(ctinfo));\n\t}\n#endif\n\tif (nf_bridge_in_prerouting(skb))\n\t\treturn IP6_DEFRAG_CONNTRACK_BRIDGE_IN + zone_id;\n\n\tif (hooknum == NF_INET_PRE_ROUTING)\n\t\treturn IP6_DEFRAG_CONNTRACK_IN + zone_id;\n\telse\n\t\treturn IP6_DEFRAG_CONNTRACK_OUT + zone_id;\n}\n\nstatic unsigned int ipv6_defrag(void *priv,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tconst struct nf_hook_state *state)\n{\n\tint err;\n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\t \n\tif (skb_nfct(skb) && !nf_ct_is_template((struct nf_conn *)skb_nfct(skb)))\n\t\treturn NF_ACCEPT;\n\n\tif (skb->_nfct == IP_CT_UNTRACKED)\n\t\treturn NF_ACCEPT;\n#endif\n\n\terr = nf_ct_frag6_gather(state->net, skb,\n\t\t\t\t nf_ct6_defrag_user(state->hook, skb));\n\t \n\tif (err == -EINPROGRESS)\n\t\treturn NF_STOLEN;\n\n\treturn err == 0 ? NF_ACCEPT : NF_DROP;\n}\n\nstatic const struct nf_hook_ops ipv6_defrag_ops[] = {\n\t{\n\t\t.hook\t\t= ipv6_defrag,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_PRE_ROUTING,\n\t\t.priority\t= NF_IP6_PRI_CONNTRACK_DEFRAG,\n\t},\n\t{\n\t\t.hook\t\t= ipv6_defrag,\n\t\t.pf\t\t= NFPROTO_IPV6,\n\t\t.hooknum\t= NF_INET_LOCAL_OUT,\n\t\t.priority\t= NF_IP6_PRI_CONNTRACK_DEFRAG,\n\t},\n};\n\nstatic void __net_exit defrag6_net_exit(struct net *net)\n{\n\tif (net->nf.defrag_ipv6_users) {\n\t\tnf_unregister_net_hooks(net, ipv6_defrag_ops,\n\t\t\t\t\tARRAY_SIZE(ipv6_defrag_ops));\n\t\tnet->nf.defrag_ipv6_users = 0;\n\t}\n}\n\nstatic const struct nf_defrag_hook defrag_hook = {\n\t.owner = THIS_MODULE,\n\t.enable = nf_defrag_ipv6_enable,\n\t.disable = nf_defrag_ipv6_disable,\n};\n\nstatic struct pernet_operations defrag6_net_ops = {\n\t.exit = defrag6_net_exit,\n};\n\nstatic int __init nf_defrag_init(void)\n{\n\tint ret = 0;\n\n\tret = nf_ct_frag6_init();\n\tif (ret < 0) {\n\t\tpr_err(\"nf_defrag_ipv6: can't initialize frag6.\\n\");\n\t\treturn ret;\n\t}\n\tret = register_pernet_subsys(&defrag6_net_ops);\n\tif (ret < 0) {\n\t\tpr_err(\"nf_defrag_ipv6: can't register pernet ops\\n\");\n\t\tgoto cleanup_frag6;\n\t}\n\n\trcu_assign_pointer(nf_defrag_v6_hook, &defrag_hook);\n\n\treturn ret;\n\ncleanup_frag6:\n\tnf_ct_frag6_cleanup();\n\treturn ret;\n\n}\n\nstatic void __exit nf_defrag_fini(void)\n{\n\trcu_assign_pointer(nf_defrag_v6_hook, NULL);\n\tunregister_pernet_subsys(&defrag6_net_ops);\n\tnf_ct_frag6_cleanup();\n}\n\nint nf_defrag_ipv6_enable(struct net *net)\n{\n\tint err = 0;\n\n\tmutex_lock(&defrag6_mutex);\n\tif (net->nf.defrag_ipv6_users == UINT_MAX) {\n\t\terr = -EOVERFLOW;\n\t\tgoto out_unlock;\n\t}\n\n\tif (net->nf.defrag_ipv6_users) {\n\t\tnet->nf.defrag_ipv6_users++;\n\t\tgoto out_unlock;\n\t}\n\n\terr = nf_register_net_hooks(net, ipv6_defrag_ops,\n\t\t\t\t    ARRAY_SIZE(ipv6_defrag_ops));\n\tif (err == 0)\n\t\tnet->nf.defrag_ipv6_users = 1;\n\n out_unlock:\n\tmutex_unlock(&defrag6_mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(nf_defrag_ipv6_enable);\n\nvoid nf_defrag_ipv6_disable(struct net *net)\n{\n\tmutex_lock(&defrag6_mutex);\n\tif (net->nf.defrag_ipv6_users) {\n\t\tnet->nf.defrag_ipv6_users--;\n\t\tif (net->nf.defrag_ipv6_users == 0)\n\t\t\tnf_unregister_net_hooks(net, ipv6_defrag_ops,\n\t\t\t\t\t\tARRAY_SIZE(ipv6_defrag_ops));\n\t}\n\tmutex_unlock(&defrag6_mutex);\n}\nEXPORT_SYMBOL_GPL(nf_defrag_ipv6_disable);\n\nmodule_init(nf_defrag_init);\nmodule_exit(nf_defrag_fini);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}