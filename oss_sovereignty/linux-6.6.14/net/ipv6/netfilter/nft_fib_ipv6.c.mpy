{
  "module_name": "nft_fib_ipv6.c",
  "hash_id": "aab8659299349ee40bd6b795a557bb68a61d985a6695cd6a655608d5efa616d9",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/nft_fib_ipv6.c",
  "human_readable_source": "\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <linux/netfilter_ipv6.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nft_fib.h>\n\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n\nstatic int get_ifindex(const struct net_device *dev)\n{\n\treturn dev ? dev->ifindex : 0;\n}\n\nstatic int nft_fib6_flowi_init(struct flowi6 *fl6, const struct nft_fib *priv,\n\t\t\t       const struct nft_pktinfo *pkt,\n\t\t\t       const struct net_device *dev,\n\t\t\t       struct ipv6hdr *iph)\n{\n\tint lookup_flags = 0;\n\n\tif (priv->flags & NFTA_FIB_F_DADDR) {\n\t\tfl6->daddr = iph->daddr;\n\t\tfl6->saddr = iph->saddr;\n\t} else {\n\t\tif (nft_hook(pkt) == NF_INET_FORWARD &&\n\t\t    priv->flags & NFTA_FIB_F_IIF)\n\t\t\tfl6->flowi6_iif = nft_out(pkt)->ifindex;\n\n\t\tfl6->daddr = iph->saddr;\n\t\tfl6->saddr = iph->daddr;\n\t}\n\n\tif (ipv6_addr_type(&fl6->daddr) & IPV6_ADDR_LINKLOCAL) {\n\t\tlookup_flags |= RT6_LOOKUP_F_IFACE;\n\t\tfl6->flowi6_oif = get_ifindex(dev ? dev : pkt->skb->dev);\n\t} else if (priv->flags & NFTA_FIB_F_IIF) {\n\t\tfl6->flowi6_l3mdev = l3mdev_master_ifindex_rcu(dev);\n\t}\n\n\tif (ipv6_addr_type(&fl6->saddr) & IPV6_ADDR_UNICAST)\n\t\tlookup_flags |= RT6_LOOKUP_F_HAS_SADDR;\n\n\tif (priv->flags & NFTA_FIB_F_MARK)\n\t\tfl6->flowi6_mark = pkt->skb->mark;\n\n\tfl6->flowlabel = (*(__be32 *)iph) & IPV6_FLOWINFO_MASK;\n\n\treturn lookup_flags;\n}\n\nstatic u32 __nft_fib6_eval_type(const struct nft_fib *priv,\n\t\t\t\tconst struct nft_pktinfo *pkt,\n\t\t\t\tstruct ipv6hdr *iph)\n{\n\tconst struct net_device *dev = NULL;\n\tint route_err, addrtype;\n\tstruct rt6_info *rt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif = LOOPBACK_IFINDEX,\n\t\t.flowi6_proto = pkt->tprot,\n\t\t.flowi6_uid = sock_net_uid(nft_net(pkt), NULL),\n\t};\n\tu32 ret = 0;\n\n\tif (priv->flags & NFTA_FIB_F_IIF)\n\t\tdev = nft_in(pkt);\n\telse if (priv->flags & NFTA_FIB_F_OIF)\n\t\tdev = nft_out(pkt);\n\n\tnft_fib6_flowi_init(&fl6, priv, pkt, dev, iph);\n\n\tif (dev && nf_ipv6_chk_addr(nft_net(pkt), &fl6.daddr, dev, true))\n\t\tret = RTN_LOCAL;\n\n\troute_err = nf_ip6_route(nft_net(pkt), (struct dst_entry **)&rt,\n\t\t\t\t flowi6_to_flowi(&fl6), false);\n\tif (route_err)\n\t\tgoto err;\n\n\tif (rt->rt6i_flags & RTF_REJECT) {\n\t\troute_err = rt->dst.error;\n\t\tdst_release(&rt->dst);\n\t\tgoto err;\n\t}\n\n\tif (ipv6_anycast_destination((struct dst_entry *)rt, &fl6.daddr))\n\t\tret = RTN_ANYCAST;\n\telse if (!dev && rt->rt6i_flags & RTF_LOCAL)\n\t\tret = RTN_LOCAL;\n\n\tdst_release(&rt->dst);\n\n\tif (ret)\n\t\treturn ret;\n\n\taddrtype = ipv6_addr_type(&fl6.daddr);\n\n\tif (addrtype & IPV6_ADDR_MULTICAST)\n\t\treturn RTN_MULTICAST;\n\tif (addrtype & IPV6_ADDR_UNICAST)\n\t\treturn RTN_UNICAST;\n\n\treturn RTN_UNSPEC;\n err:\n\tswitch (route_err) {\n\tcase -EINVAL:\n\t\treturn RTN_BLACKHOLE;\n\tcase -EACCES:\n\t\treturn RTN_PROHIBIT;\n\tcase -EAGAIN:\n\t\treturn RTN_THROW;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn RTN_UNREACHABLE;\n}\n\nvoid nft_fib6_eval_type(const struct nft_expr *expr, struct nft_regs *regs,\n\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tconst struct nft_fib *priv = nft_expr_priv(expr);\n\tint noff = skb_network_offset(pkt->skb);\n\tu32 *dest = &regs->data[priv->dreg];\n\tstruct ipv6hdr *iph, _iph;\n\n\tiph = skb_header_pointer(pkt->skb, noff, sizeof(_iph), &_iph);\n\tif (!iph) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\t*dest = __nft_fib6_eval_type(priv, pkt, iph);\n}\nEXPORT_SYMBOL_GPL(nft_fib6_eval_type);\n\nstatic bool nft_fib_v6_skip_icmpv6(const struct sk_buff *skb, u8 next, const struct ipv6hdr *iph)\n{\n\tif (likely(next != IPPROTO_ICMPV6))\n\t\treturn false;\n\n\tif (ipv6_addr_type(&iph->saddr) != IPV6_ADDR_ANY)\n\t\treturn false;\n\n\treturn ipv6_addr_type(&iph->daddr) & IPV6_ADDR_LINKLOCAL;\n}\n\nvoid nft_fib6_eval(const struct nft_expr *expr, struct nft_regs *regs,\n\t\t   const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_fib *priv = nft_expr_priv(expr);\n\tint noff = skb_network_offset(pkt->skb);\n\tconst struct net_device *oif = NULL;\n\tu32 *dest = &regs->data[priv->dreg];\n\tstruct ipv6hdr *iph, _iph;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif = LOOPBACK_IFINDEX,\n\t\t.flowi6_proto = pkt->tprot,\n\t\t.flowi6_uid = sock_net_uid(nft_net(pkt), NULL),\n\t};\n\tstruct rt6_info *rt;\n\tint lookup_flags;\n\n\tif (priv->flags & NFTA_FIB_F_IIF)\n\t\toif = nft_in(pkt);\n\telse if (priv->flags & NFTA_FIB_F_OIF)\n\t\toif = nft_out(pkt);\n\n\tiph = skb_header_pointer(pkt->skb, noff, sizeof(_iph), &_iph);\n\tif (!iph) {\n\t\tregs->verdict.code = NFT_BREAK;\n\t\treturn;\n\t}\n\n\tlookup_flags = nft_fib6_flowi_init(&fl6, priv, pkt, oif, iph);\n\n\tif (nft_hook(pkt) == NF_INET_PRE_ROUTING ||\n\t    nft_hook(pkt) == NF_INET_INGRESS) {\n\t\tif (nft_fib_is_loopback(pkt->skb, nft_in(pkt)) ||\n\t\t    nft_fib_v6_skip_icmpv6(pkt->skb, pkt->tprot, iph)) {\n\t\t\tnft_fib_store_result(dest, priv, nft_in(pkt));\n\t\t\treturn;\n\t\t}\n\t}\n\n\t*dest = 0;\n\trt = (void *)ip6_route_lookup(nft_net(pkt), &fl6, pkt->skb,\n\t\t\t\t      lookup_flags);\n\tif (rt->dst.error)\n\t\tgoto put_rt_err;\n\n\t \n\tif (rt->rt6i_flags & (RTF_REJECT | RTF_ANYCAST | RTF_LOCAL))\n\t\tgoto put_rt_err;\n\n\tif (oif && oif != rt->rt6i_idev->dev &&\n\t    l3mdev_master_ifindex_rcu(rt->rt6i_idev->dev) != oif->ifindex)\n\t\tgoto put_rt_err;\n\n\tnft_fib_store_result(dest, priv, rt->rt6i_idev->dev);\n put_rt_err:\n\tip6_rt_put(rt);\n}\nEXPORT_SYMBOL_GPL(nft_fib6_eval);\n\nstatic struct nft_expr_type nft_fib6_type;\n\nstatic const struct nft_expr_ops nft_fib6_type_ops = {\n\t.type\t\t= &nft_fib6_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_fib)),\n\t.eval\t\t= nft_fib6_eval_type,\n\t.init\t\t= nft_fib_init,\n\t.dump\t\t= nft_fib_dump,\n\t.validate\t= nft_fib_validate,\n\t.reduce\t\t= nft_fib_reduce,\n};\n\nstatic const struct nft_expr_ops nft_fib6_ops = {\n\t.type\t\t= &nft_fib6_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_fib)),\n\t.eval\t\t= nft_fib6_eval,\n\t.init\t\t= nft_fib_init,\n\t.dump\t\t= nft_fib_dump,\n\t.validate\t= nft_fib_validate,\n\t.reduce\t\t= nft_fib_reduce,\n};\n\nstatic const struct nft_expr_ops *\nnft_fib6_select_ops(const struct nft_ctx *ctx,\n\t\t    const struct nlattr * const tb[])\n{\n\tenum nft_fib_result result;\n\n\tif (!tb[NFTA_FIB_RESULT])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tresult = ntohl(nla_get_be32(tb[NFTA_FIB_RESULT]));\n\n\tswitch (result) {\n\tcase NFT_FIB_RESULT_OIF:\n\t\treturn &nft_fib6_ops;\n\tcase NFT_FIB_RESULT_OIFNAME:\n\t\treturn &nft_fib6_ops;\n\tcase NFT_FIB_RESULT_ADDRTYPE:\n\t\treturn &nft_fib6_type_ops;\n\tdefault:\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n}\n\nstatic struct nft_expr_type nft_fib6_type __read_mostly = {\n\t.name\t\t= \"fib\",\n\t.select_ops\t= nft_fib6_select_ops,\n\t.policy\t\t= nft_fib_policy,\n\t.maxattr\t= NFTA_FIB_MAX,\n\t.family\t\t= NFPROTO_IPV6,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __init nft_fib6_module_init(void)\n{\n\treturn nft_register_expr(&nft_fib6_type);\n}\n\nstatic void __exit nft_fib6_module_exit(void)\n{\n\tnft_unregister_expr(&nft_fib6_type);\n}\nmodule_init(nft_fib6_module_init);\nmodule_exit(nft_fib6_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Florian Westphal <fw@strlen.de>\");\nMODULE_ALIAS_NFT_AF_EXPR(10, \"fib\");\nMODULE_DESCRIPTION(\"nftables fib / ipv6 route lookup support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}