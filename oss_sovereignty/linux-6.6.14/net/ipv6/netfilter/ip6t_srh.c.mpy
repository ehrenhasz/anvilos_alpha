{
  "module_name": "ip6t_srh.c",
  "hash_id": "5aa4acf0dec8217c3882d7494a367076ddc765733b9081b98f024cd0fd86c176",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/ip6t_srh.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ipv6.h>\n#include <linux/types.h>\n#include <net/ipv6.h>\n#include <net/seg6.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv6/ip6t_srh.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n\n \n#define NF_SRH_INVF(ptr, flag, boolean)\t\\\n\t((boolean) ^ !!((ptr)->mt_invflags & (flag)))\n\nstatic bool srh_mt6(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct ip6t_srh *srhinfo = par->matchinfo;\n\tstruct ipv6_sr_hdr *srh;\n\tstruct ipv6_sr_hdr _srh;\n\tint hdrlen, srhoff = 0;\n\n\tif (ipv6_find_hdr(skb, &srhoff, IPPROTO_ROUTING, NULL, NULL) < 0)\n\t\treturn false;\n\tsrh = skb_header_pointer(skb, srhoff, sizeof(_srh), &_srh);\n\tif (!srh)\n\t\treturn false;\n\n\thdrlen = ipv6_optlen(srh);\n\tif (skb->len - srhoff < hdrlen)\n\t\treturn false;\n\n\tif (srh->type != IPV6_SRCRT_TYPE_4)\n\t\treturn false;\n\n\tif (srh->segments_left > srh->first_segment)\n\t\treturn false;\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_NEXTHDR)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_NEXTHDR,\n\t\t\t\t!(srh->nexthdr == srhinfo->next_hdr)))\n\t\t\treturn false;\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_LEN_EQ)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LEN_EQ,\n\t\t\t\t!(srh->hdrlen == srhinfo->hdr_len)))\n\t\t\treturn false;\n\n\tif (srhinfo->mt_flags & IP6T_SRH_LEN_GT)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LEN_GT,\n\t\t\t\t!(srh->hdrlen > srhinfo->hdr_len)))\n\t\t\treturn false;\n\n\tif (srhinfo->mt_flags & IP6T_SRH_LEN_LT)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LEN_LT,\n\t\t\t\t!(srh->hdrlen < srhinfo->hdr_len)))\n\t\t\treturn false;\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_SEGS_EQ)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_SEGS_EQ,\n\t\t\t\t!(srh->segments_left == srhinfo->segs_left)))\n\t\t\treturn false;\n\n\tif (srhinfo->mt_flags & IP6T_SRH_SEGS_GT)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_SEGS_GT,\n\t\t\t\t!(srh->segments_left > srhinfo->segs_left)))\n\t\t\treturn false;\n\n\tif (srhinfo->mt_flags & IP6T_SRH_SEGS_LT)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_SEGS_LT,\n\t\t\t\t!(srh->segments_left < srhinfo->segs_left)))\n\t\t\treturn false;\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_LAST_EQ)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LAST_EQ,\n\t\t\t\t!(srh->first_segment == srhinfo->last_entry)))\n\t\t\treturn false;\n\n\tif (srhinfo->mt_flags & IP6T_SRH_LAST_GT)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LAST_GT,\n\t\t\t\t!(srh->first_segment > srhinfo->last_entry)))\n\t\t\treturn false;\n\n\tif (srhinfo->mt_flags & IP6T_SRH_LAST_LT)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LAST_LT,\n\t\t\t\t!(srh->first_segment < srhinfo->last_entry)))\n\t\t\treturn false;\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_TAG)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_TAG,\n\t\t\t\t!(srh->tag == srhinfo->tag)))\n\t\t\treturn false;\n\treturn true;\n}\n\nstatic bool srh1_mt6(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tint hdrlen, psidoff, nsidoff, lsidoff, srhoff = 0;\n\tconst struct ip6t_srh1 *srhinfo = par->matchinfo;\n\tstruct in6_addr *psid, *nsid, *lsid;\n\tstruct in6_addr _psid, _nsid, _lsid;\n\tstruct ipv6_sr_hdr *srh;\n\tstruct ipv6_sr_hdr _srh;\n\n\tif (ipv6_find_hdr(skb, &srhoff, IPPROTO_ROUTING, NULL, NULL) < 0)\n\t\treturn false;\n\tsrh = skb_header_pointer(skb, srhoff, sizeof(_srh), &_srh);\n\tif (!srh)\n\t\treturn false;\n\n\thdrlen = ipv6_optlen(srh);\n\tif (skb->len - srhoff < hdrlen)\n\t\treturn false;\n\n\tif (srh->type != IPV6_SRCRT_TYPE_4)\n\t\treturn false;\n\n\tif (srh->segments_left > srh->first_segment)\n\t\treturn false;\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_NEXTHDR)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_NEXTHDR,\n\t\t\t\t!(srh->nexthdr == srhinfo->next_hdr)))\n\t\t\treturn false;\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_LEN_EQ)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LEN_EQ,\n\t\t\t\t!(srh->hdrlen == srhinfo->hdr_len)))\n\t\t\treturn false;\n\tif (srhinfo->mt_flags & IP6T_SRH_LEN_GT)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LEN_GT,\n\t\t\t\t!(srh->hdrlen > srhinfo->hdr_len)))\n\t\t\treturn false;\n\tif (srhinfo->mt_flags & IP6T_SRH_LEN_LT)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LEN_LT,\n\t\t\t\t!(srh->hdrlen < srhinfo->hdr_len)))\n\t\t\treturn false;\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_SEGS_EQ)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_SEGS_EQ,\n\t\t\t\t!(srh->segments_left == srhinfo->segs_left)))\n\t\t\treturn false;\n\tif (srhinfo->mt_flags & IP6T_SRH_SEGS_GT)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_SEGS_GT,\n\t\t\t\t!(srh->segments_left > srhinfo->segs_left)))\n\t\t\treturn false;\n\tif (srhinfo->mt_flags & IP6T_SRH_SEGS_LT)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_SEGS_LT,\n\t\t\t\t!(srh->segments_left < srhinfo->segs_left)))\n\t\t\treturn false;\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_LAST_EQ)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LAST_EQ,\n\t\t\t\t!(srh->first_segment == srhinfo->last_entry)))\n\t\t\treturn false;\n\tif (srhinfo->mt_flags & IP6T_SRH_LAST_GT)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LAST_GT,\n\t\t\t\t!(srh->first_segment > srhinfo->last_entry)))\n\t\t\treturn false;\n\tif (srhinfo->mt_flags & IP6T_SRH_LAST_LT)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LAST_LT,\n\t\t\t\t!(srh->first_segment < srhinfo->last_entry)))\n\t\t\treturn false;\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_TAG)\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_TAG,\n\t\t\t\t!(srh->tag == srhinfo->tag)))\n\t\t\treturn false;\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_PSID) {\n\t\tif (srh->segments_left == srh->first_segment)\n\t\t\treturn false;\n\t\tpsidoff = srhoff + sizeof(struct ipv6_sr_hdr) +\n\t\t\t  ((srh->segments_left + 1) * sizeof(struct in6_addr));\n\t\tpsid = skb_header_pointer(skb, psidoff, sizeof(_psid), &_psid);\n\t\tif (!psid)\n\t\t\treturn false;\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_PSID,\n\t\t\t\tipv6_masked_addr_cmp(psid, &srhinfo->psid_msk,\n\t\t\t\t\t\t     &srhinfo->psid_addr)))\n\t\t\treturn false;\n\t}\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_NSID) {\n\t\tif (srh->segments_left == 0)\n\t\t\treturn false;\n\t\tnsidoff = srhoff + sizeof(struct ipv6_sr_hdr) +\n\t\t\t  ((srh->segments_left - 1) * sizeof(struct in6_addr));\n\t\tnsid = skb_header_pointer(skb, nsidoff, sizeof(_nsid), &_nsid);\n\t\tif (!nsid)\n\t\t\treturn false;\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_NSID,\n\t\t\t\tipv6_masked_addr_cmp(nsid, &srhinfo->nsid_msk,\n\t\t\t\t\t\t     &srhinfo->nsid_addr)))\n\t\t\treturn false;\n\t}\n\n\t \n\tif (srhinfo->mt_flags & IP6T_SRH_LSID) {\n\t\tlsidoff = srhoff + sizeof(struct ipv6_sr_hdr);\n\t\tlsid = skb_header_pointer(skb, lsidoff, sizeof(_lsid), &_lsid);\n\t\tif (!lsid)\n\t\t\treturn false;\n\t\tif (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LSID,\n\t\t\t\tipv6_masked_addr_cmp(lsid, &srhinfo->lsid_msk,\n\t\t\t\t\t\t     &srhinfo->lsid_addr)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int srh_mt6_check(const struct xt_mtchk_param *par)\n{\n\tconst struct ip6t_srh *srhinfo = par->matchinfo;\n\n\tif (srhinfo->mt_flags & ~IP6T_SRH_MASK) {\n\t\tpr_info_ratelimited(\"unknown srh match flags  %X\\n\",\n\t\t\t\t    srhinfo->mt_flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (srhinfo->mt_invflags & ~IP6T_SRH_INV_MASK) {\n\t\tpr_info_ratelimited(\"unknown srh invflags %X\\n\",\n\t\t\t\t    srhinfo->mt_invflags);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int srh1_mt6_check(const struct xt_mtchk_param *par)\n{\n\tconst struct ip6t_srh1 *srhinfo = par->matchinfo;\n\n\tif (srhinfo->mt_flags & ~IP6T_SRH_MASK) {\n\t\tpr_info_ratelimited(\"unknown srh match flags  %X\\n\",\n\t\t\t\t    srhinfo->mt_flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (srhinfo->mt_invflags & ~IP6T_SRH_INV_MASK) {\n\t\tpr_info_ratelimited(\"unknown srh invflags %X\\n\",\n\t\t\t\t    srhinfo->mt_invflags);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct xt_match srh_mt6_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"srh\",\n\t\t.revision\t= 0,\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.match\t\t= srh_mt6,\n\t\t.matchsize\t= sizeof(struct ip6t_srh),\n\t\t.checkentry\t= srh_mt6_check,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name           = \"srh\",\n\t\t.revision       = 1,\n\t\t.family         = NFPROTO_IPV6,\n\t\t.match          = srh1_mt6,\n\t\t.matchsize      = sizeof(struct ip6t_srh1),\n\t\t.checkentry     = srh1_mt6_check,\n\t\t.me             = THIS_MODULE,\n\t}\n};\n\nstatic int __init srh_mt6_init(void)\n{\n\treturn xt_register_matches(srh_mt6_reg, ARRAY_SIZE(srh_mt6_reg));\n}\n\nstatic void __exit srh_mt6_exit(void)\n{\n\txt_unregister_matches(srh_mt6_reg, ARRAY_SIZE(srh_mt6_reg));\n}\n\nmodule_init(srh_mt6_init);\nmodule_exit(srh_mt6_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Xtables: IPv6 Segment Routing Header match\");\nMODULE_AUTHOR(\"Ahmed Abdelsalam <amsalam20@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}