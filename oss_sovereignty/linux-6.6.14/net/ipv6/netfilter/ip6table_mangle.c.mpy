{
  "module_name": "ip6table_mangle.c",
  "hash_id": "6d04381b55d0a91acdae1891aa082e0c7e9f3212ac70cfdbefd78c3cb6360497",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/ip6table_mangle.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <linux/slab.h>\n#include <net/ipv6.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Netfilter Core Team <coreteam@netfilter.org>\");\nMODULE_DESCRIPTION(\"ip6tables mangle table\");\n\n#define MANGLE_VALID_HOOKS ((1 << NF_INET_PRE_ROUTING) | \\\n\t\t\t    (1 << NF_INET_LOCAL_IN) | \\\n\t\t\t    (1 << NF_INET_FORWARD) | \\\n\t\t\t    (1 << NF_INET_LOCAL_OUT) | \\\n\t\t\t    (1 << NF_INET_POST_ROUTING))\n\nstatic const struct xt_table packet_mangler = {\n\t.name\t\t= \"mangle\",\n\t.valid_hooks\t= MANGLE_VALID_HOOKS,\n\t.me\t\t= THIS_MODULE,\n\t.af\t\t= NFPROTO_IPV6,\n\t.priority\t= NF_IP6_PRI_MANGLE,\n};\n\nstatic unsigned int\nip6t_mangle_out(void *priv, struct sk_buff *skb, const struct nf_hook_state *state)\n{\n\tunsigned int ret;\n\tstruct in6_addr saddr, daddr;\n\tu_int8_t hop_limit;\n\tu_int32_t flowlabel, mark;\n\tint err;\n\n\t \n\tmemcpy(&saddr, &ipv6_hdr(skb)->saddr, sizeof(saddr));\n\tmemcpy(&daddr, &ipv6_hdr(skb)->daddr, sizeof(daddr));\n\tmark = skb->mark;\n\thop_limit = ipv6_hdr(skb)->hop_limit;\n\n\t \n\tflowlabel = *((u_int32_t *)ipv6_hdr(skb));\n\n\tret = ip6t_do_table(priv, skb, state);\n\n\tif (ret != NF_DROP && ret != NF_STOLEN &&\n\t    (!ipv6_addr_equal(&ipv6_hdr(skb)->saddr, &saddr) ||\n\t     !ipv6_addr_equal(&ipv6_hdr(skb)->daddr, &daddr) ||\n\t     skb->mark != mark ||\n\t     ipv6_hdr(skb)->hop_limit != hop_limit ||\n\t     flowlabel != *((u_int32_t *)ipv6_hdr(skb)))) {\n\t\terr = ip6_route_me_harder(state->net, state->sk, skb);\n\t\tif (err < 0)\n\t\t\tret = NF_DROP_ERR(err);\n\t}\n\n\treturn ret;\n}\n\n \nstatic unsigned int\nip6table_mangle_hook(void *priv, struct sk_buff *skb,\n\t\t     const struct nf_hook_state *state)\n{\n\tif (state->hook == NF_INET_LOCAL_OUT)\n\t\treturn ip6t_mangle_out(priv, skb, state);\n\treturn ip6t_do_table(priv, skb, state);\n}\n\nstatic struct nf_hook_ops *mangle_ops __read_mostly;\nstatic int ip6table_mangle_table_init(struct net *net)\n{\n\tstruct ip6t_replace *repl;\n\tint ret;\n\n\trepl = ip6t_alloc_initial_table(&packet_mangler);\n\tif (repl == NULL)\n\t\treturn -ENOMEM;\n\tret = ip6t_register_table(net, &packet_mangler, repl, mangle_ops);\n\tkfree(repl);\n\treturn ret;\n}\n\nstatic void __net_exit ip6table_mangle_net_pre_exit(struct net *net)\n{\n\tip6t_unregister_table_pre_exit(net, \"mangle\");\n}\n\nstatic void __net_exit ip6table_mangle_net_exit(struct net *net)\n{\n\tip6t_unregister_table_exit(net, \"mangle\");\n}\n\nstatic struct pernet_operations ip6table_mangle_net_ops = {\n\t.pre_exit = ip6table_mangle_net_pre_exit,\n\t.exit = ip6table_mangle_net_exit,\n};\n\nstatic int __init ip6table_mangle_init(void)\n{\n\tint ret = xt_register_template(&packet_mangler,\n\t\t\t\t       ip6table_mangle_table_init);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmangle_ops = xt_hook_ops_alloc(&packet_mangler, ip6table_mangle_hook);\n\tif (IS_ERR(mangle_ops)) {\n\t\txt_unregister_template(&packet_mangler);\n\t\treturn PTR_ERR(mangle_ops);\n\t}\n\n\tret = register_pernet_subsys(&ip6table_mangle_net_ops);\n\tif (ret < 0) {\n\t\txt_unregister_template(&packet_mangler);\n\t\tkfree(mangle_ops);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit ip6table_mangle_fini(void)\n{\n\tunregister_pernet_subsys(&ip6table_mangle_net_ops);\n\txt_unregister_template(&packet_mangler);\n\tkfree(mangle_ops);\n}\n\nmodule_init(ip6table_mangle_init);\nmodule_exit(ip6table_mangle_fini);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}