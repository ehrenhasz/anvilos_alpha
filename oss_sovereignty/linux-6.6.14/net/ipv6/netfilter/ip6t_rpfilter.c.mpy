{
  "module_name": "ip6t_rpfilter.c",
  "hash_id": "6f57ef03a14329a0152ce49cb997325cde6214ff03e2796ba0de462de08cf270",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/ip6t_rpfilter.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/route.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n\n#include <linux/netfilter/xt_rpfilter.h>\n#include <linux/netfilter/x_tables.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Florian Westphal <fw@strlen.de>\");\nMODULE_DESCRIPTION(\"Xtables: IPv6 reverse path filter match\");\n\nstatic bool rpfilter_addr_unicast(const struct in6_addr *addr)\n{\n\tint addr_type = ipv6_addr_type(addr);\n\treturn addr_type & IPV6_ADDR_UNICAST;\n}\n\nstatic bool rpfilter_addr_linklocal(const struct in6_addr *addr)\n{\n\tint addr_type = ipv6_addr_type(addr);\n\treturn addr_type & IPV6_ADDR_LINKLOCAL;\n}\n\nstatic bool rpfilter_lookup_reverse6(struct net *net, const struct sk_buff *skb,\n\t\t\t\t     const struct net_device *dev, u8 flags)\n{\n\tstruct rt6_info *rt;\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\tbool ret = false;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif = LOOPBACK_IFINDEX,\n\t\t.flowi6_l3mdev = l3mdev_master_ifindex_rcu(dev),\n\t\t.flowlabel = (* (__be32 *) iph) & IPV6_FLOWINFO_MASK,\n\t\t.flowi6_proto = iph->nexthdr,\n\t\t.flowi6_uid = sock_net_uid(net, NULL),\n\t\t.daddr = iph->saddr,\n\t};\n\tint lookup_flags;\n\n\tif (rpfilter_addr_unicast(&iph->daddr)) {\n\t\tmemcpy(&fl6.saddr, &iph->daddr, sizeof(struct in6_addr));\n\t\tlookup_flags = RT6_LOOKUP_F_HAS_SADDR;\n\t} else {\n\t\tlookup_flags = 0;\n\t}\n\n\tfl6.flowi6_mark = flags & XT_RPFILTER_VALID_MARK ? skb->mark : 0;\n\n\tif (rpfilter_addr_linklocal(&iph->saddr)) {\n\t\tlookup_flags |= RT6_LOOKUP_F_IFACE;\n\t\tfl6.flowi6_oif = dev->ifindex;\n\t} else if ((flags & XT_RPFILTER_LOOSE) == 0)\n\t\tfl6.flowi6_oif = dev->ifindex;\n\n\trt = (void *)ip6_route_lookup(net, &fl6, skb, lookup_flags);\n\tif (rt->dst.error)\n\t\tgoto out;\n\n\tif (rt->rt6i_flags & (RTF_REJECT|RTF_ANYCAST))\n\t\tgoto out;\n\n\tif (rt->rt6i_flags & RTF_LOCAL) {\n\t\tret = flags & XT_RPFILTER_ACCEPT_LOCAL;\n\t\tgoto out;\n\t}\n\n\tif (rt->rt6i_idev->dev == dev ||\n\t    l3mdev_master_ifindex_rcu(rt->rt6i_idev->dev) == dev->ifindex ||\n\t    (flags & XT_RPFILTER_LOOSE))\n\t\tret = true;\n out:\n\tip6_rt_put(rt);\n\treturn ret;\n}\n\nstatic bool\nrpfilter_is_loopback(const struct sk_buff *skb, const struct net_device *in)\n{\n\treturn skb->pkt_type == PACKET_LOOPBACK || in->flags & IFF_LOOPBACK;\n}\n\nstatic bool rpfilter_mt(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct xt_rpfilter_info *info = par->matchinfo;\n\tint saddrtype;\n\tstruct ipv6hdr *iph;\n\tbool invert = info->flags & XT_RPFILTER_INVERT;\n\n\tif (rpfilter_is_loopback(skb, xt_in(par)))\n\t\treturn true ^ invert;\n\n\tiph = ipv6_hdr(skb);\n\tsaddrtype = ipv6_addr_type(&iph->saddr);\n\tif (unlikely(saddrtype == IPV6_ADDR_ANY))\n\t\treturn true ^ invert;  \n\n\treturn rpfilter_lookup_reverse6(xt_net(par), skb, xt_in(par),\n\t\t\t\t\tinfo->flags) ^ invert;\n}\n\nstatic int rpfilter_check(const struct xt_mtchk_param *par)\n{\n\tconst struct xt_rpfilter_info *info = par->matchinfo;\n\tunsigned int options = ~XT_RPFILTER_OPTION_MASK;\n\n\tif (info->flags & options) {\n\t\tpr_info_ratelimited(\"unknown options\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (strcmp(par->table, \"mangle\") != 0 &&\n\t    strcmp(par->table, \"raw\") != 0) {\n\t\tpr_info_ratelimited(\"only valid in \\'raw\\' or \\'mangle\\' table, not \\'%s\\'\\n\",\n\t\t\t\t    par->table);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct xt_match rpfilter_mt_reg __read_mostly = {\n\t.name\t\t= \"rpfilter\",\n\t.family\t\t= NFPROTO_IPV6,\n\t.checkentry\t= rpfilter_check,\n\t.match\t\t= rpfilter_mt,\n\t.matchsize\t= sizeof(struct xt_rpfilter_info),\n\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING),\n\t.me\t\t= THIS_MODULE\n};\n\nstatic int __init rpfilter_mt_init(void)\n{\n\treturn xt_register_match(&rpfilter_mt_reg);\n}\n\nstatic void __exit rpfilter_mt_exit(void)\n{\n\txt_unregister_match(&rpfilter_mt_reg);\n}\n\nmodule_init(rpfilter_mt_init);\nmodule_exit(rpfilter_mt_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}