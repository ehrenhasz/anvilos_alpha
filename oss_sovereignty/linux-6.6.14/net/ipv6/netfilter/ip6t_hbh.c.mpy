{
  "module_name": "ip6t_hbh.c",
  "hash_id": "3dd4c2313bcd2b5808b56fdd431fecf59b58099a149db0146f2ac87cab940548",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/ip6t_hbh.c",
  "human_readable_source": "\n \n\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ipv6.h>\n#include <linux/types.h>\n#include <net/checksum.h>\n#include <net/ipv6.h>\n\n#include <asm/byteorder.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#include <linux/netfilter_ipv6/ip6t_opts.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Xtables: IPv6 Hop-By-Hop and Destination Header match\");\nMODULE_AUTHOR(\"Andras Kis-Szabo <kisza@sch.bme.hu>\");\nMODULE_ALIAS(\"ip6t_dst\");\n\n \n\nstatic struct xt_match hbh_mt6_reg[] __read_mostly;\n\nstatic bool\nhbh_mt6(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tstruct ipv6_opt_hdr _optsh;\n\tconst struct ipv6_opt_hdr *oh;\n\tconst struct ip6t_opts *optinfo = par->matchinfo;\n\tunsigned int temp;\n\tunsigned int ptr = 0;\n\tunsigned int hdrlen = 0;\n\tbool ret = false;\n\tu8 _opttype;\n\tu8 _optlen;\n\tconst u_int8_t *tp = NULL;\n\tconst u_int8_t *lp = NULL;\n\tunsigned int optlen;\n\tint err;\n\n\terr = ipv6_find_hdr(skb, &ptr,\n\t\t\t    (par->match == &hbh_mt6_reg[0]) ?\n\t\t\t    NEXTHDR_HOP : NEXTHDR_DEST, NULL, NULL);\n\tif (err < 0) {\n\t\tif (err != -ENOENT)\n\t\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\n\toh = skb_header_pointer(skb, ptr, sizeof(_optsh), &_optsh);\n\tif (oh == NULL) {\n\t\tpar->hotdrop = true;\n\t\treturn false;\n\t}\n\n\thdrlen = ipv6_optlen(oh);\n\tif (skb->len - ptr < hdrlen) {\n\t\t \n\t\treturn false;\n\t}\n\n\tpr_debug(\"IPv6 OPTS LEN %u %u \", hdrlen, oh->hdrlen);\n\n\tpr_debug(\"len %02X %04X %02X \",\n\t\t optinfo->hdrlen, hdrlen,\n\t\t (!(optinfo->flags & IP6T_OPTS_LEN) ||\n\t\t  ((optinfo->hdrlen == hdrlen) ^\n\t\t   !!(optinfo->invflags & IP6T_OPTS_INV_LEN))));\n\n\tret = (!(optinfo->flags & IP6T_OPTS_LEN) ||\n\t       ((optinfo->hdrlen == hdrlen) ^\n\t\t!!(optinfo->invflags & IP6T_OPTS_INV_LEN)));\n\n\tptr += 2;\n\thdrlen -= 2;\n\tif (!(optinfo->flags & IP6T_OPTS_OPTS)) {\n\t\treturn ret;\n\t} else {\n\t\tpr_debug(\"Strict \");\n\t\tpr_debug(\"#%d \", optinfo->optsnr);\n\t\tfor (temp = 0; temp < optinfo->optsnr; temp++) {\n\t\t\t \n\t\t\tif (hdrlen < 1)\n\t\t\t\tbreak;\n\t\t\ttp = skb_header_pointer(skb, ptr, sizeof(_opttype),\n\t\t\t\t\t\t&_opttype);\n\t\t\tif (tp == NULL)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (*tp != (optinfo->opts[temp] & 0xFF00) >> 8) {\n\t\t\t\tpr_debug(\"Tbad %02X %02X\\n\", *tp,\n\t\t\t\t\t (optinfo->opts[temp] & 0xFF00) >> 8);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tpr_debug(\"Tok \");\n\t\t\t}\n\t\t\t \n\t\t\tif (*tp) {\n\t\t\t\tu16 spec_len;\n\n\t\t\t\t \n\t\t\t\tif (hdrlen < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tlp = skb_header_pointer(skb, ptr + 1,\n\t\t\t\t\t\t\tsizeof(_optlen),\n\t\t\t\t\t\t\t&_optlen);\n\t\t\t\tif (lp == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tspec_len = optinfo->opts[temp] & 0x00FF;\n\n\t\t\t\tif (spec_len != 0x00FF && spec_len != *lp) {\n\t\t\t\t\tpr_debug(\"Lbad %02X %04X\\n\", *lp,\n\t\t\t\t\t\t spec_len);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tpr_debug(\"Lok \");\n\t\t\t\toptlen = *lp + 2;\n\t\t\t} else {\n\t\t\t\tpr_debug(\"Pad1\\n\");\n\t\t\t\toptlen = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tpr_debug(\"len%04X\\n\", optlen);\n\n\t\t\tif ((ptr > skb->len - optlen || hdrlen < optlen) &&\n\t\t\t    temp < optinfo->optsnr - 1) {\n\t\t\t\tpr_debug(\"new pointer is too large!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr += optlen;\n\t\t\thdrlen -= optlen;\n\t\t}\n\t\tif (temp == optinfo->optsnr)\n\t\t\treturn ret;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic int hbh_mt6_check(const struct xt_mtchk_param *par)\n{\n\tconst struct ip6t_opts *optsinfo = par->matchinfo;\n\n\tif (optsinfo->invflags & ~IP6T_OPTS_INV_MASK) {\n\t\tpr_debug(\"unknown flags %X\\n\", optsinfo->invflags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (optsinfo->flags & IP6T_OPTS_NSTRICT) {\n\t\tpr_debug(\"Not strict - not implemented\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct xt_match hbh_mt6_reg[] __read_mostly = {\n\t{\n\t\t \n\t\t.name\t\t= \"hbh\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.match\t\t= hbh_mt6,\n\t\t.matchsize\t= sizeof(struct ip6t_opts),\n\t\t.checkentry\t= hbh_mt6_check,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"dst\",\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.match\t\t= hbh_mt6,\n\t\t.matchsize\t= sizeof(struct ip6t_opts),\n\t\t.checkentry\t= hbh_mt6_check,\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init hbh_mt6_init(void)\n{\n\treturn xt_register_matches(hbh_mt6_reg, ARRAY_SIZE(hbh_mt6_reg));\n}\n\nstatic void __exit hbh_mt6_exit(void)\n{\n\txt_unregister_matches(hbh_mt6_reg, ARRAY_SIZE(hbh_mt6_reg));\n}\n\nmodule_init(hbh_mt6_init);\nmodule_exit(hbh_mt6_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}