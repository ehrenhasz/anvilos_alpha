{
  "module_name": "nf_conntrack_reasm.c",
  "hash_id": "9548f5a49e989183259d971a686310d71ad1ddb9bf7ceeb964267d28f7a9602d",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/nf_conntrack_reasm.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"IPv6-nf: \" fmt\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/ipv6.h>\n#include <linux/slab.h>\n\n#include <net/ipv6_frag.h>\n\n#include <net/netfilter/ipv6/nf_conntrack_ipv6.h>\n#include <linux/sysctl.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <net/netfilter/ipv6/nf_defrag_ipv6.h>\n#include <net/netns/generic.h>\n\nstatic const char nf_frags_cache_name[] = \"nf-frags\";\n\nstatic unsigned int nf_frag_pernet_id __read_mostly;\nstatic struct inet_frags nf_frags;\n\nstatic struct nft_ct_frag6_pernet *nf_frag_pernet(struct net *net)\n{\n\treturn net_generic(net, nf_frag_pernet_id);\n}\n\n#ifdef CONFIG_SYSCTL\n\nstatic struct ctl_table nf_ct_frag6_sysctl_table[] = {\n\t{\n\t\t.procname\t= \"nf_conntrack_frag6_timeout\",\n\t\t.maxlen\t\t= sizeof(unsigned int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_frag6_low_thresh\",\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"nf_conntrack_frag6_high_thresh\",\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{ }\n};\n\nstatic int nf_ct_frag6_sysctl_register(struct net *net)\n{\n\tstruct nft_ct_frag6_pernet *nf_frag;\n\tstruct ctl_table *table;\n\tstruct ctl_table_header *hdr;\n\n\ttable = nf_ct_frag6_sysctl_table;\n\tif (!net_eq(net, &init_net)) {\n\t\ttable = kmemdup(table, sizeof(nf_ct_frag6_sysctl_table),\n\t\t\t\tGFP_KERNEL);\n\t\tif (table == NULL)\n\t\t\tgoto err_alloc;\n\t}\n\n\tnf_frag = nf_frag_pernet(net);\n\n\ttable[0].data\t= &nf_frag->fqdir->timeout;\n\ttable[1].data\t= &nf_frag->fqdir->low_thresh;\n\ttable[1].extra2\t= &nf_frag->fqdir->high_thresh;\n\ttable[2].data\t= &nf_frag->fqdir->high_thresh;\n\ttable[2].extra1\t= &nf_frag->fqdir->low_thresh;\n\n\thdr = register_net_sysctl_sz(net, \"net/netfilter\", table,\n\t\t\t\t     ARRAY_SIZE(nf_ct_frag6_sysctl_table));\n\tif (hdr == NULL)\n\t\tgoto err_reg;\n\n\tnf_frag->nf_frag_frags_hdr = hdr;\n\treturn 0;\n\nerr_reg:\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\nerr_alloc:\n\treturn -ENOMEM;\n}\n\nstatic void __net_exit nf_ct_frags6_sysctl_unregister(struct net *net)\n{\n\tstruct nft_ct_frag6_pernet *nf_frag = nf_frag_pernet(net);\n\tstruct ctl_table *table;\n\n\ttable = nf_frag->nf_frag_frags_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(nf_frag->nf_frag_frags_hdr);\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\n}\n\n#else\nstatic int nf_ct_frag6_sysctl_register(struct net *net)\n{\n\treturn 0;\n}\nstatic void __net_exit nf_ct_frags6_sysctl_unregister(struct net *net)\n{\n}\n#endif\n\nstatic int nf_ct_frag6_reasm(struct frag_queue *fq, struct sk_buff *skb,\n\t\t\t     struct sk_buff *prev_tail, struct net_device *dev);\n\nstatic inline u8 ip6_frag_ecn(const struct ipv6hdr *ipv6h)\n{\n\treturn 1 << (ipv6_get_dsfield(ipv6h) & INET_ECN_MASK);\n}\n\nstatic void nf_ct_frag6_expire(struct timer_list *t)\n{\n\tstruct inet_frag_queue *frag = from_timer(frag, t, timer);\n\tstruct frag_queue *fq;\n\n\tfq = container_of(frag, struct frag_queue, q);\n\n\tip6frag_expire_frag_queue(fq->q.fqdir->net, fq);\n}\n\n \nstatic struct frag_queue *fq_find(struct net *net, __be32 id, u32 user,\n\t\t\t\t  const struct ipv6hdr *hdr, int iif)\n{\n\tstruct nft_ct_frag6_pernet *nf_frag = nf_frag_pernet(net);\n\tstruct frag_v6_compare_key key = {\n\t\t.id = id,\n\t\t.saddr = hdr->saddr,\n\t\t.daddr = hdr->daddr,\n\t\t.user = user,\n\t\t.iif = iif,\n\t};\n\tstruct inet_frag_queue *q;\n\n\tq = inet_frag_find(nf_frag->fqdir, &key);\n\tif (!q)\n\t\treturn NULL;\n\n\treturn container_of(q, struct frag_queue, q);\n}\n\n\nstatic int nf_ct_frag6_queue(struct frag_queue *fq, struct sk_buff *skb,\n\t\t\t     const struct frag_hdr *fhdr, int nhoff)\n{\n\tunsigned int payload_len;\n\tstruct net_device *dev;\n\tstruct sk_buff *prev;\n\tint offset, end, err;\n\tu8 ecn;\n\n\tif (fq->q.flags & INET_FRAG_COMPLETE) {\n\t\tpr_debug(\"Already completed\\n\");\n\t\tgoto err;\n\t}\n\n\tpayload_len = ntohs(ipv6_hdr(skb)->payload_len);\n\n\toffset = ntohs(fhdr->frag_off) & ~0x7;\n\tend = offset + (payload_len -\n\t\t\t((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\n\n\tif ((unsigned int)end > IPV6_MAXPLEN) {\n\t\tpr_debug(\"offset is too large.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tecn = ip6_frag_ecn(ipv6_hdr(skb));\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tskb->csum = csum_sub(skb->csum,\n\t\t\t\t     csum_partial(nh, (u8 *)(fhdr + 1) - nh,\n\t\t\t\t\t\t  0));\n\t}\n\n\t \n\tif (!(fhdr->frag_off & htons(IP6_MF))) {\n\t\t \n\t\tif (end < fq->q.len ||\n\t\t    ((fq->q.flags & INET_FRAG_LAST_IN) && end != fq->q.len)) {\n\t\t\tpr_debug(\"already received last fragment\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tfq->q.flags |= INET_FRAG_LAST_IN;\n\t\tfq->q.len = end;\n\t} else {\n\t\t \n\t\tif (end & 0x7) {\n\t\t\t \n\t\t\tpr_debug(\"end of fragment not rounded to 8 bytes.\\n\");\n\t\t\tinet_frag_kill(&fq->q);\n\t\t\treturn -EPROTO;\n\t\t}\n\t\tif (end > fq->q.len) {\n\t\t\t \n\t\t\tif (fq->q.flags & INET_FRAG_LAST_IN) {\n\t\t\t\tpr_debug(\"last packet already reached.\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tfq->q.len = end;\n\t\t}\n\t}\n\n\tif (end == offset)\n\t\tgoto err;\n\n\t \n\tif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data)) {\n\t\tpr_debug(\"queue: message is too short.\\n\");\n\t\tgoto err;\n\t}\n\tif (pskb_trim_rcsum(skb, end - offset)) {\n\t\tpr_debug(\"Can't trim\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tdev = skb->dev;\n\t \n\tbarrier();\n\n\tprev = fq->q.fragments_tail;\n\terr = inet_frag_queue_insert(&fq->q, skb, offset, end);\n\tif (err) {\n\t\tif (err == IPFRAG_DUP) {\n\t\t\t \n\t\t\tkfree_skb_reason(skb, SKB_DROP_REASON_DUP_FRAG);\n\t\t\treturn -EINPROGRESS;\n\t\t}\n\t\tgoto insert_error;\n\t}\n\n\tif (dev)\n\t\tfq->iif = dev->ifindex;\n\n\tfq->q.stamp = skb->tstamp;\n\tfq->q.mono_delivery_time = skb->mono_delivery_time;\n\tfq->q.meat += skb->len;\n\tfq->ecn |= ecn;\n\tif (payload_len > fq->q.max_size)\n\t\tfq->q.max_size = payload_len;\n\tadd_frag_mem_limit(fq->q.fqdir, skb->truesize);\n\n\t \n\tif (offset == 0) {\n\t\tfq->nhoffset = nhoff;\n\t\tfq->q.flags |= INET_FRAG_FIRST_IN;\n\t}\n\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len) {\n\t\tunsigned long orefdst = skb->_skb_refdst;\n\n\t\tskb->_skb_refdst = 0UL;\n\t\terr = nf_ct_frag6_reasm(fq, skb, prev, dev);\n\t\tskb->_skb_refdst = orefdst;\n\n\t\t \n\t\treturn err ? -EINPROGRESS : 0;\n\t}\n\n\tskb_dst_drop(skb);\n\treturn -EINPROGRESS;\n\ninsert_error:\n\tinet_frag_kill(&fq->q);\nerr:\n\tskb_dst_drop(skb);\n\treturn -EINVAL;\n}\n\n \nstatic int nf_ct_frag6_reasm(struct frag_queue *fq, struct sk_buff *skb,\n\t\t\t     struct sk_buff *prev_tail, struct net_device *dev)\n{\n\tvoid *reasm_data;\n\tint payload_len;\n\tu8 ecn;\n\n\tinet_frag_kill(&fq->q);\n\n\tecn = ip_frag_ecn_table[fq->ecn];\n\tif (unlikely(ecn == 0xff))\n\t\tgoto err;\n\n\treasm_data = inet_frag_reasm_prepare(&fq->q, skb, prev_tail);\n\tif (!reasm_data)\n\t\tgoto err;\n\n\tpayload_len = ((skb->data - skb_network_header(skb)) -\n\t\t       sizeof(struct ipv6hdr) + fq->q.len -\n\t\t       sizeof(struct frag_hdr));\n\tif (payload_len > IPV6_MAXPLEN) {\n\t\tnet_dbg_ratelimited(\"nf_ct_frag6_reasm: payload len = %d\\n\",\n\t\t\t\t    payload_len);\n\t\tgoto err;\n\t}\n\n\t \n\tskb_network_header(skb)[fq->nhoffset] = skb_transport_header(skb)[0];\n\tmemmove(skb->head + sizeof(struct frag_hdr), skb->head,\n\t\t(skb->data - skb->head) - sizeof(struct frag_hdr));\n\tskb->mac_header += sizeof(struct frag_hdr);\n\tskb->network_header += sizeof(struct frag_hdr);\n\n\tskb_reset_transport_header(skb);\n\n\tinet_frag_reasm_finish(&fq->q, skb, reasm_data, false);\n\n\tskb->ignore_df = 1;\n\tskb->dev = dev;\n\tipv6_hdr(skb)->payload_len = htons(payload_len);\n\tipv6_change_dsfield(ipv6_hdr(skb), 0xff, ecn);\n\tIP6CB(skb)->frag_max_size = sizeof(struct ipv6hdr) + fq->q.max_size;\n\tIP6CB(skb)->flags |= IP6SKB_FRAGMENTED;\n\n\t \n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tskb->csum = csum_partial(skb_network_header(skb),\n\t\t\t\t\t skb_network_header_len(skb),\n\t\t\t\t\t skb->csum);\n\n\tfq->q.rb_fragments = RB_ROOT;\n\tfq->q.fragments_tail = NULL;\n\tfq->q.last_run_head = NULL;\n\n\treturn 0;\n\nerr:\n\tinet_frag_kill(&fq->q);\n\treturn -EINVAL;\n}\n\n \nstatic int\nfind_prev_fhdr(struct sk_buff *skb, u8 *prevhdrp, int *prevhoff, int *fhoff)\n{\n\tu8 nexthdr = ipv6_hdr(skb)->nexthdr;\n\tconst int netoff = skb_network_offset(skb);\n\tu8 prev_nhoff = netoff + offsetof(struct ipv6hdr, nexthdr);\n\tint start = netoff + sizeof(struct ipv6hdr);\n\tint len = skb->len - start;\n\tu8 prevhdr = NEXTHDR_IPV6;\n\n\twhile (nexthdr != NEXTHDR_FRAGMENT) {\n\t\tstruct ipv6_opt_hdr hdr;\n\t\tint hdrlen;\n\n\t\tif (!ipv6_ext_hdr(nexthdr)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (nexthdr == NEXTHDR_NONE) {\n\t\t\tpr_debug(\"next header is none\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (len < (int)sizeof(struct ipv6_opt_hdr)) {\n\t\t\tpr_debug(\"too short\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (skb_copy_bits(skb, start, &hdr, sizeof(hdr)))\n\t\t\tBUG();\n\t\tif (nexthdr == NEXTHDR_AUTH)\n\t\t\thdrlen = ipv6_authlen(&hdr);\n\t\telse\n\t\t\thdrlen = ipv6_optlen(&hdr);\n\n\t\tprevhdr = nexthdr;\n\t\tprev_nhoff = start;\n\n\t\tnexthdr = hdr.nexthdr;\n\t\tlen -= hdrlen;\n\t\tstart += hdrlen;\n\t}\n\n\tif (len < 0)\n\t\treturn -1;\n\n\t*prevhdrp = prevhdr;\n\t*prevhoff = prev_nhoff;\n\t*fhoff = start;\n\n\treturn 0;\n}\n\nint nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tu16 savethdr = skb->transport_header;\n\tu8 nexthdr = NEXTHDR_FRAGMENT;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n\n\t \n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn 0;\n\n\t \n\tif (ipv6frag_thdr_truncated(skb, fhoff, &nexthdr)) {\n\t\tpr_debug(\"Drop incomplete fragment\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n\t\treturn -ENOMEM;\n\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\n\tskb_orphan(skb);\n\tfq = fq_find(net, fhdr->identification, user, hdr,\n\t\t     skb->dev ? skb->dev->ifindex : 0);\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_bh(&fq->q.lock);\n\n\tret = nf_ct_frag6_queue(fq, skb, fhdr, nhoff);\n\tif (ret == -EPROTO) {\n\t\tskb->transport_header = savethdr;\n\t\tret = 0;\n\t}\n\n\tspin_unlock_bh(&fq->q.lock);\n\tinet_frag_put(&fq->q);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nf_ct_frag6_gather);\n\nstatic int nf_ct_net_init(struct net *net)\n{\n\tstruct nft_ct_frag6_pernet *nf_frag  = nf_frag_pernet(net);\n\tint res;\n\n\tres = fqdir_init(&nf_frag->fqdir, &nf_frags, net);\n\tif (res < 0)\n\t\treturn res;\n\n\tnf_frag->fqdir->high_thresh = IPV6_FRAG_HIGH_THRESH;\n\tnf_frag->fqdir->low_thresh = IPV6_FRAG_LOW_THRESH;\n\tnf_frag->fqdir->timeout = IPV6_FRAG_TIMEOUT;\n\n\tres = nf_ct_frag6_sysctl_register(net);\n\tif (res < 0)\n\t\tfqdir_exit(nf_frag->fqdir);\n\treturn res;\n}\n\nstatic void nf_ct_net_pre_exit(struct net *net)\n{\n\tstruct nft_ct_frag6_pernet *nf_frag  = nf_frag_pernet(net);\n\n\tfqdir_pre_exit(nf_frag->fqdir);\n}\n\nstatic void nf_ct_net_exit(struct net *net)\n{\n\tstruct nft_ct_frag6_pernet *nf_frag  = nf_frag_pernet(net);\n\n\tnf_ct_frags6_sysctl_unregister(net);\n\tfqdir_exit(nf_frag->fqdir);\n}\n\nstatic struct pernet_operations nf_ct_net_ops = {\n\t.init\t\t= nf_ct_net_init,\n\t.pre_exit\t= nf_ct_net_pre_exit,\n\t.exit\t\t= nf_ct_net_exit,\n\t.id\t\t= &nf_frag_pernet_id,\n\t.size\t\t= sizeof(struct nft_ct_frag6_pernet),\n};\n\nstatic const struct rhashtable_params nfct_rhash_params = {\n\t.head_offset\t\t= offsetof(struct inet_frag_queue, node),\n\t.hashfn\t\t\t= ip6frag_key_hashfn,\n\t.obj_hashfn\t\t= ip6frag_obj_hashfn,\n\t.obj_cmpfn\t\t= ip6frag_obj_cmpfn,\n\t.automatic_shrinking\t= true,\n};\n\nint nf_ct_frag6_init(void)\n{\n\tint ret = 0;\n\n\tnf_frags.constructor = ip6frag_init;\n\tnf_frags.destructor = NULL;\n\tnf_frags.qsize = sizeof(struct frag_queue);\n\tnf_frags.frag_expire = nf_ct_frag6_expire;\n\tnf_frags.frags_cache_name = nf_frags_cache_name;\n\tnf_frags.rhash_params = nfct_rhash_params;\n\tret = inet_frags_init(&nf_frags);\n\tif (ret)\n\t\tgoto out;\n\tret = register_pernet_subsys(&nf_ct_net_ops);\n\tif (ret)\n\t\tinet_frags_fini(&nf_frags);\n\nout:\n\treturn ret;\n}\n\nvoid nf_ct_frag6_cleanup(void)\n{\n\tunregister_pernet_subsys(&nf_ct_net_ops);\n\tinet_frags_fini(&nf_frags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}