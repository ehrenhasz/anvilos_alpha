{
  "module_name": "ip6t_NPT.c",
  "hash_id": "64a880174529d8a7cef3b4cb6cc4f6ee53af4a895cd1029279123e99a87f206c",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/ip6t_NPT.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ipv6.h>\n#include <net/ipv6.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_ipv6/ip6t_NPT.h>\n#include <linux/netfilter/x_tables.h>\n\nstatic int ip6t_npt_checkentry(const struct xt_tgchk_param *par)\n{\n\tstruct ip6t_npt_tginfo *npt = par->targinfo;\n\tstruct in6_addr pfx;\n\t__wsum src_sum, dst_sum;\n\n\tif (npt->src_pfx_len > 64 || npt->dst_pfx_len > 64)\n\t\treturn -EINVAL;\n\n\t \n\tipv6_addr_prefix(&pfx, &npt->src_pfx.in6, npt->src_pfx_len);\n\tif (!ipv6_addr_equal(&pfx, &npt->src_pfx.in6))\n\t\treturn -EINVAL;\n\tipv6_addr_prefix(&pfx, &npt->dst_pfx.in6, npt->dst_pfx_len);\n\tif (!ipv6_addr_equal(&pfx, &npt->dst_pfx.in6))\n\t\treturn -EINVAL;\n\n\tsrc_sum = csum_partial(&npt->src_pfx.in6, sizeof(npt->src_pfx.in6), 0);\n\tdst_sum = csum_partial(&npt->dst_pfx.in6, sizeof(npt->dst_pfx.in6), 0);\n\n\tnpt->adjustment = ~csum_fold(csum_sub(src_sum, dst_sum));\n\treturn 0;\n}\n\nstatic bool ip6t_npt_map_pfx(const struct ip6t_npt_tginfo *npt,\n\t\t\t     struct in6_addr *addr)\n{\n\tunsigned int pfx_len;\n\tunsigned int i, idx;\n\t__be32 mask;\n\t__sum16 sum;\n\n\tpfx_len = max(npt->src_pfx_len, npt->dst_pfx_len);\n\tfor (i = 0; i < pfx_len; i += 32) {\n\t\tif (pfx_len - i >= 32)\n\t\t\tmask = 0;\n\t\telse\n\t\t\tmask = htonl((1 << (i - pfx_len + 32)) - 1);\n\n\t\tidx = i / 32;\n\t\taddr->s6_addr32[idx] &= mask;\n\t\taddr->s6_addr32[idx] |= ~mask & npt->dst_pfx.in6.s6_addr32[idx];\n\t}\n\n\tif (pfx_len <= 48)\n\t\tidx = 3;\n\telse {\n\t\tfor (idx = 4; idx < ARRAY_SIZE(addr->s6_addr16); idx++) {\n\t\t\tif ((__force __sum16)addr->s6_addr16[idx] !=\n\t\t\t    CSUM_MANGLED_0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (idx == ARRAY_SIZE(addr->s6_addr16))\n\t\t\treturn false;\n\t}\n\n\tsum = ~csum_fold(csum_add(csum_unfold((__force __sum16)addr->s6_addr16[idx]),\n\t\t\t\t  csum_unfold(npt->adjustment)));\n\tif (sum == CSUM_MANGLED_0)\n\t\tsum = 0;\n\t*(__force __sum16 *)&addr->s6_addr16[idx] = sum;\n\n\treturn true;\n}\n\nstatic struct ipv6hdr *icmpv6_bounced_ipv6hdr(struct sk_buff *skb,\n\t\t\t\t\t      struct ipv6hdr *_bounced_hdr)\n{\n\tif (ipv6_hdr(skb)->nexthdr != IPPROTO_ICMPV6)\n\t\treturn NULL;\n\n\tif (!icmpv6_is_err(icmp6_hdr(skb)->icmp6_type))\n\t\treturn NULL;\n\n\treturn skb_header_pointer(skb,\n\t\t\t\t  skb_transport_offset(skb) + sizeof(struct icmp6hdr),\n\t\t\t\t  sizeof(struct ipv6hdr),\n\t\t\t\t  _bounced_hdr);\n}\n\nstatic unsigned int\nip6t_snpt_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct ip6t_npt_tginfo *npt = par->targinfo;\n\tstruct ipv6hdr _bounced_hdr;\n\tstruct ipv6hdr *bounced_hdr;\n\tstruct in6_addr bounced_pfx;\n\n\tif (!ip6t_npt_map_pfx(npt, &ipv6_hdr(skb)->saddr)) {\n\t\ticmpv6_send(skb, ICMPV6_PARAMPROB, ICMPV6_HDR_FIELD,\n\t\t\t    offsetof(struct ipv6hdr, saddr));\n\t\treturn NF_DROP;\n\t}\n\n\t \n\tbounced_hdr = icmpv6_bounced_ipv6hdr(skb, &_bounced_hdr);\n\tif (bounced_hdr) {\n\t\tipv6_addr_prefix(&bounced_pfx, &bounced_hdr->daddr, npt->src_pfx_len);\n\t\tif (ipv6_addr_cmp(&bounced_pfx, &npt->src_pfx.in6) == 0)\n\t\t\tip6t_npt_map_pfx(npt, &bounced_hdr->daddr);\n\t}\n\n\treturn XT_CONTINUE;\n}\n\nstatic unsigned int\nip6t_dnpt_tg(struct sk_buff *skb, const struct xt_action_param *par)\n{\n\tconst struct ip6t_npt_tginfo *npt = par->targinfo;\n\tstruct ipv6hdr _bounced_hdr;\n\tstruct ipv6hdr *bounced_hdr;\n\tstruct in6_addr bounced_pfx;\n\n\tif (!ip6t_npt_map_pfx(npt, &ipv6_hdr(skb)->daddr)) {\n\t\ticmpv6_send(skb, ICMPV6_PARAMPROB, ICMPV6_HDR_FIELD,\n\t\t\t    offsetof(struct ipv6hdr, daddr));\n\t\treturn NF_DROP;\n\t}\n\n\t \n\tbounced_hdr = icmpv6_bounced_ipv6hdr(skb, &_bounced_hdr);\n\tif (bounced_hdr) {\n\t\tipv6_addr_prefix(&bounced_pfx, &bounced_hdr->saddr, npt->src_pfx_len);\n\t\tif (ipv6_addr_cmp(&bounced_pfx, &npt->src_pfx.in6) == 0)\n\t\t\tip6t_npt_map_pfx(npt, &bounced_hdr->saddr);\n\t}\n\n\treturn XT_CONTINUE;\n}\n\nstatic struct xt_target ip6t_npt_target_reg[] __read_mostly = {\n\t{\n\t\t.name\t\t= \"SNPT\",\n\t\t.table\t\t= \"mangle\",\n\t\t.target\t\t= ip6t_snpt_tg,\n\t\t.targetsize\t= sizeof(struct ip6t_npt_tginfo),\n\t\t.usersize\t= offsetof(struct ip6t_npt_tginfo, adjustment),\n\t\t.checkentry\t= ip6t_npt_checkentry,\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.hooks\t\t= (1 << NF_INET_LOCAL_IN) |\n\t\t\t\t  (1 << NF_INET_POST_ROUTING),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n\t{\n\t\t.name\t\t= \"DNPT\",\n\t\t.table\t\t= \"mangle\",\n\t\t.target\t\t= ip6t_dnpt_tg,\n\t\t.targetsize\t= sizeof(struct ip6t_npt_tginfo),\n\t\t.usersize\t= offsetof(struct ip6t_npt_tginfo, adjustment),\n\t\t.checkentry\t= ip6t_npt_checkentry,\n\t\t.family\t\t= NFPROTO_IPV6,\n\t\t.hooks\t\t= (1 << NF_INET_PRE_ROUTING) |\n\t\t\t\t  (1 << NF_INET_LOCAL_OUT),\n\t\t.me\t\t= THIS_MODULE,\n\t},\n};\n\nstatic int __init ip6t_npt_init(void)\n{\n\treturn xt_register_targets(ip6t_npt_target_reg,\n\t\t\t\t   ARRAY_SIZE(ip6t_npt_target_reg));\n}\n\nstatic void __exit ip6t_npt_exit(void)\n{\n\txt_unregister_targets(ip6t_npt_target_reg,\n\t\t\t      ARRAY_SIZE(ip6t_npt_target_reg));\n}\n\nmodule_init(ip6t_npt_init);\nmodule_exit(ip6t_npt_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"IPv6-to-IPv6 Network Prefix Translation (RFC 6296)\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_ALIAS(\"ip6t_SNPT\");\nMODULE_ALIAS(\"ip6t_DNPT\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}