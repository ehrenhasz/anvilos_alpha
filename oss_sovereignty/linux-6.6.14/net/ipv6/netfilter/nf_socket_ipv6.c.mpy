{
  "module_name": "nf_socket_ipv6.c",
  "hash_id": "091054686d94bb8133b6d19b449177e5a7e31a8569778a975ef52a7d49678b32",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/nf_socket_ipv6.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/icmp.h>\n#include <net/sock.h>\n#include <net/inet_sock.h>\n#include <net/inet6_hashtables.h>\n#include <net/netfilter/nf_socket.h>\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n#include <net/netfilter/nf_conntrack.h>\n#endif\n\nstatic int\nextract_icmp6_fields(const struct sk_buff *skb,\n\t\t     unsigned int outside_hdrlen,\n\t\t     int *protocol,\n\t\t     const struct in6_addr **raddr,\n\t\t     const struct in6_addr **laddr,\n\t\t     __be16 *rport,\n\t\t     __be16 *lport,\n\t\t     struct ipv6hdr *ipv6_var)\n{\n\tconst struct ipv6hdr *inside_iph;\n\tstruct icmp6hdr *icmph, _icmph;\n\t__be16 *ports, _ports[2];\n\tu8 inside_nexthdr;\n\t__be16 inside_fragoff;\n\tint inside_hdrlen;\n\n\ticmph = skb_header_pointer(skb, outside_hdrlen,\n\t\t\t\t   sizeof(_icmph), &_icmph);\n\tif (icmph == NULL)\n\t\treturn 1;\n\n\tif (icmph->icmp6_type & ICMPV6_INFOMSG_MASK)\n\t\treturn 1;\n\n\tinside_iph = skb_header_pointer(skb, outside_hdrlen + sizeof(_icmph),\n\t\t\t\t\tsizeof(*ipv6_var), ipv6_var);\n\tif (inside_iph == NULL)\n\t\treturn 1;\n\tinside_nexthdr = inside_iph->nexthdr;\n\n\tinside_hdrlen = ipv6_skip_exthdr(skb, outside_hdrlen + sizeof(_icmph) +\n\t\t\t\t\t      sizeof(*ipv6_var),\n\t\t\t\t\t &inside_nexthdr, &inside_fragoff);\n\tif (inside_hdrlen < 0)\n\t\treturn 1;  \n\n\tif (inside_nexthdr != IPPROTO_TCP &&\n\t    inside_nexthdr != IPPROTO_UDP)\n\t\treturn 1;\n\n\tports = skb_header_pointer(skb, inside_hdrlen,\n\t\t\t\t   sizeof(_ports), &_ports);\n\tif (ports == NULL)\n\t\treturn 1;\n\n\t \n\t*protocol = inside_nexthdr;\n\t*laddr = &inside_iph->saddr;\n\t*lport = ports[0];\n\t*raddr = &inside_iph->daddr;\n\t*rport = ports[1];\n\n\treturn 0;\n}\n\nstatic struct sock *\nnf_socket_get_sock_v6(struct net *net, struct sk_buff *skb, int doff,\n\t\t      const u8 protocol,\n\t\t      const struct in6_addr *saddr, const struct in6_addr *daddr,\n\t\t      const __be16 sport, const __be16 dport,\n\t\t      const struct net_device *in)\n{\n\tswitch (protocol) {\n\tcase IPPROTO_TCP:\n\t\treturn inet6_lookup(net, net->ipv4.tcp_death_row.hashinfo,\n\t\t\t\t    skb, doff, saddr, sport, daddr, dport,\n\t\t\t\t    in->ifindex);\n\tcase IPPROTO_UDP:\n\t\treturn udp6_lib_lookup(net, saddr, sport, daddr, dport,\n\t\t\t\t       in->ifindex);\n\t}\n\n\treturn NULL;\n}\n\nstruct sock *nf_sk_lookup_slow_v6(struct net *net, const struct sk_buff *skb,\n\t\t\t\t  const struct net_device *indev)\n{\n\t__be16 dport, sport;\n\tconst struct in6_addr *daddr = NULL, *saddr = NULL;\n\tstruct ipv6hdr *iph = ipv6_hdr(skb), ipv6_var;\n\tstruct sk_buff *data_skb = NULL;\n\tint doff = 0;\n\tint thoff = 0, tproto;\n\n\ttproto = ipv6_find_hdr(skb, &thoff, -1, NULL, NULL);\n\tif (tproto < 0) {\n\t\tpr_debug(\"unable to find transport header in IPv6 packet, dropping\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (tproto == IPPROTO_UDP || tproto == IPPROTO_TCP) {\n\t\tstruct tcphdr _hdr;\n\t\tstruct udphdr *hp;\n\n\t\thp = skb_header_pointer(skb, thoff, tproto == IPPROTO_UDP ?\n\t\t\t\t\tsizeof(*hp) : sizeof(_hdr), &_hdr);\n\t\tif (hp == NULL)\n\t\t\treturn NULL;\n\n\t\tsaddr = &iph->saddr;\n\t\tsport = hp->source;\n\t\tdaddr = &iph->daddr;\n\t\tdport = hp->dest;\n\t\tdata_skb = (struct sk_buff *)skb;\n\t\tdoff = tproto == IPPROTO_TCP ?\n\t\t\tthoff + __tcp_hdrlen((struct tcphdr *)hp) :\n\t\t\tthoff + sizeof(*hp);\n\n\t} else if (tproto == IPPROTO_ICMPV6) {\n\t\tif (extract_icmp6_fields(skb, thoff, &tproto, &saddr, &daddr,\n\t\t\t\t\t &sport, &dport, &ipv6_var))\n\t\t\treturn NULL;\n\t} else {\n\t\treturn NULL;\n\t}\n\n\treturn nf_socket_get_sock_v6(net, data_skb, doff, tproto, saddr, daddr,\n\t\t\t\t     sport, dport, indev);\n}\nEXPORT_SYMBOL_GPL(nf_sk_lookup_slow_v6);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Krisztian Kovacs, Balazs Scheidler\");\nMODULE_DESCRIPTION(\"Netfilter IPv6 socket lookup infrastructure\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}