{
  "module_name": "ip6t_ipv6header.c",
  "hash_id": "7107ccf7a61b41ee33528d9b9c73aaf7817499d2a47eec9b8af286c65edd238a",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/ip6t_ipv6header.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/ipv6.h>\n#include <linux/types.h>\n#include <net/checksum.h>\n#include <net/ipv6.h>\n\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/netfilter_ipv6/ip6t_ipv6header.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Xtables: IPv6 header types match\");\nMODULE_AUTHOR(\"Andras Kis-Szabo <kisza@sch.bme.hu>\");\n\nstatic bool\nipv6header_mt6(const struct sk_buff *skb, struct xt_action_param *par)\n{\n\tconst struct ip6t_ipv6header_info *info = par->matchinfo;\n\tunsigned int temp;\n\tint len;\n\tu8 nexthdr;\n\tunsigned int ptr;\n\n\t \n\n\t \n\tnexthdr = ipv6_hdr(skb)->nexthdr;\n\t \n\tptr = sizeof(struct ipv6hdr);\n\t \n\tlen = skb->len - ptr;\n\ttemp = 0;\n\n\twhile (nf_ip6_ext_hdr(nexthdr)) {\n\t\tconst struct ipv6_opt_hdr *hp;\n\t\tstruct ipv6_opt_hdr _hdr;\n\t\tint hdrlen;\n\n\t\t \n\t\tif (nexthdr == NEXTHDR_NONE) {\n\t\t\ttemp |= MASK_NONE;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (len < (int)sizeof(struct ipv6_opt_hdr))\n\t\t\treturn false;\n\t\t \n\t\tif (nexthdr == NEXTHDR_ESP) {\n\t\t\ttemp |= MASK_ESP;\n\t\t\tbreak;\n\t\t}\n\n\t\thp = skb_header_pointer(skb, ptr, sizeof(_hdr), &_hdr);\n\t\tif (!hp) {\n\t\t\tpar->hotdrop = true;\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tif (nexthdr == NEXTHDR_FRAGMENT)\n\t\t\thdrlen = 8;\n\t\telse if (nexthdr == NEXTHDR_AUTH)\n\t\t\thdrlen = ipv6_authlen(hp);\n\t\telse\n\t\t\thdrlen = ipv6_optlen(hp);\n\n\t\t \n\t\tswitch (nexthdr) {\n\t\tcase NEXTHDR_HOP:\n\t\t\ttemp |= MASK_HOPOPTS;\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\ttemp |= MASK_ROUTING;\n\t\t\tbreak;\n\t\tcase NEXTHDR_FRAGMENT:\n\t\t\ttemp |= MASK_FRAGMENT;\n\t\t\tbreak;\n\t\tcase NEXTHDR_AUTH:\n\t\t\ttemp |= MASK_AH;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n\t\t\ttemp |= MASK_DSTOPTS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\n\t\tnexthdr = hp->nexthdr;\n\t\tlen -= hdrlen;\n\t\tptr += hdrlen;\n\t\tif (ptr > skb->len)\n\t\t\tbreak;\n\t}\n\n\tif (nexthdr != NEXTHDR_NONE && nexthdr != NEXTHDR_ESP)\n\t\ttemp |= MASK_PROTO;\n\n\tif (info->modeflag)\n\t\treturn !((temp ^ info->matchflags ^ info->invflags)\n\t\t\t & info->matchflags);\n\telse {\n\t\tif (info->invflags)\n\t\t\treturn temp != info->matchflags;\n\t\telse\n\t\t\treturn temp == info->matchflags;\n\t}\n}\n\nstatic int ipv6header_mt6_check(const struct xt_mtchk_param *par)\n{\n\tconst struct ip6t_ipv6header_info *info = par->matchinfo;\n\n\t \n\tif ((!info->modeflag) && info->invflags != 0x00 &&\n\t    info->invflags != 0xFF)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct xt_match ipv6header_mt6_reg __read_mostly = {\n\t.name\t\t= \"ipv6header\",\n\t.family\t\t= NFPROTO_IPV6,\n\t.match\t\t= ipv6header_mt6,\n\t.matchsize\t= sizeof(struct ip6t_ipv6header_info),\n\t.checkentry\t= ipv6header_mt6_check,\n\t.destroy\t= NULL,\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init ipv6header_mt6_init(void)\n{\n\treturn xt_register_match(&ipv6header_mt6_reg);\n}\n\nstatic void __exit ipv6header_mt6_exit(void)\n{\n\txt_unregister_match(&ipv6header_mt6_reg);\n}\n\nmodule_init(ipv6header_mt6_init);\nmodule_exit(ipv6header_mt6_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}