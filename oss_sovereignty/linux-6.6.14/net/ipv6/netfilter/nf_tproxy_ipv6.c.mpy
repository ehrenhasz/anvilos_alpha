{
  "module_name": "nf_tproxy_ipv6.c",
  "hash_id": "17b05d95a2fbdc63ffe1814d9d5339c7192adf3a57e84cde3e5e9a7159a567cd",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/netfilter/nf_tproxy_ipv6.c",
  "human_readable_source": "\n#include <net/netfilter/nf_tproxy.h>\n#include <linux/module.h>\n#include <net/inet6_hashtables.h>\n#include <net/addrconf.h>\n#include <net/udp.h>\n#include <net/tcp.h>\n\nconst struct in6_addr *\nnf_tproxy_laddr6(struct sk_buff *skb, const struct in6_addr *user_laddr,\n\t      const struct in6_addr *daddr)\n{\n\tstruct inet6_dev *indev;\n\tstruct inet6_ifaddr *ifa;\n\tstruct in6_addr *laddr;\n\n\tif (!ipv6_addr_any(user_laddr))\n\t\treturn user_laddr;\n\tladdr = NULL;\n\n\tindev = __in6_dev_get(skb->dev);\n\tif (indev) {\n\t\tread_lock_bh(&indev->lock);\n\t\tlist_for_each_entry(ifa, &indev->addr_list, if_list) {\n\t\t\tif (ifa->flags & (IFA_F_TENTATIVE | IFA_F_DEPRECATED))\n\t\t\t\tcontinue;\n\n\t\t\tladdr = &ifa->addr;\n\t\t\tbreak;\n\t\t}\n\t\tread_unlock_bh(&indev->lock);\n\t}\n\n\treturn laddr ? laddr : daddr;\n}\nEXPORT_SYMBOL_GPL(nf_tproxy_laddr6);\n\nstruct sock *\nnf_tproxy_handle_time_wait6(struct sk_buff *skb, int tproto, int thoff,\n\t\t\t struct net *net,\n\t\t\t const struct in6_addr *laddr,\n\t\t\t const __be16 lport,\n\t\t\t struct sock *sk)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct tcphdr _hdr, *hp;\n\n\thp = skb_header_pointer(skb, thoff, sizeof(_hdr), &_hdr);\n\tif (hp == NULL) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn NULL;\n\t}\n\n\tif (hp->syn && !hp->rst && !hp->ack && !hp->fin) {\n\t\t \n\t\tstruct sock *sk2;\n\n\t\tsk2 = nf_tproxy_get_sock_v6(net, skb, thoff, tproto,\n\t\t\t\t\t    &iph->saddr,\n\t\t\t\t\t    nf_tproxy_laddr6(skb, laddr, &iph->daddr),\n\t\t\t\t\t    hp->source,\n\t\t\t\t\t    lport ? lport : hp->dest,\n\t\t\t\t\t    skb->dev, NF_TPROXY_LOOKUP_LISTENER);\n\t\tif (sk2) {\n\t\t\tnf_tproxy_twsk_deschedule_put(inet_twsk(sk));\n\t\t\tsk = sk2;\n\t\t}\n\t}\n\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(nf_tproxy_handle_time_wait6);\n\nstruct sock *\nnf_tproxy_get_sock_v6(struct net *net, struct sk_buff *skb, int thoff,\n\t\t      const u8 protocol,\n\t\t      const struct in6_addr *saddr, const struct in6_addr *daddr,\n\t\t      const __be16 sport, const __be16 dport,\n\t\t      const struct net_device *in,\n\t\t      const enum nf_tproxy_lookup_t lookup_type)\n{\n\tstruct inet_hashinfo *hinfo = net->ipv4.tcp_death_row.hashinfo;\n\tstruct sock *sk;\n\n\tswitch (protocol) {\n\tcase IPPROTO_TCP: {\n\t\tstruct tcphdr _hdr, *hp;\n\n\t\thp = skb_header_pointer(skb, thoff,\n\t\t\t\t\tsizeof(struct tcphdr), &_hdr);\n\t\tif (hp == NULL)\n\t\t\treturn NULL;\n\n\t\tswitch (lookup_type) {\n\t\tcase NF_TPROXY_LOOKUP_LISTENER:\n\t\t\tsk = inet6_lookup_listener(net, hinfo, skb,\n\t\t\t\t\t\t   thoff + __tcp_hdrlen(hp),\n\t\t\t\t\t\t   saddr, sport,\n\t\t\t\t\t\t   daddr, ntohs(dport),\n\t\t\t\t\t\t   in->ifindex, 0);\n\n\t\t\tif (sk && !refcount_inc_not_zero(&sk->sk_refcnt))\n\t\t\t\tsk = NULL;\n\t\t\t \n\t\t\tbreak;\n\t\tcase NF_TPROXY_LOOKUP_ESTABLISHED:\n\t\t\tsk = __inet6_lookup_established(net, hinfo, saddr, sport, daddr,\n\t\t\t\t\t\t\tntohs(dport), in->ifindex, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tbreak;\n\t\t}\n\tcase IPPROTO_UDP:\n\t\tsk = udp6_lib_lookup(net, saddr, sport, daddr, dport,\n\t\t\t\t     in->ifindex);\n\t\tif (sk) {\n\t\t\tint connected = (sk->sk_state == TCP_ESTABLISHED);\n\t\t\tint wildcard = ipv6_addr_any(&sk->sk_v6_rcv_saddr);\n\n\t\t\t \n\t\t\tif ((lookup_type == NF_TPROXY_LOOKUP_ESTABLISHED && (!connected || wildcard)) ||\n\t\t\t    (lookup_type == NF_TPROXY_LOOKUP_LISTENER && connected)) {\n\t\t\t\tsock_put(sk);\n\t\t\t\tsk = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tsk = NULL;\n\t}\n\n\tpr_debug(\"tproxy socket lookup: proto %u %pI6:%u -> %pI6:%u, lookup type: %d, sock %p\\n\",\n\t\t protocol, saddr, ntohs(sport), daddr, ntohs(dport), lookup_type, sk);\n\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(nf_tproxy_get_sock_v6);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Balazs Scheidler, Krisztian Kovacs\");\nMODULE_DESCRIPTION(\"Netfilter IPv6 transparent proxy support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}