{
  "module_name": "output_core.c",
  "hash_id": "d409215a82526bc95db660ff5f693c56f7794601500ec8952919ddf81e47575a",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/output_core.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/ip6_fib.h>\n#include <net/addrconf.h>\n#include <net/secure_seq.h>\n#include <linux/netfilter.h>\n\nstatic u32 __ipv6_select_ident(struct net *net,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\treturn get_random_u32_above(0);\n}\n\n \n__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\n\tid = __ipv6_select_ident(net, &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}\nEXPORT_SYMBOL_GPL(ipv6_proxy_select_ident);\n\n__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tu32 id;\n\n\tid = __ipv6_select_ident(net, daddr, saddr);\n\treturn htonl(id);\n}\nEXPORT_SYMBOL(ipv6_select_ident);\n\nint ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tunsigned int offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\toffset += ipv6_optlen(exthdr);\n\t\tif (offset > IPV6_MAXPLEN)\n\t\t\treturn -EINVAL;\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(ip6_find_1stfragopt);\n\n#if IS_ENABLED(CONFIG_IPV6)\nint ip6_dst_hoplimit(struct dst_entry *dst)\n{\n\tint hoplimit = dst_metric_raw(dst, RTAX_HOPLIMIT);\n\tif (hoplimit == 0) {\n\t\tstruct net_device *dev = dst->dev;\n\t\tstruct inet6_dev *idev;\n\n\t\trcu_read_lock();\n\t\tidev = __in6_dev_get(dev);\n\t\tif (idev)\n\t\t\thoplimit = idev->cnf.hop_limit;\n\t\telse\n\t\t\thoplimit = dev_net(dev)->ipv6.devconf_all->hop_limit;\n\t\trcu_read_unlock();\n\t}\n\treturn hoplimit;\n}\nEXPORT_SYMBOL(ip6_dst_hoplimit);\n#endif\n\nint __ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tint len;\n\n\tlen = skb->len - sizeof(struct ipv6hdr);\n\tif (len > IPV6_MAXPLEN)\n\t\tlen = 0;\n\tipv6_hdr(skb)->payload_len = htons(len);\n\tIP6CB(skb)->nhoff = offsetof(struct ipv6hdr, nexthdr);\n\n\t \n\tskb = l3mdev_ip6_out(sk, skb);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\treturn nf_hook(NFPROTO_IPV6, NF_INET_LOCAL_OUT,\n\t\t       net, sk, skb, NULL, skb_dst(skb)->dev,\n\t\t       dst_output);\n}\nEXPORT_SYMBOL_GPL(__ip6_local_out);\n\nint ip6_local_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tint err;\n\n\terr = __ip6_local_out(net, sk, skb);\n\tif (likely(err == 1))\n\t\terr = dst_output(net, sk, skb);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip6_local_out);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}