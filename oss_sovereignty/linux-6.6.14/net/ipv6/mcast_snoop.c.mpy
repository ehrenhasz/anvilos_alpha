{
  "module_name": "mcast_snoop.c",
  "hash_id": "d7cd2d54d68428e577186af079e5e013ed16896951f9f6432744adf10eace8d4",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/mcast_snoop.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <net/ipv6.h>\n#include <net/mld.h>\n#include <net/addrconf.h>\n#include <net/ip6_checksum.h>\n\nstatic int ipv6_mc_check_ip6hdr(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *ip6h;\n\tunsigned int len;\n\tunsigned int offset = skb_network_offset(skb) + sizeof(*ip6h);\n\n\tif (!pskb_may_pull(skb, offset))\n\t\treturn -EINVAL;\n\n\tip6h = ipv6_hdr(skb);\n\n\tif (ip6h->version != 6)\n\t\treturn -EINVAL;\n\n\tlen = offset + ntohs(ip6h->payload_len);\n\tif (skb->len < len || len <= offset)\n\t\treturn -EINVAL;\n\n\tskb_set_transport_header(skb, offset);\n\n\treturn 0;\n}\n\nstatic int ipv6_mc_check_exthdrs(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *ip6h;\n\tint offset;\n\tu8 nexthdr;\n\t__be16 frag_off;\n\n\tip6h = ipv6_hdr(skb);\n\n\tif (ip6h->nexthdr != IPPROTO_HOPOPTS)\n\t\treturn -ENOMSG;\n\n\tnexthdr = ip6h->nexthdr;\n\toffset = skb_network_offset(skb) + sizeof(*ip6h);\n\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);\n\n\tif (offset < 0)\n\t\treturn -EINVAL;\n\n\tif (nexthdr != IPPROTO_ICMPV6)\n\t\treturn -ENOMSG;\n\n\tskb_set_transport_header(skb, offset);\n\n\treturn 0;\n}\n\nstatic int ipv6_mc_check_mld_reportv2(struct sk_buff *skb)\n{\n\tunsigned int len = skb_transport_offset(skb);\n\n\tlen += sizeof(struct mld2_report);\n\n\treturn ipv6_mc_may_pull(skb, len) ? 0 : -EINVAL;\n}\n\nstatic int ipv6_mc_check_mld_query(struct sk_buff *skb)\n{\n\tunsigned int transport_len = ipv6_transport_len(skb);\n\tstruct mld_msg *mld;\n\tunsigned int len;\n\n\t \n\tif (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL))\n\t\treturn -EINVAL;\n\n\t \n\tif (transport_len != sizeof(struct mld_msg)) {\n\t\t \n\t\tif (transport_len < sizeof(struct mld2_query))\n\t\t\treturn -EINVAL;\n\n\t\tlen = skb_transport_offset(skb) + sizeof(struct mld2_query);\n\t\tif (!ipv6_mc_may_pull(skb, len))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmld = (struct mld_msg *)skb_transport_header(skb);\n\n\t \n\tif (ipv6_addr_any(&mld->mld_mca) &&\n\t    !ipv6_addr_is_ll_all_nodes(&ipv6_hdr(skb)->daddr))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ipv6_mc_check_mld_msg(struct sk_buff *skb)\n{\n\tunsigned int len = skb_transport_offset(skb) + sizeof(struct mld_msg);\n\tstruct mld_msg *mld;\n\n\tif (!ipv6_mc_may_pull(skb, len))\n\t\treturn -ENODATA;\n\n\tmld = (struct mld_msg *)skb_transport_header(skb);\n\n\tswitch (mld->mld_type) {\n\tcase ICMPV6_MGM_REDUCTION:\n\tcase ICMPV6_MGM_REPORT:\n\t\treturn 0;\n\tcase ICMPV6_MLD2_REPORT:\n\t\treturn ipv6_mc_check_mld_reportv2(skb);\n\tcase ICMPV6_MGM_QUERY:\n\t\treturn ipv6_mc_check_mld_query(skb);\n\tdefault:\n\t\treturn -ENODATA;\n\t}\n}\n\nstatic inline __sum16 ipv6_mc_validate_checksum(struct sk_buff *skb)\n{\n\treturn skb_checksum_validate(skb, IPPROTO_ICMPV6, ip6_compute_pseudo);\n}\n\nstatic int ipv6_mc_check_icmpv6(struct sk_buff *skb)\n{\n\tunsigned int len = skb_transport_offset(skb) + sizeof(struct icmp6hdr);\n\tunsigned int transport_len = ipv6_transport_len(skb);\n\tstruct sk_buff *skb_chk;\n\n\tif (!ipv6_mc_may_pull(skb, len))\n\t\treturn -EINVAL;\n\n\tskb_chk = skb_checksum_trimmed(skb, transport_len,\n\t\t\t\t       ipv6_mc_validate_checksum);\n\tif (!skb_chk)\n\t\treturn -EINVAL;\n\n\tif (skb_chk != skb)\n\t\tkfree_skb(skb_chk);\n\n\treturn 0;\n}\n\n \nint ipv6_mc_check_mld(struct sk_buff *skb)\n{\n\tint ret;\n\n\tret = ipv6_mc_check_ip6hdr(skb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ipv6_mc_check_exthdrs(skb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ipv6_mc_check_icmpv6(skb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ipv6_mc_check_mld_msg(skb);\n}\nEXPORT_SYMBOL(ipv6_mc_check_mld);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}