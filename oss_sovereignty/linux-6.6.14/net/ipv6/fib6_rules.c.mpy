{
  "module_name": "fib6_rules.c",
  "hash_id": "65b402ee11350b2a268ae533357e3396b7f2ca66937dc130dac90f7dff6cbe26",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/fib6_rules.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/indirect_call_wrapper.h>\n\n#include <net/fib_rules.h>\n#include <net/inet_dscp.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/netlink.h>\n\nstruct fib6_rule {\n\tstruct fib_rule\t\tcommon;\n\tstruct rt6key\t\tsrc;\n\tstruct rt6key\t\tdst;\n\tdscp_t\t\t\tdscp;\n};\n\nstatic bool fib6_rule_matchall(const struct fib_rule *rule)\n{\n\tstruct fib6_rule *r = container_of(rule, struct fib6_rule, common);\n\n\tif (r->dst.plen || r->src.plen || r->dscp)\n\t\treturn false;\n\treturn fib_rule_matchall(rule);\n}\n\nbool fib6_rule_default(const struct fib_rule *rule)\n{\n\tif (!fib6_rule_matchall(rule) || rule->action != FR_ACT_TO_TBL ||\n\t    rule->l3mdev)\n\t\treturn false;\n\tif (rule->table != RT6_TABLE_LOCAL && rule->table != RT6_TABLE_MAIN)\n\t\treturn false;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(fib6_rule_default);\n\nint fib6_rules_dump(struct net *net, struct notifier_block *nb,\n\t\t    struct netlink_ext_ack *extack)\n{\n\treturn fib_rules_dump(net, nb, AF_INET6, extack);\n}\n\nunsigned int fib6_rules_seq_read(struct net *net)\n{\n\treturn fib_rules_seq_read(net, AF_INET6);\n}\n\n \nint fib6_lookup(struct net *net, int oif, struct flowi6 *fl6,\n\t\tstruct fib6_result *res, int flags)\n{\n\tint err;\n\n\tif (net->ipv6.fib6_has_custom_rules) {\n\t\tstruct fib_lookup_arg arg = {\n\t\t\t.lookup_ptr = fib6_table_lookup,\n\t\t\t.lookup_data = &oif,\n\t\t\t.result = res,\n\t\t\t.flags = FIB_LOOKUP_NOREF,\n\t\t};\n\n\t\tl3mdev_update_flow(net, flowi6_to_flowi(fl6));\n\n\t\terr = fib_rules_lookup(net->ipv6.fib6_rules_ops,\n\t\t\t\t       flowi6_to_flowi(fl6), flags, &arg);\n\t} else {\n\t\terr = fib6_table_lookup(net, net->ipv6.fib6_local_tbl, oif,\n\t\t\t\t\tfl6, res, flags);\n\t\tif (err || res->f6i == net->ipv6.fib6_null_entry)\n\t\t\terr = fib6_table_lookup(net, net->ipv6.fib6_main_tbl,\n\t\t\t\t\t\toif, fl6, res, flags);\n\t}\n\n\treturn err;\n}\n\nstruct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tif (net->ipv6.fib6_has_custom_rules) {\n\t\tstruct fib6_result res = {};\n\t\tstruct fib_lookup_arg arg = {\n\t\t\t.lookup_ptr = lookup,\n\t\t\t.lookup_data = skb,\n\t\t\t.result = &res,\n\t\t\t.flags = FIB_LOOKUP_NOREF,\n\t\t};\n\n\t\t \n\t\tl3mdev_update_flow(net, flowi6_to_flowi(fl6));\n\n\t\tfib_rules_lookup(net->ipv6.fib6_rules_ops,\n\t\t\t\t flowi6_to_flowi(fl6), flags, &arg);\n\n\t\tif (res.rt6)\n\t\t\treturn &res.rt6->dst;\n\t} else {\n\t\tstruct rt6_info *rt;\n\n\t\trt = pol_lookup_func(lookup,\n\t\t\t     net, net->ipv6.fib6_local_tbl, fl6, skb, flags);\n\t\tif (rt != net->ipv6.ip6_null_entry && rt->dst.error != -EAGAIN)\n\t\t\treturn &rt->dst;\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = pol_lookup_func(lookup,\n\t\t\t     net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\t\tif (rt->dst.error != -EAGAIN)\n\t\t\treturn &rt->dst;\n\t\tip6_rt_put_flags(rt, flags);\n\t}\n\n\tif (!(flags & RT6_LOOKUP_F_DST_NOREF))\n\t\tdst_hold(&net->ipv6.ip6_null_entry->dst);\n\treturn &net->ipv6.ip6_null_entry->dst;\n}\n\nstatic int fib6_rule_saddr(struct net *net, struct fib_rule *rule, int flags,\n\t\t\t   struct flowi6 *flp6, const struct net_device *dev)\n{\n\tstruct fib6_rule *r = (struct fib6_rule *)rule;\n\n\t \n\tif ((rule->flags & FIB_RULE_FIND_SADDR) &&\n\t    r->src.plen && !(flags & RT6_LOOKUP_F_HAS_SADDR)) {\n\t\tstruct in6_addr saddr;\n\n\t\tif (ipv6_dev_get_saddr(net, dev, &flp6->daddr,\n\t\t\t\t       rt6_flags2srcprefs(flags), &saddr))\n\t\t\treturn -EAGAIN;\n\n\t\tif (!ipv6_prefix_equal(&saddr, &r->src.addr, r->src.plen))\n\t\t\treturn -EAGAIN;\n\n\t\tflp6->saddr = saddr;\n\t}\n\n\treturn 0;\n}\n\nstatic int fib6_rule_action_alt(struct fib_rule *rule, struct flowi *flp,\n\t\t\t\tint flags, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct net *net = rule->fr_net;\n\tstruct fib6_table *table;\n\tint err, *oif;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\treturn -ENETUNREACH;\n\tcase FR_ACT_PROHIBIT:\n\t\treturn -EACCES;\n\tcase FR_ACT_BLACKHOLE:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table)\n\t\treturn -EAGAIN;\n\n\toif = (int *)arg->lookup_data;\n\terr = fib6_table_lookup(net, table, *oif, flp6, res, flags);\n\tif (!err && res->f6i != net->ipv6.fib6_null_entry)\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      res->nh->fib_nh_dev);\n\telse\n\t\terr = -EAGAIN;\n\n\treturn err;\n}\n\nstatic int __fib6_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t      int flags, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct flowi6 *flp6 = &flp->u.ip6;\n\tstruct rt6_info *rt = NULL;\n\tstruct fib6_table *table;\n\tstruct net *net = rule->fr_net;\n\tpol_lookup_t lookup = arg->lookup_ptr;\n\tint err = 0;\n\tu32 tb_id;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\terr = -ENETUNREACH;\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tgoto discard_pkt;\n\tdefault:\n\tcase FR_ACT_BLACKHOLE:\n\t\terr = -EINVAL;\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tgoto discard_pkt;\n\tcase FR_ACT_PROHIBIT:\n\t\terr = -EACCES;\n\t\trt = net->ipv6.ip6_prohibit_entry;\n\t\tgoto discard_pkt;\n\t}\n\n\ttb_id = fib_rule_get_table(rule, arg);\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table) {\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trt = pol_lookup_func(lookup,\n\t\t\t     net, table, flp6, arg->lookup_data, flags);\n\tif (rt != net->ipv6.ip6_null_entry) {\n\t\terr = fib6_rule_saddr(net, rule, flags, flp6,\n\t\t\t\t      ip6_dst_idev(&rt->dst)->dev);\n\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\n\t\terr = rt->dst.error;\n\t\tif (err != -EAGAIN)\n\t\t\tgoto out;\n\t}\nagain:\n\tip6_rt_put_flags(rt, flags);\n\terr = -EAGAIN;\n\trt = NULL;\n\tgoto out;\n\ndiscard_pkt:\n\tif (!(flags & RT6_LOOKUP_F_DST_NOREF))\n\t\tdst_hold(&rt->dst);\nout:\n\tres->rt6 = rt;\n\treturn err;\n}\n\nINDIRECT_CALLABLE_SCOPE int fib6_rule_action(struct fib_rule *rule,\n\t\t\t\t\t     struct flowi *flp, int flags,\n\t\t\t\t\t     struct fib_lookup_arg *arg)\n{\n\tif (arg->lookup_ptr == fib6_table_lookup)\n\t\treturn fib6_rule_action_alt(rule, flp, flags, arg);\n\n\treturn __fib6_rule_action(rule, flp, flags, arg);\n}\n\nINDIRECT_CALLABLE_SCOPE bool fib6_rule_suppress(struct fib_rule *rule,\n\t\t\t\t\t\tint flags,\n\t\t\t\t\t\tstruct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\n\tif (!rt)\n\t\treturn false;\n\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\n\t \n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\n\t \n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\n\treturn false;\n\nsuppress_route:\n\tip6_rt_put_flags(rt, flags);\n\treturn true;\n}\n\nINDIRECT_CALLABLE_SCOPE int fib6_rule_match(struct fib_rule *rule,\n\t\t\t\t\t    struct flowi *fl, int flags)\n{\n\tstruct fib6_rule *r = (struct fib6_rule *) rule;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\n\tif (r->dst.plen &&\n\t    !ipv6_prefix_equal(&fl6->daddr, &r->dst.addr, r->dst.plen))\n\t\treturn 0;\n\n\t \n\tif (r->src.plen) {\n\t\tif (flags & RT6_LOOKUP_F_HAS_SADDR) {\n\t\t\tif (!ipv6_prefix_equal(&fl6->saddr, &r->src.addr,\n\t\t\t\t\t       r->src.plen))\n\t\t\t\treturn 0;\n\t\t} else if (!(r->common.flags & FIB_RULE_FIND_SADDR))\n\t\t\treturn 0;\n\t}\n\n\tif (r->dscp && r->dscp != ip6_dscp(fl6->flowlabel))\n\t\treturn 0;\n\n\tif (rule->ip_proto && (rule->ip_proto != fl6->flowi6_proto))\n\t\treturn 0;\n\n\tif (fib_rule_port_range_set(&rule->sport_range) &&\n\t    !fib_rule_port_inrange(&rule->sport_range, fl6->fl6_sport))\n\t\treturn 0;\n\n\tif (fib_rule_port_range_set(&rule->dport_range) &&\n\t    !fib_rule_port_inrange(&rule->dport_range, fl6->fl6_dport))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int fib6_rule_configure(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t       struct fib_rule_hdr *frh,\n\t\t\t       struct nlattr **tb,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tint err = -EINVAL;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib6_rule *rule6 = (struct fib6_rule *) rule;\n\n\tif (!inet_validate_dscp(frh->tos)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid dsfield (tos): ECN bits must be 0\");\n\t\tgoto errout;\n\t}\n\trule6->dscp = inet_dsfield_to_dscp(frh->tos);\n\n\tif (rule->action == FR_ACT_TO_TBL && !rule->l3mdev) {\n\t\tif (rule->table == RT6_TABLE_UNSPEC) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid table\");\n\t\t\tgoto errout;\n\t\t}\n\n\t\tif (fib6_new_table(net, rule->table) == NULL) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tif (frh->src_len)\n\t\trule6->src.addr = nla_get_in6_addr(tb[FRA_SRC]);\n\n\tif (frh->dst_len)\n\t\trule6->dst.addr = nla_get_in6_addr(tb[FRA_DST]);\n\n\trule6->src.plen = frh->src_len;\n\trule6->dst.plen = frh->dst_len;\n\n\tif (fib_rule_requires_fldissect(rule))\n\t\tnet->ipv6.fib6_rules_require_fldissect++;\n\n\tnet->ipv6.fib6_has_custom_rules = true;\n\terr = 0;\nerrout:\n\treturn err;\n}\n\nstatic int fib6_rule_delete(struct fib_rule *rule)\n{\n\tstruct net *net = rule->fr_net;\n\n\tif (net->ipv6.fib6_rules_require_fldissect &&\n\t    fib_rule_requires_fldissect(rule))\n\t\tnet->ipv6.fib6_rules_require_fldissect--;\n\n\treturn 0;\n}\n\nstatic int fib6_rule_compare(struct fib_rule *rule, struct fib_rule_hdr *frh,\n\t\t\t     struct nlattr **tb)\n{\n\tstruct fib6_rule *rule6 = (struct fib6_rule *) rule;\n\n\tif (frh->src_len && (rule6->src.plen != frh->src_len))\n\t\treturn 0;\n\n\tif (frh->dst_len && (rule6->dst.plen != frh->dst_len))\n\t\treturn 0;\n\n\tif (frh->tos && inet_dscp_to_dsfield(rule6->dscp) != frh->tos)\n\t\treturn 0;\n\n\tif (frh->src_len &&\n\t    nla_memcmp(tb[FRA_SRC], &rule6->src.addr, sizeof(struct in6_addr)))\n\t\treturn 0;\n\n\tif (frh->dst_len &&\n\t    nla_memcmp(tb[FRA_DST], &rule6->dst.addr, sizeof(struct in6_addr)))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int fib6_rule_fill(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t  struct fib_rule_hdr *frh)\n{\n\tstruct fib6_rule *rule6 = (struct fib6_rule *) rule;\n\n\tfrh->dst_len = rule6->dst.plen;\n\tfrh->src_len = rule6->src.plen;\n\tfrh->tos = inet_dscp_to_dsfield(rule6->dscp);\n\n\tif ((rule6->dst.plen &&\n\t     nla_put_in6_addr(skb, FRA_DST, &rule6->dst.addr)) ||\n\t    (rule6->src.plen &&\n\t     nla_put_in6_addr(skb, FRA_SRC, &rule6->src.addr)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic size_t fib6_rule_nlmsg_payload(struct fib_rule *rule)\n{\n\treturn nla_total_size(16)  \n\t       + nla_total_size(16);  \n}\n\nstatic const struct fib_rules_ops __net_initconst fib6_rules_ops_template = {\n\t.family\t\t\t= AF_INET6,\n\t.rule_size\t\t= sizeof(struct fib6_rule),\n\t.addr_size\t\t= sizeof(struct in6_addr),\n\t.action\t\t\t= fib6_rule_action,\n\t.match\t\t\t= fib6_rule_match,\n\t.suppress\t\t= fib6_rule_suppress,\n\t.configure\t\t= fib6_rule_configure,\n\t.delete\t\t\t= fib6_rule_delete,\n\t.compare\t\t= fib6_rule_compare,\n\t.fill\t\t\t= fib6_rule_fill,\n\t.nlmsg_payload\t\t= fib6_rule_nlmsg_payload,\n\t.nlgroup\t\t= RTNLGRP_IPV6_RULE,\n\t.owner\t\t\t= THIS_MODULE,\n\t.fro_net\t\t= &init_net,\n};\n\nstatic int __net_init fib6_rules_net_init(struct net *net)\n{\n\tstruct fib_rules_ops *ops;\n\tint err;\n\n\tops = fib_rules_register(&fib6_rules_ops_template, net);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\terr = fib_default_rule_add(ops, 0, RT6_TABLE_LOCAL, 0);\n\tif (err)\n\t\tgoto out_fib6_rules_ops;\n\n\terr = fib_default_rule_add(ops, 0x7FFE, RT6_TABLE_MAIN, 0);\n\tif (err)\n\t\tgoto out_fib6_rules_ops;\n\n\tnet->ipv6.fib6_rules_ops = ops;\n\tnet->ipv6.fib6_rules_require_fldissect = 0;\nout:\n\treturn err;\n\nout_fib6_rules_ops:\n\tfib_rules_unregister(ops);\n\tgoto out;\n}\n\nstatic void __net_exit fib6_rules_net_exit_batch(struct list_head *net_list)\n{\n\tstruct net *net;\n\n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\tfib_rules_unregister(net->ipv6.fib6_rules_ops);\n\t\tcond_resched();\n\t}\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations fib6_rules_net_ops = {\n\t.init = fib6_rules_net_init,\n\t.exit_batch = fib6_rules_net_exit_batch,\n};\n\nint __init fib6_rules_init(void)\n{\n\treturn register_pernet_subsys(&fib6_rules_net_ops);\n}\n\n\nvoid fib6_rules_cleanup(void)\n{\n\tunregister_pernet_subsys(&fib6_rules_net_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}