{
  "module_name": "xfrm6_output.c",
  "hash_id": "4c18b0477de395d21a5fcee3a76a9d76e3e2dc19153f7845d2f8aa8ccdc318cb",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/xfrm6_output.c",
  "human_readable_source": "\n \n\n#include <linux/if_ether.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/icmpv6.h>\n#include <linux/netfilter_ipv6.h>\n#include <net/dst.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/xfrm.h>\n\nvoid xfrm6_local_rxpmtu(struct sk_buff *skb, u32 mtu)\n{\n\tstruct flowi6 fl6;\n\tstruct sock *sk = skb->sk;\n\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.daddr = ipv6_hdr(skb)->daddr;\n\n\tipv6_local_rxpmtu(sk, &fl6, mtu);\n}\n\nvoid xfrm6_local_error(struct sk_buff *skb, u32 mtu)\n{\n\tstruct flowi6 fl6;\n\tconst struct ipv6hdr *hdr;\n\tstruct sock *sk = skb->sk;\n\n\thdr = skb->encapsulation ? inner_ipv6_hdr(skb) : ipv6_hdr(skb);\n\tfl6.fl6_dport = inet_sk(sk)->inet_dport;\n\tfl6.daddr = hdr->daddr;\n\n\tipv6_local_error(sk, EMSGSIZE, &fl6, mtu);\n}\n\nstatic int __xfrm6_output_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\treturn xfrm_output(sk, skb);\n}\n\nstatic int xfrm6_noneed_fragment(struct sk_buff *skb)\n{\n\tstruct frag_hdr *fh;\n\tu8 prevhdr = ipv6_hdr(skb)->nexthdr;\n\n\tif (prevhdr != NEXTHDR_FRAGMENT)\n\t\treturn 0;\n\tfh = (struct frag_hdr *)(skb->data + sizeof(struct ipv6hdr));\n\tif (fh->nexthdr == NEXTHDR_ESP || fh->nexthdr == NEXTHDR_AUTH)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int __xfrm6_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct xfrm_state *x = dst->xfrm;\n\tunsigned int mtu;\n\tbool toobig;\n\n#ifdef CONFIG_NETFILTER\n\tif (!x) {\n\t\tIP6CB(skb)->flags |= IP6SKB_REROUTED;\n\t\treturn dst_output(net, sk, skb);\n\t}\n#endif\n\n\tif (x->props.mode != XFRM_MODE_TUNNEL)\n\t\tgoto skip_frag;\n\n\tif (skb->protocol == htons(ETH_P_IPV6))\n\t\tmtu = ip6_skb_dst_mtu(skb);\n\telse\n\t\tmtu = dst_mtu(skb_dst(skb));\n\n\ttoobig = skb->len > mtu && !skb_is_gso(skb);\n\n\tif (toobig && xfrm6_local_dontfrag(skb->sk)) {\n\t\txfrm6_local_rxpmtu(skb, mtu);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t} else if (toobig && xfrm6_noneed_fragment(skb)) {\n\t\tskb->ignore_df = 1;\n\t\tgoto skip_frag;\n\t} else if (!skb->ignore_df && toobig && skb->sk) {\n\t\txfrm_local_error(skb, mtu);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (toobig || dst_allfrag(skb_dst(skb)))\n\t\treturn ip6_fragment(net, sk, skb,\n\t\t\t\t    __xfrm6_output_finish);\n\nskip_frag:\n\treturn xfrm_output(sk, skb);\n}\n\nint xfrm6_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\treturn NF_HOOK_COND(NFPROTO_IPV6, NF_INET_POST_ROUTING,\n\t\t\t    net, sk, skb,  skb->dev, skb_dst(skb)->dev,\n\t\t\t    __xfrm6_output,\n\t\t\t    !(IP6CB(skb)->flags & IP6SKB_REROUTED));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}