{
  "module_name": "mcast.c",
  "hash_id": "f2cda0adacf5cadeb680ead46751d58a1b581472ea7ee53d7a41d337e4a1deec",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/mcast.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/jiffies.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/route.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/pkt_sched.h>\n#include <net/mld.h>\n#include <linux/workqueue.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/if_inet6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/inet_common.h>\n\n#include <net/ip6_checksum.h>\n\n \nstatic int __mld2_query_bugs[] __attribute__((__unused__)) = {\n\tBUILD_BUG_ON_ZERO(offsetof(struct mld2_query, mld2q_srcs) % 4),\n\tBUILD_BUG_ON_ZERO(offsetof(struct mld2_report, mld2r_grec) % 4),\n\tBUILD_BUG_ON_ZERO(offsetof(struct mld2_grec, grec_mca) % 4)\n};\n\nstatic struct workqueue_struct *mld_wq;\nstatic struct in6_addr mld2_all_mcr = MLD2_ALL_MCR_INIT;\n\nstatic void igmp6_join_group(struct ifmcaddr6 *ma);\nstatic void igmp6_leave_group(struct ifmcaddr6 *ma);\nstatic void mld_mca_work(struct work_struct *work);\n\nstatic void mld_ifc_event(struct inet6_dev *idev);\nstatic bool mld_in_v1_mode(const struct inet6_dev *idev);\nstatic int sf_setstate(struct ifmcaddr6 *pmc);\nstatic void sf_markstate(struct ifmcaddr6 *pmc);\nstatic void ip6_mc_clear_src(struct ifmcaddr6 *pmc);\nstatic int ip6_mc_del_src(struct inet6_dev *idev, const struct in6_addr *pmca,\n\t\t\t  int sfmode, int sfcount, const struct in6_addr *psfsrc,\n\t\t\t  int delta);\nstatic int ip6_mc_add_src(struct inet6_dev *idev, const struct in6_addr *pmca,\n\t\t\t  int sfmode, int sfcount, const struct in6_addr *psfsrc,\n\t\t\t  int delta);\nstatic int ip6_mc_leave_src(struct sock *sk, struct ipv6_mc_socklist *iml,\n\t\t\t    struct inet6_dev *idev);\nstatic int __ipv6_dev_mc_inc(struct net_device *dev,\n\t\t\t     const struct in6_addr *addr, unsigned int mode);\n\n#define MLD_QRV_DEFAULT\t\t2\n \n#define MLD_QI_DEFAULT\t\t(125 * HZ)\n \n#define MLD_QRI_DEFAULT\t\t(10 * HZ)\n\n \n#define MLD_V1_QUERY_LEN\t24\n#define MLD_V2_QUERY_LEN_MIN\t28\n\n#define IPV6_MLD_MAX_MSF\t64\n\nint sysctl_mld_max_msf __read_mostly = IPV6_MLD_MAX_MSF;\nint sysctl_mld_qrv __read_mostly = MLD_QRV_DEFAULT;\n\n \n#define mc_dereference(e, idev) \\\n\trcu_dereference_protected(e, lockdep_is_held(&(idev)->mc_lock))\n\n#define sock_dereference(e, sk) \\\n\trcu_dereference_protected(e, lockdep_sock_is_held(sk))\n\n#define for_each_pmc_socklock(np, sk, pmc)\t\t\t\\\n\tfor (pmc = sock_dereference((np)->ipv6_mc_list, sk);\t\\\n\t     pmc;\t\t\t\t\t\t\\\n\t     pmc = sock_dereference(pmc->next, sk))\n\n#define for_each_pmc_rcu(np, pmc)\t\t\t\t\\\n\tfor (pmc = rcu_dereference((np)->ipv6_mc_list);\t\t\\\n\t     pmc;\t\t\t\t\t\t\\\n\t     pmc = rcu_dereference(pmc->next))\n\n#define for_each_psf_mclock(mc, psf)\t\t\t\t\\\n\tfor (psf = mc_dereference((mc)->mca_sources, mc->idev);\t\\\n\t     psf;\t\t\t\t\t\t\\\n\t     psf = mc_dereference(psf->sf_next, mc->idev))\n\n#define for_each_psf_rcu(mc, psf)\t\t\t\t\\\n\tfor (psf = rcu_dereference((mc)->mca_sources);\t\t\\\n\t     psf;\t\t\t\t\t\t\\\n\t     psf = rcu_dereference(psf->sf_next))\n\n#define for_each_psf_tomb(mc, psf)\t\t\t\t\\\n\tfor (psf = mc_dereference((mc)->mca_tomb, mc->idev);\t\\\n\t     psf;\t\t\t\t\t\t\\\n\t     psf = mc_dereference(psf->sf_next, mc->idev))\n\n#define for_each_mc_mclock(idev, mc)\t\t\t\t\\\n\tfor (mc = mc_dereference((idev)->mc_list, idev);\t\\\n\t     mc;\t\t\t\t\t\t\\\n\t     mc = mc_dereference(mc->next, idev))\n\n#define for_each_mc_rcu(idev, mc)\t\t\t\t\\\n\tfor (mc = rcu_dereference((idev)->mc_list);             \\\n\t     mc;                                                \\\n\t     mc = rcu_dereference(mc->next))\n\n#define for_each_mc_tomb(idev, mc)\t\t\t\t\\\n\tfor (mc = mc_dereference((idev)->mc_tomb, idev);\t\\\n\t     mc;\t\t\t\t\t\t\\\n\t     mc = mc_dereference(mc->next, idev))\n\nstatic int unsolicited_report_interval(struct inet6_dev *idev)\n{\n\tint iv;\n\n\tif (mld_in_v1_mode(idev))\n\t\tiv = idev->cnf.mldv1_unsolicited_report_interval;\n\telse\n\t\tiv = idev->cnf.mldv2_unsolicited_report_interval;\n\n\treturn iv > 0 ? iv : 1;\n}\n\nstatic int __ipv6_sock_mc_join(struct sock *sk, int ifindex,\n\t\t\t       const struct in6_addr *addr, unsigned int mode)\n{\n\tstruct net_device *dev = NULL;\n\tstruct ipv6_mc_socklist *mc_lst;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint err;\n\n\tASSERT_RTNL();\n\n\tif (!ipv6_addr_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\tfor_each_pmc_socklock(np, sk, mc_lst) {\n\t\tif ((ifindex == 0 || mc_lst->ifindex == ifindex) &&\n\t\t    ipv6_addr_equal(&mc_lst->addr, addr))\n\t\t\treturn -EADDRINUSE;\n\t}\n\n\tmc_lst = sock_kmalloc(sk, sizeof(struct ipv6_mc_socklist), GFP_KERNEL);\n\n\tif (!mc_lst)\n\t\treturn -ENOMEM;\n\n\tmc_lst->next = NULL;\n\tmc_lst->addr = *addr;\n\n\tif (ifindex == 0) {\n\t\tstruct rt6_info *rt;\n\t\trt = rt6_lookup(net, addr, NULL, 0, NULL, 0);\n\t\tif (rt) {\n\t\t\tdev = rt->dst.dev;\n\t\t\tip6_rt_put(rt);\n\t\t}\n\t} else\n\t\tdev = __dev_get_by_index(net, ifindex);\n\n\tif (!dev) {\n\t\tsock_kfree_s(sk, mc_lst, sizeof(*mc_lst));\n\t\treturn -ENODEV;\n\t}\n\n\tmc_lst->ifindex = dev->ifindex;\n\tmc_lst->sfmode = mode;\n\tRCU_INIT_POINTER(mc_lst->sflist, NULL);\n\n\t \n\n\terr = __ipv6_dev_mc_inc(dev, addr, mode);\n\n\tif (err) {\n\t\tsock_kfree_s(sk, mc_lst, sizeof(*mc_lst));\n\t\treturn err;\n\t}\n\n\tmc_lst->next = np->ipv6_mc_list;\n\trcu_assign_pointer(np->ipv6_mc_list, mc_lst);\n\n\treturn 0;\n}\n\nint ipv6_sock_mc_join(struct sock *sk, int ifindex, const struct in6_addr *addr)\n{\n\treturn __ipv6_sock_mc_join(sk, ifindex, addr, MCAST_EXCLUDE);\n}\nEXPORT_SYMBOL(ipv6_sock_mc_join);\n\nint ipv6_sock_mc_join_ssm(struct sock *sk, int ifindex,\n\t\t\t  const struct in6_addr *addr, unsigned int mode)\n{\n\treturn __ipv6_sock_mc_join(sk, ifindex, addr, mode);\n}\n\n \nint ipv6_sock_mc_drop(struct sock *sk, int ifindex, const struct in6_addr *addr)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_mc_socklist *mc_lst;\n\tstruct ipv6_mc_socklist __rcu **lnk;\n\tstruct net *net = sock_net(sk);\n\n\tASSERT_RTNL();\n\n\tif (!ipv6_addr_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\tfor (lnk = &np->ipv6_mc_list;\n\t     (mc_lst = sock_dereference(*lnk, sk)) != NULL;\n\t      lnk = &mc_lst->next) {\n\t\tif ((ifindex == 0 || mc_lst->ifindex == ifindex) &&\n\t\t    ipv6_addr_equal(&mc_lst->addr, addr)) {\n\t\t\tstruct net_device *dev;\n\n\t\t\t*lnk = mc_lst->next;\n\n\t\t\tdev = __dev_get_by_index(net, mc_lst->ifindex);\n\t\t\tif (dev) {\n\t\t\t\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\n\t\t\t\tip6_mc_leave_src(sk, mc_lst, idev);\n\t\t\t\tif (idev)\n\t\t\t\t\t__ipv6_dev_mc_dec(idev, &mc_lst->addr);\n\t\t\t} else {\n\t\t\t\tip6_mc_leave_src(sk, mc_lst, NULL);\n\t\t\t}\n\n\t\t\tatomic_sub(sizeof(*mc_lst), &sk->sk_omem_alloc);\n\t\t\tkfree_rcu(mc_lst, rcu);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EADDRNOTAVAIL;\n}\nEXPORT_SYMBOL(ipv6_sock_mc_drop);\n\nstatic struct inet6_dev *ip6_mc_find_dev_rtnl(struct net *net,\n\t\t\t\t\t      const struct in6_addr *group,\n\t\t\t\t\t      int ifindex)\n{\n\tstruct net_device *dev = NULL;\n\tstruct inet6_dev *idev = NULL;\n\n\tif (ifindex == 0) {\n\t\tstruct rt6_info *rt = rt6_lookup(net, group, NULL, 0, NULL, 0);\n\n\t\tif (rt) {\n\t\t\tdev = rt->dst.dev;\n\t\t\tip6_rt_put(rt);\n\t\t}\n\t} else {\n\t\tdev = __dev_get_by_index(net, ifindex);\n\t}\n\n\tif (!dev)\n\t\treturn NULL;\n\tidev = __in6_dev_get(dev);\n\tif (!idev)\n\t\treturn NULL;\n\tif (idev->dead)\n\t\treturn NULL;\n\treturn idev;\n}\n\nvoid __ipv6_sock_mc_close(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_mc_socklist *mc_lst;\n\tstruct net *net = sock_net(sk);\n\n\tASSERT_RTNL();\n\n\twhile ((mc_lst = sock_dereference(np->ipv6_mc_list, sk)) != NULL) {\n\t\tstruct net_device *dev;\n\n\t\tnp->ipv6_mc_list = mc_lst->next;\n\n\t\tdev = __dev_get_by_index(net, mc_lst->ifindex);\n\t\tif (dev) {\n\t\t\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\n\t\t\tip6_mc_leave_src(sk, mc_lst, idev);\n\t\t\tif (idev)\n\t\t\t\t__ipv6_dev_mc_dec(idev, &mc_lst->addr);\n\t\t} else {\n\t\t\tip6_mc_leave_src(sk, mc_lst, NULL);\n\t\t}\n\n\t\tatomic_sub(sizeof(*mc_lst), &sk->sk_omem_alloc);\n\t\tkfree_rcu(mc_lst, rcu);\n\t}\n}\n\nvoid ipv6_sock_mc_close(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\tif (!rcu_access_pointer(np->ipv6_mc_list))\n\t\treturn;\n\n\trtnl_lock();\n\tlock_sock(sk);\n\t__ipv6_sock_mc_close(sk);\n\trelease_sock(sk);\n\trtnl_unlock();\n}\n\nint ip6_mc_source(int add, int omode, struct sock *sk,\n\tstruct group_source_req *pgsr)\n{\n\tstruct in6_addr *source, *group;\n\tstruct ipv6_mc_socklist *pmc;\n\tstruct inet6_dev *idev;\n\tstruct ipv6_pinfo *inet6 = inet6_sk(sk);\n\tstruct ip6_sf_socklist *psl;\n\tstruct net *net = sock_net(sk);\n\tint i, j, rv;\n\tint leavegroup = 0;\n\tint err;\n\n\tsource = &((struct sockaddr_in6 *)&pgsr->gsr_source)->sin6_addr;\n\tgroup = &((struct sockaddr_in6 *)&pgsr->gsr_group)->sin6_addr;\n\n\tif (!ipv6_addr_is_multicast(group))\n\t\treturn -EINVAL;\n\n\tidev = ip6_mc_find_dev_rtnl(net, group, pgsr->gsr_interface);\n\tif (!idev)\n\t\treturn -ENODEV;\n\n\terr = -EADDRNOTAVAIL;\n\n\tmutex_lock(&idev->mc_lock);\n\tfor_each_pmc_socklock(inet6, sk, pmc) {\n\t\tif (pgsr->gsr_interface && pmc->ifindex != pgsr->gsr_interface)\n\t\t\tcontinue;\n\t\tif (ipv6_addr_equal(&pmc->addr, group))\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\t\t \n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\t \n\tif (rcu_access_pointer(pmc->sflist)) {\n\t\tif (pmc->sfmode != omode) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t} else if (pmc->sfmode != omode) {\n\t\t \n\t\tip6_mc_add_src(idev, group, omode, 0, NULL, 0);\n\t\tip6_mc_del_src(idev, group, pmc->sfmode, 0, NULL, 0);\n\t\tpmc->sfmode = omode;\n\t}\n\n\tpsl = sock_dereference(pmc->sflist, sk);\n\tif (!add) {\n\t\tif (!psl)\n\t\t\tgoto done;\t \n\t\trv = !0;\n\t\tfor (i = 0; i < psl->sl_count; i++) {\n\t\t\trv = !ipv6_addr_equal(&psl->sl_addr[i], source);\n\t\t\tif (rv == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (rv)\t\t \n\t\t\tgoto done;\t \n\n\t\t \n\t\tif (psl->sl_count == 1 && omode == MCAST_INCLUDE) {\n\t\t\tleavegroup = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tip6_mc_del_src(idev, group, omode, 1, source, 1);\n\n\t\tfor (j = i+1; j < psl->sl_count; j++)\n\t\t\tpsl->sl_addr[j-1] = psl->sl_addr[j];\n\t\tpsl->sl_count--;\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\t \n\n\tif (psl && psl->sl_count >= sysctl_mld_max_msf) {\n\t\terr = -ENOBUFS;\n\t\tgoto done;\n\t}\n\tif (!psl || psl->sl_count == psl->sl_max) {\n\t\tstruct ip6_sf_socklist *newpsl;\n\t\tint count = IP6_SFBLOCK;\n\n\t\tif (psl)\n\t\t\tcount += psl->sl_max;\n\t\tnewpsl = sock_kmalloc(sk, struct_size(newpsl, sl_addr, count),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!newpsl) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto done;\n\t\t}\n\t\tnewpsl->sl_max = count;\n\t\tnewpsl->sl_count = count - IP6_SFBLOCK;\n\t\tif (psl) {\n\t\t\tfor (i = 0; i < psl->sl_count; i++)\n\t\t\t\tnewpsl->sl_addr[i] = psl->sl_addr[i];\n\t\t\tatomic_sub(struct_size(psl, sl_addr, psl->sl_max),\n\t\t\t\t   &sk->sk_omem_alloc);\n\t\t}\n\t\trcu_assign_pointer(pmc->sflist, newpsl);\n\t\tkfree_rcu(psl, rcu);\n\t\tpsl = newpsl;\n\t}\n\trv = 1;\t \n\tfor (i = 0; i < psl->sl_count; i++) {\n\t\trv = !ipv6_addr_equal(&psl->sl_addr[i], source);\n\t\tif (rv == 0)  \n\t\t\tgoto done;\n\t}\n\tfor (j = psl->sl_count-1; j >= i; j--)\n\t\tpsl->sl_addr[j+1] = psl->sl_addr[j];\n\tpsl->sl_addr[i] = *source;\n\tpsl->sl_count++;\n\terr = 0;\n\t \n\tip6_mc_add_src(idev, group, omode, 1, source, 1);\ndone:\n\tmutex_unlock(&idev->mc_lock);\n\tif (leavegroup)\n\t\terr = ipv6_sock_mc_drop(sk, pgsr->gsr_interface, group);\n\treturn err;\n}\n\nint ip6_mc_msfilter(struct sock *sk, struct group_filter *gsf,\n\t\t    struct sockaddr_storage *list)\n{\n\tconst struct in6_addr *group;\n\tstruct ipv6_mc_socklist *pmc;\n\tstruct inet6_dev *idev;\n\tstruct ipv6_pinfo *inet6 = inet6_sk(sk);\n\tstruct ip6_sf_socklist *newpsl, *psl;\n\tstruct net *net = sock_net(sk);\n\tint leavegroup = 0;\n\tint i, err;\n\n\tgroup = &((struct sockaddr_in6 *)&gsf->gf_group)->sin6_addr;\n\n\tif (!ipv6_addr_is_multicast(group))\n\t\treturn -EINVAL;\n\tif (gsf->gf_fmode != MCAST_INCLUDE &&\n\t    gsf->gf_fmode != MCAST_EXCLUDE)\n\t\treturn -EINVAL;\n\n\tidev = ip6_mc_find_dev_rtnl(net, group, gsf->gf_interface);\n\tif (!idev)\n\t\treturn -ENODEV;\n\n\terr = 0;\n\n\tif (gsf->gf_fmode == MCAST_INCLUDE && gsf->gf_numsrc == 0) {\n\t\tleavegroup = 1;\n\t\tgoto done;\n\t}\n\n\tfor_each_pmc_socklock(inet6, sk, pmc) {\n\t\tif (pmc->ifindex != gsf->gf_interface)\n\t\t\tcontinue;\n\t\tif (ipv6_addr_equal(&pmc->addr, group))\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\t\t \n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tif (gsf->gf_numsrc) {\n\t\tnewpsl = sock_kmalloc(sk, struct_size(newpsl, sl_addr,\n\t\t\t\t\t\t      gsf->gf_numsrc),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!newpsl) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto done;\n\t\t}\n\t\tnewpsl->sl_max = newpsl->sl_count = gsf->gf_numsrc;\n\t\tfor (i = 0; i < newpsl->sl_count; ++i, ++list) {\n\t\t\tstruct sockaddr_in6 *psin6;\n\n\t\t\tpsin6 = (struct sockaddr_in6 *)list;\n\t\t\tnewpsl->sl_addr[i] = psin6->sin6_addr;\n\t\t}\n\t\tmutex_lock(&idev->mc_lock);\n\t\terr = ip6_mc_add_src(idev, group, gsf->gf_fmode,\n\t\t\t\t     newpsl->sl_count, newpsl->sl_addr, 0);\n\t\tif (err) {\n\t\t\tmutex_unlock(&idev->mc_lock);\n\t\t\tsock_kfree_s(sk, newpsl, struct_size(newpsl, sl_addr,\n\t\t\t\t\t\t\t     newpsl->sl_max));\n\t\t\tgoto done;\n\t\t}\n\t\tmutex_unlock(&idev->mc_lock);\n\t} else {\n\t\tnewpsl = NULL;\n\t\tmutex_lock(&idev->mc_lock);\n\t\tip6_mc_add_src(idev, group, gsf->gf_fmode, 0, NULL, 0);\n\t\tmutex_unlock(&idev->mc_lock);\n\t}\n\n\tmutex_lock(&idev->mc_lock);\n\tpsl = sock_dereference(pmc->sflist, sk);\n\tif (psl) {\n\t\tip6_mc_del_src(idev, group, pmc->sfmode,\n\t\t\t       psl->sl_count, psl->sl_addr, 0);\n\t\tatomic_sub(struct_size(psl, sl_addr, psl->sl_max),\n\t\t\t   &sk->sk_omem_alloc);\n\t} else {\n\t\tip6_mc_del_src(idev, group, pmc->sfmode, 0, NULL, 0);\n\t}\n\trcu_assign_pointer(pmc->sflist, newpsl);\n\tmutex_unlock(&idev->mc_lock);\n\tkfree_rcu(psl, rcu);\n\tpmc->sfmode = gsf->gf_fmode;\n\terr = 0;\ndone:\n\tif (leavegroup)\n\t\terr = ipv6_sock_mc_drop(sk, gsf->gf_interface, group);\n\treturn err;\n}\n\nint ip6_mc_msfget(struct sock *sk, struct group_filter *gsf,\n\t\t  sockptr_t optval, size_t ss_offset)\n{\n\tstruct ipv6_pinfo *inet6 = inet6_sk(sk);\n\tconst struct in6_addr *group;\n\tstruct ipv6_mc_socklist *pmc;\n\tstruct ip6_sf_socklist *psl;\n\tint i, count, copycount;\n\n\tgroup = &((struct sockaddr_in6 *)&gsf->gf_group)->sin6_addr;\n\n\tif (!ipv6_addr_is_multicast(group))\n\t\treturn -EINVAL;\n\n\t \n\n\tfor_each_pmc_socklock(inet6, sk, pmc) {\n\t\tif (pmc->ifindex != gsf->gf_interface)\n\t\t\tcontinue;\n\t\tif (ipv6_addr_equal(group, &pmc->addr))\n\t\t\tbreak;\n\t}\n\tif (!pmc)\t\t \n\t\treturn -EADDRNOTAVAIL;\n\n\tgsf->gf_fmode = pmc->sfmode;\n\tpsl = sock_dereference(pmc->sflist, sk);\n\tcount = psl ? psl->sl_count : 0;\n\n\tcopycount = count < gsf->gf_numsrc ? count : gsf->gf_numsrc;\n\tgsf->gf_numsrc = count;\n\tfor (i = 0; i < copycount; i++) {\n\t\tstruct sockaddr_in6 *psin6;\n\t\tstruct sockaddr_storage ss;\n\n\t\tpsin6 = (struct sockaddr_in6 *)&ss;\n\t\tmemset(&ss, 0, sizeof(ss));\n\t\tpsin6->sin6_family = AF_INET6;\n\t\tpsin6->sin6_addr = psl->sl_addr[i];\n\t\tif (copy_to_sockptr_offset(optval, ss_offset, &ss, sizeof(ss)))\n\t\t\treturn -EFAULT;\n\t\tss_offset += sizeof(ss);\n\t}\n\treturn 0;\n}\n\nbool inet6_mc_check(const struct sock *sk, const struct in6_addr *mc_addr,\n\t\t    const struct in6_addr *src_addr)\n{\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tconst struct ipv6_mc_socklist *mc;\n\tconst struct ip6_sf_socklist *psl;\n\tbool rv = true;\n\n\trcu_read_lock();\n\tfor_each_pmc_rcu(np, mc) {\n\t\tif (ipv6_addr_equal(&mc->addr, mc_addr))\n\t\t\tbreak;\n\t}\n\tif (!mc) {\n\t\trcu_read_unlock();\n\t\treturn np->mc_all;\n\t}\n\tpsl = rcu_dereference(mc->sflist);\n\tif (!psl) {\n\t\trv = mc->sfmode == MCAST_EXCLUDE;\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < psl->sl_count; i++) {\n\t\t\tif (ipv6_addr_equal(&psl->sl_addr[i], src_addr))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (mc->sfmode == MCAST_INCLUDE && i >= psl->sl_count)\n\t\t\trv = false;\n\t\tif (mc->sfmode == MCAST_EXCLUDE && i < psl->sl_count)\n\t\t\trv = false;\n\t}\n\trcu_read_unlock();\n\n\treturn rv;\n}\n\n \nstatic void igmp6_group_added(struct ifmcaddr6 *mc)\n{\n\tstruct net_device *dev = mc->idev->dev;\n\tchar buf[MAX_ADDR_LEN];\n\n\tif (IPV6_ADDR_MC_SCOPE(&mc->mca_addr) <\n\t    IPV6_ADDR_SCOPE_LINKLOCAL)\n\t\treturn;\n\n\tif (!(mc->mca_flags&MAF_LOADED)) {\n\t\tmc->mca_flags |= MAF_LOADED;\n\t\tif (ndisc_mc_map(&mc->mca_addr, buf, dev, 0) == 0)\n\t\t\tdev_mc_add(dev, buf);\n\t}\n\n\tif (!(dev->flags & IFF_UP) || (mc->mca_flags & MAF_NOREPORT))\n\t\treturn;\n\n\tif (mld_in_v1_mode(mc->idev)) {\n\t\tigmp6_join_group(mc);\n\t\treturn;\n\t}\n\t \n\n\t \n\tif (mc->mca_sfmode == MCAST_EXCLUDE)\n\t\tmc->mca_crcount = mc->idev->mc_qrv;\n\n\tmld_ifc_event(mc->idev);\n}\n\n \nstatic void igmp6_group_dropped(struct ifmcaddr6 *mc)\n{\n\tstruct net_device *dev = mc->idev->dev;\n\tchar buf[MAX_ADDR_LEN];\n\n\tif (IPV6_ADDR_MC_SCOPE(&mc->mca_addr) <\n\t    IPV6_ADDR_SCOPE_LINKLOCAL)\n\t\treturn;\n\n\tif (mc->mca_flags&MAF_LOADED) {\n\t\tmc->mca_flags &= ~MAF_LOADED;\n\t\tif (ndisc_mc_map(&mc->mca_addr, buf, dev, 0) == 0)\n\t\t\tdev_mc_del(dev, buf);\n\t}\n\n\tif (mc->mca_flags & MAF_NOREPORT)\n\t\treturn;\n\n\tif (!mc->idev->dead)\n\t\tigmp6_leave_group(mc);\n\n\tif (cancel_delayed_work(&mc->mca_work))\n\t\trefcount_dec(&mc->mca_refcnt);\n}\n\n \nstatic void mld_add_delrec(struct inet6_dev *idev, struct ifmcaddr6 *im)\n{\n\tstruct ifmcaddr6 *pmc;\n\n\t \n\tpmc = kzalloc(sizeof(*pmc), GFP_KERNEL);\n\tif (!pmc)\n\t\treturn;\n\n\tpmc->idev = im->idev;\n\tin6_dev_hold(idev);\n\tpmc->mca_addr = im->mca_addr;\n\tpmc->mca_crcount = idev->mc_qrv;\n\tpmc->mca_sfmode = im->mca_sfmode;\n\tif (pmc->mca_sfmode == MCAST_INCLUDE) {\n\t\tstruct ip6_sf_list *psf;\n\n\t\trcu_assign_pointer(pmc->mca_tomb,\n\t\t\t\t   mc_dereference(im->mca_tomb, idev));\n\t\trcu_assign_pointer(pmc->mca_sources,\n\t\t\t\t   mc_dereference(im->mca_sources, idev));\n\t\tRCU_INIT_POINTER(im->mca_tomb, NULL);\n\t\tRCU_INIT_POINTER(im->mca_sources, NULL);\n\n\t\tfor_each_psf_mclock(pmc, psf)\n\t\t\tpsf->sf_crcount = pmc->mca_crcount;\n\t}\n\n\trcu_assign_pointer(pmc->next, idev->mc_tomb);\n\trcu_assign_pointer(idev->mc_tomb, pmc);\n}\n\n \nstatic void mld_del_delrec(struct inet6_dev *idev, struct ifmcaddr6 *im)\n{\n\tstruct ip6_sf_list *psf, *sources, *tomb;\n\tstruct in6_addr *pmca = &im->mca_addr;\n\tstruct ifmcaddr6 *pmc, *pmc_prev;\n\n\tpmc_prev = NULL;\n\tfor_each_mc_tomb(idev, pmc) {\n\t\tif (ipv6_addr_equal(&pmc->mca_addr, pmca))\n\t\t\tbreak;\n\t\tpmc_prev = pmc;\n\t}\n\tif (pmc) {\n\t\tif (pmc_prev)\n\t\t\trcu_assign_pointer(pmc_prev->next, pmc->next);\n\t\telse\n\t\t\trcu_assign_pointer(idev->mc_tomb, pmc->next);\n\t}\n\n\tif (pmc) {\n\t\tim->idev = pmc->idev;\n\t\tif (im->mca_sfmode == MCAST_INCLUDE) {\n\t\t\ttomb = rcu_replace_pointer(im->mca_tomb,\n\t\t\t\t\t\t   mc_dereference(pmc->mca_tomb, pmc->idev),\n\t\t\t\t\t\t   lockdep_is_held(&im->idev->mc_lock));\n\t\t\trcu_assign_pointer(pmc->mca_tomb, tomb);\n\n\t\t\tsources = rcu_replace_pointer(im->mca_sources,\n\t\t\t\t\t\t      mc_dereference(pmc->mca_sources, pmc->idev),\n\t\t\t\t\t\t      lockdep_is_held(&im->idev->mc_lock));\n\t\t\trcu_assign_pointer(pmc->mca_sources, sources);\n\t\t\tfor_each_psf_mclock(im, psf)\n\t\t\t\tpsf->sf_crcount = idev->mc_qrv;\n\t\t} else {\n\t\t\tim->mca_crcount = idev->mc_qrv;\n\t\t}\n\t\tin6_dev_put(pmc->idev);\n\t\tip6_mc_clear_src(pmc);\n\t\tkfree_rcu(pmc, rcu);\n\t}\n}\n\n \nstatic void mld_clear_delrec(struct inet6_dev *idev)\n{\n\tstruct ifmcaddr6 *pmc, *nextpmc;\n\n\tpmc = mc_dereference(idev->mc_tomb, idev);\n\tRCU_INIT_POINTER(idev->mc_tomb, NULL);\n\n\tfor (; pmc; pmc = nextpmc) {\n\t\tnextpmc = mc_dereference(pmc->next, idev);\n\t\tip6_mc_clear_src(pmc);\n\t\tin6_dev_put(pmc->idev);\n\t\tkfree_rcu(pmc, rcu);\n\t}\n\n\t \n\tfor_each_mc_mclock(idev, pmc) {\n\t\tstruct ip6_sf_list *psf, *psf_next;\n\n\t\tpsf = mc_dereference(pmc->mca_tomb, idev);\n\t\tRCU_INIT_POINTER(pmc->mca_tomb, NULL);\n\t\tfor (; psf; psf = psf_next) {\n\t\t\tpsf_next = mc_dereference(psf->sf_next, idev);\n\t\t\tkfree_rcu(psf, rcu);\n\t\t}\n\t}\n}\n\nstatic void mld_clear_query(struct inet6_dev *idev)\n{\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&idev->mc_query_lock);\n\twhile ((skb = __skb_dequeue(&idev->mc_query_queue)))\n\t\tkfree_skb(skb);\n\tspin_unlock_bh(&idev->mc_query_lock);\n}\n\nstatic void mld_clear_report(struct inet6_dev *idev)\n{\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&idev->mc_report_lock);\n\twhile ((skb = __skb_dequeue(&idev->mc_report_queue)))\n\t\tkfree_skb(skb);\n\tspin_unlock_bh(&idev->mc_report_lock);\n}\n\nstatic void mca_get(struct ifmcaddr6 *mc)\n{\n\trefcount_inc(&mc->mca_refcnt);\n}\n\nstatic void ma_put(struct ifmcaddr6 *mc)\n{\n\tif (refcount_dec_and_test(&mc->mca_refcnt)) {\n\t\tin6_dev_put(mc->idev);\n\t\tkfree_rcu(mc, rcu);\n\t}\n}\n\n \nstatic struct ifmcaddr6 *mca_alloc(struct inet6_dev *idev,\n\t\t\t\t   const struct in6_addr *addr,\n\t\t\t\t   unsigned int mode)\n{\n\tstruct ifmcaddr6 *mc;\n\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn NULL;\n\n\tINIT_DELAYED_WORK(&mc->mca_work, mld_mca_work);\n\n\tmc->mca_addr = *addr;\n\tmc->idev = idev;  \n\tmc->mca_users = 1;\n\t \n\tmc->mca_cstamp = mc->mca_tstamp = jiffies;\n\trefcount_set(&mc->mca_refcnt, 1);\n\n\tmc->mca_sfmode = mode;\n\tmc->mca_sfcount[mode] = 1;\n\n\tif (ipv6_addr_is_ll_all_nodes(&mc->mca_addr) ||\n\t    IPV6_ADDR_MC_SCOPE(&mc->mca_addr) < IPV6_ADDR_SCOPE_LINKLOCAL)\n\t\tmc->mca_flags |= MAF_NOREPORT;\n\n\treturn mc;\n}\n\n \nstatic int __ipv6_dev_mc_inc(struct net_device *dev,\n\t\t\t     const struct in6_addr *addr, unsigned int mode)\n{\n\tstruct ifmcaddr6 *mc;\n\tstruct inet6_dev *idev;\n\n\tASSERT_RTNL();\n\n\t \n\tidev = in6_dev_get(dev);\n\n\tif (!idev)\n\t\treturn -EINVAL;\n\n\tif (idev->dead) {\n\t\tin6_dev_put(idev);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&idev->mc_lock);\n\tfor_each_mc_mclock(idev, mc) {\n\t\tif (ipv6_addr_equal(&mc->mca_addr, addr)) {\n\t\t\tmc->mca_users++;\n\t\t\tip6_mc_add_src(idev, &mc->mca_addr, mode, 0, NULL, 0);\n\t\t\tmutex_unlock(&idev->mc_lock);\n\t\t\tin6_dev_put(idev);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmc = mca_alloc(idev, addr, mode);\n\tif (!mc) {\n\t\tmutex_unlock(&idev->mc_lock);\n\t\tin6_dev_put(idev);\n\t\treturn -ENOMEM;\n\t}\n\n\trcu_assign_pointer(mc->next, idev->mc_list);\n\trcu_assign_pointer(idev->mc_list, mc);\n\n\tmca_get(mc);\n\n\tmld_del_delrec(idev, mc);\n\tigmp6_group_added(mc);\n\tmutex_unlock(&idev->mc_lock);\n\tma_put(mc);\n\treturn 0;\n}\n\nint ipv6_dev_mc_inc(struct net_device *dev, const struct in6_addr *addr)\n{\n\treturn __ipv6_dev_mc_inc(dev, addr, MCAST_EXCLUDE);\n}\nEXPORT_SYMBOL(ipv6_dev_mc_inc);\n\n \nint __ipv6_dev_mc_dec(struct inet6_dev *idev, const struct in6_addr *addr)\n{\n\tstruct ifmcaddr6 *ma, __rcu **map;\n\n\tASSERT_RTNL();\n\n\tmutex_lock(&idev->mc_lock);\n\tfor (map = &idev->mc_list;\n\t     (ma = mc_dereference(*map, idev));\n\t     map = &ma->next) {\n\t\tif (ipv6_addr_equal(&ma->mca_addr, addr)) {\n\t\t\tif (--ma->mca_users == 0) {\n\t\t\t\t*map = ma->next;\n\n\t\t\t\tigmp6_group_dropped(ma);\n\t\t\t\tip6_mc_clear_src(ma);\n\t\t\t\tmutex_unlock(&idev->mc_lock);\n\n\t\t\t\tma_put(ma);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tmutex_unlock(&idev->mc_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmutex_unlock(&idev->mc_lock);\n\treturn -ENOENT;\n}\n\nint ipv6_dev_mc_dec(struct net_device *dev, const struct in6_addr *addr)\n{\n\tstruct inet6_dev *idev;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tidev = __in6_dev_get(dev);\n\tif (!idev)\n\t\terr = -ENODEV;\n\telse\n\t\terr = __ipv6_dev_mc_dec(idev, addr);\n\n\treturn err;\n}\nEXPORT_SYMBOL(ipv6_dev_mc_dec);\n\n \nbool ipv6_chk_mcast_addr(struct net_device *dev, const struct in6_addr *group,\n\t\t\t const struct in6_addr *src_addr)\n{\n\tstruct inet6_dev *idev;\n\tstruct ifmcaddr6 *mc;\n\tbool rv = false;\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(dev);\n\tif (idev) {\n\t\tfor_each_mc_rcu(idev, mc) {\n\t\t\tif (ipv6_addr_equal(&mc->mca_addr, group))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (mc) {\n\t\t\tif (src_addr && !ipv6_addr_any(src_addr)) {\n\t\t\t\tstruct ip6_sf_list *psf;\n\n\t\t\t\tfor_each_psf_rcu(mc, psf) {\n\t\t\t\t\tif (ipv6_addr_equal(&psf->sf_addr, src_addr))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (psf)\n\t\t\t\t\trv = psf->sf_count[MCAST_INCLUDE] ||\n\t\t\t\t\t\tpsf->sf_count[MCAST_EXCLUDE] !=\n\t\t\t\t\t\tmc->mca_sfcount[MCAST_EXCLUDE];\n\t\t\t\telse\n\t\t\t\t\trv = mc->mca_sfcount[MCAST_EXCLUDE] != 0;\n\t\t\t} else\n\t\t\t\trv = true;  \n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn rv;\n}\n\n \nstatic void mld_gq_start_work(struct inet6_dev *idev)\n{\n\tunsigned long tv = get_random_u32_below(idev->mc_maxdelay);\n\n\tidev->mc_gq_running = 1;\n\tif (!mod_delayed_work(mld_wq, &idev->mc_gq_work, tv + 2))\n\t\tin6_dev_hold(idev);\n}\n\n \nstatic void mld_gq_stop_work(struct inet6_dev *idev)\n{\n\tidev->mc_gq_running = 0;\n\tif (cancel_delayed_work(&idev->mc_gq_work))\n\t\t__in6_dev_put(idev);\n}\n\n \nstatic void mld_ifc_start_work(struct inet6_dev *idev, unsigned long delay)\n{\n\tunsigned long tv = get_random_u32_below(delay);\n\n\tif (!mod_delayed_work(mld_wq, &idev->mc_ifc_work, tv + 2))\n\t\tin6_dev_hold(idev);\n}\n\n \nstatic void mld_ifc_stop_work(struct inet6_dev *idev)\n{\n\tidev->mc_ifc_count = 0;\n\tif (cancel_delayed_work(&idev->mc_ifc_work))\n\t\t__in6_dev_put(idev);\n}\n\n \nstatic void mld_dad_start_work(struct inet6_dev *idev, unsigned long delay)\n{\n\tunsigned long tv = get_random_u32_below(delay);\n\n\tif (!mod_delayed_work(mld_wq, &idev->mc_dad_work, tv + 2))\n\t\tin6_dev_hold(idev);\n}\n\nstatic void mld_dad_stop_work(struct inet6_dev *idev)\n{\n\tif (cancel_delayed_work(&idev->mc_dad_work))\n\t\t__in6_dev_put(idev);\n}\n\nstatic void mld_query_stop_work(struct inet6_dev *idev)\n{\n\tspin_lock_bh(&idev->mc_query_lock);\n\tif (cancel_delayed_work(&idev->mc_query_work))\n\t\t__in6_dev_put(idev);\n\tspin_unlock_bh(&idev->mc_query_lock);\n}\n\nstatic void mld_report_stop_work(struct inet6_dev *idev)\n{\n\tif (cancel_delayed_work_sync(&idev->mc_report_work))\n\t\t__in6_dev_put(idev);\n}\n\n \nstatic void igmp6_group_queried(struct ifmcaddr6 *ma, unsigned long resptime)\n{\n\tunsigned long delay = resptime;\n\n\t \n\tif (ipv6_addr_is_ll_all_nodes(&ma->mca_addr) ||\n\t    IPV6_ADDR_MC_SCOPE(&ma->mca_addr) < IPV6_ADDR_SCOPE_LINKLOCAL)\n\t\treturn;\n\n\tif (cancel_delayed_work(&ma->mca_work)) {\n\t\trefcount_dec(&ma->mca_refcnt);\n\t\tdelay = ma->mca_work.timer.expires - jiffies;\n\t}\n\n\tif (delay >= resptime)\n\t\tdelay = get_random_u32_below(resptime);\n\n\tif (!mod_delayed_work(mld_wq, &ma->mca_work, delay))\n\t\trefcount_inc(&ma->mca_refcnt);\n\tma->mca_flags |= MAF_TIMER_RUNNING;\n}\n\n \nstatic bool mld_xmarksources(struct ifmcaddr6 *pmc, int nsrcs,\n\t\t\t     const struct in6_addr *srcs)\n{\n\tstruct ip6_sf_list *psf;\n\tint i, scount;\n\n\tscount = 0;\n\tfor_each_psf_mclock(pmc, psf) {\n\t\tif (scount == nsrcs)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nsrcs; i++) {\n\t\t\t \n\t\t\tif (psf->sf_count[MCAST_INCLUDE] ||\n\t\t\t    pmc->mca_sfcount[MCAST_EXCLUDE] !=\n\t\t\t    psf->sf_count[MCAST_EXCLUDE])\n\t\t\t\tbreak;\n\t\t\tif (ipv6_addr_equal(&srcs[i], &psf->sf_addr)) {\n\t\t\t\tscount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpmc->mca_flags &= ~MAF_GSQUERY;\n\tif (scount == nsrcs)\t \n\t\treturn false;\n\treturn true;\n}\n\n \nstatic bool mld_marksources(struct ifmcaddr6 *pmc, int nsrcs,\n\t\t\t    const struct in6_addr *srcs)\n{\n\tstruct ip6_sf_list *psf;\n\tint i, scount;\n\n\tif (pmc->mca_sfmode == MCAST_EXCLUDE)\n\t\treturn mld_xmarksources(pmc, nsrcs, srcs);\n\n\t \n\n\tscount = 0;\n\tfor_each_psf_mclock(pmc, psf) {\n\t\tif (scount == nsrcs)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nsrcs; i++) {\n\t\t\tif (ipv6_addr_equal(&srcs[i], &psf->sf_addr)) {\n\t\t\t\tpsf->sf_gsresp = 1;\n\t\t\t\tscount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!scount) {\n\t\tpmc->mca_flags &= ~MAF_GSQUERY;\n\t\treturn false;\n\t}\n\tpmc->mca_flags |= MAF_GSQUERY;\n\treturn true;\n}\n\nstatic int mld_force_mld_version(const struct inet6_dev *idev)\n{\n\t \n\n\tif (dev_net(idev->dev)->ipv6.devconf_all->force_mld_version != 0)\n\t\treturn dev_net(idev->dev)->ipv6.devconf_all->force_mld_version;\n\telse\n\t\treturn idev->cnf.force_mld_version;\n}\n\nstatic bool mld_in_v2_mode_only(const struct inet6_dev *idev)\n{\n\treturn mld_force_mld_version(idev) == 2;\n}\n\nstatic bool mld_in_v1_mode_only(const struct inet6_dev *idev)\n{\n\treturn mld_force_mld_version(idev) == 1;\n}\n\nstatic bool mld_in_v1_mode(const struct inet6_dev *idev)\n{\n\tif (mld_in_v2_mode_only(idev))\n\t\treturn false;\n\tif (mld_in_v1_mode_only(idev))\n\t\treturn true;\n\tif (idev->mc_v1_seen && time_before(jiffies, idev->mc_v1_seen))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void mld_set_v1_mode(struct inet6_dev *idev)\n{\n\t \n\tunsigned long switchback;\n\n\tswitchback = (idev->mc_qrv * idev->mc_qi) + idev->mc_qri;\n\n\tidev->mc_v1_seen = jiffies + switchback;\n}\n\nstatic void mld_update_qrv(struct inet6_dev *idev,\n\t\t\t   const struct mld2_query *mlh2)\n{\n\t \n\n\t \n\tconst int min_qrv = min(MLD_QRV_DEFAULT, sysctl_mld_qrv);\n\tWARN_ON(idev->mc_qrv == 0);\n\n\tif (mlh2->mld2q_qrv > 0)\n\t\tidev->mc_qrv = mlh2->mld2q_qrv;\n\n\tif (unlikely(idev->mc_qrv < min_qrv)) {\n\t\tnet_warn_ratelimited(\"IPv6: MLD: clamping QRV from %u to %u!\\n\",\n\t\t\t\t     idev->mc_qrv, min_qrv);\n\t\tidev->mc_qrv = min_qrv;\n\t}\n}\n\nstatic void mld_update_qi(struct inet6_dev *idev,\n\t\t\t  const struct mld2_query *mlh2)\n{\n\t \n\tunsigned long mc_qqi;\n\n\tif (mlh2->mld2q_qqic < 128) {\n\t\tmc_qqi = mlh2->mld2q_qqic;\n\t} else {\n\t\tunsigned long mc_man, mc_exp;\n\n\t\tmc_exp = MLDV2_QQIC_EXP(mlh2->mld2q_qqic);\n\t\tmc_man = MLDV2_QQIC_MAN(mlh2->mld2q_qqic);\n\n\t\tmc_qqi = (mc_man | 0x10) << (mc_exp + 3);\n\t}\n\n\tidev->mc_qi = mc_qqi * HZ;\n}\n\nstatic void mld_update_qri(struct inet6_dev *idev,\n\t\t\t   const struct mld2_query *mlh2)\n{\n\t \n\tidev->mc_qri = msecs_to_jiffies(mldv2_mrc(mlh2));\n}\n\nstatic int mld_process_v1(struct inet6_dev *idev, struct mld_msg *mld,\n\t\t\t  unsigned long *max_delay, bool v1_query)\n{\n\tunsigned long mldv1_md;\n\n\t \n\tif (mld_in_v2_mode_only(idev))\n\t\treturn -EINVAL;\n\n\tmldv1_md = ntohs(mld->mld_maxdelay);\n\n\t \n\tif (!v1_query)\n\t\tmldv1_md = min(mldv1_md, MLDV1_MRD_MAX_COMPAT);\n\n\t*max_delay = max(msecs_to_jiffies(mldv1_md), 1UL);\n\n\t \n\tif (v1_query)\n\t\tmld_set_v1_mode(idev);\n\n\t \n\tmld_gq_stop_work(idev);\n\t \n\tmld_ifc_stop_work(idev);\n\t \n\tmld_clear_delrec(idev);\n\n\treturn 0;\n}\n\nstatic void mld_process_v2(struct inet6_dev *idev, struct mld2_query *mld,\n\t\t\t   unsigned long *max_delay)\n{\n\t*max_delay = max(msecs_to_jiffies(mldv2_mrc(mld)), 1UL);\n\n\tmld_update_qrv(idev, mld);\n\tmld_update_qi(idev, mld);\n\tmld_update_qri(idev, mld);\n\n\tidev->mc_maxdelay = *max_delay;\n\n\treturn;\n}\n\n \nvoid igmp6_event_query(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev || idev->dead)\n\t\tgoto out;\n\n\tspin_lock_bh(&idev->mc_query_lock);\n\tif (skb_queue_len(&idev->mc_query_queue) < MLD_MAX_SKBS) {\n\t\t__skb_queue_tail(&idev->mc_query_queue, skb);\n\t\tif (!mod_delayed_work(mld_wq, &idev->mc_query_work, 0))\n\t\t\tin6_dev_hold(idev);\n\t\tskb = NULL;\n\t}\n\tspin_unlock_bh(&idev->mc_query_lock);\nout:\n\tkfree_skb(skb);\n}\n\nstatic void __mld_query_work(struct sk_buff *skb)\n{\n\tstruct mld2_query *mlh2 = NULL;\n\tconst struct in6_addr *group;\n\tunsigned long max_delay;\n\tstruct inet6_dev *idev;\n\tstruct ifmcaddr6 *ma;\n\tstruct mld_msg *mld;\n\tint group_type;\n\tint mark = 0;\n\tint len, err;\n\n\tif (!pskb_may_pull(skb, sizeof(struct in6_addr)))\n\t\tgoto kfree_skb;\n\n\t \n\tlen = ntohs(ipv6_hdr(skb)->payload_len) + sizeof(struct ipv6hdr);\n\tlen -= skb_network_header_len(skb);\n\n\t \n\tif (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL) ||\n\t    ipv6_hdr(skb)->hop_limit != 1 ||\n\t    !(IP6CB(skb)->flags & IP6SKB_ROUTERALERT) ||\n\t    IP6CB(skb)->ra != htons(IPV6_OPT_ROUTERALERT_MLD))\n\t\tgoto kfree_skb;\n\n\tidev = in6_dev_get(skb->dev);\n\tif (!idev)\n\t\tgoto kfree_skb;\n\n\tmld = (struct mld_msg *)icmp6_hdr(skb);\n\tgroup = &mld->mld_mca;\n\tgroup_type = ipv6_addr_type(group);\n\n\tif (group_type != IPV6_ADDR_ANY &&\n\t    !(group_type&IPV6_ADDR_MULTICAST))\n\t\tgoto out;\n\n\tif (len < MLD_V1_QUERY_LEN) {\n\t\tgoto out;\n\t} else if (len == MLD_V1_QUERY_LEN || mld_in_v1_mode(idev)) {\n\t\terr = mld_process_v1(idev, mld, &max_delay,\n\t\t\t\t     len == MLD_V1_QUERY_LEN);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else if (len >= MLD_V2_QUERY_LEN_MIN) {\n\t\tint srcs_offset = sizeof(struct mld2_query) -\n\t\t\t\t  sizeof(struct icmp6hdr);\n\n\t\tif (!pskb_may_pull(skb, srcs_offset))\n\t\t\tgoto out;\n\n\t\tmlh2 = (struct mld2_query *)skb_transport_header(skb);\n\n\t\tmld_process_v2(idev, mlh2, &max_delay);\n\n\t\tif (group_type == IPV6_ADDR_ANY) {  \n\t\t\tif (mlh2->mld2q_nsrcs)\n\t\t\t\tgoto out;  \n\n\t\t\tmld_gq_start_work(idev);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (mlh2->mld2q_nsrcs != 0) {\n\t\t\tif (!pskb_may_pull(skb, srcs_offset +\n\t\t\t    ntohs(mlh2->mld2q_nsrcs) * sizeof(struct in6_addr)))\n\t\t\t\tgoto out;\n\n\t\t\tmlh2 = (struct mld2_query *)skb_transport_header(skb);\n\t\t\tmark = 1;\n\t\t}\n\t} else {\n\t\tgoto out;\n\t}\n\n\tif (group_type == IPV6_ADDR_ANY) {\n\t\tfor_each_mc_mclock(idev, ma) {\n\t\t\tigmp6_group_queried(ma, max_delay);\n\t\t}\n\t} else {\n\t\tfor_each_mc_mclock(idev, ma) {\n\t\t\tif (!ipv6_addr_equal(group, &ma->mca_addr))\n\t\t\t\tcontinue;\n\t\t\tif (ma->mca_flags & MAF_TIMER_RUNNING) {\n\t\t\t\t \n\t\t\t\tif (!mark)\n\t\t\t\t\tma->mca_flags &= ~MAF_GSQUERY;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (mark)\n\t\t\t\t\tma->mca_flags |= MAF_GSQUERY;\n\t\t\t\telse\n\t\t\t\t\tma->mca_flags &= ~MAF_GSQUERY;\n\t\t\t}\n\t\t\tif (!(ma->mca_flags & MAF_GSQUERY) ||\n\t\t\t    mld_marksources(ma, ntohs(mlh2->mld2q_nsrcs), mlh2->mld2q_srcs))\n\t\t\t\tigmp6_group_queried(ma, max_delay);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tin6_dev_put(idev);\nkfree_skb:\n\tconsume_skb(skb);\n}\n\nstatic void mld_query_work(struct work_struct *work)\n{\n\tstruct inet6_dev *idev = container_of(to_delayed_work(work),\n\t\t\t\t\t      struct inet6_dev,\n\t\t\t\t\t      mc_query_work);\n\tstruct sk_buff_head q;\n\tstruct sk_buff *skb;\n\tbool rework = false;\n\tint cnt = 0;\n\n\tskb_queue_head_init(&q);\n\n\tspin_lock_bh(&idev->mc_query_lock);\n\twhile ((skb = __skb_dequeue(&idev->mc_query_queue))) {\n\t\t__skb_queue_tail(&q, skb);\n\n\t\tif (++cnt >= MLD_MAX_QUEUE) {\n\t\t\trework = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&idev->mc_query_lock);\n\n\tmutex_lock(&idev->mc_lock);\n\twhile ((skb = __skb_dequeue(&q)))\n\t\t__mld_query_work(skb);\n\tmutex_unlock(&idev->mc_lock);\n\n\tif (rework && queue_delayed_work(mld_wq, &idev->mc_query_work, 0))\n\t\treturn;\n\n\tin6_dev_put(idev);\n}\n\n \nvoid igmp6_event_report(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev || idev->dead)\n\t\tgoto out;\n\n\tspin_lock_bh(&idev->mc_report_lock);\n\tif (skb_queue_len(&idev->mc_report_queue) < MLD_MAX_SKBS) {\n\t\t__skb_queue_tail(&idev->mc_report_queue, skb);\n\t\tif (!mod_delayed_work(mld_wq, &idev->mc_report_work, 0))\n\t\t\tin6_dev_hold(idev);\n\t\tskb = NULL;\n\t}\n\tspin_unlock_bh(&idev->mc_report_lock);\nout:\n\tkfree_skb(skb);\n}\n\nstatic void __mld_report_work(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev;\n\tstruct ifmcaddr6 *ma;\n\tstruct mld_msg *mld;\n\tint addr_type;\n\n\t \n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto kfree_skb;\n\n\t \n\tif (skb->pkt_type != PACKET_MULTICAST &&\n\t    skb->pkt_type != PACKET_BROADCAST)\n\t\tgoto kfree_skb;\n\n\tif (!pskb_may_pull(skb, sizeof(*mld) - sizeof(struct icmp6hdr)))\n\t\tgoto kfree_skb;\n\n\tmld = (struct mld_msg *)icmp6_hdr(skb);\n\n\t \n\taddr_type = ipv6_addr_type(&ipv6_hdr(skb)->saddr);\n\tif (addr_type != IPV6_ADDR_ANY &&\n\t    !(addr_type&IPV6_ADDR_LINKLOCAL))\n\t\tgoto kfree_skb;\n\n\tidev = in6_dev_get(skb->dev);\n\tif (!idev)\n\t\tgoto kfree_skb;\n\n\t \n\n\tfor_each_mc_mclock(idev, ma) {\n\t\tif (ipv6_addr_equal(&ma->mca_addr, &mld->mld_mca)) {\n\t\t\tif (cancel_delayed_work(&ma->mca_work))\n\t\t\t\trefcount_dec(&ma->mca_refcnt);\n\t\t\tma->mca_flags &= ~(MAF_LAST_REPORTER |\n\t\t\t\t\t   MAF_TIMER_RUNNING);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tin6_dev_put(idev);\nkfree_skb:\n\tconsume_skb(skb);\n}\n\nstatic void mld_report_work(struct work_struct *work)\n{\n\tstruct inet6_dev *idev = container_of(to_delayed_work(work),\n\t\t\t\t\t      struct inet6_dev,\n\t\t\t\t\t      mc_report_work);\n\tstruct sk_buff_head q;\n\tstruct sk_buff *skb;\n\tbool rework = false;\n\tint cnt = 0;\n\n\tskb_queue_head_init(&q);\n\tspin_lock_bh(&idev->mc_report_lock);\n\twhile ((skb = __skb_dequeue(&idev->mc_report_queue))) {\n\t\t__skb_queue_tail(&q, skb);\n\n\t\tif (++cnt >= MLD_MAX_QUEUE) {\n\t\t\trework = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&idev->mc_report_lock);\n\n\tmutex_lock(&idev->mc_lock);\n\twhile ((skb = __skb_dequeue(&q)))\n\t\t__mld_report_work(skb);\n\tmutex_unlock(&idev->mc_lock);\n\n\tif (rework && queue_delayed_work(mld_wq, &idev->mc_report_work, 0))\n\t\treturn;\n\n\tin6_dev_put(idev);\n}\n\nstatic bool is_in(struct ifmcaddr6 *pmc, struct ip6_sf_list *psf, int type,\n\t\t  int gdeleted, int sdeleted)\n{\n\tswitch (type) {\n\tcase MLD2_MODE_IS_INCLUDE:\n\tcase MLD2_MODE_IS_EXCLUDE:\n\t\tif (gdeleted || sdeleted)\n\t\t\treturn false;\n\t\tif (!((pmc->mca_flags & MAF_GSQUERY) && !psf->sf_gsresp)) {\n\t\t\tif (pmc->mca_sfmode == MCAST_INCLUDE)\n\t\t\t\treturn true;\n\t\t\t \n\t\t\tif (psf->sf_count[MCAST_INCLUDE])\n\t\t\t\treturn type == MLD2_MODE_IS_INCLUDE;\n\t\t\treturn pmc->mca_sfcount[MCAST_EXCLUDE] ==\n\t\t\t\tpsf->sf_count[MCAST_EXCLUDE];\n\t\t}\n\t\treturn false;\n\tcase MLD2_CHANGE_TO_INCLUDE:\n\t\tif (gdeleted || sdeleted)\n\t\t\treturn false;\n\t\treturn psf->sf_count[MCAST_INCLUDE] != 0;\n\tcase MLD2_CHANGE_TO_EXCLUDE:\n\t\tif (gdeleted || sdeleted)\n\t\t\treturn false;\n\t\tif (pmc->mca_sfcount[MCAST_EXCLUDE] == 0 ||\n\t\t    psf->sf_count[MCAST_INCLUDE])\n\t\t\treturn false;\n\t\treturn pmc->mca_sfcount[MCAST_EXCLUDE] ==\n\t\t\tpsf->sf_count[MCAST_EXCLUDE];\n\tcase MLD2_ALLOW_NEW_SOURCES:\n\t\tif (gdeleted || !psf->sf_crcount)\n\t\t\treturn false;\n\t\treturn (pmc->mca_sfmode == MCAST_INCLUDE) ^ sdeleted;\n\tcase MLD2_BLOCK_OLD_SOURCES:\n\t\tif (pmc->mca_sfmode == MCAST_INCLUDE)\n\t\t\treturn gdeleted || (psf->sf_crcount && sdeleted);\n\t\treturn psf->sf_crcount && !gdeleted && !sdeleted;\n\t}\n\treturn false;\n}\n\nstatic int\nmld_scount(struct ifmcaddr6 *pmc, int type, int gdeleted, int sdeleted)\n{\n\tstruct ip6_sf_list *psf;\n\tint scount = 0;\n\n\tfor_each_psf_mclock(pmc, psf) {\n\t\tif (!is_in(pmc, psf, type, gdeleted, sdeleted))\n\t\t\tcontinue;\n\t\tscount++;\n\t}\n\treturn scount;\n}\n\nstatic void ip6_mc_hdr(const struct sock *sk, struct sk_buff *skb,\n\t\t       struct net_device *dev, const struct in6_addr *saddr,\n\t\t       const struct in6_addr *daddr, int proto, int len)\n{\n\tstruct ipv6hdr *hdr;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->dev = dev;\n\n\tskb_reset_network_header(skb);\n\tskb_put(skb, sizeof(struct ipv6hdr));\n\thdr = ipv6_hdr(skb);\n\n\tip6_flow_hdr(hdr, 0, 0);\n\n\thdr->payload_len = htons(len);\n\thdr->nexthdr = proto;\n\thdr->hop_limit = inet6_sk(sk)->hop_limit;\n\n\thdr->saddr = *saddr;\n\thdr->daddr = *daddr;\n}\n\nstatic struct sk_buff *mld_newpack(struct inet6_dev *idev, unsigned int mtu)\n{\n\tu8 ra[8] = { IPPROTO_ICMPV6, 0, IPV6_TLV_ROUTERALERT,\n\t\t     2, 0, 0, IPV6_TLV_PADN, 0 };\n\tstruct net_device *dev = idev->dev;\n\tint hlen = LL_RESERVED_SPACE(dev);\n\tint tlen = dev->needed_tailroom;\n\tstruct net *net = dev_net(dev);\n\tconst struct in6_addr *saddr;\n\tstruct in6_addr addr_buf;\n\tstruct mld2_report *pmr;\n\tstruct sk_buff *skb;\n\tunsigned int size;\n\tstruct sock *sk;\n\tint err;\n\n\tsk = net->ipv6.igmp_sk;\n\t \n\tsize = min_t(int, mtu, PAGE_SIZE / 2) + hlen + tlen;\n\tskb = sock_alloc_send_skb(sk, size, 1, &err);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb_reserve(skb, hlen);\n\tskb_tailroom_reserve(skb, mtu, tlen);\n\n\tif (ipv6_get_lladdr(dev, &addr_buf, IFA_F_TENTATIVE)) {\n\t\t \n\t\tsaddr = &in6addr_any;\n\t} else\n\t\tsaddr = &addr_buf;\n\n\tip6_mc_hdr(sk, skb, dev, saddr, &mld2_all_mcr, NEXTHDR_HOP, 0);\n\n\tskb_put_data(skb, ra, sizeof(ra));\n\n\tskb_set_transport_header(skb, skb_tail_pointer(skb) - skb->data);\n\tskb_put(skb, sizeof(*pmr));\n\tpmr = (struct mld2_report *)skb_transport_header(skb);\n\tpmr->mld2r_type = ICMPV6_MLD2_REPORT;\n\tpmr->mld2r_resv1 = 0;\n\tpmr->mld2r_cksum = 0;\n\tpmr->mld2r_resv2 = 0;\n\tpmr->mld2r_ngrec = 0;\n\treturn skb;\n}\n\nstatic void mld_sendpack(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *pip6 = ipv6_hdr(skb);\n\tstruct mld2_report *pmr =\n\t\t\t      (struct mld2_report *)skb_transport_header(skb);\n\tint payload_len, mldlen;\n\tstruct inet6_dev *idev;\n\tstruct net *net = dev_net(skb->dev);\n\tint err;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(skb->dev);\n\tIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUT, skb->len);\n\n\tpayload_len = (skb_tail_pointer(skb) - skb_network_header(skb)) -\n\t\tsizeof(*pip6);\n\tmldlen = skb_tail_pointer(skb) - skb_transport_header(skb);\n\tpip6->payload_len = htons(payload_len);\n\n\tpmr->mld2r_cksum = csum_ipv6_magic(&pip6->saddr, &pip6->daddr, mldlen,\n\t\t\t\t\t   IPPROTO_ICMPV6,\n\t\t\t\t\t   csum_partial(skb_transport_header(skb),\n\t\t\t\t\t\t\tmldlen, 0));\n\n\ticmpv6_flow_init(net->ipv6.igmp_sk, &fl6, ICMPV6_MLD2_REPORT,\n\t\t\t &ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr,\n\t\t\t skb->dev->ifindex);\n\tdst = icmp6_dst_alloc(skb->dev, &fl6);\n\n\terr = 0;\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t}\n\tskb_dst_set(skb, dst);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,\n\t\t      net, net->ipv6.igmp_sk, skb, NULL, skb->dev,\n\t\t      dst_output);\nout:\n\tif (!err) {\n\t\tICMP6MSGOUT_INC_STATS(net, idev, ICMPV6_MLD2_REPORT);\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);\n\t} else {\n\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);\n\t}\n\n\trcu_read_unlock();\n\treturn;\n\nerr_out:\n\tkfree_skb(skb);\n\tgoto out;\n}\n\nstatic int grec_size(struct ifmcaddr6 *pmc, int type, int gdel, int sdel)\n{\n\treturn sizeof(struct mld2_grec) + 16 * mld_scount(pmc,type,gdel,sdel);\n}\n\nstatic struct sk_buff *add_grhead(struct sk_buff *skb, struct ifmcaddr6 *pmc,\n\tint type, struct mld2_grec **ppgr, unsigned int mtu)\n{\n\tstruct mld2_report *pmr;\n\tstruct mld2_grec *pgr;\n\n\tif (!skb) {\n\t\tskb = mld_newpack(pmc->idev, mtu);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t}\n\tpgr = skb_put(skb, sizeof(struct mld2_grec));\n\tpgr->grec_type = type;\n\tpgr->grec_auxwords = 0;\n\tpgr->grec_nsrcs = 0;\n\tpgr->grec_mca = pmc->mca_addr;\t \n\tpmr = (struct mld2_report *)skb_transport_header(skb);\n\tpmr->mld2r_ngrec = htons(ntohs(pmr->mld2r_ngrec)+1);\n\t*ppgr = pgr;\n\treturn skb;\n}\n\n#define AVAILABLE(skb)\t((skb) ? skb_availroom(skb) : 0)\n\n \nstatic struct sk_buff *add_grec(struct sk_buff *skb, struct ifmcaddr6 *pmc,\n\t\t\t\tint type, int gdeleted, int sdeleted,\n\t\t\t\tint crsend)\n{\n\tstruct ip6_sf_list *psf, *psf_prev, *psf_next;\n\tint scount, stotal, first, isquery, truncate;\n\tstruct ip6_sf_list __rcu **psf_list;\n\tstruct inet6_dev *idev = pmc->idev;\n\tstruct net_device *dev = idev->dev;\n\tstruct mld2_grec *pgr = NULL;\n\tstruct mld2_report *pmr;\n\tunsigned int mtu;\n\n\tif (pmc->mca_flags & MAF_NOREPORT)\n\t\treturn skb;\n\n\tmtu = READ_ONCE(dev->mtu);\n\tif (mtu < IPV6_MIN_MTU)\n\t\treturn skb;\n\n\tisquery = type == MLD2_MODE_IS_INCLUDE ||\n\t\t  type == MLD2_MODE_IS_EXCLUDE;\n\ttruncate = type == MLD2_MODE_IS_EXCLUDE ||\n\t\t    type == MLD2_CHANGE_TO_EXCLUDE;\n\n\tstotal = scount = 0;\n\n\tpsf_list = sdeleted ? &pmc->mca_tomb : &pmc->mca_sources;\n\n\tif (!rcu_access_pointer(*psf_list))\n\t\tgoto empty_source;\n\n\tpmr = skb ? (struct mld2_report *)skb_transport_header(skb) : NULL;\n\n\t \n\tif (truncate) {\n\t\tif (pmr && pmr->mld2r_ngrec &&\n\t\t    AVAILABLE(skb) < grec_size(pmc, type, gdeleted, sdeleted)) {\n\t\t\tif (skb)\n\t\t\t\tmld_sendpack(skb);\n\t\t\tskb = mld_newpack(idev, mtu);\n\t\t}\n\t}\n\tfirst = 1;\n\tpsf_prev = NULL;\n\tfor (psf = mc_dereference(*psf_list, idev);\n\t     psf;\n\t     psf = psf_next) {\n\t\tstruct in6_addr *psrc;\n\n\t\tpsf_next = mc_dereference(psf->sf_next, idev);\n\n\t\tif (!is_in(pmc, psf, type, gdeleted, sdeleted) && !crsend) {\n\t\t\tpsf_prev = psf;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (((gdeleted && pmc->mca_sfmode == MCAST_EXCLUDE) ||\n\t\t     (!gdeleted && pmc->mca_crcount)) &&\n\t\t    (type == MLD2_ALLOW_NEW_SOURCES ||\n\t\t     type == MLD2_BLOCK_OLD_SOURCES) && psf->sf_crcount)\n\t\t\tgoto decrease_sf_crcount;\n\n\t\t \n\t\tif (isquery)\n\t\t\tpsf->sf_gsresp = 0;\n\n\t\tif (AVAILABLE(skb) < sizeof(*psrc) +\n\t\t    first*sizeof(struct mld2_grec)) {\n\t\t\tif (truncate && !first)\n\t\t\t\tbreak;\t  \n\t\t\tif (pgr)\n\t\t\t\tpgr->grec_nsrcs = htons(scount);\n\t\t\tif (skb)\n\t\t\t\tmld_sendpack(skb);\n\t\t\tskb = mld_newpack(idev, mtu);\n\t\t\tfirst = 1;\n\t\t\tscount = 0;\n\t\t}\n\t\tif (first) {\n\t\t\tskb = add_grhead(skb, pmc, type, &pgr, mtu);\n\t\t\tfirst = 0;\n\t\t}\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t\tpsrc = skb_put(skb, sizeof(*psrc));\n\t\t*psrc = psf->sf_addr;\n\t\tscount++; stotal++;\n\t\tif ((type == MLD2_ALLOW_NEW_SOURCES ||\n\t\t     type == MLD2_BLOCK_OLD_SOURCES) && psf->sf_crcount) {\ndecrease_sf_crcount:\n\t\t\tpsf->sf_crcount--;\n\t\t\tif ((sdeleted || gdeleted) && psf->sf_crcount == 0) {\n\t\t\t\tif (psf_prev)\n\t\t\t\t\trcu_assign_pointer(psf_prev->sf_next,\n\t\t\t\t\t\t\t   mc_dereference(psf->sf_next, idev));\n\t\t\t\telse\n\t\t\t\t\trcu_assign_pointer(*psf_list,\n\t\t\t\t\t\t\t   mc_dereference(psf->sf_next, idev));\n\t\t\t\tkfree_rcu(psf, rcu);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tpsf_prev = psf;\n\t}\n\nempty_source:\n\tif (!stotal) {\n\t\tif (type == MLD2_ALLOW_NEW_SOURCES ||\n\t\t    type == MLD2_BLOCK_OLD_SOURCES)\n\t\t\treturn skb;\n\t\tif (pmc->mca_crcount || isquery || crsend) {\n\t\t\t \n\t\t\tif (skb && AVAILABLE(skb) < sizeof(struct mld2_grec)) {\n\t\t\t\tmld_sendpack(skb);\n\t\t\t\tskb = NULL;  \n\t\t\t}\n\t\t\tskb = add_grhead(skb, pmc, type, &pgr, mtu);\n\t\t}\n\t}\n\tif (pgr)\n\t\tpgr->grec_nsrcs = htons(scount);\n\n\tif (isquery)\n\t\tpmc->mca_flags &= ~MAF_GSQUERY;\t \n\treturn skb;\n}\n\n \nstatic void mld_send_report(struct inet6_dev *idev, struct ifmcaddr6 *pmc)\n{\n\tstruct sk_buff *skb = NULL;\n\tint type;\n\n\tif (!pmc) {\n\t\tfor_each_mc_mclock(idev, pmc) {\n\t\t\tif (pmc->mca_flags & MAF_NOREPORT)\n\t\t\t\tcontinue;\n\t\t\tif (pmc->mca_sfcount[MCAST_EXCLUDE])\n\t\t\t\ttype = MLD2_MODE_IS_EXCLUDE;\n\t\t\telse\n\t\t\t\ttype = MLD2_MODE_IS_INCLUDE;\n\t\t\tskb = add_grec(skb, pmc, type, 0, 0, 0);\n\t\t}\n\t} else {\n\t\tif (pmc->mca_sfcount[MCAST_EXCLUDE])\n\t\t\ttype = MLD2_MODE_IS_EXCLUDE;\n\t\telse\n\t\t\ttype = MLD2_MODE_IS_INCLUDE;\n\t\tskb = add_grec(skb, pmc, type, 0, 0, 0);\n\t}\n\tif (skb)\n\t\tmld_sendpack(skb);\n}\n\n \nstatic void mld_clear_zeros(struct ip6_sf_list __rcu **ppsf, struct inet6_dev *idev)\n{\n\tstruct ip6_sf_list *psf_prev, *psf_next, *psf;\n\n\tpsf_prev = NULL;\n\tfor (psf = mc_dereference(*ppsf, idev);\n\t     psf;\n\t     psf = psf_next) {\n\t\tpsf_next = mc_dereference(psf->sf_next, idev);\n\t\tif (psf->sf_crcount == 0) {\n\t\t\tif (psf_prev)\n\t\t\t\trcu_assign_pointer(psf_prev->sf_next,\n\t\t\t\t\t\t   mc_dereference(psf->sf_next, idev));\n\t\t\telse\n\t\t\t\trcu_assign_pointer(*ppsf,\n\t\t\t\t\t\t   mc_dereference(psf->sf_next, idev));\n\t\t\tkfree_rcu(psf, rcu);\n\t\t} else {\n\t\t\tpsf_prev = psf;\n\t\t}\n\t}\n}\n\n \nstatic void mld_send_cr(struct inet6_dev *idev)\n{\n\tstruct ifmcaddr6 *pmc, *pmc_prev, *pmc_next;\n\tstruct sk_buff *skb = NULL;\n\tint type, dtype;\n\n\t \n\tpmc_prev = NULL;\n\tfor (pmc = mc_dereference(idev->mc_tomb, idev);\n\t     pmc;\n\t     pmc = pmc_next) {\n\t\tpmc_next = mc_dereference(pmc->next, idev);\n\t\tif (pmc->mca_sfmode == MCAST_INCLUDE) {\n\t\t\ttype = MLD2_BLOCK_OLD_SOURCES;\n\t\t\tdtype = MLD2_BLOCK_OLD_SOURCES;\n\t\t\tskb = add_grec(skb, pmc, type, 1, 0, 0);\n\t\t\tskb = add_grec(skb, pmc, dtype, 1, 1, 0);\n\t\t}\n\t\tif (pmc->mca_crcount) {\n\t\t\tif (pmc->mca_sfmode == MCAST_EXCLUDE) {\n\t\t\t\ttype = MLD2_CHANGE_TO_INCLUDE;\n\t\t\t\tskb = add_grec(skb, pmc, type, 1, 0, 0);\n\t\t\t}\n\t\t\tpmc->mca_crcount--;\n\t\t\tif (pmc->mca_crcount == 0) {\n\t\t\t\tmld_clear_zeros(&pmc->mca_tomb, idev);\n\t\t\t\tmld_clear_zeros(&pmc->mca_sources, idev);\n\t\t\t}\n\t\t}\n\t\tif (pmc->mca_crcount == 0 &&\n\t\t    !rcu_access_pointer(pmc->mca_tomb) &&\n\t\t    !rcu_access_pointer(pmc->mca_sources)) {\n\t\t\tif (pmc_prev)\n\t\t\t\trcu_assign_pointer(pmc_prev->next, pmc_next);\n\t\t\telse\n\t\t\t\trcu_assign_pointer(idev->mc_tomb, pmc_next);\n\t\t\tin6_dev_put(pmc->idev);\n\t\t\tkfree_rcu(pmc, rcu);\n\t\t} else\n\t\t\tpmc_prev = pmc;\n\t}\n\n\t \n\tfor_each_mc_mclock(idev, pmc) {\n\t\tif (pmc->mca_sfcount[MCAST_EXCLUDE]) {\n\t\t\ttype = MLD2_BLOCK_OLD_SOURCES;\n\t\t\tdtype = MLD2_ALLOW_NEW_SOURCES;\n\t\t} else {\n\t\t\ttype = MLD2_ALLOW_NEW_SOURCES;\n\t\t\tdtype = MLD2_BLOCK_OLD_SOURCES;\n\t\t}\n\t\tskb = add_grec(skb, pmc, type, 0, 0, 0);\n\t\tskb = add_grec(skb, pmc, dtype, 0, 1, 0);\t \n\n\t\t \n\t\tif (pmc->mca_crcount) {\n\t\t\tif (pmc->mca_sfmode == MCAST_EXCLUDE)\n\t\t\t\ttype = MLD2_CHANGE_TO_EXCLUDE;\n\t\t\telse\n\t\t\t\ttype = MLD2_CHANGE_TO_INCLUDE;\n\t\t\tskb = add_grec(skb, pmc, type, 0, 0, 0);\n\t\t\tpmc->mca_crcount--;\n\t\t}\n\t}\n\tif (!skb)\n\t\treturn;\n\t(void) mld_sendpack(skb);\n}\n\nstatic void igmp6_send(struct in6_addr *addr, struct net_device *dev, int type)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sock *sk = net->ipv6.igmp_sk;\n\tstruct inet6_dev *idev;\n\tstruct sk_buff *skb;\n\tstruct mld_msg *hdr;\n\tconst struct in6_addr *snd_addr, *saddr;\n\tstruct in6_addr addr_buf;\n\tint hlen = LL_RESERVED_SPACE(dev);\n\tint tlen = dev->needed_tailroom;\n\tint err, len, payload_len, full_len;\n\tu8 ra[8] = { IPPROTO_ICMPV6, 0,\n\t\t     IPV6_TLV_ROUTERALERT, 2, 0, 0,\n\t\t     IPV6_TLV_PADN, 0 };\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\n\tif (type == ICMPV6_MGM_REDUCTION)\n\t\tsnd_addr = &in6addr_linklocal_allrouters;\n\telse\n\t\tsnd_addr = addr;\n\n\tlen = sizeof(struct icmp6hdr) + sizeof(struct in6_addr);\n\tpayload_len = len + sizeof(ra);\n\tfull_len = sizeof(struct ipv6hdr) + payload_len;\n\n\trcu_read_lock();\n\tIP6_UPD_PO_STATS(net, __in6_dev_get(dev),\n\t\t      IPSTATS_MIB_OUT, full_len);\n\trcu_read_unlock();\n\n\tskb = sock_alloc_send_skb(sk, hlen + tlen + full_len, 1, &err);\n\n\tif (!skb) {\n\t\trcu_read_lock();\n\t\tIP6_INC_STATS(net, __in6_dev_get(dev),\n\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb_reserve(skb, hlen);\n\n\tif (ipv6_get_lladdr(dev, &addr_buf, IFA_F_TENTATIVE)) {\n\t\t \n\t\tsaddr = &in6addr_any;\n\t} else\n\t\tsaddr = &addr_buf;\n\n\tip6_mc_hdr(sk, skb, dev, saddr, snd_addr, NEXTHDR_HOP, payload_len);\n\n\tskb_put_data(skb, ra, sizeof(ra));\n\n\thdr = skb_put_zero(skb, sizeof(struct mld_msg));\n\thdr->mld_type = type;\n\thdr->mld_mca = *addr;\n\n\thdr->mld_cksum = csum_ipv6_magic(saddr, snd_addr, len,\n\t\t\t\t\t IPPROTO_ICMPV6,\n\t\t\t\t\t csum_partial(hdr, len, 0));\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(skb->dev);\n\n\ticmpv6_flow_init(sk, &fl6, type,\n\t\t\t &ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr,\n\t\t\t skb->dev->ifindex);\n\tdst = icmp6_dst_alloc(skb->dev, &fl6);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto err_out;\n\t}\n\n\tskb_dst_set(skb, dst);\n\terr = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,\n\t\t      net, sk, skb, NULL, skb->dev,\n\t\t      dst_output);\nout:\n\tif (!err) {\n\t\tICMP6MSGOUT_INC_STATS(net, idev, type);\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);\n\t} else\n\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);\n\n\trcu_read_unlock();\n\treturn;\n\nerr_out:\n\tkfree_skb(skb);\n\tgoto out;\n}\n\n \nstatic void mld_send_initial_cr(struct inet6_dev *idev)\n{\n\tstruct sk_buff *skb;\n\tstruct ifmcaddr6 *pmc;\n\tint type;\n\n\tif (mld_in_v1_mode(idev))\n\t\treturn;\n\n\tskb = NULL;\n\tfor_each_mc_mclock(idev, pmc) {\n\t\tif (pmc->mca_sfcount[MCAST_EXCLUDE])\n\t\t\ttype = MLD2_CHANGE_TO_EXCLUDE;\n\t\telse\n\t\t\ttype = MLD2_ALLOW_NEW_SOURCES;\n\t\tskb = add_grec(skb, pmc, type, 0, 0, 1);\n\t}\n\tif (skb)\n\t\tmld_sendpack(skb);\n}\n\nvoid ipv6_mc_dad_complete(struct inet6_dev *idev)\n{\n\tmutex_lock(&idev->mc_lock);\n\tidev->mc_dad_count = idev->mc_qrv;\n\tif (idev->mc_dad_count) {\n\t\tmld_send_initial_cr(idev);\n\t\tidev->mc_dad_count--;\n\t\tif (idev->mc_dad_count)\n\t\t\tmld_dad_start_work(idev,\n\t\t\t\t\t   unsolicited_report_interval(idev));\n\t}\n\tmutex_unlock(&idev->mc_lock);\n}\n\nstatic void mld_dad_work(struct work_struct *work)\n{\n\tstruct inet6_dev *idev = container_of(to_delayed_work(work),\n\t\t\t\t\t      struct inet6_dev,\n\t\t\t\t\t      mc_dad_work);\n\tmutex_lock(&idev->mc_lock);\n\tmld_send_initial_cr(idev);\n\tif (idev->mc_dad_count) {\n\t\tidev->mc_dad_count--;\n\t\tif (idev->mc_dad_count)\n\t\t\tmld_dad_start_work(idev,\n\t\t\t\t\t   unsolicited_report_interval(idev));\n\t}\n\tmutex_unlock(&idev->mc_lock);\n\tin6_dev_put(idev);\n}\n\n \nstatic int ip6_mc_del1_src(struct ifmcaddr6 *pmc, int sfmode,\n\tconst struct in6_addr *psfsrc)\n{\n\tstruct ip6_sf_list *psf, *psf_prev;\n\tint rv = 0;\n\n\tpsf_prev = NULL;\n\tfor_each_psf_mclock(pmc, psf) {\n\t\tif (ipv6_addr_equal(&psf->sf_addr, psfsrc))\n\t\t\tbreak;\n\t\tpsf_prev = psf;\n\t}\n\tif (!psf || psf->sf_count[sfmode] == 0) {\n\t\t \n\t\treturn -ESRCH;\n\t}\n\tpsf->sf_count[sfmode]--;\n\tif (!psf->sf_count[MCAST_INCLUDE] && !psf->sf_count[MCAST_EXCLUDE]) {\n\t\tstruct inet6_dev *idev = pmc->idev;\n\n\t\t \n\t\tif (psf_prev)\n\t\t\trcu_assign_pointer(psf_prev->sf_next,\n\t\t\t\t\t   mc_dereference(psf->sf_next, idev));\n\t\telse\n\t\t\trcu_assign_pointer(pmc->mca_sources,\n\t\t\t\t\t   mc_dereference(psf->sf_next, idev));\n\n\t\tif (psf->sf_oldin && !(pmc->mca_flags & MAF_NOREPORT) &&\n\t\t    !mld_in_v1_mode(idev)) {\n\t\t\tpsf->sf_crcount = idev->mc_qrv;\n\t\t\trcu_assign_pointer(psf->sf_next,\n\t\t\t\t\t   mc_dereference(pmc->mca_tomb, idev));\n\t\t\trcu_assign_pointer(pmc->mca_tomb, psf);\n\t\t\trv = 1;\n\t\t} else {\n\t\t\tkfree_rcu(psf, rcu);\n\t\t}\n\t}\n\treturn rv;\n}\n\n \nstatic int ip6_mc_del_src(struct inet6_dev *idev, const struct in6_addr *pmca,\n\t\t\t  int sfmode, int sfcount, const struct in6_addr *psfsrc,\n\t\t\t  int delta)\n{\n\tstruct ifmcaddr6 *pmc;\n\tint\tchangerec = 0;\n\tint\ti, err;\n\n\tif (!idev)\n\t\treturn -ENODEV;\n\n\tfor_each_mc_mclock(idev, pmc) {\n\t\tif (ipv6_addr_equal(pmca, &pmc->mca_addr))\n\t\t\tbreak;\n\t}\n\tif (!pmc)\n\t\treturn -ESRCH;\n\n\tsf_markstate(pmc);\n\tif (!delta) {\n\t\tif (!pmc->mca_sfcount[sfmode])\n\t\t\treturn -EINVAL;\n\n\t\tpmc->mca_sfcount[sfmode]--;\n\t}\n\terr = 0;\n\tfor (i = 0; i < sfcount; i++) {\n\t\tint rv = ip6_mc_del1_src(pmc, sfmode, &psfsrc[i]);\n\n\t\tchangerec |= rv > 0;\n\t\tif (!err && rv < 0)\n\t\t\terr = rv;\n\t}\n\tif (pmc->mca_sfmode == MCAST_EXCLUDE &&\n\t    pmc->mca_sfcount[MCAST_EXCLUDE] == 0 &&\n\t    pmc->mca_sfcount[MCAST_INCLUDE]) {\n\t\tstruct ip6_sf_list *psf;\n\n\t\t \n\t\tpmc->mca_sfmode = MCAST_INCLUDE;\n\t\tpmc->mca_crcount = idev->mc_qrv;\n\t\tidev->mc_ifc_count = pmc->mca_crcount;\n\t\tfor_each_psf_mclock(pmc, psf)\n\t\t\tpsf->sf_crcount = 0;\n\t\tmld_ifc_event(pmc->idev);\n\t} else if (sf_setstate(pmc) || changerec) {\n\t\tmld_ifc_event(pmc->idev);\n\t}\n\n\treturn err;\n}\n\n \nstatic int ip6_mc_add1_src(struct ifmcaddr6 *pmc, int sfmode,\n\tconst struct in6_addr *psfsrc)\n{\n\tstruct ip6_sf_list *psf, *psf_prev;\n\n\tpsf_prev = NULL;\n\tfor_each_psf_mclock(pmc, psf) {\n\t\tif (ipv6_addr_equal(&psf->sf_addr, psfsrc))\n\t\t\tbreak;\n\t\tpsf_prev = psf;\n\t}\n\tif (!psf) {\n\t\tpsf = kzalloc(sizeof(*psf), GFP_KERNEL);\n\t\tif (!psf)\n\t\t\treturn -ENOBUFS;\n\n\t\tpsf->sf_addr = *psfsrc;\n\t\tif (psf_prev) {\n\t\t\trcu_assign_pointer(psf_prev->sf_next, psf);\n\t\t} else {\n\t\t\trcu_assign_pointer(pmc->mca_sources, psf);\n\t\t}\n\t}\n\tpsf->sf_count[sfmode]++;\n\treturn 0;\n}\n\n \nstatic void sf_markstate(struct ifmcaddr6 *pmc)\n{\n\tstruct ip6_sf_list *psf;\n\tint mca_xcount = pmc->mca_sfcount[MCAST_EXCLUDE];\n\n\tfor_each_psf_mclock(pmc, psf) {\n\t\tif (pmc->mca_sfcount[MCAST_EXCLUDE]) {\n\t\t\tpsf->sf_oldin = mca_xcount ==\n\t\t\t\tpsf->sf_count[MCAST_EXCLUDE] &&\n\t\t\t\t!psf->sf_count[MCAST_INCLUDE];\n\t\t} else {\n\t\t\tpsf->sf_oldin = psf->sf_count[MCAST_INCLUDE] != 0;\n\t\t}\n\t}\n}\n\n \nstatic int sf_setstate(struct ifmcaddr6 *pmc)\n{\n\tstruct ip6_sf_list *psf, *dpsf;\n\tint mca_xcount = pmc->mca_sfcount[MCAST_EXCLUDE];\n\tint qrv = pmc->idev->mc_qrv;\n\tint new_in, rv;\n\n\trv = 0;\n\tfor_each_psf_mclock(pmc, psf) {\n\t\tif (pmc->mca_sfcount[MCAST_EXCLUDE]) {\n\t\t\tnew_in = mca_xcount == psf->sf_count[MCAST_EXCLUDE] &&\n\t\t\t\t!psf->sf_count[MCAST_INCLUDE];\n\t\t} else\n\t\t\tnew_in = psf->sf_count[MCAST_INCLUDE] != 0;\n\t\tif (new_in) {\n\t\t\tif (!psf->sf_oldin) {\n\t\t\t\tstruct ip6_sf_list *prev = NULL;\n\n\t\t\t\tfor_each_psf_tomb(pmc, dpsf) {\n\t\t\t\t\tif (ipv6_addr_equal(&dpsf->sf_addr,\n\t\t\t\t\t    &psf->sf_addr))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tprev = dpsf;\n\t\t\t\t}\n\t\t\t\tif (dpsf) {\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\trcu_assign_pointer(prev->sf_next,\n\t\t\t\t\t\t\t\t   mc_dereference(dpsf->sf_next,\n\t\t\t\t\t\t\t\t\t\t  pmc->idev));\n\t\t\t\t\telse\n\t\t\t\t\t\trcu_assign_pointer(pmc->mca_tomb,\n\t\t\t\t\t\t\t\t   mc_dereference(dpsf->sf_next,\n\t\t\t\t\t\t\t\t\t\t  pmc->idev));\n\t\t\t\t\tkfree_rcu(dpsf, rcu);\n\t\t\t\t}\n\t\t\t\tpsf->sf_crcount = qrv;\n\t\t\t\trv++;\n\t\t\t}\n\t\t} else if (psf->sf_oldin) {\n\t\t\tpsf->sf_crcount = 0;\n\t\t\t \n\n\t\t\tfor_each_psf_tomb(pmc, dpsf)\n\t\t\t\tif (ipv6_addr_equal(&dpsf->sf_addr,\n\t\t\t\t    &psf->sf_addr))\n\t\t\t\t\tbreak;\n\t\t\tif (!dpsf) {\n\t\t\t\tdpsf = kmalloc(sizeof(*dpsf), GFP_KERNEL);\n\t\t\t\tif (!dpsf)\n\t\t\t\t\tcontinue;\n\t\t\t\t*dpsf = *psf;\n\t\t\t\trcu_assign_pointer(dpsf->sf_next,\n\t\t\t\t\t\t   mc_dereference(pmc->mca_tomb, pmc->idev));\n\t\t\t\trcu_assign_pointer(pmc->mca_tomb, dpsf);\n\t\t\t}\n\t\t\tdpsf->sf_crcount = qrv;\n\t\t\trv++;\n\t\t}\n\t}\n\treturn rv;\n}\n\n \nstatic int ip6_mc_add_src(struct inet6_dev *idev, const struct in6_addr *pmca,\n\t\t\t  int sfmode, int sfcount, const struct in6_addr *psfsrc,\n\t\t\t  int delta)\n{\n\tstruct ifmcaddr6 *pmc;\n\tint\tisexclude;\n\tint\ti, err;\n\n\tif (!idev)\n\t\treturn -ENODEV;\n\n\tfor_each_mc_mclock(idev, pmc) {\n\t\tif (ipv6_addr_equal(pmca, &pmc->mca_addr))\n\t\t\tbreak;\n\t}\n\tif (!pmc)\n\t\treturn -ESRCH;\n\n\tsf_markstate(pmc);\n\tisexclude = pmc->mca_sfmode == MCAST_EXCLUDE;\n\tif (!delta)\n\t\tpmc->mca_sfcount[sfmode]++;\n\terr = 0;\n\tfor (i = 0; i < sfcount; i++) {\n\t\terr = ip6_mc_add1_src(pmc, sfmode, &psfsrc[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif (err) {\n\t\tint j;\n\n\t\tif (!delta)\n\t\t\tpmc->mca_sfcount[sfmode]--;\n\t\tfor (j = 0; j < i; j++)\n\t\t\tip6_mc_del1_src(pmc, sfmode, &psfsrc[j]);\n\t} else if (isexclude != (pmc->mca_sfcount[MCAST_EXCLUDE] != 0)) {\n\t\tstruct ip6_sf_list *psf;\n\n\t\t \n\t\tif (pmc->mca_sfcount[MCAST_EXCLUDE])\n\t\t\tpmc->mca_sfmode = MCAST_EXCLUDE;\n\t\telse if (pmc->mca_sfcount[MCAST_INCLUDE])\n\t\t\tpmc->mca_sfmode = MCAST_INCLUDE;\n\t\t \n\n\t\tpmc->mca_crcount = idev->mc_qrv;\n\t\tidev->mc_ifc_count = pmc->mca_crcount;\n\t\tfor_each_psf_mclock(pmc, psf)\n\t\t\tpsf->sf_crcount = 0;\n\t\tmld_ifc_event(idev);\n\t} else if (sf_setstate(pmc)) {\n\t\tmld_ifc_event(idev);\n\t}\n\treturn err;\n}\n\n \nstatic void ip6_mc_clear_src(struct ifmcaddr6 *pmc)\n{\n\tstruct ip6_sf_list *psf, *nextpsf;\n\n\tfor (psf = mc_dereference(pmc->mca_tomb, pmc->idev);\n\t     psf;\n\t     psf = nextpsf) {\n\t\tnextpsf = mc_dereference(psf->sf_next, pmc->idev);\n\t\tkfree_rcu(psf, rcu);\n\t}\n\tRCU_INIT_POINTER(pmc->mca_tomb, NULL);\n\tfor (psf = mc_dereference(pmc->mca_sources, pmc->idev);\n\t     psf;\n\t     psf = nextpsf) {\n\t\tnextpsf = mc_dereference(psf->sf_next, pmc->idev);\n\t\tkfree_rcu(psf, rcu);\n\t}\n\tRCU_INIT_POINTER(pmc->mca_sources, NULL);\n\tpmc->mca_sfmode = MCAST_EXCLUDE;\n\tpmc->mca_sfcount[MCAST_INCLUDE] = 0;\n\tpmc->mca_sfcount[MCAST_EXCLUDE] = 1;\n}\n\n \nstatic void igmp6_join_group(struct ifmcaddr6 *ma)\n{\n\tunsigned long delay;\n\n\tif (ma->mca_flags & MAF_NOREPORT)\n\t\treturn;\n\n\tigmp6_send(&ma->mca_addr, ma->idev->dev, ICMPV6_MGM_REPORT);\n\n\tdelay = get_random_u32_below(unsolicited_report_interval(ma->idev));\n\n\tif (cancel_delayed_work(&ma->mca_work)) {\n\t\trefcount_dec(&ma->mca_refcnt);\n\t\tdelay = ma->mca_work.timer.expires - jiffies;\n\t}\n\n\tif (!mod_delayed_work(mld_wq, &ma->mca_work, delay))\n\t\trefcount_inc(&ma->mca_refcnt);\n\tma->mca_flags |= MAF_TIMER_RUNNING | MAF_LAST_REPORTER;\n}\n\nstatic int ip6_mc_leave_src(struct sock *sk, struct ipv6_mc_socklist *iml,\n\t\t\t    struct inet6_dev *idev)\n{\n\tstruct ip6_sf_socklist *psl;\n\tint err;\n\n\tpsl = sock_dereference(iml->sflist, sk);\n\n\tif (idev)\n\t\tmutex_lock(&idev->mc_lock);\n\n\tif (!psl) {\n\t\t \n\t\terr = ip6_mc_del_src(idev, &iml->addr, iml->sfmode, 0, NULL, 0);\n\t} else {\n\t\terr = ip6_mc_del_src(idev, &iml->addr, iml->sfmode,\n\t\t\t\t     psl->sl_count, psl->sl_addr, 0);\n\t\tRCU_INIT_POINTER(iml->sflist, NULL);\n\t\tatomic_sub(struct_size(psl, sl_addr, psl->sl_max),\n\t\t\t   &sk->sk_omem_alloc);\n\t\tkfree_rcu(psl, rcu);\n\t}\n\n\tif (idev)\n\t\tmutex_unlock(&idev->mc_lock);\n\n\treturn err;\n}\n\n \nstatic void igmp6_leave_group(struct ifmcaddr6 *ma)\n{\n\tif (mld_in_v1_mode(ma->idev)) {\n\t\tif (ma->mca_flags & MAF_LAST_REPORTER) {\n\t\t\tigmp6_send(&ma->mca_addr, ma->idev->dev,\n\t\t\t\tICMPV6_MGM_REDUCTION);\n\t\t}\n\t} else {\n\t\tmld_add_delrec(ma->idev, ma);\n\t\tmld_ifc_event(ma->idev);\n\t}\n}\n\nstatic void mld_gq_work(struct work_struct *work)\n{\n\tstruct inet6_dev *idev = container_of(to_delayed_work(work),\n\t\t\t\t\t      struct inet6_dev,\n\t\t\t\t\t      mc_gq_work);\n\n\tmutex_lock(&idev->mc_lock);\n\tmld_send_report(idev, NULL);\n\tidev->mc_gq_running = 0;\n\tmutex_unlock(&idev->mc_lock);\n\n\tin6_dev_put(idev);\n}\n\nstatic void mld_ifc_work(struct work_struct *work)\n{\n\tstruct inet6_dev *idev = container_of(to_delayed_work(work),\n\t\t\t\t\t      struct inet6_dev,\n\t\t\t\t\t      mc_ifc_work);\n\n\tmutex_lock(&idev->mc_lock);\n\tmld_send_cr(idev);\n\n\tif (idev->mc_ifc_count) {\n\t\tidev->mc_ifc_count--;\n\t\tif (idev->mc_ifc_count)\n\t\t\tmld_ifc_start_work(idev,\n\t\t\t\t\t   unsolicited_report_interval(idev));\n\t}\n\tmutex_unlock(&idev->mc_lock);\n\tin6_dev_put(idev);\n}\n\n \nstatic void mld_ifc_event(struct inet6_dev *idev)\n{\n\tif (mld_in_v1_mode(idev))\n\t\treturn;\n\n\tidev->mc_ifc_count = idev->mc_qrv;\n\tmld_ifc_start_work(idev, 1);\n}\n\nstatic void mld_mca_work(struct work_struct *work)\n{\n\tstruct ifmcaddr6 *ma = container_of(to_delayed_work(work),\n\t\t\t\t\t    struct ifmcaddr6, mca_work);\n\n\tmutex_lock(&ma->idev->mc_lock);\n\tif (mld_in_v1_mode(ma->idev))\n\t\tigmp6_send(&ma->mca_addr, ma->idev->dev, ICMPV6_MGM_REPORT);\n\telse\n\t\tmld_send_report(ma->idev, ma);\n\tma->mca_flags |=  MAF_LAST_REPORTER;\n\tma->mca_flags &= ~MAF_TIMER_RUNNING;\n\tmutex_unlock(&ma->idev->mc_lock);\n\n\tma_put(ma);\n}\n\n \n\nvoid ipv6_mc_unmap(struct inet6_dev *idev)\n{\n\tstruct ifmcaddr6 *i;\n\n\t \n\n\tmutex_lock(&idev->mc_lock);\n\tfor_each_mc_mclock(idev, i)\n\t\tigmp6_group_dropped(i);\n\tmutex_unlock(&idev->mc_lock);\n}\n\nvoid ipv6_mc_remap(struct inet6_dev *idev)\n{\n\tipv6_mc_up(idev);\n}\n\n \nvoid ipv6_mc_down(struct inet6_dev *idev)\n{\n\tstruct ifmcaddr6 *i;\n\n\tmutex_lock(&idev->mc_lock);\n\t \n\tfor_each_mc_mclock(idev, i)\n\t\tigmp6_group_dropped(i);\n\tmutex_unlock(&idev->mc_lock);\n\n\t \n\tsynchronize_net();\n\tmld_query_stop_work(idev);\n\tmld_report_stop_work(idev);\n\n\tmutex_lock(&idev->mc_lock);\n\tmld_ifc_stop_work(idev);\n\tmld_gq_stop_work(idev);\n\tmutex_unlock(&idev->mc_lock);\n\n\tmld_dad_stop_work(idev);\n}\n\nstatic void ipv6_mc_reset(struct inet6_dev *idev)\n{\n\tidev->mc_qrv = sysctl_mld_qrv;\n\tidev->mc_qi = MLD_QI_DEFAULT;\n\tidev->mc_qri = MLD_QRI_DEFAULT;\n\tidev->mc_v1_seen = 0;\n\tidev->mc_maxdelay = unsolicited_report_interval(idev);\n}\n\n \n\nvoid ipv6_mc_up(struct inet6_dev *idev)\n{\n\tstruct ifmcaddr6 *i;\n\n\t \n\n\tipv6_mc_reset(idev);\n\tmutex_lock(&idev->mc_lock);\n\tfor_each_mc_mclock(idev, i) {\n\t\tmld_del_delrec(idev, i);\n\t\tigmp6_group_added(i);\n\t}\n\tmutex_unlock(&idev->mc_lock);\n}\n\n \n\nvoid ipv6_mc_init_dev(struct inet6_dev *idev)\n{\n\tidev->mc_gq_running = 0;\n\tINIT_DELAYED_WORK(&idev->mc_gq_work, mld_gq_work);\n\tRCU_INIT_POINTER(idev->mc_tomb, NULL);\n\tidev->mc_ifc_count = 0;\n\tINIT_DELAYED_WORK(&idev->mc_ifc_work, mld_ifc_work);\n\tINIT_DELAYED_WORK(&idev->mc_dad_work, mld_dad_work);\n\tINIT_DELAYED_WORK(&idev->mc_query_work, mld_query_work);\n\tINIT_DELAYED_WORK(&idev->mc_report_work, mld_report_work);\n\tskb_queue_head_init(&idev->mc_query_queue);\n\tskb_queue_head_init(&idev->mc_report_queue);\n\tspin_lock_init(&idev->mc_query_lock);\n\tspin_lock_init(&idev->mc_report_lock);\n\tmutex_init(&idev->mc_lock);\n\tipv6_mc_reset(idev);\n}\n\n \n\nvoid ipv6_mc_destroy_dev(struct inet6_dev *idev)\n{\n\tstruct ifmcaddr6 *i;\n\n\t \n\tipv6_mc_down(idev);\n\tmutex_lock(&idev->mc_lock);\n\tmld_clear_delrec(idev);\n\tmutex_unlock(&idev->mc_lock);\n\tmld_clear_query(idev);\n\tmld_clear_report(idev);\n\n\t \n\t \n\t__ipv6_dev_mc_dec(idev, &in6addr_linklocal_allnodes);\n\n\tif (idev->cnf.forwarding)\n\t\t__ipv6_dev_mc_dec(idev, &in6addr_linklocal_allrouters);\n\n\tmutex_lock(&idev->mc_lock);\n\twhile ((i = mc_dereference(idev->mc_list, idev))) {\n\t\trcu_assign_pointer(idev->mc_list, mc_dereference(i->next, idev));\n\n\t\tip6_mc_clear_src(i);\n\t\tma_put(i);\n\t}\n\tmutex_unlock(&idev->mc_lock);\n}\n\nstatic void ipv6_mc_rejoin_groups(struct inet6_dev *idev)\n{\n\tstruct ifmcaddr6 *pmc;\n\n\tASSERT_RTNL();\n\n\tmutex_lock(&idev->mc_lock);\n\tif (mld_in_v1_mode(idev)) {\n\t\tfor_each_mc_mclock(idev, pmc)\n\t\t\tigmp6_join_group(pmc);\n\t} else {\n\t\tmld_send_report(idev, NULL);\n\t}\n\tmutex_unlock(&idev->mc_lock);\n}\n\nstatic int ipv6_mc_netdev_event(struct notifier_block *this,\n\t\t\t\tunsigned long event,\n\t\t\t\tvoid *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\n\tswitch (event) {\n\tcase NETDEV_RESEND_IGMP:\n\t\tif (idev)\n\t\t\tipv6_mc_rejoin_groups(idev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block igmp6_netdev_notifier = {\n\t.notifier_call = ipv6_mc_netdev_event,\n};\n\n#ifdef CONFIG_PROC_FS\nstruct igmp6_mc_iter_state {\n\tstruct seq_net_private p;\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n};\n\n#define igmp6_mc_seq_private(seq)\t((struct igmp6_mc_iter_state *)(seq)->private)\n\nstatic inline struct ifmcaddr6 *igmp6_mc_get_first(struct seq_file *seq)\n{\n\tstruct ifmcaddr6 *im = NULL;\n\tstruct igmp6_mc_iter_state *state = igmp6_mc_seq_private(seq);\n\tstruct net *net = seq_file_net(seq);\n\n\tstate->idev = NULL;\n\tfor_each_netdev_rcu(net, state->dev) {\n\t\tstruct inet6_dev *idev;\n\t\tidev = __in6_dev_get(state->dev);\n\t\tif (!idev)\n\t\t\tcontinue;\n\n\t\tim = rcu_dereference(idev->mc_list);\n\t\tif (im) {\n\t\t\tstate->idev = idev;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn im;\n}\n\nstatic struct ifmcaddr6 *igmp6_mc_get_next(struct seq_file *seq, struct ifmcaddr6 *im)\n{\n\tstruct igmp6_mc_iter_state *state = igmp6_mc_seq_private(seq);\n\n\tim = rcu_dereference(im->next);\n\twhile (!im) {\n\t\tstate->dev = next_net_device_rcu(state->dev);\n\t\tif (!state->dev) {\n\t\t\tstate->idev = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tstate->idev = __in6_dev_get(state->dev);\n\t\tif (!state->idev)\n\t\t\tcontinue;\n\t\tim = rcu_dereference(state->idev->mc_list);\n\t}\n\treturn im;\n}\n\nstatic struct ifmcaddr6 *igmp6_mc_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct ifmcaddr6 *im = igmp6_mc_get_first(seq);\n\tif (im)\n\t\twhile (pos && (im = igmp6_mc_get_next(seq, im)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : im;\n}\n\nstatic void *igmp6_mc_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\trcu_read_lock();\n\treturn igmp6_mc_get_idx(seq, *pos);\n}\n\nstatic void *igmp6_mc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ifmcaddr6 *im = igmp6_mc_get_next(seq, v);\n\n\t++*pos;\n\treturn im;\n}\n\nstatic void igmp6_mc_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\tstruct igmp6_mc_iter_state *state = igmp6_mc_seq_private(seq);\n\n\tif (likely(state->idev))\n\t\tstate->idev = NULL;\n\tstate->dev = NULL;\n\trcu_read_unlock();\n}\n\nstatic int igmp6_mc_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct ifmcaddr6 *im = (struct ifmcaddr6 *)v;\n\tstruct igmp6_mc_iter_state *state = igmp6_mc_seq_private(seq);\n\n\tseq_printf(seq,\n\t\t   \"%-4d %-15s %pi6 %5d %08X %ld\\n\",\n\t\t   state->dev->ifindex, state->dev->name,\n\t\t   &im->mca_addr,\n\t\t   im->mca_users, im->mca_flags,\n\t\t   (im->mca_flags & MAF_TIMER_RUNNING) ?\n\t\t   jiffies_to_clock_t(im->mca_work.timer.expires - jiffies) : 0);\n\treturn 0;\n}\n\nstatic const struct seq_operations igmp6_mc_seq_ops = {\n\t.start\t=\tigmp6_mc_seq_start,\n\t.next\t=\tigmp6_mc_seq_next,\n\t.stop\t=\tigmp6_mc_seq_stop,\n\t.show\t=\tigmp6_mc_seq_show,\n};\n\nstruct igmp6_mcf_iter_state {\n\tstruct seq_net_private p;\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\tstruct ifmcaddr6 *im;\n};\n\n#define igmp6_mcf_seq_private(seq)\t((struct igmp6_mcf_iter_state *)(seq)->private)\n\nstatic inline struct ip6_sf_list *igmp6_mcf_get_first(struct seq_file *seq)\n{\n\tstruct ip6_sf_list *psf = NULL;\n\tstruct ifmcaddr6 *im = NULL;\n\tstruct igmp6_mcf_iter_state *state = igmp6_mcf_seq_private(seq);\n\tstruct net *net = seq_file_net(seq);\n\n\tstate->idev = NULL;\n\tstate->im = NULL;\n\tfor_each_netdev_rcu(net, state->dev) {\n\t\tstruct inet6_dev *idev;\n\t\tidev = __in6_dev_get(state->dev);\n\t\tif (unlikely(idev == NULL))\n\t\t\tcontinue;\n\n\t\tim = rcu_dereference(idev->mc_list);\n\t\tif (likely(im)) {\n\t\t\tpsf = rcu_dereference(im->mca_sources);\n\t\t\tif (likely(psf)) {\n\t\t\t\tstate->im = im;\n\t\t\t\tstate->idev = idev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn psf;\n}\n\nstatic struct ip6_sf_list *igmp6_mcf_get_next(struct seq_file *seq, struct ip6_sf_list *psf)\n{\n\tstruct igmp6_mcf_iter_state *state = igmp6_mcf_seq_private(seq);\n\n\tpsf = rcu_dereference(psf->sf_next);\n\twhile (!psf) {\n\t\tstate->im = rcu_dereference(state->im->next);\n\t\twhile (!state->im) {\n\t\t\tstate->dev = next_net_device_rcu(state->dev);\n\t\t\tif (!state->dev) {\n\t\t\t\tstate->idev = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstate->idev = __in6_dev_get(state->dev);\n\t\t\tif (!state->idev)\n\t\t\t\tcontinue;\n\t\t\tstate->im = rcu_dereference(state->idev->mc_list);\n\t\t}\n\t\tif (!state->im)\n\t\t\tbreak;\n\t\tpsf = rcu_dereference(state->im->mca_sources);\n\t}\nout:\n\treturn psf;\n}\n\nstatic struct ip6_sf_list *igmp6_mcf_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct ip6_sf_list *psf = igmp6_mcf_get_first(seq);\n\tif (psf)\n\t\twhile (pos && (psf = igmp6_mcf_get_next(seq, psf)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : psf;\n}\n\nstatic void *igmp6_mcf_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\trcu_read_lock();\n\treturn *pos ? igmp6_mcf_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *igmp6_mcf_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ip6_sf_list *psf;\n\tif (v == SEQ_START_TOKEN)\n\t\tpsf = igmp6_mcf_get_first(seq);\n\telse\n\t\tpsf = igmp6_mcf_get_next(seq, v);\n\t++*pos;\n\treturn psf;\n}\n\nstatic void igmp6_mcf_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\tstruct igmp6_mcf_iter_state *state = igmp6_mcf_seq_private(seq);\n\n\tif (likely(state->im))\n\t\tstate->im = NULL;\n\tif (likely(state->idev))\n\t\tstate->idev = NULL;\n\n\tstate->dev = NULL;\n\trcu_read_unlock();\n}\n\nstatic int igmp6_mcf_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct ip6_sf_list *psf = (struct ip6_sf_list *)v;\n\tstruct igmp6_mcf_iter_state *state = igmp6_mcf_seq_private(seq);\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Idx Device                Multicast Address                   Source Address    INC    EXC\\n\");\n\t} else {\n\t\tseq_printf(seq,\n\t\t\t   \"%3d %6.6s %pi6 %pi6 %6lu %6lu\\n\",\n\t\t\t   state->dev->ifindex, state->dev->name,\n\t\t\t   &state->im->mca_addr,\n\t\t\t   &psf->sf_addr,\n\t\t\t   psf->sf_count[MCAST_INCLUDE],\n\t\t\t   psf->sf_count[MCAST_EXCLUDE]);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations igmp6_mcf_seq_ops = {\n\t.start\t=\tigmp6_mcf_seq_start,\n\t.next\t=\tigmp6_mcf_seq_next,\n\t.stop\t=\tigmp6_mcf_seq_stop,\n\t.show\t=\tigmp6_mcf_seq_show,\n};\n\nstatic int __net_init igmp6_proc_init(struct net *net)\n{\n\tint err;\n\n\terr = -ENOMEM;\n\tif (!proc_create_net(\"igmp6\", 0444, net->proc_net, &igmp6_mc_seq_ops,\n\t\t\tsizeof(struct igmp6_mc_iter_state)))\n\t\tgoto out;\n\tif (!proc_create_net(\"mcfilter6\", 0444, net->proc_net,\n\t\t\t&igmp6_mcf_seq_ops,\n\t\t\tsizeof(struct igmp6_mcf_iter_state)))\n\t\tgoto out_proc_net_igmp6;\n\n\terr = 0;\nout:\n\treturn err;\n\nout_proc_net_igmp6:\n\tremove_proc_entry(\"igmp6\", net->proc_net);\n\tgoto out;\n}\n\nstatic void __net_exit igmp6_proc_exit(struct net *net)\n{\n\tremove_proc_entry(\"mcfilter6\", net->proc_net);\n\tremove_proc_entry(\"igmp6\", net->proc_net);\n}\n#else\nstatic inline int igmp6_proc_init(struct net *net)\n{\n\treturn 0;\n}\nstatic inline void igmp6_proc_exit(struct net *net)\n{\n}\n#endif\n\nstatic int __net_init igmp6_net_init(struct net *net)\n{\n\tint err;\n\n\terr = inet_ctl_sock_create(&net->ipv6.igmp_sk, PF_INET6,\n\t\t\t\t   SOCK_RAW, IPPROTO_ICMPV6, net);\n\tif (err < 0) {\n\t\tpr_err(\"Failed to initialize the IGMP6 control socket (err %d)\\n\",\n\t\t       err);\n\t\tgoto out;\n\t}\n\n\tinet6_sk(net->ipv6.igmp_sk)->hop_limit = 1;\n\tnet->ipv6.igmp_sk->sk_allocation = GFP_KERNEL;\n\n\terr = inet_ctl_sock_create(&net->ipv6.mc_autojoin_sk, PF_INET6,\n\t\t\t\t   SOCK_RAW, IPPROTO_ICMPV6, net);\n\tif (err < 0) {\n\t\tpr_err(\"Failed to initialize the IGMP6 autojoin socket (err %d)\\n\",\n\t\t       err);\n\t\tgoto out_sock_create;\n\t}\n\n\terr = igmp6_proc_init(net);\n\tif (err)\n\t\tgoto out_sock_create_autojoin;\n\n\treturn 0;\n\nout_sock_create_autojoin:\n\tinet_ctl_sock_destroy(net->ipv6.mc_autojoin_sk);\nout_sock_create:\n\tinet_ctl_sock_destroy(net->ipv6.igmp_sk);\nout:\n\treturn err;\n}\n\nstatic void __net_exit igmp6_net_exit(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->ipv6.igmp_sk);\n\tinet_ctl_sock_destroy(net->ipv6.mc_autojoin_sk);\n\tigmp6_proc_exit(net);\n}\n\nstatic struct pernet_operations igmp6_net_ops = {\n\t.init = igmp6_net_init,\n\t.exit = igmp6_net_exit,\n};\n\nint __init igmp6_init(void)\n{\n\tint err;\n\n\terr = register_pernet_subsys(&igmp6_net_ops);\n\tif (err)\n\t\treturn err;\n\n\tmld_wq = create_workqueue(\"mld\");\n\tif (!mld_wq) {\n\t\tunregister_pernet_subsys(&igmp6_net_ops);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn err;\n}\n\nint __init igmp6_late_init(void)\n{\n\treturn register_netdevice_notifier(&igmp6_netdev_notifier);\n}\n\nvoid igmp6_cleanup(void)\n{\n\tunregister_pernet_subsys(&igmp6_net_ops);\n\tdestroy_workqueue(mld_wq);\n}\n\nvoid igmp6_late_cleanup(void)\n{\n\tunregister_netdevice_notifier(&igmp6_netdev_notifier);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}