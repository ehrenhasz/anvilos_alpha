{
  "module_name": "fou6.c",
  "hash_id": "2a008c0be6b52fda9a35514c13b96625a32310a8bf6885824b1f2b90e95e8900",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/fou6.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/socket.h>\n#include <linux/skbuff.h>\n#include <linux/ip.h>\n#include <linux/udp.h>\n#include <linux/icmpv6.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <net/fou.h>\n#include <net/ip.h>\n#include <net/ip6_tunnel.h>\n#include <net/ip6_checksum.h>\n#include <net/protocol.h>\n#include <net/udp.h>\n#include <net/udp_tunnel.h>\n\n#if IS_ENABLED(CONFIG_IPV6_FOU_TUNNEL)\n\nstatic void fou6_build_udp(struct sk_buff *skb, struct ip_tunnel_encap *e,\n\t\t\t   struct flowi6 *fl6, u8 *protocol, __be16 sport)\n{\n\tstruct udphdr *uh;\n\n\tskb_push(skb, sizeof(struct udphdr));\n\tskb_reset_transport_header(skb);\n\n\tuh = udp_hdr(skb);\n\n\tuh->dest = e->dport;\n\tuh->source = sport;\n\tuh->len = htons(skb->len);\n\tudp6_set_csum(!(e->flags & TUNNEL_ENCAP_FLAG_CSUM6), skb,\n\t\t      &fl6->saddr, &fl6->daddr, skb->len);\n\n\t*protocol = IPPROTO_UDP;\n}\n\nstatic int fou6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,\n\t\t\t     u8 *protocol, struct flowi6 *fl6)\n{\n\t__be16 sport;\n\tint err;\n\tint type = e->flags & TUNNEL_ENCAP_FLAG_CSUM6 ?\n\t\tSKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;\n\n\terr = __fou_build_header(skb, e, protocol, &sport, type);\n\tif (err)\n\t\treturn err;\n\n\tfou6_build_udp(skb, e, fl6, protocol, sport);\n\n\treturn 0;\n}\n\nstatic int gue6_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,\n\t\t\t     u8 *protocol, struct flowi6 *fl6)\n{\n\t__be16 sport;\n\tint err;\n\tint type = e->flags & TUNNEL_ENCAP_FLAG_CSUM6 ?\n\t\tSKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;\n\n\terr = __gue_build_header(skb, e, protocol, &sport, type);\n\tif (err)\n\t\treturn err;\n\n\tfou6_build_udp(skb, e, fl6, protocol, sport);\n\n\treturn 0;\n}\n\nstatic int gue6_err_proto_handler(int proto, struct sk_buff *skb,\n\t\t\t\t  struct inet6_skb_parm *opt,\n\t\t\t\t  u8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct inet6_protocol *ipprot;\n\n\tipprot = rcu_dereference(inet6_protos[proto]);\n\tif (ipprot && ipprot->err_handler) {\n\t\tif (!ipprot->err_handler(skb, opt, type, code, offset, info))\n\t\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int gue6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t    u8 type, u8 code, int offset, __be32 info)\n{\n\tint transport_offset = skb_transport_offset(skb);\n\tstruct guehdr *guehdr;\n\tsize_t len, optlen;\n\tint ret;\n\n\tlen = sizeof(struct udphdr) + sizeof(struct guehdr);\n\tif (!pskb_may_pull(skb, transport_offset + len))\n\t\treturn -EINVAL;\n\n\tguehdr = (struct guehdr *)&udp_hdr(skb)[1];\n\n\tswitch (guehdr->version) {\n\tcase 0:  \n\t\tbreak;\n\tcase 1: {\n\t\t \n\t\tskb_set_transport_header(skb, -(int)sizeof(struct icmp6hdr));\n\n\t\tswitch (((struct iphdr *)guehdr)->version) {\n\t\tcase 4:\n\t\t\tret = gue6_err_proto_handler(IPPROTO_IPIP, skb, opt,\n\t\t\t\t\t\t     type, code, offset, info);\n\t\t\tgoto out;\n\t\tcase 6:\n\t\t\tret = gue6_err_proto_handler(IPPROTO_IPV6, skb, opt,\n\t\t\t\t\t\t     type, code, offset, info);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdefault:  \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (guehdr->control)\n\t\treturn -ENOENT;\n\n\toptlen = guehdr->hlen << 2;\n\n\tif (!pskb_may_pull(skb, transport_offset + len + optlen))\n\t\treturn -EINVAL;\n\n\tguehdr = (struct guehdr *)&udp_hdr(skb)[1];\n\tif (validate_gue_flags(guehdr, optlen))\n\t\treturn -EINVAL;\n\n\t \n\tif (guehdr->proto_ctype == IPPROTO_UDP ||\n\t    guehdr->proto_ctype == IPPROTO_UDPLITE)\n\t\treturn -EOPNOTSUPP;\n\n\tskb_set_transport_header(skb, -(int)sizeof(struct icmp6hdr));\n\tret = gue6_err_proto_handler(guehdr->proto_ctype, skb,\n\t\t\t\t     opt, type, code, offset, info);\n\nout:\n\tskb_set_transport_header(skb, transport_offset);\n\treturn ret;\n}\n\n\nstatic const struct ip6_tnl_encap_ops fou_ip6tun_ops = {\n\t.encap_hlen = fou_encap_hlen,\n\t.build_header = fou6_build_header,\n\t.err_handler = gue6_err,\n};\n\nstatic const struct ip6_tnl_encap_ops gue_ip6tun_ops = {\n\t.encap_hlen = gue_encap_hlen,\n\t.build_header = gue6_build_header,\n\t.err_handler = gue6_err,\n};\n\nstatic int ip6_tnl_encap_add_fou_ops(void)\n{\n\tint ret;\n\n\tret = ip6_tnl_encap_add_ops(&fou_ip6tun_ops, TUNNEL_ENCAP_FOU);\n\tif (ret < 0) {\n\t\tpr_err(\"can't add fou6 ops\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ip6_tnl_encap_add_ops(&gue_ip6tun_ops, TUNNEL_ENCAP_GUE);\n\tif (ret < 0) {\n\t\tpr_err(\"can't add gue6 ops\\n\");\n\t\tip6_tnl_encap_del_ops(&fou_ip6tun_ops, TUNNEL_ENCAP_FOU);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ip6_tnl_encap_del_fou_ops(void)\n{\n\tip6_tnl_encap_del_ops(&fou_ip6tun_ops, TUNNEL_ENCAP_FOU);\n\tip6_tnl_encap_del_ops(&gue_ip6tun_ops, TUNNEL_ENCAP_GUE);\n}\n\n#else\n\nstatic int ip6_tnl_encap_add_fou_ops(void)\n{\n\treturn 0;\n}\n\nstatic void ip6_tnl_encap_del_fou_ops(void)\n{\n}\n\n#endif\n\nstatic int __init fou6_init(void)\n{\n\tint ret;\n\n\tret = ip6_tnl_encap_add_fou_ops();\n\n\treturn ret;\n}\n\nstatic void __exit fou6_fini(void)\n{\n\tip6_tnl_encap_del_fou_ops();\n}\n\nmodule_init(fou6_init);\nmodule_exit(fou6_fini);\nMODULE_AUTHOR(\"Tom Herbert <therbert@google.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Foo over UDP (IPv6)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}