{
  "module_name": "route.c",
  "hash_id": "836730851be5f1d5b08dfad35f0a596a0e0fed605aac619351b185dc66d93d74",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/route.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/types.h>\n#include <linux/times.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/route.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/mroute6.h>\n#include <linux/init.h>\n#include <linux/if_arp.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/siphash.h>\n#include <net/net_namespace.h>\n#include <net/snmp.h>\n#include <net/ipv6.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/tcp.h>\n#include <linux/rtnetlink.h>\n#include <net/dst.h>\n#include <net/dst_metadata.h>\n#include <net/xfrm.h>\n#include <net/netevent.h>\n#include <net/netlink.h>\n#include <net/rtnh.h>\n#include <net/lwtunnel.h>\n#include <net/ip_tunnels.h>\n#include <net/l3mdev.h>\n#include <net/ip.h>\n#include <linux/uaccess.h>\n#include <linux/btf_ids.h>\n\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\nstatic int ip6_rt_type_to_error(u8 fib6_type);\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/fib6.h>\nEXPORT_TRACEPOINT_SYMBOL_GPL(fib6_table_lookup);\n#undef CREATE_TRACE_POINTS\n\nenum rt6_nud_state {\n\tRT6_NUD_FAIL_HARD = -3,\n\tRT6_NUD_FAIL_PROBE = -2,\n\tRT6_NUD_FAIL_DO_RR = -1,\n\tRT6_NUD_SUCCEED = 1\n};\n\nINDIRECT_CALLABLE_SCOPE\nstruct dst_entry\t*ip6_dst_check(struct dst_entry *dst, u32 cookie);\nstatic unsigned int\t ip6_default_advmss(const struct dst_entry *dst);\nINDIRECT_CALLABLE_SCOPE\nunsigned int\t\tip6_mtu(const struct dst_entry *dst);\nstatic struct dst_entry *ip6_negative_advice(struct dst_entry *);\nstatic void\t\tip6_dst_destroy(struct dst_entry *);\nstatic void\t\tip6_dst_ifdown(struct dst_entry *,\n\t\t\t\t       struct net_device *dev);\nstatic void\t\t ip6_dst_gc(struct dst_ops *ops);\n\nstatic int\t\tip6_pkt_discard(struct sk_buff *skb);\nstatic int\t\tip6_pkt_discard_out(struct net *net, struct sock *sk, struct sk_buff *skb);\nstatic int\t\tip6_pkt_prohibit(struct sk_buff *skb);\nstatic int\t\tip6_pkt_prohibit_out(struct net *net, struct sock *sk, struct sk_buff *skb);\nstatic void\t\tip6_link_failure(struct sk_buff *skb);\nstatic void\t\tip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t\t\t   struct sk_buff *skb, u32 mtu,\n\t\t\t\t\t   bool confirm_neigh);\nstatic void\t\trt6_do_redirect(struct dst_entry *dst, struct sock *sk,\n\t\t\t\t\tstruct sk_buff *skb);\nstatic int rt6_score_route(const struct fib6_nh *nh, u32 fib6_flags, int oif,\n\t\t\t   int strict);\nstatic size_t rt6_nlmsg_size(struct fib6_info *f6i);\nstatic int rt6_fill_node(struct net *net, struct sk_buff *skb,\n\t\t\t struct fib6_info *rt, struct dst_entry *dst,\n\t\t\t struct in6_addr *dest, struct in6_addr *src,\n\t\t\t int iif, int type, u32 portid, u32 seq,\n\t\t\t unsigned int flags);\nstatic struct rt6_info *rt6_find_cached_rt(const struct fib6_result *res,\n\t\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t\t   const struct in6_addr *saddr);\n\n#ifdef CONFIG_IPV6_ROUTE_INFO\nstatic struct fib6_info *rt6_add_route_info(struct net *net,\n\t\t\t\t\t   const struct in6_addr *prefix, int prefixlen,\n\t\t\t\t\t   const struct in6_addr *gwaddr,\n\t\t\t\t\t   struct net_device *dev,\n\t\t\t\t\t   unsigned int pref);\nstatic struct fib6_info *rt6_get_route_info(struct net *net,\n\t\t\t\t\t   const struct in6_addr *prefix, int prefixlen,\n\t\t\t\t\t   const struct in6_addr *gwaddr,\n\t\t\t\t\t   struct net_device *dev);\n#endif\n\nstruct uncached_list {\n\tspinlock_t\t\tlock;\n\tstruct list_head\thead;\n\tstruct list_head\tquarantine;\n};\n\nstatic DEFINE_PER_CPU_ALIGNED(struct uncached_list, rt6_uncached_list);\n\nvoid rt6_uncached_list_add(struct rt6_info *rt)\n{\n\tstruct uncached_list *ul = raw_cpu_ptr(&rt6_uncached_list);\n\n\trt->dst.rt_uncached_list = ul;\n\n\tspin_lock_bh(&ul->lock);\n\tlist_add_tail(&rt->dst.rt_uncached, &ul->head);\n\tspin_unlock_bh(&ul->lock);\n}\n\nvoid rt6_uncached_list_del(struct rt6_info *rt)\n{\n\tif (!list_empty(&rt->dst.rt_uncached)) {\n\t\tstruct uncached_list *ul = rt->dst.rt_uncached_list;\n\n\t\tspin_lock_bh(&ul->lock);\n\t\tlist_del_init(&rt->dst.rt_uncached);\n\t\tspin_unlock_bh(&ul->lock);\n\t}\n}\n\nstatic void rt6_uncached_list_flush_dev(struct net_device *dev)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct uncached_list *ul = per_cpu_ptr(&rt6_uncached_list, cpu);\n\t\tstruct rt6_info *rt, *safe;\n\n\t\tif (list_empty(&ul->head))\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(&ul->lock);\n\t\tlist_for_each_entry_safe(rt, safe, &ul->head, dst.rt_uncached) {\n\t\t\tstruct inet6_dev *rt_idev = rt->rt6i_idev;\n\t\t\tstruct net_device *rt_dev = rt->dst.dev;\n\t\t\tbool handled = false;\n\n\t\t\tif (rt_idev->dev == dev) {\n\t\t\t\trt->rt6i_idev = in6_dev_get(blackhole_netdev);\n\t\t\t\tin6_dev_put(rt_idev);\n\t\t\t\thandled = true;\n\t\t\t}\n\n\t\t\tif (rt_dev == dev) {\n\t\t\t\trt->dst.dev = blackhole_netdev;\n\t\t\t\tnetdev_ref_replace(rt_dev, blackhole_netdev,\n\t\t\t\t\t\t   &rt->dst.dev_tracker,\n\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t\t\thandled = true;\n\t\t\t}\n\t\t\tif (handled)\n\t\t\t\tlist_move(&rt->dst.rt_uncached,\n\t\t\t\t\t  &ul->quarantine);\n\t\t}\n\t\tspin_unlock_bh(&ul->lock);\n\t}\n}\n\nstatic inline const void *choose_neigh_daddr(const struct in6_addr *p,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     const void *daddr)\n{\n\tif (!ipv6_addr_any(p))\n\t\treturn (const void *) p;\n\telse if (skb)\n\t\treturn &ipv6_hdr(skb)->daddr;\n\treturn daddr;\n}\n\nstruct neighbour *ip6_neigh_lookup(const struct in6_addr *gw,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   const void *daddr)\n{\n\tstruct neighbour *n;\n\n\tdaddr = choose_neigh_daddr(gw, skb, daddr);\n\tn = __ipv6_neigh_lookup(dev, daddr);\n\tif (n)\n\t\treturn n;\n\n\tn = neigh_create(&nd_tbl, daddr, dev);\n\treturn IS_ERR(n) ? NULL : n;\n}\n\nstatic struct neighbour *ip6_dst_neigh_lookup(const struct dst_entry *dst,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      const void *daddr)\n{\n\tconst struct rt6_info *rt = container_of(dst, struct rt6_info, dst);\n\n\treturn ip6_neigh_lookup(rt6_nexthop(rt, &in6addr_any),\n\t\t\t\tdst->dev, skb, daddr);\n}\n\nstatic void ip6_confirm_neigh(const struct dst_entry *dst, const void *daddr)\n{\n\tstruct net_device *dev = dst->dev;\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\n\tdaddr = choose_neigh_daddr(rt6_nexthop(rt, &in6addr_any), NULL, daddr);\n\tif (!daddr)\n\t\treturn;\n\tif (dev->flags & (IFF_NOARP | IFF_LOOPBACK))\n\t\treturn;\n\tif (ipv6_addr_is_multicast((const struct in6_addr *)daddr))\n\t\treturn;\n\t__ipv6_confirm_neigh(dev, daddr);\n}\n\nstatic struct dst_ops ip6_dst_ops_template = {\n\t.family\t\t\t=\tAF_INET6,\n\t.gc\t\t\t=\tip6_dst_gc,\n\t.gc_thresh\t\t=\t1024,\n\t.check\t\t\t=\tip6_dst_check,\n\t.default_advmss\t\t=\tip6_default_advmss,\n\t.mtu\t\t\t=\tip6_mtu,\n\t.cow_metrics\t\t=\tdst_cow_metrics_generic,\n\t.destroy\t\t=\tip6_dst_destroy,\n\t.ifdown\t\t\t=\tip6_dst_ifdown,\n\t.negative_advice\t=\tip6_negative_advice,\n\t.link_failure\t\t=\tip6_link_failure,\n\t.update_pmtu\t\t=\tip6_rt_update_pmtu,\n\t.redirect\t\t=\trt6_do_redirect,\n\t.local_out\t\t=\t__ip6_local_out,\n\t.neigh_lookup\t\t=\tip6_dst_neigh_lookup,\n\t.confirm_neigh\t\t=\tip6_confirm_neigh,\n};\n\nstatic struct dst_ops ip6_dst_blackhole_ops = {\n\t.family\t\t\t= AF_INET6,\n\t.default_advmss\t\t= ip6_default_advmss,\n\t.neigh_lookup\t\t= ip6_dst_neigh_lookup,\n\t.check\t\t\t= ip6_dst_check,\n\t.destroy\t\t= ip6_dst_destroy,\n\t.cow_metrics\t\t= dst_cow_metrics_generic,\n\t.update_pmtu\t\t= dst_blackhole_update_pmtu,\n\t.redirect\t\t= dst_blackhole_redirect,\n\t.mtu\t\t\t= dst_blackhole_mtu,\n};\n\nstatic const u32 ip6_template_metrics[RTAX_MAX] = {\n\t[RTAX_HOPLIMIT - 1] = 0,\n};\n\nstatic const struct fib6_info fib6_null_entry_template = {\n\t.fib6_flags\t= (RTF_REJECT | RTF_NONEXTHOP),\n\t.fib6_protocol  = RTPROT_KERNEL,\n\t.fib6_metric\t= ~(u32)0,\n\t.fib6_ref\t= REFCOUNT_INIT(1),\n\t.fib6_type\t= RTN_UNREACHABLE,\n\t.fib6_metrics\t= (struct dst_metrics *)&dst_default_metrics,\n};\n\nstatic const struct rt6_info ip6_null_entry_template = {\n\t.dst = {\n\t\t.__rcuref\t= RCUREF_INIT(1),\n\t\t.__use\t\t= 1,\n\t\t.obsolete\t= DST_OBSOLETE_FORCE_CHK,\n\t\t.error\t\t= -ENETUNREACH,\n\t\t.input\t\t= ip6_pkt_discard,\n\t\t.output\t\t= ip6_pkt_discard_out,\n\t},\n\t.rt6i_flags\t= (RTF_REJECT | RTF_NONEXTHOP),\n};\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\nstatic const struct rt6_info ip6_prohibit_entry_template = {\n\t.dst = {\n\t\t.__rcuref\t= RCUREF_INIT(1),\n\t\t.__use\t\t= 1,\n\t\t.obsolete\t= DST_OBSOLETE_FORCE_CHK,\n\t\t.error\t\t= -EACCES,\n\t\t.input\t\t= ip6_pkt_prohibit,\n\t\t.output\t\t= ip6_pkt_prohibit_out,\n\t},\n\t.rt6i_flags\t= (RTF_REJECT | RTF_NONEXTHOP),\n};\n\nstatic const struct rt6_info ip6_blk_hole_entry_template = {\n\t.dst = {\n\t\t.__rcuref\t= RCUREF_INIT(1),\n\t\t.__use\t\t= 1,\n\t\t.obsolete\t= DST_OBSOLETE_FORCE_CHK,\n\t\t.error\t\t= -EINVAL,\n\t\t.input\t\t= dst_discard,\n\t\t.output\t\t= dst_discard_out,\n\t},\n\t.rt6i_flags\t= (RTF_REJECT | RTF_NONEXTHOP),\n};\n\n#endif\n\nstatic void rt6_info_init(struct rt6_info *rt)\n{\n\tmemset_after(rt, 0, dst);\n}\n\n \nstruct rt6_info *ip6_dst_alloc(struct net *net, struct net_device *dev,\n\t\t\t       int flags)\n{\n\tstruct rt6_info *rt = dst_alloc(&net->ipv6.ip6_dst_ops, dev,\n\t\t\t\t\t1, DST_OBSOLETE_FORCE_CHK, flags);\n\n\tif (rt) {\n\t\trt6_info_init(rt);\n\t\tatomic_inc(&net->ipv6.rt6_stats->fib_rt_alloc);\n\t}\n\n\treturn rt;\n}\nEXPORT_SYMBOL(ip6_dst_alloc);\n\nstatic void ip6_dst_destroy(struct dst_entry *dst)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tstruct fib6_info *from;\n\tstruct inet6_dev *idev;\n\n\tip_dst_metrics_put(dst);\n\trt6_uncached_list_del(rt);\n\n\tidev = rt->rt6i_idev;\n\tif (idev) {\n\t\trt->rt6i_idev = NULL;\n\t\tin6_dev_put(idev);\n\t}\n\n\tfrom = xchg((__force struct fib6_info **)&rt->from, NULL);\n\tfib6_info_release(from);\n}\n\nstatic void ip6_dst_ifdown(struct dst_entry *dst, struct net_device *dev)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tstruct inet6_dev *idev = rt->rt6i_idev;\n\n\tif (idev && idev->dev != blackhole_netdev) {\n\t\tstruct inet6_dev *blackhole_idev = in6_dev_get(blackhole_netdev);\n\n\t\tif (blackhole_idev) {\n\t\t\trt->rt6i_idev = blackhole_idev;\n\t\t\tin6_dev_put(idev);\n\t\t}\n\t}\n}\n\nstatic bool __rt6_check_expired(const struct rt6_info *rt)\n{\n\tif (rt->rt6i_flags & RTF_EXPIRES)\n\t\treturn time_after(jiffies, rt->dst.expires);\n\telse\n\t\treturn false;\n}\n\nstatic bool rt6_check_expired(const struct rt6_info *rt)\n{\n\tstruct fib6_info *from;\n\n\tfrom = rcu_dereference(rt->from);\n\n\tif (rt->rt6i_flags & RTF_EXPIRES) {\n\t\tif (time_after(jiffies, rt->dst.expires))\n\t\t\treturn true;\n\t} else if (from) {\n\t\treturn rt->dst.obsolete != DST_OBSOLETE_FORCE_CHK ||\n\t\t\tfib6_check_expired(from);\n\t}\n\treturn false;\n}\n\nvoid fib6_select_path(const struct net *net, struct fib6_result *res,\n\t\t      struct flowi6 *fl6, int oif, bool have_oif_match,\n\t\t      const struct sk_buff *skb, int strict)\n{\n\tstruct fib6_info *sibling, *next_sibling;\n\tstruct fib6_info *match = res->f6i;\n\n\tif (!match->nh && (!match->fib6_nsiblings || have_oif_match))\n\t\tgoto out;\n\n\tif (match->nh && have_oif_match && res->nh)\n\t\treturn;\n\n\tif (skb)\n\t\tIP6CB(skb)->flags |= IP6SKB_MULTIPATH;\n\n\t \n\tif (!fl6->mp_hash &&\n\t    (!match->nh || nexthop_is_multipath(match->nh)))\n\t\tfl6->mp_hash = rt6_multipath_hash(net, fl6, skb, NULL);\n\n\tif (unlikely(match->nh)) {\n\t\tnexthop_path_fib6_result(res, fl6->mp_hash);\n\t\treturn;\n\t}\n\n\tif (fl6->mp_hash <= atomic_read(&match->fib6_nh->fib_nh_upper_bound))\n\t\tgoto out;\n\n\tlist_for_each_entry_safe(sibling, next_sibling, &match->fib6_siblings,\n\t\t\t\t fib6_siblings) {\n\t\tconst struct fib6_nh *nh = sibling->fib6_nh;\n\t\tint nh_upper_bound;\n\n\t\tnh_upper_bound = atomic_read(&nh->fib_nh_upper_bound);\n\t\tif (fl6->mp_hash > nh_upper_bound)\n\t\t\tcontinue;\n\t\tif (rt6_score_route(nh, sibling->fib6_flags, oif, strict) < 0)\n\t\t\tbreak;\n\t\tmatch = sibling;\n\t\tbreak;\n\t}\n\nout:\n\tres->f6i = match;\n\tres->nh = match->fib6_nh;\n}\n\n \n\nstatic bool __rt6_device_match(struct net *net, const struct fib6_nh *nh,\n\t\t\t       const struct in6_addr *saddr, int oif, int flags)\n{\n\tconst struct net_device *dev;\n\n\tif (nh->fib_nh_flags & RTNH_F_DEAD)\n\t\treturn false;\n\n\tdev = nh->fib_nh_dev;\n\tif (oif) {\n\t\tif (dev->ifindex == oif)\n\t\t\treturn true;\n\t} else {\n\t\tif (ipv6_chk_addr(net, saddr, dev,\n\t\t\t\t  flags & RT6_LOOKUP_F_IFACE))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstruct fib6_nh_dm_arg {\n\tstruct net\t\t*net;\n\tconst struct in6_addr\t*saddr;\n\tint\t\t\toif;\n\tint\t\t\tflags;\n\tstruct fib6_nh\t\t*nh;\n};\n\nstatic int __rt6_nh_dev_match(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_dm_arg *arg = _arg;\n\n\targ->nh = nh;\n\treturn __rt6_device_match(arg->net, nh, arg->saddr, arg->oif,\n\t\t\t\t  arg->flags);\n}\n\n \nstatic struct fib6_nh *rt6_nh_dev_match(struct net *net, struct nexthop *nh,\n\t\t\t\t\tstruct fib6_result *res,\n\t\t\t\t\tconst struct in6_addr *saddr,\n\t\t\t\t\tint oif, int flags)\n{\n\tstruct fib6_nh_dm_arg arg = {\n\t\t.net   = net,\n\t\t.saddr = saddr,\n\t\t.oif   = oif,\n\t\t.flags = flags,\n\t};\n\n\tif (nexthop_is_blackhole(nh))\n\t\treturn NULL;\n\n\tif (nexthop_for_each_fib6_nh(nh, __rt6_nh_dev_match, &arg))\n\t\treturn arg.nh;\n\n\treturn NULL;\n}\n\nstatic void rt6_device_match(struct net *net, struct fib6_result *res,\n\t\t\t     const struct in6_addr *saddr, int oif, int flags)\n{\n\tstruct fib6_info *f6i = res->f6i;\n\tstruct fib6_info *spf6i;\n\tstruct fib6_nh *nh;\n\n\tif (!oif && ipv6_addr_any(saddr)) {\n\t\tif (unlikely(f6i->nh)) {\n\t\t\tnh = nexthop_fib6_nh(f6i->nh);\n\t\t\tif (nexthop_is_blackhole(f6i->nh))\n\t\t\t\tgoto out_blackhole;\n\t\t} else {\n\t\t\tnh = f6i->fib6_nh;\n\t\t}\n\t\tif (!(nh->fib_nh_flags & RTNH_F_DEAD))\n\t\t\tgoto out;\n\t}\n\n\tfor (spf6i = f6i; spf6i; spf6i = rcu_dereference(spf6i->fib6_next)) {\n\t\tbool matched = false;\n\n\t\tif (unlikely(spf6i->nh)) {\n\t\t\tnh = rt6_nh_dev_match(net, spf6i->nh, res, saddr,\n\t\t\t\t\t      oif, flags);\n\t\t\tif (nh)\n\t\t\t\tmatched = true;\n\t\t} else {\n\t\t\tnh = spf6i->fib6_nh;\n\t\t\tif (__rt6_device_match(net, nh, saddr, oif, flags))\n\t\t\t\tmatched = true;\n\t\t}\n\t\tif (matched) {\n\t\t\tres->f6i = spf6i;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (oif && flags & RT6_LOOKUP_F_IFACE) {\n\t\tres->f6i = net->ipv6.fib6_null_entry;\n\t\tnh = res->f6i->fib6_nh;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(f6i->nh)) {\n\t\tnh = nexthop_fib6_nh(f6i->nh);\n\t\tif (nexthop_is_blackhole(f6i->nh))\n\t\t\tgoto out_blackhole;\n\t} else {\n\t\tnh = f6i->fib6_nh;\n\t}\n\n\tif (nh->fib_nh_flags & RTNH_F_DEAD) {\n\t\tres->f6i = net->ipv6.fib6_null_entry;\n\t\tnh = res->f6i->fib6_nh;\n\t}\nout:\n\tres->nh = nh;\n\tres->fib6_type = res->f6i->fib6_type;\n\tres->fib6_flags = res->f6i->fib6_flags;\n\treturn;\n\nout_blackhole:\n\tres->fib6_flags |= RTF_REJECT;\n\tres->fib6_type = RTN_BLACKHOLE;\n\tres->nh = nh;\n}\n\n#ifdef CONFIG_IPV6_ROUTER_PREF\nstruct __rt6_probe_work {\n\tstruct work_struct work;\n\tstruct in6_addr target;\n\tstruct net_device *dev;\n\tnetdevice_tracker dev_tracker;\n};\n\nstatic void rt6_probe_deferred(struct work_struct *w)\n{\n\tstruct in6_addr mcaddr;\n\tstruct __rt6_probe_work *work =\n\t\tcontainer_of(w, struct __rt6_probe_work, work);\n\n\taddrconf_addr_solict_mult(&work->target, &mcaddr);\n\tndisc_send_ns(work->dev, &work->target, &mcaddr, NULL, 0);\n\tnetdev_put(work->dev, &work->dev_tracker);\n\tkfree(work);\n}\n\nstatic void rt6_probe(struct fib6_nh *fib6_nh)\n{\n\tstruct __rt6_probe_work *work = NULL;\n\tconst struct in6_addr *nh_gw;\n\tunsigned long last_probe;\n\tstruct neighbour *neigh;\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\n\t \n\tif (!fib6_nh->fib_nh_gw_family)\n\t\treturn;\n\n\tnh_gw = &fib6_nh->fib_nh_gw6;\n\tdev = fib6_nh->fib_nh_dev;\n\trcu_read_lock();\n\tlast_probe = READ_ONCE(fib6_nh->last_probe);\n\tidev = __in6_dev_get(dev);\n\tneigh = __ipv6_neigh_lookup_noref(dev, nh_gw);\n\tif (neigh) {\n\t\tif (READ_ONCE(neigh->nud_state) & NUD_VALID)\n\t\t\tgoto out;\n\n\t\twrite_lock_bh(&neigh->lock);\n\t\tif (!(neigh->nud_state & NUD_VALID) &&\n\t\t    time_after(jiffies,\n\t\t\t       neigh->updated + idev->cnf.rtr_probe_interval)) {\n\t\t\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\t\t\tif (work)\n\t\t\t\t__neigh_set_probe_once(neigh);\n\t\t}\n\t\twrite_unlock_bh(&neigh->lock);\n\t} else if (time_after(jiffies, last_probe +\n\t\t\t\t       idev->cnf.rtr_probe_interval)) {\n\t\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\t}\n\n\tif (!work || cmpxchg(&fib6_nh->last_probe,\n\t\t\t     last_probe, jiffies) != last_probe) {\n\t\tkfree(work);\n\t} else {\n\t\tINIT_WORK(&work->work, rt6_probe_deferred);\n\t\twork->target = *nh_gw;\n\t\tnetdev_hold(dev, &work->dev_tracker, GFP_ATOMIC);\n\t\twork->dev = dev;\n\t\tschedule_work(&work->work);\n\t}\n\nout:\n\trcu_read_unlock();\n}\n#else\nstatic inline void rt6_probe(struct fib6_nh *fib6_nh)\n{\n}\n#endif\n\n \nstatic enum rt6_nud_state rt6_check_neigh(const struct fib6_nh *fib6_nh)\n{\n\tenum rt6_nud_state ret = RT6_NUD_FAIL_HARD;\n\tstruct neighbour *neigh;\n\n\trcu_read_lock();\n\tneigh = __ipv6_neigh_lookup_noref(fib6_nh->fib_nh_dev,\n\t\t\t\t\t  &fib6_nh->fib_nh_gw6);\n\tif (neigh) {\n\t\tu8 nud_state = READ_ONCE(neigh->nud_state);\n\n\t\tif (nud_state & NUD_VALID)\n\t\t\tret = RT6_NUD_SUCCEED;\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\t\telse if (!(nud_state & NUD_FAILED))\n\t\t\tret = RT6_NUD_SUCCEED;\n\t\telse\n\t\t\tret = RT6_NUD_FAIL_PROBE;\n#endif\n\t} else {\n\t\tret = IS_ENABLED(CONFIG_IPV6_ROUTER_PREF) ?\n\t\t      RT6_NUD_SUCCEED : RT6_NUD_FAIL_DO_RR;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic int rt6_score_route(const struct fib6_nh *nh, u32 fib6_flags, int oif,\n\t\t\t   int strict)\n{\n\tint m = 0;\n\n\tif (!oif || nh->fib_nh_dev->ifindex == oif)\n\t\tm = 2;\n\n\tif (!m && (strict & RT6_LOOKUP_F_IFACE))\n\t\treturn RT6_NUD_FAIL_HARD;\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\tm |= IPV6_DECODE_PREF(IPV6_EXTRACT_PREF(fib6_flags)) << 2;\n#endif\n\tif ((strict & RT6_LOOKUP_F_REACHABLE) &&\n\t    !(fib6_flags & RTF_NONEXTHOP) && nh->fib_nh_gw_family) {\n\t\tint n = rt6_check_neigh(nh);\n\t\tif (n < 0)\n\t\t\treturn n;\n\t}\n\treturn m;\n}\n\nstatic bool find_match(struct fib6_nh *nh, u32 fib6_flags,\n\t\t       int oif, int strict, int *mpri, bool *do_rr)\n{\n\tbool match_do_rr = false;\n\tbool rc = false;\n\tint m;\n\n\tif (nh->fib_nh_flags & RTNH_F_DEAD)\n\t\tgoto out;\n\n\tif (ip6_ignore_linkdown(nh->fib_nh_dev) &&\n\t    nh->fib_nh_flags & RTNH_F_LINKDOWN &&\n\t    !(strict & RT6_LOOKUP_F_IGNORE_LINKSTATE))\n\t\tgoto out;\n\n\tm = rt6_score_route(nh, fib6_flags, oif, strict);\n\tif (m == RT6_NUD_FAIL_DO_RR) {\n\t\tmatch_do_rr = true;\n\t\tm = 0;  \n\t} else if (m == RT6_NUD_FAIL_HARD) {\n\t\tgoto out;\n\t}\n\n\tif (strict & RT6_LOOKUP_F_REACHABLE)\n\t\trt6_probe(nh);\n\n\t \n\tif (m > *mpri) {\n\t\t*do_rr = match_do_rr;\n\t\t*mpri = m;\n\t\trc = true;\n\t}\nout:\n\treturn rc;\n}\n\nstruct fib6_nh_frl_arg {\n\tu32\t\tflags;\n\tint\t\toif;\n\tint\t\tstrict;\n\tint\t\t*mpri;\n\tbool\t\t*do_rr;\n\tstruct fib6_nh\t*nh;\n};\n\nstatic int rt6_nh_find_match(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_frl_arg *arg = _arg;\n\n\targ->nh = nh;\n\treturn find_match(nh, arg->flags, arg->oif, arg->strict,\n\t\t\t  arg->mpri, arg->do_rr);\n}\n\nstatic void __find_rr_leaf(struct fib6_info *f6i_start,\n\t\t\t   struct fib6_info *nomatch, u32 metric,\n\t\t\t   struct fib6_result *res, struct fib6_info **cont,\n\t\t\t   int oif, int strict, bool *do_rr, int *mpri)\n{\n\tstruct fib6_info *f6i;\n\n\tfor (f6i = f6i_start;\n\t     f6i && f6i != nomatch;\n\t     f6i = rcu_dereference(f6i->fib6_next)) {\n\t\tbool matched = false;\n\t\tstruct fib6_nh *nh;\n\n\t\tif (cont && f6i->fib6_metric != metric) {\n\t\t\t*cont = f6i;\n\t\t\treturn;\n\t\t}\n\n\t\tif (fib6_check_expired(f6i))\n\t\t\tcontinue;\n\n\t\tif (unlikely(f6i->nh)) {\n\t\t\tstruct fib6_nh_frl_arg arg = {\n\t\t\t\t.flags  = f6i->fib6_flags,\n\t\t\t\t.oif    = oif,\n\t\t\t\t.strict = strict,\n\t\t\t\t.mpri   = mpri,\n\t\t\t\t.do_rr  = do_rr\n\t\t\t};\n\n\t\t\tif (nexthop_is_blackhole(f6i->nh)) {\n\t\t\t\tres->fib6_flags = RTF_REJECT;\n\t\t\t\tres->fib6_type = RTN_BLACKHOLE;\n\t\t\t\tres->f6i = f6i;\n\t\t\t\tres->nh = nexthop_fib6_nh(f6i->nh);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (nexthop_for_each_fib6_nh(f6i->nh, rt6_nh_find_match,\n\t\t\t\t\t\t     &arg)) {\n\t\t\t\tmatched = true;\n\t\t\t\tnh = arg.nh;\n\t\t\t}\n\t\t} else {\n\t\t\tnh = f6i->fib6_nh;\n\t\t\tif (find_match(nh, f6i->fib6_flags, oif, strict,\n\t\t\t\t       mpri, do_rr))\n\t\t\t\tmatched = true;\n\t\t}\n\t\tif (matched) {\n\t\t\tres->f6i = f6i;\n\t\t\tres->nh = nh;\n\t\t\tres->fib6_flags = f6i->fib6_flags;\n\t\t\tres->fib6_type = f6i->fib6_type;\n\t\t}\n\t}\n}\n\nstatic void find_rr_leaf(struct fib6_node *fn, struct fib6_info *leaf,\n\t\t\t struct fib6_info *rr_head, int oif, int strict,\n\t\t\t bool *do_rr, struct fib6_result *res)\n{\n\tu32 metric = rr_head->fib6_metric;\n\tstruct fib6_info *cont = NULL;\n\tint mpri = -1;\n\n\t__find_rr_leaf(rr_head, NULL, metric, res, &cont,\n\t\t       oif, strict, do_rr, &mpri);\n\n\t__find_rr_leaf(leaf, rr_head, metric, res, &cont,\n\t\t       oif, strict, do_rr, &mpri);\n\n\tif (res->f6i || !cont)\n\t\treturn;\n\n\t__find_rr_leaf(cont, NULL, metric, res, NULL,\n\t\t       oif, strict, do_rr, &mpri);\n}\n\nstatic void rt6_select(struct net *net, struct fib6_node *fn, int oif,\n\t\t       struct fib6_result *res, int strict)\n{\n\tstruct fib6_info *leaf = rcu_dereference(fn->leaf);\n\tstruct fib6_info *rt0;\n\tbool do_rr = false;\n\tint key_plen;\n\n\t \n\tres->f6i = NULL;\n\n\tif (!leaf || leaf == net->ipv6.fib6_null_entry)\n\t\tgoto out;\n\n\trt0 = rcu_dereference(fn->rr_ptr);\n\tif (!rt0)\n\t\trt0 = leaf;\n\n\t \n\tkey_plen = rt0->fib6_dst.plen;\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (rt0->fib6_src.plen)\n\t\tkey_plen = rt0->fib6_src.plen;\n#endif\n\tif (fn->fn_bit != key_plen)\n\t\tgoto out;\n\n\tfind_rr_leaf(fn, leaf, rt0, oif, strict, &do_rr, res);\n\tif (do_rr) {\n\t\tstruct fib6_info *next = rcu_dereference(rt0->fib6_next);\n\n\t\t \n\t\tif (!next || next->fib6_metric != rt0->fib6_metric)\n\t\t\tnext = leaf;\n\n\t\tif (next != rt0) {\n\t\t\tspin_lock_bh(&leaf->fib6_table->tb6_lock);\n\t\t\t \n\t\t\tif (next->fib6_node)\n\t\t\t\trcu_assign_pointer(fn->rr_ptr, next);\n\t\t\tspin_unlock_bh(&leaf->fib6_table->tb6_lock);\n\t\t}\n\t}\n\nout:\n\tif (!res->f6i) {\n\t\tres->f6i = net->ipv6.fib6_null_entry;\n\t\tres->nh = res->f6i->fib6_nh;\n\t\tres->fib6_flags = res->f6i->fib6_flags;\n\t\tres->fib6_type = res->f6i->fib6_type;\n\t}\n}\n\nstatic bool rt6_is_gw_or_nonexthop(const struct fib6_result *res)\n{\n\treturn (res->f6i->fib6_flags & RTF_NONEXTHOP) ||\n\t       res->nh->fib_nh_gw_family;\n}\n\n#ifdef CONFIG_IPV6_ROUTE_INFO\nint rt6_route_rcv(struct net_device *dev, u8 *opt, int len,\n\t\t  const struct in6_addr *gwaddr)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct route_info *rinfo = (struct route_info *) opt;\n\tstruct in6_addr prefix_buf, *prefix;\n\tunsigned int pref;\n\tunsigned long lifetime;\n\tstruct fib6_info *rt;\n\n\tif (len < sizeof(struct route_info)) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rinfo->length > 3) {\n\t\treturn -EINVAL;\n\t} else if (rinfo->prefix_len > 128) {\n\t\treturn -EINVAL;\n\t} else if (rinfo->prefix_len > 64) {\n\t\tif (rinfo->length < 2) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (rinfo->prefix_len > 0) {\n\t\tif (rinfo->length < 1) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpref = rinfo->route_pref;\n\tif (pref == ICMPV6_ROUTER_PREF_INVALID)\n\t\treturn -EINVAL;\n\n\tlifetime = addrconf_timeout_fixup(ntohl(rinfo->lifetime), HZ);\n\n\tif (rinfo->length == 3)\n\t\tprefix = (struct in6_addr *)rinfo->prefix;\n\telse {\n\t\t \n\t\tipv6_addr_prefix(&prefix_buf,\n\t\t\t\t (struct in6_addr *)rinfo->prefix,\n\t\t\t\t rinfo->prefix_len);\n\t\tprefix = &prefix_buf;\n\t}\n\n\tif (rinfo->prefix_len == 0)\n\t\trt = rt6_get_dflt_router(net, gwaddr, dev);\n\telse\n\t\trt = rt6_get_route_info(net, prefix, rinfo->prefix_len,\n\t\t\t\t\tgwaddr, dev);\n\n\tif (rt && !lifetime) {\n\t\tip6_del_rt(net, rt, false);\n\t\trt = NULL;\n\t}\n\n\tif (!rt && lifetime)\n\t\trt = rt6_add_route_info(net, prefix, rinfo->prefix_len, gwaddr,\n\t\t\t\t\tdev, pref);\n\telse if (rt)\n\t\trt->fib6_flags = RTF_ROUTEINFO |\n\t\t\t\t (rt->fib6_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);\n\n\tif (rt) {\n\t\tif (!addrconf_finite_timeout(lifetime))\n\t\t\tfib6_clean_expires(rt);\n\t\telse\n\t\t\tfib6_set_expires(rt, jiffies + HZ * lifetime);\n\n\t\tfib6_info_release(rt);\n\t}\n\treturn 0;\n}\n#endif\n\n \n\n \nstatic struct net_device *ip6_rt_get_dev_rcu(const struct fib6_result *res)\n{\n\tstruct net_device *dev = res->nh->fib_nh_dev;\n\n\tif (res->fib6_flags & (RTF_LOCAL | RTF_ANYCAST)) {\n\t\t \n\t\tif (netif_is_l3_slave(dev) &&\n\t\t    !rt6_need_strict(&res->f6i->fib6_dst.addr))\n\t\t\tdev = l3mdev_master_dev_rcu(dev);\n\t\telse if (!netif_is_l3_master(dev))\n\t\t\tdev = dev_net(dev)->loopback_dev;\n\t\t \n\t}\n\n\treturn dev;\n}\n\nstatic const int fib6_prop[RTN_MAX + 1] = {\n\t[RTN_UNSPEC]\t= 0,\n\t[RTN_UNICAST]\t= 0,\n\t[RTN_LOCAL]\t= 0,\n\t[RTN_BROADCAST]\t= 0,\n\t[RTN_ANYCAST]\t= 0,\n\t[RTN_MULTICAST]\t= 0,\n\t[RTN_BLACKHOLE]\t= -EINVAL,\n\t[RTN_UNREACHABLE] = -EHOSTUNREACH,\n\t[RTN_PROHIBIT]\t= -EACCES,\n\t[RTN_THROW]\t= -EAGAIN,\n\t[RTN_NAT]\t= -EINVAL,\n\t[RTN_XRESOLVE]\t= -EINVAL,\n};\n\nstatic int ip6_rt_type_to_error(u8 fib6_type)\n{\n\treturn fib6_prop[fib6_type];\n}\n\nstatic unsigned short fib6_info_dst_flags(struct fib6_info *rt)\n{\n\tunsigned short flags = 0;\n\n\tif (rt->dst_nocount)\n\t\tflags |= DST_NOCOUNT;\n\tif (rt->dst_nopolicy)\n\t\tflags |= DST_NOPOLICY;\n\n\treturn flags;\n}\n\nstatic void ip6_rt_init_dst_reject(struct rt6_info *rt, u8 fib6_type)\n{\n\trt->dst.error = ip6_rt_type_to_error(fib6_type);\n\n\tswitch (fib6_type) {\n\tcase RTN_BLACKHOLE:\n\t\trt->dst.output = dst_discard_out;\n\t\trt->dst.input = dst_discard;\n\t\tbreak;\n\tcase RTN_PROHIBIT:\n\t\trt->dst.output = ip6_pkt_prohibit_out;\n\t\trt->dst.input = ip6_pkt_prohibit;\n\t\tbreak;\n\tcase RTN_THROW:\n\tcase RTN_UNREACHABLE:\n\tdefault:\n\t\trt->dst.output = ip6_pkt_discard_out;\n\t\trt->dst.input = ip6_pkt_discard;\n\t\tbreak;\n\t}\n}\n\nstatic void ip6_rt_init_dst(struct rt6_info *rt, const struct fib6_result *res)\n{\n\tstruct fib6_info *f6i = res->f6i;\n\n\tif (res->fib6_flags & RTF_REJECT) {\n\t\tip6_rt_init_dst_reject(rt, res->fib6_type);\n\t\treturn;\n\t}\n\n\trt->dst.error = 0;\n\trt->dst.output = ip6_output;\n\n\tif (res->fib6_type == RTN_LOCAL || res->fib6_type == RTN_ANYCAST) {\n\t\trt->dst.input = ip6_input;\n\t} else if (ipv6_addr_type(&f6i->fib6_dst.addr) & IPV6_ADDR_MULTICAST) {\n\t\trt->dst.input = ip6_mc_input;\n\t} else {\n\t\trt->dst.input = ip6_forward;\n\t}\n\n\tif (res->nh->fib_nh_lws) {\n\t\trt->dst.lwtstate = lwtstate_get(res->nh->fib_nh_lws);\n\t\tlwtunnel_set_redirect(&rt->dst);\n\t}\n\n\trt->dst.lastuse = jiffies;\n}\n\n \nstatic void rt6_set_from(struct rt6_info *rt, struct fib6_info *from)\n{\n\trt->rt6i_flags &= ~RTF_EXPIRES;\n\trcu_assign_pointer(rt->from, from);\n\tip_dst_init_metrics(&rt->dst, from->fib6_metrics);\n}\n\n \nstatic void ip6_rt_copy_init(struct rt6_info *rt, const struct fib6_result *res)\n{\n\tconst struct fib6_nh *nh = res->nh;\n\tconst struct net_device *dev = nh->fib_nh_dev;\n\tstruct fib6_info *f6i = res->f6i;\n\n\tip6_rt_init_dst(rt, res);\n\n\trt->rt6i_dst = f6i->fib6_dst;\n\trt->rt6i_idev = dev ? in6_dev_get(dev) : NULL;\n\trt->rt6i_flags = res->fib6_flags;\n\tif (nh->fib_nh_gw_family) {\n\t\trt->rt6i_gateway = nh->fib_nh_gw6;\n\t\trt->rt6i_flags |= RTF_GATEWAY;\n\t}\n\trt6_set_from(rt, f6i);\n#ifdef CONFIG_IPV6_SUBTREES\n\trt->rt6i_src = f6i->fib6_src;\n#endif\n}\n\nstatic struct fib6_node* fib6_backtrack(struct fib6_node *fn,\n\t\t\t\t\tstruct in6_addr *saddr)\n{\n\tstruct fib6_node *pn, *sn;\n\twhile (1) {\n\t\tif (fn->fn_flags & RTN_TL_ROOT)\n\t\t\treturn NULL;\n\t\tpn = rcu_dereference(fn->parent);\n\t\tsn = FIB6_SUBTREE(pn);\n\t\tif (sn && sn != fn)\n\t\t\tfn = fib6_node_lookup(sn, NULL, saddr);\n\t\telse\n\t\t\tfn = pn;\n\t\tif (fn->fn_flags & RTN_RTINFO)\n\t\t\treturn fn;\n\t}\n}\n\nstatic bool ip6_hold_safe(struct net *net, struct rt6_info **prt)\n{\n\tstruct rt6_info *rt = *prt;\n\n\tif (dst_hold_safe(&rt->dst))\n\t\treturn true;\n\tif (net) {\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tdst_hold(&rt->dst);\n\t} else {\n\t\trt = NULL;\n\t}\n\t*prt = rt;\n\treturn false;\n}\n\n \nstatic struct rt6_info *ip6_create_rt_rcu(const struct fib6_result *res)\n{\n\tstruct net_device *dev = res->nh->fib_nh_dev;\n\tstruct fib6_info *f6i = res->f6i;\n\tunsigned short flags;\n\tstruct rt6_info *nrt;\n\n\tif (!fib6_info_hold_safe(f6i))\n\t\tgoto fallback;\n\n\tflags = fib6_info_dst_flags(f6i);\n\tnrt = ip6_dst_alloc(dev_net(dev), dev, flags);\n\tif (!nrt) {\n\t\tfib6_info_release(f6i);\n\t\tgoto fallback;\n\t}\n\n\tip6_rt_copy_init(nrt, res);\n\treturn nrt;\n\nfallback:\n\tnrt = dev_net(dev)->ipv6.ip6_null_entry;\n\tdst_hold(&nrt->dst);\n\treturn nrt;\n}\n\nINDIRECT_CALLABLE_SCOPE struct rt6_info *ip6_pol_route_lookup(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags)\n{\n\tstruct fib6_result res = {};\n\tstruct fib6_node *fn;\n\tstruct rt6_info *rt;\n\n\trcu_read_lock();\n\tfn = fib6_node_lookup(&table->tb6_root, &fl6->daddr, &fl6->saddr);\nrestart:\n\tres.f6i = rcu_dereference(fn->leaf);\n\tif (!res.f6i)\n\t\tres.f6i = net->ipv6.fib6_null_entry;\n\telse\n\t\trt6_device_match(net, &res, &fl6->saddr, fl6->flowi6_oif,\n\t\t\t\t flags);\n\n\tif (res.f6i == net->ipv6.fib6_null_entry) {\n\t\tfn = fib6_backtrack(fn, &fl6->saddr);\n\t\tif (fn)\n\t\t\tgoto restart;\n\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tdst_hold(&rt->dst);\n\t\tgoto out;\n\t} else if (res.fib6_flags & RTF_REJECT) {\n\t\tgoto do_create;\n\t}\n\n\tfib6_select_path(net, &res, fl6, fl6->flowi6_oif,\n\t\t\t fl6->flowi6_oif != 0, skb, flags);\n\n\t \n\trt = rt6_find_cached_rt(&res, &fl6->daddr, &fl6->saddr);\n\tif (rt) {\n\t\tif (ip6_hold_safe(net, &rt))\n\t\t\tdst_use_noref(&rt->dst, jiffies);\n\t} else {\ndo_create:\n\t\trt = ip6_create_rt_rcu(&res);\n\t}\n\nout:\n\ttrace_fib6_table_lookup(net, &res, table, fl6);\n\n\trcu_read_unlock();\n\n\treturn rt;\n}\n\nstruct dst_entry *ip6_route_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb, int flags)\n{\n\treturn fib6_rule_lookup(net, fl6, skb, flags, ip6_pol_route_lookup);\n}\nEXPORT_SYMBOL_GPL(ip6_route_lookup);\n\nstruct rt6_info *rt6_lookup(struct net *net, const struct in6_addr *daddr,\n\t\t\t    const struct in6_addr *saddr, int oif,\n\t\t\t    const struct sk_buff *skb, int strict)\n{\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_oif = oif,\n\t\t.daddr = *daddr,\n\t};\n\tstruct dst_entry *dst;\n\tint flags = strict ? RT6_LOOKUP_F_IFACE : 0;\n\n\tif (saddr) {\n\t\tmemcpy(&fl6.saddr, saddr, sizeof(*saddr));\n\t\tflags |= RT6_LOOKUP_F_HAS_SADDR;\n\t}\n\n\tdst = fib6_rule_lookup(net, &fl6, skb, flags, ip6_pol_route_lookup);\n\tif (dst->error == 0)\n\t\treturn (struct rt6_info *) dst;\n\n\tdst_release(dst);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(rt6_lookup);\n\n \n\nstatic int __ip6_ins_rt(struct fib6_info *rt, struct nl_info *info,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tint err;\n\tstruct fib6_table *table;\n\n\ttable = rt->fib6_table;\n\tspin_lock_bh(&table->tb6_lock);\n\terr = fib6_add(&table->tb6_root, rt, info, extack);\n\tspin_unlock_bh(&table->tb6_lock);\n\n\treturn err;\n}\n\nint ip6_ins_rt(struct net *net, struct fib6_info *rt)\n{\n\tstruct nl_info info = {\t.nl_net = net, };\n\n\treturn __ip6_ins_rt(rt, &info, NULL);\n}\n\nstatic struct rt6_info *ip6_rt_cache_alloc(const struct fib6_result *res,\n\t\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t\t   const struct in6_addr *saddr)\n{\n\tstruct fib6_info *f6i = res->f6i;\n\tstruct net_device *dev;\n\tstruct rt6_info *rt;\n\n\t \n\n\tif (!fib6_info_hold_safe(f6i))\n\t\treturn NULL;\n\n\tdev = ip6_rt_get_dev_rcu(res);\n\trt = ip6_dst_alloc(dev_net(dev), dev, 0);\n\tif (!rt) {\n\t\tfib6_info_release(f6i);\n\t\treturn NULL;\n\t}\n\n\tip6_rt_copy_init(rt, res);\n\trt->rt6i_flags |= RTF_CACHE;\n\trt->rt6i_dst.addr = *daddr;\n\trt->rt6i_dst.plen = 128;\n\n\tif (!rt6_is_gw_or_nonexthop(res)) {\n\t\tif (f6i->fib6_dst.plen != 128 &&\n\t\t    ipv6_addr_equal(&f6i->fib6_dst.addr, daddr))\n\t\t\trt->rt6i_flags |= RTF_ANYCAST;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tif (rt->rt6i_src.plen && saddr) {\n\t\t\trt->rt6i_src.addr = *saddr;\n\t\t\trt->rt6i_src.plen = 128;\n\t\t}\n#endif\n\t}\n\n\treturn rt;\n}\n\nstatic struct rt6_info *ip6_rt_pcpu_alloc(const struct fib6_result *res)\n{\n\tstruct fib6_info *f6i = res->f6i;\n\tunsigned short flags = fib6_info_dst_flags(f6i);\n\tstruct net_device *dev;\n\tstruct rt6_info *pcpu_rt;\n\n\tif (!fib6_info_hold_safe(f6i))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tdev = ip6_rt_get_dev_rcu(res);\n\tpcpu_rt = ip6_dst_alloc(dev_net(dev), dev, flags | DST_NOCOUNT);\n\trcu_read_unlock();\n\tif (!pcpu_rt) {\n\t\tfib6_info_release(f6i);\n\t\treturn NULL;\n\t}\n\tip6_rt_copy_init(pcpu_rt, res);\n\tpcpu_rt->rt6i_flags |= RTF_PCPU;\n\n\tif (f6i->nh)\n\t\tpcpu_rt->sernum = rt_genid_ipv6(dev_net(dev));\n\n\treturn pcpu_rt;\n}\n\nstatic bool rt6_is_valid(const struct rt6_info *rt6)\n{\n\treturn rt6->sernum == rt_genid_ipv6(dev_net(rt6->dst.dev));\n}\n\n \nstatic struct rt6_info *rt6_get_pcpu_route(const struct fib6_result *res)\n{\n\tstruct rt6_info *pcpu_rt;\n\n\tpcpu_rt = this_cpu_read(*res->nh->rt6i_pcpu);\n\n\tif (pcpu_rt && pcpu_rt->sernum && !rt6_is_valid(pcpu_rt)) {\n\t\tstruct rt6_info *prev, **p;\n\n\t\tp = this_cpu_ptr(res->nh->rt6i_pcpu);\n\t\tprev = xchg(p, NULL);\n\t\tif (prev) {\n\t\t\tdst_dev_put(&prev->dst);\n\t\t\tdst_release(&prev->dst);\n\t\t}\n\n\t\tpcpu_rt = NULL;\n\t}\n\n\treturn pcpu_rt;\n}\n\nstatic struct rt6_info *rt6_make_pcpu_route(struct net *net,\n\t\t\t\t\t    const struct fib6_result *res)\n{\n\tstruct rt6_info *pcpu_rt, *prev, **p;\n\n\tpcpu_rt = ip6_rt_pcpu_alloc(res);\n\tif (!pcpu_rt)\n\t\treturn NULL;\n\n\tp = this_cpu_ptr(res->nh->rt6i_pcpu);\n\tprev = cmpxchg(p, NULL, pcpu_rt);\n\tBUG_ON(prev);\n\n\tif (res->f6i->fib6_destroying) {\n\t\tstruct fib6_info *from;\n\n\t\tfrom = xchg((__force struct fib6_info **)&pcpu_rt->from, NULL);\n\t\tfib6_info_release(from);\n\t}\n\n\treturn pcpu_rt;\n}\n\n \nstatic DEFINE_SPINLOCK(rt6_exception_lock);\n\n \nstatic void rt6_remove_exception(struct rt6_exception_bucket *bucket,\n\t\t\t\t struct rt6_exception *rt6_ex)\n{\n\tstruct fib6_info *from;\n\tstruct net *net;\n\n\tif (!bucket || !rt6_ex)\n\t\treturn;\n\n\tnet = dev_net(rt6_ex->rt6i->dst.dev);\n\tnet->ipv6.rt6_stats->fib_rt_cache--;\n\n\t \n\tfrom = xchg((__force struct fib6_info **)&rt6_ex->rt6i->from, NULL);\n\tfib6_info_release(from);\n\tdst_dev_put(&rt6_ex->rt6i->dst);\n\n\thlist_del_rcu(&rt6_ex->hlist);\n\tdst_release(&rt6_ex->rt6i->dst);\n\tkfree_rcu(rt6_ex, rcu);\n\tWARN_ON_ONCE(!bucket->depth);\n\tbucket->depth--;\n}\n\n \nstatic void rt6_exception_remove_oldest(struct rt6_exception_bucket *bucket)\n{\n\tstruct rt6_exception *rt6_ex, *oldest = NULL;\n\n\tif (!bucket)\n\t\treturn;\n\n\thlist_for_each_entry(rt6_ex, &bucket->chain, hlist) {\n\t\tif (!oldest || time_before(rt6_ex->stamp, oldest->stamp))\n\t\t\toldest = rt6_ex;\n\t}\n\trt6_remove_exception(bucket, oldest);\n}\n\nstatic u32 rt6_exception_hash(const struct in6_addr *dst,\n\t\t\t      const struct in6_addr *src)\n{\n\tstatic siphash_aligned_key_t rt6_exception_key;\n\tstruct {\n\t\tstruct in6_addr dst;\n\t\tstruct in6_addr src;\n\t} __aligned(SIPHASH_ALIGNMENT) combined = {\n\t\t.dst = *dst,\n\t};\n\tu64 val;\n\n\tnet_get_random_once(&rt6_exception_key, sizeof(rt6_exception_key));\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (src)\n\t\tcombined.src = *src;\n#endif\n\tval = siphash(&combined, sizeof(combined), &rt6_exception_key);\n\n\treturn hash_64(val, FIB6_EXCEPTION_BUCKET_SIZE_SHIFT);\n}\n\n \nstatic struct rt6_exception *\n__rt6_find_exception_spinlock(struct rt6_exception_bucket **bucket,\n\t\t\t      const struct in6_addr *daddr,\n\t\t\t      const struct in6_addr *saddr)\n{\n\tstruct rt6_exception *rt6_ex;\n\tu32 hval;\n\n\tif (!(*bucket) || !daddr)\n\t\treturn NULL;\n\n\thval = rt6_exception_hash(daddr, saddr);\n\t*bucket += hval;\n\n\thlist_for_each_entry(rt6_ex, &(*bucket)->chain, hlist) {\n\t\tstruct rt6_info *rt6 = rt6_ex->rt6i;\n\t\tbool matched = ipv6_addr_equal(daddr, &rt6->rt6i_dst.addr);\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tif (matched && saddr)\n\t\t\tmatched = ipv6_addr_equal(saddr, &rt6->rt6i_src.addr);\n#endif\n\t\tif (matched)\n\t\t\treturn rt6_ex;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct rt6_exception *\n__rt6_find_exception_rcu(struct rt6_exception_bucket **bucket,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tstruct rt6_exception *rt6_ex;\n\tu32 hval;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tif (!(*bucket) || !daddr)\n\t\treturn NULL;\n\n\thval = rt6_exception_hash(daddr, saddr);\n\t*bucket += hval;\n\n\thlist_for_each_entry_rcu(rt6_ex, &(*bucket)->chain, hlist) {\n\t\tstruct rt6_info *rt6 = rt6_ex->rt6i;\n\t\tbool matched = ipv6_addr_equal(daddr, &rt6->rt6i_dst.addr);\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tif (matched && saddr)\n\t\t\tmatched = ipv6_addr_equal(saddr, &rt6->rt6i_src.addr);\n#endif\n\t\tif (matched)\n\t\t\treturn rt6_ex;\n\t}\n\treturn NULL;\n}\n\nstatic unsigned int fib6_mtu(const struct fib6_result *res)\n{\n\tconst struct fib6_nh *nh = res->nh;\n\tunsigned int mtu;\n\n\tif (res->f6i->fib6_pmtu) {\n\t\tmtu = res->f6i->fib6_pmtu;\n\t} else {\n\t\tstruct net_device *dev = nh->fib_nh_dev;\n\t\tstruct inet6_dev *idev;\n\n\t\trcu_read_lock();\n\t\tidev = __in6_dev_get(dev);\n\t\tmtu = idev->cnf.mtu6;\n\t\trcu_read_unlock();\n\t}\n\n\tmtu = min_t(unsigned int, mtu, IP6_MAX_MTU);\n\n\treturn mtu - lwtunnel_headroom(nh->fib_nh_lws, mtu);\n}\n\n#define FIB6_EXCEPTION_BUCKET_FLUSHED  0x1UL\n\n \nstatic\nstruct rt6_exception_bucket *fib6_nh_get_excptn_bucket(const struct fib6_nh *nh,\n\t\t\t\t\t\t       spinlock_t *lock)\n{\n\tstruct rt6_exception_bucket *bucket;\n\n\tif (lock)\n\t\tbucket = rcu_dereference_protected(nh->rt6i_exception_bucket,\n\t\t\t\t\t\t   lockdep_is_held(lock));\n\telse\n\t\tbucket = rcu_dereference(nh->rt6i_exception_bucket);\n\n\t \n\tif (bucket) {\n\t\tunsigned long p = (unsigned long)bucket;\n\n\t\tp &= ~FIB6_EXCEPTION_BUCKET_FLUSHED;\n\t\tbucket = (struct rt6_exception_bucket *)p;\n\t}\n\n\treturn bucket;\n}\n\nstatic bool fib6_nh_excptn_bucket_flushed(struct rt6_exception_bucket *bucket)\n{\n\tunsigned long p = (unsigned long)bucket;\n\n\treturn !!(p & FIB6_EXCEPTION_BUCKET_FLUSHED);\n}\n\n \nstatic void fib6_nh_excptn_bucket_set_flushed(struct fib6_nh *nh,\n\t\t\t\t\t      spinlock_t *lock)\n{\n\tstruct rt6_exception_bucket *bucket;\n\tunsigned long p;\n\n\tbucket = rcu_dereference_protected(nh->rt6i_exception_bucket,\n\t\t\t\t\t   lockdep_is_held(lock));\n\n\tp = (unsigned long)bucket;\n\tp |= FIB6_EXCEPTION_BUCKET_FLUSHED;\n\tbucket = (struct rt6_exception_bucket *)p;\n\trcu_assign_pointer(nh->rt6i_exception_bucket, bucket);\n}\n\nstatic int rt6_insert_exception(struct rt6_info *nrt,\n\t\t\t\tconst struct fib6_result *res)\n{\n\tstruct net *net = dev_net(nrt->dst.dev);\n\tstruct rt6_exception_bucket *bucket;\n\tstruct fib6_info *f6i = res->f6i;\n\tstruct in6_addr *src_key = NULL;\n\tstruct rt6_exception *rt6_ex;\n\tstruct fib6_nh *nh = res->nh;\n\tint max_depth;\n\tint err = 0;\n\n\tspin_lock_bh(&rt6_exception_lock);\n\n\tbucket = rcu_dereference_protected(nh->rt6i_exception_bucket,\n\t\t\t\t\t  lockdep_is_held(&rt6_exception_lock));\n\tif (!bucket) {\n\t\tbucket = kcalloc(FIB6_EXCEPTION_BUCKET_SIZE, sizeof(*bucket),\n\t\t\t\t GFP_ATOMIC);\n\t\tif (!bucket) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\trcu_assign_pointer(nh->rt6i_exception_bucket, bucket);\n\t} else if (fib6_nh_excptn_bucket_flushed(bucket)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t \n\tif (f6i->fib6_src.plen)\n\t\tsrc_key = &nrt->rt6i_src.addr;\n#endif\n\t \n\tif (dst_metric_raw(&nrt->dst, RTAX_MTU) >= fib6_mtu(res)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trt6_ex = __rt6_find_exception_spinlock(&bucket, &nrt->rt6i_dst.addr,\n\t\t\t\t\t       src_key);\n\tif (rt6_ex)\n\t\trt6_remove_exception(bucket, rt6_ex);\n\n\trt6_ex = kzalloc(sizeof(*rt6_ex), GFP_ATOMIC);\n\tif (!rt6_ex) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\trt6_ex->rt6i = nrt;\n\trt6_ex->stamp = jiffies;\n\thlist_add_head_rcu(&rt6_ex->hlist, &bucket->chain);\n\tbucket->depth++;\n\tnet->ipv6.rt6_stats->fib_rt_cache++;\n\n\t \n\tmax_depth = FIB6_MAX_DEPTH + get_random_u32_below(FIB6_MAX_DEPTH);\n\twhile (bucket->depth > max_depth)\n\t\trt6_exception_remove_oldest(bucket);\n\nout:\n\tspin_unlock_bh(&rt6_exception_lock);\n\n\t \n\tif (!err) {\n\t\tspin_lock_bh(&f6i->fib6_table->tb6_lock);\n\t\tfib6_update_sernum(net, f6i);\n\t\tspin_unlock_bh(&f6i->fib6_table->tb6_lock);\n\t\tfib6_force_start_gc(net);\n\t}\n\n\treturn err;\n}\n\nstatic void fib6_nh_flush_exceptions(struct fib6_nh *nh, struct fib6_info *from)\n{\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tstruct hlist_node *tmp;\n\tint i;\n\n\tspin_lock_bh(&rt6_exception_lock);\n\n\tbucket = fib6_nh_get_excptn_bucket(nh, &rt6_exception_lock);\n\tif (!bucket)\n\t\tgoto out;\n\n\t \n\tif (!from)\n\t\tfib6_nh_excptn_bucket_set_flushed(nh, &rt6_exception_lock);\n\n\tfor (i = 0; i < FIB6_EXCEPTION_BUCKET_SIZE; i++) {\n\t\thlist_for_each_entry_safe(rt6_ex, tmp, &bucket->chain, hlist) {\n\t\t\tif (!from ||\n\t\t\t    rcu_access_pointer(rt6_ex->rt6i->from) == from)\n\t\t\t\trt6_remove_exception(bucket, rt6_ex);\n\t\t}\n\t\tWARN_ON_ONCE(!from && bucket->depth);\n\t\tbucket++;\n\t}\nout:\n\tspin_unlock_bh(&rt6_exception_lock);\n}\n\nstatic int rt6_nh_flush_exceptions(struct fib6_nh *nh, void *arg)\n{\n\tstruct fib6_info *f6i = arg;\n\n\tfib6_nh_flush_exceptions(nh, f6i);\n\n\treturn 0;\n}\n\nvoid rt6_flush_exceptions(struct fib6_info *f6i)\n{\n\tif (f6i->nh)\n\t\tnexthop_for_each_fib6_nh(f6i->nh, rt6_nh_flush_exceptions,\n\t\t\t\t\t f6i);\n\telse\n\t\tfib6_nh_flush_exceptions(f6i->fib6_nh, f6i);\n}\n\n \nstatic struct rt6_info *rt6_find_cached_rt(const struct fib6_result *res,\n\t\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t\t   const struct in6_addr *saddr)\n{\n\tconst struct in6_addr *src_key = NULL;\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tstruct rt6_info *ret = NULL;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t \n\tif (res->f6i->fib6_src.plen)\n\t\tsrc_key = saddr;\nfind_ex:\n#endif\n\tbucket = fib6_nh_get_excptn_bucket(res->nh, NULL);\n\trt6_ex = __rt6_find_exception_rcu(&bucket, daddr, src_key);\n\n\tif (rt6_ex && !rt6_check_expired(rt6_ex->rt6i))\n\t\tret = rt6_ex->rt6i;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t \n\tif (!ret && src_key && src_key != &res->f6i->fib6_src.addr) {\n\t\tsrc_key = &res->f6i->fib6_src.addr;\n\t\tgoto find_ex;\n\t}\n#endif\n\n\treturn ret;\n}\n\n \nstatic int fib6_nh_remove_exception(const struct fib6_nh *nh, int plen,\n\t\t\t\t    const struct rt6_info *rt)\n{\n\tconst struct in6_addr *src_key = NULL;\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tint err;\n\n\tif (!rcu_access_pointer(nh->rt6i_exception_bucket))\n\t\treturn -ENOENT;\n\n\tspin_lock_bh(&rt6_exception_lock);\n\tbucket = fib6_nh_get_excptn_bucket(nh, &rt6_exception_lock);\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t \n\tif (plen)\n\t\tsrc_key = &rt->rt6i_src.addr;\n#endif\n\trt6_ex = __rt6_find_exception_spinlock(&bucket,\n\t\t\t\t\t       &rt->rt6i_dst.addr,\n\t\t\t\t\t       src_key);\n\tif (rt6_ex) {\n\t\trt6_remove_exception(bucket, rt6_ex);\n\t\terr = 0;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\n\tspin_unlock_bh(&rt6_exception_lock);\n\treturn err;\n}\n\nstruct fib6_nh_excptn_arg {\n\tstruct rt6_info\t*rt;\n\tint\t\tplen;\n};\n\nstatic int rt6_nh_remove_exception_rt(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_excptn_arg *arg = _arg;\n\tint err;\n\n\terr = fib6_nh_remove_exception(nh, arg->plen, arg->rt);\n\tif (err == 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int rt6_remove_exception_rt(struct rt6_info *rt)\n{\n\tstruct fib6_info *from;\n\n\tfrom = rcu_dereference(rt->from);\n\tif (!from || !(rt->rt6i_flags & RTF_CACHE))\n\t\treturn -EINVAL;\n\n\tif (from->nh) {\n\t\tstruct fib6_nh_excptn_arg arg = {\n\t\t\t.rt = rt,\n\t\t\t.plen = from->fib6_src.plen\n\t\t};\n\t\tint rc;\n\n\t\t \n\t\trc = nexthop_for_each_fib6_nh(from->nh,\n\t\t\t\t\t      rt6_nh_remove_exception_rt,\n\t\t\t\t\t      &arg);\n\t\treturn rc ? 0 : -ENOENT;\n\t}\n\n\treturn fib6_nh_remove_exception(from->fib6_nh,\n\t\t\t\t\tfrom->fib6_src.plen, rt);\n}\n\n \nstatic void fib6_nh_update_exception(const struct fib6_nh *nh, int plen,\n\t\t\t\t     const struct rt6_info *rt)\n{\n\tconst struct in6_addr *src_key = NULL;\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\n\tbucket = fib6_nh_get_excptn_bucket(nh, NULL);\n#ifdef CONFIG_IPV6_SUBTREES\n\t \n\tif (plen)\n\t\tsrc_key = &rt->rt6i_src.addr;\n#endif\n\trt6_ex = __rt6_find_exception_rcu(&bucket, &rt->rt6i_dst.addr, src_key);\n\tif (rt6_ex)\n\t\trt6_ex->stamp = jiffies;\n}\n\nstruct fib6_nh_match_arg {\n\tconst struct net_device *dev;\n\tconst struct in6_addr\t*gw;\n\tstruct fib6_nh\t\t*match;\n};\n\n \nstatic int fib6_nh_find_match(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_match_arg *arg = _arg;\n\n\tif (arg->dev != nh->fib_nh_dev ||\n\t    (arg->gw && !nh->fib_nh_gw_family) ||\n\t    (!arg->gw && nh->fib_nh_gw_family) ||\n\t    (arg->gw && !ipv6_addr_equal(arg->gw, &nh->fib_nh_gw6)))\n\t\treturn 0;\n\n\targ->match = nh;\n\n\t \n\treturn 1;\n}\n\nstatic void rt6_update_exception_stamp_rt(struct rt6_info *rt)\n{\n\tstruct fib6_info *from;\n\tstruct fib6_nh *fib6_nh;\n\n\trcu_read_lock();\n\n\tfrom = rcu_dereference(rt->from);\n\tif (!from || !(rt->rt6i_flags & RTF_CACHE))\n\t\tgoto unlock;\n\n\tif (from->nh) {\n\t\tstruct fib6_nh_match_arg arg = {\n\t\t\t.dev = rt->dst.dev,\n\t\t\t.gw = &rt->rt6i_gateway,\n\t\t};\n\n\t\tnexthop_for_each_fib6_nh(from->nh, fib6_nh_find_match, &arg);\n\n\t\tif (!arg.match)\n\t\t\tgoto unlock;\n\t\tfib6_nh = arg.match;\n\t} else {\n\t\tfib6_nh = from->fib6_nh;\n\t}\n\tfib6_nh_update_exception(fib6_nh, from->fib6_src.plen, rt);\nunlock:\n\trcu_read_unlock();\n}\n\nstatic bool rt6_mtu_change_route_allowed(struct inet6_dev *idev,\n\t\t\t\t\t struct rt6_info *rt, int mtu)\n{\n\t \n\n\tif (dst_mtu(&rt->dst) >= mtu)\n\t\treturn true;\n\n\tif (dst_mtu(&rt->dst) == idev->cnf.mtu6)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void rt6_exceptions_update_pmtu(struct inet6_dev *idev,\n\t\t\t\t       const struct fib6_nh *nh, int mtu)\n{\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tint i;\n\n\tbucket = fib6_nh_get_excptn_bucket(nh, &rt6_exception_lock);\n\tif (!bucket)\n\t\treturn;\n\n\tfor (i = 0; i < FIB6_EXCEPTION_BUCKET_SIZE; i++) {\n\t\thlist_for_each_entry(rt6_ex, &bucket->chain, hlist) {\n\t\t\tstruct rt6_info *entry = rt6_ex->rt6i;\n\n\t\t\t \n\t\t\tif (dst_metric_raw(&entry->dst, RTAX_MTU) &&\n\t\t\t    rt6_mtu_change_route_allowed(idev, entry, mtu))\n\t\t\t\tdst_metric_set(&entry->dst, RTAX_MTU, mtu);\n\t\t}\n\t\tbucket++;\n\t}\n}\n\n#define RTF_CACHE_GATEWAY\t(RTF_GATEWAY | RTF_CACHE)\n\nstatic void fib6_nh_exceptions_clean_tohost(const struct fib6_nh *nh,\n\t\t\t\t\t    const struct in6_addr *gateway)\n{\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tstruct hlist_node *tmp;\n\tint i;\n\n\tif (!rcu_access_pointer(nh->rt6i_exception_bucket))\n\t\treturn;\n\n\tspin_lock_bh(&rt6_exception_lock);\n\tbucket = fib6_nh_get_excptn_bucket(nh, &rt6_exception_lock);\n\tif (bucket) {\n\t\tfor (i = 0; i < FIB6_EXCEPTION_BUCKET_SIZE; i++) {\n\t\t\thlist_for_each_entry_safe(rt6_ex, tmp,\n\t\t\t\t\t\t  &bucket->chain, hlist) {\n\t\t\t\tstruct rt6_info *entry = rt6_ex->rt6i;\n\n\t\t\t\tif ((entry->rt6i_flags & RTF_CACHE_GATEWAY) ==\n\t\t\t\t    RTF_CACHE_GATEWAY &&\n\t\t\t\t    ipv6_addr_equal(gateway,\n\t\t\t\t\t\t    &entry->rt6i_gateway)) {\n\t\t\t\t\trt6_remove_exception(bucket, rt6_ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbucket++;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rt6_exception_lock);\n}\n\nstatic void rt6_age_examine_exception(struct rt6_exception_bucket *bucket,\n\t\t\t\t      struct rt6_exception *rt6_ex,\n\t\t\t\t      struct fib6_gc_args *gc_args,\n\t\t\t\t      unsigned long now)\n{\n\tstruct rt6_info *rt = rt6_ex->rt6i;\n\n\t \n\tif (!(rt->rt6i_flags & RTF_EXPIRES)) {\n\t\tif (time_after_eq(now, rt->dst.lastuse + gc_args->timeout)) {\n\t\t\tRT6_TRACE(\"aging clone %p\\n\", rt);\n\t\t\trt6_remove_exception(bucket, rt6_ex);\n\t\t\treturn;\n\t\t}\n\t} else if (time_after(jiffies, rt->dst.expires)) {\n\t\tRT6_TRACE(\"purging expired route %p\\n\", rt);\n\t\trt6_remove_exception(bucket, rt6_ex);\n\t\treturn;\n\t}\n\n\tif (rt->rt6i_flags & RTF_GATEWAY) {\n\t\tstruct neighbour *neigh;\n\n\t\tneigh = __ipv6_neigh_lookup_noref(rt->dst.dev, &rt->rt6i_gateway);\n\n\t\tif (!(neigh && (neigh->flags & NTF_ROUTER))) {\n\t\t\tRT6_TRACE(\"purging route %p via non-router but gateway\\n\",\n\t\t\t\t  rt);\n\t\t\trt6_remove_exception(bucket, rt6_ex);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tgc_args->more++;\n}\n\nstatic void fib6_nh_age_exceptions(const struct fib6_nh *nh,\n\t\t\t\t   struct fib6_gc_args *gc_args,\n\t\t\t\t   unsigned long now)\n{\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tstruct hlist_node *tmp;\n\tint i;\n\n\tif (!rcu_access_pointer(nh->rt6i_exception_bucket))\n\t\treturn;\n\n\trcu_read_lock_bh();\n\tspin_lock(&rt6_exception_lock);\n\tbucket = fib6_nh_get_excptn_bucket(nh, &rt6_exception_lock);\n\tif (bucket) {\n\t\tfor (i = 0; i < FIB6_EXCEPTION_BUCKET_SIZE; i++) {\n\t\t\thlist_for_each_entry_safe(rt6_ex, tmp,\n\t\t\t\t\t\t  &bucket->chain, hlist) {\n\t\t\t\trt6_age_examine_exception(bucket, rt6_ex,\n\t\t\t\t\t\t\t  gc_args, now);\n\t\t\t}\n\t\t\tbucket++;\n\t\t}\n\t}\n\tspin_unlock(&rt6_exception_lock);\n\trcu_read_unlock_bh();\n}\n\nstruct fib6_nh_age_excptn_arg {\n\tstruct fib6_gc_args\t*gc_args;\n\tunsigned long\t\tnow;\n};\n\nstatic int rt6_nh_age_exceptions(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_age_excptn_arg *arg = _arg;\n\n\tfib6_nh_age_exceptions(nh, arg->gc_args, arg->now);\n\treturn 0;\n}\n\nvoid rt6_age_exceptions(struct fib6_info *f6i,\n\t\t\tstruct fib6_gc_args *gc_args,\n\t\t\tunsigned long now)\n{\n\tif (f6i->nh) {\n\t\tstruct fib6_nh_age_excptn_arg arg = {\n\t\t\t.gc_args = gc_args,\n\t\t\t.now = now\n\t\t};\n\n\t\tnexthop_for_each_fib6_nh(f6i->nh, rt6_nh_age_exceptions,\n\t\t\t\t\t &arg);\n\t} else {\n\t\tfib6_nh_age_exceptions(f6i->fib6_nh, gc_args, now);\n\t}\n}\n\n \nint fib6_table_lookup(struct net *net, struct fib6_table *table, int oif,\n\t\t      struct flowi6 *fl6, struct fib6_result *res, int strict)\n{\n\tstruct fib6_node *fn, *saved_fn;\n\n\tfn = fib6_node_lookup(&table->tb6_root, &fl6->daddr, &fl6->saddr);\n\tsaved_fn = fn;\n\nredo_rt6_select:\n\trt6_select(net, fn, oif, res, strict);\n\tif (res->f6i == net->ipv6.fib6_null_entry) {\n\t\tfn = fib6_backtrack(fn, &fl6->saddr);\n\t\tif (fn)\n\t\t\tgoto redo_rt6_select;\n\t\telse if (strict & RT6_LOOKUP_F_REACHABLE) {\n\t\t\t \n\t\t\tstrict &= ~RT6_LOOKUP_F_REACHABLE;\n\t\t\tfn = saved_fn;\n\t\t\tgoto redo_rt6_select;\n\t\t}\n\t}\n\n\ttrace_fib6_table_lookup(net, res, table, fl6);\n\n\treturn 0;\n}\n\nstruct rt6_info *ip6_pol_route(struct net *net, struct fib6_table *table,\n\t\t\t       int oif, struct flowi6 *fl6,\n\t\t\t       const struct sk_buff *skb, int flags)\n{\n\tstruct fib6_result res = {};\n\tstruct rt6_info *rt = NULL;\n\tint strict = 0;\n\n\tWARN_ON_ONCE((flags & RT6_LOOKUP_F_DST_NOREF) &&\n\t\t     !rcu_read_lock_held());\n\n\tstrict |= flags & RT6_LOOKUP_F_IFACE;\n\tstrict |= flags & RT6_LOOKUP_F_IGNORE_LINKSTATE;\n\tif (net->ipv6.devconf_all->forwarding == 0)\n\t\tstrict |= RT6_LOOKUP_F_REACHABLE;\n\n\trcu_read_lock();\n\n\tfib6_table_lookup(net, table, oif, fl6, &res, strict);\n\tif (res.f6i == net->ipv6.fib6_null_entry)\n\t\tgoto out;\n\n\tfib6_select_path(net, &res, fl6, oif, false, skb, strict);\n\n\t \n\trt = rt6_find_cached_rt(&res, &fl6->daddr, &fl6->saddr);\n\tif (rt) {\n\t\tgoto out;\n\t} else if (unlikely((fl6->flowi6_flags & FLOWI_FLAG_KNOWN_NH) &&\n\t\t\t    !res.nh->fib_nh_gw_family)) {\n\t\t \n\t\trt = ip6_rt_cache_alloc(&res, &fl6->daddr, NULL);\n\n\t\tif (rt) {\n\t\t\t \n\t\t\trt6_uncached_list_add(rt);\n\t\t\trcu_read_unlock();\n\n\t\t\treturn rt;\n\t\t}\n\t} else {\n\t\t \n\t\tlocal_bh_disable();\n\t\trt = rt6_get_pcpu_route(&res);\n\n\t\tif (!rt)\n\t\t\trt = rt6_make_pcpu_route(net, &res);\n\n\t\tlocal_bh_enable();\n\t}\nout:\n\tif (!rt)\n\t\trt = net->ipv6.ip6_null_entry;\n\tif (!(flags & RT6_LOOKUP_F_DST_NOREF))\n\t\tip6_hold_safe(net, &rt);\n\trcu_read_unlock();\n\n\treturn rt;\n}\nEXPORT_SYMBOL_GPL(ip6_pol_route);\n\nINDIRECT_CALLABLE_SCOPE struct rt6_info *ip6_pol_route_input(struct net *net,\n\t\t\t\t\t    struct fib6_table *table,\n\t\t\t\t\t    struct flowi6 *fl6,\n\t\t\t\t\t    const struct sk_buff *skb,\n\t\t\t\t\t    int flags)\n{\n\treturn ip6_pol_route(net, table, fl6->flowi6_iif, fl6, skb, flags);\n}\n\nstruct dst_entry *ip6_route_input_lookup(struct net *net,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t struct flowi6 *fl6,\n\t\t\t\t\t const struct sk_buff *skb,\n\t\t\t\t\t int flags)\n{\n\tif (rt6_need_strict(&fl6->daddr) && dev->type != ARPHRD_PIMREG)\n\t\tflags |= RT6_LOOKUP_F_IFACE;\n\n\treturn fib6_rule_lookup(net, fl6, skb, flags, ip6_pol_route_input);\n}\nEXPORT_SYMBOL_GPL(ip6_route_input_lookup);\n\nstatic void ip6_multipath_l3_keys(const struct sk_buff *skb,\n\t\t\t\t  struct flow_keys *keys,\n\t\t\t\t  struct flow_keys *flkeys)\n{\n\tconst struct ipv6hdr *outer_iph = ipv6_hdr(skb);\n\tconst struct ipv6hdr *key_iph = outer_iph;\n\tstruct flow_keys *_flkeys = flkeys;\n\tconst struct ipv6hdr *inner_iph;\n\tconst struct icmp6hdr *icmph;\n\tstruct ipv6hdr _inner_iph;\n\tstruct icmp6hdr _icmph;\n\n\tif (likely(outer_iph->nexthdr != IPPROTO_ICMPV6))\n\t\tgoto out;\n\n\ticmph = skb_header_pointer(skb, skb_transport_offset(skb),\n\t\t\t\t   sizeof(_icmph), &_icmph);\n\tif (!icmph)\n\t\tgoto out;\n\n\tif (!icmpv6_is_err(icmph->icmp6_type))\n\t\tgoto out;\n\n\tinner_iph = skb_header_pointer(skb,\n\t\t\t\t       skb_transport_offset(skb) + sizeof(*icmph),\n\t\t\t\t       sizeof(_inner_iph), &_inner_iph);\n\tif (!inner_iph)\n\t\tgoto out;\n\n\tkey_iph = inner_iph;\n\t_flkeys = NULL;\nout:\n\tif (_flkeys) {\n\t\tkeys->addrs.v6addrs.src = _flkeys->addrs.v6addrs.src;\n\t\tkeys->addrs.v6addrs.dst = _flkeys->addrs.v6addrs.dst;\n\t\tkeys->tags.flow_label = _flkeys->tags.flow_label;\n\t\tkeys->basic.ip_proto = _flkeys->basic.ip_proto;\n\t} else {\n\t\tkeys->addrs.v6addrs.src = key_iph->saddr;\n\t\tkeys->addrs.v6addrs.dst = key_iph->daddr;\n\t\tkeys->tags.flow_label = ip6_flowlabel(key_iph);\n\t\tkeys->basic.ip_proto = key_iph->nexthdr;\n\t}\n}\n\nstatic u32 rt6_multipath_custom_hash_outer(const struct net *net,\n\t\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t\t   bool *p_has_inner)\n{\n\tu32 hash_fields = ip6_multipath_hash_fields(net);\n\tstruct flow_keys keys, hash_keys;\n\n\tif (!(hash_fields & FIB_MULTIPATH_HASH_FIELD_OUTER_MASK))\n\t\treturn 0;\n\n\tmemset(&hash_keys, 0, sizeof(hash_keys));\n\tskb_flow_dissect_flow_keys(skb, &keys, FLOW_DISSECTOR_F_STOP_AT_ENCAP);\n\n\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_SRC_IP)\n\t\thash_keys.addrs.v6addrs.src = keys.addrs.v6addrs.src;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_DST_IP)\n\t\thash_keys.addrs.v6addrs.dst = keys.addrs.v6addrs.dst;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_IP_PROTO)\n\t\thash_keys.basic.ip_proto = keys.basic.ip_proto;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_FLOWLABEL)\n\t\thash_keys.tags.flow_label = keys.tags.flow_label;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_SRC_PORT)\n\t\thash_keys.ports.src = keys.ports.src;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_DST_PORT)\n\t\thash_keys.ports.dst = keys.ports.dst;\n\n\t*p_has_inner = !!(keys.control.flags & FLOW_DIS_ENCAPSULATION);\n\treturn flow_hash_from_keys(&hash_keys);\n}\n\nstatic u32 rt6_multipath_custom_hash_inner(const struct net *net,\n\t\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t\t   bool has_inner)\n{\n\tu32 hash_fields = ip6_multipath_hash_fields(net);\n\tstruct flow_keys keys, hash_keys;\n\n\t \n\tif (!has_inner)\n\t\treturn 0;\n\n\tif (!(hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_MASK))\n\t\treturn 0;\n\n\tmemset(&hash_keys, 0, sizeof(hash_keys));\n\tskb_flow_dissect_flow_keys(skb, &keys, 0);\n\n\tif (!(keys.control.flags & FLOW_DIS_ENCAPSULATION))\n\t\treturn 0;\n\n\tif (keys.control.addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_SRC_IP)\n\t\t\thash_keys.addrs.v4addrs.src = keys.addrs.v4addrs.src;\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_DST_IP)\n\t\t\thash_keys.addrs.v4addrs.dst = keys.addrs.v4addrs.dst;\n\t} else if (keys.control.addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {\n\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_SRC_IP)\n\t\t\thash_keys.addrs.v6addrs.src = keys.addrs.v6addrs.src;\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_DST_IP)\n\t\t\thash_keys.addrs.v6addrs.dst = keys.addrs.v6addrs.dst;\n\t\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_FLOWLABEL)\n\t\t\thash_keys.tags.flow_label = keys.tags.flow_label;\n\t}\n\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_IP_PROTO)\n\t\thash_keys.basic.ip_proto = keys.basic.ip_proto;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_SRC_PORT)\n\t\thash_keys.ports.src = keys.ports.src;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_INNER_DST_PORT)\n\t\thash_keys.ports.dst = keys.ports.dst;\n\n\treturn flow_hash_from_keys(&hash_keys);\n}\n\nstatic u32 rt6_multipath_custom_hash_skb(const struct net *net,\n\t\t\t\t\t const struct sk_buff *skb)\n{\n\tu32 mhash, mhash_inner;\n\tbool has_inner = true;\n\n\tmhash = rt6_multipath_custom_hash_outer(net, skb, &has_inner);\n\tmhash_inner = rt6_multipath_custom_hash_inner(net, skb, has_inner);\n\n\treturn jhash_2words(mhash, mhash_inner, 0);\n}\n\nstatic u32 rt6_multipath_custom_hash_fl6(const struct net *net,\n\t\t\t\t\t const struct flowi6 *fl6)\n{\n\tu32 hash_fields = ip6_multipath_hash_fields(net);\n\tstruct flow_keys hash_keys;\n\n\tif (!(hash_fields & FIB_MULTIPATH_HASH_FIELD_OUTER_MASK))\n\t\treturn 0;\n\n\tmemset(&hash_keys, 0, sizeof(hash_keys));\n\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_SRC_IP)\n\t\thash_keys.addrs.v6addrs.src = fl6->saddr;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_DST_IP)\n\t\thash_keys.addrs.v6addrs.dst = fl6->daddr;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_IP_PROTO)\n\t\thash_keys.basic.ip_proto = fl6->flowi6_proto;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_FLOWLABEL)\n\t\thash_keys.tags.flow_label = (__force u32)flowi6_get_flowlabel(fl6);\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_SRC_PORT)\n\t\thash_keys.ports.src = fl6->fl6_sport;\n\tif (hash_fields & FIB_MULTIPATH_HASH_FIELD_DST_PORT)\n\t\thash_keys.ports.dst = fl6->fl6_dport;\n\n\treturn flow_hash_from_keys(&hash_keys);\n}\n\n \nu32 rt6_multipath_hash(const struct net *net, const struct flowi6 *fl6,\n\t\t       const struct sk_buff *skb, struct flow_keys *flkeys)\n{\n\tstruct flow_keys hash_keys;\n\tu32 mhash = 0;\n\n\tswitch (ip6_multipath_hash_policy(net)) {\n\tcase 0:\n\t\tmemset(&hash_keys, 0, sizeof(hash_keys));\n\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\tif (skb) {\n\t\t\tip6_multipath_l3_keys(skb, &hash_keys, flkeys);\n\t\t} else {\n\t\t\thash_keys.addrs.v6addrs.src = fl6->saddr;\n\t\t\thash_keys.addrs.v6addrs.dst = fl6->daddr;\n\t\t\thash_keys.tags.flow_label = (__force u32)flowi6_get_flowlabel(fl6);\n\t\t\thash_keys.basic.ip_proto = fl6->flowi6_proto;\n\t\t}\n\t\tmhash = flow_hash_from_keys(&hash_keys);\n\t\tbreak;\n\tcase 1:\n\t\tif (skb) {\n\t\t\tunsigned int flag = FLOW_DISSECTOR_F_STOP_AT_ENCAP;\n\t\t\tstruct flow_keys keys;\n\n\t\t\t \n\t\t\tif (skb->l4_hash)\n\t\t\t\treturn skb_get_hash_raw(skb) >> 1;\n\n\t\t\tmemset(&hash_keys, 0, sizeof(hash_keys));\n\n\t\t\tif (!flkeys) {\n\t\t\t\tskb_flow_dissect_flow_keys(skb, &keys, flag);\n\t\t\t\tflkeys = &keys;\n\t\t\t}\n\t\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t\thash_keys.addrs.v6addrs.src = flkeys->addrs.v6addrs.src;\n\t\t\thash_keys.addrs.v6addrs.dst = flkeys->addrs.v6addrs.dst;\n\t\t\thash_keys.ports.src = flkeys->ports.src;\n\t\t\thash_keys.ports.dst = flkeys->ports.dst;\n\t\t\thash_keys.basic.ip_proto = flkeys->basic.ip_proto;\n\t\t} else {\n\t\t\tmemset(&hash_keys, 0, sizeof(hash_keys));\n\t\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t\thash_keys.addrs.v6addrs.src = fl6->saddr;\n\t\t\thash_keys.addrs.v6addrs.dst = fl6->daddr;\n\t\t\thash_keys.ports.src = fl6->fl6_sport;\n\t\t\thash_keys.ports.dst = fl6->fl6_dport;\n\t\t\thash_keys.basic.ip_proto = fl6->flowi6_proto;\n\t\t}\n\t\tmhash = flow_hash_from_keys(&hash_keys);\n\t\tbreak;\n\tcase 2:\n\t\tmemset(&hash_keys, 0, sizeof(hash_keys));\n\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\tif (skb) {\n\t\t\tstruct flow_keys keys;\n\n\t\t\tif (!flkeys) {\n\t\t\t\tskb_flow_dissect_flow_keys(skb, &keys, 0);\n\t\t\t\tflkeys = &keys;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (flkeys->control.addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\t\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\t\t\thash_keys.addrs.v4addrs.src = flkeys->addrs.v4addrs.src;\n\t\t\t\thash_keys.addrs.v4addrs.dst = flkeys->addrs.v4addrs.dst;\n\t\t\t} else if (flkeys->control.addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {\n\t\t\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t\t\thash_keys.addrs.v6addrs.src = flkeys->addrs.v6addrs.src;\n\t\t\t\thash_keys.addrs.v6addrs.dst = flkeys->addrs.v6addrs.dst;\n\t\t\t\thash_keys.tags.flow_label = flkeys->tags.flow_label;\n\t\t\t\thash_keys.basic.ip_proto = flkeys->basic.ip_proto;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t\t\tip6_multipath_l3_keys(skb, &hash_keys, flkeys);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t\thash_keys.addrs.v6addrs.src = fl6->saddr;\n\t\t\thash_keys.addrs.v6addrs.dst = fl6->daddr;\n\t\t\thash_keys.tags.flow_label = (__force u32)flowi6_get_flowlabel(fl6);\n\t\t\thash_keys.basic.ip_proto = fl6->flowi6_proto;\n\t\t}\n\t\tmhash = flow_hash_from_keys(&hash_keys);\n\t\tbreak;\n\tcase 3:\n\t\tif (skb)\n\t\t\tmhash = rt6_multipath_custom_hash_skb(net, skb);\n\t\telse\n\t\t\tmhash = rt6_multipath_custom_hash_fl6(net, fl6);\n\t\tbreak;\n\t}\n\n\treturn mhash >> 1;\n}\n\n \nvoid ip6_route_input(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tint flags = RT6_LOOKUP_F_HAS_SADDR | RT6_LOOKUP_F_DST_NOREF;\n\tstruct ip_tunnel_info *tun_info;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif = skb->dev->ifindex,\n\t\t.daddr = iph->daddr,\n\t\t.saddr = iph->saddr,\n\t\t.flowlabel = ip6_flowinfo(iph),\n\t\t.flowi6_mark = skb->mark,\n\t\t.flowi6_proto = iph->nexthdr,\n\t};\n\tstruct flow_keys *flkeys = NULL, _flkeys;\n\n\ttun_info = skb_tunnel_info(skb);\n\tif (tun_info && !(tun_info->mode & IP_TUNNEL_INFO_TX))\n\t\tfl6.flowi6_tun_key.tun_id = tun_info->key.tun_id;\n\n\tif (fib6_rules_early_flow_dissect(net, skb, &fl6, &_flkeys))\n\t\tflkeys = &_flkeys;\n\n\tif (unlikely(fl6.flowi6_proto == IPPROTO_ICMPV6))\n\t\tfl6.mp_hash = rt6_multipath_hash(net, &fl6, skb, flkeys);\n\tskb_dst_drop(skb);\n\tskb_dst_set_noref(skb, ip6_route_input_lookup(net, skb->dev,\n\t\t\t\t\t\t      &fl6, skb, flags));\n}\n\nINDIRECT_CALLABLE_SCOPE struct rt6_info *ip6_pol_route_output(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags)\n{\n\treturn ip6_pol_route(net, table, fl6->flowi6_oif, fl6, skb, flags);\n}\n\nstatic struct dst_entry *ip6_route_output_flags_noref(struct net *net,\n\t\t\t\t\t\t      const struct sock *sk,\n\t\t\t\t\t\t      struct flowi6 *fl6,\n\t\t\t\t\t\t      int flags)\n{\n\tbool any_src;\n\n\tif (ipv6_addr_type(&fl6->daddr) &\n\t    (IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL)) {\n\t\tstruct dst_entry *dst;\n\n\t\t \n\t\tdst = l3mdev_link_scope_lookup(net, fl6);\n\t\tif (dst)\n\t\t\treturn dst;\n\t}\n\n\tfl6->flowi6_iif = LOOPBACK_IFINDEX;\n\n\tflags |= RT6_LOOKUP_F_DST_NOREF;\n\tany_src = ipv6_addr_any(&fl6->saddr);\n\tif ((sk && sk->sk_bound_dev_if) || rt6_need_strict(&fl6->daddr) ||\n\t    (fl6->flowi6_oif && any_src))\n\t\tflags |= RT6_LOOKUP_F_IFACE;\n\n\tif (!any_src)\n\t\tflags |= RT6_LOOKUP_F_HAS_SADDR;\n\telse if (sk)\n\t\tflags |= rt6_srcprefs2flags(inet6_sk(sk)->srcprefs);\n\n\treturn fib6_rule_lookup(net, fl6, NULL, flags, ip6_pol_route_output);\n}\n\nstruct dst_entry *ip6_route_output_flags(struct net *net,\n\t\t\t\t\t const struct sock *sk,\n\t\t\t\t\t struct flowi6 *fl6,\n\t\t\t\t\t int flags)\n{\n\tstruct dst_entry *dst;\n\tstruct rt6_info *rt6;\n\n\trcu_read_lock();\n\tdst = ip6_route_output_flags_noref(net, sk, fl6, flags);\n\trt6 = (struct rt6_info *)dst;\n\t \n\tif (list_empty(&rt6->dst.rt_uncached) && !dst_hold_safe(dst)) {\n\t\tdst = &net->ipv6.ip6_null_entry->dst;\n\t\tdst_hold(dst);\n\t}\n\trcu_read_unlock();\n\n\treturn dst;\n}\nEXPORT_SYMBOL_GPL(ip6_route_output_flags);\n\nstruct dst_entry *ip6_blackhole_route(struct net *net, struct dst_entry *dst_orig)\n{\n\tstruct rt6_info *rt, *ort = (struct rt6_info *) dst_orig;\n\tstruct net_device *loopback_dev = net->loopback_dev;\n\tstruct dst_entry *new = NULL;\n\n\trt = dst_alloc(&ip6_dst_blackhole_ops, loopback_dev, 1,\n\t\t       DST_OBSOLETE_DEAD, 0);\n\tif (rt) {\n\t\trt6_info_init(rt);\n\t\tatomic_inc(&net->ipv6.rt6_stats->fib_rt_alloc);\n\n\t\tnew = &rt->dst;\n\t\tnew->__use = 1;\n\t\tnew->input = dst_discard;\n\t\tnew->output = dst_discard_out;\n\n\t\tdst_copy_metrics(new, &ort->dst);\n\n\t\trt->rt6i_idev = in6_dev_get(loopback_dev);\n\t\trt->rt6i_gateway = ort->rt6i_gateway;\n\t\trt->rt6i_flags = ort->rt6i_flags & ~RTF_PCPU;\n\n\t\tmemcpy(&rt->rt6i_dst, &ort->rt6i_dst, sizeof(struct rt6key));\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tmemcpy(&rt->rt6i_src, &ort->rt6i_src, sizeof(struct rt6key));\n#endif\n\t}\n\n\tdst_release(dst_orig);\n\treturn new ? new : ERR_PTR(-ENOMEM);\n}\n\n \n\nstatic bool fib6_check(struct fib6_info *f6i, u32 cookie)\n{\n\tu32 rt_cookie = 0;\n\n\tif (!fib6_get_cookie_safe(f6i, &rt_cookie) || rt_cookie != cookie)\n\t\treturn false;\n\n\tif (fib6_check_expired(f6i))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct dst_entry *rt6_check(struct rt6_info *rt,\n\t\t\t\t   struct fib6_info *from,\n\t\t\t\t   u32 cookie)\n{\n\tu32 rt_cookie = 0;\n\n\tif (!from || !fib6_get_cookie_safe(from, &rt_cookie) ||\n\t    rt_cookie != cookie)\n\t\treturn NULL;\n\n\tif (rt6_check_expired(rt))\n\t\treturn NULL;\n\n\treturn &rt->dst;\n}\n\nstatic struct dst_entry *rt6_dst_from_check(struct rt6_info *rt,\n\t\t\t\t\t    struct fib6_info *from,\n\t\t\t\t\t    u32 cookie)\n{\n\tif (!__rt6_check_expired(rt) &&\n\t    rt->dst.obsolete == DST_OBSOLETE_FORCE_CHK &&\n\t    fib6_check(from, cookie))\n\t\treturn &rt->dst;\n\telse\n\t\treturn NULL;\n}\n\nINDIRECT_CALLABLE_SCOPE struct dst_entry *ip6_dst_check(struct dst_entry *dst,\n\t\t\t\t\t\t\tu32 cookie)\n{\n\tstruct dst_entry *dst_ret;\n\tstruct fib6_info *from;\n\tstruct rt6_info *rt;\n\n\trt = container_of(dst, struct rt6_info, dst);\n\n\tif (rt->sernum)\n\t\treturn rt6_is_valid(rt) ? dst : NULL;\n\n\trcu_read_lock();\n\n\t \n\n\tfrom = rcu_dereference(rt->from);\n\n\tif (from && (rt->rt6i_flags & RTF_PCPU ||\n\t    unlikely(!list_empty(&rt->dst.rt_uncached))))\n\t\tdst_ret = rt6_dst_from_check(rt, from, cookie);\n\telse\n\t\tdst_ret = rt6_check(rt, from, cookie);\n\n\trcu_read_unlock();\n\n\treturn dst_ret;\n}\nEXPORT_INDIRECT_CALLABLE(ip6_dst_check);\n\nstatic struct dst_entry *ip6_negative_advice(struct dst_entry *dst)\n{\n\tstruct rt6_info *rt = (struct rt6_info *) dst;\n\n\tif (rt) {\n\t\tif (rt->rt6i_flags & RTF_CACHE) {\n\t\t\trcu_read_lock();\n\t\t\tif (rt6_check_expired(rt)) {\n\t\t\t\trt6_remove_exception_rt(rt);\n\t\t\t\tdst = NULL;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t\tdst = NULL;\n\t\t}\n\t}\n\treturn dst;\n}\n\nstatic void ip6_link_failure(struct sk_buff *skb)\n{\n\tstruct rt6_info *rt;\n\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_ADDR_UNREACH, 0);\n\n\trt = (struct rt6_info *) skb_dst(skb);\n\tif (rt) {\n\t\trcu_read_lock();\n\t\tif (rt->rt6i_flags & RTF_CACHE) {\n\t\t\trt6_remove_exception_rt(rt);\n\t\t} else {\n\t\t\tstruct fib6_info *from;\n\t\t\tstruct fib6_node *fn;\n\n\t\t\tfrom = rcu_dereference(rt->from);\n\t\t\tif (from) {\n\t\t\t\tfn = rcu_dereference(from->fib6_node);\n\t\t\t\tif (fn && (rt->rt6i_flags & RTF_DEFAULT))\n\t\t\t\t\tWRITE_ONCE(fn->fn_sernum, -1);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic void rt6_update_expires(struct rt6_info *rt0, int timeout)\n{\n\tif (!(rt0->rt6i_flags & RTF_EXPIRES)) {\n\t\tstruct fib6_info *from;\n\n\t\trcu_read_lock();\n\t\tfrom = rcu_dereference(rt0->from);\n\t\tif (from)\n\t\t\trt0->dst.expires = from->expires;\n\t\trcu_read_unlock();\n\t}\n\n\tdst_set_expires(&rt0->dst, timeout);\n\trt0->rt6i_flags |= RTF_EXPIRES;\n}\n\nstatic void rt6_do_update_pmtu(struct rt6_info *rt, u32 mtu)\n{\n\tstruct net *net = dev_net(rt->dst.dev);\n\n\tdst_metric_set(&rt->dst, RTAX_MTU, mtu);\n\trt->rt6i_flags |= RTF_MODIFIED;\n\trt6_update_expires(rt, net->ipv6.sysctl.ip6_rt_mtu_expires);\n}\n\nstatic bool rt6_cache_allowed_for_pmtu(const struct rt6_info *rt)\n{\n\treturn !(rt->rt6i_flags & RTF_CACHE) &&\n\t\t(rt->rt6i_flags & RTF_PCPU || rcu_access_pointer(rt->from));\n}\n\nstatic void __ip6_rt_update_pmtu(struct dst_entry *dst, const struct sock *sk,\n\t\t\t\t const struct ipv6hdr *iph, u32 mtu,\n\t\t\t\t bool confirm_neigh)\n{\n\tconst struct in6_addr *daddr, *saddr;\n\tstruct rt6_info *rt6 = (struct rt6_info *)dst;\n\n\t \n\n\tif (iph) {\n\t\tdaddr = &iph->daddr;\n\t\tsaddr = &iph->saddr;\n\t} else if (sk) {\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tsaddr = &inet6_sk(sk)->saddr;\n\t} else {\n\t\tdaddr = NULL;\n\t\tsaddr = NULL;\n\t}\n\n\tif (confirm_neigh)\n\t\tdst_confirm_neigh(dst, daddr);\n\n\tif (mtu < IPV6_MIN_MTU)\n\t\treturn;\n\tif (mtu >= dst_mtu(dst))\n\t\treturn;\n\n\tif (!rt6_cache_allowed_for_pmtu(rt6)) {\n\t\trt6_do_update_pmtu(rt6, mtu);\n\t\t \n\t\tif (rt6->rt6i_flags & RTF_CACHE)\n\t\t\trt6_update_exception_stamp_rt(rt6);\n\t} else if (daddr) {\n\t\tstruct fib6_result res = {};\n\t\tstruct rt6_info *nrt6;\n\n\t\trcu_read_lock();\n\t\tres.f6i = rcu_dereference(rt6->from);\n\t\tif (!res.f6i)\n\t\t\tgoto out_unlock;\n\n\t\tres.fib6_flags = res.f6i->fib6_flags;\n\t\tres.fib6_type = res.f6i->fib6_type;\n\n\t\tif (res.f6i->nh) {\n\t\t\tstruct fib6_nh_match_arg arg = {\n\t\t\t\t.dev = dst->dev,\n\t\t\t\t.gw = &rt6->rt6i_gateway,\n\t\t\t};\n\n\t\t\tnexthop_for_each_fib6_nh(res.f6i->nh,\n\t\t\t\t\t\t fib6_nh_find_match, &arg);\n\n\t\t\t \n\t\t\tif (!arg.match)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tres.nh = arg.match;\n\t\t} else {\n\t\t\tres.nh = res.f6i->fib6_nh;\n\t\t}\n\n\t\tnrt6 = ip6_rt_cache_alloc(&res, daddr, saddr);\n\t\tif (nrt6) {\n\t\t\trt6_do_update_pmtu(nrt6, mtu);\n\t\t\tif (rt6_insert_exception(nrt6, &res))\n\t\t\t\tdst_release_immediate(&nrt6->dst);\n\t\t}\nout_unlock:\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic void ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t       struct sk_buff *skb, u32 mtu,\n\t\t\t       bool confirm_neigh)\n{\n\t__ip6_rt_update_pmtu(dst, sk, skb ? ipv6_hdr(skb) : NULL, mtu,\n\t\t\t     confirm_neigh);\n}\n\nvoid ip6_update_pmtu(struct sk_buff *skb, struct net *net, __be32 mtu,\n\t\t     int oif, u32 mark, kuid_t uid)\n{\n\tconst struct ipv6hdr *iph = (struct ipv6hdr *) skb->data;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_oif = oif,\n\t\t.flowi6_mark = mark ? mark : IP6_REPLY_MARK(net, skb->mark),\n\t\t.daddr = iph->daddr,\n\t\t.saddr = iph->saddr,\n\t\t.flowlabel = ip6_flowinfo(iph),\n\t\t.flowi6_uid = uid,\n\t};\n\n\tdst = ip6_route_output(net, NULL, &fl6);\n\tif (!dst->error)\n\t\t__ip6_rt_update_pmtu(dst, NULL, iph, ntohl(mtu), true);\n\tdst_release(dst);\n}\nEXPORT_SYMBOL_GPL(ip6_update_pmtu);\n\nvoid ip6_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, __be32 mtu)\n{\n\tint oif = sk->sk_bound_dev_if;\n\tstruct dst_entry *dst;\n\n\tif (!oif && skb->dev)\n\t\toif = l3mdev_master_ifindex(skb->dev);\n\n\tip6_update_pmtu(skb, sock_net(sk), mtu, oif, READ_ONCE(sk->sk_mark),\n\t\t\tsk->sk_uid);\n\n\tdst = __sk_dst_get(sk);\n\tif (!dst || !dst->obsolete ||\n\t    dst->ops->check(dst, inet6_sk(sk)->dst_cookie))\n\t\treturn;\n\n\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk) && !ipv6_addr_v4mapped(&sk->sk_v6_daddr))\n\t\tip6_datagram_dst_update(sk, false);\n\tbh_unlock_sock(sk);\n}\nEXPORT_SYMBOL_GPL(ip6_sk_update_pmtu);\n\nvoid ip6_sk_dst_store_flow(struct sock *sk, struct dst_entry *dst,\n\t\t\t   const struct flowi6 *fl6)\n{\n#ifdef CONFIG_IPV6_SUBTREES\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n#endif\n\n\tip6_dst_store(sk, dst,\n\t\t      ipv6_addr_equal(&fl6->daddr, &sk->sk_v6_daddr) ?\n\t\t      &sk->sk_v6_daddr : NULL,\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t      ipv6_addr_equal(&fl6->saddr, &np->saddr) ?\n\t\t      &np->saddr :\n#endif\n\t\t      NULL);\n}\n\nstatic bool ip6_redirect_nh_match(const struct fib6_result *res,\n\t\t\t\t  struct flowi6 *fl6,\n\t\t\t\t  const struct in6_addr *gw,\n\t\t\t\t  struct rt6_info **ret)\n{\n\tconst struct fib6_nh *nh = res->nh;\n\n\tif (nh->fib_nh_flags & RTNH_F_DEAD || !nh->fib_nh_gw_family ||\n\t    fl6->flowi6_oif != nh->fib_nh_dev->ifindex)\n\t\treturn false;\n\n\t \n\tif (!ipv6_addr_equal(gw, &nh->fib_nh_gw6)) {\n\t\tstruct rt6_info *rt_cache;\n\n\t\trt_cache = rt6_find_cached_rt(res, &fl6->daddr, &fl6->saddr);\n\t\tif (rt_cache &&\n\t\t    ipv6_addr_equal(gw, &rt_cache->rt6i_gateway)) {\n\t\t\t*ret = rt_cache;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstruct fib6_nh_rd_arg {\n\tstruct fib6_result\t*res;\n\tstruct flowi6\t\t*fl6;\n\tconst struct in6_addr\t*gw;\n\tstruct rt6_info\t\t**ret;\n};\n\nstatic int fib6_nh_redirect_match(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_rd_arg *arg = _arg;\n\n\targ->res->nh = nh;\n\treturn ip6_redirect_nh_match(arg->res, arg->fl6, arg->gw, arg->ret);\n}\n\n \nstruct ip6rd_flowi {\n\tstruct flowi6 fl6;\n\tstruct in6_addr gateway;\n};\n\nINDIRECT_CALLABLE_SCOPE struct rt6_info *__ip6_route_redirect(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags)\n{\n\tstruct ip6rd_flowi *rdfl = (struct ip6rd_flowi *)fl6;\n\tstruct rt6_info *ret = NULL;\n\tstruct fib6_result res = {};\n\tstruct fib6_nh_rd_arg arg = {\n\t\t.res = &res,\n\t\t.fl6 = fl6,\n\t\t.gw  = &rdfl->gateway,\n\t\t.ret = &ret\n\t};\n\tstruct fib6_info *rt;\n\tstruct fib6_node *fn;\n\n\t \n\n\trcu_read_lock();\n\tfn = fib6_node_lookup(&table->tb6_root, &fl6->daddr, &fl6->saddr);\nrestart:\n\tfor_each_fib6_node_rt_rcu(fn) {\n\t\tres.f6i = rt;\n\t\tif (fib6_check_expired(rt))\n\t\t\tcontinue;\n\t\tif (rt->fib6_flags & RTF_REJECT)\n\t\t\tbreak;\n\t\tif (unlikely(rt->nh)) {\n\t\t\tif (nexthop_is_blackhole(rt->nh))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (nexthop_for_each_fib6_nh(rt->nh,\n\t\t\t\t\t\t     fib6_nh_redirect_match,\n\t\t\t\t\t\t     &arg))\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tres.nh = rt->fib6_nh;\n\t\t\tif (ip6_redirect_nh_match(&res, fl6, &rdfl->gateway,\n\t\t\t\t\t\t  &ret))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!rt)\n\t\trt = net->ipv6.fib6_null_entry;\n\telse if (rt->fib6_flags & RTF_REJECT) {\n\t\tret = net->ipv6.ip6_null_entry;\n\t\tgoto out;\n\t}\n\n\tif (rt == net->ipv6.fib6_null_entry) {\n\t\tfn = fib6_backtrack(fn, &fl6->saddr);\n\t\tif (fn)\n\t\t\tgoto restart;\n\t}\n\n\tres.f6i = rt;\n\tres.nh = rt->fib6_nh;\nout:\n\tif (ret) {\n\t\tip6_hold_safe(net, &ret);\n\t} else {\n\t\tres.fib6_flags = res.f6i->fib6_flags;\n\t\tres.fib6_type = res.f6i->fib6_type;\n\t\tret = ip6_create_rt_rcu(&res);\n\t}\n\n\trcu_read_unlock();\n\n\ttrace_fib6_table_lookup(net, &res, table, fl6);\n\treturn ret;\n};\n\nstatic struct dst_entry *ip6_route_redirect(struct net *net,\n\t\t\t\t\t    const struct flowi6 *fl6,\n\t\t\t\t\t    const struct sk_buff *skb,\n\t\t\t\t\t    const struct in6_addr *gateway)\n{\n\tint flags = RT6_LOOKUP_F_HAS_SADDR;\n\tstruct ip6rd_flowi rdfl;\n\n\trdfl.fl6 = *fl6;\n\trdfl.gateway = *gateway;\n\n\treturn fib6_rule_lookup(net, &rdfl.fl6, skb,\n\t\t\t\tflags, __ip6_route_redirect);\n}\n\nvoid ip6_redirect(struct sk_buff *skb, struct net *net, int oif, u32 mark,\n\t\t  kuid_t uid)\n{\n\tconst struct ipv6hdr *iph = (struct ipv6hdr *) skb->data;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif = LOOPBACK_IFINDEX,\n\t\t.flowi6_oif = oif,\n\t\t.flowi6_mark = mark,\n\t\t.daddr = iph->daddr,\n\t\t.saddr = iph->saddr,\n\t\t.flowlabel = ip6_flowinfo(iph),\n\t\t.flowi6_uid = uid,\n\t};\n\n\tdst = ip6_route_redirect(net, &fl6, skb, &ipv6_hdr(skb)->saddr);\n\trt6_do_redirect(dst, NULL, skb);\n\tdst_release(dst);\n}\nEXPORT_SYMBOL_GPL(ip6_redirect);\n\nvoid ip6_redirect_no_header(struct sk_buff *skb, struct net *net, int oif)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tconst struct rd_msg *msg = (struct rd_msg *)icmp6_hdr(skb);\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif = LOOPBACK_IFINDEX,\n\t\t.flowi6_oif = oif,\n\t\t.daddr = msg->dest,\n\t\t.saddr = iph->daddr,\n\t\t.flowi6_uid = sock_net_uid(net, NULL),\n\t};\n\n\tdst = ip6_route_redirect(net, &fl6, skb, &iph->saddr);\n\trt6_do_redirect(dst, NULL, skb);\n\tdst_release(dst);\n}\n\nvoid ip6_sk_redirect(struct sk_buff *skb, struct sock *sk)\n{\n\tip6_redirect(skb, sock_net(sk), sk->sk_bound_dev_if,\n\t\t     READ_ONCE(sk->sk_mark), sk->sk_uid);\n}\nEXPORT_SYMBOL_GPL(ip6_sk_redirect);\n\nstatic unsigned int ip6_default_advmss(const struct dst_entry *dst)\n{\n\tstruct net_device *dev = dst->dev;\n\tunsigned int mtu = dst_mtu(dst);\n\tstruct net *net = dev_net(dev);\n\n\tmtu -= sizeof(struct ipv6hdr) + sizeof(struct tcphdr);\n\n\tif (mtu < net->ipv6.sysctl.ip6_rt_min_advmss)\n\t\tmtu = net->ipv6.sysctl.ip6_rt_min_advmss;\n\n\t \n\tif (mtu > IPV6_MAXPLEN - sizeof(struct tcphdr))\n\t\tmtu = IPV6_MAXPLEN;\n\treturn mtu;\n}\n\nINDIRECT_CALLABLE_SCOPE unsigned int ip6_mtu(const struct dst_entry *dst)\n{\n\treturn ip6_dst_mtu_maybe_forward(dst, false);\n}\nEXPORT_INDIRECT_CALLABLE(ip6_mtu);\n\n \nu32 ip6_mtu_from_fib6(const struct fib6_result *res,\n\t\t      const struct in6_addr *daddr,\n\t\t      const struct in6_addr *saddr)\n{\n\tconst struct fib6_nh *nh = res->nh;\n\tstruct fib6_info *f6i = res->f6i;\n\tstruct inet6_dev *idev;\n\tstruct rt6_info *rt;\n\tu32 mtu = 0;\n\n\tif (unlikely(fib6_metric_locked(f6i, RTAX_MTU))) {\n\t\tmtu = f6i->fib6_pmtu;\n\t\tif (mtu)\n\t\t\tgoto out;\n\t}\n\n\trt = rt6_find_cached_rt(res, daddr, saddr);\n\tif (unlikely(rt)) {\n\t\tmtu = dst_metric_raw(&rt->dst, RTAX_MTU);\n\t} else {\n\t\tstruct net_device *dev = nh->fib_nh_dev;\n\n\t\tmtu = IPV6_MIN_MTU;\n\t\tidev = __in6_dev_get(dev);\n\t\tif (idev && idev->cnf.mtu6 > mtu)\n\t\t\tmtu = idev->cnf.mtu6;\n\t}\n\n\tmtu = min_t(unsigned int, mtu, IP6_MAX_MTU);\nout:\n\treturn mtu - lwtunnel_headroom(nh->fib_nh_lws, mtu);\n}\n\nstruct dst_entry *icmp6_dst_alloc(struct net_device *dev,\n\t\t\t\t  struct flowi6 *fl6)\n{\n\tstruct dst_entry *dst;\n\tstruct rt6_info *rt;\n\tstruct inet6_dev *idev = in6_dev_get(dev);\n\tstruct net *net = dev_net(dev);\n\n\tif (unlikely(!idev))\n\t\treturn ERR_PTR(-ENODEV);\n\n\trt = ip6_dst_alloc(net, dev, 0);\n\tif (unlikely(!rt)) {\n\t\tin6_dev_put(idev);\n\t\tdst = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\trt->dst.input = ip6_input;\n\trt->dst.output  = ip6_output;\n\trt->rt6i_gateway  = fl6->daddr;\n\trt->rt6i_dst.addr = fl6->daddr;\n\trt->rt6i_dst.plen = 128;\n\trt->rt6i_idev     = idev;\n\tdst_metric_set(&rt->dst, RTAX_HOPLIMIT, 0);\n\n\t \n\trt6_uncached_list_add(rt);\n\n\tdst = xfrm_lookup(net, &rt->dst, flowi6_to_flowi(fl6), NULL, 0);\n\nout:\n\treturn dst;\n}\n\nstatic void ip6_dst_gc(struct dst_ops *ops)\n{\n\tstruct net *net = container_of(ops, struct net, ipv6.ip6_dst_ops);\n\tint rt_min_interval = net->ipv6.sysctl.ip6_rt_gc_min_interval;\n\tint rt_elasticity = net->ipv6.sysctl.ip6_rt_gc_elasticity;\n\tint rt_gc_timeout = net->ipv6.sysctl.ip6_rt_gc_timeout;\n\tunsigned long rt_last_gc = net->ipv6.ip6_rt_last_gc;\n\tunsigned int val;\n\tint entries;\n\n\tif (time_after(rt_last_gc + rt_min_interval, jiffies))\n\t\tgoto out;\n\n\tfib6_run_gc(atomic_inc_return(&net->ipv6.ip6_rt_gc_expire), net, true);\n\tentries = dst_entries_get_slow(ops);\n\tif (entries < ops->gc_thresh)\n\t\tatomic_set(&net->ipv6.ip6_rt_gc_expire, rt_gc_timeout >> 1);\nout:\n\tval = atomic_read(&net->ipv6.ip6_rt_gc_expire);\n\tatomic_set(&net->ipv6.ip6_rt_gc_expire, val - (val >> rt_elasticity));\n}\n\nstatic int ip6_nh_lookup_table(struct net *net, struct fib6_config *cfg,\n\t\t\t       const struct in6_addr *gw_addr, u32 tbid,\n\t\t\t       int flags, struct fib6_result *res)\n{\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_oif = cfg->fc_ifindex,\n\t\t.daddr = *gw_addr,\n\t\t.saddr = cfg->fc_prefsrc,\n\t};\n\tstruct fib6_table *table;\n\tint err;\n\n\ttable = fib6_get_table(net, tbid);\n\tif (!table)\n\t\treturn -EINVAL;\n\n\tif (!ipv6_addr_any(&cfg->fc_prefsrc))\n\t\tflags |= RT6_LOOKUP_F_HAS_SADDR;\n\n\tflags |= RT6_LOOKUP_F_IGNORE_LINKSTATE;\n\n\terr = fib6_table_lookup(net, table, cfg->fc_ifindex, &fl6, res, flags);\n\tif (!err && res->f6i != net->ipv6.fib6_null_entry)\n\t\tfib6_select_path(net, res, &fl6, cfg->fc_ifindex,\n\t\t\t\t cfg->fc_ifindex != 0, NULL, flags);\n\n\treturn err;\n}\n\nstatic int ip6_route_check_nh_onlink(struct net *net,\n\t\t\t\t     struct fib6_config *cfg,\n\t\t\t\t     const struct net_device *dev,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu32 tbid = l3mdev_fib_table_rcu(dev) ? : RT_TABLE_MAIN;\n\tconst struct in6_addr *gw_addr = &cfg->fc_gateway;\n\tstruct fib6_result res = {};\n\tint err;\n\n\terr = ip6_nh_lookup_table(net, cfg, gw_addr, tbid, 0, &res);\n\tif (!err && !(res.fib6_flags & RTF_REJECT) &&\n\t     \n\t    !ipv6_addr_any(&res.f6i->fib6_dst.addr) &&\n\t    (res.fib6_type != RTN_UNICAST || dev != res.nh->fib_nh_dev)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Nexthop has invalid gateway or device mismatch\");\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int ip6_route_check_nh(struct net *net,\n\t\t\t      struct fib6_config *cfg,\n\t\t\t      struct net_device **_dev,\n\t\t\t      netdevice_tracker *dev_tracker,\n\t\t\t      struct inet6_dev **idev)\n{\n\tconst struct in6_addr *gw_addr = &cfg->fc_gateway;\n\tstruct net_device *dev = _dev ? *_dev : NULL;\n\tint flags = RT6_LOOKUP_F_IFACE;\n\tstruct fib6_result res = {};\n\tint err = -EHOSTUNREACH;\n\n\tif (cfg->fc_table) {\n\t\terr = ip6_nh_lookup_table(net, cfg, gw_addr,\n\t\t\t\t\t  cfg->fc_table, flags, &res);\n\t\t \n\t\tif (err || res.fib6_flags & RTF_REJECT ||\n\t\t    res.nh->fib_nh_gw_family ||\n\t\t    (dev && dev != res.nh->fib_nh_dev))\n\t\t\terr = -EHOSTUNREACH;\n\t}\n\n\tif (err < 0) {\n\t\tstruct flowi6 fl6 = {\n\t\t\t.flowi6_oif = cfg->fc_ifindex,\n\t\t\t.daddr = *gw_addr,\n\t\t};\n\n\t\terr = fib6_lookup(net, cfg->fc_ifindex, &fl6, &res, flags);\n\t\tif (err || res.fib6_flags & RTF_REJECT ||\n\t\t    res.nh->fib_nh_gw_family)\n\t\t\terr = -EHOSTUNREACH;\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfib6_select_path(net, &res, &fl6, cfg->fc_ifindex,\n\t\t\t\t cfg->fc_ifindex != 0, NULL, flags);\n\t}\n\n\terr = 0;\n\tif (dev) {\n\t\tif (dev != res.nh->fib_nh_dev)\n\t\t\terr = -EHOSTUNREACH;\n\t} else {\n\t\t*_dev = dev = res.nh->fib_nh_dev;\n\t\tnetdev_hold(dev, dev_tracker, GFP_ATOMIC);\n\t\t*idev = in6_dev_get(dev);\n\t}\n\n\treturn err;\n}\n\nstatic int ip6_validate_gw(struct net *net, struct fib6_config *cfg,\n\t\t\t   struct net_device **_dev,\n\t\t\t   netdevice_tracker *dev_tracker,\n\t\t\t   struct inet6_dev **idev,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tconst struct in6_addr *gw_addr = &cfg->fc_gateway;\n\tint gwa_type = ipv6_addr_type(gw_addr);\n\tbool skip_dev = gwa_type & IPV6_ADDR_LINKLOCAL ? false : true;\n\tconst struct net_device *dev = *_dev;\n\tbool need_addr_check = !dev;\n\tint err = -EINVAL;\n\n\t \n\tif (dev &&\n\t    ipv6_chk_addr_and_flags(net, gw_addr, dev, skip_dev, 0, 0)) {\n\t\tNL_SET_ERR_MSG(extack, \"Gateway can not be a local address\");\n\t\tgoto out;\n\t}\n\n\tif (gwa_type != (IPV6_ADDR_LINKLOCAL | IPV6_ADDR_UNICAST)) {\n\t\t \n\t\tif (!(gwa_type & (IPV6_ADDR_UNICAST | IPV6_ADDR_MAPPED))) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid gateway address\");\n\t\t\tgoto out;\n\t\t}\n\n\t\trcu_read_lock();\n\n\t\tif (cfg->fc_flags & RTNH_F_ONLINK)\n\t\t\terr = ip6_route_check_nh_onlink(net, cfg, dev, extack);\n\t\telse\n\t\t\terr = ip6_route_check_nh(net, cfg, _dev, dev_tracker,\n\t\t\t\t\t\t idev);\n\n\t\trcu_read_unlock();\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\tdev = *_dev;\n\n\terr = -EINVAL;\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack, \"Egress device not specified\");\n\t\tgoto out;\n\t} else if (dev->flags & IFF_LOOPBACK) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Egress device can not be loopback device for this route\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (need_addr_check &&\n\t    ipv6_chk_addr_and_flags(net, gw_addr, dev, skip_dev, 0, 0)) {\n\t\tNL_SET_ERR_MSG(extack, \"Gateway can not be a local address\");\n\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\treturn err;\n}\n\nstatic bool fib6_is_reject(u32 flags, struct net_device *dev, int addr_type)\n{\n\tif ((flags & RTF_REJECT) ||\n\t    (dev && (dev->flags & IFF_LOOPBACK) &&\n\t     !(addr_type & IPV6_ADDR_LOOPBACK) &&\n\t     !(flags & (RTF_ANYCAST | RTF_LOCAL))))\n\t\treturn true;\n\n\treturn false;\n}\n\nint fib6_nh_init(struct net *net, struct fib6_nh *fib6_nh,\n\t\t struct fib6_config *cfg, gfp_t gfp_flags,\n\t\t struct netlink_ext_ack *extack)\n{\n\tnetdevice_tracker *dev_tracker = &fib6_nh->fib_nh_dev_tracker;\n\tstruct net_device *dev = NULL;\n\tstruct inet6_dev *idev = NULL;\n\tint addr_type;\n\tint err;\n\n\tfib6_nh->fib_nh_family = AF_INET6;\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\tfib6_nh->last_probe = jiffies;\n#endif\n\tif (cfg->fc_is_fdb) {\n\t\tfib6_nh->fib_nh_gw6 = cfg->fc_gateway;\n\t\tfib6_nh->fib_nh_gw_family = AF_INET6;\n\t\treturn 0;\n\t}\n\n\terr = -ENODEV;\n\tif (cfg->fc_ifindex) {\n\t\tdev = netdev_get_by_index(net, cfg->fc_ifindex,\n\t\t\t\t\t  dev_tracker, gfp_flags);\n\t\tif (!dev)\n\t\t\tgoto out;\n\t\tidev = in6_dev_get(dev);\n\t\tif (!idev)\n\t\t\tgoto out;\n\t}\n\n\tif (cfg->fc_flags & RTNH_F_ONLINK) {\n\t\tif (!dev) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Nexthop device required for onlink\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(dev->flags & IFF_UP)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop device is not up\");\n\t\t\terr = -ENETDOWN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfib6_nh->fib_nh_flags |= RTNH_F_ONLINK;\n\t}\n\n\tfib6_nh->fib_nh_weight = 1;\n\n\t \n\taddr_type = ipv6_addr_type(&cfg->fc_dst);\n\tif (fib6_is_reject(cfg->fc_flags, dev, addr_type)) {\n\t\t \n\t\tif (dev != net->loopback_dev) {\n\t\t\tif (dev) {\n\t\t\t\tnetdev_put(dev, dev_tracker);\n\t\t\t\tin6_dev_put(idev);\n\t\t\t}\n\t\t\tdev = net->loopback_dev;\n\t\t\tnetdev_hold(dev, dev_tracker, gfp_flags);\n\t\t\tidev = in6_dev_get(dev);\n\t\t\tif (!idev) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tgoto pcpu_alloc;\n\t}\n\n\tif (cfg->fc_flags & RTF_GATEWAY) {\n\t\terr = ip6_validate_gw(net, cfg, &dev, dev_tracker,\n\t\t\t\t      &idev, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfib6_nh->fib_nh_gw6 = cfg->fc_gateway;\n\t\tfib6_nh->fib_nh_gw_family = AF_INET6;\n\t}\n\n\terr = -ENODEV;\n\tif (!dev)\n\t\tgoto out;\n\n\tif (idev->cnf.disable_ipv6) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv6 is disabled on nexthop device\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (!(dev->flags & IFF_UP) && !cfg->fc_ignore_dev_down) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop device is not up\");\n\t\terr = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\tif (!(cfg->fc_flags & (RTF_LOCAL | RTF_ANYCAST)) &&\n\t    !netif_carrier_ok(dev))\n\t\tfib6_nh->fib_nh_flags |= RTNH_F_LINKDOWN;\n\n\terr = fib_nh_common_init(net, &fib6_nh->nh_common, cfg->fc_encap,\n\t\t\t\t cfg->fc_encap_type, cfg, gfp_flags, extack);\n\tif (err)\n\t\tgoto out;\n\npcpu_alloc:\n\tfib6_nh->rt6i_pcpu = alloc_percpu_gfp(struct rt6_info *, gfp_flags);\n\tif (!fib6_nh->rt6i_pcpu) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfib6_nh->fib_nh_dev = dev;\n\tfib6_nh->fib_nh_oif = dev->ifindex;\n\terr = 0;\nout:\n\tif (idev)\n\t\tin6_dev_put(idev);\n\n\tif (err) {\n\t\tlwtstate_put(fib6_nh->fib_nh_lws);\n\t\tfib6_nh->fib_nh_lws = NULL;\n\t\tnetdev_put(dev, dev_tracker);\n\t}\n\n\treturn err;\n}\n\nvoid fib6_nh_release(struct fib6_nh *fib6_nh)\n{\n\tstruct rt6_exception_bucket *bucket;\n\n\trcu_read_lock();\n\n\tfib6_nh_flush_exceptions(fib6_nh, NULL);\n\tbucket = fib6_nh_get_excptn_bucket(fib6_nh, NULL);\n\tif (bucket) {\n\t\trcu_assign_pointer(fib6_nh->rt6i_exception_bucket, NULL);\n\t\tkfree(bucket);\n\t}\n\n\trcu_read_unlock();\n\n\tfib6_nh_release_dsts(fib6_nh);\n\tfree_percpu(fib6_nh->rt6i_pcpu);\n\n\tfib_nh_common_release(&fib6_nh->nh_common);\n}\n\nvoid fib6_nh_release_dsts(struct fib6_nh *fib6_nh)\n{\n\tint cpu;\n\n\tif (!fib6_nh->rt6i_pcpu)\n\t\treturn;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct rt6_info *pcpu_rt, **ppcpu_rt;\n\n\t\tppcpu_rt = per_cpu_ptr(fib6_nh->rt6i_pcpu, cpu);\n\t\tpcpu_rt = xchg(ppcpu_rt, NULL);\n\t\tif (pcpu_rt) {\n\t\t\tdst_dev_put(&pcpu_rt->dst);\n\t\t\tdst_release(&pcpu_rt->dst);\n\t\t}\n\t}\n}\n\nstatic struct fib6_info *ip6_route_info_create(struct fib6_config *cfg,\n\t\t\t\t\t      gfp_t gfp_flags,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net *net = cfg->fc_nlinfo.nl_net;\n\tstruct fib6_info *rt = NULL;\n\tstruct nexthop *nh = NULL;\n\tstruct fib6_table *table;\n\tstruct fib6_nh *fib6_nh;\n\tint err = -EINVAL;\n\tint addr_type;\n\n\t \n\tif (cfg->fc_flags & RTF_PCPU) {\n\t\tNL_SET_ERR_MSG(extack, \"Userspace can not set RTF_PCPU\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (cfg->fc_flags & RTF_CACHE) {\n\t\tNL_SET_ERR_MSG(extack, \"Userspace can not set RTF_CACHE\");\n\t\tgoto out;\n\t}\n\n\tif (cfg->fc_type > RTN_MAX) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid route type\");\n\t\tgoto out;\n\t}\n\n\tif (cfg->fc_dst_len > 128) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid prefix length\");\n\t\tgoto out;\n\t}\n\tif (cfg->fc_src_len > 128) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid source address length\");\n\t\tgoto out;\n\t}\n#ifndef CONFIG_IPV6_SUBTREES\n\tif (cfg->fc_src_len) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Specifying source address requires IPV6_SUBTREES to be enabled\");\n\t\tgoto out;\n\t}\n#endif\n\tif (cfg->fc_nh_id) {\n\t\tnh = nexthop_find_by_id(net, cfg->fc_nh_id);\n\t\tif (!nh) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop id does not exist\");\n\t\t\tgoto out;\n\t\t}\n\t\terr = fib6_check_nexthop(nh, cfg, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -ENOBUFS;\n\tif (cfg->fc_nlinfo.nlh &&\n\t    !(cfg->fc_nlinfo.nlh->nlmsg_flags & NLM_F_CREATE)) {\n\t\ttable = fib6_get_table(net, cfg->fc_table);\n\t\tif (!table) {\n\t\t\tpr_warn(\"NLM_F_CREATE should be specified when creating new route\\n\");\n\t\t\ttable = fib6_new_table(net, cfg->fc_table);\n\t\t}\n\t} else {\n\t\ttable = fib6_new_table(net, cfg->fc_table);\n\t}\n\n\tif (!table)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\trt = fib6_info_alloc(gfp_flags, !nh);\n\tif (!rt)\n\t\tgoto out;\n\n\trt->fib6_metrics = ip_fib_metrics_init(net, cfg->fc_mx, cfg->fc_mx_len,\n\t\t\t\t\t       extack);\n\tif (IS_ERR(rt->fib6_metrics)) {\n\t\terr = PTR_ERR(rt->fib6_metrics);\n\t\t \n\t\trt->fib6_metrics = (struct dst_metrics *)&dst_default_metrics;\n\t\tgoto out_free;\n\t}\n\n\tif (cfg->fc_flags & RTF_ADDRCONF)\n\t\trt->dst_nocount = true;\n\n\tif (cfg->fc_flags & RTF_EXPIRES)\n\t\tfib6_set_expires(rt, jiffies +\n\t\t\t\tclock_t_to_jiffies(cfg->fc_expires));\n\telse\n\t\tfib6_clean_expires(rt);\n\n\tif (cfg->fc_protocol == RTPROT_UNSPEC)\n\t\tcfg->fc_protocol = RTPROT_BOOT;\n\trt->fib6_protocol = cfg->fc_protocol;\n\n\trt->fib6_table = table;\n\trt->fib6_metric = cfg->fc_metric;\n\trt->fib6_type = cfg->fc_type ? : RTN_UNICAST;\n\trt->fib6_flags = cfg->fc_flags & ~RTF_GATEWAY;\n\n\tipv6_addr_prefix(&rt->fib6_dst.addr, &cfg->fc_dst, cfg->fc_dst_len);\n\trt->fib6_dst.plen = cfg->fc_dst_len;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tipv6_addr_prefix(&rt->fib6_src.addr, &cfg->fc_src, cfg->fc_src_len);\n\trt->fib6_src.plen = cfg->fc_src_len;\n#endif\n\tif (nh) {\n\t\tif (rt->fib6_src.plen) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthops can not be used with source routing\");\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (!nexthop_get(nh)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop has been deleted\");\n\t\t\tgoto out_free;\n\t\t}\n\t\trt->nh = nh;\n\t\tfib6_nh = nexthop_fib6_nh(rt->nh);\n\t} else {\n\t\terr = fib6_nh_init(net, rt->fib6_nh, cfg, gfp_flags, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfib6_nh = rt->fib6_nh;\n\n\t\t \n\t\taddr_type = ipv6_addr_type(&cfg->fc_dst);\n\t\tif (fib6_is_reject(cfg->fc_flags, rt->fib6_nh->fib_nh_dev,\n\t\t\t\t   addr_type))\n\t\t\trt->fib6_flags = RTF_REJECT | RTF_NONEXTHOP;\n\t}\n\n\tif (!ipv6_addr_any(&cfg->fc_prefsrc)) {\n\t\tstruct net_device *dev = fib6_nh->fib_nh_dev;\n\n\t\tif (!ipv6_chk_addr(net, &cfg->fc_prefsrc, dev, 0)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid source address\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trt->fib6_prefsrc.addr = cfg->fc_prefsrc;\n\t\trt->fib6_prefsrc.plen = 128;\n\t} else\n\t\trt->fib6_prefsrc.plen = 0;\n\n\treturn rt;\nout:\n\tfib6_info_release(rt);\n\treturn ERR_PTR(err);\nout_free:\n\tip_fib_metrics_put(rt->fib6_metrics);\n\tkfree(rt);\n\treturn ERR_PTR(err);\n}\n\nint ip6_route_add(struct fib6_config *cfg, gfp_t gfp_flags,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *rt;\n\tint err;\n\n\trt = ip6_route_info_create(cfg, gfp_flags, extack);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\terr = __ip6_ins_rt(rt, &cfg->fc_nlinfo, extack);\n\tfib6_info_release(rt);\n\n\treturn err;\n}\n\nstatic int __ip6_del_rt(struct fib6_info *rt, struct nl_info *info)\n{\n\tstruct net *net = info->nl_net;\n\tstruct fib6_table *table;\n\tint err;\n\n\tif (rt == net->ipv6.fib6_null_entry) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttable = rt->fib6_table;\n\tspin_lock_bh(&table->tb6_lock);\n\terr = fib6_del(rt, info);\n\tspin_unlock_bh(&table->tb6_lock);\n\nout:\n\tfib6_info_release(rt);\n\treturn err;\n}\n\nint ip6_del_rt(struct net *net, struct fib6_info *rt, bool skip_notify)\n{\n\tstruct nl_info info = {\n\t\t.nl_net = net,\n\t\t.skip_notify = skip_notify\n\t};\n\n\treturn __ip6_del_rt(rt, &info);\n}\n\nstatic int __ip6_del_rt_siblings(struct fib6_info *rt, struct fib6_config *cfg)\n{\n\tstruct nl_info *info = &cfg->fc_nlinfo;\n\tstruct net *net = info->nl_net;\n\tstruct sk_buff *skb = NULL;\n\tstruct fib6_table *table;\n\tint err = -ENOENT;\n\n\tif (rt == net->ipv6.fib6_null_entry)\n\t\tgoto out_put;\n\ttable = rt->fib6_table;\n\tspin_lock_bh(&table->tb6_lock);\n\n\tif (rt->fib6_nsiblings && cfg->fc_delete_all_nh) {\n\t\tstruct fib6_info *sibling, *next_sibling;\n\t\tstruct fib6_node *fn;\n\n\t\t \n\t\tskb = nlmsg_new(rt6_nlmsg_size(rt), gfp_any());\n\t\tif (skb) {\n\t\t\tu32 seq = info->nlh ? info->nlh->nlmsg_seq : 0;\n\n\t\t\tif (rt6_fill_node(net, skb, rt, NULL,\n\t\t\t\t\t  NULL, NULL, 0, RTM_DELROUTE,\n\t\t\t\t\t  info->portid, seq, 0) < 0) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tskb = NULL;\n\t\t\t} else\n\t\t\t\tinfo->skip_notify = 1;\n\t\t}\n\n\t\t \n\t\tinfo->skip_notify_kernel = 1;\n\t\tfn = rcu_dereference_protected(rt->fib6_node,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tif (rcu_access_pointer(fn->leaf) == rt) {\n\t\t\tstruct fib6_info *last_sibling, *replace_rt;\n\n\t\t\tlast_sibling = list_last_entry(&rt->fib6_siblings,\n\t\t\t\t\t\t       struct fib6_info,\n\t\t\t\t\t\t       fib6_siblings);\n\t\t\treplace_rt = rcu_dereference_protected(\n\t\t\t\t\t    last_sibling->fib6_next,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\t\tif (replace_rt)\n\t\t\t\tcall_fib6_entry_notifiers_replace(net,\n\t\t\t\t\t\t\t\t  replace_rt);\n\t\t\telse\n\t\t\t\tcall_fib6_multipath_entry_notifiers(net,\n\t\t\t\t\t\t       FIB_EVENT_ENTRY_DEL,\n\t\t\t\t\t\t       rt, rt->fib6_nsiblings,\n\t\t\t\t\t\t       NULL);\n\t\t}\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t &rt->fib6_siblings,\n\t\t\t\t\t fib6_siblings) {\n\t\t\terr = fib6_del(sibling, info);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\terr = fib6_del(rt, info);\nout_unlock:\n\tspin_unlock_bh(&table->tb6_lock);\nout_put:\n\tfib6_info_release(rt);\n\n\tif (skb) {\n\t\trtnl_notify(skb, net, info->portid, RTNLGRP_IPV6_ROUTE,\n\t\t\t    info->nlh, gfp_any());\n\t}\n\treturn err;\n}\n\nstatic int __ip6_del_cached_rt(struct rt6_info *rt, struct fib6_config *cfg)\n{\n\tint rc = -ESRCH;\n\n\tif (cfg->fc_ifindex && rt->dst.dev->ifindex != cfg->fc_ifindex)\n\t\tgoto out;\n\n\tif (cfg->fc_flags & RTF_GATEWAY &&\n\t    !ipv6_addr_equal(&cfg->fc_gateway, &rt->rt6i_gateway))\n\t\tgoto out;\n\n\trc = rt6_remove_exception_rt(rt);\nout:\n\treturn rc;\n}\n\nstatic int ip6_del_cached_rt(struct fib6_config *cfg, struct fib6_info *rt,\n\t\t\t     struct fib6_nh *nh)\n{\n\tstruct fib6_result res = {\n\t\t.f6i = rt,\n\t\t.nh = nh,\n\t};\n\tstruct rt6_info *rt_cache;\n\n\trt_cache = rt6_find_cached_rt(&res, &cfg->fc_dst, &cfg->fc_src);\n\tif (rt_cache)\n\t\treturn __ip6_del_cached_rt(rt_cache, cfg);\n\n\treturn 0;\n}\n\nstruct fib6_nh_del_cached_rt_arg {\n\tstruct fib6_config *cfg;\n\tstruct fib6_info *f6i;\n};\n\nstatic int fib6_nh_del_cached_rt(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_del_cached_rt_arg *arg = _arg;\n\tint rc;\n\n\trc = ip6_del_cached_rt(arg->cfg, arg->f6i, nh);\n\treturn rc != -ESRCH ? rc : 0;\n}\n\nstatic int ip6_del_cached_rt_nh(struct fib6_config *cfg, struct fib6_info *f6i)\n{\n\tstruct fib6_nh_del_cached_rt_arg arg = {\n\t\t.cfg = cfg,\n\t\t.f6i = f6i\n\t};\n\n\treturn nexthop_for_each_fib6_nh(f6i->nh, fib6_nh_del_cached_rt, &arg);\n}\n\nstatic int ip6_route_del(struct fib6_config *cfg,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct fib6_table *table;\n\tstruct fib6_info *rt;\n\tstruct fib6_node *fn;\n\tint err = -ESRCH;\n\n\ttable = fib6_get_table(cfg->fc_nlinfo.nl_net, cfg->fc_table);\n\tif (!table) {\n\t\tNL_SET_ERR_MSG(extack, \"FIB table does not exist\");\n\t\treturn err;\n\t}\n\n\trcu_read_lock();\n\n\tfn = fib6_locate(&table->tb6_root,\n\t\t\t &cfg->fc_dst, cfg->fc_dst_len,\n\t\t\t &cfg->fc_src, cfg->fc_src_len,\n\t\t\t !(cfg->fc_flags & RTF_CACHE));\n\n\tif (fn) {\n\t\tfor_each_fib6_node_rt_rcu(fn) {\n\t\t\tstruct fib6_nh *nh;\n\n\t\t\tif (rt->nh && cfg->fc_nh_id &&\n\t\t\t    rt->nh->id != cfg->fc_nh_id)\n\t\t\t\tcontinue;\n\n\t\t\tif (cfg->fc_flags & RTF_CACHE) {\n\t\t\t\tint rc = 0;\n\n\t\t\t\tif (rt->nh) {\n\t\t\t\t\trc = ip6_del_cached_rt_nh(cfg, rt);\n\t\t\t\t} else if (cfg->fc_nh_id) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tnh = rt->fib6_nh;\n\t\t\t\t\trc = ip6_del_cached_rt(cfg, rt, nh);\n\t\t\t\t}\n\t\t\t\tif (rc != -ESRCH) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (cfg->fc_metric && cfg->fc_metric != rt->fib6_metric)\n\t\t\t\tcontinue;\n\t\t\tif (cfg->fc_protocol &&\n\t\t\t    cfg->fc_protocol != rt->fib6_protocol)\n\t\t\t\tcontinue;\n\n\t\t\tif (rt->nh) {\n\t\t\t\tif (!fib6_info_hold_safe(rt))\n\t\t\t\t\tcontinue;\n\t\t\t\trcu_read_unlock();\n\n\t\t\t\treturn __ip6_del_rt(rt, &cfg->fc_nlinfo);\n\t\t\t}\n\t\t\tif (cfg->fc_nh_id)\n\t\t\t\tcontinue;\n\n\t\t\tnh = rt->fib6_nh;\n\t\t\tif (cfg->fc_ifindex &&\n\t\t\t    (!nh->fib_nh_dev ||\n\t\t\t     nh->fib_nh_dev->ifindex != cfg->fc_ifindex))\n\t\t\t\tcontinue;\n\t\t\tif (cfg->fc_flags & RTF_GATEWAY &&\n\t\t\t    !ipv6_addr_equal(&cfg->fc_gateway, &nh->fib_nh_gw6))\n\t\t\t\tcontinue;\n\t\t\tif (!fib6_info_hold_safe(rt))\n\t\t\t\tcontinue;\n\t\t\trcu_read_unlock();\n\n\t\t\t \n\t\t\tif (cfg->fc_flags & RTF_GATEWAY)\n\t\t\t\treturn __ip6_del_rt(rt, &cfg->fc_nlinfo);\n\n\t\t\treturn __ip6_del_rt_siblings(rt, cfg);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic void rt6_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct netevent_redirect netevent;\n\tstruct rt6_info *rt, *nrt = NULL;\n\tstruct fib6_result res = {};\n\tstruct ndisc_options ndopts;\n\tstruct inet6_dev *in6_dev;\n\tstruct neighbour *neigh;\n\tstruct rd_msg *msg;\n\tint optlen, on_link;\n\tu8 *lladdr;\n\n\toptlen = skb_tail_pointer(skb) - skb_transport_header(skb);\n\toptlen -= sizeof(*msg);\n\n\tif (optlen < 0) {\n\t\tnet_dbg_ratelimited(\"rt6_do_redirect: packet too short\\n\");\n\t\treturn;\n\t}\n\n\tmsg = (struct rd_msg *)icmp6_hdr(skb);\n\n\tif (ipv6_addr_is_multicast(&msg->dest)) {\n\t\tnet_dbg_ratelimited(\"rt6_do_redirect: destination address is multicast\\n\");\n\t\treturn;\n\t}\n\n\ton_link = 0;\n\tif (ipv6_addr_equal(&msg->dest, &msg->target)) {\n\t\ton_link = 1;\n\t} else if (ipv6_addr_type(&msg->target) !=\n\t\t   (IPV6_ADDR_UNICAST|IPV6_ADDR_LINKLOCAL)) {\n\t\tnet_dbg_ratelimited(\"rt6_do_redirect: target address is not link-local unicast\\n\");\n\t\treturn;\n\t}\n\n\tin6_dev = __in6_dev_get(skb->dev);\n\tif (!in6_dev)\n\t\treturn;\n\tif (in6_dev->cnf.forwarding || !in6_dev->cnf.accept_redirects)\n\t\treturn;\n\n\t \n\n\tif (!ndisc_parse_options(skb->dev, msg->opt, optlen, &ndopts)) {\n\t\tnet_dbg_ratelimited(\"rt6_redirect: invalid ND options\\n\");\n\t\treturn;\n\t}\n\n\tlladdr = NULL;\n\tif (ndopts.nd_opts_tgt_lladdr) {\n\t\tlladdr = ndisc_opt_addr_data(ndopts.nd_opts_tgt_lladdr,\n\t\t\t\t\t     skb->dev);\n\t\tif (!lladdr) {\n\t\t\tnet_dbg_ratelimited(\"rt6_redirect: invalid link-layer address length\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\trt = (struct rt6_info *) dst;\n\tif (rt->rt6i_flags & RTF_REJECT) {\n\t\tnet_dbg_ratelimited(\"rt6_redirect: source isn't a valid nexthop for redirect target\\n\");\n\t\treturn;\n\t}\n\n\t \n\tdst_confirm_neigh(&rt->dst, &ipv6_hdr(skb)->saddr);\n\n\tneigh = __neigh_lookup(&nd_tbl, &msg->target, skb->dev, 1);\n\tif (!neigh)\n\t\treturn;\n\n\t \n\n\tndisc_update(skb->dev, neigh, lladdr, NUD_STALE,\n\t\t     NEIGH_UPDATE_F_WEAK_OVERRIDE|\n\t\t     NEIGH_UPDATE_F_OVERRIDE|\n\t\t     (on_link ? 0 : (NEIGH_UPDATE_F_OVERRIDE_ISROUTER|\n\t\t\t\t     NEIGH_UPDATE_F_ISROUTER)),\n\t\t     NDISC_REDIRECT, &ndopts);\n\n\trcu_read_lock();\n\tres.f6i = rcu_dereference(rt->from);\n\tif (!res.f6i)\n\t\tgoto out;\n\n\tif (res.f6i->nh) {\n\t\tstruct fib6_nh_match_arg arg = {\n\t\t\t.dev = dst->dev,\n\t\t\t.gw = &rt->rt6i_gateway,\n\t\t};\n\n\t\tnexthop_for_each_fib6_nh(res.f6i->nh,\n\t\t\t\t\t fib6_nh_find_match, &arg);\n\n\t\t \n\t\tif (!arg.match)\n\t\t\tgoto out;\n\t\tres.nh = arg.match;\n\t} else {\n\t\tres.nh = res.f6i->fib6_nh;\n\t}\n\n\tres.fib6_flags = res.f6i->fib6_flags;\n\tres.fib6_type = res.f6i->fib6_type;\n\tnrt = ip6_rt_cache_alloc(&res, &msg->dest, NULL);\n\tif (!nrt)\n\t\tgoto out;\n\n\tnrt->rt6i_flags = RTF_GATEWAY|RTF_UP|RTF_DYNAMIC|RTF_CACHE;\n\tif (on_link)\n\t\tnrt->rt6i_flags &= ~RTF_GATEWAY;\n\n\tnrt->rt6i_gateway = *(struct in6_addr *)neigh->primary_key;\n\n\t \n\tif (rt6_insert_exception(nrt, &res)) {\n\t\tdst_release_immediate(&nrt->dst);\n\t\tgoto out;\n\t}\n\n\tnetevent.old = &rt->dst;\n\tnetevent.new = &nrt->dst;\n\tnetevent.daddr = &msg->dest;\n\tnetevent.neigh = neigh;\n\tcall_netevent_notifiers(NETEVENT_REDIRECT, &netevent);\n\nout:\n\trcu_read_unlock();\n\tneigh_release(neigh);\n}\n\n#ifdef CONFIG_IPV6_ROUTE_INFO\nstatic struct fib6_info *rt6_get_route_info(struct net *net,\n\t\t\t\t\t   const struct in6_addr *prefix, int prefixlen,\n\t\t\t\t\t   const struct in6_addr *gwaddr,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tu32 tb_id = l3mdev_fib_table(dev) ? : RT6_TABLE_INFO;\n\tint ifindex = dev->ifindex;\n\tstruct fib6_node *fn;\n\tstruct fib6_info *rt = NULL;\n\tstruct fib6_table *table;\n\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tfn = fib6_locate(&table->tb6_root, prefix, prefixlen, NULL, 0, true);\n\tif (!fn)\n\t\tgoto out;\n\n\tfor_each_fib6_node_rt_rcu(fn) {\n\t\t \n\t\tif (rt->nh)\n\t\t\tcontinue;\n\t\tif (rt->fib6_nh->fib_nh_dev->ifindex != ifindex)\n\t\t\tcontinue;\n\t\tif (!(rt->fib6_flags & RTF_ROUTEINFO) ||\n\t\t    !rt->fib6_nh->fib_nh_gw_family)\n\t\t\tcontinue;\n\t\tif (!ipv6_addr_equal(&rt->fib6_nh->fib_nh_gw6, gwaddr))\n\t\t\tcontinue;\n\t\tif (!fib6_info_hold_safe(rt))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\nout:\n\trcu_read_unlock();\n\treturn rt;\n}\n\nstatic struct fib6_info *rt6_add_route_info(struct net *net,\n\t\t\t\t\t   const struct in6_addr *prefix, int prefixlen,\n\t\t\t\t\t   const struct in6_addr *gwaddr,\n\t\t\t\t\t   struct net_device *dev,\n\t\t\t\t\t   unsigned int pref)\n{\n\tstruct fib6_config cfg = {\n\t\t.fc_metric\t= IP6_RT_PRIO_USER,\n\t\t.fc_ifindex\t= dev->ifindex,\n\t\t.fc_dst_len\t= prefixlen,\n\t\t.fc_flags\t= RTF_GATEWAY | RTF_ADDRCONF | RTF_ROUTEINFO |\n\t\t\t\t  RTF_UP | RTF_PREF(pref),\n\t\t.fc_protocol = RTPROT_RA,\n\t\t.fc_type = RTN_UNICAST,\n\t\t.fc_nlinfo.portid = 0,\n\t\t.fc_nlinfo.nlh = NULL,\n\t\t.fc_nlinfo.nl_net = net,\n\t};\n\n\tcfg.fc_table = l3mdev_fib_table(dev) ? : RT6_TABLE_INFO;\n\tcfg.fc_dst = *prefix;\n\tcfg.fc_gateway = *gwaddr;\n\n\t \n\tif (!prefixlen)\n\t\tcfg.fc_flags |= RTF_DEFAULT;\n\n\tip6_route_add(&cfg, GFP_ATOMIC, NULL);\n\n\treturn rt6_get_route_info(net, prefix, prefixlen, gwaddr, dev);\n}\n#endif\n\nstruct fib6_info *rt6_get_dflt_router(struct net *net,\n\t\t\t\t     const struct in6_addr *addr,\n\t\t\t\t     struct net_device *dev)\n{\n\tu32 tb_id = l3mdev_fib_table(dev) ? : RT6_TABLE_DFLT;\n\tstruct fib6_info *rt;\n\tstruct fib6_table *table;\n\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tfor_each_fib6_node_rt_rcu(&table->tb6_root) {\n\t\tstruct fib6_nh *nh;\n\n\t\t \n\t\tif (rt->nh)\n\t\t\tcontinue;\n\n\t\tnh = rt->fib6_nh;\n\t\tif (dev == nh->fib_nh_dev &&\n\t\t    ((rt->fib6_flags & (RTF_ADDRCONF | RTF_DEFAULT)) == (RTF_ADDRCONF | RTF_DEFAULT)) &&\n\t\t    ipv6_addr_equal(&nh->fib_nh_gw6, addr))\n\t\t\tbreak;\n\t}\n\tif (rt && !fib6_info_hold_safe(rt))\n\t\trt = NULL;\n\trcu_read_unlock();\n\treturn rt;\n}\n\nstruct fib6_info *rt6_add_dflt_router(struct net *net,\n\t\t\t\t     const struct in6_addr *gwaddr,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     unsigned int pref,\n\t\t\t\t     u32 defrtr_usr_metric)\n{\n\tstruct fib6_config cfg = {\n\t\t.fc_table\t= l3mdev_fib_table(dev) ? : RT6_TABLE_DFLT,\n\t\t.fc_metric\t= defrtr_usr_metric,\n\t\t.fc_ifindex\t= dev->ifindex,\n\t\t.fc_flags\t= RTF_GATEWAY | RTF_ADDRCONF | RTF_DEFAULT |\n\t\t\t\t  RTF_UP | RTF_EXPIRES | RTF_PREF(pref),\n\t\t.fc_protocol = RTPROT_RA,\n\t\t.fc_type = RTN_UNICAST,\n\t\t.fc_nlinfo.portid = 0,\n\t\t.fc_nlinfo.nlh = NULL,\n\t\t.fc_nlinfo.nl_net = net,\n\t};\n\n\tcfg.fc_gateway = *gwaddr;\n\n\tif (!ip6_route_add(&cfg, GFP_ATOMIC, NULL)) {\n\t\tstruct fib6_table *table;\n\n\t\ttable = fib6_get_table(dev_net(dev), cfg.fc_table);\n\t\tif (table)\n\t\t\ttable->flags |= RT6_TABLE_HAS_DFLT_ROUTER;\n\t}\n\n\treturn rt6_get_dflt_router(net, gwaddr, dev);\n}\n\nstatic void __rt6_purge_dflt_routers(struct net *net,\n\t\t\t\t     struct fib6_table *table)\n{\n\tstruct fib6_info *rt;\n\nrestart:\n\trcu_read_lock();\n\tfor_each_fib6_node_rt_rcu(&table->tb6_root) {\n\t\tstruct net_device *dev = fib6_info_nh_dev(rt);\n\t\tstruct inet6_dev *idev = dev ? __in6_dev_get(dev) : NULL;\n\n\t\tif (rt->fib6_flags & (RTF_DEFAULT | RTF_ADDRCONF) &&\n\t\t    (!idev || idev->cnf.accept_ra != 2) &&\n\t\t    fib6_info_hold_safe(rt)) {\n\t\t\trcu_read_unlock();\n\t\t\tip6_del_rt(net, rt, false);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\ttable->flags &= ~RT6_TABLE_HAS_DFLT_ROUTER;\n}\n\nvoid rt6_purge_dflt_routers(struct net *net)\n{\n\tstruct fib6_table *table;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\trcu_read_lock();\n\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(table, head, tb6_hlist) {\n\t\t\tif (table->flags & RT6_TABLE_HAS_DFLT_ROUTER)\n\t\t\t\t__rt6_purge_dflt_routers(net, table);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic void rtmsg_to_fib6_config(struct net *net,\n\t\t\t\t struct in6_rtmsg *rtmsg,\n\t\t\t\t struct fib6_config *cfg)\n{\n\t*cfg = (struct fib6_config){\n\t\t.fc_table = l3mdev_fib_table_by_index(net, rtmsg->rtmsg_ifindex) ?\n\t\t\t : RT6_TABLE_MAIN,\n\t\t.fc_ifindex = rtmsg->rtmsg_ifindex,\n\t\t.fc_metric = rtmsg->rtmsg_metric ? : IP6_RT_PRIO_USER,\n\t\t.fc_expires = rtmsg->rtmsg_info,\n\t\t.fc_dst_len = rtmsg->rtmsg_dst_len,\n\t\t.fc_src_len = rtmsg->rtmsg_src_len,\n\t\t.fc_flags = rtmsg->rtmsg_flags,\n\t\t.fc_type = rtmsg->rtmsg_type,\n\n\t\t.fc_nlinfo.nl_net = net,\n\n\t\t.fc_dst = rtmsg->rtmsg_dst,\n\t\t.fc_src = rtmsg->rtmsg_src,\n\t\t.fc_gateway = rtmsg->rtmsg_gateway,\n\t};\n}\n\nint ipv6_route_ioctl(struct net *net, unsigned int cmd, struct in6_rtmsg *rtmsg)\n{\n\tstruct fib6_config cfg;\n\tint err;\n\n\tif (cmd != SIOCADDRT && cmd != SIOCDELRT)\n\t\treturn -EINVAL;\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\trtmsg_to_fib6_config(net, rtmsg, &cfg);\n\n\trtnl_lock();\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\t\terr = ip6_route_add(&cfg, GFP_KERNEL, NULL);\n\t\tbreak;\n\tcase SIOCDELRT:\n\t\terr = ip6_route_del(&cfg, NULL);\n\t\tbreak;\n\t}\n\trtnl_unlock();\n\treturn err;\n}\n\n \n\nstatic int ip6_pkt_drop(struct sk_buff *skb, u8 code, int ipstats_mib_noroutes)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net *net = dev_net(dst->dev);\n\tstruct inet6_dev *idev;\n\tSKB_DR(reason);\n\tint type;\n\n\tif (netif_is_l3_master(skb->dev) ||\n\t    dst->dev == net->loopback_dev)\n\t\tidev = __in6_dev_get_safely(dev_get_by_index_rcu(net, IP6CB(skb)->iif));\n\telse\n\t\tidev = ip6_dst_idev(dst);\n\n\tswitch (ipstats_mib_noroutes) {\n\tcase IPSTATS_MIB_INNOROUTES:\n\t\ttype = ipv6_addr_type(&ipv6_hdr(skb)->daddr);\n\t\tif (type == IPV6_ADDR_ANY) {\n\t\t\tSKB_DR_SET(reason, IP_INADDRERRORS);\n\t\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_INADDRERRORS);\n\t\t\tbreak;\n\t\t}\n\t\tSKB_DR_SET(reason, IP_INNOROUTES);\n\t\tfallthrough;\n\tcase IPSTATS_MIB_OUTNOROUTES:\n\t\tSKB_DR_OR(reason, IP_OUTNOROUTES);\n\t\tIP6_INC_STATS(net, idev, ipstats_mib_noroutes);\n\t\tbreak;\n\t}\n\n\t \n\tif (netif_is_l3_master(skb->dev))\n\t\tskb_dst_drop(skb);\n\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, code, 0);\n\tkfree_skb_reason(skb, reason);\n\treturn 0;\n}\n\nstatic int ip6_pkt_discard(struct sk_buff *skb)\n{\n\treturn ip6_pkt_drop(skb, ICMPV6_NOROUTE, IPSTATS_MIB_INNOROUTES);\n}\n\nstatic int ip6_pkt_discard_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tskb->dev = skb_dst(skb)->dev;\n\treturn ip6_pkt_drop(skb, ICMPV6_NOROUTE, IPSTATS_MIB_OUTNOROUTES);\n}\n\nstatic int ip6_pkt_prohibit(struct sk_buff *skb)\n{\n\treturn ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_INNOROUTES);\n}\n\nstatic int ip6_pkt_prohibit_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tskb->dev = skb_dst(skb)->dev;\n\treturn ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_OUTNOROUTES);\n}\n\n \n\nstruct fib6_info *addrconf_f6i_alloc(struct net *net,\n\t\t\t\t     struct inet6_dev *idev,\n\t\t\t\t     const struct in6_addr *addr,\n\t\t\t\t     bool anycast, gfp_t gfp_flags,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct fib6_config cfg = {\n\t\t.fc_table = l3mdev_fib_table(idev->dev) ? : RT6_TABLE_LOCAL,\n\t\t.fc_ifindex = idev->dev->ifindex,\n\t\t.fc_flags = RTF_UP | RTF_NONEXTHOP,\n\t\t.fc_dst = *addr,\n\t\t.fc_dst_len = 128,\n\t\t.fc_protocol = RTPROT_KERNEL,\n\t\t.fc_nlinfo.nl_net = net,\n\t\t.fc_ignore_dev_down = true,\n\t};\n\tstruct fib6_info *f6i;\n\n\tif (anycast) {\n\t\tcfg.fc_type = RTN_ANYCAST;\n\t\tcfg.fc_flags |= RTF_ANYCAST;\n\t} else {\n\t\tcfg.fc_type = RTN_LOCAL;\n\t\tcfg.fc_flags |= RTF_LOCAL;\n\t}\n\n\tf6i = ip6_route_info_create(&cfg, gfp_flags, extack);\n\tif (!IS_ERR(f6i)) {\n\t\tf6i->dst_nocount = true;\n\n\t\tif (!anycast &&\n\t\t    (net->ipv6.devconf_all->disable_policy ||\n\t\t     idev->cnf.disable_policy))\n\t\t\tf6i->dst_nopolicy = true;\n\t}\n\n\treturn f6i;\n}\n\n \nstruct arg_dev_net_ip {\n\tstruct net *net;\n\tstruct in6_addr *addr;\n};\n\nstatic int fib6_remove_prefsrc(struct fib6_info *rt, void *arg)\n{\n\tstruct net *net = ((struct arg_dev_net_ip *)arg)->net;\n\tstruct in6_addr *addr = ((struct arg_dev_net_ip *)arg)->addr;\n\n\tif (!rt->nh &&\n\t    rt != net->ipv6.fib6_null_entry &&\n\t    ipv6_addr_equal(addr, &rt->fib6_prefsrc.addr) &&\n\t    !ipv6_chk_addr(net, addr, rt->fib6_nh->fib_nh_dev, 0)) {\n\t\tspin_lock_bh(&rt6_exception_lock);\n\t\t \n\t\trt->fib6_prefsrc.plen = 0;\n\t\tspin_unlock_bh(&rt6_exception_lock);\n\t}\n\treturn 0;\n}\n\nvoid rt6_remove_prefsrc(struct inet6_ifaddr *ifp)\n{\n\tstruct net *net = dev_net(ifp->idev->dev);\n\tstruct arg_dev_net_ip adni = {\n\t\t.net = net,\n\t\t.addr = &ifp->addr,\n\t};\n\tfib6_clean_all(net, fib6_remove_prefsrc, &adni);\n}\n\n#define RTF_RA_ROUTER\t\t(RTF_ADDRCONF | RTF_DEFAULT)\n\n \nstatic int fib6_clean_tohost(struct fib6_info *rt, void *arg)\n{\n\tstruct in6_addr *gateway = (struct in6_addr *)arg;\n\tstruct fib6_nh *nh;\n\n\t \n\tif (rt->nh)\n\t\treturn 0;\n\n\tnh = rt->fib6_nh;\n\tif (((rt->fib6_flags & RTF_RA_ROUTER) == RTF_RA_ROUTER) &&\n\t    nh->fib_nh_gw_family && ipv6_addr_equal(gateway, &nh->fib_nh_gw6))\n\t\treturn -1;\n\n\t \n\tfib6_nh_exceptions_clean_tohost(nh, gateway);\n\n\treturn 0;\n}\n\nvoid rt6_clean_tohost(struct net *net, struct in6_addr *gateway)\n{\n\tfib6_clean_all(net, fib6_clean_tohost, gateway);\n}\n\nstruct arg_netdev_event {\n\tconst struct net_device *dev;\n\tunion {\n\t\tunsigned char nh_flags;\n\t\tunsigned long event;\n\t};\n};\n\nstatic struct fib6_info *rt6_multipath_first_sibling(const struct fib6_info *rt)\n{\n\tstruct fib6_info *iter;\n\tstruct fib6_node *fn;\n\n\tfn = rcu_dereference_protected(rt->fib6_node,\n\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\titer = rcu_dereference_protected(fn->leaf,\n\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\twhile (iter) {\n\t\tif (iter->fib6_metric == rt->fib6_metric &&\n\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\treturn iter;\n\t\titer = rcu_dereference_protected(iter->fib6_next,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t}\n\n\treturn NULL;\n}\n\n \nstatic bool rt6_is_dead(const struct fib6_info *rt)\n{\n\tif (rt->fib6_nh->fib_nh_flags & RTNH_F_DEAD ||\n\t    (rt->fib6_nh->fib_nh_flags & RTNH_F_LINKDOWN &&\n\t     ip6_ignore_linkdown(rt->fib6_nh->fib_nh_dev)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int rt6_multipath_total_weight(const struct fib6_info *rt)\n{\n\tstruct fib6_info *iter;\n\tint total = 0;\n\n\tif (!rt6_is_dead(rt))\n\t\ttotal += rt->fib6_nh->fib_nh_weight;\n\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings) {\n\t\tif (!rt6_is_dead(iter))\n\t\t\ttotal += iter->fib6_nh->fib_nh_weight;\n\t}\n\n\treturn total;\n}\n\nstatic void rt6_upper_bound_set(struct fib6_info *rt, int *weight, int total)\n{\n\tint upper_bound = -1;\n\n\tif (!rt6_is_dead(rt)) {\n\t\t*weight += rt->fib6_nh->fib_nh_weight;\n\t\tupper_bound = DIV_ROUND_CLOSEST_ULL((u64) (*weight) << 31,\n\t\t\t\t\t\t    total) - 1;\n\t}\n\tatomic_set(&rt->fib6_nh->fib_nh_upper_bound, upper_bound);\n}\n\nstatic void rt6_multipath_upper_bound_set(struct fib6_info *rt, int total)\n{\n\tstruct fib6_info *iter;\n\tint weight = 0;\n\n\trt6_upper_bound_set(rt, &weight, total);\n\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings)\n\t\trt6_upper_bound_set(iter, &weight, total);\n}\n\nvoid rt6_multipath_rebalance(struct fib6_info *rt)\n{\n\tstruct fib6_info *first;\n\tint total;\n\n\t \n\tif (!rt->fib6_nsiblings || rt->should_flush)\n\t\treturn;\n\n\t \n\tfirst = rt6_multipath_first_sibling(rt);\n\tif (WARN_ON_ONCE(!first))\n\t\treturn;\n\n\ttotal = rt6_multipath_total_weight(first);\n\trt6_multipath_upper_bound_set(first, total);\n}\n\nstatic int fib6_ifup(struct fib6_info *rt, void *p_arg)\n{\n\tconst struct arg_netdev_event *arg = p_arg;\n\tstruct net *net = dev_net(arg->dev);\n\n\tif (rt != net->ipv6.fib6_null_entry && !rt->nh &&\n\t    rt->fib6_nh->fib_nh_dev == arg->dev) {\n\t\trt->fib6_nh->fib_nh_flags &= ~arg->nh_flags;\n\t\tfib6_update_sernum_upto_root(net, rt);\n\t\trt6_multipath_rebalance(rt);\n\t}\n\n\treturn 0;\n}\n\nvoid rt6_sync_up(struct net_device *dev, unsigned char nh_flags)\n{\n\tstruct arg_netdev_event arg = {\n\t\t.dev = dev,\n\t\t{\n\t\t\t.nh_flags = nh_flags,\n\t\t},\n\t};\n\n\tif (nh_flags & RTNH_F_DEAD && netif_carrier_ok(dev))\n\t\targ.nh_flags |= RTNH_F_LINKDOWN;\n\n\tfib6_clean_all(dev_net(dev), fib6_ifup, &arg);\n}\n\n \nstatic bool rt6_multipath_uses_dev(const struct fib6_info *rt,\n\t\t\t\t   const struct net_device *dev)\n{\n\tstruct fib6_info *iter;\n\n\tif (rt->fib6_nh->fib_nh_dev == dev)\n\t\treturn true;\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings)\n\t\tif (iter->fib6_nh->fib_nh_dev == dev)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void rt6_multipath_flush(struct fib6_info *rt)\n{\n\tstruct fib6_info *iter;\n\n\trt->should_flush = 1;\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings)\n\t\titer->should_flush = 1;\n}\n\nstatic unsigned int rt6_multipath_dead_count(const struct fib6_info *rt,\n\t\t\t\t\t     const struct net_device *down_dev)\n{\n\tstruct fib6_info *iter;\n\tunsigned int dead = 0;\n\n\tif (rt->fib6_nh->fib_nh_dev == down_dev ||\n\t    rt->fib6_nh->fib_nh_flags & RTNH_F_DEAD)\n\t\tdead++;\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings)\n\t\tif (iter->fib6_nh->fib_nh_dev == down_dev ||\n\t\t    iter->fib6_nh->fib_nh_flags & RTNH_F_DEAD)\n\t\t\tdead++;\n\n\treturn dead;\n}\n\nstatic void rt6_multipath_nh_flags_set(struct fib6_info *rt,\n\t\t\t\t       const struct net_device *dev,\n\t\t\t\t       unsigned char nh_flags)\n{\n\tstruct fib6_info *iter;\n\n\tif (rt->fib6_nh->fib_nh_dev == dev)\n\t\trt->fib6_nh->fib_nh_flags |= nh_flags;\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings)\n\t\tif (iter->fib6_nh->fib_nh_dev == dev)\n\t\t\titer->fib6_nh->fib_nh_flags |= nh_flags;\n}\n\n \nstatic int fib6_ifdown(struct fib6_info *rt, void *p_arg)\n{\n\tconst struct arg_netdev_event *arg = p_arg;\n\tconst struct net_device *dev = arg->dev;\n\tstruct net *net = dev_net(dev);\n\n\tif (rt == net->ipv6.fib6_null_entry || rt->nh)\n\t\treturn 0;\n\n\tswitch (arg->event) {\n\tcase NETDEV_UNREGISTER:\n\t\treturn rt->fib6_nh->fib_nh_dev == dev ? -1 : 0;\n\tcase NETDEV_DOWN:\n\t\tif (rt->should_flush)\n\t\t\treturn -1;\n\t\tif (!rt->fib6_nsiblings)\n\t\t\treturn rt->fib6_nh->fib_nh_dev == dev ? -1 : 0;\n\t\tif (rt6_multipath_uses_dev(rt, dev)) {\n\t\t\tunsigned int count;\n\n\t\t\tcount = rt6_multipath_dead_count(rt, dev);\n\t\t\tif (rt->fib6_nsiblings + 1 == count) {\n\t\t\t\trt6_multipath_flush(rt);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\trt6_multipath_nh_flags_set(rt, dev, RTNH_F_DEAD |\n\t\t\t\t\t\t   RTNH_F_LINKDOWN);\n\t\t\tfib6_update_sernum(net, rt);\n\t\t\trt6_multipath_rebalance(rt);\n\t\t}\n\t\treturn -2;\n\tcase NETDEV_CHANGE:\n\t\tif (rt->fib6_nh->fib_nh_dev != dev ||\n\t\t    rt->fib6_flags & (RTF_LOCAL | RTF_ANYCAST))\n\t\t\tbreak;\n\t\trt->fib6_nh->fib_nh_flags |= RTNH_F_LINKDOWN;\n\t\trt6_multipath_rebalance(rt);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nvoid rt6_sync_down_dev(struct net_device *dev, unsigned long event)\n{\n\tstruct arg_netdev_event arg = {\n\t\t.dev = dev,\n\t\t{\n\t\t\t.event = event,\n\t\t},\n\t};\n\tstruct net *net = dev_net(dev);\n\n\tif (net->ipv6.sysctl.skip_notify_on_dev_down)\n\t\tfib6_clean_all_skip_notify(net, fib6_ifdown, &arg);\n\telse\n\t\tfib6_clean_all(net, fib6_ifdown, &arg);\n}\n\nvoid rt6_disable_ip(struct net_device *dev, unsigned long event)\n{\n\trt6_sync_down_dev(dev, event);\n\trt6_uncached_list_flush_dev(dev);\n\tneigh_ifdown(&nd_tbl, dev);\n}\n\nstruct rt6_mtu_change_arg {\n\tstruct net_device *dev;\n\tunsigned int mtu;\n\tstruct fib6_info *f6i;\n};\n\nstatic int fib6_nh_mtu_change(struct fib6_nh *nh, void *_arg)\n{\n\tstruct rt6_mtu_change_arg *arg = (struct rt6_mtu_change_arg *)_arg;\n\tstruct fib6_info *f6i = arg->f6i;\n\n\t \n\tif (nh->fib_nh_dev == arg->dev) {\n\t\tstruct inet6_dev *idev = __in6_dev_get(arg->dev);\n\t\tu32 mtu = f6i->fib6_pmtu;\n\n\t\tif (mtu >= arg->mtu ||\n\t\t    (mtu < arg->mtu && mtu == idev->cnf.mtu6))\n\t\t\tfib6_metric_set(f6i, RTAX_MTU, arg->mtu);\n\n\t\tspin_lock_bh(&rt6_exception_lock);\n\t\trt6_exceptions_update_pmtu(idev, nh, arg->mtu);\n\t\tspin_unlock_bh(&rt6_exception_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int rt6_mtu_change_route(struct fib6_info *f6i, void *p_arg)\n{\n\tstruct rt6_mtu_change_arg *arg = (struct rt6_mtu_change_arg *) p_arg;\n\tstruct inet6_dev *idev;\n\n\t \n\n\tidev = __in6_dev_get(arg->dev);\n\tif (!idev)\n\t\treturn 0;\n\n\tif (fib6_metric_locked(f6i, RTAX_MTU))\n\t\treturn 0;\n\n\targ->f6i = f6i;\n\tif (f6i->nh) {\n\t\t \n\t\treturn nexthop_for_each_fib6_nh(f6i->nh, fib6_nh_mtu_change,\n\t\t\t\t\t\targ);\n\t}\n\n\treturn fib6_nh_mtu_change(f6i->fib6_nh, arg);\n}\n\nvoid rt6_mtu_change(struct net_device *dev, unsigned int mtu)\n{\n\tstruct rt6_mtu_change_arg arg = {\n\t\t.dev = dev,\n\t\t.mtu = mtu,\n\t};\n\n\tfib6_clean_all(dev_net(dev), rt6_mtu_change_route, &arg);\n}\n\nstatic const struct nla_policy rtm_ipv6_policy[RTA_MAX+1] = {\n\t[RTA_UNSPEC]\t\t= { .strict_start_type = RTA_DPORT + 1 },\n\t[RTA_GATEWAY]           = { .len = sizeof(struct in6_addr) },\n\t[RTA_PREFSRC]\t\t= { .len = sizeof(struct in6_addr) },\n\t[RTA_OIF]               = { .type = NLA_U32 },\n\t[RTA_IIF]\t\t= { .type = NLA_U32 },\n\t[RTA_PRIORITY]          = { .type = NLA_U32 },\n\t[RTA_METRICS]           = { .type = NLA_NESTED },\n\t[RTA_MULTIPATH]\t\t= { .len = sizeof(struct rtnexthop) },\n\t[RTA_PREF]              = { .type = NLA_U8 },\n\t[RTA_ENCAP_TYPE]\t= { .type = NLA_U16 },\n\t[RTA_ENCAP]\t\t= { .type = NLA_NESTED },\n\t[RTA_EXPIRES]\t\t= { .type = NLA_U32 },\n\t[RTA_UID]\t\t= { .type = NLA_U32 },\n\t[RTA_MARK]\t\t= { .type = NLA_U32 },\n\t[RTA_TABLE]\t\t= { .type = NLA_U32 },\n\t[RTA_IP_PROTO]\t\t= { .type = NLA_U8 },\n\t[RTA_SPORT]\t\t= { .type = NLA_U16 },\n\t[RTA_DPORT]\t\t= { .type = NLA_U16 },\n\t[RTA_NH_ID]\t\t= { .type = NLA_U32 },\n};\n\nstatic int rtm_to_fib6_config(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t      struct fib6_config *cfg,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tunsigned int pref;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t     rtm_ipv6_policy, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\trtm = nlmsg_data(nlh);\n\n\tif (rtm->rtm_tos) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid dsfield (tos): option not available for IPv6\");\n\t\tgoto errout;\n\t}\n\n\t*cfg = (struct fib6_config){\n\t\t.fc_table = rtm->rtm_table,\n\t\t.fc_dst_len = rtm->rtm_dst_len,\n\t\t.fc_src_len = rtm->rtm_src_len,\n\t\t.fc_flags = RTF_UP,\n\t\t.fc_protocol = rtm->rtm_protocol,\n\t\t.fc_type = rtm->rtm_type,\n\n\t\t.fc_nlinfo.portid = NETLINK_CB(skb).portid,\n\t\t.fc_nlinfo.nlh = nlh,\n\t\t.fc_nlinfo.nl_net = sock_net(skb->sk),\n\t};\n\n\tif (rtm->rtm_type == RTN_UNREACHABLE ||\n\t    rtm->rtm_type == RTN_BLACKHOLE ||\n\t    rtm->rtm_type == RTN_PROHIBIT ||\n\t    rtm->rtm_type == RTN_THROW)\n\t\tcfg->fc_flags |= RTF_REJECT;\n\n\tif (rtm->rtm_type == RTN_LOCAL)\n\t\tcfg->fc_flags |= RTF_LOCAL;\n\n\tif (rtm->rtm_flags & RTM_F_CLONED)\n\t\tcfg->fc_flags |= RTF_CACHE;\n\n\tcfg->fc_flags |= (rtm->rtm_flags & RTNH_F_ONLINK);\n\n\tif (tb[RTA_NH_ID]) {\n\t\tif (tb[RTA_GATEWAY]   || tb[RTA_OIF] ||\n\t\t    tb[RTA_MULTIPATH] || tb[RTA_ENCAP]) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Nexthop specification and nexthop id are mutually exclusive\");\n\t\t\tgoto errout;\n\t\t}\n\t\tcfg->fc_nh_id = nla_get_u32(tb[RTA_NH_ID]);\n\t}\n\n\tif (tb[RTA_GATEWAY]) {\n\t\tcfg->fc_gateway = nla_get_in6_addr(tb[RTA_GATEWAY]);\n\t\tcfg->fc_flags |= RTF_GATEWAY;\n\t}\n\tif (tb[RTA_VIA]) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv6 does not support RTA_VIA attribute\");\n\t\tgoto errout;\n\t}\n\n\tif (tb[RTA_DST]) {\n\t\tint plen = (rtm->rtm_dst_len + 7) >> 3;\n\n\t\tif (nla_len(tb[RTA_DST]) < plen)\n\t\t\tgoto errout;\n\n\t\tnla_memcpy(&cfg->fc_dst, tb[RTA_DST], plen);\n\t}\n\n\tif (tb[RTA_SRC]) {\n\t\tint plen = (rtm->rtm_src_len + 7) >> 3;\n\n\t\tif (nla_len(tb[RTA_SRC]) < plen)\n\t\t\tgoto errout;\n\n\t\tnla_memcpy(&cfg->fc_src, tb[RTA_SRC], plen);\n\t}\n\n\tif (tb[RTA_PREFSRC])\n\t\tcfg->fc_prefsrc = nla_get_in6_addr(tb[RTA_PREFSRC]);\n\n\tif (tb[RTA_OIF])\n\t\tcfg->fc_ifindex = nla_get_u32(tb[RTA_OIF]);\n\n\tif (tb[RTA_PRIORITY])\n\t\tcfg->fc_metric = nla_get_u32(tb[RTA_PRIORITY]);\n\n\tif (tb[RTA_METRICS]) {\n\t\tcfg->fc_mx = nla_data(tb[RTA_METRICS]);\n\t\tcfg->fc_mx_len = nla_len(tb[RTA_METRICS]);\n\t}\n\n\tif (tb[RTA_TABLE])\n\t\tcfg->fc_table = nla_get_u32(tb[RTA_TABLE]);\n\n\tif (tb[RTA_MULTIPATH]) {\n\t\tcfg->fc_mp = nla_data(tb[RTA_MULTIPATH]);\n\t\tcfg->fc_mp_len = nla_len(tb[RTA_MULTIPATH]);\n\n\t\terr = lwtunnel_valid_encap_type_attr(cfg->fc_mp,\n\t\t\t\t\t\t     cfg->fc_mp_len, extack);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif (tb[RTA_PREF]) {\n\t\tpref = nla_get_u8(tb[RTA_PREF]);\n\t\tif (pref != ICMPV6_ROUTER_PREF_LOW &&\n\t\t    pref != ICMPV6_ROUTER_PREF_HIGH)\n\t\t\tpref = ICMPV6_ROUTER_PREF_MEDIUM;\n\t\tcfg->fc_flags |= RTF_PREF(pref);\n\t}\n\n\tif (tb[RTA_ENCAP])\n\t\tcfg->fc_encap = tb[RTA_ENCAP];\n\n\tif (tb[RTA_ENCAP_TYPE]) {\n\t\tcfg->fc_encap_type = nla_get_u16(tb[RTA_ENCAP_TYPE]);\n\n\t\terr = lwtunnel_valid_encap_type(cfg->fc_encap_type, extack);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif (tb[RTA_EXPIRES]) {\n\t\tunsigned long timeout = addrconf_timeout_fixup(nla_get_u32(tb[RTA_EXPIRES]), HZ);\n\n\t\tif (addrconf_finite_timeout(timeout)) {\n\t\t\tcfg->fc_expires = jiffies_to_clock_t(timeout * HZ);\n\t\t\tcfg->fc_flags |= RTF_EXPIRES;\n\t\t}\n\t}\n\n\terr = 0;\nerrout:\n\treturn err;\n}\n\nstruct rt6_nh {\n\tstruct fib6_info *fib6_info;\n\tstruct fib6_config r_cfg;\n\tstruct list_head next;\n};\n\nstatic int ip6_route_info_append(struct net *net,\n\t\t\t\t struct list_head *rt6_nh_list,\n\t\t\t\t struct fib6_info *rt,\n\t\t\t\t struct fib6_config *r_cfg)\n{\n\tstruct rt6_nh *nh;\n\tint err = -EEXIST;\n\n\tlist_for_each_entry(nh, rt6_nh_list, next) {\n\t\t \n\t\tif (rt6_duplicate_nexthop(nh->fib6_info, rt))\n\t\t\treturn err;\n\t}\n\n\tnh = kzalloc(sizeof(*nh), GFP_KERNEL);\n\tif (!nh)\n\t\treturn -ENOMEM;\n\tnh->fib6_info = rt;\n\tmemcpy(&nh->r_cfg, r_cfg, sizeof(*r_cfg));\n\tlist_add_tail(&nh->next, rt6_nh_list);\n\n\treturn 0;\n}\n\nstatic void ip6_route_mpath_notify(struct fib6_info *rt,\n\t\t\t\t   struct fib6_info *rt_last,\n\t\t\t\t   struct nl_info *info,\n\t\t\t\t   __u16 nlflags)\n{\n\t \n\tif ((nlflags & NLM_F_APPEND) && rt_last && rt_last->fib6_nsiblings) {\n\t\trt = list_first_entry(&rt_last->fib6_siblings,\n\t\t\t\t      struct fib6_info,\n\t\t\t\t      fib6_siblings);\n\t}\n\n\tif (rt)\n\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);\n}\n\nstatic bool ip6_route_mpath_should_notify(const struct fib6_info *rt)\n{\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\tbool should_notify = false;\n\tstruct fib6_info *leaf;\n\tstruct fib6_node *fn;\n\n\trcu_read_lock();\n\tfn = rcu_dereference(rt->fib6_node);\n\tif (!fn)\n\t\tgoto out;\n\n\tleaf = rcu_dereference(fn->leaf);\n\tif (!leaf)\n\t\tgoto out;\n\n\tif (rt == leaf ||\n\t    (rt_can_ecmp && rt->fib6_metric == leaf->fib6_metric &&\n\t     rt6_qualify_for_ecmp(leaf)))\n\t\tshould_notify = true;\nout:\n\trcu_read_unlock();\n\n\treturn should_notify;\n}\n\nstatic int fib6_gw_from_attr(struct in6_addr *gw, struct nlattr *nla,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tif (nla_len(nla) < sizeof(*gw)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid IPv6 address in RTA_GATEWAY\");\n\t\treturn -EINVAL;\n\t}\n\n\t*gw = nla_get_in6_addr(nla);\n\n\treturn 0;\n}\n\nstatic int ip6_route_multipath_add(struct fib6_config *cfg,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *rt_notif = NULL, *rt_last = NULL;\n\tstruct nl_info *info = &cfg->fc_nlinfo;\n\tstruct fib6_config r_cfg;\n\tstruct rtnexthop *rtnh;\n\tstruct fib6_info *rt;\n\tstruct rt6_nh *err_nh;\n\tstruct rt6_nh *nh, *nh_safe;\n\t__u16 nlflags;\n\tint remaining;\n\tint attrlen;\n\tint err = 1;\n\tint nhn = 0;\n\tint replace = (cfg->fc_nlinfo.nlh &&\n\t\t       (cfg->fc_nlinfo.nlh->nlmsg_flags & NLM_F_REPLACE));\n\tLIST_HEAD(rt6_nh_list);\n\n\tnlflags = replace ? NLM_F_REPLACE : NLM_F_CREATE;\n\tif (info->nlh && info->nlh->nlmsg_flags & NLM_F_APPEND)\n\t\tnlflags |= NLM_F_APPEND;\n\n\tremaining = cfg->fc_mp_len;\n\trtnh = (struct rtnexthop *)cfg->fc_mp;\n\n\t \n\twhile (rtnh_ok(rtnh, remaining)) {\n\t\tmemcpy(&r_cfg, cfg, sizeof(*cfg));\n\t\tif (rtnh->rtnh_ifindex)\n\t\t\tr_cfg.fc_ifindex = rtnh->rtnh_ifindex;\n\n\t\tattrlen = rtnh_attrlen(rtnh);\n\t\tif (attrlen > 0) {\n\t\t\tstruct nlattr *nla, *attrs = rtnh_attrs(rtnh);\n\n\t\t\tnla = nla_find(attrs, attrlen, RTA_GATEWAY);\n\t\t\tif (nla) {\n\t\t\t\terr = fib6_gw_from_attr(&r_cfg.fc_gateway, nla,\n\t\t\t\t\t\t\textack);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tr_cfg.fc_flags |= RTF_GATEWAY;\n\t\t\t}\n\t\t\tr_cfg.fc_encap = nla_find(attrs, attrlen, RTA_ENCAP);\n\n\t\t\t \n\t\t\tnla = nla_find(attrs, attrlen, RTA_ENCAP_TYPE);\n\t\t\tif (nla)\n\t\t\t\tr_cfg.fc_encap_type = nla_get_u16(nla);\n\t\t}\n\n\t\tr_cfg.fc_flags |= (rtnh->rtnh_flags & RTNH_F_ONLINK);\n\t\trt = ip6_route_info_create(&r_cfg, GFP_KERNEL, extack);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\trt = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (!rt6_qualify_for_ecmp(rt)) {\n\t\t\terr = -EINVAL;\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Device only routes can not be added for IPv6 using the multipath API.\");\n\t\t\tfib6_info_release(rt);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\trt->fib6_nh->fib_nh_weight = rtnh->rtnh_hops + 1;\n\n\t\terr = ip6_route_info_append(info->nl_net, &rt6_nh_list,\n\t\t\t\t\t    rt, &r_cfg);\n\t\tif (err) {\n\t\t\tfib6_info_release(rt);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t}\n\n\tif (list_empty(&rt6_nh_list)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid nexthop configuration - no valid nexthops\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tinfo->skip_notify = 1;\n\n\t \n\tinfo->skip_notify_kernel = 1;\n\n\terr_nh = NULL;\n\tlist_for_each_entry(nh, &rt6_nh_list, next) {\n\t\terr = __ip6_ins_rt(nh->fib6_info, info, extack);\n\t\tfib6_info_release(nh->fib6_info);\n\n\t\tif (!err) {\n\t\t\t \n\t\t\trt_last = nh->fib6_info;\n\n\t\t\t \n\t\t\tif (!rt_notif)\n\t\t\t\trt_notif = nh->fib6_info;\n\t\t}\n\n\t\t \n\t\tnh->fib6_info = NULL;\n\t\tif (err) {\n\t\t\tif (replace && nhn)\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"multipath route replace failed (check consistency of installed routes)\");\n\t\t\terr_nh = nh;\n\t\t\tgoto add_errout;\n\t\t}\n\n\t\t \n\t\tif (cfg->fc_nlinfo.nlh) {\n\t\t\tcfg->fc_nlinfo.nlh->nlmsg_flags &= ~(NLM_F_EXCL |\n\t\t\t\t\t\t\t     NLM_F_REPLACE);\n\t\t\tcfg->fc_nlinfo.nlh->nlmsg_flags |= NLM_F_CREATE;\n\t\t}\n\t\tnhn++;\n\t}\n\n\t \n\tif (ip6_route_mpath_should_notify(rt_notif)) {\n\t\tenum fib_event_type fib_event;\n\n\t\tif (rt_notif->fib6_nsiblings != nhn - 1)\n\t\t\tfib_event = FIB_EVENT_ENTRY_APPEND;\n\t\telse\n\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\n\t\terr = call_fib6_multipath_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\t  fib_event, rt_notif,\n\t\t\t\t\t\t\t  nhn - 1, extack);\n\t\tif (err) {\n\t\t\t \n\t\t\terr_nh = NULL;\n\t\t\tgoto add_errout;\n\t\t}\n\t}\n\n\t \n\tip6_route_mpath_notify(rt_notif, rt_last, info, nlflags);\n\tgoto cleanup;\n\nadd_errout:\n\t \n\tif (rt_notif)\n\t\tip6_route_mpath_notify(rt_notif, rt_last, info, nlflags);\n\n\t \n\tlist_for_each_entry(nh, &rt6_nh_list, next) {\n\t\tif (err_nh == nh)\n\t\t\tbreak;\n\t\tip6_route_del(&nh->r_cfg, extack);\n\t}\n\ncleanup:\n\tlist_for_each_entry_safe(nh, nh_safe, &rt6_nh_list, next) {\n\t\tif (nh->fib6_info)\n\t\t\tfib6_info_release(nh->fib6_info);\n\t\tlist_del(&nh->next);\n\t\tkfree(nh);\n\t}\n\n\treturn err;\n}\n\nstatic int ip6_route_multipath_del(struct fib6_config *cfg,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct fib6_config r_cfg;\n\tstruct rtnexthop *rtnh;\n\tint last_err = 0;\n\tint remaining;\n\tint attrlen;\n\tint err;\n\n\tremaining = cfg->fc_mp_len;\n\trtnh = (struct rtnexthop *)cfg->fc_mp;\n\n\t \n\twhile (rtnh_ok(rtnh, remaining)) {\n\t\tmemcpy(&r_cfg, cfg, sizeof(*cfg));\n\t\tif (rtnh->rtnh_ifindex)\n\t\t\tr_cfg.fc_ifindex = rtnh->rtnh_ifindex;\n\n\t\tattrlen = rtnh_attrlen(rtnh);\n\t\tif (attrlen > 0) {\n\t\t\tstruct nlattr *nla, *attrs = rtnh_attrs(rtnh);\n\n\t\t\tnla = nla_find(attrs, attrlen, RTA_GATEWAY);\n\t\t\tif (nla) {\n\t\t\t\terr = fib6_gw_from_attr(&r_cfg.fc_gateway, nla,\n\t\t\t\t\t\t\textack);\n\t\t\t\tif (err) {\n\t\t\t\t\tlast_err = err;\n\t\t\t\t\tgoto next_rtnh;\n\t\t\t\t}\n\n\t\t\t\tr_cfg.fc_flags |= RTF_GATEWAY;\n\t\t\t}\n\t\t}\n\t\terr = ip6_route_del(&r_cfg, extack);\n\t\tif (err)\n\t\t\tlast_err = err;\n\nnext_rtnh:\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t}\n\n\treturn last_err;\n}\n\nstatic int inet6_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct fib6_config cfg;\n\tint err;\n\n\terr = rtm_to_fib6_config(skb, nlh, &cfg, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (cfg.fc_nh_id &&\n\t    !nexthop_find_by_id(sock_net(skb->sk), cfg.fc_nh_id)) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop id does not exist\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg.fc_mp)\n\t\treturn ip6_route_multipath_del(&cfg, extack);\n\telse {\n\t\tcfg.fc_delete_all_nh = 1;\n\t\treturn ip6_route_del(&cfg, extack);\n\t}\n}\n\nstatic int inet6_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct fib6_config cfg;\n\tint err;\n\n\terr = rtm_to_fib6_config(skb, nlh, &cfg, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (cfg.fc_metric == 0)\n\t\tcfg.fc_metric = IP6_RT_PRIO_USER;\n\n\tif (cfg.fc_mp)\n\t\treturn ip6_route_multipath_add(&cfg, extack);\n\telse\n\t\treturn ip6_route_add(&cfg, GFP_KERNEL, extack);\n}\n\n \nstatic int rt6_nh_nlmsg_size(struct fib6_nh *nh, void *arg)\n{\n\tint *nexthop_len = arg;\n\n\t*nexthop_len += nla_total_size(0)\t  \n\t\t     + NLA_ALIGN(sizeof(struct rtnexthop))\n\t\t     + nla_total_size(16);  \n\n\tif (nh->fib_nh_lws) {\n\t\t \n\t\t*nexthop_len += lwtunnel_get_encap_size(nh->fib_nh_lws);\n\t\t \n\t\t*nexthop_len += nla_total_size(2);\n\t}\n\n\treturn 0;\n}\n\nstatic size_t rt6_nlmsg_size(struct fib6_info *f6i)\n{\n\tint nexthop_len;\n\n\tif (f6i->nh) {\n\t\tnexthop_len = nla_total_size(4);  \n\t\tnexthop_for_each_fib6_nh(f6i->nh, rt6_nh_nlmsg_size,\n\t\t\t\t\t &nexthop_len);\n\t} else {\n\t\tstruct fib6_info *sibling, *next_sibling;\n\t\tstruct fib6_nh *nh = f6i->fib6_nh;\n\n\t\tnexthop_len = 0;\n\t\tif (f6i->fib6_nsiblings) {\n\t\t\trt6_nh_nlmsg_size(nh, &nexthop_len);\n\n\t\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t\t &f6i->fib6_siblings, fib6_siblings) {\n\t\t\t\trt6_nh_nlmsg_size(sibling->fib6_nh, &nexthop_len);\n\t\t\t}\n\t\t}\n\t\tnexthop_len += lwtunnel_get_encap_size(nh->fib_nh_lws);\n\t}\n\n\treturn NLMSG_ALIGN(sizeof(struct rtmsg))\n\t       + nla_total_size(16)  \n\t       + nla_total_size(16)  \n\t       + nla_total_size(16)  \n\t       + nla_total_size(16)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + nla_total_size(4)  \n\t       + RTAX_MAX * nla_total_size(4)  \n\t       + nla_total_size(sizeof(struct rta_cacheinfo))\n\t       + nla_total_size(TCP_CA_NAME_MAX)  \n\t       + nla_total_size(1)  \n\t       + nexthop_len;\n}\n\nstatic int rt6_fill_node_nexthop(struct sk_buff *skb, struct nexthop *nh,\n\t\t\t\t unsigned char *flags)\n{\n\tif (nexthop_is_multipath(nh)) {\n\t\tstruct nlattr *mp;\n\n\t\tmp = nla_nest_start_noflag(skb, RTA_MULTIPATH);\n\t\tif (!mp)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nexthop_mpath_fill_node(skb, nh, AF_INET6))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(skb, mp);\n\t} else {\n\t\tstruct fib6_nh *fib6_nh;\n\n\t\tfib6_nh = nexthop_fib6_nh(nh);\n\t\tif (fib_nexthop_info(skb, &fib6_nh->nh_common, AF_INET6,\n\t\t\t\t     flags, false) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int rt6_fill_node(struct net *net, struct sk_buff *skb,\n\t\t\t struct fib6_info *rt, struct dst_entry *dst,\n\t\t\t struct in6_addr *dest, struct in6_addr *src,\n\t\t\t int iif, int type, u32 portid, u32 seq,\n\t\t\t unsigned int flags)\n{\n\tstruct rt6_info *rt6 = (struct rt6_info *)dst;\n\tstruct rt6key *rt6_dst, *rt6_src;\n\tu32 *pmetrics, table, rt6_flags;\n\tunsigned char nh_flags = 0;\n\tstruct nlmsghdr *nlh;\n\tstruct rtmsg *rtm;\n\tlong expires = 0;\n\n\tnlh = nlmsg_put(skb, portid, seq, type, sizeof(*rtm), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tif (rt6) {\n\t\trt6_dst = &rt6->rt6i_dst;\n\t\trt6_src = &rt6->rt6i_src;\n\t\trt6_flags = rt6->rt6i_flags;\n\t} else {\n\t\trt6_dst = &rt->fib6_dst;\n\t\trt6_src = &rt->fib6_src;\n\t\trt6_flags = rt->fib6_flags;\n\t}\n\n\trtm = nlmsg_data(nlh);\n\trtm->rtm_family = AF_INET6;\n\trtm->rtm_dst_len = rt6_dst->plen;\n\trtm->rtm_src_len = rt6_src->plen;\n\trtm->rtm_tos = 0;\n\tif (rt->fib6_table)\n\t\ttable = rt->fib6_table->tb6_id;\n\telse\n\t\ttable = RT6_TABLE_UNSPEC;\n\trtm->rtm_table = table < 256 ? table : RT_TABLE_COMPAT;\n\tif (nla_put_u32(skb, RTA_TABLE, table))\n\t\tgoto nla_put_failure;\n\n\trtm->rtm_type = rt->fib6_type;\n\trtm->rtm_flags = 0;\n\trtm->rtm_scope = RT_SCOPE_UNIVERSE;\n\trtm->rtm_protocol = rt->fib6_protocol;\n\n\tif (rt6_flags & RTF_CACHE)\n\t\trtm->rtm_flags |= RTM_F_CLONED;\n\n\tif (dest) {\n\t\tif (nla_put_in6_addr(skb, RTA_DST, dest))\n\t\t\tgoto nla_put_failure;\n\t\trtm->rtm_dst_len = 128;\n\t} else if (rtm->rtm_dst_len)\n\t\tif (nla_put_in6_addr(skb, RTA_DST, &rt6_dst->addr))\n\t\t\tgoto nla_put_failure;\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (src) {\n\t\tif (nla_put_in6_addr(skb, RTA_SRC, src))\n\t\t\tgoto nla_put_failure;\n\t\trtm->rtm_src_len = 128;\n\t} else if (rtm->rtm_src_len &&\n\t\t   nla_put_in6_addr(skb, RTA_SRC, &rt6_src->addr))\n\t\tgoto nla_put_failure;\n#endif\n\tif (iif) {\n#ifdef CONFIG_IPV6_MROUTE\n\t\tif (ipv6_addr_is_multicast(&rt6_dst->addr)) {\n\t\t\tint err = ip6mr_get_route(net, skb, rtm, portid);\n\n\t\t\tif (err == 0)\n\t\t\t\treturn 0;\n\t\t\tif (err < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t} else\n#endif\n\t\t\tif (nla_put_u32(skb, RTA_IIF, iif))\n\t\t\t\tgoto nla_put_failure;\n\t} else if (dest) {\n\t\tstruct in6_addr saddr_buf;\n\t\tif (ip6_route_get_saddr(net, rt, dest, 0, &saddr_buf) == 0 &&\n\t\t    nla_put_in6_addr(skb, RTA_PREFSRC, &saddr_buf))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rt->fib6_prefsrc.plen) {\n\t\tstruct in6_addr saddr_buf;\n\t\tsaddr_buf = rt->fib6_prefsrc.addr;\n\t\tif (nla_put_in6_addr(skb, RTA_PREFSRC, &saddr_buf))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tpmetrics = dst ? dst_metrics_ptr(dst) : rt->fib6_metrics->metrics;\n\tif (rtnetlink_put_metrics(skb, pmetrics) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, RTA_PRIORITY, rt->fib6_metric))\n\t\tgoto nla_put_failure;\n\n\t \n\tif (rt6) {\n\t\tif (rt6_flags & RTF_GATEWAY &&\n\t\t    nla_put_in6_addr(skb, RTA_GATEWAY, &rt6->rt6i_gateway))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (dst->dev && nla_put_u32(skb, RTA_OIF, dst->dev->ifindex))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (dst->lwtstate &&\n\t\t    lwtunnel_fill_encap(skb, dst->lwtstate, RTA_ENCAP, RTA_ENCAP_TYPE) < 0)\n\t\t\tgoto nla_put_failure;\n\t} else if (rt->fib6_nsiblings) {\n\t\tstruct fib6_info *sibling, *next_sibling;\n\t\tstruct nlattr *mp;\n\n\t\tmp = nla_nest_start_noflag(skb, RTA_MULTIPATH);\n\t\tif (!mp)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (fib_add_nexthop(skb, &rt->fib6_nh->nh_common,\n\t\t\t\t    rt->fib6_nh->fib_nh_weight, AF_INET6,\n\t\t\t\t    0) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings) {\n\t\t\tif (fib_add_nexthop(skb, &sibling->fib6_nh->nh_common,\n\t\t\t\t\t    sibling->fib6_nh->fib_nh_weight,\n\t\t\t\t\t    AF_INET6, 0) < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tnla_nest_end(skb, mp);\n\t} else if (rt->nh) {\n\t\tif (nla_put_u32(skb, RTA_NH_ID, rt->nh->id))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nexthop_is_blackhole(rt->nh))\n\t\t\trtm->rtm_type = RTN_BLACKHOLE;\n\n\t\tif (READ_ONCE(net->ipv4.sysctl_nexthop_compat_mode) &&\n\t\t    rt6_fill_node_nexthop(skb, rt->nh, &nh_flags) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\trtm->rtm_flags |= nh_flags;\n\t} else {\n\t\tif (fib_nexthop_info(skb, &rt->fib6_nh->nh_common, AF_INET6,\n\t\t\t\t     &nh_flags, false) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\trtm->rtm_flags |= nh_flags;\n\t}\n\n\tif (rt6_flags & RTF_EXPIRES) {\n\t\texpires = dst ? dst->expires : rt->expires;\n\t\texpires -= jiffies;\n\t}\n\n\tif (!dst) {\n\t\tif (READ_ONCE(rt->offload))\n\t\t\trtm->rtm_flags |= RTM_F_OFFLOAD;\n\t\tif (READ_ONCE(rt->trap))\n\t\t\trtm->rtm_flags |= RTM_F_TRAP;\n\t\tif (READ_ONCE(rt->offload_failed))\n\t\t\trtm->rtm_flags |= RTM_F_OFFLOAD_FAILED;\n\t}\n\n\tif (rtnl_put_cacheinfo(skb, dst, 0, expires, dst ? dst->error : 0) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, RTA_PREF, IPV6_EXTRACT_PREF(rt6_flags)))\n\t\tgoto nla_put_failure;\n\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int fib6_info_nh_uses_dev(struct fib6_nh *nh, void *arg)\n{\n\tconst struct net_device *dev = arg;\n\n\tif (nh->fib_nh_dev == dev)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic bool fib6_info_uses_dev(const struct fib6_info *f6i,\n\t\t\t       const struct net_device *dev)\n{\n\tif (f6i->nh) {\n\t\tstruct net_device *_dev = (struct net_device *)dev;\n\n\t\treturn !!nexthop_for_each_fib6_nh(f6i->nh,\n\t\t\t\t\t\t  fib6_info_nh_uses_dev,\n\t\t\t\t\t\t  _dev);\n\t}\n\n\tif (f6i->fib6_nh->fib_nh_dev == dev)\n\t\treturn true;\n\n\tif (f6i->fib6_nsiblings) {\n\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t &f6i->fib6_siblings, fib6_siblings) {\n\t\t\tif (sibling->fib6_nh->fib_nh_dev == dev)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstruct fib6_nh_exception_dump_walker {\n\tstruct rt6_rtnl_dump_arg *dump;\n\tstruct fib6_info *rt;\n\tunsigned int flags;\n\tunsigned int skip;\n\tunsigned int count;\n};\n\nstatic int rt6_nh_dump_exceptions(struct fib6_nh *nh, void *arg)\n{\n\tstruct fib6_nh_exception_dump_walker *w = arg;\n\tstruct rt6_rtnl_dump_arg *dump = w->dump;\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tint i, err;\n\n\tbucket = fib6_nh_get_excptn_bucket(nh, NULL);\n\tif (!bucket)\n\t\treturn 0;\n\n\tfor (i = 0; i < FIB6_EXCEPTION_BUCKET_SIZE; i++) {\n\t\thlist_for_each_entry(rt6_ex, &bucket->chain, hlist) {\n\t\t\tif (w->skip) {\n\t\t\t\tw->skip--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (rt6_check_expired(rt6_ex->rt6i)) {\n\t\t\t\tw->count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = rt6_fill_node(dump->net, dump->skb, w->rt,\n\t\t\t\t\t    &rt6_ex->rt6i->dst, NULL, NULL, 0,\n\t\t\t\t\t    RTM_NEWROUTE,\n\t\t\t\t\t    NETLINK_CB(dump->cb->skb).portid,\n\t\t\t\t\t    dump->cb->nlh->nlmsg_seq, w->flags);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tw->count++;\n\t\t}\n\t\tbucket++;\n\t}\n\n\treturn 0;\n}\n\n \nint rt6_dump_route(struct fib6_info *rt, void *p_arg, unsigned int skip)\n{\n\tstruct rt6_rtnl_dump_arg *arg = (struct rt6_rtnl_dump_arg *) p_arg;\n\tstruct fib_dump_filter *filter = &arg->filter;\n\tunsigned int flags = NLM_F_MULTI;\n\tstruct net *net = arg->net;\n\tint count = 0;\n\n\tif (rt == net->ipv6.fib6_null_entry)\n\t\treturn -1;\n\n\tif ((filter->flags & RTM_F_PREFIX) &&\n\t    !(rt->fib6_flags & RTF_PREFIX_RT)) {\n\t\t \n\t\treturn -1;\n\t}\n\tif (filter->filter_set &&\n\t    ((filter->rt_type  && rt->fib6_type != filter->rt_type) ||\n\t     (filter->dev      && !fib6_info_uses_dev(rt, filter->dev)) ||\n\t     (filter->protocol && rt->fib6_protocol != filter->protocol))) {\n\t\treturn -1;\n\t}\n\n\tif (filter->filter_set ||\n\t    !filter->dump_routes || !filter->dump_exceptions) {\n\t\tflags |= NLM_F_DUMP_FILTERED;\n\t}\n\n\tif (filter->dump_routes) {\n\t\tif (skip) {\n\t\t\tskip--;\n\t\t} else {\n\t\t\tif (rt6_fill_node(net, arg->skb, rt, NULL, NULL, NULL,\n\t\t\t\t\t  0, RTM_NEWROUTE,\n\t\t\t\t\t  NETLINK_CB(arg->cb->skb).portid,\n\t\t\t\t\t  arg->cb->nlh->nlmsg_seq, flags)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (filter->dump_exceptions) {\n\t\tstruct fib6_nh_exception_dump_walker w = { .dump = arg,\n\t\t\t\t\t\t\t   .rt = rt,\n\t\t\t\t\t\t\t   .flags = flags,\n\t\t\t\t\t\t\t   .skip = skip,\n\t\t\t\t\t\t\t   .count = 0 };\n\t\tint err;\n\n\t\trcu_read_lock();\n\t\tif (rt->nh) {\n\t\t\terr = nexthop_for_each_fib6_nh(rt->nh,\n\t\t\t\t\t\t       rt6_nh_dump_exceptions,\n\t\t\t\t\t\t       &w);\n\t\t} else {\n\t\t\terr = rt6_nh_dump_exceptions(rt->fib6_nh, &w);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (err)\n\t\t\treturn count + w.count;\n\t}\n\n\treturn -1;\n}\n\nstatic int inet6_rtm_valid_getroute_req(struct sk_buff *skb,\n\t\t\t\t\tconst struct nlmsghdr *nlh,\n\t\t\t\t\tstruct nlattr **tb,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct rtmsg *rtm;\n\tint i, err;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*rtm))) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid header for get route request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t\t      rtm_ipv6_policy, extack);\n\n\trtm = nlmsg_data(nlh);\n\tif ((rtm->rtm_src_len && rtm->rtm_src_len != 128) ||\n\t    (rtm->rtm_dst_len && rtm->rtm_dst_len != 128) ||\n\t    rtm->rtm_table || rtm->rtm_protocol || rtm->rtm_scope ||\n\t    rtm->rtm_type) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid values in header for get route request\");\n\t\treturn -EINVAL;\n\t}\n\tif (rtm->rtm_flags & ~RTM_F_FIB_MATCH) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid flags for get route request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t\t    rtm_ipv6_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif ((tb[RTA_SRC] && !rtm->rtm_src_len) ||\n\t    (tb[RTA_DST] && !rtm->rtm_dst_len)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"rtm_src_len and rtm_dst_len must be 128 for IPv6\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i <= RTA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase RTA_SRC:\n\t\tcase RTA_DST:\n\t\tcase RTA_IIF:\n\t\tcase RTA_OIF:\n\t\tcase RTA_MARK:\n\t\tcase RTA_UID:\n\t\tcase RTA_SPORT:\n\t\tcase RTA_DPORT:\n\t\tcase RTA_IP_PROTO:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported attribute in get route request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int inet6_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[RTA_MAX+1];\n\tint err, iif = 0, oif = 0;\n\tstruct fib6_info *from;\n\tstruct dst_entry *dst;\n\tstruct rt6_info *rt;\n\tstruct sk_buff *skb;\n\tstruct rtmsg *rtm;\n\tstruct flowi6 fl6 = {};\n\tbool fibmatch;\n\n\terr = inet6_rtm_valid_getroute_req(in_skb, nlh, tb, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\trtm = nlmsg_data(nlh);\n\tfl6.flowlabel = ip6_make_flowinfo(rtm->rtm_tos, 0);\n\tfibmatch = !!(rtm->rtm_flags & RTM_F_FIB_MATCH);\n\n\tif (tb[RTA_SRC]) {\n\t\tif (nla_len(tb[RTA_SRC]) < sizeof(struct in6_addr))\n\t\t\tgoto errout;\n\n\t\tfl6.saddr = *(struct in6_addr *)nla_data(tb[RTA_SRC]);\n\t}\n\n\tif (tb[RTA_DST]) {\n\t\tif (nla_len(tb[RTA_DST]) < sizeof(struct in6_addr))\n\t\t\tgoto errout;\n\n\t\tfl6.daddr = *(struct in6_addr *)nla_data(tb[RTA_DST]);\n\t}\n\n\tif (tb[RTA_IIF])\n\t\tiif = nla_get_u32(tb[RTA_IIF]);\n\n\tif (tb[RTA_OIF])\n\t\toif = nla_get_u32(tb[RTA_OIF]);\n\n\tif (tb[RTA_MARK])\n\t\tfl6.flowi6_mark = nla_get_u32(tb[RTA_MARK]);\n\n\tif (tb[RTA_UID])\n\t\tfl6.flowi6_uid = make_kuid(current_user_ns(),\n\t\t\t\t\t   nla_get_u32(tb[RTA_UID]));\n\telse\n\t\tfl6.flowi6_uid = iif ? INVALID_UID : current_uid();\n\n\tif (tb[RTA_SPORT])\n\t\tfl6.fl6_sport = nla_get_be16(tb[RTA_SPORT]);\n\n\tif (tb[RTA_DPORT])\n\t\tfl6.fl6_dport = nla_get_be16(tb[RTA_DPORT]);\n\n\tif (tb[RTA_IP_PROTO]) {\n\t\terr = rtm_getroute_parse_ip_proto(tb[RTA_IP_PROTO],\n\t\t\t\t\t\t  &fl6.flowi6_proto, AF_INET6,\n\t\t\t\t\t\t  extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\t}\n\n\tif (iif) {\n\t\tstruct net_device *dev;\n\t\tint flags = 0;\n\n\t\trcu_read_lock();\n\n\t\tdev = dev_get_by_index_rcu(net, iif);\n\t\tif (!dev) {\n\t\t\trcu_read_unlock();\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tfl6.flowi6_iif = iif;\n\n\t\tif (!ipv6_addr_any(&fl6.saddr))\n\t\t\tflags |= RT6_LOOKUP_F_HAS_SADDR;\n\n\t\tdst = ip6_route_input_lookup(net, dev, &fl6, NULL, flags);\n\n\t\trcu_read_unlock();\n\t} else {\n\t\tfl6.flowi6_oif = oif;\n\n\t\tdst = ip6_route_output(net, NULL, &fl6);\n\t}\n\n\n\trt = container_of(dst, struct rt6_info, dst);\n\tif (rt->dst.error) {\n\t\terr = rt->dst.error;\n\t\tip6_rt_put(rt);\n\t\tgoto errout;\n\t}\n\n\tif (rt == net->ipv6.ip6_null_entry) {\n\t\terr = rt->dst.error;\n\t\tip6_rt_put(rt);\n\t\tgoto errout;\n\t}\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\tip6_rt_put(rt);\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\tskb_dst_set(skb, &rt->dst);\n\n\trcu_read_lock();\n\tfrom = rcu_dereference(rt->from);\n\tif (from) {\n\t\tif (fibmatch)\n\t\t\terr = rt6_fill_node(net, skb, from, NULL, NULL, NULL,\n\t\t\t\t\t    iif, RTM_NEWROUTE,\n\t\t\t\t\t    NETLINK_CB(in_skb).portid,\n\t\t\t\t\t    nlh->nlmsg_seq, 0);\n\t\telse\n\t\t\terr = rt6_fill_node(net, skb, from, dst, &fl6.daddr,\n\t\t\t\t\t    &fl6.saddr, iif, RTM_NEWROUTE,\n\t\t\t\t\t    NETLINK_CB(in_skb).portid,\n\t\t\t\t\t    nlh->nlmsg_seq, 0);\n\t} else {\n\t\terr = -ENETUNREACH;\n\t}\n\trcu_read_unlock();\n\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n}\n\nvoid inet6_rt_notify(int event, struct fib6_info *rt, struct nl_info *info,\n\t\t     unsigned int nlm_flags)\n{\n\tstruct sk_buff *skb;\n\tstruct net *net = info->nl_net;\n\tu32 seq;\n\tint err;\n\n\terr = -ENOBUFS;\n\tseq = info->nlh ? info->nlh->nlmsg_seq : 0;\n\n\tskb = nlmsg_new(rt6_nlmsg_size(rt), gfp_any());\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = rt6_fill_node(net, skb, rt, NULL, NULL, NULL, 0,\n\t\t\t    event, info->portid, seq, nlm_flags);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, info->portid, RTNLGRP_IPV6_ROUTE,\n\t\t    info->nlh, gfp_any());\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV6_ROUTE, err);\n}\n\nvoid fib6_rt_update(struct net *net, struct fib6_info *rt,\n\t\t    struct nl_info *info)\n{\n\tu32 seq = info->nlh ? info->nlh->nlmsg_seq : 0;\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(rt6_nlmsg_size(rt), gfp_any());\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = rt6_fill_node(net, skb, rt, NULL, NULL, NULL, 0,\n\t\t\t    RTM_NEWROUTE, info->portid, seq, NLM_F_REPLACE);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, info->portid, RTNLGRP_IPV6_ROUTE,\n\t\t    info->nlh, gfp_any());\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV6_ROUTE, err);\n}\n\nvoid fib6_info_hw_flags_set(struct net *net, struct fib6_info *f6i,\n\t\t\t    bool offload, bool trap, bool offload_failed)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (READ_ONCE(f6i->offload) == offload &&\n\t    READ_ONCE(f6i->trap) == trap &&\n\t    READ_ONCE(f6i->offload_failed) == offload_failed)\n\t\treturn;\n\n\tWRITE_ONCE(f6i->offload, offload);\n\tWRITE_ONCE(f6i->trap, trap);\n\n\t \n\tif (net->ipv6.sysctl.fib_notify_on_flag_change == 2 &&\n\t    READ_ONCE(f6i->offload_failed) == offload_failed)\n\t\treturn;\n\n\tWRITE_ONCE(f6i->offload_failed, offload_failed);\n\n\tif (!rcu_access_pointer(f6i->fib6_node))\n\t\t \n\t\treturn;\n\n\tif (!net->ipv6.sysctl.fib_notify_on_flag_change)\n\t\treturn;\n\n\tskb = nlmsg_new(rt6_nlmsg_size(f6i), GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\terr = rt6_fill_node(net, skb, f6i, NULL, NULL, NULL, 0, RTM_NEWROUTE, 0,\n\t\t\t    0, 0);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV6_ROUTE, NULL, GFP_KERNEL);\n\treturn;\n\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_IPV6_ROUTE, err);\n}\nEXPORT_SYMBOL(fib6_info_hw_flags_set);\n\nstatic int ip6_route_dev_notify(struct notifier_block *this,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\n\tif (!(dev->flags & IFF_LOOPBACK))\n\t\treturn NOTIFY_OK;\n\n\tif (event == NETDEV_REGISTER) {\n\t\tnet->ipv6.fib6_null_entry->fib6_nh->fib_nh_dev = dev;\n\t\tnet->ipv6.ip6_null_entry->dst.dev = dev;\n\t\tnet->ipv6.ip6_null_entry->rt6i_idev = in6_dev_get(dev);\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\t\tnet->ipv6.ip6_prohibit_entry->dst.dev = dev;\n\t\tnet->ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(dev);\n\t\tnet->ipv6.ip6_blk_hole_entry->dst.dev = dev;\n\t\tnet->ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(dev);\n#endif\n\t } else if (event == NETDEV_UNREGISTER &&\n\t\t    dev->reg_state != NETREG_UNREGISTERED) {\n\t\t \n\t\tin6_dev_put_clear(&net->ipv6.ip6_null_entry->rt6i_idev);\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\t\tin6_dev_put_clear(&net->ipv6.ip6_prohibit_entry->rt6i_idev);\n\t\tin6_dev_put_clear(&net->ipv6.ip6_blk_hole_entry->rt6i_idev);\n#endif\n\t}\n\n\treturn NOTIFY_OK;\n}\n\n \n\n#ifdef CONFIG_PROC_FS\nstatic int rt6_stats_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct net *net = (struct net *)seq->private;\n\tseq_printf(seq, \"%04x %04x %04x %04x %04x %04x %04x\\n\",\n\t\t   net->ipv6.rt6_stats->fib_nodes,\n\t\t   net->ipv6.rt6_stats->fib_route_nodes,\n\t\t   atomic_read(&net->ipv6.rt6_stats->fib_rt_alloc),\n\t\t   net->ipv6.rt6_stats->fib_rt_entries,\n\t\t   net->ipv6.rt6_stats->fib_rt_cache,\n\t\t   dst_entries_get_slow(&net->ipv6.ip6_dst_ops),\n\t\t   net->ipv6.rt6_stats->fib_discarded_routes);\n\n\treturn 0;\n}\n#endif\t \n\n#ifdef CONFIG_SYSCTL\n\nstatic int ipv6_sysctl_rtcache_flush(struct ctl_table *ctl, int write,\n\t\t\t      void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net;\n\tint delay;\n\tint ret;\n\tif (!write)\n\t\treturn -EINVAL;\n\n\tnet = (struct net *)ctl->extra1;\n\tdelay = net->ipv6.sysctl.flush_delay;\n\tret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\tif (ret)\n\t\treturn ret;\n\n\tfib6_run_gc(delay <= 0 ? 0 : (unsigned long)delay, net, delay > 0);\n\treturn 0;\n}\n\nstatic struct ctl_table ipv6_route_table_template[] = {\n\t{\n\t\t.procname\t=\t\"max_size\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_max_size,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec,\n\t},\n\t{\n\t\t.procname\t=\t\"gc_thresh\",\n\t\t.data\t\t=\t&ip6_dst_ops_template.gc_thresh,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec,\n\t},\n\t{\n\t\t.procname\t=\t\"flush\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.flush_delay,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0200,\n\t\t.proc_handler\t=\tipv6_sysctl_rtcache_flush\n\t},\n\t{\n\t\t.procname\t=\t\"gc_min_interval\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_gc_min_interval,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t=\t\"gc_timeout\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_gc_timeout,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t=\t\"gc_interval\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_gc_interval,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t=\t\"gc_elasticity\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_gc_elasticity,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec,\n\t},\n\t{\n\t\t.procname\t=\t\"mtu_expires\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_mtu_expires,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t=\t\"min_adv_mss\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_min_advmss,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec,\n\t},\n\t{\n\t\t.procname\t=\t\"gc_min_interval_ms\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_gc_min_interval,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec_ms_jiffies,\n\t},\n\t{\n\t\t.procname\t=\t\"skip_notify_on_dev_down\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.skip_notify_on_dev_down,\n\t\t.maxlen\t\t=\tsizeof(u8),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dou8vec_minmax,\n\t\t.extra1\t\t=\tSYSCTL_ZERO,\n\t\t.extra2\t\t=\tSYSCTL_ONE,\n\t},\n\t{ }\n};\n\nstruct ctl_table * __net_init ipv6_route_sysctl_init(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = kmemdup(ipv6_route_table_template,\n\t\t\tsizeof(ipv6_route_table_template),\n\t\t\tGFP_KERNEL);\n\n\tif (table) {\n\t\ttable[0].data = &net->ipv6.sysctl.ip6_rt_max_size;\n\t\ttable[1].data = &net->ipv6.ip6_dst_ops.gc_thresh;\n\t\ttable[2].data = &net->ipv6.sysctl.flush_delay;\n\t\ttable[2].extra1 = net;\n\t\ttable[3].data = &net->ipv6.sysctl.ip6_rt_gc_min_interval;\n\t\ttable[4].data = &net->ipv6.sysctl.ip6_rt_gc_timeout;\n\t\ttable[5].data = &net->ipv6.sysctl.ip6_rt_gc_interval;\n\t\ttable[6].data = &net->ipv6.sysctl.ip6_rt_gc_elasticity;\n\t\ttable[7].data = &net->ipv6.sysctl.ip6_rt_mtu_expires;\n\t\ttable[8].data = &net->ipv6.sysctl.ip6_rt_min_advmss;\n\t\ttable[9].data = &net->ipv6.sysctl.ip6_rt_gc_min_interval;\n\t\ttable[10].data = &net->ipv6.sysctl.skip_notify_on_dev_down;\n\n\t\t \n\t\tif (net->user_ns != &init_user_ns)\n\t\t\ttable[1].procname = NULL;\n\t}\n\n\treturn table;\n}\n\nsize_t ipv6_route_sysctl_table_size(struct net *net)\n{\n\t \n\tif (net->user_ns != &init_user_ns)\n\t\treturn 1;\n\n\treturn ARRAY_SIZE(ipv6_route_table_template);\n}\n#endif\n\nstatic int __net_init ip6_route_net_init(struct net *net)\n{\n\tint ret = -ENOMEM;\n\n\tmemcpy(&net->ipv6.ip6_dst_ops, &ip6_dst_ops_template,\n\t       sizeof(net->ipv6.ip6_dst_ops));\n\n\tif (dst_entries_init(&net->ipv6.ip6_dst_ops) < 0)\n\t\tgoto out_ip6_dst_ops;\n\n\tnet->ipv6.fib6_null_entry = fib6_info_alloc(GFP_KERNEL, true);\n\tif (!net->ipv6.fib6_null_entry)\n\t\tgoto out_ip6_dst_entries;\n\tmemcpy(net->ipv6.fib6_null_entry, &fib6_null_entry_template,\n\t       sizeof(*net->ipv6.fib6_null_entry));\n\n\tnet->ipv6.ip6_null_entry = kmemdup(&ip6_null_entry_template,\n\t\t\t\t\t   sizeof(*net->ipv6.ip6_null_entry),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!net->ipv6.ip6_null_entry)\n\t\tgoto out_fib6_null_entry;\n\tnet->ipv6.ip6_null_entry->dst.ops = &net->ipv6.ip6_dst_ops;\n\tdst_init_metrics(&net->ipv6.ip6_null_entry->dst,\n\t\t\t ip6_template_metrics, true);\n\tINIT_LIST_HEAD(&net->ipv6.ip6_null_entry->dst.rt_uncached);\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tnet->ipv6.fib6_has_custom_rules = false;\n\tnet->ipv6.ip6_prohibit_entry = kmemdup(&ip6_prohibit_entry_template,\n\t\t\t\t\t       sizeof(*net->ipv6.ip6_prohibit_entry),\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!net->ipv6.ip6_prohibit_entry)\n\t\tgoto out_ip6_null_entry;\n\tnet->ipv6.ip6_prohibit_entry->dst.ops = &net->ipv6.ip6_dst_ops;\n\tdst_init_metrics(&net->ipv6.ip6_prohibit_entry->dst,\n\t\t\t ip6_template_metrics, true);\n\tINIT_LIST_HEAD(&net->ipv6.ip6_prohibit_entry->dst.rt_uncached);\n\n\tnet->ipv6.ip6_blk_hole_entry = kmemdup(&ip6_blk_hole_entry_template,\n\t\t\t\t\t       sizeof(*net->ipv6.ip6_blk_hole_entry),\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!net->ipv6.ip6_blk_hole_entry)\n\t\tgoto out_ip6_prohibit_entry;\n\tnet->ipv6.ip6_blk_hole_entry->dst.ops = &net->ipv6.ip6_dst_ops;\n\tdst_init_metrics(&net->ipv6.ip6_blk_hole_entry->dst,\n\t\t\t ip6_template_metrics, true);\n\tINIT_LIST_HEAD(&net->ipv6.ip6_blk_hole_entry->dst.rt_uncached);\n#ifdef CONFIG_IPV6_SUBTREES\n\tnet->ipv6.fib6_routes_require_src = 0;\n#endif\n#endif\n\n\tnet->ipv6.sysctl.flush_delay = 0;\n\tnet->ipv6.sysctl.ip6_rt_max_size = INT_MAX;\n\tnet->ipv6.sysctl.ip6_rt_gc_min_interval = HZ / 2;\n\tnet->ipv6.sysctl.ip6_rt_gc_timeout = 60*HZ;\n\tnet->ipv6.sysctl.ip6_rt_gc_interval = 30*HZ;\n\tnet->ipv6.sysctl.ip6_rt_gc_elasticity = 9;\n\tnet->ipv6.sysctl.ip6_rt_mtu_expires = 10*60*HZ;\n\tnet->ipv6.sysctl.ip6_rt_min_advmss = IPV6_MIN_MTU - 20 - 40;\n\tnet->ipv6.sysctl.skip_notify_on_dev_down = 0;\n\n\tatomic_set(&net->ipv6.ip6_rt_gc_expire, 30*HZ);\n\n\tret = 0;\nout:\n\treturn ret;\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\nout_ip6_prohibit_entry:\n\tkfree(net->ipv6.ip6_prohibit_entry);\nout_ip6_null_entry:\n\tkfree(net->ipv6.ip6_null_entry);\n#endif\nout_fib6_null_entry:\n\tkfree(net->ipv6.fib6_null_entry);\nout_ip6_dst_entries:\n\tdst_entries_destroy(&net->ipv6.ip6_dst_ops);\nout_ip6_dst_ops:\n\tgoto out;\n}\n\nstatic void __net_exit ip6_route_net_exit(struct net *net)\n{\n\tkfree(net->ipv6.fib6_null_entry);\n\tkfree(net->ipv6.ip6_null_entry);\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tkfree(net->ipv6.ip6_prohibit_entry);\n\tkfree(net->ipv6.ip6_blk_hole_entry);\n#endif\n\tdst_entries_destroy(&net->ipv6.ip6_dst_ops);\n}\n\nstatic int __net_init ip6_route_net_init_late(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tif (!proc_create_net(\"ipv6_route\", 0, net->proc_net,\n\t\t\t     &ipv6_route_seq_ops,\n\t\t\t     sizeof(struct ipv6_route_iter)))\n\t\treturn -ENOMEM;\n\n\tif (!proc_create_net_single(\"rt6_stats\", 0444, net->proc_net,\n\t\t\t\t    rt6_stats_seq_show, NULL)) {\n\t\tremove_proc_entry(\"ipv6_route\", net->proc_net);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic void __net_exit ip6_route_net_exit_late(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"ipv6_route\", net->proc_net);\n\tremove_proc_entry(\"rt6_stats\", net->proc_net);\n#endif\n}\n\nstatic struct pernet_operations ip6_route_net_ops = {\n\t.init = ip6_route_net_init,\n\t.exit = ip6_route_net_exit,\n};\n\nstatic int __net_init ipv6_inetpeer_init(struct net *net)\n{\n\tstruct inet_peer_base *bp = kmalloc(sizeof(*bp), GFP_KERNEL);\n\n\tif (!bp)\n\t\treturn -ENOMEM;\n\tinet_peer_base_init(bp);\n\tnet->ipv6.peers = bp;\n\treturn 0;\n}\n\nstatic void __net_exit ipv6_inetpeer_exit(struct net *net)\n{\n\tstruct inet_peer_base *bp = net->ipv6.peers;\n\n\tnet->ipv6.peers = NULL;\n\tinetpeer_invalidate_tree(bp);\n\tkfree(bp);\n}\n\nstatic struct pernet_operations ipv6_inetpeer_ops = {\n\t.init\t=\tipv6_inetpeer_init,\n\t.exit\t=\tipv6_inetpeer_exit,\n};\n\nstatic struct pernet_operations ip6_route_net_late_ops = {\n\t.init = ip6_route_net_init_late,\n\t.exit = ip6_route_net_exit_late,\n};\n\nstatic struct notifier_block ip6_route_dev_notifier = {\n\t.notifier_call = ip6_route_dev_notify,\n\t.priority = ADDRCONF_NOTIFY_PRIORITY - 10,\n};\n\nvoid __init ip6_route_init_special_entries(void)\n{\n\t \n\tinit_net.ipv6.fib6_null_entry->fib6_nh->fib_nh_dev = init_net.loopback_dev;\n\tinit_net.ipv6.ip6_null_entry->dst.dev = init_net.loopback_dev;\n\tinit_net.ipv6.ip6_null_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);\n  #ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tinit_net.ipv6.ip6_prohibit_entry->dst.dev = init_net.loopback_dev;\n\tinit_net.ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);\n\tinit_net.ipv6.ip6_blk_hole_entry->dst.dev = init_net.loopback_dev;\n\tinit_net.ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);\n  #endif\n}\n\n#if IS_BUILTIN(CONFIG_IPV6)\n#if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_PROC_FS)\nDEFINE_BPF_ITER_FUNC(ipv6_route, struct bpf_iter_meta *meta, struct fib6_info *rt)\n\nBTF_ID_LIST(btf_fib6_info_id)\nBTF_ID(struct, fib6_info)\n\nstatic const struct bpf_iter_seq_info ipv6_route_seq_info = {\n\t.seq_ops\t\t= &ipv6_route_seq_ops,\n\t.init_seq_private\t= bpf_iter_init_seq_net,\n\t.fini_seq_private\t= bpf_iter_fini_seq_net,\n\t.seq_priv_size\t\t= sizeof(struct ipv6_route_iter),\n};\n\nstatic struct bpf_iter_reg ipv6_route_reg_info = {\n\t.target\t\t\t= \"ipv6_route\",\n\t.ctx_arg_info_size\t= 1,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__ipv6_route, rt),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &ipv6_route_seq_info,\n};\n\nstatic int __init bpf_iter_register(void)\n{\n\tipv6_route_reg_info.ctx_arg_info[0].btf_id = *btf_fib6_info_id;\n\treturn bpf_iter_reg_target(&ipv6_route_reg_info);\n}\n\nstatic void bpf_iter_unregister(void)\n{\n\tbpf_iter_unreg_target(&ipv6_route_reg_info);\n}\n#endif\n#endif\n\nint __init ip6_route_init(void)\n{\n\tint ret;\n\tint cpu;\n\n\tret = -ENOMEM;\n\tip6_dst_ops_template.kmem_cachep =\n\t\tkmem_cache_create(\"ip6_dst_cache\", sizeof(struct rt6_info), 0,\n\t\t\t\t  SLAB_HWCACHE_ALIGN | SLAB_ACCOUNT, NULL);\n\tif (!ip6_dst_ops_template.kmem_cachep)\n\t\tgoto out;\n\n\tret = dst_entries_init(&ip6_dst_blackhole_ops);\n\tif (ret)\n\t\tgoto out_kmem_cache;\n\n\tret = register_pernet_subsys(&ipv6_inetpeer_ops);\n\tif (ret)\n\t\tgoto out_dst_entries;\n\n\tret = register_pernet_subsys(&ip6_route_net_ops);\n\tif (ret)\n\t\tgoto out_register_inetpeer;\n\n\tip6_dst_blackhole_ops.kmem_cachep = ip6_dst_ops_template.kmem_cachep;\n\n\tret = fib6_init();\n\tif (ret)\n\t\tgoto out_register_subsys;\n\n\tret = xfrm6_init();\n\tif (ret)\n\t\tgoto out_fib6_init;\n\n\tret = fib6_rules_init();\n\tif (ret)\n\t\tgoto xfrm6_init;\n\n\tret = register_pernet_subsys(&ip6_route_net_late_ops);\n\tif (ret)\n\t\tgoto fib6_rules_init;\n\n\tret = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_NEWROUTE,\n\t\t\t\t   inet6_rtm_newroute, NULL, 0);\n\tif (ret < 0)\n\t\tgoto out_register_late_subsys;\n\n\tret = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_DELROUTE,\n\t\t\t\t   inet6_rtm_delroute, NULL, 0);\n\tif (ret < 0)\n\t\tgoto out_register_late_subsys;\n\n\tret = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_GETROUTE,\n\t\t\t\t   inet6_rtm_getroute, NULL,\n\t\t\t\t   RTNL_FLAG_DOIT_UNLOCKED);\n\tif (ret < 0)\n\t\tgoto out_register_late_subsys;\n\n\tret = register_netdevice_notifier(&ip6_route_dev_notifier);\n\tif (ret)\n\t\tgoto out_register_late_subsys;\n\n#if IS_BUILTIN(CONFIG_IPV6)\n#if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_PROC_FS)\n\tret = bpf_iter_register();\n\tif (ret)\n\t\tgoto out_register_late_subsys;\n#endif\n#endif\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct uncached_list *ul = per_cpu_ptr(&rt6_uncached_list, cpu);\n\n\t\tINIT_LIST_HEAD(&ul->head);\n\t\tINIT_LIST_HEAD(&ul->quarantine);\n\t\tspin_lock_init(&ul->lock);\n\t}\n\nout:\n\treturn ret;\n\nout_register_late_subsys:\n\trtnl_unregister_all(PF_INET6);\n\tunregister_pernet_subsys(&ip6_route_net_late_ops);\nfib6_rules_init:\n\tfib6_rules_cleanup();\nxfrm6_init:\n\txfrm6_fini();\nout_fib6_init:\n\tfib6_gc_cleanup();\nout_register_subsys:\n\tunregister_pernet_subsys(&ip6_route_net_ops);\nout_register_inetpeer:\n\tunregister_pernet_subsys(&ipv6_inetpeer_ops);\nout_dst_entries:\n\tdst_entries_destroy(&ip6_dst_blackhole_ops);\nout_kmem_cache:\n\tkmem_cache_destroy(ip6_dst_ops_template.kmem_cachep);\n\tgoto out;\n}\n\nvoid ip6_route_cleanup(void)\n{\n#if IS_BUILTIN(CONFIG_IPV6)\n#if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_PROC_FS)\n\tbpf_iter_unregister();\n#endif\n#endif\n\tunregister_netdevice_notifier(&ip6_route_dev_notifier);\n\tunregister_pernet_subsys(&ip6_route_net_late_ops);\n\tfib6_rules_cleanup();\n\txfrm6_fini();\n\tfib6_gc_cleanup();\n\tunregister_pernet_subsys(&ipv6_inetpeer_ops);\n\tunregister_pernet_subsys(&ip6_route_net_ops);\n\tdst_entries_destroy(&ip6_dst_blackhole_ops);\n\tkmem_cache_destroy(ip6_dst_ops_template.kmem_cachep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}