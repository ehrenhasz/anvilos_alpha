{
  "module_name": "tunnel6.c",
  "hash_id": "1515e763adac6318136cc61b0bd208578723dd368d01a441f2030aa21e7efdaf",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/tunnel6.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/icmpv6.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\nstatic struct xfrm6_tunnel __rcu *tunnel6_handlers __read_mostly;\nstatic struct xfrm6_tunnel __rcu *tunnel46_handlers __read_mostly;\nstatic struct xfrm6_tunnel __rcu *tunnelmpls6_handlers __read_mostly;\nstatic DEFINE_MUTEX(tunnel6_mutex);\n\nstatic inline int xfrm6_tunnel_mpls_supported(void)\n{\n\treturn IS_ENABLED(CONFIG_MPLS);\n}\n\nint xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family)\n{\n\tstruct xfrm6_tunnel __rcu **pprev;\n\tstruct xfrm6_tunnel *t;\n\tint ret = -EEXIST;\n\tint priority = handler->priority;\n\n\tmutex_lock(&tunnel6_mutex);\n\n\tswitch (family) {\n\tcase AF_INET6:\n\t\tpprev = &tunnel6_handlers;\n\t\tbreak;\n\tcase AF_INET:\n\t\tpprev = &tunnel46_handlers;\n\t\tbreak;\n\tcase AF_MPLS:\n\t\tpprev = &tunnelmpls6_handlers;\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\tfor (; (t = rcu_dereference_protected(*pprev,\n\t\t\tlockdep_is_held(&tunnel6_mutex))) != NULL;\n\t     pprev = &t->next) {\n\t\tif (t->priority > priority)\n\t\t\tbreak;\n\t\tif (t->priority == priority)\n\t\t\tgoto err;\n\t}\n\n\thandler->next = *pprev;\n\trcu_assign_pointer(*pprev, handler);\n\n\tret = 0;\n\nerr:\n\tmutex_unlock(&tunnel6_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(xfrm6_tunnel_register);\n\nint xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family)\n{\n\tstruct xfrm6_tunnel __rcu **pprev;\n\tstruct xfrm6_tunnel *t;\n\tint ret = -ENOENT;\n\n\tmutex_lock(&tunnel6_mutex);\n\n\tswitch (family) {\n\tcase AF_INET6:\n\t\tpprev = &tunnel6_handlers;\n\t\tbreak;\n\tcase AF_INET:\n\t\tpprev = &tunnel46_handlers;\n\t\tbreak;\n\tcase AF_MPLS:\n\t\tpprev = &tunnelmpls6_handlers;\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\tfor (; (t = rcu_dereference_protected(*pprev,\n\t\t\tlockdep_is_held(&tunnel6_mutex))) != NULL;\n\t     pprev = &t->next) {\n\t\tif (t == handler) {\n\t\t\t*pprev = handler->next;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nerr:\n\tmutex_unlock(&tunnel6_mutex);\n\n\tsynchronize_net();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(xfrm6_tunnel_deregister);\n\n#define for_each_tunnel_rcu(head, handler)\t\t\\\n\tfor (handler = rcu_dereference(head);\t\t\\\n\t     handler != NULL;\t\t\t\t\\\n\t     handler = rcu_dereference(handler->next))\t\\\n\nstatic int tunnelmpls6_rcv(struct sk_buff *skb)\n{\n\tstruct xfrm6_tunnel *handler;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto drop;\n\n\tfor_each_tunnel_rcu(tunnelmpls6_handlers, handler)\n\t\tif (!handler->handler(skb))\n\t\t\treturn 0;\n\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int tunnel6_rcv(struct sk_buff *skb)\n{\n\tstruct xfrm6_tunnel *handler;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto drop;\n\n\tfor_each_tunnel_rcu(tunnel6_handlers, handler)\n\t\tif (!handler->handler(skb))\n\t\t\treturn 0;\n\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_INET6_XFRM_TUNNEL)\nstatic int tunnel6_rcv_cb(struct sk_buff *skb, u8 proto, int err)\n{\n\tstruct xfrm6_tunnel __rcu *head;\n\tstruct xfrm6_tunnel *handler;\n\tint ret;\n\n\thead = (proto == IPPROTO_IPV6) ? tunnel6_handlers : tunnel46_handlers;\n\n\tfor_each_tunnel_rcu(head, handler) {\n\t\tif (handler->cb_handler) {\n\t\t\tret = handler->cb_handler(skb, err);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct xfrm_input_afinfo tunnel6_input_afinfo = {\n\t.family\t\t=\tAF_INET6,\n\t.is_ipip\t=\ttrue,\n\t.callback\t=\ttunnel6_rcv_cb,\n};\n#endif\n\nstatic int tunnel46_rcv(struct sk_buff *skb)\n{\n\tstruct xfrm6_tunnel *handler;\n\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\tgoto drop;\n\n\tfor_each_tunnel_rcu(tunnel46_handlers, handler)\n\t\tif (!handler->handler(skb))\n\t\t\treturn 0;\n\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int tunnel6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tstruct xfrm6_tunnel *handler;\n\n\tfor_each_tunnel_rcu(tunnel6_handlers, handler)\n\t\tif (!handler->err_handler(skb, opt, type, code, offset, info))\n\t\t\treturn 0;\n\n\treturn -ENOENT;\n}\n\nstatic int tunnel46_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t u8 type, u8 code, int offset, __be32 info)\n{\n\tstruct xfrm6_tunnel *handler;\n\n\tfor_each_tunnel_rcu(tunnel46_handlers, handler)\n\t\tif (!handler->err_handler(skb, opt, type, code, offset, info))\n\t\t\treturn 0;\n\n\treturn -ENOENT;\n}\n\nstatic int tunnelmpls6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t   u8 type, u8 code, int offset, __be32 info)\n{\n\tstruct xfrm6_tunnel *handler;\n\n\tfor_each_tunnel_rcu(tunnelmpls6_handlers, handler)\n\t\tif (!handler->err_handler(skb, opt, type, code, offset, info))\n\t\t\treturn 0;\n\n\treturn -ENOENT;\n}\n\nstatic const struct inet6_protocol tunnel6_protocol = {\n\t.handler\t= tunnel6_rcv,\n\t.err_handler\t= tunnel6_err,\n\t.flags          = INET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\nstatic const struct inet6_protocol tunnel46_protocol = {\n\t.handler\t= tunnel46_rcv,\n\t.err_handler\t= tunnel46_err,\n\t.flags          = INET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\nstatic const struct inet6_protocol tunnelmpls6_protocol = {\n\t.handler\t= tunnelmpls6_rcv,\n\t.err_handler\t= tunnelmpls6_err,\n\t.flags          = INET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\nstatic int __init tunnel6_init(void)\n{\n\tif (inet6_add_protocol(&tunnel6_protocol, IPPROTO_IPV6)) {\n\t\tpr_err(\"%s: can't add protocol\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\tif (inet6_add_protocol(&tunnel46_protocol, IPPROTO_IPIP)) {\n\t\tpr_err(\"%s: can't add protocol\\n\", __func__);\n\t\tinet6_del_protocol(&tunnel6_protocol, IPPROTO_IPV6);\n\t\treturn -EAGAIN;\n\t}\n\tif (xfrm6_tunnel_mpls_supported() &&\n\t    inet6_add_protocol(&tunnelmpls6_protocol, IPPROTO_MPLS)) {\n\t\tpr_err(\"%s: can't add protocol\\n\", __func__);\n\t\tinet6_del_protocol(&tunnel6_protocol, IPPROTO_IPV6);\n\t\tinet6_del_protocol(&tunnel46_protocol, IPPROTO_IPIP);\n\t\treturn -EAGAIN;\n\t}\n#if IS_ENABLED(CONFIG_INET6_XFRM_TUNNEL)\n\tif (xfrm_input_register_afinfo(&tunnel6_input_afinfo)) {\n\t\tpr_err(\"%s: can't add input afinfo\\n\", __func__);\n\t\tinet6_del_protocol(&tunnel6_protocol, IPPROTO_IPV6);\n\t\tinet6_del_protocol(&tunnel46_protocol, IPPROTO_IPIP);\n\t\tif (xfrm6_tunnel_mpls_supported())\n\t\t\tinet6_del_protocol(&tunnelmpls6_protocol, IPPROTO_MPLS);\n\t\treturn -EAGAIN;\n\t}\n#endif\n\treturn 0;\n}\n\nstatic void __exit tunnel6_fini(void)\n{\n#if IS_ENABLED(CONFIG_INET6_XFRM_TUNNEL)\n\tif (xfrm_input_unregister_afinfo(&tunnel6_input_afinfo))\n\t\tpr_err(\"%s: can't remove input afinfo\\n\", __func__);\n#endif\n\tif (inet6_del_protocol(&tunnel46_protocol, IPPROTO_IPIP))\n\t\tpr_err(\"%s: can't remove protocol\\n\", __func__);\n\tif (inet6_del_protocol(&tunnel6_protocol, IPPROTO_IPV6))\n\t\tpr_err(\"%s: can't remove protocol\\n\", __func__);\n\tif (xfrm6_tunnel_mpls_supported() &&\n\t    inet6_del_protocol(&tunnelmpls6_protocol, IPPROTO_MPLS))\n\t\tpr_err(\"%s: can't remove protocol\\n\", __func__);\n}\n\nmodule_init(tunnel6_init);\nmodule_exit(tunnel6_fini);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}