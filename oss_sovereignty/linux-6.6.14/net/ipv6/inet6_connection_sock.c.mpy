{
  "module_name": "inet6_connection_sock.c",
  "hash_id": "df677a1b0403d344feaf8fdea38acf7fc0638df830d78d9c722ac6b4486f0f36",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/inet6_connection_sock.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/jhash.h>\n#include <linux/slab.h>\n\n#include <net/addrconf.h>\n#include <net/inet_connection_sock.h>\n#include <net/inet_ecn.h>\n#include <net/inet_hashtables.h>\n#include <net/ip6_route.h>\n#include <net/sock.h>\n#include <net/inet6_connection_sock.h>\n#include <net/sock_reuseport.h>\n\nstruct dst_entry *inet6_csk_route_req(const struct sock *sk,\n\t\t\t\t      struct flowi6 *fl6,\n\t\t\t\t      const struct request_sock *req,\n\t\t\t\t      u8 proto)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = proto;\n\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\tfl6->saddr = ireq->ir_v6_loc_addr;\n\tfl6->flowi6_oif = ireq->ir_iif;\n\tfl6->flowi6_mark = ireq->ir_mark;\n\tfl6->fl6_dport = ireq->ir_rmt_port;\n\tfl6->fl6_sport = htons(ireq->ir_num);\n\tfl6->flowi6_uid = sk->sk_uid;\n\tsecurity_req_classify_flow(req, flowi6_to_flowi_common(fl6));\n\n\tdst = ip6_dst_lookup_flow(sock_net(sk), sk, fl6, final_p);\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\n\treturn dst;\n}\nEXPORT_SYMBOL(inet6_csk_route_req);\n\nvoid inet6_csk_addr2sockaddr(struct sock *sk, struct sockaddr *uaddr)\n{\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) uaddr;\n\n\tsin6->sin6_family = AF_INET6;\n\tsin6->sin6_addr = sk->sk_v6_daddr;\n\tsin6->sin6_port\t= inet_sk(sk)->inet_dport;\n\t \n\tsin6->sin6_flowinfo = 0;\n\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t  sk->sk_bound_dev_if);\n}\nEXPORT_SYMBOL_GPL(inet6_csk_addr2sockaddr);\n\nstatic inline\nstruct dst_entry *__inet6_csk_dst_check(struct sock *sk, u32 cookie)\n{\n\treturn __sk_dst_check(sk, cookie);\n}\n\nstatic struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tfl6->flowi6_uid = sk->sk_uid;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi_common(fl6));\n\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sock_net(sk), sk, fl6, final_p);\n\n\t\tif (!IS_ERR(dst))\n\t\t\tip6_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}\n\nint inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint res;\n\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\tif (IS_ERR(dst)) {\n\t\tWRITE_ONCE(sk->sk_err_soft, -PTR_ERR(dst));\n\t\tsk->sk_route_caps = 0;\n\t\tkfree_skb(skb);\n\t\treturn PTR_ERR(dst);\n\t}\n\n\trcu_read_lock();\n\tskb_dst_set_noref(skb, dst);\n\n\t \n\tfl6.daddr = sk->sk_v6_daddr;\n\n\tres = ip6_xmit(sk, skb, &fl6, sk->sk_mark, rcu_dereference(np->opt),\n\t\t       np->tclass,  sk->sk_priority);\n\trcu_read_unlock();\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(inet6_csk_xmit);\n\nstruct dst_entry *inet6_csk_update_pmtu(struct sock *sk, u32 mtu)\n{\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst = inet6_csk_route_socket(sk, &fl6);\n\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\tdst->ops->update_pmtu(dst, sk, NULL, mtu, true);\n\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\treturn IS_ERR(dst) ? NULL : dst;\n}\nEXPORT_SYMBOL_GPL(inet6_csk_update_pmtu);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}