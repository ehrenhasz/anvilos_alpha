{
  "module_name": "esp6_offload.c",
  "hash_id": "64f06c98d3590cef9a698c70dcc61150c256bcf6a5cefff60f774c0aea5b1a97",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/esp6_offload.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <net/protocol.h>\n#include <crypto/aead.h>\n#include <crypto/authenc.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <net/gro.h>\n#include <net/gso.h>\n#include <net/ip.h>\n#include <net/xfrm.h>\n#include <net/esp.h>\n#include <linux/scatterlist.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <net/ip6_route.h>\n#include <net/ipv6.h>\n#include <linux/icmpv6.h>\n\nstatic __u16 esp6_nexthdr_esp_offset(struct ipv6hdr *ipv6_hdr, int nhlen)\n{\n\tint off = sizeof(struct ipv6hdr);\n\tstruct ipv6_opt_hdr *exthdr;\n\n\tif (likely(ipv6_hdr->nexthdr == NEXTHDR_ESP))\n\t\treturn offsetof(struct ipv6hdr, nexthdr);\n\n\twhile (off < nhlen) {\n\t\texthdr = (void *)ipv6_hdr + off;\n\t\tif (exthdr->nexthdr == NEXTHDR_ESP)\n\t\t\treturn off;\n\n\t\toff += ipv6_optlen(exthdr);\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff *esp6_gro_receive(struct list_head *head,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tint offset = skb_gro_offset(skb);\n\tstruct xfrm_offload *xo;\n\tstruct xfrm_state *x;\n\t__be32 seq;\n\t__be32 spi;\n\tint nhoff;\n\n\tif (!pskb_pull(skb, offset))\n\t\treturn NULL;\n\n\tif (xfrm_parse_spi(skb, IPPROTO_ESP, &spi, &seq) != 0)\n\t\tgoto out;\n\n\txo = xfrm_offload(skb);\n\tif (!xo || !(xo->flags & CRYPTO_DONE)) {\n\t\tstruct sec_path *sp = secpath_set(skb);\n\n\t\tif (!sp)\n\t\t\tgoto out;\n\n\t\tif (sp->len == XFRM_MAX_DEPTH)\n\t\t\tgoto out_reset;\n\n\t\tx = xfrm_state_lookup(dev_net(skb->dev), skb->mark,\n\t\t\t\t      (xfrm_address_t *)&ipv6_hdr(skb)->daddr,\n\t\t\t\t      spi, IPPROTO_ESP, AF_INET6);\n\t\tif (!x)\n\t\t\tgoto out_reset;\n\n\t\tskb->mark = xfrm_smark_get(skb->mark, x);\n\n\t\tsp->xvec[sp->len++] = x;\n\t\tsp->olen++;\n\n\t\txo = xfrm_offload(skb);\n\t\tif (!xo)\n\t\t\tgoto out_reset;\n\t}\n\n\txo->flags |= XFRM_GRO;\n\n\tnhoff = esp6_nexthdr_esp_offset(ipv6_hdr(skb), offset);\n\tif (!nhoff)\n\t\tgoto out;\n\n\tIP6CB(skb)->nhoff = nhoff;\n\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6 = NULL;\n\tXFRM_SPI_SKB_CB(skb)->family = AF_INET6;\n\tXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct ipv6hdr, daddr);\n\tXFRM_SPI_SKB_CB(skb)->seq = seq;\n\n\t \n\txfrm_input(skb, IPPROTO_ESP, spi, -2);\n\n\treturn ERR_PTR(-EINPROGRESS);\nout_reset:\n\tsecpath_reset(skb);\nout:\n\tskb_push(skb, offset);\n\tNAPI_GRO_CB(skb)->same_flow = 0;\n\tNAPI_GRO_CB(skb)->flush = 1;\n\n\treturn NULL;\n}\n\nstatic void esp6_gso_encap(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ip_esp_hdr *esph;\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tu8 proto = iph->nexthdr;\n\n\tskb_push(skb, -skb_network_offset(skb));\n\n\tif (x->outer_mode.encap == XFRM_MODE_TRANSPORT) {\n\t\t__be16 frag;\n\n\t\tipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &proto, &frag);\n\t}\n\n\tesph = ip_esp_hdr(skb);\n\t*skb_mac_header(skb) = IPPROTO_ESP;\n\n\tesph->spi = x->id.spi;\n\tesph->seq_no = htonl(XFRM_SKB_CB(skb)->seq.output.low);\n\n\txo->proto = proto;\n}\n\nstatic struct sk_buff *xfrm6_tunnel_gso_segment(struct xfrm_state *x,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\tnetdev_features_t features)\n{\n\t__be16 type = x->inner_mode.family == AF_INET ? htons(ETH_P_IP)\n\t\t\t\t\t\t      : htons(ETH_P_IPV6);\n\n\treturn skb_eth_gso_segment(skb, features, type);\n}\n\nstatic struct sk_buff *xfrm6_transport_gso_segment(struct xfrm_state *x,\n\t\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t\t   netdev_features_t features)\n{\n\tconst struct net_offload *ops;\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\n\tskb->transport_header += x->props.header_len;\n\tops = rcu_dereference(inet6_offloads[xo->proto]);\n\tif (likely(ops && ops->callbacks.gso_segment))\n\t\tsegs = ops->callbacks.gso_segment(skb, features);\n\n\treturn segs;\n}\n\nstatic struct sk_buff *xfrm6_beet_gso_segment(struct xfrm_state *x,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      netdev_features_t features)\n{\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tconst struct net_offload *ops;\n\tu8 proto = xo->proto;\n\n\tskb->transport_header += x->props.header_len;\n\n\tif (x->sel.family != AF_INET6) {\n\t\tskb->transport_header -=\n\t\t\t(sizeof(struct ipv6hdr) - sizeof(struct iphdr));\n\n\t\tif (proto == IPPROTO_BEETPH) {\n\t\t\tstruct ip_beet_phdr *ph =\n\t\t\t\t(struct ip_beet_phdr *)skb->data;\n\n\t\t\tskb->transport_header += ph->hdrlen * 8;\n\t\t\tproto = ph->nexthdr;\n\t\t} else {\n\t\t\tskb->transport_header -= IPV4_BEET_PHMAXLEN;\n\t\t}\n\n\t\tif (proto == IPPROTO_TCP)\n\t\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_TCPV6;\n\t} else {\n\t\t__be16 frag;\n\n\t\tskb->transport_header +=\n\t\t\tipv6_skip_exthdr(skb, 0, &proto, &frag);\n\t}\n\n\tif (proto == IPPROTO_IPIP)\n\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_IPXIP6;\n\n\t__skb_pull(skb, skb_transport_offset(skb));\n\tops = rcu_dereference(inet6_offloads[proto]);\n\tif (likely(ops && ops->callbacks.gso_segment))\n\t\tsegs = ops->callbacks.gso_segment(skb, features);\n\n\treturn segs;\n}\n\nstatic struct sk_buff *xfrm6_outer_mode_gso_segment(struct xfrm_state *x,\n\t\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t\t    netdev_features_t features)\n{\n\tswitch (x->outer_mode.encap) {\n\tcase XFRM_MODE_TUNNEL:\n\t\treturn xfrm6_tunnel_gso_segment(x, skb, features);\n\tcase XFRM_MODE_TRANSPORT:\n\t\treturn xfrm6_transport_gso_segment(x, skb, features);\n\tcase XFRM_MODE_BEET:\n\t\treturn xfrm6_beet_gso_segment(x, skb, features);\n\t}\n\n\treturn ERR_PTR(-EOPNOTSUPP);\n}\n\nstatic struct sk_buff *esp6_gso_segment(struct sk_buff *skb,\n\t\t\t\t        netdev_features_t features)\n{\n\tstruct xfrm_state *x;\n\tstruct ip_esp_hdr *esph;\n\tstruct crypto_aead *aead;\n\tnetdev_features_t esp_features = features;\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tstruct sec_path *sp;\n\n\tif (!xo)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(skb_shinfo(skb)->gso_type & SKB_GSO_ESP))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsp = skb_sec_path(skb);\n\tx = sp->xvec[sp->len - 1];\n\taead = x->data;\n\tesph = ip_esp_hdr(skb);\n\n\tif (esph->spi != x->id.spi)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!pskb_may_pull(skb, sizeof(*esph) + crypto_aead_ivsize(aead)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t__skb_pull(skb, sizeof(*esph) + crypto_aead_ivsize(aead));\n\n\tskb->encap_hdr_csum = 1;\n\n\tif (!(features & NETIF_F_HW_ESP) || x->xso.dev != skb->dev)\n\t\tesp_features = features & ~(NETIF_F_SG | NETIF_F_CSUM_MASK |\n\t\t\t\t\t    NETIF_F_SCTP_CRC);\n\telse if (!(features & NETIF_F_HW_ESP_TX_CSUM))\n\t\tesp_features = features & ~(NETIF_F_CSUM_MASK |\n\t\t\t\t\t    NETIF_F_SCTP_CRC);\n\n\txo->flags |= XFRM_GSO_SEGMENT;\n\n\treturn xfrm6_outer_mode_gso_segment(x, skb, esp_features);\n}\n\nstatic int esp6_input_tail(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct crypto_aead *aead = x->data;\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\n\tif (!pskb_may_pull(skb, sizeof(struct ip_esp_hdr) + crypto_aead_ivsize(aead)))\n\t\treturn -EINVAL;\n\n\tif (!(xo->flags & CRYPTO_DONE))\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\treturn esp6_input_done2(skb, 0);\n}\n\nstatic int esp6_xmit(struct xfrm_state *x, struct sk_buff *skb,  netdev_features_t features)\n{\n\tint len;\n\tint err;\n\tint alen;\n\tint blksize;\n\tstruct xfrm_offload *xo;\n\tstruct crypto_aead *aead;\n\tstruct esp_info esp;\n\tbool hw_offload = true;\n\t__u32 seq;\n\n\tesp.inplace = true;\n\n\txo = xfrm_offload(skb);\n\n\tif (!xo)\n\t\treturn -EINVAL;\n\n\tif (!(features & NETIF_F_HW_ESP) || x->xso.dev != skb->dev) {\n\t\txo->flags |= CRYPTO_FALLBACK;\n\t\thw_offload = false;\n\t}\n\n\tesp.proto = xo->proto;\n\n\t \n\n\taead = x->data;\n\talen = crypto_aead_authsize(aead);\n\n\tesp.tfclen = 0;\n\t \n\n\tblksize = ALIGN(crypto_aead_blocksize(aead), 4);\n\tesp.clen = ALIGN(skb->len + 2 + esp.tfclen, blksize);\n\tesp.plen = esp.clen - skb->len - esp.tfclen;\n\tesp.tailen = esp.tfclen + esp.plen + alen;\n\n\tif (!hw_offload || !skb_is_gso(skb)) {\n\t\tesp.nfrags = esp6_output_head(x, skb, &esp);\n\t\tif (esp.nfrags < 0)\n\t\t\treturn esp.nfrags;\n\t}\n\n\tseq = xo->seq.low;\n\n\tesp.esph = ip_esp_hdr(skb);\n\tesp.esph->spi = x->id.spi;\n\n\tskb_push(skb, -skb_network_offset(skb));\n\n\tif (xo->flags & XFRM_GSO_SEGMENT) {\n\t\tesp.esph->seq_no = htonl(seq);\n\n\t\tif (!skb_is_gso(skb))\n\t\t\txo->seq.low++;\n\t\telse\n\t\t\txo->seq.low += skb_shinfo(skb)->gso_segs;\n\t}\n\n\tif (xo->seq.low < seq)\n\t\txo->seq.hi++;\n\n\tesp.seqno = cpu_to_be64(xo->seq.low + ((u64)xo->seq.hi << 32));\n\n\tlen = skb->len - sizeof(struct ipv6hdr);\n\tif (len > IPV6_MAXPLEN)\n\t\tlen = 0;\n\n\tipv6_hdr(skb)->payload_len = htons(len);\n\n\tif (hw_offload) {\n\t\tif (!skb_ext_add(skb, SKB_EXT_SEC_PATH))\n\t\t\treturn -ENOMEM;\n\n\t\txo = xfrm_offload(skb);\n\t\tif (!xo)\n\t\t\treturn -EINVAL;\n\n\t\txo->flags |= XFRM_XMIT;\n\t\treturn 0;\n\t}\n\n\terr = esp6_output_tail(x, skb, &esp);\n\tif (err)\n\t\treturn err;\n\n\tsecpath_reset(skb);\n\n\tif (skb_needs_linearize(skb, skb->dev->features) &&\n\t    __skb_linearize(skb))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic const struct net_offload esp6_offload = {\n\t.callbacks = {\n\t\t.gro_receive = esp6_gro_receive,\n\t\t.gso_segment = esp6_gso_segment,\n\t},\n};\n\nstatic const struct xfrm_type_offload esp6_type_offload = {\n\t.owner\t\t= THIS_MODULE,\n\t.proto\t     \t= IPPROTO_ESP,\n\t.input_tail\t= esp6_input_tail,\n\t.xmit\t\t= esp6_xmit,\n\t.encap\t\t= esp6_gso_encap,\n};\n\nstatic int __init esp6_offload_init(void)\n{\n\tif (xfrm_register_type_offload(&esp6_type_offload, AF_INET6) < 0) {\n\t\tpr_info(\"%s: can't add xfrm type offload\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn inet6_add_offload(&esp6_offload, IPPROTO_ESP);\n}\n\nstatic void __exit esp6_offload_exit(void)\n{\n\txfrm_unregister_type_offload(&esp6_type_offload, AF_INET6);\n\tinet6_del_offload(&esp6_offload, IPPROTO_ESP);\n}\n\nmodule_init(esp6_offload_init);\nmodule_exit(esp6_offload_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Steffen Klassert <steffen.klassert@secunet.com>\");\nMODULE_ALIAS_XFRM_OFFLOAD_TYPE(AF_INET6, XFRM_PROTO_ESP);\nMODULE_DESCRIPTION(\"IPV6 GSO/GRO offload support\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}