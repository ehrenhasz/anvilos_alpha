{
  "module_name": "ip6_output.c",
  "hash_id": "2743094d87c5385b97b3606b5a7433f7ca56def7b6935f3bf12195fe19729fc7",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ip6_output.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/tcp.h>\n#include <linux/route.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/bpf-cgroup.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/gso.h>\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/rawv6.h>\n#include <net/icmp.h>\n#include <net/xfrm.h>\n#include <net/checksum.h>\n#include <linux/mroute6.h>\n#include <net/l3mdev.h>\n#include <net/lwtunnel.h>\n#include <net/ip_tunnels.h>\n\nstatic int ip6_finish_output2(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net_device *dev = dst->dev;\n\tstruct inet6_dev *idev = ip6_dst_idev(dst);\n\tunsigned int hh_len = LL_RESERVED_SPACE(dev);\n\tconst struct in6_addr *daddr, *nexthop;\n\tstruct ipv6hdr *hdr;\n\tstruct neighbour *neigh;\n\tint ret;\n\n\t \n\tif (unlikely(hh_len > skb_headroom(skb)) && dev->header_ops) {\n\t\tskb = skb_expand_head(skb, hh_len);\n\t\tif (!skb) {\n\t\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\thdr = ipv6_hdr(skb);\n\tdaddr = &hdr->daddr;\n\tif (ipv6_addr_is_multicast(daddr)) {\n\t\tif (!(dev->flags & IFF_LOOPBACK) && sk_mc_loop(sk) &&\n\t\t    ((mroute6_is_socket(net, skb) &&\n\t\t     !(IP6CB(skb)->flags & IP6SKB_FORWARDED)) ||\n\t\t     ipv6_chk_mcast_addr(dev, daddr, &hdr->saddr))) {\n\t\t\tstruct sk_buff *newskb = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t \n\t\t\tif (newskb)\n\t\t\t\tNF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING,\n\t\t\t\t\tnet, sk, newskb, NULL, newskb->dev,\n\t\t\t\t\tdev_loopback_xmit);\n\n\t\t\tif (hdr->hop_limit == 0) {\n\t\t\t\tIP6_INC_STATS(net, idev,\n\t\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUTMCAST, skb->len);\n\t\tif (IPV6_ADDR_MC_SCOPE(daddr) <= IPV6_ADDR_SCOPE_NODELOCAL &&\n\t\t    !(dev->flags & IFF_LOOPBACK)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (lwtunnel_xmit_redirect(dst->lwtstate)) {\n\t\tint res = lwtunnel_xmit(skb);\n\n\t\tif (res != LWTUNNEL_XMIT_CONTINUE)\n\t\t\treturn res;\n\t}\n\n\trcu_read_lock();\n\tnexthop = rt6_nexthop((struct rt6_info *)dst, daddr);\n\tneigh = __ipv6_neigh_lookup_noref(dev, nexthop);\n\n\tif (unlikely(IS_ERR_OR_NULL(neigh))) {\n\t\tif (unlikely(!neigh))\n\t\t\tneigh = __neigh_create(&nd_tbl, nexthop, dev, false);\n\t\tif (IS_ERR(neigh)) {\n\t\t\trcu_read_unlock();\n\t\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTNOROUTES);\n\t\t\tkfree_skb_reason(skb, SKB_DROP_REASON_NEIGH_CREATEFAIL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tsock_confirm_neigh(skb, neigh);\n\tret = neigh_output(neigh, skb, false);\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int\nip6_finish_output_gso_slowpath_drop(struct net *net, struct sock *sk,\n\t\t\t\t    struct sk_buff *skb, unsigned int mtu)\n{\n\tstruct sk_buff *segs, *nskb;\n\tnetdev_features_t features;\n\tint ret = 0;\n\n\t \n\tfeatures = netif_skb_features(skb);\n\tsegs = skb_gso_segment(skb, features & ~NETIF_F_GSO_MASK);\n\tif (IS_ERR_OR_NULL(segs)) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tconsume_skb(skb);\n\n\tskb_list_walk_safe(segs, segs, nskb) {\n\t\tint err;\n\n\t\tskb_mark_not_on_list(segs);\n\t\t \n\t\terr = segs->len > mtu ?\n\t\t\tip6_fragment(net, sk, segs, ip6_finish_output2) :\n\t\t\tip6_finish_output2(net, sk, segs);\n\t\tif (err && ret == 0)\n\t\t\tret = err;\n\t}\n\n\treturn ret;\n}\n\nstatic int __ip6_finish_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tunsigned int mtu;\n\n#if defined(CONFIG_NETFILTER) && defined(CONFIG_XFRM)\n\t \n\tif (skb_dst(skb)->xfrm) {\n\t\tIP6CB(skb)->flags |= IP6SKB_REROUTED;\n\t\treturn dst_output(net, sk, skb);\n\t}\n#endif\n\n\tmtu = ip6_skb_dst_mtu(skb);\n\tif (skb_is_gso(skb) &&\n\t    !(IP6CB(skb)->flags & IP6SKB_FAKEJUMBO) &&\n\t    !skb_gso_validate_network_len(skb, mtu))\n\t\treturn ip6_finish_output_gso_slowpath_drop(net, sk, skb, mtu);\n\n\tif ((skb->len > mtu && !skb_is_gso(skb)) ||\n\t    dst_allfrag(skb_dst(skb)) ||\n\t    (IP6CB(skb)->frag_max_size && skb->len > IP6CB(skb)->frag_max_size))\n\t\treturn ip6_fragment(net, sk, skb, ip6_finish_output2);\n\telse\n\t\treturn ip6_finish_output2(net, sk, skb);\n}\n\nstatic int ip6_finish_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tint ret;\n\n\tret = BPF_CGROUP_RUN_PROG_INET_EGRESS(sk, skb);\n\tswitch (ret) {\n\tcase NET_XMIT_SUCCESS:\n\tcase NET_XMIT_CN:\n\t\treturn __ip6_finish_output(net, sk, skb) ? : ret;\n\tdefault:\n\t\tkfree_skb_reason(skb, SKB_DROP_REASON_BPF_CGROUP_EGRESS);\n\t\treturn ret;\n\t}\n}\n\nint ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb_dst(skb)->dev, *indev = skb->dev;\n\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->dev = dev;\n\n\tif (unlikely(idev->cnf.disable_ipv6)) {\n\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);\n\t\tkfree_skb_reason(skb, SKB_DROP_REASON_IPV6DISABLED);\n\t\treturn 0;\n\t}\n\n\treturn NF_HOOK_COND(NFPROTO_IPV6, NF_INET_POST_ROUTING,\n\t\t\t    net, sk, skb, indev, dev,\n\t\t\t    ip6_finish_output,\n\t\t\t    !(IP6CB(skb)->flags & IP6SKB_REROUTED));\n}\nEXPORT_SYMBOL(ip6_output);\n\nbool ip6_autoflowlabel(struct net *net, const struct ipv6_pinfo *np)\n{\n\tif (!np->autoflowlabel_set)\n\t\treturn ip6_default_np_autolabel(net);\n\telse\n\t\treturn np->autoflowlabel;\n}\n\n \nint ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,\n\t     __u32 mark, struct ipv6_txoptions *opt, int tclass, u32 priority)\n{\n\tstruct net *net = sock_net(sk);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *first_hop = &fl6->daddr;\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net_device *dev = dst->dev;\n\tstruct inet6_dev *idev = ip6_dst_idev(dst);\n\tstruct hop_jumbo_hdr *hop_jumbo;\n\tint hoplen = sizeof(*hop_jumbo);\n\tunsigned int head_room;\n\tstruct ipv6hdr *hdr;\n\tu8  proto = fl6->flowi6_proto;\n\tint seg_len = skb->len;\n\tint hlimit = -1;\n\tu32 mtu;\n\n\thead_room = sizeof(struct ipv6hdr) + hoplen + LL_RESERVED_SPACE(dev);\n\tif (opt)\n\t\thead_room += opt->opt_nflen + opt->opt_flen;\n\n\tif (unlikely(head_room > skb_headroom(skb))) {\n\t\tskb = skb_expand_head(skb, head_room);\n\t\tif (!skb) {\n\t\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t}\n\n\tif (opt) {\n\t\tseg_len += opt->opt_nflen + opt->opt_flen;\n\n\t\tif (opt->opt_flen)\n\t\t\tipv6_push_frag_opts(skb, opt, &proto);\n\n\t\tif (opt->opt_nflen)\n\t\t\tipv6_push_nfrag_opts(skb, opt, &proto, &first_hop,\n\t\t\t\t\t     &fl6->saddr);\n\t}\n\n\tif (unlikely(seg_len > IPV6_MAXPLEN)) {\n\t\thop_jumbo = skb_push(skb, hoplen);\n\n\t\thop_jumbo->nexthdr = proto;\n\t\thop_jumbo->hdrlen = 0;\n\t\thop_jumbo->tlv_type = IPV6_TLV_JUMBO;\n\t\thop_jumbo->tlv_len = 4;\n\t\thop_jumbo->jumbo_payload_len = htonl(seg_len + hoplen);\n\n\t\tproto = IPPROTO_HOPOPTS;\n\t\tseg_len = 0;\n\t\tIP6CB(skb)->flags |= IP6SKB_FAKEJUMBO;\n\t}\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\thdr = ipv6_hdr(skb);\n\n\t \n\tif (np)\n\t\thlimit = np->hop_limit;\n\tif (hlimit < 0)\n\t\thlimit = ip6_dst_hoplimit(dst);\n\n\tip6_flow_hdr(hdr, tclass, ip6_make_flowlabel(net, skb, fl6->flowlabel,\n\t\t\t\tip6_autoflowlabel(net, np), fl6));\n\n\thdr->payload_len = htons(seg_len);\n\thdr->nexthdr = proto;\n\thdr->hop_limit = hlimit;\n\n\thdr->saddr = fl6->saddr;\n\thdr->daddr = *first_hop;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->priority = priority;\n\tskb->mark = mark;\n\n\tmtu = dst_mtu(dst);\n\tif ((skb->len <= mtu) || skb->ignore_df || skb_is_gso(skb)) {\n\t\tIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUT, skb->len);\n\n\t\t \n\t\tskb = l3mdev_ip6_out((struct sock *)sk, skb);\n\t\tif (unlikely(!skb))\n\t\t\treturn 0;\n\n\t\t \n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,\n\t\t\t       net, (struct sock *)sk, skb, NULL, dev,\n\t\t\t       dst_output);\n\t}\n\n\tskb->dev = dev;\n\t \n\tipv6_local_error((struct sock *)sk, EMSGSIZE, fl6, mtu);\n\n\tIP6_INC_STATS(net, idev, IPSTATS_MIB_FRAGFAILS);\n\tkfree_skb(skb);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL(ip6_xmit);\n\nstatic int ip6_call_ra_chain(struct sk_buff *skb, int sel)\n{\n\tstruct ip6_ra_chain *ra;\n\tstruct sock *last = NULL;\n\n\tread_lock(&ip6_ra_lock);\n\tfor (ra = ip6_ra_chain; ra; ra = ra->next) {\n\t\tstruct sock *sk = ra->sk;\n\t\tif (sk && ra->sel == sel &&\n\t\t    (!sk->sk_bound_dev_if ||\n\t\t     sk->sk_bound_dev_if == skb->dev->ifindex)) {\n\t\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\t\t\tif (np && np->rtalert_isolate &&\n\t\t\t    !net_eq(sock_net(sk), dev_net(skb->dev))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (last) {\n\t\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (skb2)\n\t\t\t\t\trawv6_rcv(last, skb2);\n\t\t\t}\n\t\t\tlast = sk;\n\t\t}\n\t}\n\n\tif (last) {\n\t\trawv6_rcv(last, skb);\n\t\tread_unlock(&ip6_ra_lock);\n\t\treturn 1;\n\t}\n\tread_unlock(&ip6_ra_lock);\n\treturn 0;\n}\n\nstatic int ip6_forward_proxy_check(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tu8 nexthdr = hdr->nexthdr;\n\t__be16 frag_off;\n\tint offset;\n\n\tif (ipv6_ext_hdr(nexthdr)) {\n\t\toffset = ipv6_skip_exthdr(skb, sizeof(*hdr), &nexthdr, &frag_off);\n\t\tif (offset < 0)\n\t\t\treturn 0;\n\t} else\n\t\toffset = sizeof(struct ipv6hdr);\n\n\tif (nexthdr == IPPROTO_ICMPV6) {\n\t\tstruct icmp6hdr *icmp6;\n\n\t\tif (!pskb_may_pull(skb, (skb_network_header(skb) +\n\t\t\t\t\t offset + 1 - skb->data)))\n\t\t\treturn 0;\n\n\t\ticmp6 = (struct icmp6hdr *)(skb_network_header(skb) + offset);\n\n\t\tswitch (icmp6->icmp6_type) {\n\t\tcase NDISC_ROUTER_SOLICITATION:\n\t\tcase NDISC_ROUTER_ADVERTISEMENT:\n\t\tcase NDISC_NEIGHBOUR_SOLICITATION:\n\t\tcase NDISC_NEIGHBOUR_ADVERTISEMENT:\n\t\tcase NDISC_REDIRECT:\n\t\t\t \n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ipv6_addr_type(&hdr->daddr) & IPV6_ADDR_LINKLOCAL) {\n\t\tdst_link_failure(skb);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int ip6_forward_finish(struct net *net, struct sock *sk,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\t__IP6_INC_STATS(net, ip6_dst_idev(dst), IPSTATS_MIB_OUTFORWDATAGRAMS);\n\n#ifdef CONFIG_NET_SWITCHDEV\n\tif (skb->offload_l3_fwd_mark) {\n\t\tconsume_skb(skb);\n\t\treturn 0;\n\t}\n#endif\n\n\tskb_clear_tstamp(skb);\n\treturn dst_output(net, sk, skb);\n}\n\nstatic bool ip6_pkt_too_big(const struct sk_buff *skb, unsigned int mtu)\n{\n\tif (skb->len <= mtu)\n\t\treturn false;\n\n\t \n\tif (IP6CB(skb)->frag_max_size && IP6CB(skb)->frag_max_size > mtu)\n\t\treturn true;\n\n\tif (skb->ignore_df)\n\t\treturn false;\n\n\tif (skb_is_gso(skb) && skb_gso_validate_network_len(skb, mtu))\n\t\treturn false;\n\n\treturn true;\n}\n\nint ip6_forward(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct net *net = dev_net(dst->dev);\n\tstruct inet6_dev *idev;\n\tSKB_DR(reason);\n\tu32 mtu;\n\n\tidev = __in6_dev_get_safely(dev_get_by_index_rcu(net, IP6CB(skb)->iif));\n\tif (net->ipv6.devconf_all->forwarding == 0)\n\t\tgoto error;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto drop;\n\n\tif (unlikely(skb->sk))\n\t\tgoto drop;\n\n\tif (skb_warn_if_lro(skb))\n\t\tgoto drop;\n\n\tif (!net->ipv6.devconf_all->disable_policy &&\n\t    (!idev || !idev->cnf.disable_policy) &&\n\t    !xfrm6_policy_check(NULL, XFRM_POLICY_FWD, skb)) {\n\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tskb_forward_csum(skb);\n\n\t \n\tif (unlikely(opt->flags & IP6SKB_ROUTERALERT)) {\n\t\tif (ip6_call_ra_chain(skb, ntohs(opt->ra)))\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (hdr->hop_limit <= 1) {\n\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT, 0);\n\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\n\t\tkfree_skb_reason(skb, SKB_DROP_REASON_IP_INHDR);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tif (net->ipv6.devconf_all->proxy_ndp &&\n\t    pneigh_lookup(&nd_tbl, net, &hdr->daddr, skb->dev, 0)) {\n\t\tint proxied = ip6_forward_proxy_check(skb);\n\t\tif (proxied > 0) {\n\t\t\t \n\t\t\treturn ip6_input(skb);\n\t\t} else if (proxied < 0) {\n\t\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDISCARDS);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (!xfrm6_route_forward(skb)) {\n\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDISCARDS);\n\t\tSKB_DR_SET(reason, XFRM_POLICY);\n\t\tgoto drop;\n\t}\n\tdst = skb_dst(skb);\n\n\t \n\tif (IP6CB(skb)->iif == dst->dev->ifindex &&\n\t    opt->srcrt == 0 && !skb_sec_path(skb)) {\n\t\tstruct in6_addr *target = NULL;\n\t\tstruct inet_peer *peer;\n\t\tstruct rt6_info *rt;\n\n\t\t \n\n\t\trt = (struct rt6_info *) dst;\n\t\tif (rt->rt6i_flags & RTF_GATEWAY)\n\t\t\ttarget = &rt->rt6i_gateway;\n\t\telse\n\t\t\ttarget = &hdr->daddr;\n\n\t\tpeer = inet_getpeer_v6(net->ipv6.peers, &hdr->daddr, 1);\n\n\t\t \n\t\tif (inet_peer_xrlim_allow(peer, 1*HZ))\n\t\t\tndisc_send_redirect(skb, target);\n\t\tif (peer)\n\t\t\tinet_putpeer(peer);\n\t} else {\n\t\tint addrtype = ipv6_addr_type(&hdr->saddr);\n\n\t\t \n\t\tif (addrtype == IPV6_ADDR_ANY ||\n\t\t    addrtype & (IPV6_ADDR_MULTICAST | IPV6_ADDR_LOOPBACK))\n\t\t\tgoto error;\n\t\tif (addrtype & IPV6_ADDR_LINKLOCAL) {\n\t\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH,\n\t\t\t\t    ICMPV6_NOT_NEIGHBOUR, 0);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tmtu = ip6_dst_mtu_maybe_forward(dst, true);\n\tif (mtu < IPV6_MIN_MTU)\n\t\tmtu = IPV6_MIN_MTU;\n\n\tif (ip6_pkt_too_big(skb, mtu)) {\n\t\t \n\t\tskb->dev = dst->dev;\n\t\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INTOOBIGERRORS);\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_FRAGFAILS);\n\t\tkfree_skb_reason(skb, SKB_DROP_REASON_PKT_TOO_BIG);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (skb_cow(skb, dst->dev->hard_header_len)) {\n\t\t__IP6_INC_STATS(net, ip6_dst_idev(dst),\n\t\t\t\tIPSTATS_MIB_OUTDISCARDS);\n\t\tgoto drop;\n\t}\n\n\thdr = ipv6_hdr(skb);\n\n\t \n\n\thdr->hop_limit--;\n\n\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD,\n\t\t       net, NULL, skb, skb->dev, dst->dev,\n\t\t       ip6_forward_finish);\n\nerror:\n\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INADDRERRORS);\n\tSKB_DR_SET(reason, IP_INADDRERRORS);\ndrop:\n\tkfree_skb_reason(skb, reason);\n\treturn -EINVAL;\n}\n\nstatic void ip6_copy_metadata(struct sk_buff *to, struct sk_buff *from)\n{\n\tto->pkt_type = from->pkt_type;\n\tto->priority = from->priority;\n\tto->protocol = from->protocol;\n\tskb_dst_drop(to);\n\tskb_dst_set(to, dst_clone(skb_dst(from)));\n\tto->dev = from->dev;\n\tto->mark = from->mark;\n\n\tskb_copy_hash(to, from);\n\n#ifdef CONFIG_NET_SCHED\n\tto->tc_index = from->tc_index;\n#endif\n\tnf_copy(to, from);\n\tskb_ext_copy(to, from);\n\tskb_copy_secmark(to, from);\n}\n\nint ip6_fraglist_init(struct sk_buff *skb, unsigned int hlen, u8 *prevhdr,\n\t\t      u8 nexthdr, __be32 frag_id,\n\t\t      struct ip6_fraglist_iter *iter)\n{\n\tunsigned int first_len;\n\tstruct frag_hdr *fh;\n\n\t \n\t*prevhdr = NEXTHDR_FRAGMENT;\n\titer->tmp_hdr = kmemdup(skb_network_header(skb), hlen, GFP_ATOMIC);\n\tif (!iter->tmp_hdr)\n\t\treturn -ENOMEM;\n\n\titer->frag = skb_shinfo(skb)->frag_list;\n\tskb_frag_list_init(skb);\n\n\titer->offset = 0;\n\titer->hlen = hlen;\n\titer->frag_id = frag_id;\n\titer->nexthdr = nexthdr;\n\n\t__skb_pull(skb, hlen);\n\tfh = __skb_push(skb, sizeof(struct frag_hdr));\n\t__skb_push(skb, hlen);\n\tskb_reset_network_header(skb);\n\tmemcpy(skb_network_header(skb), iter->tmp_hdr, hlen);\n\n\tfh->nexthdr = nexthdr;\n\tfh->reserved = 0;\n\tfh->frag_off = htons(IP6_MF);\n\tfh->identification = frag_id;\n\n\tfirst_len = skb_pagelen(skb);\n\tskb->data_len = first_len - skb_headlen(skb);\n\tskb->len = first_len;\n\tipv6_hdr(skb)->payload_len = htons(first_len - sizeof(struct ipv6hdr));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ip6_fraglist_init);\n\nvoid ip6_fraglist_prepare(struct sk_buff *skb,\n\t\t\t  struct ip6_fraglist_iter *iter)\n{\n\tstruct sk_buff *frag = iter->frag;\n\tunsigned int hlen = iter->hlen;\n\tstruct frag_hdr *fh;\n\n\tfrag->ip_summed = CHECKSUM_NONE;\n\tskb_reset_transport_header(frag);\n\tfh = __skb_push(frag, sizeof(struct frag_hdr));\n\t__skb_push(frag, hlen);\n\tskb_reset_network_header(frag);\n\tmemcpy(skb_network_header(frag), iter->tmp_hdr, hlen);\n\titer->offset += skb->len - hlen - sizeof(struct frag_hdr);\n\tfh->nexthdr = iter->nexthdr;\n\tfh->reserved = 0;\n\tfh->frag_off = htons(iter->offset);\n\tif (frag->next)\n\t\tfh->frag_off |= htons(IP6_MF);\n\tfh->identification = iter->frag_id;\n\tipv6_hdr(frag)->payload_len = htons(frag->len - sizeof(struct ipv6hdr));\n\tip6_copy_metadata(frag, skb);\n}\nEXPORT_SYMBOL(ip6_fraglist_prepare);\n\nvoid ip6_frag_init(struct sk_buff *skb, unsigned int hlen, unsigned int mtu,\n\t\t   unsigned short needed_tailroom, int hdr_room, u8 *prevhdr,\n\t\t   u8 nexthdr, __be32 frag_id, struct ip6_frag_state *state)\n{\n\tstate->prevhdr = prevhdr;\n\tstate->nexthdr = nexthdr;\n\tstate->frag_id = frag_id;\n\n\tstate->hlen = hlen;\n\tstate->mtu = mtu;\n\n\tstate->left = skb->len - hlen;\t \n\tstate->ptr = hlen;\t\t \n\n\tstate->hroom = hdr_room;\n\tstate->troom = needed_tailroom;\n\n\tstate->offset = 0;\n}\nEXPORT_SYMBOL(ip6_frag_init);\n\nstruct sk_buff *ip6_frag_next(struct sk_buff *skb, struct ip6_frag_state *state)\n{\n\tu8 *prevhdr = state->prevhdr, *fragnexthdr_offset;\n\tstruct sk_buff *frag;\n\tstruct frag_hdr *fh;\n\tunsigned int len;\n\n\tlen = state->left;\n\t \n\tif (len > state->mtu)\n\t\tlen = state->mtu;\n\t \n\tif (len < state->left)\n\t\tlen &= ~7;\n\n\t \n\tfrag = alloc_skb(len + state->hlen + sizeof(struct frag_hdr) +\n\t\t\t state->hroom + state->troom, GFP_ATOMIC);\n\tif (!frag)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\n\tip6_copy_metadata(frag, skb);\n\tskb_reserve(frag, state->hroom);\n\tskb_put(frag, len + state->hlen + sizeof(struct frag_hdr));\n\tskb_reset_network_header(frag);\n\tfh = (struct frag_hdr *)(skb_network_header(frag) + state->hlen);\n\tfrag->transport_header = (frag->network_header + state->hlen +\n\t\t\t\t  sizeof(struct frag_hdr));\n\n\t \n\tif (skb->sk)\n\t\tskb_set_owner_w(frag, skb->sk);\n\n\t \n\tskb_copy_from_linear_data(skb, skb_network_header(frag), state->hlen);\n\n\tfragnexthdr_offset = skb_network_header(frag);\n\tfragnexthdr_offset += prevhdr - skb_network_header(skb);\n\t*fragnexthdr_offset = NEXTHDR_FRAGMENT;\n\n\t \n\tfh->nexthdr = state->nexthdr;\n\tfh->reserved = 0;\n\tfh->identification = state->frag_id;\n\n\t \n\tBUG_ON(skb_copy_bits(skb, state->ptr, skb_transport_header(frag),\n\t\t\t     len));\n\tstate->left -= len;\n\n\tfh->frag_off = htons(state->offset);\n\tif (state->left > 0)\n\t\tfh->frag_off |= htons(IP6_MF);\n\tipv6_hdr(frag)->payload_len = htons(frag->len - sizeof(struct ipv6hdr));\n\n\tstate->ptr += len;\n\tstate->offset += len;\n\n\treturn frag;\n}\nEXPORT_SYMBOL(ip6_frag_next);\n\nint ip6_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,\n\t\t int (*output)(struct net *, struct sock *, struct sk_buff *))\n{\n\tstruct sk_buff *frag;\n\tstruct rt6_info *rt = (struct rt6_info *)skb_dst(skb);\n\tstruct ipv6_pinfo *np = skb->sk && !dev_recursion_level() ?\n\t\t\t\tinet6_sk(skb->sk) : NULL;\n\tbool mono_delivery_time = skb->mono_delivery_time;\n\tstruct ip6_frag_state state;\n\tunsigned int mtu, hlen, nexthdr_offset;\n\tktime_t tstamp = skb->tstamp;\n\tint hroom, err = 0;\n\t__be32 frag_id;\n\tu8 *prevhdr, nexthdr = 0;\n\n\terr = ip6_find_1stfragopt(skb, &prevhdr);\n\tif (err < 0)\n\t\tgoto fail;\n\thlen = err;\n\tnexthdr = *prevhdr;\n\tnexthdr_offset = prevhdr - skb_network_header(skb);\n\n\tmtu = ip6_skb_dst_mtu(skb);\n\n\t \n\tif (unlikely(!skb->ignore_df && skb->len > mtu))\n\t\tgoto fail_toobig;\n\n\tif (IP6CB(skb)->frag_max_size) {\n\t\tif (IP6CB(skb)->frag_max_size > mtu)\n\t\t\tgoto fail_toobig;\n\n\t\t \n\t\tmtu = IP6CB(skb)->frag_max_size;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t}\n\n\tif (np && np->frag_size < mtu) {\n\t\tif (np->frag_size)\n\t\t\tmtu = np->frag_size;\n\t}\n\tif (mtu < hlen + sizeof(struct frag_hdr) + 8)\n\t\tgoto fail_toobig;\n\tmtu -= hlen + sizeof(struct frag_hdr);\n\n\tfrag_id = ipv6_select_ident(net, &ipv6_hdr(skb)->daddr,\n\t\t\t\t    &ipv6_hdr(skb)->saddr);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    (err = skb_checksum_help(skb)))\n\t\tgoto fail;\n\n\tprevhdr = skb_network_header(skb) + nexthdr_offset;\n\throom = LL_RESERVED_SPACE(rt->dst.dev);\n\tif (skb_has_frag_list(skb)) {\n\t\tunsigned int first_len = skb_pagelen(skb);\n\t\tstruct ip6_fraglist_iter iter;\n\t\tstruct sk_buff *frag2;\n\n\t\tif (first_len - hlen > mtu ||\n\t\t    ((first_len - hlen) & 7) ||\n\t\t    skb_cloned(skb) ||\n\t\t    skb_headroom(skb) < (hroom + sizeof(struct frag_hdr)))\n\t\t\tgoto slow_path;\n\n\t\tskb_walk_frags(skb, frag) {\n\t\t\t \n\t\t\tif (frag->len > mtu ||\n\t\t\t    ((frag->len & 7) && frag->next) ||\n\t\t\t    skb_headroom(frag) < (hlen + hroom + sizeof(struct frag_hdr)))\n\t\t\t\tgoto slow_path_clean;\n\n\t\t\t \n\t\t\tif (skb_shared(frag))\n\t\t\t\tgoto slow_path_clean;\n\n\t\t\tBUG_ON(frag->sk);\n\t\t\tif (skb->sk) {\n\t\t\t\tfrag->sk = skb->sk;\n\t\t\t\tfrag->destructor = sock_wfree;\n\t\t\t}\n\t\t\tskb->truesize -= frag->truesize;\n\t\t}\n\n\t\terr = ip6_fraglist_init(skb, hlen, prevhdr, nexthdr, frag_id,\n\t\t\t\t\t&iter);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\n\t\t \n\t\trcu_read_lock();\n\n\t\tfor (;;) {\n\t\t\t \n\t\t\tif (iter.frag)\n\t\t\t\tip6_fraglist_prepare(skb, &iter);\n\n\t\t\tskb_set_delivery_time(skb, tstamp, mono_delivery_time);\n\t\t\terr = output(net, sk, skb);\n\t\t\tif (!err)\n\t\t\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t\t\t      IPSTATS_MIB_FRAGCREATES);\n\n\t\t\tif (err || !iter.frag)\n\t\t\t\tbreak;\n\n\t\t\tskb = ip6_fraglist_next(&iter);\n\t\t}\n\n\t\tkfree(iter.tmp_hdr);\n\n\t\tif (err == 0) {\n\t\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t\t      IPSTATS_MIB_FRAGOKS);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\n\t\tkfree_skb_list(iter.frag);\n\n\t\tIP6_INC_STATS(net, ip6_dst_idev(&rt->dst),\n\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\trcu_read_unlock();\n\t\treturn err;\n\nslow_path_clean:\n\t\tskb_walk_frags(skb, frag2) {\n\t\t\tif (frag2 == frag)\n\t\t\t\tbreak;\n\t\t\tfrag2->sk = NULL;\n\t\t\tfrag2->destructor = NULL;\n\t\t\tskb->truesize += frag2->truesize;\n\t\t}\n\t}\n\nslow_path:\n\t \n\n\tip6_frag_init(skb, hlen, mtu, rt->dst.dev->needed_tailroom,\n\t\t      LL_RESERVED_SPACE(rt->dst.dev), prevhdr, nexthdr, frag_id,\n\t\t      &state);\n\n\t \n\n\twhile (state.left > 0) {\n\t\tfrag = ip6_frag_next(skb, &state);\n\t\tif (IS_ERR(frag)) {\n\t\t\terr = PTR_ERR(frag);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\tskb_set_delivery_time(frag, tstamp, mono_delivery_time);\n\t\terr = output(net, sk, frag);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t      IPSTATS_MIB_FRAGCREATES);\n\t}\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_FRAGOKS);\n\tconsume_skb(skb);\n\treturn err;\n\nfail_toobig:\n\tif (skb->sk && dst_allfrag(skb_dst(skb)))\n\t\tsk_gso_disable(skb->sk);\n\n\ticmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\terr = -EMSGSIZE;\n\nfail:\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_FRAGFAILS);\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic inline int ip6_rt_check(const struct rt6key *rt_key,\n\t\t\t       const struct in6_addr *fl_addr,\n\t\t\t       const struct in6_addr *addr_cache)\n{\n\treturn (rt_key->plen != 128 || !ipv6_addr_equal(fl_addr, &rt_key->addr)) &&\n\t\t(!addr_cache || !ipv6_addr_equal(fl_addr, addr_cache));\n}\n\nstatic struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt;\n\n\tif (!dst)\n\t\tgoto out;\n\n\tif (dst->ops->family != AF_INET6) {\n\t\tdst_release(dst);\n\t\treturn NULL;\n\t}\n\n\trt = (struct rt6_info *)dst;\n\t \n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t   (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\nout:\n\treturn dst;\n}\n\nstatic int ip6_dst_lookup_tail(struct net *net, const struct sock *sk,\n\t\t\t       struct dst_entry **dst, struct flowi6 *fl6)\n{\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\tstruct neighbour *n;\n\tstruct rt6_info *rt;\n#endif\n\tint err;\n\tint flags = 0;\n\n\t \n\tif (ipv6_addr_any(&fl6->saddr)) {\n\t\tstruct fib6_info *from;\n\t\tstruct rt6_info *rt;\n\n\t\t*dst = ip6_route_output(net, sk, fl6);\n\t\trt = (*dst)->error ? NULL : (struct rt6_info *)*dst;\n\n\t\trcu_read_lock();\n\t\tfrom = rt ? rcu_dereference(rt->from) : NULL;\n\t\terr = ip6_route_get_saddr(net, from, &fl6->daddr,\n\t\t\t\t\t  sk ? inet6_sk(sk)->srcprefs : 0,\n\t\t\t\t\t  &fl6->saddr);\n\t\trcu_read_unlock();\n\n\t\tif (err)\n\t\t\tgoto out_err_release;\n\n\t\t \n\t\tif ((*dst)->error) {\n\t\t\tdst_release(*dst);\n\t\t\t*dst = NULL;\n\t\t}\n\n\t\tif (fl6->flowi6_oif)\n\t\t\tflags |= RT6_LOOKUP_F_IFACE;\n\t}\n\n\tif (!*dst)\n\t\t*dst = ip6_route_output_flags(net, sk, fl6, flags);\n\n\terr = (*dst)->error;\n\tif (err)\n\t\tgoto out_err_release;\n\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\t \n\trt = (struct rt6_info *) *dst;\n\trcu_read_lock();\n\tn = __ipv6_neigh_lookup_noref(rt->dst.dev,\n\t\t\t\t      rt6_nexthop(rt, &fl6->daddr));\n\terr = n && !(READ_ONCE(n->nud_state) & NUD_VALID) ? -EINVAL : 0;\n\trcu_read_unlock();\n\n\tif (err) {\n\t\tstruct inet6_ifaddr *ifp;\n\t\tstruct flowi6 fl_gw6;\n\t\tint redirect;\n\n\t\tifp = ipv6_get_ifaddr(net, &fl6->saddr,\n\t\t\t\t      (*dst)->dev, 1);\n\n\t\tredirect = (ifp && ifp->flags & IFA_F_OPTIMISTIC);\n\t\tif (ifp)\n\t\t\tin6_ifa_put(ifp);\n\n\t\tif (redirect) {\n\t\t\t \n\t\t\tdst_release(*dst);\n\t\t\tmemcpy(&fl_gw6, fl6, sizeof(struct flowi6));\n\t\t\tmemset(&fl_gw6.daddr, 0, sizeof(struct in6_addr));\n\t\t\t*dst = ip6_route_output(net, sk, &fl_gw6);\n\t\t\terr = (*dst)->error;\n\t\t\tif (err)\n\t\t\t\tgoto out_err_release;\n\t\t}\n\t}\n#endif\n\tif (ipv6_addr_v4mapped(&fl6->saddr) &&\n\t    !(ipv6_addr_v4mapped(&fl6->daddr) || ipv6_addr_any(&fl6->daddr))) {\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto out_err_release;\n\t}\n\n\treturn 0;\n\nout_err_release:\n\tdst_release(*dst);\n\t*dst = NULL;\n\n\tif (err == -ENETUNREACH)\n\t\tIP6_INC_STATS(net, NULL, IPSTATS_MIB_OUTNOROUTES);\n\treturn err;\n}\n\n \nint ip6_dst_lookup(struct net *net, struct sock *sk, struct dst_entry **dst,\n\t\t   struct flowi6 *fl6)\n{\n\t*dst = NULL;\n\treturn ip6_dst_lookup_tail(net, sk, dst, fl6);\n}\nEXPORT_SYMBOL_GPL(ip6_dst_lookup);\n\n \nstruct dst_entry *ip6_dst_lookup_flow(struct net *net, const struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t      const struct in6_addr *final_dst)\n{\n\tstruct dst_entry *dst = NULL;\n\tint err;\n\n\terr = ip6_dst_lookup_tail(net, sk, &dst, fl6);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (final_dst)\n\t\tfl6->daddr = *final_dst;\n\n\treturn xfrm_lookup_route(net, dst, flowi6_to_flowi(fl6), sk, 0);\n}\nEXPORT_SYMBOL_GPL(ip6_dst_lookup_flow);\n\n \nstruct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t\t const struct in6_addr *final_dst,\n\t\t\t\t\t bool connected)\n{\n\tstruct dst_entry *dst = sk_dst_check(sk, inet6_sk(sk)->dst_cookie);\n\n\tdst = ip6_sk_dst_check(sk, dst, fl6);\n\tif (dst)\n\t\treturn dst;\n\n\tdst = ip6_dst_lookup_flow(sock_net(sk), sk, fl6, final_dst);\n\tif (connected && !IS_ERR(dst))\n\t\tip6_sk_dst_store_flow(sk, dst_clone(dst), fl6);\n\n\treturn dst;\n}\nEXPORT_SYMBOL_GPL(ip6_sk_dst_lookup_flow);\n\n \n\nstruct dst_entry *ip6_dst_lookup_tunnel(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tstruct socket *sock,\n\t\t\t\t\tstruct in6_addr *saddr,\n\t\t\t\t\tconst struct ip_tunnel_info *info,\n\t\t\t\t\tu8 protocol,\n\t\t\t\t\tbool use_cache)\n{\n\tstruct dst_entry *dst = NULL;\n#ifdef CONFIG_DST_CACHE\n\tstruct dst_cache *dst_cache;\n#endif\n\tstruct flowi6 fl6;\n\t__u8 prio;\n\n#ifdef CONFIG_DST_CACHE\n\tdst_cache = (struct dst_cache *)&info->dst_cache;\n\tif (use_cache) {\n\t\tdst = dst_cache_get_ip6(dst_cache, saddr);\n\t\tif (dst)\n\t\t\treturn dst;\n\t}\n#endif\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_mark = skb->mark;\n\tfl6.flowi6_proto = protocol;\n\tfl6.daddr = info->key.u.ipv6.dst;\n\tfl6.saddr = info->key.u.ipv6.src;\n\tprio = info->key.tos;\n\tfl6.flowlabel = ip6_make_flowinfo(prio, info->key.label);\n\n\tdst = ipv6_stub->ipv6_dst_lookup_flow(net, sock->sk, &fl6,\n\t\t\t\t\t      NULL);\n\tif (IS_ERR(dst)) {\n\t\tnetdev_dbg(dev, \"no route to %pI6\\n\", &fl6.daddr);\n\t\treturn ERR_PTR(-ENETUNREACH);\n\t}\n\tif (dst->dev == dev) {  \n\t\tnetdev_dbg(dev, \"circular route to %pI6\\n\", &fl6.daddr);\n\t\tdst_release(dst);\n\t\treturn ERR_PTR(-ELOOP);\n\t}\n#ifdef CONFIG_DST_CACHE\n\tif (use_cache)\n\t\tdst_cache_set_ip6(dst_cache, dst, &fl6.saddr);\n#endif\n\t*saddr = fl6.saddr;\n\treturn dst;\n}\nEXPORT_SYMBOL_GPL(ip6_dst_lookup_tunnel);\n\nstatic inline struct ipv6_opt_hdr *ip6_opt_dup(struct ipv6_opt_hdr *src,\n\t\t\t\t\t       gfp_t gfp)\n{\n\treturn src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;\n}\n\nstatic inline struct ipv6_rt_hdr *ip6_rthdr_dup(struct ipv6_rt_hdr *src,\n\t\t\t\t\t\tgfp_t gfp)\n{\n\treturn src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;\n}\n\nstatic void ip6_append_data_mtu(unsigned int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt,\n\t\t\t\tunsigned int orig_mtu)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (!skb) {\n\t\t\t \n\t\t\t*mtu = orig_mtu - rt->dst.header_len;\n\n\t\t} else {\n\t\t\t \n\t\t\t*mtu = orig_mtu;\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}\n\nstatic int ip6_setup_cork(struct sock *sk, struct inet_cork_full *cork,\n\t\t\t  struct inet6_cork *v6_cork, struct ipcm6_cookie *ipc6,\n\t\t\t  struct rt6_info *rt)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tunsigned int mtu;\n\tstruct ipv6_txoptions *nopt, *opt = ipc6->opt;\n\n\t \n\tcork->base.dst = &rt->dst;\n\n\t \n\tif (opt) {\n\t\tif (WARN_ON(v6_cork->opt))\n\t\t\treturn -EINVAL;\n\n\t\tnopt = v6_cork->opt = kzalloc(sizeof(*opt), sk->sk_allocation);\n\t\tif (unlikely(!nopt))\n\t\t\treturn -ENOBUFS;\n\n\t\tnopt->tot_len = sizeof(*opt);\n\t\tnopt->opt_flen = opt->opt_flen;\n\t\tnopt->opt_nflen = opt->opt_nflen;\n\n\t\tnopt->dst0opt = ip6_opt_dup(opt->dst0opt, sk->sk_allocation);\n\t\tif (opt->dst0opt && !nopt->dst0opt)\n\t\t\treturn -ENOBUFS;\n\n\t\tnopt->dst1opt = ip6_opt_dup(opt->dst1opt, sk->sk_allocation);\n\t\tif (opt->dst1opt && !nopt->dst1opt)\n\t\t\treturn -ENOBUFS;\n\n\t\tnopt->hopopt = ip6_opt_dup(opt->hopopt, sk->sk_allocation);\n\t\tif (opt->hopopt && !nopt->hopopt)\n\t\t\treturn -ENOBUFS;\n\n\t\tnopt->srcrt = ip6_rthdr_dup(opt->srcrt, sk->sk_allocation);\n\t\tif (opt->srcrt && !nopt->srcrt)\n\t\t\treturn -ENOBUFS;\n\n\t\t \n\t}\n\tv6_cork->hop_limit = ipc6->hlimit;\n\tv6_cork->tclass = ipc6->tclass;\n\tif (rt->dst.flags & DST_XFRM_TUNNEL)\n\t\tmtu = np->pmtudisc >= IPV6_PMTUDISC_PROBE ?\n\t\t      READ_ONCE(rt->dst.dev->mtu) : dst_mtu(&rt->dst);\n\telse\n\t\tmtu = np->pmtudisc >= IPV6_PMTUDISC_PROBE ?\n\t\t\tREAD_ONCE(rt->dst.dev->mtu) : dst_mtu(xfrm_dst_path(&rt->dst));\n\tif (np->frag_size < mtu) {\n\t\tif (np->frag_size)\n\t\t\tmtu = np->frag_size;\n\t}\n\tcork->base.fragsize = mtu;\n\tcork->base.gso_size = ipc6->gso_size;\n\tcork->base.tx_flags = 0;\n\tcork->base.mark = ipc6->sockc.mark;\n\tsock_tx_timestamp(sk, ipc6->sockc.tsflags, &cork->base.tx_flags);\n\n\tif (dst_allfrag(xfrm_dst_path(&rt->dst)))\n\t\tcork->base.flags |= IPCORK_ALLFRAG;\n\tcork->base.length = 0;\n\n\tcork->base.transmit_time = ipc6->sockc.transmit_time;\n\n\treturn 0;\n}\n\nstatic int __ip6_append_data(struct sock *sk,\n\t\t\t     struct sk_buff_head *queue,\n\t\t\t     struct inet_cork_full *cork_full,\n\t\t\t     struct inet6_cork *v6_cork,\n\t\t\t     struct page_frag *pfrag,\n\t\t\t     int getfrag(void *from, char *to, int offset,\n\t\t\t\t\t int len, int odd, struct sk_buff *skb),\n\t\t\t     void *from, size_t length, int transhdrlen,\n\t\t\t     unsigned int flags, struct ipcm6_cookie *ipc6)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tstruct inet_cork *cork = &cork_full->base;\n\tstruct flowi6 *fl6 = &cork_full->fl.u.ip6;\n\tunsigned int maxfraglen, fragheaderlen, mtu, orig_mtu, pmtu;\n\tstruct ubuf_info *uarg = NULL;\n\tint exthdrlen = 0;\n\tint dst_exthdrlen = 0;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\tbool zc = false;\n\tu32 tskey = 0;\n\tstruct rt6_info *rt = (struct rt6_info *)cork->dst;\n\tstruct ipv6_txoptions *opt = v6_cork->opt;\n\tint csummode = CHECKSUM_NONE;\n\tunsigned int maxnonfragsize, headersize;\n\tunsigned int wmem_alloc_delta = 0;\n\tbool paged, extra_uref = false;\n\n\tskb = skb_peek_tail(queue);\n\tif (!skb) {\n\t\texthdrlen = opt ? opt->opt_flen : 0;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t}\n\n\tpaged = !!cork->gso_size;\n\tmtu = cork->gso_size ? IP6_MAX_MTU : cork->fragsize;\n\torig_mtu = mtu;\n\n\tif (cork->tx_flags & SKBTX_ANY_TSTAMP &&\n\t    READ_ONCE(sk->sk_tsflags) & SOF_TIMESTAMPING_OPT_ID)\n\t\ttskey = atomic_inc_return(&sk->sk_tskey) - 1;\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\n\theadersize = sizeof(struct ipv6hdr) +\n\t\t     (opt ? opt->opt_flen + opt->opt_nflen : 0) +\n\t\t     (dst_allfrag(&rt->dst) ?\n\t\t      sizeof(struct frag_hdr) : 0) +\n\t\t     rt->rt6i_nfheader_len;\n\n\tif (mtu <= fragheaderlen ||\n\t    ((mtu - fragheaderlen) & ~7) + fragheaderlen <= sizeof(struct frag_hdr))\n\t\tgoto emsgsize;\n\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen -\n\t\t     sizeof(struct frag_hdr);\n\n\t \n\tif (headersize + transhdrlen > mtu)\n\t\tgoto emsgsize;\n\n\tif (cork->length + length > mtu - headersize && ipc6->dontfrag &&\n\t    (sk->sk_protocol == IPPROTO_UDP ||\n\t     sk->sk_protocol == IPPROTO_ICMPV6 ||\n\t     sk->sk_protocol == IPPROTO_RAW)) {\n\t\tipv6_local_rxpmtu(sk, fl6, mtu - headersize +\n\t\t\t\tsizeof(struct ipv6hdr));\n\t\tgoto emsgsize;\n\t}\n\n\tif (ip6_sk_ignore_df(sk))\n\t\tmaxnonfragsize = sizeof(struct ipv6hdr) + IPV6_MAXPLEN;\n\telse\n\t\tmaxnonfragsize = mtu;\n\n\tif (cork->length + length > maxnonfragsize - headersize) {\nemsgsize:\n\t\tpmtu = max_t(int, mtu - headersize + sizeof(struct ipv6hdr), 0);\n\t\tipv6_local_error(sk, EMSGSIZE, fl6, pmtu);\n\t\treturn -EMSGSIZE;\n\t}\n\n\t \n\tif (transhdrlen && sk->sk_protocol == IPPROTO_UDP &&\n\t    headersize == sizeof(struct ipv6hdr) &&\n\t    length <= mtu - headersize &&\n\t    (!(flags & MSG_MORE) || cork->gso_size) &&\n\t    rt->dst.dev->features & (NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM))\n\t\tcsummode = CHECKSUM_PARTIAL;\n\n\tif ((flags & MSG_ZEROCOPY) && length) {\n\t\tstruct msghdr *msg = from;\n\n\t\tif (getfrag == ip_generic_getfrag && msg->msg_ubuf) {\n\t\t\tif (skb_zcopy(skb) && msg->msg_ubuf != skb_zcopy(skb))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tif ((rt->dst.dev->features & NETIF_F_SG) &&\n\t\t\t    csummode == CHECKSUM_PARTIAL) {\n\t\t\t\tpaged = true;\n\t\t\t\tzc = true;\n\t\t\t\tuarg = msg->msg_ubuf;\n\t\t\t}\n\t\t} else if (sock_flag(sk, SOCK_ZEROCOPY)) {\n\t\t\tuarg = msg_zerocopy_realloc(sk, length, skb_zcopy(skb));\n\t\t\tif (!uarg)\n\t\t\t\treturn -ENOBUFS;\n\t\t\textra_uref = !skb_zcopy(skb);\t \n\t\t\tif (rt->dst.dev->features & NETIF_F_SG &&\n\t\t\t    csummode == CHECKSUM_PARTIAL) {\n\t\t\t\tpaged = true;\n\t\t\t\tzc = true;\n\t\t\t} else {\n\t\t\t\tuarg_to_msgzc(uarg)->zerocopy = 0;\n\t\t\t\tskb_zcopy_set(skb, uarg, &extra_uref);\n\t\t\t}\n\t\t}\n\t} else if ((flags & MSG_SPLICE_PAGES) && length) {\n\t\tif (inet_test_bit(HDRINCL, sk))\n\t\t\treturn -EPERM;\n\t\tif (rt->dst.dev->features & NETIF_F_SG &&\n\t\t    getfrag == ip_generic_getfrag)\n\t\t\t \n\t\t\tpaged = true;\n\t\telse\n\t\t\tflags &= ~MSG_SPLICE_PAGES;\n\t}\n\n\t \n\n\tcork->length += length;\n\tif (!skb)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t \n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen, alloc_extra;\n\t\t\tunsigned int pagedlen;\nalloc_new_skb:\n\t\t\t \n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t \n\t\t\tif (!skb || !skb_prev)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    orig_mtu);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t \n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\t\t\tpagedlen = 0;\n\n\t\t\talloc_extra = hh_len;\n\t\t\talloc_extra += dst_exthdrlen;\n\t\t\talloc_extra += rt->dst.trailer_len;\n\n\t\t\t \n\t\t\talloc_extra += sizeof(struct frag_hdr);\n\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse if (!paged &&\n\t\t\t\t (fraglen + alloc_extra < SKB_MAX_ALLOC ||\n\t\t\t\t  !(rt->dst.dev->features & NETIF_F_SG)))\n\t\t\t\talloclen = fraglen;\n\t\t\telse {\n\t\t\t\talloclen = fragheaderlen + transhdrlen;\n\t\t\t\tpagedlen = datalen - transhdrlen;\n\t\t\t}\n\t\t\talloclen += alloc_extra;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t \n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\tcopy = datalen - transhdrlen - fraggap - pagedlen;\n\t\t\t \n\t\t\tif (copy < 0 && !(flags & MSG_SPLICE_PAGES)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk, alloclen,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (refcount_read(&sk->sk_wmem_alloc) + wmem_alloc_delta <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = alloc_skb(alloclen,\n\t\t\t\t\t\t\tsk->sk_allocation);\n\t\t\t\tif (unlikely(!skb))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t}\n\t\t\tif (!skb)\n\t\t\t\tgoto error;\n\t\t\t \n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = csummode;\n\t\t\tskb->csum = 0;\n\t\t\t \n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\t \n\t\t\tdata = skb_put(skb, fraglen - pagedlen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tif (copy > 0 &&\n\t\t\t    getfrag(from, data + transhdrlen, offset,\n\t\t\t\t    copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (flags & MSG_SPLICE_PAGES) {\n\t\t\t\tcopy = 0;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= copy + transhdrlen;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t \n\t\t\tskb_shinfo(skb)->tx_flags = cork->tx_flags;\n\t\t\tcork->tx_flags = 0;\n\t\t\tskb_shinfo(skb)->tskey = tskey;\n\t\t\ttskey = 0;\n\t\t\tskb_zcopy_set(skb, uarg, &extra_uref);\n\n\t\t\tif ((flags & MSG_CONFIRM) && !skb_prev)\n\t\t\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\t\t\t \n\t\t\tif (!skb->destructor) {\n\t\t\t\tskb->destructor = sock_wfree;\n\t\t\t\tskb->sk = sk;\n\t\t\t\twmem_alloc_delta += skb->truesize;\n\t\t\t}\n\t\t\t__skb_queue_tail(queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG) &&\n\t\t    skb_tailroom(skb) >= copy) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else if (flags & MSG_SPLICE_PAGES) {\n\t\t\tstruct msghdr *msg = from;\n\n\t\t\terr = -EIO;\n\t\t\tif (WARN_ON_ONCE(copy > msg->msg_iter.count))\n\t\t\t\tgoto error;\n\n\t\t\terr = skb_splice_from_iter(skb, &msg->msg_iter, copy,\n\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (err < 0)\n\t\t\t\tgoto error;\n\t\t\tcopy = err;\n\t\t\twmem_alloc_delta += copy;\n\t\t} else if (!zc) {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tskb_zcopy_downgrade_managed(skb);\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\twmem_alloc_delta += copy;\n\t\t} else {\n\t\t\terr = skb_zerocopy_iter_dgram(skb, from, copy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\tif (wmem_alloc_delta)\n\t\trefcount_add(wmem_alloc_delta, &sk->sk_wmem_alloc);\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tnet_zcopy_put_abort(uarg, extra_uref);\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\trefcount_add(wmem_alloc_delta, &sk->sk_wmem_alloc);\n\treturn err;\n}\n\nint ip6_append_data(struct sock *sk,\n\t\t    int getfrag(void *from, char *to, int offset, int len,\n\t\t\t\tint odd, struct sk_buff *skb),\n\t\t    void *from, size_t length, int transhdrlen,\n\t\t    struct ipcm6_cookie *ipc6, struct flowi6 *fl6,\n\t\t    struct rt6_info *rt, unsigned int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tint exthdrlen;\n\tint err;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t \n\t\tdst_hold(&rt->dst);\n\t\terr = ip6_setup_cork(sk, &inet->cork, &np->cork,\n\t\t\t\t     ipc6, rt);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tinet->cork.fl.u.ip6 = *fl6;\n\t\texthdrlen = (ipc6->opt ? ipc6->opt->opt_flen : 0);\n\t\tlength += exthdrlen;\n\t\ttranshdrlen += exthdrlen;\n\t} else {\n\t\ttranshdrlen = 0;\n\t}\n\n\treturn __ip6_append_data(sk, &sk->sk_write_queue, &inet->cork,\n\t\t\t\t &np->cork, sk_page_frag(sk), getfrag,\n\t\t\t\t from, length, transhdrlen, flags, ipc6);\n}\nEXPORT_SYMBOL_GPL(ip6_append_data);\n\nstatic void ip6_cork_steal_dst(struct sk_buff *skb, struct inet_cork_full *cork)\n{\n\tstruct dst_entry *dst = cork->base.dst;\n\n\tcork->base.dst = NULL;\n\tcork->base.flags &= ~IPCORK_ALLFRAG;\n\tskb_dst_set(skb, dst);\n}\n\nstatic void ip6_cork_release(struct inet_cork_full *cork,\n\t\t\t     struct inet6_cork *v6_cork)\n{\n\tif (v6_cork->opt) {\n\t\tstruct ipv6_txoptions *opt = v6_cork->opt;\n\n\t\tkfree(opt->dst0opt);\n\t\tkfree(opt->dst1opt);\n\t\tkfree(opt->hopopt);\n\t\tkfree(opt->srcrt);\n\t\tkfree(opt);\n\t\tv6_cork->opt = NULL;\n\t}\n\n\tif (cork->base.dst) {\n\t\tdst_release(cork->base.dst);\n\t\tcork->base.dst = NULL;\n\t\tcork->base.flags &= ~IPCORK_ALLFRAG;\n\t}\n}\n\nstruct sk_buff *__ip6_make_skb(struct sock *sk,\n\t\t\t       struct sk_buff_head *queue,\n\t\t\t       struct inet_cork_full *cork,\n\t\t\t       struct inet6_cork *v6_cork)\n{\n\tstruct sk_buff *skb, *tmp_skb;\n\tstruct sk_buff **tail_skb;\n\tstruct in6_addr *final_dst;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6hdr *hdr;\n\tstruct ipv6_txoptions *opt = v6_cork->opt;\n\tstruct rt6_info *rt = (struct rt6_info *)cork->base.dst;\n\tstruct flowi6 *fl6 = &cork->fl.u.ip6;\n\tunsigned char proto = fl6->flowi6_proto;\n\n\tskb = __skb_dequeue(queue);\n\tif (!skb)\n\t\tgoto out;\n\ttail_skb = &(skb_shinfo(skb)->frag_list);\n\n\t \n\tif (skb->data < skb_network_header(skb))\n\t\t__skb_pull(skb, skb_network_offset(skb));\n\twhile ((tmp_skb = __skb_dequeue(queue)) != NULL) {\n\t\t__skb_pull(tmp_skb, skb_network_header_len(skb));\n\t\t*tail_skb = tmp_skb;\n\t\ttail_skb = &(tmp_skb->next);\n\t\tskb->len += tmp_skb->len;\n\t\tskb->data_len += tmp_skb->len;\n\t\tskb->truesize += tmp_skb->truesize;\n\t\ttmp_skb->destructor = NULL;\n\t\ttmp_skb->sk = NULL;\n\t}\n\n\t \n\tskb->ignore_df = ip6_sk_ignore_df(sk);\n\t__skb_pull(skb, skb_network_header_len(skb));\n\n\tfinal_dst = &fl6->daddr;\n\tif (opt && opt->opt_flen)\n\t\tipv6_push_frag_opts(skb, opt, &proto);\n\tif (opt && opt->opt_nflen)\n\t\tipv6_push_nfrag_opts(skb, opt, &proto, &final_dst, &fl6->saddr);\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\thdr = ipv6_hdr(skb);\n\n\tip6_flow_hdr(hdr, v6_cork->tclass,\n\t\t     ip6_make_flowlabel(net, skb, fl6->flowlabel,\n\t\t\t\t\tip6_autoflowlabel(net, np), fl6));\n\thdr->hop_limit = v6_cork->hop_limit;\n\thdr->nexthdr = proto;\n\thdr->saddr = fl6->saddr;\n\thdr->daddr = *final_dst;\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = cork->base.mark;\n\tskb->tstamp = cork->base.transmit_time;\n\n\tip6_cork_steal_dst(skb, cork);\n\tIP6_UPD_PO_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUT, skb->len);\n\tif (proto == IPPROTO_ICMPV6) {\n\t\tstruct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));\n\t\tu8 icmp6_type;\n\n\t\tif (sk->sk_socket->type == SOCK_RAW &&\n\t\t   !inet_test_bit(HDRINCL, sk))\n\t\t\ticmp6_type = fl6->fl6_icmp_type;\n\t\telse\n\t\t\ticmp6_type = icmp6_hdr(skb)->icmp6_type;\n\t\tICMP6MSGOUT_INC_STATS(net, idev, icmp6_type);\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);\n\t}\n\n\tip6_cork_release(cork, v6_cork);\nout:\n\treturn skb;\n}\n\nint ip6_send_skb(struct sk_buff *skb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct rt6_info *rt = (struct rt6_info *)skb_dst(skb);\n\tint err;\n\n\terr = ip6_local_out(net, skb->sk, skb);\n\tif (err) {\n\t\tif (err > 0)\n\t\t\terr = net_xmit_errno(err);\n\t\tif (err)\n\t\t\tIP6_INC_STATS(net, rt->rt6i_idev,\n\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t}\n\n\treturn err;\n}\n\nint ip6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\tskb = ip6_finish_skb(sk);\n\tif (!skb)\n\t\treturn 0;\n\n\treturn ip6_send_skb(skb);\n}\nEXPORT_SYMBOL_GPL(ip6_push_pending_frames);\n\nstatic void __ip6_flush_pending_frames(struct sock *sk,\n\t\t\t\t       struct sk_buff_head *queue,\n\t\t\t\t       struct inet_cork_full *cork,\n\t\t\t\t       struct inet6_cork *v6_cork)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue_tail(queue)) != NULL) {\n\t\tif (skb_dst(skb))\n\t\t\tIP6_INC_STATS(sock_net(sk), ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\tkfree_skb(skb);\n\t}\n\n\tip6_cork_release(cork, v6_cork);\n}\n\nvoid ip6_flush_pending_frames(struct sock *sk)\n{\n\t__ip6_flush_pending_frames(sk, &sk->sk_write_queue,\n\t\t\t\t   &inet_sk(sk)->cork, &inet6_sk(sk)->cork);\n}\nEXPORT_SYMBOL_GPL(ip6_flush_pending_frames);\n\nstruct sk_buff *ip6_make_skb(struct sock *sk,\n\t\t\t     int getfrag(void *from, char *to, int offset,\n\t\t\t\t\t int len, int odd, struct sk_buff *skb),\n\t\t\t     void *from, size_t length, int transhdrlen,\n\t\t\t     struct ipcm6_cookie *ipc6, struct rt6_info *rt,\n\t\t\t     unsigned int flags, struct inet_cork_full *cork)\n{\n\tstruct inet6_cork v6_cork;\n\tstruct sk_buff_head queue;\n\tint exthdrlen = (ipc6->opt ? ipc6->opt->opt_flen : 0);\n\tint err;\n\n\tif (flags & MSG_PROBE) {\n\t\tdst_release(&rt->dst);\n\t\treturn NULL;\n\t}\n\n\t__skb_queue_head_init(&queue);\n\n\tcork->base.flags = 0;\n\tcork->base.addr = 0;\n\tcork->base.opt = NULL;\n\tv6_cork.opt = NULL;\n\terr = ip6_setup_cork(sk, cork, &v6_cork, ipc6, rt);\n\tif (err) {\n\t\tip6_cork_release(cork, &v6_cork);\n\t\treturn ERR_PTR(err);\n\t}\n\tif (ipc6->dontfrag < 0)\n\t\tipc6->dontfrag = inet6_sk(sk)->dontfrag;\n\n\terr = __ip6_append_data(sk, &queue, cork, &v6_cork,\n\t\t\t\t&current->task_frag, getfrag, from,\n\t\t\t\tlength + exthdrlen, transhdrlen + exthdrlen,\n\t\t\t\tflags, ipc6);\n\tif (err) {\n\t\t__ip6_flush_pending_frames(sk, &queue, cork, &v6_cork);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn __ip6_make_skb(sk, &queue, cork, &v6_cork);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}