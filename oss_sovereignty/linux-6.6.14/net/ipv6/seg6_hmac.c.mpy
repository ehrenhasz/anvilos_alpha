{
  "module_name": "seg6_hmac.c",
  "hash_id": "6175cfded37b4b4fe00bcd67880f086887729bac3cd7caeb60b74371e8209717",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/seg6_hmac.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/icmpv6.h>\n#include <linux/mroute6.h>\n#include <linux/slab.h>\n#include <linux/rhashtable.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/rawv6.h>\n#include <net/ndisc.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/xfrm.h>\n\n#include <crypto/hash.h>\n#include <net/seg6.h>\n#include <net/genetlink.h>\n#include <net/seg6_hmac.h>\n#include <linux/random.h>\n\nstatic DEFINE_PER_CPU(char [SEG6_HMAC_RING_SIZE], hmac_ring);\n\nstatic int seg6_hmac_cmpfn(struct rhashtable_compare_arg *arg, const void *obj)\n{\n\tconst struct seg6_hmac_info *hinfo = obj;\n\n\treturn (hinfo->hmackeyid != *(__u32 *)arg->key);\n}\n\nstatic inline void seg6_hinfo_release(struct seg6_hmac_info *hinfo)\n{\n\tkfree_rcu(hinfo, rcu);\n}\n\nstatic void seg6_free_hi(void *ptr, void *arg)\n{\n\tstruct seg6_hmac_info *hinfo = (struct seg6_hmac_info *)ptr;\n\n\tif (hinfo)\n\t\tseg6_hinfo_release(hinfo);\n}\n\nstatic const struct rhashtable_params rht_params = {\n\t.head_offset\t\t= offsetof(struct seg6_hmac_info, node),\n\t.key_offset\t\t= offsetof(struct seg6_hmac_info, hmackeyid),\n\t.key_len\t\t= sizeof(u32),\n\t.automatic_shrinking\t= true,\n\t.obj_cmpfn\t\t= seg6_hmac_cmpfn,\n};\n\nstatic struct seg6_hmac_algo hmac_algos[] = {\n\t{\n\t\t.alg_id = SEG6_HMAC_ALGO_SHA1,\n\t\t.name = \"hmac(sha1)\",\n\t},\n\t{\n\t\t.alg_id = SEG6_HMAC_ALGO_SHA256,\n\t\t.name = \"hmac(sha256)\",\n\t},\n};\n\nstatic struct sr6_tlv_hmac *seg6_get_tlv_hmac(struct ipv6_sr_hdr *srh)\n{\n\tstruct sr6_tlv_hmac *tlv;\n\n\tif (srh->hdrlen < (srh->first_segment + 1) * 2 + 5)\n\t\treturn NULL;\n\n\tif (!sr_has_hmac(srh))\n\t\treturn NULL;\n\n\ttlv = (struct sr6_tlv_hmac *)\n\t      ((char *)srh + ((srh->hdrlen + 1) << 3) - 40);\n\n\tif (tlv->tlvhdr.type != SR6_TLV_HMAC || tlv->tlvhdr.len != 38)\n\t\treturn NULL;\n\n\treturn tlv;\n}\n\nstatic struct seg6_hmac_algo *__hmac_get_algo(u8 alg_id)\n{\n\tstruct seg6_hmac_algo *algo;\n\tint i, alg_count;\n\n\talg_count = ARRAY_SIZE(hmac_algos);\n\tfor (i = 0; i < alg_count; i++) {\n\t\talgo = &hmac_algos[i];\n\t\tif (algo->alg_id == alg_id)\n\t\t\treturn algo;\n\t}\n\n\treturn NULL;\n}\n\nstatic int __do_hmac(struct seg6_hmac_info *hinfo, const char *text, u8 psize,\n\t\t     u8 *output, int outlen)\n{\n\tstruct seg6_hmac_algo *algo;\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *shash;\n\tint ret, dgsize;\n\n\talgo = __hmac_get_algo(hinfo->alg_id);\n\tif (!algo)\n\t\treturn -ENOENT;\n\n\ttfm = *this_cpu_ptr(algo->tfms);\n\n\tdgsize = crypto_shash_digestsize(tfm);\n\tif (dgsize > outlen) {\n\t\tpr_debug(\"sr-ipv6: __do_hmac: digest size too big (%d / %d)\\n\",\n\t\t\t dgsize, outlen);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = crypto_shash_setkey(tfm, hinfo->secret, hinfo->slen);\n\tif (ret < 0) {\n\t\tpr_debug(\"sr-ipv6: crypto_shash_setkey failed: err %d\\n\", ret);\n\t\tgoto failed;\n\t}\n\n\tshash = *this_cpu_ptr(algo->shashs);\n\tshash->tfm = tfm;\n\n\tret = crypto_shash_digest(shash, text, psize, output);\n\tif (ret < 0) {\n\t\tpr_debug(\"sr-ipv6: crypto_shash_digest failed: err %d\\n\", ret);\n\t\tgoto failed;\n\t}\n\n\treturn dgsize;\n\nfailed:\n\treturn ret;\n}\n\nint seg6_hmac_compute(struct seg6_hmac_info *hinfo, struct ipv6_sr_hdr *hdr,\n\t\t      struct in6_addr *saddr, u8 *output)\n{\n\t__be32 hmackeyid = cpu_to_be32(hinfo->hmackeyid);\n\tu8 tmp_out[SEG6_HMAC_MAX_DIGESTSIZE];\n\tint plen, i, dgsize, wrsize;\n\tchar *ring, *off;\n\n\t \n\n\t \n\tplen = 16 + 1 + 1 + 4 + (hdr->first_segment + 1) * 16;\n\n\t \n\tif (plen >= SEG6_HMAC_RING_SIZE)\n\t\treturn -EMSGSIZE;\n\n\t \n\n\tlocal_bh_disable();\n\tring = this_cpu_ptr(hmac_ring);\n\toff = ring;\n\n\t \n\tmemcpy(off, saddr, 16);\n\toff += 16;\n\n\t \n\t*off++ = hdr->first_segment;\n\n\t \n\t*off++ = hdr->flags;\n\n\t \n\tmemcpy(off, &hmackeyid, 4);\n\toff += 4;\n\n\t \n\tfor (i = 0; i < hdr->first_segment + 1; i++) {\n\t\tmemcpy(off, hdr->segments + i, 16);\n\t\toff += 16;\n\t}\n\n\tdgsize = __do_hmac(hinfo, ring, plen, tmp_out,\n\t\t\t   SEG6_HMAC_MAX_DIGESTSIZE);\n\tlocal_bh_enable();\n\n\tif (dgsize < 0)\n\t\treturn dgsize;\n\n\twrsize = SEG6_HMAC_FIELD_LEN;\n\tif (wrsize > dgsize)\n\t\twrsize = dgsize;\n\n\tmemset(output, 0, SEG6_HMAC_FIELD_LEN);\n\tmemcpy(output, tmp_out, wrsize);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(seg6_hmac_compute);\n\n \nbool seg6_hmac_validate_skb(struct sk_buff *skb)\n{\n\tu8 hmac_output[SEG6_HMAC_FIELD_LEN];\n\tstruct net *net = dev_net(skb->dev);\n\tstruct seg6_hmac_info *hinfo;\n\tstruct sr6_tlv_hmac *tlv;\n\tstruct ipv6_sr_hdr *srh;\n\tstruct inet6_dev *idev;\n\n\tidev = __in6_dev_get(skb->dev);\n\n\tsrh = (struct ipv6_sr_hdr *)skb_transport_header(skb);\n\n\ttlv = seg6_get_tlv_hmac(srh);\n\n\t \n\tif (idev->cnf.seg6_require_hmac > 0 && !tlv)\n\t\treturn false;\n\n\t \n\tif (idev->cnf.seg6_require_hmac < 0)\n\t\treturn true;\n\n\t \n\tif (idev->cnf.seg6_require_hmac == 0 && !tlv)\n\t\treturn true;\n\n\t \n\n\thinfo = seg6_hmac_info_lookup(net, be32_to_cpu(tlv->hmackeyid));\n\tif (!hinfo)\n\t\treturn false;\n\n\tif (seg6_hmac_compute(hinfo, srh, &ipv6_hdr(skb)->saddr, hmac_output))\n\t\treturn false;\n\n\tif (memcmp(hmac_output, tlv->hmac, SEG6_HMAC_FIELD_LEN) != 0)\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(seg6_hmac_validate_skb);\n\n \nstruct seg6_hmac_info *seg6_hmac_info_lookup(struct net *net, u32 key)\n{\n\tstruct seg6_pernet_data *sdata = seg6_pernet(net);\n\tstruct seg6_hmac_info *hinfo;\n\n\thinfo = rhashtable_lookup_fast(&sdata->hmac_infos, &key, rht_params);\n\n\treturn hinfo;\n}\nEXPORT_SYMBOL(seg6_hmac_info_lookup);\n\nint seg6_hmac_info_add(struct net *net, u32 key, struct seg6_hmac_info *hinfo)\n{\n\tstruct seg6_pernet_data *sdata = seg6_pernet(net);\n\tint err;\n\n\terr = rhashtable_lookup_insert_fast(&sdata->hmac_infos, &hinfo->node,\n\t\t\t\t\t    rht_params);\n\n\treturn err;\n}\nEXPORT_SYMBOL(seg6_hmac_info_add);\n\nint seg6_hmac_info_del(struct net *net, u32 key)\n{\n\tstruct seg6_pernet_data *sdata = seg6_pernet(net);\n\tstruct seg6_hmac_info *hinfo;\n\tint err = -ENOENT;\n\n\thinfo = rhashtable_lookup_fast(&sdata->hmac_infos, &key, rht_params);\n\tif (!hinfo)\n\t\tgoto out;\n\n\terr = rhashtable_remove_fast(&sdata->hmac_infos, &hinfo->node,\n\t\t\t\t     rht_params);\n\tif (err)\n\t\tgoto out;\n\n\tseg6_hinfo_release(hinfo);\n\nout:\n\treturn err;\n}\nEXPORT_SYMBOL(seg6_hmac_info_del);\n\nint seg6_push_hmac(struct net *net, struct in6_addr *saddr,\n\t\t   struct ipv6_sr_hdr *srh)\n{\n\tstruct seg6_hmac_info *hinfo;\n\tstruct sr6_tlv_hmac *tlv;\n\tint err = -ENOENT;\n\n\ttlv = seg6_get_tlv_hmac(srh);\n\tif (!tlv)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\n\thinfo = seg6_hmac_info_lookup(net, be32_to_cpu(tlv->hmackeyid));\n\tif (!hinfo)\n\t\tgoto out;\n\n\tmemset(tlv->hmac, 0, SEG6_HMAC_FIELD_LEN);\n\terr = seg6_hmac_compute(hinfo, srh, saddr, tlv->hmac);\n\nout:\n\trcu_read_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL(seg6_push_hmac);\n\nstatic int seg6_hmac_init_algo(void)\n{\n\tstruct seg6_hmac_algo *algo;\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *shash;\n\tint i, alg_count, cpu;\n\n\talg_count = ARRAY_SIZE(hmac_algos);\n\n\tfor (i = 0; i < alg_count; i++) {\n\t\tstruct crypto_shash **p_tfm;\n\t\tint shsize;\n\n\t\talgo = &hmac_algos[i];\n\t\talgo->tfms = alloc_percpu(struct crypto_shash *);\n\t\tif (!algo->tfms)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\ttfm = crypto_alloc_shash(algo->name, 0, 0);\n\t\t\tif (IS_ERR(tfm))\n\t\t\t\treturn PTR_ERR(tfm);\n\t\t\tp_tfm = per_cpu_ptr(algo->tfms, cpu);\n\t\t\t*p_tfm = tfm;\n\t\t}\n\n\t\tp_tfm = raw_cpu_ptr(algo->tfms);\n\t\ttfm = *p_tfm;\n\n\t\tshsize = sizeof(*shash) + crypto_shash_descsize(tfm);\n\n\t\talgo->shashs = alloc_percpu(struct shash_desc *);\n\t\tif (!algo->shashs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tshash = kzalloc_node(shsize, GFP_KERNEL,\n\t\t\t\t\t     cpu_to_node(cpu));\n\t\t\tif (!shash)\n\t\t\t\treturn -ENOMEM;\n\t\t\t*per_cpu_ptr(algo->shashs, cpu) = shash;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint __init seg6_hmac_init(void)\n{\n\treturn seg6_hmac_init_algo();\n}\n\nint __net_init seg6_hmac_net_init(struct net *net)\n{\n\tstruct seg6_pernet_data *sdata = seg6_pernet(net);\n\n\treturn rhashtable_init(&sdata->hmac_infos, &rht_params);\n}\n\nvoid seg6_hmac_exit(void)\n{\n\tstruct seg6_hmac_algo *algo = NULL;\n\tint i, alg_count, cpu;\n\n\talg_count = ARRAY_SIZE(hmac_algos);\n\tfor (i = 0; i < alg_count; i++) {\n\t\talgo = &hmac_algos[i];\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct crypto_shash *tfm;\n\t\t\tstruct shash_desc *shash;\n\n\t\t\tshash = *per_cpu_ptr(algo->shashs, cpu);\n\t\t\tkfree(shash);\n\t\t\ttfm = *per_cpu_ptr(algo->tfms, cpu);\n\t\t\tcrypto_free_shash(tfm);\n\t\t}\n\t\tfree_percpu(algo->tfms);\n\t\tfree_percpu(algo->shashs);\n\t}\n}\nEXPORT_SYMBOL(seg6_hmac_exit);\n\nvoid __net_exit seg6_hmac_net_exit(struct net *net)\n{\n\tstruct seg6_pernet_data *sdata = seg6_pernet(net);\n\n\trhashtable_free_and_destroy(&sdata->hmac_infos, seg6_free_hi, NULL);\n}\nEXPORT_SYMBOL(seg6_hmac_net_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}