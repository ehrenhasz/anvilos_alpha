{
  "module_name": "datagram.c",
  "hash_id": "396ffe1a2ef51ab7e780c4f78cb4df345bba82090766891d09da27bf34108238",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/datagram.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/route.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/icmp.h>\n\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/tcp_states.h>\n#include <net/dsfield.h>\n#include <net/sock_reuseport.h>\n\n#include <linux/errqueue.h>\n#include <linux/uaccess.h>\n\nstatic bool ipv6_mapped_addr_any(const struct in6_addr *a)\n{\n\treturn ipv6_addr_v4mapped(a) && (a->s6_addr32[3] == 0);\n}\n\nstatic void ip6_datagram_flow_key_init(struct flowi6 *fl6,\n\t\t\t\t       const struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tint oif = sk->sk_bound_dev_if;\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_dport = inet->inet_dport;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->flowlabel = ip6_make_flowinfo(np->tclass, np->flow_label);\n\tfl6->flowi6_uid = sk->sk_uid;\n\n\tif (!oif)\n\t\toif = np->sticky_pktinfo.ipi6_ifindex;\n\n\tif (!oif) {\n\t\tif (ipv6_addr_is_multicast(&fl6->daddr))\n\t\t\toif = np->mcast_oif;\n\t\telse\n\t\t\toif = np->ucast_oif;\n\t}\n\n\tfl6->flowi6_oif = oif;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi_common(fl6));\n}\n\nint ip6_datagram_dst_update(struct sock *sk, bool fix_sk_saddr)\n{\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct in6_addr *final_p, final;\n\tstruct ipv6_txoptions *opt;\n\tstruct dst_entry *dst;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tint err = 0;\n\n\tif (np->sndflow && (np->flow_label & IPV6_FLOWLABEL_MASK)) {\n\t\tflowlabel = fl6_sock_lookup(sk, np->flow_label);\n\t\tif (IS_ERR(flowlabel))\n\t\t\treturn -EINVAL;\n\t}\n\tip6_datagram_flow_key_init(&fl6, sk);\n\n\trcu_read_lock();\n\topt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\trcu_read_unlock();\n\n\tdst = ip6_dst_lookup_flow(sock_net(sk), sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto out;\n\t}\n\n\tif (fix_sk_saddr) {\n\t\tif (ipv6_addr_any(&np->saddr))\n\t\t\tnp->saddr = fl6.saddr;\n\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {\n\t\t\tsk->sk_v6_rcv_saddr = fl6.saddr;\n\t\t\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\t\t\tif (sk->sk_prot->rehash)\n\t\t\t\tsk->sk_prot->rehash(sk);\n\t\t}\n\t}\n\n\tip6_sk_dst_store_flow(sk, dst, &fl6);\n\nout:\n\tfl6_sock_release(flowlabel);\n\treturn err;\n}\n\nvoid ip6_datagram_release_cb(struct sock *sk)\n{\n\tstruct dst_entry *dst;\n\n\tif (ipv6_addr_v4mapped(&sk->sk_v6_daddr))\n\t\treturn;\n\n\trcu_read_lock();\n\tdst = __sk_dst_get(sk);\n\tif (!dst || !dst->obsolete ||\n\t    dst->ops->check(dst, inet6_sk(sk)->dst_cookie)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\n\tip6_datagram_dst_update(sk, false);\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_release_cb);\n\nint __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t   int addr_len)\n{\n\tstruct sockaddr_in6\t*usin = (struct sockaddr_in6 *) uaddr;\n\tstruct inet_sock\t*inet = inet_sk(sk);\n\tstruct ipv6_pinfo\t*np = inet6_sk(sk);\n\tstruct in6_addr\t\t*daddr, old_daddr;\n\t__be32\t\t\tfl6_flowlabel = 0;\n\t__be32\t\t\told_fl6_flowlabel;\n\t__be16\t\t\told_dport;\n\tint\t\t\taddr_type;\n\tint\t\t\terr;\n\n\tif (usin->sin6_family == AF_INET) {\n\t\tif (ipv6_only_sock(sk))\n\t\t\treturn -EAFNOSUPPORT;\n\t\terr = __ip4_datagram_connect(sk, uaddr, addr_len);\n\t\tgoto ipv4_connected;\n\t}\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tif (np->sndflow)\n\t\tfl6_flowlabel = usin->sin6_flowinfo & IPV6_FLOWINFO_MASK;\n\n\tif (ipv6_addr_any(&usin->sin6_addr)) {\n\t\t \n\t\tif (ipv6_addr_v4mapped(&sk->sk_v6_rcv_saddr))\n\t\t\tipv6_addr_set_v4mapped(htonl(INADDR_LOOPBACK),\n\t\t\t\t\t       &usin->sin6_addr);\n\t\telse\n\t\t\tusin->sin6_addr = in6addr_loopback;\n\t}\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tdaddr = &usin->sin6_addr;\n\n\tif (addr_type & IPV6_ADDR_MAPPED) {\n\t\tstruct sockaddr_in sin;\n\n\t\tif (ipv6_only_sock(sk)) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out;\n\t\t}\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\tsin.sin_port = usin->sin6_port;\n\n\t\terr = __ip4_datagram_connect(sk,\n\t\t\t\t\t     (struct sockaddr *) &sin,\n\t\t\t\t\t     sizeof(sin));\n\nipv4_connected:\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tipv6_addr_set_v4mapped(inet->inet_daddr, &sk->sk_v6_daddr);\n\n\t\tif (ipv6_addr_any(&np->saddr) ||\n\t\t    ipv6_mapped_addr_any(&np->saddr))\n\t\t\tipv6_addr_set_v4mapped(inet->inet_saddr, &np->saddr);\n\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr) ||\n\t\t    ipv6_mapped_addr_any(&sk->sk_v6_rcv_saddr)) {\n\t\t\tipv6_addr_set_v4mapped(inet->inet_rcv_saddr,\n\t\t\t\t\t       &sk->sk_v6_rcv_saddr);\n\t\t\tif (sk->sk_prot->rehash)\n\t\t\t\tsk->sk_prot->rehash(sk);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (__ipv6_addr_needs_scope_id(addr_type)) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\tif (!sk_dev_equal_l3scope(sk, usin->sin6_scope_id)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tWRITE_ONCE(sk->sk_bound_dev_if, usin->sin6_scope_id);\n\t\t}\n\n\t\tif (!sk->sk_bound_dev_if && (addr_type & IPV6_ADDR_MULTICAST))\n\t\t\tWRITE_ONCE(sk->sk_bound_dev_if, np->mcast_oif);\n\n\t\t \n\t\tif (!sk->sk_bound_dev_if) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\told_daddr = sk->sk_v6_daddr;\n\told_fl6_flowlabel = np->flow_label;\n\told_dport = inet->inet_dport;\n\n\tsk->sk_v6_daddr = *daddr;\n\tnp->flow_label = fl6_flowlabel;\n\tinet->inet_dport = usin->sin6_port;\n\n\t \n\n\terr = ip6_datagram_dst_update(sk, true);\n\tif (err) {\n\t\t \n\t\tsk->sk_v6_daddr = old_daddr;\n\t\tnp->flow_label = old_fl6_flowlabel;\n\t\tinet->inet_dport = old_dport;\n\t\tgoto out;\n\t}\n\n\treuseport_has_conns_set(sk);\n\tsk->sk_state = TCP_ESTABLISHED;\n\tsk_set_txhash(sk);\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(__ip6_datagram_connect);\n\nint ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tint res;\n\n\tlock_sock(sk);\n\tres = __ip6_datagram_connect(sk, uaddr, addr_len);\n\trelease_sock(sk);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_connect);\n\nint ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t\t int addr_len)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, uaddr);\n\tif (sin6->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\treturn ip6_datagram_connect(sk, uaddr, addr_len);\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_connect_v6_only);\n\nstatic void ipv6_icmp_error_rfc4884(const struct sk_buff *skb,\n\t\t\t\t    struct sock_ee_data_rfc4884 *out)\n{\n\tswitch (icmp6_hdr(skb)->icmp6_type) {\n\tcase ICMPV6_TIME_EXCEED:\n\tcase ICMPV6_DEST_UNREACH:\n\t\tip_icmp_error_rfc4884(skb, out, sizeof(struct icmp6hdr),\n\t\t\t\t      icmp6_hdr(skb)->icmp6_datagram_len * 8);\n\t}\n}\n\nvoid ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,\n\t\t     __be16 port, u32 info, u8 *payload)\n{\n\tstruct ipv6_pinfo *np  = inet6_sk(sk);\n\tstruct icmp6hdr *icmph = icmp6_hdr(skb);\n\tstruct sock_exterr_skb *serr;\n\n\tif (!np->recverr)\n\t\treturn;\n\n\tskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\tserr = SKB_EXT_ERR(skb);\n\tserr->ee.ee_errno = err;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_ICMP6;\n\tserr->ee.ee_type = icmph->icmp6_type;\n\tserr->ee.ee_code = icmph->icmp6_code;\n\tserr->ee.ee_pad = 0;\n\tserr->ee.ee_info = info;\n\tserr->ee.ee_data = 0;\n\tserr->addr_offset = (u8 *)&(((struct ipv6hdr *)(icmph + 1))->daddr) -\n\t\t\t\t  skb_network_header(skb);\n\tserr->port = port;\n\n\t__skb_pull(skb, payload - skb->data);\n\n\tif (inet6_sk(sk)->recverr_rfc4884)\n\t\tipv6_icmp_error_rfc4884(skb, &serr->ee.ee_rfc4884);\n\n\tskb_reset_transport_header(skb);\n\n\tif (sock_queue_err_skb(sk, skb))\n\t\tkfree_skb(skb);\n}\nEXPORT_SYMBOL_GPL(ipv6_icmp_error);\n\nvoid ipv6_local_error(struct sock *sk, int err, struct flowi6 *fl6, u32 info)\n{\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sock_exterr_skb *serr;\n\tstruct ipv6hdr *iph;\n\tstruct sk_buff *skb;\n\n\tif (!np->recverr)\n\t\treturn;\n\n\tskb = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\n\tskb_put(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tiph = ipv6_hdr(skb);\n\tiph->daddr = fl6->daddr;\n\tip6_flow_hdr(iph, 0, 0);\n\n\tserr = SKB_EXT_ERR(skb);\n\tserr->ee.ee_errno = err;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_LOCAL;\n\tserr->ee.ee_type = 0;\n\tserr->ee.ee_code = 0;\n\tserr->ee.ee_pad = 0;\n\tserr->ee.ee_info = info;\n\tserr->ee.ee_data = 0;\n\tserr->addr_offset = (u8 *)&iph->daddr - skb_network_header(skb);\n\tserr->port = fl6->fl6_dport;\n\n\t__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\n\tskb_reset_transport_header(skb);\n\n\tif (sock_queue_err_skb(sk, skb))\n\t\tkfree_skb(skb);\n}\n\nvoid ipv6_local_rxpmtu(struct sock *sk, struct flowi6 *fl6, u32 mtu)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6hdr *iph;\n\tstruct sk_buff *skb;\n\tstruct ip6_mtuinfo *mtu_info;\n\n\tif (!np->rxopt.bits.rxpmtu)\n\t\treturn;\n\n\tskb = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tiph = ipv6_hdr(skb);\n\tiph->daddr = fl6->daddr;\n\n\tmtu_info = IP6CBMTU(skb);\n\n\tmtu_info->ip6m_mtu = mtu;\n\tmtu_info->ip6m_addr.sin6_family = AF_INET6;\n\tmtu_info->ip6m_addr.sin6_port = 0;\n\tmtu_info->ip6m_addr.sin6_flowinfo = 0;\n\tmtu_info->ip6m_addr.sin6_scope_id = fl6->flowi6_oif;\n\tmtu_info->ip6m_addr.sin6_addr = ipv6_hdr(skb)->daddr;\n\n\t__skb_pull(skb, skb_tail_pointer(skb) - skb->data);\n\tskb_reset_transport_header(skb);\n\n\tskb = xchg(&np->rxpmtu, skb);\n\tkfree_skb(skb);\n}\n\n \nstatic inline bool ipv6_datagram_support_addr(struct sock_exterr_skb *serr)\n{\n\treturn serr->ee.ee_origin == SO_EE_ORIGIN_ICMP6 ||\n\t       serr->ee.ee_origin == SO_EE_ORIGIN_ICMP ||\n\t       serr->ee.ee_origin == SO_EE_ORIGIN_LOCAL || serr->port;\n}\n\n \nstatic bool ip6_datagram_support_cmsg(struct sk_buff *skb,\n\t\t\t\t      struct sock_exterr_skb *serr)\n{\n\tif (serr->ee.ee_origin == SO_EE_ORIGIN_ICMP ||\n\t    serr->ee.ee_origin == SO_EE_ORIGIN_ICMP6)\n\t\treturn true;\n\n\tif (serr->ee.ee_origin == SO_EE_ORIGIN_LOCAL)\n\t\treturn false;\n\n\tif (!IP6CB(skb)->iif)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nint ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sock_exterr_skb *serr;\n\tstruct sk_buff *skb;\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin, msg->msg_name);\n\tstruct {\n\t\tstruct sock_extended_err ee;\n\t\tstruct sockaddr_in6\t offender;\n\t} errhdr;\n\tint err;\n\tint copied;\n\n\terr = -EAGAIN;\n\tskb = sock_dequeue_err_skb(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (unlikely(err)) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tserr = SKB_EXT_ERR(skb);\n\n\tif (sin && ipv6_datagram_support_addr(serr)) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tsin->sin6_family = AF_INET6;\n\t\tsin->sin6_flowinfo = 0;\n\t\tsin->sin6_port = serr->port;\n\t\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\t\tconst struct ipv6hdr *ip6h = container_of((struct in6_addr *)(nh + serr->addr_offset),\n\t\t\t\t\t\t\t\t  struct ipv6hdr, daddr);\n\t\t\tsin->sin6_addr = ip6h->daddr;\n\t\t\tif (np->sndflow)\n\t\t\t\tsin->sin6_flowinfo = ip6_flowinfo(ip6h);\n\t\t\tsin->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin->sin6_addr,\n\t\t\t\t\t\t    IP6CB(skb)->iif);\n\t\t} else {\n\t\t\tipv6_addr_set_v4mapped(*(__be32 *)(nh + serr->addr_offset),\n\t\t\t\t\t       &sin->sin6_addr);\n\t\t\tsin->sin6_scope_id = 0;\n\t\t}\n\t\t*addr_len = sizeof(*sin);\n\t}\n\n\tmemcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));\n\tsin = &errhdr.offender;\n\tmemset(sin, 0, sizeof(*sin));\n\n\tif (ip6_datagram_support_cmsg(skb, serr)) {\n\t\tsin->sin6_family = AF_INET6;\n\t\tif (np->rxopt.all)\n\t\t\tip6_datagram_recv_common_ctl(sk, msg, skb);\n\t\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\t\tsin->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\t\tif (np->rxopt.all)\n\t\t\t\tip6_datagram_recv_specific_ctl(sk, msg, skb);\n\t\t\tsin->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin->sin6_addr,\n\t\t\t\t\t\t    IP6CB(skb)->iif);\n\t\t} else {\n\t\t\tipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\n\t\t\t\t\t       &sin->sin6_addr);\n\t\t\tif (inet_cmsg_flags(inet_sk(sk)))\n\t\t\t\tip_cmsg_recv(msg, skb);\n\t\t}\n\t}\n\n\tput_cmsg(msg, SOL_IPV6, IPV6_RECVERR, sizeof(errhdr), &errhdr);\n\n\t \n\n\tmsg->msg_flags |= MSG_ERRQUEUE;\n\terr = copied;\n\n\tconsume_skb(skb);\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ipv6_recv_error);\n\n \nint ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len,\n\t\t     int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ip6_mtuinfo mtu_info;\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin, msg->msg_name);\n\tint err;\n\tint copied;\n\n\terr = -EAGAIN;\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tmemcpy(&mtu_info, IP6CBMTU(skb), sizeof(mtu_info));\n\n\tif (sin) {\n\t\tsin->sin6_family = AF_INET6;\n\t\tsin->sin6_flowinfo = 0;\n\t\tsin->sin6_port = 0;\n\t\tsin->sin6_scope_id = mtu_info.ip6m_addr.sin6_scope_id;\n\t\tsin->sin6_addr = mtu_info.ip6m_addr.sin6_addr;\n\t\t*addr_len = sizeof(*sin);\n\t}\n\n\tput_cmsg(msg, SOL_IPV6, IPV6_PATHMTU, sizeof(mtu_info), &mtu_info);\n\n\terr = copied;\n\nout_free_skb:\n\tkfree_skb(skb);\nout:\n\treturn err;\n}\n\n\nvoid ip6_datagram_recv_common_ctl(struct sock *sk, struct msghdr *msg,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tbool is_ipv6 = skb->protocol == htons(ETH_P_IPV6);\n\n\tif (np->rxopt.bits.rxinfo) {\n\t\tstruct in6_pktinfo src_info;\n\n\t\tif (is_ipv6) {\n\t\t\tsrc_info.ipi6_ifindex = IP6CB(skb)->iif;\n\t\t\tsrc_info.ipi6_addr = ipv6_hdr(skb)->daddr;\n\t\t} else {\n\t\t\tsrc_info.ipi6_ifindex =\n\t\t\t\tPKTINFO_SKB_CB(skb)->ipi_ifindex;\n\t\t\tipv6_addr_set_v4mapped(ip_hdr(skb)->daddr,\n\t\t\t\t\t       &src_info.ipi6_addr);\n\t\t}\n\n\t\tif (src_info.ipi6_ifindex >= 0)\n\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_PKTINFO,\n\t\t\t\t sizeof(src_info), &src_info);\n\t}\n}\n\nvoid ip6_datagram_recv_specific_ctl(struct sock *sk, struct msghdr *msg,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tunsigned char *nh = skb_network_header(skb);\n\n\tif (np->rxopt.bits.rxhlim) {\n\t\tint hlim = ipv6_hdr(skb)->hop_limit;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_HOPLIMIT, sizeof(hlim), &hlim);\n\t}\n\n\tif (np->rxopt.bits.rxtclass) {\n\t\tint tclass = ipv6_get_dsfield(ipv6_hdr(skb));\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_TCLASS, sizeof(tclass), &tclass);\n\t}\n\n\tif (np->rxopt.bits.rxflow) {\n\t\t__be32 flowinfo = ip6_flowinfo((struct ipv6hdr *)nh);\n\t\tif (flowinfo)\n\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_FLOWINFO, sizeof(flowinfo), &flowinfo);\n\t}\n\n\t \n\tif (np->rxopt.bits.hopopts && (opt->flags & IP6SKB_HOPBYHOP)) {\n\t\tu8 *ptr = nh + sizeof(struct ipv6hdr);\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_HOPOPTS, (ptr[1]+1)<<3, ptr);\n\t}\n\n\tif (opt->lastopt &&\n\t    (np->rxopt.bits.dstopts || np->rxopt.bits.srcrt)) {\n\t\t \n\t\tunsigned int off = sizeof(struct ipv6hdr);\n\t\tu8 nexthdr = ipv6_hdr(skb)->nexthdr;\n\n\t\twhile (off <= opt->lastopt) {\n\t\t\tunsigned int len;\n\t\t\tu8 *ptr = nh + off;\n\n\t\t\tswitch (nexthdr) {\n\t\t\tcase IPPROTO_DSTOPTS:\n\t\t\t\tnexthdr = ptr[0];\n\t\t\t\tlen = (ptr[1] + 1) << 3;\n\t\t\t\tif (np->rxopt.bits.dstopts)\n\t\t\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_DSTOPTS, len, ptr);\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_ROUTING:\n\t\t\t\tnexthdr = ptr[0];\n\t\t\t\tlen = (ptr[1] + 1) << 3;\n\t\t\t\tif (np->rxopt.bits.srcrt)\n\t\t\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_RTHDR, len, ptr);\n\t\t\t\tbreak;\n\t\t\tcase IPPROTO_AH:\n\t\t\t\tnexthdr = ptr[0];\n\t\t\t\tlen = (ptr[1] + 2) << 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnexthdr = ptr[0];\n\t\t\t\tlen = (ptr[1] + 1) << 3;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toff += len;\n\t\t}\n\t}\n\n\t \n\tif (np->rxopt.bits.rxoinfo) {\n\t\tstruct in6_pktinfo src_info;\n\n\t\tsrc_info.ipi6_ifindex = opt->iif;\n\t\tsrc_info.ipi6_addr = ipv6_hdr(skb)->daddr;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292PKTINFO, sizeof(src_info), &src_info);\n\t}\n\tif (np->rxopt.bits.rxohlim) {\n\t\tint hlim = ipv6_hdr(skb)->hop_limit;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292HOPLIMIT, sizeof(hlim), &hlim);\n\t}\n\tif (np->rxopt.bits.ohopopts && (opt->flags & IP6SKB_HOPBYHOP)) {\n\t\tu8 *ptr = nh + sizeof(struct ipv6hdr);\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292HOPOPTS, (ptr[1]+1)<<3, ptr);\n\t}\n\tif (np->rxopt.bits.odstopts && opt->dst0) {\n\t\tu8 *ptr = nh + opt->dst0;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292DSTOPTS, (ptr[1]+1)<<3, ptr);\n\t}\n\tif (np->rxopt.bits.osrcrt && opt->srcrt) {\n\t\tstruct ipv6_rt_hdr *rthdr = (struct ipv6_rt_hdr *)(nh + opt->srcrt);\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292RTHDR, (rthdr->hdrlen+1) << 3, rthdr);\n\t}\n\tif (np->rxopt.bits.odstopts && opt->dst1) {\n\t\tu8 *ptr = nh + opt->dst1;\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_2292DSTOPTS, (ptr[1]+1)<<3, ptr);\n\t}\n\tif (np->rxopt.bits.rxorigdstaddr) {\n\t\tstruct sockaddr_in6 sin6;\n\t\t__be16 _ports[2], *ports;\n\n\t\tports = skb_header_pointer(skb, skb_transport_offset(skb),\n\t\t\t\t\t   sizeof(_ports), &_ports);\n\t\tif (ports) {\n\t\t\t \n\t\t\tsin6.sin6_family = AF_INET6;\n\t\t\tsin6.sin6_addr = ipv6_hdr(skb)->daddr;\n\t\t\tsin6.sin6_port = ports[1];\n\t\t\tsin6.sin6_flowinfo = 0;\n\t\t\tsin6.sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t    opt->iif);\n\n\t\t\tput_cmsg(msg, SOL_IPV6, IPV6_ORIGDSTADDR, sizeof(sin6), &sin6);\n\t\t}\n\t}\n\tif (np->rxopt.bits.recvfragsize && opt->frag_max_size) {\n\t\tint val = opt->frag_max_size;\n\n\t\tput_cmsg(msg, SOL_IPV6, IPV6_RECVFRAGSIZE, sizeof(val), &val);\n\t}\n}\n\nvoid ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,\n\t\t\t  struct sk_buff *skb)\n{\n\tip6_datagram_recv_common_ctl(sk, msg, skb);\n\tip6_datagram_recv_specific_ctl(sk, msg, skb);\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_recv_ctl);\n\nint ip6_datagram_send_ctl(struct net *net, struct sock *sk,\n\t\t\t  struct msghdr *msg, struct flowi6 *fl6,\n\t\t\t  struct ipcm6_cookie *ipc6)\n{\n\tstruct in6_pktinfo *src_info;\n\tstruct cmsghdr *cmsg;\n\tstruct ipv6_rt_hdr *rthdr;\n\tstruct ipv6_opt_hdr *hdr;\n\tstruct ipv6_txoptions *opt = ipc6->opt;\n\tint len;\n\tint err = 0;\n\n\tfor_each_cmsghdr(cmsg, msg) {\n\t\tint addr_type;\n\n\t\tif (!CMSG_OK(msg, cmsg)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_f;\n\t\t}\n\n\t\tif (cmsg->cmsg_level == SOL_SOCKET) {\n\t\t\terr = __sock_cmsg_send(sk, cmsg, &ipc6->sockc);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cmsg->cmsg_level != SOL_IPV6)\n\t\t\tcontinue;\n\n\t\tswitch (cmsg->cmsg_type) {\n\t\tcase IPV6_PKTINFO:\n\t\tcase IPV6_2292PKTINFO:\n\t\t    {\n\t\t\tstruct net_device *dev = NULL;\n\t\t\tint src_idx;\n\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct in6_pktinfo))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tsrc_info = (struct in6_pktinfo *)CMSG_DATA(cmsg);\n\t\t\tsrc_idx = src_info->ipi6_ifindex;\n\n\t\t\tif (src_idx) {\n\t\t\t\tif (fl6->flowi6_oif &&\n\t\t\t\t    src_idx != fl6->flowi6_oif &&\n\t\t\t\t    (READ_ONCE(sk->sk_bound_dev_if) != fl6->flowi6_oif ||\n\t\t\t\t     !sk_dev_equal_l3scope(sk, src_idx)))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tfl6->flowi6_oif = src_idx;\n\t\t\t}\n\n\t\t\taddr_type = __ipv6_addr_type(&src_info->ipi6_addr);\n\n\t\t\trcu_read_lock();\n\t\t\tif (fl6->flowi6_oif) {\n\t\t\t\tdev = dev_get_by_index_rcu(net, fl6->flowi6_oif);\n\t\t\t\tif (!dev) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\t}\n\t\t\t} else if (addr_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (addr_type != IPV6_ADDR_ANY) {\n\t\t\t\tint strict = __ipv6_addr_src_scope(addr_type) <= IPV6_ADDR_SCOPE_LINKLOCAL;\n\t\t\t\tif (!ipv6_can_nonlocal_bind(net, inet_sk(sk)) &&\n\t\t\t\t    !ipv6_chk_addr_and_flags(net, &src_info->ipi6_addr,\n\t\t\t\t\t\t\t     dev, !strict, 0,\n\t\t\t\t\t\t\t     IFA_F_TENTATIVE) &&\n\t\t\t\t    !ipv6_chk_acast_addr_src(net, dev,\n\t\t\t\t\t\t\t     &src_info->ipi6_addr))\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tfl6->saddr = src_info->ipi6_addr;\n\t\t\t}\n\n\t\t\trcu_read_unlock();\n\n\t\t\tif (err)\n\t\t\t\tgoto exit_f;\n\n\t\t\tbreak;\n\t\t    }\n\n\t\tcase IPV6_FLOWINFO:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(4)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tif (fl6->flowlabel&IPV6_FLOWINFO_MASK) {\n\t\t\t\tif ((fl6->flowlabel^*(__be32 *)CMSG_DATA(cmsg))&~IPV6_FLOWINFO_MASK) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto exit_f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfl6->flowlabel = IPV6_FLOWINFO_MASK & *(__be32 *)CMSG_DATA(cmsg);\n\t\t\tbreak;\n\n\t\tcase IPV6_2292HOPOPTS:\n\t\tcase IPV6_HOPOPTS:\n\t\t\tif (opt->hopopt || cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\thdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\n\t\t\tlen = ((hdr->hdrlen + 1) << 3);\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(len)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (!ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\topt->opt_nflen += len;\n\t\t\topt->hopopt = hdr;\n\t\t\tbreak;\n\n\t\tcase IPV6_2292DSTOPTS:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\thdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\n\t\t\tlen = ((hdr->hdrlen + 1) << 3);\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(len)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (!ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (opt->dst1opt) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\topt->opt_flen += len;\n\t\t\topt->dst1opt = hdr;\n\t\t\tbreak;\n\n\t\tcase IPV6_DSTOPTS:\n\t\tcase IPV6_RTHDRDSTOPTS:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_opt_hdr))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\thdr = (struct ipv6_opt_hdr *)CMSG_DATA(cmsg);\n\t\t\tlen = ((hdr->hdrlen + 1) << 3);\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(len)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (!ns_capable(net->user_ns, CAP_NET_RAW)) {\n\t\t\t\terr = -EPERM;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\t\t\tif (cmsg->cmsg_type == IPV6_DSTOPTS) {\n\t\t\t\topt->opt_flen += len;\n\t\t\t\topt->dst1opt = hdr;\n\t\t\t} else {\n\t\t\t\topt->opt_nflen += len;\n\t\t\t\topt->dst0opt = hdr;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IPV6_2292RTHDR:\n\t\tcase IPV6_RTHDR:\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(struct ipv6_rt_hdr))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\trthdr = (struct ipv6_rt_hdr *)CMSG_DATA(cmsg);\n\n\t\t\tswitch (rthdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tcase IPV6_SRCRT_TYPE_2:\n\t\t\t\tif (rthdr->hdrlen != 2 ||\n\t\t\t\t    rthdr->segments_left != 1) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto exit_f;\n\t\t\t\t}\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tlen = ((rthdr->hdrlen + 1) << 3);\n\n\t\t\tif (cmsg->cmsg_len < CMSG_LEN(len)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((rthdr->hdrlen >> 1) != rthdr->segments_left) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\topt->opt_nflen += len;\n\t\t\topt->srcrt = rthdr;\n\n\t\t\tif (cmsg->cmsg_type == IPV6_2292RTHDR && opt->dst1opt) {\n\t\t\t\tint dsthdrlen = ((opt->dst1opt->hdrlen+1)<<3);\n\n\t\t\t\topt->opt_nflen += dsthdrlen;\n\t\t\t\topt->dst0opt = opt->dst1opt;\n\t\t\t\topt->dst1opt = NULL;\n\t\t\t\topt->opt_flen -= dsthdrlen;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IPV6_2292HOPLIMIT:\n\t\tcase IPV6_HOPLIMIT:\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int))) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tipc6->hlimit = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (ipc6->hlimit < -1 || ipc6->hlimit > 0xff) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_f;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IPV6_TCLASS:\n\t\t    {\n\t\t\tint tc;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\n\t\t\t\tgoto exit_f;\n\n\t\t\ttc = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (tc < -1 || tc > 0xff)\n\t\t\t\tgoto exit_f;\n\n\t\t\terr = 0;\n\t\t\tipc6->tclass = tc;\n\n\t\t\tbreak;\n\t\t    }\n\n\t\tcase IPV6_DONTFRAG:\n\t\t    {\n\t\t\tint df;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (cmsg->cmsg_len != CMSG_LEN(sizeof(int)))\n\t\t\t\tgoto exit_f;\n\n\t\t\tdf = *(int *)CMSG_DATA(cmsg);\n\t\t\tif (df < 0 || df > 1)\n\t\t\t\tgoto exit_f;\n\n\t\t\terr = 0;\n\t\t\tipc6->dontfrag = df;\n\n\t\t\tbreak;\n\t\t    }\n\t\tdefault:\n\t\t\tnet_dbg_ratelimited(\"invalid cmsg type: %d\\n\",\n\t\t\t\t\t    cmsg->cmsg_type);\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_f;\n\t\t}\n\t}\n\nexit_f:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ip6_datagram_send_ctl);\n\nvoid __ip6_dgram_sock_seq_show(struct seq_file *seq, struct sock *sp,\n\t\t\t       __u16 srcp, __u16 destp, int rqueue, int bucket)\n{\n\tconst struct in6_addr *dest, *src;\n\n\tdest  = &sp->sk_v6_daddr;\n\tsrc   = &sp->sk_v6_rcv_saddr;\n\tseq_printf(seq,\n\t\t   \"%5d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %u\\n\",\n\t\t   bucket,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   sp->sk_state,\n\t\t   sk_wmem_alloc_get(sp),\n\t\t   rqueue,\n\t\t   0, 0L, 0,\n\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t   0,\n\t\t   sock_i_ino(sp),\n\t\t   refcount_read(&sp->sk_refcnt), sp,\n\t\t   atomic_read(&sp->sk_drops));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}