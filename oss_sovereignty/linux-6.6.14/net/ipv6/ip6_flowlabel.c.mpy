{
  "module_name": "ip6_flowlabel.c",
  "hash_id": "2f8640cd475097aa6aa8849812a751c55293f608d6dd47f68ad3df2bbf80b6da",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ip6_flowlabel.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/pid_namespace.h>\n#include <linux/jump_label_ratelimit.h>\n\n#include <net/net_namespace.h>\n#include <net/sock.h>\n\n#include <net/ipv6.h>\n#include <net/rawv6.h>\n#include <net/transp_v6.h>\n\n#include <linux/uaccess.h>\n\n#define FL_MIN_LINGER\t6\t \n#define FL_MAX_LINGER\t150\t \n\n \n\n#define FL_MAX_PER_SOCK\t32\n#define FL_MAX_SIZE\t4096\n#define FL_HASH_MASK\t255\n#define FL_HASH(l)\t(ntohl(l)&FL_HASH_MASK)\n\nstatic atomic_t fl_size = ATOMIC_INIT(0);\nstatic struct ip6_flowlabel __rcu *fl_ht[FL_HASH_MASK+1];\n\nstatic void ip6_fl_gc(struct timer_list *unused);\nstatic DEFINE_TIMER(ip6_fl_gc_timer, ip6_fl_gc);\n\n \n\nstatic DEFINE_SPINLOCK(ip6_fl_lock);\n\n \n\nstatic DEFINE_SPINLOCK(ip6_sk_fl_lock);\n\nDEFINE_STATIC_KEY_DEFERRED_FALSE(ipv6_flowlabel_exclusive, HZ);\nEXPORT_SYMBOL(ipv6_flowlabel_exclusive);\n\n#define for_each_fl_rcu(hash, fl)\t\t\t\t\\\n\tfor (fl = rcu_dereference(fl_ht[(hash)]);\t\t\\\n\t     fl != NULL;\t\t\t\t\t\\\n\t     fl = rcu_dereference(fl->next))\n#define for_each_fl_continue_rcu(fl)\t\t\t\t\\\n\tfor (fl = rcu_dereference(fl->next);\t\t\t\\\n\t     fl != NULL;\t\t\t\t\t\\\n\t     fl = rcu_dereference(fl->next))\n\n#define for_each_sk_fl_rcu(np, sfl)\t\t\t\t\\\n\tfor (sfl = rcu_dereference(np->ipv6_fl_list);\t\\\n\t     sfl != NULL;\t\t\t\t\t\\\n\t     sfl = rcu_dereference(sfl->next))\n\nstatic inline struct ip6_flowlabel *__fl_lookup(struct net *net, __be32 label)\n{\n\tstruct ip6_flowlabel *fl;\n\n\tfor_each_fl_rcu(FL_HASH(label), fl) {\n\t\tif (fl->label == label && net_eq(fl->fl_net, net))\n\t\t\treturn fl;\n\t}\n\treturn NULL;\n}\n\nstatic struct ip6_flowlabel *fl_lookup(struct net *net, __be32 label)\n{\n\tstruct ip6_flowlabel *fl;\n\n\trcu_read_lock();\n\tfl = __fl_lookup(net, label);\n\tif (fl && !atomic_inc_not_zero(&fl->users))\n\t\tfl = NULL;\n\trcu_read_unlock();\n\treturn fl;\n}\n\nstatic bool fl_shared_exclusive(struct ip6_flowlabel *fl)\n{\n\treturn fl->share == IPV6_FL_S_EXCL ||\n\t       fl->share == IPV6_FL_S_PROCESS ||\n\t       fl->share == IPV6_FL_S_USER;\n}\n\nstatic void fl_free_rcu(struct rcu_head *head)\n{\n\tstruct ip6_flowlabel *fl = container_of(head, struct ip6_flowlabel, rcu);\n\n\tif (fl->share == IPV6_FL_S_PROCESS)\n\t\tput_pid(fl->owner.pid);\n\tkfree(fl->opt);\n\tkfree(fl);\n}\n\n\nstatic void fl_free(struct ip6_flowlabel *fl)\n{\n\tif (!fl)\n\t\treturn;\n\n\tif (fl_shared_exclusive(fl) || fl->opt)\n\t\tstatic_branch_slow_dec_deferred(&ipv6_flowlabel_exclusive);\n\n\tcall_rcu(&fl->rcu, fl_free_rcu);\n}\n\nstatic void fl_release(struct ip6_flowlabel *fl)\n{\n\tspin_lock_bh(&ip6_fl_lock);\n\n\tfl->lastuse = jiffies;\n\tif (atomic_dec_and_test(&fl->users)) {\n\t\tunsigned long ttd = fl->lastuse + fl->linger;\n\t\tif (time_after(ttd, fl->expires))\n\t\t\tfl->expires = ttd;\n\t\tttd = fl->expires;\n\t\tif (fl->opt && fl->share == IPV6_FL_S_EXCL) {\n\t\t\tstruct ipv6_txoptions *opt = fl->opt;\n\t\t\tfl->opt = NULL;\n\t\t\tkfree(opt);\n\t\t}\n\t\tif (!timer_pending(&ip6_fl_gc_timer) ||\n\t\t    time_after(ip6_fl_gc_timer.expires, ttd))\n\t\t\tmod_timer(&ip6_fl_gc_timer, ttd);\n\t}\n\tspin_unlock_bh(&ip6_fl_lock);\n}\n\nstatic void ip6_fl_gc(struct timer_list *unused)\n{\n\tint i;\n\tunsigned long now = jiffies;\n\tunsigned long sched = 0;\n\n\tspin_lock(&ip6_fl_lock);\n\n\tfor (i = 0; i <= FL_HASH_MASK; i++) {\n\t\tstruct ip6_flowlabel *fl;\n\t\tstruct ip6_flowlabel __rcu **flp;\n\n\t\tflp = &fl_ht[i];\n\t\twhile ((fl = rcu_dereference_protected(*flp,\n\t\t\t\t\t\t       lockdep_is_held(&ip6_fl_lock))) != NULL) {\n\t\t\tif (atomic_read(&fl->users) == 0) {\n\t\t\t\tunsigned long ttd = fl->lastuse + fl->linger;\n\t\t\t\tif (time_after(ttd, fl->expires))\n\t\t\t\t\tfl->expires = ttd;\n\t\t\t\tttd = fl->expires;\n\t\t\t\tif (time_after_eq(now, ttd)) {\n\t\t\t\t\t*flp = fl->next;\n\t\t\t\t\tfl_free(fl);\n\t\t\t\t\tatomic_dec(&fl_size);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!sched || time_before(ttd, sched))\n\t\t\t\t\tsched = ttd;\n\t\t\t}\n\t\t\tflp = &fl->next;\n\t\t}\n\t}\n\tif (!sched && atomic_read(&fl_size))\n\t\tsched = now + FL_MAX_LINGER;\n\tif (sched) {\n\t\tmod_timer(&ip6_fl_gc_timer, sched);\n\t}\n\tspin_unlock(&ip6_fl_lock);\n}\n\nstatic void __net_exit ip6_fl_purge(struct net *net)\n{\n\tint i;\n\n\tspin_lock_bh(&ip6_fl_lock);\n\tfor (i = 0; i <= FL_HASH_MASK; i++) {\n\t\tstruct ip6_flowlabel *fl;\n\t\tstruct ip6_flowlabel __rcu **flp;\n\n\t\tflp = &fl_ht[i];\n\t\twhile ((fl = rcu_dereference_protected(*flp,\n\t\t\t\t\t\t       lockdep_is_held(&ip6_fl_lock))) != NULL) {\n\t\t\tif (net_eq(fl->fl_net, net) &&\n\t\t\t    atomic_read(&fl->users) == 0) {\n\t\t\t\t*flp = fl->next;\n\t\t\t\tfl_free(fl);\n\t\t\t\tatomic_dec(&fl_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tflp = &fl->next;\n\t\t}\n\t}\n\tspin_unlock_bh(&ip6_fl_lock);\n}\n\nstatic struct ip6_flowlabel *fl_intern(struct net *net,\n\t\t\t\t       struct ip6_flowlabel *fl, __be32 label)\n{\n\tstruct ip6_flowlabel *lfl;\n\n\tfl->label = label & IPV6_FLOWLABEL_MASK;\n\n\trcu_read_lock();\n\tspin_lock_bh(&ip6_fl_lock);\n\tif (label == 0) {\n\t\tfor (;;) {\n\t\t\tfl->label = htonl(get_random_u32())&IPV6_FLOWLABEL_MASK;\n\t\t\tif (fl->label) {\n\t\t\t\tlfl = __fl_lookup(net, fl->label);\n\t\t\t\tif (!lfl)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tlfl = __fl_lookup(net, fl->label);\n\t\tif (lfl) {\n\t\t\tatomic_inc(&lfl->users);\n\t\t\tspin_unlock_bh(&ip6_fl_lock);\n\t\t\trcu_read_unlock();\n\t\t\treturn lfl;\n\t\t}\n\t}\n\n\tfl->lastuse = jiffies;\n\tfl->next = fl_ht[FL_HASH(fl->label)];\n\trcu_assign_pointer(fl_ht[FL_HASH(fl->label)], fl);\n\tatomic_inc(&fl_size);\n\tspin_unlock_bh(&ip6_fl_lock);\n\trcu_read_unlock();\n\treturn NULL;\n}\n\n\n\n \n\nstruct ip6_flowlabel *__fl6_sock_lookup(struct sock *sk, __be32 label)\n{\n\tstruct ipv6_fl_socklist *sfl;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\tlabel &= IPV6_FLOWLABEL_MASK;\n\n\trcu_read_lock();\n\tfor_each_sk_fl_rcu(np, sfl) {\n\t\tstruct ip6_flowlabel *fl = sfl->fl;\n\n\t\tif (fl->label == label && atomic_inc_not_zero(&fl->users)) {\n\t\t\tfl->lastuse = jiffies;\n\t\t\trcu_read_unlock();\n\t\t\treturn fl;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(__fl6_sock_lookup);\n\nvoid fl6_free_socklist(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_fl_socklist *sfl;\n\n\tif (!rcu_access_pointer(np->ipv6_fl_list))\n\t\treturn;\n\n\tspin_lock_bh(&ip6_sk_fl_lock);\n\twhile ((sfl = rcu_dereference_protected(np->ipv6_fl_list,\n\t\t\t\t\t\tlockdep_is_held(&ip6_sk_fl_lock))) != NULL) {\n\t\tnp->ipv6_fl_list = sfl->next;\n\t\tspin_unlock_bh(&ip6_sk_fl_lock);\n\n\t\tfl_release(sfl->fl);\n\t\tkfree_rcu(sfl, rcu);\n\n\t\tspin_lock_bh(&ip6_sk_fl_lock);\n\t}\n\tspin_unlock_bh(&ip6_sk_fl_lock);\n}\n\n \n\n\n \n\nstruct ipv6_txoptions *fl6_merge_options(struct ipv6_txoptions *opt_space,\n\t\t\t\t\t struct ip6_flowlabel *fl,\n\t\t\t\t\t struct ipv6_txoptions *fopt)\n{\n\tstruct ipv6_txoptions *fl_opt = fl->opt;\n\n\tif (!fopt || fopt->opt_flen == 0)\n\t\treturn fl_opt;\n\n\tif (fl_opt) {\n\t\topt_space->hopopt = fl_opt->hopopt;\n\t\topt_space->dst0opt = fl_opt->dst0opt;\n\t\topt_space->srcrt = fl_opt->srcrt;\n\t\topt_space->opt_nflen = fl_opt->opt_nflen;\n\t} else {\n\t\tif (fopt->opt_nflen == 0)\n\t\t\treturn fopt;\n\t\topt_space->hopopt = NULL;\n\t\topt_space->dst0opt = NULL;\n\t\topt_space->srcrt = NULL;\n\t\topt_space->opt_nflen = 0;\n\t}\n\topt_space->dst1opt = fopt->dst1opt;\n\topt_space->opt_flen = fopt->opt_flen;\n\topt_space->tot_len = fopt->tot_len;\n\treturn opt_space;\n}\nEXPORT_SYMBOL_GPL(fl6_merge_options);\n\nstatic unsigned long check_linger(unsigned long ttl)\n{\n\tif (ttl < FL_MIN_LINGER)\n\t\treturn FL_MIN_LINGER*HZ;\n\tif (ttl > FL_MAX_LINGER && !capable(CAP_NET_ADMIN))\n\t\treturn 0;\n\treturn ttl*HZ;\n}\n\nstatic int fl6_renew(struct ip6_flowlabel *fl, unsigned long linger, unsigned long expires)\n{\n\tlinger = check_linger(linger);\n\tif (!linger)\n\t\treturn -EPERM;\n\texpires = check_linger(expires);\n\tif (!expires)\n\t\treturn -EPERM;\n\n\tspin_lock_bh(&ip6_fl_lock);\n\tfl->lastuse = jiffies;\n\tif (time_before(fl->linger, linger))\n\t\tfl->linger = linger;\n\tif (time_before(expires, fl->linger))\n\t\texpires = fl->linger;\n\tif (time_before(fl->expires, fl->lastuse + expires))\n\t\tfl->expires = fl->lastuse + expires;\n\tspin_unlock_bh(&ip6_fl_lock);\n\n\treturn 0;\n}\n\nstatic struct ip6_flowlabel *\nfl_create(struct net *net, struct sock *sk, struct in6_flowlabel_req *freq,\n\t  sockptr_t optval, int optlen, int *err_p)\n{\n\tstruct ip6_flowlabel *fl = NULL;\n\tint olen;\n\tint addr_type;\n\tint err;\n\n\tolen = optlen - CMSG_ALIGN(sizeof(*freq));\n\terr = -EINVAL;\n\tif (olen > 64 * 1024)\n\t\tgoto done;\n\n\terr = -ENOMEM;\n\tfl = kzalloc(sizeof(*fl), GFP_KERNEL);\n\tif (!fl)\n\t\tgoto done;\n\n\tif (olen > 0) {\n\t\tstruct msghdr msg;\n\t\tstruct flowi6 flowi6;\n\t\tstruct ipcm6_cookie ipc6;\n\n\t\terr = -ENOMEM;\n\t\tfl->opt = kmalloc(sizeof(*fl->opt) + olen, GFP_KERNEL);\n\t\tif (!fl->opt)\n\t\t\tgoto done;\n\n\t\tmemset(fl->opt, 0, sizeof(*fl->opt));\n\t\tfl->opt->tot_len = sizeof(*fl->opt) + olen;\n\t\terr = -EFAULT;\n\t\tif (copy_from_sockptr_offset(fl->opt + 1, optval,\n\t\t\t\tCMSG_ALIGN(sizeof(*freq)), olen))\n\t\t\tgoto done;\n\n\t\tmsg.msg_controllen = olen;\n\t\tmsg.msg_control = (void *)(fl->opt+1);\n\t\tmemset(&flowi6, 0, sizeof(flowi6));\n\n\t\tipc6.opt = fl->opt;\n\t\terr = ip6_datagram_send_ctl(net, sk, &msg, &flowi6, &ipc6);\n\t\tif (err)\n\t\t\tgoto done;\n\t\terr = -EINVAL;\n\t\tif (fl->opt->opt_flen)\n\t\t\tgoto done;\n\t\tif (fl->opt->opt_nflen == 0) {\n\t\t\tkfree(fl->opt);\n\t\t\tfl->opt = NULL;\n\t\t}\n\t}\n\n\tfl->fl_net = net;\n\tfl->expires = jiffies;\n\terr = fl6_renew(fl, freq->flr_linger, freq->flr_expires);\n\tif (err)\n\t\tgoto done;\n\tfl->share = freq->flr_share;\n\taddr_type = ipv6_addr_type(&freq->flr_dst);\n\tif ((addr_type & IPV6_ADDR_MAPPED) ||\n\t    addr_type == IPV6_ADDR_ANY) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tfl->dst = freq->flr_dst;\n\tatomic_set(&fl->users, 1);\n\tswitch (fl->share) {\n\tcase IPV6_FL_S_EXCL:\n\tcase IPV6_FL_S_ANY:\n\t\tbreak;\n\tcase IPV6_FL_S_PROCESS:\n\t\tfl->owner.pid = get_task_pid(current, PIDTYPE_PID);\n\t\tbreak;\n\tcase IPV6_FL_S_USER:\n\t\tfl->owner.uid = current_euid();\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tif (fl_shared_exclusive(fl) || fl->opt) {\n\t\tWRITE_ONCE(sock_net(sk)->ipv6.flowlabel_has_excl, 1);\n\t\tstatic_branch_deferred_inc(&ipv6_flowlabel_exclusive);\n\t}\n\treturn fl;\n\ndone:\n\tif (fl) {\n\t\tkfree(fl->opt);\n\t\tkfree(fl);\n\t}\n\t*err_p = err;\n\treturn NULL;\n}\n\nstatic int mem_check(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_fl_socklist *sfl;\n\tint room = FL_MAX_SIZE - atomic_read(&fl_size);\n\tint count = 0;\n\n\tif (room > FL_MAX_SIZE - FL_MAX_PER_SOCK)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tfor_each_sk_fl_rcu(np, sfl)\n\t\tcount++;\n\trcu_read_unlock();\n\n\tif (room <= 0 ||\n\t    ((count >= FL_MAX_PER_SOCK ||\n\t      (count > 0 && room < FL_MAX_SIZE/2) || room < FL_MAX_SIZE/4) &&\n\t     !capable(CAP_NET_ADMIN)))\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\nstatic inline void fl_link(struct ipv6_pinfo *np, struct ipv6_fl_socklist *sfl,\n\t\tstruct ip6_flowlabel *fl)\n{\n\tspin_lock_bh(&ip6_sk_fl_lock);\n\tsfl->fl = fl;\n\tsfl->next = np->ipv6_fl_list;\n\trcu_assign_pointer(np->ipv6_fl_list, sfl);\n\tspin_unlock_bh(&ip6_sk_fl_lock);\n}\n\nint ipv6_flowlabel_opt_get(struct sock *sk, struct in6_flowlabel_req *freq,\n\t\t\t   int flags)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_fl_socklist *sfl;\n\n\tif (flags & IPV6_FL_F_REMOTE) {\n\t\tfreq->flr_label = np->rcv_flowinfo & IPV6_FLOWLABEL_MASK;\n\t\treturn 0;\n\t}\n\n\tif (np->repflow) {\n\t\tfreq->flr_label = np->flow_label;\n\t\treturn 0;\n\t}\n\n\trcu_read_lock();\n\n\tfor_each_sk_fl_rcu(np, sfl) {\n\t\tif (sfl->fl->label == (np->flow_label & IPV6_FLOWLABEL_MASK)) {\n\t\t\tspin_lock_bh(&ip6_fl_lock);\n\t\t\tfreq->flr_label = sfl->fl->label;\n\t\t\tfreq->flr_dst = sfl->fl->dst;\n\t\t\tfreq->flr_share = sfl->fl->share;\n\t\t\tfreq->flr_expires = (sfl->fl->expires - jiffies) / HZ;\n\t\t\tfreq->flr_linger = sfl->fl->linger / HZ;\n\n\t\t\tspin_unlock_bh(&ip6_fl_lock);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn -ENOENT;\n}\n\n#define socklist_dereference(__sflp) \\\n\trcu_dereference_protected(__sflp, lockdep_is_held(&ip6_sk_fl_lock))\n\nstatic int ipv6_flowlabel_put(struct sock *sk, struct in6_flowlabel_req *freq)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_fl_socklist __rcu **sflp;\n\tstruct ipv6_fl_socklist *sfl;\n\n\tif (freq->flr_flags & IPV6_FL_F_REFLECT) {\n\t\tif (sk->sk_protocol != IPPROTO_TCP)\n\t\t\treturn -ENOPROTOOPT;\n\t\tif (!np->repflow)\n\t\t\treturn -ESRCH;\n\t\tnp->flow_label = 0;\n\t\tnp->repflow = 0;\n\t\treturn 0;\n\t}\n\n\tspin_lock_bh(&ip6_sk_fl_lock);\n\tfor (sflp = &np->ipv6_fl_list;\n\t     (sfl = socklist_dereference(*sflp)) != NULL;\n\t     sflp = &sfl->next) {\n\t\tif (sfl->fl->label == freq->flr_label)\n\t\t\tgoto found;\n\t}\n\tspin_unlock_bh(&ip6_sk_fl_lock);\n\treturn -ESRCH;\nfound:\n\tif (freq->flr_label == (np->flow_label & IPV6_FLOWLABEL_MASK))\n\t\tnp->flow_label &= ~IPV6_FLOWLABEL_MASK;\n\t*sflp = sfl->next;\n\tspin_unlock_bh(&ip6_sk_fl_lock);\n\tfl_release(sfl->fl);\n\tkfree_rcu(sfl, rcu);\n\treturn 0;\n}\n\nstatic int ipv6_flowlabel_renew(struct sock *sk, struct in6_flowlabel_req *freq)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6_fl_socklist *sfl;\n\tint err;\n\n\trcu_read_lock();\n\tfor_each_sk_fl_rcu(np, sfl) {\n\t\tif (sfl->fl->label == freq->flr_label) {\n\t\t\terr = fl6_renew(sfl->fl, freq->flr_linger,\n\t\t\t\t\tfreq->flr_expires);\n\t\t\trcu_read_unlock();\n\t\t\treturn err;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (freq->flr_share == IPV6_FL_S_NONE &&\n\t    ns_capable(net->user_ns, CAP_NET_ADMIN)) {\n\t\tstruct ip6_flowlabel *fl = fl_lookup(net, freq->flr_label);\n\n\t\tif (fl) {\n\t\t\terr = fl6_renew(fl, freq->flr_linger,\n\t\t\t\t\tfreq->flr_expires);\n\t\t\tfl_release(fl);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn -ESRCH;\n}\n\nstatic int ipv6_flowlabel_get(struct sock *sk, struct in6_flowlabel_req *freq,\n\t\tsockptr_t optval, int optlen)\n{\n\tstruct ipv6_fl_socklist *sfl, *sfl1 = NULL;\n\tstruct ip6_flowlabel *fl, *fl1 = NULL;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint err;\n\n\tif (freq->flr_flags & IPV6_FL_F_REFLECT) {\n\t\tif (net->ipv6.sysctl.flowlabel_consistency) {\n\t\t\tnet_info_ratelimited(\"Can not set IPV6_FL_F_REFLECT if flowlabel_consistency sysctl is enable\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (sk->sk_protocol != IPPROTO_TCP)\n\t\t\treturn -ENOPROTOOPT;\n\t\tnp->repflow = 1;\n\t\treturn 0;\n\t}\n\n\tif (freq->flr_label & ~IPV6_FLOWLABEL_MASK)\n\t\treturn -EINVAL;\n\tif (net->ipv6.sysctl.flowlabel_state_ranges &&\n\t    (freq->flr_label & IPV6_FLOWLABEL_STATELESS_FLAG))\n\t\treturn -ERANGE;\n\n\tfl = fl_create(net, sk, freq, optval, optlen, &err);\n\tif (!fl)\n\t\treturn err;\n\n\tsfl1 = kmalloc(sizeof(*sfl1), GFP_KERNEL);\n\n\tif (freq->flr_label) {\n\t\terr = -EEXIST;\n\t\trcu_read_lock();\n\t\tfor_each_sk_fl_rcu(np, sfl) {\n\t\t\tif (sfl->fl->label == freq->flr_label) {\n\t\t\t\tif (freq->flr_flags & IPV6_FL_F_EXCL) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tfl1 = sfl->fl;\n\t\t\t\tif (!atomic_inc_not_zero(&fl1->users))\n\t\t\t\t\tfl1 = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!fl1)\n\t\t\tfl1 = fl_lookup(net, freq->flr_label);\n\t\tif (fl1) {\nrecheck:\n\t\t\terr = -EEXIST;\n\t\t\tif (freq->flr_flags&IPV6_FL_F_EXCL)\n\t\t\t\tgoto release;\n\t\t\terr = -EPERM;\n\t\t\tif (fl1->share == IPV6_FL_S_EXCL ||\n\t\t\t    fl1->share != fl->share ||\n\t\t\t    ((fl1->share == IPV6_FL_S_PROCESS) &&\n\t\t\t     (fl1->owner.pid != fl->owner.pid)) ||\n\t\t\t    ((fl1->share == IPV6_FL_S_USER) &&\n\t\t\t     !uid_eq(fl1->owner.uid, fl->owner.uid)))\n\t\t\t\tgoto release;\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sfl1)\n\t\t\t\tgoto release;\n\t\t\tif (fl->linger > fl1->linger)\n\t\t\t\tfl1->linger = fl->linger;\n\t\t\tif ((long)(fl->expires - fl1->expires) > 0)\n\t\t\t\tfl1->expires = fl->expires;\n\t\t\tfl_link(np, sfl1, fl1);\n\t\t\tfl_free(fl);\n\t\t\treturn 0;\n\nrelease:\n\t\t\tfl_release(fl1);\n\t\t\tgoto done;\n\t\t}\n\t}\n\terr = -ENOENT;\n\tif (!(freq->flr_flags & IPV6_FL_F_CREATE))\n\t\tgoto done;\n\n\terr = -ENOMEM;\n\tif (!sfl1)\n\t\tgoto done;\n\n\terr = mem_check(sk);\n\tif (err != 0)\n\t\tgoto done;\n\n\tfl1 = fl_intern(net, fl, freq->flr_label);\n\tif (fl1)\n\t\tgoto recheck;\n\n\tif (!freq->flr_label) {\n\t\tsize_t offset = offsetof(struct in6_flowlabel_req, flr_label);\n\n\t\tif (copy_to_sockptr_offset(optval, offset, &fl->label,\n\t\t\t\tsizeof(fl->label))) {\n\t\t\t \n\t\t}\n\t}\n\n\tfl_link(np, sfl1, fl);\n\treturn 0;\ndone:\n\tfl_free(fl);\n\tkfree(sfl1);\n\treturn err;\n}\n\nint ipv6_flowlabel_opt(struct sock *sk, sockptr_t optval, int optlen)\n{\n\tstruct in6_flowlabel_req freq;\n\n\tif (optlen < sizeof(freq))\n\t\treturn -EINVAL;\n\tif (copy_from_sockptr(&freq, optval, sizeof(freq)))\n\t\treturn -EFAULT;\n\n\tswitch (freq.flr_action) {\n\tcase IPV6_FL_A_PUT:\n\t\treturn ipv6_flowlabel_put(sk, &freq);\n\tcase IPV6_FL_A_RENEW:\n\t\treturn ipv6_flowlabel_renew(sk, &freq);\n\tcase IPV6_FL_A_GET:\n\t\treturn ipv6_flowlabel_get(sk, &freq, optval, optlen);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#ifdef CONFIG_PROC_FS\n\nstruct ip6fl_iter_state {\n\tstruct seq_net_private p;\n\tstruct pid_namespace *pid_ns;\n\tint bucket;\n};\n\n#define ip6fl_seq_private(seq)\t((struct ip6fl_iter_state *)(seq)->private)\n\nstatic struct ip6_flowlabel *ip6fl_get_first(struct seq_file *seq)\n{\n\tstruct ip6_flowlabel *fl = NULL;\n\tstruct ip6fl_iter_state *state = ip6fl_seq_private(seq);\n\tstruct net *net = seq_file_net(seq);\n\n\tfor (state->bucket = 0; state->bucket <= FL_HASH_MASK; ++state->bucket) {\n\t\tfor_each_fl_rcu(state->bucket, fl) {\n\t\t\tif (net_eq(fl->fl_net, net))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tfl = NULL;\nout:\n\treturn fl;\n}\n\nstatic struct ip6_flowlabel *ip6fl_get_next(struct seq_file *seq, struct ip6_flowlabel *fl)\n{\n\tstruct ip6fl_iter_state *state = ip6fl_seq_private(seq);\n\tstruct net *net = seq_file_net(seq);\n\n\tfor_each_fl_continue_rcu(fl) {\n\t\tif (net_eq(fl->fl_net, net))\n\t\t\tgoto out;\n\t}\n\ntry_again:\n\tif (++state->bucket <= FL_HASH_MASK) {\n\t\tfor_each_fl_rcu(state->bucket, fl) {\n\t\t\tif (net_eq(fl->fl_net, net))\n\t\t\t\tgoto out;\n\t\t}\n\t\tgoto try_again;\n\t}\n\tfl = NULL;\n\nout:\n\treturn fl;\n}\n\nstatic struct ip6_flowlabel *ip6fl_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct ip6_flowlabel *fl = ip6fl_get_first(seq);\n\tif (fl)\n\t\twhile (pos && (fl = ip6fl_get_next(seq, fl)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : fl;\n}\n\nstatic void *ip6fl_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct ip6fl_iter_state *state = ip6fl_seq_private(seq);\n\n\tstate->pid_ns = proc_pid_ns(file_inode(seq->file)->i_sb);\n\n\trcu_read_lock();\n\treturn *pos ? ip6fl_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *ip6fl_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ip6_flowlabel *fl;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tfl = ip6fl_get_first(seq);\n\telse\n\t\tfl = ip6fl_get_next(seq, v);\n\t++*pos;\n\treturn fl;\n}\n\nstatic void ip6fl_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\nstatic int ip6fl_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct ip6fl_iter_state *state = ip6fl_seq_private(seq);\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"Label S Owner  Users  Linger Expires  Dst                              Opt\\n\");\n\t} else {\n\t\tstruct ip6_flowlabel *fl = v;\n\t\tseq_printf(seq,\n\t\t\t   \"%05X %-1d %-6d %-6d %-6ld %-8ld %pi6 %-4d\\n\",\n\t\t\t   (unsigned int)ntohl(fl->label),\n\t\t\t   fl->share,\n\t\t\t   ((fl->share == IPV6_FL_S_PROCESS) ?\n\t\t\t    pid_nr_ns(fl->owner.pid, state->pid_ns) :\n\t\t\t    ((fl->share == IPV6_FL_S_USER) ?\n\t\t\t     from_kuid_munged(seq_user_ns(seq), fl->owner.uid) :\n\t\t\t     0)),\n\t\t\t   atomic_read(&fl->users),\n\t\t\t   fl->linger/HZ,\n\t\t\t   (long)(fl->expires - jiffies)/HZ,\n\t\t\t   &fl->dst,\n\t\t\t   fl->opt ? fl->opt->opt_nflen : 0);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ip6fl_seq_ops = {\n\t.start\t=\tip6fl_seq_start,\n\t.next\t=\tip6fl_seq_next,\n\t.stop\t=\tip6fl_seq_stop,\n\t.show\t=\tip6fl_seq_show,\n};\n\nstatic int __net_init ip6_flowlabel_proc_init(struct net *net)\n{\n\tif (!proc_create_net(\"ip6_flowlabel\", 0444, net->proc_net,\n\t\t\t&ip6fl_seq_ops, sizeof(struct ip6fl_iter_state)))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void __net_exit ip6_flowlabel_proc_fini(struct net *net)\n{\n\tremove_proc_entry(\"ip6_flowlabel\", net->proc_net);\n}\n#else\nstatic inline int ip6_flowlabel_proc_init(struct net *net)\n{\n\treturn 0;\n}\nstatic inline void ip6_flowlabel_proc_fini(struct net *net)\n{\n}\n#endif\n\nstatic void __net_exit ip6_flowlabel_net_exit(struct net *net)\n{\n\tip6_fl_purge(net);\n\tip6_flowlabel_proc_fini(net);\n}\n\nstatic struct pernet_operations ip6_flowlabel_net_ops = {\n\t.init = ip6_flowlabel_proc_init,\n\t.exit = ip6_flowlabel_net_exit,\n};\n\nint ip6_flowlabel_init(void)\n{\n\treturn register_pernet_subsys(&ip6_flowlabel_net_ops);\n}\n\nvoid ip6_flowlabel_cleanup(void)\n{\n\tstatic_key_deferred_flush(&ipv6_flowlabel_exclusive);\n\tdel_timer(&ip6_fl_gc_timer);\n\tunregister_pernet_subsys(&ip6_flowlabel_net_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}