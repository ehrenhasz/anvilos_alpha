{
  "module_name": "ah6.c",
  "hash_id": "7f1d67e0cfbe4d085bf580750252d54d81ad0109a950d088e8b4fe87bb2e20c8",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ah6.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <net/ip.h>\n#include <net/ah.h>\n#include <linux/crypto.h>\n#include <linux/pfkeyv2.h>\n#include <linux/string.h>\n#include <linux/scatterlist.h>\n#include <net/ip6_route.h>\n#include <net/icmp.h>\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\n#define IPV6HDR_BASELEN 8\n\nstruct tmp_ext {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tstruct in6_addr saddr;\n#endif\n\t\tstruct in6_addr daddr;\n\t\tchar hdrs[];\n};\n\nstruct ah_skb_cb {\n\tstruct xfrm_skb_cb xfrm;\n\tvoid *tmp;\n};\n\n#define AH_SKB_CB(__skb) ((struct ah_skb_cb *)&((__skb)->cb[0]))\n\nstatic void *ah_alloc_tmp(struct crypto_ahash *ahash, int nfrags,\n\t\t\t  unsigned int size)\n{\n\tunsigned int len;\n\n\tlen = size + crypto_ahash_digestsize(ahash) +\n\t      (crypto_ahash_alignmask(ahash) &\n\t       ~(crypto_tfm_ctx_alignment() - 1));\n\n\tlen = ALIGN(len, crypto_tfm_ctx_alignment());\n\n\tlen += sizeof(struct ahash_request) + crypto_ahash_reqsize(ahash);\n\tlen = ALIGN(len, __alignof__(struct scatterlist));\n\n\tlen += sizeof(struct scatterlist) * nfrags;\n\n\treturn kmalloc(len, GFP_ATOMIC);\n}\n\nstatic inline struct tmp_ext *ah_tmp_ext(void *base)\n{\n\treturn base + IPV6HDR_BASELEN;\n}\n\nstatic inline u8 *ah_tmp_auth(u8 *tmp, unsigned int offset)\n{\n\treturn tmp + offset;\n}\n\nstatic inline u8 *ah_tmp_icv(struct crypto_ahash *ahash, void *tmp,\n\t\t\t     unsigned int offset)\n{\n\treturn PTR_ALIGN((u8 *)tmp + offset, crypto_ahash_alignmask(ahash) + 1);\n}\n\nstatic inline struct ahash_request *ah_tmp_req(struct crypto_ahash *ahash,\n\t\t\t\t\t       u8 *icv)\n{\n\tstruct ahash_request *req;\n\n\treq = (void *)PTR_ALIGN(icv + crypto_ahash_digestsize(ahash),\n\t\t\t\tcrypto_tfm_ctx_alignment());\n\n\tahash_request_set_tfm(req, ahash);\n\n\treturn req;\n}\n\nstatic inline struct scatterlist *ah_req_sg(struct crypto_ahash *ahash,\n\t\t\t\t\t     struct ahash_request *req)\n{\n\treturn (void *)ALIGN((unsigned long)(req + 1) +\n\t\t\t     crypto_ahash_reqsize(ahash),\n\t\t\t     __alignof__(struct scatterlist));\n}\n\nstatic bool zero_out_mutable_opts(struct ipv6_opt_hdr *opthdr)\n{\n\tu8 *opt = (u8 *)opthdr;\n\tint len = ipv6_optlen(opthdr);\n\tint off = 0;\n\tint optlen = 0;\n\n\toff += 2;\n\tlen -= 2;\n\n\twhile (len > 0) {\n\n\t\tswitch (opt[off]) {\n\n\t\tcase IPV6_TLV_PAD1:\n\t\t\toptlen = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len < 2)\n\t\t\t\tgoto bad;\n\t\t\toptlen = opt[off+1]+2;\n\t\t\tif (len < optlen)\n\t\t\t\tgoto bad;\n\t\t\tif (opt[off] & 0x20)\n\t\t\t\tmemset(&opt[off+2], 0, opt[off+1]);\n\t\t\tbreak;\n\t\t}\n\n\t\toff += optlen;\n\t\tlen -= optlen;\n\t}\n\tif (len == 0)\n\t\treturn true;\n\nbad:\n\treturn false;\n}\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n \nstatic void ipv6_rearrange_destopt(struct ipv6hdr *iph, struct ipv6_opt_hdr *destopt)\n{\n\tu8 *opt = (u8 *)destopt;\n\tint len = ipv6_optlen(destopt);\n\tint off = 0;\n\tint optlen = 0;\n\n\toff += 2;\n\tlen -= 2;\n\n\twhile (len > 0) {\n\n\t\tswitch (opt[off]) {\n\n\t\tcase IPV6_TLV_PAD1:\n\t\t\toptlen = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len < 2)\n\t\t\t\tgoto bad;\n\t\t\toptlen = opt[off+1]+2;\n\t\t\tif (len < optlen)\n\t\t\t\tgoto bad;\n\n\t\t\t \n\t\t\tif (opt[off] == IPV6_TLV_HAO) {\n\t\t\t\tstruct ipv6_destopt_hao *hao;\n\n\t\t\t\thao = (struct ipv6_destopt_hao *)&opt[off];\n\t\t\t\tif (hao->length != sizeof(hao->addr)) {\n\t\t\t\t\tnet_warn_ratelimited(\"destopt hao: invalid header length: %u\\n\",\n\t\t\t\t\t\t\t     hao->length);\n\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\tswap(hao->addr, iph->saddr);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\toff += optlen;\n\t\tlen -= optlen;\n\t}\n\t \nbad:\n\treturn;\n}\n#else\nstatic void ipv6_rearrange_destopt(struct ipv6hdr *iph, struct ipv6_opt_hdr *destopt) {}\n#endif\n\n \nstatic void ipv6_rearrange_rthdr(struct ipv6hdr *iph, struct ipv6_rt_hdr *rthdr)\n{\n\tint segments, segments_left;\n\tstruct in6_addr *addrs;\n\tstruct in6_addr final_addr;\n\n\tsegments_left = rthdr->segments_left;\n\tif (segments_left == 0)\n\t\treturn;\n\trthdr->segments_left = 0;\n\n\t \n\tsegments = rthdr->hdrlen >> 1;\n\n\taddrs = ((struct rt0_hdr *)rthdr)->addr;\n\tfinal_addr = addrs[segments - 1];\n\n\taddrs += segments - segments_left;\n\tmemmove(addrs + 1, addrs, (segments_left - 1) * sizeof(*addrs));\n\n\taddrs[0] = iph->daddr;\n\tiph->daddr = final_addr;\n}\n\nstatic int ipv6_clear_mutable_options(struct ipv6hdr *iph, int len, int dir)\n{\n\tunion {\n\t\tstruct ipv6hdr *iph;\n\t\tstruct ipv6_opt_hdr *opth;\n\t\tstruct ipv6_rt_hdr *rth;\n\t\tchar *raw;\n\t} exthdr = { .iph = iph };\n\tchar *end = exthdr.raw + len;\n\tint nexthdr = iph->nexthdr;\n\n\texthdr.iph++;\n\n\twhile (exthdr.raw < end) {\n\t\tswitch (nexthdr) {\n\t\tcase NEXTHDR_DEST:\n\t\t\tif (dir == XFRM_POLICY_OUT)\n\t\t\t\tipv6_rearrange_destopt(iph, exthdr.opth);\n\t\t\tfallthrough;\n\t\tcase NEXTHDR_HOP:\n\t\t\tif (!zero_out_mutable_opts(exthdr.opth)) {\n\t\t\t\tnet_dbg_ratelimited(\"overrun %sopts\\n\",\n\t\t\t\t\t\t    nexthdr == NEXTHDR_HOP ?\n\t\t\t\t\t\t    \"hop\" : \"dest\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tipv6_rearrange_rthdr(iph, exthdr.rth);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\t\tnexthdr = exthdr.opth->nexthdr;\n\t\texthdr.raw += ipv6_optlen(exthdr.opth);\n\t}\n\n\treturn 0;\n}\n\nstatic void ah6_output_done(void *data, int err)\n{\n\tint extlen;\n\tu8 *iph_base;\n\tu8 *icv;\n\tstruct sk_buff *skb = data;\n\tstruct xfrm_state *x = skb_dst(skb)->xfrm;\n\tstruct ah_data *ahp = x->data;\n\tstruct ipv6hdr *top_iph = ipv6_hdr(skb);\n\tstruct ip_auth_hdr *ah = ip_auth_hdr(skb);\n\tstruct tmp_ext *iph_ext;\n\n\textlen = skb_network_header_len(skb) - sizeof(struct ipv6hdr);\n\tif (extlen)\n\t\textlen += sizeof(*iph_ext);\n\n\tiph_base = AH_SKB_CB(skb)->tmp;\n\tiph_ext = ah_tmp_ext(iph_base);\n\ticv = ah_tmp_icv(ahp->ahash, iph_ext, extlen);\n\n\tmemcpy(ah->auth_data, icv, ahp->icv_trunc_len);\n\tmemcpy(top_iph, iph_base, IPV6HDR_BASELEN);\n\n\tif (extlen) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tmemcpy(&top_iph->saddr, iph_ext, extlen);\n#else\n\t\tmemcpy(&top_iph->daddr, iph_ext, extlen);\n#endif\n\t}\n\n\tkfree(AH_SKB_CB(skb)->tmp);\n\txfrm_output_resume(skb->sk, skb, err);\n}\n\nstatic int ah6_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tint err;\n\tint nfrags;\n\tint extlen;\n\tu8 *iph_base;\n\tu8 *icv;\n\tu8 nexthdr;\n\tstruct sk_buff *trailer;\n\tstruct crypto_ahash *ahash;\n\tstruct ahash_request *req;\n\tstruct scatterlist *sg;\n\tstruct ipv6hdr *top_iph;\n\tstruct ip_auth_hdr *ah;\n\tstruct ah_data *ahp;\n\tstruct tmp_ext *iph_ext;\n\tint seqhi_len = 0;\n\t__be32 *seqhi;\n\tint sglists = 0;\n\tstruct scatterlist *seqhisg;\n\n\tahp = x->data;\n\tahash = ahp->ahash;\n\n\terr = skb_cow_data(skb, 0, &trailer);\n\tif (err < 0)\n\t\tgoto out;\n\tnfrags = err;\n\n\tskb_push(skb, -skb_network_offset(skb));\n\textlen = skb_network_header_len(skb) - sizeof(struct ipv6hdr);\n\tif (extlen)\n\t\textlen += sizeof(*iph_ext);\n\n\tif (x->props.flags & XFRM_STATE_ESN) {\n\t\tsglists = 1;\n\t\tseqhi_len = sizeof(*seqhi);\n\t}\n\terr = -ENOMEM;\n\tiph_base = ah_alloc_tmp(ahash, nfrags + sglists, IPV6HDR_BASELEN +\n\t\t\t\textlen + seqhi_len);\n\tif (!iph_base)\n\t\tgoto out;\n\n\tiph_ext = ah_tmp_ext(iph_base);\n\tseqhi = (__be32 *)((char *)iph_ext + extlen);\n\ticv = ah_tmp_icv(ahash, seqhi, seqhi_len);\n\treq = ah_tmp_req(ahash, icv);\n\tsg = ah_req_sg(ahash, req);\n\tseqhisg = sg + nfrags;\n\n\tah = ip_auth_hdr(skb);\n\tmemset(ah->auth_data, 0, ahp->icv_trunc_len);\n\n\ttop_iph = ipv6_hdr(skb);\n\ttop_iph->payload_len = htons(skb->len - sizeof(*top_iph));\n\n\tnexthdr = *skb_mac_header(skb);\n\t*skb_mac_header(skb) = IPPROTO_AH;\n\n\t \n\tmemcpy(iph_base, top_iph, IPV6HDR_BASELEN);\n\n\tif (extlen) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tmemcpy(iph_ext, &top_iph->saddr, extlen);\n#else\n\t\tmemcpy(iph_ext, &top_iph->daddr, extlen);\n#endif\n\t\terr = ipv6_clear_mutable_options(top_iph,\n\t\t\t\t\t\t extlen - sizeof(*iph_ext) +\n\t\t\t\t\t\t sizeof(*top_iph),\n\t\t\t\t\t\t XFRM_POLICY_OUT);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tah->nexthdr = nexthdr;\n\n\ttop_iph->priority    = 0;\n\ttop_iph->flow_lbl[0] = 0;\n\ttop_iph->flow_lbl[1] = 0;\n\ttop_iph->flow_lbl[2] = 0;\n\ttop_iph->hop_limit   = 0;\n\n\tah->hdrlen  = (XFRM_ALIGN8(sizeof(*ah) + ahp->icv_trunc_len) >> 2) - 2;\n\n\tah->reserved = 0;\n\tah->spi = x->id.spi;\n\tah->seq_no = htonl(XFRM_SKB_CB(skb)->seq.output.low);\n\n\tsg_init_table(sg, nfrags + sglists);\n\terr = skb_to_sgvec_nomark(skb, sg, 0, skb->len);\n\tif (unlikely(err < 0))\n\t\tgoto out_free;\n\n\tif (x->props.flags & XFRM_STATE_ESN) {\n\t\t \n\t\t*seqhi = htonl(XFRM_SKB_CB(skb)->seq.output.hi);\n\t\tsg_set_buf(seqhisg, seqhi, seqhi_len);\n\t}\n\tahash_request_set_crypt(req, sg, icv, skb->len + seqhi_len);\n\tahash_request_set_callback(req, 0, ah6_output_done, skb);\n\n\tAH_SKB_CB(skb)->tmp = iph_base;\n\n\terr = crypto_ahash_digest(req);\n\tif (err) {\n\t\tif (err == -EINPROGRESS)\n\t\t\tgoto out;\n\n\t\tif (err == -ENOSPC)\n\t\t\terr = NET_XMIT_DROP;\n\t\tgoto out_free;\n\t}\n\n\tmemcpy(ah->auth_data, icv, ahp->icv_trunc_len);\n\tmemcpy(top_iph, iph_base, IPV6HDR_BASELEN);\n\n\tif (extlen) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tmemcpy(&top_iph->saddr, iph_ext, extlen);\n#else\n\t\tmemcpy(&top_iph->daddr, iph_ext, extlen);\n#endif\n\t}\n\nout_free:\n\tkfree(iph_base);\nout:\n\treturn err;\n}\n\nstatic void ah6_input_done(void *data, int err)\n{\n\tu8 *auth_data;\n\tu8 *icv;\n\tu8 *work_iph;\n\tstruct sk_buff *skb = data;\n\tstruct xfrm_state *x = xfrm_input_state(skb);\n\tstruct ah_data *ahp = x->data;\n\tstruct ip_auth_hdr *ah = ip_auth_hdr(skb);\n\tint hdr_len = skb_network_header_len(skb);\n\tint ah_hlen = ipv6_authlen(ah);\n\n\tif (err)\n\t\tgoto out;\n\n\twork_iph = AH_SKB_CB(skb)->tmp;\n\tauth_data = ah_tmp_auth(work_iph, hdr_len);\n\ticv = ah_tmp_icv(ahp->ahash, auth_data, ahp->icv_trunc_len);\n\n\terr = crypto_memneq(icv, auth_data, ahp->icv_trunc_len) ? -EBADMSG : 0;\n\tif (err)\n\t\tgoto out;\n\n\terr = ah->nexthdr;\n\n\tskb->network_header += ah_hlen;\n\tmemcpy(skb_network_header(skb), work_iph, hdr_len);\n\t__skb_pull(skb, ah_hlen + hdr_len);\n\tif (x->props.mode == XFRM_MODE_TUNNEL)\n\t\tskb_reset_transport_header(skb);\n\telse\n\t\tskb_set_transport_header(skb, -hdr_len);\nout:\n\tkfree(AH_SKB_CB(skb)->tmp);\n\txfrm_input_resume(skb, err);\n}\n\n\n\nstatic int ah6_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\t \n\n\tu8 *auth_data;\n\tu8 *icv;\n\tu8 *work_iph;\n\tstruct sk_buff *trailer;\n\tstruct crypto_ahash *ahash;\n\tstruct ahash_request *req;\n\tstruct scatterlist *sg;\n\tstruct ip_auth_hdr *ah;\n\tstruct ipv6hdr *ip6h;\n\tstruct ah_data *ahp;\n\tu16 hdr_len;\n\tu16 ah_hlen;\n\tint nexthdr;\n\tint nfrags;\n\tint err = -ENOMEM;\n\tint seqhi_len = 0;\n\t__be32 *seqhi;\n\tint sglists = 0;\n\tstruct scatterlist *seqhisg;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ip_auth_hdr)))\n\t\tgoto out;\n\n\t \n\tif (skb_unclone(skb, GFP_ATOMIC))\n\t\tgoto out;\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\thdr_len = skb_network_header_len(skb);\n\tah = (struct ip_auth_hdr *)skb->data;\n\tahp = x->data;\n\tahash = ahp->ahash;\n\n\tnexthdr = ah->nexthdr;\n\tah_hlen = ipv6_authlen(ah);\n\n\tif (ah_hlen != XFRM_ALIGN8(sizeof(*ah) + ahp->icv_full_len) &&\n\t    ah_hlen != XFRM_ALIGN8(sizeof(*ah) + ahp->icv_trunc_len))\n\t\tgoto out;\n\n\tif (!pskb_may_pull(skb, ah_hlen))\n\t\tgoto out;\n\n\terr = skb_cow_data(skb, 0, &trailer);\n\tif (err < 0)\n\t\tgoto out;\n\tnfrags = err;\n\n\tah = (struct ip_auth_hdr *)skb->data;\n\tip6h = ipv6_hdr(skb);\n\n\tskb_push(skb, hdr_len);\n\n\tif (x->props.flags & XFRM_STATE_ESN) {\n\t\tsglists = 1;\n\t\tseqhi_len = sizeof(*seqhi);\n\t}\n\n\twork_iph = ah_alloc_tmp(ahash, nfrags + sglists, hdr_len +\n\t\t\t\tahp->icv_trunc_len + seqhi_len);\n\tif (!work_iph) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tauth_data = ah_tmp_auth((u8 *)work_iph, hdr_len);\n\tseqhi = (__be32 *)(auth_data + ahp->icv_trunc_len);\n\ticv = ah_tmp_icv(ahash, seqhi, seqhi_len);\n\treq = ah_tmp_req(ahash, icv);\n\tsg = ah_req_sg(ahash, req);\n\tseqhisg = sg + nfrags;\n\n\tmemcpy(work_iph, ip6h, hdr_len);\n\tmemcpy(auth_data, ah->auth_data, ahp->icv_trunc_len);\n\tmemset(ah->auth_data, 0, ahp->icv_trunc_len);\n\n\terr = ipv6_clear_mutable_options(ip6h, hdr_len, XFRM_POLICY_IN);\n\tif (err)\n\t\tgoto out_free;\n\n\tip6h->priority    = 0;\n\tip6h->flow_lbl[0] = 0;\n\tip6h->flow_lbl[1] = 0;\n\tip6h->flow_lbl[2] = 0;\n\tip6h->hop_limit   = 0;\n\n\tsg_init_table(sg, nfrags + sglists);\n\terr = skb_to_sgvec_nomark(skb, sg, 0, skb->len);\n\tif (unlikely(err < 0))\n\t\tgoto out_free;\n\n\tif (x->props.flags & XFRM_STATE_ESN) {\n\t\t \n\t\t*seqhi = XFRM_SKB_CB(skb)->seq.input.hi;\n\t\tsg_set_buf(seqhisg, seqhi, seqhi_len);\n\t}\n\n\tahash_request_set_crypt(req, sg, icv, skb->len + seqhi_len);\n\tahash_request_set_callback(req, 0, ah6_input_done, skb);\n\n\tAH_SKB_CB(skb)->tmp = work_iph;\n\n\terr = crypto_ahash_digest(req);\n\tif (err) {\n\t\tif (err == -EINPROGRESS)\n\t\t\tgoto out;\n\n\t\tgoto out_free;\n\t}\n\n\terr = crypto_memneq(icv, auth_data, ahp->icv_trunc_len) ? -EBADMSG : 0;\n\tif (err)\n\t\tgoto out_free;\n\n\tskb->network_header += ah_hlen;\n\tmemcpy(skb_network_header(skb), work_iph, hdr_len);\n\t__skb_pull(skb, ah_hlen + hdr_len);\n\n\tif (x->props.mode == XFRM_MODE_TUNNEL)\n\t\tskb_reset_transport_header(skb);\n\telse\n\t\tskb_set_transport_header(skb, -hdr_len);\n\n\terr = nexthdr;\n\nout_free:\n\tkfree(work_iph);\nout:\n\treturn err;\n}\n\nstatic int ah6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t   u8 type, u8 code, int offset, __be32 info)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct ipv6hdr *iph = (struct ipv6hdr *)skb->data;\n\tstruct ip_auth_hdr *ah = (struct ip_auth_hdr *)(skb->data+offset);\n\tstruct xfrm_state *x;\n\n\tif (type != ICMPV6_PKT_TOOBIG &&\n\t    type != NDISC_REDIRECT)\n\t\treturn 0;\n\n\tx = xfrm_state_lookup(net, skb->mark, (xfrm_address_t *)&iph->daddr, ah->spi, IPPROTO_AH, AF_INET6);\n\tif (!x)\n\t\treturn 0;\n\n\tif (type == NDISC_REDIRECT)\n\t\tip6_redirect(skb, net, skb->dev->ifindex, 0,\n\t\t\t     sock_net_uid(net, NULL));\n\telse\n\t\tip6_update_pmtu(skb, net, info, 0, 0, sock_net_uid(net, NULL));\n\txfrm_state_put(x);\n\n\treturn 0;\n}\n\nstatic int ah6_init_state(struct xfrm_state *x, struct netlink_ext_ack *extack)\n{\n\tstruct ah_data *ahp = NULL;\n\tstruct xfrm_algo_desc *aalg_desc;\n\tstruct crypto_ahash *ahash;\n\n\tif (!x->aalg) {\n\t\tNL_SET_ERR_MSG(extack, \"AH requires a state with an AUTH algorithm\");\n\t\tgoto error;\n\t}\n\n\tif (x->encap) {\n\t\tNL_SET_ERR_MSG(extack, \"AH is not compatible with encapsulation\");\n\t\tgoto error;\n\t}\n\n\tahp = kzalloc(sizeof(*ahp), GFP_KERNEL);\n\tif (!ahp)\n\t\treturn -ENOMEM;\n\n\tahash = crypto_alloc_ahash(x->aalg->alg_name, 0, 0);\n\tif (IS_ERR(ahash)) {\n\t\tNL_SET_ERR_MSG(extack, \"Kernel was unable to initialize cryptographic operations\");\n\t\tgoto error;\n\t}\n\n\tahp->ahash = ahash;\n\tif (crypto_ahash_setkey(ahash, x->aalg->alg_key,\n\t\t\t       (x->aalg->alg_key_len + 7) / 8)) {\n\t\tNL_SET_ERR_MSG(extack, \"Kernel was unable to initialize cryptographic operations\");\n\t\tgoto error;\n\t}\n\n\t \n\taalg_desc = xfrm_aalg_get_byname(x->aalg->alg_name, 0);\n\tBUG_ON(!aalg_desc);\n\n\tif (aalg_desc->uinfo.auth.icv_fullbits/8 !=\n\t    crypto_ahash_digestsize(ahash)) {\n\t\tNL_SET_ERR_MSG(extack, \"Kernel was unable to initialize cryptographic operations\");\n\t\tgoto error;\n\t}\n\n\tahp->icv_full_len = aalg_desc->uinfo.auth.icv_fullbits/8;\n\tahp->icv_trunc_len = x->aalg->alg_trunc_len/8;\n\n\tx->props.header_len = XFRM_ALIGN8(sizeof(struct ip_auth_hdr) +\n\t\t\t\t\t  ahp->icv_trunc_len);\n\tswitch (x->props.mode) {\n\tcase XFRM_MODE_BEET:\n\tcase XFRM_MODE_TRANSPORT:\n\t\tbreak;\n\tcase XFRM_MODE_TUNNEL:\n\t\tx->props.header_len += sizeof(struct ipv6hdr);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG(extack, \"Invalid mode requested for AH, must be one of TRANSPORT, TUNNEL, BEET\");\n\t\tgoto error;\n\t}\n\tx->data = ahp;\n\n\treturn 0;\n\nerror:\n\tif (ahp) {\n\t\tcrypto_free_ahash(ahp->ahash);\n\t\tkfree(ahp);\n\t}\n\treturn -EINVAL;\n}\n\nstatic void ah6_destroy(struct xfrm_state *x)\n{\n\tstruct ah_data *ahp = x->data;\n\n\tif (!ahp)\n\t\treturn;\n\n\tcrypto_free_ahash(ahp->ahash);\n\tkfree(ahp);\n}\n\nstatic int ah6_rcv_cb(struct sk_buff *skb, int err)\n{\n\treturn 0;\n}\n\nstatic const struct xfrm_type ah6_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.proto\t\t= IPPROTO_AH,\n\t.flags\t\t= XFRM_TYPE_REPLAY_PROT,\n\t.init_state\t= ah6_init_state,\n\t.destructor\t= ah6_destroy,\n\t.input\t\t= ah6_input,\n\t.output\t\t= ah6_output,\n};\n\nstatic struct xfrm6_protocol ah6_protocol = {\n\t.handler\t=\txfrm6_rcv,\n\t.input_handler\t=\txfrm_input,\n\t.cb_handler\t=\tah6_rcv_cb,\n\t.err_handler\t=\tah6_err,\n\t.priority\t=\t0,\n};\n\nstatic int __init ah6_init(void)\n{\n\tif (xfrm_register_type(&ah6_type, AF_INET6) < 0) {\n\t\tpr_info(\"%s: can't add xfrm type\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (xfrm6_protocol_register(&ah6_protocol, IPPROTO_AH) < 0) {\n\t\tpr_info(\"%s: can't add protocol\\n\", __func__);\n\t\txfrm_unregister_type(&ah6_type, AF_INET6);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit ah6_fini(void)\n{\n\tif (xfrm6_protocol_deregister(&ah6_protocol, IPPROTO_AH) < 0)\n\t\tpr_info(\"%s: can't remove protocol\\n\", __func__);\n\n\txfrm_unregister_type(&ah6_type, AF_INET6);\n}\n\nmodule_init(ah6_init);\nmodule_exit(ah6_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_XFRM_TYPE(AF_INET6, XFRM_PROTO_AH);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}