{
  "module_name": "seg6_iptunnel.c",
  "hash_id": "de59a585f3e2b3e3000415c297905cf9784dec70cf709f9f06ae091c57941259",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/seg6_iptunnel.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/net.h>\n#include <linux/module.h>\n#include <net/ip.h>\n#include <net/ip_tunnels.h>\n#include <net/lwtunnel.h>\n#include <net/netevent.h>\n#include <net/netns/generic.h>\n#include <net/ip6_fib.h>\n#include <net/route.h>\n#include <net/seg6.h>\n#include <linux/seg6.h>\n#include <linux/seg6_iptunnel.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/dst_cache.h>\n#ifdef CONFIG_IPV6_SEG6_HMAC\n#include <net/seg6_hmac.h>\n#endif\n#include <linux/netfilter.h>\n\nstatic size_t seg6_lwt_headroom(struct seg6_iptunnel_encap *tuninfo)\n{\n\tint head = 0;\n\n\tswitch (tuninfo->mode) {\n\tcase SEG6_IPTUN_MODE_INLINE:\n\t\tbreak;\n\tcase SEG6_IPTUN_MODE_ENCAP:\n\tcase SEG6_IPTUN_MODE_ENCAP_RED:\n\t\thead = sizeof(struct ipv6hdr);\n\t\tbreak;\n\tcase SEG6_IPTUN_MODE_L2ENCAP:\n\tcase SEG6_IPTUN_MODE_L2ENCAP_RED:\n\t\treturn 0;\n\t}\n\n\treturn ((tuninfo->srh->hdrlen + 1) << 3) + head;\n}\n\nstruct seg6_lwt {\n\tstruct dst_cache cache;\n\tstruct seg6_iptunnel_encap tuninfo[];\n};\n\nstatic inline struct seg6_lwt *seg6_lwt_lwtunnel(struct lwtunnel_state *lwt)\n{\n\treturn (struct seg6_lwt *)lwt->data;\n}\n\nstatic inline struct seg6_iptunnel_encap *\nseg6_encap_lwtunnel(struct lwtunnel_state *lwt)\n{\n\treturn seg6_lwt_lwtunnel(lwt)->tuninfo;\n}\n\nstatic const struct nla_policy seg6_iptunnel_policy[SEG6_IPTUNNEL_MAX + 1] = {\n\t[SEG6_IPTUNNEL_SRH]\t= { .type = NLA_BINARY },\n};\n\nstatic int nla_put_srh(struct sk_buff *skb, int attrtype,\n\t\t       struct seg6_iptunnel_encap *tuninfo)\n{\n\tstruct seg6_iptunnel_encap *data;\n\tstruct nlattr *nla;\n\tint len;\n\n\tlen = SEG6_IPTUN_ENCAP_SIZE(tuninfo);\n\n\tnla = nla_reserve(skb, attrtype, len);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tdata = nla_data(nla);\n\tmemcpy(data, tuninfo, len);\n\n\treturn 0;\n}\n\nstatic void set_tun_src(struct net *net, struct net_device *dev,\n\t\t\tstruct in6_addr *daddr, struct in6_addr *saddr)\n{\n\tstruct seg6_pernet_data *sdata = seg6_pernet(net);\n\tstruct in6_addr *tun_src;\n\n\trcu_read_lock();\n\n\ttun_src = rcu_dereference(sdata->tun_src);\n\n\tif (!ipv6_addr_any(tun_src)) {\n\t\tmemcpy(saddr, tun_src, sizeof(struct in6_addr));\n\t} else {\n\t\tipv6_dev_get_saddr(net, dev, daddr, IPV6_PREFER_SRC_PUBLIC,\n\t\t\t\t   saddr);\n\t}\n\n\trcu_read_unlock();\n}\n\n \nstatic __be32 seg6_make_flowlabel(struct net *net, struct sk_buff *skb,\n\t\t\t\t  struct ipv6hdr *inner_hdr)\n{\n\tint do_flowlabel = net->ipv6.sysctl.seg6_flowlabel;\n\t__be32 flowlabel = 0;\n\tu32 hash;\n\n\tif (do_flowlabel > 0) {\n\t\thash = skb_get_hash(skb);\n\t\thash = rol32(hash, 16);\n\t\tflowlabel = (__force __be32)hash & IPV6_FLOWLABEL_MASK;\n\t} else if (!do_flowlabel && skb->protocol == htons(ETH_P_IPV6)) {\n\t\tflowlabel = ip6_flowlabel(inner_hdr);\n\t}\n\treturn flowlabel;\n}\n\n \nint seg6_do_srh_encap(struct sk_buff *skb, struct ipv6_sr_hdr *osrh, int proto)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net *net = dev_net(dst->dev);\n\tstruct ipv6hdr *hdr, *inner_hdr;\n\tstruct ipv6_sr_hdr *isrh;\n\tint hdrlen, tot_len, err;\n\t__be32 flowlabel;\n\n\thdrlen = (osrh->hdrlen + 1) << 3;\n\ttot_len = hdrlen + sizeof(*hdr);\n\n\terr = skb_cow_head(skb, tot_len + skb->mac_len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tinner_hdr = ipv6_hdr(skb);\n\tflowlabel = seg6_make_flowlabel(net, skb, inner_hdr);\n\n\tskb_push(skb, tot_len);\n\tskb_reset_network_header(skb);\n\tskb_mac_header_rebuild(skb);\n\thdr = ipv6_hdr(skb);\n\n\t \n\n\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tip6_flow_hdr(hdr, ip6_tclass(ip6_flowinfo(inner_hdr)),\n\t\t\t     flowlabel);\n\t\thdr->hop_limit = inner_hdr->hop_limit;\n\t} else {\n\t\tip6_flow_hdr(hdr, 0, flowlabel);\n\t\thdr->hop_limit = ip6_dst_hoplimit(skb_dst(skb));\n\n\t\tmemset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));\n\n\t\t \n\t\tIP6CB(skb)->iif = skb->skb_iif;\n\t}\n\n\thdr->nexthdr = NEXTHDR_ROUTING;\n\n\tisrh = (void *)hdr + sizeof(*hdr);\n\tmemcpy(isrh, osrh, hdrlen);\n\n\tisrh->nexthdr = proto;\n\n\thdr->daddr = isrh->segments[isrh->first_segment];\n\tset_tun_src(net, dst->dev, &hdr->daddr, &hdr->saddr);\n\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\tif (sr_has_hmac(isrh)) {\n\t\terr = seg6_push_hmac(net, &hdr->saddr, isrh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t}\n#endif\n\n\thdr->payload_len = htons(skb->len - sizeof(struct ipv6hdr));\n\n\tskb_postpush_rcsum(skb, hdr, tot_len);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(seg6_do_srh_encap);\n\n \nstatic int seg6_do_srh_encap_red(struct sk_buff *skb,\n\t\t\t\t struct ipv6_sr_hdr *osrh, int proto)\n{\n\t__u8 first_seg = osrh->first_segment;\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net *net = dev_net(dst->dev);\n\tstruct ipv6hdr *hdr, *inner_hdr;\n\tint hdrlen = ipv6_optlen(osrh);\n\tint red_tlv_offset, tlv_offset;\n\tstruct ipv6_sr_hdr *isrh;\n\tbool skip_srh = false;\n\t__be32 flowlabel;\n\tint tot_len, err;\n\tint red_hdrlen;\n\tint tlvs_len;\n\n\tif (first_seg > 0) {\n\t\tred_hdrlen = hdrlen - sizeof(struct in6_addr);\n\t} else {\n\t\t \n\t\tskip_srh = !sr_has_hmac(osrh);\n\n\t\tred_hdrlen = skip_srh ? 0 : hdrlen;\n\t}\n\n\ttot_len = red_hdrlen + sizeof(struct ipv6hdr);\n\n\terr = skb_cow_head(skb, tot_len + skb->mac_len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tinner_hdr = ipv6_hdr(skb);\n\tflowlabel = seg6_make_flowlabel(net, skb, inner_hdr);\n\n\tskb_push(skb, tot_len);\n\tskb_reset_network_header(skb);\n\tskb_mac_header_rebuild(skb);\n\thdr = ipv6_hdr(skb);\n\n\t \n\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tip6_flow_hdr(hdr, ip6_tclass(ip6_flowinfo(inner_hdr)),\n\t\t\t     flowlabel);\n\t\thdr->hop_limit = inner_hdr->hop_limit;\n\t} else {\n\t\tip6_flow_hdr(hdr, 0, flowlabel);\n\t\thdr->hop_limit = ip6_dst_hoplimit(skb_dst(skb));\n\n\t\tmemset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));\n\t\tIP6CB(skb)->iif = skb->skb_iif;\n\t}\n\n\t \n\thdr->daddr = osrh->segments[first_seg];\n\n\tif (skip_srh) {\n\t\thdr->nexthdr = proto;\n\n\t\tset_tun_src(net, dst->dev, &hdr->daddr, &hdr->saddr);\n\t\tgoto out;\n\t}\n\n\t \n\n\thdr->nexthdr = NEXTHDR_ROUTING;\n\tisrh = (void *)hdr + sizeof(struct ipv6hdr);\n\n\tif (unlikely(!first_seg)) {\n\t\t \n\t\tmemcpy(isrh, osrh, hdrlen);\n\t\tgoto srcaddr;\n\t}\n\n\ttlv_offset = sizeof(*osrh) + (first_seg + 1) * sizeof(struct in6_addr);\n\tred_tlv_offset = tlv_offset - sizeof(struct in6_addr);\n\n\tmemcpy(isrh, osrh, red_tlv_offset);\n\n\ttlvs_len = hdrlen - tlv_offset;\n\tif (unlikely(tlvs_len > 0)) {\n\t\tconst void *s = (const void *)osrh + tlv_offset;\n\t\tvoid *d = (void *)isrh + red_tlv_offset;\n\n\t\tmemcpy(d, s, tlvs_len);\n\t}\n\n\t--isrh->first_segment;\n\tisrh->hdrlen -= 2;\n\nsrcaddr:\n\tisrh->nexthdr = proto;\n\tset_tun_src(net, dst->dev, &hdr->daddr, &hdr->saddr);\n\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\tif (unlikely(!skip_srh && sr_has_hmac(isrh))) {\n\t\terr = seg6_push_hmac(net, &hdr->saddr, isrh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t}\n#endif\n\nout:\n\thdr->payload_len = htons(skb->len - sizeof(struct ipv6hdr));\n\n\tskb_postpush_rcsum(skb, hdr, tot_len);\n\n\treturn 0;\n}\n\n \nint seg6_do_srh_inline(struct sk_buff *skb, struct ipv6_sr_hdr *osrh)\n{\n\tstruct ipv6hdr *hdr, *oldhdr;\n\tstruct ipv6_sr_hdr *isrh;\n\tint hdrlen, err;\n\n\thdrlen = (osrh->hdrlen + 1) << 3;\n\n\terr = skb_cow_head(skb, hdrlen + skb->mac_len);\n\tif (unlikely(err))\n\t\treturn err;\n\n\toldhdr = ipv6_hdr(skb);\n\n\tskb_pull(skb, sizeof(struct ipv6hdr));\n\tskb_postpull_rcsum(skb, skb_network_header(skb),\n\t\t\t   sizeof(struct ipv6hdr));\n\n\tskb_push(skb, sizeof(struct ipv6hdr) + hdrlen);\n\tskb_reset_network_header(skb);\n\tskb_mac_header_rebuild(skb);\n\n\thdr = ipv6_hdr(skb);\n\n\tmemmove(hdr, oldhdr, sizeof(*hdr));\n\n\tisrh = (void *)hdr + sizeof(*hdr);\n\tmemcpy(isrh, osrh, hdrlen);\n\n\tisrh->nexthdr = hdr->nexthdr;\n\thdr->nexthdr = NEXTHDR_ROUTING;\n\n\tisrh->segments[0] = hdr->daddr;\n\thdr->daddr = isrh->segments[isrh->first_segment];\n\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\tif (sr_has_hmac(isrh)) {\n\t\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\n\t\terr = seg6_push_hmac(net, &hdr->saddr, isrh);\n\t\tif (unlikely(err))\n\t\t\treturn err;\n\t}\n#endif\n\n\thdr->payload_len = htons(skb->len - sizeof(struct ipv6hdr));\n\n\tskb_postpush_rcsum(skb, hdr, sizeof(struct ipv6hdr) + hdrlen);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(seg6_do_srh_inline);\n\nstatic int seg6_do_srh(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct seg6_iptunnel_encap *tinfo;\n\tint proto, err = 0;\n\n\ttinfo = seg6_encap_lwtunnel(dst->lwtstate);\n\n\tswitch (tinfo->mode) {\n\tcase SEG6_IPTUN_MODE_INLINE:\n\t\tif (skb->protocol != htons(ETH_P_IPV6))\n\t\t\treturn -EINVAL;\n\n\t\terr = seg6_do_srh_inline(skb, tinfo->srh);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase SEG6_IPTUN_MODE_ENCAP:\n\tcase SEG6_IPTUN_MODE_ENCAP_RED:\n\t\terr = iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (skb->protocol == htons(ETH_P_IPV6))\n\t\t\tproto = IPPROTO_IPV6;\n\t\telse if (skb->protocol == htons(ETH_P_IP))\n\t\t\tproto = IPPROTO_IPIP;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (tinfo->mode == SEG6_IPTUN_MODE_ENCAP)\n\t\t\terr = seg6_do_srh_encap(skb, tinfo->srh, proto);\n\t\telse\n\t\t\terr = seg6_do_srh_encap_red(skb, tinfo->srh, proto);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tskb_set_inner_transport_header(skb, skb_transport_offset(skb));\n\t\tskb_set_inner_protocol(skb, skb->protocol);\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tbreak;\n\tcase SEG6_IPTUN_MODE_L2ENCAP:\n\tcase SEG6_IPTUN_MODE_L2ENCAP_RED:\n\t\tif (!skb_mac_header_was_set(skb))\n\t\t\treturn -EINVAL;\n\n\t\tif (pskb_expand_head(skb, skb->mac_len, 0, GFP_ATOMIC) < 0)\n\t\t\treturn -ENOMEM;\n\n\t\tskb_mac_header_rebuild(skb);\n\t\tskb_push(skb, skb->mac_len);\n\n\t\tif (tinfo->mode == SEG6_IPTUN_MODE_L2ENCAP)\n\t\t\terr = seg6_do_srh_encap(skb, tinfo->srh,\n\t\t\t\t\t\tIPPROTO_ETHERNET);\n\t\telse\n\t\t\terr = seg6_do_srh_encap_red(skb, tinfo->srh,\n\t\t\t\t\t\t    IPPROTO_ETHERNET);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tbreak;\n\t}\n\n\tskb_set_transport_header(skb, sizeof(struct ipv6hdr));\n\tnf_reset_ct(skb);\n\n\treturn 0;\n}\n\nstatic int seg6_input_finish(struct net *net, struct sock *sk,\n\t\t\t     struct sk_buff *skb)\n{\n\treturn dst_input(skb);\n}\n\nstatic int seg6_input_core(struct net *net, struct sock *sk,\n\t\t\t   struct sk_buff *skb)\n{\n\tstruct dst_entry *orig_dst = skb_dst(skb);\n\tstruct dst_entry *dst = NULL;\n\tstruct seg6_lwt *slwt;\n\tint err;\n\n\terr = seg6_do_srh(skb);\n\tif (unlikely(err)) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tslwt = seg6_lwt_lwtunnel(orig_dst->lwtstate);\n\n\tpreempt_disable();\n\tdst = dst_cache_get(&slwt->cache);\n\tpreempt_enable();\n\n\tif (!dst) {\n\t\tip6_route_input(skb);\n\t\tdst = skb_dst(skb);\n\t\tif (!dst->error) {\n\t\t\tpreempt_disable();\n\t\t\tdst_cache_set_ip6(&slwt->cache, dst,\n\t\t\t\t\t  &ipv6_hdr(skb)->saddr);\n\t\t\tpreempt_enable();\n\t\t}\n\t} else {\n\t\tskb_dst_drop(skb);\n\t\tskb_dst_set(skb, dst);\n\t}\n\n\terr = skb_cow_head(skb, LL_RESERVED_SPACE(dst->dev));\n\tif (unlikely(err))\n\t\treturn err;\n\n\tif (static_branch_unlikely(&nf_hooks_lwtunnel_enabled))\n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,\n\t\t\t       dev_net(skb->dev), NULL, skb, NULL,\n\t\t\t       skb_dst(skb)->dev, seg6_input_finish);\n\n\treturn seg6_input_finish(dev_net(skb->dev), NULL, skb);\n}\n\nstatic int seg6_input_nf(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb_dst(skb)->dev;\n\tstruct net *net = dev_net(skb->dev);\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\treturn NF_HOOK(NFPROTO_IPV4, NF_INET_POST_ROUTING, net, NULL,\n\t\t\t       skb, NULL, dev, seg6_input_core);\n\tcase htons(ETH_P_IPV6):\n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING, net, NULL,\n\t\t\t       skb, NULL, dev, seg6_input_core);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int seg6_input(struct sk_buff *skb)\n{\n\tif (static_branch_unlikely(&nf_hooks_lwtunnel_enabled))\n\t\treturn seg6_input_nf(skb);\n\n\treturn seg6_input_core(dev_net(skb->dev), NULL, skb);\n}\n\nstatic int seg6_output_core(struct net *net, struct sock *sk,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct dst_entry *orig_dst = skb_dst(skb);\n\tstruct dst_entry *dst = NULL;\n\tstruct seg6_lwt *slwt;\n\tint err;\n\n\terr = seg6_do_srh(skb);\n\tif (unlikely(err))\n\t\tgoto drop;\n\n\tslwt = seg6_lwt_lwtunnel(orig_dst->lwtstate);\n\n\tpreempt_disable();\n\tdst = dst_cache_get(&slwt->cache);\n\tpreempt_enable();\n\n\tif (unlikely(!dst)) {\n\t\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.daddr = hdr->daddr;\n\t\tfl6.saddr = hdr->saddr;\n\t\tfl6.flowlabel = ip6_flowinfo(hdr);\n\t\tfl6.flowi6_mark = skb->mark;\n\t\tfl6.flowi6_proto = hdr->nexthdr;\n\n\t\tdst = ip6_route_output(net, NULL, &fl6);\n\t\tif (dst->error) {\n\t\t\terr = dst->error;\n\t\t\tdst_release(dst);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tpreempt_disable();\n\t\tdst_cache_set_ip6(&slwt->cache, dst, &fl6.saddr);\n\t\tpreempt_enable();\n\t}\n\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, dst);\n\n\terr = skb_cow_head(skb, LL_RESERVED_SPACE(dst->dev));\n\tif (unlikely(err))\n\t\tgoto drop;\n\n\tif (static_branch_unlikely(&nf_hooks_lwtunnel_enabled))\n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, net, sk, skb,\n\t\t\t       NULL, skb_dst(skb)->dev, dst_output);\n\n\treturn dst_output(net, sk, skb);\ndrop:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int seg6_output_nf(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb_dst(skb)->dev;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\treturn NF_HOOK(NFPROTO_IPV4, NF_INET_POST_ROUTING, net, sk, skb,\n\t\t\t       NULL, dev, seg6_output_core);\n\tcase htons(ETH_P_IPV6):\n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING, net, sk, skb,\n\t\t\t       NULL, dev, seg6_output_core);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int seg6_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tif (static_branch_unlikely(&nf_hooks_lwtunnel_enabled))\n\t\treturn seg6_output_nf(net, sk, skb);\n\n\treturn seg6_output_core(net, sk, skb);\n}\n\nstatic int seg6_build_state(struct net *net, struct nlattr *nla,\n\t\t\t    unsigned int family, const void *cfg,\n\t\t\t    struct lwtunnel_state **ts,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[SEG6_IPTUNNEL_MAX + 1];\n\tstruct seg6_iptunnel_encap *tuninfo;\n\tstruct lwtunnel_state *newts;\n\tint tuninfo_len, min_size;\n\tstruct seg6_lwt *slwt;\n\tint err;\n\n\tif (family != AF_INET && family != AF_INET6)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, SEG6_IPTUNNEL_MAX, nla,\n\t\t\t\t\t  seg6_iptunnel_policy, extack);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[SEG6_IPTUNNEL_SRH])\n\t\treturn -EINVAL;\n\n\ttuninfo = nla_data(tb[SEG6_IPTUNNEL_SRH]);\n\ttuninfo_len = nla_len(tb[SEG6_IPTUNNEL_SRH]);\n\n\t \n\tmin_size = sizeof(*tuninfo) + sizeof(struct ipv6_sr_hdr) +\n\t\t   sizeof(struct in6_addr);\n\tif (tuninfo_len < min_size)\n\t\treturn -EINVAL;\n\n\tswitch (tuninfo->mode) {\n\tcase SEG6_IPTUN_MODE_INLINE:\n\t\tif (family != AF_INET6)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\tcase SEG6_IPTUN_MODE_ENCAP:\n\t\tbreak;\n\tcase SEG6_IPTUN_MODE_L2ENCAP:\n\t\tbreak;\n\tcase SEG6_IPTUN_MODE_ENCAP_RED:\n\t\tbreak;\n\tcase SEG6_IPTUN_MODE_L2ENCAP_RED:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!seg6_validate_srh(tuninfo->srh, tuninfo_len - sizeof(*tuninfo), false))\n\t\treturn -EINVAL;\n\n\tnewts = lwtunnel_state_alloc(tuninfo_len + sizeof(*slwt));\n\tif (!newts)\n\t\treturn -ENOMEM;\n\n\tslwt = seg6_lwt_lwtunnel(newts);\n\n\terr = dst_cache_init(&slwt->cache, GFP_ATOMIC);\n\tif (err) {\n\t\tkfree(newts);\n\t\treturn err;\n\t}\n\n\tmemcpy(&slwt->tuninfo, tuninfo, tuninfo_len);\n\n\tnewts->type = LWTUNNEL_ENCAP_SEG6;\n\tnewts->flags |= LWTUNNEL_STATE_INPUT_REDIRECT;\n\n\tif (tuninfo->mode != SEG6_IPTUN_MODE_L2ENCAP)\n\t\tnewts->flags |= LWTUNNEL_STATE_OUTPUT_REDIRECT;\n\n\tnewts->headroom = seg6_lwt_headroom(tuninfo);\n\n\t*ts = newts;\n\n\treturn 0;\n}\n\nstatic void seg6_destroy_state(struct lwtunnel_state *lwt)\n{\n\tdst_cache_destroy(&seg6_lwt_lwtunnel(lwt)->cache);\n}\n\nstatic int seg6_fill_encap_info(struct sk_buff *skb,\n\t\t\t\tstruct lwtunnel_state *lwtstate)\n{\n\tstruct seg6_iptunnel_encap *tuninfo = seg6_encap_lwtunnel(lwtstate);\n\n\tif (nla_put_srh(skb, SEG6_IPTUNNEL_SRH, tuninfo))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int seg6_encap_nlsize(struct lwtunnel_state *lwtstate)\n{\n\tstruct seg6_iptunnel_encap *tuninfo = seg6_encap_lwtunnel(lwtstate);\n\n\treturn nla_total_size(SEG6_IPTUN_ENCAP_SIZE(tuninfo));\n}\n\nstatic int seg6_encap_cmp(struct lwtunnel_state *a, struct lwtunnel_state *b)\n{\n\tstruct seg6_iptunnel_encap *a_hdr = seg6_encap_lwtunnel(a);\n\tstruct seg6_iptunnel_encap *b_hdr = seg6_encap_lwtunnel(b);\n\tint len = SEG6_IPTUN_ENCAP_SIZE(a_hdr);\n\n\tif (len != SEG6_IPTUN_ENCAP_SIZE(b_hdr))\n\t\treturn 1;\n\n\treturn memcmp(a_hdr, b_hdr, len);\n}\n\nstatic const struct lwtunnel_encap_ops seg6_iptun_ops = {\n\t.build_state = seg6_build_state,\n\t.destroy_state = seg6_destroy_state,\n\t.output = seg6_output,\n\t.input = seg6_input,\n\t.fill_encap = seg6_fill_encap_info,\n\t.get_encap_size = seg6_encap_nlsize,\n\t.cmp_encap = seg6_encap_cmp,\n\t.owner = THIS_MODULE,\n};\n\nint __init seg6_iptunnel_init(void)\n{\n\treturn lwtunnel_encap_add_ops(&seg6_iptun_ops, LWTUNNEL_ENCAP_SEG6);\n}\n\nvoid seg6_iptunnel_exit(void)\n{\n\tlwtunnel_encap_del_ops(&seg6_iptun_ops, LWTUNNEL_ENCAP_SEG6);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}