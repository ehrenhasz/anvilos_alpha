{
  "module_name": "addrconf_core.c",
  "hash_id": "5b2687035f101e19f16ae94bd012337a849cf60ec0e4f841dd26eade5a7b0fc1",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/addrconf_core.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <net/ipv6.h>\n#include <net/ipv6_stubs.h>\n#include <net/addrconf.h>\n#include <net/ip.h>\n\n \nvoid (*__fib6_flush_trees)(struct net *);\nEXPORT_SYMBOL(__fib6_flush_trees);\n\n#define IPV6_ADDR_SCOPE_TYPE(scope)\t((scope) << 16)\n\nstatic inline unsigned int ipv6_addr_scope2type(unsigned int scope)\n{\n\tswitch (scope) {\n\tcase IPV6_ADDR_SCOPE_NODELOCAL:\n\t\treturn (IPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_NODELOCAL) |\n\t\t\tIPV6_ADDR_LOOPBACK);\n\tcase IPV6_ADDR_SCOPE_LINKLOCAL:\n\t\treturn (IPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_LINKLOCAL) |\n\t\t\tIPV6_ADDR_LINKLOCAL);\n\tcase IPV6_ADDR_SCOPE_SITELOCAL:\n\t\treturn (IPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_SITELOCAL) |\n\t\t\tIPV6_ADDR_SITELOCAL);\n\t}\n\treturn IPV6_ADDR_SCOPE_TYPE(scope);\n}\n\nint __ipv6_addr_type(const struct in6_addr *addr)\n{\n\t__be32 st;\n\n\tst = addr->s6_addr32[0];\n\n\t \n\tif ((st & htonl(0xE0000000)) != htonl(0x00000000) &&\n\t    (st & htonl(0xE0000000)) != htonl(0xE0000000))\n\t\treturn (IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\n\n\tif ((st & htonl(0xFF000000)) == htonl(0xFF000000)) {\n\t\t \n\t\t \n\t\treturn (IPV6_ADDR_MULTICAST |\n\t\t\tipv6_addr_scope2type(IPV6_ADDR_MC_SCOPE(addr)));\n\t}\n\n\tif ((st & htonl(0xFFC00000)) == htonl(0xFE800000))\n\t\treturn (IPV6_ADDR_LINKLOCAL | IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_LINKLOCAL));\t\t \n\tif ((st & htonl(0xFFC00000)) == htonl(0xFEC00000))\n\t\treturn (IPV6_ADDR_SITELOCAL | IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_SITELOCAL));\t\t \n\tif ((st & htonl(0xFE000000)) == htonl(0xFC000000))\n\t\treturn (IPV6_ADDR_UNICAST |\n\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t\t\t \n\n\tif ((addr->s6_addr32[0] | addr->s6_addr32[1]) == 0) {\n\t\tif (addr->s6_addr32[2] == 0) {\n\t\t\tif (addr->s6_addr32[3] == 0)\n\t\t\t\treturn IPV6_ADDR_ANY;\n\n\t\t\tif (addr->s6_addr32[3] == htonl(0x00000001))\n\t\t\t\treturn (IPV6_ADDR_LOOPBACK | IPV6_ADDR_UNICAST |\n\t\t\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_LINKLOCAL));\t \n\n\t\t\treturn (IPV6_ADDR_COMPATv4 | IPV6_ADDR_UNICAST |\n\t\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t \n\t\t}\n\n\t\tif (addr->s6_addr32[2] == htonl(0x0000ffff))\n\t\t\treturn (IPV6_ADDR_MAPPED |\n\t\t\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t \n\t}\n\n\treturn (IPV6_ADDR_UNICAST |\n\t\tIPV6_ADDR_SCOPE_TYPE(IPV6_ADDR_SCOPE_GLOBAL));\t \n}\nEXPORT_SYMBOL(__ipv6_addr_type);\n\nstatic ATOMIC_NOTIFIER_HEAD(inet6addr_chain);\nstatic BLOCKING_NOTIFIER_HEAD(inet6addr_validator_chain);\n\nint register_inet6addr_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&inet6addr_chain, nb);\n}\nEXPORT_SYMBOL(register_inet6addr_notifier);\n\nint unregister_inet6addr_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&inet6addr_chain, nb);\n}\nEXPORT_SYMBOL(unregister_inet6addr_notifier);\n\nint inet6addr_notifier_call_chain(unsigned long val, void *v)\n{\n\treturn atomic_notifier_call_chain(&inet6addr_chain, val, v);\n}\nEXPORT_SYMBOL(inet6addr_notifier_call_chain);\n\nint register_inet6addr_validator_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&inet6addr_validator_chain, nb);\n}\nEXPORT_SYMBOL(register_inet6addr_validator_notifier);\n\nint unregister_inet6addr_validator_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&inet6addr_validator_chain,\n\t\t\t\t\t\t  nb);\n}\nEXPORT_SYMBOL(unregister_inet6addr_validator_notifier);\n\nint inet6addr_validator_notifier_call_chain(unsigned long val, void *v)\n{\n\treturn blocking_notifier_call_chain(&inet6addr_validator_chain, val, v);\n}\nEXPORT_SYMBOL(inet6addr_validator_notifier_call_chain);\n\nstatic struct dst_entry *eafnosupport_ipv6_dst_lookup_flow(struct net *net,\n\t\t\t\t\t\t\t   const struct sock *sk,\n\t\t\t\t\t\t\t   struct flowi6 *fl6,\n\t\t\t\t\t\t\t   const struct in6_addr *final_dst)\n{\n\treturn ERR_PTR(-EAFNOSUPPORT);\n}\n\nstatic int eafnosupport_ipv6_route_input(struct sk_buff *skb)\n{\n\treturn -EAFNOSUPPORT;\n}\n\nstatic struct fib6_table *eafnosupport_fib6_get_table(struct net *net, u32 id)\n{\n\treturn NULL;\n}\n\nstatic int\neafnosupport_fib6_table_lookup(struct net *net, struct fib6_table *table,\n\t\t\t       int oif, struct flowi6 *fl6,\n\t\t\t       struct fib6_result *res, int flags)\n{\n\treturn -EAFNOSUPPORT;\n}\n\nstatic int\neafnosupport_fib6_lookup(struct net *net, int oif, struct flowi6 *fl6,\n\t\t\t struct fib6_result *res, int flags)\n{\n\treturn -EAFNOSUPPORT;\n}\n\nstatic void\neafnosupport_fib6_select_path(const struct net *net, struct fib6_result *res,\n\t\t\t      struct flowi6 *fl6, int oif, bool have_oif_match,\n\t\t\t      const struct sk_buff *skb, int strict)\n{\n}\n\nstatic u32\neafnosupport_ip6_mtu_from_fib6(const struct fib6_result *res,\n\t\t\t       const struct in6_addr *daddr,\n\t\t\t       const struct in6_addr *saddr)\n{\n\treturn 0;\n}\n\nstatic int eafnosupport_fib6_nh_init(struct net *net, struct fib6_nh *fib6_nh,\n\t\t\t\t     struct fib6_config *cfg, gfp_t gfp_flags,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tNL_SET_ERR_MSG(extack, \"IPv6 support not enabled in kernel\");\n\treturn -EAFNOSUPPORT;\n}\n\nstatic int eafnosupport_ip6_del_rt(struct net *net, struct fib6_info *rt,\n\t\t\t\t   bool skip_notify)\n{\n\treturn -EAFNOSUPPORT;\n}\n\nstatic int eafnosupport_ipv6_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,\n\t\t\t\t      int (*output)(struct net *, struct sock *, struct sk_buff *))\n{\n\tkfree_skb(skb);\n\treturn -EAFNOSUPPORT;\n}\n\nstatic struct net_device *eafnosupport_ipv6_dev_find(struct net *net, const struct in6_addr *addr,\n\t\t\t\t\t\t     struct net_device *dev)\n{\n\treturn ERR_PTR(-EAFNOSUPPORT);\n}\n\nconst struct ipv6_stub *ipv6_stub __read_mostly = &(struct ipv6_stub) {\n\t.ipv6_dst_lookup_flow = eafnosupport_ipv6_dst_lookup_flow,\n\t.ipv6_route_input  = eafnosupport_ipv6_route_input,\n\t.fib6_get_table    = eafnosupport_fib6_get_table,\n\t.fib6_table_lookup = eafnosupport_fib6_table_lookup,\n\t.fib6_lookup       = eafnosupport_fib6_lookup,\n\t.fib6_select_path  = eafnosupport_fib6_select_path,\n\t.ip6_mtu_from_fib6 = eafnosupport_ip6_mtu_from_fib6,\n\t.fib6_nh_init\t   = eafnosupport_fib6_nh_init,\n\t.ip6_del_rt\t   = eafnosupport_ip6_del_rt,\n\t.ipv6_fragment\t   = eafnosupport_ipv6_fragment,\n\t.ipv6_dev_find     = eafnosupport_ipv6_dev_find,\n};\nEXPORT_SYMBOL_GPL(ipv6_stub);\n\n \nconst struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;\nEXPORT_SYMBOL(in6addr_loopback);\nconst struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;\nEXPORT_SYMBOL(in6addr_any);\nconst struct in6_addr in6addr_linklocal_allnodes = IN6ADDR_LINKLOCAL_ALLNODES_INIT;\nEXPORT_SYMBOL(in6addr_linklocal_allnodes);\nconst struct in6_addr in6addr_linklocal_allrouters = IN6ADDR_LINKLOCAL_ALLROUTERS_INIT;\nEXPORT_SYMBOL(in6addr_linklocal_allrouters);\nconst struct in6_addr in6addr_interfacelocal_allnodes = IN6ADDR_INTERFACELOCAL_ALLNODES_INIT;\nEXPORT_SYMBOL(in6addr_interfacelocal_allnodes);\nconst struct in6_addr in6addr_interfacelocal_allrouters = IN6ADDR_INTERFACELOCAL_ALLROUTERS_INIT;\nEXPORT_SYMBOL(in6addr_interfacelocal_allrouters);\nconst struct in6_addr in6addr_sitelocal_allrouters = IN6ADDR_SITELOCAL_ALLROUTERS_INIT;\nEXPORT_SYMBOL(in6addr_sitelocal_allrouters);\n\nstatic void snmp6_free_dev(struct inet6_dev *idev)\n{\n\tkfree(idev->stats.icmpv6msgdev);\n\tkfree(idev->stats.icmpv6dev);\n\tfree_percpu(idev->stats.ipv6);\n}\n\nstatic void in6_dev_finish_destroy_rcu(struct rcu_head *head)\n{\n\tstruct inet6_dev *idev = container_of(head, struct inet6_dev, rcu);\n\n\tsnmp6_free_dev(idev);\n\tkfree(idev);\n}\n\n \n\nvoid in6_dev_finish_destroy(struct inet6_dev *idev)\n{\n\tstruct net_device *dev = idev->dev;\n\n\tWARN_ON(!list_empty(&idev->addr_list));\n\tWARN_ON(rcu_access_pointer(idev->mc_list));\n\tWARN_ON(timer_pending(&idev->rs_timer));\n\n#ifdef NET_REFCNT_DEBUG\n\tpr_debug(\"%s: %s\\n\", __func__, dev ? dev->name : \"NIL\");\n#endif\n\tnetdev_put(dev, &idev->dev_tracker);\n\tif (!idev->dead) {\n\t\tpr_warn(\"Freeing alive inet6 device %p\\n\", idev);\n\t\treturn;\n\t}\n\tcall_rcu(&idev->rcu, in6_dev_finish_destroy_rcu);\n}\nEXPORT_SYMBOL(in6_dev_finish_destroy);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}