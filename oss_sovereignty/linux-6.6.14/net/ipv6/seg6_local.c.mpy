{
  "module_name": "seg6_local.c",
  "hash_id": "f55802e8764de839845fd8cf1d182b45779c94b740d4f4f9e0d36b9ba7662373",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/seg6_local.c",
  "human_readable_source": "\n \n\n#include <linux/filter.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/net.h>\n#include <linux/module.h>\n#include <net/ip.h>\n#include <net/lwtunnel.h>\n#include <net/netevent.h>\n#include <net/netns/generic.h>\n#include <net/ip6_fib.h>\n#include <net/route.h>\n#include <net/seg6.h>\n#include <linux/seg6.h>\n#include <linux/seg6_local.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/dst_cache.h>\n#include <net/ip_tunnels.h>\n#ifdef CONFIG_IPV6_SEG6_HMAC\n#include <net/seg6_hmac.h>\n#endif\n#include <net/seg6_local.h>\n#include <linux/etherdevice.h>\n#include <linux/bpf.h>\n#include <linux/netfilter.h>\n\n#define SEG6_F_ATTR(i)\t\tBIT(i)\n\nstruct seg6_local_lwt;\n\n \nstruct seg6_local_lwtunnel_ops {\n\tint (*build_state)(struct seg6_local_lwt *slwt, const void *cfg,\n\t\t\t   struct netlink_ext_ack *extack);\n\tvoid (*destroy_state)(struct seg6_local_lwt *slwt);\n};\n\nstruct seg6_action_desc {\n\tint action;\n\tunsigned long attrs;\n\n\t \n\tunsigned long optattrs;\n\n\tint (*input)(struct sk_buff *skb, struct seg6_local_lwt *slwt);\n\tint static_headroom;\n\n\tstruct seg6_local_lwtunnel_ops slwt_ops;\n};\n\nstruct bpf_lwt_prog {\n\tstruct bpf_prog *prog;\n\tchar *name;\n};\n\n \n#define SEG6_LOCAL_LCBLOCK_DBITS\t32\n#define SEG6_LOCAL_LCNODE_FN_DBITS\t16\n\n \n#define next_csid_chk_cntr_bits(blen, flen)\t\t\\\n\t((blen) + (flen) > 128)\n\n#define next_csid_chk_lcblock_bits(blen)\t\t\\\n({\t\t\t\t\t\t\t\\\n\ttypeof(blen) __tmp = blen;\t\t\t\\\n\t(!__tmp || __tmp > 120 || (__tmp & 0x07));\t\\\n})\n\n#define next_csid_chk_lcnode_fn_bits(flen)\t\t\\\n\tnext_csid_chk_lcblock_bits(flen)\n\n \n#define SEG6_F_LOCAL_FLAVORS\t\tSEG6_F_ATTR(SEG6_LOCAL_FLAVORS)\n\n#define SEG6_F_LOCAL_FLV_OP(flvname)\tBIT(SEG6_LOCAL_FLV_OP_##flvname)\n#define SEG6_F_LOCAL_FLV_NEXT_CSID\tSEG6_F_LOCAL_FLV_OP(NEXT_CSID)\n#define SEG6_F_LOCAL_FLV_PSP\t\tSEG6_F_LOCAL_FLV_OP(PSP)\n\n \n#define SEG6_LOCAL_FLV8986_SUPP_OPS\tSEG6_F_LOCAL_FLV_PSP\n\n#define SEG6_LOCAL_END_FLV_SUPP_OPS\t(SEG6_F_LOCAL_FLV_NEXT_CSID | \\\n\t\t\t\t\t SEG6_LOCAL_FLV8986_SUPP_OPS)\n#define SEG6_LOCAL_END_X_FLV_SUPP_OPS\tSEG6_F_LOCAL_FLV_NEXT_CSID\n\nstruct seg6_flavors_info {\n\t \n\t__u32 flv_ops;\n\n\t \n\t__u8 lcblock_bits;\n\t \n\t__u8 lcnode_func_bits;\n};\n\nenum seg6_end_dt_mode {\n\tDT_INVALID_MODE\t= -EINVAL,\n\tDT_LEGACY_MODE\t= 0,\n\tDT_VRF_MODE\t= 1,\n};\n\nstruct seg6_end_dt_info {\n\tenum seg6_end_dt_mode mode;\n\n\tstruct net *net;\n\t \n\tint vrf_ifindex;\n\tint vrf_table;\n\n\t \n\tu16 family;\n};\n\nstruct pcpu_seg6_local_counters {\n\tu64_stats_t packets;\n\tu64_stats_t bytes;\n\tu64_stats_t errors;\n\n\tstruct u64_stats_sync syncp;\n};\n\n \nstruct seg6_local_counters {\n\t__u64 packets;\n\t__u64 bytes;\n\t__u64 errors;\n};\n\n#define seg6_local_alloc_pcpu_counters(__gfp)\t\t\t\t\\\n\t__netdev_alloc_pcpu_stats(struct pcpu_seg6_local_counters,\t\\\n\t\t\t\t  ((__gfp) | __GFP_ZERO))\n\n#define SEG6_F_LOCAL_COUNTERS\tSEG6_F_ATTR(SEG6_LOCAL_COUNTERS)\n\nstruct seg6_local_lwt {\n\tint action;\n\tstruct ipv6_sr_hdr *srh;\n\tint table;\n\tstruct in_addr nh4;\n\tstruct in6_addr nh6;\n\tint iif;\n\tint oif;\n\tstruct bpf_lwt_prog bpf;\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\tstruct seg6_end_dt_info dt_info;\n#endif\n\tstruct seg6_flavors_info flv_info;\n\n\tstruct pcpu_seg6_local_counters __percpu *pcpu_counters;\n\n\tint headroom;\n\tstruct seg6_action_desc *desc;\n\t \n\tunsigned long parsed_optattrs;\n};\n\nstatic struct seg6_local_lwt *seg6_local_lwtunnel(struct lwtunnel_state *lwt)\n{\n\treturn (struct seg6_local_lwt *)lwt->data;\n}\n\nstatic struct ipv6_sr_hdr *get_and_validate_srh(struct sk_buff *skb)\n{\n\tstruct ipv6_sr_hdr *srh;\n\n\tsrh = seg6_get_srh(skb, IP6_FH_F_SKIP_RH);\n\tif (!srh)\n\t\treturn NULL;\n\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\tif (!seg6_hmac_validate_skb(skb))\n\t\treturn NULL;\n#endif\n\n\treturn srh;\n}\n\nstatic bool decap_and_validate(struct sk_buff *skb, int proto)\n{\n\tstruct ipv6_sr_hdr *srh;\n\tunsigned int off = 0;\n\n\tsrh = seg6_get_srh(skb, 0);\n\tif (srh && srh->segments_left > 0)\n\t\treturn false;\n\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\tif (srh && !seg6_hmac_validate_skb(skb))\n\t\treturn false;\n#endif\n\n\tif (ipv6_find_hdr(skb, &off, proto, NULL, NULL) < 0)\n\t\treturn false;\n\n\tif (!pskb_pull(skb, off))\n\t\treturn false;\n\n\tskb_postpull_rcsum(skb, skb_network_header(skb), off);\n\n\tskb_reset_network_header(skb);\n\tskb_reset_transport_header(skb);\n\tif (iptunnel_pull_offloads(skb))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void advance_nextseg(struct ipv6_sr_hdr *srh, struct in6_addr *daddr)\n{\n\tstruct in6_addr *addr;\n\n\tsrh->segments_left--;\n\taddr = srh->segments + srh->segments_left;\n\t*daddr = *addr;\n}\n\nstatic int\nseg6_lookup_any_nexthop(struct sk_buff *skb, struct in6_addr *nhaddr,\n\t\t\tu32 tbl_id, bool local_delivery)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\tint flags = RT6_LOOKUP_F_HAS_SADDR;\n\tstruct dst_entry *dst = NULL;\n\tstruct rt6_info *rt;\n\tstruct flowi6 fl6;\n\tint dev_flags = 0;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_iif = skb->dev->ifindex;\n\tfl6.daddr = nhaddr ? *nhaddr : hdr->daddr;\n\tfl6.saddr = hdr->saddr;\n\tfl6.flowlabel = ip6_flowinfo(hdr);\n\tfl6.flowi6_mark = skb->mark;\n\tfl6.flowi6_proto = hdr->nexthdr;\n\n\tif (nhaddr)\n\t\tfl6.flowi6_flags = FLOWI_FLAG_KNOWN_NH;\n\n\tif (!tbl_id) {\n\t\tdst = ip6_route_input_lookup(net, skb->dev, &fl6, skb, flags);\n\t} else {\n\t\tstruct fib6_table *table;\n\n\t\ttable = fib6_get_table(net, tbl_id);\n\t\tif (!table)\n\t\t\tgoto out;\n\n\t\trt = ip6_pol_route(net, table, 0, &fl6, skb, flags);\n\t\tdst = &rt->dst;\n\t}\n\n\t \n\tif (!local_delivery)\n\t\tdev_flags |= IFF_LOOPBACK;\n\n\tif (dst && (dst->dev->flags & dev_flags) && !dst->error) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\nout:\n\tif (!dst) {\n\t\trt = net->ipv6.ip6_blk_hole_entry;\n\t\tdst = &rt->dst;\n\t\tdst_hold(dst);\n\t}\n\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, dst);\n\treturn dst->error;\n}\n\nint seg6_lookup_nexthop(struct sk_buff *skb,\n\t\t\tstruct in6_addr *nhaddr, u32 tbl_id)\n{\n\treturn seg6_lookup_any_nexthop(skb, nhaddr, tbl_id, false);\n}\n\nstatic __u8 seg6_flv_lcblock_octects(const struct seg6_flavors_info *finfo)\n{\n\treturn finfo->lcblock_bits >> 3;\n}\n\nstatic __u8 seg6_flv_lcnode_func_octects(const struct seg6_flavors_info *finfo)\n{\n\treturn finfo->lcnode_func_bits >> 3;\n}\n\nstatic bool seg6_next_csid_is_arg_zero(const struct in6_addr *addr,\n\t\t\t\t       const struct seg6_flavors_info *finfo)\n{\n\t__u8 fnc_octects = seg6_flv_lcnode_func_octects(finfo);\n\t__u8 blk_octects = seg6_flv_lcblock_octects(finfo);\n\t__u8 arg_octects;\n\tint i;\n\n\targ_octects = 16 - blk_octects - fnc_octects;\n\tfor (i = 0; i < arg_octects; ++i) {\n\t\tif (addr->s6_addr[blk_octects + fnc_octects + i] != 0x00)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic void seg6_next_csid_advance_arg(struct in6_addr *addr,\n\t\t\t\t       const struct seg6_flavors_info *finfo)\n{\n\t__u8 fnc_octects = seg6_flv_lcnode_func_octects(finfo);\n\t__u8 blk_octects = seg6_flv_lcblock_octects(finfo);\n\n\t \n\tmemmove(&addr->s6_addr[blk_octects],\n\t\t&addr->s6_addr[blk_octects + fnc_octects],\n\t\t16 - blk_octects - fnc_octects);\n\n\tmemset(&addr->s6_addr[16 - fnc_octects], 0x00, fnc_octects);\n}\n\nstatic int input_action_end_finish(struct sk_buff *skb,\n\t\t\t\t   struct seg6_local_lwt *slwt)\n{\n\tseg6_lookup_nexthop(skb, NULL, 0);\n\n\treturn dst_input(skb);\n}\n\nstatic int input_action_end_core(struct sk_buff *skb,\n\t\t\t\t struct seg6_local_lwt *slwt)\n{\n\tstruct ipv6_sr_hdr *srh;\n\n\tsrh = get_and_validate_srh(skb);\n\tif (!srh)\n\t\tgoto drop;\n\n\tadvance_nextseg(srh, &ipv6_hdr(skb)->daddr);\n\n\treturn input_action_end_finish(skb, slwt);\n\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int end_next_csid_core(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tconst struct seg6_flavors_info *finfo = &slwt->flv_info;\n\tstruct in6_addr *daddr = &ipv6_hdr(skb)->daddr;\n\n\tif (seg6_next_csid_is_arg_zero(daddr, finfo))\n\t\treturn input_action_end_core(skb, slwt);\n\n\t \n\tseg6_next_csid_advance_arg(daddr, finfo);\n\n\treturn input_action_end_finish(skb, slwt);\n}\n\nstatic int input_action_end_x_finish(struct sk_buff *skb,\n\t\t\t\t     struct seg6_local_lwt *slwt)\n{\n\tseg6_lookup_nexthop(skb, &slwt->nh6, 0);\n\n\treturn dst_input(skb);\n}\n\nstatic int input_action_end_x_core(struct sk_buff *skb,\n\t\t\t\t   struct seg6_local_lwt *slwt)\n{\n\tstruct ipv6_sr_hdr *srh;\n\n\tsrh = get_and_validate_srh(skb);\n\tif (!srh)\n\t\tgoto drop;\n\n\tadvance_nextseg(srh, &ipv6_hdr(skb)->daddr);\n\n\treturn input_action_end_x_finish(skb, slwt);\n\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int end_x_next_csid_core(struct sk_buff *skb,\n\t\t\t\tstruct seg6_local_lwt *slwt)\n{\n\tconst struct seg6_flavors_info *finfo = &slwt->flv_info;\n\tstruct in6_addr *daddr = &ipv6_hdr(skb)->daddr;\n\n\tif (seg6_next_csid_is_arg_zero(daddr, finfo))\n\t\treturn input_action_end_x_core(skb, slwt);\n\n\t \n\tseg6_next_csid_advance_arg(daddr, finfo);\n\n\treturn input_action_end_x_finish(skb, slwt);\n}\n\nstatic bool seg6_next_csid_enabled(__u32 fops)\n{\n\treturn fops & SEG6_F_LOCAL_FLV_NEXT_CSID;\n}\n\n \nstatic int seg6_flv_supp_ops_by_action(int action, __u32 *fops)\n{\n\tswitch (action) {\n\tcase SEG6_LOCAL_ACTION_END:\n\t\t*fops = SEG6_LOCAL_END_FLV_SUPP_OPS;\n\t\tbreak;\n\tcase SEG6_LOCAL_ACTION_END_X:\n\t\t*fops = SEG6_LOCAL_END_X_FLV_SUPP_OPS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nenum seg6_local_pktinfo {\n\t \n\tSEG6_LOCAL_PKTINFO_NOHDR\t= 0,\n\tSEG6_LOCAL_PKTINFO_SL_ZERO,\n\tSEG6_LOCAL_PKTINFO_SL_ONE,\n\tSEG6_LOCAL_PKTINFO_SL_MORE,\n\t__SEG6_LOCAL_PKTINFO_MAX,\n};\n\n#define SEG6_LOCAL_PKTINFO_MAX (__SEG6_LOCAL_PKTINFO_MAX - 1)\n\nstatic enum seg6_local_pktinfo seg6_get_srh_pktinfo(struct ipv6_sr_hdr *srh)\n{\n\t__u8 sgl;\n\n\tif (!srh)\n\t\treturn SEG6_LOCAL_PKTINFO_NOHDR;\n\n\tsgl = srh->segments_left;\n\tif (sgl < 2)\n\t\treturn SEG6_LOCAL_PKTINFO_SL_ZERO + sgl;\n\n\treturn SEG6_LOCAL_PKTINFO_SL_MORE;\n}\n\nenum seg6_local_flv_action {\n\tSEG6_LOCAL_FLV_ACT_UNSPEC\t= 0,\n\tSEG6_LOCAL_FLV_ACT_END,\n\tSEG6_LOCAL_FLV_ACT_PSP,\n\tSEG6_LOCAL_FLV_ACT_USP,\n\tSEG6_LOCAL_FLV_ACT_USD,\n\t__SEG6_LOCAL_FLV_ACT_MAX\n};\n\n#define SEG6_LOCAL_FLV_ACT_MAX (__SEG6_LOCAL_FLV_ACT_MAX - 1)\n\n \n#define flv8986_act_tbl_idx(pf, fm)\t\t\t\t\t\\\n\t((((pf) << bits_per(SEG6_LOCAL_FLV8986_SUPP_OPS)) |\t\t\\\n\t  ((fm) & SEG6_LOCAL_FLV8986_SUPP_OPS)) >> SEG6_LOCAL_FLV_OP_PSP)\n\n \n#define FLV8986_ACT_TBL_SIZE\t\t\t\t\t\t\\\n\troundup_pow_of_two(flv8986_act_tbl_idx(SEG6_LOCAL_PKTINFO_MAX,\t\\\n\t\t\t\t\t       SEG6_LOCAL_FLV8986_SUPP_OPS))\n\n \n#define tbl_cfg(act, pf, fm)\t\t\t\t\t\t\\\n\t[flv8986_act_tbl_idx(SEG6_LOCAL_PKTINFO_##pf,\t\t\t\\\n\t\t\t     (fm))] = SEG6_LOCAL_FLV_ACT_##act\n\n \n#define F_PSP\tSEG6_F_LOCAL_FLV_PSP\n\n \nstatic const u8 flv8986_act_tbl[FLV8986_ACT_TBL_SIZE] = {\n\t \n\ttbl_cfg(PSP, SL_ONE, F_PSP),\n\t \n\ttbl_cfg(END, SL_MORE, F_PSP),\n};\n\n#undef F_PSP\n#undef tbl_cfg\n\n \nstatic enum seg6_local_flv_action\nseg6_local_flv8986_act_lookup(enum seg6_local_pktinfo pinfo, __u32 flvmask)\n{\n\tunsigned long index;\n\n\t \n\tif (unlikely(flvmask & ~SEG6_LOCAL_FLV8986_SUPP_OPS))\n\t\treturn SEG6_LOCAL_FLV_ACT_UNSPEC;\n\n\tindex = flv8986_act_tbl_idx(pinfo, flvmask);\n\tif (unlikely(index >= FLV8986_ACT_TBL_SIZE))\n\t\treturn SEG6_LOCAL_FLV_ACT_UNSPEC;\n\n\treturn flv8986_act_tbl[index];\n}\n\n \nstatic bool seg6_pop_srh(struct sk_buff *skb, int srhoff)\n{\n\tstruct ipv6_sr_hdr *srh;\n\tstruct ipv6hdr *iph;\n\t__u8 srh_nexthdr;\n\tint thoff = -1;\n\tint srhlen;\n\tint nhlen;\n\n\tif (unlikely(srhoff < sizeof(*iph) ||\n\t\t     !pskb_may_pull(skb, srhoff + sizeof(*srh))))\n\t\treturn false;\n\n\tsrh = (struct ipv6_sr_hdr *)(skb->data + srhoff);\n\tsrhlen = ipv6_optlen(srh);\n\n\t \n\tif (unlikely(skb_ensure_writable(skb, srhoff + srhlen)))\n\t\treturn false;\n\n\t \n\tsrh = (struct ipv6_sr_hdr *)(skb->data + srhoff);\n\tsrh_nexthdr = srh->nexthdr;\n\n\tif (unlikely(!skb_transport_header_was_set(skb)))\n\t\tgoto pull;\n\n\tnhlen = skb_network_header_len(skb);\n\t \n\tif (likely(nhlen <= srhoff))\n\t\tthoff = nhlen;\n\telse if (nhlen >= srhoff + srhlen)\n\t\t \n\t\tthoff = nhlen - srhlen;\n\telse\n\t\t \n\t\treturn false;\npull:\n\t \n\tskb_pull_rcsum(skb, srhoff + srhlen);\n\tmemmove(skb_network_header(skb) + srhlen, skb_network_header(skb),\n\t\tsrhoff);\n\tskb_push(skb, srhoff);\n\n\tskb_reset_network_header(skb);\n\tskb_mac_header_rebuild(skb);\n\tif (likely(thoff >= 0))\n\t\tskb_set_transport_header(skb, thoff);\n\n\tiph = ipv6_hdr(skb);\n\tif (iph->nexthdr == NEXTHDR_ROUTING) {\n\t\tiph->nexthdr = srh_nexthdr;\n\t} else {\n\t\t \n\t\tunsigned int off = sizeof(*iph);\n\t\tstruct ipv6_opt_hdr *hp, _hdr;\n\t\t__u8 nexthdr = iph->nexthdr;\n\n\t\tfor (;;) {\n\t\t\tif (unlikely(!ipv6_ext_hdr(nexthdr) ||\n\t\t\t\t     nexthdr == NEXTHDR_NONE))\n\t\t\t\treturn false;\n\n\t\t\thp = skb_header_pointer(skb, off, sizeof(_hdr), &_hdr);\n\t\t\tif (unlikely(!hp))\n\t\t\t\treturn false;\n\n\t\t\tif (hp->nexthdr == NEXTHDR_ROUTING) {\n\t\t\t\thp->nexthdr = srh_nexthdr;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (nexthdr) {\n\t\t\tcase NEXTHDR_FRAGMENT:\n\t\t\t\tfallthrough;\n\t\t\tcase NEXTHDR_AUTH:\n\t\t\t\t \n\t\t\t\treturn false;\n\t\t\tdefault:\n\t\t\t\toff += ipv6_optlen(hp);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnexthdr = hp->nexthdr;\n\t\t}\n\t}\n\n\tiph->payload_len = htons(skb->len - sizeof(struct ipv6hdr));\n\n\tskb_postpush_rcsum(skb, iph, srhoff);\n\n\treturn true;\n}\n\n \nstatic int end_flv8986_core(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tconst struct seg6_flavors_info *finfo = &slwt->flv_info;\n\tenum seg6_local_flv_action action;\n\tenum seg6_local_pktinfo pinfo;\n\tstruct ipv6_sr_hdr *srh;\n\t__u32 flvmask;\n\tint srhoff;\n\n\tsrh = seg6_get_srh(skb, 0);\n\tsrhoff = srh ? ((unsigned char *)srh - skb->data) : 0;\n\tpinfo = seg6_get_srh_pktinfo(srh);\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\tif (srh && !seg6_hmac_validate_skb(skb))\n\t\tgoto drop;\n#endif\n\tflvmask = finfo->flv_ops;\n\tif (unlikely(flvmask & ~SEG6_LOCAL_FLV8986_SUPP_OPS)) {\n\t\tpr_warn_once(\"seg6local: invalid RFC8986 flavors\\n\");\n\t\tgoto drop;\n\t}\n\n\t \n\taction = seg6_local_flv8986_act_lookup(pinfo, flvmask);\n\tswitch (action) {\n\tcase SEG6_LOCAL_FLV_ACT_END:\n\t\t \n\t\tadvance_nextseg(srh, &ipv6_hdr(skb)->daddr);\n\t\tbreak;\n\tcase SEG6_LOCAL_FLV_ACT_PSP:\n\t\tadvance_nextseg(srh, &ipv6_hdr(skb)->daddr);\n\n\t\tif (unlikely(!seg6_pop_srh(skb, srhoff)))\n\t\t\tgoto drop;\n\t\tbreak;\n\tcase SEG6_LOCAL_FLV_ACT_UNSPEC:\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tgoto drop;\n\t}\n\n\treturn input_action_end_finish(skb, slwt);\n\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\n \nstatic int input_action_end(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tconst struct seg6_flavors_info *finfo = &slwt->flv_info;\n\t__u32 fops = finfo->flv_ops;\n\n\tif (!fops)\n\t\treturn input_action_end_core(skb, slwt);\n\n\t \n\tif (seg6_next_csid_enabled(fops))\n\t\treturn end_next_csid_core(skb, slwt);\n\n\t \n\treturn end_flv8986_core(skb, slwt);\n}\n\n \nstatic int input_action_end_x(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tconst struct seg6_flavors_info *finfo = &slwt->flv_info;\n\t__u32 fops = finfo->flv_ops;\n\n\t \n\tif (seg6_next_csid_enabled(fops))\n\t\treturn end_x_next_csid_core(skb, slwt);\n\n\treturn input_action_end_x_core(skb, slwt);\n}\n\nstatic int input_action_end_t(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tstruct ipv6_sr_hdr *srh;\n\n\tsrh = get_and_validate_srh(skb);\n\tif (!srh)\n\t\tgoto drop;\n\n\tadvance_nextseg(srh, &ipv6_hdr(skb)->daddr);\n\n\tseg6_lookup_nexthop(skb, NULL, slwt->table);\n\n\treturn dst_input(skb);\n\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\n \nstatic int input_action_end_dx2(struct sk_buff *skb,\n\t\t\t\tstruct seg6_local_lwt *slwt)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct net_device *odev;\n\tstruct ethhdr *eth;\n\n\tif (!decap_and_validate(skb, IPPROTO_ETHERNET))\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, ETH_HLEN))\n\t\tgoto drop;\n\n\tskb_reset_mac_header(skb);\n\teth = (struct ethhdr *)skb->data;\n\n\t \n\tif (!eth_proto_is_802_3(eth->h_proto))\n\t\tgoto drop;\n\n\todev = dev_get_by_index_rcu(net, slwt->oif);\n\tif (!odev)\n\t\tgoto drop;\n\n\t \n\tif (odev->type != ARPHRD_ETHER)\n\t\tgoto drop;\n\n\tif (!(odev->flags & IFF_UP) || !netif_carrier_ok(odev))\n\t\tgoto drop;\n\n\tskb_orphan(skb);\n\n\tif (skb_warn_if_lro(skb))\n\t\tgoto drop;\n\n\tskb_forward_csum(skb);\n\n\tif (skb->len - ETH_HLEN > odev->mtu)\n\t\tgoto drop;\n\n\tskb->dev = odev;\n\tskb->protocol = eth->h_proto;\n\n\treturn dev_queue_xmit(skb);\n\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int input_action_end_dx6_finish(struct net *net, struct sock *sk,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct dst_entry *orig_dst = skb_dst(skb);\n\tstruct in6_addr *nhaddr = NULL;\n\tstruct seg6_local_lwt *slwt;\n\n\tslwt = seg6_local_lwtunnel(orig_dst->lwtstate);\n\n\t \n\tif (!ipv6_addr_any(&slwt->nh6))\n\t\tnhaddr = &slwt->nh6;\n\n\tseg6_lookup_nexthop(skb, nhaddr, 0);\n\n\treturn dst_input(skb);\n}\n\n \nstatic int input_action_end_dx6(struct sk_buff *skb,\n\t\t\t\tstruct seg6_local_lwt *slwt)\n{\n\t \n\n\tif (!decap_and_validate(skb, IPPROTO_IPV6))\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto drop;\n\n\tskb_set_transport_header(skb, sizeof(struct ipv6hdr));\n\tnf_reset_ct(skb);\n\n\tif (static_branch_unlikely(&nf_hooks_lwtunnel_enabled))\n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING,\n\t\t\t       dev_net(skb->dev), NULL, skb, NULL,\n\t\t\t       skb_dst(skb)->dev, input_action_end_dx6_finish);\n\n\treturn input_action_end_dx6_finish(dev_net(skb->dev), NULL, skb);\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int input_action_end_dx4_finish(struct net *net, struct sock *sk,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct dst_entry *orig_dst = skb_dst(skb);\n\tstruct seg6_local_lwt *slwt;\n\tstruct iphdr *iph;\n\t__be32 nhaddr;\n\tint err;\n\n\tslwt = seg6_local_lwtunnel(orig_dst->lwtstate);\n\n\tiph = ip_hdr(skb);\n\n\tnhaddr = slwt->nh4.s_addr ?: iph->daddr;\n\n\tskb_dst_drop(skb);\n\n\terr = ip_route_input(skb, nhaddr, iph->saddr, 0, skb->dev);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\treturn dst_input(skb);\n}\n\nstatic int input_action_end_dx4(struct sk_buff *skb,\n\t\t\t\tstruct seg6_local_lwt *slwt)\n{\n\tif (!decap_and_validate(skb, IPPROTO_IPIP))\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\tgoto drop;\n\n\tskb->protocol = htons(ETH_P_IP);\n\tskb_set_transport_header(skb, sizeof(struct iphdr));\n\tnf_reset_ct(skb);\n\n\tif (static_branch_unlikely(&nf_hooks_lwtunnel_enabled))\n\t\treturn NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,\n\t\t\t       dev_net(skb->dev), NULL, skb, NULL,\n\t\t\t       skb_dst(skb)->dev, input_action_end_dx4_finish);\n\n\treturn input_action_end_dx4_finish(dev_net(skb->dev), NULL, skb);\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_NET_L3_MASTER_DEV\nstatic struct net *fib6_config_get_net(const struct fib6_config *fib6_cfg)\n{\n\tconst struct nl_info *nli = &fib6_cfg->fc_nlinfo;\n\n\treturn nli->nl_net;\n}\n\nstatic int __seg6_end_dt_vrf_build(struct seg6_local_lwt *slwt, const void *cfg,\n\t\t\t\t   u16 family, struct netlink_ext_ack *extack)\n{\n\tstruct seg6_end_dt_info *info = &slwt->dt_info;\n\tint vrf_ifindex;\n\tstruct net *net;\n\n\tnet = fib6_config_get_net(cfg);\n\n\t \n\tvrf_ifindex = l3mdev_ifindex_lookup_by_table_id(L3MDEV_TYPE_VRF, net,\n\t\t\t\t\t\t\tinfo->vrf_table);\n\tif (vrf_ifindex < 0) {\n\t\tif (vrf_ifindex == -EPERM) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Strict mode for VRF is disabled\");\n\t\t} else if (vrf_ifindex == -ENODEV) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Table has no associated VRF device\");\n\t\t} else {\n\t\t\tpr_debug(\"seg6local: SRv6 End.DT* creation error=%d\\n\",\n\t\t\t\t vrf_ifindex);\n\t\t}\n\n\t\treturn vrf_ifindex;\n\t}\n\n\tinfo->net = net;\n\tinfo->vrf_ifindex = vrf_ifindex;\n\n\tinfo->family = family;\n\tinfo->mode = DT_VRF_MODE;\n\n\treturn 0;\n}\n\n \nstatic struct sk_buff *end_dt_vrf_rcv(struct sk_buff *skb, u16 family,\n\t\t\t\t      struct net_device *dev)\n{\n\t \n\tif (unlikely(!netif_is_l3_master(dev) && !netif_has_l3_rx_handler(dev)))\n\t\tgoto drop;\n\n\tif (unlikely(!dev->l3mdev_ops->l3mdev_l3_rcv))\n\t\tgoto drop;\n\n\t \n\tskb_unset_mac_header(skb);\n\n\tskb = dev->l3mdev_ops->l3mdev_l3_rcv(dev, skb, family);\n\tif (!skb)\n\t\t \n\t\treturn NULL;\n\n\t \n\tif (unlikely(skb->dev != dev || skb->skb_iif != dev->ifindex))\n\t\tgoto drop;\n\n\treturn skb;\n\ndrop:\n\tkfree_skb(skb);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct net_device *end_dt_get_vrf_rcu(struct sk_buff *skb,\n\t\t\t\t\t     struct seg6_end_dt_info *info)\n{\n\tint vrf_ifindex = info->vrf_ifindex;\n\tstruct net *net = info->net;\n\n\tif (unlikely(vrf_ifindex < 0))\n\t\tgoto error;\n\n\tif (unlikely(!net_eq(dev_net(skb->dev), net)))\n\t\tgoto error;\n\n\treturn dev_get_by_index_rcu(net, vrf_ifindex);\n\nerror:\n\treturn NULL;\n}\n\nstatic struct sk_buff *end_dt_vrf_core(struct sk_buff *skb,\n\t\t\t\t       struct seg6_local_lwt *slwt, u16 family)\n{\n\tstruct seg6_end_dt_info *info = &slwt->dt_info;\n\tstruct net_device *vrf;\n\t__be16 protocol;\n\tint hdrlen;\n\n\tvrf = end_dt_get_vrf_rcu(skb, info);\n\tif (unlikely(!vrf))\n\t\tgoto drop;\n\n\tswitch (family) {\n\tcase AF_INET:\n\t\tprotocol = htons(ETH_P_IP);\n\t\thdrlen = sizeof(struct iphdr);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tprotocol = htons(ETH_P_IPV6);\n\t\thdrlen = sizeof(struct ipv6hdr);\n\t\tbreak;\n\tcase AF_UNSPEC:\n\t\tfallthrough;\n\tdefault:\n\t\tgoto drop;\n\t}\n\n\tif (unlikely(info->family != AF_UNSPEC && info->family != family)) {\n\t\tpr_warn_once(\"seg6local: SRv6 End.DT* family mismatch\");\n\t\tgoto drop;\n\t}\n\n\tskb->protocol = protocol;\n\n\tskb_dst_drop(skb);\n\n\tskb_set_transport_header(skb, hdrlen);\n\tnf_reset_ct(skb);\n\n\treturn end_dt_vrf_rcv(skb, family, vrf);\n\ndrop:\n\tkfree_skb(skb);\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int input_action_end_dt4(struct sk_buff *skb,\n\t\t\t\tstruct seg6_local_lwt *slwt)\n{\n\tstruct iphdr *iph;\n\tint err;\n\n\tif (!decap_and_validate(skb, IPPROTO_IPIP))\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\tgoto drop;\n\n\tskb = end_dt_vrf_core(skb, slwt, AF_INET);\n\tif (!skb)\n\t\t \n\t\treturn 0;\n\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tiph = ip_hdr(skb);\n\n\terr = ip_route_input(skb, iph->daddr, iph->saddr, 0, skb->dev);\n\tif (unlikely(err))\n\t\tgoto drop;\n\n\treturn dst_input(skb);\n\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int seg6_end_dt4_build(struct seg6_local_lwt *slwt, const void *cfg,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\treturn __seg6_end_dt_vrf_build(slwt, cfg, AF_INET, extack);\n}\n\nstatic enum\nseg6_end_dt_mode seg6_end_dt6_parse_mode(struct seg6_local_lwt *slwt)\n{\n\tunsigned long parsed_optattrs = slwt->parsed_optattrs;\n\tbool legacy, vrfmode;\n\n\tlegacy\t= !!(parsed_optattrs & SEG6_F_ATTR(SEG6_LOCAL_TABLE));\n\tvrfmode\t= !!(parsed_optattrs & SEG6_F_ATTR(SEG6_LOCAL_VRFTABLE));\n\n\tif (!(legacy ^ vrfmode))\n\t\t \n\t\treturn DT_INVALID_MODE;\n\n\treturn legacy ? DT_LEGACY_MODE : DT_VRF_MODE;\n}\n\nstatic enum seg6_end_dt_mode seg6_end_dt6_get_mode(struct seg6_local_lwt *slwt)\n{\n\tstruct seg6_end_dt_info *info = &slwt->dt_info;\n\n\treturn info->mode;\n}\n\nstatic int seg6_end_dt6_build(struct seg6_local_lwt *slwt, const void *cfg,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tenum seg6_end_dt_mode mode = seg6_end_dt6_parse_mode(slwt);\n\tstruct seg6_end_dt_info *info = &slwt->dt_info;\n\n\tswitch (mode) {\n\tcase DT_LEGACY_MODE:\n\t\tinfo->mode = DT_LEGACY_MODE;\n\t\treturn 0;\n\tcase DT_VRF_MODE:\n\t\treturn __seg6_end_dt_vrf_build(slwt, cfg, AF_INET6, extack);\n\tdefault:\n\t\tNL_SET_ERR_MSG(extack, \"table or vrftable must be specified\");\n\t\treturn -EINVAL;\n\t}\n}\n#endif\n\nstatic int input_action_end_dt6(struct sk_buff *skb,\n\t\t\t\tstruct seg6_local_lwt *slwt)\n{\n\tif (!decap_and_validate(skb, IPPROTO_IPV6))\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\tgoto drop;\n\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\tif (seg6_end_dt6_get_mode(slwt) == DT_LEGACY_MODE)\n\t\tgoto legacy_mode;\n\n\t \n\tskb = end_dt_vrf_core(skb, slwt, AF_INET6);\n\tif (!skb)\n\t\t \n\t\treturn 0;\n\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\t \n\tseg6_lookup_any_nexthop(skb, NULL, 0, true);\n\n\treturn dst_input(skb);\n\nlegacy_mode:\n#endif\n\tskb_set_transport_header(skb, sizeof(struct ipv6hdr));\n\n\tseg6_lookup_any_nexthop(skb, NULL, slwt->table, true);\n\n\treturn dst_input(skb);\n\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\n#ifdef CONFIG_NET_L3_MASTER_DEV\nstatic int seg6_end_dt46_build(struct seg6_local_lwt *slwt, const void *cfg,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn __seg6_end_dt_vrf_build(slwt, cfg, AF_UNSPEC, extack);\n}\n\nstatic int input_action_end_dt46(struct sk_buff *skb,\n\t\t\t\t struct seg6_local_lwt *slwt)\n{\n\tunsigned int off = 0;\n\tint nexthdr;\n\n\tnexthdr = ipv6_find_hdr(skb, &off, -1, NULL, NULL);\n\tif (unlikely(nexthdr < 0))\n\t\tgoto drop;\n\n\tswitch (nexthdr) {\n\tcase IPPROTO_IPIP:\n\t\treturn input_action_end_dt4(skb, slwt);\n\tcase IPPROTO_IPV6:\n\t\treturn input_action_end_dt6(skb, slwt);\n\t}\n\ndrop:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n#endif\n\n \nstatic int input_action_end_b6(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tstruct ipv6_sr_hdr *srh;\n\tint err = -EINVAL;\n\n\tsrh = get_and_validate_srh(skb);\n\tif (!srh)\n\t\tgoto drop;\n\n\terr = seg6_do_srh_inline(skb, slwt->srh);\n\tif (err)\n\t\tgoto drop;\n\n\tskb_set_transport_header(skb, sizeof(struct ipv6hdr));\n\n\tseg6_lookup_nexthop(skb, NULL, 0);\n\n\treturn dst_input(skb);\n\ndrop:\n\tkfree_skb(skb);\n\treturn err;\n}\n\n \nstatic int input_action_end_b6_encap(struct sk_buff *skb,\n\t\t\t\t     struct seg6_local_lwt *slwt)\n{\n\tstruct ipv6_sr_hdr *srh;\n\tint err = -EINVAL;\n\n\tsrh = get_and_validate_srh(skb);\n\tif (!srh)\n\t\tgoto drop;\n\n\tadvance_nextseg(srh, &ipv6_hdr(skb)->daddr);\n\n\tskb_reset_inner_headers(skb);\n\tskb->encapsulation = 1;\n\n\terr = seg6_do_srh_encap(skb, slwt->srh, IPPROTO_IPV6);\n\tif (err)\n\t\tgoto drop;\n\n\tskb_set_transport_header(skb, sizeof(struct ipv6hdr));\n\n\tseg6_lookup_nexthop(skb, NULL, 0);\n\n\treturn dst_input(skb);\n\ndrop:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nDEFINE_PER_CPU(struct seg6_bpf_srh_state, seg6_bpf_srh_states);\n\nbool seg6_bpf_has_valid_srh(struct sk_buff *skb)\n{\n\tstruct seg6_bpf_srh_state *srh_state =\n\t\tthis_cpu_ptr(&seg6_bpf_srh_states);\n\tstruct ipv6_sr_hdr *srh = srh_state->srh;\n\n\tif (unlikely(srh == NULL))\n\t\treturn false;\n\n\tif (unlikely(!srh_state->valid)) {\n\t\tif ((srh_state->hdrlen & 7) != 0)\n\t\t\treturn false;\n\n\t\tsrh->hdrlen = (u8)(srh_state->hdrlen >> 3);\n\t\tif (!seg6_validate_srh(srh, (srh->hdrlen + 1) << 3, true))\n\t\t\treturn false;\n\n\t\tsrh_state->valid = true;\n\t}\n\n\treturn true;\n}\n\nstatic int input_action_end_bpf(struct sk_buff *skb,\n\t\t\t\tstruct seg6_local_lwt *slwt)\n{\n\tstruct seg6_bpf_srh_state *srh_state =\n\t\tthis_cpu_ptr(&seg6_bpf_srh_states);\n\tstruct ipv6_sr_hdr *srh;\n\tint ret;\n\n\tsrh = get_and_validate_srh(skb);\n\tif (!srh) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tadvance_nextseg(srh, &ipv6_hdr(skb)->daddr);\n\n\t \n\tpreempt_disable();\n\tsrh_state->srh = srh;\n\tsrh_state->hdrlen = srh->hdrlen << 3;\n\tsrh_state->valid = true;\n\n\trcu_read_lock();\n\tbpf_compute_data_pointers(skb);\n\tret = bpf_prog_run_save_cb(slwt->bpf.prog, skb);\n\trcu_read_unlock();\n\n\tswitch (ret) {\n\tcase BPF_OK:\n\tcase BPF_REDIRECT:\n\t\tbreak;\n\tcase BPF_DROP:\n\t\tgoto drop;\n\tdefault:\n\t\tpr_warn_once(\"bpf-seg6local: Illegal return value %u\\n\", ret);\n\t\tgoto drop;\n\t}\n\n\tif (srh_state->srh && !seg6_bpf_has_valid_srh(skb))\n\t\tgoto drop;\n\n\tpreempt_enable();\n\tif (ret != BPF_REDIRECT)\n\t\tseg6_lookup_nexthop(skb, NULL, 0);\n\n\treturn dst_input(skb);\n\ndrop:\n\tpreempt_enable();\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic struct seg6_action_desc seg6_action_table[] = {\n\t{\n\t\t.action\t\t= SEG6_LOCAL_ACTION_END,\n\t\t.attrs\t\t= 0,\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS |\n\t\t\t\t  SEG6_F_LOCAL_FLAVORS,\n\t\t.input\t\t= input_action_end,\n\t},\n\t{\n\t\t.action\t\t= SEG6_LOCAL_ACTION_END_X,\n\t\t.attrs\t\t= SEG6_F_ATTR(SEG6_LOCAL_NH6),\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS |\n\t\t\t\t  SEG6_F_LOCAL_FLAVORS,\n\t\t.input\t\t= input_action_end_x,\n\t},\n\t{\n\t\t.action\t\t= SEG6_LOCAL_ACTION_END_T,\n\t\t.attrs\t\t= SEG6_F_ATTR(SEG6_LOCAL_TABLE),\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS,\n\t\t.input\t\t= input_action_end_t,\n\t},\n\t{\n\t\t.action\t\t= SEG6_LOCAL_ACTION_END_DX2,\n\t\t.attrs\t\t= SEG6_F_ATTR(SEG6_LOCAL_OIF),\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS,\n\t\t.input\t\t= input_action_end_dx2,\n\t},\n\t{\n\t\t.action\t\t= SEG6_LOCAL_ACTION_END_DX6,\n\t\t.attrs\t\t= SEG6_F_ATTR(SEG6_LOCAL_NH6),\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS,\n\t\t.input\t\t= input_action_end_dx6,\n\t},\n\t{\n\t\t.action\t\t= SEG6_LOCAL_ACTION_END_DX4,\n\t\t.attrs\t\t= SEG6_F_ATTR(SEG6_LOCAL_NH4),\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS,\n\t\t.input\t\t= input_action_end_dx4,\n\t},\n\t{\n\t\t.action\t\t= SEG6_LOCAL_ACTION_END_DT4,\n\t\t.attrs\t\t= SEG6_F_ATTR(SEG6_LOCAL_VRFTABLE),\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS,\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\t\t.input\t\t= input_action_end_dt4,\n\t\t.slwt_ops\t= {\n\t\t\t\t\t.build_state = seg6_end_dt4_build,\n\t\t\t\t  },\n#endif\n\t},\n\t{\n\t\t.action\t\t= SEG6_LOCAL_ACTION_END_DT6,\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\t\t.attrs\t\t= 0,\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS\t\t|\n\t\t\t\t  SEG6_F_ATTR(SEG6_LOCAL_TABLE) |\n\t\t\t\t  SEG6_F_ATTR(SEG6_LOCAL_VRFTABLE),\n\t\t.slwt_ops\t= {\n\t\t\t\t\t.build_state = seg6_end_dt6_build,\n\t\t\t\t  },\n#else\n\t\t.attrs\t\t= SEG6_F_ATTR(SEG6_LOCAL_TABLE),\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS,\n#endif\n\t\t.input\t\t= input_action_end_dt6,\n\t},\n\t{\n\t\t.action\t\t= SEG6_LOCAL_ACTION_END_DT46,\n\t\t.attrs\t\t= SEG6_F_ATTR(SEG6_LOCAL_VRFTABLE),\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS,\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\t\t.input\t\t= input_action_end_dt46,\n\t\t.slwt_ops\t= {\n\t\t\t\t\t.build_state = seg6_end_dt46_build,\n\t\t\t\t  },\n#endif\n\t},\n\t{\n\t\t.action\t\t= SEG6_LOCAL_ACTION_END_B6,\n\t\t.attrs\t\t= SEG6_F_ATTR(SEG6_LOCAL_SRH),\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS,\n\t\t.input\t\t= input_action_end_b6,\n\t},\n\t{\n\t\t.action\t\t= SEG6_LOCAL_ACTION_END_B6_ENCAP,\n\t\t.attrs\t\t= SEG6_F_ATTR(SEG6_LOCAL_SRH),\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS,\n\t\t.input\t\t= input_action_end_b6_encap,\n\t\t.static_headroom\t= sizeof(struct ipv6hdr),\n\t},\n\t{\n\t\t.action\t\t= SEG6_LOCAL_ACTION_END_BPF,\n\t\t.attrs\t\t= SEG6_F_ATTR(SEG6_LOCAL_BPF),\n\t\t.optattrs\t= SEG6_F_LOCAL_COUNTERS,\n\t\t.input\t\t= input_action_end_bpf,\n\t},\n\n};\n\nstatic struct seg6_action_desc *__get_action_desc(int action)\n{\n\tstruct seg6_action_desc *desc;\n\tint i, count;\n\n\tcount = ARRAY_SIZE(seg6_action_table);\n\tfor (i = 0; i < count; i++) {\n\t\tdesc = &seg6_action_table[i];\n\t\tif (desc->action == action)\n\t\t\treturn desc;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool seg6_lwtunnel_counters_enabled(struct seg6_local_lwt *slwt)\n{\n\treturn slwt->parsed_optattrs & SEG6_F_LOCAL_COUNTERS;\n}\n\nstatic void seg6_local_update_counters(struct seg6_local_lwt *slwt,\n\t\t\t\t       unsigned int len, int err)\n{\n\tstruct pcpu_seg6_local_counters *pcounters;\n\n\tpcounters = this_cpu_ptr(slwt->pcpu_counters);\n\tu64_stats_update_begin(&pcounters->syncp);\n\n\tif (likely(!err)) {\n\t\tu64_stats_inc(&pcounters->packets);\n\t\tu64_stats_add(&pcounters->bytes, len);\n\t} else {\n\t\tu64_stats_inc(&pcounters->errors);\n\t}\n\n\tu64_stats_update_end(&pcounters->syncp);\n}\n\nstatic int seg6_local_input_core(struct net *net, struct sock *sk,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct dst_entry *orig_dst = skb_dst(skb);\n\tstruct seg6_action_desc *desc;\n\tstruct seg6_local_lwt *slwt;\n\tunsigned int len = skb->len;\n\tint rc;\n\n\tslwt = seg6_local_lwtunnel(orig_dst->lwtstate);\n\tdesc = slwt->desc;\n\n\trc = desc->input(skb, slwt);\n\n\tif (!seg6_lwtunnel_counters_enabled(slwt))\n\t\treturn rc;\n\n\tseg6_local_update_counters(slwt, len, rc);\n\n\treturn rc;\n}\n\nstatic int seg6_local_input(struct sk_buff *skb)\n{\n\tif (skb->protocol != htons(ETH_P_IPV6)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (static_branch_unlikely(&nf_hooks_lwtunnel_enabled))\n\t\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_IN,\n\t\t\t       dev_net(skb->dev), NULL, skb, skb->dev, NULL,\n\t\t\t       seg6_local_input_core);\n\n\treturn seg6_local_input_core(dev_net(skb->dev), NULL, skb);\n}\n\nstatic const struct nla_policy seg6_local_policy[SEG6_LOCAL_MAX + 1] = {\n\t[SEG6_LOCAL_ACTION]\t= { .type = NLA_U32 },\n\t[SEG6_LOCAL_SRH]\t= { .type = NLA_BINARY },\n\t[SEG6_LOCAL_TABLE]\t= { .type = NLA_U32 },\n\t[SEG6_LOCAL_VRFTABLE]\t= { .type = NLA_U32 },\n\t[SEG6_LOCAL_NH4]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct in_addr) },\n\t[SEG6_LOCAL_NH6]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = sizeof(struct in6_addr) },\n\t[SEG6_LOCAL_IIF]\t= { .type = NLA_U32 },\n\t[SEG6_LOCAL_OIF]\t= { .type = NLA_U32 },\n\t[SEG6_LOCAL_BPF]\t= { .type = NLA_NESTED },\n\t[SEG6_LOCAL_COUNTERS]\t= { .type = NLA_NESTED },\n\t[SEG6_LOCAL_FLAVORS]\t= { .type = NLA_NESTED },\n};\n\nstatic int parse_nla_srh(struct nlattr **attrs, struct seg6_local_lwt *slwt,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct ipv6_sr_hdr *srh;\n\tint len;\n\n\tsrh = nla_data(attrs[SEG6_LOCAL_SRH]);\n\tlen = nla_len(attrs[SEG6_LOCAL_SRH]);\n\n\t \n\tif (len < sizeof(*srh) + sizeof(struct in6_addr))\n\t\treturn -EINVAL;\n\n\tif (!seg6_validate_srh(srh, len, false))\n\t\treturn -EINVAL;\n\n\tslwt->srh = kmemdup(srh, len, GFP_KERNEL);\n\tif (!slwt->srh)\n\t\treturn -ENOMEM;\n\n\tslwt->headroom += len;\n\n\treturn 0;\n}\n\nstatic int put_nla_srh(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tstruct ipv6_sr_hdr *srh;\n\tstruct nlattr *nla;\n\tint len;\n\n\tsrh = slwt->srh;\n\tlen = (srh->hdrlen + 1) << 3;\n\n\tnla = nla_reserve(skb, SEG6_LOCAL_SRH, len);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tmemcpy(nla_data(nla), srh, len);\n\n\treturn 0;\n}\n\nstatic int cmp_nla_srh(struct seg6_local_lwt *a, struct seg6_local_lwt *b)\n{\n\tint len = (a->srh->hdrlen + 1) << 3;\n\n\tif (len != ((b->srh->hdrlen + 1) << 3))\n\t\treturn 1;\n\n\treturn memcmp(a->srh, b->srh, len);\n}\n\nstatic void destroy_attr_srh(struct seg6_local_lwt *slwt)\n{\n\tkfree(slwt->srh);\n}\n\nstatic int parse_nla_table(struct nlattr **attrs, struct seg6_local_lwt *slwt,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tslwt->table = nla_get_u32(attrs[SEG6_LOCAL_TABLE]);\n\n\treturn 0;\n}\n\nstatic int put_nla_table(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tif (nla_put_u32(skb, SEG6_LOCAL_TABLE, slwt->table))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int cmp_nla_table(struct seg6_local_lwt *a, struct seg6_local_lwt *b)\n{\n\tif (a->table != b->table)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct\nseg6_end_dt_info *seg6_possible_end_dt_info(struct seg6_local_lwt *slwt)\n{\n#ifdef CONFIG_NET_L3_MASTER_DEV\n\treturn &slwt->dt_info;\n#else\n\treturn ERR_PTR(-EOPNOTSUPP);\n#endif\n}\n\nstatic int parse_nla_vrftable(struct nlattr **attrs,\n\t\t\t      struct seg6_local_lwt *slwt,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct seg6_end_dt_info *info = seg6_possible_end_dt_info(slwt);\n\n\tif (IS_ERR(info))\n\t\treturn PTR_ERR(info);\n\n\tinfo->vrf_table = nla_get_u32(attrs[SEG6_LOCAL_VRFTABLE]);\n\n\treturn 0;\n}\n\nstatic int put_nla_vrftable(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tstruct seg6_end_dt_info *info = seg6_possible_end_dt_info(slwt);\n\n\tif (IS_ERR(info))\n\t\treturn PTR_ERR(info);\n\n\tif (nla_put_u32(skb, SEG6_LOCAL_VRFTABLE, info->vrf_table))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int cmp_nla_vrftable(struct seg6_local_lwt *a, struct seg6_local_lwt *b)\n{\n\tstruct seg6_end_dt_info *info_a = seg6_possible_end_dt_info(a);\n\tstruct seg6_end_dt_info *info_b = seg6_possible_end_dt_info(b);\n\n\tif (info_a->vrf_table != info_b->vrf_table)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int parse_nla_nh4(struct nlattr **attrs, struct seg6_local_lwt *slwt,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tmemcpy(&slwt->nh4, nla_data(attrs[SEG6_LOCAL_NH4]),\n\t       sizeof(struct in_addr));\n\n\treturn 0;\n}\n\nstatic int put_nla_nh4(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tstruct nlattr *nla;\n\n\tnla = nla_reserve(skb, SEG6_LOCAL_NH4, sizeof(struct in_addr));\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tmemcpy(nla_data(nla), &slwt->nh4, sizeof(struct in_addr));\n\n\treturn 0;\n}\n\nstatic int cmp_nla_nh4(struct seg6_local_lwt *a, struct seg6_local_lwt *b)\n{\n\treturn memcmp(&a->nh4, &b->nh4, sizeof(struct in_addr));\n}\n\nstatic int parse_nla_nh6(struct nlattr **attrs, struct seg6_local_lwt *slwt,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tmemcpy(&slwt->nh6, nla_data(attrs[SEG6_LOCAL_NH6]),\n\t       sizeof(struct in6_addr));\n\n\treturn 0;\n}\n\nstatic int put_nla_nh6(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tstruct nlattr *nla;\n\n\tnla = nla_reserve(skb, SEG6_LOCAL_NH6, sizeof(struct in6_addr));\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tmemcpy(nla_data(nla), &slwt->nh6, sizeof(struct in6_addr));\n\n\treturn 0;\n}\n\nstatic int cmp_nla_nh6(struct seg6_local_lwt *a, struct seg6_local_lwt *b)\n{\n\treturn memcmp(&a->nh6, &b->nh6, sizeof(struct in6_addr));\n}\n\nstatic int parse_nla_iif(struct nlattr **attrs, struct seg6_local_lwt *slwt,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tslwt->iif = nla_get_u32(attrs[SEG6_LOCAL_IIF]);\n\n\treturn 0;\n}\n\nstatic int put_nla_iif(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tif (nla_put_u32(skb, SEG6_LOCAL_IIF, slwt->iif))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int cmp_nla_iif(struct seg6_local_lwt *a, struct seg6_local_lwt *b)\n{\n\tif (a->iif != b->iif)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int parse_nla_oif(struct nlattr **attrs, struct seg6_local_lwt *slwt,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tslwt->oif = nla_get_u32(attrs[SEG6_LOCAL_OIF]);\n\n\treturn 0;\n}\n\nstatic int put_nla_oif(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tif (nla_put_u32(skb, SEG6_LOCAL_OIF, slwt->oif))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int cmp_nla_oif(struct seg6_local_lwt *a, struct seg6_local_lwt *b)\n{\n\tif (a->oif != b->oif)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n#define MAX_PROG_NAME 256\nstatic const struct nla_policy bpf_prog_policy[SEG6_LOCAL_BPF_PROG_MAX + 1] = {\n\t[SEG6_LOCAL_BPF_PROG]\t   = { .type = NLA_U32, },\n\t[SEG6_LOCAL_BPF_PROG_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t\t       .len = MAX_PROG_NAME },\n};\n\nstatic int parse_nla_bpf(struct nlattr **attrs, struct seg6_local_lwt *slwt,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[SEG6_LOCAL_BPF_PROG_MAX + 1];\n\tstruct bpf_prog *p;\n\tint ret;\n\tu32 fd;\n\n\tret = nla_parse_nested_deprecated(tb, SEG6_LOCAL_BPF_PROG_MAX,\n\t\t\t\t\t  attrs[SEG6_LOCAL_BPF],\n\t\t\t\t\t  bpf_prog_policy, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!tb[SEG6_LOCAL_BPF_PROG] || !tb[SEG6_LOCAL_BPF_PROG_NAME])\n\t\treturn -EINVAL;\n\n\tslwt->bpf.name = nla_memdup(tb[SEG6_LOCAL_BPF_PROG_NAME], GFP_KERNEL);\n\tif (!slwt->bpf.name)\n\t\treturn -ENOMEM;\n\n\tfd = nla_get_u32(tb[SEG6_LOCAL_BPF_PROG]);\n\tp = bpf_prog_get_type(fd, BPF_PROG_TYPE_LWT_SEG6LOCAL);\n\tif (IS_ERR(p)) {\n\t\tkfree(slwt->bpf.name);\n\t\treturn PTR_ERR(p);\n\t}\n\n\tslwt->bpf.prog = p;\n\treturn 0;\n}\n\nstatic int put_nla_bpf(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tstruct nlattr *nest;\n\n\tif (!slwt->bpf.prog)\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(skb, SEG6_LOCAL_BPF);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, SEG6_LOCAL_BPF_PROG, slwt->bpf.prog->aux->id))\n\t\treturn -EMSGSIZE;\n\n\tif (slwt->bpf.name &&\n\t    nla_put_string(skb, SEG6_LOCAL_BPF_PROG_NAME, slwt->bpf.name))\n\t\treturn -EMSGSIZE;\n\n\treturn nla_nest_end(skb, nest);\n}\n\nstatic int cmp_nla_bpf(struct seg6_local_lwt *a, struct seg6_local_lwt *b)\n{\n\tif (!a->bpf.name && !b->bpf.name)\n\t\treturn 0;\n\n\tif (!a->bpf.name || !b->bpf.name)\n\t\treturn 1;\n\n\treturn strcmp(a->bpf.name, b->bpf.name);\n}\n\nstatic void destroy_attr_bpf(struct seg6_local_lwt *slwt)\n{\n\tkfree(slwt->bpf.name);\n\tif (slwt->bpf.prog)\n\t\tbpf_prog_put(slwt->bpf.prog);\n}\n\nstatic const struct\nnla_policy seg6_local_counters_policy[SEG6_LOCAL_CNT_MAX + 1] = {\n\t[SEG6_LOCAL_CNT_PACKETS]\t= { .type = NLA_U64 },\n\t[SEG6_LOCAL_CNT_BYTES]\t\t= { .type = NLA_U64 },\n\t[SEG6_LOCAL_CNT_ERRORS]\t\t= { .type = NLA_U64 },\n};\n\nstatic int parse_nla_counters(struct nlattr **attrs,\n\t\t\t      struct seg6_local_lwt *slwt,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct pcpu_seg6_local_counters __percpu *pcounters;\n\tstruct nlattr *tb[SEG6_LOCAL_CNT_MAX + 1];\n\tint ret;\n\n\tret = nla_parse_nested_deprecated(tb, SEG6_LOCAL_CNT_MAX,\n\t\t\t\t\t  attrs[SEG6_LOCAL_COUNTERS],\n\t\t\t\t\t  seg6_local_counters_policy, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!tb[SEG6_LOCAL_CNT_PACKETS] || !tb[SEG6_LOCAL_CNT_BYTES] ||\n\t    !tb[SEG6_LOCAL_CNT_ERRORS])\n\t\treturn -EINVAL;\n\n\t \n\tpcounters = seg6_local_alloc_pcpu_counters(GFP_KERNEL);\n\tif (!pcounters)\n\t\treturn -ENOMEM;\n\n\tslwt->pcpu_counters = pcounters;\n\n\treturn 0;\n}\n\nstatic int seg6_local_fill_nla_counters(struct sk_buff *skb,\n\t\t\t\t\tstruct seg6_local_counters *counters)\n{\n\tif (nla_put_u64_64bit(skb, SEG6_LOCAL_CNT_PACKETS, counters->packets,\n\t\t\t      SEG6_LOCAL_CNT_PAD))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u64_64bit(skb, SEG6_LOCAL_CNT_BYTES, counters->bytes,\n\t\t\t      SEG6_LOCAL_CNT_PAD))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u64_64bit(skb, SEG6_LOCAL_CNT_ERRORS, counters->errors,\n\t\t\t      SEG6_LOCAL_CNT_PAD))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int put_nla_counters(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tstruct seg6_local_counters counters = { 0, 0, 0 };\n\tstruct nlattr *nest;\n\tint rc, i;\n\n\tnest = nla_nest_start(skb, SEG6_LOCAL_COUNTERS);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct pcpu_seg6_local_counters *pcounters;\n\t\tu64 packets, bytes, errors;\n\t\tunsigned int start;\n\n\t\tpcounters = per_cpu_ptr(slwt->pcpu_counters, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&pcounters->syncp);\n\n\t\t\tpackets = u64_stats_read(&pcounters->packets);\n\t\t\tbytes = u64_stats_read(&pcounters->bytes);\n\t\t\terrors = u64_stats_read(&pcounters->errors);\n\n\t\t} while (u64_stats_fetch_retry(&pcounters->syncp, start));\n\n\t\tcounters.packets += packets;\n\t\tcounters.bytes += bytes;\n\t\tcounters.errors += errors;\n\t}\n\n\trc = seg6_local_fill_nla_counters(skb, &counters);\n\tif (rc < 0) {\n\t\tnla_nest_cancel(skb, nest);\n\t\treturn rc;\n\t}\n\n\treturn nla_nest_end(skb, nest);\n}\n\nstatic int cmp_nla_counters(struct seg6_local_lwt *a, struct seg6_local_lwt *b)\n{\n\t \n\treturn (!!((unsigned long)a->pcpu_counters)) ^\n\t\t(!!((unsigned long)b->pcpu_counters));\n}\n\nstatic void destroy_attr_counters(struct seg6_local_lwt *slwt)\n{\n\tfree_percpu(slwt->pcpu_counters);\n}\n\nstatic const\nstruct nla_policy seg6_local_flavors_policy[SEG6_LOCAL_FLV_MAX + 1] = {\n\t[SEG6_LOCAL_FLV_OPERATION]\t= { .type = NLA_U32 },\n\t[SEG6_LOCAL_FLV_LCBLOCK_BITS]\t= { .type = NLA_U8 },\n\t[SEG6_LOCAL_FLV_LCNODE_FN_BITS]\t= { .type = NLA_U8 },\n};\n\n \nstatic int seg6_chk_next_csid_cfg(__u8 block_len, __u8 func_len)\n{\n\t \n\tif (next_csid_chk_cntr_bits(block_len, func_len))\n\t\treturn -EINVAL;\n\n\t \n\tif (next_csid_chk_lcblock_bits(block_len))\n\t\treturn -EINVAL;\n\n\t \n\tif (next_csid_chk_lcnode_fn_bits(func_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int seg6_parse_nla_next_csid_cfg(struct nlattr **tb,\n\t\t\t\t\tstruct seg6_flavors_info *finfo,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\t__u8 func_len = SEG6_LOCAL_LCNODE_FN_DBITS;\n\t__u8 block_len = SEG6_LOCAL_LCBLOCK_DBITS;\n\tint rc;\n\n\tif (tb[SEG6_LOCAL_FLV_LCBLOCK_BITS])\n\t\tblock_len = nla_get_u8(tb[SEG6_LOCAL_FLV_LCBLOCK_BITS]);\n\n\tif (tb[SEG6_LOCAL_FLV_LCNODE_FN_BITS])\n\t\tfunc_len = nla_get_u8(tb[SEG6_LOCAL_FLV_LCNODE_FN_BITS]);\n\n\trc = seg6_chk_next_csid_cfg(block_len, func_len);\n\tif (rc < 0) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid Locator Block/Node Function lengths\");\n\t\treturn rc;\n\t}\n\n\tfinfo->lcblock_bits = block_len;\n\tfinfo->lcnode_func_bits = func_len;\n\n\treturn 0;\n}\n\nstatic int parse_nla_flavors(struct nlattr **attrs, struct seg6_local_lwt *slwt,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct seg6_flavors_info *finfo = &slwt->flv_info;\n\tstruct nlattr *tb[SEG6_LOCAL_FLV_MAX + 1];\n\tint action = slwt->action;\n\t__u32 fops, supp_fops;\n\tint rc;\n\n\trc = nla_parse_nested_deprecated(tb, SEG6_LOCAL_FLV_MAX,\n\t\t\t\t\t attrs[SEG6_LOCAL_FLAVORS],\n\t\t\t\t\t seg6_local_flavors_policy, NULL);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (!tb[SEG6_LOCAL_FLV_OPERATION])\n\t\treturn -EINVAL;\n\n\tfops = nla_get_u32(tb[SEG6_LOCAL_FLV_OPERATION]);\n\trc = seg6_flv_supp_ops_by_action(action, &supp_fops);\n\tif (rc < 0 || (fops & ~supp_fops)) {\n\t\tNL_SET_ERR_MSG(extack, \"Unsupported Flavor operation(s)\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfinfo->flv_ops = fops;\n\n\tif (seg6_next_csid_enabled(fops)) {\n\t\t \n\t\trc = seg6_parse_nla_next_csid_cfg(tb, finfo, extack);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int seg6_fill_nla_next_csid_cfg(struct sk_buff *skb,\n\t\t\t\t       struct seg6_flavors_info *finfo)\n{\n\tif (nla_put_u8(skb, SEG6_LOCAL_FLV_LCBLOCK_BITS, finfo->lcblock_bits))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u8(skb, SEG6_LOCAL_FLV_LCNODE_FN_BITS,\n\t\t       finfo->lcnode_func_bits))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int put_nla_flavors(struct sk_buff *skb, struct seg6_local_lwt *slwt)\n{\n\tstruct seg6_flavors_info *finfo = &slwt->flv_info;\n\t__u32 fops = finfo->flv_ops;\n\tstruct nlattr *nest;\n\tint rc;\n\n\tnest = nla_nest_start(skb, SEG6_LOCAL_FLAVORS);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, SEG6_LOCAL_FLV_OPERATION, fops)) {\n\t\trc = -EMSGSIZE;\n\t\tgoto err;\n\t}\n\n\tif (seg6_next_csid_enabled(fops)) {\n\t\trc = seg6_fill_nla_next_csid_cfg(skb, finfo);\n\t\tif (rc < 0)\n\t\t\tgoto err;\n\t}\n\n\treturn nla_nest_end(skb, nest);\n\nerr:\n\tnla_nest_cancel(skb, nest);\n\treturn rc;\n}\n\nstatic int seg6_cmp_nla_next_csid_cfg(struct seg6_flavors_info *finfo_a,\n\t\t\t\t      struct seg6_flavors_info *finfo_b)\n{\n\tif (finfo_a->lcblock_bits != finfo_b->lcblock_bits)\n\t\treturn 1;\n\n\tif (finfo_a->lcnode_func_bits != finfo_b->lcnode_func_bits)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int cmp_nla_flavors(struct seg6_local_lwt *a, struct seg6_local_lwt *b)\n{\n\tstruct seg6_flavors_info *finfo_a = &a->flv_info;\n\tstruct seg6_flavors_info *finfo_b = &b->flv_info;\n\n\tif (finfo_a->flv_ops != finfo_b->flv_ops)\n\t\treturn 1;\n\n\tif (seg6_next_csid_enabled(finfo_a->flv_ops)) {\n\t\tif (seg6_cmp_nla_next_csid_cfg(finfo_a, finfo_b))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int encap_size_flavors(struct seg6_local_lwt *slwt)\n{\n\tstruct seg6_flavors_info *finfo = &slwt->flv_info;\n\tint nlsize;\n\n\tnlsize = nla_total_size(0) +\t \n\t\t nla_total_size(4);\t \n\n\tif (seg6_next_csid_enabled(finfo->flv_ops))\n\t\tnlsize += nla_total_size(1) +  \n\t\t\t  nla_total_size(1);  \n\n\treturn nlsize;\n}\n\nstruct seg6_action_param {\n\tint (*parse)(struct nlattr **attrs, struct seg6_local_lwt *slwt,\n\t\t     struct netlink_ext_ack *extack);\n\tint (*put)(struct sk_buff *skb, struct seg6_local_lwt *slwt);\n\tint (*cmp)(struct seg6_local_lwt *a, struct seg6_local_lwt *b);\n\n\t \n\tvoid (*destroy)(struct seg6_local_lwt *slwt);\n};\n\nstatic struct seg6_action_param seg6_action_params[SEG6_LOCAL_MAX + 1] = {\n\t[SEG6_LOCAL_SRH]\t= { .parse = parse_nla_srh,\n\t\t\t\t    .put = put_nla_srh,\n\t\t\t\t    .cmp = cmp_nla_srh,\n\t\t\t\t    .destroy = destroy_attr_srh },\n\n\t[SEG6_LOCAL_TABLE]\t= { .parse = parse_nla_table,\n\t\t\t\t    .put = put_nla_table,\n\t\t\t\t    .cmp = cmp_nla_table },\n\n\t[SEG6_LOCAL_NH4]\t= { .parse = parse_nla_nh4,\n\t\t\t\t    .put = put_nla_nh4,\n\t\t\t\t    .cmp = cmp_nla_nh4 },\n\n\t[SEG6_LOCAL_NH6]\t= { .parse = parse_nla_nh6,\n\t\t\t\t    .put = put_nla_nh6,\n\t\t\t\t    .cmp = cmp_nla_nh6 },\n\n\t[SEG6_LOCAL_IIF]\t= { .parse = parse_nla_iif,\n\t\t\t\t    .put = put_nla_iif,\n\t\t\t\t    .cmp = cmp_nla_iif },\n\n\t[SEG6_LOCAL_OIF]\t= { .parse = parse_nla_oif,\n\t\t\t\t    .put = put_nla_oif,\n\t\t\t\t    .cmp = cmp_nla_oif },\n\n\t[SEG6_LOCAL_BPF]\t= { .parse = parse_nla_bpf,\n\t\t\t\t    .put = put_nla_bpf,\n\t\t\t\t    .cmp = cmp_nla_bpf,\n\t\t\t\t    .destroy = destroy_attr_bpf },\n\n\t[SEG6_LOCAL_VRFTABLE]\t= { .parse = parse_nla_vrftable,\n\t\t\t\t    .put = put_nla_vrftable,\n\t\t\t\t    .cmp = cmp_nla_vrftable },\n\n\t[SEG6_LOCAL_COUNTERS]\t= { .parse = parse_nla_counters,\n\t\t\t\t    .put = put_nla_counters,\n\t\t\t\t    .cmp = cmp_nla_counters,\n\t\t\t\t    .destroy = destroy_attr_counters },\n\n\t[SEG6_LOCAL_FLAVORS]\t= { .parse = parse_nla_flavors,\n\t\t\t\t    .put = put_nla_flavors,\n\t\t\t\t    .cmp = cmp_nla_flavors },\n};\n\n \nstatic void __destroy_attrs(unsigned long parsed_attrs, int max_parsed,\n\t\t\t    struct seg6_local_lwt *slwt)\n{\n\tstruct seg6_action_param *param;\n\tint i;\n\n\t \n\tfor (i = SEG6_LOCAL_SRH; i < max_parsed; ++i) {\n\t\tif (!(parsed_attrs & SEG6_F_ATTR(i)))\n\t\t\tcontinue;\n\n\t\tparam = &seg6_action_params[i];\n\n\t\tif (param->destroy)\n\t\t\tparam->destroy(slwt);\n\t}\n}\n\n \nstatic void destroy_attrs(struct seg6_local_lwt *slwt)\n{\n\tunsigned long attrs = slwt->desc->attrs | slwt->parsed_optattrs;\n\n\t__destroy_attrs(attrs, SEG6_LOCAL_MAX + 1, slwt);\n}\n\nstatic int parse_nla_optional_attrs(struct nlattr **attrs,\n\t\t\t\t    struct seg6_local_lwt *slwt,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct seg6_action_desc *desc = slwt->desc;\n\tunsigned long parsed_optattrs = 0;\n\tstruct seg6_action_param *param;\n\tint err, i;\n\n\tfor (i = SEG6_LOCAL_SRH; i < SEG6_LOCAL_MAX + 1; ++i) {\n\t\tif (!(desc->optattrs & SEG6_F_ATTR(i)) || !attrs[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tparam = &seg6_action_params[i];\n\n\t\terr = param->parse(attrs, slwt, extack);\n\t\tif (err < 0)\n\t\t\tgoto parse_optattrs_err;\n\n\t\t \n\t\tparsed_optattrs |= SEG6_F_ATTR(i);\n\t}\n\n\t \n\tslwt->parsed_optattrs = parsed_optattrs;\n\n\treturn 0;\n\nparse_optattrs_err:\n\t__destroy_attrs(parsed_optattrs, i, slwt);\n\n\treturn err;\n}\n\n \nstatic int\nseg6_local_lwtunnel_build_state(struct seg6_local_lwt *slwt, const void *cfg,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct seg6_action_desc *desc = slwt->desc;\n\tstruct seg6_local_lwtunnel_ops *ops;\n\n\tops = &desc->slwt_ops;\n\tif (!ops->build_state)\n\t\treturn 0;\n\n\treturn ops->build_state(slwt, cfg, extack);\n}\n\n \nstatic void seg6_local_lwtunnel_destroy_state(struct seg6_local_lwt *slwt)\n{\n\tstruct seg6_action_desc *desc = slwt->desc;\n\tstruct seg6_local_lwtunnel_ops *ops;\n\n\tops = &desc->slwt_ops;\n\tif (!ops->destroy_state)\n\t\treturn;\n\n\tops->destroy_state(slwt);\n}\n\nstatic int parse_nla_action(struct nlattr **attrs, struct seg6_local_lwt *slwt,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct seg6_action_param *param;\n\tstruct seg6_action_desc *desc;\n\tunsigned long invalid_attrs;\n\tint i, err;\n\n\tdesc = __get_action_desc(slwt->action);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (!desc->input)\n\t\treturn -EOPNOTSUPP;\n\n\tslwt->desc = desc;\n\tslwt->headroom += desc->static_headroom;\n\n\t \n\tinvalid_attrs = desc->attrs & desc->optattrs;\n\tif (invalid_attrs) {\n\t\tWARN_ONCE(1,\n\t\t\t  \"An attribute cannot be both required AND optional\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = SEG6_LOCAL_SRH; i < SEG6_LOCAL_MAX + 1; i++) {\n\t\tif (desc->attrs & SEG6_F_ATTR(i)) {\n\t\t\tif (!attrs[i])\n\t\t\t\treturn -EINVAL;\n\n\t\t\tparam = &seg6_action_params[i];\n\n\t\t\terr = param->parse(attrs, slwt, extack);\n\t\t\tif (err < 0)\n\t\t\t\tgoto parse_attrs_err;\n\t\t}\n\t}\n\n\t \n\terr = parse_nla_optional_attrs(attrs, slwt, extack);\n\tif (err < 0)\n\t\tgoto parse_attrs_err;\n\n\treturn 0;\n\nparse_attrs_err:\n\t \n\t__destroy_attrs(desc->attrs, i, slwt);\n\n\treturn err;\n}\n\nstatic int seg6_local_build_state(struct net *net, struct nlattr *nla,\n\t\t\t\t  unsigned int family, const void *cfg,\n\t\t\t\t  struct lwtunnel_state **ts,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[SEG6_LOCAL_MAX + 1];\n\tstruct lwtunnel_state *newts;\n\tstruct seg6_local_lwt *slwt;\n\tint err;\n\n\tif (family != AF_INET6)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, SEG6_LOCAL_MAX, nla,\n\t\t\t\t\t  seg6_local_policy, extack);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[SEG6_LOCAL_ACTION])\n\t\treturn -EINVAL;\n\n\tnewts = lwtunnel_state_alloc(sizeof(*slwt));\n\tif (!newts)\n\t\treturn -ENOMEM;\n\n\tslwt = seg6_local_lwtunnel(newts);\n\tslwt->action = nla_get_u32(tb[SEG6_LOCAL_ACTION]);\n\n\terr = parse_nla_action(tb, slwt, extack);\n\tif (err < 0)\n\t\tgoto out_free;\n\n\terr = seg6_local_lwtunnel_build_state(slwt, cfg, extack);\n\tif (err < 0)\n\t\tgoto out_destroy_attrs;\n\n\tnewts->type = LWTUNNEL_ENCAP_SEG6_LOCAL;\n\tnewts->flags = LWTUNNEL_STATE_INPUT_REDIRECT;\n\tnewts->headroom = slwt->headroom;\n\n\t*ts = newts;\n\n\treturn 0;\n\nout_destroy_attrs:\n\tdestroy_attrs(slwt);\nout_free:\n\tkfree(newts);\n\treturn err;\n}\n\nstatic void seg6_local_destroy_state(struct lwtunnel_state *lwt)\n{\n\tstruct seg6_local_lwt *slwt = seg6_local_lwtunnel(lwt);\n\n\tseg6_local_lwtunnel_destroy_state(slwt);\n\n\tdestroy_attrs(slwt);\n\n\treturn;\n}\n\nstatic int seg6_local_fill_encap(struct sk_buff *skb,\n\t\t\t\t struct lwtunnel_state *lwt)\n{\n\tstruct seg6_local_lwt *slwt = seg6_local_lwtunnel(lwt);\n\tstruct seg6_action_param *param;\n\tunsigned long attrs;\n\tint i, err;\n\n\tif (nla_put_u32(skb, SEG6_LOCAL_ACTION, slwt->action))\n\t\treturn -EMSGSIZE;\n\n\tattrs = slwt->desc->attrs | slwt->parsed_optattrs;\n\n\tfor (i = SEG6_LOCAL_SRH; i < SEG6_LOCAL_MAX + 1; i++) {\n\t\tif (attrs & SEG6_F_ATTR(i)) {\n\t\t\tparam = &seg6_action_params[i];\n\t\t\terr = param->put(skb, slwt);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int seg6_local_get_encap_size(struct lwtunnel_state *lwt)\n{\n\tstruct seg6_local_lwt *slwt = seg6_local_lwtunnel(lwt);\n\tunsigned long attrs;\n\tint nlsize;\n\n\tnlsize = nla_total_size(4);  \n\n\tattrs = slwt->desc->attrs | slwt->parsed_optattrs;\n\n\tif (attrs & SEG6_F_ATTR(SEG6_LOCAL_SRH))\n\t\tnlsize += nla_total_size((slwt->srh->hdrlen + 1) << 3);\n\n\tif (attrs & SEG6_F_ATTR(SEG6_LOCAL_TABLE))\n\t\tnlsize += nla_total_size(4);\n\n\tif (attrs & SEG6_F_ATTR(SEG6_LOCAL_NH4))\n\t\tnlsize += nla_total_size(4);\n\n\tif (attrs & SEG6_F_ATTR(SEG6_LOCAL_NH6))\n\t\tnlsize += nla_total_size(16);\n\n\tif (attrs & SEG6_F_ATTR(SEG6_LOCAL_IIF))\n\t\tnlsize += nla_total_size(4);\n\n\tif (attrs & SEG6_F_ATTR(SEG6_LOCAL_OIF))\n\t\tnlsize += nla_total_size(4);\n\n\tif (attrs & SEG6_F_ATTR(SEG6_LOCAL_BPF))\n\t\tnlsize += nla_total_size(sizeof(struct nlattr)) +\n\t\t       nla_total_size(MAX_PROG_NAME) +\n\t\t       nla_total_size(4);\n\n\tif (attrs & SEG6_F_ATTR(SEG6_LOCAL_VRFTABLE))\n\t\tnlsize += nla_total_size(4);\n\n\tif (attrs & SEG6_F_LOCAL_COUNTERS)\n\t\tnlsize += nla_total_size(0) +  \n\t\t\t   \n\t\t\t  nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t   \n\t\t\t  nla_total_size_64bit(sizeof(__u64)) +\n\t\t\t   \n\t\t\t  nla_total_size_64bit(sizeof(__u64));\n\n\tif (attrs & SEG6_F_ATTR(SEG6_LOCAL_FLAVORS))\n\t\tnlsize += encap_size_flavors(slwt);\n\n\treturn nlsize;\n}\n\nstatic int seg6_local_cmp_encap(struct lwtunnel_state *a,\n\t\t\t\tstruct lwtunnel_state *b)\n{\n\tstruct seg6_local_lwt *slwt_a, *slwt_b;\n\tstruct seg6_action_param *param;\n\tunsigned long attrs_a, attrs_b;\n\tint i;\n\n\tslwt_a = seg6_local_lwtunnel(a);\n\tslwt_b = seg6_local_lwtunnel(b);\n\n\tif (slwt_a->action != slwt_b->action)\n\t\treturn 1;\n\n\tattrs_a = slwt_a->desc->attrs | slwt_a->parsed_optattrs;\n\tattrs_b = slwt_b->desc->attrs | slwt_b->parsed_optattrs;\n\n\tif (attrs_a != attrs_b)\n\t\treturn 1;\n\n\tfor (i = SEG6_LOCAL_SRH; i < SEG6_LOCAL_MAX + 1; i++) {\n\t\tif (attrs_a & SEG6_F_ATTR(i)) {\n\t\t\tparam = &seg6_action_params[i];\n\t\t\tif (param->cmp(slwt_a, slwt_b))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct lwtunnel_encap_ops seg6_local_ops = {\n\t.build_state\t= seg6_local_build_state,\n\t.destroy_state\t= seg6_local_destroy_state,\n\t.input\t\t= seg6_local_input,\n\t.fill_encap\t= seg6_local_fill_encap,\n\t.get_encap_size\t= seg6_local_get_encap_size,\n\t.cmp_encap\t= seg6_local_cmp_encap,\n\t.owner\t\t= THIS_MODULE,\n};\n\nint __init seg6_local_init(void)\n{\n\t \n\tBUILD_BUG_ON(SEG6_LOCAL_MAX + 1 > BITS_PER_TYPE(unsigned long));\n\n\t \n\tBUILD_BUG_ON(SEG6_LOCAL_FLV_OP_MAX + 1 > BITS_PER_TYPE(__u32));\n\n\t \n\tBUILD_BUG_ON(next_csid_chk_cntr_bits(SEG6_LOCAL_LCBLOCK_DBITS,\n\t\t\t\t\t     SEG6_LOCAL_LCNODE_FN_DBITS));\n\tBUILD_BUG_ON(next_csid_chk_lcblock_bits(SEG6_LOCAL_LCBLOCK_DBITS));\n\tBUILD_BUG_ON(next_csid_chk_lcnode_fn_bits(SEG6_LOCAL_LCNODE_FN_DBITS));\n\n\t \n\tBUILD_BUG_ON(SEG6_LOCAL_FLV_ACT_MAX > (typeof(flv8986_act_tbl[0]))~0U);\n\n\treturn lwtunnel_encap_add_ops(&seg6_local_ops,\n\t\t\t\t      LWTUNNEL_ENCAP_SEG6_LOCAL);\n}\n\nvoid seg6_local_exit(void)\n{\n\tlwtunnel_encap_del_ops(&seg6_local_ops, LWTUNNEL_ENCAP_SEG6_LOCAL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}