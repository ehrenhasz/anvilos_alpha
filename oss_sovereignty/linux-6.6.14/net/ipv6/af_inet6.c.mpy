{
  "module_name": "af_inet6.c",
  "hash_id": "086b43922a7aac00a4d1a9ab05e151ad8e9978ed56c95428c0187ec02b5ddc0b",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/af_inet6.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/icmpv6.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/udp.h>\n#include <net/udplite.h>\n#include <net/tcp.h>\n#include <net/ping.h>\n#include <net/protocol.h>\n#include <net/inet_common.h>\n#include <net/route.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/ipv6_stubs.h>\n#include <net/ndisc.h>\n#ifdef CONFIG_IPV6_TUNNEL\n#include <net/ip6_tunnel.h>\n#endif\n#include <net/calipso.h>\n#include <net/seg6.h>\n#include <net/rpl.h>\n#include <net/compat.h>\n#include <net/xfrm.h>\n#include <net/ioam6.h>\n#include <net/rawv6.h>\n\n#include <linux/uaccess.h>\n#include <linux/mroute6.h>\n\n#include \"ip6_offload.h\"\n\nMODULE_AUTHOR(\"Cast of dozens\");\nMODULE_DESCRIPTION(\"IPv6 protocol stack for Linux\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic struct list_head inetsw6[SOCK_MAX];\nstatic DEFINE_SPINLOCK(inetsw6_lock);\n\nstruct ipv6_params ipv6_defaults = {\n\t.disable_ipv6 = 0,\n\t.autoconf = 1,\n};\n\nstatic int disable_ipv6_mod;\n\nmodule_param_named(disable, disable_ipv6_mod, int, 0444);\nMODULE_PARM_DESC(disable, \"Disable IPv6 module such that it is non-functional\");\n\nmodule_param_named(disable_ipv6, ipv6_defaults.disable_ipv6, int, 0444);\nMODULE_PARM_DESC(disable_ipv6, \"Disable IPv6 on all interfaces\");\n\nmodule_param_named(autoconf, ipv6_defaults.autoconf, int, 0444);\nMODULE_PARM_DESC(autoconf, \"Enable IPv6 address autoconfiguration on all interfaces\");\n\nbool ipv6_mod_enabled(void)\n{\n\treturn disable_ipv6_mod == 0;\n}\nEXPORT_SYMBOL_GPL(ipv6_mod_enabled);\n\nstatic struct ipv6_pinfo *inet6_sk_generic(struct sock *sk)\n{\n\tconst int offset = sk->sk_prot->ipv6_pinfo_offset;\n\n\treturn (struct ipv6_pinfo *)(((u8 *)sk) + offset);\n}\n\nvoid inet6_sock_destruct(struct sock *sk)\n{\n\tinet6_cleanup_sock(sk);\n\tinet_sock_destruct(sk);\n}\nEXPORT_SYMBOL_GPL(inet6_sock_destruct);\n\nstatic int inet6_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct inet_sock *inet;\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tstruct inet_protosw *answer;\n\tstruct proto *answer_prot;\n\tunsigned char answer_flags;\n\tint try_loading_module = 0;\n\tint err;\n\n\tif (protocol < 0 || protocol >= IPPROTO_MAX)\n\t\treturn -EINVAL;\n\n\t \nlookup_protocol:\n\terr = -ESOCKTNOSUPPORT;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(answer, &inetsw6[sock->type], list) {\n\n\t\terr = 0;\n\t\t \n\t\tif (protocol == answer->protocol) {\n\t\t\tif (protocol != IPPROTO_IP)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tif (IPPROTO_IP == protocol) {\n\t\t\t\tprotocol = answer->protocol;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IPPROTO_IP == answer->protocol)\n\t\t\t\tbreak;\n\t\t}\n\t\terr = -EPROTONOSUPPORT;\n\t}\n\n\tif (err) {\n\t\tif (try_loading_module < 2) {\n\t\t\trcu_read_unlock();\n\t\t\t \n\t\t\tif (++try_loading_module == 1)\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d-type-%d\",\n\t\t\t\t\t\tPF_INET6, protocol, sock->type);\n\t\t\t \n\t\t\telse\n\t\t\t\trequest_module(\"net-pf-%d-proto-%d\",\n\t\t\t\t\t\tPF_INET6, protocol);\n\t\t\tgoto lookup_protocol;\n\t\t} else\n\t\t\tgoto out_rcu_unlock;\n\t}\n\n\terr = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern &&\n\t    !ns_capable(net->user_ns, CAP_NET_RAW))\n\t\tgoto out_rcu_unlock;\n\n\tsock->ops = answer->ops;\n\tanswer_prot = answer->prot;\n\tanswer_flags = answer->flags;\n\trcu_read_unlock();\n\n\tWARN_ON(!answer_prot->slab);\n\n\terr = -ENOBUFS;\n\tsk = sk_alloc(net, PF_INET6, GFP_KERNEL, answer_prot, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_init_data(sock, sk);\n\n\terr = 0;\n\tif (INET_PROTOSW_REUSE & answer_flags)\n\t\tsk->sk_reuse = SK_CAN_REUSE;\n\n\tinet = inet_sk(sk);\n\tinet_assign_bit(IS_ICSK, sk, INET_PROTOSW_ICSK & answer_flags);\n\n\tif (SOCK_RAW == sock->type) {\n\t\tinet->inet_num = protocol;\n\t\tif (IPPROTO_RAW == protocol)\n\t\t\tinet_set_bit(HDRINCL, sk);\n\t}\n\n\tsk->sk_destruct\t\t= inet6_sock_destruct;\n\tsk->sk_family\t\t= PF_INET6;\n\tsk->sk_protocol\t\t= protocol;\n\n\tsk->sk_backlog_rcv\t= answer->prot->backlog_rcv;\n\n\tinet_sk(sk)->pinet6 = np = inet6_sk_generic(sk);\n\tnp->hop_limit\t= -1;\n\tnp->mcast_hops\t= IPV6_DEFAULT_MCASTHOPS;\n\tnp->mc_loop\t= 1;\n\tnp->mc_all\t= 1;\n\tnp->pmtudisc\t= IPV6_PMTUDISC_WANT;\n\tnp->repflow\t= net->ipv6.sysctl.flowlabel_reflect & FLOWLABEL_REFLECT_ESTABLISHED;\n\tsk->sk_ipv6only\t= net->ipv6.sysctl.bindv6only;\n\tsk->sk_txrehash = READ_ONCE(net->core.sysctl_txrehash);\n\n\t \n\tinet->uc_ttl\t= -1;\n\n\tinet_set_bit(MC_LOOP, sk);\n\tinet->mc_ttl\t= 1;\n\tinet->mc_index\t= 0;\n\tRCU_INIT_POINTER(inet->mc_list, NULL);\n\tinet->rcv_tos\t= 0;\n\n\tif (READ_ONCE(net->ipv4.sysctl_ip_no_pmtu_disc))\n\t\tinet->pmtudisc = IP_PMTUDISC_DONT;\n\telse\n\t\tinet->pmtudisc = IP_PMTUDISC_WANT;\n\n\tif (inet->inet_num) {\n\t\t \n\t\tinet->inet_sport = htons(inet->inet_num);\n\t\terr = sk->sk_prot->hash(sk);\n\t\tif (err) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (sk->sk_prot->init) {\n\t\terr = sk->sk_prot->init(sk);\n\t\tif (err) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!kern) {\n\t\terr = BPF_CGROUP_RUN_PROG_INET_SOCK(sk);\n\t\tif (err) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn err;\nout_rcu_unlock:\n\trcu_read_unlock();\n\tgoto out;\n}\n\nstatic int __inet6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len,\n\t\t\tu32 flags)\n{\n\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\t__be32 v4addr = 0;\n\tunsigned short snum;\n\tbool saved_ipv6only;\n\tint addr_type = 0;\n\tint err = 0;\n\n\tif (addr->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\taddr_type = ipv6_addr_type(&addr->sin6_addr);\n\tif ((addr_type & IPV6_ADDR_MULTICAST) && sk->sk_type == SOCK_STREAM)\n\t\treturn -EINVAL;\n\n\tsnum = ntohs(addr->sin6_port);\n\tif (!(flags & BIND_NO_CAP_NET_BIND_SERVICE) &&\n\t    snum && inet_port_requires_bind_service(net, snum) &&\n\t    !ns_capable(net->user_ns, CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\n\tif (flags & BIND_WITH_LOCK)\n\t\tlock_sock(sk);\n\n\t \n\tif (sk->sk_state != TCP_CLOSE || inet->inet_num) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (addr_type == IPV6_ADDR_MAPPED) {\n\t\tstruct net_device *dev = NULL;\n\t\tint chk_addr_ret;\n\n\t\t \n\t\tif (ipv6_only_sock(sk)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tif (sk->sk_bound_dev_if) {\n\t\t\tdev = dev_get_by_index_rcu(net, sk->sk_bound_dev_if);\n\t\t\tif (!dev) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tv4addr = addr->sin6_addr.s6_addr32[3];\n\t\tchk_addr_ret = inet_addr_type_dev_table(net, dev, v4addr);\n\t\trcu_read_unlock();\n\n\t\tif (!inet_addr_valid_or_nonlocal(net, inet, v4addr,\n\t\t\t\t\t\t chk_addr_ret)) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (addr_type != IPV6_ADDR_ANY) {\n\t\t\tstruct net_device *dev = NULL;\n\n\t\t\trcu_read_lock();\n\t\t\tif (__ipv6_addr_needs_scope_id(addr_type)) {\n\t\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t\t    addr->sin6_scope_id) {\n\t\t\t\t\t \n\t\t\t\t\tsk->sk_bound_dev_if = addr->sin6_scope_id;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (!sk->sk_bound_dev_if) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (sk->sk_bound_dev_if) {\n\t\t\t\tdev = dev_get_by_index_rcu(net, sk->sk_bound_dev_if);\n\t\t\t\tif (!dev) {\n\t\t\t\t\terr = -ENODEV;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tv4addr = LOOPBACK4_IPV6;\n\t\t\tif (!(addr_type & IPV6_ADDR_MULTICAST))\t{\n\t\t\t\tif (!ipv6_can_nonlocal_bind(net, inet) &&\n\t\t\t\t    !ipv6_chk_addr(net, &addr->sin6_addr,\n\t\t\t\t\t\t   dev, 0)) {\n\t\t\t\t\terr = -EADDRNOTAVAIL;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\t}\n\n\tinet->inet_rcv_saddr = v4addr;\n\tinet->inet_saddr = v4addr;\n\n\tsk->sk_v6_rcv_saddr = addr->sin6_addr;\n\n\tif (!(addr_type & IPV6_ADDR_MULTICAST))\n\t\tnp->saddr = addr->sin6_addr;\n\n\tsaved_ipv6only = sk->sk_ipv6only;\n\tif (addr_type != IPV6_ADDR_ANY && addr_type != IPV6_ADDR_MAPPED)\n\t\tsk->sk_ipv6only = 1;\n\n\t \n\tif (snum || !(inet_test_bit(BIND_ADDRESS_NO_PORT, sk) ||\n\t\t      (flags & BIND_FORCE_ADDRESS_NO_PORT))) {\n\t\terr = sk->sk_prot->get_port(sk, snum);\n\t\tif (err) {\n\t\t\tsk->sk_ipv6only = saved_ipv6only;\n\t\t\tinet_reset_saddr(sk);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!(flags & BIND_FROM_BPF)) {\n\t\t\terr = BPF_CGROUP_RUN_PROG_INET6_POST_BIND(sk);\n\t\t\tif (err) {\n\t\t\t\tsk->sk_ipv6only = saved_ipv6only;\n\t\t\t\tinet_reset_saddr(sk);\n\t\t\t\tif (sk->sk_prot->put_port)\n\t\t\t\t\tsk->sk_prot->put_port(sk);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (addr_type != IPV6_ADDR_ANY)\n\t\tsk->sk_userlocks |= SOCK_BINDADDR_LOCK;\n\tif (snum)\n\t\tsk->sk_userlocks |= SOCK_BINDPORT_LOCK;\n\tinet->inet_sport = htons(inet->inet_num);\n\tinet->inet_dport = 0;\n\tinet->inet_daddr = 0;\nout:\n\tif (flags & BIND_WITH_LOCK)\n\t\trelease_sock(sk);\n\treturn err;\nout_unlock:\n\trcu_read_unlock();\n\tgoto out;\n}\n\nint inet6_bind_sk(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tu32 flags = BIND_WITH_LOCK;\n\tconst struct proto *prot;\n\tint err = 0;\n\n\t \n\tprot = READ_ONCE(sk->sk_prot);\n\t \n\tif (prot->bind)\n\t\treturn prot->bind(sk, uaddr, addr_len);\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\t \n\terr = BPF_CGROUP_RUN_PROG_INET_BIND_LOCK(sk, uaddr,\n\t\t\t\t\t\t CGROUP_INET6_BIND, &flags);\n\tif (err)\n\t\treturn err;\n\n\treturn __inet6_bind(sk, uaddr, addr_len, flags);\n}\n\n \nint inet6_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\treturn inet6_bind_sk(sock->sk, uaddr, addr_len);\n}\nEXPORT_SYMBOL(inet6_bind);\n\nint inet6_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (!sk)\n\t\treturn -EINVAL;\n\n\t \n\tipv6_sock_mc_close(sk);\n\n\t \n\tipv6_sock_ac_close(sk);\n\n\treturn inet_release(sock);\n}\nEXPORT_SYMBOL(inet6_release);\n\nvoid inet6_cleanup_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\n\t \n\n\tskb = xchg(&np->pktoptions, NULL);\n\tkfree_skb(skb);\n\n\tskb = xchg(&np->rxpmtu, NULL);\n\tkfree_skb(skb);\n\n\t \n\tfl6_free_socklist(sk);\n\n\t \n\n\topt = xchg((__force struct ipv6_txoptions **)&np->opt, NULL);\n\tif (opt) {\n\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\ttxopt_put(opt);\n\t}\n}\nEXPORT_SYMBOL_GPL(inet6_cleanup_sock);\n\n \nint inet6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t  int peer)\n{\n\tstruct sockaddr_in6 *sin = (struct sockaddr_in6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\tsin->sin6_family = AF_INET6;\n\tsin->sin6_flowinfo = 0;\n\tsin->sin6_scope_id = 0;\n\tlock_sock(sk);\n\tif (peer) {\n\t\tif (!inet->inet_dport ||\n\t\t    (((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_SYN_SENT)) &&\n\t\t    peer == 1)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn -ENOTCONN;\n\t\t}\n\t\tsin->sin6_port = inet->inet_dport;\n\t\tsin->sin6_addr = sk->sk_v6_daddr;\n\t\tif (np->sndflow)\n\t\t\tsin->sin6_flowinfo = np->flow_label;\n\t\tBPF_CGROUP_RUN_SA_PROG(sk, (struct sockaddr *)sin,\n\t\t\t\t       CGROUP_INET6_GETPEERNAME);\n\t} else {\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\t\tsin->sin6_addr = np->saddr;\n\t\telse\n\t\t\tsin->sin6_addr = sk->sk_v6_rcv_saddr;\n\t\tsin->sin6_port = inet->inet_sport;\n\t\tBPF_CGROUP_RUN_SA_PROG(sk, (struct sockaddr *)sin,\n\t\t\t\t       CGROUP_INET6_GETSOCKNAME);\n\t}\n\tsin->sin6_scope_id = ipv6_iface_scope_id(&sin->sin6_addr,\n\t\t\t\t\t\t sk->sk_bound_dev_if);\n\trelease_sock(sk);\n\treturn sizeof(*sin);\n}\nEXPORT_SYMBOL(inet6_getname);\n\nint inet6_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tconst struct proto *prot;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\tcase SIOCDELRT: {\n\t\tstruct in6_rtmsg rtmsg;\n\n\t\tif (copy_from_user(&rtmsg, argp, sizeof(rtmsg)))\n\t\t\treturn -EFAULT;\n\t\treturn ipv6_route_ioctl(net, cmd, &rtmsg);\n\t}\n\tcase SIOCSIFADDR:\n\t\treturn addrconf_add_ifaddr(net, argp);\n\tcase SIOCDIFADDR:\n\t\treturn addrconf_del_ifaddr(net, argp);\n\tcase SIOCSIFDSTADDR:\n\t\treturn addrconf_set_dstaddr(net, argp);\n\tdefault:\n\t\t \n\t\tprot = READ_ONCE(sk->sk_prot);\n\t\tif (!prot->ioctl)\n\t\t\treturn -ENOIOCTLCMD;\n\t\treturn sk_ioctl(sk, cmd, (void __user *)arg);\n\t}\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL(inet6_ioctl);\n\n#ifdef CONFIG_COMPAT\nstruct compat_in6_rtmsg {\n\tstruct in6_addr\t\trtmsg_dst;\n\tstruct in6_addr\t\trtmsg_src;\n\tstruct in6_addr\t\trtmsg_gateway;\n\tu32\t\t\trtmsg_type;\n\tu16\t\t\trtmsg_dst_len;\n\tu16\t\t\trtmsg_src_len;\n\tu32\t\t\trtmsg_metric;\n\tu32\t\t\trtmsg_info;\n\tu32\t\t\trtmsg_flags;\n\ts32\t\t\trtmsg_ifindex;\n};\n\nstatic int inet6_compat_routing_ioctl(struct sock *sk, unsigned int cmd,\n\t\tstruct compat_in6_rtmsg __user *ur)\n{\n\tstruct in6_rtmsg rt;\n\n\tif (copy_from_user(&rt.rtmsg_dst, &ur->rtmsg_dst,\n\t\t\t3 * sizeof(struct in6_addr)) ||\n\t    get_user(rt.rtmsg_type, &ur->rtmsg_type) ||\n\t    get_user(rt.rtmsg_dst_len, &ur->rtmsg_dst_len) ||\n\t    get_user(rt.rtmsg_src_len, &ur->rtmsg_src_len) ||\n\t    get_user(rt.rtmsg_metric, &ur->rtmsg_metric) ||\n\t    get_user(rt.rtmsg_info, &ur->rtmsg_info) ||\n\t    get_user(rt.rtmsg_flags, &ur->rtmsg_flags) ||\n\t    get_user(rt.rtmsg_ifindex, &ur->rtmsg_ifindex))\n\t\treturn -EFAULT;\n\n\n\treturn ipv6_route_ioctl(sock_net(sk), cmd, &rt);\n}\n\nint inet6_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct sock *sk = sock->sk;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\treturn inet6_compat_routing_ioctl(sk, cmd, argp);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\nEXPORT_SYMBOL_GPL(inet6_compat_ioctl);\n#endif  \n\nINDIRECT_CALLABLE_DECLARE(int udpv6_sendmsg(struct sock *, struct msghdr *,\n\t\t\t\t\t    size_t));\nint inet6_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)\n{\n\tstruct sock *sk = sock->sk;\n\tconst struct proto *prot;\n\n\tif (unlikely(inet_send_prepare(sk)))\n\t\treturn -EAGAIN;\n\n\t \n\tprot = READ_ONCE(sk->sk_prot);\n\treturn INDIRECT_CALL_2(prot->sendmsg, tcp_sendmsg, udpv6_sendmsg,\n\t\t\t       sk, msg, size);\n}\n\nINDIRECT_CALLABLE_DECLARE(int udpv6_recvmsg(struct sock *, struct msghdr *,\n\t\t\t\t\t    size_t, int, int *));\nint inet6_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t  int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tconst struct proto *prot;\n\tint addr_len = 0;\n\tint err;\n\n\tif (likely(!(flags & MSG_ERRQUEUE)))\n\t\tsock_rps_record_flow(sk);\n\n\t \n\tprot = READ_ONCE(sk->sk_prot);\n\terr = INDIRECT_CALL_2(prot->recvmsg, tcp_recvmsg, udpv6_recvmsg,\n\t\t\t      sk, msg, size, flags, &addr_len);\n\tif (err >= 0)\n\t\tmsg->msg_namelen = addr_len;\n\treturn err;\n}\n\nconst struct proto_ops inet6_stream_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_stream_connect,\t \n\t.socketpair\t   = sock_no_socketpair,\t \n\t.accept\t\t   = inet_accept,\t\t \n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = tcp_poll,\t\t\t \n\t.ioctl\t\t   = inet6_ioctl,\t\t \n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = inet_listen,\t\t \n\t.shutdown\t   = inet_shutdown,\t\t \n\t.setsockopt\t   = sock_common_setsockopt,\t \n\t.getsockopt\t   = sock_common_getsockopt,\t \n\t.sendmsg\t   = inet6_sendmsg,\t\t \n\t.recvmsg\t   = inet6_recvmsg,\t\t \n#ifdef CONFIG_MMU\n\t.mmap\t\t   = tcp_mmap,\n#endif\n\t.splice_eof\t   = inet_splice_eof,\n\t.sendmsg_locked    = tcp_sendmsg_locked,\n\t.splice_read\t   = tcp_splice_read,\n\t.read_sock\t   = tcp_read_sock,\n\t.read_skb\t   = tcp_read_skb,\n\t.peek_len\t   = tcp_peek_len,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t   = inet6_compat_ioctl,\n#endif\n\t.set_rcvlowat\t   = tcp_set_rcvlowat,\n};\n\nconst struct proto_ops inet6_dgram_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\t \n\t.socketpair\t   = sock_no_socketpair,\t \n\t.accept\t\t   = sock_no_accept,\t\t \n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = udp_poll,\t\t\t \n\t.ioctl\t\t   = inet6_ioctl,\t\t \n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = sock_no_listen,\t\t \n\t.shutdown\t   = inet_shutdown,\t\t \n\t.setsockopt\t   = sock_common_setsockopt,\t \n\t.getsockopt\t   = sock_common_getsockopt,\t \n\t.sendmsg\t   = inet6_sendmsg,\t\t \n\t.recvmsg\t   = inet6_recvmsg,\t\t \n\t.read_skb\t   = udp_read_skb,\n\t.mmap\t\t   = sock_no_mmap,\n\t.set_peek_off\t   = sk_set_peek_off,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t   = inet6_compat_ioctl,\n#endif\n};\n\nstatic const struct net_proto_family inet6_family_ops = {\n\t.family = PF_INET6,\n\t.create = inet6_create,\n\t.owner\t= THIS_MODULE,\n};\n\nint inet6_register_protosw(struct inet_protosw *p)\n{\n\tstruct list_head *lh;\n\tstruct inet_protosw *answer;\n\tstruct list_head *last_perm;\n\tint protocol = p->protocol;\n\tint ret;\n\n\tspin_lock_bh(&inetsw6_lock);\n\n\tret = -EINVAL;\n\tif (p->type >= SOCK_MAX)\n\t\tgoto out_illegal;\n\n\t \n\tanswer = NULL;\n\tret = -EPERM;\n\tlast_perm = &inetsw6[p->type];\n\tlist_for_each(lh, &inetsw6[p->type]) {\n\t\tanswer = list_entry(lh, struct inet_protosw, list);\n\n\t\t \n\t\tif (INET_PROTOSW_PERMANENT & answer->flags) {\n\t\t\tif (protocol == answer->protocol)\n\t\t\t\tbreak;\n\t\t\tlast_perm = lh;\n\t\t}\n\n\t\tanswer = NULL;\n\t}\n\tif (answer)\n\t\tgoto out_permanent;\n\n\t \n\tlist_add_rcu(&p->list, last_perm);\n\tret = 0;\nout:\n\tspin_unlock_bh(&inetsw6_lock);\n\treturn ret;\n\nout_permanent:\n\tpr_err(\"Attempt to override permanent protocol %d\\n\", protocol);\n\tgoto out;\n\nout_illegal:\n\tpr_err(\"Ignoring attempt to register invalid socket type %d\\n\",\n\t       p->type);\n\tgoto out;\n}\nEXPORT_SYMBOL(inet6_register_protosw);\n\nvoid\ninet6_unregister_protosw(struct inet_protosw *p)\n{\n\tif (INET_PROTOSW_PERMANENT & p->flags) {\n\t\tpr_err(\"Attempt to unregister permanent protocol %d\\n\",\n\t\t       p->protocol);\n\t} else {\n\t\tspin_lock_bh(&inetsw6_lock);\n\t\tlist_del_rcu(&p->list);\n\t\tspin_unlock_bh(&inetsw6_lock);\n\n\t\tsynchronize_net();\n\t}\n}\nEXPORT_SYMBOL(inet6_unregister_protosw);\n\nint inet6_sk_rebuild_header(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dst_entry *dst;\n\n\tdst = __sk_dst_check(sk, np->dst_cookie);\n\n\tif (!dst) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = sk->sk_protocol;\n\t\tfl6.daddr = sk->sk_v6_daddr;\n\t\tfl6.saddr = np->saddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tfl6.fl6_sport = inet->inet_sport;\n\t\tfl6.flowi6_uid = sk->sk_uid;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi_common(&fl6));\n\n\t\trcu_read_lock();\n\t\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt),\n\t\t\t\t\t &final);\n\t\trcu_read_unlock();\n\n\t\tdst = ip6_dst_lookup_flow(sock_net(sk), sk, &fl6, final_p);\n\t\tif (IS_ERR(dst)) {\n\t\t\tsk->sk_route_caps = 0;\n\t\t\tWRITE_ONCE(sk->sk_err_soft, -PTR_ERR(dst));\n\t\t\treturn PTR_ERR(dst);\n\t\t}\n\n\t\tip6_dst_store(sk, dst, NULL, NULL);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(inet6_sk_rebuild_header);\n\nbool ipv6_opt_accepted(const struct sock *sk, const struct sk_buff *skb,\n\t\t       const struct inet6_skb_parm *opt)\n{\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\n\tif (np->rxopt.all) {\n\t\tif (((opt->flags & IP6SKB_HOPBYHOP) &&\n\t\t     (np->rxopt.bits.hopopts || np->rxopt.bits.ohopopts)) ||\n\t\t    (ip6_flowinfo((struct ipv6hdr *) skb_network_header(skb)) &&\n\t\t     np->rxopt.bits.rxflow) ||\n\t\t    (opt->srcrt && (np->rxopt.bits.srcrt ||\n\t\t     np->rxopt.bits.osrcrt)) ||\n\t\t    ((opt->dst1 || opt->dst0) &&\n\t\t     (np->rxopt.bits.dstopts || np->rxopt.bits.odstopts)))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(ipv6_opt_accepted);\n\nstatic struct packet_type ipv6_packet_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_IPV6),\n\t.func = ipv6_rcv,\n\t.list_func = ipv6_list_rcv,\n};\n\nstatic int __init ipv6_packet_init(void)\n{\n\tdev_add_pack(&ipv6_packet_type);\n\treturn 0;\n}\n\nstatic void ipv6_packet_cleanup(void)\n{\n\tdev_remove_pack(&ipv6_packet_type);\n}\n\nstatic int __net_init ipv6_init_mibs(struct net *net)\n{\n\tint i;\n\n\tnet->mib.udp_stats_in6 = alloc_percpu(struct udp_mib);\n\tif (!net->mib.udp_stats_in6)\n\t\treturn -ENOMEM;\n\tnet->mib.udplite_stats_in6 = alloc_percpu(struct udp_mib);\n\tif (!net->mib.udplite_stats_in6)\n\t\tgoto err_udplite_mib;\n\tnet->mib.ipv6_statistics = alloc_percpu(struct ipstats_mib);\n\tif (!net->mib.ipv6_statistics)\n\t\tgoto err_ip_mib;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct ipstats_mib *af_inet6_stats;\n\t\taf_inet6_stats = per_cpu_ptr(net->mib.ipv6_statistics, i);\n\t\tu64_stats_init(&af_inet6_stats->syncp);\n\t}\n\n\n\tnet->mib.icmpv6_statistics = alloc_percpu(struct icmpv6_mib);\n\tif (!net->mib.icmpv6_statistics)\n\t\tgoto err_icmp_mib;\n\tnet->mib.icmpv6msg_statistics = kzalloc(sizeof(struct icmpv6msg_mib),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!net->mib.icmpv6msg_statistics)\n\t\tgoto err_icmpmsg_mib;\n\treturn 0;\n\nerr_icmpmsg_mib:\n\tfree_percpu(net->mib.icmpv6_statistics);\nerr_icmp_mib:\n\tfree_percpu(net->mib.ipv6_statistics);\nerr_ip_mib:\n\tfree_percpu(net->mib.udplite_stats_in6);\nerr_udplite_mib:\n\tfree_percpu(net->mib.udp_stats_in6);\n\treturn -ENOMEM;\n}\n\nstatic void ipv6_cleanup_mibs(struct net *net)\n{\n\tfree_percpu(net->mib.udp_stats_in6);\n\tfree_percpu(net->mib.udplite_stats_in6);\n\tfree_percpu(net->mib.ipv6_statistics);\n\tfree_percpu(net->mib.icmpv6_statistics);\n\tkfree(net->mib.icmpv6msg_statistics);\n}\n\nstatic int __net_init inet6_net_init(struct net *net)\n{\n\tint err = 0;\n\n\tnet->ipv6.sysctl.bindv6only = 0;\n\tnet->ipv6.sysctl.icmpv6_time = 1*HZ;\n\tnet->ipv6.sysctl.icmpv6_echo_ignore_all = 0;\n\tnet->ipv6.sysctl.icmpv6_echo_ignore_multicast = 0;\n\tnet->ipv6.sysctl.icmpv6_echo_ignore_anycast = 0;\n\tnet->ipv6.sysctl.icmpv6_error_anycast_as_unicast = 0;\n\n\t \n\tbitmap_set(net->ipv6.sysctl.icmpv6_ratemask, 0, ICMPV6_ERRMSG_MAX + 1);\n\tbitmap_clear(net->ipv6.sysctl.icmpv6_ratemask, ICMPV6_PKT_TOOBIG, 1);\n\tnet->ipv6.sysctl.icmpv6_ratemask_ptr = net->ipv6.sysctl.icmpv6_ratemask;\n\n\tnet->ipv6.sysctl.flowlabel_consistency = 1;\n\tnet->ipv6.sysctl.auto_flowlabels = IP6_DEFAULT_AUTO_FLOW_LABELS;\n\tnet->ipv6.sysctl.idgen_retries = 3;\n\tnet->ipv6.sysctl.idgen_delay = 1 * HZ;\n\tnet->ipv6.sysctl.flowlabel_state_ranges = 0;\n\tnet->ipv6.sysctl.max_dst_opts_cnt = IP6_DEFAULT_MAX_DST_OPTS_CNT;\n\tnet->ipv6.sysctl.max_hbh_opts_cnt = IP6_DEFAULT_MAX_HBH_OPTS_CNT;\n\tnet->ipv6.sysctl.max_dst_opts_len = IP6_DEFAULT_MAX_DST_OPTS_LEN;\n\tnet->ipv6.sysctl.max_hbh_opts_len = IP6_DEFAULT_MAX_HBH_OPTS_LEN;\n\tnet->ipv6.sysctl.fib_notify_on_flag_change = 0;\n\tatomic_set(&net->ipv6.fib6_sernum, 1);\n\n\tnet->ipv6.sysctl.ioam6_id = IOAM6_DEFAULT_ID;\n\tnet->ipv6.sysctl.ioam6_id_wide = IOAM6_DEFAULT_ID_WIDE;\n\n\terr = ipv6_init_mibs(net);\n\tif (err)\n\t\treturn err;\n#ifdef CONFIG_PROC_FS\n\terr = udp6_proc_init(net);\n\tif (err)\n\t\tgoto out;\n\terr = tcp6_proc_init(net);\n\tif (err)\n\t\tgoto proc_tcp6_fail;\n\terr = ac6_proc_init(net);\n\tif (err)\n\t\tgoto proc_ac6_fail;\n#endif\n\treturn err;\n\n#ifdef CONFIG_PROC_FS\nproc_ac6_fail:\n\ttcp6_proc_exit(net);\nproc_tcp6_fail:\n\tudp6_proc_exit(net);\nout:\n\tipv6_cleanup_mibs(net);\n\treturn err;\n#endif\n}\n\nstatic void __net_exit inet6_net_exit(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tudp6_proc_exit(net);\n\ttcp6_proc_exit(net);\n\tac6_proc_exit(net);\n#endif\n\tipv6_cleanup_mibs(net);\n}\n\nstatic struct pernet_operations inet6_net_ops = {\n\t.init = inet6_net_init,\n\t.exit = inet6_net_exit,\n};\n\nstatic int ipv6_route_input(struct sk_buff *skb)\n{\n\tip6_route_input(skb);\n\treturn skb_dst(skb)->error;\n}\n\nstatic const struct ipv6_stub ipv6_stub_impl = {\n\t.ipv6_sock_mc_join = ipv6_sock_mc_join,\n\t.ipv6_sock_mc_drop = ipv6_sock_mc_drop,\n\t.ipv6_dst_lookup_flow = ip6_dst_lookup_flow,\n\t.ipv6_route_input  = ipv6_route_input,\n\t.fib6_get_table\t   = fib6_get_table,\n\t.fib6_table_lookup = fib6_table_lookup,\n\t.fib6_lookup       = fib6_lookup,\n\t.fib6_select_path  = fib6_select_path,\n\t.ip6_mtu_from_fib6 = ip6_mtu_from_fib6,\n\t.fib6_nh_init\t   = fib6_nh_init,\n\t.fib6_nh_release   = fib6_nh_release,\n\t.fib6_nh_release_dsts = fib6_nh_release_dsts,\n\t.fib6_update_sernum = fib6_update_sernum_stub,\n\t.fib6_rt_update\t   = fib6_rt_update,\n\t.ip6_del_rt\t   = ip6_del_rt,\n\t.udpv6_encap_enable = udpv6_encap_enable,\n\t.ndisc_send_na = ndisc_send_na,\n#if IS_ENABLED(CONFIG_XFRM)\n\t.xfrm6_local_rxpmtu = xfrm6_local_rxpmtu,\n\t.xfrm6_udp_encap_rcv = xfrm6_udp_encap_rcv,\n\t.xfrm6_rcv_encap = xfrm6_rcv_encap,\n#endif\n\t.nd_tbl\t= &nd_tbl,\n\t.ipv6_fragment = ip6_fragment,\n\t.ipv6_dev_find = ipv6_dev_find,\n};\n\nstatic const struct ipv6_bpf_stub ipv6_bpf_stub_impl = {\n\t.inet6_bind = __inet6_bind,\n\t.udp6_lib_lookup = __udp6_lib_lookup,\n\t.ipv6_setsockopt = do_ipv6_setsockopt,\n\t.ipv6_getsockopt = do_ipv6_getsockopt,\n};\n\nstatic int __init inet6_init(void)\n{\n\tstruct list_head *r;\n\tint err = 0;\n\n\tsock_skb_cb_check_size(sizeof(struct inet6_skb_parm));\n\n\t \n\tfor (r = &inetsw6[0]; r < &inetsw6[SOCK_MAX]; ++r)\n\t\tINIT_LIST_HEAD(r);\n\n\traw_hashinfo_init(&raw_v6_hashinfo);\n\n\tif (disable_ipv6_mod) {\n\t\tpr_info(\"Loaded, but administratively disabled, reboot required to enable\\n\");\n\t\tgoto out;\n\t}\n\n\terr = proto_register(&tcpv6_prot, 1);\n\tif (err)\n\t\tgoto out;\n\n\terr = proto_register(&udpv6_prot, 1);\n\tif (err)\n\t\tgoto out_unregister_tcp_proto;\n\n\terr = proto_register(&udplitev6_prot, 1);\n\tif (err)\n\t\tgoto out_unregister_udp_proto;\n\n\terr = proto_register(&rawv6_prot, 1);\n\tif (err)\n\t\tgoto out_unregister_udplite_proto;\n\n\terr = proto_register(&pingv6_prot, 1);\n\tif (err)\n\t\tgoto out_unregister_raw_proto;\n\n\t \n\terr = rawv6_init();\n\tif (err)\n\t\tgoto out_unregister_ping_proto;\n\n\t \n\terr = sock_register(&inet6_family_ops);\n\tif (err)\n\t\tgoto out_sock_register_fail;\n\n\t \n\n\terr = register_pernet_subsys(&inet6_net_ops);\n\tif (err)\n\t\tgoto register_pernet_fail;\n\terr = ip6_mr_init();\n\tif (err)\n\t\tgoto ipmr_fail;\n\terr = icmpv6_init();\n\tif (err)\n\t\tgoto icmp_fail;\n\terr = ndisc_init();\n\tif (err)\n\t\tgoto ndisc_fail;\n\terr = igmp6_init();\n\tif (err)\n\t\tgoto igmp_fail;\n\n\terr = ipv6_netfilter_init();\n\tif (err)\n\t\tgoto netfilter_fail;\n\t \n#ifdef CONFIG_PROC_FS\n\terr = -ENOMEM;\n\tif (raw6_proc_init())\n\t\tgoto proc_raw6_fail;\n\tif (udplite6_proc_init())\n\t\tgoto proc_udplite6_fail;\n\tif (ipv6_misc_proc_init())\n\t\tgoto proc_misc6_fail;\n\tif (if6_proc_init())\n\t\tgoto proc_if6_fail;\n#endif\n\terr = ip6_route_init();\n\tif (err)\n\t\tgoto ip6_route_fail;\n\terr = ndisc_late_init();\n\tif (err)\n\t\tgoto ndisc_late_fail;\n\terr = ip6_flowlabel_init();\n\tif (err)\n\t\tgoto ip6_flowlabel_fail;\n\terr = ipv6_anycast_init();\n\tif (err)\n\t\tgoto ipv6_anycast_fail;\n\terr = addrconf_init();\n\tif (err)\n\t\tgoto addrconf_fail;\n\n\t \n\terr = ipv6_exthdrs_init();\n\tif (err)\n\t\tgoto ipv6_exthdrs_fail;\n\n\terr = ipv6_frag_init();\n\tif (err)\n\t\tgoto ipv6_frag_fail;\n\n\t \n\terr = udpv6_init();\n\tif (err)\n\t\tgoto udpv6_fail;\n\n\terr = udplitev6_init();\n\tif (err)\n\t\tgoto udplitev6_fail;\n\n\terr = udpv6_offload_init();\n\tif (err)\n\t\tgoto udpv6_offload_fail;\n\n\terr = tcpv6_init();\n\tif (err)\n\t\tgoto tcpv6_fail;\n\n\terr = ipv6_packet_init();\n\tif (err)\n\t\tgoto ipv6_packet_fail;\n\n\terr = pingv6_init();\n\tif (err)\n\t\tgoto pingv6_fail;\n\n\terr = calipso_init();\n\tif (err)\n\t\tgoto calipso_fail;\n\n\terr = seg6_init();\n\tif (err)\n\t\tgoto seg6_fail;\n\n\terr = rpl_init();\n\tif (err)\n\t\tgoto rpl_fail;\n\n\terr = ioam6_init();\n\tif (err)\n\t\tgoto ioam6_fail;\n\n\terr = igmp6_late_init();\n\tif (err)\n\t\tgoto igmp6_late_err;\n\n#ifdef CONFIG_SYSCTL\n\terr = ipv6_sysctl_register();\n\tif (err)\n\t\tgoto sysctl_fail;\n#endif\n\n\t \n\twmb();\n\tipv6_stub = &ipv6_stub_impl;\n\tipv6_bpf_stub = &ipv6_bpf_stub_impl;\nout:\n\treturn err;\n\n#ifdef CONFIG_SYSCTL\nsysctl_fail:\n\tigmp6_late_cleanup();\n#endif\nigmp6_late_err:\n\tioam6_exit();\nioam6_fail:\n\trpl_exit();\nrpl_fail:\n\tseg6_exit();\nseg6_fail:\n\tcalipso_exit();\ncalipso_fail:\n\tpingv6_exit();\npingv6_fail:\n\tipv6_packet_cleanup();\nipv6_packet_fail:\n\ttcpv6_exit();\ntcpv6_fail:\n\tudpv6_offload_exit();\nudpv6_offload_fail:\n\tudplitev6_exit();\nudplitev6_fail:\n\tudpv6_exit();\nudpv6_fail:\n\tipv6_frag_exit();\nipv6_frag_fail:\n\tipv6_exthdrs_exit();\nipv6_exthdrs_fail:\n\taddrconf_cleanup();\naddrconf_fail:\n\tipv6_anycast_cleanup();\nipv6_anycast_fail:\n\tip6_flowlabel_cleanup();\nip6_flowlabel_fail:\n\tndisc_late_cleanup();\nndisc_late_fail:\n\tip6_route_cleanup();\nip6_route_fail:\n#ifdef CONFIG_PROC_FS\n\tif6_proc_exit();\nproc_if6_fail:\n\tipv6_misc_proc_exit();\nproc_misc6_fail:\n\tudplite6_proc_exit();\nproc_udplite6_fail:\n\traw6_proc_exit();\nproc_raw6_fail:\n#endif\n\tipv6_netfilter_fini();\nnetfilter_fail:\n\tigmp6_cleanup();\nigmp_fail:\n\tndisc_cleanup();\nndisc_fail:\n\ticmpv6_cleanup();\nicmp_fail:\n\tip6_mr_cleanup();\nipmr_fail:\n\tunregister_pernet_subsys(&inet6_net_ops);\nregister_pernet_fail:\n\tsock_unregister(PF_INET6);\n\trtnl_unregister_all(PF_INET6);\nout_sock_register_fail:\n\trawv6_exit();\nout_unregister_ping_proto:\n\tproto_unregister(&pingv6_prot);\nout_unregister_raw_proto:\n\tproto_unregister(&rawv6_prot);\nout_unregister_udplite_proto:\n\tproto_unregister(&udplitev6_prot);\nout_unregister_udp_proto:\n\tproto_unregister(&udpv6_prot);\nout_unregister_tcp_proto:\n\tproto_unregister(&tcpv6_prot);\n\tgoto out;\n}\nmodule_init(inet6_init);\n\nMODULE_ALIAS_NETPROTO(PF_INET6);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}