{
  "module_name": "ipv6_sockglue.c",
  "hash_id": "20d41c80efd19a397e79a5c442985e993cf58b2ab95e1aeff1ed886993fd9d53",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ipv6_sockglue.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/mroute6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/netfilter.h>\n#include <linux/slab.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/inet_common.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/udplite.h>\n#include <net/xfrm.h>\n#include <net/compat.h>\n#include <net/seg6.h>\n\n#include <linux/uaccess.h>\n\nstruct ip6_ra_chain *ip6_ra_chain;\nDEFINE_RWLOCK(ip6_ra_lock);\n\nDEFINE_STATIC_KEY_FALSE(ip6_min_hopcount);\n\nint ip6_ra_control(struct sock *sk, int sel)\n{\n\tstruct ip6_ra_chain *ra, *new_ra, **rap;\n\n\t \n\tif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num != IPPROTO_RAW)\n\t\treturn -ENOPROTOOPT;\n\n\tnew_ra = (sel >= 0) ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n\tif (sel >= 0 && !new_ra)\n\t\treturn -ENOMEM;\n\n\twrite_lock_bh(&ip6_ra_lock);\n\tfor (rap = &ip6_ra_chain; (ra = *rap) != NULL; rap = &ra->next) {\n\t\tif (ra->sk == sk) {\n\t\t\tif (sel >= 0) {\n\t\t\t\twrite_unlock_bh(&ip6_ra_lock);\n\t\t\t\tkfree(new_ra);\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\n\t\t\t*rap = ra->next;\n\t\t\twrite_unlock_bh(&ip6_ra_lock);\n\n\t\t\tsock_put(sk);\n\t\t\tkfree(ra);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!new_ra) {\n\t\twrite_unlock_bh(&ip6_ra_lock);\n\t\treturn -ENOBUFS;\n\t}\n\tnew_ra->sk = sk;\n\tnew_ra->sel = sel;\n\tnew_ra->next = ra;\n\t*rap = new_ra;\n\tsock_hold(sk);\n\twrite_unlock_bh(&ip6_ra_lock);\n\treturn 0;\n}\n\nstruct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_test_bit(IS_ICSK, sk)) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg((__force struct ipv6_txoptions **)&inet6_sk(sk)->opt,\n\t\t   opt);\n\tsk_dst_reset(sk);\n\n\treturn opt;\n}\n\nstatic bool setsockopt_needs_rtnl(int optname)\n{\n\tswitch (optname) {\n\tcase IPV6_ADDRFORM:\n\tcase IPV6_ADD_MEMBERSHIP:\n\tcase IPV6_DROP_MEMBERSHIP:\n\tcase IPV6_JOIN_ANYCAST:\n\tcase IPV6_LEAVE_ANYCAST:\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\tcase MCAST_MSFILTER:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int copy_group_source_from_sockptr(struct group_source_req *greqs,\n\t\tsockptr_t optval, int optlen)\n{\n\tif (in_compat_syscall()) {\n\t\tstruct compat_group_source_req gr32;\n\n\t\tif (optlen < sizeof(gr32))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&gr32, optval, sizeof(gr32)))\n\t\t\treturn -EFAULT;\n\t\tgreqs->gsr_interface = gr32.gsr_interface;\n\t\tgreqs->gsr_group = gr32.gsr_group;\n\t\tgreqs->gsr_source = gr32.gsr_source;\n\t} else {\n\t\tif (optlen < sizeof(*greqs))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(greqs, optval, sizeof(*greqs)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_ipv6_mcast_group_source(struct sock *sk, int optname,\n\t\tsockptr_t optval, int optlen)\n{\n\tstruct group_source_req greqs;\n\tint omode, add;\n\tint ret;\n\n\tret = copy_group_source_from_sockptr(&greqs, optval, optlen);\n\tif (ret)\n\t\treturn ret;\n\n\tif (greqs.gsr_group.ss_family != AF_INET6 ||\n\t    greqs.gsr_source.ss_family != AF_INET6)\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (optname == MCAST_BLOCK_SOURCE) {\n\t\tomode = MCAST_EXCLUDE;\n\t\tadd = 1;\n\t} else if (optname == MCAST_UNBLOCK_SOURCE) {\n\t\tomode = MCAST_EXCLUDE;\n\t\tadd = 0;\n\t} else if (optname == MCAST_JOIN_SOURCE_GROUP) {\n\t\tstruct sockaddr_in6 *psin6;\n\t\tint retv;\n\n\t\tpsin6 = (struct sockaddr_in6 *)&greqs.gsr_group;\n\t\tretv = ipv6_sock_mc_join_ssm(sk, greqs.gsr_interface,\n\t\t\t\t\t     &psin6->sin6_addr,\n\t\t\t\t\t     MCAST_INCLUDE);\n\t\t \n\t\tif (retv && retv != -EADDRINUSE)\n\t\t\treturn retv;\n\t\tomode = MCAST_INCLUDE;\n\t\tadd = 1;\n\t} else   {\n\t\tomode = MCAST_INCLUDE;\n\t\tadd = 0;\n\t}\n\treturn ip6_mc_source(add, omode, sk, &greqs);\n}\n\nstatic int ipv6_set_mcast_msfilter(struct sock *sk, sockptr_t optval,\n\t\tint optlen)\n{\n\tstruct group_filter *gsf;\n\tint ret;\n\n\tif (optlen < GROUP_FILTER_SIZE(0))\n\t\treturn -EINVAL;\n\tif (optlen > READ_ONCE(sysctl_optmem_max))\n\t\treturn -ENOBUFS;\n\n\tgsf = memdup_sockptr(optval, optlen);\n\tif (IS_ERR(gsf))\n\t\treturn PTR_ERR(gsf);\n\n\t \n\tret = -ENOBUFS;\n\tif (gsf->gf_numsrc >= 0x1ffffffU ||\n\t    gsf->gf_numsrc > sysctl_mld_max_msf)\n\t\tgoto out_free_gsf;\n\n\tret = -EINVAL;\n\tif (GROUP_FILTER_SIZE(gsf->gf_numsrc) > optlen)\n\t\tgoto out_free_gsf;\n\n\tret = ip6_mc_msfilter(sk, gsf, gsf->gf_slist_flex);\nout_free_gsf:\n\tkfree(gsf);\n\treturn ret;\n}\n\nstatic int compat_ipv6_set_mcast_msfilter(struct sock *sk, sockptr_t optval,\n\t\tint optlen)\n{\n\tconst int size0 = offsetof(struct compat_group_filter, gf_slist_flex);\n\tstruct compat_group_filter *gf32;\n\tvoid *p;\n\tint ret;\n\tint n;\n\n\tif (optlen < size0)\n\t\treturn -EINVAL;\n\tif (optlen > READ_ONCE(sysctl_optmem_max) - 4)\n\t\treturn -ENOBUFS;\n\n\tp = kmalloc(optlen + 4, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tgf32 = p + 4;  \n\tret = -EFAULT;\n\tif (copy_from_sockptr(gf32, optval, optlen))\n\t\tgoto out_free_p;\n\n\t \n\tret = -ENOBUFS;\n\tn = gf32->gf_numsrc;\n\tif (n >= 0x1ffffffU || n > sysctl_mld_max_msf)\n\t\tgoto out_free_p;\n\n\tret = -EINVAL;\n\tif (offsetof(struct compat_group_filter, gf_slist_flex[n]) > optlen)\n\t\tgoto out_free_p;\n\n\tret = ip6_mc_msfilter(sk, &(struct group_filter){\n\t\t\t.gf_interface = gf32->gf_interface,\n\t\t\t.gf_group = gf32->gf_group,\n\t\t\t.gf_fmode = gf32->gf_fmode,\n\t\t\t.gf_numsrc = gf32->gf_numsrc}, gf32->gf_slist_flex);\n\nout_free_p:\n\tkfree(p);\n\treturn ret;\n}\n\nstatic int ipv6_mcast_join_leave(struct sock *sk, int optname,\n\t\tsockptr_t optval, int optlen)\n{\n\tstruct sockaddr_in6 *psin6;\n\tstruct group_req greq;\n\n\tif (optlen < sizeof(greq))\n\t\treturn -EINVAL;\n\tif (copy_from_sockptr(&greq, optval, sizeof(greq)))\n\t\treturn -EFAULT;\n\n\tif (greq.gr_group.ss_family != AF_INET6)\n\t\treturn -EADDRNOTAVAIL;\n\tpsin6 = (struct sockaddr_in6 *)&greq.gr_group;\n\tif (optname == MCAST_JOIN_GROUP)\n\t\treturn ipv6_sock_mc_join(sk, greq.gr_interface,\n\t\t\t\t\t &psin6->sin6_addr);\n\treturn ipv6_sock_mc_drop(sk, greq.gr_interface, &psin6->sin6_addr);\n}\n\nstatic int compat_ipv6_mcast_join_leave(struct sock *sk, int optname,\n\t\tsockptr_t optval, int optlen)\n{\n\tstruct compat_group_req gr32;\n\tstruct sockaddr_in6 *psin6;\n\n\tif (optlen < sizeof(gr32))\n\t\treturn -EINVAL;\n\tif (copy_from_sockptr(&gr32, optval, sizeof(gr32)))\n\t\treturn -EFAULT;\n\n\tif (gr32.gr_group.ss_family != AF_INET6)\n\t\treturn -EADDRNOTAVAIL;\n\tpsin6 = (struct sockaddr_in6 *)&gr32.gr_group;\n\tif (optname == MCAST_JOIN_GROUP)\n\t\treturn ipv6_sock_mc_join(sk, gr32.gr_interface,\n\t\t\t\t\t&psin6->sin6_addr);\n\treturn ipv6_sock_mc_drop(sk, gr32.gr_interface, &psin6->sin6_addr);\n}\n\nstatic int ipv6_set_opt_hdr(struct sock *sk, int optname, sockptr_t optval,\n\t\tint optlen)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_opt_hdr *new = NULL;\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6_txoptions *opt;\n\tint err;\n\n\t \n\tif (optname != IPV6_RTHDR && !sockopt_ns_capable(net->user_ns, CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\t \n\tif (optlen > 0) {\n\t\tif (sockptr_is_null(optval))\n\t\t\treturn -EINVAL;\n\t\tif (optlen < sizeof(struct ipv6_opt_hdr) ||\n\t\t    optlen & 0x7 ||\n\t\t    optlen > 8 * 255)\n\t\t\treturn -EINVAL;\n\n\t\tnew = memdup_sockptr(optval, optlen);\n\t\tif (IS_ERR(new))\n\t\t\treturn PTR_ERR(new);\n\t\tif (unlikely(ipv6_optlen(new) > optlen)) {\n\t\t\tkfree(new);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\topt = rcu_dereference_protected(np->opt, lockdep_sock_is_held(sk));\n\topt = ipv6_renew_options(sk, opt, optname, new);\n\tkfree(new);\n\tif (IS_ERR(opt))\n\t\treturn PTR_ERR(opt);\n\n\t \n\terr = -EINVAL;\n\tif (optname == IPV6_RTHDR && opt && opt->srcrt) {\n\t\tstruct ipv6_rt_hdr *rthdr = opt->srcrt;\n\t\tswitch (rthdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tcase IPV6_SRCRT_TYPE_2:\n\t\t\tif (rthdr->hdrlen != 2 || rthdr->segments_left != 1)\n\t\t\t\tgoto sticky_done;\n\t\t\tbreak;\n#endif\n\t\tcase IPV6_SRCRT_TYPE_4:\n\t\t{\n\t\t\tstruct ipv6_sr_hdr *srh =\n\t\t\t\t(struct ipv6_sr_hdr *)opt->srcrt;\n\n\t\t\tif (!seg6_validate_srh(srh, optlen, false))\n\t\t\t\tgoto sticky_done;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tgoto sticky_done;\n\t\t}\n\t}\n\n\terr = 0;\n\topt = ipv6_update_options(sk, opt);\nsticky_done:\n\tif (opt) {\n\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\ttxopt_put(opt);\n\t}\n\treturn err;\n}\n\nint do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint val, valbool;\n\tint retv = -ENOPROTOOPT;\n\tbool needs_rtnl = setsockopt_needs_rtnl(optname);\n\n\tif (sockptr_is_null(optval))\n\t\tval = 0;\n\telse {\n\t\tif (optlen >= sizeof(int)) {\n\t\t\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\t\t\treturn -EFAULT;\n\t\t} else\n\t\t\tval = 0;\n\t}\n\n\tvalbool = (val != 0);\n\n\tif (ip6_mroute_opt(optname))\n\t\treturn ip6_mroute_setsockopt(sk, optname, optval, optlen);\n\n\tif (needs_rtnl)\n\t\trtnl_lock();\n\tsockopt_lock_sock(sk);\n\n\t \n\tif (unlikely(sk->sk_family != AF_INET6))\n\t\tgoto unlock;\n\n\tswitch (optname) {\n\n\tcase IPV6_ADDRFORM:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val == PF_INET) {\n\t\t\tif (sk->sk_type == SOCK_RAW)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_protocol == IPPROTO_UDP ||\n\t\t\t    sk->sk_protocol == IPPROTO_UDPLITE) {\n\t\t\t\tstruct udp_sock *up = udp_sk(sk);\n\t\t\t\tif (up->pending == AF_INET6) {\n\t\t\t\t\tretv = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (sk->sk_protocol == IPPROTO_TCP) {\n\t\t\t\tif (sk->sk_prot != &tcpv6_prot) {\n\t\t\t\t\tretv = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\t\tretv = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ipv6_only_sock(sk) ||\n\t\t\t    !ipv6_addr_v4mapped(&sk->sk_v6_daddr)) {\n\t\t\t\tretv = -EADDRNOTAVAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t__ipv6_sock_mc_close(sk);\n\t\t\t__ipv6_sock_ac_close(sk);\n\n\t\t\tif (sk->sk_protocol == IPPROTO_TCP) {\n\t\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, &tcp_prot, 1);\n\n\t\t\t\t \n\t\t\t\tWRITE_ONCE(sk->sk_prot, &tcp_prot);\n\t\t\t\t \n\t\t\t\tWRITE_ONCE(icsk->icsk_af_ops, &ipv4_specific);\n\t\t\t\tWRITE_ONCE(sk->sk_socket->ops, &inet_stream_ops);\n\t\t\t\tWRITE_ONCE(sk->sk_family, PF_INET);\n\t\t\t\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t\t} else {\n\t\t\t\tstruct proto *prot = &udp_prot;\n\n\t\t\t\tif (sk->sk_protocol == IPPROTO_UDPLITE)\n\t\t\t\t\tprot = &udplite_prot;\n\n\t\t\t\tsock_prot_inuse_add(net, sk->sk_prot, -1);\n\t\t\t\tsock_prot_inuse_add(net, prot, 1);\n\n\t\t\t\t \n\t\t\t\tWRITE_ONCE(sk->sk_prot, prot);\n\t\t\t\tWRITE_ONCE(sk->sk_socket->ops, &inet_dgram_ops);\n\t\t\t\tWRITE_ONCE(sk->sk_family, PF_INET);\n\t\t\t}\n\n\t\t\t \n\t\t\tnp->rxopt.all = 0;\n\n\t\t\tinet6_cleanup_sock(sk);\n\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\t\tgoto e_inval;\n\n\tcase IPV6_V6ONLY:\n\t\tif (optlen < sizeof(int) ||\n\t\t    inet_sk(sk)->inet_num)\n\t\t\tgoto e_inval;\n\t\tsk->sk_ipv6only = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292PKTINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxoinfo = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxhlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPLIMIT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxohlim = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVRTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.srcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292RTHDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.osrcrt = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.hopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292HOPOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.ohopopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVDSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.dstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_2292DSTOPTS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.odstopts = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < -1 || val > 0xff)\n\t\t\tgoto e_inval;\n\t\t \n\t\tif (val == -1)\n\t\t\tval = 0;\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tval &= ~INET_ECN_MASK;\n\t\t\tval |= np->tclass & INET_ECN_MASK;\n\t\t}\n\t\tif (np->tclass != val) {\n\t\t\tnp->tclass = val;\n\t\t\tsk_dst_reset(sk);\n\t\t}\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVTCLASS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxtclass = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVPATHMTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxpmtu = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_TRANSPARENT:\n\t\tif (valbool && !sockopt_ns_capable(net->user_ns, CAP_NET_RAW) &&\n\t\t    !sockopt_ns_capable(net->user_ns, CAP_NET_ADMIN)) {\n\t\t\tretv = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\t \n\t\tinet_assign_bit(TRANSPARENT, sk, valbool);\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_FREEBIND:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\t \n\t\tinet_assign_bit(FREEBIND, sk, valbool);\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_RECVORIGDSTADDR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rxopt.bits.rxorigdstaddr = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t\tretv = ipv6_set_opt_hdr(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IPV6_PKTINFO:\n\t{\n\t\tstruct in6_pktinfo pkt;\n\n\t\tif (optlen == 0)\n\t\t\tgoto e_inval;\n\t\telse if (optlen < sizeof(struct in6_pktinfo) ||\n\t\t\t sockptr_is_null(optval))\n\t\t\tgoto e_inval;\n\n\t\tif (copy_from_sockptr(&pkt, optval, sizeof(pkt))) {\n\t\t\tretv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!sk_dev_equal_l3scope(sk, pkt.ipi6_ifindex))\n\t\t\tgoto e_inval;\n\n\t\tnp->sticky_pktinfo.ipi6_ifindex = pkt.ipi6_ifindex;\n\t\tnp->sticky_pktinfo.ipi6_addr = pkt.ipi6_addr;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_2292PKTOPTIONS:\n\t{\n\t\tstruct ipv6_txoptions *opt = NULL;\n\t\tstruct msghdr msg;\n\t\tstruct flowi6 fl6;\n\t\tstruct ipcm6_cookie ipc6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\n\t\tif (optlen == 0)\n\t\t\tgoto update;\n\n\t\t \n\t\tretv = -EINVAL;\n\t\tif (optlen > 64*1024)\n\t\t\tbreak;\n\n\t\topt = sock_kmalloc(sk, sizeof(*opt) + optlen, GFP_KERNEL);\n\t\tretv = -ENOBUFS;\n\t\tif (!opt)\n\t\t\tbreak;\n\n\t\tmemset(opt, 0, sizeof(*opt));\n\t\trefcount_set(&opt->refcnt, 1);\n\t\topt->tot_len = sizeof(*opt) + optlen;\n\t\tretv = -EFAULT;\n\t\tif (copy_from_sockptr(opt + 1, optval, optlen))\n\t\t\tgoto done;\n\n\t\tmsg.msg_controllen = optlen;\n\t\tmsg.msg_control_is_user = false;\n\t\tmsg.msg_control = (void *)(opt+1);\n\t\tipc6.opt = opt;\n\n\t\tretv = ip6_datagram_send_ctl(net, sk, &msg, &fl6, &ipc6);\n\t\tif (retv)\n\t\t\tgoto done;\nupdate:\n\t\tretv = 0;\n\t\topt = ipv6_update_options(sk, opt);\ndone:\n\t\tif (opt) {\n\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\t\ttxopt_put(opt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase IPV6_UNICAST_HOPS:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->hop_limit = val;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_HOPS:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val > 255 || val < -1)\n\t\t\tgoto e_inval;\n\t\tnp->mcast_hops = (val == -1 ? IPV6_DEFAULT_MCASTHOPS : val);\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_LOOP:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val != valbool)\n\t\t\tgoto e_inval;\n\t\tnp->mc_loop = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_IF:\n\t{\n\t\tstruct net_device *dev = NULL;\n\t\tint ifindex;\n\n\t\tif (optlen != sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tifindex = (__force int)ntohl((__force __be32)val);\n\t\tif (ifindex == 0) {\n\t\t\tnp->ucast_oif = 0;\n\t\t\tretv = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev = dev_get_by_index(net, ifindex);\n\t\tretv = -EADDRNOTAVAIL;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tdev_put(dev);\n\n\t\tretv = -EINVAL;\n\t\tif (sk->sk_bound_dev_if)\n\t\t\tbreak;\n\n\t\tnp->ucast_oif = ifindex;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPV6_MULTICAST_IF:\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\tbreak;\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\n\t\tif (val) {\n\t\t\tstruct net_device *dev;\n\t\t\tint midx;\n\n\t\t\trcu_read_lock();\n\n\t\t\tdev = dev_get_by_index_rcu(net, val);\n\t\t\tif (!dev) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tretv = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmidx = l3mdev_master_ifindex_rcu(dev);\n\n\t\t\trcu_read_unlock();\n\n\t\t\tif (sk->sk_bound_dev_if &&\n\t\t\t    sk->sk_bound_dev_if != val &&\n\t\t\t    (!midx || midx != sk->sk_bound_dev_if))\n\t\t\t\tgoto e_inval;\n\t\t}\n\t\tnp->mcast_oif = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_ADD_MEMBERSHIP:\n\tcase IPV6_DROP_MEMBERSHIP:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EPROTO;\n\t\tif (inet_test_bit(IS_ICSK, sk))\n\t\t\tbreak;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_sockptr(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_ADD_MEMBERSHIP)\n\t\t\tretv = ipv6_sock_mc_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_mc_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_multiaddr);\n\t\tbreak;\n\t}\n\tcase IPV6_JOIN_ANYCAST:\n\tcase IPV6_LEAVE_ANYCAST:\n\t{\n\t\tstruct ipv6_mreq mreq;\n\n\t\tif (optlen < sizeof(struct ipv6_mreq))\n\t\t\tgoto e_inval;\n\n\t\tretv = -EFAULT;\n\t\tif (copy_from_sockptr(&mreq, optval, sizeof(struct ipv6_mreq)))\n\t\t\tbreak;\n\n\t\tif (optname == IPV6_JOIN_ANYCAST)\n\t\t\tretv = ipv6_sock_ac_join(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\telse\n\t\t\tretv = ipv6_sock_ac_drop(sk, mreq.ipv6mr_ifindex, &mreq.ipv6mr_acaddr);\n\t\tbreak;\n\t}\n\tcase IPV6_MULTICAST_ALL:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->mc_all = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\n\tcase MCAST_JOIN_GROUP:\n\tcase MCAST_LEAVE_GROUP:\n\t\tif (in_compat_syscall())\n\t\t\tretv = compat_ipv6_mcast_join_leave(sk, optname, optval,\n\t\t\t\t\t\t\t    optlen);\n\t\telse\n\t\t\tretv = ipv6_mcast_join_leave(sk, optname, optval,\n\t\t\t\t\t\t     optlen);\n\t\tbreak;\n\tcase MCAST_JOIN_SOURCE_GROUP:\n\tcase MCAST_LEAVE_SOURCE_GROUP:\n\tcase MCAST_BLOCK_SOURCE:\n\tcase MCAST_UNBLOCK_SOURCE:\n\t\tretv = do_ipv6_mcast_group_source(sk, optname, optval, optlen);\n\t\tbreak;\n\tcase MCAST_MSFILTER:\n\t\tif (in_compat_syscall())\n\t\t\tretv = compat_ipv6_set_mcast_msfilter(sk, optval,\n\t\t\t\t\t\t\t      optlen);\n\t\telse\n\t\t\tretv = ipv6_set_mcast_msfilter(sk, optval, optlen);\n\t\tbreak;\n\tcase IPV6_ROUTER_ALERT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tretv = ip6_ra_control(sk, val);\n\t\tbreak;\n\tcase IPV6_ROUTER_ALERT_ISOLATE:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->rtalert_isolate = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_MTU_DISCOVER:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT)\n\t\t\tgoto e_inval;\n\t\tnp->pmtudisc = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_MTU:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val && val < IPV6_MIN_MTU)\n\t\t\tgoto e_inval;\n\t\tnp->frag_size = val;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVERR:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->recverr = valbool;\n\t\tif (!val)\n\t\t\tskb_errqueue_purge(&sk->sk_error_queue);\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWINFO_SEND:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tnp->sndflow = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_FLOWLABEL_MGR:\n\t\tretv = ipv6_flowlabel_opt(sk, optval, optlen);\n\t\tbreak;\n\tcase IPV6_IPSEC_POLICY:\n\tcase IPV6_XFRM_POLICY:\n\t\tretv = -EPERM;\n\t\tif (!sockopt_ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\tretv = xfrm_user_policy(sk, optname, optval, optlen);\n\t\tbreak;\n\n\tcase IPV6_ADDR_PREFERENCES:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tretv = __ip6_sock_set_addr_preferences(sk, val);\n\t\tbreak;\n\tcase IPV6_MINHOPCOUNT:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 255)\n\t\t\tgoto e_inval;\n\n\t\tif (val)\n\t\t\tstatic_branch_enable(&ip6_min_hopcount);\n\n\t\t \n\t\tWRITE_ONCE(np->min_hopcount, val);\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_DONTFRAG:\n\t\tnp->dontfrag = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_AUTOFLOWLABEL:\n\t\tnp->autoflowlabel = valbool;\n\t\tnp->autoflowlabel_set = 1;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVFRAGSIZE:\n\t\tnp->rxopt.bits.recvfragsize = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\tcase IPV6_RECVERR_RFC4884:\n\t\tif (optlen < sizeof(int))\n\t\t\tgoto e_inval;\n\t\tif (val < 0 || val > 1)\n\t\t\tgoto e_inval;\n\t\tnp->recverr_rfc4884 = valbool;\n\t\tretv = 0;\n\t\tbreak;\n\t}\n\nunlock:\n\tsockopt_release_sock(sk);\n\tif (needs_rtnl)\n\t\trtnl_unlock();\n\n\treturn retv;\n\ne_inval:\n\tretv = -EINVAL;\n\tgoto unlock;\n}\n\nint ipv6_setsockopt(struct sock *sk, int level, int optname, sockptr_t optval,\n\t\t    unsigned int optlen)\n{\n\tint err;\n\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW)\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\n\terr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\t \n\tif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&\n\t\t\toptname != IPV6_XFRM_POLICY)\n\t\terr = nf_setsockopt(sk, PF_INET6, optname, optval, optlen);\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(ipv6_setsockopt);\n\nstatic int ipv6_getsockopt_sticky(struct sock *sk, struct ipv6_txoptions *opt,\n\t\t\t\t  int optname, sockptr_t optval, int len)\n{\n\tstruct ipv6_opt_hdr *hdr;\n\n\tif (!opt)\n\t\treturn 0;\n\n\tswitch (optname) {\n\tcase IPV6_HOPOPTS:\n\t\thdr = opt->hopopt;\n\t\tbreak;\n\tcase IPV6_RTHDRDSTOPTS:\n\t\thdr = opt->dst0opt;\n\t\tbreak;\n\tcase IPV6_RTHDR:\n\t\thdr = (struct ipv6_opt_hdr *)opt->srcrt;\n\t\tbreak;\n\tcase IPV6_DSTOPTS:\n\t\thdr = opt->dst1opt;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\t \n\t}\n\n\tif (!hdr)\n\t\treturn 0;\n\n\tlen = min_t(unsigned int, len, ipv6_optlen(hdr));\n\tif (copy_to_sockptr(optval, hdr, len))\n\t\treturn -EFAULT;\n\treturn len;\n}\n\nstatic int ipv6_get_msfilter(struct sock *sk, sockptr_t optval,\n\t\t\t     sockptr_t optlen, int len)\n{\n\tconst int size0 = offsetof(struct group_filter, gf_slist_flex);\n\tstruct group_filter gsf;\n\tint num;\n\tint err;\n\n\tif (len < size0)\n\t\treturn -EINVAL;\n\tif (copy_from_sockptr(&gsf, optval, size0))\n\t\treturn -EFAULT;\n\tif (gsf.gf_group.ss_family != AF_INET6)\n\t\treturn -EADDRNOTAVAIL;\n\tnum = gsf.gf_numsrc;\n\tsockopt_lock_sock(sk);\n\terr = ip6_mc_msfget(sk, &gsf, optval, size0);\n\tif (!err) {\n\t\tif (num > gsf.gf_numsrc)\n\t\t\tnum = gsf.gf_numsrc;\n\t\tlen = GROUP_FILTER_SIZE(num);\n\t\tif (copy_to_sockptr(optlen, &len, sizeof(int)) ||\n\t\t    copy_to_sockptr(optval, &gsf, size0))\n\t\t\terr = -EFAULT;\n\t}\n\tsockopt_release_sock(sk);\n\treturn err;\n}\n\nstatic int compat_ipv6_get_msfilter(struct sock *sk, sockptr_t optval,\n\t\t\t\t    sockptr_t optlen, int len)\n{\n\tconst int size0 = offsetof(struct compat_group_filter, gf_slist_flex);\n\tstruct compat_group_filter gf32;\n\tstruct group_filter gf;\n\tint err;\n\tint num;\n\n\tif (len < size0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&gf32, optval, size0))\n\t\treturn -EFAULT;\n\tgf.gf_interface = gf32.gf_interface;\n\tgf.gf_fmode = gf32.gf_fmode;\n\tnum = gf.gf_numsrc = gf32.gf_numsrc;\n\tgf.gf_group = gf32.gf_group;\n\n\tif (gf.gf_group.ss_family != AF_INET6)\n\t\treturn -EADDRNOTAVAIL;\n\n\tsockopt_lock_sock(sk);\n\terr = ip6_mc_msfget(sk, &gf, optval, size0);\n\tsockopt_release_sock(sk);\n\tif (err)\n\t\treturn err;\n\tif (num > gf.gf_numsrc)\n\t\tnum = gf.gf_numsrc;\n\tlen = GROUP_FILTER_SIZE(num) - (sizeof(gf)-sizeof(gf32));\n\tif (copy_to_sockptr(optlen, &len, sizeof(int)) ||\n\t    copy_to_sockptr_offset(optval, offsetof(struct compat_group_filter, gf_fmode),\n\t\t\t\t   &gf.gf_fmode, sizeof(gf32.gf_fmode)) ||\n\t    copy_to_sockptr_offset(optval, offsetof(struct compat_group_filter, gf_numsrc),\n\t\t\t\t   &gf.gf_numsrc, sizeof(gf32.gf_numsrc)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint do_ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t       sockptr_t optval, sockptr_t optlen)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tint len;\n\tint val;\n\n\tif (ip6_mroute_opt(optname))\n\t\treturn ip6_mroute_getsockopt(sk, optname, optval, optlen);\n\n\tif (copy_from_sockptr(&len, optlen, sizeof(int)))\n\t\treturn -EFAULT;\n\tswitch (optname) {\n\tcase IPV6_ADDRFORM:\n\t\tif (sk->sk_protocol != IPPROTO_UDP &&\n\t\t    sk->sk_protocol != IPPROTO_UDPLITE &&\n\t\t    sk->sk_protocol != IPPROTO_TCP)\n\t\t\treturn -ENOPROTOOPT;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tval = sk->sk_family;\n\t\tbreak;\n\tcase MCAST_MSFILTER:\n\t\tif (in_compat_syscall())\n\t\t\treturn compat_ipv6_get_msfilter(sk, optval, optlen, len);\n\t\treturn ipv6_get_msfilter(sk, optval, optlen, len);\n\tcase IPV6_2292PKTOPTIONS:\n\t{\n\t\tstruct msghdr msg;\n\t\tstruct sk_buff *skb;\n\n\t\tif (sk->sk_type != SOCK_STREAM)\n\t\t\treturn -ENOPROTOOPT;\n\n\t\tif (optval.is_kernel) {\n\t\t\tmsg.msg_control_is_user = false;\n\t\t\tmsg.msg_control = optval.kernel;\n\t\t} else {\n\t\t\tmsg.msg_control_is_user = true;\n\t\t\tmsg.msg_control_user = optval.user;\n\t\t}\n\t\tmsg.msg_controllen = len;\n\t\tmsg.msg_flags = 0;\n\n\t\tsockopt_lock_sock(sk);\n\t\tskb = np->pktoptions;\n\t\tif (skb)\n\t\t\tip6_datagram_recv_ctl(sk, &msg, skb);\n\t\tsockopt_release_sock(sk);\n\t\tif (!skb) {\n\t\t\tif (np->rxopt.bits.rxinfo) {\n\t\t\t\tstruct in6_pktinfo src_info;\n\t\t\t\tsrc_info.ipi6_ifindex = np->mcast_oif ? np->mcast_oif :\n\t\t\t\t\tnp->sticky_pktinfo.ipi6_ifindex;\n\t\t\t\tsrc_info.ipi6_addr = np->mcast_oif ? sk->sk_v6_daddr : np->sticky_pktinfo.ipi6_addr;\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_PKTINFO, sizeof(src_info), &src_info);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxhlim) {\n\t\t\t\tint hlim = np->mcast_hops;\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_HOPLIMIT, sizeof(hlim), &hlim);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxtclass) {\n\t\t\t\tint tclass = (int)ip6_tclass(np->rcv_flowinfo);\n\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_TCLASS, sizeof(tclass), &tclass);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxoinfo) {\n\t\t\t\tstruct in6_pktinfo src_info;\n\t\t\t\tsrc_info.ipi6_ifindex = np->mcast_oif ? np->mcast_oif :\n\t\t\t\t\tnp->sticky_pktinfo.ipi6_ifindex;\n\t\t\t\tsrc_info.ipi6_addr = np->mcast_oif ? sk->sk_v6_daddr :\n\t\t\t\t\t\t\t\t     np->sticky_pktinfo.ipi6_addr;\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_2292PKTINFO, sizeof(src_info), &src_info);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxohlim) {\n\t\t\t\tint hlim = np->mcast_hops;\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_2292HOPLIMIT, sizeof(hlim), &hlim);\n\t\t\t}\n\t\t\tif (np->rxopt.bits.rxflow) {\n\t\t\t\t__be32 flowinfo = np->rcv_flowinfo;\n\n\t\t\t\tput_cmsg(&msg, SOL_IPV6, IPV6_FLOWINFO, sizeof(flowinfo), &flowinfo);\n\t\t\t}\n\t\t}\n\t\tlen -= msg.msg_controllen;\n\t\treturn copy_to_sockptr(optlen, &len, sizeof(int));\n\t}\n\tcase IPV6_MTU:\n\t{\n\t\tstruct dst_entry *dst;\n\n\t\tval = 0;\n\t\trcu_read_lock();\n\t\tdst = __sk_dst_get(sk);\n\t\tif (dst)\n\t\t\tval = dst_mtu(dst);\n\t\trcu_read_unlock();\n\t\tif (!val)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\t}\n\n\tcase IPV6_V6ONLY:\n\t\tval = sk->sk_ipv6only;\n\t\tbreak;\n\n\tcase IPV6_RECVPKTINFO:\n\t\tval = np->rxopt.bits.rxinfo;\n\t\tbreak;\n\n\tcase IPV6_2292PKTINFO:\n\t\tval = np->rxopt.bits.rxoinfo;\n\t\tbreak;\n\n\tcase IPV6_RECVHOPLIMIT:\n\t\tval = np->rxopt.bits.rxhlim;\n\t\tbreak;\n\n\tcase IPV6_2292HOPLIMIT:\n\t\tval = np->rxopt.bits.rxohlim;\n\t\tbreak;\n\n\tcase IPV6_RECVRTHDR:\n\t\tval = np->rxopt.bits.srcrt;\n\t\tbreak;\n\n\tcase IPV6_2292RTHDR:\n\t\tval = np->rxopt.bits.osrcrt;\n\t\tbreak;\n\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t{\n\t\tstruct ipv6_txoptions *opt;\n\n\t\tsockopt_lock_sock(sk);\n\t\topt = rcu_dereference_protected(np->opt,\n\t\t\t\t\t\tlockdep_sock_is_held(sk));\n\t\tlen = ipv6_getsockopt_sticky(sk, opt, optname, optval, len);\n\t\tsockopt_release_sock(sk);\n\t\t \n\t\tif (len < 0)\n\t\t\treturn len;\n\t\treturn copy_to_sockptr(optlen, &len, sizeof(int));\n\t}\n\n\tcase IPV6_RECVHOPOPTS:\n\t\tval = np->rxopt.bits.hopopts;\n\t\tbreak;\n\n\tcase IPV6_2292HOPOPTS:\n\t\tval = np->rxopt.bits.ohopopts;\n\t\tbreak;\n\n\tcase IPV6_RECVDSTOPTS:\n\t\tval = np->rxopt.bits.dstopts;\n\t\tbreak;\n\n\tcase IPV6_2292DSTOPTS:\n\t\tval = np->rxopt.bits.odstopts;\n\t\tbreak;\n\n\tcase IPV6_TCLASS:\n\t\tval = np->tclass;\n\t\tbreak;\n\n\tcase IPV6_RECVTCLASS:\n\t\tval = np->rxopt.bits.rxtclass;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO:\n\t\tval = np->rxopt.bits.rxflow;\n\t\tbreak;\n\n\tcase IPV6_RECVPATHMTU:\n\t\tval = np->rxopt.bits.rxpmtu;\n\t\tbreak;\n\n\tcase IPV6_PATHMTU:\n\t{\n\t\tstruct dst_entry *dst;\n\t\tstruct ip6_mtuinfo mtuinfo;\n\n\t\tif (len < sizeof(mtuinfo))\n\t\t\treturn -EINVAL;\n\n\t\tlen = sizeof(mtuinfo);\n\t\tmemset(&mtuinfo, 0, sizeof(mtuinfo));\n\n\t\trcu_read_lock();\n\t\tdst = __sk_dst_get(sk);\n\t\tif (dst)\n\t\t\tmtuinfo.ip6m_mtu = dst_mtu(dst);\n\t\trcu_read_unlock();\n\t\tif (!mtuinfo.ip6m_mtu)\n\t\t\treturn -ENOTCONN;\n\n\t\tif (copy_to_sockptr(optlen, &len, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_sockptr(optval, &mtuinfo, len))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase IPV6_TRANSPARENT:\n\t\tval = inet_test_bit(TRANSPARENT, sk);\n\t\tbreak;\n\n\tcase IPV6_FREEBIND:\n\t\tval = inet_test_bit(FREEBIND, sk);\n\t\tbreak;\n\n\tcase IPV6_RECVORIGDSTADDR:\n\t\tval = np->rxopt.bits.rxorigdstaddr;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_HOPS:\n\tcase IPV6_MULTICAST_HOPS:\n\t{\n\t\tstruct dst_entry *dst;\n\n\t\tif (optname == IPV6_UNICAST_HOPS)\n\t\t\tval = np->hop_limit;\n\t\telse\n\t\t\tval = np->mcast_hops;\n\n\t\tif (val < 0) {\n\t\t\trcu_read_lock();\n\t\t\tdst = __sk_dst_get(sk);\n\t\t\tif (dst)\n\t\t\t\tval = ip6_dst_hoplimit(dst);\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\tif (val < 0)\n\t\t\tval = sock_net(sk)->ipv6.devconf_all->hop_limit;\n\t\tbreak;\n\t}\n\n\tcase IPV6_MULTICAST_LOOP:\n\t\tval = np->mc_loop;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_IF:\n\t\tval = np->mcast_oif;\n\t\tbreak;\n\n\tcase IPV6_MULTICAST_ALL:\n\t\tval = np->mc_all;\n\t\tbreak;\n\n\tcase IPV6_UNICAST_IF:\n\t\tval = (__force int)htonl((__u32) np->ucast_oif);\n\t\tbreak;\n\n\tcase IPV6_MTU_DISCOVER:\n\t\tval = np->pmtudisc;\n\t\tbreak;\n\n\tcase IPV6_RECVERR:\n\t\tval = np->recverr;\n\t\tbreak;\n\n\tcase IPV6_FLOWINFO_SEND:\n\t\tval = np->sndflow;\n\t\tbreak;\n\n\tcase IPV6_FLOWLABEL_MGR:\n\t{\n\t\tstruct in6_flowlabel_req freq;\n\t\tint flags;\n\n\t\tif (len < sizeof(freq))\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_sockptr(&freq, optval, sizeof(freq)))\n\t\t\treturn -EFAULT;\n\n\t\tif (freq.flr_action != IPV6_FL_A_GET)\n\t\t\treturn -EINVAL;\n\n\t\tlen = sizeof(freq);\n\t\tflags = freq.flr_flags;\n\n\t\tmemset(&freq, 0, sizeof(freq));\n\n\t\tval = ipv6_flowlabel_opt_get(sk, &freq, flags);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tif (copy_to_sockptr(optlen, &len, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_sockptr(optval, &freq, len))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tcase IPV6_ADDR_PREFERENCES:\n\t\tval = 0;\n\n\t\tif (np->srcprefs & IPV6_PREFER_SRC_TMP)\n\t\t\tval |= IPV6_PREFER_SRC_TMP;\n\t\telse if (np->srcprefs & IPV6_PREFER_SRC_PUBLIC)\n\t\t\tval |= IPV6_PREFER_SRC_PUBLIC;\n\t\telse {\n\t\t\t \n\t\t\tval |= IPV6_PREFER_SRC_PUBTMP_DEFAULT;\n\t\t}\n\n\t\tif (np->srcprefs & IPV6_PREFER_SRC_COA)\n\t\t\tval |= IPV6_PREFER_SRC_COA;\n\t\telse\n\t\t\tval |= IPV6_PREFER_SRC_HOME;\n\t\tbreak;\n\n\tcase IPV6_MINHOPCOUNT:\n\t\tval = np->min_hopcount;\n\t\tbreak;\n\n\tcase IPV6_DONTFRAG:\n\t\tval = np->dontfrag;\n\t\tbreak;\n\n\tcase IPV6_AUTOFLOWLABEL:\n\t\tval = ip6_autoflowlabel(sock_net(sk), np);\n\t\tbreak;\n\n\tcase IPV6_RECVFRAGSIZE:\n\t\tval = np->rxopt.bits.recvfragsize;\n\t\tbreak;\n\n\tcase IPV6_ROUTER_ALERT_ISOLATE:\n\t\tval = np->rtalert_isolate;\n\t\tbreak;\n\n\tcase IPV6_RECVERR_RFC4884:\n\t\tval = np->recverr_rfc4884;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tlen = min_t(unsigned int, sizeof(int), len);\n\tif (copy_to_sockptr(optlen, &len, sizeof(int)))\n\t\treturn -EFAULT;\n\tif (copy_to_sockptr(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint ipv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t    char __user *optval, int __user *optlen)\n{\n\tint err;\n\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\n\terr = do_ipv6_getsockopt(sk, level, optname,\n\t\t\t\t USER_SOCKPTR(optval), USER_SOCKPTR(optlen));\n#ifdef CONFIG_NETFILTER\n\t \n\tif (err == -ENOPROTOOPT && optname != IPV6_2292PKTOPTIONS) {\n\t\tint len;\n\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\n\t\terr = nf_getsockopt(sk, PF_INET6, optname, optval, &len);\n\t\tif (err >= 0)\n\t\t\terr = put_user(len, optlen);\n\t}\n#endif\n\treturn err;\n}\nEXPORT_SYMBOL(ipv6_getsockopt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}