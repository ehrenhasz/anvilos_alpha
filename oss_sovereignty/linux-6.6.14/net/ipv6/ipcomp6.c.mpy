{
  "module_name": "ipcomp6.c",
  "hash_id": "b9d7e4372229997e7d8201624e0d8e747b7ec46eb8794571f4ca1f32bae26d8b",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ipcomp6.c",
  "human_readable_source": "\n \n \n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/module.h>\n#include <net/ip.h>\n#include <net/xfrm.h>\n#include <net/ipcomp.h>\n#include <linux/crypto.h>\n#include <linux/err.h>\n#include <linux/pfkeyv2.h>\n#include <linux/random.h>\n#include <linux/percpu.h>\n#include <linux/smp.h>\n#include <linux/list.h>\n#include <linux/vmalloc.h>\n#include <linux/rtnetlink.h>\n#include <net/ip6_route.h>\n#include <net/icmp.h>\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/mutex.h>\n\nstatic int ipcomp6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tstruct net *net = dev_net(skb->dev);\n\t__be32 spi;\n\tconst struct ipv6hdr *iph = (const struct ipv6hdr *)skb->data;\n\tstruct ip_comp_hdr *ipcomph =\n\t\t(struct ip_comp_hdr *)(skb->data + offset);\n\tstruct xfrm_state *x;\n\n\tif (type != ICMPV6_PKT_TOOBIG &&\n\t    type != NDISC_REDIRECT)\n\t\treturn 0;\n\n\tspi = htonl(ntohs(ipcomph->cpi));\n\tx = xfrm_state_lookup(net, skb->mark, (const xfrm_address_t *)&iph->daddr,\n\t\t\t      spi, IPPROTO_COMP, AF_INET6);\n\tif (!x)\n\t\treturn 0;\n\n\tif (type == NDISC_REDIRECT)\n\t\tip6_redirect(skb, net, skb->dev->ifindex, 0,\n\t\t\t     sock_net_uid(net, NULL));\n\telse\n\t\tip6_update_pmtu(skb, net, info, 0, 0, sock_net_uid(net, NULL));\n\txfrm_state_put(x);\n\n\treturn 0;\n}\n\nstatic struct xfrm_state *ipcomp6_tunnel_create(struct xfrm_state *x)\n{\n\tstruct net *net = xs_net(x);\n\tstruct xfrm_state *t = NULL;\n\n\tt = xfrm_state_alloc(net);\n\tif (!t)\n\t\tgoto out;\n\n\tt->id.proto = IPPROTO_IPV6;\n\tt->id.spi = xfrm6_tunnel_alloc_spi(net, (xfrm_address_t *)&x->props.saddr);\n\tif (!t->id.spi)\n\t\tgoto error;\n\n\tmemcpy(t->id.daddr.a6, x->id.daddr.a6, sizeof(struct in6_addr));\n\tmemcpy(&t->sel, &x->sel, sizeof(t->sel));\n\tt->props.family = AF_INET6;\n\tt->props.mode = x->props.mode;\n\tmemcpy(t->props.saddr.a6, x->props.saddr.a6, sizeof(struct in6_addr));\n\tmemcpy(&t->mark, &x->mark, sizeof(t->mark));\n\tt->if_id = x->if_id;\n\n\tif (xfrm_init_state(t))\n\t\tgoto error;\n\n\tatomic_set(&t->tunnel_users, 1);\n\nout:\n\treturn t;\n\nerror:\n\tt->km.state = XFRM_STATE_DEAD;\n\txfrm_state_put(t);\n\tt = NULL;\n\tgoto out;\n}\n\nstatic int ipcomp6_tunnel_attach(struct xfrm_state *x)\n{\n\tstruct net *net = xs_net(x);\n\tint err = 0;\n\tstruct xfrm_state *t = NULL;\n\t__be32 spi;\n\tu32 mark = x->mark.m & x->mark.v;\n\n\tspi = xfrm6_tunnel_spi_lookup(net, (xfrm_address_t *)&x->props.saddr);\n\tif (spi)\n\t\tt = xfrm_state_lookup(net, mark, (xfrm_address_t *)&x->id.daddr,\n\t\t\t\t\t      spi, IPPROTO_IPV6, AF_INET6);\n\tif (!t) {\n\t\tt = ipcomp6_tunnel_create(x);\n\t\tif (!t) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\txfrm_state_insert(t);\n\t\txfrm_state_hold(t);\n\t}\n\tx->tunnel = t;\n\tatomic_inc(&t->tunnel_users);\n\nout:\n\treturn err;\n}\n\nstatic int ipcomp6_init_state(struct xfrm_state *x,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tint err = -EINVAL;\n\n\tx->props.header_len = 0;\n\tswitch (x->props.mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\t\tbreak;\n\tcase XFRM_MODE_TUNNEL:\n\t\tx->props.header_len += sizeof(struct ipv6hdr);\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG(extack, \"Unsupported XFRM mode for IPcomp\");\n\t\tgoto out;\n\t}\n\n\terr = ipcomp_init_state(x, extack);\n\tif (err)\n\t\tgoto out;\n\n\tif (x->props.mode == XFRM_MODE_TUNNEL) {\n\t\terr = ipcomp6_tunnel_attach(x);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Kernel error: failed to initialize the associated state\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = 0;\nout:\n\treturn err;\n}\n\nstatic int ipcomp6_rcv_cb(struct sk_buff *skb, int err)\n{\n\treturn 0;\n}\n\nstatic const struct xfrm_type ipcomp6_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.proto\t\t= IPPROTO_COMP,\n\t.init_state\t= ipcomp6_init_state,\n\t.destructor\t= ipcomp_destroy,\n\t.input\t\t= ipcomp_input,\n\t.output\t\t= ipcomp_output,\n};\n\nstatic struct xfrm6_protocol ipcomp6_protocol = {\n\t.handler\t= xfrm6_rcv,\n\t.input_handler\t= xfrm_input,\n\t.cb_handler\t= ipcomp6_rcv_cb,\n\t.err_handler\t= ipcomp6_err,\n\t.priority\t= 0,\n};\n\nstatic int __init ipcomp6_init(void)\n{\n\tif (xfrm_register_type(&ipcomp6_type, AF_INET6) < 0) {\n\t\tpr_info(\"%s: can't add xfrm type\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\tif (xfrm6_protocol_register(&ipcomp6_protocol, IPPROTO_COMP) < 0) {\n\t\tpr_info(\"%s: can't add protocol\\n\", __func__);\n\t\txfrm_unregister_type(&ipcomp6_type, AF_INET6);\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n\nstatic void __exit ipcomp6_fini(void)\n{\n\tif (xfrm6_protocol_deregister(&ipcomp6_protocol, IPPROTO_COMP) < 0)\n\t\tpr_info(\"%s: can't remove protocol\\n\", __func__);\n\txfrm_unregister_type(&ipcomp6_type, AF_INET6);\n}\n\nmodule_init(ipcomp6_init);\nmodule_exit(ipcomp6_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"IP Payload Compression Protocol (IPComp) for IPv6 - RFC3173\");\nMODULE_AUTHOR(\"Mitsuru KANDA <mk@linux-ipv6.org>\");\n\nMODULE_ALIAS_XFRM_TYPE(AF_INET6, XFRM_PROTO_COMP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}