{
  "module_name": "anycast.c",
  "hash_id": "2bbe2394eb46e65f3225c45cf0cdd43bbccd127be2a8aa681a9487544b777a68",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/anycast.c",
  "human_readable_source": "\n \n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/route.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/if_inet6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n\n#include <net/checksum.h>\n\n#define IN6_ADDR_HSIZE_SHIFT\t8\n#define IN6_ADDR_HSIZE\t\tBIT(IN6_ADDR_HSIZE_SHIFT)\n \nstatic struct hlist_head inet6_acaddr_lst[IN6_ADDR_HSIZE];\nstatic DEFINE_SPINLOCK(acaddr_hash_lock);\n\nstatic int ipv6_dev_ac_dec(struct net_device *dev, const struct in6_addr *addr);\n\nstatic u32 inet6_acaddr_hash(struct net *net, const struct in6_addr *addr)\n{\n\tu32 val = ipv6_addr_hash(addr) ^ net_hash_mix(net);\n\n\treturn hash_32(val, IN6_ADDR_HSIZE_SHIFT);\n}\n\n \n\nint ipv6_sock_ac_join(struct sock *sk, int ifindex, const struct in6_addr *addr)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net_device *dev = NULL;\n\tstruct inet6_dev *idev;\n\tstruct ipv6_ac_socklist *pac;\n\tstruct net *net = sock_net(sk);\n\tint\tishost = !net->ipv6.devconf_all->forwarding;\n\tint\terr = 0;\n\n\tASSERT_RTNL();\n\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (ipv6_addr_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\tif (ifindex)\n\t\tdev = __dev_get_by_index(net, ifindex);\n\n\tif (ipv6_chk_addr_and_flags(net, addr, dev, true, 0, IFA_F_TENTATIVE))\n\t\treturn -EINVAL;\n\n\tpac = sock_kmalloc(sk, sizeof(struct ipv6_ac_socklist), GFP_KERNEL);\n\tif (!pac)\n\t\treturn -ENOMEM;\n\tpac->acl_next = NULL;\n\tpac->acl_addr = *addr;\n\n\tif (ifindex == 0) {\n\t\tstruct rt6_info *rt;\n\n\t\trt = rt6_lookup(net, addr, NULL, 0, NULL, 0);\n\t\tif (rt) {\n\t\t\tdev = rt->dst.dev;\n\t\t\tip6_rt_put(rt);\n\t\t} else if (ishost) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tgoto error;\n\t\t} else {\n\t\t\t \n\t\t\tdev = __dev_get_by_flags(net, IFF_UP,\n\t\t\t\t\t\t IFF_UP | IFF_LOOPBACK);\n\t\t}\n\t}\n\n\tif (!dev) {\n\t\terr = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tidev = __in6_dev_get(dev);\n\tif (!idev) {\n\t\tif (ifindex)\n\t\t\terr = -ENODEV;\n\t\telse\n\t\t\terr = -EADDRNOTAVAIL;\n\t\tgoto error;\n\t}\n\t \n\tishost = !idev->cnf.forwarding;\n\n\tpac->acl_ifindex = dev->ifindex;\n\n\t \n\tif (!ipv6_chk_prefix(addr, dev)) {\n\t\tif (ishost)\n\t\t\terr = -EADDRNOTAVAIL;\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\terr = __ipv6_dev_ac_inc(idev, addr);\n\tif (!err) {\n\t\tpac->acl_next = np->ipv6_ac_list;\n\t\tnp->ipv6_ac_list = pac;\n\t\tpac = NULL;\n\t}\n\nerror:\n\tif (pac)\n\t\tsock_kfree_s(sk, pac, sizeof(*pac));\n\treturn err;\n}\n\n \nint ipv6_sock_ac_drop(struct sock *sk, int ifindex, const struct in6_addr *addr)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net_device *dev;\n\tstruct ipv6_ac_socklist *pac, *prev_pac;\n\tstruct net *net = sock_net(sk);\n\n\tASSERT_RTNL();\n\n\tprev_pac = NULL;\n\tfor (pac = np->ipv6_ac_list; pac; pac = pac->acl_next) {\n\t\tif ((ifindex == 0 || pac->acl_ifindex == ifindex) &&\n\t\t     ipv6_addr_equal(&pac->acl_addr, addr))\n\t\t\tbreak;\n\t\tprev_pac = pac;\n\t}\n\tif (!pac)\n\t\treturn -ENOENT;\n\tif (prev_pac)\n\t\tprev_pac->acl_next = pac->acl_next;\n\telse\n\t\tnp->ipv6_ac_list = pac->acl_next;\n\n\tdev = __dev_get_by_index(net, pac->acl_ifindex);\n\tif (dev)\n\t\tipv6_dev_ac_dec(dev, &pac->acl_addr);\n\n\tsock_kfree_s(sk, pac, sizeof(*pac));\n\treturn 0;\n}\n\nvoid __ipv6_sock_ac_close(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net_device *dev = NULL;\n\tstruct ipv6_ac_socklist *pac;\n\tstruct net *net = sock_net(sk);\n\tint\tprev_index;\n\n\tASSERT_RTNL();\n\tpac = np->ipv6_ac_list;\n\tnp->ipv6_ac_list = NULL;\n\n\tprev_index = 0;\n\twhile (pac) {\n\t\tstruct ipv6_ac_socklist *next = pac->acl_next;\n\n\t\tif (pac->acl_ifindex != prev_index) {\n\t\t\tdev = __dev_get_by_index(net, pac->acl_ifindex);\n\t\t\tprev_index = pac->acl_ifindex;\n\t\t}\n\t\tif (dev)\n\t\t\tipv6_dev_ac_dec(dev, &pac->acl_addr);\n\t\tsock_kfree_s(sk, pac, sizeof(*pac));\n\t\tpac = next;\n\t}\n}\n\nvoid ipv6_sock_ac_close(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\tif (!np->ipv6_ac_list)\n\t\treturn;\n\trtnl_lock();\n\t__ipv6_sock_ac_close(sk);\n\trtnl_unlock();\n}\n\nstatic void ipv6_add_acaddr_hash(struct net *net, struct ifacaddr6 *aca)\n{\n\tunsigned int hash = inet6_acaddr_hash(net, &aca->aca_addr);\n\n\tspin_lock(&acaddr_hash_lock);\n\thlist_add_head_rcu(&aca->aca_addr_lst, &inet6_acaddr_lst[hash]);\n\tspin_unlock(&acaddr_hash_lock);\n}\n\nstatic void ipv6_del_acaddr_hash(struct ifacaddr6 *aca)\n{\n\tspin_lock(&acaddr_hash_lock);\n\thlist_del_init_rcu(&aca->aca_addr_lst);\n\tspin_unlock(&acaddr_hash_lock);\n}\n\nstatic void aca_get(struct ifacaddr6 *aca)\n{\n\trefcount_inc(&aca->aca_refcnt);\n}\n\nstatic void aca_free_rcu(struct rcu_head *h)\n{\n\tstruct ifacaddr6 *aca = container_of(h, struct ifacaddr6, rcu);\n\n\tfib6_info_release(aca->aca_rt);\n\tkfree(aca);\n}\n\nstatic void aca_put(struct ifacaddr6 *ac)\n{\n\tif (refcount_dec_and_test(&ac->aca_refcnt)) {\n\t\tcall_rcu(&ac->rcu, aca_free_rcu);\n\t}\n}\n\nstatic struct ifacaddr6 *aca_alloc(struct fib6_info *f6i,\n\t\t\t\t   const struct in6_addr *addr)\n{\n\tstruct ifacaddr6 *aca;\n\n\taca = kzalloc(sizeof(*aca), GFP_ATOMIC);\n\tif (!aca)\n\t\treturn NULL;\n\n\taca->aca_addr = *addr;\n\tfib6_info_hold(f6i);\n\taca->aca_rt = f6i;\n\tINIT_HLIST_NODE(&aca->aca_addr_lst);\n\taca->aca_users = 1;\n\t \n\taca->aca_cstamp = aca->aca_tstamp = jiffies;\n\trefcount_set(&aca->aca_refcnt, 1);\n\n\treturn aca;\n}\n\n \nint __ipv6_dev_ac_inc(struct inet6_dev *idev, const struct in6_addr *addr)\n{\n\tstruct ifacaddr6 *aca;\n\tstruct fib6_info *f6i;\n\tstruct net *net;\n\tint err;\n\n\tASSERT_RTNL();\n\n\twrite_lock_bh(&idev->lock);\n\tif (idev->dead) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tfor (aca = idev->ac_list; aca; aca = aca->aca_next) {\n\t\tif (ipv6_addr_equal(&aca->aca_addr, addr)) {\n\t\t\taca->aca_users++;\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnet = dev_net(idev->dev);\n\tf6i = addrconf_f6i_alloc(net, idev, addr, true, GFP_ATOMIC, NULL);\n\tif (IS_ERR(f6i)) {\n\t\terr = PTR_ERR(f6i);\n\t\tgoto out;\n\t}\n\taca = aca_alloc(f6i, addr);\n\tif (!aca) {\n\t\tfib6_info_release(f6i);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\taca->aca_next = idev->ac_list;\n\tidev->ac_list = aca;\n\n\t \n\taca_get(aca);\n\twrite_unlock_bh(&idev->lock);\n\n\tipv6_add_acaddr_hash(net, aca);\n\n\tip6_ins_rt(net, f6i);\n\n\taddrconf_join_solict(idev->dev, &aca->aca_addr);\n\n\taca_put(aca);\n\treturn 0;\nout:\n\twrite_unlock_bh(&idev->lock);\n\treturn err;\n}\n\n \nint __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr)\n{\n\tstruct ifacaddr6 *aca, *prev_aca;\n\n\tASSERT_RTNL();\n\n\twrite_lock_bh(&idev->lock);\n\tprev_aca = NULL;\n\tfor (aca = idev->ac_list; aca; aca = aca->aca_next) {\n\t\tif (ipv6_addr_equal(&aca->aca_addr, addr))\n\t\t\tbreak;\n\t\tprev_aca = aca;\n\t}\n\tif (!aca) {\n\t\twrite_unlock_bh(&idev->lock);\n\t\treturn -ENOENT;\n\t}\n\tif (--aca->aca_users > 0) {\n\t\twrite_unlock_bh(&idev->lock);\n\t\treturn 0;\n\t}\n\tif (prev_aca)\n\t\tprev_aca->aca_next = aca->aca_next;\n\telse\n\t\tidev->ac_list = aca->aca_next;\n\twrite_unlock_bh(&idev->lock);\n\tipv6_del_acaddr_hash(aca);\n\taddrconf_leave_solict(idev, &aca->aca_addr);\n\n\tip6_del_rt(dev_net(idev->dev), aca->aca_rt, false);\n\n\taca_put(aca);\n\treturn 0;\n}\n\n \nstatic int ipv6_dev_ac_dec(struct net_device *dev, const struct in6_addr *addr)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\n\tif (!idev)\n\t\treturn -ENODEV;\n\treturn __ipv6_dev_ac_dec(idev, addr);\n}\n\nvoid ipv6_ac_destroy_dev(struct inet6_dev *idev)\n{\n\tstruct ifacaddr6 *aca;\n\n\twrite_lock_bh(&idev->lock);\n\twhile ((aca = idev->ac_list) != NULL) {\n\t\tidev->ac_list = aca->aca_next;\n\t\twrite_unlock_bh(&idev->lock);\n\n\t\tipv6_del_acaddr_hash(aca);\n\n\t\taddrconf_leave_solict(idev, &aca->aca_addr);\n\n\t\tip6_del_rt(dev_net(idev->dev), aca->aca_rt, false);\n\n\t\taca_put(aca);\n\n\t\twrite_lock_bh(&idev->lock);\n\t}\n\twrite_unlock_bh(&idev->lock);\n}\n\n \nstatic bool ipv6_chk_acast_dev(struct net_device *dev, const struct in6_addr *addr)\n{\n\tstruct inet6_dev *idev;\n\tstruct ifacaddr6 *aca;\n\n\tidev = __in6_dev_get(dev);\n\tif (idev) {\n\t\tread_lock_bh(&idev->lock);\n\t\tfor (aca = idev->ac_list; aca; aca = aca->aca_next)\n\t\t\tif (ipv6_addr_equal(&aca->aca_addr, addr))\n\t\t\t\tbreak;\n\t\tread_unlock_bh(&idev->lock);\n\t\treturn aca != NULL;\n\t}\n\treturn false;\n}\n\n \nbool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,\n\t\t\t const struct in6_addr *addr)\n{\n\tstruct net_device *nh_dev;\n\tstruct ifacaddr6 *aca;\n\tbool found = false;\n\n\trcu_read_lock();\n\tif (dev)\n\t\tfound = ipv6_chk_acast_dev(dev, addr);\n\telse {\n\t\tunsigned int hash = inet6_acaddr_hash(net, addr);\n\n\t\thlist_for_each_entry_rcu(aca, &inet6_acaddr_lst[hash],\n\t\t\t\t\t aca_addr_lst) {\n\t\t\tnh_dev = fib6_info_nh_dev(aca->aca_rt);\n\t\t\tif (!nh_dev || !net_eq(dev_net(nh_dev), net))\n\t\t\t\tcontinue;\n\t\t\tif (ipv6_addr_equal(&aca->aca_addr, addr)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn found;\n}\n\n \nbool ipv6_chk_acast_addr_src(struct net *net, struct net_device *dev,\n\t\t\t     const struct in6_addr *addr)\n{\n\treturn ipv6_chk_acast_addr(net,\n\t\t\t\t   (ipv6_addr_type(addr) & IPV6_ADDR_LINKLOCAL ?\n\t\t\t\t    dev : NULL),\n\t\t\t\t   addr);\n}\n\n#ifdef CONFIG_PROC_FS\nstruct ac6_iter_state {\n\tstruct seq_net_private p;\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n};\n\n#define ac6_seq_private(seq)\t((struct ac6_iter_state *)(seq)->private)\n\nstatic inline struct ifacaddr6 *ac6_get_first(struct seq_file *seq)\n{\n\tstruct ifacaddr6 *im = NULL;\n\tstruct ac6_iter_state *state = ac6_seq_private(seq);\n\tstruct net *net = seq_file_net(seq);\n\n\tstate->idev = NULL;\n\tfor_each_netdev_rcu(net, state->dev) {\n\t\tstruct inet6_dev *idev;\n\t\tidev = __in6_dev_get(state->dev);\n\t\tif (!idev)\n\t\t\tcontinue;\n\t\tread_lock_bh(&idev->lock);\n\t\tim = idev->ac_list;\n\t\tif (im) {\n\t\t\tstate->idev = idev;\n\t\t\tbreak;\n\t\t}\n\t\tread_unlock_bh(&idev->lock);\n\t}\n\treturn im;\n}\n\nstatic struct ifacaddr6 *ac6_get_next(struct seq_file *seq, struct ifacaddr6 *im)\n{\n\tstruct ac6_iter_state *state = ac6_seq_private(seq);\n\n\tim = im->aca_next;\n\twhile (!im) {\n\t\tif (likely(state->idev != NULL))\n\t\t\tread_unlock_bh(&state->idev->lock);\n\n\t\tstate->dev = next_net_device_rcu(state->dev);\n\t\tif (!state->dev) {\n\t\t\tstate->idev = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tstate->idev = __in6_dev_get(state->dev);\n\t\tif (!state->idev)\n\t\t\tcontinue;\n\t\tread_lock_bh(&state->idev->lock);\n\t\tim = state->idev->ac_list;\n\t}\n\treturn im;\n}\n\nstatic struct ifacaddr6 *ac6_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct ifacaddr6 *im = ac6_get_first(seq);\n\tif (im)\n\t\twhile (pos && (im = ac6_get_next(seq, im)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : im;\n}\n\nstatic void *ac6_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\trcu_read_lock();\n\treturn ac6_get_idx(seq, *pos);\n}\n\nstatic void *ac6_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ifacaddr6 *im = ac6_get_next(seq, v);\n\n\t++*pos;\n\treturn im;\n}\n\nstatic void ac6_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\tstruct ac6_iter_state *state = ac6_seq_private(seq);\n\n\tif (likely(state->idev != NULL)) {\n\t\tread_unlock_bh(&state->idev->lock);\n\t\tstate->idev = NULL;\n\t}\n\trcu_read_unlock();\n}\n\nstatic int ac6_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct ifacaddr6 *im = (struct ifacaddr6 *)v;\n\tstruct ac6_iter_state *state = ac6_seq_private(seq);\n\n\tseq_printf(seq, \"%-4d %-15s %pi6 %5d\\n\",\n\t\t   state->dev->ifindex, state->dev->name,\n\t\t   &im->aca_addr, im->aca_users);\n\treturn 0;\n}\n\nstatic const struct seq_operations ac6_seq_ops = {\n\t.start\t=\tac6_seq_start,\n\t.next\t=\tac6_seq_next,\n\t.stop\t=\tac6_seq_stop,\n\t.show\t=\tac6_seq_show,\n};\n\nint __net_init ac6_proc_init(struct net *net)\n{\n\tif (!proc_create_net(\"anycast6\", 0444, net->proc_net, &ac6_seq_ops,\n\t\t\tsizeof(struct ac6_iter_state)))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid ac6_proc_exit(struct net *net)\n{\n\tremove_proc_entry(\"anycast6\", net->proc_net);\n}\n#endif\n\n \nint __init ipv6_anycast_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < IN6_ADDR_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&inet6_acaddr_lst[i]);\n\treturn 0;\n}\n\nvoid ipv6_anycast_cleanup(void)\n{\n\tint i;\n\n\tspin_lock(&acaddr_hash_lock);\n\tfor (i = 0; i < IN6_ADDR_HSIZE; i++)\n\t\tWARN_ON(!hlist_empty(&inet6_acaddr_lst[i]));\n\tspin_unlock(&acaddr_hash_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}