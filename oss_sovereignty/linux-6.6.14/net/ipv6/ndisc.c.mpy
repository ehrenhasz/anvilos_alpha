{
  "module_name": "ndisc.c",
  "hash_id": "b213520a6740c5f15b823aeb0a0ad6ce8156042ab5d4247c682a0515adf18535",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ndisc.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) \"ICMPv6: \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/sched.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/route.h>\n#include <linux/init.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\n#include <linux/if_addr.h>\n#include <linux/if_ether.h>\n#include <linux/if_arp.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/jhash.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/ndisc.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/icmp.h>\n\n#include <net/netlink.h>\n#include <linux/rtnetlink.h>\n\n#include <net/flow.h>\n#include <net/ip6_checksum.h>\n#include <net/inet_common.h>\n#include <linux/proc_fs.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n\nstatic u32 ndisc_hash(const void *pkey,\n\t\t      const struct net_device *dev,\n\t\t      __u32 *hash_rnd);\nstatic bool ndisc_key_eq(const struct neighbour *neigh, const void *pkey);\nstatic bool ndisc_allow_add(const struct net_device *dev,\n\t\t\t    struct netlink_ext_ack *extack);\nstatic int ndisc_constructor(struct neighbour *neigh);\nstatic void ndisc_solicit(struct neighbour *neigh, struct sk_buff *skb);\nstatic void ndisc_error_report(struct neighbour *neigh, struct sk_buff *skb);\nstatic int pndisc_constructor(struct pneigh_entry *n);\nstatic void pndisc_destructor(struct pneigh_entry *n);\nstatic void pndisc_redo(struct sk_buff *skb);\nstatic int ndisc_is_multicast(const void *pkey);\n\nstatic const struct neigh_ops ndisc_generic_ops = {\n\t.family =\t\tAF_INET6,\n\t.solicit =\t\tndisc_solicit,\n\t.error_report =\t\tndisc_error_report,\n\t.output =\t\tneigh_resolve_output,\n\t.connected_output =\tneigh_connected_output,\n};\n\nstatic const struct neigh_ops ndisc_hh_ops = {\n\t.family =\t\tAF_INET6,\n\t.solicit =\t\tndisc_solicit,\n\t.error_report =\t\tndisc_error_report,\n\t.output =\t\tneigh_resolve_output,\n\t.connected_output =\tneigh_resolve_output,\n};\n\n\nstatic const struct neigh_ops ndisc_direct_ops = {\n\t.family =\t\tAF_INET6,\n\t.output =\t\tneigh_direct_output,\n\t.connected_output =\tneigh_direct_output,\n};\n\nstruct neigh_table nd_tbl = {\n\t.family =\tAF_INET6,\n\t.key_len =\tsizeof(struct in6_addr),\n\t.protocol =\tcpu_to_be16(ETH_P_IPV6),\n\t.hash =\t\tndisc_hash,\n\t.key_eq =\tndisc_key_eq,\n\t.constructor =\tndisc_constructor,\n\t.pconstructor =\tpndisc_constructor,\n\t.pdestructor =\tpndisc_destructor,\n\t.proxy_redo =\tpndisc_redo,\n\t.is_multicast =\tndisc_is_multicast,\n\t.allow_add  =   ndisc_allow_add,\n\t.id =\t\t\"ndisc_cache\",\n\t.parms = {\n\t\t.tbl\t\t\t= &nd_tbl,\n\t\t.reachable_time\t\t= ND_REACHABLE_TIME,\n\t\t.data = {\n\t\t\t[NEIGH_VAR_MCAST_PROBES] = 3,\n\t\t\t[NEIGH_VAR_UCAST_PROBES] = 3,\n\t\t\t[NEIGH_VAR_RETRANS_TIME] = ND_RETRANS_TIMER,\n\t\t\t[NEIGH_VAR_BASE_REACHABLE_TIME] = ND_REACHABLE_TIME,\n\t\t\t[NEIGH_VAR_DELAY_PROBE_TIME] = 5 * HZ,\n\t\t\t[NEIGH_VAR_INTERVAL_PROBE_TIME_MS] = 5 * HZ,\n\t\t\t[NEIGH_VAR_GC_STALETIME] = 60 * HZ,\n\t\t\t[NEIGH_VAR_QUEUE_LEN_BYTES] = SK_WMEM_MAX,\n\t\t\t[NEIGH_VAR_PROXY_QLEN] = 64,\n\t\t\t[NEIGH_VAR_ANYCAST_DELAY] = 1 * HZ,\n\t\t\t[NEIGH_VAR_PROXY_DELAY] = (8 * HZ) / 10,\n\t\t},\n\t},\n\t.gc_interval =\t  30 * HZ,\n\t.gc_thresh1 =\t 128,\n\t.gc_thresh2 =\t 512,\n\t.gc_thresh3 =\t1024,\n};\nEXPORT_SYMBOL_GPL(nd_tbl);\n\nvoid __ndisc_fill_addr_option(struct sk_buff *skb, int type, const void *data,\n\t\t\t      int data_len, int pad)\n{\n\tint space = __ndisc_opt_addr_space(data_len, pad);\n\tu8 *opt = skb_put(skb, space);\n\n\topt[0] = type;\n\topt[1] = space>>3;\n\n\tmemset(opt + 2, 0, pad);\n\topt   += pad;\n\tspace -= pad;\n\n\tmemcpy(opt+2, data, data_len);\n\tdata_len += 2;\n\topt += data_len;\n\tspace -= data_len;\n\tif (space > 0)\n\t\tmemset(opt, 0, space);\n}\nEXPORT_SYMBOL_GPL(__ndisc_fill_addr_option);\n\nstatic inline void ndisc_fill_addr_option(struct sk_buff *skb, int type,\n\t\t\t\t\t  const void *data, u8 icmp6_type)\n{\n\t__ndisc_fill_addr_option(skb, type, data, skb->dev->addr_len,\n\t\t\t\t ndisc_addr_option_pad(skb->dev->type));\n\tndisc_ops_fill_addr_option(skb->dev, skb, icmp6_type);\n}\n\nstatic inline void ndisc_fill_redirect_addr_option(struct sk_buff *skb,\n\t\t\t\t\t\t   void *ha,\n\t\t\t\t\t\t   const u8 *ops_data)\n{\n\tndisc_fill_addr_option(skb, ND_OPT_TARGET_LL_ADDR, ha, NDISC_REDIRECT);\n\tndisc_ops_fill_redirect_addr_option(skb->dev, skb, ops_data);\n}\n\nstatic struct nd_opt_hdr *ndisc_next_option(struct nd_opt_hdr *cur,\n\t\t\t\t\t    struct nd_opt_hdr *end)\n{\n\tint type;\n\tif (!cur || !end || cur >= end)\n\t\treturn NULL;\n\ttype = cur->nd_opt_type;\n\tdo {\n\t\tcur = ((void *)cur) + (cur->nd_opt_len << 3);\n\t} while (cur < end && cur->nd_opt_type != type);\n\treturn cur <= end && cur->nd_opt_type == type ? cur : NULL;\n}\n\nstatic inline int ndisc_is_useropt(const struct net_device *dev,\n\t\t\t\t   struct nd_opt_hdr *opt)\n{\n\treturn opt->nd_opt_type == ND_OPT_PREFIX_INFO ||\n\t\topt->nd_opt_type == ND_OPT_RDNSS ||\n\t\topt->nd_opt_type == ND_OPT_DNSSL ||\n\t\topt->nd_opt_type == ND_OPT_CAPTIVE_PORTAL ||\n\t\topt->nd_opt_type == ND_OPT_PREF64 ||\n\t\tndisc_ops_is_useropt(dev, opt->nd_opt_type);\n}\n\nstatic struct nd_opt_hdr *ndisc_next_useropt(const struct net_device *dev,\n\t\t\t\t\t     struct nd_opt_hdr *cur,\n\t\t\t\t\t     struct nd_opt_hdr *end)\n{\n\tif (!cur || !end || cur >= end)\n\t\treturn NULL;\n\tdo {\n\t\tcur = ((void *)cur) + (cur->nd_opt_len << 3);\n\t} while (cur < end && !ndisc_is_useropt(dev, cur));\n\treturn cur <= end && ndisc_is_useropt(dev, cur) ? cur : NULL;\n}\n\nstruct ndisc_options *ndisc_parse_options(const struct net_device *dev,\n\t\t\t\t\t  u8 *opt, int opt_len,\n\t\t\t\t\t  struct ndisc_options *ndopts)\n{\n\tstruct nd_opt_hdr *nd_opt = (struct nd_opt_hdr *)opt;\n\n\tif (!nd_opt || opt_len < 0 || !ndopts)\n\t\treturn NULL;\n\tmemset(ndopts, 0, sizeof(*ndopts));\n\twhile (opt_len) {\n\t\tint l;\n\t\tif (opt_len < sizeof(struct nd_opt_hdr))\n\t\t\treturn NULL;\n\t\tl = nd_opt->nd_opt_len << 3;\n\t\tif (opt_len < l || l == 0)\n\t\t\treturn NULL;\n\t\tif (ndisc_ops_parse_options(dev, nd_opt, ndopts))\n\t\t\tgoto next_opt;\n\t\tswitch (nd_opt->nd_opt_type) {\n\t\tcase ND_OPT_SOURCE_LL_ADDR:\n\t\tcase ND_OPT_TARGET_LL_ADDR:\n\t\tcase ND_OPT_MTU:\n\t\tcase ND_OPT_NONCE:\n\t\tcase ND_OPT_REDIRECT_HDR:\n\t\t\tif (ndopts->nd_opt_array[nd_opt->nd_opt_type]) {\n\t\t\t\tND_PRINTK(2, warn,\n\t\t\t\t\t  \"%s: duplicated ND6 option found: type=%d\\n\",\n\t\t\t\t\t  __func__, nd_opt->nd_opt_type);\n\t\t\t} else {\n\t\t\t\tndopts->nd_opt_array[nd_opt->nd_opt_type] = nd_opt;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ND_OPT_PREFIX_INFO:\n\t\t\tndopts->nd_opts_pi_end = nd_opt;\n\t\t\tif (!ndopts->nd_opt_array[nd_opt->nd_opt_type])\n\t\t\t\tndopts->nd_opt_array[nd_opt->nd_opt_type] = nd_opt;\n\t\t\tbreak;\n#ifdef CONFIG_IPV6_ROUTE_INFO\n\t\tcase ND_OPT_ROUTE_INFO:\n\t\t\tndopts->nd_opts_ri_end = nd_opt;\n\t\t\tif (!ndopts->nd_opts_ri)\n\t\t\t\tndopts->nd_opts_ri = nd_opt;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tif (ndisc_is_useropt(dev, nd_opt)) {\n\t\t\t\tndopts->nd_useropts_end = nd_opt;\n\t\t\t\tif (!ndopts->nd_useropts)\n\t\t\t\t\tndopts->nd_useropts = nd_opt;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tND_PRINTK(2, notice,\n\t\t\t\t\t  \"%s: ignored unsupported option; type=%d, len=%d\\n\",\n\t\t\t\t\t  __func__,\n\t\t\t\t\t  nd_opt->nd_opt_type,\n\t\t\t\t\t  nd_opt->nd_opt_len);\n\t\t\t}\n\t\t}\nnext_opt:\n\t\topt_len -= l;\n\t\tnd_opt = ((void *)nd_opt) + l;\n\t}\n\treturn ndopts;\n}\n\nint ndisc_mc_map(const struct in6_addr *addr, char *buf, struct net_device *dev, int dir)\n{\n\tswitch (dev->type) {\n\tcase ARPHRD_ETHER:\n\tcase ARPHRD_IEEE802:\t \n\tcase ARPHRD_FDDI:\n\t\tipv6_eth_mc_map(addr, buf);\n\t\treturn 0;\n\tcase ARPHRD_ARCNET:\n\t\tipv6_arcnet_mc_map(addr, buf);\n\t\treturn 0;\n\tcase ARPHRD_INFINIBAND:\n\t\tipv6_ib_mc_map(addr, dev->broadcast, buf);\n\t\treturn 0;\n\tcase ARPHRD_IPGRE:\n\t\treturn ipv6_ipgre_mc_map(addr, dev->broadcast, buf);\n\tdefault:\n\t\tif (dir) {\n\t\t\tmemcpy(buf, dev->broadcast, dev->addr_len);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(ndisc_mc_map);\n\nstatic u32 ndisc_hash(const void *pkey,\n\t\t      const struct net_device *dev,\n\t\t      __u32 *hash_rnd)\n{\n\treturn ndisc_hashfn(pkey, dev, hash_rnd);\n}\n\nstatic bool ndisc_key_eq(const struct neighbour *n, const void *pkey)\n{\n\treturn neigh_key_eq128(n, pkey);\n}\n\nstatic int ndisc_constructor(struct neighbour *neigh)\n{\n\tstruct in6_addr *addr = (struct in6_addr *)&neigh->primary_key;\n\tstruct net_device *dev = neigh->dev;\n\tstruct inet6_dev *in6_dev;\n\tstruct neigh_parms *parms;\n\tbool is_multicast = ipv6_addr_is_multicast(addr);\n\n\tin6_dev = in6_dev_get(dev);\n\tif (!in6_dev) {\n\t\treturn -EINVAL;\n\t}\n\n\tparms = in6_dev->nd_parms;\n\t__neigh_parms_put(neigh->parms);\n\tneigh->parms = neigh_parms_clone(parms);\n\n\tneigh->type = is_multicast ? RTN_MULTICAST : RTN_UNICAST;\n\tif (!dev->header_ops) {\n\t\tneigh->nud_state = NUD_NOARP;\n\t\tneigh->ops = &ndisc_direct_ops;\n\t\tneigh->output = neigh_direct_output;\n\t} else {\n\t\tif (is_multicast) {\n\t\t\tneigh->nud_state = NUD_NOARP;\n\t\t\tndisc_mc_map(addr, neigh->ha, dev, 1);\n\t\t} else if (dev->flags&(IFF_NOARP|IFF_LOOPBACK)) {\n\t\t\tneigh->nud_state = NUD_NOARP;\n\t\t\tmemcpy(neigh->ha, dev->dev_addr, dev->addr_len);\n\t\t\tif (dev->flags&IFF_LOOPBACK)\n\t\t\t\tneigh->type = RTN_LOCAL;\n\t\t} else if (dev->flags&IFF_POINTOPOINT) {\n\t\t\tneigh->nud_state = NUD_NOARP;\n\t\t\tmemcpy(neigh->ha, dev->broadcast, dev->addr_len);\n\t\t}\n\t\tif (dev->header_ops->cache)\n\t\t\tneigh->ops = &ndisc_hh_ops;\n\t\telse\n\t\t\tneigh->ops = &ndisc_generic_ops;\n\t\tif (neigh->nud_state&NUD_VALID)\n\t\t\tneigh->output = neigh->ops->connected_output;\n\t\telse\n\t\t\tneigh->output = neigh->ops->output;\n\t}\n\tin6_dev_put(in6_dev);\n\treturn 0;\n}\n\nstatic int pndisc_constructor(struct pneigh_entry *n)\n{\n\tstruct in6_addr *addr = (struct in6_addr *)&n->key;\n\tstruct in6_addr maddr;\n\tstruct net_device *dev = n->dev;\n\n\tif (!dev || !__in6_dev_get(dev))\n\t\treturn -EINVAL;\n\taddrconf_addr_solict_mult(addr, &maddr);\n\tipv6_dev_mc_inc(dev, &maddr);\n\treturn 0;\n}\n\nstatic void pndisc_destructor(struct pneigh_entry *n)\n{\n\tstruct in6_addr *addr = (struct in6_addr *)&n->key;\n\tstruct in6_addr maddr;\n\tstruct net_device *dev = n->dev;\n\n\tif (!dev || !__in6_dev_get(dev))\n\t\treturn;\n\taddrconf_addr_solict_mult(addr, &maddr);\n\tipv6_dev_mc_dec(dev, &maddr);\n}\n\n \nstatic bool ndisc_allow_add(const struct net_device *dev,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\n\tif (!idev || idev->cnf.disable_ipv6) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv6 is disabled on this device\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic struct sk_buff *ndisc_alloc_skb(struct net_device *dev,\n\t\t\t\t       int len)\n{\n\tint hlen = LL_RESERVED_SPACE(dev);\n\tint tlen = dev->needed_tailroom;\n\tstruct sock *sk = dev_net(dev)->ipv6.ndisc_sk;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(hlen + sizeof(struct ipv6hdr) + len + tlen, GFP_ATOMIC);\n\tif (!skb) {\n\t\tND_PRINTK(0, err, \"ndisc: %s failed to allocate an skb\\n\",\n\t\t\t  __func__);\n\t\treturn NULL;\n\t}\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->dev = dev;\n\n\tskb_reserve(skb, hlen + sizeof(struct ipv6hdr));\n\tskb_reset_transport_header(skb);\n\n\t \n\tskb_set_owner_w(skb, sk);\n\n\treturn skb;\n}\n\nstatic void ip6_nd_hdr(struct sk_buff *skb,\n\t\t       const struct in6_addr *saddr,\n\t\t       const struct in6_addr *daddr,\n\t\t       int hop_limit, int len)\n{\n\tstruct ipv6hdr *hdr;\n\tstruct inet6_dev *idev;\n\tunsigned tclass;\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(skb->dev);\n\ttclass = idev ? idev->cnf.ndisc_tclass : 0;\n\trcu_read_unlock();\n\n\tskb_push(skb, sizeof(*hdr));\n\tskb_reset_network_header(skb);\n\thdr = ipv6_hdr(skb);\n\n\tip6_flow_hdr(hdr, tclass, 0);\n\n\thdr->payload_len = htons(len);\n\thdr->nexthdr = IPPROTO_ICMPV6;\n\thdr->hop_limit = hop_limit;\n\n\thdr->saddr = *saddr;\n\thdr->daddr = *daddr;\n}\n\nvoid ndisc_send_skb(struct sk_buff *skb, const struct in6_addr *daddr,\n\t\t    const struct in6_addr *saddr)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk = net->ipv6.ndisc_sk;\n\tstruct inet6_dev *idev;\n\tint err;\n\tstruct icmp6hdr *icmp6h = icmp6_hdr(skb);\n\tu8 type;\n\n\ttype = icmp6h->icmp6_type;\n\n\tif (!dst) {\n\t\tstruct flowi6 fl6;\n\t\tint oif = skb->dev->ifindex;\n\n\t\ticmpv6_flow_init(sk, &fl6, type, saddr, daddr, oif);\n\t\tdst = icmp6_dst_alloc(skb->dev, &fl6);\n\t\tif (IS_ERR(dst)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_dst_set(skb, dst);\n\t}\n\n\ticmp6h->icmp6_cksum = csum_ipv6_magic(saddr, daddr, skb->len,\n\t\t\t\t\t      IPPROTO_ICMPV6,\n\t\t\t\t\t      csum_partial(icmp6h,\n\t\t\t\t\t\t\t   skb->len, 0));\n\n\tip6_nd_hdr(skb, saddr, daddr, inet6_sk(sk)->hop_limit, skb->len);\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(dst->dev);\n\tIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUT, skb->len);\n\n\terr = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT,\n\t\t      net, sk, skb, NULL, dst->dev,\n\t\t      dst_output);\n\tif (!err) {\n\t\tICMP6MSGOUT_INC_STATS(net, idev, type);\n\t\tICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);\n\t}\n\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ndisc_send_skb);\n\nvoid ndisc_send_na(struct net_device *dev, const struct in6_addr *daddr,\n\t\t   const struct in6_addr *solicited_addr,\n\t\t   bool router, bool solicited, bool override, bool inc_opt)\n{\n\tstruct sk_buff *skb;\n\tstruct in6_addr tmpaddr;\n\tstruct inet6_ifaddr *ifp;\n\tconst struct in6_addr *src_addr;\n\tstruct nd_msg *msg;\n\tint optlen = 0;\n\n\t \n\tifp = ipv6_get_ifaddr(dev_net(dev), solicited_addr, dev, 1);\n\tif (ifp) {\n\t\tsrc_addr = solicited_addr;\n\t\tif (ifp->flags & IFA_F_OPTIMISTIC)\n\t\t\toverride = false;\n\t\tinc_opt |= ifp->idev->cnf.force_tllao;\n\t\tin6_ifa_put(ifp);\n\t} else {\n\t\tif (ipv6_dev_get_saddr(dev_net(dev), dev, daddr,\n\t\t\t\t       inet6_sk(dev_net(dev)->ipv6.ndisc_sk)->srcprefs,\n\t\t\t\t       &tmpaddr))\n\t\t\treturn;\n\t\tsrc_addr = &tmpaddr;\n\t}\n\n\tif (!dev->addr_len)\n\t\tinc_opt = false;\n\tif (inc_opt)\n\t\toptlen += ndisc_opt_addr_space(dev,\n\t\t\t\t\t       NDISC_NEIGHBOUR_ADVERTISEMENT);\n\n\tskb = ndisc_alloc_skb(dev, sizeof(*msg) + optlen);\n\tif (!skb)\n\t\treturn;\n\n\tmsg = skb_put(skb, sizeof(*msg));\n\t*msg = (struct nd_msg) {\n\t\t.icmph = {\n\t\t\t.icmp6_type = NDISC_NEIGHBOUR_ADVERTISEMENT,\n\t\t\t.icmp6_router = router,\n\t\t\t.icmp6_solicited = solicited,\n\t\t\t.icmp6_override = override,\n\t\t},\n\t\t.target = *solicited_addr,\n\t};\n\n\tif (inc_opt)\n\t\tndisc_fill_addr_option(skb, ND_OPT_TARGET_LL_ADDR,\n\t\t\t\t       dev->dev_addr,\n\t\t\t\t       NDISC_NEIGHBOUR_ADVERTISEMENT);\n\n\tndisc_send_skb(skb, daddr, src_addr);\n}\n\nstatic void ndisc_send_unsol_na(struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\tstruct inet6_ifaddr *ifa;\n\n\tidev = in6_dev_get(dev);\n\tif (!idev)\n\t\treturn;\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifa, &idev->addr_list, if_list) {\n\t\t \n\t\tif (ifa->flags & IFA_F_TENTATIVE &&\n\t\t    !(ifa->flags & IFA_F_OPTIMISTIC))\n\t\t\tcontinue;\n\n\t\tndisc_send_na(dev, &in6addr_linklocal_allnodes, &ifa->addr,\n\t\t\t        !!idev->cnf.forwarding,\n\t\t\t        false,   true,\n\t\t\t        true);\n\t}\n\tread_unlock_bh(&idev->lock);\n\n\tin6_dev_put(idev);\n}\n\nstruct sk_buff *ndisc_ns_create(struct net_device *dev, const struct in6_addr *solicit,\n\t\t\t\tconst struct in6_addr *saddr, u64 nonce)\n{\n\tint inc_opt = dev->addr_len;\n\tstruct sk_buff *skb;\n\tstruct nd_msg *msg;\n\tint optlen = 0;\n\n\tif (!saddr)\n\t\treturn NULL;\n\n\tif (ipv6_addr_any(saddr))\n\t\tinc_opt = false;\n\tif (inc_opt)\n\t\toptlen += ndisc_opt_addr_space(dev,\n\t\t\t\t\t       NDISC_NEIGHBOUR_SOLICITATION);\n\tif (nonce != 0)\n\t\toptlen += 8;\n\n\tskb = ndisc_alloc_skb(dev, sizeof(*msg) + optlen);\n\tif (!skb)\n\t\treturn NULL;\n\n\tmsg = skb_put(skb, sizeof(*msg));\n\t*msg = (struct nd_msg) {\n\t\t.icmph = {\n\t\t\t.icmp6_type = NDISC_NEIGHBOUR_SOLICITATION,\n\t\t},\n\t\t.target = *solicit,\n\t};\n\n\tif (inc_opt)\n\t\tndisc_fill_addr_option(skb, ND_OPT_SOURCE_LL_ADDR,\n\t\t\t\t       dev->dev_addr,\n\t\t\t\t       NDISC_NEIGHBOUR_SOLICITATION);\n\tif (nonce != 0) {\n\t\tu8 *opt = skb_put(skb, 8);\n\n\t\topt[0] = ND_OPT_NONCE;\n\t\topt[1] = 8 >> 3;\n\t\tmemcpy(opt + 2, &nonce, 6);\n\t}\n\n\treturn skb;\n}\nEXPORT_SYMBOL(ndisc_ns_create);\n\nvoid ndisc_send_ns(struct net_device *dev, const struct in6_addr *solicit,\n\t\t   const struct in6_addr *daddr, const struct in6_addr *saddr,\n\t\t   u64 nonce)\n{\n\tstruct in6_addr addr_buf;\n\tstruct sk_buff *skb;\n\n\tif (!saddr) {\n\t\tif (ipv6_get_lladdr(dev, &addr_buf,\n\t\t\t\t    (IFA_F_TENTATIVE | IFA_F_OPTIMISTIC)))\n\t\t\treturn;\n\t\tsaddr = &addr_buf;\n\t}\n\n\tskb = ndisc_ns_create(dev, solicit, saddr, nonce);\n\n\tif (skb)\n\t\tndisc_send_skb(skb, daddr, saddr);\n}\n\nvoid ndisc_send_rs(struct net_device *dev, const struct in6_addr *saddr,\n\t\t   const struct in6_addr *daddr)\n{\n\tstruct sk_buff *skb;\n\tstruct rs_msg *msg;\n\tint send_sllao = dev->addr_len;\n\tint optlen = 0;\n\n#ifdef CONFIG_IPV6_OPTIMISTIC_DAD\n\t \n\tif (send_sllao) {\n\t\tstruct inet6_ifaddr *ifp = ipv6_get_ifaddr(dev_net(dev), saddr,\n\t\t\t\t\t\t\t   dev, 1);\n\t\tif (ifp) {\n\t\t\tif (ifp->flags & IFA_F_OPTIMISTIC)  {\n\t\t\t\tsend_sllao = 0;\n\t\t\t}\n\t\t\tin6_ifa_put(ifp);\n\t\t} else {\n\t\t\tsend_sllao = 0;\n\t\t}\n\t}\n#endif\n\tif (send_sllao)\n\t\toptlen += ndisc_opt_addr_space(dev, NDISC_ROUTER_SOLICITATION);\n\n\tskb = ndisc_alloc_skb(dev, sizeof(*msg) + optlen);\n\tif (!skb)\n\t\treturn;\n\n\tmsg = skb_put(skb, sizeof(*msg));\n\t*msg = (struct rs_msg) {\n\t\t.icmph = {\n\t\t\t.icmp6_type = NDISC_ROUTER_SOLICITATION,\n\t\t},\n\t};\n\n\tif (send_sllao)\n\t\tndisc_fill_addr_option(skb, ND_OPT_SOURCE_LL_ADDR,\n\t\t\t\t       dev->dev_addr,\n\t\t\t\t       NDISC_ROUTER_SOLICITATION);\n\n\tndisc_send_skb(skb, daddr, saddr);\n}\n\n\nstatic void ndisc_error_report(struct neighbour *neigh, struct sk_buff *skb)\n{\n\t \n\tdst_link_failure(skb);\n\tkfree_skb(skb);\n}\n\n \n\nstatic void ndisc_solicit(struct neighbour *neigh, struct sk_buff *skb)\n{\n\tstruct in6_addr *saddr = NULL;\n\tstruct in6_addr mcaddr;\n\tstruct net_device *dev = neigh->dev;\n\tstruct in6_addr *target = (struct in6_addr *)&neigh->primary_key;\n\tint probes = atomic_read(&neigh->probes);\n\n\tif (skb && ipv6_chk_addr_and_flags(dev_net(dev), &ipv6_hdr(skb)->saddr,\n\t\t\t\t\t   dev, false, 1,\n\t\t\t\t\t   IFA_F_TENTATIVE|IFA_F_OPTIMISTIC))\n\t\tsaddr = &ipv6_hdr(skb)->saddr;\n\tprobes -= NEIGH_VAR(neigh->parms, UCAST_PROBES);\n\tif (probes < 0) {\n\t\tif (!(READ_ONCE(neigh->nud_state) & NUD_VALID)) {\n\t\t\tND_PRINTK(1, dbg,\n\t\t\t\t  \"%s: trying to ucast probe in NUD_INVALID: %pI6\\n\",\n\t\t\t\t  __func__, target);\n\t\t}\n\t\tndisc_send_ns(dev, target, target, saddr, 0);\n\t} else if ((probes -= NEIGH_VAR(neigh->parms, APP_PROBES)) < 0) {\n\t\tneigh_app_ns(neigh);\n\t} else {\n\t\taddrconf_addr_solict_mult(target, &mcaddr);\n\t\tndisc_send_ns(dev, target, &mcaddr, saddr, 0);\n\t}\n}\n\nstatic int pndisc_is_router(const void *pkey,\n\t\t\t    struct net_device *dev)\n{\n\tstruct pneigh_entry *n;\n\tint ret = -1;\n\n\tread_lock_bh(&nd_tbl.lock);\n\tn = __pneigh_lookup(&nd_tbl, dev_net(dev), pkey, dev);\n\tif (n)\n\t\tret = !!(n->flags & NTF_ROUTER);\n\tread_unlock_bh(&nd_tbl.lock);\n\n\treturn ret;\n}\n\nvoid ndisc_update(const struct net_device *dev, struct neighbour *neigh,\n\t\t  const u8 *lladdr, u8 new, u32 flags, u8 icmp6_type,\n\t\t  struct ndisc_options *ndopts)\n{\n\tneigh_update(neigh, lladdr, new, flags, 0);\n\t \n\tndisc_ops_update(dev, neigh, flags, icmp6_type, ndopts);\n}\n\nstatic enum skb_drop_reason ndisc_recv_ns(struct sk_buff *skb)\n{\n\tstruct nd_msg *msg = (struct nd_msg *)skb_transport_header(skb);\n\tconst struct in6_addr *saddr = &ipv6_hdr(skb)->saddr;\n\tconst struct in6_addr *daddr = &ipv6_hdr(skb)->daddr;\n\tu8 *lladdr = NULL;\n\tu32 ndoptlen = skb_tail_pointer(skb) - (skb_transport_header(skb) +\n\t\t\t\t    offsetof(struct nd_msg, opt));\n\tstruct ndisc_options ndopts;\n\tstruct net_device *dev = skb->dev;\n\tstruct inet6_ifaddr *ifp;\n\tstruct inet6_dev *idev = NULL;\n\tstruct neighbour *neigh;\n\tint dad = ipv6_addr_any(saddr);\n\tint is_router = -1;\n\tSKB_DR(reason);\n\tu64 nonce = 0;\n\tbool inc;\n\n\tif (skb->len < sizeof(struct nd_msg))\n\t\treturn SKB_DROP_REASON_PKT_TOO_SMALL;\n\n\tif (ipv6_addr_is_multicast(&msg->target)) {\n\t\tND_PRINTK(2, warn, \"NS: multicast target address\\n\");\n\t\treturn reason;\n\t}\n\n\t \n\tif (dad && !ipv6_addr_is_solict_mult(daddr)) {\n\t\tND_PRINTK(2, warn, \"NS: bad DAD packet (wrong destination)\\n\");\n\t\treturn reason;\n\t}\n\n\tif (!ndisc_parse_options(dev, msg->opt, ndoptlen, &ndopts))\n\t\treturn SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS;\n\n\tif (ndopts.nd_opts_src_lladdr) {\n\t\tlladdr = ndisc_opt_addr_data(ndopts.nd_opts_src_lladdr, dev);\n\t\tif (!lladdr) {\n\t\t\tND_PRINTK(2, warn,\n\t\t\t\t  \"NS: invalid link-layer address length\\n\");\n\t\t\treturn reason;\n\t\t}\n\n\t\t \n\t\tif (dad) {\n\t\t\tND_PRINTK(2, warn,\n\t\t\t\t  \"NS: bad DAD packet (link-layer address option)\\n\");\n\t\t\treturn reason;\n\t\t}\n\t}\n\tif (ndopts.nd_opts_nonce && ndopts.nd_opts_nonce->nd_opt_len == 1)\n\t\tmemcpy(&nonce, (u8 *)(ndopts.nd_opts_nonce + 1), 6);\n\n\tinc = ipv6_addr_is_multicast(daddr);\n\n\tifp = ipv6_get_ifaddr(dev_net(dev), &msg->target, dev, 1);\n\tif (ifp) {\nhave_ifp:\n\t\tif (ifp->flags & (IFA_F_TENTATIVE|IFA_F_OPTIMISTIC)) {\n\t\t\tif (dad) {\n\t\t\t\tif (nonce != 0 && ifp->dad_nonce == nonce) {\n\t\t\t\t\tu8 *np = (u8 *)&nonce;\n\t\t\t\t\t \n\t\t\t\t\tND_PRINTK(2, notice,\n\t\t\t\t\t\t  \"%s: IPv6 DAD loopback for address %pI6c nonce %pM ignored\\n\",\n\t\t\t\t\t\t  ifp->idev->dev->name,\n\t\t\t\t\t\t  &ifp->addr, np);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\taddrconf_dad_failure(skb, ifp);\n\t\t\t\treturn reason;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (!(ifp->flags & IFA_F_OPTIMISTIC))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tidev = ifp->idev;\n\t} else {\n\t\tstruct net *net = dev_net(dev);\n\n\t\t \n\t\tif (netif_is_l3_slave(dev)) {\n\t\t\tstruct net_device *mdev;\n\n\t\t\tmdev = netdev_master_upper_dev_get_rcu(dev);\n\t\t\tif (mdev) {\n\t\t\t\tifp = ipv6_get_ifaddr(net, &msg->target, mdev, 1);\n\t\t\t\tif (ifp)\n\t\t\t\t\tgoto have_ifp;\n\t\t\t}\n\t\t}\n\n\t\tidev = in6_dev_get(dev);\n\t\tif (!idev) {\n\t\t\t \n\t\t\treturn reason;\n\t\t}\n\n\t\tif (ipv6_chk_acast_addr(net, dev, &msg->target) ||\n\t\t    (idev->cnf.forwarding &&\n\t\t     (net->ipv6.devconf_all->proxy_ndp || idev->cnf.proxy_ndp) &&\n\t\t     (is_router = pndisc_is_router(&msg->target, dev)) >= 0)) {\n\t\t\tif (!(NEIGH_CB(skb)->flags & LOCALLY_ENQUEUED) &&\n\t\t\t    skb->pkt_type != PACKET_HOST &&\n\t\t\t    inc &&\n\t\t\t    NEIGH_VAR(idev->nd_parms, PROXY_DELAY) != 0) {\n\t\t\t\t \n\t\t\t\tstruct sk_buff *n = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (n)\n\t\t\t\t\tpneigh_enqueue(&nd_tbl, idev->nd_parms, n);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tSKB_DR_SET(reason, IPV6_NDISC_NS_OTHERHOST);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (is_router < 0)\n\t\tis_router = idev->cnf.forwarding;\n\n\tif (dad) {\n\t\tndisc_send_na(dev, &in6addr_linklocal_allnodes, &msg->target,\n\t\t\t      !!is_router, false, (ifp != NULL), true);\n\t\tgoto out;\n\t}\n\n\tif (inc)\n\t\tNEIGH_CACHE_STAT_INC(&nd_tbl, rcv_probes_mcast);\n\telse\n\t\tNEIGH_CACHE_STAT_INC(&nd_tbl, rcv_probes_ucast);\n\n\t \n\tneigh = __neigh_lookup(&nd_tbl, saddr, dev,\n\t\t\t       !inc || lladdr || !dev->addr_len);\n\tif (neigh)\n\t\tndisc_update(dev, neigh, lladdr, NUD_STALE,\n\t\t\t     NEIGH_UPDATE_F_WEAK_OVERRIDE|\n\t\t\t     NEIGH_UPDATE_F_OVERRIDE,\n\t\t\t     NDISC_NEIGHBOUR_SOLICITATION, &ndopts);\n\tif (neigh || !dev->header_ops) {\n\t\tndisc_send_na(dev, saddr, &msg->target, !!is_router,\n\t\t\t      true, (ifp != NULL && inc), inc);\n\t\tif (neigh)\n\t\t\tneigh_release(neigh);\n\t\treason = SKB_CONSUMED;\n\t}\n\nout:\n\tif (ifp)\n\t\tin6_ifa_put(ifp);\n\telse\n\t\tin6_dev_put(idev);\n\treturn reason;\n}\n\nstatic int accept_untracked_na(struct net_device *dev, struct in6_addr *saddr)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\n\tswitch (idev->cnf.accept_untracked_na) {\n\tcase 0:  \n\t\treturn 0;\n\tcase 1:  \n\t\treturn 1;\n\tcase 2:  \n\t\treturn !!ipv6_chk_prefix(saddr, dev);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic enum skb_drop_reason ndisc_recv_na(struct sk_buff *skb)\n{\n\tstruct nd_msg *msg = (struct nd_msg *)skb_transport_header(skb);\n\tstruct in6_addr *saddr = &ipv6_hdr(skb)->saddr;\n\tconst struct in6_addr *daddr = &ipv6_hdr(skb)->daddr;\n\tu8 *lladdr = NULL;\n\tu32 ndoptlen = skb_tail_pointer(skb) - (skb_transport_header(skb) +\n\t\t\t\t    offsetof(struct nd_msg, opt));\n\tstruct ndisc_options ndopts;\n\tstruct net_device *dev = skb->dev;\n\tstruct inet6_dev *idev = __in6_dev_get(dev);\n\tstruct inet6_ifaddr *ifp;\n\tstruct neighbour *neigh;\n\tSKB_DR(reason);\n\tu8 new_state;\n\n\tif (skb->len < sizeof(struct nd_msg))\n\t\treturn SKB_DROP_REASON_PKT_TOO_SMALL;\n\n\tif (ipv6_addr_is_multicast(&msg->target)) {\n\t\tND_PRINTK(2, warn, \"NA: target address is multicast\\n\");\n\t\treturn reason;\n\t}\n\n\tif (ipv6_addr_is_multicast(daddr) &&\n\t    msg->icmph.icmp6_solicited) {\n\t\tND_PRINTK(2, warn, \"NA: solicited NA is multicasted\\n\");\n\t\treturn reason;\n\t}\n\n\t \n\tif (!msg->icmph.icmp6_solicited && idev &&\n\t    idev->cnf.drop_unsolicited_na)\n\t\treturn reason;\n\n\tif (!ndisc_parse_options(dev, msg->opt, ndoptlen, &ndopts))\n\t\treturn SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS;\n\n\tif (ndopts.nd_opts_tgt_lladdr) {\n\t\tlladdr = ndisc_opt_addr_data(ndopts.nd_opts_tgt_lladdr, dev);\n\t\tif (!lladdr) {\n\t\t\tND_PRINTK(2, warn,\n\t\t\t\t  \"NA: invalid link-layer address length\\n\");\n\t\t\treturn reason;\n\t\t}\n\t}\n\tifp = ipv6_get_ifaddr(dev_net(dev), &msg->target, dev, 1);\n\tif (ifp) {\n\t\tif (skb->pkt_type != PACKET_LOOPBACK\n\t\t    && (ifp->flags & IFA_F_TENTATIVE)) {\n\t\t\t\taddrconf_dad_failure(skb, ifp);\n\t\t\t\treturn reason;\n\t\t}\n\t\t \n\t\tif (skb->pkt_type != PACKET_LOOPBACK)\n\t\t\tND_PRINTK(1, warn,\n\t\t\t\t  \"NA: %pM advertised our address %pI6c on %s!\\n\",\n\t\t\t\t  eth_hdr(skb)->h_source, &ifp->addr, ifp->idev->dev->name);\n\t\tin6_ifa_put(ifp);\n\t\treturn reason;\n\t}\n\n\tneigh = neigh_lookup(&nd_tbl, &msg->target, dev);\n\n\t \n\tnew_state = msg->icmph.icmp6_solicited ? NUD_REACHABLE : NUD_STALE;\n\tif (!neigh && lladdr && idev && idev->cnf.forwarding) {\n\t\tif (accept_untracked_na(dev, saddr)) {\n\t\t\tneigh = neigh_create(&nd_tbl, &msg->target, dev);\n\t\t\tnew_state = NUD_STALE;\n\t\t}\n\t}\n\n\tif (neigh && !IS_ERR(neigh)) {\n\t\tu8 old_flags = neigh->flags;\n\t\tstruct net *net = dev_net(dev);\n\n\t\tif (READ_ONCE(neigh->nud_state) & NUD_FAILED)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (lladdr && !memcmp(lladdr, dev->dev_addr, dev->addr_len) &&\n\t\t    net->ipv6.devconf_all->forwarding && net->ipv6.devconf_all->proxy_ndp &&\n\t\t    pneigh_lookup(&nd_tbl, net, &msg->target, dev, 0)) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\tndisc_update(dev, neigh, lladdr,\n\t\t\t     new_state,\n\t\t\t     NEIGH_UPDATE_F_WEAK_OVERRIDE|\n\t\t\t     (msg->icmph.icmp6_override ? NEIGH_UPDATE_F_OVERRIDE : 0)|\n\t\t\t     NEIGH_UPDATE_F_OVERRIDE_ISROUTER|\n\t\t\t     (msg->icmph.icmp6_router ? NEIGH_UPDATE_F_ISROUTER : 0),\n\t\t\t     NDISC_NEIGHBOUR_ADVERTISEMENT, &ndopts);\n\n\t\tif ((old_flags & ~neigh->flags) & NTF_ROUTER) {\n\t\t\t \n\t\t\trt6_clean_tohost(dev_net(dev),  saddr);\n\t\t}\n\t\treason = SKB_CONSUMED;\nout:\n\t\tneigh_release(neigh);\n\t}\n\treturn reason;\n}\n\nstatic enum skb_drop_reason ndisc_recv_rs(struct sk_buff *skb)\n{\n\tstruct rs_msg *rs_msg = (struct rs_msg *)skb_transport_header(skb);\n\tunsigned long ndoptlen = skb->len - sizeof(*rs_msg);\n\tstruct neighbour *neigh;\n\tstruct inet6_dev *idev;\n\tconst struct in6_addr *saddr = &ipv6_hdr(skb)->saddr;\n\tstruct ndisc_options ndopts;\n\tu8 *lladdr = NULL;\n\tSKB_DR(reason);\n\n\tif (skb->len < sizeof(*rs_msg))\n\t\treturn SKB_DROP_REASON_PKT_TOO_SMALL;\n\n\tidev = __in6_dev_get(skb->dev);\n\tif (!idev) {\n\t\tND_PRINTK(1, err, \"RS: can't find in6 device\\n\");\n\t\treturn reason;\n\t}\n\n\t \n\tif (!idev->cnf.forwarding)\n\t\tgoto out;\n\n\t \n\tif (ipv6_addr_any(saddr))\n\t\tgoto out;\n\n\t \n\tif (!ndisc_parse_options(skb->dev, rs_msg->opt, ndoptlen, &ndopts))\n\t\treturn SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS;\n\n\tif (ndopts.nd_opts_src_lladdr) {\n\t\tlladdr = ndisc_opt_addr_data(ndopts.nd_opts_src_lladdr,\n\t\t\t\t\t     skb->dev);\n\t\tif (!lladdr)\n\t\t\tgoto out;\n\t}\n\n\tneigh = __neigh_lookup(&nd_tbl, saddr, skb->dev, 1);\n\tif (neigh) {\n\t\tndisc_update(skb->dev, neigh, lladdr, NUD_STALE,\n\t\t\t     NEIGH_UPDATE_F_WEAK_OVERRIDE|\n\t\t\t     NEIGH_UPDATE_F_OVERRIDE|\n\t\t\t     NEIGH_UPDATE_F_OVERRIDE_ISROUTER,\n\t\t\t     NDISC_ROUTER_SOLICITATION, &ndopts);\n\t\tneigh_release(neigh);\n\t\treason = SKB_CONSUMED;\n\t}\nout:\n\treturn reason;\n}\n\nstatic void ndisc_ra_useropt(struct sk_buff *ra, struct nd_opt_hdr *opt)\n{\n\tstruct icmp6hdr *icmp6h = (struct icmp6hdr *)skb_transport_header(ra);\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\tstruct nduseroptmsg *ndmsg;\n\tstruct net *net = dev_net(ra->dev);\n\tint err;\n\tint base_size = NLMSG_ALIGN(sizeof(struct nduseroptmsg)\n\t\t\t\t    + (opt->nd_opt_len << 3));\n\tsize_t msg_size = base_size + nla_total_size(sizeof(struct in6_addr));\n\n\tskb = nlmsg_new(msg_size, GFP_ATOMIC);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\tnlh = nlmsg_put(skb, 0, 0, RTM_NEWNDUSEROPT, base_size, 0);\n\tif (!nlh) {\n\t\tgoto nla_put_failure;\n\t}\n\n\tndmsg = nlmsg_data(nlh);\n\tndmsg->nduseropt_family = AF_INET6;\n\tndmsg->nduseropt_ifindex = ra->dev->ifindex;\n\tndmsg->nduseropt_icmp_type = icmp6h->icmp6_type;\n\tndmsg->nduseropt_icmp_code = icmp6h->icmp6_code;\n\tndmsg->nduseropt_opts_len = opt->nd_opt_len << 3;\n\n\tmemcpy(ndmsg + 1, opt, opt->nd_opt_len << 3);\n\n\tif (nla_put_in6_addr(skb, NDUSEROPT_SRCADDR, &ipv6_hdr(ra)->saddr))\n\t\tgoto nla_put_failure;\n\tnlmsg_end(skb, nlh);\n\n\trtnl_notify(skb, net, 0, RTNLGRP_ND_USEROPT, NULL, GFP_ATOMIC);\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(skb);\n\terr = -EMSGSIZE;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_ND_USEROPT, err);\n}\n\nstatic enum skb_drop_reason ndisc_router_discovery(struct sk_buff *skb)\n{\n\tstruct ra_msg *ra_msg = (struct ra_msg *)skb_transport_header(skb);\n\tbool send_ifinfo_notify = false;\n\tstruct neighbour *neigh = NULL;\n\tstruct ndisc_options ndopts;\n\tstruct fib6_info *rt = NULL;\n\tstruct inet6_dev *in6_dev;\n\tu32 defrtr_usr_metric;\n\tunsigned int pref = 0;\n\t__u32 old_if_flags;\n\tstruct net *net;\n\tSKB_DR(reason);\n\tint lifetime;\n\tint optlen;\n\n\t__u8 *opt = (__u8 *)(ra_msg + 1);\n\n\toptlen = (skb_tail_pointer(skb) - skb_transport_header(skb)) -\n\t\tsizeof(struct ra_msg);\n\n\tND_PRINTK(2, info,\n\t\t  \"RA: %s, dev: %s\\n\",\n\t\t  __func__, skb->dev->name);\n\tif (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL)) {\n\t\tND_PRINTK(2, warn, \"RA: source address is not link-local\\n\");\n\t\treturn reason;\n\t}\n\tif (optlen < 0)\n\t\treturn SKB_DROP_REASON_PKT_TOO_SMALL;\n\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\n\tif (skb->ndisc_nodetype == NDISC_NODETYPE_HOST) {\n\t\tND_PRINTK(2, warn, \"RA: from host or unauthorized router\\n\");\n\t\treturn reason;\n\t}\n#endif\n\n\tin6_dev = __in6_dev_get(skb->dev);\n\tif (!in6_dev) {\n\t\tND_PRINTK(0, err, \"RA: can't find inet6 device for %s\\n\",\n\t\t\t  skb->dev->name);\n\t\treturn reason;\n\t}\n\n\tif (!ndisc_parse_options(skb->dev, opt, optlen, &ndopts))\n\t\treturn SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS;\n\n\tif (!ipv6_accept_ra(in6_dev)) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA: %s, did not accept ra for dev: %s\\n\",\n\t\t\t  __func__, skb->dev->name);\n\t\tgoto skip_linkparms;\n\t}\n\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\n\t \n\tif (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA: %s, nodetype is NODEFAULT, dev: %s\\n\",\n\t\t\t  __func__, skb->dev->name);\n\t\tgoto skip_linkparms;\n\t}\n#endif\n\n\tif (in6_dev->if_flags & IF_RS_SENT) {\n\t\t \n\t\tin6_dev->if_flags |= IF_RA_RCVD;\n\t}\n\n\t \n\told_if_flags = in6_dev->if_flags;\n\tin6_dev->if_flags = (in6_dev->if_flags & ~(IF_RA_MANAGED |\n\t\t\t\tIF_RA_OTHERCONF)) |\n\t\t\t\t(ra_msg->icmph.icmp6_addrconf_managed ?\n\t\t\t\t\tIF_RA_MANAGED : 0) |\n\t\t\t\t(ra_msg->icmph.icmp6_addrconf_other ?\n\t\t\t\t\tIF_RA_OTHERCONF : 0);\n\n\tif (old_if_flags != in6_dev->if_flags)\n\t\tsend_ifinfo_notify = true;\n\n\tif (!in6_dev->cnf.accept_ra_defrtr) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA: %s, defrtr is false for dev: %s\\n\",\n\t\t\t  __func__, skb->dev->name);\n\t\tgoto skip_defrtr;\n\t}\n\n\tlifetime = ntohs(ra_msg->icmph.icmp6_rt_lifetime);\n\tif (lifetime != 0 && lifetime < in6_dev->cnf.accept_ra_min_lft) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA: router lifetime (%ds) is too short: %s\\n\",\n\t\t\t  lifetime, skb->dev->name);\n\t\tgoto skip_defrtr;\n\t}\n\n\t \n\tnet = dev_net(in6_dev->dev);\n\tif (!in6_dev->cnf.accept_ra_from_local &&\n\t    ipv6_chk_addr(net, &ipv6_hdr(skb)->saddr, in6_dev->dev, 0)) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA from local address detected on dev: %s: default router ignored\\n\",\n\t\t\t  skb->dev->name);\n\t\tgoto skip_defrtr;\n\t}\n\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\tpref = ra_msg->icmph.icmp6_router_pref;\n\t \n\tif (pref == ICMPV6_ROUTER_PREF_INVALID ||\n\t    !in6_dev->cnf.accept_ra_rtr_pref)\n\t\tpref = ICMPV6_ROUTER_PREF_MEDIUM;\n#endif\n\t \n\trt = rt6_get_dflt_router(net, &ipv6_hdr(skb)->saddr, skb->dev);\n\tif (rt) {\n\t\tneigh = ip6_neigh_lookup(&rt->fib6_nh->fib_nh_gw6,\n\t\t\t\t\t rt->fib6_nh->fib_nh_dev, NULL,\n\t\t\t\t\t  &ipv6_hdr(skb)->saddr);\n\t\tif (!neigh) {\n\t\t\tND_PRINTK(0, err,\n\t\t\t\t  \"RA: %s got default router without neighbour\\n\",\n\t\t\t\t  __func__);\n\t\t\tfib6_info_release(rt);\n\t\t\treturn reason;\n\t\t}\n\t}\n\t \n\tdefrtr_usr_metric = in6_dev->cnf.ra_defrtr_metric;\n\t \n\tif (rt && (lifetime == 0 || rt->fib6_metric != defrtr_usr_metric)) {\n\t\tip6_del_rt(net, rt, false);\n\t\trt = NULL;\n\t}\n\n\tND_PRINTK(3, info, \"RA: rt: %p  lifetime: %d, metric: %d, for dev: %s\\n\",\n\t\t  rt, lifetime, defrtr_usr_metric, skb->dev->name);\n\tif (!rt && lifetime) {\n\t\tND_PRINTK(3, info, \"RA: adding default router\\n\");\n\n\t\tif (neigh)\n\t\t\tneigh_release(neigh);\n\n\t\trt = rt6_add_dflt_router(net, &ipv6_hdr(skb)->saddr,\n\t\t\t\t\t skb->dev, pref, defrtr_usr_metric);\n\t\tif (!rt) {\n\t\t\tND_PRINTK(0, err,\n\t\t\t\t  \"RA: %s failed to add default route\\n\",\n\t\t\t\t  __func__);\n\t\t\treturn reason;\n\t\t}\n\n\t\tneigh = ip6_neigh_lookup(&rt->fib6_nh->fib_nh_gw6,\n\t\t\t\t\t rt->fib6_nh->fib_nh_dev, NULL,\n\t\t\t\t\t  &ipv6_hdr(skb)->saddr);\n\t\tif (!neigh) {\n\t\t\tND_PRINTK(0, err,\n\t\t\t\t  \"RA: %s got default router without neighbour\\n\",\n\t\t\t\t  __func__);\n\t\t\tfib6_info_release(rt);\n\t\t\treturn reason;\n\t\t}\n\t\tneigh->flags |= NTF_ROUTER;\n\t} else if (rt && IPV6_EXTRACT_PREF(rt->fib6_flags) != pref) {\n\t\tstruct nl_info nlinfo = {\n\t\t\t.nl_net = net,\n\t\t};\n\t\trt->fib6_flags = (rt->fib6_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);\n\t\tinet6_rt_notify(RTM_NEWROUTE, rt, &nlinfo, NLM_F_REPLACE);\n\t}\n\n\tif (rt)\n\t\tfib6_set_expires(rt, jiffies + (HZ * lifetime));\n\tif (in6_dev->cnf.accept_ra_min_hop_limit < 256 &&\n\t    ra_msg->icmph.icmp6_hop_limit) {\n\t\tif (in6_dev->cnf.accept_ra_min_hop_limit <= ra_msg->icmph.icmp6_hop_limit) {\n\t\t\tin6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;\n\t\t\tfib6_metric_set(rt, RTAX_HOPLIMIT,\n\t\t\t\t\tra_msg->icmph.icmp6_hop_limit);\n\t\t} else {\n\t\t\tND_PRINTK(2, warn, \"RA: Got route advertisement with lower hop_limit than minimum\\n\");\n\t\t}\n\t}\n\nskip_defrtr:\n\n\t \n\n\tif (in6_dev->nd_parms) {\n\t\tunsigned long rtime = ntohl(ra_msg->retrans_timer);\n\n\t\tif (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/HZ) {\n\t\t\trtime = (rtime*HZ)/1000;\n\t\t\tif (rtime < HZ/100)\n\t\t\t\trtime = HZ/100;\n\t\t\tNEIGH_VAR_SET(in6_dev->nd_parms, RETRANS_TIME, rtime);\n\t\t\tin6_dev->tstamp = jiffies;\n\t\t\tsend_ifinfo_notify = true;\n\t\t}\n\n\t\trtime = ntohl(ra_msg->reachable_time);\n\t\tif (rtime && rtime/1000 < MAX_SCHEDULE_TIMEOUT/(3*HZ)) {\n\t\t\trtime = (rtime*HZ)/1000;\n\n\t\t\tif (rtime < HZ/10)\n\t\t\t\trtime = HZ/10;\n\n\t\t\tif (rtime != NEIGH_VAR(in6_dev->nd_parms, BASE_REACHABLE_TIME)) {\n\t\t\t\tNEIGH_VAR_SET(in6_dev->nd_parms,\n\t\t\t\t\t      BASE_REACHABLE_TIME, rtime);\n\t\t\t\tNEIGH_VAR_SET(in6_dev->nd_parms,\n\t\t\t\t\t      GC_STALETIME, 3 * rtime);\n\t\t\t\tin6_dev->nd_parms->reachable_time = neigh_rand_reach_time(rtime);\n\t\t\t\tin6_dev->tstamp = jiffies;\n\t\t\t\tsend_ifinfo_notify = true;\n\t\t\t}\n\t\t}\n\t}\n\nskip_linkparms:\n\n\t \n\n\tif (!neigh)\n\t\tneigh = __neigh_lookup(&nd_tbl, &ipv6_hdr(skb)->saddr,\n\t\t\t\t       skb->dev, 1);\n\tif (neigh) {\n\t\tu8 *lladdr = NULL;\n\t\tif (ndopts.nd_opts_src_lladdr) {\n\t\t\tlladdr = ndisc_opt_addr_data(ndopts.nd_opts_src_lladdr,\n\t\t\t\t\t\t     skb->dev);\n\t\t\tif (!lladdr) {\n\t\t\t\tND_PRINTK(2, warn,\n\t\t\t\t\t  \"RA: invalid link-layer address length\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tndisc_update(skb->dev, neigh, lladdr, NUD_STALE,\n\t\t\t     NEIGH_UPDATE_F_WEAK_OVERRIDE|\n\t\t\t     NEIGH_UPDATE_F_OVERRIDE|\n\t\t\t     NEIGH_UPDATE_F_OVERRIDE_ISROUTER|\n\t\t\t     NEIGH_UPDATE_F_ISROUTER,\n\t\t\t     NDISC_ROUTER_ADVERTISEMENT, &ndopts);\n\t\treason = SKB_CONSUMED;\n\t}\n\n\tif (!ipv6_accept_ra(in6_dev)) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA: %s, accept_ra is false for dev: %s\\n\",\n\t\t\t  __func__, skb->dev->name);\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_IPV6_ROUTE_INFO\n\tif (!in6_dev->cnf.accept_ra_from_local &&\n\t    ipv6_chk_addr(dev_net(in6_dev->dev), &ipv6_hdr(skb)->saddr,\n\t\t\t  in6_dev->dev, 0)) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA from local address detected on dev: %s: router info ignored.\\n\",\n\t\t\t  skb->dev->name);\n\t\tgoto skip_routeinfo;\n\t}\n\n\tif (in6_dev->cnf.accept_ra_rtr_pref && ndopts.nd_opts_ri) {\n\t\tstruct nd_opt_hdr *p;\n\t\tfor (p = ndopts.nd_opts_ri;\n\t\t     p;\n\t\t     p = ndisc_next_option(p, ndopts.nd_opts_ri_end)) {\n\t\t\tstruct route_info *ri = (struct route_info *)p;\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\n\t\t\tif (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT &&\n\t\t\t    ri->prefix_len == 0)\n\t\t\t\tcontinue;\n#endif\n\t\t\tif (ri->prefix_len == 0 &&\n\t\t\t    !in6_dev->cnf.accept_ra_defrtr)\n\t\t\t\tcontinue;\n\t\t\tif (ri->lifetime != 0 &&\n\t\t\t    ntohl(ri->lifetime) < in6_dev->cnf.accept_ra_min_lft)\n\t\t\t\tcontinue;\n\t\t\tif (ri->prefix_len < in6_dev->cnf.accept_ra_rt_info_min_plen)\n\t\t\t\tcontinue;\n\t\t\tif (ri->prefix_len > in6_dev->cnf.accept_ra_rt_info_max_plen)\n\t\t\t\tcontinue;\n\t\t\trt6_route_rcv(skb->dev, (u8 *)p, (p->nd_opt_len) << 3,\n\t\t\t\t      &ipv6_hdr(skb)->saddr);\n\t\t}\n\t}\n\nskip_routeinfo:\n#endif\n\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\n\t \n\tif (skb->ndisc_nodetype == NDISC_NODETYPE_NODEFAULT) {\n\t\tND_PRINTK(2, info,\n\t\t\t  \"RA: %s, nodetype is NODEFAULT (interior routes), dev: %s\\n\",\n\t\t\t  __func__, skb->dev->name);\n\t\tgoto out;\n\t}\n#endif\n\n\tif (in6_dev->cnf.accept_ra_pinfo && ndopts.nd_opts_pi) {\n\t\tstruct nd_opt_hdr *p;\n\t\tfor (p = ndopts.nd_opts_pi;\n\t\t     p;\n\t\t     p = ndisc_next_option(p, ndopts.nd_opts_pi_end)) {\n\t\t\taddrconf_prefix_rcv(skb->dev, (u8 *)p,\n\t\t\t\t\t    (p->nd_opt_len) << 3,\n\t\t\t\t\t    ndopts.nd_opts_src_lladdr != NULL);\n\t\t}\n\t}\n\n\tif (ndopts.nd_opts_mtu && in6_dev->cnf.accept_ra_mtu) {\n\t\t__be32 n;\n\t\tu32 mtu;\n\n\t\tmemcpy(&n, ((u8 *)(ndopts.nd_opts_mtu+1))+2, sizeof(mtu));\n\t\tmtu = ntohl(n);\n\n\t\tif (in6_dev->ra_mtu != mtu) {\n\t\t\tin6_dev->ra_mtu = mtu;\n\t\t\tsend_ifinfo_notify = true;\n\t\t}\n\n\t\tif (mtu < IPV6_MIN_MTU || mtu > skb->dev->mtu) {\n\t\t\tND_PRINTK(2, warn, \"RA: invalid mtu: %d\\n\", mtu);\n\t\t} else if (in6_dev->cnf.mtu6 != mtu) {\n\t\t\tin6_dev->cnf.mtu6 = mtu;\n\t\t\tfib6_metric_set(rt, RTAX_MTU, mtu);\n\t\t\trt6_mtu_change(skb->dev, mtu);\n\t\t}\n\t}\n\n\tif (ndopts.nd_useropts) {\n\t\tstruct nd_opt_hdr *p;\n\t\tfor (p = ndopts.nd_useropts;\n\t\t     p;\n\t\t     p = ndisc_next_useropt(skb->dev, p,\n\t\t\t\t\t    ndopts.nd_useropts_end)) {\n\t\t\tndisc_ra_useropt(skb, p);\n\t\t}\n\t}\n\n\tif (ndopts.nd_opts_tgt_lladdr || ndopts.nd_opts_rh) {\n\t\tND_PRINTK(2, warn, \"RA: invalid RA options\\n\");\n\t}\nout:\n\t \n\tif (send_ifinfo_notify)\n\t\tinet6_ifinfo_notify(RTM_NEWLINK, in6_dev);\n\n\tfib6_info_release(rt);\n\tif (neigh)\n\t\tneigh_release(neigh);\n\treturn reason;\n}\n\nstatic enum skb_drop_reason ndisc_redirect_rcv(struct sk_buff *skb)\n{\n\tstruct rd_msg *msg = (struct rd_msg *)skb_transport_header(skb);\n\tu32 ndoptlen = skb_tail_pointer(skb) - (skb_transport_header(skb) +\n\t\t\t\t    offsetof(struct rd_msg, opt));\n\tstruct ndisc_options ndopts;\n\tSKB_DR(reason);\n\tu8 *hdr;\n\n#ifdef CONFIG_IPV6_NDISC_NODETYPE\n\tswitch (skb->ndisc_nodetype) {\n\tcase NDISC_NODETYPE_HOST:\n\tcase NDISC_NODETYPE_NODEFAULT:\n\t\tND_PRINTK(2, warn,\n\t\t\t  \"Redirect: from host or unauthorized router\\n\");\n\t\treturn reason;\n\t}\n#endif\n\n\tif (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL)) {\n\t\tND_PRINTK(2, warn,\n\t\t\t  \"Redirect: source address is not link-local\\n\");\n\t\treturn reason;\n\t}\n\n\tif (!ndisc_parse_options(skb->dev, msg->opt, ndoptlen, &ndopts))\n\t\treturn SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS;\n\n\tif (!ndopts.nd_opts_rh) {\n\t\tip6_redirect_no_header(skb, dev_net(skb->dev),\n\t\t\t\t\tskb->dev->ifindex);\n\t\treturn reason;\n\t}\n\n\thdr = (u8 *)ndopts.nd_opts_rh;\n\thdr += 8;\n\tif (!pskb_pull(skb, hdr - skb_transport_header(skb)))\n\t\treturn SKB_DROP_REASON_PKT_TOO_SMALL;\n\n\treturn icmpv6_notify(skb, NDISC_REDIRECT, 0, 0);\n}\n\nstatic void ndisc_fill_redirect_hdr_option(struct sk_buff *skb,\n\t\t\t\t\t   struct sk_buff *orig_skb,\n\t\t\t\t\t   int rd_len)\n{\n\tu8 *opt = skb_put(skb, rd_len);\n\n\tmemset(opt, 0, 8);\n\t*(opt++) = ND_OPT_REDIRECT_HDR;\n\t*(opt++) = (rd_len >> 3);\n\topt += 6;\n\n\tskb_copy_bits(orig_skb, skb_network_offset(orig_skb), opt,\n\t\t      rd_len - 8);\n}\n\nvoid ndisc_send_redirect(struct sk_buff *skb, const struct in6_addr *target)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct sock *sk = net->ipv6.ndisc_sk;\n\tint optlen = 0;\n\tstruct inet_peer *peer;\n\tstruct sk_buff *buff;\n\tstruct rd_msg *msg;\n\tstruct in6_addr saddr_buf;\n\tstruct rt6_info *rt;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6;\n\tint rd_len;\n\tu8 ha_buf[MAX_ADDR_LEN], *ha = NULL,\n\t   ops_data_buf[NDISC_OPS_REDIRECT_DATA_SPACE], *ops_data = NULL;\n\tbool ret;\n\n\tif (netif_is_l3_master(skb->dev)) {\n\t\tdev = __dev_get_by_index(dev_net(skb->dev), IPCB(skb)->iif);\n\t\tif (!dev)\n\t\t\treturn;\n\t}\n\n\tif (ipv6_get_lladdr(dev, &saddr_buf, IFA_F_TENTATIVE)) {\n\t\tND_PRINTK(2, warn, \"Redirect: no link-local address on %s\\n\",\n\t\t\t  dev->name);\n\t\treturn;\n\t}\n\n\tif (!ipv6_addr_equal(&ipv6_hdr(skb)->daddr, target) &&\n\t    ipv6_addr_type(target) != (IPV6_ADDR_UNICAST|IPV6_ADDR_LINKLOCAL)) {\n\t\tND_PRINTK(2, warn,\n\t\t\t  \"Redirect: target address is not link-local unicast\\n\");\n\t\treturn;\n\t}\n\n\ticmpv6_flow_init(sk, &fl6, NDISC_REDIRECT,\n\t\t\t &saddr_buf, &ipv6_hdr(skb)->saddr, dev->ifindex);\n\n\tdst = ip6_route_output(net, NULL, &fl6);\n\tif (dst->error) {\n\t\tdst_release(dst);\n\t\treturn;\n\t}\n\tdst = xfrm_lookup(net, dst, flowi6_to_flowi(&fl6), NULL, 0);\n\tif (IS_ERR(dst))\n\t\treturn;\n\n\trt = (struct rt6_info *) dst;\n\n\tif (rt->rt6i_flags & RTF_GATEWAY) {\n\t\tND_PRINTK(2, warn,\n\t\t\t  \"Redirect: destination is not a neighbour\\n\");\n\t\tgoto release;\n\t}\n\tpeer = inet_getpeer_v6(net->ipv6.peers, &ipv6_hdr(skb)->saddr, 1);\n\tret = inet_peer_xrlim_allow(peer, 1*HZ);\n\tif (peer)\n\t\tinet_putpeer(peer);\n\tif (!ret)\n\t\tgoto release;\n\n\tif (dev->addr_len) {\n\t\tstruct neighbour *neigh = dst_neigh_lookup(skb_dst(skb), target);\n\t\tif (!neigh) {\n\t\t\tND_PRINTK(2, warn,\n\t\t\t\t  \"Redirect: no neigh for target address\\n\");\n\t\t\tgoto release;\n\t\t}\n\n\t\tread_lock_bh(&neigh->lock);\n\t\tif (neigh->nud_state & NUD_VALID) {\n\t\t\tmemcpy(ha_buf, neigh->ha, dev->addr_len);\n\t\t\tread_unlock_bh(&neigh->lock);\n\t\t\tha = ha_buf;\n\t\t\toptlen += ndisc_redirect_opt_addr_space(dev, neigh,\n\t\t\t\t\t\t\t\tops_data_buf,\n\t\t\t\t\t\t\t\t&ops_data);\n\t\t} else\n\t\t\tread_unlock_bh(&neigh->lock);\n\n\t\tneigh_release(neigh);\n\t}\n\n\trd_len = min_t(unsigned int,\n\t\t       IPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(*msg) - optlen,\n\t\t       skb->len + 8);\n\trd_len &= ~0x7;\n\toptlen += rd_len;\n\n\tbuff = ndisc_alloc_skb(dev, sizeof(*msg) + optlen);\n\tif (!buff)\n\t\tgoto release;\n\n\tmsg = skb_put(buff, sizeof(*msg));\n\t*msg = (struct rd_msg) {\n\t\t.icmph = {\n\t\t\t.icmp6_type = NDISC_REDIRECT,\n\t\t},\n\t\t.target = *target,\n\t\t.dest = ipv6_hdr(skb)->daddr,\n\t};\n\n\t \n\n\tif (ha)\n\t\tndisc_fill_redirect_addr_option(buff, ha, ops_data);\n\n\t \n\n\tif (rd_len)\n\t\tndisc_fill_redirect_hdr_option(buff, skb, rd_len);\n\n\tskb_dst_set(buff, dst);\n\tndisc_send_skb(buff, &ipv6_hdr(skb)->saddr, &saddr_buf);\n\treturn;\n\nrelease:\n\tdst_release(dst);\n}\n\nstatic void pndisc_redo(struct sk_buff *skb)\n{\n\tenum skb_drop_reason reason = ndisc_recv_ns(skb);\n\n\tkfree_skb_reason(skb, reason);\n}\n\nstatic int ndisc_is_multicast(const void *pkey)\n{\n\treturn ipv6_addr_is_multicast((struct in6_addr *)pkey);\n}\n\nstatic bool ndisc_suppress_frag_ndisc(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev)\n\t\treturn true;\n\tif (IP6CB(skb)->flags & IP6SKB_FRAGMENTED &&\n\t    idev->cnf.suppress_frag_ndisc) {\n\t\tnet_warn_ratelimited(\"Received fragmented ndisc packet. Carefully consider disabling suppress_frag_ndisc.\\n\");\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nenum skb_drop_reason ndisc_rcv(struct sk_buff *skb)\n{\n\tstruct nd_msg *msg;\n\tSKB_DR(reason);\n\n\tif (ndisc_suppress_frag_ndisc(skb))\n\t\treturn SKB_DROP_REASON_IPV6_NDISC_FRAG;\n\n\tif (skb_linearize(skb))\n\t\treturn SKB_DROP_REASON_NOMEM;\n\n\tmsg = (struct nd_msg *)skb_transport_header(skb);\n\n\t__skb_push(skb, skb->data - skb_transport_header(skb));\n\n\tif (ipv6_hdr(skb)->hop_limit != 255) {\n\t\tND_PRINTK(2, warn, \"NDISC: invalid hop-limit: %d\\n\",\n\t\t\t  ipv6_hdr(skb)->hop_limit);\n\t\treturn SKB_DROP_REASON_IPV6_NDISC_HOP_LIMIT;\n\t}\n\n\tif (msg->icmph.icmp6_code != 0) {\n\t\tND_PRINTK(2, warn, \"NDISC: invalid ICMPv6 code: %d\\n\",\n\t\t\t  msg->icmph.icmp6_code);\n\t\treturn SKB_DROP_REASON_IPV6_NDISC_BAD_CODE;\n\t}\n\n\tswitch (msg->icmph.icmp6_type) {\n\tcase NDISC_NEIGHBOUR_SOLICITATION:\n\t\tmemset(NEIGH_CB(skb), 0, sizeof(struct neighbour_cb));\n\t\treason = ndisc_recv_ns(skb);\n\t\tbreak;\n\n\tcase NDISC_NEIGHBOUR_ADVERTISEMENT:\n\t\treason = ndisc_recv_na(skb);\n\t\tbreak;\n\n\tcase NDISC_ROUTER_SOLICITATION:\n\t\treason = ndisc_recv_rs(skb);\n\t\tbreak;\n\n\tcase NDISC_ROUTER_ADVERTISEMENT:\n\t\treason = ndisc_router_discovery(skb);\n\t\tbreak;\n\n\tcase NDISC_REDIRECT:\n\t\treason = ndisc_redirect_rcv(skb);\n\t\tbreak;\n\t}\n\n\treturn reason;\n}\n\nstatic int ndisc_netdev_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_notifier_change_info *change_info;\n\tstruct net *net = dev_net(dev);\n\tstruct inet6_dev *idev;\n\tbool evict_nocarrier;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEADDR:\n\t\tneigh_changeaddr(&nd_tbl, dev);\n\t\tfib6_run_gc(0, net, false);\n\t\tfallthrough;\n\tcase NETDEV_UP:\n\t\tidev = in6_dev_get(dev);\n\t\tif (!idev)\n\t\t\tbreak;\n\t\tif (idev->cnf.ndisc_notify ||\n\t\t    net->ipv6.devconf_all->ndisc_notify)\n\t\t\tndisc_send_unsol_na(dev);\n\t\tin6_dev_put(idev);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tidev = in6_dev_get(dev);\n\t\tif (!idev)\n\t\t\tevict_nocarrier = true;\n\t\telse {\n\t\t\tevict_nocarrier = idev->cnf.ndisc_evict_nocarrier &&\n\t\t\t\t\t  net->ipv6.devconf_all->ndisc_evict_nocarrier;\n\t\t\tin6_dev_put(idev);\n\t\t}\n\n\t\tchange_info = ptr;\n\t\tif (change_info->flags_changed & IFF_NOARP)\n\t\t\tneigh_changeaddr(&nd_tbl, dev);\n\t\tif (evict_nocarrier && !netif_carrier_ok(dev))\n\t\t\tneigh_carrier_down(&nd_tbl, dev);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tneigh_ifdown(&nd_tbl, dev);\n\t\tfib6_run_gc(0, net, false);\n\t\tbreak;\n\tcase NETDEV_NOTIFY_PEERS:\n\t\tndisc_send_unsol_na(dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block ndisc_netdev_notifier = {\n\t.notifier_call = ndisc_netdev_event,\n\t.priority = ADDRCONF_NOTIFY_PRIORITY - 5,\n};\n\n#ifdef CONFIG_SYSCTL\nstatic void ndisc_warn_deprecated_sysctl(struct ctl_table *ctl,\n\t\t\t\t\t const char *func, const char *dev_name)\n{\n\tstatic char warncomm[TASK_COMM_LEN];\n\tstatic int warned;\n\tif (strcmp(warncomm, current->comm) && warned < 5) {\n\t\tstrcpy(warncomm, current->comm);\n\t\tpr_warn(\"process `%s' is using deprecated sysctl (%s) net.ipv6.neigh.%s.%s - use net.ipv6.neigh.%s.%s_ms instead\\n\",\n\t\t\twarncomm, func,\n\t\t\tdev_name, ctl->procname,\n\t\t\tdev_name, ctl->procname);\n\t\twarned++;\n\t}\n}\n\nint ndisc_ifinfo_sysctl_change(struct ctl_table *ctl, int write, void *buffer,\n\t\tsize_t *lenp, loff_t *ppos)\n{\n\tstruct net_device *dev = ctl->extra1;\n\tstruct inet6_dev *idev;\n\tint ret;\n\n\tif ((strcmp(ctl->procname, \"retrans_time\") == 0) ||\n\t    (strcmp(ctl->procname, \"base_reachable_time\") == 0))\n\t\tndisc_warn_deprecated_sysctl(ctl, \"syscall\", dev ? dev->name : \"default\");\n\n\tif (strcmp(ctl->procname, \"retrans_time\") == 0)\n\t\tret = neigh_proc_dointvec(ctl, write, buffer, lenp, ppos);\n\n\telse if (strcmp(ctl->procname, \"base_reachable_time\") == 0)\n\t\tret = neigh_proc_dointvec_jiffies(ctl, write,\n\t\t\t\t\t\t  buffer, lenp, ppos);\n\n\telse if ((strcmp(ctl->procname, \"retrans_time_ms\") == 0) ||\n\t\t (strcmp(ctl->procname, \"base_reachable_time_ms\") == 0))\n\t\tret = neigh_proc_dointvec_ms_jiffies(ctl, write,\n\t\t\t\t\t\t     buffer, lenp, ppos);\n\telse\n\t\tret = -1;\n\n\tif (write && ret == 0 && dev && (idev = in6_dev_get(dev)) != NULL) {\n\t\tif (ctl->data == &NEIGH_VAR(idev->nd_parms, BASE_REACHABLE_TIME))\n\t\t\tidev->nd_parms->reachable_time =\n\t\t\t\t\tneigh_rand_reach_time(NEIGH_VAR(idev->nd_parms, BASE_REACHABLE_TIME));\n\t\tidev->tstamp = jiffies;\n\t\tinet6_ifinfo_notify(RTM_NEWLINK, idev);\n\t\tin6_dev_put(idev);\n\t}\n\treturn ret;\n}\n\n\n#endif\n\nstatic int __net_init ndisc_net_init(struct net *net)\n{\n\tstruct ipv6_pinfo *np;\n\tstruct sock *sk;\n\tint err;\n\n\terr = inet_ctl_sock_create(&sk, PF_INET6,\n\t\t\t\t   SOCK_RAW, IPPROTO_ICMPV6, net);\n\tif (err < 0) {\n\t\tND_PRINTK(0, err,\n\t\t\t  \"NDISC: Failed to initialize the control socket (err %d)\\n\",\n\t\t\t  err);\n\t\treturn err;\n\t}\n\n\tnet->ipv6.ndisc_sk = sk;\n\n\tnp = inet6_sk(sk);\n\tnp->hop_limit = 255;\n\t \n\tnp->mc_loop = 0;\n\n\treturn 0;\n}\n\nstatic void __net_exit ndisc_net_exit(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->ipv6.ndisc_sk);\n}\n\nstatic struct pernet_operations ndisc_net_ops = {\n\t.init = ndisc_net_init,\n\t.exit = ndisc_net_exit,\n};\n\nint __init ndisc_init(void)\n{\n\tint err;\n\n\terr = register_pernet_subsys(&ndisc_net_ops);\n\tif (err)\n\t\treturn err;\n\t \n\tneigh_table_init(NEIGH_ND_TABLE, &nd_tbl);\n\n#ifdef CONFIG_SYSCTL\n\terr = neigh_sysctl_register(NULL, &nd_tbl.parms,\n\t\t\t\t    ndisc_ifinfo_sysctl_change);\n\tif (err)\n\t\tgoto out_unregister_pernet;\nout:\n#endif\n\treturn err;\n\n#ifdef CONFIG_SYSCTL\nout_unregister_pernet:\n\tunregister_pernet_subsys(&ndisc_net_ops);\n\tgoto out;\n#endif\n}\n\nint __init ndisc_late_init(void)\n{\n\treturn register_netdevice_notifier(&ndisc_netdev_notifier);\n}\n\nvoid ndisc_late_cleanup(void)\n{\n\tunregister_netdevice_notifier(&ndisc_netdev_notifier);\n}\n\nvoid ndisc_cleanup(void)\n{\n#ifdef CONFIG_SYSCTL\n\tneigh_sysctl_unregister(&nd_tbl.parms);\n#endif\n\tneigh_table_clear(NEIGH_ND_TABLE, &nd_tbl);\n\tunregister_pernet_subsys(&ndisc_net_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}