{
  "module_name": "syncookies.c",
  "hash_id": "2d578ba8559191330e818d0074023284f50b8658192946210715908906694f8f",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/syncookies.c",
  "human_readable_source": "\n \n\n#include <linux/tcp.h>\n#include <linux/random.h>\n#include <linux/siphash.h>\n#include <linux/kernel.h>\n#include <net/secure_seq.h>\n#include <net/ipv6.h>\n#include <net/tcp.h>\n\n#define COOKIEBITS 24\t \n#define COOKIEMASK (((__u32)1 << COOKIEBITS) - 1)\n\nstatic siphash_aligned_key_t syncookie6_secret[2];\n\n \nstatic __u16 const msstab[] = {\n\t1280 - 60,  \n\t1480 - 60,\n\t1500 - 60,\n\t9000 - 60,\n};\n\nstatic u32 cookie_hash(const struct in6_addr *saddr,\n\t\t       const struct in6_addr *daddr,\n\t\t       __be16 sport, __be16 dport, u32 count, int c)\n{\n\tconst struct {\n\t\tstruct in6_addr saddr;\n\t\tstruct in6_addr daddr;\n\t\tu32 count;\n\t\t__be16 sport;\n\t\t__be16 dport;\n\t} __aligned(SIPHASH_ALIGNMENT) combined = {\n\t\t.saddr = *saddr,\n\t\t.daddr = *daddr,\n\t\t.count = count,\n\t\t.sport = sport,\n\t\t.dport = dport\n\t};\n\n\tnet_get_random_once(syncookie6_secret, sizeof(syncookie6_secret));\n\treturn siphash(&combined, offsetofend(typeof(combined), dport),\n\t\t       &syncookie6_secret[c]);\n}\n\nstatic __u32 secure_tcp_syn_cookie(const struct in6_addr *saddr,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   __be16 sport, __be16 dport, __u32 sseq,\n\t\t\t\t   __u32 data)\n{\n\tu32 count = tcp_cookie_time();\n\treturn (cookie_hash(saddr, daddr, sport, dport, 0, 0) +\n\t\tsseq + (count << COOKIEBITS) +\n\t\t((cookie_hash(saddr, daddr, sport, dport, count, 1) + data)\n\t\t& COOKIEMASK));\n}\n\nstatic __u32 check_tcp_syn_cookie(__u32 cookie, const struct in6_addr *saddr,\n\t\t\t\t  const struct in6_addr *daddr, __be16 sport,\n\t\t\t\t  __be16 dport, __u32 sseq)\n{\n\t__u32 diff, count = tcp_cookie_time();\n\n\tcookie -= cookie_hash(saddr, daddr, sport, dport, 0, 0) + sseq;\n\n\tdiff = (count - (cookie >> COOKIEBITS)) & ((__u32) -1 >> COOKIEBITS);\n\tif (diff >= MAX_SYNCOOKIE_AGE)\n\t\treturn (__u32)-1;\n\n\treturn (cookie -\n\t\tcookie_hash(saddr, daddr, sport, dport, count - diff, 1))\n\t\t& COOKIEMASK;\n}\n\nu32 __cookie_v6_init_sequence(const struct ipv6hdr *iph,\n\t\t\t      const struct tcphdr *th, __u16 *mssp)\n{\n\tint mssind;\n\tconst __u16 mss = *mssp;\n\n\tfor (mssind = ARRAY_SIZE(msstab) - 1; mssind ; mssind--)\n\t\tif (mss >= msstab[mssind])\n\t\t\tbreak;\n\n\t*mssp = msstab[mssind];\n\n\treturn secure_tcp_syn_cookie(&iph->saddr, &iph->daddr, th->source,\n\t\t\t\t     th->dest, ntohl(th->seq), mssind);\n}\nEXPORT_SYMBOL_GPL(__cookie_v6_init_sequence);\n\n__u32 cookie_v6_init_sequence(const struct sk_buff *skb, __u16 *mssp)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\treturn __cookie_v6_init_sequence(iph, th, mssp);\n}\n\nint __cookie_v6_check(const struct ipv6hdr *iph, const struct tcphdr *th,\n\t\t      __u32 cookie)\n{\n\t__u32 seq = ntohl(th->seq) - 1;\n\t__u32 mssind = check_tcp_syn_cookie(cookie, &iph->saddr, &iph->daddr,\n\t\t\t\t\t    th->source, th->dest, seq);\n\n\treturn mssind < ARRAY_SIZE(msstab) ? msstab[mssind] : 0;\n}\nEXPORT_SYMBOL_GPL(__cookie_v6_check);\n\nstruct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcp_options_received tcp_opt;\n\tstruct inet_request_sock *ireq;\n\tstruct tcp_request_sock *treq;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\t__u32 cookie = ntohl(th->ack_seq) - 1;\n\tstruct sock *ret = sk;\n\tstruct request_sock *req;\n\tint full_space, mss;\n\tstruct dst_entry *dst;\n\t__u8 rcv_wscale;\n\tu32 tsoff = 0;\n\n\tif (!READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_syncookies) ||\n\t    !th->ack || th->rst)\n\t\tgoto out;\n\n\tif (tcp_synq_no_recent_overflow(sk))\n\t\tgoto out;\n\n\tmss = __cookie_v6_check(ipv6_hdr(skb), th, cookie);\n\tif (mss == 0) {\n\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESFAILED);\n\t\tgoto out;\n\t}\n\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_SYNCOOKIESRECV);\n\n\t \n\tmemset(&tcp_opt, 0, sizeof(tcp_opt));\n\ttcp_parse_options(sock_net(sk), skb, &tcp_opt, 0, NULL);\n\n\tif (tcp_opt.saw_tstamp && tcp_opt.rcv_tsecr) {\n\t\ttsoff = secure_tcpv6_ts_off(sock_net(sk),\n\t\t\t\t\t    ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t    ipv6_hdr(skb)->saddr.s6_addr32);\n\t\ttcp_opt.rcv_tsecr -= tsoff;\n\t}\n\n\tif (!cookie_timestamp_decode(sock_net(sk), &tcp_opt))\n\t\tgoto out;\n\n\tret = NULL;\n\treq = cookie_tcp_reqsk_alloc(&tcp6_request_sock_ops,\n\t\t\t\t     &tcp_request_sock_ipv6_ops, sk, skb);\n\tif (!req)\n\t\tgoto out;\n\n\tireq = inet_rsk(req);\n\ttreq = tcp_rsk(req);\n\ttreq->tfo_listener = false;\n\n\treq->mss = mss;\n\tireq->ir_rmt_port = th->source;\n\tireq->ir_num = ntohs(th->dest);\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\tgoto out_free;\n\n\tif (ipv6_opt_accepted(sk, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t    np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||\n\t    np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {\n\t\trefcount_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n\n\tireq->ir_iif = inet_request_bound_dev_if(sk, skb);\n\t \n\tif (!sk->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tireq->ir_mark = inet_request_mark(sk, skb);\n\n\treq->num_retrans = 0;\n\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\ttreq->snt_synack\t= 0;\n\ttreq->rcv_isn = ntohl(th->seq) - 1;\n\ttreq->snt_isn = cookie;\n\ttreq->ts_off = 0;\n\ttreq->txhash = net_tx_rndhash();\n\tif (IS_ENABLED(CONFIG_SMC))\n\t\tireq->smc_ok = 0;\n\n\t \n\t{\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_TCP;\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n\t\tfl6.saddr = ireq->ir_v6_loc_addr;\n\t\tfl6.flowi6_oif = ireq->ir_iif;\n\t\tfl6.flowi6_mark = ireq->ir_mark;\n\t\tfl6.fl6_dport = ireq->ir_rmt_port;\n\t\tfl6.fl6_sport = inet_sk(sk)->inet_sport;\n\t\tfl6.flowi6_uid = sk->sk_uid;\n\t\tsecurity_req_classify_flow(req, flowi6_to_flowi_common(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sock_net(sk), sk, &fl6, final_p);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out_free;\n\t}\n\n\treq->rsk_window_clamp = tp->window_clamp ? :dst_metric(dst, RTAX_WINDOW);\n\t \n\tfull_space = tcp_full_space(sk);\n\tif (sk->sk_userlocks & SOCK_RCVBUF_LOCK &&\n\t    (req->rsk_window_clamp > full_space || req->rsk_window_clamp == 0))\n\t\treq->rsk_window_clamp = full_space;\n\n\ttcp_select_initial_window(sk, full_space, req->mss,\n\t\t\t\t  &req->rsk_rcv_wnd, &req->rsk_window_clamp,\n\t\t\t\t  ireq->wscale_ok, &rcv_wscale,\n\t\t\t\t  dst_metric(dst, RTAX_INITRWND));\n\n\tireq->rcv_wscale = rcv_wscale;\n\tireq->ecn_ok = cookie_ecn_ok(&tcp_opt, sock_net(sk), dst);\n\n\tret = tcp_get_cookie_sock(sk, skb, req, dst, tsoff);\nout:\n\treturn ret;\nout_free:\n\treqsk_free(req);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}