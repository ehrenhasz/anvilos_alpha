{
  "module_name": "inet6_hashtables.c",
  "hash_id": "d47cf144bd9b48b89652bf2f7219557be00e17d798de4107f97d5cca7241d4c7",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/inet6_hashtables.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/random.h>\n\n#include <net/addrconf.h>\n#include <net/inet_connection_sock.h>\n#include <net/inet_hashtables.h>\n#include <net/inet6_hashtables.h>\n#include <net/secure_seq.h>\n#include <net/ip.h>\n#include <net/sock_reuseport.h>\n\nu32 inet6_ehashfn(const struct net *net,\n\t\t  const struct in6_addr *laddr, const u16 lport,\n\t\t  const struct in6_addr *faddr, const __be16 fport)\n{\n\tstatic u32 inet6_ehash_secret __read_mostly;\n\tstatic u32 ipv6_hash_secret __read_mostly;\n\n\tu32 lhash, fhash;\n\n\tnet_get_random_once(&inet6_ehash_secret, sizeof(inet6_ehash_secret));\n\tnet_get_random_once(&ipv6_hash_secret, sizeof(ipv6_hash_secret));\n\n\tlhash = (__force u32)laddr->s6_addr32[3];\n\tfhash = __ipv6_addr_jhash(faddr, ipv6_hash_secret);\n\n\treturn __inet6_ehashfn(lhash, lport, fhash, fport,\n\t\t\t       inet6_ehash_secret + net_hash_mix(net));\n}\nEXPORT_SYMBOL_GPL(inet6_ehashfn);\n\n \nstruct sock *__inet6_lookup_established(struct net *net,\n\t\t\t\t\tstruct inet_hashinfo *hashinfo,\n\t\t\t\t\t   const struct in6_addr *saddr,\n\t\t\t\t\t   const __be16 sport,\n\t\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t\t   const u16 hnum,\n\t\t\t\t\t   const int dif, const int sdif)\n{\n\tstruct sock *sk;\n\tconst struct hlist_nulls_node *node;\n\tconst __portpair ports = INET_COMBINED_PORTS(sport, hnum);\n\t \n\tunsigned int hash = inet6_ehashfn(net, daddr, hnum, saddr, sport);\n\tunsigned int slot = hash & hashinfo->ehash_mask;\n\tstruct inet_ehash_bucket *head = &hashinfo->ehash[slot];\n\n\nbegin:\n\tsk_nulls_for_each_rcu(sk, node, &head->chain) {\n\t\tif (sk->sk_hash != hash)\n\t\t\tcontinue;\n\t\tif (!inet6_match(net, sk, saddr, daddr, ports, dif, sdif))\n\t\t\tcontinue;\n\t\tif (unlikely(!refcount_inc_not_zero(&sk->sk_refcnt)))\n\t\t\tgoto out;\n\n\t\tif (unlikely(!inet6_match(net, sk, saddr, daddr, ports, dif, sdif))) {\n\t\t\tsock_gen_put(sk);\n\t\t\tgoto begin;\n\t\t}\n\t\tgoto found;\n\t}\n\tif (get_nulls_value(node) != slot)\n\t\tgoto begin;\nout:\n\tsk = NULL;\nfound:\n\treturn sk;\n}\nEXPORT_SYMBOL(__inet6_lookup_established);\n\nstatic inline int compute_score(struct sock *sk, struct net *net,\n\t\t\t\tconst unsigned short hnum,\n\t\t\t\tconst struct in6_addr *daddr,\n\t\t\t\tconst int dif, const int sdif)\n{\n\tint score = -1;\n\n\tif (net_eq(sock_net(sk), net) && inet_sk(sk)->inet_num == hnum &&\n\t    sk->sk_family == PF_INET6) {\n\t\tif (!ipv6_addr_equal(&sk->sk_v6_rcv_saddr, daddr))\n\t\t\treturn -1;\n\n\t\tif (!inet_sk_bound_dev_eq(net, sk->sk_bound_dev_if, dif, sdif))\n\t\t\treturn -1;\n\n\t\tscore =  sk->sk_bound_dev_if ? 2 : 1;\n\t\tif (READ_ONCE(sk->sk_incoming_cpu) == raw_smp_processor_id())\n\t\t\tscore++;\n\t}\n\treturn score;\n}\n\n \nstruct sock *inet6_lookup_reuseport(struct net *net, struct sock *sk,\n\t\t\t\t    struct sk_buff *skb, int doff,\n\t\t\t\t    const struct in6_addr *saddr,\n\t\t\t\t    __be16 sport,\n\t\t\t\t    const struct in6_addr *daddr,\n\t\t\t\t    unsigned short hnum,\n\t\t\t\t    inet6_ehashfn_t *ehashfn)\n{\n\tstruct sock *reuse_sk = NULL;\n\tu32 phash;\n\n\tif (sk->sk_reuseport) {\n\t\tphash = INDIRECT_CALL_INET(ehashfn, udp6_ehashfn, inet6_ehashfn,\n\t\t\t\t\t   net, daddr, hnum, saddr, sport);\n\t\treuse_sk = reuseport_select_sock(sk, phash, skb, doff);\n\t}\n\treturn reuse_sk;\n}\nEXPORT_SYMBOL_GPL(inet6_lookup_reuseport);\n\n \nstatic struct sock *inet6_lhash2_lookup(struct net *net,\n\t\tstruct inet_listen_hashbucket *ilb2,\n\t\tstruct sk_buff *skb, int doff,\n\t\tconst struct in6_addr *saddr,\n\t\tconst __be16 sport, const struct in6_addr *daddr,\n\t\tconst unsigned short hnum, const int dif, const int sdif)\n{\n\tstruct sock *sk, *result = NULL;\n\tstruct hlist_nulls_node *node;\n\tint score, hiscore = 0;\n\n\tsk_nulls_for_each_rcu(sk, node, &ilb2->nulls_head) {\n\t\tscore = compute_score(sk, net, hnum, daddr, dif, sdif);\n\t\tif (score > hiscore) {\n\t\t\tresult = inet6_lookup_reuseport(net, sk, skb, doff,\n\t\t\t\t\t\t\tsaddr, sport, daddr, hnum, inet6_ehashfn);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\n\t\t\tresult = sk;\n\t\t\thiscore = score;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstruct sock *inet6_lookup_run_sk_lookup(struct net *net,\n\t\t\t\t\tint protocol,\n\t\t\t\t\tstruct sk_buff *skb, int doff,\n\t\t\t\t\tconst struct in6_addr *saddr,\n\t\t\t\t\tconst __be16 sport,\n\t\t\t\t\tconst struct in6_addr *daddr,\n\t\t\t\t\tconst u16 hnum, const int dif,\n\t\t\t\t\tinet6_ehashfn_t *ehashfn)\n{\n\tstruct sock *sk, *reuse_sk;\n\tbool no_reuseport;\n\n\tno_reuseport = bpf_sk_lookup_run_v6(net, protocol, saddr, sport,\n\t\t\t\t\t    daddr, hnum, dif, &sk);\n\tif (no_reuseport || IS_ERR_OR_NULL(sk))\n\t\treturn sk;\n\n\treuse_sk = inet6_lookup_reuseport(net, sk, skb, doff,\n\t\t\t\t\t  saddr, sport, daddr, hnum, ehashfn);\n\tif (reuse_sk)\n\t\tsk = reuse_sk;\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(inet6_lookup_run_sk_lookup);\n\nstruct sock *inet6_lookup_listener(struct net *net,\n\t\tstruct inet_hashinfo *hashinfo,\n\t\tstruct sk_buff *skb, int doff,\n\t\tconst struct in6_addr *saddr,\n\t\tconst __be16 sport, const struct in6_addr *daddr,\n\t\tconst unsigned short hnum, const int dif, const int sdif)\n{\n\tstruct inet_listen_hashbucket *ilb2;\n\tstruct sock *result = NULL;\n\tunsigned int hash2;\n\n\t \n\tif (static_branch_unlikely(&bpf_sk_lookup_enabled) &&\n\t    hashinfo == net->ipv4.tcp_death_row.hashinfo) {\n\t\tresult = inet6_lookup_run_sk_lookup(net, IPPROTO_TCP, skb, doff,\n\t\t\t\t\t\t    saddr, sport, daddr, hnum, dif,\n\t\t\t\t\t\t    inet6_ehashfn);\n\t\tif (result)\n\t\t\tgoto done;\n\t}\n\n\thash2 = ipv6_portaddr_hash(net, daddr, hnum);\n\tilb2 = inet_lhash2_bucket(hashinfo, hash2);\n\n\tresult = inet6_lhash2_lookup(net, ilb2, skb, doff,\n\t\t\t\t     saddr, sport, daddr, hnum,\n\t\t\t\t     dif, sdif);\n\tif (result)\n\t\tgoto done;\n\n\t \n\thash2 = ipv6_portaddr_hash(net, &in6addr_any, hnum);\n\tilb2 = inet_lhash2_bucket(hashinfo, hash2);\n\n\tresult = inet6_lhash2_lookup(net, ilb2, skb, doff,\n\t\t\t\t     saddr, sport, &in6addr_any, hnum,\n\t\t\t\t     dif, sdif);\ndone:\n\tif (IS_ERR(result))\n\t\treturn NULL;\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(inet6_lookup_listener);\n\nstruct sock *inet6_lookup(struct net *net, struct inet_hashinfo *hashinfo,\n\t\t\t  struct sk_buff *skb, int doff,\n\t\t\t  const struct in6_addr *saddr, const __be16 sport,\n\t\t\t  const struct in6_addr *daddr, const __be16 dport,\n\t\t\t  const int dif)\n{\n\tstruct sock *sk;\n\tbool refcounted;\n\n\tsk = __inet6_lookup(net, hashinfo, skb, doff, saddr, sport, daddr,\n\t\t\t    ntohs(dport), dif, 0, &refcounted);\n\tif (sk && !refcounted && !refcount_inc_not_zero(&sk->sk_refcnt))\n\t\tsk = NULL;\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(inet6_lookup);\n\nstatic int __inet6_check_established(struct inet_timewait_death_row *death_row,\n\t\t\t\t     struct sock *sk, const __u16 lport,\n\t\t\t\t     struct inet_timewait_sock **twp)\n{\n\tstruct inet_hashinfo *hinfo = death_row->hashinfo;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tconst struct in6_addr *daddr = &sk->sk_v6_rcv_saddr;\n\tconst struct in6_addr *saddr = &sk->sk_v6_daddr;\n\tconst int dif = sk->sk_bound_dev_if;\n\tstruct net *net = sock_net(sk);\n\tconst int sdif = l3mdev_master_ifindex_by_index(net, dif);\n\tconst __portpair ports = INET_COMBINED_PORTS(inet->inet_dport, lport);\n\tconst unsigned int hash = inet6_ehashfn(net, daddr, lport, saddr,\n\t\t\t\t\t\tinet->inet_dport);\n\tstruct inet_ehash_bucket *head = inet_ehash_bucket(hinfo, hash);\n\tspinlock_t *lock = inet_ehash_lockp(hinfo, hash);\n\tstruct sock *sk2;\n\tconst struct hlist_nulls_node *node;\n\tstruct inet_timewait_sock *tw = NULL;\n\n\tspin_lock(lock);\n\n\tsk_nulls_for_each(sk2, node, &head->chain) {\n\t\tif (sk2->sk_hash != hash)\n\t\t\tcontinue;\n\n\t\tif (likely(inet6_match(net, sk2, saddr, daddr, ports,\n\t\t\t\t       dif, sdif))) {\n\t\t\tif (sk2->sk_state == TCP_TIME_WAIT) {\n\t\t\t\ttw = inet_twsk(sk2);\n\t\t\t\tif (twsk_unique(sk, sk2, twp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto not_unique;\n\t\t}\n\t}\n\n\t \n\tinet->inet_num = lport;\n\tinet->inet_sport = htons(lport);\n\tsk->sk_hash = hash;\n\tWARN_ON(!sk_unhashed(sk));\n\t__sk_nulls_add_node_rcu(sk, &head->chain);\n\tif (tw) {\n\t\tsk_nulls_del_node_init_rcu((struct sock *)tw);\n\t\t__NET_INC_STATS(net, LINUX_MIB_TIMEWAITRECYCLED);\n\t}\n\tspin_unlock(lock);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\n\tif (twp) {\n\t\t*twp = tw;\n\t} else if (tw) {\n\t\t \n\t\tinet_twsk_deschedule_put(tw);\n\t}\n\treturn 0;\n\nnot_unique:\n\tspin_unlock(lock);\n\treturn -EADDRNOTAVAIL;\n}\n\nstatic u64 inet6_sk_port_offset(const struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\n\treturn secure_ipv6_port_ephemeral(sk->sk_v6_rcv_saddr.s6_addr32,\n\t\t\t\t\t  sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t  inet->inet_dport);\n}\n\nint inet6_hash_connect(struct inet_timewait_death_row *death_row,\n\t\t       struct sock *sk)\n{\n\tu64 port_offset = 0;\n\n\tif (!inet_sk(sk)->inet_num)\n\t\tport_offset = inet6_sk_port_offset(sk);\n\treturn __inet_hash_connect(death_row, sk, port_offset,\n\t\t\t\t   __inet6_check_established);\n}\nEXPORT_SYMBOL_GPL(inet6_hash_connect);\n\nint inet6_hash(struct sock *sk)\n{\n\tint err = 0;\n\n\tif (sk->sk_state != TCP_CLOSE)\n\t\terr = __inet_hash(sk, NULL);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(inet6_hash);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}