{
  "module_name": "raw.c",
  "hash_id": "b79ae25b8f0a17440b3915238074a65764fb3d947009aae83021f82d16cf6f78",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/raw.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/icmpv6.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/skbuff.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <asm/ioctls.h>\n\n#include <net/net_namespace.h>\n#include <net/ip.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/ip6_route.h>\n#include <net/ip6_checksum.h>\n#include <net/addrconf.h>\n#include <net/transp_v6.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/tcp_states.h>\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n#include <net/mip6.h>\n#endif\n#include <linux/mroute6.h>\n\n#include <net/raw.h>\n#include <net/rawv6.h>\n#include <net/xfrm.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n\n#define\tICMPV6_HDRLEN\t4\t \n\nstruct raw_hashinfo raw_v6_hashinfo;\nEXPORT_SYMBOL_GPL(raw_v6_hashinfo);\n\nbool raw_v6_match(struct net *net, const struct sock *sk, unsigned short num,\n\t\t  const struct in6_addr *loc_addr,\n\t\t  const struct in6_addr *rmt_addr, int dif, int sdif)\n{\n\tif (inet_sk(sk)->inet_num != num ||\n\t    !net_eq(sock_net(sk), net) ||\n\t    (!ipv6_addr_any(&sk->sk_v6_daddr) &&\n\t     !ipv6_addr_equal(&sk->sk_v6_daddr, rmt_addr)) ||\n\t    !raw_sk_bound_dev_eq(net, sk->sk_bound_dev_if,\n\t\t\t\t dif, sdif))\n\t\treturn false;\n\n\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr) ||\n\t    ipv6_addr_equal(&sk->sk_v6_rcv_saddr, loc_addr) ||\n\t    (ipv6_addr_is_multicast(loc_addr) &&\n\t     inet6_mc_check(sk, loc_addr, rmt_addr)))\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(raw_v6_match);\n\n \nstatic int icmpv6_filter(const struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct icmp6hdr _hdr;\n\tconst struct icmp6hdr *hdr;\n\n\t \n\thdr = skb_header_pointer(skb, skb_transport_offset(skb),\n\t\t\t\t ICMPV6_HDRLEN, &_hdr);\n\tif (hdr) {\n\t\tconst __u32 *data = &raw6_sk(sk)->filter.data[0];\n\t\tunsigned int type = hdr->icmp6_type;\n\n\t\treturn (data[type >> 5] & (1U << (type & 31))) != 0;\n\t}\n\treturn 1;\n}\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\ntypedef int mh_filter_t(struct sock *sock, struct sk_buff *skb);\n\nstatic mh_filter_t __rcu *mh_filter __read_mostly;\n\nint rawv6_mh_filter_register(mh_filter_t filter)\n{\n\trcu_assign_pointer(mh_filter, filter);\n\treturn 0;\n}\nEXPORT_SYMBOL(rawv6_mh_filter_register);\n\nint rawv6_mh_filter_unregister(mh_filter_t filter)\n{\n\tRCU_INIT_POINTER(mh_filter, NULL);\n\tsynchronize_rcu();\n\treturn 0;\n}\nEXPORT_SYMBOL(rawv6_mh_filter_unregister);\n\n#endif\n\n \nstatic bool ipv6_raw_deliver(struct sk_buff *skb, int nexthdr)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct in6_addr *saddr;\n\tconst struct in6_addr *daddr;\n\tstruct hlist_head *hlist;\n\tstruct sock *sk;\n\tbool delivered = false;\n\t__u8 hash;\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = saddr + 1;\n\n\thash = raw_hashfunc(net, nexthdr);\n\thlist = &raw_v6_hashinfo.ht[hash];\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, hlist) {\n\t\tint filtered;\n\n\t\tif (!raw_v6_match(net, sk, nexthdr, daddr, saddr,\n\t\t\t\t  inet6_iif(skb), inet6_sdif(skb)))\n\t\t\tcontinue;\n\t\tdelivered = true;\n\t\tswitch (nexthdr) {\n\t\tcase IPPROTO_ICMPV6:\n\t\t\tfiltered = icmpv6_filter(sk, skb);\n\t\t\tbreak;\n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tcase IPPROTO_MH:\n\t\t{\n\t\t\t \n\t\t\tmh_filter_t *filter;\n\n\t\t\tfilter = rcu_dereference(mh_filter);\n\t\t\tfiltered = filter ? (*filter)(sk, skb) : 0;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tfiltered = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (filtered < 0)\n\t\t\tbreak;\n\t\tif (filtered == 0) {\n\t\t\tstruct sk_buff *clone = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t \n\t\t\tif (clone)\n\t\t\t\trawv6_rcv(sk, clone);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn delivered;\n}\n\nbool raw6_local_deliver(struct sk_buff *skb, int nexthdr)\n{\n\treturn ipv6_raw_deliver(skb, nexthdr);\n}\n\n \nstatic int rawv6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) uaddr;\n\t__be32 v4addr = 0;\n\tint addr_type;\n\tint err;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (addr->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&addr->sin6_addr);\n\n\t \n\tif (addr_type == IPV6_ADDR_MAPPED)\n\t\treturn -EADDRNOTAVAIL;\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_CLOSE)\n\t\tgoto out;\n\n\trcu_read_lock();\n\t \n\tif (addr_type != IPV6_ADDR_ANY) {\n\t\tstruct net_device *dev = NULL;\n\n\t\tif (__ipv6_addr_needs_scope_id(addr_type)) {\n\t\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t\t    addr->sin6_scope_id) {\n\t\t\t\t \n\t\t\t\tsk->sk_bound_dev_if = addr->sin6_scope_id;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!sk->sk_bound_dev_if)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (sk->sk_bound_dev_if) {\n\t\t\terr = -ENODEV;\n\t\t\tdev = dev_get_by_index_rcu(sock_net(sk),\n\t\t\t\t\t\t   sk->sk_bound_dev_if);\n\t\t\tif (!dev)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tv4addr = LOOPBACK4_IPV6;\n\t\tif (!(addr_type & IPV6_ADDR_MULTICAST) &&\n\t\t    !ipv6_can_nonlocal_bind(sock_net(sk), inet)) {\n\t\t\terr = -EADDRNOTAVAIL;\n\t\t\tif (!ipv6_chk_addr(sock_net(sk), &addr->sin6_addr,\n\t\t\t\t\t   dev, 0)) {\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tinet->inet_rcv_saddr = inet->inet_saddr = v4addr;\n\tsk->sk_v6_rcv_saddr = addr->sin6_addr;\n\tif (!(addr_type & IPV6_ADDR_MULTICAST))\n\t\tnp->saddr = addr->sin6_addr;\n\terr = 0;\nout_unlock:\n\trcu_read_unlock();\nout:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic void rawv6_err(struct sock *sk, struct sk_buff *skb,\n\t       struct inet6_skb_parm *opt,\n\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tint err;\n\tint harderr;\n\n\t \n\tif (!np->recverr && sk->sk_state != TCP_ESTABLISHED)\n\t\treturn;\n\n\tharderr = icmpv6_err_convert(type, code, &err);\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\tip6_sk_update_pmtu(skb, sk, info);\n\t\tharderr = (np->pmtudisc == IPV6_PMTUDISC_DO);\n\t}\n\tif (type == NDISC_REDIRECT) {\n\t\tip6_sk_redirect(skb, sk);\n\t\treturn;\n\t}\n\tif (np->recverr) {\n\t\tu8 *payload = skb->data;\n\t\tif (!inet_test_bit(HDRINCL, sk))\n\t\t\tpayload += offset;\n\t\tipv6_icmp_error(sk, skb, err, 0, ntohl(info), payload);\n\t}\n\n\tif (np->recverr || harderr) {\n\t\tsk->sk_err = err;\n\t\tsk_error_report(sk);\n\t}\n}\n\nvoid raw6_icmp_error(struct sk_buff *skb, int nexthdr,\n\t\tu8 type, u8 code, int inner_offset, __be32 info)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct hlist_head *hlist;\n\tstruct sock *sk;\n\tint hash;\n\n\thash = raw_hashfunc(net, nexthdr);\n\thlist = &raw_v6_hashinfo.ht[hash];\n\trcu_read_lock();\n\tsk_for_each_rcu(sk, hlist) {\n\t\t \n\t\tconst struct ipv6hdr *ip6h = (const struct ipv6hdr *)skb->data;\n\n\t\tif (!raw_v6_match(net, sk, nexthdr, &ip6h->saddr, &ip6h->daddr,\n\t\t\t\t  inet6_iif(skb), inet6_iif(skb)))\n\t\t\tcontinue;\n\t\trawv6_err(sk, skb, NULL, type, code, inner_offset, info);\n\t}\n\trcu_read_unlock();\n}\n\nstatic inline int rawv6_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tenum skb_drop_reason reason;\n\n\tif ((raw6_sk(sk)->checksum || rcu_access_pointer(sk->sk_filter)) &&\n\t    skb_checksum_complete(skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tkfree_skb_reason(skb, SKB_DROP_REASON_SKB_CSUM);\n\t\treturn NET_RX_DROP;\n\t}\n\n\t \n\tskb_dst_drop(skb);\n\tif (sock_queue_rcv_skb_reason(sk, skb, &reason) < 0) {\n\t\tkfree_skb_reason(skb, reason);\n\t\treturn NET_RX_DROP;\n\t}\n\n\treturn 0;\n}\n\n \nint rawv6_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tkfree_skb_reason(skb, SKB_DROP_REASON_XFRM_POLICY);\n\t\treturn NET_RX_DROP;\n\t}\n\tnf_reset_ct(skb);\n\n\tif (!rp->checksum)\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tskb_postpull_rcsum(skb, skb_network_header(skb),\n\t\t\t\t   skb_network_header_len(skb));\n\t\tif (!csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\n\t\t\t\t     &ipv6_hdr(skb)->daddr,\n\t\t\t\t     skb->len, inet->inet_num, skb->csum))\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\tif (!skb_csum_unnecessary(skb))\n\t\tskb->csum = ~csum_unfold(csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\n\t\t\t\t\t\t\t &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t\t skb->len,\n\t\t\t\t\t\t\t inet->inet_num, 0));\n\n\tif (inet_test_bit(HDRINCL, sk)) {\n\t\tif (skb_checksum_complete(skb)) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tkfree_skb_reason(skb, SKB_DROP_REASON_SKB_CSUM);\n\t\t\treturn NET_RX_DROP;\n\t\t}\n\t}\n\n\trawv6_rcv_skb(sk, skb);\n\treturn 0;\n}\n\n\n \n\nstatic int rawv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len, addr_len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len, addr_len);\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tcopied = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tif (skb_csum_unnecessary(skb)) {\n\t\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\t} else if (msg->msg_flags&MSG_TRUNC) {\n\t\tif (__skb_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\t} else {\n\t\terr = skb_copy_and_csum_datagram_msg(skb, 0, msg);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (err)\n\t\tgoto out_free;\n\n\t \n\tif (sin6) {\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  inet6_iif(skb));\n\t\t*addr_len = sizeof(*sin6);\n\t}\n\n\tsock_recv_cmsgs(msg, sk, skb);\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = skb->len;\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tskb_kill_datagram(sk, skb, flags);\n\n\t \n\terr = (flags&MSG_DONTWAIT) ? -EAGAIN : -EHOSTUNREACH;\n\tgoto out;\n}\n\nstatic int rawv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t     struct raw6_sock *rp)\n{\n\tstruct ipv6_txoptions *opt;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tint offset;\n\tint len;\n\tint total_len;\n\t__wsum tmp_csum;\n\t__sum16 csum;\n\n\tif (!rp->checksum)\n\t\tgoto send;\n\n\tskb = skb_peek(&sk->sk_write_queue);\n\tif (!skb)\n\t\tgoto out;\n\n\toffset = rp->offset;\n\ttotal_len = inet_sk(sk)->cork.base.length;\n\topt = inet6_sk(sk)->cork.opt;\n\ttotal_len -= opt ? opt->opt_flen : 0;\n\n\tif (offset >= total_len - 1) {\n\t\terr = -EINVAL;\n\t\tip6_flush_pending_frames(sk);\n\t\tgoto out;\n\t}\n\n\t \n\tif (skb_queue_len(&sk->sk_write_queue) == 1) {\n\t\t \n\t\ttmp_csum = skb->csum;\n\t} else {\n\t\tstruct sk_buff *csum_skb = NULL;\n\t\ttmp_csum = 0;\n\n\t\tskb_queue_walk(&sk->sk_write_queue, skb) {\n\t\t\ttmp_csum = csum_add(tmp_csum, skb->csum);\n\n\t\t\tif (csum_skb)\n\t\t\t\tcontinue;\n\n\t\t\tlen = skb->len - skb_transport_offset(skb);\n\t\t\tif (offset >= len) {\n\t\t\t\toffset -= len;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcsum_skb = skb;\n\t\t}\n\n\t\tskb = csum_skb;\n\t}\n\n\toffset += skb_transport_offset(skb);\n\terr = skb_copy_bits(skb, offset, &csum, 2);\n\tif (err < 0) {\n\t\tip6_flush_pending_frames(sk);\n\t\tgoto out;\n\t}\n\n\t \n\tif (unlikely(csum))\n\t\ttmp_csum = csum_sub(tmp_csum, csum_unfold(csum));\n\n\tcsum = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t       total_len, fl6->flowi6_proto, tmp_csum);\n\n\tif (csum == 0 && fl6->flowi6_proto == IPPROTO_UDP)\n\t\tcsum = CSUM_MANGLED_0;\n\n\tBUG_ON(skb_store_bits(skb, offset, &csum, 2));\n\nsend:\n\terr = ip6_push_pending_frames(sk);\nout:\n\treturn err;\n}\n\nstatic int rawv6_send_hdrinc(struct sock *sk, struct msghdr *msg, int length,\n\t\t\tstruct flowi6 *fl6, struct dst_entry **dstp,\n\t\t\tunsigned int flags, const struct sockcm_cookie *sockc)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6hdr *iph;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct rt6_info *rt = (struct rt6_info *)*dstp;\n\tint hlen = LL_RESERVED_SPACE(rt->dst.dev);\n\tint tlen = rt->dst.dev->needed_tailroom;\n\n\tif (length > rt->dst.dev->mtu) {\n\t\tipv6_local_error(sk, EMSGSIZE, fl6, rt->dst.dev->mtu);\n\t\treturn -EMSGSIZE;\n\t}\n\tif (length < sizeof(struct ipv6hdr))\n\t\treturn -EINVAL;\n\tif (flags&MSG_PROBE)\n\t\tgoto out;\n\n\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t  length + hlen + tlen + 15,\n\t\t\t\t  flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto error;\n\tskb_reserve(skb, hlen);\n\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->priority = READ_ONCE(sk->sk_priority);\n\tskb->mark = sockc->mark;\n\tskb->tstamp = sockc->transmit_time;\n\n\tskb_put(skb, length);\n\tskb_reset_network_header(skb);\n\tiph = ipv6_hdr(skb);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb_setup_tx_timestamp(skb, sockc->tsflags);\n\n\tif (flags & MSG_CONFIRM)\n\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\tskb->transport_header = skb->network_header;\n\terr = memcpy_from_msg(iph, msg, length);\n\tif (err) {\n\t\terr = -EFAULT;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tskb_dst_set(skb, &rt->dst);\n\t*dstp = NULL;\n\n\t \n\tskb = l3mdev_ip6_out(sk, skb);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\t \n\trcu_read_lock();\n\tIP6_UPD_PO_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUT, skb->len);\n\terr = NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_OUT, net, sk, skb,\n\t\t      NULL, rt->dst.dev, dst_output);\n\tif (err > 0)\n\t\terr = net_xmit_errno(err);\n\tif (err) {\n\t\tIP6_INC_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\t\trcu_read_unlock();\n\t\tgoto error_check;\n\t}\n\trcu_read_unlock();\nout:\n\treturn 0;\n\nerror:\n\tIP6_INC_STATS(net, rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\nerror_check:\n\tif (err == -ENOBUFS && !np->recverr)\n\t\terr = 0;\n\treturn err;\n}\n\nstruct raw6_frag_vec {\n\tstruct msghdr *msg;\n\tint hlen;\n\tchar c[4];\n};\n\nstatic int rawv6_probe_proto_opt(struct raw6_frag_vec *rfv, struct flowi6 *fl6)\n{\n\tint err = 0;\n\tswitch (fl6->flowi6_proto) {\n\tcase IPPROTO_ICMPV6:\n\t\trfv->hlen = 2;\n\t\terr = memcpy_from_msg(rfv->c, rfv->msg, rfv->hlen);\n\t\tif (!err) {\n\t\t\tfl6->fl6_icmp_type = rfv->c[0];\n\t\t\tfl6->fl6_icmp_code = rfv->c[1];\n\t\t}\n\t\tbreak;\n\tcase IPPROTO_MH:\n\t\trfv->hlen = 4;\n\t\terr = memcpy_from_msg(rfv->c, rfv->msg, rfv->hlen);\n\t\tif (!err)\n\t\t\tfl6->fl6_mh_type = rfv->c[2];\n\t}\n\treturn err;\n}\n\nstatic int raw6_getfrag(void *from, char *to, int offset, int len, int odd,\n\t\t       struct sk_buff *skb)\n{\n\tstruct raw6_frag_vec *rfv = from;\n\n\tif (offset < rfv->hlen) {\n\t\tint copy = min(rfv->hlen - offset, len);\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\tmemcpy(to, rfv->c + offset, copy);\n\t\telse\n\t\t\tskb->csum = csum_block_add(\n\t\t\t\tskb->csum,\n\t\t\t\tcsum_partial_copy_nocheck(rfv->c + offset,\n\t\t\t\t\t\t\t  to, copy),\n\t\t\t\todd);\n\n\t\todd = 0;\n\t\toffset += copy;\n\t\tto += copy;\n\t\tlen -= copy;\n\n\t\tif (!len)\n\t\t\treturn 0;\n\t}\n\n\toffset -= rfv->hlen;\n\n\treturn ip_generic_getfrag(rfv->msg, to, offset, len, odd, skb);\n}\n\nstatic int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions *opt_to_free = NULL;\n\tstruct ipv6_txoptions opt_space;\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct dst_entry *dst = NULL;\n\tstruct raw6_frag_vec rfv;\n\tstruct flowi6 fl6;\n\tstruct ipcm6_cookie ipc6;\n\tint addr_len = msg->msg_namelen;\n\tint hdrincl;\n\tu16 proto;\n\tint err;\n\n\t \n\tif (len > INT_MAX)\n\t\treturn -EMSGSIZE;\n\n\t \n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\thdrincl = inet_test_bit(HDRINCL, sk);\n\n\t \n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tfl6.flowi6_mark = READ_ONCE(sk->sk_mark);\n\tfl6.flowi6_uid = sk->sk_uid;\n\n\tipcm6_init(&ipc6);\n\tipc6.sockc.tsflags = READ_ONCE(sk->sk_tsflags);\n\tipc6.sockc.mark = fl6.flowi6_mark;\n\n\tif (sin6) {\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\treturn -EINVAL;\n\n\t\tif (sin6->sin6_family && sin6->sin6_family != AF_INET6)\n\t\t\treturn -EAFNOSUPPORT;\n\n\t\t \n\t\tproto = ntohs(sin6->sin6_port);\n\n\t\tif (!proto)\n\t\t\tproto = inet->inet_num;\n\t\telse if (proto != inet->inet_num &&\n\t\t\t inet->inet_num != IPPROTO_RAW)\n\t\t\treturn -EINVAL;\n\n\t\tif (proto > 255)\n\t\t\treturn -EINVAL;\n\n\t\tdaddr = &sin6->sin6_addr;\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (IS_ERR(flowlabel))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    __ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))\n\t\t\tfl6.flowi6_oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tproto = inet->inet_num;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t}\n\n\tif (fl6.flowi6_oif == 0)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(struct ipv6_txoptions);\n\t\tipc6.opt = opt;\n\n\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, &ipc6);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (IS_ERR(flowlabel))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t}\n\tif (!opt) {\n\t\topt = txopt_get(np);\n\t\topt_to_free = opt;\n\t}\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = proto;\n\tfl6.flowi6_mark = ipc6.sockc.mark;\n\n\tif (!hdrincl) {\n\t\trfv.msg = msg;\n\t\trfv.hlen = 0;\n\t\terr = rawv6_probe_proto_opt(&rfv, &fl6);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1;  \n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6.saddr = np->saddr;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi_common(&fl6));\n\n\tif (hdrincl)\n\t\tfl6.flowi6_flags |= FLOWI_FLAG_KNOWN_NH;\n\n\tif (ipc6.tclass < 0)\n\t\tipc6.tclass = np->tclass;\n\n\tfl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);\n\n\tdst = ip6_dst_lookup_flow(sock_net(sk), sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto out;\n\t}\n\tif (ipc6.hlimit < 0)\n\t\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tif (ipc6.dontfrag < 0)\n\t\tipc6.dontfrag = np->dontfrag;\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\n\nback_from_confirm:\n\tif (hdrincl)\n\t\terr = rawv6_send_hdrinc(sk, msg, len, &fl6, &dst,\n\t\t\t\t\tmsg->msg_flags, &ipc6.sockc);\n\telse {\n\t\tipc6.opt = opt;\n\t\tlock_sock(sk);\n\t\terr = ip6_append_data(sk, raw6_getfrag, &rfv,\n\t\t\tlen, 0, &ipc6, &fl6, (struct rt6_info *)dst,\n\t\t\tmsg->msg_flags);\n\n\t\tif (err)\n\t\t\tip6_flush_pending_frames(sk);\n\t\telse if (!(msg->msg_flags & MSG_MORE))\n\t\t\terr = rawv6_push_pending_frames(sk, &fl6, rp);\n\t\trelease_sock(sk);\n\t}\ndone:\n\tdst_release(dst);\nout:\n\tfl6_sock_release(flowlabel);\n\ttxopt_put(opt_to_free);\n\treturn err < 0 ? err : len;\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(dst, &fl6.daddr);\n\tif (!(msg->msg_flags & MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto done;\n}\n\nstatic int rawv6_seticmpfilter(struct sock *sk, int level, int optname,\n\t\t\t       sockptr_t optval, int optlen)\n{\n\tswitch (optname) {\n\tcase ICMPV6_FILTER:\n\t\tif (optlen > sizeof(struct icmp6_filter))\n\t\t\toptlen = sizeof(struct icmp6_filter);\n\t\tif (copy_from_sockptr(&raw6_sk(sk)->filter, optval, optlen))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\treturn 0;\n}\n\nstatic int rawv6_geticmpfilter(struct sock *sk, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tint len;\n\n\tswitch (optname) {\n\tcase ICMPV6_FILTER:\n\t\tif (get_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (len < 0)\n\t\t\treturn -EINVAL;\n\t\tif (len > sizeof(struct icmp6_filter))\n\t\t\tlen = sizeof(struct icmp6_filter);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &raw6_sk(sk)->filter, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int do_rawv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\tint val;\n\n\tif (optlen < sizeof(val))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase IPV6_HDRINCL:\n\t\tif (sk->sk_type != SOCK_RAW)\n\t\t\treturn -EINVAL;\n\t\tinet_assign_bit(HDRINCL, sk, val);\n\t\treturn 0;\n\tcase IPV6_CHECKSUM:\n\t\tif (inet_sk(sk)->inet_num == IPPROTO_ICMPV6 &&\n\t\t    level == IPPROTO_IPV6) {\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (val > 0 && (val&1))\n\t\t\treturn -EINVAL;\n\t\tif (val < 0) {\n\t\t\trp->checksum = 0;\n\t\t} else {\n\t\t\trp->checksum = 1;\n\t\t\trp->offset = val;\n\t\t}\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\nstatic int rawv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t    sockptr_t optval, unsigned int optlen)\n{\n\tswitch (level) {\n\tcase SOL_RAW:\n\t\tbreak;\n\n\tcase SOL_ICMPV6:\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn rawv6_seticmpfilter(sk, level, optname, optval, optlen);\n\tcase SOL_IPV6:\n\t\tif (optname == IPV6_CHECKSUM ||\n\t\t    optname == IPV6_HDRINCL)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn ipv6_setsockopt(sk, level, optname, optval, optlen);\n\t}\n\n\treturn do_rawv6_setsockopt(sk, level, optname, optval, optlen);\n}\n\nstatic int do_rawv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\tint val, len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase IPV6_HDRINCL:\n\t\tval = inet_test_bit(HDRINCL, sk);\n\t\tbreak;\n\tcase IPV6_CHECKSUM:\n\t\t \n\t\tif (rp->checksum == 0)\n\t\t\tval = -1;\n\t\telse\n\t\t\tval = rp->offset;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = min_t(unsigned int, sizeof(int), len);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int rawv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t  char __user *optval, int __user *optlen)\n{\n\tswitch (level) {\n\tcase SOL_RAW:\n\t\tbreak;\n\n\tcase SOL_ICMPV6:\n\t\tif (inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn rawv6_geticmpfilter(sk, level, optname, optval, optlen);\n\tcase SOL_IPV6:\n\t\tif (optname == IPV6_CHECKSUM ||\n\t\t    optname == IPV6_HDRINCL)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn ipv6_getsockopt(sk, level, optname, optval, optlen);\n\t}\n\n\treturn do_rawv6_getsockopt(sk, level, optname, optval, optlen);\n}\n\nstatic int rawv6_ioctl(struct sock *sk, int cmd, int *karg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ: {\n\t\t*karg = sk_wmem_alloc_get(sk);\n\t\treturn 0;\n\t}\n\tcase SIOCINQ: {\n\t\tstruct sk_buff *skb;\n\n\t\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\t*karg = skb->len;\n\t\telse\n\t\t\t*karg = 0;\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\treturn 0;\n\t}\n\n\tdefault:\n#ifdef CONFIG_IPV6_MROUTE\n\t\treturn ip6mr_ioctl(sk, cmd, karg);\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_rawv6_ioctl(struct sock *sk, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\tcase SIOCINQ:\n\t\treturn -ENOIOCTLCMD;\n\tdefault:\n#ifdef CONFIG_IPV6_MROUTE\n\t\treturn ip6mr_compat_ioctl(sk, cmd, compat_ptr(arg));\n#else\n\t\treturn -ENOIOCTLCMD;\n#endif\n\t}\n}\n#endif\n\nstatic void rawv6_close(struct sock *sk, long timeout)\n{\n\tif (inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\tip6_ra_control(sk, -1);\n\tip6mr_sk_done(sk);\n\tsk_common_release(sk);\n}\n\nstatic void raw6_destroy(struct sock *sk)\n{\n\tlock_sock(sk);\n\tip6_flush_pending_frames(sk);\n\trelease_sock(sk);\n}\n\nstatic int rawv6_init_sk(struct sock *sk)\n{\n\tstruct raw6_sock *rp = raw6_sk(sk);\n\n\tswitch (inet_sk(sk)->inet_num) {\n\tcase IPPROTO_ICMPV6:\n\t\trp->checksum = 1;\n\t\trp->offset   = 2;\n\t\tbreak;\n\tcase IPPROTO_MH:\n\t\trp->checksum = 1;\n\t\trp->offset   = 4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstruct proto rawv6_prot = {\n\t.name\t\t   = \"RAWv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = rawv6_close,\n\t.destroy\t   = raw6_destroy,\n\t.connect\t   = ip6_datagram_connect_v6_only,\n\t.disconnect\t   = __udp_disconnect,\n\t.ioctl\t\t   = rawv6_ioctl,\n\t.init\t\t   = rawv6_init_sk,\n\t.setsockopt\t   = rawv6_setsockopt,\n\t.getsockopt\t   = rawv6_getsockopt,\n\t.sendmsg\t   = rawv6_sendmsg,\n\t.recvmsg\t   = rawv6_recvmsg,\n\t.bind\t\t   = rawv6_bind,\n\t.backlog_rcv\t   = rawv6_rcv_skb,\n\t.hash\t\t   = raw_hash_sk,\n\t.unhash\t\t   = raw_unhash_sk,\n\t.obj_size\t   = sizeof(struct raw6_sock),\n\t.ipv6_pinfo_offset = offsetof(struct raw6_sock, inet6),\n\t.useroffset\t   = offsetof(struct raw6_sock, filter),\n\t.usersize\t   = sizeof_field(struct raw6_sock, filter),\n\t.h.raw_hash\t   = &raw_v6_hashinfo,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t   = compat_rawv6_ioctl,\n#endif\n\t.diag_destroy\t   = raw_abort,\n};\n\n#ifdef CONFIG_PROC_FS\nstatic int raw6_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, IPV6_SEQ_DGRAM_HEADER);\n\t} else {\n\t\tstruct sock *sp = v;\n\t\t__u16 srcp  = inet_sk(sp)->inet_num;\n\t\tip6_dgram_sock_seq_show(seq, v, srcp, 0,\n\t\t\t\t\traw_seq_private(seq)->bucket);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations raw6_seq_ops = {\n\t.start =\traw_seq_start,\n\t.next =\t\traw_seq_next,\n\t.stop =\t\traw_seq_stop,\n\t.show =\t\traw6_seq_show,\n};\n\nstatic int __net_init raw6_init_net(struct net *net)\n{\n\tif (!proc_create_net_data(\"raw6\", 0444, net->proc_net, &raw6_seq_ops,\n\t\t\tsizeof(struct raw_iter_state), &raw_v6_hashinfo))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __net_exit raw6_exit_net(struct net *net)\n{\n\tremove_proc_entry(\"raw6\", net->proc_net);\n}\n\nstatic struct pernet_operations raw6_net_ops = {\n\t.init = raw6_init_net,\n\t.exit = raw6_exit_net,\n};\n\nint __init raw6_proc_init(void)\n{\n\treturn register_pernet_subsys(&raw6_net_ops);\n}\n\nvoid raw6_proc_exit(void)\n{\n\tunregister_pernet_subsys(&raw6_net_ops);\n}\n#endif\t \n\n \nconst struct proto_ops inet6_sockraw_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = inet6_bind,\n\t.connect\t   = inet_dgram_connect,\t \n\t.socketpair\t   = sock_no_socketpair,\t \n\t.accept\t\t   = sock_no_accept,\t\t \n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = datagram_poll,\t\t \n\t.ioctl\t\t   = inet6_ioctl,\t\t \n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = sock_no_listen,\t\t \n\t.shutdown\t   = inet_shutdown,\t\t \n\t.setsockopt\t   = sock_common_setsockopt,\t \n\t.getsockopt\t   = sock_common_getsockopt,\t \n\t.sendmsg\t   = inet_sendmsg,\t\t \n\t.recvmsg\t   = sock_common_recvmsg,\t \n\t.mmap\t\t   = sock_no_mmap,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t   = inet6_compat_ioctl,\n#endif\n};\n\nstatic struct inet_protosw rawv6_protosw = {\n\t.type\t\t= SOCK_RAW,\n\t.protocol\t= IPPROTO_IP,\t \n\t.prot\t\t= &rawv6_prot,\n\t.ops\t\t= &inet6_sockraw_ops,\n\t.flags\t\t= INET_PROTOSW_REUSE,\n};\n\nint __init rawv6_init(void)\n{\n\treturn inet6_register_protosw(&rawv6_protosw);\n}\n\nvoid rawv6_exit(void)\n{\n\tinet6_unregister_protosw(&rawv6_protosw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}