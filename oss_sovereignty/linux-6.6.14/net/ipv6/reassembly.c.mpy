{
  "module_name": "reassembly.c",
  "hash_id": "93a25c567ac1235f2685b3f5080ada28f0ade77119c7ac9d7c4965303e55113c",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/reassembly.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/jiffies.h>\n#include <linux/net.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n#include <linux/jhash.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/rawv6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/ipv6_frag.h>\n#include <net/inet_ecn.h>\n\nstatic const char ip6_frag_cache_name[] = \"ip6-frags\";\n\nstatic u8 ip6_frag_ecn(const struct ipv6hdr *ipv6h)\n{\n\treturn 1 << (ipv6_get_dsfield(ipv6h) & INET_ECN_MASK);\n}\n\nstatic struct inet_frags ip6_frags;\n\nstatic int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *skb,\n\t\t\t  struct sk_buff *prev_tail, struct net_device *dev);\n\nstatic void ip6_frag_expire(struct timer_list *t)\n{\n\tstruct inet_frag_queue *frag = from_timer(frag, t, timer);\n\tstruct frag_queue *fq;\n\n\tfq = container_of(frag, struct frag_queue, q);\n\n\tip6frag_expire_frag_queue(fq->q.fqdir->net, fq);\n}\n\nstatic struct frag_queue *\nfq_find(struct net *net, __be32 id, const struct ipv6hdr *hdr, int iif)\n{\n\tstruct frag_v6_compare_key key = {\n\t\t.id = id,\n\t\t.saddr = hdr->saddr,\n\t\t.daddr = hdr->daddr,\n\t\t.user = IP6_DEFRAG_LOCAL_DELIVER,\n\t\t.iif = iif,\n\t};\n\tstruct inet_frag_queue *q;\n\n\tif (!(ipv6_addr_type(&hdr->daddr) & (IPV6_ADDR_MULTICAST |\n\t\t\t\t\t    IPV6_ADDR_LINKLOCAL)))\n\t\tkey.iif = 0;\n\n\tq = inet_frag_find(net->ipv6.fqdir, &key);\n\tif (!q)\n\t\treturn NULL;\n\n\treturn container_of(q, struct frag_queue, q);\n}\n\nstatic int ip6_frag_queue(struct frag_queue *fq, struct sk_buff *skb,\n\t\t\t  struct frag_hdr *fhdr, int nhoff,\n\t\t\t  u32 *prob_offset)\n{\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\tint offset, end, fragsize;\n\tstruct sk_buff *prev_tail;\n\tstruct net_device *dev;\n\tint err = -ENOENT;\n\tSKB_DR(reason);\n\tu8 ecn;\n\n\t \n\tif (fq->q.flags & INET_FRAG_COMPLETE) {\n\t\tSKB_DR_SET(reason, DUP_FRAG);\n\t\tgoto err;\n\t}\n\n\terr = -EINVAL;\n\toffset = ntohs(fhdr->frag_off) & ~0x7;\n\tend = offset + (ntohs(ipv6_hdr(skb)->payload_len) -\n\t\t\t((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\n\n\tif ((unsigned int)end > IPV6_MAXPLEN) {\n\t\t*prob_offset = (u8 *)&fhdr->frag_off - skb_network_header(skb);\n\t\t \n\t\treturn -1;\n\t}\n\n\tecn = ip6_frag_ecn(ipv6_hdr(skb));\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\tconst unsigned char *nh = skb_network_header(skb);\n\t\tskb->csum = csum_sub(skb->csum,\n\t\t\t\t     csum_partial(nh, (u8 *)(fhdr + 1) - nh,\n\t\t\t\t\t\t  0));\n\t}\n\n\t \n\tif (!(fhdr->frag_off & htons(IP6_MF))) {\n\t\t \n\t\tif (end < fq->q.len ||\n\t\t    ((fq->q.flags & INET_FRAG_LAST_IN) && end != fq->q.len))\n\t\t\tgoto discard_fq;\n\t\tfq->q.flags |= INET_FRAG_LAST_IN;\n\t\tfq->q.len = end;\n\t} else {\n\t\t \n\t\tif (end & 0x7) {\n\t\t\t \n\t\t\t*prob_offset = offsetof(struct ipv6hdr, payload_len);\n\t\t\treturn -1;\n\t\t}\n\t\tif (end > fq->q.len) {\n\t\t\t \n\t\t\tif (fq->q.flags & INET_FRAG_LAST_IN)\n\t\t\t\tgoto discard_fq;\n\t\t\tfq->q.len = end;\n\t\t}\n\t}\n\n\tif (end == offset)\n\t\tgoto discard_fq;\n\n\terr = -ENOMEM;\n\t \n\tif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data))\n\t\tgoto discard_fq;\n\n\terr = pskb_trim_rcsum(skb, end - offset);\n\tif (err)\n\t\tgoto discard_fq;\n\n\t \n\tdev = skb->dev;\n\t \n\tbarrier();\n\n\tprev_tail = fq->q.fragments_tail;\n\terr = inet_frag_queue_insert(&fq->q, skb, offset, end);\n\tif (err)\n\t\tgoto insert_error;\n\n\tif (dev)\n\t\tfq->iif = dev->ifindex;\n\n\tfq->q.stamp = skb->tstamp;\n\tfq->q.mono_delivery_time = skb->mono_delivery_time;\n\tfq->q.meat += skb->len;\n\tfq->ecn |= ecn;\n\tadd_frag_mem_limit(fq->q.fqdir, skb->truesize);\n\n\tfragsize = -skb_network_offset(skb) + skb->len;\n\tif (fragsize > fq->q.max_size)\n\t\tfq->q.max_size = fragsize;\n\n\t \n\tif (offset == 0) {\n\t\tfq->nhoffset = nhoff;\n\t\tfq->q.flags |= INET_FRAG_FIRST_IN;\n\t}\n\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len) {\n\t\tunsigned long orefdst = skb->_skb_refdst;\n\n\t\tskb->_skb_refdst = 0UL;\n\t\terr = ip6_frag_reasm(fq, skb, prev_tail, dev);\n\t\tskb->_skb_refdst = orefdst;\n\t\treturn err;\n\t}\n\n\tskb_dst_drop(skb);\n\treturn -EINPROGRESS;\n\ninsert_error:\n\tif (err == IPFRAG_DUP) {\n\t\tSKB_DR_SET(reason, DUP_FRAG);\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\terr = -EINVAL;\n\t__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\tIPSTATS_MIB_REASM_OVERLAPS);\ndiscard_fq:\n\tinet_frag_kill(&fq->q);\n\t__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\tIPSTATS_MIB_REASMFAILS);\nerr:\n\tkfree_skb_reason(skb, reason);\n\treturn err;\n}\n\n \nstatic int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *skb,\n\t\t\t  struct sk_buff *prev_tail, struct net_device *dev)\n{\n\tstruct net *net = fq->q.fqdir->net;\n\tunsigned int nhoff;\n\tvoid *reasm_data;\n\tint payload_len;\n\tu8 ecn;\n\n\tinet_frag_kill(&fq->q);\n\n\tecn = ip_frag_ecn_table[fq->ecn];\n\tif (unlikely(ecn == 0xff))\n\t\tgoto out_fail;\n\n\treasm_data = inet_frag_reasm_prepare(&fq->q, skb, prev_tail);\n\tif (!reasm_data)\n\t\tgoto out_oom;\n\n\tpayload_len = ((skb->data - skb_network_header(skb)) -\n\t\t       sizeof(struct ipv6hdr) + fq->q.len -\n\t\t       sizeof(struct frag_hdr));\n\tif (payload_len > IPV6_MAXPLEN)\n\t\tgoto out_oversize;\n\n\t \n\tnhoff = fq->nhoffset;\n\tskb_network_header(skb)[nhoff] = skb_transport_header(skb)[0];\n\tmemmove(skb->head + sizeof(struct frag_hdr), skb->head,\n\t\t(skb->data - skb->head) - sizeof(struct frag_hdr));\n\tif (skb_mac_header_was_set(skb))\n\t\tskb->mac_header += sizeof(struct frag_hdr);\n\tskb->network_header += sizeof(struct frag_hdr);\n\n\tskb_reset_transport_header(skb);\n\n\tinet_frag_reasm_finish(&fq->q, skb, reasm_data, true);\n\n\tskb->dev = dev;\n\tipv6_hdr(skb)->payload_len = htons(payload_len);\n\tipv6_change_dsfield(ipv6_hdr(skb), 0xff, ecn);\n\tIP6CB(skb)->nhoff = nhoff;\n\tIP6CB(skb)->flags |= IP6SKB_FRAGMENTED;\n\tIP6CB(skb)->frag_max_size = fq->q.max_size;\n\n\t \n\tskb_postpush_rcsum(skb, skb_network_header(skb),\n\t\t\t   skb_network_header_len(skb));\n\n\trcu_read_lock();\n\t__IP6_INC_STATS(net, __in6_dev_stats_get(dev, skb), IPSTATS_MIB_REASMOKS);\n\trcu_read_unlock();\n\tfq->q.rb_fragments = RB_ROOT;\n\tfq->q.fragments_tail = NULL;\n\tfq->q.last_run_head = NULL;\n\treturn 1;\n\nout_oversize:\n\tnet_dbg_ratelimited(\"ip6_frag_reasm: payload len = %d\\n\", payload_len);\n\tgoto out_fail;\nout_oom:\n\tnet_dbg_ratelimited(\"ip6_frag_reasm: no memory for reassembly\\n\");\nout_fail:\n\trcu_read_lock();\n\t__IP6_INC_STATS(net, __in6_dev_stats_get(dev, skb), IPSTATS_MIB_REASMFAILS);\n\trcu_read_unlock();\n\tinet_frag_kill(&fq->q);\n\treturn -1;\n}\n\nstatic int ipv6_frag_rcv(struct sk_buff *skb)\n{\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tconst struct ipv6hdr *hdr = ipv6_hdr(skb);\n\tstruct net *net = dev_net(skb_dst(skb)->dev);\n\tu8 nexthdr;\n\tint iif;\n\n\tif (IP6CB(skb)->flags & IP6SKB_FRAGMENTED)\n\t\tgoto fail_hdr;\n\n\t__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMREQDS);\n\n\t \n\tif (hdr->payload_len == 0)\n\t\tgoto fail_hdr;\n\n\tif (!pskb_may_pull(skb, (skb_transport_offset(skb) +\n\t\t\t\t sizeof(struct frag_hdr))))\n\t\tgoto fail_hdr;\n\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\n\tif (!(fhdr->frag_off & htons(IP6_OFFSET | IP6_MF))) {\n\t\t \n\t\tskb->transport_header += sizeof(struct frag_hdr);\n\t\t__IP6_INC_STATS(net,\n\t\t\t\tip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMOKS);\n\n\t\tIP6CB(skb)->nhoff = (u8 *)fhdr - skb_network_header(skb);\n\t\tIP6CB(skb)->flags |= IP6SKB_FRAGMENTED;\n\t\tIP6CB(skb)->frag_max_size = ntohs(hdr->payload_len) +\n\t\t\t\t\t    sizeof(struct ipv6hdr);\n\t\treturn 1;\n\t}\n\n\t \n\tnexthdr = hdr->nexthdr;\n\tif (ipv6frag_thdr_truncated(skb, skb_transport_offset(skb), &nexthdr)) {\n\t\t__IP6_INC_STATS(net, __in6_dev_get_safely(skb->dev),\n\t\t\t\tIPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_INCOMP, 0);\n\t\treturn -1;\n\t}\n\n\tiif = skb->dev ? skb->dev->ifindex : 0;\n\tfq = fq_find(net, fhdr->identification, hdr, iif);\n\tif (fq) {\n\t\tu32 prob_offset = 0;\n\t\tint ret;\n\n\t\tspin_lock(&fq->q.lock);\n\n\t\tfq->iif = iif;\n\t\tret = ip6_frag_queue(fq, skb, fhdr, IP6CB(skb)->nhoff,\n\t\t\t\t     &prob_offset);\n\n\t\tspin_unlock(&fq->q.lock);\n\t\tinet_frag_put(&fq->q);\n\t\tif (prob_offset) {\n\t\t\t__IP6_INC_STATS(net, __in6_dev_get_safely(skb->dev),\n\t\t\t\t\tIPSTATS_MIB_INHDRERRORS);\n\t\t\t \n\t\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD, prob_offset);\n\t\t}\n\t\treturn ret;\n\t}\n\n\t__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_REASMFAILS);\n\tkfree_skb(skb);\n\treturn -1;\n\nfail_hdr:\n\t__IP6_INC_STATS(net, __in6_dev_get_safely(skb->dev),\n\t\t\tIPSTATS_MIB_INHDRERRORS);\n\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD, skb_network_header_len(skb));\n\treturn -1;\n}\n\nstatic const struct inet6_protocol frag_protocol = {\n\t.handler\t=\tipv6_frag_rcv,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\n#ifdef CONFIG_SYSCTL\n\nstatic struct ctl_table ip6_frags_ns_ctl_table[] = {\n\t{\n\t\t.procname\t= \"ip6frag_high_thresh\",\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"ip6frag_low_thresh\",\n\t\t.maxlen\t\t= sizeof(unsigned long),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_doulongvec_minmax,\n\t},\n\t{\n\t\t.procname\t= \"ip6frag_time\",\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{ }\n};\n\n \nstatic int ip6_frags_secret_interval_unused;\nstatic struct ctl_table ip6_frags_ctl_table[] = {\n\t{\n\t\t.procname\t= \"ip6frag_secret_interval\",\n\t\t.data\t\t= &ip6_frags_secret_interval_unused,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{ }\n};\n\nstatic int __net_init ip6_frags_ns_sysctl_register(struct net *net)\n{\n\tstruct ctl_table *table;\n\tstruct ctl_table_header *hdr;\n\n\ttable = ip6_frags_ns_ctl_table;\n\tif (!net_eq(net, &init_net)) {\n\t\ttable = kmemdup(table, sizeof(ip6_frags_ns_ctl_table), GFP_KERNEL);\n\t\tif (!table)\n\t\t\tgoto err_alloc;\n\n\t}\n\ttable[0].data\t= &net->ipv6.fqdir->high_thresh;\n\ttable[0].extra1\t= &net->ipv6.fqdir->low_thresh;\n\ttable[1].data\t= &net->ipv6.fqdir->low_thresh;\n\ttable[1].extra2\t= &net->ipv6.fqdir->high_thresh;\n\ttable[2].data\t= &net->ipv6.fqdir->timeout;\n\n\thdr = register_net_sysctl_sz(net, \"net/ipv6\", table,\n\t\t\t\t     ARRAY_SIZE(ip6_frags_ns_ctl_table));\n\tif (!hdr)\n\t\tgoto err_reg;\n\n\tnet->ipv6.sysctl.frags_hdr = hdr;\n\treturn 0;\n\nerr_reg:\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\nerr_alloc:\n\treturn -ENOMEM;\n}\n\nstatic void __net_exit ip6_frags_ns_sysctl_unregister(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = net->ipv6.sysctl.frags_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(net->ipv6.sysctl.frags_hdr);\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\n}\n\nstatic struct ctl_table_header *ip6_ctl_header;\n\nstatic int ip6_frags_sysctl_register(void)\n{\n\tip6_ctl_header = register_net_sysctl(&init_net, \"net/ipv6\",\n\t\t\tip6_frags_ctl_table);\n\treturn ip6_ctl_header == NULL ? -ENOMEM : 0;\n}\n\nstatic void ip6_frags_sysctl_unregister(void)\n{\n\tunregister_net_sysctl_table(ip6_ctl_header);\n}\n#else\nstatic int ip6_frags_ns_sysctl_register(struct net *net)\n{\n\treturn 0;\n}\n\nstatic void ip6_frags_ns_sysctl_unregister(struct net *net)\n{\n}\n\nstatic int ip6_frags_sysctl_register(void)\n{\n\treturn 0;\n}\n\nstatic void ip6_frags_sysctl_unregister(void)\n{\n}\n#endif\n\nstatic int __net_init ipv6_frags_init_net(struct net *net)\n{\n\tint res;\n\n\tres = fqdir_init(&net->ipv6.fqdir, &ip6_frags, net);\n\tif (res < 0)\n\t\treturn res;\n\n\tnet->ipv6.fqdir->high_thresh = IPV6_FRAG_HIGH_THRESH;\n\tnet->ipv6.fqdir->low_thresh = IPV6_FRAG_LOW_THRESH;\n\tnet->ipv6.fqdir->timeout = IPV6_FRAG_TIMEOUT;\n\n\tres = ip6_frags_ns_sysctl_register(net);\n\tif (res < 0)\n\t\tfqdir_exit(net->ipv6.fqdir);\n\treturn res;\n}\n\nstatic void __net_exit ipv6_frags_pre_exit_net(struct net *net)\n{\n\tfqdir_pre_exit(net->ipv6.fqdir);\n}\n\nstatic void __net_exit ipv6_frags_exit_net(struct net *net)\n{\n\tip6_frags_ns_sysctl_unregister(net);\n\tfqdir_exit(net->ipv6.fqdir);\n}\n\nstatic struct pernet_operations ip6_frags_ops = {\n\t.init\t\t= ipv6_frags_init_net,\n\t.pre_exit\t= ipv6_frags_pre_exit_net,\n\t.exit\t\t= ipv6_frags_exit_net,\n};\n\nstatic const struct rhashtable_params ip6_rhash_params = {\n\t.head_offset\t\t= offsetof(struct inet_frag_queue, node),\n\t.hashfn\t\t\t= ip6frag_key_hashfn,\n\t.obj_hashfn\t\t= ip6frag_obj_hashfn,\n\t.obj_cmpfn\t\t= ip6frag_obj_cmpfn,\n\t.automatic_shrinking\t= true,\n};\n\nint __init ipv6_frag_init(void)\n{\n\tint ret;\n\n\tip6_frags.constructor = ip6frag_init;\n\tip6_frags.destructor = NULL;\n\tip6_frags.qsize = sizeof(struct frag_queue);\n\tip6_frags.frag_expire = ip6_frag_expire;\n\tip6_frags.frags_cache_name = ip6_frag_cache_name;\n\tip6_frags.rhash_params = ip6_rhash_params;\n\tret = inet_frags_init(&ip6_frags);\n\tif (ret)\n\t\tgoto out;\n\n\tret = inet6_add_protocol(&frag_protocol, IPPROTO_FRAGMENT);\n\tif (ret)\n\t\tgoto err_protocol;\n\n\tret = ip6_frags_sysctl_register();\n\tif (ret)\n\t\tgoto err_sysctl;\n\n\tret = register_pernet_subsys(&ip6_frags_ops);\n\tif (ret)\n\t\tgoto err_pernet;\n\nout:\n\treturn ret;\n\nerr_pernet:\n\tip6_frags_sysctl_unregister();\nerr_sysctl:\n\tinet6_del_protocol(&frag_protocol, IPPROTO_FRAGMENT);\nerr_protocol:\n\tinet_frags_fini(&ip6_frags);\n\tgoto out;\n}\n\nvoid ipv6_frag_exit(void)\n{\n\tip6_frags_sysctl_unregister();\n\tunregister_pernet_subsys(&ip6_frags_ops);\n\tinet6_del_protocol(&frag_protocol, IPPROTO_FRAGMENT);\n\tinet_frags_fini(&ip6_frags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}