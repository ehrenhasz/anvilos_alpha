{
  "module_name": "ip6_input.c",
  "hash_id": "147a132e1fdb75312dc53e5d7c1f775173c1eb3445d2025cf90f92f156cc11d8",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ip6_input.c",
  "human_readable_source": "\n \n \n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/icmpv6.h>\n#include <linux/mroute6.h>\n#include <linux/slab.h>\n#include <linux/indirect_call_wrapper.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n#include <net/udp.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/rawv6.h>\n#include <net/ndisc.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/xfrm.h>\n#include <net/inet_ecn.h>\n#include <net/dst_metadata.h>\n\nstatic void ip6_rcv_finish_core(struct net *net, struct sock *sk,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tif (READ_ONCE(net->ipv4.sysctl_ip_early_demux) &&\n\t    !skb_dst(skb) && !skb->sk) {\n\t\tswitch (ipv6_hdr(skb)->nexthdr) {\n\t\tcase IPPROTO_TCP:\n\t\t\tif (READ_ONCE(net->ipv4.sysctl_tcp_early_demux))\n\t\t\t\ttcp_v6_early_demux(skb);\n\t\t\tbreak;\n\t\tcase IPPROTO_UDP:\n\t\t\tif (READ_ONCE(net->ipv4.sysctl_udp_early_demux))\n\t\t\t\tudp_v6_early_demux(skb);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!skb_valid_dst(skb))\n\t\tip6_route_input(skb);\n}\n\nint ip6_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\t \n\tskb = l3mdev_ip6_rcv(skb);\n\tif (!skb)\n\t\treturn NET_RX_SUCCESS;\n\tip6_rcv_finish_core(net, sk, skb);\n\n\treturn dst_input(skb);\n}\n\nstatic void ip6_sublist_rcv_finish(struct list_head *head)\n{\n\tstruct sk_buff *skb, *next;\n\n\tlist_for_each_entry_safe(skb, next, head, list) {\n\t\tskb_list_del_init(skb);\n\t\tdst_input(skb);\n\t}\n}\n\nstatic bool ip6_can_use_hint(const struct sk_buff *skb,\n\t\t\t     const struct sk_buff *hint)\n{\n\treturn hint && !skb_dst(skb) &&\n\t       ipv6_addr_equal(&ipv6_hdr(hint)->daddr, &ipv6_hdr(skb)->daddr);\n}\n\nstatic struct sk_buff *ip6_extract_route_hint(const struct net *net,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tif (fib6_routes_require_src(net) || fib6_has_custom_rules(net) ||\n\t    IP6CB(skb)->flags & IP6SKB_MULTIPATH)\n\t\treturn NULL;\n\n\treturn skb;\n}\n\nstatic void ip6_list_rcv_finish(struct net *net, struct sock *sk,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct sk_buff *skb, *next, *hint = NULL;\n\tstruct dst_entry *curr_dst = NULL;\n\tstruct list_head sublist;\n\n\tINIT_LIST_HEAD(&sublist);\n\tlist_for_each_entry_safe(skb, next, head, list) {\n\t\tstruct dst_entry *dst;\n\n\t\tskb_list_del_init(skb);\n\t\t \n\t\tskb = l3mdev_ip6_rcv(skb);\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tif (ip6_can_use_hint(skb, hint))\n\t\t\tskb_dst_copy(skb, hint);\n\t\telse\n\t\t\tip6_rcv_finish_core(net, sk, skb);\n\t\tdst = skb_dst(skb);\n\t\tif (curr_dst != dst) {\n\t\t\thint = ip6_extract_route_hint(net, skb);\n\n\t\t\t \n\t\t\tif (!list_empty(&sublist))\n\t\t\t\tip6_sublist_rcv_finish(&sublist);\n\t\t\t \n\t\t\tINIT_LIST_HEAD(&sublist);\n\t\t\tcurr_dst = dst;\n\t\t}\n\t\tlist_add_tail(&skb->list, &sublist);\n\t}\n\t \n\tip6_sublist_rcv_finish(&sublist);\n}\n\nstatic struct sk_buff *ip6_rcv_core(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t    struct net *net)\n{\n\tenum skb_drop_reason reason;\n\tconst struct ipv6hdr *hdr;\n\tu32 pkt_len;\n\tstruct inet6_dev *idev;\n\n\tif (skb->pkt_type == PACKET_OTHERHOST) {\n\t\tdev_core_stats_rx_otherhost_dropped_inc(skb->dev);\n\t\tkfree_skb_reason(skb, SKB_DROP_REASON_OTHERHOST);\n\t\treturn NULL;\n\t}\n\n\trcu_read_lock();\n\n\tidev = __in6_dev_get(skb->dev);\n\n\t__IP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_IN, skb->len);\n\n\tSKB_DR_SET(reason, NOT_SPECIFIED);\n\tif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL ||\n\t    !idev || unlikely(idev->cnf.disable_ipv6)) {\n\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDISCARDS);\n\t\tif (idev && unlikely(idev->cnf.disable_ipv6))\n\t\t\tSKB_DR_SET(reason, IPV6DISABLED);\n\t\tgoto drop;\n\t}\n\n\tmemset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));\n\n\t \n\tIP6CB(skb)->iif = skb_valid_dst(skb) ? ip6_dst_idev(skb_dst(skb))->dev->ifindex : dev->ifindex;\n\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*hdr))))\n\t\tgoto err;\n\n\thdr = ipv6_hdr(skb);\n\n\tif (hdr->version != 6) {\n\t\tSKB_DR_SET(reason, UNHANDLED_PROTO);\n\t\tgoto err;\n\t}\n\n\t__IP6_ADD_STATS(net, idev,\n\t\t\tIPSTATS_MIB_NOECTPKTS +\n\t\t\t\t(ipv6_get_dsfield(hdr) & INET_ECN_MASK),\n\t\t\tmax_t(unsigned short, 1, skb_shinfo(skb)->gso_segs));\n\t \n\tif ((ipv6_addr_loopback(&hdr->saddr) ||\n\t     ipv6_addr_loopback(&hdr->daddr)) &&\n\t    !(dev->flags & IFF_LOOPBACK) &&\n\t    !netif_is_l3_master(dev))\n\t\tgoto err;\n\n\t \n\tif (!(skb->pkt_type == PACKET_LOOPBACK ||\n\t      dev->flags & IFF_LOOPBACK) &&\n\t    ipv6_addr_is_multicast(&hdr->daddr) &&\n\t    IPV6_ADDR_MC_SCOPE(&hdr->daddr) == 1)\n\t\tgoto err;\n\n\t \n\tif (!ipv6_addr_is_multicast(&hdr->daddr) &&\n\t    (skb->pkt_type == PACKET_BROADCAST ||\n\t     skb->pkt_type == PACKET_MULTICAST) &&\n\t    idev->cnf.drop_unicast_in_l2_multicast) {\n\t\tSKB_DR_SET(reason, UNICAST_IN_L2_MULTICAST);\n\t\tgoto err;\n\t}\n\n\t \n\tif (ipv6_addr_is_multicast(&hdr->daddr) &&\n\t    IPV6_ADDR_MC_SCOPE(&hdr->daddr) == 0)\n\t\tgoto err;\n\n\t \n\tif (ipv6_addr_is_multicast(&hdr->saddr))\n\t\tgoto err;\n\n\tskb->transport_header = skb->network_header + sizeof(*hdr);\n\tIP6CB(skb)->nhoff = offsetof(struct ipv6hdr, nexthdr);\n\n\tpkt_len = ntohs(hdr->payload_len);\n\n\t \n\tif (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {\n\t\tif (pkt_len + sizeof(struct ipv6hdr) > skb->len) {\n\t\t\t__IP6_INC_STATS(net,\n\t\t\t\t\tidev, IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\t\tSKB_DR_SET(reason, PKT_TOO_SMALL);\n\t\t\tgoto drop;\n\t\t}\n\t\tif (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))\n\t\t\tgoto err;\n\t\thdr = ipv6_hdr(skb);\n\t}\n\n\tif (hdr->nexthdr == NEXTHDR_HOP) {\n\t\tif (ipv6_parse_hopopts(skb) < 0) {\n\t\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\t \n\tif (!skb_sk_is_prefetched(skb))\n\t\tskb_orphan(skb);\n\n\treturn skb;\nerr:\n\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\tSKB_DR_OR(reason, IP_INHDR);\ndrop:\n\trcu_read_unlock();\n\tkfree_skb_reason(skb, reason);\n\treturn NULL;\n}\n\nint ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct net *net = dev_net(skb->dev);\n\n\tskb = ip6_rcv_core(skb, dev, net);\n\tif (skb == NULL)\n\t\treturn NET_RX_DROP;\n\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING,\n\t\t       net, NULL, skb, dev, NULL,\n\t\t       ip6_rcv_finish);\n}\n\nstatic void ip6_sublist_rcv(struct list_head *head, struct net_device *dev,\n\t\t\t    struct net *net)\n{\n\tNF_HOOK_LIST(NFPROTO_IPV6, NF_INET_PRE_ROUTING, net, NULL,\n\t\t     head, dev, NULL, ip6_rcv_finish);\n\tip6_list_rcv_finish(net, NULL, head);\n}\n\n \nvoid ipv6_list_rcv(struct list_head *head, struct packet_type *pt,\n\t\t   struct net_device *orig_dev)\n{\n\tstruct net_device *curr_dev = NULL;\n\tstruct net *curr_net = NULL;\n\tstruct sk_buff *skb, *next;\n\tstruct list_head sublist;\n\n\tINIT_LIST_HEAD(&sublist);\n\tlist_for_each_entry_safe(skb, next, head, list) {\n\t\tstruct net_device *dev = skb->dev;\n\t\tstruct net *net = dev_net(dev);\n\n\t\tskb_list_del_init(skb);\n\t\tskb = ip6_rcv_core(skb, dev, net);\n\t\tif (skb == NULL)\n\t\t\tcontinue;\n\n\t\tif (curr_dev != dev || curr_net != net) {\n\t\t\t \n\t\t\tif (!list_empty(&sublist))\n\t\t\t\tip6_sublist_rcv(&sublist, curr_dev, curr_net);\n\t\t\t \n\t\t\tINIT_LIST_HEAD(&sublist);\n\t\t\tcurr_dev = dev;\n\t\t\tcurr_net = net;\n\t\t}\n\t\tlist_add_tail(&skb->list, &sublist);\n\t}\n\t \n\tif (!list_empty(&sublist))\n\t\tip6_sublist_rcv(&sublist, curr_dev, curr_net);\n}\n\nINDIRECT_CALLABLE_DECLARE(int tcp_v6_rcv(struct sk_buff *));\n\n \nvoid ip6_protocol_deliver_rcu(struct net *net, struct sk_buff *skb, int nexthdr,\n\t\t\t      bool have_final)\n{\n\tconst struct inet6_protocol *ipprot;\n\tstruct inet6_dev *idev;\n\tunsigned int nhoff;\n\tSKB_DR(reason);\n\tbool raw;\n\n\t \n\nresubmit:\n\tidev = ip6_dst_idev(skb_dst(skb));\n\tnhoff = IP6CB(skb)->nhoff;\n\tif (!have_final) {\n\t\tif (!pskb_pull(skb, skb_transport_offset(skb)))\n\t\t\tgoto discard;\n\t\tnexthdr = skb_network_header(skb)[nhoff];\n\t}\n\nresubmit_final:\n\traw = raw6_local_deliver(skb, nexthdr);\n\tipprot = rcu_dereference(inet6_protos[nexthdr]);\n\tif (ipprot) {\n\t\tint ret;\n\n\t\tif (have_final) {\n\t\t\tif (!(ipprot->flags & INET6_PROTO_FINAL)) {\n\t\t\t\t \n\t\t\t\tgoto discard;\n\t\t\t}\n\t\t} else if (ipprot->flags & INET6_PROTO_FINAL) {\n\t\t\tconst struct ipv6hdr *hdr;\n\t\t\tint sdif = inet6_sdif(skb);\n\t\t\tstruct net_device *dev;\n\n\t\t\t \n\t\t\thave_final = true;\n\n\n\t\t\tskb_postpull_rcsum(skb, skb_network_header(skb),\n\t\t\t\t\t   skb_network_header_len(skb));\n\t\t\thdr = ipv6_hdr(skb);\n\n\t\t\t \n\t\t\tif (sdif) {\n\t\t\t\tdev = dev_get_by_index_rcu(net, sdif);\n\t\t\t\tif (!dev)\n\t\t\t\t\tgoto discard;\n\t\t\t} else {\n\t\t\t\tdev = skb->dev;\n\t\t\t}\n\n\t\t\tif (ipv6_addr_is_multicast(&hdr->daddr) &&\n\t\t\t    !ipv6_chk_mcast_addr(dev, &hdr->daddr,\n\t\t\t\t\t\t &hdr->saddr) &&\n\t\t\t    !ipv6_is_mld(skb, nexthdr, skb_network_header_len(skb))) {\n\t\t\t\tSKB_DR_SET(reason, IP_INADDRERRORS);\n\t\t\t\tgoto discard;\n\t\t\t}\n\t\t}\n\t\tif (!(ipprot->flags & INET6_PROTO_NOPOLICY)) {\n\t\t\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\t\t\tSKB_DR_SET(reason, XFRM_POLICY);\n\t\t\t\tgoto discard;\n\t\t\t}\n\t\t\tnf_reset_ct(skb);\n\t\t}\n\n\t\tret = INDIRECT_CALL_2(ipprot->handler, tcp_v6_rcv, udpv6_rcv,\n\t\t\t\t      skb);\n\t\tif (ret > 0) {\n\t\t\tif (ipprot->flags & INET6_PROTO_FINAL) {\n\t\t\t\t \n\t\t\t\tnexthdr = ret;\n\t\t\t\tgoto resubmit_final;\n\t\t\t} else {\n\t\t\t\tgoto resubmit;\n\t\t\t}\n\t\t} else if (ret == 0) {\n\t\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDELIVERS);\n\t\t}\n\t} else {\n\t\tif (!raw) {\n\t\t\tif (xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\t\t\t__IP6_INC_STATS(net, idev,\n\t\t\t\t\t\tIPSTATS_MIB_INUNKNOWNPROTOS);\n\t\t\t\ticmpv6_send(skb, ICMPV6_PARAMPROB,\n\t\t\t\t\t    ICMPV6_UNK_NEXTHDR, nhoff);\n\t\t\t\tSKB_DR_SET(reason, IP_NOPROTO);\n\t\t\t} else {\n\t\t\t\tSKB_DR_SET(reason, XFRM_POLICY);\n\t\t\t}\n\t\t\tkfree_skb_reason(skb, reason);\n\t\t} else {\n\t\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDELIVERS);\n\t\t\tconsume_skb(skb);\n\t\t}\n\t}\n\treturn;\n\ndiscard:\n\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INDISCARDS);\n\tkfree_skb_reason(skb, reason);\n}\n\nstatic int ip6_input_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tskb_clear_delivery_time(skb);\n\trcu_read_lock();\n\tip6_protocol_deliver_rcu(net, skb, 0, false);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\n\nint ip6_input(struct sk_buff *skb)\n{\n\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_IN,\n\t\t       dev_net(skb->dev), NULL, skb, skb->dev, NULL,\n\t\t       ip6_input_finish);\n}\nEXPORT_SYMBOL_GPL(ip6_input);\n\nint ip6_mc_input(struct sk_buff *skb)\n{\n\tint sdif = inet6_sdif(skb);\n\tconst struct ipv6hdr *hdr;\n\tstruct net_device *dev;\n\tbool deliver;\n\n\t__IP6_UPD_PO_STATS(dev_net(skb_dst(skb)->dev),\n\t\t\t __in6_dev_get_safely(skb->dev), IPSTATS_MIB_INMCAST,\n\t\t\t skb->len);\n\n\t \n\tif (sdif) {\n\t\trcu_read_lock();\n\t\tdev = dev_get_by_index_rcu(dev_net(skb->dev), sdif);\n\t\tif (!dev) {\n\t\t\trcu_read_unlock();\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tdev = skb->dev;\n\t}\n\n\thdr = ipv6_hdr(skb);\n\tdeliver = ipv6_chk_mcast_addr(dev, &hdr->daddr, NULL);\n\tif (sdif)\n\t\trcu_read_unlock();\n\n#ifdef CONFIG_IPV6_MROUTE\n\t \n\tif (atomic_read(&dev_net(skb->dev)->ipv6.devconf_all->mc_forwarding) &&\n\t    !(ipv6_addr_type(&hdr->daddr) &\n\t      (IPV6_ADDR_LOOPBACK|IPV6_ADDR_LINKLOCAL)) &&\n\t    likely(!(IP6CB(skb)->flags & IP6SKB_FORWARDED))) {\n\t\t \n\t\tstruct sk_buff *skb2;\n\t\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\n\t\t \n\t\tif (unlikely(opt->flags & IP6SKB_ROUTERALERT)) {\n\t\t\t \n\t\t\tu8 nexthdr = hdr->nexthdr;\n\t\t\t__be16 frag_off;\n\t\t\tint offset;\n\n\t\t\t \n\t\t\tif (opt->ra == htons(IPV6_OPT_ROUTERALERT_MLD)) {\n\t\t\t\tdeliver = false;\n\n\t\t\t\tif (!ipv6_ext_hdr(nexthdr)) {\n\t\t\t\t\t \n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\toffset = ipv6_skip_exthdr(skb, sizeof(*hdr),\n\t\t\t\t\t\t\t  &nexthdr, &frag_off);\n\t\t\t\tif (offset < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tif (ipv6_is_mld(skb, nexthdr, offset))\n\t\t\t\t\tdeliver = true;\n\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t \n\t\t}\n\n\t\tif (deliver)\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\telse {\n\t\t\tskb2 = skb;\n\t\t\tskb = NULL;\n\t\t}\n\n\t\tif (skb2) {\n\t\t\tip6_mr_input(skb2);\n\t\t}\n\t}\nout:\n#endif\n\tif (likely(deliver))\n\t\tip6_input(skb);\n\telse {\n\t\t \n\t\tkfree_skb(skb);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}