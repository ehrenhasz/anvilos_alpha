{
  "module_name": "ip6mr.c",
  "hash_id": "bf2f6d4a8dff79c5e54720f3325abee49118cb103288d81660cc234adc3d82de",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ip6mr.c",
  "human_readable_source": "\n \n\n#include <linux/uaccess.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/socket.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/compat.h>\n#include <linux/rhashtable.h>\n#include <net/protocol.h>\n#include <linux/skbuff.h>\n#include <net/raw.h>\n#include <linux/notifier.h>\n#include <linux/if_arp.h>\n#include <net/checksum.h>\n#include <net/netlink.h>\n#include <net/fib_rules.h>\n\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <linux/mroute6.h>\n#include <linux/pim.h>\n#include <net/addrconf.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/export.h>\n#include <net/ip6_checksum.h>\n#include <linux/netconf.h>\n#include <net/ip_tunnels.h>\n\n#include <linux/nospec.h>\n\nstruct ip6mr_rule {\n\tstruct fib_rule\t\tcommon;\n};\n\nstruct ip6mr_result {\n\tstruct mr_table\t*mrt;\n};\n\n \n\nstatic DEFINE_SPINLOCK(mrt_lock);\n\nstatic struct net_device *vif_dev_read(const struct vif_device *vif)\n{\n\treturn rcu_dereference(vif->dev);\n}\n\n \n\n \nstatic DEFINE_SPINLOCK(mfc_unres_lock);\n\n \n\nstatic struct kmem_cache *mrt_cachep __read_mostly;\n\nstatic struct mr_table *ip6mr_new_table(struct net *net, u32 id);\nstatic void ip6mr_free_table(struct mr_table *mrt);\n\nstatic void ip6_mr_forward(struct net *net, struct mr_table *mrt,\n\t\t\t   struct net_device *dev, struct sk_buff *skb,\n\t\t\t   struct mfc6_cache *cache);\nstatic int ip6mr_cache_report(const struct mr_table *mrt, struct sk_buff *pkt,\n\t\t\t      mifi_t mifi, int assert);\nstatic void mr6_netlink_event(struct mr_table *mrt, struct mfc6_cache *mfc,\n\t\t\t      int cmd);\nstatic void mrt6msg_netlink_event(const struct mr_table *mrt, struct sk_buff *pkt);\nstatic int ip6mr_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t      struct netlink_ext_ack *extack);\nstatic int ip6mr_rtm_dumproute(struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb);\nstatic void mroute_clean_tables(struct mr_table *mrt, int flags);\nstatic void ipmr_expire_process(struct timer_list *t);\n\n#ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES\n#define ip6mr_for_each_table(mrt, net) \\\n\tlist_for_each_entry_rcu(mrt, &net->ipv6.mr6_tables, list, \\\n\t\t\t\tlockdep_rtnl_is_held() || \\\n\t\t\t\tlist_empty(&net->ipv6.mr6_tables))\n\nstatic struct mr_table *ip6mr_mr_table_iter(struct net *net,\n\t\t\t\t\t    struct mr_table *mrt)\n{\n\tstruct mr_table *ret;\n\n\tif (!mrt)\n\t\tret = list_entry_rcu(net->ipv6.mr6_tables.next,\n\t\t\t\t     struct mr_table, list);\n\telse\n\t\tret = list_entry_rcu(mrt->list.next,\n\t\t\t\t     struct mr_table, list);\n\n\tif (&ret->list == &net->ipv6.mr6_tables)\n\t\treturn NULL;\n\treturn ret;\n}\n\nstatic struct mr_table *ip6mr_get_table(struct net *net, u32 id)\n{\n\tstruct mr_table *mrt;\n\n\tip6mr_for_each_table(mrt, net) {\n\t\tif (mrt->id == id)\n\t\t\treturn mrt;\n\t}\n\treturn NULL;\n}\n\nstatic int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,\n\t\t\t    struct mr_table **mrt)\n{\n\tint err;\n\tstruct ip6mr_result res;\n\tstruct fib_lookup_arg arg = {\n\t\t.result = &res,\n\t\t.flags = FIB_LOOKUP_NOREF,\n\t};\n\n\t \n\tl3mdev_update_flow(net, flowi6_to_flowi(flp6));\n\n\terr = fib_rules_lookup(net->ipv6.mr6_rules_ops,\n\t\t\t       flowi6_to_flowi(flp6), 0, &arg);\n\tif (err < 0)\n\t\treturn err;\n\t*mrt = res.mrt;\n\treturn 0;\n}\n\nstatic int ip6mr_rule_action(struct fib_rule *rule, struct flowi *flp,\n\t\t\t     int flags, struct fib_lookup_arg *arg)\n{\n\tstruct ip6mr_result *res = arg->result;\n\tstruct mr_table *mrt;\n\n\tswitch (rule->action) {\n\tcase FR_ACT_TO_TBL:\n\t\tbreak;\n\tcase FR_ACT_UNREACHABLE:\n\t\treturn -ENETUNREACH;\n\tcase FR_ACT_PROHIBIT:\n\t\treturn -EACCES;\n\tcase FR_ACT_BLACKHOLE:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\targ->table = fib_rule_get_table(rule, arg);\n\n\tmrt = ip6mr_get_table(rule->fr_net, arg->table);\n\tif (!mrt)\n\t\treturn -EAGAIN;\n\tres->mrt = mrt;\n\treturn 0;\n}\n\nstatic int ip6mr_rule_match(struct fib_rule *rule, struct flowi *flp, int flags)\n{\n\treturn 1;\n}\n\nstatic int ip6mr_rule_configure(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t\tstruct fib_rule_hdr *frh, struct nlattr **tb,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\treturn 0;\n}\n\nstatic int ip6mr_rule_compare(struct fib_rule *rule, struct fib_rule_hdr *frh,\n\t\t\t      struct nlattr **tb)\n{\n\treturn 1;\n}\n\nstatic int ip6mr_rule_fill(struct fib_rule *rule, struct sk_buff *skb,\n\t\t\t   struct fib_rule_hdr *frh)\n{\n\tfrh->dst_len = 0;\n\tfrh->src_len = 0;\n\tfrh->tos     = 0;\n\treturn 0;\n}\n\nstatic const struct fib_rules_ops __net_initconst ip6mr_rules_ops_template = {\n\t.family\t\t= RTNL_FAMILY_IP6MR,\n\t.rule_size\t= sizeof(struct ip6mr_rule),\n\t.addr_size\t= sizeof(struct in6_addr),\n\t.action\t\t= ip6mr_rule_action,\n\t.match\t\t= ip6mr_rule_match,\n\t.configure\t= ip6mr_rule_configure,\n\t.compare\t= ip6mr_rule_compare,\n\t.fill\t\t= ip6mr_rule_fill,\n\t.nlgroup\t= RTNLGRP_IPV6_RULE,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __net_init ip6mr_rules_init(struct net *net)\n{\n\tstruct fib_rules_ops *ops;\n\tstruct mr_table *mrt;\n\tint err;\n\n\tops = fib_rules_register(&ip6mr_rules_ops_template, net);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\tINIT_LIST_HEAD(&net->ipv6.mr6_tables);\n\n\tmrt = ip6mr_new_table(net, RT6_TABLE_DFLT);\n\tif (IS_ERR(mrt)) {\n\t\terr = PTR_ERR(mrt);\n\t\tgoto err1;\n\t}\n\n\terr = fib_default_rule_add(ops, 0x7fff, RT6_TABLE_DFLT, 0);\n\tif (err < 0)\n\t\tgoto err2;\n\n\tnet->ipv6.mr6_rules_ops = ops;\n\treturn 0;\n\nerr2:\n\trtnl_lock();\n\tip6mr_free_table(mrt);\n\trtnl_unlock();\nerr1:\n\tfib_rules_unregister(ops);\n\treturn err;\n}\n\nstatic void __net_exit ip6mr_rules_exit(struct net *net)\n{\n\tstruct mr_table *mrt, *next;\n\n\tASSERT_RTNL();\n\tlist_for_each_entry_safe(mrt, next, &net->ipv6.mr6_tables, list) {\n\t\tlist_del(&mrt->list);\n\t\tip6mr_free_table(mrt);\n\t}\n\tfib_rules_unregister(net->ipv6.mr6_rules_ops);\n}\n\nstatic int ip6mr_rules_dump(struct net *net, struct notifier_block *nb,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\treturn fib_rules_dump(net, nb, RTNL_FAMILY_IP6MR, extack);\n}\n\nstatic unsigned int ip6mr_rules_seq_read(struct net *net)\n{\n\treturn fib_rules_seq_read(net, RTNL_FAMILY_IP6MR);\n}\n\nbool ip6mr_rule_default(const struct fib_rule *rule)\n{\n\treturn fib_rule_matchall(rule) && rule->action == FR_ACT_TO_TBL &&\n\t       rule->table == RT6_TABLE_DFLT && !rule->l3mdev;\n}\nEXPORT_SYMBOL(ip6mr_rule_default);\n#else\n#define ip6mr_for_each_table(mrt, net) \\\n\tfor (mrt = net->ipv6.mrt6; mrt; mrt = NULL)\n\nstatic struct mr_table *ip6mr_mr_table_iter(struct net *net,\n\t\t\t\t\t    struct mr_table *mrt)\n{\n\tif (!mrt)\n\t\treturn net->ipv6.mrt6;\n\treturn NULL;\n}\n\nstatic struct mr_table *ip6mr_get_table(struct net *net, u32 id)\n{\n\treturn net->ipv6.mrt6;\n}\n\nstatic int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,\n\t\t\t    struct mr_table **mrt)\n{\n\t*mrt = net->ipv6.mrt6;\n\treturn 0;\n}\n\nstatic int __net_init ip6mr_rules_init(struct net *net)\n{\n\tstruct mr_table *mrt;\n\n\tmrt = ip6mr_new_table(net, RT6_TABLE_DFLT);\n\tif (IS_ERR(mrt))\n\t\treturn PTR_ERR(mrt);\n\tnet->ipv6.mrt6 = mrt;\n\treturn 0;\n}\n\nstatic void __net_exit ip6mr_rules_exit(struct net *net)\n{\n\tASSERT_RTNL();\n\tip6mr_free_table(net->ipv6.mrt6);\n\tnet->ipv6.mrt6 = NULL;\n}\n\nstatic int ip6mr_rules_dump(struct net *net, struct notifier_block *nb,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\treturn 0;\n}\n\nstatic unsigned int ip6mr_rules_seq_read(struct net *net)\n{\n\treturn 0;\n}\n#endif\n\nstatic int ip6mr_hash_cmp(struct rhashtable_compare_arg *arg,\n\t\t\t  const void *ptr)\n{\n\tconst struct mfc6_cache_cmp_arg *cmparg = arg->key;\n\tstruct mfc6_cache *c = (struct mfc6_cache *)ptr;\n\n\treturn !ipv6_addr_equal(&c->mf6c_mcastgrp, &cmparg->mf6c_mcastgrp) ||\n\t       !ipv6_addr_equal(&c->mf6c_origin, &cmparg->mf6c_origin);\n}\n\nstatic const struct rhashtable_params ip6mr_rht_params = {\n\t.head_offset = offsetof(struct mr_mfc, mnode),\n\t.key_offset = offsetof(struct mfc6_cache, cmparg),\n\t.key_len = sizeof(struct mfc6_cache_cmp_arg),\n\t.nelem_hint = 3,\n\t.obj_cmpfn = ip6mr_hash_cmp,\n\t.automatic_shrinking = true,\n};\n\nstatic void ip6mr_new_table_set(struct mr_table *mrt,\n\t\t\t\tstruct net *net)\n{\n#ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES\n\tlist_add_tail_rcu(&mrt->list, &net->ipv6.mr6_tables);\n#endif\n}\n\nstatic struct mfc6_cache_cmp_arg ip6mr_mr_table_ops_cmparg_any = {\n\t.mf6c_origin = IN6ADDR_ANY_INIT,\n\t.mf6c_mcastgrp = IN6ADDR_ANY_INIT,\n};\n\nstatic struct mr_table_ops ip6mr_mr_table_ops = {\n\t.rht_params = &ip6mr_rht_params,\n\t.cmparg_any = &ip6mr_mr_table_ops_cmparg_any,\n};\n\nstatic struct mr_table *ip6mr_new_table(struct net *net, u32 id)\n{\n\tstruct mr_table *mrt;\n\n\tmrt = ip6mr_get_table(net, id);\n\tif (mrt)\n\t\treturn mrt;\n\n\treturn mr_table_alloc(net, id, &ip6mr_mr_table_ops,\n\t\t\t      ipmr_expire_process, ip6mr_new_table_set);\n}\n\nstatic void ip6mr_free_table(struct mr_table *mrt)\n{\n\ttimer_shutdown_sync(&mrt->ipmr_expire_timer);\n\tmroute_clean_tables(mrt, MRT6_FLUSH_MIFS | MRT6_FLUSH_MIFS_STATIC |\n\t\t\t\t MRT6_FLUSH_MFC | MRT6_FLUSH_MFC_STATIC);\n\trhltable_destroy(&mrt->mfc_hash);\n\tkfree(mrt);\n}\n\n#ifdef CONFIG_PROC_FS\n \n\nstatic void *ip6mr_vif_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct mr_vif_iter *iter = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tstruct mr_table *mrt;\n\n\tmrt = ip6mr_get_table(net, RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn ERR_PTR(-ENOENT);\n\n\titer->mrt = mrt;\n\n\trcu_read_lock();\n\treturn mr_vif_seq_start(seq, pos);\n}\n\nstatic void ip6mr_vif_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\nstatic int ip6mr_vif_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct mr_vif_iter *iter = seq->private;\n\tstruct mr_table *mrt = iter->mrt;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"Interface      BytesIn  PktsIn  BytesOut PktsOut Flags\\n\");\n\t} else {\n\t\tconst struct vif_device *vif = v;\n\t\tconst struct net_device *vif_dev;\n\t\tconst char *name;\n\n\t\tvif_dev = vif_dev_read(vif);\n\t\tname = vif_dev ? vif_dev->name : \"none\";\n\n\t\tseq_printf(seq,\n\t\t\t   \"%2td %-10s %8ld %7ld  %8ld %7ld %05X\\n\",\n\t\t\t   vif - mrt->vif_table,\n\t\t\t   name, vif->bytes_in, vif->pkt_in,\n\t\t\t   vif->bytes_out, vif->pkt_out,\n\t\t\t   vif->flags);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ip6mr_vif_seq_ops = {\n\t.start = ip6mr_vif_seq_start,\n\t.next  = mr_vif_seq_next,\n\t.stop  = ip6mr_vif_seq_stop,\n\t.show  = ip6mr_vif_seq_show,\n};\n\nstatic void *ipmr_mfc_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct mr_table *mrt;\n\n\tmrt = ip6mr_get_table(net, RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn mr_mfc_seq_start(seq, pos, mrt, &mfc_unres_lock);\n}\n\nstatic int ipmr_mfc_seq_show(struct seq_file *seq, void *v)\n{\n\tint n;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"Group                            \"\n\t\t\t \"Origin                           \"\n\t\t\t \"Iif      Pkts  Bytes     Wrong  Oifs\\n\");\n\t} else {\n\t\tconst struct mfc6_cache *mfc = v;\n\t\tconst struct mr_mfc_iter *it = seq->private;\n\t\tstruct mr_table *mrt = it->mrt;\n\n\t\tseq_printf(seq, \"%pI6 %pI6 %-3hd\",\n\t\t\t   &mfc->mf6c_mcastgrp, &mfc->mf6c_origin,\n\t\t\t   mfc->_c.mfc_parent);\n\n\t\tif (it->cache != &mrt->mfc_unres_queue) {\n\t\t\tseq_printf(seq, \" %8lu %8lu %8lu\",\n\t\t\t\t   mfc->_c.mfc_un.res.pkt,\n\t\t\t\t   mfc->_c.mfc_un.res.bytes,\n\t\t\t\t   mfc->_c.mfc_un.res.wrong_if);\n\t\t\tfor (n = mfc->_c.mfc_un.res.minvif;\n\t\t\t     n < mfc->_c.mfc_un.res.maxvif; n++) {\n\t\t\t\tif (VIF_EXISTS(mrt, n) &&\n\t\t\t\t    mfc->_c.mfc_un.res.ttls[n] < 255)\n\t\t\t\t\tseq_printf(seq,\n\t\t\t\t\t\t   \" %2d:%-3d\", n,\n\t\t\t\t\t\t   mfc->_c.mfc_un.res.ttls[n]);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tseq_printf(seq, \" %8lu %8lu %8lu\", 0ul, 0ul, 0ul);\n\t\t}\n\t\tseq_putc(seq, '\\n');\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ipmr_mfc_seq_ops = {\n\t.start = ipmr_mfc_seq_start,\n\t.next  = mr_mfc_seq_next,\n\t.stop  = mr_mfc_seq_stop,\n\t.show  = ipmr_mfc_seq_show,\n};\n#endif\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\nstatic int pim6_rcv(struct sk_buff *skb)\n{\n\tstruct pimreghdr *pim;\n\tstruct ipv6hdr   *encap;\n\tstruct net_device  *reg_dev = NULL;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct mr_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif\t= skb->dev->ifindex,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\tint reg_vif_num;\n\n\tif (!pskb_may_pull(skb, sizeof(*pim) + sizeof(*encap)))\n\t\tgoto drop;\n\n\tpim = (struct pimreghdr *)skb_transport_header(skb);\n\tif (pim->type != ((PIM_VERSION << 4) | PIM_TYPE_REGISTER) ||\n\t    (pim->flags & PIM_NULL_REGISTER) ||\n\t    (csum_ipv6_magic(&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr,\n\t\t\t     sizeof(*pim), IPPROTO_PIM,\n\t\t\t     csum_partial((void *)pim, sizeof(*pim), 0)) &&\n\t     csum_fold(skb_checksum(skb, 0, skb->len, 0))))\n\t\tgoto drop;\n\n\t \n\tencap = (struct ipv6hdr *)(skb_transport_header(skb) +\n\t\t\t\t   sizeof(*pim));\n\n\tif (!ipv6_addr_is_multicast(&encap->daddr) ||\n\t    encap->payload_len == 0 ||\n\t    ntohs(encap->payload_len) + sizeof(*pim) > skb->len)\n\t\tgoto drop;\n\n\tif (ip6mr_fib_lookup(net, &fl6, &mrt) < 0)\n\t\tgoto drop;\n\n\t \n\treg_vif_num = READ_ONCE(mrt->mroute_reg_vif_num);\n\tif (reg_vif_num >= 0)\n\t\treg_dev = vif_dev_read(&mrt->vif_table[reg_vif_num]);\n\n\tif (!reg_dev)\n\t\tgoto drop;\n\n\tskb->mac_header = skb->network_header;\n\tskb_pull(skb, (u8 *)encap - skb->data);\n\tskb_reset_network_header(skb);\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb_tunnel_rx(skb, reg_dev, dev_net(reg_dev));\n\n\tnetif_rx(skb);\n\n\treturn 0;\n drop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic const struct inet6_protocol pim6_protocol = {\n\t.handler\t=\tpim6_rcv,\n};\n\n \n\nstatic netdev_tx_t reg_vif_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct mr_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_oif\t= dev->ifindex,\n\t\t.flowi6_iif\t= skb->skb_iif ? : LOOPBACK_IFINDEX,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\n\tif (!pskb_inet_may_pull(skb))\n\t\tgoto tx_err;\n\n\tif (ip6mr_fib_lookup(net, &fl6, &mrt) < 0)\n\t\tgoto tx_err;\n\n\tDEV_STATS_ADD(dev, tx_bytes, skb->len);\n\tDEV_STATS_INC(dev, tx_packets);\n\trcu_read_lock();\n\tip6mr_cache_report(mrt, skb, READ_ONCE(mrt->mroute_reg_vif_num),\n\t\t\t   MRT6MSG_WHOLEPKT);\n\trcu_read_unlock();\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n\ntx_err:\n\tDEV_STATS_INC(dev, tx_errors);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int reg_vif_get_iflink(const struct net_device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct net_device_ops reg_vif_netdev_ops = {\n\t.ndo_start_xmit\t= reg_vif_xmit,\n\t.ndo_get_iflink = reg_vif_get_iflink,\n};\n\nstatic void reg_vif_setup(struct net_device *dev)\n{\n\tdev->type\t\t= ARPHRD_PIMREG;\n\tdev->mtu\t\t= 1500 - sizeof(struct ipv6hdr) - 8;\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->netdev_ops\t\t= &reg_vif_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n}\n\nstatic struct net_device *ip6mr_reg_vif(struct net *net, struct mr_table *mrt)\n{\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\n\tif (mrt->id == RT6_TABLE_DFLT)\n\t\tsprintf(name, \"pim6reg\");\n\telse\n\t\tsprintf(name, \"pim6reg%u\", mrt->id);\n\n\tdev = alloc_netdev(0, name, NET_NAME_UNKNOWN, reg_vif_setup);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev_net_set(dev, net);\n\n\tif (register_netdevice(dev)) {\n\t\tfree_netdev(dev);\n\t\treturn NULL;\n\t}\n\n\tif (dev_open(dev, NULL))\n\t\tgoto failure;\n\n\tdev_hold(dev);\n\treturn dev;\n\nfailure:\n\tunregister_netdevice(dev);\n\treturn NULL;\n}\n#endif\n\nstatic int call_ip6mr_vif_entry_notifiers(struct net *net,\n\t\t\t\t\t  enum fib_event_type event_type,\n\t\t\t\t\t  struct vif_device *vif,\n\t\t\t\t\t  struct net_device *vif_dev,\n\t\t\t\t\t  mifi_t vif_index, u32 tb_id)\n{\n\treturn mr_call_vif_notifiers(net, RTNL_FAMILY_IP6MR, event_type,\n\t\t\t\t     vif, vif_dev, vif_index, tb_id,\n\t\t\t\t     &net->ipv6.ipmr_seq);\n}\n\nstatic int call_ip6mr_mfc_entry_notifiers(struct net *net,\n\t\t\t\t\t  enum fib_event_type event_type,\n\t\t\t\t\t  struct mfc6_cache *mfc, u32 tb_id)\n{\n\treturn mr_call_mfc_notifiers(net, RTNL_FAMILY_IP6MR, event_type,\n\t\t\t\t     &mfc->_c, tb_id, &net->ipv6.ipmr_seq);\n}\n\n \nstatic int mif6_delete(struct mr_table *mrt, int vifi, int notify,\n\t\t       struct list_head *head)\n{\n\tstruct vif_device *v;\n\tstruct net_device *dev;\n\tstruct inet6_dev *in6_dev;\n\n\tif (vifi < 0 || vifi >= mrt->maxvif)\n\t\treturn -EADDRNOTAVAIL;\n\n\tv = &mrt->vif_table[vifi];\n\n\tdev = rtnl_dereference(v->dev);\n\tif (!dev)\n\t\treturn -EADDRNOTAVAIL;\n\n\tcall_ip6mr_vif_entry_notifiers(read_pnet(&mrt->net),\n\t\t\t\t       FIB_EVENT_VIF_DEL, v, dev,\n\t\t\t\t       vifi, mrt->id);\n\tspin_lock(&mrt_lock);\n\tRCU_INIT_POINTER(v->dev, NULL);\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (vifi == mrt->mroute_reg_vif_num) {\n\t\t \n\t\tWRITE_ONCE(mrt->mroute_reg_vif_num, -1);\n\t}\n#endif\n\n\tif (vifi + 1 == mrt->maxvif) {\n\t\tint tmp;\n\t\tfor (tmp = vifi - 1; tmp >= 0; tmp--) {\n\t\t\tif (VIF_EXISTS(mrt, tmp))\n\t\t\t\tbreak;\n\t\t}\n\t\tWRITE_ONCE(mrt->maxvif, tmp + 1);\n\t}\n\n\tspin_unlock(&mrt_lock);\n\n\tdev_set_allmulti(dev, -1);\n\n\tin6_dev = __in6_dev_get(dev);\n\tif (in6_dev) {\n\t\tatomic_dec(&in6_dev->cnf.mc_forwarding);\n\t\tinet6_netconf_notify_devconf(dev_net(dev), RTM_NEWNETCONF,\n\t\t\t\t\t     NETCONFA_MC_FORWARDING,\n\t\t\t\t\t     dev->ifindex, &in6_dev->cnf);\n\t}\n\n\tif ((v->flags & MIFF_REGISTER) && !notify)\n\t\tunregister_netdevice_queue(dev, head);\n\n\tnetdev_put(dev, &v->dev_tracker);\n\treturn 0;\n}\n\nstatic inline void ip6mr_cache_free_rcu(struct rcu_head *head)\n{\n\tstruct mr_mfc *c = container_of(head, struct mr_mfc, rcu);\n\n\tkmem_cache_free(mrt_cachep, (struct mfc6_cache *)c);\n}\n\nstatic inline void ip6mr_cache_free(struct mfc6_cache *c)\n{\n\tcall_rcu(&c->_c.rcu, ip6mr_cache_free_rcu);\n}\n\n \n\nstatic void ip6mr_destroy_unres(struct mr_table *mrt, struct mfc6_cache *c)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct sk_buff *skb;\n\n\tatomic_dec(&mrt->cache_resolve_queue_len);\n\n\twhile ((skb = skb_dequeue(&c->_c.mfc_un.unres.unresolved)) != NULL) {\n\t\tif (ipv6_hdr(skb)->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = skb_pull(skb,\n\t\t\t\t\t\t\tsizeof(struct ipv6hdr));\n\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\tnlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));\n\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;\n\t\t\trtnl_unicast(skb, net, NETLINK_CB(skb).portid);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n\n\tip6mr_cache_free(c);\n}\n\n\n \n\nstatic void ipmr_do_expire_process(struct mr_table *mrt)\n{\n\tunsigned long now = jiffies;\n\tunsigned long expires = 10 * HZ;\n\tstruct mr_mfc *c, *next;\n\n\tlist_for_each_entry_safe(c, next, &mrt->mfc_unres_queue, list) {\n\t\tif (time_after(c->mfc_un.unres.expires, now)) {\n\t\t\t \n\t\t\tunsigned long interval = c->mfc_un.unres.expires - now;\n\t\t\tif (interval < expires)\n\t\t\t\texpires = interval;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_del(&c->list);\n\t\tmr6_netlink_event(mrt, (struct mfc6_cache *)c, RTM_DELROUTE);\n\t\tip6mr_destroy_unres(mrt, (struct mfc6_cache *)c);\n\t}\n\n\tif (!list_empty(&mrt->mfc_unres_queue))\n\t\tmod_timer(&mrt->ipmr_expire_timer, jiffies + expires);\n}\n\nstatic void ipmr_expire_process(struct timer_list *t)\n{\n\tstruct mr_table *mrt = from_timer(mrt, t, ipmr_expire_timer);\n\n\tif (!spin_trylock(&mfc_unres_lock)) {\n\t\tmod_timer(&mrt->ipmr_expire_timer, jiffies + 1);\n\t\treturn;\n\t}\n\n\tif (!list_empty(&mrt->mfc_unres_queue))\n\t\tipmr_do_expire_process(mrt);\n\n\tspin_unlock(&mfc_unres_lock);\n}\n\n \n\nstatic void ip6mr_update_thresholds(struct mr_table *mrt,\n\t\t\t\t    struct mr_mfc *cache,\n\t\t\t\t    unsigned char *ttls)\n{\n\tint vifi;\n\n\tcache->mfc_un.res.minvif = MAXMIFS;\n\tcache->mfc_un.res.maxvif = 0;\n\tmemset(cache->mfc_un.res.ttls, 255, MAXMIFS);\n\n\tfor (vifi = 0; vifi < mrt->maxvif; vifi++) {\n\t\tif (VIF_EXISTS(mrt, vifi) &&\n\t\t    ttls[vifi] && ttls[vifi] < 255) {\n\t\t\tcache->mfc_un.res.ttls[vifi] = ttls[vifi];\n\t\t\tif (cache->mfc_un.res.minvif > vifi)\n\t\t\t\tcache->mfc_un.res.minvif = vifi;\n\t\t\tif (cache->mfc_un.res.maxvif <= vifi)\n\t\t\t\tcache->mfc_un.res.maxvif = vifi + 1;\n\t\t}\n\t}\n\tcache->mfc_un.res.lastuse = jiffies;\n}\n\nstatic int mif6_add(struct net *net, struct mr_table *mrt,\n\t\t    struct mif6ctl *vifc, int mrtsock)\n{\n\tint vifi = vifc->mif6c_mifi;\n\tstruct vif_device *v = &mrt->vif_table[vifi];\n\tstruct net_device *dev;\n\tstruct inet6_dev *in6_dev;\n\tint err;\n\n\t \n\tif (VIF_EXISTS(mrt, vifi))\n\t\treturn -EADDRINUSE;\n\n\tswitch (vifc->mif6c_flags) {\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MIFF_REGISTER:\n\t\t \n\t\tif (mrt->mroute_reg_vif_num >= 0)\n\t\t\treturn -EADDRINUSE;\n\t\tdev = ip6mr_reg_vif(net, mrt);\n\t\tif (!dev)\n\t\t\treturn -ENOBUFS;\n\t\terr = dev_set_allmulti(dev, 1);\n\t\tif (err) {\n\t\t\tunregister_netdevice(dev);\n\t\t\tdev_put(dev);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n#endif\n\tcase 0:\n\t\tdev = dev_get_by_index(net, vifc->mif6c_pifi);\n\t\tif (!dev)\n\t\t\treturn -EADDRNOTAVAIL;\n\t\terr = dev_set_allmulti(dev, 1);\n\t\tif (err) {\n\t\t\tdev_put(dev);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tin6_dev = __in6_dev_get(dev);\n\tif (in6_dev) {\n\t\tatomic_inc(&in6_dev->cnf.mc_forwarding);\n\t\tinet6_netconf_notify_devconf(dev_net(dev), RTM_NEWNETCONF,\n\t\t\t\t\t     NETCONFA_MC_FORWARDING,\n\t\t\t\t\t     dev->ifindex, &in6_dev->cnf);\n\t}\n\n\t \n\tvif_device_init(v, dev, vifc->vifc_rate_limit, vifc->vifc_threshold,\n\t\t\tvifc->mif6c_flags | (!mrtsock ? VIFF_STATIC : 0),\n\t\t\tMIFF_REGISTER);\n\n\t \n\tspin_lock(&mrt_lock);\n\trcu_assign_pointer(v->dev, dev);\n\tnetdev_tracker_alloc(dev, &v->dev_tracker, GFP_ATOMIC);\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (v->flags & MIFF_REGISTER)\n\t\tWRITE_ONCE(mrt->mroute_reg_vif_num, vifi);\n#endif\n\tif (vifi + 1 > mrt->maxvif)\n\t\tWRITE_ONCE(mrt->maxvif, vifi + 1);\n\tspin_unlock(&mrt_lock);\n\tcall_ip6mr_vif_entry_notifiers(net, FIB_EVENT_VIF_ADD,\n\t\t\t\t       v, dev, vifi, mrt->id);\n\treturn 0;\n}\n\nstatic struct mfc6_cache *ip6mr_cache_find(struct mr_table *mrt,\n\t\t\t\t\t   const struct in6_addr *origin,\n\t\t\t\t\t   const struct in6_addr *mcastgrp)\n{\n\tstruct mfc6_cache_cmp_arg arg = {\n\t\t.mf6c_origin = *origin,\n\t\t.mf6c_mcastgrp = *mcastgrp,\n\t};\n\n\treturn mr_mfc_find(mrt, &arg);\n}\n\n \nstatic struct mfc6_cache *ip6mr_cache_find_any(struct mr_table *mrt,\n\t\t\t\t\t       struct in6_addr *mcastgrp,\n\t\t\t\t\t       mifi_t mifi)\n{\n\tstruct mfc6_cache_cmp_arg arg = {\n\t\t.mf6c_origin = in6addr_any,\n\t\t.mf6c_mcastgrp = *mcastgrp,\n\t};\n\n\tif (ipv6_addr_any(mcastgrp))\n\t\treturn mr_mfc_find_any_parent(mrt, mifi);\n\treturn mr_mfc_find_any(mrt, mifi, &arg);\n}\n\n \nstatic struct mfc6_cache *\nip6mr_cache_find_parent(struct mr_table *mrt,\n\t\t\tconst struct in6_addr *origin,\n\t\t\tconst struct in6_addr *mcastgrp,\n\t\t\tint parent)\n{\n\tstruct mfc6_cache_cmp_arg arg = {\n\t\t.mf6c_origin = *origin,\n\t\t.mf6c_mcastgrp = *mcastgrp,\n\t};\n\n\treturn mr_mfc_find_parent(mrt, &arg, parent);\n}\n\n \nstatic struct mfc6_cache *ip6mr_cache_alloc(void)\n{\n\tstruct mfc6_cache *c = kmem_cache_zalloc(mrt_cachep, GFP_KERNEL);\n\tif (!c)\n\t\treturn NULL;\n\tc->_c.mfc_un.res.last_assert = jiffies - MFC_ASSERT_THRESH - 1;\n\tc->_c.mfc_un.res.minvif = MAXMIFS;\n\tc->_c.free = ip6mr_cache_free_rcu;\n\trefcount_set(&c->_c.mfc_un.res.refcount, 1);\n\treturn c;\n}\n\nstatic struct mfc6_cache *ip6mr_cache_alloc_unres(void)\n{\n\tstruct mfc6_cache *c = kmem_cache_zalloc(mrt_cachep, GFP_ATOMIC);\n\tif (!c)\n\t\treturn NULL;\n\tskb_queue_head_init(&c->_c.mfc_un.unres.unresolved);\n\tc->_c.mfc_un.unres.expires = jiffies + 10 * HZ;\n\treturn c;\n}\n\n \n\nstatic void ip6mr_cache_resolve(struct net *net, struct mr_table *mrt,\n\t\t\t\tstruct mfc6_cache *uc, struct mfc6_cache *c)\n{\n\tstruct sk_buff *skb;\n\n\t \n\n\twhile ((skb = __skb_dequeue(&uc->_c.mfc_un.unres.unresolved))) {\n\t\tif (ipv6_hdr(skb)->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = skb_pull(skb,\n\t\t\t\t\t\t\tsizeof(struct ipv6hdr));\n\n\t\t\tif (mr_fill_mroute(mrt, skb, &c->_c,\n\t\t\t\t\t   nlmsg_data(nlh)) > 0) {\n\t\t\t\tnlh->nlmsg_len = skb_tail_pointer(skb) - (u8 *)nlh;\n\t\t\t} else {\n\t\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\t\tnlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));\n\t\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t\t((struct nlmsgerr *)nlmsg_data(nlh))->error = -EMSGSIZE;\n\t\t\t}\n\t\t\trtnl_unicast(skb, net, NETLINK_CB(skb).portid);\n\t\t} else {\n\t\t\trcu_read_lock();\n\t\t\tip6_mr_forward(net, mrt, skb->dev, skb, c);\n\t\t\trcu_read_unlock();\n\t\t}\n\t}\n}\n\n \n\nstatic int ip6mr_cache_report(const struct mr_table *mrt, struct sk_buff *pkt,\n\t\t\t      mifi_t mifi, int assert)\n{\n\tstruct sock *mroute6_sk;\n\tstruct sk_buff *skb;\n\tstruct mrt6msg *msg;\n\tint ret;\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (assert == MRT6MSG_WHOLEPKT || assert == MRT6MSG_WRMIFWHOLE)\n\t\tskb = skb_realloc_headroom(pkt, -skb_network_offset(pkt)\n\t\t\t\t\t\t+sizeof(*msg));\n\telse\n#endif\n\t\tskb = alloc_skb(sizeof(struct ipv6hdr) + sizeof(*msg), GFP_ATOMIC);\n\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\t \n\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (assert == MRT6MSG_WHOLEPKT || assert == MRT6MSG_WRMIFWHOLE) {\n\t\t \n\t\t__skb_pull(skb, skb_network_offset(pkt));\n\n\t\tskb_push(skb, sizeof(*msg));\n\t\tskb_reset_transport_header(skb);\n\t\tmsg = (struct mrt6msg *)skb_transport_header(skb);\n\t\tmsg->im6_mbz = 0;\n\t\tmsg->im6_msgtype = assert;\n\t\tif (assert == MRT6MSG_WRMIFWHOLE)\n\t\t\tmsg->im6_mif = mifi;\n\t\telse\n\t\t\tmsg->im6_mif = READ_ONCE(mrt->mroute_reg_vif_num);\n\t\tmsg->im6_pad = 0;\n\t\tmsg->im6_src = ipv6_hdr(pkt)->saddr;\n\t\tmsg->im6_dst = ipv6_hdr(pkt)->daddr;\n\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t} else\n#endif\n\t{\n\t \n\n\tskb_put(skb, sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tskb_copy_to_linear_data(skb, ipv6_hdr(pkt), sizeof(struct ipv6hdr));\n\n\t \n\tskb_put(skb, sizeof(*msg));\n\tskb_reset_transport_header(skb);\n\tmsg = (struct mrt6msg *)skb_transport_header(skb);\n\n\tmsg->im6_mbz = 0;\n\tmsg->im6_msgtype = assert;\n\tmsg->im6_mif = mifi;\n\tmsg->im6_pad = 0;\n\tmsg->im6_src = ipv6_hdr(pkt)->saddr;\n\tmsg->im6_dst = ipv6_hdr(pkt)->daddr;\n\n\tskb_dst_set(skb, dst_clone(skb_dst(pkt)));\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\n\tmroute6_sk = rcu_dereference(mrt->mroute_sk);\n\tif (!mroute6_sk) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tmrt6msg_netlink_event(mrt, skb);\n\n\t \n\tret = sock_queue_rcv_skb(mroute6_sk, skb);\n\n\tif (ret < 0) {\n\t\tnet_warn_ratelimited(\"mroute6: pending queue full, dropping entries\\n\");\n\t\tkfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ip6mr_cache_unresolved(struct mr_table *mrt, mifi_t mifi,\n\t\t\t\t  struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct mfc6_cache *c;\n\tbool found = false;\n\tint err;\n\n\tspin_lock_bh(&mfc_unres_lock);\n\tlist_for_each_entry(c, &mrt->mfc_unres_queue, _c.list) {\n\t\tif (ipv6_addr_equal(&c->mf6c_mcastgrp, &ipv6_hdr(skb)->daddr) &&\n\t\t    ipv6_addr_equal(&c->mf6c_origin, &ipv6_hdr(skb)->saddr)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\t \n\n\t\tc = ip6mr_cache_alloc_unres();\n\t\tif (!c) {\n\t\t\tspin_unlock_bh(&mfc_unres_lock);\n\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\t \n\t\tc->_c.mfc_parent = -1;\n\t\tc->mf6c_origin = ipv6_hdr(skb)->saddr;\n\t\tc->mf6c_mcastgrp = ipv6_hdr(skb)->daddr;\n\n\t\t \n\t\terr = ip6mr_cache_report(mrt, skb, mifi, MRT6MSG_NOCACHE);\n\t\tif (err < 0) {\n\t\t\t \n\t\t\tspin_unlock_bh(&mfc_unres_lock);\n\n\t\t\tip6mr_cache_free(c);\n\t\t\tkfree_skb(skb);\n\t\t\treturn err;\n\t\t}\n\n\t\tatomic_inc(&mrt->cache_resolve_queue_len);\n\t\tlist_add(&c->_c.list, &mrt->mfc_unres_queue);\n\t\tmr6_netlink_event(mrt, c, RTM_NEWROUTE);\n\n\t\tipmr_do_expire_process(mrt);\n\t}\n\n\t \n\tif (c->_c.mfc_un.unres.unresolved.qlen > 3) {\n\t\tkfree_skb(skb);\n\t\terr = -ENOBUFS;\n\t} else {\n\t\tif (dev) {\n\t\t\tskb->dev = dev;\n\t\t\tskb->skb_iif = dev->ifindex;\n\t\t}\n\t\tskb_queue_tail(&c->_c.mfc_un.unres.unresolved, skb);\n\t\terr = 0;\n\t}\n\n\tspin_unlock_bh(&mfc_unres_lock);\n\treturn err;\n}\n\n \n\nstatic int ip6mr_mfc_delete(struct mr_table *mrt, struct mf6cctl *mfc,\n\t\t\t    int parent)\n{\n\tstruct mfc6_cache *c;\n\n\t \n\trcu_read_lock();\n\tc = ip6mr_cache_find_parent(mrt, &mfc->mf6cc_origin.sin6_addr,\n\t\t\t\t    &mfc->mf6cc_mcastgrp.sin6_addr, parent);\n\trcu_read_unlock();\n\tif (!c)\n\t\treturn -ENOENT;\n\trhltable_remove(&mrt->mfc_hash, &c->_c.mnode, ip6mr_rht_params);\n\tlist_del_rcu(&c->_c.list);\n\n\tcall_ip6mr_mfc_entry_notifiers(read_pnet(&mrt->net),\n\t\t\t\t       FIB_EVENT_ENTRY_DEL, c, mrt->id);\n\tmr6_netlink_event(mrt, c, RTM_DELROUTE);\n\tmr_cache_put(&c->_c);\n\treturn 0;\n}\n\nstatic int ip6mr_device_event(struct notifier_block *this,\n\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\tstruct mr_table *mrt;\n\tstruct vif_device *v;\n\tint ct;\n\n\tif (event != NETDEV_UNREGISTER)\n\t\treturn NOTIFY_DONE;\n\n\tip6mr_for_each_table(mrt, net) {\n\t\tv = &mrt->vif_table[0];\n\t\tfor (ct = 0; ct < mrt->maxvif; ct++, v++) {\n\t\t\tif (rcu_access_pointer(v->dev) == dev)\n\t\t\t\tmif6_delete(mrt, ct, 1, NULL);\n\t\t}\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic unsigned int ip6mr_seq_read(struct net *net)\n{\n\tASSERT_RTNL();\n\n\treturn net->ipv6.ipmr_seq + ip6mr_rules_seq_read(net);\n}\n\nstatic int ip6mr_dump(struct net *net, struct notifier_block *nb,\n\t\t      struct netlink_ext_ack *extack)\n{\n\treturn mr_dump(net, nb, RTNL_FAMILY_IP6MR, ip6mr_rules_dump,\n\t\t       ip6mr_mr_table_iter, extack);\n}\n\nstatic struct notifier_block ip6_mr_notifier = {\n\t.notifier_call = ip6mr_device_event\n};\n\nstatic const struct fib_notifier_ops ip6mr_notifier_ops_template = {\n\t.family\t\t= RTNL_FAMILY_IP6MR,\n\t.fib_seq_read\t= ip6mr_seq_read,\n\t.fib_dump\t= ip6mr_dump,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int __net_init ip6mr_notifier_init(struct net *net)\n{\n\tstruct fib_notifier_ops *ops;\n\n\tnet->ipv6.ipmr_seq = 0;\n\n\tops = fib_notifier_ops_register(&ip6mr_notifier_ops_template, net);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\tnet->ipv6.ip6mr_notifier_ops = ops;\n\n\treturn 0;\n}\n\nstatic void __net_exit ip6mr_notifier_exit(struct net *net)\n{\n\tfib_notifier_ops_unregister(net->ipv6.ip6mr_notifier_ops);\n\tnet->ipv6.ip6mr_notifier_ops = NULL;\n}\n\n \nstatic int __net_init ip6mr_net_init(struct net *net)\n{\n\tint err;\n\n\terr = ip6mr_notifier_init(net);\n\tif (err)\n\t\treturn err;\n\n\terr = ip6mr_rules_init(net);\n\tif (err < 0)\n\t\tgoto ip6mr_rules_fail;\n\n#ifdef CONFIG_PROC_FS\n\terr = -ENOMEM;\n\tif (!proc_create_net(\"ip6_mr_vif\", 0, net->proc_net, &ip6mr_vif_seq_ops,\n\t\t\tsizeof(struct mr_vif_iter)))\n\t\tgoto proc_vif_fail;\n\tif (!proc_create_net(\"ip6_mr_cache\", 0, net->proc_net, &ipmr_mfc_seq_ops,\n\t\t\tsizeof(struct mr_mfc_iter)))\n\t\tgoto proc_cache_fail;\n#endif\n\n\treturn 0;\n\n#ifdef CONFIG_PROC_FS\nproc_cache_fail:\n\tremove_proc_entry(\"ip6_mr_vif\", net->proc_net);\nproc_vif_fail:\n\trtnl_lock();\n\tip6mr_rules_exit(net);\n\trtnl_unlock();\n#endif\nip6mr_rules_fail:\n\tip6mr_notifier_exit(net);\n\treturn err;\n}\n\nstatic void __net_exit ip6mr_net_exit(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"ip6_mr_cache\", net->proc_net);\n\tremove_proc_entry(\"ip6_mr_vif\", net->proc_net);\n#endif\n\tip6mr_notifier_exit(net);\n}\n\nstatic void __net_exit ip6mr_net_exit_batch(struct list_head *net_list)\n{\n\tstruct net *net;\n\n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list)\n\t\tip6mr_rules_exit(net);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations ip6mr_net_ops = {\n\t.init = ip6mr_net_init,\n\t.exit = ip6mr_net_exit,\n\t.exit_batch = ip6mr_net_exit_batch,\n};\n\nint __init ip6_mr_init(void)\n{\n\tint err;\n\n\tmrt_cachep = kmem_cache_create(\"ip6_mrt_cache\",\n\t\t\t\t       sizeof(struct mfc6_cache),\n\t\t\t\t       0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t       NULL);\n\tif (!mrt_cachep)\n\t\treturn -ENOMEM;\n\n\terr = register_pernet_subsys(&ip6mr_net_ops);\n\tif (err)\n\t\tgoto reg_pernet_fail;\n\n\terr = register_netdevice_notifier(&ip6_mr_notifier);\n\tif (err)\n\t\tgoto reg_notif_fail;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (inet6_add_protocol(&pim6_protocol, IPPROTO_PIM) < 0) {\n\t\tpr_err(\"%s: can't add PIM protocol\\n\", __func__);\n\t\terr = -EAGAIN;\n\t\tgoto add_proto_fail;\n\t}\n#endif\n\terr = rtnl_register_module(THIS_MODULE, RTNL_FAMILY_IP6MR, RTM_GETROUTE,\n\t\t\t\t   ip6mr_rtm_getroute, ip6mr_rtm_dumproute, 0);\n\tif (err == 0)\n\t\treturn 0;\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tinet6_del_protocol(&pim6_protocol, IPPROTO_PIM);\nadd_proto_fail:\n\tunregister_netdevice_notifier(&ip6_mr_notifier);\n#endif\nreg_notif_fail:\n\tunregister_pernet_subsys(&ip6mr_net_ops);\nreg_pernet_fail:\n\tkmem_cache_destroy(mrt_cachep);\n\treturn err;\n}\n\nvoid ip6_mr_cleanup(void)\n{\n\trtnl_unregister(RTNL_FAMILY_IP6MR, RTM_GETROUTE);\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tinet6_del_protocol(&pim6_protocol, IPPROTO_PIM);\n#endif\n\tunregister_netdevice_notifier(&ip6_mr_notifier);\n\tunregister_pernet_subsys(&ip6mr_net_ops);\n\tkmem_cache_destroy(mrt_cachep);\n}\n\nstatic int ip6mr_mfc_add(struct net *net, struct mr_table *mrt,\n\t\t\t struct mf6cctl *mfc, int mrtsock, int parent)\n{\n\tunsigned char ttls[MAXMIFS];\n\tstruct mfc6_cache *uc, *c;\n\tstruct mr_mfc *_uc;\n\tbool found;\n\tint i, err;\n\n\tif (mfc->mf6cc_parent >= MAXMIFS)\n\t\treturn -ENFILE;\n\n\tmemset(ttls, 255, MAXMIFS);\n\tfor (i = 0; i < MAXMIFS; i++) {\n\t\tif (IF_ISSET(i, &mfc->mf6cc_ifset))\n\t\t\tttls[i] = 1;\n\t}\n\n\t \n\trcu_read_lock();\n\tc = ip6mr_cache_find_parent(mrt, &mfc->mf6cc_origin.sin6_addr,\n\t\t\t\t    &mfc->mf6cc_mcastgrp.sin6_addr, parent);\n\trcu_read_unlock();\n\tif (c) {\n\t\tspin_lock(&mrt_lock);\n\t\tc->_c.mfc_parent = mfc->mf6cc_parent;\n\t\tip6mr_update_thresholds(mrt, &c->_c, ttls);\n\t\tif (!mrtsock)\n\t\t\tc->_c.mfc_flags |= MFC_STATIC;\n\t\tspin_unlock(&mrt_lock);\n\t\tcall_ip6mr_mfc_entry_notifiers(net, FIB_EVENT_ENTRY_REPLACE,\n\t\t\t\t\t       c, mrt->id);\n\t\tmr6_netlink_event(mrt, c, RTM_NEWROUTE);\n\t\treturn 0;\n\t}\n\n\tif (!ipv6_addr_any(&mfc->mf6cc_mcastgrp.sin6_addr) &&\n\t    !ipv6_addr_is_multicast(&mfc->mf6cc_mcastgrp.sin6_addr))\n\t\treturn -EINVAL;\n\n\tc = ip6mr_cache_alloc();\n\tif (!c)\n\t\treturn -ENOMEM;\n\n\tc->mf6c_origin = mfc->mf6cc_origin.sin6_addr;\n\tc->mf6c_mcastgrp = mfc->mf6cc_mcastgrp.sin6_addr;\n\tc->_c.mfc_parent = mfc->mf6cc_parent;\n\tip6mr_update_thresholds(mrt, &c->_c, ttls);\n\tif (!mrtsock)\n\t\tc->_c.mfc_flags |= MFC_STATIC;\n\n\terr = rhltable_insert_key(&mrt->mfc_hash, &c->cmparg, &c->_c.mnode,\n\t\t\t\t  ip6mr_rht_params);\n\tif (err) {\n\t\tpr_err(\"ip6mr: rhtable insert error %d\\n\", err);\n\t\tip6mr_cache_free(c);\n\t\treturn err;\n\t}\n\tlist_add_tail_rcu(&c->_c.list, &mrt->mfc_cache_list);\n\n\t \n\tfound = false;\n\tspin_lock_bh(&mfc_unres_lock);\n\tlist_for_each_entry(_uc, &mrt->mfc_unres_queue, list) {\n\t\tuc = (struct mfc6_cache *)_uc;\n\t\tif (ipv6_addr_equal(&uc->mf6c_origin, &c->mf6c_origin) &&\n\t\t    ipv6_addr_equal(&uc->mf6c_mcastgrp, &c->mf6c_mcastgrp)) {\n\t\t\tlist_del(&_uc->list);\n\t\t\tatomic_dec(&mrt->cache_resolve_queue_len);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (list_empty(&mrt->mfc_unres_queue))\n\t\tdel_timer(&mrt->ipmr_expire_timer);\n\tspin_unlock_bh(&mfc_unres_lock);\n\n\tif (found) {\n\t\tip6mr_cache_resolve(net, mrt, uc, c);\n\t\tip6mr_cache_free(uc);\n\t}\n\tcall_ip6mr_mfc_entry_notifiers(net, FIB_EVENT_ENTRY_ADD,\n\t\t\t\t       c, mrt->id);\n\tmr6_netlink_event(mrt, c, RTM_NEWROUTE);\n\treturn 0;\n}\n\n \n\nstatic void mroute_clean_tables(struct mr_table *mrt, int flags)\n{\n\tstruct mr_mfc *c, *tmp;\n\tLIST_HEAD(list);\n\tint i;\n\n\t \n\tif (flags & (MRT6_FLUSH_MIFS | MRT6_FLUSH_MIFS_STATIC)) {\n\t\tfor (i = 0; i < mrt->maxvif; i++) {\n\t\t\tif (((mrt->vif_table[i].flags & VIFF_STATIC) &&\n\t\t\t     !(flags & MRT6_FLUSH_MIFS_STATIC)) ||\n\t\t\t    (!(mrt->vif_table[i].flags & VIFF_STATIC) && !(flags & MRT6_FLUSH_MIFS)))\n\t\t\t\tcontinue;\n\t\t\tmif6_delete(mrt, i, 0, &list);\n\t\t}\n\t\tunregister_netdevice_many(&list);\n\t}\n\n\t \n\tif (flags & (MRT6_FLUSH_MFC | MRT6_FLUSH_MFC_STATIC)) {\n\t\tlist_for_each_entry_safe(c, tmp, &mrt->mfc_cache_list, list) {\n\t\t\tif (((c->mfc_flags & MFC_STATIC) && !(flags & MRT6_FLUSH_MFC_STATIC)) ||\n\t\t\t    (!(c->mfc_flags & MFC_STATIC) && !(flags & MRT6_FLUSH_MFC)))\n\t\t\t\tcontinue;\n\t\t\trhltable_remove(&mrt->mfc_hash, &c->mnode, ip6mr_rht_params);\n\t\t\tlist_del_rcu(&c->list);\n\t\t\tcall_ip6mr_mfc_entry_notifiers(read_pnet(&mrt->net),\n\t\t\t\t\t\t       FIB_EVENT_ENTRY_DEL,\n\t\t\t\t\t\t       (struct mfc6_cache *)c, mrt->id);\n\t\t\tmr6_netlink_event(mrt, (struct mfc6_cache *)c, RTM_DELROUTE);\n\t\t\tmr_cache_put(c);\n\t\t}\n\t}\n\n\tif (flags & MRT6_FLUSH_MFC) {\n\t\tif (atomic_read(&mrt->cache_resolve_queue_len) != 0) {\n\t\t\tspin_lock_bh(&mfc_unres_lock);\n\t\t\tlist_for_each_entry_safe(c, tmp, &mrt->mfc_unres_queue, list) {\n\t\t\t\tlist_del(&c->list);\n\t\t\t\tmr6_netlink_event(mrt, (struct mfc6_cache *)c,\n\t\t\t\t\t\t  RTM_DELROUTE);\n\t\t\t\tip6mr_destroy_unres(mrt, (struct mfc6_cache *)c);\n\t\t\t}\n\t\t\tspin_unlock_bh(&mfc_unres_lock);\n\t\t}\n\t}\n}\n\nstatic int ip6mr_sk_init(struct mr_table *mrt, struct sock *sk)\n{\n\tint err = 0;\n\tstruct net *net = sock_net(sk);\n\n\trtnl_lock();\n\tspin_lock(&mrt_lock);\n\tif (rtnl_dereference(mrt->mroute_sk)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\trcu_assign_pointer(mrt->mroute_sk, sk);\n\t\tsock_set_flag(sk, SOCK_RCU_FREE);\n\t\tatomic_inc(&net->ipv6.devconf_all->mc_forwarding);\n\t}\n\tspin_unlock(&mrt_lock);\n\n\tif (!err)\n\t\tinet6_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t     NETCONFA_MC_FORWARDING,\n\t\t\t\t\t     NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t     net->ipv6.devconf_all);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nint ip6mr_sk_done(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6_devconf *devconf;\n\tstruct mr_table *mrt;\n\tint err = -EACCES;\n\n\tif (sk->sk_type != SOCK_RAW ||\n\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\treturn err;\n\n\tdevconf = net->ipv6.devconf_all;\n\tif (!devconf || !atomic_read(&devconf->mc_forwarding))\n\t\treturn err;\n\n\trtnl_lock();\n\tip6mr_for_each_table(mrt, net) {\n\t\tif (sk == rtnl_dereference(mrt->mroute_sk)) {\n\t\t\tspin_lock(&mrt_lock);\n\t\t\tRCU_INIT_POINTER(mrt->mroute_sk, NULL);\n\t\t\t \n\t\t\tatomic_dec(&devconf->mc_forwarding);\n\t\t\tspin_unlock(&mrt_lock);\n\t\t\tinet6_netconf_notify_devconf(net, RTM_NEWNETCONF,\n\t\t\t\t\t\t     NETCONFA_MC_FORWARDING,\n\t\t\t\t\t\t     NETCONFA_IFINDEX_ALL,\n\t\t\t\t\t\t     net->ipv6.devconf_all);\n\n\t\t\tmroute_clean_tables(mrt, MRT6_FLUSH_MIFS | MRT6_FLUSH_MFC);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\trtnl_unlock();\n\n\treturn err;\n}\n\nbool mroute6_is_socket(struct net *net, struct sk_buff *skb)\n{\n\tstruct mr_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif\t= skb->skb_iif ? : LOOPBACK_IFINDEX,\n\t\t.flowi6_oif\t= skb->dev->ifindex,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\n\tif (ip6mr_fib_lookup(net, &fl6, &mrt) < 0)\n\t\treturn NULL;\n\n\treturn rcu_access_pointer(mrt->mroute_sk);\n}\nEXPORT_SYMBOL(mroute6_is_socket);\n\n \n\nint ip6_mroute_setsockopt(struct sock *sk, int optname, sockptr_t optval,\n\t\t\t  unsigned int optlen)\n{\n\tint ret, parent = 0;\n\tstruct mif6ctl vif;\n\tstruct mf6cctl mfc;\n\tmifi_t mifi;\n\tstruct net *net = sock_net(sk);\n\tstruct mr_table *mrt;\n\n\tif (sk->sk_type != SOCK_RAW ||\n\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\treturn -EOPNOTSUPP;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tif (optname != MRT6_INIT) {\n\t\tif (sk != rcu_access_pointer(mrt->mroute_sk) &&\n\t\t    !ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t}\n\n\tswitch (optname) {\n\tcase MRT6_INIT:\n\t\tif (optlen < sizeof(int))\n\t\t\treturn -EINVAL;\n\n\t\treturn ip6mr_sk_init(mrt, sk);\n\n\tcase MRT6_DONE:\n\t\treturn ip6mr_sk_done(sk);\n\n\tcase MRT6_ADD_MIF:\n\t\tif (optlen < sizeof(vif))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&vif, optval, sizeof(vif)))\n\t\t\treturn -EFAULT;\n\t\tif (vif.mif6c_mifi >= MAXMIFS)\n\t\t\treturn -ENFILE;\n\t\trtnl_lock();\n\t\tret = mif6_add(net, mrt, &vif,\n\t\t\t       sk == rtnl_dereference(mrt->mroute_sk));\n\t\trtnl_unlock();\n\t\treturn ret;\n\n\tcase MRT6_DEL_MIF:\n\t\tif (optlen < sizeof(mifi_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&mifi, optval, sizeof(mifi_t)))\n\t\t\treturn -EFAULT;\n\t\trtnl_lock();\n\t\tret = mif6_delete(mrt, mifi, 0, NULL);\n\t\trtnl_unlock();\n\t\treturn ret;\n\n\t \n\tcase MRT6_ADD_MFC:\n\tcase MRT6_DEL_MFC:\n\t\tparent = -1;\n\t\tfallthrough;\n\tcase MRT6_ADD_MFC_PROXY:\n\tcase MRT6_DEL_MFC_PROXY:\n\t\tif (optlen < sizeof(mfc))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&mfc, optval, sizeof(mfc)))\n\t\t\treturn -EFAULT;\n\t\tif (parent == 0)\n\t\t\tparent = mfc.mf6cc_parent;\n\t\trtnl_lock();\n\t\tif (optname == MRT6_DEL_MFC || optname == MRT6_DEL_MFC_PROXY)\n\t\t\tret = ip6mr_mfc_delete(mrt, &mfc, parent);\n\t\telse\n\t\t\tret = ip6mr_mfc_add(net, mrt, &mfc,\n\t\t\t\t\t    sk ==\n\t\t\t\t\t    rtnl_dereference(mrt->mroute_sk),\n\t\t\t\t\t    parent);\n\t\trtnl_unlock();\n\t\treturn ret;\n\n\tcase MRT6_FLUSH:\n\t{\n\t\tint flags;\n\n\t\tif (optlen != sizeof(flags))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&flags, optval, sizeof(flags)))\n\t\t\treturn -EFAULT;\n\t\trtnl_lock();\n\t\tmroute_clean_tables(mrt, flags);\n\t\trtnl_unlock();\n\t\treturn 0;\n\t}\n\n\t \n\tcase MRT6_ASSERT:\n\t{\n\t\tint v;\n\n\t\tif (optlen != sizeof(v))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&v, optval, sizeof(v)))\n\t\t\treturn -EFAULT;\n\t\tmrt->mroute_do_assert = v;\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t{\n\t\tbool do_wrmifwhole;\n\t\tint v;\n\n\t\tif (optlen != sizeof(v))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&v, optval, sizeof(v)))\n\t\t\treturn -EFAULT;\n\n\t\tdo_wrmifwhole = (v == MRT6MSG_WRMIFWHOLE);\n\t\tv = !!v;\n\t\trtnl_lock();\n\t\tret = 0;\n\t\tif (v != mrt->mroute_do_pim) {\n\t\t\tmrt->mroute_do_pim = v;\n\t\t\tmrt->mroute_do_assert = v;\n\t\t\tmrt->mroute_do_wrvifwhole = do_wrmifwhole;\n\t\t}\n\t\trtnl_unlock();\n\t\treturn ret;\n\t}\n\n#endif\n#ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES\n\tcase MRT6_TABLE:\n\t{\n\t\tu32 v;\n\n\t\tif (optlen != sizeof(u32))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_sockptr(&v, optval, sizeof(v)))\n\t\t\treturn -EFAULT;\n\t\t \n\t\tif (v != RT_TABLE_DEFAULT && v >= 100000000)\n\t\t\treturn -EINVAL;\n\t\tif (sk == rcu_access_pointer(mrt->mroute_sk))\n\t\t\treturn -EBUSY;\n\n\t\trtnl_lock();\n\t\tret = 0;\n\t\tmrt = ip6mr_new_table(net, v);\n\t\tif (IS_ERR(mrt))\n\t\t\tret = PTR_ERR(mrt);\n\t\telse\n\t\t\traw6_sk(sk)->ip6mr_table = v;\n\t\trtnl_unlock();\n\t\treturn ret;\n\t}\n#endif\n\t \n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\n \n\nint ip6_mroute_getsockopt(struct sock *sk, int optname, sockptr_t optval,\n\t\t\t  sockptr_t optlen)\n{\n\tint olr;\n\tint val;\n\tstruct net *net = sock_net(sk);\n\tstruct mr_table *mrt;\n\n\tif (sk->sk_type != SOCK_RAW ||\n\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\treturn -EOPNOTSUPP;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tswitch (optname) {\n\tcase MRT6_VERSION:\n\t\tval = 0x0305;\n\t\tbreak;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t\tval = mrt->mroute_do_pim;\n\t\tbreak;\n#endif\n\tcase MRT6_ASSERT:\n\t\tval = mrt->mroute_do_assert;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (copy_from_sockptr(&olr, optlen, sizeof(int)))\n\t\treturn -EFAULT;\n\n\tolr = min_t(int, olr, sizeof(int));\n\tif (olr < 0)\n\t\treturn -EINVAL;\n\n\tif (copy_to_sockptr(optlen, &olr, sizeof(int)))\n\t\treturn -EFAULT;\n\tif (copy_to_sockptr(optval, &val, olr))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nint ip6mr_ioctl(struct sock *sk, int cmd, void *arg)\n{\n\tstruct sioc_sg_req6 *sr;\n\tstruct sioc_mif_req6 *vr;\n\tstruct vif_device *vif;\n\tstruct mfc6_cache *c;\n\tstruct net *net = sock_net(sk);\n\tstruct mr_table *mrt;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tswitch (cmd) {\n\tcase SIOCGETMIFCNT_IN6:\n\t\tvr = (struct sioc_mif_req6 *)arg;\n\t\tif (vr->mifi >= mrt->maxvif)\n\t\t\treturn -EINVAL;\n\t\tvr->mifi = array_index_nospec(vr->mifi, mrt->maxvif);\n\t\trcu_read_lock();\n\t\tvif = &mrt->vif_table[vr->mifi];\n\t\tif (VIF_EXISTS(mrt, vr->mifi)) {\n\t\t\tvr->icount = READ_ONCE(vif->pkt_in);\n\t\t\tvr->ocount = READ_ONCE(vif->pkt_out);\n\t\t\tvr->ibytes = READ_ONCE(vif->bytes_in);\n\t\t\tvr->obytes = READ_ONCE(vif->bytes_out);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\trcu_read_unlock();\n\t\treturn -EADDRNOTAVAIL;\n\tcase SIOCGETSGCNT_IN6:\n\t\tsr = (struct sioc_sg_req6 *)arg;\n\n\t\trcu_read_lock();\n\t\tc = ip6mr_cache_find(mrt, &sr->src.sin6_addr,\n\t\t\t\t     &sr->grp.sin6_addr);\n\t\tif (c) {\n\t\t\tsr->pktcnt = c->_c.mfc_un.res.pkt;\n\t\t\tsr->bytecnt = c->_c.mfc_un.res.bytes;\n\t\t\tsr->wrong_if = c->_c.mfc_un.res.wrong_if;\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\trcu_read_unlock();\n\t\treturn -EADDRNOTAVAIL;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstruct compat_sioc_sg_req6 {\n\tstruct sockaddr_in6 src;\n\tstruct sockaddr_in6 grp;\n\tcompat_ulong_t pktcnt;\n\tcompat_ulong_t bytecnt;\n\tcompat_ulong_t wrong_if;\n};\n\nstruct compat_sioc_mif_req6 {\n\tmifi_t\tmifi;\n\tcompat_ulong_t icount;\n\tcompat_ulong_t ocount;\n\tcompat_ulong_t ibytes;\n\tcompat_ulong_t obytes;\n};\n\nint ip6mr_compat_ioctl(struct sock *sk, unsigned int cmd, void __user *arg)\n{\n\tstruct compat_sioc_sg_req6 sr;\n\tstruct compat_sioc_mif_req6 vr;\n\tstruct vif_device *vif;\n\tstruct mfc6_cache *c;\n\tstruct net *net = sock_net(sk);\n\tstruct mr_table *mrt;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tswitch (cmd) {\n\tcase SIOCGETMIFCNT_IN6:\n\t\tif (copy_from_user(&vr, arg, sizeof(vr)))\n\t\t\treturn -EFAULT;\n\t\tif (vr.mifi >= mrt->maxvif)\n\t\t\treturn -EINVAL;\n\t\tvr.mifi = array_index_nospec(vr.mifi, mrt->maxvif);\n\t\trcu_read_lock();\n\t\tvif = &mrt->vif_table[vr.mifi];\n\t\tif (VIF_EXISTS(mrt, vr.mifi)) {\n\t\t\tvr.icount = READ_ONCE(vif->pkt_in);\n\t\t\tvr.ocount = READ_ONCE(vif->pkt_out);\n\t\t\tvr.ibytes = READ_ONCE(vif->bytes_in);\n\t\t\tvr.obytes = READ_ONCE(vif->bytes_out);\n\t\t\trcu_read_unlock();\n\n\t\t\tif (copy_to_user(arg, &vr, sizeof(vr)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t\trcu_read_unlock();\n\t\treturn -EADDRNOTAVAIL;\n\tcase SIOCGETSGCNT_IN6:\n\t\tif (copy_from_user(&sr, arg, sizeof(sr)))\n\t\t\treturn -EFAULT;\n\n\t\trcu_read_lock();\n\t\tc = ip6mr_cache_find(mrt, &sr.src.sin6_addr, &sr.grp.sin6_addr);\n\t\tif (c) {\n\t\t\tsr.pktcnt = c->_c.mfc_un.res.pkt;\n\t\t\tsr.bytecnt = c->_c.mfc_un.res.bytes;\n\t\t\tsr.wrong_if = c->_c.mfc_un.res.wrong_if;\n\t\t\trcu_read_unlock();\n\n\t\t\tif (copy_to_user(arg, &sr, sizeof(sr)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\t\trcu_read_unlock();\n\t\treturn -EADDRNOTAVAIL;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n#endif\n\nstatic inline int ip6mr_forward2_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tIP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t      IPSTATS_MIB_OUTFORWDATAGRAMS);\n\treturn dst_output(net, sk, skb);\n}\n\n \n\nstatic int ip6mr_forward2(struct net *net, struct mr_table *mrt,\n\t\t\t  struct sk_buff *skb, int vifi)\n{\n\tstruct vif_device *vif = &mrt->vif_table[vifi];\n\tstruct net_device *vif_dev;\n\tstruct ipv6hdr *ipv6h;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6;\n\n\tvif_dev = vif_dev_read(vif);\n\tif (!vif_dev)\n\t\tgoto out_free;\n\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tif (vif->flags & MIFF_REGISTER) {\n\t\tWRITE_ONCE(vif->pkt_out, vif->pkt_out + 1);\n\t\tWRITE_ONCE(vif->bytes_out, vif->bytes_out + skb->len);\n\t\tDEV_STATS_ADD(vif_dev, tx_bytes, skb->len);\n\t\tDEV_STATS_INC(vif_dev, tx_packets);\n\t\tip6mr_cache_report(mrt, skb, vifi, MRT6MSG_WHOLEPKT);\n\t\tgoto out_free;\n\t}\n#endif\n\n\tipv6h = ipv6_hdr(skb);\n\n\tfl6 = (struct flowi6) {\n\t\t.flowi6_oif = vif->link,\n\t\t.daddr = ipv6h->daddr,\n\t};\n\n\tdst = ip6_route_output(net, NULL, &fl6);\n\tif (dst->error) {\n\t\tdst_release(dst);\n\t\tgoto out_free;\n\t}\n\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, dst);\n\n\t \n\tskb->dev = vif_dev;\n\tWRITE_ONCE(vif->pkt_out, vif->pkt_out + 1);\n\tWRITE_ONCE(vif->bytes_out, vif->bytes_out + skb->len);\n\n\t \n\t \n\tif (skb_cow(skb, sizeof(*ipv6h) + LL_RESERVED_SPACE(vif_dev)))\n\t\tgoto out_free;\n\n\tipv6h = ipv6_hdr(skb);\n\tipv6h->hop_limit--;\n\n\tIP6CB(skb)->flags |= IP6SKB_FORWARDED;\n\n\treturn NF_HOOK(NFPROTO_IPV6, NF_INET_FORWARD,\n\t\t       net, NULL, skb, skb->dev, vif_dev,\n\t\t       ip6mr_forward2_finish);\n\nout_free:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n \nstatic int ip6mr_find_vif(struct mr_table *mrt, struct net_device *dev)\n{\n\tint ct;\n\n\t \n\tfor (ct = READ_ONCE(mrt->maxvif) - 1; ct >= 0; ct--) {\n\t\tif (rcu_access_pointer(mrt->vif_table[ct].dev) == dev)\n\t\t\tbreak;\n\t}\n\treturn ct;\n}\n\n \nstatic void ip6_mr_forward(struct net *net, struct mr_table *mrt,\n\t\t\t   struct net_device *dev, struct sk_buff *skb,\n\t\t\t   struct mfc6_cache *c)\n{\n\tint psend = -1;\n\tint vif, ct;\n\tint true_vifi = ip6mr_find_vif(mrt, dev);\n\n\tvif = c->_c.mfc_parent;\n\tc->_c.mfc_un.res.pkt++;\n\tc->_c.mfc_un.res.bytes += skb->len;\n\tc->_c.mfc_un.res.lastuse = jiffies;\n\n\tif (ipv6_addr_any(&c->mf6c_origin) && true_vifi >= 0) {\n\t\tstruct mfc6_cache *cache_proxy;\n\n\t\t \n\t\tcache_proxy = mr_mfc_find_any_parent(mrt, vif);\n\t\tif (cache_proxy &&\n\t\t    cache_proxy->_c.mfc_un.res.ttls[true_vifi] < 255)\n\t\t\tgoto forward;\n\t}\n\n\t \n\tif (rcu_access_pointer(mrt->vif_table[vif].dev) != dev) {\n\t\tc->_c.mfc_un.res.wrong_if++;\n\n\t\tif (true_vifi >= 0 && mrt->mroute_do_assert &&\n\t\t     \n\t\t    (mrt->mroute_do_pim ||\n\t\t     c->_c.mfc_un.res.ttls[true_vifi] < 255) &&\n\t\t    time_after(jiffies,\n\t\t\t       c->_c.mfc_un.res.last_assert +\n\t\t\t       MFC_ASSERT_THRESH)) {\n\t\t\tc->_c.mfc_un.res.last_assert = jiffies;\n\t\t\tip6mr_cache_report(mrt, skb, true_vifi, MRT6MSG_WRONGMIF);\n\t\t\tif (mrt->mroute_do_wrvifwhole)\n\t\t\t\tip6mr_cache_report(mrt, skb, true_vifi,\n\t\t\t\t\t\t   MRT6MSG_WRMIFWHOLE);\n\t\t}\n\t\tgoto dont_forward;\n\t}\n\nforward:\n\tWRITE_ONCE(mrt->vif_table[vif].pkt_in,\n\t\t   mrt->vif_table[vif].pkt_in + 1);\n\tWRITE_ONCE(mrt->vif_table[vif].bytes_in,\n\t\t   mrt->vif_table[vif].bytes_in + skb->len);\n\n\t \n\tif (ipv6_addr_any(&c->mf6c_origin) &&\n\t    ipv6_addr_any(&c->mf6c_mcastgrp)) {\n\t\tif (true_vifi >= 0 &&\n\t\t    true_vifi != c->_c.mfc_parent &&\n\t\t    ipv6_hdr(skb)->hop_limit >\n\t\t\t\tc->_c.mfc_un.res.ttls[c->_c.mfc_parent]) {\n\t\t\t \n\t\t\tpsend = c->_c.mfc_parent;\n\t\t\tgoto last_forward;\n\t\t}\n\t\tgoto dont_forward;\n\t}\n\tfor (ct = c->_c.mfc_un.res.maxvif - 1;\n\t     ct >= c->_c.mfc_un.res.minvif; ct--) {\n\t\t \n\t\tif ((!ipv6_addr_any(&c->mf6c_origin) || ct != true_vifi) &&\n\t\t    ipv6_hdr(skb)->hop_limit > c->_c.mfc_un.res.ttls[ct]) {\n\t\t\tif (psend != -1) {\n\t\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (skb2)\n\t\t\t\t\tip6mr_forward2(net, mrt, skb2, psend);\n\t\t\t}\n\t\t\tpsend = ct;\n\t\t}\n\t}\nlast_forward:\n\tif (psend != -1) {\n\t\tip6mr_forward2(net, mrt, skb, psend);\n\t\treturn;\n\t}\n\ndont_forward:\n\tkfree_skb(skb);\n}\n\n\n \n\nint ip6_mr_input(struct sk_buff *skb)\n{\n\tstruct mfc6_cache *cache;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct mr_table *mrt;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif\t= skb->dev->ifindex,\n\t\t.flowi6_mark\t= skb->mark,\n\t};\n\tint err;\n\tstruct net_device *dev;\n\n\t \n\tdev = skb->dev;\n\tif (netif_is_l3_master(skb->dev)) {\n\t\tdev = dev_get_by_index_rcu(net, IPCB(skb)->iif);\n\t\tif (!dev) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\terr = ip6mr_fib_lookup(net, &fl6, &mrt);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tcache = ip6mr_cache_find(mrt,\n\t\t\t\t &ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr);\n\tif (!cache) {\n\t\tint vif = ip6mr_find_vif(mrt, dev);\n\n\t\tif (vif >= 0)\n\t\t\tcache = ip6mr_cache_find_any(mrt,\n\t\t\t\t\t\t     &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t     vif);\n\t}\n\n\t \n\tif (!cache) {\n\t\tint vif;\n\n\t\tvif = ip6mr_find_vif(mrt, dev);\n\t\tif (vif >= 0) {\n\t\t\tint err = ip6mr_cache_unresolved(mrt, vif, skb, dev);\n\n\t\t\treturn err;\n\t\t}\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\tip6_mr_forward(net, mrt, dev, skb, cache);\n\n\treturn 0;\n}\n\nint ip6mr_get_route(struct net *net, struct sk_buff *skb, struct rtmsg *rtm,\n\t\t    u32 portid)\n{\n\tint err;\n\tstruct mr_table *mrt;\n\tstruct mfc6_cache *cache;\n\tstruct rt6_info *rt = (struct rt6_info *)skb_dst(skb);\n\n\tmrt = ip6mr_get_table(net, RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\trcu_read_lock();\n\tcache = ip6mr_cache_find(mrt, &rt->rt6i_src.addr, &rt->rt6i_dst.addr);\n\tif (!cache && skb->dev) {\n\t\tint vif = ip6mr_find_vif(mrt, skb->dev);\n\n\t\tif (vif >= 0)\n\t\t\tcache = ip6mr_cache_find_any(mrt, &rt->rt6i_dst.addr,\n\t\t\t\t\t\t     vif);\n\t}\n\n\tif (!cache) {\n\t\tstruct sk_buff *skb2;\n\t\tstruct ipv6hdr *iph;\n\t\tstruct net_device *dev;\n\t\tint vif;\n\n\t\tdev = skb->dev;\n\t\tif (!dev || (vif = ip6mr_find_vif(mrt, dev)) < 0) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tskb2 = alloc_skb(sizeof(struct ipv6hdr), GFP_ATOMIC);\n\t\tif (!skb2) {\n\t\t\trcu_read_unlock();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tNETLINK_CB(skb2).portid = portid;\n\t\tskb_reset_transport_header(skb2);\n\n\t\tskb_put(skb2, sizeof(struct ipv6hdr));\n\t\tskb_reset_network_header(skb2);\n\n\t\tiph = ipv6_hdr(skb2);\n\t\tiph->version = 0;\n\t\tiph->priority = 0;\n\t\tiph->flow_lbl[0] = 0;\n\t\tiph->flow_lbl[1] = 0;\n\t\tiph->flow_lbl[2] = 0;\n\t\tiph->payload_len = 0;\n\t\tiph->nexthdr = IPPROTO_NONE;\n\t\tiph->hop_limit = 0;\n\t\tiph->saddr = rt->rt6i_src.addr;\n\t\tiph->daddr = rt->rt6i_dst.addr;\n\n\t\terr = ip6mr_cache_unresolved(mrt, vif, skb2, dev);\n\t\trcu_read_unlock();\n\n\t\treturn err;\n\t}\n\n\terr = mr_fill_mroute(mrt, skb, &cache->_c, rtm);\n\trcu_read_unlock();\n\treturn err;\n}\n\nstatic int ip6mr_fill_mroute(struct mr_table *mrt, struct sk_buff *skb,\n\t\t\t     u32 portid, u32 seq, struct mfc6_cache *c, int cmd,\n\t\t\t     int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct rtmsg *rtm;\n\tint err;\n\n\tnlh = nlmsg_put(skb, portid, seq, cmd, sizeof(*rtm), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\trtm = nlmsg_data(nlh);\n\trtm->rtm_family   = RTNL_FAMILY_IP6MR;\n\trtm->rtm_dst_len  = 128;\n\trtm->rtm_src_len  = 128;\n\trtm->rtm_tos      = 0;\n\trtm->rtm_table    = mrt->id;\n\tif (nla_put_u32(skb, RTA_TABLE, mrt->id))\n\t\tgoto nla_put_failure;\n\trtm->rtm_type = RTN_MULTICAST;\n\trtm->rtm_scope    = RT_SCOPE_UNIVERSE;\n\tif (c->_c.mfc_flags & MFC_STATIC)\n\t\trtm->rtm_protocol = RTPROT_STATIC;\n\telse\n\t\trtm->rtm_protocol = RTPROT_MROUTED;\n\trtm->rtm_flags    = 0;\n\n\tif (nla_put_in6_addr(skb, RTA_SRC, &c->mf6c_origin) ||\n\t    nla_put_in6_addr(skb, RTA_DST, &c->mf6c_mcastgrp))\n\t\tgoto nla_put_failure;\n\terr = mr_fill_mroute(mrt, skb, &c->_c, rtm);\n\t \n\tif (err < 0 && err != -ENOENT)\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int _ip6mr_fill_mroute(struct mr_table *mrt, struct sk_buff *skb,\n\t\t\t      u32 portid, u32 seq, struct mr_mfc *c,\n\t\t\t      int cmd, int flags)\n{\n\treturn ip6mr_fill_mroute(mrt, skb, portid, seq, (struct mfc6_cache *)c,\n\t\t\t\t cmd, flags);\n}\n\nstatic int mr6_msgsize(bool unresolved, int maxvif)\n{\n\tsize_t len =\n\t\tNLMSG_ALIGN(sizeof(struct rtmsg))\n\t\t+ nla_total_size(4)\t \n\t\t+ nla_total_size(sizeof(struct in6_addr))\t \n\t\t+ nla_total_size(sizeof(struct in6_addr))\t \n\t\t;\n\n\tif (!unresolved)\n\t\tlen = len\n\t\t      + nla_total_size(4)\t \n\t\t      + nla_total_size(0)\t \n\t\t      + maxvif * NLA_ALIGN(sizeof(struct rtnexthop))\n\t\t\t\t\t\t \n\t\t      + nla_total_size_64bit(sizeof(struct rta_mfc_stats))\n\t\t;\n\n\treturn len;\n}\n\nstatic void mr6_netlink_event(struct mr_table *mrt, struct mfc6_cache *mfc,\n\t\t\t      int cmd)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(mr6_msgsize(mfc->_c.mfc_parent >= MAXMIFS, mrt->maxvif),\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = ip6mr_fill_mroute(mrt, skb, 0, 0, mfc, cmd, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV6_MROUTE, NULL, GFP_ATOMIC);\n\treturn;\n\nerrout:\n\tkfree_skb(skb);\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV6_MROUTE, err);\n}\n\nstatic size_t mrt6msg_netlink_msgsize(size_t payloadlen)\n{\n\tsize_t len =\n\t\tNLMSG_ALIGN(sizeof(struct rtgenmsg))\n\t\t+ nla_total_size(1)\t \n\t\t+ nla_total_size(4)\t \n\t\t\t\t\t \n\t\t+ nla_total_size(sizeof(struct in6_addr))\n\t\t\t\t\t \n\t\t+ nla_total_size(sizeof(struct in6_addr))\n\t\t\t\t\t \n\t\t+ nla_total_size(payloadlen)\n\t\t;\n\n\treturn len;\n}\n\nstatic void mrt6msg_netlink_event(const struct mr_table *mrt, struct sk_buff *pkt)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct nlmsghdr *nlh;\n\tstruct rtgenmsg *rtgenm;\n\tstruct mrt6msg *msg;\n\tstruct sk_buff *skb;\n\tstruct nlattr *nla;\n\tint payloadlen;\n\n\tpayloadlen = pkt->len - sizeof(struct mrt6msg);\n\tmsg = (struct mrt6msg *)skb_transport_header(pkt);\n\n\tskb = nlmsg_new(mrt6msg_netlink_msgsize(payloadlen), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\tnlh = nlmsg_put(skb, 0, 0, RTM_NEWCACHEREPORT,\n\t\t\tsizeof(struct rtgenmsg), 0);\n\tif (!nlh)\n\t\tgoto errout;\n\trtgenm = nlmsg_data(nlh);\n\trtgenm->rtgen_family = RTNL_FAMILY_IP6MR;\n\tif (nla_put_u8(skb, IP6MRA_CREPORT_MSGTYPE, msg->im6_msgtype) ||\n\t    nla_put_u32(skb, IP6MRA_CREPORT_MIF_ID, msg->im6_mif) ||\n\t    nla_put_in6_addr(skb, IP6MRA_CREPORT_SRC_ADDR,\n\t\t\t     &msg->im6_src) ||\n\t    nla_put_in6_addr(skb, IP6MRA_CREPORT_DST_ADDR,\n\t\t\t     &msg->im6_dst))\n\t\tgoto nla_put_failure;\n\n\tnla = nla_reserve(skb, IP6MRA_CREPORT_PKT, payloadlen);\n\tif (!nla || skb_copy_bits(pkt, sizeof(struct mrt6msg),\n\t\t\t\t  nla_data(nla), payloadlen))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV6_MROUTE_R, NULL, GFP_ATOMIC);\n\treturn;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\nerrout:\n\tkfree_skb(skb);\n\trtnl_set_sk_err(net, RTNLGRP_IPV6_MROUTE_R, -ENOBUFS);\n}\n\nstatic const struct nla_policy ip6mr_getroute_policy[RTA_MAX + 1] = {\n\t[RTA_SRC]\t\t= NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr)),\n\t[RTA_DST]\t\t= NLA_POLICY_EXACT_LEN(sizeof(struct in6_addr)),\n\t[RTA_TABLE]\t\t= { .type = NLA_U32 },\n};\n\nstatic int ip6mr_rtm_valid_getroute_req(struct sk_buff *skb,\n\t\t\t\t\tconst struct nlmsghdr *nlh,\n\t\t\t\t\tstruct nlattr **tb,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct rtmsg *rtm;\n\tint err;\n\n\terr = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, ip6mr_getroute_policy,\n\t\t\t  extack);\n\tif (err)\n\t\treturn err;\n\n\trtm = nlmsg_data(nlh);\n\tif ((rtm->rtm_src_len && rtm->rtm_src_len != 128) ||\n\t    (rtm->rtm_dst_len && rtm->rtm_dst_len != 128) ||\n\t    rtm->rtm_tos || rtm->rtm_table || rtm->rtm_protocol ||\n\t    rtm->rtm_scope || rtm->rtm_type || rtm->rtm_flags) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid values in header for multicast route get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((tb[RTA_SRC] && !rtm->rtm_src_len) ||\n\t    (tb[RTA_DST] && !rtm->rtm_dst_len)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"rtm_src_len and rtm_dst_len must be 128 for IPv6\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ip6mr_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct in6_addr src = {}, grp = {};\n\tstruct nlattr *tb[RTA_MAX + 1];\n\tstruct mfc6_cache *cache;\n\tstruct mr_table *mrt;\n\tstruct sk_buff *skb;\n\tu32 tableid;\n\tint err;\n\n\terr = ip6mr_rtm_valid_getroute_req(in_skb, nlh, tb, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[RTA_SRC])\n\t\tsrc = nla_get_in6_addr(tb[RTA_SRC]);\n\tif (tb[RTA_DST])\n\t\tgrp = nla_get_in6_addr(tb[RTA_DST]);\n\ttableid = tb[RTA_TABLE] ? nla_get_u32(tb[RTA_TABLE]) : 0;\n\n\tmrt = ip6mr_get_table(net, tableid ?: RT_TABLE_DEFAULT);\n\tif (!mrt) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"MR table does not exist\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\trcu_read_lock();\n\tcache = ip6mr_cache_find(mrt, &src, &grp);\n\trcu_read_unlock();\n\tif (!cache) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"MR cache entry not found\");\n\t\treturn -ENOENT;\n\t}\n\n\tskb = nlmsg_new(mr6_msgsize(false, mrt->maxvif), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\terr = ip6mr_fill_mroute(mrt, skb, NETLINK_CB(in_skb).portid,\n\t\t\t\tnlh->nlmsg_seq, cache, RTM_NEWROUTE, 0);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\treturn rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\n}\n\nstatic int ip6mr_rtm_dumproute(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct fib_dump_filter filter = {};\n\tint err;\n\n\tif (cb->strict_check) {\n\t\terr = ip_valid_fib_dump_req(sock_net(skb->sk), nlh,\n\t\t\t\t\t    &filter, cb);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (filter.table_id) {\n\t\tstruct mr_table *mrt;\n\n\t\tmrt = ip6mr_get_table(sock_net(skb->sk), filter.table_id);\n\t\tif (!mrt) {\n\t\t\tif (rtnl_msg_family(cb->nlh) != RTNL_FAMILY_IP6MR)\n\t\t\t\treturn skb->len;\n\n\t\t\tNL_SET_ERR_MSG_MOD(cb->extack, \"MR table does not exist\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\terr = mr_table_dump(mrt, skb, cb, _ip6mr_fill_mroute,\n\t\t\t\t    &mfc_unres_lock, &filter);\n\t\treturn skb->len ? : err;\n\t}\n\n\treturn mr_rtm_dumproute(skb, cb, ip6mr_mr_table_iter,\n\t\t\t\t_ip6mr_fill_mroute, &mfc_unres_lock, &filter);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}