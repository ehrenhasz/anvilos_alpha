{
  "module_name": "xfrm6_tunnel.c",
  "hash_id": "e28628f23575916ff1823226fa0954f7202a03befa533222de8266e72a023aef",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/xfrm6_tunnel.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/xfrm.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <net/ip.h>\n#include <net/xfrm.h>\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/mutex.h>\n#include <net/netns/generic.h>\n\n#define XFRM6_TUNNEL_SPI_BYADDR_HSIZE 256\n#define XFRM6_TUNNEL_SPI_BYSPI_HSIZE 256\n\n#define XFRM6_TUNNEL_SPI_MIN\t1\n#define XFRM6_TUNNEL_SPI_MAX\t0xffffffff\n\nstruct xfrm6_tunnel_net {\n\tstruct hlist_head spi_byaddr[XFRM6_TUNNEL_SPI_BYADDR_HSIZE];\n\tstruct hlist_head spi_byspi[XFRM6_TUNNEL_SPI_BYSPI_HSIZE];\n\tu32 spi;\n};\n\nstatic unsigned int xfrm6_tunnel_net_id __read_mostly;\nstatic inline struct xfrm6_tunnel_net *xfrm6_tunnel_pernet(struct net *net)\n{\n\treturn net_generic(net, xfrm6_tunnel_net_id);\n}\n\n \nstruct xfrm6_tunnel_spi {\n\tstruct hlist_node\tlist_byaddr;\n\tstruct hlist_node\tlist_byspi;\n\txfrm_address_t\t\taddr;\n\tu32\t\t\tspi;\n\trefcount_t\t\trefcnt;\n\tstruct rcu_head\t\trcu_head;\n};\n\nstatic DEFINE_SPINLOCK(xfrm6_tunnel_spi_lock);\n\nstatic struct kmem_cache *xfrm6_tunnel_spi_kmem __read_mostly;\n\nstatic inline unsigned int xfrm6_tunnel_spi_hash_byaddr(const xfrm_address_t *addr)\n{\n\tunsigned int h;\n\n\th = ipv6_addr_hash((const struct in6_addr *)addr);\n\th ^= h >> 16;\n\th ^= h >> 8;\n\th &= XFRM6_TUNNEL_SPI_BYADDR_HSIZE - 1;\n\n\treturn h;\n}\n\nstatic inline unsigned int xfrm6_tunnel_spi_hash_byspi(u32 spi)\n{\n\treturn spi % XFRM6_TUNNEL_SPI_BYSPI_HSIZE;\n}\n\nstatic struct xfrm6_tunnel_spi *__xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tstruct xfrm6_tunnel_spi *x6spi;\n\n\thlist_for_each_entry_rcu(x6spi,\n\t\t\t     &xfrm6_tn->spi_byaddr[xfrm6_tunnel_spi_hash_byaddr(saddr)],\n\t\t\t     list_byaddr, lockdep_is_held(&xfrm6_tunnel_spi_lock)) {\n\t\tif (xfrm6_addr_equal(&x6spi->addr, saddr))\n\t\t\treturn x6spi;\n\t}\n\n\treturn NULL;\n}\n\n__be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tu32 spi;\n\n\trcu_read_lock_bh();\n\tx6spi = __xfrm6_tunnel_spi_lookup(net, saddr);\n\tspi = x6spi ? x6spi->spi : 0;\n\trcu_read_unlock_bh();\n\treturn htonl(spi);\n}\nEXPORT_SYMBOL(xfrm6_tunnel_spi_lookup);\n\nstatic int __xfrm6_tunnel_spi_check(struct net *net, u32 spi)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tint index = xfrm6_tunnel_spi_hash_byspi(spi);\n\n\thlist_for_each_entry(x6spi,\n\t\t\t     &xfrm6_tn->spi_byspi[index],\n\t\t\t     list_byspi) {\n\t\tif (x6spi->spi == spi)\n\t\t\treturn -1;\n\t}\n\treturn index;\n}\n\nstatic u32 __xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tu32 spi;\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tint index;\n\n\tif (xfrm6_tn->spi < XFRM6_TUNNEL_SPI_MIN ||\n\t    xfrm6_tn->spi >= XFRM6_TUNNEL_SPI_MAX)\n\t\txfrm6_tn->spi = XFRM6_TUNNEL_SPI_MIN;\n\telse\n\t\txfrm6_tn->spi++;\n\n\tfor (spi = xfrm6_tn->spi; spi <= XFRM6_TUNNEL_SPI_MAX; spi++) {\n\t\tindex = __xfrm6_tunnel_spi_check(net, spi);\n\t\tif (index >= 0)\n\t\t\tgoto alloc_spi;\n\n\t\tif (spi == XFRM6_TUNNEL_SPI_MAX)\n\t\t\tbreak;\n\t}\n\tfor (spi = XFRM6_TUNNEL_SPI_MIN; spi < xfrm6_tn->spi; spi++) {\n\t\tindex = __xfrm6_tunnel_spi_check(net, spi);\n\t\tif (index >= 0)\n\t\t\tgoto alloc_spi;\n\t}\n\tspi = 0;\n\tgoto out;\nalloc_spi:\n\txfrm6_tn->spi = spi;\n\tx6spi = kmem_cache_alloc(xfrm6_tunnel_spi_kmem, GFP_ATOMIC);\n\tif (!x6spi)\n\t\tgoto out;\n\n\tmemcpy(&x6spi->addr, saddr, sizeof(x6spi->addr));\n\tx6spi->spi = spi;\n\trefcount_set(&x6spi->refcnt, 1);\n\n\thlist_add_head_rcu(&x6spi->list_byspi, &xfrm6_tn->spi_byspi[index]);\n\n\tindex = xfrm6_tunnel_spi_hash_byaddr(saddr);\n\thlist_add_head_rcu(&x6spi->list_byaddr, &xfrm6_tn->spi_byaddr[index]);\nout:\n\treturn spi;\n}\n\n__be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tu32 spi;\n\n\tspin_lock_bh(&xfrm6_tunnel_spi_lock);\n\tx6spi = __xfrm6_tunnel_spi_lookup(net, saddr);\n\tif (x6spi) {\n\t\trefcount_inc(&x6spi->refcnt);\n\t\tspi = x6spi->spi;\n\t} else\n\t\tspi = __xfrm6_tunnel_alloc_spi(net, saddr);\n\tspin_unlock_bh(&xfrm6_tunnel_spi_lock);\n\n\treturn htonl(spi);\n}\nEXPORT_SYMBOL(xfrm6_tunnel_alloc_spi);\n\nstatic void x6spi_destroy_rcu(struct rcu_head *head)\n{\n\tkmem_cache_free(xfrm6_tunnel_spi_kmem,\n\t\t\tcontainer_of(head, struct xfrm6_tunnel_spi, rcu_head));\n}\n\nstatic void xfrm6_tunnel_free_spi(struct net *net, xfrm_address_t *saddr)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tstruct xfrm6_tunnel_spi *x6spi;\n\tstruct hlist_node *n;\n\n\tspin_lock_bh(&xfrm6_tunnel_spi_lock);\n\n\thlist_for_each_entry_safe(x6spi, n,\n\t\t\t\t  &xfrm6_tn->spi_byaddr[xfrm6_tunnel_spi_hash_byaddr(saddr)],\n\t\t\t\t  list_byaddr)\n\t{\n\t\tif (xfrm6_addr_equal(&x6spi->addr, saddr)) {\n\t\t\tif (refcount_dec_and_test(&x6spi->refcnt)) {\n\t\t\t\thlist_del_rcu(&x6spi->list_byaddr);\n\t\t\t\thlist_del_rcu(&x6spi->list_byspi);\n\t\t\t\tcall_rcu(&x6spi->rcu_head, x6spi_destroy_rcu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&xfrm6_tunnel_spi_lock);\n}\n\nstatic int xfrm6_tunnel_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tskb_push(skb, -skb_network_offset(skb));\n\treturn 0;\n}\n\nstatic int xfrm6_tunnel_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\treturn skb_network_header(skb)[IP6CB(skb)->nhoff];\n}\n\nstatic int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\n\tspi = xfrm6_tunnel_spi_lookup(net, (const xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, IPPROTO_IPV6, spi, NULL);\n}\n\nstatic int xfrm6_tunnel_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t    u8 type, u8 code, int offset, __be32 info)\n{\n\t \n\tswitch (type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMPV6_NOROUTE:\n\t\tcase ICMPV6_ADM_PROHIBITED:\n\t\tcase ICMPV6_NOT_NEIGHBOUR:\n\t\tcase ICMPV6_ADDR_UNREACH:\n\t\tcase ICMPV6_PORT_UNREACH:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tbreak;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tswitch (code) {\n\t\tcase ICMPV6_EXC_HOPLIMIT:\n\t\t\tbreak;\n\t\tcase ICMPV6_EXC_FRAGTIME:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMPV6_PARAMPROB:\n\t\tswitch (code) {\n\t\tcase ICMPV6_HDR_FIELD: break;\n\t\tcase ICMPV6_UNK_NEXTHDR: break;\n\t\tcase ICMPV6_UNK_OPTION: break;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int xfrm6_tunnel_init_state(struct xfrm_state *x, struct netlink_ext_ack *extack)\n{\n\tif (x->props.mode != XFRM_MODE_TUNNEL) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv6 tunnel can only be used with tunnel mode\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (x->encap) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv6 tunnel is not compatible with encapsulation\");\n\t\treturn -EINVAL;\n\t}\n\n\tx->props.header_len = sizeof(struct ipv6hdr);\n\n\treturn 0;\n}\n\nstatic void xfrm6_tunnel_destroy(struct xfrm_state *x)\n{\n\tstruct net *net = xs_net(x);\n\n\txfrm6_tunnel_free_spi(net, (xfrm_address_t *)&x->props.saddr);\n}\n\nstatic const struct xfrm_type xfrm6_tunnel_type = {\n\t.owner          = THIS_MODULE,\n\t.proto\t\t= IPPROTO_IPV6,\n\t.init_state\t= xfrm6_tunnel_init_state,\n\t.destructor\t= xfrm6_tunnel_destroy,\n\t.input\t\t= xfrm6_tunnel_input,\n\t.output\t\t= xfrm6_tunnel_output,\n};\n\nstatic struct xfrm6_tunnel xfrm6_tunnel_handler __read_mostly = {\n\t.handler\t= xfrm6_tunnel_rcv,\n\t.err_handler\t= xfrm6_tunnel_err,\n\t.priority\t= 3,\n};\n\nstatic struct xfrm6_tunnel xfrm46_tunnel_handler __read_mostly = {\n\t.handler\t= xfrm6_tunnel_rcv,\n\t.err_handler\t= xfrm6_tunnel_err,\n\t.priority\t= 3,\n};\n\nstatic int __net_init xfrm6_tunnel_net_init(struct net *net)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tunsigned int i;\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYADDR_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&xfrm6_tn->spi_byaddr[i]);\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYSPI_HSIZE; i++)\n\t\tINIT_HLIST_HEAD(&xfrm6_tn->spi_byspi[i]);\n\txfrm6_tn->spi = 0;\n\n\treturn 0;\n}\n\nstatic void __net_exit xfrm6_tunnel_net_exit(struct net *net)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tunsigned int i;\n\n\txfrm_flush_gc();\n\txfrm_state_flush(net, 0, false, true);\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYADDR_HSIZE; i++)\n\t\tWARN_ON_ONCE(!hlist_empty(&xfrm6_tn->spi_byaddr[i]));\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYSPI_HSIZE; i++)\n\t\tWARN_ON_ONCE(!hlist_empty(&xfrm6_tn->spi_byspi[i]));\n}\n\nstatic struct pernet_operations xfrm6_tunnel_net_ops = {\n\t.init\t= xfrm6_tunnel_net_init,\n\t.exit\t= xfrm6_tunnel_net_exit,\n\t.id\t= &xfrm6_tunnel_net_id,\n\t.size\t= sizeof(struct xfrm6_tunnel_net),\n};\n\nstatic int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto out_pernet;\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto out_type;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto out_xfrm6;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto out_xfrm46;\n\treturn 0;\n\nout_xfrm46:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nout_xfrm6:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nout_type:\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\nout_pernet:\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n\treturn rv;\n}\n\nstatic void __exit xfrm6_tunnel_fini(void)\n{\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\t \n\trcu_barrier();\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}\n\nmodule_init(xfrm6_tunnel_init);\nmodule_exit(xfrm6_tunnel_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_XFRM_TYPE(AF_INET6, XFRM_PROTO_IPV6);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}