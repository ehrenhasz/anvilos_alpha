{
  "module_name": "ioam6.c",
  "hash_id": "c913c1cad73b7e8023ff258a4e1f547e3471401b0d59a0fb38aeec5edd8b4587",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ioam6.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/net.h>\n#include <linux/ioam6.h>\n#include <linux/ioam6_genl.h>\n#include <linux/rhashtable.h>\n#include <linux/netdevice.h>\n\n#include <net/addrconf.h>\n#include <net/genetlink.h>\n#include <net/ioam6.h>\n#include <net/sch_generic.h>\n\nstatic void ioam6_ns_release(struct ioam6_namespace *ns)\n{\n\tkfree_rcu(ns, rcu);\n}\n\nstatic void ioam6_sc_release(struct ioam6_schema *sc)\n{\n\tkfree_rcu(sc, rcu);\n}\n\nstatic void ioam6_free_ns(void *ptr, void *arg)\n{\n\tstruct ioam6_namespace *ns = (struct ioam6_namespace *)ptr;\n\n\tif (ns)\n\t\tioam6_ns_release(ns);\n}\n\nstatic void ioam6_free_sc(void *ptr, void *arg)\n{\n\tstruct ioam6_schema *sc = (struct ioam6_schema *)ptr;\n\n\tif (sc)\n\t\tioam6_sc_release(sc);\n}\n\nstatic int ioam6_ns_cmpfn(struct rhashtable_compare_arg *arg, const void *obj)\n{\n\tconst struct ioam6_namespace *ns = obj;\n\n\treturn (ns->id != *(__be16 *)arg->key);\n}\n\nstatic int ioam6_sc_cmpfn(struct rhashtable_compare_arg *arg, const void *obj)\n{\n\tconst struct ioam6_schema *sc = obj;\n\n\treturn (sc->id != *(u32 *)arg->key);\n}\n\nstatic const struct rhashtable_params rht_ns_params = {\n\t.key_len\t\t= sizeof(__be16),\n\t.key_offset\t\t= offsetof(struct ioam6_namespace, id),\n\t.head_offset\t\t= offsetof(struct ioam6_namespace, head),\n\t.automatic_shrinking\t= true,\n\t.obj_cmpfn\t\t= ioam6_ns_cmpfn,\n};\n\nstatic const struct rhashtable_params rht_sc_params = {\n\t.key_len\t\t= sizeof(u32),\n\t.key_offset\t\t= offsetof(struct ioam6_schema, id),\n\t.head_offset\t\t= offsetof(struct ioam6_schema, head),\n\t.automatic_shrinking\t= true,\n\t.obj_cmpfn\t\t= ioam6_sc_cmpfn,\n};\n\nstatic struct genl_family ioam6_genl_family;\n\nstatic const struct nla_policy ioam6_genl_policy_addns[] = {\n\t[IOAM6_ATTR_NS_ID]\t= { .type = NLA_U16 },\n\t[IOAM6_ATTR_NS_DATA]\t= { .type = NLA_U32 },\n\t[IOAM6_ATTR_NS_DATA_WIDE] = { .type = NLA_U64 },\n};\n\nstatic const struct nla_policy ioam6_genl_policy_delns[] = {\n\t[IOAM6_ATTR_NS_ID]\t= { .type = NLA_U16 },\n};\n\nstatic const struct nla_policy ioam6_genl_policy_addsc[] = {\n\t[IOAM6_ATTR_SC_ID]\t= { .type = NLA_U32 },\n\t[IOAM6_ATTR_SC_DATA]\t= { .type = NLA_BINARY,\n\t\t\t\t    .len = IOAM6_MAX_SCHEMA_DATA_LEN },\n};\n\nstatic const struct nla_policy ioam6_genl_policy_delsc[] = {\n\t[IOAM6_ATTR_SC_ID]\t= { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy ioam6_genl_policy_ns_sc[] = {\n\t[IOAM6_ATTR_NS_ID]\t= { .type = NLA_U16 },\n\t[IOAM6_ATTR_SC_ID]\t= { .type = NLA_U32 },\n\t[IOAM6_ATTR_SC_NONE]\t= { .type = NLA_FLAG },\n};\n\nstatic int ioam6_genl_addns(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ioam6_pernet_data *nsdata;\n\tstruct ioam6_namespace *ns;\n\tu64 data64;\n\tu32 data32;\n\t__be16 id;\n\tint err;\n\n\tif (!info->attrs[IOAM6_ATTR_NS_ID])\n\t\treturn -EINVAL;\n\n\tid = cpu_to_be16(nla_get_u16(info->attrs[IOAM6_ATTR_NS_ID]));\n\tnsdata = ioam6_pernet(genl_info_net(info));\n\n\tmutex_lock(&nsdata->lock);\n\n\tns = rhashtable_lookup_fast(&nsdata->namespaces, &id, rht_ns_params);\n\tif (ns) {\n\t\terr = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tns = kzalloc(sizeof(*ns), GFP_KERNEL);\n\tif (!ns) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tns->id = id;\n\n\tif (!info->attrs[IOAM6_ATTR_NS_DATA])\n\t\tdata32 = IOAM6_U32_UNAVAILABLE;\n\telse\n\t\tdata32 = nla_get_u32(info->attrs[IOAM6_ATTR_NS_DATA]);\n\n\tif (!info->attrs[IOAM6_ATTR_NS_DATA_WIDE])\n\t\tdata64 = IOAM6_U64_UNAVAILABLE;\n\telse\n\t\tdata64 = nla_get_u64(info->attrs[IOAM6_ATTR_NS_DATA_WIDE]);\n\n\tns->data = cpu_to_be32(data32);\n\tns->data_wide = cpu_to_be64(data64);\n\n\terr = rhashtable_lookup_insert_fast(&nsdata->namespaces, &ns->head,\n\t\t\t\t\t    rht_ns_params);\n\tif (err)\n\t\tkfree(ns);\n\nout_unlock:\n\tmutex_unlock(&nsdata->lock);\n\treturn err;\n}\n\nstatic int ioam6_genl_delns(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ioam6_pernet_data *nsdata;\n\tstruct ioam6_namespace *ns;\n\tstruct ioam6_schema *sc;\n\t__be16 id;\n\tint err;\n\n\tif (!info->attrs[IOAM6_ATTR_NS_ID])\n\t\treturn -EINVAL;\n\n\tid = cpu_to_be16(nla_get_u16(info->attrs[IOAM6_ATTR_NS_ID]));\n\tnsdata = ioam6_pernet(genl_info_net(info));\n\n\tmutex_lock(&nsdata->lock);\n\n\tns = rhashtable_lookup_fast(&nsdata->namespaces, &id, rht_ns_params);\n\tif (!ns) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\tsc = rcu_dereference_protected(ns->schema,\n\t\t\t\t       lockdep_is_held(&nsdata->lock));\n\n\terr = rhashtable_remove_fast(&nsdata->namespaces, &ns->head,\n\t\t\t\t     rht_ns_params);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tif (sc)\n\t\trcu_assign_pointer(sc->ns, NULL);\n\n\tioam6_ns_release(ns);\n\nout_unlock:\n\tmutex_unlock(&nsdata->lock);\n\treturn err;\n}\n\nstatic int __ioam6_genl_dumpns_element(struct ioam6_namespace *ns,\n\t\t\t\t       u32 portid,\n\t\t\t\t       u32 seq,\n\t\t\t\t       u32 flags,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       u8 cmd)\n{\n\tstruct ioam6_schema *sc;\n\tu64 data64;\n\tu32 data32;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, portid, seq, &ioam6_genl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tdata32 = be32_to_cpu(ns->data);\n\tdata64 = be64_to_cpu(ns->data_wide);\n\n\tif (nla_put_u16(skb, IOAM6_ATTR_NS_ID, be16_to_cpu(ns->id)) ||\n\t    (data32 != IOAM6_U32_UNAVAILABLE &&\n\t     nla_put_u32(skb, IOAM6_ATTR_NS_DATA, data32)) ||\n\t    (data64 != IOAM6_U64_UNAVAILABLE &&\n\t     nla_put_u64_64bit(skb, IOAM6_ATTR_NS_DATA_WIDE,\n\t\t\t       data64, IOAM6_ATTR_PAD)))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\n\tsc = rcu_dereference(ns->schema);\n\tif (sc && nla_put_u32(skb, IOAM6_ATTR_SC_ID, sc->id)) {\n\t\trcu_read_unlock();\n\t\tgoto nla_put_failure;\n\t}\n\n\trcu_read_unlock();\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ioam6_genl_dumpns_start(struct netlink_callback *cb)\n{\n\tstruct ioam6_pernet_data *nsdata = ioam6_pernet(sock_net(cb->skb->sk));\n\tstruct rhashtable_iter *iter = (struct rhashtable_iter *)cb->args[0];\n\n\tif (!iter) {\n\t\titer = kmalloc(sizeof(*iter), GFP_KERNEL);\n\t\tif (!iter)\n\t\t\treturn -ENOMEM;\n\n\t\tcb->args[0] = (long)iter;\n\t}\n\n\trhashtable_walk_enter(&nsdata->namespaces, iter);\n\n\treturn 0;\n}\n\nstatic int ioam6_genl_dumpns_done(struct netlink_callback *cb)\n{\n\tstruct rhashtable_iter *iter = (struct rhashtable_iter *)cb->args[0];\n\n\trhashtable_walk_exit(iter);\n\tkfree(iter);\n\n\treturn 0;\n}\n\nstatic int ioam6_genl_dumpns(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct rhashtable_iter *iter;\n\tstruct ioam6_namespace *ns;\n\tint err;\n\n\titer = (struct rhashtable_iter *)cb->args[0];\n\trhashtable_walk_start(iter);\n\n\tfor (;;) {\n\t\tns = rhashtable_walk_next(iter);\n\n\t\tif (IS_ERR(ns)) {\n\t\t\tif (PTR_ERR(ns) == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\terr = PTR_ERR(ns);\n\t\t\tgoto done;\n\t\t} else if (!ns) {\n\t\t\tbreak;\n\t\t}\n\n\t\terr = __ioam6_genl_dumpns_element(ns,\n\t\t\t\t\t\t  NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t  cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t  NLM_F_MULTI,\n\t\t\t\t\t\t  skb,\n\t\t\t\t\t\t  IOAM6_CMD_DUMP_NAMESPACES);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\terr = skb->len;\n\ndone:\n\trhashtable_walk_stop(iter);\n\treturn err;\n}\n\nstatic int ioam6_genl_addsc(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ioam6_pernet_data *nsdata;\n\tint len, len_aligned, err;\n\tstruct ioam6_schema *sc;\n\tu32 id;\n\n\tif (!info->attrs[IOAM6_ATTR_SC_ID] || !info->attrs[IOAM6_ATTR_SC_DATA])\n\t\treturn -EINVAL;\n\n\tid = nla_get_u32(info->attrs[IOAM6_ATTR_SC_ID]);\n\tnsdata = ioam6_pernet(genl_info_net(info));\n\n\tmutex_lock(&nsdata->lock);\n\n\tsc = rhashtable_lookup_fast(&nsdata->schemas, &id, rht_sc_params);\n\tif (sc) {\n\t\terr = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\tlen = nla_len(info->attrs[IOAM6_ATTR_SC_DATA]);\n\tlen_aligned = ALIGN(len, 4);\n\n\tsc = kzalloc(sizeof(*sc) + len_aligned, GFP_KERNEL);\n\tif (!sc) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tsc->id = id;\n\tsc->len = len_aligned;\n\tsc->hdr = cpu_to_be32(sc->id | ((u8)(sc->len / 4) << 24));\n\tnla_memcpy(sc->data, info->attrs[IOAM6_ATTR_SC_DATA], len);\n\n\terr = rhashtable_lookup_insert_fast(&nsdata->schemas, &sc->head,\n\t\t\t\t\t    rht_sc_params);\n\tif (err)\n\t\tgoto free_sc;\n\nout_unlock:\n\tmutex_unlock(&nsdata->lock);\n\treturn err;\nfree_sc:\n\tkfree(sc);\n\tgoto out_unlock;\n}\n\nstatic int ioam6_genl_delsc(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ioam6_pernet_data *nsdata;\n\tstruct ioam6_namespace *ns;\n\tstruct ioam6_schema *sc;\n\tint err;\n\tu32 id;\n\n\tif (!info->attrs[IOAM6_ATTR_SC_ID])\n\t\treturn -EINVAL;\n\n\tid = nla_get_u32(info->attrs[IOAM6_ATTR_SC_ID]);\n\tnsdata = ioam6_pernet(genl_info_net(info));\n\n\tmutex_lock(&nsdata->lock);\n\n\tsc = rhashtable_lookup_fast(&nsdata->schemas, &id, rht_sc_params);\n\tif (!sc) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\tns = rcu_dereference_protected(sc->ns, lockdep_is_held(&nsdata->lock));\n\n\terr = rhashtable_remove_fast(&nsdata->schemas, &sc->head,\n\t\t\t\t     rht_sc_params);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tif (ns)\n\t\trcu_assign_pointer(ns->schema, NULL);\n\n\tioam6_sc_release(sc);\n\nout_unlock:\n\tmutex_unlock(&nsdata->lock);\n\treturn err;\n}\n\nstatic int __ioam6_genl_dumpsc_element(struct ioam6_schema *sc,\n\t\t\t\t       u32 portid, u32 seq, u32 flags,\n\t\t\t\t       struct sk_buff *skb, u8 cmd)\n{\n\tstruct ioam6_namespace *ns;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, portid, seq, &ioam6_genl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tif (nla_put_u32(skb, IOAM6_ATTR_SC_ID, sc->id) ||\n\t    nla_put(skb, IOAM6_ATTR_SC_DATA, sc->len, sc->data))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\n\tns = rcu_dereference(sc->ns);\n\tif (ns && nla_put_u16(skb, IOAM6_ATTR_NS_ID, be16_to_cpu(ns->id))) {\n\t\trcu_read_unlock();\n\t\tgoto nla_put_failure;\n\t}\n\n\trcu_read_unlock();\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int ioam6_genl_dumpsc_start(struct netlink_callback *cb)\n{\n\tstruct ioam6_pernet_data *nsdata = ioam6_pernet(sock_net(cb->skb->sk));\n\tstruct rhashtable_iter *iter = (struct rhashtable_iter *)cb->args[0];\n\n\tif (!iter) {\n\t\titer = kmalloc(sizeof(*iter), GFP_KERNEL);\n\t\tif (!iter)\n\t\t\treturn -ENOMEM;\n\n\t\tcb->args[0] = (long)iter;\n\t}\n\n\trhashtable_walk_enter(&nsdata->schemas, iter);\n\n\treturn 0;\n}\n\nstatic int ioam6_genl_dumpsc_done(struct netlink_callback *cb)\n{\n\tstruct rhashtable_iter *iter = (struct rhashtable_iter *)cb->args[0];\n\n\trhashtable_walk_exit(iter);\n\tkfree(iter);\n\n\treturn 0;\n}\n\nstatic int ioam6_genl_dumpsc(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct rhashtable_iter *iter;\n\tstruct ioam6_schema *sc;\n\tint err;\n\n\titer = (struct rhashtable_iter *)cb->args[0];\n\trhashtable_walk_start(iter);\n\n\tfor (;;) {\n\t\tsc = rhashtable_walk_next(iter);\n\n\t\tif (IS_ERR(sc)) {\n\t\t\tif (PTR_ERR(sc) == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\terr = PTR_ERR(sc);\n\t\t\tgoto done;\n\t\t} else if (!sc) {\n\t\t\tbreak;\n\t\t}\n\n\t\terr = __ioam6_genl_dumpsc_element(sc,\n\t\t\t\t\t\t  NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t  cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t  NLM_F_MULTI,\n\t\t\t\t\t\t  skb,\n\t\t\t\t\t\t  IOAM6_CMD_DUMP_SCHEMAS);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\terr = skb->len;\n\ndone:\n\trhashtable_walk_stop(iter);\n\treturn err;\n}\n\nstatic int ioam6_genl_ns_set_schema(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct ioam6_namespace *ns, *ns_ref;\n\tstruct ioam6_schema *sc, *sc_ref;\n\tstruct ioam6_pernet_data *nsdata;\n\t__be16 ns_id;\n\tu32 sc_id;\n\tint err;\n\n\tif (!info->attrs[IOAM6_ATTR_NS_ID] ||\n\t    (!info->attrs[IOAM6_ATTR_SC_ID] &&\n\t     !info->attrs[IOAM6_ATTR_SC_NONE]))\n\t\treturn -EINVAL;\n\n\tns_id = cpu_to_be16(nla_get_u16(info->attrs[IOAM6_ATTR_NS_ID]));\n\tnsdata = ioam6_pernet(genl_info_net(info));\n\n\tmutex_lock(&nsdata->lock);\n\n\tns = rhashtable_lookup_fast(&nsdata->namespaces, &ns_id, rht_ns_params);\n\tif (!ns) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\tif (info->attrs[IOAM6_ATTR_SC_NONE]) {\n\t\tsc = NULL;\n\t} else {\n\t\tsc_id = nla_get_u32(info->attrs[IOAM6_ATTR_SC_ID]);\n\t\tsc = rhashtable_lookup_fast(&nsdata->schemas, &sc_id,\n\t\t\t\t\t    rht_sc_params);\n\t\tif (!sc) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tsc_ref = rcu_dereference_protected(ns->schema,\n\t\t\t\t\t   lockdep_is_held(&nsdata->lock));\n\tif (sc_ref)\n\t\trcu_assign_pointer(sc_ref->ns, NULL);\n\trcu_assign_pointer(ns->schema, sc);\n\n\tif (sc) {\n\t\tns_ref = rcu_dereference_protected(sc->ns,\n\t\t\t\t\t\t   lockdep_is_held(&nsdata->lock));\n\t\tif (ns_ref)\n\t\t\trcu_assign_pointer(ns_ref->schema, NULL);\n\t\trcu_assign_pointer(sc->ns, ns);\n\t}\n\n\terr = 0;\n\nout_unlock:\n\tmutex_unlock(&nsdata->lock);\n\treturn err;\n}\n\nstatic const struct genl_ops ioam6_genl_ops[] = {\n\t{\n\t\t.cmd\t= IOAM6_CMD_ADD_NAMESPACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit\t= ioam6_genl_addns,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ioam6_genl_policy_addns,\n\t\t.maxattr = ARRAY_SIZE(ioam6_genl_policy_addns) - 1,\n\t},\n\t{\n\t\t.cmd\t= IOAM6_CMD_DEL_NAMESPACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit\t= ioam6_genl_delns,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ioam6_genl_policy_delns,\n\t\t.maxattr = ARRAY_SIZE(ioam6_genl_policy_delns) - 1,\n\t},\n\t{\n\t\t.cmd\t= IOAM6_CMD_DUMP_NAMESPACES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.start\t= ioam6_genl_dumpns_start,\n\t\t.dumpit\t= ioam6_genl_dumpns,\n\t\t.done\t= ioam6_genl_dumpns_done,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd\t= IOAM6_CMD_ADD_SCHEMA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit\t= ioam6_genl_addsc,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ioam6_genl_policy_addsc,\n\t\t.maxattr = ARRAY_SIZE(ioam6_genl_policy_addsc) - 1,\n\t},\n\t{\n\t\t.cmd\t= IOAM6_CMD_DEL_SCHEMA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit\t= ioam6_genl_delsc,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ioam6_genl_policy_delsc,\n\t\t.maxattr = ARRAY_SIZE(ioam6_genl_policy_delsc) - 1,\n\t},\n\t{\n\t\t.cmd\t= IOAM6_CMD_DUMP_SCHEMAS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.start\t= ioam6_genl_dumpsc_start,\n\t\t.dumpit\t= ioam6_genl_dumpsc,\n\t\t.done\t= ioam6_genl_dumpsc_done,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd\t= IOAM6_CMD_NS_SET_SCHEMA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit\t= ioam6_genl_ns_set_schema,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t\t.policy\t= ioam6_genl_policy_ns_sc,\n\t\t.maxattr = ARRAY_SIZE(ioam6_genl_policy_ns_sc) - 1,\n\t},\n};\n\nstatic struct genl_family ioam6_genl_family __ro_after_init = {\n\t.name\t\t= IOAM6_GENL_NAME,\n\t.version\t= IOAM6_GENL_VERSION,\n\t.netnsok\t= true,\n\t.parallel_ops\t= true,\n\t.ops\t\t= ioam6_genl_ops,\n\t.n_ops\t\t= ARRAY_SIZE(ioam6_genl_ops),\n\t.resv_start_op\t= IOAM6_CMD_NS_SET_SCHEMA + 1,\n\t.module\t\t= THIS_MODULE,\n};\n\nstruct ioam6_namespace *ioam6_namespace(struct net *net, __be16 id)\n{\n\tstruct ioam6_pernet_data *nsdata = ioam6_pernet(net);\n\n\treturn rhashtable_lookup_fast(&nsdata->namespaces, &id, rht_ns_params);\n}\n\nstatic void __ioam6_fill_trace_data(struct sk_buff *skb,\n\t\t\t\t    struct ioam6_namespace *ns,\n\t\t\t\t    struct ioam6_trace_hdr *trace,\n\t\t\t\t    struct ioam6_schema *sc,\n\t\t\t\t    u8 sclen, bool is_input)\n{\n\tstruct timespec64 ts;\n\tktime_t tstamp;\n\tu64 raw64;\n\tu32 raw32;\n\tu16 raw16;\n\tu8 *data;\n\tu8 byte;\n\n\tdata = trace->data + trace->remlen * 4 - trace->nodelen * 4 - sclen * 4;\n\n\t \n\tif (trace->type.bit0) {\n\t\tbyte = ipv6_hdr(skb)->hop_limit;\n\t\tif (is_input)\n\t\t\tbyte--;\n\n\t\traw32 = dev_net(skb_dst(skb)->dev)->ipv6.sysctl.ioam6_id;\n\n\t\t*(__be32 *)data = cpu_to_be32((byte << 24) | raw32);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit1) {\n\t\tif (!skb->dev)\n\t\t\traw16 = IOAM6_U16_UNAVAILABLE;\n\t\telse\n\t\t\traw16 = (__force u16)__in6_dev_get(skb->dev)->cnf.ioam6_id;\n\n\t\t*(__be16 *)data = cpu_to_be16(raw16);\n\t\tdata += sizeof(__be16);\n\n\t\tif (skb_dst(skb)->dev->flags & IFF_LOOPBACK)\n\t\t\traw16 = IOAM6_U16_UNAVAILABLE;\n\t\telse\n\t\t\traw16 = (__force u16)__in6_dev_get(skb_dst(skb)->dev)->cnf.ioam6_id;\n\n\t\t*(__be16 *)data = cpu_to_be16(raw16);\n\t\tdata += sizeof(__be16);\n\t}\n\n\t \n\tif (trace->type.bit2) {\n\t\tif (!skb->dev) {\n\t\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\t} else {\n\t\t\ttstamp = skb_tstamp_cond(skb, true);\n\t\t\tts = ktime_to_timespec64(tstamp);\n\n\t\t\t*(__be32 *)data = cpu_to_be32((u32)ts.tv_sec);\n\t\t}\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit3) {\n\t\tif (!skb->dev) {\n\t\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\t} else {\n\t\t\tif (!trace->type.bit2) {\n\t\t\t\ttstamp = skb_tstamp_cond(skb, true);\n\t\t\t\tts = ktime_to_timespec64(tstamp);\n\t\t\t}\n\n\t\t\t*(__be32 *)data = cpu_to_be32((u32)(ts.tv_nsec / NSEC_PER_USEC));\n\t\t}\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit4) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit5) {\n\t\t*(__be32 *)data = ns->data;\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit6) {\n\t\tstruct netdev_queue *queue;\n\t\tstruct Qdisc *qdisc;\n\t\t__u32 qlen, backlog;\n\n\t\tif (skb_dst(skb)->dev->flags & IFF_LOOPBACK) {\n\t\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\t} else {\n\t\t\tqueue = skb_get_tx_queue(skb_dst(skb)->dev, skb);\n\t\t\tqdisc = rcu_dereference(queue->qdisc);\n\t\t\tqdisc_qstats_qlen_backlog(qdisc, &qlen, &backlog);\n\n\t\t\t*(__be32 *)data = cpu_to_be32(backlog);\n\t\t}\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit7) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit8) {\n\t\tbyte = ipv6_hdr(skb)->hop_limit;\n\t\tif (is_input)\n\t\t\tbyte--;\n\n\t\traw64 = dev_net(skb_dst(skb)->dev)->ipv6.sysctl.ioam6_id_wide;\n\n\t\t*(__be64 *)data = cpu_to_be64(((u64)byte << 56) | raw64);\n\t\tdata += sizeof(__be64);\n\t}\n\n\t \n\tif (trace->type.bit9) {\n\t\tif (!skb->dev)\n\t\t\traw32 = IOAM6_U32_UNAVAILABLE;\n\t\telse\n\t\t\traw32 = __in6_dev_get(skb->dev)->cnf.ioam6_id_wide;\n\n\t\t*(__be32 *)data = cpu_to_be32(raw32);\n\t\tdata += sizeof(__be32);\n\n\t\tif (skb_dst(skb)->dev->flags & IFF_LOOPBACK)\n\t\t\traw32 = IOAM6_U32_UNAVAILABLE;\n\t\telse\n\t\t\traw32 = __in6_dev_get(skb_dst(skb)->dev)->cnf.ioam6_id_wide;\n\n\t\t*(__be32 *)data = cpu_to_be32(raw32);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit10) {\n\t\t*(__be64 *)data = ns->data_wide;\n\t\tdata += sizeof(__be64);\n\t}\n\n\t \n\tif (trace->type.bit11) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit12) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit13) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit14) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit15) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit16) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit17) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit18) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit19) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit20) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit21) {\n\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE);\n\t\tdata += sizeof(__be32);\n\t}\n\n\t \n\tif (trace->type.bit22) {\n\t\tif (!sc) {\n\t\t\t*(__be32 *)data = cpu_to_be32(IOAM6_U32_UNAVAILABLE >> 8);\n\t\t} else {\n\t\t\t*(__be32 *)data = sc->hdr;\n\t\t\tdata += sizeof(__be32);\n\n\t\t\tmemcpy(data, sc->data, sc->len);\n\t\t}\n\t}\n}\n\n \nvoid ioam6_fill_trace_data(struct sk_buff *skb,\n\t\t\t   struct ioam6_namespace *ns,\n\t\t\t   struct ioam6_trace_hdr *trace,\n\t\t\t   bool is_input)\n{\n\tstruct ioam6_schema *sc;\n\tu8 sclen = 0;\n\n\t \n\tif (trace->overflow)\n\t\treturn;\n\n\t \n\tsc = rcu_dereference(ns->schema);\n\tif (trace->type.bit22) {\n\t\tsclen = sizeof_field(struct ioam6_schema, hdr) / 4;\n\n\t\tif (sc)\n\t\t\tsclen += sc->len / 4;\n\t}\n\n\t \n\tif (!trace->remlen || trace->remlen < trace->nodelen + sclen) {\n\t\ttrace->overflow = 1;\n\t\treturn;\n\t}\n\n\t__ioam6_fill_trace_data(skb, ns, trace, sc, sclen, is_input);\n\ttrace->remlen -= trace->nodelen + sclen;\n}\n\nstatic int __net_init ioam6_net_init(struct net *net)\n{\n\tstruct ioam6_pernet_data *nsdata;\n\tint err = -ENOMEM;\n\n\tnsdata = kzalloc(sizeof(*nsdata), GFP_KERNEL);\n\tif (!nsdata)\n\t\tgoto out;\n\n\tmutex_init(&nsdata->lock);\n\tnet->ipv6.ioam6_data = nsdata;\n\n\terr = rhashtable_init(&nsdata->namespaces, &rht_ns_params);\n\tif (err)\n\t\tgoto free_nsdata;\n\n\terr = rhashtable_init(&nsdata->schemas, &rht_sc_params);\n\tif (err)\n\t\tgoto free_rht_ns;\n\nout:\n\treturn err;\nfree_rht_ns:\n\trhashtable_destroy(&nsdata->namespaces);\nfree_nsdata:\n\tkfree(nsdata);\n\tnet->ipv6.ioam6_data = NULL;\n\tgoto out;\n}\n\nstatic void __net_exit ioam6_net_exit(struct net *net)\n{\n\tstruct ioam6_pernet_data *nsdata = ioam6_pernet(net);\n\n\trhashtable_free_and_destroy(&nsdata->namespaces, ioam6_free_ns, NULL);\n\trhashtable_free_and_destroy(&nsdata->schemas, ioam6_free_sc, NULL);\n\n\tkfree(nsdata);\n}\n\nstatic struct pernet_operations ioam6_net_ops = {\n\t.init = ioam6_net_init,\n\t.exit = ioam6_net_exit,\n};\n\nint __init ioam6_init(void)\n{\n\tint err = register_pernet_subsys(&ioam6_net_ops);\n\tif (err)\n\t\tgoto out;\n\n\terr = genl_register_family(&ioam6_genl_family);\n\tif (err)\n\t\tgoto out_unregister_pernet_subsys;\n\n#ifdef CONFIG_IPV6_IOAM6_LWTUNNEL\n\terr = ioam6_iptunnel_init();\n\tif (err)\n\t\tgoto out_unregister_genl;\n#endif\n\n\tpr_info(\"In-situ OAM (IOAM) with IPv6\\n\");\n\nout:\n\treturn err;\n#ifdef CONFIG_IPV6_IOAM6_LWTUNNEL\nout_unregister_genl:\n\tgenl_unregister_family(&ioam6_genl_family);\n#endif\nout_unregister_pernet_subsys:\n\tunregister_pernet_subsys(&ioam6_net_ops);\n\tgoto out;\n}\n\nvoid ioam6_exit(void)\n{\n#ifdef CONFIG_IPV6_IOAM6_LWTUNNEL\n\tioam6_iptunnel_exit();\n#endif\n\tgenl_unregister_family(&ioam6_genl_family);\n\tunregister_pernet_subsys(&ioam6_net_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}