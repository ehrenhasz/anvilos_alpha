{
  "module_name": "rpl.c",
  "hash_id": "a0b20fb1739abe7e5f7eef7d407f6801a8c40e955d024b880aa90ea39b5051c8",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/rpl.c",
  "human_readable_source": "\n \n\n#include <net/ipv6.h>\n#include <net/rpl.h>\n\n#define IPV6_PFXTAIL_LEN(x) (sizeof(struct in6_addr) - (x))\n#define IPV6_RPL_BEST_ADDR_COMPRESSION 15\n\nstatic void ipv6_rpl_addr_decompress(struct in6_addr *dst,\n\t\t\t\t     const struct in6_addr *daddr,\n\t\t\t\t     const void *post, unsigned char pfx)\n{\n\tmemcpy(dst, daddr, pfx);\n\tmemcpy(&dst->s6_addr[pfx], post, IPV6_PFXTAIL_LEN(pfx));\n}\n\nstatic void ipv6_rpl_addr_compress(void *dst, const struct in6_addr *addr,\n\t\t\t\t   unsigned char pfx)\n{\n\tmemcpy(dst, &addr->s6_addr[pfx], IPV6_PFXTAIL_LEN(pfx));\n}\n\nstatic void *ipv6_rpl_segdata_pos(const struct ipv6_rpl_sr_hdr *hdr, int i)\n{\n\treturn (void *)&hdr->rpl_segdata[i * IPV6_PFXTAIL_LEN(hdr->cmpri)];\n}\n\nvoid ipv6_rpl_srh_decompress(struct ipv6_rpl_sr_hdr *outhdr,\n\t\t\t     const struct ipv6_rpl_sr_hdr *inhdr,\n\t\t\t     const struct in6_addr *daddr, unsigned char n)\n{\n\tint i;\n\n\touthdr->nexthdr = inhdr->nexthdr;\n\touthdr->hdrlen = (((n + 1) * sizeof(struct in6_addr)) >> 3);\n\touthdr->pad = 0;\n\touthdr->type = inhdr->type;\n\touthdr->segments_left = inhdr->segments_left;\n\touthdr->cmpri = 0;\n\touthdr->cmpre = 0;\n\n\tfor (i = 0; i < n; i++)\n\t\tipv6_rpl_addr_decompress(&outhdr->rpl_segaddr[i], daddr,\n\t\t\t\t\t ipv6_rpl_segdata_pos(inhdr, i),\n\t\t\t\t\t inhdr->cmpri);\n\n\tipv6_rpl_addr_decompress(&outhdr->rpl_segaddr[n], daddr,\n\t\t\t\t ipv6_rpl_segdata_pos(inhdr, n),\n\t\t\t\t inhdr->cmpre);\n}\n\nstatic unsigned char ipv6_rpl_srh_calc_cmpri(const struct ipv6_rpl_sr_hdr *inhdr,\n\t\t\t\t\t     const struct in6_addr *daddr,\n\t\t\t\t\t     unsigned char n)\n{\n\tunsigned char plen;\n\tint i;\n\n\tfor (plen = 0; plen < sizeof(*daddr); plen++) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (daddr->s6_addr[plen] !=\n\t\t\t    inhdr->rpl_segaddr[i].s6_addr[plen])\n\t\t\t\treturn plen;\n\t\t}\n\t}\n\n\treturn IPV6_RPL_BEST_ADDR_COMPRESSION;\n}\n\nstatic unsigned char ipv6_rpl_srh_calc_cmpre(const struct in6_addr *daddr,\n\t\t\t\t\t     const struct in6_addr *last_segment)\n{\n\tunsigned int plen;\n\n\tfor (plen = 0; plen < sizeof(*daddr); plen++) {\n\t\tif (daddr->s6_addr[plen] != last_segment->s6_addr[plen])\n\t\t\treturn plen;\n\t}\n\n\treturn IPV6_RPL_BEST_ADDR_COMPRESSION;\n}\n\nvoid ipv6_rpl_srh_compress(struct ipv6_rpl_sr_hdr *outhdr,\n\t\t\t   const struct ipv6_rpl_sr_hdr *inhdr,\n\t\t\t   const struct in6_addr *daddr, unsigned char n)\n{\n\tunsigned char cmpri, cmpre;\n\tsize_t seglen;\n\tint i;\n\n\tcmpri = ipv6_rpl_srh_calc_cmpri(inhdr, daddr, n);\n\tcmpre = ipv6_rpl_srh_calc_cmpre(daddr, &inhdr->rpl_segaddr[n]);\n\n\touthdr->nexthdr = inhdr->nexthdr;\n\tseglen = (n * IPV6_PFXTAIL_LEN(cmpri)) + IPV6_PFXTAIL_LEN(cmpre);\n\touthdr->hdrlen = seglen >> 3;\n\tif (seglen & 0x7) {\n\t\touthdr->hdrlen++;\n\t\touthdr->pad = 8 - (seglen & 0x7);\n\t} else {\n\t\touthdr->pad = 0;\n\t}\n\touthdr->type = inhdr->type;\n\touthdr->segments_left = inhdr->segments_left;\n\touthdr->cmpri = cmpri;\n\touthdr->cmpre = cmpre;\n\n\tfor (i = 0; i < n; i++)\n\t\tipv6_rpl_addr_compress(ipv6_rpl_segdata_pos(outhdr, i),\n\t\t\t\t       &inhdr->rpl_segaddr[i], cmpri);\n\n\tipv6_rpl_addr_compress(ipv6_rpl_segdata_pos(outhdr, n),\n\t\t\t       &inhdr->rpl_segaddr[n], cmpre);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}