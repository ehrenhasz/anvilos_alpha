{
  "module_name": "udp_offload.c",
  "hash_id": "6218fd3d773c0610ce9fd06c0834c55aa9002176341c363e4ad401ce6061f596",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/udp_offload.c",
  "human_readable_source": "\n \n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/indirect_call_wrapper.h>\n#include <net/protocol.h>\n#include <net/ipv6.h>\n#include <net/udp.h>\n#include <net/ip6_checksum.h>\n#include \"ip6_offload.h\"\n#include <net/gro.h>\n#include <net/gso.h>\n\nstatic struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\n\t\t\t\t\t netdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *packet_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\t__wsum csum;\n\tint tnl_hlen;\n\tint err;\n\n\tif (skb->encapsulation && skb_shinfo(skb)->gso_type &\n\t    (SKB_GSO_UDP_TUNNEL|SKB_GSO_UDP_TUNNEL_CSUM))\n\t\tsegs = skb_udp_tunnel_segment(skb, features, true);\n\telse {\n\t\tconst struct ipv6hdr *ipv6h;\n\t\tstruct udphdr *uh;\n\n\t\tif (!(skb_shinfo(skb)->gso_type & (SKB_GSO_UDP | SKB_GSO_UDP_L4)))\n\t\t\tgoto out;\n\n\t\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\t\tgoto out;\n\n\t\tif (skb_shinfo(skb)->gso_type & SKB_GSO_UDP_L4)\n\t\t\treturn __udp_gso_segment(skb, features, true);\n\n\t\tmss = skb_shinfo(skb)->gso_size;\n\t\tif (unlikely(skb->len <= mss))\n\t\t\tgoto out;\n\n\t\t \n\n\t\tuh = udp_hdr(skb);\n\t\tipv6h = ipv6_hdr(skb);\n\n\t\tuh->check = 0;\n\t\tcsum = skb_checksum(skb, 0, skb->len, 0);\n\t\tuh->check = udp_v6_check(skb->len, &ipv6h->saddr,\n\t\t\t\t\t  &ipv6h->daddr, csum);\n\t\tif (uh->check == 0)\n\t\t\tuh->check = CSUM_MANGLED_0;\n\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\t \n\t\tif (!skb->encap_hdr_csum)\n\t\t\tfeatures |= NETIF_F_HW_CSUM;\n\n\t\t \n\t\ttnl_hlen = skb_tnl_header_len(skb);\n\t\tif (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {\n\t\t\tif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\terr = ip6_find_1stfragopt(skb, &prevhdr);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t\tunfrag_ip6hlen = err;\n\t\tnexthdr = *prevhdr;\n\t\t*prevhdr = NEXTHDR_FRAGMENT;\n\t\tunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\n\t\t\t     unfrag_ip6hlen + tnl_hlen;\n\t\tpacket_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;\n\t\tmemmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);\n\n\t\tSKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;\n\t\tskb->mac_header -= frag_hdr_sz;\n\t\tskb->network_header -= frag_hdr_sz;\n\n\t\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\t\tfptr->nexthdr = nexthdr;\n\t\tfptr->reserved = 0;\n\t\tfptr->identification = ipv6_proxy_select_ident(dev_net(skb->dev), skb);\n\n\t\t \n\t\tsegs = skb_segment(skb, features);\n\t}\n\nout:\n\treturn segs;\n}\n\nstatic struct sock *udp6_gro_lookup_skb(struct sk_buff *skb, __be16 sport,\n\t\t\t\t\t__be16 dport)\n{\n\tconst struct ipv6hdr *iph = skb_gro_network_header(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tint iif, sdif;\n\n\tinet6_get_iif_sdif(skb, &iif, &sdif);\n\n\treturn __udp6_lib_lookup(net, &iph->saddr, sport,\n\t\t\t\t &iph->daddr, dport, iif,\n\t\t\t\t sdif, net->ipv4.udp_table, NULL);\n}\n\nINDIRECT_CALLABLE_SCOPE\nstruct sk_buff *udp6_gro_receive(struct list_head *head, struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_gro_udphdr(skb);\n\tstruct sock *sk = NULL;\n\tstruct sk_buff *pp;\n\n\tif (unlikely(!uh))\n\t\tgoto flush;\n\n\t \n\tif (NAPI_GRO_CB(skb)->flush)\n\t\tgoto skip;\n\n\tif (skb_gro_checksum_validate_zero_check(skb, IPPROTO_UDP, uh->check,\n\t\t\t\t\t\t ip6_gro_compute_pseudo))\n\t\tgoto flush;\n\telse if (uh->check)\n\t\tskb_gro_checksum_try_convert(skb, IPPROTO_UDP,\n\t\t\t\t\t     ip6_gro_compute_pseudo);\n\nskip:\n\tNAPI_GRO_CB(skb)->is_ipv6 = 1;\n\n\tif (static_branch_unlikely(&udpv6_encap_needed_key))\n\t\tsk = udp6_gro_lookup_skb(skb, uh->source, uh->dest);\n\n\tpp = udp_gro_receive(head, skb, uh, sk);\n\treturn pp;\n\nflush:\n\tNAPI_GRO_CB(skb)->flush = 1;\n\treturn NULL;\n}\n\nINDIRECT_CALLABLE_SCOPE int udp6_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tconst struct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tstruct udphdr *uh = (struct udphdr *)(skb->data + nhoff);\n\n\t \n\tif (NAPI_GRO_CB(skb)->is_flist && !NAPI_GRO_CB(skb)->encap_mark) {\n\t\tuh->len = htons(skb->len - nhoff);\n\n\t\tskb_shinfo(skb)->gso_type |= (SKB_GSO_FRAGLIST|SKB_GSO_UDP_L4);\n\t\tskb_shinfo(skb)->gso_segs = NAPI_GRO_CB(skb)->count;\n\n\t\tif (skb->ip_summed == CHECKSUM_UNNECESSARY) {\n\t\t\tif (skb->csum_level < SKB_MAX_CSUM_LEVEL)\n\t\t\t\tskb->csum_level++;\n\t\t} else {\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\tskb->csum_level = 0;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (uh->check)\n\t\tuh->check = ~udp_v6_check(skb->len - nhoff, &ipv6h->saddr,\n\t\t\t\t\t  &ipv6h->daddr, 0);\n\n\treturn udp_gro_complete(skb, nhoff, udp6_lib_lookup_skb);\n}\n\nstatic const struct net_offload udpv6_offload = {\n\t.callbacks = {\n\t\t.gso_segment\t=\tudp6_ufo_fragment,\n\t\t.gro_receive\t=\tudp6_gro_receive,\n\t\t.gro_complete\t=\tudp6_gro_complete,\n\t},\n};\n\nint udpv6_offload_init(void)\n{\n\treturn inet6_add_offload(&udpv6_offload, IPPROTO_UDP);\n}\n\nint udpv6_offload_exit(void)\n{\n\treturn inet6_del_offload(&udpv6_offload, IPPROTO_UDP);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}