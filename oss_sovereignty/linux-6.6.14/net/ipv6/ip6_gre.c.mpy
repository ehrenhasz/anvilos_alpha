{
  "module_name": "ip6_gre.c",
  "hash_id": "995d0d83fae9e39b7db1e610efce583d1bbac7ece6ec93a5f4b7ce5da4e185de",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ip6_gre.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/in.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/in6.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/hash.h>\n#include <linux/if_tunnel.h>\n#include <linux/ip6_tunnel.h>\n\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/ip_tunnels.h>\n#include <net/icmp.h>\n#include <net/protocol.h>\n#include <net/addrconf.h>\n#include <net/arp.h>\n#include <net/checksum.h>\n#include <net/dsfield.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/rtnetlink.h>\n\n#include <net/ipv6.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n#include <net/ip6_tunnel.h>\n#include <net/gre.h>\n#include <net/erspan.h>\n#include <net/dst_metadata.h>\n\n\nstatic bool log_ecn_error = true;\nmodule_param(log_ecn_error, bool, 0644);\nMODULE_PARM_DESC(log_ecn_error, \"Log packets received with corrupted ECN\");\n\n#define IP6_GRE_HASH_SIZE_SHIFT  5\n#define IP6_GRE_HASH_SIZE (1 << IP6_GRE_HASH_SIZE_SHIFT)\n\nstatic unsigned int ip6gre_net_id __read_mostly;\nstruct ip6gre_net {\n\tstruct ip6_tnl __rcu *tunnels[4][IP6_GRE_HASH_SIZE];\n\n\tstruct ip6_tnl __rcu *collect_md_tun;\n\tstruct ip6_tnl __rcu *collect_md_tun_erspan;\n\tstruct net_device *fb_tunnel_dev;\n};\n\nstatic struct rtnl_link_ops ip6gre_link_ops __read_mostly;\nstatic struct rtnl_link_ops ip6gre_tap_ops __read_mostly;\nstatic struct rtnl_link_ops ip6erspan_tap_ops __read_mostly;\nstatic int ip6gre_tunnel_init(struct net_device *dev);\nstatic void ip6gre_tunnel_setup(struct net_device *dev);\nstatic void ip6gre_tunnel_link(struct ip6gre_net *ign, struct ip6_tnl *t);\nstatic void ip6gre_tnl_link_config(struct ip6_tnl *t, int set_mtu);\nstatic void ip6erspan_tnl_link_config(struct ip6_tnl *t, int set_mtu);\n\n \n\n \n\n#define HASH_KEY(key) (((__force u32)key^((__force u32)key>>4))&(IP6_GRE_HASH_SIZE - 1))\nstatic u32 HASH_ADDR(const struct in6_addr *addr)\n{\n\tu32 hash = ipv6_addr_hash(addr);\n\n\treturn hash_32(hash, IP6_GRE_HASH_SIZE_SHIFT);\n}\n\n#define tunnels_r_l\ttunnels[3]\n#define tunnels_r\ttunnels[2]\n#define tunnels_l\ttunnels[1]\n#define tunnels_wc\ttunnels[0]\n\n \n\nstatic struct ip6_tnl *ip6gre_tunnel_lookup(struct net_device *dev,\n\t\tconst struct in6_addr *remote, const struct in6_addr *local,\n\t\t__be32 key, __be16 gre_proto)\n{\n\tstruct net *net = dev_net(dev);\n\tint link = dev->ifindex;\n\tunsigned int h0 = HASH_ADDR(remote);\n\tunsigned int h1 = HASH_KEY(key);\n\tstruct ip6_tnl *t, *cand = NULL;\n\tstruct ip6gre_net *ign = net_generic(net, ip6gre_net_id);\n\tint dev_type = (gre_proto == htons(ETH_P_TEB) ||\n\t\t\tgre_proto == htons(ETH_P_ERSPAN) ||\n\t\t\tgre_proto == htons(ETH_P_ERSPAN2)) ?\n\t\t       ARPHRD_ETHER : ARPHRD_IP6GRE;\n\tint score, cand_score = 4;\n\tstruct net_device *ndev;\n\n\tfor_each_ip_tunnel_rcu(t, ign->tunnels_r_l[h0 ^ h1]) {\n\t\tif (!ipv6_addr_equal(local, &t->parms.laddr) ||\n\t\t    !ipv6_addr_equal(remote, &t->parms.raddr) ||\n\t\t    key != t->parms.i_key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IP6GRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tfor_each_ip_tunnel_rcu(t, ign->tunnels_r[h0 ^ h1]) {\n\t\tif (!ipv6_addr_equal(remote, &t->parms.raddr) ||\n\t\t    key != t->parms.i_key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IP6GRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tfor_each_ip_tunnel_rcu(t, ign->tunnels_l[h1]) {\n\t\tif ((!ipv6_addr_equal(local, &t->parms.laddr) &&\n\t\t\t  (!ipv6_addr_equal(local, &t->parms.raddr) ||\n\t\t\t\t !ipv6_addr_is_multicast(local))) ||\n\t\t    key != t->parms.i_key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IP6GRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tfor_each_ip_tunnel_rcu(t, ign->tunnels_wc[h1]) {\n\t\tif (t->parms.i_key != key ||\n\t\t    !(t->dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (t->dev->type != ARPHRD_IP6GRE &&\n\t\t    t->dev->type != dev_type)\n\t\t\tcontinue;\n\n\t\tscore = 0;\n\t\tif (t->parms.link != link)\n\t\t\tscore |= 1;\n\t\tif (t->dev->type != dev_type)\n\t\t\tscore |= 2;\n\t\tif (score == 0)\n\t\t\treturn t;\n\n\t\tif (score < cand_score) {\n\t\t\tcand = t;\n\t\t\tcand_score = score;\n\t\t}\n\t}\n\n\tif (cand)\n\t\treturn cand;\n\n\tif (gre_proto == htons(ETH_P_ERSPAN) ||\n\t    gre_proto == htons(ETH_P_ERSPAN2))\n\t\tt = rcu_dereference(ign->collect_md_tun_erspan);\n\telse\n\t\tt = rcu_dereference(ign->collect_md_tun);\n\n\tif (t && t->dev->flags & IFF_UP)\n\t\treturn t;\n\n\tndev = READ_ONCE(ign->fb_tunnel_dev);\n\tif (ndev && ndev->flags & IFF_UP)\n\t\treturn netdev_priv(ndev);\n\n\treturn NULL;\n}\n\nstatic struct ip6_tnl __rcu **__ip6gre_bucket(struct ip6gre_net *ign,\n\t\tconst struct __ip6_tnl_parm *p)\n{\n\tconst struct in6_addr *remote = &p->raddr;\n\tconst struct in6_addr *local = &p->laddr;\n\tunsigned int h = HASH_KEY(p->i_key);\n\tint prio = 0;\n\n\tif (!ipv6_addr_any(local))\n\t\tprio |= 1;\n\tif (!ipv6_addr_any(remote) && !ipv6_addr_is_multicast(remote)) {\n\t\tprio |= 2;\n\t\th ^= HASH_ADDR(remote);\n\t}\n\n\treturn &ign->tunnels[prio][h];\n}\n\nstatic void ip6gre_tunnel_link_md(struct ip6gre_net *ign, struct ip6_tnl *t)\n{\n\tif (t->parms.collect_md)\n\t\trcu_assign_pointer(ign->collect_md_tun, t);\n}\n\nstatic void ip6erspan_tunnel_link_md(struct ip6gre_net *ign, struct ip6_tnl *t)\n{\n\tif (t->parms.collect_md)\n\t\trcu_assign_pointer(ign->collect_md_tun_erspan, t);\n}\n\nstatic void ip6gre_tunnel_unlink_md(struct ip6gre_net *ign, struct ip6_tnl *t)\n{\n\tif (t->parms.collect_md)\n\t\trcu_assign_pointer(ign->collect_md_tun, NULL);\n}\n\nstatic void ip6erspan_tunnel_unlink_md(struct ip6gre_net *ign,\n\t\t\t\t       struct ip6_tnl *t)\n{\n\tif (t->parms.collect_md)\n\t\trcu_assign_pointer(ign->collect_md_tun_erspan, NULL);\n}\n\nstatic inline struct ip6_tnl __rcu **ip6gre_bucket(struct ip6gre_net *ign,\n\t\tconst struct ip6_tnl *t)\n{\n\treturn __ip6gre_bucket(ign, &t->parms);\n}\n\nstatic void ip6gre_tunnel_link(struct ip6gre_net *ign, struct ip6_tnl *t)\n{\n\tstruct ip6_tnl __rcu **tp = ip6gre_bucket(ign, t);\n\n\trcu_assign_pointer(t->next, rtnl_dereference(*tp));\n\trcu_assign_pointer(*tp, t);\n}\n\nstatic void ip6gre_tunnel_unlink(struct ip6gre_net *ign, struct ip6_tnl *t)\n{\n\tstruct ip6_tnl __rcu **tp;\n\tstruct ip6_tnl *iter;\n\n\tfor (tp = ip6gre_bucket(ign, t);\n\t     (iter = rtnl_dereference(*tp)) != NULL;\n\t     tp = &iter->next) {\n\t\tif (t == iter) {\n\t\t\trcu_assign_pointer(*tp, t->next);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct ip6_tnl *ip6gre_tunnel_find(struct net *net,\n\t\t\t\t\t   const struct __ip6_tnl_parm *parms,\n\t\t\t\t\t   int type)\n{\n\tconst struct in6_addr *remote = &parms->raddr;\n\tconst struct in6_addr *local = &parms->laddr;\n\t__be32 key = parms->i_key;\n\tint link = parms->link;\n\tstruct ip6_tnl *t;\n\tstruct ip6_tnl __rcu **tp;\n\tstruct ip6gre_net *ign = net_generic(net, ip6gre_net_id);\n\n\tfor (tp = __ip6gre_bucket(ign, parms);\n\t     (t = rtnl_dereference(*tp)) != NULL;\n\t     tp = &t->next)\n\t\tif (ipv6_addr_equal(local, &t->parms.laddr) &&\n\t\t    ipv6_addr_equal(remote, &t->parms.raddr) &&\n\t\t    key == t->parms.i_key &&\n\t\t    link == t->parms.link &&\n\t\t    type == t->dev->type)\n\t\t\tbreak;\n\n\treturn t;\n}\n\nstatic struct ip6_tnl *ip6gre_tunnel_locate(struct net *net,\n\t\tconst struct __ip6_tnl_parm *parms, int create)\n{\n\tstruct ip6_tnl *t, *nt;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct ip6gre_net *ign = net_generic(net, ip6gre_net_id);\n\n\tt = ip6gre_tunnel_find(net, parms, ARPHRD_IP6GRE);\n\tif (t && create)\n\t\treturn NULL;\n\tif (t || !create)\n\t\treturn t;\n\n\tif (parms->name[0]) {\n\t\tif (!dev_valid_name(parms->name))\n\t\t\treturn NULL;\n\t\tstrscpy(name, parms->name, IFNAMSIZ);\n\t} else {\n\t\tstrcpy(name, \"ip6gre%d\");\n\t}\n\tdev = alloc_netdev(sizeof(*t), name, NET_NAME_UNKNOWN,\n\t\t\t   ip6gre_tunnel_setup);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev_net_set(dev, net);\n\n\tnt = netdev_priv(dev);\n\tnt->parms = *parms;\n\tdev->rtnl_link_ops = &ip6gre_link_ops;\n\n\tnt->dev = dev;\n\tnt->net = dev_net(dev);\n\n\tif (register_netdevice(dev) < 0)\n\t\tgoto failed_free;\n\n\tip6gre_tnl_link_config(nt, 1);\n\tip6gre_tunnel_link(ign, nt);\n\treturn nt;\n\nfailed_free:\n\tfree_netdev(dev);\n\treturn NULL;\n}\n\nstatic void ip6erspan_tunnel_uninit(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct ip6gre_net *ign = net_generic(t->net, ip6gre_net_id);\n\n\tip6erspan_tunnel_unlink_md(ign, t);\n\tip6gre_tunnel_unlink(ign, t);\n\tdst_cache_reset(&t->dst_cache);\n\tnetdev_put(dev, &t->dev_tracker);\n}\n\nstatic void ip6gre_tunnel_uninit(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct ip6gre_net *ign = net_generic(t->net, ip6gre_net_id);\n\n\tip6gre_tunnel_unlink_md(ign, t);\n\tip6gre_tunnel_unlink(ign, t);\n\tif (ign->fb_tunnel_dev == dev)\n\t\tWRITE_ONCE(ign->fb_tunnel_dev, NULL);\n\tdst_cache_reset(&t->dst_cache);\n\tnetdev_put(dev, &t->dev_tracker);\n}\n\n\nstatic int ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t       u8 type, u8 code, int offset, __be32 info)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct ipv6hdr *ipv6h;\n\tstruct tnl_ptk_info tpi;\n\tstruct ip6_tnl *t;\n\n\tif (gre_parse_header(skb, &tpi, NULL, htons(ETH_P_IPV6),\n\t\t\t     offset) < 0)\n\t\treturn -EINVAL;\n\n\tipv6h = (const struct ipv6hdr *)skb->data;\n\tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n\t\t\t\t tpi.key, tpi.proto);\n\tif (!t)\n\t\treturn -ENOENT;\n\n\tswitch (type) {\n\tcase ICMPV6_DEST_UNREACH:\n\t\tnet_dbg_ratelimited(\"%s: Path to destination invalid or inactive!\\n\",\n\t\t\t\t    t->parms.name);\n\t\tif (code != ICMPV6_PORT_UNREACH)\n\t\t\tbreak;\n\t\treturn 0;\n\tcase ICMPV6_TIME_EXCEED:\n\t\tif (code == ICMPV6_EXC_HOPLIMIT) {\n\t\t\tnet_dbg_ratelimited(\"%s: Too small hop limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\tcase ICMPV6_PARAMPROB: {\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\t\t__u32 teli;\n\n\t\tteli = 0;\n\t\tif (code == ICMPV6_HDR_FIELD)\n\t\t\tteli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data);\n\n\t\tif (teli && teli == be32_to_cpu(info) - 2) {\n\t\t\ttel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli];\n\t\t\tif (tel->encap_limit == 0) {\n\t\t\t\tnet_dbg_ratelimited(\"%s: Too small encapsulation limit or routing loop in tunnel!\\n\",\n\t\t\t\t\t\t    t->parms.name);\n\t\t\t}\n\t\t} else {\n\t\t\tnet_dbg_ratelimited(\"%s: Recipient unable to parse tunneled packet!\\n\",\n\t\t\t\t\t    t->parms.name);\n\t\t}\n\t\treturn 0;\n\t}\n\tcase ICMPV6_PKT_TOOBIG:\n\t\tip6_update_pmtu(skb, net, info, 0, 0, sock_net_uid(net, NULL));\n\t\treturn 0;\n\tcase NDISC_REDIRECT:\n\t\tip6_redirect(skb, net, skb->dev->ifindex, 0,\n\t\t\t     sock_net_uid(net, NULL));\n\t\treturn 0;\n\t}\n\n\tif (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\n\n\treturn 0;\n}\n\nstatic int ip6gre_rcv(struct sk_buff *skb, const struct tnl_ptk_info *tpi)\n{\n\tconst struct ipv6hdr *ipv6h;\n\tstruct ip6_tnl *tunnel;\n\n\tipv6h = ipv6_hdr(skb);\n\ttunnel = ip6gre_tunnel_lookup(skb->dev,\n\t\t\t\t      &ipv6h->saddr, &ipv6h->daddr, tpi->key,\n\t\t\t\t      tpi->proto);\n\tif (tunnel) {\n\t\tif (tunnel->parms.collect_md) {\n\t\t\tstruct metadata_dst *tun_dst;\n\t\t\t__be64 tun_id;\n\t\t\t__be16 flags;\n\n\t\t\tflags = tpi->flags;\n\t\t\ttun_id = key32_to_tunnel_id(tpi->key);\n\n\t\t\ttun_dst = ipv6_tun_rx_dst(skb, flags, tun_id, 0);\n\t\t\tif (!tun_dst)\n\t\t\t\treturn PACKET_REJECT;\n\n\t\t\tip6_tnl_rcv(tunnel, skb, tpi, tun_dst, log_ecn_error);\n\t\t} else {\n\t\t\tip6_tnl_rcv(tunnel, skb, tpi, NULL, log_ecn_error);\n\t\t}\n\n\t\treturn PACKET_RCVD;\n\t}\n\n\treturn PACKET_REJECT;\n}\n\nstatic int ip6erspan_rcv(struct sk_buff *skb,\n\t\t\t struct tnl_ptk_info *tpi,\n\t\t\t int gre_hdr_len)\n{\n\tstruct erspan_base_hdr *ershdr;\n\tconst struct ipv6hdr *ipv6h;\n\tstruct erspan_md2 *md2;\n\tstruct ip6_tnl *tunnel;\n\tu8 ver;\n\n\tipv6h = ipv6_hdr(skb);\n\tershdr = (struct erspan_base_hdr *)skb->data;\n\tver = ershdr->ver;\n\n\ttunnel = ip6gre_tunnel_lookup(skb->dev,\n\t\t\t\t      &ipv6h->saddr, &ipv6h->daddr, tpi->key,\n\t\t\t\t      tpi->proto);\n\tif (tunnel) {\n\t\tint len = erspan_hdr_len(ver);\n\n\t\tif (unlikely(!pskb_may_pull(skb, len)))\n\t\t\treturn PACKET_REJECT;\n\n\t\tif (__iptunnel_pull_header(skb, len,\n\t\t\t\t\t   htons(ETH_P_TEB),\n\t\t\t\t\t   false, false) < 0)\n\t\t\treturn PACKET_REJECT;\n\n\t\tif (tunnel->parms.collect_md) {\n\t\t\tstruct erspan_metadata *pkt_md, *md;\n\t\t\tstruct metadata_dst *tun_dst;\n\t\t\tstruct ip_tunnel_info *info;\n\t\t\tunsigned char *gh;\n\t\t\t__be64 tun_id;\n\t\t\t__be16 flags;\n\n\t\t\ttpi->flags |= TUNNEL_KEY;\n\t\t\tflags = tpi->flags;\n\t\t\ttun_id = key32_to_tunnel_id(tpi->key);\n\n\t\t\ttun_dst = ipv6_tun_rx_dst(skb, flags, tun_id,\n\t\t\t\t\t\t  sizeof(*md));\n\t\t\tif (!tun_dst)\n\t\t\t\treturn PACKET_REJECT;\n\n\t\t\t \n\t\t\tgh = skb_network_header(skb) +\n\t\t\t     skb_network_header_len(skb);\n\t\t\tpkt_md = (struct erspan_metadata *)(gh + gre_hdr_len +\n\t\t\t\t\t\t\t    sizeof(*ershdr));\n\t\t\tinfo = &tun_dst->u.tun_info;\n\t\t\tmd = ip_tunnel_info_opts(info);\n\t\t\tmd->version = ver;\n\t\t\tmd2 = &md->u.md2;\n\t\t\tmemcpy(md2, pkt_md, ver == 1 ? ERSPAN_V1_MDSIZE :\n\t\t\t\t\t\t       ERSPAN_V2_MDSIZE);\n\t\t\tinfo->key.tun_flags |= TUNNEL_ERSPAN_OPT;\n\t\t\tinfo->options_len = sizeof(*md);\n\n\t\t\tip6_tnl_rcv(tunnel, skb, tpi, tun_dst, log_ecn_error);\n\n\t\t} else {\n\t\t\tip6_tnl_rcv(tunnel, skb, tpi, NULL, log_ecn_error);\n\t\t}\n\n\t\treturn PACKET_RCVD;\n\t}\n\n\treturn PACKET_REJECT;\n}\n\nstatic int gre_rcv(struct sk_buff *skb)\n{\n\tstruct tnl_ptk_info tpi;\n\tbool csum_err = false;\n\tint hdr_len;\n\n\thdr_len = gre_parse_header(skb, &tpi, &csum_err, htons(ETH_P_IPV6), 0);\n\tif (hdr_len < 0)\n\t\tgoto drop;\n\n\tif (iptunnel_pull_header(skb, hdr_len, tpi.proto, false))\n\t\tgoto drop;\n\n\tif (unlikely(tpi.proto == htons(ETH_P_ERSPAN) ||\n\t\t     tpi.proto == htons(ETH_P_ERSPAN2))) {\n\t\tif (ip6erspan_rcv(skb, &tpi, hdr_len) == PACKET_RCVD)\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\n\tif (ip6gre_rcv(skb, &tpi) == PACKET_RCVD)\n\t\treturn 0;\n\nout:\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int gre_handle_offloads(struct sk_buff *skb, bool csum)\n{\n\treturn iptunnel_handle_offloads(skb,\n\t\t\t\t\tcsum ? SKB_GSO_GRE_CSUM : SKB_GSO_GRE);\n}\n\nstatic void prepare_ip6gre_xmit_ipv4(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     struct flowi6 *fl6, __u8 *dsfield,\n\t\t\t\t     int *encap_limit)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\n\tif (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\n\t\t*encap_limit = t->parms.encap_limit;\n\n\tmemcpy(fl6, &t->fl.u.ip6, sizeof(*fl6));\n\n\tif (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)\n\t\t*dsfield = ipv4_get_dsfield(iph);\n\telse\n\t\t*dsfield = ip6_tclass(t->parms.flowinfo);\n\n\tif (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)\n\t\tfl6->flowi6_mark = skb->mark;\n\telse\n\t\tfl6->flowi6_mark = t->parms.fwmark;\n\n\tfl6->flowi6_uid = sock_net_uid(dev_net(dev), NULL);\n}\n\nstatic int prepare_ip6gre_xmit_ipv6(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    struct flowi6 *fl6, __u8 *dsfield,\n\t\t\t\t    int *encap_limit)\n{\n\tstruct ipv6hdr *ipv6h;\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\t__u16 offset;\n\n\toffset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));\n\t \n\tipv6h = ipv6_hdr(skb);\n\n\tif (offset > 0) {\n\t\tstruct ipv6_tlv_tnl_enc_lim *tel;\n\n\t\ttel = (struct ipv6_tlv_tnl_enc_lim *)&skb_network_header(skb)[offset];\n\t\tif (tel->encap_limit == 0) {\n\t\t\ticmpv6_ndo_send(skb, ICMPV6_PARAMPROB,\n\t\t\t\t\tICMPV6_HDR_FIELD, offset + 2);\n\t\t\treturn -1;\n\t\t}\n\t\t*encap_limit = tel->encap_limit - 1;\n\t} else if (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT)) {\n\t\t*encap_limit = t->parms.encap_limit;\n\t}\n\n\tmemcpy(fl6, &t->fl.u.ip6, sizeof(*fl6));\n\n\tif (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)\n\t\t*dsfield = ipv6_get_dsfield(ipv6h);\n\telse\n\t\t*dsfield = ip6_tclass(t->parms.flowinfo);\n\n\tif (t->parms.flags & IP6_TNL_F_USE_ORIG_FLOWLABEL)\n\t\tfl6->flowlabel |= ip6_flowlabel(ipv6h);\n\n\tif (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)\n\t\tfl6->flowi6_mark = skb->mark;\n\telse\n\t\tfl6->flowi6_mark = t->parms.fwmark;\n\n\tfl6->flowi6_uid = sock_net_uid(dev_net(dev), NULL);\n\n\treturn 0;\n}\n\nstatic int prepare_ip6gre_xmit_other(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     struct flowi6 *fl6, __u8 *dsfield,\n\t\t\t\t     int *encap_limit)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\n\tif (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\n\t\t*encap_limit = t->parms.encap_limit;\n\n\tmemcpy(fl6, &t->fl.u.ip6, sizeof(*fl6));\n\n\tif (t->parms.flags & IP6_TNL_F_USE_ORIG_TCLASS)\n\t\t*dsfield = 0;\n\telse\n\t\t*dsfield = ip6_tclass(t->parms.flowinfo);\n\n\tif (t->parms.flags & IP6_TNL_F_USE_ORIG_FWMARK)\n\t\tfl6->flowi6_mark = skb->mark;\n\telse\n\t\tfl6->flowi6_mark = t->parms.fwmark;\n\n\tfl6->flowi6_uid = sock_net_uid(dev_net(dev), NULL);\n\n\treturn 0;\n}\n\nstatic struct ip_tunnel_info *skb_tunnel_info_txcheck(struct sk_buff *skb)\n{\n\tstruct ip_tunnel_info *tun_info;\n\n\ttun_info = skb_tunnel_info(skb);\n\tif (unlikely(!tun_info || !(tun_info->mode & IP_TUNNEL_INFO_TX)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn tun_info;\n}\n\nstatic netdev_tx_t __gre6_xmit(struct sk_buff *skb,\n\t\t\t       struct net_device *dev, __u8 dsfield,\n\t\t\t       struct flowi6 *fl6, int encap_limit,\n\t\t\t       __u32 *pmtu, __be16 proto)\n{\n\tstruct ip6_tnl *tunnel = netdev_priv(dev);\n\t__be16 protocol;\n\t__be16 flags;\n\n\tif (dev->type == ARPHRD_ETHER)\n\t\tIPCB(skb)->flags = 0;\n\n\tif (dev->header_ops && dev->type == ARPHRD_IP6GRE)\n\t\tfl6->daddr = ((struct ipv6hdr *)skb->data)->daddr;\n\telse\n\t\tfl6->daddr = tunnel->parms.raddr;\n\n\t \n\tprotocol = (dev->type == ARPHRD_ETHER) ? htons(ETH_P_TEB) : proto;\n\n\tif (tunnel->parms.collect_md) {\n\t\tstruct ip_tunnel_info *tun_info;\n\t\tconst struct ip_tunnel_key *key;\n\t\tint tun_hlen;\n\n\t\ttun_info = skb_tunnel_info_txcheck(skb);\n\t\tif (IS_ERR(tun_info) ||\n\t\t    unlikely(ip_tunnel_info_af(tun_info) != AF_INET6))\n\t\t\treturn -EINVAL;\n\n\t\tkey = &tun_info->key;\n\t\tmemset(fl6, 0, sizeof(*fl6));\n\t\tfl6->flowi6_proto = IPPROTO_GRE;\n\t\tfl6->daddr = key->u.ipv6.dst;\n\t\tfl6->flowlabel = key->label;\n\t\tfl6->flowi6_uid = sock_net_uid(dev_net(dev), NULL);\n\t\tfl6->fl6_gre_key = tunnel_id_to_key32(key->tun_id);\n\n\t\tdsfield = key->tos;\n\t\tflags = key->tun_flags &\n\t\t\t(TUNNEL_CSUM | TUNNEL_KEY | TUNNEL_SEQ);\n\t\ttun_hlen = gre_calc_hlen(flags);\n\n\t\tif (skb_cow_head(skb, dev->needed_headroom ?: tun_hlen + tunnel->encap_hlen))\n\t\t\treturn -ENOMEM;\n\n\t\tgre_build_header(skb, tun_hlen,\n\t\t\t\t flags, protocol,\n\t\t\t\t tunnel_id_to_key32(tun_info->key.tun_id),\n\t\t\t\t (flags & TUNNEL_SEQ) ? htonl(atomic_fetch_inc(&tunnel->o_seqno))\n\t\t\t\t\t\t      : 0);\n\n\t} else {\n\t\tif (skb_cow_head(skb, dev->needed_headroom ?: tunnel->hlen))\n\t\t\treturn -ENOMEM;\n\n\t\tflags = tunnel->parms.o_flags;\n\n\t\tgre_build_header(skb, tunnel->tun_hlen, flags,\n\t\t\t\t protocol, tunnel->parms.o_key,\n\t\t\t\t (flags & TUNNEL_SEQ) ? htonl(atomic_fetch_inc(&tunnel->o_seqno))\n\t\t\t\t\t\t      : 0);\n\t}\n\n\treturn ip6_tnl_xmit(skb, dev, dsfield, fl6, encap_limit, pmtu,\n\t\t\t    NEXTHDR_GRE);\n}\n\nstatic inline int ip6gre_xmit_ipv4(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tint encap_limit = -1;\n\tstruct flowi6 fl6;\n\t__u8 dsfield = 0;\n\t__u32 mtu;\n\tint err;\n\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\n\tif (!t->parms.collect_md)\n\t\tprepare_ip6gre_xmit_ipv4(skb, dev, &fl6,\n\t\t\t\t\t &dsfield, &encap_limit);\n\n\terr = gre_handle_offloads(skb, !!(t->parms.o_flags & TUNNEL_CSUM));\n\tif (err)\n\t\treturn -1;\n\n\terr = __gre6_xmit(skb, dev, dsfield, &fl6, encap_limit, &mtu,\n\t\t\t  skb->protocol);\n\tif (err != 0) {\n\t\t \n\t\tif (err == -EMSGSIZE)\n\t\t\ticmp_ndo_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\n\t\t\t\t      htonl(mtu));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int ip6gre_xmit_ipv6(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tint encap_limit = -1;\n\tstruct flowi6 fl6;\n\t__u8 dsfield = 0;\n\t__u32 mtu;\n\tint err;\n\n\tif (ipv6_addr_equal(&t->parms.raddr, &ipv6h->saddr))\n\t\treturn -1;\n\n\tif (!t->parms.collect_md &&\n\t    prepare_ip6gre_xmit_ipv6(skb, dev, &fl6, &dsfield, &encap_limit))\n\t\treturn -1;\n\n\tif (gre_handle_offloads(skb, !!(t->parms.o_flags & TUNNEL_CSUM)))\n\t\treturn -1;\n\n\terr = __gre6_xmit(skb, dev, dsfield, &fl6, encap_limit,\n\t\t\t  &mtu, skb->protocol);\n\tif (err != 0) {\n\t\tif (err == -EMSGSIZE)\n\t\t\ticmpv6_ndo_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ip6gre_xmit_other(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tint encap_limit = -1;\n\tstruct flowi6 fl6;\n\t__u8 dsfield = 0;\n\t__u32 mtu;\n\tint err;\n\n\tif (!t->parms.collect_md &&\n\t    prepare_ip6gre_xmit_other(skb, dev, &fl6, &dsfield, &encap_limit))\n\t\treturn -1;\n\n\terr = gre_handle_offloads(skb, !!(t->parms.o_flags & TUNNEL_CSUM));\n\tif (err)\n\t\treturn err;\n\terr = __gre6_xmit(skb, dev, dsfield, &fl6, encap_limit, &mtu, skb->protocol);\n\n\treturn err;\n}\n\nstatic netdev_tx_t ip6gre_tunnel_xmit(struct sk_buff *skb,\n\tstruct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\t__be16 payload_protocol;\n\tint ret;\n\n\tif (!pskb_inet_may_pull(skb))\n\t\tgoto tx_err;\n\n\tif (!ip6_tnl_xmit_ctl(t, &t->parms.laddr, &t->parms.raddr))\n\t\tgoto tx_err;\n\n\tpayload_protocol = skb_protocol(skb, true);\n\tswitch (payload_protocol) {\n\tcase htons(ETH_P_IP):\n\t\tret = ip6gre_xmit_ipv4(skb, dev);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tret = ip6gre_xmit_ipv6(skb, dev);\n\t\tbreak;\n\tdefault:\n\t\tret = ip6gre_xmit_other(skb, dev);\n\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tgoto tx_err;\n\n\treturn NETDEV_TX_OK;\n\ntx_err:\n\tif (!t->parms.collect_md || !IS_ERR(skb_tunnel_info_txcheck(skb)))\n\t\tDEV_STATS_INC(dev, tx_errors);\n\tDEV_STATS_INC(dev, tx_dropped);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic netdev_tx_t ip6erspan_tunnel_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct ip_tunnel_info *tun_info = NULL;\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct dst_entry *dst = skb_dst(skb);\n\tbool truncate = false;\n\tint encap_limit = -1;\n\t__u8 dsfield = false;\n\tstruct flowi6 fl6;\n\tint err = -EINVAL;\n\t__be16 proto;\n\t__u32 mtu;\n\tint nhoff;\n\n\tif (!pskb_inet_may_pull(skb))\n\t\tgoto tx_err;\n\n\tif (!ip6_tnl_xmit_ctl(t, &t->parms.laddr, &t->parms.raddr))\n\t\tgoto tx_err;\n\n\tif (gre_handle_offloads(skb, false))\n\t\tgoto tx_err;\n\n\tif (skb->len > dev->mtu + dev->hard_header_len) {\n\t\tif (pskb_trim(skb, dev->mtu + dev->hard_header_len))\n\t\t\tgoto tx_err;\n\t\ttruncate = true;\n\t}\n\n\tnhoff = skb_network_offset(skb);\n\tif (skb->protocol == htons(ETH_P_IP) &&\n\t    (ntohs(ip_hdr(skb)->tot_len) > skb->len - nhoff))\n\t\ttruncate = true;\n\n\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tint thoff;\n\n\t\tif (skb_transport_header_was_set(skb))\n\t\t\tthoff = skb_transport_offset(skb);\n\t\telse\n\t\t\tthoff = nhoff + sizeof(struct ipv6hdr);\n\t\tif (ntohs(ipv6_hdr(skb)->payload_len) > skb->len - thoff)\n\t\t\ttruncate = true;\n\t}\n\n\tif (skb_cow_head(skb, dev->needed_headroom ?: t->hlen))\n\t\tgoto tx_err;\n\n\tt->parms.o_flags &= ~TUNNEL_KEY;\n\tIPCB(skb)->flags = 0;\n\n\t \n\tif (t->parms.collect_md) {\n\t\tconst struct ip_tunnel_key *key;\n\t\tstruct erspan_metadata *md;\n\t\t__be32 tun_id;\n\n\t\ttun_info = skb_tunnel_info_txcheck(skb);\n\t\tif (IS_ERR(tun_info) ||\n\t\t    unlikely(ip_tunnel_info_af(tun_info) != AF_INET6))\n\t\t\tgoto tx_err;\n\n\t\tkey = &tun_info->key;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_GRE;\n\t\tfl6.daddr = key->u.ipv6.dst;\n\t\tfl6.flowlabel = key->label;\n\t\tfl6.flowi6_uid = sock_net_uid(dev_net(dev), NULL);\n\t\tfl6.fl6_gre_key = tunnel_id_to_key32(key->tun_id);\n\n\t\tdsfield = key->tos;\n\t\tif (!(tun_info->key.tun_flags & TUNNEL_ERSPAN_OPT))\n\t\t\tgoto tx_err;\n\t\tif (tun_info->options_len < sizeof(*md))\n\t\t\tgoto tx_err;\n\t\tmd = ip_tunnel_info_opts(tun_info);\n\n\t\ttun_id = tunnel_id_to_key32(key->tun_id);\n\t\tif (md->version == 1) {\n\t\t\terspan_build_header(skb,\n\t\t\t\t\t    ntohl(tun_id),\n\t\t\t\t\t    ntohl(md->u.index), truncate,\n\t\t\t\t\t    false);\n\t\t\tproto = htons(ETH_P_ERSPAN);\n\t\t} else if (md->version == 2) {\n\t\t\terspan_build_header_v2(skb,\n\t\t\t\t\t       ntohl(tun_id),\n\t\t\t\t\t       md->u.md2.dir,\n\t\t\t\t\t       get_hwid(&md->u.md2),\n\t\t\t\t\t       truncate, false);\n\t\t\tproto = htons(ETH_P_ERSPAN2);\n\t\t} else {\n\t\t\tgoto tx_err;\n\t\t}\n\t} else {\n\t\tswitch (skb->protocol) {\n\t\tcase htons(ETH_P_IP):\n\t\t\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\t\t\tprepare_ip6gre_xmit_ipv4(skb, dev, &fl6,\n\t\t\t\t\t\t &dsfield, &encap_limit);\n\t\t\tbreak;\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tif (ipv6_addr_equal(&t->parms.raddr, &ipv6_hdr(skb)->saddr))\n\t\t\t\tgoto tx_err;\n\t\t\tif (prepare_ip6gre_xmit_ipv6(skb, dev, &fl6,\n\t\t\t\t\t\t     &dsfield, &encap_limit))\n\t\t\t\tgoto tx_err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemcpy(&fl6, &t->fl.u.ip6, sizeof(fl6));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (t->parms.erspan_ver == 1) {\n\t\t\terspan_build_header(skb, ntohl(t->parms.o_key),\n\t\t\t\t\t    t->parms.index,\n\t\t\t\t\t    truncate, false);\n\t\t\tproto = htons(ETH_P_ERSPAN);\n\t\t} else if (t->parms.erspan_ver == 2) {\n\t\t\terspan_build_header_v2(skb, ntohl(t->parms.o_key),\n\t\t\t\t\t       t->parms.dir,\n\t\t\t\t\t       t->parms.hwid,\n\t\t\t\t\t       truncate, false);\n\t\t\tproto = htons(ETH_P_ERSPAN2);\n\t\t} else {\n\t\t\tgoto tx_err;\n\t\t}\n\n\t\tfl6.daddr = t->parms.raddr;\n\t}\n\n\t \n\tgre_build_header(skb, 8, TUNNEL_SEQ, proto, 0, htonl(atomic_fetch_inc(&t->o_seqno)));\n\n\t \n\tif (!t->parms.collect_md && dst && dst_mtu(dst) > dst->dev->mtu)\n\t\tdst->ops->update_pmtu(dst, NULL, skb, dst->dev->mtu, false);\n\n\terr = ip6_tnl_xmit(skb, dev, dsfield, &fl6, encap_limit, &mtu,\n\t\t\t   NEXTHDR_GRE);\n\tif (err != 0) {\n\t\t \n\t\tif (err == -EMSGSIZE) {\n\t\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\t\ticmp_ndo_send(skb, ICMP_DEST_UNREACH,\n\t\t\t\t\t      ICMP_FRAG_NEEDED, htonl(mtu));\n\t\t\telse\n\t\t\t\ticmpv6_ndo_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\t}\n\n\t\tgoto tx_err;\n\t}\n\treturn NETDEV_TX_OK;\n\ntx_err:\n\tif (!IS_ERR(tun_info))\n\t\tDEV_STATS_INC(dev, tx_errors);\n\tDEV_STATS_INC(dev, tx_dropped);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ip6gre_tnl_link_config_common(struct ip6_tnl *t)\n{\n\tstruct net_device *dev = t->dev;\n\tstruct __ip6_tnl_parm *p = &t->parms;\n\tstruct flowi6 *fl6 = &t->fl.u.ip6;\n\n\tif (dev->type != ARPHRD_ETHER) {\n\t\t__dev_addr_set(dev, &p->laddr, sizeof(struct in6_addr));\n\t\tmemcpy(dev->broadcast, &p->raddr, sizeof(struct in6_addr));\n\t}\n\n\t \n\tfl6->saddr = p->laddr;\n\tfl6->daddr = p->raddr;\n\tfl6->flowi6_oif = p->link;\n\tfl6->flowlabel = 0;\n\tfl6->flowi6_proto = IPPROTO_GRE;\n\tfl6->fl6_gre_key = t->parms.o_key;\n\n\tif (!(p->flags&IP6_TNL_F_USE_ORIG_TCLASS))\n\t\tfl6->flowlabel |= IPV6_TCLASS_MASK & p->flowinfo;\n\tif (!(p->flags&IP6_TNL_F_USE_ORIG_FLOWLABEL))\n\t\tfl6->flowlabel |= IPV6_FLOWLABEL_MASK & p->flowinfo;\n\n\tp->flags &= ~(IP6_TNL_F_CAP_XMIT|IP6_TNL_F_CAP_RCV|IP6_TNL_F_CAP_PER_PACKET);\n\tp->flags |= ip6_tnl_get_cap(t, &p->laddr, &p->raddr);\n\n\tif (p->flags&IP6_TNL_F_CAP_XMIT &&\n\t\t\tp->flags&IP6_TNL_F_CAP_RCV && dev->type != ARPHRD_ETHER)\n\t\tdev->flags |= IFF_POINTOPOINT;\n\telse\n\t\tdev->flags &= ~IFF_POINTOPOINT;\n}\n\nstatic void ip6gre_tnl_link_config_route(struct ip6_tnl *t, int set_mtu,\n\t\t\t\t\t int t_hlen)\n{\n\tconst struct __ip6_tnl_parm *p = &t->parms;\n\tstruct net_device *dev = t->dev;\n\n\tif (p->flags & IP6_TNL_F_CAP_XMIT) {\n\t\tint strict = (ipv6_addr_type(&p->raddr) &\n\t\t\t      (IPV6_ADDR_MULTICAST|IPV6_ADDR_LINKLOCAL));\n\n\t\tstruct rt6_info *rt = rt6_lookup(t->net,\n\t\t\t\t\t\t &p->raddr, &p->laddr,\n\t\t\t\t\t\t p->link, NULL, strict);\n\n\t\tif (!rt)\n\t\t\treturn;\n\n\t\tif (rt->dst.dev) {\n\t\t\tunsigned short dst_len = rt->dst.dev->hard_header_len +\n\t\t\t\t\t\t t_hlen;\n\n\t\t\tif (t->dev->header_ops)\n\t\t\t\tdev->hard_header_len = dst_len;\n\t\t\telse\n\t\t\t\tdev->needed_headroom = dst_len;\n\n\t\t\tif (set_mtu) {\n\t\t\t\tint mtu = rt->dst.dev->mtu - t_hlen;\n\n\t\t\t\tif (!(t->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\n\t\t\t\t\tmtu -= 8;\n\t\t\t\tif (dev->type == ARPHRD_ETHER)\n\t\t\t\t\tmtu -= ETH_HLEN;\n\n\t\t\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\t\t\tmtu = IPV6_MIN_MTU;\n\t\t\t\tWRITE_ONCE(dev->mtu, mtu);\n\t\t\t}\n\t\t}\n\t\tip6_rt_put(rt);\n\t}\n}\n\nstatic int ip6gre_calc_hlen(struct ip6_tnl *tunnel)\n{\n\tint t_hlen;\n\n\ttunnel->tun_hlen = gre_calc_hlen(tunnel->parms.o_flags);\n\ttunnel->hlen = tunnel->tun_hlen + tunnel->encap_hlen;\n\n\tt_hlen = tunnel->hlen + sizeof(struct ipv6hdr);\n\n\tif (tunnel->dev->header_ops)\n\t\ttunnel->dev->hard_header_len = LL_MAX_HEADER + t_hlen;\n\telse\n\t\ttunnel->dev->needed_headroom = LL_MAX_HEADER + t_hlen;\n\n\treturn t_hlen;\n}\n\nstatic void ip6gre_tnl_link_config(struct ip6_tnl *t, int set_mtu)\n{\n\tip6gre_tnl_link_config_common(t);\n\tip6gre_tnl_link_config_route(t, set_mtu, ip6gre_calc_hlen(t));\n}\n\nstatic void ip6gre_tnl_copy_tnl_parm(struct ip6_tnl *t,\n\t\t\t\t     const struct __ip6_tnl_parm *p)\n{\n\tt->parms.laddr = p->laddr;\n\tt->parms.raddr = p->raddr;\n\tt->parms.flags = p->flags;\n\tt->parms.hop_limit = p->hop_limit;\n\tt->parms.encap_limit = p->encap_limit;\n\tt->parms.flowinfo = p->flowinfo;\n\tt->parms.link = p->link;\n\tt->parms.proto = p->proto;\n\tt->parms.i_key = p->i_key;\n\tt->parms.o_key = p->o_key;\n\tt->parms.i_flags = p->i_flags;\n\tt->parms.o_flags = p->o_flags;\n\tt->parms.fwmark = p->fwmark;\n\tt->parms.erspan_ver = p->erspan_ver;\n\tt->parms.index = p->index;\n\tt->parms.dir = p->dir;\n\tt->parms.hwid = p->hwid;\n\tdst_cache_reset(&t->dst_cache);\n}\n\nstatic int ip6gre_tnl_change(struct ip6_tnl *t, const struct __ip6_tnl_parm *p,\n\t\t\t     int set_mtu)\n{\n\tip6gre_tnl_copy_tnl_parm(t, p);\n\tip6gre_tnl_link_config(t, set_mtu);\n\treturn 0;\n}\n\nstatic void ip6gre_tnl_parm_from_user(struct __ip6_tnl_parm *p,\n\tconst struct ip6_tnl_parm2 *u)\n{\n\tp->laddr = u->laddr;\n\tp->raddr = u->raddr;\n\tp->flags = u->flags;\n\tp->hop_limit = u->hop_limit;\n\tp->encap_limit = u->encap_limit;\n\tp->flowinfo = u->flowinfo;\n\tp->link = u->link;\n\tp->i_key = u->i_key;\n\tp->o_key = u->o_key;\n\tp->i_flags = gre_flags_to_tnl_flags(u->i_flags);\n\tp->o_flags = gre_flags_to_tnl_flags(u->o_flags);\n\tmemcpy(p->name, u->name, sizeof(u->name));\n}\n\nstatic void ip6gre_tnl_parm_to_user(struct ip6_tnl_parm2 *u,\n\tconst struct __ip6_tnl_parm *p)\n{\n\tu->proto = IPPROTO_GRE;\n\tu->laddr = p->laddr;\n\tu->raddr = p->raddr;\n\tu->flags = p->flags;\n\tu->hop_limit = p->hop_limit;\n\tu->encap_limit = p->encap_limit;\n\tu->flowinfo = p->flowinfo;\n\tu->link = p->link;\n\tu->i_key = p->i_key;\n\tu->o_key = p->o_key;\n\tu->i_flags = gre_tnl_flags_to_gre_flags(p->i_flags);\n\tu->o_flags = gre_tnl_flags_to_gre_flags(p->o_flags);\n\tmemcpy(u->name, p->name, sizeof(u->name));\n}\n\nstatic int ip6gre_tunnel_siocdevprivate(struct net_device *dev,\n\t\t\t\t\tstruct ifreq *ifr, void __user *data,\n\t\t\t\t\tint cmd)\n{\n\tint err = 0;\n\tstruct ip6_tnl_parm2 p;\n\tstruct __ip6_tnl_parm p1;\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net *net = t->net;\n\tstruct ip6gre_net *ign = net_generic(net, ip6gre_net_id);\n\n\tmemset(&p1, 0, sizeof(p1));\n\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n\t\tif (dev == ign->fb_tunnel_dev) {\n\t\t\tif (copy_from_user(&p, data, sizeof(p))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tip6gre_tnl_parm_from_user(&p1, &p);\n\t\t\tt = ip6gre_tunnel_locate(net, &p1, 0);\n\t\t\tif (!t)\n\t\t\t\tt = netdev_priv(dev);\n\t\t}\n\t\tmemset(&p, 0, sizeof(p));\n\t\tip6gre_tnl_parm_to_user(&p, &t->parms);\n\t\tif (copy_to_user(data, &p, sizeof(p)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&p, data, sizeof(p)))\n\t\t\tgoto done;\n\n\t\terr = -EINVAL;\n\t\tif ((p.i_flags|p.o_flags)&(GRE_VERSION|GRE_ROUTING))\n\t\t\tgoto done;\n\n\t\tif (!(p.i_flags&GRE_KEY))\n\t\t\tp.i_key = 0;\n\t\tif (!(p.o_flags&GRE_KEY))\n\t\t\tp.o_key = 0;\n\n\t\tip6gre_tnl_parm_from_user(&p1, &p);\n\t\tt = ip6gre_tunnel_locate(net, &p1, cmd == SIOCADDTUNNEL);\n\n\t\tif (dev != ign->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {\n\t\t\tif (t) {\n\t\t\t\tif (t->dev != dev) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt = netdev_priv(dev);\n\n\t\t\t\tip6gre_tunnel_unlink(ign, t);\n\t\t\t\tsynchronize_net();\n\t\t\t\tip6gre_tnl_change(t, &p1, 1);\n\t\t\t\tip6gre_tunnel_link(ign, t);\n\t\t\t\tnetdev_state_change(dev);\n\t\t\t}\n\t\t}\n\n\t\tif (t) {\n\t\t\terr = 0;\n\n\t\t\tmemset(&p, 0, sizeof(p));\n\t\t\tip6gre_tnl_parm_to_user(&p, &t->parms);\n\t\t\tif (copy_to_user(data, &p, sizeof(p)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\terr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\n\t\tbreak;\n\n\tcase SIOCDELTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tgoto done;\n\n\t\tif (dev == ign->fb_tunnel_dev) {\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(&p, data, sizeof(p)))\n\t\t\t\tgoto done;\n\t\t\terr = -ENOENT;\n\t\t\tip6gre_tnl_parm_from_user(&p1, &p);\n\t\t\tt = ip6gre_tunnel_locate(net, &p1, 0);\n\t\t\tif (!t)\n\t\t\t\tgoto done;\n\t\t\terr = -EPERM;\n\t\t\tif (t == netdev_priv(ign->fb_tunnel_dev))\n\t\t\t\tgoto done;\n\t\t\tdev = t->dev;\n\t\t}\n\t\tunregister_netdevice(dev);\n\t\terr = 0;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\ndone:\n\treturn err;\n}\n\nstatic int ip6gre_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t unsigned short type, const void *daddr,\n\t\t\t const void *saddr, unsigned int len)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct ipv6hdr *ipv6h;\n\t__be16 *p;\n\n\tipv6h = skb_push(skb, t->hlen + sizeof(*ipv6h));\n\tip6_flow_hdr(ipv6h, 0, ip6_make_flowlabel(dev_net(dev), skb,\n\t\t\t\t\t\t  t->fl.u.ip6.flowlabel,\n\t\t\t\t\t\t  true, &t->fl.u.ip6));\n\tipv6h->hop_limit = t->parms.hop_limit;\n\tipv6h->nexthdr = NEXTHDR_GRE;\n\tipv6h->saddr = t->parms.laddr;\n\tipv6h->daddr = t->parms.raddr;\n\n\tp = (__be16 *)(ipv6h + 1);\n\tp[0] = t->parms.o_flags;\n\tp[1] = htons(type);\n\n\t \n\n\tif (saddr)\n\t\tmemcpy(&ipv6h->saddr, saddr, sizeof(struct in6_addr));\n\tif (daddr)\n\t\tmemcpy(&ipv6h->daddr, daddr, sizeof(struct in6_addr));\n\tif (!ipv6_addr_any(&ipv6h->daddr))\n\t\treturn t->hlen;\n\n\treturn -t->hlen;\n}\n\nstatic const struct header_ops ip6gre_header_ops = {\n\t.create\t= ip6gre_header,\n};\n\nstatic const struct net_device_ops ip6gre_netdev_ops = {\n\t.ndo_init\t\t= ip6gre_tunnel_init,\n\t.ndo_uninit\t\t= ip6gre_tunnel_uninit,\n\t.ndo_start_xmit\t\t= ip6gre_tunnel_xmit,\n\t.ndo_siocdevprivate\t= ip6gre_tunnel_siocdevprivate,\n\t.ndo_change_mtu\t\t= ip6_tnl_change_mtu,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_get_iflink\t\t= ip6_tnl_get_iflink,\n};\n\nstatic void ip6gre_dev_free(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\n\tgro_cells_destroy(&t->gro_cells);\n\tdst_cache_destroy(&t->dst_cache);\n\tfree_percpu(dev->tstats);\n}\n\nstatic void ip6gre_tunnel_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &ip6gre_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = ip6gre_dev_free;\n\n\tdev->type = ARPHRD_IP6GRE;\n\n\tdev->flags |= IFF_NOARP;\n\tdev->addr_len = sizeof(struct in6_addr);\n\tnetif_keep_dst(dev);\n\t \n\tdev->addr_assign_type = NET_ADDR_RANDOM;\n\teth_random_addr(dev->perm_addr);\n}\n\n#define GRE6_FEATURES (NETIF_F_SG |\t\t\\\n\t\t       NETIF_F_FRAGLIST |\t\\\n\t\t       NETIF_F_HIGHDMA |\t\\\n\t\t       NETIF_F_HW_CSUM)\n\nstatic void ip6gre_tnl_init_features(struct net_device *dev)\n{\n\tstruct ip6_tnl *nt = netdev_priv(dev);\n\t__be16 flags;\n\n\tdev->features\t\t|= GRE6_FEATURES | NETIF_F_LLTX;\n\tdev->hw_features\t|= GRE6_FEATURES;\n\n\tflags = nt->parms.o_flags;\n\n\t \n\tif (flags & TUNNEL_SEQ)\n\t\treturn;\n\tif (flags & TUNNEL_CSUM && nt->encap.type != TUNNEL_ENCAP_NONE)\n\t\treturn;\n\n\tdev->features |= NETIF_F_GSO_SOFTWARE;\n\tdev->hw_features |= NETIF_F_GSO_SOFTWARE;\n}\n\nstatic int ip6gre_tunnel_init_common(struct net_device *dev)\n{\n\tstruct ip6_tnl *tunnel;\n\tint ret;\n\tint t_hlen;\n\n\ttunnel = netdev_priv(dev);\n\n\ttunnel->dev = dev;\n\ttunnel->net = dev_net(dev);\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\tret = dst_cache_init(&tunnel->dst_cache, GFP_KERNEL);\n\tif (ret)\n\t\tgoto cleanup_alloc_pcpu_stats;\n\n\tret = gro_cells_init(&tunnel->gro_cells, dev);\n\tif (ret)\n\t\tgoto cleanup_dst_cache_init;\n\n\tt_hlen = ip6gre_calc_hlen(tunnel);\n\tdev->mtu = ETH_DATA_LEN - t_hlen;\n\tif (dev->type == ARPHRD_ETHER)\n\t\tdev->mtu -= ETH_HLEN;\n\tif (!(tunnel->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\n\t\tdev->mtu -= 8;\n\n\tif (tunnel->parms.collect_md) {\n\t\tnetif_keep_dst(dev);\n\t}\n\tip6gre_tnl_init_features(dev);\n\n\tnetdev_hold(dev, &tunnel->dev_tracker, GFP_KERNEL);\n\treturn 0;\n\ncleanup_dst_cache_init:\n\tdst_cache_destroy(&tunnel->dst_cache);\ncleanup_alloc_pcpu_stats:\n\tfree_percpu(dev->tstats);\n\tdev->tstats = NULL;\n\treturn ret;\n}\n\nstatic int ip6gre_tunnel_init(struct net_device *dev)\n{\n\tstruct ip6_tnl *tunnel;\n\tint ret;\n\n\tret = ip6gre_tunnel_init_common(dev);\n\tif (ret)\n\t\treturn ret;\n\n\ttunnel = netdev_priv(dev);\n\n\tif (tunnel->parms.collect_md)\n\t\treturn 0;\n\n\t__dev_addr_set(dev, &tunnel->parms.laddr, sizeof(struct in6_addr));\n\tmemcpy(dev->broadcast, &tunnel->parms.raddr, sizeof(struct in6_addr));\n\n\tif (ipv6_addr_any(&tunnel->parms.raddr))\n\t\tdev->header_ops = &ip6gre_header_ops;\n\n\treturn 0;\n}\n\nstatic void ip6gre_fb_tunnel_init(struct net_device *dev)\n{\n\tstruct ip6_tnl *tunnel = netdev_priv(dev);\n\n\ttunnel->dev = dev;\n\ttunnel->net = dev_net(dev);\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\ttunnel->hlen\t\t= sizeof(struct ipv6hdr) + 4;\n}\n\nstatic struct inet6_protocol ip6gre_protocol __read_mostly = {\n\t.handler     = gre_rcv,\n\t.err_handler = ip6gre_err,\n\t.flags       = INET6_PROTO_FINAL,\n};\n\nstatic void ip6gre_destroy_tunnels(struct net *net, struct list_head *head)\n{\n\tstruct ip6gre_net *ign = net_generic(net, ip6gre_net_id);\n\tstruct net_device *dev, *aux;\n\tint prio;\n\n\tfor_each_netdev_safe(net, dev, aux)\n\t\tif (dev->rtnl_link_ops == &ip6gre_link_ops ||\n\t\t    dev->rtnl_link_ops == &ip6gre_tap_ops ||\n\t\t    dev->rtnl_link_ops == &ip6erspan_tap_ops)\n\t\t\tunregister_netdevice_queue(dev, head);\n\n\tfor (prio = 0; prio < 4; prio++) {\n\t\tint h;\n\t\tfor (h = 0; h < IP6_GRE_HASH_SIZE; h++) {\n\t\t\tstruct ip6_tnl *t;\n\n\t\t\tt = rtnl_dereference(ign->tunnels[prio][h]);\n\n\t\t\twhile (t) {\n\t\t\t\t \n\t\t\t\tif (!net_eq(dev_net(t->dev), net))\n\t\t\t\t\tunregister_netdevice_queue(t->dev,\n\t\t\t\t\t\t\t\t   head);\n\t\t\t\tt = rtnl_dereference(t->next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __net_init ip6gre_init_net(struct net *net)\n{\n\tstruct ip6gre_net *ign = net_generic(net, ip6gre_net_id);\n\tstruct net_device *ndev;\n\tint err;\n\n\tif (!net_has_fallback_tunnels(net))\n\t\treturn 0;\n\tndev = alloc_netdev(sizeof(struct ip6_tnl), \"ip6gre0\",\n\t\t\t    NET_NAME_UNKNOWN, ip6gre_tunnel_setup);\n\tif (!ndev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tign->fb_tunnel_dev = ndev;\n\tdev_net_set(ign->fb_tunnel_dev, net);\n\t \n\tign->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;\n\n\n\tip6gre_fb_tunnel_init(ign->fb_tunnel_dev);\n\tign->fb_tunnel_dev->rtnl_link_ops = &ip6gre_link_ops;\n\n\terr = register_netdev(ign->fb_tunnel_dev);\n\tif (err)\n\t\tgoto err_reg_dev;\n\n\trcu_assign_pointer(ign->tunnels_wc[0],\n\t\t\t   netdev_priv(ign->fb_tunnel_dev));\n\treturn 0;\n\nerr_reg_dev:\n\tfree_netdev(ndev);\nerr_alloc_dev:\n\treturn err;\n}\n\nstatic void __net_exit ip6gre_exit_batch_net(struct list_head *net_list)\n{\n\tstruct net *net;\n\tLIST_HEAD(list);\n\n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list)\n\t\tip6gre_destroy_tunnels(net, &list);\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations ip6gre_net_ops = {\n\t.init = ip6gre_init_net,\n\t.exit_batch = ip6gre_exit_batch_net,\n\t.id   = &ip6gre_net_id,\n\t.size = sizeof(struct ip6gre_net),\n};\n\nstatic int ip6gre_tunnel_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\t__be16 flags;\n\n\tif (!data)\n\t\treturn 0;\n\n\tflags = 0;\n\tif (data[IFLA_GRE_IFLAGS])\n\t\tflags |= nla_get_be16(data[IFLA_GRE_IFLAGS]);\n\tif (data[IFLA_GRE_OFLAGS])\n\t\tflags |= nla_get_be16(data[IFLA_GRE_OFLAGS]);\n\tif (flags & (GRE_VERSION|GRE_ROUTING))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ip6gre_tap_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct in6_addr daddr;\n\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (!data)\n\t\tgoto out;\n\n\tif (data[IFLA_GRE_REMOTE]) {\n\t\tdaddr = nla_get_in6_addr(data[IFLA_GRE_REMOTE]);\n\t\tif (ipv6_addr_any(&daddr))\n\t\t\treturn -EINVAL;\n\t}\n\nout:\n\treturn ip6gre_tunnel_validate(tb, data, extack);\n}\n\nstatic int ip6erspan_tap_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\t__be16 flags = 0;\n\tint ret, ver = 0;\n\n\tif (!data)\n\t\treturn 0;\n\n\tret = ip6gre_tap_validate(tb, data, extack);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (data[IFLA_GRE_OFLAGS])\n\t\tflags |= nla_get_be16(data[IFLA_GRE_OFLAGS]);\n\tif (data[IFLA_GRE_IFLAGS])\n\t\tflags |= nla_get_be16(data[IFLA_GRE_IFLAGS]);\n\tif (!data[IFLA_GRE_COLLECT_METADATA] &&\n\t    flags != (GRE_SEQ | GRE_KEY))\n\t\treturn -EINVAL;\n\n\t \n\tif (data[IFLA_GRE_IKEY] &&\n\t    (ntohl(nla_get_be32(data[IFLA_GRE_IKEY])) & ~ID_MASK))\n\t\treturn -EINVAL;\n\n\tif (data[IFLA_GRE_OKEY] &&\n\t    (ntohl(nla_get_be32(data[IFLA_GRE_OKEY])) & ~ID_MASK))\n\t\treturn -EINVAL;\n\n\tif (data[IFLA_GRE_ERSPAN_VER]) {\n\t\tver = nla_get_u8(data[IFLA_GRE_ERSPAN_VER]);\n\t\tif (ver != 1 && ver != 2)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (ver == 1) {\n\t\tif (data[IFLA_GRE_ERSPAN_INDEX]) {\n\t\t\tu32 index = nla_get_u32(data[IFLA_GRE_ERSPAN_INDEX]);\n\n\t\t\tif (index & ~INDEX_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (ver == 2) {\n\t\tif (data[IFLA_GRE_ERSPAN_DIR]) {\n\t\t\tu16 dir = nla_get_u8(data[IFLA_GRE_ERSPAN_DIR]);\n\n\t\t\tif (dir & ~(DIR_MASK >> DIR_OFFSET))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (data[IFLA_GRE_ERSPAN_HWID]) {\n\t\t\tu16 hwid = nla_get_u16(data[IFLA_GRE_ERSPAN_HWID]);\n\n\t\t\tif (hwid & ~(HWID_MASK >> HWID_OFFSET))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ip6erspan_set_version(struct nlattr *data[],\n\t\t\t\t  struct __ip6_tnl_parm *parms)\n{\n\tif (!data)\n\t\treturn;\n\n\tparms->erspan_ver = 1;\n\tif (data[IFLA_GRE_ERSPAN_VER])\n\t\tparms->erspan_ver = nla_get_u8(data[IFLA_GRE_ERSPAN_VER]);\n\n\tif (parms->erspan_ver == 1) {\n\t\tif (data[IFLA_GRE_ERSPAN_INDEX])\n\t\t\tparms->index = nla_get_u32(data[IFLA_GRE_ERSPAN_INDEX]);\n\t} else if (parms->erspan_ver == 2) {\n\t\tif (data[IFLA_GRE_ERSPAN_DIR])\n\t\t\tparms->dir = nla_get_u8(data[IFLA_GRE_ERSPAN_DIR]);\n\t\tif (data[IFLA_GRE_ERSPAN_HWID])\n\t\t\tparms->hwid = nla_get_u16(data[IFLA_GRE_ERSPAN_HWID]);\n\t}\n}\n\nstatic void ip6gre_netlink_parms(struct nlattr *data[],\n\t\t\t\tstruct __ip6_tnl_parm *parms)\n{\n\tmemset(parms, 0, sizeof(*parms));\n\n\tif (!data)\n\t\treturn;\n\n\tif (data[IFLA_GRE_LINK])\n\t\tparms->link = nla_get_u32(data[IFLA_GRE_LINK]);\n\n\tif (data[IFLA_GRE_IFLAGS])\n\t\tparms->i_flags = gre_flags_to_tnl_flags(\n\t\t\t\tnla_get_be16(data[IFLA_GRE_IFLAGS]));\n\n\tif (data[IFLA_GRE_OFLAGS])\n\t\tparms->o_flags = gre_flags_to_tnl_flags(\n\t\t\t\tnla_get_be16(data[IFLA_GRE_OFLAGS]));\n\n\tif (data[IFLA_GRE_IKEY])\n\t\tparms->i_key = nla_get_be32(data[IFLA_GRE_IKEY]);\n\n\tif (data[IFLA_GRE_OKEY])\n\t\tparms->o_key = nla_get_be32(data[IFLA_GRE_OKEY]);\n\n\tif (data[IFLA_GRE_LOCAL])\n\t\tparms->laddr = nla_get_in6_addr(data[IFLA_GRE_LOCAL]);\n\n\tif (data[IFLA_GRE_REMOTE])\n\t\tparms->raddr = nla_get_in6_addr(data[IFLA_GRE_REMOTE]);\n\n\tif (data[IFLA_GRE_TTL])\n\t\tparms->hop_limit = nla_get_u8(data[IFLA_GRE_TTL]);\n\n\tif (data[IFLA_GRE_ENCAP_LIMIT])\n\t\tparms->encap_limit = nla_get_u8(data[IFLA_GRE_ENCAP_LIMIT]);\n\n\tif (data[IFLA_GRE_FLOWINFO])\n\t\tparms->flowinfo = nla_get_be32(data[IFLA_GRE_FLOWINFO]);\n\n\tif (data[IFLA_GRE_FLAGS])\n\t\tparms->flags = nla_get_u32(data[IFLA_GRE_FLAGS]);\n\n\tif (data[IFLA_GRE_FWMARK])\n\t\tparms->fwmark = nla_get_u32(data[IFLA_GRE_FWMARK]);\n\n\tif (data[IFLA_GRE_COLLECT_METADATA])\n\t\tparms->collect_md = true;\n}\n\nstatic int ip6gre_tap_init(struct net_device *dev)\n{\n\tint ret;\n\n\tret = ip6gre_tunnel_init_common(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ip6gre_tap_netdev_ops = {\n\t.ndo_init = ip6gre_tap_init,\n\t.ndo_uninit = ip6gre_tunnel_uninit,\n\t.ndo_start_xmit = ip6gre_tunnel_xmit,\n\t.ndo_set_mac_address = eth_mac_addr,\n\t.ndo_validate_addr = eth_validate_addr,\n\t.ndo_change_mtu = ip6_tnl_change_mtu,\n\t.ndo_get_stats64 = dev_get_tstats64,\n\t.ndo_get_iflink = ip6_tnl_get_iflink,\n};\n\nstatic int ip6erspan_calc_hlen(struct ip6_tnl *tunnel)\n{\n\tint t_hlen;\n\n\ttunnel->tun_hlen = 8;\n\ttunnel->hlen = tunnel->tun_hlen + tunnel->encap_hlen +\n\t\t       erspan_hdr_len(tunnel->parms.erspan_ver);\n\n\tt_hlen = tunnel->hlen + sizeof(struct ipv6hdr);\n\ttunnel->dev->needed_headroom = LL_MAX_HEADER + t_hlen;\n\treturn t_hlen;\n}\n\nstatic int ip6erspan_tap_init(struct net_device *dev)\n{\n\tstruct ip6_tnl *tunnel;\n\tint t_hlen;\n\tint ret;\n\n\ttunnel = netdev_priv(dev);\n\n\ttunnel->dev = dev;\n\ttunnel->net = dev_net(dev);\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\tret = dst_cache_init(&tunnel->dst_cache, GFP_KERNEL);\n\tif (ret)\n\t\tgoto cleanup_alloc_pcpu_stats;\n\n\tret = gro_cells_init(&tunnel->gro_cells, dev);\n\tif (ret)\n\t\tgoto cleanup_dst_cache_init;\n\n\tt_hlen = ip6erspan_calc_hlen(tunnel);\n\tdev->mtu = ETH_DATA_LEN - t_hlen;\n\tif (dev->type == ARPHRD_ETHER)\n\t\tdev->mtu -= ETH_HLEN;\n\tif (!(tunnel->parms.flags & IP6_TNL_F_IGN_ENCAP_LIMIT))\n\t\tdev->mtu -= 8;\n\n\tdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\tip6erspan_tnl_link_config(tunnel, 1);\n\n\tnetdev_hold(dev, &tunnel->dev_tracker, GFP_KERNEL);\n\treturn 0;\n\ncleanup_dst_cache_init:\n\tdst_cache_destroy(&tunnel->dst_cache);\ncleanup_alloc_pcpu_stats:\n\tfree_percpu(dev->tstats);\n\tdev->tstats = NULL;\n\treturn ret;\n}\n\nstatic const struct net_device_ops ip6erspan_netdev_ops = {\n\t.ndo_init =\t\tip6erspan_tap_init,\n\t.ndo_uninit =\t\tip6erspan_tunnel_uninit,\n\t.ndo_start_xmit =\tip6erspan_tunnel_xmit,\n\t.ndo_set_mac_address =\teth_mac_addr,\n\t.ndo_validate_addr =\teth_validate_addr,\n\t.ndo_change_mtu =\tip6_tnl_change_mtu,\n\t.ndo_get_stats64 =\tdev_get_tstats64,\n\t.ndo_get_iflink =\tip6_tnl_get_iflink,\n};\n\nstatic void ip6gre_tap_setup(struct net_device *dev)\n{\n\n\tether_setup(dev);\n\n\tdev->max_mtu = 0;\n\tdev->netdev_ops = &ip6gre_tap_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = ip6gre_dev_free;\n\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\tnetif_keep_dst(dev);\n}\n\nstatic bool ip6gre_netlink_encap_parms(struct nlattr *data[],\n\t\t\t\t       struct ip_tunnel_encap *ipencap)\n{\n\tbool ret = false;\n\n\tmemset(ipencap, 0, sizeof(*ipencap));\n\n\tif (!data)\n\t\treturn ret;\n\n\tif (data[IFLA_GRE_ENCAP_TYPE]) {\n\t\tret = true;\n\t\tipencap->type = nla_get_u16(data[IFLA_GRE_ENCAP_TYPE]);\n\t}\n\n\tif (data[IFLA_GRE_ENCAP_FLAGS]) {\n\t\tret = true;\n\t\tipencap->flags = nla_get_u16(data[IFLA_GRE_ENCAP_FLAGS]);\n\t}\n\n\tif (data[IFLA_GRE_ENCAP_SPORT]) {\n\t\tret = true;\n\t\tipencap->sport = nla_get_be16(data[IFLA_GRE_ENCAP_SPORT]);\n\t}\n\n\tif (data[IFLA_GRE_ENCAP_DPORT]) {\n\t\tret = true;\n\t\tipencap->dport = nla_get_be16(data[IFLA_GRE_ENCAP_DPORT]);\n\t}\n\n\treturn ret;\n}\n\nstatic int ip6gre_newlink_common(struct net *src_net, struct net_device *dev,\n\t\t\t\t struct nlattr *tb[], struct nlattr *data[],\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct ip6_tnl *nt;\n\tstruct ip_tunnel_encap ipencap;\n\tint err;\n\n\tnt = netdev_priv(dev);\n\n\tif (ip6gre_netlink_encap_parms(data, &ipencap)) {\n\t\tint err = ip6_tnl_encap_setup(nt, &ipencap);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (dev->type == ARPHRD_ETHER && !tb[IFLA_ADDRESS])\n\t\teth_hw_addr_random(dev);\n\n\tnt->dev = dev;\n\tnt->net = dev_net(dev);\n\n\terr = register_netdevice(dev);\n\tif (err)\n\t\tgoto out;\n\n\tif (tb[IFLA_MTU])\n\t\tip6_tnl_change_mtu(dev, nla_get_u32(tb[IFLA_MTU]));\n\nout:\n\treturn err;\n}\n\nstatic int ip6gre_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t  struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ip6_tnl *nt = netdev_priv(dev);\n\tstruct net *net = dev_net(dev);\n\tstruct ip6gre_net *ign;\n\tint err;\n\n\tip6gre_netlink_parms(data, &nt->parms);\n\tign = net_generic(net, ip6gre_net_id);\n\n\tif (nt->parms.collect_md) {\n\t\tif (rtnl_dereference(ign->collect_md_tun))\n\t\t\treturn -EEXIST;\n\t} else {\n\t\tif (ip6gre_tunnel_find(net, &nt->parms, dev->type))\n\t\t\treturn -EEXIST;\n\t}\n\n\terr = ip6gre_newlink_common(src_net, dev, tb, data, extack);\n\tif (!err) {\n\t\tip6gre_tnl_link_config(nt, !tb[IFLA_MTU]);\n\t\tip6gre_tunnel_link_md(ign, nt);\n\t\tip6gre_tunnel_link(net_generic(net, ip6gre_net_id), nt);\n\t}\n\treturn err;\n}\n\nstatic struct ip6_tnl *\nip6gre_changelink_common(struct net_device *dev, struct nlattr *tb[],\n\t\t\t struct nlattr *data[], struct __ip6_tnl_parm *p_p,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct ip6_tnl *t, *nt = netdev_priv(dev);\n\tstruct net *net = nt->net;\n\tstruct ip6gre_net *ign = net_generic(net, ip6gre_net_id);\n\tstruct ip_tunnel_encap ipencap;\n\n\tif (dev == ign->fb_tunnel_dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (ip6gre_netlink_encap_parms(data, &ipencap)) {\n\t\tint err = ip6_tnl_encap_setup(nt, &ipencap);\n\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\tip6gre_netlink_parms(data, p_p);\n\n\tt = ip6gre_tunnel_locate(net, p_p, 0);\n\n\tif (t) {\n\t\tif (t->dev != dev)\n\t\t\treturn ERR_PTR(-EEXIST);\n\t} else {\n\t\tt = nt;\n\t}\n\n\treturn t;\n}\n\nstatic int ip6gre_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t     struct nlattr *data[],\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct ip6gre_net *ign = net_generic(t->net, ip6gre_net_id);\n\tstruct __ip6_tnl_parm p;\n\n\tt = ip6gre_changelink_common(dev, tb, data, &p, extack);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\tip6gre_tunnel_unlink_md(ign, t);\n\tip6gre_tunnel_unlink(ign, t);\n\tip6gre_tnl_change(t, &p, !tb[IFLA_MTU]);\n\tip6gre_tunnel_link_md(ign, t);\n\tip6gre_tunnel_link(ign, t);\n\treturn 0;\n}\n\nstatic void ip6gre_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ip6gre_net *ign = net_generic(net, ip6gre_net_id);\n\n\tif (dev != ign->fb_tunnel_dev)\n\t\tunregister_netdevice_queue(dev, head);\n}\n\nstatic size_t ip6gre_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(sizeof(struct in6_addr)) +\n\t\t \n\t\tnla_total_size(sizeof(struct in6_addr)) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(0) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t0;\n}\n\nstatic int ip6gre_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct __ip6_tnl_parm *p = &t->parms;\n\t__be16 o_flags = p->o_flags;\n\n\tif (p->erspan_ver == 1 || p->erspan_ver == 2) {\n\t\tif (!p->collect_md)\n\t\t\to_flags |= TUNNEL_KEY;\n\n\t\tif (nla_put_u8(skb, IFLA_GRE_ERSPAN_VER, p->erspan_ver))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (p->erspan_ver == 1) {\n\t\t\tif (nla_put_u32(skb, IFLA_GRE_ERSPAN_INDEX, p->index))\n\t\t\t\tgoto nla_put_failure;\n\t\t} else {\n\t\t\tif (nla_put_u8(skb, IFLA_GRE_ERSPAN_DIR, p->dir))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u16(skb, IFLA_GRE_ERSPAN_HWID, p->hwid))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (nla_put_u32(skb, IFLA_GRE_LINK, p->link) ||\n\t    nla_put_be16(skb, IFLA_GRE_IFLAGS,\n\t\t\t gre_tnl_flags_to_gre_flags(p->i_flags)) ||\n\t    nla_put_be16(skb, IFLA_GRE_OFLAGS,\n\t\t\t gre_tnl_flags_to_gre_flags(o_flags)) ||\n\t    nla_put_be32(skb, IFLA_GRE_IKEY, p->i_key) ||\n\t    nla_put_be32(skb, IFLA_GRE_OKEY, p->o_key) ||\n\t    nla_put_in6_addr(skb, IFLA_GRE_LOCAL, &p->laddr) ||\n\t    nla_put_in6_addr(skb, IFLA_GRE_REMOTE, &p->raddr) ||\n\t    nla_put_u8(skb, IFLA_GRE_TTL, p->hop_limit) ||\n\t    nla_put_u8(skb, IFLA_GRE_ENCAP_LIMIT, p->encap_limit) ||\n\t    nla_put_be32(skb, IFLA_GRE_FLOWINFO, p->flowinfo) ||\n\t    nla_put_u32(skb, IFLA_GRE_FLAGS, p->flags) ||\n\t    nla_put_u32(skb, IFLA_GRE_FWMARK, p->fwmark))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(skb, IFLA_GRE_ENCAP_TYPE,\n\t\t\tt->encap.type) ||\n\t    nla_put_be16(skb, IFLA_GRE_ENCAP_SPORT,\n\t\t\t t->encap.sport) ||\n\t    nla_put_be16(skb, IFLA_GRE_ENCAP_DPORT,\n\t\t\t t->encap.dport) ||\n\t    nla_put_u16(skb, IFLA_GRE_ENCAP_FLAGS,\n\t\t\tt->encap.flags))\n\t\tgoto nla_put_failure;\n\n\tif (p->collect_md) {\n\t\tif (nla_put_flag(skb, IFLA_GRE_COLLECT_METADATA))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy ip6gre_policy[IFLA_GRE_MAX + 1] = {\n\t[IFLA_GRE_LINK]        = { .type = NLA_U32 },\n\t[IFLA_GRE_IFLAGS]      = { .type = NLA_U16 },\n\t[IFLA_GRE_OFLAGS]      = { .type = NLA_U16 },\n\t[IFLA_GRE_IKEY]        = { .type = NLA_U32 },\n\t[IFLA_GRE_OKEY]        = { .type = NLA_U32 },\n\t[IFLA_GRE_LOCAL]       = { .len = sizeof_field(struct ipv6hdr, saddr) },\n\t[IFLA_GRE_REMOTE]      = { .len = sizeof_field(struct ipv6hdr, daddr) },\n\t[IFLA_GRE_TTL]         = { .type = NLA_U8 },\n\t[IFLA_GRE_ENCAP_LIMIT] = { .type = NLA_U8 },\n\t[IFLA_GRE_FLOWINFO]    = { .type = NLA_U32 },\n\t[IFLA_GRE_FLAGS]       = { .type = NLA_U32 },\n\t[IFLA_GRE_ENCAP_TYPE]   = { .type = NLA_U16 },\n\t[IFLA_GRE_ENCAP_FLAGS]  = { .type = NLA_U16 },\n\t[IFLA_GRE_ENCAP_SPORT]  = { .type = NLA_U16 },\n\t[IFLA_GRE_ENCAP_DPORT]  = { .type = NLA_U16 },\n\t[IFLA_GRE_COLLECT_METADATA] = { .type = NLA_FLAG },\n\t[IFLA_GRE_FWMARK]       = { .type = NLA_U32 },\n\t[IFLA_GRE_ERSPAN_INDEX] = { .type = NLA_U32 },\n\t[IFLA_GRE_ERSPAN_VER]\t= { .type = NLA_U8 },\n\t[IFLA_GRE_ERSPAN_DIR]\t= { .type = NLA_U8 },\n\t[IFLA_GRE_ERSPAN_HWID]\t= { .type = NLA_U16 },\n};\n\nstatic void ip6erspan_tap_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->max_mtu = 0;\n\tdev->netdev_ops = &ip6erspan_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = ip6gre_dev_free;\n\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\tnetif_keep_dst(dev);\n}\n\nstatic int ip6erspan_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t     struct nlattr *tb[], struct nlattr *data[],\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ip6_tnl *nt = netdev_priv(dev);\n\tstruct net *net = dev_net(dev);\n\tstruct ip6gre_net *ign;\n\tint err;\n\n\tip6gre_netlink_parms(data, &nt->parms);\n\tip6erspan_set_version(data, &nt->parms);\n\tign = net_generic(net, ip6gre_net_id);\n\n\tif (nt->parms.collect_md) {\n\t\tif (rtnl_dereference(ign->collect_md_tun_erspan))\n\t\t\treturn -EEXIST;\n\t} else {\n\t\tif (ip6gre_tunnel_find(net, &nt->parms, dev->type))\n\t\t\treturn -EEXIST;\n\t}\n\n\terr = ip6gre_newlink_common(src_net, dev, tb, data, extack);\n\tif (!err) {\n\t\tip6erspan_tnl_link_config(nt, !tb[IFLA_MTU]);\n\t\tip6erspan_tunnel_link_md(ign, nt);\n\t\tip6gre_tunnel_link(net_generic(net, ip6gre_net_id), nt);\n\t}\n\treturn err;\n}\n\nstatic void ip6erspan_tnl_link_config(struct ip6_tnl *t, int set_mtu)\n{\n\tip6gre_tnl_link_config_common(t);\n\tip6gre_tnl_link_config_route(t, set_mtu, ip6erspan_calc_hlen(t));\n}\n\nstatic int ip6erspan_tnl_change(struct ip6_tnl *t,\n\t\t\t\tconst struct __ip6_tnl_parm *p, int set_mtu)\n{\n\tip6gre_tnl_copy_tnl_parm(t, p);\n\tip6erspan_tnl_link_config(t, set_mtu);\n\treturn 0;\n}\n\nstatic int ip6erspan_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t\tstruct nlattr *data[],\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ip6gre_net *ign = net_generic(dev_net(dev), ip6gre_net_id);\n\tstruct __ip6_tnl_parm p;\n\tstruct ip6_tnl *t;\n\n\tt = ip6gre_changelink_common(dev, tb, data, &p, extack);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\tip6erspan_set_version(data, &p);\n\tip6gre_tunnel_unlink_md(ign, t);\n\tip6gre_tunnel_unlink(ign, t);\n\tip6erspan_tnl_change(t, &p, !tb[IFLA_MTU]);\n\tip6erspan_tunnel_link_md(ign, t);\n\tip6gre_tunnel_link(ign, t);\n\treturn 0;\n}\n\nstatic struct rtnl_link_ops ip6gre_link_ops __read_mostly = {\n\t.kind\t\t= \"ip6gre\",\n\t.maxtype\t= IFLA_GRE_MAX,\n\t.policy\t\t= ip6gre_policy,\n\t.priv_size\t= sizeof(struct ip6_tnl),\n\t.setup\t\t= ip6gre_tunnel_setup,\n\t.validate\t= ip6gre_tunnel_validate,\n\t.newlink\t= ip6gre_newlink,\n\t.changelink\t= ip6gre_changelink,\n\t.dellink\t= ip6gre_dellink,\n\t.get_size\t= ip6gre_get_size,\n\t.fill_info\t= ip6gre_fill_info,\n\t.get_link_net\t= ip6_tnl_get_link_net,\n};\n\nstatic struct rtnl_link_ops ip6gre_tap_ops __read_mostly = {\n\t.kind\t\t= \"ip6gretap\",\n\t.maxtype\t= IFLA_GRE_MAX,\n\t.policy\t\t= ip6gre_policy,\n\t.priv_size\t= sizeof(struct ip6_tnl),\n\t.setup\t\t= ip6gre_tap_setup,\n\t.validate\t= ip6gre_tap_validate,\n\t.newlink\t= ip6gre_newlink,\n\t.changelink\t= ip6gre_changelink,\n\t.get_size\t= ip6gre_get_size,\n\t.fill_info\t= ip6gre_fill_info,\n\t.get_link_net\t= ip6_tnl_get_link_net,\n};\n\nstatic struct rtnl_link_ops ip6erspan_tap_ops __read_mostly = {\n\t.kind\t\t= \"ip6erspan\",\n\t.maxtype\t= IFLA_GRE_MAX,\n\t.policy\t\t= ip6gre_policy,\n\t.priv_size\t= sizeof(struct ip6_tnl),\n\t.setup\t\t= ip6erspan_tap_setup,\n\t.validate\t= ip6erspan_tap_validate,\n\t.newlink\t= ip6erspan_newlink,\n\t.changelink\t= ip6erspan_changelink,\n\t.get_size\t= ip6gre_get_size,\n\t.fill_info\t= ip6gre_fill_info,\n\t.get_link_net\t= ip6_tnl_get_link_net,\n};\n\n \n\nstatic int __init ip6gre_init(void)\n{\n\tint err;\n\n\tpr_info(\"GRE over IPv6 tunneling driver\\n\");\n\n\terr = register_pernet_device(&ip6gre_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = inet6_add_protocol(&ip6gre_protocol, IPPROTO_GRE);\n\tif (err < 0) {\n\t\tpr_info(\"%s: can't add protocol\\n\", __func__);\n\t\tgoto add_proto_failed;\n\t}\n\n\terr = rtnl_link_register(&ip6gre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\n\terr = rtnl_link_register(&ip6gre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\n\n\terr = rtnl_link_register(&ip6erspan_tap_ops);\n\tif (err < 0)\n\t\tgoto erspan_link_failed;\n\nout:\n\treturn err;\n\nerspan_link_failed:\n\trtnl_link_unregister(&ip6gre_tap_ops);\ntap_ops_failed:\n\trtnl_link_unregister(&ip6gre_link_ops);\nrtnl_link_failed:\n\tinet6_del_protocol(&ip6gre_protocol, IPPROTO_GRE);\nadd_proto_failed:\n\tunregister_pernet_device(&ip6gre_net_ops);\n\tgoto out;\n}\n\nstatic void __exit ip6gre_fini(void)\n{\n\trtnl_link_unregister(&ip6gre_tap_ops);\n\trtnl_link_unregister(&ip6gre_link_ops);\n\trtnl_link_unregister(&ip6erspan_tap_ops);\n\tinet6_del_protocol(&ip6gre_protocol, IPPROTO_GRE);\n\tunregister_pernet_device(&ip6gre_net_ops);\n}\n\nmodule_init(ip6gre_init);\nmodule_exit(ip6gre_fini);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"D. Kozlov (xeb@mail.ru)\");\nMODULE_DESCRIPTION(\"GRE over IPv6 tunneling device\");\nMODULE_ALIAS_RTNL_LINK(\"ip6gre\");\nMODULE_ALIAS_RTNL_LINK(\"ip6gretap\");\nMODULE_ALIAS_RTNL_LINK(\"ip6erspan\");\nMODULE_ALIAS_NETDEV(\"ip6gre0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}