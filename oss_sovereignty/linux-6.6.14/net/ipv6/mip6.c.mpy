{
  "module_name": "mip6.c",
  "hash_id": "762086664118847ed847a2482fd7e6806bba5bf6bd8143ca3d1ff2db37e3ae2c",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/mip6.c",
  "human_readable_source": "\n \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/time.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <net/ip6_checksum.h>\n#include <net/rawv6.h>\n#include <net/xfrm.h>\n#include <net/mip6.h>\n\nstatic inline unsigned int calc_padlen(unsigned int len, unsigned int n)\n{\n\treturn (n - len + 16) & 0x7;\n}\n\nstatic inline void *mip6_padn(__u8 *data, __u8 padlen)\n{\n\tif (!data)\n\t\treturn NULL;\n\tif (padlen == 1) {\n\t\tdata[0] = IPV6_TLV_PAD1;\n\t} else if (padlen > 1) {\n\t\tdata[0] = IPV6_TLV_PADN;\n\t\tdata[1] = padlen - 2;\n\t\tif (padlen > 2)\n\t\t\tmemset(data+2, 0, data[1]);\n\t}\n\treturn data + padlen;\n}\n\nstatic inline void mip6_param_prob(struct sk_buff *skb, u8 code, int pos)\n{\n\ticmpv6_send(skb, ICMPV6_PARAMPROB, code, pos);\n}\n\nstatic int mip6_mh_len(int type)\n{\n\tint len = 0;\n\n\tswitch (type) {\n\tcase IP6_MH_TYPE_BRR:\n\t\tlen = 0;\n\t\tbreak;\n\tcase IP6_MH_TYPE_HOTI:\n\tcase IP6_MH_TYPE_COTI:\n\tcase IP6_MH_TYPE_BU:\n\tcase IP6_MH_TYPE_BACK:\n\t\tlen = 1;\n\t\tbreak;\n\tcase IP6_MH_TYPE_HOT:\n\tcase IP6_MH_TYPE_COT:\n\tcase IP6_MH_TYPE_BERROR:\n\t\tlen = 2;\n\t\tbreak;\n\t}\n\treturn len;\n}\n\nstatic int mip6_mh_filter(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ip6_mh _hdr;\n\tconst struct ip6_mh *mh;\n\n\tmh = skb_header_pointer(skb, skb_transport_offset(skb),\n\t\t\t\tsizeof(_hdr), &_hdr);\n\tif (!mh)\n\t\treturn -1;\n\n\tif (((mh->ip6mh_hdrlen + 1) << 3) > skb->len)\n\t\treturn -1;\n\n\tif (mh->ip6mh_hdrlen < mip6_mh_len(mh->ip6mh_type)) {\n\t\tnet_dbg_ratelimited(\"mip6: MH message too short: %d vs >=%d\\n\",\n\t\t\t\t    mh->ip6mh_hdrlen,\n\t\t\t\t    mip6_mh_len(mh->ip6mh_type));\n\t\tmip6_param_prob(skb, 0, offsetof(struct ip6_mh, ip6mh_hdrlen) +\n\t\t\t\tskb_network_header_len(skb));\n\t\treturn -1;\n\t}\n\n\tif (mh->ip6mh_proto != IPPROTO_NONE) {\n\t\tnet_dbg_ratelimited(\"mip6: MH invalid payload proto = %d\\n\",\n\t\t\t\t    mh->ip6mh_proto);\n\t\tmip6_param_prob(skb, 0, offsetof(struct ip6_mh, ip6mh_proto) +\n\t\t\t\tskb_network_header_len(skb));\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstruct mip6_report_rate_limiter {\n\tspinlock_t lock;\n\tktime_t stamp;\n\tint iif;\n\tstruct in6_addr src;\n\tstruct in6_addr dst;\n};\n\nstatic struct mip6_report_rate_limiter mip6_report_rl = {\n\t.lock = __SPIN_LOCK_UNLOCKED(mip6_report_rl.lock)\n};\n\nstatic int mip6_destopt_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct ipv6_destopt_hdr *destopt = (struct ipv6_destopt_hdr *)skb->data;\n\tint err = destopt->nexthdr;\n\n\tspin_lock(&x->lock);\n\tif (!ipv6_addr_equal(&iph->saddr, (struct in6_addr *)x->coaddr) &&\n\t    !ipv6_addr_any((struct in6_addr *)x->coaddr))\n\t\terr = -ENOENT;\n\tspin_unlock(&x->lock);\n\n\treturn err;\n}\n\n \nstatic int mip6_destopt_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph;\n\tstruct ipv6_destopt_hdr *dstopt;\n\tstruct ipv6_destopt_hao *hao;\n\tu8 nexthdr;\n\tint len;\n\n\tskb_push(skb, -skb_network_offset(skb));\n\tiph = ipv6_hdr(skb);\n\n\tnexthdr = *skb_mac_header(skb);\n\t*skb_mac_header(skb) = IPPROTO_DSTOPTS;\n\n\tdstopt = (struct ipv6_destopt_hdr *)skb_transport_header(skb);\n\tdstopt->nexthdr = nexthdr;\n\n\thao = mip6_padn((char *)(dstopt + 1),\n\t\t\tcalc_padlen(sizeof(*dstopt), 6));\n\n\thao->type = IPV6_TLV_HAO;\n\tBUILD_BUG_ON(sizeof(*hao) != 18);\n\thao->length = sizeof(*hao) - 2;\n\n\tlen = ((char *)hao - (char *)dstopt) + sizeof(*hao);\n\n\tmemcpy(&hao->addr, &iph->saddr, sizeof(hao->addr));\n\tspin_lock_bh(&x->lock);\n\tmemcpy(&iph->saddr, x->coaddr, sizeof(iph->saddr));\n\tspin_unlock_bh(&x->lock);\n\n\tWARN_ON(len != x->props.header_len);\n\tdstopt->hdrlen = (x->props.header_len >> 3) - 1;\n\n\treturn 0;\n}\n\nstatic inline int mip6_report_rl_allow(ktime_t stamp,\n\t\t\t\t       const struct in6_addr *dst,\n\t\t\t\t       const struct in6_addr *src, int iif)\n{\n\tint allow = 0;\n\n\tspin_lock_bh(&mip6_report_rl.lock);\n\tif (mip6_report_rl.stamp != stamp ||\n\t    mip6_report_rl.iif != iif ||\n\t    !ipv6_addr_equal(&mip6_report_rl.src, src) ||\n\t    !ipv6_addr_equal(&mip6_report_rl.dst, dst)) {\n\t\tmip6_report_rl.stamp = stamp;\n\t\tmip6_report_rl.iif = iif;\n\t\tmip6_report_rl.src = *src;\n\t\tmip6_report_rl.dst = *dst;\n\t\tallow = 1;\n\t}\n\tspin_unlock_bh(&mip6_report_rl.lock);\n\treturn allow;\n}\n\nstatic int mip6_destopt_reject(struct xfrm_state *x, struct sk_buff *skb,\n\t\t\t       const struct flowi *fl)\n{\n\tstruct net *net = xs_net(x);\n\tstruct inet6_skb_parm *opt = (struct inet6_skb_parm *)skb->cb;\n\tconst struct flowi6 *fl6 = &fl->u.ip6;\n\tstruct ipv6_destopt_hao *hao = NULL;\n\tstruct xfrm_selector sel;\n\tint offset;\n\tktime_t stamp;\n\tint err = 0;\n\n\tif (unlikely(fl6->flowi6_proto == IPPROTO_MH &&\n\t\t     fl6->fl6_mh_type <= IP6_MH_TYPE_MAX))\n\t\tgoto out;\n\n\tif (likely(opt->dsthao)) {\n\t\toffset = ipv6_find_tlv(skb, opt->dsthao, IPV6_TLV_HAO);\n\t\tif (likely(offset >= 0))\n\t\t\thao = (struct ipv6_destopt_hao *)\n\t\t\t\t\t(skb_network_header(skb) + offset);\n\t}\n\n\tstamp = skb_get_ktime(skb);\n\n\tif (!mip6_report_rl_allow(stamp, &ipv6_hdr(skb)->daddr,\n\t\t\t\t  hao ? &hao->addr : &ipv6_hdr(skb)->saddr,\n\t\t\t\t  opt->iif))\n\t\tgoto out;\n\n\tmemset(&sel, 0, sizeof(sel));\n\tmemcpy(&sel.daddr, (xfrm_address_t *)&ipv6_hdr(skb)->daddr,\n\t       sizeof(sel.daddr));\n\tsel.prefixlen_d = 128;\n\tmemcpy(&sel.saddr, (xfrm_address_t *)&ipv6_hdr(skb)->saddr,\n\t       sizeof(sel.saddr));\n\tsel.prefixlen_s = 128;\n\tsel.family = AF_INET6;\n\tsel.proto = fl6->flowi6_proto;\n\tsel.dport = xfrm_flowi_dport(fl, &fl6->uli);\n\tif (sel.dport)\n\t\tsel.dport_mask = htons(~0);\n\tsel.sport = xfrm_flowi_sport(fl, &fl6->uli);\n\tif (sel.sport)\n\t\tsel.sport_mask = htons(~0);\n\tsel.ifindex = fl6->flowi6_oif;\n\n\terr = km_report(net, IPPROTO_DSTOPTS, &sel,\n\t\t\t(hao ? (xfrm_address_t *)&hao->addr : NULL));\n\n out:\n\treturn err;\n}\n\nstatic int mip6_destopt_init_state(struct xfrm_state *x, struct netlink_ext_ack *extack)\n{\n\tif (x->id.spi) {\n\t\tNL_SET_ERR_MSG(extack, \"SPI must be 0\");\n\t\treturn -EINVAL;\n\t}\n\tif (x->props.mode != XFRM_MODE_ROUTEOPTIMIZATION) {\n\t\tNL_SET_ERR_MSG(extack, \"XFRM mode must be XFRM_MODE_ROUTEOPTIMIZATION\");\n\t\treturn -EINVAL;\n\t}\n\n\tx->props.header_len = sizeof(struct ipv6_destopt_hdr) +\n\t\tcalc_padlen(sizeof(struct ipv6_destopt_hdr), 6) +\n\t\tsizeof(struct ipv6_destopt_hao);\n\tWARN_ON(x->props.header_len != 24);\n\n\treturn 0;\n}\n\n \nstatic void mip6_destopt_destroy(struct xfrm_state *x)\n{\n}\n\nstatic const struct xfrm_type mip6_destopt_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.proto\t\t= IPPROTO_DSTOPTS,\n\t.flags\t\t= XFRM_TYPE_NON_FRAGMENT | XFRM_TYPE_LOCAL_COADDR,\n\t.init_state\t= mip6_destopt_init_state,\n\t.destructor\t= mip6_destopt_destroy,\n\t.input\t\t= mip6_destopt_input,\n\t.output\t\t= mip6_destopt_output,\n\t.reject\t\t= mip6_destopt_reject,\n};\n\nstatic int mip6_rthdr_input(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct rt2_hdr *rt2 = (struct rt2_hdr *)skb->data;\n\tint err = rt2->rt_hdr.nexthdr;\n\n\tspin_lock(&x->lock);\n\tif (!ipv6_addr_equal(&iph->daddr, (struct in6_addr *)x->coaddr) &&\n\t    !ipv6_addr_any((struct in6_addr *)x->coaddr))\n\t\terr = -ENOENT;\n\tspin_unlock(&x->lock);\n\n\treturn err;\n}\n\n \nstatic int mip6_rthdr_output(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph;\n\tstruct rt2_hdr *rt2;\n\tu8 nexthdr;\n\n\tskb_push(skb, -skb_network_offset(skb));\n\tiph = ipv6_hdr(skb);\n\n\tnexthdr = *skb_mac_header(skb);\n\t*skb_mac_header(skb) = IPPROTO_ROUTING;\n\n\trt2 = (struct rt2_hdr *)skb_transport_header(skb);\n\trt2->rt_hdr.nexthdr = nexthdr;\n\trt2->rt_hdr.hdrlen = (x->props.header_len >> 3) - 1;\n\trt2->rt_hdr.type = IPV6_SRCRT_TYPE_2;\n\trt2->rt_hdr.segments_left = 1;\n\tmemset(&rt2->reserved, 0, sizeof(rt2->reserved));\n\n\tWARN_ON(rt2->rt_hdr.hdrlen != 2);\n\n\tmemcpy(&rt2->addr, &iph->daddr, sizeof(rt2->addr));\n\tspin_lock_bh(&x->lock);\n\tmemcpy(&iph->daddr, x->coaddr, sizeof(iph->daddr));\n\tspin_unlock_bh(&x->lock);\n\n\treturn 0;\n}\n\nstatic int mip6_rthdr_init_state(struct xfrm_state *x, struct netlink_ext_ack *extack)\n{\n\tif (x->id.spi) {\n\t\tNL_SET_ERR_MSG(extack, \"SPI must be 0\");\n\t\treturn -EINVAL;\n\t}\n\tif (x->props.mode != XFRM_MODE_ROUTEOPTIMIZATION) {\n\t\tNL_SET_ERR_MSG(extack, \"XFRM mode must be XFRM_MODE_ROUTEOPTIMIZATION\");\n\t\treturn -EINVAL;\n\t}\n\n\tx->props.header_len = sizeof(struct rt2_hdr);\n\n\treturn 0;\n}\n\n \nstatic void mip6_rthdr_destroy(struct xfrm_state *x)\n{\n}\n\nstatic const struct xfrm_type mip6_rthdr_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.proto\t\t= IPPROTO_ROUTING,\n\t.flags\t\t= XFRM_TYPE_NON_FRAGMENT | XFRM_TYPE_REMOTE_COADDR,\n\t.init_state\t= mip6_rthdr_init_state,\n\t.destructor\t= mip6_rthdr_destroy,\n\t.input\t\t= mip6_rthdr_input,\n\t.output\t\t= mip6_rthdr_output,\n};\n\nstatic int __init mip6_init(void)\n{\n\tpr_info(\"Mobile IPv6\\n\");\n\n\tif (xfrm_register_type(&mip6_destopt_type, AF_INET6) < 0) {\n\t\tpr_info(\"%s: can't add xfrm type(destopt)\\n\", __func__);\n\t\tgoto mip6_destopt_xfrm_fail;\n\t}\n\tif (xfrm_register_type(&mip6_rthdr_type, AF_INET6) < 0) {\n\t\tpr_info(\"%s: can't add xfrm type(rthdr)\\n\", __func__);\n\t\tgoto mip6_rthdr_xfrm_fail;\n\t}\n\tif (rawv6_mh_filter_register(mip6_mh_filter) < 0) {\n\t\tpr_info(\"%s: can't add rawv6 mh filter\\n\", __func__);\n\t\tgoto mip6_rawv6_mh_fail;\n\t}\n\n\n\treturn 0;\n\n mip6_rawv6_mh_fail:\n\txfrm_unregister_type(&mip6_rthdr_type, AF_INET6);\n mip6_rthdr_xfrm_fail:\n\txfrm_unregister_type(&mip6_destopt_type, AF_INET6);\n mip6_destopt_xfrm_fail:\n\treturn -EAGAIN;\n}\n\nstatic void __exit mip6_fini(void)\n{\n\tif (rawv6_mh_filter_unregister(mip6_mh_filter) < 0)\n\t\tpr_info(\"%s: can't remove rawv6 mh filter\\n\", __func__);\n\txfrm_unregister_type(&mip6_rthdr_type, AF_INET6);\n\txfrm_unregister_type(&mip6_destopt_type, AF_INET6);\n}\n\nmodule_init(mip6_init);\nmodule_exit(mip6_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_XFRM_TYPE(AF_INET6, XFRM_PROTO_DSTOPTS);\nMODULE_ALIAS_XFRM_TYPE(AF_INET6, XFRM_PROTO_ROUTING);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}