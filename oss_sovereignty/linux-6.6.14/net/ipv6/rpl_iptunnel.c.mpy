{
  "module_name": "rpl_iptunnel.c",
  "hash_id": "33ac390c8881aac58589d309db8e6a38de9dd6f8e63907c2bc539ed45cb3fc7f",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/rpl_iptunnel.c",
  "human_readable_source": "\n \n\n#include <linux/rpl_iptunnel.h>\n\n#include <net/dst_cache.h>\n#include <net/ip6_route.h>\n#include <net/lwtunnel.h>\n#include <net/ipv6.h>\n#include <net/rpl.h>\n\nstruct rpl_iptunnel_encap {\n\tDECLARE_FLEX_ARRAY(struct ipv6_rpl_sr_hdr, srh);\n};\n\nstruct rpl_lwt {\n\tstruct dst_cache cache;\n\tstruct rpl_iptunnel_encap tuninfo;\n};\n\nstatic inline struct rpl_lwt *rpl_lwt_lwtunnel(struct lwtunnel_state *lwt)\n{\n\treturn (struct rpl_lwt *)lwt->data;\n}\n\nstatic inline struct rpl_iptunnel_encap *\nrpl_encap_lwtunnel(struct lwtunnel_state *lwt)\n{\n\treturn &rpl_lwt_lwtunnel(lwt)->tuninfo;\n}\n\nstatic const struct nla_policy rpl_iptunnel_policy[RPL_IPTUNNEL_MAX + 1] = {\n\t[RPL_IPTUNNEL_SRH]\t= { .type = NLA_BINARY },\n};\n\nstatic bool rpl_validate_srh(struct net *net, struct ipv6_rpl_sr_hdr *srh,\n\t\t\t     size_t seglen)\n{\n\tint err;\n\n\tif ((srh->hdrlen << 3) != seglen)\n\t\treturn false;\n\n\t \n\tif (!srh->segments_left ||\n\t    (srh->segments_left * sizeof(struct in6_addr)) != seglen)\n\t\treturn false;\n\n\tif (srh->cmpri || srh->cmpre)\n\t\treturn false;\n\n\terr = ipv6_chk_rpl_srh_loop(net, srh->rpl_segaddr,\n\t\t\t\t    srh->segments_left);\n\tif (err)\n\t\treturn false;\n\n\tif (ipv6_addr_type(&srh->rpl_segaddr[srh->segments_left - 1]) &\n\t    IPV6_ADDR_MULTICAST)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int rpl_build_state(struct net *net, struct nlattr *nla,\n\t\t\t   unsigned int family, const void *cfg,\n\t\t\t   struct lwtunnel_state **ts,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RPL_IPTUNNEL_MAX + 1];\n\tstruct lwtunnel_state *newts;\n\tstruct ipv6_rpl_sr_hdr *srh;\n\tstruct rpl_lwt *rlwt;\n\tint err, srh_len;\n\n\tif (family != AF_INET6)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested(tb, RPL_IPTUNNEL_MAX, nla,\n\t\t\t       rpl_iptunnel_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[RPL_IPTUNNEL_SRH])\n\t\treturn -EINVAL;\n\n\tsrh = nla_data(tb[RPL_IPTUNNEL_SRH]);\n\tsrh_len = nla_len(tb[RPL_IPTUNNEL_SRH]);\n\n\tif (srh_len < sizeof(*srh))\n\t\treturn -EINVAL;\n\n\t \n\tif (!rpl_validate_srh(net, srh, srh_len - sizeof(*srh)))\n\t\treturn -EINVAL;\n\n\tnewts = lwtunnel_state_alloc(srh_len + sizeof(*rlwt));\n\tif (!newts)\n\t\treturn -ENOMEM;\n\n\trlwt = rpl_lwt_lwtunnel(newts);\n\n\terr = dst_cache_init(&rlwt->cache, GFP_ATOMIC);\n\tif (err) {\n\t\tkfree(newts);\n\t\treturn err;\n\t}\n\n\tmemcpy(&rlwt->tuninfo.srh, srh, srh_len);\n\n\tnewts->type = LWTUNNEL_ENCAP_RPL;\n\tnewts->flags |= LWTUNNEL_STATE_INPUT_REDIRECT;\n\tnewts->flags |= LWTUNNEL_STATE_OUTPUT_REDIRECT;\n\n\t*ts = newts;\n\n\treturn 0;\n}\n\nstatic void rpl_destroy_state(struct lwtunnel_state *lwt)\n{\n\tdst_cache_destroy(&rpl_lwt_lwtunnel(lwt)->cache);\n}\n\nstatic int rpl_do_srh_inline(struct sk_buff *skb, const struct rpl_lwt *rlwt,\n\t\t\t     const struct ipv6_rpl_sr_hdr *srh)\n{\n\tstruct ipv6_rpl_sr_hdr *isrh, *csrh;\n\tconst struct ipv6hdr *oldhdr;\n\tstruct ipv6hdr *hdr;\n\tunsigned char *buf;\n\tsize_t hdrlen;\n\tint err;\n\n\toldhdr = ipv6_hdr(skb);\n\n\tbuf = kcalloc(struct_size(srh, segments.addr, srh->segments_left), 2, GFP_ATOMIC);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tisrh = (struct ipv6_rpl_sr_hdr *)buf;\n\tcsrh = (struct ipv6_rpl_sr_hdr *)(buf + ((srh->hdrlen + 1) << 3));\n\n\tmemcpy(isrh, srh, sizeof(*isrh));\n\tmemcpy(isrh->rpl_segaddr, &srh->rpl_segaddr[1],\n\t       (srh->segments_left - 1) * 16);\n\tisrh->rpl_segaddr[srh->segments_left - 1] = oldhdr->daddr;\n\n\tipv6_rpl_srh_compress(csrh, isrh, &srh->rpl_segaddr[0],\n\t\t\t      isrh->segments_left - 1);\n\n\thdrlen = ((csrh->hdrlen + 1) << 3);\n\n\terr = skb_cow_head(skb, hdrlen + skb->mac_len);\n\tif (unlikely(err)) {\n\t\tkfree(buf);\n\t\treturn err;\n\t}\n\n\tskb_pull(skb, sizeof(struct ipv6hdr));\n\tskb_postpull_rcsum(skb, skb_network_header(skb),\n\t\t\t   sizeof(struct ipv6hdr));\n\n\tskb_push(skb, sizeof(struct ipv6hdr) + hdrlen);\n\tskb_reset_network_header(skb);\n\tskb_mac_header_rebuild(skb);\n\n\thdr = ipv6_hdr(skb);\n\tmemmove(hdr, oldhdr, sizeof(*hdr));\n\tisrh = (void *)hdr + sizeof(*hdr);\n\tmemcpy(isrh, csrh, hdrlen);\n\n\tisrh->nexthdr = hdr->nexthdr;\n\thdr->nexthdr = NEXTHDR_ROUTING;\n\thdr->daddr = srh->rpl_segaddr[0];\n\n\tipv6_hdr(skb)->payload_len = htons(skb->len - sizeof(struct ipv6hdr));\n\tskb_set_transport_header(skb, sizeof(struct ipv6hdr));\n\n\tskb_postpush_rcsum(skb, hdr, sizeof(struct ipv6hdr) + hdrlen);\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int rpl_do_srh(struct sk_buff *skb, const struct rpl_lwt *rlwt)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct rpl_iptunnel_encap *tinfo;\n\n\tif (skb->protocol != htons(ETH_P_IPV6))\n\t\treturn -EINVAL;\n\n\ttinfo = rpl_encap_lwtunnel(dst->lwtstate);\n\n\treturn rpl_do_srh_inline(skb, rlwt, tinfo->srh);\n}\n\nstatic int rpl_output(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dst_entry *orig_dst = skb_dst(skb);\n\tstruct dst_entry *dst = NULL;\n\tstruct rpl_lwt *rlwt;\n\tint err;\n\n\trlwt = rpl_lwt_lwtunnel(orig_dst->lwtstate);\n\n\terr = rpl_do_srh(skb, rlwt);\n\tif (unlikely(err))\n\t\tgoto drop;\n\n\tpreempt_disable();\n\tdst = dst_cache_get(&rlwt->cache);\n\tpreempt_enable();\n\n\tif (unlikely(!dst)) {\n\t\tstruct ipv6hdr *hdr = ipv6_hdr(skb);\n\t\tstruct flowi6 fl6;\n\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.daddr = hdr->daddr;\n\t\tfl6.saddr = hdr->saddr;\n\t\tfl6.flowlabel = ip6_flowinfo(hdr);\n\t\tfl6.flowi6_mark = skb->mark;\n\t\tfl6.flowi6_proto = hdr->nexthdr;\n\n\t\tdst = ip6_route_output(net, NULL, &fl6);\n\t\tif (dst->error) {\n\t\t\terr = dst->error;\n\t\t\tdst_release(dst);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tpreempt_disable();\n\t\tdst_cache_set_ip6(&rlwt->cache, dst, &fl6.saddr);\n\t\tpreempt_enable();\n\t}\n\n\tskb_dst_drop(skb);\n\tskb_dst_set(skb, dst);\n\n\terr = skb_cow_head(skb, LL_RESERVED_SPACE(dst->dev));\n\tif (unlikely(err))\n\t\tgoto drop;\n\n\treturn dst_output(net, sk, skb);\n\ndrop:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int rpl_input(struct sk_buff *skb)\n{\n\tstruct dst_entry *orig_dst = skb_dst(skb);\n\tstruct dst_entry *dst = NULL;\n\tstruct rpl_lwt *rlwt;\n\tint err;\n\n\trlwt = rpl_lwt_lwtunnel(orig_dst->lwtstate);\n\n\terr = rpl_do_srh(skb, rlwt);\n\tif (unlikely(err)) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tpreempt_disable();\n\tdst = dst_cache_get(&rlwt->cache);\n\tpreempt_enable();\n\n\tif (!dst) {\n\t\tip6_route_input(skb);\n\t\tdst = skb_dst(skb);\n\t\tif (!dst->error) {\n\t\t\tpreempt_disable();\n\t\t\tdst_cache_set_ip6(&rlwt->cache, dst,\n\t\t\t\t\t  &ipv6_hdr(skb)->saddr);\n\t\t\tpreempt_enable();\n\t\t}\n\t} else {\n\t\tskb_dst_drop(skb);\n\t\tskb_dst_set(skb, dst);\n\t}\n\n\terr = skb_cow_head(skb, LL_RESERVED_SPACE(dst->dev));\n\tif (unlikely(err))\n\t\treturn err;\n\n\treturn dst_input(skb);\n}\n\nstatic int nla_put_rpl_srh(struct sk_buff *skb, int attrtype,\n\t\t\t   struct rpl_iptunnel_encap *tuninfo)\n{\n\tstruct rpl_iptunnel_encap *data;\n\tstruct nlattr *nla;\n\tint len;\n\n\tlen = RPL_IPTUNNEL_SRH_SIZE(tuninfo->srh);\n\n\tnla = nla_reserve(skb, attrtype, len);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\tdata = nla_data(nla);\n\tmemcpy(data, tuninfo->srh, len);\n\n\treturn 0;\n}\n\nstatic int rpl_fill_encap_info(struct sk_buff *skb,\n\t\t\t       struct lwtunnel_state *lwtstate)\n{\n\tstruct rpl_iptunnel_encap *tuninfo = rpl_encap_lwtunnel(lwtstate);\n\n\tif (nla_put_rpl_srh(skb, RPL_IPTUNNEL_SRH, tuninfo))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int rpl_encap_nlsize(struct lwtunnel_state *lwtstate)\n{\n\tstruct rpl_iptunnel_encap *tuninfo = rpl_encap_lwtunnel(lwtstate);\n\n\treturn nla_total_size(RPL_IPTUNNEL_SRH_SIZE(tuninfo->srh));\n}\n\nstatic int rpl_encap_cmp(struct lwtunnel_state *a, struct lwtunnel_state *b)\n{\n\tstruct rpl_iptunnel_encap *a_hdr = rpl_encap_lwtunnel(a);\n\tstruct rpl_iptunnel_encap *b_hdr = rpl_encap_lwtunnel(b);\n\tint len = RPL_IPTUNNEL_SRH_SIZE(a_hdr->srh);\n\n\tif (len != RPL_IPTUNNEL_SRH_SIZE(b_hdr->srh))\n\t\treturn 1;\n\n\treturn memcmp(a_hdr, b_hdr, len);\n}\n\nstatic const struct lwtunnel_encap_ops rpl_ops = {\n\t.build_state\t= rpl_build_state,\n\t.destroy_state\t= rpl_destroy_state,\n\t.output\t\t= rpl_output,\n\t.input\t\t= rpl_input,\n\t.fill_encap\t= rpl_fill_encap_info,\n\t.get_encap_size\t= rpl_encap_nlsize,\n\t.cmp_encap\t= rpl_encap_cmp,\n\t.owner\t\t= THIS_MODULE,\n};\n\nint __init rpl_init(void)\n{\n\tint err;\n\n\terr = lwtunnel_encap_add_ops(&rpl_ops, LWTUNNEL_ENCAP_RPL);\n\tif (err)\n\t\tgoto out;\n\n\tpr_info(\"RPL Segment Routing with IPv6\\n\");\n\n\treturn 0;\n\nout:\n\treturn err;\n}\n\nvoid rpl_exit(void)\n{\n\tlwtunnel_encap_del_ops(&rpl_ops, LWTUNNEL_ENCAP_RPL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}