{
  "module_name": "calipso.c",
  "hash_id": "76370157a21c4b90f49157ff467b6947e294e482c2451b1ef2a1c65979cf7466",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/calipso.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/jhash.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/tcp.h>\n#include <net/netlabel.h>\n#include <net/calipso.h>\n#include <linux/atomic.h>\n#include <linux/bug.h>\n#include <asm/unaligned.h>\n#include <linux/crc-ccitt.h>\n\n \n#define CALIPSO_OPT_LEN_MAX (2 + 252)\n\n \n#define CALIPSO_HDR_LEN (2 + 8)\n\n \n#define CALIPSO_OPT_LEN_MAX_WITH_PAD (3 + CALIPSO_OPT_LEN_MAX + 7)\n\n  \n#define CALIPSO_MAX_BUFFER (6 + CALIPSO_OPT_LEN_MAX)\n\n \nstatic DEFINE_SPINLOCK(calipso_doi_list_lock);\nstatic LIST_HEAD(calipso_doi_list);\n\n \nint calipso_cache_enabled = 1;\nint calipso_cache_bucketsize = 10;\n#define CALIPSO_CACHE_BUCKETBITS     7\n#define CALIPSO_CACHE_BUCKETS        BIT(CALIPSO_CACHE_BUCKETBITS)\n#define CALIPSO_CACHE_REORDERLIMIT   10\nstruct calipso_map_cache_bkt {\n\tspinlock_t lock;\n\tu32 size;\n\tstruct list_head list;\n};\n\nstruct calipso_map_cache_entry {\n\tu32 hash;\n\tunsigned char *key;\n\tsize_t key_len;\n\n\tstruct netlbl_lsm_cache *lsm_data;\n\n\tu32 activity;\n\tstruct list_head list;\n};\n\nstatic struct calipso_map_cache_bkt *calipso_cache;\n\nstatic void calipso_cache_invalidate(void);\nstatic void calipso_doi_putdef(struct calipso_doi *doi_def);\n\n \n\n \nstatic void calipso_cache_entry_free(struct calipso_map_cache_entry *entry)\n{\n\tif (entry->lsm_data)\n\t\tnetlbl_secattr_cache_free(entry->lsm_data);\n\tkfree(entry->key);\n\tkfree(entry);\n}\n\n \nstatic u32 calipso_map_cache_hash(const unsigned char *key, u32 key_len)\n{\n\treturn jhash(key, key_len, 0);\n}\n\n \nstatic int __init calipso_cache_init(void)\n{\n\tu32 iter;\n\n\tcalipso_cache = kcalloc(CALIPSO_CACHE_BUCKETS,\n\t\t\t\tsizeof(struct calipso_map_cache_bkt),\n\t\t\t\tGFP_KERNEL);\n\tif (!calipso_cache)\n\t\treturn -ENOMEM;\n\n\tfor (iter = 0; iter < CALIPSO_CACHE_BUCKETS; iter++) {\n\t\tspin_lock_init(&calipso_cache[iter].lock);\n\t\tcalipso_cache[iter].size = 0;\n\t\tINIT_LIST_HEAD(&calipso_cache[iter].list);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void calipso_cache_invalidate(void)\n{\n\tstruct calipso_map_cache_entry *entry, *tmp_entry;\n\tu32 iter;\n\n\tfor (iter = 0; iter < CALIPSO_CACHE_BUCKETS; iter++) {\n\t\tspin_lock_bh(&calipso_cache[iter].lock);\n\t\tlist_for_each_entry_safe(entry,\n\t\t\t\t\t tmp_entry,\n\t\t\t\t\t &calipso_cache[iter].list, list) {\n\t\t\tlist_del(&entry->list);\n\t\t\tcalipso_cache_entry_free(entry);\n\t\t}\n\t\tcalipso_cache[iter].size = 0;\n\t\tspin_unlock_bh(&calipso_cache[iter].lock);\n\t}\n}\n\n \nstatic int calipso_cache_check(const unsigned char *key,\n\t\t\t       u32 key_len,\n\t\t\t       struct netlbl_lsm_secattr *secattr)\n{\n\tu32 bkt;\n\tstruct calipso_map_cache_entry *entry;\n\tstruct calipso_map_cache_entry *prev_entry = NULL;\n\tu32 hash;\n\n\tif (!calipso_cache_enabled)\n\t\treturn -ENOENT;\n\n\thash = calipso_map_cache_hash(key, key_len);\n\tbkt = hash & (CALIPSO_CACHE_BUCKETS - 1);\n\tspin_lock_bh(&calipso_cache[bkt].lock);\n\tlist_for_each_entry(entry, &calipso_cache[bkt].list, list) {\n\t\tif (entry->hash == hash &&\n\t\t    entry->key_len == key_len &&\n\t\t    memcmp(entry->key, key, key_len) == 0) {\n\t\t\tentry->activity += 1;\n\t\t\trefcount_inc(&entry->lsm_data->refcount);\n\t\t\tsecattr->cache = entry->lsm_data;\n\t\t\tsecattr->flags |= NETLBL_SECATTR_CACHE;\n\t\t\tsecattr->type = NETLBL_NLTYPE_CALIPSO;\n\t\t\tif (!prev_entry) {\n\t\t\t\tspin_unlock_bh(&calipso_cache[bkt].lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (prev_entry->activity > 0)\n\t\t\t\tprev_entry->activity -= 1;\n\t\t\tif (entry->activity > prev_entry->activity &&\n\t\t\t    entry->activity - prev_entry->activity >\n\t\t\t    CALIPSO_CACHE_REORDERLIMIT) {\n\t\t\t\t__list_del(entry->list.prev, entry->list.next);\n\t\t\t\t__list_add(&entry->list,\n\t\t\t\t\t   prev_entry->list.prev,\n\t\t\t\t\t   &prev_entry->list);\n\t\t\t}\n\n\t\t\tspin_unlock_bh(&calipso_cache[bkt].lock);\n\t\t\treturn 0;\n\t\t}\n\t\tprev_entry = entry;\n\t}\n\tspin_unlock_bh(&calipso_cache[bkt].lock);\n\n\treturn -ENOENT;\n}\n\n \nstatic int calipso_cache_add(const unsigned char *calipso_ptr,\n\t\t\t     const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tu32 bkt;\n\tstruct calipso_map_cache_entry *entry = NULL;\n\tstruct calipso_map_cache_entry *old_entry = NULL;\n\tu32 calipso_ptr_len;\n\n\tif (!calipso_cache_enabled || calipso_cache_bucketsize <= 0)\n\t\treturn 0;\n\n\tcalipso_ptr_len = calipso_ptr[1];\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry->key = kmemdup(calipso_ptr + 2, calipso_ptr_len, GFP_ATOMIC);\n\tif (!entry->key) {\n\t\tret_val = -ENOMEM;\n\t\tgoto cache_add_failure;\n\t}\n\tentry->key_len = calipso_ptr_len;\n\tentry->hash = calipso_map_cache_hash(calipso_ptr, calipso_ptr_len);\n\trefcount_inc(&secattr->cache->refcount);\n\tentry->lsm_data = secattr->cache;\n\n\tbkt = entry->hash & (CALIPSO_CACHE_BUCKETS - 1);\n\tspin_lock_bh(&calipso_cache[bkt].lock);\n\tif (calipso_cache[bkt].size < calipso_cache_bucketsize) {\n\t\tlist_add(&entry->list, &calipso_cache[bkt].list);\n\t\tcalipso_cache[bkt].size += 1;\n\t} else {\n\t\told_entry = list_entry(calipso_cache[bkt].list.prev,\n\t\t\t\t       struct calipso_map_cache_entry, list);\n\t\tlist_del(&old_entry->list);\n\t\tlist_add(&entry->list, &calipso_cache[bkt].list);\n\t\tcalipso_cache_entry_free(old_entry);\n\t}\n\tspin_unlock_bh(&calipso_cache[bkt].lock);\n\n\treturn 0;\n\ncache_add_failure:\n\tif (entry)\n\t\tcalipso_cache_entry_free(entry);\n\treturn ret_val;\n}\n\n \n\n \nstatic struct calipso_doi *calipso_doi_search(u32 doi)\n{\n\tstruct calipso_doi *iter;\n\n\tlist_for_each_entry_rcu(iter, &calipso_doi_list, list)\n\t\tif (iter->doi == doi && refcount_read(&iter->refcount))\n\t\t\treturn iter;\n\treturn NULL;\n}\n\n \nstatic int calipso_doi_add(struct calipso_doi *doi_def,\n\t\t\t   struct netlbl_audit *audit_info)\n{\n\tint ret_val = -EINVAL;\n\tu32 doi;\n\tu32 doi_type;\n\tstruct audit_buffer *audit_buf;\n\n\tdoi = doi_def->doi;\n\tdoi_type = doi_def->type;\n\n\tif (doi_def->doi == CALIPSO_DOI_UNKNOWN)\n\t\tgoto doi_add_return;\n\n\trefcount_set(&doi_def->refcount, 1);\n\n\tspin_lock(&calipso_doi_list_lock);\n\tif (calipso_doi_search(doi_def->doi)) {\n\t\tspin_unlock(&calipso_doi_list_lock);\n\t\tret_val = -EEXIST;\n\t\tgoto doi_add_return;\n\t}\n\tlist_add_tail_rcu(&doi_def->list, &calipso_doi_list);\n\tspin_unlock(&calipso_doi_list_lock);\n\tret_val = 0;\n\ndoi_add_return:\n\taudit_buf = netlbl_audit_start(AUDIT_MAC_CALIPSO_ADD, audit_info);\n\tif (audit_buf) {\n\t\tconst char *type_str;\n\n\t\tswitch (doi_type) {\n\t\tcase CALIPSO_MAP_PASS:\n\t\t\ttype_str = \"pass\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype_str = \"(unknown)\";\n\t\t}\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \" calipso_doi=%u calipso_type=%s res=%u\",\n\t\t\t\t doi, type_str, ret_val == 0 ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic void calipso_doi_free(struct calipso_doi *doi_def)\n{\n\tkfree(doi_def);\n}\n\n \nstatic void calipso_doi_free_rcu(struct rcu_head *entry)\n{\n\tstruct calipso_doi *doi_def;\n\n\tdoi_def = container_of(entry, struct calipso_doi, rcu);\n\tcalipso_doi_free(doi_def);\n}\n\n \nstatic int calipso_doi_remove(u32 doi, struct netlbl_audit *audit_info)\n{\n\tint ret_val;\n\tstruct calipso_doi *doi_def;\n\tstruct audit_buffer *audit_buf;\n\n\tspin_lock(&calipso_doi_list_lock);\n\tdoi_def = calipso_doi_search(doi);\n\tif (!doi_def) {\n\t\tspin_unlock(&calipso_doi_list_lock);\n\t\tret_val = -ENOENT;\n\t\tgoto doi_remove_return;\n\t}\n\tlist_del_rcu(&doi_def->list);\n\tspin_unlock(&calipso_doi_list_lock);\n\n\tcalipso_doi_putdef(doi_def);\n\tret_val = 0;\n\ndoi_remove_return:\n\taudit_buf = netlbl_audit_start(AUDIT_MAC_CALIPSO_DEL, audit_info);\n\tif (audit_buf) {\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \" calipso_doi=%u res=%u\",\n\t\t\t\t doi, ret_val == 0 ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic struct calipso_doi *calipso_doi_getdef(u32 doi)\n{\n\tstruct calipso_doi *doi_def;\n\n\trcu_read_lock();\n\tdoi_def = calipso_doi_search(doi);\n\tif (!doi_def)\n\t\tgoto doi_getdef_return;\n\tif (!refcount_inc_not_zero(&doi_def->refcount))\n\t\tdoi_def = NULL;\n\ndoi_getdef_return:\n\trcu_read_unlock();\n\treturn doi_def;\n}\n\n \nstatic void calipso_doi_putdef(struct calipso_doi *doi_def)\n{\n\tif (!doi_def)\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&doi_def->refcount))\n\t\treturn;\n\n\tcalipso_cache_invalidate();\n\tcall_rcu(&doi_def->rcu, calipso_doi_free_rcu);\n}\n\n \nstatic int calipso_doi_walk(u32 *skip_cnt,\n\t\t\t    int (*callback)(struct calipso_doi *doi_def,\n\t\t\t\t\t    void *arg),\n\t\t\t    void *cb_arg)\n{\n\tint ret_val = -ENOENT;\n\tu32 doi_cnt = 0;\n\tstruct calipso_doi *iter_doi;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(iter_doi, &calipso_doi_list, list)\n\t\tif (refcount_read(&iter_doi->refcount) > 0) {\n\t\t\tif (doi_cnt++ < *skip_cnt)\n\t\t\t\tcontinue;\n\t\t\tret_val = callback(iter_doi, cb_arg);\n\t\t\tif (ret_val < 0) {\n\t\t\t\tdoi_cnt--;\n\t\t\t\tgoto doi_walk_return;\n\t\t\t}\n\t\t}\n\ndoi_walk_return:\n\trcu_read_unlock();\n\t*skip_cnt = doi_cnt;\n\treturn ret_val;\n}\n\n \nbool calipso_validate(const struct sk_buff *skb, const unsigned char *option)\n{\n\tstruct calipso_doi *doi_def;\n\tbool ret_val;\n\tu16 crc, len = option[1] + 2;\n\tstatic const u8 zero[2];\n\n\t \n\tcrc = crc_ccitt(0xffff, option, 8);\n\tcrc = crc_ccitt(crc, zero, sizeof(zero));\n\tif (len > 10)\n\t\tcrc = crc_ccitt(crc, option + 10, len - 10);\n\tcrc = ~crc;\n\tif (option[8] != (crc & 0xff) || option[9] != ((crc >> 8) & 0xff))\n\t\treturn false;\n\n\trcu_read_lock();\n\tdoi_def = calipso_doi_search(get_unaligned_be32(option + 2));\n\tret_val = !!doi_def;\n\trcu_read_unlock();\n\n\treturn ret_val;\n}\n\n \nstatic int calipso_map_cat_hton(const struct calipso_doi *doi_def,\n\t\t\t\tconst struct netlbl_lsm_secattr *secattr,\n\t\t\t\tunsigned char *net_cat,\n\t\t\t\tu32 net_cat_len)\n{\n\tint spot = -1;\n\tu32 net_spot_max = 0;\n\tu32 net_clen_bits = net_cat_len * 8;\n\n\tfor (;;) {\n\t\tspot = netlbl_catmap_walk(secattr->attr.mls.cat,\n\t\t\t\t\t  spot + 1);\n\t\tif (spot < 0)\n\t\t\tbreak;\n\t\tif (spot >= net_clen_bits)\n\t\t\treturn -ENOSPC;\n\t\tnetlbl_bitmap_setbit(net_cat, spot, 1);\n\n\t\tif (spot > net_spot_max)\n\t\t\tnet_spot_max = spot;\n\t}\n\n\treturn (net_spot_max / 32 + 1) * 4;\n}\n\n \nstatic int calipso_map_cat_ntoh(const struct calipso_doi *doi_def,\n\t\t\t\tconst unsigned char *net_cat,\n\t\t\t\tu32 net_cat_len,\n\t\t\t\tstruct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tint spot = -1;\n\tu32 net_clen_bits = net_cat_len * 8;\n\n\tfor (;;) {\n\t\tspot = netlbl_bitmap_walk(net_cat,\n\t\t\t\t\t  net_clen_bits,\n\t\t\t\t\t  spot + 1,\n\t\t\t\t\t  1);\n\t\tif (spot < 0) {\n\t\t\tif (spot == -2)\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\t\t}\n\n\t\tret_val = netlbl_catmap_setbit(&secattr->attr.mls.cat,\n\t\t\t\t\t       spot,\n\t\t\t\t\t       GFP_ATOMIC);\n\t\tif (ret_val != 0)\n\t\t\treturn ret_val;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int calipso_pad_write(unsigned char *buf, unsigned int offset,\n\t\t\t     unsigned int count)\n{\n\tif (WARN_ON_ONCE(count >= 8))\n\t\treturn -EINVAL;\n\n\tswitch (count) {\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tbuf[offset] = IPV6_TLV_PAD1;\n\t\tbreak;\n\tdefault:\n\t\tbuf[offset] = IPV6_TLV_PADN;\n\t\tbuf[offset + 1] = count - 2;\n\t\tif (count > 2)\n\t\t\tmemset(buf + offset + 2, 0, count - 2);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int calipso_genopt(unsigned char *buf, u32 start, u32 buf_len,\n\t\t\t  const struct calipso_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tu32 len, pad;\n\tu16 crc;\n\tstatic const unsigned char padding[4] = {2, 1, 0, 3};\n\tunsigned char *calipso;\n\n\t \n\tpad = padding[start & 3];\n\tif (buf_len <= start + pad + CALIPSO_HDR_LEN)\n\t\treturn -ENOSPC;\n\n\tif ((secattr->flags & NETLBL_SECATTR_MLS_LVL) == 0)\n\t\treturn -EPERM;\n\n\tlen = CALIPSO_HDR_LEN;\n\n\tif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\n\t\tret_val = calipso_map_cat_hton(doi_def,\n\t\t\t\t\t       secattr,\n\t\t\t\t\t       buf + start + pad + len,\n\t\t\t\t\t       buf_len - start - pad - len);\n\t\tif (ret_val < 0)\n\t\t\treturn ret_val;\n\t\tlen += ret_val;\n\t}\n\n\tcalipso_pad_write(buf, start, pad);\n\tcalipso = buf + start + pad;\n\n\tcalipso[0] = IPV6_TLV_CALIPSO;\n\tcalipso[1] = len - 2;\n\t*(__be32 *)(calipso + 2) = htonl(doi_def->doi);\n\tcalipso[6] = (len - CALIPSO_HDR_LEN) / 4;\n\tcalipso[7] = secattr->attr.mls.lvl;\n\tcrc = ~crc_ccitt(0xffff, calipso, len);\n\tcalipso[8] = crc & 0xff;\n\tcalipso[9] = (crc >> 8) & 0xff;\n\treturn pad + len;\n}\n\n \n\n \nstatic int calipso_opt_update(struct sock *sk, struct ipv6_opt_hdr *hop)\n{\n\tstruct ipv6_txoptions *old = txopt_get(inet6_sk(sk)), *txopts;\n\n\ttxopts = ipv6_renew_options(sk, old, IPV6_HOPOPTS, hop);\n\ttxopt_put(old);\n\tif (IS_ERR(txopts))\n\t\treturn PTR_ERR(txopts);\n\n\ttxopts = ipv6_update_options(sk, txopts);\n\tif (txopts) {\n\t\tatomic_sub(txopts->tot_len, &sk->sk_omem_alloc);\n\t\ttxopt_put(txopts);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int calipso_tlv_len(struct ipv6_opt_hdr *opt, unsigned int offset)\n{\n\tunsigned char *tlv = (unsigned char *)opt;\n\tunsigned int opt_len = ipv6_optlen(opt), tlv_len;\n\n\tif (offset < sizeof(*opt) || offset >= opt_len)\n\t\treturn -EINVAL;\n\tif (tlv[offset] == IPV6_TLV_PAD1)\n\t\treturn 1;\n\tif (offset + 1 >= opt_len)\n\t\treturn -EINVAL;\n\ttlv_len = tlv[offset + 1] + 2;\n\tif (offset + tlv_len > opt_len)\n\t\treturn -EINVAL;\n\treturn tlv_len;\n}\n\n \nstatic int calipso_opt_find(struct ipv6_opt_hdr *hop, unsigned int *start,\n\t\t\t    unsigned int *end)\n{\n\tint ret_val = -ENOENT, tlv_len;\n\tunsigned int opt_len, offset, offset_s = 0, offset_e = 0;\n\tunsigned char *opt = (unsigned char *)hop;\n\n\topt_len = ipv6_optlen(hop);\n\toffset = sizeof(*hop);\n\n\twhile (offset < opt_len) {\n\t\ttlv_len = calipso_tlv_len(hop, offset);\n\t\tif (tlv_len < 0)\n\t\t\treturn tlv_len;\n\n\t\tswitch (opt[offset]) {\n\t\tcase IPV6_TLV_PAD1:\n\t\tcase IPV6_TLV_PADN:\n\t\t\tif (offset_e)\n\t\t\t\toffset_e = offset;\n\t\t\tbreak;\n\t\tcase IPV6_TLV_CALIPSO:\n\t\t\tret_val = 0;\n\t\t\toffset_e = offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (offset_e == 0)\n\t\t\t\toffset_s = offset;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\t}\n\t\toffset += tlv_len;\n\t}\n\nout:\n\tif (offset_s)\n\t\t*start = offset_s + calipso_tlv_len(hop, offset_s);\n\telse\n\t\t*start = sizeof(*hop);\n\tif (offset_e)\n\t\t*end = offset_e + calipso_tlv_len(hop, offset_e);\n\telse\n\t\t*end = opt_len;\n\n\treturn ret_val;\n}\n\n \nstatic struct ipv6_opt_hdr *\ncalipso_opt_insert(struct ipv6_opt_hdr *hop,\n\t\t   const struct calipso_doi *doi_def,\n\t\t   const struct netlbl_lsm_secattr *secattr)\n{\n\tunsigned int start, end, buf_len, pad, hop_len;\n\tstruct ipv6_opt_hdr *new;\n\tint ret_val;\n\n\tif (hop) {\n\t\thop_len = ipv6_optlen(hop);\n\t\tret_val = calipso_opt_find(hop, &start, &end);\n\t\tif (ret_val && ret_val != -ENOENT)\n\t\t\treturn ERR_PTR(ret_val);\n\t} else {\n\t\thop_len = 0;\n\t\tstart = sizeof(*hop);\n\t\tend = 0;\n\t}\n\n\tbuf_len = hop_len + start - end + CALIPSO_OPT_LEN_MAX_WITH_PAD;\n\tnew = kzalloc(buf_len, GFP_ATOMIC);\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (start > sizeof(*hop))\n\t\tmemcpy(new, hop, start);\n\tret_val = calipso_genopt((unsigned char *)new, start, buf_len, doi_def,\n\t\t\t\t secattr);\n\tif (ret_val < 0) {\n\t\tkfree(new);\n\t\treturn ERR_PTR(ret_val);\n\t}\n\n\tbuf_len = start + ret_val;\n\t \n\tpad = ((buf_len & 4) + (end & 7)) & 7;\n\tcalipso_pad_write((unsigned char *)new, buf_len, pad);\n\tbuf_len += pad;\n\n\tif (end != hop_len) {\n\t\tmemcpy((char *)new + buf_len, (char *)hop + end, hop_len - end);\n\t\tbuf_len += hop_len - end;\n\t}\n\tnew->nexthdr = 0;\n\tnew->hdrlen = buf_len / 8 - 1;\n\n\treturn new;\n}\n\n \nstatic int calipso_opt_del(struct ipv6_opt_hdr *hop,\n\t\t\t   struct ipv6_opt_hdr **new)\n{\n\tint ret_val;\n\tunsigned int start, end, delta, pad, hop_len;\n\n\tret_val = calipso_opt_find(hop, &start, &end);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\thop_len = ipv6_optlen(hop);\n\tif (start == sizeof(*hop) && end == hop_len) {\n\t\t \n\t\t*new = NULL;\n\t\treturn 0;\n\t}\n\n\tdelta = (end - start) & ~7;\n\t*new = kzalloc(hop_len - delta, GFP_ATOMIC);\n\tif (!*new)\n\t\treturn -ENOMEM;\n\n\tmemcpy(*new, hop, start);\n\t(*new)->hdrlen -= delta / 8;\n\tpad = (end - start) & 7;\n\tcalipso_pad_write((unsigned char *)*new, start, pad);\n\tif (end != hop_len)\n\t\tmemcpy((char *)*new + start + pad, (char *)hop + end,\n\t\t       hop_len - end);\n\n\treturn 0;\n}\n\n \nstatic int calipso_opt_getattr(const unsigned char *calipso,\n\t\t\t       struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -ENOMSG;\n\tu32 doi, len = calipso[1], cat_len = calipso[6] * 4;\n\tstruct calipso_doi *doi_def;\n\n\tif (cat_len + 8 > len)\n\t\treturn -EINVAL;\n\n\tif (calipso_cache_check(calipso + 2, calipso[1], secattr) == 0)\n\t\treturn 0;\n\n\tdoi = get_unaligned_be32(calipso + 2);\n\trcu_read_lock();\n\tdoi_def = calipso_doi_search(doi);\n\tif (!doi_def)\n\t\tgoto getattr_return;\n\n\tsecattr->attr.mls.lvl = calipso[7];\n\tsecattr->flags |= NETLBL_SECATTR_MLS_LVL;\n\n\tif (cat_len) {\n\t\tret_val = calipso_map_cat_ntoh(doi_def,\n\t\t\t\t\t       calipso + 10,\n\t\t\t\t\t       cat_len,\n\t\t\t\t\t       secattr);\n\t\tif (ret_val != 0) {\n\t\t\tnetlbl_catmap_free(secattr->attr.mls.cat);\n\t\t\tgoto getattr_return;\n\t\t}\n\n\t\tif (secattr->attr.mls.cat)\n\t\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\n\t}\n\n\tsecattr->type = NETLBL_NLTYPE_CALIPSO;\n\ngetattr_return:\n\trcu_read_unlock();\n\treturn ret_val;\n}\n\n \n\n \nstatic int calipso_sock_getattr(struct sock *sk,\n\t\t\t\tstruct netlbl_lsm_secattr *secattr)\n{\n\tstruct ipv6_opt_hdr *hop;\n\tint opt_len, len, ret_val = -ENOMSG, offset;\n\tunsigned char *opt;\n\tstruct ipv6_txoptions *txopts = txopt_get(inet6_sk(sk));\n\n\tif (!txopts || !txopts->hopopt)\n\t\tgoto done;\n\n\thop = txopts->hopopt;\n\topt = (unsigned char *)hop;\n\topt_len = ipv6_optlen(hop);\n\toffset = sizeof(*hop);\n\twhile (offset < opt_len) {\n\t\tlen = calipso_tlv_len(hop, offset);\n\t\tif (len < 0) {\n\t\t\tret_val = len;\n\t\t\tgoto done;\n\t\t}\n\t\tswitch (opt[offset]) {\n\t\tcase IPV6_TLV_CALIPSO:\n\t\t\tif (len < CALIPSO_HDR_LEN)\n\t\t\t\tret_val = -EINVAL;\n\t\t\telse\n\t\t\t\tret_val = calipso_opt_getattr(&opt[offset],\n\t\t\t\t\t\t\t      secattr);\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\toffset += len;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\ttxopt_put(txopts);\n\treturn ret_val;\n}\n\n \nstatic int calipso_sock_setattr(struct sock *sk,\n\t\t\t\tconst struct calipso_doi *doi_def,\n\t\t\t\tconst struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tstruct ipv6_opt_hdr *old, *new;\n\tstruct ipv6_txoptions *txopts = txopt_get(inet6_sk(sk));\n\n\told = NULL;\n\tif (txopts)\n\t\told = txopts->hopopt;\n\n\tnew = calipso_opt_insert(old, doi_def, secattr);\n\ttxopt_put(txopts);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tret_val = calipso_opt_update(sk, new);\n\n\tkfree(new);\n\treturn ret_val;\n}\n\n \nstatic void calipso_sock_delattr(struct sock *sk)\n{\n\tstruct ipv6_opt_hdr *new_hop;\n\tstruct ipv6_txoptions *txopts = txopt_get(inet6_sk(sk));\n\n\tif (!txopts || !txopts->hopopt)\n\t\tgoto done;\n\n\tif (calipso_opt_del(txopts->hopopt, &new_hop))\n\t\tgoto done;\n\n\tcalipso_opt_update(sk, new_hop);\n\tkfree(new_hop);\n\ndone:\n\ttxopt_put(txopts);\n}\n\n \n\n \nstatic int calipso_req_setattr(struct request_sock *req,\n\t\t\t       const struct calipso_doi *doi_def,\n\t\t\t       const struct netlbl_lsm_secattr *secattr)\n{\n\tstruct ipv6_txoptions *txopts;\n\tstruct inet_request_sock *req_inet = inet_rsk(req);\n\tstruct ipv6_opt_hdr *old, *new;\n\tstruct sock *sk = sk_to_full_sk(req_to_sk(req));\n\n\tif (req_inet->ipv6_opt && req_inet->ipv6_opt->hopopt)\n\t\told = req_inet->ipv6_opt->hopopt;\n\telse\n\t\told = NULL;\n\n\tnew = calipso_opt_insert(old, doi_def, secattr);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\ttxopts = ipv6_renew_options(sk, req_inet->ipv6_opt, IPV6_HOPOPTS, new);\n\n\tkfree(new);\n\n\tif (IS_ERR(txopts))\n\t\treturn PTR_ERR(txopts);\n\n\ttxopts = xchg(&req_inet->ipv6_opt, txopts);\n\tif (txopts) {\n\t\tatomic_sub(txopts->tot_len, &sk->sk_omem_alloc);\n\t\ttxopt_put(txopts);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void calipso_req_delattr(struct request_sock *req)\n{\n\tstruct inet_request_sock *req_inet = inet_rsk(req);\n\tstruct ipv6_opt_hdr *new;\n\tstruct ipv6_txoptions *txopts;\n\tstruct sock *sk = sk_to_full_sk(req_to_sk(req));\n\n\tif (!req_inet->ipv6_opt || !req_inet->ipv6_opt->hopopt)\n\t\treturn;\n\n\tif (calipso_opt_del(req_inet->ipv6_opt->hopopt, &new))\n\t\treturn;  \n\n\ttxopts = ipv6_renew_options(sk, req_inet->ipv6_opt, IPV6_HOPOPTS, new);\n\n\tif (!IS_ERR(txopts)) {\n\t\ttxopts = xchg(&req_inet->ipv6_opt, txopts);\n\t\tif (txopts) {\n\t\t\tatomic_sub(txopts->tot_len, &sk->sk_omem_alloc);\n\t\t\ttxopt_put(txopts);\n\t\t}\n\t}\n\tkfree(new);\n}\n\n \n\n \nstatic unsigned char *calipso_skbuff_optptr(const struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *ip6_hdr = ipv6_hdr(skb);\n\tint offset;\n\n\tif (ip6_hdr->nexthdr != NEXTHDR_HOP)\n\t\treturn NULL;\n\n\toffset = ipv6_find_tlv(skb, sizeof(*ip6_hdr), IPV6_TLV_CALIPSO);\n\tif (offset >= 0)\n\t\treturn (unsigned char *)ip6_hdr + offset;\n\n\treturn NULL;\n}\n\n \nstatic int calipso_skbuff_setattr(struct sk_buff *skb,\n\t\t\t\t  const struct calipso_doi *doi_def,\n\t\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tstruct ipv6hdr *ip6_hdr;\n\tstruct ipv6_opt_hdr *hop;\n\tunsigned char buf[CALIPSO_MAX_BUFFER];\n\tint len_delta, new_end, pad, payload;\n\tunsigned int start, end;\n\n\tip6_hdr = ipv6_hdr(skb);\n\tif (ip6_hdr->nexthdr == NEXTHDR_HOP) {\n\t\thop = (struct ipv6_opt_hdr *)(ip6_hdr + 1);\n\t\tret_val = calipso_opt_find(hop, &start, &end);\n\t\tif (ret_val && ret_val != -ENOENT)\n\t\t\treturn ret_val;\n\t} else {\n\t\tstart = 0;\n\t\tend = 0;\n\t}\n\n\tmemset(buf, 0, sizeof(buf));\n\tret_val = calipso_genopt(buf, start & 3, sizeof(buf), doi_def, secattr);\n\tif (ret_val < 0)\n\t\treturn ret_val;\n\n\tnew_end = start + ret_val;\n\t \n\tpad = ((new_end & 4) + (end & 7)) & 7;\n\tlen_delta = new_end - (int)end + pad;\n\tret_val = skb_cow(skb, skb_headroom(skb) + len_delta);\n\tif (ret_val < 0)\n\t\treturn ret_val;\n\n\tip6_hdr = ipv6_hdr(skb);  \n\n\tif (len_delta) {\n\t\tif (len_delta > 0)\n\t\t\tskb_push(skb, len_delta);\n\t\telse\n\t\t\tskb_pull(skb, -len_delta);\n\t\tmemmove((char *)ip6_hdr - len_delta, ip6_hdr,\n\t\t\tsizeof(*ip6_hdr) + start);\n\t\tskb_reset_network_header(skb);\n\t\tip6_hdr = ipv6_hdr(skb);\n\t\tpayload = ntohs(ip6_hdr->payload_len);\n\t\tip6_hdr->payload_len = htons(payload + len_delta);\n\t}\n\n\thop = (struct ipv6_opt_hdr *)(ip6_hdr + 1);\n\tif (start == 0) {\n\t\tstruct ipv6_opt_hdr *new_hop = (struct ipv6_opt_hdr *)buf;\n\n\t\tnew_hop->nexthdr = ip6_hdr->nexthdr;\n\t\tnew_hop->hdrlen = len_delta / 8 - 1;\n\t\tip6_hdr->nexthdr = NEXTHDR_HOP;\n\t} else {\n\t\thop->hdrlen += len_delta / 8;\n\t}\n\tmemcpy((char *)hop + start, buf + (start & 3), new_end - start);\n\tcalipso_pad_write((unsigned char *)hop, new_end, pad);\n\n\treturn 0;\n}\n\n \nstatic int calipso_skbuff_delattr(struct sk_buff *skb)\n{\n\tint ret_val;\n\tstruct ipv6hdr *ip6_hdr;\n\tstruct ipv6_opt_hdr *old_hop;\n\tu32 old_hop_len, start = 0, end = 0, delta, size, pad;\n\n\tif (!calipso_skbuff_optptr(skb))\n\t\treturn 0;\n\n\t \n\tret_val = skb_cow(skb, skb_headroom(skb));\n\tif (ret_val < 0)\n\t\treturn ret_val;\n\n\tip6_hdr = ipv6_hdr(skb);\n\told_hop = (struct ipv6_opt_hdr *)(ip6_hdr + 1);\n\told_hop_len = ipv6_optlen(old_hop);\n\n\tret_val = calipso_opt_find(old_hop, &start, &end);\n\tif (ret_val)\n\t\treturn ret_val;\n\n\tif (start == sizeof(*old_hop) && end == old_hop_len) {\n\t\t \n\t\tdelta = old_hop_len;\n\t\tsize = sizeof(*ip6_hdr);\n\t\tip6_hdr->nexthdr = old_hop->nexthdr;\n\t} else {\n\t\tdelta = (end - start) & ~7;\n\t\tif (delta)\n\t\t\told_hop->hdrlen -= delta / 8;\n\t\tpad = (end - start) & 7;\n\t\tsize = sizeof(*ip6_hdr) + start + pad;\n\t\tcalipso_pad_write((unsigned char *)old_hop, start, pad);\n\t}\n\n\tif (delta) {\n\t\tskb_pull(skb, delta);\n\t\tmemmove((char *)ip6_hdr + delta, ip6_hdr, size);\n\t\tskb_reset_network_header(skb);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct netlbl_calipso_ops ops = {\n\t.doi_add          = calipso_doi_add,\n\t.doi_free         = calipso_doi_free,\n\t.doi_remove       = calipso_doi_remove,\n\t.doi_getdef       = calipso_doi_getdef,\n\t.doi_putdef       = calipso_doi_putdef,\n\t.doi_walk         = calipso_doi_walk,\n\t.sock_getattr     = calipso_sock_getattr,\n\t.sock_setattr     = calipso_sock_setattr,\n\t.sock_delattr     = calipso_sock_delattr,\n\t.req_setattr      = calipso_req_setattr,\n\t.req_delattr      = calipso_req_delattr,\n\t.opt_getattr      = calipso_opt_getattr,\n\t.skbuff_optptr    = calipso_skbuff_optptr,\n\t.skbuff_setattr   = calipso_skbuff_setattr,\n\t.skbuff_delattr   = calipso_skbuff_delattr,\n\t.cache_invalidate = calipso_cache_invalidate,\n\t.cache_add        = calipso_cache_add\n};\n\n \nint __init calipso_init(void)\n{\n\tint ret_val;\n\n\tret_val = calipso_cache_init();\n\tif (!ret_val)\n\t\tnetlbl_calipso_ops_register(&ops);\n\treturn ret_val;\n}\n\nvoid calipso_exit(void)\n{\n\tnetlbl_calipso_ops_register(NULL);\n\tcalipso_cache_invalidate();\n\tkfree(calipso_cache);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}