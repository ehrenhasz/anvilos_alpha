{
  "module_name": "udp.c",
  "hash_id": "05b850c6a786989910975d847aea4ec12196182e30a2303ee7e647876018042c",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/udp.c",
  "human_readable_source": "\n \n\n#include <linux/bpf-cgroup.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/indirect_call_wrapper.h>\n\n#include <net/addrconf.h>\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/raw.h>\n#include <net/seg6.h>\n#include <net/tcp_states.h>\n#include <net/ip6_checksum.h>\n#include <net/ip6_tunnel.h>\n#include <trace/events/udp.h>\n#include <net/xfrm.h>\n#include <net/inet_hashtables.h>\n#include <net/inet6_hashtables.h>\n#include <net/busy_poll.h>\n#include <net/sock_reuseport.h>\n#include <net/gro.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <trace/events/skb.h>\n#include \"udp_impl.h\"\n\nstatic void udpv6_destruct_sock(struct sock *sk)\n{\n\tudp_destruct_common(sk);\n\tinet6_sock_destruct(sk);\n}\n\nint udpv6_init_sock(struct sock *sk)\n{\n\tudp_lib_init_sock(sk);\n\tsk->sk_destruct = udpv6_destruct_sock;\n\tset_bit(SOCK_SUPPORT_ZC, &sk->sk_socket->flags);\n\treturn 0;\n}\n\nINDIRECT_CALLABLE_SCOPE\nu32 udp6_ehashfn(const struct net *net,\n\t\t const struct in6_addr *laddr,\n\t\t const u16 lport,\n\t\t const struct in6_addr *faddr,\n\t\t const __be16 fport)\n{\n\tstatic u32 udp6_ehash_secret __read_mostly;\n\tstatic u32 udp_ipv6_hash_secret __read_mostly;\n\n\tu32 lhash, fhash;\n\n\tnet_get_random_once(&udp6_ehash_secret,\n\t\t\t    sizeof(udp6_ehash_secret));\n\tnet_get_random_once(&udp_ipv6_hash_secret,\n\t\t\t    sizeof(udp_ipv6_hash_secret));\n\n\tlhash = (__force u32)laddr->s6_addr32[3];\n\tfhash = __ipv6_addr_jhash(faddr, udp_ipv6_hash_secret);\n\n\treturn __inet6_ehashfn(lhash, lport, fhash, fport,\n\t\t\t       udp6_ehash_secret + net_hash_mix(net));\n}\n\nint udp_v6_get_port(struct sock *sk, unsigned short snum)\n{\n\tunsigned int hash2_nulladdr =\n\t\tipv6_portaddr_hash(sock_net(sk), &in6addr_any, snum);\n\tunsigned int hash2_partial =\n\t\tipv6_portaddr_hash(sock_net(sk), &sk->sk_v6_rcv_saddr, 0);\n\n\t \n\tudp_sk(sk)->udp_portaddr_hash = hash2_partial;\n\treturn udp_lib_get_port(sk, snum, hash2_nulladdr);\n}\n\nvoid udp_v6_rehash(struct sock *sk)\n{\n\tu16 new_hash = ipv6_portaddr_hash(sock_net(sk),\n\t\t\t\t\t  &sk->sk_v6_rcv_saddr,\n\t\t\t\t\t  inet_sk(sk)->inet_num);\n\n\tudp_lib_rehash(sk, new_hash);\n}\n\nstatic int compute_score(struct sock *sk, struct net *net,\n\t\t\t const struct in6_addr *saddr, __be16 sport,\n\t\t\t const struct in6_addr *daddr, unsigned short hnum,\n\t\t\t int dif, int sdif)\n{\n\tint bound_dev_if, score;\n\tstruct inet_sock *inet;\n\tbool dev_match;\n\n\tif (!net_eq(sock_net(sk), net) ||\n\t    udp_sk(sk)->udp_port_hash != hnum ||\n\t    sk->sk_family != PF_INET6)\n\t\treturn -1;\n\n\tif (!ipv6_addr_equal(&sk->sk_v6_rcv_saddr, daddr))\n\t\treturn -1;\n\n\tscore = 0;\n\tinet = inet_sk(sk);\n\n\tif (inet->inet_dport) {\n\t\tif (inet->inet_dport != sport)\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_daddr)) {\n\t\tif (!ipv6_addr_equal(&sk->sk_v6_daddr, saddr))\n\t\t\treturn -1;\n\t\tscore++;\n\t}\n\n\tbound_dev_if = READ_ONCE(sk->sk_bound_dev_if);\n\tdev_match = udp_sk_bound_dev_eq(net, bound_dev_if, dif, sdif);\n\tif (!dev_match)\n\t\treturn -1;\n\tif (bound_dev_if)\n\t\tscore++;\n\n\tif (READ_ONCE(sk->sk_incoming_cpu) == raw_smp_processor_id())\n\t\tscore++;\n\n\treturn score;\n}\n\n \nstatic struct sock *udp6_lib_lookup2(struct net *net,\n\t\tconst struct in6_addr *saddr, __be16 sport,\n\t\tconst struct in6_addr *daddr, unsigned int hnum,\n\t\tint dif, int sdif, struct udp_hslot *hslot2,\n\t\tstruct sk_buff *skb)\n{\n\tstruct sock *sk, *result;\n\tint score, badness;\n\n\tresult = NULL;\n\tbadness = -1;\n\tudp_portaddr_for_each_entry_rcu(sk, &hslot2->head) {\n\t\tscore = compute_score(sk, net, saddr, sport,\n\t\t\t\t      daddr, hnum, dif, sdif);\n\t\tif (score > badness) {\n\t\t\tbadness = score;\n\n\t\t\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\t\t\tresult = sk;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresult = inet6_lookup_reuseport(net, sk, skb, sizeof(struct udphdr),\n\t\t\t\t\t\t\tsaddr, sport, daddr, hnum, udp6_ehashfn);\n\t\t\tif (!result) {\n\t\t\t\tresult = sk;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!reuseport_has_conns(sk))\n\t\t\t\treturn result;\n\n\t\t\t \n\t\t\tif (IS_ERR(result))\n\t\t\t\tcontinue;\n\n\t\t\tbadness = compute_score(sk, net, saddr, sport,\n\t\t\t\t\t\tdaddr, hnum, dif, sdif);\n\t\t}\n\t}\n\treturn result;\n}\n\n \nstruct sock *__udp6_lib_lookup(struct net *net,\n\t\t\t       const struct in6_addr *saddr, __be16 sport,\n\t\t\t       const struct in6_addr *daddr, __be16 dport,\n\t\t\t       int dif, int sdif, struct udp_table *udptable,\n\t\t\t       struct sk_buff *skb)\n{\n\tunsigned short hnum = ntohs(dport);\n\tunsigned int hash2, slot2;\n\tstruct udp_hslot *hslot2;\n\tstruct sock *result, *sk;\n\n\thash2 = ipv6_portaddr_hash(net, daddr, hnum);\n\tslot2 = hash2 & udptable->mask;\n\thslot2 = &udptable->hash2[slot2];\n\n\t \n\tresult = udp6_lib_lookup2(net, saddr, sport,\n\t\t\t\t  daddr, hnum, dif, sdif,\n\t\t\t\t  hslot2, skb);\n\tif (!IS_ERR_OR_NULL(result) && result->sk_state == TCP_ESTABLISHED)\n\t\tgoto done;\n\n\t \n\tif (static_branch_unlikely(&bpf_sk_lookup_enabled) &&\n\t    udptable == net->ipv4.udp_table) {\n\t\tsk = inet6_lookup_run_sk_lookup(net, IPPROTO_UDP, skb, sizeof(struct udphdr),\n\t\t\t\t\t\tsaddr, sport, daddr, hnum, dif,\n\t\t\t\t\t\tudp6_ehashfn);\n\t\tif (sk) {\n\t\t\tresult = sk;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (result)\n\t\tgoto done;\n\n\t \n\thash2 = ipv6_portaddr_hash(net, &in6addr_any, hnum);\n\tslot2 = hash2 & udptable->mask;\n\thslot2 = &udptable->hash2[slot2];\n\n\tresult = udp6_lib_lookup2(net, saddr, sport,\n\t\t\t\t  &in6addr_any, hnum, dif, sdif,\n\t\t\t\t  hslot2, skb);\ndone:\n\tif (IS_ERR(result))\n\t\treturn NULL;\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(__udp6_lib_lookup);\n\nstatic struct sock *__udp6_lib_lookup_skb(struct sk_buff *skb,\n\t\t\t\t\t  __be16 sport, __be16 dport,\n\t\t\t\t\t  struct udp_table *udptable)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\n\treturn __udp6_lib_lookup(dev_net(skb->dev), &iph->saddr, sport,\n\t\t\t\t &iph->daddr, dport, inet6_iif(skb),\n\t\t\t\t inet6_sdif(skb), udptable, skb);\n}\n\nstruct sock *udp6_lib_lookup_skb(const struct sk_buff *skb,\n\t\t\t\t __be16 sport, __be16 dport)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tint iif, sdif;\n\n\tinet6_get_iif_sdif(skb, &iif, &sdif);\n\n\treturn __udp6_lib_lookup(net, &iph->saddr, sport,\n\t\t\t\t &iph->daddr, dport, iif,\n\t\t\t\t sdif, net->ipv4.udp_table, NULL);\n}\n\n \n#if IS_ENABLED(CONFIG_NF_TPROXY_IPV6) || IS_ENABLED(CONFIG_NF_SOCKET_IPV6)\nstruct sock *udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,\n\t\t\t     const struct in6_addr *daddr, __be16 dport, int dif)\n{\n\tstruct sock *sk;\n\n\tsk =  __udp6_lib_lookup(net, saddr, sport, daddr, dport,\n\t\t\t\tdif, 0, net->ipv4.udp_table, NULL);\n\tif (sk && !refcount_inc_not_zero(&sk->sk_refcnt))\n\t\tsk = NULL;\n\treturn sk;\n}\nEXPORT_SYMBOL_GPL(udp6_lib_lookup);\n#endif\n\n \nstatic int udp6_skb_len(struct sk_buff *skb)\n{\n\treturn unlikely(inet6_is_jumbogram(skb)) ? skb->len : udp_skb_len(skb);\n}\n\n \n\nint udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t  int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned int ulen, copied;\n\tint off, err, peeking = flags & MSG_PEEK;\n\tint is_udplite = IS_UDPLITE(sk);\n\tstruct udp_mib __percpu *mib;\n\tbool checksum_valid = false;\n\tint is_udp4;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len, addr_len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len, addr_len);\n\ntry_again:\n\toff = sk_peek_offset(sk, flags);\n\tskb = __skb_recv_udp(sk, flags, &off, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tulen = udp6_skb_len(skb);\n\tcopied = len;\n\tif (copied > ulen - off)\n\t\tcopied = ulen - off;\n\telse if (copied < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\tis_udp4 = (skb->protocol == htons(ETH_P_IP));\n\tmib = __UDPX_MIB(sk, is_udp4);\n\n\t \n\n\tif (copied < ulen || peeking ||\n\t    (is_udplite && UDP_SKB_CB(skb)->partial_cov)) {\n\t\tchecksum_valid = udp_skb_csum_unnecessary(skb) ||\n\t\t\t\t!__udp_lib_checksum_complete(skb);\n\t\tif (!checksum_valid)\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (checksum_valid || udp_skb_csum_unnecessary(skb)) {\n\t\tif (udp_skb_is_linear(skb))\n\t\t\terr = copy_linear_skb(skb, copied, off, &msg->msg_iter);\n\t\telse\n\t\t\terr = skb_copy_datagram_msg(skb, off, msg, copied);\n\t} else {\n\t\terr = skb_copy_and_csum_datagram_msg(skb, off, msg);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (unlikely(err)) {\n\t\tif (!peeking) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tSNMP_INC_STATS(mib, UDP_MIB_INERRORS);\n\t\t}\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\tif (!peeking)\n\t\tSNMP_INC_STATS(mib, UDP_MIB_INDATAGRAMS);\n\n\tsock_recv_cmsgs(msg, sk, skb);\n\n\t \n\tif (msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = udp_hdr(skb)->source;\n\t\tsin6->sin6_flowinfo = 0;\n\n\t\tif (is_udp4) {\n\t\t\tipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\n\t\t\t\t\t       &sin6->sin6_addr);\n\t\t\tsin6->sin6_scope_id = 0;\n\t\t} else {\n\t\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\t\tsin6->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t    inet6_iif(skb));\n\t\t}\n\t\t*addr_len = sizeof(*sin6);\n\n\t\tBPF_CGROUP_RUN_PROG_UDP6_RECVMSG_LOCK(sk,\n\t\t\t\t\t\t      (struct sockaddr *)sin6);\n\t}\n\n\tif (udp_test_bit(GRO_ENABLED, sk))\n\t\tudp_cmsg_recv(msg, sk, skb);\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_common_ctl(sk, msg, skb);\n\n\tif (is_udp4) {\n\t\tif (inet_cmsg_flags(inet))\n\t\t\tip_cmsg_recv_offset(msg, sk, skb,\n\t\t\t\t\t    sizeof(struct udphdr), off);\n\t} else {\n\t\tif (np->rxopt.all)\n\t\t\tip6_datagram_recv_specific_ctl(sk, msg, skb);\n\t}\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\n\n\tskb_consume_udp(sk, skb, peeking ? -err : err);\n\treturn err;\n\ncsum_copy_err:\n\tif (!__sk_queue_drop_skb(sk, &udp_sk(sk)->reader_queue, skb, flags,\n\t\t\t\t udp_skb_destructor)) {\n\t\tSNMP_INC_STATS(mib, UDP_MIB_CSUMERRORS);\n\t\tSNMP_INC_STATS(mib, UDP_MIB_INERRORS);\n\t}\n\tkfree_skb(skb);\n\n\t \n\tcond_resched();\n\tmsg->msg_flags &= ~MSG_TRUNC;\n\tgoto try_again;\n}\n\nDEFINE_STATIC_KEY_FALSE(udpv6_encap_needed_key);\nvoid udpv6_encap_enable(void)\n{\n\tstatic_branch_inc(&udpv6_encap_needed_key);\n}\nEXPORT_SYMBOL(udpv6_encap_enable);\n\n \nstatic int __udp6_lib_err_encap_no_sk(struct sk_buff *skb,\n\t\t\t\t      struct inet6_skb_parm *opt,\n\t\t\t\t      u8 type, u8 code, int offset, __be32 info)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_IPTUN_ENCAP_OPS; i++) {\n\t\tint (*handler)(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t       u8 type, u8 code, int offset, __be32 info);\n\t\tconst struct ip6_tnl_encap_ops *encap;\n\n\t\tencap = rcu_dereference(ip6tun_encaps[i]);\n\t\tif (!encap)\n\t\t\tcontinue;\n\t\thandler = encap->err_handler;\n\t\tif (handler && !handler(skb, opt, type, code, offset, info))\n\t\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic struct sock *__udp6_lib_err_encap(struct net *net,\n\t\t\t\t\t const struct ipv6hdr *hdr, int offset,\n\t\t\t\t\t struct udphdr *uh,\n\t\t\t\t\t struct udp_table *udptable,\n\t\t\t\t\t struct sock *sk,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t struct inet6_skb_parm *opt,\n\t\t\t\t\t u8 type, u8 code, __be32 info)\n{\n\tint (*lookup)(struct sock *sk, struct sk_buff *skb);\n\tint network_offset, transport_offset;\n\tstruct udp_sock *up;\n\n\tnetwork_offset = skb_network_offset(skb);\n\ttransport_offset = skb_transport_offset(skb);\n\n\t \n\tskb_reset_network_header(skb);\n\n\t \n\tskb_set_transport_header(skb, offset);\n\n\tif (sk) {\n\t\tup = udp_sk(sk);\n\n\t\tlookup = READ_ONCE(up->encap_err_lookup);\n\t\tif (lookup && lookup(sk, skb))\n\t\t\tsk = NULL;\n\n\t\tgoto out;\n\t}\n\n\tsk = __udp6_lib_lookup(net, &hdr->daddr, uh->source,\n\t\t\t       &hdr->saddr, uh->dest,\n\t\t\t       inet6_iif(skb), 0, udptable, skb);\n\tif (sk) {\n\t\tup = udp_sk(sk);\n\n\t\tlookup = READ_ONCE(up->encap_err_lookup);\n\t\tif (!lookup || lookup(sk, skb))\n\t\t\tsk = NULL;\n\t}\n\nout:\n\tif (!sk) {\n\t\tsk = ERR_PTR(__udp6_lib_err_encap_no_sk(skb, opt, type, code,\n\t\t\t\t\t\t\toffset, info));\n\t}\n\n\tskb_set_transport_header(skb, transport_offset);\n\tskb_set_network_header(skb, network_offset);\n\n\treturn sk;\n}\n\nint __udp6_lib_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t   u8 type, u8 code, int offset, __be32 info,\n\t\t   struct udp_table *udptable)\n{\n\tstruct ipv6_pinfo *np;\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct in6_addr *saddr = &hdr->saddr;\n\tconst struct in6_addr *daddr = seg6_get_daddr(skb, opt) ? : &hdr->daddr;\n\tstruct udphdr *uh = (struct udphdr *)(skb->data+offset);\n\tbool tunnel = false;\n\tstruct sock *sk;\n\tint harderr;\n\tint err;\n\tstruct net *net = dev_net(skb->dev);\n\n\tsk = __udp6_lib_lookup(net, daddr, uh->dest, saddr, uh->source,\n\t\t\t       inet6_iif(skb), inet6_sdif(skb), udptable, NULL);\n\n\tif (!sk || READ_ONCE(udp_sk(sk)->encap_type)) {\n\t\t \n\t\tif (static_branch_unlikely(&udpv6_encap_needed_key)) {\n\t\t\tsk = __udp6_lib_err_encap(net, hdr, offset, uh,\n\t\t\t\t\t\t  udptable, sk, skb,\n\t\t\t\t\t\t  opt, type, code, info);\n\t\t\tif (!sk)\n\t\t\t\treturn 0;\n\t\t} else\n\t\t\tsk = ERR_PTR(-ENOENT);\n\n\t\tif (IS_ERR(sk)) {\n\t\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),\n\t\t\t\t\t  ICMP6_MIB_INERRORS);\n\t\t\treturn PTR_ERR(sk);\n\t\t}\n\n\t\ttunnel = true;\n\t}\n\n\tharderr = icmpv6_err_convert(type, code, &err);\n\tnp = inet6_sk(sk);\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\t\tip6_sk_update_pmtu(skb, sk, info);\n\t\tif (np->pmtudisc != IPV6_PMTUDISC_DONT)\n\t\t\tharderr = 1;\n\t}\n\tif (type == NDISC_REDIRECT) {\n\t\tif (tunnel) {\n\t\t\tip6_redirect(skb, sock_net(sk), inet6_iif(skb),\n\t\t\t\t     READ_ONCE(sk->sk_mark), sk->sk_uid);\n\t\t} else {\n\t\t\tip6_sk_redirect(skb, sk);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tif (tunnel) {\n\t\tif (udp_sk(sk)->encap_err_rcv)\n\t\t\tudp_sk(sk)->encap_err_rcv(sk, skb, err, uh->dest,\n\t\t\t\t\t\t  ntohl(info), (u8 *)(uh+1));\n\t\tgoto out;\n\t}\n\n\tif (!np->recverr) {\n\t\tif (!harderr || sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t} else {\n\t\tipv6_icmp_error(sk, skb, err, uh->dest, ntohl(info), (u8 *)(uh+1));\n\t}\n\n\tsk->sk_err = err;\n\tsk_error_report(sk);\nout:\n\treturn 0;\n}\n\nstatic int __udpv6_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\tif (!ipv6_addr_any(&sk->sk_v6_daddr)) {\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tsk_incoming_cpu_update(sk);\n\t} else {\n\t\tsk_mark_napi_id_once(sk, skb);\n\t}\n\n\trc = __udp_enqueue_schedule_skb(sk, skb);\n\tif (rc < 0) {\n\t\tint is_udplite = IS_UDPLITE(sk);\n\t\tenum skb_drop_reason drop_reason;\n\n\t\t \n\t\tif (rc == -ENOMEM) {\n\t\t\tUDP6_INC_STATS(sock_net(sk),\n\t\t\t\t\t UDP_MIB_RCVBUFERRORS, is_udplite);\n\t\t\tdrop_reason = SKB_DROP_REASON_SOCKET_RCVBUFF;\n\t\t} else {\n\t\t\tUDP6_INC_STATS(sock_net(sk),\n\t\t\t\t       UDP_MIB_MEMERRORS, is_udplite);\n\t\t\tdrop_reason = SKB_DROP_REASON_PROTO_MEM;\n\t\t}\n\t\tUDP6_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t\tkfree_skb_reason(skb, drop_reason);\n\t\ttrace_udp_fail_queue_rcv_skb(rc, sk);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic __inline__ int udpv6_err(struct sk_buff *skb,\n\t\t\t\tstruct inet6_skb_parm *opt, u8 type,\n\t\t\t\tu8 code, int offset, __be32 info)\n{\n\treturn __udp6_lib_err(skb, opt, type, code, offset, info,\n\t\t\t      dev_net(skb->dev)->ipv4.udp_table);\n}\n\nstatic int udpv6_queue_rcv_one_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tenum skb_drop_reason drop_reason = SKB_DROP_REASON_NOT_SPECIFIED;\n\tstruct udp_sock *up = udp_sk(sk);\n\tint is_udplite = IS_UDPLITE(sk);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb)) {\n\t\tdrop_reason = SKB_DROP_REASON_XFRM_POLICY;\n\t\tgoto drop;\n\t}\n\tnf_reset_ct(skb);\n\n\tif (static_branch_unlikely(&udpv6_encap_needed_key) &&\n\t    READ_ONCE(up->encap_type)) {\n\t\tint (*encap_rcv)(struct sock *sk, struct sk_buff *skb);\n\n\t\t \n\n\t\t \n\t\tencap_rcv = READ_ONCE(up->encap_rcv);\n\t\tif (encap_rcv) {\n\t\t\tint ret;\n\n\t\t\t \n\t\t\tif (udp_lib_checksum_complete(skb))\n\t\t\t\tgoto csum_error;\n\n\t\t\tret = encap_rcv(sk, skb);\n\t\t\tif (ret <= 0) {\n\t\t\t\t__UDP6_INC_STATS(sock_net(sk),\n\t\t\t\t\t\t UDP_MIB_INDATAGRAMS,\n\t\t\t\t\t\t is_udplite);\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t}\n\n\t\t \n\t}\n\n\t \n\tif (udp_test_bit(UDPLITE_RECV_CC, sk) && UDP_SKB_CB(skb)->partial_cov) {\n\t\tu16 pcrlen = READ_ONCE(up->pcrlen);\n\n\t\tif (pcrlen == 0) {           \n\t\t\tnet_dbg_ratelimited(\"UDPLITE6: partial coverage %d while full coverage %d requested\\n\",\n\t\t\t\t\t    UDP_SKB_CB(skb)->cscov, skb->len);\n\t\t\tgoto drop;\n\t\t}\n\t\tif (UDP_SKB_CB(skb)->cscov < pcrlen) {\n\t\t\tnet_dbg_ratelimited(\"UDPLITE6: coverage %d too small, need min %d\\n\",\n\t\t\t\t\t    UDP_SKB_CB(skb)->cscov, pcrlen);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tprefetch(&sk->sk_rmem_alloc);\n\tif (rcu_access_pointer(sk->sk_filter) &&\n\t    udp_lib_checksum_complete(skb))\n\t\tgoto csum_error;\n\n\tif (sk_filter_trim_cap(sk, skb, sizeof(struct udphdr))) {\n\t\tdrop_reason = SKB_DROP_REASON_SOCKET_FILTER;\n\t\tgoto drop;\n\t}\n\n\tudp_csum_pull_header(skb);\n\n\tskb_dst_drop(skb);\n\n\treturn __udpv6_queue_rcv_skb(sk, skb);\n\ncsum_error:\n\tdrop_reason = SKB_DROP_REASON_UDP_CSUM;\n\t__UDP6_INC_STATS(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);\ndrop:\n\t__UDP6_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\tatomic_inc(&sk->sk_drops);\n\tkfree_skb_reason(skb, drop_reason);\n\treturn -1;\n}\n\nstatic int udpv6_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sk_buff *next, *segs;\n\tint ret;\n\n\tif (likely(!udp_unexpected_gso(sk, skb)))\n\t\treturn udpv6_queue_rcv_one_skb(sk, skb);\n\n\t__skb_push(skb, -skb_mac_offset(skb));\n\tsegs = udp_rcv_segment(sk, skb, false);\n\tskb_list_walk_safe(segs, skb, next) {\n\t\t__skb_pull(skb, skb_transport_offset(skb));\n\n\t\tudp_post_segment_fix_csum(skb);\n\t\tret = udpv6_queue_rcv_one_skb(sk, skb);\n\t\tif (ret > 0)\n\t\t\tip6_protocol_deliver_rcu(dev_net(skb->dev), skb, ret,\n\t\t\t\t\t\t true);\n\t}\n\treturn 0;\n}\n\nstatic bool __udp_v6_is_mcast_sock(struct net *net, const struct sock *sk,\n\t\t\t\t   __be16 loc_port, const struct in6_addr *loc_addr,\n\t\t\t\t   __be16 rmt_port, const struct in6_addr *rmt_addr,\n\t\t\t\t   int dif, int sdif, unsigned short hnum)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\n\tif (!net_eq(sock_net(sk), net))\n\t\treturn false;\n\n\tif (udp_sk(sk)->udp_port_hash != hnum ||\n\t    sk->sk_family != PF_INET6 ||\n\t    (inet->inet_dport && inet->inet_dport != rmt_port) ||\n\t    (!ipv6_addr_any(&sk->sk_v6_daddr) &&\n\t\t    !ipv6_addr_equal(&sk->sk_v6_daddr, rmt_addr)) ||\n\t    !udp_sk_bound_dev_eq(net, READ_ONCE(sk->sk_bound_dev_if), dif, sdif) ||\n\t    (!ipv6_addr_any(&sk->sk_v6_rcv_saddr) &&\n\t\t    !ipv6_addr_equal(&sk->sk_v6_rcv_saddr, loc_addr)))\n\t\treturn false;\n\tif (!inet6_mc_check(sk, loc_addr, rmt_addr))\n\t\treturn false;\n\treturn true;\n}\n\nstatic void udp6_csum_zero_error(struct sk_buff *skb)\n{\n\t \n\tnet_dbg_ratelimited(\"IPv6: udp checksum is 0 for [%pI6c]:%u->[%pI6c]:%u\\n\",\n\t\t\t    &ipv6_hdr(skb)->saddr, ntohs(udp_hdr(skb)->source),\n\t\t\t    &ipv6_hdr(skb)->daddr, ntohs(udp_hdr(skb)->dest));\n}\n\n \nstatic int __udp6_lib_mcast_deliver(struct net *net, struct sk_buff *skb,\n\t\tconst struct in6_addr *saddr, const struct in6_addr *daddr,\n\t\tstruct udp_table *udptable, int proto)\n{\n\tstruct sock *sk, *first = NULL;\n\tconst struct udphdr *uh = udp_hdr(skb);\n\tunsigned short hnum = ntohs(uh->dest);\n\tstruct udp_hslot *hslot = udp_hashslot(udptable, net, hnum);\n\tunsigned int offset = offsetof(typeof(*sk), sk_node);\n\tunsigned int hash2 = 0, hash2_any = 0, use_hash2 = (hslot->count > 10);\n\tint dif = inet6_iif(skb);\n\tint sdif = inet6_sdif(skb);\n\tstruct hlist_node *node;\n\tstruct sk_buff *nskb;\n\n\tif (use_hash2) {\n\t\thash2_any = ipv6_portaddr_hash(net, &in6addr_any, hnum) &\n\t\t\t    udptable->mask;\n\t\thash2 = ipv6_portaddr_hash(net, daddr, hnum) & udptable->mask;\nstart_lookup:\n\t\thslot = &udptable->hash2[hash2];\n\t\toffset = offsetof(typeof(*sk), __sk_common.skc_portaddr_node);\n\t}\n\n\tsk_for_each_entry_offset_rcu(sk, node, &hslot->head, offset) {\n\t\tif (!__udp_v6_is_mcast_sock(net, sk, uh->dest, daddr,\n\t\t\t\t\t    uh->source, saddr, dif, sdif,\n\t\t\t\t\t    hnum))\n\t\t\tcontinue;\n\t\t \n\t\tif (!uh->check && !udp_get_no_check6_rx(sk))\n\t\t\tcontinue;\n\t\tif (!first) {\n\t\t\tfirst = sk;\n\t\t\tcontinue;\n\t\t}\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (unlikely(!nskb)) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\t__UDP6_INC_STATS(net, UDP_MIB_RCVBUFERRORS,\n\t\t\t\t\t IS_UDPLITE(sk));\n\t\t\t__UDP6_INC_STATS(net, UDP_MIB_INERRORS,\n\t\t\t\t\t IS_UDPLITE(sk));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (udpv6_queue_rcv_skb(sk, nskb) > 0)\n\t\t\tconsume_skb(nskb);\n\t}\n\n\t \n\tif (use_hash2 && hash2 != hash2_any) {\n\t\thash2 = hash2_any;\n\t\tgoto start_lookup;\n\t}\n\n\tif (first) {\n\t\tif (udpv6_queue_rcv_skb(first, skb) > 0)\n\t\t\tconsume_skb(skb);\n\t} else {\n\t\tkfree_skb(skb);\n\t\t__UDP6_INC_STATS(net, UDP_MIB_IGNOREDMULTI,\n\t\t\t\t proto == IPPROTO_UDPLITE);\n\t}\n\treturn 0;\n}\n\nstatic void udp6_sk_rx_dst_set(struct sock *sk, struct dst_entry *dst)\n{\n\tif (udp_sk_rx_dst_set(sk, dst)) {\n\t\tconst struct rt6_info *rt = (const struct rt6_info *)dst;\n\n\t\tsk->sk_rx_dst_cookie = rt6_get_cookie(rt);\n\t}\n}\n\n \nstatic int udp6_unicast_rcv_skb(struct sock *sk, struct sk_buff *skb,\n\t\t\t\tstruct udphdr *uh)\n{\n\tint ret;\n\n\tif (inet_get_convert_csum(sk) && uh->check && !IS_UDPLITE(sk))\n\t\tskb_checksum_try_convert(skb, IPPROTO_UDP, ip6_compute_pseudo);\n\n\tret = udpv6_queue_rcv_skb(sk, skb);\n\n\t \n\tif (ret > 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nint __udp6_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,\n\t\t   int proto)\n{\n\tenum skb_drop_reason reason = SKB_DROP_REASON_NOT_SPECIFIED;\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct net *net = dev_net(skb->dev);\n\tstruct udphdr *uh;\n\tstruct sock *sk;\n\tbool refcounted;\n\tu32 ulen = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\tgoto discard;\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\tuh = udp_hdr(skb);\n\n\tulen = ntohs(uh->len);\n\tif (ulen > skb->len)\n\t\tgoto short_packet;\n\n\tif (proto == IPPROTO_UDP) {\n\t\t \n\n\t\t \n\t\tif (ulen == 0)\n\t\t\tulen = skb->len;\n\n\t\tif (ulen < sizeof(*uh))\n\t\t\tgoto short_packet;\n\n\t\tif (ulen < skb->len) {\n\t\t\tif (pskb_trim_rcsum(skb, ulen))\n\t\t\t\tgoto short_packet;\n\t\t\tsaddr = &ipv6_hdr(skb)->saddr;\n\t\t\tdaddr = &ipv6_hdr(skb)->daddr;\n\t\t\tuh = udp_hdr(skb);\n\t\t}\n\t}\n\n\tif (udp6_csum_init(skb, uh, proto))\n\t\tgoto csum_error;\n\n\t \n\tsk = inet6_steal_sock(net, skb, sizeof(struct udphdr), saddr, uh->source, daddr, uh->dest,\n\t\t\t      &refcounted, udp6_ehashfn);\n\tif (IS_ERR(sk))\n\t\tgoto no_sk;\n\n\tif (sk) {\n\t\tstruct dst_entry *dst = skb_dst(skb);\n\t\tint ret;\n\n\t\tif (unlikely(rcu_dereference(sk->sk_rx_dst) != dst))\n\t\t\tudp6_sk_rx_dst_set(sk, dst);\n\n\t\tif (!uh->check && !udp_get_no_check6_rx(sk)) {\n\t\t\tif (refcounted)\n\t\t\t\tsock_put(sk);\n\t\t\tgoto report_csum_error;\n\t\t}\n\n\t\tret = udp6_unicast_rcv_skb(sk, skb, uh);\n\t\tif (refcounted)\n\t\t\tsock_put(sk);\n\t\treturn ret;\n\t}\n\n\t \n\tif (ipv6_addr_is_multicast(daddr))\n\t\treturn __udp6_lib_mcast_deliver(net, skb,\n\t\t\t\tsaddr, daddr, udptable, proto);\n\n\t \n\tsk = __udp6_lib_lookup_skb(skb, uh->source, uh->dest, udptable);\n\tif (sk) {\n\t\tif (!uh->check && !udp_get_no_check6_rx(sk))\n\t\t\tgoto report_csum_error;\n\t\treturn udp6_unicast_rcv_skb(sk, skb, uh);\n\t}\nno_sk:\n\treason = SKB_DROP_REASON_NO_SOCKET;\n\n\tif (!uh->check)\n\t\tgoto report_csum_error;\n\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard;\n\tnf_reset_ct(skb);\n\n\tif (udp_lib_checksum_complete(skb))\n\t\tgoto csum_error;\n\n\t__UDP6_INC_STATS(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE);\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\n\tkfree_skb_reason(skb, reason);\n\treturn 0;\n\nshort_packet:\n\tif (reason == SKB_DROP_REASON_NOT_SPECIFIED)\n\t\treason = SKB_DROP_REASON_PKT_TOO_SMALL;\n\tnet_dbg_ratelimited(\"UDP%sv6: short packet: From [%pI6c]:%u %d/%d to [%pI6c]:%u\\n\",\n\t\t\t    proto == IPPROTO_UDPLITE ? \"-Lite\" : \"\",\n\t\t\t    saddr, ntohs(uh->source),\n\t\t\t    ulen, skb->len,\n\t\t\t    daddr, ntohs(uh->dest));\n\tgoto discard;\n\nreport_csum_error:\n\tudp6_csum_zero_error(skb);\ncsum_error:\n\tif (reason == SKB_DROP_REASON_NOT_SPECIFIED)\n\t\treason = SKB_DROP_REASON_UDP_CSUM;\n\t__UDP6_INC_STATS(net, UDP_MIB_CSUMERRORS, proto == IPPROTO_UDPLITE);\ndiscard:\n\t__UDP6_INC_STATS(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);\n\tkfree_skb_reason(skb, reason);\n\treturn 0;\n}\n\n\nstatic struct sock *__udp6_lib_demux_lookup(struct net *net,\n\t\t\t__be16 loc_port, const struct in6_addr *loc_addr,\n\t\t\t__be16 rmt_port, const struct in6_addr *rmt_addr,\n\t\t\tint dif, int sdif)\n{\n\tstruct udp_table *udptable = net->ipv4.udp_table;\n\tunsigned short hnum = ntohs(loc_port);\n\tunsigned int hash2, slot2;\n\tstruct udp_hslot *hslot2;\n\t__portpair ports;\n\tstruct sock *sk;\n\n\thash2 = ipv6_portaddr_hash(net, loc_addr, hnum);\n\tslot2 = hash2 & udptable->mask;\n\thslot2 = &udptable->hash2[slot2];\n\tports = INET_COMBINED_PORTS(rmt_port, hnum);\n\n\tudp_portaddr_for_each_entry_rcu(sk, &hslot2->head) {\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    inet6_match(net, sk, rmt_addr, loc_addr, ports, dif, sdif))\n\t\t\treturn sk;\n\t\t \n\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nvoid udp_v6_early_demux(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct udphdr *uh;\n\tstruct sock *sk;\n\tstruct dst_entry *dst;\n\tint dif = skb->dev->ifindex;\n\tint sdif = inet6_sdif(skb);\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) +\n\t    sizeof(struct udphdr)))\n\t\treturn;\n\n\tuh = udp_hdr(skb);\n\n\tif (skb->pkt_type == PACKET_HOST)\n\t\tsk = __udp6_lib_demux_lookup(net, uh->dest,\n\t\t\t\t\t     &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t     uh->source, &ipv6_hdr(skb)->saddr,\n\t\t\t\t\t     dif, sdif);\n\telse\n\t\treturn;\n\n\tif (!sk || !refcount_inc_not_zero(&sk->sk_refcnt))\n\t\treturn;\n\n\tskb->sk = sk;\n\tskb->destructor = sock_efree;\n\tdst = rcu_dereference(sk->sk_rx_dst);\n\n\tif (dst)\n\t\tdst = dst_check(dst, sk->sk_rx_dst_cookie);\n\tif (dst) {\n\t\t \n\t\tskb_dst_set_noref(skb, dst);\n\t}\n}\n\nINDIRECT_CALLABLE_SCOPE int udpv6_rcv(struct sk_buff *skb)\n{\n\treturn __udp6_lib_rcv(skb, dev_net(skb->dev)->ipv4.udp_table, IPPROTO_UDP);\n}\n\n \nstatic void udp_v6_flush_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\n\tif (up->pending == AF_INET)\n\t\tudp_flush_pending_frames(sk);\n\telse if (up->pending) {\n\t\tup->len = 0;\n\t\tWRITE_ONCE(up->pending, 0);\n\t\tip6_flush_pending_frames(sk);\n\t}\n}\n\nstatic int udpv6_pre_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t     int addr_len)\n{\n\tif (addr_len < offsetofend(struct sockaddr, sa_family))\n\t\treturn -EINVAL;\n\t \n\tif (uaddr->sa_family == AF_INET) {\n\t\tif (ipv6_only_sock(sk))\n\t\t\treturn -EAFNOSUPPORT;\n\t\treturn udp_pre_connect(sk, uaddr, addr_len);\n\t}\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\treturn BPF_CGROUP_RUN_PROG_INET6_CONNECT_LOCK(sk, uaddr);\n}\n\n \nstatic void udp6_hwcsum_outgoing(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t const struct in6_addr *saddr,\n\t\t\t\t const struct in6_addr *daddr, int len)\n{\n\tunsigned int offset;\n\tstruct udphdr *uh = udp_hdr(skb);\n\tstruct sk_buff *frags = skb_shinfo(skb)->frag_list;\n\t__wsum csum = 0;\n\n\tif (!frags) {\n\t\t \n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct udphdr, check);\n\t\tuh->check = ~csum_ipv6_magic(saddr, daddr, len, IPPROTO_UDP, 0);\n\t} else {\n\t\t \n\t\toffset = skb_transport_offset(skb);\n\t\tskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\n\t\tcsum = skb->csum;\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\tdo {\n\t\t\tcsum = csum_add(csum, frags->csum);\n\t\t} while ((frags = frags->next));\n\n\t\tuh->check = csum_ipv6_magic(saddr, daddr, len, IPPROTO_UDP,\n\t\t\t\t\t    csum);\n\t\tif (uh->check == 0)\n\t\t\tuh->check = CSUM_MANGLED_0;\n\t}\n}\n\n \n\nstatic int udp_v6_send_skb(struct sk_buff *skb, struct flowi6 *fl6,\n\t\t\t   struct inet_cork *cork)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct udphdr *uh;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\t__wsum csum = 0;\n\tint offset = skb_transport_offset(skb);\n\tint len = skb->len - offset;\n\tint datalen = len - sizeof(*uh);\n\n\t \n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(len);\n\tuh->check = 0;\n\n\tif (cork->gso_size) {\n\t\tconst int hlen = skb_network_header_len(skb) +\n\t\t\t\t sizeof(struct udphdr);\n\n\t\tif (hlen + cork->gso_size > cork->fragsize) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (datalen > cork->gso_size * UDP_MAX_SEGMENTS) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (udp_get_no_check6_tx(sk)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (skb->ip_summed != CHECKSUM_PARTIAL || is_udplite ||\n\t\t    dst_xfrm(skb_dst(skb))) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (datalen > cork->gso_size) {\n\t\t\tskb_shinfo(skb)->gso_size = cork->gso_size;\n\t\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP_L4;\n\t\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(datalen,\n\t\t\t\t\t\t\t\t cork->gso_size);\n\t\t}\n\t\tgoto csum_partial;\n\t}\n\n\tif (is_udplite)\n\t\tcsum = udplite_csum(skb);\n\telse if (udp_get_no_check6_tx(sk)) {    \n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tgoto send;\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) {  \ncsum_partial:\n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr, len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum(skb);\n\n\t \n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\n\nsend:\n\terr = ip6_send_skb(skb);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS(sock_net(sk),\n\t\t\t\t       UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else {\n\t\tUDP6_INC_STATS(sock_net(sk),\n\t\t\t       UDP_MIB_OUTDATAGRAMS, is_udplite);\n\t}\n\treturn err;\n}\n\nstatic int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct udp_sock  *up = udp_sk(sk);\n\tint err = 0;\n\n\tif (up->pending == AF_INET)\n\t\treturn udp_push_pending_frames(sk);\n\n\tskb = ip6_finish_skb(sk);\n\tif (!skb)\n\t\tgoto out;\n\n\terr = udp_v6_send_skb(skb, &inet_sk(sk)->cork.fl.u.ip6,\n\t\t\t      &inet_sk(sk)->cork.base);\nout:\n\tup->len = 0;\n\tWRITE_ONCE(up->pending, 0);\n\treturn err;\n}\n\nint udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ipv6_txoptions *opt_to_free = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct inet_cork_full cork;\n\tstruct flowi6 *fl6 = &cork.fl.u.ip6;\n\tstruct dst_entry *dst;\n\tstruct ipcm6_cookie ipc6;\n\tint addr_len = msg->msg_namelen;\n\tbool connected = false;\n\tint ulen = len;\n\tint corkreq = udp_test_bit(CORK, sk) || msg->msg_flags & MSG_MORE;\n\tint err;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint (*getfrag)(void *, char *, int, int, int, struct sk_buff *);\n\n\tipcm6_init(&ipc6);\n\tipc6.gso_size = READ_ONCE(up->gso_size);\n\tipc6.sockc.tsflags = READ_ONCE(sk->sk_tsflags);\n\tipc6.sockc.mark = READ_ONCE(sk->sk_mark);\n\n\t \n\tif (sin6) {\n\t\tif (addr_len < offsetof(struct sockaddr, sa_data))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sin6->sin6_family) {\n\t\tcase AF_INET6:\n\t\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\tdaddr = &sin6->sin6_addr;\n\t\t\tif (ipv6_addr_any(daddr) &&\n\t\t\t    ipv6_addr_v4mapped(&np->saddr))\n\t\t\t\tipv6_addr_set_v4mapped(htonl(INADDR_LOOPBACK),\n\t\t\t\t\t\t       daddr);\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\tgoto do_udp_sendmsg;\n\t\tcase AF_UNSPEC:\n\t\t\tmsg->msg_name = sin6 = NULL;\n\t\t\tmsg->msg_namelen = addr_len = 0;\n\t\t\tdaddr = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!READ_ONCE(up->pending)) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t} else\n\t\tdaddr = NULL;\n\n\tif (daddr) {\n\t\tif (ipv6_addr_v4mapped(daddr)) {\n\t\t\tstruct sockaddr_in sin;\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = sin6 ? sin6->sin6_port : inet->inet_dport;\n\t\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\t\tmsg->msg_name = &sin;\n\t\t\tmsg->msg_namelen = sizeof(sin);\ndo_udp_sendmsg:\n\t\t\terr = ipv6_only_sock(sk) ?\n\t\t\t\t-ENETUNREACH : udp_sendmsg(sk, msg, len);\n\t\t\tmsg->msg_name = sin6;\n\t\t\tmsg->msg_namelen = addr_len;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (len > INT_MAX - sizeof(struct udphdr))\n\t\treturn -EMSGSIZE;\n\n\tgetfrag  =  is_udplite ?  udplite_getfrag : ip_generic_getfrag;\n\tif (READ_ONCE(up->pending)) {\n\t\tif (READ_ONCE(up->pending) == AF_INET)\n\t\t\treturn udp_sendmsg(sk, msg, len);\n\t\t \n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET6)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t\t}\n\t\t\tdst = NULL;\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\n\tif (sin6) {\n\t\tif (sin6->sin6_port == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfl6->fl6_dport = sin6->sin6_port;\n\t\tdaddr = &sin6->sin6_addr;\n\n\t\tif (np->sndflow) {\n\t\t\tfl6->flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6->flowlabel & IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6->flowlabel);\n\t\t\t\tif (IS_ERR(flowlabel))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    __ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))\n\t\t\tfl6->flowi6_oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tfl6->fl6_dport = inet->inet_dport;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6->flowlabel = np->flow_label;\n\t\tconnected = true;\n\t}\n\n\tif (!fl6->flowi6_oif)\n\t\tfl6->flowi6_oif = READ_ONCE(sk->sk_bound_dev_if);\n\n\tif (!fl6->flowi6_oif)\n\t\tfl6->flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;\n\n\tfl6->flowi6_uid = sk->sk_uid;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(*opt);\n\t\tipc6.opt = opt;\n\n\t\terr = udp_cmsg_send(sk, msg, &ipc6.gso_size);\n\t\tif (err > 0)\n\t\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, fl6,\n\t\t\t\t\t\t    &ipc6);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6->flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6->flowlabel);\n\t\t\tif (IS_ERR(flowlabel))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = false;\n\t}\n\tif (!opt) {\n\t\topt = txopt_get(np);\n\t\topt_to_free = opt;\n\t}\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\tipc6.opt = opt;\n\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->flowi6_mark = ipc6.sockc.mark;\n\tfl6->daddr = *daddr;\n\tif (ipv6_addr_any(&fl6->saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6->saddr = np->saddr;\n\tfl6->fl6_sport = inet->inet_sport;\n\n\tif (cgroup_bpf_enabled(CGROUP_UDP6_SENDMSG) && !connected) {\n\t\terr = BPF_CGROUP_RUN_PROG_UDP6_SENDMSG_LOCK(sk,\n\t\t\t\t\t   (struct sockaddr *)sin6,\n\t\t\t\t\t   &fl6->saddr);\n\t\tif (err)\n\t\t\tgoto out_no_dst;\n\t\tif (sin6) {\n\t\t\tif (ipv6_addr_v4mapped(&sin6->sin6_addr)) {\n\t\t\t\t \n\t\t\t\terr = -ENOTSUPP;\n\t\t\t\tgoto out_no_dst;\n\t\t\t}\n\t\t\tif (sin6->sin6_port == 0) {\n\t\t\t\t \n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_no_dst;\n\t\t\t}\n\t\t\tfl6->fl6_dport = sin6->sin6_port;\n\t\t\tfl6->daddr = sin6->sin6_addr;\n\t\t}\n\t}\n\n\tif (ipv6_addr_any(&fl6->daddr))\n\t\tfl6->daddr.s6_addr[15] = 0x1;  \n\n\tfinal_p = fl6_update_dst(fl6, opt, &final);\n\tif (final_p)\n\t\tconnected = false;\n\n\tif (!fl6->flowi6_oif && ipv6_addr_is_multicast(&fl6->daddr)) {\n\t\tfl6->flowi6_oif = np->mcast_oif;\n\t\tconnected = false;\n\t} else if (!fl6->flowi6_oif)\n\t\tfl6->flowi6_oif = np->ucast_oif;\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi_common(fl6));\n\n\tif (ipc6.tclass < 0)\n\t\tipc6.tclass = np->tclass;\n\n\tfl6->flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6->flowlabel);\n\n\tdst = ip6_sk_dst_lookup_flow(sk, fl6, final_p, connected);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto out;\n\t}\n\n\tif (ipc6.hlimit < 0)\n\t\tipc6.hlimit = ip6_sk_dst_hoplimit(np, fl6, dst);\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\t \n\tif (!corkreq) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = ip6_make_skb(sk, getfrag, msg, ulen,\n\t\t\t\t   sizeof(struct udphdr), &ipc6,\n\t\t\t\t   (struct rt6_info *)dst,\n\t\t\t\t   msg->msg_flags, &cork);\n\t\terr = PTR_ERR(skb);\n\t\tif (!IS_ERR_OR_NULL(skb))\n\t\t\terr = udp_v6_send_skb(skb, fl6, &cork.base);\n\t\t \n\t\tgoto out_no_dst;\n\t}\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t \n\t\t \n\t\trelease_sock(sk);\n\n\t\tnet_dbg_ratelimited(\"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tWRITE_ONCE(up->pending, AF_INET6);\n\ndo_append_data:\n\tif (ipc6.dontfrag < 0)\n\t\tipc6.dontfrag = np->dontfrag;\n\tup->len += ulen;\n\terr = ip6_append_data(sk, getfrag, msg, ulen, sizeof(struct udphdr),\n\t\t\t      &ipc6, fl6, (struct rt6_info *)dst,\n\t\t\t      corkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_v6_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_v6_push_pending_frames(sk);\n\telse if (unlikely(skb_queue_empty(&sk->sk_write_queue)))\n\t\tWRITE_ONCE(up->pending, 0);\n\n\tif (err > 0)\n\t\terr = np->recverr ? net_xmit_errno(err) : 0;\n\trelease_sock(sk);\n\nout:\n\tdst_release(dst);\nout_no_dst:\n\tfl6_sock_release(flowlabel);\n\ttxopt_put(opt_to_free);\n\tif (!err)\n\t\treturn len;\n\t \n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP6_INC_STATS(sock_net(sk),\n\t\t\t       UDP_MIB_SNDBUFERRORS, is_udplite);\n\t}\n\treturn err;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(dst, &fl6->daddr);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}\nEXPORT_SYMBOL(udpv6_sendmsg);\n\nstatic void udpv6_splice_eof(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct udp_sock *up = udp_sk(sk);\n\n\tif (!READ_ONCE(up->pending) || udp_test_bit(CORK, sk))\n\t\treturn;\n\n\tlock_sock(sk);\n\tif (up->pending && !udp_test_bit(CORK, sk))\n\t\tudp_v6_push_pending_frames(sk);\n\trelease_sock(sk);\n}\n\nvoid udpv6_destroy_sock(struct sock *sk)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tlock_sock(sk);\n\n\t \n\tsock_set_flag(sk, SOCK_DEAD);\n\tudp_v6_flush_pending_frames(sk);\n\trelease_sock(sk);\n\n\tif (static_branch_unlikely(&udpv6_encap_needed_key)) {\n\t\tif (up->encap_type) {\n\t\t\tvoid (*encap_destroy)(struct sock *sk);\n\t\t\tencap_destroy = READ_ONCE(up->encap_destroy);\n\t\t\tif (encap_destroy)\n\t\t\t\tencap_destroy(sk);\n\t\t}\n\t\tif (udp_test_bit(ENCAP_ENABLED, sk)) {\n\t\t\tstatic_branch_dec(&udpv6_encap_needed_key);\n\t\t\tudp_encap_disable();\n\t\t}\n\t}\n}\n\n \nint udpv6_setsockopt(struct sock *sk, int level, int optname, sockptr_t optval,\n\t\t     unsigned int optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE || level == SOL_SOCKET)\n\t\treturn udp_lib_setsockopt(sk, level, optname,\n\t\t\t\t\t  optval, optlen,\n\t\t\t\t\t  udp_v6_push_pending_frames);\n\treturn ipv6_setsockopt(sk, level, optname, optval, optlen);\n}\n\nint udpv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t     char __user *optval, int __user *optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_getsockopt(sk, level, optname, optval, optlen);\n\treturn ipv6_getsockopt(sk, level, optname, optval, optlen);\n}\n\nstatic const struct inet6_protocol udpv6_protocol = {\n\t.handler\t=\tudpv6_rcv,\n\t.err_handler\t=\tudpv6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\n \n#ifdef CONFIG_PROC_FS\nint udp6_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, IPV6_SEQ_DGRAM_HEADER);\n\t} else {\n\t\tint bucket = ((struct udp_iter_state *)seq->private)->bucket;\n\t\tconst struct inet_sock *inet = inet_sk((const struct sock *)v);\n\t\t__u16 srcp = ntohs(inet->inet_sport);\n\t\t__u16 destp = ntohs(inet->inet_dport);\n\t\t__ip6_dgram_sock_seq_show(seq, v, srcp, destp,\n\t\t\t\t\t  udp_rqueue_get(v), bucket);\n\t}\n\treturn 0;\n}\n\nconst struct seq_operations udp6_seq_ops = {\n\t.start\t\t= udp_seq_start,\n\t.next\t\t= udp_seq_next,\n\t.stop\t\t= udp_seq_stop,\n\t.show\t\t= udp6_seq_show,\n};\nEXPORT_SYMBOL(udp6_seq_ops);\n\nstatic struct udp_seq_afinfo udp6_seq_afinfo = {\n\t.family\t\t= AF_INET6,\n\t.udp_table\t= NULL,\n};\n\nint __net_init udp6_proc_init(struct net *net)\n{\n\tif (!proc_create_net_data(\"udp6\", 0444, net->proc_net, &udp6_seq_ops,\n\t\t\tsizeof(struct udp_iter_state), &udp6_seq_afinfo))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid udp6_proc_exit(struct net *net)\n{\n\tremove_proc_entry(\"udp6\", net->proc_net);\n}\n#endif  \n\n \n\nstruct proto udpv6_prot = {\n\t.name\t\t\t= \"UDPv6\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.close\t\t\t= udp_lib_close,\n\t.pre_connect\t\t= udpv6_pre_connect,\n\t.connect\t\t= ip6_datagram_connect,\n\t.disconnect\t\t= udp_disconnect,\n\t.ioctl\t\t\t= udp_ioctl,\n\t.init\t\t\t= udpv6_init_sock,\n\t.destroy\t\t= udpv6_destroy_sock,\n\t.setsockopt\t\t= udpv6_setsockopt,\n\t.getsockopt\t\t= udpv6_getsockopt,\n\t.sendmsg\t\t= udpv6_sendmsg,\n\t.recvmsg\t\t= udpv6_recvmsg,\n\t.splice_eof\t\t= udpv6_splice_eof,\n\t.release_cb\t\t= ip6_datagram_release_cb,\n\t.hash\t\t\t= udp_lib_hash,\n\t.unhash\t\t\t= udp_lib_unhash,\n\t.rehash\t\t\t= udp_v6_rehash,\n\t.get_port\t\t= udp_v6_get_port,\n\t.put_port\t\t= udp_lib_unhash,\n#ifdef CONFIG_BPF_SYSCALL\n\t.psock_update_sk_prot\t= udp_bpf_update_proto,\n#endif\n\n\t.memory_allocated\t= &udp_memory_allocated,\n\t.per_cpu_fw_alloc\t= &udp_memory_per_cpu_fw_alloc,\n\n\t.sysctl_mem\t\t= sysctl_udp_mem,\n\t.sysctl_wmem_offset     = offsetof(struct net, ipv4.sysctl_udp_wmem_min),\n\t.sysctl_rmem_offset     = offsetof(struct net, ipv4.sysctl_udp_rmem_min),\n\t.obj_size\t\t= sizeof(struct udp6_sock),\n\t.ipv6_pinfo_offset = offsetof(struct udp6_sock, inet6),\n\t.h.udp_table\t\t= NULL,\n\t.diag_destroy\t\t= udp_abort,\n};\n\nstatic struct inet_protosw udpv6_protosw = {\n\t.type =      SOCK_DGRAM,\n\t.protocol =  IPPROTO_UDP,\n\t.prot =      &udpv6_prot,\n\t.ops =       &inet6_dgram_ops,\n\t.flags =     INET_PROTOSW_PERMANENT,\n};\n\nint __init udpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&udpv6_protocol, IPPROTO_UDP);\n\tif (ret)\n\t\tgoto out;\n\n\tret = inet6_register_protosw(&udpv6_protosw);\n\tif (ret)\n\t\tgoto out_udpv6_protocol;\nout:\n\treturn ret;\n\nout_udpv6_protocol:\n\tinet6_del_protocol(&udpv6_protocol, IPPROTO_UDP);\n\tgoto out;\n}\n\nvoid udpv6_exit(void)\n{\n\tinet6_unregister_protosw(&udpv6_protosw);\n\tinet6_del_protocol(&udpv6_protocol, IPPROTO_UDP);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}