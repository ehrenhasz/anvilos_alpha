{
  "module_name": "sit.c",
  "hash_id": "f9c3c822619c0d4cbc0b165781a29bb465b5b2c9d0e7d3887048ffa274abba56",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/sit.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/icmp.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/init.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/if_ether.h>\n\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/ip.h>\n#include <net/udp.h>\n#include <net/icmp.h>\n#include <net/ip_tunnels.h>\n#include <net/inet_ecn.h>\n#include <net/xfrm.h>\n#include <net/dsfield.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n \n\n#define IP6_SIT_HASH_SIZE  16\n#define HASH(addr) (((__force u32)addr^((__force u32)addr>>4))&0xF)\n\nstatic bool log_ecn_error = true;\nmodule_param(log_ecn_error, bool, 0644);\nMODULE_PARM_DESC(log_ecn_error, \"Log packets received with corrupted ECN\");\n\nstatic int ipip6_tunnel_init(struct net_device *dev);\nstatic void ipip6_tunnel_setup(struct net_device *dev);\nstatic void ipip6_dev_free(struct net_device *dev);\nstatic bool check_6rd(struct ip_tunnel *tunnel, const struct in6_addr *v6dst,\n\t\t      __be32 *v4dst);\nstatic struct rtnl_link_ops sit_link_ops __read_mostly;\n\nstatic unsigned int sit_net_id __read_mostly;\nstruct sit_net {\n\tstruct ip_tunnel __rcu *tunnels_r_l[IP6_SIT_HASH_SIZE];\n\tstruct ip_tunnel __rcu *tunnels_r[IP6_SIT_HASH_SIZE];\n\tstruct ip_tunnel __rcu *tunnels_l[IP6_SIT_HASH_SIZE];\n\tstruct ip_tunnel __rcu *tunnels_wc[1];\n\tstruct ip_tunnel __rcu **tunnels[4];\n\n\tstruct net_device *fb_tunnel_dev;\n};\n\nstatic inline struct sit_net *dev_to_sit_net(struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\treturn net_generic(t->net, sit_net_id);\n}\n\n \nstatic struct ip_tunnel *ipip6_tunnel_lookup(struct net *net,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     __be32 remote, __be32 local,\n\t\t\t\t\t     int sifindex)\n{\n\tunsigned int h0 = HASH(remote);\n\tunsigned int h1 = HASH(local);\n\tstruct ip_tunnel *t;\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tint ifindex = dev ? dev->ifindex : 0;\n\n\tfor_each_ip_tunnel_rcu(t, sitn->tunnels_r_l[h0 ^ h1]) {\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr &&\n\t\t    (!dev || !t->parms.link || ifindex == t->parms.link ||\n\t\t     sifindex == t->parms.link) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tfor_each_ip_tunnel_rcu(t, sitn->tunnels_r[h0]) {\n\t\tif (remote == t->parms.iph.daddr &&\n\t\t    (!dev || !t->parms.link || ifindex == t->parms.link ||\n\t\t     sifindex == t->parms.link) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tfor_each_ip_tunnel_rcu(t, sitn->tunnels_l[h1]) {\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    (!dev || !t->parms.link || ifindex == t->parms.link ||\n\t\t     sifindex == t->parms.link) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\tt = rcu_dereference(sitn->tunnels_wc[0]);\n\tif (t && (t->dev->flags & IFF_UP))\n\t\treturn t;\n\treturn NULL;\n}\n\nstatic struct ip_tunnel __rcu **__ipip6_bucket(struct sit_net *sitn,\n\t\tstruct ip_tunnel_parm *parms)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\tunsigned int h = 0;\n\tint prio = 0;\n\n\tif (remote) {\n\t\tprio |= 2;\n\t\th ^= HASH(remote);\n\t}\n\tif (local) {\n\t\tprio |= 1;\n\t\th ^= HASH(local);\n\t}\n\treturn &sitn->tunnels[prio][h];\n}\n\nstatic inline struct ip_tunnel __rcu **ipip6_bucket(struct sit_net *sitn,\n\t\tstruct ip_tunnel *t)\n{\n\treturn __ipip6_bucket(sitn, &t->parms);\n}\n\nstatic void ipip6_tunnel_unlink(struct sit_net *sitn, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel __rcu **tp;\n\tstruct ip_tunnel *iter;\n\n\tfor (tp = ipip6_bucket(sitn, t);\n\t     (iter = rtnl_dereference(*tp)) != NULL;\n\t     tp = &iter->next) {\n\t\tif (t == iter) {\n\t\t\trcu_assign_pointer(*tp, t->next);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ipip6_tunnel_link(struct sit_net *sitn, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel __rcu **tp = ipip6_bucket(sitn, t);\n\n\trcu_assign_pointer(t->next, rtnl_dereference(*tp));\n\trcu_assign_pointer(*tp, t);\n}\n\nstatic void ipip6_tunnel_clone_6rd(struct net_device *dev, struct sit_net *sitn)\n{\n#ifdef CONFIG_IPV6_SIT_6RD\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (dev == sitn->fb_tunnel_dev || !sitn->fb_tunnel_dev) {\n\t\tipv6_addr_set(&t->ip6rd.prefix, htonl(0x20020000), 0, 0, 0);\n\t\tt->ip6rd.relay_prefix = 0;\n\t\tt->ip6rd.prefixlen = 16;\n\t\tt->ip6rd.relay_prefixlen = 0;\n\t} else {\n\t\tstruct ip_tunnel *t0 = netdev_priv(sitn->fb_tunnel_dev);\n\t\tmemcpy(&t->ip6rd, &t0->ip6rd, sizeof(t->ip6rd));\n\t}\n#endif\n}\n\nstatic int ipip6_tunnel_create(struct net_device *dev)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct net *net = dev_net(dev);\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tint err;\n\n\t__dev_addr_set(dev, &t->parms.iph.saddr, 4);\n\tmemcpy(dev->broadcast, &t->parms.iph.daddr, 4);\n\n\tif ((__force u16)t->parms.i_flags & SIT_ISATAP)\n\t\tdev->priv_flags |= IFF_ISATAP;\n\n\tdev->rtnl_link_ops = &sit_link_ops;\n\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\tgoto out;\n\n\tipip6_tunnel_clone_6rd(dev, sitn);\n\n\tipip6_tunnel_link(sitn, t);\n\treturn 0;\n\nout:\n\treturn err;\n}\n\nstatic struct ip_tunnel *ipip6_tunnel_locate(struct net *net,\n\t\tstruct ip_tunnel_parm *parms, int create)\n{\n\t__be32 remote = parms->iph.daddr;\n\t__be32 local = parms->iph.saddr;\n\tstruct ip_tunnel *t, *nt;\n\tstruct ip_tunnel __rcu **tp;\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\n\tfor (tp = __ipip6_bucket(sitn, parms);\n\t    (t = rtnl_dereference(*tp)) != NULL;\n\t     tp = &t->next) {\n\t\tif (local == t->parms.iph.saddr &&\n\t\t    remote == t->parms.iph.daddr &&\n\t\t    parms->link == t->parms.link) {\n\t\t\tif (create)\n\t\t\t\treturn NULL;\n\t\t\telse\n\t\t\t\treturn t;\n\t\t}\n\t}\n\tif (!create)\n\t\tgoto failed;\n\n\tif (parms->name[0]) {\n\t\tif (!dev_valid_name(parms->name))\n\t\t\tgoto failed;\n\t\tstrscpy(name, parms->name, IFNAMSIZ);\n\t} else {\n\t\tstrcpy(name, \"sit%d\");\n\t}\n\tdev = alloc_netdev(sizeof(*t), name, NET_NAME_UNKNOWN,\n\t\t\t   ipip6_tunnel_setup);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev_net_set(dev, net);\n\n\tnt = netdev_priv(dev);\n\n\tnt->parms = *parms;\n\tif (ipip6_tunnel_create(dev) < 0)\n\t\tgoto failed_free;\n\n\tif (!parms->name[0])\n\t\tstrcpy(parms->name, dev->name);\n\n\treturn nt;\n\nfailed_free:\n\tfree_netdev(dev);\nfailed:\n\treturn NULL;\n}\n\n#define for_each_prl_rcu(start)\t\t\t\\\n\tfor (prl = rcu_dereference(start);\t\\\n\t     prl;\t\t\t\t\\\n\t     prl = rcu_dereference(prl->next))\n\nstatic struct ip_tunnel_prl_entry *\n__ipip6_tunnel_locate_prl(struct ip_tunnel *t, __be32 addr)\n{\n\tstruct ip_tunnel_prl_entry *prl;\n\n\tfor_each_prl_rcu(t->prl)\n\t\tif (prl->addr == addr)\n\t\t\tbreak;\n\treturn prl;\n\n}\n\nstatic int ipip6_tunnel_get_prl(struct net_device *dev, struct ip_tunnel_prl __user *a)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_prl kprl, *kp;\n\tstruct ip_tunnel_prl_entry *prl;\n\tunsigned int cmax, c = 0, ca, len;\n\tint ret = 0;\n\n\tif (dev == dev_to_sit_net(dev)->fb_tunnel_dev)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&kprl, a, sizeof(kprl)))\n\t\treturn -EFAULT;\n\tcmax = kprl.datalen / sizeof(kprl);\n\tif (cmax > 1 && kprl.addr != htonl(INADDR_ANY))\n\t\tcmax = 1;\n\n\t \n\tkp = (cmax <= 1 || capable(CAP_NET_ADMIN)) ?\n\t\tkcalloc(cmax, sizeof(*kp), GFP_KERNEL_ACCOUNT | __GFP_NOWARN) :\n\t\tNULL;\n\n\tca = min(t->prl_count, cmax);\n\n\tif (!kp) {\n\t\t \n\t\tkp = kcalloc(ca, sizeof(*kp), GFP_ATOMIC | __GFP_ACCOUNT |\n\t\t\t\t\t      __GFP_NOWARN);\n\t\tif (!kp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tfor_each_prl_rcu(t->prl) {\n\t\tif (c >= cmax)\n\t\t\tbreak;\n\t\tif (kprl.addr != htonl(INADDR_ANY) && prl->addr != kprl.addr)\n\t\t\tcontinue;\n\t\tkp[c].addr = prl->addr;\n\t\tkp[c].flags = prl->flags;\n\t\tc++;\n\t\tif (kprl.addr != htonl(INADDR_ANY))\n\t\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\n\tlen = sizeof(*kp) * c;\n\tret = 0;\n\tif ((len && copy_to_user(a + 1, kp, len)) || put_user(len, &a->datalen))\n\t\tret = -EFAULT;\n\n\tkfree(kp);\nout:\n\treturn ret;\n}\n\nstatic int\nipip6_tunnel_add_prl(struct ip_tunnel *t, struct ip_tunnel_prl *a, int chg)\n{\n\tstruct ip_tunnel_prl_entry *p;\n\tint err = 0;\n\n\tif (a->addr == htonl(INADDR_ANY))\n\t\treturn -EINVAL;\n\n\tASSERT_RTNL();\n\n\tfor (p = rtnl_dereference(t->prl); p; p = rtnl_dereference(p->next)) {\n\t\tif (p->addr == a->addr) {\n\t\t\tif (chg) {\n\t\t\t\tp->flags = a->flags;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (chg) {\n\t\terr = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tp = kzalloc(sizeof(struct ip_tunnel_prl_entry), GFP_KERNEL);\n\tif (!p) {\n\t\terr = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tp->next = t->prl;\n\tp->addr = a->addr;\n\tp->flags = a->flags;\n\tt->prl_count++;\n\trcu_assign_pointer(t->prl, p);\nout:\n\treturn err;\n}\n\nstatic void prl_list_destroy_rcu(struct rcu_head *head)\n{\n\tstruct ip_tunnel_prl_entry *p, *n;\n\n\tp = container_of(head, struct ip_tunnel_prl_entry, rcu_head);\n\tdo {\n\t\tn = rcu_dereference_protected(p->next, 1);\n\t\tkfree(p);\n\t\tp = n;\n\t} while (p);\n}\n\nstatic int\nipip6_tunnel_del_prl(struct ip_tunnel *t, struct ip_tunnel_prl *a)\n{\n\tstruct ip_tunnel_prl_entry *x;\n\tstruct ip_tunnel_prl_entry __rcu **p;\n\tint err = 0;\n\n\tASSERT_RTNL();\n\n\tif (a && a->addr != htonl(INADDR_ANY)) {\n\t\tfor (p = &t->prl;\n\t\t     (x = rtnl_dereference(*p)) != NULL;\n\t\t     p = &x->next) {\n\t\t\tif (x->addr == a->addr) {\n\t\t\t\t*p = x->next;\n\t\t\t\tkfree_rcu(x, rcu_head);\n\t\t\t\tt->prl_count--;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\terr = -ENXIO;\n\t} else {\n\t\tx = rtnl_dereference(t->prl);\n\t\tif (x) {\n\t\t\tt->prl_count = 0;\n\t\t\tcall_rcu(&x->rcu_head, prl_list_destroy_rcu);\n\t\t\tt->prl = NULL;\n\t\t}\n\t}\nout:\n\treturn err;\n}\n\nstatic int ipip6_tunnel_prl_ctl(struct net_device *dev,\n\t\t\t\tstruct ip_tunnel_prl __user *data, int cmd)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_prl prl;\n\tint err;\n\n\tif (!ns_capable(t->net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (dev == dev_to_sit_net(dev)->fb_tunnel_dev)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&prl, data, sizeof(prl)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase SIOCDELPRL:\n\t\terr = ipip6_tunnel_del_prl(t, &prl);\n\t\tbreak;\n\tcase SIOCADDPRL:\n\tcase SIOCCHGPRL:\n\t\terr = ipip6_tunnel_add_prl(t, &prl, cmd == SIOCCHGPRL);\n\t\tbreak;\n\t}\n\tdst_cache_reset(&t->dst_cache);\n\tnetdev_state_change(dev);\n\treturn err;\n}\n\nstatic int\nisatap_chksrc(struct sk_buff *skb, const struct iphdr *iph, struct ip_tunnel *t)\n{\n\tstruct ip_tunnel_prl_entry *p;\n\tint ok = 1;\n\n\trcu_read_lock();\n\tp = __ipip6_tunnel_locate_prl(t, iph->saddr);\n\tif (p) {\n\t\tif (p->flags & PRL_DEFAULT)\n\t\t\tskb->ndisc_nodetype = NDISC_NODETYPE_DEFAULT;\n\t\telse\n\t\t\tskb->ndisc_nodetype = NDISC_NODETYPE_NODEFAULT;\n\t} else {\n\t\tconst struct in6_addr *addr6 = &ipv6_hdr(skb)->saddr;\n\n\t\tif (ipv6_addr_is_isatap(addr6) &&\n\t\t    (addr6->s6_addr32[3] == iph->saddr) &&\n\t\t    ipv6_chk_prefix(addr6, t->dev))\n\t\t\tskb->ndisc_nodetype = NDISC_NODETYPE_HOST;\n\t\telse\n\t\t\tok = 0;\n\t}\n\trcu_read_unlock();\n\treturn ok;\n}\n\nstatic void ipip6_tunnel_uninit(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct sit_net *sitn = net_generic(tunnel->net, sit_net_id);\n\n\tif (dev == sitn->fb_tunnel_dev) {\n\t\tRCU_INIT_POINTER(sitn->tunnels_wc[0], NULL);\n\t} else {\n\t\tipip6_tunnel_unlink(sitn, tunnel);\n\t\tipip6_tunnel_del_prl(tunnel, NULL);\n\t}\n\tdst_cache_reset(&tunnel->dst_cache);\n\tnetdev_put(dev, &tunnel->dev_tracker);\n}\n\nstatic int ipip6_err(struct sk_buff *skb, u32 info)\n{\n\tconst struct iphdr *iph = (const struct iphdr *)skb->data;\n\tconst int type = icmp_hdr(skb)->type;\n\tconst int code = icmp_hdr(skb)->code;\n\tunsigned int data_len = 0;\n\tstruct ip_tunnel *t;\n\tint sifindex;\n\tint err;\n\n\tswitch (type) {\n\tdefault:\n\tcase ICMP_PARAMETERPROB:\n\t\treturn 0;\n\n\tcase ICMP_DEST_UNREACH:\n\t\tswitch (code) {\n\t\tcase ICMP_SR_FAILED:\n\t\t\t \n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ICMP_TIME_EXCEEDED:\n\t\tif (code != ICMP_EXC_TTL)\n\t\t\treturn 0;\n\t\tdata_len = icmp_hdr(skb)->un.reserved[1] * 4;  \n\t\tbreak;\n\tcase ICMP_REDIRECT:\n\t\tbreak;\n\t}\n\n\terr = -ENOENT;\n\n\tsifindex = netif_is_l3_master(skb->dev) ? IPCB(skb)->iif : 0;\n\tt = ipip6_tunnel_lookup(dev_net(skb->dev), skb->dev,\n\t\t\t\tiph->daddr, iph->saddr, sifindex);\n\tif (!t)\n\t\tgoto out;\n\n\tif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED) {\n\t\tipv4_update_pmtu(skb, dev_net(skb->dev), info,\n\t\t\t\t t->parms.link, iph->protocol);\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\tif (type == ICMP_REDIRECT) {\n\t\tipv4_redirect(skb, dev_net(skb->dev), t->parms.link,\n\t\t\t      iph->protocol);\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\tif (__in6_dev_get(skb->dev) &&\n\t    !ip6_err_gen_icmpv6_unreach(skb, iph->ihl * 4, type, data_len))\n\t\tgoto out;\n\n\tif (t->parms.iph.daddr == 0)\n\t\tgoto out;\n\n\tif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\n\t\tgoto out;\n\n\tif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\n\t\tt->err_count++;\n\telse\n\t\tt->err_count = 1;\n\tt->err_time = jiffies;\nout:\n\treturn err;\n}\n\nstatic inline bool is_spoofed_6rd(struct ip_tunnel *tunnel, const __be32 v4addr,\n\t\t\t\t  const struct in6_addr *v6addr)\n{\n\t__be32 v4embed = 0;\n\tif (check_6rd(tunnel, v6addr, &v4embed) && v4addr != v4embed)\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic bool only_dnatted(const struct ip_tunnel *tunnel,\n\tconst struct in6_addr *v6dst)\n{\n\tint prefix_len;\n\n#ifdef CONFIG_IPV6_SIT_6RD\n\tprefix_len = tunnel->ip6rd.prefixlen + 32\n\t\t- tunnel->ip6rd.relay_prefixlen;\n#else\n\tprefix_len = 48;\n#endif\n\treturn ipv6_chk_custom_prefix(v6dst, prefix_len, tunnel->dev);\n}\n\n \nstatic bool packet_is_spoofed(struct sk_buff *skb,\n\t\t\t      const struct iphdr *iph,\n\t\t\t      struct ip_tunnel *tunnel)\n{\n\tconst struct ipv6hdr *ipv6h;\n\n\tif (tunnel->dev->priv_flags & IFF_ISATAP) {\n\t\tif (!isatap_chksrc(skb, iph, tunnel))\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\tif (tunnel->dev->flags & IFF_POINTOPOINT)\n\t\treturn false;\n\n\tipv6h = ipv6_hdr(skb);\n\n\tif (unlikely(is_spoofed_6rd(tunnel, iph->saddr, &ipv6h->saddr))) {\n\t\tnet_warn_ratelimited(\"Src spoofed %pI4/%pI6c -> %pI4/%pI6c\\n\",\n\t\t\t\t     &iph->saddr, &ipv6h->saddr,\n\t\t\t\t     &iph->daddr, &ipv6h->daddr);\n\t\treturn true;\n\t}\n\n\tif (likely(!is_spoofed_6rd(tunnel, iph->daddr, &ipv6h->daddr)))\n\t\treturn false;\n\n\tif (only_dnatted(tunnel, &ipv6h->daddr))\n\t\treturn false;\n\n\tnet_warn_ratelimited(\"Dst spoofed %pI4/%pI6c -> %pI4/%pI6c\\n\",\n\t\t\t     &iph->saddr, &ipv6h->saddr,\n\t\t\t     &iph->daddr, &ipv6h->daddr);\n\treturn true;\n}\n\nstatic int ipip6_rcv(struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tstruct ip_tunnel *tunnel;\n\tint sifindex;\n\tint err;\n\n\tsifindex = netif_is_l3_master(skb->dev) ? IPCB(skb)->iif : 0;\n\ttunnel = ipip6_tunnel_lookup(dev_net(skb->dev), skb->dev,\n\t\t\t\t     iph->saddr, iph->daddr, sifindex);\n\tif (tunnel) {\n\t\tif (tunnel->parms.iph.protocol != IPPROTO_IPV6 &&\n\t\t    tunnel->parms.iph.protocol != 0)\n\t\t\tgoto out;\n\n\t\tskb->mac_header = skb->network_header;\n\t\tskb_reset_network_header(skb);\n\t\tIPCB(skb)->flags = 0;\n\t\tskb->dev = tunnel->dev;\n\n\t\tif (packet_is_spoofed(skb, iph, tunnel)) {\n\t\t\tDEV_STATS_INC(tunnel->dev, rx_errors);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (iptunnel_pull_header(skb, 0, htons(ETH_P_IPV6),\n\t\t    !net_eq(tunnel->net, dev_net(tunnel->dev))))\n\t\t\tgoto out;\n\n\t\t \n\t\tiph = (const struct iphdr *)skb_mac_header(skb);\n\t\tskb_reset_mac_header(skb);\n\n\t\terr = IP_ECN_decapsulate(iph, skb);\n\t\tif (unlikely(err)) {\n\t\t\tif (log_ecn_error)\n\t\t\t\tnet_info_ratelimited(\"non-ECT from %pI4 with TOS=%#x\\n\",\n\t\t\t\t\t\t     &iph->saddr, iph->tos);\n\t\t\tif (err > 1) {\n\t\t\t\tDEV_STATS_INC(tunnel->dev, rx_frame_errors);\n\t\t\t\tDEV_STATS_INC(tunnel->dev, rx_errors);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tdev_sw_netstats_rx_add(tunnel->dev, skb->len);\n\n\t\tnetif_rx(skb);\n\n\t\treturn 0;\n\t}\n\n\t \n\treturn 1;\nout:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic const struct tnl_ptk_info ipip_tpi = {\n\t \n\t.proto = htons(ETH_P_IP),\n};\n\n#if IS_ENABLED(CONFIG_MPLS)\nstatic const struct tnl_ptk_info mplsip_tpi = {\n\t \n\t.proto = htons(ETH_P_MPLS_UC),\n};\n#endif\n\nstatic int sit_tunnel_rcv(struct sk_buff *skb, u8 ipproto)\n{\n\tconst struct iphdr *iph;\n\tstruct ip_tunnel *tunnel;\n\tint sifindex;\n\n\tsifindex = netif_is_l3_master(skb->dev) ? IPCB(skb)->iif : 0;\n\n\tiph = ip_hdr(skb);\n\ttunnel = ipip6_tunnel_lookup(dev_net(skb->dev), skb->dev,\n\t\t\t\t     iph->saddr, iph->daddr, sifindex);\n\tif (tunnel) {\n\t\tconst struct tnl_ptk_info *tpi;\n\n\t\tif (tunnel->parms.iph.protocol != ipproto &&\n\t\t    tunnel->parms.iph.protocol != 0)\n\t\t\tgoto drop;\n\n\t\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\t\tgoto drop;\n#if IS_ENABLED(CONFIG_MPLS)\n\t\tif (ipproto == IPPROTO_MPLS)\n\t\t\ttpi = &mplsip_tpi;\n\t\telse\n#endif\n\t\t\ttpi = &ipip_tpi;\n\t\tif (iptunnel_pull_header(skb, 0, tpi->proto, false))\n\t\t\tgoto drop;\n\t\tskb_reset_mac_header(skb);\n\n\t\treturn ip_tunnel_rcv(tunnel, skb, tpi, NULL, log_ecn_error);\n\t}\n\n\treturn 1;\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int ipip_rcv(struct sk_buff *skb)\n{\n\treturn sit_tunnel_rcv(skb, IPPROTO_IPIP);\n}\n\n#if IS_ENABLED(CONFIG_MPLS)\nstatic int mplsip_rcv(struct sk_buff *skb)\n{\n\treturn sit_tunnel_rcv(skb, IPPROTO_MPLS);\n}\n#endif\n\n \nstatic bool check_6rd(struct ip_tunnel *tunnel, const struct in6_addr *v6dst,\n\t\t      __be32 *v4dst)\n{\n#ifdef CONFIG_IPV6_SIT_6RD\n\tif (ipv6_prefix_equal(v6dst, &tunnel->ip6rd.prefix,\n\t\t\t      tunnel->ip6rd.prefixlen)) {\n\t\tunsigned int pbw0, pbi0;\n\t\tint pbi1;\n\t\tu32 d;\n\n\t\tpbw0 = tunnel->ip6rd.prefixlen >> 5;\n\t\tpbi0 = tunnel->ip6rd.prefixlen & 0x1f;\n\n\t\td = tunnel->ip6rd.relay_prefixlen < 32 ?\n\t\t\t(ntohl(v6dst->s6_addr32[pbw0]) << pbi0) >>\n\t\t    tunnel->ip6rd.relay_prefixlen : 0;\n\n\t\tpbi1 = pbi0 - tunnel->ip6rd.relay_prefixlen;\n\t\tif (pbi1 > 0)\n\t\t\td |= ntohl(v6dst->s6_addr32[pbw0 + 1]) >>\n\t\t\t     (32 - pbi1);\n\n\t\t*v4dst = tunnel->ip6rd.relay_prefix | htonl(d);\n\t\treturn true;\n\t}\n#else\n\tif (v6dst->s6_addr16[0] == htons(0x2002)) {\n\t\t \n\t\tmemcpy(v4dst, &v6dst->s6_addr16[1], 4);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic inline __be32 try_6rd(struct ip_tunnel *tunnel,\n\t\t\t     const struct in6_addr *v6dst)\n{\n\t__be32 dst = 0;\n\tcheck_6rd(tunnel, v6dst, &dst);\n\treturn dst;\n}\n\n \n\nstatic netdev_tx_t ipip6_tunnel_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tconst struct iphdr  *tiph = &tunnel->parms.iph;\n\tconst struct ipv6hdr *iph6 = ipv6_hdr(skb);\n\tu8     tos = tunnel->parms.iph.tos;\n\t__be16 df = tiph->frag_off;\n\tstruct rtable *rt;\t\t \n\tstruct net_device *tdev;\t \n\tunsigned int max_headroom;\t \n\t__be32 dst = tiph->daddr;\n\tstruct flowi4 fl4;\n\tint    mtu;\n\tconst struct in6_addr *addr6;\n\tint addr_type;\n\tu8 ttl;\n\tu8 protocol = IPPROTO_IPV6;\n\tint t_hlen = tunnel->hlen + sizeof(struct iphdr);\n\n\tif (tos == 1)\n\t\ttos = ipv6_get_dsfield(iph6);\n\n\t \n\tif (dev->priv_flags & IFF_ISATAP) {\n\t\tstruct neighbour *neigh = NULL;\n\t\tbool do_tx_error = false;\n\n\t\tif (skb_dst(skb))\n\t\t\tneigh = dst_neigh_lookup(skb_dst(skb), &iph6->daddr);\n\n\t\tif (!neigh) {\n\t\t\tnet_dbg_ratelimited(\"nexthop == NULL\\n\");\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\taddr6 = (const struct in6_addr *)&neigh->primary_key;\n\t\taddr_type = ipv6_addr_type(addr6);\n\n\t\tif ((addr_type & IPV6_ADDR_UNICAST) &&\n\t\t     ipv6_addr_is_isatap(addr6))\n\t\t\tdst = addr6->s6_addr32[3];\n\t\telse\n\t\t\tdo_tx_error = true;\n\n\t\tneigh_release(neigh);\n\t\tif (do_tx_error)\n\t\t\tgoto tx_error;\n\t}\n\n\tif (!dst)\n\t\tdst = try_6rd(tunnel, &iph6->daddr);\n\n\tif (!dst) {\n\t\tstruct neighbour *neigh = NULL;\n\t\tbool do_tx_error = false;\n\n\t\tif (skb_dst(skb))\n\t\t\tneigh = dst_neigh_lookup(skb_dst(skb), &iph6->daddr);\n\n\t\tif (!neigh) {\n\t\t\tnet_dbg_ratelimited(\"nexthop == NULL\\n\");\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\taddr6 = (const struct in6_addr *)&neigh->primary_key;\n\t\taddr_type = ipv6_addr_type(addr6);\n\n\t\tif (addr_type == IPV6_ADDR_ANY) {\n\t\t\taddr6 = &ipv6_hdr(skb)->daddr;\n\t\t\taddr_type = ipv6_addr_type(addr6);\n\t\t}\n\n\t\tif ((addr_type & IPV6_ADDR_COMPATv4) != 0)\n\t\t\tdst = addr6->s6_addr32[3];\n\t\telse\n\t\t\tdo_tx_error = true;\n\n\t\tneigh_release(neigh);\n\t\tif (do_tx_error)\n\t\t\tgoto tx_error;\n\t}\n\n\tflowi4_init_output(&fl4, tunnel->parms.link, tunnel->fwmark,\n\t\t\t   RT_TOS(tos), RT_SCOPE_UNIVERSE, IPPROTO_IPV6,\n\t\t\t   0, dst, tiph->saddr, 0, 0,\n\t\t\t   sock_net_uid(tunnel->net, NULL));\n\n\trt = dst_cache_get_ip4(&tunnel->dst_cache, &fl4.saddr);\n\tif (!rt) {\n\t\trt = ip_route_output_flow(tunnel->net, &fl4, NULL);\n\t\tif (IS_ERR(rt)) {\n\t\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\t\tgoto tx_error_icmp;\n\t\t}\n\t\tdst_cache_set_ip4(&tunnel->dst_cache, &rt->dst, fl4.saddr);\n\t}\n\n\tif (rt->rt_type != RTN_UNICAST && rt->rt_type != RTN_LOCAL) {\n\t\tip_rt_put(rt);\n\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\tgoto tx_error_icmp;\n\t}\n\ttdev = rt->dst.dev;\n\n\tif (tdev == dev) {\n\t\tip_rt_put(rt);\n\t\tDEV_STATS_INC(dev, collisions);\n\t\tgoto tx_error;\n\t}\n\n\tif (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP4)) {\n\t\tip_rt_put(rt);\n\t\tgoto tx_error;\n\t}\n\n\tif (df) {\n\t\tmtu = dst_mtu(&rt->dst) - t_hlen;\n\n\t\tif (mtu < IPV4_MIN_MTU) {\n\t\t\tDEV_STATS_INC(dev, collisions);\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\tif (mtu < IPV6_MIN_MTU) {\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\t\tdf = 0;\n\t\t}\n\n\t\tif (tunnel->parms.iph.daddr)\n\t\t\tskb_dst_update_pmtu_no_confirm(skb, mtu);\n\n\t\tif (skb->len > mtu && !skb_is_gso(skb)) {\n\t\t\ticmpv6_ndo_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\t\tip_rt_put(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\t}\n\n\tif (tunnel->err_count > 0) {\n\t\tif (time_before(jiffies,\n\t\t\t\ttunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\n\t\t\ttunnel->err_count--;\n\t\t\tdst_link_failure(skb);\n\t\t} else\n\t\t\ttunnel->err_count = 0;\n\t}\n\n\t \n\tmax_headroom = LL_RESERVED_SPACE(tdev) + t_hlen;\n\n\tif (skb_headroom(skb) < max_headroom || skb_shared(skb) ||\n\t    (skb_cloned(skb) && !skb_clone_writable(skb, 0))) {\n\t\tstruct sk_buff *new_skb = skb_realloc_headroom(skb, max_headroom);\n\t\tif (!new_skb) {\n\t\t\tip_rt_put(rt);\n\t\t\tDEV_STATS_INC(dev, tx_dropped);\n\t\t\tkfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tif (skb->sk)\n\t\t\tskb_set_owner_w(new_skb, skb->sk);\n\t\tdev_kfree_skb(skb);\n\t\tskb = new_skb;\n\t\tiph6 = ipv6_hdr(skb);\n\t}\n\tttl = tiph->ttl;\n\tif (ttl == 0)\n\t\tttl = iph6->hop_limit;\n\ttos = INET_ECN_encapsulate(tos, ipv6_get_dsfield(iph6));\n\n\tif (ip_tunnel_encap(skb, &tunnel->encap, &protocol, &fl4) < 0) {\n\t\tip_rt_put(rt);\n\t\tgoto tx_error;\n\t}\n\n\tskb_set_inner_ipproto(skb, IPPROTO_IPV6);\n\n\tiptunnel_xmit(NULL, rt, skb, fl4.saddr, fl4.daddr, protocol, tos, ttl,\n\t\t      df, !net_eq(tunnel->net, dev_net(dev)));\n\treturn NETDEV_TX_OK;\n\ntx_error_icmp:\n\tdst_link_failure(skb);\ntx_error:\n\tkfree_skb(skb);\n\tDEV_STATS_INC(dev, tx_errors);\n\treturn NETDEV_TX_OK;\n}\n\nstatic netdev_tx_t sit_tunnel_xmit__(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev, u8 ipproto)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tconst struct iphdr  *tiph = &tunnel->parms.iph;\n\n\tif (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP4))\n\t\tgoto tx_error;\n\n\tskb_set_inner_ipproto(skb, ipproto);\n\n\tip_tunnel_xmit(skb, dev, tiph, ipproto);\n\treturn NETDEV_TX_OK;\ntx_error:\n\tkfree_skb(skb);\n\tDEV_STATS_INC(dev, tx_errors);\n\treturn NETDEV_TX_OK;\n}\n\nstatic netdev_tx_t sit_tunnel_xmit(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev)\n{\n\tif (!pskb_inet_may_pull(skb))\n\t\tgoto tx_err;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tsit_tunnel_xmit__(skb, dev, IPPROTO_IPIP);\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tipip6_tunnel_xmit(skb, dev);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_MPLS)\n\tcase htons(ETH_P_MPLS_UC):\n\t\tsit_tunnel_xmit__(skb, dev, IPPROTO_MPLS);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tgoto tx_err;\n\t}\n\n\treturn NETDEV_TX_OK;\n\ntx_err:\n\tDEV_STATS_INC(dev, tx_errors);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n\n}\n\nstatic void ipip6_tunnel_bind_dev(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tint t_hlen = tunnel->hlen + sizeof(struct iphdr);\n\tstruct net_device *tdev = NULL;\n\tint hlen = LL_MAX_HEADER;\n\tconst struct iphdr *iph;\n\tstruct flowi4 fl4;\n\n\tiph = &tunnel->parms.iph;\n\n\tif (iph->daddr) {\n\t\tstruct rtable *rt = ip_route_output_ports(tunnel->net, &fl4,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  iph->daddr, iph->saddr,\n\t\t\t\t\t\t\t  0, 0,\n\t\t\t\t\t\t\t  IPPROTO_IPV6,\n\t\t\t\t\t\t\t  RT_TOS(iph->tos),\n\t\t\t\t\t\t\t  tunnel->parms.link);\n\n\t\tif (!IS_ERR(rt)) {\n\t\t\ttdev = rt->dst.dev;\n\t\t\tip_rt_put(rt);\n\t\t}\n\t\tdev->flags |= IFF_POINTOPOINT;\n\t}\n\n\tif (!tdev && tunnel->parms.link)\n\t\ttdev = __dev_get_by_index(tunnel->net, tunnel->parms.link);\n\n\tif (tdev && !netif_is_l3_master(tdev)) {\n\t\tint mtu;\n\n\t\tmtu = tdev->mtu - t_hlen;\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\tWRITE_ONCE(dev->mtu, mtu);\n\t\thlen = tdev->hard_header_len + tdev->needed_headroom;\n\t}\n\tdev->needed_headroom = t_hlen + hlen;\n}\n\nstatic void ipip6_tunnel_update(struct ip_tunnel *t, struct ip_tunnel_parm *p,\n\t\t\t\t__u32 fwmark)\n{\n\tstruct net *net = t->net;\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\n\tipip6_tunnel_unlink(sitn, t);\n\tsynchronize_net();\n\tt->parms.iph.saddr = p->iph.saddr;\n\tt->parms.iph.daddr = p->iph.daddr;\n\t__dev_addr_set(t->dev, &p->iph.saddr, 4);\n\tmemcpy(t->dev->broadcast, &p->iph.daddr, 4);\n\tipip6_tunnel_link(sitn, t);\n\tt->parms.iph.ttl = p->iph.ttl;\n\tt->parms.iph.tos = p->iph.tos;\n\tt->parms.iph.frag_off = p->iph.frag_off;\n\tif (t->parms.link != p->link || t->fwmark != fwmark) {\n\t\tt->parms.link = p->link;\n\t\tt->fwmark = fwmark;\n\t\tipip6_tunnel_bind_dev(t->dev);\n\t}\n\tdst_cache_reset(&t->dst_cache);\n\tnetdev_state_change(t->dev);\n}\n\n#ifdef CONFIG_IPV6_SIT_6RD\nstatic int ipip6_tunnel_update_6rd(struct ip_tunnel *t,\n\t\t\t\t   struct ip_tunnel_6rd *ip6rd)\n{\n\tstruct in6_addr prefix;\n\t__be32 relay_prefix;\n\n\tif (ip6rd->relay_prefixlen > 32 ||\n\t    ip6rd->prefixlen + (32 - ip6rd->relay_prefixlen) > 64)\n\t\treturn -EINVAL;\n\n\tipv6_addr_prefix(&prefix, &ip6rd->prefix, ip6rd->prefixlen);\n\tif (!ipv6_addr_equal(&prefix, &ip6rd->prefix))\n\t\treturn -EINVAL;\n\tif (ip6rd->relay_prefixlen)\n\t\trelay_prefix = ip6rd->relay_prefix &\n\t\t\t       htonl(0xffffffffUL <<\n\t\t\t\t     (32 - ip6rd->relay_prefixlen));\n\telse\n\t\trelay_prefix = 0;\n\tif (relay_prefix != ip6rd->relay_prefix)\n\t\treturn -EINVAL;\n\n\tt->ip6rd.prefix = prefix;\n\tt->ip6rd.relay_prefix = relay_prefix;\n\tt->ip6rd.prefixlen = ip6rd->prefixlen;\n\tt->ip6rd.relay_prefixlen = ip6rd->relay_prefixlen;\n\tdst_cache_reset(&t->dst_cache);\n\tnetdev_state_change(t->dev);\n\treturn 0;\n}\n\nstatic int\nipip6_tunnel_get6rd(struct net_device *dev, struct ip_tunnel_parm __user *data)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_6rd ip6rd;\n\tstruct ip_tunnel_parm p;\n\n\tif (dev == dev_to_sit_net(dev)->fb_tunnel_dev) {\n\t\tif (copy_from_user(&p, data, sizeof(p)))\n\t\t\treturn -EFAULT;\n\t\tt = ipip6_tunnel_locate(t->net, &p, 0);\n\t}\n\tif (!t)\n\t\tt = netdev_priv(dev);\n\n\tip6rd.prefix = t->ip6rd.prefix;\n\tip6rd.relay_prefix = t->ip6rd.relay_prefix;\n\tip6rd.prefixlen = t->ip6rd.prefixlen;\n\tip6rd.relay_prefixlen = t->ip6rd.relay_prefixlen;\n\tif (copy_to_user(data, &ip6rd, sizeof(ip6rd)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int\nipip6_tunnel_6rdctl(struct net_device *dev, struct ip_tunnel_6rd __user *data,\n\t\t    int cmd)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_6rd ip6rd;\n\tint err;\n\n\tif (!ns_capable(t->net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&ip6rd, data, sizeof(ip6rd)))\n\t\treturn -EFAULT;\n\n\tif (cmd != SIOCDEL6RD) {\n\t\terr = ipip6_tunnel_update_6rd(t, &ip6rd);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else\n\t\tipip6_tunnel_clone_6rd(dev, dev_to_sit_net(dev));\n\treturn 0;\n}\n\n#endif  \n\nstatic bool ipip6_valid_ip_proto(u8 ipproto)\n{\n\treturn ipproto == IPPROTO_IPV6 ||\n\t\tipproto == IPPROTO_IPIP ||\n#if IS_ENABLED(CONFIG_MPLS)\n\t\tipproto == IPPROTO_MPLS ||\n#endif\n\t\tipproto == 0;\n}\n\nstatic int\n__ipip6_tunnel_ioctl_validate(struct net *net, struct ip_tunnel_parm *p)\n{\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!ipip6_valid_ip_proto(p->iph.protocol))\n\t\treturn -EINVAL;\n\tif (p->iph.version != 4 ||\n\t    p->iph.ihl != 5 || (p->iph.frag_off & htons(~IP_DF)))\n\t\treturn -EINVAL;\n\n\tif (p->iph.ttl)\n\t\tp->iph.frag_off |= htons(IP_DF);\n\treturn 0;\n}\n\nstatic int\nipip6_tunnel_get(struct net_device *dev, struct ip_tunnel_parm *p)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (dev == dev_to_sit_net(dev)->fb_tunnel_dev)\n\t\tt = ipip6_tunnel_locate(t->net, p, 0);\n\tif (!t)\n\t\tt = netdev_priv(dev);\n\tmemcpy(p, &t->parms, sizeof(*p));\n\treturn 0;\n}\n\nstatic int\nipip6_tunnel_add(struct net_device *dev, struct ip_tunnel_parm *p)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tint err;\n\n\terr = __ipip6_tunnel_ioctl_validate(t->net, p);\n\tif (err)\n\t\treturn err;\n\n\tt = ipip6_tunnel_locate(t->net, p, 1);\n\tif (!t)\n\t\treturn -ENOBUFS;\n\treturn 0;\n}\n\nstatic int\nipip6_tunnel_change(struct net_device *dev, struct ip_tunnel_parm *p)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tint err;\n\n\terr = __ipip6_tunnel_ioctl_validate(t->net, p);\n\tif (err)\n\t\treturn err;\n\n\tt = ipip6_tunnel_locate(t->net, p, 0);\n\tif (dev == dev_to_sit_net(dev)->fb_tunnel_dev) {\n\t\tif (!t)\n\t\t\treturn -ENOENT;\n\t} else {\n\t\tif (t) {\n\t\t\tif (t->dev != dev)\n\t\t\t\treturn -EEXIST;\n\t\t} else {\n\t\t\tif (((dev->flags & IFF_POINTOPOINT) && !p->iph.daddr) ||\n\t\t\t    (!(dev->flags & IFF_POINTOPOINT) && p->iph.daddr))\n\t\t\t\treturn -EINVAL;\n\t\t\tt = netdev_priv(dev);\n\t\t}\n\n\t\tipip6_tunnel_update(t, p, t->fwmark);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nipip6_tunnel_del(struct net_device *dev, struct ip_tunnel_parm *p)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\n\tif (!ns_capable(t->net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (dev == dev_to_sit_net(dev)->fb_tunnel_dev) {\n\t\tt = ipip6_tunnel_locate(t->net, p, 0);\n\t\tif (!t)\n\t\t\treturn -ENOENT;\n\t\tif (t == netdev_priv(dev_to_sit_net(dev)->fb_tunnel_dev))\n\t\t\treturn -EPERM;\n\t\tdev = t->dev;\n\t}\n\tunregister_netdevice(dev);\n\treturn 0;\n}\n\nstatic int\nipip6_tunnel_ctl(struct net_device *dev, struct ip_tunnel_parm *p, int cmd)\n{\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n\t\treturn ipip6_tunnel_get(dev, p);\n\tcase SIOCADDTUNNEL:\n\t\treturn ipip6_tunnel_add(dev, p);\n\tcase SIOCCHGTUNNEL:\n\t\treturn ipip6_tunnel_change(dev, p);\n\tcase SIOCDELTUNNEL:\n\t\treturn ipip6_tunnel_del(dev, p);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nipip6_tunnel_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t    void __user *data, int cmd)\n{\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\tcase SIOCDELTUNNEL:\n\t\treturn ip_tunnel_siocdevprivate(dev, ifr, data, cmd);\n\tcase SIOCGETPRL:\n\t\treturn ipip6_tunnel_get_prl(dev, data);\n\tcase SIOCADDPRL:\n\tcase SIOCDELPRL:\n\tcase SIOCCHGPRL:\n\t\treturn ipip6_tunnel_prl_ctl(dev, data, cmd);\n#ifdef CONFIG_IPV6_SIT_6RD\n\tcase SIOCGET6RD:\n\t\treturn ipip6_tunnel_get6rd(dev, data);\n\tcase SIOCADD6RD:\n\tcase SIOCCHG6RD:\n\tcase SIOCDEL6RD:\n\t\treturn ipip6_tunnel_6rdctl(dev, data, cmd);\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct net_device_ops ipip6_netdev_ops = {\n\t.ndo_init\t= ipip6_tunnel_init,\n\t.ndo_uninit\t= ipip6_tunnel_uninit,\n\t.ndo_start_xmit\t= sit_tunnel_xmit,\n\t.ndo_siocdevprivate = ipip6_tunnel_siocdevprivate,\n\t.ndo_get_stats64 = dev_get_tstats64,\n\t.ndo_get_iflink = ip_tunnel_get_iflink,\n\t.ndo_tunnel_ctl = ipip6_tunnel_ctl,\n};\n\nstatic void ipip6_dev_free(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\n\tdst_cache_destroy(&tunnel->dst_cache);\n\tfree_percpu(dev->tstats);\n}\n\n#define SIT_FEATURES (NETIF_F_SG\t   | \\\n\t\t      NETIF_F_FRAGLIST\t   | \\\n\t\t      NETIF_F_HIGHDMA\t   | \\\n\t\t      NETIF_F_GSO_SOFTWARE | \\\n\t\t      NETIF_F_HW_CSUM)\n\nstatic void ipip6_tunnel_setup(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tint t_hlen = tunnel->hlen + sizeof(struct iphdr);\n\n\tdev->netdev_ops\t\t= &ipip6_netdev_ops;\n\tdev->header_ops\t\t= &ip_tunnel_header_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->priv_destructor\t= ipip6_dev_free;\n\n\tdev->type\t\t= ARPHRD_SIT;\n\tdev->mtu\t\t= ETH_DATA_LEN - t_hlen;\n\tdev->min_mtu\t\t= IPV6_MIN_MTU;\n\tdev->max_mtu\t\t= IP6_MAX_MTU - t_hlen;\n\tdev->flags\t\t= IFF_NOARP;\n\tnetif_keep_dst(dev);\n\tdev->addr_len\t\t= 4;\n\tdev->features\t\t|= NETIF_F_LLTX;\n\tdev->features\t\t|= SIT_FEATURES;\n\tdev->hw_features\t|= SIT_FEATURES;\n}\n\nstatic int ipip6_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tint err;\n\n\ttunnel->dev = dev;\n\ttunnel->net = dev_net(dev);\n\tstrcpy(tunnel->parms.name, dev->name);\n\n\tipip6_tunnel_bind_dev(dev);\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\terr = dst_cache_init(&tunnel->dst_cache, GFP_KERNEL);\n\tif (err) {\n\t\tfree_percpu(dev->tstats);\n\t\tdev->tstats = NULL;\n\t\treturn err;\n\t}\n\tnetdev_hold(dev, &tunnel->dev_tracker, GFP_KERNEL);\n\treturn 0;\n}\n\nstatic void __net_init ipip6_fb_tunnel_init(struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct iphdr *iph = &tunnel->parms.iph;\n\tstruct net *net = dev_net(dev);\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\n\tiph->version\t\t= 4;\n\tiph->protocol\t\t= IPPROTO_IPV6;\n\tiph->ihl\t\t= 5;\n\tiph->ttl\t\t= 64;\n\n\trcu_assign_pointer(sitn->tunnels_wc[0], tunnel);\n}\n\nstatic int ipip6_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tu8 proto;\n\n\tif (!data || !data[IFLA_IPTUN_PROTO])\n\t\treturn 0;\n\n\tproto = nla_get_u8(data[IFLA_IPTUN_PROTO]);\n\tif (!ipip6_valid_ip_proto(proto))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void ipip6_netlink_parms(struct nlattr *data[],\n\t\t\t\tstruct ip_tunnel_parm *parms,\n\t\t\t\t__u32 *fwmark)\n{\n\tmemset(parms, 0, sizeof(*parms));\n\n\tparms->iph.version = 4;\n\tparms->iph.protocol = IPPROTO_IPV6;\n\tparms->iph.ihl = 5;\n\tparms->iph.ttl = 64;\n\n\tif (!data)\n\t\treturn;\n\n\tip_tunnel_netlink_parms(data, parms);\n\n\tif (data[IFLA_IPTUN_FWMARK])\n\t\t*fwmark = nla_get_u32(data[IFLA_IPTUN_FWMARK]);\n}\n\n#ifdef CONFIG_IPV6_SIT_6RD\n \nstatic bool ipip6_netlink_6rd_parms(struct nlattr *data[],\n\t\t\t\t    struct ip_tunnel_6rd *ip6rd)\n{\n\tbool ret = false;\n\tmemset(ip6rd, 0, sizeof(*ip6rd));\n\n\tif (!data)\n\t\treturn ret;\n\n\tif (data[IFLA_IPTUN_6RD_PREFIX]) {\n\t\tret = true;\n\t\tip6rd->prefix = nla_get_in6_addr(data[IFLA_IPTUN_6RD_PREFIX]);\n\t}\n\n\tif (data[IFLA_IPTUN_6RD_RELAY_PREFIX]) {\n\t\tret = true;\n\t\tip6rd->relay_prefix =\n\t\t\tnla_get_be32(data[IFLA_IPTUN_6RD_RELAY_PREFIX]);\n\t}\n\n\tif (data[IFLA_IPTUN_6RD_PREFIXLEN]) {\n\t\tret = true;\n\t\tip6rd->prefixlen = nla_get_u16(data[IFLA_IPTUN_6RD_PREFIXLEN]);\n\t}\n\n\tif (data[IFLA_IPTUN_6RD_RELAY_PREFIXLEN]) {\n\t\tret = true;\n\t\tip6rd->relay_prefixlen =\n\t\t\tnla_get_u16(data[IFLA_IPTUN_6RD_RELAY_PREFIXLEN]);\n\t}\n\n\treturn ret;\n}\n#endif\n\nstatic int ipip6_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ip_tunnel *nt;\n\tstruct ip_tunnel_encap ipencap;\n#ifdef CONFIG_IPV6_SIT_6RD\n\tstruct ip_tunnel_6rd ip6rd;\n#endif\n\tint err;\n\n\tnt = netdev_priv(dev);\n\n\tif (ip_tunnel_netlink_encap_parms(data, &ipencap)) {\n\t\terr = ip_tunnel_encap_setup(nt, &ipencap);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tipip6_netlink_parms(data, &nt->parms, &nt->fwmark);\n\n\tif (ipip6_tunnel_locate(net, &nt->parms, 0))\n\t\treturn -EEXIST;\n\n\terr = ipip6_tunnel_create(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[IFLA_MTU]) {\n\t\tu32 mtu = nla_get_u32(tb[IFLA_MTU]);\n\n\t\tif (mtu >= IPV6_MIN_MTU &&\n\t\t    mtu <= IP6_MAX_MTU - dev->hard_header_len)\n\t\t\tdev->mtu = mtu;\n\t}\n\n#ifdef CONFIG_IPV6_SIT_6RD\n\tif (ipip6_netlink_6rd_parms(data, &ip6rd)) {\n\t\terr = ipip6_tunnel_update_6rd(nt, &ip6rd);\n\t\tif (err < 0)\n\t\t\tunregister_netdevice_queue(dev, NULL);\n\t}\n#endif\n\n\treturn err;\n}\n\nstatic int ipip6_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t    struct nlattr *data[],\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ip_tunnel *t = netdev_priv(dev);\n\tstruct ip_tunnel_parm p;\n\tstruct ip_tunnel_encap ipencap;\n\tstruct net *net = t->net;\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n#ifdef CONFIG_IPV6_SIT_6RD\n\tstruct ip_tunnel_6rd ip6rd;\n#endif\n\t__u32 fwmark = t->fwmark;\n\tint err;\n\n\tif (dev == sitn->fb_tunnel_dev)\n\t\treturn -EINVAL;\n\n\tif (ip_tunnel_netlink_encap_parms(data, &ipencap)) {\n\t\terr = ip_tunnel_encap_setup(t, &ipencap);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tipip6_netlink_parms(data, &p, &fwmark);\n\n\tif (((dev->flags & IFF_POINTOPOINT) && !p.iph.daddr) ||\n\t    (!(dev->flags & IFF_POINTOPOINT) && p.iph.daddr))\n\t\treturn -EINVAL;\n\n\tt = ipip6_tunnel_locate(net, &p, 0);\n\n\tif (t) {\n\t\tif (t->dev != dev)\n\t\t\treturn -EEXIST;\n\t} else\n\t\tt = netdev_priv(dev);\n\n\tipip6_tunnel_update(t, &p, fwmark);\n\n#ifdef CONFIG_IPV6_SIT_6RD\n\tif (ipip6_netlink_6rd_parms(data, &ip6rd))\n\t\treturn ipip6_tunnel_update_6rd(t, &ip6rd);\n#endif\n\n\treturn 0;\n}\n\nstatic size_t ipip6_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(1) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(1) +\n#ifdef CONFIG_IPV6_SIT_6RD\n\t\t \n\t\tnla_total_size(sizeof(struct in6_addr)) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n#endif\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t0;\n}\n\nstatic int ipip6_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct ip_tunnel_parm *parm = &tunnel->parms;\n\n\tif (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||\n\t    nla_put_in_addr(skb, IFLA_IPTUN_LOCAL, parm->iph.saddr) ||\n\t    nla_put_in_addr(skb, IFLA_IPTUN_REMOTE, parm->iph.daddr) ||\n\t    nla_put_u8(skb, IFLA_IPTUN_TTL, parm->iph.ttl) ||\n\t    nla_put_u8(skb, IFLA_IPTUN_TOS, parm->iph.tos) ||\n\t    nla_put_u8(skb, IFLA_IPTUN_PMTUDISC,\n\t\t       !!(parm->iph.frag_off & htons(IP_DF))) ||\n\t    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->iph.protocol) ||\n\t    nla_put_be16(skb, IFLA_IPTUN_FLAGS, parm->i_flags) ||\n\t    nla_put_u32(skb, IFLA_IPTUN_FWMARK, tunnel->fwmark))\n\t\tgoto nla_put_failure;\n\n#ifdef CONFIG_IPV6_SIT_6RD\n\tif (nla_put_in6_addr(skb, IFLA_IPTUN_6RD_PREFIX,\n\t\t\t     &tunnel->ip6rd.prefix) ||\n\t    nla_put_in_addr(skb, IFLA_IPTUN_6RD_RELAY_PREFIX,\n\t\t\t    tunnel->ip6rd.relay_prefix) ||\n\t    nla_put_u16(skb, IFLA_IPTUN_6RD_PREFIXLEN,\n\t\t\ttunnel->ip6rd.prefixlen) ||\n\t    nla_put_u16(skb, IFLA_IPTUN_6RD_RELAY_PREFIXLEN,\n\t\t\ttunnel->ip6rd.relay_prefixlen))\n\t\tgoto nla_put_failure;\n#endif\n\n\tif (nla_put_u16(skb, IFLA_IPTUN_ENCAP_TYPE,\n\t\t\ttunnel->encap.type) ||\n\t    nla_put_be16(skb, IFLA_IPTUN_ENCAP_SPORT,\n\t\t\ttunnel->encap.sport) ||\n\t    nla_put_be16(skb, IFLA_IPTUN_ENCAP_DPORT,\n\t\t\ttunnel->encap.dport) ||\n\t    nla_put_u16(skb, IFLA_IPTUN_ENCAP_FLAGS,\n\t\t\ttunnel->encap.flags))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy ipip6_policy[IFLA_IPTUN_MAX + 1] = {\n\t[IFLA_IPTUN_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_IPTUN_LOCAL]\t\t= { .type = NLA_U32 },\n\t[IFLA_IPTUN_REMOTE]\t\t= { .type = NLA_U32 },\n\t[IFLA_IPTUN_TTL]\t\t= { .type = NLA_U8 },\n\t[IFLA_IPTUN_TOS]\t\t= { .type = NLA_U8 },\n\t[IFLA_IPTUN_PMTUDISC]\t\t= { .type = NLA_U8 },\n\t[IFLA_IPTUN_FLAGS]\t\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_PROTO]\t\t= { .type = NLA_U8 },\n#ifdef CONFIG_IPV6_SIT_6RD\n\t[IFLA_IPTUN_6RD_PREFIX]\t\t= { .len = sizeof(struct in6_addr) },\n\t[IFLA_IPTUN_6RD_RELAY_PREFIX]\t= { .type = NLA_U32 },\n\t[IFLA_IPTUN_6RD_PREFIXLEN]\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_6RD_RELAY_PREFIXLEN] = { .type = NLA_U16 },\n#endif\n\t[IFLA_IPTUN_ENCAP_TYPE]\t\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_ENCAP_FLAGS]\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_ENCAP_SPORT]\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_ENCAP_DPORT]\t= { .type = NLA_U16 },\n\t[IFLA_IPTUN_FWMARK]\t\t= { .type = NLA_U32 },\n};\n\nstatic void ipip6_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\n\tif (dev != sitn->fb_tunnel_dev)\n\t\tunregister_netdevice_queue(dev, head);\n}\n\nstatic struct rtnl_link_ops sit_link_ops __read_mostly = {\n\t.kind\t\t= \"sit\",\n\t.maxtype\t= IFLA_IPTUN_MAX,\n\t.policy\t\t= ipip6_policy,\n\t.priv_size\t= sizeof(struct ip_tunnel),\n\t.setup\t\t= ipip6_tunnel_setup,\n\t.validate\t= ipip6_validate,\n\t.newlink\t= ipip6_newlink,\n\t.changelink\t= ipip6_changelink,\n\t.get_size\t= ipip6_get_size,\n\t.fill_info\t= ipip6_fill_info,\n\t.dellink\t= ipip6_dellink,\n\t.get_link_net\t= ip_tunnel_get_link_net,\n};\n\nstatic struct xfrm_tunnel sit_handler __read_mostly = {\n\t.handler\t=\tipip6_rcv,\n\t.err_handler\t=\tipip6_err,\n\t.priority\t=\t1,\n};\n\nstatic struct xfrm_tunnel ipip_handler __read_mostly = {\n\t.handler\t=\tipip_rcv,\n\t.err_handler\t=\tipip6_err,\n\t.priority\t=\t2,\n};\n\n#if IS_ENABLED(CONFIG_MPLS)\nstatic struct xfrm_tunnel mplsip_handler __read_mostly = {\n\t.handler\t=\tmplsip_rcv,\n\t.err_handler\t=\tipip6_err,\n\t.priority\t=\t2,\n};\n#endif\n\nstatic void __net_exit sit_destroy_tunnels(struct net *net,\n\t\t\t\t\t   struct list_head *head)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tstruct net_device *dev, *aux;\n\tint prio;\n\n\tfor_each_netdev_safe(net, dev, aux)\n\t\tif (dev->rtnl_link_ops == &sit_link_ops)\n\t\t\tunregister_netdevice_queue(dev, head);\n\n\tfor (prio = 0; prio < 4; prio++) {\n\t\tint h;\n\t\tfor (h = 0; h < (prio ? IP6_SIT_HASH_SIZE : 1); h++) {\n\t\t\tstruct ip_tunnel *t;\n\n\t\t\tt = rtnl_dereference(sitn->tunnels[prio][h]);\n\t\t\twhile (t) {\n\t\t\t\t \n\t\t\t\tif (!net_eq(dev_net(t->dev), net))\n\t\t\t\t\tunregister_netdevice_queue(t->dev,\n\t\t\t\t\t\t\t\t   head);\n\t\t\t\tt = rtnl_dereference(t->next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __net_init sit_init_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tstruct ip_tunnel *t;\n\tint err;\n\n\tsitn->tunnels[0] = sitn->tunnels_wc;\n\tsitn->tunnels[1] = sitn->tunnels_l;\n\tsitn->tunnels[2] = sitn->tunnels_r;\n\tsitn->tunnels[3] = sitn->tunnels_r_l;\n\n\tif (!net_has_fallback_tunnels(net))\n\t\treturn 0;\n\n\tsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"sit0\",\n\t\t\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t\t\t   ipip6_tunnel_setup);\n\tif (!sitn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(sitn->fb_tunnel_dev, net);\n\tsitn->fb_tunnel_dev->rtnl_link_ops = &sit_link_ops;\n\t \n\tsitn->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;\n\n\terr = register_netdev(sitn->fb_tunnel_dev);\n\tif (err)\n\t\tgoto err_reg_dev;\n\n\tipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);\n\tipip6_fb_tunnel_init(sitn->fb_tunnel_dev);\n\n\tt = netdev_priv(sitn->fb_tunnel_dev);\n\n\tstrcpy(t->parms.name, sitn->fb_tunnel_dev->name);\n\treturn 0;\n\nerr_reg_dev:\n\tfree_netdev(sitn->fb_tunnel_dev);\nerr_alloc_dev:\n\treturn err;\n}\n\nstatic void __net_exit sit_exit_batch_net(struct list_head *net_list)\n{\n\tLIST_HEAD(list);\n\tstruct net *net;\n\n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list)\n\t\tsit_destroy_tunnels(net, &list);\n\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations sit_net_ops = {\n\t.init = sit_init_net,\n\t.exit_batch = sit_exit_batch_net,\n\t.id   = &sit_net_id,\n\t.size = sizeof(struct sit_net),\n};\n\nstatic void __exit sit_cleanup(void)\n{\n\trtnl_link_unregister(&sit_link_ops);\n\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n#if IS_ENABLED(CONFIG_MPLS)\n\txfrm4_tunnel_deregister(&mplsip_handler, AF_MPLS);\n#endif\n\n\tunregister_pernet_device(&sit_net_ops);\n\trcu_barrier();  \n}\n\nstatic int __init sit_init(void)\n{\n\tint err;\n\n\tpr_info(\"IPv6, IPv4 and MPLS over IPv4 tunneling driver\\n\");\n\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\terr = xfrm4_tunnel_register(&sit_handler, AF_INET6);\n\tif (err < 0) {\n\t\tpr_info(\"%s: can't register ip6ip4\\n\", __func__);\n\t\tgoto xfrm_tunnel_failed;\n\t}\n\terr = xfrm4_tunnel_register(&ipip_handler, AF_INET);\n\tif (err < 0) {\n\t\tpr_info(\"%s: can't register ip4ip4\\n\", __func__);\n\t\tgoto xfrm_tunnel4_failed;\n\t}\n#if IS_ENABLED(CONFIG_MPLS)\n\terr = xfrm4_tunnel_register(&mplsip_handler, AF_MPLS);\n\tif (err < 0) {\n\t\tpr_info(\"%s: can't register mplsip\\n\", __func__);\n\t\tgoto xfrm_tunnel_mpls_failed;\n\t}\n#endif\n\terr = rtnl_link_register(&sit_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\nout:\n\treturn err;\n\nrtnl_link_failed:\n#if IS_ENABLED(CONFIG_MPLS)\n\txfrm4_tunnel_deregister(&mplsip_handler, AF_MPLS);\nxfrm_tunnel_mpls_failed:\n#endif\n\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\nxfrm_tunnel4_failed:\n\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\nxfrm_tunnel_failed:\n\tunregister_pernet_device(&sit_net_ops);\n\tgoto out;\n}\n\nmodule_init(sit_init);\nmodule_exit(sit_cleanup);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(\"sit\");\nMODULE_ALIAS_NETDEV(\"sit0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}