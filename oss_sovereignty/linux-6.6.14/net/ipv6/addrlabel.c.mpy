{
  "module_name": "addrlabel.c",
  "hash_id": "5cc386e48ba7e28e4a97242f91dfdaa69f9840d000cbe58a3347d96c2b789529",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/addrlabel.c",
  "human_readable_source": "\n \n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/in6.h>\n#include <linux/slab.h>\n#include <net/addrconf.h>\n#include <linux/if_addrlabel.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n\n#if 0\n#define ADDRLABEL(x...) printk(x)\n#else\n#define ADDRLABEL(x...) do { ; } while (0)\n#endif\n\n \nstruct ip6addrlbl_entry {\n\tstruct in6_addr prefix;\n\tint prefixlen;\n\tint ifindex;\n\tint addrtype;\n\tu32 label;\n\tstruct hlist_node list;\n\tstruct rcu_head rcu;\n};\n\n \n\n#define IPV6_ADDR_LABEL_DEFAULT\t0xffffffffUL\n\nstatic const __net_initconst struct ip6addrlbl_init_table\n{\n\tconst struct in6_addr *prefix;\n\tint prefixlen;\n\tu32 label;\n} ip6addrlbl_init_table[] = {\n\t{\t \n\t\t.prefix = &in6addr_any,\n\t\t.label = 1,\n\t}, {\t \n\t\t.prefix = &(struct in6_addr){ { { 0xfc } } } ,\n\t\t.prefixlen = 7,\n\t\t.label = 5,\n\t}, {\t \n\t\t.prefix = &(struct in6_addr){ { { 0xfe, 0xc0 } } },\n\t\t.prefixlen = 10,\n\t\t.label = 11,\n\t}, {\t \n\t\t.prefix = &(struct in6_addr){ { { 0x20, 0x02 } } },\n\t\t.prefixlen = 16,\n\t\t.label = 2,\n\t}, {\t \n\t\t.prefix = &(struct in6_addr){ { { 0x3f, 0xfe } } },\n\t\t.prefixlen = 16,\n\t\t.label = 12,\n\t}, {\t \n\t\t.prefix = &(struct in6_addr){ { { 0x20, 0x01 } } },\n\t\t.prefixlen = 32,\n\t\t.label = 6,\n\t}, {\t \n\t\t.prefix = &(struct in6_addr){ { { 0x20, 0x01, 0x00, 0x10 } } },\n\t\t.prefixlen = 28,\n\t\t.label = 7,\n\t}, {\t \n\t\t.prefix = &(struct in6_addr){ { { [10] = 0xff, [11] = 0xff } } },\n\t\t.prefixlen = 96,\n\t\t.label = 4,\n\t}, {\t \n\t\t.prefix = &in6addr_any,\n\t\t.prefixlen = 96,\n\t\t.label = 3,\n\t}, {\t \n\t\t.prefix = &in6addr_loopback,\n\t\t.prefixlen = 128,\n\t\t.label = 0,\n\t}\n};\n\n \nstatic bool __ip6addrlbl_match(const struct ip6addrlbl_entry *p,\n\t\t\t       const struct in6_addr *addr,\n\t\t\t       int addrtype, int ifindex)\n{\n\tif (p->ifindex && p->ifindex != ifindex)\n\t\treturn false;\n\tif (p->addrtype && p->addrtype != addrtype)\n\t\treturn false;\n\tif (!ipv6_prefix_equal(addr, &p->prefix, p->prefixlen))\n\t\treturn false;\n\treturn true;\n}\n\nstatic struct ip6addrlbl_entry *__ipv6_addr_label(struct net *net,\n\t\t\t\t\t\t  const struct in6_addr *addr,\n\t\t\t\t\t\t  int type, int ifindex)\n{\n\tstruct ip6addrlbl_entry *p;\n\n\thlist_for_each_entry_rcu(p, &net->ipv6.ip6addrlbl_table.head, list) {\n\t\tif (__ip6addrlbl_match(p, addr, type, ifindex))\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\nu32 ipv6_addr_label(struct net *net,\n\t\t    const struct in6_addr *addr, int type, int ifindex)\n{\n\tu32 label;\n\tstruct ip6addrlbl_entry *p;\n\n\ttype &= IPV6_ADDR_MAPPED | IPV6_ADDR_COMPATv4 | IPV6_ADDR_LOOPBACK;\n\n\trcu_read_lock();\n\tp = __ipv6_addr_label(net, addr, type, ifindex);\n\tlabel = p ? p->label : IPV6_ADDR_LABEL_DEFAULT;\n\trcu_read_unlock();\n\n\tADDRLABEL(KERN_DEBUG \"%s(addr=%pI6, type=%d, ifindex=%d) => %08x\\n\",\n\t\t  __func__, addr, type, ifindex, label);\n\n\treturn label;\n}\n\n \nstatic struct ip6addrlbl_entry *ip6addrlbl_alloc(const struct in6_addr *prefix,\n\t\t\t\t\t\t int prefixlen, int ifindex,\n\t\t\t\t\t\t u32 label)\n{\n\tstruct ip6addrlbl_entry *newp;\n\tint addrtype;\n\n\tADDRLABEL(KERN_DEBUG \"%s(prefix=%pI6, prefixlen=%d, ifindex=%d, label=%u)\\n\",\n\t\t  __func__, prefix, prefixlen, ifindex, (unsigned int)label);\n\n\taddrtype = ipv6_addr_type(prefix) & (IPV6_ADDR_MAPPED | IPV6_ADDR_COMPATv4 | IPV6_ADDR_LOOPBACK);\n\n\tswitch (addrtype) {\n\tcase IPV6_ADDR_MAPPED:\n\t\tif (prefixlen > 96)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tif (prefixlen < 96)\n\t\t\taddrtype = 0;\n\t\tbreak;\n\tcase IPV6_ADDR_COMPATv4:\n\t\tif (prefixlen != 96)\n\t\t\taddrtype = 0;\n\t\tbreak;\n\tcase IPV6_ADDR_LOOPBACK:\n\t\tif (prefixlen != 128)\n\t\t\taddrtype = 0;\n\t\tbreak;\n\t}\n\n\tnewp = kmalloc(sizeof(*newp), GFP_KERNEL);\n\tif (!newp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tipv6_addr_prefix(&newp->prefix, prefix, prefixlen);\n\tnewp->prefixlen = prefixlen;\n\tnewp->ifindex = ifindex;\n\tnewp->addrtype = addrtype;\n\tnewp->label = label;\n\tINIT_HLIST_NODE(&newp->list);\n\treturn newp;\n}\n\n \nstatic int __ip6addrlbl_add(struct net *net, struct ip6addrlbl_entry *newp,\n\t\t\t    int replace)\n{\n\tstruct ip6addrlbl_entry *last = NULL, *p = NULL;\n\tstruct hlist_node *n;\n\tint ret = 0;\n\n\tADDRLABEL(KERN_DEBUG \"%s(newp=%p, replace=%d)\\n\", __func__, newp,\n\t\t  replace);\n\n\thlist_for_each_entry_safe(p, n,\t&net->ipv6.ip6addrlbl_table.head, list) {\n\t\tif (p->prefixlen == newp->prefixlen &&\n\t\t    p->ifindex == newp->ifindex &&\n\t\t    ipv6_addr_equal(&p->prefix, &newp->prefix)) {\n\t\t\tif (!replace) {\n\t\t\t\tret = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thlist_replace_rcu(&p->list, &newp->list);\n\t\t\tkfree_rcu(p, rcu);\n\t\t\tgoto out;\n\t\t} else if ((p->prefixlen == newp->prefixlen && !p->ifindex) ||\n\t\t\t   (p->prefixlen < newp->prefixlen)) {\n\t\t\thlist_add_before_rcu(&newp->list, &p->list);\n\t\t\tgoto out;\n\t\t}\n\t\tlast = p;\n\t}\n\tif (last)\n\t\thlist_add_behind_rcu(&newp->list, &last->list);\n\telse\n\t\thlist_add_head_rcu(&newp->list, &net->ipv6.ip6addrlbl_table.head);\nout:\n\tif (!ret)\n\t\tnet->ipv6.ip6addrlbl_table.seq++;\n\treturn ret;\n}\n\n \nstatic int ip6addrlbl_add(struct net *net,\n\t\t\t  const struct in6_addr *prefix, int prefixlen,\n\t\t\t  int ifindex, u32 label, int replace)\n{\n\tstruct ip6addrlbl_entry *newp;\n\tint ret = 0;\n\n\tADDRLABEL(KERN_DEBUG \"%s(prefix=%pI6, prefixlen=%d, ifindex=%d, label=%u, replace=%d)\\n\",\n\t\t  __func__, prefix, prefixlen, ifindex, (unsigned int)label,\n\t\t  replace);\n\n\tnewp = ip6addrlbl_alloc(prefix, prefixlen, ifindex, label);\n\tif (IS_ERR(newp))\n\t\treturn PTR_ERR(newp);\n\tspin_lock(&net->ipv6.ip6addrlbl_table.lock);\n\tret = __ip6addrlbl_add(net, newp, replace);\n\tspin_unlock(&net->ipv6.ip6addrlbl_table.lock);\n\tif (ret)\n\t\tkfree(newp);\n\treturn ret;\n}\n\n \nstatic int __ip6addrlbl_del(struct net *net,\n\t\t\t    const struct in6_addr *prefix, int prefixlen,\n\t\t\t    int ifindex)\n{\n\tstruct ip6addrlbl_entry *p = NULL;\n\tstruct hlist_node *n;\n\tint ret = -ESRCH;\n\n\tADDRLABEL(KERN_DEBUG \"%s(prefix=%pI6, prefixlen=%d, ifindex=%d)\\n\",\n\t\t  __func__, prefix, prefixlen, ifindex);\n\n\thlist_for_each_entry_safe(p, n, &net->ipv6.ip6addrlbl_table.head, list) {\n\t\tif (p->prefixlen == prefixlen &&\n\t\t    p->ifindex == ifindex &&\n\t\t    ipv6_addr_equal(&p->prefix, prefix)) {\n\t\t\thlist_del_rcu(&p->list);\n\t\t\tkfree_rcu(p, rcu);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int ip6addrlbl_del(struct net *net,\n\t\t\t  const struct in6_addr *prefix, int prefixlen,\n\t\t\t  int ifindex)\n{\n\tstruct in6_addr prefix_buf;\n\tint ret;\n\n\tADDRLABEL(KERN_DEBUG \"%s(prefix=%pI6, prefixlen=%d, ifindex=%d)\\n\",\n\t\t  __func__, prefix, prefixlen, ifindex);\n\n\tipv6_addr_prefix(&prefix_buf, prefix, prefixlen);\n\tspin_lock(&net->ipv6.ip6addrlbl_table.lock);\n\tret = __ip6addrlbl_del(net, &prefix_buf, prefixlen, ifindex);\n\tspin_unlock(&net->ipv6.ip6addrlbl_table.lock);\n\treturn ret;\n}\n\n \nstatic int __net_init ip6addrlbl_net_init(struct net *net)\n{\n\tstruct ip6addrlbl_entry *p = NULL;\n\tstruct hlist_node *n;\n\tint err;\n\tint i;\n\n\tADDRLABEL(KERN_DEBUG \"%s\\n\", __func__);\n\n\tspin_lock_init(&net->ipv6.ip6addrlbl_table.lock);\n\tINIT_HLIST_HEAD(&net->ipv6.ip6addrlbl_table.head);\n\n\tfor (i = 0; i < ARRAY_SIZE(ip6addrlbl_init_table); i++) {\n\t\terr = ip6addrlbl_add(net,\n\t\t\t\t     ip6addrlbl_init_table[i].prefix,\n\t\t\t\t     ip6addrlbl_init_table[i].prefixlen,\n\t\t\t\t     0,\n\t\t\t\t     ip6addrlbl_init_table[i].label, 0);\n\t\tif (err)\n\t\t\tgoto err_ip6addrlbl_add;\n\t}\n\treturn 0;\n\nerr_ip6addrlbl_add:\n\thlist_for_each_entry_safe(p, n, &net->ipv6.ip6addrlbl_table.head, list) {\n\t\thlist_del_rcu(&p->list);\n\t\tkfree_rcu(p, rcu);\n\t}\n\treturn err;\n}\n\nstatic void __net_exit ip6addrlbl_net_exit(struct net *net)\n{\n\tstruct ip6addrlbl_entry *p = NULL;\n\tstruct hlist_node *n;\n\n\t \n\tspin_lock(&net->ipv6.ip6addrlbl_table.lock);\n\thlist_for_each_entry_safe(p, n, &net->ipv6.ip6addrlbl_table.head, list) {\n\t\thlist_del_rcu(&p->list);\n\t\tkfree_rcu(p, rcu);\n\t}\n\tspin_unlock(&net->ipv6.ip6addrlbl_table.lock);\n}\n\nstatic struct pernet_operations ipv6_addr_label_ops = {\n\t.init = ip6addrlbl_net_init,\n\t.exit = ip6addrlbl_net_exit,\n};\n\nint __init ipv6_addr_label_init(void)\n{\n\treturn register_pernet_subsys(&ipv6_addr_label_ops);\n}\n\nvoid ipv6_addr_label_cleanup(void)\n{\n\tunregister_pernet_subsys(&ipv6_addr_label_ops);\n}\n\nstatic const struct nla_policy ifal_policy[IFAL_MAX+1] = {\n\t[IFAL_ADDRESS]\t\t= { .len = sizeof(struct in6_addr), },\n\t[IFAL_LABEL]\t\t= { .len = sizeof(u32), },\n};\n\nstatic bool addrlbl_ifindex_exists(struct net *net, int ifindex)\n{\n\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tdev = dev_get_by_index_rcu(net, ifindex);\n\trcu_read_unlock();\n\n\treturn dev != NULL;\n}\n\nstatic int ip6addrlbl_newdel(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifaddrlblmsg *ifal;\n\tstruct nlattr *tb[IFAL_MAX+1];\n\tstruct in6_addr *pfx;\n\tu32 label;\n\tint err = 0;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*ifal), tb, IFAL_MAX,\n\t\t\t\t     ifal_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tifal = nlmsg_data(nlh);\n\n\tif (ifal->ifal_family != AF_INET6 ||\n\t    ifal->ifal_prefixlen > 128)\n\t\treturn -EINVAL;\n\n\tif (!tb[IFAL_ADDRESS])\n\t\treturn -EINVAL;\n\tpfx = nla_data(tb[IFAL_ADDRESS]);\n\n\tif (!tb[IFAL_LABEL])\n\t\treturn -EINVAL;\n\tlabel = nla_get_u32(tb[IFAL_LABEL]);\n\tif (label == IPV6_ADDR_LABEL_DEFAULT)\n\t\treturn -EINVAL;\n\n\tswitch (nlh->nlmsg_type) {\n\tcase RTM_NEWADDRLABEL:\n\t\tif (ifal->ifal_index &&\n\t\t    !addrlbl_ifindex_exists(net, ifal->ifal_index))\n\t\t\treturn -EINVAL;\n\n\t\terr = ip6addrlbl_add(net, pfx, ifal->ifal_prefixlen,\n\t\t\t\t     ifal->ifal_index, label,\n\t\t\t\t     nlh->nlmsg_flags & NLM_F_REPLACE);\n\t\tbreak;\n\tcase RTM_DELADDRLABEL:\n\t\terr = ip6addrlbl_del(net, pfx, ifal->ifal_prefixlen,\n\t\t\t\t     ifal->ifal_index);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t}\n\treturn err;\n}\n\nstatic void ip6addrlbl_putmsg(struct nlmsghdr *nlh,\n\t\t\t      int prefixlen, int ifindex, u32 lseq)\n{\n\tstruct ifaddrlblmsg *ifal = nlmsg_data(nlh);\n\tifal->ifal_family = AF_INET6;\n\tifal->__ifal_reserved = 0;\n\tifal->ifal_prefixlen = prefixlen;\n\tifal->ifal_flags = 0;\n\tifal->ifal_index = ifindex;\n\tifal->ifal_seq = lseq;\n};\n\nstatic int ip6addrlbl_fill(struct sk_buff *skb,\n\t\t\t   struct ip6addrlbl_entry *p,\n\t\t\t   u32 lseq,\n\t\t\t   u32 portid, u32 seq, int event,\n\t\t\t   unsigned int flags)\n{\n\tstruct nlmsghdr *nlh = nlmsg_put(skb, portid, seq, event,\n\t\t\t\t\t sizeof(struct ifaddrlblmsg), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tip6addrlbl_putmsg(nlh, p->prefixlen, p->ifindex, lseq);\n\n\tif (nla_put_in6_addr(skb, IFAL_ADDRESS, &p->prefix) < 0 ||\n\t    nla_put_u32(skb, IFAL_LABEL, p->label) < 0) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int ip6addrlbl_valid_dump_req(const struct nlmsghdr *nlh,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ifaddrlblmsg *ifal;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifal))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid header for address label dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tifal = nlmsg_data(nlh);\n\tif (ifal->__ifal_reserved || ifal->ifal_prefixlen ||\n\t    ifal->ifal_flags || ifal->ifal_index || ifal->ifal_seq) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid values in header for address label dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nlmsg_attrlen(nlh, sizeof(*ifal))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid data after header for address label dump request\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ip6addrlbl_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ip6addrlbl_entry *p;\n\tint idx = 0, s_idx = cb->args[0];\n\tint err;\n\n\tif (cb->strict_check) {\n\t\terr = ip6addrlbl_valid_dump_req(nlh, cb->extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(p, &net->ipv6.ip6addrlbl_table.head, list) {\n\t\tif (idx >= s_idx) {\n\t\t\terr = ip6addrlbl_fill(skb, p,\n\t\t\t\t\t      net->ipv6.ip6addrlbl_table.seq,\n\t\t\t\t\t      NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t      nlh->nlmsg_seq,\n\t\t\t\t\t      RTM_NEWADDRLABEL,\n\t\t\t\t\t      NLM_F_MULTI);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tidx++;\n\t}\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic inline int ip6addrlbl_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ifaddrlblmsg))\n\t\t+ nla_total_size(16)\t \n\t\t+ nla_total_size(4);\t \n}\n\nstatic int ip6addrlbl_valid_get_req(struct sk_buff *skb,\n\t\t\t\t    const struct nlmsghdr *nlh,\n\t\t\t\t    struct nlattr **tb,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ifaddrlblmsg *ifal;\n\tint i, err;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*ifal))) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid header for addrlabel get request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(*ifal), tb,\n\t\t\t\t\t      IFAL_MAX, ifal_policy, extack);\n\n\tifal = nlmsg_data(nlh);\n\tif (ifal->__ifal_reserved || ifal->ifal_flags || ifal->ifal_seq) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid values in header for addrlabel get request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*ifal), tb, IFAL_MAX,\n\t\t\t\t\t    ifal_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i <= IFAL_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase IFAL_ADDRESS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported attribute in addrlabel get request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ip6addrlbl_get(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct ifaddrlblmsg *ifal;\n\tstruct nlattr *tb[IFAL_MAX+1];\n\tstruct in6_addr *addr;\n\tu32 lseq;\n\tint err = 0;\n\tstruct ip6addrlbl_entry *p;\n\tstruct sk_buff *skb;\n\n\terr = ip6addrlbl_valid_get_req(in_skb, nlh, tb, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tifal = nlmsg_data(nlh);\n\n\tif (ifal->ifal_family != AF_INET6 ||\n\t    ifal->ifal_prefixlen != 128)\n\t\treturn -EINVAL;\n\n\tif (ifal->ifal_index &&\n\t    !addrlbl_ifindex_exists(net, ifal->ifal_index))\n\t\treturn -EINVAL;\n\n\tif (!tb[IFAL_ADDRESS])\n\t\treturn -EINVAL;\n\taddr = nla_data(tb[IFAL_ADDRESS]);\n\n\tskb = nlmsg_new(ip6addrlbl_msgsize(), GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\n\terr = -ESRCH;\n\n\trcu_read_lock();\n\tp = __ipv6_addr_label(net, addr, ipv6_addr_type(addr), ifal->ifal_index);\n\tlseq = net->ipv6.ip6addrlbl_table.seq;\n\tif (p)\n\t\terr = ip6addrlbl_fill(skb, p, lseq,\n\t\t\t\t      NETLINK_CB(in_skb).portid,\n\t\t\t\t      nlh->nlmsg_seq,\n\t\t\t\t      RTM_NEWADDRLABEL, 0);\n\trcu_read_unlock();\n\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t} else {\n\t\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\n\t}\n\treturn err;\n}\n\nint __init ipv6_addr_label_rtnl_register(void)\n{\n\tint ret;\n\n\tret = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_NEWADDRLABEL,\n\t\t\t\t   ip6addrlbl_newdel,\n\t\t\t\t   NULL, RTNL_FLAG_DOIT_UNLOCKED);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_DELADDRLABEL,\n\t\t\t\t   ip6addrlbl_newdel,\n\t\t\t\t   NULL, RTNL_FLAG_DOIT_UNLOCKED);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_GETADDRLABEL,\n\t\t\t\t   ip6addrlbl_get,\n\t\t\t\t   ip6addrlbl_dump, RTNL_FLAG_DOIT_UNLOCKED);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}