{
  "module_name": "ip6_offload.c",
  "hash_id": "4b0208f75befae37fdfd95e4e920415e683015a065414b68c8c8fbc75346f08e",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ip6_offload.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/printk.h>\n\n#include <net/protocol.h>\n#include <net/ipv6.h>\n#include <net/inet_common.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/gro.h>\n#include <net/gso.h>\n\n#include \"ip6_offload.h\"\n\n \n#if IS_BUILTIN(CONFIG_IPV6)\n#define INDIRECT_CALL_L4(f, f2, f1, ...) INDIRECT_CALL_2(f, f2, f1, __VA_ARGS__)\n#else\n#define INDIRECT_CALL_L4(f, f2, f1, ...) INDIRECT_CALL_1(f, f2, __VA_ARGS__)\n#endif\n\n#define indirect_call_gro_receive_l4(f2, f1, cb, head, skb)\t\\\n({\t\t\t\t\t\t\t\t\\\n\tunlikely(gro_recursion_inc_test(skb)) ?\t\t\t\\\n\t\tNAPI_GRO_CB(skb)->flush |= 1, NULL :\t\t\\\n\t\tINDIRECT_CALL_L4(cb, f2, f1, head, skb);\t\\\n})\n\nstatic int ipv6_gso_pull_exthdrs(struct sk_buff *skb, int proto)\n{\n\tconst struct net_offload *ops = NULL;\n\n\tfor (;;) {\n\t\tstruct ipv6_opt_hdr *opth;\n\t\tint len;\n\n\t\tif (proto != NEXTHDR_HOP) {\n\t\t\tops = rcu_dereference(inet6_offloads[proto]);\n\n\t\t\tif (unlikely(!ops))\n\t\t\t\tbreak;\n\n\t\t\tif (!(ops->flags & INET6_PROTO_GSO_EXTHDR))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (unlikely(!pskb_may_pull(skb, 8)))\n\t\t\tbreak;\n\n\t\topth = (void *)skb->data;\n\t\tlen = ipv6_optlen(opth);\n\n\t\tif (unlikely(!pskb_may_pull(skb, len)))\n\t\t\tbreak;\n\n\t\topth = (void *)skb->data;\n\t\tproto = opth->nexthdr;\n\t\t__skb_pull(skb, len);\n\t}\n\n\treturn proto;\n}\n\nstatic struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,\n\tnetdev_features_t features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct ipv6hdr *ipv6h;\n\tconst struct net_offload *ops;\n\tint proto, err;\n\tstruct frag_hdr *fptr;\n\tunsigned int payload_len;\n\tu8 *prevhdr;\n\tint offset = 0;\n\tbool encap, udpfrag;\n\tint nhoff;\n\tbool gso_partial;\n\n\tskb_reset_network_header(skb);\n\terr = ipv6_hopopt_jumbo_remove(skb);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tnhoff = skb_network_header(skb) - skb_mac_header(skb);\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))\n\t\tgoto out;\n\n\tencap = SKB_GSO_CB(skb)->encap_level > 0;\n\tif (encap)\n\t\tfeatures &= skb->dev->hw_enc_features;\n\tSKB_GSO_CB(skb)->encap_level += sizeof(*ipv6h);\n\n\tipv6h = ipv6_hdr(skb);\n\t__skb_pull(skb, sizeof(*ipv6h));\n\tsegs = ERR_PTR(-EPROTONOSUPPORT);\n\n\tproto = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);\n\n\tif (skb->encapsulation &&\n\t    skb_shinfo(skb)->gso_type & (SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6))\n\t\tudpfrag = proto == IPPROTO_UDP && encap &&\n\t\t\t  (skb_shinfo(skb)->gso_type & SKB_GSO_UDP);\n\telse\n\t\tudpfrag = proto == IPPROTO_UDP && !skb->encapsulation &&\n\t\t\t  (skb_shinfo(skb)->gso_type & SKB_GSO_UDP);\n\n\tops = rcu_dereference(inet6_offloads[proto]);\n\tif (likely(ops && ops->callbacks.gso_segment)) {\n\t\tskb_reset_transport_header(skb);\n\t\tsegs = ops->callbacks.gso_segment(skb, features);\n\t\tif (!segs)\n\t\t\tskb->network_header = skb_mac_header(skb) + nhoff - skb->head;\n\t}\n\n\tif (IS_ERR_OR_NULL(segs))\n\t\tgoto out;\n\n\tgso_partial = !!(skb_shinfo(segs)->gso_type & SKB_GSO_PARTIAL);\n\n\tfor (skb = segs; skb; skb = skb->next) {\n\t\tipv6h = (struct ipv6hdr *)(skb_mac_header(skb) + nhoff);\n\t\tif (gso_partial && skb_is_gso(skb))\n\t\t\tpayload_len = skb_shinfo(skb)->gso_size +\n\t\t\t\t      SKB_GSO_CB(skb)->data_offset +\n\t\t\t\t      skb->head - (unsigned char *)(ipv6h + 1);\n\t\telse\n\t\t\tpayload_len = skb->len - nhoff - sizeof(*ipv6h);\n\t\tipv6h->payload_len = htons(payload_len);\n\t\tskb->network_header = (u8 *)ipv6h - skb->head;\n\t\tskb_reset_mac_len(skb);\n\n\t\tif (udpfrag) {\n\t\t\tint err = ip6_find_1stfragopt(skb, &prevhdr);\n\t\t\tif (err < 0) {\n\t\t\t\tkfree_skb_list(segs);\n\t\t\t\treturn ERR_PTR(err);\n\t\t\t}\n\t\t\tfptr = (struct frag_hdr *)((u8 *)ipv6h + err);\n\t\t\tfptr->frag_off = htons(offset);\n\t\t\tif (skb->next)\n\t\t\t\tfptr->frag_off |= htons(IP6_MF);\n\t\t\toffset += (ntohs(ipv6h->payload_len) -\n\t\t\t\t   sizeof(struct frag_hdr));\n\t\t}\n\t\tif (encap)\n\t\t\tskb_reset_inner_headers(skb);\n\t}\n\nout:\n\treturn segs;\n}\n\n \nstatic int ipv6_exthdrs_len(struct ipv6hdr *iph,\n\t\t\t    const struct net_offload **opps)\n{\n\tstruct ipv6_opt_hdr *opth = (void *)iph;\n\tint len = 0, proto, optlen = sizeof(*iph);\n\n\tproto = iph->nexthdr;\n\tfor (;;) {\n\t\tif (proto != NEXTHDR_HOP) {\n\t\t\t*opps = rcu_dereference(inet6_offloads[proto]);\n\t\t\tif (unlikely(!(*opps)))\n\t\t\t\tbreak;\n\t\t\tif (!((*opps)->flags & INET6_PROTO_GSO_EXTHDR))\n\t\t\t\tbreak;\n\t\t}\n\t\topth = (void *)opth + optlen;\n\t\toptlen = ipv6_optlen(opth);\n\t\tlen += optlen;\n\t\tproto = opth->nexthdr;\n\t}\n\treturn len;\n}\n\nINDIRECT_CALLABLE_SCOPE struct sk_buff *ipv6_gro_receive(struct list_head *head,\n\t\t\t\t\t\t\t struct sk_buff *skb)\n{\n\tconst struct net_offload *ops;\n\tstruct sk_buff *pp = NULL;\n\tstruct sk_buff *p;\n\tstruct ipv6hdr *iph;\n\tunsigned int nlen;\n\tunsigned int hlen;\n\tunsigned int off;\n\tu16 flush = 1;\n\tint proto;\n\n\toff = skb_gro_offset(skb);\n\thlen = off + sizeof(*iph);\n\tiph = skb_gro_header(skb, hlen, off);\n\tif (unlikely(!iph))\n\t\tgoto out;\n\n\tskb_set_network_header(skb, off);\n\tskb_gro_pull(skb, sizeof(*iph));\n\tskb_set_transport_header(skb, skb_gro_offset(skb));\n\n\tflush += ntohs(iph->payload_len) != skb_gro_len(skb);\n\n\tproto = iph->nexthdr;\n\tops = rcu_dereference(inet6_offloads[proto]);\n\tif (!ops || !ops->callbacks.gro_receive) {\n\t\tpskb_pull(skb, skb_gro_offset(skb));\n\t\tskb_gro_frag0_invalidate(skb);\n\t\tproto = ipv6_gso_pull_exthdrs(skb, proto);\n\t\tskb_gro_pull(skb, -skb_transport_offset(skb));\n\t\tskb_reset_transport_header(skb);\n\t\t__skb_push(skb, skb_gro_offset(skb));\n\n\t\tops = rcu_dereference(inet6_offloads[proto]);\n\t\tif (!ops || !ops->callbacks.gro_receive)\n\t\t\tgoto out;\n\n\t\tiph = ipv6_hdr(skb);\n\t}\n\n\tNAPI_GRO_CB(skb)->proto = proto;\n\n\tflush--;\n\tnlen = skb_network_header_len(skb);\n\n\tlist_for_each_entry(p, head, list) {\n\t\tconst struct ipv6hdr *iph2;\n\t\t__be32 first_word;  \n\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tiph2 = (struct ipv6hdr *)(p->data + off);\n\t\tfirst_word = *(__be32 *)iph ^ *(__be32 *)iph2;\n\n\t\t \n\t\t if ((first_word & htonl(0xF00FFFFF)) ||\n\t\t     !ipv6_addr_equal(&iph->saddr, &iph2->saddr) ||\n\t\t     !ipv6_addr_equal(&iph->daddr, &iph2->daddr) ||\n\t\t     iph->nexthdr != iph2->nexthdr) {\nnot_same_flow:\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(nlen > sizeof(struct ipv6hdr))) {\n\t\t\tif (memcmp(iph + 1, iph2 + 1,\n\t\t\t\t   nlen - sizeof(struct ipv6hdr)))\n\t\t\t\tgoto not_same_flow;\n\t\t}\n\t\t \n\t\tNAPI_GRO_CB(p)->flush |= !!((first_word & htonl(0x0FF00000)) |\n\t\t\t(__force __be32)(iph->hop_limit ^ iph2->hop_limit));\n\t\tNAPI_GRO_CB(p)->flush |= flush;\n\n\t\t \n\t\tif (NAPI_GRO_CB(skb)->is_atomic)\n\t\t\tNAPI_GRO_CB(p)->flush_id = 0;\n\t}\n\n\tNAPI_GRO_CB(skb)->is_atomic = true;\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\n\tskb_gro_postpull_rcsum(skb, iph, nlen);\n\n\tpp = indirect_call_gro_receive_l4(tcp6_gro_receive, udp6_gro_receive,\n\t\t\t\t\t ops->callbacks.gro_receive, head, skb);\n\nout:\n\tskb_gro_flush_final(skb, pp, flush);\n\n\treturn pp;\n}\n\nstatic struct sk_buff *sit_ip6ip6_gro_receive(struct list_head *head,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\t \n\n\tif (NAPI_GRO_CB(skb)->encap_mark) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\n\treturn ipv6_gro_receive(head, skb);\n}\n\nstatic struct sk_buff *ip4ip6_gro_receive(struct list_head *head,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\t \n\n\tif (NAPI_GRO_CB(skb)->encap_mark) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\n\treturn inet_gro_receive(head, skb);\n}\n\nINDIRECT_CALLABLE_SCOPE int ipv6_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tconst struct net_offload *ops;\n\tstruct ipv6hdr *iph;\n\tint err = -ENOSYS;\n\tu32 payload_len;\n\n\tif (skb->encapsulation) {\n\t\tskb_set_inner_protocol(skb, cpu_to_be16(ETH_P_IPV6));\n\t\tskb_set_inner_network_header(skb, nhoff);\n\t}\n\n\tpayload_len = skb->len - nhoff - sizeof(*iph);\n\tif (unlikely(payload_len > IPV6_MAXPLEN)) {\n\t\tstruct hop_jumbo_hdr *hop_jumbo;\n\t\tint hoplen = sizeof(*hop_jumbo);\n\n\t\t \n\t\tmemmove(skb_mac_header(skb) - hoplen, skb_mac_header(skb),\n\t\t\tskb->transport_header - skb->mac_header);\n\t\tskb->data -= hoplen;\n\t\tskb->len += hoplen;\n\t\tskb->mac_header -= hoplen;\n\t\tskb->network_header -= hoplen;\n\t\tiph = (struct ipv6hdr *)(skb->data + nhoff);\n\t\thop_jumbo = (struct hop_jumbo_hdr *)(iph + 1);\n\n\t\t \n\t\thop_jumbo->nexthdr = iph->nexthdr;\n\t\thop_jumbo->hdrlen = 0;\n\t\thop_jumbo->tlv_type = IPV6_TLV_JUMBO;\n\t\thop_jumbo->tlv_len = 4;\n\t\thop_jumbo->jumbo_payload_len = htonl(payload_len + hoplen);\n\n\t\tiph->nexthdr = NEXTHDR_HOP;\n\t\tiph->payload_len = 0;\n\t} else {\n\t\tiph = (struct ipv6hdr *)(skb->data + nhoff);\n\t\tiph->payload_len = htons(payload_len);\n\t}\n\n\tnhoff += sizeof(*iph) + ipv6_exthdrs_len(iph, &ops);\n\tif (WARN_ON(!ops || !ops->callbacks.gro_complete))\n\t\tgoto out;\n\n\terr = INDIRECT_CALL_L4(ops->callbacks.gro_complete, tcp6_gro_complete,\n\t\t\t       udp6_gro_complete, skb, nhoff);\n\nout:\n\treturn err;\n}\n\nstatic int sit_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tskb->encapsulation = 1;\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_IPXIP4;\n\treturn ipv6_gro_complete(skb, nhoff);\n}\n\nstatic int ip6ip6_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tskb->encapsulation = 1;\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_IPXIP6;\n\treturn ipv6_gro_complete(skb, nhoff);\n}\n\nstatic int ip4ip6_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tskb->encapsulation = 1;\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_IPXIP6;\n\treturn inet_gro_complete(skb, nhoff);\n}\n\nstatic struct packet_offload ipv6_packet_offload __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_IPV6),\n\t.callbacks = {\n\t\t.gso_segment = ipv6_gso_segment,\n\t\t.gro_receive = ipv6_gro_receive,\n\t\t.gro_complete = ipv6_gro_complete,\n\t},\n};\n\nstatic struct sk_buff *sit_gso_segment(struct sk_buff *skb,\n\t\t\t\t       netdev_features_t features)\n{\n\tif (!(skb_shinfo(skb)->gso_type & SKB_GSO_IPXIP4))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn ipv6_gso_segment(skb, features);\n}\n\nstatic struct sk_buff *ip4ip6_gso_segment(struct sk_buff *skb,\n\t\t\t\t\t  netdev_features_t features)\n{\n\tif (!(skb_shinfo(skb)->gso_type & SKB_GSO_IPXIP6))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn inet_gso_segment(skb, features);\n}\n\nstatic struct sk_buff *ip6ip6_gso_segment(struct sk_buff *skb,\n\t\t\t\t\t  netdev_features_t features)\n{\n\tif (!(skb_shinfo(skb)->gso_type & SKB_GSO_IPXIP6))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn ipv6_gso_segment(skb, features);\n}\n\nstatic const struct net_offload sit_offload = {\n\t.callbacks = {\n\t\t.gso_segment\t= sit_gso_segment,\n\t\t.gro_receive    = sit_ip6ip6_gro_receive,\n\t\t.gro_complete   = sit_gro_complete,\n\t},\n};\n\nstatic const struct net_offload ip4ip6_offload = {\n\t.callbacks = {\n\t\t.gso_segment\t= ip4ip6_gso_segment,\n\t\t.gro_receive    = ip4ip6_gro_receive,\n\t\t.gro_complete   = ip4ip6_gro_complete,\n\t},\n};\n\nstatic const struct net_offload ip6ip6_offload = {\n\t.callbacks = {\n\t\t.gso_segment\t= ip6ip6_gso_segment,\n\t\t.gro_receive    = sit_ip6ip6_gro_receive,\n\t\t.gro_complete   = ip6ip6_gro_complete,\n\t},\n};\nstatic int __init ipv6_offload_init(void)\n{\n\n\tif (tcpv6_offload_init() < 0)\n\t\tpr_crit(\"%s: Cannot add TCP protocol offload\\n\", __func__);\n\tif (ipv6_exthdrs_offload_init() < 0)\n\t\tpr_crit(\"%s: Cannot add EXTHDRS protocol offload\\n\", __func__);\n\n\tdev_add_offload(&ipv6_packet_offload);\n\n\tinet_add_offload(&sit_offload, IPPROTO_IPV6);\n\tinet6_add_offload(&ip6ip6_offload, IPPROTO_IPV6);\n\tinet6_add_offload(&ip4ip6_offload, IPPROTO_IPIP);\n\n\treturn 0;\n}\n\nfs_initcall(ipv6_offload_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}