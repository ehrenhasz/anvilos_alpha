{
  "module_name": "seg6.c",
  "hash_id": "26454bce828089c59241383d05acecdd695eab9d32703f289c330e837f27141e",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/seg6.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/slab.h>\n#include <linux/rhashtable.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n\n#include <net/seg6.h>\n#include <net/genetlink.h>\n#include <linux/seg6.h>\n#include <linux/seg6_genl.h>\n#ifdef CONFIG_IPV6_SEG6_HMAC\n#include <net/seg6_hmac.h>\n#endif\n\nbool seg6_validate_srh(struct ipv6_sr_hdr *srh, int len, bool reduced)\n{\n\tunsigned int tlv_offset;\n\tint max_last_entry;\n\tint trailing;\n\n\tif (srh->type != IPV6_SRCRT_TYPE_4)\n\t\treturn false;\n\n\tif (((srh->hdrlen + 1) << 3) != len)\n\t\treturn false;\n\n\tif (!reduced && srh->segments_left > srh->first_segment) {\n\t\treturn false;\n\t} else {\n\t\tmax_last_entry = (srh->hdrlen / 2) - 1;\n\n\t\tif (srh->first_segment > max_last_entry)\n\t\t\treturn false;\n\n\t\tif (srh->segments_left > srh->first_segment + 1)\n\t\t\treturn false;\n\t}\n\n\ttlv_offset = sizeof(*srh) + ((srh->first_segment + 1) << 4);\n\n\ttrailing = len - tlv_offset;\n\tif (trailing < 0)\n\t\treturn false;\n\n\twhile (trailing) {\n\t\tstruct sr6_tlv *tlv;\n\t\tunsigned int tlv_len;\n\n\t\tif (trailing < sizeof(*tlv))\n\t\t\treturn false;\n\n\t\ttlv = (struct sr6_tlv *)((unsigned char *)srh + tlv_offset);\n\t\ttlv_len = sizeof(*tlv) + tlv->len;\n\n\t\ttrailing -= tlv_len;\n\t\tif (trailing < 0)\n\t\t\treturn false;\n\n\t\ttlv_offset += tlv_len;\n\t}\n\n\treturn true;\n}\n\nstruct ipv6_sr_hdr *seg6_get_srh(struct sk_buff *skb, int flags)\n{\n\tstruct ipv6_sr_hdr *srh;\n\tint len, srhoff = 0;\n\n\tif (ipv6_find_hdr(skb, &srhoff, IPPROTO_ROUTING, NULL, &flags) < 0)\n\t\treturn NULL;\n\n\tif (!pskb_may_pull(skb, srhoff + sizeof(*srh)))\n\t\treturn NULL;\n\n\tsrh = (struct ipv6_sr_hdr *)(skb->data + srhoff);\n\n\tlen = (srh->hdrlen + 1) << 3;\n\n\tif (!pskb_may_pull(skb, srhoff + len))\n\t\treturn NULL;\n\n\t \n\tsrh = (struct ipv6_sr_hdr *)(skb->data + srhoff);\n\n\tif (!seg6_validate_srh(srh, len, true))\n\t\treturn NULL;\n\n\treturn srh;\n}\n\n \nvoid seg6_icmp_srh(struct sk_buff *skb, struct inet6_skb_parm *opt)\n{\n\t__u16 network_header = skb->network_header;\n\tstruct ipv6_sr_hdr *srh;\n\n\t \n\tskb_reset_network_header(skb);\n\n\tsrh = seg6_get_srh(skb, 0);\n\tif (!srh)\n\t\tgoto out;\n\n\tif (srh->type != IPV6_SRCRT_TYPE_4)\n\t\tgoto out;\n\n\topt->flags |= IP6SKB_SEG6;\n\topt->srhoff = (unsigned char *)srh - skb->data;\n\nout:\n\t \n\tskb->network_header = network_header;\n}\n\nstatic struct genl_family seg6_genl_family;\n\nstatic const struct nla_policy seg6_genl_policy[SEG6_ATTR_MAX + 1] = {\n\t[SEG6_ATTR_DST]\t\t\t\t= { .type = NLA_BINARY,\n\t\t.len = sizeof(struct in6_addr) },\n\t[SEG6_ATTR_DSTLEN]\t\t\t= { .type = NLA_S32, },\n\t[SEG6_ATTR_HMACKEYID]\t\t= { .type = NLA_U32, },\n\t[SEG6_ATTR_SECRET]\t\t\t= { .type = NLA_BINARY, },\n\t[SEG6_ATTR_SECRETLEN]\t\t= { .type = NLA_U8, },\n\t[SEG6_ATTR_ALGID]\t\t\t= { .type = NLA_U8, },\n\t[SEG6_ATTR_HMACINFO]\t\t= { .type = NLA_NESTED, },\n};\n\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\nstatic int seg6_genl_sethmac(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct seg6_pernet_data *sdata;\n\tstruct seg6_hmac_info *hinfo;\n\tu32 hmackeyid;\n\tchar *secret;\n\tint err = 0;\n\tu8 algid;\n\tu8 slen;\n\n\tsdata = seg6_pernet(net);\n\n\tif (!info->attrs[SEG6_ATTR_HMACKEYID] ||\n\t    !info->attrs[SEG6_ATTR_SECRETLEN] ||\n\t    !info->attrs[SEG6_ATTR_ALGID])\n\t\treturn -EINVAL;\n\n\thmackeyid = nla_get_u32(info->attrs[SEG6_ATTR_HMACKEYID]);\n\tslen = nla_get_u8(info->attrs[SEG6_ATTR_SECRETLEN]);\n\talgid = nla_get_u8(info->attrs[SEG6_ATTR_ALGID]);\n\n\tif (hmackeyid == 0)\n\t\treturn -EINVAL;\n\n\tif (slen > SEG6_HMAC_SECRET_LEN)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&sdata->lock);\n\thinfo = seg6_hmac_info_lookup(net, hmackeyid);\n\n\tif (!slen) {\n\t\terr = seg6_hmac_info_del(net, hmackeyid);\n\n\t\tgoto out_unlock;\n\t}\n\n\tif (!info->attrs[SEG6_ATTR_SECRET]) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (slen > nla_len(info->attrs[SEG6_ATTR_SECRET])) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (hinfo) {\n\t\terr = seg6_hmac_info_del(net, hmackeyid);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tsecret = (char *)nla_data(info->attrs[SEG6_ATTR_SECRET]);\n\n\thinfo = kzalloc(sizeof(*hinfo), GFP_KERNEL);\n\tif (!hinfo) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tmemcpy(hinfo->secret, secret, slen);\n\thinfo->slen = slen;\n\thinfo->alg_id = algid;\n\thinfo->hmackeyid = hmackeyid;\n\n\terr = seg6_hmac_info_add(net, hmackeyid, hinfo);\n\tif (err)\n\t\tkfree(hinfo);\n\nout_unlock:\n\tmutex_unlock(&sdata->lock);\n\treturn err;\n}\n\n#else\n\nstatic int seg6_genl_sethmac(struct sk_buff *skb, struct genl_info *info)\n{\n\treturn -ENOTSUPP;\n}\n\n#endif\n\nstatic int seg6_genl_set_tunsrc(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct in6_addr *val, *t_old, *t_new;\n\tstruct seg6_pernet_data *sdata;\n\n\tsdata = seg6_pernet(net);\n\n\tif (!info->attrs[SEG6_ATTR_DST])\n\t\treturn -EINVAL;\n\n\tval = nla_data(info->attrs[SEG6_ATTR_DST]);\n\tt_new = kmemdup(val, sizeof(*val), GFP_KERNEL);\n\tif (!t_new)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&sdata->lock);\n\n\tt_old = sdata->tun_src;\n\trcu_assign_pointer(sdata->tun_src, t_new);\n\n\tmutex_unlock(&sdata->lock);\n\n\tsynchronize_net();\n\tkfree(t_old);\n\n\treturn 0;\n}\n\nstatic int seg6_genl_get_tunsrc(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net *net = genl_info_net(info);\n\tstruct in6_addr *tun_src;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = genlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, info->snd_portid, info->snd_seq,\n\t\t\t  &seg6_genl_family, 0, SEG6_CMD_GET_TUNSRC);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\trcu_read_lock();\n\ttun_src = rcu_dereference(seg6_pernet(net)->tun_src);\n\n\tif (nla_put(msg, SEG6_ATTR_DST, sizeof(struct in6_addr), tun_src))\n\t\tgoto nla_put_failure;\n\n\trcu_read_unlock();\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\trcu_read_unlock();\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -ENOMEM;\n}\n\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\nstatic int __seg6_hmac_fill_info(struct seg6_hmac_info *hinfo,\n\t\t\t\t struct sk_buff *msg)\n{\n\tif (nla_put_u32(msg, SEG6_ATTR_HMACKEYID, hinfo->hmackeyid) ||\n\t    nla_put_u8(msg, SEG6_ATTR_SECRETLEN, hinfo->slen) ||\n\t    nla_put(msg, SEG6_ATTR_SECRET, hinfo->slen, hinfo->secret) ||\n\t    nla_put_u8(msg, SEG6_ATTR_ALGID, hinfo->alg_id))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int __seg6_genl_dumphmac_element(struct seg6_hmac_info *hinfo,\n\t\t\t\t\tu32 portid, u32 seq, u32 flags,\n\t\t\t\t\tstruct sk_buff *skb, u8 cmd)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(skb, portid, seq, &seg6_genl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tif (__seg6_hmac_fill_info(hinfo, skb) < 0)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int seg6_genl_dumphmac_start(struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(cb->skb->sk);\n\tstruct seg6_pernet_data *sdata;\n\tstruct rhashtable_iter *iter;\n\n\tsdata = seg6_pernet(net);\n\titer = (struct rhashtable_iter *)cb->args[0];\n\n\tif (!iter) {\n\t\titer = kmalloc(sizeof(*iter), GFP_KERNEL);\n\t\tif (!iter)\n\t\t\treturn -ENOMEM;\n\n\t\tcb->args[0] = (long)iter;\n\t}\n\n\trhashtable_walk_enter(&sdata->hmac_infos, iter);\n\n\treturn 0;\n}\n\nstatic int seg6_genl_dumphmac_done(struct netlink_callback *cb)\n{\n\tstruct rhashtable_iter *iter = (struct rhashtable_iter *)cb->args[0];\n\n\trhashtable_walk_exit(iter);\n\n\tkfree(iter);\n\n\treturn 0;\n}\n\nstatic int seg6_genl_dumphmac(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct rhashtable_iter *iter = (struct rhashtable_iter *)cb->args[0];\n\tstruct seg6_hmac_info *hinfo;\n\tint ret;\n\n\trhashtable_walk_start(iter);\n\n\tfor (;;) {\n\t\thinfo = rhashtable_walk_next(iter);\n\n\t\tif (IS_ERR(hinfo)) {\n\t\t\tif (PTR_ERR(hinfo) == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tret = PTR_ERR(hinfo);\n\t\t\tgoto done;\n\t\t} else if (!hinfo) {\n\t\t\tbreak;\n\t\t}\n\n\t\tret = __seg6_genl_dumphmac_element(hinfo,\n\t\t\t\t\t\t   NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t   cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t   NLM_F_MULTI,\n\t\t\t\t\t\t   skb, SEG6_CMD_DUMPHMAC);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tret = skb->len;\n\ndone:\n\trhashtable_walk_stop(iter);\n\treturn ret;\n}\n\n#else\n\nstatic int seg6_genl_dumphmac_start(struct netlink_callback *cb)\n{\n\treturn 0;\n}\n\nstatic int seg6_genl_dumphmac_done(struct netlink_callback *cb)\n{\n\treturn 0;\n}\n\nstatic int seg6_genl_dumphmac(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\treturn -ENOTSUPP;\n}\n\n#endif\n\nstatic int __net_init seg6_net_init(struct net *net)\n{\n\tstruct seg6_pernet_data *sdata;\n\n\tsdata = kzalloc(sizeof(*sdata), GFP_KERNEL);\n\tif (!sdata)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&sdata->lock);\n\n\tsdata->tun_src = kzalloc(sizeof(*sdata->tun_src), GFP_KERNEL);\n\tif (!sdata->tun_src) {\n\t\tkfree(sdata);\n\t\treturn -ENOMEM;\n\t}\n\n\tnet->ipv6.seg6_data = sdata;\n\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\tif (seg6_hmac_net_init(net)) {\n\t\tkfree(rcu_dereference_raw(sdata->tun_src));\n\t\tkfree(sdata);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic void __net_exit seg6_net_exit(struct net *net)\n{\n\tstruct seg6_pernet_data *sdata = seg6_pernet(net);\n\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\tseg6_hmac_net_exit(net);\n#endif\n\n\tkfree(rcu_dereference_raw(sdata->tun_src));\n\tkfree(sdata);\n}\n\nstatic struct pernet_operations ip6_segments_ops = {\n\t.init = seg6_net_init,\n\t.exit = seg6_net_exit,\n};\n\nstatic const struct genl_ops seg6_genl_ops[] = {\n\t{\n\t\t.cmd\t= SEG6_CMD_SETHMAC,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit\t= seg6_genl_sethmac,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd\t= SEG6_CMD_DUMPHMAC,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.start\t= seg6_genl_dumphmac_start,\n\t\t.dumpit\t= seg6_genl_dumphmac,\n\t\t.done\t= seg6_genl_dumphmac_done,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd\t= SEG6_CMD_SET_TUNSRC,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit\t= seg6_genl_set_tunsrc,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd\t= SEG6_CMD_GET_TUNSRC,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit\t= seg6_genl_get_tunsrc,\n\t\t.flags\t= GENL_ADMIN_PERM,\n\t},\n};\n\nstatic struct genl_family seg6_genl_family __ro_after_init = {\n\t.hdrsize\t= 0,\n\t.name\t\t= SEG6_GENL_NAME,\n\t.version\t= SEG6_GENL_VERSION,\n\t.maxattr\t= SEG6_ATTR_MAX,\n\t.policy = seg6_genl_policy,\n\t.netnsok\t= true,\n\t.parallel_ops\t= true,\n\t.ops\t\t= seg6_genl_ops,\n\t.n_ops\t\t= ARRAY_SIZE(seg6_genl_ops),\n\t.resv_start_op\t= SEG6_CMD_GET_TUNSRC + 1,\n\t.module\t\t= THIS_MODULE,\n};\n\nint __init seg6_init(void)\n{\n\tint err;\n\n\terr = genl_register_family(&seg6_genl_family);\n\tif (err)\n\t\tgoto out;\n\n\terr = register_pernet_subsys(&ip6_segments_ops);\n\tif (err)\n\t\tgoto out_unregister_genl;\n\n#ifdef CONFIG_IPV6_SEG6_LWTUNNEL\n\terr = seg6_iptunnel_init();\n\tif (err)\n\t\tgoto out_unregister_pernet;\n\n\terr = seg6_local_init();\n\tif (err)\n\t\tgoto out_unregister_pernet;\n#endif\n\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\terr = seg6_hmac_init();\n\tif (err)\n\t\tgoto out_unregister_iptun;\n#endif\n\n\tpr_info(\"Segment Routing with IPv6\\n\");\n\nout:\n\treturn err;\n#ifdef CONFIG_IPV6_SEG6_HMAC\nout_unregister_iptun:\n#ifdef CONFIG_IPV6_SEG6_LWTUNNEL\n\tseg6_local_exit();\n\tseg6_iptunnel_exit();\n#endif\n#endif\n#ifdef CONFIG_IPV6_SEG6_LWTUNNEL\nout_unregister_pernet:\n\tunregister_pernet_subsys(&ip6_segments_ops);\n#endif\nout_unregister_genl:\n\tgenl_unregister_family(&seg6_genl_family);\n\tgoto out;\n}\n\nvoid seg6_exit(void)\n{\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\tseg6_hmac_exit();\n#endif\n#ifdef CONFIG_IPV6_SEG6_LWTUNNEL\n\tseg6_iptunnel_exit();\n#endif\n\tunregister_pernet_subsys(&ip6_segments_ops);\n\tgenl_unregister_family(&seg6_genl_family);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}