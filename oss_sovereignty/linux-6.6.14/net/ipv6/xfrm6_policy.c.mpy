{
  "module_name": "xfrm6_policy.c",
  "hash_id": "8aee407f4f16603a59c8353f9eb55a5ddf947ac31cd3aa1004389888f5ae7f8e",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/xfrm6_policy.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <net/addrconf.h>\n#include <net/dst.h>\n#include <net/xfrm.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/l3mdev.h>\n\nstatic struct dst_entry *xfrm6_dst_lookup(struct net *net, int tos, int oif,\n\t\t\t\t\t  const xfrm_address_t *saddr,\n\t\t\t\t\t  const xfrm_address_t *daddr,\n\t\t\t\t\t  u32 mark)\n{\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint err;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_l3mdev = l3mdev_master_ifindex_by_index(net, oif);\n\tfl6.flowi6_mark = mark;\n\tmemcpy(&fl6.daddr, daddr, sizeof(fl6.daddr));\n\tif (saddr)\n\t\tmemcpy(&fl6.saddr, saddr, sizeof(fl6.saddr));\n\n\tdst = ip6_route_output(net, NULL, &fl6);\n\n\terr = dst->error;\n\tif (dst->error) {\n\t\tdst_release(dst);\n\t\tdst = ERR_PTR(err);\n\t}\n\n\treturn dst;\n}\n\nstatic int xfrm6_get_saddr(struct net *net, int oif,\n\t\t\t   xfrm_address_t *saddr, xfrm_address_t *daddr,\n\t\t\t   u32 mark)\n{\n\tstruct dst_entry *dst;\n\tstruct net_device *dev;\n\n\tdst = xfrm6_dst_lookup(net, 0, oif, NULL, daddr, mark);\n\tif (IS_ERR(dst))\n\t\treturn -EHOSTUNREACH;\n\n\tdev = ip6_dst_idev(dst)->dev;\n\tipv6_dev_get_saddr(dev_net(dev), dev, &daddr->in6, 0, &saddr->in6);\n\tdst_release(dst);\n\treturn 0;\n}\n\nstatic int xfrm6_fill_dst(struct xfrm_dst *xdst, struct net_device *dev,\n\t\t\t  const struct flowi *fl)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)xdst->route;\n\n\txdst->u.dst.dev = dev;\n\tnetdev_hold(dev, &xdst->u.dst.dev_tracker, GFP_ATOMIC);\n\n\txdst->u.rt6.rt6i_idev = in6_dev_get(dev);\n\tif (!xdst->u.rt6.rt6i_idev) {\n\t\tnetdev_put(dev, &xdst->u.dst.dev_tracker);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\txdst->u.rt6.rt6i_flags = rt->rt6i_flags & (RTF_ANYCAST |\n\t\t\t\t\t\t   RTF_LOCAL);\n\txdst->route_cookie = rt6_get_cookie(rt);\n\txdst->u.rt6.rt6i_gateway = rt->rt6i_gateway;\n\txdst->u.rt6.rt6i_dst = rt->rt6i_dst;\n\txdst->u.rt6.rt6i_src = rt->rt6i_src;\n\trt6_uncached_list_add(&xdst->u.rt6);\n\n\treturn 0;\n}\n\nstatic void xfrm6_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t      struct sk_buff *skb, u32 mtu,\n\t\t\t      bool confirm_neigh)\n{\n\tstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\n\tstruct dst_entry *path = xdst->route;\n\n\tpath->ops->update_pmtu(path, sk, skb, mtu, confirm_neigh);\n}\n\nstatic void xfrm6_redirect(struct dst_entry *dst, struct sock *sk,\n\t\t\t   struct sk_buff *skb)\n{\n\tstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\n\tstruct dst_entry *path = xdst->route;\n\n\tpath->ops->redirect(path, sk, skb);\n}\n\nstatic void xfrm6_dst_destroy(struct dst_entry *dst)\n{\n\tstruct xfrm_dst *xdst = (struct xfrm_dst *)dst;\n\n\tdst_destroy_metrics_generic(dst);\n\trt6_uncached_list_del(&xdst->u.rt6);\n\tif (likely(xdst->u.rt6.rt6i_idev))\n\t\tin6_dev_put(xdst->u.rt6.rt6i_idev);\n\txfrm_dst_destroy(xdst);\n}\n\nstatic void xfrm6_dst_ifdown(struct dst_entry *dst, struct net_device *dev)\n{\n\tstruct xfrm_dst *xdst;\n\n\txdst = (struct xfrm_dst *)dst;\n\tif (xdst->u.rt6.rt6i_idev->dev == dev) {\n\t\tstruct inet6_dev *loopback_idev =\n\t\t\tin6_dev_get(dev_net(dev)->loopback_dev);\n\n\t\tdo {\n\t\t\tin6_dev_put(xdst->u.rt6.rt6i_idev);\n\t\t\txdst->u.rt6.rt6i_idev = loopback_idev;\n\t\t\tin6_dev_hold(loopback_idev);\n\t\t\txdst = (struct xfrm_dst *)xfrm_dst_child(&xdst->u.dst);\n\t\t} while (xdst->u.dst.xfrm);\n\n\t\t__in6_dev_put(loopback_idev);\n\t}\n\n\txfrm_dst_ifdown(dst, dev);\n}\n\nstatic struct dst_ops xfrm6_dst_ops_template = {\n\t.family =\t\tAF_INET6,\n\t.update_pmtu =\t\txfrm6_update_pmtu,\n\t.redirect =\t\txfrm6_redirect,\n\t.cow_metrics =\t\tdst_cow_metrics_generic,\n\t.destroy =\t\txfrm6_dst_destroy,\n\t.ifdown =\t\txfrm6_dst_ifdown,\n\t.local_out =\t\t__ip6_local_out,\n\t.gc_thresh =\t\t32768,\n};\n\nstatic const struct xfrm_policy_afinfo xfrm6_policy_afinfo = {\n\t.dst_ops =\t\t&xfrm6_dst_ops_template,\n\t.dst_lookup =\t\txfrm6_dst_lookup,\n\t.get_saddr =\t\txfrm6_get_saddr,\n\t.fill_dst =\t\txfrm6_fill_dst,\n\t.blackhole_route =\tip6_blackhole_route,\n};\n\nstatic int __init xfrm6_policy_init(void)\n{\n\treturn xfrm_policy_register_afinfo(&xfrm6_policy_afinfo, AF_INET6);\n}\n\nstatic void xfrm6_policy_fini(void)\n{\n\txfrm_policy_unregister_afinfo(&xfrm6_policy_afinfo);\n}\n\n#ifdef CONFIG_SYSCTL\nstatic struct ctl_table xfrm6_policy_table[] = {\n\t{\n\t\t.procname       = \"xfrm6_gc_thresh\",\n\t\t.data\t\t= &init_net.xfrm.xfrm6_dst_ops.gc_thresh,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler   = proc_dointvec,\n\t},\n\t{ }\n};\n\nstatic int __net_init xfrm6_net_sysctl_init(struct net *net)\n{\n\tstruct ctl_table *table;\n\tstruct ctl_table_header *hdr;\n\n\ttable = xfrm6_policy_table;\n\tif (!net_eq(net, &init_net)) {\n\t\ttable = kmemdup(table, sizeof(xfrm6_policy_table), GFP_KERNEL);\n\t\tif (!table)\n\t\t\tgoto err_alloc;\n\n\t\ttable[0].data = &net->xfrm.xfrm6_dst_ops.gc_thresh;\n\t}\n\n\thdr = register_net_sysctl_sz(net, \"net/ipv6\", table,\n\t\t\t\t     ARRAY_SIZE(xfrm6_policy_table));\n\tif (!hdr)\n\t\tgoto err_reg;\n\n\tnet->ipv6.sysctl.xfrm6_hdr = hdr;\n\treturn 0;\n\nerr_reg:\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\nerr_alloc:\n\treturn -ENOMEM;\n}\n\nstatic void __net_exit xfrm6_net_sysctl_exit(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\tif (!net->ipv6.sysctl.xfrm6_hdr)\n\t\treturn;\n\n\ttable = net->ipv6.sysctl.xfrm6_hdr->ctl_table_arg;\n\tunregister_net_sysctl_table(net->ipv6.sysctl.xfrm6_hdr);\n\tif (!net_eq(net, &init_net))\n\t\tkfree(table);\n}\n#else  \nstatic inline int xfrm6_net_sysctl_init(struct net *net)\n{\n\treturn 0;\n}\n\nstatic inline void xfrm6_net_sysctl_exit(struct net *net)\n{\n}\n#endif\n\nstatic int __net_init xfrm6_net_init(struct net *net)\n{\n\tint ret;\n\n\tmemcpy(&net->xfrm.xfrm6_dst_ops, &xfrm6_dst_ops_template,\n\t       sizeof(xfrm6_dst_ops_template));\n\tret = dst_entries_init(&net->xfrm.xfrm6_dst_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xfrm6_net_sysctl_init(net);\n\tif (ret)\n\t\tdst_entries_destroy(&net->xfrm.xfrm6_dst_ops);\n\n\treturn ret;\n}\n\nstatic void __net_exit xfrm6_net_exit(struct net *net)\n{\n\txfrm6_net_sysctl_exit(net);\n\tdst_entries_destroy(&net->xfrm.xfrm6_dst_ops);\n}\n\nstatic struct pernet_operations xfrm6_net_ops = {\n\t.init\t= xfrm6_net_init,\n\t.exit\t= xfrm6_net_exit,\n};\n\nint __init xfrm6_init(void)\n{\n\tint ret;\n\n\tret = xfrm6_policy_init();\n\tif (ret)\n\t\tgoto out;\n\tret = xfrm6_state_init();\n\tif (ret)\n\t\tgoto out_policy;\n\n\tret = xfrm6_protocol_init();\n\tif (ret)\n\t\tgoto out_state;\n\n\tret = register_pernet_subsys(&xfrm6_net_ops);\n\tif (ret)\n\t\tgoto out_protocol;\nout:\n\treturn ret;\nout_protocol:\n\txfrm6_protocol_fini();\nout_state:\n\txfrm6_state_fini();\nout_policy:\n\txfrm6_policy_fini();\n\tgoto out;\n}\n\nvoid xfrm6_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_net_ops);\n\txfrm6_protocol_fini();\n\txfrm6_policy_fini();\n\txfrm6_state_fini();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}