{
  "module_name": "exthdrs.c",
  "hash_id": "b3414ebcbb9617595008c5edf991cb6ee66ec44cfae9270182b40cdb7bd01e80",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/exthdrs.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/icmpv6.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include <net/dst.h>\n#include <net/sock.h>\n#include <net/snmp.h>\n\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/rawv6.h>\n#include <net/ndisc.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/calipso.h>\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n#include <net/xfrm.h>\n#endif\n#include <linux/seg6.h>\n#include <net/seg6.h>\n#ifdef CONFIG_IPV6_SEG6_HMAC\n#include <net/seg6_hmac.h>\n#endif\n#include <net/rpl.h>\n#include <linux/ioam6.h>\n#include <net/ioam6.h>\n#include <net/dst_metadata.h>\n\n#include <linux/uaccess.h>\n\n \n\n \n\nstatic bool ip6_tlvopt_unknown(struct sk_buff *skb, int optoff,\n\t\t\t       bool disallow_unknowns)\n{\n\tif (disallow_unknowns) {\n\t\t \n\n\t\tgoto drop;\n\t}\n\n\tswitch ((skb_network_header(skb)[optoff] & 0xC0) >> 6) {\n\tcase 0:  \n\t\treturn true;\n\n\tcase 1:  \n\t\tbreak;\n\n\tcase 3:  \n\t\t \n\t\tif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr))\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 2:  \n\t\ticmpv6_param_prob_reason(skb, ICMPV6_UNK_OPTION, optoff,\n\t\t\t\t\t SKB_DROP_REASON_UNHANDLED_PROTO);\n\t\treturn false;\n\t}\n\ndrop:\n\tkfree_skb_reason(skb, SKB_DROP_REASON_UNHANDLED_PROTO);\n\treturn false;\n}\n\nstatic bool ipv6_hop_ra(struct sk_buff *skb, int optoff);\nstatic bool ipv6_hop_ioam(struct sk_buff *skb, int optoff);\nstatic bool ipv6_hop_jumbo(struct sk_buff *skb, int optoff);\nstatic bool ipv6_hop_calipso(struct sk_buff *skb, int optoff);\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\nstatic bool ipv6_dest_hao(struct sk_buff *skb, int optoff);\n#endif\n\n \n\nstatic bool ip6_parse_tlv(bool hopbyhop,\n\t\t\t  struct sk_buff *skb,\n\t\t\t  int max_count)\n{\n\tint len = (skb_transport_header(skb)[1] + 1) << 3;\n\tconst unsigned char *nh = skb_network_header(skb);\n\tint off = skb_network_header_len(skb);\n\tbool disallow_unknowns = false;\n\tint tlv_count = 0;\n\tint padlen = 0;\n\n\tif (unlikely(max_count < 0)) {\n\t\tdisallow_unknowns = true;\n\t\tmax_count = -max_count;\n\t}\n\n\toff += 2;\n\tlen -= 2;\n\n\twhile (len > 0) {\n\t\tint optlen, i;\n\n\t\tif (nh[off] == IPV6_TLV_PAD1) {\n\t\t\tpadlen++;\n\t\t\tif (padlen > 7)\n\t\t\t\tgoto bad;\n\t\t\toff++;\n\t\t\tlen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (len < 2)\n\t\t\tgoto bad;\n\t\toptlen = nh[off + 1] + 2;\n\t\tif (optlen > len)\n\t\t\tgoto bad;\n\n\t\tif (nh[off] == IPV6_TLV_PADN) {\n\t\t\t \n\t\t\tpadlen += optlen;\n\t\t\tif (padlen > 7)\n\t\t\t\tgoto bad;\n\t\t\t \n\t\t\tfor (i = 2; i < optlen; i++) {\n\t\t\t\tif (nh[off + i] != 0)\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t} else {\n\t\t\ttlv_count++;\n\t\t\tif (tlv_count > max_count)\n\t\t\t\tgoto bad;\n\n\t\t\tif (hopbyhop) {\n\t\t\t\tswitch (nh[off]) {\n\t\t\t\tcase IPV6_TLV_ROUTERALERT:\n\t\t\t\t\tif (!ipv6_hop_ra(skb, off))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IPV6_TLV_IOAM:\n\t\t\t\t\tif (!ipv6_hop_ioam(skb, off))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IPV6_TLV_JUMBO:\n\t\t\t\t\tif (!ipv6_hop_jumbo(skb, off))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IPV6_TLV_CALIPSO:\n\t\t\t\t\tif (!ipv6_hop_calipso(skb, off))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!ip6_tlvopt_unknown(skb, off,\n\t\t\t\t\t\t\t\tdisallow_unknowns))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (nh[off]) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\t\tcase IPV6_TLV_HAO:\n\t\t\t\t\tif (!ipv6_dest_hao(skb, off))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tif (!ip6_tlvopt_unknown(skb, off,\n\t\t\t\t\t\t\t\tdisallow_unknowns))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpadlen = 0;\n\t\t}\n\t\toff += optlen;\n\t\tlen -= optlen;\n\t}\n\n\tif (len == 0)\n\t\treturn true;\nbad:\n\tkfree_skb_reason(skb, SKB_DROP_REASON_IP_INHDR);\n\treturn false;\n}\n\n \n\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\nstatic bool ipv6_dest_hao(struct sk_buff *skb, int optoff)\n{\n\tstruct ipv6_destopt_hao *hao;\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tSKB_DR(reason);\n\tint ret;\n\n\tif (opt->dsthao) {\n\t\tnet_dbg_ratelimited(\"hao duplicated\\n\");\n\t\tgoto discard;\n\t}\n\topt->dsthao = opt->dst1;\n\topt->dst1 = 0;\n\n\thao = (struct ipv6_destopt_hao *)(skb_network_header(skb) + optoff);\n\n\tif (hao->length != 16) {\n\t\tnet_dbg_ratelimited(\"hao invalid option length = %d\\n\",\n\t\t\t\t    hao->length);\n\t\tSKB_DR_SET(reason, IP_INHDR);\n\t\tgoto discard;\n\t}\n\n\tif (!(ipv6_addr_type(&hao->addr) & IPV6_ADDR_UNICAST)) {\n\t\tnet_dbg_ratelimited(\"hao is not an unicast addr: %pI6\\n\",\n\t\t\t\t    &hao->addr);\n\t\tSKB_DR_SET(reason, INVALID_PROTO);\n\t\tgoto discard;\n\t}\n\n\tret = xfrm6_input_addr(skb, (xfrm_address_t *)&ipv6h->daddr,\n\t\t\t       (xfrm_address_t *)&hao->addr, IPPROTO_DSTOPTS);\n\tif (unlikely(ret < 0)) {\n\t\tSKB_DR_SET(reason, XFRM_POLICY);\n\t\tgoto discard;\n\t}\n\n\tif (skb_cloned(skb)) {\n\t\tif (pskb_expand_head(skb, 0, 0, GFP_ATOMIC))\n\t\t\tgoto discard;\n\n\t\t \n\t\thao = (struct ipv6_destopt_hao *)(skb_network_header(skb) +\n\t\t\t\t\t\t  optoff);\n\t\tipv6h = ipv6_hdr(skb);\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\tswap(ipv6h->saddr, hao->addr);\n\n\tif (skb->tstamp == 0)\n\t\t__net_timestamp(skb);\n\n\treturn true;\n\n discard:\n\tkfree_skb_reason(skb, reason);\n\treturn false;\n}\n#endif\n\nstatic int ipv6_destopt_rcv(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t__u16 dstbuf;\n#endif\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tint extlen;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) ||\n\t    !pskb_may_pull(skb, (skb_transport_offset(skb) +\n\t\t\t\t ((skb_transport_header(skb)[1] + 1) << 3)))) {\n\t\t__IP6_INC_STATS(dev_net(dst->dev), idev,\n\t\t\t\tIPSTATS_MIB_INHDRERRORS);\nfail_and_free:\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\textlen = (skb_transport_header(skb)[1] + 1) << 3;\n\tif (extlen > net->ipv6.sysctl.max_dst_opts_len)\n\t\tgoto fail_and_free;\n\n\topt->lastopt = opt->dst1 = skb_network_header_len(skb);\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\tdstbuf = opt->dst1;\n#endif\n\n\tif (ip6_parse_tlv(false, skb, net->ipv6.sysctl.max_dst_opts_cnt)) {\n\t\tskb->transport_header += extlen;\n\t\topt = IP6CB(skb);\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\topt->nhoff = dstbuf;\n#else\n\t\topt->nhoff = opt->dst1;\n#endif\n\t\treturn 1;\n\t}\n\n\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\treturn -1;\n}\n\nstatic void seg6_update_csum(struct sk_buff *skb)\n{\n\tstruct ipv6_sr_hdr *hdr;\n\tstruct in6_addr *addr;\n\t__be32 from, to;\n\n\t \n\n\thdr = (struct ipv6_sr_hdr *)skb_transport_header(skb);\n\taddr = hdr->segments + hdr->segments_left;\n\n\thdr->segments_left++;\n\tfrom = *(__be32 *)hdr;\n\n\thdr->segments_left--;\n\tto = *(__be32 *)hdr;\n\n\t \n\n\tupdate_csum_diff4(skb, from, to);\n\n\t \n\n\tupdate_csum_diff16(skb, (__be32 *)(&ipv6_hdr(skb)->daddr),\n\t\t\t   (__be32 *)addr);\n}\n\nstatic int ipv6_srh_rcv(struct sk_buff *skb)\n{\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct ipv6_sr_hdr *hdr;\n\tstruct inet6_dev *idev;\n\tstruct in6_addr *addr;\n\tint accept_seg6;\n\n\thdr = (struct ipv6_sr_hdr *)skb_transport_header(skb);\n\n\tidev = __in6_dev_get(skb->dev);\n\n\taccept_seg6 = net->ipv6.devconf_all->seg6_enabled;\n\tif (accept_seg6 > idev->cnf.seg6_enabled)\n\t\taccept_seg6 = idev->cnf.seg6_enabled;\n\n\tif (!accept_seg6) {\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\tif (!seg6_hmac_validate_skb(skb)) {\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n#endif\n\nlooped_back:\n\tif (hdr->segments_left == 0) {\n\t\tif (hdr->nexthdr == NEXTHDR_IPV6 || hdr->nexthdr == NEXTHDR_IPV4) {\n\t\t\tint offset = (hdr->hdrlen + 1) << 3;\n\n\t\t\tskb_postpull_rcsum(skb, skb_network_header(skb),\n\t\t\t\t\t   skb_network_header_len(skb));\n\t\t\tskb_pull(skb, offset);\n\t\t\tskb_postpull_rcsum(skb, skb_transport_header(skb),\n\t\t\t\t\t   offset);\n\n\t\t\tskb_reset_network_header(skb);\n\t\t\tskb_reset_transport_header(skb);\n\t\t\tskb->encapsulation = 0;\n\t\t\tif (hdr->nexthdr == NEXTHDR_IPV4)\n\t\t\t\tskb->protocol = htons(ETH_P_IP);\n\t\t\t__skb_tunnel_rx(skb, skb->dev, net);\n\n\t\t\tnetif_rx(skb);\n\t\t\treturn -1;\n\t\t}\n\n\t\topt->srcrt = skb_network_header_len(skb);\n\t\topt->lastopt = opt->srcrt;\n\t\tskb->transport_header += (hdr->hdrlen + 1) << 3;\n\t\topt->nhoff = (&hdr->nexthdr) - skb_network_header(skb);\n\n\t\treturn 1;\n\t}\n\n\tif (hdr->segments_left >= (hdr->hdrlen >> 1)) {\n\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t  ((&hdr->segments_left) -\n\t\t\t\t   skb_network_header(skb)));\n\t\treturn -1;\n\t}\n\n\tif (skb_cloned(skb)) {\n\t\tif (pskb_expand_head(skb, 0, 0, GFP_ATOMIC)) {\n\t\t\t__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\tIPSTATS_MIB_OUTDISCARDS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\n\t\thdr = (struct ipv6_sr_hdr *)skb_transport_header(skb);\n\t}\n\n\thdr->segments_left--;\n\taddr = hdr->segments + hdr->segments_left;\n\n\tskb_push(skb, sizeof(struct ipv6hdr));\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tseg6_update_csum(skb);\n\n\tipv6_hdr(skb)->daddr = *addr;\n\n\tip6_route_input(skb);\n\n\tif (skb_dst(skb)->error) {\n\t\tdst_input(skb);\n\t\treturn -1;\n\t}\n\n\tif (skb_dst(skb)->dev->flags & IFF_LOOPBACK) {\n\t\tif (ipv6_hdr(skb)->hop_limit <= 1) {\n\t\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\t\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED,\n\t\t\t\t    ICMPV6_EXC_HOPLIMIT, 0);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tipv6_hdr(skb)->hop_limit--;\n\n\t\tskb_pull(skb, sizeof(struct ipv6hdr));\n\t\tgoto looped_back;\n\t}\n\n\tdst_input(skb);\n\n\treturn -1;\n}\n\nstatic int ipv6_rpl_srh_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6_rpl_sr_hdr *hdr, *ohdr, *chdr;\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct inet6_dev *idev;\n\tstruct ipv6hdr *oldhdr;\n\tunsigned char *buf;\n\tint accept_rpl_seg;\n\tint i, err;\n\tu64 n = 0;\n\tu32 r;\n\n\tidev = __in6_dev_get(skb->dev);\n\n\taccept_rpl_seg = net->ipv6.devconf_all->rpl_seg_enabled;\n\tif (accept_rpl_seg > idev->cnf.rpl_seg_enabled)\n\t\taccept_rpl_seg = idev->cnf.rpl_seg_enabled;\n\n\tif (!accept_rpl_seg) {\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\nlooped_back:\n\thdr = (struct ipv6_rpl_sr_hdr *)skb_transport_header(skb);\n\n\tif (hdr->segments_left == 0) {\n\t\tif (hdr->nexthdr == NEXTHDR_IPV6) {\n\t\t\tint offset = (hdr->hdrlen + 1) << 3;\n\n\t\t\tskb_postpull_rcsum(skb, skb_network_header(skb),\n\t\t\t\t\t   skb_network_header_len(skb));\n\t\t\tskb_pull(skb, offset);\n\t\t\tskb_postpull_rcsum(skb, skb_transport_header(skb),\n\t\t\t\t\t   offset);\n\n\t\t\tskb_reset_network_header(skb);\n\t\t\tskb_reset_transport_header(skb);\n\t\t\tskb->encapsulation = 0;\n\n\t\t\t__skb_tunnel_rx(skb, skb->dev, net);\n\n\t\t\tnetif_rx(skb);\n\t\t\treturn -1;\n\t\t}\n\n\t\topt->srcrt = skb_network_header_len(skb);\n\t\topt->lastopt = opt->srcrt;\n\t\tskb->transport_header += (hdr->hdrlen + 1) << 3;\n\t\topt->nhoff = (&hdr->nexthdr) - skb_network_header(skb);\n\n\t\treturn 1;\n\t}\n\n\tn = (hdr->hdrlen << 3) - hdr->pad - (16 - hdr->cmpre);\n\tr = do_div(n, (16 - hdr->cmpri));\n\t \n\tif (r || (n + 1) > 255) {\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\tif (hdr->segments_left > n + 1) {\n\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t  ((&hdr->segments_left) -\n\t\t\t\t   skb_network_header(skb)));\n\t\treturn -1;\n\t}\n\n\thdr->segments_left--;\n\ti = n - hdr->segments_left;\n\n\tbuf = kcalloc(struct_size(hdr, segments.addr, n + 2), 2, GFP_ATOMIC);\n\tif (unlikely(!buf)) {\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\tohdr = (struct ipv6_rpl_sr_hdr *)buf;\n\tipv6_rpl_srh_decompress(ohdr, hdr, &ipv6_hdr(skb)->daddr, n);\n\tchdr = (struct ipv6_rpl_sr_hdr *)(buf + ((ohdr->hdrlen + 1) << 3));\n\n\tif (ipv6_addr_is_multicast(&ohdr->rpl_segaddr[i])) {\n\t\tkfree_skb(skb);\n\t\tkfree(buf);\n\t\treturn -1;\n\t}\n\n\terr = ipv6_chk_rpl_srh_loop(net, ohdr->rpl_segaddr, n + 1);\n\tif (err) {\n\t\ticmpv6_send(skb, ICMPV6_PARAMPROB, 0, 0);\n\t\tkfree_skb(skb);\n\t\tkfree(buf);\n\t\treturn -1;\n\t}\n\n\tswap(ipv6_hdr(skb)->daddr, ohdr->rpl_segaddr[i]);\n\n\tipv6_rpl_srh_compress(chdr, ohdr, &ipv6_hdr(skb)->daddr, n);\n\n\toldhdr = ipv6_hdr(skb);\n\n\tskb_pull(skb, ((hdr->hdrlen + 1) << 3));\n\tskb_postpull_rcsum(skb, oldhdr,\n\t\t\t   sizeof(struct ipv6hdr) + ((hdr->hdrlen + 1) << 3));\n\tif (unlikely(!hdr->segments_left)) {\n\t\tif (pskb_expand_head(skb, sizeof(struct ipv6hdr) + ((chdr->hdrlen + 1) << 3), 0,\n\t\t\t\t     GFP_ATOMIC)) {\n\t\t\t__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)), IPSTATS_MIB_OUTDISCARDS);\n\t\t\tkfree_skb(skb);\n\t\t\tkfree(buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toldhdr = ipv6_hdr(skb);\n\t}\n\tskb_push(skb, ((chdr->hdrlen + 1) << 3) + sizeof(struct ipv6hdr));\n\tskb_reset_network_header(skb);\n\tskb_mac_header_rebuild(skb);\n\tskb_set_transport_header(skb, sizeof(struct ipv6hdr));\n\n\tmemmove(ipv6_hdr(skb), oldhdr, sizeof(struct ipv6hdr));\n\tmemcpy(skb_transport_header(skb), chdr, (chdr->hdrlen + 1) << 3);\n\n\tipv6_hdr(skb)->payload_len = htons(skb->len - sizeof(struct ipv6hdr));\n\tskb_postpush_rcsum(skb, ipv6_hdr(skb),\n\t\t\t   sizeof(struct ipv6hdr) + ((chdr->hdrlen + 1) << 3));\n\n\tkfree(buf);\n\n\tip6_route_input(skb);\n\n\tif (skb_dst(skb)->error) {\n\t\tdst_input(skb);\n\t\treturn -1;\n\t}\n\n\tif (skb_dst(skb)->dev->flags & IFF_LOOPBACK) {\n\t\tif (ipv6_hdr(skb)->hop_limit <= 1) {\n\t\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\t\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED,\n\t\t\t\t    ICMPV6_EXC_HOPLIMIT, 0);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tipv6_hdr(skb)->hop_limit--;\n\n\t\tskb_pull(skb, sizeof(struct ipv6hdr));\n\t\tgoto looped_back;\n\t}\n\n\tdst_input(skb);\n\n\treturn -1;\n}\n\n \n\n \nstatic int ipv6_rthdr_rcv(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct in6_addr *addr = NULL;\n\tint n, i;\n\tstruct ipv6_rt_hdr *hdr;\n\tstruct rt0_hdr *rthdr;\n\tstruct net *net = dev_net(skb->dev);\n\tint accept_source_route = net->ipv6.devconf_all->accept_source_route;\n\n\tif (idev && accept_source_route > idev->cnf.accept_source_route)\n\t\taccept_source_route = idev->cnf.accept_source_route;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + 8) ||\n\t    !pskb_may_pull(skb, (skb_transport_offset(skb) +\n\t\t\t\t ((skb_transport_header(skb)[1] + 1) << 3)))) {\n\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\thdr = (struct ipv6_rt_hdr *)skb_transport_header(skb);\n\n\tif (ipv6_addr_is_multicast(&ipv6_hdr(skb)->daddr) ||\n\t    skb->pkt_type != PACKET_HOST) {\n\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INADDRERRORS);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\tswitch (hdr->type) {\n\tcase IPV6_SRCRT_TYPE_4:\n\t\t \n\t\treturn ipv6_srh_rcv(skb);\n\tcase IPV6_SRCRT_TYPE_3:\n\t\t \n\t\treturn ipv6_rpl_srh_rcv(skb);\n\tdefault:\n\t\tbreak;\n\t}\n\nlooped_back:\n\tif (hdr->segments_left == 0) {\n\t\tswitch (hdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tcase IPV6_SRCRT_TYPE_2:\n\t\t\t \n\t\t\tif (!addr) {\n\t\t\t\t__IP6_INC_STATS(net, idev,\n\t\t\t\t\t\tIPSTATS_MIB_INADDRERRORS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\topt->lastopt = opt->srcrt = skb_network_header_len(skb);\n\t\tskb->transport_header += (hdr->hdrlen + 1) << 3;\n\t\topt->dst0 = opt->dst1;\n\t\topt->dst1 = 0;\n\t\topt->nhoff = (&hdr->nexthdr) - skb_network_header(skb);\n\t\treturn 1;\n\t}\n\n\tswitch (hdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\tcase IPV6_SRCRT_TYPE_2:\n\t\tif (accept_source_route < 0)\n\t\t\tgoto unknown_rh;\n\t\t \n\t\tif (hdr->hdrlen != 2 || hdr->segments_left != 1) {\n\t\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tgoto unknown_rh;\n\t}\n\n\t \n\n\tn = hdr->hdrlen >> 1;\n\n\tif (hdr->segments_left > n) {\n\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t\t  ((&hdr->segments_left) -\n\t\t\t\t   skb_network_header(skb)));\n\t\treturn -1;\n\t}\n\n\t \n\tif (skb_cloned(skb)) {\n\t\t \n\t\tif (pskb_expand_head(skb, 0, 0, GFP_ATOMIC)) {\n\t\t\t__IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),\n\t\t\t\t\tIPSTATS_MIB_OUTDISCARDS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\thdr = (struct ipv6_rt_hdr *)skb_transport_header(skb);\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE)\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\ti = n - --hdr->segments_left;\n\n\trthdr = (struct rt0_hdr *) hdr;\n\taddr = rthdr->addr;\n\taddr += i - 1;\n\n\tswitch (hdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\tcase IPV6_SRCRT_TYPE_2:\n\t\tif (xfrm6_input_addr(skb, (xfrm_address_t *)addr,\n\t\t\t\t     (xfrm_address_t *)&ipv6_hdr(skb)->saddr,\n\t\t\t\t     IPPROTO_ROUTING) < 0) {\n\t\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INADDRERRORS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!ipv6_chk_home_addr(dev_net(skb_dst(skb)->dev), addr)) {\n\t\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INADDRERRORS);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ipv6_addr_is_multicast(addr)) {\n\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INADDRERRORS);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\tswap(*addr, ipv6_hdr(skb)->daddr);\n\n\tip6_route_input(skb);\n\tif (skb_dst(skb)->error) {\n\t\tskb_push(skb, skb->data - skb_network_header(skb));\n\t\tdst_input(skb);\n\t\treturn -1;\n\t}\n\n\tif (skb_dst(skb)->dev->flags&IFF_LOOPBACK) {\n\t\tif (ipv6_hdr(skb)->hop_limit <= 1) {\n\t\t\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\t\t\ticmpv6_send(skb, ICMPV6_TIME_EXCEED, ICMPV6_EXC_HOPLIMIT,\n\t\t\t\t    0);\n\t\t\tkfree_skb(skb);\n\t\t\treturn -1;\n\t\t}\n\t\tipv6_hdr(skb)->hop_limit--;\n\t\tgoto looped_back;\n\t}\n\n\tskb_push(skb, skb->data - skb_network_header(skb));\n\tdst_input(skb);\n\treturn -1;\n\nunknown_rh:\n\t__IP6_INC_STATS(net, idev, IPSTATS_MIB_INHDRERRORS);\n\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD,\n\t\t\t  (&hdr->type) - skb_network_header(skb));\n\treturn -1;\n}\n\nstatic const struct inet6_protocol rthdr_protocol = {\n\t.handler\t=\tipv6_rthdr_rcv,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\nstatic const struct inet6_protocol destopt_protocol = {\n\t.handler\t=\tipv6_destopt_rcv,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\nstatic const struct inet6_protocol nodata_protocol = {\n\t.handler\t=\tdst_discard,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\nint __init ipv6_exthdrs_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&rthdr_protocol, IPPROTO_ROUTING);\n\tif (ret)\n\t\tgoto out;\n\n\tret = inet6_add_protocol(&destopt_protocol, IPPROTO_DSTOPTS);\n\tif (ret)\n\t\tgoto out_rthdr;\n\n\tret = inet6_add_protocol(&nodata_protocol, IPPROTO_NONE);\n\tif (ret)\n\t\tgoto out_destopt;\n\nout:\n\treturn ret;\nout_destopt:\n\tinet6_del_protocol(&destopt_protocol, IPPROTO_DSTOPTS);\nout_rthdr:\n\tinet6_del_protocol(&rthdr_protocol, IPPROTO_ROUTING);\n\tgoto out;\n};\n\nvoid ipv6_exthdrs_exit(void)\n{\n\tinet6_del_protocol(&nodata_protocol, IPPROTO_NONE);\n\tinet6_del_protocol(&destopt_protocol, IPPROTO_DSTOPTS);\n\tinet6_del_protocol(&rthdr_protocol, IPPROTO_ROUTING);\n}\n\n \n\n \nstatic inline struct net *ipv6_skb_net(struct sk_buff *skb)\n{\n\treturn skb_dst(skb) ? dev_net(skb_dst(skb)->dev) : dev_net(skb->dev);\n}\n\n \n\nstatic bool ipv6_hop_ra(struct sk_buff *skb, int optoff)\n{\n\tconst unsigned char *nh = skb_network_header(skb);\n\n\tif (nh[optoff + 1] == 2) {\n\t\tIP6CB(skb)->flags |= IP6SKB_ROUTERALERT;\n\t\tmemcpy(&IP6CB(skb)->ra, nh + optoff + 2, sizeof(IP6CB(skb)->ra));\n\t\treturn true;\n\t}\n\tnet_dbg_ratelimited(\"ipv6_hop_ra: wrong RA length %d\\n\",\n\t\t\t    nh[optoff + 1]);\n\tkfree_skb_reason(skb, SKB_DROP_REASON_IP_INHDR);\n\treturn false;\n}\n\n \n\nstatic bool ipv6_hop_ioam(struct sk_buff *skb, int optoff)\n{\n\tstruct ioam6_trace_hdr *trace;\n\tstruct ioam6_namespace *ns;\n\tstruct ioam6_hdr *hdr;\n\n\t \n\tif (optoff & 3)\n\t\tgoto drop;\n\n\t \n\tif (!__in6_dev_get(skb->dev)->cnf.ioam6_enabled)\n\t\tgoto ignore;\n\n\t \n\thdr = (struct ioam6_hdr *)(skb_network_header(skb) + optoff);\n\tif (hdr->opt_len < 2)\n\t\tgoto drop;\n\n\tswitch (hdr->type) {\n\tcase IOAM6_TYPE_PREALLOC:\n\t\t \n\t\tif (hdr->opt_len < 2 + sizeof(*trace))\n\t\t\tgoto drop;\n\n\t\t \n\t\ttrace = (struct ioam6_trace_hdr *)((u8 *)hdr + sizeof(*hdr));\n\t\tif (hdr->opt_len < 2 + sizeof(*trace) + trace->remlen * 4)\n\t\t\tgoto drop;\n\n\t\t \n\t\tns = ioam6_namespace(ipv6_skb_net(skb), trace->namespace_id);\n\t\tif (!ns)\n\t\t\tgoto ignore;\n\n\t\tif (!skb_valid_dst(skb))\n\t\t\tip6_route_input(skb);\n\n\t\tioam6_fill_trace_data(skb, ns, trace, true);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nignore:\n\treturn true;\n\ndrop:\n\tkfree_skb_reason(skb, SKB_DROP_REASON_IP_INHDR);\n\treturn false;\n}\n\n \n\nstatic bool ipv6_hop_jumbo(struct sk_buff *skb, int optoff)\n{\n\tconst unsigned char *nh = skb_network_header(skb);\n\tSKB_DR(reason);\n\tu32 pkt_len;\n\n\tif (nh[optoff + 1] != 4 || (optoff & 3) != 2) {\n\t\tnet_dbg_ratelimited(\"ipv6_hop_jumbo: wrong jumbo opt length/alignment %d\\n\",\n\t\t\t\t    nh[optoff+1]);\n\t\tSKB_DR_SET(reason, IP_INHDR);\n\t\tgoto drop;\n\t}\n\n\tpkt_len = ntohl(*(__be32 *)(nh + optoff + 2));\n\tif (pkt_len <= IPV6_MAXPLEN) {\n\t\ticmpv6_param_prob_reason(skb, ICMPV6_HDR_FIELD, optoff + 2,\n\t\t\t\t\t SKB_DROP_REASON_IP_INHDR);\n\t\treturn false;\n\t}\n\tif (ipv6_hdr(skb)->payload_len) {\n\t\ticmpv6_param_prob_reason(skb, ICMPV6_HDR_FIELD, optoff,\n\t\t\t\t\t SKB_DROP_REASON_IP_INHDR);\n\t\treturn false;\n\t}\n\n\tif (pkt_len > skb->len - sizeof(struct ipv6hdr)) {\n\t\tSKB_DR_SET(reason, PKT_TOO_SMALL);\n\t\tgoto drop;\n\t}\n\n\tif (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))\n\t\tgoto drop;\n\n\tIP6CB(skb)->flags |= IP6SKB_JUMBOGRAM;\n\treturn true;\n\ndrop:\n\tkfree_skb_reason(skb, reason);\n\treturn false;\n}\n\n \n\nstatic bool ipv6_hop_calipso(struct sk_buff *skb, int optoff)\n{\n\tconst unsigned char *nh = skb_network_header(skb);\n\n\tif (nh[optoff + 1] < 8)\n\t\tgoto drop;\n\n\tif (nh[optoff + 6] * 4 + 8 > nh[optoff + 1])\n\t\tgoto drop;\n\n\tif (!calipso_validate(skb, nh + optoff))\n\t\tgoto drop;\n\n\treturn true;\n\ndrop:\n\tkfree_skb_reason(skb, SKB_DROP_REASON_IP_INHDR);\n\treturn false;\n}\n\nint ipv6_parse_hopopts(struct sk_buff *skb)\n{\n\tstruct inet6_skb_parm *opt = IP6CB(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tint extlen;\n\n\t \n\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr) + 8) ||\n\t    !pskb_may_pull(skb, (sizeof(struct ipv6hdr) +\n\t\t\t\t ((skb_transport_header(skb)[1] + 1) << 3)))) {\nfail_and_free:\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\textlen = (skb_transport_header(skb)[1] + 1) << 3;\n\tif (extlen > net->ipv6.sysctl.max_hbh_opts_len)\n\t\tgoto fail_and_free;\n\n\topt->flags |= IP6SKB_HOPBYHOP;\n\tif (ip6_parse_tlv(true, skb, net->ipv6.sysctl.max_hbh_opts_cnt)) {\n\t\tskb->transport_header += extlen;\n\t\topt = IP6CB(skb);\n\t\topt->nhoff = sizeof(struct ipv6hdr);\n\t\treturn 1;\n\t}\n\treturn -1;\n}\n\n \n\nstatic void ipv6_push_rthdr0(struct sk_buff *skb, u8 *proto,\n\t\t\t     struct ipv6_rt_hdr *opt,\n\t\t\t     struct in6_addr **addr_p, struct in6_addr *saddr)\n{\n\tstruct rt0_hdr *phdr, *ihdr;\n\tint hops;\n\n\tihdr = (struct rt0_hdr *) opt;\n\n\tphdr = skb_push(skb, (ihdr->rt_hdr.hdrlen + 1) << 3);\n\tmemcpy(phdr, ihdr, sizeof(struct rt0_hdr));\n\n\thops = ihdr->rt_hdr.hdrlen >> 1;\n\n\tif (hops > 1)\n\t\tmemcpy(phdr->addr, ihdr->addr + 1,\n\t\t       (hops - 1) * sizeof(struct in6_addr));\n\n\tphdr->addr[hops - 1] = **addr_p;\n\t*addr_p = ihdr->addr;\n\n\tphdr->rt_hdr.nexthdr = *proto;\n\t*proto = NEXTHDR_ROUTING;\n}\n\nstatic void ipv6_push_rthdr4(struct sk_buff *skb, u8 *proto,\n\t\t\t     struct ipv6_rt_hdr *opt,\n\t\t\t     struct in6_addr **addr_p, struct in6_addr *saddr)\n{\n\tstruct ipv6_sr_hdr *sr_phdr, *sr_ihdr;\n\tint plen, hops;\n\n\tsr_ihdr = (struct ipv6_sr_hdr *)opt;\n\tplen = (sr_ihdr->hdrlen + 1) << 3;\n\n\tsr_phdr = skb_push(skb, plen);\n\tmemcpy(sr_phdr, sr_ihdr, sizeof(struct ipv6_sr_hdr));\n\n\thops = sr_ihdr->first_segment + 1;\n\tmemcpy(sr_phdr->segments + 1, sr_ihdr->segments + 1,\n\t       (hops - 1) * sizeof(struct in6_addr));\n\n\tsr_phdr->segments[0] = **addr_p;\n\t*addr_p = &sr_ihdr->segments[sr_ihdr->segments_left];\n\n\tif (sr_ihdr->hdrlen > hops * 2) {\n\t\tint tlvs_offset, tlvs_length;\n\n\t\ttlvs_offset = (1 + hops * 2) << 3;\n\t\ttlvs_length = (sr_ihdr->hdrlen - hops * 2) << 3;\n\t\tmemcpy((char *)sr_phdr + tlvs_offset,\n\t\t       (char *)sr_ihdr + tlvs_offset, tlvs_length);\n\t}\n\n#ifdef CONFIG_IPV6_SEG6_HMAC\n\tif (sr_has_hmac(sr_phdr)) {\n\t\tstruct net *net = NULL;\n\n\t\tif (skb->dev)\n\t\t\tnet = dev_net(skb->dev);\n\t\telse if (skb->sk)\n\t\t\tnet = sock_net(skb->sk);\n\n\t\tWARN_ON(!net);\n\n\t\tif (net)\n\t\t\tseg6_push_hmac(net, saddr, sr_phdr);\n\t}\n#endif\n\n\tsr_phdr->nexthdr = *proto;\n\t*proto = NEXTHDR_ROUTING;\n}\n\nstatic void ipv6_push_rthdr(struct sk_buff *skb, u8 *proto,\n\t\t\t    struct ipv6_rt_hdr *opt,\n\t\t\t    struct in6_addr **addr_p, struct in6_addr *saddr)\n{\n\tswitch (opt->type) {\n\tcase IPV6_SRCRT_TYPE_0:\n\tcase IPV6_SRCRT_STRICT:\n\tcase IPV6_SRCRT_TYPE_2:\n\t\tipv6_push_rthdr0(skb, proto, opt, addr_p, saddr);\n\t\tbreak;\n\tcase IPV6_SRCRT_TYPE_4:\n\t\tipv6_push_rthdr4(skb, proto, opt, addr_p, saddr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ipv6_push_exthdr(struct sk_buff *skb, u8 *proto, u8 type, struct ipv6_opt_hdr *opt)\n{\n\tstruct ipv6_opt_hdr *h = skb_push(skb, ipv6_optlen(opt));\n\n\tmemcpy(h, opt, ipv6_optlen(opt));\n\th->nexthdr = *proto;\n\t*proto = type;\n}\n\nvoid ipv6_push_nfrag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt,\n\t\t\t  u8 *proto,\n\t\t\t  struct in6_addr **daddr, struct in6_addr *saddr)\n{\n\tif (opt->srcrt) {\n\t\tipv6_push_rthdr(skb, proto, opt->srcrt, daddr, saddr);\n\t\t \n\t\tif (opt->dst0opt)\n\t\t\tipv6_push_exthdr(skb, proto, NEXTHDR_DEST, opt->dst0opt);\n\t}\n\tif (opt->hopopt)\n\t\tipv6_push_exthdr(skb, proto, NEXTHDR_HOP, opt->hopopt);\n}\n\nvoid ipv6_push_frag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt, u8 *proto)\n{\n\tif (opt->dst1opt)\n\t\tipv6_push_exthdr(skb, proto, NEXTHDR_DEST, opt->dst1opt);\n}\nEXPORT_SYMBOL(ipv6_push_frag_opts);\n\nstruct ipv6_txoptions *\nipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)\n{\n\tstruct ipv6_txoptions *opt2;\n\n\topt2 = sock_kmalloc(sk, opt->tot_len, GFP_ATOMIC);\n\tif (opt2) {\n\t\tlong dif = (char *)opt2 - (char *)opt;\n\t\tmemcpy(opt2, opt, opt->tot_len);\n\t\tif (opt2->hopopt)\n\t\t\t*((char **)&opt2->hopopt) += dif;\n\t\tif (opt2->dst0opt)\n\t\t\t*((char **)&opt2->dst0opt) += dif;\n\t\tif (opt2->dst1opt)\n\t\t\t*((char **)&opt2->dst1opt) += dif;\n\t\tif (opt2->srcrt)\n\t\t\t*((char **)&opt2->srcrt) += dif;\n\t\trefcount_set(&opt2->refcnt, 1);\n\t}\n\treturn opt2;\n}\nEXPORT_SYMBOL_GPL(ipv6_dup_options);\n\nstatic void ipv6_renew_option(int renewtype,\n\t\t\t      struct ipv6_opt_hdr **dest,\n\t\t\t      struct ipv6_opt_hdr *old,\n\t\t\t      struct ipv6_opt_hdr *new,\n\t\t\t      int newtype, char **p)\n{\n\tstruct ipv6_opt_hdr *src;\n\n\tsrc = (renewtype == newtype ? new : old);\n\tif (!src)\n\t\treturn;\n\n\tmemcpy(*p, src, ipv6_optlen(src));\n\t*dest = (struct ipv6_opt_hdr *)*p;\n\t*p += CMSG_ALIGN(ipv6_optlen(*dest));\n}\n\n \nstruct ipv6_txoptions *\nipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,\n\t\t   int newtype, struct ipv6_opt_hdr *newopt)\n{\n\tint tot_len = 0;\n\tchar *p;\n\tstruct ipv6_txoptions *opt2;\n\n\tif (opt) {\n\t\tif (newtype != IPV6_HOPOPTS && opt->hopopt)\n\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->hopopt));\n\t\tif (newtype != IPV6_RTHDRDSTOPTS && opt->dst0opt)\n\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst0opt));\n\t\tif (newtype != IPV6_RTHDR && opt->srcrt)\n\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->srcrt));\n\t\tif (newtype != IPV6_DSTOPTS && opt->dst1opt)\n\t\t\ttot_len += CMSG_ALIGN(ipv6_optlen(opt->dst1opt));\n\t}\n\n\tif (newopt)\n\t\ttot_len += CMSG_ALIGN(ipv6_optlen(newopt));\n\n\tif (!tot_len)\n\t\treturn NULL;\n\n\ttot_len += sizeof(*opt2);\n\topt2 = sock_kmalloc(sk, tot_len, GFP_ATOMIC);\n\tif (!opt2)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\tmemset(opt2, 0, tot_len);\n\trefcount_set(&opt2->refcnt, 1);\n\topt2->tot_len = tot_len;\n\tp = (char *)(opt2 + 1);\n\n\tipv6_renew_option(IPV6_HOPOPTS, &opt2->hopopt,\n\t\t\t  (opt ? opt->hopopt : NULL),\n\t\t\t  newopt, newtype, &p);\n\tipv6_renew_option(IPV6_RTHDRDSTOPTS, &opt2->dst0opt,\n\t\t\t  (opt ? opt->dst0opt : NULL),\n\t\t\t  newopt, newtype, &p);\n\tipv6_renew_option(IPV6_RTHDR,\n\t\t\t  (struct ipv6_opt_hdr **)&opt2->srcrt,\n\t\t\t  (opt ? (struct ipv6_opt_hdr *)opt->srcrt : NULL),\n\t\t\t  newopt, newtype, &p);\n\tipv6_renew_option(IPV6_DSTOPTS, &opt2->dst1opt,\n\t\t\t  (opt ? opt->dst1opt : NULL),\n\t\t\t  newopt, newtype, &p);\n\n\topt2->opt_nflen = (opt2->hopopt ? ipv6_optlen(opt2->hopopt) : 0) +\n\t\t\t  (opt2->dst0opt ? ipv6_optlen(opt2->dst0opt) : 0) +\n\t\t\t  (opt2->srcrt ? ipv6_optlen(opt2->srcrt) : 0);\n\topt2->opt_flen = (opt2->dst1opt ? ipv6_optlen(opt2->dst1opt) : 0);\n\n\treturn opt2;\n}\n\nstruct ipv6_txoptions *__ipv6_fixup_options(struct ipv6_txoptions *opt_space,\n\t\t\t\t\t    struct ipv6_txoptions *opt)\n{\n\t \n\tif (opt->dst0opt && !opt->srcrt) {\n\t\tif (opt_space != opt) {\n\t\t\tmemcpy(opt_space, opt, sizeof(*opt_space));\n\t\t\topt = opt_space;\n\t\t}\n\t\topt->opt_nflen -= ipv6_optlen(opt->dst0opt);\n\t\topt->dst0opt = NULL;\n\t}\n\n\treturn opt;\n}\nEXPORT_SYMBOL_GPL(__ipv6_fixup_options);\n\n \nstruct in6_addr *fl6_update_dst(struct flowi6 *fl6,\n\t\t\t\tconst struct ipv6_txoptions *opt,\n\t\t\t\tstruct in6_addr *orig)\n{\n\tif (!opt || !opt->srcrt)\n\t\treturn NULL;\n\n\t*orig = fl6->daddr;\n\n\tswitch (opt->srcrt->type) {\n\tcase IPV6_SRCRT_TYPE_0:\n\tcase IPV6_SRCRT_STRICT:\n\tcase IPV6_SRCRT_TYPE_2:\n\t\tfl6->daddr = *((struct rt0_hdr *)opt->srcrt)->addr;\n\t\tbreak;\n\tcase IPV6_SRCRT_TYPE_4:\n\t{\n\t\tstruct ipv6_sr_hdr *srh = (struct ipv6_sr_hdr *)opt->srcrt;\n\n\t\tfl6->daddr = srh->segments[srh->segments_left];\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn orig;\n}\nEXPORT_SYMBOL_GPL(fl6_update_dst);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}