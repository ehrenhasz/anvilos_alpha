{
  "module_name": "tcp_ipv6.c",
  "hash_id": "618c05cf4cccad2c44aec59950fa41760def8e73cd9050917477cbe5c59a025d",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/tcp_ipv6.c",
  "human_readable_source": "\n \n\n#include <linux/bottom_half.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/jiffies.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/jhash.h>\n#include <linux/ipsec.h>\n#include <linux/times.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/random.h>\n#include <linux/indirect_call_wrapper.h>\n\n#include <net/tcp.h>\n#include <net/ndisc.h>\n#include <net/inet6_hashtables.h>\n#include <net/inet6_connection_sock.h>\n#include <net/ipv6.h>\n#include <net/transp_v6.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/ip6_checksum.h>\n#include <net/inet_ecn.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n#include <net/snmp.h>\n#include <net/dsfield.h>\n#include <net/timewait_sock.h>\n#include <net/inet_common.h>\n#include <net/secure_seq.h>\n#include <net/busy_poll.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n\n#include <crypto/hash.h>\n#include <linux/scatterlist.h>\n\n#include <trace/events/tcp.h>\n\nstatic void\ttcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb);\nstatic void\ttcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t      struct request_sock *req);\n\nINDIRECT_CALLABLE_SCOPE int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb);\n\nstatic const struct inet_connection_sock_af_ops ipv6_mapped;\nconst struct inet_connection_sock_af_ops ipv6_specific;\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific;\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific;\n#else\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr,\n\t\t\t\t\t\t   int l3index)\n{\n\treturn NULL;\n}\n#endif\n\n \n#define tcp_inet6_sk(sk) (&container_of_const(tcp_sk(sk), \\\n\t\t\t\t\t      struct tcp6_sock, tcp)->inet6)\n\nstatic void inet6_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\n\tif (dst && dst_hold_safe(dst)) {\n\t\tconst struct rt6_info *rt = (const struct rt6_info *)dst;\n\n\t\trcu_assign_pointer(sk->sk_rx_dst, dst);\n\t\tsk->sk_rx_dst_ifindex = skb->skb_iif;\n\t\tsk->sk_rx_dst_cookie = rt6_get_cookie(rt);\n\t}\n}\n\nstatic u32 tcp_v6_init_seq(const struct sk_buff *skb)\n{\n\treturn secure_tcpv6_seq(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\tipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\ttcp_hdr(skb)->dest,\n\t\t\t\ttcp_hdr(skb)->source);\n}\n\nstatic u32 tcp_v6_init_ts_off(const struct net *net, const struct sk_buff *skb)\n{\n\treturn secure_tcpv6_ts_off(net, ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t   ipv6_hdr(skb)->saddr.s6_addr32);\n}\n\nstatic int tcp_v6_pre_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t      int addr_len)\n{\n\t \n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tsock_owned_by_me(sk);\n\n\treturn BPF_CGROUP_RUN_PROG_INET6_CONNECT(sk, uaddr);\n}\n\nstatic int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t  int addr_len)\n{\n\tstruct sockaddr_in6 *usin = (struct sockaddr_in6 *) uaddr;\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct in6_addr *saddr = NULL, *final_p, final;\n\tstruct inet_timewait_death_row *tcp_death_row;\n\tstruct ipv6_pinfo *np = tcp_inet6_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6;\n\tint addr_type;\n\tint err;\n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (np->sndflow) {\n\t\tfl6.flowlabel = usin->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\tIP6_ECN_flow_init(fl6.flowlabel);\n\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\tstruct ip6_flowlabel *flowlabel;\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (IS_ERR(flowlabel))\n\t\t\t\treturn -EINVAL;\n\t\t\tfl6_sock_release(flowlabel);\n\t\t}\n\t}\n\n\t \n\n\tif (ipv6_addr_any(&usin->sin6_addr)) {\n\t\tif (ipv6_addr_v4mapped(&sk->sk_v6_rcv_saddr))\n\t\t\tipv6_addr_set_v4mapped(htonl(INADDR_LOOPBACK),\n\t\t\t\t\t       &usin->sin6_addr);\n\t\telse\n\t\t\tusin->sin6_addr = in6addr_loopback;\n\t}\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -ENETUNREACH;\n\n\tif (addr_type&IPV6_ADDR_LINKLOCAL) {\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    usin->sin6_scope_id) {\n\t\t\t \n\t\t\tif (!sk_dev_equal_l3scope(sk, usin->sin6_scope_id))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsk->sk_bound_dev_if = usin->sin6_scope_id;\n\t\t}\n\n\t\t \n\t\tif (!sk->sk_bound_dev_if)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tp->rx_opt.ts_recent_stamp &&\n\t    !ipv6_addr_equal(&sk->sk_v6_daddr, &usin->sin6_addr)) {\n\t\ttp->rx_opt.ts_recent = 0;\n\t\ttp->rx_opt.ts_recent_stamp = 0;\n\t\tWRITE_ONCE(tp->write_seq, 0);\n\t}\n\n\tsk->sk_v6_daddr = usin->sin6_addr;\n\tnp->flow_label = fl6.flowlabel;\n\n\t \n\n\tif (addr_type & IPV6_ADDR_MAPPED) {\n\t\tu32 exthdrlen = icsk->icsk_ext_hdr_len;\n\t\tstruct sockaddr_in sin;\n\n\t\tif (ipv6_only_sock(sk))\n\t\t\treturn -ENETUNREACH;\n\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = usin->sin6_port;\n\t\tsin.sin_addr.s_addr = usin->sin6_addr.s6_addr32[3];\n\n\t\t \n\t\tWRITE_ONCE(icsk->icsk_af_ops, &ipv6_mapped);\n\t\tif (sk_is_mptcp(sk))\n\t\t\tmptcpv6_handle_mapped(sk, true);\n\t\tsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\ttp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\terr = tcp_v4_connect(sk, (struct sockaddr *)&sin, sizeof(sin));\n\n\t\tif (err) {\n\t\t\ticsk->icsk_ext_hdr_len = exthdrlen;\n\t\t\t \n\t\t\tWRITE_ONCE(icsk->icsk_af_ops, &ipv6_specific);\n\t\t\tif (sk_is_mptcp(sk))\n\t\t\t\tmptcpv6_handle_mapped(sk, false);\n\t\t\tsk->sk_backlog_rcv = tcp_v6_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\t\ttp->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\t\t\tgoto failure;\n\t\t}\n\t\tnp->saddr = sk->sk_v6_rcv_saddr;\n\n\t\treturn err;\n\t}\n\n\tif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tfl6.daddr = sk->sk_v6_daddr;\n\tfl6.saddr = saddr ? *saddr : np->saddr;\n\tfl6.flowlabel = ip6_make_flowinfo(np->tclass, np->flow_label);\n\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tfl6.flowi6_mark = sk->sk_mark;\n\tfl6.fl6_dport = usin->sin6_port;\n\tfl6.fl6_sport = inet->inet_sport;\n\tfl6.flowi6_uid = sk->sk_uid;\n\n\topt = rcu_dereference_protected(np->opt, lockdep_sock_is_held(sk));\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi_common(&fl6));\n\n\tdst = ip6_dst_lookup_flow(net, sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tgoto failure;\n\t}\n\n\ttcp_death_row = &sock_net(sk)->ipv4.tcp_death_row;\n\n\tif (!saddr) {\n\t\tsaddr = &fl6.saddr;\n\n\t\terr = inet_bhash2_update_saddr(sk, saddr, AF_INET6);\n\t\tif (err)\n\t\t\tgoto failure;\n\t}\n\n\t \n\tnp->saddr = *saddr;\n\tinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n\tsk->sk_gso_type = SKB_GSO_TCPV6;\n\tip6_dst_store(sk, dst, NULL, NULL);\n\n\ticsk->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\ticsk->icsk_ext_hdr_len = opt->opt_flen +\n\t\t\t\t\t opt->opt_nflen;\n\n\ttp->rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);\n\n\tinet->inet_dport = usin->sin6_port;\n\n\ttcp_set_state(sk, TCP_SYN_SENT);\n\terr = inet6_hash_connect(tcp_death_row, sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\tsk_set_txhash(sk);\n\n\tif (likely(!tp->repair)) {\n\t\tif (!tp->write_seq)\n\t\t\tWRITE_ONCE(tp->write_seq,\n\t\t\t\t   secure_tcpv6_seq(np->saddr.s6_addr32,\n\t\t\t\t\t\t    sk->sk_v6_daddr.s6_addr32,\n\t\t\t\t\t\t    inet->inet_sport,\n\t\t\t\t\t\t    inet->inet_dport));\n\t\ttp->tsoffset = secure_tcpv6_ts_off(net, np->saddr.s6_addr32,\n\t\t\t\t\t\t   sk->sk_v6_daddr.s6_addr32);\n\t}\n\n\tif (tcp_fastopen_defer_connect(sk, &err))\n\t\treturn err;\n\tif (err)\n\t\tgoto late_failure;\n\n\terr = tcp_connect(sk);\n\tif (err)\n\t\tgoto late_failure;\n\n\treturn 0;\n\nlate_failure:\n\ttcp_set_state(sk, TCP_CLOSE);\n\tinet_bhash2_reset_saddr(sk);\nfailure:\n\tinet->inet_dport = 0;\n\tsk->sk_route_caps = 0;\n\treturn err;\n}\n\nstatic void tcp_v6_mtu_reduced(struct sock *sk)\n{\n\tstruct dst_entry *dst;\n\tu32 mtu;\n\n\tif ((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE))\n\t\treturn;\n\n\tmtu = READ_ONCE(tcp_sk(sk)->mtu_info);\n\n\t \n\tif (tcp_mtu_to_mss(sk, mtu) >= tcp_sk(sk)->mss_cache)\n\t\treturn;\n\n\tdst = inet6_csk_update_pmtu(sk, mtu);\n\tif (!dst)\n\t\treturn;\n\n\tif (inet_csk(sk)->icsk_pmtu_cookie > dst_mtu(dst)) {\n\t\ttcp_sync_mss(sk, dst_mtu(dst));\n\t\ttcp_simple_retransmit(sk);\n\t}\n}\n\nstatic int tcp_v6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\tu8 type, u8 code, int offset, __be32 info)\n{\n\tconst struct ipv6hdr *hdr = (const struct ipv6hdr *)skb->data;\n\tconst struct tcphdr *th = (struct tcphdr *)(skb->data+offset);\n\tstruct net *net = dev_net(skb->dev);\n\tstruct request_sock *fastopen;\n\tstruct ipv6_pinfo *np;\n\tstruct tcp_sock *tp;\n\t__u32 seq, snd_una;\n\tstruct sock *sk;\n\tbool fatal;\n\tint err;\n\n\tsk = __inet6_lookup_established(net, net->ipv4.tcp_death_row.hashinfo,\n\t\t\t\t\t&hdr->daddr, th->dest,\n\t\t\t\t\t&hdr->saddr, ntohs(th->source),\n\t\t\t\t\tskb->dev->ifindex, inet6_sdif(skb));\n\n\tif (!sk) {\n\t\t__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),\n\t\t\t\t  ICMP6_MIB_INERRORS);\n\t\treturn -ENOENT;\n\t}\n\n\tif (sk->sk_state == TCP_TIME_WAIT) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\treturn 0;\n\t}\n\tseq = ntohl(th->seq);\n\tfatal = icmpv6_err_convert(type, code, &err);\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\ttcp_req_err(sk, seq, fatal);\n\t\treturn 0;\n\t}\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk) && type != ICMPV6_PKT_TOOBIG)\n\t\t__NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS);\n\n\tif (sk->sk_state == TCP_CLOSE)\n\t\tgoto out;\n\n\tif (static_branch_unlikely(&ip6_min_hopcount)) {\n\t\t \n\t\tif (ipv6_hdr(skb)->hop_limit < READ_ONCE(tcp_inet6_sk(sk)->min_hopcount)) {\n\t\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttp = tcp_sk(sk);\n\t \n\tfastopen = rcu_dereference(tp->fastopen_rsk);\n\tsnd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una;\n\tif (sk->sk_state != TCP_LISTEN &&\n\t    !between(seq, snd_una, tp->snd_nxt)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS);\n\t\tgoto out;\n\t}\n\n\tnp = tcp_inet6_sk(sk);\n\n\tif (type == NDISC_REDIRECT) {\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tstruct dst_entry *dst = __sk_dst_check(sk, np->dst_cookie);\n\n\t\t\tif (dst)\n\t\t\t\tdst->ops->redirect(dst, sk, skb);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (type == ICMPV6_PKT_TOOBIG) {\n\t\tu32 mtu = ntohl(info);\n\n\t\t \n\t\tif (sk->sk_state == TCP_LISTEN)\n\t\t\tgoto out;\n\n\t\tif (!ip6_sk_accept_pmtu(sk))\n\t\t\tgoto out;\n\n\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\tgoto out;\n\n\t\tWRITE_ONCE(tp->mtu_info, mtu);\n\n\t\tif (!sock_owned_by_user(sk))\n\t\t\ttcp_v6_mtu_reduced(sk);\n\t\telse if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED,\n\t\t\t\t\t   &sk->sk_tsq_flags))\n\t\t\tsock_hold(sk);\n\t\tgoto out;\n\t}\n\n\n\t \n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\tcase TCP_SYN_RECV:\n\t\t \n\t\tif (fastopen && !fastopen->sk)\n\t\t\tbreak;\n\n\t\tipv6_icmp_error(sk, skb, err, th->dest, ntohl(info), (u8 *)th);\n\n\t\tif (!sock_owned_by_user(sk)) {\n\t\t\tWRITE_ONCE(sk->sk_err, err);\n\t\t\tsk_error_report(sk);\t\t \n\n\t\t\ttcp_done(sk);\n\t\t} else {\n\t\t\tWRITE_ONCE(sk->sk_err_soft, err);\n\t\t}\n\t\tgoto out;\n\tcase TCP_LISTEN:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (!fastopen && type == ICMPV6_DEST_UNREACH &&\n\t\t    code == ICMPV6_NOROUTE)\n\t\t\ttcp_ld_RTO_revert(sk, seq);\n\t}\n\n\tif (!sock_owned_by_user(sk) && np->recverr) {\n\t\tWRITE_ONCE(sk->sk_err, err);\n\t\tsk_error_report(sk);\n\t} else {\n\t\tWRITE_ONCE(sk->sk_err_soft, err);\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}\n\n\nstatic int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      enum tcp_synack_type synack_type,\n\t\t\t      struct sk_buff *syn_skb)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = tcp_inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\tu8 tclass;\n\n\t \n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, synack_type, syn_skb);\n\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\n\t\ttclass = READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_reflect_tos) ?\n\t\t\t\t(tcp_rsk(req)->syn_tos & ~INET_ECN_MASK) |\n\t\t\t\t(np->tclass & INET_ECN_MASK) :\n\t\t\t\tnp->tclass;\n\n\t\tif (!INET_ECN_is_capable(tclass) &&\n\t\t    tcp_bpf_ca_needs_ecn((struct sock *)req))\n\t\t\ttclass |= INET_ECN_ECT_0;\n\n\t\trcu_read_lock();\n\t\topt = ireq->ipv6_opt;\n\t\tif (!opt)\n\t\t\topt = rcu_dereference(np->opt);\n\t\terr = ip6_xmit(sk, skb, fl6, skb->mark ? : READ_ONCE(sk->sk_mark),\n\t\t\t       opt, tclass, sk->sk_priority);\n\t\trcu_read_unlock();\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\treturn err;\n}\n\n\nstatic void tcp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tkfree(inet_rsk(req)->ipv6_opt);\n\tconsume_skb(inet_rsk(req)->pktopts);\n}\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic struct tcp_md5sig_key *tcp_v6_md5_do_lookup(const struct sock *sk,\n\t\t\t\t\t\t   const struct in6_addr *addr,\n\t\t\t\t\t\t   int l3index)\n{\n\treturn tcp_md5_do_lookup(sk, l3index,\n\t\t\t\t (union tcp_md5_addr *)addr, AF_INET6);\n}\n\nstatic struct tcp_md5sig_key *tcp_v6_md5_lookup(const struct sock *sk,\n\t\t\t\t\t\tconst struct sock *addr_sk)\n{\n\tint l3index;\n\n\tl3index = l3mdev_master_ifindex_by_index(sock_net(sk),\n\t\t\t\t\t\t addr_sk->sk_bound_dev_if);\n\treturn tcp_v6_md5_do_lookup(sk, &addr_sk->sk_v6_daddr,\n\t\t\t\t    l3index);\n}\n\nstatic int tcp_v6_parse_md5_keys(struct sock *sk, int optname,\n\t\t\t\t sockptr_t optval, int optlen)\n{\n\tstruct tcp_md5sig cmd;\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&cmd.tcpm_addr;\n\tint l3index = 0;\n\tu8 prefixlen;\n\tu8 flags;\n\n\tif (optlen < sizeof(cmd))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&cmd, optval, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (sin6->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\tflags = cmd.tcpm_flags & TCP_MD5SIG_FLAG_IFINDEX;\n\n\tif (optname == TCP_MD5SIG_EXT &&\n\t    cmd.tcpm_flags & TCP_MD5SIG_FLAG_PREFIX) {\n\t\tprefixlen = cmd.tcpm_prefixlen;\n\t\tif (prefixlen > 128 || (ipv6_addr_v4mapped(&sin6->sin6_addr) &&\n\t\t\t\t\tprefixlen > 32))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tprefixlen = ipv6_addr_v4mapped(&sin6->sin6_addr) ? 32 : 128;\n\t}\n\n\tif (optname == TCP_MD5SIG_EXT && cmd.tcpm_ifindex &&\n\t    cmd.tcpm_flags & TCP_MD5SIG_FLAG_IFINDEX) {\n\t\tstruct net_device *dev;\n\n\t\trcu_read_lock();\n\t\tdev = dev_get_by_index_rcu(sock_net(sk), cmd.tcpm_ifindex);\n\t\tif (dev && netif_is_l3_master(dev))\n\t\t\tl3index = dev->ifindex;\n\t\trcu_read_unlock();\n\n\t\t \n\t\tif (!dev || !l3index)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!cmd.tcpm_keylen) {\n\t\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t\t      AF_INET, prefixlen,\n\t\t\t\t\t      l3index, flags);\n\t\treturn tcp_md5_do_del(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t\t      AF_INET6, prefixlen, l3index, flags);\n\t}\n\n\tif (cmd.tcpm_keylen > TCP_MD5SIG_MAXKEYLEN)\n\t\treturn -EINVAL;\n\n\tif (ipv6_addr_v4mapped(&sin6->sin6_addr))\n\t\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr.s6_addr32[3],\n\t\t\t\t      AF_INET, prefixlen, l3index, flags,\n\t\t\t\t      cmd.tcpm_key, cmd.tcpm_keylen);\n\n\treturn tcp_md5_do_add(sk, (union tcp_md5_addr *)&sin6->sin6_addr,\n\t\t\t      AF_INET6, prefixlen, l3index, flags,\n\t\t\t      cmd.tcpm_key, cmd.tcpm_keylen);\n}\n\nstatic int tcp_v6_md5_hash_headers(struct tcp_md5sig_pool *hp,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   const struct in6_addr *saddr,\n\t\t\t\t   const struct tcphdr *th, int nbytes)\n{\n\tstruct tcp6_pseudohdr *bp;\n\tstruct scatterlist sg;\n\tstruct tcphdr *_th;\n\n\tbp = hp->scratch;\n\t \n\tbp->saddr = *saddr;\n\tbp->daddr = *daddr;\n\tbp->protocol = cpu_to_be32(IPPROTO_TCP);\n\tbp->len = cpu_to_be32(nbytes);\n\n\t_th = (struct tcphdr *)(bp + 1);\n\tmemcpy(_th, th, sizeof(*th));\n\t_th->check = 0;\n\n\tsg_init_one(&sg, bp, sizeof(*bp) + sizeof(*th));\n\tahash_request_set_crypt(hp->md5_req, &sg, NULL,\n\t\t\t\tsizeof(*bp) + sizeof(*th));\n\treturn crypto_ahash_update(hp->md5_req);\n}\n\nstatic int tcp_v6_md5_hash_hdr(char *md5_hash, const struct tcp_md5sig_key *key,\n\t\t\t       const struct in6_addr *daddr, struct in6_addr *saddr,\n\t\t\t       const struct tcphdr *th)\n{\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\tif (tcp_v6_md5_hash_headers(hp, daddr, saddr, th, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\nstatic int tcp_v6_md5_hash_skb(char *md5_hash,\n\t\t\t       const struct tcp_md5sig_key *key,\n\t\t\t       const struct sock *sk,\n\t\t\t       const struct sk_buff *skb)\n{\n\tconst struct in6_addr *saddr, *daddr;\n\tstruct tcp_md5sig_pool *hp;\n\tstruct ahash_request *req;\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (sk) {  \n\t\tsaddr = &sk->sk_v6_rcv_saddr;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t} else {\n\t\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t\tsaddr = &ip6h->saddr;\n\t\tdaddr = &ip6h->daddr;\n\t}\n\n\thp = tcp_get_md5sig_pool();\n\tif (!hp)\n\t\tgoto clear_hash_noput;\n\treq = hp->md5_req;\n\n\tif (crypto_ahash_init(req))\n\t\tgoto clear_hash;\n\n\tif (tcp_v6_md5_hash_headers(hp, daddr, saddr, th, skb->len))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_skb_data(hp, skb, th->doff << 2))\n\t\tgoto clear_hash;\n\tif (tcp_md5_hash_key(hp, key))\n\t\tgoto clear_hash;\n\tahash_request_set_crypt(req, NULL, md5_hash, 0);\n\tif (crypto_ahash_final(req))\n\t\tgoto clear_hash;\n\n\ttcp_put_md5sig_pool();\n\treturn 0;\n\nclear_hash:\n\ttcp_put_md5sig_pool();\nclear_hash_noput:\n\tmemset(md5_hash, 0, 16);\n\treturn 1;\n}\n\n#endif\n\nstatic void tcp_v6_init_req(struct request_sock *req,\n\t\t\t    const struct sock *sk_listener,\n\t\t\t    struct sk_buff *skb)\n{\n\tbool l3_slave = ipv6_l3mdev_skb(TCP_SKB_CB(skb)->header.h6.flags);\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = tcp_inet6_sk(sk_listener);\n\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\n\t \n\tif ((!sk_listener->sk_bound_dev_if || l3_slave) &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tif (!TCP_SKB_CB(skb)->tcp_tw_isn &&\n\t    (ipv6_opt_accepted(sk_listener, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t     np->rxopt.bits.rxinfo ||\n\t     np->rxopt.bits.rxoinfo || np->rxopt.bits.rxhlim ||\n\t     np->rxopt.bits.rxohlim || np->repflow)) {\n\t\trefcount_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n}\n\nstatic struct dst_entry *tcp_v6_route_req(const struct sock *sk,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct flowi *fl,\n\t\t\t\t\t  struct request_sock *req)\n{\n\ttcp_v6_init_req(req, sk, skb);\n\n\tif (security_inet_conn_request(sk, skb, req))\n\t\treturn NULL;\n\n\treturn inet6_csk_route_req(sk, &fl->u.ip6, req, IPPROTO_TCP);\n}\n\nstruct request_sock_ops tcp6_request_sock_ops __read_mostly = {\n\t.family\t\t=\tAF_INET6,\n\t.obj_size\t=\tsizeof(struct tcp6_request_sock),\n\t.rtx_syn_ack\t=\ttcp_rtx_synack,\n\t.send_ack\t=\ttcp_v6_reqsk_send_ack,\n\t.destructor\t=\ttcp_v6_reqsk_destructor,\n\t.send_reset\t=\ttcp_v6_send_reset,\n\t.syn_ack_timeout =\ttcp_syn_ack_timeout,\n};\n\nconst struct tcp_request_sock_ops tcp_request_sock_ipv6_ops = {\n\t.mss_clamp\t=\tIPV6_MIN_MTU - sizeof(struct tcphdr) -\n\t\t\t\tsizeof(struct ipv6hdr),\n#ifdef CONFIG_TCP_MD5SIG\n\t.req_md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n#endif\n#ifdef CONFIG_SYN_COOKIES\n\t.cookie_init_seq =\tcookie_v6_init_sequence,\n#endif\n\t.route_req\t=\ttcp_v6_route_req,\n\t.init_seq\t=\ttcp_v6_init_seq,\n\t.init_ts_off\t=\ttcp_v6_init_ts_off,\n\t.send_synack\t=\ttcp_v6_send_synack,\n};\n\nstatic void tcp_v6_send_response(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t\t u32 ack, u32 win, u32 tsval, u32 tsecr,\n\t\t\t\t int oif, struct tcp_md5sig_key *key, int rst,\n\t\t\t\t u8 tclass, __be32 label, u32 priority, u32 txhash)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct tcphdr *t1;\n\tstruct sk_buff *buff;\n\tstruct flowi6 fl6;\n\tstruct net *net = sk ? sock_net(sk) : dev_net(skb_dst(skb)->dev);\n\tstruct sock *ctl_sk = net->ipv6.tcp_sk;\n\tunsigned int tot_len = sizeof(struct tcphdr);\n\t__be32 mrst = 0, *topt;\n\tstruct dst_entry *dst;\n\t__u32 mark = 0;\n\n\tif (tsecr)\n\t\ttot_len += TCPOLEN_TSTAMP_ALIGNED;\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key)\n\t\ttot_len += TCPOLEN_MD5SIG_ALIGNED;\n#endif\n\n#ifdef CONFIG_MPTCP\n\tif (rst && !key) {\n\t\tmrst = mptcp_reset_option(skb);\n\n\t\tif (mrst)\n\t\t\ttot_len += sizeof(__be32);\n\t}\n#endif\n\n\tbuff = alloc_skb(MAX_TCP_HEADER, GFP_ATOMIC);\n\tif (!buff)\n\t\treturn;\n\n\tskb_reserve(buff, MAX_TCP_HEADER);\n\n\tt1 = skb_push(buff, tot_len);\n\tskb_reset_transport_header(buff);\n\n\t \n\tmemset(t1, 0, sizeof(*t1));\n\tt1->dest = th->source;\n\tt1->source = th->dest;\n\tt1->doff = tot_len / 4;\n\tt1->seq = htonl(seq);\n\tt1->ack_seq = htonl(ack);\n\tt1->ack = !rst || !th->ack;\n\tt1->rst = rst;\n\tt1->window = htons(win);\n\n\ttopt = (__be32 *)(t1 + 1);\n\n\tif (tsecr) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_TIMESTAMP << 8) | TCPOLEN_TIMESTAMP);\n\t\t*topt++ = htonl(tsval);\n\t\t*topt++ = htonl(tsecr);\n\t}\n\n\tif (mrst)\n\t\t*topt++ = mrst;\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (key) {\n\t\t*topt++ = htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16) |\n\t\t\t\t(TCPOPT_MD5SIG << 8) | TCPOLEN_MD5SIG);\n\t\ttcp_v6_md5_hash_hdr((__u8 *)topt, key,\n\t\t\t\t    &ipv6_hdr(skb)->saddr,\n\t\t\t\t    &ipv6_hdr(skb)->daddr, t1);\n\t}\n#endif\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = ipv6_hdr(skb)->saddr;\n\tfl6.saddr = ipv6_hdr(skb)->daddr;\n\tfl6.flowlabel = label;\n\n\tbuff->ip_summed = CHECKSUM_PARTIAL;\n\n\t__tcp_v6_send_check(buff, &fl6.saddr, &fl6.daddr);\n\n\tfl6.flowi6_proto = IPPROTO_TCP;\n\tif (rt6_need_strict(&fl6.daddr) && !oif)\n\t\tfl6.flowi6_oif = tcp_v6_iif(skb);\n\telse {\n\t\tif (!oif && netif_index_is_l3_master(net, skb->skb_iif))\n\t\t\toif = skb->skb_iif;\n\n\t\tfl6.flowi6_oif = oif;\n\t}\n\n\tif (sk) {\n\t\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\t\tmark = inet_twsk(sk)->tw_mark;\n\t\telse\n\t\t\tmark = READ_ONCE(sk->sk_mark);\n\t\tskb_set_delivery_time(buff, tcp_transmit_time(sk), true);\n\t}\n\tif (txhash) {\n\t\t \n\t\tskb_set_hash(buff, txhash, PKT_HASH_TYPE_L4);\n\t}\n\tfl6.flowi6_mark = IP6_REPLY_MARK(net, skb->mark) ?: mark;\n\tfl6.fl6_dport = t1->dest;\n\tfl6.fl6_sport = t1->source;\n\tfl6.flowi6_uid = sock_net_uid(net, sk && sk_fullsock(sk) ? sk : NULL);\n\tsecurity_skb_classify_flow(skb, flowi6_to_flowi_common(&fl6));\n\n\t \n\tif (sk && sk->sk_state != TCP_TIME_WAIT)\n\t\tdst = ip6_dst_lookup_flow(net, sk, &fl6, NULL);  \n\telse\n\t\tdst = ip6_dst_lookup_flow(net, ctl_sk, &fl6, NULL);\n\tif (!IS_ERR(dst)) {\n\t\tskb_dst_set(buff, dst);\n\t\tip6_xmit(ctl_sk, buff, &fl6, fl6.flowi6_mark, NULL,\n\t\t\t tclass & ~INET_ECN_MASK, priority);\n\t\tTCP_INC_STATS(net, TCP_MIB_OUTSEGS);\n\t\tif (rst)\n\t\t\tTCP_INC_STATS(net, TCP_MIB_OUTRSTS);\n\t\treturn;\n\t}\n\n\tkfree_skb(buff);\n}\n\nstatic void tcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tstruct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\tu32 seq = 0, ack_seq = 0;\n\tstruct tcp_md5sig_key *key = NULL;\n#ifdef CONFIG_TCP_MD5SIG\n\tconst __u8 *hash_location = NULL;\n\tunsigned char newhash[16];\n\tint genhash;\n\tstruct sock *sk1 = NULL;\n#endif\n\t__be32 label = 0;\n\tu32 priority = 0;\n\tstruct net *net;\n\tu32 txhash = 0;\n\tint oif = 0;\n\n\tif (th->rst)\n\t\treturn;\n\n\t \n\tif (!sk && !ipv6_unicast_destination(skb))\n\t\treturn;\n\n\tnet = sk ? sock_net(sk) : dev_net(skb_dst(skb)->dev);\n#ifdef CONFIG_TCP_MD5SIG\n\trcu_read_lock();\n\thash_location = tcp_parse_md5sig_option(th);\n\tif (sk && sk_fullsock(sk)) {\n\t\tint l3index;\n\n\t\t \n\t\tl3index = tcp_v6_sdif(skb) ? tcp_v6_iif_l3_slave(skb) : 0;\n\t\tkey = tcp_v6_md5_do_lookup(sk, &ipv6h->saddr, l3index);\n\t} else if (hash_location) {\n\t\tint dif = tcp_v6_iif_l3_slave(skb);\n\t\tint sdif = tcp_v6_sdif(skb);\n\t\tint l3index;\n\n\t\t \n\t\tsk1 = inet6_lookup_listener(net, net->ipv4.tcp_death_row.hashinfo,\n\t\t\t\t\t    NULL, 0, &ipv6h->saddr, th->source,\n\t\t\t\t\t    &ipv6h->daddr, ntohs(th->source),\n\t\t\t\t\t    dif, sdif);\n\t\tif (!sk1)\n\t\t\tgoto out;\n\n\t\t \n\t\tl3index = tcp_v6_sdif(skb) ? dif : 0;\n\n\t\tkey = tcp_v6_md5_do_lookup(sk1, &ipv6h->saddr, l3index);\n\t\tif (!key)\n\t\t\tgoto out;\n\n\t\tgenhash = tcp_v6_md5_hash_skb(newhash, key, NULL, skb);\n\t\tif (genhash || memcmp(hash_location, newhash, 16) != 0)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (th->ack)\n\t\tseq = ntohl(th->ack_seq);\n\telse\n\t\tack_seq = ntohl(th->seq) + th->syn + th->fin + skb->len -\n\t\t\t  (th->doff << 2);\n\n\tif (sk) {\n\t\toif = sk->sk_bound_dev_if;\n\t\tif (sk_fullsock(sk)) {\n\t\t\tconst struct ipv6_pinfo *np = tcp_inet6_sk(sk);\n\n\t\t\ttrace_tcp_send_reset(sk, skb);\n\t\t\tif (np->repflow)\n\t\t\t\tlabel = ip6_flowlabel(ipv6h);\n\t\t\tpriority = sk->sk_priority;\n\t\t\ttxhash = sk->sk_txhash;\n\t\t}\n\t\tif (sk->sk_state == TCP_TIME_WAIT) {\n\t\t\tlabel = cpu_to_be32(inet_twsk(sk)->tw_flowlabel);\n\t\t\tpriority = inet_twsk(sk)->tw_priority;\n\t\t\ttxhash = inet_twsk(sk)->tw_txhash;\n\t\t}\n\t} else {\n\t\tif (net->ipv6.sysctl.flowlabel_reflect & FLOWLABEL_REFLECT_TCP_RESET)\n\t\t\tlabel = ip6_flowlabel(ipv6h);\n\t}\n\n\ttcp_v6_send_response(sk, skb, seq, ack_seq, 0, 0, 0, oif, key, 1,\n\t\t\t     ipv6_get_dsfield(ipv6h), label, priority, txhash);\n\n#ifdef CONFIG_TCP_MD5SIG\nout:\n\trcu_read_unlock();\n#endif\n}\n\nstatic void tcp_v6_send_ack(const struct sock *sk, struct sk_buff *skb, u32 seq,\n\t\t\t    u32 ack, u32 win, u32 tsval, u32 tsecr, int oif,\n\t\t\t    struct tcp_md5sig_key *key, u8 tclass,\n\t\t\t    __be32 label, u32 priority, u32 txhash)\n{\n\ttcp_v6_send_response(sk, skb, seq, ack, win, tsval, tsecr, oif, key, 0,\n\t\t\t     tclass, label, priority, txhash);\n}\n\nstatic void tcp_v6_timewait_ack(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\tstruct tcp_timewait_sock *tcptw = tcp_twsk(sk);\n\n\ttcp_v6_send_ack(sk, skb, tcptw->tw_snd_nxt, tcptw->tw_rcv_nxt,\n\t\t\ttcptw->tw_rcv_wnd >> tw->tw_rcv_wscale,\n\t\t\ttcp_time_stamp_raw() + tcptw->tw_ts_offset,\n\t\t\ttcptw->tw_ts_recent, tw->tw_bound_dev_if, tcp_twsk_md5_key(tcptw),\n\t\t\ttw->tw_tclass, cpu_to_be32(tw->tw_flowlabel), tw->tw_priority,\n\t\t\ttw->tw_txhash);\n\n\tinet_twsk_put(tw);\n}\n\nstatic void tcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t  struct request_sock *req)\n{\n\tint l3index;\n\n\tl3index = tcp_v6_sdif(skb) ? tcp_v6_iif_l3_slave(skb) : 0;\n\n\t \n\t \n\ttcp_v6_send_ack(sk, skb, (sk->sk_state == TCP_LISTEN) ?\n\t\t\ttcp_rsk(req)->snt_isn + 1 : tcp_sk(sk)->snd_nxt,\n\t\t\ttcp_rsk(req)->rcv_nxt,\n\t\t\treq->rsk_rcv_wnd >> inet_rsk(req)->rcv_wscale,\n\t\t\ttcp_time_stamp_raw() + tcp_rsk(req)->ts_off,\n\t\t\tREAD_ONCE(req->ts_recent), sk->sk_bound_dev_if,\n\t\t\ttcp_v6_md5_do_lookup(sk, &ipv6_hdr(skb)->saddr, l3index),\n\t\t\tipv6_get_dsfield(ipv6_hdr(skb)), 0,\n\t\t\tREAD_ONCE(sk->sk_priority),\n\t\t\tREAD_ONCE(tcp_rsk(req)->txhash));\n}\n\n\nstatic struct sock *tcp_v6_cookie_check(struct sock *sk, struct sk_buff *skb)\n{\n#ifdef CONFIG_SYN_COOKIES\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\n\tif (!th->syn)\n\t\tsk = cookie_v6_check(sk, skb);\n#endif\n\treturn sk;\n}\n\nu16 tcp_v6_get_syncookie(struct sock *sk, struct ipv6hdr *iph,\n\t\t\t struct tcphdr *th, u32 *cookie)\n{\n\tu16 mss = 0;\n#ifdef CONFIG_SYN_COOKIES\n\tmss = tcp_get_syncookie_mss(&tcp6_request_sock_ops,\n\t\t\t\t    &tcp_request_sock_ipv6_ops, sk, th);\n\tif (mss) {\n\t\t*cookie = __cookie_v6_init_sequence(iph, th, &mss);\n\t\ttcp_synq_overflow(sk);\n\t}\n#endif\n\treturn mss;\n}\n\nstatic int tcp_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\tgoto drop;\n\n\tif (ipv6_addr_v4mapped(&ipv6_hdr(skb)->saddr)) {\n\t\t__IP6_INC_STATS(sock_net(sk), NULL, IPSTATS_MIB_INHDRERRORS);\n\t\treturn 0;\n\t}\n\n\treturn tcp_conn_request(&tcp6_request_sock_ops,\n\t\t\t\t&tcp_request_sock_ipv6_ops, sk, skb);\n\ndrop:\n\ttcp_listendrop(sk);\n\treturn 0;  \n}\n\nstatic void tcp_v6_restore_cb(struct sk_buff *skb)\n{\n\t \n\tmemmove(IP6CB(skb), &TCP_SKB_CB(skb)->header.h6,\n\t\tsizeof(struct inet6_skb_parm));\n}\n\nstatic struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t struct request_sock *req,\n\t\t\t\t\t struct dst_entry *dst,\n\t\t\t\t\t struct request_sock *req_unhash,\n\t\t\t\t\t bool *own_req)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct ipv6_pinfo *newnp;\n\tconst struct ipv6_pinfo *np = tcp_inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct inet_sock *newinet;\n\tbool found_dup_sk = false;\n\tstruct tcp_sock *newtp;\n\tstruct sock *newsk;\n#ifdef CONFIG_TCP_MD5SIG\n\tstruct tcp_md5sig_key *key;\n\tint l3index;\n#endif\n\tstruct flowi6 fl6;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\t \n\n\t\tnewsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t     req_unhash, own_req);\n\n\t\tif (!newsk)\n\t\t\treturn NULL;\n\n\t\tinet_sk(newsk)->pinet6 = tcp_inet6_sk(newsk);\n\n\t\tnewnp = tcp_inet6_sk(newsk);\n\t\tnewtp = tcp_sk(newsk);\n\n\t\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\t\tnewnp->saddr = newsk->sk_v6_rcv_saddr;\n\n\t\tinet_csk(newsk)->icsk_af_ops = &ipv6_mapped;\n\t\tif (sk_is_mptcp(newsk))\n\t\t\tmptcpv6_handle_mapped(newsk, true);\n\t\tnewsk->sk_backlog_rcv = tcp_v4_do_rcv;\n#ifdef CONFIG_TCP_MD5SIG\n\t\tnewtp->af_specific = &tcp_sock_ipv6_mapped_specific;\n#endif\n\n\t\tnewnp->ipv6_mc_list = NULL;\n\t\tnewnp->ipv6_ac_list = NULL;\n\t\tnewnp->ipv6_fl_list = NULL;\n\t\tnewnp->pktoptions  = NULL;\n\t\tnewnp->opt\t   = NULL;\n\t\tnewnp->mcast_oif   = inet_iif(skb);\n\t\tnewnp->mcast_hops  = ip_hdr(skb)->ttl;\n\t\tnewnp->rcv_flowinfo = 0;\n\t\tif (np->repflow)\n\t\t\tnewnp->flow_label = 0;\n\n\t\t \n\n\t\t \n\t\ttcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);\n\n\t\treturn newsk;\n\t}\n\n\tireq = inet_rsk(req);\n\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto out_overflow;\n\n\tif (!dst) {\n\t\tdst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);\n\t\tif (!dst)\n\t\t\tgoto out;\n\t}\n\n\tnewsk = tcp_create_openreq_child(sk, req, skb);\n\tif (!newsk)\n\t\tgoto out_nonewsk;\n\n\t \n\n\tnewsk->sk_gso_type = SKB_GSO_TCPV6;\n\tip6_dst_store(newsk, dst, NULL, NULL);\n\tinet6_sk_rx_dst_set(newsk, skb);\n\n\tinet_sk(newsk)->pinet6 = tcp_inet6_sk(newsk);\n\n\tnewtp = tcp_sk(newsk);\n\tnewinet = inet_sk(newsk);\n\tnewnp = tcp_inet6_sk(newsk);\n\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\n\tnewsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;\n\tnewnp->saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;\n\tnewsk->sk_bound_dev_if = ireq->ir_iif;\n\n\t \n\tnewinet->inet_opt = NULL;\n\tnewnp->ipv6_mc_list = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\n\t \n\tnewnp->rxopt.all = np->rxopt.all;\n\n\tnewnp->pktoptions = NULL;\n\tnewnp->opt\t  = NULL;\n\tnewnp->mcast_oif  = tcp_v6_iif(skb);\n\tnewnp->mcast_hops = ipv6_hdr(skb)->hop_limit;\n\tnewnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));\n\tif (np->repflow)\n\t\tnewnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));\n\n\t \n\tif (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_reflect_tos))\n\t\tnewnp->tclass = tcp_rsk(req)->syn_tos & ~INET_ECN_MASK;\n\n\t \n\topt = ireq->ipv6_opt;\n\tif (!opt)\n\t\topt = rcu_dereference(np->opt);\n\tif (opt) {\n\t\topt = ipv6_dup_options(newsk, opt);\n\t\tRCU_INIT_POINTER(newnp->opt, opt);\n\t}\n\tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n\tif (opt)\n\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n\t\t\t\t\t\t    opt->opt_flen;\n\n\ttcp_ca_openreq_child(newsk, dst);\n\n\ttcp_sync_mss(newsk, dst_mtu(dst));\n\tnewtp->advmss = tcp_mss_clamp(tcp_sk(sk), dst_metric_advmss(dst));\n\n\ttcp_initialize_rcv_mss(newsk);\n\n\tnewinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;\n\tnewinet->inet_rcv_saddr = LOOPBACK4_IPV6;\n\n#ifdef CONFIG_TCP_MD5SIG\n\tl3index = l3mdev_master_ifindex_by_index(sock_net(sk), ireq->ir_iif);\n\n\t \n\tkey = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr, l3index);\n\tif (key) {\n\t\tconst union tcp_md5_addr *addr;\n\n\t\taddr = (union tcp_md5_addr *)&newsk->sk_v6_daddr;\n\t\tif (tcp_md5_key_copy(newsk, addr, AF_INET6, 128, l3index, key)) {\n\t\t\tinet_csk_prepare_forced_close(newsk);\n\t\t\ttcp_done(newsk);\n\t\t\tgoto out;\n\t\t}\n\t}\n#endif\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tinet_csk_prepare_forced_close(newsk);\n\t\ttcp_done(newsk);\n\t\tgoto out;\n\t}\n\t*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash),\n\t\t\t\t       &found_dup_sk);\n\tif (*own_req) {\n\t\ttcp_move_syn(newtp, req);\n\n\t\t \n\t\tif (ireq->pktopts) {\n\t\t\tnewnp->pktoptions = skb_clone_and_charge_r(ireq->pktopts, newsk);\n\t\t\tconsume_skb(ireq->pktopts);\n\t\t\tireq->pktopts = NULL;\n\t\t\tif (newnp->pktoptions)\n\t\t\t\ttcp_v6_restore_cb(newnp->pktoptions);\n\t\t}\n\t} else {\n\t\tif (!req_unhash && found_dup_sk) {\n\t\t\t \n\t\t\tbh_unlock_sock(newsk);\n\t\t\tsock_put(newsk);\n\t\t\tnewsk = NULL;\n\t\t}\n\t}\n\n\treturn newsk;\n\nout_overflow:\n\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nout_nonewsk:\n\tdst_release(dst);\nout:\n\ttcp_listendrop(sk);\n\treturn NULL;\n}\n\nINDIRECT_CALLABLE_DECLARE(struct dst_entry *ipv4_dst_check(struct dst_entry *,\n\t\t\t\t\t\t\t   u32));\n \nINDIRECT_CALLABLE_SCOPE\nint tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = tcp_inet6_sk(sk);\n\tstruct sk_buff *opt_skb = NULL;\n\tenum skb_drop_reason reason;\n\tstruct tcp_sock *tp;\n\n\t \n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_do_rcv(sk, skb);\n\n\t \n\n\t \n\tif (np->rxopt.all)\n\t\topt_skb = skb_clone_and_charge_r(skb, sk);\n\n\treason = SKB_DROP_REASON_NOT_SPECIFIED;\n\tif (sk->sk_state == TCP_ESTABLISHED) {  \n\t\tstruct dst_entry *dst;\n\n\t\tdst = rcu_dereference_protected(sk->sk_rx_dst,\n\t\t\t\t\t\tlockdep_sock_is_held(sk));\n\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tif (dst) {\n\t\t\tif (sk->sk_rx_dst_ifindex != skb->skb_iif ||\n\t\t\t    INDIRECT_CALL_1(dst->ops->check, ip6_dst_check,\n\t\t\t\t\t    dst, sk->sk_rx_dst_cookie) == NULL) {\n\t\t\t\tRCU_INIT_POINTER(sk->sk_rx_dst, NULL);\n\t\t\t\tdst_release(dst);\n\t\t\t}\n\t\t}\n\n\t\ttcp_rcv_established(sk, skb);\n\t\tif (opt_skb)\n\t\t\tgoto ipv6_pktoptions;\n\t\treturn 0;\n\t}\n\n\tif (tcp_checksum_complete(skb))\n\t\tgoto csum_err;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tstruct sock *nsk = tcp_v6_cookie_check(sk, skb);\n\n\t\tif (!nsk)\n\t\t\tgoto discard;\n\n\t\tif (nsk != sk) {\n\t\t\tif (tcp_child_process(sk, nsk, skb))\n\t\t\t\tgoto reset;\n\t\t\tif (opt_skb)\n\t\t\t\t__kfree_skb(opt_skb);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tsock_rps_save_rxhash(sk, skb);\n\n\tif (tcp_rcv_state_process(sk, skb))\n\t\tgoto reset;\n\tif (opt_skb)\n\t\tgoto ipv6_pktoptions;\n\treturn 0;\n\nreset:\n\ttcp_v6_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb_reason(skb, reason);\n\treturn 0;\ncsum_err:\n\treason = SKB_DROP_REASON_TCP_CSUM;\n\ttrace_tcp_bad_csum(skb);\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\n\tgoto discard;\n\n\nipv6_pktoptions:\n\t \n\ttp = tcp_sk(sk);\n\tif (TCP_SKB_CB(opt_skb)->end_seq == tp->rcv_nxt &&\n\t    !((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {\n\t\tif (np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo)\n\t\t\tnp->mcast_oif = tcp_v6_iif(opt_skb);\n\t\tif (np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim)\n\t\t\tnp->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;\n\t\tif (np->rxopt.bits.rxflow || np->rxopt.bits.rxtclass)\n\t\t\tnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));\n\t\tif (np->repflow)\n\t\t\tnp->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));\n\t\tif (ipv6_opt_accepted(sk, opt_skb, &TCP_SKB_CB(opt_skb)->header.h6)) {\n\t\t\ttcp_v6_restore_cb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, opt_skb);\n\t\t} else {\n\t\t\t__kfree_skb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, NULL);\n\t\t}\n\t}\n\n\tconsume_skb(opt_skb);\n\treturn 0;\n}\n\nstatic void tcp_v6_fill_cb(struct sk_buff *skb, const struct ipv6hdr *hdr,\n\t\t\t   const struct tcphdr *th)\n{\n\t \n\tmemmove(&TCP_SKB_CB(skb)->header.h6, IP6CB(skb),\n\t\tsizeof(struct inet6_skb_parm));\n\tbarrier();\n\n\tTCP_SKB_CB(skb)->seq = ntohl(th->seq);\n\tTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\n\t\t\t\t    skb->len - th->doff*4);\n\tTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\n\tTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)->tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)->ip_dsfield = ipv6_get_dsfield(hdr);\n\tTCP_SKB_CB(skb)->sacked = 0;\n\tTCP_SKB_CB(skb)->has_rxtstamp =\n\t\t\tskb->tstamp || skb_hwtstamps(skb)->hwtstamp;\n}\n\nINDIRECT_CALLABLE_SCOPE int tcp_v6_rcv(struct sk_buff *skb)\n{\n\tenum skb_drop_reason drop_reason;\n\tint sdif = inet6_sdif(skb);\n\tint dif = inet6_iif(skb);\n\tconst struct tcphdr *th;\n\tconst struct ipv6hdr *hdr;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n\tstruct net *net = dev_net(skb->dev);\n\n\tdrop_reason = SKB_DROP_REASON_NOT_SPECIFIED;\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t \n\t__TCP_INC_STATS(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = (const struct tcphdr *)skb->data;\n\n\tif (unlikely(th->doff < sizeof(struct tcphdr) / 4)) {\n\t\tdrop_reason = SKB_DROP_REASON_PKT_TOO_SMALL;\n\t\tgoto bad_packet;\n\t}\n\tif (!pskb_may_pull(skb, th->doff*4))\n\t\tgoto discard_it;\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, ip6_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = (const struct tcphdr *)skb->data;\n\thdr = ipv6_hdr(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(net->ipv4.tcp_death_row.hashinfo, skb, __tcp_hdrlen(th),\n\t\t\t\tth->source, th->dest, inet6_iif(skb), sdif,\n\t\t\t\t&refcounted);\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tbool req_stolen = false;\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\t\tdrop_reason = SKB_DROP_REASON_XFRM_POLICY;\n\t\telse\n\t\t\tdrop_reason = tcp_inbound_md5_hash(sk, skb,\n\t\t\t\t\t\t\t   &hdr->saddr, &hdr->daddr,\n\t\t\t\t\t\t\t   AF_INET6, dif, sdif);\n\t\tif (drop_reason) {\n\t\t\tsk_drops_add(sk, skb);\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (tcp_checksum_complete(skb)) {\n\t\t\treqsk_put(req);\n\t\t\tgoto csum_error;\n\t\t}\n\t\tif (unlikely(sk->sk_state != TCP_LISTEN)) {\n\t\t\tnsk = reuseport_migrate_sock(sk, req_to_sk(req), skb);\n\t\t\tif (!nsk) {\n\t\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\t\tgoto lookup;\n\t\t\t}\n\t\t\tsk = nsk;\n\t\t\t \n\t\t} else {\n\t\t\tsock_hold(sk);\n\t\t}\n\t\trefcounted = true;\n\t\tnsk = NULL;\n\t\tif (!tcp_filter(sk, skb)) {\n\t\t\tth = (const struct tcphdr *)skb->data;\n\t\t\thdr = ipv6_hdr(skb);\n\t\t\ttcp_v6_fill_cb(skb, hdr, th);\n\t\t\tnsk = tcp_check_req(sk, skb, req, false, &req_stolen);\n\t\t} else {\n\t\t\tdrop_reason = SKB_DROP_REASON_SOCKET_FILTER;\n\t\t}\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tif (req_stolen) {\n\t\t\t\t \n\t\t\t\ttcp_v6_restore_cb(skb);\n\t\t\t\tsock_put(sk);\n\t\t\t\tgoto lookup;\n\t\t\t}\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tnf_reset_ct(skb);\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v6_send_reset(nsk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (static_branch_unlikely(&ip6_min_hopcount)) {\n\t\t \n\t\tif (unlikely(hdr->hop_limit < READ_ONCE(tcp_inet6_sk(sk)->min_hopcount))) {\n\t\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\t\tdrop_reason = SKB_DROP_REASON_TCP_MINTTL;\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb)) {\n\t\tdrop_reason = SKB_DROP_REASON_XFRM_POLICY;\n\t\tgoto discard_and_relse;\n\t}\n\n\tdrop_reason = tcp_inbound_md5_hash(sk, skb, &hdr->saddr, &hdr->daddr,\n\t\t\t\t\t   AF_INET6, dif, sdif);\n\tif (drop_reason)\n\t\tgoto discard_and_relse;\n\n\tnf_reset_ct(skb);\n\n\tif (tcp_filter(sk, skb)) {\n\t\tdrop_reason = SKB_DROP_REASON_SOCKET_FILTER;\n\t\tgoto discard_and_relse;\n\t}\n\tth = (const struct tcphdr *)skb->data;\n\thdr = ipv6_hdr(skb);\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v6_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_segs_in(tcp_sk(sk), skb);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tret = tcp_v6_do_rcv(sk, skb);\n\t} else {\n\t\tif (tcp_add_backlog(sk, skb, &drop_reason))\n\t\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\nput_and_return:\n\tif (refcounted)\n\t\tsock_put(sk);\n\treturn ret ? -1 : 0;\n\nno_tcp_socket:\n\tdrop_reason = SKB_DROP_REASON_NO_SOCKET;\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\tdrop_reason = SKB_DROP_REASON_TCP_CSUM;\n\t\ttrace_tcp_bad_csum(skb);\n\t\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\t__TCP_INC_STATS(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v6_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\tSKB_DR_OR(drop_reason, NOT_SPECIFIED);\n\tkfree_skb_reason(skb, drop_reason);\n\treturn 0;\n\ndiscard_and_relse:\n\tsk_drops_add(sk, skb);\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tdrop_reason = SKB_DROP_REASON_XFRM_POLICY;\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN:\n\t{\n\t\tstruct sock *sk2;\n\n\t\tsk2 = inet6_lookup_listener(net, net->ipv4.tcp_death_row.hashinfo,\n\t\t\t\t\t    skb, __tcp_hdrlen(th),\n\t\t\t\t\t    &ipv6_hdr(skb)->saddr, th->source,\n\t\t\t\t\t    &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t    ntohs(th->dest),\n\t\t\t\t\t    tcp_v6_iif_l3_slave(skb),\n\t\t\t\t\t    sdif);\n\t\tif (sk2) {\n\t\t\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\t\t\tinet_twsk_deschedule_put(tw);\n\t\t\tsk = sk2;\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t\trefcounted = false;\n\t\t\tgoto process;\n\t\t}\n\t}\n\t\t \n\t\tfallthrough;\n\tcase TCP_TW_ACK:\n\t\ttcp_v6_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v6_send_reset(sk, skb);\n\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\tcase TCP_TW_SUCCESS:\n\t\t;\n\t}\n\tgoto discard_it;\n}\n\nvoid tcp_v6_early_demux(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct ipv6hdr *hdr;\n\tconst struct tcphdr *th;\n\tstruct sock *sk;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\treturn;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct tcphdr)))\n\t\treturn;\n\n\thdr = ipv6_hdr(skb);\n\tth = tcp_hdr(skb);\n\n\tif (th->doff < sizeof(struct tcphdr) / 4)\n\t\treturn;\n\n\t \n\tsk = __inet6_lookup_established(net, net->ipv4.tcp_death_row.hashinfo,\n\t\t\t\t\t&hdr->saddr, th->source,\n\t\t\t\t\t&hdr->daddr, ntohs(th->dest),\n\t\t\t\t\tinet6_iif(skb), inet6_sdif(skb));\n\tif (sk) {\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_edemux;\n\t\tif (sk_fullsock(sk)) {\n\t\t\tstruct dst_entry *dst = rcu_dereference(sk->sk_rx_dst);\n\n\t\t\tif (dst)\n\t\t\t\tdst = dst_check(dst, sk->sk_rx_dst_cookie);\n\t\t\tif (dst &&\n\t\t\t    sk->sk_rx_dst_ifindex == skb->skb_iif)\n\t\t\t\tskb_dst_set_noref(skb, dst);\n\t\t}\n\t}\n}\n\nstatic struct timewait_sock_ops tcp6_timewait_sock_ops = {\n\t.twsk_obj_size\t= sizeof(struct tcp6_timewait_sock),\n\t.twsk_unique\t= tcp_twsk_unique,\n\t.twsk_destructor = tcp_twsk_destructor,\n};\n\nINDIRECT_CALLABLE_SCOPE void tcp_v6_send_check(struct sock *sk, struct sk_buff *skb)\n{\n\t__tcp_v6_send_check(skb, &sk->sk_v6_rcv_saddr, &sk->sk_v6_daddr);\n}\n\nconst struct inet_connection_sock_af_ops ipv6_specific = {\n\t.queue_xmit\t   = inet6_csk_xmit,\n\t.send_check\t   = tcp_v6_send_check,\n\t.rebuild_header\t   = inet6_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet6_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct ipv6hdr),\n\t.net_frag_header_len = sizeof(struct frag_hdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.mtu_reduced\t   = tcp_v6_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_specific = {\n\t.md5_lookup\t=\ttcp_v6_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v6_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n \nstatic const struct inet_connection_sock_af_ops ipv6_mapped = {\n\t.queue_xmit\t   = ip_queue_xmit,\n\t.send_check\t   = tcp_v4_send_check,\n\t.rebuild_header\t   = inet_sk_rebuild_header,\n\t.sk_rx_dst_set\t   = inet_sk_rx_dst_set,\n\t.conn_request\t   = tcp_v6_conn_request,\n\t.syn_recv_sock\t   = tcp_v6_syn_recv_sock,\n\t.net_header_len\t   = sizeof(struct iphdr),\n\t.setsockopt\t   = ipv6_setsockopt,\n\t.getsockopt\t   = ipv6_getsockopt,\n\t.addr2sockaddr\t   = inet6_csk_addr2sockaddr,\n\t.sockaddr_len\t   = sizeof(struct sockaddr_in6),\n\t.mtu_reduced\t   = tcp_v4_mtu_reduced,\n};\n\n#ifdef CONFIG_TCP_MD5SIG\nstatic const struct tcp_sock_af_ops tcp_sock_ipv6_mapped_specific = {\n\t.md5_lookup\t=\ttcp_v4_md5_lookup,\n\t.calc_md5_hash\t=\ttcp_v4_md5_hash_skb,\n\t.md5_parse\t=\ttcp_v6_parse_md5_keys,\n};\n#endif\n\n \nstatic int tcp_v6_init_sock(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_init_sock(sk);\n\n\ticsk->icsk_af_ops = &ipv6_specific;\n\n#ifdef CONFIG_TCP_MD5SIG\n\ttcp_sk(sk)->af_specific = &tcp_sock_ipv6_specific;\n#endif\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\n \nstatic void get_openreq6(struct seq_file *seq,\n\t\t\t const struct request_sock *req, int i)\n{\n\tlong ttd = req->rsk_timer.expires - jiffies;\n\tconst struct in6_addr *src = &inet_rsk(req)->ir_v6_loc_addr;\n\tconst struct in6_addr *dest = &inet_rsk(req)->ir_v6_rmt_addr;\n\n\tif (ttd < 0)\n\t\tttd = 0;\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3],\n\t\t   inet_rsk(req)->ir_num,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3],\n\t\t   ntohs(inet_rsk(req)->ir_rmt_port),\n\t\t   TCP_SYN_RECV,\n\t\t   0, 0,  \n\t\t   1,    \n\t\t   jiffies_to_clock_t(ttd),\n\t\t   req->num_timeout,\n\t\t   from_kuid_munged(seq_user_ns(seq),\n\t\t\t\t    sock_i_uid(req->rsk_listener)),\n\t\t   0,   \n\t\t   0,  \n\t\t   0, req);\n}\n\nstatic void get_tcp6_sock(struct seq_file *seq, struct sock *sp, int i)\n{\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\tint timer_active;\n\tunsigned long timer_expires;\n\tconst struct inet_sock *inet = inet_sk(sp);\n\tconst struct tcp_sock *tp = tcp_sk(sp);\n\tconst struct inet_connection_sock *icsk = inet_csk(sp);\n\tconst struct fastopen_queue *fastopenq = &icsk->icsk_accept_queue.fastopenq;\n\tint rx_queue;\n\tint state;\n\n\tdest  = &sp->sk_v6_daddr;\n\tsrc   = &sp->sk_v6_rcv_saddr;\n\tdestp = ntohs(inet->inet_dport);\n\tsrcp  = ntohs(inet->inet_sport);\n\n\tif (icsk->icsk_pending == ICSK_TIME_RETRANS ||\n\t    icsk->icsk_pending == ICSK_TIME_REO_TIMEOUT ||\n\t    icsk->icsk_pending == ICSK_TIME_LOSS_PROBE) {\n\t\ttimer_active\t= 1;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {\n\t\ttimer_active\t= 4;\n\t\ttimer_expires\t= icsk->icsk_timeout;\n\t} else if (timer_pending(&sp->sk_timer)) {\n\t\ttimer_active\t= 2;\n\t\ttimer_expires\t= sp->sk_timer.expires;\n\t} else {\n\t\ttimer_active\t= 0;\n\t\ttimer_expires = jiffies;\n\t}\n\n\tstate = inet_sk_state_load(sp);\n\tif (state == TCP_LISTEN)\n\t\trx_queue = READ_ONCE(sp->sk_ack_backlog);\n\telse\n\t\t \n\t\trx_queue = max_t(int, READ_ONCE(tp->rcv_nxt) -\n\t\t\t\t      READ_ONCE(tp->copied_seq), 0);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5u %8d %lu %d %pK %lu %lu %u %u %d\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   state,\n\t\t   READ_ONCE(tp->write_seq) - tp->snd_una,\n\t\t   rx_queue,\n\t\t   timer_active,\n\t\t   jiffies_delta_to_clock_t(timer_expires - jiffies),\n\t\t   icsk->icsk_retransmits,\n\t\t   from_kuid_munged(seq_user_ns(seq), sock_i_uid(sp)),\n\t\t   icsk->icsk_probes_out,\n\t\t   sock_i_ino(sp),\n\t\t   refcount_read(&sp->sk_refcnt), sp,\n\t\t   jiffies_to_clock_t(icsk->icsk_rto),\n\t\t   jiffies_to_clock_t(icsk->icsk_ack.ato),\n\t\t   (icsk->icsk_ack.quick << 1) | inet_csk_in_pingpong_mode(sp),\n\t\t   tcp_snd_cwnd(tp),\n\t\t   state == TCP_LISTEN ?\n\t\t\tfastopenq->max_qlen :\n\t\t\t(tcp_in_initial_slowstart(tp) ? -1 : tp->snd_ssthresh)\n\t\t   );\n}\n\nstatic void get_timewait6_sock(struct seq_file *seq,\n\t\t\t       struct inet_timewait_sock *tw, int i)\n{\n\tlong delta = tw->tw_timer.expires - jiffies;\n\tconst struct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\n\tdest = &tw->tw_v6_daddr;\n\tsrc  = &tw->tw_v6_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(seq,\n\t\t   \"%4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %pK\\n\",\n\t\t   i,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   tw->tw_substate, 0, 0,\n\t\t   3, jiffies_delta_to_clock_t(delta), 0, 0, 0, 0,\n\t\t   refcount_read(&tw->tw_refcnt), tw);\n}\n\nstatic int tcp6_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct tcp_iter_state *st;\n\tstruct sock *sk = v;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq,\n\t\t\t \"  sl  \"\n\t\t\t \"local_address                         \"\n\t\t\t \"remote_address                        \"\n\t\t\t \"st tx_queue rx_queue tr tm->when retrnsmt\"\n\t\t\t \"   uid  timeout inode\\n\");\n\t\tgoto out;\n\t}\n\tst = seq->private;\n\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tget_timewait6_sock(seq, v, st->num);\n\telse if (sk->sk_state == TCP_NEW_SYN_RECV)\n\t\tget_openreq6(seq, v, st->num);\n\telse\n\t\tget_tcp6_sock(seq, v, st->num);\nout:\n\treturn 0;\n}\n\nstatic const struct seq_operations tcp6_seq_ops = {\n\t.show\t\t= tcp6_seq_show,\n\t.start\t\t= tcp_seq_start,\n\t.next\t\t= tcp_seq_next,\n\t.stop\t\t= tcp_seq_stop,\n};\n\nstatic struct tcp_seq_afinfo tcp6_seq_afinfo = {\n\t.family\t\t= AF_INET6,\n};\n\nint __net_init tcp6_proc_init(struct net *net)\n{\n\tif (!proc_create_net_data(\"tcp6\", 0444, net->proc_net, &tcp6_seq_ops,\n\t\t\tsizeof(struct tcp_iter_state), &tcp6_seq_afinfo))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nvoid tcp6_proc_exit(struct net *net)\n{\n\tremove_proc_entry(\"tcp6\", net->proc_net);\n}\n#endif\n\nstruct proto tcpv6_prot = {\n\t.name\t\t\t= \"TCPv6\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.close\t\t\t= tcp_close,\n\t.pre_connect\t\t= tcp_v6_pre_connect,\n\t.connect\t\t= tcp_v6_connect,\n\t.disconnect\t\t= tcp_disconnect,\n\t.accept\t\t\t= inet_csk_accept,\n\t.ioctl\t\t\t= tcp_ioctl,\n\t.init\t\t\t= tcp_v6_init_sock,\n\t.destroy\t\t= tcp_v4_destroy_sock,\n\t.shutdown\t\t= tcp_shutdown,\n\t.setsockopt\t\t= tcp_setsockopt,\n\t.getsockopt\t\t= tcp_getsockopt,\n\t.bpf_bypass_getsockopt\t= tcp_bpf_bypass_getsockopt,\n\t.keepalive\t\t= tcp_set_keepalive,\n\t.recvmsg\t\t= tcp_recvmsg,\n\t.sendmsg\t\t= tcp_sendmsg,\n\t.splice_eof\t\t= tcp_splice_eof,\n\t.backlog_rcv\t\t= tcp_v6_do_rcv,\n\t.release_cb\t\t= tcp_release_cb,\n\t.hash\t\t\t= inet6_hash,\n\t.unhash\t\t\t= inet_unhash,\n\t.get_port\t\t= inet_csk_get_port,\n\t.put_port\t\t= inet_put_port,\n#ifdef CONFIG_BPF_SYSCALL\n\t.psock_update_sk_prot\t= tcp_bpf_update_proto,\n#endif\n\t.enter_memory_pressure\t= tcp_enter_memory_pressure,\n\t.leave_memory_pressure\t= tcp_leave_memory_pressure,\n\t.stream_memory_free\t= tcp_stream_memory_free,\n\t.sockets_allocated\t= &tcp_sockets_allocated,\n\n\t.memory_allocated\t= &tcp_memory_allocated,\n\t.per_cpu_fw_alloc\t= &tcp_memory_per_cpu_fw_alloc,\n\n\t.memory_pressure\t= &tcp_memory_pressure,\n\t.orphan_count\t\t= &tcp_orphan_count,\n\t.sysctl_mem\t\t= sysctl_tcp_mem,\n\t.sysctl_wmem_offset\t= offsetof(struct net, ipv4.sysctl_tcp_wmem),\n\t.sysctl_rmem_offset\t= offsetof(struct net, ipv4.sysctl_tcp_rmem),\n\t.max_header\t\t= MAX_TCP_HEADER,\n\t.obj_size\t\t= sizeof(struct tcp6_sock),\n\t.ipv6_pinfo_offset = offsetof(struct tcp6_sock, inet6),\n\t.slab_flags\t\t= SLAB_TYPESAFE_BY_RCU,\n\t.twsk_prot\t\t= &tcp6_timewait_sock_ops,\n\t.rsk_prot\t\t= &tcp6_request_sock_ops,\n\t.h.hashinfo\t\t= NULL,\n\t.no_autobind\t\t= true,\n\t.diag_destroy\t\t= tcp_abort,\n};\nEXPORT_SYMBOL_GPL(tcpv6_prot);\n\nstatic const struct inet6_protocol tcpv6_protocol = {\n\t.handler\t=\ttcp_v6_rcv,\n\t.err_handler\t=\ttcp_v6_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\nstatic struct inet_protosw tcpv6_protosw = {\n\t.type\t\t=\tSOCK_STREAM,\n\t.protocol\t=\tIPPROTO_TCP,\n\t.prot\t\t=\t&tcpv6_prot,\n\t.ops\t\t=\t&inet6_stream_ops,\n\t.flags\t\t=\tINET_PROTOSW_PERMANENT |\n\t\t\t\tINET_PROTOSW_ICSK,\n};\n\nstatic int __net_init tcpv6_net_init(struct net *net)\n{\n\treturn inet_ctl_sock_create(&net->ipv6.tcp_sk, PF_INET6,\n\t\t\t\t    SOCK_RAW, IPPROTO_TCP, net);\n}\n\nstatic void __net_exit tcpv6_net_exit(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->ipv6.tcp_sk);\n}\n\nstatic void __net_exit tcpv6_net_exit_batch(struct list_head *net_exit_list)\n{\n\ttcp_twsk_purge(net_exit_list, AF_INET6);\n}\n\nstatic struct pernet_operations tcpv6_net_ops = {\n\t.init\t    = tcpv6_net_init,\n\t.exit\t    = tcpv6_net_exit,\n\t.exit_batch = tcpv6_net_exit_batch,\n};\n\nint __init tcpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = inet6_register_protosw(&tcpv6_protosw);\n\tif (ret)\n\t\tgoto out_tcpv6_protocol;\n\n\tret = register_pernet_subsys(&tcpv6_net_ops);\n\tif (ret)\n\t\tgoto out_tcpv6_protosw;\n\n\tret = mptcpv6_init();\n\tif (ret)\n\t\tgoto out_tcpv6_pernet_subsys;\n\nout:\n\treturn ret;\n\nout_tcpv6_pernet_subsys:\n\tunregister_pernet_subsys(&tcpv6_net_ops);\nout_tcpv6_protosw:\n\tinet6_unregister_protosw(&tcpv6_protosw);\nout_tcpv6_protocol:\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n\tgoto out;\n}\n\nvoid tcpv6_exit(void)\n{\n\tunregister_pernet_subsys(&tcpv6_net_ops);\n\tinet6_unregister_protosw(&tcpv6_protosw);\n\tinet6_del_protocol(&tcpv6_protocol, IPPROTO_TCP);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}