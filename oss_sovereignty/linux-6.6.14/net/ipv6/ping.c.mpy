{
  "module_name": "ping.c",
  "hash_id": "71161dc3abecd7e0f955e922f51883639033cd82a1a1ed31fefc5460f0202226",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ping.c",
  "human_readable_source": "\n \n\n#include <net/addrconf.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/protocol.h>\n#include <net/udp.h>\n#include <net/transp_v6.h>\n#include <linux/proc_fs.h>\n#include <linux/bpf-cgroup.h>\n#include <net/ping.h>\n\n \nstatic int dummy_ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len,\n\t\t\t\t int *addr_len)\n{\n\treturn -EAFNOSUPPORT;\n}\nstatic void dummy_ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,\n\t\t\t\t       struct sk_buff *skb)\n{\n}\nstatic int dummy_icmpv6_err_convert(u8 type, u8 code, int *err)\n{\n\treturn -EAFNOSUPPORT;\n}\nstatic void dummy_ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,\n\t\t\t\t  __be16 port, u32 info, u8 *payload) {}\nstatic int dummy_ipv6_chk_addr(struct net *net, const struct in6_addr *addr,\n\t\t\t       const struct net_device *dev, int strict)\n{\n\treturn 0;\n}\n\nstatic int ping_v6_pre_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t       int addr_len)\n{\n\t \n\n\tif (addr_len < SIN6_LEN_RFC2133)\n\t\treturn -EINVAL;\n\n\treturn BPF_CGROUP_RUN_PROG_INET6_CONNECT_LOCK(sk, uaddr);\n}\n\nstatic int ping_v6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct icmp6hdr user_icmph;\n\tint addr_type;\n\tstruct in6_addr *daddr;\n\tint oif = 0;\n\tstruct flowi6 fl6;\n\tint err;\n\tstruct dst_entry *dst;\n\tstruct rt6_info *rt;\n\tstruct pingfakehdr pfh;\n\tstruct ipcm6_cookie ipc6;\n\n\terr = ping_common_sendmsg(AF_INET6, msg, len, &user_icmph,\n\t\t\t\t  sizeof(user_icmph));\n\tif (err)\n\t\treturn err;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (msg->msg_name) {\n\t\tDECLARE_SOCKADDR(struct sockaddr_in6 *, u, msg->msg_name);\n\t\tif (msg->msg_namelen < sizeof(*u))\n\t\t\treturn -EINVAL;\n\t\tif (u->sin6_family != AF_INET6) {\n\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\t\tdaddr = &(u->sin6_addr);\n\t\tif (np->sndflow)\n\t\t\tfl6.flowlabel = u->sin6_flowinfo & IPV6_FLOWINFO_MASK;\n\t\tif (__ipv6_addr_needs_scope_id(ipv6_addr_type(daddr)))\n\t\t\toif = u->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t}\n\n\tif (!oif)\n\t\toif = sk->sk_bound_dev_if;\n\n\tif (!oif)\n\t\toif = np->sticky_pktinfo.ipi6_ifindex;\n\n\tif (!oif && ipv6_addr_is_multicast(daddr))\n\t\toif = np->mcast_oif;\n\telse if (!oif)\n\t\toif = np->ucast_oif;\n\n\taddr_type = ipv6_addr_type(daddr);\n\tif ((__ipv6_addr_needs_scope_id(addr_type) && !oif) ||\n\t    (addr_type & IPV6_ADDR_MAPPED) ||\n\t    (oif && sk->sk_bound_dev_if && oif != sk->sk_bound_dev_if &&\n\t     l3mdev_master_ifindex_by_index(sock_net(sk), oif) != sk->sk_bound_dev_if))\n\t\treturn -EINVAL;\n\n\tipcm6_init_sk(&ipc6, np);\n\tipc6.sockc.tsflags = READ_ONCE(sk->sk_tsflags);\n\tipc6.sockc.mark = READ_ONCE(sk->sk_mark);\n\n\tfl6.flowi6_oif = oif;\n\n\tif (msg->msg_controllen) {\n\t\tstruct ipv6_txoptions opt = {};\n\n\t\topt.tot_len = sizeof(opt);\n\t\tipc6.opt = &opt;\n\n\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, &ipc6);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tipc6.opt = NULL;\n\t}\n\n\tfl6.flowi6_proto = IPPROTO_ICMPV6;\n\tfl6.saddr = np->saddr;\n\tfl6.daddr = *daddr;\n\tfl6.flowi6_mark = ipc6.sockc.mark;\n\tfl6.flowi6_uid = sk->sk_uid;\n\tfl6.fl6_icmp_type = user_icmph.icmp6_type;\n\tfl6.fl6_icmp_code = user_icmph.icmp6_code;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi_common(&fl6));\n\n\tfl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);\n\n\tdst = ip6_sk_dst_lookup_flow(sk, &fl6, daddr, false);\n\tif (IS_ERR(dst))\n\t\treturn PTR_ERR(dst);\n\trt = (struct rt6_info *) dst;\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\telse if (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->ucast_oif;\n\n\tpfh.icmph.type = user_icmph.icmp6_type;\n\tpfh.icmph.code = user_icmph.icmp6_code;\n\tpfh.icmph.checksum = 0;\n\tpfh.icmph.un.echo.id = inet->inet_sport;\n\tpfh.icmph.un.echo.sequence = user_icmph.icmp6_sequence;\n\tpfh.msg = msg;\n\tpfh.wcheck = 0;\n\tpfh.family = AF_INET6;\n\n\tif (ipc6.hlimit < 0)\n\t\tipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\n\n\tlock_sock(sk);\n\terr = ip6_append_data(sk, ping_getfrag, &pfh, len,\n\t\t\t      sizeof(struct icmp6hdr), &ipc6, &fl6, rt,\n\t\t\t      MSG_DONTWAIT);\n\n\tif (err) {\n\t\tICMP6_INC_STATS(sock_net(sk), rt->rt6i_idev,\n\t\t\t\tICMP6_MIB_OUTERRORS);\n\t\tip6_flush_pending_frames(sk);\n\t} else {\n\t\ticmpv6_push_pending_frames(sk, &fl6,\n\t\t\t\t\t   (struct icmp6hdr *)&pfh.icmph, len);\n\t}\n\trelease_sock(sk);\n\n\tdst_release(dst);\n\n\tif (err)\n\t\treturn err;\n\n\treturn len;\n}\n\nstruct proto pingv6_prot = {\n\t.name =\t\t\"PINGv6\",\n\t.owner =\tTHIS_MODULE,\n\t.init =\t\tping_init_sock,\n\t.close =\tping_close,\n\t.pre_connect =\tping_v6_pre_connect,\n\t.connect =\tip6_datagram_connect_v6_only,\n\t.disconnect =\t__udp_disconnect,\n\t.setsockopt =\tipv6_setsockopt,\n\t.getsockopt =\tipv6_getsockopt,\n\t.sendmsg =\tping_v6_sendmsg,\n\t.recvmsg =\tping_recvmsg,\n\t.bind =\t\tping_bind,\n\t.backlog_rcv =\tping_queue_rcv_skb,\n\t.hash =\t\tping_hash,\n\t.unhash =\tping_unhash,\n\t.get_port =\tping_get_port,\n\t.put_port =\tping_unhash,\n\t.obj_size =\tsizeof(struct raw6_sock),\n\t.ipv6_pinfo_offset = offsetof(struct raw6_sock, inet6),\n};\nEXPORT_SYMBOL_GPL(pingv6_prot);\n\nstatic struct inet_protosw pingv6_protosw = {\n\t.type =      SOCK_DGRAM,\n\t.protocol =  IPPROTO_ICMPV6,\n\t.prot =      &pingv6_prot,\n\t.ops =       &inet6_sockraw_ops,\n\t.flags =     INET_PROTOSW_REUSE,\n};\n\n#ifdef CONFIG_PROC_FS\nstatic void *ping_v6_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn ping_seq_start(seq, pos, AF_INET6);\n}\n\nstatic int ping_v6_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, IPV6_SEQ_DGRAM_HEADER);\n\t} else {\n\t\tint bucket = ((struct ping_iter_state *) seq->private)->bucket;\n\t\tstruct inet_sock *inet = inet_sk((struct sock *)v);\n\t\t__u16 srcp = ntohs(inet->inet_sport);\n\t\t__u16 destp = ntohs(inet->inet_dport);\n\t\tip6_dgram_sock_seq_show(seq, v, srcp, destp, bucket);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations ping_v6_seq_ops = {\n\t.start\t\t= ping_v6_seq_start,\n\t.show\t\t= ping_v6_seq_show,\n\t.next\t\t= ping_seq_next,\n\t.stop\t\t= ping_seq_stop,\n};\n\nstatic int __net_init ping_v6_proc_init_net(struct net *net)\n{\n\tif (!proc_create_net(\"icmp6\", 0444, net->proc_net, &ping_v6_seq_ops,\n\t\t\tsizeof(struct ping_iter_state)))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void __net_exit ping_v6_proc_exit_net(struct net *net)\n{\n\tremove_proc_entry(\"icmp6\", net->proc_net);\n}\n\nstatic struct pernet_operations ping_v6_net_ops = {\n\t.init = ping_v6_proc_init_net,\n\t.exit = ping_v6_proc_exit_net,\n};\n#endif\n\nint __init pingv6_init(void)\n{\n#ifdef CONFIG_PROC_FS\n\tint ret = register_pernet_subsys(&ping_v6_net_ops);\n\tif (ret)\n\t\treturn ret;\n#endif\n\tpingv6_ops.ipv6_recv_error = ipv6_recv_error;\n\tpingv6_ops.ip6_datagram_recv_common_ctl = ip6_datagram_recv_common_ctl;\n\tpingv6_ops.ip6_datagram_recv_specific_ctl =\n\t\tip6_datagram_recv_specific_ctl;\n\tpingv6_ops.icmpv6_err_convert = icmpv6_err_convert;\n\tpingv6_ops.ipv6_icmp_error = ipv6_icmp_error;\n\tpingv6_ops.ipv6_chk_addr = ipv6_chk_addr;\n\treturn inet6_register_protosw(&pingv6_protosw);\n}\n\n \nvoid pingv6_exit(void)\n{\n\tpingv6_ops.ipv6_recv_error = dummy_ipv6_recv_error;\n\tpingv6_ops.ip6_datagram_recv_common_ctl = dummy_ip6_datagram_recv_ctl;\n\tpingv6_ops.ip6_datagram_recv_specific_ctl = dummy_ip6_datagram_recv_ctl;\n\tpingv6_ops.icmpv6_err_convert = dummy_icmpv6_err_convert;\n\tpingv6_ops.ipv6_icmp_error = dummy_ipv6_icmp_error;\n\tpingv6_ops.ipv6_chk_addr = dummy_ipv6_chk_addr;\n#ifdef CONFIG_PROC_FS\n\tunregister_pernet_subsys(&ping_v6_net_ops);\n#endif\n\tinet6_unregister_protosw(&pingv6_protosw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}