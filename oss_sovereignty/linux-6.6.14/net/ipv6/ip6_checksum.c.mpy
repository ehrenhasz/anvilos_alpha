{
  "module_name": "ip6_checksum.c",
  "hash_id": "58ca8c6c91205bdb158660d6c2a0bb4cef4dab4c3bcb2115abbb67b9031741fc",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ip6_checksum.c",
  "human_readable_source": "\n#include <net/ip.h>\n#include <net/udp.h>\n#include <net/udplite.h>\n#include <asm/checksum.h>\n\n#ifndef _HAVE_ARCH_IPV6_CSUM\n__sum16 csum_ipv6_magic(const struct in6_addr *saddr,\n\t\t\tconst struct in6_addr *daddr,\n\t\t\t__u32 len, __u8 proto, __wsum csum)\n{\n\n\tint carry;\n\t__u32 ulen;\n\t__u32 uproto;\n\t__u32 sum = (__force u32)csum;\n\n\tsum += (__force u32)saddr->s6_addr32[0];\n\tcarry = (sum < (__force u32)saddr->s6_addr32[0]);\n\tsum += carry;\n\n\tsum += (__force u32)saddr->s6_addr32[1];\n\tcarry = (sum < (__force u32)saddr->s6_addr32[1]);\n\tsum += carry;\n\n\tsum += (__force u32)saddr->s6_addr32[2];\n\tcarry = (sum < (__force u32)saddr->s6_addr32[2]);\n\tsum += carry;\n\n\tsum += (__force u32)saddr->s6_addr32[3];\n\tcarry = (sum < (__force u32)saddr->s6_addr32[3]);\n\tsum += carry;\n\n\tsum += (__force u32)daddr->s6_addr32[0];\n\tcarry = (sum < (__force u32)daddr->s6_addr32[0]);\n\tsum += carry;\n\n\tsum += (__force u32)daddr->s6_addr32[1];\n\tcarry = (sum < (__force u32)daddr->s6_addr32[1]);\n\tsum += carry;\n\n\tsum += (__force u32)daddr->s6_addr32[2];\n\tcarry = (sum < (__force u32)daddr->s6_addr32[2]);\n\tsum += carry;\n\n\tsum += (__force u32)daddr->s6_addr32[3];\n\tcarry = (sum < (__force u32)daddr->s6_addr32[3]);\n\tsum += carry;\n\n\tulen = (__force u32)htonl((__u32) len);\n\tsum += ulen;\n\tcarry = (sum < ulen);\n\tsum += carry;\n\n\tuproto = (__force u32)htonl(proto);\n\tsum += uproto;\n\tcarry = (sum < uproto);\n\tsum += carry;\n\n\treturn csum_fold((__force __wsum)sum);\n}\nEXPORT_SYMBOL(csum_ipv6_magic);\n#endif\n\nint udp6_csum_init(struct sk_buff *skb, struct udphdr *uh, int proto)\n{\n\tint err;\n\n\tUDP_SKB_CB(skb)->partial_cov = 0;\n\tUDP_SKB_CB(skb)->cscov = skb->len;\n\n\tif (proto == IPPROTO_UDPLITE) {\n\t\terr = udplite_checksum_init(skb, uh);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (UDP_SKB_CB(skb)->partial_cov) {\n\t\t\tskb->csum = ip6_compute_pseudo(skb, proto);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\terr = (__force int)skb_checksum_init_zero_check(skb, proto, uh->check,\n\t\t\t\t\t\t\tip6_compute_pseudo);\n\tif (err)\n\t\treturn err;\n\n\tif (skb->ip_summed == CHECKSUM_COMPLETE && !skb->csum_valid) {\n\t\t \n\t\tif (skb->csum_complete_sw)\n\t\t\treturn 1;\n\n\t\t \n\t\tskb_checksum_complete_unset(skb);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(udp6_csum_init);\n\n \nvoid udp6_set_csum(bool nocheck, struct sk_buff *skb,\n\t\t   const struct in6_addr *saddr,\n\t\t   const struct in6_addr *daddr, int len)\n{\n\tstruct udphdr *uh = udp_hdr(skb);\n\n\tif (nocheck)\n\t\tuh->check = 0;\n\telse if (skb_is_gso(skb))\n\t\tuh->check = ~udp_v6_check(len, saddr, daddr, 0);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tuh->check = 0;\n\t\tuh->check = udp_v6_check(len, saddr, daddr, lco_csum(skb));\n\t\tif (uh->check == 0)\n\t\t\tuh->check = CSUM_MANGLED_0;\n\t} else {\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct udphdr, check);\n\t\tuh->check = ~udp_v6_check(len, saddr, daddr, 0);\n\t}\n}\nEXPORT_SYMBOL(udp6_set_csum);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}