{
  "module_name": "xfrm6_input.c",
  "hash_id": "25dde2335662e469405093a45f69e26e1f1dd025d2ba9d85d497c05896cb6412",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/xfrm6_input.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter_ipv6.h>\n#include <net/ipv6.h>\n#include <net/xfrm.h>\n\nint xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi,\n\t\t  struct ip6_tnl *t)\n{\n\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6 = t;\n\tXFRM_SPI_SKB_CB(skb)->family = AF_INET6;\n\tXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct ipv6hdr, daddr);\n\treturn xfrm_input(skb, nexthdr, spi, 0);\n}\nEXPORT_SYMBOL(xfrm6_rcv_spi);\n\nstatic int xfrm6_transport_finish2(struct net *net, struct sock *sk,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tif (xfrm_trans_queue(skb, ip6_rcv_finish)) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\treturn 0;\n}\n\nint xfrm6_transport_finish(struct sk_buff *skb, int async)\n{\n\tstruct xfrm_offload *xo = xfrm_offload(skb);\n\tint nhlen = skb->data - skb_network_header(skb);\n\n\tskb_network_header(skb)[IP6CB(skb)->nhoff] =\n\t\tXFRM_MODE_SKB_CB(skb)->protocol;\n\n#ifndef CONFIG_NETFILTER\n\tif (!async)\n\t\treturn 1;\n#endif\n\n\t__skb_push(skb, nhlen);\n\tipv6_hdr(skb)->payload_len = htons(skb->len - sizeof(struct ipv6hdr));\n\tskb_postpush_rcsum(skb, skb_network_header(skb), nhlen);\n\n\tif (xo && (xo->flags & XFRM_GRO)) {\n\t\tskb_mac_header_rebuild(skb);\n\t\tskb_reset_transport_header(skb);\n\t\treturn 0;\n\t}\n\n\tNF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING,\n\t\tdev_net(skb->dev), NULL, skb, skb->dev, NULL,\n\t\txfrm6_transport_finish2);\n\treturn 0;\n}\n\n \nint xfrm6_udp_encap_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct udphdr *uh;\n\tstruct ipv6hdr *ip6h;\n\tint len;\n\tint ip6hlen = sizeof(struct ipv6hdr);\n\t__u8 *udpdata;\n\t__be32 *udpdata32;\n\tu16 encap_type;\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn xfrm4_udp_encap_rcv(sk, skb);\n\n\tencap_type = READ_ONCE(up->encap_type);\n\t \n\tif (!encap_type)\n\t\treturn 1;\n\n\t \n\tlen = skb->len - sizeof(struct udphdr);\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr) + min(len, 8)))\n\t\treturn 1;\n\n\t \n\tuh = udp_hdr(skb);\n\tudpdata = (__u8 *)uh + sizeof(struct udphdr);\n\tudpdata32 = (__be32 *)udpdata;\n\n\tswitch (encap_type) {\n\tdefault:\n\tcase UDP_ENCAP_ESPINUDP:\n\t\t \n\t\tif (len == 1 && udpdata[0] == 0xff) {\n\t\t\tgoto drop;\n\t\t} else if (len > sizeof(struct ip_esp_hdr) && udpdata32[0] != 0) {\n\t\t\t \n\t\t\tlen = sizeof(struct udphdr);\n\t\t} else\n\t\t\t \n\t\t\treturn 1;\n\t\tbreak;\n\tcase UDP_ENCAP_ESPINUDP_NON_IKE:\n\t\t \n\t\tif (len == 1 && udpdata[0] == 0xff) {\n\t\t\tgoto drop;\n\t\t} else if (len > 2 * sizeof(u32) + sizeof(struct ip_esp_hdr) &&\n\t\t\t   udpdata32[0] == 0 && udpdata32[1] == 0) {\n\n\t\t\t \n\t\t\tlen = sizeof(struct udphdr) + 2 * sizeof(u32);\n\t\t} else\n\t\t\t \n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\n\t \n\tif (skb_unclone(skb, GFP_ATOMIC))\n\t\tgoto drop;\n\n\t \n\tip6h = ipv6_hdr(skb);\n\tip6h->payload_len = htons(ntohs(ip6h->payload_len) - len);\n\tif (skb->len < ip6hlen + len) {\n\t\t \n\t\tgoto drop;\n\t}\n\n\t \n\t__skb_pull(skb, len);\n\tskb_reset_transport_header(skb);\n\n\t \n\treturn xfrm6_rcv_encap(skb, IPPROTO_ESP, 0, encap_type);\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nint xfrm6_rcv_tnl(struct sk_buff *skb, struct ip6_tnl *t)\n{\n\treturn xfrm6_rcv_spi(skb, skb_network_header(skb)[IP6CB(skb)->nhoff],\n\t\t\t     0, t);\n}\nEXPORT_SYMBOL(xfrm6_rcv_tnl);\n\nint xfrm6_rcv(struct sk_buff *skb)\n{\n\treturn xfrm6_rcv_tnl(skb, NULL);\n}\nEXPORT_SYMBOL(xfrm6_rcv);\nint xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,\n\t\t     xfrm_address_t *saddr, u8 proto)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct xfrm_state *x = NULL;\n\tstruct sec_path *sp;\n\tint i = 0;\n\n\tsp = secpath_set(skb);\n\tif (!sp) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINERROR);\n\t\tgoto drop;\n\t}\n\n\tif (1 + sp->len == XFRM_MAX_DEPTH) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINBUFFERERROR);\n\t\tgoto drop;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\txfrm_address_t *dst, *src;\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tdst = daddr;\n\t\t\tsrc = saddr;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tdst = daddr;\n\t\t\tsrc = (xfrm_address_t *)&in6addr_any;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdst = (xfrm_address_t *)&in6addr_any;\n\t\t\tsrc = (xfrm_address_t *)&in6addr_any;\n\t\t\tbreak;\n\t\t}\n\n\t\tx = xfrm_state_lookup_byaddr(net, skb->mark, dst, src, proto, AF_INET6);\n\t\tif (!x)\n\t\t\tcontinue;\n\n\t\tspin_lock(&x->lock);\n\n\t\tif ((!i || (x->props.flags & XFRM_STATE_WILDRECV)) &&\n\t\t    likely(x->km.state == XFRM_STATE_VALID) &&\n\t\t    !xfrm_state_check_expire(x)) {\n\t\t\tspin_unlock(&x->lock);\n\t\t\tif (x->type->input(x, skb) > 0) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tspin_unlock(&x->lock);\n\n\t\txfrm_state_put(x);\n\t\tx = NULL;\n\t}\n\n\tif (!x) {\n\t\tXFRM_INC_STATS(net, LINUX_MIB_XFRMINNOSTATES);\n\t\txfrm_audit_state_notfound_simple(skb, AF_INET6);\n\t\tgoto drop;\n\t}\n\n\tsp->xvec[sp->len++] = x;\n\n\tspin_lock(&x->lock);\n\n\tx->curlft.bytes += skb->len;\n\tx->curlft.packets++;\n\n\tspin_unlock(&x->lock);\n\n\treturn 1;\n\ndrop:\n\treturn -1;\n}\nEXPORT_SYMBOL(xfrm6_input_addr);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}