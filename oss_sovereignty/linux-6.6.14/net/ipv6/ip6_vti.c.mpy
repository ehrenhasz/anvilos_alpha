{
  "module_name": "ip6_vti.c",
  "hash_id": "e2b5828c9524b46380e18c9b01c3c0eab2e3fac405d1fb469f898632cb515e53",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/ip6_vti.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/sockios.h>\n#include <linux/icmp.h>\n#include <linux/if.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/icmpv6.h>\n#include <linux/init.h>\n#include <linux/route.h>\n#include <linux/rtnetlink.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/slab.h>\n#include <linux/hash.h>\n\n#include <linux/uaccess.h>\n#include <linux/atomic.h>\n\n#include <net/icmp.h>\n#include <net/ip.h>\n#include <net/ip_tunnels.h>\n#include <net/ipv6.h>\n#include <net/ip6_route.h>\n#include <net/addrconf.h>\n#include <net/ip6_tunnel.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <linux/etherdevice.h>\n\n#define IP6_VTI_HASH_SIZE_SHIFT  5\n#define IP6_VTI_HASH_SIZE (1 << IP6_VTI_HASH_SIZE_SHIFT)\n\nstatic u32 HASH(const struct in6_addr *addr1, const struct in6_addr *addr2)\n{\n\tu32 hash = ipv6_addr_hash(addr1) ^ ipv6_addr_hash(addr2);\n\n\treturn hash_32(hash, IP6_VTI_HASH_SIZE_SHIFT);\n}\n\nstatic int vti6_dev_init(struct net_device *dev);\nstatic void vti6_dev_setup(struct net_device *dev);\nstatic struct rtnl_link_ops vti6_link_ops __read_mostly;\n\nstatic unsigned int vti6_net_id __read_mostly;\nstruct vti6_net {\n\t \n\tstruct net_device *fb_tnl_dev;\n\t \n\tstruct ip6_tnl __rcu *tnls_r_l[IP6_VTI_HASH_SIZE];\n\tstruct ip6_tnl __rcu *tnls_wc[1];\n\tstruct ip6_tnl __rcu **tnls[2];\n};\n\n#define for_each_vti6_tunnel_rcu(start) \\\n\tfor (t = rcu_dereference(start); t; t = rcu_dereference(t->next))\n\n \nstatic struct ip6_tnl *\nvti6_tnl_lookup(struct net *net, const struct in6_addr *remote,\n\t\tconst struct in6_addr *local)\n{\n\tunsigned int hash = HASH(remote, local);\n\tstruct ip6_tnl *t;\n\tstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\n\tstruct in6_addr any;\n\n\tfor_each_vti6_tunnel_rcu(ip6n->tnls_r_l[hash]) {\n\t\tif (ipv6_addr_equal(local, &t->parms.laddr) &&\n\t\t    ipv6_addr_equal(remote, &t->parms.raddr) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\n\tmemset(&any, 0, sizeof(any));\n\thash = HASH(&any, local);\n\tfor_each_vti6_tunnel_rcu(ip6n->tnls_r_l[hash]) {\n\t\tif (ipv6_addr_equal(local, &t->parms.laddr) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\n\thash = HASH(remote, &any);\n\tfor_each_vti6_tunnel_rcu(ip6n->tnls_r_l[hash]) {\n\t\tif (ipv6_addr_equal(remote, &t->parms.raddr) &&\n\t\t    (t->dev->flags & IFF_UP))\n\t\t\treturn t;\n\t}\n\n\tt = rcu_dereference(ip6n->tnls_wc[0]);\n\tif (t && (t->dev->flags & IFF_UP))\n\t\treturn t;\n\n\treturn NULL;\n}\n\n \nstatic struct ip6_tnl __rcu **\nvti6_tnl_bucket(struct vti6_net *ip6n, const struct __ip6_tnl_parm *p)\n{\n\tconst struct in6_addr *remote = &p->raddr;\n\tconst struct in6_addr *local = &p->laddr;\n\tunsigned int h = 0;\n\tint prio = 0;\n\n\tif (!ipv6_addr_any(remote) || !ipv6_addr_any(local)) {\n\t\tprio = 1;\n\t\th = HASH(remote, local);\n\t}\n\treturn &ip6n->tnls[prio][h];\n}\n\nstatic void\nvti6_tnl_link(struct vti6_net *ip6n, struct ip6_tnl *t)\n{\n\tstruct ip6_tnl __rcu **tp = vti6_tnl_bucket(ip6n, &t->parms);\n\n\trcu_assign_pointer(t->next, rtnl_dereference(*tp));\n\trcu_assign_pointer(*tp, t);\n}\n\nstatic void\nvti6_tnl_unlink(struct vti6_net *ip6n, struct ip6_tnl *t)\n{\n\tstruct ip6_tnl __rcu **tp;\n\tstruct ip6_tnl *iter;\n\n\tfor (tp = vti6_tnl_bucket(ip6n, &t->parms);\n\t     (iter = rtnl_dereference(*tp)) != NULL;\n\t     tp = &iter->next) {\n\t\tif (t == iter) {\n\t\t\trcu_assign_pointer(*tp, t->next);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void vti6_dev_free(struct net_device *dev)\n{\n\tfree_percpu(dev->tstats);\n}\n\nstatic int vti6_tnl_create2(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net *net = dev_net(dev);\n\tstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\n\tint err;\n\n\tdev->rtnl_link_ops = &vti6_link_ops;\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\tgoto out;\n\n\tstrcpy(t->parms.name, dev->name);\n\n\tvti6_tnl_link(ip6n, t);\n\n\treturn 0;\n\nout:\n\treturn err;\n}\n\nstatic struct ip6_tnl *vti6_tnl_create(struct net *net, struct __ip6_tnl_parm *p)\n{\n\tstruct net_device *dev;\n\tstruct ip6_tnl *t;\n\tchar name[IFNAMSIZ];\n\tint err;\n\n\tif (p->name[0]) {\n\t\tif (!dev_valid_name(p->name))\n\t\t\tgoto failed;\n\t\tstrscpy(name, p->name, IFNAMSIZ);\n\t} else {\n\t\tsprintf(name, \"ip6_vti%%d\");\n\t}\n\n\tdev = alloc_netdev(sizeof(*t), name, NET_NAME_UNKNOWN, vti6_dev_setup);\n\tif (!dev)\n\t\tgoto failed;\n\n\tdev_net_set(dev, net);\n\n\tt = netdev_priv(dev);\n\tt->parms = *p;\n\tt->net = dev_net(dev);\n\n\terr = vti6_tnl_create2(dev);\n\tif (err < 0)\n\t\tgoto failed_free;\n\n\treturn t;\n\nfailed_free:\n\tfree_netdev(dev);\nfailed:\n\treturn NULL;\n}\n\n \nstatic struct ip6_tnl *vti6_locate(struct net *net, struct __ip6_tnl_parm *p,\n\t\t\t\t   int create)\n{\n\tconst struct in6_addr *remote = &p->raddr;\n\tconst struct in6_addr *local = &p->laddr;\n\tstruct ip6_tnl __rcu **tp;\n\tstruct ip6_tnl *t;\n\tstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\n\n\tfor (tp = vti6_tnl_bucket(ip6n, p);\n\t     (t = rtnl_dereference(*tp)) != NULL;\n\t     tp = &t->next) {\n\t\tif (ipv6_addr_equal(local, &t->parms.laddr) &&\n\t\t    ipv6_addr_equal(remote, &t->parms.raddr)) {\n\t\t\tif (create)\n\t\t\t\treturn NULL;\n\n\t\t\treturn t;\n\t\t}\n\t}\n\tif (!create)\n\t\treturn NULL;\n\treturn vti6_tnl_create(net, p);\n}\n\n \nstatic void vti6_dev_uninit(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct vti6_net *ip6n = net_generic(t->net, vti6_net_id);\n\n\tif (dev == ip6n->fb_tnl_dev)\n\t\tRCU_INIT_POINTER(ip6n->tnls_wc[0], NULL);\n\telse\n\t\tvti6_tnl_unlink(ip6n, t);\n\tnetdev_put(dev, &t->dev_tracker);\n}\n\nstatic int vti6_input_proto(struct sk_buff *skb, int nexthdr, __be32 spi,\n\t\t\t    int encap_type)\n{\n\tstruct ip6_tnl *t;\n\tconst struct ipv6hdr *ipv6h = ipv6_hdr(skb);\n\n\trcu_read_lock();\n\tt = vti6_tnl_lookup(dev_net(skb->dev), &ipv6h->saddr, &ipv6h->daddr);\n\tif (t) {\n\t\tif (t->parms.proto != IPPROTO_IPV6 && t->parms.proto != 0) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto discard;\n\t\t}\n\n\t\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto discard;\n\t\t}\n\n\t\tipv6h = ipv6_hdr(skb);\n\t\tif (!ip6_tnl_rcv_ctl(t, &ipv6h->daddr, &ipv6h->saddr)) {\n\t\t\tDEV_STATS_INC(t->dev, rx_dropped);\n\t\t\trcu_read_unlock();\n\t\t\tgoto discard;\n\t\t}\n\n\t\trcu_read_unlock();\n\n\t\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6 = t;\n\t\tXFRM_SPI_SKB_CB(skb)->family = AF_INET6;\n\t\tXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct ipv6hdr, daddr);\n\t\treturn xfrm_input(skb, nexthdr, spi, encap_type);\n\t}\n\trcu_read_unlock();\n\treturn -EINVAL;\ndiscard:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int vti6_rcv(struct sk_buff *skb)\n{\n\tint nexthdr = skb_network_header(skb)[IP6CB(skb)->nhoff];\n\n\treturn vti6_input_proto(skb, nexthdr, 0, 0);\n}\n\nstatic int vti6_rcv_cb(struct sk_buff *skb, int err)\n{\n\tunsigned short family;\n\tstruct net_device *dev;\n\tstruct xfrm_state *x;\n\tconst struct xfrm_mode *inner_mode;\n\tstruct ip6_tnl *t = XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6;\n\tu32 orig_mark = skb->mark;\n\tint ret;\n\n\tif (!t)\n\t\treturn 1;\n\n\tdev = t->dev;\n\n\tif (err) {\n\t\tDEV_STATS_INC(dev, rx_errors);\n\t\tDEV_STATS_INC(dev, rx_dropped);\n\n\t\treturn 0;\n\t}\n\n\tx = xfrm_input_state(skb);\n\n\tinner_mode = &x->inner_mode;\n\n\tif (x->sel.family == AF_UNSPEC) {\n\t\tinner_mode = xfrm_ip2inner_mode(x, XFRM_MODE_SKB_CB(skb)->protocol);\n\t\tif (inner_mode == NULL) {\n\t\t\tXFRM_INC_STATS(dev_net(skb->dev),\n\t\t\t\t       LINUX_MIB_XFRMINSTATEMODEERROR);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfamily = inner_mode->family;\n\n\tskb->mark = be32_to_cpu(t->parms.i_key);\n\tret = xfrm_policy_check(NULL, XFRM_POLICY_IN, skb, family);\n\tskb->mark = orig_mark;\n\n\tif (!ret)\n\t\treturn -EPERM;\n\n\tskb_scrub_packet(skb, !net_eq(t->net, dev_net(skb->dev)));\n\tskb->dev = dev;\n\tdev_sw_netstats_rx_add(dev, skb->len);\n\n\treturn 0;\n}\n\n \nstatic inline bool\nvti6_addr_conflict(const struct ip6_tnl *t, const struct ipv6hdr *hdr)\n{\n\treturn ipv6_addr_equal(&t->parms.raddr, &hdr->saddr);\n}\n\nstatic bool vti6_state_check(const struct xfrm_state *x,\n\t\t\t     const struct in6_addr *dst,\n\t\t\t     const struct in6_addr *src)\n{\n\txfrm_address_t *daddr = (xfrm_address_t *)dst;\n\txfrm_address_t *saddr = (xfrm_address_t *)src;\n\n\t \n\tif (!x || x->props.mode != XFRM_MODE_TUNNEL ||\n\t    x->props.family != AF_INET6)\n\t\treturn false;\n\n\tif (ipv6_addr_any(dst))\n\t\treturn xfrm_addr_equal(saddr, &x->props.saddr, AF_INET6);\n\n\tif (!xfrm_state_addr_check(x, daddr, saddr, AF_INET6))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int\nvti6_xmit(struct sk_buff *skb, struct net_device *dev, struct flowi *fl)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net_device *tdev;\n\tstruct xfrm_state *x;\n\tint pkt_len = skb->len;\n\tint err = -1;\n\tint mtu;\n\n\tif (!dst) {\n\t\tswitch (skb->protocol) {\n\t\tcase htons(ETH_P_IP): {\n\t\t\tstruct rtable *rt;\n\n\t\t\tfl->u.ip4.flowi4_oif = dev->ifindex;\n\t\t\tfl->u.ip4.flowi4_flags |= FLOWI_FLAG_ANYSRC;\n\t\t\trt = __ip_route_output_key(dev_net(dev), &fl->u.ip4);\n\t\t\tif (IS_ERR(rt))\n\t\t\t\tgoto tx_err_link_failure;\n\t\t\tdst = &rt->dst;\n\t\t\tskb_dst_set(skb, dst);\n\t\t\tbreak;\n\t\t}\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tfl->u.ip6.flowi6_oif = dev->ifindex;\n\t\t\tfl->u.ip6.flowi6_flags |= FLOWI_FLAG_ANYSRC;\n\t\t\tdst = ip6_route_output(dev_net(dev), NULL, &fl->u.ip6);\n\t\t\tif (dst->error) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tdst = NULL;\n\t\t\t\tgoto tx_err_link_failure;\n\t\t\t}\n\t\t\tskb_dst_set(skb, dst);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto tx_err_link_failure;\n\t\t}\n\t}\n\n\tdst_hold(dst);\n\tdst = xfrm_lookup_route(t->net, dst, fl, NULL, 0);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto tx_err_link_failure;\n\t}\n\n\tif (dst->flags & DST_XFRM_QUEUE)\n\t\tgoto xmit;\n\n\tx = dst->xfrm;\n\tif (!vti6_state_check(x, &t->parms.raddr, &t->parms.laddr))\n\t\tgoto tx_err_link_failure;\n\n\tif (!ip6_tnl_xmit_ctl(t, (const struct in6_addr *)&x->props.saddr,\n\t\t\t      (const struct in6_addr *)&x->id.daddr))\n\t\tgoto tx_err_link_failure;\n\n\ttdev = dst->dev;\n\n\tif (tdev == dev) {\n\t\tDEV_STATS_INC(dev, collisions);\n\t\tnet_warn_ratelimited(\"%s: Local routing loop detected!\\n\",\n\t\t\t\t     t->parms.name);\n\t\tgoto tx_err_dst_release;\n\t}\n\n\tmtu = dst_mtu(dst);\n\tif (skb->len > mtu) {\n\t\tskb_dst_update_pmtu_no_confirm(skb, mtu);\n\n\t\tif (skb->protocol == htons(ETH_P_IPV6)) {\n\t\t\tif (mtu < IPV6_MIN_MTU)\n\t\t\t\tmtu = IPV6_MIN_MTU;\n\n\t\t\ticmpv6_ndo_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\n\t\t} else {\n\t\t\tif (!(ip_hdr(skb)->frag_off & htons(IP_DF)))\n\t\t\t\tgoto xmit;\n\t\t\ticmp_ndo_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,\n\t\t\t\t      htonl(mtu));\n\t\t}\n\n\t\terr = -EMSGSIZE;\n\t\tgoto tx_err_dst_release;\n\t}\n\nxmit:\n\tskb_scrub_packet(skb, !net_eq(t->net, dev_net(dev)));\n\tskb_dst_set(skb, dst);\n\tskb->dev = skb_dst(skb)->dev;\n\n\terr = dst_output(t->net, skb->sk, skb);\n\tif (net_xmit_eval(err) == 0)\n\t\terr = pkt_len;\n\tiptunnel_xmit_stats(dev, err);\n\n\treturn 0;\ntx_err_link_failure:\n\tDEV_STATS_INC(dev, tx_carrier_errors);\n\tdst_link_failure(skb);\ntx_err_dst_release:\n\tdst_release(dst);\n\treturn err;\n}\n\nstatic netdev_tx_t\nvti6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct flowi fl;\n\tint ret;\n\n\tif (!pskb_inet_may_pull(skb))\n\t\tgoto tx_err;\n\n\tmemset(&fl, 0, sizeof(fl));\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IPV6):\n\t\tif ((t->parms.proto != IPPROTO_IPV6 && t->parms.proto != 0) ||\n\t\t    vti6_addr_conflict(t, ipv6_hdr(skb)))\n\t\t\tgoto tx_err;\n\n\t\tmemset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));\n\t\txfrm_decode_session(skb, &fl, AF_INET6);\n\t\tbreak;\n\tcase htons(ETH_P_IP):\n\t\tmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\n\t\txfrm_decode_session(skb, &fl, AF_INET);\n\t\tbreak;\n\tdefault:\n\t\tgoto tx_err;\n\t}\n\n\t \n\tfl.flowi_mark = be32_to_cpu(t->parms.o_key);\n\n\tret = vti6_xmit(skb, dev, &fl);\n\tif (ret < 0)\n\t\tgoto tx_err;\n\n\treturn NETDEV_TX_OK;\n\ntx_err:\n\tDEV_STATS_INC(dev, tx_errors);\n\tDEV_STATS_INC(dev, tx_dropped);\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int vti6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t    u8 type, u8 code, int offset, __be32 info)\n{\n\t__be32 spi;\n\t__u32 mark;\n\tstruct xfrm_state *x;\n\tstruct ip6_tnl *t;\n\tstruct ip_esp_hdr *esph;\n\tstruct ip_auth_hdr *ah;\n\tstruct ip_comp_hdr *ipch;\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct ipv6hdr *iph = (const struct ipv6hdr *)skb->data;\n\tint protocol = iph->nexthdr;\n\n\tt = vti6_tnl_lookup(dev_net(skb->dev), &iph->daddr, &iph->saddr);\n\tif (!t)\n\t\treturn -1;\n\n\tmark = be32_to_cpu(t->parms.o_key);\n\n\tswitch (protocol) {\n\tcase IPPROTO_ESP:\n\t\tesph = (struct ip_esp_hdr *)(skb->data + offset);\n\t\tspi = esph->spi;\n\t\tbreak;\n\tcase IPPROTO_AH:\n\t\tah = (struct ip_auth_hdr *)(skb->data + offset);\n\t\tspi = ah->spi;\n\t\tbreak;\n\tcase IPPROTO_COMP:\n\t\tipch = (struct ip_comp_hdr *)(skb->data + offset);\n\t\tspi = htonl(ntohs(ipch->cpi));\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (type != ICMPV6_PKT_TOOBIG &&\n\t    type != NDISC_REDIRECT)\n\t\treturn 0;\n\n\tx = xfrm_state_lookup(net, mark, (const xfrm_address_t *)&iph->daddr,\n\t\t\t      spi, protocol, AF_INET6);\n\tif (!x)\n\t\treturn 0;\n\n\tif (type == NDISC_REDIRECT)\n\t\tip6_redirect(skb, net, skb->dev->ifindex, 0,\n\t\t\t     sock_net_uid(net, NULL));\n\telse\n\t\tip6_update_pmtu(skb, net, info, 0, 0, sock_net_uid(net, NULL));\n\txfrm_state_put(x);\n\n\treturn 0;\n}\n\nstatic void vti6_link_config(struct ip6_tnl *t, bool keep_mtu)\n{\n\tstruct net_device *dev = t->dev;\n\tstruct __ip6_tnl_parm *p = &t->parms;\n\tstruct net_device *tdev = NULL;\n\tint mtu;\n\n\t__dev_addr_set(dev, &p->laddr, sizeof(struct in6_addr));\n\tmemcpy(dev->broadcast, &p->raddr, sizeof(struct in6_addr));\n\n\tp->flags &= ~(IP6_TNL_F_CAP_XMIT | IP6_TNL_F_CAP_RCV |\n\t\t      IP6_TNL_F_CAP_PER_PACKET);\n\tp->flags |= ip6_tnl_get_cap(t, &p->laddr, &p->raddr);\n\n\tif (p->flags & IP6_TNL_F_CAP_XMIT && p->flags & IP6_TNL_F_CAP_RCV)\n\t\tdev->flags |= IFF_POINTOPOINT;\n\telse\n\t\tdev->flags &= ~IFF_POINTOPOINT;\n\n\tif (keep_mtu && dev->mtu) {\n\t\tdev->mtu = clamp(dev->mtu, dev->min_mtu, dev->max_mtu);\n\t\treturn;\n\t}\n\n\tif (p->flags & IP6_TNL_F_CAP_XMIT) {\n\t\tint strict = (ipv6_addr_type(&p->raddr) &\n\t\t\t      (IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL));\n\t\tstruct rt6_info *rt = rt6_lookup(t->net,\n\t\t\t\t\t\t &p->raddr, &p->laddr,\n\t\t\t\t\t\t p->link, NULL, strict);\n\n\t\tif (rt)\n\t\t\ttdev = rt->dst.dev;\n\t\tip6_rt_put(rt);\n\t}\n\n\tif (!tdev && p->link)\n\t\ttdev = __dev_get_by_index(t->net, p->link);\n\n\tif (tdev)\n\t\tmtu = tdev->mtu - sizeof(struct ipv6hdr);\n\telse\n\t\tmtu = ETH_DATA_LEN - LL_MAX_HEADER - sizeof(struct ipv6hdr);\n\n\tdev->mtu = max_t(int, mtu, IPV4_MIN_MTU);\n}\n\n \nstatic int\nvti6_tnl_change(struct ip6_tnl *t, const struct __ip6_tnl_parm *p,\n\t\tbool keep_mtu)\n{\n\tt->parms.laddr = p->laddr;\n\tt->parms.raddr = p->raddr;\n\tt->parms.link = p->link;\n\tt->parms.i_key = p->i_key;\n\tt->parms.o_key = p->o_key;\n\tt->parms.proto = p->proto;\n\tt->parms.fwmark = p->fwmark;\n\tdst_cache_reset(&t->dst_cache);\n\tvti6_link_config(t, keep_mtu);\n\treturn 0;\n}\n\nstatic int vti6_update(struct ip6_tnl *t, struct __ip6_tnl_parm *p,\n\t\t       bool keep_mtu)\n{\n\tstruct net *net = dev_net(t->dev);\n\tstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\n\tint err;\n\n\tvti6_tnl_unlink(ip6n, t);\n\tsynchronize_net();\n\terr = vti6_tnl_change(t, p, keep_mtu);\n\tvti6_tnl_link(ip6n, t);\n\tnetdev_state_change(t->dev);\n\treturn err;\n}\n\nstatic void\nvti6_parm_from_user(struct __ip6_tnl_parm *p, const struct ip6_tnl_parm2 *u)\n{\n\tp->laddr = u->laddr;\n\tp->raddr = u->raddr;\n\tp->link = u->link;\n\tp->i_key = u->i_key;\n\tp->o_key = u->o_key;\n\tp->proto = u->proto;\n\n\tmemcpy(p->name, u->name, sizeof(u->name));\n}\n\nstatic void\nvti6_parm_to_user(struct ip6_tnl_parm2 *u, const struct __ip6_tnl_parm *p)\n{\n\tu->laddr = p->laddr;\n\tu->raddr = p->raddr;\n\tu->link = p->link;\n\tu->i_key = p->i_key;\n\tu->o_key = p->o_key;\n\tif (u->i_key)\n\t\tu->i_flags |= GRE_KEY;\n\tif (u->o_key)\n\t\tu->o_flags |= GRE_KEY;\n\tu->proto = p->proto;\n\n\tmemcpy(u->name, p->name, sizeof(u->name));\n}\n\n \nstatic int\nvti6_siocdevprivate(struct net_device *dev, struct ifreq *ifr, void __user *data, int cmd)\n{\n\tint err = 0;\n\tstruct ip6_tnl_parm2 p;\n\tstruct __ip6_tnl_parm p1;\n\tstruct ip6_tnl *t = NULL;\n\tstruct net *net = dev_net(dev);\n\tstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\n\n\tmemset(&p1, 0, sizeof(p1));\n\n\tswitch (cmd) {\n\tcase SIOCGETTUNNEL:\n\t\tif (dev == ip6n->fb_tnl_dev) {\n\t\t\tif (copy_from_user(&p, data, sizeof(p))) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvti6_parm_from_user(&p1, &p);\n\t\t\tt = vti6_locate(net, &p1, 0);\n\t\t} else {\n\t\t\tmemset(&p, 0, sizeof(p));\n\t\t}\n\t\tif (!t)\n\t\t\tt = netdev_priv(dev);\n\t\tvti6_parm_to_user(&p, &t->parms);\n\t\tif (copy_to_user(data, &p, sizeof(p)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase SIOCADDTUNNEL:\n\tcase SIOCCHGTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(&p, data, sizeof(p)))\n\t\t\tbreak;\n\t\terr = -EINVAL;\n\t\tif (p.proto != IPPROTO_IPV6  && p.proto != 0)\n\t\t\tbreak;\n\t\tvti6_parm_from_user(&p1, &p);\n\t\tt = vti6_locate(net, &p1, cmd == SIOCADDTUNNEL);\n\t\tif (dev != ip6n->fb_tnl_dev && cmd == SIOCCHGTUNNEL) {\n\t\t\tif (t) {\n\t\t\t\tif (t->dev != dev) {\n\t\t\t\t\terr = -EEXIST;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tt = netdev_priv(dev);\n\n\t\t\terr = vti6_update(t, &p1, false);\n\t\t}\n\t\tif (t) {\n\t\t\terr = 0;\n\t\t\tvti6_parm_to_user(&p, &t->parms);\n\t\t\tif (copy_to_user(data, &p, sizeof(p)))\n\t\t\t\terr = -EFAULT;\n\n\t\t} else\n\t\t\terr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\n\t\tbreak;\n\tcase SIOCDELTUNNEL:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\n\t\tif (dev == ip6n->fb_tnl_dev) {\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(&p, data, sizeof(p)))\n\t\t\t\tbreak;\n\t\t\terr = -ENOENT;\n\t\t\tvti6_parm_from_user(&p1, &p);\n\t\t\tt = vti6_locate(net, &p1, 0);\n\t\t\tif (!t)\n\t\t\t\tbreak;\n\t\t\terr = -EPERM;\n\t\t\tif (t->dev == ip6n->fb_tnl_dev)\n\t\t\t\tbreak;\n\t\t\tdev = t->dev;\n\t\t}\n\t\terr = 0;\n\t\tunregister_netdevice(dev);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic const struct net_device_ops vti6_netdev_ops = {\n\t.ndo_init\t= vti6_dev_init,\n\t.ndo_uninit\t= vti6_dev_uninit,\n\t.ndo_start_xmit = vti6_tnl_xmit,\n\t.ndo_siocdevprivate = vti6_siocdevprivate,\n\t.ndo_get_stats64 = dev_get_tstats64,\n\t.ndo_get_iflink = ip6_tnl_get_iflink,\n};\n\n \nstatic void vti6_dev_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &vti6_netdev_ops;\n\tdev->header_ops = &ip_tunnel_header_ops;\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = vti6_dev_free;\n\n\tdev->type = ARPHRD_TUNNEL6;\n\tdev->min_mtu = IPV4_MIN_MTU;\n\tdev->max_mtu = IP_MAX_MTU - sizeof(struct ipv6hdr);\n\tdev->flags |= IFF_NOARP;\n\tdev->addr_len = sizeof(struct in6_addr);\n\tnetif_keep_dst(dev);\n\t \n\tdev->addr_assign_type = NET_ADDR_RANDOM;\n\teth_random_addr(dev->perm_addr);\n}\n\n \nstatic inline int vti6_dev_init_gen(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\n\tt->dev = dev;\n\tt->net = dev_net(dev);\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\tnetdev_hold(dev, &t->dev_tracker, GFP_KERNEL);\n\treturn 0;\n}\n\n \nstatic int vti6_dev_init(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tint err = vti6_dev_init_gen(dev);\n\n\tif (err)\n\t\treturn err;\n\tvti6_link_config(t, true);\n\treturn 0;\n}\n\n \nstatic int __net_init vti6_fb_tnl_dev_init(struct net_device *dev)\n{\n\tstruct ip6_tnl *t = netdev_priv(dev);\n\tstruct net *net = dev_net(dev);\n\tstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\n\n\tt->parms.proto = IPPROTO_IPV6;\n\n\trcu_assign_pointer(ip6n->tnls_wc[0], t);\n\treturn 0;\n}\n\nstatic int vti6_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn 0;\n}\n\nstatic void vti6_netlink_parms(struct nlattr *data[],\n\t\t\t       struct __ip6_tnl_parm *parms)\n{\n\tmemset(parms, 0, sizeof(*parms));\n\n\tif (!data)\n\t\treturn;\n\n\tif (data[IFLA_VTI_LINK])\n\t\tparms->link = nla_get_u32(data[IFLA_VTI_LINK]);\n\n\tif (data[IFLA_VTI_LOCAL])\n\t\tparms->laddr = nla_get_in6_addr(data[IFLA_VTI_LOCAL]);\n\n\tif (data[IFLA_VTI_REMOTE])\n\t\tparms->raddr = nla_get_in6_addr(data[IFLA_VTI_REMOTE]);\n\n\tif (data[IFLA_VTI_IKEY])\n\t\tparms->i_key = nla_get_be32(data[IFLA_VTI_IKEY]);\n\n\tif (data[IFLA_VTI_OKEY])\n\t\tparms->o_key = nla_get_be32(data[IFLA_VTI_OKEY]);\n\n\tif (data[IFLA_VTI_FWMARK])\n\t\tparms->fwmark = nla_get_u32(data[IFLA_VTI_FWMARK]);\n}\n\nstatic int vti6_newlink(struct net *src_net, struct net_device *dev,\n\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ip6_tnl *nt;\n\n\tnt = netdev_priv(dev);\n\tvti6_netlink_parms(data, &nt->parms);\n\n\tnt->parms.proto = IPPROTO_IPV6;\n\n\tif (vti6_locate(net, &nt->parms, 0))\n\t\treturn -EEXIST;\n\n\treturn vti6_tnl_create2(dev);\n}\n\nstatic void vti6_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\n\n\tif (dev != ip6n->fb_tnl_dev)\n\t\tunregister_netdevice_queue(dev, head);\n}\n\nstatic int vti6_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t   struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ip6_tnl *t;\n\tstruct __ip6_tnl_parm p;\n\tstruct net *net = dev_net(dev);\n\tstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\n\n\tif (dev == ip6n->fb_tnl_dev)\n\t\treturn -EINVAL;\n\n\tvti6_netlink_parms(data, &p);\n\n\tt = vti6_locate(net, &p, 0);\n\n\tif (t) {\n\t\tif (t->dev != dev)\n\t\t\treturn -EEXIST;\n\t} else\n\t\tt = netdev_priv(dev);\n\n\treturn vti6_update(t, &p, tb && tb[IFLA_MTU]);\n}\n\nstatic size_t vti6_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(sizeof(struct in6_addr)) +\n\t\t \n\t\tnla_total_size(sizeof(struct in6_addr)) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t \n\t\tnla_total_size(4) +\n\t\t0;\n}\n\nstatic int vti6_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ip6_tnl *tunnel = netdev_priv(dev);\n\tstruct __ip6_tnl_parm *parm = &tunnel->parms;\n\n\tif (nla_put_u32(skb, IFLA_VTI_LINK, parm->link) ||\n\t    nla_put_in6_addr(skb, IFLA_VTI_LOCAL, &parm->laddr) ||\n\t    nla_put_in6_addr(skb, IFLA_VTI_REMOTE, &parm->raddr) ||\n\t    nla_put_be32(skb, IFLA_VTI_IKEY, parm->i_key) ||\n\t    nla_put_be32(skb, IFLA_VTI_OKEY, parm->o_key) ||\n\t    nla_put_u32(skb, IFLA_VTI_FWMARK, parm->fwmark))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy vti6_policy[IFLA_VTI_MAX + 1] = {\n\t[IFLA_VTI_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_VTI_LOCAL]\t= { .len = sizeof(struct in6_addr) },\n\t[IFLA_VTI_REMOTE]\t= { .len = sizeof(struct in6_addr) },\n\t[IFLA_VTI_IKEY]\t\t= { .type = NLA_U32 },\n\t[IFLA_VTI_OKEY]\t\t= { .type = NLA_U32 },\n\t[IFLA_VTI_FWMARK]\t= { .type = NLA_U32 },\n};\n\nstatic struct rtnl_link_ops vti6_link_ops __read_mostly = {\n\t.kind\t\t= \"vti6\",\n\t.maxtype\t= IFLA_VTI_MAX,\n\t.policy\t\t= vti6_policy,\n\t.priv_size\t= sizeof(struct ip6_tnl),\n\t.setup\t\t= vti6_dev_setup,\n\t.validate\t= vti6_validate,\n\t.newlink\t= vti6_newlink,\n\t.dellink\t= vti6_dellink,\n\t.changelink\t= vti6_changelink,\n\t.get_size\t= vti6_get_size,\n\t.fill_info\t= vti6_fill_info,\n\t.get_link_net\t= ip6_tnl_get_link_net,\n};\n\nstatic void __net_exit vti6_destroy_tunnels(struct vti6_net *ip6n,\n\t\t\t\t\t    struct list_head *list)\n{\n\tint h;\n\tstruct ip6_tnl *t;\n\n\tfor (h = 0; h < IP6_VTI_HASH_SIZE; h++) {\n\t\tt = rtnl_dereference(ip6n->tnls_r_l[h]);\n\t\twhile (t) {\n\t\t\tunregister_netdevice_queue(t->dev, list);\n\t\t\tt = rtnl_dereference(t->next);\n\t\t}\n\t}\n\n\tt = rtnl_dereference(ip6n->tnls_wc[0]);\n\tif (t)\n\t\tunregister_netdevice_queue(t->dev, list);\n}\n\nstatic int __net_init vti6_init_net(struct net *net)\n{\n\tstruct vti6_net *ip6n = net_generic(net, vti6_net_id);\n\tstruct ip6_tnl *t = NULL;\n\tint err;\n\n\tip6n->tnls[0] = ip6n->tnls_wc;\n\tip6n->tnls[1] = ip6n->tnls_r_l;\n\n\tif (!net_has_fallback_tunnels(net))\n\t\treturn 0;\n\terr = -ENOMEM;\n\tip6n->fb_tnl_dev = alloc_netdev(sizeof(struct ip6_tnl), \"ip6_vti0\",\n\t\t\t\t\tNET_NAME_UNKNOWN, vti6_dev_setup);\n\n\tif (!ip6n->fb_tnl_dev)\n\t\tgoto err_alloc_dev;\n\tdev_net_set(ip6n->fb_tnl_dev, net);\n\tip6n->fb_tnl_dev->rtnl_link_ops = &vti6_link_ops;\n\n\terr = vti6_fb_tnl_dev_init(ip6n->fb_tnl_dev);\n\tif (err < 0)\n\t\tgoto err_register;\n\n\terr = register_netdev(ip6n->fb_tnl_dev);\n\tif (err < 0)\n\t\tgoto err_register;\n\n\tt = netdev_priv(ip6n->fb_tnl_dev);\n\n\tstrcpy(t->parms.name, ip6n->fb_tnl_dev->name);\n\treturn 0;\n\nerr_register:\n\tfree_netdev(ip6n->fb_tnl_dev);\nerr_alloc_dev:\n\treturn err;\n}\n\nstatic void __net_exit vti6_exit_batch_net(struct list_head *net_list)\n{\n\tstruct vti6_net *ip6n;\n\tstruct net *net;\n\tLIST_HEAD(list);\n\n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\tip6n = net_generic(net, vti6_net_id);\n\t\tvti6_destroy_tunnels(ip6n, &list);\n\t}\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations vti6_net_ops = {\n\t.init = vti6_init_net,\n\t.exit_batch = vti6_exit_batch_net,\n\t.id   = &vti6_net_id,\n\t.size = sizeof(struct vti6_net),\n};\n\nstatic struct xfrm6_protocol vti_esp6_protocol __read_mostly = {\n\t.handler\t=\tvti6_rcv,\n\t.input_handler\t=\tvti6_input_proto,\n\t.cb_handler\t=\tvti6_rcv_cb,\n\t.err_handler\t=\tvti6_err,\n\t.priority\t=\t100,\n};\n\nstatic struct xfrm6_protocol vti_ah6_protocol __read_mostly = {\n\t.handler\t=\tvti6_rcv,\n\t.input_handler\t=\tvti6_input_proto,\n\t.cb_handler\t=\tvti6_rcv_cb,\n\t.err_handler\t=\tvti6_err,\n\t.priority\t=\t100,\n};\n\nstatic struct xfrm6_protocol vti_ipcomp6_protocol __read_mostly = {\n\t.handler\t=\tvti6_rcv,\n\t.input_handler\t=\tvti6_input_proto,\n\t.cb_handler\t=\tvti6_rcv_cb,\n\t.err_handler\t=\tvti6_err,\n\t.priority\t=\t100,\n};\n\n#if IS_REACHABLE(CONFIG_INET6_XFRM_TUNNEL)\nstatic int vti6_rcv_tunnel(struct sk_buff *skb)\n{\n\tconst xfrm_address_t *saddr;\n\t__be32 spi;\n\n\tsaddr = (const xfrm_address_t *)&ipv6_hdr(skb)->saddr;\n\tspi = xfrm6_tunnel_spi_lookup(dev_net(skb->dev), saddr);\n\n\treturn vti6_input_proto(skb, IPPROTO_IPV6, spi, 0);\n}\n\nstatic struct xfrm6_tunnel vti_ipv6_handler __read_mostly = {\n\t.handler\t=\tvti6_rcv_tunnel,\n\t.cb_handler\t=\tvti6_rcv_cb,\n\t.err_handler\t=\tvti6_err,\n\t.priority\t=\t0,\n};\n\nstatic struct xfrm6_tunnel vti_ip6ip_handler __read_mostly = {\n\t.handler\t=\tvti6_rcv_tunnel,\n\t.cb_handler\t=\tvti6_rcv_cb,\n\t.err_handler\t=\tvti6_err,\n\t.priority\t=\t0,\n};\n#endif\n\n \nstatic int __init vti6_tunnel_init(void)\n{\n\tconst char *msg;\n\tint err;\n\n\tmsg = \"tunnel device\";\n\terr = register_pernet_device(&vti6_net_ops);\n\tif (err < 0)\n\t\tgoto pernet_dev_failed;\n\n\tmsg = \"tunnel protocols\";\n\terr = xfrm6_protocol_register(&vti_esp6_protocol, IPPROTO_ESP);\n\tif (err < 0)\n\t\tgoto xfrm_proto_esp_failed;\n\terr = xfrm6_protocol_register(&vti_ah6_protocol, IPPROTO_AH);\n\tif (err < 0)\n\t\tgoto xfrm_proto_ah_failed;\n\terr = xfrm6_protocol_register(&vti_ipcomp6_protocol, IPPROTO_COMP);\n\tif (err < 0)\n\t\tgoto xfrm_proto_comp_failed;\n#if IS_REACHABLE(CONFIG_INET6_XFRM_TUNNEL)\n\tmsg = \"ipv6 tunnel\";\n\terr = xfrm6_tunnel_register(&vti_ipv6_handler, AF_INET6);\n\tif (err < 0)\n\t\tgoto vti_tunnel_ipv6_failed;\n\terr = xfrm6_tunnel_register(&vti_ip6ip_handler, AF_INET);\n\tif (err < 0)\n\t\tgoto vti_tunnel_ip6ip_failed;\n#endif\n\n\tmsg = \"netlink interface\";\n\terr = rtnl_link_register(&vti6_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\n\treturn 0;\n\nrtnl_link_failed:\n#if IS_REACHABLE(CONFIG_INET6_XFRM_TUNNEL)\n\terr = xfrm6_tunnel_deregister(&vti_ip6ip_handler, AF_INET);\nvti_tunnel_ip6ip_failed:\n\terr = xfrm6_tunnel_deregister(&vti_ipv6_handler, AF_INET6);\nvti_tunnel_ipv6_failed:\n#endif\n\txfrm6_protocol_deregister(&vti_ipcomp6_protocol, IPPROTO_COMP);\nxfrm_proto_comp_failed:\n\txfrm6_protocol_deregister(&vti_ah6_protocol, IPPROTO_AH);\nxfrm_proto_ah_failed:\n\txfrm6_protocol_deregister(&vti_esp6_protocol, IPPROTO_ESP);\nxfrm_proto_esp_failed:\n\tunregister_pernet_device(&vti6_net_ops);\npernet_dev_failed:\n\tpr_err(\"vti6 init: failed to register %s\\n\", msg);\n\treturn err;\n}\n\n \nstatic void __exit vti6_tunnel_cleanup(void)\n{\n\trtnl_link_unregister(&vti6_link_ops);\n#if IS_REACHABLE(CONFIG_INET6_XFRM_TUNNEL)\n\txfrm6_tunnel_deregister(&vti_ip6ip_handler, AF_INET);\n\txfrm6_tunnel_deregister(&vti_ipv6_handler, AF_INET6);\n#endif\n\txfrm6_protocol_deregister(&vti_ipcomp6_protocol, IPPROTO_COMP);\n\txfrm6_protocol_deregister(&vti_ah6_protocol, IPPROTO_AH);\n\txfrm6_protocol_deregister(&vti_esp6_protocol, IPPROTO_ESP);\n\tunregister_pernet_device(&vti6_net_ops);\n}\n\nmodule_init(vti6_tunnel_init);\nmodule_exit(vti6_tunnel_cleanup);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(\"vti6\");\nMODULE_ALIAS_NETDEV(\"ip6_vti0\");\nMODULE_AUTHOR(\"Steffen Klassert\");\nMODULE_DESCRIPTION(\"IPv6 virtual tunnel interface\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}