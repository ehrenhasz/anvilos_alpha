{
  "module_name": "xfrm6_protocol.c",
  "hash_id": "0b88cfc81c97278554513d7a7feeccb4f034257b59436b31671dc45bafb3a5be",
  "original_prompt": "Ingested from linux-6.6.14/net/ipv6/xfrm6_protocol.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/skbuff.h>\n#include <linux/icmpv6.h>\n#include <net/ip6_route.h>\n#include <net/ipv6.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n\nstatic struct xfrm6_protocol __rcu *esp6_handlers __read_mostly;\nstatic struct xfrm6_protocol __rcu *ah6_handlers __read_mostly;\nstatic struct xfrm6_protocol __rcu *ipcomp6_handlers __read_mostly;\nstatic DEFINE_MUTEX(xfrm6_protocol_mutex);\n\nstatic inline struct xfrm6_protocol __rcu **proto_handlers(u8 protocol)\n{\n\tswitch (protocol) {\n\tcase IPPROTO_ESP:\n\t\treturn &esp6_handlers;\n\tcase IPPROTO_AH:\n\t\treturn &ah6_handlers;\n\tcase IPPROTO_COMP:\n\t\treturn &ipcomp6_handlers;\n\t}\n\n\treturn NULL;\n}\n\n#define for_each_protocol_rcu(head, handler)\t\t\\\n\tfor (handler = rcu_dereference(head);\t\t\\\n\t     handler != NULL;\t\t\t\t\\\n\t     handler = rcu_dereference(handler->next))\t\\\n\nstatic int xfrm6_rcv_cb(struct sk_buff *skb, u8 protocol, int err)\n{\n\tint ret;\n\tstruct xfrm6_protocol *handler;\n\tstruct xfrm6_protocol __rcu **head = proto_handlers(protocol);\n\n\tif (!head)\n\t\treturn 0;\n\n\tfor_each_protocol_rcu(*proto_handlers(protocol), handler)\n\t\tif ((ret = handler->cb_handler(skb, err)) <= 0)\n\t\t\treturn ret;\n\n\treturn 0;\n}\n\nint xfrm6_rcv_encap(struct sk_buff *skb, int nexthdr, __be32 spi,\n\t\t    int encap_type)\n{\n\tint ret;\n\tstruct xfrm6_protocol *handler;\n\tstruct xfrm6_protocol __rcu **head = proto_handlers(nexthdr);\n\n\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6 = NULL;\n\tXFRM_SPI_SKB_CB(skb)->family = AF_INET6;\n\tXFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct ipv6hdr, daddr);\n\n\tif (!head)\n\t\tgoto out;\n\n\tif (!skb_dst(skb)) {\n\t\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t\tint flags = RT6_LOOKUP_F_HAS_SADDR;\n\t\tstruct dst_entry *dst;\n\t\tstruct flowi6 fl6 = {\n\t\t\t.flowi6_iif   = skb->dev->ifindex,\n\t\t\t.daddr        = ip6h->daddr,\n\t\t\t.saddr        = ip6h->saddr,\n\t\t\t.flowlabel    = ip6_flowinfo(ip6h),\n\t\t\t.flowi6_mark  = skb->mark,\n\t\t\t.flowi6_proto = ip6h->nexthdr,\n\t\t};\n\n\t\tdst = ip6_route_input_lookup(dev_net(skb->dev), skb->dev, &fl6,\n\t\t\t\t\t     skb, flags);\n\t\tif (dst->error)\n\t\t\tgoto drop;\n\t\tskb_dst_set(skb, dst);\n\t}\n\n\tfor_each_protocol_rcu(*head, handler)\n\t\tif ((ret = handler->input_handler(skb, nexthdr, spi, encap_type)) != -EINVAL)\n\t\t\treturn ret;\n\nout:\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\nEXPORT_SYMBOL(xfrm6_rcv_encap);\n\nstatic int xfrm6_esp_rcv(struct sk_buff *skb)\n{\n\tint ret;\n\tstruct xfrm6_protocol *handler;\n\n\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6 = NULL;\n\n\tfor_each_protocol_rcu(esp6_handlers, handler)\n\t\tif ((ret = handler->handler(skb)) != -EINVAL)\n\t\t\treturn ret;\n\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int xfrm6_esp_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t  u8 type, u8 code, int offset, __be32 info)\n{\n\tstruct xfrm6_protocol *handler;\n\n\tfor_each_protocol_rcu(esp6_handlers, handler)\n\t\tif (!handler->err_handler(skb, opt, type, code, offset, info))\n\t\t\treturn 0;\n\n\treturn -ENOENT;\n}\n\nstatic int xfrm6_ah_rcv(struct sk_buff *skb)\n{\n\tint ret;\n\tstruct xfrm6_protocol *handler;\n\n\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6 = NULL;\n\n\tfor_each_protocol_rcu(ah6_handlers, handler)\n\t\tif ((ret = handler->handler(skb)) != -EINVAL)\n\t\t\treturn ret;\n\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int xfrm6_ah_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t u8 type, u8 code, int offset, __be32 info)\n{\n\tstruct xfrm6_protocol *handler;\n\n\tfor_each_protocol_rcu(ah6_handlers, handler)\n\t\tif (!handler->err_handler(skb, opt, type, code, offset, info))\n\t\t\treturn 0;\n\n\treturn -ENOENT;\n}\n\nstatic int xfrm6_ipcomp_rcv(struct sk_buff *skb)\n{\n\tint ret;\n\tstruct xfrm6_protocol *handler;\n\n\tXFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6 = NULL;\n\n\tfor_each_protocol_rcu(ipcomp6_handlers, handler)\n\t\tif ((ret = handler->handler(skb)) != -EINVAL)\n\t\t\treturn ret;\n\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int xfrm6_ipcomp_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t\t     u8 type, u8 code, int offset, __be32 info)\n{\n\tstruct xfrm6_protocol *handler;\n\n\tfor_each_protocol_rcu(ipcomp6_handlers, handler)\n\t\tif (!handler->err_handler(skb, opt, type, code, offset, info))\n\t\t\treturn 0;\n\n\treturn -ENOENT;\n}\n\nstatic const struct inet6_protocol esp6_protocol = {\n\t.handler\t=\txfrm6_esp_rcv,\n\t.err_handler\t=\txfrm6_esp_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\nstatic const struct inet6_protocol ah6_protocol = {\n\t.handler\t=\txfrm6_ah_rcv,\n\t.err_handler\t=\txfrm6_ah_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\nstatic const struct inet6_protocol ipcomp6_protocol = {\n\t.handler\t=\txfrm6_ipcomp_rcv,\n\t.err_handler\t=\txfrm6_ipcomp_err,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY,\n};\n\nstatic const struct xfrm_input_afinfo xfrm6_input_afinfo = {\n\t.family\t\t=\tAF_INET6,\n\t.callback\t=\txfrm6_rcv_cb,\n};\n\nstatic inline const struct inet6_protocol *netproto(unsigned char protocol)\n{\n\tswitch (protocol) {\n\tcase IPPROTO_ESP:\n\t\treturn &esp6_protocol;\n\tcase IPPROTO_AH:\n\t\treturn &ah6_protocol;\n\tcase IPPROTO_COMP:\n\t\treturn &ipcomp6_protocol;\n\t}\n\n\treturn NULL;\n}\n\nint xfrm6_protocol_register(struct xfrm6_protocol *handler,\n\t\t\t    unsigned char protocol)\n{\n\tstruct xfrm6_protocol __rcu **pprev;\n\tstruct xfrm6_protocol *t;\n\tbool add_netproto = false;\n\tint ret = -EEXIST;\n\tint priority = handler->priority;\n\n\tif (!proto_handlers(protocol) || !netproto(protocol))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&xfrm6_protocol_mutex);\n\n\tif (!rcu_dereference_protected(*proto_handlers(protocol),\n\t\t\t\t       lockdep_is_held(&xfrm6_protocol_mutex)))\n\t\tadd_netproto = true;\n\n\tfor (pprev = proto_handlers(protocol);\n\t     (t = rcu_dereference_protected(*pprev,\n\t\t\tlockdep_is_held(&xfrm6_protocol_mutex))) != NULL;\n\t     pprev = &t->next) {\n\t\tif (t->priority < priority)\n\t\t\tbreak;\n\t\tif (t->priority == priority)\n\t\t\tgoto err;\n\t}\n\n\thandler->next = *pprev;\n\trcu_assign_pointer(*pprev, handler);\n\n\tret = 0;\n\nerr:\n\tmutex_unlock(&xfrm6_protocol_mutex);\n\n\tif (add_netproto) {\n\t\tif (inet6_add_protocol(netproto(protocol), protocol)) {\n\t\t\tpr_err(\"%s: can't add protocol\\n\", __func__);\n\t\t\tret = -EAGAIN;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(xfrm6_protocol_register);\n\nint xfrm6_protocol_deregister(struct xfrm6_protocol *handler,\n\t\t\t      unsigned char protocol)\n{\n\tstruct xfrm6_protocol __rcu **pprev;\n\tstruct xfrm6_protocol *t;\n\tint ret = -ENOENT;\n\n\tif (!proto_handlers(protocol) || !netproto(protocol))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&xfrm6_protocol_mutex);\n\n\tfor (pprev = proto_handlers(protocol);\n\t     (t = rcu_dereference_protected(*pprev,\n\t\t\tlockdep_is_held(&xfrm6_protocol_mutex))) != NULL;\n\t     pprev = &t->next) {\n\t\tif (t == handler) {\n\t\t\t*pprev = handler->next;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!rcu_dereference_protected(*proto_handlers(protocol),\n\t\t\t\t       lockdep_is_held(&xfrm6_protocol_mutex))) {\n\t\tif (inet6_del_protocol(netproto(protocol), protocol) < 0) {\n\t\t\tpr_err(\"%s: can't remove protocol\\n\", __func__);\n\t\t\tret = -EAGAIN;\n\t\t}\n\t}\n\n\tmutex_unlock(&xfrm6_protocol_mutex);\n\n\tsynchronize_net();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(xfrm6_protocol_deregister);\n\nint __init xfrm6_protocol_init(void)\n{\n\treturn xfrm_input_register_afinfo(&xfrm6_input_afinfo);\n}\n\nvoid xfrm6_protocol_fini(void)\n{\n\txfrm_input_unregister_afinfo(&xfrm6_input_afinfo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}