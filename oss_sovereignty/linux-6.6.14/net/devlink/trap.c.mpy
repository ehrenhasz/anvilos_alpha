{
  "module_name": "trap.c",
  "hash_id": "07f98c967c2c540246302abd8638ffdffdf43fd770491401c56a093eccf8af87",
  "original_prompt": "Ingested from linux-6.6.14/net/devlink/trap.c",
  "human_readable_source": "\n \n\n#include <trace/events/devlink.h>\n\n#include \"devl_internal.h\"\n\nstruct devlink_stats {\n\tu64_stats_t rx_bytes;\n\tu64_stats_t rx_packets;\n\tstruct u64_stats_sync syncp;\n};\n\n \nstruct devlink_trap_policer_item {\n\tconst struct devlink_trap_policer *policer;\n\tu64 rate;\n\tu64 burst;\n\tstruct list_head list;\n};\n\n \nstruct devlink_trap_group_item {\n\tconst struct devlink_trap_group *group;\n\tstruct devlink_trap_policer_item *policer_item;\n\tstruct list_head list;\n\tstruct devlink_stats __percpu *stats;\n};\n\n \nstruct devlink_trap_item {\n\tconst struct devlink_trap *trap;\n\tstruct devlink_trap_group_item *group_item;\n\tstruct list_head list;\n\tenum devlink_trap_action action;\n\tstruct devlink_stats __percpu *stats;\n\tvoid *priv;\n};\n\nstatic struct devlink_trap_policer_item *\ndevlink_trap_policer_item_lookup(struct devlink *devlink, u32 id)\n{\n\tstruct devlink_trap_policer_item *policer_item;\n\n\tlist_for_each_entry(policer_item, &devlink->trap_policer_list, list) {\n\t\tif (policer_item->policer->id == id)\n\t\t\treturn policer_item;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct devlink_trap_item *\ndevlink_trap_item_lookup(struct devlink *devlink, const char *name)\n{\n\tstruct devlink_trap_item *trap_item;\n\n\tlist_for_each_entry(trap_item, &devlink->trap_list, list) {\n\t\tif (!strcmp(trap_item->trap->name, name))\n\t\t\treturn trap_item;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct devlink_trap_item *\ndevlink_trap_item_get_from_info(struct devlink *devlink,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct nlattr *attr;\n\n\tif (!info->attrs[DEVLINK_ATTR_TRAP_NAME])\n\t\treturn NULL;\n\tattr = info->attrs[DEVLINK_ATTR_TRAP_NAME];\n\n\treturn devlink_trap_item_lookup(devlink, nla_data(attr));\n}\n\nstatic int\ndevlink_trap_action_get_from_info(struct genl_info *info,\n\t\t\t\t  enum devlink_trap_action *p_trap_action)\n{\n\tu8 val;\n\n\tval = nla_get_u8(info->attrs[DEVLINK_ATTR_TRAP_ACTION]);\n\tswitch (val) {\n\tcase DEVLINK_TRAP_ACTION_DROP:\n\tcase DEVLINK_TRAP_ACTION_TRAP:\n\tcase DEVLINK_TRAP_ACTION_MIRROR:\n\t\t*p_trap_action = val;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int devlink_trap_metadata_put(struct sk_buff *msg,\n\t\t\t\t     const struct devlink_trap *trap)\n{\n\tstruct nlattr *attr;\n\n\tattr = nla_nest_start(msg, DEVLINK_ATTR_TRAP_METADATA);\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tif ((trap->metadata_cap & DEVLINK_TRAP_METADATA_TYPE_F_IN_PORT) &&\n\t    nla_put_flag(msg, DEVLINK_ATTR_TRAP_METADATA_TYPE_IN_PORT))\n\t\tgoto nla_put_failure;\n\tif ((trap->metadata_cap & DEVLINK_TRAP_METADATA_TYPE_F_FA_COOKIE) &&\n\t    nla_put_flag(msg, DEVLINK_ATTR_TRAP_METADATA_TYPE_FA_COOKIE))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, attr);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(msg, attr);\n\treturn -EMSGSIZE;\n}\n\nstatic void devlink_trap_stats_read(struct devlink_stats __percpu *trap_stats,\n\t\t\t\t    struct devlink_stats *stats)\n{\n\tint i;\n\n\tmemset(stats, 0, sizeof(*stats));\n\tfor_each_possible_cpu(i) {\n\t\tstruct devlink_stats *cpu_stats;\n\t\tu64 rx_packets, rx_bytes;\n\t\tunsigned int start;\n\n\t\tcpu_stats = per_cpu_ptr(trap_stats, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&cpu_stats->syncp);\n\t\t\trx_packets = u64_stats_read(&cpu_stats->rx_packets);\n\t\t\trx_bytes = u64_stats_read(&cpu_stats->rx_bytes);\n\t\t} while (u64_stats_fetch_retry(&cpu_stats->syncp, start));\n\n\t\tu64_stats_add(&stats->rx_packets, rx_packets);\n\t\tu64_stats_add(&stats->rx_bytes, rx_bytes);\n\t}\n}\n\nstatic int\ndevlink_trap_group_stats_put(struct sk_buff *msg,\n\t\t\t     struct devlink_stats __percpu *trap_stats)\n{\n\tstruct devlink_stats stats;\n\tstruct nlattr *attr;\n\n\tdevlink_trap_stats_read(trap_stats, &stats);\n\n\tattr = nla_nest_start(msg, DEVLINK_ATTR_STATS);\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u64_64bit(msg, DEVLINK_ATTR_STATS_RX_PACKETS,\n\t\t\t      u64_stats_read(&stats.rx_packets),\n\t\t\t      DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, DEVLINK_ATTR_STATS_RX_BYTES,\n\t\t\t      u64_stats_read(&stats.rx_bytes),\n\t\t\t      DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, attr);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(msg, attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int devlink_trap_stats_put(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t\t  const struct devlink_trap_item *trap_item)\n{\n\tstruct devlink_stats stats;\n\tstruct nlattr *attr;\n\tu64 drops = 0;\n\tint err;\n\n\tif (devlink->ops->trap_drop_counter_get) {\n\t\terr = devlink->ops->trap_drop_counter_get(devlink,\n\t\t\t\t\t\t\t  trap_item->trap,\n\t\t\t\t\t\t\t  &drops);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdevlink_trap_stats_read(trap_item->stats, &stats);\n\n\tattr = nla_nest_start(msg, DEVLINK_ATTR_STATS);\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink->ops->trap_drop_counter_get &&\n\t    nla_put_u64_64bit(msg, DEVLINK_ATTR_STATS_RX_DROPPED, drops,\n\t\t\t      DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, DEVLINK_ATTR_STATS_RX_PACKETS,\n\t\t\t      u64_stats_read(&stats.rx_packets),\n\t\t\t      DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, DEVLINK_ATTR_STATS_RX_BYTES,\n\t\t\t      u64_stats_read(&stats.rx_bytes),\n\t\t\t      DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, attr);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(msg, attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int devlink_nl_trap_fill(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t\tconst struct devlink_trap_item *trap_item,\n\t\t\t\tenum devlink_command cmd, u32 portid, u32 seq,\n\t\t\t\tint flags)\n{\n\tstruct devlink_trap_group_item *group_item = trap_item->group_item;\n\tvoid *hdr;\n\tint err;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(msg, DEVLINK_ATTR_TRAP_GROUP_NAME,\n\t\t\t   group_item->group->name))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(msg, DEVLINK_ATTR_TRAP_NAME, trap_item->trap->name))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, DEVLINK_ATTR_TRAP_TYPE, trap_item->trap->type))\n\t\tgoto nla_put_failure;\n\n\tif (trap_item->trap->generic &&\n\t    nla_put_flag(msg, DEVLINK_ATTR_TRAP_GENERIC))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, DEVLINK_ATTR_TRAP_ACTION, trap_item->action))\n\t\tgoto nla_put_failure;\n\n\terr = devlink_trap_metadata_put(msg, trap_item->trap);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\terr = devlink_trap_stats_put(msg, devlink, trap_item);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nint devlink_nl_trap_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_trap_item *trap_item;\n\tstruct sk_buff *msg;\n\tint err;\n\n\tif (list_empty(&devlink->trap_list))\n\t\treturn -EOPNOTSUPP;\n\n\ttrap_item = devlink_trap_item_get_from_info(devlink, info);\n\tif (!trap_item) {\n\t\tNL_SET_ERR_MSG(extack, \"Device did not register this trap\");\n\t\treturn -ENOENT;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_trap_fill(msg, devlink, trap_item,\n\t\t\t\t   DEVLINK_CMD_TRAP_NEW, info->snd_portid,\n\t\t\t\t   info->snd_seq, 0);\n\tif (err)\n\t\tgoto err_trap_fill;\n\n\treturn genlmsg_reply(msg, info);\n\nerr_trap_fill:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int devlink_nl_trap_get_dump_one(struct sk_buff *msg,\n\t\t\t\t\tstruct devlink *devlink,\n\t\t\t\t\tstruct netlink_callback *cb, int flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct devlink_trap_item *trap_item;\n\tint idx = 0;\n\tint err = 0;\n\n\tlist_for_each_entry(trap_item, &devlink->trap_list, list) {\n\t\tif (idx < state->idx) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = devlink_nl_trap_fill(msg, devlink, trap_item,\n\t\t\t\t\t   DEVLINK_CMD_TRAP_NEW,\n\t\t\t\t\t   NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, flags);\n\t\tif (err) {\n\t\t\tstate->idx = idx;\n\t\t\tbreak;\n\t\t}\n\t\tidx++;\n\t}\n\n\treturn err;\n}\n\nint devlink_nl_trap_get_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb, devlink_nl_trap_get_dump_one);\n}\n\nstatic int __devlink_trap_action_set(struct devlink *devlink,\n\t\t\t\t     struct devlink_trap_item *trap_item,\n\t\t\t\t     enum devlink_trap_action trap_action,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tif (trap_item->action != trap_action &&\n\t    trap_item->trap->type != DEVLINK_TRAP_TYPE_DROP) {\n\t\tNL_SET_ERR_MSG(extack, \"Cannot change action of non-drop traps. Skipping\");\n\t\treturn 0;\n\t}\n\n\terr = devlink->ops->trap_action_set(devlink, trap_item->trap,\n\t\t\t\t\t    trap_action, extack);\n\tif (err)\n\t\treturn err;\n\n\ttrap_item->action = trap_action;\n\n\treturn 0;\n}\n\nstatic int devlink_trap_action_set(struct devlink *devlink,\n\t\t\t\t   struct devlink_trap_item *trap_item,\n\t\t\t\t   struct genl_info *info)\n{\n\tenum devlink_trap_action trap_action;\n\tint err;\n\n\tif (!info->attrs[DEVLINK_ATTR_TRAP_ACTION])\n\t\treturn 0;\n\n\terr = devlink_trap_action_get_from_info(info, &trap_action);\n\tif (err) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Invalid trap action\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn __devlink_trap_action_set(devlink, trap_item, trap_action,\n\t\t\t\t\t info->extack);\n}\n\nint devlink_nl_cmd_trap_set_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_trap_item *trap_item;\n\n\tif (list_empty(&devlink->trap_list))\n\t\treturn -EOPNOTSUPP;\n\n\ttrap_item = devlink_trap_item_get_from_info(devlink, info);\n\tif (!trap_item) {\n\t\tNL_SET_ERR_MSG(extack, \"Device did not register this trap\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn devlink_trap_action_set(devlink, trap_item, info);\n}\n\nstatic struct devlink_trap_group_item *\ndevlink_trap_group_item_lookup(struct devlink *devlink, const char *name)\n{\n\tstruct devlink_trap_group_item *group_item;\n\n\tlist_for_each_entry(group_item, &devlink->trap_group_list, list) {\n\t\tif (!strcmp(group_item->group->name, name))\n\t\t\treturn group_item;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct devlink_trap_group_item *\ndevlink_trap_group_item_lookup_by_id(struct devlink *devlink, u16 id)\n{\n\tstruct devlink_trap_group_item *group_item;\n\n\tlist_for_each_entry(group_item, &devlink->trap_group_list, list) {\n\t\tif (group_item->group->id == id)\n\t\t\treturn group_item;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct devlink_trap_group_item *\ndevlink_trap_group_item_get_from_info(struct devlink *devlink,\n\t\t\t\t      struct genl_info *info)\n{\n\tchar *name;\n\n\tif (!info->attrs[DEVLINK_ATTR_TRAP_GROUP_NAME])\n\t\treturn NULL;\n\tname = nla_data(info->attrs[DEVLINK_ATTR_TRAP_GROUP_NAME]);\n\n\treturn devlink_trap_group_item_lookup(devlink, name);\n}\n\nstatic int\ndevlink_nl_trap_group_fill(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t   const struct devlink_trap_group_item *group_item,\n\t\t\t   enum devlink_command cmd, u32 portid, u32 seq,\n\t\t\t   int flags)\n{\n\tvoid *hdr;\n\tint err;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_string(msg, DEVLINK_ATTR_TRAP_GROUP_NAME,\n\t\t\t   group_item->group->name))\n\t\tgoto nla_put_failure;\n\n\tif (group_item->group->generic &&\n\t    nla_put_flag(msg, DEVLINK_ATTR_TRAP_GENERIC))\n\t\tgoto nla_put_failure;\n\n\tif (group_item->policer_item &&\n\t    nla_put_u32(msg, DEVLINK_ATTR_TRAP_POLICER_ID,\n\t\t\tgroup_item->policer_item->policer->id))\n\t\tgoto nla_put_failure;\n\n\terr = devlink_trap_group_stats_put(msg, group_item->stats);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nint devlink_nl_trap_group_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_trap_group_item *group_item;\n\tstruct sk_buff *msg;\n\tint err;\n\n\tif (list_empty(&devlink->trap_group_list))\n\t\treturn -EOPNOTSUPP;\n\n\tgroup_item = devlink_trap_group_item_get_from_info(devlink, info);\n\tif (!group_item) {\n\t\tNL_SET_ERR_MSG(extack, \"Device did not register this trap group\");\n\t\treturn -ENOENT;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_trap_group_fill(msg, devlink, group_item,\n\t\t\t\t\t DEVLINK_CMD_TRAP_GROUP_NEW,\n\t\t\t\t\t info->snd_portid, info->snd_seq, 0);\n\tif (err)\n\t\tgoto err_trap_group_fill;\n\n\treturn genlmsg_reply(msg, info);\n\nerr_trap_group_fill:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int devlink_nl_trap_group_get_dump_one(struct sk_buff *msg,\n\t\t\t\t\t      struct devlink *devlink,\n\t\t\t\t\t      struct netlink_callback *cb,\n\t\t\t\t\t      int flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct devlink_trap_group_item *group_item;\n\tint idx = 0;\n\tint err = 0;\n\n\tlist_for_each_entry(group_item, &devlink->trap_group_list, list) {\n\t\tif (idx < state->idx) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = devlink_nl_trap_group_fill(msg, devlink, group_item,\n\t\t\t\t\t\t DEVLINK_CMD_TRAP_GROUP_NEW,\n\t\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t cb->nlh->nlmsg_seq, flags);\n\t\tif (err) {\n\t\t\tstate->idx = idx;\n\t\t\tbreak;\n\t\t}\n\t\tidx++;\n\t}\n\n\treturn err;\n}\n\nint devlink_nl_trap_group_get_dumpit(struct sk_buff *skb,\n\t\t\t\t     struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb, devlink_nl_trap_group_get_dump_one);\n}\n\nstatic int\n__devlink_trap_group_action_set(struct devlink *devlink,\n\t\t\t\tstruct devlink_trap_group_item *group_item,\n\t\t\t\tenum devlink_trap_action trap_action,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst char *group_name = group_item->group->name;\n\tstruct devlink_trap_item *trap_item;\n\tint err;\n\n\tif (devlink->ops->trap_group_action_set) {\n\t\terr = devlink->ops->trap_group_action_set(devlink, group_item->group,\n\t\t\t\t\t\t\t  trap_action, extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tlist_for_each_entry(trap_item, &devlink->trap_list, list) {\n\t\t\tif (strcmp(trap_item->group_item->group->name, group_name))\n\t\t\t\tcontinue;\n\t\t\tif (trap_item->action != trap_action &&\n\t\t\t    trap_item->trap->type != DEVLINK_TRAP_TYPE_DROP)\n\t\t\t\tcontinue;\n\t\t\ttrap_item->action = trap_action;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(trap_item, &devlink->trap_list, list) {\n\t\tif (strcmp(trap_item->group_item->group->name, group_name))\n\t\t\tcontinue;\n\t\terr = __devlink_trap_action_set(devlink, trap_item,\n\t\t\t\t\t\ttrap_action, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndevlink_trap_group_action_set(struct devlink *devlink,\n\t\t\t      struct devlink_trap_group_item *group_item,\n\t\t\t      struct genl_info *info, bool *p_modified)\n{\n\tenum devlink_trap_action trap_action;\n\tint err;\n\n\tif (!info->attrs[DEVLINK_ATTR_TRAP_ACTION])\n\t\treturn 0;\n\n\terr = devlink_trap_action_get_from_info(info, &trap_action);\n\tif (err) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Invalid trap action\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = __devlink_trap_group_action_set(devlink, group_item, trap_action,\n\t\t\t\t\t      info->extack);\n\tif (err)\n\t\treturn err;\n\n\t*p_modified = true;\n\n\treturn 0;\n}\n\nstatic int devlink_trap_group_set(struct devlink *devlink,\n\t\t\t\t  struct devlink_trap_group_item *group_item,\n\t\t\t\t  struct genl_info *info)\n{\n\tstruct devlink_trap_policer_item *policer_item;\n\tstruct netlink_ext_ack *extack = info->extack;\n\tconst struct devlink_trap_policer *policer;\n\tstruct nlattr **attrs = info->attrs;\n\tu32 policer_id;\n\tint err;\n\n\tif (!attrs[DEVLINK_ATTR_TRAP_POLICER_ID])\n\t\treturn 0;\n\n\tif (!devlink->ops->trap_group_set)\n\t\treturn -EOPNOTSUPP;\n\n\tpolicer_id = nla_get_u32(attrs[DEVLINK_ATTR_TRAP_POLICER_ID]);\n\tpolicer_item = devlink_trap_policer_item_lookup(devlink, policer_id);\n\tif (policer_id && !policer_item) {\n\t\tNL_SET_ERR_MSG(extack, \"Device did not register this trap policer\");\n\t\treturn -ENOENT;\n\t}\n\tpolicer = policer_item ? policer_item->policer : NULL;\n\n\terr = devlink->ops->trap_group_set(devlink, group_item->group, policer,\n\t\t\t\t\t   extack);\n\tif (err)\n\t\treturn err;\n\n\tgroup_item->policer_item = policer_item;\n\n\treturn 0;\n}\n\nint devlink_nl_cmd_trap_group_set_doit(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_trap_group_item *group_item;\n\tbool modified = false;\n\tint err;\n\n\tif (list_empty(&devlink->trap_group_list))\n\t\treturn -EOPNOTSUPP;\n\n\tgroup_item = devlink_trap_group_item_get_from_info(devlink, info);\n\tif (!group_item) {\n\t\tNL_SET_ERR_MSG(extack, \"Device did not register this trap group\");\n\t\treturn -ENOENT;\n\t}\n\n\terr = devlink_trap_group_action_set(devlink, group_item, info,\n\t\t\t\t\t    &modified);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_trap_group_set(devlink, group_item, info);\n\tif (err)\n\t\tgoto err_trap_group_set;\n\n\treturn 0;\n\nerr_trap_group_set:\n\tif (modified)\n\t\tNL_SET_ERR_MSG(extack, \"Trap group set failed, but some changes were committed already\");\n\treturn err;\n}\n\nstatic struct devlink_trap_policer_item *\ndevlink_trap_policer_item_get_from_info(struct devlink *devlink,\n\t\t\t\t\tstruct genl_info *info)\n{\n\tu32 id;\n\n\tif (!info->attrs[DEVLINK_ATTR_TRAP_POLICER_ID])\n\t\treturn NULL;\n\tid = nla_get_u32(info->attrs[DEVLINK_ATTR_TRAP_POLICER_ID]);\n\n\treturn devlink_trap_policer_item_lookup(devlink, id);\n}\n\nstatic int\ndevlink_trap_policer_stats_put(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t       const struct devlink_trap_policer *policer)\n{\n\tstruct nlattr *attr;\n\tu64 drops;\n\tint err;\n\n\tif (!devlink->ops->trap_policer_counter_get)\n\t\treturn 0;\n\n\terr = devlink->ops->trap_policer_counter_get(devlink, policer, &drops);\n\tif (err)\n\t\treturn err;\n\n\tattr = nla_nest_start(msg, DEVLINK_ATTR_STATS);\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u64_64bit(msg, DEVLINK_ATTR_STATS_RX_DROPPED, drops,\n\t\t\t      DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, attr);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(msg, attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\ndevlink_nl_trap_policer_fill(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t     const struct devlink_trap_policer_item *policer_item,\n\t\t\t     enum devlink_command cmd, u32 portid, u32 seq,\n\t\t\t     int flags)\n{\n\tvoid *hdr;\n\tint err;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, DEVLINK_ATTR_TRAP_POLICER_ID,\n\t\t\tpolicer_item->policer->id))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, DEVLINK_ATTR_TRAP_POLICER_RATE,\n\t\t\t      policer_item->rate, DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, DEVLINK_ATTR_TRAP_POLICER_BURST,\n\t\t\t      policer_item->burst, DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\terr = devlink_trap_policer_stats_put(msg, devlink,\n\t\t\t\t\t     policer_item->policer);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nint devlink_nl_trap_policer_get_doit(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct devlink_trap_policer_item *policer_item;\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tint err;\n\n\tif (list_empty(&devlink->trap_policer_list))\n\t\treturn -EOPNOTSUPP;\n\n\tpolicer_item = devlink_trap_policer_item_get_from_info(devlink, info);\n\tif (!policer_item) {\n\t\tNL_SET_ERR_MSG(extack, \"Device did not register this trap policer\");\n\t\treturn -ENOENT;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_trap_policer_fill(msg, devlink, policer_item,\n\t\t\t\t\t   DEVLINK_CMD_TRAP_POLICER_NEW,\n\t\t\t\t\t   info->snd_portid, info->snd_seq, 0);\n\tif (err)\n\t\tgoto err_trap_policer_fill;\n\n\treturn genlmsg_reply(msg, info);\n\nerr_trap_policer_fill:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int devlink_nl_trap_policer_get_dump_one(struct sk_buff *msg,\n\t\t\t\t\t\tstruct devlink *devlink,\n\t\t\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\t\t\tint flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct devlink_trap_policer_item *policer_item;\n\tint idx = 0;\n\tint err = 0;\n\n\tlist_for_each_entry(policer_item, &devlink->trap_policer_list, list) {\n\t\tif (idx < state->idx) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = devlink_nl_trap_policer_fill(msg, devlink, policer_item,\n\t\t\t\t\t\t   DEVLINK_CMD_TRAP_POLICER_NEW,\n\t\t\t\t\t\t   NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t   cb->nlh->nlmsg_seq, flags);\n\t\tif (err) {\n\t\t\tstate->idx = idx;\n\t\t\tbreak;\n\t\t}\n\t\tidx++;\n\t}\n\n\treturn err;\n}\n\nint devlink_nl_trap_policer_get_dumpit(struct sk_buff *skb,\n\t\t\t\t       struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb, devlink_nl_trap_policer_get_dump_one);\n}\n\nstatic int\ndevlink_trap_policer_set(struct devlink *devlink,\n\t\t\t struct devlink_trap_policer_item *policer_item,\n\t\t\t struct genl_info *info)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct nlattr **attrs = info->attrs;\n\tu64 rate, burst;\n\tint err;\n\n\trate = policer_item->rate;\n\tburst = policer_item->burst;\n\n\tif (attrs[DEVLINK_ATTR_TRAP_POLICER_RATE])\n\t\trate = nla_get_u64(attrs[DEVLINK_ATTR_TRAP_POLICER_RATE]);\n\n\tif (attrs[DEVLINK_ATTR_TRAP_POLICER_BURST])\n\t\tburst = nla_get_u64(attrs[DEVLINK_ATTR_TRAP_POLICER_BURST]);\n\n\tif (rate < policer_item->policer->min_rate) {\n\t\tNL_SET_ERR_MSG(extack, \"Policer rate lower than limit\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rate > policer_item->policer->max_rate) {\n\t\tNL_SET_ERR_MSG(extack, \"Policer rate higher than limit\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (burst < policer_item->policer->min_burst) {\n\t\tNL_SET_ERR_MSG(extack, \"Policer burst size lower than limit\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (burst > policer_item->policer->max_burst) {\n\t\tNL_SET_ERR_MSG(extack, \"Policer burst size higher than limit\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = devlink->ops->trap_policer_set(devlink, policer_item->policer,\n\t\t\t\t\t     rate, burst, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tpolicer_item->rate = rate;\n\tpolicer_item->burst = burst;\n\n\treturn 0;\n}\n\nint devlink_nl_cmd_trap_policer_set_doit(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct devlink_trap_policer_item *policer_item;\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct devlink *devlink = info->user_ptr[0];\n\n\tif (list_empty(&devlink->trap_policer_list))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!devlink->ops->trap_policer_set)\n\t\treturn -EOPNOTSUPP;\n\n\tpolicer_item = devlink_trap_policer_item_get_from_info(devlink, info);\n\tif (!policer_item) {\n\t\tNL_SET_ERR_MSG(extack, \"Device did not register this trap policer\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn devlink_trap_policer_set(devlink, policer_item, info);\n}\n\n#define DEVLINK_TRAP(_id, _type)\t\t\t\t\t      \\\n\t{\t\t\t\t\t\t\t\t      \\\n\t\t.type = DEVLINK_TRAP_TYPE_##_type,\t\t\t      \\\n\t\t.id = DEVLINK_TRAP_GENERIC_ID_##_id,\t\t\t      \\\n\t\t.name = DEVLINK_TRAP_GENERIC_NAME_##_id,\t\t      \\\n\t}\n\nstatic const struct devlink_trap devlink_trap_generic[] = {\n\tDEVLINK_TRAP(SMAC_MC, DROP),\n\tDEVLINK_TRAP(VLAN_TAG_MISMATCH, DROP),\n\tDEVLINK_TRAP(INGRESS_VLAN_FILTER, DROP),\n\tDEVLINK_TRAP(INGRESS_STP_FILTER, DROP),\n\tDEVLINK_TRAP(EMPTY_TX_LIST, DROP),\n\tDEVLINK_TRAP(PORT_LOOPBACK_FILTER, DROP),\n\tDEVLINK_TRAP(BLACKHOLE_ROUTE, DROP),\n\tDEVLINK_TRAP(TTL_ERROR, EXCEPTION),\n\tDEVLINK_TRAP(TAIL_DROP, DROP),\n\tDEVLINK_TRAP(NON_IP_PACKET, DROP),\n\tDEVLINK_TRAP(UC_DIP_MC_DMAC, DROP),\n\tDEVLINK_TRAP(DIP_LB, DROP),\n\tDEVLINK_TRAP(SIP_MC, DROP),\n\tDEVLINK_TRAP(SIP_LB, DROP),\n\tDEVLINK_TRAP(CORRUPTED_IP_HDR, DROP),\n\tDEVLINK_TRAP(IPV4_SIP_BC, DROP),\n\tDEVLINK_TRAP(IPV6_MC_DIP_RESERVED_SCOPE, DROP),\n\tDEVLINK_TRAP(IPV6_MC_DIP_INTERFACE_LOCAL_SCOPE, DROP),\n\tDEVLINK_TRAP(MTU_ERROR, EXCEPTION),\n\tDEVLINK_TRAP(UNRESOLVED_NEIGH, EXCEPTION),\n\tDEVLINK_TRAP(RPF, EXCEPTION),\n\tDEVLINK_TRAP(REJECT_ROUTE, EXCEPTION),\n\tDEVLINK_TRAP(IPV4_LPM_UNICAST_MISS, EXCEPTION),\n\tDEVLINK_TRAP(IPV6_LPM_UNICAST_MISS, EXCEPTION),\n\tDEVLINK_TRAP(NON_ROUTABLE, DROP),\n\tDEVLINK_TRAP(DECAP_ERROR, EXCEPTION),\n\tDEVLINK_TRAP(OVERLAY_SMAC_MC, DROP),\n\tDEVLINK_TRAP(INGRESS_FLOW_ACTION_DROP, DROP),\n\tDEVLINK_TRAP(EGRESS_FLOW_ACTION_DROP, DROP),\n\tDEVLINK_TRAP(STP, CONTROL),\n\tDEVLINK_TRAP(LACP, CONTROL),\n\tDEVLINK_TRAP(LLDP, CONTROL),\n\tDEVLINK_TRAP(IGMP_QUERY, CONTROL),\n\tDEVLINK_TRAP(IGMP_V1_REPORT, CONTROL),\n\tDEVLINK_TRAP(IGMP_V2_REPORT, CONTROL),\n\tDEVLINK_TRAP(IGMP_V3_REPORT, CONTROL),\n\tDEVLINK_TRAP(IGMP_V2_LEAVE, CONTROL),\n\tDEVLINK_TRAP(MLD_QUERY, CONTROL),\n\tDEVLINK_TRAP(MLD_V1_REPORT, CONTROL),\n\tDEVLINK_TRAP(MLD_V2_REPORT, CONTROL),\n\tDEVLINK_TRAP(MLD_V1_DONE, CONTROL),\n\tDEVLINK_TRAP(IPV4_DHCP, CONTROL),\n\tDEVLINK_TRAP(IPV6_DHCP, CONTROL),\n\tDEVLINK_TRAP(ARP_REQUEST, CONTROL),\n\tDEVLINK_TRAP(ARP_RESPONSE, CONTROL),\n\tDEVLINK_TRAP(ARP_OVERLAY, CONTROL),\n\tDEVLINK_TRAP(IPV6_NEIGH_SOLICIT, CONTROL),\n\tDEVLINK_TRAP(IPV6_NEIGH_ADVERT, CONTROL),\n\tDEVLINK_TRAP(IPV4_BFD, CONTROL),\n\tDEVLINK_TRAP(IPV6_BFD, CONTROL),\n\tDEVLINK_TRAP(IPV4_OSPF, CONTROL),\n\tDEVLINK_TRAP(IPV6_OSPF, CONTROL),\n\tDEVLINK_TRAP(IPV4_BGP, CONTROL),\n\tDEVLINK_TRAP(IPV6_BGP, CONTROL),\n\tDEVLINK_TRAP(IPV4_VRRP, CONTROL),\n\tDEVLINK_TRAP(IPV6_VRRP, CONTROL),\n\tDEVLINK_TRAP(IPV4_PIM, CONTROL),\n\tDEVLINK_TRAP(IPV6_PIM, CONTROL),\n\tDEVLINK_TRAP(UC_LB, CONTROL),\n\tDEVLINK_TRAP(LOCAL_ROUTE, CONTROL),\n\tDEVLINK_TRAP(EXTERNAL_ROUTE, CONTROL),\n\tDEVLINK_TRAP(IPV6_UC_DIP_LINK_LOCAL_SCOPE, CONTROL),\n\tDEVLINK_TRAP(IPV6_DIP_ALL_NODES, CONTROL),\n\tDEVLINK_TRAP(IPV6_DIP_ALL_ROUTERS, CONTROL),\n\tDEVLINK_TRAP(IPV6_ROUTER_SOLICIT, CONTROL),\n\tDEVLINK_TRAP(IPV6_ROUTER_ADVERT, CONTROL),\n\tDEVLINK_TRAP(IPV6_REDIRECT, CONTROL),\n\tDEVLINK_TRAP(IPV4_ROUTER_ALERT, CONTROL),\n\tDEVLINK_TRAP(IPV6_ROUTER_ALERT, CONTROL),\n\tDEVLINK_TRAP(PTP_EVENT, CONTROL),\n\tDEVLINK_TRAP(PTP_GENERAL, CONTROL),\n\tDEVLINK_TRAP(FLOW_ACTION_SAMPLE, CONTROL),\n\tDEVLINK_TRAP(FLOW_ACTION_TRAP, CONTROL),\n\tDEVLINK_TRAP(EARLY_DROP, DROP),\n\tDEVLINK_TRAP(VXLAN_PARSING, DROP),\n\tDEVLINK_TRAP(LLC_SNAP_PARSING, DROP),\n\tDEVLINK_TRAP(VLAN_PARSING, DROP),\n\tDEVLINK_TRAP(PPPOE_PPP_PARSING, DROP),\n\tDEVLINK_TRAP(MPLS_PARSING, DROP),\n\tDEVLINK_TRAP(ARP_PARSING, DROP),\n\tDEVLINK_TRAP(IP_1_PARSING, DROP),\n\tDEVLINK_TRAP(IP_N_PARSING, DROP),\n\tDEVLINK_TRAP(GRE_PARSING, DROP),\n\tDEVLINK_TRAP(UDP_PARSING, DROP),\n\tDEVLINK_TRAP(TCP_PARSING, DROP),\n\tDEVLINK_TRAP(IPSEC_PARSING, DROP),\n\tDEVLINK_TRAP(SCTP_PARSING, DROP),\n\tDEVLINK_TRAP(DCCP_PARSING, DROP),\n\tDEVLINK_TRAP(GTP_PARSING, DROP),\n\tDEVLINK_TRAP(ESP_PARSING, DROP),\n\tDEVLINK_TRAP(BLACKHOLE_NEXTHOP, DROP),\n\tDEVLINK_TRAP(DMAC_FILTER, DROP),\n\tDEVLINK_TRAP(EAPOL, CONTROL),\n\tDEVLINK_TRAP(LOCKED_PORT, DROP),\n};\n\n#define DEVLINK_TRAP_GROUP(_id)\t\t\t\t\t\t      \\\n\t{\t\t\t\t\t\t\t\t      \\\n\t\t.id = DEVLINK_TRAP_GROUP_GENERIC_ID_##_id,\t\t      \\\n\t\t.name = DEVLINK_TRAP_GROUP_GENERIC_NAME_##_id,\t\t      \\\n\t}\n\nstatic const struct devlink_trap_group devlink_trap_group_generic[] = {\n\tDEVLINK_TRAP_GROUP(L2_DROPS),\n\tDEVLINK_TRAP_GROUP(L3_DROPS),\n\tDEVLINK_TRAP_GROUP(L3_EXCEPTIONS),\n\tDEVLINK_TRAP_GROUP(BUFFER_DROPS),\n\tDEVLINK_TRAP_GROUP(TUNNEL_DROPS),\n\tDEVLINK_TRAP_GROUP(ACL_DROPS),\n\tDEVLINK_TRAP_GROUP(STP),\n\tDEVLINK_TRAP_GROUP(LACP),\n\tDEVLINK_TRAP_GROUP(LLDP),\n\tDEVLINK_TRAP_GROUP(MC_SNOOPING),\n\tDEVLINK_TRAP_GROUP(DHCP),\n\tDEVLINK_TRAP_GROUP(NEIGH_DISCOVERY),\n\tDEVLINK_TRAP_GROUP(BFD),\n\tDEVLINK_TRAP_GROUP(OSPF),\n\tDEVLINK_TRAP_GROUP(BGP),\n\tDEVLINK_TRAP_GROUP(VRRP),\n\tDEVLINK_TRAP_GROUP(PIM),\n\tDEVLINK_TRAP_GROUP(UC_LB),\n\tDEVLINK_TRAP_GROUP(LOCAL_DELIVERY),\n\tDEVLINK_TRAP_GROUP(EXTERNAL_DELIVERY),\n\tDEVLINK_TRAP_GROUP(IPV6),\n\tDEVLINK_TRAP_GROUP(PTP_EVENT),\n\tDEVLINK_TRAP_GROUP(PTP_GENERAL),\n\tDEVLINK_TRAP_GROUP(ACL_SAMPLE),\n\tDEVLINK_TRAP_GROUP(ACL_TRAP),\n\tDEVLINK_TRAP_GROUP(PARSER_ERROR_DROPS),\n\tDEVLINK_TRAP_GROUP(EAPOL),\n};\n\nstatic int devlink_trap_generic_verify(const struct devlink_trap *trap)\n{\n\tif (trap->id > DEVLINK_TRAP_GENERIC_ID_MAX)\n\t\treturn -EINVAL;\n\n\tif (strcmp(trap->name, devlink_trap_generic[trap->id].name))\n\t\treturn -EINVAL;\n\n\tif (trap->type != devlink_trap_generic[trap->id].type)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int devlink_trap_driver_verify(const struct devlink_trap *trap)\n{\n\tint i;\n\n\tif (trap->id <= DEVLINK_TRAP_GENERIC_ID_MAX)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(devlink_trap_generic); i++) {\n\t\tif (!strcmp(trap->name, devlink_trap_generic[i].name))\n\t\t\treturn -EEXIST;\n\t}\n\n\treturn 0;\n}\n\nstatic int devlink_trap_verify(const struct devlink_trap *trap)\n{\n\tif (!trap || !trap->name)\n\t\treturn -EINVAL;\n\n\tif (trap->generic)\n\t\treturn devlink_trap_generic_verify(trap);\n\telse\n\t\treturn devlink_trap_driver_verify(trap);\n}\n\nstatic int\ndevlink_trap_group_generic_verify(const struct devlink_trap_group *group)\n{\n\tif (group->id > DEVLINK_TRAP_GROUP_GENERIC_ID_MAX)\n\t\treturn -EINVAL;\n\n\tif (strcmp(group->name, devlink_trap_group_generic[group->id].name))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\ndevlink_trap_group_driver_verify(const struct devlink_trap_group *group)\n{\n\tint i;\n\n\tif (group->id <= DEVLINK_TRAP_GROUP_GENERIC_ID_MAX)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(devlink_trap_group_generic); i++) {\n\t\tif (!strcmp(group->name, devlink_trap_group_generic[i].name))\n\t\t\treturn -EEXIST;\n\t}\n\n\treturn 0;\n}\n\nstatic int devlink_trap_group_verify(const struct devlink_trap_group *group)\n{\n\tif (group->generic)\n\t\treturn devlink_trap_group_generic_verify(group);\n\telse\n\t\treturn devlink_trap_group_driver_verify(group);\n}\n\nstatic void\ndevlink_trap_group_notify(struct devlink *devlink,\n\t\t\t  const struct devlink_trap_group_item *group_item,\n\t\t\t  enum devlink_command cmd)\n{\n\tstruct sk_buff *msg;\n\tint err;\n\n\tWARN_ON_ONCE(cmd != DEVLINK_CMD_TRAP_GROUP_NEW &&\n\t\t     cmd != DEVLINK_CMD_TRAP_GROUP_DEL);\n\tif (!xa_get_mark(&devlinks, devlink->index, DEVLINK_REGISTERED))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\terr = devlink_nl_trap_group_fill(msg, devlink, group_item, cmd, 0, 0,\n\t\t\t\t\t 0);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink),\n\t\t\t\tmsg, 0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nvoid devlink_trap_groups_notify_register(struct devlink *devlink)\n{\n\tstruct devlink_trap_group_item *group_item;\n\n\tlist_for_each_entry(group_item, &devlink->trap_group_list, list)\n\t\tdevlink_trap_group_notify(devlink, group_item,\n\t\t\t\t\t  DEVLINK_CMD_TRAP_GROUP_NEW);\n}\n\nvoid devlink_trap_groups_notify_unregister(struct devlink *devlink)\n{\n\tstruct devlink_trap_group_item *group_item;\n\n\tlist_for_each_entry_reverse(group_item, &devlink->trap_group_list, list)\n\t\tdevlink_trap_group_notify(devlink, group_item,\n\t\t\t\t\t  DEVLINK_CMD_TRAP_GROUP_DEL);\n}\n\nstatic int\ndevlink_trap_item_group_link(struct devlink *devlink,\n\t\t\t     struct devlink_trap_item *trap_item)\n{\n\tu16 group_id = trap_item->trap->init_group_id;\n\tstruct devlink_trap_group_item *group_item;\n\n\tgroup_item = devlink_trap_group_item_lookup_by_id(devlink, group_id);\n\tif (WARN_ON_ONCE(!group_item))\n\t\treturn -EINVAL;\n\n\ttrap_item->group_item = group_item;\n\n\treturn 0;\n}\n\nstatic void devlink_trap_notify(struct devlink *devlink,\n\t\t\t\tconst struct devlink_trap_item *trap_item,\n\t\t\t\tenum devlink_command cmd)\n{\n\tstruct sk_buff *msg;\n\tint err;\n\n\tWARN_ON_ONCE(cmd != DEVLINK_CMD_TRAP_NEW &&\n\t\t     cmd != DEVLINK_CMD_TRAP_DEL);\n\tif (!xa_get_mark(&devlinks, devlink->index, DEVLINK_REGISTERED))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\terr = devlink_nl_trap_fill(msg, devlink, trap_item, cmd, 0, 0, 0);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink),\n\t\t\t\tmsg, 0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nvoid devlink_traps_notify_register(struct devlink *devlink)\n{\n\tstruct devlink_trap_item *trap_item;\n\n\tlist_for_each_entry(trap_item, &devlink->trap_list, list)\n\t\tdevlink_trap_notify(devlink, trap_item, DEVLINK_CMD_TRAP_NEW);\n}\n\nvoid devlink_traps_notify_unregister(struct devlink *devlink)\n{\n\tstruct devlink_trap_item *trap_item;\n\n\tlist_for_each_entry_reverse(trap_item, &devlink->trap_list, list)\n\t\tdevlink_trap_notify(devlink, trap_item, DEVLINK_CMD_TRAP_DEL);\n}\n\nstatic int\ndevlink_trap_register(struct devlink *devlink,\n\t\t      const struct devlink_trap *trap, void *priv)\n{\n\tstruct devlink_trap_item *trap_item;\n\tint err;\n\n\tif (devlink_trap_item_lookup(devlink, trap->name))\n\t\treturn -EEXIST;\n\n\ttrap_item = kzalloc(sizeof(*trap_item), GFP_KERNEL);\n\tif (!trap_item)\n\t\treturn -ENOMEM;\n\n\ttrap_item->stats = netdev_alloc_pcpu_stats(struct devlink_stats);\n\tif (!trap_item->stats) {\n\t\terr = -ENOMEM;\n\t\tgoto err_stats_alloc;\n\t}\n\n\ttrap_item->trap = trap;\n\ttrap_item->action = trap->init_action;\n\ttrap_item->priv = priv;\n\n\terr = devlink_trap_item_group_link(devlink, trap_item);\n\tif (err)\n\t\tgoto err_group_link;\n\n\terr = devlink->ops->trap_init(devlink, trap, trap_item);\n\tif (err)\n\t\tgoto err_trap_init;\n\n\tlist_add_tail(&trap_item->list, &devlink->trap_list);\n\tdevlink_trap_notify(devlink, trap_item, DEVLINK_CMD_TRAP_NEW);\n\n\treturn 0;\n\nerr_trap_init:\nerr_group_link:\n\tfree_percpu(trap_item->stats);\nerr_stats_alloc:\n\tkfree(trap_item);\n\treturn err;\n}\n\nstatic void devlink_trap_unregister(struct devlink *devlink,\n\t\t\t\t    const struct devlink_trap *trap)\n{\n\tstruct devlink_trap_item *trap_item;\n\n\ttrap_item = devlink_trap_item_lookup(devlink, trap->name);\n\tif (WARN_ON_ONCE(!trap_item))\n\t\treturn;\n\n\tdevlink_trap_notify(devlink, trap_item, DEVLINK_CMD_TRAP_DEL);\n\tlist_del(&trap_item->list);\n\tif (devlink->ops->trap_fini)\n\t\tdevlink->ops->trap_fini(devlink, trap, trap_item);\n\tfree_percpu(trap_item->stats);\n\tkfree(trap_item);\n}\n\nstatic void devlink_trap_disable(struct devlink *devlink,\n\t\t\t\t const struct devlink_trap *trap)\n{\n\tstruct devlink_trap_item *trap_item;\n\n\ttrap_item = devlink_trap_item_lookup(devlink, trap->name);\n\tif (WARN_ON_ONCE(!trap_item))\n\t\treturn;\n\n\tdevlink->ops->trap_action_set(devlink, trap, DEVLINK_TRAP_ACTION_DROP,\n\t\t\t\t      NULL);\n\ttrap_item->action = DEVLINK_TRAP_ACTION_DROP;\n}\n\n \nint devl_traps_register(struct devlink *devlink,\n\t\t\tconst struct devlink_trap *traps,\n\t\t\tsize_t traps_count, void *priv)\n{\n\tint i, err;\n\n\tif (!devlink->ops->trap_init || !devlink->ops->trap_action_set)\n\t\treturn -EINVAL;\n\n\tdevl_assert_locked(devlink);\n\tfor (i = 0; i < traps_count; i++) {\n\t\tconst struct devlink_trap *trap = &traps[i];\n\n\t\terr = devlink_trap_verify(trap);\n\t\tif (err)\n\t\t\tgoto err_trap_verify;\n\n\t\terr = devlink_trap_register(devlink, trap, priv);\n\t\tif (err)\n\t\t\tgoto err_trap_register;\n\t}\n\n\treturn 0;\n\nerr_trap_register:\nerr_trap_verify:\n\tfor (i--; i >= 0; i--)\n\t\tdevlink_trap_unregister(devlink, &traps[i]);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(devl_traps_register);\n\n \nint devlink_traps_register(struct devlink *devlink,\n\t\t\t   const struct devlink_trap *traps,\n\t\t\t   size_t traps_count, void *priv)\n{\n\tint err;\n\n\tdevl_lock(devlink);\n\terr = devl_traps_register(devlink, traps, traps_count, priv);\n\tdevl_unlock(devlink);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(devlink_traps_register);\n\n \nvoid devl_traps_unregister(struct devlink *devlink,\n\t\t\t   const struct devlink_trap *traps,\n\t\t\t   size_t traps_count)\n{\n\tint i;\n\n\tdevl_assert_locked(devlink);\n\t \n\tfor (i = traps_count - 1; i >= 0; i--)\n\t\tdevlink_trap_disable(devlink, &traps[i]);\n\tsynchronize_rcu();\n\tfor (i = traps_count - 1; i >= 0; i--)\n\t\tdevlink_trap_unregister(devlink, &traps[i]);\n}\nEXPORT_SYMBOL_GPL(devl_traps_unregister);\n\n \nvoid devlink_traps_unregister(struct devlink *devlink,\n\t\t\t      const struct devlink_trap *traps,\n\t\t\t      size_t traps_count)\n{\n\tdevl_lock(devlink);\n\tdevl_traps_unregister(devlink, traps, traps_count);\n\tdevl_unlock(devlink);\n}\nEXPORT_SYMBOL_GPL(devlink_traps_unregister);\n\nstatic void\ndevlink_trap_stats_update(struct devlink_stats __percpu *trap_stats,\n\t\t\t  size_t skb_len)\n{\n\tstruct devlink_stats *stats;\n\n\tstats = this_cpu_ptr(trap_stats);\n\tu64_stats_update_begin(&stats->syncp);\n\tu64_stats_add(&stats->rx_bytes, skb_len);\n\tu64_stats_inc(&stats->rx_packets);\n\tu64_stats_update_end(&stats->syncp);\n}\n\nstatic void\ndevlink_trap_report_metadata_set(struct devlink_trap_metadata *metadata,\n\t\t\t\t const struct devlink_trap_item *trap_item,\n\t\t\t\t struct devlink_port *in_devlink_port,\n\t\t\t\t const struct flow_action_cookie *fa_cookie)\n{\n\tmetadata->trap_name = trap_item->trap->name;\n\tmetadata->trap_group_name = trap_item->group_item->group->name;\n\tmetadata->fa_cookie = fa_cookie;\n\tmetadata->trap_type = trap_item->trap->type;\n\n\tspin_lock(&in_devlink_port->type_lock);\n\tif (in_devlink_port->type == DEVLINK_PORT_TYPE_ETH)\n\t\tmetadata->input_dev = in_devlink_port->type_eth.netdev;\n\tspin_unlock(&in_devlink_port->type_lock);\n}\n\n \nvoid devlink_trap_report(struct devlink *devlink, struct sk_buff *skb,\n\t\t\t void *trap_ctx, struct devlink_port *in_devlink_port,\n\t\t\t const struct flow_action_cookie *fa_cookie)\n\n{\n\tstruct devlink_trap_item *trap_item = trap_ctx;\n\n\tdevlink_trap_stats_update(trap_item->stats, skb->len);\n\tdevlink_trap_stats_update(trap_item->group_item->stats, skb->len);\n\n\tif (tracepoint_enabled(devlink_trap_report)) {\n\t\tstruct devlink_trap_metadata metadata = {};\n\n\t\tdevlink_trap_report_metadata_set(&metadata, trap_item,\n\t\t\t\t\t\t in_devlink_port, fa_cookie);\n\t\ttrace_devlink_trap_report(devlink, skb, &metadata);\n\t}\n}\nEXPORT_SYMBOL_GPL(devlink_trap_report);\n\n \nvoid *devlink_trap_ctx_priv(void *trap_ctx)\n{\n\tstruct devlink_trap_item *trap_item = trap_ctx;\n\n\treturn trap_item->priv;\n}\nEXPORT_SYMBOL_GPL(devlink_trap_ctx_priv);\n\nstatic int\ndevlink_trap_group_item_policer_link(struct devlink *devlink,\n\t\t\t\t     struct devlink_trap_group_item *group_item)\n{\n\tu32 policer_id = group_item->group->init_policer_id;\n\tstruct devlink_trap_policer_item *policer_item;\n\n\tif (policer_id == 0)\n\t\treturn 0;\n\n\tpolicer_item = devlink_trap_policer_item_lookup(devlink, policer_id);\n\tif (WARN_ON_ONCE(!policer_item))\n\t\treturn -EINVAL;\n\n\tgroup_item->policer_item = policer_item;\n\n\treturn 0;\n}\n\nstatic int\ndevlink_trap_group_register(struct devlink *devlink,\n\t\t\t    const struct devlink_trap_group *group)\n{\n\tstruct devlink_trap_group_item *group_item;\n\tint err;\n\n\tif (devlink_trap_group_item_lookup(devlink, group->name))\n\t\treturn -EEXIST;\n\n\tgroup_item = kzalloc(sizeof(*group_item), GFP_KERNEL);\n\tif (!group_item)\n\t\treturn -ENOMEM;\n\n\tgroup_item->stats = netdev_alloc_pcpu_stats(struct devlink_stats);\n\tif (!group_item->stats) {\n\t\terr = -ENOMEM;\n\t\tgoto err_stats_alloc;\n\t}\n\n\tgroup_item->group = group;\n\n\terr = devlink_trap_group_item_policer_link(devlink, group_item);\n\tif (err)\n\t\tgoto err_policer_link;\n\n\tif (devlink->ops->trap_group_init) {\n\t\terr = devlink->ops->trap_group_init(devlink, group);\n\t\tif (err)\n\t\t\tgoto err_group_init;\n\t}\n\n\tlist_add_tail(&group_item->list, &devlink->trap_group_list);\n\tdevlink_trap_group_notify(devlink, group_item,\n\t\t\t\t  DEVLINK_CMD_TRAP_GROUP_NEW);\n\n\treturn 0;\n\nerr_group_init:\nerr_policer_link:\n\tfree_percpu(group_item->stats);\nerr_stats_alloc:\n\tkfree(group_item);\n\treturn err;\n}\n\nstatic void\ndevlink_trap_group_unregister(struct devlink *devlink,\n\t\t\t      const struct devlink_trap_group *group)\n{\n\tstruct devlink_trap_group_item *group_item;\n\n\tgroup_item = devlink_trap_group_item_lookup(devlink, group->name);\n\tif (WARN_ON_ONCE(!group_item))\n\t\treturn;\n\n\tdevlink_trap_group_notify(devlink, group_item,\n\t\t\t\t  DEVLINK_CMD_TRAP_GROUP_DEL);\n\tlist_del(&group_item->list);\n\tfree_percpu(group_item->stats);\n\tkfree(group_item);\n}\n\n \nint devl_trap_groups_register(struct devlink *devlink,\n\t\t\t      const struct devlink_trap_group *groups,\n\t\t\t      size_t groups_count)\n{\n\tint i, err;\n\n\tdevl_assert_locked(devlink);\n\tfor (i = 0; i < groups_count; i++) {\n\t\tconst struct devlink_trap_group *group = &groups[i];\n\n\t\terr = devlink_trap_group_verify(group);\n\t\tif (err)\n\t\t\tgoto err_trap_group_verify;\n\n\t\terr = devlink_trap_group_register(devlink, group);\n\t\tif (err)\n\t\t\tgoto err_trap_group_register;\n\t}\n\n\treturn 0;\n\nerr_trap_group_register:\nerr_trap_group_verify:\n\tfor (i--; i >= 0; i--)\n\t\tdevlink_trap_group_unregister(devlink, &groups[i]);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(devl_trap_groups_register);\n\n \nint devlink_trap_groups_register(struct devlink *devlink,\n\t\t\t\t const struct devlink_trap_group *groups,\n\t\t\t\t size_t groups_count)\n{\n\tint err;\n\n\tdevl_lock(devlink);\n\terr = devl_trap_groups_register(devlink, groups, groups_count);\n\tdevl_unlock(devlink);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(devlink_trap_groups_register);\n\n \nvoid devl_trap_groups_unregister(struct devlink *devlink,\n\t\t\t\t const struct devlink_trap_group *groups,\n\t\t\t\t size_t groups_count)\n{\n\tint i;\n\n\tdevl_assert_locked(devlink);\n\tfor (i = groups_count - 1; i >= 0; i--)\n\t\tdevlink_trap_group_unregister(devlink, &groups[i]);\n}\nEXPORT_SYMBOL_GPL(devl_trap_groups_unregister);\n\n \nvoid devlink_trap_groups_unregister(struct devlink *devlink,\n\t\t\t\t    const struct devlink_trap_group *groups,\n\t\t\t\t    size_t groups_count)\n{\n\tdevl_lock(devlink);\n\tdevl_trap_groups_unregister(devlink, groups, groups_count);\n\tdevl_unlock(devlink);\n}\nEXPORT_SYMBOL_GPL(devlink_trap_groups_unregister);\n\nstatic void\ndevlink_trap_policer_notify(struct devlink *devlink,\n\t\t\t    const struct devlink_trap_policer_item *policer_item,\n\t\t\t    enum devlink_command cmd)\n{\n\tstruct sk_buff *msg;\n\tint err;\n\n\tWARN_ON_ONCE(cmd != DEVLINK_CMD_TRAP_POLICER_NEW &&\n\t\t     cmd != DEVLINK_CMD_TRAP_POLICER_DEL);\n\tif (!xa_get_mark(&devlinks, devlink->index, DEVLINK_REGISTERED))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\terr = devlink_nl_trap_policer_fill(msg, devlink, policer_item, cmd, 0,\n\t\t\t\t\t   0, 0);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink),\n\t\t\t\tmsg, 0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nvoid devlink_trap_policers_notify_register(struct devlink *devlink)\n{\n\tstruct devlink_trap_policer_item *policer_item;\n\n\tlist_for_each_entry(policer_item, &devlink->trap_policer_list, list)\n\t\tdevlink_trap_policer_notify(devlink, policer_item,\n\t\t\t\t\t    DEVLINK_CMD_TRAP_POLICER_NEW);\n}\n\nvoid devlink_trap_policers_notify_unregister(struct devlink *devlink)\n{\n\tstruct devlink_trap_policer_item *policer_item;\n\n\tlist_for_each_entry_reverse(policer_item, &devlink->trap_policer_list,\n\t\t\t\t    list)\n\t\tdevlink_trap_policer_notify(devlink, policer_item,\n\t\t\t\t\t    DEVLINK_CMD_TRAP_POLICER_DEL);\n}\n\nstatic int\ndevlink_trap_policer_register(struct devlink *devlink,\n\t\t\t      const struct devlink_trap_policer *policer)\n{\n\tstruct devlink_trap_policer_item *policer_item;\n\tint err;\n\n\tif (devlink_trap_policer_item_lookup(devlink, policer->id))\n\t\treturn -EEXIST;\n\n\tpolicer_item = kzalloc(sizeof(*policer_item), GFP_KERNEL);\n\tif (!policer_item)\n\t\treturn -ENOMEM;\n\n\tpolicer_item->policer = policer;\n\tpolicer_item->rate = policer->init_rate;\n\tpolicer_item->burst = policer->init_burst;\n\n\tif (devlink->ops->trap_policer_init) {\n\t\terr = devlink->ops->trap_policer_init(devlink, policer);\n\t\tif (err)\n\t\t\tgoto err_policer_init;\n\t}\n\n\tlist_add_tail(&policer_item->list, &devlink->trap_policer_list);\n\tdevlink_trap_policer_notify(devlink, policer_item,\n\t\t\t\t    DEVLINK_CMD_TRAP_POLICER_NEW);\n\n\treturn 0;\n\nerr_policer_init:\n\tkfree(policer_item);\n\treturn err;\n}\n\nstatic void\ndevlink_trap_policer_unregister(struct devlink *devlink,\n\t\t\t\tconst struct devlink_trap_policer *policer)\n{\n\tstruct devlink_trap_policer_item *policer_item;\n\n\tpolicer_item = devlink_trap_policer_item_lookup(devlink, policer->id);\n\tif (WARN_ON_ONCE(!policer_item))\n\t\treturn;\n\n\tdevlink_trap_policer_notify(devlink, policer_item,\n\t\t\t\t    DEVLINK_CMD_TRAP_POLICER_DEL);\n\tlist_del(&policer_item->list);\n\tif (devlink->ops->trap_policer_fini)\n\t\tdevlink->ops->trap_policer_fini(devlink, policer);\n\tkfree(policer_item);\n}\n\n \nint\ndevl_trap_policers_register(struct devlink *devlink,\n\t\t\t    const struct devlink_trap_policer *policers,\n\t\t\t    size_t policers_count)\n{\n\tint i, err;\n\n\tdevl_assert_locked(devlink);\n\tfor (i = 0; i < policers_count; i++) {\n\t\tconst struct devlink_trap_policer *policer = &policers[i];\n\n\t\tif (WARN_ON(policer->id == 0 ||\n\t\t\t    policer->max_rate < policer->min_rate ||\n\t\t\t    policer->max_burst < policer->min_burst)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_trap_policer_verify;\n\t\t}\n\n\t\terr = devlink_trap_policer_register(devlink, policer);\n\t\tif (err)\n\t\t\tgoto err_trap_policer_register;\n\t}\n\treturn 0;\n\nerr_trap_policer_register:\nerr_trap_policer_verify:\n\tfor (i--; i >= 0; i--)\n\t\tdevlink_trap_policer_unregister(devlink, &policers[i]);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(devl_trap_policers_register);\n\n \nvoid\ndevl_trap_policers_unregister(struct devlink *devlink,\n\t\t\t      const struct devlink_trap_policer *policers,\n\t\t\t      size_t policers_count)\n{\n\tint i;\n\n\tdevl_assert_locked(devlink);\n\tfor (i = policers_count - 1; i >= 0; i--)\n\t\tdevlink_trap_policer_unregister(devlink, &policers[i]);\n}\nEXPORT_SYMBOL_GPL(devl_trap_policers_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}