{
  "module_name": "param.c",
  "hash_id": "92eff5421d5097a076673312e60c3969af9b1fd86cf6f23c7442d6cf8f213890",
  "original_prompt": "Ingested from linux-6.6.14/net/devlink/param.c",
  "human_readable_source": "\n \n\n#include \"devl_internal.h\"\n\nstatic const struct devlink_param devlink_param_generic[] = {\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_INT_ERR_RESET,\n\t\t.name = DEVLINK_PARAM_GENERIC_INT_ERR_RESET_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_INT_ERR_RESET_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_MAX_MACS,\n\t\t.name = DEVLINK_PARAM_GENERIC_MAX_MACS_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_MAX_MACS_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_ENABLE_SRIOV,\n\t\t.name = DEVLINK_PARAM_GENERIC_ENABLE_SRIOV_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_ENABLE_SRIOV_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_REGION_SNAPSHOT,\n\t\t.name = DEVLINK_PARAM_GENERIC_REGION_SNAPSHOT_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_REGION_SNAPSHOT_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_IGNORE_ARI,\n\t\t.name = DEVLINK_PARAM_GENERIC_IGNORE_ARI_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_IGNORE_ARI_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MAX,\n\t\t.name = DEVLINK_PARAM_GENERIC_MSIX_VEC_PER_PF_MAX_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_MSIX_VEC_PER_PF_MAX_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MIN,\n\t\t.name = DEVLINK_PARAM_GENERIC_MSIX_VEC_PER_PF_MIN_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_MSIX_VEC_PER_PF_MIN_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_FW_LOAD_POLICY,\n\t\t.name = DEVLINK_PARAM_GENERIC_FW_LOAD_POLICY_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_FW_LOAD_POLICY_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_RESET_DEV_ON_DRV_PROBE,\n\t\t.name = DEVLINK_PARAM_GENERIC_RESET_DEV_ON_DRV_PROBE_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_RESET_DEV_ON_DRV_PROBE_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE,\n\t\t.name = DEVLINK_PARAM_GENERIC_ENABLE_ROCE_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_ENABLE_ROCE_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_ENABLE_REMOTE_DEV_RESET,\n\t\t.name = DEVLINK_PARAM_GENERIC_ENABLE_REMOTE_DEV_RESET_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_ENABLE_REMOTE_DEV_RESET_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_ENABLE_ETH,\n\t\t.name = DEVLINK_PARAM_GENERIC_ENABLE_ETH_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_ENABLE_ETH_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_ENABLE_RDMA,\n\t\t.name = DEVLINK_PARAM_GENERIC_ENABLE_RDMA_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_ENABLE_RDMA_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_ENABLE_VNET,\n\t\t.name = DEVLINK_PARAM_GENERIC_ENABLE_VNET_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_ENABLE_VNET_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_ENABLE_IWARP,\n\t\t.name = DEVLINK_PARAM_GENERIC_ENABLE_IWARP_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_ENABLE_IWARP_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_IO_EQ_SIZE,\n\t\t.name = DEVLINK_PARAM_GENERIC_IO_EQ_SIZE_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_IO_EQ_SIZE_TYPE,\n\t},\n\t{\n\t\t.id = DEVLINK_PARAM_GENERIC_ID_EVENT_EQ_SIZE,\n\t\t.name = DEVLINK_PARAM_GENERIC_EVENT_EQ_SIZE_NAME,\n\t\t.type = DEVLINK_PARAM_GENERIC_EVENT_EQ_SIZE_TYPE,\n\t},\n};\n\nstatic int devlink_param_generic_verify(const struct devlink_param *param)\n{\n\t \n\tif (param->id > DEVLINK_PARAM_GENERIC_ID_MAX)\n\t\treturn -EINVAL;\n\tif (strcmp(param->name, devlink_param_generic[param->id].name))\n\t\treturn -ENOENT;\n\n\tWARN_ON(param->type != devlink_param_generic[param->id].type);\n\n\treturn 0;\n}\n\nstatic int devlink_param_driver_verify(const struct devlink_param *param)\n{\n\tint i;\n\n\tif (param->id <= DEVLINK_PARAM_GENERIC_ID_MAX)\n\t\treturn -EINVAL;\n\t \n\tfor (i = 0; i <= DEVLINK_PARAM_GENERIC_ID_MAX; i++)\n\t\tif (!strcmp(param->name, devlink_param_generic[i].name))\n\t\t\treturn -EEXIST;\n\n\treturn 0;\n}\n\nstatic struct devlink_param_item *\ndevlink_param_find_by_name(struct xarray *params, const char *param_name)\n{\n\tstruct devlink_param_item *param_item;\n\tunsigned long param_id;\n\n\txa_for_each(params, param_id, param_item) {\n\t\tif (!strcmp(param_item->param->name, param_name))\n\t\t\treturn param_item;\n\t}\n\treturn NULL;\n}\n\nstatic struct devlink_param_item *\ndevlink_param_find_by_id(struct xarray *params, u32 param_id)\n{\n\treturn xa_load(params, param_id);\n}\n\nstatic bool\ndevlink_param_cmode_is_supported(const struct devlink_param *param,\n\t\t\t\t enum devlink_param_cmode cmode)\n{\n\treturn test_bit(cmode, &param->supported_cmodes);\n}\n\nstatic int devlink_param_get(struct devlink *devlink,\n\t\t\t     const struct devlink_param *param,\n\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tif (!param->get)\n\t\treturn -EOPNOTSUPP;\n\treturn param->get(devlink, param->id, ctx);\n}\n\nstatic int devlink_param_set(struct devlink *devlink,\n\t\t\t     const struct devlink_param *param,\n\t\t\t     struct devlink_param_gset_ctx *ctx)\n{\n\tif (!param->set)\n\t\treturn -EOPNOTSUPP;\n\treturn param->set(devlink, param->id, ctx);\n}\n\nstatic int\ndevlink_param_type_to_nla_type(enum devlink_param_type param_type)\n{\n\tswitch (param_type) {\n\tcase DEVLINK_PARAM_TYPE_U8:\n\t\treturn NLA_U8;\n\tcase DEVLINK_PARAM_TYPE_U16:\n\t\treturn NLA_U16;\n\tcase DEVLINK_PARAM_TYPE_U32:\n\t\treturn NLA_U32;\n\tcase DEVLINK_PARAM_TYPE_STRING:\n\t\treturn NLA_STRING;\n\tcase DEVLINK_PARAM_TYPE_BOOL:\n\t\treturn NLA_FLAG;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\ndevlink_nl_param_value_fill_one(struct sk_buff *msg,\n\t\t\t\tenum devlink_param_type type,\n\t\t\t\tenum devlink_param_cmode cmode,\n\t\t\t\tunion devlink_param_value val)\n{\n\tstruct nlattr *param_value_attr;\n\n\tparam_value_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t DEVLINK_ATTR_PARAM_VALUE);\n\tif (!param_value_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, DEVLINK_ATTR_PARAM_VALUE_CMODE, cmode))\n\t\tgoto value_nest_cancel;\n\n\tswitch (type) {\n\tcase DEVLINK_PARAM_TYPE_U8:\n\t\tif (nla_put_u8(msg, DEVLINK_ATTR_PARAM_VALUE_DATA, val.vu8))\n\t\t\tgoto value_nest_cancel;\n\t\tbreak;\n\tcase DEVLINK_PARAM_TYPE_U16:\n\t\tif (nla_put_u16(msg, DEVLINK_ATTR_PARAM_VALUE_DATA, val.vu16))\n\t\t\tgoto value_nest_cancel;\n\t\tbreak;\n\tcase DEVLINK_PARAM_TYPE_U32:\n\t\tif (nla_put_u32(msg, DEVLINK_ATTR_PARAM_VALUE_DATA, val.vu32))\n\t\t\tgoto value_nest_cancel;\n\t\tbreak;\n\tcase DEVLINK_PARAM_TYPE_STRING:\n\t\tif (nla_put_string(msg, DEVLINK_ATTR_PARAM_VALUE_DATA,\n\t\t\t\t   val.vstr))\n\t\t\tgoto value_nest_cancel;\n\t\tbreak;\n\tcase DEVLINK_PARAM_TYPE_BOOL:\n\t\tif (val.vbool &&\n\t\t    nla_put_flag(msg, DEVLINK_ATTR_PARAM_VALUE_DATA))\n\t\t\tgoto value_nest_cancel;\n\t\tbreak;\n\t}\n\n\tnla_nest_end(msg, param_value_attr);\n\treturn 0;\n\nvalue_nest_cancel:\n\tnla_nest_cancel(msg, param_value_attr);\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int devlink_nl_param_fill(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t\t unsigned int port_index,\n\t\t\t\t struct devlink_param_item *param_item,\n\t\t\t\t enum devlink_command cmd,\n\t\t\t\t u32 portid, u32 seq, int flags)\n{\n\tunion devlink_param_value param_value[DEVLINK_PARAM_CMODE_MAX + 1];\n\tbool param_value_set[DEVLINK_PARAM_CMODE_MAX + 1] = {};\n\tconst struct devlink_param *param = param_item->param;\n\tstruct devlink_param_gset_ctx ctx;\n\tstruct nlattr *param_values_list;\n\tstruct nlattr *param_attr;\n\tint nla_type;\n\tvoid *hdr;\n\tint err;\n\tint i;\n\n\t \n\tfor (i = 0; i <= DEVLINK_PARAM_CMODE_MAX; i++) {\n\t\tif (!devlink_param_cmode_is_supported(param, i))\n\t\t\tcontinue;\n\t\tif (i == DEVLINK_PARAM_CMODE_DRIVERINIT) {\n\t\t\tif (param_item->driverinit_value_new_valid)\n\t\t\t\tparam_value[i] = param_item->driverinit_value_new;\n\t\t\telse if (param_item->driverinit_value_valid)\n\t\t\t\tparam_value[i] = param_item->driverinit_value;\n\t\t\telse\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t} else {\n\t\t\tctx.cmode = i;\n\t\t\terr = devlink_param_get(devlink, param, &ctx);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tparam_value[i] = ctx.val;\n\t\t}\n\t\tparam_value_set[i] = true;\n\t}\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto genlmsg_cancel;\n\n\tif (cmd == DEVLINK_CMD_PORT_PARAM_GET ||\n\t    cmd == DEVLINK_CMD_PORT_PARAM_NEW ||\n\t    cmd == DEVLINK_CMD_PORT_PARAM_DEL)\n\t\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_INDEX, port_index))\n\t\t\tgoto genlmsg_cancel;\n\n\tparam_attr = nla_nest_start_noflag(msg, DEVLINK_ATTR_PARAM);\n\tif (!param_attr)\n\t\tgoto genlmsg_cancel;\n\tif (nla_put_string(msg, DEVLINK_ATTR_PARAM_NAME, param->name))\n\t\tgoto param_nest_cancel;\n\tif (param->generic && nla_put_flag(msg, DEVLINK_ATTR_PARAM_GENERIC))\n\t\tgoto param_nest_cancel;\n\n\tnla_type = devlink_param_type_to_nla_type(param->type);\n\tif (nla_type < 0)\n\t\tgoto param_nest_cancel;\n\tif (nla_put_u8(msg, DEVLINK_ATTR_PARAM_TYPE, nla_type))\n\t\tgoto param_nest_cancel;\n\n\tparam_values_list = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  DEVLINK_ATTR_PARAM_VALUES_LIST);\n\tif (!param_values_list)\n\t\tgoto param_nest_cancel;\n\n\tfor (i = 0; i <= DEVLINK_PARAM_CMODE_MAX; i++) {\n\t\tif (!param_value_set[i])\n\t\t\tcontinue;\n\t\terr = devlink_nl_param_value_fill_one(msg, param->type,\n\t\t\t\t\t\t      i, param_value[i]);\n\t\tif (err)\n\t\t\tgoto values_list_nest_cancel;\n\t}\n\n\tnla_nest_end(msg, param_values_list);\n\tnla_nest_end(msg, param_attr);\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nvalues_list_nest_cancel:\n\tnla_nest_end(msg, param_values_list);\nparam_nest_cancel:\n\tnla_nest_cancel(msg, param_attr);\ngenlmsg_cancel:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic void devlink_param_notify(struct devlink *devlink,\n\t\t\t\t unsigned int port_index,\n\t\t\t\t struct devlink_param_item *param_item,\n\t\t\t\t enum devlink_command cmd)\n{\n\tstruct sk_buff *msg;\n\tint err;\n\n\tWARN_ON(cmd != DEVLINK_CMD_PARAM_NEW && cmd != DEVLINK_CMD_PARAM_DEL &&\n\t\tcmd != DEVLINK_CMD_PORT_PARAM_NEW &&\n\t\tcmd != DEVLINK_CMD_PORT_PARAM_DEL);\n\n\t \n\tif (!devl_is_registered(devlink))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\terr = devlink_nl_param_fill(msg, devlink, port_index, param_item, cmd,\n\t\t\t\t    0, 0, 0);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink),\n\t\t\t\tmsg, 0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nstatic void devlink_params_notify(struct devlink *devlink,\n\t\t\t\t  enum devlink_command cmd)\n{\n\tstruct devlink_param_item *param_item;\n\tunsigned long param_id;\n\n\txa_for_each(&devlink->params, param_id, param_item)\n\t\tdevlink_param_notify(devlink, 0, param_item, cmd);\n}\n\nvoid devlink_params_notify_register(struct devlink *devlink)\n{\n\tdevlink_params_notify(devlink, DEVLINK_CMD_PARAM_NEW);\n}\n\nvoid devlink_params_notify_unregister(struct devlink *devlink)\n{\n\tdevlink_params_notify(devlink, DEVLINK_CMD_PARAM_DEL);\n}\n\nstatic int devlink_nl_param_get_dump_one(struct sk_buff *msg,\n\t\t\t\t\t struct devlink *devlink,\n\t\t\t\t\t struct netlink_callback *cb,\n\t\t\t\t\t int flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct devlink_param_item *param_item;\n\tunsigned long param_id;\n\tint err = 0;\n\n\txa_for_each_start(&devlink->params, param_id, param_item, state->idx) {\n\t\terr = devlink_nl_param_fill(msg, devlink, 0, param_item,\n\t\t\t\t\t    DEVLINK_CMD_PARAM_GET,\n\t\t\t\t\t    NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t    cb->nlh->nlmsg_seq, flags);\n\t\tif (err == -EOPNOTSUPP) {\n\t\t\terr = 0;\n\t\t} else if (err) {\n\t\t\tstate->idx = param_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint devlink_nl_param_get_dumpit(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb, devlink_nl_param_get_dump_one);\n}\n\nstatic int\ndevlink_param_type_get_from_info(struct genl_info *info,\n\t\t\t\t enum devlink_param_type *param_type)\n{\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_PARAM_TYPE))\n\t\treturn -EINVAL;\n\n\tswitch (nla_get_u8(info->attrs[DEVLINK_ATTR_PARAM_TYPE])) {\n\tcase NLA_U8:\n\t\t*param_type = DEVLINK_PARAM_TYPE_U8;\n\t\tbreak;\n\tcase NLA_U16:\n\t\t*param_type = DEVLINK_PARAM_TYPE_U16;\n\t\tbreak;\n\tcase NLA_U32:\n\t\t*param_type = DEVLINK_PARAM_TYPE_U32;\n\t\tbreak;\n\tcase NLA_STRING:\n\t\t*param_type = DEVLINK_PARAM_TYPE_STRING;\n\t\tbreak;\n\tcase NLA_FLAG:\n\t\t*param_type = DEVLINK_PARAM_TYPE_BOOL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndevlink_param_value_get_from_info(const struct devlink_param *param,\n\t\t\t\t  struct genl_info *info,\n\t\t\t\t  union devlink_param_value *value)\n{\n\tstruct nlattr *param_data;\n\tint len;\n\n\tparam_data = info->attrs[DEVLINK_ATTR_PARAM_VALUE_DATA];\n\n\tif (param->type != DEVLINK_PARAM_TYPE_BOOL && !param_data)\n\t\treturn -EINVAL;\n\n\tswitch (param->type) {\n\tcase DEVLINK_PARAM_TYPE_U8:\n\t\tif (nla_len(param_data) != sizeof(u8))\n\t\t\treturn -EINVAL;\n\t\tvalue->vu8 = nla_get_u8(param_data);\n\t\tbreak;\n\tcase DEVLINK_PARAM_TYPE_U16:\n\t\tif (nla_len(param_data) != sizeof(u16))\n\t\t\treturn -EINVAL;\n\t\tvalue->vu16 = nla_get_u16(param_data);\n\t\tbreak;\n\tcase DEVLINK_PARAM_TYPE_U32:\n\t\tif (nla_len(param_data) != sizeof(u32))\n\t\t\treturn -EINVAL;\n\t\tvalue->vu32 = nla_get_u32(param_data);\n\t\tbreak;\n\tcase DEVLINK_PARAM_TYPE_STRING:\n\t\tlen = strnlen(nla_data(param_data), nla_len(param_data));\n\t\tif (len == nla_len(param_data) ||\n\t\t    len >= __DEVLINK_PARAM_MAX_STRING_VALUE)\n\t\t\treturn -EINVAL;\n\t\tstrcpy(value->vstr, nla_data(param_data));\n\t\tbreak;\n\tcase DEVLINK_PARAM_TYPE_BOOL:\n\t\tif (param_data && nla_len(param_data))\n\t\t\treturn -EINVAL;\n\t\tvalue->vbool = nla_get_flag(param_data);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic struct devlink_param_item *\ndevlink_param_get_from_info(struct xarray *params, struct genl_info *info)\n{\n\tchar *param_name;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_PARAM_NAME))\n\t\treturn NULL;\n\n\tparam_name = nla_data(info->attrs[DEVLINK_ATTR_PARAM_NAME]);\n\treturn devlink_param_find_by_name(params, param_name);\n}\n\nint devlink_nl_param_get_doit(struct sk_buff *skb,\n\t\t\t      struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_param_item *param_item;\n\tstruct sk_buff *msg;\n\tint err;\n\n\tparam_item = devlink_param_get_from_info(&devlink->params, info);\n\tif (!param_item)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_param_fill(msg, devlink, 0, param_item,\n\t\t\t\t    DEVLINK_CMD_PARAM_GET,\n\t\t\t\t    info->snd_portid, info->snd_seq, 0);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int __devlink_nl_cmd_param_set_doit(struct devlink *devlink,\n\t\t\t\t\t   unsigned int port_index,\n\t\t\t\t\t   struct xarray *params,\n\t\t\t\t\t   struct genl_info *info,\n\t\t\t\t\t   enum devlink_command cmd)\n{\n\tenum devlink_param_type param_type;\n\tstruct devlink_param_gset_ctx ctx;\n\tenum devlink_param_cmode cmode;\n\tstruct devlink_param_item *param_item;\n\tconst struct devlink_param *param;\n\tunion devlink_param_value value;\n\tint err = 0;\n\n\tparam_item = devlink_param_get_from_info(params, info);\n\tif (!param_item)\n\t\treturn -EINVAL;\n\tparam = param_item->param;\n\terr = devlink_param_type_get_from_info(info, &param_type);\n\tif (err)\n\t\treturn err;\n\tif (param_type != param->type)\n\t\treturn -EINVAL;\n\terr = devlink_param_value_get_from_info(param, info, &value);\n\tif (err)\n\t\treturn err;\n\tif (param->validate) {\n\t\terr = param->validate(devlink, param->id, value, info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_PARAM_VALUE_CMODE))\n\t\treturn -EINVAL;\n\tcmode = nla_get_u8(info->attrs[DEVLINK_ATTR_PARAM_VALUE_CMODE]);\n\tif (!devlink_param_cmode_is_supported(param, cmode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (cmode == DEVLINK_PARAM_CMODE_DRIVERINIT) {\n\t\tparam_item->driverinit_value_new = value;\n\t\tparam_item->driverinit_value_new_valid = true;\n\t} else {\n\t\tif (!param->set)\n\t\t\treturn -EOPNOTSUPP;\n\t\tctx.val = value;\n\t\tctx.cmode = cmode;\n\t\terr = devlink_param_set(devlink, param, &ctx);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdevlink_param_notify(devlink, port_index, param_item, cmd);\n\treturn 0;\n}\n\nint devlink_nl_cmd_param_set_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\n\treturn __devlink_nl_cmd_param_set_doit(devlink, 0, &devlink->params,\n\t\t\t\t\t       info, DEVLINK_CMD_PARAM_NEW);\n}\n\nint devlink_nl_cmd_port_param_get_dumpit(struct sk_buff *msg,\n\t\t\t\t\t struct netlink_callback *cb)\n{\n\tNL_SET_ERR_MSG(cb->extack, \"Port params are not supported\");\n\treturn msg->len;\n}\n\nint devlink_nl_cmd_port_param_get_doit(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tNL_SET_ERR_MSG(info->extack, \"Port params are not supported\");\n\treturn -EINVAL;\n}\n\nint devlink_nl_cmd_port_param_set_doit(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tNL_SET_ERR_MSG(info->extack, \"Port params are not supported\");\n\treturn -EINVAL;\n}\n\nstatic int devlink_param_verify(const struct devlink_param *param)\n{\n\tif (!param || !param->name || !param->supported_cmodes)\n\t\treturn -EINVAL;\n\tif (param->generic)\n\t\treturn devlink_param_generic_verify(param);\n\telse\n\t\treturn devlink_param_driver_verify(param);\n}\n\nstatic int devlink_param_register(struct devlink *devlink,\n\t\t\t\t  const struct devlink_param *param)\n{\n\tstruct devlink_param_item *param_item;\n\tint err;\n\n\tWARN_ON(devlink_param_verify(param));\n\tWARN_ON(devlink_param_find_by_name(&devlink->params, param->name));\n\n\tif (param->supported_cmodes == BIT(DEVLINK_PARAM_CMODE_DRIVERINIT))\n\t\tWARN_ON(param->get || param->set);\n\telse\n\t\tWARN_ON(!param->get || !param->set);\n\n\tparam_item = kzalloc(sizeof(*param_item), GFP_KERNEL);\n\tif (!param_item)\n\t\treturn -ENOMEM;\n\n\tparam_item->param = param;\n\n\terr = xa_insert(&devlink->params, param->id, param_item, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_xa_insert;\n\n\tdevlink_param_notify(devlink, 0, param_item, DEVLINK_CMD_PARAM_NEW);\n\treturn 0;\n\nerr_xa_insert:\n\tkfree(param_item);\n\treturn err;\n}\n\nstatic void devlink_param_unregister(struct devlink *devlink,\n\t\t\t\t     const struct devlink_param *param)\n{\n\tstruct devlink_param_item *param_item;\n\n\tparam_item = devlink_param_find_by_id(&devlink->params, param->id);\n\tif (WARN_ON(!param_item))\n\t\treturn;\n\tdevlink_param_notify(devlink, 0, param_item, DEVLINK_CMD_PARAM_DEL);\n\txa_erase(&devlink->params, param->id);\n\tkfree(param_item);\n}\n\n \nint devl_params_register(struct devlink *devlink,\n\t\t\t const struct devlink_param *params,\n\t\t\t size_t params_count)\n{\n\tconst struct devlink_param *param = params;\n\tint i, err;\n\n\tlockdep_assert_held(&devlink->lock);\n\n\tfor (i = 0; i < params_count; i++, param++) {\n\t\terr = devlink_param_register(devlink, param);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\treturn 0;\n\nrollback:\n\tif (!i)\n\t\treturn err;\n\n\tfor (param--; i > 0; i--, param--)\n\t\tdevlink_param_unregister(devlink, param);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(devl_params_register);\n\nint devlink_params_register(struct devlink *devlink,\n\t\t\t    const struct devlink_param *params,\n\t\t\t    size_t params_count)\n{\n\tint err;\n\n\tdevl_lock(devlink);\n\terr = devl_params_register(devlink, params, params_count);\n\tdevl_unlock(devlink);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(devlink_params_register);\n\n \nvoid devl_params_unregister(struct devlink *devlink,\n\t\t\t    const struct devlink_param *params,\n\t\t\t    size_t params_count)\n{\n\tconst struct devlink_param *param = params;\n\tint i;\n\n\tlockdep_assert_held(&devlink->lock);\n\n\tfor (i = 0; i < params_count; i++, param++)\n\t\tdevlink_param_unregister(devlink, param);\n}\nEXPORT_SYMBOL_GPL(devl_params_unregister);\n\nvoid devlink_params_unregister(struct devlink *devlink,\n\t\t\t       const struct devlink_param *params,\n\t\t\t       size_t params_count)\n{\n\tdevl_lock(devlink);\n\tdevl_params_unregister(devlink, params, params_count);\n\tdevl_unlock(devlink);\n}\nEXPORT_SYMBOL_GPL(devlink_params_unregister);\n\n \nint devl_param_driverinit_value_get(struct devlink *devlink, u32 param_id,\n\t\t\t\t    union devlink_param_value *val)\n{\n\tstruct devlink_param_item *param_item;\n\n\tif (WARN_ON(!devlink_reload_supported(devlink->ops)))\n\t\treturn -EOPNOTSUPP;\n\n\tparam_item = devlink_param_find_by_id(&devlink->params, param_id);\n\tif (!param_item)\n\t\treturn -EINVAL;\n\n\tif (!param_item->driverinit_value_valid)\n\t\treturn -EOPNOTSUPP;\n\n\tif (WARN_ON(!devlink_param_cmode_is_supported(param_item->param,\n\t\t\t\t\t\t      DEVLINK_PARAM_CMODE_DRIVERINIT)))\n\t\treturn -EOPNOTSUPP;\n\n\t*val = param_item->driverinit_value;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devl_param_driverinit_value_get);\n\n \nvoid devl_param_driverinit_value_set(struct devlink *devlink, u32 param_id,\n\t\t\t\t     union devlink_param_value init_val)\n{\n\tstruct devlink_param_item *param_item;\n\n\tdevl_assert_locked(devlink);\n\n\tparam_item = devlink_param_find_by_id(&devlink->params, param_id);\n\tif (WARN_ON(!param_item))\n\t\treturn;\n\n\tif (WARN_ON(!devlink_param_cmode_is_supported(param_item->param,\n\t\t\t\t\t\t      DEVLINK_PARAM_CMODE_DRIVERINIT)))\n\t\treturn;\n\n\tparam_item->driverinit_value = init_val;\n\tparam_item->driverinit_value_valid = true;\n\n\tdevlink_param_notify(devlink, 0, param_item, DEVLINK_CMD_PARAM_NEW);\n}\nEXPORT_SYMBOL_GPL(devl_param_driverinit_value_set);\n\nvoid devlink_params_driverinit_load_new(struct devlink *devlink)\n{\n\tstruct devlink_param_item *param_item;\n\tunsigned long param_id;\n\n\txa_for_each(&devlink->params, param_id, param_item) {\n\t\tif (!devlink_param_cmode_is_supported(param_item->param,\n\t\t\t\t\t\t      DEVLINK_PARAM_CMODE_DRIVERINIT) ||\n\t\t    !param_item->driverinit_value_new_valid)\n\t\t\tcontinue;\n\t\tparam_item->driverinit_value = param_item->driverinit_value_new;\n\t\tparam_item->driverinit_value_valid = true;\n\t\tparam_item->driverinit_value_new_valid = false;\n\t}\n}\n\n \nvoid devl_param_value_changed(struct devlink *devlink, u32 param_id)\n{\n\tstruct devlink_param_item *param_item;\n\n\tparam_item = devlink_param_find_by_id(&devlink->params, param_id);\n\tWARN_ON(!param_item);\n\n\tdevlink_param_notify(devlink, 0, param_item, DEVLINK_CMD_PARAM_NEW);\n}\nEXPORT_SYMBOL_GPL(devl_param_value_changed);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}