{
  "module_name": "rate.c",
  "hash_id": "6e994af0f9dd7b2cf8ba5aeee7bff593ad5805373c466c4fd8a44a17ab2da18b",
  "original_prompt": "Ingested from linux-6.6.14/net/devlink/rate.c",
  "human_readable_source": "\n \n\n#include \"devl_internal.h\"\n\nstatic inline bool\ndevlink_rate_is_leaf(struct devlink_rate *devlink_rate)\n{\n\treturn devlink_rate->type == DEVLINK_RATE_TYPE_LEAF;\n}\n\nstatic inline bool\ndevlink_rate_is_node(struct devlink_rate *devlink_rate)\n{\n\treturn devlink_rate->type == DEVLINK_RATE_TYPE_NODE;\n}\n\nstatic struct devlink_rate *\ndevlink_rate_leaf_get_from_info(struct devlink *devlink, struct genl_info *info)\n{\n\tstruct devlink_rate *devlink_rate;\n\tstruct devlink_port *devlink_port;\n\n\tdevlink_port = devlink_port_get_from_attrs(devlink, info->attrs);\n\tif (IS_ERR(devlink_port))\n\t\treturn ERR_CAST(devlink_port);\n\tdevlink_rate = devlink_port->devlink_rate;\n\treturn devlink_rate ?: ERR_PTR(-ENODEV);\n}\n\nstatic struct devlink_rate *\ndevlink_rate_node_get_by_name(struct devlink *devlink, const char *node_name)\n{\n\tstatic struct devlink_rate *devlink_rate;\n\n\tlist_for_each_entry(devlink_rate, &devlink->rate_list, list) {\n\t\tif (devlink_rate_is_node(devlink_rate) &&\n\t\t    !strcmp(node_name, devlink_rate->name))\n\t\t\treturn devlink_rate;\n\t}\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic struct devlink_rate *\ndevlink_rate_node_get_from_attrs(struct devlink *devlink, struct nlattr **attrs)\n{\n\tconst char *rate_node_name;\n\tsize_t len;\n\n\tif (!attrs[DEVLINK_ATTR_RATE_NODE_NAME])\n\t\treturn ERR_PTR(-EINVAL);\n\trate_node_name = nla_data(attrs[DEVLINK_ATTR_RATE_NODE_NAME]);\n\tlen = strlen(rate_node_name);\n\t \n\tif (!len || strspn(rate_node_name, \"0123456789\") == len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn devlink_rate_node_get_by_name(devlink, rate_node_name);\n}\n\nstatic struct devlink_rate *\ndevlink_rate_node_get_from_info(struct devlink *devlink, struct genl_info *info)\n{\n\treturn devlink_rate_node_get_from_attrs(devlink, info->attrs);\n}\n\nstatic struct devlink_rate *\ndevlink_rate_get_from_info(struct devlink *devlink, struct genl_info *info)\n{\n\tstruct nlattr **attrs = info->attrs;\n\n\tif (attrs[DEVLINK_ATTR_PORT_INDEX])\n\t\treturn devlink_rate_leaf_get_from_info(devlink, info);\n\telse if (attrs[DEVLINK_ATTR_RATE_NODE_NAME])\n\t\treturn devlink_rate_node_get_from_info(devlink, info);\n\telse\n\t\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int devlink_nl_rate_fill(struct sk_buff *msg,\n\t\t\t\tstruct devlink_rate *devlink_rate,\n\t\t\t\tenum devlink_command cmd, u32 portid, u32 seq,\n\t\t\t\tint flags, struct netlink_ext_ack *extack)\n{\n\tstruct devlink *devlink = devlink_rate->devlink;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(msg, DEVLINK_ATTR_RATE_TYPE, devlink_rate->type))\n\t\tgoto nla_put_failure;\n\n\tif (devlink_rate_is_leaf(devlink_rate)) {\n\t\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_INDEX,\n\t\t\t\tdevlink_rate->devlink_port->index))\n\t\t\tgoto nla_put_failure;\n\t} else if (devlink_rate_is_node(devlink_rate)) {\n\t\tif (nla_put_string(msg, DEVLINK_ATTR_RATE_NODE_NAME,\n\t\t\t\t   devlink_rate->name))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u64_64bit(msg, DEVLINK_ATTR_RATE_TX_SHARE,\n\t\t\t      devlink_rate->tx_share, DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, DEVLINK_ATTR_RATE_TX_MAX,\n\t\t\t      devlink_rate->tx_max, DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, DEVLINK_ATTR_RATE_TX_PRIORITY,\n\t\t\tdevlink_rate->tx_priority))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, DEVLINK_ATTR_RATE_TX_WEIGHT,\n\t\t\tdevlink_rate->tx_weight))\n\t\tgoto nla_put_failure;\n\n\tif (devlink_rate->parent)\n\t\tif (nla_put_string(msg, DEVLINK_ATTR_RATE_PARENT_NODE_NAME,\n\t\t\t\t   devlink_rate->parent->name))\n\t\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic void devlink_rate_notify(struct devlink_rate *devlink_rate,\n\t\t\t\tenum devlink_command cmd)\n{\n\tstruct devlink *devlink = devlink_rate->devlink;\n\tstruct sk_buff *msg;\n\tint err;\n\n\tWARN_ON(cmd != DEVLINK_CMD_RATE_NEW && cmd != DEVLINK_CMD_RATE_DEL);\n\n\tif (!xa_get_mark(&devlinks, devlink->index, DEVLINK_REGISTERED))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\terr = devlink_nl_rate_fill(msg, devlink_rate, cmd, 0, 0, 0, NULL);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink), msg,\n\t\t\t\t0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nvoid devlink_rates_notify_register(struct devlink *devlink)\n{\n\tstruct devlink_rate *rate_node;\n\n\tlist_for_each_entry(rate_node, &devlink->rate_list, list)\n\t\tdevlink_rate_notify(rate_node, DEVLINK_CMD_RATE_NEW);\n}\n\nvoid devlink_rates_notify_unregister(struct devlink *devlink)\n{\n\tstruct devlink_rate *rate_node;\n\n\tlist_for_each_entry_reverse(rate_node, &devlink->rate_list, list)\n\t\tdevlink_rate_notify(rate_node, DEVLINK_CMD_RATE_DEL);\n}\n\nstatic int\ndevlink_nl_rate_get_dump_one(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t     struct netlink_callback *cb, int flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct devlink_rate *devlink_rate;\n\tint idx = 0;\n\tint err = 0;\n\n\tlist_for_each_entry(devlink_rate, &devlink->rate_list, list) {\n\t\tenum devlink_command cmd = DEVLINK_CMD_RATE_NEW;\n\t\tu32 id = NETLINK_CB(cb->skb).portid;\n\n\t\tif (idx < state->idx) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = devlink_nl_rate_fill(msg, devlink_rate, cmd, id,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, flags, NULL);\n\t\tif (err) {\n\t\t\tstate->idx = idx;\n\t\t\tbreak;\n\t\t}\n\t\tidx++;\n\t}\n\n\treturn err;\n}\n\nint devlink_nl_rate_get_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb, devlink_nl_rate_get_dump_one);\n}\n\nint devlink_nl_rate_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_rate *devlink_rate;\n\tstruct sk_buff *msg;\n\tint err;\n\n\tdevlink_rate = devlink_rate_get_from_info(devlink, info);\n\tif (IS_ERR(devlink_rate))\n\t\treturn PTR_ERR(devlink_rate);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_rate_fill(msg, devlink_rate, DEVLINK_CMD_RATE_NEW,\n\t\t\t\t   info->snd_portid, info->snd_seq, 0,\n\t\t\t\t   info->extack);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic bool\ndevlink_rate_is_parent_node(struct devlink_rate *devlink_rate,\n\t\t\t    struct devlink_rate *parent)\n{\n\twhile (parent) {\n\t\tif (parent == devlink_rate)\n\t\t\treturn true;\n\t\tparent = parent->parent;\n\t}\n\treturn false;\n}\n\nstatic int\ndevlink_nl_rate_parent_node_set(struct devlink_rate *devlink_rate,\n\t\t\t\tstruct genl_info *info,\n\t\t\t\tstruct nlattr *nla_parent)\n{\n\tstruct devlink *devlink = devlink_rate->devlink;\n\tconst char *parent_name = nla_data(nla_parent);\n\tconst struct devlink_ops *ops = devlink->ops;\n\tsize_t len = strlen(parent_name);\n\tstruct devlink_rate *parent;\n\tint err = -EOPNOTSUPP;\n\n\tparent = devlink_rate->parent;\n\n\tif (parent && !len) {\n\t\tif (devlink_rate_is_leaf(devlink_rate))\n\t\t\terr = ops->rate_leaf_parent_set(devlink_rate, NULL,\n\t\t\t\t\t\t\tdevlink_rate->priv, NULL,\n\t\t\t\t\t\t\tinfo->extack);\n\t\telse if (devlink_rate_is_node(devlink_rate))\n\t\t\terr = ops->rate_node_parent_set(devlink_rate, NULL,\n\t\t\t\t\t\t\tdevlink_rate->priv, NULL,\n\t\t\t\t\t\t\tinfo->extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\trefcount_dec(&parent->refcnt);\n\t\tdevlink_rate->parent = NULL;\n\t} else if (len) {\n\t\tparent = devlink_rate_node_get_by_name(devlink, parent_name);\n\t\tif (IS_ERR(parent))\n\t\t\treturn -ENODEV;\n\n\t\tif (parent == devlink_rate) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"Parent to self is not allowed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (devlink_rate_is_node(devlink_rate) &&\n\t\t    devlink_rate_is_parent_node(devlink_rate, parent->parent)) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"Node is already a parent of parent node.\");\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\tif (devlink_rate_is_leaf(devlink_rate))\n\t\t\terr = ops->rate_leaf_parent_set(devlink_rate, parent,\n\t\t\t\t\t\t\tdevlink_rate->priv, parent->priv,\n\t\t\t\t\t\t\tinfo->extack);\n\t\telse if (devlink_rate_is_node(devlink_rate))\n\t\t\terr = ops->rate_node_parent_set(devlink_rate, parent,\n\t\t\t\t\t\t\tdevlink_rate->priv, parent->priv,\n\t\t\t\t\t\t\tinfo->extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (devlink_rate->parent)\n\t\t\t \n\t\t\trefcount_dec(&devlink_rate->parent->refcnt);\n\n\t\trefcount_inc(&parent->refcnt);\n\t\tdevlink_rate->parent = parent;\n\t}\n\n\treturn 0;\n}\n\nstatic int devlink_nl_rate_set(struct devlink_rate *devlink_rate,\n\t\t\t       const struct devlink_ops *ops,\n\t\t\t       struct genl_info *info)\n{\n\tstruct nlattr *nla_parent, **attrs = info->attrs;\n\tint err = -EOPNOTSUPP;\n\tu32 priority;\n\tu32 weight;\n\tu64 rate;\n\n\tif (attrs[DEVLINK_ATTR_RATE_TX_SHARE]) {\n\t\trate = nla_get_u64(attrs[DEVLINK_ATTR_RATE_TX_SHARE]);\n\t\tif (devlink_rate_is_leaf(devlink_rate))\n\t\t\terr = ops->rate_leaf_tx_share_set(devlink_rate, devlink_rate->priv,\n\t\t\t\t\t\t\t  rate, info->extack);\n\t\telse if (devlink_rate_is_node(devlink_rate))\n\t\t\terr = ops->rate_node_tx_share_set(devlink_rate, devlink_rate->priv,\n\t\t\t\t\t\t\t  rate, info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdevlink_rate->tx_share = rate;\n\t}\n\n\tif (attrs[DEVLINK_ATTR_RATE_TX_MAX]) {\n\t\trate = nla_get_u64(attrs[DEVLINK_ATTR_RATE_TX_MAX]);\n\t\tif (devlink_rate_is_leaf(devlink_rate))\n\t\t\terr = ops->rate_leaf_tx_max_set(devlink_rate, devlink_rate->priv,\n\t\t\t\t\t\t\trate, info->extack);\n\t\telse if (devlink_rate_is_node(devlink_rate))\n\t\t\terr = ops->rate_node_tx_max_set(devlink_rate, devlink_rate->priv,\n\t\t\t\t\t\t\trate, info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tdevlink_rate->tx_max = rate;\n\t}\n\n\tif (attrs[DEVLINK_ATTR_RATE_TX_PRIORITY]) {\n\t\tpriority = nla_get_u32(attrs[DEVLINK_ATTR_RATE_TX_PRIORITY]);\n\t\tif (devlink_rate_is_leaf(devlink_rate))\n\t\t\terr = ops->rate_leaf_tx_priority_set(devlink_rate, devlink_rate->priv,\n\t\t\t\t\t\t\t     priority, info->extack);\n\t\telse if (devlink_rate_is_node(devlink_rate))\n\t\t\terr = ops->rate_node_tx_priority_set(devlink_rate, devlink_rate->priv,\n\t\t\t\t\t\t\t     priority, info->extack);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\tdevlink_rate->tx_priority = priority;\n\t}\n\n\tif (attrs[DEVLINK_ATTR_RATE_TX_WEIGHT]) {\n\t\tweight = nla_get_u32(attrs[DEVLINK_ATTR_RATE_TX_WEIGHT]);\n\t\tif (devlink_rate_is_leaf(devlink_rate))\n\t\t\terr = ops->rate_leaf_tx_weight_set(devlink_rate, devlink_rate->priv,\n\t\t\t\t\t\t\t   weight, info->extack);\n\t\telse if (devlink_rate_is_node(devlink_rate))\n\t\t\terr = ops->rate_node_tx_weight_set(devlink_rate, devlink_rate->priv,\n\t\t\t\t\t\t\t   weight, info->extack);\n\n\t\tif (err)\n\t\t\treturn err;\n\t\tdevlink_rate->tx_weight = weight;\n\t}\n\n\tnla_parent = attrs[DEVLINK_ATTR_RATE_PARENT_NODE_NAME];\n\tif (nla_parent) {\n\t\terr = devlink_nl_rate_parent_node_set(devlink_rate, info,\n\t\t\t\t\t\t      nla_parent);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic bool devlink_rate_set_ops_supported(const struct devlink_ops *ops,\n\t\t\t\t\t   struct genl_info *info,\n\t\t\t\t\t   enum devlink_rate_type type)\n{\n\tstruct nlattr **attrs = info->attrs;\n\n\tif (type == DEVLINK_RATE_TYPE_LEAF) {\n\t\tif (attrs[DEVLINK_ATTR_RATE_TX_SHARE] && !ops->rate_leaf_tx_share_set) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"TX share set isn't supported for the leafs\");\n\t\t\treturn false;\n\t\t}\n\t\tif (attrs[DEVLINK_ATTR_RATE_TX_MAX] && !ops->rate_leaf_tx_max_set) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"TX max set isn't supported for the leafs\");\n\t\t\treturn false;\n\t\t}\n\t\tif (attrs[DEVLINK_ATTR_RATE_PARENT_NODE_NAME] &&\n\t\t    !ops->rate_leaf_parent_set) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"Parent set isn't supported for the leafs\");\n\t\t\treturn false;\n\t\t}\n\t\tif (attrs[DEVLINK_ATTR_RATE_TX_PRIORITY] && !ops->rate_leaf_tx_priority_set) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t\t    attrs[DEVLINK_ATTR_RATE_TX_PRIORITY],\n\t\t\t\t\t    \"TX priority set isn't supported for the leafs\");\n\t\t\treturn false;\n\t\t}\n\t\tif (attrs[DEVLINK_ATTR_RATE_TX_WEIGHT] && !ops->rate_leaf_tx_weight_set) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t\t    attrs[DEVLINK_ATTR_RATE_TX_WEIGHT],\n\t\t\t\t\t    \"TX weight set isn't supported for the leafs\");\n\t\t\treturn false;\n\t\t}\n\t} else if (type == DEVLINK_RATE_TYPE_NODE) {\n\t\tif (attrs[DEVLINK_ATTR_RATE_TX_SHARE] && !ops->rate_node_tx_share_set) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"TX share set isn't supported for the nodes\");\n\t\t\treturn false;\n\t\t}\n\t\tif (attrs[DEVLINK_ATTR_RATE_TX_MAX] && !ops->rate_node_tx_max_set) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"TX max set isn't supported for the nodes\");\n\t\t\treturn false;\n\t\t}\n\t\tif (attrs[DEVLINK_ATTR_RATE_PARENT_NODE_NAME] &&\n\t\t    !ops->rate_node_parent_set) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"Parent set isn't supported for the nodes\");\n\t\t\treturn false;\n\t\t}\n\t\tif (attrs[DEVLINK_ATTR_RATE_TX_PRIORITY] && !ops->rate_node_tx_priority_set) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t\t    attrs[DEVLINK_ATTR_RATE_TX_PRIORITY],\n\t\t\t\t\t    \"TX priority set isn't supported for the nodes\");\n\t\t\treturn false;\n\t\t}\n\t\tif (attrs[DEVLINK_ATTR_RATE_TX_WEIGHT] && !ops->rate_node_tx_weight_set) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t\t    attrs[DEVLINK_ATTR_RATE_TX_WEIGHT],\n\t\t\t\t\t    \"TX weight set isn't supported for the nodes\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tWARN(1, \"Unknown type of rate object\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint devlink_nl_cmd_rate_set_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_rate *devlink_rate;\n\tconst struct devlink_ops *ops;\n\tint err;\n\n\tdevlink_rate = devlink_rate_get_from_info(devlink, info);\n\tif (IS_ERR(devlink_rate))\n\t\treturn PTR_ERR(devlink_rate);\n\n\tops = devlink->ops;\n\tif (!ops || !devlink_rate_set_ops_supported(ops, info, devlink_rate->type))\n\t\treturn -EOPNOTSUPP;\n\n\terr = devlink_nl_rate_set(devlink_rate, ops, info);\n\n\tif (!err)\n\t\tdevlink_rate_notify(devlink_rate, DEVLINK_CMD_RATE_NEW);\n\treturn err;\n}\n\nint devlink_nl_cmd_rate_new_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_rate *rate_node;\n\tconst struct devlink_ops *ops;\n\tint err;\n\n\tops = devlink->ops;\n\tif (!ops || !ops->rate_node_new || !ops->rate_node_del) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Rate nodes aren't supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!devlink_rate_set_ops_supported(ops, info, DEVLINK_RATE_TYPE_NODE))\n\t\treturn -EOPNOTSUPP;\n\n\trate_node = devlink_rate_node_get_from_attrs(devlink, info->attrs);\n\tif (!IS_ERR(rate_node))\n\t\treturn -EEXIST;\n\telse if (rate_node == ERR_PTR(-EINVAL))\n\t\treturn -EINVAL;\n\n\trate_node = kzalloc(sizeof(*rate_node), GFP_KERNEL);\n\tif (!rate_node)\n\t\treturn -ENOMEM;\n\n\trate_node->devlink = devlink;\n\trate_node->type = DEVLINK_RATE_TYPE_NODE;\n\trate_node->name = nla_strdup(info->attrs[DEVLINK_ATTR_RATE_NODE_NAME], GFP_KERNEL);\n\tif (!rate_node->name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_strdup;\n\t}\n\n\terr = ops->rate_node_new(rate_node, &rate_node->priv, info->extack);\n\tif (err)\n\t\tgoto err_node_new;\n\n\terr = devlink_nl_rate_set(rate_node, ops, info);\n\tif (err)\n\t\tgoto err_rate_set;\n\n\trefcount_set(&rate_node->refcnt, 1);\n\tlist_add(&rate_node->list, &devlink->rate_list);\n\tdevlink_rate_notify(rate_node, DEVLINK_CMD_RATE_NEW);\n\treturn 0;\n\nerr_rate_set:\n\tops->rate_node_del(rate_node, rate_node->priv, info->extack);\nerr_node_new:\n\tkfree(rate_node->name);\nerr_strdup:\n\tkfree(rate_node);\n\treturn err;\n}\n\nint devlink_nl_cmd_rate_del_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_rate *rate_node;\n\tint err;\n\n\trate_node = devlink_rate_node_get_from_info(devlink, info);\n\tif (IS_ERR(rate_node))\n\t\treturn PTR_ERR(rate_node);\n\n\tif (refcount_read(&rate_node->refcnt) > 1) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Node has children. Cannot delete node.\");\n\t\treturn -EBUSY;\n\t}\n\n\tdevlink_rate_notify(rate_node, DEVLINK_CMD_RATE_DEL);\n\terr = devlink->ops->rate_node_del(rate_node, rate_node->priv,\n\t\t\t\t\t  info->extack);\n\tif (rate_node->parent)\n\t\trefcount_dec(&rate_node->parent->refcnt);\n\tlist_del(&rate_node->list);\n\tkfree(rate_node->name);\n\tkfree(rate_node);\n\treturn err;\n}\n\nint devlink_rate_nodes_check(struct devlink *devlink, u16 mode,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct devlink_rate *devlink_rate;\n\n\tlist_for_each_entry(devlink_rate, &devlink->rate_list, list)\n\t\tif (devlink_rate_is_node(devlink_rate)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Rate node(s) exists.\");\n\t\t\treturn -EBUSY;\n\t\t}\n\treturn 0;\n}\n\n \nstruct devlink_rate *\ndevl_rate_node_create(struct devlink *devlink, void *priv, char *node_name,\n\t\t      struct devlink_rate *parent)\n{\n\tstruct devlink_rate *rate_node;\n\n\trate_node = devlink_rate_node_get_by_name(devlink, node_name);\n\tif (!IS_ERR(rate_node))\n\t\treturn ERR_PTR(-EEXIST);\n\n\trate_node = kzalloc(sizeof(*rate_node), GFP_KERNEL);\n\tif (!rate_node)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (parent) {\n\t\trate_node->parent = parent;\n\t\trefcount_inc(&rate_node->parent->refcnt);\n\t}\n\n\trate_node->type = DEVLINK_RATE_TYPE_NODE;\n\trate_node->devlink = devlink;\n\trate_node->priv = priv;\n\n\trate_node->name = kstrdup(node_name, GFP_KERNEL);\n\tif (!rate_node->name) {\n\t\tkfree(rate_node);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\trefcount_set(&rate_node->refcnt, 1);\n\tlist_add(&rate_node->list, &devlink->rate_list);\n\tdevlink_rate_notify(rate_node, DEVLINK_CMD_RATE_NEW);\n\treturn rate_node;\n}\nEXPORT_SYMBOL_GPL(devl_rate_node_create);\n\n \nint devl_rate_leaf_create(struct devlink_port *devlink_port, void *priv,\n\t\t\t  struct devlink_rate *parent)\n{\n\tstruct devlink *devlink = devlink_port->devlink;\n\tstruct devlink_rate *devlink_rate;\n\n\tdevl_assert_locked(devlink_port->devlink);\n\n\tif (WARN_ON(devlink_port->devlink_rate))\n\t\treturn -EBUSY;\n\n\tdevlink_rate = kzalloc(sizeof(*devlink_rate), GFP_KERNEL);\n\tif (!devlink_rate)\n\t\treturn -ENOMEM;\n\n\tif (parent) {\n\t\tdevlink_rate->parent = parent;\n\t\trefcount_inc(&devlink_rate->parent->refcnt);\n\t}\n\n\tdevlink_rate->type = DEVLINK_RATE_TYPE_LEAF;\n\tdevlink_rate->devlink = devlink;\n\tdevlink_rate->devlink_port = devlink_port;\n\tdevlink_rate->priv = priv;\n\tlist_add_tail(&devlink_rate->list, &devlink->rate_list);\n\tdevlink_port->devlink_rate = devlink_rate;\n\tdevlink_rate_notify(devlink_rate, DEVLINK_CMD_RATE_NEW);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devl_rate_leaf_create);\n\n \nvoid devl_rate_leaf_destroy(struct devlink_port *devlink_port)\n{\n\tstruct devlink_rate *devlink_rate = devlink_port->devlink_rate;\n\n\tdevl_assert_locked(devlink_port->devlink);\n\tif (!devlink_rate)\n\t\treturn;\n\n\tdevlink_rate_notify(devlink_rate, DEVLINK_CMD_RATE_DEL);\n\tif (devlink_rate->parent)\n\t\trefcount_dec(&devlink_rate->parent->refcnt);\n\tlist_del(&devlink_rate->list);\n\tdevlink_port->devlink_rate = NULL;\n\tkfree(devlink_rate);\n}\nEXPORT_SYMBOL_GPL(devl_rate_leaf_destroy);\n\n \nvoid devl_rate_nodes_destroy(struct devlink *devlink)\n{\n\tstatic struct devlink_rate *devlink_rate, *tmp;\n\tconst struct devlink_ops *ops = devlink->ops;\n\n\tdevl_assert_locked(devlink);\n\n\tlist_for_each_entry(devlink_rate, &devlink->rate_list, list) {\n\t\tif (!devlink_rate->parent)\n\t\t\tcontinue;\n\n\t\trefcount_dec(&devlink_rate->parent->refcnt);\n\t\tif (devlink_rate_is_leaf(devlink_rate))\n\t\t\tops->rate_leaf_parent_set(devlink_rate, NULL, devlink_rate->priv,\n\t\t\t\t\t\t  NULL, NULL);\n\t\telse if (devlink_rate_is_node(devlink_rate))\n\t\t\tops->rate_node_parent_set(devlink_rate, NULL, devlink_rate->priv,\n\t\t\t\t\t\t  NULL, NULL);\n\t}\n\tlist_for_each_entry_safe(devlink_rate, tmp, &devlink->rate_list, list) {\n\t\tif (devlink_rate_is_node(devlink_rate)) {\n\t\t\tops->rate_node_del(devlink_rate, devlink_rate->priv, NULL);\n\t\t\tlist_del(&devlink_rate->list);\n\t\t\tkfree(devlink_rate->name);\n\t\t\tkfree(devlink_rate);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(devl_rate_nodes_destroy);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}