{
  "module_name": "dpipe.c",
  "hash_id": "acdb424eccc7cc16cbacead03d80cb23bef96e7cb0d36bcf4167a3e89b09c632",
  "original_prompt": "Ingested from linux-6.6.14/net/devlink/dpipe.c",
  "human_readable_source": "\n \n\n#include \"devl_internal.h\"\n\nstatic struct devlink_dpipe_field devlink_dpipe_fields_ethernet[] = {\n\t{\n\t\t.name = \"destination mac\",\n\t\t.id = DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC,\n\t\t.bitwidth = 48,\n\t},\n};\n\nstruct devlink_dpipe_header devlink_dpipe_header_ethernet = {\n\t.name = \"ethernet\",\n\t.id = DEVLINK_DPIPE_HEADER_ETHERNET,\n\t.fields = devlink_dpipe_fields_ethernet,\n\t.fields_count = ARRAY_SIZE(devlink_dpipe_fields_ethernet),\n\t.global = true,\n};\nEXPORT_SYMBOL_GPL(devlink_dpipe_header_ethernet);\n\nstatic struct devlink_dpipe_field devlink_dpipe_fields_ipv4[] = {\n\t{\n\t\t.name = \"destination ip\",\n\t\t.id = DEVLINK_DPIPE_FIELD_IPV4_DST_IP,\n\t\t.bitwidth = 32,\n\t},\n};\n\nstruct devlink_dpipe_header devlink_dpipe_header_ipv4 = {\n\t.name = \"ipv4\",\n\t.id = DEVLINK_DPIPE_HEADER_IPV4,\n\t.fields = devlink_dpipe_fields_ipv4,\n\t.fields_count = ARRAY_SIZE(devlink_dpipe_fields_ipv4),\n\t.global = true,\n};\nEXPORT_SYMBOL_GPL(devlink_dpipe_header_ipv4);\n\nstatic struct devlink_dpipe_field devlink_dpipe_fields_ipv6[] = {\n\t{\n\t\t.name = \"destination ip\",\n\t\t.id = DEVLINK_DPIPE_FIELD_IPV6_DST_IP,\n\t\t.bitwidth = 128,\n\t},\n};\n\nstruct devlink_dpipe_header devlink_dpipe_header_ipv6 = {\n\t.name = \"ipv6\",\n\t.id = DEVLINK_DPIPE_HEADER_IPV6,\n\t.fields = devlink_dpipe_fields_ipv6,\n\t.fields_count = ARRAY_SIZE(devlink_dpipe_fields_ipv6),\n\t.global = true,\n};\nEXPORT_SYMBOL_GPL(devlink_dpipe_header_ipv6);\n\nint devlink_dpipe_match_put(struct sk_buff *skb,\n\t\t\t    struct devlink_dpipe_match *match)\n{\n\tstruct devlink_dpipe_header *header = match->header;\n\tstruct devlink_dpipe_field *field = &header->fields[match->field_id];\n\tstruct nlattr *match_attr;\n\n\tmatch_attr = nla_nest_start_noflag(skb, DEVLINK_ATTR_DPIPE_MATCH);\n\tif (!match_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, DEVLINK_ATTR_DPIPE_MATCH_TYPE, match->type) ||\n\t    nla_put_u32(skb, DEVLINK_ATTR_DPIPE_HEADER_INDEX, match->header_index) ||\n\t    nla_put_u32(skb, DEVLINK_ATTR_DPIPE_HEADER_ID, header->id) ||\n\t    nla_put_u32(skb, DEVLINK_ATTR_DPIPE_FIELD_ID, field->id) ||\n\t    nla_put_u8(skb, DEVLINK_ATTR_DPIPE_HEADER_GLOBAL, header->global))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, match_attr);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, match_attr);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL_GPL(devlink_dpipe_match_put);\n\nstatic int devlink_dpipe_matches_put(struct devlink_dpipe_table *table,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct nlattr *matches_attr;\n\n\tmatches_attr = nla_nest_start_noflag(skb,\n\t\t\t\t\t     DEVLINK_ATTR_DPIPE_TABLE_MATCHES);\n\tif (!matches_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (table->table_ops->matches_dump(table->priv, skb))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, matches_attr);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, matches_attr);\n\treturn -EMSGSIZE;\n}\n\nint devlink_dpipe_action_put(struct sk_buff *skb,\n\t\t\t     struct devlink_dpipe_action *action)\n{\n\tstruct devlink_dpipe_header *header = action->header;\n\tstruct devlink_dpipe_field *field = &header->fields[action->field_id];\n\tstruct nlattr *action_attr;\n\n\taction_attr = nla_nest_start_noflag(skb, DEVLINK_ATTR_DPIPE_ACTION);\n\tif (!action_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, DEVLINK_ATTR_DPIPE_ACTION_TYPE, action->type) ||\n\t    nla_put_u32(skb, DEVLINK_ATTR_DPIPE_HEADER_INDEX, action->header_index) ||\n\t    nla_put_u32(skb, DEVLINK_ATTR_DPIPE_HEADER_ID, header->id) ||\n\t    nla_put_u32(skb, DEVLINK_ATTR_DPIPE_FIELD_ID, field->id) ||\n\t    nla_put_u8(skb, DEVLINK_ATTR_DPIPE_HEADER_GLOBAL, header->global))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, action_attr);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, action_attr);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL_GPL(devlink_dpipe_action_put);\n\nstatic int devlink_dpipe_actions_put(struct devlink_dpipe_table *table,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct nlattr *actions_attr;\n\n\tactions_attr = nla_nest_start_noflag(skb,\n\t\t\t\t\t     DEVLINK_ATTR_DPIPE_TABLE_ACTIONS);\n\tif (!actions_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (table->table_ops->actions_dump(table->priv, skb))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, actions_attr);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, actions_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int devlink_dpipe_table_put(struct sk_buff *skb,\n\t\t\t\t   struct devlink_dpipe_table *table)\n{\n\tstruct nlattr *table_attr;\n\tu64 table_size;\n\n\ttable_size = table->table_ops->size_get(table->priv);\n\ttable_attr = nla_nest_start_noflag(skb, DEVLINK_ATTR_DPIPE_TABLE);\n\tif (!table_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(skb, DEVLINK_ATTR_DPIPE_TABLE_NAME, table->name) ||\n\t    nla_put_u64_64bit(skb, DEVLINK_ATTR_DPIPE_TABLE_SIZE, table_size,\n\t\t\t      DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb, DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED,\n\t\t       table->counters_enabled))\n\t\tgoto nla_put_failure;\n\n\tif (table->resource_valid) {\n\t\tif (nla_put_u64_64bit(skb, DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_ID,\n\t\t\t\t      table->resource_id, DEVLINK_ATTR_PAD) ||\n\t\t    nla_put_u64_64bit(skb, DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_UNITS,\n\t\t\t\t      table->resource_units, DEVLINK_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (devlink_dpipe_matches_put(table, skb))\n\t\tgoto nla_put_failure;\n\n\tif (devlink_dpipe_actions_put(table, skb))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, table_attr);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, table_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int devlink_dpipe_send_and_alloc_skb(struct sk_buff **pskb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tint err;\n\n\tif (*pskb) {\n\t\terr = genlmsg_reply(*pskb, info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t*pskb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!*pskb)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int devlink_dpipe_tables_fill(struct genl_info *info,\n\t\t\t\t     enum devlink_command cmd, int flags,\n\t\t\t\t     struct list_head *dpipe_tables,\n\t\t\t\t     const char *table_name)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_dpipe_table *table;\n\tstruct nlattr *tables_attr;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tbool incomplete;\n\tvoid *hdr;\n\tint i;\n\tint err;\n\n\ttable = list_first_entry(dpipe_tables,\n\t\t\t\t struct devlink_dpipe_table, list);\nstart_again:\n\terr = devlink_dpipe_send_and_alloc_skb(&skb, info);\n\tif (err)\n\t\treturn err;\n\n\thdr = genlmsg_put(skb, info->snd_portid, info->snd_seq,\n\t\t\t  &devlink_nl_family, NLM_F_MULTI, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (devlink_nl_put_handle(skb, devlink))\n\t\tgoto nla_put_failure;\n\ttables_attr = nla_nest_start_noflag(skb, DEVLINK_ATTR_DPIPE_TABLES);\n\tif (!tables_attr)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n\tincomplete = false;\n\tlist_for_each_entry_from(table, dpipe_tables, list) {\n\t\tif (!table_name) {\n\t\t\terr = devlink_dpipe_table_put(skb, table);\n\t\t\tif (err) {\n\t\t\t\tif (!i)\n\t\t\t\t\tgoto err_table_put;\n\t\t\t\tincomplete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!strcmp(table->name, table_name)) {\n\t\t\t\terr = devlink_dpipe_table_put(skb, table);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\n\tnla_nest_end(skb, tables_attr);\n\tgenlmsg_end(skb, hdr);\n\tif (incomplete)\n\t\tgoto start_again;\n\nsend_done:\n\tnlh = nlmsg_put(skb, info->snd_portid, info->snd_seq,\n\t\t\tNLMSG_DONE, 0, flags | NLM_F_MULTI);\n\tif (!nlh) {\n\t\terr = devlink_dpipe_send_and_alloc_skb(&skb, info);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto send_done;\n\t}\n\n\treturn genlmsg_reply(skb, info);\n\nnla_put_failure:\n\terr = -EMSGSIZE;\nerr_table_put:\n\tnlmsg_free(skb);\n\treturn err;\n}\n\nint devlink_nl_cmd_dpipe_table_get(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tconst char *table_name =  NULL;\n\n\tif (info->attrs[DEVLINK_ATTR_DPIPE_TABLE_NAME])\n\t\ttable_name = nla_data(info->attrs[DEVLINK_ATTR_DPIPE_TABLE_NAME]);\n\n\treturn devlink_dpipe_tables_fill(info, DEVLINK_CMD_DPIPE_TABLE_GET, 0,\n\t\t\t\t\t &devlink->dpipe_table_list,\n\t\t\t\t\t table_name);\n}\n\nstatic int devlink_dpipe_value_put(struct sk_buff *skb,\n\t\t\t\t   struct devlink_dpipe_value *value)\n{\n\tif (nla_put(skb, DEVLINK_ATTR_DPIPE_VALUE,\n\t\t    value->value_size, value->value))\n\t\treturn -EMSGSIZE;\n\tif (value->mask)\n\t\tif (nla_put(skb, DEVLINK_ATTR_DPIPE_VALUE_MASK,\n\t\t\t    value->value_size, value->mask))\n\t\t\treturn -EMSGSIZE;\n\tif (value->mapping_valid)\n\t\tif (nla_put_u32(skb, DEVLINK_ATTR_DPIPE_VALUE_MAPPING,\n\t\t\t\tvalue->mapping_value))\n\t\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int devlink_dpipe_action_value_put(struct sk_buff *skb,\n\t\t\t\t\t  struct devlink_dpipe_value *value)\n{\n\tif (!value->action)\n\t\treturn -EINVAL;\n\tif (devlink_dpipe_action_put(skb, value->action))\n\t\treturn -EMSGSIZE;\n\tif (devlink_dpipe_value_put(skb, value))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int devlink_dpipe_action_values_put(struct sk_buff *skb,\n\t\t\t\t\t   struct devlink_dpipe_value *values,\n\t\t\t\t\t   unsigned int values_count)\n{\n\tstruct nlattr *action_attr;\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < values_count; i++) {\n\t\taction_attr = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t    DEVLINK_ATTR_DPIPE_ACTION_VALUE);\n\t\tif (!action_attr)\n\t\t\treturn -EMSGSIZE;\n\t\terr = devlink_dpipe_action_value_put(skb, &values[i]);\n\t\tif (err)\n\t\t\tgoto err_action_value_put;\n\t\tnla_nest_end(skb, action_attr);\n\t}\n\treturn 0;\n\nerr_action_value_put:\n\tnla_nest_cancel(skb, action_attr);\n\treturn err;\n}\n\nstatic int devlink_dpipe_match_value_put(struct sk_buff *skb,\n\t\t\t\t\t struct devlink_dpipe_value *value)\n{\n\tif (!value->match)\n\t\treturn -EINVAL;\n\tif (devlink_dpipe_match_put(skb, value->match))\n\t\treturn -EMSGSIZE;\n\tif (devlink_dpipe_value_put(skb, value))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int devlink_dpipe_match_values_put(struct sk_buff *skb,\n\t\t\t\t\t  struct devlink_dpipe_value *values,\n\t\t\t\t\t  unsigned int values_count)\n{\n\tstruct nlattr *match_attr;\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < values_count; i++) {\n\t\tmatch_attr = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t   DEVLINK_ATTR_DPIPE_MATCH_VALUE);\n\t\tif (!match_attr)\n\t\t\treturn -EMSGSIZE;\n\t\terr = devlink_dpipe_match_value_put(skb, &values[i]);\n\t\tif (err)\n\t\t\tgoto err_match_value_put;\n\t\tnla_nest_end(skb, match_attr);\n\t}\n\treturn 0;\n\nerr_match_value_put:\n\tnla_nest_cancel(skb, match_attr);\n\treturn err;\n}\n\nstatic int devlink_dpipe_entry_put(struct sk_buff *skb,\n\t\t\t\t   struct devlink_dpipe_entry *entry)\n{\n\tstruct nlattr *entry_attr, *matches_attr, *actions_attr;\n\tint err;\n\n\tentry_attr = nla_nest_start_noflag(skb, DEVLINK_ATTR_DPIPE_ENTRY);\n\tif (!entry_attr)\n\t\treturn  -EMSGSIZE;\n\n\tif (nla_put_u64_64bit(skb, DEVLINK_ATTR_DPIPE_ENTRY_INDEX, entry->index,\n\t\t\t      DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\tif (entry->counter_valid)\n\t\tif (nla_put_u64_64bit(skb, DEVLINK_ATTR_DPIPE_ENTRY_COUNTER,\n\t\t\t\t      entry->counter, DEVLINK_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\n\tmatches_attr = nla_nest_start_noflag(skb,\n\t\t\t\t\t     DEVLINK_ATTR_DPIPE_ENTRY_MATCH_VALUES);\n\tif (!matches_attr)\n\t\tgoto nla_put_failure;\n\n\terr = devlink_dpipe_match_values_put(skb, entry->match_values,\n\t\t\t\t\t     entry->match_values_count);\n\tif (err) {\n\t\tnla_nest_cancel(skb, matches_attr);\n\t\tgoto err_match_values_put;\n\t}\n\tnla_nest_end(skb, matches_attr);\n\n\tactions_attr = nla_nest_start_noflag(skb,\n\t\t\t\t\t     DEVLINK_ATTR_DPIPE_ENTRY_ACTION_VALUES);\n\tif (!actions_attr)\n\t\tgoto nla_put_failure;\n\n\terr = devlink_dpipe_action_values_put(skb, entry->action_values,\n\t\t\t\t\t      entry->action_values_count);\n\tif (err) {\n\t\tnla_nest_cancel(skb, actions_attr);\n\t\tgoto err_action_values_put;\n\t}\n\tnla_nest_end(skb, actions_attr);\n\n\tnla_nest_end(skb, entry_attr);\n\treturn 0;\n\nnla_put_failure:\n\terr = -EMSGSIZE;\nerr_match_values_put:\nerr_action_values_put:\n\tnla_nest_cancel(skb, entry_attr);\n\treturn err;\n}\n\nstatic struct devlink_dpipe_table *\ndevlink_dpipe_table_find(struct list_head *dpipe_tables,\n\t\t\t const char *table_name, struct devlink *devlink)\n{\n\tstruct devlink_dpipe_table *table;\n\n\tlist_for_each_entry_rcu(table, dpipe_tables, list,\n\t\t\t\tlockdep_is_held(&devlink->lock)) {\n\t\tif (!strcmp(table->name, table_name))\n\t\t\treturn table;\n\t}\n\treturn NULL;\n}\n\nint devlink_dpipe_entry_ctx_prepare(struct devlink_dpipe_dump_ctx *dump_ctx)\n{\n\tstruct devlink *devlink;\n\tint err;\n\n\terr = devlink_dpipe_send_and_alloc_skb(&dump_ctx->skb,\n\t\t\t\t\t       dump_ctx->info);\n\tif (err)\n\t\treturn err;\n\n\tdump_ctx->hdr = genlmsg_put(dump_ctx->skb,\n\t\t\t\t    dump_ctx->info->snd_portid,\n\t\t\t\t    dump_ctx->info->snd_seq,\n\t\t\t\t    &devlink_nl_family, NLM_F_MULTI,\n\t\t\t\t    dump_ctx->cmd);\n\tif (!dump_ctx->hdr)\n\t\tgoto nla_put_failure;\n\n\tdevlink = dump_ctx->info->user_ptr[0];\n\tif (devlink_nl_put_handle(dump_ctx->skb, devlink))\n\t\tgoto nla_put_failure;\n\tdump_ctx->nest = nla_nest_start_noflag(dump_ctx->skb,\n\t\t\t\t\t       DEVLINK_ATTR_DPIPE_ENTRIES);\n\tif (!dump_ctx->nest)\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_free(dump_ctx->skb);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL_GPL(devlink_dpipe_entry_ctx_prepare);\n\nint devlink_dpipe_entry_ctx_append(struct devlink_dpipe_dump_ctx *dump_ctx,\n\t\t\t\t   struct devlink_dpipe_entry *entry)\n{\n\treturn devlink_dpipe_entry_put(dump_ctx->skb, entry);\n}\nEXPORT_SYMBOL_GPL(devlink_dpipe_entry_ctx_append);\n\nint devlink_dpipe_entry_ctx_close(struct devlink_dpipe_dump_ctx *dump_ctx)\n{\n\tnla_nest_end(dump_ctx->skb, dump_ctx->nest);\n\tgenlmsg_end(dump_ctx->skb, dump_ctx->hdr);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devlink_dpipe_entry_ctx_close);\n\nvoid devlink_dpipe_entry_clear(struct devlink_dpipe_entry *entry)\n\n{\n\tunsigned int value_count, value_index;\n\tstruct devlink_dpipe_value *value;\n\n\tvalue = entry->action_values;\n\tvalue_count = entry->action_values_count;\n\tfor (value_index = 0; value_index < value_count; value_index++) {\n\t\tkfree(value[value_index].value);\n\t\tkfree(value[value_index].mask);\n\t}\n\n\tvalue = entry->match_values;\n\tvalue_count = entry->match_values_count;\n\tfor (value_index = 0; value_index < value_count; value_index++) {\n\t\tkfree(value[value_index].value);\n\t\tkfree(value[value_index].mask);\n\t}\n}\nEXPORT_SYMBOL_GPL(devlink_dpipe_entry_clear);\n\nstatic int devlink_dpipe_entries_fill(struct genl_info *info,\n\t\t\t\t      enum devlink_command cmd, int flags,\n\t\t\t\t      struct devlink_dpipe_table *table)\n{\n\tstruct devlink_dpipe_dump_ctx dump_ctx;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tdump_ctx.skb = NULL;\n\tdump_ctx.cmd = cmd;\n\tdump_ctx.info = info;\n\n\terr = table->table_ops->entries_dump(table->priv,\n\t\t\t\t\t     table->counters_enabled,\n\t\t\t\t\t     &dump_ctx);\n\tif (err)\n\t\treturn err;\n\nsend_done:\n\tnlh = nlmsg_put(dump_ctx.skb, info->snd_portid, info->snd_seq,\n\t\t\tNLMSG_DONE, 0, flags | NLM_F_MULTI);\n\tif (!nlh) {\n\t\terr = devlink_dpipe_send_and_alloc_skb(&dump_ctx.skb, info);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto send_done;\n\t}\n\treturn genlmsg_reply(dump_ctx.skb, info);\n}\n\nint devlink_nl_cmd_dpipe_entries_get(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_dpipe_table *table;\n\tconst char *table_name;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_DPIPE_TABLE_NAME))\n\t\treturn -EINVAL;\n\n\ttable_name = nla_data(info->attrs[DEVLINK_ATTR_DPIPE_TABLE_NAME]);\n\ttable = devlink_dpipe_table_find(&devlink->dpipe_table_list,\n\t\t\t\t\t table_name, devlink);\n\tif (!table)\n\t\treturn -EINVAL;\n\n\tif (!table->table_ops->entries_dump)\n\t\treturn -EINVAL;\n\n\treturn devlink_dpipe_entries_fill(info, DEVLINK_CMD_DPIPE_ENTRIES_GET,\n\t\t\t\t\t  0, table);\n}\n\nstatic int devlink_dpipe_fields_put(struct sk_buff *skb,\n\t\t\t\t    const struct devlink_dpipe_header *header)\n{\n\tstruct devlink_dpipe_field *field;\n\tstruct nlattr *field_attr;\n\tint i;\n\n\tfor (i = 0; i < header->fields_count; i++) {\n\t\tfield = &header->fields[i];\n\t\tfield_attr = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t   DEVLINK_ATTR_DPIPE_FIELD);\n\t\tif (!field_attr)\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_string(skb, DEVLINK_ATTR_DPIPE_FIELD_NAME, field->name) ||\n\t\t    nla_put_u32(skb, DEVLINK_ATTR_DPIPE_FIELD_ID, field->id) ||\n\t\t    nla_put_u32(skb, DEVLINK_ATTR_DPIPE_FIELD_BITWIDTH, field->bitwidth) ||\n\t\t    nla_put_u32(skb, DEVLINK_ATTR_DPIPE_FIELD_MAPPING_TYPE, field->mapping_type))\n\t\t\tgoto nla_put_failure;\n\t\tnla_nest_end(skb, field_attr);\n\t}\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, field_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int devlink_dpipe_header_put(struct sk_buff *skb,\n\t\t\t\t    struct devlink_dpipe_header *header)\n{\n\tstruct nlattr *fields_attr, *header_attr;\n\tint err;\n\n\theader_attr = nla_nest_start_noflag(skb, DEVLINK_ATTR_DPIPE_HEADER);\n\tif (!header_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(skb, DEVLINK_ATTR_DPIPE_HEADER_NAME, header->name) ||\n\t    nla_put_u32(skb, DEVLINK_ATTR_DPIPE_HEADER_ID, header->id) ||\n\t    nla_put_u8(skb, DEVLINK_ATTR_DPIPE_HEADER_GLOBAL, header->global))\n\t\tgoto nla_put_failure;\n\n\tfields_attr = nla_nest_start_noflag(skb,\n\t\t\t\t\t    DEVLINK_ATTR_DPIPE_HEADER_FIELDS);\n\tif (!fields_attr)\n\t\tgoto nla_put_failure;\n\n\terr = devlink_dpipe_fields_put(skb, header);\n\tif (err) {\n\t\tnla_nest_cancel(skb, fields_attr);\n\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, fields_attr);\n\tnla_nest_end(skb, header_attr);\n\treturn 0;\n\nnla_put_failure:\n\terr = -EMSGSIZE;\n\tnla_nest_cancel(skb, header_attr);\n\treturn err;\n}\n\nstatic int devlink_dpipe_headers_fill(struct genl_info *info,\n\t\t\t\t      enum devlink_command cmd, int flags,\n\t\t\t\t      struct devlink_dpipe_headers *\n\t\t\t\t      dpipe_headers)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct nlattr *headers_attr;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tvoid *hdr;\n\tint i, j;\n\tint err;\n\n\ti = 0;\nstart_again:\n\terr = devlink_dpipe_send_and_alloc_skb(&skb, info);\n\tif (err)\n\t\treturn err;\n\n\thdr = genlmsg_put(skb, info->snd_portid, info->snd_seq,\n\t\t\t  &devlink_nl_family, NLM_F_MULTI, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (devlink_nl_put_handle(skb, devlink))\n\t\tgoto nla_put_failure;\n\theaders_attr = nla_nest_start_noflag(skb, DEVLINK_ATTR_DPIPE_HEADERS);\n\tif (!headers_attr)\n\t\tgoto nla_put_failure;\n\n\tj = 0;\n\tfor (; i < dpipe_headers->headers_count; i++) {\n\t\terr = devlink_dpipe_header_put(skb, dpipe_headers->headers[i]);\n\t\tif (err) {\n\t\t\tif (!j)\n\t\t\t\tgoto err_table_put;\n\t\t\tbreak;\n\t\t}\n\t\tj++;\n\t}\n\tnla_nest_end(skb, headers_attr);\n\tgenlmsg_end(skb, hdr);\n\tif (i != dpipe_headers->headers_count)\n\t\tgoto start_again;\n\nsend_done:\n\tnlh = nlmsg_put(skb, info->snd_portid, info->snd_seq,\n\t\t\tNLMSG_DONE, 0, flags | NLM_F_MULTI);\n\tif (!nlh) {\n\t\terr = devlink_dpipe_send_and_alloc_skb(&skb, info);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto send_done;\n\t}\n\treturn genlmsg_reply(skb, info);\n\nnla_put_failure:\n\terr = -EMSGSIZE;\nerr_table_put:\n\tnlmsg_free(skb);\n\treturn err;\n}\n\nint devlink_nl_cmd_dpipe_headers_get(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\n\tif (!devlink->dpipe_headers)\n\t\treturn -EOPNOTSUPP;\n\treturn devlink_dpipe_headers_fill(info, DEVLINK_CMD_DPIPE_HEADERS_GET,\n\t\t\t\t\t  0, devlink->dpipe_headers);\n}\n\nstatic int devlink_dpipe_table_counters_set(struct devlink *devlink,\n\t\t\t\t\t    const char *table_name,\n\t\t\t\t\t    bool enable)\n{\n\tstruct devlink_dpipe_table *table;\n\n\ttable = devlink_dpipe_table_find(&devlink->dpipe_table_list,\n\t\t\t\t\t table_name, devlink);\n\tif (!table)\n\t\treturn -EINVAL;\n\n\tif (table->counter_control_extern)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(table->counters_enabled ^ enable))\n\t\treturn 0;\n\n\ttable->counters_enabled = enable;\n\tif (table->table_ops->counters_set_update)\n\t\ttable->table_ops->counters_set_update(table->priv, enable);\n\treturn 0;\n}\n\nint devlink_nl_cmd_dpipe_table_counters_set(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tconst char *table_name;\n\tbool counters_enable;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_DPIPE_TABLE_NAME) ||\n\t    GENL_REQ_ATTR_CHECK(info,\n\t\t\t\tDEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED))\n\t\treturn -EINVAL;\n\n\ttable_name = nla_data(info->attrs[DEVLINK_ATTR_DPIPE_TABLE_NAME]);\n\tcounters_enable = !!nla_get_u8(info->attrs[DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED]);\n\n\treturn devlink_dpipe_table_counters_set(devlink, table_name,\n\t\t\t\t\t\tcounters_enable);\n}\n\n \nvoid devl_dpipe_headers_register(struct devlink *devlink,\n\t\t\t\t struct devlink_dpipe_headers *dpipe_headers)\n{\n\tlockdep_assert_held(&devlink->lock);\n\n\tdevlink->dpipe_headers = dpipe_headers;\n}\nEXPORT_SYMBOL_GPL(devl_dpipe_headers_register);\n\n \nvoid devl_dpipe_headers_unregister(struct devlink *devlink)\n{\n\tlockdep_assert_held(&devlink->lock);\n\n\tdevlink->dpipe_headers = NULL;\n}\nEXPORT_SYMBOL_GPL(devl_dpipe_headers_unregister);\n\n \nbool devlink_dpipe_table_counter_enabled(struct devlink *devlink,\n\t\t\t\t\t const char *table_name)\n{\n\tstruct devlink_dpipe_table *table;\n\tbool enabled;\n\n\trcu_read_lock();\n\ttable = devlink_dpipe_table_find(&devlink->dpipe_table_list,\n\t\t\t\t\t table_name, devlink);\n\tenabled = false;\n\tif (table)\n\t\tenabled = table->counters_enabled;\n\trcu_read_unlock();\n\treturn enabled;\n}\nEXPORT_SYMBOL_GPL(devlink_dpipe_table_counter_enabled);\n\n \nint devl_dpipe_table_register(struct devlink *devlink,\n\t\t\t      const char *table_name,\n\t\t\t      struct devlink_dpipe_table_ops *table_ops,\n\t\t\t      void *priv, bool counter_control_extern)\n{\n\tstruct devlink_dpipe_table *table;\n\n\tlockdep_assert_held(&devlink->lock);\n\n\tif (WARN_ON(!table_ops->size_get))\n\t\treturn -EINVAL;\n\n\tif (devlink_dpipe_table_find(&devlink->dpipe_table_list, table_name,\n\t\t\t\t     devlink))\n\t\treturn -EEXIST;\n\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\ttable->name = table_name;\n\ttable->table_ops = table_ops;\n\ttable->priv = priv;\n\ttable->counter_control_extern = counter_control_extern;\n\n\tlist_add_tail_rcu(&table->list, &devlink->dpipe_table_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devl_dpipe_table_register);\n\n \nvoid devl_dpipe_table_unregister(struct devlink *devlink,\n\t\t\t\t const char *table_name)\n{\n\tstruct devlink_dpipe_table *table;\n\n\tlockdep_assert_held(&devlink->lock);\n\n\ttable = devlink_dpipe_table_find(&devlink->dpipe_table_list,\n\t\t\t\t\t table_name, devlink);\n\tif (!table)\n\t\treturn;\n\tlist_del_rcu(&table->list);\n\tkfree_rcu(table, rcu);\n}\nEXPORT_SYMBOL_GPL(devl_dpipe_table_unregister);\n\n \nint devl_dpipe_table_resource_set(struct devlink *devlink,\n\t\t\t\t  const char *table_name, u64 resource_id,\n\t\t\t\t  u64 resource_units)\n{\n\tstruct devlink_dpipe_table *table;\n\n\ttable = devlink_dpipe_table_find(&devlink->dpipe_table_list,\n\t\t\t\t\t table_name, devlink);\n\tif (!table)\n\t\treturn -EINVAL;\n\n\ttable->resource_id = resource_id;\n\ttable->resource_units = resource_units;\n\ttable->resource_valid = true;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devl_dpipe_table_resource_set);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}