{
  "module_name": "core.c",
  "hash_id": "98ffdc77af74d052ced6dd3d87efd79f3f7092ad7382e3f89537f4253dd18255",
  "original_prompt": "Ingested from linux-6.6.14/net/devlink/core.c",
  "human_readable_source": "\n \n\n#include <net/genetlink.h>\n#define CREATE_TRACE_POINTS\n#include <trace/events/devlink.h>\n\n#include \"devl_internal.h\"\n\nEXPORT_TRACEPOINT_SYMBOL_GPL(devlink_hwmsg);\nEXPORT_TRACEPOINT_SYMBOL_GPL(devlink_hwerr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(devlink_trap_report);\n\nDEFINE_XARRAY_FLAGS(devlinks, XA_FLAGS_ALLOC);\n\nvoid *devlink_priv(struct devlink *devlink)\n{\n\treturn &devlink->priv;\n}\nEXPORT_SYMBOL_GPL(devlink_priv);\n\nstruct devlink *priv_to_devlink(void *priv)\n{\n\treturn container_of(priv, struct devlink, priv);\n}\nEXPORT_SYMBOL_GPL(priv_to_devlink);\n\nstruct device *devlink_to_dev(const struct devlink *devlink)\n{\n\treturn devlink->dev;\n}\nEXPORT_SYMBOL_GPL(devlink_to_dev);\n\nstruct net *devlink_net(const struct devlink *devlink)\n{\n\treturn read_pnet(&devlink->_net);\n}\nEXPORT_SYMBOL_GPL(devlink_net);\n\nvoid devl_assert_locked(struct devlink *devlink)\n{\n\tlockdep_assert_held(&devlink->lock);\n}\nEXPORT_SYMBOL_GPL(devl_assert_locked);\n\n#ifdef CONFIG_LOCKDEP\n \nbool devl_lock_is_held(struct devlink *devlink)\n{\n\treturn lockdep_is_held(&devlink->lock);\n}\nEXPORT_SYMBOL_GPL(devl_lock_is_held);\n#endif\n\nvoid devl_lock(struct devlink *devlink)\n{\n\tmutex_lock(&devlink->lock);\n}\nEXPORT_SYMBOL_GPL(devl_lock);\n\nint devl_trylock(struct devlink *devlink)\n{\n\treturn mutex_trylock(&devlink->lock);\n}\nEXPORT_SYMBOL_GPL(devl_trylock);\n\nvoid devl_unlock(struct devlink *devlink)\n{\n\tmutex_unlock(&devlink->lock);\n}\nEXPORT_SYMBOL_GPL(devl_unlock);\n\n \nstruct devlink *__must_check devlink_try_get(struct devlink *devlink)\n{\n\tif (refcount_inc_not_zero(&devlink->refcount))\n\t\treturn devlink;\n\treturn NULL;\n}\n\nstatic void devlink_release(struct work_struct *work)\n{\n\tstruct devlink *devlink;\n\n\tdevlink = container_of(to_rcu_work(work), struct devlink, rwork);\n\n\tmutex_destroy(&devlink->lock);\n\tlockdep_unregister_key(&devlink->lock_key);\n\tkfree(devlink);\n}\n\nvoid devlink_put(struct devlink *devlink)\n{\n\tif (refcount_dec_and_test(&devlink->refcount))\n\t\tqueue_rcu_work(system_wq, &devlink->rwork);\n}\n\nstruct devlink *devlinks_xa_find_get(struct net *net, unsigned long *indexp)\n{\n\tstruct devlink *devlink = NULL;\n\n\trcu_read_lock();\nretry:\n\tdevlink = xa_find(&devlinks, indexp, ULONG_MAX, DEVLINK_REGISTERED);\n\tif (!devlink)\n\t\tgoto unlock;\n\n\tif (!devlink_try_get(devlink))\n\t\tgoto next;\n\tif (!net_eq(devlink_net(devlink), net)) {\n\t\tdevlink_put(devlink);\n\t\tgoto next;\n\t}\nunlock:\n\trcu_read_unlock();\n\treturn devlink;\n\nnext:\n\t(*indexp)++;\n\tgoto retry;\n}\n\n \nint devl_register(struct devlink *devlink)\n{\n\tASSERT_DEVLINK_NOT_REGISTERED(devlink);\n\tdevl_assert_locked(devlink);\n\n\txa_set_mark(&devlinks, devlink->index, DEVLINK_REGISTERED);\n\tdevlink_notify_register(devlink);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devl_register);\n\nvoid devlink_register(struct devlink *devlink)\n{\n\tdevl_lock(devlink);\n\tdevl_register(devlink);\n\tdevl_unlock(devlink);\n}\nEXPORT_SYMBOL_GPL(devlink_register);\n\n \nvoid devl_unregister(struct devlink *devlink)\n{\n\tASSERT_DEVLINK_REGISTERED(devlink);\n\tdevl_assert_locked(devlink);\n\n\tdevlink_notify_unregister(devlink);\n\txa_clear_mark(&devlinks, devlink->index, DEVLINK_REGISTERED);\n}\nEXPORT_SYMBOL_GPL(devl_unregister);\n\nvoid devlink_unregister(struct devlink *devlink)\n{\n\tdevl_lock(devlink);\n\tdevl_unregister(devlink);\n\tdevl_unlock(devlink);\n}\nEXPORT_SYMBOL_GPL(devlink_unregister);\n\n \nstruct devlink *devlink_alloc_ns(const struct devlink_ops *ops,\n\t\t\t\t size_t priv_size, struct net *net,\n\t\t\t\t struct device *dev)\n{\n\tstruct devlink *devlink;\n\tstatic u32 last_id;\n\tint ret;\n\n\tWARN_ON(!ops || !dev);\n\tif (!devlink_reload_actions_valid(ops))\n\t\treturn NULL;\n\n\tdevlink = kzalloc(sizeof(*devlink) + priv_size, GFP_KERNEL);\n\tif (!devlink)\n\t\treturn NULL;\n\n\tret = xa_alloc_cyclic(&devlinks, &devlink->index, devlink, xa_limit_31b,\n\t\t\t      &last_id, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_xa_alloc;\n\n\tdevlink->dev = dev;\n\tdevlink->ops = ops;\n\txa_init_flags(&devlink->ports, XA_FLAGS_ALLOC);\n\txa_init_flags(&devlink->params, XA_FLAGS_ALLOC);\n\txa_init_flags(&devlink->snapshot_ids, XA_FLAGS_ALLOC);\n\twrite_pnet(&devlink->_net, net);\n\tINIT_LIST_HEAD(&devlink->rate_list);\n\tINIT_LIST_HEAD(&devlink->linecard_list);\n\tINIT_LIST_HEAD(&devlink->sb_list);\n\tINIT_LIST_HEAD_RCU(&devlink->dpipe_table_list);\n\tINIT_LIST_HEAD(&devlink->resource_list);\n\tINIT_LIST_HEAD(&devlink->region_list);\n\tINIT_LIST_HEAD(&devlink->reporter_list);\n\tINIT_LIST_HEAD(&devlink->trap_list);\n\tINIT_LIST_HEAD(&devlink->trap_group_list);\n\tINIT_LIST_HEAD(&devlink->trap_policer_list);\n\tINIT_RCU_WORK(&devlink->rwork, devlink_release);\n\tlockdep_register_key(&devlink->lock_key);\n\tmutex_init(&devlink->lock);\n\tlockdep_set_class(&devlink->lock, &devlink->lock_key);\n\trefcount_set(&devlink->refcount, 1);\n\n\treturn devlink;\n\nerr_xa_alloc:\n\tkfree(devlink);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(devlink_alloc_ns);\n\n \nvoid devlink_free(struct devlink *devlink)\n{\n\tASSERT_DEVLINK_NOT_REGISTERED(devlink);\n\n\tWARN_ON(!list_empty(&devlink->trap_policer_list));\n\tWARN_ON(!list_empty(&devlink->trap_group_list));\n\tWARN_ON(!list_empty(&devlink->trap_list));\n\tWARN_ON(!list_empty(&devlink->reporter_list));\n\tWARN_ON(!list_empty(&devlink->region_list));\n\tWARN_ON(!list_empty(&devlink->resource_list));\n\tWARN_ON(!list_empty(&devlink->dpipe_table_list));\n\tWARN_ON(!list_empty(&devlink->sb_list));\n\tWARN_ON(!list_empty(&devlink->rate_list));\n\tWARN_ON(!list_empty(&devlink->linecard_list));\n\tWARN_ON(!xa_empty(&devlink->ports));\n\n\txa_destroy(&devlink->snapshot_ids);\n\txa_destroy(&devlink->params);\n\txa_destroy(&devlink->ports);\n\n\txa_erase(&devlinks, devlink->index);\n\n\tdevlink_put(devlink);\n}\nEXPORT_SYMBOL_GPL(devlink_free);\n\nstatic void __net_exit devlink_pernet_pre_exit(struct net *net)\n{\n\tstruct devlink *devlink;\n\tu32 actions_performed;\n\tunsigned long index;\n\tint err;\n\n\t \n\tdevlinks_xa_for_each_registered_get(net, index, devlink) {\n\t\tdevl_lock(devlink);\n\t\terr = 0;\n\t\tif (devl_is_registered(devlink))\n\t\t\terr = devlink_reload(devlink, &init_net,\n\t\t\t\t\t     DEVLINK_RELOAD_ACTION_DRIVER_REINIT,\n\t\t\t\t\t     DEVLINK_RELOAD_LIMIT_UNSPEC,\n\t\t\t\t\t     &actions_performed, NULL);\n\t\tdevl_unlock(devlink);\n\t\tdevlink_put(devlink);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\tpr_warn(\"Failed to reload devlink instance into init_net\\n\");\n\t}\n}\n\nstatic struct pernet_operations devlink_pernet_ops __net_initdata = {\n\t.pre_exit = devlink_pernet_pre_exit,\n};\n\nstatic struct notifier_block devlink_port_netdevice_nb = {\n\t.notifier_call = devlink_port_netdevice_event,\n};\n\nstatic int __init devlink_init(void)\n{\n\tint err;\n\n\terr = genl_register_family(&devlink_nl_family);\n\tif (err)\n\t\tgoto out;\n\terr = register_pernet_subsys(&devlink_pernet_ops);\n\tif (err)\n\t\tgoto out;\n\terr = register_netdevice_notifier(&devlink_port_netdevice_nb);\n\nout:\n\tWARN_ON(err);\n\treturn err;\n}\n\nsubsys_initcall(devlink_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}