{
  "module_name": "port.c",
  "hash_id": "4c270dfc1e7a4303744ef35d7ee8548c9e5e943b8bab5dd9127a2c7319e56a6d",
  "original_prompt": "Ingested from linux-6.6.14/net/devlink/port.c",
  "human_readable_source": "\n \n\n#include \"devl_internal.h\"\n\n#define DEVLINK_PORT_FN_CAPS_VALID_MASK \\\n\t(_BITUL(__DEVLINK_PORT_FN_ATTR_CAPS_MAX) - 1)\n\nstatic const struct nla_policy devlink_function_nl_policy[DEVLINK_PORT_FUNCTION_ATTR_MAX + 1] = {\n\t[DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR] = { .type = NLA_BINARY },\n\t[DEVLINK_PORT_FN_ATTR_STATE] =\n\t\tNLA_POLICY_RANGE(NLA_U8, DEVLINK_PORT_FN_STATE_INACTIVE,\n\t\t\t\t DEVLINK_PORT_FN_STATE_ACTIVE),\n\t[DEVLINK_PORT_FN_ATTR_CAPS] =\n\t\tNLA_POLICY_BITFIELD32(DEVLINK_PORT_FN_CAPS_VALID_MASK),\n};\n\n#define ASSERT_DEVLINK_PORT_REGISTERED(devlink_port)\t\t\t\t\\\n\tWARN_ON_ONCE(!(devlink_port)->registered)\n#define ASSERT_DEVLINK_PORT_NOT_REGISTERED(devlink_port)\t\t\t\\\n\tWARN_ON_ONCE((devlink_port)->registered)\n\nstruct devlink_port *devlink_port_get_by_index(struct devlink *devlink,\n\t\t\t\t\t       unsigned int port_index)\n{\n\treturn xa_load(&devlink->ports, port_index);\n}\n\nstruct devlink_port *devlink_port_get_from_attrs(struct devlink *devlink,\n\t\t\t\t\t\t struct nlattr **attrs)\n{\n\tif (attrs[DEVLINK_ATTR_PORT_INDEX]) {\n\t\tu32 port_index = nla_get_u32(attrs[DEVLINK_ATTR_PORT_INDEX]);\n\t\tstruct devlink_port *devlink_port;\n\n\t\tdevlink_port = devlink_port_get_by_index(devlink, port_index);\n\t\tif (!devlink_port)\n\t\t\treturn ERR_PTR(-ENODEV);\n\t\treturn devlink_port;\n\t}\n\treturn ERR_PTR(-EINVAL);\n}\n\nstruct devlink_port *devlink_port_get_from_info(struct devlink *devlink,\n\t\t\t\t\t\tstruct genl_info *info)\n{\n\treturn devlink_port_get_from_attrs(devlink, info->attrs);\n}\n\nstatic void devlink_port_fn_cap_fill(struct nla_bitfield32 *caps,\n\t\t\t\t     u32 cap, bool is_enable)\n{\n\tcaps->selector |= cap;\n\tif (is_enable)\n\t\tcaps->value |= cap;\n}\n\nstatic int devlink_port_fn_roce_fill(struct devlink_port *devlink_port,\n\t\t\t\t     struct nla_bitfield32 *caps,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tbool is_enable;\n\tint err;\n\n\tif (!devlink_port->ops->port_fn_roce_get)\n\t\treturn 0;\n\n\terr = devlink_port->ops->port_fn_roce_get(devlink_port, &is_enable,\n\t\t\t\t\t\t  extack);\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tdevlink_port_fn_cap_fill(caps, DEVLINK_PORT_FN_CAP_ROCE, is_enable);\n\treturn 0;\n}\n\nstatic int devlink_port_fn_migratable_fill(struct devlink_port *devlink_port,\n\t\t\t\t\t   struct nla_bitfield32 *caps,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tbool is_enable;\n\tint err;\n\n\tif (!devlink_port->ops->port_fn_migratable_get ||\n\t    devlink_port->attrs.flavour != DEVLINK_PORT_FLAVOUR_PCI_VF)\n\t\treturn 0;\n\n\terr = devlink_port->ops->port_fn_migratable_get(devlink_port,\n\t\t\t\t\t\t\t&is_enable, extack);\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tdevlink_port_fn_cap_fill(caps, DEVLINK_PORT_FN_CAP_MIGRATABLE, is_enable);\n\treturn 0;\n}\n\nstatic int devlink_port_fn_ipsec_crypto_fill(struct devlink_port *devlink_port,\n\t\t\t\t\t     struct nla_bitfield32 *caps,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tbool is_enable;\n\tint err;\n\n\tif (!devlink_port->ops->port_fn_ipsec_crypto_get ||\n\t    devlink_port->attrs.flavour != DEVLINK_PORT_FLAVOUR_PCI_VF)\n\t\treturn 0;\n\n\terr = devlink_port->ops->port_fn_ipsec_crypto_get(devlink_port, &is_enable, extack);\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tdevlink_port_fn_cap_fill(caps, DEVLINK_PORT_FN_CAP_IPSEC_CRYPTO, is_enable);\n\treturn 0;\n}\n\nstatic int devlink_port_fn_ipsec_packet_fill(struct devlink_port *devlink_port,\n\t\t\t\t\t     struct nla_bitfield32 *caps,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tbool is_enable;\n\tint err;\n\n\tif (!devlink_port->ops->port_fn_ipsec_packet_get ||\n\t    devlink_port->attrs.flavour != DEVLINK_PORT_FLAVOUR_PCI_VF)\n\t\treturn 0;\n\n\terr = devlink_port->ops->port_fn_ipsec_packet_get(devlink_port, &is_enable, extack);\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tdevlink_port_fn_cap_fill(caps, DEVLINK_PORT_FN_CAP_IPSEC_PACKET, is_enable);\n\treturn 0;\n}\n\nstatic int devlink_port_fn_caps_fill(struct devlink_port *devlink_port,\n\t\t\t\t     struct sk_buff *msg,\n\t\t\t\t     struct netlink_ext_ack *extack,\n\t\t\t\t     bool *msg_updated)\n{\n\tstruct nla_bitfield32 caps = {};\n\tint err;\n\n\terr = devlink_port_fn_roce_fill(devlink_port, &caps, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_port_fn_migratable_fill(devlink_port, &caps, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_port_fn_ipsec_crypto_fill(devlink_port, &caps, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_port_fn_ipsec_packet_fill(devlink_port, &caps, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!caps.selector)\n\t\treturn 0;\n\terr = nla_put_bitfield32(msg, DEVLINK_PORT_FN_ATTR_CAPS, caps.value,\n\t\t\t\t caps.selector);\n\tif (err)\n\t\treturn err;\n\n\t*msg_updated = true;\n\treturn 0;\n}\n\nint devlink_nl_port_handle_fill(struct sk_buff *msg, struct devlink_port *devlink_port)\n{\n\tif (devlink_nl_put_handle(msg, devlink_port->devlink))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_INDEX, devlink_port->index))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nsize_t devlink_nl_port_handle_size(struct devlink_port *devlink_port)\n{\n\tstruct devlink *devlink = devlink_port->devlink;\n\n\treturn nla_total_size(strlen(devlink->dev->bus->name) + 1)  \n\t     + nla_total_size(strlen(dev_name(devlink->dev)) + 1)  \n\t     + nla_total_size(4);  \n}\n\nstatic int devlink_nl_port_attrs_put(struct sk_buff *msg,\n\t\t\t\t     struct devlink_port *devlink_port)\n{\n\tstruct devlink_port_attrs *attrs = &devlink_port->attrs;\n\n\tif (!devlink_port->attrs_set)\n\t\treturn 0;\n\tif (attrs->lanes) {\n\t\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_LANES, attrs->lanes))\n\t\t\treturn -EMSGSIZE;\n\t}\n\tif (nla_put_u8(msg, DEVLINK_ATTR_PORT_SPLITTABLE, attrs->splittable))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u16(msg, DEVLINK_ATTR_PORT_FLAVOUR, attrs->flavour))\n\t\treturn -EMSGSIZE;\n\tswitch (devlink_port->attrs.flavour) {\n\tcase DEVLINK_PORT_FLAVOUR_PCI_PF:\n\t\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_CONTROLLER_NUMBER,\n\t\t\t\tattrs->pci_pf.controller) ||\n\t\t    nla_put_u16(msg, DEVLINK_ATTR_PORT_PCI_PF_NUMBER, attrs->pci_pf.pf))\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_u8(msg, DEVLINK_ATTR_PORT_EXTERNAL, attrs->pci_pf.external))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\tcase DEVLINK_PORT_FLAVOUR_PCI_VF:\n\t\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_CONTROLLER_NUMBER,\n\t\t\t\tattrs->pci_vf.controller) ||\n\t\t    nla_put_u16(msg, DEVLINK_ATTR_PORT_PCI_PF_NUMBER, attrs->pci_vf.pf) ||\n\t\t    nla_put_u16(msg, DEVLINK_ATTR_PORT_PCI_VF_NUMBER, attrs->pci_vf.vf))\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_u8(msg, DEVLINK_ATTR_PORT_EXTERNAL, attrs->pci_vf.external))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\tcase DEVLINK_PORT_FLAVOUR_PCI_SF:\n\t\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_CONTROLLER_NUMBER,\n\t\t\t\tattrs->pci_sf.controller) ||\n\t\t    nla_put_u16(msg, DEVLINK_ATTR_PORT_PCI_PF_NUMBER,\n\t\t\t\tattrs->pci_sf.pf) ||\n\t\t    nla_put_u32(msg, DEVLINK_ATTR_PORT_PCI_SF_NUMBER,\n\t\t\t\tattrs->pci_sf.sf))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\tcase DEVLINK_PORT_FLAVOUR_PHYSICAL:\n\tcase DEVLINK_PORT_FLAVOUR_CPU:\n\tcase DEVLINK_PORT_FLAVOUR_DSA:\n\t\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_NUMBER,\n\t\t\t\tattrs->phys.port_number))\n\t\t\treturn -EMSGSIZE;\n\t\tif (!attrs->split)\n\t\t\treturn 0;\n\t\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_SPLIT_GROUP,\n\t\t\t\tattrs->phys.port_number))\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_SPLIT_SUBPORT_NUMBER,\n\t\t\t\tattrs->phys.split_subport_number))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int devlink_port_fn_hw_addr_fill(struct devlink_port *port,\n\t\t\t\t\tstruct sk_buff *msg,\n\t\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\t\tbool *msg_updated)\n{\n\tu8 hw_addr[MAX_ADDR_LEN];\n\tint hw_addr_len;\n\tint err;\n\n\tif (!port->ops->port_fn_hw_addr_get)\n\t\treturn 0;\n\n\terr = port->ops->port_fn_hw_addr_get(port, hw_addr, &hw_addr_len,\n\t\t\t\t\t     extack);\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\terr = nla_put(msg, DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR, hw_addr_len, hw_addr);\n\tif (err)\n\t\treturn err;\n\t*msg_updated = true;\n\treturn 0;\n}\n\nstatic bool\ndevlink_port_fn_state_valid(enum devlink_port_fn_state state)\n{\n\treturn state == DEVLINK_PORT_FN_STATE_INACTIVE ||\n\t       state == DEVLINK_PORT_FN_STATE_ACTIVE;\n}\n\nstatic bool\ndevlink_port_fn_opstate_valid(enum devlink_port_fn_opstate opstate)\n{\n\treturn opstate == DEVLINK_PORT_FN_OPSTATE_DETACHED ||\n\t       opstate == DEVLINK_PORT_FN_OPSTATE_ATTACHED;\n}\n\nstatic int devlink_port_fn_state_fill(struct devlink_port *port,\n\t\t\t\t      struct sk_buff *msg,\n\t\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t\t      bool *msg_updated)\n{\n\tenum devlink_port_fn_opstate opstate;\n\tenum devlink_port_fn_state state;\n\tint err;\n\n\tif (!port->ops->port_fn_state_get)\n\t\treturn 0;\n\n\terr = port->ops->port_fn_state_get(port, &state, &opstate, extack);\n\tif (err) {\n\t\tif (err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tif (!devlink_port_fn_state_valid(state)) {\n\t\tWARN_ON_ONCE(1);\n\t\tNL_SET_ERR_MSG(extack, \"Invalid state read from driver\");\n\t\treturn -EINVAL;\n\t}\n\tif (!devlink_port_fn_opstate_valid(opstate)) {\n\t\tWARN_ON_ONCE(1);\n\t\tNL_SET_ERR_MSG(extack, \"Invalid operational state read from driver\");\n\t\treturn -EINVAL;\n\t}\n\tif (nla_put_u8(msg, DEVLINK_PORT_FN_ATTR_STATE, state) ||\n\t    nla_put_u8(msg, DEVLINK_PORT_FN_ATTR_OPSTATE, opstate))\n\t\treturn -EMSGSIZE;\n\t*msg_updated = true;\n\treturn 0;\n}\n\nstatic int\ndevlink_port_fn_mig_set(struct devlink_port *devlink_port, bool enable,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\treturn devlink_port->ops->port_fn_migratable_set(devlink_port, enable,\n\t\t\t\t\t\t\t extack);\n}\n\nstatic int\ndevlink_port_fn_roce_set(struct devlink_port *devlink_port, bool enable,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn devlink_port->ops->port_fn_roce_set(devlink_port, enable,\n\t\t\t\t\t\t   extack);\n}\n\nstatic int\ndevlink_port_fn_ipsec_crypto_set(struct devlink_port *devlink_port, bool enable,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn devlink_port->ops->port_fn_ipsec_crypto_set(devlink_port, enable, extack);\n}\n\nstatic int\ndevlink_port_fn_ipsec_packet_set(struct devlink_port *devlink_port, bool enable,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\treturn devlink_port->ops->port_fn_ipsec_packet_set(devlink_port, enable, extack);\n}\n\nstatic int devlink_port_fn_caps_set(struct devlink_port *devlink_port,\n\t\t\t\t    const struct nlattr *attr,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nla_bitfield32 caps;\n\tu32 caps_value;\n\tint err;\n\n\tcaps = nla_get_bitfield32(attr);\n\tcaps_value = caps.value & caps.selector;\n\tif (caps.selector & DEVLINK_PORT_FN_CAP_ROCE) {\n\t\terr = devlink_port_fn_roce_set(devlink_port,\n\t\t\t\t\t       caps_value & DEVLINK_PORT_FN_CAP_ROCE,\n\t\t\t\t\t       extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (caps.selector & DEVLINK_PORT_FN_CAP_MIGRATABLE) {\n\t\terr = devlink_port_fn_mig_set(devlink_port, caps_value &\n\t\t\t\t\t      DEVLINK_PORT_FN_CAP_MIGRATABLE,\n\t\t\t\t\t      extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (caps.selector & DEVLINK_PORT_FN_CAP_IPSEC_CRYPTO) {\n\t\terr = devlink_port_fn_ipsec_crypto_set(devlink_port, caps_value &\n\t\t\t\t\t\t       DEVLINK_PORT_FN_CAP_IPSEC_CRYPTO,\n\t\t\t\t\t\t       extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (caps.selector & DEVLINK_PORT_FN_CAP_IPSEC_PACKET) {\n\t\terr = devlink_port_fn_ipsec_packet_set(devlink_port, caps_value &\n\t\t\t\t\t\t       DEVLINK_PORT_FN_CAP_IPSEC_PACKET,\n\t\t\t\t\t\t       extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int\ndevlink_nl_port_function_attrs_put(struct sk_buff *msg, struct devlink_port *port,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *function_attr;\n\tbool msg_updated = false;\n\tint err;\n\n\tfunction_attr = nla_nest_start_noflag(msg, DEVLINK_ATTR_PORT_FUNCTION);\n\tif (!function_attr)\n\t\treturn -EMSGSIZE;\n\n\terr = devlink_port_fn_hw_addr_fill(port, msg, extack, &msg_updated);\n\tif (err)\n\t\tgoto out;\n\terr = devlink_port_fn_caps_fill(port, msg, extack, &msg_updated);\n\tif (err)\n\t\tgoto out;\n\terr = devlink_port_fn_state_fill(port, msg, extack, &msg_updated);\nout:\n\tif (err || !msg_updated)\n\t\tnla_nest_cancel(msg, function_attr);\n\telse\n\t\tnla_nest_end(msg, function_attr);\n\treturn err;\n}\n\nstatic int devlink_nl_port_fill(struct sk_buff *msg,\n\t\t\t\tstruct devlink_port *devlink_port,\n\t\t\t\tenum devlink_command cmd, u32 portid, u32 seq,\n\t\t\t\tint flags, struct netlink_ext_ack *extack)\n{\n\tstruct devlink *devlink = devlink_port->devlink;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_INDEX, devlink_port->index))\n\t\tgoto nla_put_failure;\n\n\tspin_lock_bh(&devlink_port->type_lock);\n\tif (nla_put_u16(msg, DEVLINK_ATTR_PORT_TYPE, devlink_port->type))\n\t\tgoto nla_put_failure_type_locked;\n\tif (devlink_port->desired_type != DEVLINK_PORT_TYPE_NOTSET &&\n\t    nla_put_u16(msg, DEVLINK_ATTR_PORT_DESIRED_TYPE,\n\t\t\tdevlink_port->desired_type))\n\t\tgoto nla_put_failure_type_locked;\n\tif (devlink_port->type == DEVLINK_PORT_TYPE_ETH) {\n\t\tif (devlink_port->type_eth.netdev &&\n\t\t    (nla_put_u32(msg, DEVLINK_ATTR_PORT_NETDEV_IFINDEX,\n\t\t\t\t devlink_port->type_eth.ifindex) ||\n\t\t     nla_put_string(msg, DEVLINK_ATTR_PORT_NETDEV_NAME,\n\t\t\t\t    devlink_port->type_eth.ifname)))\n\t\t\tgoto nla_put_failure_type_locked;\n\t}\n\tif (devlink_port->type == DEVLINK_PORT_TYPE_IB) {\n\t\tstruct ib_device *ibdev = devlink_port->type_ib.ibdev;\n\n\t\tif (ibdev &&\n\t\t    nla_put_string(msg, DEVLINK_ATTR_PORT_IBDEV_NAME,\n\t\t\t\t   ibdev->name))\n\t\t\tgoto nla_put_failure_type_locked;\n\t}\n\tspin_unlock_bh(&devlink_port->type_lock);\n\tif (devlink_nl_port_attrs_put(msg, devlink_port))\n\t\tgoto nla_put_failure;\n\tif (devlink_nl_port_function_attrs_put(msg, devlink_port, extack))\n\t\tgoto nla_put_failure;\n\tif (devlink_port->linecard &&\n\t    nla_put_u32(msg, DEVLINK_ATTR_LINECARD_INDEX,\n\t\t\tdevlink_port->linecard->index))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure_type_locked:\n\tspin_unlock_bh(&devlink_port->type_lock);\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic void devlink_port_notify(struct devlink_port *devlink_port,\n\t\t\t\tenum devlink_command cmd)\n{\n\tstruct devlink *devlink = devlink_port->devlink;\n\tstruct sk_buff *msg;\n\tint err;\n\n\tWARN_ON(cmd != DEVLINK_CMD_PORT_NEW && cmd != DEVLINK_CMD_PORT_DEL);\n\n\tif (!xa_get_mark(&devlinks, devlink->index, DEVLINK_REGISTERED))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\terr = devlink_nl_port_fill(msg, devlink_port, cmd, 0, 0, 0, NULL);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink), msg,\n\t\t\t\t0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nstatic void devlink_ports_notify(struct devlink *devlink,\n\t\t\t\t enum devlink_command cmd)\n{\n\tstruct devlink_port *devlink_port;\n\tunsigned long port_index;\n\n\txa_for_each(&devlink->ports, port_index, devlink_port)\n\t\tdevlink_port_notify(devlink_port, cmd);\n}\n\nvoid devlink_ports_notify_register(struct devlink *devlink)\n{\n\tdevlink_ports_notify(devlink, DEVLINK_CMD_PORT_NEW);\n}\n\nvoid devlink_ports_notify_unregister(struct devlink *devlink)\n{\n\tdevlink_ports_notify(devlink, DEVLINK_CMD_PORT_DEL);\n}\n\nint devlink_nl_port_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink_port *devlink_port = info->user_ptr[1];\n\tstruct sk_buff *msg;\n\tint err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_port_fill(msg, devlink_port, DEVLINK_CMD_PORT_NEW,\n\t\t\t\t   info->snd_portid, info->snd_seq, 0,\n\t\t\t\t   info->extack);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int\ndevlink_nl_port_get_dump_one(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t     struct netlink_callback *cb, int flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct devlink_port *devlink_port;\n\tunsigned long port_index;\n\tint err = 0;\n\n\txa_for_each_start(&devlink->ports, port_index, devlink_port, state->idx) {\n\t\terr = devlink_nl_port_fill(msg, devlink_port,\n\t\t\t\t\t   DEVLINK_CMD_NEW,\n\t\t\t\t\t   NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, flags,\n\t\t\t\t\t   cb->extack);\n\t\tif (err) {\n\t\t\tstate->idx = port_index;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint devlink_nl_port_get_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb, devlink_nl_port_get_dump_one);\n}\n\nstatic int devlink_port_type_set(struct devlink_port *devlink_port,\n\t\t\t\t enum devlink_port_type port_type)\n\n{\n\tint err;\n\n\tif (!devlink_port->ops->port_type_set)\n\t\treturn -EOPNOTSUPP;\n\n\tif (port_type == devlink_port->type)\n\t\treturn 0;\n\n\terr = devlink_port->ops->port_type_set(devlink_port, port_type);\n\tif (err)\n\t\treturn err;\n\n\tdevlink_port->desired_type = port_type;\n\tdevlink_port_notify(devlink_port, DEVLINK_CMD_PORT_NEW);\n\treturn 0;\n}\n\nstatic int devlink_port_function_hw_addr_set(struct devlink_port *port,\n\t\t\t\t\t     const struct nlattr *attr,\n\t\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tconst u8 *hw_addr;\n\tint hw_addr_len;\n\n\thw_addr = nla_data(attr);\n\thw_addr_len = nla_len(attr);\n\tif (hw_addr_len > MAX_ADDR_LEN) {\n\t\tNL_SET_ERR_MSG(extack, \"Port function hardware address too long\");\n\t\treturn -EINVAL;\n\t}\n\tif (port->type == DEVLINK_PORT_TYPE_ETH) {\n\t\tif (hw_addr_len != ETH_ALEN) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Address must be 6 bytes for Ethernet device\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!is_unicast_ether_addr(hw_addr)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Non-unicast hardware address unsupported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn port->ops->port_fn_hw_addr_set(port, hw_addr, hw_addr_len,\n\t\t\t\t\t      extack);\n}\n\nstatic int devlink_port_fn_state_set(struct devlink_port *port,\n\t\t\t\t     const struct nlattr *attr,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tenum devlink_port_fn_state state;\n\n\tstate = nla_get_u8(attr);\n\treturn port->ops->port_fn_state_set(port, state, extack);\n}\n\nstatic int devlink_port_function_validate(struct devlink_port *devlink_port,\n\t\t\t\t\t  struct nlattr **tb,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tconst struct devlink_port_ops *ops = devlink_port->ops;\n\tstruct nlattr *attr;\n\n\tif (tb[DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR] &&\n\t    !ops->port_fn_hw_addr_set) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR],\n\t\t\t\t    \"Port doesn't support function attributes\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (tb[DEVLINK_PORT_FN_ATTR_STATE] && !ops->port_fn_state_set) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR],\n\t\t\t\t    \"Function does not support state setting\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tattr = tb[DEVLINK_PORT_FN_ATTR_CAPS];\n\tif (attr) {\n\t\tstruct nla_bitfield32 caps;\n\n\t\tcaps = nla_get_bitfield32(attr);\n\t\tif (caps.selector & DEVLINK_PORT_FN_CAP_ROCE &&\n\t\t    !ops->port_fn_roce_set) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t    \"Port doesn't support RoCE function attribute\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (caps.selector & DEVLINK_PORT_FN_CAP_MIGRATABLE) {\n\t\t\tif (!ops->port_fn_migratable_set) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t\t    \"Port doesn't support migratable function attribute\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (devlink_port->attrs.flavour != DEVLINK_PORT_FLAVOUR_PCI_VF) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t\t    \"migratable function attribute supported for VFs only\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t\tif (caps.selector & DEVLINK_PORT_FN_CAP_IPSEC_CRYPTO) {\n\t\t\tif (!ops->port_fn_ipsec_crypto_set) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t\t    \"Port doesn't support ipsec_crypto function attribute\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (devlink_port->attrs.flavour != DEVLINK_PORT_FLAVOUR_PCI_VF) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t\t    \"ipsec_crypto function attribute supported for VFs only\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t\tif (caps.selector & DEVLINK_PORT_FN_CAP_IPSEC_PACKET) {\n\t\t\tif (!ops->port_fn_ipsec_packet_set) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t\t    \"Port doesn't support ipsec_packet function attribute\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (devlink_port->attrs.flavour != DEVLINK_PORT_FLAVOUR_PCI_VF) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t\t    \"ipsec_packet function attribute supported for VFs only\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int devlink_port_function_set(struct devlink_port *port,\n\t\t\t\t     const struct nlattr *attr,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[DEVLINK_PORT_FUNCTION_ATTR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(tb, DEVLINK_PORT_FUNCTION_ATTR_MAX, attr,\n\t\t\t       devlink_function_nl_policy, extack);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG(extack, \"Fail to parse port function attributes\");\n\t\treturn err;\n\t}\n\n\terr = devlink_port_function_validate(port, tb, extack);\n\tif (err)\n\t\treturn err;\n\n\tattr = tb[DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR];\n\tif (attr) {\n\t\terr = devlink_port_function_hw_addr_set(port, attr, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tattr = tb[DEVLINK_PORT_FN_ATTR_CAPS];\n\tif (attr) {\n\t\terr = devlink_port_fn_caps_set(port, attr, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tattr = tb[DEVLINK_PORT_FN_ATTR_STATE];\n\tif (attr)\n\t\terr = devlink_port_fn_state_set(port, attr, extack);\n\n\tif (!err)\n\t\tdevlink_port_notify(port, DEVLINK_CMD_PORT_NEW);\n\treturn err;\n}\n\nint devlink_nl_cmd_port_set_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink_port *devlink_port = info->user_ptr[1];\n\tint err;\n\n\tif (info->attrs[DEVLINK_ATTR_PORT_TYPE]) {\n\t\tenum devlink_port_type port_type;\n\n\t\tport_type = nla_get_u16(info->attrs[DEVLINK_ATTR_PORT_TYPE]);\n\t\terr = devlink_port_type_set(devlink_port, port_type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[DEVLINK_ATTR_PORT_FUNCTION]) {\n\t\tstruct nlattr *attr = info->attrs[DEVLINK_ATTR_PORT_FUNCTION];\n\t\tstruct netlink_ext_ack *extack = info->extack;\n\n\t\terr = devlink_port_function_set(devlink_port, attr, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint devlink_nl_cmd_port_split_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink_port *devlink_port = info->user_ptr[1];\n\tstruct devlink *devlink = info->user_ptr[0];\n\tu32 count;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_PORT_SPLIT_COUNT))\n\t\treturn -EINVAL;\n\tif (!devlink_port->ops->port_split)\n\t\treturn -EOPNOTSUPP;\n\n\tcount = nla_get_u32(info->attrs[DEVLINK_ATTR_PORT_SPLIT_COUNT]);\n\n\tif (!devlink_port->attrs.splittable) {\n\t\t \n\t\tif (devlink_port->attrs.split)\n\t\t\tNL_SET_ERR_MSG(info->extack, \"Port cannot be split further\");\n\t\telse\n\t\t\tNL_SET_ERR_MSG(info->extack, \"Port cannot be split\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (count < 2 || !is_power_of_2(count) || count > devlink_port->attrs.lanes) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Invalid split count\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn devlink_port->ops->port_split(devlink, devlink_port, count,\n\t\t\t\t\t     info->extack);\n}\n\nint devlink_nl_cmd_port_unsplit_doit(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct devlink_port *devlink_port = info->user_ptr[1];\n\tstruct devlink *devlink = info->user_ptr[0];\n\n\tif (!devlink_port->ops->port_unsplit)\n\t\treturn -EOPNOTSUPP;\n\treturn devlink_port->ops->port_unsplit(devlink, devlink_port, info->extack);\n}\n\nint devlink_nl_cmd_port_new_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct devlink_port_new_attrs new_attrs = {};\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_port *devlink_port;\n\tstruct sk_buff *msg;\n\tint err;\n\n\tif (!devlink->ops->port_new)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[DEVLINK_ATTR_PORT_FLAVOUR] ||\n\t    !info->attrs[DEVLINK_ATTR_PORT_PCI_PF_NUMBER]) {\n\t\tNL_SET_ERR_MSG(extack, \"Port flavour or PCI PF are not specified\");\n\t\treturn -EINVAL;\n\t}\n\tnew_attrs.flavour = nla_get_u16(info->attrs[DEVLINK_ATTR_PORT_FLAVOUR]);\n\tnew_attrs.pfnum =\n\t\tnla_get_u16(info->attrs[DEVLINK_ATTR_PORT_PCI_PF_NUMBER]);\n\n\tif (info->attrs[DEVLINK_ATTR_PORT_INDEX]) {\n\t\t \n\t\tnew_attrs.port_index =\n\t\t\tnla_get_u32(info->attrs[DEVLINK_ATTR_PORT_INDEX]);\n\t\tnew_attrs.port_index_valid = true;\n\t}\n\tif (info->attrs[DEVLINK_ATTR_PORT_CONTROLLER_NUMBER]) {\n\t\tnew_attrs.controller =\n\t\t\tnla_get_u16(info->attrs[DEVLINK_ATTR_PORT_CONTROLLER_NUMBER]);\n\t\tnew_attrs.controller_valid = true;\n\t}\n\tif (new_attrs.flavour == DEVLINK_PORT_FLAVOUR_PCI_SF &&\n\t    info->attrs[DEVLINK_ATTR_PORT_PCI_SF_NUMBER]) {\n\t\tnew_attrs.sfnum = nla_get_u32(info->attrs[DEVLINK_ATTR_PORT_PCI_SF_NUMBER]);\n\t\tnew_attrs.sfnum_valid = true;\n\t}\n\n\terr = devlink->ops->port_new(devlink, &new_attrs,\n\t\t\t\t     extack, &devlink_port);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_port_del;\n\t}\n\terr = devlink_nl_port_fill(msg, devlink_port, DEVLINK_CMD_NEW,\n\t\t\t\t   info->snd_portid, info->snd_seq, 0, NULL);\n\tif (WARN_ON_ONCE(err))\n\t\tgoto err_out_msg_free;\n\terr = genlmsg_reply(msg, info);\n\tif (err)\n\t\tgoto err_out_port_del;\n\treturn 0;\n\nerr_out_msg_free:\n\tnlmsg_free(msg);\nerr_out_port_del:\n\tdevlink_port->ops->port_del(devlink, devlink_port, NULL);\n\treturn err;\n}\n\nint devlink_nl_cmd_port_del_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink_port *devlink_port = info->user_ptr[1];\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct devlink *devlink = info->user_ptr[0];\n\n\tif (!devlink_port->ops->port_del)\n\t\treturn -EOPNOTSUPP;\n\n\treturn devlink_port->ops->port_del(devlink, devlink_port, extack);\n}\n\nstatic void devlink_port_type_warn(struct work_struct *work)\n{\n\tstruct devlink_port *port = container_of(to_delayed_work(work),\n\t\t\t\t\t\t struct devlink_port,\n\t\t\t\t\t\t type_warn_dw);\n\tdev_warn(port->devlink->dev, \"Type was not set for devlink port.\");\n}\n\nstatic bool devlink_port_type_should_warn(struct devlink_port *devlink_port)\n{\n\t \n\treturn devlink_port->attrs.flavour != DEVLINK_PORT_FLAVOUR_CPU &&\n\t       devlink_port->attrs.flavour != DEVLINK_PORT_FLAVOUR_DSA &&\n\t       devlink_port->attrs.flavour != DEVLINK_PORT_FLAVOUR_UNUSED;\n}\n\n#define DEVLINK_PORT_TYPE_WARN_TIMEOUT (HZ * 3600)\n\nstatic void devlink_port_type_warn_schedule(struct devlink_port *devlink_port)\n{\n\tif (!devlink_port_type_should_warn(devlink_port))\n\t\treturn;\n\t \n\tschedule_delayed_work(&devlink_port->type_warn_dw,\n\t\t\t      DEVLINK_PORT_TYPE_WARN_TIMEOUT);\n}\n\nstatic void devlink_port_type_warn_cancel(struct devlink_port *devlink_port)\n{\n\tif (!devlink_port_type_should_warn(devlink_port))\n\t\treturn;\n\tcancel_delayed_work_sync(&devlink_port->type_warn_dw);\n}\n\n \nvoid devlink_port_init(struct devlink *devlink,\n\t\t       struct devlink_port *devlink_port)\n{\n\tif (devlink_port->initialized)\n\t\treturn;\n\tdevlink_port->devlink = devlink;\n\tINIT_LIST_HEAD(&devlink_port->region_list);\n\tdevlink_port->initialized = true;\n}\nEXPORT_SYMBOL_GPL(devlink_port_init);\n\n \nvoid devlink_port_fini(struct devlink_port *devlink_port)\n{\n\tWARN_ON(!list_empty(&devlink_port->region_list));\n}\nEXPORT_SYMBOL_GPL(devlink_port_fini);\n\nstatic const struct devlink_port_ops devlink_port_dummy_ops = {};\n\n \nint devl_port_register_with_ops(struct devlink *devlink,\n\t\t\t\tstruct devlink_port *devlink_port,\n\t\t\t\tunsigned int port_index,\n\t\t\t\tconst struct devlink_port_ops *ops)\n{\n\tint err;\n\n\tdevl_assert_locked(devlink);\n\n\tASSERT_DEVLINK_PORT_NOT_REGISTERED(devlink_port);\n\n\tdevlink_port_init(devlink, devlink_port);\n\tdevlink_port->registered = true;\n\tdevlink_port->index = port_index;\n\tdevlink_port->ops = ops ? ops : &devlink_port_dummy_ops;\n\tspin_lock_init(&devlink_port->type_lock);\n\tINIT_LIST_HEAD(&devlink_port->reporter_list);\n\terr = xa_insert(&devlink->ports, port_index, devlink_port, GFP_KERNEL);\n\tif (err) {\n\t\tdevlink_port->registered = false;\n\t\treturn err;\n\t}\n\n\tINIT_DELAYED_WORK(&devlink_port->type_warn_dw, &devlink_port_type_warn);\n\tdevlink_port_type_warn_schedule(devlink_port);\n\tdevlink_port_notify(devlink_port, DEVLINK_CMD_PORT_NEW);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devl_port_register_with_ops);\n\n \nint devlink_port_register_with_ops(struct devlink *devlink,\n\t\t\t\t   struct devlink_port *devlink_port,\n\t\t\t\t   unsigned int port_index,\n\t\t\t\t   const struct devlink_port_ops *ops)\n{\n\tint err;\n\n\tdevl_lock(devlink);\n\terr = devl_port_register_with_ops(devlink, devlink_port,\n\t\t\t\t\t  port_index, ops);\n\tdevl_unlock(devlink);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(devlink_port_register_with_ops);\n\n \nvoid devl_port_unregister(struct devlink_port *devlink_port)\n{\n\tlockdep_assert_held(&devlink_port->devlink->lock);\n\tWARN_ON(devlink_port->type != DEVLINK_PORT_TYPE_NOTSET);\n\n\tdevlink_port_type_warn_cancel(devlink_port);\n\tdevlink_port_notify(devlink_port, DEVLINK_CMD_PORT_DEL);\n\txa_erase(&devlink_port->devlink->ports, devlink_port->index);\n\tWARN_ON(!list_empty(&devlink_port->reporter_list));\n\tdevlink_port->registered = false;\n}\nEXPORT_SYMBOL_GPL(devl_port_unregister);\n\n \nvoid devlink_port_unregister(struct devlink_port *devlink_port)\n{\n\tstruct devlink *devlink = devlink_port->devlink;\n\n\tdevl_lock(devlink);\n\tdevl_port_unregister(devlink_port);\n\tdevl_unlock(devlink);\n}\nEXPORT_SYMBOL_GPL(devlink_port_unregister);\n\nstatic void devlink_port_type_netdev_checks(struct devlink_port *devlink_port,\n\t\t\t\t\t    struct net_device *netdev)\n{\n\tconst struct net_device_ops *ops = netdev->netdev_ops;\n\n\t \n\tif (ops->ndo_get_phys_port_name) {\n\t\t \n\t\tchar name[IFNAMSIZ];\n\t\tint err;\n\n\t\terr = ops->ndo_get_phys_port_name(netdev, name, sizeof(name));\n\t\tWARN_ON(err != -EOPNOTSUPP);\n\t}\n\tif (ops->ndo_get_port_parent_id) {\n\t\t \n\t\tstruct netdev_phys_item_id ppid;\n\t\tint err;\n\n\t\terr = ops->ndo_get_port_parent_id(netdev, &ppid);\n\t\tWARN_ON(err != -EOPNOTSUPP);\n\t}\n}\n\nstatic void __devlink_port_type_set(struct devlink_port *devlink_port,\n\t\t\t\t    enum devlink_port_type type,\n\t\t\t\t    void *type_dev)\n{\n\tstruct net_device *netdev = type_dev;\n\n\tASSERT_DEVLINK_PORT_REGISTERED(devlink_port);\n\n\tif (type == DEVLINK_PORT_TYPE_NOTSET) {\n\t\tdevlink_port_type_warn_schedule(devlink_port);\n\t} else {\n\t\tdevlink_port_type_warn_cancel(devlink_port);\n\t\tif (type == DEVLINK_PORT_TYPE_ETH && netdev)\n\t\t\tdevlink_port_type_netdev_checks(devlink_port, netdev);\n\t}\n\n\tspin_lock_bh(&devlink_port->type_lock);\n\tdevlink_port->type = type;\n\tswitch (type) {\n\tcase DEVLINK_PORT_TYPE_ETH:\n\t\tdevlink_port->type_eth.netdev = netdev;\n\t\tif (netdev) {\n\t\t\tASSERT_RTNL();\n\t\t\tdevlink_port->type_eth.ifindex = netdev->ifindex;\n\t\t\tBUILD_BUG_ON(sizeof(devlink_port->type_eth.ifname) !=\n\t\t\t\t     sizeof(netdev->name));\n\t\t\tstrcpy(devlink_port->type_eth.ifname, netdev->name);\n\t\t}\n\t\tbreak;\n\tcase DEVLINK_PORT_TYPE_IB:\n\t\tdevlink_port->type_ib.ibdev = type_dev;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock_bh(&devlink_port->type_lock);\n\tdevlink_port_notify(devlink_port, DEVLINK_CMD_PORT_NEW);\n}\n\n \nvoid devlink_port_type_eth_set(struct devlink_port *devlink_port)\n{\n\tdev_warn(devlink_port->devlink->dev,\n\t\t \"devlink port type for port %d set to Ethernet without a software interface reference, device type not supported by the kernel?\\n\",\n\t\t devlink_port->index);\n\t__devlink_port_type_set(devlink_port, DEVLINK_PORT_TYPE_ETH, NULL);\n}\nEXPORT_SYMBOL_GPL(devlink_port_type_eth_set);\n\n \nvoid devlink_port_type_ib_set(struct devlink_port *devlink_port,\n\t\t\t      struct ib_device *ibdev)\n{\n\t__devlink_port_type_set(devlink_port, DEVLINK_PORT_TYPE_IB, ibdev);\n}\nEXPORT_SYMBOL_GPL(devlink_port_type_ib_set);\n\n \nvoid devlink_port_type_clear(struct devlink_port *devlink_port)\n{\n\tif (devlink_port->type == DEVLINK_PORT_TYPE_ETH)\n\t\tdev_warn(devlink_port->devlink->dev,\n\t\t\t \"devlink port type for port %d cleared without a software interface reference, device type not supported by the kernel?\\n\",\n\t\t\t devlink_port->index);\n\t__devlink_port_type_set(devlink_port, DEVLINK_PORT_TYPE_NOTSET, NULL);\n}\nEXPORT_SYMBOL_GPL(devlink_port_type_clear);\n\nint devlink_port_netdevice_event(struct notifier_block *nb,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\n\tstruct devlink_port *devlink_port = netdev->devlink_port;\n\tstruct devlink *devlink;\n\n\tif (!devlink_port)\n\t\treturn NOTIFY_OK;\n\tdevlink = devlink_port->devlink;\n\n\tswitch (event) {\n\tcase NETDEV_POST_INIT:\n\t\t \n\t\t__devlink_port_type_set(devlink_port, DEVLINK_PORT_TYPE_ETH,\n\t\t\t\t\tNULL);\n\t\tbreak;\n\tcase NETDEV_REGISTER:\n\tcase NETDEV_CHANGENAME:\n\t\tif (devlink_net(devlink) != dev_net(netdev))\n\t\t\treturn NOTIFY_OK;\n\t\t \n\t\t__devlink_port_type_set(devlink_port, devlink_port->type,\n\t\t\t\t\tnetdev);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\tif (devlink_net(devlink) != dev_net(netdev))\n\t\t\treturn NOTIFY_OK;\n\t\t \n\t\t__devlink_port_type_set(devlink_port, devlink_port->type,\n\t\t\t\t\tNULL);\n\t\tbreak;\n\tcase NETDEV_PRE_UNINIT:\n\t\t \n\t\t__devlink_port_type_set(devlink_port, DEVLINK_PORT_TYPE_NOTSET,\n\t\t\t\t\tNULL);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int __devlink_port_attrs_set(struct devlink_port *devlink_port,\n\t\t\t\t    enum devlink_port_flavour flavour)\n{\n\tstruct devlink_port_attrs *attrs = &devlink_port->attrs;\n\n\tdevlink_port->attrs_set = true;\n\tattrs->flavour = flavour;\n\tif (attrs->switch_id.id_len) {\n\t\tdevlink_port->switch_port = true;\n\t\tif (WARN_ON(attrs->switch_id.id_len > MAX_PHYS_ITEM_ID_LEN))\n\t\t\tattrs->switch_id.id_len = MAX_PHYS_ITEM_ID_LEN;\n\t} else {\n\t\tdevlink_port->switch_port = false;\n\t}\n\treturn 0;\n}\n\n \nvoid devlink_port_attrs_set(struct devlink_port *devlink_port,\n\t\t\t    struct devlink_port_attrs *attrs)\n{\n\tint ret;\n\n\tASSERT_DEVLINK_PORT_NOT_REGISTERED(devlink_port);\n\n\tdevlink_port->attrs = *attrs;\n\tret = __devlink_port_attrs_set(devlink_port, attrs->flavour);\n\tif (ret)\n\t\treturn;\n\tWARN_ON(attrs->splittable && attrs->split);\n}\nEXPORT_SYMBOL_GPL(devlink_port_attrs_set);\n\n \nvoid devlink_port_attrs_pci_pf_set(struct devlink_port *devlink_port, u32 controller,\n\t\t\t\t   u16 pf, bool external)\n{\n\tstruct devlink_port_attrs *attrs = &devlink_port->attrs;\n\tint ret;\n\n\tASSERT_DEVLINK_PORT_NOT_REGISTERED(devlink_port);\n\n\tret = __devlink_port_attrs_set(devlink_port,\n\t\t\t\t       DEVLINK_PORT_FLAVOUR_PCI_PF);\n\tif (ret)\n\t\treturn;\n\tattrs->pci_pf.controller = controller;\n\tattrs->pci_pf.pf = pf;\n\tattrs->pci_pf.external = external;\n}\nEXPORT_SYMBOL_GPL(devlink_port_attrs_pci_pf_set);\n\n \nvoid devlink_port_attrs_pci_vf_set(struct devlink_port *devlink_port, u32 controller,\n\t\t\t\t   u16 pf, u16 vf, bool external)\n{\n\tstruct devlink_port_attrs *attrs = &devlink_port->attrs;\n\tint ret;\n\n\tASSERT_DEVLINK_PORT_NOT_REGISTERED(devlink_port);\n\n\tret = __devlink_port_attrs_set(devlink_port,\n\t\t\t\t       DEVLINK_PORT_FLAVOUR_PCI_VF);\n\tif (ret)\n\t\treturn;\n\tattrs->pci_vf.controller = controller;\n\tattrs->pci_vf.pf = pf;\n\tattrs->pci_vf.vf = vf;\n\tattrs->pci_vf.external = external;\n}\nEXPORT_SYMBOL_GPL(devlink_port_attrs_pci_vf_set);\n\n \nvoid devlink_port_attrs_pci_sf_set(struct devlink_port *devlink_port, u32 controller,\n\t\t\t\t   u16 pf, u32 sf, bool external)\n{\n\tstruct devlink_port_attrs *attrs = &devlink_port->attrs;\n\tint ret;\n\n\tASSERT_DEVLINK_PORT_NOT_REGISTERED(devlink_port);\n\n\tret = __devlink_port_attrs_set(devlink_port,\n\t\t\t\t       DEVLINK_PORT_FLAVOUR_PCI_SF);\n\tif (ret)\n\t\treturn;\n\tattrs->pci_sf.controller = controller;\n\tattrs->pci_sf.pf = pf;\n\tattrs->pci_sf.sf = sf;\n\tattrs->pci_sf.external = external;\n}\nEXPORT_SYMBOL_GPL(devlink_port_attrs_pci_sf_set);\n\n \nvoid devlink_port_linecard_set(struct devlink_port *devlink_port,\n\t\t\t       struct devlink_linecard *linecard)\n{\n\tASSERT_DEVLINK_PORT_NOT_REGISTERED(devlink_port);\n\n\tdevlink_port->linecard = linecard;\n}\nEXPORT_SYMBOL_GPL(devlink_port_linecard_set);\n\nstatic int __devlink_port_phys_port_name_get(struct devlink_port *devlink_port,\n\t\t\t\t\t     char *name, size_t len)\n{\n\tstruct devlink_port_attrs *attrs = &devlink_port->attrs;\n\tint n = 0;\n\n\tif (!devlink_port->attrs_set)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (attrs->flavour) {\n\tcase DEVLINK_PORT_FLAVOUR_PHYSICAL:\n\t\tif (devlink_port->linecard)\n\t\t\tn = snprintf(name, len, \"l%u\",\n\t\t\t\t     devlink_port->linecard->index);\n\t\tif (n < len)\n\t\t\tn += snprintf(name + n, len - n, \"p%u\",\n\t\t\t\t      attrs->phys.port_number);\n\t\tif (n < len && attrs->split)\n\t\t\tn += snprintf(name + n, len - n, \"s%u\",\n\t\t\t\t      attrs->phys.split_subport_number);\n\t\tbreak;\n\tcase DEVLINK_PORT_FLAVOUR_CPU:\n\tcase DEVLINK_PORT_FLAVOUR_DSA:\n\tcase DEVLINK_PORT_FLAVOUR_UNUSED:\n\t\t \n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\tcase DEVLINK_PORT_FLAVOUR_PCI_PF:\n\t\tif (attrs->pci_pf.external) {\n\t\t\tn = snprintf(name, len, \"c%u\", attrs->pci_pf.controller);\n\t\t\tif (n >= len)\n\t\t\t\treturn -EINVAL;\n\t\t\tlen -= n;\n\t\t\tname += n;\n\t\t}\n\t\tn = snprintf(name, len, \"pf%u\", attrs->pci_pf.pf);\n\t\tbreak;\n\tcase DEVLINK_PORT_FLAVOUR_PCI_VF:\n\t\tif (attrs->pci_vf.external) {\n\t\t\tn = snprintf(name, len, \"c%u\", attrs->pci_vf.controller);\n\t\t\tif (n >= len)\n\t\t\t\treturn -EINVAL;\n\t\t\tlen -= n;\n\t\t\tname += n;\n\t\t}\n\t\tn = snprintf(name, len, \"pf%uvf%u\",\n\t\t\t     attrs->pci_vf.pf, attrs->pci_vf.vf);\n\t\tbreak;\n\tcase DEVLINK_PORT_FLAVOUR_PCI_SF:\n\t\tif (attrs->pci_sf.external) {\n\t\t\tn = snprintf(name, len, \"c%u\", attrs->pci_sf.controller);\n\t\t\tif (n >= len)\n\t\t\t\treturn -EINVAL;\n\t\t\tlen -= n;\n\t\t\tname += n;\n\t\t}\n\t\tn = snprintf(name, len, \"pf%usf%u\", attrs->pci_sf.pf,\n\t\t\t     attrs->pci_sf.sf);\n\t\tbreak;\n\tcase DEVLINK_PORT_FLAVOUR_VIRTUAL:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (n >= len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint devlink_compat_phys_port_name_get(struct net_device *dev,\n\t\t\t\t      char *name, size_t len)\n{\n\tstruct devlink_port *devlink_port;\n\n\t \n\tASSERT_RTNL();\n\n\tdevlink_port = dev->devlink_port;\n\tif (!devlink_port)\n\t\treturn -EOPNOTSUPP;\n\n\treturn __devlink_port_phys_port_name_get(devlink_port, name, len);\n}\n\nint devlink_compat_switch_id_get(struct net_device *dev,\n\t\t\t\t struct netdev_phys_item_id *ppid)\n{\n\tstruct devlink_port *devlink_port;\n\n\t \n\tdevlink_port = dev->devlink_port;\n\tif (!devlink_port || !devlink_port->switch_port)\n\t\treturn -EOPNOTSUPP;\n\n\tmemcpy(ppid, &devlink_port->attrs.switch_id, sizeof(*ppid));\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}