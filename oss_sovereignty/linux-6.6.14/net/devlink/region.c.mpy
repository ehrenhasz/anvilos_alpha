{
  "module_name": "region.c",
  "hash_id": "8a3288e6b6d694fc842d417715c6c4fbc50e0f17e5827ba3a6cc42c36965849e",
  "original_prompt": "Ingested from linux-6.6.14/net/devlink/region.c",
  "human_readable_source": "\n \n\n#include \"devl_internal.h\"\n\nstruct devlink_region {\n\tstruct devlink *devlink;\n\tstruct devlink_port *port;\n\tstruct list_head list;\n\tunion {\n\t\tconst struct devlink_region_ops *ops;\n\t\tconst struct devlink_port_region_ops *port_ops;\n\t};\n\tstruct mutex snapshot_lock;  \n\tstruct list_head snapshot_list;\n\tu32 max_snapshots;\n\tu32 cur_snapshots;\n\tu64 size;\n};\n\nstruct devlink_snapshot {\n\tstruct list_head list;\n\tstruct devlink_region *region;\n\tu8 *data;\n\tu32 id;\n};\n\nstatic struct devlink_region *\ndevlink_region_get_by_name(struct devlink *devlink, const char *region_name)\n{\n\tstruct devlink_region *region;\n\n\tlist_for_each_entry(region, &devlink->region_list, list)\n\t\tif (!strcmp(region->ops->name, region_name))\n\t\t\treturn region;\n\n\treturn NULL;\n}\n\nstatic struct devlink_region *\ndevlink_port_region_get_by_name(struct devlink_port *port,\n\t\t\t\tconst char *region_name)\n{\n\tstruct devlink_region *region;\n\n\tlist_for_each_entry(region, &port->region_list, list)\n\t\tif (!strcmp(region->ops->name, region_name))\n\t\t\treturn region;\n\n\treturn NULL;\n}\n\nstatic struct devlink_snapshot *\ndevlink_region_snapshot_get_by_id(struct devlink_region *region, u32 id)\n{\n\tstruct devlink_snapshot *snapshot;\n\n\tlist_for_each_entry(snapshot, &region->snapshot_list, list)\n\t\tif (snapshot->id == id)\n\t\t\treturn snapshot;\n\n\treturn NULL;\n}\n\nstatic int devlink_nl_region_snapshot_id_put(struct sk_buff *msg,\n\t\t\t\t\t     struct devlink *devlink,\n\t\t\t\t\t     struct devlink_snapshot *snapshot)\n{\n\tstruct nlattr *snap_attr;\n\tint err;\n\n\tsnap_attr = nla_nest_start_noflag(msg, DEVLINK_ATTR_REGION_SNAPSHOT);\n\tif (!snap_attr)\n\t\treturn -EINVAL;\n\n\terr = nla_put_u32(msg, DEVLINK_ATTR_REGION_SNAPSHOT_ID, snapshot->id);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, snap_attr);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(msg, snap_attr);\n\treturn err;\n}\n\nstatic int devlink_nl_region_snapshots_id_put(struct sk_buff *msg,\n\t\t\t\t\t      struct devlink *devlink,\n\t\t\t\t\t      struct devlink_region *region)\n{\n\tstruct devlink_snapshot *snapshot;\n\tstruct nlattr *snapshots_attr;\n\tint err;\n\n\tsnapshots_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       DEVLINK_ATTR_REGION_SNAPSHOTS);\n\tif (!snapshots_attr)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(snapshot, &region->snapshot_list, list) {\n\t\terr = devlink_nl_region_snapshot_id_put(msg, devlink, snapshot);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tnla_nest_end(msg, snapshots_attr);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(msg, snapshots_attr);\n\treturn err;\n}\n\nstatic int devlink_nl_region_fill(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t\t  enum devlink_command cmd, u32 portid,\n\t\t\t\t  u32 seq, int flags,\n\t\t\t\t  struct devlink_region *region)\n{\n\tvoid *hdr;\n\tint err;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\terr = devlink_nl_put_handle(msg, devlink);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\tif (region->port) {\n\t\terr = nla_put_u32(msg, DEVLINK_ATTR_PORT_INDEX,\n\t\t\t\t  region->port->index);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\terr = nla_put_string(msg, DEVLINK_ATTR_REGION_NAME, region->ops->name);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\terr = nla_put_u64_64bit(msg, DEVLINK_ATTR_REGION_SIZE,\n\t\t\t\tregion->size,\n\t\t\t\tDEVLINK_ATTR_PAD);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\terr = nla_put_u32(msg, DEVLINK_ATTR_REGION_MAX_SNAPSHOTS,\n\t\t\t  region->max_snapshots);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\terr = devlink_nl_region_snapshots_id_put(msg, devlink, region);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn err;\n}\n\nstatic struct sk_buff *\ndevlink_nl_region_notify_build(struct devlink_region *region,\n\t\t\t       struct devlink_snapshot *snapshot,\n\t\t\t       enum devlink_command cmd, u32 portid, u32 seq)\n{\n\tstruct devlink *devlink = region->devlink;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, 0, cmd);\n\tif (!hdr) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out_free_msg;\n\t}\n\n\terr = devlink_nl_put_handle(msg, devlink);\n\tif (err)\n\t\tgoto out_cancel_msg;\n\n\tif (region->port) {\n\t\terr = nla_put_u32(msg, DEVLINK_ATTR_PORT_INDEX,\n\t\t\t\t  region->port->index);\n\t\tif (err)\n\t\t\tgoto out_cancel_msg;\n\t}\n\n\terr = nla_put_string(msg, DEVLINK_ATTR_REGION_NAME,\n\t\t\t     region->ops->name);\n\tif (err)\n\t\tgoto out_cancel_msg;\n\n\tif (snapshot) {\n\t\terr = nla_put_u32(msg, DEVLINK_ATTR_REGION_SNAPSHOT_ID,\n\t\t\t\t  snapshot->id);\n\t\tif (err)\n\t\t\tgoto out_cancel_msg;\n\t} else {\n\t\terr = nla_put_u64_64bit(msg, DEVLINK_ATTR_REGION_SIZE,\n\t\t\t\t\tregion->size, DEVLINK_ATTR_PAD);\n\t\tif (err)\n\t\t\tgoto out_cancel_msg;\n\t}\n\tgenlmsg_end(msg, hdr);\n\n\treturn msg;\n\nout_cancel_msg:\n\tgenlmsg_cancel(msg, hdr);\nout_free_msg:\n\tnlmsg_free(msg);\n\treturn ERR_PTR(err);\n}\n\nstatic void devlink_nl_region_notify(struct devlink_region *region,\n\t\t\t\t     struct devlink_snapshot *snapshot,\n\t\t\t\t     enum devlink_command cmd)\n{\n\tstruct devlink *devlink = region->devlink;\n\tstruct sk_buff *msg;\n\n\tWARN_ON(cmd != DEVLINK_CMD_REGION_NEW && cmd != DEVLINK_CMD_REGION_DEL);\n\tif (!xa_get_mark(&devlinks, devlink->index, DEVLINK_REGISTERED))\n\t\treturn;\n\n\tmsg = devlink_nl_region_notify_build(region, snapshot, cmd, 0, 0);\n\tif (IS_ERR(msg))\n\t\treturn;\n\n\tgenlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink), msg,\n\t\t\t\t0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nvoid devlink_regions_notify_register(struct devlink *devlink)\n{\n\tstruct devlink_region *region;\n\n\tlist_for_each_entry(region, &devlink->region_list, list)\n\t\tdevlink_nl_region_notify(region, NULL, DEVLINK_CMD_REGION_NEW);\n}\n\nvoid devlink_regions_notify_unregister(struct devlink *devlink)\n{\n\tstruct devlink_region *region;\n\n\tlist_for_each_entry_reverse(region, &devlink->region_list, list)\n\t\tdevlink_nl_region_notify(region, NULL, DEVLINK_CMD_REGION_DEL);\n}\n\n \nstatic int __devlink_snapshot_id_increment(struct devlink *devlink, u32 id)\n{\n\tunsigned long count;\n\tvoid *p;\n\tint err;\n\n\txa_lock(&devlink->snapshot_ids);\n\tp = xa_load(&devlink->snapshot_ids, id);\n\tif (WARN_ON(!p)) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (WARN_ON(!xa_is_value(p))) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tcount = xa_to_value(p);\n\tcount++;\n\n\terr = xa_err(__xa_store(&devlink->snapshot_ids, id, xa_mk_value(count),\n\t\t\t\tGFP_ATOMIC));\nunlock:\n\txa_unlock(&devlink->snapshot_ids);\n\treturn err;\n}\n\n \nstatic void __devlink_snapshot_id_decrement(struct devlink *devlink, u32 id)\n{\n\tunsigned long count;\n\tvoid *p;\n\n\txa_lock(&devlink->snapshot_ids);\n\tp = xa_load(&devlink->snapshot_ids, id);\n\tif (WARN_ON(!p))\n\t\tgoto unlock;\n\n\tif (WARN_ON(!xa_is_value(p)))\n\t\tgoto unlock;\n\n\tcount = xa_to_value(p);\n\n\tif (count > 1) {\n\t\tcount--;\n\t\t__xa_store(&devlink->snapshot_ids, id, xa_mk_value(count),\n\t\t\t   GFP_ATOMIC);\n\t} else {\n\t\t \n\t\t__xa_erase(&devlink->snapshot_ids, id);\n\t}\nunlock:\n\txa_unlock(&devlink->snapshot_ids);\n}\n\n \nstatic int __devlink_snapshot_id_insert(struct devlink *devlink, u32 id)\n{\n\tint err;\n\n\txa_lock(&devlink->snapshot_ids);\n\tif (xa_load(&devlink->snapshot_ids, id)) {\n\t\txa_unlock(&devlink->snapshot_ids);\n\t\treturn -EEXIST;\n\t}\n\terr = xa_err(__xa_store(&devlink->snapshot_ids, id, xa_mk_value(0),\n\t\t\t\tGFP_ATOMIC));\n\txa_unlock(&devlink->snapshot_ids);\n\treturn err;\n}\n\n \nstatic int __devlink_region_snapshot_id_get(struct devlink *devlink, u32 *id)\n{\n\treturn xa_alloc(&devlink->snapshot_ids, id, xa_mk_value(1),\n\t\t\txa_limit_32b, GFP_KERNEL);\n}\n\n \nstatic int\n__devlink_region_snapshot_create(struct devlink_region *region,\n\t\t\t\t u8 *data, u32 snapshot_id)\n{\n\tstruct devlink *devlink = region->devlink;\n\tstruct devlink_snapshot *snapshot;\n\tint err;\n\n\tlockdep_assert_held(&region->snapshot_lock);\n\n\t \n\tif (region->cur_snapshots == region->max_snapshots)\n\t\treturn -ENOSPC;\n\n\tif (devlink_region_snapshot_get_by_id(region, snapshot_id))\n\t\treturn -EEXIST;\n\n\tsnapshot = kzalloc(sizeof(*snapshot), GFP_KERNEL);\n\tif (!snapshot)\n\t\treturn -ENOMEM;\n\n\terr = __devlink_snapshot_id_increment(devlink, snapshot_id);\n\tif (err)\n\t\tgoto err_snapshot_id_increment;\n\n\tsnapshot->id = snapshot_id;\n\tsnapshot->region = region;\n\tsnapshot->data = data;\n\n\tlist_add_tail(&snapshot->list, &region->snapshot_list);\n\n\tregion->cur_snapshots++;\n\n\tdevlink_nl_region_notify(region, snapshot, DEVLINK_CMD_REGION_NEW);\n\treturn 0;\n\nerr_snapshot_id_increment:\n\tkfree(snapshot);\n\treturn err;\n}\n\nstatic void devlink_region_snapshot_del(struct devlink_region *region,\n\t\t\t\t\tstruct devlink_snapshot *snapshot)\n{\n\tstruct devlink *devlink = region->devlink;\n\n\tlockdep_assert_held(&region->snapshot_lock);\n\n\tdevlink_nl_region_notify(region, snapshot, DEVLINK_CMD_REGION_DEL);\n\tregion->cur_snapshots--;\n\tlist_del(&snapshot->list);\n\tregion->ops->destructor(snapshot->data);\n\t__devlink_snapshot_id_decrement(devlink, snapshot->id);\n\tkfree(snapshot);\n}\n\nint devlink_nl_region_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_port *port = NULL;\n\tstruct devlink_region *region;\n\tconst char *region_name;\n\tstruct sk_buff *msg;\n\tunsigned int index;\n\tint err;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_REGION_NAME))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[DEVLINK_ATTR_PORT_INDEX]) {\n\t\tindex = nla_get_u32(info->attrs[DEVLINK_ATTR_PORT_INDEX]);\n\n\t\tport = devlink_port_get_by_index(devlink, index);\n\t\tif (!port)\n\t\t\treturn -ENODEV;\n\t}\n\n\tregion_name = nla_data(info->attrs[DEVLINK_ATTR_REGION_NAME]);\n\tif (port)\n\t\tregion = devlink_port_region_get_by_name(port, region_name);\n\telse\n\t\tregion = devlink_region_get_by_name(devlink, region_name);\n\n\tif (!region)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_region_fill(msg, devlink, DEVLINK_CMD_REGION_GET,\n\t\t\t\t     info->snd_portid, info->snd_seq, 0,\n\t\t\t\t     region);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int devlink_nl_cmd_region_get_port_dumpit(struct sk_buff *msg,\n\t\t\t\t\t\t struct netlink_callback *cb,\n\t\t\t\t\t\t struct devlink_port *port,\n\t\t\t\t\t\t int *idx, int start, int flags)\n{\n\tstruct devlink_region *region;\n\tint err = 0;\n\n\tlist_for_each_entry(region, &port->region_list, list) {\n\t\tif (*idx < start) {\n\t\t\t(*idx)++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = devlink_nl_region_fill(msg, port->devlink,\n\t\t\t\t\t     DEVLINK_CMD_REGION_GET,\n\t\t\t\t\t     NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t     cb->nlh->nlmsg_seq,\n\t\t\t\t\t     flags, region);\n\t\tif (err)\n\t\t\tgoto out;\n\t\t(*idx)++;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic int devlink_nl_region_get_dump_one(struct sk_buff *msg,\n\t\t\t\t\t  struct devlink *devlink,\n\t\t\t\t\t  struct netlink_callback *cb,\n\t\t\t\t\t  int flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct devlink_region *region;\n\tstruct devlink_port *port;\n\tunsigned long port_index;\n\tint idx = 0;\n\tint err;\n\n\tlist_for_each_entry(region, &devlink->region_list, list) {\n\t\tif (idx < state->idx) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = devlink_nl_region_fill(msg, devlink,\n\t\t\t\t\t     DEVLINK_CMD_REGION_GET,\n\t\t\t\t\t     NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t     cb->nlh->nlmsg_seq, flags,\n\t\t\t\t\t     region);\n\t\tif (err) {\n\t\t\tstate->idx = idx;\n\t\t\treturn err;\n\t\t}\n\t\tidx++;\n\t}\n\n\txa_for_each(&devlink->ports, port_index, port) {\n\t\terr = devlink_nl_cmd_region_get_port_dumpit(msg, cb, port, &idx,\n\t\t\t\t\t\t\t    state->idx, flags);\n\t\tif (err) {\n\t\t\tstate->idx = idx;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint devlink_nl_region_get_dumpit(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb, devlink_nl_region_get_dump_one);\n}\n\nint devlink_nl_cmd_region_del(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_snapshot *snapshot;\n\tstruct devlink_port *port = NULL;\n\tstruct devlink_region *region;\n\tconst char *region_name;\n\tunsigned int index;\n\tu32 snapshot_id;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_REGION_NAME) ||\n\t    GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_REGION_SNAPSHOT_ID))\n\t\treturn -EINVAL;\n\n\tregion_name = nla_data(info->attrs[DEVLINK_ATTR_REGION_NAME]);\n\tsnapshot_id = nla_get_u32(info->attrs[DEVLINK_ATTR_REGION_SNAPSHOT_ID]);\n\n\tif (info->attrs[DEVLINK_ATTR_PORT_INDEX]) {\n\t\tindex = nla_get_u32(info->attrs[DEVLINK_ATTR_PORT_INDEX]);\n\n\t\tport = devlink_port_get_by_index(devlink, index);\n\t\tif (!port)\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (port)\n\t\tregion = devlink_port_region_get_by_name(port, region_name);\n\telse\n\t\tregion = devlink_region_get_by_name(devlink, region_name);\n\n\tif (!region)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&region->snapshot_lock);\n\tsnapshot = devlink_region_snapshot_get_by_id(region, snapshot_id);\n\tif (!snapshot) {\n\t\tmutex_unlock(&region->snapshot_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tdevlink_region_snapshot_del(region, snapshot);\n\tmutex_unlock(&region->snapshot_lock);\n\treturn 0;\n}\n\nint devlink_nl_cmd_region_new(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_snapshot *snapshot;\n\tstruct devlink_port *port = NULL;\n\tstruct nlattr *snapshot_id_attr;\n\tstruct devlink_region *region;\n\tconst char *region_name;\n\tunsigned int index;\n\tu32 snapshot_id;\n\tu8 *data;\n\tint err;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_REGION_NAME)) {\n\t\tNL_SET_ERR_MSG(info->extack, \"No region name provided\");\n\t\treturn -EINVAL;\n\t}\n\n\tregion_name = nla_data(info->attrs[DEVLINK_ATTR_REGION_NAME]);\n\n\tif (info->attrs[DEVLINK_ATTR_PORT_INDEX]) {\n\t\tindex = nla_get_u32(info->attrs[DEVLINK_ATTR_PORT_INDEX]);\n\n\t\tport = devlink_port_get_by_index(devlink, index);\n\t\tif (!port)\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (port)\n\t\tregion = devlink_port_region_get_by_name(port, region_name);\n\telse\n\t\tregion = devlink_region_get_by_name(devlink, region_name);\n\n\tif (!region) {\n\t\tNL_SET_ERR_MSG(info->extack, \"The requested region does not exist\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!region->ops->snapshot) {\n\t\tNL_SET_ERR_MSG(info->extack, \"The requested region does not support taking an immediate snapshot\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&region->snapshot_lock);\n\n\tif (region->cur_snapshots == region->max_snapshots) {\n\t\tNL_SET_ERR_MSG(info->extack, \"The region has reached the maximum number of stored snapshots\");\n\t\terr = -ENOSPC;\n\t\tgoto unlock;\n\t}\n\n\tsnapshot_id_attr = info->attrs[DEVLINK_ATTR_REGION_SNAPSHOT_ID];\n\tif (snapshot_id_attr) {\n\t\tsnapshot_id = nla_get_u32(snapshot_id_attr);\n\n\t\tif (devlink_region_snapshot_get_by_id(region, snapshot_id)) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"The requested snapshot id is already in use\");\n\t\t\terr = -EEXIST;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = __devlink_snapshot_id_insert(devlink, snapshot_id);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t} else {\n\t\terr = __devlink_region_snapshot_id_get(devlink, &snapshot_id);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"Failed to allocate a new snapshot id\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (port)\n\t\terr = region->port_ops->snapshot(port, region->port_ops,\n\t\t\t\t\t\t info->extack, &data);\n\telse\n\t\terr = region->ops->snapshot(devlink, region->ops,\n\t\t\t\t\t    info->extack, &data);\n\tif (err)\n\t\tgoto err_snapshot_capture;\n\n\terr = __devlink_region_snapshot_create(region, data, snapshot_id);\n\tif (err)\n\t\tgoto err_snapshot_create;\n\n\tif (!snapshot_id_attr) {\n\t\tstruct sk_buff *msg;\n\n\t\tsnapshot = devlink_region_snapshot_get_by_id(region,\n\t\t\t\t\t\t\t     snapshot_id);\n\t\tif (WARN_ON(!snapshot)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tmsg = devlink_nl_region_notify_build(region, snapshot,\n\t\t\t\t\t\t     DEVLINK_CMD_REGION_NEW,\n\t\t\t\t\t\t     info->snd_portid,\n\t\t\t\t\t\t     info->snd_seq);\n\t\terr = PTR_ERR_OR_ZERO(msg);\n\t\tif (err)\n\t\t\tgoto err_notify;\n\n\t\terr = genlmsg_reply(msg, info);\n\t\tif (err)\n\t\t\tgoto err_notify;\n\t}\n\n\tmutex_unlock(&region->snapshot_lock);\n\treturn 0;\n\nerr_snapshot_create:\n\tregion->ops->destructor(data);\nerr_snapshot_capture:\n\t__devlink_snapshot_id_decrement(devlink, snapshot_id);\n\tmutex_unlock(&region->snapshot_lock);\n\treturn err;\n\nerr_notify:\n\tdevlink_region_snapshot_del(region, snapshot);\nunlock:\n\tmutex_unlock(&region->snapshot_lock);\n\treturn err;\n}\n\nstatic int devlink_nl_cmd_region_read_chunk_fill(struct sk_buff *msg,\n\t\t\t\t\t\t u8 *chunk, u32 chunk_size,\n\t\t\t\t\t\t u64 addr)\n{\n\tstruct nlattr *chunk_attr;\n\tint err;\n\n\tchunk_attr = nla_nest_start_noflag(msg, DEVLINK_ATTR_REGION_CHUNK);\n\tif (!chunk_attr)\n\t\treturn -EINVAL;\n\n\terr = nla_put(msg, DEVLINK_ATTR_REGION_CHUNK_DATA, chunk_size, chunk);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\terr = nla_put_u64_64bit(msg, DEVLINK_ATTR_REGION_CHUNK_ADDR, addr,\n\t\t\t\tDEVLINK_ATTR_PAD);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, chunk_attr);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(msg, chunk_attr);\n\treturn err;\n}\n\n#define DEVLINK_REGION_READ_CHUNK_SIZE 256\n\ntypedef int devlink_chunk_fill_t(void *cb_priv, u8 *chunk, u32 chunk_size,\n\t\t\t\t u64 curr_offset,\n\t\t\t\t struct netlink_ext_ack *extack);\n\nstatic int\ndevlink_nl_region_read_fill(struct sk_buff *skb, devlink_chunk_fill_t *cb,\n\t\t\t    void *cb_priv, u64 start_offset, u64 end_offset,\n\t\t\t    u64 *new_offset, struct netlink_ext_ack *extack)\n{\n\tu64 curr_offset = start_offset;\n\tint err = 0;\n\tu8 *data;\n\n\t \n\tdata = kmalloc(DEVLINK_REGION_READ_CHUNK_SIZE, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t*new_offset = start_offset;\n\n\twhile (curr_offset < end_offset) {\n\t\tu32 data_size;\n\n\t\tdata_size = min_t(u32, end_offset - curr_offset,\n\t\t\t\t  DEVLINK_REGION_READ_CHUNK_SIZE);\n\n\t\terr = cb(cb_priv, data, data_size, curr_offset, extack);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = devlink_nl_cmd_region_read_chunk_fill(skb, data, data_size, curr_offset);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tcurr_offset += data_size;\n\t}\n\t*new_offset = curr_offset;\n\n\tkfree(data);\n\n\treturn err;\n}\n\nstatic int\ndevlink_region_snapshot_fill(void *cb_priv, u8 *chunk, u32 chunk_size,\n\t\t\t     u64 curr_offset,\n\t\t\t     struct netlink_ext_ack __always_unused *extack)\n{\n\tstruct devlink_snapshot *snapshot = cb_priv;\n\n\tmemcpy(chunk, &snapshot->data[curr_offset], chunk_size);\n\n\treturn 0;\n}\n\nstatic int\ndevlink_region_port_direct_fill(void *cb_priv, u8 *chunk, u32 chunk_size,\n\t\t\t\tu64 curr_offset, struct netlink_ext_ack *extack)\n{\n\tstruct devlink_region *region = cb_priv;\n\n\treturn region->port_ops->read(region->port, region->port_ops, extack,\n\t\t\t\t      curr_offset, chunk_size, chunk);\n}\n\nstatic int\ndevlink_region_direct_fill(void *cb_priv, u8 *chunk, u32 chunk_size,\n\t\t\t   u64 curr_offset, struct netlink_ext_ack *extack)\n{\n\tstruct devlink_region *region = cb_priv;\n\n\treturn region->ops->read(region->devlink, region->ops, extack,\n\t\t\t\t curr_offset, chunk_size, chunk);\n}\n\nint devlink_nl_cmd_region_read_dumpit(struct sk_buff *skb,\n\t\t\t\t      struct netlink_callback *cb)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct nlattr *chunks_attr, *region_attr, *snapshot_attr;\n\tu64 ret_offset, start_offset, end_offset = U64_MAX;\n\tstruct nlattr **attrs = info->info.attrs;\n\tstruct devlink_port *port = NULL;\n\tdevlink_chunk_fill_t *region_cb;\n\tstruct devlink_region *region;\n\tconst char *region_name;\n\tstruct devlink *devlink;\n\tunsigned int index;\n\tvoid *region_cb_priv;\n\tvoid *hdr;\n\tint err;\n\n\tstart_offset = state->start_offset;\n\n\tdevlink = devlink_get_from_attrs_lock(sock_net(cb->skb->sk), attrs);\n\tif (IS_ERR(devlink))\n\t\treturn PTR_ERR(devlink);\n\n\tif (!attrs[DEVLINK_ATTR_REGION_NAME]) {\n\t\tNL_SET_ERR_MSG(cb->extack, \"No region name provided\");\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (attrs[DEVLINK_ATTR_PORT_INDEX]) {\n\t\tindex = nla_get_u32(attrs[DEVLINK_ATTR_PORT_INDEX]);\n\n\t\tport = devlink_port_get_by_index(devlink, index);\n\t\tif (!port) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tregion_attr = attrs[DEVLINK_ATTR_REGION_NAME];\n\tregion_name = nla_data(region_attr);\n\n\tif (port)\n\t\tregion = devlink_port_region_get_by_name(port, region_name);\n\telse\n\t\tregion = devlink_region_get_by_name(devlink, region_name);\n\n\tif (!region) {\n\t\tNL_SET_ERR_MSG_ATTR(cb->extack, region_attr, \"Requested region does not exist\");\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tsnapshot_attr = attrs[DEVLINK_ATTR_REGION_SNAPSHOT_ID];\n\tif (!snapshot_attr) {\n\t\tif (!nla_get_flag(attrs[DEVLINK_ATTR_REGION_DIRECT])) {\n\t\t\tNL_SET_ERR_MSG(cb->extack, \"No snapshot id provided\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (!region->ops->read) {\n\t\t\tNL_SET_ERR_MSG(cb->extack, \"Requested region does not support direct read\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (port)\n\t\t\tregion_cb = &devlink_region_port_direct_fill;\n\t\telse\n\t\t\tregion_cb = &devlink_region_direct_fill;\n\t\tregion_cb_priv = region;\n\t} else {\n\t\tstruct devlink_snapshot *snapshot;\n\t\tu32 snapshot_id;\n\n\t\tif (nla_get_flag(attrs[DEVLINK_ATTR_REGION_DIRECT])) {\n\t\t\tNL_SET_ERR_MSG_ATTR(cb->extack, snapshot_attr, \"Direct region read does not use snapshot\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tsnapshot_id = nla_get_u32(snapshot_attr);\n\t\tsnapshot = devlink_region_snapshot_get_by_id(region, snapshot_id);\n\t\tif (!snapshot) {\n\t\t\tNL_SET_ERR_MSG_ATTR(cb->extack, snapshot_attr, \"Requested snapshot does not exist\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tregion_cb = &devlink_region_snapshot_fill;\n\t\tregion_cb_priv = snapshot;\n\t}\n\n\tif (attrs[DEVLINK_ATTR_REGION_CHUNK_ADDR] &&\n\t    attrs[DEVLINK_ATTR_REGION_CHUNK_LEN]) {\n\t\tif (!start_offset)\n\t\t\tstart_offset =\n\t\t\t\tnla_get_u64(attrs[DEVLINK_ATTR_REGION_CHUNK_ADDR]);\n\n\t\tend_offset = nla_get_u64(attrs[DEVLINK_ATTR_REGION_CHUNK_ADDR]);\n\t\tend_offset += nla_get_u64(attrs[DEVLINK_ATTR_REGION_CHUNK_LEN]);\n\t}\n\n\tif (end_offset > region->size)\n\t\tend_offset = region->size;\n\n\t \n\tif (start_offset == end_offset) {\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &devlink_nl_family, NLM_F_ACK | NLM_F_MULTI,\n\t\t\t  DEVLINK_CMD_REGION_READ);\n\tif (!hdr) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out_unlock;\n\t}\n\n\terr = devlink_nl_put_handle(skb, devlink);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\tif (region->port) {\n\t\terr = nla_put_u32(skb, DEVLINK_ATTR_PORT_INDEX,\n\t\t\t\t  region->port->index);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\terr = nla_put_string(skb, DEVLINK_ATTR_REGION_NAME, region_name);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\tchunks_attr = nla_nest_start_noflag(skb, DEVLINK_ATTR_REGION_CHUNKS);\n\tif (!chunks_attr) {\n\t\terr = -EMSGSIZE;\n\t\tgoto nla_put_failure;\n\t}\n\n\terr = devlink_nl_region_read_fill(skb, region_cb, region_cb_priv,\n\t\t\t\t\t  start_offset, end_offset, &ret_offset,\n\t\t\t\t\t  cb->extack);\n\n\tif (err && err != -EMSGSIZE)\n\t\tgoto nla_put_failure;\n\n\t \n\tif (ret_offset == start_offset) {\n\t\terr = -EINVAL;\n\t\tgoto nla_put_failure;\n\t}\n\n\tstate->start_offset = ret_offset;\n\n\tnla_nest_end(skb, chunks_attr);\n\tgenlmsg_end(skb, hdr);\n\tdevl_unlock(devlink);\n\tdevlink_put(devlink);\n\treturn skb->len;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\nout_unlock:\n\tdevl_unlock(devlink);\n\tdevlink_put(devlink);\n\treturn err;\n}\n\n \nstruct devlink_region *devl_region_create(struct devlink *devlink,\n\t\t\t\t\t  const struct devlink_region_ops *ops,\n\t\t\t\t\t  u32 region_max_snapshots,\n\t\t\t\t\t  u64 region_size)\n{\n\tstruct devlink_region *region;\n\n\tdevl_assert_locked(devlink);\n\n\tif (WARN_ON(!ops) || WARN_ON(!ops->destructor))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (devlink_region_get_by_name(devlink, ops->name))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tregion = kzalloc(sizeof(*region), GFP_KERNEL);\n\tif (!region)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tregion->devlink = devlink;\n\tregion->max_snapshots = region_max_snapshots;\n\tregion->ops = ops;\n\tregion->size = region_size;\n\tINIT_LIST_HEAD(&region->snapshot_list);\n\tmutex_init(&region->snapshot_lock);\n\tlist_add_tail(&region->list, &devlink->region_list);\n\tdevlink_nl_region_notify(region, NULL, DEVLINK_CMD_REGION_NEW);\n\n\treturn region;\n}\nEXPORT_SYMBOL_GPL(devl_region_create);\n\n \nstruct devlink_region *\ndevlink_region_create(struct devlink *devlink,\n\t\t      const struct devlink_region_ops *ops,\n\t\t      u32 region_max_snapshots, u64 region_size)\n{\n\tstruct devlink_region *region;\n\n\tdevl_lock(devlink);\n\tregion = devl_region_create(devlink, ops, region_max_snapshots,\n\t\t\t\t    region_size);\n\tdevl_unlock(devlink);\n\treturn region;\n}\nEXPORT_SYMBOL_GPL(devlink_region_create);\n\n \nstruct devlink_region *\ndevlink_port_region_create(struct devlink_port *port,\n\t\t\t   const struct devlink_port_region_ops *ops,\n\t\t\t   u32 region_max_snapshots, u64 region_size)\n{\n\tstruct devlink *devlink = port->devlink;\n\tstruct devlink_region *region;\n\tint err = 0;\n\n\tASSERT_DEVLINK_PORT_INITIALIZED(port);\n\n\tif (WARN_ON(!ops) || WARN_ON(!ops->destructor))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdevl_lock(devlink);\n\n\tif (devlink_port_region_get_by_name(port, ops->name)) {\n\t\terr = -EEXIST;\n\t\tgoto unlock;\n\t}\n\n\tregion = kzalloc(sizeof(*region), GFP_KERNEL);\n\tif (!region) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tregion->devlink = devlink;\n\tregion->port = port;\n\tregion->max_snapshots = region_max_snapshots;\n\tregion->port_ops = ops;\n\tregion->size = region_size;\n\tINIT_LIST_HEAD(&region->snapshot_list);\n\tmutex_init(&region->snapshot_lock);\n\tlist_add_tail(&region->list, &port->region_list);\n\tdevlink_nl_region_notify(region, NULL, DEVLINK_CMD_REGION_NEW);\n\n\tdevl_unlock(devlink);\n\treturn region;\n\nunlock:\n\tdevl_unlock(devlink);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(devlink_port_region_create);\n\n \nvoid devl_region_destroy(struct devlink_region *region)\n{\n\tstruct devlink *devlink = region->devlink;\n\tstruct devlink_snapshot *snapshot, *ts;\n\n\tdevl_assert_locked(devlink);\n\n\t \n\tmutex_lock(&region->snapshot_lock);\n\tlist_for_each_entry_safe(snapshot, ts, &region->snapshot_list, list)\n\t\tdevlink_region_snapshot_del(region, snapshot);\n\tmutex_unlock(&region->snapshot_lock);\n\n\tlist_del(&region->list);\n\tmutex_destroy(&region->snapshot_lock);\n\n\tdevlink_nl_region_notify(region, NULL, DEVLINK_CMD_REGION_DEL);\n\tkfree(region);\n}\nEXPORT_SYMBOL_GPL(devl_region_destroy);\n\n \nvoid devlink_region_destroy(struct devlink_region *region)\n{\n\tstruct devlink *devlink = region->devlink;\n\n\tdevl_lock(devlink);\n\tdevl_region_destroy(region);\n\tdevl_unlock(devlink);\n}\nEXPORT_SYMBOL_GPL(devlink_region_destroy);\n\n \nint devlink_region_snapshot_id_get(struct devlink *devlink, u32 *id)\n{\n\treturn __devlink_region_snapshot_id_get(devlink, id);\n}\nEXPORT_SYMBOL_GPL(devlink_region_snapshot_id_get);\n\n \nvoid devlink_region_snapshot_id_put(struct devlink *devlink, u32 id)\n{\n\t__devlink_snapshot_id_decrement(devlink, id);\n}\nEXPORT_SYMBOL_GPL(devlink_region_snapshot_id_put);\n\n \nint devlink_region_snapshot_create(struct devlink_region *region,\n\t\t\t\t   u8 *data, u32 snapshot_id)\n{\n\tint err;\n\n\tmutex_lock(&region->snapshot_lock);\n\terr = __devlink_region_snapshot_create(region, data, snapshot_id);\n\tmutex_unlock(&region->snapshot_lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(devlink_region_snapshot_create);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}