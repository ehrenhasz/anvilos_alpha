{
  "module_name": "dev.c",
  "hash_id": "75c87278bbdeee2a78fa4b45432b0b08a3fc8cd5bcb043b609af605200149841",
  "original_prompt": "Ingested from linux-6.6.14/net/devlink/dev.c",
  "human_readable_source": "\n \n\n#include <net/genetlink.h>\n#include <net/sock.h>\n#include \"devl_internal.h\"\n\nstruct devlink_info_req {\n\tstruct sk_buff *msg;\n\tvoid (*version_cb)(const char *version_name,\n\t\t\t   enum devlink_info_version_type version_type,\n\t\t\t   void *version_cb_priv);\n\tvoid *version_cb_priv;\n};\n\nstruct devlink_reload_combination {\n\tenum devlink_reload_action action;\n\tenum devlink_reload_limit limit;\n};\n\nstatic const struct devlink_reload_combination devlink_reload_invalid_combinations[] = {\n\t{\n\t\t \n\t\t.action = DEVLINK_RELOAD_ACTION_DRIVER_REINIT,\n\t\t.limit = DEVLINK_RELOAD_LIMIT_NO_RESET,\n\t},\n};\n\nstatic bool\ndevlink_reload_combination_is_invalid(enum devlink_reload_action action,\n\t\t\t\t      enum devlink_reload_limit limit)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(devlink_reload_invalid_combinations); i++)\n\t\tif (devlink_reload_invalid_combinations[i].action == action &&\n\t\t    devlink_reload_invalid_combinations[i].limit == limit)\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic bool\ndevlink_reload_action_is_supported(struct devlink *devlink, enum devlink_reload_action action)\n{\n\treturn test_bit(action, &devlink->ops->reload_actions);\n}\n\nstatic bool\ndevlink_reload_limit_is_supported(struct devlink *devlink, enum devlink_reload_limit limit)\n{\n\treturn test_bit(limit, &devlink->ops->reload_limits);\n}\n\nstatic int devlink_reload_stat_put(struct sk_buff *msg,\n\t\t\t\t   enum devlink_reload_limit limit, u32 value)\n{\n\tstruct nlattr *reload_stats_entry;\n\n\treload_stats_entry = nla_nest_start(msg, DEVLINK_ATTR_RELOAD_STATS_ENTRY);\n\tif (!reload_stats_entry)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u8(msg, DEVLINK_ATTR_RELOAD_STATS_LIMIT, limit) ||\n\t    nla_put_u32(msg, DEVLINK_ATTR_RELOAD_STATS_VALUE, value))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, reload_stats_entry);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(msg, reload_stats_entry);\n\treturn -EMSGSIZE;\n}\n\nstatic int\ndevlink_reload_stats_put(struct sk_buff *msg, struct devlink *devlink, bool is_remote)\n{\n\tstruct nlattr *reload_stats_attr, *act_info, *act_stats;\n\tint i, j, stat_idx;\n\tu32 value;\n\n\tif (!is_remote)\n\t\treload_stats_attr = nla_nest_start(msg, DEVLINK_ATTR_RELOAD_STATS);\n\telse\n\t\treload_stats_attr = nla_nest_start(msg, DEVLINK_ATTR_REMOTE_RELOAD_STATS);\n\n\tif (!reload_stats_attr)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i <= DEVLINK_RELOAD_ACTION_MAX; i++) {\n\t\tif ((!is_remote &&\n\t\t     !devlink_reload_action_is_supported(devlink, i)) ||\n\t\t    i == DEVLINK_RELOAD_ACTION_UNSPEC)\n\t\t\tcontinue;\n\t\tact_info = nla_nest_start(msg, DEVLINK_ATTR_RELOAD_ACTION_INFO);\n\t\tif (!act_info)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u8(msg, DEVLINK_ATTR_RELOAD_ACTION, i))\n\t\t\tgoto action_info_nest_cancel;\n\t\tact_stats = nla_nest_start(msg, DEVLINK_ATTR_RELOAD_ACTION_STATS);\n\t\tif (!act_stats)\n\t\t\tgoto action_info_nest_cancel;\n\n\t\tfor (j = 0; j <= DEVLINK_RELOAD_LIMIT_MAX; j++) {\n\t\t\t \n\t\t\tif ((!is_remote && j != DEVLINK_RELOAD_LIMIT_UNSPEC &&\n\t\t\t     !devlink_reload_limit_is_supported(devlink, j)) ||\n\t\t\t    devlink_reload_combination_is_invalid(i, j))\n\t\t\t\tcontinue;\n\n\t\t\tstat_idx = j * __DEVLINK_RELOAD_ACTION_MAX + i;\n\t\t\tif (!is_remote)\n\t\t\t\tvalue = devlink->stats.reload_stats[stat_idx];\n\t\t\telse\n\t\t\t\tvalue = devlink->stats.remote_reload_stats[stat_idx];\n\t\t\tif (devlink_reload_stat_put(msg, j, value))\n\t\t\t\tgoto action_stats_nest_cancel;\n\t\t}\n\t\tnla_nest_end(msg, act_stats);\n\t\tnla_nest_end(msg, act_info);\n\t}\n\tnla_nest_end(msg, reload_stats_attr);\n\treturn 0;\n\naction_stats_nest_cancel:\n\tnla_nest_cancel(msg, act_stats);\naction_info_nest_cancel:\n\tnla_nest_cancel(msg, act_info);\nnla_put_failure:\n\tnla_nest_cancel(msg, reload_stats_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int devlink_nl_fill(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t   enum devlink_command cmd, u32 portid,\n\t\t\t   u32 seq, int flags)\n{\n\tstruct nlattr *dev_stats;\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(msg, DEVLINK_ATTR_RELOAD_FAILED, devlink->reload_failed))\n\t\tgoto nla_put_failure;\n\n\tdev_stats = nla_nest_start(msg, DEVLINK_ATTR_DEV_STATS);\n\tif (!dev_stats)\n\t\tgoto nla_put_failure;\n\n\tif (devlink_reload_stats_put(msg, devlink, false))\n\t\tgoto dev_stats_nest_cancel;\n\tif (devlink_reload_stats_put(msg, devlink, true))\n\t\tgoto dev_stats_nest_cancel;\n\n\tnla_nest_end(msg, dev_stats);\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\ndev_stats_nest_cancel:\n\tnla_nest_cancel(msg, dev_stats);\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic void devlink_notify(struct devlink *devlink, enum devlink_command cmd)\n{\n\tstruct sk_buff *msg;\n\tint err;\n\n\tWARN_ON(cmd != DEVLINK_CMD_NEW && cmd != DEVLINK_CMD_DEL);\n\tWARN_ON(!xa_get_mark(&devlinks, devlink->index, DEVLINK_REGISTERED));\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\terr = devlink_nl_fill(msg, devlink, cmd, 0, 0, 0);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink),\n\t\t\t\tmsg, 0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nint devlink_nl_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tint err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_fill(msg, devlink, DEVLINK_CMD_NEW,\n\t\t\t      info->snd_portid, info->snd_seq, 0);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int\ndevlink_nl_get_dump_one(struct sk_buff *msg, struct devlink *devlink,\n\t\t\tstruct netlink_callback *cb, int flags)\n{\n\treturn devlink_nl_fill(msg, devlink, DEVLINK_CMD_NEW,\n\t\t\t       NETLINK_CB(cb->skb).portid,\n\t\t\t       cb->nlh->nlmsg_seq, flags);\n}\n\nint devlink_nl_get_dumpit(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(msg, cb, devlink_nl_get_dump_one);\n}\n\nvoid devlink_notify_register(struct devlink *devlink)\n{\n\tdevlink_notify(devlink, DEVLINK_CMD_NEW);\n\tdevlink_linecards_notify_register(devlink);\n\tdevlink_ports_notify_register(devlink);\n\tdevlink_trap_policers_notify_register(devlink);\n\tdevlink_trap_groups_notify_register(devlink);\n\tdevlink_traps_notify_register(devlink);\n\tdevlink_rates_notify_register(devlink);\n\tdevlink_regions_notify_register(devlink);\n\tdevlink_params_notify_register(devlink);\n}\n\nvoid devlink_notify_unregister(struct devlink *devlink)\n{\n\tdevlink_params_notify_unregister(devlink);\n\tdevlink_regions_notify_unregister(devlink);\n\tdevlink_rates_notify_unregister(devlink);\n\tdevlink_traps_notify_unregister(devlink);\n\tdevlink_trap_groups_notify_unregister(devlink);\n\tdevlink_trap_policers_notify_unregister(devlink);\n\tdevlink_ports_notify_unregister(devlink);\n\tdevlink_linecards_notify_unregister(devlink);\n\tdevlink_notify(devlink, DEVLINK_CMD_DEL);\n}\n\nstatic void devlink_reload_failed_set(struct devlink *devlink,\n\t\t\t\t      bool reload_failed)\n{\n\tif (devlink->reload_failed == reload_failed)\n\t\treturn;\n\tdevlink->reload_failed = reload_failed;\n\tdevlink_notify(devlink, DEVLINK_CMD_NEW);\n}\n\nbool devlink_is_reload_failed(const struct devlink *devlink)\n{\n\treturn devlink->reload_failed;\n}\nEXPORT_SYMBOL_GPL(devlink_is_reload_failed);\n\nstatic void\n__devlink_reload_stats_update(struct devlink *devlink, u32 *reload_stats,\n\t\t\t      enum devlink_reload_limit limit, u32 actions_performed)\n{\n\tunsigned long actions = actions_performed;\n\tint stat_idx;\n\tint action;\n\n\tfor_each_set_bit(action, &actions, __DEVLINK_RELOAD_ACTION_MAX) {\n\t\tstat_idx = limit * __DEVLINK_RELOAD_ACTION_MAX + action;\n\t\treload_stats[stat_idx]++;\n\t}\n\tdevlink_notify(devlink, DEVLINK_CMD_NEW);\n}\n\nstatic void\ndevlink_reload_stats_update(struct devlink *devlink, enum devlink_reload_limit limit,\n\t\t\t    u32 actions_performed)\n{\n\t__devlink_reload_stats_update(devlink, devlink->stats.reload_stats, limit,\n\t\t\t\t      actions_performed);\n}\n\n \nvoid devlink_remote_reload_actions_performed(struct devlink *devlink,\n\t\t\t\t\t     enum devlink_reload_limit limit,\n\t\t\t\t\t     u32 actions_performed)\n{\n\tif (WARN_ON(!actions_performed ||\n\t\t    actions_performed & BIT(DEVLINK_RELOAD_ACTION_UNSPEC) ||\n\t\t    actions_performed >= BIT(__DEVLINK_RELOAD_ACTION_MAX) ||\n\t\t    limit > DEVLINK_RELOAD_LIMIT_MAX))\n\t\treturn;\n\n\t__devlink_reload_stats_update(devlink, devlink->stats.remote_reload_stats, limit,\n\t\t\t\t      actions_performed);\n}\nEXPORT_SYMBOL_GPL(devlink_remote_reload_actions_performed);\n\nstatic struct net *devlink_netns_get(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct nlattr *netns_pid_attr = info->attrs[DEVLINK_ATTR_NETNS_PID];\n\tstruct nlattr *netns_fd_attr = info->attrs[DEVLINK_ATTR_NETNS_FD];\n\tstruct nlattr *netns_id_attr = info->attrs[DEVLINK_ATTR_NETNS_ID];\n\tstruct net *net;\n\n\tif (!!netns_pid_attr + !!netns_fd_attr + !!netns_id_attr > 1) {\n\t\tNL_SET_ERR_MSG(info->extack, \"multiple netns identifying attributes specified\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (netns_pid_attr) {\n\t\tnet = get_net_ns_by_pid(nla_get_u32(netns_pid_attr));\n\t} else if (netns_fd_attr) {\n\t\tnet = get_net_ns_by_fd(nla_get_u32(netns_fd_attr));\n\t} else if (netns_id_attr) {\n\t\tnet = get_net_ns_by_id(sock_net(skb->sk),\n\t\t\t\t       nla_get_u32(netns_id_attr));\n\t\tif (!net)\n\t\t\tnet = ERR_PTR(-EINVAL);\n\t} else {\n\t\tWARN_ON(1);\n\t\tnet = ERR_PTR(-EINVAL);\n\t}\n\tif (IS_ERR(net)) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Unknown network namespace\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN)) {\n\t\tput_net(net);\n\t\treturn ERR_PTR(-EPERM);\n\t}\n\treturn net;\n}\n\nstatic void devlink_reload_netns_change(struct devlink *devlink,\n\t\t\t\t\tstruct net *curr_net,\n\t\t\t\t\tstruct net *dest_net)\n{\n\t \n\tdevlink_notify_unregister(devlink);\n\twrite_pnet(&devlink->_net, dest_net);\n\tdevlink_notify_register(devlink);\n}\n\nint devlink_reload(struct devlink *devlink, struct net *dest_net,\n\t\t   enum devlink_reload_action action,\n\t\t   enum devlink_reload_limit limit,\n\t\t   u32 *actions_performed, struct netlink_ext_ack *extack)\n{\n\tu32 remote_reload_stats[DEVLINK_RELOAD_STATS_ARRAY_SIZE];\n\tstruct net *curr_net;\n\tint err;\n\n\tmemcpy(remote_reload_stats, devlink->stats.remote_reload_stats,\n\t       sizeof(remote_reload_stats));\n\n\terr = devlink->ops->reload_down(devlink, !!dest_net, action, limit, extack);\n\tif (err)\n\t\treturn err;\n\n\tcurr_net = devlink_net(devlink);\n\tif (dest_net && !net_eq(dest_net, curr_net))\n\t\tdevlink_reload_netns_change(devlink, curr_net, dest_net);\n\n\tif (action == DEVLINK_RELOAD_ACTION_DRIVER_REINIT)\n\t\tdevlink_params_driverinit_load_new(devlink);\n\n\terr = devlink->ops->reload_up(devlink, action, limit, actions_performed, extack);\n\tdevlink_reload_failed_set(devlink, !!err);\n\tif (err)\n\t\treturn err;\n\n\tWARN_ON(!(*actions_performed & BIT(action)));\n\t \n\tWARN_ON(memcmp(remote_reload_stats, devlink->stats.remote_reload_stats,\n\t\t       sizeof(remote_reload_stats)));\n\tdevlink_reload_stats_update(devlink, limit, *actions_performed);\n\treturn 0;\n}\n\nstatic int\ndevlink_nl_reload_actions_performed_snd(struct devlink *devlink, u32 actions_performed,\n\t\t\t\t\tenum devlink_command cmd, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, info->snd_portid, info->snd_seq, &devlink_nl_family, 0, cmd);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_bitfield32(msg, DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED, actions_performed,\n\t\t\t       actions_performed))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint devlink_nl_cmd_reload(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tenum devlink_reload_action action;\n\tenum devlink_reload_limit limit;\n\tstruct net *dest_net = NULL;\n\tu32 actions_performed;\n\tint err;\n\n\terr = devlink_resources_validate(devlink, NULL, info);\n\tif (err) {\n\t\tNL_SET_ERR_MSG(info->extack, \"resources size validation failed\");\n\t\treturn err;\n\t}\n\n\tif (info->attrs[DEVLINK_ATTR_RELOAD_ACTION])\n\t\taction = nla_get_u8(info->attrs[DEVLINK_ATTR_RELOAD_ACTION]);\n\telse\n\t\taction = DEVLINK_RELOAD_ACTION_DRIVER_REINIT;\n\n\tif (!devlink_reload_action_is_supported(devlink, action)) {\n\t\tNL_SET_ERR_MSG(info->extack, \"Requested reload action is not supported by the driver\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tlimit = DEVLINK_RELOAD_LIMIT_UNSPEC;\n\tif (info->attrs[DEVLINK_ATTR_RELOAD_LIMITS]) {\n\t\tstruct nla_bitfield32 limits;\n\t\tu32 limits_selected;\n\n\t\tlimits = nla_get_bitfield32(info->attrs[DEVLINK_ATTR_RELOAD_LIMITS]);\n\t\tlimits_selected = limits.value & limits.selector;\n\t\tif (!limits_selected) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"Invalid limit selected\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (limit = 0 ; limit <= DEVLINK_RELOAD_LIMIT_MAX ; limit++)\n\t\t\tif (limits_selected & BIT(limit))\n\t\t\t\tbreak;\n\t\t \n\t\tif (limits_selected != BIT(limit)) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"Multiselection of limit is not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!devlink_reload_limit_is_supported(devlink, limit)) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"Requested limit is not supported by the driver\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (devlink_reload_combination_is_invalid(action, limit)) {\n\t\t\tNL_SET_ERR_MSG(info->extack, \"Requested limit is invalid for this action\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (info->attrs[DEVLINK_ATTR_NETNS_PID] ||\n\t    info->attrs[DEVLINK_ATTR_NETNS_FD] ||\n\t    info->attrs[DEVLINK_ATTR_NETNS_ID]) {\n\t\tdest_net = devlink_netns_get(skb, info);\n\t\tif (IS_ERR(dest_net))\n\t\t\treturn PTR_ERR(dest_net);\n\t\tif (!net_eq(dest_net, devlink_net(devlink)) &&\n\t\t    action != DEVLINK_RELOAD_ACTION_DRIVER_REINIT) {\n\t\t\tNL_SET_ERR_MSG_MOD(info->extack,\n\t\t\t\t\t   \"Changing namespace is only supported for reinit action\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\terr = devlink_reload(devlink, dest_net, action, limit, &actions_performed, info->extack);\n\n\tif (dest_net)\n\t\tput_net(dest_net);\n\n\tif (err)\n\t\treturn err;\n\t \n\tif (!info->attrs[DEVLINK_ATTR_RELOAD_ACTION] && !info->attrs[DEVLINK_ATTR_RELOAD_LIMITS])\n\t\treturn 0;\n\n\treturn devlink_nl_reload_actions_performed_snd(devlink, actions_performed,\n\t\t\t\t\t\t       DEVLINK_CMD_RELOAD, info);\n}\n\nbool devlink_reload_actions_valid(const struct devlink_ops *ops)\n{\n\tconst struct devlink_reload_combination *comb;\n\tint i;\n\n\tif (!devlink_reload_supported(ops)) {\n\t\tif (WARN_ON(ops->reload_actions))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tif (WARN_ON(!ops->reload_actions ||\n\t\t    ops->reload_actions & BIT(DEVLINK_RELOAD_ACTION_UNSPEC) ||\n\t\t    ops->reload_actions >= BIT(__DEVLINK_RELOAD_ACTION_MAX)))\n\t\treturn false;\n\n\tif (WARN_ON(ops->reload_limits & BIT(DEVLINK_RELOAD_LIMIT_UNSPEC) ||\n\t\t    ops->reload_limits >= BIT(__DEVLINK_RELOAD_LIMIT_MAX)))\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(devlink_reload_invalid_combinations); i++)  {\n\t\tcomb = &devlink_reload_invalid_combinations[i];\n\t\tif (ops->reload_actions == BIT(comb->action) &&\n\t\t    ops->reload_limits == BIT(comb->limit))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int devlink_nl_eswitch_fill(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t\t   enum devlink_command cmd, u32 portid,\n\t\t\t\t   u32 seq, int flags)\n{\n\tconst struct devlink_ops *ops = devlink->ops;\n\tenum devlink_eswitch_encap_mode encap_mode;\n\tu8 inline_mode;\n\tvoid *hdr;\n\tint err = 0;\n\tu16 mode;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\terr = devlink_nl_put_handle(msg, devlink);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\tif (ops->eswitch_mode_get) {\n\t\terr = ops->eswitch_mode_get(devlink, &mode);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t\terr = nla_put_u16(msg, DEVLINK_ATTR_ESWITCH_MODE, mode);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (ops->eswitch_inline_mode_get) {\n\t\terr = ops->eswitch_inline_mode_get(devlink, &inline_mode);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t\terr = nla_put_u8(msg, DEVLINK_ATTR_ESWITCH_INLINE_MODE,\n\t\t\t\t inline_mode);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (ops->eswitch_encap_mode_get) {\n\t\terr = ops->eswitch_encap_mode_get(devlink, &encap_mode);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t\terr = nla_put_u8(msg, DEVLINK_ATTR_ESWITCH_ENCAP_MODE, encap_mode);\n\t\tif (err)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn err;\n}\n\nint devlink_nl_cmd_eswitch_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tint err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_eswitch_fill(msg, devlink, DEVLINK_CMD_ESWITCH_GET,\n\t\t\t\t      info->snd_portid, info->snd_seq, 0);\n\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nint devlink_nl_cmd_eswitch_set_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tconst struct devlink_ops *ops = devlink->ops;\n\tenum devlink_eswitch_encap_mode encap_mode;\n\tu8 inline_mode;\n\tint err = 0;\n\tu16 mode;\n\n\tif (info->attrs[DEVLINK_ATTR_ESWITCH_MODE]) {\n\t\tif (!ops->eswitch_mode_set)\n\t\t\treturn -EOPNOTSUPP;\n\t\tmode = nla_get_u16(info->attrs[DEVLINK_ATTR_ESWITCH_MODE]);\n\t\terr = devlink_rate_nodes_check(devlink, mode, info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = ops->eswitch_mode_set(devlink, mode, info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[DEVLINK_ATTR_ESWITCH_INLINE_MODE]) {\n\t\tif (!ops->eswitch_inline_mode_set)\n\t\t\treturn -EOPNOTSUPP;\n\t\tinline_mode = nla_get_u8(info->attrs[DEVLINK_ATTR_ESWITCH_INLINE_MODE]);\n\t\terr = ops->eswitch_inline_mode_set(devlink, inline_mode,\n\t\t\t\t\t\t   info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[DEVLINK_ATTR_ESWITCH_ENCAP_MODE]) {\n\t\tif (!ops->eswitch_encap_mode_set)\n\t\t\treturn -EOPNOTSUPP;\n\t\tencap_mode = nla_get_u8(info->attrs[DEVLINK_ATTR_ESWITCH_ENCAP_MODE]);\n\t\terr = ops->eswitch_encap_mode_set(devlink, encap_mode,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint devlink_info_serial_number_put(struct devlink_info_req *req, const char *sn)\n{\n\tif (!req->msg)\n\t\treturn 0;\n\treturn nla_put_string(req->msg, DEVLINK_ATTR_INFO_SERIAL_NUMBER, sn);\n}\nEXPORT_SYMBOL_GPL(devlink_info_serial_number_put);\n\nint devlink_info_board_serial_number_put(struct devlink_info_req *req,\n\t\t\t\t\t const char *bsn)\n{\n\tif (!req->msg)\n\t\treturn 0;\n\treturn nla_put_string(req->msg, DEVLINK_ATTR_INFO_BOARD_SERIAL_NUMBER,\n\t\t\t      bsn);\n}\nEXPORT_SYMBOL_GPL(devlink_info_board_serial_number_put);\n\nstatic int devlink_info_version_put(struct devlink_info_req *req, int attr,\n\t\t\t\t    const char *version_name,\n\t\t\t\t    const char *version_value,\n\t\t\t\t    enum devlink_info_version_type version_type)\n{\n\tstruct nlattr *nest;\n\tint err;\n\n\tif (req->version_cb)\n\t\treq->version_cb(version_name, version_type,\n\t\t\t\treq->version_cb_priv);\n\n\tif (!req->msg)\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(req->msg, attr);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\terr = nla_put_string(req->msg, DEVLINK_ATTR_INFO_VERSION_NAME,\n\t\t\t     version_name);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\terr = nla_put_string(req->msg, DEVLINK_ATTR_INFO_VERSION_VALUE,\n\t\t\t     version_value);\n\tif (err)\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(req->msg, nest);\n\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(req->msg, nest);\n\treturn err;\n}\n\nint devlink_info_version_fixed_put(struct devlink_info_req *req,\n\t\t\t\t   const char *version_name,\n\t\t\t\t   const char *version_value)\n{\n\treturn devlink_info_version_put(req, DEVLINK_ATTR_INFO_VERSION_FIXED,\n\t\t\t\t\tversion_name, version_value,\n\t\t\t\t\tDEVLINK_INFO_VERSION_TYPE_NONE);\n}\nEXPORT_SYMBOL_GPL(devlink_info_version_fixed_put);\n\nint devlink_info_version_stored_put(struct devlink_info_req *req,\n\t\t\t\t    const char *version_name,\n\t\t\t\t    const char *version_value)\n{\n\treturn devlink_info_version_put(req, DEVLINK_ATTR_INFO_VERSION_STORED,\n\t\t\t\t\tversion_name, version_value,\n\t\t\t\t\tDEVLINK_INFO_VERSION_TYPE_NONE);\n}\nEXPORT_SYMBOL_GPL(devlink_info_version_stored_put);\n\nint devlink_info_version_stored_put_ext(struct devlink_info_req *req,\n\t\t\t\t\tconst char *version_name,\n\t\t\t\t\tconst char *version_value,\n\t\t\t\t\tenum devlink_info_version_type version_type)\n{\n\treturn devlink_info_version_put(req, DEVLINK_ATTR_INFO_VERSION_STORED,\n\t\t\t\t\tversion_name, version_value,\n\t\t\t\t\tversion_type);\n}\nEXPORT_SYMBOL_GPL(devlink_info_version_stored_put_ext);\n\nint devlink_info_version_running_put(struct devlink_info_req *req,\n\t\t\t\t     const char *version_name,\n\t\t\t\t     const char *version_value)\n{\n\treturn devlink_info_version_put(req, DEVLINK_ATTR_INFO_VERSION_RUNNING,\n\t\t\t\t\tversion_name, version_value,\n\t\t\t\t\tDEVLINK_INFO_VERSION_TYPE_NONE);\n}\nEXPORT_SYMBOL_GPL(devlink_info_version_running_put);\n\nint devlink_info_version_running_put_ext(struct devlink_info_req *req,\n\t\t\t\t\t const char *version_name,\n\t\t\t\t\t const char *version_value,\n\t\t\t\t\t enum devlink_info_version_type version_type)\n{\n\treturn devlink_info_version_put(req, DEVLINK_ATTR_INFO_VERSION_RUNNING,\n\t\t\t\t\tversion_name, version_value,\n\t\t\t\t\tversion_type);\n}\nEXPORT_SYMBOL_GPL(devlink_info_version_running_put_ext);\n\nstatic int devlink_nl_driver_info_get(struct device_driver *drv,\n\t\t\t\t      struct devlink_info_req *req)\n{\n\tif (!drv)\n\t\treturn 0;\n\n\tif (drv->name[0])\n\t\treturn nla_put_string(req->msg, DEVLINK_ATTR_INFO_DRIVER_NAME,\n\t\t\t\t      drv->name);\n\n\treturn 0;\n}\n\nstatic int\ndevlink_nl_info_fill(struct sk_buff *msg, struct devlink *devlink,\n\t\t     enum devlink_command cmd, u32 portid,\n\t\t     u32 seq, int flags, struct netlink_ext_ack *extack)\n{\n\tstruct device *dev = devlink_to_dev(devlink);\n\tstruct devlink_info_req req = {};\n\tvoid *hdr;\n\tint err;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\terr = -EMSGSIZE;\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto err_cancel_msg;\n\n\treq.msg = msg;\n\tif (devlink->ops->info_get) {\n\t\terr = devlink->ops->info_get(devlink, &req, extack);\n\t\tif (err)\n\t\t\tgoto err_cancel_msg;\n\t}\n\n\terr = devlink_nl_driver_info_get(dev->driver, &req);\n\tif (err)\n\t\tgoto err_cancel_msg;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nerr_cancel_msg:\n\tgenlmsg_cancel(msg, hdr);\n\treturn err;\n}\n\nint devlink_nl_info_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tint err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_info_fill(msg, devlink, DEVLINK_CMD_INFO_GET,\n\t\t\t\t   info->snd_portid, info->snd_seq, 0,\n\t\t\t\t   info->extack);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int\ndevlink_nl_info_get_dump_one(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t     struct netlink_callback *cb, int flags)\n{\n\tint err;\n\n\terr = devlink_nl_info_fill(msg, devlink, DEVLINK_CMD_INFO_GET,\n\t\t\t\t   NETLINK_CB(cb->skb).portid,\n\t\t\t\t   cb->nlh->nlmsg_seq, flags,\n\t\t\t\t   cb->extack);\n\tif (err == -EOPNOTSUPP)\n\t\terr = 0;\n\treturn err;\n}\n\nint devlink_nl_info_get_dumpit(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(msg, cb, devlink_nl_info_get_dump_one);\n}\n\nstatic int devlink_nl_flash_update_fill(struct sk_buff *msg,\n\t\t\t\t\tstruct devlink *devlink,\n\t\t\t\t\tenum devlink_command cmd,\n\t\t\t\t\tstruct devlink_flash_notify *params)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, 0, 0, &devlink_nl_family, 0, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\n\tif (cmd != DEVLINK_CMD_FLASH_UPDATE_STATUS)\n\t\tgoto out;\n\n\tif (params->status_msg &&\n\t    nla_put_string(msg, DEVLINK_ATTR_FLASH_UPDATE_STATUS_MSG,\n\t\t\t   params->status_msg))\n\t\tgoto nla_put_failure;\n\tif (params->component &&\n\t    nla_put_string(msg, DEVLINK_ATTR_FLASH_UPDATE_COMPONENT,\n\t\t\t   params->component))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u64_64bit(msg, DEVLINK_ATTR_FLASH_UPDATE_STATUS_DONE,\n\t\t\t      params->done, DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u64_64bit(msg, DEVLINK_ATTR_FLASH_UPDATE_STATUS_TOTAL,\n\t\t\t      params->total, DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u64_64bit(msg, DEVLINK_ATTR_FLASH_UPDATE_STATUS_TIMEOUT,\n\t\t\t      params->timeout, DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\nout:\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic void __devlink_flash_update_notify(struct devlink *devlink,\n\t\t\t\t\t  enum devlink_command cmd,\n\t\t\t\t\t  struct devlink_flash_notify *params)\n{\n\tstruct sk_buff *msg;\n\tint err;\n\n\tWARN_ON(cmd != DEVLINK_CMD_FLASH_UPDATE &&\n\t\tcmd != DEVLINK_CMD_FLASH_UPDATE_END &&\n\t\tcmd != DEVLINK_CMD_FLASH_UPDATE_STATUS);\n\n\tif (!xa_get_mark(&devlinks, devlink->index, DEVLINK_REGISTERED))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\terr = devlink_nl_flash_update_fill(msg, devlink, cmd, params);\n\tif (err)\n\t\tgoto out_free_msg;\n\n\tgenlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink),\n\t\t\t\tmsg, 0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);\n\treturn;\n\nout_free_msg:\n\tnlmsg_free(msg);\n}\n\nstatic void devlink_flash_update_begin_notify(struct devlink *devlink)\n{\n\tstruct devlink_flash_notify params = {};\n\n\t__devlink_flash_update_notify(devlink,\n\t\t\t\t      DEVLINK_CMD_FLASH_UPDATE,\n\t\t\t\t      &params);\n}\n\nstatic void devlink_flash_update_end_notify(struct devlink *devlink)\n{\n\tstruct devlink_flash_notify params = {};\n\n\t__devlink_flash_update_notify(devlink,\n\t\t\t\t      DEVLINK_CMD_FLASH_UPDATE_END,\n\t\t\t\t      &params);\n}\n\nvoid devlink_flash_update_status_notify(struct devlink *devlink,\n\t\t\t\t\tconst char *status_msg,\n\t\t\t\t\tconst char *component,\n\t\t\t\t\tunsigned long done,\n\t\t\t\t\tunsigned long total)\n{\n\tstruct devlink_flash_notify params = {\n\t\t.status_msg = status_msg,\n\t\t.component = component,\n\t\t.done = done,\n\t\t.total = total,\n\t};\n\n\t__devlink_flash_update_notify(devlink,\n\t\t\t\t      DEVLINK_CMD_FLASH_UPDATE_STATUS,\n\t\t\t\t      &params);\n}\nEXPORT_SYMBOL_GPL(devlink_flash_update_status_notify);\n\nvoid devlink_flash_update_timeout_notify(struct devlink *devlink,\n\t\t\t\t\t const char *status_msg,\n\t\t\t\t\t const char *component,\n\t\t\t\t\t unsigned long timeout)\n{\n\tstruct devlink_flash_notify params = {\n\t\t.status_msg = status_msg,\n\t\t.component = component,\n\t\t.timeout = timeout,\n\t};\n\n\t__devlink_flash_update_notify(devlink,\n\t\t\t\t      DEVLINK_CMD_FLASH_UPDATE_STATUS,\n\t\t\t\t      &params);\n}\nEXPORT_SYMBOL_GPL(devlink_flash_update_timeout_notify);\n\nstruct devlink_flash_component_lookup_ctx {\n\tconst char *lookup_name;\n\tbool lookup_name_found;\n};\n\nstatic void\ndevlink_flash_component_lookup_cb(const char *version_name,\n\t\t\t\t  enum devlink_info_version_type version_type,\n\t\t\t\t  void *version_cb_priv)\n{\n\tstruct devlink_flash_component_lookup_ctx *lookup_ctx = version_cb_priv;\n\n\tif (version_type != DEVLINK_INFO_VERSION_TYPE_COMPONENT ||\n\t    lookup_ctx->lookup_name_found)\n\t\treturn;\n\n\tlookup_ctx->lookup_name_found =\n\t\t!strcmp(lookup_ctx->lookup_name, version_name);\n}\n\nstatic int devlink_flash_component_get(struct devlink *devlink,\n\t\t\t\t       struct nlattr *nla_component,\n\t\t\t\t       const char **p_component,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct devlink_flash_component_lookup_ctx lookup_ctx = {};\n\tstruct devlink_info_req req = {};\n\tconst char *component;\n\tint ret;\n\n\tif (!nla_component)\n\t\treturn 0;\n\n\tcomponent = nla_data(nla_component);\n\n\tif (!devlink->ops->info_get) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla_component,\n\t\t\t\t    \"component update is not supported by this device\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tlookup_ctx.lookup_name = component;\n\treq.version_cb = devlink_flash_component_lookup_cb;\n\treq.version_cb_priv = &lookup_ctx;\n\n\tret = devlink->ops->info_get(devlink, &req, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!lookup_ctx.lookup_name_found) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nla_component,\n\t\t\t\t    \"selected component is not supported by this device\");\n\t\treturn -EINVAL;\n\t}\n\t*p_component = component;\n\treturn 0;\n}\n\nint devlink_nl_cmd_flash_update(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *nla_overwrite_mask, *nla_file_name;\n\tstruct devlink_flash_update_params params = {};\n\tstruct devlink *devlink = info->user_ptr[0];\n\tconst char *file_name;\n\tu32 supported_params;\n\tint ret;\n\n\tif (!devlink->ops->flash_update)\n\t\treturn -EOPNOTSUPP;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_FLASH_UPDATE_FILE_NAME))\n\t\treturn -EINVAL;\n\n\tret = devlink_flash_component_get(devlink,\n\t\t\t\t\t  info->attrs[DEVLINK_ATTR_FLASH_UPDATE_COMPONENT],\n\t\t\t\t\t  &params.component, info->extack);\n\tif (ret)\n\t\treturn ret;\n\n\tsupported_params = devlink->ops->supported_flash_update_params;\n\n\tnla_overwrite_mask = info->attrs[DEVLINK_ATTR_FLASH_UPDATE_OVERWRITE_MASK];\n\tif (nla_overwrite_mask) {\n\t\tstruct nla_bitfield32 sections;\n\n\t\tif (!(supported_params & DEVLINK_SUPPORT_FLASH_UPDATE_OVERWRITE_MASK)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack, nla_overwrite_mask,\n\t\t\t\t\t    \"overwrite settings are not supported by this device\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tsections = nla_get_bitfield32(nla_overwrite_mask);\n\t\tparams.overwrite_mask = sections.value & sections.selector;\n\t}\n\n\tnla_file_name = info->attrs[DEVLINK_ATTR_FLASH_UPDATE_FILE_NAME];\n\tfile_name = nla_data(nla_file_name);\n\tret = request_firmware(&params.fw, file_name, devlink->dev);\n\tif (ret) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, nla_file_name,\n\t\t\t\t    \"failed to locate the requested firmware file\");\n\t\treturn ret;\n\t}\n\n\tdevlink_flash_update_begin_notify(devlink);\n\tret = devlink->ops->flash_update(devlink, &params, info->extack);\n\tdevlink_flash_update_end_notify(devlink);\n\n\trelease_firmware(params.fw);\n\n\treturn ret;\n}\n\nstatic void __devlink_compat_running_version(struct devlink *devlink,\n\t\t\t\t\t     char *buf, size_t len)\n{\n\tstruct devlink_info_req req = {};\n\tconst struct nlattr *nlattr;\n\tstruct sk_buff *msg;\n\tint rem, err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\treq.msg = msg;\n\terr = devlink->ops->info_get(devlink, &req, NULL);\n\tif (err)\n\t\tgoto free_msg;\n\n\tnla_for_each_attr(nlattr, (void *)msg->data, msg->len, rem) {\n\t\tconst struct nlattr *kv;\n\t\tint rem_kv;\n\n\t\tif (nla_type(nlattr) != DEVLINK_ATTR_INFO_VERSION_RUNNING)\n\t\t\tcontinue;\n\n\t\tnla_for_each_nested(kv, nlattr, rem_kv) {\n\t\t\tif (nla_type(kv) != DEVLINK_ATTR_INFO_VERSION_VALUE)\n\t\t\t\tcontinue;\n\n\t\t\tstrlcat(buf, nla_data(kv), len);\n\t\t\tstrlcat(buf, \" \", len);\n\t\t}\n\t}\nfree_msg:\n\tnlmsg_free(msg);\n}\n\nvoid devlink_compat_running_version(struct devlink *devlink,\n\t\t\t\t    char *buf, size_t len)\n{\n\tif (!devlink->ops->info_get)\n\t\treturn;\n\n\tdevl_lock(devlink);\n\tif (devl_is_registered(devlink))\n\t\t__devlink_compat_running_version(devlink, buf, len);\n\tdevl_unlock(devlink);\n}\n\nint devlink_compat_flash_update(struct devlink *devlink, const char *file_name)\n{\n\tstruct devlink_flash_update_params params = {};\n\tint ret;\n\n\tdevl_lock(devlink);\n\tif (!devl_is_registered(devlink)) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!devlink->ops->flash_update) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_unlock;\n\t}\n\n\tret = request_firmware(&params.fw, file_name, devlink->dev);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tdevlink_flash_update_begin_notify(devlink);\n\tret = devlink->ops->flash_update(devlink, &params, NULL);\n\tdevlink_flash_update_end_notify(devlink);\n\n\trelease_firmware(params.fw);\nout_unlock:\n\tdevl_unlock(devlink);\n\n\treturn ret;\n}\n\nstatic int\ndevlink_nl_selftests_fill(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t  u32 portid, u32 seq, int flags,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *selftests;\n\tvoid *hdr;\n\tint err;\n\tint i;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags,\n\t\t\t  DEVLINK_CMD_SELFTESTS_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\terr = -EMSGSIZE;\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto err_cancel_msg;\n\n\tselftests = nla_nest_start(msg, DEVLINK_ATTR_SELFTESTS);\n\tif (!selftests)\n\t\tgoto err_cancel_msg;\n\n\tfor (i = DEVLINK_ATTR_SELFTEST_ID_UNSPEC + 1;\n\t     i <= DEVLINK_ATTR_SELFTEST_ID_MAX; i++) {\n\t\tif (devlink->ops->selftest_check(devlink, i, extack)) {\n\t\t\terr = nla_put_flag(msg, i);\n\t\t\tif (err)\n\t\t\t\tgoto err_cancel_msg;\n\t\t}\n\t}\n\n\tnla_nest_end(msg, selftests);\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nerr_cancel_msg:\n\tgenlmsg_cancel(msg, hdr);\n\treturn err;\n}\n\nint devlink_nl_selftests_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tint err;\n\n\tif (!devlink->ops->selftest_check)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_selftests_fill(msg, devlink, info->snd_portid,\n\t\t\t\t\tinfo->snd_seq, 0, info->extack);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int devlink_nl_selftests_get_dump_one(struct sk_buff *msg,\n\t\t\t\t\t     struct devlink *devlink,\n\t\t\t\t\t     struct netlink_callback *cb,\n\t\t\t\t\t     int flags)\n{\n\tif (!devlink->ops->selftest_check)\n\t\treturn 0;\n\n\treturn devlink_nl_selftests_fill(msg, devlink,\n\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t cb->nlh->nlmsg_seq, flags,\n\t\t\t\t\t cb->extack);\n}\n\nint devlink_nl_selftests_get_dumpit(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb, devlink_nl_selftests_get_dump_one);\n}\n\nstatic int devlink_selftest_result_put(struct sk_buff *skb, unsigned int id,\n\t\t\t\t       enum devlink_selftest_status test_status)\n{\n\tstruct nlattr *result_attr;\n\n\tresult_attr = nla_nest_start(skb, DEVLINK_ATTR_SELFTEST_RESULT);\n\tif (!result_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, DEVLINK_ATTR_SELFTEST_RESULT_ID, id) ||\n\t    nla_put_u8(skb, DEVLINK_ATTR_SELFTEST_RESULT_STATUS,\n\t\t       test_status))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, result_attr);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, result_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy devlink_selftest_nl_policy[DEVLINK_ATTR_SELFTEST_ID_MAX + 1] = {\n\t[DEVLINK_ATTR_SELFTEST_ID_FLASH] = { .type = NLA_FLAG },\n};\n\nint devlink_nl_cmd_selftests_run(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *tb[DEVLINK_ATTR_SELFTEST_ID_MAX + 1];\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct nlattr *attrs, *selftests;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\tint i;\n\n\tif (!devlink->ops->selftest_run || !devlink->ops->selftest_check)\n\t\treturn -EOPNOTSUPP;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_SELFTESTS))\n\t\treturn -EINVAL;\n\n\tattrs = info->attrs[DEVLINK_ATTR_SELFTESTS];\n\n\terr = nla_parse_nested(tb, DEVLINK_ATTR_SELFTEST_ID_MAX, attrs,\n\t\t\t       devlink_selftest_nl_policy, info->extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = -EMSGSIZE;\n\thdr = genlmsg_put(msg, info->snd_portid, info->snd_seq,\n\t\t\t  &devlink_nl_family, 0, DEVLINK_CMD_SELFTESTS_RUN);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto genlmsg_cancel;\n\n\tselftests = nla_nest_start(msg, DEVLINK_ATTR_SELFTESTS);\n\tif (!selftests)\n\t\tgoto genlmsg_cancel;\n\n\tfor (i = DEVLINK_ATTR_SELFTEST_ID_UNSPEC + 1;\n\t     i <= DEVLINK_ATTR_SELFTEST_ID_MAX; i++) {\n\t\tenum devlink_selftest_status test_status;\n\n\t\tif (nla_get_flag(tb[i])) {\n\t\t\tif (!devlink->ops->selftest_check(devlink, i,\n\t\t\t\t\t\t\t  info->extack)) {\n\t\t\t\tif (devlink_selftest_result_put(msg, i,\n\t\t\t\t\t\t\t\tDEVLINK_SELFTEST_STATUS_SKIP))\n\t\t\t\t\tgoto selftests_nest_cancel;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttest_status = devlink->ops->selftest_run(devlink, i,\n\t\t\t\t\t\t\t\t info->extack);\n\t\t\tif (devlink_selftest_result_put(msg, i, test_status))\n\t\t\t\tgoto selftests_nest_cancel;\n\t\t}\n\t}\n\n\tnla_nest_end(msg, selftests);\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nselftests_nest_cancel:\n\tnla_nest_cancel(msg, selftests);\ngenlmsg_cancel:\n\tgenlmsg_cancel(msg, hdr);\nfree_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}