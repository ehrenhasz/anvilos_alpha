{
  "module_name": "resource.c",
  "hash_id": "ec1b2c931a95734f82a4d2ff15a6fbe0b8174a28355c15bf6cf84ebc0516c25c",
  "original_prompt": "Ingested from linux-6.6.14/net/devlink/resource.c",
  "human_readable_source": "\n \n\n#include \"devl_internal.h\"\n\n \nstruct devlink_resource {\n\tconst char *name;\n\tu64 id;\n\tu64 size;\n\tu64 size_new;\n\tbool size_valid;\n\tstruct devlink_resource *parent;\n\tstruct devlink_resource_size_params size_params;\n\tstruct list_head list;\n\tstruct list_head resource_list;\n\tdevlink_resource_occ_get_t *occ_get;\n\tvoid *occ_get_priv;\n};\n\nstatic struct devlink_resource *\ndevlink_resource_find(struct devlink *devlink,\n\t\t      struct devlink_resource *resource, u64 resource_id)\n{\n\tstruct list_head *resource_list;\n\n\tif (resource)\n\t\tresource_list = &resource->resource_list;\n\telse\n\t\tresource_list = &devlink->resource_list;\n\n\tlist_for_each_entry(resource, resource_list, list) {\n\t\tstruct devlink_resource *child_resource;\n\n\t\tif (resource->id == resource_id)\n\t\t\treturn resource;\n\n\t\tchild_resource = devlink_resource_find(devlink, resource,\n\t\t\t\t\t\t       resource_id);\n\t\tif (child_resource)\n\t\t\treturn child_resource;\n\t}\n\treturn NULL;\n}\n\nstatic void\ndevlink_resource_validate_children(struct devlink_resource *resource)\n{\n\tstruct devlink_resource *child_resource;\n\tbool size_valid = true;\n\tu64 parts_size = 0;\n\n\tif (list_empty(&resource->resource_list))\n\t\tgoto out;\n\n\tlist_for_each_entry(child_resource, &resource->resource_list, list)\n\t\tparts_size += child_resource->size_new;\n\n\tif (parts_size > resource->size_new)\n\t\tsize_valid = false;\nout:\n\tresource->size_valid = size_valid;\n}\n\nstatic int\ndevlink_resource_validate_size(struct devlink_resource *resource, u64 size,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tu64 reminder;\n\tint err = 0;\n\n\tif (size > resource->size_params.size_max) {\n\t\tNL_SET_ERR_MSG(extack, \"Size larger than maximum\");\n\t\terr = -EINVAL;\n\t}\n\n\tif (size < resource->size_params.size_min) {\n\t\tNL_SET_ERR_MSG(extack, \"Size smaller than minimum\");\n\t\terr = -EINVAL;\n\t}\n\n\tdiv64_u64_rem(size, resource->size_params.size_granularity, &reminder);\n\tif (reminder) {\n\t\tNL_SET_ERR_MSG(extack, \"Wrong granularity\");\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nint devlink_nl_cmd_resource_set(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_resource *resource;\n\tu64 resource_id;\n\tu64 size;\n\tint err;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_RESOURCE_ID) ||\n\t    GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_RESOURCE_SIZE))\n\t\treturn -EINVAL;\n\tresource_id = nla_get_u64(info->attrs[DEVLINK_ATTR_RESOURCE_ID]);\n\n\tresource = devlink_resource_find(devlink, NULL, resource_id);\n\tif (!resource)\n\t\treturn -EINVAL;\n\n\tsize = nla_get_u64(info->attrs[DEVLINK_ATTR_RESOURCE_SIZE]);\n\terr = devlink_resource_validate_size(resource, size, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tresource->size_new = size;\n\tdevlink_resource_validate_children(resource);\n\tif (resource->parent)\n\t\tdevlink_resource_validate_children(resource->parent);\n\treturn 0;\n}\n\nstatic int\ndevlink_resource_size_params_put(struct devlink_resource *resource,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct devlink_resource_size_params *size_params;\n\n\tsize_params = &resource->size_params;\n\tif (nla_put_u64_64bit(skb, DEVLINK_ATTR_RESOURCE_SIZE_GRAN,\n\t\t\t      size_params->size_granularity, DEVLINK_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, DEVLINK_ATTR_RESOURCE_SIZE_MAX,\n\t\t\t      size_params->size_max, DEVLINK_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, DEVLINK_ATTR_RESOURCE_SIZE_MIN,\n\t\t\t      size_params->size_min, DEVLINK_ATTR_PAD) ||\n\t    nla_put_u8(skb, DEVLINK_ATTR_RESOURCE_UNIT, size_params->unit))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic int devlink_resource_occ_put(struct devlink_resource *resource,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tif (!resource->occ_get)\n\t\treturn 0;\n\treturn nla_put_u64_64bit(skb, DEVLINK_ATTR_RESOURCE_OCC,\n\t\t\t\t resource->occ_get(resource->occ_get_priv),\n\t\t\t\t DEVLINK_ATTR_PAD);\n}\n\nstatic int devlink_resource_put(struct devlink *devlink, struct sk_buff *skb,\n\t\t\t\tstruct devlink_resource *resource)\n{\n\tstruct devlink_resource *child_resource;\n\tstruct nlattr *child_resource_attr;\n\tstruct nlattr *resource_attr;\n\n\tresource_attr = nla_nest_start_noflag(skb, DEVLINK_ATTR_RESOURCE);\n\tif (!resource_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(skb, DEVLINK_ATTR_RESOURCE_NAME, resource->name) ||\n\t    nla_put_u64_64bit(skb, DEVLINK_ATTR_RESOURCE_SIZE, resource->size,\n\t\t\t      DEVLINK_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, DEVLINK_ATTR_RESOURCE_ID, resource->id,\n\t\t\t      DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\tif (resource->size != resource->size_new &&\n\t    nla_put_u64_64bit(skb, DEVLINK_ATTR_RESOURCE_SIZE_NEW,\n\t\t\t      resource->size_new, DEVLINK_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\tif (devlink_resource_occ_put(resource, skb))\n\t\tgoto nla_put_failure;\n\tif (devlink_resource_size_params_put(resource, skb))\n\t\tgoto nla_put_failure;\n\tif (list_empty(&resource->resource_list))\n\t\tgoto out;\n\n\tif (nla_put_u8(skb, DEVLINK_ATTR_RESOURCE_SIZE_VALID,\n\t\t       resource->size_valid))\n\t\tgoto nla_put_failure;\n\n\tchild_resource_attr = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t    DEVLINK_ATTR_RESOURCE_LIST);\n\tif (!child_resource_attr)\n\t\tgoto nla_put_failure;\n\n\tlist_for_each_entry(child_resource, &resource->resource_list, list) {\n\t\tif (devlink_resource_put(devlink, skb, child_resource))\n\t\t\tgoto resource_put_failure;\n\t}\n\n\tnla_nest_end(skb, child_resource_attr);\nout:\n\tnla_nest_end(skb, resource_attr);\n\treturn 0;\n\nresource_put_failure:\n\tnla_nest_cancel(skb, child_resource_attr);\nnla_put_failure:\n\tnla_nest_cancel(skb, resource_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int devlink_resource_fill(struct genl_info *info,\n\t\t\t\t enum devlink_command cmd, int flags)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_resource *resource;\n\tstruct nlattr *resources_attr;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tbool incomplete;\n\tvoid *hdr;\n\tint i;\n\tint err;\n\n\tresource = list_first_entry(&devlink->resource_list,\n\t\t\t\t    struct devlink_resource, list);\nstart_again:\n\terr = devlink_nl_msg_reply_and_new(&skb, info);\n\tif (err)\n\t\treturn err;\n\n\thdr = genlmsg_put(skb, info->snd_portid, info->snd_seq,\n\t\t\t  &devlink_nl_family, NLM_F_MULTI, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (devlink_nl_put_handle(skb, devlink))\n\t\tgoto nla_put_failure;\n\n\tresources_attr = nla_nest_start_noflag(skb,\n\t\t\t\t\t       DEVLINK_ATTR_RESOURCE_LIST);\n\tif (!resources_attr)\n\t\tgoto nla_put_failure;\n\n\tincomplete = false;\n\ti = 0;\n\tlist_for_each_entry_from(resource, &devlink->resource_list, list) {\n\t\terr = devlink_resource_put(devlink, skb, resource);\n\t\tif (err) {\n\t\t\tif (!i)\n\t\t\t\tgoto err_resource_put;\n\t\t\tincomplete = true;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tnla_nest_end(skb, resources_attr);\n\tgenlmsg_end(skb, hdr);\n\tif (incomplete)\n\t\tgoto start_again;\nsend_done:\n\tnlh = nlmsg_put(skb, info->snd_portid, info->snd_seq,\n\t\t\tNLMSG_DONE, 0, flags | NLM_F_MULTI);\n\tif (!nlh) {\n\t\terr = devlink_nl_msg_reply_and_new(&skb, info);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto send_done;\n\t}\n\treturn genlmsg_reply(skb, info);\n\nnla_put_failure:\n\terr = -EMSGSIZE;\nerr_resource_put:\n\tnlmsg_free(skb);\n\treturn err;\n}\n\nint devlink_nl_cmd_resource_dump(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\n\tif (list_empty(&devlink->resource_list))\n\t\treturn -EOPNOTSUPP;\n\n\treturn devlink_resource_fill(info, DEVLINK_CMD_RESOURCE_DUMP, 0);\n}\n\nint devlink_resources_validate(struct devlink *devlink,\n\t\t\t       struct devlink_resource *resource,\n\t\t\t       struct genl_info *info)\n{\n\tstruct list_head *resource_list;\n\tint err = 0;\n\n\tif (resource)\n\t\tresource_list = &resource->resource_list;\n\telse\n\t\tresource_list = &devlink->resource_list;\n\n\tlist_for_each_entry(resource, resource_list, list) {\n\t\tif (!resource->size_valid)\n\t\t\treturn -EINVAL;\n\t\terr = devlink_resources_validate(devlink, resource, info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn err;\n}\n\n \nint devl_resource_register(struct devlink *devlink,\n\t\t\t   const char *resource_name,\n\t\t\t   u64 resource_size,\n\t\t\t   u64 resource_id,\n\t\t\t   u64 parent_resource_id,\n\t\t\t   const struct devlink_resource_size_params *size_params)\n{\n\tstruct devlink_resource *resource;\n\tstruct list_head *resource_list;\n\tbool top_hierarchy;\n\n\tlockdep_assert_held(&devlink->lock);\n\n\ttop_hierarchy = parent_resource_id == DEVLINK_RESOURCE_ID_PARENT_TOP;\n\n\tresource = devlink_resource_find(devlink, NULL, resource_id);\n\tif (resource)\n\t\treturn -EINVAL;\n\n\tresource = kzalloc(sizeof(*resource), GFP_KERNEL);\n\tif (!resource)\n\t\treturn -ENOMEM;\n\n\tif (top_hierarchy) {\n\t\tresource_list = &devlink->resource_list;\n\t} else {\n\t\tstruct devlink_resource *parent_resource;\n\n\t\tparent_resource = devlink_resource_find(devlink, NULL,\n\t\t\t\t\t\t\tparent_resource_id);\n\t\tif (parent_resource) {\n\t\t\tresource_list = &parent_resource->resource_list;\n\t\t\tresource->parent = parent_resource;\n\t\t} else {\n\t\t\tkfree(resource);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tresource->name = resource_name;\n\tresource->size = resource_size;\n\tresource->size_new = resource_size;\n\tresource->id = resource_id;\n\tresource->size_valid = true;\n\tmemcpy(&resource->size_params, size_params,\n\t       sizeof(resource->size_params));\n\tINIT_LIST_HEAD(&resource->resource_list);\n\tlist_add_tail(&resource->list, resource_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devl_resource_register);\n\n \nint devlink_resource_register(struct devlink *devlink,\n\t\t\t      const char *resource_name,\n\t\t\t      u64 resource_size,\n\t\t\t      u64 resource_id,\n\t\t\t      u64 parent_resource_id,\n\t\t\t      const struct devlink_resource_size_params *size_params)\n{\n\tint err;\n\n\tdevl_lock(devlink);\n\terr = devl_resource_register(devlink, resource_name, resource_size,\n\t\t\t\t     resource_id, parent_resource_id, size_params);\n\tdevl_unlock(devlink);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(devlink_resource_register);\n\nstatic void devlink_resource_unregister(struct devlink *devlink,\n\t\t\t\t\tstruct devlink_resource *resource)\n{\n\tstruct devlink_resource *tmp, *child_resource;\n\n\tlist_for_each_entry_safe(child_resource, tmp, &resource->resource_list,\n\t\t\t\t list) {\n\t\tdevlink_resource_unregister(devlink, child_resource);\n\t\tlist_del(&child_resource->list);\n\t\tkfree(child_resource);\n\t}\n}\n\n \nvoid devl_resources_unregister(struct devlink *devlink)\n{\n\tstruct devlink_resource *tmp, *child_resource;\n\n\tlockdep_assert_held(&devlink->lock);\n\n\tlist_for_each_entry_safe(child_resource, tmp, &devlink->resource_list,\n\t\t\t\t list) {\n\t\tdevlink_resource_unregister(devlink, child_resource);\n\t\tlist_del(&child_resource->list);\n\t\tkfree(child_resource);\n\t}\n}\nEXPORT_SYMBOL_GPL(devl_resources_unregister);\n\n \nvoid devlink_resources_unregister(struct devlink *devlink)\n{\n\tdevl_lock(devlink);\n\tdevl_resources_unregister(devlink);\n\tdevl_unlock(devlink);\n}\nEXPORT_SYMBOL_GPL(devlink_resources_unregister);\n\n \nint devl_resource_size_get(struct devlink *devlink,\n\t\t\t   u64 resource_id,\n\t\t\t   u64 *p_resource_size)\n{\n\tstruct devlink_resource *resource;\n\n\tlockdep_assert_held(&devlink->lock);\n\n\tresource = devlink_resource_find(devlink, NULL, resource_id);\n\tif (!resource)\n\t\treturn -EINVAL;\n\t*p_resource_size = resource->size_new;\n\tresource->size = resource->size_new;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devl_resource_size_get);\n\n \nvoid devl_resource_occ_get_register(struct devlink *devlink,\n\t\t\t\t    u64 resource_id,\n\t\t\t\t    devlink_resource_occ_get_t *occ_get,\n\t\t\t\t    void *occ_get_priv)\n{\n\tstruct devlink_resource *resource;\n\n\tlockdep_assert_held(&devlink->lock);\n\n\tresource = devlink_resource_find(devlink, NULL, resource_id);\n\tif (WARN_ON(!resource))\n\t\treturn;\n\tWARN_ON(resource->occ_get);\n\n\tresource->occ_get = occ_get;\n\tresource->occ_get_priv = occ_get_priv;\n}\nEXPORT_SYMBOL_GPL(devl_resource_occ_get_register);\n\n \nvoid devlink_resource_occ_get_register(struct devlink *devlink,\n\t\t\t\t       u64 resource_id,\n\t\t\t\t       devlink_resource_occ_get_t *occ_get,\n\t\t\t\t       void *occ_get_priv)\n{\n\tdevl_lock(devlink);\n\tdevl_resource_occ_get_register(devlink, resource_id,\n\t\t\t\t       occ_get, occ_get_priv);\n\tdevl_unlock(devlink);\n}\nEXPORT_SYMBOL_GPL(devlink_resource_occ_get_register);\n\n \nvoid devl_resource_occ_get_unregister(struct devlink *devlink,\n\t\t\t\t      u64 resource_id)\n{\n\tstruct devlink_resource *resource;\n\n\tlockdep_assert_held(&devlink->lock);\n\n\tresource = devlink_resource_find(devlink, NULL, resource_id);\n\tif (WARN_ON(!resource))\n\t\treturn;\n\tWARN_ON(!resource->occ_get);\n\n\tresource->occ_get = NULL;\n\tresource->occ_get_priv = NULL;\n}\nEXPORT_SYMBOL_GPL(devl_resource_occ_get_unregister);\n\n \nvoid devlink_resource_occ_get_unregister(struct devlink *devlink,\n\t\t\t\t\t u64 resource_id)\n{\n\tdevl_lock(devlink);\n\tdevl_resource_occ_get_unregister(devlink, resource_id);\n\tdevl_unlock(devlink);\n}\nEXPORT_SYMBOL_GPL(devlink_resource_occ_get_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}