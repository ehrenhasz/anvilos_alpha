{
  "module_name": "linecard.c",
  "hash_id": "7689b7ac1a1b7e5a5491fa45defcb7bfd9010eb78bcc661596fe5802f4678f63",
  "original_prompt": "Ingested from linux-6.6.14/net/devlink/linecard.c",
  "human_readable_source": "\n \n\n#include \"devl_internal.h\"\n\nstatic struct devlink_linecard *\ndevlink_linecard_get_by_index(struct devlink *devlink,\n\t\t\t      unsigned int linecard_index)\n{\n\tstruct devlink_linecard *devlink_linecard;\n\n\tlist_for_each_entry(devlink_linecard, &devlink->linecard_list, list) {\n\t\tif (devlink_linecard->index == linecard_index)\n\t\t\treturn devlink_linecard;\n\t}\n\treturn NULL;\n}\n\nstatic bool devlink_linecard_index_exists(struct devlink *devlink,\n\t\t\t\t\t  unsigned int linecard_index)\n{\n\treturn devlink_linecard_get_by_index(devlink, linecard_index);\n}\n\nstatic struct devlink_linecard *\ndevlink_linecard_get_from_attrs(struct devlink *devlink, struct nlattr **attrs)\n{\n\tif (attrs[DEVLINK_ATTR_LINECARD_INDEX]) {\n\t\tu32 linecard_index = nla_get_u32(attrs[DEVLINK_ATTR_LINECARD_INDEX]);\n\t\tstruct devlink_linecard *linecard;\n\n\t\tlinecard = devlink_linecard_get_by_index(devlink, linecard_index);\n\t\tif (!linecard)\n\t\t\treturn ERR_PTR(-ENODEV);\n\t\treturn linecard;\n\t}\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct devlink_linecard *\ndevlink_linecard_get_from_info(struct devlink *devlink, struct genl_info *info)\n{\n\treturn devlink_linecard_get_from_attrs(devlink, info->attrs);\n}\n\nstatic int devlink_nl_put_nested_handle(struct sk_buff *msg, struct devlink *devlink)\n{\n\tstruct nlattr *nested_attr;\n\n\tnested_attr = nla_nest_start(msg, DEVLINK_ATTR_NESTED_DEVLINK);\n\tif (!nested_attr)\n\t\treturn -EMSGSIZE;\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, nested_attr);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(msg, nested_attr);\n\treturn -EMSGSIZE;\n}\n\nstruct devlink_linecard_type {\n\tconst char *type;\n\tconst void *priv;\n};\n\nstatic int devlink_nl_linecard_fill(struct sk_buff *msg,\n\t\t\t\t    struct devlink *devlink,\n\t\t\t\t    struct devlink_linecard *linecard,\n\t\t\t\t    enum devlink_command cmd, u32 portid,\n\t\t\t\t    u32 seq, int flags,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct devlink_linecard_type *linecard_type;\n\tstruct nlattr *attr;\n\tvoid *hdr;\n\tint i;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_LINECARD_INDEX, linecard->index))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(msg, DEVLINK_ATTR_LINECARD_STATE, linecard->state))\n\t\tgoto nla_put_failure;\n\tif (linecard->type &&\n\t    nla_put_string(msg, DEVLINK_ATTR_LINECARD_TYPE, linecard->type))\n\t\tgoto nla_put_failure;\n\n\tif (linecard->types_count) {\n\t\tattr = nla_nest_start(msg,\n\t\t\t\t      DEVLINK_ATTR_LINECARD_SUPPORTED_TYPES);\n\t\tif (!attr)\n\t\t\tgoto nla_put_failure;\n\t\tfor (i = 0; i < linecard->types_count; i++) {\n\t\t\tlinecard_type = &linecard->types[i];\n\t\t\tif (nla_put_string(msg, DEVLINK_ATTR_LINECARD_TYPE,\n\t\t\t\t\t   linecard_type->type)) {\n\t\t\t\tnla_nest_cancel(msg, attr);\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\t\tnla_nest_end(msg, attr);\n\t}\n\n\tif (linecard->nested_devlink &&\n\t    devlink_nl_put_nested_handle(msg, linecard->nested_devlink))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic void devlink_linecard_notify(struct devlink_linecard *linecard,\n\t\t\t\t    enum devlink_command cmd)\n{\n\tstruct devlink *devlink = linecard->devlink;\n\tstruct sk_buff *msg;\n\tint err;\n\n\tWARN_ON(cmd != DEVLINK_CMD_LINECARD_NEW &&\n\t\tcmd != DEVLINK_CMD_LINECARD_DEL);\n\n\tif (!xa_get_mark(&devlinks, devlink->index, DEVLINK_REGISTERED))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\terr = devlink_nl_linecard_fill(msg, devlink, linecard, cmd, 0, 0, 0,\n\t\t\t\t       NULL);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&devlink_nl_family, devlink_net(devlink),\n\t\t\t\tmsg, 0, DEVLINK_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nvoid devlink_linecards_notify_register(struct devlink *devlink)\n{\n\tstruct devlink_linecard *linecard;\n\n\tlist_for_each_entry(linecard, &devlink->linecard_list, list)\n\t\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n}\n\nvoid devlink_linecards_notify_unregister(struct devlink *devlink)\n{\n\tstruct devlink_linecard *linecard;\n\n\tlist_for_each_entry_reverse(linecard, &devlink->linecard_list, list)\n\t\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_DEL);\n}\n\nint devlink_nl_linecard_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_linecard *linecard;\n\tstruct sk_buff *msg;\n\tint err;\n\n\tlinecard = devlink_linecard_get_from_info(devlink, info);\n\tif (IS_ERR(linecard))\n\t\treturn PTR_ERR(linecard);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&linecard->state_lock);\n\terr = devlink_nl_linecard_fill(msg, devlink, linecard,\n\t\t\t\t       DEVLINK_CMD_LINECARD_NEW,\n\t\t\t\t       info->snd_portid, info->snd_seq, 0,\n\t\t\t\t       info->extack);\n\tmutex_unlock(&linecard->state_lock);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int devlink_nl_linecard_get_dump_one(struct sk_buff *msg,\n\t\t\t\t\t    struct devlink *devlink,\n\t\t\t\t\t    struct netlink_callback *cb,\n\t\t\t\t\t    int flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct devlink_linecard *linecard;\n\tint idx = 0;\n\tint err = 0;\n\n\tlist_for_each_entry(linecard, &devlink->linecard_list, list) {\n\t\tif (idx < state->idx) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_lock(&linecard->state_lock);\n\t\terr = devlink_nl_linecard_fill(msg, devlink, linecard,\n\t\t\t\t\t       DEVLINK_CMD_LINECARD_NEW,\n\t\t\t\t\t       NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, flags,\n\t\t\t\t\t       cb->extack);\n\t\tmutex_unlock(&linecard->state_lock);\n\t\tif (err) {\n\t\t\tstate->idx = idx;\n\t\t\tbreak;\n\t\t}\n\t\tidx++;\n\t}\n\n\treturn err;\n}\n\nint devlink_nl_linecard_get_dumpit(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb, devlink_nl_linecard_get_dump_one);\n}\n\nstatic struct devlink_linecard_type *\ndevlink_linecard_type_lookup(struct devlink_linecard *linecard,\n\t\t\t     const char *type)\n{\n\tstruct devlink_linecard_type *linecard_type;\n\tint i;\n\n\tfor (i = 0; i < linecard->types_count; i++) {\n\t\tlinecard_type = &linecard->types[i];\n\t\tif (!strcmp(type, linecard_type->type))\n\t\t\treturn linecard_type;\n\t}\n\treturn NULL;\n}\n\nstatic int devlink_linecard_type_set(struct devlink_linecard *linecard,\n\t\t\t\t     const char *type,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tconst struct devlink_linecard_ops *ops = linecard->ops;\n\tstruct devlink_linecard_type *linecard_type;\n\tint err;\n\n\tmutex_lock(&linecard->state_lock);\n\tif (linecard->state == DEVLINK_LINECARD_STATE_PROVISIONING) {\n\t\tNL_SET_ERR_MSG(extack, \"Line card is currently being provisioned\");\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (linecard->state == DEVLINK_LINECARD_STATE_UNPROVISIONING) {\n\t\tNL_SET_ERR_MSG(extack, \"Line card is currently being unprovisioned\");\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tlinecard_type = devlink_linecard_type_lookup(linecard, type);\n\tif (!linecard_type) {\n\t\tNL_SET_ERR_MSG(extack, \"Unsupported line card type provided\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (linecard->state != DEVLINK_LINECARD_STATE_UNPROVISIONED &&\n\t    linecard->state != DEVLINK_LINECARD_STATE_PROVISIONING_FAILED) {\n\t\tNL_SET_ERR_MSG(extack, \"Line card already provisioned\");\n\t\terr = -EBUSY;\n\t\t \n\t\tif (ops->same_provision &&\n\t\t    ops->same_provision(linecard, linecard->priv,\n\t\t\t\t\tlinecard_type->type,\n\t\t\t\t\tlinecard_type->priv))\n\t\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tlinecard->state = DEVLINK_LINECARD_STATE_PROVISIONING;\n\tlinecard->type = linecard_type->type;\n\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n\tmutex_unlock(&linecard->state_lock);\n\terr = ops->provision(linecard, linecard->priv, linecard_type->type,\n\t\t\t     linecard_type->priv, extack);\n\tif (err) {\n\t\t \n\t\tmutex_lock(&linecard->state_lock);\n\t\tlinecard->state = DEVLINK_LINECARD_STATE_UNPROVISIONED;\n\t\tlinecard->type = NULL;\n\t\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n\t\tmutex_unlock(&linecard->state_lock);\n\t}\n\treturn err;\n\nout:\n\tmutex_unlock(&linecard->state_lock);\n\treturn err;\n}\n\nstatic int devlink_linecard_type_unset(struct devlink_linecard *linecard,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tmutex_lock(&linecard->state_lock);\n\tif (linecard->state == DEVLINK_LINECARD_STATE_PROVISIONING) {\n\t\tNL_SET_ERR_MSG(extack, \"Line card is currently being provisioned\");\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (linecard->state == DEVLINK_LINECARD_STATE_UNPROVISIONING) {\n\t\tNL_SET_ERR_MSG(extack, \"Line card is currently being unprovisioned\");\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (linecard->state == DEVLINK_LINECARD_STATE_PROVISIONING_FAILED) {\n\t\tlinecard->state = DEVLINK_LINECARD_STATE_UNPROVISIONED;\n\t\tlinecard->type = NULL;\n\t\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (linecard->state == DEVLINK_LINECARD_STATE_UNPROVISIONED) {\n\t\tNL_SET_ERR_MSG(extack, \"Line card is not provisioned\");\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\tlinecard->state = DEVLINK_LINECARD_STATE_UNPROVISIONING;\n\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n\tmutex_unlock(&linecard->state_lock);\n\terr = linecard->ops->unprovision(linecard, linecard->priv,\n\t\t\t\t\t extack);\n\tif (err) {\n\t\t \n\t\tmutex_lock(&linecard->state_lock);\n\t\tlinecard->state = DEVLINK_LINECARD_STATE_UNPROVISIONED;\n\t\tlinecard->type = NULL;\n\t\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n\t\tmutex_unlock(&linecard->state_lock);\n\t}\n\treturn err;\n\nout:\n\tmutex_unlock(&linecard->state_lock);\n\treturn err;\n}\n\nint devlink_nl_cmd_linecard_set_doit(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_linecard *linecard;\n\tint err;\n\n\tlinecard = devlink_linecard_get_from_info(devlink, info);\n\tif (IS_ERR(linecard))\n\t\treturn PTR_ERR(linecard);\n\n\tif (info->attrs[DEVLINK_ATTR_LINECARD_TYPE]) {\n\t\tconst char *type;\n\n\t\ttype = nla_data(info->attrs[DEVLINK_ATTR_LINECARD_TYPE]);\n\t\tif (strcmp(type, \"\")) {\n\t\t\terr = devlink_linecard_type_set(linecard, type, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\terr = devlink_linecard_type_unset(linecard, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int devlink_linecard_types_init(struct devlink_linecard *linecard)\n{\n\tstruct devlink_linecard_type *linecard_type;\n\tunsigned int count;\n\tint i;\n\n\tcount = linecard->ops->types_count(linecard, linecard->priv);\n\tlinecard->types = kmalloc_array(count, sizeof(*linecard_type),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!linecard->types)\n\t\treturn -ENOMEM;\n\tlinecard->types_count = count;\n\n\tfor (i = 0; i < count; i++) {\n\t\tlinecard_type = &linecard->types[i];\n\t\tlinecard->ops->types_get(linecard, linecard->priv, i,\n\t\t\t\t\t &linecard_type->type,\n\t\t\t\t\t &linecard_type->priv);\n\t}\n\treturn 0;\n}\n\nstatic void devlink_linecard_types_fini(struct devlink_linecard *linecard)\n{\n\tkfree(linecard->types);\n}\n\n \nstruct devlink_linecard *\ndevl_linecard_create(struct devlink *devlink, unsigned int linecard_index,\n\t\t     const struct devlink_linecard_ops *ops, void *priv)\n{\n\tstruct devlink_linecard *linecard;\n\tint err;\n\n\tif (WARN_ON(!ops || !ops->provision || !ops->unprovision ||\n\t\t    !ops->types_count || !ops->types_get))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (devlink_linecard_index_exists(devlink, linecard_index))\n\t\treturn ERR_PTR(-EEXIST);\n\n\tlinecard = kzalloc(sizeof(*linecard), GFP_KERNEL);\n\tif (!linecard)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlinecard->devlink = devlink;\n\tlinecard->index = linecard_index;\n\tlinecard->ops = ops;\n\tlinecard->priv = priv;\n\tlinecard->state = DEVLINK_LINECARD_STATE_UNPROVISIONED;\n\tmutex_init(&linecard->state_lock);\n\n\terr = devlink_linecard_types_init(linecard);\n\tif (err) {\n\t\tmutex_destroy(&linecard->state_lock);\n\t\tkfree(linecard);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlist_add_tail(&linecard->list, &devlink->linecard_list);\n\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n\treturn linecard;\n}\nEXPORT_SYMBOL_GPL(devl_linecard_create);\n\n \nvoid devl_linecard_destroy(struct devlink_linecard *linecard)\n{\n\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_DEL);\n\tlist_del(&linecard->list);\n\tdevlink_linecard_types_fini(linecard);\n\tmutex_destroy(&linecard->state_lock);\n\tkfree(linecard);\n}\nEXPORT_SYMBOL_GPL(devl_linecard_destroy);\n\n \nvoid devlink_linecard_provision_set(struct devlink_linecard *linecard,\n\t\t\t\t    const char *type)\n{\n\tmutex_lock(&linecard->state_lock);\n\tWARN_ON(linecard->type && strcmp(linecard->type, type));\n\tlinecard->state = DEVLINK_LINECARD_STATE_PROVISIONED;\n\tlinecard->type = type;\n\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n\tmutex_unlock(&linecard->state_lock);\n}\nEXPORT_SYMBOL_GPL(devlink_linecard_provision_set);\n\n \nvoid devlink_linecard_provision_clear(struct devlink_linecard *linecard)\n{\n\tmutex_lock(&linecard->state_lock);\n\tWARN_ON(linecard->nested_devlink);\n\tlinecard->state = DEVLINK_LINECARD_STATE_UNPROVISIONED;\n\tlinecard->type = NULL;\n\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n\tmutex_unlock(&linecard->state_lock);\n}\nEXPORT_SYMBOL_GPL(devlink_linecard_provision_clear);\n\n \nvoid devlink_linecard_provision_fail(struct devlink_linecard *linecard)\n{\n\tmutex_lock(&linecard->state_lock);\n\tWARN_ON(linecard->nested_devlink);\n\tlinecard->state = DEVLINK_LINECARD_STATE_PROVISIONING_FAILED;\n\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n\tmutex_unlock(&linecard->state_lock);\n}\nEXPORT_SYMBOL_GPL(devlink_linecard_provision_fail);\n\n \nvoid devlink_linecard_activate(struct devlink_linecard *linecard)\n{\n\tmutex_lock(&linecard->state_lock);\n\tWARN_ON(linecard->state != DEVLINK_LINECARD_STATE_PROVISIONED);\n\tlinecard->state = DEVLINK_LINECARD_STATE_ACTIVE;\n\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n\tmutex_unlock(&linecard->state_lock);\n}\nEXPORT_SYMBOL_GPL(devlink_linecard_activate);\n\n \nvoid devlink_linecard_deactivate(struct devlink_linecard *linecard)\n{\n\tmutex_lock(&linecard->state_lock);\n\tswitch (linecard->state) {\n\tcase DEVLINK_LINECARD_STATE_ACTIVE:\n\t\tlinecard->state = DEVLINK_LINECARD_STATE_PROVISIONED;\n\t\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n\t\tbreak;\n\tcase DEVLINK_LINECARD_STATE_UNPROVISIONING:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\tmutex_unlock(&linecard->state_lock);\n}\nEXPORT_SYMBOL_GPL(devlink_linecard_deactivate);\n\n \nvoid devlink_linecard_nested_dl_set(struct devlink_linecard *linecard,\n\t\t\t\t    struct devlink *nested_devlink)\n{\n\tmutex_lock(&linecard->state_lock);\n\tlinecard->nested_devlink = nested_devlink;\n\tdevlink_linecard_notify(linecard, DEVLINK_CMD_LINECARD_NEW);\n\tmutex_unlock(&linecard->state_lock);\n}\nEXPORT_SYMBOL_GPL(devlink_linecard_nested_dl_set);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}