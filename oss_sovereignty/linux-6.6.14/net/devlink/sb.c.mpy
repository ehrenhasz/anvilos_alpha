{
  "module_name": "sb.c",
  "hash_id": "bdf02e10e57eb393eef3d746d09dd7963e5df8f6de1d16d50baa4423d81ece76",
  "original_prompt": "Ingested from linux-6.6.14/net/devlink/sb.c",
  "human_readable_source": "\n \n\n#include \"devl_internal.h\"\n\nstruct devlink_sb {\n\tstruct list_head list;\n\tunsigned int index;\n\tu32 size;\n\tu16 ingress_pools_count;\n\tu16 egress_pools_count;\n\tu16 ingress_tc_count;\n\tu16 egress_tc_count;\n};\n\nstatic u16 devlink_sb_pool_count(struct devlink_sb *devlink_sb)\n{\n\treturn devlink_sb->ingress_pools_count + devlink_sb->egress_pools_count;\n}\n\nstatic struct devlink_sb *devlink_sb_get_by_index(struct devlink *devlink,\n\t\t\t\t\t\t  unsigned int sb_index)\n{\n\tstruct devlink_sb *devlink_sb;\n\n\tlist_for_each_entry(devlink_sb, &devlink->sb_list, list) {\n\t\tif (devlink_sb->index == sb_index)\n\t\t\treturn devlink_sb;\n\t}\n\treturn NULL;\n}\n\nstatic bool devlink_sb_index_exists(struct devlink *devlink,\n\t\t\t\t    unsigned int sb_index)\n{\n\treturn devlink_sb_get_by_index(devlink, sb_index);\n}\n\nstatic struct devlink_sb *devlink_sb_get_from_attrs(struct devlink *devlink,\n\t\t\t\t\t\t    struct nlattr **attrs)\n{\n\tif (attrs[DEVLINK_ATTR_SB_INDEX]) {\n\t\tu32 sb_index = nla_get_u32(attrs[DEVLINK_ATTR_SB_INDEX]);\n\t\tstruct devlink_sb *devlink_sb;\n\n\t\tdevlink_sb = devlink_sb_get_by_index(devlink, sb_index);\n\t\tif (!devlink_sb)\n\t\t\treturn ERR_PTR(-ENODEV);\n\t\treturn devlink_sb;\n\t}\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic struct devlink_sb *devlink_sb_get_from_info(struct devlink *devlink,\n\t\t\t\t\t\t   struct genl_info *info)\n{\n\treturn devlink_sb_get_from_attrs(devlink, info->attrs);\n}\n\nstatic int devlink_sb_pool_index_get_from_attrs(struct devlink_sb *devlink_sb,\n\t\t\t\t\t\tstruct nlattr **attrs,\n\t\t\t\t\t\tu16 *p_pool_index)\n{\n\tu16 val;\n\n\tif (!attrs[DEVLINK_ATTR_SB_POOL_INDEX])\n\t\treturn -EINVAL;\n\n\tval = nla_get_u16(attrs[DEVLINK_ATTR_SB_POOL_INDEX]);\n\tif (val >= devlink_sb_pool_count(devlink_sb))\n\t\treturn -EINVAL;\n\t*p_pool_index = val;\n\treturn 0;\n}\n\nstatic int devlink_sb_pool_index_get_from_info(struct devlink_sb *devlink_sb,\n\t\t\t\t\t       struct genl_info *info,\n\t\t\t\t\t       u16 *p_pool_index)\n{\n\treturn devlink_sb_pool_index_get_from_attrs(devlink_sb, info->attrs,\n\t\t\t\t\t\t    p_pool_index);\n}\n\nstatic int\ndevlink_sb_pool_type_get_from_attrs(struct nlattr **attrs,\n\t\t\t\t    enum devlink_sb_pool_type *p_pool_type)\n{\n\tu8 val;\n\n\tif (!attrs[DEVLINK_ATTR_SB_POOL_TYPE])\n\t\treturn -EINVAL;\n\n\tval = nla_get_u8(attrs[DEVLINK_ATTR_SB_POOL_TYPE]);\n\tif (val != DEVLINK_SB_POOL_TYPE_INGRESS &&\n\t    val != DEVLINK_SB_POOL_TYPE_EGRESS)\n\t\treturn -EINVAL;\n\t*p_pool_type = val;\n\treturn 0;\n}\n\nstatic int\ndevlink_sb_pool_type_get_from_info(struct genl_info *info,\n\t\t\t\t   enum devlink_sb_pool_type *p_pool_type)\n{\n\treturn devlink_sb_pool_type_get_from_attrs(info->attrs, p_pool_type);\n}\n\nstatic int\ndevlink_sb_th_type_get_from_attrs(struct nlattr **attrs,\n\t\t\t\t  enum devlink_sb_threshold_type *p_th_type)\n{\n\tu8 val;\n\n\tif (!attrs[DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE])\n\t\treturn -EINVAL;\n\n\tval = nla_get_u8(attrs[DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE]);\n\tif (val != DEVLINK_SB_THRESHOLD_TYPE_STATIC &&\n\t    val != DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC)\n\t\treturn -EINVAL;\n\t*p_th_type = val;\n\treturn 0;\n}\n\nstatic int\ndevlink_sb_th_type_get_from_info(struct genl_info *info,\n\t\t\t\t enum devlink_sb_threshold_type *p_th_type)\n{\n\treturn devlink_sb_th_type_get_from_attrs(info->attrs, p_th_type);\n}\n\nstatic int\ndevlink_sb_tc_index_get_from_attrs(struct devlink_sb *devlink_sb,\n\t\t\t\t   struct nlattr **attrs,\n\t\t\t\t   enum devlink_sb_pool_type pool_type,\n\t\t\t\t   u16 *p_tc_index)\n{\n\tu16 val;\n\n\tif (!attrs[DEVLINK_ATTR_SB_TC_INDEX])\n\t\treturn -EINVAL;\n\n\tval = nla_get_u16(attrs[DEVLINK_ATTR_SB_TC_INDEX]);\n\tif (pool_type == DEVLINK_SB_POOL_TYPE_INGRESS &&\n\t    val >= devlink_sb->ingress_tc_count)\n\t\treturn -EINVAL;\n\tif (pool_type == DEVLINK_SB_POOL_TYPE_EGRESS &&\n\t    val >= devlink_sb->egress_tc_count)\n\t\treturn -EINVAL;\n\t*p_tc_index = val;\n\treturn 0;\n}\n\nstatic int\ndevlink_sb_tc_index_get_from_info(struct devlink_sb *devlink_sb,\n\t\t\t\t  struct genl_info *info,\n\t\t\t\t  enum devlink_sb_pool_type pool_type,\n\t\t\t\t  u16 *p_tc_index)\n{\n\treturn devlink_sb_tc_index_get_from_attrs(devlink_sb, info->attrs,\n\t\t\t\t\t\t  pool_type, p_tc_index);\n}\n\nstatic int devlink_nl_sb_fill(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t      struct devlink_sb *devlink_sb,\n\t\t\t      enum devlink_command cmd, u32 portid,\n\t\t\t      u32 seq, int flags)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_INDEX, devlink_sb->index))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_SIZE, devlink_sb->size))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, DEVLINK_ATTR_SB_INGRESS_POOL_COUNT,\n\t\t\tdevlink_sb->ingress_pools_count))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, DEVLINK_ATTR_SB_EGRESS_POOL_COUNT,\n\t\t\tdevlink_sb->egress_pools_count))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, DEVLINK_ATTR_SB_INGRESS_TC_COUNT,\n\t\t\tdevlink_sb->ingress_tc_count))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, DEVLINK_ATTR_SB_EGRESS_TC_COUNT,\n\t\t\tdevlink_sb->egress_tc_count))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nint devlink_nl_sb_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_sb *devlink_sb;\n\tstruct sk_buff *msg;\n\tint err;\n\n\tdevlink_sb = devlink_sb_get_from_info(devlink, info);\n\tif (IS_ERR(devlink_sb))\n\t\treturn PTR_ERR(devlink_sb);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_sb_fill(msg, devlink, devlink_sb,\n\t\t\t\t DEVLINK_CMD_SB_NEW,\n\t\t\t\t info->snd_portid, info->snd_seq, 0);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int\ndevlink_nl_sb_get_dump_one(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t   struct netlink_callback *cb, int flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct devlink_sb *devlink_sb;\n\tint idx = 0;\n\tint err = 0;\n\n\tlist_for_each_entry(devlink_sb, &devlink->sb_list, list) {\n\t\tif (idx < state->idx) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = devlink_nl_sb_fill(msg, devlink, devlink_sb,\n\t\t\t\t\t DEVLINK_CMD_SB_NEW,\n\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t cb->nlh->nlmsg_seq, flags);\n\t\tif (err) {\n\t\t\tstate->idx = idx;\n\t\t\tbreak;\n\t\t}\n\t\tidx++;\n\t}\n\n\treturn err;\n}\n\nint devlink_nl_sb_get_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb, devlink_nl_sb_get_dump_one);\n}\n\nstatic int devlink_nl_sb_pool_fill(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t\t   struct devlink_sb *devlink_sb,\n\t\t\t\t   u16 pool_index, enum devlink_command cmd,\n\t\t\t\t   u32 portid, u32 seq, int flags)\n{\n\tstruct devlink_sb_pool_info pool_info;\n\tvoid *hdr;\n\tint err;\n\n\terr = devlink->ops->sb_pool_get(devlink, devlink_sb->index,\n\t\t\t\t\tpool_index, &pool_info);\n\tif (err)\n\t\treturn err;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_INDEX, devlink_sb->index))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, DEVLINK_ATTR_SB_POOL_INDEX, pool_index))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(msg, DEVLINK_ATTR_SB_POOL_TYPE, pool_info.pool_type))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_POOL_SIZE, pool_info.size))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(msg, DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE,\n\t\t       pool_info.threshold_type))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_POOL_CELL_SIZE,\n\t\t\tpool_info.cell_size))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nint devlink_nl_sb_pool_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_sb *devlink_sb;\n\tstruct sk_buff *msg;\n\tu16 pool_index;\n\tint err;\n\n\tdevlink_sb = devlink_sb_get_from_info(devlink, info);\n\tif (IS_ERR(devlink_sb))\n\t\treturn PTR_ERR(devlink_sb);\n\n\terr = devlink_sb_pool_index_get_from_info(devlink_sb, info,\n\t\t\t\t\t\t  &pool_index);\n\tif (err)\n\t\treturn err;\n\n\tif (!devlink->ops->sb_pool_get)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_sb_pool_fill(msg, devlink, devlink_sb, pool_index,\n\t\t\t\t      DEVLINK_CMD_SB_POOL_NEW,\n\t\t\t\t      info->snd_portid, info->snd_seq, 0);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int __sb_pool_get_dumpit(struct sk_buff *msg, int start, int *p_idx,\n\t\t\t\tstruct devlink *devlink,\n\t\t\t\tstruct devlink_sb *devlink_sb,\n\t\t\t\tu32 portid, u32 seq, int flags)\n{\n\tu16 pool_count = devlink_sb_pool_count(devlink_sb);\n\tu16 pool_index;\n\tint err;\n\n\tfor (pool_index = 0; pool_index < pool_count; pool_index++) {\n\t\tif (*p_idx < start) {\n\t\t\t(*p_idx)++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = devlink_nl_sb_pool_fill(msg, devlink,\n\t\t\t\t\t      devlink_sb,\n\t\t\t\t\t      pool_index,\n\t\t\t\t\t      DEVLINK_CMD_SB_POOL_NEW,\n\t\t\t\t\t      portid, seq, flags);\n\t\tif (err)\n\t\t\treturn err;\n\t\t(*p_idx)++;\n\t}\n\treturn 0;\n}\n\nstatic int\ndevlink_nl_sb_pool_get_dump_one(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t\tstruct netlink_callback *cb, int flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct devlink_sb *devlink_sb;\n\tint err = 0;\n\tint idx = 0;\n\n\tif (!devlink->ops->sb_pool_get)\n\t\treturn 0;\n\n\tlist_for_each_entry(devlink_sb, &devlink->sb_list, list) {\n\t\terr = __sb_pool_get_dumpit(msg, state->idx, &idx,\n\t\t\t\t\t   devlink, devlink_sb,\n\t\t\t\t\t   NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, flags);\n\t\tif (err == -EOPNOTSUPP) {\n\t\t\terr = 0;\n\t\t} else if (err) {\n\t\t\tstate->idx = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint devlink_nl_sb_pool_get_dumpit(struct sk_buff *skb,\n\t\t\t\t  struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb, devlink_nl_sb_pool_get_dump_one);\n}\n\nstatic int devlink_sb_pool_set(struct devlink *devlink, unsigned int sb_index,\n\t\t\t       u16 pool_index, u32 size,\n\t\t\t       enum devlink_sb_threshold_type threshold_type,\n\t\t\t       struct netlink_ext_ack *extack)\n\n{\n\tconst struct devlink_ops *ops = devlink->ops;\n\n\tif (ops->sb_pool_set)\n\t\treturn ops->sb_pool_set(devlink, sb_index, pool_index,\n\t\t\t\t\tsize, threshold_type, extack);\n\treturn -EOPNOTSUPP;\n}\n\nint devlink_nl_cmd_sb_pool_set_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tenum devlink_sb_threshold_type threshold_type;\n\tstruct devlink_sb *devlink_sb;\n\tu16 pool_index;\n\tu32 size;\n\tint err;\n\n\tdevlink_sb = devlink_sb_get_from_info(devlink, info);\n\tif (IS_ERR(devlink_sb))\n\t\treturn PTR_ERR(devlink_sb);\n\n\terr = devlink_sb_pool_index_get_from_info(devlink_sb, info,\n\t\t\t\t\t\t  &pool_index);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_sb_th_type_get_from_info(info, &threshold_type);\n\tif (err)\n\t\treturn err;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_SB_POOL_SIZE))\n\t\treturn -EINVAL;\n\n\tsize = nla_get_u32(info->attrs[DEVLINK_ATTR_SB_POOL_SIZE]);\n\treturn devlink_sb_pool_set(devlink, devlink_sb->index,\n\t\t\t\t   pool_index, size, threshold_type,\n\t\t\t\t   info->extack);\n}\n\nstatic int devlink_nl_sb_port_pool_fill(struct sk_buff *msg,\n\t\t\t\t\tstruct devlink *devlink,\n\t\t\t\t\tstruct devlink_port *devlink_port,\n\t\t\t\t\tstruct devlink_sb *devlink_sb,\n\t\t\t\t\tu16 pool_index,\n\t\t\t\t\tenum devlink_command cmd,\n\t\t\t\t\tu32 portid, u32 seq, int flags)\n{\n\tconst struct devlink_ops *ops = devlink->ops;\n\tu32 threshold;\n\tvoid *hdr;\n\tint err;\n\n\terr = ops->sb_port_pool_get(devlink_port, devlink_sb->index,\n\t\t\t\t    pool_index, &threshold);\n\tif (err)\n\t\treturn err;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_INDEX, devlink_port->index))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_INDEX, devlink_sb->index))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, DEVLINK_ATTR_SB_POOL_INDEX, pool_index))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_THRESHOLD, threshold))\n\t\tgoto nla_put_failure;\n\n\tif (ops->sb_occ_port_pool_get) {\n\t\tu32 cur;\n\t\tu32 max;\n\n\t\terr = ops->sb_occ_port_pool_get(devlink_port, devlink_sb->index,\n\t\t\t\t\t\tpool_index, &cur, &max);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\tgoto sb_occ_get_failure;\n\t\tif (!err) {\n\t\t\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_OCC_CUR, cur))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_OCC_MAX, max))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\terr = -EMSGSIZE;\nsb_occ_get_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn err;\n}\n\nint devlink_nl_sb_port_pool_get_doit(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct devlink_port *devlink_port = info->user_ptr[1];\n\tstruct devlink *devlink = devlink_port->devlink;\n\tstruct devlink_sb *devlink_sb;\n\tstruct sk_buff *msg;\n\tu16 pool_index;\n\tint err;\n\n\tdevlink_sb = devlink_sb_get_from_info(devlink, info);\n\tif (IS_ERR(devlink_sb))\n\t\treturn PTR_ERR(devlink_sb);\n\n\terr = devlink_sb_pool_index_get_from_info(devlink_sb, info,\n\t\t\t\t\t\t  &pool_index);\n\tif (err)\n\t\treturn err;\n\n\tif (!devlink->ops->sb_port_pool_get)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_sb_port_pool_fill(msg, devlink, devlink_port,\n\t\t\t\t\t   devlink_sb, pool_index,\n\t\t\t\t\t   DEVLINK_CMD_SB_PORT_POOL_NEW,\n\t\t\t\t\t   info->snd_portid, info->snd_seq, 0);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int __sb_port_pool_get_dumpit(struct sk_buff *msg, int start, int *p_idx,\n\t\t\t\t     struct devlink *devlink,\n\t\t\t\t     struct devlink_sb *devlink_sb,\n\t\t\t\t     u32 portid, u32 seq, int flags)\n{\n\tstruct devlink_port *devlink_port;\n\tu16 pool_count = devlink_sb_pool_count(devlink_sb);\n\tunsigned long port_index;\n\tu16 pool_index;\n\tint err;\n\n\txa_for_each(&devlink->ports, port_index, devlink_port) {\n\t\tfor (pool_index = 0; pool_index < pool_count; pool_index++) {\n\t\t\tif (*p_idx < start) {\n\t\t\t\t(*p_idx)++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = devlink_nl_sb_port_pool_fill(msg, devlink,\n\t\t\t\t\t\t\t   devlink_port,\n\t\t\t\t\t\t\t   devlink_sb,\n\t\t\t\t\t\t\t   pool_index,\n\t\t\t\t\t\t\t   DEVLINK_CMD_SB_PORT_POOL_NEW,\n\t\t\t\t\t\t\t   portid, seq, flags);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t(*p_idx)++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\ndevlink_nl_sb_port_pool_get_dump_one(struct sk_buff *msg,\n\t\t\t\t     struct devlink *devlink,\n\t\t\t\t     struct netlink_callback *cb, int flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct devlink_sb *devlink_sb;\n\tint idx = 0;\n\tint err = 0;\n\n\tif (!devlink->ops->sb_port_pool_get)\n\t\treturn 0;\n\n\tlist_for_each_entry(devlink_sb, &devlink->sb_list, list) {\n\t\terr = __sb_port_pool_get_dumpit(msg, state->idx, &idx,\n\t\t\t\t\t\tdevlink, devlink_sb,\n\t\t\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\tcb->nlh->nlmsg_seq, flags);\n\t\tif (err == -EOPNOTSUPP) {\n\t\t\terr = 0;\n\t\t} else if (err) {\n\t\t\tstate->idx = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint devlink_nl_sb_port_pool_get_dumpit(struct sk_buff *skb,\n\t\t\t\t       struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb, devlink_nl_sb_port_pool_get_dump_one);\n}\n\nstatic int devlink_sb_port_pool_set(struct devlink_port *devlink_port,\n\t\t\t\t    unsigned int sb_index, u16 pool_index,\n\t\t\t\t    u32 threshold,\n\t\t\t\t    struct netlink_ext_ack *extack)\n\n{\n\tconst struct devlink_ops *ops = devlink_port->devlink->ops;\n\n\tif (ops->sb_port_pool_set)\n\t\treturn ops->sb_port_pool_set(devlink_port, sb_index,\n\t\t\t\t\t     pool_index, threshold, extack);\n\treturn -EOPNOTSUPP;\n}\n\nint devlink_nl_cmd_sb_port_pool_set_doit(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct devlink_port *devlink_port = info->user_ptr[1];\n\tstruct devlink *devlink = info->user_ptr[0];\n\tstruct devlink_sb *devlink_sb;\n\tu16 pool_index;\n\tu32 threshold;\n\tint err;\n\n\tdevlink_sb = devlink_sb_get_from_info(devlink, info);\n\tif (IS_ERR(devlink_sb))\n\t\treturn PTR_ERR(devlink_sb);\n\n\terr = devlink_sb_pool_index_get_from_info(devlink_sb, info,\n\t\t\t\t\t\t  &pool_index);\n\tif (err)\n\t\treturn err;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_SB_THRESHOLD))\n\t\treturn -EINVAL;\n\n\tthreshold = nla_get_u32(info->attrs[DEVLINK_ATTR_SB_THRESHOLD]);\n\treturn devlink_sb_port_pool_set(devlink_port, devlink_sb->index,\n\t\t\t\t\tpool_index, threshold, info->extack);\n}\n\nstatic int\ndevlink_nl_sb_tc_pool_bind_fill(struct sk_buff *msg, struct devlink *devlink,\n\t\t\t\tstruct devlink_port *devlink_port,\n\t\t\t\tstruct devlink_sb *devlink_sb, u16 tc_index,\n\t\t\t\tenum devlink_sb_pool_type pool_type,\n\t\t\t\tenum devlink_command cmd,\n\t\t\t\tu32 portid, u32 seq, int flags)\n{\n\tconst struct devlink_ops *ops = devlink->ops;\n\tu16 pool_index;\n\tu32 threshold;\n\tvoid *hdr;\n\tint err;\n\n\terr = ops->sb_tc_pool_bind_get(devlink_port, devlink_sb->index,\n\t\t\t\t       tc_index, pool_type,\n\t\t\t\t       &pool_index, &threshold);\n\tif (err)\n\t\treturn err;\n\n\thdr = genlmsg_put(msg, portid, seq, &devlink_nl_family, flags, cmd);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (devlink_nl_put_handle(msg, devlink))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_PORT_INDEX, devlink_port->index))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_INDEX, devlink_sb->index))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, DEVLINK_ATTR_SB_TC_INDEX, tc_index))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(msg, DEVLINK_ATTR_SB_POOL_TYPE, pool_type))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, DEVLINK_ATTR_SB_POOL_INDEX, pool_index))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_THRESHOLD, threshold))\n\t\tgoto nla_put_failure;\n\n\tif (ops->sb_occ_tc_port_bind_get) {\n\t\tu32 cur;\n\t\tu32 max;\n\n\t\terr = ops->sb_occ_tc_port_bind_get(devlink_port,\n\t\t\t\t\t\t   devlink_sb->index,\n\t\t\t\t\t\t   tc_index, pool_type,\n\t\t\t\t\t\t   &cur, &max);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t\tif (!err) {\n\t\t\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_OCC_CUR, cur))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, DEVLINK_ATTR_SB_OCC_MAX, max))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nint devlink_nl_sb_tc_pool_bind_get_doit(struct sk_buff *skb,\n\t\t\t\t\tstruct genl_info *info)\n{\n\tstruct devlink_port *devlink_port = info->user_ptr[1];\n\tstruct devlink *devlink = devlink_port->devlink;\n\tstruct devlink_sb *devlink_sb;\n\tstruct sk_buff *msg;\n\tenum devlink_sb_pool_type pool_type;\n\tu16 tc_index;\n\tint err;\n\n\tdevlink_sb = devlink_sb_get_from_info(devlink, info);\n\tif (IS_ERR(devlink_sb))\n\t\treturn PTR_ERR(devlink_sb);\n\n\terr = devlink_sb_pool_type_get_from_info(info, &pool_type);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_sb_tc_index_get_from_info(devlink_sb, info,\n\t\t\t\t\t\tpool_type, &tc_index);\n\tif (err)\n\t\treturn err;\n\n\tif (!devlink->ops->sb_tc_pool_bind_get)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\terr = devlink_nl_sb_tc_pool_bind_fill(msg, devlink, devlink_port,\n\t\t\t\t\t      devlink_sb, tc_index, pool_type,\n\t\t\t\t\t      DEVLINK_CMD_SB_TC_POOL_BIND_NEW,\n\t\t\t\t\t      info->snd_portid,\n\t\t\t\t\t      info->snd_seq, 0);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int __sb_tc_pool_bind_get_dumpit(struct sk_buff *msg,\n\t\t\t\t\tint start, int *p_idx,\n\t\t\t\t\tstruct devlink *devlink,\n\t\t\t\t\tstruct devlink_sb *devlink_sb,\n\t\t\t\t\tu32 portid, u32 seq, int flags)\n{\n\tstruct devlink_port *devlink_port;\n\tunsigned long port_index;\n\tu16 tc_index;\n\tint err;\n\n\txa_for_each(&devlink->ports, port_index, devlink_port) {\n\t\tfor (tc_index = 0;\n\t\t     tc_index < devlink_sb->ingress_tc_count; tc_index++) {\n\t\t\tif (*p_idx < start) {\n\t\t\t\t(*p_idx)++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = devlink_nl_sb_tc_pool_bind_fill(msg, devlink,\n\t\t\t\t\t\t\t      devlink_port,\n\t\t\t\t\t\t\t      devlink_sb,\n\t\t\t\t\t\t\t      tc_index,\n\t\t\t\t\t\t\t      DEVLINK_SB_POOL_TYPE_INGRESS,\n\t\t\t\t\t\t\t      DEVLINK_CMD_SB_TC_POOL_BIND_NEW,\n\t\t\t\t\t\t\t      portid, seq,\n\t\t\t\t\t\t\t      flags);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t(*p_idx)++;\n\t\t}\n\t\tfor (tc_index = 0;\n\t\t     tc_index < devlink_sb->egress_tc_count; tc_index++) {\n\t\t\tif (*p_idx < start) {\n\t\t\t\t(*p_idx)++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = devlink_nl_sb_tc_pool_bind_fill(msg, devlink,\n\t\t\t\t\t\t\t      devlink_port,\n\t\t\t\t\t\t\t      devlink_sb,\n\t\t\t\t\t\t\t      tc_index,\n\t\t\t\t\t\t\t      DEVLINK_SB_POOL_TYPE_EGRESS,\n\t\t\t\t\t\t\t      DEVLINK_CMD_SB_TC_POOL_BIND_NEW,\n\t\t\t\t\t\t\t      portid, seq,\n\t\t\t\t\t\t\t      flags);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\t(*p_idx)++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int devlink_nl_sb_tc_pool_bind_get_dump_one(struct sk_buff *msg,\n\t\t\t\t\t\t   struct devlink *devlink,\n\t\t\t\t\t\t   struct netlink_callback *cb,\n\t\t\t\t\t\t   int flags)\n{\n\tstruct devlink_nl_dump_state *state = devlink_dump_state(cb);\n\tstruct devlink_sb *devlink_sb;\n\tint idx = 0;\n\tint err = 0;\n\n\tif (!devlink->ops->sb_tc_pool_bind_get)\n\t\treturn 0;\n\n\tlist_for_each_entry(devlink_sb, &devlink->sb_list, list) {\n\t\terr = __sb_tc_pool_bind_get_dumpit(msg, state->idx, &idx,\n\t\t\t\t\t\t   devlink, devlink_sb,\n\t\t\t\t\t\t   NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t   cb->nlh->nlmsg_seq, flags);\n\t\tif (err == -EOPNOTSUPP) {\n\t\t\terr = 0;\n\t\t} else if (err) {\n\t\t\tstate->idx = idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint devlink_nl_sb_tc_pool_bind_get_dumpit(struct sk_buff *skb,\n\t\t\t\t\t  struct netlink_callback *cb)\n{\n\treturn devlink_nl_dumpit(skb, cb,\n\t\t\t\t devlink_nl_sb_tc_pool_bind_get_dump_one);\n}\n\nstatic int devlink_sb_tc_pool_bind_set(struct devlink_port *devlink_port,\n\t\t\t\t       unsigned int sb_index, u16 tc_index,\n\t\t\t\t       enum devlink_sb_pool_type pool_type,\n\t\t\t\t       u16 pool_index, u32 threshold,\n\t\t\t\t       struct netlink_ext_ack *extack)\n\n{\n\tconst struct devlink_ops *ops = devlink_port->devlink->ops;\n\n\tif (ops->sb_tc_pool_bind_set)\n\t\treturn ops->sb_tc_pool_bind_set(devlink_port, sb_index,\n\t\t\t\t\t\ttc_index, pool_type,\n\t\t\t\t\t\tpool_index, threshold, extack);\n\treturn -EOPNOTSUPP;\n}\n\nint devlink_nl_cmd_sb_tc_pool_bind_set_doit(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct devlink_port *devlink_port = info->user_ptr[1];\n\tstruct devlink *devlink = info->user_ptr[0];\n\tenum devlink_sb_pool_type pool_type;\n\tstruct devlink_sb *devlink_sb;\n\tu16 tc_index;\n\tu16 pool_index;\n\tu32 threshold;\n\tint err;\n\n\tdevlink_sb = devlink_sb_get_from_info(devlink, info);\n\tif (IS_ERR(devlink_sb))\n\t\treturn PTR_ERR(devlink_sb);\n\n\terr = devlink_sb_pool_type_get_from_info(info, &pool_type);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_sb_tc_index_get_from_info(devlink_sb, info,\n\t\t\t\t\t\tpool_type, &tc_index);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_sb_pool_index_get_from_info(devlink_sb, info,\n\t\t\t\t\t\t  &pool_index);\n\tif (err)\n\t\treturn err;\n\n\tif (GENL_REQ_ATTR_CHECK(info, DEVLINK_ATTR_SB_THRESHOLD))\n\t\treturn -EINVAL;\n\n\tthreshold = nla_get_u32(info->attrs[DEVLINK_ATTR_SB_THRESHOLD]);\n\treturn devlink_sb_tc_pool_bind_set(devlink_port, devlink_sb->index,\n\t\t\t\t\t   tc_index, pool_type,\n\t\t\t\t\t   pool_index, threshold, info->extack);\n}\n\nint devlink_nl_cmd_sb_occ_snapshot_doit(struct sk_buff *skb,\n\t\t\t\t\tstruct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tconst struct devlink_ops *ops = devlink->ops;\n\tstruct devlink_sb *devlink_sb;\n\n\tdevlink_sb = devlink_sb_get_from_info(devlink, info);\n\tif (IS_ERR(devlink_sb))\n\t\treturn PTR_ERR(devlink_sb);\n\n\tif (ops->sb_occ_snapshot)\n\t\treturn ops->sb_occ_snapshot(devlink, devlink_sb->index);\n\treturn -EOPNOTSUPP;\n}\n\nint devlink_nl_cmd_sb_occ_max_clear_doit(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct devlink *devlink = info->user_ptr[0];\n\tconst struct devlink_ops *ops = devlink->ops;\n\tstruct devlink_sb *devlink_sb;\n\n\tdevlink_sb = devlink_sb_get_from_info(devlink, info);\n\tif (IS_ERR(devlink_sb))\n\t\treturn PTR_ERR(devlink_sb);\n\n\tif (ops->sb_occ_max_clear)\n\t\treturn ops->sb_occ_max_clear(devlink, devlink_sb->index);\n\treturn -EOPNOTSUPP;\n}\n\nint devl_sb_register(struct devlink *devlink, unsigned int sb_index,\n\t\t     u32 size, u16 ingress_pools_count,\n\t\t     u16 egress_pools_count, u16 ingress_tc_count,\n\t\t     u16 egress_tc_count)\n{\n\tstruct devlink_sb *devlink_sb;\n\n\tlockdep_assert_held(&devlink->lock);\n\n\tif (devlink_sb_index_exists(devlink, sb_index))\n\t\treturn -EEXIST;\n\n\tdevlink_sb = kzalloc(sizeof(*devlink_sb), GFP_KERNEL);\n\tif (!devlink_sb)\n\t\treturn -ENOMEM;\n\tdevlink_sb->index = sb_index;\n\tdevlink_sb->size = size;\n\tdevlink_sb->ingress_pools_count = ingress_pools_count;\n\tdevlink_sb->egress_pools_count = egress_pools_count;\n\tdevlink_sb->ingress_tc_count = ingress_tc_count;\n\tdevlink_sb->egress_tc_count = egress_tc_count;\n\tlist_add_tail(&devlink_sb->list, &devlink->sb_list);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devl_sb_register);\n\nint devlink_sb_register(struct devlink *devlink, unsigned int sb_index,\n\t\t\tu32 size, u16 ingress_pools_count,\n\t\t\tu16 egress_pools_count, u16 ingress_tc_count,\n\t\t\tu16 egress_tc_count)\n{\n\tint err;\n\n\tdevl_lock(devlink);\n\terr = devl_sb_register(devlink, sb_index, size, ingress_pools_count,\n\t\t\t       egress_pools_count, ingress_tc_count,\n\t\t\t       egress_tc_count);\n\tdevl_unlock(devlink);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(devlink_sb_register);\n\nvoid devl_sb_unregister(struct devlink *devlink, unsigned int sb_index)\n{\n\tstruct devlink_sb *devlink_sb;\n\n\tlockdep_assert_held(&devlink->lock);\n\n\tdevlink_sb = devlink_sb_get_by_index(devlink, sb_index);\n\tWARN_ON(!devlink_sb);\n\tlist_del(&devlink_sb->list);\n\tkfree(devlink_sb);\n}\nEXPORT_SYMBOL_GPL(devl_sb_unregister);\n\nvoid devlink_sb_unregister(struct devlink *devlink, unsigned int sb_index)\n{\n\tdevl_lock(devlink);\n\tdevl_sb_unregister(devlink, sb_index);\n\tdevl_unlock(devlink);\n}\nEXPORT_SYMBOL_GPL(devlink_sb_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}