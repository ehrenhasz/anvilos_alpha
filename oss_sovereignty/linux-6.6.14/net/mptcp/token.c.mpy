{
  "module_name": "token.c",
  "hash_id": "023dda0d9bfa697189940f6b22b5af8a31dc5191f8beb9db6e1af235a829da16",
  "original_prompt": "Ingested from linux-6.6.14/net/mptcp/token.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"MPTCP: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/memblock.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <net/sock.h>\n#include <net/inet_common.h>\n#include <net/protocol.h>\n#include <net/mptcp.h>\n#include \"protocol.h\"\n\n#define TOKEN_MAX_CHAIN_LEN\t4\n\nstruct token_bucket {\n\tspinlock_t\t\tlock;\n\tint\t\t\tchain_len;\n\tstruct hlist_nulls_head\treq_chain;\n\tstruct hlist_nulls_head\tmsk_chain;\n};\n\nstatic struct token_bucket *token_hash __read_mostly;\nstatic unsigned int token_mask __read_mostly;\n\nstatic struct token_bucket *token_bucket(u32 token)\n{\n\treturn &token_hash[token & token_mask];\n}\n\n \nstatic struct mptcp_subflow_request_sock *\n__token_lookup_req(struct token_bucket *t, u32 token)\n{\n\tstruct mptcp_subflow_request_sock *req;\n\tstruct hlist_nulls_node *pos;\n\n\thlist_nulls_for_each_entry_rcu(req, pos, &t->req_chain, token_node)\n\t\tif (req->token == token)\n\t\t\treturn req;\n\treturn NULL;\n}\n\n \nstatic struct mptcp_sock *\n__token_lookup_msk(struct token_bucket *t, u32 token)\n{\n\tstruct hlist_nulls_node *pos;\n\tstruct sock *sk;\n\n\tsk_nulls_for_each_rcu(sk, pos, &t->msk_chain)\n\t\tif (mptcp_sk(sk)->token == token)\n\t\t\treturn mptcp_sk(sk);\n\treturn NULL;\n}\n\nstatic bool __token_bucket_busy(struct token_bucket *t, u32 token)\n{\n\treturn !token || t->chain_len >= TOKEN_MAX_CHAIN_LEN ||\n\t       __token_lookup_req(t, token) || __token_lookup_msk(t, token);\n}\n\nstatic void mptcp_crypto_key_gen_sha(u64 *key, u32 *token, u64 *idsn)\n{\n\t \n\tget_random_bytes(key, sizeof(u64));\n\tmptcp_crypto_key_sha(*key, token, idsn);\n}\n\n \nint mptcp_token_new_request(struct request_sock *req)\n{\n\tstruct mptcp_subflow_request_sock *subflow_req = mptcp_subflow_rsk(req);\n\tstruct token_bucket *bucket;\n\tu32 token;\n\n\tmptcp_crypto_key_sha(subflow_req->local_key,\n\t\t\t     &subflow_req->token,\n\t\t\t     &subflow_req->idsn);\n\tpr_debug(\"req=%p local_key=%llu, token=%u, idsn=%llu\\n\",\n\t\t req, subflow_req->local_key, subflow_req->token,\n\t\t subflow_req->idsn);\n\n\ttoken = subflow_req->token;\n\tbucket = token_bucket(token);\n\tspin_lock_bh(&bucket->lock);\n\tif (__token_bucket_busy(bucket, token)) {\n\t\tspin_unlock_bh(&bucket->lock);\n\t\treturn -EBUSY;\n\t}\n\n\thlist_nulls_add_head_rcu(&subflow_req->token_node, &bucket->req_chain);\n\tbucket->chain_len++;\n\tspin_unlock_bh(&bucket->lock);\n\treturn 0;\n}\n\n \nint mptcp_token_new_connect(struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\tint retries = MPTCP_TOKEN_MAX_RETRIES;\n\tstruct sock *sk = subflow->conn;\n\tstruct token_bucket *bucket;\n\nagain:\n\tmptcp_crypto_key_gen_sha(&subflow->local_key, &subflow->token,\n\t\t\t\t &subflow->idsn);\n\n\tbucket = token_bucket(subflow->token);\n\tspin_lock_bh(&bucket->lock);\n\tif (__token_bucket_busy(bucket, subflow->token)) {\n\t\tspin_unlock_bh(&bucket->lock);\n\t\tif (!--retries)\n\t\t\treturn -EBUSY;\n\t\tgoto again;\n\t}\n\n\tpr_debug(\"ssk=%p, local_key=%llu, token=%u, idsn=%llu\\n\",\n\t\t ssk, subflow->local_key, subflow->token, subflow->idsn);\n\n\tWRITE_ONCE(msk->token, subflow->token);\n\t__sk_nulls_add_node_rcu((struct sock *)msk, &bucket->msk_chain);\n\tbucket->chain_len++;\n\tspin_unlock_bh(&bucket->lock);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\treturn 0;\n}\n\n \nvoid mptcp_token_accept(struct mptcp_subflow_request_sock *req,\n\t\t\tstruct mptcp_sock *msk)\n{\n\tstruct mptcp_subflow_request_sock *pos;\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct token_bucket *bucket;\n\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\tbucket = token_bucket(req->token);\n\tspin_lock_bh(&bucket->lock);\n\n\t \n\tpos = __token_lookup_req(bucket, req->token);\n\tif (!WARN_ON_ONCE(pos != req))\n\t\thlist_nulls_del_init_rcu(&req->token_node);\n\t__sk_nulls_add_node_rcu((struct sock *)msk, &bucket->msk_chain);\n\tspin_unlock_bh(&bucket->lock);\n}\n\nbool mptcp_token_exists(u32 token)\n{\n\tstruct hlist_nulls_node *pos;\n\tstruct token_bucket *bucket;\n\tstruct mptcp_sock *msk;\n\tstruct sock *sk;\n\n\trcu_read_lock();\n\tbucket = token_bucket(token);\n\nagain:\n\tsk_nulls_for_each_rcu(sk, pos, &bucket->msk_chain) {\n\t\tmsk = mptcp_sk(sk);\n\t\tif (READ_ONCE(msk->token) == token)\n\t\t\tgoto found;\n\t}\n\tif (get_nulls_value(pos) != (token & token_mask))\n\t\tgoto again;\n\n\trcu_read_unlock();\n\treturn false;\nfound:\n\trcu_read_unlock();\n\treturn true;\n}\n\n \nstruct mptcp_sock *mptcp_token_get_sock(struct net *net, u32 token)\n{\n\tstruct hlist_nulls_node *pos;\n\tstruct token_bucket *bucket;\n\tstruct mptcp_sock *msk;\n\tstruct sock *sk;\n\n\trcu_read_lock();\n\tbucket = token_bucket(token);\n\nagain:\n\tsk_nulls_for_each_rcu(sk, pos, &bucket->msk_chain) {\n\t\tmsk = mptcp_sk(sk);\n\t\tif (READ_ONCE(msk->token) != token ||\n\t\t    !net_eq(sock_net(sk), net))\n\t\t\tcontinue;\n\n\t\tif (!refcount_inc_not_zero(&sk->sk_refcnt))\n\t\t\tgoto not_found;\n\n\t\tif (READ_ONCE(msk->token) != token ||\n\t\t    !net_eq(sock_net(sk), net)) {\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t\tgoto found;\n\t}\n\tif (get_nulls_value(pos) != (token & token_mask))\n\t\tgoto again;\n\nnot_found:\n\tmsk = NULL;\n\nfound:\n\trcu_read_unlock();\n\treturn msk;\n}\nEXPORT_SYMBOL_GPL(mptcp_token_get_sock);\n\n \nstruct mptcp_sock *mptcp_token_iter_next(const struct net *net, long *s_slot,\n\t\t\t\t\t long *s_num)\n{\n\tstruct mptcp_sock *ret = NULL;\n\tstruct hlist_nulls_node *pos;\n\tint slot, num = 0;\n\n\tfor (slot = *s_slot; slot <= token_mask; *s_num = 0, slot++) {\n\t\tstruct token_bucket *bucket = &token_hash[slot];\n\t\tstruct sock *sk;\n\n\t\tnum = 0;\n\n\t\tif (hlist_nulls_empty(&bucket->msk_chain))\n\t\t\tcontinue;\n\n\t\trcu_read_lock();\n\t\tsk_nulls_for_each_rcu(sk, pos, &bucket->msk_chain) {\n\t\t\t++num;\n\t\t\tif (!net_eq(sock_net(sk), net))\n\t\t\t\tcontinue;\n\n\t\t\tif (num <= *s_num)\n\t\t\t\tcontinue;\n\n\t\t\tif (!refcount_inc_not_zero(&sk->sk_refcnt))\n\t\t\t\tcontinue;\n\n\t\t\tif (!net_eq(sock_net(sk), net)) {\n\t\t\t\tsock_put(sk);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = mptcp_sk(sk);\n\t\t\trcu_read_unlock();\n\t\t\tgoto out;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\nout:\n\t*s_slot = slot;\n\t*s_num = num;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mptcp_token_iter_next);\n\n \nvoid mptcp_token_destroy_request(struct request_sock *req)\n{\n\tstruct mptcp_subflow_request_sock *subflow_req = mptcp_subflow_rsk(req);\n\tstruct mptcp_subflow_request_sock *pos;\n\tstruct token_bucket *bucket;\n\n\tif (hlist_nulls_unhashed(&subflow_req->token_node))\n\t\treturn;\n\n\tbucket = token_bucket(subflow_req->token);\n\tspin_lock_bh(&bucket->lock);\n\tpos = __token_lookup_req(bucket, subflow_req->token);\n\tif (!WARN_ON_ONCE(pos != subflow_req)) {\n\t\thlist_nulls_del_init_rcu(&pos->token_node);\n\t\tbucket->chain_len--;\n\t}\n\tspin_unlock_bh(&bucket->lock);\n}\n\n \nvoid mptcp_token_destroy(struct mptcp_sock *msk)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct token_bucket *bucket;\n\tstruct mptcp_sock *pos;\n\n\tif (sk_unhashed((struct sock *)msk))\n\t\treturn;\n\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tbucket = token_bucket(msk->token);\n\tspin_lock_bh(&bucket->lock);\n\tpos = __token_lookup_msk(bucket, msk->token);\n\tif (!WARN_ON_ONCE(pos != msk)) {\n\t\t__sk_nulls_del_node_init_rcu((struct sock *)pos);\n\t\tbucket->chain_len--;\n\t}\n\tspin_unlock_bh(&bucket->lock);\n\tWRITE_ONCE(msk->token, 0);\n}\n\nvoid __init mptcp_token_init(void)\n{\n\tint i;\n\n\ttoken_hash = alloc_large_system_hash(\"MPTCP token\",\n\t\t\t\t\t     sizeof(struct token_bucket),\n\t\t\t\t\t     0,\n\t\t\t\t\t     20, \n\t\t\t\t\t     HASH_ZERO,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     &token_mask,\n\t\t\t\t\t     0,\n\t\t\t\t\t     64 * 1024);\n\tfor (i = 0; i < token_mask + 1; ++i) {\n\t\tINIT_HLIST_NULLS_HEAD(&token_hash[i].req_chain, i);\n\t\tINIT_HLIST_NULLS_HEAD(&token_hash[i].msk_chain, i);\n\t\tspin_lock_init(&token_hash[i].lock);\n\t}\n}\n\n#if IS_MODULE(CONFIG_MPTCP_KUNIT_TEST)\nEXPORT_SYMBOL_GPL(mptcp_token_new_request);\nEXPORT_SYMBOL_GPL(mptcp_token_new_connect);\nEXPORT_SYMBOL_GPL(mptcp_token_accept);\nEXPORT_SYMBOL_GPL(mptcp_token_destroy_request);\nEXPORT_SYMBOL_GPL(mptcp_token_destroy);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}