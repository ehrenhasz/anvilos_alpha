{
  "module_name": "pm_userspace.c",
  "hash_id": "a400ee0147597fcf01e5a001bde18284104818c50d4664841e6fe3ba04266f1a",
  "original_prompt": "Ingested from linux-6.6.14/net/mptcp/pm_userspace.c",
  "human_readable_source": "\n \n\n#include \"protocol.h\"\n#include \"mib.h\"\n\nvoid mptcp_free_local_addr_list(struct mptcp_sock *msk)\n{\n\tstruct mptcp_pm_addr_entry *entry, *tmp;\n\tstruct sock *sk = (struct sock *)msk;\n\tLIST_HEAD(free_list);\n\n\tif (!mptcp_pm_is_userspace(msk))\n\t\treturn;\n\n\tspin_lock_bh(&msk->pm.lock);\n\tlist_splice_init(&msk->pm.userspace_pm_local_addr_list, &free_list);\n\tspin_unlock_bh(&msk->pm.lock);\n\n\tlist_for_each_entry_safe(entry, tmp, &free_list, list) {\n\t\tsock_kfree_s(sk, entry, sizeof(*entry));\n\t}\n}\n\nstatic int mptcp_userspace_pm_append_new_local_addr(struct mptcp_sock *msk,\n\t\t\t\t\t\t    struct mptcp_pm_addr_entry *entry)\n{\n\tDECLARE_BITMAP(id_bitmap, MPTCP_PM_MAX_ADDR_ID + 1);\n\tstruct mptcp_pm_addr_entry *match = NULL;\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct mptcp_pm_addr_entry *e;\n\tbool addr_match = false;\n\tbool id_match = false;\n\tint ret = -EINVAL;\n\n\tbitmap_zero(id_bitmap, MPTCP_PM_MAX_ADDR_ID + 1);\n\n\tspin_lock_bh(&msk->pm.lock);\n\tlist_for_each_entry(e, &msk->pm.userspace_pm_local_addr_list, list) {\n\t\taddr_match = mptcp_addresses_equal(&e->addr, &entry->addr, true);\n\t\tif (addr_match && entry->addr.id == 0)\n\t\t\tentry->addr.id = e->addr.id;\n\t\tid_match = (e->addr.id == entry->addr.id);\n\t\tif (addr_match && id_match) {\n\t\t\tmatch = e;\n\t\t\tbreak;\n\t\t} else if (addr_match || id_match) {\n\t\t\tbreak;\n\t\t}\n\t\t__set_bit(e->addr.id, id_bitmap);\n\t}\n\n\tif (!match && !addr_match && !id_match) {\n\t\t \n\t\te = sock_kmalloc(sk, sizeof(*e), GFP_ATOMIC);\n\t\tif (!e) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto append_err;\n\t\t}\n\n\t\t*e = *entry;\n\t\tif (!e->addr.id)\n\t\t\te->addr.id = find_next_zero_bit(id_bitmap,\n\t\t\t\t\t\t\tMPTCP_PM_MAX_ADDR_ID + 1,\n\t\t\t\t\t\t\t1);\n\t\tlist_add_tail_rcu(&e->list, &msk->pm.userspace_pm_local_addr_list);\n\t\tmsk->pm.local_addr_used++;\n\t\tret = e->addr.id;\n\t} else if (match) {\n\t\tret = entry->addr.id;\n\t}\n\nappend_err:\n\tspin_unlock_bh(&msk->pm.lock);\n\treturn ret;\n}\n\n \nstatic int mptcp_userspace_pm_delete_local_addr(struct mptcp_sock *msk,\n\t\t\t\t\t\tstruct mptcp_pm_addr_entry *addr)\n{\n\tstruct mptcp_pm_addr_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &msk->pm.userspace_pm_local_addr_list, list) {\n\t\tif (mptcp_addresses_equal(&entry->addr, &addr->addr, false)) {\n\t\t\t \n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tkfree(entry);\n\t\t\tmsk->pm.local_addr_used--;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nint mptcp_userspace_pm_get_flags_and_ifindex_by_id(struct mptcp_sock *msk,\n\t\t\t\t\t\t   unsigned int id,\n\t\t\t\t\t\t   u8 *flags, int *ifindex)\n{\n\tstruct mptcp_pm_addr_entry *entry, *match = NULL;\n\n\tspin_lock_bh(&msk->pm.lock);\n\tlist_for_each_entry(entry, &msk->pm.userspace_pm_local_addr_list, list) {\n\t\tif (id == entry->addr.id) {\n\t\t\tmatch = entry;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&msk->pm.lock);\n\tif (match) {\n\t\t*flags = match->flags;\n\t\t*ifindex = match->ifindex;\n\t}\n\n\treturn 0;\n}\n\nint mptcp_userspace_pm_get_local_id(struct mptcp_sock *msk,\n\t\t\t\t    struct mptcp_addr_info *skc)\n{\n\tstruct mptcp_pm_addr_entry new_entry;\n\t__be16 msk_sport =  ((struct inet_sock *)\n\t\t\t     inet_sk((struct sock *)msk))->inet_sport;\n\n\tmemset(&new_entry, 0, sizeof(struct mptcp_pm_addr_entry));\n\tnew_entry.addr = *skc;\n\tnew_entry.addr.id = 0;\n\tnew_entry.flags = MPTCP_PM_ADDR_FLAG_IMPLICIT;\n\n\tif (new_entry.addr.port == msk_sport)\n\t\tnew_entry.addr.port = 0;\n\n\treturn mptcp_userspace_pm_append_new_local_addr(msk, &new_entry);\n}\n\nint mptcp_nl_cmd_announce(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *token = info->attrs[MPTCP_PM_ATTR_TOKEN];\n\tstruct nlattr *addr = info->attrs[MPTCP_PM_ATTR_ADDR];\n\tstruct mptcp_pm_addr_entry addr_val;\n\tstruct mptcp_sock *msk;\n\tint err = -EINVAL;\n\tu32 token_val;\n\n\tif (!addr || !token) {\n\t\tGENL_SET_ERR_MSG(info, \"missing required inputs\");\n\t\treturn err;\n\t}\n\n\ttoken_val = nla_get_u32(token);\n\n\tmsk = mptcp_token_get_sock(sock_net(skb->sk), token_val);\n\tif (!msk) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, token, \"invalid token\");\n\t\treturn err;\n\t}\n\n\tif (!mptcp_pm_is_userspace(msk)) {\n\t\tGENL_SET_ERR_MSG(info, \"invalid request; userspace PM not selected\");\n\t\tgoto announce_err;\n\t}\n\n\terr = mptcp_pm_parse_entry(addr, info, true, &addr_val);\n\tif (err < 0) {\n\t\tGENL_SET_ERR_MSG(info, \"error parsing local address\");\n\t\tgoto announce_err;\n\t}\n\n\tif (addr_val.addr.id == 0 || !(addr_val.flags & MPTCP_PM_ADDR_FLAG_SIGNAL)) {\n\t\tGENL_SET_ERR_MSG(info, \"invalid addr id or flags\");\n\t\terr = -EINVAL;\n\t\tgoto announce_err;\n\t}\n\n\terr = mptcp_userspace_pm_append_new_local_addr(msk, &addr_val);\n\tif (err < 0) {\n\t\tGENL_SET_ERR_MSG(info, \"did not match address and id\");\n\t\tgoto announce_err;\n\t}\n\n\tlock_sock((struct sock *)msk);\n\tspin_lock_bh(&msk->pm.lock);\n\n\tif (mptcp_pm_alloc_anno_list(msk, &addr_val.addr)) {\n\t\tmsk->pm.add_addr_signaled++;\n\t\tmptcp_pm_announce_addr(msk, &addr_val.addr, false);\n\t\tmptcp_pm_nl_addr_send_ack(msk);\n\t}\n\n\tspin_unlock_bh(&msk->pm.lock);\n\trelease_sock((struct sock *)msk);\n\n\terr = 0;\n announce_err:\n\tsock_put((struct sock *)msk);\n\treturn err;\n}\n\nint mptcp_nl_cmd_remove(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *token = info->attrs[MPTCP_PM_ATTR_TOKEN];\n\tstruct nlattr *id = info->attrs[MPTCP_PM_ATTR_LOC_ID];\n\tstruct mptcp_pm_addr_entry *match = NULL;\n\tstruct mptcp_pm_addr_entry *entry;\n\tstruct mptcp_sock *msk;\n\tLIST_HEAD(free_list);\n\tint err = -EINVAL;\n\tu32 token_val;\n\tu8 id_val;\n\n\tif (!id || !token) {\n\t\tGENL_SET_ERR_MSG(info, \"missing required inputs\");\n\t\treturn err;\n\t}\n\n\tid_val = nla_get_u8(id);\n\ttoken_val = nla_get_u32(token);\n\n\tmsk = mptcp_token_get_sock(sock_net(skb->sk), token_val);\n\tif (!msk) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, token, \"invalid token\");\n\t\treturn err;\n\t}\n\n\tif (!mptcp_pm_is_userspace(msk)) {\n\t\tGENL_SET_ERR_MSG(info, \"invalid request; userspace PM not selected\");\n\t\tgoto remove_err;\n\t}\n\n\tlock_sock((struct sock *)msk);\n\n\tlist_for_each_entry(entry, &msk->pm.userspace_pm_local_addr_list, list) {\n\t\tif (entry->addr.id == id_val) {\n\t\t\tmatch = entry;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!match) {\n\t\tGENL_SET_ERR_MSG(info, \"address with specified id not found\");\n\t\trelease_sock((struct sock *)msk);\n\t\tgoto remove_err;\n\t}\n\n\tlist_move(&match->list, &free_list);\n\n\tmptcp_pm_remove_addrs(msk, &free_list);\n\n\trelease_sock((struct sock *)msk);\n\n\tlist_for_each_entry_safe(match, entry, &free_list, list) {\n\t\tsock_kfree_s((struct sock *)msk, match, sizeof(*match));\n\t}\n\n\terr = 0;\n remove_err:\n\tsock_put((struct sock *)msk);\n\treturn err;\n}\n\nint mptcp_nl_cmd_sf_create(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *raddr = info->attrs[MPTCP_PM_ATTR_ADDR_REMOTE];\n\tstruct nlattr *token = info->attrs[MPTCP_PM_ATTR_TOKEN];\n\tstruct nlattr *laddr = info->attrs[MPTCP_PM_ATTR_ADDR];\n\tstruct mptcp_pm_addr_entry local = { 0 };\n\tstruct mptcp_addr_info addr_r;\n\tstruct mptcp_addr_info addr_l;\n\tstruct mptcp_sock *msk;\n\tint err = -EINVAL;\n\tstruct sock *sk;\n\tu32 token_val;\n\n\tif (!laddr || !raddr || !token) {\n\t\tGENL_SET_ERR_MSG(info, \"missing required inputs\");\n\t\treturn err;\n\t}\n\n\ttoken_val = nla_get_u32(token);\n\n\tmsk = mptcp_token_get_sock(genl_info_net(info), token_val);\n\tif (!msk) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, token, \"invalid token\");\n\t\treturn err;\n\t}\n\n\tif (!mptcp_pm_is_userspace(msk)) {\n\t\tGENL_SET_ERR_MSG(info, \"invalid request; userspace PM not selected\");\n\t\tgoto create_err;\n\t}\n\n\terr = mptcp_pm_parse_addr(laddr, info, &addr_l);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, laddr, \"error parsing local addr\");\n\t\tgoto create_err;\n\t}\n\n\terr = mptcp_pm_parse_addr(raddr, info, &addr_r);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, raddr, \"error parsing remote addr\");\n\t\tgoto create_err;\n\t}\n\n\tsk = (struct sock *)msk;\n\n\tif (!mptcp_pm_addr_families_match(sk, &addr_l, &addr_r)) {\n\t\tGENL_SET_ERR_MSG(info, \"families mismatch\");\n\t\terr = -EINVAL;\n\t\tgoto create_err;\n\t}\n\n\tlocal.addr = addr_l;\n\terr = mptcp_userspace_pm_append_new_local_addr(msk, &local);\n\tif (err < 0) {\n\t\tGENL_SET_ERR_MSG(info, \"did not match address and id\");\n\t\tgoto create_err;\n\t}\n\n\tlock_sock(sk);\n\n\terr = __mptcp_subflow_connect(sk, &addr_l, &addr_r);\n\n\trelease_sock(sk);\n\n\tspin_lock_bh(&msk->pm.lock);\n\tif (err)\n\t\tmptcp_userspace_pm_delete_local_addr(msk, &local);\n\telse\n\t\tmsk->pm.subflows++;\n\tspin_unlock_bh(&msk->pm.lock);\n\n create_err:\n\tsock_put((struct sock *)msk);\n\treturn err;\n}\n\nstatic struct sock *mptcp_nl_find_ssk(struct mptcp_sock *msk,\n\t\t\t\t      const struct mptcp_addr_info *local,\n\t\t\t\t      const struct mptcp_addr_info *remote)\n{\n\tstruct mptcp_subflow_context *subflow;\n\n\tif (local->family != remote->family)\n\t\treturn NULL;\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tconst struct inet_sock *issk;\n\t\tstruct sock *ssk;\n\n\t\tssk = mptcp_subflow_tcp_sock(subflow);\n\n\t\tif (local->family != ssk->sk_family)\n\t\t\tcontinue;\n\n\t\tissk = inet_sk(ssk);\n\n\t\tswitch (ssk->sk_family) {\n\t\tcase AF_INET:\n\t\t\tif (issk->inet_saddr != local->addr.s_addr ||\n\t\t\t    issk->inet_daddr != remote->addr.s_addr)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t\tcase AF_INET6: {\n\t\t\tconst struct ipv6_pinfo *pinfo = inet6_sk(ssk);\n\n\t\t\tif (!ipv6_addr_equal(&local->addr6, &pinfo->saddr) ||\n\t\t\t    !ipv6_addr_equal(&remote->addr6, &ssk->sk_v6_daddr))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (issk->inet_sport == local->port &&\n\t\t    issk->inet_dport == remote->port)\n\t\t\treturn ssk;\n\t}\n\n\treturn NULL;\n}\n\nint mptcp_nl_cmd_sf_destroy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *raddr = info->attrs[MPTCP_PM_ATTR_ADDR_REMOTE];\n\tstruct nlattr *token = info->attrs[MPTCP_PM_ATTR_TOKEN];\n\tstruct nlattr *laddr = info->attrs[MPTCP_PM_ATTR_ADDR];\n\tstruct mptcp_addr_info addr_l;\n\tstruct mptcp_addr_info addr_r;\n\tstruct mptcp_sock *msk;\n\tstruct sock *sk, *ssk;\n\tint err = -EINVAL;\n\tu32 token_val;\n\n\tif (!laddr || !raddr || !token) {\n\t\tGENL_SET_ERR_MSG(info, \"missing required inputs\");\n\t\treturn err;\n\t}\n\n\ttoken_val = nla_get_u32(token);\n\n\tmsk = mptcp_token_get_sock(genl_info_net(info), token_val);\n\tif (!msk) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, token, \"invalid token\");\n\t\treturn err;\n\t}\n\n\tif (!mptcp_pm_is_userspace(msk)) {\n\t\tGENL_SET_ERR_MSG(info, \"invalid request; userspace PM not selected\");\n\t\tgoto destroy_err;\n\t}\n\n\terr = mptcp_pm_parse_addr(laddr, info, &addr_l);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, laddr, \"error parsing local addr\");\n\t\tgoto destroy_err;\n\t}\n\n\terr = mptcp_pm_parse_addr(raddr, info, &addr_r);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, raddr, \"error parsing remote addr\");\n\t\tgoto destroy_err;\n\t}\n\n\tif (addr_l.family != addr_r.family) {\n\t\tGENL_SET_ERR_MSG(info, \"address families do not match\");\n\t\terr = -EINVAL;\n\t\tgoto destroy_err;\n\t}\n\n\tif (!addr_l.port || !addr_r.port) {\n\t\tGENL_SET_ERR_MSG(info, \"missing local or remote port\");\n\t\terr = -EINVAL;\n\t\tgoto destroy_err;\n\t}\n\n\tsk = (struct sock *)msk;\n\tlock_sock(sk);\n\tssk = mptcp_nl_find_ssk(msk, &addr_l, &addr_r);\n\tif (ssk) {\n\t\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\t\tstruct mptcp_pm_addr_entry entry = { .addr = addr_l };\n\n\t\tspin_lock_bh(&msk->pm.lock);\n\t\tmptcp_userspace_pm_delete_local_addr(msk, &entry);\n\t\tspin_unlock_bh(&msk->pm.lock);\n\t\tmptcp_subflow_shutdown(sk, ssk, RCV_SHUTDOWN | SEND_SHUTDOWN);\n\t\tmptcp_close_ssk(sk, ssk, subflow);\n\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RMSUBFLOW);\n\t\terr = 0;\n\t} else {\n\t\terr = -ESRCH;\n\t}\n\trelease_sock(sk);\n\ndestroy_err:\n\tsock_put((struct sock *)msk);\n\treturn err;\n}\n\nint mptcp_userspace_pm_set_flags(struct net *net, struct nlattr *token,\n\t\t\t\t struct mptcp_pm_addr_entry *loc,\n\t\t\t\t struct mptcp_pm_addr_entry *rem, u8 bkup)\n{\n\tstruct mptcp_sock *msk;\n\tint ret = -EINVAL;\n\tu32 token_val;\n\n\ttoken_val = nla_get_u32(token);\n\n\tmsk = mptcp_token_get_sock(net, token_val);\n\tif (!msk)\n\t\treturn ret;\n\n\tif (!mptcp_pm_is_userspace(msk))\n\t\tgoto set_flags_err;\n\n\tif (loc->addr.family == AF_UNSPEC ||\n\t    rem->addr.family == AF_UNSPEC)\n\t\tgoto set_flags_err;\n\n\tlock_sock((struct sock *)msk);\n\tret = mptcp_pm_nl_mp_prio_send_ack(msk, &loc->addr, &rem->addr, bkup);\n\trelease_sock((struct sock *)msk);\n\nset_flags_err:\n\tsock_put((struct sock *)msk);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}