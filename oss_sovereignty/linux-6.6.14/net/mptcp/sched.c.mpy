{
  "module_name": "sched.c",
  "hash_id": "2ad0b9eb7484de843f93de57a789f149c0d904d9612a274714ed79edea1be8ee",
  "original_prompt": "Ingested from linux-6.6.14/net/mptcp/sched.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"MPTCP: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/rculist.h>\n#include <linux/spinlock.h>\n#include \"protocol.h\"\n\nstatic DEFINE_SPINLOCK(mptcp_sched_list_lock);\nstatic LIST_HEAD(mptcp_sched_list);\n\nstatic int mptcp_sched_default_get_subflow(struct mptcp_sock *msk,\n\t\t\t\t\t   struct mptcp_sched_data *data)\n{\n\tstruct sock *ssk;\n\n\tssk = data->reinject ? mptcp_subflow_get_retrans(msk) :\n\t\t\t       mptcp_subflow_get_send(msk);\n\tif (!ssk)\n\t\treturn -EINVAL;\n\n\tmptcp_subflow_set_scheduled(mptcp_subflow_ctx(ssk), true);\n\treturn 0;\n}\n\nstatic struct mptcp_sched_ops mptcp_sched_default = {\n\t.get_subflow\t= mptcp_sched_default_get_subflow,\n\t.name\t\t= \"default\",\n\t.owner\t\t= THIS_MODULE,\n};\n\n \nstruct mptcp_sched_ops *mptcp_sched_find(const char *name)\n{\n\tstruct mptcp_sched_ops *sched, *ret = NULL;\n\n\tlist_for_each_entry_rcu(sched, &mptcp_sched_list, list) {\n\t\tif (!strcmp(sched->name, name)) {\n\t\t\tret = sched;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint mptcp_register_scheduler(struct mptcp_sched_ops *sched)\n{\n\tif (!sched->get_subflow)\n\t\treturn -EINVAL;\n\n\tspin_lock(&mptcp_sched_list_lock);\n\tif (mptcp_sched_find(sched->name)) {\n\t\tspin_unlock(&mptcp_sched_list_lock);\n\t\treturn -EEXIST;\n\t}\n\tlist_add_tail_rcu(&sched->list, &mptcp_sched_list);\n\tspin_unlock(&mptcp_sched_list_lock);\n\n\tpr_debug(\"%s registered\", sched->name);\n\treturn 0;\n}\n\nvoid mptcp_unregister_scheduler(struct mptcp_sched_ops *sched)\n{\n\tif (sched == &mptcp_sched_default)\n\t\treturn;\n\n\tspin_lock(&mptcp_sched_list_lock);\n\tlist_del_rcu(&sched->list);\n\tspin_unlock(&mptcp_sched_list_lock);\n}\n\nvoid mptcp_sched_init(void)\n{\n\tmptcp_register_scheduler(&mptcp_sched_default);\n}\n\nint mptcp_init_sched(struct mptcp_sock *msk,\n\t\t     struct mptcp_sched_ops *sched)\n{\n\tif (!sched)\n\t\tsched = &mptcp_sched_default;\n\n\tif (!bpf_try_module_get(sched, sched->owner))\n\t\treturn -EBUSY;\n\n\tmsk->sched = sched;\n\tif (msk->sched->init)\n\t\tmsk->sched->init(msk);\n\n\tpr_debug(\"sched=%s\", msk->sched->name);\n\n\treturn 0;\n}\n\nvoid mptcp_release_sched(struct mptcp_sock *msk)\n{\n\tstruct mptcp_sched_ops *sched = msk->sched;\n\n\tif (!sched)\n\t\treturn;\n\n\tmsk->sched = NULL;\n\tif (sched->release)\n\t\tsched->release(msk);\n\n\tbpf_module_put(sched, sched->owner);\n}\n\nvoid mptcp_subflow_set_scheduled(struct mptcp_subflow_context *subflow,\n\t\t\t\t bool scheduled)\n{\n\tWRITE_ONCE(subflow->scheduled, scheduled);\n}\n\nint mptcp_sched_get_send(struct mptcp_sock *msk)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct mptcp_sched_data data;\n\n\tmsk_owned_by_me(msk);\n\n\t \n\tif (__mptcp_check_fallback(msk)) {\n\t\tif (msk->first &&\n\t\t    __tcp_can_send(msk->first) &&\n\t\t    sk_stream_memory_free(msk->first)) {\n\t\t\tmptcp_subflow_set_scheduled(mptcp_subflow_ctx(msk->first), true);\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tif (READ_ONCE(subflow->scheduled))\n\t\t\treturn 0;\n\t}\n\n\tdata.reinject = false;\n\tif (msk->sched == &mptcp_sched_default || !msk->sched)\n\t\treturn mptcp_sched_default_get_subflow(msk, &data);\n\treturn msk->sched->get_subflow(msk, &data);\n}\n\nint mptcp_sched_get_retrans(struct mptcp_sock *msk)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct mptcp_sched_data data;\n\n\tmsk_owned_by_me(msk);\n\n\t \n\tif (__mptcp_check_fallback(msk))\n\t\treturn -EINVAL;\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tif (READ_ONCE(subflow->scheduled))\n\t\t\treturn 0;\n\t}\n\n\tdata.reinject = true;\n\tif (msk->sched == &mptcp_sched_default || !msk->sched)\n\t\treturn mptcp_sched_default_get_subflow(msk, &data);\n\treturn msk->sched->get_subflow(msk, &data);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}