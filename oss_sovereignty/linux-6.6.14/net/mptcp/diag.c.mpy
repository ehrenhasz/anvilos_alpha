{
  "module_name": "diag.c",
  "hash_id": "c28d37d2f38e624bb15719c973283fe89ca1eb72d752aa84843e2c524125ec72",
  "original_prompt": "Ingested from linux-6.6.14/net/mptcp/diag.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/net.h>\n#include <linux/inet_diag.h>\n#include <net/netlink.h>\n#include <uapi/linux/mptcp.h>\n#include \"protocol.h\"\n\nstatic int subflow_get_info(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct mptcp_subflow_context *sf;\n\tstruct nlattr *start;\n\tu32 flags = 0;\n\tint err;\n\n\tstart = nla_nest_start_noflag(skb, INET_ULP_INFO_MPTCP);\n\tif (!start)\n\t\treturn -EMSGSIZE;\n\n\trcu_read_lock();\n\tsf = rcu_dereference(inet_csk(sk)->icsk_ulp_data);\n\tif (!sf) {\n\t\terr = 0;\n\t\tgoto nla_failure;\n\t}\n\n\tif (sf->mp_capable)\n\t\tflags |= MPTCP_SUBFLOW_FLAG_MCAP_REM;\n\tif (sf->request_mptcp)\n\t\tflags |= MPTCP_SUBFLOW_FLAG_MCAP_LOC;\n\tif (sf->mp_join)\n\t\tflags |= MPTCP_SUBFLOW_FLAG_JOIN_REM;\n\tif (sf->request_join)\n\t\tflags |= MPTCP_SUBFLOW_FLAG_JOIN_LOC;\n\tif (sf->backup)\n\t\tflags |= MPTCP_SUBFLOW_FLAG_BKUP_REM;\n\tif (sf->request_bkup)\n\t\tflags |= MPTCP_SUBFLOW_FLAG_BKUP_LOC;\n\tif (sf->fully_established)\n\t\tflags |= MPTCP_SUBFLOW_FLAG_FULLY_ESTABLISHED;\n\tif (sf->conn_finished)\n\t\tflags |= MPTCP_SUBFLOW_FLAG_CONNECTED;\n\tif (sf->map_valid)\n\t\tflags |= MPTCP_SUBFLOW_FLAG_MAPVALID;\n\n\tif (nla_put_u32(skb, MPTCP_SUBFLOW_ATTR_TOKEN_REM, sf->remote_token) ||\n\t    nla_put_u32(skb, MPTCP_SUBFLOW_ATTR_TOKEN_LOC, sf->token) ||\n\t    nla_put_u32(skb, MPTCP_SUBFLOW_ATTR_RELWRITE_SEQ,\n\t\t\tsf->rel_write_seq) ||\n\t    nla_put_u64_64bit(skb, MPTCP_SUBFLOW_ATTR_MAP_SEQ, sf->map_seq,\n\t\t\t      MPTCP_SUBFLOW_ATTR_PAD) ||\n\t    nla_put_u32(skb, MPTCP_SUBFLOW_ATTR_MAP_SFSEQ,\n\t\t\tsf->map_subflow_seq) ||\n\t    nla_put_u32(skb, MPTCP_SUBFLOW_ATTR_SSN_OFFSET, sf->ssn_offset) ||\n\t    nla_put_u16(skb, MPTCP_SUBFLOW_ATTR_MAP_DATALEN,\n\t\t\tsf->map_data_len) ||\n\t    nla_put_u32(skb, MPTCP_SUBFLOW_ATTR_FLAGS, flags) ||\n\t    nla_put_u8(skb, MPTCP_SUBFLOW_ATTR_ID_REM, sf->remote_id) ||\n\t    nla_put_u8(skb, MPTCP_SUBFLOW_ATTR_ID_LOC, sf->local_id)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto nla_failure;\n\t}\n\n\trcu_read_unlock();\n\tnla_nest_end(skb, start);\n\treturn 0;\n\nnla_failure:\n\trcu_read_unlock();\n\tnla_nest_cancel(skb, start);\n\treturn err;\n}\n\nstatic size_t subflow_get_info_size(const struct sock *sk)\n{\n\tsize_t size = 0;\n\n\tsize += nla_total_size(0) +\t \n\t\tnla_total_size(4) +\t \n\t\tnla_total_size(4) +\t \n\t\tnla_total_size(4) +\t \n\t\tnla_total_size_64bit(8) +\t \n\t\tnla_total_size(4) +\t \n\t\tnla_total_size(2) +\t \n\t\tnla_total_size(2) +\t \n\t\tnla_total_size(4) +\t \n\t\tnla_total_size(1) +\t \n\t\tnla_total_size(1) +\t \n\t\t0;\n\treturn size;\n}\n\nvoid mptcp_diag_subflow_init(struct tcp_ulp_ops *ops)\n{\n\tops->get_info = subflow_get_info;\n\tops->get_info_size = subflow_get_info_size;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}