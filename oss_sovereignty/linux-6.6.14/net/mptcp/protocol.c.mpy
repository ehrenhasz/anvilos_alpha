{
  "module_name": "protocol.c",
  "hash_id": "944dccad2a2f747c7facb0e85078e796646903d766848f111696d1f2ac923967",
  "original_prompt": "Ingested from linux-6.6.14/net/mptcp/protocol.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"MPTCP: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/sched/signal.h>\n#include <linux/atomic.h>\n#include <net/sock.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/protocol.h>\n#include <net/tcp.h>\n#include <net/tcp_states.h>\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n#include <net/transp_v6.h>\n#endif\n#include <net/mptcp.h>\n#include <net/xfrm.h>\n#include <asm/ioctls.h>\n#include \"protocol.h\"\n#include \"mib.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/mptcp.h>\n\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\nstruct mptcp6_sock {\n\tstruct mptcp_sock msk;\n\tstruct ipv6_pinfo np;\n};\n#endif\n\nenum {\n\tMPTCP_CMSG_TS = BIT(0),\n\tMPTCP_CMSG_INQ = BIT(1),\n};\n\nstatic struct percpu_counter mptcp_sockets_allocated ____cacheline_aligned_in_smp;\n\nstatic void __mptcp_destroy_sock(struct sock *sk);\nstatic void mptcp_check_send_data_fin(struct sock *sk);\n\nDEFINE_PER_CPU(struct mptcp_delegated_action, mptcp_delegated_actions);\nstatic struct net_device mptcp_napi_dev;\n\n \nstatic u64 mptcp_wnd_end(const struct mptcp_sock *msk)\n{\n\treturn READ_ONCE(msk->wnd_end);\n}\n\nstatic bool mptcp_is_tcpsk(struct sock *sk)\n{\n\tstruct socket *sock = sk->sk_socket;\n\n\tif (unlikely(sk->sk_prot == &tcp_prot)) {\n\t\t \n\t\tWRITE_ONCE(sock->ops, &inet_stream_ops);\n\t\treturn true;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t} else if (unlikely(sk->sk_prot == &tcpv6_prot)) {\n\t\tWRITE_ONCE(sock->ops, &inet6_stream_ops);\n\t\treturn true;\n#endif\n\t}\n\n\treturn false;\n}\n\nstatic int __mptcp_socket_create(struct mptcp_sock *msk)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct socket *ssock;\n\tint err;\n\n\terr = mptcp_subflow_create_socket(sk, sk->sk_family, &ssock);\n\tif (err)\n\t\treturn err;\n\n\tmsk->scaling_ratio = tcp_sk(ssock->sk)->scaling_ratio;\n\tWRITE_ONCE(msk->first, ssock->sk);\n\tsubflow = mptcp_subflow_ctx(ssock->sk);\n\tlist_add(&subflow->node, &msk->conn_list);\n\tsock_hold(ssock->sk);\n\tsubflow->request_mptcp = 1;\n\tsubflow->subflow_id = msk->subflow_id++;\n\n\t \n\tsubflow->local_id_valid = 1;\n\tmptcp_sock_graft(msk->first, sk->sk_socket);\n\tiput(SOCK_INODE(ssock));\n\n\treturn 0;\n}\n\n \nstruct sock *__mptcp_nmpc_sk(struct mptcp_sock *msk)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tint ret;\n\n\tif (!((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!msk->first) {\n\t\tret = __mptcp_socket_create(msk);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tmptcp_sockopt_sync(msk, msk->first);\n\t}\n\n\treturn msk->first;\n}\n\nstatic void mptcp_drop(struct sock *sk, struct sk_buff *skb)\n{\n\tsk_drops_add(sk, skb);\n\t__kfree_skb(skb);\n}\n\nstatic void mptcp_rmem_fwd_alloc_add(struct sock *sk, int size)\n{\n\tWRITE_ONCE(mptcp_sk(sk)->rmem_fwd_alloc,\n\t\t   mptcp_sk(sk)->rmem_fwd_alloc + size);\n}\n\nstatic void mptcp_rmem_charge(struct sock *sk, int size)\n{\n\tmptcp_rmem_fwd_alloc_add(sk, -size);\n}\n\nstatic bool mptcp_try_coalesce(struct sock *sk, struct sk_buff *to,\n\t\t\t       struct sk_buff *from)\n{\n\tbool fragstolen;\n\tint delta;\n\n\tif (MPTCP_SKB_CB(from)->offset ||\n\t    !skb_try_coalesce(to, from, &fragstolen, &delta))\n\t\treturn false;\n\n\tpr_debug(\"colesced seq %llx into %llx new len %d new end seq %llx\",\n\t\t MPTCP_SKB_CB(from)->map_seq, MPTCP_SKB_CB(to)->map_seq,\n\t\t to->len, MPTCP_SKB_CB(from)->end_seq);\n\tMPTCP_SKB_CB(to)->end_seq = MPTCP_SKB_CB(from)->end_seq;\n\n\t \n\tatomic_add(delta, &sk->sk_rmem_alloc);\n\tmptcp_rmem_charge(sk, delta);\n\tkfree_skb_partial(from, fragstolen);\n\n\treturn true;\n}\n\nstatic bool mptcp_ooo_try_coalesce(struct mptcp_sock *msk, struct sk_buff *to,\n\t\t\t\t   struct sk_buff *from)\n{\n\tif (MPTCP_SKB_CB(from)->map_seq != MPTCP_SKB_CB(to)->end_seq)\n\t\treturn false;\n\n\treturn mptcp_try_coalesce((struct sock *)msk, to, from);\n}\n\nstatic void __mptcp_rmem_reclaim(struct sock *sk, int amount)\n{\n\tamount >>= PAGE_SHIFT;\n\tmptcp_rmem_charge(sk, amount << PAGE_SHIFT);\n\t__sk_mem_reduce_allocated(sk, amount);\n}\n\nstatic void mptcp_rmem_uncharge(struct sock *sk, int size)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tint reclaimable;\n\n\tmptcp_rmem_fwd_alloc_add(sk, size);\n\treclaimable = msk->rmem_fwd_alloc - sk_unused_reserved_mem(sk);\n\n\t \n\tif (unlikely(reclaimable >= PAGE_SIZE))\n\t\t__mptcp_rmem_reclaim(sk, reclaimable);\n}\n\nstatic void mptcp_rfree(struct sk_buff *skb)\n{\n\tunsigned int len = skb->truesize;\n\tstruct sock *sk = skb->sk;\n\n\tatomic_sub(len, &sk->sk_rmem_alloc);\n\tmptcp_rmem_uncharge(sk, len);\n}\n\nvoid mptcp_set_owner_r(struct sk_buff *skb, struct sock *sk)\n{\n\tskb_orphan(skb);\n\tskb->sk = sk;\n\tskb->destructor = mptcp_rfree;\n\tatomic_add(skb->truesize, &sk->sk_rmem_alloc);\n\tmptcp_rmem_charge(sk, skb->truesize);\n}\n\n \nstatic void mptcp_data_queue_ofo(struct mptcp_sock *msk, struct sk_buff *skb)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct rb_node **p, *parent;\n\tu64 seq, end_seq, max_seq;\n\tstruct sk_buff *skb1;\n\n\tseq = MPTCP_SKB_CB(skb)->map_seq;\n\tend_seq = MPTCP_SKB_CB(skb)->end_seq;\n\tmax_seq = atomic64_read(&msk->rcv_wnd_sent);\n\n\tpr_debug(\"msk=%p seq=%llx limit=%llx empty=%d\", msk, seq, max_seq,\n\t\t RB_EMPTY_ROOT(&msk->out_of_order_queue));\n\tif (after64(end_seq, max_seq)) {\n\t\t \n\t\tmptcp_drop(sk, skb);\n\t\tpr_debug(\"oow by %lld, rcv_wnd_sent %llu\\n\",\n\t\t\t (unsigned long long)end_seq - (unsigned long)max_seq,\n\t\t\t (unsigned long long)atomic64_read(&msk->rcv_wnd_sent));\n\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_NODSSWINDOW);\n\t\treturn;\n\t}\n\n\tp = &msk->out_of_order_queue.rb_node;\n\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_OFOQUEUE);\n\tif (RB_EMPTY_ROOT(&msk->out_of_order_queue)) {\n\t\trb_link_node(&skb->rbnode, NULL, p);\n\t\trb_insert_color(&skb->rbnode, &msk->out_of_order_queue);\n\t\tmsk->ooo_last_skb = skb;\n\t\tgoto end;\n\t}\n\n\t \n\tif (mptcp_ooo_try_coalesce(msk, msk->ooo_last_skb, skb)) {\n\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_OFOMERGE);\n\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_OFOQUEUETAIL);\n\t\treturn;\n\t}\n\n\t \n\tif (!before64(seq, MPTCP_SKB_CB(msk->ooo_last_skb)->end_seq)) {\n\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_OFOQUEUETAIL);\n\t\tparent = &msk->ooo_last_skb->rbnode;\n\t\tp = &parent->rb_right;\n\t\tgoto insert;\n\t}\n\n\t \n\tparent = NULL;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tskb1 = rb_to_skb(parent);\n\t\tif (before64(seq, MPTCP_SKB_CB(skb1)->map_seq)) {\n\t\t\tp = &parent->rb_left;\n\t\t\tcontinue;\n\t\t}\n\t\tif (before64(seq, MPTCP_SKB_CB(skb1)->end_seq)) {\n\t\t\tif (!after64(end_seq, MPTCP_SKB_CB(skb1)->end_seq)) {\n\t\t\t\t \n\t\t\t\tmptcp_drop(sk, skb);\n\t\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_DUPDATA);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (after64(seq, MPTCP_SKB_CB(skb1)->map_seq)) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trb_replace_node(&skb1->rbnode, &skb->rbnode,\n\t\t\t\t\t\t&msk->out_of_order_queue);\n\t\t\t\tmptcp_drop(sk, skb1);\n\t\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_DUPDATA);\n\t\t\t\tgoto merge_right;\n\t\t\t}\n\t\t} else if (mptcp_ooo_try_coalesce(msk, skb1, skb)) {\n\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_OFOMERGE);\n\t\t\treturn;\n\t\t}\n\t\tp = &parent->rb_right;\n\t}\n\ninsert:\n\t \n\trb_link_node(&skb->rbnode, parent, p);\n\trb_insert_color(&skb->rbnode, &msk->out_of_order_queue);\n\nmerge_right:\n\t \n\twhile ((skb1 = skb_rb_next(skb)) != NULL) {\n\t\tif (before64(end_seq, MPTCP_SKB_CB(skb1)->end_seq))\n\t\t\tbreak;\n\t\trb_erase(&skb1->rbnode, &msk->out_of_order_queue);\n\t\tmptcp_drop(sk, skb1);\n\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_DUPDATA);\n\t}\n\t \n\tif (!skb1)\n\t\tmsk->ooo_last_skb = skb;\n\nend:\n\tskb_condense(skb);\n\tmptcp_set_owner_r(skb, sk);\n}\n\nstatic bool mptcp_rmem_schedule(struct sock *sk, struct sock *ssk, int size)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tint amt, amount;\n\n\tif (size <= msk->rmem_fwd_alloc)\n\t\treturn true;\n\n\tsize -= msk->rmem_fwd_alloc;\n\tamt = sk_mem_pages(size);\n\tamount = amt << PAGE_SHIFT;\n\tif (!__sk_mem_raise_allocated(sk, size, amt, SK_MEM_RECV))\n\t\treturn false;\n\n\tmptcp_rmem_fwd_alloc_add(sk, amount);\n\treturn true;\n}\n\nstatic bool __mptcp_move_skb(struct mptcp_sock *msk, struct sock *ssk,\n\t\t\t     struct sk_buff *skb, unsigned int offset,\n\t\t\t     size_t copy_len)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct sk_buff *tail;\n\tbool has_rxtstamp;\n\n\t__skb_unlink(skb, &ssk->sk_receive_queue);\n\n\tskb_ext_reset(skb);\n\tskb_orphan(skb);\n\n\t \n\tif (!mptcp_rmem_schedule(sk, ssk, skb->truesize))\n\t\tgoto drop;\n\n\thas_rxtstamp = TCP_SKB_CB(skb)->has_rxtstamp;\n\n\t \n\tMPTCP_SKB_CB(skb)->map_seq = mptcp_subflow_get_mapped_dsn(subflow);\n\tMPTCP_SKB_CB(skb)->end_seq = MPTCP_SKB_CB(skb)->map_seq + copy_len;\n\tMPTCP_SKB_CB(skb)->offset = offset;\n\tMPTCP_SKB_CB(skb)->has_rxtstamp = has_rxtstamp;\n\n\tif (MPTCP_SKB_CB(skb)->map_seq == msk->ack_seq) {\n\t\t \n\t\tmsk->bytes_received += copy_len;\n\t\tWRITE_ONCE(msk->ack_seq, msk->ack_seq + copy_len);\n\t\ttail = skb_peek_tail(&sk->sk_receive_queue);\n\t\tif (tail && mptcp_try_coalesce(sk, tail, skb))\n\t\t\treturn true;\n\n\t\tmptcp_set_owner_r(skb, sk);\n\t\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\t\treturn true;\n\t} else if (after64(MPTCP_SKB_CB(skb)->map_seq, msk->ack_seq)) {\n\t\tmptcp_data_queue_ofo(msk, skb);\n\t\treturn false;\n\t}\n\n\t \n\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_DUPDATA);\ndrop:\n\tmptcp_drop(sk, skb);\n\treturn false;\n}\n\nstatic void mptcp_stop_rtx_timer(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tsk_stop_timer(sk, &icsk->icsk_retransmit_timer);\n\tmptcp_sk(sk)->timer_ival = 0;\n}\n\nstatic void mptcp_close_wake_up(struct sock *sk)\n{\n\tif (sock_flag(sk, SOCK_DEAD))\n\t\treturn;\n\n\tsk->sk_state_change(sk);\n\tif (sk->sk_shutdown == SHUTDOWN_MASK ||\n\t    sk->sk_state == TCP_CLOSE)\n\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);\n\telse\n\t\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);\n}\n\nstatic bool mptcp_pending_data_fin_ack(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\treturn ((1 << sk->sk_state) &\n\t\t(TCPF_FIN_WAIT1 | TCPF_CLOSING | TCPF_LAST_ACK)) &&\n\t       msk->write_seq == READ_ONCE(msk->snd_una);\n}\n\nstatic void mptcp_check_data_fin_ack(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\t \n\tif (mptcp_pending_data_fin_ack(sk)) {\n\t\tWRITE_ONCE(msk->snd_data_fin_enable, 0);\n\n\t\tswitch (sk->sk_state) {\n\t\tcase TCP_FIN_WAIT1:\n\t\t\tinet_sk_state_store(sk, TCP_FIN_WAIT2);\n\t\t\tbreak;\n\t\tcase TCP_CLOSING:\n\t\tcase TCP_LAST_ACK:\n\t\t\tinet_sk_state_store(sk, TCP_CLOSE);\n\t\t\tbreak;\n\t\t}\n\n\t\tmptcp_close_wake_up(sk);\n\t}\n}\n\nstatic bool mptcp_pending_data_fin(struct sock *sk, u64 *seq)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tif (READ_ONCE(msk->rcv_data_fin) &&\n\t    ((1 << sk->sk_state) &\n\t     (TCPF_ESTABLISHED | TCPF_FIN_WAIT1 | TCPF_FIN_WAIT2))) {\n\t\tu64 rcv_data_fin_seq = READ_ONCE(msk->rcv_data_fin_seq);\n\n\t\tif (msk->ack_seq == rcv_data_fin_seq) {\n\t\t\tif (seq)\n\t\t\t\t*seq = rcv_data_fin_seq;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic void mptcp_set_datafin_timeout(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tu32 retransmits;\n\n\tretransmits = min_t(u32, icsk->icsk_retransmits,\n\t\t\t    ilog2(TCP_RTO_MAX / TCP_RTO_MIN));\n\n\tmptcp_sk(sk)->timer_ival = TCP_RTO_MIN << retransmits;\n}\n\nstatic void __mptcp_set_timeout(struct sock *sk, long tout)\n{\n\tmptcp_sk(sk)->timer_ival = tout > 0 ? tout : TCP_RTO_MIN;\n}\n\nstatic long mptcp_timeout_from_subflow(const struct mptcp_subflow_context *subflow)\n{\n\tconst struct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\n\treturn inet_csk(ssk)->icsk_pending && !subflow->stale_count ?\n\t       inet_csk(ssk)->icsk_timeout - jiffies : 0;\n}\n\nstatic void mptcp_set_timeout(struct sock *sk)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tlong tout = 0;\n\n\tmptcp_for_each_subflow(mptcp_sk(sk), subflow)\n\t\ttout = max(tout, mptcp_timeout_from_subflow(subflow));\n\t__mptcp_set_timeout(sk, tout);\n}\n\nstatic inline bool tcp_can_send_ack(const struct sock *ssk)\n{\n\treturn !((1 << inet_sk_state_load(ssk)) &\n\t       (TCPF_SYN_SENT | TCPF_SYN_RECV | TCPF_TIME_WAIT | TCPF_CLOSE | TCPF_LISTEN));\n}\n\nvoid __mptcp_subflow_send_ack(struct sock *ssk)\n{\n\tif (tcp_can_send_ack(ssk))\n\t\ttcp_send_ack(ssk);\n}\n\nstatic void mptcp_subflow_send_ack(struct sock *ssk)\n{\n\tbool slow;\n\n\tslow = lock_sock_fast(ssk);\n\t__mptcp_subflow_send_ack(ssk);\n\tunlock_sock_fast(ssk, slow);\n}\n\nstatic void mptcp_send_ack(struct mptcp_sock *msk)\n{\n\tstruct mptcp_subflow_context *subflow;\n\n\tmptcp_for_each_subflow(msk, subflow)\n\t\tmptcp_subflow_send_ack(mptcp_subflow_tcp_sock(subflow));\n}\n\nstatic void mptcp_subflow_cleanup_rbuf(struct sock *ssk)\n{\n\tbool slow;\n\n\tslow = lock_sock_fast(ssk);\n\tif (tcp_can_send_ack(ssk))\n\t\ttcp_cleanup_rbuf(ssk, 1);\n\tunlock_sock_fast(ssk, slow);\n}\n\nstatic bool mptcp_subflow_could_cleanup(const struct sock *ssk, bool rx_empty)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(ssk);\n\tu8 ack_pending = READ_ONCE(icsk->icsk_ack.pending);\n\tconst struct tcp_sock *tp = tcp_sk(ssk);\n\n\treturn (ack_pending & ICSK_ACK_SCHED) &&\n\t\t((READ_ONCE(tp->rcv_nxt) - READ_ONCE(tp->rcv_wup) >\n\t\t  READ_ONCE(icsk->icsk_ack.rcv_mss)) ||\n\t\t (rx_empty && ack_pending &\n\t\t\t      (ICSK_ACK_PUSHED2 | ICSK_ACK_PUSHED)));\n}\n\nstatic void mptcp_cleanup_rbuf(struct mptcp_sock *msk)\n{\n\tint old_space = READ_ONCE(msk->old_wspace);\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tint space =  __mptcp_space(sk);\n\tbool cleanup, rx_empty;\n\n\tcleanup = (space > 0) && (space >= (old_space << 1));\n\trx_empty = !__mptcp_rmem(sk);\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\n\t\tif (cleanup || mptcp_subflow_could_cleanup(ssk, rx_empty))\n\t\t\tmptcp_subflow_cleanup_rbuf(ssk);\n\t}\n}\n\nstatic bool mptcp_check_data_fin(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tu64 rcv_data_fin_seq;\n\tbool ret = false;\n\n\t \n\n\tif (mptcp_pending_data_fin(sk, &rcv_data_fin_seq)) {\n\t\tWRITE_ONCE(msk->ack_seq, msk->ack_seq + 1);\n\t\tWRITE_ONCE(msk->rcv_data_fin, 0);\n\n\t\tWRITE_ONCE(sk->sk_shutdown, sk->sk_shutdown | RCV_SHUTDOWN);\n\t\tsmp_mb__before_atomic();  \n\n\t\tswitch (sk->sk_state) {\n\t\tcase TCP_ESTABLISHED:\n\t\t\tinet_sk_state_store(sk, TCP_CLOSE_WAIT);\n\t\t\tbreak;\n\t\tcase TCP_FIN_WAIT1:\n\t\t\tinet_sk_state_store(sk, TCP_CLOSING);\n\t\t\tbreak;\n\t\tcase TCP_FIN_WAIT2:\n\t\t\tinet_sk_state_store(sk, TCP_CLOSE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tWARN_ON_ONCE(1);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = true;\n\t\tif (!__mptcp_check_fallback(msk))\n\t\t\tmptcp_send_ack(msk);\n\t\tmptcp_close_wake_up(sk);\n\t}\n\treturn ret;\n}\n\nstatic bool __mptcp_move_skbs_from_subflow(struct mptcp_sock *msk,\n\t\t\t\t\t   struct sock *ssk,\n\t\t\t\t\t   unsigned int *bytes)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tstruct sock *sk = (struct sock *)msk;\n\tunsigned int moved = 0;\n\tbool more_data_avail;\n\tstruct tcp_sock *tp;\n\tbool done = false;\n\tint sk_rbuf;\n\n\tsk_rbuf = READ_ONCE(sk->sk_rcvbuf);\n\n\tif (!(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\tint ssk_rbuf = READ_ONCE(ssk->sk_rcvbuf);\n\n\t\tif (unlikely(ssk_rbuf > sk_rbuf)) {\n\t\t\tWRITE_ONCE(sk->sk_rcvbuf, ssk_rbuf);\n\t\t\tsk_rbuf = ssk_rbuf;\n\t\t}\n\t}\n\n\tpr_debug(\"msk=%p ssk=%p\", msk, ssk);\n\ttp = tcp_sk(ssk);\n\tdo {\n\t\tu32 map_remaining, offset;\n\t\tu32 seq = tp->copied_seq;\n\t\tstruct sk_buff *skb;\n\t\tbool fin;\n\n\t\t \n\t\tmap_remaining = subflow->map_data_len -\n\t\t\t\tmptcp_subflow_get_map_offset(subflow);\n\n\t\tskb = skb_peek(&ssk->sk_receive_queue);\n\t\tif (!skb) {\n\t\t\t \n\t\t\tif (!moved)\n\t\t\t\tdone = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (__mptcp_check_fallback(msk)) {\n\t\t\t \n\t\t\tmap_remaining = skb->len;\n\t\t\tsubflow->map_data_len = skb->len;\n\t\t}\n\n\t\toffset = seq - TCP_SKB_CB(skb)->seq;\n\t\tfin = TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN;\n\t\tif (fin) {\n\t\t\tdone = true;\n\t\t\tseq++;\n\t\t}\n\n\t\tif (offset < skb->len) {\n\t\t\tsize_t len = skb->len - offset;\n\n\t\t\tif (tp->urg_data)\n\t\t\t\tdone = true;\n\n\t\t\tif (__mptcp_move_skb(msk, ssk, skb, offset, len))\n\t\t\t\tmoved += len;\n\t\t\tseq += len;\n\n\t\t\tif (WARN_ON_ONCE(map_remaining < len))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(!fin);\n\t\t\tsk_eat_skb(ssk, skb);\n\t\t\tdone = true;\n\t\t}\n\n\t\tWRITE_ONCE(tp->copied_seq, seq);\n\t\tmore_data_avail = mptcp_subflow_data_available(ssk);\n\n\t\tif (atomic_read(&sk->sk_rmem_alloc) > sk_rbuf) {\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\t}\n\t} while (more_data_avail);\n\n\t*bytes += moved;\n\treturn done;\n}\n\nstatic bool __mptcp_ofo_queue(struct mptcp_sock *msk)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct sk_buff *skb, *tail;\n\tbool moved = false;\n\tstruct rb_node *p;\n\tu64 end_seq;\n\n\tp = rb_first(&msk->out_of_order_queue);\n\tpr_debug(\"msk=%p empty=%d\", msk, RB_EMPTY_ROOT(&msk->out_of_order_queue));\n\twhile (p) {\n\t\tskb = rb_to_skb(p);\n\t\tif (after64(MPTCP_SKB_CB(skb)->map_seq, msk->ack_seq))\n\t\t\tbreak;\n\n\t\tp = rb_next(p);\n\t\trb_erase(&skb->rbnode, &msk->out_of_order_queue);\n\n\t\tif (unlikely(!after64(MPTCP_SKB_CB(skb)->end_seq,\n\t\t\t\t      msk->ack_seq))) {\n\t\t\tmptcp_drop(sk, skb);\n\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_DUPDATA);\n\t\t\tcontinue;\n\t\t}\n\n\t\tend_seq = MPTCP_SKB_CB(skb)->end_seq;\n\t\ttail = skb_peek_tail(&sk->sk_receive_queue);\n\t\tif (!tail || !mptcp_ooo_try_coalesce(msk, tail, skb)) {\n\t\t\tint delta = msk->ack_seq - MPTCP_SKB_CB(skb)->map_seq;\n\n\t\t\t \n\t\t\tpr_debug(\"uncoalesced seq=%llx ack seq=%llx delta=%d\",\n\t\t\t\t MPTCP_SKB_CB(skb)->map_seq, msk->ack_seq,\n\t\t\t\t delta);\n\t\t\tMPTCP_SKB_CB(skb)->offset += delta;\n\t\t\tMPTCP_SKB_CB(skb)->map_seq += delta;\n\t\t\t__skb_queue_tail(&sk->sk_receive_queue, skb);\n\t\t}\n\t\tmsk->bytes_received += end_seq - msk->ack_seq;\n\t\tmsk->ack_seq = end_seq;\n\t\tmoved = true;\n\t}\n\treturn moved;\n}\n\nstatic bool __mptcp_subflow_error_report(struct sock *sk, struct sock *ssk)\n{\n\tint err = sock_error(ssk);\n\tint ssk_state;\n\n\tif (!err)\n\t\treturn false;\n\n\t \n\tif (sk->sk_state != TCP_SYN_SENT && !__mptcp_check_fallback(mptcp_sk(sk)))\n\t\treturn false;\n\n\t \n\tssk_state = inet_sk_state_load(ssk);\n\tif (ssk_state == TCP_CLOSE && !sock_flag(sk, SOCK_DEAD))\n\t\tinet_sk_state_store(sk, ssk_state);\n\tWRITE_ONCE(sk->sk_err, -err);\n\n\t \n\tsmp_wmb();\n\tsk_error_report(sk);\n\treturn true;\n}\n\nvoid __mptcp_error_report(struct sock *sk)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tmptcp_for_each_subflow(msk, subflow)\n\t\tif (__mptcp_subflow_error_report(sk, mptcp_subflow_tcp_sock(subflow)))\n\t\t\tbreak;\n}\n\n \nstatic bool move_skbs_to_msk(struct mptcp_sock *msk, struct sock *ssk)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tunsigned int moved = 0;\n\n\t__mptcp_move_skbs_from_subflow(msk, ssk, &moved);\n\t__mptcp_ofo_queue(msk);\n\tif (unlikely(ssk->sk_err)) {\n\t\tif (!sock_owned_by_user(sk))\n\t\t\t__mptcp_error_report(sk);\n\t\telse\n\t\t\t__set_bit(MPTCP_ERROR_REPORT,  &msk->cb_flags);\n\t}\n\n\t \n\tif (mptcp_pending_data_fin(sk, NULL))\n\t\tmptcp_schedule_work(sk);\n\treturn moved > 0;\n}\n\nvoid mptcp_data_ready(struct sock *sk, struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tint sk_rbuf, ssk_rbuf;\n\n\t \n\tif (unlikely(subflow->disposable))\n\t\treturn;\n\n\tssk_rbuf = READ_ONCE(ssk->sk_rcvbuf);\n\tsk_rbuf = READ_ONCE(sk->sk_rcvbuf);\n\tif (unlikely(ssk_rbuf > sk_rbuf))\n\t\tsk_rbuf = ssk_rbuf;\n\n\t \n\tif (__mptcp_rmem(sk) > sk_rbuf) {\n\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RCVPRUNED);\n\t\treturn;\n\t}\n\n\t \n\tmptcp_data_lock(sk);\n\tif (move_skbs_to_msk(msk, ssk))\n\t\tsk->sk_data_ready(sk);\n\n\tmptcp_data_unlock(sk);\n}\n\nstatic void mptcp_subflow_joined(struct mptcp_sock *msk, struct sock *ssk)\n{\n\tmptcp_subflow_ctx(ssk)->map_seq = READ_ONCE(msk->ack_seq);\n\tWRITE_ONCE(msk->allow_infinite_fallback, false);\n\tmptcp_event(MPTCP_EVENT_SUB_ESTABLISHED, msk, ssk, GFP_ATOMIC);\n}\n\nstatic bool __mptcp_finish_join(struct mptcp_sock *msk, struct sock *ssk)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn false;\n\n\t \n\tif (sk->sk_socket && !ssk->sk_socket)\n\t\tmptcp_sock_graft(ssk, sk->sk_socket);\n\n\tmptcp_subflow_ctx(ssk)->subflow_id = msk->subflow_id++;\n\tmptcp_sockopt_sync_locked(msk, ssk);\n\tmptcp_subflow_joined(msk, ssk);\n\tmptcp_stop_tout_timer(sk);\n\t__mptcp_propagate_sndbuf(sk, ssk);\n\treturn true;\n}\n\nstatic void __mptcp_flush_join_list(struct sock *sk, struct list_head *join_list)\n{\n\tstruct mptcp_subflow_context *tmp, *subflow;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tlist_for_each_entry_safe(subflow, tmp, join_list, node) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\t\tbool slow = lock_sock_fast(ssk);\n\n\t\tlist_move_tail(&subflow->node, &msk->conn_list);\n\t\tif (!__mptcp_finish_join(msk, ssk))\n\t\t\tmptcp_subflow_reset(ssk);\n\t\tunlock_sock_fast(ssk, slow);\n\t}\n}\n\nstatic bool mptcp_rtx_timer_pending(struct sock *sk)\n{\n\treturn timer_pending(&inet_csk(sk)->icsk_retransmit_timer);\n}\n\nstatic void mptcp_reset_rtx_timer(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tunsigned long tout;\n\n\t \n\tif (unlikely(inet_sk_state_load(sk) == TCP_CLOSE))\n\t\treturn;\n\n\ttout = mptcp_sk(sk)->timer_ival;\n\tsk_reset_timer(sk, &icsk->icsk_retransmit_timer, jiffies + tout);\n}\n\nbool mptcp_schedule_work(struct sock *sk)\n{\n\tif (inet_sk_state_load(sk) != TCP_CLOSE &&\n\t    schedule_work(&mptcp_sk(sk)->work)) {\n\t\t \n\t\tsock_hold(sk);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic struct sock *mptcp_subflow_recv_lookup(const struct mptcp_sock *msk)\n{\n\tstruct mptcp_subflow_context *subflow;\n\n\tmsk_owned_by_me(msk);\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tif (READ_ONCE(subflow->data_avail))\n\t\t\treturn mptcp_subflow_tcp_sock(subflow);\n\t}\n\n\treturn NULL;\n}\n\nstatic bool mptcp_skb_can_collapse_to(u64 write_seq,\n\t\t\t\t      const struct sk_buff *skb,\n\t\t\t\t      const struct mptcp_ext *mpext)\n{\n\tif (!tcp_skb_can_collapse_to(skb))\n\t\treturn false;\n\n\t \n\treturn mpext && mpext->data_seq + mpext->data_len == write_seq &&\n\t       !mpext->frozen;\n}\n\n \nstatic bool mptcp_frag_can_collapse_to(const struct mptcp_sock *msk,\n\t\t\t\t       const struct page_frag *pfrag,\n\t\t\t\t       const struct mptcp_data_frag *df)\n{\n\treturn df && pfrag->page == df->page &&\n\t\tpfrag->size - pfrag->offset > 0 &&\n\t\tpfrag->offset == (df->offset + df->data_len) &&\n\t\tdf->data_seq + df->data_len == msk->write_seq;\n}\n\nstatic void dfrag_uncharge(struct sock *sk, int len)\n{\n\tsk_mem_uncharge(sk, len);\n\tsk_wmem_queued_add(sk, -len);\n}\n\nstatic void dfrag_clear(struct sock *sk, struct mptcp_data_frag *dfrag)\n{\n\tint len = dfrag->data_len + dfrag->overhead;\n\n\tlist_del(&dfrag->list);\n\tdfrag_uncharge(sk, len);\n\tput_page(dfrag->page);\n}\n\nstatic void __mptcp_clean_una(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct mptcp_data_frag *dtmp, *dfrag;\n\tu64 snd_una;\n\n\tsnd_una = msk->snd_una;\n\tlist_for_each_entry_safe(dfrag, dtmp, &msk->rtx_queue, list) {\n\t\tif (after64(dfrag->data_seq + dfrag->data_len, snd_una))\n\t\t\tbreak;\n\n\t\tif (unlikely(dfrag == msk->first_pending)) {\n\t\t\t \n\t\t\tif (WARN_ON_ONCE(!msk->recovery))\n\t\t\t\tbreak;\n\n\t\t\tWRITE_ONCE(msk->first_pending, mptcp_send_next(sk));\n\t\t}\n\n\t\tdfrag_clear(sk, dfrag);\n\t}\n\n\tdfrag = mptcp_rtx_head(sk);\n\tif (dfrag && after64(snd_una, dfrag->data_seq)) {\n\t\tu64 delta = snd_una - dfrag->data_seq;\n\n\t\t \n\t\tif (unlikely(delta > dfrag->already_sent)) {\n\t\t\tif (WARN_ON_ONCE(!msk->recovery))\n\t\t\t\tgoto out;\n\t\t\tif (WARN_ON_ONCE(delta > dfrag->data_len))\n\t\t\t\tgoto out;\n\t\t\tdfrag->already_sent += delta - dfrag->already_sent;\n\t\t}\n\n\t\tdfrag->data_seq += delta;\n\t\tdfrag->offset += delta;\n\t\tdfrag->data_len -= delta;\n\t\tdfrag->already_sent -= delta;\n\n\t\tdfrag_uncharge(sk, delta);\n\t}\n\n\t \n\tif (unlikely(msk->recovery) && after64(msk->snd_una, msk->recovery_snd_nxt))\n\t\tmsk->recovery = false;\n\nout:\n\tif (snd_una == READ_ONCE(msk->snd_nxt) &&\n\t    snd_una == READ_ONCE(msk->write_seq)) {\n\t\tif (mptcp_rtx_timer_pending(sk) && !mptcp_data_fin_enabled(msk))\n\t\t\tmptcp_stop_rtx_timer(sk);\n\t} else {\n\t\tmptcp_reset_rtx_timer(sk);\n\t}\n}\n\nstatic void __mptcp_clean_una_wakeup(struct sock *sk)\n{\n\tlockdep_assert_held_once(&sk->sk_lock.slock);\n\n\t__mptcp_clean_una(sk);\n\tmptcp_write_space(sk);\n}\n\nstatic void mptcp_clean_una_wakeup(struct sock *sk)\n{\n\tmptcp_data_lock(sk);\n\t__mptcp_clean_una_wakeup(sk);\n\tmptcp_data_unlock(sk);\n}\n\nstatic void mptcp_enter_memory_pressure(struct sock *sk)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tbool first = true;\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\n\t\tif (first)\n\t\t\ttcp_enter_memory_pressure(ssk);\n\t\tsk_stream_moderate_sndbuf(ssk);\n\n\t\tfirst = false;\n\t}\n\t__mptcp_sync_sndbuf(sk);\n}\n\n \nstatic bool mptcp_page_frag_refill(struct sock *sk, struct page_frag *pfrag)\n{\n\tif (likely(skb_page_frag_refill(32U + sizeof(struct mptcp_data_frag),\n\t\t\t\t\tpfrag, sk->sk_allocation)))\n\t\treturn true;\n\n\tmptcp_enter_memory_pressure(sk);\n\treturn false;\n}\n\nstatic struct mptcp_data_frag *\nmptcp_carve_data_frag(const struct mptcp_sock *msk, struct page_frag *pfrag,\n\t\t      int orig_offset)\n{\n\tint offset = ALIGN(orig_offset, sizeof(long));\n\tstruct mptcp_data_frag *dfrag;\n\n\tdfrag = (struct mptcp_data_frag *)(page_to_virt(pfrag->page) + offset);\n\tdfrag->data_len = 0;\n\tdfrag->data_seq = msk->write_seq;\n\tdfrag->overhead = offset - orig_offset + sizeof(struct mptcp_data_frag);\n\tdfrag->offset = offset + sizeof(struct mptcp_data_frag);\n\tdfrag->already_sent = 0;\n\tdfrag->page = pfrag->page;\n\n\treturn dfrag;\n}\n\nstruct mptcp_sendmsg_info {\n\tint mss_now;\n\tint size_goal;\n\tu16 limit;\n\tu16 sent;\n\tunsigned int flags;\n\tbool data_lock_held;\n};\n\nstatic int mptcp_check_allowed_size(const struct mptcp_sock *msk, struct sock *ssk,\n\t\t\t\t    u64 data_seq, int avail_size)\n{\n\tu64 window_end = mptcp_wnd_end(msk);\n\tu64 mptcp_snd_wnd;\n\n\tif (__mptcp_check_fallback(msk))\n\t\treturn avail_size;\n\n\tmptcp_snd_wnd = window_end - data_seq;\n\tavail_size = min_t(unsigned int, mptcp_snd_wnd, avail_size);\n\n\tif (unlikely(tcp_sk(ssk)->snd_wnd < mptcp_snd_wnd)) {\n\t\ttcp_sk(ssk)->snd_wnd = min_t(u64, U32_MAX, mptcp_snd_wnd);\n\t\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_SNDWNDSHARED);\n\t}\n\n\treturn avail_size;\n}\n\nstatic bool __mptcp_add_ext(struct sk_buff *skb, gfp_t gfp)\n{\n\tstruct skb_ext *mpext = __skb_ext_alloc(gfp);\n\n\tif (!mpext)\n\t\treturn false;\n\t__skb_ext_set(skb, SKB_EXT_MPTCP, mpext);\n\treturn true;\n}\n\nstatic struct sk_buff *__mptcp_do_alloc_tx_skb(struct sock *sk, gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb_fclone(MAX_TCP_HEADER, gfp);\n\tif (likely(skb)) {\n\t\tif (likely(__mptcp_add_ext(skb, gfp))) {\n\t\t\tskb_reserve(skb, MAX_TCP_HEADER);\n\t\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\t\tINIT_LIST_HEAD(&skb->tcp_tsorted_anchor);\n\t\t\treturn skb;\n\t\t}\n\t\t__kfree_skb(skb);\n\t} else {\n\t\tmptcp_enter_memory_pressure(sk);\n\t}\n\treturn NULL;\n}\n\nstatic struct sk_buff *__mptcp_alloc_tx_skb(struct sock *sk, struct sock *ssk, gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __mptcp_do_alloc_tx_skb(sk, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\tif (likely(sk_wmem_schedule(ssk, skb->truesize))) {\n\t\ttcp_skb_entail(ssk, skb);\n\t\treturn skb;\n\t}\n\ttcp_skb_tsorted_anchor_cleanup(skb);\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstatic struct sk_buff *mptcp_alloc_tx_skb(struct sock *sk, struct sock *ssk, bool data_lock_held)\n{\n\tgfp_t gfp = data_lock_held ? GFP_ATOMIC : sk->sk_allocation;\n\n\treturn __mptcp_alloc_tx_skb(sk, ssk, gfp);\n}\n\n \nstatic void mptcp_update_data_checksum(struct sk_buff *skb, int added)\n{\n\tstruct mptcp_ext *mpext = mptcp_get_ext(skb);\n\t__wsum csum = ~csum_unfold(mpext->csum);\n\tint offset = skb->len - added;\n\n\tmpext->csum = csum_fold(csum_block_add(csum, skb_checksum(skb, offset, added, 0), offset));\n}\n\nstatic void mptcp_update_infinite_map(struct mptcp_sock *msk,\n\t\t\t\t      struct sock *ssk,\n\t\t\t\t      struct mptcp_ext *mpext)\n{\n\tif (!mpext)\n\t\treturn;\n\n\tmpext->infinite_map = 1;\n\tmpext->data_len = 0;\n\n\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_INFINITEMAPTX);\n\tmptcp_subflow_ctx(ssk)->send_infinite_map = 0;\n\tpr_fallback(msk);\n\tmptcp_do_fallback(ssk);\n}\n\n#define MPTCP_MAX_GSO_SIZE (GSO_LEGACY_MAX_SIZE - (MAX_TCP_HEADER + 1))\n\nstatic int mptcp_sendmsg_frag(struct sock *sk, struct sock *ssk,\n\t\t\t      struct mptcp_data_frag *dfrag,\n\t\t\t      struct mptcp_sendmsg_info *info)\n{\n\tu64 data_seq = dfrag->data_seq + info->sent;\n\tint offset = dfrag->offset + info->sent;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tbool zero_window_probe = false;\n\tstruct mptcp_ext *mpext = NULL;\n\tbool can_coalesce = false;\n\tbool reuse_skb = true;\n\tstruct sk_buff *skb;\n\tsize_t copy;\n\tint i;\n\n\tpr_debug(\"msk=%p ssk=%p sending dfrag at seq=%llu len=%u already sent=%u\",\n\t\t msk, ssk, dfrag->data_seq, dfrag->data_len, info->sent);\n\n\tif (WARN_ON_ONCE(info->sent > info->limit ||\n\t\t\t info->limit > dfrag->data_len))\n\t\treturn 0;\n\n\tif (unlikely(!__tcp_can_send(ssk)))\n\t\treturn -EAGAIN;\n\n\t \n\tif (unlikely(ssk->sk_gso_max_size > MPTCP_MAX_GSO_SIZE))\n\t\tssk->sk_gso_max_size = MPTCP_MAX_GSO_SIZE;\n\tinfo->mss_now = tcp_send_mss(ssk, &info->size_goal, info->flags);\n\tcopy = info->size_goal;\n\n\tskb = tcp_write_queue_tail(ssk);\n\tif (skb && copy > skb->len) {\n\t\t \n\t\tmpext = skb_ext_find(skb, SKB_EXT_MPTCP);\n\t\tif (!mptcp_skb_can_collapse_to(data_seq, skb, mpext)) {\n\t\t\tTCP_SKB_CB(skb)->eor = 1;\n\t\t\tgoto alloc_skb;\n\t\t}\n\n\t\ti = skb_shinfo(skb)->nr_frags;\n\t\tcan_coalesce = skb_can_coalesce(skb, i, dfrag->page, offset);\n\t\tif (!can_coalesce && i >= READ_ONCE(sysctl_max_skb_frags)) {\n\t\t\ttcp_mark_push(tcp_sk(ssk), skb);\n\t\t\tgoto alloc_skb;\n\t\t}\n\n\t\tcopy -= skb->len;\n\t} else {\nalloc_skb:\n\t\tskb = mptcp_alloc_tx_skb(sk, ssk, info->data_lock_held);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\ti = skb_shinfo(skb)->nr_frags;\n\t\treuse_skb = false;\n\t\tmpext = skb_ext_find(skb, SKB_EXT_MPTCP);\n\t}\n\n\t \n\tcopy = mptcp_check_allowed_size(msk, ssk, data_seq, copy);\n\tif (copy == 0) {\n\t\tu64 snd_una = READ_ONCE(msk->snd_una);\n\n\t\tif (snd_una != msk->snd_nxt || tcp_write_queue_tail(ssk)) {\n\t\t\ttcp_remove_empty_skb(ssk);\n\t\t\treturn 0;\n\t\t}\n\n\t\tzero_window_probe = true;\n\t\tdata_seq = snd_una - 1;\n\t\tcopy = 1;\n\t}\n\n\tcopy = min_t(size_t, copy, info->limit - info->sent);\n\tif (!sk_wmem_schedule(ssk, copy)) {\n\t\ttcp_remove_empty_skb(ssk);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (can_coalesce) {\n\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t} else {\n\t\tget_page(dfrag->page);\n\t\tskb_fill_page_desc(skb, i, dfrag->page, offset, copy);\n\t}\n\n\tskb->len += copy;\n\tskb->data_len += copy;\n\tskb->truesize += copy;\n\tsk_wmem_queued_add(ssk, copy);\n\tsk_mem_charge(ssk, copy);\n\tWRITE_ONCE(tcp_sk(ssk)->write_seq, tcp_sk(ssk)->write_seq + copy);\n\tTCP_SKB_CB(skb)->end_seq += copy;\n\ttcp_skb_pcount_set(skb, 0);\n\n\t \n\tif (reuse_skb) {\n\t\tTCP_SKB_CB(skb)->tcp_flags &= ~TCPHDR_PSH;\n\t\tmpext->data_len += copy;\n\t\tgoto out;\n\t}\n\n\tmemset(mpext, 0, sizeof(*mpext));\n\tmpext->data_seq = data_seq;\n\tmpext->subflow_seq = mptcp_subflow_ctx(ssk)->rel_write_seq;\n\tmpext->data_len = copy;\n\tmpext->use_map = 1;\n\tmpext->dsn64 = 1;\n\n\tpr_debug(\"data_seq=%llu subflow_seq=%u data_len=%u dsn64=%d\",\n\t\t mpext->data_seq, mpext->subflow_seq, mpext->data_len,\n\t\t mpext->dsn64);\n\n\tif (zero_window_probe) {\n\t\tmptcp_subflow_ctx(ssk)->rel_write_seq += copy;\n\t\tmpext->frozen = 1;\n\t\tif (READ_ONCE(msk->csum_enabled))\n\t\t\tmptcp_update_data_checksum(skb, copy);\n\t\ttcp_push_pending_frames(ssk);\n\t\treturn 0;\n\t}\nout:\n\tif (READ_ONCE(msk->csum_enabled))\n\t\tmptcp_update_data_checksum(skb, copy);\n\tif (mptcp_subflow_ctx(ssk)->send_infinite_map)\n\t\tmptcp_update_infinite_map(msk, ssk, mpext);\n\ttrace_mptcp_sendmsg_frag(mpext);\n\tmptcp_subflow_ctx(ssk)->rel_write_seq += copy;\n\treturn copy;\n}\n\n#define MPTCP_SEND_BURST_SIZE\t\t((1 << 16) - \\\n\t\t\t\t\t sizeof(struct tcphdr) - \\\n\t\t\t\t\t MAX_TCP_OPTION_SPACE - \\\n\t\t\t\t\t sizeof(struct ipv6hdr) - \\\n\t\t\t\t\t sizeof(struct frag_hdr))\n\nstruct subflow_send_info {\n\tstruct sock *ssk;\n\tu64 linger_time;\n};\n\nvoid mptcp_subflow_set_active(struct mptcp_subflow_context *subflow)\n{\n\tif (!subflow->stale)\n\t\treturn;\n\n\tsubflow->stale = 0;\n\tMPTCP_INC_STATS(sock_net(mptcp_subflow_tcp_sock(subflow)), MPTCP_MIB_SUBFLOWRECOVER);\n}\n\nbool mptcp_subflow_active(struct mptcp_subflow_context *subflow)\n{\n\tif (unlikely(subflow->stale)) {\n\t\tu32 rcv_tstamp = READ_ONCE(tcp_sk(mptcp_subflow_tcp_sock(subflow))->rcv_tstamp);\n\n\t\tif (subflow->stale_rcv_tstamp == rcv_tstamp)\n\t\t\treturn false;\n\n\t\tmptcp_subflow_set_active(subflow);\n\t}\n\treturn __mptcp_subflow_active(subflow);\n}\n\n#define SSK_MODE_ACTIVE\t0\n#define SSK_MODE_BACKUP\t1\n#define SSK_MODE_MAX\t2\n\n \nstruct sock *mptcp_subflow_get_send(struct mptcp_sock *msk)\n{\n\tstruct subflow_send_info send_info[SSK_MODE_MAX];\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tu32 pace, burst, wmem;\n\tint i, nr_active = 0;\n\tstruct sock *ssk;\n\tu64 linger_time;\n\tlong tout = 0;\n\n\t \n\tfor (i = 0; i < SSK_MODE_MAX; ++i) {\n\t\tsend_info[i].ssk = NULL;\n\t\tsend_info[i].linger_time = -1;\n\t}\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\ttrace_mptcp_subflow_get_send(subflow);\n\t\tssk =  mptcp_subflow_tcp_sock(subflow);\n\t\tif (!mptcp_subflow_active(subflow))\n\t\t\tcontinue;\n\n\t\ttout = max(tout, mptcp_timeout_from_subflow(subflow));\n\t\tnr_active += !subflow->backup;\n\t\tpace = subflow->avg_pacing_rate;\n\t\tif (unlikely(!pace)) {\n\t\t\t \n\t\t\tsubflow->avg_pacing_rate = READ_ONCE(ssk->sk_pacing_rate);\n\t\t\tpace = subflow->avg_pacing_rate;\n\t\t\tif (!pace)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tlinger_time = div_u64((u64)READ_ONCE(ssk->sk_wmem_queued) << 32, pace);\n\t\tif (linger_time < send_info[subflow->backup].linger_time) {\n\t\t\tsend_info[subflow->backup].ssk = ssk;\n\t\t\tsend_info[subflow->backup].linger_time = linger_time;\n\t\t}\n\t}\n\t__mptcp_set_timeout(sk, tout);\n\n\t \n\tif (!nr_active)\n\t\tsend_info[SSK_MODE_ACTIVE].ssk = send_info[SSK_MODE_BACKUP].ssk;\n\n\t \n\tssk = send_info[SSK_MODE_ACTIVE].ssk;\n\tif (!ssk || !sk_stream_memory_free(ssk))\n\t\treturn NULL;\n\n\tburst = min_t(int, MPTCP_SEND_BURST_SIZE, mptcp_wnd_end(msk) - msk->snd_nxt);\n\twmem = READ_ONCE(ssk->sk_wmem_queued);\n\tif (!burst)\n\t\treturn ssk;\n\n\tsubflow = mptcp_subflow_ctx(ssk);\n\tsubflow->avg_pacing_rate = div_u64((u64)subflow->avg_pacing_rate * wmem +\n\t\t\t\t\t   READ_ONCE(ssk->sk_pacing_rate) * burst,\n\t\t\t\t\t   burst + wmem);\n\tmsk->snd_burst = burst;\n\treturn ssk;\n}\n\nstatic void mptcp_push_release(struct sock *ssk, struct mptcp_sendmsg_info *info)\n{\n\ttcp_push(ssk, 0, info->mss_now, tcp_sk(ssk)->nonagle, info->size_goal);\n\trelease_sock(ssk);\n}\n\nstatic void mptcp_update_post_push(struct mptcp_sock *msk,\n\t\t\t\t   struct mptcp_data_frag *dfrag,\n\t\t\t\t   u32 sent)\n{\n\tu64 snd_nxt_new = dfrag->data_seq;\n\n\tdfrag->already_sent += sent;\n\n\tmsk->snd_burst -= sent;\n\n\tsnd_nxt_new += dfrag->already_sent;\n\n\t \n\tif (likely(after64(snd_nxt_new, msk->snd_nxt))) {\n\t\tmsk->bytes_sent += snd_nxt_new - msk->snd_nxt;\n\t\tmsk->snd_nxt = snd_nxt_new;\n\t}\n}\n\nvoid mptcp_check_and_set_pending(struct sock *sk)\n{\n\tif (mptcp_send_head(sk))\n\t\tmptcp_sk(sk)->push_pending |= BIT(MPTCP_PUSH_PENDING);\n}\n\nstatic int __subflow_push_pending(struct sock *sk, struct sock *ssk,\n\t\t\t\t  struct mptcp_sendmsg_info *info)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct mptcp_data_frag *dfrag;\n\tint len, copied = 0, err = 0;\n\n\twhile ((dfrag = mptcp_send_head(sk))) {\n\t\tinfo->sent = dfrag->already_sent;\n\t\tinfo->limit = dfrag->data_len;\n\t\tlen = dfrag->data_len - dfrag->already_sent;\n\t\twhile (len > 0) {\n\t\t\tint ret = 0;\n\n\t\t\tret = mptcp_sendmsg_frag(sk, ssk, dfrag, info);\n\t\t\tif (ret <= 0) {\n\t\t\t\terr = copied ? : ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tinfo->sent += ret;\n\t\t\tcopied += ret;\n\t\t\tlen -= ret;\n\n\t\t\tmptcp_update_post_push(msk, dfrag, ret);\n\t\t}\n\t\tWRITE_ONCE(msk->first_pending, mptcp_send_next(sk));\n\n\t\tif (msk->snd_burst <= 0 ||\n\t\t    !sk_stream_memory_free(ssk) ||\n\t\t    !mptcp_subflow_active(mptcp_subflow_ctx(ssk))) {\n\t\t\terr = copied;\n\t\t\tgoto out;\n\t\t}\n\t\tmptcp_set_timeout(sk);\n\t}\n\terr = copied;\n\nout:\n\treturn err;\n}\n\nvoid __mptcp_push_pending(struct sock *sk, unsigned int flags)\n{\n\tstruct sock *prev_ssk = NULL, *ssk = NULL;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct mptcp_sendmsg_info info = {\n\t\t\t\t.flags = flags,\n\t};\n\tbool do_check_data_fin = false;\n\tint push_count = 1;\n\n\twhile (mptcp_send_head(sk) && (push_count > 0)) {\n\t\tstruct mptcp_subflow_context *subflow;\n\t\tint ret = 0;\n\n\t\tif (mptcp_sched_get_send(msk))\n\t\t\tbreak;\n\n\t\tpush_count = 0;\n\n\t\tmptcp_for_each_subflow(msk, subflow) {\n\t\t\tif (READ_ONCE(subflow->scheduled)) {\n\t\t\t\tmptcp_subflow_set_scheduled(subflow, false);\n\n\t\t\t\tprev_ssk = ssk;\n\t\t\t\tssk = mptcp_subflow_tcp_sock(subflow);\n\t\t\t\tif (ssk != prev_ssk) {\n\t\t\t\t\t \n\t\t\t\t\tif (prev_ssk)\n\t\t\t\t\t\tmptcp_push_release(prev_ssk, &info);\n\n\t\t\t\t\t \n\t\t\t\t\tlock_sock(ssk);\n\t\t\t\t}\n\n\t\t\t\tpush_count++;\n\n\t\t\t\tret = __subflow_push_pending(sk, ssk, &info);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\tif (ret != -EAGAIN ||\n\t\t\t\t\t    (1 << ssk->sk_state) &\n\t\t\t\t\t     (TCPF_FIN_WAIT1 | TCPF_FIN_WAIT2 | TCPF_CLOSE))\n\t\t\t\t\t\tpush_count--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdo_check_data_fin = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (ssk)\n\t\tmptcp_push_release(ssk, &info);\n\n\t \n\tif (!mptcp_rtx_timer_pending(sk))\n\t\tmptcp_reset_rtx_timer(sk);\n\tif (do_check_data_fin)\n\t\tmptcp_check_send_data_fin(sk);\n}\n\nstatic void __mptcp_subflow_push_pending(struct sock *sk, struct sock *ssk, bool first)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct mptcp_sendmsg_info info = {\n\t\t.data_lock_held = true,\n\t};\n\tbool keep_pushing = true;\n\tstruct sock *xmit_ssk;\n\tint copied = 0;\n\n\tinfo.flags = 0;\n\twhile (mptcp_send_head(sk) && keep_pushing) {\n\t\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\t\tint ret = 0;\n\n\t\t \n\t\tif (first) {\n\t\t\tmptcp_subflow_set_scheduled(subflow, false);\n\t\t\tret = __subflow_push_pending(sk, ssk, &info);\n\t\t\tfirst = false;\n\t\t\tif (ret <= 0)\n\t\t\t\tbreak;\n\t\t\tcopied += ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mptcp_sched_get_send(msk))\n\t\t\tgoto out;\n\n\t\tif (READ_ONCE(subflow->scheduled)) {\n\t\t\tmptcp_subflow_set_scheduled(subflow, false);\n\t\t\tret = __subflow_push_pending(sk, ssk, &info);\n\t\t\tif (ret <= 0)\n\t\t\t\tkeep_pushing = false;\n\t\t\tcopied += ret;\n\t\t}\n\n\t\tmptcp_for_each_subflow(msk, subflow) {\n\t\t\tif (READ_ONCE(subflow->scheduled)) {\n\t\t\t\txmit_ssk = mptcp_subflow_tcp_sock(subflow);\n\t\t\t\tif (xmit_ssk != ssk) {\n\t\t\t\t\tmptcp_subflow_delegate(subflow,\n\t\t\t\t\t\t\t       MPTCP_DELEGATE_SEND);\n\t\t\t\t\tkeep_pushing = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\t \n\tif (copied) {\n\t\ttcp_push(ssk, 0, info.mss_now, tcp_sk(ssk)->nonagle,\n\t\t\t info.size_goal);\n\t\tif (!mptcp_rtx_timer_pending(sk))\n\t\t\tmptcp_reset_rtx_timer(sk);\n\n\t\tif (msk->snd_data_fin_enable &&\n\t\t    msk->snd_nxt + 1 == msk->write_seq)\n\t\t\tmptcp_schedule_work(sk);\n\t}\n}\n\nstatic void mptcp_set_nospace(struct sock *sk)\n{\n\t \n\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\n\t \n\tset_bit(MPTCP_NOSPACE, &mptcp_sk(sk)->flags);\n}\n\nstatic int mptcp_disconnect(struct sock *sk, int flags);\n\nstatic int mptcp_sendmsg_fastopen(struct sock *sk, struct msghdr *msg,\n\t\t\t\t  size_t len, int *copied_syn)\n{\n\tunsigned int saved_flags = msg->msg_flags;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct sock *ssk;\n\tint ret;\n\n\t \n\tif (msg->msg_flags & MSG_FASTOPEN) {\n\t\tssk = __mptcp_nmpc_sk(msk);\n\t\tif (IS_ERR(ssk))\n\t\t\treturn PTR_ERR(ssk);\n\t}\n\tif (!msk->first)\n\t\treturn -EINVAL;\n\n\tssk = msk->first;\n\n\tlock_sock(ssk);\n\tmsg->msg_flags |= MSG_DONTWAIT;\n\tmsk->fastopening = 1;\n\tret = tcp_sendmsg_fastopen(ssk, msg, copied_syn, len, NULL);\n\tmsk->fastopening = 0;\n\tmsg->msg_flags = saved_flags;\n\trelease_sock(ssk);\n\n\t \n\tif (ret == -EINPROGRESS && !(msg->msg_flags & MSG_DONTWAIT)) {\n\t\tret = __inet_stream_connect(sk->sk_socket, msg->msg_name,\n\t\t\t\t\t    msg->msg_namelen, msg->msg_flags, 1);\n\n\t\t \n\t\tif (ret && ret != -EINPROGRESS && ret != -ERESTARTSYS && ret != -EINTR)\n\t\t\t*copied_syn = 0;\n\t} else if (ret && ret != -EINPROGRESS) {\n\t\t \n\t\tif (!mptcp_disconnect(sk, 0))\n\t\t\tsk->sk_socket->state = SS_UNCONNECTED;\n\t}\n\tinet_clear_bit(DEFER_CONNECT, sk);\n\n\treturn ret;\n}\n\nstatic int mptcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct page_frag *pfrag;\n\tsize_t copied = 0;\n\tint ret = 0;\n\tlong timeo;\n\n\t \n\tmsg->msg_flags &= MSG_MORE | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_FASTOPEN;\n\n\tlock_sock(sk);\n\n\tif (unlikely(inet_test_bit(DEFER_CONNECT, sk) ||\n\t\t     msg->msg_flags & MSG_FASTOPEN)) {\n\t\tint copied_syn = 0;\n\n\t\tret = mptcp_sendmsg_fastopen(sk, msg, len, &copied_syn);\n\t\tcopied += copied_syn;\n\t\tif (ret == -EINPROGRESS && copied_syn > 0)\n\t\t\tgoto out;\n\t\telse if (ret)\n\t\t\tgoto do_error;\n\t}\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\n\tif ((1 << sk->sk_state) & ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) {\n\t\tret = sk_stream_wait_connect(sk, &timeo);\n\t\tif (ret)\n\t\t\tgoto do_error;\n\t}\n\n\tret = -EPIPE;\n\tif (unlikely(sk->sk_err || (sk->sk_shutdown & SEND_SHUTDOWN)))\n\t\tgoto do_error;\n\n\tpfrag = sk_page_frag(sk);\n\n\twhile (msg_data_left(msg)) {\n\t\tint total_ts, frag_truesize = 0;\n\t\tstruct mptcp_data_frag *dfrag;\n\t\tbool dfrag_collapsed;\n\t\tsize_t psize, offset;\n\n\t\t \n\t\tdfrag = mptcp_pending_tail(sk);\n\t\tdfrag_collapsed = mptcp_frag_can_collapse_to(msk, pfrag, dfrag);\n\t\tif (!dfrag_collapsed) {\n\t\t\tif (!sk_stream_memory_free(sk))\n\t\t\t\tgoto wait_for_memory;\n\n\t\t\tif (!mptcp_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto wait_for_memory;\n\n\t\t\tdfrag = mptcp_carve_data_frag(msk, pfrag, pfrag->offset);\n\t\t\tfrag_truesize = dfrag->overhead;\n\t\t}\n\n\t\t \n\t\toffset = dfrag->offset + dfrag->data_len;\n\t\tpsize = pfrag->size - offset;\n\t\tpsize = min_t(size_t, psize, msg_data_left(msg));\n\t\ttotal_ts = psize + frag_truesize;\n\n\t\tif (!sk_wmem_schedule(sk, total_ts))\n\t\t\tgoto wait_for_memory;\n\n\t\tif (copy_page_from_iter(dfrag->page, offset, psize,\n\t\t\t\t\t&msg->msg_iter) != psize) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto do_error;\n\t\t}\n\n\t\t \n\t\tsk_forward_alloc_add(sk, -total_ts);\n\t\tcopied += psize;\n\t\tdfrag->data_len += psize;\n\t\tfrag_truesize += psize;\n\t\tpfrag->offset += frag_truesize;\n\t\tWRITE_ONCE(msk->write_seq, msk->write_seq + psize);\n\n\t\t \n\t\tsk_wmem_queued_add(sk, frag_truesize);\n\t\tif (!dfrag_collapsed) {\n\t\t\tget_page(dfrag->page);\n\t\t\tlist_add_tail(&dfrag->list, &msk->rtx_queue);\n\t\t\tif (!msk->first_pending)\n\t\t\t\tWRITE_ONCE(msk->first_pending, dfrag);\n\t\t}\n\t\tpr_debug(\"msk=%p dfrag at seq=%llu len=%u sent=%u new=%d\", msk,\n\t\t\t dfrag->data_seq, dfrag->data_len, dfrag->already_sent,\n\t\t\t !dfrag_collapsed);\n\n\t\tcontinue;\n\nwait_for_memory:\n\t\tmptcp_set_nospace(sk);\n\t\t__mptcp_push_pending(sk, msg->msg_flags);\n\t\tret = sk_stream_wait_memory(sk, &timeo);\n\t\tif (ret)\n\t\t\tgoto do_error;\n\t}\n\n\tif (copied)\n\t\t__mptcp_push_pending(sk, msg->msg_flags);\n\nout:\n\trelease_sock(sk);\n\treturn copied;\n\ndo_error:\n\tif (copied)\n\t\tgoto out;\n\n\tcopied = sk_stream_error(sk, msg->msg_flags, ret);\n\tgoto out;\n}\n\nstatic int __mptcp_recvmsg_mskq(struct mptcp_sock *msk,\n\t\t\t\tstruct msghdr *msg,\n\t\t\t\tsize_t len, int flags,\n\t\t\t\tstruct scm_timestamping_internal *tss,\n\t\t\t\tint *cmsg_flags)\n{\n\tstruct sk_buff *skb, *tmp;\n\tint copied = 0;\n\n\tskb_queue_walk_safe(&msk->receive_queue, skb, tmp) {\n\t\tu32 offset = MPTCP_SKB_CB(skb)->offset;\n\t\tu32 data_len = skb->len - offset;\n\t\tu32 count = min_t(size_t, len - copied, data_len);\n\t\tint err;\n\n\t\tif (!(flags & MSG_TRUNC)) {\n\t\t\terr = skb_copy_datagram_msg(skb, offset, msg, count);\n\t\t\tif (unlikely(err < 0)) {\n\t\t\t\tif (!copied)\n\t\t\t\t\treturn err;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (MPTCP_SKB_CB(skb)->has_rxtstamp) {\n\t\t\ttcp_update_recv_tstamps(skb, tss);\n\t\t\t*cmsg_flags |= MPTCP_CMSG_TS;\n\t\t}\n\n\t\tcopied += count;\n\n\t\tif (count < data_len) {\n\t\t\tif (!(flags & MSG_PEEK)) {\n\t\t\t\tMPTCP_SKB_CB(skb)->offset += count;\n\t\t\t\tMPTCP_SKB_CB(skb)->map_seq += count;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(flags & MSG_PEEK)) {\n\t\t\t \n\t\t\tskb->destructor = NULL;\n\t\t\tWRITE_ONCE(msk->rmem_released, msk->rmem_released + skb->truesize);\n\t\t\t__skb_unlink(skb, &msk->receive_queue);\n\t\t\t__kfree_skb(skb);\n\t\t}\n\n\t\tif (copied >= len)\n\t\t\tbreak;\n\t}\n\n\treturn copied;\n}\n\n \nstatic void mptcp_rcv_space_adjust(struct mptcp_sock *msk, int copied)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tu8 scaling_ratio = U8_MAX;\n\tu32 time, advmss = 1;\n\tu64 rtt_us, mstamp;\n\n\tmsk_owned_by_me(msk);\n\n\tif (copied <= 0)\n\t\treturn;\n\n\tmsk->rcvq_space.copied += copied;\n\n\tmstamp = div_u64(tcp_clock_ns(), NSEC_PER_USEC);\n\ttime = tcp_stamp_us_delta(mstamp, msk->rcvq_space.time);\n\n\trtt_us = msk->rcvq_space.rtt_us;\n\tif (rtt_us && time < (rtt_us >> 3))\n\t\treturn;\n\n\trtt_us = 0;\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tconst struct tcp_sock *tp;\n\t\tu64 sf_rtt_us;\n\t\tu32 sf_advmss;\n\n\t\ttp = tcp_sk(mptcp_subflow_tcp_sock(subflow));\n\n\t\tsf_rtt_us = READ_ONCE(tp->rcv_rtt_est.rtt_us);\n\t\tsf_advmss = READ_ONCE(tp->advmss);\n\n\t\trtt_us = max(sf_rtt_us, rtt_us);\n\t\tadvmss = max(sf_advmss, advmss);\n\t\tscaling_ratio = min(tp->scaling_ratio, scaling_ratio);\n\t}\n\n\tmsk->rcvq_space.rtt_us = rtt_us;\n\tmsk->scaling_ratio = scaling_ratio;\n\tif (time < (rtt_us >> 3) || rtt_us == 0)\n\t\treturn;\n\n\tif (msk->rcvq_space.copied <= msk->rcvq_space.space)\n\t\tgoto new_measure;\n\n\tif (READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_moderate_rcvbuf) &&\n\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\tu64 rcvwin, grow;\n\t\tint rcvbuf;\n\n\t\trcvwin = ((u64)msk->rcvq_space.copied << 1) + 16 * advmss;\n\n\t\tgrow = rcvwin * (msk->rcvq_space.copied - msk->rcvq_space.space);\n\n\t\tdo_div(grow, msk->rcvq_space.space);\n\t\trcvwin += (grow << 1);\n\n\t\trcvbuf = min_t(u64, __tcp_space_from_win(scaling_ratio, rcvwin),\n\t\t\t       READ_ONCE(sock_net(sk)->ipv4.sysctl_tcp_rmem[2]));\n\n\t\tif (rcvbuf > sk->sk_rcvbuf) {\n\t\t\tu32 window_clamp;\n\n\t\t\twindow_clamp = __tcp_win_from_space(scaling_ratio, rcvbuf);\n\t\t\tWRITE_ONCE(sk->sk_rcvbuf, rcvbuf);\n\n\t\t\t \n\t\t\tmptcp_for_each_subflow(msk, subflow) {\n\t\t\t\tstruct sock *ssk;\n\t\t\t\tbool slow;\n\n\t\t\t\tssk = mptcp_subflow_tcp_sock(subflow);\n\t\t\t\tslow = lock_sock_fast(ssk);\n\t\t\t\tWRITE_ONCE(ssk->sk_rcvbuf, rcvbuf);\n\t\t\t\ttcp_sk(ssk)->window_clamp = window_clamp;\n\t\t\t\ttcp_cleanup_rbuf(ssk, 1);\n\t\t\t\tunlock_sock_fast(ssk, slow);\n\t\t\t}\n\t\t}\n\t}\n\n\tmsk->rcvq_space.space = msk->rcvq_space.copied;\nnew_measure:\n\tmsk->rcvq_space.copied = 0;\n\tmsk->rcvq_space.time = mstamp;\n}\n\nstatic void __mptcp_update_rmem(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tif (!msk->rmem_released)\n\t\treturn;\n\n\tatomic_sub(msk->rmem_released, &sk->sk_rmem_alloc);\n\tmptcp_rmem_uncharge(sk, msk->rmem_released);\n\tWRITE_ONCE(msk->rmem_released, 0);\n}\n\nstatic void __mptcp_splice_receive_queue(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tskb_queue_splice_tail_init(&sk->sk_receive_queue, &msk->receive_queue);\n}\n\nstatic bool __mptcp_move_skbs(struct mptcp_sock *msk)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tunsigned int moved = 0;\n\tbool ret, done;\n\n\tdo {\n\t\tstruct sock *ssk = mptcp_subflow_recv_lookup(msk);\n\t\tbool slowpath;\n\n\t\t \n\t\tif (likely(!ssk))\n\t\t\tbreak;\n\n\t\tslowpath = lock_sock_fast(ssk);\n\t\tmptcp_data_lock(sk);\n\t\t__mptcp_update_rmem(sk);\n\t\tdone = __mptcp_move_skbs_from_subflow(msk, ssk, &moved);\n\t\tmptcp_data_unlock(sk);\n\n\t\tif (unlikely(ssk->sk_err))\n\t\t\t__mptcp_error_report(sk);\n\t\tunlock_sock_fast(ssk, slowpath);\n\t} while (!done);\n\n\t \n\tret = moved > 0;\n\tif (!RB_EMPTY_ROOT(&msk->out_of_order_queue) ||\n\t    !skb_queue_empty_lockless(&sk->sk_receive_queue)) {\n\t\tmptcp_data_lock(sk);\n\t\t__mptcp_update_rmem(sk);\n\t\tret |= __mptcp_ofo_queue(msk);\n\t\t__mptcp_splice_receive_queue(sk);\n\t\tmptcp_data_unlock(sk);\n\t}\n\tif (ret)\n\t\tmptcp_check_data_fin((struct sock *)msk);\n\treturn !skb_queue_empty(&msk->receive_queue);\n}\n\nstatic unsigned int mptcp_inq_hint(const struct sock *sk)\n{\n\tconst struct mptcp_sock *msk = mptcp_sk(sk);\n\tconst struct sk_buff *skb;\n\n\tskb = skb_peek(&msk->receive_queue);\n\tif (skb) {\n\t\tu64 hint_val = msk->ack_seq - MPTCP_SKB_CB(skb)->map_seq;\n\n\t\tif (hint_val >= INT_MAX)\n\t\t\treturn INT_MAX;\n\n\t\treturn (unsigned int)hint_val;\n\t}\n\n\tif (sk->sk_state == TCP_CLOSE || (sk->sk_shutdown & RCV_SHUTDOWN))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int mptcp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n\t\t\t int flags, int *addr_len)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct scm_timestamping_internal tss;\n\tint copied = 0, cmsg_flags = 0;\n\tint target;\n\tlong timeo;\n\n\t \n\tif (unlikely(flags & MSG_ERRQUEUE))\n\t\treturn inet_recv_error(sk, msg, len, addr_len);\n\n\tlock_sock(sk);\n\tif (unlikely(sk->sk_state == TCP_LISTEN)) {\n\t\tcopied = -ENOTCONN;\n\t\tgoto out_err;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\n\tlen = min_t(size_t, len, INT_MAX);\n\ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, len);\n\n\tif (unlikely(msk->recvmsg_inq))\n\t\tcmsg_flags = MPTCP_CMSG_INQ;\n\n\twhile (copied < len) {\n\t\tint bytes_read;\n\n\t\tbytes_read = __mptcp_recvmsg_mskq(msk, msg, len - copied, flags, &tss, &cmsg_flags);\n\t\tif (unlikely(bytes_read < 0)) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = bytes_read;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tcopied += bytes_read;\n\n\t\t \n\t\tmptcp_cleanup_rbuf(msk);\n\n\t\tif (skb_queue_empty(&msk->receive_queue) && __mptcp_move_skbs(msk))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (copied >= target)\n\t\t\tbreak;\n\n\t\tif (copied) {\n\t\t\tif (sk->sk_err ||\n\t\t\t    sk->sk_state == TCP_CLOSE ||\n\t\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t    !timeo ||\n\t\t\t    signal_pending(current))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (sk->sk_err) {\n\t\t\t\tcopied = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\t\t \n\t\t\t\tif (__mptcp_move_skbs(msk))\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\t\tcopied = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!timeo) {\n\t\t\t\tcopied = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tcopied = sock_intr_errno(timeo);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpr_debug(\"block timeout %ld\", timeo);\n\t\tsk_wait_data(sk, &timeo, NULL);\n\t}\n\nout_err:\n\tif (cmsg_flags && copied >= 0) {\n\t\tif (cmsg_flags & MPTCP_CMSG_TS)\n\t\t\ttcp_recv_timestamp(msg, sk, &tss);\n\n\t\tif (cmsg_flags & MPTCP_CMSG_INQ) {\n\t\t\tunsigned int inq = mptcp_inq_hint(sk);\n\n\t\t\tput_cmsg(msg, SOL_TCP, TCP_CM_INQ, sizeof(inq), &inq);\n\t\t}\n\t}\n\n\tpr_debug(\"msk=%p rx queue empty=%d:%d copied=%d\",\n\t\t msk, skb_queue_empty_lockless(&sk->sk_receive_queue),\n\t\t skb_queue_empty(&msk->receive_queue), copied);\n\tif (!(flags & MSG_PEEK))\n\t\tmptcp_rcv_space_adjust(msk, copied);\n\n\trelease_sock(sk);\n\treturn copied;\n}\n\nstatic void mptcp_retransmit_timer(struct timer_list *t)\n{\n\tstruct inet_connection_sock *icsk = from_timer(icsk, t,\n\t\t\t\t\t\t       icsk_retransmit_timer);\n\tstruct sock *sk = &icsk->icsk_inet.sk;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk)) {\n\t\t \n\t\tif (!test_and_set_bit(MPTCP_WORK_RTX, &msk->flags))\n\t\t\tmptcp_schedule_work(sk);\n\t} else {\n\t\t \n\t\t__set_bit(MPTCP_RETRANSMIT, &msk->cb_flags);\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}\n\nstatic void mptcp_tout_timer(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\n\tmptcp_schedule_work(sk);\n\tsock_put(sk);\n}\n\n \nstruct sock *mptcp_subflow_get_retrans(struct mptcp_sock *msk)\n{\n\tstruct sock *backup = NULL, *pick = NULL;\n\tstruct mptcp_subflow_context *subflow;\n\tint min_stale_count = INT_MAX;\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\n\t\tif (!__mptcp_subflow_active(subflow))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!tcp_rtx_and_write_queues_empty(ssk)) {\n\t\t\tmptcp_pm_subflow_chk_stale(msk, ssk);\n\t\t\tmin_stale_count = min_t(int, min_stale_count, subflow->stale_count);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (subflow->backup) {\n\t\t\tif (!backup)\n\t\t\t\tbackup = ssk;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!pick)\n\t\t\tpick = ssk;\n\t}\n\n\tif (pick)\n\t\treturn pick;\n\n\t \n\treturn min_stale_count > 1 ? backup : NULL;\n}\n\nbool __mptcp_retransmit_pending_data(struct sock *sk)\n{\n\tstruct mptcp_data_frag *cur, *rtx_head;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tif (__mptcp_check_fallback(msk))\n\t\treturn false;\n\n\tif (tcp_rtx_and_write_queues_empty(sk))\n\t\treturn false;\n\n\t \n\tmptcp_data_lock(sk);\n\t__mptcp_clean_una_wakeup(sk);\n\trtx_head = mptcp_rtx_head(sk);\n\tif (!rtx_head) {\n\t\tmptcp_data_unlock(sk);\n\t\treturn false;\n\t}\n\n\tmsk->recovery_snd_nxt = msk->snd_nxt;\n\tmsk->recovery = true;\n\tmptcp_data_unlock(sk);\n\n\tmsk->first_pending = rtx_head;\n\tmsk->snd_burst = 0;\n\n\t \n\tlist_for_each_entry(cur, &msk->rtx_queue, list) {\n\t\tif (!cur->already_sent)\n\t\t\tbreak;\n\t\tcur->already_sent = 0;\n\t}\n\n\treturn true;\n}\n\n \n#define MPTCP_CF_PUSH\t\tBIT(1)\n#define MPTCP_CF_FASTCLOSE\tBIT(2)\n\n \nstatic void __mptcp_subflow_disconnect(struct sock *ssk,\n\t\t\t\t       struct mptcp_subflow_context *subflow,\n\t\t\t\t       unsigned int flags)\n{\n\tif (((1 << ssk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN)) ||\n\t    (flags & MPTCP_CF_FASTCLOSE)) {\n\t\t \n\t\tWARN_ON_ONCE(tcp_disconnect(ssk, 0));\n\t\tmptcp_subflow_ctx_reset(subflow);\n\t} else {\n\t\ttcp_shutdown(ssk, SEND_SHUTDOWN);\n\t}\n}\n\n \nstatic void __mptcp_close_ssk(struct sock *sk, struct sock *ssk,\n\t\t\t      struct mptcp_subflow_context *subflow,\n\t\t\t      unsigned int flags)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tbool dispose_it, need_push = false;\n\n\t \n\tif (msk->in_accept_queue && msk->first == ssk &&\n\t    (sock_flag(sk, SOCK_DEAD) || sock_flag(ssk, SOCK_DEAD))) {\n\t\t \n\t\tmptcp_set_close_tout(sk, tcp_jiffies32 - (TCP_TIMEWAIT_LEN + 1));\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t\tlock_sock_nested(ssk, SINGLE_DEPTH_NESTING);\n\t\tmptcp_subflow_drop_ctx(ssk);\n\t\tgoto out_release;\n\t}\n\n\tdispose_it = msk->free_first || ssk != msk->first;\n\tif (dispose_it)\n\t\tlist_del(&subflow->node);\n\n\tlock_sock_nested(ssk, SINGLE_DEPTH_NESTING);\n\n\tif ((flags & MPTCP_CF_FASTCLOSE) && !__mptcp_check_fallback(msk)) {\n\t\t \n\t\tssk->sk_lingertime = 0;\n\t\tsock_set_flag(ssk, SOCK_LINGER);\n\t\tsubflow->send_fastclose = 1;\n\t}\n\n\tneed_push = (flags & MPTCP_CF_PUSH) && __mptcp_retransmit_pending_data(sk);\n\tif (!dispose_it) {\n\t\t__mptcp_subflow_disconnect(ssk, subflow, flags);\n\t\trelease_sock(ssk);\n\n\t\tgoto out;\n\t}\n\n\tsubflow->disposable = 1;\n\n\t \n\tif (!inet_csk(ssk)->icsk_ulp_ops) {\n\t\tWARN_ON_ONCE(!sock_flag(ssk, SOCK_DEAD));\n\t\tkfree_rcu(subflow, rcu);\n\t} else {\n\t\t \n\t\t__tcp_close(ssk, 0);\n\n\t\t \n\t\t__sock_put(ssk);\n\t}\n\nout_release:\n\t__mptcp_subflow_error_report(sk, ssk);\n\trelease_sock(ssk);\n\n\tsock_put(ssk);\n\n\tif (ssk == msk->first)\n\t\tWRITE_ONCE(msk->first, NULL);\n\nout:\n\t__mptcp_sync_sndbuf(sk);\n\tif (need_push)\n\t\t__mptcp_push_pending(sk, 0);\n\n\t \n\tif (list_is_singular(&msk->conn_list) && msk->first &&\n\t    inet_sk_state_load(msk->first) == TCP_CLOSE) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED ||\n\t\t    msk->in_accept_queue || sock_flag(sk, SOCK_DEAD)) {\n\t\t\tinet_sk_state_store(sk, TCP_CLOSE);\n\t\t\tmptcp_close_wake_up(sk);\n\t\t} else {\n\t\t\tmptcp_start_tout_timer(sk);\n\t\t}\n\t}\n}\n\nvoid mptcp_close_ssk(struct sock *sk, struct sock *ssk,\n\t\t     struct mptcp_subflow_context *subflow)\n{\n\tif (sk->sk_state == TCP_ESTABLISHED)\n\t\tmptcp_event(MPTCP_EVENT_SUB_CLOSED, mptcp_sk(sk), ssk, GFP_KERNEL);\n\n\t \n\tmptcp_pm_subflow_check_next(mptcp_sk(sk), ssk, subflow);\n\n\t__mptcp_close_ssk(sk, ssk, subflow, MPTCP_CF_PUSH);\n}\n\nstatic unsigned int mptcp_sync_mss(struct sock *sk, u32 pmtu)\n{\n\treturn 0;\n}\n\nstatic void __mptcp_close_subflow(struct sock *sk)\n{\n\tstruct mptcp_subflow_context *subflow, *tmp;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tmight_sleep();\n\n\tmptcp_for_each_subflow_safe(msk, subflow, tmp) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\n\t\tif (inet_sk_state_load(ssk) != TCP_CLOSE)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!skb_queue_empty_lockless(&ssk->sk_receive_queue))\n\t\t\tcontinue;\n\n\t\tmptcp_close_ssk(sk, ssk, subflow);\n\t}\n\n}\n\nstatic bool mptcp_close_tout_expired(const struct sock *sk)\n{\n\tif (!inet_csk(sk)->icsk_mtup.probe_timestamp ||\n\t    sk->sk_state == TCP_CLOSE)\n\t\treturn false;\n\n\treturn time_after32(tcp_jiffies32,\n\t\t  inet_csk(sk)->icsk_mtup.probe_timestamp + TCP_TIMEWAIT_LEN);\n}\n\nstatic void mptcp_check_fastclose(struct mptcp_sock *msk)\n{\n\tstruct mptcp_subflow_context *subflow, *tmp;\n\tstruct sock *sk = (struct sock *)msk;\n\n\tif (likely(!READ_ONCE(msk->rcv_fastclose)))\n\t\treturn;\n\n\tmptcp_token_destroy(msk);\n\n\tmptcp_for_each_subflow_safe(msk, subflow, tmp) {\n\t\tstruct sock *tcp_sk = mptcp_subflow_tcp_sock(subflow);\n\t\tbool slow;\n\n\t\tslow = lock_sock_fast(tcp_sk);\n\t\tif (tcp_sk->sk_state != TCP_CLOSE) {\n\t\t\ttcp_send_active_reset(tcp_sk, GFP_ATOMIC);\n\t\t\ttcp_set_state(tcp_sk, TCP_CLOSE);\n\t\t}\n\t\tunlock_sock_fast(tcp_sk, slow);\n\t}\n\n\t \n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\t\tWRITE_ONCE(sk->sk_err, ECONNREFUSED);\n\t\tbreak;\n\tcase TCP_CLOSE_WAIT:\n\t\tWRITE_ONCE(sk->sk_err, EPIPE);\n\t\tbreak;\n\tcase TCP_CLOSE:\n\t\treturn;\n\tdefault:\n\t\tWRITE_ONCE(sk->sk_err, ECONNRESET);\n\t}\n\n\tinet_sk_state_store(sk, TCP_CLOSE);\n\tWRITE_ONCE(sk->sk_shutdown, SHUTDOWN_MASK);\n\tsmp_mb__before_atomic();  \n\tset_bit(MPTCP_WORK_CLOSE_SUBFLOW, &msk->flags);\n\n\t \n\tif (sock_flag(sk, SOCK_DEAD))\n\t\treturn;\n\n\tsk->sk_state_change(sk);\n\tsk_error_report(sk);\n}\n\nstatic void __mptcp_retrans(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct mptcp_subflow_context *subflow;\n\tstruct mptcp_sendmsg_info info = {};\n\tstruct mptcp_data_frag *dfrag;\n\tstruct sock *ssk;\n\tint ret, err;\n\tu16 len = 0;\n\n\tmptcp_clean_una_wakeup(sk);\n\n\t \n\terr = mptcp_sched_get_retrans(msk);\n\tdfrag = mptcp_rtx_head(sk);\n\tif (!dfrag) {\n\t\tif (mptcp_data_fin_enabled(msk)) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\t\t\ticsk->icsk_retransmits++;\n\t\t\tmptcp_set_datafin_timeout(sk);\n\t\t\tmptcp_send_ack(msk);\n\n\t\t\tgoto reset_timer;\n\t\t}\n\n\t\tif (!mptcp_send_head(sk))\n\t\t\treturn;\n\n\t\tgoto reset_timer;\n\t}\n\n\tif (err)\n\t\tgoto reset_timer;\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tif (READ_ONCE(subflow->scheduled)) {\n\t\t\tu16 copied = 0;\n\n\t\t\tmptcp_subflow_set_scheduled(subflow, false);\n\n\t\t\tssk = mptcp_subflow_tcp_sock(subflow);\n\n\t\t\tlock_sock(ssk);\n\n\t\t\t \n\t\t\tinfo.sent = 0;\n\t\t\tinfo.limit = READ_ONCE(msk->csum_enabled) ? dfrag->data_len :\n\t\t\t\t\t\t\t\t    dfrag->already_sent;\n\t\t\twhile (info.sent < info.limit) {\n\t\t\t\tret = mptcp_sendmsg_frag(sk, ssk, dfrag, &info);\n\t\t\t\tif (ret <= 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RETRANSSEGS);\n\t\t\t\tcopied += ret;\n\t\t\t\tinfo.sent += ret;\n\t\t\t}\n\t\t\tif (copied) {\n\t\t\t\tlen = max(copied, len);\n\t\t\t\ttcp_push(ssk, 0, info.mss_now, tcp_sk(ssk)->nonagle,\n\t\t\t\t\t info.size_goal);\n\t\t\t\tWRITE_ONCE(msk->allow_infinite_fallback, false);\n\t\t\t}\n\n\t\t\trelease_sock(ssk);\n\t\t}\n\t}\n\n\tmsk->bytes_retrans += len;\n\tdfrag->already_sent = max(dfrag->already_sent, len);\n\nreset_timer:\n\tmptcp_check_and_set_pending(sk);\n\n\tif (!mptcp_rtx_timer_pending(sk))\n\t\tmptcp_reset_rtx_timer(sk);\n}\n\n \nvoid mptcp_reset_tout_timer(struct mptcp_sock *msk, unsigned long fail_tout)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tunsigned long timeout, close_timeout;\n\n\tif (!fail_tout && !inet_csk(sk)->icsk_mtup.probe_timestamp)\n\t\treturn;\n\n\tclose_timeout = inet_csk(sk)->icsk_mtup.probe_timestamp - tcp_jiffies32 + jiffies +\n\t\t\tTCP_TIMEWAIT_LEN;\n\n\t \n\ttimeout = inet_csk(sk)->icsk_mtup.probe_timestamp ? close_timeout : fail_tout;\n\n\tsk_reset_timer(sk, &sk->sk_timer, timeout);\n}\n\nstatic void mptcp_mp_fail_no_response(struct mptcp_sock *msk)\n{\n\tstruct sock *ssk = msk->first;\n\tbool slow;\n\n\tif (!ssk)\n\t\treturn;\n\n\tpr_debug(\"MP_FAIL doesn't respond, reset the subflow\");\n\n\tslow = lock_sock_fast(ssk);\n\tmptcp_subflow_reset(ssk);\n\tWRITE_ONCE(mptcp_subflow_ctx(ssk)->fail_tout, 0);\n\tunlock_sock_fast(ssk, slow);\n}\n\nstatic void mptcp_do_fastclose(struct sock *sk)\n{\n\tstruct mptcp_subflow_context *subflow, *tmp;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tinet_sk_state_store(sk, TCP_CLOSE);\n\tmptcp_for_each_subflow_safe(msk, subflow, tmp)\n\t\t__mptcp_close_ssk(sk, mptcp_subflow_tcp_sock(subflow),\n\t\t\t\t  subflow, MPTCP_CF_FASTCLOSE);\n}\n\nstatic void mptcp_worker(struct work_struct *work)\n{\n\tstruct mptcp_sock *msk = container_of(work, struct mptcp_sock, work);\n\tstruct sock *sk = (struct sock *)msk;\n\tunsigned long fail_tout;\n\tint state;\n\n\tlock_sock(sk);\n\tstate = sk->sk_state;\n\tif (unlikely((1 << state) & (TCPF_CLOSE | TCPF_LISTEN)))\n\t\tgoto unlock;\n\n\tmptcp_check_fastclose(msk);\n\n\tmptcp_pm_nl_work(msk);\n\n\tmptcp_check_send_data_fin(sk);\n\tmptcp_check_data_fin_ack(sk);\n\tmptcp_check_data_fin(sk);\n\n\tif (test_and_clear_bit(MPTCP_WORK_CLOSE_SUBFLOW, &msk->flags))\n\t\t__mptcp_close_subflow(sk);\n\n\tif (mptcp_close_tout_expired(sk)) {\n\t\tmptcp_do_fastclose(sk);\n\t\tmptcp_close_wake_up(sk);\n\t}\n\n\tif (sock_flag(sk, SOCK_DEAD) && sk->sk_state == TCP_CLOSE) {\n\t\t__mptcp_destroy_sock(sk);\n\t\tgoto unlock;\n\t}\n\n\tif (test_and_clear_bit(MPTCP_WORK_RTX, &msk->flags))\n\t\t__mptcp_retrans(sk);\n\n\tfail_tout = msk->first ? READ_ONCE(mptcp_subflow_ctx(msk->first)->fail_tout) : 0;\n\tif (fail_tout && time_after(jiffies, fail_tout))\n\t\tmptcp_mp_fail_no_response(msk);\n\nunlock:\n\trelease_sock(sk);\n\tsock_put(sk);\n}\n\nstatic void __mptcp_init_sock(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tINIT_LIST_HEAD(&msk->conn_list);\n\tINIT_LIST_HEAD(&msk->join_list);\n\tINIT_LIST_HEAD(&msk->rtx_queue);\n\tINIT_WORK(&msk->work, mptcp_worker);\n\t__skb_queue_head_init(&msk->receive_queue);\n\tmsk->out_of_order_queue = RB_ROOT;\n\tmsk->first_pending = NULL;\n\tmsk->rmem_fwd_alloc = 0;\n\tWRITE_ONCE(msk->rmem_released, 0);\n\tmsk->timer_ival = TCP_RTO_MIN;\n\n\tWRITE_ONCE(msk->first, NULL);\n\tinet_csk(sk)->icsk_sync_mss = mptcp_sync_mss;\n\tWRITE_ONCE(msk->csum_enabled, mptcp_is_checksum_enabled(sock_net(sk)));\n\tWRITE_ONCE(msk->allow_infinite_fallback, true);\n\tmsk->recovery = false;\n\tmsk->subflow_id = 1;\n\n\tmptcp_pm_data_init(msk);\n\n\t \n\ttimer_setup(&msk->sk.icsk_retransmit_timer, mptcp_retransmit_timer, 0);\n\ttimer_setup(&sk->sk_timer, mptcp_tout_timer, 0);\n}\n\nstatic void mptcp_ca_reset(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\ttcp_assign_congestion_control(sk);\n\tstrcpy(mptcp_sk(sk)->ca_name, icsk->icsk_ca_ops->name);\n\n\t \n\ttcp_cleanup_congestion_control(sk);\n\ticsk->icsk_ca_ops = NULL;\n}\n\nstatic int mptcp_init_sock(struct sock *sk)\n{\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\n\t__mptcp_init_sock(sk);\n\n\tif (!mptcp_is_enabled(net))\n\t\treturn -ENOPROTOOPT;\n\n\tif (unlikely(!net->mib.mptcp_statistics) && !mptcp_mib_alloc(net))\n\t\treturn -ENOMEM;\n\n\tret = mptcp_init_sched(mptcp_sk(sk),\n\t\t\t       mptcp_sched_find(mptcp_get_scheduler(net)));\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(SOCK_CUSTOM_SOCKOPT, &sk->sk_socket->flags);\n\n\t \n\tmptcp_ca_reset(sk);\n\n\tsk_sockets_allocated_inc(sk);\n\tsk->sk_rcvbuf = READ_ONCE(net->ipv4.sysctl_tcp_rmem[1]);\n\tsk->sk_sndbuf = READ_ONCE(net->ipv4.sysctl_tcp_wmem[1]);\n\n\treturn 0;\n}\n\nstatic void __mptcp_clear_xmit(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct mptcp_data_frag *dtmp, *dfrag;\n\n\tWRITE_ONCE(msk->first_pending, NULL);\n\tlist_for_each_entry_safe(dfrag, dtmp, &msk->rtx_queue, list)\n\t\tdfrag_clear(sk, dfrag);\n}\n\nvoid mptcp_cancel_work(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tif (cancel_work_sync(&msk->work))\n\t\t__sock_put(sk);\n}\n\nvoid mptcp_subflow_shutdown(struct sock *sk, struct sock *ssk, int how)\n{\n\tlock_sock(ssk);\n\n\tswitch (ssk->sk_state) {\n\tcase TCP_LISTEN:\n\t\tif (!(how & RCV_SHUTDOWN))\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase TCP_SYN_SENT:\n\t\tWARN_ON_ONCE(tcp_disconnect(ssk, O_NONBLOCK));\n\t\tbreak;\n\tdefault:\n\t\tif (__mptcp_check_fallback(mptcp_sk(sk))) {\n\t\t\tpr_debug(\"Fallback\");\n\t\t\tssk->sk_shutdown |= how;\n\t\t\ttcp_shutdown(ssk, how);\n\n\t\t\t \n\t\t\tWRITE_ONCE(mptcp_sk(sk)->snd_una, mptcp_sk(sk)->snd_nxt);\n\t\t\tmptcp_schedule_work(sk);\n\t\t} else {\n\t\t\tpr_debug(\"Sending DATA_FIN on subflow %p\", ssk);\n\t\t\ttcp_send_ack(ssk);\n\t\t\tif (!mptcp_rtx_timer_pending(sk))\n\t\t\t\tmptcp_reset_rtx_timer(sk);\n\t\t}\n\t\tbreak;\n\t}\n\n\trelease_sock(ssk);\n}\n\nstatic const unsigned char new_state[16] = {\n\t \n\t[0  ] = TCP_CLOSE,\n\t[TCP_ESTABLISHED]   = TCP_FIN_WAIT1 | TCP_ACTION_FIN,\n\t[TCP_SYN_SENT]      = TCP_CLOSE,\n\t[TCP_SYN_RECV]      = TCP_FIN_WAIT1 | TCP_ACTION_FIN,\n\t[TCP_FIN_WAIT1]     = TCP_FIN_WAIT1,\n\t[TCP_FIN_WAIT2]     = TCP_FIN_WAIT2,\n\t[TCP_TIME_WAIT]     = TCP_CLOSE,\t \n\t[TCP_CLOSE]         = TCP_CLOSE,\n\t[TCP_CLOSE_WAIT]    = TCP_LAST_ACK  | TCP_ACTION_FIN,\n\t[TCP_LAST_ACK]      = TCP_LAST_ACK,\n\t[TCP_LISTEN]        = TCP_CLOSE,\n\t[TCP_CLOSING]       = TCP_CLOSING,\n\t[TCP_NEW_SYN_RECV]  = TCP_CLOSE,\t \n};\n\nstatic int mptcp_close_state(struct sock *sk)\n{\n\tint next = (int)new_state[sk->sk_state];\n\tint ns = next & TCP_STATE_MASK;\n\n\tinet_sk_state_store(sk, ns);\n\n\treturn next & TCP_ACTION_FIN;\n}\n\nstatic void mptcp_check_send_data_fin(struct sock *sk)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tpr_debug(\"msk=%p snd_data_fin_enable=%d pending=%d snd_nxt=%llu write_seq=%llu\",\n\t\t msk, msk->snd_data_fin_enable, !!mptcp_send_head(sk),\n\t\t msk->snd_nxt, msk->write_seq);\n\n\t \n\tif (!msk->snd_data_fin_enable || msk->snd_nxt + 1 != msk->write_seq ||\n\t    mptcp_send_head(sk))\n\t\treturn;\n\n\tWRITE_ONCE(msk->snd_nxt, msk->write_seq);\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *tcp_sk = mptcp_subflow_tcp_sock(subflow);\n\n\t\tmptcp_subflow_shutdown(sk, tcp_sk, SEND_SHUTDOWN);\n\t}\n}\n\nstatic void __mptcp_wr_shutdown(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tpr_debug(\"msk=%p snd_data_fin_enable=%d shutdown=%x state=%d pending=%d\",\n\t\t msk, msk->snd_data_fin_enable, sk->sk_shutdown, sk->sk_state,\n\t\t !!mptcp_send_head(sk));\n\n\t \n\tWRITE_ONCE(msk->write_seq, msk->write_seq + 1);\n\tWRITE_ONCE(msk->snd_data_fin_enable, 1);\n\n\tmptcp_check_send_data_fin(sk);\n}\n\nstatic void __mptcp_destroy_sock(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tpr_debug(\"msk=%p\", msk);\n\n\tmight_sleep();\n\n\tmptcp_stop_rtx_timer(sk);\n\tsk_stop_timer(sk, &sk->sk_timer);\n\tmsk->pm.status = 0;\n\tmptcp_release_sched(msk);\n\n\tsk->sk_prot->destroy(sk);\n\n\tWARN_ON_ONCE(msk->rmem_fwd_alloc);\n\tWARN_ON_ONCE(msk->rmem_released);\n\tsk_stream_kill_queues(sk);\n\txfrm_sk_free_policy(sk);\n\n\tsock_put(sk);\n}\n\nvoid __mptcp_unaccepted_force_close(struct sock *sk)\n{\n\tsock_set_flag(sk, SOCK_DEAD);\n\tmptcp_do_fastclose(sk);\n\t__mptcp_destroy_sock(sk);\n}\n\nstatic __poll_t mptcp_check_readable(struct mptcp_sock *msk)\n{\n\t \n\tif (skb_queue_empty_lockless(&((struct sock *)msk)->sk_receive_queue) &&\n\t    skb_queue_empty_lockless(&msk->receive_queue))\n\t\treturn 0;\n\n\treturn EPOLLIN | EPOLLRDNORM;\n}\n\nstatic void mptcp_check_listen_stop(struct sock *sk)\n{\n\tstruct sock *ssk;\n\n\tif (inet_sk_state_load(sk) != TCP_LISTEN)\n\t\treturn;\n\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tssk = mptcp_sk(sk)->first;\n\tif (WARN_ON_ONCE(!ssk || inet_sk_state_load(ssk) != TCP_LISTEN))\n\t\treturn;\n\n\tlock_sock_nested(ssk, SINGLE_DEPTH_NESTING);\n\ttcp_set_state(ssk, TCP_CLOSE);\n\tmptcp_subflow_queue_clean(sk, ssk);\n\tinet_csk_listen_stop(ssk);\n\tmptcp_event_pm_listener(ssk, MPTCP_EVENT_LISTENER_CLOSED);\n\trelease_sock(ssk);\n}\n\nbool __mptcp_close(struct sock *sk, long timeout)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tbool do_cancel_work = false;\n\tint subflows_alive = 0;\n\n\tWRITE_ONCE(sk->sk_shutdown, SHUTDOWN_MASK);\n\n\tif ((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) {\n\t\tmptcp_check_listen_stop(sk);\n\t\tinet_sk_state_store(sk, TCP_CLOSE);\n\t\tgoto cleanup;\n\t}\n\n\tif (mptcp_check_readable(msk) || timeout < 0) {\n\t\t \n\t\tmptcp_do_fastclose(sk);\n\t\ttimeout = 0;\n\t} else if (mptcp_close_state(sk)) {\n\t\t__mptcp_wr_shutdown(sk);\n\t}\n\n\tsk_stream_wait_close(sk, timeout);\n\ncleanup:\n\t \n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\t\tbool slow = lock_sock_fast_nested(ssk);\n\n\t\tsubflows_alive += ssk->sk_state != TCP_CLOSE;\n\n\t\t \n\t\tif (ssk == msk->first)\n\t\t\tsubflow->fail_tout = 0;\n\n\t\t \n\t\tssk->sk_socket = NULL;\n\t\tssk->sk_wq = NULL;\n\t\tunlock_sock_fast(ssk, slow);\n\t}\n\tsock_orphan(sk);\n\n\t \n\tif (subflows_alive == 0)\n\t\tinet_sk_state_store(sk, TCP_CLOSE);\n\n\tsock_hold(sk);\n\tpr_debug(\"msk=%p state=%d\", sk, sk->sk_state);\n\tif (msk->token)\n\t\tmptcp_event(MPTCP_EVENT_CLOSED, msk, NULL, GFP_KERNEL);\n\n\tif (sk->sk_state == TCP_CLOSE) {\n\t\t__mptcp_destroy_sock(sk);\n\t\tdo_cancel_work = true;\n\t} else {\n\t\tmptcp_start_tout_timer(sk);\n\t}\n\n\treturn do_cancel_work;\n}\n\nstatic void mptcp_close(struct sock *sk, long timeout)\n{\n\tbool do_cancel_work;\n\n\tlock_sock(sk);\n\n\tdo_cancel_work = __mptcp_close(sk, timeout);\n\trelease_sock(sk);\n\tif (do_cancel_work)\n\t\tmptcp_cancel_work(sk);\n\n\tsock_put(sk);\n}\n\nstatic void mptcp_copy_inaddrs(struct sock *msk, const struct sock *ssk)\n{\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\tconst struct ipv6_pinfo *ssk6 = inet6_sk(ssk);\n\tstruct ipv6_pinfo *msk6 = inet6_sk(msk);\n\n\tmsk->sk_v6_daddr = ssk->sk_v6_daddr;\n\tmsk->sk_v6_rcv_saddr = ssk->sk_v6_rcv_saddr;\n\n\tif (msk6 && ssk6) {\n\t\tmsk6->saddr = ssk6->saddr;\n\t\tmsk6->flow_label = ssk6->flow_label;\n\t}\n#endif\n\n\tinet_sk(msk)->inet_num = inet_sk(ssk)->inet_num;\n\tinet_sk(msk)->inet_dport = inet_sk(ssk)->inet_dport;\n\tinet_sk(msk)->inet_sport = inet_sk(ssk)->inet_sport;\n\tinet_sk(msk)->inet_daddr = inet_sk(ssk)->inet_daddr;\n\tinet_sk(msk)->inet_saddr = inet_sk(ssk)->inet_saddr;\n\tinet_sk(msk)->inet_rcv_saddr = inet_sk(ssk)->inet_rcv_saddr;\n}\n\nstatic int mptcp_disconnect(struct sock *sk, int flags)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\t \n\tif (msk->fastopening)\n\t\treturn -EBUSY;\n\n\tmptcp_check_listen_stop(sk);\n\tinet_sk_state_store(sk, TCP_CLOSE);\n\n\tmptcp_stop_rtx_timer(sk);\n\tmptcp_stop_tout_timer(sk);\n\n\tif (msk->token)\n\t\tmptcp_event(MPTCP_EVENT_CLOSED, msk, NULL, GFP_KERNEL);\n\n\t \n\tmptcp_destroy_common(msk, MPTCP_CF_FASTCLOSE);\n\tWRITE_ONCE(msk->flags, 0);\n\tmsk->cb_flags = 0;\n\tmsk->push_pending = 0;\n\tmsk->recovery = false;\n\tmsk->can_ack = false;\n\tmsk->fully_established = false;\n\tmsk->rcv_data_fin = false;\n\tmsk->snd_data_fin_enable = false;\n\tmsk->rcv_fastclose = false;\n\tmsk->use_64bit_ack = false;\n\tWRITE_ONCE(msk->csum_enabled, mptcp_is_checksum_enabled(sock_net(sk)));\n\tmptcp_pm_data_reset(msk);\n\tmptcp_ca_reset(sk);\n\tmsk->bytes_acked = 0;\n\tmsk->bytes_received = 0;\n\tmsk->bytes_sent = 0;\n\tmsk->bytes_retrans = 0;\n\n\tWRITE_ONCE(sk->sk_shutdown, 0);\n\tsk_error_report(sk);\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\nstatic struct ipv6_pinfo *mptcp_inet6_sk(const struct sock *sk)\n{\n\tunsigned int offset = sizeof(struct mptcp6_sock) - sizeof(struct ipv6_pinfo);\n\n\treturn (struct ipv6_pinfo *)(((u8 *)sk) + offset);\n}\n#endif\n\nstruct sock *mptcp_sk_clone_init(const struct sock *sk,\n\t\t\t\t const struct mptcp_options_received *mp_opt,\n\t\t\t\t struct sock *ssk,\n\t\t\t\t struct request_sock *req)\n{\n\tstruct mptcp_subflow_request_sock *subflow_req = mptcp_subflow_rsk(req);\n\tstruct sock *nsk = sk_clone_lock(sk, GFP_ATOMIC);\n\tstruct mptcp_sock *msk;\n\n\tif (!nsk)\n\t\treturn NULL;\n\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\tif (nsk->sk_family == AF_INET6)\n\t\tinet_sk(nsk)->pinet6 = mptcp_inet6_sk(nsk);\n#endif\n\n\t__mptcp_init_sock(nsk);\n\n\tmsk = mptcp_sk(nsk);\n\tmsk->local_key = subflow_req->local_key;\n\tmsk->token = subflow_req->token;\n\tmsk->in_accept_queue = 1;\n\tWRITE_ONCE(msk->fully_established, false);\n\tif (mp_opt->suboptions & OPTION_MPTCP_CSUMREQD)\n\t\tWRITE_ONCE(msk->csum_enabled, true);\n\n\tmsk->write_seq = subflow_req->idsn + 1;\n\tmsk->snd_nxt = msk->write_seq;\n\tmsk->snd_una = msk->write_seq;\n\tmsk->wnd_end = msk->snd_nxt + req->rsk_rcv_wnd;\n\tmsk->setsockopt_seq = mptcp_sk(sk)->setsockopt_seq;\n\tmptcp_init_sched(msk, mptcp_sk(sk)->sched);\n\n\t \n\tmsk->subflow_id = 2;\n\n\tsock_reset_flag(nsk, SOCK_RCU_FREE);\n\tsecurity_inet_csk_clone(nsk, req);\n\n\t \n\tinet_sk_state_store(nsk, TCP_ESTABLISHED);\n\n\t \n\tWRITE_ONCE(msk->first, ssk);\n\tlist_add(&mptcp_subflow_ctx(ssk)->node, &msk->conn_list);\n\tsock_hold(ssk);\n\n\t \n\tmptcp_token_accept(subflow_req, msk);\n\n\t \n\tmptcp_copy_inaddrs(nsk, ssk);\n\t__mptcp_propagate_sndbuf(nsk, ssk);\n\n\tmptcp_rcv_space_init(msk, ssk);\n\tbh_unlock_sock(nsk);\n\n\t \n\treturn nsk;\n}\n\nvoid mptcp_rcv_space_init(struct mptcp_sock *msk, const struct sock *ssk)\n{\n\tconst struct tcp_sock *tp = tcp_sk(ssk);\n\n\tmsk->rcvq_space.copied = 0;\n\tmsk->rcvq_space.rtt_us = 0;\n\n\tmsk->rcvq_space.time = tp->tcp_mstamp;\n\n\t \n\tmsk->rcvq_space.space = min_t(u32, tp->rcv_wnd,\n\t\t\t\t      TCP_INIT_CWND * tp->advmss);\n\tif (msk->rcvq_space.space == 0)\n\t\tmsk->rcvq_space.space = TCP_INIT_CWND * TCP_MSS_DEFAULT;\n\n\tWRITE_ONCE(msk->wnd_end, msk->snd_nxt + tcp_sk(ssk)->snd_wnd);\n}\n\nstatic struct sock *mptcp_accept(struct sock *ssk, int flags, int *err,\n\t\t\t\t bool kern)\n{\n\tstruct sock *newsk;\n\n\tpr_debug(\"ssk=%p, listener=%p\", ssk, mptcp_subflow_ctx(ssk));\n\tnewsk = inet_csk_accept(ssk, flags, err, kern);\n\tif (!newsk)\n\t\treturn NULL;\n\n\tpr_debug(\"newsk=%p, subflow is mptcp=%d\", newsk, sk_is_mptcp(newsk));\n\tif (sk_is_mptcp(newsk)) {\n\t\tstruct mptcp_subflow_context *subflow;\n\t\tstruct sock *new_mptcp_sock;\n\n\t\tsubflow = mptcp_subflow_ctx(newsk);\n\t\tnew_mptcp_sock = subflow->conn;\n\n\t\t \n\t\tif (WARN_ON_ONCE(!new_mptcp_sock)) {\n\t\t\ttcp_sk(newsk)->is_mptcp = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnewsk = new_mptcp_sock;\n\t\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_MPCAPABLEPASSIVEACK);\n\t} else {\n\t\tMPTCP_INC_STATS(sock_net(ssk),\n\t\t\t\tMPTCP_MIB_MPCAPABLEPASSIVEFALLBACK);\n\t}\n\nout:\n\tnewsk->sk_kern_sock = kern;\n\treturn newsk;\n}\n\nvoid mptcp_destroy_common(struct mptcp_sock *msk, unsigned int flags)\n{\n\tstruct mptcp_subflow_context *subflow, *tmp;\n\tstruct sock *sk = (struct sock *)msk;\n\n\t__mptcp_clear_xmit(sk);\n\n\t \n\tmptcp_for_each_subflow_safe(msk, subflow, tmp)\n\t\t__mptcp_close_ssk(sk, mptcp_subflow_tcp_sock(subflow), subflow, flags);\n\n\t \n\tmptcp_data_lock(sk);\n\tskb_queue_splice_tail_init(&msk->receive_queue, &sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\tskb_rbtree_purge(&msk->out_of_order_queue);\n\tmptcp_data_unlock(sk);\n\n\t \n\tsk_forward_alloc_add(sk, msk->rmem_fwd_alloc);\n\tWRITE_ONCE(msk->rmem_fwd_alloc, 0);\n\tmptcp_token_destroy(msk);\n\tmptcp_pm_free_anno_list(msk);\n\tmptcp_free_local_addr_list(msk);\n}\n\nstatic void mptcp_destroy(struct sock *sk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\t \n\tmsk->free_first = 1;\n\tmptcp_destroy_common(msk, 0);\n\tsk_sockets_allocated_dec(sk);\n}\n\nvoid __mptcp_data_acked(struct sock *sk)\n{\n\tif (!sock_owned_by_user(sk))\n\t\t__mptcp_clean_una(sk);\n\telse\n\t\t__set_bit(MPTCP_CLEAN_UNA, &mptcp_sk(sk)->cb_flags);\n\n\tif (mptcp_pending_data_fin_ack(sk))\n\t\tmptcp_schedule_work(sk);\n}\n\nvoid __mptcp_check_push(struct sock *sk, struct sock *ssk)\n{\n\tif (!mptcp_send_head(sk))\n\t\treturn;\n\n\tif (!sock_owned_by_user(sk))\n\t\t__mptcp_subflow_push_pending(sk, ssk, false);\n\telse\n\t\t__set_bit(MPTCP_PUSH_PENDING, &mptcp_sk(sk)->cb_flags);\n}\n\n#define MPTCP_FLAGS_PROCESS_CTX_NEED (BIT(MPTCP_PUSH_PENDING) | \\\n\t\t\t\t      BIT(MPTCP_RETRANSMIT) | \\\n\t\t\t\t      BIT(MPTCP_FLUSH_JOIN_LIST))\n\n \nstatic void mptcp_release_cb(struct sock *sk)\n\t__must_hold(&sk->sk_lock.slock)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tfor (;;) {\n\t\tunsigned long flags = (msk->cb_flags & MPTCP_FLAGS_PROCESS_CTX_NEED) |\n\t\t\t\t      msk->push_pending;\n\t\tstruct list_head join_list;\n\n\t\tif (!flags)\n\t\t\tbreak;\n\n\t\tINIT_LIST_HEAD(&join_list);\n\t\tlist_splice_init(&msk->join_list, &join_list);\n\n\t\t \n\t\tmsk->push_pending = 0;\n\t\tmsk->cb_flags &= ~flags;\n\t\tspin_unlock_bh(&sk->sk_lock.slock);\n\n\t\tif (flags & BIT(MPTCP_FLUSH_JOIN_LIST))\n\t\t\t__mptcp_flush_join_list(sk, &join_list);\n\t\tif (flags & BIT(MPTCP_PUSH_PENDING))\n\t\t\t__mptcp_push_pending(sk, 0);\n\t\tif (flags & BIT(MPTCP_RETRANSMIT))\n\t\t\t__mptcp_retrans(sk);\n\n\t\tcond_resched();\n\t\tspin_lock_bh(&sk->sk_lock.slock);\n\t}\n\n\tif (__test_and_clear_bit(MPTCP_CLEAN_UNA, &msk->cb_flags))\n\t\t__mptcp_clean_una_wakeup(sk);\n\tif (unlikely(msk->cb_flags)) {\n\t\t \n\t\tif (__test_and_clear_bit(MPTCP_SYNC_STATE, &msk->cb_flags) && msk->first)\n\t\t\t__mptcp_sync_state(sk, msk->pending_state);\n\t\tif (__test_and_clear_bit(MPTCP_ERROR_REPORT, &msk->cb_flags))\n\t\t\t__mptcp_error_report(sk);\n\t\tif (__test_and_clear_bit(MPTCP_SYNC_SNDBUF, &msk->cb_flags))\n\t\t\t__mptcp_sync_sndbuf(sk);\n\t}\n\n\t__mptcp_update_rmem(sk);\n}\n\n \nstatic void schedule_3rdack_retransmission(struct sock *ssk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(ssk);\n\tstruct tcp_sock *tp = tcp_sk(ssk);\n\tunsigned long timeout;\n\n\tif (mptcp_subflow_ctx(ssk)->fully_established)\n\t\treturn;\n\n\t \n\tif (tp->srtt_us)\n\t\ttimeout = usecs_to_jiffies(tp->srtt_us >> (3 - 1));\n\telse\n\t\ttimeout = TCP_TIMEOUT_INIT;\n\ttimeout += jiffies;\n\n\tWARN_ON_ONCE(icsk->icsk_ack.pending & ICSK_ACK_TIMER);\n\ticsk->icsk_ack.pending |= ICSK_ACK_SCHED | ICSK_ACK_TIMER;\n\ticsk->icsk_ack.timeout = timeout;\n\tsk_reset_timer(ssk, &icsk->icsk_delack_timer, timeout);\n}\n\nvoid mptcp_subflow_process_delegated(struct sock *ssk, long status)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tstruct sock *sk = subflow->conn;\n\n\tif (status & BIT(MPTCP_DELEGATE_SEND)) {\n\t\tmptcp_data_lock(sk);\n\t\tif (!sock_owned_by_user(sk))\n\t\t\t__mptcp_subflow_push_pending(sk, ssk, true);\n\t\telse\n\t\t\t__set_bit(MPTCP_PUSH_PENDING, &mptcp_sk(sk)->cb_flags);\n\t\tmptcp_data_unlock(sk);\n\t}\n\tif (status & BIT(MPTCP_DELEGATE_SNDBUF)) {\n\t\tmptcp_data_lock(sk);\n\t\tif (!sock_owned_by_user(sk))\n\t\t\t__mptcp_sync_sndbuf(sk);\n\t\telse\n\t\t\t__set_bit(MPTCP_SYNC_SNDBUF, &mptcp_sk(sk)->cb_flags);\n\t\tmptcp_data_unlock(sk);\n\t}\n\tif (status & BIT(MPTCP_DELEGATE_ACK))\n\t\tschedule_3rdack_retransmission(ssk);\n}\n\nstatic int mptcp_hash(struct sock *sk)\n{\n\t \n\tWARN_ON_ONCE(1);\n\treturn 0;\n}\n\nstatic void mptcp_unhash(struct sock *sk)\n{\n\t \n}\n\nstatic int mptcp_get_port(struct sock *sk, unsigned short snum)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tpr_debug(\"msk=%p, ssk=%p\", msk, msk->first);\n\tif (WARN_ON_ONCE(!msk->first))\n\t\treturn -EINVAL;\n\n\treturn inet_csk_get_port(msk->first, snum);\n}\n\nvoid mptcp_finish_connect(struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct mptcp_sock *msk;\n\tstruct sock *sk;\n\n\tsubflow = mptcp_subflow_ctx(ssk);\n\tsk = subflow->conn;\n\tmsk = mptcp_sk(sk);\n\n\tpr_debug(\"msk=%p, token=%u\", sk, subflow->token);\n\n\tsubflow->map_seq = subflow->iasn;\n\tsubflow->map_subflow_seq = 1;\n\n\t \n\tWRITE_ONCE(msk->local_key, subflow->local_key);\n\tWRITE_ONCE(msk->write_seq, subflow->idsn + 1);\n\tWRITE_ONCE(msk->snd_nxt, msk->write_seq);\n\tWRITE_ONCE(msk->snd_una, msk->write_seq);\n\n\tmptcp_pm_new_connection(msk, ssk, 0);\n\n\tmptcp_rcv_space_init(msk, ssk);\n}\n\nvoid mptcp_sock_graft(struct sock *sk, struct socket *parent)\n{\n\twrite_lock_bh(&sk->sk_callback_lock);\n\trcu_assign_pointer(sk->sk_wq, &parent->wq);\n\tsk_set_socket(sk, parent);\n\tsk->sk_uid = SOCK_INODE(parent)->i_uid;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nbool mptcp_finish_join(struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\tstruct sock *parent = (void *)msk;\n\tbool ret = true;\n\n\tpr_debug(\"msk=%p, subflow=%p\", msk, subflow);\n\n\t \n\tif (!mptcp_is_fully_established(parent)) {\n\t\tsubflow->reset_reason = MPTCP_RST_EMPTCP;\n\t\treturn false;\n\t}\n\n\t \n\tif (!list_empty(&subflow->node)) {\n\t\tmptcp_subflow_joined(msk, ssk);\n\t\tmptcp_propagate_sndbuf(parent, ssk);\n\t\treturn true;\n\t}\n\n\tif (!mptcp_pm_allow_new_subflow(msk))\n\t\tgoto err_prohibited;\n\n\t \n\tmptcp_data_lock(parent);\n\tif (!sock_owned_by_user(parent)) {\n\t\tret = __mptcp_finish_join(msk, ssk);\n\t\tif (ret) {\n\t\t\tsock_hold(ssk);\n\t\t\tlist_add_tail(&subflow->node, &msk->conn_list);\n\t\t}\n\t} else {\n\t\tsock_hold(ssk);\n\t\tlist_add_tail(&subflow->node, &msk->join_list);\n\t\t__set_bit(MPTCP_FLUSH_JOIN_LIST, &msk->cb_flags);\n\t}\n\tmptcp_data_unlock(parent);\n\n\tif (!ret) {\nerr_prohibited:\n\t\tsubflow->reset_reason = MPTCP_RST_EPROHIBIT;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void mptcp_shutdown(struct sock *sk, int how)\n{\n\tpr_debug(\"sk=%p, how=%d\", sk, how);\n\n\tif ((how & SEND_SHUTDOWN) && mptcp_close_state(sk))\n\t\t__mptcp_wr_shutdown(sk);\n}\n\nstatic int mptcp_forward_alloc_get(const struct sock *sk)\n{\n\treturn READ_ONCE(sk->sk_forward_alloc) +\n\t       READ_ONCE(mptcp_sk(sk)->rmem_fwd_alloc);\n}\n\nstatic int mptcp_ioctl_outq(const struct mptcp_sock *msk, u64 v)\n{\n\tconst struct sock *sk = (void *)msk;\n\tu64 delta;\n\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn -EINVAL;\n\n\tif ((1 << sk->sk_state) & (TCPF_SYN_SENT | TCPF_SYN_RECV))\n\t\treturn 0;\n\n\tdelta = msk->write_seq - v;\n\tif (__mptcp_check_fallback(msk) && msk->first) {\n\t\tstruct tcp_sock *tp = tcp_sk(msk->first);\n\n\t\t \n\t\tif (!((1 << msk->first->sk_state) &\n\t\t      (TCPF_SYN_SENT | TCPF_SYN_RECV | TCPF_CLOSE)))\n\t\t\tdelta += READ_ONCE(tp->write_seq) - tp->snd_una;\n\t}\n\tif (delta > INT_MAX)\n\t\tdelta = INT_MAX;\n\n\treturn (int)delta;\n}\n\nstatic int mptcp_ioctl(struct sock *sk, int cmd, int *karg)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tbool slow;\n\n\tswitch (cmd) {\n\tcase SIOCINQ:\n\t\tif (sk->sk_state == TCP_LISTEN)\n\t\t\treturn -EINVAL;\n\n\t\tlock_sock(sk);\n\t\t__mptcp_move_skbs(msk);\n\t\t*karg = mptcp_inq_hint(sk);\n\t\trelease_sock(sk);\n\t\tbreak;\n\tcase SIOCOUTQ:\n\t\tslow = lock_sock_fast(sk);\n\t\t*karg = mptcp_ioctl_outq(msk, READ_ONCE(msk->snd_una));\n\t\tunlock_sock_fast(sk, slow);\n\t\tbreak;\n\tcase SIOCOUTQNSD:\n\t\tslow = lock_sock_fast(sk);\n\t\t*karg = mptcp_ioctl_outq(msk, msk->snd_nxt);\n\t\tunlock_sock_fast(sk, slow);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic void mptcp_subflow_early_fallback(struct mptcp_sock *msk,\n\t\t\t\t\t struct mptcp_subflow_context *subflow)\n{\n\tsubflow->request_mptcp = 0;\n\t__mptcp_do_fallback(msk);\n}\n\nstatic int mptcp_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tint err = -EINVAL;\n\tstruct sock *ssk;\n\n\tssk = __mptcp_nmpc_sk(msk);\n\tif (IS_ERR(ssk))\n\t\treturn PTR_ERR(ssk);\n\n\tinet_sk_state_store(sk, TCP_SYN_SENT);\n\tsubflow = mptcp_subflow_ctx(ssk);\n#ifdef CONFIG_TCP_MD5SIG\n\t \n\tif (rcu_access_pointer(tcp_sk(ssk)->md5sig_info))\n\t\tmptcp_subflow_early_fallback(msk, subflow);\n#endif\n\tif (subflow->request_mptcp && mptcp_token_new_connect(ssk)) {\n\t\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_TOKENFALLBACKINIT);\n\t\tmptcp_subflow_early_fallback(msk, subflow);\n\t}\n\tif (likely(!__mptcp_check_fallback(msk)))\n\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPCAPABLEACTIVE);\n\n\t \n\tif (!msk->fastopening)\n\t\tlock_sock(ssk);\n\n\t \n\tif (ssk->sk_state != TCP_CLOSE)\n\t\tgoto out;\n\n\tif (BPF_CGROUP_PRE_CONNECT_ENABLED(ssk)) {\n\t\terr = ssk->sk_prot->pre_connect(ssk, uaddr, addr_len);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = ssk->sk_prot->connect(ssk, uaddr, addr_len);\n\tif (err < 0)\n\t\tgoto out;\n\n\tinet_assign_bit(DEFER_CONNECT, sk, inet_test_bit(DEFER_CONNECT, ssk));\n\nout:\n\tif (!msk->fastopening)\n\t\trelease_sock(ssk);\n\n\t \n\tif (unlikely(err)) {\n\t\t \n\t\tmptcp_token_destroy(msk);\n\t\tinet_sk_state_store(sk, TCP_CLOSE);\n\t\treturn err;\n\t}\n\n\tmptcp_copy_inaddrs(sk, ssk);\n\treturn 0;\n}\n\nstatic struct proto mptcp_prot = {\n\t.name\t\t= \"MPTCP\",\n\t.owner\t\t= THIS_MODULE,\n\t.init\t\t= mptcp_init_sock,\n\t.connect\t= mptcp_connect,\n\t.disconnect\t= mptcp_disconnect,\n\t.close\t\t= mptcp_close,\n\t.accept\t\t= mptcp_accept,\n\t.setsockopt\t= mptcp_setsockopt,\n\t.getsockopt\t= mptcp_getsockopt,\n\t.shutdown\t= mptcp_shutdown,\n\t.destroy\t= mptcp_destroy,\n\t.sendmsg\t= mptcp_sendmsg,\n\t.ioctl\t\t= mptcp_ioctl,\n\t.recvmsg\t= mptcp_recvmsg,\n\t.release_cb\t= mptcp_release_cb,\n\t.hash\t\t= mptcp_hash,\n\t.unhash\t\t= mptcp_unhash,\n\t.get_port\t= mptcp_get_port,\n\t.forward_alloc_get\t= mptcp_forward_alloc_get,\n\t.sockets_allocated\t= &mptcp_sockets_allocated,\n\n\t.memory_allocated\t= &tcp_memory_allocated,\n\t.per_cpu_fw_alloc\t= &tcp_memory_per_cpu_fw_alloc,\n\n\t.memory_pressure\t= &tcp_memory_pressure,\n\t.sysctl_wmem_offset\t= offsetof(struct net, ipv4.sysctl_tcp_wmem),\n\t.sysctl_rmem_offset\t= offsetof(struct net, ipv4.sysctl_tcp_rmem),\n\t.sysctl_mem\t= sysctl_tcp_mem,\n\t.obj_size\t= sizeof(struct mptcp_sock),\n\t.slab_flags\t= SLAB_TYPESAFE_BY_RCU,\n\t.no_autobind\t= true,\n};\n\nstatic int mptcp_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sock->sk);\n\tstruct sock *ssk, *sk = sock->sk;\n\tint err = -EINVAL;\n\n\tlock_sock(sk);\n\tssk = __mptcp_nmpc_sk(msk);\n\tif (IS_ERR(ssk)) {\n\t\terr = PTR_ERR(ssk);\n\t\tgoto unlock;\n\t}\n\n\tif (sk->sk_family == AF_INET)\n\t\terr = inet_bind_sk(ssk, uaddr, addr_len);\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\telse if (sk->sk_family == AF_INET6)\n\t\terr = inet6_bind_sk(ssk, uaddr, addr_len);\n#endif\n\tif (!err)\n\t\tmptcp_copy_inaddrs(sk, ssk);\n\nunlock:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int mptcp_listen(struct socket *sock, int backlog)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sock->sk);\n\tstruct sock *sk = sock->sk;\n\tstruct sock *ssk;\n\tint err;\n\n\tpr_debug(\"msk=%p\", msk);\n\n\tlock_sock(sk);\n\n\terr = -EINVAL;\n\tif (sock->state != SS_UNCONNECTED || sock->type != SOCK_STREAM)\n\t\tgoto unlock;\n\n\tssk = __mptcp_nmpc_sk(msk);\n\tif (IS_ERR(ssk)) {\n\t\terr = PTR_ERR(ssk);\n\t\tgoto unlock;\n\t}\n\n\tinet_sk_state_store(sk, TCP_LISTEN);\n\tsock_set_flag(sk, SOCK_RCU_FREE);\n\n\tlock_sock(ssk);\n\terr = __inet_listen_sk(ssk, backlog);\n\trelease_sock(ssk);\n\tinet_sk_state_store(sk, inet_sk_state_load(ssk));\n\n\tif (!err) {\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t\tmptcp_copy_inaddrs(sk, ssk);\n\t\tmptcp_event_pm_listener(ssk, MPTCP_EVENT_LISTENER_CREATED);\n\t}\n\nunlock:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int mptcp_stream_accept(struct socket *sock, struct socket *newsock,\n\t\t\t       int flags, bool kern)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sock->sk);\n\tstruct sock *ssk, *newsk;\n\tint err;\n\n\tpr_debug(\"msk=%p\", msk);\n\n\t \n\tssk = READ_ONCE(msk->first);\n\tif (!ssk)\n\t\treturn -EINVAL;\n\n\tnewsk = mptcp_accept(ssk, flags, &err, kern);\n\tif (!newsk)\n\t\treturn err;\n\n\tlock_sock(newsk);\n\n\t__inet_accept(sock, newsock, newsk);\n\tif (!mptcp_is_tcpsk(newsock->sk)) {\n\t\tstruct mptcp_sock *msk = mptcp_sk(newsk);\n\t\tstruct mptcp_subflow_context *subflow;\n\n\t\tset_bit(SOCK_CUSTOM_SOCKOPT, &newsock->flags);\n\t\tmsk->in_accept_queue = 0;\n\n\t\t \n\t\tmptcp_for_each_subflow(msk, subflow) {\n\t\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\n\t\t\tif (!ssk->sk_socket)\n\t\t\t\tmptcp_sock_graft(ssk, newsock);\n\t\t}\n\n\t\t \n\t\tif (unlikely(inet_sk_state_load(msk->first) == TCP_CLOSE)) {\n\t\t\t__mptcp_close_ssk(newsk, msk->first,\n\t\t\t\t\t  mptcp_subflow_ctx(msk->first), 0);\n\t\t\tif (unlikely(list_is_singular(&msk->conn_list)))\n\t\t\t\tinet_sk_state_store(newsk, TCP_CLOSE);\n\t\t}\n\t}\n\trelease_sock(newsk);\n\n\treturn 0;\n}\n\nstatic __poll_t mptcp_check_writeable(struct mptcp_sock *msk)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\n\tif (sk_stream_is_writeable(sk))\n\t\treturn EPOLLOUT | EPOLLWRNORM;\n\n\tmptcp_set_nospace(sk);\n\tsmp_mb__after_atomic();  \n\tif (sk_stream_is_writeable(sk))\n\t\treturn EPOLLOUT | EPOLLWRNORM;\n\n\treturn 0;\n}\n\nstatic __poll_t mptcp_poll(struct file *file, struct socket *sock,\n\t\t\t   struct poll_table_struct *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct mptcp_sock *msk;\n\t__poll_t mask = 0;\n\tu8 shutdown;\n\tint state;\n\n\tmsk = mptcp_sk(sk);\n\tsock_poll_wait(file, sock, wait);\n\n\tstate = inet_sk_state_load(sk);\n\tpr_debug(\"msk=%p state=%d flags=%lx\", msk, state, msk->flags);\n\tif (state == TCP_LISTEN) {\n\t\tstruct sock *ssk = READ_ONCE(msk->first);\n\n\t\tif (WARN_ON_ONCE(!ssk))\n\t\t\treturn 0;\n\n\t\treturn inet_csk_listen_poll(ssk);\n\t}\n\n\tshutdown = READ_ONCE(sk->sk_shutdown);\n\tif (shutdown == SHUTDOWN_MASK || state == TCP_CLOSE)\n\t\tmask |= EPOLLHUP;\n\tif (shutdown & RCV_SHUTDOWN)\n\t\tmask |= EPOLLIN | EPOLLRDNORM | EPOLLRDHUP;\n\n\tif (state != TCP_SYN_SENT && state != TCP_SYN_RECV) {\n\t\tmask |= mptcp_check_readable(msk);\n\t\tif (shutdown & SEND_SHUTDOWN)\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t\telse\n\t\t\tmask |= mptcp_check_writeable(msk);\n\t} else if (state == TCP_SYN_SENT &&\n\t\t   inet_test_bit(DEFER_CONNECT, sk)) {\n\t\t \n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t}\n\n\t \n\tsmp_rmb();\n\tif (READ_ONCE(sk->sk_err))\n\t\tmask |= EPOLLERR;\n\n\treturn mask;\n}\n\nstatic const struct proto_ops mptcp_stream_ops = {\n\t.family\t\t   = PF_INET,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet_release,\n\t.bind\t\t   = mptcp_bind,\n\t.connect\t   = inet_stream_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = mptcp_stream_accept,\n\t.getname\t   = inet_getname,\n\t.poll\t\t   = mptcp_poll,\n\t.ioctl\t\t   = inet_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = mptcp_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet_sendmsg,\n\t.recvmsg\t   = inet_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n};\n\nstatic struct inet_protosw mptcp_protosw = {\n\t.type\t\t= SOCK_STREAM,\n\t.protocol\t= IPPROTO_MPTCP,\n\t.prot\t\t= &mptcp_prot,\n\t.ops\t\t= &mptcp_stream_ops,\n\t.flags\t\t= INET_PROTOSW_ICSK,\n};\n\nstatic int mptcp_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct mptcp_delegated_action *delegated;\n\tstruct mptcp_subflow_context *subflow;\n\tint work_done = 0;\n\n\tdelegated = container_of(napi, struct mptcp_delegated_action, napi);\n\twhile ((subflow = mptcp_subflow_delegated_next(delegated)) != NULL) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\n\t\tbh_lock_sock_nested(ssk);\n\t\tif (!sock_owned_by_user(ssk)) {\n\t\t\tmptcp_subflow_process_delegated(ssk, xchg(&subflow->delegated_status, 0));\n\t\t} else {\n\t\t\t \n\t\t\tsmp_wmb();\n\t\t\tclear_bit(MPTCP_DELEGATE_SCHEDULED, &subflow->delegated_status);\n\t\t}\n\t\tbh_unlock_sock(ssk);\n\t\tsock_put(ssk);\n\n\t\tif (++work_done == budget)\n\t\t\treturn budget;\n\t}\n\n\t \n\tnapi_complete_done(napi, 0);\n\treturn work_done;\n}\n\nvoid __init mptcp_proto_init(void)\n{\n\tstruct mptcp_delegated_action *delegated;\n\tint cpu;\n\n\tmptcp_prot.h.hashinfo = tcp_prot.h.hashinfo;\n\n\tif (percpu_counter_init(&mptcp_sockets_allocated, 0, GFP_KERNEL))\n\t\tpanic(\"Failed to allocate MPTCP pcpu counter\\n\");\n\n\tinit_dummy_netdev(&mptcp_napi_dev);\n\tfor_each_possible_cpu(cpu) {\n\t\tdelegated = per_cpu_ptr(&mptcp_delegated_actions, cpu);\n\t\tINIT_LIST_HEAD(&delegated->head);\n\t\tnetif_napi_add_tx(&mptcp_napi_dev, &delegated->napi,\n\t\t\t\t  mptcp_napi_poll);\n\t\tnapi_enable(&delegated->napi);\n\t}\n\n\tmptcp_subflow_init();\n\tmptcp_pm_init();\n\tmptcp_sched_init();\n\tmptcp_token_init();\n\n\tif (proto_register(&mptcp_prot, 1) != 0)\n\t\tpanic(\"Failed to register MPTCP proto.\\n\");\n\n\tinet_register_protosw(&mptcp_protosw);\n\n\tBUILD_BUG_ON(sizeof(struct mptcp_skb_cb) > sizeof_field(struct sk_buff, cb));\n}\n\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\nstatic const struct proto_ops mptcp_v6_stream_ops = {\n\t.family\t\t   = PF_INET6,\n\t.owner\t\t   = THIS_MODULE,\n\t.release\t   = inet6_release,\n\t.bind\t\t   = mptcp_bind,\n\t.connect\t   = inet_stream_connect,\n\t.socketpair\t   = sock_no_socketpair,\n\t.accept\t\t   = mptcp_stream_accept,\n\t.getname\t   = inet6_getname,\n\t.poll\t\t   = mptcp_poll,\n\t.ioctl\t\t   = inet6_ioctl,\n\t.gettstamp\t   = sock_gettstamp,\n\t.listen\t\t   = mptcp_listen,\n\t.shutdown\t   = inet_shutdown,\n\t.setsockopt\t   = sock_common_setsockopt,\n\t.getsockopt\t   = sock_common_getsockopt,\n\t.sendmsg\t   = inet6_sendmsg,\n\t.recvmsg\t   = inet6_recvmsg,\n\t.mmap\t\t   = sock_no_mmap,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t   = inet6_compat_ioctl,\n#endif\n};\n\nstatic struct proto mptcp_v6_prot;\n\nstatic struct inet_protosw mptcp_v6_protosw = {\n\t.type\t\t= SOCK_STREAM,\n\t.protocol\t= IPPROTO_MPTCP,\n\t.prot\t\t= &mptcp_v6_prot,\n\t.ops\t\t= &mptcp_v6_stream_ops,\n\t.flags\t\t= INET_PROTOSW_ICSK,\n};\n\nint __init mptcp_proto_v6_init(void)\n{\n\tint err;\n\n\tmptcp_v6_prot = mptcp_prot;\n\tstrcpy(mptcp_v6_prot.name, \"MPTCPv6\");\n\tmptcp_v6_prot.slab = NULL;\n\tmptcp_v6_prot.obj_size = sizeof(struct mptcp6_sock);\n\tmptcp_v6_prot.ipv6_pinfo_offset = offsetof(struct mptcp6_sock, np);\n\n\terr = proto_register(&mptcp_v6_prot, 1);\n\tif (err)\n\t\treturn err;\n\n\terr = inet6_register_protosw(&mptcp_v6_protosw);\n\tif (err)\n\t\tproto_unregister(&mptcp_v6_prot);\n\n\treturn err;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}