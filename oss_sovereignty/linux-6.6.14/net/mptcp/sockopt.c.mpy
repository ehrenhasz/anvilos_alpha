{
  "module_name": "sockopt.c",
  "hash_id": "f4e72206b11a3df93674fb1a9c4b17bc1568eac98339ab80871bf2c29ef35948",
  "original_prompt": "Ingested from linux-6.6.14/net/mptcp/sockopt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"MPTCP: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <net/sock.h>\n#include <net/protocol.h>\n#include <net/tcp.h>\n#include <net/mptcp.h>\n#include \"protocol.h\"\n\n#define MIN_INFO_OPTLEN_SIZE\t\t16\n#define MIN_FULL_INFO_OPTLEN_SIZE\t40\n\nstatic struct sock *__mptcp_tcp_fallback(struct mptcp_sock *msk)\n{\n\tmsk_owned_by_me(msk);\n\n\tif (likely(!__mptcp_check_fallback(msk)))\n\t\treturn NULL;\n\n\treturn msk->first;\n}\n\nstatic u32 sockopt_seq_reset(const struct sock *sk)\n{\n\tsock_owned_by_me(sk);\n\n\t \n\n\treturn (u32)sk->sk_state << 24u;\n}\n\nstatic void sockopt_seq_inc(struct mptcp_sock *msk)\n{\n\tu32 seq = (msk->setsockopt_seq + 1) & 0x00ffffff;\n\n\tmsk->setsockopt_seq = sockopt_seq_reset((struct sock *)msk) + seq;\n}\n\nstatic int mptcp_get_int_option(struct mptcp_sock *msk, sockptr_t optval,\n\t\t\t\tunsigned int optlen, int *val)\n{\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(val, optval, sizeof(*val)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic void mptcp_sol_socket_sync_intval(struct mptcp_sock *msk, int optname, int val)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\n\tlock_sock(sk);\n\tsockopt_seq_inc(msk);\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\t\tbool slow = lock_sock_fast(ssk);\n\n\t\tswitch (optname) {\n\t\tcase SO_DEBUG:\n\t\t\tsock_valbool_flag(ssk, SOCK_DBG, !!val);\n\t\t\tbreak;\n\t\tcase SO_KEEPALIVE:\n\t\t\tif (ssk->sk_prot->keepalive)\n\t\t\t\tssk->sk_prot->keepalive(ssk, !!val);\n\t\t\tsock_valbool_flag(ssk, SOCK_KEEPOPEN, !!val);\n\t\t\tbreak;\n\t\tcase SO_PRIORITY:\n\t\t\tssk->sk_priority = val;\n\t\t\tbreak;\n\t\tcase SO_SNDBUF:\n\t\tcase SO_SNDBUFFORCE:\n\t\t\tssk->sk_userlocks |= SOCK_SNDBUF_LOCK;\n\t\t\tWRITE_ONCE(ssk->sk_sndbuf, sk->sk_sndbuf);\n\t\t\tmptcp_subflow_ctx(ssk)->cached_sndbuf = sk->sk_sndbuf;\n\t\t\tbreak;\n\t\tcase SO_RCVBUF:\n\t\tcase SO_RCVBUFFORCE:\n\t\t\tssk->sk_userlocks |= SOCK_RCVBUF_LOCK;\n\t\t\tWRITE_ONCE(ssk->sk_rcvbuf, sk->sk_rcvbuf);\n\t\t\tbreak;\n\t\tcase SO_MARK:\n\t\t\tif (READ_ONCE(ssk->sk_mark) != sk->sk_mark) {\n\t\t\t\tWRITE_ONCE(ssk->sk_mark, sk->sk_mark);\n\t\t\t\tsk_dst_reset(ssk);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SO_INCOMING_CPU:\n\t\t\tWRITE_ONCE(ssk->sk_incoming_cpu, val);\n\t\t\tbreak;\n\t\t}\n\n\t\tsubflow->setsockopt_seq = msk->setsockopt_seq;\n\t\tunlock_sock_fast(ssk, slow);\n\t}\n\n\trelease_sock(sk);\n}\n\nstatic int mptcp_sol_socket_intval(struct mptcp_sock *msk, int optname, int val)\n{\n\tsockptr_t optval = KERNEL_SOCKPTR(&val);\n\tstruct sock *sk = (struct sock *)msk;\n\tint ret;\n\n\tret = sock_setsockopt(sk->sk_socket, SOL_SOCKET, optname,\n\t\t\t      optval, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\tmptcp_sol_socket_sync_intval(msk, optname, val);\n\treturn 0;\n}\n\nstatic void mptcp_so_incoming_cpu(struct mptcp_sock *msk, int val)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\n\tWRITE_ONCE(sk->sk_incoming_cpu, val);\n\n\tmptcp_sol_socket_sync_intval(msk, SO_INCOMING_CPU, val);\n}\n\nstatic int mptcp_setsockopt_sol_socket_tstamp(struct mptcp_sock *msk, int optname, int val)\n{\n\tsockptr_t optval = KERNEL_SOCKPTR(&val);\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tint ret;\n\n\tret = sock_setsockopt(sk->sk_socket, SOL_SOCKET, optname,\n\t\t\t      optval, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\tlock_sock(sk);\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\t\tbool slow = lock_sock_fast(ssk);\n\n\t\tsock_set_timestamp(sk, optname, !!val);\n\t\tunlock_sock_fast(ssk, slow);\n\t}\n\n\trelease_sock(sk);\n\treturn 0;\n}\n\nstatic int mptcp_setsockopt_sol_socket_int(struct mptcp_sock *msk, int optname,\n\t\t\t\t\t   sockptr_t optval,\n\t\t\t\t\t   unsigned int optlen)\n{\n\tint val, ret;\n\n\tret = mptcp_get_int_option(msk, optval, optlen, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (optname) {\n\tcase SO_KEEPALIVE:\n\t\tmptcp_sol_socket_sync_intval(msk, optname, val);\n\t\treturn 0;\n\tcase SO_DEBUG:\n\tcase SO_MARK:\n\tcase SO_PRIORITY:\n\tcase SO_SNDBUF:\n\tcase SO_SNDBUFFORCE:\n\tcase SO_RCVBUF:\n\tcase SO_RCVBUFFORCE:\n\t\treturn mptcp_sol_socket_intval(msk, optname, val);\n\tcase SO_INCOMING_CPU:\n\t\tmptcp_so_incoming_cpu(msk, val);\n\t\treturn 0;\n\tcase SO_TIMESTAMP_OLD:\n\tcase SO_TIMESTAMP_NEW:\n\tcase SO_TIMESTAMPNS_OLD:\n\tcase SO_TIMESTAMPNS_NEW:\n\t\treturn mptcp_setsockopt_sol_socket_tstamp(msk, optname, val);\n\t}\n\n\treturn -ENOPROTOOPT;\n}\n\nstatic int mptcp_setsockopt_sol_socket_timestamping(struct mptcp_sock *msk,\n\t\t\t\t\t\t    int optname,\n\t\t\t\t\t\t    sockptr_t optval,\n\t\t\t\t\t\t    unsigned int optlen)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct so_timestamping timestamping;\n\tint ret;\n\n\tif (optlen == sizeof(timestamping)) {\n\t\tif (copy_from_sockptr(&timestamping, optval,\n\t\t\t\t      sizeof(timestamping)))\n\t\t\treturn -EFAULT;\n\t} else if (optlen == sizeof(int)) {\n\t\tmemset(&timestamping, 0, sizeof(timestamping));\n\n\t\tif (copy_from_sockptr(&timestamping.flags, optval, sizeof(int)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tret = sock_setsockopt(sk->sk_socket, SOL_SOCKET, optname,\n\t\t\t      KERNEL_SOCKPTR(&timestamping),\n\t\t\t      sizeof(timestamping));\n\tif (ret)\n\t\treturn ret;\n\n\tlock_sock(sk);\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\t\tbool slow = lock_sock_fast(ssk);\n\n\t\tsock_set_timestamping(sk, optname, timestamping);\n\t\tunlock_sock_fast(ssk, slow);\n\t}\n\n\trelease_sock(sk);\n\n\treturn 0;\n}\n\nstatic int mptcp_setsockopt_sol_socket_linger(struct mptcp_sock *msk, sockptr_t optval,\n\t\t\t\t\t      unsigned int optlen)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct linger ling;\n\tsockptr_t kopt;\n\tint ret;\n\n\tif (optlen < sizeof(ling))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&ling, optval, sizeof(ling)))\n\t\treturn -EFAULT;\n\n\tkopt = KERNEL_SOCKPTR(&ling);\n\tret = sock_setsockopt(sk->sk_socket, SOL_SOCKET, SO_LINGER, kopt, sizeof(ling));\n\tif (ret)\n\t\treturn ret;\n\n\tlock_sock(sk);\n\tsockopt_seq_inc(msk);\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\t\tbool slow = lock_sock_fast(ssk);\n\n\t\tif (!ling.l_onoff) {\n\t\t\tsock_reset_flag(ssk, SOCK_LINGER);\n\t\t} else {\n\t\t\tssk->sk_lingertime = sk->sk_lingertime;\n\t\t\tsock_set_flag(ssk, SOCK_LINGER);\n\t\t}\n\n\t\tsubflow->setsockopt_seq = msk->setsockopt_seq;\n\t\tunlock_sock_fast(ssk, slow);\n\t}\n\n\trelease_sock(sk);\n\treturn 0;\n}\n\nstatic int mptcp_setsockopt_sol_socket(struct mptcp_sock *msk, int optname,\n\t\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct sock *ssk;\n\tint ret;\n\n\tswitch (optname) {\n\tcase SO_REUSEPORT:\n\tcase SO_REUSEADDR:\n\tcase SO_BINDTODEVICE:\n\tcase SO_BINDTOIFINDEX:\n\t\tlock_sock(sk);\n\t\tssk = __mptcp_nmpc_sk(msk);\n\t\tif (IS_ERR(ssk)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn PTR_ERR(ssk);\n\t\t}\n\n\t\tret = sk_setsockopt(ssk, SOL_SOCKET, optname, optval, optlen);\n\t\tif (ret == 0) {\n\t\t\tif (optname == SO_REUSEPORT)\n\t\t\t\tsk->sk_reuseport = ssk->sk_reuseport;\n\t\t\telse if (optname == SO_REUSEADDR)\n\t\t\t\tsk->sk_reuse = ssk->sk_reuse;\n\t\t\telse if (optname == SO_BINDTODEVICE)\n\t\t\t\tsk->sk_bound_dev_if = ssk->sk_bound_dev_if;\n\t\t\telse if (optname == SO_BINDTOIFINDEX)\n\t\t\t\tsk->sk_bound_dev_if = ssk->sk_bound_dev_if;\n\t\t}\n\t\trelease_sock(sk);\n\t\treturn ret;\n\tcase SO_KEEPALIVE:\n\tcase SO_PRIORITY:\n\tcase SO_SNDBUF:\n\tcase SO_SNDBUFFORCE:\n\tcase SO_RCVBUF:\n\tcase SO_RCVBUFFORCE:\n\tcase SO_MARK:\n\tcase SO_INCOMING_CPU:\n\tcase SO_DEBUG:\n\tcase SO_TIMESTAMP_OLD:\n\tcase SO_TIMESTAMP_NEW:\n\tcase SO_TIMESTAMPNS_OLD:\n\tcase SO_TIMESTAMPNS_NEW:\n\t\treturn mptcp_setsockopt_sol_socket_int(msk, optname, optval,\n\t\t\t\t\t\t       optlen);\n\tcase SO_TIMESTAMPING_OLD:\n\tcase SO_TIMESTAMPING_NEW:\n\t\treturn mptcp_setsockopt_sol_socket_timestamping(msk, optname,\n\t\t\t\t\t\t\t\toptval, optlen);\n\tcase SO_LINGER:\n\t\treturn mptcp_setsockopt_sol_socket_linger(msk, optval, optlen);\n\tcase SO_RCVLOWAT:\n\tcase SO_RCVTIMEO_OLD:\n\tcase SO_RCVTIMEO_NEW:\n\tcase SO_SNDTIMEO_OLD:\n\tcase SO_SNDTIMEO_NEW:\n\tcase SO_BUSY_POLL:\n\tcase SO_PREFER_BUSY_POLL:\n\tcase SO_BUSY_POLL_BUDGET:\n\t\t \n\t\treturn sock_setsockopt(sk->sk_socket, SOL_SOCKET, optname, optval, optlen);\n\tcase SO_NO_CHECK:\n\tcase SO_DONTROUTE:\n\tcase SO_BROADCAST:\n\tcase SO_BSDCOMPAT:\n\tcase SO_PASSCRED:\n\tcase SO_PASSPIDFD:\n\tcase SO_PASSSEC:\n\tcase SO_RXQ_OVFL:\n\tcase SO_WIFI_STATUS:\n\tcase SO_NOFCS:\n\tcase SO_SELECT_ERR_QUEUE:\n\t\treturn 0;\n\t}\n\n\t \n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mptcp_setsockopt_v6(struct mptcp_sock *msk, int optname,\n\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tint ret = -EOPNOTSUPP;\n\tstruct sock *ssk;\n\n\tswitch (optname) {\n\tcase IPV6_V6ONLY:\n\tcase IPV6_TRANSPARENT:\n\tcase IPV6_FREEBIND:\n\t\tlock_sock(sk);\n\t\tssk = __mptcp_nmpc_sk(msk);\n\t\tif (IS_ERR(ssk)) {\n\t\t\trelease_sock(sk);\n\t\t\treturn PTR_ERR(ssk);\n\t\t}\n\n\t\tret = tcp_setsockopt(ssk, SOL_IPV6, optname, optval, optlen);\n\t\tif (ret != 0) {\n\t\t\trelease_sock(sk);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsockopt_seq_inc(msk);\n\n\t\tswitch (optname) {\n\t\tcase IPV6_V6ONLY:\n\t\t\tsk->sk_ipv6only = ssk->sk_ipv6only;\n\t\t\tbreak;\n\t\tcase IPV6_TRANSPARENT:\n\t\t\tinet_assign_bit(TRANSPARENT, sk,\n\t\t\t\t\tinet_test_bit(TRANSPARENT, ssk));\n\t\t\tbreak;\n\t\tcase IPV6_FREEBIND:\n\t\t\tinet_assign_bit(FREEBIND, sk,\n\t\t\t\t\tinet_test_bit(FREEBIND, ssk));\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic bool mptcp_supported_sockopt(int level, int optname)\n{\n\tif (level == SOL_IP) {\n\t\tswitch (optname) {\n\t\t \n\t\tcase IP_FREEBIND:\n\t\tcase IP_TRANSPARENT:\n\n\t\t \n\t\tcase IP_PKTINFO:\n\t\tcase IP_RECVTTL:\n\t\tcase IP_RECVTOS:\n\t\tcase IP_RECVOPTS:\n\t\tcase IP_RETOPTS:\n\t\tcase IP_PASSSEC:\n\t\tcase IP_RECVORIGDSTADDR:\n\t\tcase IP_CHECKSUM:\n\t\tcase IP_RECVFRAGSIZE:\n\n\t\t \n\t\tcase IP_TOS:\n\t\tcase IP_TTL:\n\t\tcase IP_BIND_ADDRESS_NO_PORT:\n\t\tcase IP_MTU_DISCOVER:\n\t\tcase IP_RECVERR:\n\n\t\t \n\t\tcase IP_MINTTL:\n\n\t\t \n\t\tcase IP_RECVERR_RFC4884:\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\t \n\t\t \n\t\t \n\t\treturn false;\n\t}\n\tif (level == SOL_IPV6) {\n\t\tswitch (optname) {\n\t\tcase IPV6_V6ONLY:\n\n\t\t \n\t\tcase IPV6_RECVPKTINFO:\n\t\tcase IPV6_2292PKTINFO:\n\t\tcase IPV6_RECVHOPLIMIT:\n\t\tcase IPV6_2292HOPLIMIT:\n\t\tcase IPV6_RECVRTHDR:\n\t\tcase IPV6_2292RTHDR:\n\t\tcase IPV6_RECVHOPOPTS:\n\t\tcase IPV6_2292HOPOPTS:\n\t\tcase IPV6_RECVDSTOPTS:\n\t\tcase IPV6_2292DSTOPTS:\n\t\tcase IPV6_RECVTCLASS:\n\t\tcase IPV6_FLOWINFO:\n\t\tcase IPV6_RECVPATHMTU:\n\t\tcase IPV6_RECVORIGDSTADDR:\n\t\tcase IPV6_RECVFRAGSIZE:\n\n\t\t \n\t\tcase IPV6_TCLASS:\n\t\tcase IPV6_TRANSPARENT:\n\t\tcase IPV6_FREEBIND:\n\t\tcase IPV6_PKTINFO:\n\t\tcase IPV6_2292PKTOPTIONS:\n\t\tcase IPV6_UNICAST_HOPS:\n\t\tcase IPV6_MTU_DISCOVER:\n\t\tcase IPV6_MTU:\n\t\tcase IPV6_RECVERR:\n\t\tcase IPV6_FLOWINFO_SEND:\n\t\tcase IPV6_FLOWLABEL_MGR:\n\t\tcase IPV6_MINHOPCOUNT:\n\t\tcase IPV6_DONTFRAG:\n\t\tcase IPV6_AUTOFLOWLABEL:\n\n\t\t \n\t\tcase IPV6_RECVERR_RFC4884:\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\t \n\t\t \n\n\t\t \n\t\t \n\t\treturn false;\n\t}\n\tif (level == SOL_TCP) {\n\t\tswitch (optname) {\n\t\t \n\t\tcase TCP_THIN_DUPACK:\n\t\tcase TCP_DEFER_ACCEPT:\n\n\t\t \n\t\tcase TCP_MAXSEG:\n\t\tcase TCP_NODELAY:\n\t\tcase TCP_THIN_LINEAR_TIMEOUTS:\n\t\tcase TCP_CONGESTION:\n\t\tcase TCP_CORK:\n\t\tcase TCP_KEEPIDLE:\n\t\tcase TCP_KEEPINTVL:\n\t\tcase TCP_KEEPCNT:\n\t\tcase TCP_SYNCNT:\n\t\tcase TCP_SAVE_SYN:\n\t\tcase TCP_LINGER2:\n\t\tcase TCP_WINDOW_CLAMP:\n\t\tcase TCP_QUICKACK:\n\t\tcase TCP_USER_TIMEOUT:\n\t\tcase TCP_TIMESTAMP:\n\t\tcase TCP_NOTSENT_LOWAT:\n\t\tcase TCP_TX_DELAY:\n\t\tcase TCP_INQ:\n\t\tcase TCP_FASTOPEN:\n\t\tcase TCP_FASTOPEN_CONNECT:\n\t\tcase TCP_FASTOPEN_KEY:\n\t\tcase TCP_FASTOPEN_NO_COOKIE:\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\n\t\t \n\t}\n\treturn false;\n}\n\nstatic int mptcp_setsockopt_sol_tcp_congestion(struct mptcp_sock *msk, sockptr_t optval,\n\t\t\t\t\t       unsigned int optlen)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tchar name[TCP_CA_NAME_MAX];\n\tbool cap_net_admin;\n\tint ret;\n\n\tif (optlen < 1)\n\t\treturn -EINVAL;\n\n\tret = strncpy_from_sockptr(name, optval,\n\t\t\t\t   min_t(long, TCP_CA_NAME_MAX - 1, optlen));\n\tif (ret < 0)\n\t\treturn -EFAULT;\n\n\tname[ret] = 0;\n\n\tcap_net_admin = ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN);\n\n\tret = 0;\n\tlock_sock(sk);\n\tsockopt_seq_inc(msk);\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\t\tint err;\n\n\t\tlock_sock(ssk);\n\t\terr = tcp_set_congestion_control(ssk, name, true, cap_net_admin);\n\t\tif (err < 0 && ret == 0)\n\t\t\tret = err;\n\t\tsubflow->setsockopt_seq = msk->setsockopt_seq;\n\t\trelease_sock(ssk);\n\t}\n\n\tif (ret == 0)\n\t\tstrcpy(msk->ca_name, name);\n\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int mptcp_setsockopt_sol_tcp_cork(struct mptcp_sock *msk, sockptr_t optval,\n\t\t\t\t\t unsigned int optlen)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tint val;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\tsockopt_seq_inc(msk);\n\tmsk->cork = !!val;\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\n\t\tlock_sock(ssk);\n\t\t__tcp_sock_set_cork(ssk, !!val);\n\t\trelease_sock(ssk);\n\t}\n\tif (!val)\n\t\tmptcp_check_and_set_pending(sk);\n\trelease_sock(sk);\n\n\treturn 0;\n}\n\nstatic int mptcp_setsockopt_sol_tcp_nodelay(struct mptcp_sock *msk, sockptr_t optval,\n\t\t\t\t\t    unsigned int optlen)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tint val;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (copy_from_sockptr(&val, optval, sizeof(val)))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\tsockopt_seq_inc(msk);\n\tmsk->nodelay = !!val;\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\n\t\tlock_sock(ssk);\n\t\t__tcp_sock_set_nodelay(ssk, !!val);\n\t\trelease_sock(ssk);\n\t}\n\tif (val)\n\t\tmptcp_check_and_set_pending(sk);\n\trelease_sock(sk);\n\n\treturn 0;\n}\n\nstatic int mptcp_setsockopt_sol_ip_set_transparent(struct mptcp_sock *msk, int optname,\n\t\t\t\t\t\t   sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct sock *ssk;\n\tint err;\n\n\terr = ip_setsockopt(sk, SOL_IP, optname, optval, optlen);\n\tif (err != 0)\n\t\treturn err;\n\n\tlock_sock(sk);\n\n\tssk = __mptcp_nmpc_sk(msk);\n\tif (IS_ERR(ssk)) {\n\t\trelease_sock(sk);\n\t\treturn PTR_ERR(ssk);\n\t}\n\n\tswitch (optname) {\n\tcase IP_FREEBIND:\n\t\tinet_assign_bit(FREEBIND, ssk, inet_test_bit(FREEBIND, sk));\n\t\tbreak;\n\tcase IP_TRANSPARENT:\n\t\tinet_assign_bit(TRANSPARENT, ssk,\n\t\t\t\tinet_test_bit(TRANSPARENT, sk));\n\t\tbreak;\n\tdefault:\n\t\trelease_sock(sk);\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tsockopt_seq_inc(msk);\n\trelease_sock(sk);\n\treturn 0;\n}\n\nstatic int mptcp_setsockopt_v4_set_tos(struct mptcp_sock *msk, int optname,\n\t\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tint err, val;\n\n\terr = ip_setsockopt(sk, SOL_IP, optname, optval, optlen);\n\n\tif (err != 0)\n\t\treturn err;\n\n\tlock_sock(sk);\n\tsockopt_seq_inc(msk);\n\tval = inet_sk(sk)->tos;\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\t\tbool slow;\n\n\t\tslow = lock_sock_fast(ssk);\n\t\t__ip_sock_set_tos(ssk, val);\n\t\tunlock_sock_fast(ssk, slow);\n\t}\n\trelease_sock(sk);\n\n\treturn 0;\n}\n\nstatic int mptcp_setsockopt_v4(struct mptcp_sock *msk, int optname,\n\t\t\t       sockptr_t optval, unsigned int optlen)\n{\n\tswitch (optname) {\n\tcase IP_FREEBIND:\n\tcase IP_TRANSPARENT:\n\t\treturn mptcp_setsockopt_sol_ip_set_transparent(msk, optname, optval, optlen);\n\tcase IP_TOS:\n\t\treturn mptcp_setsockopt_v4_set_tos(msk, optname, optval, optlen);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mptcp_setsockopt_first_sf_only(struct mptcp_sock *msk, int level, int optname,\n\t\t\t\t\t  sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct sock *ssk;\n\tint ret;\n\n\t \n\tlock_sock(sk);\n\tssk = __mptcp_nmpc_sk(msk);\n\tif (IS_ERR(ssk)) {\n\t\tret = PTR_ERR(ssk);\n\t\tgoto unlock;\n\t}\n\n\tret = tcp_setsockopt(ssk, level, optname, optval, optlen);\n\nunlock:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nstatic int mptcp_setsockopt_sol_tcp(struct mptcp_sock *msk, int optname,\n\t\t\t\t    sockptr_t optval, unsigned int optlen)\n{\n\tstruct sock *sk = (void *)msk;\n\tint ret, val;\n\n\tswitch (optname) {\n\tcase TCP_INQ:\n\t\tret = mptcp_get_int_option(msk, optval, optlen, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (val < 0 || val > 1)\n\t\t\treturn -EINVAL;\n\n\t\tlock_sock(sk);\n\t\tmsk->recvmsg_inq = !!val;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\tcase TCP_ULP:\n\t\treturn -EOPNOTSUPP;\n\tcase TCP_CONGESTION:\n\t\treturn mptcp_setsockopt_sol_tcp_congestion(msk, optval, optlen);\n\tcase TCP_CORK:\n\t\treturn mptcp_setsockopt_sol_tcp_cork(msk, optval, optlen);\n\tcase TCP_NODELAY:\n\t\treturn mptcp_setsockopt_sol_tcp_nodelay(msk, optval, optlen);\n\tcase TCP_DEFER_ACCEPT:\n\t\t \n\t\tmptcp_setsockopt_first_sf_only(msk, SOL_TCP, optname, optval, optlen);\n\t\treturn 0;\n\tcase TCP_FASTOPEN:\n\tcase TCP_FASTOPEN_CONNECT:\n\tcase TCP_FASTOPEN_KEY:\n\tcase TCP_FASTOPEN_NO_COOKIE:\n\t\treturn mptcp_setsockopt_first_sf_only(msk, SOL_TCP, optname,\n\t\t\t\t\t\t      optval, optlen);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nint mptcp_setsockopt(struct sock *sk, int level, int optname,\n\t\t     sockptr_t optval, unsigned int optlen)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct sock *ssk;\n\n\tpr_debug(\"msk=%p\", msk);\n\n\tif (level == SOL_SOCKET)\n\t\treturn mptcp_setsockopt_sol_socket(msk, optname, optval, optlen);\n\n\tif (!mptcp_supported_sockopt(level, optname))\n\t\treturn -ENOPROTOOPT;\n\n\t \n\tlock_sock(sk);\n\tssk = __mptcp_tcp_fallback(msk);\n\trelease_sock(sk);\n\tif (ssk)\n\t\treturn tcp_setsockopt(ssk, level, optname, optval, optlen);\n\n\tif (level == SOL_IP)\n\t\treturn mptcp_setsockopt_v4(msk, optname, optval, optlen);\n\n\tif (level == SOL_IPV6)\n\t\treturn mptcp_setsockopt_v6(msk, optname, optval, optlen);\n\n\tif (level == SOL_TCP)\n\t\treturn mptcp_setsockopt_sol_tcp(msk, optname, optval, optlen);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mptcp_getsockopt_first_sf_only(struct mptcp_sock *msk, int level, int optname,\n\t\t\t\t\t  char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct sock *ssk;\n\tint ret;\n\n\tlock_sock(sk);\n\tssk = msk->first;\n\tif (ssk) {\n\t\tret = tcp_getsockopt(ssk, level, optname, optval, optlen);\n\t\tgoto out;\n\t}\n\n\tssk = __mptcp_nmpc_sk(msk);\n\tif (IS_ERR(ssk)) {\n\t\tret = PTR_ERR(ssk);\n\t\tgoto out;\n\t}\n\n\tret = tcp_getsockopt(ssk, level, optname, optval, optlen);\n\nout:\n\trelease_sock(sk);\n\treturn ret;\n}\n\nvoid mptcp_diag_fill_info(struct mptcp_sock *msk, struct mptcp_info *info)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tu32 flags = 0;\n\tbool slow;\n\n\tmemset(info, 0, sizeof(*info));\n\n\tinfo->mptcpi_subflows = READ_ONCE(msk->pm.subflows);\n\tinfo->mptcpi_add_addr_signal = READ_ONCE(msk->pm.add_addr_signaled);\n\tinfo->mptcpi_add_addr_accepted = READ_ONCE(msk->pm.add_addr_accepted);\n\tinfo->mptcpi_local_addr_used = READ_ONCE(msk->pm.local_addr_used);\n\n\tif (inet_sk_state_load(sk) == TCP_LISTEN)\n\t\treturn;\n\n\t \n\tif (mptcp_pm_is_kernel(msk)) {\n\t\tinfo->mptcpi_subflows_max =\n\t\t\tmptcp_pm_get_subflows_max(msk);\n\t\tinfo->mptcpi_add_addr_signal_max =\n\t\t\tmptcp_pm_get_add_addr_signal_max(msk);\n\t\tinfo->mptcpi_add_addr_accepted_max =\n\t\t\tmptcp_pm_get_add_addr_accept_max(msk);\n\t\tinfo->mptcpi_local_addr_max =\n\t\t\tmptcp_pm_get_local_addr_max(msk);\n\t}\n\n\tif (test_bit(MPTCP_FALLBACK_DONE, &msk->flags))\n\t\tflags |= MPTCP_INFO_FLAG_FALLBACK;\n\tif (READ_ONCE(msk->can_ack))\n\t\tflags |= MPTCP_INFO_FLAG_REMOTE_KEY_RECEIVED;\n\tinfo->mptcpi_flags = flags;\n\tmptcp_data_lock(sk);\n\tinfo->mptcpi_snd_una = msk->snd_una;\n\tinfo->mptcpi_rcv_nxt = msk->ack_seq;\n\tinfo->mptcpi_bytes_acked = msk->bytes_acked;\n\tmptcp_data_unlock(sk);\n\n\tslow = lock_sock_fast(sk);\n\tinfo->mptcpi_csum_enabled = msk->csum_enabled;\n\tinfo->mptcpi_token = msk->token;\n\tinfo->mptcpi_write_seq = msk->write_seq;\n\tinfo->mptcpi_retransmits = inet_csk(sk)->icsk_retransmits;\n\tinfo->mptcpi_bytes_sent = msk->bytes_sent;\n\tinfo->mptcpi_bytes_received = msk->bytes_received;\n\tinfo->mptcpi_bytes_retrans = msk->bytes_retrans;\n\tunlock_sock_fast(sk, slow);\n}\nEXPORT_SYMBOL_GPL(mptcp_diag_fill_info);\n\nstatic int mptcp_getsockopt_info(struct mptcp_sock *msk, char __user *optval, int __user *optlen)\n{\n\tstruct mptcp_info m_info;\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlen = min_t(unsigned int, len, sizeof(struct mptcp_info));\n\n\tmptcp_diag_fill_info(msk, &m_info);\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, &m_info, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int mptcp_put_subflow_data(struct mptcp_subflow_data *sfd,\n\t\t\t\t  char __user *optval,\n\t\t\t\t  u32 copied,\n\t\t\t\t  int __user *optlen)\n{\n\tu32 copylen = min_t(u32, sfd->size_subflow_data, sizeof(*sfd));\n\n\tif (copied)\n\t\tcopied += sfd->size_subflow_data;\n\telse\n\t\tcopied = copylen;\n\n\tif (put_user(copied, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, sfd, copylen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int mptcp_get_subflow_data(struct mptcp_subflow_data *sfd,\n\t\t\t\t  char __user *optval,\n\t\t\t\t  int __user *optlen)\n{\n\tint len, copylen;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\t \n\tBUILD_BUG_ON(sizeof(*sfd) != MIN_INFO_OPTLEN_SIZE);\n\n\tif (len < MIN_INFO_OPTLEN_SIZE)\n\t\treturn -EINVAL;\n\n\tmemset(sfd, 0, sizeof(*sfd));\n\n\tcopylen = min_t(unsigned int, len, sizeof(*sfd));\n\tif (copy_from_user(sfd, optval, copylen))\n\t\treturn -EFAULT;\n\n\t \n\tif (sfd->size_subflow_data > INT_MAX ||\n\t    sfd->size_user > INT_MAX)\n\t\treturn -EINVAL;\n\n\tif (sfd->size_subflow_data < MIN_INFO_OPTLEN_SIZE ||\n\t    sfd->size_subflow_data > len)\n\t\treturn -EINVAL;\n\n\tif (sfd->num_subflows || sfd->size_kernel)\n\t\treturn -EINVAL;\n\n\treturn len - sfd->size_subflow_data;\n}\n\nstatic int mptcp_getsockopt_tcpinfo(struct mptcp_sock *msk, char __user *optval,\n\t\t\t\t    int __user *optlen)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tunsigned int sfcount = 0, copied = 0;\n\tstruct mptcp_subflow_data sfd;\n\tchar __user *infoptr;\n\tint len;\n\n\tlen = mptcp_get_subflow_data(&sfd, optval, optlen);\n\tif (len < 0)\n\t\treturn len;\n\n\tsfd.size_kernel = sizeof(struct tcp_info);\n\tsfd.size_user = min_t(unsigned int, sfd.size_user,\n\t\t\t      sizeof(struct tcp_info));\n\n\tinfoptr = optval + sfd.size_subflow_data;\n\n\tlock_sock(sk);\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\n\t\t++sfcount;\n\n\t\tif (len && len >= sfd.size_user) {\n\t\t\tstruct tcp_info info;\n\n\t\t\ttcp_get_info(ssk, &info);\n\n\t\t\tif (copy_to_user(infoptr, &info, sfd.size_user)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\tinfoptr += sfd.size_user;\n\t\t\tcopied += sfd.size_user;\n\t\t\tlen -= sfd.size_user;\n\t\t}\n\t}\n\n\trelease_sock(sk);\n\n\tsfd.num_subflows = sfcount;\n\n\tif (mptcp_put_subflow_data(&sfd, optval, copied, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic void mptcp_get_sub_addrs(const struct sock *sk, struct mptcp_subflow_addrs *a)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\n\tmemset(a, 0, sizeof(*a));\n\n\tif (sk->sk_family == AF_INET) {\n\t\ta->sin_local.sin_family = AF_INET;\n\t\ta->sin_local.sin_port = inet->inet_sport;\n\t\ta->sin_local.sin_addr.s_addr = inet->inet_rcv_saddr;\n\n\t\tif (!a->sin_local.sin_addr.s_addr)\n\t\t\ta->sin_local.sin_addr.s_addr = inet->inet_saddr;\n\n\t\ta->sin_remote.sin_family = AF_INET;\n\t\ta->sin_remote.sin_port = inet->inet_dport;\n\t\ta->sin_remote.sin_addr.s_addr = inet->inet_daddr;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (sk->sk_family == AF_INET6) {\n\t\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\n\t\tif (WARN_ON_ONCE(!np))\n\t\t\treturn;\n\n\t\ta->sin6_local.sin6_family = AF_INET6;\n\t\ta->sin6_local.sin6_port = inet->inet_sport;\n\n\t\tif (ipv6_addr_any(&sk->sk_v6_rcv_saddr))\n\t\t\ta->sin6_local.sin6_addr = np->saddr;\n\t\telse\n\t\t\ta->sin6_local.sin6_addr = sk->sk_v6_rcv_saddr;\n\n\t\ta->sin6_remote.sin6_family = AF_INET6;\n\t\ta->sin6_remote.sin6_port = inet->inet_dport;\n\t\ta->sin6_remote.sin6_addr = sk->sk_v6_daddr;\n#endif\n\t}\n}\n\nstatic int mptcp_getsockopt_subflow_addrs(struct mptcp_sock *msk, char __user *optval,\n\t\t\t\t\t  int __user *optlen)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tunsigned int sfcount = 0, copied = 0;\n\tstruct mptcp_subflow_data sfd;\n\tchar __user *addrptr;\n\tint len;\n\n\tlen = mptcp_get_subflow_data(&sfd, optval, optlen);\n\tif (len < 0)\n\t\treturn len;\n\n\tsfd.size_kernel = sizeof(struct mptcp_subflow_addrs);\n\tsfd.size_user = min_t(unsigned int, sfd.size_user,\n\t\t\t      sizeof(struct mptcp_subflow_addrs));\n\n\taddrptr = optval + sfd.size_subflow_data;\n\n\tlock_sock(sk);\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\n\t\t++sfcount;\n\n\t\tif (len && len >= sfd.size_user) {\n\t\t\tstruct mptcp_subflow_addrs a;\n\n\t\t\tmptcp_get_sub_addrs(ssk, &a);\n\n\t\t\tif (copy_to_user(addrptr, &a, sfd.size_user)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\taddrptr += sfd.size_user;\n\t\t\tcopied += sfd.size_user;\n\t\t\tlen -= sfd.size_user;\n\t\t}\n\t}\n\n\trelease_sock(sk);\n\n\tsfd.num_subflows = sfcount;\n\n\tif (mptcp_put_subflow_data(&sfd, optval, copied, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int mptcp_get_full_info(struct mptcp_full_info *mfi,\n\t\t\t       char __user *optval,\n\t\t\t       int __user *optlen)\n{\n\tint len;\n\n\tBUILD_BUG_ON(offsetof(struct mptcp_full_info, mptcp_info) !=\n\t\t     MIN_FULL_INFO_OPTLEN_SIZE);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < MIN_FULL_INFO_OPTLEN_SIZE)\n\t\treturn -EINVAL;\n\n\tmemset(mfi, 0, sizeof(*mfi));\n\tif (copy_from_user(mfi, optval, MIN_FULL_INFO_OPTLEN_SIZE))\n\t\treturn -EFAULT;\n\n\tif (mfi->size_tcpinfo_kernel ||\n\t    mfi->size_sfinfo_kernel ||\n\t    mfi->num_subflows)\n\t\treturn -EINVAL;\n\n\tif (mfi->size_sfinfo_user > INT_MAX ||\n\t    mfi->size_tcpinfo_user > INT_MAX)\n\t\treturn -EINVAL;\n\n\treturn len - MIN_FULL_INFO_OPTLEN_SIZE;\n}\n\nstatic int mptcp_put_full_info(struct mptcp_full_info *mfi,\n\t\t\t       char __user *optval,\n\t\t\t       u32 copylen,\n\t\t\t       int __user *optlen)\n{\n\tcopylen += MIN_FULL_INFO_OPTLEN_SIZE;\n\tif (put_user(copylen, optlen))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(optval, mfi, copylen))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int mptcp_getsockopt_full_info(struct mptcp_sock *msk, char __user *optval,\n\t\t\t\t      int __user *optlen)\n{\n\tunsigned int sfcount = 0, copylen = 0;\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk = (struct sock *)msk;\n\tvoid __user *tcpinfoptr, *sfinfoptr;\n\tstruct mptcp_full_info mfi;\n\tint len;\n\n\tlen = mptcp_get_full_info(&mfi, optval, optlen);\n\tif (len < 0)\n\t\treturn len;\n\n\t \n\tif (len > 0) {\n\t\tmptcp_diag_fill_info(msk, &mfi.mptcp_info);\n\t\tcopylen += min_t(unsigned int, len, sizeof(struct mptcp_info));\n\t}\n\n\tmfi.size_tcpinfo_kernel = sizeof(struct tcp_info);\n\tmfi.size_tcpinfo_user = min_t(unsigned int, mfi.size_tcpinfo_user,\n\t\t\t\t      sizeof(struct tcp_info));\n\tsfinfoptr = u64_to_user_ptr(mfi.subflow_info);\n\tmfi.size_sfinfo_kernel = sizeof(struct mptcp_subflow_info);\n\tmfi.size_sfinfo_user = min_t(unsigned int, mfi.size_sfinfo_user,\n\t\t\t\t     sizeof(struct mptcp_subflow_info));\n\ttcpinfoptr = u64_to_user_ptr(mfi.tcp_info);\n\n\tlock_sock(sk);\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\t\tstruct mptcp_subflow_info sfinfo;\n\t\tstruct tcp_info tcp_info;\n\n\t\tif (sfcount++ >= mfi.size_arrays_user)\n\t\t\tcontinue;\n\n\t\t \n\t\tmemset(&sfinfo, 0, sizeof(sfinfo));\n\t\tsfinfo.id = subflow->subflow_id;\n\t\tif (mfi.size_sfinfo_user >\n\t\t    offsetof(struct mptcp_subflow_info, addrs))\n\t\t\tmptcp_get_sub_addrs(ssk, &sfinfo.addrs);\n\t\tif (copy_to_user(sfinfoptr, &sfinfo, mfi.size_sfinfo_user))\n\t\t\tgoto fail_release;\n\n\t\tif (mfi.size_tcpinfo_user) {\n\t\t\ttcp_get_info(ssk, &tcp_info);\n\t\t\tif (copy_to_user(tcpinfoptr, &tcp_info,\n\t\t\t\t\t mfi.size_tcpinfo_user))\n\t\t\t\tgoto fail_release;\n\t\t}\n\n\t\ttcpinfoptr += mfi.size_tcpinfo_user;\n\t\tsfinfoptr += mfi.size_sfinfo_user;\n\t}\n\trelease_sock(sk);\n\n\tmfi.num_subflows = sfcount;\n\tif (mptcp_put_full_info(&mfi, optval, copylen, optlen))\n\t\treturn -EFAULT;\n\n\treturn 0;\n\nfail_release:\n\trelease_sock(sk);\n\treturn -EFAULT;\n}\n\nstatic int mptcp_put_int_option(struct mptcp_sock *msk, char __user *optval,\n\t\t\t\tint __user *optlen, int val)\n{\n\tint len;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tif (len < sizeof(int) && len > 0 && val >= 0 && val <= 255) {\n\t\tunsigned char ucval = (unsigned char)val;\n\n\t\tlen = 1;\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &ucval, 1))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tlen = min_t(unsigned int, len, sizeof(int));\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;\n\t\tif (copy_to_user(optval, &val, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int mptcp_getsockopt_sol_tcp(struct mptcp_sock *msk, int optname,\n\t\t\t\t    char __user *optval, int __user *optlen)\n{\n\tswitch (optname) {\n\tcase TCP_ULP:\n\tcase TCP_CONGESTION:\n\tcase TCP_INFO:\n\tcase TCP_CC_INFO:\n\tcase TCP_DEFER_ACCEPT:\n\tcase TCP_FASTOPEN:\n\tcase TCP_FASTOPEN_CONNECT:\n\tcase TCP_FASTOPEN_KEY:\n\tcase TCP_FASTOPEN_NO_COOKIE:\n\t\treturn mptcp_getsockopt_first_sf_only(msk, SOL_TCP, optname,\n\t\t\t\t\t\t      optval, optlen);\n\tcase TCP_INQ:\n\t\treturn mptcp_put_int_option(msk, optval, optlen, msk->recvmsg_inq);\n\tcase TCP_CORK:\n\t\treturn mptcp_put_int_option(msk, optval, optlen, msk->cork);\n\tcase TCP_NODELAY:\n\t\treturn mptcp_put_int_option(msk, optval, optlen, msk->nodelay);\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mptcp_getsockopt_v4(struct mptcp_sock *msk, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = (void *)msk;\n\n\tswitch (optname) {\n\tcase IP_TOS:\n\t\treturn mptcp_put_int_option(msk, optval, optlen, inet_sk(sk)->tos);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mptcp_getsockopt_sol_mptcp(struct mptcp_sock *msk, int optname,\n\t\t\t\t      char __user *optval, int __user *optlen)\n{\n\tswitch (optname) {\n\tcase MPTCP_INFO:\n\t\treturn mptcp_getsockopt_info(msk, optval, optlen);\n\tcase MPTCP_FULL_INFO:\n\t\treturn mptcp_getsockopt_full_info(msk, optval, optlen);\n\tcase MPTCP_TCPINFO:\n\t\treturn mptcp_getsockopt_tcpinfo(msk, optval, optlen);\n\tcase MPTCP_SUBFLOW_ADDRS:\n\t\treturn mptcp_getsockopt_subflow_addrs(msk, optval, optlen);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nint mptcp_getsockopt(struct sock *sk, int level, int optname,\n\t\t     char __user *optval, int __user *option)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct sock *ssk;\n\n\tpr_debug(\"msk=%p\", msk);\n\n\t \n\tlock_sock(sk);\n\tssk = __mptcp_tcp_fallback(msk);\n\trelease_sock(sk);\n\tif (ssk)\n\t\treturn tcp_getsockopt(ssk, level, optname, optval, option);\n\n\tif (level == SOL_IP)\n\t\treturn mptcp_getsockopt_v4(msk, optname, optval, option);\n\tif (level == SOL_TCP)\n\t\treturn mptcp_getsockopt_sol_tcp(msk, optname, optval, option);\n\tif (level == SOL_MPTCP)\n\t\treturn mptcp_getsockopt_sol_mptcp(msk, optname, optval, option);\n\treturn -EOPNOTSUPP;\n}\n\nstatic void sync_socket_options(struct mptcp_sock *msk, struct sock *ssk)\n{\n\tstatic const unsigned int tx_rx_locks = SOCK_RCVBUF_LOCK | SOCK_SNDBUF_LOCK;\n\tstruct sock *sk = (struct sock *)msk;\n\n\tif (ssk->sk_prot->keepalive) {\n\t\tif (sock_flag(sk, SOCK_KEEPOPEN))\n\t\t\tssk->sk_prot->keepalive(ssk, 1);\n\t\telse\n\t\t\tssk->sk_prot->keepalive(ssk, 0);\n\t}\n\n\tssk->sk_priority = sk->sk_priority;\n\tssk->sk_bound_dev_if = sk->sk_bound_dev_if;\n\tssk->sk_incoming_cpu = sk->sk_incoming_cpu;\n\tssk->sk_ipv6only = sk->sk_ipv6only;\n\t__ip_sock_set_tos(ssk, inet_sk(sk)->tos);\n\n\tif (sk->sk_userlocks & tx_rx_locks) {\n\t\tssk->sk_userlocks |= sk->sk_userlocks & tx_rx_locks;\n\t\tif (sk->sk_userlocks & SOCK_SNDBUF_LOCK) {\n\t\t\tWRITE_ONCE(ssk->sk_sndbuf, sk->sk_sndbuf);\n\t\t\tmptcp_subflow_ctx(ssk)->cached_sndbuf = sk->sk_sndbuf;\n\t\t}\n\t\tif (sk->sk_userlocks & SOCK_RCVBUF_LOCK)\n\t\t\tWRITE_ONCE(ssk->sk_rcvbuf, sk->sk_rcvbuf);\n\t}\n\n\tif (sock_flag(sk, SOCK_LINGER)) {\n\t\tssk->sk_lingertime = sk->sk_lingertime;\n\t\tsock_set_flag(ssk, SOCK_LINGER);\n\t} else {\n\t\tsock_reset_flag(ssk, SOCK_LINGER);\n\t}\n\n\tif (sk->sk_mark != ssk->sk_mark) {\n\t\tssk->sk_mark = sk->sk_mark;\n\t\tsk_dst_reset(ssk);\n\t}\n\n\tsock_valbool_flag(ssk, SOCK_DBG, sock_flag(sk, SOCK_DBG));\n\n\tif (inet_csk(sk)->icsk_ca_ops != inet_csk(ssk)->icsk_ca_ops)\n\t\ttcp_set_congestion_control(ssk, msk->ca_name, false, true);\n\t__tcp_sock_set_cork(ssk, !!msk->cork);\n\t__tcp_sock_set_nodelay(ssk, !!msk->nodelay);\n\n\tinet_assign_bit(TRANSPARENT, ssk, inet_test_bit(TRANSPARENT, sk));\n\tinet_assign_bit(FREEBIND, ssk, inet_test_bit(FREEBIND, sk));\n}\n\nstatic void __mptcp_sockopt_sync(struct mptcp_sock *msk, struct sock *ssk)\n{\n\tbool slow = lock_sock_fast(ssk);\n\n\tsync_socket_options(msk, ssk);\n\n\tunlock_sock_fast(ssk, slow);\n}\n\nvoid mptcp_sockopt_sync(struct mptcp_sock *msk, struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\n\tmsk_owned_by_me(msk);\n\n\tif (READ_ONCE(subflow->setsockopt_seq) != msk->setsockopt_seq) {\n\t\t__mptcp_sockopt_sync(msk, ssk);\n\n\t\tsubflow->setsockopt_seq = msk->setsockopt_seq;\n\t}\n}\n\nvoid mptcp_sockopt_sync_locked(struct mptcp_sock *msk, struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\n\tmsk_owned_by_me(msk);\n\n\tif (READ_ONCE(subflow->setsockopt_seq) != msk->setsockopt_seq) {\n\t\tsync_socket_options(msk, ssk);\n\n\t\tsubflow->setsockopt_seq = msk->setsockopt_seq;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}