{
  "module_name": "subflow.c",
  "hash_id": "f311e0b500e1cc4750b3ba872e2afbaf7f54af470dc15ef35dff910220eb6522",
  "original_prompt": "Ingested from linux-6.6.14/net/mptcp/subflow.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"MPTCP: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <crypto/algapi.h>\n#include <crypto/sha2.h>\n#include <net/sock.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/protocol.h>\n#include <net/tcp.h>\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n#include <net/ip6_route.h>\n#include <net/transp_v6.h>\n#endif\n#include <net/mptcp.h>\n#include <uapi/linux/mptcp.h>\n#include \"protocol.h\"\n#include \"mib.h\"\n\n#include <trace/events/mptcp.h>\n#include <trace/events/sock.h>\n\nstatic void mptcp_subflow_ops_undo_override(struct sock *ssk);\n\nstatic void SUBFLOW_REQ_INC_STATS(struct request_sock *req,\n\t\t\t\t  enum linux_mptcp_mib_field field)\n{\n\tMPTCP_INC_STATS(sock_net(req_to_sk(req)), field);\n}\n\nstatic void subflow_req_destructor(struct request_sock *req)\n{\n\tstruct mptcp_subflow_request_sock *subflow_req = mptcp_subflow_rsk(req);\n\n\tpr_debug(\"subflow_req=%p\", subflow_req);\n\n\tif (subflow_req->msk)\n\t\tsock_put((struct sock *)subflow_req->msk);\n\n\tmptcp_token_destroy_request(req);\n}\n\nstatic void subflow_generate_hmac(u64 key1, u64 key2, u32 nonce1, u32 nonce2,\n\t\t\t\t  void *hmac)\n{\n\tu8 msg[8];\n\n\tput_unaligned_be32(nonce1, &msg[0]);\n\tput_unaligned_be32(nonce2, &msg[4]);\n\n\tmptcp_crypto_hmac_sha(key1, key2, msg, 8, hmac);\n}\n\nstatic bool mptcp_can_accept_new_subflow(const struct mptcp_sock *msk)\n{\n\treturn mptcp_is_fully_established((void *)msk) &&\n\t\t((mptcp_pm_is_userspace(msk) &&\n\t\t  mptcp_userspace_pm_active(msk)) ||\n\t\t READ_ONCE(msk->pm.accept_subflow));\n}\n\n \nstatic void subflow_req_create_thmac(struct mptcp_subflow_request_sock *subflow_req)\n{\n\tstruct mptcp_sock *msk = subflow_req->msk;\n\tu8 hmac[SHA256_DIGEST_SIZE];\n\n\tget_random_bytes(&subflow_req->local_nonce, sizeof(u32));\n\n\tsubflow_generate_hmac(msk->local_key, msk->remote_key,\n\t\t\t      subflow_req->local_nonce,\n\t\t\t      subflow_req->remote_nonce, hmac);\n\n\tsubflow_req->thmac = get_unaligned_be64(hmac);\n}\n\nstatic struct mptcp_sock *subflow_token_join_request(struct request_sock *req)\n{\n\tstruct mptcp_subflow_request_sock *subflow_req = mptcp_subflow_rsk(req);\n\tstruct mptcp_sock *msk;\n\tint local_id;\n\n\tmsk = mptcp_token_get_sock(sock_net(req_to_sk(req)), subflow_req->token);\n\tif (!msk) {\n\t\tSUBFLOW_REQ_INC_STATS(req, MPTCP_MIB_JOINNOTOKEN);\n\t\treturn NULL;\n\t}\n\n\tlocal_id = mptcp_pm_get_local_id(msk, (struct sock_common *)req);\n\tif (local_id < 0) {\n\t\tsock_put((struct sock *)msk);\n\t\treturn NULL;\n\t}\n\tsubflow_req->local_id = local_id;\n\n\treturn msk;\n}\n\nstatic void subflow_init_req(struct request_sock *req, const struct sock *sk_listener)\n{\n\tstruct mptcp_subflow_request_sock *subflow_req = mptcp_subflow_rsk(req);\n\n\tsubflow_req->mp_capable = 0;\n\tsubflow_req->mp_join = 0;\n\tsubflow_req->csum_reqd = mptcp_is_checksum_enabled(sock_net(sk_listener));\n\tsubflow_req->allow_join_id0 = mptcp_allow_join_id0(sock_net(sk_listener));\n\tsubflow_req->msk = NULL;\n\tmptcp_token_init_request(req);\n}\n\nstatic bool subflow_use_different_sport(struct mptcp_sock *msk, const struct sock *sk)\n{\n\treturn inet_sk(sk)->inet_sport != inet_sk((struct sock *)msk)->inet_sport;\n}\n\nstatic void subflow_add_reset_reason(struct sk_buff *skb, u8 reason)\n{\n\tstruct mptcp_ext *mpext = skb_ext_add(skb, SKB_EXT_MPTCP);\n\n\tif (mpext) {\n\t\tmemset(mpext, 0, sizeof(*mpext));\n\t\tmpext->reset_reason = reason;\n\t}\n}\n\n \nstatic int subflow_check_req(struct request_sock *req,\n\t\t\t     const struct sock *sk_listener,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct mptcp_subflow_context *listener = mptcp_subflow_ctx(sk_listener);\n\tstruct mptcp_subflow_request_sock *subflow_req = mptcp_subflow_rsk(req);\n\tstruct mptcp_options_received mp_opt;\n\tbool opt_mp_capable, opt_mp_join;\n\n\tpr_debug(\"subflow_req=%p, listener=%p\", subflow_req, listener);\n\n#ifdef CONFIG_TCP_MD5SIG\n\t \n\tif (rcu_access_pointer(tcp_sk(sk_listener)->md5sig_info))\n\t\treturn -EINVAL;\n#endif\n\n\tmptcp_get_options(skb, &mp_opt);\n\n\topt_mp_capable = !!(mp_opt.suboptions & OPTION_MPTCP_MPC_SYN);\n\topt_mp_join = !!(mp_opt.suboptions & OPTION_MPTCP_MPJ_SYN);\n\tif (opt_mp_capable) {\n\t\tSUBFLOW_REQ_INC_STATS(req, MPTCP_MIB_MPCAPABLEPASSIVE);\n\n\t\tif (opt_mp_join)\n\t\t\treturn 0;\n\t} else if (opt_mp_join) {\n\t\tSUBFLOW_REQ_INC_STATS(req, MPTCP_MIB_JOINSYNRX);\n\t}\n\n\tif (opt_mp_capable && listener->request_mptcp) {\n\t\tint err, retries = MPTCP_TOKEN_MAX_RETRIES;\n\n\t\tsubflow_req->ssn_offset = TCP_SKB_CB(skb)->seq;\nagain:\n\t\tdo {\n\t\t\tget_random_bytes(&subflow_req->local_key, sizeof(subflow_req->local_key));\n\t\t} while (subflow_req->local_key == 0);\n\n\t\tif (unlikely(req->syncookie)) {\n\t\t\tmptcp_crypto_key_sha(subflow_req->local_key,\n\t\t\t\t\t     &subflow_req->token,\n\t\t\t\t\t     &subflow_req->idsn);\n\t\t\tif (mptcp_token_exists(subflow_req->token)) {\n\t\t\t\tif (retries-- > 0)\n\t\t\t\t\tgoto again;\n\t\t\t\tSUBFLOW_REQ_INC_STATS(req, MPTCP_MIB_TOKENFALLBACKINIT);\n\t\t\t} else {\n\t\t\t\tsubflow_req->mp_capable = 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\terr = mptcp_token_new_request(req);\n\t\tif (err == 0)\n\t\t\tsubflow_req->mp_capable = 1;\n\t\telse if (retries-- > 0)\n\t\t\tgoto again;\n\t\telse\n\t\t\tSUBFLOW_REQ_INC_STATS(req, MPTCP_MIB_TOKENFALLBACKINIT);\n\n\t} else if (opt_mp_join && listener->request_mptcp) {\n\t\tsubflow_req->ssn_offset = TCP_SKB_CB(skb)->seq;\n\t\tsubflow_req->mp_join = 1;\n\t\tsubflow_req->backup = mp_opt.backup;\n\t\tsubflow_req->remote_id = mp_opt.join_id;\n\t\tsubflow_req->token = mp_opt.token;\n\t\tsubflow_req->remote_nonce = mp_opt.nonce;\n\t\tsubflow_req->msk = subflow_token_join_request(req);\n\n\t\t \n\t\tif (!subflow_req->msk) {\n\t\t\tsubflow_add_reset_reason(skb, MPTCP_RST_EMPTCP);\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (subflow_use_different_sport(subflow_req->msk, sk_listener)) {\n\t\t\tpr_debug(\"syn inet_sport=%d %d\",\n\t\t\t\t ntohs(inet_sk(sk_listener)->inet_sport),\n\t\t\t\t ntohs(inet_sk((struct sock *)subflow_req->msk)->inet_sport));\n\t\t\tif (!mptcp_pm_sport_in_anno_list(subflow_req->msk, sk_listener)) {\n\t\t\t\tSUBFLOW_REQ_INC_STATS(req, MPTCP_MIB_MISMATCHPORTSYNRX);\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t\tSUBFLOW_REQ_INC_STATS(req, MPTCP_MIB_JOINPORTSYNRX);\n\t\t}\n\n\t\tsubflow_req_create_thmac(subflow_req);\n\n\t\tif (unlikely(req->syncookie)) {\n\t\t\tif (mptcp_can_accept_new_subflow(subflow_req->msk))\n\t\t\t\tsubflow_init_req_cookie_join_save(subflow_req, skb);\n\t\t\telse\n\t\t\t\treturn -EPERM;\n\t\t}\n\n\t\tpr_debug(\"token=%u, remote_nonce=%u msk=%p\", subflow_req->token,\n\t\t\t subflow_req->remote_nonce, subflow_req->msk);\n\t}\n\n\treturn 0;\n}\n\nint mptcp_subflow_init_cookie_req(struct request_sock *req,\n\t\t\t\t  const struct sock *sk_listener,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct mptcp_subflow_context *listener = mptcp_subflow_ctx(sk_listener);\n\tstruct mptcp_subflow_request_sock *subflow_req = mptcp_subflow_rsk(req);\n\tstruct mptcp_options_received mp_opt;\n\tbool opt_mp_capable, opt_mp_join;\n\tint err;\n\n\tsubflow_init_req(req, sk_listener);\n\tmptcp_get_options(skb, &mp_opt);\n\n\topt_mp_capable = !!(mp_opt.suboptions & OPTION_MPTCP_MPC_ACK);\n\topt_mp_join = !!(mp_opt.suboptions & OPTION_MPTCP_MPJ_ACK);\n\tif (opt_mp_capable && opt_mp_join)\n\t\treturn -EINVAL;\n\n\tif (opt_mp_capable && listener->request_mptcp) {\n\t\tif (mp_opt.sndr_key == 0)\n\t\t\treturn -EINVAL;\n\n\t\tsubflow_req->local_key = mp_opt.rcvr_key;\n\t\terr = mptcp_token_new_request(req);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tsubflow_req->mp_capable = 1;\n\t\tsubflow_req->ssn_offset = TCP_SKB_CB(skb)->seq - 1;\n\t} else if (opt_mp_join && listener->request_mptcp) {\n\t\tif (!mptcp_token_join_cookie_init_state(subflow_req, skb))\n\t\t\treturn -EINVAL;\n\n\t\tsubflow_req->mp_join = 1;\n\t\tsubflow_req->ssn_offset = TCP_SKB_CB(skb)->seq - 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mptcp_subflow_init_cookie_req);\n\nstatic struct dst_entry *subflow_v4_route_req(const struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct flowi *fl,\n\t\t\t\t\t      struct request_sock *req)\n{\n\tstruct dst_entry *dst;\n\tint err;\n\n\ttcp_rsk(req)->is_mptcp = 1;\n\tsubflow_init_req(req, sk);\n\n\tdst = tcp_request_sock_ipv4_ops.route_req(sk, skb, fl, req);\n\tif (!dst)\n\t\treturn NULL;\n\n\terr = subflow_check_req(req, sk, skb);\n\tif (err == 0)\n\t\treturn dst;\n\n\tdst_release(dst);\n\tif (!req->syncookie)\n\t\ttcp_request_sock_ops.send_reset(sk, skb);\n\treturn NULL;\n}\n\nstatic void subflow_prep_synack(const struct sock *sk, struct request_sock *req,\n\t\t\t\tstruct tcp_fastopen_cookie *foc,\n\t\t\t\tenum tcp_synack_type synack_type)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\t \n\tif (foc && foc->len > -1)\n\t\tireq->tstamp_ok = 0;\n\n\tif (synack_type == TCP_SYNACK_FASTOPEN)\n\t\tmptcp_fastopen_subflow_synack_set_params(subflow, req);\n}\n\nstatic int subflow_v4_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t\t  struct flowi *fl,\n\t\t\t\t  struct request_sock *req,\n\t\t\t\t  struct tcp_fastopen_cookie *foc,\n\t\t\t\t  enum tcp_synack_type synack_type,\n\t\t\t\t  struct sk_buff *syn_skb)\n{\n\tsubflow_prep_synack(sk, req, foc, synack_type);\n\n\treturn tcp_request_sock_ipv4_ops.send_synack(sk, dst, fl, req, foc,\n\t\t\t\t\t\t     synack_type, syn_skb);\n}\n\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\nstatic int subflow_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t\t  struct flowi *fl,\n\t\t\t\t  struct request_sock *req,\n\t\t\t\t  struct tcp_fastopen_cookie *foc,\n\t\t\t\t  enum tcp_synack_type synack_type,\n\t\t\t\t  struct sk_buff *syn_skb)\n{\n\tsubflow_prep_synack(sk, req, foc, synack_type);\n\n\treturn tcp_request_sock_ipv6_ops.send_synack(sk, dst, fl, req, foc,\n\t\t\t\t\t\t     synack_type, syn_skb);\n}\n\nstatic struct dst_entry *subflow_v6_route_req(const struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct flowi *fl,\n\t\t\t\t\t      struct request_sock *req)\n{\n\tstruct dst_entry *dst;\n\tint err;\n\n\ttcp_rsk(req)->is_mptcp = 1;\n\tsubflow_init_req(req, sk);\n\n\tdst = tcp_request_sock_ipv6_ops.route_req(sk, skb, fl, req);\n\tif (!dst)\n\t\treturn NULL;\n\n\terr = subflow_check_req(req, sk, skb);\n\tif (err == 0)\n\t\treturn dst;\n\n\tdst_release(dst);\n\tif (!req->syncookie)\n\t\ttcp6_request_sock_ops.send_reset(sk, skb);\n\treturn NULL;\n}\n#endif\n\n \nstatic bool subflow_thmac_valid(struct mptcp_subflow_context *subflow)\n{\n\tu8 hmac[SHA256_DIGEST_SIZE];\n\tu64 thmac;\n\n\tsubflow_generate_hmac(subflow->remote_key, subflow->local_key,\n\t\t\t      subflow->remote_nonce, subflow->local_nonce,\n\t\t\t      hmac);\n\n\tthmac = get_unaligned_be64(hmac);\n\tpr_debug(\"subflow=%p, token=%u, thmac=%llu, subflow->thmac=%llu\\n\",\n\t\t subflow, subflow->token, thmac, subflow->thmac);\n\n\treturn thmac == subflow->thmac;\n}\n\nvoid mptcp_subflow_reset(struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tstruct sock *sk = subflow->conn;\n\n\t \n\tif (ssk->sk_state == TCP_CLOSE)\n\t\treturn;\n\n\t \n\tsock_hold(sk);\n\n\ttcp_send_active_reset(ssk, GFP_ATOMIC);\n\ttcp_done(ssk);\n\tif (!test_and_set_bit(MPTCP_WORK_CLOSE_SUBFLOW, &mptcp_sk(sk)->flags))\n\t\tmptcp_schedule_work(sk);\n\n\tsock_put(sk);\n}\n\nstatic bool subflow_use_different_dport(struct mptcp_sock *msk, const struct sock *sk)\n{\n\treturn inet_sk(sk)->inet_dport != inet_sk((struct sock *)msk)->inet_dport;\n}\n\nvoid __mptcp_sync_state(struct sock *sk, int state)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\t__mptcp_propagate_sndbuf(sk, msk->first);\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tinet_sk_state_store(sk, state);\n\t\tsk->sk_state_change(sk);\n\t}\n}\n\nstatic void mptcp_propagate_state(struct sock *sk, struct sock *ssk)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\n\tmptcp_data_lock(sk);\n\tif (!sock_owned_by_user(sk)) {\n\t\t__mptcp_sync_state(sk, ssk->sk_state);\n\t} else {\n\t\tmsk->pending_state = ssk->sk_state;\n\t\t__set_bit(MPTCP_SYNC_STATE, &msk->cb_flags);\n\t}\n\tmptcp_data_unlock(sk);\n}\n\nstatic void subflow_set_remote_key(struct mptcp_sock *msk,\n\t\t\t\t   struct mptcp_subflow_context *subflow,\n\t\t\t\t   const struct mptcp_options_received *mp_opt)\n{\n\t \n\tif (subflow->remote_key_valid)\n\t\treturn;\n\n\tsubflow->remote_key_valid = 1;\n\tsubflow->remote_key = mp_opt->sndr_key;\n\tmptcp_crypto_key_sha(subflow->remote_key, NULL, &subflow->iasn);\n\tsubflow->iasn++;\n\n\tWRITE_ONCE(msk->remote_key, subflow->remote_key);\n\tWRITE_ONCE(msk->ack_seq, subflow->iasn);\n\tWRITE_ONCE(msk->can_ack, true);\n\tatomic64_set(&msk->rcv_wnd_sent, subflow->iasn);\n}\n\nstatic void subflow_finish_connect(struct sock *sk, const struct sk_buff *skb)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tstruct mptcp_options_received mp_opt;\n\tstruct sock *parent = subflow->conn;\n\tstruct mptcp_sock *msk;\n\n\tsubflow->icsk_af_ops->sk_rx_dst_set(sk, skb);\n\n\t \n\tif (subflow->conn_finished)\n\t\treturn;\n\n\tmsk = mptcp_sk(parent);\n\tsubflow->rel_write_seq = 1;\n\tsubflow->conn_finished = 1;\n\tsubflow->ssn_offset = TCP_SKB_CB(skb)->seq;\n\tpr_debug(\"subflow=%p synack seq=%x\", subflow, subflow->ssn_offset);\n\n\tmptcp_get_options(skb, &mp_opt);\n\tif (subflow->request_mptcp) {\n\t\tif (!(mp_opt.suboptions & OPTION_MPTCP_MPC_SYNACK)) {\n\t\t\tMPTCP_INC_STATS(sock_net(sk),\n\t\t\t\t\tMPTCP_MIB_MPCAPABLEACTIVEFALLBACK);\n\t\t\tmptcp_do_fallback(sk);\n\t\t\tpr_fallback(msk);\n\t\t\tgoto fallback;\n\t\t}\n\n\t\tif (mp_opt.suboptions & OPTION_MPTCP_CSUMREQD)\n\t\t\tWRITE_ONCE(msk->csum_enabled, true);\n\t\tif (mp_opt.deny_join_id0)\n\t\t\tWRITE_ONCE(msk->pm.remote_deny_join_id0, true);\n\t\tsubflow->mp_capable = 1;\n\t\tsubflow_set_remote_key(msk, subflow, &mp_opt);\n\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPCAPABLEACTIVEACK);\n\t\tmptcp_finish_connect(sk);\n\t\tmptcp_propagate_state(parent, sk);\n\t} else if (subflow->request_join) {\n\t\tu8 hmac[SHA256_DIGEST_SIZE];\n\n\t\tif (!(mp_opt.suboptions & OPTION_MPTCP_MPJ_SYNACK)) {\n\t\t\tsubflow->reset_reason = MPTCP_RST_EMPTCP;\n\t\t\tgoto do_reset;\n\t\t}\n\n\t\tsubflow->backup = mp_opt.backup;\n\t\tsubflow->thmac = mp_opt.thmac;\n\t\tsubflow->remote_nonce = mp_opt.nonce;\n\t\tsubflow->remote_id = mp_opt.join_id;\n\t\tpr_debug(\"subflow=%p, thmac=%llu, remote_nonce=%u backup=%d\",\n\t\t\t subflow, subflow->thmac, subflow->remote_nonce,\n\t\t\t subflow->backup);\n\n\t\tif (!subflow_thmac_valid(subflow)) {\n\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_JOINACKMAC);\n\t\t\tsubflow->reset_reason = MPTCP_RST_EMPTCP;\n\t\t\tgoto do_reset;\n\t\t}\n\n\t\tif (!mptcp_finish_join(sk))\n\t\t\tgoto do_reset;\n\n\t\tsubflow_generate_hmac(subflow->local_key, subflow->remote_key,\n\t\t\t\t      subflow->local_nonce,\n\t\t\t\t      subflow->remote_nonce,\n\t\t\t\t      hmac);\n\t\tmemcpy(subflow->hmac, hmac, MPTCPOPT_HMAC_LEN);\n\n\t\tsubflow->mp_join = 1;\n\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_JOINSYNACKRX);\n\n\t\tif (subflow_use_different_dport(msk, sk)) {\n\t\t\tpr_debug(\"synack inet_dport=%d %d\",\n\t\t\t\t ntohs(inet_sk(sk)->inet_dport),\n\t\t\t\t ntohs(inet_sk(parent)->inet_dport));\n\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_JOINPORTSYNACKRX);\n\t\t}\n\t} else if (mptcp_check_fallback(sk)) {\nfallback:\n\t\tmptcp_rcv_space_init(msk, sk);\n\t\tmptcp_propagate_state(parent, sk);\n\t}\n\treturn;\n\ndo_reset:\n\tsubflow->reset_transient = 0;\n\tmptcp_subflow_reset(sk);\n}\n\nstatic void subflow_set_local_id(struct mptcp_subflow_context *subflow, int local_id)\n{\n\tsubflow->local_id = local_id;\n\tsubflow->local_id_valid = 1;\n}\n\nstatic int subflow_chk_local_id(struct sock *sk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\tint err;\n\n\tif (likely(subflow->local_id_valid))\n\t\treturn 0;\n\n\terr = mptcp_pm_get_local_id(msk, (struct sock_common *)sk);\n\tif (err < 0)\n\t\treturn err;\n\n\tsubflow_set_local_id(subflow, err);\n\treturn 0;\n}\n\nstatic int subflow_rebuild_header(struct sock *sk)\n{\n\tint err = subflow_chk_local_id(sk);\n\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\treturn inet_sk_rebuild_header(sk);\n}\n\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\nstatic int subflow_v6_rebuild_header(struct sock *sk)\n{\n\tint err = subflow_chk_local_id(sk);\n\n\tif (unlikely(err < 0))\n\t\treturn err;\n\n\treturn inet6_sk_rebuild_header(sk);\n}\n#endif\n\nstatic struct request_sock_ops mptcp_subflow_v4_request_sock_ops __ro_after_init;\nstatic struct tcp_request_sock_ops subflow_request_sock_ipv4_ops __ro_after_init;\n\nstatic int subflow_v4_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\n\tpr_debug(\"subflow=%p\", subflow);\n\n\t \n\tif (skb_rtable(skb)->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))\n\t\tgoto drop;\n\n\treturn tcp_conn_request(&mptcp_subflow_v4_request_sock_ops,\n\t\t\t\t&subflow_request_sock_ipv4_ops,\n\t\t\t\tsk, skb);\ndrop:\n\ttcp_listendrop(sk);\n\treturn 0;\n}\n\nstatic void subflow_v4_req_destructor(struct request_sock *req)\n{\n\tsubflow_req_destructor(req);\n\ttcp_request_sock_ops.destructor(req);\n}\n\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\nstatic struct request_sock_ops mptcp_subflow_v6_request_sock_ops __ro_after_init;\nstatic struct tcp_request_sock_ops subflow_request_sock_ipv6_ops __ro_after_init;\nstatic struct inet_connection_sock_af_ops subflow_v6_specific __ro_after_init;\nstatic struct inet_connection_sock_af_ops subflow_v6m_specific __ro_after_init;\nstatic struct proto tcpv6_prot_override __ro_after_init;\n\nstatic int subflow_v6_conn_request(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\n\tpr_debug(\"subflow=%p\", subflow);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn subflow_v4_conn_request(sk, skb);\n\n\tif (!ipv6_unicast_destination(skb))\n\t\tgoto drop;\n\n\tif (ipv6_addr_v4mapped(&ipv6_hdr(skb)->saddr)) {\n\t\t__IP6_INC_STATS(sock_net(sk), NULL, IPSTATS_MIB_INHDRERRORS);\n\t\treturn 0;\n\t}\n\n\treturn tcp_conn_request(&mptcp_subflow_v6_request_sock_ops,\n\t\t\t\t&subflow_request_sock_ipv6_ops, sk, skb);\n\ndrop:\n\ttcp_listendrop(sk);\n\treturn 0;  \n}\n\nstatic void subflow_v6_req_destructor(struct request_sock *req)\n{\n\tsubflow_req_destructor(req);\n\ttcp6_request_sock_ops.destructor(req);\n}\n#endif\n\nstruct request_sock *mptcp_subflow_reqsk_alloc(const struct request_sock_ops *ops,\n\t\t\t\t\t       struct sock *sk_listener,\n\t\t\t\t\t       bool attach_listener)\n{\n\tif (ops->family == AF_INET)\n\t\tops = &mptcp_subflow_v4_request_sock_ops;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\telse if (ops->family == AF_INET6)\n\t\tops = &mptcp_subflow_v6_request_sock_ops;\n#endif\n\n\treturn inet_reqsk_alloc(ops, sk_listener, attach_listener);\n}\nEXPORT_SYMBOL(mptcp_subflow_reqsk_alloc);\n\n \nstatic bool subflow_hmac_valid(const struct request_sock *req,\n\t\t\t       const struct mptcp_options_received *mp_opt)\n{\n\tconst struct mptcp_subflow_request_sock *subflow_req;\n\tu8 hmac[SHA256_DIGEST_SIZE];\n\tstruct mptcp_sock *msk;\n\n\tsubflow_req = mptcp_subflow_rsk(req);\n\tmsk = subflow_req->msk;\n\tif (!msk)\n\t\treturn false;\n\n\tsubflow_generate_hmac(msk->remote_key, msk->local_key,\n\t\t\t      subflow_req->remote_nonce,\n\t\t\t      subflow_req->local_nonce, hmac);\n\n\treturn !crypto_memneq(hmac, mp_opt->hmac, MPTCPOPT_HMAC_LEN);\n}\n\nstatic void subflow_ulp_fallback(struct sock *sk,\n\t\t\t\t struct mptcp_subflow_context *old_ctx)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tmptcp_subflow_tcp_fallback(sk, old_ctx);\n\ticsk->icsk_ulp_ops = NULL;\n\trcu_assign_pointer(icsk->icsk_ulp_data, NULL);\n\ttcp_sk(sk)->is_mptcp = 0;\n\n\tmptcp_subflow_ops_undo_override(sk);\n}\n\nvoid mptcp_subflow_drop_ctx(struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *ctx = mptcp_subflow_ctx(ssk);\n\n\tif (!ctx)\n\t\treturn;\n\n\tlist_del(&mptcp_subflow_ctx(ssk)->node);\n\tif (inet_csk(ssk)->icsk_ulp_ops) {\n\t\tsubflow_ulp_fallback(ssk, ctx);\n\t\tif (ctx->conn)\n\t\t\tsock_put(ctx->conn);\n\t}\n\n\tkfree_rcu(ctx, rcu);\n}\n\nvoid mptcp_subflow_fully_established(struct mptcp_subflow_context *subflow,\n\t\t\t\t     const struct mptcp_options_received *mp_opt)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\n\tsubflow_set_remote_key(msk, subflow, mp_opt);\n\tsubflow->fully_established = 1;\n\tWRITE_ONCE(msk->fully_established, true);\n\n\tif (subflow->is_mptfo)\n\t\tmptcp_fastopen_gen_msk_ackseq(msk, subflow, mp_opt);\n}\n\nstatic struct sock *subflow_syn_recv_sock(const struct sock *sk,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct request_sock *req,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  struct request_sock *req_unhash,\n\t\t\t\t\t  bool *own_req)\n{\n\tstruct mptcp_subflow_context *listener = mptcp_subflow_ctx(sk);\n\tstruct mptcp_subflow_request_sock *subflow_req;\n\tstruct mptcp_options_received mp_opt;\n\tbool fallback, fallback_is_fatal;\n\tstruct mptcp_sock *owner;\n\tstruct sock *child;\n\n\tpr_debug(\"listener=%p, req=%p, conn=%p\", listener, req, listener->conn);\n\n\t \n\tmp_opt.suboptions = 0;\n\n\t \n\tsubflow_req = mptcp_subflow_rsk(req);\n\tfallback_is_fatal = tcp_rsk(req)->is_mptcp && subflow_req->mp_join;\n\tfallback = !tcp_rsk(req)->is_mptcp;\n\tif (fallback)\n\t\tgoto create_child;\n\n\t \n\tif (subflow_req->mp_capable) {\n\t\t \n\t\tmptcp_get_options(skb, &mp_opt);\n\t\tif (!(mp_opt.suboptions &\n\t\t      (OPTION_MPTCP_MPC_SYN | OPTION_MPTCP_MPC_ACK)))\n\t\t\tfallback = true;\n\n\t} else if (subflow_req->mp_join) {\n\t\tmptcp_get_options(skb, &mp_opt);\n\t\tif (!(mp_opt.suboptions & OPTION_MPTCP_MPJ_ACK) ||\n\t\t    !subflow_hmac_valid(req, &mp_opt) ||\n\t\t    !mptcp_can_accept_new_subflow(subflow_req->msk)) {\n\t\t\tSUBFLOW_REQ_INC_STATS(req, MPTCP_MIB_JOINACKMAC);\n\t\t\tfallback = true;\n\t\t}\n\t}\n\ncreate_child:\n\tchild = listener->icsk_af_ops->syn_recv_sock(sk, skb, req, dst,\n\t\t\t\t\t\t     req_unhash, own_req);\n\n\tif (child && *own_req) {\n\t\tstruct mptcp_subflow_context *ctx = mptcp_subflow_ctx(child);\n\n\t\ttcp_rsk(req)->drop_req = false;\n\n\t\t \n\t\tif (!ctx || fallback) {\n\t\t\tif (fallback_is_fatal) {\n\t\t\t\tsubflow_add_reset_reason(skb, MPTCP_RST_EMPTCP);\n\t\t\t\tgoto dispose_child;\n\t\t\t}\n\t\t\tgoto fallback;\n\t\t}\n\n\t\t \n\t\tctx->setsockopt_seq = listener->setsockopt_seq;\n\n\t\tif (ctx->mp_capable) {\n\t\t\tctx->conn = mptcp_sk_clone_init(listener->conn, &mp_opt, child, req);\n\t\t\tif (!ctx->conn)\n\t\t\t\tgoto fallback;\n\n\t\t\tctx->subflow_id = 1;\n\t\t\towner = mptcp_sk(ctx->conn);\n\t\t\tmptcp_pm_new_connection(owner, child, 1);\n\n\t\t\t \n\t\t\tif (mp_opt.suboptions & OPTION_MPTCP_MPC_ACK) {\n\t\t\t\tmptcp_subflow_fully_established(ctx, &mp_opt);\n\t\t\t\tmptcp_pm_fully_established(owner, child);\n\t\t\t\tctx->pm_notified = 1;\n\t\t\t}\n\t\t} else if (ctx->mp_join) {\n\t\t\towner = subflow_req->msk;\n\t\t\tif (!owner) {\n\t\t\t\tsubflow_add_reset_reason(skb, MPTCP_RST_EPROHIBIT);\n\t\t\t\tgoto dispose_child;\n\t\t\t}\n\n\t\t\t \n\t\t\tsubflow_req->msk = NULL;\n\t\t\tctx->conn = (struct sock *)owner;\n\n\t\t\tif (subflow_use_different_sport(owner, sk)) {\n\t\t\t\tpr_debug(\"ack inet_sport=%d %d\",\n\t\t\t\t\t ntohs(inet_sk(sk)->inet_sport),\n\t\t\t\t\t ntohs(inet_sk((struct sock *)owner)->inet_sport));\n\t\t\t\tif (!mptcp_pm_sport_in_anno_list(owner, sk)) {\n\t\t\t\t\tSUBFLOW_REQ_INC_STATS(req, MPTCP_MIB_MISMATCHPORTACKRX);\n\t\t\t\t\tgoto dispose_child;\n\t\t\t\t}\n\t\t\t\tSUBFLOW_REQ_INC_STATS(req, MPTCP_MIB_JOINPORTACKRX);\n\t\t\t}\n\n\t\t\tif (!mptcp_finish_join(child))\n\t\t\t\tgoto dispose_child;\n\n\t\t\tSUBFLOW_REQ_INC_STATS(req, MPTCP_MIB_JOINACKRX);\n\t\t\ttcp_rsk(req)->drop_req = true;\n\t\t}\n\t}\n\n\t \n\tWARN_ON_ONCE(child && *own_req && tcp_sk(child)->is_mptcp &&\n\t\t     (!mptcp_subflow_ctx(child) ||\n\t\t      !mptcp_subflow_ctx(child)->conn));\n\treturn child;\n\ndispose_child:\n\tmptcp_subflow_drop_ctx(child);\n\ttcp_rsk(req)->drop_req = true;\n\tinet_csk_prepare_for_destroy_sock(child);\n\ttcp_done(child);\n\treq->rsk_ops->send_reset(sk, skb);\n\n\t \n\treturn child;\n\nfallback:\n\tmptcp_subflow_drop_ctx(child);\n\treturn child;\n}\n\nstatic struct inet_connection_sock_af_ops subflow_specific __ro_after_init;\nstatic struct proto tcp_prot_override __ro_after_init;\n\nenum mapping_status {\n\tMAPPING_OK,\n\tMAPPING_INVALID,\n\tMAPPING_EMPTY,\n\tMAPPING_DATA_FIN,\n\tMAPPING_DUMMY,\n\tMAPPING_BAD_CSUM\n};\n\nstatic void dbg_bad_map(struct mptcp_subflow_context *subflow, u32 ssn)\n{\n\tpr_debug(\"Bad mapping: ssn=%d map_seq=%d map_data_len=%d\",\n\t\t ssn, subflow->map_subflow_seq, subflow->map_data_len);\n}\n\nstatic bool skb_is_fully_mapped(struct sock *ssk, struct sk_buff *skb)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tunsigned int skb_consumed;\n\n\tskb_consumed = tcp_sk(ssk)->copied_seq - TCP_SKB_CB(skb)->seq;\n\tif (WARN_ON_ONCE(skb_consumed >= skb->len))\n\t\treturn true;\n\n\treturn skb->len - skb_consumed <= subflow->map_data_len -\n\t\t\t\t\t  mptcp_subflow_get_map_offset(subflow);\n}\n\nstatic bool validate_mapping(struct sock *ssk, struct sk_buff *skb)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tu32 ssn = tcp_sk(ssk)->copied_seq - subflow->ssn_offset;\n\n\tif (unlikely(before(ssn, subflow->map_subflow_seq))) {\n\t\t \n\t\tdbg_bad_map(subflow, ssn);\n\t\treturn false;\n\t}\n\tif (unlikely(!before(ssn, subflow->map_subflow_seq +\n\t\t\t\t  subflow->map_data_len))) {\n\t\t \n\t\tdbg_bad_map(subflow, ssn);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic enum mapping_status validate_data_csum(struct sock *ssk, struct sk_buff *skb,\n\t\t\t\t\t      bool csum_reqd)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tu32 offset, seq, delta;\n\t__sum16 csum;\n\tint len;\n\n\tif (!csum_reqd)\n\t\treturn MAPPING_OK;\n\n\t \n\tif (subflow->map_csum_len == subflow->map_data_len)\n\t\treturn MAPPING_OK;\n\n\t \n\tdelta = subflow->map_data_len - subflow->map_csum_len;\n\tfor (;;) {\n\t\tseq = tcp_sk(ssk)->copied_seq + subflow->map_csum_len;\n\t\toffset = seq - TCP_SKB_CB(skb)->seq;\n\n\t\t \n\t\tif (offset < skb->len) {\n\t\t\t__wsum csum;\n\n\t\t\tlen = min(skb->len - offset, delta);\n\t\t\tcsum = skb_checksum(skb, offset, len, 0);\n\t\t\tsubflow->map_data_csum = csum_block_add(subflow->map_data_csum, csum,\n\t\t\t\t\t\t\t\tsubflow->map_csum_len);\n\n\t\t\tdelta -= len;\n\t\t\tsubflow->map_csum_len += len;\n\t\t}\n\t\tif (delta == 0)\n\t\t\tbreak;\n\n\t\tif (skb_queue_is_last(&ssk->sk_receive_queue, skb)) {\n\t\t\t \n\t\t\tif (unlikely(ssk->sk_state == TCP_CLOSE))\n\t\t\t\twhile ((skb = skb_peek(&ssk->sk_receive_queue)))\n\t\t\t\t\tsk_eat_skb(ssk, skb);\n\n\t\t\t \n\t\t\treturn MAPPING_EMPTY;\n\t\t}\n\n\t\t \n\t\tskb = skb->next;\n\t}\n\n\t \n\tcsum = __mptcp_make_csum(subflow->map_seq,\n\t\t\t\t subflow->map_subflow_seq,\n\t\t\t\t subflow->map_data_len + subflow->map_data_fin,\n\t\t\t\t subflow->map_data_csum);\n\tif (unlikely(csum)) {\n\t\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_DATACSUMERR);\n\t\treturn MAPPING_BAD_CSUM;\n\t}\n\n\tsubflow->valid_csum_seen = 1;\n\treturn MAPPING_OK;\n}\n\nstatic enum mapping_status get_mapping_status(struct sock *ssk,\n\t\t\t\t\t      struct mptcp_sock *msk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tbool csum_reqd = READ_ONCE(msk->csum_enabled);\n\tstruct mptcp_ext *mpext;\n\tstruct sk_buff *skb;\n\tu16 data_len;\n\tu64 map_seq;\n\n\tskb = skb_peek(&ssk->sk_receive_queue);\n\tif (!skb)\n\t\treturn MAPPING_EMPTY;\n\n\tif (mptcp_check_fallback(ssk))\n\t\treturn MAPPING_DUMMY;\n\n\tmpext = mptcp_get_ext(skb);\n\tif (!mpext || !mpext->use_map) {\n\t\tif (!subflow->map_valid && !skb->len) {\n\t\t\t \n\t\t\tif (!(TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN))\n\t\t\t\tWARN_ONCE(1, \"0len seq %d:%d flags %x\",\n\t\t\t\t\t  TCP_SKB_CB(skb)->seq,\n\t\t\t\t\t  TCP_SKB_CB(skb)->end_seq,\n\t\t\t\t\t  TCP_SKB_CB(skb)->tcp_flags);\n\t\t\tsk_eat_skb(ssk, skb);\n\t\t\treturn MAPPING_EMPTY;\n\t\t}\n\n\t\tif (!subflow->map_valid)\n\t\t\treturn MAPPING_INVALID;\n\n\t\tgoto validate_seq;\n\t}\n\n\ttrace_get_mapping_status(mpext);\n\n\tdata_len = mpext->data_len;\n\tif (data_len == 0) {\n\t\tpr_debug(\"infinite mapping received\");\n\t\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_INFINITEMAPRX);\n\t\tsubflow->map_data_len = 0;\n\t\treturn MAPPING_INVALID;\n\t}\n\n\tif (mpext->data_fin == 1) {\n\t\tif (data_len == 1) {\n\t\t\tbool updated = mptcp_update_rcv_data_fin(msk, mpext->data_seq,\n\t\t\t\t\t\t\t\t mpext->dsn64);\n\t\t\tpr_debug(\"DATA_FIN with no payload seq=%llu\", mpext->data_seq);\n\t\t\tif (subflow->map_valid) {\n\t\t\t\t \n\t\t\t\tskb_ext_del(skb, SKB_EXT_MPTCP);\n\t\t\t\treturn MAPPING_OK;\n\t\t\t} else {\n\t\t\t\tif (updated)\n\t\t\t\t\tmptcp_schedule_work((struct sock *)msk);\n\n\t\t\t\treturn MAPPING_DATA_FIN;\n\t\t\t}\n\t\t} else {\n\t\t\tu64 data_fin_seq = mpext->data_seq + data_len - 1;\n\n\t\t\t \n\t\t\tif (!mpext->dsn64)\n\t\t\t\tdata_fin_seq &= GENMASK_ULL(31, 0);\n\n\t\t\tmptcp_update_rcv_data_fin(msk, data_fin_seq, mpext->dsn64);\n\t\t\tpr_debug(\"DATA_FIN with mapping seq=%llu dsn64=%d\",\n\t\t\t\t data_fin_seq, mpext->dsn64);\n\t\t}\n\n\t\t \n\t\tdata_len--;\n\t}\n\n\tmap_seq = mptcp_expand_seq(READ_ONCE(msk->ack_seq), mpext->data_seq, mpext->dsn64);\n\tWRITE_ONCE(mptcp_sk(subflow->conn)->use_64bit_ack, !!mpext->dsn64);\n\n\tif (subflow->map_valid) {\n\t\t \n\t\tif (subflow->map_seq == map_seq &&\n\t\t    subflow->map_subflow_seq == mpext->subflow_seq &&\n\t\t    subflow->map_data_len == data_len &&\n\t\t    subflow->map_csum_reqd == mpext->csum_reqd) {\n\t\t\tskb_ext_del(skb, SKB_EXT_MPTCP);\n\t\t\tgoto validate_csum;\n\t\t}\n\n\t\t \n\t\tif (skb_is_fully_mapped(ssk, skb)) {\n\t\t\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_DSSNOMATCH);\n\t\t\treturn MAPPING_INVALID;\n\t\t}\n\n\t\t \n\t\tgoto validate_csum;\n\t}\n\n\tsubflow->map_seq = map_seq;\n\tsubflow->map_subflow_seq = mpext->subflow_seq;\n\tsubflow->map_data_len = data_len;\n\tsubflow->map_valid = 1;\n\tsubflow->map_data_fin = mpext->data_fin;\n\tsubflow->mpc_map = mpext->mpc_map;\n\tsubflow->map_csum_reqd = mpext->csum_reqd;\n\tsubflow->map_csum_len = 0;\n\tsubflow->map_data_csum = csum_unfold(mpext->csum);\n\n\t \n\tif (unlikely(subflow->map_csum_reqd != csum_reqd))\n\t\treturn MAPPING_INVALID;\n\n\tpr_debug(\"new map seq=%llu subflow_seq=%u data_len=%u csum=%d:%u\",\n\t\t subflow->map_seq, subflow->map_subflow_seq,\n\t\t subflow->map_data_len, subflow->map_csum_reqd,\n\t\t subflow->map_data_csum);\n\nvalidate_seq:\n\t \n\tif (!validate_mapping(ssk, skb)) {\n\t\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_DSSTCPMISMATCH);\n\t\treturn MAPPING_INVALID;\n\t}\n\n\tskb_ext_del(skb, SKB_EXT_MPTCP);\n\nvalidate_csum:\n\treturn validate_data_csum(ssk, skb, csum_reqd);\n}\n\nstatic void mptcp_subflow_discard_data(struct sock *ssk, struct sk_buff *skb,\n\t\t\t\t       u64 limit)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tbool fin = TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN;\n\tu32 incr;\n\n\tincr = limit >= skb->len ? skb->len + fin : limit;\n\n\tpr_debug(\"discarding=%d len=%d seq=%d\", incr, skb->len,\n\t\t subflow->map_subflow_seq);\n\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_DUPDATA);\n\ttcp_sk(ssk)->copied_seq += incr;\n\tif (!before(tcp_sk(ssk)->copied_seq, TCP_SKB_CB(skb)->end_seq))\n\t\tsk_eat_skb(ssk, skb);\n\tif (mptcp_subflow_get_map_offset(subflow) >= subflow->map_data_len)\n\t\tsubflow->map_valid = 0;\n}\n\n \nstatic void subflow_sched_work_if_closed(struct mptcp_sock *msk, struct sock *ssk)\n{\n\tif (likely(ssk->sk_state != TCP_CLOSE))\n\t\treturn;\n\n\tif (skb_queue_empty(&ssk->sk_receive_queue) &&\n\t    !test_and_set_bit(MPTCP_WORK_CLOSE_SUBFLOW, &msk->flags))\n\t\tmptcp_schedule_work((struct sock *)msk);\n}\n\nstatic bool subflow_can_fallback(struct mptcp_subflow_context *subflow)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\n\tif (subflow->mp_join)\n\t\treturn false;\n\telse if (READ_ONCE(msk->csum_enabled))\n\t\treturn !subflow->valid_csum_seen;\n\telse\n\t\treturn !subflow->fully_established;\n}\n\nstatic void mptcp_subflow_fail(struct mptcp_sock *msk, struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tunsigned long fail_tout;\n\n\t \n\tif (WARN_ON_ONCE(ssk != READ_ONCE(msk->first)))\n\t\treturn;\n\n\t \n\tif (sock_flag((struct sock *)msk, SOCK_DEAD))\n\t\treturn;\n\n\t \n\tfail_tout = jiffies + TCP_RTO_MAX;\n\tif (!fail_tout)\n\t\tfail_tout = 1;\n\tWRITE_ONCE(subflow->fail_tout, fail_tout);\n\ttcp_send_ack(ssk);\n\n\tmptcp_reset_tout_timer(msk, subflow->fail_tout);\n}\n\nstatic bool subflow_check_data_avail(struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tenum mapping_status status;\n\tstruct mptcp_sock *msk;\n\tstruct sk_buff *skb;\n\n\tif (!skb_peek(&ssk->sk_receive_queue))\n\t\tWRITE_ONCE(subflow->data_avail, MPTCP_SUBFLOW_NODATA);\n\tif (subflow->data_avail)\n\t\treturn true;\n\n\tmsk = mptcp_sk(subflow->conn);\n\tfor (;;) {\n\t\tu64 ack_seq;\n\t\tu64 old_ack;\n\n\t\tstatus = get_mapping_status(ssk, msk);\n\t\ttrace_subflow_check_data_avail(status, skb_peek(&ssk->sk_receive_queue));\n\t\tif (unlikely(status == MAPPING_INVALID || status == MAPPING_DUMMY ||\n\t\t\t     status == MAPPING_BAD_CSUM))\n\t\t\tgoto fallback;\n\n\t\tif (status != MAPPING_OK)\n\t\t\tgoto no_data;\n\n\t\tskb = skb_peek(&ssk->sk_receive_queue);\n\t\tif (WARN_ON_ONCE(!skb))\n\t\t\tgoto no_data;\n\n\t\tif (unlikely(!READ_ONCE(msk->can_ack)))\n\t\t\tgoto fallback;\n\n\t\told_ack = READ_ONCE(msk->ack_seq);\n\t\tack_seq = mptcp_subflow_get_mapped_dsn(subflow);\n\t\tpr_debug(\"msk ack_seq=%llx subflow ack_seq=%llx\", old_ack,\n\t\t\t ack_seq);\n\t\tif (unlikely(before64(ack_seq, old_ack))) {\n\t\t\tmptcp_subflow_discard_data(ssk, skb, old_ack - ack_seq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tWRITE_ONCE(subflow->data_avail, MPTCP_SUBFLOW_DATA_AVAIL);\n\t\tbreak;\n\t}\n\treturn true;\n\nno_data:\n\tsubflow_sched_work_if_closed(msk, ssk);\n\treturn false;\n\nfallback:\n\tif (!__mptcp_check_fallback(msk)) {\n\t\t \n\t\tif (status == MAPPING_BAD_CSUM &&\n\t\t    (subflow->mp_join || subflow->valid_csum_seen)) {\n\t\t\tsubflow->send_mp_fail = 1;\n\n\t\t\tif (!READ_ONCE(msk->allow_infinite_fallback)) {\n\t\t\t\tsubflow->reset_transient = 0;\n\t\t\t\tsubflow->reset_reason = MPTCP_RST_EMIDDLEBOX;\n\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\tmptcp_subflow_fail(msk, ssk);\n\t\t\tWRITE_ONCE(subflow->data_avail, MPTCP_SUBFLOW_DATA_AVAIL);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!subflow_can_fallback(subflow) && subflow->map_data_len) {\n\t\t\t \n\t\t\tsubflow->reset_transient = 0;\n\t\t\tsubflow->reset_reason = MPTCP_RST_EMPTCP;\n\nreset:\n\t\t\tWRITE_ONCE(ssk->sk_err, EBADMSG);\n\t\t\ttcp_set_state(ssk, TCP_CLOSE);\n\t\t\twhile ((skb = skb_peek(&ssk->sk_receive_queue)))\n\t\t\t\tsk_eat_skb(ssk, skb);\n\t\t\ttcp_send_active_reset(ssk, GFP_ATOMIC);\n\t\t\tWRITE_ONCE(subflow->data_avail, MPTCP_SUBFLOW_NODATA);\n\t\t\treturn false;\n\t\t}\n\n\t\tmptcp_do_fallback(ssk);\n\t}\n\n\tskb = skb_peek(&ssk->sk_receive_queue);\n\tsubflow->map_valid = 1;\n\tsubflow->map_seq = READ_ONCE(msk->ack_seq);\n\tsubflow->map_data_len = skb->len;\n\tsubflow->map_subflow_seq = tcp_sk(ssk)->copied_seq - subflow->ssn_offset;\n\tWRITE_ONCE(subflow->data_avail, MPTCP_SUBFLOW_DATA_AVAIL);\n\treturn true;\n}\n\nbool mptcp_subflow_data_available(struct sock *sk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\n\t \n\tif (subflow->map_valid &&\n\t    mptcp_subflow_get_map_offset(subflow) >= subflow->map_data_len) {\n\t\tsubflow->map_valid = 0;\n\t\tWRITE_ONCE(subflow->data_avail, MPTCP_SUBFLOW_NODATA);\n\n\t\tpr_debug(\"Done with mapping: seq=%u data_len=%u\",\n\t\t\t subflow->map_subflow_seq,\n\t\t\t subflow->map_data_len);\n\t}\n\n\treturn subflow_check_data_avail(sk);\n}\n\n \nvoid mptcp_space(const struct sock *ssk, int *space, int *full_space)\n{\n\tconst struct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tconst struct sock *sk = subflow->conn;\n\n\t*space = __mptcp_space(sk);\n\t*full_space = mptcp_win_from_space(sk, READ_ONCE(sk->sk_rcvbuf));\n}\n\nstatic void subflow_error_report(struct sock *ssk)\n{\n\tstruct sock *sk = mptcp_subflow_ctx(ssk)->conn;\n\n\t \n\tif (!sk->sk_socket)\n\t\treturn;\n\n\tmptcp_data_lock(sk);\n\tif (!sock_owned_by_user(sk))\n\t\t__mptcp_error_report(sk);\n\telse\n\t\t__set_bit(MPTCP_ERROR_REPORT,  &mptcp_sk(sk)->cb_flags);\n\tmptcp_data_unlock(sk);\n}\n\nstatic void subflow_data_ready(struct sock *sk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tu16 state = 1 << inet_sk_state_load(sk);\n\tstruct sock *parent = subflow->conn;\n\tstruct mptcp_sock *msk;\n\n\ttrace_sk_data_ready(sk);\n\n\tmsk = mptcp_sk(parent);\n\tif (state & TCPF_LISTEN) {\n\t\t \n\t\tif (reqsk_queue_empty(&inet_csk(sk)->icsk_accept_queue))\n\t\t\treturn;\n\n\t\tparent->sk_data_ready(parent);\n\t\treturn;\n\t}\n\n\tWARN_ON_ONCE(!__mptcp_check_fallback(msk) && !subflow->mp_capable &&\n\t\t     !subflow->mp_join && !(state & TCPF_CLOSE));\n\n\tif (mptcp_subflow_data_available(sk))\n\t\tmptcp_data_ready(parent, sk);\n\telse if (unlikely(sk->sk_err))\n\t\tsubflow_error_report(sk);\n}\n\nstatic void subflow_write_space(struct sock *ssk)\n{\n\tstruct sock *sk = mptcp_subflow_ctx(ssk)->conn;\n\n\tmptcp_propagate_sndbuf(sk, ssk);\n\tmptcp_write_space(sk);\n}\n\nstatic const struct inet_connection_sock_af_ops *\nsubflow_default_af_ops(struct sock *sk)\n{\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\tif (sk->sk_family == AF_INET6)\n\t\treturn &subflow_v6_specific;\n#endif\n\treturn &subflow_specific;\n}\n\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\nvoid mptcpv6_handle_mapped(struct sock *sk, bool mapped)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tconst struct inet_connection_sock_af_ops *target;\n\n\ttarget = mapped ? &subflow_v6m_specific : subflow_default_af_ops(sk);\n\n\tpr_debug(\"subflow=%p family=%d ops=%p target=%p mapped=%d\",\n\t\t subflow, sk->sk_family, icsk->icsk_af_ops, target, mapped);\n\n\tif (likely(icsk->icsk_af_ops == target))\n\t\treturn;\n\n\tsubflow->icsk_af_ops = icsk->icsk_af_ops;\n\ticsk->icsk_af_ops = target;\n}\n#endif\n\nvoid mptcp_info2sockaddr(const struct mptcp_addr_info *info,\n\t\t\t struct sockaddr_storage *addr,\n\t\t\t unsigned short family)\n{\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->ss_family = family;\n\tif (addr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *in_addr = (struct sockaddr_in *)addr;\n\n\t\tif (info->family == AF_INET)\n\t\t\tin_addr->sin_addr = info->addr;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t\telse if (ipv6_addr_v4mapped(&info->addr6))\n\t\t\tin_addr->sin_addr.s_addr = info->addr6.s6_addr32[3];\n#endif\n\t\tin_addr->sin_port = info->port;\n\t}\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\telse if (addr->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)addr;\n\n\t\tif (info->family == AF_INET)\n\t\t\tipv6_addr_set_v4mapped(info->addr.s_addr,\n\t\t\t\t\t       &in6_addr->sin6_addr);\n\t\telse\n\t\t\tin6_addr->sin6_addr = info->addr6;\n\t\tin6_addr->sin6_port = info->port;\n\t}\n#endif\n}\n\nint __mptcp_subflow_connect(struct sock *sk, const struct mptcp_addr_info *loc,\n\t\t\t    const struct mptcp_addr_info *remote)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sockaddr_storage addr;\n\tint remote_id = remote->id;\n\tint local_id = loc->id;\n\tint err = -ENOTCONN;\n\tstruct socket *sf;\n\tstruct sock *ssk;\n\tu32 remote_token;\n\tint addrlen;\n\tint ifindex;\n\tu8 flags;\n\n\tif (!mptcp_is_fully_established(sk))\n\t\tgoto err_out;\n\n\terr = mptcp_subflow_create_socket(sk, loc->family, &sf);\n\tif (err)\n\t\tgoto err_out;\n\n\tssk = sf->sk;\n\tsubflow = mptcp_subflow_ctx(ssk);\n\tdo {\n\t\tget_random_bytes(&subflow->local_nonce, sizeof(u32));\n\t} while (!subflow->local_nonce);\n\n\tif (local_id)\n\t\tsubflow_set_local_id(subflow, local_id);\n\n\tmptcp_pm_get_flags_and_ifindex_by_id(msk, local_id,\n\t\t\t\t\t     &flags, &ifindex);\n\tsubflow->remote_key_valid = 1;\n\tsubflow->remote_key = msk->remote_key;\n\tsubflow->local_key = msk->local_key;\n\tsubflow->token = msk->token;\n\tmptcp_info2sockaddr(loc, &addr, ssk->sk_family);\n\n\taddrlen = sizeof(struct sockaddr_in);\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\tif (addr.ss_family == AF_INET6)\n\t\taddrlen = sizeof(struct sockaddr_in6);\n#endif\n\tmptcp_sockopt_sync(msk, ssk);\n\n\tssk->sk_bound_dev_if = ifindex;\n\terr = kernel_bind(sf, (struct sockaddr *)&addr, addrlen);\n\tif (err)\n\t\tgoto failed;\n\n\tmptcp_crypto_key_sha(subflow->remote_key, &remote_token, NULL);\n\tpr_debug(\"msk=%p remote_token=%u local_id=%d remote_id=%d\", msk,\n\t\t remote_token, local_id, remote_id);\n\tsubflow->remote_token = remote_token;\n\tsubflow->remote_id = remote_id;\n\tsubflow->request_join = 1;\n\tsubflow->request_bkup = !!(flags & MPTCP_PM_ADDR_FLAG_BACKUP);\n\tsubflow->subflow_id = msk->subflow_id++;\n\tmptcp_info2sockaddr(remote, &addr, ssk->sk_family);\n\n\tsock_hold(ssk);\n\tlist_add_tail(&subflow->node, &msk->conn_list);\n\terr = kernel_connect(sf, (struct sockaddr *)&addr, addrlen, O_NONBLOCK);\n\tif (err && err != -EINPROGRESS)\n\t\tgoto failed_unlink;\n\n\t \n\tmptcp_sock_graft(ssk, sk->sk_socket);\n\tiput(SOCK_INODE(sf));\n\tWRITE_ONCE(msk->allow_infinite_fallback, false);\n\tmptcp_stop_tout_timer(sk);\n\treturn 0;\n\nfailed_unlink:\n\tlist_del(&subflow->node);\n\tsock_put(mptcp_subflow_tcp_sock(subflow));\n\nfailed:\n\tsubflow->disposable = 1;\n\tsock_release(sf);\n\nerr_out:\n\t \n\tmptcp_pm_close_subflow(msk);\n\treturn err;\n}\n\nstatic void mptcp_attach_cgroup(struct sock *parent, struct sock *child)\n{\n#ifdef CONFIG_SOCK_CGROUP_DATA\n\tstruct sock_cgroup_data *parent_skcd = &parent->sk_cgrp_data,\n\t\t\t\t*child_skcd = &child->sk_cgrp_data;\n\n\t \n\tif (cgroup_id(sock_cgroup_ptr(parent_skcd)) !=\n\t    cgroup_id(sock_cgroup_ptr(child_skcd))) {\n#ifdef CONFIG_MEMCG\n\t\tstruct mem_cgroup *memcg = parent->sk_memcg;\n\n\t\tmem_cgroup_sk_free(child);\n\t\tif (memcg && css_tryget(&memcg->css))\n\t\t\tchild->sk_memcg = memcg;\n#endif  \n\n\t\tcgroup_sk_free(child_skcd);\n\t\t*child_skcd = *parent_skcd;\n\t\tcgroup_sk_clone(child_skcd);\n\t}\n#endif  \n}\n\nstatic void mptcp_subflow_ops_override(struct sock *ssk)\n{\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\tif (ssk->sk_prot == &tcpv6_prot)\n\t\tssk->sk_prot = &tcpv6_prot_override;\n\telse\n#endif\n\t\tssk->sk_prot = &tcp_prot_override;\n}\n\nstatic void mptcp_subflow_ops_undo_override(struct sock *ssk)\n{\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\tif (ssk->sk_prot == &tcpv6_prot_override)\n\t\tssk->sk_prot = &tcpv6_prot;\n\telse\n#endif\n\t\tssk->sk_prot = &tcp_prot;\n}\n\nint mptcp_subflow_create_socket(struct sock *sk, unsigned short family,\n\t\t\t\tstruct socket **new_sock)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct net *net = sock_net(sk);\n\tstruct socket *sf;\n\tint err;\n\n\t \n\tif (unlikely(!sk->sk_socket))\n\t\treturn -EINVAL;\n\n\terr = sock_create_kern(net, family, SOCK_STREAM, IPPROTO_TCP, &sf);\n\tif (err)\n\t\treturn err;\n\n\tlock_sock_nested(sf->sk, SINGLE_DEPTH_NESTING);\n\n\terr = security_mptcp_add_subflow(sk, sf->sk);\n\tif (err)\n\t\tgoto release_ssk;\n\n\t \n\tmptcp_attach_cgroup(sk, sf->sk);\n\n\t \n\t__netns_tracker_free(net, &sf->sk->ns_tracker, false);\n\tsf->sk->sk_net_refcnt = 1;\n\tget_net_track(net, &sf->sk->ns_tracker, GFP_KERNEL);\n\tsock_inuse_add(net, 1);\n\terr = tcp_set_ulp(sf->sk, \"mptcp\");\n\nrelease_ssk:\n\trelease_sock(sf->sk);\n\n\tif (err) {\n\t\tsock_release(sf);\n\t\treturn err;\n\t}\n\n\t \n\tSOCK_INODE(sf)->i_ino = SOCK_INODE(sk->sk_socket)->i_ino;\n\tSOCK_INODE(sf)->i_uid = SOCK_INODE(sk->sk_socket)->i_uid;\n\tSOCK_INODE(sf)->i_gid = SOCK_INODE(sk->sk_socket)->i_gid;\n\n\tsubflow = mptcp_subflow_ctx(sf->sk);\n\tpr_debug(\"subflow=%p\", subflow);\n\n\t*new_sock = sf;\n\tsock_hold(sk);\n\tsubflow->conn = sk;\n\tmptcp_subflow_ops_override(sf->sk);\n\n\treturn 0;\n}\n\nstatic struct mptcp_subflow_context *subflow_create_ctx(struct sock *sk,\n\t\t\t\t\t\t\tgfp_t priority)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct mptcp_subflow_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), priority);\n\tif (!ctx)\n\t\treturn NULL;\n\n\trcu_assign_pointer(icsk->icsk_ulp_data, ctx);\n\tINIT_LIST_HEAD(&ctx->node);\n\tINIT_LIST_HEAD(&ctx->delegated_node);\n\n\tpr_debug(\"subflow=%p\", ctx);\n\n\tctx->tcp_sock = sk;\n\n\treturn ctx;\n}\n\nstatic void __subflow_state_change(struct sock *sk)\n{\n\tstruct socket_wq *wq;\n\n\trcu_read_lock();\n\twq = rcu_dereference(sk->sk_wq);\n\tif (skwq_has_sleeper(wq))\n\t\twake_up_interruptible_all(&wq->wait);\n\trcu_read_unlock();\n}\n\nstatic bool subflow_is_done(const struct sock *sk)\n{\n\treturn sk->sk_shutdown & RCV_SHUTDOWN || sk->sk_state == TCP_CLOSE;\n}\n\nstatic void subflow_state_change(struct sock *sk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tstruct sock *parent = subflow->conn;\n\tstruct mptcp_sock *msk;\n\n\t__subflow_state_change(sk);\n\n\tmsk = mptcp_sk(parent);\n\tif (subflow_simultaneous_connect(sk)) {\n\t\tmptcp_do_fallback(sk);\n\t\tmptcp_rcv_space_init(msk, sk);\n\t\tpr_fallback(msk);\n\t\tsubflow->conn_finished = 1;\n\t\tmptcp_propagate_state(parent, sk);\n\t}\n\n\t \n\tif (mptcp_subflow_data_available(sk))\n\t\tmptcp_data_ready(parent, sk);\n\telse if (unlikely(sk->sk_err))\n\t\tsubflow_error_report(sk);\n\n\tsubflow_sched_work_if_closed(mptcp_sk(parent), sk);\n\n\t \n\tif (__mptcp_check_fallback(msk) && subflow_is_done(sk) && msk->first == sk &&\n\t    mptcp_update_rcv_data_fin(msk, READ_ONCE(msk->ack_seq), true))\n\t\tmptcp_schedule_work(parent);\n}\n\nvoid mptcp_subflow_queue_clean(struct sock *listener_sk, struct sock *listener_ssk)\n{\n\tstruct request_sock_queue *queue = &inet_csk(listener_ssk)->icsk_accept_queue;\n\tstruct request_sock *req, *head, *tail;\n\tstruct mptcp_subflow_context *subflow;\n\tstruct sock *sk, *ssk;\n\n\t \n\tspin_lock_bh(&queue->rskq_lock);\n\thead = queue->rskq_accept_head;\n\ttail = queue->rskq_accept_tail;\n\tqueue->rskq_accept_head = NULL;\n\tqueue->rskq_accept_tail = NULL;\n\tspin_unlock_bh(&queue->rskq_lock);\n\n\tif (!head)\n\t\treturn;\n\n\t \n\trelease_sock(listener_ssk);\n\n\tfor (req = head; req; req = req->dl_next) {\n\t\tssk = req->sk;\n\t\tif (!sk_is_mptcp(ssk))\n\t\t\tcontinue;\n\n\t\tsubflow = mptcp_subflow_ctx(ssk);\n\t\tif (!subflow || !subflow->conn)\n\t\t\tcontinue;\n\n\t\tsk = subflow->conn;\n\t\tsock_hold(sk);\n\n\t\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\t\t__mptcp_unaccepted_force_close(sk);\n\t\trelease_sock(sk);\n\n\t\t \n\t\tmutex_release(&listener_sk->sk_lock.dep_map, _RET_IP_);\n\t\tmptcp_cancel_work(sk);\n\t\tmutex_acquire(&listener_sk->sk_lock.dep_map, 0, 0, _RET_IP_);\n\n\t\tsock_put(sk);\n\t}\n\n\t \n\tlock_sock_nested(listener_ssk, SINGLE_DEPTH_NESTING);\n\n\t \n\tspin_lock_bh(&queue->rskq_lock);\n\tWARN_ON_ONCE(queue->rskq_accept_head);\n\tqueue->rskq_accept_head = head;\n\tqueue->rskq_accept_tail = tail;\n\tspin_unlock_bh(&queue->rskq_lock);\n}\n\nstatic int subflow_ulp_init(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct mptcp_subflow_context *ctx;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint err = 0;\n\n\t \n\tif (!sk->sk_kern_sock) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tctx = subflow_create_ctx(sk, GFP_KERNEL);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"subflow=%p, family=%d\", ctx, sk->sk_family);\n\n\ttp->is_mptcp = 1;\n\tctx->icsk_af_ops = icsk->icsk_af_ops;\n\ticsk->icsk_af_ops = subflow_default_af_ops(sk);\n\tctx->tcp_state_change = sk->sk_state_change;\n\tctx->tcp_error_report = sk->sk_error_report;\n\n\tWARN_ON_ONCE(sk->sk_data_ready != sock_def_readable);\n\tWARN_ON_ONCE(sk->sk_write_space != sk_stream_write_space);\n\n\tsk->sk_data_ready = subflow_data_ready;\n\tsk->sk_write_space = subflow_write_space;\n\tsk->sk_state_change = subflow_state_change;\n\tsk->sk_error_report = subflow_error_report;\nout:\n\treturn err;\n}\n\nstatic void subflow_ulp_release(struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *ctx = mptcp_subflow_ctx(ssk);\n\tbool release = true;\n\tstruct sock *sk;\n\n\tif (!ctx)\n\t\treturn;\n\n\tsk = ctx->conn;\n\tif (sk) {\n\t\t \n\t\trelease = ctx->disposable || list_empty(&ctx->node);\n\n\t\t \n\t\tif (!release && !test_and_set_bit(MPTCP_WORK_CLOSE_SUBFLOW,\n\t\t\t\t\t\t  &mptcp_sk(sk)->flags))\n\t\t\tmptcp_schedule_work(sk);\n\t\tsock_put(sk);\n\t}\n\n\tmptcp_subflow_ops_undo_override(ssk);\n\tif (release)\n\t\tkfree_rcu(ctx, rcu);\n}\n\nstatic void subflow_ulp_clone(const struct request_sock *req,\n\t\t\t      struct sock *newsk,\n\t\t\t      const gfp_t priority)\n{\n\tstruct mptcp_subflow_request_sock *subflow_req = mptcp_subflow_rsk(req);\n\tstruct mptcp_subflow_context *old_ctx = mptcp_subflow_ctx(newsk);\n\tstruct mptcp_subflow_context *new_ctx;\n\n\tif (!tcp_rsk(req)->is_mptcp ||\n\t    (!subflow_req->mp_capable && !subflow_req->mp_join)) {\n\t\tsubflow_ulp_fallback(newsk, old_ctx);\n\t\treturn;\n\t}\n\n\tnew_ctx = subflow_create_ctx(newsk, priority);\n\tif (!new_ctx) {\n\t\tsubflow_ulp_fallback(newsk, old_ctx);\n\t\treturn;\n\t}\n\n\tnew_ctx->conn_finished = 1;\n\tnew_ctx->icsk_af_ops = old_ctx->icsk_af_ops;\n\tnew_ctx->tcp_state_change = old_ctx->tcp_state_change;\n\tnew_ctx->tcp_error_report = old_ctx->tcp_error_report;\n\tnew_ctx->rel_write_seq = 1;\n\tnew_ctx->tcp_sock = newsk;\n\n\tif (subflow_req->mp_capable) {\n\t\t \n\t\tnew_ctx->mp_capable = 1;\n\t\tnew_ctx->local_key = subflow_req->local_key;\n\t\tnew_ctx->token = subflow_req->token;\n\t\tnew_ctx->ssn_offset = subflow_req->ssn_offset;\n\t\tnew_ctx->idsn = subflow_req->idsn;\n\n\t\t \n\t\tnew_ctx->local_id_valid = 1;\n\t} else if (subflow_req->mp_join) {\n\t\tnew_ctx->ssn_offset = subflow_req->ssn_offset;\n\t\tnew_ctx->mp_join = 1;\n\t\tnew_ctx->fully_established = 1;\n\t\tnew_ctx->remote_key_valid = 1;\n\t\tnew_ctx->backup = subflow_req->backup;\n\t\tnew_ctx->remote_id = subflow_req->remote_id;\n\t\tnew_ctx->token = subflow_req->token;\n\t\tnew_ctx->thmac = subflow_req->thmac;\n\n\t\t \n\t\tsubflow_set_local_id(new_ctx, subflow_req->local_id);\n\t}\n}\n\nstatic void tcp_release_cb_override(struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tlong status;\n\n\t \n\tstatus = set_mask_bits(&subflow->delegated_status, MPTCP_DELEGATE_ACTIONS_MASK, 0);\n\tif (status)\n\t\tmptcp_subflow_process_delegated(ssk, status);\n\n\ttcp_release_cb(ssk);\n}\n\nstatic int tcp_abort_override(struct sock *ssk, int err)\n{\n\t \n\tif (inet_sk_state_load(ssk) == TCP_LISTEN)\n\t\treturn -EINVAL;\n\n\treturn tcp_abort(ssk, err);\n}\n\nstatic struct tcp_ulp_ops subflow_ulp_ops __read_mostly = {\n\t.name\t\t= \"mptcp\",\n\t.owner\t\t= THIS_MODULE,\n\t.init\t\t= subflow_ulp_init,\n\t.release\t= subflow_ulp_release,\n\t.clone\t\t= subflow_ulp_clone,\n};\n\nstatic int subflow_ops_init(struct request_sock_ops *subflow_ops)\n{\n\tsubflow_ops->obj_size = sizeof(struct mptcp_subflow_request_sock);\n\n\tsubflow_ops->slab = kmem_cache_create(subflow_ops->slab_name,\n\t\t\t\t\t      subflow_ops->obj_size, 0,\n\t\t\t\t\t      SLAB_ACCOUNT |\n\t\t\t\t\t      SLAB_TYPESAFE_BY_RCU,\n\t\t\t\t\t      NULL);\n\tif (!subflow_ops->slab)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid __init mptcp_subflow_init(void)\n{\n\tmptcp_subflow_v4_request_sock_ops = tcp_request_sock_ops;\n\tmptcp_subflow_v4_request_sock_ops.slab_name = \"request_sock_subflow_v4\";\n\tmptcp_subflow_v4_request_sock_ops.destructor = subflow_v4_req_destructor;\n\n\tif (subflow_ops_init(&mptcp_subflow_v4_request_sock_ops) != 0)\n\t\tpanic(\"MPTCP: failed to init subflow v4 request sock ops\\n\");\n\n\tsubflow_request_sock_ipv4_ops = tcp_request_sock_ipv4_ops;\n\tsubflow_request_sock_ipv4_ops.route_req = subflow_v4_route_req;\n\tsubflow_request_sock_ipv4_ops.send_synack = subflow_v4_send_synack;\n\n\tsubflow_specific = ipv4_specific;\n\tsubflow_specific.conn_request = subflow_v4_conn_request;\n\tsubflow_specific.syn_recv_sock = subflow_syn_recv_sock;\n\tsubflow_specific.sk_rx_dst_set = subflow_finish_connect;\n\tsubflow_specific.rebuild_header = subflow_rebuild_header;\n\n\ttcp_prot_override = tcp_prot;\n\ttcp_prot_override.release_cb = tcp_release_cb_override;\n\ttcp_prot_override.diag_destroy = tcp_abort_override;\n\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t \n\tBUILD_BUG_ON(sizeof(struct tcp_request_sock) != sizeof(struct tcp6_request_sock));\n\n\tmptcp_subflow_v6_request_sock_ops = tcp6_request_sock_ops;\n\tmptcp_subflow_v6_request_sock_ops.slab_name = \"request_sock_subflow_v6\";\n\tmptcp_subflow_v6_request_sock_ops.destructor = subflow_v6_req_destructor;\n\n\tif (subflow_ops_init(&mptcp_subflow_v6_request_sock_ops) != 0)\n\t\tpanic(\"MPTCP: failed to init subflow v6 request sock ops\\n\");\n\n\tsubflow_request_sock_ipv6_ops = tcp_request_sock_ipv6_ops;\n\tsubflow_request_sock_ipv6_ops.route_req = subflow_v6_route_req;\n\tsubflow_request_sock_ipv6_ops.send_synack = subflow_v6_send_synack;\n\n\tsubflow_v6_specific = ipv6_specific;\n\tsubflow_v6_specific.conn_request = subflow_v6_conn_request;\n\tsubflow_v6_specific.syn_recv_sock = subflow_syn_recv_sock;\n\tsubflow_v6_specific.sk_rx_dst_set = subflow_finish_connect;\n\tsubflow_v6_specific.rebuild_header = subflow_v6_rebuild_header;\n\n\tsubflow_v6m_specific = subflow_v6_specific;\n\tsubflow_v6m_specific.queue_xmit = ipv4_specific.queue_xmit;\n\tsubflow_v6m_specific.send_check = ipv4_specific.send_check;\n\tsubflow_v6m_specific.net_header_len = ipv4_specific.net_header_len;\n\tsubflow_v6m_specific.mtu_reduced = ipv4_specific.mtu_reduced;\n\tsubflow_v6m_specific.net_frag_header_len = 0;\n\tsubflow_v6m_specific.rebuild_header = subflow_rebuild_header;\n\n\ttcpv6_prot_override = tcpv6_prot;\n\ttcpv6_prot_override.release_cb = tcp_release_cb_override;\n\ttcpv6_prot_override.diag_destroy = tcp_abort_override;\n#endif\n\n\tmptcp_diag_subflow_init(&subflow_ulp_ops);\n\n\tif (tcp_register_ulp(&subflow_ulp_ops) != 0)\n\t\tpanic(\"MPTCP: failed to register subflows to ULP\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}