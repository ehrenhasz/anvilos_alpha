{
  "module_name": "mptcp_diag.c",
  "hash_id": "333d56f5488ceaaa56e6ca8609a45746728a95caebc2f0be49d0c853ef705285",
  "original_prompt": "Ingested from linux-6.6.14/net/mptcp/mptcp_diag.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/net.h>\n#include <linux/inet_diag.h>\n#include <net/netlink.h>\n#include <uapi/linux/mptcp.h>\n#include \"protocol.h\"\n\nstatic int sk_diag_dump(struct sock *sk, struct sk_buff *skb,\n\t\t\tstruct netlink_callback *cb,\n\t\t\tconst struct inet_diag_req_v2 *req,\n\t\t\tstruct nlattr *bc, bool net_admin)\n{\n\tif (!inet_diag_bc_sk(bc, sk))\n\t\treturn 0;\n\n\treturn inet_sk_diag_fill(sk, inet_csk(sk), skb, cb, req, NLM_F_MULTI,\n\t\t\t\t net_admin);\n}\n\nstatic int mptcp_diag_dump_one(struct netlink_callback *cb,\n\t\t\t       const struct inet_diag_req_v2 *req)\n{\n\tstruct sk_buff *in_skb = cb->skb;\n\tstruct mptcp_sock *msk = NULL;\n\tstruct sk_buff *rep;\n\tint err = -ENOENT;\n\tstruct net *net;\n\tstruct sock *sk;\n\n\tnet = sock_net(in_skb->sk);\n\tmsk = mptcp_token_get_sock(net, req->id.idiag_cookie[0]);\n\tif (!msk)\n\t\tgoto out_nosk;\n\n\terr = -ENOMEM;\n\tsk = (struct sock *)msk;\n\trep = nlmsg_new(nla_total_size(sizeof(struct inet_diag_msg)) +\n\t\t\tinet_diag_msg_attrs_size() +\n\t\t\tnla_total_size(sizeof(struct mptcp_info)) +\n\t\t\tnla_total_size(sizeof(struct inet_diag_meminfo)) + 64,\n\t\t\tGFP_KERNEL);\n\tif (!rep)\n\t\tgoto out;\n\n\terr = inet_sk_diag_fill(sk, inet_csk(sk), rep, cb, req, 0,\n\t\t\t\tnetlink_net_capable(in_skb, CAP_NET_ADMIN));\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(rep);\n\t\tgoto out;\n\t}\n\terr = nlmsg_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid);\n\nout:\n\tsock_put(sk);\n\nout_nosk:\n\treturn err;\n}\n\nstruct mptcp_diag_ctx {\n\tlong s_slot;\n\tlong s_num;\n\tunsigned int l_slot;\n\tunsigned int l_num;\n};\n\nstatic void mptcp_diag_dump_listeners(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t\t      const struct inet_diag_req_v2 *r,\n\t\t\t\t      bool net_admin)\n{\n\tstruct inet_diag_dump_data *cb_data = cb->data;\n\tstruct mptcp_diag_ctx *diag_ctx = (void *)cb->ctx;\n\tstruct nlattr *bc = cb_data->inet_diag_nla_bc;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct inet_hashinfo *hinfo;\n\tint i;\n\n\thinfo = net->ipv4.tcp_death_row.hashinfo;\n\n\tfor (i = diag_ctx->l_slot; i <= hinfo->lhash2_mask; i++) {\n\t\tstruct inet_listen_hashbucket *ilb;\n\t\tstruct hlist_nulls_node *node;\n\t\tstruct sock *sk;\n\t\tint num = 0;\n\n\t\tilb = &hinfo->lhash2[i];\n\n\t\trcu_read_lock();\n\t\tspin_lock(&ilb->lock);\n\t\tsk_nulls_for_each(sk, node, &ilb->nulls_head) {\n\t\t\tconst struct mptcp_subflow_context *ctx = mptcp_subflow_ctx(sk);\n\t\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\t\tint ret;\n\n\t\t\tif (num < diag_ctx->l_num)\n\t\t\t\tgoto next_listen;\n\n\t\t\tif (!ctx || strcmp(inet_csk(sk)->icsk_ulp_ops->name, \"mptcp\"))\n\t\t\t\tgoto next_listen;\n\n\t\t\tsk = ctx->conn;\n\t\t\tif (!sk || !net_eq(sock_net(sk), net))\n\t\t\t\tgoto next_listen;\n\n\t\t\tif (r->sdiag_family != AF_UNSPEC &&\n\t\t\t    sk->sk_family != r->sdiag_family)\n\t\t\t\tgoto next_listen;\n\n\t\t\tif (r->id.idiag_sport != inet->inet_sport &&\n\t\t\t    r->id.idiag_sport)\n\t\t\t\tgoto next_listen;\n\n\t\t\tif (!refcount_inc_not_zero(&sk->sk_refcnt))\n\t\t\t\tgoto next_listen;\n\n\t\t\tret = sk_diag_dump(sk, skb, cb, r, bc, net_admin);\n\n\t\t\tsock_put(sk);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tspin_unlock(&ilb->lock);\n\t\t\t\trcu_read_unlock();\n\t\t\t\tdiag_ctx->l_slot = i;\n\t\t\t\tdiag_ctx->l_num = num;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdiag_ctx->l_num = num + 1;\n\t\t\tnum = 0;\nnext_listen:\n\t\t\t++num;\n\t\t}\n\t\tspin_unlock(&ilb->lock);\n\t\trcu_read_unlock();\n\n\t\tcond_resched();\n\t\tdiag_ctx->l_num = 0;\n\t}\n\n\tdiag_ctx->l_num = 0;\n\tdiag_ctx->l_slot = i;\n}\n\nstatic void mptcp_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t    const struct inet_diag_req_v2 *r)\n{\n\tbool net_admin = netlink_net_capable(cb->skb, CAP_NET_ADMIN);\n\tstruct mptcp_diag_ctx *diag_ctx = (void *)cb->ctx;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct inet_diag_dump_data *cb_data;\n\tstruct mptcp_sock *msk;\n\tstruct nlattr *bc;\n\n\tBUILD_BUG_ON(sizeof(cb->ctx) < sizeof(*diag_ctx));\n\n\tcb_data = cb->data;\n\tbc = cb_data->inet_diag_nla_bc;\n\n\twhile ((msk = mptcp_token_iter_next(net, &diag_ctx->s_slot,\n\t\t\t\t\t    &diag_ctx->s_num)) != NULL) {\n\t\tstruct inet_sock *inet = (struct inet_sock *)msk;\n\t\tstruct sock *sk = (struct sock *)msk;\n\t\tint ret = 0;\n\n\t\tif (!(r->idiag_states & (1 << sk->sk_state)))\n\t\t\tgoto next;\n\t\tif (r->sdiag_family != AF_UNSPEC &&\n\t\t    sk->sk_family != r->sdiag_family)\n\t\t\tgoto next;\n\t\tif (r->id.idiag_sport != inet->inet_sport &&\n\t\t    r->id.idiag_sport)\n\t\t\tgoto next;\n\t\tif (r->id.idiag_dport != inet->inet_dport &&\n\t\t    r->id.idiag_dport)\n\t\t\tgoto next;\n\n\t\tret = sk_diag_dump(sk, skb, cb, r, bc, net_admin);\nnext:\n\t\tsock_put(sk);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tdiag_ctx->s_num--;\n\t\t\tbreak;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\tif ((r->idiag_states & TCPF_LISTEN) && r->id.idiag_dport == 0)\n\t\tmptcp_diag_dump_listeners(skb, cb, r, net_admin);\n}\n\nstatic void mptcp_diag_get_info(struct sock *sk, struct inet_diag_msg *r,\n\t\t\t\tvoid *_info)\n{\n\tstruct mptcp_sock *msk = mptcp_sk(sk);\n\tstruct mptcp_info *info = _info;\n\n\tr->idiag_rqueue = sk_rmem_alloc_get(sk);\n\tr->idiag_wqueue = sk_wmem_alloc_get(sk);\n\n\tif (inet_sk_state_load(sk) == TCP_LISTEN) {\n\t\tstruct sock *lsk = READ_ONCE(msk->first);\n\n\t\tif (lsk) {\n\t\t\t \n\t\t\tr->idiag_rqueue = READ_ONCE(lsk->sk_ack_backlog);\n\t\t\tr->idiag_wqueue = READ_ONCE(lsk->sk_max_ack_backlog);\n\t\t}\n\t}\n\n\tif (!info)\n\t\treturn;\n\n\tmptcp_diag_fill_info(msk, info);\n}\n\nstatic const struct inet_diag_handler mptcp_diag_handler = {\n\t.dump\t\t = mptcp_diag_dump,\n\t.dump_one\t = mptcp_diag_dump_one,\n\t.idiag_get_info  = mptcp_diag_get_info,\n\t.idiag_type\t = IPPROTO_MPTCP,\n\t.idiag_info_size = sizeof(struct mptcp_info),\n};\n\nstatic int __init mptcp_diag_init(void)\n{\n\treturn inet_diag_register(&mptcp_diag_handler);\n}\n\nstatic void __exit mptcp_diag_exit(void)\n{\n\tinet_diag_unregister(&mptcp_diag_handler);\n}\n\nmodule_init(mptcp_diag_init);\nmodule_exit(mptcp_diag_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO_TYPE(PF_NETLINK, NETLINK_SOCK_DIAG, 2-262  );\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}