{
  "module_name": "options.c",
  "hash_id": "27d0c9b09771a2927f931c9b95228830c2d29a18365dd2083b82c65cb4430ce9",
  "original_prompt": "Ingested from linux-6.6.14/net/mptcp/options.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"MPTCP: \" fmt\n\n#include <linux/kernel.h>\n#include <crypto/sha2.h>\n#include <net/tcp.h>\n#include <net/mptcp.h>\n#include \"protocol.h\"\n#include \"mib.h\"\n\n#include <trace/events/mptcp.h>\n\nstatic bool mptcp_cap_flag_sha256(u8 flags)\n{\n\treturn (flags & MPTCP_CAP_FLAG_MASK) == MPTCP_CAP_HMAC_SHA256;\n}\n\nstatic void mptcp_parse_option(const struct sk_buff *skb,\n\t\t\t       const unsigned char *ptr, int opsize,\n\t\t\t       struct mptcp_options_received *mp_opt)\n{\n\tu8 subtype = *ptr >> 4;\n\tint expected_opsize;\n\tu16 subopt;\n\tu8 version;\n\tu8 flags;\n\tu8 i;\n\n\tswitch (subtype) {\n\tcase MPTCPOPT_MP_CAPABLE:\n\t\t \n\t\tif (!(TCP_SKB_CB(skb)->tcp_flags & TCPHDR_SYN)) {\n\t\t\tif (skb->len > tcp_hdr(skb)->doff << 2)\n\t\t\t\texpected_opsize = TCPOLEN_MPTCP_MPC_ACK_DATA;\n\t\t\telse\n\t\t\t\texpected_opsize = TCPOLEN_MPTCP_MPC_ACK;\n\t\t\tsubopt = OPTION_MPTCP_MPC_ACK;\n\t\t} else {\n\t\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_ACK) {\n\t\t\t\texpected_opsize = TCPOLEN_MPTCP_MPC_SYNACK;\n\t\t\t\tsubopt = OPTION_MPTCP_MPC_SYNACK;\n\t\t\t} else {\n\t\t\t\texpected_opsize = TCPOLEN_MPTCP_MPC_SYN;\n\t\t\t\tsubopt = OPTION_MPTCP_MPC_SYN;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (opsize != expected_opsize &&\n\t\t    (expected_opsize != TCPOLEN_MPTCP_MPC_ACK_DATA ||\n\t\t     opsize != TCPOLEN_MPTCP_MPC_ACK_DATA_CSUM))\n\t\t\tbreak;\n\n\t\t \n\t\tversion = *ptr++ & MPTCP_VERSION_MASK;\n\t\tif (opsize != TCPOLEN_MPTCP_MPC_SYN) {\n\t\t\tif (version != MPTCP_SUPPORTED_VERSION)\n\t\t\t\tbreak;\n\t\t} else if (version < MPTCP_SUPPORTED_VERSION) {\n\t\t\tbreak;\n\t\t}\n\n\t\tflags = *ptr++;\n\t\tif (!mptcp_cap_flag_sha256(flags) ||\n\t\t    (flags & MPTCP_CAP_EXTENSIBILITY))\n\t\t\tbreak;\n\n\t\t \n\t\tif (flags & MPTCP_CAP_CHECKSUM_REQD)\n\t\t\tmp_opt->suboptions |= OPTION_MPTCP_CSUMREQD;\n\n\t\tmp_opt->deny_join_id0 = !!(flags & MPTCP_CAP_DENY_JOIN_ID0);\n\n\t\tmp_opt->suboptions |= subopt;\n\t\tif (opsize >= TCPOLEN_MPTCP_MPC_SYNACK) {\n\t\t\tmp_opt->sndr_key = get_unaligned_be64(ptr);\n\t\t\tptr += 8;\n\t\t}\n\t\tif (opsize >= TCPOLEN_MPTCP_MPC_ACK) {\n\t\t\tmp_opt->rcvr_key = get_unaligned_be64(ptr);\n\t\t\tptr += 8;\n\t\t}\n\t\tif (opsize >= TCPOLEN_MPTCP_MPC_ACK_DATA) {\n\t\t\t \n\t\t\tmp_opt->suboptions |= OPTION_MPTCP_DSS;\n\t\t\tmp_opt->use_map = 1;\n\t\t\tmp_opt->mpc_map = 1;\n\t\t\tmp_opt->use_ack = 0;\n\t\t\tmp_opt->data_len = get_unaligned_be16(ptr);\n\t\t\tptr += 2;\n\t\t}\n\t\tif (opsize == TCPOLEN_MPTCP_MPC_ACK_DATA_CSUM) {\n\t\t\tmp_opt->csum = get_unaligned((__force __sum16 *)ptr);\n\t\t\tmp_opt->suboptions |= OPTION_MPTCP_CSUMREQD;\n\t\t\tptr += 2;\n\t\t}\n\t\tpr_debug(\"MP_CAPABLE version=%x, flags=%x, optlen=%d sndr=%llu, rcvr=%llu len=%d csum=%u\",\n\t\t\t version, flags, opsize, mp_opt->sndr_key,\n\t\t\t mp_opt->rcvr_key, mp_opt->data_len, mp_opt->csum);\n\t\tbreak;\n\n\tcase MPTCPOPT_MP_JOIN:\n\t\tif (opsize == TCPOLEN_MPTCP_MPJ_SYN) {\n\t\t\tmp_opt->suboptions |= OPTION_MPTCP_MPJ_SYN;\n\t\t\tmp_opt->backup = *ptr++ & MPTCPOPT_BACKUP;\n\t\t\tmp_opt->join_id = *ptr++;\n\t\t\tmp_opt->token = get_unaligned_be32(ptr);\n\t\t\tptr += 4;\n\t\t\tmp_opt->nonce = get_unaligned_be32(ptr);\n\t\t\tptr += 4;\n\t\t\tpr_debug(\"MP_JOIN bkup=%u, id=%u, token=%u, nonce=%u\",\n\t\t\t\t mp_opt->backup, mp_opt->join_id,\n\t\t\t\t mp_opt->token, mp_opt->nonce);\n\t\t} else if (opsize == TCPOLEN_MPTCP_MPJ_SYNACK) {\n\t\t\tmp_opt->suboptions |= OPTION_MPTCP_MPJ_SYNACK;\n\t\t\tmp_opt->backup = *ptr++ & MPTCPOPT_BACKUP;\n\t\t\tmp_opt->join_id = *ptr++;\n\t\t\tmp_opt->thmac = get_unaligned_be64(ptr);\n\t\t\tptr += 8;\n\t\t\tmp_opt->nonce = get_unaligned_be32(ptr);\n\t\t\tptr += 4;\n\t\t\tpr_debug(\"MP_JOIN bkup=%u, id=%u, thmac=%llu, nonce=%u\",\n\t\t\t\t mp_opt->backup, mp_opt->join_id,\n\t\t\t\t mp_opt->thmac, mp_opt->nonce);\n\t\t} else if (opsize == TCPOLEN_MPTCP_MPJ_ACK) {\n\t\t\tmp_opt->suboptions |= OPTION_MPTCP_MPJ_ACK;\n\t\t\tptr += 2;\n\t\t\tmemcpy(mp_opt->hmac, ptr, MPTCPOPT_HMAC_LEN);\n\t\t\tpr_debug(\"MP_JOIN hmac\");\n\t\t}\n\t\tbreak;\n\n\tcase MPTCPOPT_DSS:\n\t\tpr_debug(\"DSS\");\n\t\tptr++;\n\n\t\t \n\t\tmp_opt->mpc_map = 0;\n\t\tflags = (*ptr++) & MPTCP_DSS_FLAG_MASK;\n\t\tmp_opt->data_fin = (flags & MPTCP_DSS_DATA_FIN) != 0;\n\t\tmp_opt->dsn64 = (flags & MPTCP_DSS_DSN64) != 0;\n\t\tmp_opt->use_map = (flags & MPTCP_DSS_HAS_MAP) != 0;\n\t\tmp_opt->ack64 = (flags & MPTCP_DSS_ACK64) != 0;\n\t\tmp_opt->use_ack = (flags & MPTCP_DSS_HAS_ACK);\n\n\t\tpr_debug(\"data_fin=%d dsn64=%d use_map=%d ack64=%d use_ack=%d\",\n\t\t\t mp_opt->data_fin, mp_opt->dsn64,\n\t\t\t mp_opt->use_map, mp_opt->ack64,\n\t\t\t mp_opt->use_ack);\n\n\t\texpected_opsize = TCPOLEN_MPTCP_DSS_BASE;\n\n\t\tif (mp_opt->use_ack) {\n\t\t\tif (mp_opt->ack64)\n\t\t\t\texpected_opsize += TCPOLEN_MPTCP_DSS_ACK64;\n\t\t\telse\n\t\t\t\texpected_opsize += TCPOLEN_MPTCP_DSS_ACK32;\n\t\t}\n\n\t\tif (mp_opt->use_map) {\n\t\t\tif (mp_opt->dsn64)\n\t\t\t\texpected_opsize += TCPOLEN_MPTCP_DSS_MAP64;\n\t\t\telse\n\t\t\t\texpected_opsize += TCPOLEN_MPTCP_DSS_MAP32;\n\t\t}\n\n\t\t \n\t\tif (opsize != expected_opsize &&\n\t\t    opsize != expected_opsize + TCPOLEN_MPTCP_DSS_CHECKSUM)\n\t\t\tbreak;\n\n\t\tmp_opt->suboptions |= OPTION_MPTCP_DSS;\n\t\tif (mp_opt->use_ack) {\n\t\t\tif (mp_opt->ack64) {\n\t\t\t\tmp_opt->data_ack = get_unaligned_be64(ptr);\n\t\t\t\tptr += 8;\n\t\t\t} else {\n\t\t\t\tmp_opt->data_ack = get_unaligned_be32(ptr);\n\t\t\t\tptr += 4;\n\t\t\t}\n\n\t\t\tpr_debug(\"data_ack=%llu\", mp_opt->data_ack);\n\t\t}\n\n\t\tif (mp_opt->use_map) {\n\t\t\tif (mp_opt->dsn64) {\n\t\t\t\tmp_opt->data_seq = get_unaligned_be64(ptr);\n\t\t\t\tptr += 8;\n\t\t\t} else {\n\t\t\t\tmp_opt->data_seq = get_unaligned_be32(ptr);\n\t\t\t\tptr += 4;\n\t\t\t}\n\n\t\t\tmp_opt->subflow_seq = get_unaligned_be32(ptr);\n\t\t\tptr += 4;\n\n\t\t\tmp_opt->data_len = get_unaligned_be16(ptr);\n\t\t\tptr += 2;\n\n\t\t\tif (opsize == expected_opsize + TCPOLEN_MPTCP_DSS_CHECKSUM) {\n\t\t\t\tmp_opt->suboptions |= OPTION_MPTCP_CSUMREQD;\n\t\t\t\tmp_opt->csum = get_unaligned((__force __sum16 *)ptr);\n\t\t\t\tptr += 2;\n\t\t\t}\n\n\t\t\tpr_debug(\"data_seq=%llu subflow_seq=%u data_len=%u csum=%d:%u\",\n\t\t\t\t mp_opt->data_seq, mp_opt->subflow_seq,\n\t\t\t\t mp_opt->data_len, !!(mp_opt->suboptions & OPTION_MPTCP_CSUMREQD),\n\t\t\t\t mp_opt->csum);\n\t\t}\n\n\t\tbreak;\n\n\tcase MPTCPOPT_ADD_ADDR:\n\t\tmp_opt->echo = (*ptr++) & MPTCP_ADDR_ECHO;\n\t\tif (!mp_opt->echo) {\n\t\t\tif (opsize == TCPOLEN_MPTCP_ADD_ADDR ||\n\t\t\t    opsize == TCPOLEN_MPTCP_ADD_ADDR_PORT)\n\t\t\t\tmp_opt->addr.family = AF_INET;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t\t\telse if (opsize == TCPOLEN_MPTCP_ADD_ADDR6 ||\n\t\t\t\t opsize == TCPOLEN_MPTCP_ADD_ADDR6_PORT)\n\t\t\t\tmp_opt->addr.family = AF_INET6;\n#endif\n\t\t\telse\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (opsize == TCPOLEN_MPTCP_ADD_ADDR_BASE ||\n\t\t\t    opsize == TCPOLEN_MPTCP_ADD_ADDR_BASE_PORT)\n\t\t\t\tmp_opt->addr.family = AF_INET;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t\t\telse if (opsize == TCPOLEN_MPTCP_ADD_ADDR6_BASE ||\n\t\t\t\t opsize == TCPOLEN_MPTCP_ADD_ADDR6_BASE_PORT)\n\t\t\t\tmp_opt->addr.family = AF_INET6;\n#endif\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tmp_opt->suboptions |= OPTION_MPTCP_ADD_ADDR;\n\t\tmp_opt->addr.id = *ptr++;\n\t\tmp_opt->addr.port = 0;\n\t\tmp_opt->ahmac = 0;\n\t\tif (mp_opt->addr.family == AF_INET) {\n\t\t\tmemcpy((u8 *)&mp_opt->addr.addr.s_addr, (u8 *)ptr, 4);\n\t\t\tptr += 4;\n\t\t\tif (opsize == TCPOLEN_MPTCP_ADD_ADDR_PORT ||\n\t\t\t    opsize == TCPOLEN_MPTCP_ADD_ADDR_BASE_PORT) {\n\t\t\t\tmp_opt->addr.port = htons(get_unaligned_be16(ptr));\n\t\t\t\tptr += 2;\n\t\t\t}\n\t\t}\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t\telse {\n\t\t\tmemcpy(mp_opt->addr.addr6.s6_addr, (u8 *)ptr, 16);\n\t\t\tptr += 16;\n\t\t\tif (opsize == TCPOLEN_MPTCP_ADD_ADDR6_PORT ||\n\t\t\t    opsize == TCPOLEN_MPTCP_ADD_ADDR6_BASE_PORT) {\n\t\t\t\tmp_opt->addr.port = htons(get_unaligned_be16(ptr));\n\t\t\t\tptr += 2;\n\t\t\t}\n\t\t}\n#endif\n\t\tif (!mp_opt->echo) {\n\t\t\tmp_opt->ahmac = get_unaligned_be64(ptr);\n\t\t\tptr += 8;\n\t\t}\n\t\tpr_debug(\"ADD_ADDR%s: id=%d, ahmac=%llu, echo=%d, port=%d\",\n\t\t\t (mp_opt->addr.family == AF_INET6) ? \"6\" : \"\",\n\t\t\t mp_opt->addr.id, mp_opt->ahmac, mp_opt->echo, ntohs(mp_opt->addr.port));\n\t\tbreak;\n\n\tcase MPTCPOPT_RM_ADDR:\n\t\tif (opsize < TCPOLEN_MPTCP_RM_ADDR_BASE + 1 ||\n\t\t    opsize > TCPOLEN_MPTCP_RM_ADDR_BASE + MPTCP_RM_IDS_MAX)\n\t\t\tbreak;\n\n\t\tptr++;\n\n\t\tmp_opt->suboptions |= OPTION_MPTCP_RM_ADDR;\n\t\tmp_opt->rm_list.nr = opsize - TCPOLEN_MPTCP_RM_ADDR_BASE;\n\t\tfor (i = 0; i < mp_opt->rm_list.nr; i++)\n\t\t\tmp_opt->rm_list.ids[i] = *ptr++;\n\t\tpr_debug(\"RM_ADDR: rm_list_nr=%d\", mp_opt->rm_list.nr);\n\t\tbreak;\n\n\tcase MPTCPOPT_MP_PRIO:\n\t\tif (opsize != TCPOLEN_MPTCP_PRIO)\n\t\t\tbreak;\n\n\t\tmp_opt->suboptions |= OPTION_MPTCP_PRIO;\n\t\tmp_opt->backup = *ptr++ & MPTCP_PRIO_BKUP;\n\t\tpr_debug(\"MP_PRIO: prio=%d\", mp_opt->backup);\n\t\tbreak;\n\n\tcase MPTCPOPT_MP_FASTCLOSE:\n\t\tif (opsize != TCPOLEN_MPTCP_FASTCLOSE)\n\t\t\tbreak;\n\n\t\tptr += 2;\n\t\tmp_opt->rcvr_key = get_unaligned_be64(ptr);\n\t\tptr += 8;\n\t\tmp_opt->suboptions |= OPTION_MPTCP_FASTCLOSE;\n\t\tpr_debug(\"MP_FASTCLOSE: recv_key=%llu\", mp_opt->rcvr_key);\n\t\tbreak;\n\n\tcase MPTCPOPT_RST:\n\t\tif (opsize != TCPOLEN_MPTCP_RST)\n\t\t\tbreak;\n\n\t\tif (!(TCP_SKB_CB(skb)->tcp_flags & TCPHDR_RST))\n\t\t\tbreak;\n\n\t\tmp_opt->suboptions |= OPTION_MPTCP_RST;\n\t\tflags = *ptr++;\n\t\tmp_opt->reset_transient = flags & MPTCP_RST_TRANSIENT;\n\t\tmp_opt->reset_reason = *ptr;\n\t\tpr_debug(\"MP_RST: transient=%u reason=%u\",\n\t\t\t mp_opt->reset_transient, mp_opt->reset_reason);\n\t\tbreak;\n\n\tcase MPTCPOPT_MP_FAIL:\n\t\tif (opsize != TCPOLEN_MPTCP_FAIL)\n\t\t\tbreak;\n\n\t\tptr += 2;\n\t\tmp_opt->suboptions |= OPTION_MPTCP_FAIL;\n\t\tmp_opt->fail_seq = get_unaligned_be64(ptr);\n\t\tpr_debug(\"MP_FAIL: data_seq=%llu\", mp_opt->fail_seq);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid mptcp_get_options(const struct sk_buff *skb,\n\t\t       struct mptcp_options_received *mp_opt)\n{\n\tconst struct tcphdr *th = tcp_hdr(skb);\n\tconst unsigned char *ptr;\n\tint length;\n\n\t \n\tmp_opt->suboptions = 0;\n\n\tlength = (th->doff * 4) - sizeof(struct tcphdr);\n\tptr = (const unsigned char *)(th + 1);\n\n\twhile (length > 0) {\n\t\tint opcode = *ptr++;\n\t\tint opsize;\n\n\t\tswitch (opcode) {\n\t\tcase TCPOPT_EOL:\n\t\t\treturn;\n\t\tcase TCPOPT_NOP:\t \n\t\t\tlength--;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (length < 2)\n\t\t\t\treturn;\n\t\t\topsize = *ptr++;\n\t\t\tif (opsize < 2)  \n\t\t\t\treturn;\n\t\t\tif (opsize > length)\n\t\t\t\treturn;\t \n\t\t\tif (opcode == TCPOPT_MPTCP)\n\t\t\t\tmptcp_parse_option(skb, ptr, opsize, mp_opt);\n\t\t\tptr += opsize - 2;\n\t\t\tlength -= opsize;\n\t\t}\n\t}\n}\n\nbool mptcp_syn_options(struct sock *sk, const struct sk_buff *skb,\n\t\t       unsigned int *size, struct mptcp_out_options *opts)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\n\t \n\tsubflow->snd_isn = TCP_SKB_CB(skb)->end_seq;\n\tif (subflow->request_mptcp) {\n\t\topts->suboptions = OPTION_MPTCP_MPC_SYN;\n\t\topts->csum_reqd = mptcp_is_checksum_enabled(sock_net(sk));\n\t\topts->allow_join_id0 = mptcp_allow_join_id0(sock_net(sk));\n\t\t*size = TCPOLEN_MPTCP_MPC_SYN;\n\t\treturn true;\n\t} else if (subflow->request_join) {\n\t\tpr_debug(\"remote_token=%u, nonce=%u\", subflow->remote_token,\n\t\t\t subflow->local_nonce);\n\t\topts->suboptions = OPTION_MPTCP_MPJ_SYN;\n\t\topts->join_id = subflow->local_id;\n\t\topts->token = subflow->remote_token;\n\t\topts->nonce = subflow->local_nonce;\n\t\topts->backup = subflow->request_bkup;\n\t\t*size = TCPOLEN_MPTCP_MPJ_SYN;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void clear_3rdack_retransmission(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\n\tsk_stop_timer(sk, &icsk->icsk_delack_timer);\n\ticsk->icsk_ack.timeout = 0;\n\ticsk->icsk_ack.ato = 0;\n\ticsk->icsk_ack.pending &= ~(ICSK_ACK_SCHED | ICSK_ACK_TIMER);\n}\n\nstatic bool mptcp_established_options_mp(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t bool snd_data_fin_enable,\n\t\t\t\t\t unsigned int *size,\n\t\t\t\t\t struct mptcp_out_options *opts)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\tstruct mptcp_ext *mpext;\n\tunsigned int data_len;\n\tu8 len;\n\n\t \n\tif (!skb)\n\t\treturn false;\n\n\t \n\tif (subflow->fully_established || snd_data_fin_enable ||\n\t    subflow->snd_isn != TCP_SKB_CB(skb)->seq ||\n\t    sk->sk_state != TCP_ESTABLISHED)\n\t\treturn false;\n\n\tif (subflow->mp_capable) {\n\t\tmpext = mptcp_get_ext(skb);\n\t\tdata_len = mpext ? mpext->data_len : 0;\n\n\t\t \n\t\topts->data_len = data_len;\n\t\topts->suboptions = OPTION_MPTCP_MPC_ACK;\n\t\topts->sndr_key = subflow->local_key;\n\t\topts->rcvr_key = subflow->remote_key;\n\t\topts->csum_reqd = READ_ONCE(msk->csum_enabled);\n\t\topts->allow_join_id0 = mptcp_allow_join_id0(sock_net(sk));\n\n\t\t \n\t\tif (data_len > 0) {\n\t\t\tlen = TCPOLEN_MPTCP_MPC_ACK_DATA;\n\t\t\tif (opts->csum_reqd) {\n\t\t\t\t \n\t\t\t\topts->data_seq = mpext->data_seq;\n\t\t\t\topts->subflow_seq = mpext->subflow_seq;\n\t\t\t\topts->csum = mpext->csum;\n\t\t\t\tlen += TCPOLEN_MPTCP_DSS_CHECKSUM;\n\t\t\t}\n\t\t\t*size = ALIGN(len, 4);\n\t\t} else {\n\t\t\t*size = TCPOLEN_MPTCP_MPC_ACK;\n\t\t}\n\n\t\tpr_debug(\"subflow=%p, local_key=%llu, remote_key=%llu map_len=%d\",\n\t\t\t subflow, subflow->local_key, subflow->remote_key,\n\t\t\t data_len);\n\n\t\treturn true;\n\t} else if (subflow->mp_join) {\n\t\topts->suboptions = OPTION_MPTCP_MPJ_ACK;\n\t\tmemcpy(opts->hmac, subflow->hmac, MPTCPOPT_HMAC_LEN);\n\t\t*size = TCPOLEN_MPTCP_MPJ_ACK;\n\t\tpr_debug(\"subflow=%p\", subflow);\n\n\t\t \n\t\tif (sock_owned_by_user(sk))\n\t\t\tset_bit(MPTCP_DELEGATE_ACK, &subflow->delegated_status);\n\t\telse\n\t\t\tmptcp_subflow_delegate(subflow, MPTCP_DELEGATE_ACK);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic void mptcp_write_data_fin(struct mptcp_subflow_context *subflow,\n\t\t\t\t struct sk_buff *skb, struct mptcp_ext *ext)\n{\n\t \n\tu64 data_fin_tx_seq = READ_ONCE(mptcp_sk(subflow->conn)->write_seq) - 1;\n\n\tif (!ext->use_map || !skb->len) {\n\t\t \n\t\text->data_fin = 1;\n\t\text->use_map = 1;\n\t\text->dsn64 = 1;\n\t\text->data_seq = data_fin_tx_seq;\n\t\text->subflow_seq = 0;\n\t\text->data_len = 1;\n\t} else if (ext->data_seq + ext->data_len == data_fin_tx_seq) {\n\t\t \n\t\text->data_fin = 1;\n\t\text->data_len++;\n\t}\n}\n\nstatic bool mptcp_established_options_dss(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  bool snd_data_fin_enable,\n\t\t\t\t\t  unsigned int *size,\n\t\t\t\t\t  struct mptcp_out_options *opts)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\tunsigned int dss_size = 0;\n\tstruct mptcp_ext *mpext;\n\tunsigned int ack_size;\n\tbool ret = false;\n\tu64 ack_seq;\n\n\topts->csum_reqd = READ_ONCE(msk->csum_enabled);\n\tmpext = skb ? mptcp_get_ext(skb) : NULL;\n\n\tif (!skb || (mpext && mpext->use_map) || snd_data_fin_enable) {\n\t\tunsigned int map_size = TCPOLEN_MPTCP_DSS_BASE + TCPOLEN_MPTCP_DSS_MAP64;\n\n\t\tif (mpext) {\n\t\t\tif (opts->csum_reqd)\n\t\t\t\tmap_size += TCPOLEN_MPTCP_DSS_CHECKSUM;\n\n\t\t\topts->ext_copy = *mpext;\n\t\t}\n\n\t\tdss_size = map_size;\n\t\tif (skb && snd_data_fin_enable)\n\t\t\tmptcp_write_data_fin(subflow, skb, &opts->ext_copy);\n\t\topts->suboptions = OPTION_MPTCP_DSS;\n\t\tret = true;\n\t}\n\n\t \n\topts->ext_copy.use_ack = 0;\n\tif (!READ_ONCE(msk->can_ack)) {\n\t\t*size = ALIGN(dss_size, 4);\n\t\treturn ret;\n\t}\n\n\tack_seq = READ_ONCE(msk->ack_seq);\n\tif (READ_ONCE(msk->use_64bit_ack)) {\n\t\tack_size = TCPOLEN_MPTCP_DSS_ACK64;\n\t\topts->ext_copy.data_ack = ack_seq;\n\t\topts->ext_copy.ack64 = 1;\n\t} else {\n\t\tack_size = TCPOLEN_MPTCP_DSS_ACK32;\n\t\topts->ext_copy.data_ack32 = (uint32_t)ack_seq;\n\t\topts->ext_copy.ack64 = 0;\n\t}\n\topts->ext_copy.use_ack = 1;\n\topts->suboptions = OPTION_MPTCP_DSS;\n\tWRITE_ONCE(msk->old_wspace, __mptcp_space((struct sock *)msk));\n\n\t \n\tif (dss_size == 0)\n\t\tack_size += TCPOLEN_MPTCP_DSS_BASE;\n\n\tdss_size += ack_size;\n\n\t*size = ALIGN(dss_size, 4);\n\treturn true;\n}\n\nstatic u64 add_addr_generate_hmac(u64 key1, u64 key2,\n\t\t\t\t  struct mptcp_addr_info *addr)\n{\n\tu16 port = ntohs(addr->port);\n\tu8 hmac[SHA256_DIGEST_SIZE];\n\tu8 msg[19];\n\tint i = 0;\n\n\tmsg[i++] = addr->id;\n\tif (addr->family == AF_INET) {\n\t\tmemcpy(&msg[i], &addr->addr.s_addr, 4);\n\t\ti += 4;\n\t}\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\telse if (addr->family == AF_INET6) {\n\t\tmemcpy(&msg[i], &addr->addr6.s6_addr, 16);\n\t\ti += 16;\n\t}\n#endif\n\tmsg[i++] = port >> 8;\n\tmsg[i++] = port & 0xFF;\n\n\tmptcp_crypto_hmac_sha(key1, key2, msg, i, hmac);\n\n\treturn get_unaligned_be64(&hmac[SHA256_DIGEST_SIZE - sizeof(u64)]);\n}\n\nstatic bool mptcp_established_options_add_addr(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t       unsigned int *size,\n\t\t\t\t\t       unsigned int remaining,\n\t\t\t\t\t       struct mptcp_out_options *opts)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\tbool drop_other_suboptions = false;\n\tunsigned int opt_size = *size;\n\tbool echo;\n\tint len;\n\n\t \n\tif (!mptcp_pm_should_add_signal(msk) ||\n\t    (opts->suboptions & (OPTION_MPTCP_MPJ_ACK | OPTION_MPTCP_MPC_ACK)) ||\n\t    !mptcp_pm_add_addr_signal(msk, skb, opt_size, remaining, &opts->addr,\n\t\t    &echo, &drop_other_suboptions))\n\t\treturn false;\n\n\tif (drop_other_suboptions)\n\t\tremaining += opt_size;\n\tlen = mptcp_add_addr_len(opts->addr.family, echo, !!opts->addr.port);\n\tif (remaining < len)\n\t\treturn false;\n\n\t*size = len;\n\tif (drop_other_suboptions) {\n\t\tpr_debug(\"drop other suboptions\");\n\t\topts->suboptions = 0;\n\n\t\t \n\t\topts->ahmac = 0;\n\t\t*size -= opt_size;\n\t}\n\topts->suboptions |= OPTION_MPTCP_ADD_ADDR;\n\tif (!echo) {\n\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_ADDADDRTX);\n\t\topts->ahmac = add_addr_generate_hmac(msk->local_key,\n\t\t\t\t\t\t     msk->remote_key,\n\t\t\t\t\t\t     &opts->addr);\n\t} else {\n\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_ECHOADDTX);\n\t}\n\tpr_debug(\"addr_id=%d, ahmac=%llu, echo=%d, port=%d\",\n\t\t opts->addr.id, opts->ahmac, echo, ntohs(opts->addr.port));\n\n\treturn true;\n}\n\nstatic bool mptcp_established_options_rm_addr(struct sock *sk,\n\t\t\t\t\t      unsigned int *size,\n\t\t\t\t\t      unsigned int remaining,\n\t\t\t\t\t      struct mptcp_out_options *opts)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\tstruct mptcp_rm_list rm_list;\n\tint i, len;\n\n\tif (!mptcp_pm_should_rm_signal(msk) ||\n\t    !(mptcp_pm_rm_addr_signal(msk, remaining, &rm_list)))\n\t\treturn false;\n\n\tlen = mptcp_rm_addr_len(&rm_list);\n\tif (len < 0)\n\t\treturn false;\n\tif (remaining < len)\n\t\treturn false;\n\n\t*size = len;\n\topts->suboptions |= OPTION_MPTCP_RM_ADDR;\n\topts->rm_list = rm_list;\n\n\tfor (i = 0; i < opts->rm_list.nr; i++)\n\t\tpr_debug(\"rm_list_ids[%d]=%d\", i, opts->rm_list.ids[i]);\n\tMPTCP_ADD_STATS(sock_net(sk), MPTCP_MIB_RMADDRTX, opts->rm_list.nr);\n\treturn true;\n}\n\nstatic bool mptcp_established_options_mp_prio(struct sock *sk,\n\t\t\t\t\t      unsigned int *size,\n\t\t\t\t\t      unsigned int remaining,\n\t\t\t\t\t      struct mptcp_out_options *opts)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\n\t \n\tif (!subflow->send_mp_prio || (opts->suboptions & OPTIONS_MPTCP_MPC))\n\t\treturn false;\n\n\t \n\tif (remaining < TCPOLEN_MPTCP_PRIO_ALIGN)\n\t\treturn false;\n\n\t*size = TCPOLEN_MPTCP_PRIO_ALIGN;\n\topts->suboptions |= OPTION_MPTCP_PRIO;\n\topts->backup = subflow->request_bkup;\n\n\tpr_debug(\"prio=%d\", opts->backup);\n\n\treturn true;\n}\n\nstatic noinline bool mptcp_established_options_rst(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t\t   unsigned int *size,\n\t\t\t\t\t\t   unsigned int remaining,\n\t\t\t\t\t\t   struct mptcp_out_options *opts)\n{\n\tconst struct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\n\tif (remaining < TCPOLEN_MPTCP_RST)\n\t\treturn false;\n\n\t*size = TCPOLEN_MPTCP_RST;\n\topts->suboptions |= OPTION_MPTCP_RST;\n\topts->reset_transient = subflow->reset_transient;\n\topts->reset_reason = subflow->reset_reason;\n\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPRSTTX);\n\n\treturn true;\n}\n\nstatic bool mptcp_established_options_fastclose(struct sock *sk,\n\t\t\t\t\t\tunsigned int *size,\n\t\t\t\t\t\tunsigned int remaining,\n\t\t\t\t\t\tstruct mptcp_out_options *opts)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\n\tif (likely(!subflow->send_fastclose))\n\t\treturn false;\n\n\tif (remaining < TCPOLEN_MPTCP_FASTCLOSE)\n\t\treturn false;\n\n\t*size = TCPOLEN_MPTCP_FASTCLOSE;\n\topts->suboptions |= OPTION_MPTCP_FASTCLOSE;\n\topts->rcvr_key = msk->remote_key;\n\n\tpr_debug(\"FASTCLOSE key=%llu\", opts->rcvr_key);\n\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPFASTCLOSETX);\n\treturn true;\n}\n\nstatic bool mptcp_established_options_mp_fail(struct sock *sk,\n\t\t\t\t\t      unsigned int *size,\n\t\t\t\t\t      unsigned int remaining,\n\t\t\t\t\t      struct mptcp_out_options *opts)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\n\tif (likely(!subflow->send_mp_fail))\n\t\treturn false;\n\n\tif (remaining < TCPOLEN_MPTCP_FAIL)\n\t\treturn false;\n\n\t*size = TCPOLEN_MPTCP_FAIL;\n\topts->suboptions |= OPTION_MPTCP_FAIL;\n\topts->fail_seq = subflow->map_seq;\n\n\tpr_debug(\"MP_FAIL fail_seq=%llu\", opts->fail_seq);\n\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPFAILTX);\n\n\treturn true;\n}\n\nbool mptcp_established_options(struct sock *sk, struct sk_buff *skb,\n\t\t\t       unsigned int *size, unsigned int remaining,\n\t\t\t       struct mptcp_out_options *opts)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\tunsigned int opt_size = 0;\n\tbool snd_data_fin;\n\tbool ret = false;\n\n\topts->suboptions = 0;\n\n\tif (unlikely(__mptcp_check_fallback(msk) && !mptcp_check_infinite_map(skb)))\n\t\treturn false;\n\n\tif (unlikely(skb && TCP_SKB_CB(skb)->tcp_flags & TCPHDR_RST)) {\n\t\tif (mptcp_established_options_fastclose(sk, &opt_size, remaining, opts) ||\n\t\t    mptcp_established_options_mp_fail(sk, &opt_size, remaining, opts)) {\n\t\t\t*size += opt_size;\n\t\t\tremaining -= opt_size;\n\t\t}\n\t\t \n\t\tif (mptcp_established_options_rst(sk, skb, &opt_size, remaining, opts)) {\n\t\t\t*size += opt_size;\n\t\t\tremaining -= opt_size;\n\t\t}\n\t\treturn true;\n\t}\n\n\tsnd_data_fin = mptcp_data_fin_enabled(msk);\n\tif (mptcp_established_options_mp(sk, skb, snd_data_fin, &opt_size, opts))\n\t\tret = true;\n\telse if (mptcp_established_options_dss(sk, skb, snd_data_fin, &opt_size, opts)) {\n\t\tunsigned int mp_fail_size;\n\n\t\tret = true;\n\t\tif (mptcp_established_options_mp_fail(sk, &mp_fail_size,\n\t\t\t\t\t\t      remaining - opt_size, opts)) {\n\t\t\t*size += opt_size + mp_fail_size;\n\t\t\tremaining -= opt_size - mp_fail_size;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t \n\tif (WARN_ON_ONCE(opt_size > remaining))\n\t\treturn false;\n\n\t*size += opt_size;\n\tremaining -= opt_size;\n\tif (mptcp_established_options_add_addr(sk, skb, &opt_size, remaining, opts)) {\n\t\t*size += opt_size;\n\t\tremaining -= opt_size;\n\t\tret = true;\n\t} else if (mptcp_established_options_rm_addr(sk, &opt_size, remaining, opts)) {\n\t\t*size += opt_size;\n\t\tremaining -= opt_size;\n\t\tret = true;\n\t}\n\n\tif (mptcp_established_options_mp_prio(sk, &opt_size, remaining, opts)) {\n\t\t*size += opt_size;\n\t\tremaining -= opt_size;\n\t\tret = true;\n\t}\n\n\treturn ret;\n}\n\nbool mptcp_synack_options(const struct request_sock *req, unsigned int *size,\n\t\t\t  struct mptcp_out_options *opts)\n{\n\tstruct mptcp_subflow_request_sock *subflow_req = mptcp_subflow_rsk(req);\n\n\tif (subflow_req->mp_capable) {\n\t\topts->suboptions = OPTION_MPTCP_MPC_SYNACK;\n\t\topts->sndr_key = subflow_req->local_key;\n\t\topts->csum_reqd = subflow_req->csum_reqd;\n\t\topts->allow_join_id0 = subflow_req->allow_join_id0;\n\t\t*size = TCPOLEN_MPTCP_MPC_SYNACK;\n\t\tpr_debug(\"subflow_req=%p, local_key=%llu\",\n\t\t\t subflow_req, subflow_req->local_key);\n\t\treturn true;\n\t} else if (subflow_req->mp_join) {\n\t\topts->suboptions = OPTION_MPTCP_MPJ_SYNACK;\n\t\topts->backup = subflow_req->backup;\n\t\topts->join_id = subflow_req->local_id;\n\t\topts->thmac = subflow_req->thmac;\n\t\topts->nonce = subflow_req->local_nonce;\n\t\tpr_debug(\"req=%p, bkup=%u, id=%u, thmac=%llu, nonce=%u\",\n\t\t\t subflow_req, opts->backup, opts->join_id,\n\t\t\t opts->thmac, opts->nonce);\n\t\t*size = TCPOLEN_MPTCP_MPJ_SYNACK;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool check_fully_established(struct mptcp_sock *msk, struct sock *ssk,\n\t\t\t\t    struct mptcp_subflow_context *subflow,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct mptcp_options_received *mp_opt)\n{\n\t \n\tif (likely(subflow->fully_established)) {\n\t\t \n\t\tif (TCP_SKB_CB(skb)->seq == subflow->ssn_offset + 1 &&\n\t\t    TCP_SKB_CB(skb)->end_seq == TCP_SKB_CB(skb)->seq &&\n\t\t    subflow->mp_join && (mp_opt->suboptions & OPTIONS_MPTCP_MPJ) &&\n\t\t    !subflow->request_join)\n\t\t\ttcp_send_ack(ssk);\n\t\tgoto check_notify;\n\t}\n\n\t \n\tif (TCP_SKB_CB(skb)->seq != subflow->ssn_offset + 1) {\n\t\tif (subflow->mp_join)\n\t\t\tgoto reset;\n\t\tif (subflow->is_mptfo && mp_opt->suboptions & OPTION_MPTCP_MPC_ACK)\n\t\t\tgoto set_fully_established;\n\t\treturn subflow->mp_capable;\n\t}\n\n\tif (subflow->remote_key_valid &&\n\t    (((mp_opt->suboptions & OPTION_MPTCP_DSS) && mp_opt->use_ack) ||\n\t     ((mp_opt->suboptions & OPTION_MPTCP_ADD_ADDR) && !mp_opt->echo))) {\n\t\t \n\t\tsubflow->fully_established = 1;\n\t\tWRITE_ONCE(msk->fully_established, true);\n\t\tgoto check_notify;\n\t}\n\n\t \n\tif (!(mp_opt->suboptions & OPTIONS_MPTCP_MPC)) {\n\t\tif (subflow->mp_join)\n\t\t\tgoto reset;\n\t\tsubflow->mp_capable = 0;\n\t\tpr_fallback(msk);\n\t\tmptcp_do_fallback(ssk);\n\t\treturn false;\n\t}\n\n\tif (mp_opt->deny_join_id0)\n\t\tWRITE_ONCE(msk->pm.remote_deny_join_id0, true);\n\nset_fully_established:\n\tif (unlikely(!READ_ONCE(msk->pm.server_side)))\n\t\tpr_warn_once(\"bogus mpc option on established client sk\");\n\tmptcp_subflow_fully_established(subflow, mp_opt);\n\ncheck_notify:\n\t \n\tif (likely(subflow->pm_notified) || list_empty(&subflow->node))\n\t\treturn true;\n\n\tsubflow->pm_notified = 1;\n\tif (subflow->mp_join) {\n\t\tclear_3rdack_retransmission(ssk);\n\t\tmptcp_pm_subflow_established(msk);\n\t} else {\n\t\tmptcp_pm_fully_established(msk, ssk);\n\t}\n\treturn true;\n\nreset:\n\tmptcp_subflow_reset(ssk);\n\treturn false;\n}\n\nu64 __mptcp_expand_seq(u64 old_seq, u64 cur_seq)\n{\n\tu32 old_seq32, cur_seq32;\n\n\told_seq32 = (u32)old_seq;\n\tcur_seq32 = (u32)cur_seq;\n\tcur_seq = (old_seq & GENMASK_ULL(63, 32)) + cur_seq32;\n\tif (unlikely(cur_seq32 < old_seq32 && before(old_seq32, cur_seq32)))\n\t\treturn cur_seq + (1LL << 32);\n\n\t \n\tif (unlikely(cur_seq32 > old_seq32 && after(old_seq32, cur_seq32)))\n\t\treturn cur_seq - (1LL << 32);\n\treturn cur_seq;\n}\n\nstatic void __mptcp_snd_una_update(struct mptcp_sock *msk, u64 new_snd_una)\n{\n\tmsk->bytes_acked += new_snd_una - msk->snd_una;\n\tmsk->snd_una = new_snd_una;\n}\n\nstatic void ack_update_msk(struct mptcp_sock *msk,\n\t\t\t   struct sock *ssk,\n\t\t\t   struct mptcp_options_received *mp_opt)\n{\n\tu64 new_wnd_end, new_snd_una, snd_nxt = READ_ONCE(msk->snd_nxt);\n\tstruct sock *sk = (struct sock *)msk;\n\tu64 old_snd_una;\n\n\tmptcp_data_lock(sk);\n\n\t \n\told_snd_una = msk->snd_una;\n\tnew_snd_una = mptcp_expand_seq(old_snd_una, mp_opt->data_ack, mp_opt->ack64);\n\n\t \n\tif (unlikely(after64(new_snd_una, snd_nxt)))\n\t\tnew_snd_una = old_snd_una;\n\n\tnew_wnd_end = new_snd_una + tcp_sk(ssk)->snd_wnd;\n\n\tif (after64(new_wnd_end, msk->wnd_end))\n\t\tmsk->wnd_end = new_wnd_end;\n\n\t \n\tif (after64(msk->wnd_end, READ_ONCE(msk->snd_nxt)))\n\t\t__mptcp_check_push(sk, ssk);\n\n\tif (after64(new_snd_una, old_snd_una)) {\n\t\t__mptcp_snd_una_update(msk, new_snd_una);\n\t\t__mptcp_data_acked(sk);\n\t}\n\tmptcp_data_unlock(sk);\n\n\ttrace_ack_update_msk(mp_opt->data_ack,\n\t\t\t     old_snd_una, new_snd_una,\n\t\t\t     new_wnd_end, msk->wnd_end);\n}\n\nbool mptcp_update_rcv_data_fin(struct mptcp_sock *msk, u64 data_fin_seq, bool use_64bit)\n{\n\t \n\tif (READ_ONCE(msk->rcv_data_fin))\n\t\treturn false;\n\n\tWRITE_ONCE(msk->rcv_data_fin_seq,\n\t\t   mptcp_expand_seq(READ_ONCE(msk->ack_seq), data_fin_seq, use_64bit));\n\tWRITE_ONCE(msk->rcv_data_fin, 1);\n\n\treturn true;\n}\n\nstatic bool add_addr_hmac_valid(struct mptcp_sock *msk,\n\t\t\t\tstruct mptcp_options_received *mp_opt)\n{\n\tu64 hmac = 0;\n\n\tif (mp_opt->echo)\n\t\treturn true;\n\n\thmac = add_addr_generate_hmac(msk->remote_key,\n\t\t\t\t      msk->local_key,\n\t\t\t\t      &mp_opt->addr);\n\n\tpr_debug(\"msk=%p, ahmac=%llu, mp_opt->ahmac=%llu\\n\",\n\t\t msk, hmac, mp_opt->ahmac);\n\n\treturn hmac == mp_opt->ahmac;\n}\n\n \nbool mptcp_incoming_options(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(sk);\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\tstruct mptcp_options_received mp_opt;\n\tstruct mptcp_ext *mpext;\n\n\tif (__mptcp_check_fallback(msk)) {\n\t\t \n\t\tmptcp_data_lock(subflow->conn);\n\t\tif (sk_stream_memory_free(sk))\n\t\t\t__mptcp_check_push(subflow->conn, sk);\n\n\t\t \n\t\t__mptcp_snd_una_update(msk, READ_ONCE(msk->snd_nxt));\n\n\t\t__mptcp_data_acked(subflow->conn);\n\t\tmptcp_data_unlock(subflow->conn);\n\t\treturn true;\n\t}\n\n\tmptcp_get_options(skb, &mp_opt);\n\n\t \n\tif (!check_fully_established(msk, sk, subflow, skb, &mp_opt))\n\t\treturn sk->sk_state != TCP_CLOSE;\n\n\tif (unlikely(mp_opt.suboptions != OPTION_MPTCP_DSS)) {\n\t\tif ((mp_opt.suboptions & OPTION_MPTCP_FASTCLOSE) &&\n\t\t    msk->local_key == mp_opt.rcvr_key) {\n\t\t\tWRITE_ONCE(msk->rcv_fastclose, true);\n\t\t\tmptcp_schedule_work((struct sock *)msk);\n\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPFASTCLOSERX);\n\t\t}\n\n\t\tif ((mp_opt.suboptions & OPTION_MPTCP_ADD_ADDR) &&\n\t\t    add_addr_hmac_valid(msk, &mp_opt)) {\n\t\t\tif (!mp_opt.echo) {\n\t\t\t\tmptcp_pm_add_addr_received(sk, &mp_opt.addr);\n\t\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_ADDADDR);\n\t\t\t} else {\n\t\t\t\tmptcp_pm_add_addr_echoed(msk, &mp_opt.addr);\n\t\t\t\tmptcp_pm_del_add_timer(msk, &mp_opt.addr, true);\n\t\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_ECHOADD);\n\t\t\t}\n\n\t\t\tif (mp_opt.addr.port)\n\t\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_PORTADD);\n\t\t}\n\n\t\tif (mp_opt.suboptions & OPTION_MPTCP_RM_ADDR)\n\t\t\tmptcp_pm_rm_addr_received(msk, &mp_opt.rm_list);\n\n\t\tif (mp_opt.suboptions & OPTION_MPTCP_PRIO) {\n\t\t\tmptcp_pm_mp_prio_received(sk, mp_opt.backup);\n\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPPRIORX);\n\t\t}\n\n\t\tif (mp_opt.suboptions & OPTION_MPTCP_FAIL) {\n\t\t\tmptcp_pm_mp_fail_received(sk, mp_opt.fail_seq);\n\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPFAILRX);\n\t\t}\n\n\t\tif (mp_opt.suboptions & OPTION_MPTCP_RST) {\n\t\t\tsubflow->reset_seen = 1;\n\t\t\tsubflow->reset_reason = mp_opt.reset_reason;\n\t\t\tsubflow->reset_transient = mp_opt.reset_transient;\n\t\t\tMPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_MPRSTRX);\n\t\t}\n\n\t\tif (!(mp_opt.suboptions & OPTION_MPTCP_DSS))\n\t\t\treturn true;\n\t}\n\n\t \n\tif (mp_opt.use_ack)\n\t\tack_update_msk(msk, sk, &mp_opt);\n\n\t \n\tif (TCP_SKB_CB(skb)->seq == TCP_SKB_CB(skb)->end_seq) {\n\t\tif (mp_opt.data_fin && mp_opt.data_len == 1 &&\n\t\t    mptcp_update_rcv_data_fin(msk, mp_opt.data_seq, mp_opt.dsn64))\n\t\t\tmptcp_schedule_work((struct sock *)msk);\n\n\t\treturn true;\n\t}\n\n\tmpext = skb_ext_add(skb, SKB_EXT_MPTCP);\n\tif (!mpext)\n\t\treturn true;\n\n\tmemset(mpext, 0, sizeof(*mpext));\n\n\tif (likely(mp_opt.use_map)) {\n\t\tif (mp_opt.mpc_map) {\n\t\t\t \n\t\t\tmptcp_crypto_key_sha(subflow->remote_key, NULL,\n\t\t\t\t\t     &mpext->data_seq);\n\t\t\tmpext->data_seq++;\n\t\t\tmpext->subflow_seq = 1;\n\t\t\tmpext->dsn64 = 1;\n\t\t\tmpext->mpc_map = 1;\n\t\t\tmpext->data_fin = 0;\n\t\t} else {\n\t\t\tmpext->data_seq = mp_opt.data_seq;\n\t\t\tmpext->subflow_seq = mp_opt.subflow_seq;\n\t\t\tmpext->dsn64 = mp_opt.dsn64;\n\t\t\tmpext->data_fin = mp_opt.data_fin;\n\t\t}\n\t\tmpext->data_len = mp_opt.data_len;\n\t\tmpext->use_map = 1;\n\t\tmpext->csum_reqd = !!(mp_opt.suboptions & OPTION_MPTCP_CSUMREQD);\n\n\t\tif (mpext->csum_reqd)\n\t\t\tmpext->csum = mp_opt.csum;\n\t}\n\n\treturn true;\n}\n\nstatic void mptcp_set_rwin(struct tcp_sock *tp, struct tcphdr *th)\n{\n\tconst struct sock *ssk = (const struct sock *)tp;\n\tstruct mptcp_subflow_context *subflow;\n\tu64 ack_seq, rcv_wnd_old, rcv_wnd_new;\n\tstruct mptcp_sock *msk;\n\tu32 new_win;\n\tu64 win;\n\n\tsubflow = mptcp_subflow_ctx(ssk);\n\tmsk = mptcp_sk(subflow->conn);\n\n\tack_seq = READ_ONCE(msk->ack_seq);\n\trcv_wnd_new = ack_seq + tp->rcv_wnd;\n\n\trcv_wnd_old = atomic64_read(&msk->rcv_wnd_sent);\n\tif (after64(rcv_wnd_new, rcv_wnd_old)) {\n\t\tu64 rcv_wnd;\n\n\t\tfor (;;) {\n\t\t\trcv_wnd = atomic64_cmpxchg(&msk->rcv_wnd_sent, rcv_wnd_old, rcv_wnd_new);\n\n\t\t\tif (rcv_wnd == rcv_wnd_old)\n\t\t\t\tbreak;\n\n\t\t\trcv_wnd_old = rcv_wnd;\n\t\t\tif (before64(rcv_wnd_new, rcv_wnd_old)) {\n\t\t\t\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_RCVWNDCONFLICTUPDATE);\n\t\t\t\tgoto raise_win;\n\t\t\t}\n\t\t\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_RCVWNDCONFLICT);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (rcv_wnd_new != rcv_wnd_old) {\nraise_win:\n\t\twin = rcv_wnd_old - ack_seq;\n\t\ttp->rcv_wnd = min_t(u64, win, U32_MAX);\n\t\tnew_win = tp->rcv_wnd;\n\n\t\t \n\t\tif (unlikely(th->syn))\n\t\t\tnew_win = min(new_win, 65535U) << tp->rx_opt.rcv_wscale;\n\t\tif (!tp->rx_opt.rcv_wscale &&\n\t\t    READ_ONCE(sock_net(ssk)->ipv4.sysctl_tcp_workaround_signed_windows))\n\t\t\tnew_win = min(new_win, MAX_TCP_WINDOW);\n\t\telse\n\t\t\tnew_win = min(new_win, (65535U << tp->rx_opt.rcv_wscale));\n\n\t\t \n\t\tnew_win >>= tp->rx_opt.rcv_wscale;\n\t\tth->window = htons(new_win);\n\t\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_RCVWNDSHARED);\n\t}\n}\n\n__sum16 __mptcp_make_csum(u64 data_seq, u32 subflow_seq, u16 data_len, __wsum sum)\n{\n\tstruct csum_pseudo_header header;\n\t__wsum csum;\n\n\t \n\theader.data_seq = cpu_to_be64(data_seq);\n\theader.subflow_seq = htonl(subflow_seq);\n\theader.data_len = htons(data_len);\n\theader.csum = 0;\n\n\tcsum = csum_partial(&header, sizeof(header), sum);\n\treturn csum_fold(csum);\n}\n\nstatic __sum16 mptcp_make_csum(const struct mptcp_ext *mpext)\n{\n\treturn __mptcp_make_csum(mpext->data_seq, mpext->subflow_seq, mpext->data_len,\n\t\t\t\t ~csum_unfold(mpext->csum));\n}\n\nstatic void put_len_csum(u16 len, __sum16 csum, void *data)\n{\n\t__sum16 *sumptr = data + 2;\n\t__be16 *ptr = data;\n\n\tput_unaligned_be16(len, ptr);\n\n\tput_unaligned(csum, sumptr);\n}\n\nvoid mptcp_write_options(struct tcphdr *th, __be32 *ptr, struct tcp_sock *tp,\n\t\t\t struct mptcp_out_options *opts)\n{\n\tconst struct sock *ssk = (const struct sock *)tp;\n\tstruct mptcp_subflow_context *subflow;\n\n\t \n\tif (likely(OPTION_MPTCP_DSS & opts->suboptions)) {\n\t\tstruct mptcp_ext *mpext = &opts->ext_copy;\n\t\tu8 len = TCPOLEN_MPTCP_DSS_BASE;\n\t\tu8 flags = 0;\n\n\t\tif (mpext->use_ack) {\n\t\t\tflags = MPTCP_DSS_HAS_ACK;\n\t\t\tif (mpext->ack64) {\n\t\t\t\tlen += TCPOLEN_MPTCP_DSS_ACK64;\n\t\t\t\tflags |= MPTCP_DSS_ACK64;\n\t\t\t} else {\n\t\t\t\tlen += TCPOLEN_MPTCP_DSS_ACK32;\n\t\t\t}\n\t\t}\n\n\t\tif (mpext->use_map) {\n\t\t\tlen += TCPOLEN_MPTCP_DSS_MAP64;\n\n\t\t\t \n\t\t\tflags |= MPTCP_DSS_HAS_MAP | MPTCP_DSS_DSN64;\n\t\t\tif (mpext->data_fin)\n\t\t\t\tflags |= MPTCP_DSS_DATA_FIN;\n\n\t\t\tif (opts->csum_reqd)\n\t\t\t\tlen += TCPOLEN_MPTCP_DSS_CHECKSUM;\n\t\t}\n\n\t\t*ptr++ = mptcp_option(MPTCPOPT_DSS, len, 0, flags);\n\n\t\tif (mpext->use_ack) {\n\t\t\tif (mpext->ack64) {\n\t\t\t\tput_unaligned_be64(mpext->data_ack, ptr);\n\t\t\t\tptr += 2;\n\t\t\t} else {\n\t\t\t\tput_unaligned_be32(mpext->data_ack32, ptr);\n\t\t\t\tptr += 1;\n\t\t\t}\n\t\t}\n\n\t\tif (mpext->use_map) {\n\t\t\tput_unaligned_be64(mpext->data_seq, ptr);\n\t\t\tptr += 2;\n\t\t\tput_unaligned_be32(mpext->subflow_seq, ptr);\n\t\t\tptr += 1;\n\t\t\tif (opts->csum_reqd) {\n\t\t\t\t \n\t\t\t\tput_len_csum(mpext->data_len,\n\t\t\t\t\t     (mpext->data_len ? mptcp_make_csum(mpext) : 0),\n\t\t\t\t\t     ptr);\n\t\t\t} else {\n\t\t\t\tput_unaligned_be32(mpext->data_len << 16 |\n\t\t\t\t\t\t   TCPOPT_NOP << 8 | TCPOPT_NOP, ptr);\n\t\t\t}\n\t\t\tptr += 1;\n\t\t}\n\n\t\t \n\t\tif (unlikely(OPTION_MPTCP_FAIL & opts->suboptions))\n\t\t\tgoto mp_fail;\n\t} else if (OPTIONS_MPTCP_MPC & opts->suboptions) {\n\t\tu8 len, flag = MPTCP_CAP_HMAC_SHA256;\n\n\t\tif (OPTION_MPTCP_MPC_SYN & opts->suboptions) {\n\t\t\tlen = TCPOLEN_MPTCP_MPC_SYN;\n\t\t} else if (OPTION_MPTCP_MPC_SYNACK & opts->suboptions) {\n\t\t\tlen = TCPOLEN_MPTCP_MPC_SYNACK;\n\t\t} else if (opts->data_len) {\n\t\t\tlen = TCPOLEN_MPTCP_MPC_ACK_DATA;\n\t\t\tif (opts->csum_reqd)\n\t\t\t\tlen += TCPOLEN_MPTCP_DSS_CHECKSUM;\n\t\t} else {\n\t\t\tlen = TCPOLEN_MPTCP_MPC_ACK;\n\t\t}\n\n\t\tif (opts->csum_reqd)\n\t\t\tflag |= MPTCP_CAP_CHECKSUM_REQD;\n\n\t\tif (!opts->allow_join_id0)\n\t\t\tflag |= MPTCP_CAP_DENY_JOIN_ID0;\n\n\t\t*ptr++ = mptcp_option(MPTCPOPT_MP_CAPABLE, len,\n\t\t\t\t      MPTCP_SUPPORTED_VERSION,\n\t\t\t\t      flag);\n\n\t\tif (!((OPTION_MPTCP_MPC_SYNACK | OPTION_MPTCP_MPC_ACK) &\n\t\t    opts->suboptions))\n\t\t\tgoto mp_capable_done;\n\n\t\tput_unaligned_be64(opts->sndr_key, ptr);\n\t\tptr += 2;\n\t\tif (!((OPTION_MPTCP_MPC_ACK) & opts->suboptions))\n\t\t\tgoto mp_capable_done;\n\n\t\tput_unaligned_be64(opts->rcvr_key, ptr);\n\t\tptr += 2;\n\t\tif (!opts->data_len)\n\t\t\tgoto mp_capable_done;\n\n\t\tif (opts->csum_reqd) {\n\t\t\tput_len_csum(opts->data_len,\n\t\t\t\t     __mptcp_make_csum(opts->data_seq,\n\t\t\t\t\t\t       opts->subflow_seq,\n\t\t\t\t\t\t       opts->data_len,\n\t\t\t\t\t\t       ~csum_unfold(opts->csum)),\n\t\t\t\t     ptr);\n\t\t} else {\n\t\t\tput_unaligned_be32(opts->data_len << 16 |\n\t\t\t\t\t   TCPOPT_NOP << 8 | TCPOPT_NOP, ptr);\n\t\t}\n\t\tptr += 1;\n\n\t\t \n\t\tgoto mp_capable_done;\n\t} else if (OPTIONS_MPTCP_MPJ & opts->suboptions) {\n\t\tif (OPTION_MPTCP_MPJ_SYN & opts->suboptions) {\n\t\t\t*ptr++ = mptcp_option(MPTCPOPT_MP_JOIN,\n\t\t\t\t\t      TCPOLEN_MPTCP_MPJ_SYN,\n\t\t\t\t\t      opts->backup, opts->join_id);\n\t\t\tput_unaligned_be32(opts->token, ptr);\n\t\t\tptr += 1;\n\t\t\tput_unaligned_be32(opts->nonce, ptr);\n\t\t\tptr += 1;\n\t\t} else if (OPTION_MPTCP_MPJ_SYNACK & opts->suboptions) {\n\t\t\t*ptr++ = mptcp_option(MPTCPOPT_MP_JOIN,\n\t\t\t\t\t      TCPOLEN_MPTCP_MPJ_SYNACK,\n\t\t\t\t\t      opts->backup, opts->join_id);\n\t\t\tput_unaligned_be64(opts->thmac, ptr);\n\t\t\tptr += 2;\n\t\t\tput_unaligned_be32(opts->nonce, ptr);\n\t\t\tptr += 1;\n\t\t} else {\n\t\t\t*ptr++ = mptcp_option(MPTCPOPT_MP_JOIN,\n\t\t\t\t\t      TCPOLEN_MPTCP_MPJ_ACK, 0, 0);\n\t\t\tmemcpy(ptr, opts->hmac, MPTCPOPT_HMAC_LEN);\n\t\t\tptr += 5;\n\t\t}\n\t} else if (OPTION_MPTCP_ADD_ADDR & opts->suboptions) {\n\t\tu8 len = TCPOLEN_MPTCP_ADD_ADDR_BASE;\n\t\tu8 echo = MPTCP_ADDR_ECHO;\n\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t\tif (opts->addr.family == AF_INET6)\n\t\t\tlen = TCPOLEN_MPTCP_ADD_ADDR6_BASE;\n#endif\n\n\t\tif (opts->addr.port)\n\t\t\tlen += TCPOLEN_MPTCP_PORT_LEN;\n\n\t\tif (opts->ahmac) {\n\t\t\tlen += sizeof(opts->ahmac);\n\t\t\techo = 0;\n\t\t}\n\n\t\t*ptr++ = mptcp_option(MPTCPOPT_ADD_ADDR,\n\t\t\t\t      len, echo, opts->addr.id);\n\t\tif (opts->addr.family == AF_INET) {\n\t\t\tmemcpy((u8 *)ptr, (u8 *)&opts->addr.addr.s_addr, 4);\n\t\t\tptr += 1;\n\t\t}\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t\telse if (opts->addr.family == AF_INET6) {\n\t\t\tmemcpy((u8 *)ptr, opts->addr.addr6.s6_addr, 16);\n\t\t\tptr += 4;\n\t\t}\n#endif\n\n\t\tif (!opts->addr.port) {\n\t\t\tif (opts->ahmac) {\n\t\t\t\tput_unaligned_be64(opts->ahmac, ptr);\n\t\t\t\tptr += 2;\n\t\t\t}\n\t\t} else {\n\t\t\tu16 port = ntohs(opts->addr.port);\n\n\t\t\tif (opts->ahmac) {\n\t\t\t\tu8 *bptr = (u8 *)ptr;\n\n\t\t\t\tput_unaligned_be16(port, bptr);\n\t\t\t\tbptr += 2;\n\t\t\t\tput_unaligned_be64(opts->ahmac, bptr);\n\t\t\t\tbptr += 8;\n\t\t\t\tput_unaligned_be16(TCPOPT_NOP << 8 |\n\t\t\t\t\t\t   TCPOPT_NOP, bptr);\n\n\t\t\t\tptr += 3;\n\t\t\t} else {\n\t\t\t\tput_unaligned_be32(port << 16 |\n\t\t\t\t\t\t   TCPOPT_NOP << 8 |\n\t\t\t\t\t\t   TCPOPT_NOP, ptr);\n\t\t\t\tptr += 1;\n\t\t\t}\n\t\t}\n\t} else if (unlikely(OPTION_MPTCP_FASTCLOSE & opts->suboptions)) {\n\t\t \n\t\t*ptr++ = mptcp_option(MPTCPOPT_MP_FASTCLOSE,\n\t\t\t\t      TCPOLEN_MPTCP_FASTCLOSE,\n\t\t\t\t      0, 0);\n\t\tput_unaligned_be64(opts->rcvr_key, ptr);\n\t\tptr += 2;\n\n\t\tif (OPTION_MPTCP_RST & opts->suboptions)\n\t\t\tgoto mp_rst;\n\t\treturn;\n\t} else if (unlikely(OPTION_MPTCP_FAIL & opts->suboptions)) {\nmp_fail:\n\t\t \n\t\tsubflow = mptcp_subflow_ctx(ssk);\n\t\tsubflow->send_mp_fail = 0;\n\n\t\t*ptr++ = mptcp_option(MPTCPOPT_MP_FAIL,\n\t\t\t\t      TCPOLEN_MPTCP_FAIL,\n\t\t\t\t      0, 0);\n\t\tput_unaligned_be64(opts->fail_seq, ptr);\n\t\tptr += 2;\n\n\t\tif (OPTION_MPTCP_RST & opts->suboptions)\n\t\t\tgoto mp_rst;\n\t\treturn;\n\t} else if (unlikely(OPTION_MPTCP_RST & opts->suboptions)) {\nmp_rst:\n\t\t*ptr++ = mptcp_option(MPTCPOPT_RST,\n\t\t\t\t      TCPOLEN_MPTCP_RST,\n\t\t\t\t      opts->reset_transient,\n\t\t\t\t      opts->reset_reason);\n\t\treturn;\n\t}\n\n\tif (OPTION_MPTCP_PRIO & opts->suboptions) {\n\t\tsubflow = mptcp_subflow_ctx(ssk);\n\t\tsubflow->send_mp_prio = 0;\n\n\t\t*ptr++ = mptcp_option(MPTCPOPT_MP_PRIO,\n\t\t\t\t      TCPOLEN_MPTCP_PRIO,\n\t\t\t\t      opts->backup, TCPOPT_NOP);\n\n\t\tMPTCP_INC_STATS(sock_net(ssk), MPTCP_MIB_MPPRIOTX);\n\t}\n\nmp_capable_done:\n\tif (OPTION_MPTCP_RM_ADDR & opts->suboptions) {\n\t\tu8 i = 1;\n\n\t\t*ptr++ = mptcp_option(MPTCPOPT_RM_ADDR,\n\t\t\t\t      TCPOLEN_MPTCP_RM_ADDR_BASE + opts->rm_list.nr,\n\t\t\t\t      0, opts->rm_list.ids[0]);\n\n\t\twhile (i < opts->rm_list.nr) {\n\t\t\tu8 id1, id2, id3, id4;\n\n\t\t\tid1 = opts->rm_list.ids[i];\n\t\t\tid2 = i + 1 < opts->rm_list.nr ? opts->rm_list.ids[i + 1] : TCPOPT_NOP;\n\t\t\tid3 = i + 2 < opts->rm_list.nr ? opts->rm_list.ids[i + 2] : TCPOPT_NOP;\n\t\t\tid4 = i + 3 < opts->rm_list.nr ? opts->rm_list.ids[i + 3] : TCPOPT_NOP;\n\t\t\tput_unaligned_be32(id1 << 24 | id2 << 16 | id3 << 8 | id4, ptr);\n\t\t\tptr += 1;\n\t\t\ti += 4;\n\t\t}\n\t}\n\n\tif (tp)\n\t\tmptcp_set_rwin(tp, th);\n}\n\n__be32 mptcp_get_reset_option(const struct sk_buff *skb)\n{\n\tconst struct mptcp_ext *ext = mptcp_get_ext(skb);\n\tu8 flags, reason;\n\n\tif (ext) {\n\t\tflags = ext->reset_transient;\n\t\treason = ext->reset_reason;\n\n\t\treturn mptcp_option(MPTCPOPT_RST, TCPOLEN_MPTCP_RST,\n\t\t\t\t    flags, reason);\n\t}\n\n\treturn htonl(0u);\n}\nEXPORT_SYMBOL_GPL(mptcp_get_reset_option);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}