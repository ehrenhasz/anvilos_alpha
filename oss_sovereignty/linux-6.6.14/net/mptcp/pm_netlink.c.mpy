{
  "module_name": "pm_netlink.c",
  "hash_id": "4b230cb01d2f6d4b9805e01359f4d5d76a4fba027011ee418ae6f7f4e22c90d8",
  "original_prompt": "Ingested from linux-6.6.14/net/mptcp/pm_netlink.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"MPTCP: \" fmt\n\n#include <linux/inet.h>\n#include <linux/kernel.h>\n#include <net/tcp.h>\n#include <net/inet_common.h>\n#include <net/netns/generic.h>\n#include <net/mptcp.h>\n#include <net/genetlink.h>\n#include <uapi/linux/mptcp.h>\n\n#include \"protocol.h\"\n#include \"mib.h\"\n\n \nstatic struct genl_family mptcp_genl_family;\n\nstatic int pm_nl_pernet_id;\n\nstruct mptcp_pm_add_entry {\n\tstruct list_head\tlist;\n\tstruct mptcp_addr_info\taddr;\n\tu8\t\t\tretrans_times;\n\tstruct timer_list\tadd_timer;\n\tstruct mptcp_sock\t*sock;\n};\n\nstruct pm_nl_pernet {\n\t \n\tspinlock_t\t\tlock;\n\tstruct list_head\tlocal_addr_list;\n\tunsigned int\t\taddrs;\n\tunsigned int\t\tstale_loss_cnt;\n\tunsigned int\t\tadd_addr_signal_max;\n\tunsigned int\t\tadd_addr_accept_max;\n\tunsigned int\t\tlocal_addr_max;\n\tunsigned int\t\tsubflows_max;\n\tunsigned int\t\tnext_id;\n\tDECLARE_BITMAP(id_bitmap, MPTCP_PM_MAX_ADDR_ID + 1);\n};\n\n#define MPTCP_PM_ADDR_MAX\t8\n#define ADD_ADDR_RETRANS_MAX\t3\n\nstatic struct pm_nl_pernet *pm_nl_get_pernet(const struct net *net)\n{\n\treturn net_generic(net, pm_nl_pernet_id);\n}\n\nstatic struct pm_nl_pernet *\npm_nl_get_pernet_from_msk(const struct mptcp_sock *msk)\n{\n\treturn pm_nl_get_pernet(sock_net((struct sock *)msk));\n}\n\nbool mptcp_addresses_equal(const struct mptcp_addr_info *a,\n\t\t\t   const struct mptcp_addr_info *b, bool use_port)\n{\n\tbool addr_equals = false;\n\n\tif (a->family == b->family) {\n\t\tif (a->family == AF_INET)\n\t\t\taddr_equals = a->addr.s_addr == b->addr.s_addr;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t\telse\n\t\t\taddr_equals = !ipv6_addr_cmp(&a->addr6, &b->addr6);\n\t} else if (a->family == AF_INET) {\n\t\tif (ipv6_addr_v4mapped(&b->addr6))\n\t\t\taddr_equals = a->addr.s_addr == b->addr6.s6_addr32[3];\n\t} else if (b->family == AF_INET) {\n\t\tif (ipv6_addr_v4mapped(&a->addr6))\n\t\t\taddr_equals = a->addr6.s6_addr32[3] == b->addr.s_addr;\n#endif\n\t}\n\n\tif (!addr_equals)\n\t\treturn false;\n\tif (!use_port)\n\t\treturn true;\n\n\treturn a->port == b->port;\n}\n\nvoid mptcp_local_address(const struct sock_common *skc, struct mptcp_addr_info *addr)\n{\n\taddr->family = skc->skc_family;\n\taddr->port = htons(skc->skc_num);\n\tif (addr->family == AF_INET)\n\t\taddr->addr.s_addr = skc->skc_rcv_saddr;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\telse if (addr->family == AF_INET6)\n\t\taddr->addr6 = skc->skc_v6_rcv_saddr;\n#endif\n}\n\nstatic void remote_address(const struct sock_common *skc,\n\t\t\t   struct mptcp_addr_info *addr)\n{\n\taddr->family = skc->skc_family;\n\taddr->port = skc->skc_dport;\n\tif (addr->family == AF_INET)\n\t\taddr->addr.s_addr = skc->skc_daddr;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\telse if (addr->family == AF_INET6)\n\t\taddr->addr6 = skc->skc_v6_daddr;\n#endif\n}\n\nstatic bool lookup_subflow_by_saddr(const struct list_head *list,\n\t\t\t\t    const struct mptcp_addr_info *saddr)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct mptcp_addr_info cur;\n\tstruct sock_common *skc;\n\n\tlist_for_each_entry(subflow, list, node) {\n\t\tskc = (struct sock_common *)mptcp_subflow_tcp_sock(subflow);\n\n\t\tmptcp_local_address(skc, &cur);\n\t\tif (mptcp_addresses_equal(&cur, saddr, saddr->port))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool lookup_subflow_by_daddr(const struct list_head *list,\n\t\t\t\t    const struct mptcp_addr_info *daddr)\n{\n\tstruct mptcp_subflow_context *subflow;\n\tstruct mptcp_addr_info cur;\n\tstruct sock_common *skc;\n\n\tlist_for_each_entry(subflow, list, node) {\n\t\tskc = (struct sock_common *)mptcp_subflow_tcp_sock(subflow);\n\n\t\tremote_address(skc, &cur);\n\t\tif (mptcp_addresses_equal(&cur, daddr, daddr->port))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct mptcp_pm_addr_entry *\nselect_local_address(const struct pm_nl_pernet *pernet,\n\t\t     const struct mptcp_sock *msk)\n{\n\tstruct mptcp_pm_addr_entry *entry, *ret = NULL;\n\n\tmsk_owned_by_me(msk);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, &pernet->local_addr_list, list) {\n\t\tif (!(entry->flags & MPTCP_PM_ADDR_FLAG_SUBFLOW))\n\t\t\tcontinue;\n\n\t\tif (!test_bit(entry->addr.id, msk->pm.id_avail_bitmap))\n\t\t\tcontinue;\n\n\t\tret = entry;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic struct mptcp_pm_addr_entry *\nselect_signal_address(struct pm_nl_pernet *pernet, const struct mptcp_sock *msk)\n{\n\tstruct mptcp_pm_addr_entry *entry, *ret = NULL;\n\n\trcu_read_lock();\n\t \n\tlist_for_each_entry_rcu(entry, &pernet->local_addr_list, list) {\n\t\tif (!test_bit(entry->addr.id, msk->pm.id_avail_bitmap))\n\t\t\tcontinue;\n\n\t\tif (!(entry->flags & MPTCP_PM_ADDR_FLAG_SIGNAL))\n\t\t\tcontinue;\n\n\t\tret = entry;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nunsigned int mptcp_pm_get_add_addr_signal_max(const struct mptcp_sock *msk)\n{\n\tconst struct pm_nl_pernet *pernet = pm_nl_get_pernet_from_msk(msk);\n\n\treturn READ_ONCE(pernet->add_addr_signal_max);\n}\nEXPORT_SYMBOL_GPL(mptcp_pm_get_add_addr_signal_max);\n\nunsigned int mptcp_pm_get_add_addr_accept_max(const struct mptcp_sock *msk)\n{\n\tstruct pm_nl_pernet *pernet = pm_nl_get_pernet_from_msk(msk);\n\n\treturn READ_ONCE(pernet->add_addr_accept_max);\n}\nEXPORT_SYMBOL_GPL(mptcp_pm_get_add_addr_accept_max);\n\nunsigned int mptcp_pm_get_subflows_max(const struct mptcp_sock *msk)\n{\n\tstruct pm_nl_pernet *pernet = pm_nl_get_pernet_from_msk(msk);\n\n\treturn READ_ONCE(pernet->subflows_max);\n}\nEXPORT_SYMBOL_GPL(mptcp_pm_get_subflows_max);\n\nunsigned int mptcp_pm_get_local_addr_max(const struct mptcp_sock *msk)\n{\n\tstruct pm_nl_pernet *pernet = pm_nl_get_pernet_from_msk(msk);\n\n\treturn READ_ONCE(pernet->local_addr_max);\n}\nEXPORT_SYMBOL_GPL(mptcp_pm_get_local_addr_max);\n\nbool mptcp_pm_nl_check_work_pending(struct mptcp_sock *msk)\n{\n\tstruct pm_nl_pernet *pernet = pm_nl_get_pernet_from_msk(msk);\n\n\tif (msk->pm.subflows == mptcp_pm_get_subflows_max(msk) ||\n\t    (find_next_and_bit(pernet->id_bitmap, msk->pm.id_avail_bitmap,\n\t\t\t       MPTCP_PM_MAX_ADDR_ID + 1, 0) == MPTCP_PM_MAX_ADDR_ID + 1)) {\n\t\tWRITE_ONCE(msk->pm.work_pending, false);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstruct mptcp_pm_add_entry *\nmptcp_lookup_anno_list_by_saddr(const struct mptcp_sock *msk,\n\t\t\t\tconst struct mptcp_addr_info *addr)\n{\n\tstruct mptcp_pm_add_entry *entry;\n\n\tlockdep_assert_held(&msk->pm.lock);\n\n\tlist_for_each_entry(entry, &msk->pm.anno_list, list) {\n\t\tif (mptcp_addresses_equal(&entry->addr, addr, true))\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\nbool mptcp_pm_sport_in_anno_list(struct mptcp_sock *msk, const struct sock *sk)\n{\n\tstruct mptcp_pm_add_entry *entry;\n\tstruct mptcp_addr_info saddr;\n\tbool ret = false;\n\n\tmptcp_local_address((struct sock_common *)sk, &saddr);\n\n\tspin_lock_bh(&msk->pm.lock);\n\tlist_for_each_entry(entry, &msk->pm.anno_list, list) {\n\t\tif (mptcp_addresses_equal(&entry->addr, &saddr, true)) {\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock_bh(&msk->pm.lock);\n\treturn ret;\n}\n\nstatic void mptcp_pm_add_timer(struct timer_list *timer)\n{\n\tstruct mptcp_pm_add_entry *entry = from_timer(entry, timer, add_timer);\n\tstruct mptcp_sock *msk = entry->sock;\n\tstruct sock *sk = (struct sock *)msk;\n\n\tpr_debug(\"msk=%p\", msk);\n\n\tif (!msk)\n\t\treturn;\n\n\tif (inet_sk_state_load(sk) == TCP_CLOSE)\n\t\treturn;\n\n\tif (!entry->addr.id)\n\t\treturn;\n\n\tif (mptcp_pm_should_add_signal_addr(msk)) {\n\t\tsk_reset_timer(sk, timer, jiffies + TCP_RTO_MAX / 8);\n\t\tgoto out;\n\t}\n\n\tspin_lock_bh(&msk->pm.lock);\n\n\tif (!mptcp_pm_should_add_signal_addr(msk)) {\n\t\tpr_debug(\"retransmit ADD_ADDR id=%d\", entry->addr.id);\n\t\tmptcp_pm_announce_addr(msk, &entry->addr, false);\n\t\tmptcp_pm_add_addr_send_ack(msk);\n\t\tentry->retrans_times++;\n\t}\n\n\tif (entry->retrans_times < ADD_ADDR_RETRANS_MAX)\n\t\tsk_reset_timer(sk, timer,\n\t\t\t       jiffies + mptcp_get_add_addr_timeout(sock_net(sk)));\n\n\tspin_unlock_bh(&msk->pm.lock);\n\n\tif (entry->retrans_times == ADD_ADDR_RETRANS_MAX)\n\t\tmptcp_pm_subflow_established(msk);\n\nout:\n\t__sock_put(sk);\n}\n\nstruct mptcp_pm_add_entry *\nmptcp_pm_del_add_timer(struct mptcp_sock *msk,\n\t\t       const struct mptcp_addr_info *addr, bool check_id)\n{\n\tstruct mptcp_pm_add_entry *entry;\n\tstruct sock *sk = (struct sock *)msk;\n\n\tspin_lock_bh(&msk->pm.lock);\n\tentry = mptcp_lookup_anno_list_by_saddr(msk, addr);\n\tif (entry && (!check_id || entry->addr.id == addr->id))\n\t\tentry->retrans_times = ADD_ADDR_RETRANS_MAX;\n\tspin_unlock_bh(&msk->pm.lock);\n\n\tif (entry && (!check_id || entry->addr.id == addr->id))\n\t\tsk_stop_timer_sync(sk, &entry->add_timer);\n\n\treturn entry;\n}\n\nbool mptcp_pm_alloc_anno_list(struct mptcp_sock *msk,\n\t\t\t      const struct mptcp_addr_info *addr)\n{\n\tstruct mptcp_pm_add_entry *add_entry = NULL;\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct net *net = sock_net(sk);\n\n\tlockdep_assert_held(&msk->pm.lock);\n\n\tadd_entry = mptcp_lookup_anno_list_by_saddr(msk, addr);\n\n\tif (add_entry) {\n\t\tif (mptcp_pm_is_kernel(msk))\n\t\t\treturn false;\n\n\t\tsk_reset_timer(sk, &add_entry->add_timer,\n\t\t\t       jiffies + mptcp_get_add_addr_timeout(net));\n\t\treturn true;\n\t}\n\n\tadd_entry = kmalloc(sizeof(*add_entry), GFP_ATOMIC);\n\tif (!add_entry)\n\t\treturn false;\n\n\tlist_add(&add_entry->list, &msk->pm.anno_list);\n\n\tadd_entry->addr = *addr;\n\tadd_entry->sock = msk;\n\tadd_entry->retrans_times = 0;\n\n\ttimer_setup(&add_entry->add_timer, mptcp_pm_add_timer, 0);\n\tsk_reset_timer(sk, &add_entry->add_timer,\n\t\t       jiffies + mptcp_get_add_addr_timeout(net));\n\n\treturn true;\n}\n\nvoid mptcp_pm_free_anno_list(struct mptcp_sock *msk)\n{\n\tstruct mptcp_pm_add_entry *entry, *tmp;\n\tstruct sock *sk = (struct sock *)msk;\n\tLIST_HEAD(free_list);\n\n\tpr_debug(\"msk=%p\", msk);\n\n\tspin_lock_bh(&msk->pm.lock);\n\tlist_splice_init(&msk->pm.anno_list, &free_list);\n\tspin_unlock_bh(&msk->pm.lock);\n\n\tlist_for_each_entry_safe(entry, tmp, &free_list, list) {\n\t\tsk_stop_timer_sync(sk, &entry->add_timer);\n\t\tkfree(entry);\n\t}\n}\n\nstatic bool lookup_address_in_vec(const struct mptcp_addr_info *addrs, unsigned int nr,\n\t\t\t\t  const struct mptcp_addr_info *addr)\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (addrs[i].id == addr->id)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic unsigned int fill_remote_addresses_vec(struct mptcp_sock *msk,\n\t\t\t\t\t      struct mptcp_addr_info *local,\n\t\t\t\t\t      bool fullmesh,\n\t\t\t\t\t      struct mptcp_addr_info *addrs)\n{\n\tbool deny_id0 = READ_ONCE(msk->pm.remote_deny_join_id0);\n\tstruct sock *sk = (struct sock *)msk, *ssk;\n\tstruct mptcp_subflow_context *subflow;\n\tstruct mptcp_addr_info remote = { 0 };\n\tunsigned int subflows_max;\n\tint i = 0;\n\n\tsubflows_max = mptcp_pm_get_subflows_max(msk);\n\tremote_address((struct sock_common *)sk, &remote);\n\n\t \n\tif (!fullmesh) {\n\t\tif (deny_id0)\n\t\t\treturn 0;\n\n\t\tif (!mptcp_pm_addr_families_match(sk, local, &remote))\n\t\t\treturn 0;\n\n\t\tmsk->pm.subflows++;\n\t\taddrs[i++] = remote;\n\t} else {\n\t\tmptcp_for_each_subflow(msk, subflow) {\n\t\t\tssk = mptcp_subflow_tcp_sock(subflow);\n\t\t\tremote_address((struct sock_common *)ssk, &addrs[i]);\n\t\t\taddrs[i].id = subflow->remote_id;\n\t\t\tif (deny_id0 && !addrs[i].id)\n\t\t\t\tcontinue;\n\n\t\t\tif (!mptcp_pm_addr_families_match(sk, local, &addrs[i]))\n\t\t\t\tcontinue;\n\n\t\t\tif (!lookup_address_in_vec(addrs, i, &addrs[i]) &&\n\t\t\t    msk->pm.subflows < subflows_max) {\n\t\t\t\tmsk->pm.subflows++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn i;\n}\n\nstatic void __mptcp_pm_send_ack(struct mptcp_sock *msk, struct mptcp_subflow_context *subflow,\n\t\t\t\tbool prio, bool backup)\n{\n\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\tbool slow;\n\n\tpr_debug(\"send ack for %s\",\n\t\t prio ? \"mp_prio\" : (mptcp_pm_should_add_signal(msk) ? \"add_addr\" : \"rm_addr\"));\n\n\tslow = lock_sock_fast(ssk);\n\tif (prio) {\n\t\tsubflow->send_mp_prio = 1;\n\t\tsubflow->backup = backup;\n\t\tsubflow->request_bkup = backup;\n\t}\n\n\t__mptcp_subflow_send_ack(ssk);\n\tunlock_sock_fast(ssk, slow);\n}\n\nstatic void mptcp_pm_send_ack(struct mptcp_sock *msk, struct mptcp_subflow_context *subflow,\n\t\t\t      bool prio, bool backup)\n{\n\tspin_unlock_bh(&msk->pm.lock);\n\t__mptcp_pm_send_ack(msk, subflow, prio, backup);\n\tspin_lock_bh(&msk->pm.lock);\n}\n\nstatic struct mptcp_pm_addr_entry *\n__lookup_addr_by_id(struct pm_nl_pernet *pernet, unsigned int id)\n{\n\tstruct mptcp_pm_addr_entry *entry;\n\n\tlist_for_each_entry(entry, &pernet->local_addr_list, list) {\n\t\tif (entry->addr.id == id)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic struct mptcp_pm_addr_entry *\n__lookup_addr(struct pm_nl_pernet *pernet, const struct mptcp_addr_info *info,\n\t      bool lookup_by_id)\n{\n\tstruct mptcp_pm_addr_entry *entry;\n\n\tlist_for_each_entry(entry, &pernet->local_addr_list, list) {\n\t\tif ((!lookup_by_id &&\n\t\t     mptcp_addresses_equal(&entry->addr, info, entry->addr.port)) ||\n\t\t    (lookup_by_id && entry->addr.id == info->id))\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic void mptcp_pm_create_subflow_or_signal_addr(struct mptcp_sock *msk)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct mptcp_pm_addr_entry *local;\n\tunsigned int add_addr_signal_max;\n\tunsigned int local_addr_max;\n\tstruct pm_nl_pernet *pernet;\n\tunsigned int subflows_max;\n\n\tpernet = pm_nl_get_pernet(sock_net(sk));\n\n\tadd_addr_signal_max = mptcp_pm_get_add_addr_signal_max(msk);\n\tlocal_addr_max = mptcp_pm_get_local_addr_max(msk);\n\tsubflows_max = mptcp_pm_get_subflows_max(msk);\n\n\t \n\tif (unlikely(!(msk->pm.status & BIT(MPTCP_PM_MPC_ENDPOINT_ACCOUNTED))) && msk->first) {\n\t\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(msk->first);\n\t\tstruct mptcp_pm_addr_entry *entry;\n\t\tstruct mptcp_addr_info mpc_addr;\n\t\tbool backup = false;\n\n\t\tmptcp_local_address((struct sock_common *)msk->first, &mpc_addr);\n\t\trcu_read_lock();\n\t\tentry = __lookup_addr(pernet, &mpc_addr, false);\n\t\tif (entry) {\n\t\t\t__clear_bit(entry->addr.id, msk->pm.id_avail_bitmap);\n\t\t\tmsk->mpc_endpoint_id = entry->addr.id;\n\t\t\tbackup = !!(entry->flags & MPTCP_PM_ADDR_FLAG_BACKUP);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (backup)\n\t\t\tmptcp_pm_send_ack(msk, subflow, true, backup);\n\n\t\tmsk->pm.status |= BIT(MPTCP_PM_MPC_ENDPOINT_ACCOUNTED);\n\t}\n\n\tpr_debug(\"local %d:%d signal %d:%d subflows %d:%d\\n\",\n\t\t msk->pm.local_addr_used, local_addr_max,\n\t\t msk->pm.add_addr_signaled, add_addr_signal_max,\n\t\t msk->pm.subflows, subflows_max);\n\n\t \n\tif (msk->pm.add_addr_signaled < add_addr_signal_max) {\n\t\tlocal = select_signal_address(pernet, msk);\n\n\t\t \n\t\tif (msk->pm.addr_signal & BIT(MPTCP_ADD_ADDR_SIGNAL))\n\t\t\treturn;\n\n\t\tif (local) {\n\t\t\tif (mptcp_pm_alloc_anno_list(msk, &local->addr)) {\n\t\t\t\t__clear_bit(local->addr.id, msk->pm.id_avail_bitmap);\n\t\t\t\tmsk->pm.add_addr_signaled++;\n\t\t\t\tmptcp_pm_announce_addr(msk, &local->addr, false);\n\t\t\t\tmptcp_pm_nl_addr_send_ack(msk);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\twhile (msk->pm.local_addr_used < local_addr_max &&\n\t       msk->pm.subflows < subflows_max) {\n\t\tstruct mptcp_addr_info addrs[MPTCP_PM_ADDR_MAX];\n\t\tbool fullmesh;\n\t\tint i, nr;\n\n\t\tlocal = select_local_address(pernet, msk);\n\t\tif (!local)\n\t\t\tbreak;\n\n\t\tfullmesh = !!(local->flags & MPTCP_PM_ADDR_FLAG_FULLMESH);\n\n\t\tmsk->pm.local_addr_used++;\n\t\t__clear_bit(local->addr.id, msk->pm.id_avail_bitmap);\n\t\tnr = fill_remote_addresses_vec(msk, &local->addr, fullmesh, addrs);\n\t\tif (nr == 0)\n\t\t\tcontinue;\n\n\t\tspin_unlock_bh(&msk->pm.lock);\n\t\tfor (i = 0; i < nr; i++)\n\t\t\t__mptcp_subflow_connect(sk, &local->addr, &addrs[i]);\n\t\tspin_lock_bh(&msk->pm.lock);\n\t}\n\tmptcp_pm_nl_check_work_pending(msk);\n}\n\nstatic void mptcp_pm_nl_fully_established(struct mptcp_sock *msk)\n{\n\tmptcp_pm_create_subflow_or_signal_addr(msk);\n}\n\nstatic void mptcp_pm_nl_subflow_established(struct mptcp_sock *msk)\n{\n\tmptcp_pm_create_subflow_or_signal_addr(msk);\n}\n\n \nstatic unsigned int fill_local_addresses_vec(struct mptcp_sock *msk,\n\t\t\t\t\t     struct mptcp_addr_info *remote,\n\t\t\t\t\t     struct mptcp_addr_info *addrs)\n{\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct mptcp_pm_addr_entry *entry;\n\tstruct pm_nl_pernet *pernet;\n\tunsigned int subflows_max;\n\tint i = 0;\n\n\tpernet = pm_nl_get_pernet_from_msk(msk);\n\tsubflows_max = mptcp_pm_get_subflows_max(msk);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, &pernet->local_addr_list, list) {\n\t\tif (!(entry->flags & MPTCP_PM_ADDR_FLAG_FULLMESH))\n\t\t\tcontinue;\n\n\t\tif (!mptcp_pm_addr_families_match(sk, &entry->addr, remote))\n\t\t\tcontinue;\n\n\t\tif (msk->pm.subflows < subflows_max) {\n\t\t\tmsk->pm.subflows++;\n\t\t\taddrs[i++] = entry->addr;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t \n\tif (!i) {\n\t\tstruct mptcp_addr_info local;\n\n\t\tmemset(&local, 0, sizeof(local));\n\t\tlocal.family =\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t\t\t       remote->family == AF_INET6 &&\n\t\t\t       ipv6_addr_v4mapped(&remote->addr6) ? AF_INET :\n#endif\n\t\t\t       remote->family;\n\n\t\tif (!mptcp_pm_addr_families_match(sk, &local, remote))\n\t\t\treturn 0;\n\n\t\tmsk->pm.subflows++;\n\t\taddrs[i++] = local;\n\t}\n\n\treturn i;\n}\n\nstatic void mptcp_pm_nl_add_addr_received(struct mptcp_sock *msk)\n{\n\tstruct mptcp_addr_info addrs[MPTCP_PM_ADDR_MAX];\n\tstruct sock *sk = (struct sock *)msk;\n\tunsigned int add_addr_accept_max;\n\tstruct mptcp_addr_info remote;\n\tunsigned int subflows_max;\n\tint i, nr;\n\n\tadd_addr_accept_max = mptcp_pm_get_add_addr_accept_max(msk);\n\tsubflows_max = mptcp_pm_get_subflows_max(msk);\n\n\tpr_debug(\"accepted %d:%d remote family %d\",\n\t\t msk->pm.add_addr_accepted, add_addr_accept_max,\n\t\t msk->pm.remote.family);\n\n\tremote = msk->pm.remote;\n\tmptcp_pm_announce_addr(msk, &remote, true);\n\tmptcp_pm_nl_addr_send_ack(msk);\n\n\tif (lookup_subflow_by_daddr(&msk->conn_list, &remote))\n\t\treturn;\n\n\t \n\tif (!remote.port)\n\t\tremote.port = sk->sk_dport;\n\n\t \n\tnr = fill_local_addresses_vec(msk, &remote, addrs);\n\tif (nr == 0)\n\t\treturn;\n\n\tmsk->pm.add_addr_accepted++;\n\tif (msk->pm.add_addr_accepted >= add_addr_accept_max ||\n\t    msk->pm.subflows >= subflows_max)\n\t\tWRITE_ONCE(msk->pm.accept_addr, false);\n\n\tspin_unlock_bh(&msk->pm.lock);\n\tfor (i = 0; i < nr; i++)\n\t\t__mptcp_subflow_connect(sk, &addrs[i], &remote);\n\tspin_lock_bh(&msk->pm.lock);\n}\n\nvoid mptcp_pm_nl_addr_send_ack(struct mptcp_sock *msk)\n{\n\tstruct mptcp_subflow_context *subflow;\n\n\tmsk_owned_by_me(msk);\n\tlockdep_assert_held(&msk->pm.lock);\n\n\tif (!mptcp_pm_should_add_signal(msk) &&\n\t    !mptcp_pm_should_rm_signal(msk))\n\t\treturn;\n\n\tsubflow = list_first_entry_or_null(&msk->conn_list, typeof(*subflow), node);\n\tif (subflow)\n\t\tmptcp_pm_send_ack(msk, subflow, false, false);\n}\n\nint mptcp_pm_nl_mp_prio_send_ack(struct mptcp_sock *msk,\n\t\t\t\t struct mptcp_addr_info *addr,\n\t\t\t\t struct mptcp_addr_info *rem,\n\t\t\t\t u8 bkup)\n{\n\tstruct mptcp_subflow_context *subflow;\n\n\tpr_debug(\"bkup=%d\", bkup);\n\n\tmptcp_for_each_subflow(msk, subflow) {\n\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\t\tstruct mptcp_addr_info local, remote;\n\n\t\tmptcp_local_address((struct sock_common *)ssk, &local);\n\t\tif (!mptcp_addresses_equal(&local, addr, addr->port))\n\t\t\tcontinue;\n\n\t\tif (rem && rem->family != AF_UNSPEC) {\n\t\t\tremote_address((struct sock_common *)ssk, &remote);\n\t\t\tif (!mptcp_addresses_equal(&remote, rem, rem->port))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t__mptcp_pm_send_ack(msk, subflow, true, bkup);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic bool mptcp_local_id_match(const struct mptcp_sock *msk, u8 local_id, u8 id)\n{\n\treturn local_id == id || (!local_id && msk->mpc_endpoint_id == id);\n}\n\nstatic void mptcp_pm_nl_rm_addr_or_subflow(struct mptcp_sock *msk,\n\t\t\t\t\t   const struct mptcp_rm_list *rm_list,\n\t\t\t\t\t   enum linux_mptcp_mib_field rm_type)\n{\n\tstruct mptcp_subflow_context *subflow, *tmp;\n\tstruct sock *sk = (struct sock *)msk;\n\tu8 i;\n\n\tpr_debug(\"%s rm_list_nr %d\",\n\t\t rm_type == MPTCP_MIB_RMADDR ? \"address\" : \"subflow\", rm_list->nr);\n\n\tmsk_owned_by_me(msk);\n\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn;\n\n\tif (!rm_list->nr)\n\t\treturn;\n\n\tif (list_empty(&msk->conn_list))\n\t\treturn;\n\n\tfor (i = 0; i < rm_list->nr; i++) {\n\t\tu8 rm_id = rm_list->ids[i];\n\t\tbool removed = false;\n\n\t\tmptcp_for_each_subflow_safe(msk, subflow, tmp) {\n\t\t\tstruct sock *ssk = mptcp_subflow_tcp_sock(subflow);\n\t\t\tint how = RCV_SHUTDOWN | SEND_SHUTDOWN;\n\t\t\tu8 id = subflow->local_id;\n\n\t\t\tif (rm_type == MPTCP_MIB_RMADDR && subflow->remote_id != rm_id)\n\t\t\t\tcontinue;\n\t\t\tif (rm_type == MPTCP_MIB_RMSUBFLOW && !mptcp_local_id_match(msk, id, rm_id))\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\" -> %s rm_list_ids[%d]=%u local_id=%u remote_id=%u mpc_id=%u\",\n\t\t\t\t rm_type == MPTCP_MIB_RMADDR ? \"address\" : \"subflow\",\n\t\t\t\t i, rm_id, subflow->local_id, subflow->remote_id,\n\t\t\t\t msk->mpc_endpoint_id);\n\t\t\tspin_unlock_bh(&msk->pm.lock);\n\t\t\tmptcp_subflow_shutdown(sk, ssk, how);\n\n\t\t\t \n\t\t\tmptcp_close_ssk(sk, ssk, subflow);\n\t\t\tspin_lock_bh(&msk->pm.lock);\n\n\t\t\tremoved = true;\n\t\t\t__MPTCP_INC_STATS(sock_net(sk), rm_type);\n\t\t}\n\t\tif (rm_type == MPTCP_MIB_RMSUBFLOW)\n\t\t\t__set_bit(rm_id ? rm_id : msk->mpc_endpoint_id, msk->pm.id_avail_bitmap);\n\t\tif (!removed)\n\t\t\tcontinue;\n\n\t\tif (!mptcp_pm_is_kernel(msk))\n\t\t\tcontinue;\n\n\t\tif (rm_type == MPTCP_MIB_RMADDR) {\n\t\t\tmsk->pm.add_addr_accepted--;\n\t\t\tWRITE_ONCE(msk->pm.accept_addr, true);\n\t\t} else if (rm_type == MPTCP_MIB_RMSUBFLOW) {\n\t\t\tmsk->pm.local_addr_used--;\n\t\t}\n\t}\n}\n\nstatic void mptcp_pm_nl_rm_addr_received(struct mptcp_sock *msk)\n{\n\tmptcp_pm_nl_rm_addr_or_subflow(msk, &msk->pm.rm_list_rx, MPTCP_MIB_RMADDR);\n}\n\nvoid mptcp_pm_nl_rm_subflow_received(struct mptcp_sock *msk,\n\t\t\t\t     const struct mptcp_rm_list *rm_list)\n{\n\tmptcp_pm_nl_rm_addr_or_subflow(msk, rm_list, MPTCP_MIB_RMSUBFLOW);\n}\n\nvoid mptcp_pm_nl_work(struct mptcp_sock *msk)\n{\n\tstruct mptcp_pm_data *pm = &msk->pm;\n\n\tmsk_owned_by_me(msk);\n\n\tif (!(pm->status & MPTCP_PM_WORK_MASK))\n\t\treturn;\n\n\tspin_lock_bh(&msk->pm.lock);\n\n\tpr_debug(\"msk=%p status=%x\", msk, pm->status);\n\tif (pm->status & BIT(MPTCP_PM_ADD_ADDR_RECEIVED)) {\n\t\tpm->status &= ~BIT(MPTCP_PM_ADD_ADDR_RECEIVED);\n\t\tmptcp_pm_nl_add_addr_received(msk);\n\t}\n\tif (pm->status & BIT(MPTCP_PM_ADD_ADDR_SEND_ACK)) {\n\t\tpm->status &= ~BIT(MPTCP_PM_ADD_ADDR_SEND_ACK);\n\t\tmptcp_pm_nl_addr_send_ack(msk);\n\t}\n\tif (pm->status & BIT(MPTCP_PM_RM_ADDR_RECEIVED)) {\n\t\tpm->status &= ~BIT(MPTCP_PM_RM_ADDR_RECEIVED);\n\t\tmptcp_pm_nl_rm_addr_received(msk);\n\t}\n\tif (pm->status & BIT(MPTCP_PM_ESTABLISHED)) {\n\t\tpm->status &= ~BIT(MPTCP_PM_ESTABLISHED);\n\t\tmptcp_pm_nl_fully_established(msk);\n\t}\n\tif (pm->status & BIT(MPTCP_PM_SUBFLOW_ESTABLISHED)) {\n\t\tpm->status &= ~BIT(MPTCP_PM_SUBFLOW_ESTABLISHED);\n\t\tmptcp_pm_nl_subflow_established(msk);\n\t}\n\n\tspin_unlock_bh(&msk->pm.lock);\n}\n\nstatic bool address_use_port(struct mptcp_pm_addr_entry *entry)\n{\n\treturn (entry->flags &\n\t\t(MPTCP_PM_ADDR_FLAG_SIGNAL | MPTCP_PM_ADDR_FLAG_SUBFLOW)) ==\n\t\tMPTCP_PM_ADDR_FLAG_SIGNAL;\n}\n\n \nstatic void __mptcp_pm_release_addr_entry(struct mptcp_pm_addr_entry *entry)\n{\n\tif (entry->lsk)\n\t\tsock_release(entry->lsk);\n\tkfree(entry);\n}\n\nstatic int mptcp_pm_nl_append_new_local_addr(struct pm_nl_pernet *pernet,\n\t\t\t\t\t     struct mptcp_pm_addr_entry *entry)\n{\n\tstruct mptcp_pm_addr_entry *cur, *del_entry = NULL;\n\tunsigned int addr_max;\n\tint ret = -EINVAL;\n\n\tspin_lock_bh(&pernet->lock);\n\t \n\tif (pernet->next_id == MPTCP_PM_MAX_ADDR_ID)\n\t\tpernet->next_id = 1;\n\tif (pernet->addrs >= MPTCP_PM_ADDR_MAX) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\tif (test_bit(entry->addr.id, pernet->id_bitmap)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!address_use_port(entry))\n\t\tentry->addr.port = 0;\n\tlist_for_each_entry(cur, &pernet->local_addr_list, list) {\n\t\tif (mptcp_addresses_equal(&cur->addr, &entry->addr,\n\t\t\t\t\t  cur->addr.port || entry->addr.port)) {\n\t\t\t \n\t\t\tif (!(cur->flags & MPTCP_PM_ADDR_FLAG_IMPLICIT)) {\n\t\t\t\tret = -EEXIST;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (entry->addr.id)\n\t\t\t\tgoto out;\n\n\t\t\tpernet->addrs--;\n\t\t\tentry->addr.id = cur->addr.id;\n\t\t\tlist_del_rcu(&cur->list);\n\t\t\tdel_entry = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!entry->addr.id) {\nfind_next:\n\t\tentry->addr.id = find_next_zero_bit(pernet->id_bitmap,\n\t\t\t\t\t\t    MPTCP_PM_MAX_ADDR_ID + 1,\n\t\t\t\t\t\t    pernet->next_id);\n\t\tif (!entry->addr.id && pernet->next_id != 1) {\n\t\t\tpernet->next_id = 1;\n\t\t\tgoto find_next;\n\t\t}\n\t}\n\n\tif (!entry->addr.id)\n\t\tgoto out;\n\n\t__set_bit(entry->addr.id, pernet->id_bitmap);\n\tif (entry->addr.id > pernet->next_id)\n\t\tpernet->next_id = entry->addr.id;\n\n\tif (entry->flags & MPTCP_PM_ADDR_FLAG_SIGNAL) {\n\t\taddr_max = pernet->add_addr_signal_max;\n\t\tWRITE_ONCE(pernet->add_addr_signal_max, addr_max + 1);\n\t}\n\tif (entry->flags & MPTCP_PM_ADDR_FLAG_SUBFLOW) {\n\t\taddr_max = pernet->local_addr_max;\n\t\tWRITE_ONCE(pernet->local_addr_max, addr_max + 1);\n\t}\n\n\tpernet->addrs++;\n\tif (!entry->addr.port)\n\t\tlist_add_tail_rcu(&entry->list, &pernet->local_addr_list);\n\telse\n\t\tlist_add_rcu(&entry->list, &pernet->local_addr_list);\n\tret = entry->addr.id;\n\nout:\n\tspin_unlock_bh(&pernet->lock);\n\n\t \n\tif (del_entry) {\n\t\tsynchronize_rcu();\n\t\t__mptcp_pm_release_addr_entry(del_entry);\n\t}\n\treturn ret;\n}\n\nstatic struct lock_class_key mptcp_slock_keys[2];\nstatic struct lock_class_key mptcp_keys[2];\n\nstatic int mptcp_pm_nl_create_listen_socket(struct sock *sk,\n\t\t\t\t\t    struct mptcp_pm_addr_entry *entry)\n{\n\tbool is_ipv6 = sk->sk_family == AF_INET6;\n\tint addrlen = sizeof(struct sockaddr_in);\n\tstruct sockaddr_storage addr;\n\tstruct sock *newsk, *ssk;\n\tint backlog = 1024;\n\tint err;\n\n\terr = sock_create_kern(sock_net(sk), entry->addr.family,\n\t\t\t       SOCK_STREAM, IPPROTO_MPTCP, &entry->lsk);\n\tif (err)\n\t\treturn err;\n\n\tnewsk = entry->lsk->sk;\n\tif (!newsk)\n\t\treturn -EINVAL;\n\n\t \n\tsock_lock_init_class_and_name(newsk,\n\t\t\t\t      is_ipv6 ? \"mlock-AF_INET6\" : \"mlock-AF_INET\",\n\t\t\t\t      &mptcp_slock_keys[is_ipv6],\n\t\t\t\t      is_ipv6 ? \"msk_lock-AF_INET6\" : \"msk_lock-AF_INET\",\n\t\t\t\t      &mptcp_keys[is_ipv6]);\n\n\tlock_sock(newsk);\n\tssk = __mptcp_nmpc_sk(mptcp_sk(newsk));\n\trelease_sock(newsk);\n\tif (IS_ERR(ssk))\n\t\treturn PTR_ERR(ssk);\n\n\tmptcp_info2sockaddr(&entry->addr, &addr, entry->addr.family);\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\tif (entry->addr.family == AF_INET6)\n\t\taddrlen = sizeof(struct sockaddr_in6);\n#endif\n\tif (ssk->sk_family == AF_INET)\n\t\terr = inet_bind_sk(ssk, (struct sockaddr *)&addr, addrlen);\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\telse if (ssk->sk_family == AF_INET6)\n\t\terr = inet6_bind_sk(ssk, (struct sockaddr *)&addr, addrlen);\n#endif\n\tif (err)\n\t\treturn err;\n\n\tinet_sk_state_store(newsk, TCP_LISTEN);\n\tlock_sock(ssk);\n\terr = __inet_listen_sk(ssk, backlog);\n\tif (!err)\n\t\tmptcp_event_pm_listener(ssk, MPTCP_EVENT_LISTENER_CREATED);\n\trelease_sock(ssk);\n\treturn err;\n}\n\nint mptcp_pm_nl_get_local_id(struct mptcp_sock *msk, struct mptcp_addr_info *skc)\n{\n\tstruct mptcp_pm_addr_entry *entry;\n\tstruct pm_nl_pernet *pernet;\n\tint ret = -1;\n\n\tpernet = pm_nl_get_pernet_from_msk(msk);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, &pernet->local_addr_list, list) {\n\t\tif (mptcp_addresses_equal(&entry->addr, skc, entry->addr.port)) {\n\t\t\tret = entry->addr.id;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (ret >= 0)\n\t\treturn ret;\n\n\t \n\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->addr = *skc;\n\tentry->addr.id = 0;\n\tentry->addr.port = 0;\n\tentry->ifindex = 0;\n\tentry->flags = MPTCP_PM_ADDR_FLAG_IMPLICIT;\n\tentry->lsk = NULL;\n\tret = mptcp_pm_nl_append_new_local_addr(pernet, entry);\n\tif (ret < 0)\n\t\tkfree(entry);\n\n\treturn ret;\n}\n\n#define MPTCP_PM_CMD_GRP_OFFSET       0\n#define MPTCP_PM_EV_GRP_OFFSET        1\n\nstatic const struct genl_multicast_group mptcp_pm_mcgrps[] = {\n\t[MPTCP_PM_CMD_GRP_OFFSET]\t= { .name = MPTCP_PM_CMD_GRP_NAME, },\n\t[MPTCP_PM_EV_GRP_OFFSET]        = { .name = MPTCP_PM_EV_GRP_NAME,\n\t\t\t\t\t    .flags = GENL_UNS_ADMIN_PERM,\n\t\t\t\t\t  },\n};\n\nstatic const struct nla_policy\nmptcp_pm_addr_policy[MPTCP_PM_ADDR_ATTR_MAX + 1] = {\n\t[MPTCP_PM_ADDR_ATTR_FAMILY]\t= { .type\t= NLA_U16,\t},\n\t[MPTCP_PM_ADDR_ATTR_ID]\t\t= { .type\t= NLA_U8,\t},\n\t[MPTCP_PM_ADDR_ATTR_ADDR4]\t= { .type\t= NLA_U32,\t},\n\t[MPTCP_PM_ADDR_ATTR_ADDR6]\t=\n\t\tNLA_POLICY_EXACT_LEN(sizeof(struct in6_addr)),\n\t[MPTCP_PM_ADDR_ATTR_PORT]\t= { .type\t= NLA_U16\t},\n\t[MPTCP_PM_ADDR_ATTR_FLAGS]\t= { .type\t= NLA_U32\t},\n\t[MPTCP_PM_ADDR_ATTR_IF_IDX]     = { .type\t= NLA_S32\t},\n};\n\nstatic const struct nla_policy mptcp_pm_policy[MPTCP_PM_ATTR_MAX + 1] = {\n\t[MPTCP_PM_ATTR_ADDR]\t\t=\n\t\t\t\t\tNLA_POLICY_NESTED(mptcp_pm_addr_policy),\n\t[MPTCP_PM_ATTR_RCV_ADD_ADDRS]\t= { .type\t= NLA_U32,\t},\n\t[MPTCP_PM_ATTR_SUBFLOWS]\t= { .type\t= NLA_U32,\t},\n\t[MPTCP_PM_ATTR_TOKEN]\t\t= { .type\t= NLA_U32,\t},\n\t[MPTCP_PM_ATTR_LOC_ID]\t\t= { .type\t= NLA_U8,\t},\n\t[MPTCP_PM_ATTR_ADDR_REMOTE]\t=\n\t\t\t\t\tNLA_POLICY_NESTED(mptcp_pm_addr_policy),\n};\n\nvoid mptcp_pm_nl_subflow_chk_stale(const struct mptcp_sock *msk, struct sock *ssk)\n{\n\tstruct mptcp_subflow_context *iter, *subflow = mptcp_subflow_ctx(ssk);\n\tstruct sock *sk = (struct sock *)msk;\n\tunsigned int active_max_loss_cnt;\n\tstruct net *net = sock_net(sk);\n\tunsigned int stale_loss_cnt;\n\tbool slow;\n\n\tstale_loss_cnt = mptcp_stale_loss_cnt(net);\n\tif (subflow->stale || !stale_loss_cnt || subflow->stale_count <= stale_loss_cnt)\n\t\treturn;\n\n\t \n\tactive_max_loss_cnt = max_t(int, stale_loss_cnt - 1, 1);\n\tmptcp_for_each_subflow(msk, iter) {\n\t\tif (iter != subflow && mptcp_subflow_active(iter) &&\n\t\t    iter->stale_count < active_max_loss_cnt) {\n\t\t\t \n\t\t\tslow = lock_sock_fast(ssk);\n\t\t\tif (!tcp_rtx_and_write_queues_empty(ssk)) {\n\t\t\t\tsubflow->stale = 1;\n\t\t\t\t__mptcp_retransmit_pending_data(sk);\n\t\t\t\tMPTCP_INC_STATS(net, MPTCP_MIB_SUBFLOWSTALE);\n\t\t\t}\n\t\t\tunlock_sock_fast(ssk, slow);\n\n\t\t\t \n\t\t\t__mptcp_push_pending(sk, 0);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int mptcp_pm_family_to_addr(int family)\n{\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\tif (family == AF_INET6)\n\t\treturn MPTCP_PM_ADDR_ATTR_ADDR6;\n#endif\n\treturn MPTCP_PM_ADDR_ATTR_ADDR4;\n}\n\nstatic int mptcp_pm_parse_pm_addr_attr(struct nlattr *tb[],\n\t\t\t\t       const struct nlattr *attr,\n\t\t\t\t       struct genl_info *info,\n\t\t\t\t       struct mptcp_addr_info *addr,\n\t\t\t\t       bool require_family)\n{\n\tint err, addr_addr;\n\n\tif (!attr) {\n\t\tGENL_SET_ERR_MSG(info, \"missing address info\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = nla_parse_nested_deprecated(tb, MPTCP_PM_ADDR_ATTR_MAX, attr,\n\t\t\t\t\t  mptcp_pm_addr_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[MPTCP_PM_ADDR_ATTR_ID])\n\t\taddr->id = nla_get_u8(tb[MPTCP_PM_ADDR_ATTR_ID]);\n\n\tif (!tb[MPTCP_PM_ADDR_ATTR_FAMILY]) {\n\t\tif (!require_family)\n\t\t\treturn 0;\n\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, attr,\n\t\t\t\t    \"missing family\");\n\t\treturn -EINVAL;\n\t}\n\n\taddr->family = nla_get_u16(tb[MPTCP_PM_ADDR_ATTR_FAMILY]);\n\tif (addr->family != AF_INET\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\t    && addr->family != AF_INET6\n#endif\n\t    ) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, attr,\n\t\t\t\t    \"unknown address family\");\n\t\treturn -EINVAL;\n\t}\n\taddr_addr = mptcp_pm_family_to_addr(addr->family);\n\tif (!tb[addr_addr]) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, attr,\n\t\t\t\t    \"missing address data\");\n\t\treturn -EINVAL;\n\t}\n\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\tif (addr->family == AF_INET6)\n\t\taddr->addr6 = nla_get_in6_addr(tb[addr_addr]);\n\telse\n#endif\n\t\taddr->addr.s_addr = nla_get_in_addr(tb[addr_addr]);\n\n\tif (tb[MPTCP_PM_ADDR_ATTR_PORT])\n\t\taddr->port = htons(nla_get_u16(tb[MPTCP_PM_ADDR_ATTR_PORT]));\n\n\treturn 0;\n}\n\nint mptcp_pm_parse_addr(struct nlattr *attr, struct genl_info *info,\n\t\t\tstruct mptcp_addr_info *addr)\n{\n\tstruct nlattr *tb[MPTCP_PM_ADDR_ATTR_MAX + 1];\n\n\tmemset(addr, 0, sizeof(*addr));\n\n\treturn mptcp_pm_parse_pm_addr_attr(tb, attr, info, addr, true);\n}\n\nint mptcp_pm_parse_entry(struct nlattr *attr, struct genl_info *info,\n\t\t\t bool require_family,\n\t\t\t struct mptcp_pm_addr_entry *entry)\n{\n\tstruct nlattr *tb[MPTCP_PM_ADDR_ATTR_MAX + 1];\n\tint err;\n\n\tmemset(entry, 0, sizeof(*entry));\n\n\terr = mptcp_pm_parse_pm_addr_attr(tb, attr, info, &entry->addr, require_family);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[MPTCP_PM_ADDR_ATTR_IF_IDX]) {\n\t\tu32 val = nla_get_s32(tb[MPTCP_PM_ADDR_ATTR_IF_IDX]);\n\n\t\tentry->ifindex = val;\n\t}\n\n\tif (tb[MPTCP_PM_ADDR_ATTR_FLAGS])\n\t\tentry->flags = nla_get_u32(tb[MPTCP_PM_ADDR_ATTR_FLAGS]);\n\n\tif (tb[MPTCP_PM_ADDR_ATTR_PORT])\n\t\tentry->addr.port = htons(nla_get_u16(tb[MPTCP_PM_ADDR_ATTR_PORT]));\n\n\treturn 0;\n}\n\nstatic struct pm_nl_pernet *genl_info_pm_nl(struct genl_info *info)\n{\n\treturn pm_nl_get_pernet(genl_info_net(info));\n}\n\nstatic int mptcp_nl_add_subflow_or_signal_addr(struct net *net)\n{\n\tstruct mptcp_sock *msk;\n\tlong s_slot = 0, s_num = 0;\n\n\twhile ((msk = mptcp_token_iter_next(net, &s_slot, &s_num)) != NULL) {\n\t\tstruct sock *sk = (struct sock *)msk;\n\n\t\tif (!READ_ONCE(msk->fully_established) ||\n\t\t    mptcp_pm_is_userspace(msk))\n\t\t\tgoto next;\n\n\t\tlock_sock(sk);\n\t\tspin_lock_bh(&msk->pm.lock);\n\t\tmptcp_pm_create_subflow_or_signal_addr(msk);\n\t\tspin_unlock_bh(&msk->pm.lock);\n\t\trelease_sock(sk);\n\nnext:\n\t\tsock_put(sk);\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}\n\nstatic int mptcp_nl_cmd_add_addr(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attr = info->attrs[MPTCP_PM_ATTR_ADDR];\n\tstruct pm_nl_pernet *pernet = genl_info_pm_nl(info);\n\tstruct mptcp_pm_addr_entry addr, *entry;\n\tint ret;\n\n\tret = mptcp_pm_parse_entry(attr, info, true, &addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (addr.addr.port && !(addr.flags & MPTCP_PM_ADDR_FLAG_SIGNAL)) {\n\t\tGENL_SET_ERR_MSG(info, \"flags must have signal when using port\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (addr.flags & MPTCP_PM_ADDR_FLAG_SIGNAL &&\n\t    addr.flags & MPTCP_PM_ADDR_FLAG_FULLMESH) {\n\t\tGENL_SET_ERR_MSG(info, \"flags mustn't have both signal and fullmesh\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (addr.flags & MPTCP_PM_ADDR_FLAG_IMPLICIT) {\n\t\tGENL_SET_ERR_MSG(info, \"can't create IMPLICIT endpoint\");\n\t\treturn -EINVAL;\n\t}\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL_ACCOUNT);\n\tif (!entry) {\n\t\tGENL_SET_ERR_MSG(info, \"can't allocate addr\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*entry = addr;\n\tif (entry->addr.port) {\n\t\tret = mptcp_pm_nl_create_listen_socket(skb->sk, entry);\n\t\tif (ret) {\n\t\t\tGENL_SET_ERR_MSG_FMT(info, \"create listen socket error: %d\", ret);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\tret = mptcp_pm_nl_append_new_local_addr(pernet, entry);\n\tif (ret < 0) {\n\t\tGENL_SET_ERR_MSG_FMT(info, \"too many addresses or duplicate one: %d\", ret);\n\t\tgoto out_free;\n\t}\n\n\tmptcp_nl_add_subflow_or_signal_addr(sock_net(skb->sk));\n\treturn 0;\n\nout_free:\n\t__mptcp_pm_release_addr_entry(entry);\n\treturn ret;\n}\n\nint mptcp_pm_nl_get_flags_and_ifindex_by_id(struct mptcp_sock *msk, unsigned int id,\n\t\t\t\t\t    u8 *flags, int *ifindex)\n{\n\tstruct mptcp_pm_addr_entry *entry;\n\tstruct sock *sk = (struct sock *)msk;\n\tstruct net *net = sock_net(sk);\n\n\trcu_read_lock();\n\tentry = __lookup_addr_by_id(pm_nl_get_pernet(net), id);\n\tif (entry) {\n\t\t*flags = entry->flags;\n\t\t*ifindex = entry->ifindex;\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic bool remove_anno_list_by_saddr(struct mptcp_sock *msk,\n\t\t\t\t      const struct mptcp_addr_info *addr)\n{\n\tstruct mptcp_pm_add_entry *entry;\n\n\tentry = mptcp_pm_del_add_timer(msk, addr, false);\n\tif (entry) {\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool mptcp_pm_remove_anno_addr(struct mptcp_sock *msk,\n\t\t\t\t      const struct mptcp_addr_info *addr,\n\t\t\t\t      bool force)\n{\n\tstruct mptcp_rm_list list = { .nr = 0 };\n\tbool ret;\n\n\tlist.ids[list.nr++] = addr->id;\n\n\tret = remove_anno_list_by_saddr(msk, addr);\n\tif (ret || force) {\n\t\tspin_lock_bh(&msk->pm.lock);\n\t\tmptcp_pm_remove_addr(msk, &list);\n\t\tspin_unlock_bh(&msk->pm.lock);\n\t}\n\treturn ret;\n}\n\nstatic int mptcp_nl_remove_subflow_and_signal_addr(struct net *net,\n\t\t\t\t\t\t   const struct mptcp_pm_addr_entry *entry)\n{\n\tconst struct mptcp_addr_info *addr = &entry->addr;\n\tstruct mptcp_rm_list list = { .nr = 0 };\n\tlong s_slot = 0, s_num = 0;\n\tstruct mptcp_sock *msk;\n\n\tpr_debug(\"remove_id=%d\", addr->id);\n\n\tlist.ids[list.nr++] = addr->id;\n\n\twhile ((msk = mptcp_token_iter_next(net, &s_slot, &s_num)) != NULL) {\n\t\tstruct sock *sk = (struct sock *)msk;\n\t\tbool remove_subflow;\n\n\t\tif (mptcp_pm_is_userspace(msk))\n\t\t\tgoto next;\n\n\t\tif (list_empty(&msk->conn_list)) {\n\t\t\tmptcp_pm_remove_anno_addr(msk, addr, false);\n\t\t\tgoto next;\n\t\t}\n\n\t\tlock_sock(sk);\n\t\tremove_subflow = lookup_subflow_by_saddr(&msk->conn_list, addr);\n\t\tmptcp_pm_remove_anno_addr(msk, addr, remove_subflow &&\n\t\t\t\t\t  !(entry->flags & MPTCP_PM_ADDR_FLAG_IMPLICIT));\n\t\tif (remove_subflow)\n\t\t\tmptcp_pm_remove_subflow(msk, &list);\n\t\trelease_sock(sk);\n\nnext:\n\t\tsock_put(sk);\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}\n\nstatic int mptcp_nl_remove_id_zero_address(struct net *net,\n\t\t\t\t\t   struct mptcp_addr_info *addr)\n{\n\tstruct mptcp_rm_list list = { .nr = 0 };\n\tlong s_slot = 0, s_num = 0;\n\tstruct mptcp_sock *msk;\n\n\tlist.ids[list.nr++] = 0;\n\n\twhile ((msk = mptcp_token_iter_next(net, &s_slot, &s_num)) != NULL) {\n\t\tstruct sock *sk = (struct sock *)msk;\n\t\tstruct mptcp_addr_info msk_local;\n\n\t\tif (list_empty(&msk->conn_list) || mptcp_pm_is_userspace(msk))\n\t\t\tgoto next;\n\n\t\tmptcp_local_address((struct sock_common *)msk, &msk_local);\n\t\tif (!mptcp_addresses_equal(&msk_local, addr, addr->port))\n\t\t\tgoto next;\n\n\t\tlock_sock(sk);\n\t\tspin_lock_bh(&msk->pm.lock);\n\t\tmptcp_pm_remove_addr(msk, &list);\n\t\tmptcp_pm_nl_rm_subflow_received(msk, &list);\n\t\tspin_unlock_bh(&msk->pm.lock);\n\t\trelease_sock(sk);\n\nnext:\n\t\tsock_put(sk);\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}\n\nstatic int mptcp_nl_cmd_del_addr(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attr = info->attrs[MPTCP_PM_ATTR_ADDR];\n\tstruct pm_nl_pernet *pernet = genl_info_pm_nl(info);\n\tstruct mptcp_pm_addr_entry addr, *entry;\n\tunsigned int addr_max;\n\tint ret;\n\n\tret = mptcp_pm_parse_entry(attr, info, false, &addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (addr.addr.id == 0)\n\t\treturn mptcp_nl_remove_id_zero_address(sock_net(skb->sk), &addr.addr);\n\n\tspin_lock_bh(&pernet->lock);\n\tentry = __lookup_addr_by_id(pernet, addr.addr.id);\n\tif (!entry) {\n\t\tGENL_SET_ERR_MSG(info, \"address not found\");\n\t\tspin_unlock_bh(&pernet->lock);\n\t\treturn -EINVAL;\n\t}\n\tif (entry->flags & MPTCP_PM_ADDR_FLAG_SIGNAL) {\n\t\taddr_max = pernet->add_addr_signal_max;\n\t\tWRITE_ONCE(pernet->add_addr_signal_max, addr_max - 1);\n\t}\n\tif (entry->flags & MPTCP_PM_ADDR_FLAG_SUBFLOW) {\n\t\taddr_max = pernet->local_addr_max;\n\t\tWRITE_ONCE(pernet->local_addr_max, addr_max - 1);\n\t}\n\n\tpernet->addrs--;\n\tlist_del_rcu(&entry->list);\n\t__clear_bit(entry->addr.id, pernet->id_bitmap);\n\tspin_unlock_bh(&pernet->lock);\n\n\tmptcp_nl_remove_subflow_and_signal_addr(sock_net(skb->sk), entry);\n\tsynchronize_rcu();\n\t__mptcp_pm_release_addr_entry(entry);\n\n\treturn ret;\n}\n\nvoid mptcp_pm_remove_addrs(struct mptcp_sock *msk, struct list_head *rm_list)\n{\n\tstruct mptcp_rm_list alist = { .nr = 0 };\n\tstruct mptcp_pm_addr_entry *entry;\n\n\tlist_for_each_entry(entry, rm_list, list) {\n\t\tif ((remove_anno_list_by_saddr(msk, &entry->addr) ||\n\t\t     lookup_subflow_by_saddr(&msk->conn_list, &entry->addr)) &&\n\t\t    alist.nr < MPTCP_RM_IDS_MAX)\n\t\t\talist.ids[alist.nr++] = entry->addr.id;\n\t}\n\n\tif (alist.nr) {\n\t\tspin_lock_bh(&msk->pm.lock);\n\t\tmptcp_pm_remove_addr(msk, &alist);\n\t\tspin_unlock_bh(&msk->pm.lock);\n\t}\n}\n\nvoid mptcp_pm_remove_addrs_and_subflows(struct mptcp_sock *msk,\n\t\t\t\t\tstruct list_head *rm_list)\n{\n\tstruct mptcp_rm_list alist = { .nr = 0 }, slist = { .nr = 0 };\n\tstruct mptcp_pm_addr_entry *entry;\n\n\tlist_for_each_entry(entry, rm_list, list) {\n\t\tif (lookup_subflow_by_saddr(&msk->conn_list, &entry->addr) &&\n\t\t    slist.nr < MPTCP_RM_IDS_MAX)\n\t\t\tslist.ids[slist.nr++] = entry->addr.id;\n\n\t\tif (remove_anno_list_by_saddr(msk, &entry->addr) &&\n\t\t    alist.nr < MPTCP_RM_IDS_MAX)\n\t\t\talist.ids[alist.nr++] = entry->addr.id;\n\t}\n\n\tif (alist.nr) {\n\t\tspin_lock_bh(&msk->pm.lock);\n\t\tmptcp_pm_remove_addr(msk, &alist);\n\t\tspin_unlock_bh(&msk->pm.lock);\n\t}\n\tif (slist.nr)\n\t\tmptcp_pm_remove_subflow(msk, &slist);\n}\n\nstatic void mptcp_nl_remove_addrs_list(struct net *net,\n\t\t\t\t       struct list_head *rm_list)\n{\n\tlong s_slot = 0, s_num = 0;\n\tstruct mptcp_sock *msk;\n\n\tif (list_empty(rm_list))\n\t\treturn;\n\n\twhile ((msk = mptcp_token_iter_next(net, &s_slot, &s_num)) != NULL) {\n\t\tstruct sock *sk = (struct sock *)msk;\n\n\t\tif (!mptcp_pm_is_userspace(msk)) {\n\t\t\tlock_sock(sk);\n\t\t\tmptcp_pm_remove_addrs_and_subflows(msk, rm_list);\n\t\t\trelease_sock(sk);\n\t\t}\n\n\t\tsock_put(sk);\n\t\tcond_resched();\n\t}\n}\n\n \nstatic void __flush_addrs(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct mptcp_pm_addr_entry *cur;\n\n\t\tcur = list_entry(list->next,\n\t\t\t\t struct mptcp_pm_addr_entry, list);\n\t\tlist_del_rcu(&cur->list);\n\t\t__mptcp_pm_release_addr_entry(cur);\n\t}\n}\n\nstatic void __reset_counters(struct pm_nl_pernet *pernet)\n{\n\tWRITE_ONCE(pernet->add_addr_signal_max, 0);\n\tWRITE_ONCE(pernet->add_addr_accept_max, 0);\n\tWRITE_ONCE(pernet->local_addr_max, 0);\n\tpernet->addrs = 0;\n}\n\nstatic int mptcp_nl_cmd_flush_addrs(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct pm_nl_pernet *pernet = genl_info_pm_nl(info);\n\tLIST_HEAD(free_list);\n\n\tspin_lock_bh(&pernet->lock);\n\tlist_splice_init(&pernet->local_addr_list, &free_list);\n\t__reset_counters(pernet);\n\tpernet->next_id = 1;\n\tbitmap_zero(pernet->id_bitmap, MPTCP_PM_MAX_ADDR_ID + 1);\n\tspin_unlock_bh(&pernet->lock);\n\tmptcp_nl_remove_addrs_list(sock_net(skb->sk), &free_list);\n\tsynchronize_rcu();\n\t__flush_addrs(&free_list);\n\treturn 0;\n}\n\nstatic int mptcp_nl_fill_addr(struct sk_buff *skb,\n\t\t\t      struct mptcp_pm_addr_entry *entry)\n{\n\tstruct mptcp_addr_info *addr = &entry->addr;\n\tstruct nlattr *attr;\n\n\tattr = nla_nest_start(skb, MPTCP_PM_ATTR_ADDR);\n\tif (!attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u16(skb, MPTCP_PM_ADDR_ATTR_FAMILY, addr->family))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(skb, MPTCP_PM_ADDR_ATTR_PORT, ntohs(addr->port)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb, MPTCP_PM_ADDR_ATTR_ID, addr->id))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, MPTCP_PM_ADDR_ATTR_FLAGS, entry->flags))\n\t\tgoto nla_put_failure;\n\tif (entry->ifindex &&\n\t    nla_put_s32(skb, MPTCP_PM_ADDR_ATTR_IF_IDX, entry->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (addr->family == AF_INET &&\n\t    nla_put_in_addr(skb, MPTCP_PM_ADDR_ATTR_ADDR4,\n\t\t\t    addr->addr.s_addr))\n\t\tgoto nla_put_failure;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\telse if (addr->family == AF_INET6 &&\n\t\t nla_put_in6_addr(skb, MPTCP_PM_ADDR_ATTR_ADDR6, &addr->addr6))\n\t\tgoto nla_put_failure;\n#endif\n\tnla_nest_end(skb, attr);\n\treturn 0;\n\nnla_put_failure:\n\tnla_nest_cancel(skb, attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int mptcp_nl_cmd_get_addr(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attr = info->attrs[MPTCP_PM_ATTR_ADDR];\n\tstruct pm_nl_pernet *pernet = genl_info_pm_nl(info);\n\tstruct mptcp_pm_addr_entry addr, *entry;\n\tstruct sk_buff *msg;\n\tvoid *reply;\n\tint ret;\n\n\tret = mptcp_pm_parse_entry(attr, info, false, &addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\treply = genlmsg_put_reply(msg, info, &mptcp_genl_family, 0,\n\t\t\t\t  info->genlhdr->cmd);\n\tif (!reply) {\n\t\tGENL_SET_ERR_MSG(info, \"not enough space in Netlink message\");\n\t\tret = -EMSGSIZE;\n\t\tgoto fail;\n\t}\n\n\tspin_lock_bh(&pernet->lock);\n\tentry = __lookup_addr_by_id(pernet, addr.addr.id);\n\tif (!entry) {\n\t\tGENL_SET_ERR_MSG(info, \"address not found\");\n\t\tret = -EINVAL;\n\t\tgoto unlock_fail;\n\t}\n\n\tret = mptcp_nl_fill_addr(msg, entry);\n\tif (ret)\n\t\tgoto unlock_fail;\n\n\tgenlmsg_end(msg, reply);\n\tret = genlmsg_reply(msg, info);\n\tspin_unlock_bh(&pernet->lock);\n\treturn ret;\n\nunlock_fail:\n\tspin_unlock_bh(&pernet->lock);\n\nfail:\n\tnlmsg_free(msg);\n\treturn ret;\n}\n\nstatic int mptcp_nl_cmd_dump_addrs(struct sk_buff *msg,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(msg->sk);\n\tstruct mptcp_pm_addr_entry *entry;\n\tstruct pm_nl_pernet *pernet;\n\tint id = cb->args[0];\n\tvoid *hdr;\n\tint i;\n\n\tpernet = pm_nl_get_pernet(net);\n\n\tspin_lock_bh(&pernet->lock);\n\tfor (i = id; i < MPTCP_PM_MAX_ADDR_ID + 1; i++) {\n\t\tif (test_bit(i, pernet->id_bitmap)) {\n\t\t\tentry = __lookup_addr_by_id(pernet, i);\n\t\t\tif (!entry)\n\t\t\t\tbreak;\n\n\t\t\tif (entry->addr.id <= id)\n\t\t\t\tcontinue;\n\n\t\t\thdr = genlmsg_put(msg, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t  cb->nlh->nlmsg_seq, &mptcp_genl_family,\n\t\t\t\t\t  NLM_F_MULTI, MPTCP_PM_CMD_GET_ADDR);\n\t\t\tif (!hdr)\n\t\t\t\tbreak;\n\n\t\t\tif (mptcp_nl_fill_addr(msg, entry) < 0) {\n\t\t\t\tgenlmsg_cancel(msg, hdr);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tid = entry->addr.id;\n\t\t\tgenlmsg_end(msg, hdr);\n\t\t}\n\t}\n\tspin_unlock_bh(&pernet->lock);\n\n\tcb->args[0] = id;\n\treturn msg->len;\n}\n\nstatic int parse_limit(struct genl_info *info, int id, unsigned int *limit)\n{\n\tstruct nlattr *attr = info->attrs[id];\n\n\tif (!attr)\n\t\treturn 0;\n\n\t*limit = nla_get_u32(attr);\n\tif (*limit > MPTCP_PM_ADDR_MAX) {\n\t\tGENL_SET_ERR_MSG(info, \"limit greater than maximum\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int\nmptcp_nl_cmd_set_limits(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct pm_nl_pernet *pernet = genl_info_pm_nl(info);\n\tunsigned int rcv_addrs, subflows;\n\tint ret;\n\n\tspin_lock_bh(&pernet->lock);\n\trcv_addrs = pernet->add_addr_accept_max;\n\tret = parse_limit(info, MPTCP_PM_ATTR_RCV_ADD_ADDRS, &rcv_addrs);\n\tif (ret)\n\t\tgoto unlock;\n\n\tsubflows = pernet->subflows_max;\n\tret = parse_limit(info, MPTCP_PM_ATTR_SUBFLOWS, &subflows);\n\tif (ret)\n\t\tgoto unlock;\n\n\tWRITE_ONCE(pernet->add_addr_accept_max, rcv_addrs);\n\tWRITE_ONCE(pernet->subflows_max, subflows);\n\nunlock:\n\tspin_unlock_bh(&pernet->lock);\n\treturn ret;\n}\n\nstatic int\nmptcp_nl_cmd_get_limits(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct pm_nl_pernet *pernet = genl_info_pm_nl(info);\n\tstruct sk_buff *msg;\n\tvoid *reply;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\treply = genlmsg_put_reply(msg, info, &mptcp_genl_family, 0,\n\t\t\t\t  MPTCP_PM_CMD_GET_LIMITS);\n\tif (!reply)\n\t\tgoto fail;\n\n\tif (nla_put_u32(msg, MPTCP_PM_ATTR_RCV_ADD_ADDRS,\n\t\t\tREAD_ONCE(pernet->add_addr_accept_max)))\n\t\tgoto fail;\n\n\tif (nla_put_u32(msg, MPTCP_PM_ATTR_SUBFLOWS,\n\t\t\tREAD_ONCE(pernet->subflows_max)))\n\t\tgoto fail;\n\n\tgenlmsg_end(msg, reply);\n\treturn genlmsg_reply(msg, info);\n\nfail:\n\tGENL_SET_ERR_MSG(info, \"not enough space in Netlink message\");\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic void mptcp_pm_nl_fullmesh(struct mptcp_sock *msk,\n\t\t\t\t struct mptcp_addr_info *addr)\n{\n\tstruct mptcp_rm_list list = { .nr = 0 };\n\n\tlist.ids[list.nr++] = addr->id;\n\n\tspin_lock_bh(&msk->pm.lock);\n\tmptcp_pm_nl_rm_subflow_received(msk, &list);\n\tmptcp_pm_create_subflow_or_signal_addr(msk);\n\tspin_unlock_bh(&msk->pm.lock);\n}\n\nstatic int mptcp_nl_set_flags(struct net *net,\n\t\t\t      struct mptcp_addr_info *addr,\n\t\t\t      u8 bkup, u8 changed)\n{\n\tlong s_slot = 0, s_num = 0;\n\tstruct mptcp_sock *msk;\n\tint ret = -EINVAL;\n\n\twhile ((msk = mptcp_token_iter_next(net, &s_slot, &s_num)) != NULL) {\n\t\tstruct sock *sk = (struct sock *)msk;\n\n\t\tif (list_empty(&msk->conn_list) || mptcp_pm_is_userspace(msk))\n\t\t\tgoto next;\n\n\t\tlock_sock(sk);\n\t\tif (changed & MPTCP_PM_ADDR_FLAG_BACKUP)\n\t\t\tret = mptcp_pm_nl_mp_prio_send_ack(msk, addr, NULL, bkup);\n\t\tif (changed & MPTCP_PM_ADDR_FLAG_FULLMESH)\n\t\t\tmptcp_pm_nl_fullmesh(msk, addr);\n\t\trelease_sock(sk);\n\nnext:\n\t\tsock_put(sk);\n\t\tcond_resched();\n\t}\n\n\treturn ret;\n}\n\nint mptcp_pm_nl_set_flags(struct net *net, struct mptcp_pm_addr_entry *addr, u8 bkup)\n{\n\tstruct pm_nl_pernet *pernet = pm_nl_get_pernet(net);\n\tu8 changed, mask = MPTCP_PM_ADDR_FLAG_BACKUP |\n\t\t\t   MPTCP_PM_ADDR_FLAG_FULLMESH;\n\tstruct mptcp_pm_addr_entry *entry;\n\tu8 lookup_by_id = 0;\n\n\tif (addr->addr.family == AF_UNSPEC) {\n\t\tlookup_by_id = 1;\n\t\tif (!addr->addr.id)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tspin_lock_bh(&pernet->lock);\n\tentry = __lookup_addr(pernet, &addr->addr, lookup_by_id);\n\tif (!entry) {\n\t\tspin_unlock_bh(&pernet->lock);\n\t\treturn -EINVAL;\n\t}\n\tif ((addr->flags & MPTCP_PM_ADDR_FLAG_FULLMESH) &&\n\t    (entry->flags & MPTCP_PM_ADDR_FLAG_SIGNAL)) {\n\t\tspin_unlock_bh(&pernet->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tchanged = (addr->flags ^ entry->flags) & mask;\n\tentry->flags = (entry->flags & ~mask) | (addr->flags & mask);\n\t*addr = *entry;\n\tspin_unlock_bh(&pernet->lock);\n\n\tmptcp_nl_set_flags(net, &addr->addr, bkup, changed);\n\treturn 0;\n}\n\nstatic int mptcp_nl_cmd_set_flags(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct mptcp_pm_addr_entry remote = { .addr = { .family = AF_UNSPEC }, };\n\tstruct mptcp_pm_addr_entry addr = { .addr = { .family = AF_UNSPEC }, };\n\tstruct nlattr *attr_rem = info->attrs[MPTCP_PM_ATTR_ADDR_REMOTE];\n\tstruct nlattr *token = info->attrs[MPTCP_PM_ATTR_TOKEN];\n\tstruct nlattr *attr = info->attrs[MPTCP_PM_ATTR_ADDR];\n\tstruct net *net = sock_net(skb->sk);\n\tu8 bkup = 0;\n\tint ret;\n\n\tret = mptcp_pm_parse_entry(attr, info, false, &addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (attr_rem) {\n\t\tret = mptcp_pm_parse_entry(attr_rem, info, false, &remote);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (addr.flags & MPTCP_PM_ADDR_FLAG_BACKUP)\n\t\tbkup = 1;\n\n\treturn mptcp_pm_set_flags(net, token, &addr, &remote, bkup);\n}\n\nstatic void mptcp_nl_mcast_send(struct net *net, struct sk_buff *nlskb, gfp_t gfp)\n{\n\tgenlmsg_multicast_netns(&mptcp_genl_family, net,\n\t\t\t\tnlskb, 0, MPTCP_PM_EV_GRP_OFFSET, gfp);\n}\n\nbool mptcp_userspace_pm_active(const struct mptcp_sock *msk)\n{\n\treturn genl_has_listeners(&mptcp_genl_family,\n\t\t\t\t  sock_net((const struct sock *)msk),\n\t\t\t\t  MPTCP_PM_EV_GRP_OFFSET);\n}\n\nstatic int mptcp_event_add_subflow(struct sk_buff *skb, const struct sock *ssk)\n{\n\tconst struct inet_sock *issk = inet_sk(ssk);\n\tconst struct mptcp_subflow_context *sf;\n\n\tif (nla_put_u16(skb, MPTCP_ATTR_FAMILY, ssk->sk_family))\n\t\treturn -EMSGSIZE;\n\n\tswitch (ssk->sk_family) {\n\tcase AF_INET:\n\t\tif (nla_put_in_addr(skb, MPTCP_ATTR_SADDR4, issk->inet_saddr))\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_in_addr(skb, MPTCP_ATTR_DADDR4, issk->inet_daddr))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\tcase AF_INET6: {\n\t\tconst struct ipv6_pinfo *np = inet6_sk(ssk);\n\n\t\tif (nla_put_in6_addr(skb, MPTCP_ATTR_SADDR6, &np->saddr))\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_in6_addr(skb, MPTCP_ATTR_DADDR6, &ssk->sk_v6_daddr))\n\t\t\treturn -EMSGSIZE;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (nla_put_be16(skb, MPTCP_ATTR_SPORT, issk->inet_sport))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_be16(skb, MPTCP_ATTR_DPORT, issk->inet_dport))\n\t\treturn -EMSGSIZE;\n\n\tsf = mptcp_subflow_ctx(ssk);\n\tif (WARN_ON_ONCE(!sf))\n\t\treturn -EINVAL;\n\n\tif (nla_put_u8(skb, MPTCP_ATTR_LOC_ID, sf->local_id))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u8(skb, MPTCP_ATTR_REM_ID, sf->remote_id))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int mptcp_event_put_token_and_ssk(struct sk_buff *skb,\n\t\t\t\t\t const struct mptcp_sock *msk,\n\t\t\t\t\t const struct sock *ssk)\n{\n\tconst struct sock *sk = (const struct sock *)msk;\n\tconst struct mptcp_subflow_context *sf;\n\tu8 sk_err;\n\n\tif (nla_put_u32(skb, MPTCP_ATTR_TOKEN, msk->token))\n\t\treturn -EMSGSIZE;\n\n\tif (mptcp_event_add_subflow(skb, ssk))\n\t\treturn -EMSGSIZE;\n\n\tsf = mptcp_subflow_ctx(ssk);\n\tif (WARN_ON_ONCE(!sf))\n\t\treturn -EINVAL;\n\n\tif (nla_put_u8(skb, MPTCP_ATTR_BACKUP, sf->backup))\n\t\treturn -EMSGSIZE;\n\n\tif (ssk->sk_bound_dev_if &&\n\t    nla_put_s32(skb, MPTCP_ATTR_IF_IDX, ssk->sk_bound_dev_if))\n\t\treturn -EMSGSIZE;\n\n\tsk_err = READ_ONCE(ssk->sk_err);\n\tif (sk_err && sk->sk_state == TCP_ESTABLISHED &&\n\t    nla_put_u8(skb, MPTCP_ATTR_ERROR, sk_err))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int mptcp_event_sub_established(struct sk_buff *skb,\n\t\t\t\t       const struct mptcp_sock *msk,\n\t\t\t\t       const struct sock *ssk)\n{\n\treturn mptcp_event_put_token_and_ssk(skb, msk, ssk);\n}\n\nstatic int mptcp_event_sub_closed(struct sk_buff *skb,\n\t\t\t\t  const struct mptcp_sock *msk,\n\t\t\t\t  const struct sock *ssk)\n{\n\tconst struct mptcp_subflow_context *sf;\n\n\tif (mptcp_event_put_token_and_ssk(skb, msk, ssk))\n\t\treturn -EMSGSIZE;\n\n\tsf = mptcp_subflow_ctx(ssk);\n\tif (!sf->reset_seen)\n\t\treturn 0;\n\n\tif (nla_put_u32(skb, MPTCP_ATTR_RESET_REASON, sf->reset_reason))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, MPTCP_ATTR_RESET_FLAGS, sf->reset_transient))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int mptcp_event_created(struct sk_buff *skb,\n\t\t\t       const struct mptcp_sock *msk,\n\t\t\t       const struct sock *ssk)\n{\n\tint err = nla_put_u32(skb, MPTCP_ATTR_TOKEN, msk->token);\n\n\tif (err)\n\t\treturn err;\n\n\tif (nla_put_u8(skb, MPTCP_ATTR_SERVER_SIDE, READ_ONCE(msk->pm.server_side)))\n\t\treturn -EMSGSIZE;\n\n\treturn mptcp_event_add_subflow(skb, ssk);\n}\n\nvoid mptcp_event_addr_removed(const struct mptcp_sock *msk, uint8_t id)\n{\n\tstruct net *net = sock_net((const struct sock *)msk);\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\n\tif (!genl_has_listeners(&mptcp_genl_family, net, MPTCP_PM_EV_GRP_OFFSET))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tnlh = genlmsg_put(skb, 0, 0, &mptcp_genl_family, 0, MPTCP_EVENT_REMOVED);\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, MPTCP_ATTR_TOKEN, msk->token))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, MPTCP_ATTR_REM_ID, id))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(skb, nlh);\n\tmptcp_nl_mcast_send(net, skb, GFP_ATOMIC);\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(skb);\n}\n\nvoid mptcp_event_addr_announced(const struct sock *ssk,\n\t\t\t\tconst struct mptcp_addr_info *info)\n{\n\tstruct mptcp_subflow_context *subflow = mptcp_subflow_ctx(ssk);\n\tstruct mptcp_sock *msk = mptcp_sk(subflow->conn);\n\tstruct net *net = sock_net(ssk);\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\n\tif (!genl_has_listeners(&mptcp_genl_family, net, MPTCP_PM_EV_GRP_OFFSET))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tnlh = genlmsg_put(skb, 0, 0, &mptcp_genl_family, 0,\n\t\t\t  MPTCP_EVENT_ANNOUNCED);\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, MPTCP_ATTR_TOKEN, msk->token))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, MPTCP_ATTR_REM_ID, info->id))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be16(skb, MPTCP_ATTR_DPORT,\n\t\t\t info->port == 0 ?\n\t\t\t inet_sk(ssk)->inet_dport :\n\t\t\t info->port))\n\t\tgoto nla_put_failure;\n\n\tswitch (info->family) {\n\tcase AF_INET:\n\t\tif (nla_put_in_addr(skb, MPTCP_ATTR_DADDR4, info->addr.s_addr))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\tcase AF_INET6:\n\t\tif (nla_put_in6_addr(skb, MPTCP_ATTR_DADDR6, &info->addr6))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(skb, nlh);\n\tmptcp_nl_mcast_send(net, skb, GFP_ATOMIC);\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(skb);\n}\n\nvoid mptcp_event_pm_listener(const struct sock *ssk,\n\t\t\t     enum mptcp_event_type event)\n{\n\tconst struct inet_sock *issk = inet_sk(ssk);\n\tstruct net *net = sock_net(ssk);\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\n\tif (!genl_has_listeners(&mptcp_genl_family, net, MPTCP_PM_EV_GRP_OFFSET))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn;\n\n\tnlh = genlmsg_put(skb, 0, 0, &mptcp_genl_family, 0, event);\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u16(skb, MPTCP_ATTR_FAMILY, ssk->sk_family))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be16(skb, MPTCP_ATTR_SPORT, issk->inet_sport))\n\t\tgoto nla_put_failure;\n\n\tswitch (ssk->sk_family) {\n\tcase AF_INET:\n\t\tif (nla_put_in_addr(skb, MPTCP_ATTR_SADDR4, issk->inet_saddr))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_MPTCP_IPV6)\n\tcase AF_INET6: {\n\t\tconst struct ipv6_pinfo *np = inet6_sk(ssk);\n\n\t\tif (nla_put_in6_addr(skb, MPTCP_ATTR_SADDR6, &np->saddr))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(skb, nlh);\n\tmptcp_nl_mcast_send(net, skb, GFP_KERNEL);\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(skb);\n}\n\nvoid mptcp_event(enum mptcp_event_type type, const struct mptcp_sock *msk,\n\t\t const struct sock *ssk, gfp_t gfp)\n{\n\tstruct net *net = sock_net((const struct sock *)msk);\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\n\tif (!genl_has_listeners(&mptcp_genl_family, net, MPTCP_PM_EV_GRP_OFFSET))\n\t\treturn;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!skb)\n\t\treturn;\n\n\tnlh = genlmsg_put(skb, 0, 0, &mptcp_genl_family, 0, type);\n\tif (!nlh)\n\t\tgoto nla_put_failure;\n\n\tswitch (type) {\n\tcase MPTCP_EVENT_UNSPEC:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\tcase MPTCP_EVENT_CREATED:\n\tcase MPTCP_EVENT_ESTABLISHED:\n\t\tif (mptcp_event_created(skb, msk, ssk) < 0)\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase MPTCP_EVENT_CLOSED:\n\t\tif (nla_put_u32(skb, MPTCP_ATTR_TOKEN, msk->token) < 0)\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase MPTCP_EVENT_ANNOUNCED:\n\tcase MPTCP_EVENT_REMOVED:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\tcase MPTCP_EVENT_SUB_ESTABLISHED:\n\tcase MPTCP_EVENT_SUB_PRIORITY:\n\t\tif (mptcp_event_sub_established(skb, msk, ssk) < 0)\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase MPTCP_EVENT_SUB_CLOSED:\n\t\tif (mptcp_event_sub_closed(skb, msk, ssk) < 0)\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase MPTCP_EVENT_LISTENER_CREATED:\n\tcase MPTCP_EVENT_LISTENER_CLOSED:\n\t\tbreak;\n\t}\n\n\tgenlmsg_end(skb, nlh);\n\tmptcp_nl_mcast_send(net, skb, gfp);\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(skb);\n}\n\nstatic const struct genl_small_ops mptcp_pm_ops[] = {\n\t{\n\t\t.cmd    = MPTCP_PM_CMD_ADD_ADDR,\n\t\t.doit   = mptcp_nl_cmd_add_addr,\n\t\t.flags  = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd    = MPTCP_PM_CMD_DEL_ADDR,\n\t\t.doit   = mptcp_nl_cmd_del_addr,\n\t\t.flags  = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd    = MPTCP_PM_CMD_FLUSH_ADDRS,\n\t\t.doit   = mptcp_nl_cmd_flush_addrs,\n\t\t.flags  = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd    = MPTCP_PM_CMD_GET_ADDR,\n\t\t.doit   = mptcp_nl_cmd_get_addr,\n\t\t.dumpit   = mptcp_nl_cmd_dump_addrs,\n\t},\n\t{\n\t\t.cmd    = MPTCP_PM_CMD_SET_LIMITS,\n\t\t.doit   = mptcp_nl_cmd_set_limits,\n\t\t.flags  = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd    = MPTCP_PM_CMD_GET_LIMITS,\n\t\t.doit   = mptcp_nl_cmd_get_limits,\n\t},\n\t{\n\t\t.cmd    = MPTCP_PM_CMD_SET_FLAGS,\n\t\t.doit   = mptcp_nl_cmd_set_flags,\n\t\t.flags  = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd    = MPTCP_PM_CMD_ANNOUNCE,\n\t\t.doit   = mptcp_nl_cmd_announce,\n\t\t.flags  = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd    = MPTCP_PM_CMD_REMOVE,\n\t\t.doit   = mptcp_nl_cmd_remove,\n\t\t.flags  = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd    = MPTCP_PM_CMD_SUBFLOW_CREATE,\n\t\t.doit   = mptcp_nl_cmd_sf_create,\n\t\t.flags  = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd    = MPTCP_PM_CMD_SUBFLOW_DESTROY,\n\t\t.doit   = mptcp_nl_cmd_sf_destroy,\n\t\t.flags  = GENL_UNS_ADMIN_PERM,\n\t},\n};\n\nstatic struct genl_family mptcp_genl_family __ro_after_init = {\n\t.name\t\t= MPTCP_PM_NAME,\n\t.version\t= MPTCP_PM_VER,\n\t.maxattr\t= MPTCP_PM_ATTR_MAX,\n\t.policy\t\t= mptcp_pm_policy,\n\t.netnsok\t= true,\n\t.module\t\t= THIS_MODULE,\n\t.small_ops\t= mptcp_pm_ops,\n\t.n_small_ops\t= ARRAY_SIZE(mptcp_pm_ops),\n\t.resv_start_op\t= MPTCP_PM_CMD_SUBFLOW_DESTROY + 1,\n\t.mcgrps\t\t= mptcp_pm_mcgrps,\n\t.n_mcgrps\t= ARRAY_SIZE(mptcp_pm_mcgrps),\n};\n\nstatic int __net_init pm_nl_init_net(struct net *net)\n{\n\tstruct pm_nl_pernet *pernet = pm_nl_get_pernet(net);\n\n\tINIT_LIST_HEAD_RCU(&pernet->local_addr_list);\n\n\t \n\tpernet->subflows_max = 2;\n\tpernet->next_id = 1;\n\tpernet->stale_loss_cnt = 4;\n\tspin_lock_init(&pernet->lock);\n\n\t \n\n\treturn 0;\n}\n\nstatic void __net_exit pm_nl_exit_net(struct list_head *net_list)\n{\n\tstruct net *net;\n\n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\tstruct pm_nl_pernet *pernet = pm_nl_get_pernet(net);\n\n\t\t \n\t\t__flush_addrs(&pernet->local_addr_list);\n\t}\n}\n\nstatic struct pernet_operations mptcp_pm_pernet_ops = {\n\t.init = pm_nl_init_net,\n\t.exit_batch = pm_nl_exit_net,\n\t.id = &pm_nl_pernet_id,\n\t.size = sizeof(struct pm_nl_pernet),\n};\n\nvoid __init mptcp_pm_nl_init(void)\n{\n\tif (register_pernet_subsys(&mptcp_pm_pernet_ops) < 0)\n\t\tpanic(\"Failed to register MPTCP PM pernet subsystem.\\n\");\n\n\tif (genl_register_family(&mptcp_genl_family))\n\t\tpanic(\"Failed to register MPTCP PM netlink family\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}