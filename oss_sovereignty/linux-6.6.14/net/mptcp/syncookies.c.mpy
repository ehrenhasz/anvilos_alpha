{
  "module_name": "syncookies.c",
  "hash_id": "6b75f9c71c58cd27380ef9a8272c8ae1d8bdbd4efc3941d4f9fe3494f3dbd080",
  "original_prompt": "Ingested from linux-6.6.14/net/mptcp/syncookies.c",
  "human_readable_source": "\n#include <linux/skbuff.h>\n\n#include \"protocol.h\"\n\n \n\nstruct join_entry {\n\tu32 token;\n\tu32 remote_nonce;\n\tu32 local_nonce;\n\tu8 join_id;\n\tu8 local_id;\n\tu8 backup;\n\tu8 valid;\n};\n\n#define COOKIE_JOIN_SLOTS\t1024\n\nstatic struct join_entry join_entries[COOKIE_JOIN_SLOTS] __cacheline_aligned_in_smp;\nstatic spinlock_t join_entry_locks[COOKIE_JOIN_SLOTS] __cacheline_aligned_in_smp;\n\nstatic u32 mptcp_join_entry_hash(struct sk_buff *skb, struct net *net)\n{\n\tstatic u32 mptcp_join_hash_secret __read_mostly;\n\tstruct tcphdr *th = tcp_hdr(skb);\n\tu32 seq, i;\n\n\tnet_get_random_once(&mptcp_join_hash_secret,\n\t\t\t    sizeof(mptcp_join_hash_secret));\n\n\tif (th->syn)\n\t\tseq = TCP_SKB_CB(skb)->seq;\n\telse\n\t\tseq = TCP_SKB_CB(skb)->seq - 1;\n\n\ti = jhash_3words(seq, net_hash_mix(net),\n\t\t\t (__force __u32)th->source << 16 | (__force __u32)th->dest,\n\t\t\t mptcp_join_hash_secret);\n\n\treturn i % ARRAY_SIZE(join_entries);\n}\n\nstatic void mptcp_join_store_state(struct join_entry *entry,\n\t\t\t\t   const struct mptcp_subflow_request_sock *subflow_req)\n{\n\tentry->token = subflow_req->token;\n\tentry->remote_nonce = subflow_req->remote_nonce;\n\tentry->local_nonce = subflow_req->local_nonce;\n\tentry->backup = subflow_req->backup;\n\tentry->join_id = subflow_req->remote_id;\n\tentry->local_id = subflow_req->local_id;\n\tentry->valid = 1;\n}\n\nvoid subflow_init_req_cookie_join_save(const struct mptcp_subflow_request_sock *subflow_req,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct net *net = read_pnet(&subflow_req->sk.req.ireq_net);\n\tu32 i = mptcp_join_entry_hash(skb, net);\n\n\t \n\tspin_lock_bh(&join_entry_locks[i]);\n\tmptcp_join_store_state(&join_entries[i], subflow_req);\n\tspin_unlock_bh(&join_entry_locks[i]);\n}\n\n \nbool mptcp_token_join_cookie_init_state(struct mptcp_subflow_request_sock *subflow_req,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct net *net = read_pnet(&subflow_req->sk.req.ireq_net);\n\tu32 i = mptcp_join_entry_hash(skb, net);\n\tstruct mptcp_sock *msk;\n\tstruct join_entry *e;\n\n\te = &join_entries[i];\n\n\tspin_lock_bh(&join_entry_locks[i]);\n\n\tif (e->valid == 0) {\n\t\tspin_unlock_bh(&join_entry_locks[i]);\n\t\treturn false;\n\t}\n\n\te->valid = 0;\n\n\tmsk = mptcp_token_get_sock(net, e->token);\n\tif (!msk) {\n\t\tspin_unlock_bh(&join_entry_locks[i]);\n\t\treturn false;\n\t}\n\n\tsubflow_req->remote_nonce = e->remote_nonce;\n\tsubflow_req->local_nonce = e->local_nonce;\n\tsubflow_req->backup = e->backup;\n\tsubflow_req->remote_id = e->join_id;\n\tsubflow_req->token = e->token;\n\tsubflow_req->msk = msk;\n\tspin_unlock_bh(&join_entry_locks[i]);\n\treturn true;\n}\n\nvoid __init mptcp_join_cookie_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < COOKIE_JOIN_SLOTS; i++)\n\t\tspin_lock_init(&join_entry_locks[i]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}