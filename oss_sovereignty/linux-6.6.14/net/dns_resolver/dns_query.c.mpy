{
  "module_name": "dns_query.c",
  "hash_id": "f30d98848cc42d3b10e0eebf2ec2d05fa97ae95aa627b9a99f0bbfbca1bbfbdd",
  "original_prompt": "Ingested from linux-6.6.14/net/dns_resolver/dns_query.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/dns_resolver.h>\n#include <linux/err.h>\n#include <net/net_namespace.h>\n\n#include <keys/dns_resolver-type.h>\n#include <keys/user-type.h>\n\n#include \"internal.h\"\n\n \nint dns_query(struct net *net,\n\t      const char *type, const char *name, size_t namelen,\n\t      const char *options, char **_result, time64_t *_expiry,\n\t      bool invalidate)\n{\n\tstruct key *rkey;\n\tstruct user_key_payload *upayload;\n\tconst struct cred *saved_cred;\n\tsize_t typelen, desclen;\n\tchar *desc, *cp;\n\tint ret, len;\n\n\tkenter(\"%s,%*.*s,%zu,%s\",\n\t       type, (int)namelen, (int)namelen, name, namelen, options);\n\n\tif (!name || namelen == 0)\n\t\treturn -EINVAL;\n\n\t \n\ttypelen = 0;\n\tdesclen = 0;\n\tif (type) {\n\t\ttypelen = strlen(type);\n\t\tif (typelen < 1)\n\t\t\treturn -EINVAL;\n\t\tdesclen += typelen + 1;\n\t}\n\n\tif (namelen < 3 || namelen > 255)\n\t\treturn -EINVAL;\n\tdesclen += namelen + 1;\n\n\tdesc = kmalloc(desclen, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tcp = desc;\n\tif (type) {\n\t\tmemcpy(cp, type, typelen);\n\t\tcp += typelen;\n\t\t*cp++ = ':';\n\t}\n\tmemcpy(cp, name, namelen);\n\tcp += namelen;\n\t*cp = '\\0';\n\n\tif (!options)\n\t\toptions = \"\";\n\tkdebug(\"call request_key(,%s,%s)\", desc, options);\n\n\t \n\tsaved_cred = override_creds(dns_resolver_cache);\n\trkey = request_key_net(&key_type_dns_resolver, desc, net, options);\n\trevert_creds(saved_cred);\n\tkfree(desc);\n\tif (IS_ERR(rkey)) {\n\t\tret = PTR_ERR(rkey);\n\t\tgoto out;\n\t}\n\n\tdown_read(&rkey->sem);\n\tset_bit(KEY_FLAG_ROOT_CAN_INVAL, &rkey->flags);\n\trkey->perm |= KEY_USR_VIEW;\n\n\tret = key_validate(rkey);\n\tif (ret < 0)\n\t\tgoto put;\n\n\t \n\tret = PTR_ERR(rkey->payload.data[dns_key_error]);\n\tif (ret)\n\t\tgoto put;\n\n\tupayload = user_key_payload_locked(rkey);\n\tlen = upayload->datalen;\n\n\tif (_result) {\n\t\tret = -ENOMEM;\n\t\t*_result = kmemdup_nul(upayload->data, len, GFP_KERNEL);\n\t\tif (!*_result)\n\t\t\tgoto put;\n\t}\n\n\tif (_expiry)\n\t\t*_expiry = rkey->expiry;\n\n\tret = len;\nput:\n\tup_read(&rkey->sem);\n\tif (invalidate)\n\t\tkey_invalidate(rkey);\n\tkey_put(rkey);\nout:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(dns_query);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}