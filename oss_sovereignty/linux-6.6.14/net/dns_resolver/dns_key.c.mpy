{
  "module_name": "dns_key.c",
  "hash_id": "ccf1847580e37bed9af887f579b6e5b32355f15cbfede46fa9a05e18f882c21f",
  "original_prompt": "Ingested from linux-6.6.14/net/dns_resolver/dns_key.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/keyctl.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/dns_resolver.h>\n#include <keys/dns_resolver-type.h>\n#include <keys/user-type.h>\n#include \"internal.h\"\n\nMODULE_DESCRIPTION(\"DNS Resolver\");\nMODULE_AUTHOR(\"Wang Lei\");\nMODULE_LICENSE(\"GPL\");\n\nunsigned int dns_resolver_debug;\nmodule_param_named(debug, dns_resolver_debug, uint, 0644);\nMODULE_PARM_DESC(debug, \"DNS Resolver debugging mask\");\n\nconst struct cred *dns_resolver_cache;\n\n#define\tDNS_ERRORNO_OPTION\t\"dnserror\"\n\n \nstatic int\ndns_resolver_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tunsigned long derrno;\n\tint ret;\n\tint datalen = prep->datalen, result_len = 0;\n\tconst char *data = prep->data, *end, *opt;\n\n\tif (datalen <= 1 || !data)\n\t\treturn -EINVAL;\n\n\tif (data[0] == 0) {\n\t\tconst struct dns_server_list_v1_header *v1;\n\n\t\t \n\t\tif (datalen < sizeof(*v1))\n\t\t\treturn -EINVAL;\n\n\t\tv1 = (const struct dns_server_list_v1_header *)data;\n\t\tkenter(\"[%u,%u],%u\", v1->hdr.content, v1->hdr.version, datalen);\n\t\tif (v1->hdr.content != DNS_PAYLOAD_IS_SERVER_LIST) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"dns_resolver: Unsupported content type (%u)\\n\",\n\t\t\t\tv1->hdr.content);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (v1->hdr.version != 1) {\n\t\t\tpr_warn_ratelimited(\n\t\t\t\t\"dns_resolver: Unsupported server list version (%u)\\n\",\n\t\t\t\tv1->hdr.version);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((v1->status != DNS_LOOKUP_GOOD &&\n\t\t     v1->status != DNS_LOOKUP_GOOD_WITH_BAD)) {\n\t\t\tif (prep->expiry == TIME64_MAX)\n\t\t\t\tprep->expiry = ktime_get_real_seconds() + 1;\n\t\t}\n\n\t\tresult_len = datalen;\n\t\tgoto store_result;\n\t}\n\n\tkenter(\"'%*.*s',%u\", datalen, datalen, data, datalen);\n\n\tif (!data || data[datalen - 1] != '\\0')\n\t\treturn -EINVAL;\n\tdatalen--;\n\n\t \n\tend = data + datalen;\n\topt = memchr(data, '#', datalen);\n\tif (!opt) {\n\t\t \n\t\tkdebug(\"no options\");\n\t\tresult_len = datalen;\n\t} else {\n\t\tconst char *next_opt;\n\n\t\tresult_len = opt - data;\n\t\topt++;\n\t\tkdebug(\"options: '%s'\", opt);\n\t\tdo {\n\t\t\tint opt_len, opt_nlen;\n\t\t\tconst char *eq;\n\t\t\tchar optval[128];\n\n\t\t\tnext_opt = memchr(opt, '#', end - opt) ?: end;\n\t\t\topt_len = next_opt - opt;\n\t\t\tif (opt_len <= 0 || opt_len > sizeof(optval)) {\n\t\t\t\tpr_warn_ratelimited(\"Invalid option length (%d) for dns_resolver key\\n\",\n\t\t\t\t\t\t    opt_len);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\teq = memchr(opt, '=', opt_len);\n\t\t\tif (eq) {\n\t\t\t\topt_nlen = eq - opt;\n\t\t\t\teq++;\n\t\t\t\tmemcpy(optval, eq, next_opt - eq);\n\t\t\t\toptval[next_opt - eq] = '\\0';\n\t\t\t} else {\n\t\t\t\topt_nlen = opt_len;\n\t\t\t\toptval[0] = '\\0';\n\t\t\t}\n\n\t\t\tkdebug(\"option '%*.*s' val '%s'\",\n\t\t\t       opt_nlen, opt_nlen, opt, optval);\n\n\t\t\t \n\t\t\tif (opt_nlen == sizeof(DNS_ERRORNO_OPTION) - 1 &&\n\t\t\t    memcmp(opt, DNS_ERRORNO_OPTION, opt_nlen) == 0) {\n\t\t\t\tkdebug(\"dns error number option\");\n\n\t\t\t\tret = kstrtoul(optval, 10, &derrno);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tif (derrno < 1 || derrno > 511)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tkdebug(\"dns error no. = %lu\", derrno);\n\t\t\t\tprep->payload.data[dns_key_error] = ERR_PTR(-derrno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\tbad_option_value:\n\t\t\tpr_warn_ratelimited(\"Option '%*.*s' to dns_resolver key: bad/missing value\\n\",\n\t\t\t\t\t    opt_nlen, opt_nlen, opt);\n\t\t\treturn -EINVAL;\n\t\t} while (opt = next_opt + 1, opt < end);\n\t}\n\n\t \n\tif (prep->payload.data[dns_key_error]) {\n\t\tkleave(\" = 0 [h_error %ld]\", PTR_ERR(prep->payload.data[dns_key_error]));\n\t\treturn 0;\n\t}\n\nstore_result:\n\tkdebug(\"store result\");\n\tprep->quotalen = result_len;\n\n\tupayload = kmalloc(sizeof(*upayload) + result_len + 1, GFP_KERNEL);\n\tif (!upayload) {\n\t\tkleave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\tupayload->datalen = result_len;\n\tmemcpy(upayload->data, data, result_len);\n\tupayload->data[result_len] = '\\0';\n\n\tprep->payload.data[dns_key_data] = upayload;\n\tkleave(\" = 0\");\n\treturn 0;\n}\n\n \nstatic void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n{\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tkfree(prep->payload.data[dns_key_data]);\n}\n\n \nstatic bool dns_resolver_cmp(const struct key *key,\n\t\t\t     const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\n\tkenter(\"%s,%s\", src, dsp);\n\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\n\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n \nstatic int dns_resolver_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = dns_resolver_cmp;\n\treturn 0;\n}\n\n \nstatic void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key)) {\n\t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}\n\n \nstatic long dns_resolver_read(const struct key *key,\n\t\t\t      char *buffer, size_t buflen)\n{\n\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\n\tif (err)\n\t\treturn err;\n\n\treturn user_read(key, buffer, buflen);\n}\n\nstruct key_type key_type_dns_resolver = {\n\t.name\t\t= \"dns_resolver\",\n\t.flags\t\t= KEY_TYPE_NET_DOMAIN | KEY_TYPE_INSTANT_REAP,\n\t.preparse\t= dns_resolver_preparse,\n\t.free_preparse\t= dns_resolver_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.match_preparse\t= dns_resolver_match_preparse,\n\t.revoke\t\t= user_revoke,\n\t.destroy\t= user_destroy,\n\t.describe\t= dns_resolver_describe,\n\t.read\t\t= dns_resolver_read,\n};\n\nstatic int __init init_dns_resolver(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\t \n\tcred = prepare_kernel_cred(&init_task);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".dns_resolver\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&key_type_dns_resolver);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t \n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\tdns_resolver_cache = cred;\n\n\tkdebug(\"DNS resolver keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}\n\nstatic void __exit exit_dns_resolver(void)\n{\n\tkey_revoke(dns_resolver_cache->thread_keyring);\n\tunregister_key_type(&key_type_dns_resolver);\n\tput_cred(dns_resolver_cache);\n}\n\nmodule_init(init_dns_resolver)\nmodule_exit(exit_dns_resolver)\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}