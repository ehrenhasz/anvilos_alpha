{
  "module_name": "core.c",
  "hash_id": "1311cf414cabfa8597a022fc0a0789c5362874df5f4e427477fb05efe6364f3e",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/if.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/nl80211.h>\n#include <linux/debugfs.h>\n#include <linux/notifier.h>\n#include <linux/device.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/sched.h>\n#include <net/genetlink.h>\n#include <net/cfg80211.h>\n#include \"nl80211.h\"\n#include \"core.h\"\n#include \"sysfs.h\"\n#include \"debugfs.h\"\n#include \"wext-compat.h\"\n#include \"rdev-ops.h\"\n\n \n#define PHY_NAME \"phy\"\n\nMODULE_AUTHOR(\"Johannes Berg\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"wireless configuration support\");\nMODULE_ALIAS_GENL_FAMILY(NL80211_GENL_NAME);\n\n \nLIST_HEAD(cfg80211_rdev_list);\nint cfg80211_rdev_list_generation;\n\n \nstatic struct dentry *ieee80211_debugfs_dir;\n\n \nstruct workqueue_struct *cfg80211_wq;\n\nstatic bool cfg80211_disable_40mhz_24ghz;\nmodule_param(cfg80211_disable_40mhz_24ghz, bool, 0644);\nMODULE_PARM_DESC(cfg80211_disable_40mhz_24ghz,\n\t\t \"Disable 40MHz support in the 2.4GHz band\");\n\nstruct cfg80211_registered_device *cfg80211_rdev_by_wiphy_idx(int wiphy_idx)\n{\n\tstruct cfg80211_registered_device *result = NULL, *rdev;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (rdev->wiphy_idx == wiphy_idx) {\n\t\t\tresult = rdev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nint get_wiphy_idx(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\treturn rdev->wiphy_idx;\n}\n\nstruct wiphy *wiphy_idx_to_wiphy(int wiphy_idx)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\tASSERT_RTNL();\n\n\trdev = cfg80211_rdev_by_wiphy_idx(wiphy_idx);\n\tif (!rdev)\n\t\treturn NULL;\n\treturn &rdev->wiphy;\n}\n\nstatic int cfg80211_dev_check_name(struct cfg80211_registered_device *rdev,\n\t\t\t\t   const char *newname)\n{\n\tstruct cfg80211_registered_device *rdev2;\n\tint wiphy_idx, taken = -1, digits;\n\n\tASSERT_RTNL();\n\n\tif (strlen(newname) > NL80211_WIPHY_NAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\t \n\tsscanf(newname, PHY_NAME \"%d%n\", &wiphy_idx, &taken);\n\tif (taken == strlen(newname) && wiphy_idx != rdev->wiphy_idx) {\n\t\t \n\t\tdigits = 1;\n\t\twhile (wiphy_idx /= 10)\n\t\t\tdigits++;\n\t\t \n\t\tif (taken == strlen(PHY_NAME) + digits)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tlist_for_each_entry(rdev2, &cfg80211_rdev_list, list)\n\t\tif (strcmp(newname, wiphy_name(&rdev2->wiphy)) == 0)\n\t\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint cfg80211_dev_rename(struct cfg80211_registered_device *rdev,\n\t\t\tchar *newname)\n{\n\tint result;\n\n\tASSERT_RTNL();\n\tlockdep_assert_wiphy(&rdev->wiphy);\n\n\t \n\tif (strcmp(newname, wiphy_name(&rdev->wiphy)) == 0)\n\t\treturn 0;\n\n\tresult = cfg80211_dev_check_name(rdev, newname);\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = device_rename(&rdev->wiphy.dev, newname);\n\tif (result)\n\t\treturn result;\n\n\tif (!IS_ERR_OR_NULL(rdev->wiphy.debugfsdir))\n\t\tdebugfs_rename(rdev->wiphy.debugfsdir->d_parent,\n\t\t\t       rdev->wiphy.debugfsdir,\n\t\t\t       rdev->wiphy.debugfsdir->d_parent, newname);\n\n\tnl80211_notify_wiphy(rdev, NL80211_CMD_NEW_WIPHY);\n\n\treturn 0;\n}\n\nint cfg80211_switch_netns(struct cfg80211_registered_device *rdev,\n\t\t\t  struct net *net)\n{\n\tstruct wireless_dev *wdev;\n\tint err = 0;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_NETNS_OK))\n\t\treturn -EOPNOTSUPP;\n\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\tif (!wdev->netdev)\n\t\t\tcontinue;\n\t\twdev->netdev->features &= ~NETIF_F_NETNS_LOCAL;\n\t\terr = dev_change_net_namespace(wdev->netdev, net, \"wlan%d\");\n\t\tif (err)\n\t\t\tbreak;\n\t\twdev->netdev->features |= NETIF_F_NETNS_LOCAL;\n\t}\n\n\tif (err) {\n\t\t \n\t\tnet = wiphy_net(&rdev->wiphy);\n\n\t\tlist_for_each_entry_continue_reverse(wdev,\n\t\t\t\t\t\t     &rdev->wiphy.wdev_list,\n\t\t\t\t\t\t     list) {\n\t\t\tif (!wdev->netdev)\n\t\t\t\tcontinue;\n\t\t\twdev->netdev->features &= ~NETIF_F_NETNS_LOCAL;\n\t\t\terr = dev_change_net_namespace(wdev->netdev, net,\n\t\t\t\t\t\t\t\"wlan%d\");\n\t\t\tWARN_ON(err);\n\t\t\twdev->netdev->features |= NETIF_F_NETNS_LOCAL;\n\t\t}\n\n\t\treturn err;\n\t}\n\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\tif (!wdev->netdev)\n\t\t\tcontinue;\n\t\tnl80211_notify_iface(rdev, wdev, NL80211_CMD_DEL_INTERFACE);\n\t}\n\n\twiphy_lock(&rdev->wiphy);\n\tnl80211_notify_wiphy(rdev, NL80211_CMD_DEL_WIPHY);\n\n\twiphy_net_set(&rdev->wiphy, net);\n\n\terr = device_rename(&rdev->wiphy.dev, dev_name(&rdev->wiphy.dev));\n\tWARN_ON(err);\n\n\tnl80211_notify_wiphy(rdev, NL80211_CMD_NEW_WIPHY);\n\twiphy_unlock(&rdev->wiphy);\n\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\tif (!wdev->netdev)\n\t\t\tcontinue;\n\t\tnl80211_notify_iface(rdev, wdev, NL80211_CMD_NEW_INTERFACE);\n\t}\n\n\treturn 0;\n}\n\nstatic void cfg80211_rfkill_poll(struct rfkill *rfkill, void *data)\n{\n\tstruct cfg80211_registered_device *rdev = data;\n\n\twiphy_lock(&rdev->wiphy);\n\trdev_rfkill_poll(rdev);\n\twiphy_unlock(&rdev->wiphy);\n}\n\nvoid cfg80211_stop_p2p_device(struct cfg80211_registered_device *rdev,\n\t\t\t      struct wireless_dev *wdev)\n{\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_P2P_DEVICE))\n\t\treturn;\n\n\tif (!wdev_running(wdev))\n\t\treturn;\n\n\trdev_stop_p2p_device(rdev, wdev);\n\twdev->is_running = false;\n\n\trdev->opencount--;\n\n\tif (rdev->scan_req && rdev->scan_req->wdev == wdev) {\n\t\tif (WARN_ON(!rdev->scan_req->notified &&\n\t\t\t    (!rdev->int_scan_req ||\n\t\t\t     !rdev->int_scan_req->notified)))\n\t\t\trdev->scan_req->info.aborted = true;\n\t\t___cfg80211_scan_done(rdev, false);\n\t}\n}\n\nvoid cfg80211_stop_nan(struct cfg80211_registered_device *rdev,\n\t\t       struct wireless_dev *wdev)\n{\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_NAN))\n\t\treturn;\n\n\tif (!wdev_running(wdev))\n\t\treturn;\n\n\trdev_stop_nan(rdev, wdev);\n\twdev->is_running = false;\n\n\trdev->opencount--;\n}\n\nvoid cfg80211_shutdown_all_interfaces(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct wireless_dev *wdev;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\tif (wdev->netdev) {\n\t\t\tdev_close(wdev->netdev);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\twiphy_lock(wiphy);\n\n\t\tswitch (wdev->iftype) {\n\t\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t\tcfg80211_stop_p2p_device(rdev, wdev);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_NAN:\n\t\t\tcfg80211_stop_nan(rdev, wdev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\twiphy_unlock(wiphy);\n\t}\n}\nEXPORT_SYMBOL_GPL(cfg80211_shutdown_all_interfaces);\n\nstatic int cfg80211_rfkill_set_block(void *data, bool blocked)\n{\n\tstruct cfg80211_registered_device *rdev = data;\n\n\tif (!blocked)\n\t\treturn 0;\n\n\trtnl_lock();\n\tcfg80211_shutdown_all_interfaces(&rdev->wiphy);\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic void cfg80211_rfkill_block_work(struct work_struct *work)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\trdev = container_of(work, struct cfg80211_registered_device,\n\t\t\t    rfkill_block);\n\tcfg80211_rfkill_set_block(rdev, true);\n}\n\nstatic void cfg80211_event_work(struct work_struct *work)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\trdev = container_of(work, struct cfg80211_registered_device,\n\t\t\t    event_work);\n\n\twiphy_lock(&rdev->wiphy);\n\tcfg80211_process_rdev_events(rdev);\n\twiphy_unlock(&rdev->wiphy);\n}\n\nvoid cfg80211_destroy_ifaces(struct cfg80211_registered_device *rdev)\n{\n\tstruct wireless_dev *wdev, *tmp;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry_safe(wdev, tmp, &rdev->wiphy.wdev_list, list) {\n\t\tif (wdev->nl_owner_dead) {\n\t\t\tif (wdev->netdev)\n\t\t\t\tdev_close(wdev->netdev);\n\n\t\t\twiphy_lock(&rdev->wiphy);\n\t\t\tcfg80211_leave(rdev, wdev);\n\t\t\tcfg80211_remove_virtual_intf(rdev, wdev);\n\t\t\twiphy_unlock(&rdev->wiphy);\n\t\t}\n\t}\n}\n\nstatic void cfg80211_destroy_iface_wk(struct work_struct *work)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\trdev = container_of(work, struct cfg80211_registered_device,\n\t\t\t    destroy_work);\n\n\trtnl_lock();\n\tcfg80211_destroy_ifaces(rdev);\n\trtnl_unlock();\n}\n\nstatic void cfg80211_sched_scan_stop_wk(struct wiphy *wiphy,\n\t\t\t\t\tstruct wiphy_work *work)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct cfg80211_sched_scan_request *req, *tmp;\n\n\trdev = container_of(work, struct cfg80211_registered_device,\n\t\t\t   sched_scan_stop_wk);\n\n\tlist_for_each_entry_safe(req, tmp, &rdev->sched_scan_req_list, list) {\n\t\tif (req->nl_owner_dead)\n\t\t\tcfg80211_stop_sched_scan_req(rdev, req, false);\n\t}\n}\n\nstatic void cfg80211_propagate_radar_detect_wk(struct work_struct *work)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\trdev = container_of(work, struct cfg80211_registered_device,\n\t\t\t    propagate_radar_detect_wk);\n\n\trtnl_lock();\n\n\tregulatory_propagate_dfs_state(&rdev->wiphy, &rdev->radar_chandef,\n\t\t\t\t       NL80211_DFS_UNAVAILABLE,\n\t\t\t\t       NL80211_RADAR_DETECTED);\n\n\trtnl_unlock();\n}\n\nstatic void cfg80211_propagate_cac_done_wk(struct work_struct *work)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\trdev = container_of(work, struct cfg80211_registered_device,\n\t\t\t    propagate_cac_done_wk);\n\n\trtnl_lock();\n\n\tregulatory_propagate_dfs_state(&rdev->wiphy, &rdev->cac_done_chandef,\n\t\t\t\t       NL80211_DFS_AVAILABLE,\n\t\t\t\t       NL80211_RADAR_CAC_FINISHED);\n\n\trtnl_unlock();\n}\n\nstatic void cfg80211_wiphy_work(struct work_struct *work)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wiphy_work *wk;\n\n\trdev = container_of(work, struct cfg80211_registered_device, wiphy_work);\n\n\twiphy_lock(&rdev->wiphy);\n\tif (rdev->suspended)\n\t\tgoto out;\n\n\tspin_lock_irq(&rdev->wiphy_work_lock);\n\twk = list_first_entry_or_null(&rdev->wiphy_work_list,\n\t\t\t\t      struct wiphy_work, entry);\n\tif (wk) {\n\t\tlist_del_init(&wk->entry);\n\t\tif (!list_empty(&rdev->wiphy_work_list))\n\t\t\tschedule_work(work);\n\t\tspin_unlock_irq(&rdev->wiphy_work_lock);\n\n\t\twk->func(&rdev->wiphy, wk);\n\t} else {\n\t\tspin_unlock_irq(&rdev->wiphy_work_lock);\n\t}\nout:\n\twiphy_unlock(&rdev->wiphy);\n}\n\n \n\nstruct wiphy *wiphy_new_nm(const struct cfg80211_ops *ops, int sizeof_priv,\n\t\t\t   const char *requested_name)\n{\n\tstatic atomic_t wiphy_counter = ATOMIC_INIT(0);\n\n\tstruct cfg80211_registered_device *rdev;\n\tint alloc_size;\n\n\tWARN_ON(ops->add_key && (!ops->del_key || !ops->set_default_key));\n\tWARN_ON(ops->auth && (!ops->assoc || !ops->deauth || !ops->disassoc));\n\tWARN_ON(ops->connect && !ops->disconnect);\n\tWARN_ON(ops->join_ibss && !ops->leave_ibss);\n\tWARN_ON(ops->add_virtual_intf && !ops->del_virtual_intf);\n\tWARN_ON(ops->add_station && !ops->del_station);\n\tWARN_ON(ops->add_mpath && !ops->del_mpath);\n\tWARN_ON(ops->join_mesh && !ops->leave_mesh);\n\tWARN_ON(ops->start_p2p_device && !ops->stop_p2p_device);\n\tWARN_ON(ops->start_ap && !ops->stop_ap);\n\tWARN_ON(ops->join_ocb && !ops->leave_ocb);\n\tWARN_ON(ops->suspend && !ops->resume);\n\tWARN_ON(ops->sched_scan_start && !ops->sched_scan_stop);\n\tWARN_ON(ops->remain_on_channel && !ops->cancel_remain_on_channel);\n\tWARN_ON(ops->tdls_channel_switch && !ops->tdls_cancel_channel_switch);\n\tWARN_ON(ops->add_tx_ts && !ops->del_tx_ts);\n\n\talloc_size = sizeof(*rdev) + sizeof_priv;\n\n\trdev = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!rdev)\n\t\treturn NULL;\n\n\trdev->ops = ops;\n\n\trdev->wiphy_idx = atomic_inc_return(&wiphy_counter);\n\n\tif (unlikely(rdev->wiphy_idx < 0)) {\n\t\t \n\t\tatomic_dec(&wiphy_counter);\n\t\tkfree(rdev);\n\t\treturn NULL;\n\t}\n\n\t \n\trdev->wiphy_idx--;\n\n\t \n\tif (requested_name && requested_name[0]) {\n\t\tint rv;\n\n\t\trtnl_lock();\n\t\trv = cfg80211_dev_check_name(rdev, requested_name);\n\n\t\tif (rv < 0) {\n\t\t\trtnl_unlock();\n\t\t\tgoto use_default_name;\n\t\t}\n\n\t\trv = dev_set_name(&rdev->wiphy.dev, \"%s\", requested_name);\n\t\trtnl_unlock();\n\t\tif (rv)\n\t\t\tgoto use_default_name;\n\t} else {\n\t\tint rv;\n\nuse_default_name:\n\t\t \n\t\trv = dev_set_name(&rdev->wiphy.dev, PHY_NAME \"%d\", rdev->wiphy_idx);\n\t\tif (rv < 0) {\n\t\t\tkfree(rdev);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tmutex_init(&rdev->wiphy.mtx);\n\tINIT_LIST_HEAD(&rdev->wiphy.wdev_list);\n\tINIT_LIST_HEAD(&rdev->beacon_registrations);\n\tspin_lock_init(&rdev->beacon_registrations_lock);\n\tspin_lock_init(&rdev->bss_lock);\n\tINIT_LIST_HEAD(&rdev->bss_list);\n\tINIT_LIST_HEAD(&rdev->sched_scan_req_list);\n\twiphy_work_init(&rdev->scan_done_wk, __cfg80211_scan_done);\n\tINIT_DELAYED_WORK(&rdev->dfs_update_channels_wk,\n\t\t\t  cfg80211_dfs_channels_update_work);\n#ifdef CONFIG_CFG80211_WEXT\n\trdev->wiphy.wext = &cfg80211_wext_handler;\n#endif\n\n\tdevice_initialize(&rdev->wiphy.dev);\n\trdev->wiphy.dev.class = &ieee80211_class;\n\trdev->wiphy.dev.platform_data = rdev;\n\tdevice_enable_async_suspend(&rdev->wiphy.dev);\n\n\tINIT_WORK(&rdev->destroy_work, cfg80211_destroy_iface_wk);\n\twiphy_work_init(&rdev->sched_scan_stop_wk, cfg80211_sched_scan_stop_wk);\n\tINIT_WORK(&rdev->sched_scan_res_wk, cfg80211_sched_scan_results_wk);\n\tINIT_WORK(&rdev->propagate_radar_detect_wk,\n\t\t  cfg80211_propagate_radar_detect_wk);\n\tINIT_WORK(&rdev->propagate_cac_done_wk, cfg80211_propagate_cac_done_wk);\n\tINIT_WORK(&rdev->mgmt_registrations_update_wk,\n\t\t  cfg80211_mgmt_registrations_update_wk);\n\tspin_lock_init(&rdev->mgmt_registrations_lock);\n\n#ifdef CONFIG_CFG80211_DEFAULT_PS\n\trdev->wiphy.flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;\n#endif\n\n\twiphy_net_set(&rdev->wiphy, &init_net);\n\n\trdev->rfkill_ops.set_block = cfg80211_rfkill_set_block;\n\trdev->wiphy.rfkill = rfkill_alloc(dev_name(&rdev->wiphy.dev),\n\t\t\t\t\t  &rdev->wiphy.dev, RFKILL_TYPE_WLAN,\n\t\t\t\t\t  &rdev->rfkill_ops, rdev);\n\n\tif (!rdev->wiphy.rfkill) {\n\t\twiphy_free(&rdev->wiphy);\n\t\treturn NULL;\n\t}\n\n\tINIT_WORK(&rdev->wiphy_work, cfg80211_wiphy_work);\n\tINIT_LIST_HEAD(&rdev->wiphy_work_list);\n\tspin_lock_init(&rdev->wiphy_work_lock);\n\tINIT_WORK(&rdev->rfkill_block, cfg80211_rfkill_block_work);\n\tINIT_WORK(&rdev->conn_work, cfg80211_conn_work);\n\tINIT_WORK(&rdev->event_work, cfg80211_event_work);\n\tINIT_WORK(&rdev->background_cac_abort_wk,\n\t\t  cfg80211_background_cac_abort_wk);\n\tINIT_DELAYED_WORK(&rdev->background_cac_done_wk,\n\t\t\t  cfg80211_background_cac_done_wk);\n\n\tinit_waitqueue_head(&rdev->dev_wait);\n\n\t \n\trdev->wiphy.retry_short = 7;\n\trdev->wiphy.retry_long = 4;\n\trdev->wiphy.frag_threshold = (u32) -1;\n\trdev->wiphy.rts_threshold = (u32) -1;\n\trdev->wiphy.coverage_class = 0;\n\n\trdev->wiphy.max_num_csa_counters = 1;\n\n\trdev->wiphy.max_sched_scan_plans = 1;\n\trdev->wiphy.max_sched_scan_plan_interval = U32_MAX;\n\n\treturn &rdev->wiphy;\n}\nEXPORT_SYMBOL(wiphy_new_nm);\n\nstatic int wiphy_verify_combinations(struct wiphy *wiphy)\n{\n\tconst struct ieee80211_iface_combination *c;\n\tint i, j;\n\n\tfor (i = 0; i < wiphy->n_iface_combinations; i++) {\n\t\tu32 cnt = 0;\n\t\tu16 all_iftypes = 0;\n\n\t\tc = &wiphy->iface_combinations[i];\n\n\t\t \n\t\tif (WARN_ON((c->max_interfaces < 2) && !c->radar_detect_widths))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (WARN_ON(!c->num_different_channels))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (WARN_ON(c->radar_detect_widths &&\n\t\t\t    (c->num_different_channels > 1)))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(!c->n_limits))\n\t\t\treturn -EINVAL;\n\n\t\tfor (j = 0; j < c->n_limits; j++) {\n\t\t\tu16 types = c->limits[j].types;\n\n\t\t\t \n\t\t\tif (WARN_ON(types & all_iftypes))\n\t\t\t\treturn -EINVAL;\n\t\t\tall_iftypes |= types;\n\n\t\t\tif (WARN_ON(!c->limits[j].max))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tif (WARN_ON(wiphy->software_iftypes & types))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tif (WARN_ON(types & BIT(NL80211_IFTYPE_P2P_DEVICE) &&\n\t\t\t\t    c->limits[j].max > 1))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tif (WARN_ON(types & BIT(NL80211_IFTYPE_NAN) &&\n\t\t\t\t    c->limits[j].max > 1))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tif (WARN_ON(types & BIT(NL80211_IFTYPE_ADHOC) &&\n\t\t\t\t    c->beacon_int_min_gcd)) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tcnt += c->limits[j].max;\n\t\t\t \n\t\t\tif (WARN_ON((wiphy->interface_modes & types) != types))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (WARN_ON(all_iftypes & BIT(NL80211_IFTYPE_WDS)))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (WARN_ON(cnt < c->max_interfaces))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint wiphy_register(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tint res;\n\tenum nl80211_band band;\n\tstruct ieee80211_supported_band *sband;\n\tbool have_band = false;\n\tint i;\n\tu16 ifmodes = wiphy->interface_modes;\n\n#ifdef CONFIG_PM\n\tif (WARN_ON(wiphy->wowlan &&\n\t\t    (wiphy->wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&\n\t\t    !(wiphy->wowlan->flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY)))\n\t\treturn -EINVAL;\n\tif (WARN_ON(wiphy->wowlan &&\n\t\t    !wiphy->wowlan->flags && !wiphy->wowlan->n_patterns &&\n\t\t    !wiphy->wowlan->tcp))\n\t\treturn -EINVAL;\n#endif\n\tif (WARN_ON((wiphy->features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH) &&\n\t\t    (!rdev->ops->tdls_channel_switch ||\n\t\t     !rdev->ops->tdls_cancel_channel_switch)))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON((wiphy->interface_modes & BIT(NL80211_IFTYPE_NAN)) &&\n\t\t    (!rdev->ops->start_nan || !rdev->ops->stop_nan ||\n\t\t     !rdev->ops->add_nan_func || !rdev->ops->del_nan_func ||\n\t\t     !(wiphy->nan_supported_bands & BIT(NL80211_BAND_2GHZ)))))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(wiphy->interface_modes & BIT(NL80211_IFTYPE_WDS)))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(wiphy->pmsr_capa && !wiphy->pmsr_capa->ftm.supported))\n\t\treturn -EINVAL;\n\n\tif (wiphy->pmsr_capa && wiphy->pmsr_capa->ftm.supported) {\n\t\tif (WARN_ON(!wiphy->pmsr_capa->ftm.asap &&\n\t\t\t    !wiphy->pmsr_capa->ftm.non_asap))\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON(!wiphy->pmsr_capa->ftm.preambles ||\n\t\t\t    !wiphy->pmsr_capa->ftm.bandwidths))\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON(wiphy->pmsr_capa->ftm.preambles &\n\t\t\t\t~(BIT(NL80211_PREAMBLE_LEGACY) |\n\t\t\t\t  BIT(NL80211_PREAMBLE_HT) |\n\t\t\t\t  BIT(NL80211_PREAMBLE_VHT) |\n\t\t\t\t  BIT(NL80211_PREAMBLE_HE) |\n\t\t\t\t  BIT(NL80211_PREAMBLE_DMG))))\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON((wiphy->pmsr_capa->ftm.trigger_based ||\n\t\t\t     wiphy->pmsr_capa->ftm.non_trigger_based) &&\n\t\t\t    !(wiphy->pmsr_capa->ftm.preambles &\n\t\t\t      BIT(NL80211_PREAMBLE_HE))))\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON(wiphy->pmsr_capa->ftm.bandwidths &\n\t\t\t\t~(BIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t  BIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t  BIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t  BIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t  BIT(NL80211_CHAN_WIDTH_80P80) |\n\t\t\t\t  BIT(NL80211_CHAN_WIDTH_160) |\n\t\t\t\t  BIT(NL80211_CHAN_WIDTH_5) |\n\t\t\t\t  BIT(NL80211_CHAN_WIDTH_10))))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (WARN_ON((wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED) &&\n\t\t    (wiphy->regulatory_flags &\n\t\t\t\t\t(REGULATORY_CUSTOM_REG |\n\t\t\t\t\t REGULATORY_STRICT_REG |\n\t\t\t\t\t REGULATORY_COUNTRY_IE_FOLLOW_POWER |\n\t\t\t\t\t REGULATORY_COUNTRY_IE_IGNORE))))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(wiphy->coalesce &&\n\t\t    (!wiphy->coalesce->n_rules ||\n\t\t     !wiphy->coalesce->n_patterns) &&\n\t\t    (!wiphy->coalesce->pattern_min_len ||\n\t\t     wiphy->coalesce->pattern_min_len >\n\t\t\twiphy->coalesce->pattern_max_len)))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(wiphy->ap_sme_capa &&\n\t\t    !(wiphy->flags & WIPHY_FLAG_HAVE_AP_SME)))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(wiphy->addresses && !wiphy->n_addresses))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(wiphy->addresses &&\n\t\t    !is_zero_ether_addr(wiphy->perm_addr) &&\n\t\t    memcmp(wiphy->perm_addr, wiphy->addresses[0].addr,\n\t\t\t   ETH_ALEN)))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(wiphy->max_acl_mac_addrs &&\n\t\t    (!(wiphy->flags & WIPHY_FLAG_HAVE_AP_SME) ||\n\t\t     !rdev->ops->set_mac_acl)))\n\t\treturn -EINVAL;\n\n\t \n\tif (WARN_ON(wiphy->bss_select_support &&\n\t\t    (wiphy->bss_select_support & ~(BIT(__NL80211_BSS_SELECT_ATTR_AFTER_LAST) - 2))))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X) &&\n\t\t    (!rdev->ops->set_pmk || !rdev->ops->del_pmk)))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_FW_ROAM) &&\n\t\t    rdev->ops->update_connect_params))\n\t\treturn -EINVAL;\n\n\tif (wiphy->addresses)\n\t\tmemcpy(wiphy->perm_addr, wiphy->addresses[0].addr, ETH_ALEN);\n\n\t \n\tWARN_ON(!ifmodes);\n\tifmodes &= ((1 << NUM_NL80211_IFTYPES) - 1) & ~1;\n\tif (WARN_ON(ifmodes != wiphy->interface_modes))\n\t\twiphy->interface_modes = ifmodes;\n\n\tres = wiphy_verify_combinations(wiphy);\n\tif (res)\n\t\treturn res;\n\n\t \n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tu16 types = 0;\n\t\tbool have_he = false;\n\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tsband->band = band;\n\t\tif (WARN_ON(!sband->n_channels))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (WARN_ON((band != NL80211_BAND_60GHZ &&\n\t\t\t     band != NL80211_BAND_S1GHZ) &&\n\t\t\t    !sband->n_bitrates))\n\t\t\treturn -EINVAL;\n\n\t\tif (WARN_ON(band == NL80211_BAND_6GHZ &&\n\t\t\t    (sband->ht_cap.ht_supported ||\n\t\t\t     sband->vht_cap.vht_supported)))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (cfg80211_disable_40mhz_24ghz &&\n\t\t    band == NL80211_BAND_2GHZ &&\n\t\t    sband->ht_cap.ht_supported) {\n\t\t\tsband->ht_cap.cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\t\tsband->ht_cap.cap &= ~IEEE80211_HT_CAP_SGI_40;\n\t\t}\n\n\t\t \n\t\tif (WARN_ON(sband->n_bitrates > 32))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\tsband->channels[i].orig_flags =\n\t\t\t\tsband->channels[i].flags;\n\t\t\tsband->channels[i].orig_mag = INT_MAX;\n\t\t\tsband->channels[i].orig_mpwr =\n\t\t\t\tsband->channels[i].max_power;\n\t\t\tsband->channels[i].band = band;\n\n\t\t\tif (WARN_ON(sband->channels[i].freq_offset >= 1000))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < sband->n_iftype_data; i++) {\n\t\t\tconst struct ieee80211_sband_iftype_data *iftd;\n\t\t\tbool has_ap, has_non_ap;\n\t\t\tu32 ap_bits = BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t      BIT(NL80211_IFTYPE_P2P_GO);\n\n\t\t\tiftd = &sband->iftype_data[i];\n\n\t\t\tif (WARN_ON(!iftd->types_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (WARN_ON(types & iftd->types_mask))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tif (WARN_ON(!iftd->he_cap.has_he))\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttypes |= iftd->types_mask;\n\n\t\t\tif (i == 0)\n\t\t\t\thave_he = iftd->he_cap.has_he;\n\t\t\telse\n\t\t\t\thave_he = have_he &&\n\t\t\t\t\t  iftd->he_cap.has_he;\n\n\t\t\thas_ap = iftd->types_mask & ap_bits;\n\t\t\thas_non_ap = iftd->types_mask & ~ap_bits;\n\n\t\t\t \n\t\t\tif (WARN_ON(iftd->eht_cap.has_eht &&\n\t\t\t\t    has_ap && has_non_ap))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (WARN_ON(!have_he && band == NL80211_BAND_6GHZ))\n\t\t\treturn -EINVAL;\n\n\t\thave_band = true;\n\t}\n\n\tif (!have_band) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {\n\t\t \n\t\tif (WARN_ON(!rdev->wiphy.vendor_commands[i].policy))\n\t\t\treturn -EINVAL;\n\t\tif (WARN_ON(!rdev->wiphy.vendor_commands[i].doit &&\n\t\t\t    !rdev->wiphy.vendor_commands[i].dumpit))\n\t\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_PM\n\tif (WARN_ON(rdev->wiphy.wowlan && rdev->wiphy.wowlan->n_patterns &&\n\t\t    (!rdev->wiphy.wowlan->pattern_min_len ||\n\t\t     rdev->wiphy.wowlan->pattern_min_len >\n\t\t\t\trdev->wiphy.wowlan->pattern_max_len)))\n\t\treturn -EINVAL;\n#endif\n\n\tif (!wiphy->max_num_akm_suites)\n\t\twiphy->max_num_akm_suites = NL80211_MAX_NR_AKM_SUITES;\n\telse if (wiphy->max_num_akm_suites < NL80211_MAX_NR_AKM_SUITES ||\n\t\t wiphy->max_num_akm_suites > CFG80211_MAX_NUM_AKM_SUITES)\n\t\treturn -EINVAL;\n\n\t \n\tieee80211_set_bitrate_flags(wiphy);\n\n\trdev->wiphy.features |= NL80211_FEATURE_SCAN_FLUSH;\n\n\trtnl_lock();\n\twiphy_lock(&rdev->wiphy);\n\tres = device_add(&rdev->wiphy.dev);\n\tif (res) {\n\t\twiphy_unlock(&rdev->wiphy);\n\t\trtnl_unlock();\n\t\treturn res;\n\t}\n\n\tlist_add_rcu(&rdev->list, &cfg80211_rdev_list);\n\tcfg80211_rdev_list_generation++;\n\n\t \n\trdev->wiphy.debugfsdir = debugfs_create_dir(wiphy_name(&rdev->wiphy),\n\t\t\t\t\t\t    ieee80211_debugfs_dir);\n\n\tcfg80211_debugfs_rdev_add(rdev);\n\tnl80211_notify_wiphy(rdev, NL80211_CMD_NEW_WIPHY);\n\twiphy_unlock(&rdev->wiphy);\n\n\t \n\twiphy_regulatory_register(wiphy);\n\n\tif (wiphy->regulatory_flags & REGULATORY_CUSTOM_REG) {\n\t\tstruct regulatory_request request;\n\n\t\trequest.wiphy_idx = get_wiphy_idx(wiphy);\n\t\trequest.initiator = NL80211_REGDOM_SET_BY_DRIVER;\n\t\trequest.alpha2[0] = '9';\n\t\trequest.alpha2[1] = '9';\n\n\t\tnl80211_send_reg_change_event(&request);\n\t}\n\n\t \n\tif (wiphy->extended_capabilities_len &&\n\t    wiphy->num_iftype_ext_capab &&\n\t    wiphy->iftype_ext_capab) {\n\t\tu8 supported_on_all, j;\n\t\tconst struct wiphy_iftype_ext_capab *capab;\n\n\t\tcapab = wiphy->iftype_ext_capab;\n\t\tfor (j = 0; j < wiphy->extended_capabilities_len; j++) {\n\t\t\tif (capab[0].extended_capabilities_len > j)\n\t\t\t\tsupported_on_all =\n\t\t\t\t\tcapab[0].extended_capabilities[j];\n\t\t\telse\n\t\t\t\tsupported_on_all = 0x00;\n\t\t\tfor (i = 1; i < wiphy->num_iftype_ext_capab; i++) {\n\t\t\t\tif (j >= capab[i].extended_capabilities_len) {\n\t\t\t\t\tsupported_on_all = 0x00;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsupported_on_all &=\n\t\t\t\t\tcapab[i].extended_capabilities[j];\n\t\t\t}\n\t\t\tif (WARN_ON(wiphy->extended_capabilities[j] &\n\t\t\t\t    ~supported_on_all))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\trdev->wiphy.registered = true;\n\trtnl_unlock();\n\n\tres = rfkill_register(rdev->wiphy.rfkill);\n\tif (res) {\n\t\trfkill_destroy(rdev->wiphy.rfkill);\n\t\trdev->wiphy.rfkill = NULL;\n\t\twiphy_unregister(&rdev->wiphy);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(wiphy_register);\n\nvoid wiphy_rfkill_start_polling(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (!rdev->ops->rfkill_poll)\n\t\treturn;\n\trdev->rfkill_ops.poll = cfg80211_rfkill_poll;\n\trfkill_resume_polling(wiphy->rfkill);\n}\nEXPORT_SYMBOL(wiphy_rfkill_start_polling);\n\nvoid cfg80211_process_wiphy_works(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct wiphy_work *end)\n{\n\tunsigned int runaway_limit = 100;\n\tunsigned long flags;\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\tspin_lock_irqsave(&rdev->wiphy_work_lock, flags);\n\twhile (!list_empty(&rdev->wiphy_work_list)) {\n\t\tstruct wiphy_work *wk;\n\n\t\twk = list_first_entry(&rdev->wiphy_work_list,\n\t\t\t\t      struct wiphy_work, entry);\n\t\tlist_del_init(&wk->entry);\n\t\tspin_unlock_irqrestore(&rdev->wiphy_work_lock, flags);\n\n\t\twk->func(&rdev->wiphy, wk);\n\n\t\tspin_lock_irqsave(&rdev->wiphy_work_lock, flags);\n\n\t\tif (wk == end)\n\t\t\tbreak;\n\n\t\tif (WARN_ON(--runaway_limit == 0))\n\t\t\tINIT_LIST_HEAD(&rdev->wiphy_work_list);\n\t}\n\tspin_unlock_irqrestore(&rdev->wiphy_work_lock, flags);\n}\n\nvoid wiphy_unregister(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\twait_event(rdev->dev_wait, ({\n\t\tint __count;\n\t\twiphy_lock(&rdev->wiphy);\n\t\t__count = rdev->opencount;\n\t\twiphy_unlock(&rdev->wiphy);\n\t\t__count == 0; }));\n\n\tif (rdev->wiphy.rfkill)\n\t\trfkill_unregister(rdev->wiphy.rfkill);\n\n\trtnl_lock();\n\twiphy_lock(&rdev->wiphy);\n\tnl80211_notify_wiphy(rdev, NL80211_CMD_DEL_WIPHY);\n\trdev->wiphy.registered = false;\n\n\tWARN_ON(!list_empty(&rdev->wiphy.wdev_list));\n\n\t \n\tdebugfs_remove_recursive(rdev->wiphy.debugfsdir);\n\tlist_del_rcu(&rdev->list);\n\tsynchronize_rcu();\n\n\t \n\twiphy_regulatory_deregister(wiphy);\n\n\tcfg80211_rdev_list_generation++;\n\tdevice_del(&rdev->wiphy.dev);\n\n#ifdef CONFIG_PM\n\tif (rdev->wiphy.wowlan_config && rdev->ops->set_wakeup)\n\t\trdev_set_wakeup(rdev, false);\n#endif\n\n\t \n\tcfg80211_process_wiphy_works(rdev, NULL);\n\twiphy_unlock(&rdev->wiphy);\n\trtnl_unlock();\n\n\t \n\tcancel_work_sync(&rdev->wiphy_work);\n\n\tcancel_work_sync(&rdev->conn_work);\n\tflush_work(&rdev->event_work);\n\tcancel_delayed_work_sync(&rdev->dfs_update_channels_wk);\n\tcancel_delayed_work_sync(&rdev->background_cac_done_wk);\n\tflush_work(&rdev->destroy_work);\n\tflush_work(&rdev->propagate_radar_detect_wk);\n\tflush_work(&rdev->propagate_cac_done_wk);\n\tflush_work(&rdev->mgmt_registrations_update_wk);\n\tflush_work(&rdev->background_cac_abort_wk);\n\n\tcfg80211_rdev_free_wowlan(rdev);\n\tcfg80211_rdev_free_coalesce(rdev);\n}\nEXPORT_SYMBOL(wiphy_unregister);\n\nvoid cfg80211_dev_free(struct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_internal_bss *scan, *tmp;\n\tstruct cfg80211_beacon_registration *reg, *treg;\n\trfkill_destroy(rdev->wiphy.rfkill);\n\tlist_for_each_entry_safe(reg, treg, &rdev->beacon_registrations, list) {\n\t\tlist_del(&reg->list);\n\t\tkfree(reg);\n\t}\n\tlist_for_each_entry_safe(scan, tmp, &rdev->bss_list, list)\n\t\tcfg80211_put_bss(&rdev->wiphy, &scan->pub);\n\tmutex_destroy(&rdev->wiphy.mtx);\n\n\t \n\tkfree(rcu_dereference_raw(rdev->wiphy.regd));\n\n\tkfree(rdev);\n}\n\nvoid wiphy_free(struct wiphy *wiphy)\n{\n\tput_device(&wiphy->dev);\n}\nEXPORT_SYMBOL(wiphy_free);\n\nvoid wiphy_rfkill_set_hw_state_reason(struct wiphy *wiphy, bool blocked,\n\t\t\t\t      enum rfkill_hard_block_reasons reason)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (rfkill_set_hw_state_reason(wiphy->rfkill, blocked, reason))\n\t\tschedule_work(&rdev->rfkill_block);\n}\nEXPORT_SYMBOL(wiphy_rfkill_set_hw_state_reason);\n\nstatic void _cfg80211_unregister_wdev(struct wireless_dev *wdev,\n\t\t\t\t      bool unregister_netdev)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_cqm_config *cqm_config;\n\tunsigned int link_id;\n\n\tASSERT_RTNL();\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\tnl80211_notify_iface(rdev, wdev, NL80211_CMD_DEL_INTERFACE);\n\n\twdev->registered = false;\n\n\tif (wdev->netdev) {\n\t\tsysfs_remove_link(&wdev->netdev->dev.kobj, \"phy80211\");\n\t\tif (unregister_netdev)\n\t\t\tunregister_netdevice(wdev->netdev);\n\t}\n\n\tlist_del_rcu(&wdev->list);\n\tsynchronize_net();\n\trdev->devlist_generation++;\n\n\tcfg80211_mlme_purge_registrations(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tcfg80211_stop_p2p_device(rdev, wdev);\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\t\tcfg80211_stop_nan(rdev, wdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n#ifdef CONFIG_CFG80211_WEXT\n\tkfree_sensitive(wdev->wext.keys);\n\twdev->wext.keys = NULL;\n#endif\n\twiphy_work_cancel(wdev->wiphy, &wdev->cqm_rssi_work);\n\t \n\tcqm_config = rcu_access_pointer(wdev->cqm_config);\n\tkfree_rcu(cqm_config, rcu_head);\n\n\t \n\tcfg80211_process_wdev_events(wdev);\n\n\tif (wdev->iftype == NL80211_IFTYPE_STATION ||\n\t    wdev->iftype == NL80211_IFTYPE_P2P_CLIENT) {\n\t\tfor (link_id = 0; link_id < ARRAY_SIZE(wdev->links); link_id++) {\n\t\t\tstruct cfg80211_internal_bss *curbss;\n\n\t\t\tcurbss = wdev->links[link_id].client.current_bss;\n\n\t\t\tif (WARN_ON(curbss)) {\n\t\t\t\tcfg80211_unhold_bss(curbss);\n\t\t\t\tcfg80211_put_bss(wdev->wiphy, &curbss->pub);\n\t\t\t\twdev->links[link_id].client.current_bss = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\twdev->connected = false;\n}\n\nvoid cfg80211_unregister_wdev(struct wireless_dev *wdev)\n{\n\t_cfg80211_unregister_wdev(wdev, true);\n}\nEXPORT_SYMBOL(cfg80211_unregister_wdev);\n\nstatic const struct device_type wiphy_type = {\n\t.name\t= \"wlan\",\n};\n\nvoid cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,\n\t\t\t       enum nl80211_iftype iftype, int num)\n{\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\trdev->num_running_ifaces += num;\n\tif (iftype == NL80211_IFTYPE_MONITOR)\n\t\trdev->num_running_monitor_ifaces += num;\n}\n\nvoid __cfg80211_leave(struct cfg80211_registered_device *rdev,\n\t\t      struct wireless_dev *wdev)\n{\n\tstruct net_device *dev = wdev->netdev;\n\tstruct cfg80211_sched_scan_request *pos, *tmp;\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\tASSERT_WDEV_LOCK(wdev);\n\n\tcfg80211_pmsr_wdev_down(wdev);\n\n\tcfg80211_stop_background_radar_detection(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t__cfg80211_leave_ibss(rdev, dev, true);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tlist_for_each_entry_safe(pos, tmp, &rdev->sched_scan_req_list,\n\t\t\t\t\t list) {\n\t\t\tif (dev == pos->dev)\n\t\t\t\tcfg80211_stop_sched_scan_req(rdev, pos, false);\n\t\t}\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\tkfree(wdev->wext.ie);\n\t\twdev->wext.ie = NULL;\n\t\twdev->wext.ie_len = 0;\n\t\twdev->wext.connect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n#endif\n\t\tcfg80211_disconnect(rdev, dev,\n\t\t\t\t    WLAN_REASON_DEAUTH_LEAVING, true);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t__cfg80211_leave_mesh(rdev, dev);\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t__cfg80211_stop_ap(rdev, dev, -1, true);\n\t\tbreak;\n\tcase NL80211_IFTYPE_OCB:\n\t\t__cfg80211_leave_ocb(rdev, dev);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\tcase NL80211_IFTYPE_NAN:\n\t\t \n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MONITOR:\n\t\t \n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NUM_NL80211_IFTYPES:\n\t\t \n\t\tbreak;\n\t}\n}\n\nvoid cfg80211_leave(struct cfg80211_registered_device *rdev,\n\t\t    struct wireless_dev *wdev)\n{\n\twdev_lock(wdev);\n\t__cfg80211_leave(rdev, wdev);\n\twdev_unlock(wdev);\n}\n\nvoid cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct cfg80211_event *ev;\n\tunsigned long flags;\n\n\ttrace_cfg80211_stop_iface(wiphy, wdev);\n\n\tev = kzalloc(sizeof(*ev), gfp);\n\tif (!ev)\n\t\treturn;\n\n\tev->type = EVENT_STOPPED;\n\n\tspin_lock_irqsave(&wdev->event_lock, flags);\n\tlist_add_tail(&ev->list, &wdev->event_list);\n\tspin_unlock_irqrestore(&wdev->event_lock, flags);\n\tqueue_work(cfg80211_wq, &rdev->event_work);\n}\nEXPORT_SYMBOL(cfg80211_stop_iface);\n\nvoid cfg80211_init_wdev(struct wireless_dev *wdev)\n{\n\tmutex_init(&wdev->mtx);\n\tINIT_LIST_HEAD(&wdev->event_list);\n\tspin_lock_init(&wdev->event_lock);\n\tINIT_LIST_HEAD(&wdev->mgmt_registrations);\n\tINIT_LIST_HEAD(&wdev->pmsr_list);\n\tspin_lock_init(&wdev->pmsr_lock);\n\tINIT_WORK(&wdev->pmsr_free_wk, cfg80211_pmsr_free_wk);\n\n#ifdef CONFIG_CFG80211_WEXT\n\twdev->wext.default_key = -1;\n\twdev->wext.default_mgmt_key = -1;\n\twdev->wext.connect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n#endif\n\n\twiphy_work_init(&wdev->cqm_rssi_work, cfg80211_cqm_rssi_notify_work);\n\n\tif (wdev->wiphy->flags & WIPHY_FLAG_PS_ON_BY_DEFAULT)\n\t\twdev->ps = true;\n\telse\n\t\twdev->ps = false;\n\t \n\twdev->ps_timeout = -1;\n\n\tif ((wdev->iftype == NL80211_IFTYPE_STATION ||\n\t     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT ||\n\t     wdev->iftype == NL80211_IFTYPE_ADHOC) && !wdev->use_4addr)\n\t\twdev->netdev->priv_flags |= IFF_DONT_BRIDGE;\n\n\tINIT_WORK(&wdev->disconnect_wk, cfg80211_autodisconnect_wk);\n}\n\nvoid cfg80211_register_wdev(struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev)\n{\n\tASSERT_RTNL();\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\t \n\tif (!wdev->identifier)\n\t\twdev->identifier = ++rdev->wdev_id;\n\tlist_add_rcu(&wdev->list, &rdev->wiphy.wdev_list);\n\trdev->devlist_generation++;\n\twdev->registered = true;\n\n\tif (wdev->netdev &&\n\t    sysfs_create_link(&wdev->netdev->dev.kobj, &rdev->wiphy.dev.kobj,\n\t\t\t      \"phy80211\"))\n\t\tpr_err(\"failed to add phy80211 symlink to netdev!\\n\");\n\n\tnl80211_notify_iface(rdev, wdev, NL80211_CMD_NEW_INTERFACE);\n}\n\nint cfg80211_register_netdevice(struct net_device *dev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tif (WARN_ON(!wdev))\n\t\treturn -EINVAL;\n\n\trdev = wiphy_to_rdev(wdev->wiphy);\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\t \n\twdev->registered = true;\n\twdev->registering = true;\n\tret = register_netdevice(dev);\n\tif (ret)\n\t\tgoto out;\n\n\tcfg80211_register_wdev(rdev, wdev);\n\tret = 0;\nout:\n\twdev->registering = false;\n\tif (ret)\n\t\twdev->registered = false;\n\treturn ret;\n}\nEXPORT_SYMBOL(cfg80211_register_netdevice);\n\nstatic int cfg80211_netdev_notifier_call(struct notifier_block *nb,\n\t\t\t\t\t unsigned long state, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct cfg80211_sched_scan_request *pos, *tmp;\n\n\tif (!wdev)\n\t\treturn NOTIFY_DONE;\n\n\trdev = wiphy_to_rdev(wdev->wiphy);\n\n\tWARN_ON(wdev->iftype == NL80211_IFTYPE_UNSPECIFIED);\n\n\tswitch (state) {\n\tcase NETDEV_POST_INIT:\n\t\tSET_NETDEV_DEVTYPE(dev, &wiphy_type);\n\t\twdev->netdev = dev;\n\t\t \n\t\tdev->features |= NETIF_F_NETNS_LOCAL;\n\n\t\tcfg80211_init_wdev(wdev);\n\t\tbreak;\n\tcase NETDEV_REGISTER:\n\t\tif (!wdev->registered) {\n\t\t\twiphy_lock(&rdev->wiphy);\n\t\t\tcfg80211_register_wdev(rdev, wdev);\n\t\t\twiphy_unlock(&rdev->wiphy);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\t \n\t\tif (wdev->registered && !wdev->registering) {\n\t\t\twiphy_lock(&rdev->wiphy);\n\t\t\t_cfg80211_unregister_wdev(wdev, false);\n\t\t\twiphy_unlock(&rdev->wiphy);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_GOING_DOWN:\n\t\twiphy_lock(&rdev->wiphy);\n\t\tcfg80211_leave(rdev, wdev);\n\t\tcfg80211_remove_links(wdev);\n\t\twiphy_unlock(&rdev->wiphy);\n\t\t \n\t\tcancel_work_sync(&wdev->disconnect_wk);\n\t\tcancel_work_sync(&wdev->pmsr_free_wk);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\twiphy_lock(&rdev->wiphy);\n\t\tcfg80211_update_iface_num(rdev, wdev->iftype, -1);\n\t\tif (rdev->scan_req && rdev->scan_req->wdev == wdev) {\n\t\t\tif (WARN_ON(!rdev->scan_req->notified &&\n\t\t\t\t    (!rdev->int_scan_req ||\n\t\t\t\t     !rdev->int_scan_req->notified)))\n\t\t\t\trdev->scan_req->info.aborted = true;\n\t\t\t___cfg80211_scan_done(rdev, false);\n\t\t}\n\n\t\tlist_for_each_entry_safe(pos, tmp,\n\t\t\t\t\t &rdev->sched_scan_req_list, list) {\n\t\t\tif (WARN_ON(pos->dev == wdev->netdev))\n\t\t\t\tcfg80211_stop_sched_scan_req(rdev, pos, false);\n\t\t}\n\n\t\trdev->opencount--;\n\t\twiphy_unlock(&rdev->wiphy);\n\t\twake_up(&rdev->dev_wait);\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\twiphy_lock(&rdev->wiphy);\n\t\tcfg80211_update_iface_num(rdev, wdev->iftype, 1);\n\t\twdev_lock(wdev);\n\t\tswitch (wdev->iftype) {\n#ifdef CONFIG_CFG80211_WEXT\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tcfg80211_ibss_wext_join(rdev, wdev);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tcfg80211_mgd_wext_connect(rdev, wdev);\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_MAC80211_MESH\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\t{\n\t\t\t\t \n\t\t\t\tstruct mesh_setup setup;\n\t\t\t\tmemcpy(&setup, &default_mesh_setup,\n\t\t\t\t\t\tsizeof(setup));\n\t\t\t\t  \n\t\t\t\tsetup.mesh_id = wdev->u.mesh.id;\n\t\t\t\tsetup.mesh_id_len = wdev->u.mesh.id_up_len;\n\t\t\t\tif (wdev->u.mesh.id_up_len)\n\t\t\t\t\t__cfg80211_join_mesh(rdev, dev,\n\t\t\t\t\t\t\t&setup,\n\t\t\t\t\t\t\t&default_mesh_config);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\twdev_unlock(wdev);\n\t\trdev->opencount++;\n\n\t\t \n\t\tif ((wdev->iftype == NL80211_IFTYPE_STATION ||\n\t\t     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT) &&\n\t\t    rdev->ops->set_power_mgmt &&\n\t\t    rdev_set_power_mgmt(rdev, dev, wdev->ps,\n\t\t\t\t\twdev->ps_timeout)) {\n\t\t\t \n\t\t\twdev->ps = false;\n\t\t}\n\t\twiphy_unlock(&rdev->wiphy);\n\t\tbreak;\n\tcase NETDEV_PRE_UP:\n\t\tif (!cfg80211_iftype_allowed(wdev->wiphy, wdev->iftype,\n\t\t\t\t\t     wdev->use_4addr, 0))\n\t\t\treturn notifier_from_errno(-EOPNOTSUPP);\n\n\t\tif (rfkill_blocked(rdev->wiphy.rfkill))\n\t\t\treturn notifier_from_errno(-ERFKILL);\n\t\tbreak;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\twireless_nlevent_flush();\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block cfg80211_netdev_notifier = {\n\t.notifier_call = cfg80211_netdev_notifier_call,\n};\n\nstatic void __net_exit cfg80211_pernet_exit(struct net *net)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\trtnl_lock();\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (net_eq(wiphy_net(&rdev->wiphy), net))\n\t\t\tWARN_ON(cfg80211_switch_netns(rdev, &init_net));\n\t}\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations cfg80211_pernet_ops = {\n\t.exit = cfg80211_pernet_exit,\n};\n\nvoid wiphy_work_queue(struct wiphy *wiphy, struct wiphy_work *work)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->wiphy_work_lock, flags);\n\tif (list_empty(&work->entry))\n\t\tlist_add_tail(&work->entry, &rdev->wiphy_work_list);\n\tspin_unlock_irqrestore(&rdev->wiphy_work_lock, flags);\n\n\tqueue_work(system_unbound_wq, &rdev->wiphy_work);\n}\nEXPORT_SYMBOL_GPL(wiphy_work_queue);\n\nvoid wiphy_work_cancel(struct wiphy *wiphy, struct wiphy_work *work)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tunsigned long flags;\n\n\tlockdep_assert_held(&wiphy->mtx);\n\n\tspin_lock_irqsave(&rdev->wiphy_work_lock, flags);\n\tif (!list_empty(&work->entry))\n\t\tlist_del_init(&work->entry);\n\tspin_unlock_irqrestore(&rdev->wiphy_work_lock, flags);\n}\nEXPORT_SYMBOL_GPL(wiphy_work_cancel);\n\nvoid wiphy_work_flush(struct wiphy *wiphy, struct wiphy_work *work)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tunsigned long flags;\n\tbool run;\n\n\tspin_lock_irqsave(&rdev->wiphy_work_lock, flags);\n\trun = !work || !list_empty(&work->entry);\n\tspin_unlock_irqrestore(&rdev->wiphy_work_lock, flags);\n\n\tif (run)\n\t\tcfg80211_process_wiphy_works(rdev, work);\n}\nEXPORT_SYMBOL_GPL(wiphy_work_flush);\n\nvoid wiphy_delayed_work_timer(struct timer_list *t)\n{\n\tstruct wiphy_delayed_work *dwork = from_timer(dwork, t, timer);\n\n\twiphy_work_queue(dwork->wiphy, &dwork->work);\n}\nEXPORT_SYMBOL(wiphy_delayed_work_timer);\n\nvoid wiphy_delayed_work_queue(struct wiphy *wiphy,\n\t\t\t      struct wiphy_delayed_work *dwork,\n\t\t\t      unsigned long delay)\n{\n\tif (!delay) {\n\t\twiphy_work_queue(wiphy, &dwork->work);\n\t\treturn;\n\t}\n\n\tdwork->wiphy = wiphy;\n\tmod_timer(&dwork->timer, jiffies + delay);\n}\nEXPORT_SYMBOL_GPL(wiphy_delayed_work_queue);\n\nvoid wiphy_delayed_work_cancel(struct wiphy *wiphy,\n\t\t\t       struct wiphy_delayed_work *dwork)\n{\n\tlockdep_assert_held(&wiphy->mtx);\n\n\tdel_timer_sync(&dwork->timer);\n\twiphy_work_cancel(wiphy, &dwork->work);\n}\nEXPORT_SYMBOL_GPL(wiphy_delayed_work_cancel);\n\nvoid wiphy_delayed_work_flush(struct wiphy *wiphy,\n\t\t\t      struct wiphy_delayed_work *dwork)\n{\n\tlockdep_assert_held(&wiphy->mtx);\n\n\tdel_timer_sync(&dwork->timer);\n\twiphy_work_flush(wiphy, &dwork->work);\n}\nEXPORT_SYMBOL_GPL(wiphy_delayed_work_flush);\n\nstatic int __init cfg80211_init(void)\n{\n\tint err;\n\n\terr = register_pernet_device(&cfg80211_pernet_ops);\n\tif (err)\n\t\tgoto out_fail_pernet;\n\n\terr = wiphy_sysfs_init();\n\tif (err)\n\t\tgoto out_fail_sysfs;\n\n\terr = register_netdevice_notifier(&cfg80211_netdev_notifier);\n\tif (err)\n\t\tgoto out_fail_notifier;\n\n\terr = nl80211_init();\n\tif (err)\n\t\tgoto out_fail_nl80211;\n\n\tieee80211_debugfs_dir = debugfs_create_dir(\"ieee80211\", NULL);\n\n\terr = regulatory_init();\n\tif (err)\n\t\tgoto out_fail_reg;\n\n\tcfg80211_wq = alloc_ordered_workqueue(\"cfg80211\", WQ_MEM_RECLAIM);\n\tif (!cfg80211_wq) {\n\t\terr = -ENOMEM;\n\t\tgoto out_fail_wq;\n\t}\n\n\treturn 0;\n\nout_fail_wq:\n\tregulatory_exit();\nout_fail_reg:\n\tdebugfs_remove(ieee80211_debugfs_dir);\n\tnl80211_exit();\nout_fail_nl80211:\n\tunregister_netdevice_notifier(&cfg80211_netdev_notifier);\nout_fail_notifier:\n\twiphy_sysfs_exit();\nout_fail_sysfs:\n\tunregister_pernet_device(&cfg80211_pernet_ops);\nout_fail_pernet:\n\treturn err;\n}\nfs_initcall(cfg80211_init);\n\nstatic void __exit cfg80211_exit(void)\n{\n\tdebugfs_remove(ieee80211_debugfs_dir);\n\tnl80211_exit();\n\tunregister_netdevice_notifier(&cfg80211_netdev_notifier);\n\twiphy_sysfs_exit();\n\tregulatory_exit();\n\tunregister_pernet_device(&cfg80211_pernet_ops);\n\tdestroy_workqueue(cfg80211_wq);\n}\nmodule_exit(cfg80211_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}