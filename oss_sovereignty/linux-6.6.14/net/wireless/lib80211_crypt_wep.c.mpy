{
  "module_name": "lib80211_crypt_wep.c",
  "hash_id": "9048c53dc0df94050c0961da4499293de11092387744d47c2dd9cd4723d89f5c",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/lib80211_crypt_wep.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/fips.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/skbuff.h>\n#include <linux/mm.h>\n#include <asm/string.h>\n\n#include <net/lib80211.h>\n\n#include <crypto/arc4.h>\n#include <linux/crc32.h>\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"lib80211 crypt: WEP\");\nMODULE_LICENSE(\"GPL\");\n\nstruct lib80211_wep_data {\n\tu32 iv;\n#define WEP_KEY_LEN 13\n\tu8 key[WEP_KEY_LEN + 1];\n\tu8 key_len;\n\tu8 key_idx;\n\tstruct arc4_ctx tx_ctx;\n\tstruct arc4_ctx rx_ctx;\n};\n\nstatic void *lib80211_wep_init(int keyidx)\n{\n\tstruct lib80211_wep_data *priv;\n\n\tif (fips_enabled)\n\t\treturn NULL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_ATOMIC);\n\tif (priv == NULL)\n\t\treturn NULL;\n\tpriv->key_idx = keyidx;\n\n\t \n\tget_random_bytes(&priv->iv, 4);\n\n\treturn priv;\n}\n\nstatic void lib80211_wep_deinit(void *priv)\n{\n\tkfree_sensitive(priv);\n}\n\n \nstatic int lib80211_wep_build_iv(struct sk_buff *skb, int hdr_len,\n\t\t\t       u8 *key, int keylen, void *priv)\n{\n\tstruct lib80211_wep_data *wep = priv;\n\tu32 klen;\n\tu8 *pos;\n\n\tif (skb_headroom(skb) < 4 || skb->len < hdr_len)\n\t\treturn -1;\n\n\tpos = skb_push(skb, 4);\n\tmemmove(pos, pos + 4, hdr_len);\n\tpos += hdr_len;\n\n\tklen = 3 + wep->key_len;\n\n\twep->iv++;\n\n\t \n\tif ((wep->iv & 0xff00) == 0xff00) {\n\t\tu8 B = (wep->iv >> 16) & 0xff;\n\t\tif (B >= 3 && B < klen)\n\t\t\twep->iv += 0x0100;\n\t}\n\n\t \n\t*pos++ = (wep->iv >> 16) & 0xff;\n\t*pos++ = (wep->iv >> 8) & 0xff;\n\t*pos++ = wep->iv & 0xff;\n\t*pos++ = wep->key_idx << 6;\n\n\treturn 0;\n}\n\n \nstatic int lib80211_wep_encrypt(struct sk_buff *skb, int hdr_len, void *priv)\n{\n\tstruct lib80211_wep_data *wep = priv;\n\tu32 crc, klen, len;\n\tu8 *pos, *icv;\n\tu8 key[WEP_KEY_LEN + 3];\n\n\t \n\tif (skb_tailroom(skb) < 4)\n\t\treturn -1;\n\n\t \n\tif (lib80211_wep_build_iv(skb, hdr_len, NULL, 0, priv))\n\t\treturn -1;\n\n\t \n\tskb_copy_from_linear_data_offset(skb, hdr_len, key, 3);\n\n\t \n\tmemcpy(key + 3, wep->key, wep->key_len);\n\n\tlen = skb->len - hdr_len - 4;\n\tpos = skb->data + hdr_len + 4;\n\tklen = 3 + wep->key_len;\n\n\t \n\tcrc = ~crc32_le(~0, pos, len);\n\ticv = skb_put(skb, 4);\n\ticv[0] = crc;\n\ticv[1] = crc >> 8;\n\ticv[2] = crc >> 16;\n\ticv[3] = crc >> 24;\n\n\tarc4_setkey(&wep->tx_ctx, key, klen);\n\tarc4_crypt(&wep->tx_ctx, pos, pos, len + 4);\n\n\treturn 0;\n}\n\n \nstatic int lib80211_wep_decrypt(struct sk_buff *skb, int hdr_len, void *priv)\n{\n\tstruct lib80211_wep_data *wep = priv;\n\tu32 crc, klen, plen;\n\tu8 key[WEP_KEY_LEN + 3];\n\tu8 keyidx, *pos, icv[4];\n\n\tif (skb->len < hdr_len + 8)\n\t\treturn -1;\n\n\tpos = skb->data + hdr_len;\n\tkey[0] = *pos++;\n\tkey[1] = *pos++;\n\tkey[2] = *pos++;\n\tkeyidx = *pos++ >> 6;\n\tif (keyidx != wep->key_idx)\n\t\treturn -1;\n\n\tklen = 3 + wep->key_len;\n\n\t \n\tmemcpy(key + 3, wep->key, wep->key_len);\n\n\t \n\tplen = skb->len - hdr_len - 8;\n\n\tarc4_setkey(&wep->rx_ctx, key, klen);\n\tarc4_crypt(&wep->rx_ctx, pos, pos, plen + 4);\n\n\tcrc = ~crc32_le(~0, pos, plen);\n\ticv[0] = crc;\n\ticv[1] = crc >> 8;\n\ticv[2] = crc >> 16;\n\ticv[3] = crc >> 24;\n\tif (memcmp(icv, pos + plen, 4) != 0) {\n\t\t \n\t\treturn -2;\n\t}\n\n\t \n\tmemmove(skb->data + 4, skb->data, hdr_len);\n\tskb_pull(skb, 4);\n\tskb_trim(skb, skb->len - 4);\n\n\treturn 0;\n}\n\nstatic int lib80211_wep_set_key(void *key, int len, u8 * seq, void *priv)\n{\n\tstruct lib80211_wep_data *wep = priv;\n\n\tif (len < 0 || len > WEP_KEY_LEN)\n\t\treturn -1;\n\n\tmemcpy(wep->key, key, len);\n\twep->key_len = len;\n\n\treturn 0;\n}\n\nstatic int lib80211_wep_get_key(void *key, int len, u8 * seq, void *priv)\n{\n\tstruct lib80211_wep_data *wep = priv;\n\n\tif (len < wep->key_len)\n\t\treturn -1;\n\n\tmemcpy(key, wep->key, wep->key_len);\n\n\treturn wep->key_len;\n}\n\nstatic void lib80211_wep_print_stats(struct seq_file *m, void *priv)\n{\n\tstruct lib80211_wep_data *wep = priv;\n\tseq_printf(m, \"key[%d] alg=WEP len=%d\\n\", wep->key_idx, wep->key_len);\n}\n\nstatic struct lib80211_crypto_ops lib80211_crypt_wep = {\n\t.name = \"WEP\",\n\t.init = lib80211_wep_init,\n\t.deinit = lib80211_wep_deinit,\n\t.encrypt_mpdu = lib80211_wep_encrypt,\n\t.decrypt_mpdu = lib80211_wep_decrypt,\n\t.encrypt_msdu = NULL,\n\t.decrypt_msdu = NULL,\n\t.set_key = lib80211_wep_set_key,\n\t.get_key = lib80211_wep_get_key,\n\t.print_stats = lib80211_wep_print_stats,\n\t.extra_mpdu_prefix_len = 4,\t \n\t.extra_mpdu_postfix_len = 4,\t \n\t.owner = THIS_MODULE,\n};\n\nstatic int __init lib80211_crypto_wep_init(void)\n{\n\treturn lib80211_register_crypto_ops(&lib80211_crypt_wep);\n}\n\nstatic void __exit lib80211_crypto_wep_exit(void)\n{\n\tlib80211_unregister_crypto_ops(&lib80211_crypt_wep);\n}\n\nmodule_init(lib80211_crypto_wep_init);\nmodule_exit(lib80211_crypto_wep_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}