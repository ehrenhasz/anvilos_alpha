{
  "module_name": "mlme.c",
  "hash_id": "4aeffafbaee79115646364b90fbc2a75b0b6d1b2ada6d41a3d2a4e1d68648dd9",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/mlme.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/nl80211.h>\n#include <linux/slab.h>\n#include <linux/wireless.h>\n#include <net/cfg80211.h>\n#include <net/iw_handler.h>\n#include \"core.h\"\n#include \"nl80211.h\"\n#include \"rdev-ops.h\"\n\n\nvoid cfg80211_rx_assoc_resp(struct net_device *dev,\n\t\t\t    struct cfg80211_rx_assoc_resp *data)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)data->buf;\n\tstruct cfg80211_connect_resp_params cr = {\n\t\t.timeout_reason = NL80211_TIMEOUT_UNSPECIFIED,\n\t\t.req_ie = data->req_ies,\n\t\t.req_ie_len = data->req_ies_len,\n\t\t.resp_ie = mgmt->u.assoc_resp.variable,\n\t\t.resp_ie_len = data->len -\n\t\t\t       offsetof(struct ieee80211_mgmt,\n\t\t\t\t\tu.assoc_resp.variable),\n\t\t.status = le16_to_cpu(mgmt->u.assoc_resp.status_code),\n\t\t.ap_mld_addr = data->ap_mld_addr,\n\t};\n\tunsigned int link_id;\n\n\tfor (link_id = 0; link_id < ARRAY_SIZE(data->links); link_id++) {\n\t\tcr.links[link_id].status = data->links[link_id].status;\n\t\tcr.links[link_id].bss = data->links[link_id].bss;\n\n\t\tWARN_ON_ONCE(cr.links[link_id].status != WLAN_STATUS_SUCCESS &&\n\t\t\t     (!cr.ap_mld_addr || !cr.links[link_id].bss));\n\n\t\tif (!cr.links[link_id].bss)\n\t\t\tcontinue;\n\t\tcr.links[link_id].bssid = data->links[link_id].bss->bssid;\n\t\tcr.links[link_id].addr = data->links[link_id].addr;\n\t\t \n\t\tWARN_ON(cr.ap_mld_addr &&\n\t\t\t!is_valid_ether_addr(cr.links[link_id].addr));\n\n\t\tBUG_ON(!cr.links[link_id].bss->channel);\n\n\t\tif (cr.links[link_id].bss->channel->band == NL80211_BAND_S1GHZ) {\n\t\t\tWARN_ON(link_id);\n\t\t\tcr.resp_ie = (u8 *)&mgmt->u.s1g_assoc_resp.variable;\n\t\t\tcr.resp_ie_len = data->len -\n\t\t\t\t\t offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t\t  u.s1g_assoc_resp.variable);\n\t\t}\n\n\t\tif (cr.ap_mld_addr)\n\t\t\tcr.valid_links |= BIT(link_id);\n\t}\n\n\ttrace_cfg80211_send_rx_assoc(dev, data);\n\n\t \n\tif (cfg80211_sme_rx_assoc_resp(wdev, cr.status)) {\n\t\tfor (link_id = 0; link_id < ARRAY_SIZE(data->links); link_id++) {\n\t\t\tstruct cfg80211_bss *bss = data->links[link_id].bss;\n\n\t\t\tif (!bss)\n\t\t\t\tcontinue;\n\n\t\t\tcfg80211_unhold_bss(bss_from_pub(bss));\n\t\t\tcfg80211_put_bss(wiphy, bss);\n\t\t}\n\t\treturn;\n\t}\n\n\tnl80211_send_rx_assoc(rdev, dev, data);\n\t \n\t__cfg80211_connect_result(dev, &cr, cr.status == WLAN_STATUS_SUCCESS);\n}\nEXPORT_SYMBOL(cfg80211_rx_assoc_resp);\n\nstatic void cfg80211_process_auth(struct wireless_dev *wdev,\n\t\t\t\t  const u8 *buf, size_t len)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\n\tnl80211_send_rx_auth(rdev, wdev->netdev, buf, len, GFP_KERNEL);\n\tcfg80211_sme_rx_auth(wdev, buf, len);\n}\n\nstatic void cfg80211_process_deauth(struct wireless_dev *wdev,\n\t\t\t\t    const u8 *buf, size_t len,\n\t\t\t\t    bool reconnect)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;\n\tconst u8 *bssid = mgmt->bssid;\n\tu16 reason_code = le16_to_cpu(mgmt->u.deauth.reason_code);\n\tbool from_ap = !ether_addr_equal(mgmt->sa, wdev->netdev->dev_addr);\n\n\tnl80211_send_deauth(rdev, wdev->netdev, buf, len, reconnect, GFP_KERNEL);\n\n\tif (!wdev->connected || !ether_addr_equal(wdev->u.client.connected_addr, bssid))\n\t\treturn;\n\n\t__cfg80211_disconnected(wdev->netdev, NULL, 0, reason_code, from_ap);\n\tcfg80211_sme_deauth(wdev);\n}\n\nstatic void cfg80211_process_disassoc(struct wireless_dev *wdev,\n\t\t\t\t      const u8 *buf, size_t len,\n\t\t\t\t      bool reconnect)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;\n\tconst u8 *bssid = mgmt->bssid;\n\tu16 reason_code = le16_to_cpu(mgmt->u.disassoc.reason_code);\n\tbool from_ap = !ether_addr_equal(mgmt->sa, wdev->netdev->dev_addr);\n\n\tnl80211_send_disassoc(rdev, wdev->netdev, buf, len, reconnect,\n\t\t\t      GFP_KERNEL);\n\n\tif (WARN_ON(!wdev->connected ||\n\t\t    !ether_addr_equal(wdev->u.client.connected_addr, bssid)))\n\t\treturn;\n\n\t__cfg80211_disconnected(wdev->netdev, NULL, 0, reason_code, from_ap);\n\tcfg80211_sme_disassoc(wdev);\n}\n\nvoid cfg80211_rx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct ieee80211_mgmt *mgmt = (void *)buf;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\ttrace_cfg80211_rx_mlme_mgmt(dev, buf, len);\n\n\tif (WARN_ON(len < 2))\n\t\treturn;\n\n\tif (ieee80211_is_auth(mgmt->frame_control))\n\t\tcfg80211_process_auth(wdev, buf, len);\n\telse if (ieee80211_is_deauth(mgmt->frame_control))\n\t\tcfg80211_process_deauth(wdev, buf, len, false);\n\telse if (ieee80211_is_disassoc(mgmt->frame_control))\n\t\tcfg80211_process_disassoc(wdev, buf, len, false);\n}\nEXPORT_SYMBOL(cfg80211_rx_mlme_mgmt);\n\nvoid cfg80211_auth_timeout(struct net_device *dev, const u8 *addr)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_send_auth_timeout(dev, addr);\n\n\tnl80211_send_auth_timeout(rdev, dev, addr, GFP_KERNEL);\n\tcfg80211_sme_auth_timeout(wdev);\n}\nEXPORT_SYMBOL(cfg80211_auth_timeout);\n\nvoid cfg80211_assoc_failure(struct net_device *dev,\n\t\t\t    struct cfg80211_assoc_failure *data)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tconst u8 *addr = data->ap_mld_addr ?: data->bss[0]->bssid;\n\tint i;\n\n\ttrace_cfg80211_send_assoc_failure(dev, data);\n\n\tif (data->timeout) {\n\t\tnl80211_send_assoc_timeout(rdev, dev, addr, GFP_KERNEL);\n\t\tcfg80211_sme_assoc_timeout(wdev);\n\t} else {\n\t\tcfg80211_sme_abandon_assoc(wdev);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data->bss); i++) {\n\t\tstruct cfg80211_bss *bss = data->bss[i];\n\n\t\tif (!bss)\n\t\t\tcontinue;\n\n\t\tcfg80211_unhold_bss(bss_from_pub(bss));\n\t\tcfg80211_put_bss(wiphy, bss);\n\t}\n}\nEXPORT_SYMBOL(cfg80211_assoc_failure);\n\nvoid cfg80211_tx_mlme_mgmt(struct net_device *dev, const u8 *buf, size_t len,\n\t\t\t   bool reconnect)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct ieee80211_mgmt *mgmt = (void *)buf;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\ttrace_cfg80211_tx_mlme_mgmt(dev, buf, len, reconnect);\n\n\tif (WARN_ON(len < 2))\n\t\treturn;\n\n\tif (ieee80211_is_deauth(mgmt->frame_control))\n\t\tcfg80211_process_deauth(wdev, buf, len, reconnect);\n\telse\n\t\tcfg80211_process_disassoc(wdev, buf, len, reconnect);\n}\nEXPORT_SYMBOL(cfg80211_tx_mlme_mgmt);\n\nvoid cfg80211_michael_mic_failure(struct net_device *dev, const u8 *addr,\n\t\t\t\t  enum nl80211_key_type key_type, int key_id,\n\t\t\t\t  const u8 *tsc, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n#ifdef CONFIG_CFG80211_WEXT\n\tunion iwreq_data wrqu;\n\tchar *buf = kmalloc(128, gfp);\n\n\tif (buf) {\n\t\tsprintf(buf, \"MLME-MICHAELMICFAILURE.indication(\"\n\t\t\t\"keyid=%d %scast addr=%pM)\", key_id,\n\t\t\tkey_type == NL80211_KEYTYPE_GROUP ? \"broad\" : \"uni\",\n\t\t\taddr);\n\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\t\twrqu.data.length = strlen(buf);\n\t\twireless_send_event(dev, IWEVCUSTOM, &wrqu, buf);\n\t\tkfree(buf);\n\t}\n#endif\n\n\ttrace_cfg80211_michael_mic_failure(dev, addr, key_type, key_id, tsc);\n\tnl80211_michael_mic_failure(rdev, dev, addr, key_type, key_id, tsc, gfp);\n}\nEXPORT_SYMBOL(cfg80211_michael_mic_failure);\n\n \nint cfg80211_mlme_auth(struct cfg80211_registered_device *rdev,\n\t\t       struct net_device *dev,\n\t\t       struct cfg80211_auth_request *req)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!req->bss)\n\t\treturn -ENOENT;\n\n\tif (req->link_id >= 0 &&\n\t    !(wdev->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO))\n\t\treturn -EINVAL;\n\n\tif (req->auth_type == NL80211_AUTHTYPE_SHARED_KEY) {\n\t\tif (!req->key || !req->key_len ||\n\t\t    req->key_idx < 0 || req->key_idx > 3)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (wdev->connected &&\n\t    ether_addr_equal(req->bss->bssid, wdev->u.client.connected_addr))\n\t\treturn -EALREADY;\n\n\tif (ether_addr_equal(req->bss->bssid, dev->dev_addr) ||\n\t    (req->link_id >= 0 &&\n\t     ether_addr_equal(req->ap_mld_addr, dev->dev_addr)))\n\t\treturn -EINVAL;\n\n\treturn rdev_auth(rdev, dev, req);\n}\n\n \nvoid cfg80211_oper_and_ht_capa(struct ieee80211_ht_cap *ht_capa,\n\t\t\t       const struct ieee80211_ht_cap *ht_capa_mask)\n{\n\tint i;\n\tu8 *p1, *p2;\n\tif (!ht_capa_mask) {\n\t\tmemset(ht_capa, 0, sizeof(*ht_capa));\n\t\treturn;\n\t}\n\n\tp1 = (u8*)(ht_capa);\n\tp2 = (u8*)(ht_capa_mask);\n\tfor (i = 0; i < sizeof(*ht_capa); i++)\n\t\tp1[i] &= p2[i];\n}\n\n \nvoid cfg80211_oper_and_vht_capa(struct ieee80211_vht_cap *vht_capa,\n\t\t\t\tconst struct ieee80211_vht_cap *vht_capa_mask)\n{\n\tint i;\n\tu8 *p1, *p2;\n\tif (!vht_capa_mask) {\n\t\tmemset(vht_capa, 0, sizeof(*vht_capa));\n\t\treturn;\n\t}\n\n\tp1 = (u8*)(vht_capa);\n\tp2 = (u8*)(vht_capa_mask);\n\tfor (i = 0; i < sizeof(*vht_capa); i++)\n\t\tp1[i] &= p2[i];\n}\n\n \nint cfg80211_mlme_assoc(struct cfg80211_registered_device *rdev,\n\t\t\tstruct net_device *dev,\n\t\t\tstruct cfg80211_assoc_request *req)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err, i, j;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tfor (i = 1; i < ARRAY_SIZE(req->links); i++) {\n\t\tif (!req->links[i].bss)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (req->links[i].bss == req->links[j].bss)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ether_addr_equal(req->links[i].bss->bssid, dev->dev_addr))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (wdev->connected &&\n\t    (!req->prev_bssid ||\n\t     !ether_addr_equal(wdev->u.client.connected_addr, req->prev_bssid)))\n\t\treturn -EALREADY;\n\n\tif ((req->bss && ether_addr_equal(req->bss->bssid, dev->dev_addr)) ||\n\t    (req->link_id >= 0 &&\n\t     ether_addr_equal(req->ap_mld_addr, dev->dev_addr)))\n\t\treturn -EINVAL;\n\n\tcfg80211_oper_and_ht_capa(&req->ht_capa_mask,\n\t\t\t\t  rdev->wiphy.ht_capa_mod_mask);\n\tcfg80211_oper_and_vht_capa(&req->vht_capa_mask,\n\t\t\t\t   rdev->wiphy.vht_capa_mod_mask);\n\n\terr = rdev_assoc(rdev, dev, req);\n\tif (!err) {\n\t\tint link_id;\n\n\t\tif (req->bss) {\n\t\t\tcfg80211_ref_bss(&rdev->wiphy, req->bss);\n\t\t\tcfg80211_hold_bss(bss_from_pub(req->bss));\n\t\t}\n\n\t\tfor (link_id = 0; link_id < ARRAY_SIZE(req->links); link_id++) {\n\t\t\tif (!req->links[link_id].bss)\n\t\t\t\tcontinue;\n\t\t\tcfg80211_ref_bss(&rdev->wiphy, req->links[link_id].bss);\n\t\t\tcfg80211_hold_bss(bss_from_pub(req->links[link_id].bss));\n\t\t}\n\t}\n\treturn err;\n}\n\nint cfg80211_mlme_deauth(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *dev, const u8 *bssid,\n\t\t\t const u8 *ie, int ie_len, u16 reason,\n\t\t\t bool local_state_change)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_deauth_request req = {\n\t\t.bssid = bssid,\n\t\t.reason_code = reason,\n\t\t.ie = ie,\n\t\t.ie_len = ie_len,\n\t\t.local_state_change = local_state_change,\n\t};\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (local_state_change &&\n\t    (!wdev->connected ||\n\t     !ether_addr_equal(wdev->u.client.connected_addr, bssid)))\n\t\treturn 0;\n\n\tif (ether_addr_equal(wdev->disconnect_bssid, bssid) ||\n\t    (wdev->connected &&\n\t     ether_addr_equal(wdev->u.client.connected_addr, bssid)))\n\t\twdev->conn_owner_nlportid = 0;\n\n\treturn rdev_deauth(rdev, dev, &req);\n}\n\nint cfg80211_mlme_disassoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *dev, const u8 *ap_addr,\n\t\t\t   const u8 *ie, int ie_len, u16 reason,\n\t\t\t   bool local_state_change)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_disassoc_request req = {\n\t\t.reason_code = reason,\n\t\t.local_state_change = local_state_change,\n\t\t.ie = ie,\n\t\t.ie_len = ie_len,\n\t\t.ap_addr = ap_addr,\n\t};\n\tint err;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!wdev->connected)\n\t\treturn -ENOTCONN;\n\n\tif (memcmp(wdev->u.client.connected_addr, ap_addr, ETH_ALEN))\n\t\treturn -ENOTCONN;\n\n\terr = rdev_disassoc(rdev, dev, &req);\n\tif (err)\n\t\treturn err;\n\n\t \n\tWARN_ON(wdev->connected);\n\treturn 0;\n}\n\nvoid cfg80211_mlme_down(struct cfg80211_registered_device *rdev,\n\t\t\tstruct net_device *dev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tu8 bssid[ETH_ALEN];\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!rdev->ops->deauth)\n\t\treturn;\n\n\tif (!wdev->connected)\n\t\treturn;\n\n\tmemcpy(bssid, wdev->u.client.connected_addr, ETH_ALEN);\n\tcfg80211_mlme_deauth(rdev, dev, bssid, NULL, 0,\n\t\t\t     WLAN_REASON_DEAUTH_LEAVING, false);\n}\n\nstruct cfg80211_mgmt_registration {\n\tstruct list_head list;\n\tstruct wireless_dev *wdev;\n\n\tu32 nlportid;\n\n\tint match_len;\n\n\t__le16 frame_type;\n\n\tbool multicast_rx;\n\n\tu8 match[];\n};\n\nstatic void cfg80211_mgmt_registrations_update(struct wireless_dev *wdev)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct wireless_dev *tmp;\n\tstruct cfg80211_mgmt_registration *reg;\n\tstruct mgmt_frame_regs upd = {};\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\tspin_lock_bh(&rdev->mgmt_registrations_lock);\n\tif (!wdev->mgmt_registrations_need_update) {\n\t\tspin_unlock_bh(&rdev->mgmt_registrations_lock);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(tmp, &rdev->wiphy.wdev_list, list) {\n\t\tlist_for_each_entry(reg, &tmp->mgmt_registrations, list) {\n\t\t\tu32 mask = BIT(le16_to_cpu(reg->frame_type) >> 4);\n\t\t\tu32 mcast_mask = 0;\n\n\t\t\tif (reg->multicast_rx)\n\t\t\t\tmcast_mask = mask;\n\n\t\t\tupd.global_stypes |= mask;\n\t\t\tupd.global_mcast_stypes |= mcast_mask;\n\n\t\t\tif (tmp == wdev) {\n\t\t\t\tupd.interface_stypes |= mask;\n\t\t\t\tupd.interface_mcast_stypes |= mcast_mask;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\twdev->mgmt_registrations_need_update = 0;\n\tspin_unlock_bh(&rdev->mgmt_registrations_lock);\n\n\trdev_update_mgmt_frame_registrations(rdev, wdev, &upd);\n}\n\nvoid cfg80211_mgmt_registrations_update_wk(struct work_struct *wk)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\n\trdev = container_of(wk, struct cfg80211_registered_device,\n\t\t\t    mgmt_registrations_update_wk);\n\n\twiphy_lock(&rdev->wiphy);\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list)\n\t\tcfg80211_mgmt_registrations_update(wdev);\n\twiphy_unlock(&rdev->wiphy);\n}\n\nint cfg80211_mlme_register_mgmt(struct wireless_dev *wdev, u32 snd_portid,\n\t\t\t\tu16 frame_type, const u8 *match_data,\n\t\t\t\tint match_len, bool multicast_rx,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_mgmt_registration *reg, *nreg;\n\tint err = 0;\n\tu16 mgmt_type;\n\tbool update_multicast = false;\n\n\tif (!wdev->wiphy->mgmt_stypes)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((frame_type & IEEE80211_FCTL_FTYPE) != IEEE80211_FTYPE_MGMT) {\n\t\tNL_SET_ERR_MSG(extack, \"frame type not management\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (frame_type & ~(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE)) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid frame type\");\n\t\treturn -EINVAL;\n\t}\n\n\tmgmt_type = (frame_type & IEEE80211_FCTL_STYPE) >> 4;\n\tif (!(wdev->wiphy->mgmt_stypes[wdev->iftype].rx & BIT(mgmt_type))) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Registration to specific type not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (wdev->iftype == NL80211_IFTYPE_STATION &&\n\t    (frame_type & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_AUTH &&\n\t    !(match_data && match_len >= 2)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Authentication algorithm number required\");\n\t\treturn -EINVAL;\n\t}\n\n\tnreg = kzalloc(sizeof(*reg) + match_len, GFP_KERNEL);\n\tif (!nreg)\n\t\treturn -ENOMEM;\n\n\tspin_lock_bh(&rdev->mgmt_registrations_lock);\n\n\tlist_for_each_entry(reg, &wdev->mgmt_registrations, list) {\n\t\tint mlen = min(match_len, reg->match_len);\n\n\t\tif (frame_type != le16_to_cpu(reg->frame_type))\n\t\t\tcontinue;\n\n\t\tif (memcmp(reg->match, match_data, mlen) == 0) {\n\t\t\tif (reg->multicast_rx != multicast_rx) {\n\t\t\t\tupdate_multicast = true;\n\t\t\t\treg->multicast_rx = multicast_rx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tNL_SET_ERR_MSG(extack, \"Match already configured\");\n\t\t\terr = -EALREADY;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (err)\n\t\tgoto out;\n\n\tif (update_multicast) {\n\t\tkfree(nreg);\n\t} else {\n\t\tmemcpy(nreg->match, match_data, match_len);\n\t\tnreg->match_len = match_len;\n\t\tnreg->nlportid = snd_portid;\n\t\tnreg->frame_type = cpu_to_le16(frame_type);\n\t\tnreg->wdev = wdev;\n\t\tnreg->multicast_rx = multicast_rx;\n\t\tlist_add(&nreg->list, &wdev->mgmt_registrations);\n\t}\n\twdev->mgmt_registrations_need_update = 1;\n\tspin_unlock_bh(&rdev->mgmt_registrations_lock);\n\n\tcfg80211_mgmt_registrations_update(wdev);\n\n\treturn 0;\n\n out:\n\tkfree(nreg);\n\tspin_unlock_bh(&rdev->mgmt_registrations_lock);\n\n\treturn err;\n}\n\nvoid cfg80211_mlme_unregister_socket(struct wireless_dev *wdev, u32 nlportid)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct cfg80211_mgmt_registration *reg, *tmp;\n\n\tspin_lock_bh(&rdev->mgmt_registrations_lock);\n\n\tlist_for_each_entry_safe(reg, tmp, &wdev->mgmt_registrations, list) {\n\t\tif (reg->nlportid != nlportid)\n\t\t\tcontinue;\n\n\t\tlist_del(&reg->list);\n\t\tkfree(reg);\n\n\t\twdev->mgmt_registrations_need_update = 1;\n\t\tschedule_work(&rdev->mgmt_registrations_update_wk);\n\t}\n\n\tspin_unlock_bh(&rdev->mgmt_registrations_lock);\n\n\tif (nlportid && rdev->crit_proto_nlportid == nlportid) {\n\t\trdev->crit_proto_nlportid = 0;\n\t\trdev_crit_proto_stop(rdev, wdev);\n\t}\n\n\tif (nlportid == wdev->ap_unexpected_nlportid)\n\t\twdev->ap_unexpected_nlportid = 0;\n}\n\nvoid cfg80211_mlme_purge_registrations(struct wireless_dev *wdev)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_mgmt_registration *reg, *tmp;\n\n\tspin_lock_bh(&rdev->mgmt_registrations_lock);\n\tlist_for_each_entry_safe(reg, tmp, &wdev->mgmt_registrations, list) {\n\t\tlist_del(&reg->list);\n\t\tkfree(reg);\n\t}\n\twdev->mgmt_registrations_need_update = 1;\n\tspin_unlock_bh(&rdev->mgmt_registrations_lock);\n\n\tcfg80211_mgmt_registrations_update(wdev);\n}\n\nstatic bool cfg80211_allowed_address(struct wireless_dev *wdev, const u8 *addr)\n{\n\tint i;\n\n\tfor_each_valid_link(wdev, i) {\n\t\tif (ether_addr_equal(addr, wdev->links[i].addr))\n\t\t\treturn true;\n\t}\n\n\treturn ether_addr_equal(addr, wdev_address(wdev));\n}\n\nstatic bool cfg80211_allowed_random_address(struct wireless_dev *wdev,\n\t\t\t\t\t    const struct ieee80211_mgmt *mgmt)\n{\n\tif (ieee80211_is_auth(mgmt->frame_control) ||\n\t    ieee80211_is_deauth(mgmt->frame_control)) {\n\t\t \n\t\tif (wiphy_ext_feature_isset(\n\t\t\t    wdev->wiphy,\n\t\t\t    NL80211_EXT_FEATURE_AUTH_AND_DEAUTH_RANDOM_TA))\n\t\t\treturn true;\n\t} else if (ieee80211_is_action(mgmt->frame_control) &&\n\t\t   mgmt->u.action.category == WLAN_CATEGORY_PUBLIC) {\n\t\t \n\t\tif (!wdev->connected &&\n\t\t    wiphy_ext_feature_isset(\n\t\t\t    wdev->wiphy,\n\t\t\t    NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA))\n\t\t\treturn true;\n\n\t\tif (wdev->connected &&\n\t\t    wiphy_ext_feature_isset(\n\t\t\t    wdev->wiphy,\n\t\t\t    NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint cfg80211_mlme_mgmt_tx(struct cfg80211_registered_device *rdev,\n\t\t\t  struct wireless_dev *wdev,\n\t\t\t  struct cfg80211_mgmt_tx_params *params, u64 *cookie)\n{\n\tconst struct ieee80211_mgmt *mgmt;\n\tu16 stype;\n\n\tif (!wdev->wiphy->mgmt_stypes)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tif (params->len < 24 + 1)\n\t\treturn -EINVAL;\n\n\tmgmt = (const struct ieee80211_mgmt *)params->buf;\n\n\tif (!ieee80211_is_mgmt(mgmt->frame_control))\n\t\treturn -EINVAL;\n\n\tstype = le16_to_cpu(mgmt->frame_control) & IEEE80211_FCTL_STYPE;\n\tif (!(wdev->wiphy->mgmt_stypes[wdev->iftype].tx & BIT(stype >> 4)))\n\t\treturn -EINVAL;\n\n\tif (ieee80211_is_action(mgmt->frame_control) &&\n\t    mgmt->u.action.category != WLAN_CATEGORY_PUBLIC) {\n\t\tint err = 0;\n\n\t\twdev_lock(wdev);\n\n\t\tswitch (wdev->iftype) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\t \n\t\t\tif (!wdev->u.ibss.current_bss ||\n\t\t\t    !ether_addr_equal(wdev->u.ibss.current_bss->pub.bssid,\n\t\t\t\t\t      mgmt->bssid)) {\n\t\t\t\terr = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t\tif (!wdev->connected) {\n\t\t\t\terr = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (!ether_addr_equal(wdev->u.client.connected_addr,\n\t\t\t\t\t      mgmt->bssid)) {\n\t\t\t\terr = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!ether_addr_equal(wdev->u.client.connected_addr,\n\t\t\t\t\t      mgmt->da)) {\n\t\t\t\terr = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t\tif (!ether_addr_equal(mgmt->bssid, wdev_address(wdev)) &&\n\t\t\t    (params->link_id < 0 ||\n\t\t\t     !ether_addr_equal(mgmt->bssid,\n\t\t\t\t\t       wdev->links[params->link_id].addr)))\n\t\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tif (!ether_addr_equal(mgmt->sa, mgmt->bssid)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t\t \n\t\tcase NL80211_IFTYPE_NAN:\n\t\tdefault:\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\twdev_unlock(wdev);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!cfg80211_allowed_address(wdev, mgmt->sa) &&\n\t    !cfg80211_allowed_random_address(wdev, mgmt))\n\t\treturn -EINVAL;\n\n\t \n\treturn rdev_mgmt_tx(rdev, wdev, params, cookie);\n}\n\nbool cfg80211_rx_mgmt_ext(struct wireless_dev *wdev,\n\t\t\t  struct cfg80211_rx_info *info)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct cfg80211_mgmt_registration *reg;\n\tconst struct ieee80211_txrx_stypes *stypes =\n\t\t&wiphy->mgmt_stypes[wdev->iftype];\n\tstruct ieee80211_mgmt *mgmt = (void *)info->buf;\n\tconst u8 *data;\n\tint data_len;\n\tbool result = false;\n\t__le16 ftype = mgmt->frame_control &\n\t\tcpu_to_le16(IEEE80211_FCTL_FTYPE | IEEE80211_FCTL_STYPE);\n\tu16 stype;\n\n\ttrace_cfg80211_rx_mgmt(wdev, info);\n\tstype = (le16_to_cpu(mgmt->frame_control) & IEEE80211_FCTL_STYPE) >> 4;\n\n\tif (!(stypes->rx & BIT(stype))) {\n\t\ttrace_cfg80211_return_bool(false);\n\t\treturn false;\n\t}\n\n\tdata = info->buf + ieee80211_hdrlen(mgmt->frame_control);\n\tdata_len = info->len - ieee80211_hdrlen(mgmt->frame_control);\n\n\tspin_lock_bh(&rdev->mgmt_registrations_lock);\n\n\tlist_for_each_entry(reg, &wdev->mgmt_registrations, list) {\n\t\tif (reg->frame_type != ftype)\n\t\t\tcontinue;\n\n\t\tif (reg->match_len > data_len)\n\t\t\tcontinue;\n\n\t\tif (memcmp(reg->match, data, reg->match_len))\n\t\t\tcontinue;\n\n\t\t \n\n\t\t \n\t\tif (nl80211_send_mgmt(rdev, wdev, reg->nlportid, info,\n\t\t\t\t      GFP_ATOMIC))\n\t\t\tcontinue;\n\n\t\tresult = true;\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&rdev->mgmt_registrations_lock);\n\n\ttrace_cfg80211_return_bool(result);\n\treturn result;\n}\nEXPORT_SYMBOL(cfg80211_rx_mgmt_ext);\n\nvoid cfg80211_sched_dfs_chan_update(struct cfg80211_registered_device *rdev)\n{\n\tcancel_delayed_work(&rdev->dfs_update_channels_wk);\n\tqueue_delayed_work(cfg80211_wq, &rdev->dfs_update_channels_wk, 0);\n}\n\nvoid cfg80211_dfs_channels_update_work(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct cfg80211_registered_device *rdev;\n\tstruct cfg80211_chan_def chandef;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *c;\n\tstruct wiphy *wiphy;\n\tbool check_again = false;\n\tunsigned long timeout, next_time = 0;\n\tunsigned long time_dfs_update;\n\tenum nl80211_radar_event radar_event;\n\tint bandid, i;\n\n\trdev = container_of(delayed_work, struct cfg80211_registered_device,\n\t\t\t    dfs_update_channels_wk);\n\twiphy = &rdev->wiphy;\n\n\trtnl_lock();\n\tfor (bandid = 0; bandid < NUM_NL80211_BANDS; bandid++) {\n\t\tsband = wiphy->bands[bandid];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\tc = &sband->channels[i];\n\n\t\t\tif (!(c->flags & IEEE80211_CHAN_RADAR))\n\t\t\t\tcontinue;\n\n\t\t\tif (c->dfs_state != NL80211_DFS_UNAVAILABLE &&\n\t\t\t    c->dfs_state != NL80211_DFS_AVAILABLE)\n\t\t\t\tcontinue;\n\n\t\t\tif (c->dfs_state == NL80211_DFS_UNAVAILABLE) {\n\t\t\t\ttime_dfs_update = IEEE80211_DFS_MIN_NOP_TIME_MS;\n\t\t\t\tradar_event = NL80211_RADAR_NOP_FINISHED;\n\t\t\t} else {\n\t\t\t\tif (regulatory_pre_cac_allowed(wiphy) ||\n\t\t\t\t    cfg80211_any_wiphy_oper_chan(wiphy, c))\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttime_dfs_update = REG_PRE_CAC_EXPIRY_GRACE_MS;\n\t\t\t\tradar_event = NL80211_RADAR_PRE_CAC_EXPIRED;\n\t\t\t}\n\n\t\t\ttimeout = c->dfs_state_entered +\n\t\t\t\t  msecs_to_jiffies(time_dfs_update);\n\n\t\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\t\tc->dfs_state = NL80211_DFS_USABLE;\n\t\t\t\tc->dfs_state_entered = jiffies;\n\n\t\t\t\tcfg80211_chandef_create(&chandef, c,\n\t\t\t\t\t\t\tNL80211_CHAN_NO_HT);\n\n\t\t\t\tnl80211_radar_notify(rdev, &chandef,\n\t\t\t\t\t\t     radar_event, NULL,\n\t\t\t\t\t\t     GFP_ATOMIC);\n\n\t\t\t\tregulatory_propagate_dfs_state(wiphy, &chandef,\n\t\t\t\t\t\t\t       c->dfs_state,\n\t\t\t\t\t\t\t       radar_event);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!check_again)\n\t\t\t\tnext_time = timeout - jiffies;\n\t\t\telse\n\t\t\t\tnext_time = min(next_time, timeout - jiffies);\n\t\t\tcheck_again = true;\n\t\t}\n\t}\n\trtnl_unlock();\n\n\t \n\tif (check_again)\n\t\tqueue_delayed_work(cfg80211_wq, &rdev->dfs_update_channels_wk,\n\t\t\t\t   next_time);\n}\n\n\nvoid __cfg80211_radar_event(struct wiphy *wiphy,\n\t\t\t    struct cfg80211_chan_def *chandef,\n\t\t\t    bool offchan, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_radar_event(wiphy, chandef, offchan);\n\n\t \n\tcfg80211_set_dfs_state(wiphy, chandef, NL80211_DFS_UNAVAILABLE);\n\n\tif (offchan)\n\t\tqueue_work(cfg80211_wq, &rdev->background_cac_abort_wk);\n\n\tcfg80211_sched_dfs_chan_update(rdev);\n\n\tnl80211_radar_notify(rdev, chandef, NL80211_RADAR_DETECTED, NULL, gfp);\n\n\tmemcpy(&rdev->radar_chandef, chandef, sizeof(struct cfg80211_chan_def));\n\tqueue_work(cfg80211_wq, &rdev->propagate_radar_detect_wk);\n}\nEXPORT_SYMBOL(__cfg80211_radar_event);\n\nvoid cfg80211_cac_event(struct net_device *netdev,\n\t\t\tconst struct cfg80211_chan_def *chandef,\n\t\t\tenum nl80211_radar_event event, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = netdev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tunsigned long timeout;\n\n\t \n\tif (wdev->valid_links)\n\t\treturn;\n\n\ttrace_cfg80211_cac_event(netdev, event);\n\n\tif (WARN_ON(!wdev->cac_started && event != NL80211_RADAR_CAC_STARTED))\n\t\treturn;\n\n\tswitch (event) {\n\tcase NL80211_RADAR_CAC_FINISHED:\n\t\ttimeout = wdev->cac_start_time +\n\t\t\t  msecs_to_jiffies(wdev->cac_time_ms);\n\t\tWARN_ON(!time_after_eq(jiffies, timeout));\n\t\tcfg80211_set_dfs_state(wiphy, chandef, NL80211_DFS_AVAILABLE);\n\t\tmemcpy(&rdev->cac_done_chandef, chandef,\n\t\t       sizeof(struct cfg80211_chan_def));\n\t\tqueue_work(cfg80211_wq, &rdev->propagate_cac_done_wk);\n\t\tcfg80211_sched_dfs_chan_update(rdev);\n\t\tfallthrough;\n\tcase NL80211_RADAR_CAC_ABORTED:\n\t\twdev->cac_started = false;\n\t\tbreak;\n\tcase NL80211_RADAR_CAC_STARTED:\n\t\twdev->cac_started = true;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tnl80211_radar_notify(rdev, chandef, event, netdev, gfp);\n}\nEXPORT_SYMBOL(cfg80211_cac_event);\n\nstatic void\n__cfg80211_background_cac_event(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\tconst struct cfg80211_chan_def *chandef,\n\t\t\t\tenum nl80211_radar_event event)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tstruct net_device *netdev;\n\n\tlockdep_assert_wiphy(&rdev->wiphy);\n\n\tif (!cfg80211_chandef_valid(chandef))\n\t\treturn;\n\n\tif (!rdev->background_radar_wdev)\n\t\treturn;\n\n\tswitch (event) {\n\tcase NL80211_RADAR_CAC_FINISHED:\n\t\tcfg80211_set_dfs_state(wiphy, chandef, NL80211_DFS_AVAILABLE);\n\t\tmemcpy(&rdev->cac_done_chandef, chandef, sizeof(*chandef));\n\t\tqueue_work(cfg80211_wq, &rdev->propagate_cac_done_wk);\n\t\tcfg80211_sched_dfs_chan_update(rdev);\n\t\twdev = rdev->background_radar_wdev;\n\t\tbreak;\n\tcase NL80211_RADAR_CAC_ABORTED:\n\t\tif (!cancel_delayed_work(&rdev->background_cac_done_wk))\n\t\t\treturn;\n\t\twdev = rdev->background_radar_wdev;\n\t\tbreak;\n\tcase NL80211_RADAR_CAC_STARTED:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tnetdev = wdev ? wdev->netdev : NULL;\n\tnl80211_radar_notify(rdev, chandef, event, netdev, GFP_KERNEL);\n}\n\nstatic void\ncfg80211_background_cac_event(struct cfg80211_registered_device *rdev,\n\t\t\t      const struct cfg80211_chan_def *chandef,\n\t\t\t      enum nl80211_radar_event event)\n{\n\twiphy_lock(&rdev->wiphy);\n\t__cfg80211_background_cac_event(rdev, rdev->background_radar_wdev,\n\t\t\t\t\tchandef, event);\n\twiphy_unlock(&rdev->wiphy);\n}\n\nvoid cfg80211_background_cac_done_wk(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct cfg80211_registered_device *rdev;\n\n\trdev = container_of(delayed_work, struct cfg80211_registered_device,\n\t\t\t    background_cac_done_wk);\n\tcfg80211_background_cac_event(rdev, &rdev->background_radar_chandef,\n\t\t\t\t      NL80211_RADAR_CAC_FINISHED);\n}\n\nvoid cfg80211_background_cac_abort_wk(struct work_struct *work)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\trdev = container_of(work, struct cfg80211_registered_device,\n\t\t\t    background_cac_abort_wk);\n\tcfg80211_background_cac_event(rdev, &rdev->background_radar_chandef,\n\t\t\t\t      NL80211_RADAR_CAC_ABORTED);\n}\n\nvoid cfg80211_background_cac_abort(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tqueue_work(cfg80211_wq, &rdev->background_cac_abort_wk);\n}\nEXPORT_SYMBOL(cfg80211_background_cac_abort);\n\nint\ncfg80211_start_background_radar_detection(struct cfg80211_registered_device *rdev,\n\t\t\t\t\t  struct wireless_dev *wdev,\n\t\t\t\t\t  struct cfg80211_chan_def *chandef)\n{\n\tunsigned int cac_time_ms;\n\tint err;\n\n\tlockdep_assert_wiphy(&rdev->wiphy);\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_RADAR_BACKGROUND))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (rdev->background_radar_wdev && rdev->background_radar_wdev != wdev)\n\t\treturn -EBUSY;\n\n\t \n\tif (rdev->background_radar_wdev == wdev &&\n\t    delayed_work_pending(&rdev->background_cac_done_wk))\n\t\treturn -EBUSY;\n\n\terr = rdev_set_radar_background(rdev, chandef);\n\tif (err)\n\t\treturn err;\n\n\tcac_time_ms = cfg80211_chandef_dfs_cac_time(&rdev->wiphy, chandef);\n\tif (!cac_time_ms)\n\t\tcac_time_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;\n\n\trdev->background_radar_chandef = *chandef;\n\trdev->background_radar_wdev = wdev;  \n\n\t__cfg80211_background_cac_event(rdev, wdev, chandef,\n\t\t\t\t\tNL80211_RADAR_CAC_STARTED);\n\tqueue_delayed_work(cfg80211_wq, &rdev->background_cac_done_wk,\n\t\t\t   msecs_to_jiffies(cac_time_ms));\n\n\treturn 0;\n}\n\nvoid cfg80211_stop_background_radar_detection(struct wireless_dev *wdev)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tlockdep_assert_wiphy(wiphy);\n\n\tif (wdev != rdev->background_radar_wdev)\n\t\treturn;\n\n\trdev_set_radar_background(rdev, NULL);\n\trdev->background_radar_wdev = NULL;  \n\n\t__cfg80211_background_cac_event(rdev, wdev,\n\t\t\t\t\t&rdev->background_radar_chandef,\n\t\t\t\t\tNL80211_RADAR_CAC_ABORTED);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}