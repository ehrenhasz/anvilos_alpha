{
  "module_name": "reg.c",
  "hash_id": "7cf591210ce145bdcdbfb1b2c448ad78b69983b4d0d24d6155fd8d65ea8dff96",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/reg.c",
  "human_readable_source": " \n\n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/nl80211.h>\n#include <linux/platform_device.h>\n#include <linux/verification.h>\n#include <linux/moduleparam.h>\n#include <linux/firmware.h>\n#include <net/cfg80211.h>\n#include \"core.h\"\n#include \"reg.h\"\n#include \"rdev-ops.h\"\n#include \"nl80211.h\"\n\n \n#define REG_ENFORCE_GRACE_MS 60000\n\n \nenum reg_request_treatment {\n\tREG_REQ_OK,\n\tREG_REQ_IGNORE,\n\tREG_REQ_INTERSECT,\n\tREG_REQ_ALREADY_SET,\n};\n\nstatic struct regulatory_request core_request_world = {\n\t.initiator = NL80211_REGDOM_SET_BY_CORE,\n\t.alpha2[0] = '0',\n\t.alpha2[1] = '0',\n\t.intersect = false,\n\t.processed = true,\n\t.country_ie_env = ENVIRON_ANY,\n};\n\n \nstatic struct regulatory_request __rcu *last_request =\n\t(void __force __rcu *)&core_request_world;\n\n \nstatic struct platform_device *reg_pdev;\n\n \nconst struct ieee80211_regdomain __rcu *cfg80211_regdomain;\n\n \nstatic int reg_num_devs_support_basehint;\n\n \nstatic bool reg_is_indoor;\nstatic DEFINE_SPINLOCK(reg_indoor_lock);\n\n \nstatic u32 reg_is_indoor_portid;\n\nstatic void restore_regulatory_settings(bool reset_user, bool cached);\nstatic void print_regdomain(const struct ieee80211_regdomain *rd);\nstatic void reg_process_hint(struct regulatory_request *reg_request);\n\nstatic const struct ieee80211_regdomain *get_cfg80211_regdom(void)\n{\n\treturn rcu_dereference_rtnl(cfg80211_regdomain);\n}\n\n \nconst struct ieee80211_regdomain *get_wiphy_regdom(struct wiphy *wiphy)\n{\n\treturn rcu_dereference_check(wiphy->regd,\n\t\t\t\t     lockdep_is_held(&wiphy->mtx) ||\n\t\t\t\t     lockdep_rtnl_is_held());\n}\nEXPORT_SYMBOL(get_wiphy_regdom);\n\nstatic const char *reg_dfs_region_str(enum nl80211_dfs_regions dfs_region)\n{\n\tswitch (dfs_region) {\n\tcase NL80211_DFS_UNSET:\n\t\treturn \"unset\";\n\tcase NL80211_DFS_FCC:\n\t\treturn \"FCC\";\n\tcase NL80211_DFS_ETSI:\n\t\treturn \"ETSI\";\n\tcase NL80211_DFS_JP:\n\t\treturn \"JP\";\n\t}\n\treturn \"Unknown\";\n}\n\nenum nl80211_dfs_regions reg_get_dfs_region(struct wiphy *wiphy)\n{\n\tconst struct ieee80211_regdomain *regd = NULL;\n\tconst struct ieee80211_regdomain *wiphy_regd = NULL;\n\tenum nl80211_dfs_regions dfs_region;\n\n\trcu_read_lock();\n\tregd = get_cfg80211_regdom();\n\tdfs_region = regd->dfs_region;\n\n\tif (!wiphy)\n\t\tgoto out;\n\n\twiphy_regd = get_wiphy_regdom(wiphy);\n\tif (!wiphy_regd)\n\t\tgoto out;\n\n\tif (wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED) {\n\t\tdfs_region = wiphy_regd->dfs_region;\n\t\tgoto out;\n\t}\n\n\tif (wiphy_regd->dfs_region == regd->dfs_region)\n\t\tgoto out;\n\n\tpr_debug(\"%s: device specific dfs_region (%s) disagrees with cfg80211's central dfs_region (%s)\\n\",\n\t\t dev_name(&wiphy->dev),\n\t\t reg_dfs_region_str(wiphy_regd->dfs_region),\n\t\t reg_dfs_region_str(regd->dfs_region));\n\nout:\n\trcu_read_unlock();\n\n\treturn dfs_region;\n}\n\nstatic void rcu_free_regdom(const struct ieee80211_regdomain *r)\n{\n\tif (!r)\n\t\treturn;\n\tkfree_rcu((struct ieee80211_regdomain *)r, rcu_head);\n}\n\nstatic struct regulatory_request *get_last_request(void)\n{\n\treturn rcu_dereference_rtnl(last_request);\n}\n\n \nstatic LIST_HEAD(reg_requests_list);\nstatic DEFINE_SPINLOCK(reg_requests_lock);\n\n \nstatic LIST_HEAD(reg_pending_beacons);\nstatic DEFINE_SPINLOCK(reg_pending_beacons_lock);\n\n \nstatic LIST_HEAD(reg_beacon_list);\n\nstruct reg_beacon {\n\tstruct list_head list;\n\tstruct ieee80211_channel chan;\n};\n\nstatic void reg_check_chans_work(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(reg_check_chans, reg_check_chans_work);\n\nstatic void reg_todo(struct work_struct *work);\nstatic DECLARE_WORK(reg_work, reg_todo);\n\n \nstatic const struct ieee80211_regdomain world_regdom = {\n\t.n_reg_rules = 8,\n\t.alpha2 =  \"00\",\n\t.reg_rules = {\n\t\t \n\t\tREG_RULE(2412-10, 2462+10, 40, 6, 20, 0),\n\t\t \n\t\tREG_RULE(2467-10, 2472+10, 20, 6, 20,\n\t\t\tNL80211_RRF_NO_IR | NL80211_RRF_AUTO_BW),\n\t\t \n\t\tREG_RULE(2484-10, 2484+10, 20, 6, 20,\n\t\t\tNL80211_RRF_NO_IR |\n\t\t\tNL80211_RRF_NO_OFDM),\n\t\t \n\t\tREG_RULE(5180-10, 5240+10, 80, 6, 20,\n                        NL80211_RRF_NO_IR |\n                        NL80211_RRF_AUTO_BW),\n\n\t\t \n\t\tREG_RULE(5260-10, 5320+10, 80, 6, 20,\n\t\t\tNL80211_RRF_NO_IR |\n\t\t\tNL80211_RRF_AUTO_BW |\n\t\t\tNL80211_RRF_DFS),\n\n\t\t \n\t\tREG_RULE(5500-10, 5720+10, 160, 6, 20,\n\t\t\tNL80211_RRF_NO_IR |\n\t\t\tNL80211_RRF_DFS),\n\n\t\t \n\t\tREG_RULE(5745-10, 5825+10, 80, 6, 20,\n\t\t\tNL80211_RRF_NO_IR),\n\n\t\t \n\t\tREG_RULE(56160+2160*1-1080, 56160+2160*3+1080, 2160, 0, 0, 0),\n\t}\n};\n\n \nstatic const struct ieee80211_regdomain *cfg80211_world_regdom =\n\t&world_regdom;\n\nstatic char *ieee80211_regdom = \"00\";\nstatic char user_alpha2[2];\nstatic const struct ieee80211_regdomain *cfg80211_user_regdom;\n\nmodule_param(ieee80211_regdom, charp, 0444);\nMODULE_PARM_DESC(ieee80211_regdom, \"IEEE 802.11 regulatory domain code\");\n\nstatic void reg_free_request(struct regulatory_request *request)\n{\n\tif (request == &core_request_world)\n\t\treturn;\n\n\tif (request != get_last_request())\n\t\tkfree(request);\n}\n\nstatic void reg_free_last_request(void)\n{\n\tstruct regulatory_request *lr = get_last_request();\n\n\tif (lr != &core_request_world && lr)\n\t\tkfree_rcu(lr, rcu_head);\n}\n\nstatic void reg_update_last_request(struct regulatory_request *request)\n{\n\tstruct regulatory_request *lr;\n\n\tlr = get_last_request();\n\tif (lr == request)\n\t\treturn;\n\n\treg_free_last_request();\n\trcu_assign_pointer(last_request, request);\n}\n\nstatic void reset_regdomains(bool full_reset,\n\t\t\t     const struct ieee80211_regdomain *new_regdom)\n{\n\tconst struct ieee80211_regdomain *r;\n\n\tASSERT_RTNL();\n\n\tr = get_cfg80211_regdom();\n\n\t \n\tif (r == cfg80211_world_regdom)\n\t\tr = NULL;\n\tif (cfg80211_world_regdom == &world_regdom)\n\t\tcfg80211_world_regdom = NULL;\n\tif (r == &world_regdom)\n\t\tr = NULL;\n\n\trcu_free_regdom(r);\n\trcu_free_regdom(cfg80211_world_regdom);\n\n\tcfg80211_world_regdom = &world_regdom;\n\trcu_assign_pointer(cfg80211_regdomain, new_regdom);\n\n\tif (!full_reset)\n\t\treturn;\n\n\treg_update_last_request(&core_request_world);\n}\n\n \nstatic void update_world_regdomain(const struct ieee80211_regdomain *rd)\n{\n\tstruct regulatory_request *lr;\n\n\tlr = get_last_request();\n\n\tWARN_ON(!lr);\n\n\treset_regdomains(false, rd);\n\n\tcfg80211_world_regdom = rd;\n}\n\nbool is_world_regdom(const char *alpha2)\n{\n\tif (!alpha2)\n\t\treturn false;\n\treturn alpha2[0] == '0' && alpha2[1] == '0';\n}\n\nstatic bool is_alpha2_set(const char *alpha2)\n{\n\tif (!alpha2)\n\t\treturn false;\n\treturn alpha2[0] && alpha2[1];\n}\n\nstatic bool is_unknown_alpha2(const char *alpha2)\n{\n\tif (!alpha2)\n\t\treturn false;\n\t \n\treturn alpha2[0] == '9' && alpha2[1] == '9';\n}\n\nstatic bool is_intersected_alpha2(const char *alpha2)\n{\n\tif (!alpha2)\n\t\treturn false;\n\t \n\treturn alpha2[0] == '9' && alpha2[1] == '8';\n}\n\nstatic bool is_an_alpha2(const char *alpha2)\n{\n\tif (!alpha2)\n\t\treturn false;\n\treturn isalpha(alpha2[0]) && isalpha(alpha2[1]);\n}\n\nstatic bool alpha2_equal(const char *alpha2_x, const char *alpha2_y)\n{\n\tif (!alpha2_x || !alpha2_y)\n\t\treturn false;\n\treturn alpha2_x[0] == alpha2_y[0] && alpha2_x[1] == alpha2_y[1];\n}\n\nstatic bool regdom_changes(const char *alpha2)\n{\n\tconst struct ieee80211_regdomain *r = get_cfg80211_regdom();\n\n\tif (!r)\n\t\treturn true;\n\treturn !alpha2_equal(r->alpha2, alpha2);\n}\n\n \nstatic bool is_user_regdom_saved(void)\n{\n\tif (user_alpha2[0] == '9' && user_alpha2[1] == '7')\n\t\treturn false;\n\n\t \n\tif (WARN(!is_world_regdom(user_alpha2) && !is_an_alpha2(user_alpha2),\n\t\t \"Unexpected user alpha2: %c%c\\n\",\n\t\t user_alpha2[0], user_alpha2[1]))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic const struct ieee80211_regdomain *\nreg_copy_regd(const struct ieee80211_regdomain *src_regd)\n{\n\tstruct ieee80211_regdomain *regd;\n\tunsigned int i;\n\n\tregd = kzalloc(struct_size(regd, reg_rules, src_regd->n_reg_rules),\n\t\t       GFP_KERNEL);\n\tif (!regd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(regd, src_regd, sizeof(struct ieee80211_regdomain));\n\n\tfor (i = 0; i < src_regd->n_reg_rules; i++)\n\t\tmemcpy(&regd->reg_rules[i], &src_regd->reg_rules[i],\n\t\t       sizeof(struct ieee80211_reg_rule));\n\n\treturn regd;\n}\n\nstatic void cfg80211_save_user_regdom(const struct ieee80211_regdomain *rd)\n{\n\tASSERT_RTNL();\n\n\tif (!IS_ERR(cfg80211_user_regdom))\n\t\tkfree(cfg80211_user_regdom);\n\tcfg80211_user_regdom = reg_copy_regd(rd);\n}\n\nstruct reg_regdb_apply_request {\n\tstruct list_head list;\n\tconst struct ieee80211_regdomain *regdom;\n};\n\nstatic LIST_HEAD(reg_regdb_apply_list);\nstatic DEFINE_MUTEX(reg_regdb_apply_mutex);\n\nstatic void reg_regdb_apply(struct work_struct *work)\n{\n\tstruct reg_regdb_apply_request *request;\n\n\trtnl_lock();\n\n\tmutex_lock(&reg_regdb_apply_mutex);\n\twhile (!list_empty(&reg_regdb_apply_list)) {\n\t\trequest = list_first_entry(&reg_regdb_apply_list,\n\t\t\t\t\t   struct reg_regdb_apply_request,\n\t\t\t\t\t   list);\n\t\tlist_del(&request->list);\n\n\t\tset_regdom(request->regdom, REGD_SOURCE_INTERNAL_DB);\n\t\tkfree(request);\n\t}\n\tmutex_unlock(&reg_regdb_apply_mutex);\n\n\trtnl_unlock();\n}\n\nstatic DECLARE_WORK(reg_regdb_work, reg_regdb_apply);\n\nstatic int reg_schedule_apply(const struct ieee80211_regdomain *regdom)\n{\n\tstruct reg_regdb_apply_request *request;\n\n\trequest = kzalloc(sizeof(struct reg_regdb_apply_request), GFP_KERNEL);\n\tif (!request) {\n\t\tkfree(regdom);\n\t\treturn -ENOMEM;\n\t}\n\n\trequest->regdom = regdom;\n\n\tmutex_lock(&reg_regdb_apply_mutex);\n\tlist_add_tail(&request->list, &reg_regdb_apply_list);\n\tmutex_unlock(&reg_regdb_apply_mutex);\n\n\tschedule_work(&reg_regdb_work);\n\treturn 0;\n}\n\n#ifdef CONFIG_CFG80211_CRDA_SUPPORT\n \n#define REG_MAX_CRDA_TIMEOUTS 10\n\nstatic u32 reg_crda_timeouts;\n\nstatic void crda_timeout_work(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(crda_timeout, crda_timeout_work);\n\nstatic void crda_timeout_work(struct work_struct *work)\n{\n\tpr_debug(\"Timeout while waiting for CRDA to reply, restoring regulatory settings\\n\");\n\trtnl_lock();\n\treg_crda_timeouts++;\n\trestore_regulatory_settings(true, false);\n\trtnl_unlock();\n}\n\nstatic void cancel_crda_timeout(void)\n{\n\tcancel_delayed_work(&crda_timeout);\n}\n\nstatic void cancel_crda_timeout_sync(void)\n{\n\tcancel_delayed_work_sync(&crda_timeout);\n}\n\nstatic void reset_crda_timeouts(void)\n{\n\treg_crda_timeouts = 0;\n}\n\n \nstatic int call_crda(const char *alpha2)\n{\n\tchar country[12];\n\tchar *env[] = { country, NULL };\n\tint ret;\n\n\tsnprintf(country, sizeof(country), \"COUNTRY=%c%c\",\n\t\t alpha2[0], alpha2[1]);\n\n\tif (reg_crda_timeouts > REG_MAX_CRDA_TIMEOUTS) {\n\t\tpr_debug(\"Exceeded CRDA call max attempts. Not calling CRDA\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!is_world_regdom((char *) alpha2))\n\t\tpr_debug(\"Calling CRDA for country: %c%c\\n\",\n\t\t\t alpha2[0], alpha2[1]);\n\telse\n\t\tpr_debug(\"Calling CRDA to update world regulatory domain\\n\");\n\n\tret = kobject_uevent_env(&reg_pdev->dev.kobj, KOBJ_CHANGE, env);\n\tif (ret)\n\t\treturn ret;\n\n\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t   &crda_timeout, msecs_to_jiffies(3142));\n\treturn 0;\n}\n#else\nstatic inline void cancel_crda_timeout(void) {}\nstatic inline void cancel_crda_timeout_sync(void) {}\nstatic inline void reset_crda_timeouts(void) {}\nstatic inline int call_crda(const char *alpha2)\n{\n\treturn -ENODATA;\n}\n#endif  \n\n \nstatic const struct fwdb_header *regdb;\n\nstruct fwdb_country {\n\tu8 alpha2[2];\n\t__be16 coll_ptr;\n\t \n} __packed __aligned(4);\n\nstruct fwdb_collection {\n\tu8 len;\n\tu8 n_rules;\n\tu8 dfs_region;\n\t \n\t \n} __packed __aligned(4);\n\nenum fwdb_flags {\n\tFWDB_FLAG_NO_OFDM\t= BIT(0),\n\tFWDB_FLAG_NO_OUTDOOR\t= BIT(1),\n\tFWDB_FLAG_DFS\t\t= BIT(2),\n\tFWDB_FLAG_NO_IR\t\t= BIT(3),\n\tFWDB_FLAG_AUTO_BW\t= BIT(4),\n};\n\nstruct fwdb_wmm_ac {\n\tu8 ecw;\n\tu8 aifsn;\n\t__be16 cot;\n} __packed;\n\nstruct fwdb_wmm_rule {\n\tstruct fwdb_wmm_ac client[IEEE80211_NUM_ACS];\n\tstruct fwdb_wmm_ac ap[IEEE80211_NUM_ACS];\n} __packed;\n\nstruct fwdb_rule {\n\tu8 len;\n\tu8 flags;\n\t__be16 max_eirp;\n\t__be32 start, end, max_bw;\n\t \n\t__be16 cac_timeout;\n\t__be16 wmm_ptr;\n} __packed __aligned(4);\n\n#define FWDB_MAGIC 0x52474442\n#define FWDB_VERSION 20\n\nstruct fwdb_header {\n\t__be32 magic;\n\t__be32 version;\n\tstruct fwdb_country country[];\n} __packed __aligned(4);\n\nstatic int ecw2cw(int ecw)\n{\n\treturn (1 << ecw) - 1;\n}\n\nstatic bool valid_wmm(struct fwdb_wmm_rule *rule)\n{\n\tstruct fwdb_wmm_ac *ac = (struct fwdb_wmm_ac *)rule;\n\tint i;\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS * 2; i++) {\n\t\tu16 cw_min = ecw2cw((ac[i].ecw & 0xf0) >> 4);\n\t\tu16 cw_max = ecw2cw(ac[i].ecw & 0x0f);\n\t\tu8 aifsn = ac[i].aifsn;\n\n\t\tif (cw_min >= cw_max)\n\t\t\treturn false;\n\n\t\tif (aifsn < 1)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool valid_rule(const u8 *data, unsigned int size, u16 rule_ptr)\n{\n\tstruct fwdb_rule *rule = (void *)(data + (rule_ptr << 2));\n\n\tif ((u8 *)rule + sizeof(rule->len) > data + size)\n\t\treturn false;\n\n\t \n\tif (rule->len < offsetofend(struct fwdb_rule, max_bw))\n\t\treturn false;\n\tif (rule->len >= offsetofend(struct fwdb_rule, wmm_ptr)) {\n\t\tu32 wmm_ptr = be16_to_cpu(rule->wmm_ptr) << 2;\n\t\tstruct fwdb_wmm_rule *wmm;\n\n\t\tif (wmm_ptr + sizeof(struct fwdb_wmm_rule) > size)\n\t\t\treturn false;\n\n\t\twmm = (void *)(data + wmm_ptr);\n\n\t\tif (!valid_wmm(wmm))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool valid_country(const u8 *data, unsigned int size,\n\t\t\t  const struct fwdb_country *country)\n{\n\tunsigned int ptr = be16_to_cpu(country->coll_ptr) << 2;\n\tstruct fwdb_collection *coll = (void *)(data + ptr);\n\t__be16 *rules_ptr;\n\tunsigned int i;\n\n\t \n\tif ((u8 *)coll + offsetofend(typeof(*coll), n_rules) > data + size)\n\t\treturn false;\n\n\t \n\tif ((u8 *)coll + ALIGN(coll->len, 2) +\n\t    (coll->n_rules * 2) > data + size)\n\t\treturn false;\n\n\t \n\tif (coll->len < offsetofend(struct fwdb_collection, dfs_region))\n\t\treturn false;\n\n\trules_ptr = (void *)((u8 *)coll + ALIGN(coll->len, 2));\n\n\tfor (i = 0; i < coll->n_rules; i++) {\n\t\tu16 rule_ptr = be16_to_cpu(rules_ptr[i]);\n\n\t\tif (!valid_rule(data, size, rule_ptr))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n#ifdef CONFIG_CFG80211_REQUIRE_SIGNED_REGDB\n#include <keys/asymmetric-type.h>\n\nstatic struct key *builtin_regdb_keys;\n\nstatic int __init load_builtin_regdb_keys(void)\n{\n\tbuiltin_regdb_keys =\n\t\tkeyring_alloc(\".builtin_regdb_keys\",\n\t\t\t      KUIDT_INIT(0), KGIDT_INIT(0), current_cred(),\n\t\t\t      ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t      KEY_USR_VIEW | KEY_USR_READ | KEY_USR_SEARCH),\n\t\t\t      KEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(builtin_regdb_keys))\n\t\treturn PTR_ERR(builtin_regdb_keys);\n\n\tpr_notice(\"Loading compiled-in X.509 certificates for regulatory database\\n\");\n\n#ifdef CONFIG_CFG80211_USE_KERNEL_REGDB_KEYS\n\tx509_load_certificate_list(shipped_regdb_certs,\n\t\t\t\t   shipped_regdb_certs_len,\n\t\t\t\t   builtin_regdb_keys);\n#endif\n#ifdef CONFIG_CFG80211_EXTRA_REGDB_KEYDIR\n\tif (CONFIG_CFG80211_EXTRA_REGDB_KEYDIR[0] != '\\0')\n\t\tx509_load_certificate_list(extra_regdb_certs,\n\t\t\t\t\t   extra_regdb_certs_len,\n\t\t\t\t\t   builtin_regdb_keys);\n#endif\n\n\treturn 0;\n}\n\nMODULE_FIRMWARE(\"regulatory.db.p7s\");\n\nstatic bool regdb_has_valid_signature(const u8 *data, unsigned int size)\n{\n\tconst struct firmware *sig;\n\tbool result;\n\n\tif (request_firmware(&sig, \"regulatory.db.p7s\", &reg_pdev->dev))\n\t\treturn false;\n\n\tresult = verify_pkcs7_signature(data, size, sig->data, sig->size,\n\t\t\t\t\tbuiltin_regdb_keys,\n\t\t\t\t\tVERIFYING_UNSPECIFIED_SIGNATURE,\n\t\t\t\t\tNULL, NULL) == 0;\n\n\trelease_firmware(sig);\n\n\treturn result;\n}\n\nstatic void free_regdb_keyring(void)\n{\n\tkey_put(builtin_regdb_keys);\n}\n#else\nstatic int load_builtin_regdb_keys(void)\n{\n\treturn 0;\n}\n\nstatic bool regdb_has_valid_signature(const u8 *data, unsigned int size)\n{\n\treturn true;\n}\n\nstatic void free_regdb_keyring(void)\n{\n}\n#endif  \n\nstatic bool valid_regdb(const u8 *data, unsigned int size)\n{\n\tconst struct fwdb_header *hdr = (void *)data;\n\tconst struct fwdb_country *country;\n\n\tif (size < sizeof(*hdr))\n\t\treturn false;\n\n\tif (hdr->magic != cpu_to_be32(FWDB_MAGIC))\n\t\treturn false;\n\n\tif (hdr->version != cpu_to_be32(FWDB_VERSION))\n\t\treturn false;\n\n\tif (!regdb_has_valid_signature(data, size))\n\t\treturn false;\n\n\tcountry = &hdr->country[0];\n\twhile ((u8 *)(country + 1) <= data + size) {\n\t\tif (!country->coll_ptr)\n\t\t\tbreak;\n\t\tif (!valid_country(data, size, country))\n\t\t\treturn false;\n\t\tcountry++;\n\t}\n\n\treturn true;\n}\n\nstatic void set_wmm_rule(const struct fwdb_header *db,\n\t\t\t const struct fwdb_country *country,\n\t\t\t const struct fwdb_rule *rule,\n\t\t\t struct ieee80211_reg_rule *rrule)\n{\n\tstruct ieee80211_wmm_rule *wmm_rule = &rrule->wmm_rule;\n\tstruct fwdb_wmm_rule *wmm;\n\tunsigned int i, wmm_ptr;\n\n\twmm_ptr = be16_to_cpu(rule->wmm_ptr) << 2;\n\twmm = (void *)((u8 *)db + wmm_ptr);\n\n\tif (!valid_wmm(wmm)) {\n\t\tpr_err(\"Invalid regulatory WMM rule %u-%u in domain %c%c\\n\",\n\t\t       be32_to_cpu(rule->start), be32_to_cpu(rule->end),\n\t\t       country->alpha2[0], country->alpha2[1]);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\twmm_rule->client[i].cw_min =\n\t\t\tecw2cw((wmm->client[i].ecw & 0xf0) >> 4);\n\t\twmm_rule->client[i].cw_max = ecw2cw(wmm->client[i].ecw & 0x0f);\n\t\twmm_rule->client[i].aifsn =  wmm->client[i].aifsn;\n\t\twmm_rule->client[i].cot =\n\t\t\t1000 * be16_to_cpu(wmm->client[i].cot);\n\t\twmm_rule->ap[i].cw_min = ecw2cw((wmm->ap[i].ecw & 0xf0) >> 4);\n\t\twmm_rule->ap[i].cw_max = ecw2cw(wmm->ap[i].ecw & 0x0f);\n\t\twmm_rule->ap[i].aifsn = wmm->ap[i].aifsn;\n\t\twmm_rule->ap[i].cot = 1000 * be16_to_cpu(wmm->ap[i].cot);\n\t}\n\n\trrule->has_wmm = true;\n}\n\nstatic int __regdb_query_wmm(const struct fwdb_header *db,\n\t\t\t     const struct fwdb_country *country, int freq,\n\t\t\t     struct ieee80211_reg_rule *rrule)\n{\n\tunsigned int ptr = be16_to_cpu(country->coll_ptr) << 2;\n\tstruct fwdb_collection *coll = (void *)((u8 *)db + ptr);\n\tint i;\n\n\tfor (i = 0; i < coll->n_rules; i++) {\n\t\t__be16 *rules_ptr = (void *)((u8 *)coll + ALIGN(coll->len, 2));\n\t\tunsigned int rule_ptr = be16_to_cpu(rules_ptr[i]) << 2;\n\t\tstruct fwdb_rule *rule = (void *)((u8 *)db + rule_ptr);\n\n\t\tif (rule->len < offsetofend(struct fwdb_rule, wmm_ptr))\n\t\t\tcontinue;\n\n\t\tif (freq >= KHZ_TO_MHZ(be32_to_cpu(rule->start)) &&\n\t\t    freq <= KHZ_TO_MHZ(be32_to_cpu(rule->end))) {\n\t\t\tset_wmm_rule(db, country, rule, rrule);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENODATA;\n}\n\nint reg_query_regdb_wmm(char *alpha2, int freq, struct ieee80211_reg_rule *rule)\n{\n\tconst struct fwdb_header *hdr = regdb;\n\tconst struct fwdb_country *country;\n\n\tif (!regdb)\n\t\treturn -ENODATA;\n\n\tif (IS_ERR(regdb))\n\t\treturn PTR_ERR(regdb);\n\n\tcountry = &hdr->country[0];\n\twhile (country->coll_ptr) {\n\t\tif (alpha2_equal(alpha2, country->alpha2))\n\t\t\treturn __regdb_query_wmm(regdb, country, freq, rule);\n\n\t\tcountry++;\n\t}\n\n\treturn -ENODATA;\n}\nEXPORT_SYMBOL(reg_query_regdb_wmm);\n\nstatic int regdb_query_country(const struct fwdb_header *db,\n\t\t\t       const struct fwdb_country *country)\n{\n\tunsigned int ptr = be16_to_cpu(country->coll_ptr) << 2;\n\tstruct fwdb_collection *coll = (void *)((u8 *)db + ptr);\n\tstruct ieee80211_regdomain *regdom;\n\tunsigned int i;\n\n\tregdom = kzalloc(struct_size(regdom, reg_rules, coll->n_rules),\n\t\t\t GFP_KERNEL);\n\tif (!regdom)\n\t\treturn -ENOMEM;\n\n\tregdom->n_reg_rules = coll->n_rules;\n\tregdom->alpha2[0] = country->alpha2[0];\n\tregdom->alpha2[1] = country->alpha2[1];\n\tregdom->dfs_region = coll->dfs_region;\n\n\tfor (i = 0; i < regdom->n_reg_rules; i++) {\n\t\t__be16 *rules_ptr = (void *)((u8 *)coll + ALIGN(coll->len, 2));\n\t\tunsigned int rule_ptr = be16_to_cpu(rules_ptr[i]) << 2;\n\t\tstruct fwdb_rule *rule = (void *)((u8 *)db + rule_ptr);\n\t\tstruct ieee80211_reg_rule *rrule = &regdom->reg_rules[i];\n\n\t\trrule->freq_range.start_freq_khz = be32_to_cpu(rule->start);\n\t\trrule->freq_range.end_freq_khz = be32_to_cpu(rule->end);\n\t\trrule->freq_range.max_bandwidth_khz = be32_to_cpu(rule->max_bw);\n\n\t\trrule->power_rule.max_antenna_gain = 0;\n\t\trrule->power_rule.max_eirp = be16_to_cpu(rule->max_eirp);\n\n\t\trrule->flags = 0;\n\t\tif (rule->flags & FWDB_FLAG_NO_OFDM)\n\t\t\trrule->flags |= NL80211_RRF_NO_OFDM;\n\t\tif (rule->flags & FWDB_FLAG_NO_OUTDOOR)\n\t\t\trrule->flags |= NL80211_RRF_NO_OUTDOOR;\n\t\tif (rule->flags & FWDB_FLAG_DFS)\n\t\t\trrule->flags |= NL80211_RRF_DFS;\n\t\tif (rule->flags & FWDB_FLAG_NO_IR)\n\t\t\trrule->flags |= NL80211_RRF_NO_IR;\n\t\tif (rule->flags & FWDB_FLAG_AUTO_BW)\n\t\t\trrule->flags |= NL80211_RRF_AUTO_BW;\n\n\t\trrule->dfs_cac_ms = 0;\n\n\t\t \n\t\tif (rule->len >= offsetofend(struct fwdb_rule, cac_timeout))\n\t\t\trrule->dfs_cac_ms =\n\t\t\t\t1000 * be16_to_cpu(rule->cac_timeout);\n\t\tif (rule->len >= offsetofend(struct fwdb_rule, wmm_ptr))\n\t\t\tset_wmm_rule(db, country, rule, rrule);\n\t}\n\n\treturn reg_schedule_apply(regdom);\n}\n\nstatic int query_regdb(const char *alpha2)\n{\n\tconst struct fwdb_header *hdr = regdb;\n\tconst struct fwdb_country *country;\n\n\tASSERT_RTNL();\n\n\tif (IS_ERR(regdb))\n\t\treturn PTR_ERR(regdb);\n\n\tcountry = &hdr->country[0];\n\twhile (country->coll_ptr) {\n\t\tif (alpha2_equal(alpha2, country->alpha2))\n\t\t\treturn regdb_query_country(regdb, country);\n\t\tcountry++;\n\t}\n\n\treturn -ENODATA;\n}\n\nstatic void regdb_fw_cb(const struct firmware *fw, void *context)\n{\n\tint set_error = 0;\n\tbool restore = true;\n\tvoid *db;\n\n\tif (!fw) {\n\t\tpr_info(\"failed to load regulatory.db\\n\");\n\t\tset_error = -ENODATA;\n\t} else if (!valid_regdb(fw->data, fw->size)) {\n\t\tpr_info(\"loaded regulatory.db is malformed or signature is missing/invalid\\n\");\n\t\tset_error = -EINVAL;\n\t}\n\n\trtnl_lock();\n\tif (regdb && !IS_ERR(regdb)) {\n\t\t \n\t} else if (set_error) {\n\t\tregdb = ERR_PTR(set_error);\n\t} else if (fw) {\n\t\tdb = kmemdup(fw->data, fw->size, GFP_KERNEL);\n\t\tif (db) {\n\t\t\tregdb = db;\n\t\t\trestore = context && query_regdb(context);\n\t\t} else {\n\t\t\trestore = true;\n\t\t}\n\t}\n\n\tif (restore)\n\t\trestore_regulatory_settings(true, false);\n\n\trtnl_unlock();\n\n\tkfree(context);\n\n\trelease_firmware(fw);\n}\n\nMODULE_FIRMWARE(\"regulatory.db\");\n\nstatic int query_regdb_file(const char *alpha2)\n{\n\tint err;\n\n\tASSERT_RTNL();\n\n\tif (regdb)\n\t\treturn query_regdb(alpha2);\n\n\talpha2 = kmemdup(alpha2, 2, GFP_KERNEL);\n\tif (!alpha2)\n\t\treturn -ENOMEM;\n\n\terr = request_firmware_nowait(THIS_MODULE, true, \"regulatory.db\",\n\t\t\t\t      &reg_pdev->dev, GFP_KERNEL,\n\t\t\t\t      (void *)alpha2, regdb_fw_cb);\n\tif (err)\n\t\tkfree(alpha2);\n\n\treturn err;\n}\n\nint reg_reload_regdb(void)\n{\n\tconst struct firmware *fw;\n\tvoid *db;\n\tint err;\n\tconst struct ieee80211_regdomain *current_regdomain;\n\tstruct regulatory_request *request;\n\n\terr = request_firmware(&fw, \"regulatory.db\", &reg_pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\tif (!valid_regdb(fw->data, fw->size)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\n\tdb = kmemdup(fw->data, fw->size, GFP_KERNEL);\n\tif (!db) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trtnl_lock();\n\tif (!IS_ERR_OR_NULL(regdb))\n\t\tkfree(regdb);\n\tregdb = db;\n\n\t \n\tcurrent_regdomain = get_cfg80211_regdom();\n\n\trequest = kzalloc(sizeof(*request), GFP_KERNEL);\n\tif (!request) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\trequest->wiphy_idx = WIPHY_IDX_INVALID;\n\trequest->alpha2[0] = current_regdomain->alpha2[0];\n\trequest->alpha2[1] = current_regdomain->alpha2[1];\n\trequest->initiator = NL80211_REGDOM_SET_BY_CORE;\n\trequest->user_reg_hint_type = NL80211_USER_REG_HINT_USER;\n\n\treg_process_hint(request);\n\nout_unlock:\n\trtnl_unlock();\n out:\n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic bool reg_query_database(struct regulatory_request *request)\n{\n\tif (query_regdb_file(request->alpha2) == 0)\n\t\treturn true;\n\n\tif (call_crda(request->alpha2) == 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool reg_is_valid_request(const char *alpha2)\n{\n\tstruct regulatory_request *lr = get_last_request();\n\n\tif (!lr || lr->processed)\n\t\treturn false;\n\n\treturn alpha2_equal(lr->alpha2, alpha2);\n}\n\nstatic const struct ieee80211_regdomain *reg_get_regdomain(struct wiphy *wiphy)\n{\n\tstruct regulatory_request *lr = get_last_request();\n\n\t \n\tif (lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE &&\n\t    lr->initiator != NL80211_REGDOM_SET_BY_USER &&\n\t    wiphy->regd)\n\t\treturn get_wiphy_regdom(wiphy);\n\n\treturn get_cfg80211_regdom();\n}\n\nstatic unsigned int\nreg_get_max_bandwidth_from_range(const struct ieee80211_regdomain *rd,\n\t\t\t\t const struct ieee80211_reg_rule *rule)\n{\n\tconst struct ieee80211_freq_range *freq_range = &rule->freq_range;\n\tconst struct ieee80211_freq_range *freq_range_tmp;\n\tconst struct ieee80211_reg_rule *tmp;\n\tu32 start_freq, end_freq, idx, no;\n\n\tfor (idx = 0; idx < rd->n_reg_rules; idx++)\n\t\tif (rule == &rd->reg_rules[idx])\n\t\t\tbreak;\n\n\tif (idx == rd->n_reg_rules)\n\t\treturn 0;\n\n\t \n\tno = idx;\n\n\twhile (no) {\n\t\ttmp = &rd->reg_rules[--no];\n\t\tfreq_range_tmp = &tmp->freq_range;\n\n\t\tif (freq_range_tmp->end_freq_khz < freq_range->start_freq_khz)\n\t\t\tbreak;\n\n\t\tfreq_range = freq_range_tmp;\n\t}\n\n\tstart_freq = freq_range->start_freq_khz;\n\n\t \n\tfreq_range = &rule->freq_range;\n\tno = idx;\n\n\twhile (no < rd->n_reg_rules - 1) {\n\t\ttmp = &rd->reg_rules[++no];\n\t\tfreq_range_tmp = &tmp->freq_range;\n\n\t\tif (freq_range_tmp->start_freq_khz > freq_range->end_freq_khz)\n\t\t\tbreak;\n\n\t\tfreq_range = freq_range_tmp;\n\t}\n\n\tend_freq = freq_range->end_freq_khz;\n\n\treturn end_freq - start_freq;\n}\n\nunsigned int reg_get_max_bandwidth(const struct ieee80211_regdomain *rd,\n\t\t\t\t   const struct ieee80211_reg_rule *rule)\n{\n\tunsigned int bw = reg_get_max_bandwidth_from_range(rd, rule);\n\n\tif (rule->flags & NL80211_RRF_NO_320MHZ)\n\t\tbw = min_t(unsigned int, bw, MHZ_TO_KHZ(160));\n\tif (rule->flags & NL80211_RRF_NO_160MHZ)\n\t\tbw = min_t(unsigned int, bw, MHZ_TO_KHZ(80));\n\tif (rule->flags & NL80211_RRF_NO_80MHZ)\n\t\tbw = min_t(unsigned int, bw, MHZ_TO_KHZ(40));\n\n\t \n\tif (rule->flags & NL80211_RRF_NO_HT40MINUS &&\n\t    rule->flags & NL80211_RRF_NO_HT40PLUS)\n\t\tbw = min_t(unsigned int, bw, MHZ_TO_KHZ(20));\n\n\treturn bw;\n}\n\n \nstatic bool is_valid_reg_rule(const struct ieee80211_reg_rule *rule)\n{\n\tconst struct ieee80211_freq_range *freq_range = &rule->freq_range;\n\tu32 freq_diff;\n\n\tif (freq_range->start_freq_khz <= 0 || freq_range->end_freq_khz <= 0)\n\t\treturn false;\n\n\tif (freq_range->start_freq_khz > freq_range->end_freq_khz)\n\t\treturn false;\n\n\tfreq_diff = freq_range->end_freq_khz - freq_range->start_freq_khz;\n\n\tif (freq_range->end_freq_khz <= freq_range->start_freq_khz ||\n\t    freq_range->max_bandwidth_khz > freq_diff)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool is_valid_rd(const struct ieee80211_regdomain *rd)\n{\n\tconst struct ieee80211_reg_rule *reg_rule = NULL;\n\tunsigned int i;\n\n\tif (!rd->n_reg_rules)\n\t\treturn false;\n\n\tif (WARN_ON(rd->n_reg_rules > NL80211_MAX_SUPP_REG_RULES))\n\t\treturn false;\n\n\tfor (i = 0; i < rd->n_reg_rules; i++) {\n\t\treg_rule = &rd->reg_rules[i];\n\t\tif (!is_valid_reg_rule(reg_rule))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool freq_in_rule_band(const struct ieee80211_freq_range *freq_range,\n\t\t\t      u32 freq_khz)\n{\n#define ONE_GHZ_IN_KHZ\t1000000\n\t \n\tu32 limit = freq_khz > 45 * ONE_GHZ_IN_KHZ ?\n\t\t\t20 * ONE_GHZ_IN_KHZ : 2 * ONE_GHZ_IN_KHZ;\n\tif (abs(freq_khz - freq_range->start_freq_khz) <= limit)\n\t\treturn true;\n\tif (abs(freq_khz - freq_range->end_freq_khz) <= limit)\n\t\treturn true;\n\treturn false;\n#undef ONE_GHZ_IN_KHZ\n}\n\n \nstatic enum nl80211_dfs_regions\nreg_intersect_dfs_region(const enum nl80211_dfs_regions dfs_region1,\n\t\t\t const enum nl80211_dfs_regions dfs_region2)\n{\n\tif (dfs_region1 != dfs_region2)\n\t\treturn NL80211_DFS_UNSET;\n\treturn dfs_region1;\n}\n\nstatic void reg_wmm_rules_intersect(const struct ieee80211_wmm_ac *wmm_ac1,\n\t\t\t\t    const struct ieee80211_wmm_ac *wmm_ac2,\n\t\t\t\t    struct ieee80211_wmm_ac *intersect)\n{\n\tintersect->cw_min = max_t(u16, wmm_ac1->cw_min, wmm_ac2->cw_min);\n\tintersect->cw_max = max_t(u16, wmm_ac1->cw_max, wmm_ac2->cw_max);\n\tintersect->cot = min_t(u16, wmm_ac1->cot, wmm_ac2->cot);\n\tintersect->aifsn = max_t(u8, wmm_ac1->aifsn, wmm_ac2->aifsn);\n}\n\n \nstatic int reg_rules_intersect(const struct ieee80211_regdomain *rd1,\n\t\t\t       const struct ieee80211_regdomain *rd2,\n\t\t\t       const struct ieee80211_reg_rule *rule1,\n\t\t\t       const struct ieee80211_reg_rule *rule2,\n\t\t\t       struct ieee80211_reg_rule *intersected_rule)\n{\n\tconst struct ieee80211_freq_range *freq_range1, *freq_range2;\n\tstruct ieee80211_freq_range *freq_range;\n\tconst struct ieee80211_power_rule *power_rule1, *power_rule2;\n\tstruct ieee80211_power_rule *power_rule;\n\tconst struct ieee80211_wmm_rule *wmm_rule1, *wmm_rule2;\n\tstruct ieee80211_wmm_rule *wmm_rule;\n\tu32 freq_diff, max_bandwidth1, max_bandwidth2;\n\n\tfreq_range1 = &rule1->freq_range;\n\tfreq_range2 = &rule2->freq_range;\n\tfreq_range = &intersected_rule->freq_range;\n\n\tpower_rule1 = &rule1->power_rule;\n\tpower_rule2 = &rule2->power_rule;\n\tpower_rule = &intersected_rule->power_rule;\n\n\twmm_rule1 = &rule1->wmm_rule;\n\twmm_rule2 = &rule2->wmm_rule;\n\twmm_rule = &intersected_rule->wmm_rule;\n\n\tfreq_range->start_freq_khz = max(freq_range1->start_freq_khz,\n\t\t\t\t\t freq_range2->start_freq_khz);\n\tfreq_range->end_freq_khz = min(freq_range1->end_freq_khz,\n\t\t\t\t       freq_range2->end_freq_khz);\n\n\tmax_bandwidth1 = freq_range1->max_bandwidth_khz;\n\tmax_bandwidth2 = freq_range2->max_bandwidth_khz;\n\n\tif (rule1->flags & NL80211_RRF_AUTO_BW)\n\t\tmax_bandwidth1 = reg_get_max_bandwidth(rd1, rule1);\n\tif (rule2->flags & NL80211_RRF_AUTO_BW)\n\t\tmax_bandwidth2 = reg_get_max_bandwidth(rd2, rule2);\n\n\tfreq_range->max_bandwidth_khz = min(max_bandwidth1, max_bandwidth2);\n\n\tintersected_rule->flags = rule1->flags | rule2->flags;\n\n\t \n\tif ((rule1->flags & NL80211_RRF_AUTO_BW) &&\n\t    (rule2->flags & NL80211_RRF_AUTO_BW))\n\t\tintersected_rule->flags |= NL80211_RRF_AUTO_BW;\n\telse\n\t\tintersected_rule->flags &= ~NL80211_RRF_AUTO_BW;\n\n\tfreq_diff = freq_range->end_freq_khz - freq_range->start_freq_khz;\n\tif (freq_range->max_bandwidth_khz > freq_diff)\n\t\tfreq_range->max_bandwidth_khz = freq_diff;\n\n\tpower_rule->max_eirp = min(power_rule1->max_eirp,\n\t\tpower_rule2->max_eirp);\n\tpower_rule->max_antenna_gain = min(power_rule1->max_antenna_gain,\n\t\tpower_rule2->max_antenna_gain);\n\n\tintersected_rule->dfs_cac_ms = max(rule1->dfs_cac_ms,\n\t\t\t\t\t   rule2->dfs_cac_ms);\n\n\tif (rule1->has_wmm && rule2->has_wmm) {\n\t\tu8 ac;\n\n\t\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\t\treg_wmm_rules_intersect(&wmm_rule1->client[ac],\n\t\t\t\t\t\t&wmm_rule2->client[ac],\n\t\t\t\t\t\t&wmm_rule->client[ac]);\n\t\t\treg_wmm_rules_intersect(&wmm_rule1->ap[ac],\n\t\t\t\t\t\t&wmm_rule2->ap[ac],\n\t\t\t\t\t\t&wmm_rule->ap[ac]);\n\t\t}\n\n\t\tintersected_rule->has_wmm = true;\n\t} else if (rule1->has_wmm) {\n\t\t*wmm_rule = *wmm_rule1;\n\t\tintersected_rule->has_wmm = true;\n\t} else if (rule2->has_wmm) {\n\t\t*wmm_rule = *wmm_rule2;\n\t\tintersected_rule->has_wmm = true;\n\t} else {\n\t\tintersected_rule->has_wmm = false;\n\t}\n\n\tif (!is_valid_reg_rule(intersected_rule))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic bool rule_contains(struct ieee80211_reg_rule *r1,\n\t\t\t  struct ieee80211_reg_rule *r2)\n{\n\t \n\tif (r1->flags != r2->flags)\n\t\treturn false;\n\n\t \n\tif ((r1->power_rule.max_antenna_gain >\n\t     r2->power_rule.max_antenna_gain) ||\n\t    r1->power_rule.max_eirp > r2->power_rule.max_eirp)\n\t\treturn false;\n\n\t \n\tif (r1->freq_range.start_freq_khz > r2->freq_range.start_freq_khz ||\n\t    r1->freq_range.end_freq_khz < r2->freq_range.end_freq_khz)\n\t\treturn false;\n\n\t \n\tif (r1->freq_range.max_bandwidth_khz <\n\t    r2->freq_range.max_bandwidth_khz)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void add_rule(struct ieee80211_reg_rule *rule,\n\t\t     struct ieee80211_reg_rule *reg_rules, u32 *n_rules)\n{\n\tstruct ieee80211_reg_rule *tmp_rule;\n\tint i;\n\n\tfor (i = 0; i < *n_rules; i++) {\n\t\ttmp_rule = &reg_rules[i];\n\t\t \n\t\tif (rule_contains(tmp_rule, rule))\n\t\t\treturn;\n\n\t\t \n\t\tif (rule_contains(rule, tmp_rule)) {\n\t\t\tmemcpy(tmp_rule, rule, sizeof(*rule));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmemcpy(&reg_rules[*n_rules], rule, sizeof(*rule));\n\t(*n_rules)++;\n}\n\n \nstatic struct ieee80211_regdomain *\nregdom_intersect(const struct ieee80211_regdomain *rd1,\n\t\t const struct ieee80211_regdomain *rd2)\n{\n\tint r;\n\tunsigned int x, y;\n\tunsigned int num_rules = 0;\n\tconst struct ieee80211_reg_rule *rule1, *rule2;\n\tstruct ieee80211_reg_rule intersected_rule;\n\tstruct ieee80211_regdomain *rd;\n\n\tif (!rd1 || !rd2)\n\t\treturn NULL;\n\n\t \n\n\tfor (x = 0; x < rd1->n_reg_rules; x++) {\n\t\trule1 = &rd1->reg_rules[x];\n\t\tfor (y = 0; y < rd2->n_reg_rules; y++) {\n\t\t\trule2 = &rd2->reg_rules[y];\n\t\t\tif (!reg_rules_intersect(rd1, rd2, rule1, rule2,\n\t\t\t\t\t\t &intersected_rule))\n\t\t\t\tnum_rules++;\n\t\t}\n\t}\n\n\tif (!num_rules)\n\t\treturn NULL;\n\n\trd = kzalloc(struct_size(rd, reg_rules, num_rules), GFP_KERNEL);\n\tif (!rd)\n\t\treturn NULL;\n\n\tfor (x = 0; x < rd1->n_reg_rules; x++) {\n\t\trule1 = &rd1->reg_rules[x];\n\t\tfor (y = 0; y < rd2->n_reg_rules; y++) {\n\t\t\trule2 = &rd2->reg_rules[y];\n\t\t\tr = reg_rules_intersect(rd1, rd2, rule1, rule2,\n\t\t\t\t\t\t&intersected_rule);\n\t\t\t \n\t\t\tif (r)\n\t\t\t\tcontinue;\n\n\t\t\tadd_rule(&intersected_rule, rd->reg_rules,\n\t\t\t\t &rd->n_reg_rules);\n\t\t}\n\t}\n\n\trd->alpha2[0] = '9';\n\trd->alpha2[1] = '8';\n\trd->dfs_region = reg_intersect_dfs_region(rd1->dfs_region,\n\t\t\t\t\t\t  rd2->dfs_region);\n\n\treturn rd;\n}\n\n \nstatic u32 map_regdom_flags(u32 rd_flags)\n{\n\tu32 channel_flags = 0;\n\tif (rd_flags & NL80211_RRF_NO_IR_ALL)\n\t\tchannel_flags |= IEEE80211_CHAN_NO_IR;\n\tif (rd_flags & NL80211_RRF_DFS)\n\t\tchannel_flags |= IEEE80211_CHAN_RADAR;\n\tif (rd_flags & NL80211_RRF_NO_OFDM)\n\t\tchannel_flags |= IEEE80211_CHAN_NO_OFDM;\n\tif (rd_flags & NL80211_RRF_NO_OUTDOOR)\n\t\tchannel_flags |= IEEE80211_CHAN_INDOOR_ONLY;\n\tif (rd_flags & NL80211_RRF_IR_CONCURRENT)\n\t\tchannel_flags |= IEEE80211_CHAN_IR_CONCURRENT;\n\tif (rd_flags & NL80211_RRF_NO_HT40MINUS)\n\t\tchannel_flags |= IEEE80211_CHAN_NO_HT40MINUS;\n\tif (rd_flags & NL80211_RRF_NO_HT40PLUS)\n\t\tchannel_flags |= IEEE80211_CHAN_NO_HT40PLUS;\n\tif (rd_flags & NL80211_RRF_NO_80MHZ)\n\t\tchannel_flags |= IEEE80211_CHAN_NO_80MHZ;\n\tif (rd_flags & NL80211_RRF_NO_160MHZ)\n\t\tchannel_flags |= IEEE80211_CHAN_NO_160MHZ;\n\tif (rd_flags & NL80211_RRF_NO_HE)\n\t\tchannel_flags |= IEEE80211_CHAN_NO_HE;\n\tif (rd_flags & NL80211_RRF_NO_320MHZ)\n\t\tchannel_flags |= IEEE80211_CHAN_NO_320MHZ;\n\tif (rd_flags & NL80211_RRF_NO_EHT)\n\t\tchannel_flags |= IEEE80211_CHAN_NO_EHT;\n\treturn channel_flags;\n}\n\nstatic const struct ieee80211_reg_rule *\nfreq_reg_info_regd(u32 center_freq,\n\t\t   const struct ieee80211_regdomain *regd, u32 bw)\n{\n\tint i;\n\tbool band_rule_found = false;\n\tbool bw_fits = false;\n\n\tif (!regd)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < regd->n_reg_rules; i++) {\n\t\tconst struct ieee80211_reg_rule *rr;\n\t\tconst struct ieee80211_freq_range *fr = NULL;\n\n\t\trr = &regd->reg_rules[i];\n\t\tfr = &rr->freq_range;\n\n\t\t \n\t\tif (!band_rule_found)\n\t\t\tband_rule_found = freq_in_rule_band(fr, center_freq);\n\n\t\tbw_fits = cfg80211_does_bw_fit_range(fr, center_freq, bw);\n\n\t\tif (band_rule_found && bw_fits)\n\t\t\treturn rr;\n\t}\n\n\tif (!band_rule_found)\n\t\treturn ERR_PTR(-ERANGE);\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic const struct ieee80211_reg_rule *\n__freq_reg_info(struct wiphy *wiphy, u32 center_freq, u32 min_bw)\n{\n\tconst struct ieee80211_regdomain *regd = reg_get_regdomain(wiphy);\n\tstatic const u32 bws[] = {0, 1, 2, 4, 5, 8, 10, 16, 20};\n\tconst struct ieee80211_reg_rule *reg_rule = ERR_PTR(-ERANGE);\n\tint i = ARRAY_SIZE(bws) - 1;\n\tu32 bw;\n\n\tfor (bw = MHZ_TO_KHZ(bws[i]); bw >= min_bw; bw = MHZ_TO_KHZ(bws[i--])) {\n\t\treg_rule = freq_reg_info_regd(center_freq, regd, bw);\n\t\tif (!IS_ERR(reg_rule))\n\t\t\treturn reg_rule;\n\t}\n\n\treturn reg_rule;\n}\n\nconst struct ieee80211_reg_rule *freq_reg_info(struct wiphy *wiphy,\n\t\t\t\t\t       u32 center_freq)\n{\n\tu32 min_bw = center_freq < MHZ_TO_KHZ(1000) ? 1 : 20;\n\n\treturn __freq_reg_info(wiphy, center_freq, MHZ_TO_KHZ(min_bw));\n}\nEXPORT_SYMBOL(freq_reg_info);\n\nconst char *reg_initiator_name(enum nl80211_reg_initiator initiator)\n{\n\tswitch (initiator) {\n\tcase NL80211_REGDOM_SET_BY_CORE:\n\t\treturn \"core\";\n\tcase NL80211_REGDOM_SET_BY_USER:\n\t\treturn \"user\";\n\tcase NL80211_REGDOM_SET_BY_DRIVER:\n\t\treturn \"driver\";\n\tcase NL80211_REGDOM_SET_BY_COUNTRY_IE:\n\t\treturn \"country element\";\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn \"bug\";\n\t}\n}\nEXPORT_SYMBOL(reg_initiator_name);\n\nstatic uint32_t reg_rule_to_chan_bw_flags(const struct ieee80211_regdomain *regd,\n\t\t\t\t\t  const struct ieee80211_reg_rule *reg_rule,\n\t\t\t\t\t  const struct ieee80211_channel *chan)\n{\n\tconst struct ieee80211_freq_range *freq_range = NULL;\n\tu32 max_bandwidth_khz, center_freq_khz, bw_flags = 0;\n\tbool is_s1g = chan->band == NL80211_BAND_S1GHZ;\n\n\tfreq_range = &reg_rule->freq_range;\n\n\tmax_bandwidth_khz = freq_range->max_bandwidth_khz;\n\tcenter_freq_khz = ieee80211_channel_to_khz(chan);\n\t \n\tif (reg_rule->flags & NL80211_RRF_AUTO_BW)\n\t\tmax_bandwidth_khz = reg_get_max_bandwidth(regd, reg_rule);\n\n\t \n\tif (!cfg80211_does_bw_fit_range(freq_range,\n\t\t\t\t\tcenter_freq_khz,\n\t\t\t\t\tMHZ_TO_KHZ(10)))\n\t\tbw_flags |= IEEE80211_CHAN_NO_10MHZ;\n\tif (!cfg80211_does_bw_fit_range(freq_range,\n\t\t\t\t\tcenter_freq_khz,\n\t\t\t\t\tMHZ_TO_KHZ(20)))\n\t\tbw_flags |= IEEE80211_CHAN_NO_20MHZ;\n\n\tif (is_s1g) {\n\t\t \n\t\tint edge_offset;\n\t\tint ch_bw = max_bandwidth_khz;\n\n\t\twhile (ch_bw) {\n\t\t\tedge_offset = (center_freq_khz - ch_bw / 2) -\n\t\t\t\t      freq_range->start_freq_khz;\n\t\t\tif (edge_offset % ch_bw == 0) {\n\t\t\t\tswitch (KHZ_TO_MHZ(ch_bw)) {\n\t\t\t\tcase 1:\n\t\t\t\t\tbw_flags |= IEEE80211_CHAN_1MHZ;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tbw_flags |= IEEE80211_CHAN_2MHZ;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tbw_flags |= IEEE80211_CHAN_4MHZ;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tbw_flags |= IEEE80211_CHAN_8MHZ;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tbw_flags |= IEEE80211_CHAN_16MHZ;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t \n\t\t\t\t\tbw_flags |= IEEE80211_CHAN_DISABLED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tch_bw /= 2;\n\t\t}\n\t} else {\n\t\tif (max_bandwidth_khz < MHZ_TO_KHZ(10))\n\t\t\tbw_flags |= IEEE80211_CHAN_NO_10MHZ;\n\t\tif (max_bandwidth_khz < MHZ_TO_KHZ(20))\n\t\t\tbw_flags |= IEEE80211_CHAN_NO_20MHZ;\n\t\tif (max_bandwidth_khz < MHZ_TO_KHZ(40))\n\t\t\tbw_flags |= IEEE80211_CHAN_NO_HT40;\n\t\tif (max_bandwidth_khz < MHZ_TO_KHZ(80))\n\t\t\tbw_flags |= IEEE80211_CHAN_NO_80MHZ;\n\t\tif (max_bandwidth_khz < MHZ_TO_KHZ(160))\n\t\t\tbw_flags |= IEEE80211_CHAN_NO_160MHZ;\n\t\tif (max_bandwidth_khz < MHZ_TO_KHZ(320))\n\t\t\tbw_flags |= IEEE80211_CHAN_NO_320MHZ;\n\t}\n\treturn bw_flags;\n}\n\nstatic void handle_channel_single_rule(struct wiphy *wiphy,\n\t\t\t\t       enum nl80211_reg_initiator initiator,\n\t\t\t\t       struct ieee80211_channel *chan,\n\t\t\t\t       u32 flags,\n\t\t\t\t       struct regulatory_request *lr,\n\t\t\t\t       struct wiphy *request_wiphy,\n\t\t\t\t       const struct ieee80211_reg_rule *reg_rule)\n{\n\tu32 bw_flags = 0;\n\tconst struct ieee80211_power_rule *power_rule = NULL;\n\tconst struct ieee80211_regdomain *regd;\n\n\tregd = reg_get_regdomain(wiphy);\n\n\tpower_rule = &reg_rule->power_rule;\n\tbw_flags = reg_rule_to_chan_bw_flags(regd, reg_rule, chan);\n\n\tif (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER &&\n\t    request_wiphy && request_wiphy == wiphy &&\n\t    request_wiphy->regulatory_flags & REGULATORY_STRICT_REG) {\n\t\t \n\t\tchan->flags = chan->orig_flags =\n\t\t\tmap_regdom_flags(reg_rule->flags) | bw_flags;\n\t\tchan->max_antenna_gain = chan->orig_mag =\n\t\t\t(int) MBI_TO_DBI(power_rule->max_antenna_gain);\n\t\tchan->max_reg_power = chan->max_power = chan->orig_mpwr =\n\t\t\t(int) MBM_TO_DBM(power_rule->max_eirp);\n\n\t\tif (chan->flags & IEEE80211_CHAN_RADAR) {\n\t\t\tchan->dfs_cac_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;\n\t\t\tif (reg_rule->dfs_cac_ms)\n\t\t\t\tchan->dfs_cac_ms = reg_rule->dfs_cac_ms;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tchan->dfs_state = NL80211_DFS_USABLE;\n\tchan->dfs_state_entered = jiffies;\n\n\tchan->beacon_found = false;\n\tchan->flags = flags | bw_flags | map_regdom_flags(reg_rule->flags);\n\tchan->max_antenna_gain =\n\t\tmin_t(int, chan->orig_mag,\n\t\t      MBI_TO_DBI(power_rule->max_antenna_gain));\n\tchan->max_reg_power = (int) MBM_TO_DBM(power_rule->max_eirp);\n\n\tif (chan->flags & IEEE80211_CHAN_RADAR) {\n\t\tif (reg_rule->dfs_cac_ms)\n\t\t\tchan->dfs_cac_ms = reg_rule->dfs_cac_ms;\n\t\telse\n\t\t\tchan->dfs_cac_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;\n\t}\n\n\tif (chan->orig_mpwr) {\n\t\t \n\t\tif (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&\n\t\t    wiphy->regulatory_flags & REGULATORY_COUNTRY_IE_FOLLOW_POWER)\n\t\t\tchan->max_power = chan->max_reg_power;\n\t\telse\n\t\t\tchan->max_power = min(chan->orig_mpwr,\n\t\t\t\t\t      chan->max_reg_power);\n\t} else\n\t\tchan->max_power = chan->max_reg_power;\n}\n\nstatic void handle_channel_adjacent_rules(struct wiphy *wiphy,\n\t\t\t\t\t  enum nl80211_reg_initiator initiator,\n\t\t\t\t\t  struct ieee80211_channel *chan,\n\t\t\t\t\t  u32 flags,\n\t\t\t\t\t  struct regulatory_request *lr,\n\t\t\t\t\t  struct wiphy *request_wiphy,\n\t\t\t\t\t  const struct ieee80211_reg_rule *rrule1,\n\t\t\t\t\t  const struct ieee80211_reg_rule *rrule2,\n\t\t\t\t\t  struct ieee80211_freq_range *comb_range)\n{\n\tu32 bw_flags1 = 0;\n\tu32 bw_flags2 = 0;\n\tconst struct ieee80211_power_rule *power_rule1 = NULL;\n\tconst struct ieee80211_power_rule *power_rule2 = NULL;\n\tconst struct ieee80211_regdomain *regd;\n\n\tregd = reg_get_regdomain(wiphy);\n\n\tpower_rule1 = &rrule1->power_rule;\n\tpower_rule2 = &rrule2->power_rule;\n\tbw_flags1 = reg_rule_to_chan_bw_flags(regd, rrule1, chan);\n\tbw_flags2 = reg_rule_to_chan_bw_flags(regd, rrule2, chan);\n\n\tif (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER &&\n\t    request_wiphy && request_wiphy == wiphy &&\n\t    request_wiphy->regulatory_flags & REGULATORY_STRICT_REG) {\n\t\t \n\t\tchan->flags =\n\t\t\tmap_regdom_flags(rrule1->flags) |\n\t\t\tmap_regdom_flags(rrule2->flags) |\n\t\t\tbw_flags1 |\n\t\t\tbw_flags2;\n\t\tchan->orig_flags = chan->flags;\n\t\tchan->max_antenna_gain =\n\t\t\tmin_t(int, MBI_TO_DBI(power_rule1->max_antenna_gain),\n\t\t\t      MBI_TO_DBI(power_rule2->max_antenna_gain));\n\t\tchan->orig_mag = chan->max_antenna_gain;\n\t\tchan->max_reg_power =\n\t\t\tmin_t(int, MBM_TO_DBM(power_rule1->max_eirp),\n\t\t\t      MBM_TO_DBM(power_rule2->max_eirp));\n\t\tchan->max_power = chan->max_reg_power;\n\t\tchan->orig_mpwr = chan->max_reg_power;\n\n\t\tif (chan->flags & IEEE80211_CHAN_RADAR) {\n\t\t\tchan->dfs_cac_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;\n\t\t\tif (rrule1->dfs_cac_ms || rrule2->dfs_cac_ms)\n\t\t\t\tchan->dfs_cac_ms = max_t(unsigned int,\n\t\t\t\t\t\t\t rrule1->dfs_cac_ms,\n\t\t\t\t\t\t\t rrule2->dfs_cac_ms);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tchan->dfs_state = NL80211_DFS_USABLE;\n\tchan->dfs_state_entered = jiffies;\n\n\tchan->beacon_found = false;\n\tchan->flags = flags | bw_flags1 | bw_flags2 |\n\t\t      map_regdom_flags(rrule1->flags) |\n\t\t      map_regdom_flags(rrule2->flags);\n\n\t \n\tif (cfg80211_does_bw_fit_range(comb_range,\n\t\t\t\t       ieee80211_channel_to_khz(chan),\n\t\t\t\t       MHZ_TO_KHZ(10)))\n\t\tchan->flags &= ~IEEE80211_CHAN_NO_10MHZ;\n\tif (cfg80211_does_bw_fit_range(comb_range,\n\t\t\t\t       ieee80211_channel_to_khz(chan),\n\t\t\t\t       MHZ_TO_KHZ(20)))\n\t\tchan->flags &= ~IEEE80211_CHAN_NO_20MHZ;\n\n\tchan->max_antenna_gain =\n\t\tmin_t(int, chan->orig_mag,\n\t\t      min_t(int,\n\t\t\t    MBI_TO_DBI(power_rule1->max_antenna_gain),\n\t\t\t    MBI_TO_DBI(power_rule2->max_antenna_gain)));\n\tchan->max_reg_power = min_t(int,\n\t\t\t\t    MBM_TO_DBM(power_rule1->max_eirp),\n\t\t\t\t    MBM_TO_DBM(power_rule2->max_eirp));\n\n\tif (chan->flags & IEEE80211_CHAN_RADAR) {\n\t\tif (rrule1->dfs_cac_ms || rrule2->dfs_cac_ms)\n\t\t\tchan->dfs_cac_ms = max_t(unsigned int,\n\t\t\t\t\t\t rrule1->dfs_cac_ms,\n\t\t\t\t\t\t rrule2->dfs_cac_ms);\n\t\telse\n\t\t\tchan->dfs_cac_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;\n\t}\n\n\tif (chan->orig_mpwr) {\n\t\t \n\t\tif (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&\n\t\t    wiphy->regulatory_flags & REGULATORY_COUNTRY_IE_FOLLOW_POWER)\n\t\t\tchan->max_power = chan->max_reg_power;\n\t\telse\n\t\t\tchan->max_power = min(chan->orig_mpwr,\n\t\t\t\t\t      chan->max_reg_power);\n\t} else {\n\t\tchan->max_power = chan->max_reg_power;\n\t}\n}\n\n \nstatic void handle_channel(struct wiphy *wiphy,\n\t\t\t   enum nl80211_reg_initiator initiator,\n\t\t\t   struct ieee80211_channel *chan)\n{\n\tconst u32 orig_chan_freq = ieee80211_channel_to_khz(chan);\n\tstruct regulatory_request *lr = get_last_request();\n\tstruct wiphy *request_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);\n\tconst struct ieee80211_reg_rule *rrule = NULL;\n\tconst struct ieee80211_reg_rule *rrule1 = NULL;\n\tconst struct ieee80211_reg_rule *rrule2 = NULL;\n\n\tu32 flags = chan->orig_flags;\n\n\trrule = freq_reg_info(wiphy, orig_chan_freq);\n\tif (IS_ERR(rrule)) {\n\t\t \n\t\trrule1 = freq_reg_info(wiphy,\n\t\t\t\t       orig_chan_freq - MHZ_TO_KHZ(20));\n\t\trrule2 = freq_reg_info(wiphy,\n\t\t\t\t       orig_chan_freq + MHZ_TO_KHZ(20));\n\t\tif (!IS_ERR(rrule1) && !IS_ERR(rrule2)) {\n\t\t\tstruct ieee80211_freq_range comb_range;\n\n\t\t\tif (rrule1->freq_range.end_freq_khz !=\n\t\t\t    rrule2->freq_range.start_freq_khz)\n\t\t\t\tgoto disable_chan;\n\n\t\t\tcomb_range.start_freq_khz =\n\t\t\t\trrule1->freq_range.start_freq_khz;\n\t\t\tcomb_range.end_freq_khz =\n\t\t\t\trrule2->freq_range.end_freq_khz;\n\t\t\tcomb_range.max_bandwidth_khz =\n\t\t\t\tmin_t(u32,\n\t\t\t\t      rrule1->freq_range.max_bandwidth_khz,\n\t\t\t\t      rrule2->freq_range.max_bandwidth_khz);\n\n\t\t\tif (!cfg80211_does_bw_fit_range(&comb_range,\n\t\t\t\t\t\t\torig_chan_freq,\n\t\t\t\t\t\t\tMHZ_TO_KHZ(20)))\n\t\t\t\tgoto disable_chan;\n\n\t\t\thandle_channel_adjacent_rules(wiphy, initiator, chan,\n\t\t\t\t\t\t      flags, lr, request_wiphy,\n\t\t\t\t\t\t      rrule1, rrule2,\n\t\t\t\t\t\t      &comb_range);\n\t\t\treturn;\n\t\t}\n\ndisable_chan:\n\t\t \n\t\tif (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&\n\t\t    PTR_ERR(rrule) == -ERANGE)\n\t\t\treturn;\n\n\t\tif (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER &&\n\t\t    request_wiphy && request_wiphy == wiphy &&\n\t\t    request_wiphy->regulatory_flags & REGULATORY_STRICT_REG) {\n\t\t\tpr_debug(\"Disabling freq %d.%03d MHz for good\\n\",\n\t\t\t\t chan->center_freq, chan->freq_offset);\n\t\t\tchan->orig_flags |= IEEE80211_CHAN_DISABLED;\n\t\t\tchan->flags = chan->orig_flags;\n\t\t} else {\n\t\t\tpr_debug(\"Disabling freq %d.%03d MHz\\n\",\n\t\t\t\t chan->center_freq, chan->freq_offset);\n\t\t\tchan->flags |= IEEE80211_CHAN_DISABLED;\n\t\t}\n\t\treturn;\n\t}\n\n\thandle_channel_single_rule(wiphy, initiator, chan, flags, lr,\n\t\t\t\t   request_wiphy, rrule);\n}\n\nstatic void handle_band(struct wiphy *wiphy,\n\t\t\tenum nl80211_reg_initiator initiator,\n\t\t\tstruct ieee80211_supported_band *sband)\n{\n\tunsigned int i;\n\n\tif (!sband)\n\t\treturn;\n\n\tfor (i = 0; i < sband->n_channels; i++)\n\t\thandle_channel(wiphy, initiator, &sband->channels[i]);\n}\n\nstatic bool reg_request_cell_base(struct regulatory_request *request)\n{\n\tif (request->initiator != NL80211_REGDOM_SET_BY_USER)\n\t\treturn false;\n\treturn request->user_reg_hint_type == NL80211_USER_REG_HINT_CELL_BASE;\n}\n\nbool reg_last_request_cell_base(void)\n{\n\treturn reg_request_cell_base(get_last_request());\n}\n\n#ifdef CONFIG_CFG80211_REG_CELLULAR_HINTS\n \nstatic enum reg_request_treatment\nreg_ignore_cell_hint(struct regulatory_request *pending_request)\n{\n\tstruct regulatory_request *lr = get_last_request();\n\n\tif (!reg_num_devs_support_basehint)\n\t\treturn REG_REQ_IGNORE;\n\n\tif (reg_request_cell_base(lr) &&\n\t    !regdom_changes(pending_request->alpha2))\n\t\treturn REG_REQ_ALREADY_SET;\n\n\treturn REG_REQ_OK;\n}\n\n \nstatic bool reg_dev_ignore_cell_hint(struct wiphy *wiphy)\n{\n\treturn !(wiphy->features & NL80211_FEATURE_CELL_BASE_REG_HINTS);\n}\n#else\nstatic enum reg_request_treatment\nreg_ignore_cell_hint(struct regulatory_request *pending_request)\n{\n\treturn REG_REQ_IGNORE;\n}\n\nstatic bool reg_dev_ignore_cell_hint(struct wiphy *wiphy)\n{\n\treturn true;\n}\n#endif\n\nstatic bool wiphy_strict_alpha2_regd(struct wiphy *wiphy)\n{\n\tif (wiphy->regulatory_flags & REGULATORY_STRICT_REG &&\n\t    !(wiphy->regulatory_flags & REGULATORY_CUSTOM_REG))\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool ignore_reg_update(struct wiphy *wiphy,\n\t\t\t      enum nl80211_reg_initiator initiator)\n{\n\tstruct regulatory_request *lr = get_last_request();\n\n\tif (wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED)\n\t\treturn true;\n\n\tif (!lr) {\n\t\tpr_debug(\"Ignoring regulatory request set by %s since last_request is not set\\n\",\n\t\t\t reg_initiator_name(initiator));\n\t\treturn true;\n\t}\n\n\tif (initiator == NL80211_REGDOM_SET_BY_CORE &&\n\t    wiphy->regulatory_flags & REGULATORY_CUSTOM_REG) {\n\t\tpr_debug(\"Ignoring regulatory request set by %s since the driver uses its own custom regulatory domain\\n\",\n\t\t\t reg_initiator_name(initiator));\n\t\treturn true;\n\t}\n\n\t \n\tif (wiphy_strict_alpha2_regd(wiphy) && !wiphy->regd &&\n\t    initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE &&\n\t    !is_world_regdom(lr->alpha2)) {\n\t\tpr_debug(\"Ignoring regulatory request set by %s since the driver requires its own regulatory domain to be set first\\n\",\n\t\t\t reg_initiator_name(initiator));\n\t\treturn true;\n\t}\n\n\tif (reg_request_cell_base(lr))\n\t\treturn reg_dev_ignore_cell_hint(wiphy);\n\n\treturn false;\n}\n\nstatic bool reg_is_world_roaming(struct wiphy *wiphy)\n{\n\tconst struct ieee80211_regdomain *cr = get_cfg80211_regdom();\n\tconst struct ieee80211_regdomain *wr = get_wiphy_regdom(wiphy);\n\tstruct regulatory_request *lr = get_last_request();\n\n\tif (is_world_regdom(cr->alpha2) || (wr && is_world_regdom(wr->alpha2)))\n\t\treturn true;\n\n\tif (lr && lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE &&\n\t    wiphy->regulatory_flags & REGULATORY_CUSTOM_REG)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void handle_reg_beacon(struct wiphy *wiphy, unsigned int chan_idx,\n\t\t\t      struct reg_beacon *reg_beacon)\n{\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *chan;\n\tbool channel_changed = false;\n\tstruct ieee80211_channel chan_before;\n\n\tsband = wiphy->bands[reg_beacon->chan.band];\n\tchan = &sband->channels[chan_idx];\n\n\tif (likely(!ieee80211_channel_equal(chan, &reg_beacon->chan)))\n\t\treturn;\n\n\tif (chan->beacon_found)\n\t\treturn;\n\n\tchan->beacon_found = true;\n\n\tif (!reg_is_world_roaming(wiphy))\n\t\treturn;\n\n\tif (wiphy->regulatory_flags & REGULATORY_DISABLE_BEACON_HINTS)\n\t\treturn;\n\n\tchan_before = *chan;\n\n\tif (chan->flags & IEEE80211_CHAN_NO_IR) {\n\t\tchan->flags &= ~IEEE80211_CHAN_NO_IR;\n\t\tchannel_changed = true;\n\t}\n\n\tif (channel_changed)\n\t\tnl80211_send_beacon_hint_event(wiphy, &chan_before, chan);\n}\n\n \nstatic void wiphy_update_new_beacon(struct wiphy *wiphy,\n\t\t\t\t    struct reg_beacon *reg_beacon)\n{\n\tunsigned int i;\n\tstruct ieee80211_supported_band *sband;\n\n\tif (!wiphy->bands[reg_beacon->chan.band])\n\t\treturn;\n\n\tsband = wiphy->bands[reg_beacon->chan.band];\n\n\tfor (i = 0; i < sband->n_channels; i++)\n\t\thandle_reg_beacon(wiphy, i, reg_beacon);\n}\n\n \nstatic void wiphy_update_beacon_reg(struct wiphy *wiphy)\n{\n\tunsigned int i;\n\tstruct ieee80211_supported_band *sband;\n\tstruct reg_beacon *reg_beacon;\n\n\tlist_for_each_entry(reg_beacon, &reg_beacon_list, list) {\n\t\tif (!wiphy->bands[reg_beacon->chan.band])\n\t\t\tcontinue;\n\t\tsband = wiphy->bands[reg_beacon->chan.band];\n\t\tfor (i = 0; i < sband->n_channels; i++)\n\t\t\thandle_reg_beacon(wiphy, i, reg_beacon);\n\t}\n}\n\n \nstatic void reg_process_beacons(struct wiphy *wiphy)\n{\n\t \n\tif (!last_request)\n\t\treturn;\n\twiphy_update_beacon_reg(wiphy);\n}\n\nstatic bool is_ht40_allowed(struct ieee80211_channel *chan)\n{\n\tif (!chan)\n\t\treturn false;\n\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn false;\n\t \n\tif ((chan->flags & IEEE80211_CHAN_NO_HT40) == IEEE80211_CHAN_NO_HT40)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void reg_process_ht_flags_channel(struct wiphy *wiphy,\n\t\t\t\t\t struct ieee80211_channel *channel)\n{\n\tstruct ieee80211_supported_band *sband = wiphy->bands[channel->band];\n\tstruct ieee80211_channel *channel_before = NULL, *channel_after = NULL;\n\tconst struct ieee80211_regdomain *regd;\n\tunsigned int i;\n\tu32 flags;\n\n\tif (!is_ht40_allowed(channel)) {\n\t\tchannel->flags |= IEEE80211_CHAN_NO_HT40;\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tstruct ieee80211_channel *c = &sband->channels[i];\n\n\t\tif (c->center_freq == (channel->center_freq - 20))\n\t\t\tchannel_before = c;\n\t\tif (c->center_freq == (channel->center_freq + 20))\n\t\t\tchannel_after = c;\n\t}\n\n\tflags = 0;\n\tregd = get_wiphy_regdom(wiphy);\n\tif (regd) {\n\t\tconst struct ieee80211_reg_rule *reg_rule =\n\t\t\tfreq_reg_info_regd(MHZ_TO_KHZ(channel->center_freq),\n\t\t\t\t\t   regd, MHZ_TO_KHZ(20));\n\n\t\tif (!IS_ERR(reg_rule))\n\t\t\tflags = reg_rule->flags;\n\t}\n\n\t \n\tif (!is_ht40_allowed(channel_before) ||\n\t    flags & NL80211_RRF_NO_HT40MINUS)\n\t\tchannel->flags |= IEEE80211_CHAN_NO_HT40MINUS;\n\telse\n\t\tchannel->flags &= ~IEEE80211_CHAN_NO_HT40MINUS;\n\n\tif (!is_ht40_allowed(channel_after) ||\n\t    flags & NL80211_RRF_NO_HT40PLUS)\n\t\tchannel->flags |= IEEE80211_CHAN_NO_HT40PLUS;\n\telse\n\t\tchannel->flags &= ~IEEE80211_CHAN_NO_HT40PLUS;\n}\n\nstatic void reg_process_ht_flags_band(struct wiphy *wiphy,\n\t\t\t\t      struct ieee80211_supported_band *sband)\n{\n\tunsigned int i;\n\n\tif (!sband)\n\t\treturn;\n\n\tfor (i = 0; i < sband->n_channels; i++)\n\t\treg_process_ht_flags_channel(wiphy, &sband->channels[i]);\n}\n\nstatic void reg_process_ht_flags(struct wiphy *wiphy)\n{\n\tenum nl80211_band band;\n\n\tif (!wiphy)\n\t\treturn;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++)\n\t\treg_process_ht_flags_band(wiphy, wiphy->bands[band]);\n}\n\nstatic void reg_call_notifier(struct wiphy *wiphy,\n\t\t\t      struct regulatory_request *request)\n{\n\tif (wiphy->reg_notifier)\n\t\twiphy->reg_notifier(wiphy, request);\n}\n\nstatic bool reg_wdev_chan_valid(struct wiphy *wiphy, struct wireless_dev *wdev)\n{\n\tstruct cfg80211_chan_def chandef = {};\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tenum nl80211_iftype iftype;\n\tbool ret;\n\tint link;\n\n\twdev_lock(wdev);\n\tiftype = wdev->iftype;\n\n\t \n\tif (!wdev->netdev || !netif_running(wdev->netdev))\n\t\tgoto wdev_inactive_unlock;\n\n\tfor (link = 0; link < ARRAY_SIZE(wdev->links); link++) {\n\t\tstruct ieee80211_channel *chan;\n\n\t\tif (!wdev->valid_links && link > 0)\n\t\t\tbreak;\n\t\tif (wdev->valid_links && !(wdev->valid_links & BIT(link)))\n\t\t\tcontinue;\n\t\tswitch (iftype) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\tif (!wdev->links[link].ap.beacon_interval)\n\t\t\t\tcontinue;\n\t\t\tchandef = wdev->links[link].ap.chandef;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tif (!wdev->u.mesh.beacon_interval)\n\t\t\t\tcontinue;\n\t\t\tchandef = wdev->u.mesh.chandef;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tif (!wdev->u.ibss.ssid_len)\n\t\t\t\tcontinue;\n\t\t\tchandef = wdev->u.ibss.chandef;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t\t \n\t\t\tif (!wdev->links[link].client.current_bss)\n\t\t\t\tcontinue;\n\n\t\t\tchan = wdev->links[link].client.current_bss->pub.channel;\n\t\t\tif (!chan)\n\t\t\t\tcontinue;\n\n\t\t\tif (!rdev->ops->get_channel ||\n\t\t\t    rdev_get_channel(rdev, wdev, link, &chandef))\n\t\t\t\tcfg80211_chandef_create(&chandef, chan,\n\t\t\t\t\t\t\tNL80211_CHAN_NO_HT);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MONITOR:\n\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t\t \n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_OCB:\n\t\t\tif (!wdev->u.ocb.chandef.chan)\n\t\t\t\tcontinue;\n\t\t\tchandef = wdev->u.ocb.chandef;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_NAN:\n\t\t\t \n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t \n\t\t\tWARN_ON_ONCE(1);\n\t\t\tbreak;\n\t\t}\n\n\t\twdev_unlock(wdev);\n\n\t\tswitch (iftype) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tret = cfg80211_reg_can_beacon_relax(wiphy, &chandef,\n\t\t\t\t\t\t\t    iftype);\n\t\t\tif (!ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t\tret = cfg80211_chandef_usable(wiphy, &chandef,\n\t\t\t\t\t\t      IEEE80211_CHAN_DISABLED);\n\t\t\tif (!ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\twdev_lock(wdev);\n\t}\n\n\twdev_unlock(wdev);\n\n\treturn true;\n\nwdev_inactive_unlock:\n\twdev_unlock(wdev);\n\treturn true;\n}\n\nstatic void reg_leave_invalid_chans(struct wiphy *wiphy)\n{\n\tstruct wireless_dev *wdev;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\twiphy_lock(wiphy);\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list)\n\t\tif (!reg_wdev_chan_valid(wiphy, wdev))\n\t\t\tcfg80211_leave(rdev, wdev);\n\twiphy_unlock(wiphy);\n}\n\nstatic void reg_check_chans_work(struct work_struct *work)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\tpr_debug(\"Verifying active interfaces after reg change\\n\");\n\trtnl_lock();\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list)\n\t\treg_leave_invalid_chans(&rdev->wiphy);\n\n\trtnl_unlock();\n}\n\nstatic void reg_check_channels(void)\n{\n\t \n\tmod_delayed_work(system_power_efficient_wq,\n\t\t\t &reg_check_chans,\n\t\t\t msecs_to_jiffies(REG_ENFORCE_GRACE_MS));\n}\n\nstatic void wiphy_update_regulatory(struct wiphy *wiphy,\n\t\t\t\t    enum nl80211_reg_initiator initiator)\n{\n\tenum nl80211_band band;\n\tstruct regulatory_request *lr = get_last_request();\n\n\tif (ignore_reg_update(wiphy, initiator)) {\n\t\t \n\t\tif (initiator == NL80211_REGDOM_SET_BY_CORE &&\n\t\t    wiphy->regulatory_flags & REGULATORY_CUSTOM_REG &&\n\t\t    !(wiphy->regulatory_flags &\n\t\t      REGULATORY_WIPHY_SELF_MANAGED))\n\t\t\treg_call_notifier(wiphy, lr);\n\t\treturn;\n\t}\n\n\tlr->dfs_region = get_cfg80211_regdom()->dfs_region;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++)\n\t\thandle_band(wiphy, initiator, wiphy->bands[band]);\n\n\treg_process_beacons(wiphy);\n\treg_process_ht_flags(wiphy);\n\treg_call_notifier(wiphy, lr);\n}\n\nstatic void update_all_wiphy_regulatory(enum nl80211_reg_initiator initiator)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wiphy *wiphy;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\twiphy = &rdev->wiphy;\n\t\twiphy_update_regulatory(wiphy, initiator);\n\t}\n\n\treg_check_channels();\n}\n\nstatic void handle_channel_custom(struct wiphy *wiphy,\n\t\t\t\t  struct ieee80211_channel *chan,\n\t\t\t\t  const struct ieee80211_regdomain *regd,\n\t\t\t\t  u32 min_bw)\n{\n\tu32 bw_flags = 0;\n\tconst struct ieee80211_reg_rule *reg_rule = NULL;\n\tconst struct ieee80211_power_rule *power_rule = NULL;\n\tu32 bw, center_freq_khz;\n\n\tcenter_freq_khz = ieee80211_channel_to_khz(chan);\n\tfor (bw = MHZ_TO_KHZ(20); bw >= min_bw; bw = bw / 2) {\n\t\treg_rule = freq_reg_info_regd(center_freq_khz, regd, bw);\n\t\tif (!IS_ERR(reg_rule))\n\t\t\tbreak;\n\t}\n\n\tif (IS_ERR_OR_NULL(reg_rule)) {\n\t\tpr_debug(\"Disabling freq %d.%03d MHz as custom regd has no rule that fits it\\n\",\n\t\t\t chan->center_freq, chan->freq_offset);\n\t\tif (wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED) {\n\t\t\tchan->flags |= IEEE80211_CHAN_DISABLED;\n\t\t} else {\n\t\t\tchan->orig_flags |= IEEE80211_CHAN_DISABLED;\n\t\t\tchan->flags = chan->orig_flags;\n\t\t}\n\t\treturn;\n\t}\n\n\tpower_rule = &reg_rule->power_rule;\n\tbw_flags = reg_rule_to_chan_bw_flags(regd, reg_rule, chan);\n\n\tchan->dfs_state_entered = jiffies;\n\tchan->dfs_state = NL80211_DFS_USABLE;\n\n\tchan->beacon_found = false;\n\n\tif (wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED)\n\t\tchan->flags = chan->orig_flags | bw_flags |\n\t\t\t      map_regdom_flags(reg_rule->flags);\n\telse\n\t\tchan->flags |= map_regdom_flags(reg_rule->flags) | bw_flags;\n\n\tchan->max_antenna_gain = (int) MBI_TO_DBI(power_rule->max_antenna_gain);\n\tchan->max_reg_power = chan->max_power =\n\t\t(int) MBM_TO_DBM(power_rule->max_eirp);\n\n\tif (chan->flags & IEEE80211_CHAN_RADAR) {\n\t\tif (reg_rule->dfs_cac_ms)\n\t\t\tchan->dfs_cac_ms = reg_rule->dfs_cac_ms;\n\t\telse\n\t\t\tchan->dfs_cac_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;\n\t}\n\n\tchan->max_power = chan->max_reg_power;\n}\n\nstatic void handle_band_custom(struct wiphy *wiphy,\n\t\t\t       struct ieee80211_supported_band *sband,\n\t\t\t       const struct ieee80211_regdomain *regd)\n{\n\tunsigned int i;\n\n\tif (!sband)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < sband->n_channels; i++)\n\t\thandle_channel_custom(wiphy, &sband->channels[i], regd,\n\t\t\t\t      MHZ_TO_KHZ(20));\n}\n\n \nvoid wiphy_apply_custom_regulatory(struct wiphy *wiphy,\n\t\t\t\t   const struct ieee80211_regdomain *regd)\n{\n\tconst struct ieee80211_regdomain *new_regd, *tmp;\n\tenum nl80211_band band;\n\tunsigned int bands_set = 0;\n\n\tWARN(!(wiphy->regulatory_flags & REGULATORY_CUSTOM_REG),\n\t     \"wiphy should have REGULATORY_CUSTOM_REG\\n\");\n\twiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!wiphy->bands[band])\n\t\t\tcontinue;\n\t\thandle_band_custom(wiphy, wiphy->bands[band], regd);\n\t\tbands_set++;\n\t}\n\n\t \n\tWARN_ON(!bands_set);\n\tnew_regd = reg_copy_regd(regd);\n\tif (IS_ERR(new_regd))\n\t\treturn;\n\n\trtnl_lock();\n\twiphy_lock(wiphy);\n\n\ttmp = get_wiphy_regdom(wiphy);\n\trcu_assign_pointer(wiphy->regd, new_regd);\n\trcu_free_regdom(tmp);\n\n\twiphy_unlock(wiphy);\n\trtnl_unlock();\n}\nEXPORT_SYMBOL(wiphy_apply_custom_regulatory);\n\nstatic void reg_set_request_processed(void)\n{\n\tbool need_more_processing = false;\n\tstruct regulatory_request *lr = get_last_request();\n\n\tlr->processed = true;\n\n\tspin_lock(&reg_requests_lock);\n\tif (!list_empty(&reg_requests_list))\n\t\tneed_more_processing = true;\n\tspin_unlock(&reg_requests_lock);\n\n\tcancel_crda_timeout();\n\n\tif (need_more_processing)\n\t\tschedule_work(&reg_work);\n}\n\n \nstatic enum reg_request_treatment\nreg_process_hint_core(struct regulatory_request *core_request)\n{\n\tif (reg_query_database(core_request)) {\n\t\tcore_request->intersect = false;\n\t\tcore_request->processed = false;\n\t\treg_update_last_request(core_request);\n\t\treturn REG_REQ_OK;\n\t}\n\n\treturn REG_REQ_IGNORE;\n}\n\nstatic enum reg_request_treatment\n__reg_process_hint_user(struct regulatory_request *user_request)\n{\n\tstruct regulatory_request *lr = get_last_request();\n\n\tif (reg_request_cell_base(user_request))\n\t\treturn reg_ignore_cell_hint(user_request);\n\n\tif (reg_request_cell_base(lr))\n\t\treturn REG_REQ_IGNORE;\n\n\tif (lr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE)\n\t\treturn REG_REQ_INTERSECT;\n\t \n\tif (lr->initiator == NL80211_REGDOM_SET_BY_USER &&\n\t    lr->intersect)\n\t\treturn REG_REQ_IGNORE;\n\t \n\tif ((lr->initiator == NL80211_REGDOM_SET_BY_CORE ||\n\t     lr->initiator == NL80211_REGDOM_SET_BY_DRIVER ||\n\t     lr->initiator == NL80211_REGDOM_SET_BY_USER) &&\n\t    regdom_changes(lr->alpha2))\n\t\treturn REG_REQ_IGNORE;\n\n\tif (!regdom_changes(user_request->alpha2))\n\t\treturn REG_REQ_ALREADY_SET;\n\n\treturn REG_REQ_OK;\n}\n\n \nstatic enum reg_request_treatment\nreg_process_hint_user(struct regulatory_request *user_request)\n{\n\tenum reg_request_treatment treatment;\n\n\ttreatment = __reg_process_hint_user(user_request);\n\tif (treatment == REG_REQ_IGNORE ||\n\t    treatment == REG_REQ_ALREADY_SET)\n\t\treturn REG_REQ_IGNORE;\n\n\tuser_request->intersect = treatment == REG_REQ_INTERSECT;\n\tuser_request->processed = false;\n\n\tif (reg_query_database(user_request)) {\n\t\treg_update_last_request(user_request);\n\t\tuser_alpha2[0] = user_request->alpha2[0];\n\t\tuser_alpha2[1] = user_request->alpha2[1];\n\t\treturn REG_REQ_OK;\n\t}\n\n\treturn REG_REQ_IGNORE;\n}\n\nstatic enum reg_request_treatment\n__reg_process_hint_driver(struct regulatory_request *driver_request)\n{\n\tstruct regulatory_request *lr = get_last_request();\n\n\tif (lr->initiator == NL80211_REGDOM_SET_BY_CORE) {\n\t\tif (regdom_changes(driver_request->alpha2))\n\t\t\treturn REG_REQ_OK;\n\t\treturn REG_REQ_ALREADY_SET;\n\t}\n\n\t \n\tif (lr->initiator == NL80211_REGDOM_SET_BY_DRIVER &&\n\t    !regdom_changes(driver_request->alpha2))\n\t\treturn REG_REQ_ALREADY_SET;\n\n\treturn REG_REQ_INTERSECT;\n}\n\n \nstatic enum reg_request_treatment\nreg_process_hint_driver(struct wiphy *wiphy,\n\t\t\tstruct regulatory_request *driver_request)\n{\n\tconst struct ieee80211_regdomain *regd, *tmp;\n\tenum reg_request_treatment treatment;\n\n\ttreatment = __reg_process_hint_driver(driver_request);\n\n\tswitch (treatment) {\n\tcase REG_REQ_OK:\n\t\tbreak;\n\tcase REG_REQ_IGNORE:\n\t\treturn REG_REQ_IGNORE;\n\tcase REG_REQ_INTERSECT:\n\tcase REG_REQ_ALREADY_SET:\n\t\tregd = reg_copy_regd(get_cfg80211_regdom());\n\t\tif (IS_ERR(regd))\n\t\t\treturn REG_REQ_IGNORE;\n\n\t\ttmp = get_wiphy_regdom(wiphy);\n\t\tASSERT_RTNL();\n\t\twiphy_lock(wiphy);\n\t\trcu_assign_pointer(wiphy->regd, regd);\n\t\twiphy_unlock(wiphy);\n\t\trcu_free_regdom(tmp);\n\t}\n\n\n\tdriver_request->intersect = treatment == REG_REQ_INTERSECT;\n\tdriver_request->processed = false;\n\n\t \n\tif (treatment == REG_REQ_ALREADY_SET) {\n\t\tnl80211_send_reg_change_event(driver_request);\n\t\treg_update_last_request(driver_request);\n\t\treg_set_request_processed();\n\t\treturn REG_REQ_ALREADY_SET;\n\t}\n\n\tif (reg_query_database(driver_request)) {\n\t\treg_update_last_request(driver_request);\n\t\treturn REG_REQ_OK;\n\t}\n\n\treturn REG_REQ_IGNORE;\n}\n\nstatic enum reg_request_treatment\n__reg_process_hint_country_ie(struct wiphy *wiphy,\n\t\t\t      struct regulatory_request *country_ie_request)\n{\n\tstruct wiphy *last_wiphy = NULL;\n\tstruct regulatory_request *lr = get_last_request();\n\n\tif (reg_request_cell_base(lr)) {\n\t\t \n\t\tif (regdom_changes(country_ie_request->alpha2))\n\t\t\treturn REG_REQ_IGNORE;\n\t\treturn REG_REQ_ALREADY_SET;\n\t} else {\n\t\tif (wiphy->regulatory_flags & REGULATORY_COUNTRY_IE_IGNORE)\n\t\t\treturn REG_REQ_IGNORE;\n\t}\n\n\tif (unlikely(!is_an_alpha2(country_ie_request->alpha2)))\n\t\treturn -EINVAL;\n\n\tif (lr->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE)\n\t\treturn REG_REQ_OK;\n\n\tlast_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);\n\n\tif (last_wiphy != wiphy) {\n\t\t \n\t\tif (regdom_changes(country_ie_request->alpha2))\n\t\t\treturn REG_REQ_IGNORE;\n\t\treturn REG_REQ_ALREADY_SET;\n\t}\n\n\tif (regdom_changes(country_ie_request->alpha2))\n\t\treturn REG_REQ_OK;\n\treturn REG_REQ_ALREADY_SET;\n}\n\n \nstatic enum reg_request_treatment\nreg_process_hint_country_ie(struct wiphy *wiphy,\n\t\t\t    struct regulatory_request *country_ie_request)\n{\n\tenum reg_request_treatment treatment;\n\n\ttreatment = __reg_process_hint_country_ie(wiphy, country_ie_request);\n\n\tswitch (treatment) {\n\tcase REG_REQ_OK:\n\t\tbreak;\n\tcase REG_REQ_IGNORE:\n\t\treturn REG_REQ_IGNORE;\n\tcase REG_REQ_ALREADY_SET:\n\t\treg_free_request(country_ie_request);\n\t\treturn REG_REQ_ALREADY_SET;\n\tcase REG_REQ_INTERSECT:\n\t\t \n\t\tWARN_ONCE(1, \"Unexpected intersection for country elements\");\n\t\treturn REG_REQ_IGNORE;\n\t}\n\n\tcountry_ie_request->intersect = false;\n\tcountry_ie_request->processed = false;\n\n\tif (reg_query_database(country_ie_request)) {\n\t\treg_update_last_request(country_ie_request);\n\t\treturn REG_REQ_OK;\n\t}\n\n\treturn REG_REQ_IGNORE;\n}\n\nbool reg_dfs_domain_same(struct wiphy *wiphy1, struct wiphy *wiphy2)\n{\n\tconst struct ieee80211_regdomain *wiphy1_regd = NULL;\n\tconst struct ieee80211_regdomain *wiphy2_regd = NULL;\n\tconst struct ieee80211_regdomain *cfg80211_regd = NULL;\n\tbool dfs_domain_same;\n\n\trcu_read_lock();\n\n\tcfg80211_regd = rcu_dereference(cfg80211_regdomain);\n\twiphy1_regd = rcu_dereference(wiphy1->regd);\n\tif (!wiphy1_regd)\n\t\twiphy1_regd = cfg80211_regd;\n\n\twiphy2_regd = rcu_dereference(wiphy2->regd);\n\tif (!wiphy2_regd)\n\t\twiphy2_regd = cfg80211_regd;\n\n\tdfs_domain_same = wiphy1_regd->dfs_region == wiphy2_regd->dfs_region;\n\n\trcu_read_unlock();\n\n\treturn dfs_domain_same;\n}\n\nstatic void reg_copy_dfs_chan_state(struct ieee80211_channel *dst_chan,\n\t\t\t\t    struct ieee80211_channel *src_chan)\n{\n\tif (!(dst_chan->flags & IEEE80211_CHAN_RADAR) ||\n\t    !(src_chan->flags & IEEE80211_CHAN_RADAR))\n\t\treturn;\n\n\tif (dst_chan->flags & IEEE80211_CHAN_DISABLED ||\n\t    src_chan->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn;\n\n\tif (src_chan->center_freq == dst_chan->center_freq &&\n\t    dst_chan->dfs_state == NL80211_DFS_USABLE) {\n\t\tdst_chan->dfs_state = src_chan->dfs_state;\n\t\tdst_chan->dfs_state_entered = src_chan->dfs_state_entered;\n\t}\n}\n\nstatic void wiphy_share_dfs_chan_state(struct wiphy *dst_wiphy,\n\t\t\t\t       struct wiphy *src_wiphy)\n{\n\tstruct ieee80211_supported_band *src_sband, *dst_sband;\n\tstruct ieee80211_channel *src_chan, *dst_chan;\n\tint i, j, band;\n\n\tif (!reg_dfs_domain_same(dst_wiphy, src_wiphy))\n\t\treturn;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tdst_sband = dst_wiphy->bands[band];\n\t\tsrc_sband = src_wiphy->bands[band];\n\t\tif (!dst_sband || !src_sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < dst_sband->n_channels; i++) {\n\t\t\tdst_chan = &dst_sband->channels[i];\n\t\t\tfor (j = 0; j < src_sband->n_channels; j++) {\n\t\t\t\tsrc_chan = &src_sband->channels[j];\n\t\t\t\treg_copy_dfs_chan_state(dst_chan, src_chan);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void wiphy_all_share_dfs_chan_state(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (wiphy == &rdev->wiphy)\n\t\t\tcontinue;\n\t\twiphy_share_dfs_chan_state(wiphy, &rdev->wiphy);\n\t}\n}\n\n \nstatic void reg_process_hint(struct regulatory_request *reg_request)\n{\n\tstruct wiphy *wiphy = NULL;\n\tenum reg_request_treatment treatment;\n\tenum nl80211_reg_initiator initiator = reg_request->initiator;\n\n\tif (reg_request->wiphy_idx != WIPHY_IDX_INVALID)\n\t\twiphy = wiphy_idx_to_wiphy(reg_request->wiphy_idx);\n\n\tswitch (initiator) {\n\tcase NL80211_REGDOM_SET_BY_CORE:\n\t\ttreatment = reg_process_hint_core(reg_request);\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_USER:\n\t\ttreatment = reg_process_hint_user(reg_request);\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_DRIVER:\n\t\tif (!wiphy)\n\t\t\tgoto out_free;\n\t\ttreatment = reg_process_hint_driver(wiphy, reg_request);\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_COUNTRY_IE:\n\t\tif (!wiphy)\n\t\t\tgoto out_free;\n\t\ttreatment = reg_process_hint_country_ie(wiphy, reg_request);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"invalid initiator %d\\n\", initiator);\n\t\tgoto out_free;\n\t}\n\n\tif (treatment == REG_REQ_IGNORE)\n\t\tgoto out_free;\n\n\tWARN(treatment != REG_REQ_OK && treatment != REG_REQ_ALREADY_SET,\n\t     \"unexpected treatment value %d\\n\", treatment);\n\n\t \n\tif (treatment == REG_REQ_ALREADY_SET && wiphy &&\n\t    wiphy->regulatory_flags & REGULATORY_STRICT_REG) {\n\t\twiphy_update_regulatory(wiphy, initiator);\n\t\twiphy_all_share_dfs_chan_state(wiphy);\n\t\treg_check_channels();\n\t}\n\n\treturn;\n\nout_free:\n\treg_free_request(reg_request);\n}\n\nstatic void notify_self_managed_wiphys(struct regulatory_request *request)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wiphy *wiphy;\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\twiphy = &rdev->wiphy;\n\t\tif (wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t\t    request->initiator == NL80211_REGDOM_SET_BY_USER)\n\t\t\treg_call_notifier(wiphy, request);\n\t}\n}\n\n \nstatic void reg_process_pending_hints(void)\n{\n\tstruct regulatory_request *reg_request, *lr;\n\n\tlr = get_last_request();\n\n\t \n\tif (lr && !lr->processed) {\n\t\tpr_debug(\"Pending regulatory request, waiting for it to be processed...\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock(&reg_requests_lock);\n\n\tif (list_empty(&reg_requests_list)) {\n\t\tspin_unlock(&reg_requests_lock);\n\t\treturn;\n\t}\n\n\treg_request = list_first_entry(&reg_requests_list,\n\t\t\t\t       struct regulatory_request,\n\t\t\t\t       list);\n\tlist_del_init(&reg_request->list);\n\n\tspin_unlock(&reg_requests_lock);\n\n\tnotify_self_managed_wiphys(reg_request);\n\n\treg_process_hint(reg_request);\n\n\tlr = get_last_request();\n\n\tspin_lock(&reg_requests_lock);\n\tif (!list_empty(&reg_requests_list) && lr && lr->processed)\n\t\tschedule_work(&reg_work);\n\tspin_unlock(&reg_requests_lock);\n}\n\n \nstatic void reg_process_pending_beacon_hints(void)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct reg_beacon *pending_beacon, *tmp;\n\n\t \n\tspin_lock_bh(&reg_pending_beacons_lock);\n\n\tlist_for_each_entry_safe(pending_beacon, tmp,\n\t\t\t\t &reg_pending_beacons, list) {\n\t\tlist_del_init(&pending_beacon->list);\n\n\t\t \n\t\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list)\n\t\t\twiphy_update_new_beacon(&rdev->wiphy, pending_beacon);\n\n\t\t \n\t\tlist_add_tail(&pending_beacon->list, &reg_beacon_list);\n\t}\n\n\tspin_unlock_bh(&reg_pending_beacons_lock);\n}\n\nstatic void reg_process_self_managed_hint(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tconst struct ieee80211_regdomain *tmp;\n\tconst struct ieee80211_regdomain *regd;\n\tenum nl80211_band band;\n\tstruct regulatory_request request = {};\n\n\tASSERT_RTNL();\n\tlockdep_assert_wiphy(wiphy);\n\n\tspin_lock(&reg_requests_lock);\n\tregd = rdev->requested_regd;\n\trdev->requested_regd = NULL;\n\tspin_unlock(&reg_requests_lock);\n\n\tif (!regd)\n\t\treturn;\n\n\ttmp = get_wiphy_regdom(wiphy);\n\trcu_assign_pointer(wiphy->regd, regd);\n\trcu_free_regdom(tmp);\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++)\n\t\thandle_band_custom(wiphy, wiphy->bands[band], regd);\n\n\treg_process_ht_flags(wiphy);\n\n\trequest.wiphy_idx = get_wiphy_idx(wiphy);\n\trequest.alpha2[0] = regd->alpha2[0];\n\trequest.alpha2[1] = regd->alpha2[1];\n\trequest.initiator = NL80211_REGDOM_SET_BY_DRIVER;\n\n\tif (wiphy->flags & WIPHY_FLAG_NOTIFY_REGDOM_BY_DRIVER)\n\t\treg_call_notifier(wiphy, &request);\n\n\tnl80211_send_wiphy_reg_change_event(&request);\n}\n\nstatic void reg_process_self_managed_hints(void)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\twiphy_lock(&rdev->wiphy);\n\t\treg_process_self_managed_hint(&rdev->wiphy);\n\t\twiphy_unlock(&rdev->wiphy);\n\t}\n\n\treg_check_channels();\n}\n\nstatic void reg_todo(struct work_struct *work)\n{\n\trtnl_lock();\n\treg_process_pending_hints();\n\treg_process_pending_beacon_hints();\n\treg_process_self_managed_hints();\n\trtnl_unlock();\n}\n\nstatic void queue_regulatory_request(struct regulatory_request *request)\n{\n\trequest->alpha2[0] = toupper(request->alpha2[0]);\n\trequest->alpha2[1] = toupper(request->alpha2[1]);\n\n\tspin_lock(&reg_requests_lock);\n\tlist_add_tail(&request->list, &reg_requests_list);\n\tspin_unlock(&reg_requests_lock);\n\n\tschedule_work(&reg_work);\n}\n\n \nstatic int regulatory_hint_core(const char *alpha2)\n{\n\tstruct regulatory_request *request;\n\n\trequest = kzalloc(sizeof(struct regulatory_request), GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\trequest->alpha2[0] = alpha2[0];\n\trequest->alpha2[1] = alpha2[1];\n\trequest->initiator = NL80211_REGDOM_SET_BY_CORE;\n\trequest->wiphy_idx = WIPHY_IDX_INVALID;\n\n\tqueue_regulatory_request(request);\n\n\treturn 0;\n}\n\n \nint regulatory_hint_user(const char *alpha2,\n\t\t\t enum nl80211_user_reg_hint_type user_reg_hint_type)\n{\n\tstruct regulatory_request *request;\n\n\tif (WARN_ON(!alpha2))\n\t\treturn -EINVAL;\n\n\tif (!is_world_regdom(alpha2) && !is_an_alpha2(alpha2))\n\t\treturn -EINVAL;\n\n\trequest = kzalloc(sizeof(struct regulatory_request), GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\trequest->wiphy_idx = WIPHY_IDX_INVALID;\n\trequest->alpha2[0] = alpha2[0];\n\trequest->alpha2[1] = alpha2[1];\n\trequest->initiator = NL80211_REGDOM_SET_BY_USER;\n\trequest->user_reg_hint_type = user_reg_hint_type;\n\n\t \n\treset_crda_timeouts();\n\n\tqueue_regulatory_request(request);\n\n\treturn 0;\n}\n\nint regulatory_hint_indoor(bool is_indoor, u32 portid)\n{\n\tspin_lock(&reg_indoor_lock);\n\n\t \n\treg_is_indoor = is_indoor;\n\tif (reg_is_indoor) {\n\t\tif (!reg_is_indoor_portid)\n\t\t\treg_is_indoor_portid = portid;\n\t} else {\n\t\treg_is_indoor_portid = 0;\n\t}\n\n\tspin_unlock(&reg_indoor_lock);\n\n\tif (!is_indoor)\n\t\treg_check_channels();\n\n\treturn 0;\n}\n\nvoid regulatory_netlink_notify(u32 portid)\n{\n\tspin_lock(&reg_indoor_lock);\n\n\tif (reg_is_indoor_portid != portid) {\n\t\tspin_unlock(&reg_indoor_lock);\n\t\treturn;\n\t}\n\n\treg_is_indoor = false;\n\treg_is_indoor_portid = 0;\n\n\tspin_unlock(&reg_indoor_lock);\n\n\treg_check_channels();\n}\n\n \nint regulatory_hint(struct wiphy *wiphy, const char *alpha2)\n{\n\tstruct regulatory_request *request;\n\n\tif (WARN_ON(!alpha2 || !wiphy))\n\t\treturn -EINVAL;\n\n\twiphy->regulatory_flags &= ~REGULATORY_CUSTOM_REG;\n\n\trequest = kzalloc(sizeof(struct regulatory_request), GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\trequest->wiphy_idx = get_wiphy_idx(wiphy);\n\n\trequest->alpha2[0] = alpha2[0];\n\trequest->alpha2[1] = alpha2[1];\n\trequest->initiator = NL80211_REGDOM_SET_BY_DRIVER;\n\n\t \n\treset_crda_timeouts();\n\n\tqueue_regulatory_request(request);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(regulatory_hint);\n\nvoid regulatory_hint_country_ie(struct wiphy *wiphy, enum nl80211_band band,\n\t\t\t\tconst u8 *country_ie, u8 country_ie_len)\n{\n\tchar alpha2[2];\n\tenum environment_cap env = ENVIRON_ANY;\n\tstruct regulatory_request *request = NULL, *lr;\n\n\t \n\tif (country_ie_len & 0x01)\n\t\treturn;\n\n\tif (country_ie_len < IEEE80211_COUNTRY_IE_MIN_LEN)\n\t\treturn;\n\n\trequest = kzalloc(sizeof(*request), GFP_KERNEL);\n\tif (!request)\n\t\treturn;\n\n\talpha2[0] = country_ie[0];\n\talpha2[1] = country_ie[1];\n\n\tif (country_ie[2] == 'I')\n\t\tenv = ENVIRON_INDOOR;\n\telse if (country_ie[2] == 'O')\n\t\tenv = ENVIRON_OUTDOOR;\n\n\trcu_read_lock();\n\tlr = get_last_request();\n\n\tif (unlikely(!lr))\n\t\tgoto out;\n\n\t \n\tif (lr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&\n\t    lr->wiphy_idx != WIPHY_IDX_INVALID)\n\t\tgoto out;\n\n\trequest->wiphy_idx = get_wiphy_idx(wiphy);\n\trequest->alpha2[0] = alpha2[0];\n\trequest->alpha2[1] = alpha2[1];\n\trequest->initiator = NL80211_REGDOM_SET_BY_COUNTRY_IE;\n\trequest->country_ie_env = env;\n\n\t \n\treset_crda_timeouts();\n\n\tqueue_regulatory_request(request);\n\trequest = NULL;\nout:\n\tkfree(request);\n\trcu_read_unlock();\n}\n\nstatic void restore_alpha2(char *alpha2, bool reset_user)\n{\n\t \n\talpha2[0] = '9';\n\talpha2[1] = '7';\n\n\t \n\tif (is_user_regdom_saved()) {\n\t\t \n\t\tif (reset_user) {\n\t\t\tpr_debug(\"Restoring regulatory settings including user preference\\n\");\n\t\t\tuser_alpha2[0] = '9';\n\t\t\tuser_alpha2[1] = '7';\n\n\t\t\t \n\t\t\tif (!is_world_regdom(ieee80211_regdom)) {\n\t\t\t\tpr_debug(\"Keeping preference on module parameter ieee80211_regdom: %c%c\\n\",\n\t\t\t\t\t ieee80211_regdom[0], ieee80211_regdom[1]);\n\t\t\t\talpha2[0] = ieee80211_regdom[0];\n\t\t\t\talpha2[1] = ieee80211_regdom[1];\n\t\t\t}\n\t\t} else {\n\t\t\tpr_debug(\"Restoring regulatory settings while preserving user preference for: %c%c\\n\",\n\t\t\t\t user_alpha2[0], user_alpha2[1]);\n\t\t\talpha2[0] = user_alpha2[0];\n\t\t\talpha2[1] = user_alpha2[1];\n\t\t}\n\t} else if (!is_world_regdom(ieee80211_regdom)) {\n\t\tpr_debug(\"Keeping preference on module parameter ieee80211_regdom: %c%c\\n\",\n\t\t\t ieee80211_regdom[0], ieee80211_regdom[1]);\n\t\talpha2[0] = ieee80211_regdom[0];\n\t\talpha2[1] = ieee80211_regdom[1];\n\t} else\n\t\tpr_debug(\"Restoring regulatory settings\\n\");\n}\n\nstatic void restore_custom_reg_settings(struct wiphy *wiphy)\n{\n\tstruct ieee80211_supported_band *sband;\n\tenum nl80211_band band;\n\tstruct ieee80211_channel *chan;\n\tint i;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\tchan = &sband->channels[i];\n\t\t\tchan->flags = chan->orig_flags;\n\t\t\tchan->max_antenna_gain = chan->orig_mag;\n\t\t\tchan->max_power = chan->orig_mpwr;\n\t\t\tchan->beacon_found = false;\n\t\t}\n\t}\n}\n\n \nstatic void restore_regulatory_settings(bool reset_user, bool cached)\n{\n\tchar alpha2[2];\n\tchar world_alpha2[2];\n\tstruct reg_beacon *reg_beacon, *btmp;\n\tLIST_HEAD(tmp_reg_req_list);\n\tstruct cfg80211_registered_device *rdev;\n\n\tASSERT_RTNL();\n\n\t \n\tspin_lock(&reg_indoor_lock);\n\tif (reg_is_indoor && !reg_is_indoor_portid) {\n\t\treg_is_indoor = false;\n\t\treg_check_channels();\n\t}\n\tspin_unlock(&reg_indoor_lock);\n\n\treset_regdomains(true, &world_regdom);\n\trestore_alpha2(alpha2, reset_user);\n\n\t \n\tspin_lock(&reg_requests_lock);\n\tlist_splice_tail_init(&reg_requests_list, &tmp_reg_req_list);\n\tspin_unlock(&reg_requests_lock);\n\n\t \n\tspin_lock_bh(&reg_pending_beacons_lock);\n\tlist_for_each_entry_safe(reg_beacon, btmp, &reg_pending_beacons, list) {\n\t\tlist_del(&reg_beacon->list);\n\t\tkfree(reg_beacon);\n\t}\n\tspin_unlock_bh(&reg_pending_beacons_lock);\n\n\tlist_for_each_entry_safe(reg_beacon, btmp, &reg_beacon_list, list) {\n\t\tlist_del(&reg_beacon->list);\n\t\tkfree(reg_beacon);\n\t}\n\n\t \n\tworld_alpha2[0] = cfg80211_world_regdom->alpha2[0];\n\tworld_alpha2[1] = cfg80211_world_regdom->alpha2[1];\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (rdev->wiphy.regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED)\n\t\t\tcontinue;\n\t\tif (rdev->wiphy.regulatory_flags & REGULATORY_CUSTOM_REG)\n\t\t\trestore_custom_reg_settings(&rdev->wiphy);\n\t}\n\n\tif (cached && (!is_an_alpha2(alpha2) ||\n\t\t       !IS_ERR_OR_NULL(cfg80211_user_regdom))) {\n\t\treset_regdomains(false, cfg80211_world_regdom);\n\t\tupdate_all_wiphy_regulatory(NL80211_REGDOM_SET_BY_CORE);\n\t\tprint_regdomain(get_cfg80211_regdom());\n\t\tnl80211_send_reg_change_event(&core_request_world);\n\t\treg_set_request_processed();\n\n\t\tif (is_an_alpha2(alpha2) &&\n\t\t    !regulatory_hint_user(alpha2, NL80211_USER_REG_HINT_USER)) {\n\t\t\tstruct regulatory_request *ureq;\n\n\t\t\tspin_lock(&reg_requests_lock);\n\t\t\tureq = list_last_entry(&reg_requests_list,\n\t\t\t\t\t       struct regulatory_request,\n\t\t\t\t\t       list);\n\t\t\tlist_del(&ureq->list);\n\t\t\tspin_unlock(&reg_requests_lock);\n\n\t\t\tnotify_self_managed_wiphys(ureq);\n\t\t\treg_update_last_request(ureq);\n\t\t\tset_regdom(reg_copy_regd(cfg80211_user_regdom),\n\t\t\t\t   REGD_SOURCE_CACHED);\n\t\t}\n\t} else {\n\t\tregulatory_hint_core(world_alpha2);\n\n\t\t \n\t\tif (is_an_alpha2(alpha2))\n\t\t\tregulatory_hint_user(alpha2, NL80211_USER_REG_HINT_USER);\n\t}\n\n\tspin_lock(&reg_requests_lock);\n\tlist_splice_tail_init(&tmp_reg_req_list, &reg_requests_list);\n\tspin_unlock(&reg_requests_lock);\n\n\tpr_debug(\"Kicking the queue\\n\");\n\n\tschedule_work(&reg_work);\n}\n\nstatic bool is_wiphy_all_set_reg_flag(enum ieee80211_regulatory_flags flag)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\twdev_lock(wdev);\n\t\t\tif (!(wdev->wiphy->regulatory_flags & flag)) {\n\t\t\t\twdev_unlock(wdev);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\twdev_unlock(wdev);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid regulatory_hint_disconnect(void)\n{\n\t \n\tif (is_wiphy_all_set_reg_flag(REGULATORY_COUNTRY_IE_IGNORE)) {\n\t\tstruct reg_beacon *reg_beacon, *btmp;\n\n\t\tif (is_wiphy_all_set_reg_flag(REGULATORY_DISABLE_BEACON_HINTS))\n\t\t\treturn;\n\n\t\tspin_lock_bh(&reg_pending_beacons_lock);\n\t\tlist_for_each_entry_safe(reg_beacon, btmp,\n\t\t\t\t\t &reg_pending_beacons, list) {\n\t\t\tlist_del(&reg_beacon->list);\n\t\t\tkfree(reg_beacon);\n\t\t}\n\t\tspin_unlock_bh(&reg_pending_beacons_lock);\n\n\t\tlist_for_each_entry_safe(reg_beacon, btmp,\n\t\t\t\t\t &reg_beacon_list, list) {\n\t\t\tlist_del(&reg_beacon->list);\n\t\t\tkfree(reg_beacon);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tpr_debug(\"All devices are disconnected, going to restore regulatory settings\\n\");\n\trestore_regulatory_settings(false, true);\n}\n\nstatic bool freq_is_chan_12_13_14(u32 freq)\n{\n\tif (freq == ieee80211_channel_to_frequency(12, NL80211_BAND_2GHZ) ||\n\t    freq == ieee80211_channel_to_frequency(13, NL80211_BAND_2GHZ) ||\n\t    freq == ieee80211_channel_to_frequency(14, NL80211_BAND_2GHZ))\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool pending_reg_beacon(struct ieee80211_channel *beacon_chan)\n{\n\tstruct reg_beacon *pending_beacon;\n\n\tlist_for_each_entry(pending_beacon, &reg_pending_beacons, list)\n\t\tif (ieee80211_channel_equal(beacon_chan,\n\t\t\t\t\t    &pending_beacon->chan))\n\t\t\treturn true;\n\treturn false;\n}\n\nint regulatory_hint_found_beacon(struct wiphy *wiphy,\n\t\t\t\t struct ieee80211_channel *beacon_chan,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct reg_beacon *reg_beacon;\n\tbool processing;\n\n\tif (beacon_chan->beacon_found ||\n\t    beacon_chan->flags & IEEE80211_CHAN_RADAR ||\n\t    (beacon_chan->band == NL80211_BAND_2GHZ &&\n\t     !freq_is_chan_12_13_14(beacon_chan->center_freq)))\n\t\treturn 0;\n\n\tspin_lock_bh(&reg_pending_beacons_lock);\n\tprocessing = pending_reg_beacon(beacon_chan);\n\tspin_unlock_bh(&reg_pending_beacons_lock);\n\n\tif (processing)\n\t\treturn 0;\n\n\treg_beacon = kzalloc(sizeof(struct reg_beacon), gfp);\n\tif (!reg_beacon)\n\t\treturn -ENOMEM;\n\n\tpr_debug(\"Found new beacon on frequency: %d.%03d MHz (Ch %d) on %s\\n\",\n\t\t beacon_chan->center_freq, beacon_chan->freq_offset,\n\t\t ieee80211_freq_khz_to_channel(\n\t\t\t ieee80211_channel_to_khz(beacon_chan)),\n\t\t wiphy_name(wiphy));\n\n\tmemcpy(&reg_beacon->chan, beacon_chan,\n\t       sizeof(struct ieee80211_channel));\n\n\t \n\tspin_lock_bh(&reg_pending_beacons_lock);\n\tlist_add_tail(&reg_beacon->list, &reg_pending_beacons);\n\tspin_unlock_bh(&reg_pending_beacons_lock);\n\n\tschedule_work(&reg_work);\n\n\treturn 0;\n}\n\nstatic void print_rd_rules(const struct ieee80211_regdomain *rd)\n{\n\tunsigned int i;\n\tconst struct ieee80211_reg_rule *reg_rule = NULL;\n\tconst struct ieee80211_freq_range *freq_range = NULL;\n\tconst struct ieee80211_power_rule *power_rule = NULL;\n\tchar bw[32], cac_time[32];\n\n\tpr_debug(\"  (start_freq - end_freq @ bandwidth), (max_antenna_gain, max_eirp), (dfs_cac_time)\\n\");\n\n\tfor (i = 0; i < rd->n_reg_rules; i++) {\n\t\treg_rule = &rd->reg_rules[i];\n\t\tfreq_range = &reg_rule->freq_range;\n\t\tpower_rule = &reg_rule->power_rule;\n\n\t\tif (reg_rule->flags & NL80211_RRF_AUTO_BW)\n\t\t\tsnprintf(bw, sizeof(bw), \"%d KHz, %u KHz AUTO\",\n\t\t\t\t freq_range->max_bandwidth_khz,\n\t\t\t\t reg_get_max_bandwidth(rd, reg_rule));\n\t\telse\n\t\t\tsnprintf(bw, sizeof(bw), \"%d KHz\",\n\t\t\t\t freq_range->max_bandwidth_khz);\n\n\t\tif (reg_rule->flags & NL80211_RRF_DFS)\n\t\t\tscnprintf(cac_time, sizeof(cac_time), \"%u s\",\n\t\t\t\t  reg_rule->dfs_cac_ms/1000);\n\t\telse\n\t\t\tscnprintf(cac_time, sizeof(cac_time), \"N/A\");\n\n\n\t\t \n\t\tif (power_rule->max_antenna_gain)\n\t\t\tpr_debug(\"  (%d KHz - %d KHz @ %s), (%d mBi, %d mBm), (%s)\\n\",\n\t\t\t\tfreq_range->start_freq_khz,\n\t\t\t\tfreq_range->end_freq_khz,\n\t\t\t\tbw,\n\t\t\t\tpower_rule->max_antenna_gain,\n\t\t\t\tpower_rule->max_eirp,\n\t\t\t\tcac_time);\n\t\telse\n\t\t\tpr_debug(\"  (%d KHz - %d KHz @ %s), (N/A, %d mBm), (%s)\\n\",\n\t\t\t\tfreq_range->start_freq_khz,\n\t\t\t\tfreq_range->end_freq_khz,\n\t\t\t\tbw,\n\t\t\t\tpower_rule->max_eirp,\n\t\t\t\tcac_time);\n\t}\n}\n\nbool reg_supported_dfs_region(enum nl80211_dfs_regions dfs_region)\n{\n\tswitch (dfs_region) {\n\tcase NL80211_DFS_UNSET:\n\tcase NL80211_DFS_FCC:\n\tcase NL80211_DFS_ETSI:\n\tcase NL80211_DFS_JP:\n\t\treturn true;\n\tdefault:\n\t\tpr_debug(\"Ignoring unknown DFS master region: %d\\n\", dfs_region);\n\t\treturn false;\n\t}\n}\n\nstatic void print_regdomain(const struct ieee80211_regdomain *rd)\n{\n\tstruct regulatory_request *lr = get_last_request();\n\n\tif (is_intersected_alpha2(rd->alpha2)) {\n\t\tif (lr->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {\n\t\t\tstruct cfg80211_registered_device *rdev;\n\t\t\trdev = cfg80211_rdev_by_wiphy_idx(lr->wiphy_idx);\n\t\t\tif (rdev) {\n\t\t\t\tpr_debug(\"Current regulatory domain updated by AP to: %c%c\\n\",\n\t\t\t\t\trdev->country_ie_alpha2[0],\n\t\t\t\t\trdev->country_ie_alpha2[1]);\n\t\t\t} else\n\t\t\t\tpr_debug(\"Current regulatory domain intersected:\\n\");\n\t\t} else\n\t\t\tpr_debug(\"Current regulatory domain intersected:\\n\");\n\t} else if (is_world_regdom(rd->alpha2)) {\n\t\tpr_debug(\"World regulatory domain updated:\\n\");\n\t} else {\n\t\tif (is_unknown_alpha2(rd->alpha2))\n\t\t\tpr_debug(\"Regulatory domain changed to driver built-in settings (unknown country)\\n\");\n\t\telse {\n\t\t\tif (reg_request_cell_base(lr))\n\t\t\t\tpr_debug(\"Regulatory domain changed to country: %c%c by Cell Station\\n\",\n\t\t\t\t\trd->alpha2[0], rd->alpha2[1]);\n\t\t\telse\n\t\t\t\tpr_debug(\"Regulatory domain changed to country: %c%c\\n\",\n\t\t\t\t\trd->alpha2[0], rd->alpha2[1]);\n\t\t}\n\t}\n\n\tpr_debug(\" DFS Master region: %s\", reg_dfs_region_str(rd->dfs_region));\n\tprint_rd_rules(rd);\n}\n\nstatic void print_regdomain_info(const struct ieee80211_regdomain *rd)\n{\n\tpr_debug(\"Regulatory domain: %c%c\\n\", rd->alpha2[0], rd->alpha2[1]);\n\tprint_rd_rules(rd);\n}\n\nstatic int reg_set_rd_core(const struct ieee80211_regdomain *rd)\n{\n\tif (!is_world_regdom(rd->alpha2))\n\t\treturn -EINVAL;\n\tupdate_world_regdomain(rd);\n\treturn 0;\n}\n\nstatic int reg_set_rd_user(const struct ieee80211_regdomain *rd,\n\t\t\t   struct regulatory_request *user_request)\n{\n\tconst struct ieee80211_regdomain *intersected_rd = NULL;\n\n\tif (!regdom_changes(rd->alpha2))\n\t\treturn -EALREADY;\n\n\tif (!is_valid_rd(rd)) {\n\t\tpr_err(\"Invalid regulatory domain detected: %c%c\\n\",\n\t\t       rd->alpha2[0], rd->alpha2[1]);\n\t\tprint_regdomain_info(rd);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!user_request->intersect) {\n\t\treset_regdomains(false, rd);\n\t\treturn 0;\n\t}\n\n\tintersected_rd = regdom_intersect(rd, get_cfg80211_regdom());\n\tif (!intersected_rd)\n\t\treturn -EINVAL;\n\n\tkfree(rd);\n\trd = NULL;\n\treset_regdomains(false, intersected_rd);\n\n\treturn 0;\n}\n\nstatic int reg_set_rd_driver(const struct ieee80211_regdomain *rd,\n\t\t\t     struct regulatory_request *driver_request)\n{\n\tconst struct ieee80211_regdomain *regd;\n\tconst struct ieee80211_regdomain *intersected_rd = NULL;\n\tconst struct ieee80211_regdomain *tmp;\n\tstruct wiphy *request_wiphy;\n\n\tif (is_world_regdom(rd->alpha2))\n\t\treturn -EINVAL;\n\n\tif (!regdom_changes(rd->alpha2))\n\t\treturn -EALREADY;\n\n\tif (!is_valid_rd(rd)) {\n\t\tpr_err(\"Invalid regulatory domain detected: %c%c\\n\",\n\t\t       rd->alpha2[0], rd->alpha2[1]);\n\t\tprint_regdomain_info(rd);\n\t\treturn -EINVAL;\n\t}\n\n\trequest_wiphy = wiphy_idx_to_wiphy(driver_request->wiphy_idx);\n\tif (!request_wiphy)\n\t\treturn -ENODEV;\n\n\tif (!driver_request->intersect) {\n\t\tASSERT_RTNL();\n\t\twiphy_lock(request_wiphy);\n\t\tif (request_wiphy->regd) {\n\t\t\twiphy_unlock(request_wiphy);\n\t\t\treturn -EALREADY;\n\t\t}\n\n\t\tregd = reg_copy_regd(rd);\n\t\tif (IS_ERR(regd)) {\n\t\t\twiphy_unlock(request_wiphy);\n\t\t\treturn PTR_ERR(regd);\n\t\t}\n\n\t\trcu_assign_pointer(request_wiphy->regd, regd);\n\t\twiphy_unlock(request_wiphy);\n\t\treset_regdomains(false, rd);\n\t\treturn 0;\n\t}\n\n\tintersected_rd = regdom_intersect(rd, get_cfg80211_regdom());\n\tif (!intersected_rd)\n\t\treturn -EINVAL;\n\n\t \n\ttmp = get_wiphy_regdom(request_wiphy);\n\trcu_assign_pointer(request_wiphy->regd, rd);\n\trcu_free_regdom(tmp);\n\n\trd = NULL;\n\n\treset_regdomains(false, intersected_rd);\n\n\treturn 0;\n}\n\nstatic int reg_set_rd_country_ie(const struct ieee80211_regdomain *rd,\n\t\t\t\t struct regulatory_request *country_ie_request)\n{\n\tstruct wiphy *request_wiphy;\n\n\tif (!is_alpha2_set(rd->alpha2) && !is_an_alpha2(rd->alpha2) &&\n\t    !is_unknown_alpha2(rd->alpha2))\n\t\treturn -EINVAL;\n\n\t \n\n\tif (!is_valid_rd(rd)) {\n\t\tpr_err(\"Invalid regulatory domain detected: %c%c\\n\",\n\t\t       rd->alpha2[0], rd->alpha2[1]);\n\t\tprint_regdomain_info(rd);\n\t\treturn -EINVAL;\n\t}\n\n\trequest_wiphy = wiphy_idx_to_wiphy(country_ie_request->wiphy_idx);\n\tif (!request_wiphy)\n\t\treturn -ENODEV;\n\n\tif (country_ie_request->intersect)\n\t\treturn -EINVAL;\n\n\treset_regdomains(false, rd);\n\treturn 0;\n}\n\n \nint set_regdom(const struct ieee80211_regdomain *rd,\n\t       enum ieee80211_regd_source regd_src)\n{\n\tstruct regulatory_request *lr;\n\tbool user_reset = false;\n\tint r;\n\n\tif (IS_ERR_OR_NULL(rd))\n\t\treturn -ENODATA;\n\n\tif (!reg_is_valid_request(rd->alpha2)) {\n\t\tkfree(rd);\n\t\treturn -EINVAL;\n\t}\n\n\tif (regd_src == REGD_SOURCE_CRDA)\n\t\treset_crda_timeouts();\n\n\tlr = get_last_request();\n\n\t \n\tswitch (lr->initiator) {\n\tcase NL80211_REGDOM_SET_BY_CORE:\n\t\tr = reg_set_rd_core(rd);\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_USER:\n\t\tcfg80211_save_user_regdom(rd);\n\t\tr = reg_set_rd_user(rd, lr);\n\t\tuser_reset = true;\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_DRIVER:\n\t\tr = reg_set_rd_driver(rd, lr);\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_COUNTRY_IE:\n\t\tr = reg_set_rd_country_ie(rd, lr);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"invalid initiator %d\\n\", lr->initiator);\n\t\tkfree(rd);\n\t\treturn -EINVAL;\n\t}\n\n\tif (r) {\n\t\tswitch (r) {\n\t\tcase -EALREADY:\n\t\t\treg_set_request_processed();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\trestore_regulatory_settings(user_reset, false);\n\t\t}\n\n\t\tkfree(rd);\n\t\treturn r;\n\t}\n\n\t \n\tif (WARN_ON(!lr->intersect && rd != get_cfg80211_regdom()))\n\t\treturn -EINVAL;\n\n\t \n\tupdate_all_wiphy_regulatory(lr->initiator);\n\n\tprint_regdomain(get_cfg80211_regdom());\n\n\tnl80211_send_reg_change_event(lr);\n\n\treg_set_request_processed();\n\n\treturn 0;\n}\n\nstatic int __regulatory_set_wiphy_regd(struct wiphy *wiphy,\n\t\t\t\t       struct ieee80211_regdomain *rd)\n{\n\tconst struct ieee80211_regdomain *regd;\n\tconst struct ieee80211_regdomain *prev_regd;\n\tstruct cfg80211_registered_device *rdev;\n\n\tif (WARN_ON(!wiphy || !rd))\n\t\treturn -EINVAL;\n\n\tif (WARN(!(wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED),\n\t\t \"wiphy should have REGULATORY_WIPHY_SELF_MANAGED\\n\"))\n\t\treturn -EPERM;\n\n\tif (WARN(!is_valid_rd(rd),\n\t\t \"Invalid regulatory domain detected: %c%c\\n\",\n\t\t rd->alpha2[0], rd->alpha2[1])) {\n\t\tprint_regdomain_info(rd);\n\t\treturn -EINVAL;\n\t}\n\n\tregd = reg_copy_regd(rd);\n\tif (IS_ERR(regd))\n\t\treturn PTR_ERR(regd);\n\n\trdev = wiphy_to_rdev(wiphy);\n\n\tspin_lock(&reg_requests_lock);\n\tprev_regd = rdev->requested_regd;\n\trdev->requested_regd = regd;\n\tspin_unlock(&reg_requests_lock);\n\n\tkfree(prev_regd);\n\treturn 0;\n}\n\nint regulatory_set_wiphy_regd(struct wiphy *wiphy,\n\t\t\t      struct ieee80211_regdomain *rd)\n{\n\tint ret = __regulatory_set_wiphy_regd(wiphy, rd);\n\n\tif (ret)\n\t\treturn ret;\n\n\tschedule_work(&reg_work);\n\treturn 0;\n}\nEXPORT_SYMBOL(regulatory_set_wiphy_regd);\n\nint regulatory_set_wiphy_regd_sync(struct wiphy *wiphy,\n\t\t\t\t   struct ieee80211_regdomain *rd)\n{\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tret = __regulatory_set_wiphy_regd(wiphy, rd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treg_process_self_managed_hint(wiphy);\n\treg_check_channels();\n\treturn 0;\n}\nEXPORT_SYMBOL(regulatory_set_wiphy_regd_sync);\n\nvoid wiphy_regulatory_register(struct wiphy *wiphy)\n{\n\tstruct regulatory_request *lr = get_last_request();\n\n\t \n\tif (wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED) {\n\t\twiphy->regulatory_flags |= REGULATORY_DISABLE_BEACON_HINTS |\n\t\t\t\t\t   REGULATORY_COUNTRY_IE_IGNORE;\n\n\t\t \n\t\tif (lr->initiator == NL80211_REGDOM_SET_BY_USER)\n\t\t\treg_call_notifier(wiphy, lr);\n\t}\n\n\tif (!reg_dev_ignore_cell_hint(wiphy))\n\t\treg_num_devs_support_basehint++;\n\n\twiphy_update_regulatory(wiphy, lr->initiator);\n\twiphy_all_share_dfs_chan_state(wiphy);\n\treg_process_self_managed_hints();\n}\n\nvoid wiphy_regulatory_deregister(struct wiphy *wiphy)\n{\n\tstruct wiphy *request_wiphy = NULL;\n\tstruct regulatory_request *lr;\n\n\tlr = get_last_request();\n\n\tif (!reg_dev_ignore_cell_hint(wiphy))\n\t\treg_num_devs_support_basehint--;\n\n\trcu_free_regdom(get_wiphy_regdom(wiphy));\n\tRCU_INIT_POINTER(wiphy->regd, NULL);\n\n\tif (lr)\n\t\trequest_wiphy = wiphy_idx_to_wiphy(lr->wiphy_idx);\n\n\tif (!request_wiphy || request_wiphy != wiphy)\n\t\treturn;\n\n\tlr->wiphy_idx = WIPHY_IDX_INVALID;\n\tlr->country_ie_env = ENVIRON_ANY;\n}\n\n \nint cfg80211_get_unii(int freq)\n{\n\t \n\tif (freq >= 5150 && freq <= 5250)\n\t\treturn 0;\n\n\t \n\tif (freq > 5250 && freq <= 5350)\n\t\treturn 1;\n\n\t \n\tif (freq > 5350 && freq <= 5470)\n\t\treturn 2;\n\n\t \n\tif (freq > 5470 && freq <= 5725)\n\t\treturn 3;\n\n\t \n\tif (freq > 5725 && freq <= 5825)\n\t\treturn 4;\n\n\t \n\tif (freq > 5925 && freq <= 6425)\n\t\treturn 5;\n\n\t \n\tif (freq > 6425 && freq <= 6525)\n\t\treturn 6;\n\n\t \n\tif (freq > 6525 && freq <= 6875)\n\t\treturn 7;\n\n\t \n\tif (freq > 6875 && freq <= 7125)\n\t\treturn 8;\n\n\treturn -EINVAL;\n}\n\nbool regulatory_indoor_allowed(void)\n{\n\treturn reg_is_indoor;\n}\n\nbool regulatory_pre_cac_allowed(struct wiphy *wiphy)\n{\n\tconst struct ieee80211_regdomain *regd = NULL;\n\tconst struct ieee80211_regdomain *wiphy_regd = NULL;\n\tbool pre_cac_allowed = false;\n\n\trcu_read_lock();\n\n\tregd = rcu_dereference(cfg80211_regdomain);\n\twiphy_regd = rcu_dereference(wiphy->regd);\n\tif (!wiphy_regd) {\n\t\tif (regd->dfs_region == NL80211_DFS_ETSI)\n\t\t\tpre_cac_allowed = true;\n\n\t\trcu_read_unlock();\n\n\t\treturn pre_cac_allowed;\n\t}\n\n\tif (regd->dfs_region == wiphy_regd->dfs_region &&\n\t    wiphy_regd->dfs_region == NL80211_DFS_ETSI)\n\t\tpre_cac_allowed = true;\n\n\trcu_read_unlock();\n\n\treturn pre_cac_allowed;\n}\nEXPORT_SYMBOL(regulatory_pre_cac_allowed);\n\nstatic void cfg80211_check_and_end_cac(struct cfg80211_registered_device *rdev)\n{\n\tstruct wireless_dev *wdev;\n\t \n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\tstruct cfg80211_chan_def *chandef;\n\n\t\tif (!wdev->cac_started)\n\t\t\tcontinue;\n\n\t\t \n\t\tchandef = wdev_chandef(wdev, 0);\n\t\tif (!chandef)\n\t\t\tcontinue;\n\n\t\tif (!cfg80211_chandef_dfs_usable(&rdev->wiphy, chandef))\n\t\t\trdev_end_cac(rdev, wdev->netdev);\n\t}\n}\n\nvoid regulatory_propagate_dfs_state(struct wiphy *wiphy,\n\t\t\t\t    struct cfg80211_chan_def *chandef,\n\t\t\t\t    enum nl80211_dfs_state dfs_state,\n\t\t\t\t    enum nl80211_radar_event event)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\tASSERT_RTNL();\n\n\tif (WARN_ON(!cfg80211_chandef_valid(chandef)))\n\t\treturn;\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (wiphy == &rdev->wiphy)\n\t\t\tcontinue;\n\n\t\tif (!reg_dfs_domain_same(wiphy, &rdev->wiphy))\n\t\t\tcontinue;\n\n\t\tif (!ieee80211_get_channel(&rdev->wiphy,\n\t\t\t\t\t   chandef->chan->center_freq))\n\t\t\tcontinue;\n\n\t\tcfg80211_set_dfs_state(&rdev->wiphy, chandef, dfs_state);\n\n\t\tif (event == NL80211_RADAR_DETECTED ||\n\t\t    event == NL80211_RADAR_CAC_FINISHED) {\n\t\t\tcfg80211_sched_dfs_chan_update(rdev);\n\t\t\tcfg80211_check_and_end_cac(rdev);\n\t\t}\n\n\t\tnl80211_radar_notify(rdev, chandef, event, NULL, GFP_KERNEL);\n\t}\n}\n\nstatic int __init regulatory_init_db(void)\n{\n\tint err;\n\n\t \n\tif (IS_ERR_OR_NULL(reg_pdev))\n\t\treturn -EINVAL;\n\n\terr = load_builtin_regdb_keys();\n\tif (err) {\n\t\tplatform_device_unregister(reg_pdev);\n\t\treturn err;\n\t}\n\n\t \n\terr = regulatory_hint_core(cfg80211_world_regdom->alpha2);\n\tif (err) {\n\t\tif (err == -ENOMEM) {\n\t\t\tplatform_device_unregister(reg_pdev);\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\tpr_err(\"kobject_uevent_env() was unable to call CRDA during init\\n\");\n\t}\n\n\t \n\tif (!is_world_regdom(ieee80211_regdom))\n\t\tregulatory_hint_user(ieee80211_regdom,\n\t\t\t\t     NL80211_USER_REG_HINT_USER);\n\n\treturn 0;\n}\n#ifndef MODULE\nlate_initcall(regulatory_init_db);\n#endif\n\nint __init regulatory_init(void)\n{\n\treg_pdev = platform_device_register_simple(\"regulatory\", 0, NULL, 0);\n\tif (IS_ERR(reg_pdev))\n\t\treturn PTR_ERR(reg_pdev);\n\n\trcu_assign_pointer(cfg80211_regdomain, cfg80211_world_regdom);\n\n\tuser_alpha2[0] = '9';\n\tuser_alpha2[1] = '7';\n\n#ifdef MODULE\n\treturn regulatory_init_db();\n#else\n\treturn 0;\n#endif\n}\n\nvoid regulatory_exit(void)\n{\n\tstruct regulatory_request *reg_request, *tmp;\n\tstruct reg_beacon *reg_beacon, *btmp;\n\n\tcancel_work_sync(&reg_work);\n\tcancel_crda_timeout_sync();\n\tcancel_delayed_work_sync(&reg_check_chans);\n\n\t \n\trtnl_lock();\n\treset_regdomains(true, NULL);\n\trtnl_unlock();\n\n\tdev_set_uevent_suppress(&reg_pdev->dev, true);\n\n\tplatform_device_unregister(reg_pdev);\n\n\tlist_for_each_entry_safe(reg_beacon, btmp, &reg_pending_beacons, list) {\n\t\tlist_del(&reg_beacon->list);\n\t\tkfree(reg_beacon);\n\t}\n\n\tlist_for_each_entry_safe(reg_beacon, btmp, &reg_beacon_list, list) {\n\t\tlist_del(&reg_beacon->list);\n\t\tkfree(reg_beacon);\n\t}\n\n\tlist_for_each_entry_safe(reg_request, tmp, &reg_requests_list, list) {\n\t\tlist_del(&reg_request->list);\n\t\tkfree(reg_request);\n\t}\n\n\tif (!IS_ERR_OR_NULL(regdb))\n\t\tkfree(regdb);\n\tif (!IS_ERR_OR_NULL(cfg80211_user_regdom))\n\t\tkfree(cfg80211_user_regdom);\n\n\tfree_regdb_keyring();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}