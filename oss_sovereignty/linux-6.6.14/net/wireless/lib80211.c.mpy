{
  "module_name": "lib80211.c",
  "hash_id": "2a9ff715ce633eeda85be3dc9f843c2981f14ffbd8460dcc7838a79555ab4a26",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/lib80211.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/ieee80211.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <net/lib80211.h>\n\n#define DRV_DESCRIPTION\t\"common routines for IEEE802.11 drivers\"\n\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_AUTHOR(\"John W. Linville <linville@tuxdriver.com>\");\nMODULE_LICENSE(\"GPL\");\n\nstruct lib80211_crypto_alg {\n\tstruct list_head list;\n\tstruct lib80211_crypto_ops *ops;\n};\n\nstatic LIST_HEAD(lib80211_crypto_algs);\nstatic DEFINE_SPINLOCK(lib80211_crypto_lock);\n\nstatic void lib80211_crypt_deinit_entries(struct lib80211_crypt_info *info,\n\t\t\t\t\t  int force);\nstatic void lib80211_crypt_quiescing(struct lib80211_crypt_info *info);\nstatic void lib80211_crypt_deinit_handler(struct timer_list *t);\n\nint lib80211_crypt_info_init(struct lib80211_crypt_info *info, char *name,\n\t\t\t\tspinlock_t *lock)\n{\n\tmemset(info, 0, sizeof(*info));\n\n\tinfo->name = name;\n\tinfo->lock = lock;\n\n\tINIT_LIST_HEAD(&info->crypt_deinit_list);\n\ttimer_setup(&info->crypt_deinit_timer, lib80211_crypt_deinit_handler,\n\t\t    0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(lib80211_crypt_info_init);\n\nvoid lib80211_crypt_info_free(struct lib80211_crypt_info *info)\n{\n\tint i;\n\n        lib80211_crypt_quiescing(info);\n        del_timer_sync(&info->crypt_deinit_timer);\n        lib80211_crypt_deinit_entries(info, 1);\n\n        for (i = 0; i < NUM_WEP_KEYS; i++) {\n                struct lib80211_crypt_data *crypt = info->crypt[i];\n                if (crypt) {\n                        if (crypt->ops) {\n                                crypt->ops->deinit(crypt->priv);\n                                module_put(crypt->ops->owner);\n                        }\n                        kfree(crypt);\n                        info->crypt[i] = NULL;\n                }\n        }\n}\nEXPORT_SYMBOL(lib80211_crypt_info_free);\n\nstatic void lib80211_crypt_deinit_entries(struct lib80211_crypt_info *info,\n\t\t\t\t\t  int force)\n{\n\tstruct lib80211_crypt_data *entry, *next;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(info->lock, flags);\n\tlist_for_each_entry_safe(entry, next, &info->crypt_deinit_list, list) {\n\t\tif (atomic_read(&entry->refcnt) != 0 && !force)\n\t\t\tcontinue;\n\n\t\tlist_del(&entry->list);\n\n\t\tif (entry->ops) {\n\t\t\tentry->ops->deinit(entry->priv);\n\t\t\tmodule_put(entry->ops->owner);\n\t\t}\n\t\tkfree(entry);\n\t}\n\tspin_unlock_irqrestore(info->lock, flags);\n}\n\n \nstatic void lib80211_crypt_quiescing(struct lib80211_crypt_info *info)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(info->lock, flags);\n\tinfo->crypt_quiesced = 1;\n\tspin_unlock_irqrestore(info->lock, flags);\n}\n\nstatic void lib80211_crypt_deinit_handler(struct timer_list *t)\n{\n\tstruct lib80211_crypt_info *info = from_timer(info, t,\n\t\t\t\t\t\t      crypt_deinit_timer);\n\tunsigned long flags;\n\n\tlib80211_crypt_deinit_entries(info, 0);\n\n\tspin_lock_irqsave(info->lock, flags);\n\tif (!list_empty(&info->crypt_deinit_list) && !info->crypt_quiesced) {\n\t\tprintk(KERN_DEBUG \"%s: entries remaining in delayed crypt \"\n\t\t       \"deletion list\\n\", info->name);\n\t\tinfo->crypt_deinit_timer.expires = jiffies + HZ;\n\t\tadd_timer(&info->crypt_deinit_timer);\n\t}\n\tspin_unlock_irqrestore(info->lock, flags);\n}\n\nvoid lib80211_crypt_delayed_deinit(struct lib80211_crypt_info *info,\n\t\t\t\t    struct lib80211_crypt_data **crypt)\n{\n\tstruct lib80211_crypt_data *tmp;\n\tunsigned long flags;\n\n\tif (*crypt == NULL)\n\t\treturn;\n\n\ttmp = *crypt;\n\t*crypt = NULL;\n\n\t \n\n\tspin_lock_irqsave(info->lock, flags);\n\tif (!info->crypt_quiesced) {\n\t\tlist_add(&tmp->list, &info->crypt_deinit_list);\n\t\tif (!timer_pending(&info->crypt_deinit_timer)) {\n\t\t\tinfo->crypt_deinit_timer.expires = jiffies + HZ;\n\t\t\tadd_timer(&info->crypt_deinit_timer);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(info->lock, flags);\n}\nEXPORT_SYMBOL(lib80211_crypt_delayed_deinit);\n\nint lib80211_register_crypto_ops(struct lib80211_crypto_ops *ops)\n{\n\tunsigned long flags;\n\tstruct lib80211_crypto_alg *alg;\n\n\talg = kzalloc(sizeof(*alg), GFP_KERNEL);\n\tif (alg == NULL)\n\t\treturn -ENOMEM;\n\n\talg->ops = ops;\n\n\tspin_lock_irqsave(&lib80211_crypto_lock, flags);\n\tlist_add(&alg->list, &lib80211_crypto_algs);\n\tspin_unlock_irqrestore(&lib80211_crypto_lock, flags);\n\n\tprintk(KERN_DEBUG \"lib80211_crypt: registered algorithm '%s'\\n\",\n\t       ops->name);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(lib80211_register_crypto_ops);\n\nint lib80211_unregister_crypto_ops(struct lib80211_crypto_ops *ops)\n{\n\tstruct lib80211_crypto_alg *alg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lib80211_crypto_lock, flags);\n\tlist_for_each_entry(alg, &lib80211_crypto_algs, list) {\n\t\tif (alg->ops == ops)\n\t\t\tgoto found;\n\t}\n\tspin_unlock_irqrestore(&lib80211_crypto_lock, flags);\n\treturn -EINVAL;\n\n      found:\n\tprintk(KERN_DEBUG \"lib80211_crypt: unregistered algorithm '%s'\\n\",\n\t       ops->name);\n\tlist_del(&alg->list);\n\tspin_unlock_irqrestore(&lib80211_crypto_lock, flags);\n\tkfree(alg);\n\treturn 0;\n}\nEXPORT_SYMBOL(lib80211_unregister_crypto_ops);\n\nstruct lib80211_crypto_ops *lib80211_get_crypto_ops(const char *name)\n{\n\tstruct lib80211_crypto_alg *alg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lib80211_crypto_lock, flags);\n\tlist_for_each_entry(alg, &lib80211_crypto_algs, list) {\n\t\tif (strcmp(alg->ops->name, name) == 0)\n\t\t\tgoto found;\n\t}\n\tspin_unlock_irqrestore(&lib80211_crypto_lock, flags);\n\treturn NULL;\n\n      found:\n\tspin_unlock_irqrestore(&lib80211_crypto_lock, flags);\n\treturn alg->ops;\n}\nEXPORT_SYMBOL(lib80211_get_crypto_ops);\n\nstatic void *lib80211_crypt_null_init(int keyidx)\n{\n\treturn (void *)1;\n}\n\nstatic void lib80211_crypt_null_deinit(void *priv)\n{\n}\n\nstatic struct lib80211_crypto_ops lib80211_crypt_null = {\n\t.name = \"NULL\",\n\t.init = lib80211_crypt_null_init,\n\t.deinit = lib80211_crypt_null_deinit,\n\t.owner = THIS_MODULE,\n};\n\nstatic int __init lib80211_init(void)\n{\n\tpr_info(DRV_DESCRIPTION \"\\n\");\n\treturn lib80211_register_crypto_ops(&lib80211_crypt_null);\n}\n\nstatic void __exit lib80211_exit(void)\n{\n\tlib80211_unregister_crypto_ops(&lib80211_crypt_null);\n\tBUG_ON(!list_empty(&lib80211_crypto_algs));\n}\n\nmodule_init(lib80211_init);\nmodule_exit(lib80211_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}