{
  "module_name": "sme.c",
  "hash_id": "d3f47279800fae8cf3e9d30477e1b607604dee3a45b0d42cfe582f535ba26145",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/sme.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/wireless.h>\n#include <linux/export.h>\n#include <net/iw_handler.h>\n#include <net/cfg80211.h>\n#include <net/rtnetlink.h>\n#include \"nl80211.h\"\n#include \"reg.h\"\n#include \"rdev-ops.h\"\n\n \n\nstruct cfg80211_conn {\n\tstruct cfg80211_connect_params params;\n\t \n\tenum {\n\t\tCFG80211_CONN_SCANNING,\n\t\tCFG80211_CONN_SCAN_AGAIN,\n\t\tCFG80211_CONN_AUTHENTICATE_NEXT,\n\t\tCFG80211_CONN_AUTHENTICATING,\n\t\tCFG80211_CONN_AUTH_FAILED_TIMEOUT,\n\t\tCFG80211_CONN_ASSOCIATE_NEXT,\n\t\tCFG80211_CONN_ASSOCIATING,\n\t\tCFG80211_CONN_ASSOC_FAILED,\n\t\tCFG80211_CONN_ASSOC_FAILED_TIMEOUT,\n\t\tCFG80211_CONN_DEAUTH,\n\t\tCFG80211_CONN_ABANDON,\n\t\tCFG80211_CONN_CONNECTED,\n\t} state;\n\tu8 bssid[ETH_ALEN], prev_bssid[ETH_ALEN];\n\tconst u8 *ie;\n\tsize_t ie_len;\n\tbool auto_auth, prev_bssid_valid;\n};\n\nstatic void cfg80211_sme_free(struct wireless_dev *wdev)\n{\n\tif (!wdev->conn)\n\t\treturn;\n\n\tkfree(wdev->conn->ie);\n\tkfree(wdev->conn);\n\twdev->conn = NULL;\n}\n\nstatic int cfg80211_conn_scan(struct wireless_dev *wdev)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_scan_request *request;\n\tint n_channels, err;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (rdev->scan_req || rdev->scan_msg)\n\t\treturn -EBUSY;\n\n\tif (wdev->conn->params.channel)\n\t\tn_channels = 1;\n\telse\n\t\tn_channels = ieee80211_get_num_supported_channels(wdev->wiphy);\n\n\trequest = kzalloc(sizeof(*request) + sizeof(request->ssids[0]) +\n\t\t\t  sizeof(request->channels[0]) * n_channels,\n\t\t\t  GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (wdev->conn->params.channel) {\n\t\tenum nl80211_band band = wdev->conn->params.channel->band;\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\twdev->wiphy->bands[band];\n\n\t\tif (!sband) {\n\t\t\tkfree(request);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trequest->channels[0] = wdev->conn->params.channel;\n\t\trequest->rates[band] = (1 << sband->n_bitrates) - 1;\n\t} else {\n\t\tint i = 0, j;\n\t\tenum nl80211_band band;\n\t\tstruct ieee80211_supported_band *bands;\n\t\tstruct ieee80211_channel *channel;\n\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tbands = wdev->wiphy->bands[band];\n\t\t\tif (!bands)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < bands->n_channels; j++) {\n\t\t\t\tchannel = &bands->channels[j];\n\t\t\t\tif (channel->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\t\t\t\trequest->channels[i++] = channel;\n\t\t\t}\n\t\t\trequest->rates[band] = (1 << bands->n_bitrates) - 1;\n\t\t}\n\t\tn_channels = i;\n\t}\n\trequest->n_channels = n_channels;\n\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = 1;\n\n\tmemcpy(request->ssids[0].ssid, wdev->conn->params.ssid,\n\t\twdev->conn->params.ssid_len);\n\trequest->ssids[0].ssid_len = wdev->conn->params.ssid_len;\n\n\teth_broadcast_addr(request->bssid);\n\n\trequest->wdev = wdev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->scan_start = jiffies;\n\n\trdev->scan_req = request;\n\n\terr = rdev_scan(rdev, request);\n\tif (!err) {\n\t\twdev->conn->state = CFG80211_CONN_SCANNING;\n\t\tnl80211_send_scan_start(rdev, wdev);\n\t\tdev_hold(wdev->netdev);\n\t} else {\n\t\trdev->scan_req = NULL;\n\t\tkfree(request);\n\t}\n\treturn err;\n}\n\nstatic int cfg80211_conn_do_work(struct wireless_dev *wdev,\n\t\t\t\t enum nl80211_timeout_reason *treason)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_connect_params *params;\n\tstruct cfg80211_auth_request auth_req = {};\n\tstruct cfg80211_assoc_request req = {};\n\tint err;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!wdev->conn)\n\t\treturn 0;\n\n\tparams = &wdev->conn->params;\n\n\tswitch (wdev->conn->state) {\n\tcase CFG80211_CONN_SCANNING:\n\t\t \n\t\treturn -ENOENT;\n\tcase CFG80211_CONN_SCAN_AGAIN:\n\t\treturn cfg80211_conn_scan(wdev);\n\tcase CFG80211_CONN_AUTHENTICATE_NEXT:\n\t\tif (WARN_ON(!rdev->ops->auth))\n\t\t\treturn -EOPNOTSUPP;\n\t\twdev->conn->state = CFG80211_CONN_AUTHENTICATING;\n\t\tauth_req.key = params->key;\n\t\tauth_req.key_len = params->key_len;\n\t\tauth_req.key_idx = params->key_idx;\n\t\tauth_req.auth_type = params->auth_type;\n\t\tauth_req.bss = cfg80211_get_bss(&rdev->wiphy, params->channel,\n\t\t\t\t\t\tparams->bssid,\n\t\t\t\t\t\tparams->ssid, params->ssid_len,\n\t\t\t\t\t\tIEEE80211_BSS_TYPE_ESS,\n\t\t\t\t\t\tIEEE80211_PRIVACY_ANY);\n\t\tauth_req.link_id = -1;\n\t\terr = cfg80211_mlme_auth(rdev, wdev->netdev, &auth_req);\n\t\tcfg80211_put_bss(&rdev->wiphy, auth_req.bss);\n\t\treturn err;\n\tcase CFG80211_CONN_AUTH_FAILED_TIMEOUT:\n\t\t*treason = NL80211_TIMEOUT_AUTH;\n\t\treturn -ENOTCONN;\n\tcase CFG80211_CONN_ASSOCIATE_NEXT:\n\t\tif (WARN_ON(!rdev->ops->assoc))\n\t\t\treturn -EOPNOTSUPP;\n\t\twdev->conn->state = CFG80211_CONN_ASSOCIATING;\n\t\tif (wdev->conn->prev_bssid_valid)\n\t\t\treq.prev_bssid = wdev->conn->prev_bssid;\n\t\treq.ie = params->ie;\n\t\treq.ie_len = params->ie_len;\n\t\treq.use_mfp = params->mfp != NL80211_MFP_NO;\n\t\treq.crypto = params->crypto;\n\t\treq.flags = params->flags;\n\t\treq.ht_capa = params->ht_capa;\n\t\treq.ht_capa_mask = params->ht_capa_mask;\n\t\treq.vht_capa = params->vht_capa;\n\t\treq.vht_capa_mask = params->vht_capa_mask;\n\t\treq.link_id = -1;\n\n\t\treq.bss = cfg80211_get_bss(&rdev->wiphy, params->channel,\n\t\t\t\t\t   params->bssid,\n\t\t\t\t\t   params->ssid, params->ssid_len,\n\t\t\t\t\t   IEEE80211_BSS_TYPE_ESS,\n\t\t\t\t\t   IEEE80211_PRIVACY_ANY);\n\t\tif (!req.bss) {\n\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\terr = cfg80211_mlme_assoc(rdev, wdev->netdev, &req);\n\t\t\tcfg80211_put_bss(&rdev->wiphy, req.bss);\n\t\t}\n\n\t\tif (err)\n\t\t\tcfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,\n\t\t\t\t\t     NULL, 0,\n\t\t\t\t\t     WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t\t     false);\n\t\treturn err;\n\tcase CFG80211_CONN_ASSOC_FAILED_TIMEOUT:\n\t\t*treason = NL80211_TIMEOUT_ASSOC;\n\t\tfallthrough;\n\tcase CFG80211_CONN_ASSOC_FAILED:\n\t\tcfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,\n\t\t\t\t     NULL, 0,\n\t\t\t\t     WLAN_REASON_DEAUTH_LEAVING, false);\n\t\treturn -ENOTCONN;\n\tcase CFG80211_CONN_DEAUTH:\n\t\tcfg80211_mlme_deauth(rdev, wdev->netdev, params->bssid,\n\t\t\t\t     NULL, 0,\n\t\t\t\t     WLAN_REASON_DEAUTH_LEAVING, false);\n\t\tfallthrough;\n\tcase CFG80211_CONN_ABANDON:\n\t\t \n\t\tcfg80211_sme_free(wdev);\n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nvoid cfg80211_conn_work(struct work_struct *work)\n{\n\tstruct cfg80211_registered_device *rdev =\n\t\tcontainer_of(work, struct cfg80211_registered_device, conn_work);\n\tstruct wireless_dev *wdev;\n\tu8 bssid_buf[ETH_ALEN], *bssid = NULL;\n\tenum nl80211_timeout_reason treason;\n\n\twiphy_lock(&rdev->wiphy);\n\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\tif (!wdev->netdev)\n\t\t\tcontinue;\n\n\t\twdev_lock(wdev);\n\t\tif (!netif_running(wdev->netdev)) {\n\t\t\twdev_unlock(wdev);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!wdev->conn ||\n\t\t    wdev->conn->state == CFG80211_CONN_CONNECTED) {\n\t\t\twdev_unlock(wdev);\n\t\t\tcontinue;\n\t\t}\n\t\tif (wdev->conn->params.bssid) {\n\t\t\tmemcpy(bssid_buf, wdev->conn->params.bssid, ETH_ALEN);\n\t\t\tbssid = bssid_buf;\n\t\t}\n\t\ttreason = NL80211_TIMEOUT_UNSPECIFIED;\n\t\tif (cfg80211_conn_do_work(wdev, &treason)) {\n\t\t\tstruct cfg80211_connect_resp_params cr;\n\n\t\t\tmemset(&cr, 0, sizeof(cr));\n\t\t\tcr.status = -1;\n\t\t\tcr.links[0].bssid = bssid;\n\t\t\tcr.timeout_reason = treason;\n\t\t\t__cfg80211_connect_result(wdev->netdev, &cr, false);\n\t\t}\n\t\twdev_unlock(wdev);\n\t}\n\n\twiphy_unlock(&rdev->wiphy);\n}\n\nstatic void cfg80211_step_auth_next(struct cfg80211_conn *conn,\n\t\t\t\t    struct cfg80211_bss *bss)\n{\n\tmemcpy(conn->bssid, bss->bssid, ETH_ALEN);\n\tconn->params.bssid = conn->bssid;\n\tconn->params.channel = bss->channel;\n\tconn->state = CFG80211_CONN_AUTHENTICATE_NEXT;\n}\n\n \nstatic struct cfg80211_bss *cfg80211_get_conn_bss(struct wireless_dev *wdev)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_bss *bss;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tbss = cfg80211_get_bss(wdev->wiphy, wdev->conn->params.channel,\n\t\t\t       wdev->conn->params.bssid,\n\t\t\t       wdev->conn->params.ssid,\n\t\t\t       wdev->conn->params.ssid_len,\n\t\t\t       wdev->conn_bss_type,\n\t\t\t       IEEE80211_PRIVACY(wdev->conn->params.privacy));\n\tif (!bss)\n\t\treturn NULL;\n\n\tcfg80211_step_auth_next(wdev->conn, bss);\n\tschedule_work(&rdev->conn_work);\n\n\treturn bss;\n}\n\nstatic void __cfg80211_sme_scan_done(struct net_device *dev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_bss *bss;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!wdev->conn)\n\t\treturn;\n\n\tif (wdev->conn->state != CFG80211_CONN_SCANNING &&\n\t    wdev->conn->state != CFG80211_CONN_SCAN_AGAIN)\n\t\treturn;\n\n\tbss = cfg80211_get_conn_bss(wdev);\n\tif (bss)\n\t\tcfg80211_put_bss(&rdev->wiphy, bss);\n\telse\n\t\tschedule_work(&rdev->conn_work);\n}\n\nvoid cfg80211_sme_scan_done(struct net_device *dev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\twdev_lock(wdev);\n\t__cfg80211_sme_scan_done(dev);\n\twdev_unlock(wdev);\n}\n\nvoid cfg80211_sme_rx_auth(struct wireless_dev *wdev, const u8 *buf, size_t len)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)buf;\n\tu16 status_code = le16_to_cpu(mgmt->u.auth.status_code);\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!wdev->conn || wdev->conn->state == CFG80211_CONN_CONNECTED)\n\t\treturn;\n\n\tif (status_code == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG &&\n\t    wdev->conn->auto_auth &&\n\t    wdev->conn->params.auth_type != NL80211_AUTHTYPE_NETWORK_EAP) {\n\t\t \n\t\tswitch (wdev->conn->params.auth_type) {\n\t\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\t\t\tif (wdev->connect_keys)\n\t\t\t\twdev->conn->params.auth_type =\n\t\t\t\t\tNL80211_AUTHTYPE_SHARED_KEY;\n\t\t\telse\n\t\t\t\twdev->conn->params.auth_type =\n\t\t\t\t\tNL80211_AUTHTYPE_NETWORK_EAP;\n\t\t\tbreak;\n\t\tcase NL80211_AUTHTYPE_SHARED_KEY:\n\t\t\twdev->conn->params.auth_type =\n\t\t\t\tNL80211_AUTHTYPE_NETWORK_EAP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\twdev->conn->params.auth_type =\n\t\t\t\tNL80211_AUTHTYPE_OPEN_SYSTEM;\n\t\t\tbreak;\n\t\t}\n\t\twdev->conn->state = CFG80211_CONN_AUTHENTICATE_NEXT;\n\t\tschedule_work(&rdev->conn_work);\n\t} else if (status_code != WLAN_STATUS_SUCCESS) {\n\t\tstruct cfg80211_connect_resp_params cr;\n\n\t\tmemset(&cr, 0, sizeof(cr));\n\t\tcr.status = status_code;\n\t\tcr.links[0].bssid = mgmt->bssid;\n\t\tcr.timeout_reason = NL80211_TIMEOUT_UNSPECIFIED;\n\t\t__cfg80211_connect_result(wdev->netdev, &cr, false);\n\t} else if (wdev->conn->state == CFG80211_CONN_AUTHENTICATING) {\n\t\twdev->conn->state = CFG80211_CONN_ASSOCIATE_NEXT;\n\t\tschedule_work(&rdev->conn_work);\n\t}\n}\n\nbool cfg80211_sme_rx_assoc_resp(struct wireless_dev *wdev, u16 status)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\n\tif (!wdev->conn)\n\t\treturn false;\n\n\tif (status == WLAN_STATUS_SUCCESS) {\n\t\twdev->conn->state = CFG80211_CONN_CONNECTED;\n\t\treturn false;\n\t}\n\n\tif (wdev->conn->prev_bssid_valid) {\n\t\t \n\t\twdev->conn->prev_bssid_valid = false;\n\t\twdev->conn->state = CFG80211_CONN_ASSOCIATE_NEXT;\n\t\tschedule_work(&rdev->conn_work);\n\t\treturn true;\n\t}\n\n\twdev->conn->state = CFG80211_CONN_ASSOC_FAILED;\n\tschedule_work(&rdev->conn_work);\n\treturn false;\n}\n\nvoid cfg80211_sme_deauth(struct wireless_dev *wdev)\n{\n\tcfg80211_sme_free(wdev);\n}\n\nvoid cfg80211_sme_auth_timeout(struct wireless_dev *wdev)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\n\tif (!wdev->conn)\n\t\treturn;\n\n\twdev->conn->state = CFG80211_CONN_AUTH_FAILED_TIMEOUT;\n\tschedule_work(&rdev->conn_work);\n}\n\nvoid cfg80211_sme_disassoc(struct wireless_dev *wdev)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\n\tif (!wdev->conn)\n\t\treturn;\n\n\twdev->conn->state = CFG80211_CONN_DEAUTH;\n\tschedule_work(&rdev->conn_work);\n}\n\nvoid cfg80211_sme_assoc_timeout(struct wireless_dev *wdev)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\n\tif (!wdev->conn)\n\t\treturn;\n\n\twdev->conn->state = CFG80211_CONN_ASSOC_FAILED_TIMEOUT;\n\tschedule_work(&rdev->conn_work);\n}\n\nvoid cfg80211_sme_abandon_assoc(struct wireless_dev *wdev)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\n\tif (!wdev->conn)\n\t\treturn;\n\n\twdev->conn->state = CFG80211_CONN_ABANDON;\n\tschedule_work(&rdev->conn_work);\n}\n\nstatic void cfg80211_wdev_release_bsses(struct wireless_dev *wdev)\n{\n\tunsigned int link;\n\n\tfor_each_valid_link(wdev, link) {\n\t\tif (!wdev->links[link].client.current_bss)\n\t\t\tcontinue;\n\t\tcfg80211_unhold_bss(wdev->links[link].client.current_bss);\n\t\tcfg80211_put_bss(wdev->wiphy,\n\t\t\t\t &wdev->links[link].client.current_bss->pub);\n\t\twdev->links[link].client.current_bss = NULL;\n\t}\n}\n\nvoid cfg80211_wdev_release_link_bsses(struct wireless_dev *wdev, u16 link_mask)\n{\n\tunsigned int link;\n\n\tfor_each_valid_link(wdev, link) {\n\t\tif (!wdev->links[link].client.current_bss ||\n\t\t    !(link_mask & BIT(link)))\n\t\t\tcontinue;\n\t\tcfg80211_unhold_bss(wdev->links[link].client.current_bss);\n\t\tcfg80211_put_bss(wdev->wiphy,\n\t\t\t\t &wdev->links[link].client.current_bss->pub);\n\t\twdev->links[link].client.current_bss = NULL;\n\t}\n}\n\nstatic int cfg80211_sme_get_conn_ies(struct wireless_dev *wdev,\n\t\t\t\t     const u8 *ies, size_t ies_len,\n\t\t\t\t     const u8 **out_ies, size_t *out_ies_len)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tu8 *buf;\n\tsize_t offs;\n\n\tif (!rdev->wiphy.extended_capabilities_len ||\n\t    (ies && cfg80211_find_ie(WLAN_EID_EXT_CAPABILITY, ies, ies_len))) {\n\t\t*out_ies = kmemdup(ies, ies_len, GFP_KERNEL);\n\t\tif (!*out_ies)\n\t\t\treturn -ENOMEM;\n\t\t*out_ies_len = ies_len;\n\t\treturn 0;\n\t}\n\n\tbuf = kmalloc(ies_len + rdev->wiphy.extended_capabilities_len + 2,\n\t\t      GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (ies_len) {\n\t\tstatic const u8 before_extcapa[] = {\n\t\t\t \n\t\t\tWLAN_EID_RSN,\n\t\t\tWLAN_EID_QOS_CAPA,\n\t\t\tWLAN_EID_RRM_ENABLED_CAPABILITIES,\n\t\t\tWLAN_EID_MOBILITY_DOMAIN,\n\t\t\tWLAN_EID_SUPPORTED_REGULATORY_CLASSES,\n\t\t\tWLAN_EID_BSS_COEX_2040,\n\t\t};\n\n\t\toffs = ieee80211_ie_split(ies, ies_len, before_extcapa,\n\t\t\t\t\t  ARRAY_SIZE(before_extcapa), 0);\n\t\tmemcpy(buf, ies, offs);\n\t\t \n\t\tmemcpy(buf + offs + rdev->wiphy.extended_capabilities_len + 2,\n\t\t       ies + offs, ies_len - offs);\n\t} else {\n\t\toffs = 0;\n\t}\n\n\t \n\tbuf[offs] = WLAN_EID_EXT_CAPABILITY;\n\tbuf[offs + 1] = rdev->wiphy.extended_capabilities_len;\n\tmemcpy(buf + offs + 2,\n\t       rdev->wiphy.extended_capabilities,\n\t       rdev->wiphy.extended_capabilities_len);\n\n\t*out_ies = buf;\n\t*out_ies_len = ies_len + rdev->wiphy.extended_capabilities_len + 2;\n\n\treturn 0;\n}\n\nstatic int cfg80211_sme_connect(struct wireless_dev *wdev,\n\t\t\t\tstruct cfg80211_connect_params *connect,\n\t\t\t\tconst u8 *prev_bssid)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_bss *bss;\n\tint err;\n\n\tif (!rdev->ops->auth || !rdev->ops->assoc)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg80211_wdev_release_bsses(wdev);\n\n\tif (wdev->connected) {\n\t\tcfg80211_sme_free(wdev);\n\t\twdev->connected = false;\n\t}\n\n\tif (wdev->conn)\n\t\treturn -EINPROGRESS;\n\n\twdev->conn = kzalloc(sizeof(*wdev->conn), GFP_KERNEL);\n\tif (!wdev->conn)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(&wdev->conn->params, connect, sizeof(*connect));\n\tif (connect->bssid) {\n\t\twdev->conn->params.bssid = wdev->conn->bssid;\n\t\tmemcpy(wdev->conn->bssid, connect->bssid, ETH_ALEN);\n\t}\n\n\tif (cfg80211_sme_get_conn_ies(wdev, connect->ie, connect->ie_len,\n\t\t\t\t      &wdev->conn->ie,\n\t\t\t\t      &wdev->conn->params.ie_len)) {\n\t\tkfree(wdev->conn);\n\t\twdev->conn = NULL;\n\t\treturn -ENOMEM;\n\t}\n\twdev->conn->params.ie = wdev->conn->ie;\n\n\tif (connect->auth_type == NL80211_AUTHTYPE_AUTOMATIC) {\n\t\twdev->conn->auto_auth = true;\n\t\t \n\t\twdev->conn->params.auth_type =\n\t\t\tNL80211_AUTHTYPE_OPEN_SYSTEM;\n\t} else {\n\t\twdev->conn->auto_auth = false;\n\t}\n\n\twdev->conn->params.ssid = wdev->u.client.ssid;\n\twdev->conn->params.ssid_len = wdev->u.client.ssid_len;\n\n\t \n\tbss = cfg80211_get_bss(wdev->wiphy, wdev->conn->params.channel,\n\t\t\t       wdev->conn->params.bssid,\n\t\t\t       wdev->conn->params.ssid,\n\t\t\t       wdev->conn->params.ssid_len,\n\t\t\t       wdev->conn_bss_type,\n\t\t\t       IEEE80211_PRIVACY(wdev->conn->params.privacy));\n\n\tif (prev_bssid) {\n\t\tmemcpy(wdev->conn->prev_bssid, prev_bssid, ETH_ALEN);\n\t\twdev->conn->prev_bssid_valid = true;\n\t}\n\n\t \n\tif (bss) {\n\t\tenum nl80211_timeout_reason treason;\n\n\t\tcfg80211_step_auth_next(wdev->conn, bss);\n\t\terr = cfg80211_conn_do_work(wdev, &treason);\n\t\tcfg80211_put_bss(wdev->wiphy, bss);\n\t} else {\n\t\t \n\t\terr = cfg80211_conn_scan(wdev);\n\n\t\t \n\t\tif (err == -EBUSY) {\n\t\t\terr = 0;\n\t\t\twdev->conn->state = CFG80211_CONN_SCAN_AGAIN;\n\t\t}\n\t}\n\n\tif (err)\n\t\tcfg80211_sme_free(wdev);\n\n\treturn err;\n}\n\nstatic int cfg80211_sme_disconnect(struct wireless_dev *wdev, u16 reason)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tint err;\n\n\tif (!wdev->conn)\n\t\treturn 0;\n\n\tif (!rdev->ops->deauth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->conn->state == CFG80211_CONN_SCANNING ||\n\t    wdev->conn->state == CFG80211_CONN_SCAN_AGAIN) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t \n\terr = cfg80211_mlme_deauth(rdev, wdev->netdev,\n\t\t\t\t   wdev->conn->params.bssid,\n\t\t\t\t   NULL, 0, reason, false);\n out:\n\tcfg80211_sme_free(wdev);\n\treturn err;\n}\n\n \n\nstatic bool cfg80211_is_all_idle(void)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tbool is_all_idle = true;\n\n\t \n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\twdev_lock(wdev);\n\t\t\tif (wdev->conn || wdev->connected ||\n\t\t\t    cfg80211_beaconing_iface_active(wdev))\n\t\t\t\tis_all_idle = false;\n\t\t\twdev_unlock(wdev);\n\t\t}\n\t}\n\n\treturn is_all_idle;\n}\n\nstatic void disconnect_work(struct work_struct *work)\n{\n\trtnl_lock();\n\tif (cfg80211_is_all_idle())\n\t\tregulatory_hint_disconnect();\n\trtnl_unlock();\n}\n\nDECLARE_WORK(cfg80211_disconnect_work, disconnect_work);\n\nstatic void\ncfg80211_connect_result_release_bsses(struct wireless_dev *wdev,\n\t\t\t\t      struct cfg80211_connect_resp_params *cr)\n{\n\tunsigned int link;\n\n\tfor_each_valid_link(cr, link) {\n\t\tif (!cr->links[link].bss)\n\t\t\tcontinue;\n\t\tcfg80211_unhold_bss(bss_from_pub(cr->links[link].bss));\n\t\tcfg80211_put_bss(wdev->wiphy, cr->links[link].bss);\n\t}\n}\n\n \n\n \nvoid __cfg80211_connect_result(struct net_device *dev,\n\t\t\t       struct cfg80211_connect_resp_params *cr,\n\t\t\t       bool wextev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst struct element *country_elem = NULL;\n\tconst struct element *ssid;\n\tconst u8 *country_data;\n\tu8 country_datalen;\n#ifdef CONFIG_CFG80211_WEXT\n\tunion iwreq_data wrqu;\n#endif\n\tunsigned int link;\n\tconst u8 *connected_addr;\n\tbool bss_not_found = false;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))\n\t\tgoto out;\n\n\tif (cr->valid_links) {\n\t\tif (WARN_ON(!cr->ap_mld_addr))\n\t\t\tgoto out;\n\n\t\tfor_each_valid_link(cr, link) {\n\t\t\tif (WARN_ON(!cr->links[link].addr))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (WARN_ON(wdev->connect_keys))\n\t\t\tgoto out;\n\t}\n\n\twdev->unprot_beacon_reported = 0;\n\tnl80211_send_connect_result(wiphy_to_rdev(wdev->wiphy), dev, cr,\n\t\t\t\t    GFP_KERNEL);\n\tconnected_addr = cr->valid_links ? cr->ap_mld_addr : cr->links[0].bssid;\n\n#ifdef CONFIG_CFG80211_WEXT\n\tif (wextev && !cr->valid_links) {\n\t\tif (cr->req_ie && cr->status == WLAN_STATUS_SUCCESS) {\n\t\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\t\t\twrqu.data.length = cr->req_ie_len;\n\t\t\twireless_send_event(dev, IWEVASSOCREQIE, &wrqu,\n\t\t\t\t\t    cr->req_ie);\n\t\t}\n\n\t\tif (cr->resp_ie && cr->status == WLAN_STATUS_SUCCESS) {\n\t\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\t\t\twrqu.data.length = cr->resp_ie_len;\n\t\t\twireless_send_event(dev, IWEVASSOCRESPIE, &wrqu,\n\t\t\t\t\t    cr->resp_ie);\n\t\t}\n\n\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\t\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\t\tif (connected_addr && cr->status == WLAN_STATUS_SUCCESS) {\n\t\t\tmemcpy(wrqu.ap_addr.sa_data, connected_addr, ETH_ALEN);\n\t\t\tmemcpy(wdev->wext.prev_bssid, connected_addr, ETH_ALEN);\n\t\t\twdev->wext.prev_bssid_valid = true;\n\t\t}\n\t\twireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);\n\t}\n#endif\n\n\tif (cr->status == WLAN_STATUS_SUCCESS) {\n\t\tif (!wiphy_to_rdev(wdev->wiphy)->ops->connect) {\n\t\t\tfor_each_valid_link(cr, link) {\n\t\t\t\tif (WARN_ON_ONCE(!cr->links[link].bss))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor_each_valid_link(cr, link) {\n\t\t\t \n\t\t\tif (cr->links[link].status != WLAN_STATUS_SUCCESS)\n\t\t\t\tcontinue;\n\n\t\t\tif (cr->links[link].bss)\n\t\t\t\tcontinue;\n\n\t\t\tcr->links[link].bss =\n\t\t\t\tcfg80211_get_bss(wdev->wiphy, NULL,\n\t\t\t\t\t\t cr->links[link].bssid,\n\t\t\t\t\t\t wdev->u.client.ssid,\n\t\t\t\t\t\t wdev->u.client.ssid_len,\n\t\t\t\t\t\t wdev->conn_bss_type,\n\t\t\t\t\t\t IEEE80211_PRIVACY_ANY);\n\t\t\tif (!cr->links[link].bss) {\n\t\t\t\tbss_not_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcfg80211_hold_bss(bss_from_pub(cr->links[link].bss));\n\t\t}\n\t}\n\n\tcfg80211_wdev_release_bsses(wdev);\n\n\tif (cr->status != WLAN_STATUS_SUCCESS) {\n\t\tkfree_sensitive(wdev->connect_keys);\n\t\twdev->connect_keys = NULL;\n\t\twdev->u.client.ssid_len = 0;\n\t\twdev->conn_owner_nlportid = 0;\n\t\tcfg80211_connect_result_release_bsses(wdev, cr);\n\t\tcfg80211_sme_free(wdev);\n\t\treturn;\n\t}\n\n\tif (WARN_ON(bss_not_found)) {\n\t\tcfg80211_connect_result_release_bsses(wdev, cr);\n\t\treturn;\n\t}\n\n\tmemset(wdev->links, 0, sizeof(wdev->links));\n\tfor_each_valid_link(cr, link) {\n\t\tif (cr->links[link].status == WLAN_STATUS_SUCCESS)\n\t\t\tcontinue;\n\t\tcr->valid_links &= ~BIT(link);\n\t\t \n\t\tif (!cr->links[link].bss)\n\t\t\tcontinue;\n\t\tcfg80211_unhold_bss(bss_from_pub(cr->links[link].bss));\n\t\tcfg80211_put_bss(wdev->wiphy, cr->links[link].bss);\n\t}\n\twdev->valid_links = cr->valid_links;\n\tfor_each_valid_link(cr, link)\n\t\twdev->links[link].client.current_bss =\n\t\t\tbss_from_pub(cr->links[link].bss);\n\twdev->connected = true;\n\tether_addr_copy(wdev->u.client.connected_addr, connected_addr);\n\tif (cr->valid_links) {\n\t\tfor_each_valid_link(cr, link)\n\t\t\tmemcpy(wdev->links[link].addr, cr->links[link].addr,\n\t\t\t       ETH_ALEN);\n\t}\n\n\tcfg80211_upload_connect_keys(wdev);\n\n\trcu_read_lock();\n\tfor_each_valid_link(cr, link) {\n\t\tcountry_elem =\n\t\t\tieee80211_bss_get_elem(cr->links[link].bss,\n\t\t\t\t\t       WLAN_EID_COUNTRY);\n\t\tif (country_elem)\n\t\t\tbreak;\n\t}\n\tif (!country_elem) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tcountry_datalen = country_elem->datalen;\n\tcountry_data = kmemdup(country_elem->data, country_datalen, GFP_ATOMIC);\n\trcu_read_unlock();\n\n\tif (!country_data)\n\t\treturn;\n\n\tregulatory_hint_country_ie(wdev->wiphy,\n\t\t\t\t   cr->links[link].bss->channel->band,\n\t\t\t\t   country_data, country_datalen);\n\tkfree(country_data);\n\n\tif (!wdev->u.client.ssid_len) {\n\t\trcu_read_lock();\n\t\tfor_each_valid_link(cr, link) {\n\t\t\tssid = ieee80211_bss_get_elem(cr->links[link].bss,\n\t\t\t\t\t\t      WLAN_EID_SSID);\n\n\t\t\tif (!ssid || !ssid->datalen)\n\t\t\t\tcontinue;\n\n\t\t\tmemcpy(wdev->u.client.ssid, ssid->data, ssid->datalen);\n\t\t\twdev->u.client.ssid_len = ssid->datalen;\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\treturn;\nout:\n\tfor_each_valid_link(cr, link)\n\t\tcfg80211_put_bss(wdev->wiphy, cr->links[link].bss);\n}\n\nstatic void cfg80211_update_link_bss(struct wireless_dev *wdev,\n\t\t\t\t     struct cfg80211_bss **bss)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_internal_bss *ibss;\n\n\tif (!*bss)\n\t\treturn;\n\n\tibss = bss_from_pub(*bss);\n\tif (list_empty(&ibss->list)) {\n\t\tstruct cfg80211_bss *found = NULL, *tmp = *bss;\n\n\t\tfound = cfg80211_get_bss(wdev->wiphy, NULL,\n\t\t\t\t\t (*bss)->bssid,\n\t\t\t\t\t wdev->u.client.ssid,\n\t\t\t\t\t wdev->u.client.ssid_len,\n\t\t\t\t\t wdev->conn_bss_type,\n\t\t\t\t\t IEEE80211_PRIVACY_ANY);\n\t\tif (found) {\n\t\t\t \n\t\t\t*bss = found;\n\t\t} else {\n\t\t\t \n\t\t\tcfg80211_bss_update(rdev, ibss, false,\n\t\t\t\t\t    ibss->ts);\n\t\t}\n\n\t\tcfg80211_put_bss(wdev->wiphy, tmp);\n\t}\n}\n\n \nvoid cfg80211_connect_done(struct net_device *dev,\n\t\t\t   struct cfg80211_connect_resp_params *params,\n\t\t\t   gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_event *ev;\n\tunsigned long flags;\n\tu8 *next;\n\tsize_t link_info_size = 0;\n\tunsigned int link;\n\n\tfor_each_valid_link(params, link) {\n\t\tcfg80211_update_link_bss(wdev, &params->links[link].bss);\n\t\tlink_info_size += params->links[link].bssid ? ETH_ALEN : 0;\n\t\tlink_info_size += params->links[link].addr ? ETH_ALEN : 0;\n\t}\n\n\tev = kzalloc(sizeof(*ev) + (params->ap_mld_addr ? ETH_ALEN : 0) +\n\t\t     params->req_ie_len + params->resp_ie_len +\n\t\t     params->fils.kek_len + params->fils.pmk_len +\n\t\t     (params->fils.pmkid ? WLAN_PMKID_LEN : 0) + link_info_size,\n\t\t     gfp);\n\n\tif (!ev) {\n\t\tfor_each_valid_link(params, link)\n\t\t\tcfg80211_put_bss(wdev->wiphy,\n\t\t\t\t\t params->links[link].bss);\n\t\treturn;\n\t}\n\n\tev->type = EVENT_CONNECT_RESULT;\n\tnext = ((u8 *)ev) + sizeof(*ev);\n\tif (params->ap_mld_addr) {\n\t\tev->cr.ap_mld_addr = next;\n\t\tmemcpy((void *)ev->cr.ap_mld_addr, params->ap_mld_addr,\n\t\t       ETH_ALEN);\n\t\tnext += ETH_ALEN;\n\t}\n\tif (params->req_ie_len) {\n\t\tev->cr.req_ie = next;\n\t\tev->cr.req_ie_len = params->req_ie_len;\n\t\tmemcpy((void *)ev->cr.req_ie, params->req_ie,\n\t\t       params->req_ie_len);\n\t\tnext += params->req_ie_len;\n\t}\n\tif (params->resp_ie_len) {\n\t\tev->cr.resp_ie = next;\n\t\tev->cr.resp_ie_len = params->resp_ie_len;\n\t\tmemcpy((void *)ev->cr.resp_ie, params->resp_ie,\n\t\t       params->resp_ie_len);\n\t\tnext += params->resp_ie_len;\n\t}\n\tif (params->fils.kek_len) {\n\t\tev->cr.fils.kek = next;\n\t\tev->cr.fils.kek_len = params->fils.kek_len;\n\t\tmemcpy((void *)ev->cr.fils.kek, params->fils.kek,\n\t\t       params->fils.kek_len);\n\t\tnext += params->fils.kek_len;\n\t}\n\tif (params->fils.pmk_len) {\n\t\tev->cr.fils.pmk = next;\n\t\tev->cr.fils.pmk_len = params->fils.pmk_len;\n\t\tmemcpy((void *)ev->cr.fils.pmk, params->fils.pmk,\n\t\t       params->fils.pmk_len);\n\t\tnext += params->fils.pmk_len;\n\t}\n\tif (params->fils.pmkid) {\n\t\tev->cr.fils.pmkid = next;\n\t\tmemcpy((void *)ev->cr.fils.pmkid, params->fils.pmkid,\n\t\t       WLAN_PMKID_LEN);\n\t\tnext += WLAN_PMKID_LEN;\n\t}\n\tev->cr.fils.update_erp_next_seq_num = params->fils.update_erp_next_seq_num;\n\tif (params->fils.update_erp_next_seq_num)\n\t\tev->cr.fils.erp_next_seq_num = params->fils.erp_next_seq_num;\n\tev->cr.valid_links = params->valid_links;\n\tfor_each_valid_link(params, link) {\n\t\tif (params->links[link].bss)\n\t\t\tcfg80211_hold_bss(\n\t\t\t\tbss_from_pub(params->links[link].bss));\n\t\tev->cr.links[link].bss = params->links[link].bss;\n\n\t\tif (params->links[link].addr) {\n\t\t\tev->cr.links[link].addr = next;\n\t\t\tmemcpy((void *)ev->cr.links[link].addr,\n\t\t\t       params->links[link].addr,\n\t\t\t       ETH_ALEN);\n\t\t\tnext += ETH_ALEN;\n\t\t}\n\t\tif (params->links[link].bssid) {\n\t\t\tev->cr.links[link].bssid = next;\n\t\t\tmemcpy((void *)ev->cr.links[link].bssid,\n\t\t\t       params->links[link].bssid,\n\t\t\t       ETH_ALEN);\n\t\t\tnext += ETH_ALEN;\n\t\t}\n\t}\n\tev->cr.status = params->status;\n\tev->cr.timeout_reason = params->timeout_reason;\n\n\tspin_lock_irqsave(&wdev->event_lock, flags);\n\tlist_add_tail(&ev->list, &wdev->event_list);\n\tspin_unlock_irqrestore(&wdev->event_lock, flags);\n\tqueue_work(cfg80211_wq, &rdev->event_work);\n}\nEXPORT_SYMBOL(cfg80211_connect_done);\n\n \nvoid __cfg80211_roamed(struct wireless_dev *wdev,\n\t\t       struct cfg80211_roam_info *info)\n{\n#ifdef CONFIG_CFG80211_WEXT\n\tunion iwreq_data wrqu;\n#endif\n\tunsigned int link;\n\tconst u8 *connected_addr;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))\n\t\tgoto out;\n\n\tif (WARN_ON(!wdev->connected))\n\t\tgoto out;\n\n\tif (info->valid_links) {\n\t\tif (WARN_ON(!info->ap_mld_addr))\n\t\t\tgoto out;\n\n\t\tfor_each_valid_link(info, link) {\n\t\t\tif (WARN_ON(!info->links[link].addr))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcfg80211_wdev_release_bsses(wdev);\n\n\tfor_each_valid_link(info, link) {\n\t\tif (WARN_ON(!info->links[link].bss))\n\t\t\tgoto out;\n\t}\n\n\tmemset(wdev->links, 0, sizeof(wdev->links));\n\twdev->valid_links = info->valid_links;\n\tfor_each_valid_link(info, link) {\n\t\tcfg80211_hold_bss(bss_from_pub(info->links[link].bss));\n\t\twdev->links[link].client.current_bss =\n\t\t\tbss_from_pub(info->links[link].bss);\n\t}\n\n\tconnected_addr = info->valid_links ?\n\t\t\t info->ap_mld_addr :\n\t\t\t info->links[0].bss->bssid;\n\tether_addr_copy(wdev->u.client.connected_addr, connected_addr);\n\tif (info->valid_links) {\n\t\tfor_each_valid_link(info, link)\n\t\t\tmemcpy(wdev->links[link].addr, info->links[link].addr,\n\t\t\t       ETH_ALEN);\n\t}\n\twdev->unprot_beacon_reported = 0;\n\tnl80211_send_roamed(wiphy_to_rdev(wdev->wiphy),\n\t\t\t    wdev->netdev, info, GFP_KERNEL);\n\n#ifdef CONFIG_CFG80211_WEXT\n\tif (!info->valid_links) {\n\t\tif (info->req_ie) {\n\t\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\t\t\twrqu.data.length = info->req_ie_len;\n\t\t\twireless_send_event(wdev->netdev, IWEVASSOCREQIE,\n\t\t\t\t\t    &wrqu, info->req_ie);\n\t\t}\n\n\t\tif (info->resp_ie) {\n\t\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\t\t\twrqu.data.length = info->resp_ie_len;\n\t\t\twireless_send_event(wdev->netdev, IWEVASSOCRESPIE,\n\t\t\t\t\t    &wrqu, info->resp_ie);\n\t\t}\n\n\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\t\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\t\tmemcpy(wrqu.ap_addr.sa_data, connected_addr, ETH_ALEN);\n\t\tmemcpy(wdev->wext.prev_bssid, connected_addr, ETH_ALEN);\n\t\twdev->wext.prev_bssid_valid = true;\n\t\twireless_send_event(wdev->netdev, SIOCGIWAP, &wrqu, NULL);\n\t}\n#endif\n\n\treturn;\nout:\n\tfor_each_valid_link(info, link)\n\t\tcfg80211_put_bss(wdev->wiphy, info->links[link].bss);\n}\n\n \nvoid cfg80211_roamed(struct net_device *dev, struct cfg80211_roam_info *info,\n\t\t     gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_event *ev;\n\tunsigned long flags;\n\tu8 *next;\n\tunsigned int link;\n\tsize_t link_info_size = 0;\n\tbool bss_not_found = false;\n\n\tfor_each_valid_link(info, link) {\n\t\tlink_info_size += info->links[link].addr ? ETH_ALEN : 0;\n\t\tlink_info_size += info->links[link].bssid ? ETH_ALEN : 0;\n\n\t\tif (info->links[link].bss)\n\t\t\tcontinue;\n\n\t\tinfo->links[link].bss =\n\t\t\tcfg80211_get_bss(wdev->wiphy,\n\t\t\t\t\t info->links[link].channel,\n\t\t\t\t\t info->links[link].bssid,\n\t\t\t\t\t wdev->u.client.ssid,\n\t\t\t\t\t wdev->u.client.ssid_len,\n\t\t\t\t\t wdev->conn_bss_type,\n\t\t\t\t\t IEEE80211_PRIVACY_ANY);\n\n\t\tif (!info->links[link].bss) {\n\t\t\tbss_not_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ON(bss_not_found))\n\t\tgoto out;\n\n\tev = kzalloc(sizeof(*ev) + info->req_ie_len + info->resp_ie_len +\n\t\t     info->fils.kek_len + info->fils.pmk_len +\n\t\t     (info->fils.pmkid ? WLAN_PMKID_LEN : 0) +\n\t\t     (info->ap_mld_addr ? ETH_ALEN : 0) + link_info_size, gfp);\n\tif (!ev)\n\t\tgoto out;\n\n\tev->type = EVENT_ROAMED;\n\tnext = ((u8 *)ev) + sizeof(*ev);\n\tif (info->req_ie_len) {\n\t\tev->rm.req_ie = next;\n\t\tev->rm.req_ie_len = info->req_ie_len;\n\t\tmemcpy((void *)ev->rm.req_ie, info->req_ie, info->req_ie_len);\n\t\tnext += info->req_ie_len;\n\t}\n\tif (info->resp_ie_len) {\n\t\tev->rm.resp_ie = next;\n\t\tev->rm.resp_ie_len = info->resp_ie_len;\n\t\tmemcpy((void *)ev->rm.resp_ie, info->resp_ie,\n\t\t       info->resp_ie_len);\n\t\tnext += info->resp_ie_len;\n\t}\n\tif (info->fils.kek_len) {\n\t\tev->rm.fils.kek = next;\n\t\tev->rm.fils.kek_len = info->fils.kek_len;\n\t\tmemcpy((void *)ev->rm.fils.kek, info->fils.kek,\n\t\t       info->fils.kek_len);\n\t\tnext += info->fils.kek_len;\n\t}\n\tif (info->fils.pmk_len) {\n\t\tev->rm.fils.pmk = next;\n\t\tev->rm.fils.pmk_len = info->fils.pmk_len;\n\t\tmemcpy((void *)ev->rm.fils.pmk, info->fils.pmk,\n\t\t       info->fils.pmk_len);\n\t\tnext += info->fils.pmk_len;\n\t}\n\tif (info->fils.pmkid) {\n\t\tev->rm.fils.pmkid = next;\n\t\tmemcpy((void *)ev->rm.fils.pmkid, info->fils.pmkid,\n\t\t       WLAN_PMKID_LEN);\n\t\tnext += WLAN_PMKID_LEN;\n\t}\n\tev->rm.fils.update_erp_next_seq_num = info->fils.update_erp_next_seq_num;\n\tif (info->fils.update_erp_next_seq_num)\n\t\tev->rm.fils.erp_next_seq_num = info->fils.erp_next_seq_num;\n\tif (info->ap_mld_addr) {\n\t\tev->rm.ap_mld_addr = next;\n\t\tmemcpy((void *)ev->rm.ap_mld_addr, info->ap_mld_addr,\n\t\t       ETH_ALEN);\n\t\tnext += ETH_ALEN;\n\t}\n\tev->rm.valid_links = info->valid_links;\n\tfor_each_valid_link(info, link) {\n\t\tev->rm.links[link].bss = info->links[link].bss;\n\n\t\tif (info->links[link].addr) {\n\t\t\tev->rm.links[link].addr = next;\n\t\t\tmemcpy((void *)ev->rm.links[link].addr,\n\t\t\t       info->links[link].addr,\n\t\t\t       ETH_ALEN);\n\t\t\tnext += ETH_ALEN;\n\t\t}\n\n\t\tif (info->links[link].bssid) {\n\t\t\tev->rm.links[link].bssid = next;\n\t\t\tmemcpy((void *)ev->rm.links[link].bssid,\n\t\t\t       info->links[link].bssid,\n\t\t\t       ETH_ALEN);\n\t\t\tnext += ETH_ALEN;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&wdev->event_lock, flags);\n\tlist_add_tail(&ev->list, &wdev->event_list);\n\tspin_unlock_irqrestore(&wdev->event_lock, flags);\n\tqueue_work(cfg80211_wq, &rdev->event_work);\n\n\treturn;\nout:\n\tfor_each_valid_link(info, link)\n\t\tcfg80211_put_bss(wdev->wiphy, info->links[link].bss);\n\n}\nEXPORT_SYMBOL(cfg80211_roamed);\n\nvoid __cfg80211_port_authorized(struct wireless_dev *wdev, const u8 *bssid,\n\t\t\t\t\tconst u8 *td_bitmap, u8 td_bitmap_len)\n{\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))\n\t\treturn;\n\n\tif (WARN_ON(!wdev->connected) ||\n\t    WARN_ON(!ether_addr_equal(wdev->u.client.connected_addr, bssid)))\n\t\treturn;\n\n\tnl80211_send_port_authorized(wiphy_to_rdev(wdev->wiphy), wdev->netdev,\n\t\t\t\t     bssid, td_bitmap, td_bitmap_len);\n}\n\nvoid cfg80211_port_authorized(struct net_device *dev, const u8 *bssid,\n\t\t\t      const u8 *td_bitmap, u8 td_bitmap_len, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_event *ev;\n\tunsigned long flags;\n\n\tif (WARN_ON(!bssid))\n\t\treturn;\n\n\tev = kzalloc(sizeof(*ev) + td_bitmap_len, gfp);\n\tif (!ev)\n\t\treturn;\n\n\tev->type = EVENT_PORT_AUTHORIZED;\n\tmemcpy(ev->pa.bssid, bssid, ETH_ALEN);\n\tev->pa.td_bitmap = ((u8 *)ev) + sizeof(*ev);\n\tev->pa.td_bitmap_len = td_bitmap_len;\n\tmemcpy((void *)ev->pa.td_bitmap, td_bitmap, td_bitmap_len);\n\n\t \n\tspin_lock_irqsave(&wdev->event_lock, flags);\n\tlist_add_tail(&ev->list, &wdev->event_list);\n\tspin_unlock_irqrestore(&wdev->event_lock, flags);\n\tqueue_work(cfg80211_wq, &rdev->event_work);\n}\nEXPORT_SYMBOL(cfg80211_port_authorized);\n\nvoid __cfg80211_disconnected(struct net_device *dev, const u8 *ie,\n\t\t\t     size_t ie_len, u16 reason, bool from_ap)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tint i;\n#ifdef CONFIG_CFG80211_WEXT\n\tunion iwreq_data wrqu;\n#endif\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))\n\t\treturn;\n\n\tcfg80211_wdev_release_bsses(wdev);\n\twdev->connected = false;\n\twdev->u.client.ssid_len = 0;\n\twdev->conn_owner_nlportid = 0;\n\tkfree_sensitive(wdev->connect_keys);\n\twdev->connect_keys = NULL;\n\n\tnl80211_send_disconnected(rdev, dev, reason, ie, ie_len, from_ap);\n\n\t \n\tif (rdev->ops->crit_proto_stop && rdev->crit_proto_nlportid) {\n\t\trdev->crit_proto_nlportid = 0;\n\t\trdev_crit_proto_stop(rdev, wdev);\n\t}\n\n\t \n\tif (rdev->ops->del_key) {\n\t\tint max_key_idx = 5;\n\n\t\tif (wiphy_ext_feature_isset(\n\t\t\t    wdev->wiphy,\n\t\t\t    NL80211_EXT_FEATURE_BEACON_PROTECTION) ||\n\t\t    wiphy_ext_feature_isset(\n\t\t\t    wdev->wiphy,\n\t\t\t    NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT))\n\t\t\tmax_key_idx = 7;\n\t\tfor (i = 0; i <= max_key_idx; i++)\n\t\t\trdev_del_key(rdev, dev, -1, i, false, NULL);\n\t}\n\n\trdev_set_qos_map(rdev, dev, NULL);\n\n#ifdef CONFIG_CFG80211_WEXT\n\tmemset(&wrqu, 0, sizeof(wrqu));\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\twireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);\n\twdev->wext.connect.ssid_len = 0;\n#endif\n\n\tschedule_work(&cfg80211_disconnect_work);\n}\n\nvoid cfg80211_disconnected(struct net_device *dev, u16 reason,\n\t\t\t   const u8 *ie, size_t ie_len,\n\t\t\t   bool locally_generated, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_event *ev;\n\tunsigned long flags;\n\n\tev = kzalloc(sizeof(*ev) + ie_len, gfp);\n\tif (!ev)\n\t\treturn;\n\n\tev->type = EVENT_DISCONNECTED;\n\tev->dc.ie = ((u8 *)ev) + sizeof(*ev);\n\tev->dc.ie_len = ie_len;\n\tmemcpy((void *)ev->dc.ie, ie, ie_len);\n\tev->dc.reason = reason;\n\tev->dc.locally_generated = locally_generated;\n\n\tspin_lock_irqsave(&wdev->event_lock, flags);\n\tlist_add_tail(&ev->list, &wdev->event_list);\n\tspin_unlock_irqrestore(&wdev->event_lock, flags);\n\tqueue_work(cfg80211_wq, &rdev->event_work);\n}\nEXPORT_SYMBOL(cfg80211_disconnected);\n\n \nint cfg80211_connect(struct cfg80211_registered_device *rdev,\n\t\t     struct net_device *dev,\n\t\t     struct cfg80211_connect_params *connect,\n\t\t     struct cfg80211_cached_keys *connkeys,\n\t\t     const u8 *prev_bssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\t \n\tif (wdev->u.client.ssid_len &&\n\t    (wdev->u.client.ssid_len != connect->ssid_len ||\n\t     memcmp(wdev->u.client.ssid, connect->ssid, wdev->u.client.ssid_len)))\n\t\treturn -EALREADY;\n\n\t \n\tif (wdev->connected) {\n\t\tif (!prev_bssid)\n\t\t\treturn -EALREADY;\n\t\tif (!ether_addr_equal(prev_bssid,\n\t\t\t\t      wdev->u.client.connected_addr))\n\t\t\treturn -ENOTCONN;\n\t}\n\n\t \n\tif (wdev->connect_keys)\n\t\treturn -EINPROGRESS;\n\n\tcfg80211_oper_and_ht_capa(&connect->ht_capa_mask,\n\t\t\t\t  rdev->wiphy.ht_capa_mod_mask);\n\tcfg80211_oper_and_vht_capa(&connect->vht_capa_mask,\n\t\t\t\t   rdev->wiphy.vht_capa_mod_mask);\n\n\tif (connkeys && connkeys->def >= 0) {\n\t\tint idx;\n\t\tu32 cipher;\n\n\t\tidx = connkeys->def;\n\t\tcipher = connkeys->params[idx].cipher;\n\t\t \n\t\tif (cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t\t    cipher == WLAN_CIPHER_SUITE_WEP104) {\n\t\t\tconnect->key_idx = idx;\n\t\t\tconnect->key = connkeys->params[idx].key;\n\t\t\tconnect->key_len = connkeys->params[idx].key_len;\n\n\t\t\t \n\t\t\tif (connect->crypto.cipher_group == 0)\n\t\t\t\tconnect->crypto.cipher_group = cipher;\n\n\t\t\tif (connect->crypto.n_ciphers_pairwise == 0) {\n\t\t\t\tconnect->crypto.n_ciphers_pairwise = 1;\n\t\t\t\tconnect->crypto.ciphers_pairwise[0] = cipher;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (WARN_ON(connkeys))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tconnect->key = NULL;\n\t\tconnect->key_len = 0;\n\t\tconnect->key_idx = 0;\n\t}\n\n\twdev->connect_keys = connkeys;\n\tmemcpy(wdev->u.client.ssid, connect->ssid, connect->ssid_len);\n\twdev->u.client.ssid_len = connect->ssid_len;\n\n\twdev->conn_bss_type = connect->pbss ? IEEE80211_BSS_TYPE_PBSS :\n\t\t\t\t\t      IEEE80211_BSS_TYPE_ESS;\n\n\tif (!rdev->ops->connect)\n\t\terr = cfg80211_sme_connect(wdev, connect, prev_bssid);\n\telse\n\t\terr = rdev_connect(rdev, dev, connect);\n\n\tif (err) {\n\t\twdev->connect_keys = NULL;\n\t\t \n\t\tif (!wdev->connected)\n\t\t\twdev->u.client.ssid_len = 0;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint cfg80211_disconnect(struct cfg80211_registered_device *rdev,\n\t\t\tstruct net_device *dev, u16 reason, bool wextev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err = 0;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tkfree_sensitive(wdev->connect_keys);\n\twdev->connect_keys = NULL;\n\n\twdev->conn_owner_nlportid = 0;\n\n\tif (wdev->conn)\n\t\terr = cfg80211_sme_disconnect(wdev, reason);\n\telse if (!rdev->ops->disconnect)\n\t\tcfg80211_mlme_down(rdev, dev);\n\telse if (wdev->u.client.ssid_len)\n\t\terr = rdev_disconnect(rdev, dev, reason);\n\n\t \n\tif (!wdev->connected)\n\t\twdev->u.client.ssid_len = 0;\n\n\treturn err;\n}\n\n \nvoid cfg80211_autodisconnect_wk(struct work_struct *work)\n{\n\tstruct wireless_dev *wdev =\n\t\tcontainer_of(work, struct wireless_dev, disconnect_wk);\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\n\twiphy_lock(wdev->wiphy);\n\twdev_lock(wdev);\n\n\tif (wdev->conn_owner_nlportid) {\n\t\tswitch (wdev->iftype) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\t__cfg80211_leave_ibss(rdev, wdev->netdev, false);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\t__cfg80211_stop_ap(rdev, wdev->netdev, -1, false);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\t__cfg80211_leave_mesh(rdev, wdev->netdev);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t\t \n\t\t\tif (rdev->ops->disconnect || wdev->connected)\n\t\t\t\tcfg80211_disconnect(rdev, wdev->netdev,\n\t\t\t\t\t\t    WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t\t\t    true);\n\t\t\telse\n\t\t\t\tcfg80211_mlme_deauth(rdev, wdev->netdev,\n\t\t\t\t\t\t     wdev->disconnect_bssid,\n\t\t\t\t\t\t     NULL, 0,\n\t\t\t\t\t\t     WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t\t\t     false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twdev_unlock(wdev);\n\twiphy_unlock(wdev->wiphy);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}