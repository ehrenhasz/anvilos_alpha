{
  "module_name": "mesh.c",
  "hash_id": "16ce4c9b5e24ded87db1002cd089b95f9cbf9e160fb28fef06a6113c429e36d1",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/mesh.c",
  "human_readable_source": "\n \n#include <linux/ieee80211.h>\n#include <linux/export.h>\n#include <net/cfg80211.h>\n#include \"nl80211.h\"\n#include \"core.h\"\n#include \"rdev-ops.h\"\n\n \n#define MESH_TTL \t\t31\n#define MESH_DEFAULT_ELEMENT_TTL 31\n#define MESH_MAX_RETR\t \t3\n#define MESH_RET_T \t\t100\n#define MESH_CONF_T \t\t100\n#define MESH_HOLD_T \t\t100\n\n#define MESH_PATH_TIMEOUT\t5000\n#define MESH_RANN_INTERVAL      5000\n#define MESH_PATH_TO_ROOT_TIMEOUT      6000\n#define MESH_ROOT_INTERVAL     5000\n#define MESH_ROOT_CONFIRMATION_INTERVAL 2000\n#define MESH_DEFAULT_PLINK_TIMEOUT\t1800  \n\n \n#define MESH_PREQ_MIN_INT\t10\n#define MESH_PERR_MIN_INT\t100\n#define MESH_DIAM_TRAVERSAL_TIME 50\n\n#define MESH_RSSI_THRESHOLD\t0\n\n \n#define MESH_PATH_REFRESH_TIME\t\t\t1000\n#define MESH_MIN_DISCOVERY_TIMEOUT (2 * MESH_DIAM_TRAVERSAL_TIME)\n\n \n#define MESH_MAX_ESTAB_PLINKS\t32\n\n#define MESH_MAX_PREQ_RETRIES\t4\n\n#define MESH_SYNC_NEIGHBOR_OFFSET_MAX 50\n\n#define MESH_DEFAULT_BEACON_INTERVAL\t1000\t \n#define MESH_DEFAULT_DTIM_PERIOD\t2\n#define MESH_DEFAULT_AWAKE_WINDOW\t10\t \n\nconst struct mesh_config default_mesh_config = {\n\t.dot11MeshRetryTimeout = MESH_RET_T,\n\t.dot11MeshConfirmTimeout = MESH_CONF_T,\n\t.dot11MeshHoldingTimeout = MESH_HOLD_T,\n\t.dot11MeshMaxRetries = MESH_MAX_RETR,\n\t.dot11MeshTTL = MESH_TTL,\n\t.element_ttl = MESH_DEFAULT_ELEMENT_TTL,\n\t.auto_open_plinks = true,\n\t.dot11MeshMaxPeerLinks = MESH_MAX_ESTAB_PLINKS,\n\t.dot11MeshNbrOffsetMaxNeighbor = MESH_SYNC_NEIGHBOR_OFFSET_MAX,\n\t.dot11MeshHWMPactivePathTimeout = MESH_PATH_TIMEOUT,\n\t.dot11MeshHWMPpreqMinInterval = MESH_PREQ_MIN_INT,\n\t.dot11MeshHWMPperrMinInterval = MESH_PERR_MIN_INT,\n\t.dot11MeshHWMPnetDiameterTraversalTime = MESH_DIAM_TRAVERSAL_TIME,\n\t.dot11MeshHWMPmaxPREQretries = MESH_MAX_PREQ_RETRIES,\n\t.path_refresh_time = MESH_PATH_REFRESH_TIME,\n\t.min_discovery_timeout = MESH_MIN_DISCOVERY_TIMEOUT,\n\t.dot11MeshHWMPRannInterval = MESH_RANN_INTERVAL,\n\t.dot11MeshGateAnnouncementProtocol = false,\n\t.dot11MeshForwarding = true,\n\t.rssi_threshold = MESH_RSSI_THRESHOLD,\n\t.ht_opmode = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED,\n\t.dot11MeshHWMPactivePathToRootTimeout = MESH_PATH_TO_ROOT_TIMEOUT,\n\t.dot11MeshHWMProotInterval = MESH_ROOT_INTERVAL,\n\t.dot11MeshHWMPconfirmationInterval = MESH_ROOT_CONFIRMATION_INTERVAL,\n\t.power_mode = NL80211_MESH_POWER_ACTIVE,\n\t.dot11MeshAwakeWindowDuration = MESH_DEFAULT_AWAKE_WINDOW,\n\t.plink_timeout = MESH_DEFAULT_PLINK_TIMEOUT,\n\t.dot11MeshNolearn = false,\n};\n\nconst struct mesh_setup default_mesh_setup = {\n\t \n\t.sync_method = IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET,\n\t.path_sel_proto = IEEE80211_PATH_PROTOCOL_HWMP,\n\t.path_metric = IEEE80211_PATH_METRIC_AIRTIME,\n\t.auth_id = 0,  \n\t.ie = NULL,\n\t.ie_len = 0,\n\t.is_secure = false,\n\t.user_mpm = false,\n\t.beacon_interval = MESH_DEFAULT_BEACON_INTERVAL,\n\t.dtim_period = MESH_DEFAULT_DTIM_PERIOD,\n};\n\nint __cfg80211_join_mesh(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *dev,\n\t\t\t struct mesh_setup *setup,\n\t\t\t const struct mesh_config *conf)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err;\n\n\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN != IEEE80211_MAX_MESH_ID_LEN);\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_MESH_AUTH) &&\n\t      setup->is_secure)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->u.mesh.id_len)\n\t\treturn -EALREADY;\n\n\tif (!setup->mesh_id_len)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->join_mesh)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!setup->chandef.chan) {\n\t\t \n\t\tsetup->chandef = wdev->u.mesh.preset_chandef;\n\t}\n\n\tif (!setup->chandef.chan) {\n\t\t \n\t\tenum nl80211_band band;\n\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tstruct ieee80211_supported_band *sband;\n\t\t\tstruct ieee80211_channel *chan;\n\t\t\tint i;\n\n\t\t\tsband = rdev->wiphy.bands[band];\n\t\t\tif (!sband)\n\t\t\t\tcontinue;\n\n\t\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\t\tchan = &sband->channels[i];\n\t\t\t\tif (chan->flags & (IEEE80211_CHAN_NO_IR |\n\t\t\t\t\t\t   IEEE80211_CHAN_DISABLED |\n\t\t\t\t\t\t   IEEE80211_CHAN_RADAR))\n\t\t\t\t\tcontinue;\n\t\t\t\tsetup->chandef.chan = chan;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (setup->chandef.chan)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!setup->chandef.chan)\n\t\t\treturn -EINVAL;\n\n\t\tsetup->chandef.width = NL80211_CHAN_WIDTH_20_NOHT;\n\t\tsetup->chandef.center_freq1 = setup->chandef.chan->center_freq;\n\t}\n\n\t \n\tif (!setup->basic_rates) {\n\t\tenum nl80211_bss_scan_width scan_width;\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\t\trdev->wiphy.bands[setup->chandef.chan->band];\n\n\t\tif (setup->chandef.chan->band == NL80211_BAND_2GHZ) {\n\t\t\tint i;\n\n\t\t\t \n\t\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\t\tif (sband->bitrates[i].bitrate == 10) {\n\t\t\t\t\tsetup->basic_rates = BIT(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tscan_width = cfg80211_chandef_to_scan_width(&setup->chandef);\n\t\t\tsetup->basic_rates = ieee80211_mandatory_rates(sband,\n\t\t\t\t\t\t\t\t       scan_width);\n\t\t}\n\t}\n\n\terr = cfg80211_chandef_dfs_required(&rdev->wiphy,\n\t\t\t\t\t    &setup->chandef,\n\t\t\t\t\t    NL80211_IFTYPE_MESH_POINT);\n\tif (err < 0)\n\t\treturn err;\n\tif (err > 0 && !setup->userspace_handles_dfs)\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_reg_can_beacon(&rdev->wiphy, &setup->chandef,\n\t\t\t\t     NL80211_IFTYPE_MESH_POINT))\n\t\treturn -EINVAL;\n\n\terr = rdev_join_mesh(rdev, dev, conf, setup);\n\tif (!err) {\n\t\tmemcpy(wdev->u.mesh.id, setup->mesh_id, setup->mesh_id_len);\n\t\twdev->u.mesh.id_len = setup->mesh_id_len;\n\t\twdev->u.mesh.chandef = setup->chandef;\n\t\twdev->u.mesh.beacon_interval = setup->beacon_interval;\n\t}\n\n\treturn err;\n}\n\nint cfg80211_set_mesh_channel(struct cfg80211_registered_device *rdev,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      struct cfg80211_chan_def *chandef)\n{\n\tint err;\n\n\t \n\tif (rdev->ops->libertas_set_mesh_channel) {\n\t\tif (chandef->width != NL80211_CHAN_WIDTH_20_NOHT)\n\t\t\treturn -EINVAL;\n\n\t\tif (!netif_running(wdev->netdev))\n\t\t\treturn -ENETDOWN;\n\n\t\terr = rdev_libertas_set_mesh_channel(rdev, wdev->netdev,\n\t\t\t\t\t\t     chandef->chan);\n\t\tif (!err)\n\t\t\twdev->u.mesh.chandef = *chandef;\n\n\t\treturn err;\n\t}\n\n\tif (wdev->u.mesh.id_len)\n\t\treturn -EBUSY;\n\n\twdev->u.mesh.preset_chandef = *chandef;\n\treturn 0;\n}\n\nint __cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,\n\t\t\t  struct net_device *dev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->leave_mesh)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev->u.mesh.id_len)\n\t\treturn -ENOTCONN;\n\n\terr = rdev_leave_mesh(rdev, dev);\n\tif (!err) {\n\t\twdev->conn_owner_nlportid = 0;\n\t\twdev->u.mesh.id_len = 0;\n\t\twdev->u.mesh.beacon_interval = 0;\n\t\tmemset(&wdev->u.mesh.chandef, 0,\n\t\t       sizeof(wdev->u.mesh.chandef));\n\t\trdev_set_qos_map(rdev, dev, NULL);\n\t\tcfg80211_sched_dfs_chan_update(rdev);\n\t}\n\n\treturn err;\n}\n\nint cfg80211_leave_mesh(struct cfg80211_registered_device *rdev,\n\t\t\tstruct net_device *dev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err;\n\n\twdev_lock(wdev);\n\terr = __cfg80211_leave_mesh(rdev, dev);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}