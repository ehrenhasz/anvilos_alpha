{
  "module_name": "nl80211.c",
  "hash_id": "49da0f1554a8a78139552e2e2203983c6625fc3f9b455f05e991d4ffd44b532a",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/nl80211.c",
  "human_readable_source": "\n \n\n#include <linux/if.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/if_ether.h>\n#include <linux/ieee80211.h>\n#include <linux/nl80211.h>\n#include <linux/rtnetlink.h>\n#include <linux/netlink.h>\n#include <linux/nospec.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <net/net_namespace.h>\n#include <net/genetlink.h>\n#include <net/cfg80211.h>\n#include <net/sock.h>\n#include <net/inet_connection_sock.h>\n#include \"core.h\"\n#include \"nl80211.h\"\n#include \"reg.h\"\n#include \"rdev-ops.h\"\n\nstatic int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct genl_info *info,\n\t\t\t\t   struct cfg80211_crypto_settings *settings,\n\t\t\t\t   int cipher_limit);\n\n \nstatic struct genl_family nl80211_fam;\n\n \nenum nl80211_multicast_groups {\n\tNL80211_MCGRP_CONFIG,\n\tNL80211_MCGRP_SCAN,\n\tNL80211_MCGRP_REGULATORY,\n\tNL80211_MCGRP_MLME,\n\tNL80211_MCGRP_VENDOR,\n\tNL80211_MCGRP_NAN,\n\tNL80211_MCGRP_TESTMODE  \n};\n\nstatic const struct genl_multicast_group nl80211_mcgrps[] = {\n\t[NL80211_MCGRP_CONFIG] = { .name = NL80211_MULTICAST_GROUP_CONFIG },\n\t[NL80211_MCGRP_SCAN] = { .name = NL80211_MULTICAST_GROUP_SCAN },\n\t[NL80211_MCGRP_REGULATORY] = { .name = NL80211_MULTICAST_GROUP_REG },\n\t[NL80211_MCGRP_MLME] = { .name = NL80211_MULTICAST_GROUP_MLME },\n\t[NL80211_MCGRP_VENDOR] = { .name = NL80211_MULTICAST_GROUP_VENDOR },\n\t[NL80211_MCGRP_NAN] = { .name = NL80211_MULTICAST_GROUP_NAN },\n#ifdef CONFIG_NL80211_TESTMODE\n\t[NL80211_MCGRP_TESTMODE] = { .name = NL80211_MULTICAST_GROUP_TESTMODE }\n#endif\n};\n\n \nstatic struct wireless_dev *\n__cfg80211_wdev_from_attrs(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net *netns, struct nlattr **attrs)\n{\n\tstruct wireless_dev *result = NULL;\n\tbool have_ifidx = attrs[NL80211_ATTR_IFINDEX];\n\tbool have_wdev_id = attrs[NL80211_ATTR_WDEV];\n\tu64 wdev_id = 0;\n\tint wiphy_idx = -1;\n\tint ifidx = -1;\n\n\tif (!have_ifidx && !have_wdev_id)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (have_ifidx)\n\t\tifidx = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\tif (have_wdev_id) {\n\t\twdev_id = nla_get_u64(attrs[NL80211_ATTR_WDEV]);\n\t\twiphy_idx = wdev_id >> 32;\n\t}\n\n\tif (rdev) {\n\t\tstruct wireless_dev *wdev;\n\n\t\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (have_ifidx && wdev->netdev &&\n\t\t\t    wdev->netdev->ifindex == ifidx) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (have_wdev_id && wdev->identifier == (u32)wdev_id) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result ?: ERR_PTR(-ENODEV);\n\t}\n\n\tASSERT_RTNL();\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tstruct wireless_dev *wdev;\n\n\t\tif (wiphy_net(&rdev->wiphy) != netns)\n\t\t\tcontinue;\n\n\t\tif (have_wdev_id && rdev->wiphy_idx != wiphy_idx)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (have_ifidx && wdev->netdev &&\n\t\t\t    wdev->netdev->ifindex == ifidx) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (have_wdev_id && wdev->identifier == (u32)wdev_id) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (result)\n\t\t\tbreak;\n\t}\n\n\tif (result)\n\t\treturn result;\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic struct cfg80211_registered_device *\n__cfg80211_rdev_from_attrs(struct net *netns, struct nlattr **attrs)\n{\n\tstruct cfg80211_registered_device *rdev = NULL, *tmp;\n\tstruct net_device *netdev;\n\n\tASSERT_RTNL();\n\n\tif (!attrs[NL80211_ATTR_WIPHY] &&\n\t    !attrs[NL80211_ATTR_IFINDEX] &&\n\t    !attrs[NL80211_ATTR_WDEV])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_WIPHY])\n\t\trdev = cfg80211_rdev_by_wiphy_idx(\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_WIPHY]));\n\n\tif (attrs[NL80211_ATTR_WDEV]) {\n\t\tu64 wdev_id = nla_get_u64(attrs[NL80211_ATTR_WDEV]);\n\t\tstruct wireless_dev *wdev;\n\t\tbool found = false;\n\n\t\ttmp = cfg80211_rdev_by_wiphy_idx(wdev_id >> 32);\n\t\tif (tmp) {\n\t\t\t \n\t\t\tlist_for_each_entry(wdev, &tmp->wiphy.wdev_list, list) {\n\t\t\t\tif (wdev->identifier != (u32)wdev_id)\n\t\t\t\t\tcontinue;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!found)\n\t\t\t\ttmp = NULL;\n\n\t\t\tif (rdev && tmp != rdev)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\trdev = tmp;\n\t\t}\n\t}\n\n\tif (attrs[NL80211_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(netns, ifindex);\n\t\tif (netdev) {\n\t\t\tif (netdev->ieee80211_ptr)\n\t\t\t\ttmp = wiphy_to_rdev(\n\t\t\t\t\tnetdev->ieee80211_ptr->wiphy);\n\t\t\telse\n\t\t\t\ttmp = NULL;\n\n\t\t\t \n\t\t\tif (!tmp)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\t \n\t\t\tif (rdev && tmp != rdev)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\trdev = tmp;\n\t\t}\n\t}\n\n\tif (!rdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (netns != wiphy_net(&rdev->wiphy))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn rdev;\n}\n\n \nstatic struct cfg80211_registered_device *\ncfg80211_get_dev_from_info(struct net *netns, struct genl_info *info)\n{\n\treturn __cfg80211_rdev_from_attrs(netns, info->attrs);\n}\n\nstatic int validate_beacon_head(const struct nlattr *attr,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst u8 *data = nla_data(attr);\n\tunsigned int len = nla_len(attr);\n\tconst struct element *elem;\n\tconst struct ieee80211_mgmt *mgmt = (void *)data;\n\tunsigned int fixedlen, hdrlen;\n\tbool s1g_bcn;\n\n\tif (len < offsetofend(typeof(*mgmt), frame_control))\n\t\tgoto err;\n\n\ts1g_bcn = ieee80211_is_s1g_beacon(mgmt->frame_control);\n\tif (s1g_bcn) {\n\t\tfixedlen = offsetof(struct ieee80211_ext,\n\t\t\t\t    u.s1g_beacon.variable);\n\t\thdrlen = offsetof(struct ieee80211_ext, u.s1g_beacon);\n\t} else {\n\t\tfixedlen = offsetof(struct ieee80211_mgmt,\n\t\t\t\t    u.beacon.variable);\n\t\thdrlen = offsetof(struct ieee80211_mgmt, u.beacon);\n\t}\n\n\tif (len < fixedlen)\n\t\tgoto err;\n\n\tif (ieee80211_hdrlen(mgmt->frame_control) != hdrlen)\n\t\tgoto err;\n\n\tdata += fixedlen;\n\tlen -= fixedlen;\n\n\tfor_each_element(elem, data, len) {\n\t\t \n\t}\n\n\tif (for_each_element_completed(elem, data, len))\n\t\treturn 0;\n\nerr:\n\tNL_SET_ERR_MSG_ATTR(extack, attr, \"malformed beacon head\");\n\treturn -EINVAL;\n}\n\nstatic int validate_ie_attr(const struct nlattr *attr,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tconst u8 *data = nla_data(attr);\n\tunsigned int len = nla_len(attr);\n\tconst struct element *elem;\n\n\tfor_each_element(elem, data, len) {\n\t\t \n\t}\n\n\tif (for_each_element_completed(elem, data, len))\n\t\treturn 0;\n\n\tNL_SET_ERR_MSG_ATTR(extack, attr, \"malformed information elements\");\n\treturn -EINVAL;\n}\n\nstatic int validate_he_capa(const struct nlattr *attr,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (!ieee80211_he_capa_size_ok(nla_data(attr), nla_len(attr)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic const struct nla_policy nl80211_policy[NUM_NL80211_ATTR];\n\nstatic const struct nla_policy\nnl80211_ftm_responder_policy[NL80211_FTM_RESP_ATTR_MAX + 1] = {\n\t[NL80211_FTM_RESP_ATTR_ENABLED] = { .type = NLA_FLAG, },\n\t[NL80211_FTM_RESP_ATTR_LCI] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = U8_MAX },\n\t[NL80211_FTM_RESP_ATTR_CIVICLOC] = { .type = NLA_BINARY,\n\t\t\t\t\t     .len = U8_MAX },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_ftm_req_attr_policy[NL80211_PMSR_FTM_REQ_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_FTM_REQ_ATTR_ASAP] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE] = { .type = NLA_U32 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP] =\n\t\tNLA_POLICY_MAX(NLA_U8, 15),\n\t[NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD] = { .type = NLA_U16 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION] =\n\t\tNLA_POLICY_MAX(NLA_U8, 15),\n\t[NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST] =\n\t\tNLA_POLICY_MAX(NLA_U8, 31),\n\t[NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_LMR_FEEDBACK] = { .type = NLA_FLAG },\n\t[NL80211_PMSR_FTM_REQ_ATTR_BSS_COLOR] = { .type = NLA_U8 },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_req_data_policy[NL80211_PMSR_TYPE_MAX + 1] = {\n\t[NL80211_PMSR_TYPE_FTM] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_ftm_req_attr_policy),\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_req_attr_policy[NL80211_PMSR_REQ_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_REQ_ATTR_DATA] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_req_data_policy),\n\t[NL80211_PMSR_REQ_ATTR_GET_AP_TSF] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_peer_attr_policy[NL80211_PMSR_PEER_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_PEER_ATTR_ADDR] = NLA_POLICY_ETH_ADDR,\n\t[NL80211_PMSR_PEER_ATTR_CHAN] = NLA_POLICY_NESTED(nl80211_policy),\n\t[NL80211_PMSR_PEER_ATTR_REQ] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_req_attr_policy),\n\t[NL80211_PMSR_PEER_ATTR_RESP] = { .type = NLA_REJECT },\n};\n\nstatic const struct nla_policy\nnl80211_pmsr_attr_policy[NL80211_PMSR_ATTR_MAX + 1] = {\n\t[NL80211_PMSR_ATTR_MAX_PEERS] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_REPORT_AP_TSF] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_TYPE_CAPA] = { .type = NLA_REJECT },\n\t[NL80211_PMSR_ATTR_PEERS] =\n\t\tNLA_POLICY_NESTED_ARRAY(nl80211_pmsr_peer_attr_policy),\n};\n\nstatic const struct nla_policy\nhe_obss_pd_policy[NL80211_HE_OBSS_PD_ATTR_MAX + 1] = {\n\t[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n\t[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n\t[NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 1, 20),\n\t[NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP] =\n\t\tNLA_POLICY_EXACT_LEN(8),\n\t[NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP] =\n\t\tNLA_POLICY_EXACT_LEN(8),\n\t[NL80211_HE_OBSS_PD_ATTR_SR_CTRL] = { .type = NLA_U8 },\n};\n\nstatic const struct nla_policy\nhe_bss_color_policy[NL80211_HE_BSS_COLOR_ATTR_MAX + 1] = {\n\t[NL80211_HE_BSS_COLOR_ATTR_COLOR] = NLA_POLICY_RANGE(NLA_U8, 1, 63),\n\t[NL80211_HE_BSS_COLOR_ATTR_DISABLED] = { .type = NLA_FLAG },\n\t[NL80211_HE_BSS_COLOR_ATTR_PARTIAL] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy nl80211_txattr_policy[NL80211_TXRATE_MAX + 1] = {\n\t[NL80211_TXRATE_LEGACY] = { .type = NLA_BINARY,\n\t\t\t\t    .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_TXRATE_HT] = { .type = NLA_BINARY,\n\t\t\t\t.len = NL80211_MAX_SUPP_HT_RATES },\n\t[NL80211_TXRATE_VHT] = NLA_POLICY_EXACT_LEN_WARN(sizeof(struct nl80211_txrate_vht)),\n\t[NL80211_TXRATE_GI] = { .type = NLA_U8 },\n\t[NL80211_TXRATE_HE] = NLA_POLICY_EXACT_LEN(sizeof(struct nl80211_txrate_he)),\n\t[NL80211_TXRATE_HE_GI] =  NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\t   NL80211_RATE_INFO_HE_GI_0_8,\n\t\t\t\t\t\t   NL80211_RATE_INFO_HE_GI_3_2),\n\t[NL80211_TXRATE_HE_LTF] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\t   NL80211_RATE_INFO_HE_1XLTF,\n\t\t\t\t\t\t   NL80211_RATE_INFO_HE_4XLTF),\n};\n\nstatic const struct nla_policy\nnl80211_tid_config_attr_policy[NL80211_TID_CONFIG_ATTR_MAX + 1] = {\n\t[NL80211_TID_CONFIG_ATTR_VIF_SUPP] = { .type = NLA_U64 },\n\t[NL80211_TID_CONFIG_ATTR_PEER_SUPP] = { .type = NLA_U64 },\n\t[NL80211_TID_CONFIG_ATTR_OVERRIDE] = { .type = NLA_FLAG },\n\t[NL80211_TID_CONFIG_ATTR_TIDS] = NLA_POLICY_RANGE(NLA_U16, 1, 0xff),\n\t[NL80211_TID_CONFIG_ATTR_NOACK] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),\n\t[NL80211_TID_CONFIG_ATTR_RETRY_SHORT] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_TID_CONFIG_ATTR_RETRY_LONG] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_TID_CONFIG_ATTR_AMPDU_CTRL] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),\n\t[NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),\n\t[NL80211_TID_CONFIG_ATTR_AMSDU_CTRL] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TID_CONFIG_DISABLE),\n\t[NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE] =\n\t\t\tNLA_POLICY_MAX(NLA_U8, NL80211_TX_RATE_FIXED),\n\t[NL80211_TID_CONFIG_ATTR_TX_RATE] =\n\t\t\tNLA_POLICY_NESTED(nl80211_txattr_policy),\n};\n\nstatic const struct nla_policy\nnl80211_fils_discovery_policy[NL80211_FILS_DISCOVERY_ATTR_MAX + 1] = {\n\t[NL80211_FILS_DISCOVERY_ATTR_INT_MIN] = NLA_POLICY_MAX(NLA_U32, 10000),\n\t[NL80211_FILS_DISCOVERY_ATTR_INT_MAX] = NLA_POLICY_MAX(NLA_U32, 10000),\n\t[NL80211_FILS_DISCOVERY_ATTR_TMPL] =\n\t\t\tNLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t\t NL80211_FILS_DISCOVERY_TMPL_MIN_LEN,\n\t\t\t\t\t IEEE80211_MAX_DATA_LEN),\n};\n\nstatic const struct nla_policy\nnl80211_unsol_bcast_probe_resp_policy[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX + 1] = {\n\t[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT] = NLA_POLICY_MAX(NLA_U32, 20),\n\t[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL] = { .type = NLA_BINARY,\n\t\t\t\t\t\t       .len = IEEE80211_MAX_DATA_LEN }\n};\n\nstatic const struct nla_policy\nsar_specs_policy[NL80211_SAR_ATTR_SPECS_MAX + 1] = {\n\t[NL80211_SAR_ATTR_SPECS_POWER] = { .type = NLA_S32 },\n\t[NL80211_SAR_ATTR_SPECS_RANGE_INDEX] = {.type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nsar_policy[NL80211_SAR_ATTR_MAX + 1] = {\n\t[NL80211_SAR_ATTR_TYPE] = NLA_POLICY_MAX(NLA_U32, NUM_NL80211_SAR_TYPE),\n\t[NL80211_SAR_ATTR_SPECS] = NLA_POLICY_NESTED_ARRAY(sar_specs_policy),\n};\n\nstatic const struct nla_policy\nnl80211_mbssid_config_policy[NL80211_MBSSID_CONFIG_ATTR_MAX + 1] = {\n\t[NL80211_MBSSID_CONFIG_ATTR_MAX_INTERFACES] = NLA_POLICY_MIN(NLA_U8, 2),\n\t[NL80211_MBSSID_CONFIG_ATTR_MAX_EMA_PROFILE_PERIODICITY] =\n\t\t\t\t\t\tNLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_MBSSID_CONFIG_ATTR_INDEX] = { .type = NLA_U8 },\n\t[NL80211_MBSSID_CONFIG_ATTR_TX_IFINDEX] = { .type = NLA_U32 },\n\t[NL80211_MBSSID_CONFIG_ATTR_EMA] = { .type = NLA_FLAG },\n};\n\nstatic const struct nla_policy\nnl80211_sta_wme_policy[NL80211_STA_WME_MAX + 1] = {\n\t[NL80211_STA_WME_UAPSD_QUEUES] = { .type = NLA_U8 },\n\t[NL80211_STA_WME_MAX_SP] = { .type = NLA_U8 },\n};\n\nstatic struct netlink_range_validation nl80211_punct_bitmap_range = {\n\t.min = 0,\n\t.max = 0xffff,\n};\n\nstatic const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {\n\t[0] = { .strict_start_type = NL80211_ATTR_HE_OBSS_PD },\n\t[NL80211_ATTR_WIPHY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_NAME] = { .type = NLA_NUL_STRING,\n\t\t\t\t      .len = 20-1 },\n\t[NL80211_ATTR_WIPHY_TXQ_PARAMS] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_WIPHY_FREQ] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_CHANNEL_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_EDMG_CHANNELS] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\tNL80211_EDMG_CHANNELS_MIN,\n\t\t\t\t\t\tNL80211_EDMG_CHANNELS_MAX),\n\t[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG] = NLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t\t\tNL80211_EDMG_BW_CONFIG_MIN,\n\t\t\t\t\t\tNL80211_EDMG_BW_CONFIG_MAX),\n\n\t[NL80211_ATTR_CHANNEL_WIDTH] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CENTER_FREQ1] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CENTER_FREQ1_OFFSET] = NLA_POLICY_RANGE(NLA_U32, 0, 999),\n\t[NL80211_ATTR_CENTER_FREQ2] = { .type = NLA_U32 },\n\n\t[NL80211_ATTR_WIPHY_RETRY_SHORT] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_WIPHY_RETRY_LONG] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_WIPHY_FRAG_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_RTS_THRESHOLD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_COVERAGE_CLASS] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_DYN_ACK] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_IFTYPE] = NLA_POLICY_MAX(NLA_U32, NL80211_IFTYPE_MAX),\n\t[NL80211_ATTR_IFINDEX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_IFNAME] = { .type = NLA_NUL_STRING, .len = IFNAMSIZ-1 },\n\n\t[NL80211_ATTR_MAC] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_PREV_BSSID] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\n\t[NL80211_ATTR_KEY] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_KEY_DATA] = { .type = NLA_BINARY,\n\t\t\t\t    .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_ATTR_KEY_IDX] = NLA_POLICY_MAX(NLA_U8, 7),\n\t[NL80211_ATTR_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_ATTR_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_SEQ] = { .type = NLA_BINARY, .len = 16 },\n\t[NL80211_ATTR_KEY_TYPE] =\n\t\tNLA_POLICY_MAX(NLA_U32, NUM_NL80211_KEYTYPES),\n\n\t[NL80211_ATTR_BEACON_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_DTIM_PERIOD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_BEACON_HEAD] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_beacon_head,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_BEACON_TAIL] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_STA_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_STA_FLAGS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_LISTEN_INTERVAL] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_SUPPORTED_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t       .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_STA_PLINK_ACTION] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_PLINK_ACTIONS - 1),\n\t[NL80211_ATTR_STA_TX_POWER_SETTING] =\n\t\tNLA_POLICY_RANGE(NLA_U8,\n\t\t\t\t NL80211_TX_POWER_AUTOMATIC,\n\t\t\t\t NL80211_TX_POWER_FIXED),\n\t[NL80211_ATTR_STA_TX_POWER] = { .type = NLA_S16 },\n\t[NL80211_ATTR_STA_VLAN] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MNTR_FLAGS] = {   },\n\t[NL80211_ATTR_MESH_ID] = { .type = NLA_BINARY,\n\t\t\t\t   .len = IEEE80211_MAX_MESH_ID_LEN },\n\t[NL80211_ATTR_MPATH_NEXT_HOP] = NLA_POLICY_ETH_ADDR_COMPAT,\n\n\t \n\t[NL80211_ATTR_REG_ALPHA2] = NLA_POLICY_RANGE(NLA_BINARY, 2, 3),\n\t[NL80211_ATTR_REG_RULES] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_BSS_CTS_PROT] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_PREAMBLE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_SHORT_SLOT_TIME] = { .type = NLA_U8 },\n\t[NL80211_ATTR_BSS_BASIC_RATES] = { .type = NLA_BINARY,\n\t\t\t\t\t   .len = NL80211_MAX_SUPP_RATES },\n\t[NL80211_ATTR_BSS_HT_OPMODE] = { .type = NLA_U16 },\n\n\t[NL80211_ATTR_MESH_CONFIG] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SUPPORT_MESH_AUTH] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_HT_CAPABILITY] = NLA_POLICY_EXACT_LEN_WARN(NL80211_HT_CAPABILITY_LEN),\n\n\t[NL80211_ATTR_MGMT_SUBTYPE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_IE] = NLA_POLICY_VALIDATE_FN(NLA_BINARY,\n\t\t\t\t\t\t   validate_ie_attr,\n\t\t\t\t\t\t   IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_SCAN_FREQUENCIES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SCAN_SSIDS] = { .type = NLA_NESTED },\n\n\t[NL80211_ATTR_SSID] = { .type = NLA_BINARY,\n\t\t\t\t.len = IEEE80211_MAX_SSID_LEN },\n\t[NL80211_ATTR_AUTH_TYPE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REASON_CODE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_FREQ_FIXED] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TIMED_OUT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_USE_MFP] = NLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t\t\t  NL80211_MFP_NO,\n\t\t\t\t\t\t  NL80211_MFP_OPTIONAL),\n\t[NL80211_ATTR_STA_FLAGS2] =\n\t\tNLA_POLICY_EXACT_LEN_WARN(sizeof(struct nl80211_sta_flag_update)),\n\t[NL80211_ATTR_CONTROL_PORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CONTROL_PORT_ETHERTYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CONTROL_PORT_OVER_NL80211] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PRIVACY] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_STATUS_CODE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_CIPHER_SUITE_GROUP] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WPA_VERSIONS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_PID] = { .type = NLA_U32 },\n\t[NL80211_ATTR_4ADDR] = { .type = NLA_U8 },\n\t[NL80211_ATTR_PMKID] = NLA_POLICY_EXACT_LEN_WARN(WLAN_PMKID_LEN),\n\t[NL80211_ATTR_DURATION] = { .type = NLA_U32 },\n\t[NL80211_ATTR_COOKIE] = { .type = NLA_U64 },\n\t[NL80211_ATTR_TX_RATES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_FRAME] = { .type = NLA_BINARY,\n\t\t\t\t .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_FRAME_MATCH] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_PS_STATE] = NLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t\t\t   NL80211_PS_DISABLED,\n\t\t\t\t\t\t   NL80211_PS_ENABLED),\n\t[NL80211_ATTR_CQM] = { .type = NLA_NESTED, },\n\t[NL80211_ATTR_LOCAL_STATE_CHANGE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_AP_ISOLATE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_SETTING] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_FRAME_TYPE] = { .type = NLA_U16 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_TX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_WIPHY_ANTENNA_RX] = { .type = NLA_U32 },\n\t[NL80211_ATTR_MCAST_RATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_OFFCHANNEL_TX_OK] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_WOWLAN_TRIGGERS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_PLINK_STATE] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_PLINK_STATES - 1),\n\t[NL80211_ATTR_MEASUREMENT_DURATION] = { .type = NLA_U16 },\n\t[NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_MESH_PEER_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_SCHED_SCAN_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REKEY_DATA] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_SCAN_SUPP_RATES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_HIDDEN_SSID] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_HIDDEN_SSID_NOT_IN_USE,\n\t\t\t\t NL80211_HIDDEN_SSID_ZERO_CONTENTS),\n\t[NL80211_ATTR_IE_PROBE_RESP] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_IE_ASSOC_RESP] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_ATTR_ROAM_SUPPORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_STA_WME] = NLA_POLICY_NESTED(nl80211_sta_wme_policy),\n\t[NL80211_ATTR_SCHED_SCAN_MATCH] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_TX_NO_CCK_RATE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_ACTION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_DIALOG_TOKEN] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_OPERATION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_TDLS_SUPPORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_EXTERNAL_SETUP] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TDLS_INITIATOR] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_DONT_WAIT_FOR_ACK] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PROBE_RESP] = { .type = NLA_BINARY,\n\t\t\t\t      .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_DFS_REGION] = { .type = NLA_U8 },\n\t[NL80211_ATTR_DISABLE_HT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_HT_CAPABILITY_MASK] = {\n\t\t.len = NL80211_HT_CAPABILITY_LEN\n\t},\n\t[NL80211_ATTR_NOACK_MAP] = { .type = NLA_U16 },\n\t[NL80211_ATTR_INACTIVITY_TIMEOUT] = { .type = NLA_U16 },\n\t[NL80211_ATTR_BG_SCAN_PERIOD] = { .type = NLA_U16 },\n\t[NL80211_ATTR_WDEV] = { .type = NLA_U64 },\n\t[NL80211_ATTR_USER_REG_HINT_TYPE] = { .type = NLA_U32 },\n\n\t \n\t[NL80211_ATTR_AUTH_DATA] = NLA_POLICY_MIN_LEN(4),\n\n\t[NL80211_ATTR_VHT_CAPABILITY] = NLA_POLICY_EXACT_LEN_WARN(NL80211_VHT_CAPABILITY_LEN),\n\t[NL80211_ATTR_SCAN_FLAGS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_P2P_CTWINDOW] = NLA_POLICY_MAX(NLA_U8, 127),\n\t[NL80211_ATTR_P2P_OPPPS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_ATTR_LOCAL_MESH_POWER_MODE] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_MESH_POWER_UNKNOWN + 1,\n\t\t\t\t NL80211_MESH_POWER_MAX),\n\t[NL80211_ATTR_ACL_POLICY] = {. type = NLA_U32 },\n\t[NL80211_ATTR_MAC_ADDRS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_CAPABILITY] = { .type = NLA_U16 },\n\t[NL80211_ATTR_STA_EXT_CAPABILITY] = { .type = NLA_BINARY, },\n\t[NL80211_ATTR_SPLIT_WIPHY_DUMP] = { .type = NLA_FLAG, },\n\t[NL80211_ATTR_DISABLE_VHT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_VHT_CAPABILITY_MASK] = {\n\t\t.len = NL80211_VHT_CAPABILITY_LEN,\n\t},\n\t[NL80211_ATTR_MDID] = { .type = NLA_U16 },\n\t[NL80211_ATTR_IE_RIC] = { .type = NLA_BINARY,\n\t\t\t\t  .len = IEEE80211_MAX_DATA_LEN },\n\t[NL80211_ATTR_CRIT_PROT_ID] = { .type = NLA_U16 },\n\t[NL80211_ATTR_MAX_CRIT_PROT_DURATION] =\n\t\tNLA_POLICY_MAX(NLA_U16, NL80211_CRIT_PROTO_MAX_DURATION),\n\t[NL80211_ATTR_PEER_AID] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, IEEE80211_MAX_AID),\n\t[NL80211_ATTR_CH_SWITCH_COUNT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CH_SWITCH_BLOCK_TX] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CSA_IES] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_CNTDWN_OFFS_BEACON] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_CNTDWN_OFFS_PRESP] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_STA_SUPPORTED_CHANNELS] = NLA_POLICY_MIN_LEN(2),\n\t \n\t[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES] =\n\t\tNLA_POLICY_RANGE(NLA_BINARY, 2, 253),\n\t[NL80211_ATTR_HANDLE_DFS] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_OPMODE_NOTIF] = { .type = NLA_U8 },\n\t[NL80211_ATTR_VENDOR_ID] = { .type = NLA_U32 },\n\t[NL80211_ATTR_VENDOR_SUBCMD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_QOS_MAP] = NLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t\t\t  IEEE80211_QOS_MAP_LEN_MIN,\n\t\t\t\t\t\t  IEEE80211_QOS_MAP_LEN_MAX),\n\t[NL80211_ATTR_MAC_HINT] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_WIPHY_FREQ_HINT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TDLS_PEER_CAPABILITY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_SOCKET_OWNER] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_CSA_C_OFFSETS_TX] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_USE_RRM] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_TSID] = NLA_POLICY_MAX(NLA_U8, IEEE80211_NUM_TIDS - 1),\n\t[NL80211_ATTR_USER_PRIO] =\n\t\tNLA_POLICY_MAX(NLA_U8, IEEE80211_NUM_UPS - 1),\n\t[NL80211_ATTR_ADMITTED_TIME] = { .type = NLA_U16 },\n\t[NL80211_ATTR_SMPS_MODE] = { .type = NLA_U8 },\n\t[NL80211_ATTR_OPER_CLASS] = { .type = NLA_U8 },\n\t[NL80211_ATTR_MAC_MASK] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_WIPHY_SELF_MANAGED_REG] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_NETNS_FD] = { .type = NLA_U32 },\n\t[NL80211_ATTR_SCHED_SCAN_DELAY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_REG_INDOOR] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PBSS] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_BSS_SELECT] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_STA_SUPPORT_P2P_PS] =\n\t\tNLA_POLICY_MAX(NLA_U8, NUM_NL80211_P2P_PS_STATUS - 1),\n\t[NL80211_ATTR_MU_MIMO_GROUP_DATA] = {\n\t\t.len = VHT_MUMIMO_GROUPS_DATA_LEN\n\t},\n\t[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_NAN_MASTER_PREF] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_ATTR_BANDS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_NAN_FUNC] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_FILS_KEK] = { .type = NLA_BINARY,\n\t\t\t\t    .len = FILS_MAX_KEK_LEN },\n\t[NL80211_ATTR_FILS_NONCES] = NLA_POLICY_EXACT_LEN_WARN(2 * FILS_NONCE_LEN),\n\t[NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED] = { .type = NLA_FLAG, },\n\t[NL80211_ATTR_BSSID] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI] = { .type = NLA_S8 },\n\t[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST] = {\n\t\t.len = sizeof(struct nl80211_bss_select_rssi_adjust)\n\t},\n\t[NL80211_ATTR_TIMEOUT_REASON] = { .type = NLA_U32 },\n\t[NL80211_ATTR_FILS_ERP_USERNAME] = { .type = NLA_BINARY,\n\t\t\t\t\t     .len = FILS_ERP_MAX_USERNAME_LEN },\n\t[NL80211_ATTR_FILS_ERP_REALM] = { .type = NLA_BINARY,\n\t\t\t\t\t  .len = FILS_ERP_MAX_REALM_LEN },\n\t[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] = { .type = NLA_U16 },\n\t[NL80211_ATTR_FILS_ERP_RRK] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = FILS_ERP_MAX_RRK_LEN },\n\t[NL80211_ATTR_FILS_CACHE_ID] = NLA_POLICY_EXACT_LEN_WARN(2),\n\t[NL80211_ATTR_PMK] = { .type = NLA_BINARY, .len = PMK_MAX_LEN },\n\t[NL80211_ATTR_PMKR0_NAME] = NLA_POLICY_EXACT_LEN(WLAN_PMK_NAME_LEN),\n\t[NL80211_ATTR_SCHED_SCAN_MULTI] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT] = { .type = NLA_FLAG },\n\n\t[NL80211_ATTR_TXQ_LIMIT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TXQ_MEMORY_LIMIT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_TXQ_QUANTUM] = { .type = NLA_U32 },\n\t[NL80211_ATTR_HE_CAPABILITY] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_he_capa,\n\t\t\t\t       NL80211_HE_MAX_CAPABILITY_LEN),\n\t[NL80211_ATTR_FTM_RESPONDER] =\n\t\tNLA_POLICY_NESTED(nl80211_ftm_responder_policy),\n\t[NL80211_ATTR_TIMEOUT] = NLA_POLICY_MIN(NLA_U32, 1),\n\t[NL80211_ATTR_PEER_MEASUREMENTS] =\n\t\tNLA_POLICY_NESTED(nl80211_pmsr_attr_policy),\n\t[NL80211_ATTR_AIRTIME_WEIGHT] = NLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_ATTR_SAE_PASSWORD] = { .type = NLA_BINARY,\n\t\t\t\t\t.len = SAE_PASSWORD_MAX_LEN },\n\t[NL80211_ATTR_TWT_RESPONDER] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_HE_OBSS_PD] = NLA_POLICY_NESTED(he_obss_pd_policy),\n\t[NL80211_ATTR_VLAN_ID] = NLA_POLICY_RANGE(NLA_U16, 1, VLAN_N_VID - 2),\n\t[NL80211_ATTR_HE_BSS_COLOR] = NLA_POLICY_NESTED(he_bss_color_policy),\n\t[NL80211_ATTR_TID_CONFIG] =\n\t\tNLA_POLICY_NESTED_ARRAY(nl80211_tid_config_attr_policy),\n\t[NL80211_ATTR_CONTROL_PORT_NO_PREAUTH] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_PMK_LIFETIME] = NLA_POLICY_MIN(NLA_U32, 1),\n\t[NL80211_ATTR_PMK_REAUTH_THRESHOLD] = NLA_POLICY_RANGE(NLA_U8, 1, 100),\n\t[NL80211_ATTR_RECEIVE_MULTICAST] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_WIPHY_FREQ_OFFSET] = NLA_POLICY_RANGE(NLA_U32, 0, 999),\n\t[NL80211_ATTR_SCAN_FREQ_KHZ] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_HE_6GHZ_CAPABILITY] =\n\t\tNLA_POLICY_EXACT_LEN(sizeof(struct ieee80211_he_6ghz_capa)),\n\t[NL80211_ATTR_FILS_DISCOVERY] =\n\t\tNLA_POLICY_NESTED(nl80211_fils_discovery_policy),\n\t[NL80211_ATTR_UNSOL_BCAST_PROBE_RESP] =\n\t\tNLA_POLICY_NESTED(nl80211_unsol_bcast_probe_resp_policy),\n\t[NL80211_ATTR_S1G_CAPABILITY] =\n\t\tNLA_POLICY_EXACT_LEN(IEEE80211_S1G_CAPABILITY_LEN),\n\t[NL80211_ATTR_S1G_CAPABILITY_MASK] =\n\t\tNLA_POLICY_EXACT_LEN(IEEE80211_S1G_CAPABILITY_LEN),\n\t[NL80211_ATTR_SAE_PWE] =\n\t\tNLA_POLICY_RANGE(NLA_U8, NL80211_SAE_PWE_HUNT_AND_PECK,\n\t\t\t\t NL80211_SAE_PWE_BOTH),\n\t[NL80211_ATTR_RECONNECT_REQUESTED] = { .type = NLA_REJECT },\n\t[NL80211_ATTR_SAR_SPEC] = NLA_POLICY_NESTED(sar_policy),\n\t[NL80211_ATTR_DISABLE_HE] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_OBSS_COLOR_BITMAP] = { .type = NLA_U64 },\n\t[NL80211_ATTR_COLOR_CHANGE_COUNT] = { .type = NLA_U8 },\n\t[NL80211_ATTR_COLOR_CHANGE_COLOR] = { .type = NLA_U8 },\n\t[NL80211_ATTR_COLOR_CHANGE_ELEMS] = NLA_POLICY_NESTED(nl80211_policy),\n\t[NL80211_ATTR_MBSSID_CONFIG] =\n\t\t\tNLA_POLICY_NESTED(nl80211_mbssid_config_policy),\n\t[NL80211_ATTR_MBSSID_ELEMS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_RADAR_BACKGROUND] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_AP_SETTINGS_FLAGS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_EHT_CAPABILITY] =\n\t\tNLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t NL80211_EHT_MIN_CAPABILITY_LEN,\n\t\t\t\t NL80211_EHT_MAX_CAPABILITY_LEN),\n\t[NL80211_ATTR_DISABLE_EHT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_MLO_LINKS] =\n\t\tNLA_POLICY_NESTED_ARRAY(nl80211_policy),\n\t[NL80211_ATTR_MLO_LINK_ID] =\n\t\tNLA_POLICY_RANGE(NLA_U8, 0, IEEE80211_MLD_MAX_NUM_LINKS),\n\t[NL80211_ATTR_MLD_ADDR] = NLA_POLICY_EXACT_LEN(ETH_ALEN),\n\t[NL80211_ATTR_MLO_SUPPORT] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_MAX_NUM_AKM_SUITES] = { .type = NLA_REJECT },\n\t[NL80211_ATTR_PUNCT_BITMAP] =\n\t\tNLA_POLICY_FULL_RANGE(NLA_U32, &nl80211_punct_bitmap_range),\n\n\t[NL80211_ATTR_MAX_HW_TIMESTAMP_PEERS] = { .type = NLA_U16 },\n\t[NL80211_ATTR_HW_TIMESTAMP_ENABLED] = { .type = NLA_FLAG },\n\t[NL80211_ATTR_EMA_RNR_ELEMS] = { .type = NLA_NESTED },\n\t[NL80211_ATTR_MLO_LINK_DISABLED] = { .type = NLA_FLAG },\n};\n\n \nstatic const struct nla_policy nl80211_key_policy[NL80211_KEY_MAX + 1] = {\n\t[NL80211_KEY_DATA] = { .type = NLA_BINARY, .len = WLAN_MAX_KEY_LEN },\n\t[NL80211_KEY_IDX] = { .type = NLA_U8 },\n\t[NL80211_KEY_CIPHER] = { .type = NLA_U32 },\n\t[NL80211_KEY_SEQ] = { .type = NLA_BINARY, .len = 16 },\n\t[NL80211_KEY_DEFAULT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_MGMT] = { .type = NLA_FLAG },\n\t[NL80211_KEY_TYPE] = NLA_POLICY_MAX(NLA_U32, NUM_NL80211_KEYTYPES - 1),\n\t[NL80211_KEY_DEFAULT_TYPES] = { .type = NLA_NESTED },\n\t[NL80211_KEY_MODE] = NLA_POLICY_RANGE(NLA_U8, 0, NL80211_KEY_SET_TX),\n};\n\n \nstatic const struct nla_policy\nnl80211_key_default_policy[NUM_NL80211_KEY_DEFAULT_TYPES] = {\n\t[NL80211_KEY_DEFAULT_TYPE_UNICAST] = { .type = NLA_FLAG },\n\t[NL80211_KEY_DEFAULT_TYPE_MULTICAST] = { .type = NLA_FLAG },\n};\n\n#ifdef CONFIG_PM\n \nstatic const struct nla_policy\nnl80211_wowlan_policy[NUM_NL80211_WOWLAN_TRIG] = {\n\t[NL80211_WOWLAN_TRIG_ANY] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_DISCONNECT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_MAGIC_PKT] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_PKT_PATTERN] = { .type = NLA_NESTED },\n\t[NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_RFKILL_RELEASE] = { .type = NLA_FLAG },\n\t[NL80211_WOWLAN_TRIG_TCP_CONNECTION] = { .type = NLA_NESTED },\n\t[NL80211_WOWLAN_TRIG_NET_DETECT] = { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy\nnl80211_wowlan_tcp_policy[NUM_NL80211_WOWLAN_TCP] = {\n\t[NL80211_WOWLAN_TCP_SRC_IPV4] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_DST_IPV4] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_DST_MAC] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_WOWLAN_TCP_SRC_PORT] = { .type = NLA_U16 },\n\t[NL80211_WOWLAN_TCP_DST_PORT] = { .type = NLA_U16 },\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD] = NLA_POLICY_MIN_LEN(1),\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ] = {\n\t\t.len = sizeof(struct nl80211_wowlan_tcp_data_seq)\n\t},\n\t[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN] = {\n\t\t.len = sizeof(struct nl80211_wowlan_tcp_data_token)\n\t},\n\t[NL80211_WOWLAN_TCP_DATA_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_WOWLAN_TCP_WAKE_PAYLOAD] = NLA_POLICY_MIN_LEN(1),\n\t[NL80211_WOWLAN_TCP_WAKE_MASK] = NLA_POLICY_MIN_LEN(1),\n};\n#endif  \n\n \nstatic const struct nla_policy\nnl80211_coalesce_policy[NUM_NL80211_ATTR_COALESCE_RULE] = {\n\t[NL80211_ATTR_COALESCE_RULE_DELAY] = { .type = NLA_U32 },\n\t[NL80211_ATTR_COALESCE_RULE_CONDITION] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_COALESCE_CONDITION_MATCH,\n\t\t\t\t NL80211_COALESCE_CONDITION_NO_MATCH),\n\t[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN] = { .type = NLA_NESTED },\n};\n\n \nstatic const struct nla_policy\nnl80211_rekey_policy[NUM_NL80211_REKEY_DATA] = {\n\t[NL80211_REKEY_DATA_KEK] = {\n\t\t.type = NLA_BINARY,\n\t\t.len = NL80211_KEK_EXT_LEN\n\t},\n\t[NL80211_REKEY_DATA_KCK] = {\n\t\t.type = NLA_BINARY,\n\t\t.len = NL80211_KCK_EXT_LEN_32\n\t},\n\t[NL80211_REKEY_DATA_REPLAY_CTR] = NLA_POLICY_EXACT_LEN(NL80211_REPLAY_CTR_LEN),\n\t[NL80211_REKEY_DATA_AKM] = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nnl80211_match_band_rssi_policy[NUM_NL80211_BANDS] = {\n\t[NL80211_BAND_2GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_5GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_6GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_60GHZ] = { .type = NLA_S32 },\n\t[NL80211_BAND_LC]    = { .type = NLA_S32 },\n};\n\nstatic const struct nla_policy\nnl80211_match_policy[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1] = {\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] = { .type = NLA_BINARY,\n\t\t\t\t\t\t .len = IEEE80211_MAX_SSID_LEN },\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI] = { .type = NLA_U32 },\n\t[NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI] =\n\t\tNLA_POLICY_NESTED(nl80211_match_band_rssi_policy),\n};\n\nstatic const struct nla_policy\nnl80211_plan_policy[NL80211_SCHED_SCAN_PLAN_MAX + 1] = {\n\t[NL80211_SCHED_SCAN_PLAN_INTERVAL] = { .type = NLA_U32 },\n\t[NL80211_SCHED_SCAN_PLAN_ITERATIONS] = { .type = NLA_U32 },\n};\n\nstatic const struct nla_policy\nnl80211_bss_select_policy[NL80211_BSS_SELECT_ATTR_MAX + 1] = {\n\t[NL80211_BSS_SELECT_ATTR_RSSI] = { .type = NLA_FLAG },\n\t[NL80211_BSS_SELECT_ATTR_BAND_PREF] = { .type = NLA_U32 },\n\t[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST] = {\n\t\t.len = sizeof(struct nl80211_bss_select_rssi_adjust)\n\t},\n};\n\n \nstatic const struct nla_policy\nnl80211_nan_func_policy[NL80211_NAN_FUNC_ATTR_MAX + 1] = {\n\t[NL80211_NAN_FUNC_TYPE] =\n\t\tNLA_POLICY_MAX(NLA_U8, NL80211_NAN_FUNC_MAX_TYPE),\n\t[NL80211_NAN_FUNC_SERVICE_ID] = {\n\t\t\t\t    .len = NL80211_NAN_FUNC_SERVICE_ID_LEN },\n\t[NL80211_NAN_FUNC_PUBLISH_TYPE] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_PUBLISH_BCAST] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_FOLLOW_UP_DEST] = NLA_POLICY_EXACT_LEN_WARN(ETH_ALEN),\n\t[NL80211_NAN_FUNC_CLOSE_RANGE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_FUNC_TTL] = { .type = NLA_U32 },\n\t[NL80211_NAN_FUNC_SERVICE_INFO] = { .type = NLA_BINARY,\n\t\t\t.len = NL80211_NAN_FUNC_SERVICE_SPEC_INFO_MAX_LEN },\n\t[NL80211_NAN_FUNC_SRF] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_RX_MATCH_FILTER] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_TX_MATCH_FILTER] = { .type = NLA_NESTED },\n\t[NL80211_NAN_FUNC_INSTANCE_ID] = { .type = NLA_U8 },\n\t[NL80211_NAN_FUNC_TERM_REASON] = { .type = NLA_U8 },\n};\n\n \nstatic const struct nla_policy\nnl80211_nan_srf_policy[NL80211_NAN_SRF_ATTR_MAX + 1] = {\n\t[NL80211_NAN_SRF_INCLUDE] = { .type = NLA_FLAG },\n\t[NL80211_NAN_SRF_BF] = { .type = NLA_BINARY,\n\t\t\t\t .len =  NL80211_NAN_FUNC_SRF_MAX_LEN },\n\t[NL80211_NAN_SRF_BF_IDX] = { .type = NLA_U8 },\n\t[NL80211_NAN_SRF_MAC_ADDRS] = { .type = NLA_NESTED },\n};\n\n \nstatic const struct nla_policy\nnl80211_packet_pattern_policy[MAX_NL80211_PKTPAT + 1] = {\n\t[NL80211_PKTPAT_MASK] = { .type = NLA_BINARY, },\n\t[NL80211_PKTPAT_PATTERN] = { .type = NLA_BINARY, },\n\t[NL80211_PKTPAT_OFFSET] = { .type = NLA_U32 },\n};\n\nstatic int nl80211_prepare_wdev_dump(struct netlink_callback *cb,\n\t\t\t\t     struct cfg80211_registered_device **rdev,\n\t\t\t\t     struct wireless_dev **wdev,\n\t\t\t\t     struct nlattr **attrbuf)\n{\n\tint err;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr **attrbuf_free = NULL;\n\n\t\tif (!attrbuf) {\n\t\t\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!attrbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tattrbuf_free = attrbuf;\n\t\t}\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t\t     nl80211_policy, NULL);\n\t\tif (err) {\n\t\t\tkfree(attrbuf_free);\n\t\t\treturn err;\n\t\t}\n\n\t\trtnl_lock();\n\t\t*wdev = __cfg80211_wdev_from_attrs(NULL, sock_net(cb->skb->sk),\n\t\t\t\t\t\t   attrbuf);\n\t\tkfree(attrbuf_free);\n\t\tif (IS_ERR(*wdev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(*wdev);\n\t\t}\n\t\t*rdev = wiphy_to_rdev((*wdev)->wiphy);\n\t\tmutex_lock(&(*rdev)->wiphy.mtx);\n\t\trtnl_unlock();\n\t\t \n\t\tcb->args[0] = (*rdev)->wiphy_idx + 1;\n\t\tcb->args[1] = (*wdev)->identifier;\n\t} else {\n\t\t \n\t\tstruct wiphy *wiphy;\n\t\tstruct wireless_dev *tmp;\n\n\t\trtnl_lock();\n\t\twiphy = wiphy_idx_to_wiphy(cb->args[0] - 1);\n\t\tif (!wiphy) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENODEV;\n\t\t}\n\t\t*rdev = wiphy_to_rdev(wiphy);\n\t\t*wdev = NULL;\n\n\t\tlist_for_each_entry(tmp, &(*rdev)->wiphy.wdev_list, list) {\n\t\t\tif (tmp->identifier == cb->args[1]) {\n\t\t\t\t*wdev = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!*wdev) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tmutex_lock(&(*rdev)->wiphy.mtx);\n\t\trtnl_unlock();\n\t}\n\n\treturn 0;\n}\n\n \nvoid *nl80211hdr_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t     int flags, u8 cmd)\n{\n\t \n\treturn genlmsg_put(skb, portid, seq, &nl80211_fam, flags, cmd);\n}\n\nstatic int nl80211_msg_put_wmm_rules(struct sk_buff *msg,\n\t\t\t\t     const struct ieee80211_reg_rule *rule)\n{\n\tint j;\n\tstruct nlattr *nl_wmm_rules =\n\t\tnla_nest_start_noflag(msg, NL80211_FREQUENCY_ATTR_WMM);\n\n\tif (!nl_wmm_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (j = 0; j < IEEE80211_NUM_ACS; j++) {\n\t\tstruct nlattr *nl_wmm_rule = nla_nest_start_noflag(msg, j);\n\n\t\tif (!nl_wmm_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u16(msg, NL80211_WMMR_CW_MIN,\n\t\t\t\trule->wmm_rule.client[j].cw_min) ||\n\t\t    nla_put_u16(msg, NL80211_WMMR_CW_MAX,\n\t\t\t\trule->wmm_rule.client[j].cw_max) ||\n\t\t    nla_put_u8(msg, NL80211_WMMR_AIFSN,\n\t\t\t       rule->wmm_rule.client[j].aifsn) ||\n\t\t    nla_put_u16(msg, NL80211_WMMR_TXOP,\n\t\t\t        rule->wmm_rule.client[j].cot))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_wmm_rule);\n\t}\n\tnla_nest_end(msg, nl_wmm_rules);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_msg_put_channel(struct sk_buff *msg, struct wiphy *wiphy,\n\t\t\t\t   struct ieee80211_channel *chan,\n\t\t\t\t   bool large)\n{\n\t \n\tif (!large && chan->flags &\n\t    (IEEE80211_CHAN_NO_10MHZ | IEEE80211_CHAN_NO_20MHZ))\n\t\treturn 0;\n\tif (!large && chan->freq_offset)\n\t\treturn 0;\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_FREQ,\n\t\t\tchan->center_freq))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_OFFSET, chan->freq_offset))\n\t\tgoto nla_put_failure;\n\n\tif ((chan->flags & IEEE80211_CHAN_DISABLED) &&\n\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_DISABLED))\n\t\tgoto nla_put_failure;\n\tif (chan->flags & IEEE80211_CHAN_NO_IR) {\n\t\tif (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_IR))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_flag(msg, __NL80211_FREQUENCY_ATTR_NO_IBSS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (chan->flags & IEEE80211_CHAN_RADAR) {\n\t\tif (nla_put_flag(msg, NL80211_FREQUENCY_ATTR_RADAR))\n\t\t\tgoto nla_put_failure;\n\t\tif (large) {\n\t\t\tu32 time;\n\n\t\t\ttime = elapsed_jiffies_msecs(chan->dfs_state_entered);\n\n\t\t\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_DFS_STATE,\n\t\t\t\t\tchan->dfs_state))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_DFS_TIME,\n\t\t\t\t\ttime))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg,\n\t\t\t\t\tNL80211_FREQUENCY_ATTR_DFS_CAC_TIME,\n\t\t\t\t\tchan->dfs_cac_ms))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\tif (large) {\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HT40MINUS) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HT40_MINUS))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HT40PLUS) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HT40_PLUS))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_80MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_80MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_160MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_160MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_INDOOR_ONLY) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_INDOOR_ONLY))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_IR_CONCURRENT) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_IR_CONCURRENT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_20MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_20MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_10MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_10MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_HE) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_HE))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_1MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_1MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_2MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_2MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_4MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_4MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_8MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_8MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_16MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_16MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_320MHZ) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_320MHZ))\n\t\t\tgoto nla_put_failure;\n\t\tif ((chan->flags & IEEE80211_CHAN_NO_EHT) &&\n\t\t    nla_put_flag(msg, NL80211_FREQUENCY_ATTR_NO_EHT))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_FREQUENCY_ATTR_MAX_TX_POWER,\n\t\t\tDBM_TO_MBM(chan->max_power)))\n\t\tgoto nla_put_failure;\n\n\tif (large) {\n\t\tconst struct ieee80211_reg_rule *rule =\n\t\t\tfreq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));\n\n\t\tif (!IS_ERR_OR_NULL(rule) && rule->has_wmm) {\n\t\t\tif (nl80211_msg_put_wmm_rules(msg, rule))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t}\n\n\treturn 0;\n\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic bool nl80211_put_txq_stats(struct sk_buff *msg,\n\t\t\t\t  struct cfg80211_txq_stats *txqstats,\n\t\t\t\t  int attrtype)\n{\n\tstruct nlattr *txqattr;\n\n#define PUT_TXQVAL_U32(attr, memb) do {\t\t\t\t\t  \\\n\tif (txqstats->filled & BIT(NL80211_TXQ_STATS_ ## attr) &&\t  \\\n\t    nla_put_u32(msg, NL80211_TXQ_STATS_ ## attr, txqstats->memb)) \\\n\t\treturn false;\t\t\t\t\t\t  \\\n\t} while (0)\n\n\ttxqattr = nla_nest_start_noflag(msg, attrtype);\n\tif (!txqattr)\n\t\treturn false;\n\n\tPUT_TXQVAL_U32(BACKLOG_BYTES, backlog_bytes);\n\tPUT_TXQVAL_U32(BACKLOG_PACKETS, backlog_packets);\n\tPUT_TXQVAL_U32(FLOWS, flows);\n\tPUT_TXQVAL_U32(DROPS, drops);\n\tPUT_TXQVAL_U32(ECN_MARKS, ecn_marks);\n\tPUT_TXQVAL_U32(OVERLIMIT, overlimit);\n\tPUT_TXQVAL_U32(OVERMEMORY, overmemory);\n\tPUT_TXQVAL_U32(COLLISIONS, collisions);\n\tPUT_TXQVAL_U32(TX_BYTES, tx_bytes);\n\tPUT_TXQVAL_U32(TX_PACKETS, tx_packets);\n\tPUT_TXQVAL_U32(MAX_FLOWS, max_flows);\n\tnla_nest_end(msg, txqattr);\n\n#undef PUT_TXQVAL_U32\n\treturn true;\n}\n\n \n\n \nstatic unsigned int nl80211_link_id(struct nlattr **attrs)\n{\n\tstruct nlattr *linkid = attrs[NL80211_ATTR_MLO_LINK_ID];\n\n\tif (!linkid)\n\t\treturn 0;\n\n\treturn nla_get_u8(linkid);\n}\n\nstatic int nl80211_link_id_or_invalid(struct nlattr **attrs)\n{\n\tstruct nlattr *linkid = attrs[NL80211_ATTR_MLO_LINK_ID];\n\n\tif (!linkid)\n\t\treturn -1;\n\n\treturn nla_get_u8(linkid);\n}\n\nstruct key_parse {\n\tstruct key_params p;\n\tint idx;\n\tint type;\n\tbool def, defmgmt, defbeacon;\n\tbool def_uni, def_multi;\n};\n\nstatic int nl80211_parse_key_new(struct genl_info *info, struct nlattr *key,\n\t\t\t\t struct key_parse *k)\n{\n\tstruct nlattr *tb[NL80211_KEY_MAX + 1];\n\tint err = nla_parse_nested_deprecated(tb, NL80211_KEY_MAX, key,\n\t\t\t\t\t      nl80211_key_policy,\n\t\t\t\t\t      info->extack);\n\tif (err)\n\t\treturn err;\n\n\tk->def = !!tb[NL80211_KEY_DEFAULT];\n\tk->defmgmt = !!tb[NL80211_KEY_DEFAULT_MGMT];\n\tk->defbeacon = !!tb[NL80211_KEY_DEFAULT_BEACON];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt || k->defbeacon)\n\t\tk->def_multi = true;\n\n\tif (tb[NL80211_KEY_IDX])\n\t\tk->idx = nla_get_u8(tb[NL80211_KEY_IDX]);\n\n\tif (tb[NL80211_KEY_DATA]) {\n\t\tk->p.key = nla_data(tb[NL80211_KEY_DATA]);\n\t\tk->p.key_len = nla_len(tb[NL80211_KEY_DATA]);\n\t}\n\n\tif (tb[NL80211_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(tb[NL80211_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(tb[NL80211_KEY_SEQ]);\n\t}\n\n\tif (tb[NL80211_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(tb[NL80211_KEY_CIPHER]);\n\n\tif (tb[NL80211_KEY_TYPE])\n\t\tk->type = nla_get_u32(tb[NL80211_KEY_TYPE]);\n\n\tif (tb[NL80211_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\n\t\terr = nla_parse_nested_deprecated(kdt,\n\t\t\t\t\t\t  NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t\t\t  tb[NL80211_KEY_DEFAULT_TYPES],\n\t\t\t\t\t\t  nl80211_key_default_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\tif (tb[NL80211_KEY_MODE])\n\t\tk->p.mode = nla_get_u8(tb[NL80211_KEY_MODE]);\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key_old(struct genl_info *info, struct key_parse *k)\n{\n\tif (info->attrs[NL80211_ATTR_KEY_DATA]) {\n\t\tk->p.key = nla_data(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t\tk->p.key_len = nla_len(info->attrs[NL80211_ATTR_KEY_DATA]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_SEQ]) {\n\t\tk->p.seq = nla_data(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t\tk->p.seq_len = nla_len(info->attrs[NL80211_ATTR_KEY_SEQ]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX])\n\t\tk->idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\tif (info->attrs[NL80211_ATTR_KEY_CIPHER])\n\t\tk->p.cipher = nla_get_u32(info->attrs[NL80211_ATTR_KEY_CIPHER]);\n\n\tk->def = !!info->attrs[NL80211_ATTR_KEY_DEFAULT];\n\tk->defmgmt = !!info->attrs[NL80211_ATTR_KEY_DEFAULT_MGMT];\n\n\tif (k->def) {\n\t\tk->def_uni = true;\n\t\tk->def_multi = true;\n\t}\n\tif (k->defmgmt)\n\t\tk->def_multi = true;\n\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE])\n\t\tk->type = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\n\tif (info->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES]) {\n\t\tstruct nlattr *kdt[NUM_NL80211_KEY_DEFAULT_TYPES];\n\t\tint err = nla_parse_nested_deprecated(kdt,\n\t\t\t\t\t\t      NUM_NL80211_KEY_DEFAULT_TYPES - 1,\n\t\t\t\t\t\t      info->attrs[NL80211_ATTR_KEY_DEFAULT_TYPES],\n\t\t\t\t\t\t      nl80211_key_default_policy,\n\t\t\t\t\t\t      info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tk->def_uni = kdt[NL80211_KEY_DEFAULT_TYPE_UNICAST];\n\t\tk->def_multi = kdt[NL80211_KEY_DEFAULT_TYPE_MULTICAST];\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_key(struct genl_info *info, struct key_parse *k)\n{\n\tint err;\n\n\tmemset(k, 0, sizeof(*k));\n\tk->idx = -1;\n\tk->type = -1;\n\n\tif (info->attrs[NL80211_ATTR_KEY])\n\t\terr = nl80211_parse_key_new(info, info->attrs[NL80211_ATTR_KEY], k);\n\telse\n\t\terr = nl80211_parse_key_old(info, k);\n\n\tif (err)\n\t\treturn err;\n\n\tif ((k->def ? 1 : 0) + (k->defmgmt ? 1 : 0) +\n\t    (k->defbeacon ? 1 : 0) > 1) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"key with multiple default flags is invalid\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (k->defmgmt || k->defbeacon) {\n\t\tif (k->def_uni || !k->def_multi) {\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"defmgmt/defbeacon key must be mcast\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (k->idx != -1) {\n\t\tif (k->defmgmt) {\n\t\t\tif (k->idx < 4 || k->idx > 5) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"defmgmt key idx not 4 or 5\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (k->defbeacon) {\n\t\t\tif (k->idx < 6 || k->idx > 7) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"defbeacon key idx not 6 or 7\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (k->def) {\n\t\t\tif (k->idx < 0 || k->idx > 3) {\n\t\t\t\tGENL_SET_ERR_MSG(info, \"def key idx not 0-3\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (k->idx < 0 || k->idx > 7) {\n\t\t\t\tGENL_SET_ERR_MSG(info, \"key idx not 0-7\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_cached_keys *\nnl80211_parse_connkeys(struct cfg80211_registered_device *rdev,\n\t\t       struct genl_info *info, bool *no_ht)\n{\n\tstruct nlattr *keys = info->attrs[NL80211_ATTR_KEYS];\n\tstruct key_parse parse;\n\tstruct nlattr *key;\n\tstruct cfg80211_cached_keys *result;\n\tint rem, err, def = 0;\n\tbool have_key = false;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\thave_key = true;\n\t\tbreak;\n\t}\n\n\tif (!have_key)\n\t\treturn NULL;\n\n\tresult = kzalloc(sizeof(*result), GFP_KERNEL);\n\tif (!result)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tresult->def = -1;\n\n\tnla_for_each_nested(key, keys, rem) {\n\t\tmemset(&parse, 0, sizeof(parse));\n\t\tparse.idx = -1;\n\n\t\terr = nl80211_parse_key_new(info, key, &parse);\n\t\tif (err)\n\t\t\tgoto error;\n\t\terr = -EINVAL;\n\t\tif (!parse.p.key)\n\t\t\tgoto error;\n\t\tif (parse.idx < 0 || parse.idx > 3) {\n\t\t\tGENL_SET_ERR_MSG(info, \"key index out of range [0-3]\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (parse.def) {\n\t\t\tif (def) {\n\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t \"only one key can be default\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tdef = 1;\n\t\t\tresult->def = parse.idx;\n\t\t\tif (!parse.def_uni || !parse.def_multi)\n\t\t\t\tgoto error;\n\t\t} else if (parse.defmgmt)\n\t\t\tgoto error;\n\t\terr = cfg80211_validate_key_settings(rdev, &parse.p,\n\t\t\t\t\t\t     parse.idx, false, NULL);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tif (parse.p.cipher != WLAN_CIPHER_SUITE_WEP40 &&\n\t\t    parse.p.cipher != WLAN_CIPHER_SUITE_WEP104) {\n\t\t\tGENL_SET_ERR_MSG(info, \"connect key must be WEP\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tresult->params[parse.idx].cipher = parse.p.cipher;\n\t\tresult->params[parse.idx].key_len = parse.p.key_len;\n\t\tresult->params[parse.idx].key = result->data[parse.idx];\n\t\tmemcpy(result->data[parse.idx], parse.p.key, parse.p.key_len);\n\n\t\t \n\t\tif (no_ht)\n\t\t\t*no_ht = true;\n\t}\n\n\tif (result->def < 0) {\n\t\terr = -EINVAL;\n\t\tGENL_SET_ERR_MSG(info, \"need a default/TX key\");\n\t\tgoto error;\n\t}\n\n\treturn result;\n error:\n\tkfree(result);\n\treturn ERR_PTR(err);\n}\n\nstatic int nl80211_key_allowed(struct wireless_dev *wdev)\n{\n\tASSERT_WDEV_LOCK(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (wdev->u.ibss.current_bss)\n\t\t\treturn 0;\n\t\treturn -ENOLINK;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->connected)\n\t\t\treturn 0;\n\t\treturn -ENOLINK;\n\tcase NL80211_IFTYPE_NAN:\n\t\tif (wiphy_ext_feature_isset(wdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_SECURE_NAN))\n\t\t\treturn 0;\n\t\treturn -EINVAL;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NUM_NL80211_IFTYPES:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ieee80211_channel *nl80211_get_valid_chan(struct wiphy *wiphy,\n\t\t\t\t\t\t\tu32 freq)\n{\n\tstruct ieee80211_channel *chan;\n\n\tchan = ieee80211_get_channel_khz(wiphy, freq);\n\tif (!chan || chan->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn NULL;\n\treturn chan;\n}\n\nstatic int nl80211_put_iftypes(struct sk_buff *msg, u32 attr, u16 ifmodes)\n{\n\tstruct nlattr *nl_modes = nla_nest_start_noflag(msg, attr);\n\tint i;\n\n\tif (!nl_modes)\n\t\tgoto nla_put_failure;\n\n\ti = 0;\n\twhile (ifmodes) {\n\t\tif ((ifmodes & 1) && nla_put_flag(msg, i))\n\t\t\tgoto nla_put_failure;\n\t\tifmodes >>= 1;\n\t\ti++;\n\t}\n\n\tnla_nest_end(msg, nl_modes);\n\treturn 0;\n\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_put_iface_combinations(struct wiphy *wiphy,\n\t\t\t\t\t  struct sk_buff *msg,\n\t\t\t\t\t  bool large)\n{\n\tstruct nlattr *nl_combis;\n\tint i, j;\n\n\tnl_combis = nla_nest_start_noflag(msg,\n\t\t\t\t\t  NL80211_ATTR_INTERFACE_COMBINATIONS);\n\tif (!nl_combis)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < wiphy->n_iface_combinations; i++) {\n\t\tconst struct ieee80211_iface_combination *c;\n\t\tstruct nlattr *nl_combi, *nl_limits;\n\n\t\tc = &wiphy->iface_combinations[i];\n\n\t\tnl_combi = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_combi)\n\t\t\tgoto nla_put_failure;\n\n\t\tnl_limits = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_IFACE_COMB_LIMITS);\n\t\tif (!nl_limits)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (j = 0; j < c->n_limits; j++) {\n\t\t\tstruct nlattr *nl_limit;\n\n\t\t\tnl_limit = nla_nest_start_noflag(msg, j + 1);\n\t\t\tif (!nl_limit)\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_IFACE_LIMIT_MAX,\n\t\t\t\t\tc->limits[j].max))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nl80211_put_iftypes(msg, NL80211_IFACE_LIMIT_TYPES,\n\t\t\t\t\t\tc->limits[j].types))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tnla_nest_end(msg, nl_limit);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_limits);\n\n\t\tif (c->beacon_int_infra_match &&\n\t\t    nla_put_flag(msg, NL80211_IFACE_COMB_STA_AP_BI_MATCH))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(msg, NL80211_IFACE_COMB_NUM_CHANNELS,\n\t\t\t\tc->num_different_channels) ||\n\t\t    nla_put_u32(msg, NL80211_IFACE_COMB_MAXNUM,\n\t\t\t\tc->max_interfaces))\n\t\t\tgoto nla_put_failure;\n\t\tif (large &&\n\t\t    (nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,\n\t\t\t\tc->radar_detect_widths) ||\n\t\t     nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_REGIONS,\n\t\t\t\tc->radar_detect_regions)))\n\t\t\tgoto nla_put_failure;\n\t\tif (c->beacon_int_min_gcd &&\n\t\t    nla_put_u32(msg, NL80211_IFACE_COMB_BI_MIN_GCD,\n\t\t\t\tc->beacon_int_min_gcd))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_combi);\n\t}\n\n\tnla_nest_end(msg, nl_combis);\n\n\treturn 0;\nnla_put_failure:\n\treturn -ENOBUFS;\n}\n\n#ifdef CONFIG_PM\nstatic int nl80211_send_wowlan_tcp_caps(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct sk_buff *msg)\n{\n\tconst struct wiphy_wowlan_tcp_support *tcp = rdev->wiphy.wowlan->tcp;\n\tstruct nlattr *nl_tcp;\n\n\tif (!tcp)\n\t\treturn 0;\n\n\tnl_tcp = nla_nest_start_noflag(msg,\n\t\t\t\t       NL80211_WOWLAN_TRIG_TCP_CONNECTION);\n\tif (!nl_tcp)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t\ttcp->data_payload_max))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t\ttcp->data_payload_max))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->seq && nla_put_flag(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->tok && nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,\n\t\t\t\tsizeof(*tcp->tok), tcp->tok))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_INTERVAL,\n\t\t\ttcp->data_interval_max))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_WOWLAN_TCP_WAKE_PAYLOAD,\n\t\t\ttcp->wake_payload_max))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_tcp);\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan(struct sk_buff *msg,\n\t\t\t       struct cfg80211_registered_device *rdev,\n\t\t\t       bool large)\n{\n\tstruct nlattr *nl_wowlan;\n\n\tif (!rdev->wiphy.wowlan)\n\t\treturn 0;\n\n\tnl_wowlan = nla_nest_start_noflag(msg,\n\t\t\t\t\t  NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED);\n\tif (!nl_wowlan)\n\t\treturn -ENOBUFS;\n\n\tif (((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_ANY) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_ANY)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_DISCONNECT) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE)) ||\n\t    ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE) &&\n\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE)))\n\t\treturn -ENOBUFS;\n\n\tif (rdev->wiphy.wowlan->n_patterns) {\n\t\tstruct nl80211_pattern_support pat = {\n\t\t\t.max_patterns = rdev->wiphy.wowlan->n_patterns,\n\t\t\t.min_pattern_len = rdev->wiphy.wowlan->pattern_min_len,\n\t\t\t.max_pattern_len = rdev->wiphy.wowlan->pattern_max_len,\n\t\t\t.max_pkt_offset = rdev->wiphy.wowlan->max_pkt_offset,\n\t\t};\n\n\t\tif (nla_put(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,\n\t\t\t    sizeof(pat), &pat))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tif ((rdev->wiphy.wowlan->flags & WIPHY_WOWLAN_NET_DETECT) &&\n\t    nla_put_u32(msg, NL80211_WOWLAN_TRIG_NET_DETECT,\n\t\t\trdev->wiphy.wowlan->max_nd_match_sets))\n\t\treturn -ENOBUFS;\n\n\tif (large && nl80211_send_wowlan_tcp_caps(rdev, msg))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_wowlan);\n\n\treturn 0;\n}\n#endif\n\nstatic int nl80211_send_coalesce(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev)\n{\n\tstruct nl80211_coalesce_rule_support rule;\n\n\tif (!rdev->wiphy.coalesce)\n\t\treturn 0;\n\n\trule.max_rules = rdev->wiphy.coalesce->n_rules;\n\trule.max_delay = rdev->wiphy.coalesce->max_delay;\n\trule.pat.max_patterns = rdev->wiphy.coalesce->n_patterns;\n\trule.pat.min_pattern_len = rdev->wiphy.coalesce->pattern_min_len;\n\trule.pat.max_pattern_len = rdev->wiphy.coalesce->pattern_max_len;\n\trule.pat.max_pkt_offset = rdev->wiphy.coalesce->max_pkt_offset;\n\n\tif (nla_put(msg, NL80211_ATTR_COALESCE_RULE, sizeof(rule), &rule))\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\nstatic int\nnl80211_send_iftype_data(struct sk_buff *msg,\n\t\t\t const struct ieee80211_supported_band *sband,\n\t\t\t const struct ieee80211_sband_iftype_data *iftdata)\n{\n\tconst struct ieee80211_sta_he_cap *he_cap = &iftdata->he_cap;\n\tconst struct ieee80211_sta_eht_cap *eht_cap = &iftdata->eht_cap;\n\n\tif (nl80211_put_iftypes(msg, NL80211_BAND_IFTYPE_ATTR_IFTYPES,\n\t\t\t\tiftdata->types_mask))\n\t\treturn -ENOBUFS;\n\n\tif (he_cap->has_he) {\n\t\tif (nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_MAC,\n\t\t\t    sizeof(he_cap->he_cap_elem.mac_cap_info),\n\t\t\t    he_cap->he_cap_elem.mac_cap_info) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_PHY,\n\t\t\t    sizeof(he_cap->he_cap_elem.phy_cap_info),\n\t\t\t    he_cap->he_cap_elem.phy_cap_info) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_MCS_SET,\n\t\t\t    sizeof(he_cap->he_mcs_nss_supp),\n\t\t\t    &he_cap->he_mcs_nss_supp) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_CAP_PPE,\n\t\t\t    sizeof(he_cap->ppe_thres), he_cap->ppe_thres))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tif (eht_cap->has_eht && he_cap->has_he) {\n\t\tu8 mcs_nss_size, ppe_thresh_size;\n\t\tu16 ppe_thres_hdr;\n\t\tbool is_ap;\n\n\t\tis_ap = iftdata->types_mask & BIT(NL80211_IFTYPE_AP) ||\n\t\t\tiftdata->types_mask & BIT(NL80211_IFTYPE_P2P_GO);\n\n\t\tmcs_nss_size =\n\t\t\tieee80211_eht_mcs_nss_size(&he_cap->he_cap_elem,\n\t\t\t\t\t\t   &eht_cap->eht_cap_elem,\n\t\t\t\t\t\t   is_ap);\n\n\t\tppe_thres_hdr = get_unaligned_le16(&eht_cap->eht_ppe_thres[0]);\n\t\tppe_thresh_size =\n\t\t\tieee80211_eht_ppe_size(ppe_thres_hdr,\n\t\t\t\t\t       eht_cap->eht_cap_elem.phy_cap_info);\n\n\t\tif (nla_put(msg, NL80211_BAND_IFTYPE_ATTR_EHT_CAP_MAC,\n\t\t\t    sizeof(eht_cap->eht_cap_elem.mac_cap_info),\n\t\t\t    eht_cap->eht_cap_elem.mac_cap_info) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_EHT_CAP_PHY,\n\t\t\t    sizeof(eht_cap->eht_cap_elem.phy_cap_info),\n\t\t\t    eht_cap->eht_cap_elem.phy_cap_info) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_EHT_CAP_MCS_SET,\n\t\t\t    mcs_nss_size, &eht_cap->eht_mcs_nss_supp) ||\n\t\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_EHT_CAP_PPE,\n\t\t\t    ppe_thresh_size, eht_cap->eht_ppe_thres))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tif (sband->band == NL80211_BAND_6GHZ &&\n\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_HE_6GHZ_CAPA,\n\t\t    sizeof(iftdata->he_6ghz_capa),\n\t\t    &iftdata->he_6ghz_capa))\n\t\treturn -ENOBUFS;\n\n\tif (iftdata->vendor_elems.data && iftdata->vendor_elems.len &&\n\t    nla_put(msg, NL80211_BAND_IFTYPE_ATTR_VENDOR_ELEMS,\n\t\t    iftdata->vendor_elems.len, iftdata->vendor_elems.data))\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\nstatic int nl80211_send_band_rateinfo(struct sk_buff *msg,\n\t\t\t\t      struct ieee80211_supported_band *sband,\n\t\t\t\t      bool large)\n{\n\tstruct nlattr *nl_rates, *nl_rate;\n\tstruct ieee80211_rate *rate;\n\tint i;\n\n\t \n\tif (sband->ht_cap.ht_supported &&\n\t    (nla_put(msg, NL80211_BAND_ATTR_HT_MCS_SET,\n\t\t     sizeof(sband->ht_cap.mcs),\n\t\t     &sband->ht_cap.mcs) ||\n\t     nla_put_u16(msg, NL80211_BAND_ATTR_HT_CAPA,\n\t\t\t sband->ht_cap.cap) ||\n\t     nla_put_u8(msg, NL80211_BAND_ATTR_HT_AMPDU_FACTOR,\n\t\t\tsband->ht_cap.ampdu_factor) ||\n\t     nla_put_u8(msg, NL80211_BAND_ATTR_HT_AMPDU_DENSITY,\n\t\t\tsband->ht_cap.ampdu_density)))\n\t\treturn -ENOBUFS;\n\n\t \n\tif (sband->vht_cap.vht_supported &&\n\t    (nla_put(msg, NL80211_BAND_ATTR_VHT_MCS_SET,\n\t\t     sizeof(sband->vht_cap.vht_mcs),\n\t\t     &sband->vht_cap.vht_mcs) ||\n\t     nla_put_u32(msg, NL80211_BAND_ATTR_VHT_CAPA,\n\t\t\t sband->vht_cap.cap)))\n\t\treturn -ENOBUFS;\n\n\tif (large && sband->n_iftype_data) {\n\t\tstruct nlattr *nl_iftype_data =\n\t\t\tnla_nest_start_noflag(msg,\n\t\t\t\t\t      NL80211_BAND_ATTR_IFTYPE_DATA);\n\t\tint err;\n\n\t\tif (!nl_iftype_data)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (i = 0; i < sband->n_iftype_data; i++) {\n\t\t\tstruct nlattr *iftdata;\n\n\t\t\tiftdata = nla_nest_start_noflag(msg, i + 1);\n\t\t\tif (!iftdata)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\terr = nl80211_send_iftype_data(msg, sband,\n\t\t\t\t\t\t       &sband->iftype_data[i]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tnla_nest_end(msg, iftdata);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_iftype_data);\n\t}\n\n\t \n\tif (large && sband->edmg_cap.channels &&\n\t    (nla_put_u8(msg, NL80211_BAND_ATTR_EDMG_CHANNELS,\n\t\t       sband->edmg_cap.channels) ||\n\t    nla_put_u8(msg, NL80211_BAND_ATTR_EDMG_BW_CONFIG,\n\t\t       sband->edmg_cap.bw_config)))\n\n\t\treturn -ENOBUFS;\n\n\t \n\tnl_rates = nla_nest_start_noflag(msg, NL80211_BAND_ATTR_RATES);\n\tif (!nl_rates)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tnl_rate = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_rate)\n\t\t\treturn -ENOBUFS;\n\n\t\trate = &sband->bitrates[i];\n\t\tif (nla_put_u32(msg, NL80211_BITRATE_ATTR_RATE,\n\t\t\t\trate->bitrate))\n\t\t\treturn -ENOBUFS;\n\t\tif ((rate->flags & IEEE80211_RATE_SHORT_PREAMBLE) &&\n\t\t    nla_put_flag(msg,\n\t\t\t\t NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE))\n\t\t\treturn -ENOBUFS;\n\n\t\tnla_nest_end(msg, nl_rate);\n\t}\n\n\tnla_nest_end(msg, nl_rates);\n\n\t \n\tif (sband->band == NL80211_BAND_S1GHZ && sband->s1g_cap.s1g &&\n\t    (nla_put(msg, NL80211_BAND_ATTR_S1G_CAPA,\n\t\t     sizeof(sband->s1g_cap.cap),\n\t\t     sband->s1g_cap.cap) ||\n\t     nla_put(msg, NL80211_BAND_ATTR_S1G_MCS_NSS_SET,\n\t\t     sizeof(sband->s1g_cap.nss_mcs),\n\t\t     sband->s1g_cap.nss_mcs)))\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\nstatic int\nnl80211_send_mgmt_stypes(struct sk_buff *msg,\n\t\t\t const struct ieee80211_txrx_stypes *mgmt_stypes)\n{\n\tu16 stypes;\n\tstruct nlattr *nl_ftypes, *nl_ifs;\n\tenum nl80211_iftype ift;\n\tint i;\n\n\tif (!mgmt_stypes)\n\t\treturn 0;\n\n\tnl_ifs = nla_nest_start_noflag(msg, NL80211_ATTR_TX_FRAME_TYPES);\n\tif (!nl_ifs)\n\t\treturn -ENOBUFS;\n\n\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\tnl_ftypes = nla_nest_start_noflag(msg, ift);\n\t\tif (!nl_ftypes)\n\t\t\treturn -ENOBUFS;\n\t\ti = 0;\n\t\tstypes = mgmt_stypes[ift].tx;\n\t\twhile (stypes) {\n\t\t\tif ((stypes & 1) &&\n\t\t\t    nla_put_u16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t(i << 4) | IEEE80211_FTYPE_MGMT))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tstypes >>= 1;\n\t\t\ti++;\n\t\t}\n\t\tnla_nest_end(msg, nl_ftypes);\n\t}\n\n\tnla_nest_end(msg, nl_ifs);\n\n\tnl_ifs = nla_nest_start_noflag(msg, NL80211_ATTR_RX_FRAME_TYPES);\n\tif (!nl_ifs)\n\t\treturn -ENOBUFS;\n\n\tfor (ift = 0; ift < NUM_NL80211_IFTYPES; ift++) {\n\t\tnl_ftypes = nla_nest_start_noflag(msg, ift);\n\t\tif (!nl_ftypes)\n\t\t\treturn -ENOBUFS;\n\t\ti = 0;\n\t\tstypes = mgmt_stypes[ift].rx;\n\t\twhile (stypes) {\n\t\t\tif ((stypes & 1) &&\n\t\t\t    nla_put_u16(msg, NL80211_ATTR_FRAME_TYPE,\n\t\t\t\t\t(i << 4) | IEEE80211_FTYPE_MGMT))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tstypes >>= 1;\n\t\t\ti++;\n\t\t}\n\t\tnla_nest_end(msg, nl_ftypes);\n\t}\n\tnla_nest_end(msg, nl_ifs);\n\n\treturn 0;\n}\n\n#define CMD(op, n)\t\t\t\t\t\t\t\\\n\t do {\t\t\t\t\t\t\t\t\\\n\t\tif (rdev->ops->op) {\t\t\t\t\t\\\n\t\t\ti++;\t\t\t\t\t\t\\\n\t\t\tif (nla_put_u32(msg, i, NL80211_CMD_ ## n)) \t\\\n\t\t\t\tgoto nla_put_failure;\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic int nl80211_add_commands_unsplit(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct sk_buff *msg)\n{\n\tint i = 0;\n\n\t \n\tCMD(add_virtual_intf, NEW_INTERFACE);\n\tCMD(change_virtual_intf, SET_INTERFACE);\n\tCMD(add_key, NEW_KEY);\n\tCMD(start_ap, START_AP);\n\tCMD(add_station, NEW_STATION);\n\tCMD(add_mpath, NEW_MPATH);\n\tCMD(update_mesh_config, SET_MESH_CONFIG);\n\tCMD(change_bss, SET_BSS);\n\tCMD(auth, AUTHENTICATE);\n\tCMD(assoc, ASSOCIATE);\n\tCMD(deauth, DEAUTHENTICATE);\n\tCMD(disassoc, DISASSOCIATE);\n\tCMD(join_ibss, JOIN_IBSS);\n\tCMD(join_mesh, JOIN_MESH);\n\tCMD(set_pmksa, SET_PMKSA);\n\tCMD(del_pmksa, DEL_PMKSA);\n\tCMD(flush_pmksa, FLUSH_PMKSA);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL)\n\t\tCMD(remain_on_channel, REMAIN_ON_CHANNEL);\n\tCMD(set_bitrate_mask, SET_TX_BITRATE_MASK);\n\tCMD(mgmt_tx, FRAME);\n\tCMD(mgmt_tx_cancel_wait, FRAME_WAIT_CANCEL);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_NETNS_OK) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_SET_WIPHY_NETNS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rdev->ops->set_monitor_channel || rdev->ops->start_ap ||\n\t    rdev->ops->join_mesh) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_SET_CHANNEL))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) {\n\t\tCMD(tdls_mgmt, TDLS_MGMT);\n\t\tCMD(tdls_oper, TDLS_OPER);\n\t}\n\tif (rdev->wiphy.max_sched_scan_reqs)\n\t\tCMD(sched_scan_start, START_SCHED_SCAN);\n\tCMD(probe_client, PROBE_CLIENT);\n\tCMD(set_noack_map, SET_NOACK_MAP);\n\tif (rdev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_REGISTER_BEACONS))\n\t\t\tgoto nla_put_failure;\n\t}\n\tCMD(start_p2p_device, START_P2P_DEVICE);\n\tCMD(set_mcast_rate, SET_MCAST_RATE);\n#ifdef CONFIG_NL80211_TESTMODE\n\tCMD(testmode_cmd, TESTMODE);\n#endif\n\n\tif (rdev->ops->connect || rdev->ops->auth) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_CONNECT))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rdev->ops->disconnect || rdev->ops->deauth) {\n\t\ti++;\n\t\tif (nla_put_u32(msg, i, NL80211_CMD_DISCONNECT))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn i;\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int\nnl80211_send_pmsr_ftm_capa(const struct cfg80211_pmsr_capabilities *cap,\n\t\t\t   struct sk_buff *msg)\n{\n\tstruct nlattr *ftm;\n\n\tif (!cap->ftm.supported)\n\t\treturn 0;\n\n\tftm = nla_nest_start_noflag(msg, NL80211_PMSR_TYPE_FTM);\n\tif (!ftm)\n\t\treturn -ENOBUFS;\n\n\tif (cap->ftm.asap && nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_ASAP))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.non_asap &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.request_lci &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.request_civicloc &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES,\n\t\t\tcap->ftm.preambles))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS,\n\t\t\tcap->ftm.bandwidths))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.max_bursts_exponent >= 0 &&\n\t    nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT,\n\t\t\tcap->ftm.max_bursts_exponent))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.max_ftms_per_burst &&\n\t    nla_put_u32(msg, NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST,\n\t\t\tcap->ftm.max_ftms_per_burst))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.trigger_based &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED))\n\t\treturn -ENOBUFS;\n\tif (cap->ftm.non_trigger_based &&\n\t    nla_put_flag(msg, NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, ftm);\n\treturn 0;\n}\n\nstatic int nl80211_send_pmsr_capa(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct sk_buff *msg)\n{\n\tconst struct cfg80211_pmsr_capabilities *cap = rdev->wiphy.pmsr_capa;\n\tstruct nlattr *pmsr, *caps;\n\n\tif (!cap)\n\t\treturn 0;\n\n\t \n\n\tpmsr = nla_nest_start_noflag(msg, NL80211_ATTR_PEER_MEASUREMENTS);\n\tif (!pmsr)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_PMSR_ATTR_MAX_PEERS, cap->max_peers))\n\t\treturn -ENOBUFS;\n\n\tif (cap->report_ap_tsf &&\n\t    nla_put_flag(msg, NL80211_PMSR_ATTR_REPORT_AP_TSF))\n\t\treturn -ENOBUFS;\n\n\tif (cap->randomize_mac_addr &&\n\t    nla_put_flag(msg, NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR))\n\t\treturn -ENOBUFS;\n\n\tcaps = nla_nest_start_noflag(msg, NL80211_PMSR_ATTR_TYPE_CAPA);\n\tif (!caps)\n\t\treturn -ENOBUFS;\n\n\tif (nl80211_send_pmsr_ftm_capa(cap, msg))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, caps);\n\tnla_nest_end(msg, pmsr);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_put_iftype_akm_suites(struct cfg80211_registered_device *rdev,\n\t\t\t      struct sk_buff *msg)\n{\n\tint i;\n\tstruct nlattr *nested, *nested_akms;\n\tconst struct wiphy_iftype_akm_suites *iftype_akms;\n\n\tif (!rdev->wiphy.num_iftype_akm_suites ||\n\t    !rdev->wiphy.iftype_akm_suites)\n\t\treturn 0;\n\n\tnested = nla_nest_start(msg, NL80211_ATTR_IFTYPE_AKM_SUITES);\n\tif (!nested)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < rdev->wiphy.num_iftype_akm_suites; i++) {\n\t\tnested_akms = nla_nest_start(msg, i + 1);\n\t\tif (!nested_akms)\n\t\t\treturn -ENOBUFS;\n\n\t\tiftype_akms = &rdev->wiphy.iftype_akm_suites[i];\n\n\t\tif (nl80211_put_iftypes(msg, NL80211_IFTYPE_AKM_ATTR_IFTYPES,\n\t\t\t\t\tiftype_akms->iftypes_mask))\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put(msg, NL80211_IFTYPE_AKM_ATTR_SUITES,\n\t\t\t    sizeof(u32) * iftype_akms->n_akm_suites,\n\t\t\t    iftype_akms->akm_suites)) {\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tnla_nest_end(msg, nested_akms);\n\t}\n\n\tnla_nest_end(msg, nested);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_put_tid_config_support(struct cfg80211_registered_device *rdev,\n\t\t\t       struct sk_buff *msg)\n{\n\tstruct nlattr *supp;\n\n\tif (!rdev->wiphy.tid_config_support.vif &&\n\t    !rdev->wiphy.tid_config_support.peer)\n\t\treturn 0;\n\n\tsupp = nla_nest_start(msg, NL80211_ATTR_TID_CONFIG);\n\tif (!supp)\n\t\treturn -ENOSPC;\n\n\tif (rdev->wiphy.tid_config_support.vif &&\n\t    nla_put_u64_64bit(msg, NL80211_TID_CONFIG_ATTR_VIF_SUPP,\n\t\t\t      rdev->wiphy.tid_config_support.vif,\n\t\t\t      NL80211_TID_CONFIG_ATTR_PAD))\n\t\tgoto fail;\n\n\tif (rdev->wiphy.tid_config_support.peer &&\n\t    nla_put_u64_64bit(msg, NL80211_TID_CONFIG_ATTR_PEER_SUPP,\n\t\t\t      rdev->wiphy.tid_config_support.peer,\n\t\t\t      NL80211_TID_CONFIG_ATTR_PAD))\n\t\tgoto fail;\n\n\t \n\tif (nla_put_u8(msg, NL80211_TID_CONFIG_ATTR_RETRY_SHORT,\n\t\t       rdev->wiphy.tid_config_support.max_retry))\n\t\tgoto fail;\n\tif (nla_put_u8(msg, NL80211_TID_CONFIG_ATTR_RETRY_LONG,\n\t\t       rdev->wiphy.tid_config_support.max_retry))\n\t\tgoto fail;\n\n\tnla_nest_end(msg, supp);\n\n\treturn 0;\nfail:\n\tnla_nest_cancel(msg, supp);\n\treturn -ENOBUFS;\n}\n\nstatic int\nnl80211_put_sar_specs(struct cfg80211_registered_device *rdev,\n\t\t      struct sk_buff *msg)\n{\n\tstruct nlattr *sar_capa, *specs, *sub_freq_range;\n\tu8 num_freq_ranges;\n\tint i;\n\n\tif (!rdev->wiphy.sar_capa)\n\t\treturn 0;\n\n\tnum_freq_ranges = rdev->wiphy.sar_capa->num_freq_ranges;\n\n\tsar_capa = nla_nest_start(msg, NL80211_ATTR_SAR_SPEC);\n\tif (!sar_capa)\n\t\treturn -ENOSPC;\n\n\tif (nla_put_u32(msg, NL80211_SAR_ATTR_TYPE, rdev->wiphy.sar_capa->type))\n\t\tgoto fail;\n\n\tspecs = nla_nest_start(msg, NL80211_SAR_ATTR_SPECS);\n\tif (!specs)\n\t\tgoto fail;\n\n\t \n\tfor (i = 0; i < num_freq_ranges; i++) {\n\t\tsub_freq_range = nla_nest_start(msg, i + 1);\n\t\tif (!sub_freq_range)\n\t\t\tgoto fail;\n\n\t\tif (nla_put_u32(msg, NL80211_SAR_ATTR_SPECS_START_FREQ,\n\t\t\t\trdev->wiphy.sar_capa->freq_ranges[i].start_freq))\n\t\t\tgoto fail;\n\n\t\tif (nla_put_u32(msg, NL80211_SAR_ATTR_SPECS_END_FREQ,\n\t\t\t\trdev->wiphy.sar_capa->freq_ranges[i].end_freq))\n\t\t\tgoto fail;\n\n\t\tnla_nest_end(msg, sub_freq_range);\n\t}\n\n\tnla_nest_end(msg, specs);\n\tnla_nest_end(msg, sar_capa);\n\n\treturn 0;\nfail:\n\tnla_nest_cancel(msg, sar_capa);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_put_mbssid_support(struct wiphy *wiphy, struct sk_buff *msg)\n{\n\tstruct nlattr *config;\n\n\tif (!wiphy->mbssid_max_interfaces)\n\t\treturn 0;\n\n\tconfig = nla_nest_start(msg, NL80211_ATTR_MBSSID_CONFIG);\n\tif (!config)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u8(msg, NL80211_MBSSID_CONFIG_ATTR_MAX_INTERFACES,\n\t\t       wiphy->mbssid_max_interfaces))\n\t\tgoto fail;\n\n\tif (wiphy->ema_max_profile_periodicity &&\n\t    nla_put_u8(msg,\n\t\t       NL80211_MBSSID_CONFIG_ATTR_MAX_EMA_PROFILE_PERIODICITY,\n\t\t       wiphy->ema_max_profile_periodicity))\n\t\tgoto fail;\n\n\tnla_nest_end(msg, config);\n\treturn 0;\n\nfail:\n\tnla_nest_cancel(msg, config);\n\treturn -ENOBUFS;\n}\n\nstruct nl80211_dump_wiphy_state {\n\ts64 filter_wiphy;\n\tlong start;\n\tlong split_start, band_start, chan_start, capa_start;\n\tbool split;\n};\n\nstatic int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,\n\t\t\t      enum nl80211_commands cmd,\n\t\t\t      struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t      int flags, struct nl80211_dump_wiphy_state *state)\n{\n\tvoid *hdr;\n\tstruct nlattr *nl_bands, *nl_band;\n\tstruct nlattr *nl_freqs, *nl_freq;\n\tstruct nlattr *nl_cmds;\n\tenum nl80211_band band;\n\tstruct ieee80211_channel *chan;\n\tint i;\n\tconst struct ieee80211_txrx_stypes *mgmt_stypes =\n\t\t\t\trdev->wiphy.mgmt_stypes;\n\tu32 features;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -ENOBUFS;\n\n\tif (WARN_ON(!state))\n\t\treturn -EINVAL;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_string(msg, NL80211_ATTR_WIPHY_NAME,\n\t\t\t   wiphy_name(&rdev->wiphy)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION,\n\t\t\tcfg80211_rdev_list_generation))\n\t\tgoto nla_put_failure;\n\n\tif (cmd != NL80211_CMD_NEW_WIPHY)\n\t\tgoto finish;\n\n\tswitch (state->split_start) {\n\tcase 0:\n\t\tif (nla_put_u8(msg, NL80211_ATTR_WIPHY_RETRY_SHORT,\n\t\t\t       rdev->wiphy.retry_short) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_WIPHY_RETRY_LONG,\n\t\t\t       rdev->wiphy.retry_long) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FRAG_THRESHOLD,\n\t\t\t\trdev->wiphy.frag_threshold) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_RTS_THRESHOLD,\n\t\t\t\trdev->wiphy.rts_threshold) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_WIPHY_COVERAGE_CLASS,\n\t\t\t       rdev->wiphy.coverage_class) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_NUM_SCAN_SSIDS,\n\t\t\t       rdev->wiphy.max_scan_ssids) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS,\n\t\t\t       rdev->wiphy.max_sched_scan_ssids) ||\n\t\t    nla_put_u16(msg, NL80211_ATTR_MAX_SCAN_IE_LEN,\n\t\t\t\trdev->wiphy.max_scan_ie_len) ||\n\t\t    nla_put_u16(msg, NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN,\n\t\t\t\trdev->wiphy.max_sched_scan_ie_len) ||\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_MATCH_SETS,\n\t\t\t       rdev->wiphy.max_match_sets))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_IBSS_RSN))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_MESH_AUTH) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_MESH_AUTH))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_AP_UAPSD) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_SUPPORT_AP_UAPSD))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_FW_ROAM) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_ROAM_SUPPORT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_TDLS_SUPPORT))\n\t\t\tgoto nla_put_failure;\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_TDLS_EXTERNAL_SETUP))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 1:\n\t\tif (nla_put(msg, NL80211_ATTR_CIPHER_SUITES,\n\t\t\t    sizeof(u32) * rdev->wiphy.n_cipher_suites,\n\t\t\t    rdev->wiphy.cipher_suites))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u8(msg, NL80211_ATTR_MAX_NUM_PMKIDS,\n\t\t\t       rdev->wiphy.max_num_pmkids))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX,\n\t\t\t\trdev->wiphy.available_antennas_tx) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX,\n\t\t\t\trdev->wiphy.available_antennas_rx))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD) &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_PROBE_RESP_OFFLOAD,\n\t\t\t\trdev->wiphy.probe_resp_offload))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.available_antennas_tx ||\n\t\t     rdev->wiphy.available_antennas_rx) &&\n\t\t    rdev->ops->get_antenna) {\n\t\t\tu32 tx_ant = 0, rx_ant = 0;\n\t\t\tint res;\n\n\t\t\tres = rdev_get_antenna(rdev, &tx_ant, &rx_ant);\n\t\t\tif (!res) {\n\t\t\t\tif (nla_put_u32(msg,\n\t\t\t\t\t\tNL80211_ATTR_WIPHY_ANTENNA_TX,\n\t\t\t\t\t\ttx_ant) ||\n\t\t\t\t    nla_put_u32(msg,\n\t\t\t\t\t\tNL80211_ATTR_WIPHY_ANTENNA_RX,\n\t\t\t\t\t\trx_ant))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 2:\n\t\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SUPPORTED_IFTYPES,\n\t\t\t\t\trdev->wiphy.interface_modes))\n\t\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 3:\n\t\tnl_bands = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t NL80211_ATTR_WIPHY_BANDS);\n\t\tif (!nl_bands)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (band = state->band_start;\n\t\t     band < (state->split ?\n\t\t\t\tNUM_NL80211_BANDS :\n\t\t\t\tNL80211_BAND_60GHZ + 1);\n\t\t     band++) {\n\t\t\tstruct ieee80211_supported_band *sband;\n\n\t\t\t \n\t\t\tif (band > NL80211_BAND_5GHZ && !state->split)\n\t\t\t\tbreak;\n\n\t\t\tsband = rdev->wiphy.bands[band];\n\n\t\t\tif (!sband)\n\t\t\t\tcontinue;\n\n\t\t\tnl_band = nla_nest_start_noflag(msg, band);\n\t\t\tif (!nl_band)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tswitch (state->chan_start) {\n\t\t\tcase 0:\n\t\t\t\tif (nl80211_send_band_rateinfo(msg, sband,\n\t\t\t\t\t\t\t       state->split))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\tstate->chan_start++;\n\t\t\t\tif (state->split)\n\t\t\t\t\tbreak;\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tnl_freqs = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t NL80211_BAND_ATTR_FREQS);\n\t\t\t\tif (!nl_freqs)\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\tfor (i = state->chan_start - 1;\n\t\t\t\t     i < sband->n_channels;\n\t\t\t\t     i++) {\n\t\t\t\t\tnl_freq = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t\ti);\n\t\t\t\t\tif (!nl_freq)\n\t\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\t\tchan = &sband->channels[i];\n\n\t\t\t\t\tif (nl80211_msg_put_channel(\n\t\t\t\t\t\t\tmsg, &rdev->wiphy, chan,\n\t\t\t\t\t\t\tstate->split))\n\t\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\t\tnla_nest_end(msg, nl_freq);\n\t\t\t\t\tif (state->split)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i < sband->n_channels)\n\t\t\t\t\tstate->chan_start = i + 2;\n\t\t\t\telse\n\t\t\t\t\tstate->chan_start = 0;\n\t\t\t\tnla_nest_end(msg, nl_freqs);\n\t\t\t}\n\n\t\t\tnla_nest_end(msg, nl_band);\n\n\t\t\tif (state->split) {\n\t\t\t\t \n\t\t\t\tif (state->chan_start)\n\t\t\t\t\tband--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnla_nest_end(msg, nl_bands);\n\n\t\tif (band < NUM_NL80211_BANDS)\n\t\t\tstate->band_start = band + 1;\n\t\telse\n\t\t\tstate->band_start = 0;\n\n\t\t \n\t\tif (state->band_start == 0 && state->chan_start == 0)\n\t\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 4:\n\t\tnl_cmds = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_SUPPORTED_COMMANDS);\n\t\tif (!nl_cmds)\n\t\t\tgoto nla_put_failure;\n\n\t\ti = nl80211_add_commands_unsplit(rdev, msg);\n\t\tif (i < 0)\n\t\t\tgoto nla_put_failure;\n\t\tif (state->split) {\n\t\t\tCMD(crit_proto_start, CRIT_PROTOCOL_START);\n\t\t\tCMD(crit_proto_stop, CRIT_PROTOCOL_STOP);\n\t\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH)\n\t\t\t\tCMD(channel_switch, CHANNEL_SWITCH);\n\t\t\tCMD(set_qos_map, SET_QOS_MAP);\n\t\t\tif (rdev->wiphy.features &\n\t\t\t\t\tNL80211_FEATURE_SUPPORTS_WMM_ADMISSION)\n\t\t\t\tCMD(add_tx_ts, ADD_TX_TS);\n\t\t\tCMD(set_multicast_to_unicast, SET_MULTICAST_TO_UNICAST);\n\t\t\tCMD(update_connect_params, UPDATE_CONNECT_PARAMS);\n\t\t\tCMD(update_ft_ies, UPDATE_FT_IES);\n\t\t\tif (rdev->wiphy.sar_capa)\n\t\t\t\tCMD(set_sar_specs, SET_SAR_SPECS);\n\t\t}\n#undef CMD\n\n\t\tnla_nest_end(msg, nl_cmds);\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 5:\n\t\tif (rdev->ops->remain_on_channel &&\n\t\t    (rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL) &&\n\t\t    nla_put_u32(msg,\n\t\t\t\tNL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION,\n\t\t\t\trdev->wiphy.max_remain_on_channel_duration))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX) &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_OFFCHANNEL_TX_OK))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 6:\n#ifdef CONFIG_PM\n\t\tif (nl80211_send_wowlan(msg, rdev, state->split))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n#else\n\t\tstate->split_start++;\n#endif\n\t\tfallthrough;\n\tcase 7:\n\t\tif (nl80211_put_iftypes(msg, NL80211_ATTR_SOFTWARE_IFTYPES,\n\t\t\t\t\trdev->wiphy.software_iftypes))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_put_iface_combinations(&rdev->wiphy, msg,\n\t\t\t\t\t\t   state->split))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tif (state->split)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase 8:\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME) &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_DEVICE_AP_SME,\n\t\t\t\trdev->wiphy.ap_sme_capa))\n\t\t\tgoto nla_put_failure;\n\n\t\tfeatures = rdev->wiphy.features;\n\t\t \n\t\tif (state->split)\n\t\t\tfeatures |= NL80211_FEATURE_ADVERTISE_CHAN_LIMITS;\n\t\tif (nla_put_u32(msg, NL80211_ATTR_FEATURE_FLAGS, features))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.ht_capa_mod_mask &&\n\t\t    nla_put(msg, NL80211_ATTR_HT_CAPABILITY_MASK,\n\t\t\t    sizeof(*rdev->wiphy.ht_capa_mod_mask),\n\t\t\t    rdev->wiphy.ht_capa_mod_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME &&\n\t\t    rdev->wiphy.max_acl_mac_addrs &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAC_ACL_MAX,\n\t\t\t\trdev->wiphy.max_acl_mac_addrs))\n\t\t\tgoto nla_put_failure;\n\n\t\t \n\t\tif (state->split)\n\t\t\tstate->split_start++;\n\t\telse\n\t\t\tstate->split_start = 0;\n\t\tbreak;\n\tcase 9:\n\t\tif (nl80211_send_mgmt_stypes(msg, mgmt_stypes))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_MAX_NUM_SCHED_SCAN_PLANS,\n\t\t\t\trdev->wiphy.max_sched_scan_plans) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_SCAN_PLAN_INTERVAL,\n\t\t\t\trdev->wiphy.max_sched_scan_plan_interval) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS,\n\t\t\t\trdev->wiphy.max_sched_scan_plan_iterations))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.extended_capabilities &&\n\t\t    (nla_put(msg, NL80211_ATTR_EXT_CAPA,\n\t\t\t     rdev->wiphy.extended_capabilities_len,\n\t\t\t     rdev->wiphy.extended_capabilities) ||\n\t\t     nla_put(msg, NL80211_ATTR_EXT_CAPA_MASK,\n\t\t\t     rdev->wiphy.extended_capabilities_len,\n\t\t\t     rdev->wiphy.extended_capabilities_mask)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.vht_capa_mod_mask &&\n\t\t    nla_put(msg, NL80211_ATTR_VHT_CAPABILITY_MASK,\n\t\t\t    sizeof(*rdev->wiphy.vht_capa_mod_mask),\n\t\t\t    rdev->wiphy.vht_capa_mod_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN,\n\t\t\t    rdev->wiphy.perm_addr))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (!is_zero_ether_addr(rdev->wiphy.addr_mask) &&\n\t\t    nla_put(msg, NL80211_ATTR_MAC_MASK, ETH_ALEN,\n\t\t\t    rdev->wiphy.addr_mask))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.n_addresses > 1) {\n\t\t\tvoid *attr;\n\n\t\t\tattr = nla_nest_start(msg, NL80211_ATTR_MAC_ADDRS);\n\t\t\tif (!attr)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_addresses; i++)\n\t\t\t\tif (nla_put(msg, i + 1, ETH_ALEN,\n\t\t\t\t\t    rdev->wiphy.addresses[i].addr))\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, attr);\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 10:\n\t\tif (nl80211_send_coalesce(msg, rdev))\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_5_10_MHZ) &&\n\t\t    (nla_put_flag(msg, NL80211_ATTR_SUPPORT_5_MHZ) ||\n\t\t     nla_put_flag(msg, NL80211_ATTR_SUPPORT_10_MHZ)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.max_ap_assoc_sta &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_MAX_AP_ASSOC_STA,\n\t\t\t\trdev->wiphy.max_ap_assoc_sta))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 11:\n\t\tif (rdev->wiphy.n_vendor_commands) {\n\t\t\tconst struct nl80211_vendor_cmd_info *info;\n\t\t\tstruct nlattr *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_VENDOR_DATA);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {\n\t\t\t\tinfo = &rdev->wiphy.vendor_commands[i].info;\n\t\t\t\tif (nla_put(msg, i + 1, sizeof(*info), info))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\n\t\tif (rdev->wiphy.n_vendor_events) {\n\t\t\tconst struct nl80211_vendor_cmd_info *info;\n\t\t\tstruct nlattr *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_VENDOR_EVENTS);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = 0; i < rdev->wiphy.n_vendor_events; i++) {\n\t\t\t\tinfo = &rdev->wiphy.vendor_events[i];\n\t\t\t\tif (nla_put(msg, i + 1, sizeof(*info), info))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 12:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH &&\n\t\t    nla_put_u8(msg, NL80211_ATTR_MAX_CSA_COUNTERS,\n\t\t\t       rdev->wiphy.max_num_csa_counters))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.max_sched_scan_reqs &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_MAX_REQS,\n\t\t\t\trdev->wiphy.max_sched_scan_reqs))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put(msg, NL80211_ATTR_EXT_FEATURES,\n\t\t\t    sizeof(rdev->wiphy.ext_features),\n\t\t\t    rdev->wiphy.ext_features))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.bss_select_support) {\n\t\t\tstruct nlattr *nested;\n\t\t\tu32 bss_select_support = rdev->wiphy.bss_select_support;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_BSS_SELECT);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\ti = 0;\n\t\t\twhile (bss_select_support) {\n\t\t\t\tif ((bss_select_support & 1) &&\n\t\t\t\t    nla_put_flag(msg, i))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t\ti++;\n\t\t\t\tbss_select_support >>= 1;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 13:\n\t\tif (rdev->wiphy.num_iftype_ext_capab &&\n\t\t    rdev->wiphy.iftype_ext_capab) {\n\t\t\tstruct nlattr *nested_ext_capab, *nested;\n\n\t\t\tnested = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t       NL80211_ATTR_IFTYPE_EXT_CAPA);\n\t\t\tif (!nested)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tfor (i = state->capa_start;\n\t\t\t     i < rdev->wiphy.num_iftype_ext_capab; i++) {\n\t\t\t\tconst struct wiphy_iftype_ext_capab *capab;\n\n\t\t\t\tcapab = &rdev->wiphy.iftype_ext_capab[i];\n\n\t\t\t\tnested_ext_capab = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t\t\t i);\n\t\t\t\tif (!nested_ext_capab ||\n\t\t\t\t    nla_put_u32(msg, NL80211_ATTR_IFTYPE,\n\t\t\t\t\t\tcapab->iftype) ||\n\t\t\t\t    nla_put(msg, NL80211_ATTR_EXT_CAPA,\n\t\t\t\t\t    capab->extended_capabilities_len,\n\t\t\t\t\t    capab->extended_capabilities) ||\n\t\t\t\t    nla_put(msg, NL80211_ATTR_EXT_CAPA_MASK,\n\t\t\t\t\t    capab->extended_capabilities_len,\n\t\t\t\t\t    capab->extended_capabilities_mask))\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\tif (rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_MLO &&\n\t\t\t\t    (nla_put_u16(msg,\n\t\t\t\t\t\t NL80211_ATTR_EML_CAPABILITY,\n\t\t\t\t\t\t capab->eml_capabilities) ||\n\t\t\t\t     nla_put_u16(msg,\n\t\t\t\t\t\t NL80211_ATTR_MLD_CAPA_AND_OPS,\n\t\t\t\t\t\t capab->mld_capa_and_ops)))\n\t\t\t\t\tgoto nla_put_failure;\n\n\t\t\t\tnla_nest_end(msg, nested_ext_capab);\n\t\t\t\tif (state->split)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnla_nest_end(msg, nested);\n\t\t\tif (i < rdev->wiphy.num_iftype_ext_capab) {\n\t\t\t\tstate->capa_start = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_BANDS,\n\t\t\t\trdev->wiphy.nan_supported_bands))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tstruct cfg80211_txq_stats txqstats = {};\n\t\t\tint res;\n\n\t\t\tres = rdev_get_txq_stats(rdev, NULL, &txqstats);\n\t\t\tif (!res &&\n\t\t\t    !nl80211_put_txq_stats(msg, &txqstats,\n\t\t\t\t\t\t   NL80211_ATTR_TXQ_STATS))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_LIMIT,\n\t\t\t\t\trdev->wiphy.txq_limit))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_MEMORY_LIMIT,\n\t\t\t\t\trdev->wiphy.txq_memory_limit))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put_u32(msg, NL80211_ATTR_TXQ_QUANTUM,\n\t\t\t\t\trdev->wiphy.txq_quantum))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 14:\n\t\tif (nl80211_send_pmsr_capa(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 15:\n\t\tif (rdev->wiphy.akm_suites &&\n\t\t    nla_put(msg, NL80211_ATTR_AKM_SUITES,\n\t\t\t    sizeof(u32) * rdev->wiphy.n_akm_suites,\n\t\t\t    rdev->wiphy.akm_suites))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_put_iftype_akm_suites(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_put_tid_config_support(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\t\tstate->split_start++;\n\t\tbreak;\n\tcase 16:\n\t\tif (nl80211_put_sar_specs(rdev, msg))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_put_mbssid_support(&rdev->wiphy, msg))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u16(msg, NL80211_ATTR_MAX_NUM_AKM_SUITES,\n\t\t\t\trdev->wiphy.max_num_akm_suites))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_MLO)\n\t\t\tnla_put_flag(msg, NL80211_ATTR_MLO_SUPPORT);\n\n\t\tif (rdev->wiphy.hw_timestamp_max_peers &&\n\t\t    nla_put_u16(msg, NL80211_ATTR_MAX_HW_TIMESTAMP_PEERS,\n\t\t\t\trdev->wiphy.hw_timestamp_max_peers))\n\t\t\tgoto nla_put_failure;\n\n\t\t \n\t\tstate->split_start = 0;\n\t\tbreak;\n\t}\n finish:\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_wiphy_parse(struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb,\n\t\t\t\t    struct nl80211_dump_wiphy_state *state)\n{\n\tstruct nlattr **tb = kcalloc(NUM_NL80211_ATTR, sizeof(*tb), GFP_KERNEL);\n\tint ret;\n\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t     tb, nl80211_fam.maxattr,\n\t\t\t\t     nl80211_policy, NULL);\n\t \n\tif (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tstate->split = tb[NL80211_ATTR_SPLIT_WIPHY_DUMP];\n\tif (tb[NL80211_ATTR_WIPHY])\n\t\tstate->filter_wiphy = nla_get_u32(tb[NL80211_ATTR_WIPHY]);\n\tif (tb[NL80211_ATTR_WDEV])\n\t\tstate->filter_wiphy = nla_get_u64(tb[NL80211_ATTR_WDEV]) >> 32;\n\tif (tb[NL80211_ATTR_IFINDEX]) {\n\t\tstruct net_device *netdev;\n\t\tstruct cfg80211_registered_device *rdev;\n\t\tint ifidx = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(sock_net(skb->sk), ifidx);\n\t\tif (!netdev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tif (netdev->ieee80211_ptr) {\n\t\t\trdev = wiphy_to_rdev(\n\t\t\t\tnetdev->ieee80211_ptr->wiphy);\n\t\t\tstate->filter_wiphy = rdev->wiphy_idx;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tkfree(tb);\n\treturn ret;\n}\n\nstatic int nl80211_dump_wiphy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx = 0, ret;\n\tstruct nl80211_dump_wiphy_state *state = (void *)cb->args[0];\n\tstruct cfg80211_registered_device *rdev;\n\n\trtnl_lock();\n\tif (!state) {\n\t\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\t\tif (!state) {\n\t\t\trtnl_unlock();\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tstate->filter_wiphy = -1;\n\t\tret = nl80211_dump_wiphy_parse(skb, cb, state);\n\t\tif (ret) {\n\t\t\tkfree(state);\n\t\t\trtnl_unlock();\n\t\t\treturn ret;\n\t\t}\n\t\tcb->args[0] = (long)state;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (++idx <= state->start)\n\t\t\tcontinue;\n\t\tif (state->filter_wiphy != -1 &&\n\t\t    state->filter_wiphy != rdev->wiphy_idx)\n\t\t\tcontinue;\n\t\twiphy_lock(&rdev->wiphy);\n\t\t \n\t\tdo {\n\t\t\tret = nl80211_send_wiphy(rdev, NL80211_CMD_NEW_WIPHY,\n\t\t\t\t\t\t skb,\n\t\t\t\t\t\t NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t NLM_F_MULTI, state);\n\t\t\tif (ret < 0) {\n\t\t\t\t \n\t\t\t\tif ((ret == -ENOBUFS || ret == -EMSGSIZE) &&\n\t\t\t\t    !skb->len && !state->split &&\n\t\t\t\t    cb->min_dump_alloc < 4096) {\n\t\t\t\t\tcb->min_dump_alloc = 4096;\n\t\t\t\t\tstate->split_start = 0;\n\t\t\t\t\twiphy_unlock(&rdev->wiphy);\n\t\t\t\t\trtnl_unlock();\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tidx--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (state->split_start > 0);\n\t\twiphy_unlock(&rdev->wiphy);\n\t\tbreak;\n\t}\n\trtnl_unlock();\n\n\tstate->start = idx;\n\n\treturn skb->len;\n}\n\nstatic int nl80211_dump_wiphy_done(struct netlink_callback *cb)\n{\n\tkfree((void *)cb->args[0]);\n\treturn 0;\n}\n\nstatic int nl80211_get_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nl80211_dump_wiphy_state state = {};\n\n\tmsg = nlmsg_new(4096, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_wiphy(rdev, NL80211_CMD_NEW_WIPHY, msg,\n\t\t\t       info->snd_portid, info->snd_seq, 0,\n\t\t\t       &state) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy txq_params_policy[NL80211_TXQ_ATTR_MAX + 1] = {\n\t[NL80211_TXQ_ATTR_QUEUE]\t\t= { .type = NLA_U8 },\n\t[NL80211_TXQ_ATTR_TXOP]\t\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMIN]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_CWMAX]\t\t= { .type = NLA_U16 },\n\t[NL80211_TXQ_ATTR_AIFS]\t\t\t= { .type = NLA_U8 },\n};\n\nstatic int parse_txq_params(struct nlattr *tb[],\n\t\t\t    struct ieee80211_txq_params *txq_params)\n{\n\tu8 ac;\n\n\tif (!tb[NL80211_TXQ_ATTR_AC] || !tb[NL80211_TXQ_ATTR_TXOP] ||\n\t    !tb[NL80211_TXQ_ATTR_CWMIN] || !tb[NL80211_TXQ_ATTR_CWMAX] ||\n\t    !tb[NL80211_TXQ_ATTR_AIFS])\n\t\treturn -EINVAL;\n\n\tac = nla_get_u8(tb[NL80211_TXQ_ATTR_AC]);\n\ttxq_params->txop = nla_get_u16(tb[NL80211_TXQ_ATTR_TXOP]);\n\ttxq_params->cwmin = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMIN]);\n\ttxq_params->cwmax = nla_get_u16(tb[NL80211_TXQ_ATTR_CWMAX]);\n\ttxq_params->aifs = nla_get_u8(tb[NL80211_TXQ_ATTR_AIFS]);\n\n\tif (ac >= NL80211_NUM_ACS)\n\t\treturn -EINVAL;\n\ttxq_params->ac = array_index_nospec(ac, NL80211_NUM_ACS);\n\treturn 0;\n}\n\nstatic bool nl80211_can_set_dev_channel(struct wireless_dev *wdev)\n{\n\t \n\treturn !wdev ||\n\t\twdev->iftype == NL80211_IFTYPE_AP ||\n\t\twdev->iftype == NL80211_IFTYPE_MESH_POINT ||\n\t\twdev->iftype == NL80211_IFTYPE_MONITOR ||\n\t\twdev->iftype == NL80211_IFTYPE_P2P_GO;\n}\n\nstatic int nl80211_parse_punct_bitmap(struct cfg80211_registered_device *rdev,\n\t\t\t\t      struct genl_info *info,\n\t\t\t\t      const struct cfg80211_chan_def *chandef,\n\t\t\t\t      u16 *punct_bitmap)\n{\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy, NL80211_EXT_FEATURE_PUNCT))\n\t\treturn -EINVAL;\n\n\t*punct_bitmap = nla_get_u32(info->attrs[NL80211_ATTR_PUNCT_BITMAP]);\n\tif (!cfg80211_valid_disable_subchannel_bitmap(punct_bitmap, chandef))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint nl80211_parse_chandef(struct cfg80211_registered_device *rdev,\n\t\t\t  struct genl_info *info,\n\t\t\t  struct cfg80211_chan_def *chandef)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tstruct nlattr **attrs = info->attrs;\n\tu32 control_freq;\n\n\tif (!attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, attrs[NL80211_ATTR_WIPHY_FREQ],\n\t\t\t\t    \"Frequency is missing\");\n\t\treturn -EINVAL;\n\t}\n\n\tcontrol_freq = MHZ_TO_KHZ(\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET])\n\t\tcontrol_freq +=\n\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET]);\n\n\tmemset(chandef, 0, sizeof(*chandef));\n\tchandef->chan = ieee80211_get_channel_khz(&rdev->wiphy, control_freq);\n\tchandef->width = NL80211_CHAN_WIDTH_20_NOHT;\n\tchandef->center_freq1 = KHZ_TO_MHZ(control_freq);\n\tchandef->freq1_offset = control_freq % 1000;\n\tchandef->center_freq2 = 0;\n\n\t \n\tif (!chandef->chan || chandef->chan->flags & IEEE80211_CHAN_DISABLED) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, attrs[NL80211_ATTR_WIPHY_FREQ],\n\t\t\t\t    \"Channel is disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {\n\t\tenum nl80211_channel_type chantype;\n\n\t\tchantype = nla_get_u32(attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]);\n\n\t\tswitch (chantype) {\n\t\tcase NL80211_CHAN_NO_HT:\n\t\tcase NL80211_CHAN_HT20:\n\t\tcase NL80211_CHAN_HT40PLUS:\n\t\tcase NL80211_CHAN_HT40MINUS:\n\t\t\tcfg80211_chandef_create(chandef, chandef->chan,\n\t\t\t\t\t\tchantype);\n\t\t\t \n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1] &&\n\t\t\t    chandef->center_freq1 != nla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ1])) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t\t    attrs[NL80211_ATTR_CENTER_FREQ1],\n\t\t\t\t\t\t    \"bad center frequency 1\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ2] &&\n\t\t\t    nla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ2])) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t\t    attrs[NL80211_ATTR_CENTER_FREQ2],\n\t\t\t\t\t\t    \"center frequency 2 can't be used\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t    attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE],\n\t\t\t\t\t    \"invalid channel type\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (attrs[NL80211_ATTR_CHANNEL_WIDTH]) {\n\t\tchandef->width =\n\t\t\tnla_get_u32(attrs[NL80211_ATTR_CHANNEL_WIDTH]);\n\t\tif (chandef->chan->band == NL80211_BAND_S1GHZ) {\n\t\t\t \n\t\t\tif (chandef->width != ieee80211_s1g_channel_width(chandef->chan)) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack,\n\t\t\t\t\t\t    attrs[NL80211_ATTR_CHANNEL_WIDTH],\n\t\t\t\t\t\t    \"bad channel width\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1]) {\n\t\t\tchandef->center_freq1 =\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ1]);\n\t\t\tif (attrs[NL80211_ATTR_CENTER_FREQ1_OFFSET])\n\t\t\t\tchandef->freq1_offset = nla_get_u32(\n\t\t\t\t      attrs[NL80211_ATTR_CENTER_FREQ1_OFFSET]);\n\t\t\telse\n\t\t\t\tchandef->freq1_offset = 0;\n\t\t}\n\t\tif (attrs[NL80211_ATTR_CENTER_FREQ2])\n\t\t\tchandef->center_freq2 =\n\t\t\t\tnla_get_u32(attrs[NL80211_ATTR_CENTER_FREQ2]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]) {\n\t\tchandef->edmg.channels =\n\t\t      nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]);\n\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG])\n\t\t\tchandef->edmg.bw_config =\n\t\t     nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG]);\n\t} else {\n\t\tchandef->edmg.bw_config = 0;\n\t\tchandef->edmg.channels = 0;\n\t}\n\n\tif (!cfg80211_chandef_valid(chandef)) {\n\t\tNL_SET_ERR_MSG(extack, \"invalid channel definition\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cfg80211_chandef_usable(&rdev->wiphy, chandef,\n\t\t\t\t     IEEE80211_CHAN_DISABLED)) {\n\t\tNL_SET_ERR_MSG(extack, \"(extension) channel is disabled\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((chandef->width == NL80211_CHAN_WIDTH_5 ||\n\t     chandef->width == NL80211_CHAN_WIDTH_10) &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_5_10_MHZ)) {\n\t\tNL_SET_ERR_MSG(extack, \"5/10 MHz not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __nl80211_set_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *dev,\n\t\t\t\t struct genl_info *info,\n\t\t\t\t int _link_id)\n{\n\tstruct cfg80211_chan_def chandef;\n\tint result;\n\tenum nl80211_iftype iftype = NL80211_IFTYPE_MONITOR;\n\tstruct wireless_dev *wdev = NULL;\n\tint link_id = _link_id;\n\n\tif (dev)\n\t\twdev = dev->ieee80211_ptr;\n\tif (!nl80211_can_set_dev_channel(wdev))\n\t\treturn -EOPNOTSUPP;\n\tif (wdev)\n\t\tiftype = wdev->iftype;\n\n\tif (link_id < 0) {\n\t\tif (wdev && wdev->valid_links)\n\t\t\treturn -EINVAL;\n\t\tlink_id = 0;\n\t}\n\n\tresult = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (result)\n\t\treturn result;\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &chandef,\n\t\t\t\t\t\t   iftype))\n\t\t\treturn -EINVAL;\n\t\tif (wdev->links[link_id].ap.beacon_interval) {\n\t\t\tstruct ieee80211_channel *cur_chan;\n\n\t\t\tif (!dev || !rdev->ops->set_ap_chanwidth ||\n\t\t\t    !(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE))\n\t\t\t\treturn -EBUSY;\n\n\t\t\t \n\t\t\tcur_chan = wdev->links[link_id].ap.chandef.chan;\n\t\t\tif (chandef.chan != cur_chan)\n\t\t\t\treturn -EBUSY;\n\n\t\t\tresult = rdev_set_ap_chanwidth(rdev, dev, link_id,\n\t\t\t\t\t\t       &chandef);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t\twdev->links[link_id].ap.chandef = chandef;\n\t\t} else {\n\t\t\twdev->u.ap.preset_chandef = chandef;\n\t\t}\n\t\treturn 0;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn cfg80211_set_mesh_channel(rdev, wdev, &chandef);\n\tcase NL80211_IFTYPE_MONITOR:\n\t\treturn cfg80211_set_monitor_channel(rdev, &chandef);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int nl80211_set_channel(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint link_id = nl80211_link_id_or_invalid(info->attrs);\n\tstruct net_device *netdev = info->user_ptr[1];\n\tint ret;\n\n\twdev_lock(netdev->ieee80211_ptr);\n\tret = __nl80211_set_channel(rdev, netdev, info, link_id);\n\twdev_unlock(netdev->ieee80211_ptr);\n\n\treturn ret;\n}\n\nstatic int nl80211_set_wiphy(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = NULL;\n\tstruct net_device *netdev = NULL;\n\tstruct wireless_dev *wdev;\n\tint result = 0, rem_txq_params = 0;\n\tstruct nlattr *nl_txq_params;\n\tu32 changed;\n\tu8 retry_short = 0, retry_long = 0;\n\tu32 frag_threshold = 0, rts_threshold = 0;\n\tu8 coverage_class = 0;\n\tu32 txq_limit = 0, txq_memory_limit = 0, txq_quantum = 0;\n\n\trtnl_lock();\n\t \n\n\tif (info->attrs[NL80211_ATTR_IFINDEX]) {\n\t\tint ifindex = nla_get_u32(info->attrs[NL80211_ATTR_IFINDEX]);\n\n\t\tnetdev = __dev_get_by_index(genl_info_net(info), ifindex);\n\t\tif (netdev && netdev->ieee80211_ptr)\n\t\t\trdev = wiphy_to_rdev(netdev->ieee80211_ptr->wiphy);\n\t\telse\n\t\t\tnetdev = NULL;\n\t}\n\n\tif (!netdev) {\n\t\trdev = __cfg80211_rdev_from_attrs(genl_info_net(info),\n\t\t\t\t\t\t  info->attrs);\n\t\tif (IS_ERR(rdev)) {\n\t\t\trtnl_unlock();\n\t\t\treturn PTR_ERR(rdev);\n\t\t}\n\t\twdev = NULL;\n\t\tnetdev = NULL;\n\t\tresult = 0;\n\t} else\n\t\twdev = netdev->ieee80211_ptr;\n\n\twiphy_lock(&rdev->wiphy);\n\n\t \n\n\tif (info->attrs[NL80211_ATTR_WIPHY_NAME])\n\t\tresult = cfg80211_dev_rename(\n\t\t\trdev, nla_data(info->attrs[NL80211_ATTR_WIPHY_NAME]));\n\trtnl_unlock();\n\n\tif (result)\n\t\tgoto out;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS]) {\n\t\tstruct ieee80211_txq_params txq_params;\n\t\tstruct nlattr *tb[NL80211_TXQ_ATTR_MAX + 1];\n\n\t\tif (!rdev->ops->set_txq_params) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!netdev) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t\t    netdev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!netif_running(netdev)) {\n\t\t\tresult = -ENETDOWN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnla_for_each_nested(nl_txq_params,\n\t\t\t\t    info->attrs[NL80211_ATTR_WIPHY_TXQ_PARAMS],\n\t\t\t\t    rem_txq_params) {\n\t\t\tresult = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t     NL80211_TXQ_ATTR_MAX,\n\t\t\t\t\t\t\t     nl_txq_params,\n\t\t\t\t\t\t\t     txq_params_policy,\n\t\t\t\t\t\t\t     info->extack);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\t\t\tresult = parse_txq_params(tb, &txq_params);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\n\t\t\ttxq_params.link_id =\n\t\t\t\tnl80211_link_id_or_invalid(info->attrs);\n\n\t\t\twdev_lock(netdev->ieee80211_ptr);\n\t\t\tif (txq_params.link_id >= 0 &&\n\t\t\t    !(netdev->ieee80211_ptr->valid_links &\n\t\t\t      BIT(txq_params.link_id)))\n\t\t\t\tresult = -ENOLINK;\n\t\t\telse if (txq_params.link_id >= 0 &&\n\t\t\t\t !netdev->ieee80211_ptr->valid_links)\n\t\t\t\tresult = -EINVAL;\n\t\t\telse\n\t\t\t\tresult = rdev_set_txq_params(rdev, netdev,\n\t\t\t\t\t\t\t     &txq_params);\n\t\t\twdev_unlock(netdev->ieee80211_ptr);\n\t\t\tif (result)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\tint link_id = nl80211_link_id_or_invalid(info->attrs);\n\n\t\tif (wdev) {\n\t\t\twdev_lock(wdev);\n\t\t\tresult = __nl80211_set_channel(\n\t\t\t\trdev,\n\t\t\t\tnl80211_can_set_dev_channel(wdev) ? netdev : NULL,\n\t\t\t\tinfo, link_id);\n\t\t\twdev_unlock(wdev);\n\t\t} else {\n\t\t\tresult = __nl80211_set_channel(rdev, netdev, info, link_id);\n\t\t}\n\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_TX_POWER_SETTING]) {\n\t\tstruct wireless_dev *txp_wdev = wdev;\n\t\tenum nl80211_tx_power_setting type;\n\t\tint idx, mbm = 0;\n\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_VIF_TXPOWER))\n\t\t\ttxp_wdev = NULL;\n\n\t\tif (!rdev->ops->set_tx_power) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_SETTING;\n\t\ttype = nla_get_u32(info->attrs[idx]);\n\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_TX_POWER_LEVEL] &&\n\t\t    (type != NL80211_TX_POWER_AUTOMATIC)) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (type != NL80211_TX_POWER_AUTOMATIC) {\n\t\t\tidx = NL80211_ATTR_WIPHY_TX_POWER_LEVEL;\n\t\t\tmbm = nla_get_u32(info->attrs[idx]);\n\t\t}\n\n\t\tresult = rdev_set_tx_power(rdev, txp_wdev, type, mbm);\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&\n\t    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {\n\t\tu32 tx_ant, rx_ant;\n\n\t\tif ((!rdev->wiphy.available_antennas_tx &&\n\t\t     !rdev->wiphy.available_antennas_rx) ||\n\t\t    !rdev->ops->set_antenna) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX]);\n\t\trx_ant = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]);\n\n\t\t \n\t\tif ((~tx_ant && (tx_ant & ~rdev->wiphy.available_antennas_tx)) ||\n\t\t    (~rx_ant && (rx_ant & ~rdev->wiphy.available_antennas_rx))) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttx_ant = tx_ant & rdev->wiphy.available_antennas_tx;\n\t\trx_ant = rx_ant & rdev->wiphy.available_antennas_rx;\n\n\t\tresult = rdev_set_antenna(rdev, tx_ant, rx_ant);\n\t\tif (result)\n\t\t\tgoto out;\n\t}\n\n\tchanged = 0;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]) {\n\t\tretry_short = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_SHORT]);\n\n\t\tchanged |= WIPHY_PARAM_RETRY_SHORT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]) {\n\t\tretry_long = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RETRY_LONG]);\n\n\t\tchanged |= WIPHY_PARAM_RETRY_LONG;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]) {\n\t\tfrag_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_FRAG_THRESHOLD]);\n\t\tif (frag_threshold < 256) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (frag_threshold != (u32) -1) {\n\t\t\t \n\t\t\tfrag_threshold &= ~0x1;\n\t\t}\n\t\tchanged |= WIPHY_PARAM_FRAG_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]) {\n\t\trts_threshold = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_RTS_THRESHOLD]);\n\t\tchanged |= WIPHY_PARAM_RTS_THRESHOLD;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]) {\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_DYN_ACK]) {\n\t\t\tresult = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcoverage_class = nla_get_u8(\n\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_COVERAGE_CLASS]);\n\t\tchanged |= WIPHY_PARAM_COVERAGE_CLASS;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_DYN_ACK]) {\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_ACKTO_ESTIMATION)) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tchanged |= WIPHY_PARAM_DYN_ACK;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_LIMIT]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\ttxq_limit = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_LIMIT]);\n\t\tchanged |= WIPHY_PARAM_TXQ_LIMIT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_MEMORY_LIMIT]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\ttxq_memory_limit = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_MEMORY_LIMIT]);\n\t\tchanged |= WIPHY_PARAM_TXQ_MEMORY_LIMIT;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TXQ_QUANTUM]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_TXQS)) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\ttxq_quantum = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_TXQ_QUANTUM]);\n\t\tchanged |= WIPHY_PARAM_TXQ_QUANTUM;\n\t}\n\n\tif (changed) {\n\t\tu8 old_retry_short, old_retry_long;\n\t\tu32 old_frag_threshold, old_rts_threshold;\n\t\tu8 old_coverage_class;\n\t\tu32 old_txq_limit, old_txq_memory_limit, old_txq_quantum;\n\n\t\tif (!rdev->ops->set_wiphy_params) {\n\t\t\tresult = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\told_retry_short = rdev->wiphy.retry_short;\n\t\told_retry_long = rdev->wiphy.retry_long;\n\t\told_frag_threshold = rdev->wiphy.frag_threshold;\n\t\told_rts_threshold = rdev->wiphy.rts_threshold;\n\t\told_coverage_class = rdev->wiphy.coverage_class;\n\t\told_txq_limit = rdev->wiphy.txq_limit;\n\t\told_txq_memory_limit = rdev->wiphy.txq_memory_limit;\n\t\told_txq_quantum = rdev->wiphy.txq_quantum;\n\n\t\tif (changed & WIPHY_PARAM_RETRY_SHORT)\n\t\t\trdev->wiphy.retry_short = retry_short;\n\t\tif (changed & WIPHY_PARAM_RETRY_LONG)\n\t\t\trdev->wiphy.retry_long = retry_long;\n\t\tif (changed & WIPHY_PARAM_FRAG_THRESHOLD)\n\t\t\trdev->wiphy.frag_threshold = frag_threshold;\n\t\tif (changed & WIPHY_PARAM_RTS_THRESHOLD)\n\t\t\trdev->wiphy.rts_threshold = rts_threshold;\n\t\tif (changed & WIPHY_PARAM_COVERAGE_CLASS)\n\t\t\trdev->wiphy.coverage_class = coverage_class;\n\t\tif (changed & WIPHY_PARAM_TXQ_LIMIT)\n\t\t\trdev->wiphy.txq_limit = txq_limit;\n\t\tif (changed & WIPHY_PARAM_TXQ_MEMORY_LIMIT)\n\t\t\trdev->wiphy.txq_memory_limit = txq_memory_limit;\n\t\tif (changed & WIPHY_PARAM_TXQ_QUANTUM)\n\t\t\trdev->wiphy.txq_quantum = txq_quantum;\n\n\t\tresult = rdev_set_wiphy_params(rdev, changed);\n\t\tif (result) {\n\t\t\trdev->wiphy.retry_short = old_retry_short;\n\t\t\trdev->wiphy.retry_long = old_retry_long;\n\t\t\trdev->wiphy.frag_threshold = old_frag_threshold;\n\t\t\trdev->wiphy.rts_threshold = old_rts_threshold;\n\t\t\trdev->wiphy.coverage_class = old_coverage_class;\n\t\t\trdev->wiphy.txq_limit = old_txq_limit;\n\t\t\trdev->wiphy.txq_memory_limit = old_txq_memory_limit;\n\t\t\trdev->wiphy.txq_quantum = old_txq_quantum;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tresult = 0;\n\nout:\n\twiphy_unlock(&rdev->wiphy);\n\treturn result;\n}\n\nint nl80211_send_chandef(struct sk_buff *msg, const struct cfg80211_chan_def *chandef)\n{\n\tif (WARN_ON(!cfg80211_chandef_valid(chandef)))\n\t\treturn -EINVAL;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ,\n\t\t\tchandef->chan->center_freq))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ_OFFSET,\n\t\t\tchandef->chan->freq_offset))\n\t\treturn -ENOBUFS;\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,\n\t\t\t\tcfg80211_get_chandef_type(chandef)))\n\t\t\treturn -ENOBUFS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_CHANNEL_WIDTH, chandef->width))\n\t\treturn -ENOBUFS;\n\tif (nla_put_u32(msg, NL80211_ATTR_CENTER_FREQ1, chandef->center_freq1))\n\t\treturn -ENOBUFS;\n\tif (chandef->center_freq2 &&\n\t    nla_put_u32(msg, NL80211_ATTR_CENTER_FREQ2, chandef->center_freq2))\n\t\treturn -ENOBUFS;\n\treturn 0;\n}\nEXPORT_SYMBOL(nl80211_send_chandef);\n\nstatic int nl80211_send_iface(struct sk_buff *msg, u32 portid, u32 seq, int flags,\n\t\t\t      struct cfg80211_registered_device *rdev,\n\t\t\t      struct wireless_dev *wdev,\n\t\t\t      enum nl80211_commands cmd)\n{\n\tstruct net_device *dev = wdev->netdev;\n\tvoid *hdr;\n\n\tWARN_ON(cmd != NL80211_CMD_NEW_INTERFACE &&\n\t\tcmd != NL80211_CMD_DEL_INTERFACE &&\n\t\tcmd != NL80211_CMD_SET_INTERFACE);\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (dev &&\n\t    (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t     nla_put_string(msg, NL80211_ATTR_IFNAME, dev->name)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFTYPE, wdev->iftype) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, wdev_address(wdev)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION,\n\t\t\trdev->devlist_generation ^\n\t\t\t(cfg80211_rdev_list_generation << 2)) ||\n\t    nla_put_u8(msg, NL80211_ATTR_4ADDR, wdev->use_4addr))\n\t\tgoto nla_put_failure;\n\n\tif (rdev->ops->get_channel && !wdev->valid_links) {\n\t\tstruct cfg80211_chan_def chandef = {};\n\t\tint ret;\n\n\t\tret = rdev_get_channel(rdev, wdev, 0, &chandef);\n\t\tif (ret == 0 && nl80211_send_chandef(msg, &chandef))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rdev->ops->get_tx_power) {\n\t\tint dbm, ret;\n\n\t\tret = rdev_get_tx_power(rdev, wdev, &dbm);\n\t\tif (ret == 0 &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_TX_POWER_LEVEL,\n\t\t\t\tDBM_TO_MBM(dbm)))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\twdev_lock(wdev);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (wdev->u.ap.ssid_len &&\n\t\t    nla_put(msg, NL80211_ATTR_SSID, wdev->u.ap.ssid_len,\n\t\t\t    wdev->u.ap.ssid))\n\t\t\tgoto nla_put_failure_locked;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->u.client.ssid_len &&\n\t\t    nla_put(msg, NL80211_ATTR_SSID, wdev->u.client.ssid_len,\n\t\t\t    wdev->u.client.ssid))\n\t\t\tgoto nla_put_failure_locked;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (wdev->u.ibss.ssid_len &&\n\t\t    nla_put(msg, NL80211_ATTR_SSID, wdev->u.ibss.ssid_len,\n\t\t\t    wdev->u.ibss.ssid))\n\t\t\tgoto nla_put_failure_locked;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\twdev_unlock(wdev);\n\n\tif (rdev->ops->get_txq_stats) {\n\t\tstruct cfg80211_txq_stats txqstats = {};\n\t\tint ret = rdev_get_txq_stats(rdev, wdev, &txqstats);\n\n\t\tif (ret == 0 &&\n\t\t    !nl80211_put_txq_stats(msg, &txqstats,\n\t\t\t\t\t   NL80211_ATTR_TXQ_STATS))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (wdev->valid_links) {\n\t\tunsigned int link_id;\n\t\tstruct nlattr *links = nla_nest_start(msg,\n\t\t\t\t\t\t      NL80211_ATTR_MLO_LINKS);\n\n\t\tif (!links)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor_each_valid_link(wdev, link_id) {\n\t\t\tstruct nlattr *link = nla_nest_start(msg, link_id + 1);\n\t\t\tstruct cfg80211_chan_def chandef = {};\n\t\t\tint ret;\n\n\t\t\tif (!link)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link_id))\n\t\t\t\tgoto nla_put_failure;\n\t\t\tif (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN,\n\t\t\t\t    wdev->links[link_id].addr))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tret = rdev_get_channel(rdev, wdev, link_id, &chandef);\n\t\t\tif (ret == 0 && nl80211_send_chandef(msg, &chandef))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, link);\n\t\t}\n\n\t\tnla_nest_end(msg, links);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure_locked:\n\twdev_unlock(wdev);\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint wp_idx = 0;\n\tint if_idx = 0;\n\tint wp_start = cb->args[0];\n\tint if_start = cb->args[1];\n\tint filter_wiphy = -1;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tint ret;\n\n\trtnl_lock();\n\tif (!cb->args[2]) {\n\t\tstruct nl80211_dump_wiphy_state state = {\n\t\t\t.filter_wiphy = -1,\n\t\t};\n\n\t\tret = nl80211_dump_wiphy_parse(skb, cb, &state);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tfilter_wiphy = state.filter_wiphy;\n\n\t\t \n\t\tif (filter_wiphy >= 0)\n\t\t\tcb->args[2] = filter_wiphy + 1;\n\t\telse\n\t\t\tcb->args[2] = -1;\n\t} else if (cb->args[2] > 0) {\n\t\tfilter_wiphy = cb->args[2] - 1;\n\t}\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!net_eq(wiphy_net(&rdev->wiphy), sock_net(skb->sk)))\n\t\t\tcontinue;\n\t\tif (wp_idx < wp_start) {\n\t\t\twp_idx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (filter_wiphy >= 0 && filter_wiphy != rdev->wiphy_idx)\n\t\t\tcontinue;\n\n\t\tif_idx = 0;\n\n\t\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tif (if_idx < if_start) {\n\t\t\t\tif_idx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (nl80211_send_iface(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t       rdev, wdev,\n\t\t\t\t\t       NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif_idx++;\n\t\t}\n\n\t\twp_idx++;\n\t}\n out:\n\tcb->args[0] = wp_idx;\n\tcb->args[1] = if_idx;\n\n\tret = skb->len;\n out_unlock:\n\trtnl_unlock();\n\n\treturn ret;\n}\n\nstatic int nl80211_get_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_iface(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       rdev, wdev, NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic const struct nla_policy mntr_flags_policy[NL80211_MNTR_FLAG_MAX + 1] = {\n\t[NL80211_MNTR_FLAG_FCSFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_PLCPFAIL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_CONTROL] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_OTHER_BSS] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_COOK_FRAMES] = { .type = NLA_FLAG },\n\t[NL80211_MNTR_FLAG_ACTIVE] = { .type = NLA_FLAG },\n};\n\nstatic int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)\n{\n\tstruct nlattr *flags[NL80211_MNTR_FLAG_MAX + 1];\n\tint flag;\n\n\t*mntrflags = 0;\n\n\tif (!nla)\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested_deprecated(flags, NL80211_MNTR_FLAG_MAX, nla, mntr_flags_policy, NULL))\n\t\treturn -EINVAL;\n\n\tfor (flag = 1; flag <= NL80211_MNTR_FLAG_MAX; flag++)\n\t\tif (flags[flag])\n\t\t\t*mntrflags |= (1<<flag);\n\n\t*mntrflags |= MONITOR_FLAG_CHANGED;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_mon_options(struct cfg80211_registered_device *rdev,\n\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t     struct genl_info *info,\n\t\t\t\t     struct vif_params *params)\n{\n\tbool change = false;\n\tint err;\n\n\tif (info->attrs[NL80211_ATTR_MNTR_FLAGS]) {\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\terr = parse_monitor_flags(info->attrs[NL80211_ATTR_MNTR_FLAGS],\n\t\t\t\t\t  &params->flags);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tchange = true;\n\t}\n\n\tif (params->flags & MONITOR_FLAG_ACTIVE &&\n\t    !(rdev->wiphy.features & NL80211_FEATURE_ACTIVE_MONITOR))\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_MU_MIMO_GROUP_DATA]) {\n\t\tconst u8 *mumimo_groups;\n\t\tu32 cap_flag = NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER;\n\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy, cap_flag))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmumimo_groups =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MU_MIMO_GROUP_DATA]);\n\n\t\t \n\t\tif ((mumimo_groups[0] & BIT(0)) ||\n\t\t    (mumimo_groups[VHT_MUMIMO_GROUPS_DATA_LEN - 1] & BIT(7)))\n\t\t\treturn -EINVAL;\n\n\t\tparams->vht_mumimo_groups = mumimo_groups;\n\t\tchange = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR]) {\n\t\tu32 cap_flag = NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER;\n\n\t\tif (type != NL80211_IFTYPE_MONITOR)\n\t\t\treturn -EINVAL;\n\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy, cap_flag))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tparams->vht_mumimo_follow_addr =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MU_MIMO_FOLLOW_MAC_ADDR]);\n\t\tchange = true;\n\t}\n\n\treturn change ? 1 : 0;\n}\n\nstatic int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u8 use_4addr,\n\t\t\t       enum nl80211_iftype iftype)\n{\n\tif (!use_4addr) {\n\t\tif (netdev && netif_is_bridge_port(netdev))\n\t\t\treturn -EBUSY;\n\t\treturn 0;\n\t}\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tint err;\n\tenum nl80211_iftype otype, ntype;\n\tstruct net_device *dev = info->user_ptr[1];\n\tbool change = false;\n\n\tmemset(&params, 0, sizeof(params));\n\n\totype = ntype = dev->ieee80211_ptr->iftype;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE]) {\n\t\tntype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\t\tif (otype != ntype)\n\t\t\tchange = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_ID]) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tif (ntype != NL80211_IFTYPE_MESH_POINT)\n\t\t\treturn -EINVAL;\n\t\tif (netif_running(dev))\n\t\t\treturn -EBUSY;\n\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->u.mesh.id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->u.mesh.id,\n\t\t       nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->u.mesh.id_up_len);\n\t\twdev_unlock(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\tchange = true;\n\t\terr = nl80211_valid_4addr(rdev, dev, params.use_4addr, ntype);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tparams.use_4addr = -1;\n\t}\n\n\terr = nl80211_parse_mon_options(rdev, ntype, info, &params);\n\tif (err < 0)\n\t\treturn err;\n\tif (err > 0)\n\t\tchange = true;\n\n\tif (change)\n\t\terr = cfg80211_change_iface(rdev, dev, ntype, &params);\n\telse\n\t\terr = 0;\n\n\tif (!err && params.use_4addr != -1)\n\t\tdev->ieee80211_ptr->use_4addr = params.use_4addr;\n\n\tif (change && !err) {\n\t\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t\tnl80211_notify_iface(rdev, wdev, NL80211_CMD_SET_INTERFACE);\n\t}\n\n\treturn err;\n}\n\nstatic int _nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct vif_params params;\n\tstruct wireless_dev *wdev;\n\tstruct sk_buff *msg;\n\tint err;\n\tenum nl80211_iftype type = NL80211_IFTYPE_UNSPECIFIED;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!info->attrs[NL80211_ATTR_IFNAME])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IFTYPE])\n\t\ttype = nla_get_u32(info->attrs[NL80211_ATTR_IFTYPE]);\n\n\tif (!rdev->ops->add_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((type == NL80211_IFTYPE_P2P_DEVICE || type == NL80211_IFTYPE_NAN ||\n\t     rdev->wiphy.features & NL80211_FEATURE_MAC_ON_CREATE) &&\n\t    info->attrs[NL80211_ATTR_MAC]) {\n\t\tnla_memcpy(params.macaddr, info->attrs[NL80211_ATTR_MAC],\n\t\t\t   ETH_ALEN);\n\t\tif (!is_valid_ether_addr(params.macaddr))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_4ADDR]) {\n\t\tparams.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);\n\t\terr = nl80211_valid_4addr(rdev, NULL, params.use_4addr, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!cfg80211_iftype_allowed(&rdev->wiphy, type, params.use_4addr, 0))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_mon_options(rdev, type, info, &params);\n\tif (err < 0)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\twdev = rdev_add_virtual_intf(rdev,\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_IFNAME]),\n\t\t\t\tNET_NAME_USER, type, &params);\n\tif (WARN_ON(!wdev)) {\n\t\tnlmsg_free(msg);\n\t\treturn -EPROTO;\n\t} else if (IS_ERR(wdev)) {\n\t\tnlmsg_free(msg);\n\t\treturn PTR_ERR(wdev);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\twdev->owner_nlportid = info->snd_portid;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!info->attrs[NL80211_ATTR_MESH_ID])\n\t\t\tbreak;\n\t\twdev_lock(wdev);\n\t\tBUILD_BUG_ON(IEEE80211_MAX_SSID_LEN !=\n\t\t\t     IEEE80211_MAX_MESH_ID_LEN);\n\t\twdev->u.mesh.id_up_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\t\tmemcpy(wdev->u.mesh.id,\n\t\t       nla_data(info->attrs[NL80211_ATTR_MESH_ID]),\n\t\t       wdev->u.mesh.id_up_len);\n\t\twdev_unlock(wdev);\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t \n\t\tcfg80211_init_wdev(wdev);\n\t\tcfg80211_register_wdev(rdev, wdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (nl80211_send_iface(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       rdev, wdev, NL80211_CMD_NEW_INTERFACE) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint ret;\n\n\t \n\tcfg80211_destroy_ifaces(rdev);\n\n\twiphy_lock(&rdev->wiphy);\n\tret = _nl80211_new_interface(skb, info);\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn ret;\n}\n\nstatic int nl80211_del_interface(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->del_virtual_intf)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tmutex_unlock(&rdev->wiphy.mtx);\n\n\t \n\tif (!wdev->netdev)\n\t\tinfo->user_ptr[1] = NULL;\n\telse\n\t\tdev_close(wdev->netdev);\n\n\tmutex_lock(&rdev->wiphy.mtx);\n\n\treturn cfg80211_remove_virtual_intf(rdev, wdev);\n}\n\nstatic int nl80211_set_noack_map(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 noack_map;\n\n\tif (!info->attrs[NL80211_ATTR_NOACK_MAP])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_noack_map)\n\t\treturn -EOPNOTSUPP;\n\n\tnoack_map = nla_get_u16(info->attrs[NL80211_ATTR_NOACK_MAP]);\n\n\treturn rdev_set_noack_map(rdev, dev, noack_map);\n}\n\nstatic int nl80211_validate_key_link_id(struct genl_info *info,\n\t\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\t\tint link_id, bool pairwise)\n{\n\tif (pairwise) {\n\t\tif (link_id != -1) {\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"link ID not allowed for pairwise key\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (wdev->valid_links) {\n\t\tif (link_id == -1) {\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"link ID must for MLO group key\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(wdev->valid_links & BIT(link_id))) {\n\t\t\tGENL_SET_ERR_MSG(info, \"invalid link ID for MLO group key\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (link_id != -1) {\n\t\tGENL_SET_ERR_MSG(info, \"link ID not allowed for non-MLO group key\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstruct get_key_cookie {\n\tstruct sk_buff *msg;\n\tint error;\n\tint idx;\n};\n\nstatic void get_key_callback(void *c, struct key_params *params)\n{\n\tstruct nlattr *key;\n\tstruct get_key_cookie *cookie = c;\n\n\tif ((params->key &&\n\t     nla_put(cookie->msg, NL80211_ATTR_KEY_DATA,\n\t\t     params->key_len, params->key)) ||\n\t    (params->seq &&\n\t     nla_put(cookie->msg, NL80211_ATTR_KEY_SEQ,\n\t\t     params->seq_len, params->seq)) ||\n\t    (params->cipher &&\n\t     nla_put_u32(cookie->msg, NL80211_ATTR_KEY_CIPHER,\n\t\t\t params->cipher)))\n\t\tgoto nla_put_failure;\n\n\tkey = nla_nest_start_noflag(cookie->msg, NL80211_ATTR_KEY);\n\tif (!key)\n\t\tgoto nla_put_failure;\n\n\tif ((params->key &&\n\t     nla_put(cookie->msg, NL80211_KEY_DATA,\n\t\t     params->key_len, params->key)) ||\n\t    (params->seq &&\n\t     nla_put(cookie->msg, NL80211_KEY_SEQ,\n\t\t     params->seq_len, params->seq)) ||\n\t    (params->cipher &&\n\t     nla_put_u32(cookie->msg, NL80211_KEY_CIPHER,\n\t\t\t params->cipher)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(cookie->msg, NL80211_KEY_IDX, cookie->idx))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(cookie->msg, key);\n\n\treturn;\n nla_put_failure:\n\tcookie->error = 1;\n}\n\nstatic int nl80211_get_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 key_idx = 0;\n\tconst u8 *mac_addr = NULL;\n\tbool pairwise;\n\tstruct get_key_cookie cookie = {\n\t\t.error = 0,\n\t};\n\tvoid *hdr;\n\tstruct sk_buff *msg;\n\tbool bigtk_support = false;\n\tint link_id = nl80211_link_id_or_invalid(info->attrs);\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_BEACON_PROTECTION))\n\t\tbigtk_support = true;\n\n\tif ((wdev->iftype == NL80211_IFTYPE_STATION ||\n\t     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT) &&\n\t    wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT))\n\t\tbigtk_support = true;\n\n\tif (info->attrs[NL80211_ATTR_KEY_IDX]) {\n\t\tkey_idx = nla_get_u8(info->attrs[NL80211_ATTR_KEY_IDX]);\n\n\t\tif (key_idx >= 6 && key_idx <= 7 && !bigtk_support) {\n\t\t\tGENL_SET_ERR_MSG(info, \"BIGTK not supported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tpairwise = !!mac_addr;\n\tif (info->attrs[NL80211_ATTR_KEY_TYPE]) {\n\t\tu32 kt = nla_get_u32(info->attrs[NL80211_ATTR_KEY_TYPE]);\n\n\t\tif (kt != NL80211_KEYTYPE_GROUP &&\n\t\t    kt != NL80211_KEYTYPE_PAIRWISE)\n\t\t\treturn -EINVAL;\n\t\tpairwise = kt == NL80211_KEYTYPE_PAIRWISE;\n\t}\n\n\tif (!rdev->ops->get_key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!pairwise && mac_addr && !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\treturn -ENOENT;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_NEW_KEY);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tcookie.msg = msg;\n\tcookie.idx = key_idx;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u8(msg, NL80211_ATTR_KEY_IDX, key_idx))\n\t\tgoto nla_put_failure;\n\tif (mac_addr &&\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr))\n\t\tgoto nla_put_failure;\n\n\terr = nl80211_validate_key_link_id(info, wdev, link_id, pairwise);\n\tif (err)\n\t\tgoto free_msg;\n\n\terr = rdev_get_key(rdev, dev, link_id, key_idx, pairwise, mac_addr,\n\t\t\t   &cookie, get_key_callback);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (cookie.error)\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_set_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct key_parse key;\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tint link_id = nl80211_link_id_or_invalid(info->attrs);\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (!key.def && !key.defmgmt && !key.defbeacon &&\n\t    !(key.p.mode == NL80211_KEY_SET_TX))\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\n\tif (key.def) {\n\t\tif (!rdev->ops->set_default_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(wdev);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = nl80211_validate_key_link_id(info, wdev, link_id, false);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_key(rdev, dev, link_id, key.idx,\n\t\t\t\t\t   key.def_uni, key.def_multi);\n\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\twdev->wext.default_key = key.idx;\n#endif\n\t} else if (key.defmgmt) {\n\t\tif (key.def_uni || !key.def_multi) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!rdev->ops->set_default_mgmt_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(wdev);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = nl80211_validate_key_link_id(info, wdev, link_id, false);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_mgmt_key(rdev, dev, link_id, key.idx);\n\t\tif (err)\n\t\t\tgoto out;\n\n#ifdef CONFIG_CFG80211_WEXT\n\t\twdev->wext.default_mgmt_key = key.idx;\n#endif\n\t} else if (key.defbeacon) {\n\t\tif (key.def_uni || !key.def_multi) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!rdev->ops->set_default_beacon_key) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_key_allowed(wdev);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = nl80211_validate_key_link_id(info, wdev, link_id, false);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_set_default_beacon_key(rdev, dev, link_id, key.idx);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (key.p.mode == NL80211_KEY_SET_TX &&\n\t\t   wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t   NL80211_EXT_FEATURE_EXT_KEY_ID)) {\n\t\tu8 *mac_addr = NULL;\n\n\t\tif (info->attrs[NL80211_ATTR_MAC])\n\t\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\t\tif (!mac_addr || key.idx < 0 || key.idx > 1) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = nl80211_validate_key_link_id(info, wdev, link_id, true);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = rdev_add_key(rdev, dev, link_id, key.idx,\n\t\t\t\t   NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t   mac_addr, &key.p);\n\t} else {\n\t\terr = -EINVAL;\n\t}\n out:\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_new_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct key_parse key;\n\tconst u8 *mac_addr = NULL;\n\tint link_id = nl80211_link_id_or_invalid(info->attrs);\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (!key.p.key) {\n\t\tGENL_SET_ERR_MSG(info, \"no key\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t \n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP) {\n\t\tGENL_SET_ERR_MSG(info, \"key type not pairwise or group\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (key.type == NL80211_KEYTYPE_GROUP &&\n\t    info->attrs[NL80211_ATTR_VLAN_ID])\n\t\tkey.p.vlan_id = nla_get_u16(info->attrs[NL80211_ATTR_VLAN_ID]);\n\n\tif (!rdev->ops->add_key)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cfg80211_validate_key_settings(rdev, &key.p, key.idx,\n\t\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t\t   mac_addr)) {\n\t\tGENL_SET_ERR_MSG(info, \"key setting validation failed\");\n\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\terr = nl80211_key_allowed(wdev);\n\tif (err)\n\t\tGENL_SET_ERR_MSG(info, \"key not allowed\");\n\n\tif (!err)\n\t\terr = nl80211_validate_key_link_id(info, wdev, link_id,\n\t\t\t\tkey.type == NL80211_KEYTYPE_PAIRWISE);\n\n\tif (!err) {\n\t\terr = rdev_add_key(rdev, dev, link_id, key.idx,\n\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t    mac_addr, &key.p);\n\t\tif (err)\n\t\t\tGENL_SET_ERR_MSG(info, \"key addition failed\");\n\t}\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_del_key(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *mac_addr = NULL;\n\tstruct key_parse key;\n\tint link_id = nl80211_link_id_or_invalid(info->attrs);\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (key.type == -1) {\n\t\tif (mac_addr)\n\t\t\tkey.type = NL80211_KEYTYPE_PAIRWISE;\n\t\telse\n\t\t\tkey.type = NL80211_KEYTYPE_GROUP;\n\t}\n\n\t \n\tif (key.type != NL80211_KEYTYPE_PAIRWISE &&\n\t    key.type != NL80211_KEYTYPE_GROUP)\n\t\treturn -EINVAL;\n\n\tif (!cfg80211_valid_key_idx(rdev, key.idx,\n\t\t\t\t    key.type == NL80211_KEYTYPE_PAIRWISE))\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->del_key)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\terr = nl80211_key_allowed(wdev);\n\n\tif (key.type == NL80211_KEYTYPE_GROUP && mac_addr &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\terr = -ENOENT;\n\n\tif (!err)\n\t\terr = nl80211_validate_key_link_id(info, wdev, link_id,\n\t\t\t\tkey.type == NL80211_KEYTYPE_PAIRWISE);\n\n\tif (!err)\n\t\terr = rdev_del_key(rdev, dev, link_id, key.idx,\n\t\t\t\t   key.type == NL80211_KEYTYPE_PAIRWISE,\n\t\t\t\t   mac_addr);\n\n#ifdef CONFIG_CFG80211_WEXT\n\tif (!err) {\n\t\tif (key.idx == wdev->wext.default_key)\n\t\t\twdev->wext.default_key = -1;\n\t\telse if (key.idx == wdev->wext.default_mgmt_key)\n\t\t\twdev->wext.default_mgmt_key = -1;\n\t}\n#endif\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\n \nstatic int validate_acl_mac_addrs(struct nlattr *nl_attr)\n{\n\tstruct nlattr *attr;\n\tint n_entries = 0, tmp;\n\n\tnla_for_each_nested(attr, nl_attr, tmp) {\n\t\tif (nla_len(attr) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\n\t\tn_entries++;\n\t}\n\n\treturn n_entries;\n}\n\n \nstatic struct cfg80211_acl_data *parse_acl_data(struct wiphy *wiphy,\n\t\t\t\t\t\tstruct genl_info *info)\n{\n\tenum nl80211_acl_policy acl_policy;\n\tstruct nlattr *attr;\n\tstruct cfg80211_acl_data *acl;\n\tint i = 0, n_entries, tmp;\n\n\tif (!wiphy->max_acl_mac_addrs)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (!info->attrs[NL80211_ATTR_ACL_POLICY])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tacl_policy = nla_get_u32(info->attrs[NL80211_ATTR_ACL_POLICY]);\n\tif (acl_policy != NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED &&\n\t    acl_policy != NL80211_ACL_POLICY_DENY_UNLESS_LISTED)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!info->attrs[NL80211_ATTR_MAC_ADDRS])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tn_entries = validate_acl_mac_addrs(info->attrs[NL80211_ATTR_MAC_ADDRS]);\n\tif (n_entries < 0)\n\t\treturn ERR_PTR(n_entries);\n\n\tif (n_entries > wiphy->max_acl_mac_addrs)\n\t\treturn ERR_PTR(-ENOTSUPP);\n\n\tacl = kzalloc(struct_size(acl, mac_addrs, n_entries), GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl->n_acl_entries = n_entries;\n\n\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_MAC_ADDRS], tmp) {\n\t\tmemcpy(acl->mac_addrs[i].addr, nla_data(attr), ETH_ALEN);\n\t\ti++;\n\t}\n\tacl->acl_policy = acl_policy;\n\n\treturn acl;\n}\n\nstatic int nl80211_set_mac_acl(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_acl_data *acl;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!dev->ieee80211_ptr->links[0].ap.beacon_interval)\n\t\treturn -EINVAL;\n\n\tacl = parse_acl_data(&rdev->wiphy, info);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\n\terr = rdev_set_mac_acl(rdev, dev, acl);\n\n\tkfree(acl);\n\n\treturn err;\n}\n\nstatic u32 rateset_to_mask(struct ieee80211_supported_band *sband,\n\t\t\t   u8 *rates, u8 rates_len)\n{\n\tu8 i;\n\tu32 mask = 0;\n\n\tfor (i = 0; i < rates_len; i++) {\n\t\tint rate = (rates[i] & 0x7f) * 5;\n\t\tint ridx;\n\n\t\tfor (ridx = 0; ridx < sband->n_bitrates; ridx++) {\n\t\t\tstruct ieee80211_rate *srate =\n\t\t\t\t&sband->bitrates[ridx];\n\t\t\tif (rate == srate->bitrate) {\n\t\t\t\tmask |= 1 << ridx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ridx == sband->n_bitrates)\n\t\t\treturn 0;  \n\t}\n\n\treturn mask;\n}\n\nstatic bool ht_rateset_to_mask(struct ieee80211_supported_band *sband,\n\t\t\t       u8 *rates, u8 rates_len,\n\t\t\t       u8 mcs[IEEE80211_HT_MCS_MASK_LEN])\n{\n\tu8 i;\n\n\tmemset(mcs, 0, IEEE80211_HT_MCS_MASK_LEN);\n\n\tfor (i = 0; i < rates_len; i++) {\n\t\tint ridx, rbit;\n\n\t\tridx = rates[i] / 8;\n\t\trbit = BIT(rates[i] % 8);\n\n\t\t \n\t\tif ((ridx < 0) || (ridx >= IEEE80211_HT_MCS_MASK_LEN))\n\t\t\treturn false;\n\n\t\t \n\t\tridx = array_index_nospec(ridx, IEEE80211_HT_MCS_MASK_LEN);\n\t\tif (sband->ht_cap.mcs.rx_mask[ridx] & rbit)\n\t\t\tmcs[ridx] |= rbit;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic u16 vht_mcs_map_to_mcs_mask(u8 vht_mcs_map)\n{\n\tu16 mcs_mask = 0;\n\n\tswitch (vht_mcs_map) {\n\tcase IEEE80211_VHT_MCS_NOT_SUPPORTED:\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_7:\n\t\tmcs_mask = 0x00FF;\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_8:\n\t\tmcs_mask = 0x01FF;\n\t\tbreak;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_9:\n\t\tmcs_mask = 0x03FF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn mcs_mask;\n}\n\nstatic void vht_build_mcs_mask(u16 vht_mcs_map,\n\t\t\t       u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])\n{\n\tu8 nss;\n\n\tfor (nss = 0; nss < NL80211_VHT_NSS_MAX; nss++) {\n\t\tvht_mcs_mask[nss] = vht_mcs_map_to_mcs_mask(vht_mcs_map & 0x03);\n\t\tvht_mcs_map >>= 2;\n\t}\n}\n\nstatic bool vht_set_mcs_mask(struct ieee80211_supported_band *sband,\n\t\t\t     struct nl80211_txrate_vht *txrate,\n\t\t\t     u16 mcs[NL80211_VHT_NSS_MAX])\n{\n\tu16 tx_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\tu16 tx_mcs_mask[NL80211_VHT_NSS_MAX] = {};\n\tu8 i;\n\n\tif (!sband->vht_cap.vht_supported)\n\t\treturn false;\n\n\tmemset(mcs, 0, sizeof(u16) * NL80211_VHT_NSS_MAX);\n\n\t \n\tvht_build_mcs_mask(tx_mcs_map, tx_mcs_mask);\n\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tif ((tx_mcs_mask[i] & txrate->mcs[i]) == txrate->mcs[i])\n\t\t\tmcs[i] = txrate->mcs[i];\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic u16 he_mcs_map_to_mcs_mask(u8 he_mcs_map)\n{\n\tswitch (he_mcs_map) {\n\tcase IEEE80211_HE_MCS_NOT_SUPPORTED:\n\t\treturn 0;\n\tcase IEEE80211_HE_MCS_SUPPORT_0_7:\n\t\treturn 0x00FF;\n\tcase IEEE80211_HE_MCS_SUPPORT_0_9:\n\t\treturn 0x03FF;\n\tcase IEEE80211_HE_MCS_SUPPORT_0_11:\n\t\treturn 0xFFF;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void he_build_mcs_mask(u16 he_mcs_map,\n\t\t\t      u16 he_mcs_mask[NL80211_HE_NSS_MAX])\n{\n\tu8 nss;\n\n\tfor (nss = 0; nss < NL80211_HE_NSS_MAX; nss++) {\n\t\the_mcs_mask[nss] = he_mcs_map_to_mcs_mask(he_mcs_map & 0x03);\n\t\the_mcs_map >>= 2;\n\t}\n}\n\nstatic u16 he_get_txmcsmap(struct genl_info *info, unsigned int link_id,\n\t\t\t   const struct ieee80211_sta_he_cap *he_cap)\n{\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_chan_def *chandef;\n\t__le16 tx_mcs;\n\n\tchandef = wdev_chandef(wdev, link_id);\n\tif (!chandef) {\n\t\t \n\t\treturn le16_to_cpu(he_cap->he_mcs_nss_supp.tx_mcs_80);\n\t}\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\ttx_mcs = he_cap->he_mcs_nss_supp.tx_mcs_80p80;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\ttx_mcs = he_cap->he_mcs_nss_supp.tx_mcs_160;\n\t\tbreak;\n\tdefault:\n\t\ttx_mcs = he_cap->he_mcs_nss_supp.tx_mcs_80;\n\t\tbreak;\n\t}\n\n\treturn le16_to_cpu(tx_mcs);\n}\n\nstatic bool he_set_mcs_mask(struct genl_info *info,\n\t\t\t    struct wireless_dev *wdev,\n\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t    struct nl80211_txrate_he *txrate,\n\t\t\t    u16 mcs[NL80211_HE_NSS_MAX],\n\t\t\t    unsigned int link_id)\n{\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tu16 tx_mcs_mask[NL80211_HE_NSS_MAX] = {};\n\tu16 tx_mcs_map = 0;\n\tu8 i;\n\n\the_cap = ieee80211_get_he_iftype_cap(sband, wdev->iftype);\n\tif (!he_cap)\n\t\treturn false;\n\n\tmemset(mcs, 0, sizeof(u16) * NL80211_HE_NSS_MAX);\n\n\ttx_mcs_map = he_get_txmcsmap(info, link_id, he_cap);\n\n\t \n\the_build_mcs_mask(tx_mcs_map, tx_mcs_mask);\n\n\tfor (i = 0; i < NL80211_HE_NSS_MAX; i++) {\n\t\tif ((tx_mcs_mask[i] & txrate->mcs[i]) == txrate->mcs[i])\n\t\t\tmcs[i] = txrate->mcs[i];\n\t\telse\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int nl80211_parse_tx_bitrate_mask(struct genl_info *info,\n\t\t\t\t\t struct nlattr *attrs[],\n\t\t\t\t\t enum nl80211_attrs attr,\n\t\t\t\t\t struct cfg80211_bitrate_mask *mask,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t bool default_all_enabled,\n\t\t\t\t\t unsigned int link_id)\n{\n\tstruct nlattr *tb[NL80211_TXRATE_MAX + 1];\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint rem, i;\n\tstruct nlattr *tx_rates;\n\tstruct ieee80211_supported_band *sband;\n\tu16 vht_tx_mcs_map, he_tx_mcs_map;\n\n\tmemset(mask, 0, sizeof(*mask));\n\t \n\tfor (i = 0; i < NUM_NL80211_BANDS; i++) {\n\t\tconst struct ieee80211_sta_he_cap *he_cap;\n\n\t\tif (!default_all_enabled)\n\t\t\tbreak;\n\n\t\tsband = rdev->wiphy.bands[i];\n\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tmask->control[i].legacy = (1 << sband->n_bitrates) - 1;\n\t\tmemcpy(mask->control[i].ht_mcs,\n\t\t       sband->ht_cap.mcs.rx_mask,\n\t\t       sizeof(mask->control[i].ht_mcs));\n\n\t\tif (sband->vht_cap.vht_supported) {\n\t\t\tvht_tx_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\t\t\tvht_build_mcs_mask(vht_tx_mcs_map, mask->control[i].vht_mcs);\n\t\t}\n\n\t\the_cap = ieee80211_get_he_iftype_cap(sband, wdev->iftype);\n\t\tif (!he_cap)\n\t\t\tcontinue;\n\n\t\the_tx_mcs_map = he_get_txmcsmap(info, link_id, he_cap);\n\t\the_build_mcs_mask(he_tx_mcs_map, mask->control[i].he_mcs);\n\n\t\tmask->control[i].he_gi = 0xFF;\n\t\tmask->control[i].he_ltf = 0xFF;\n\t}\n\n\t \n\tif (!attrs[attr])\n\t\tgoto out;\n\n\t \n\tBUILD_BUG_ON(NL80211_MAX_SUPP_HT_RATES > IEEE80211_HT_MCS_MASK_LEN * 8);\n\tnla_for_each_nested(tx_rates, attrs[attr], rem) {\n\t\tenum nl80211_band band = nla_type(tx_rates);\n\t\tint err;\n\n\t\tif (band < 0 || band >= NUM_NL80211_BANDS)\n\t\t\treturn -EINVAL;\n\t\tsband = rdev->wiphy.bands[band];\n\t\tif (sband == NULL)\n\t\t\treturn -EINVAL;\n\t\terr = nla_parse_nested_deprecated(tb, NL80211_TXRATE_MAX,\n\t\t\t\t\t\t  tx_rates,\n\t\t\t\t\t\t  nl80211_txattr_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (tb[NL80211_TXRATE_LEGACY]) {\n\t\t\tmask->control[band].legacy = rateset_to_mask(\n\t\t\t\tsband,\n\t\t\t\tnla_data(tb[NL80211_TXRATE_LEGACY]),\n\t\t\t\tnla_len(tb[NL80211_TXRATE_LEGACY]));\n\t\t\tif ((mask->control[band].legacy == 0) &&\n\t\t\t    nla_len(tb[NL80211_TXRATE_LEGACY]))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[NL80211_TXRATE_HT]) {\n\t\t\tif (!ht_rateset_to_mask(\n\t\t\t\t\tsband,\n\t\t\t\t\tnla_data(tb[NL80211_TXRATE_HT]),\n\t\t\t\t\tnla_len(tb[NL80211_TXRATE_HT]),\n\t\t\t\t\tmask->control[band].ht_mcs))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tb[NL80211_TXRATE_VHT]) {\n\t\t\tif (!vht_set_mcs_mask(\n\t\t\t\t\tsband,\n\t\t\t\t\tnla_data(tb[NL80211_TXRATE_VHT]),\n\t\t\t\t\tmask->control[band].vht_mcs))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tb[NL80211_TXRATE_GI]) {\n\t\t\tmask->control[band].gi =\n\t\t\t\tnla_get_u8(tb[NL80211_TXRATE_GI]);\n\t\t\tif (mask->control[band].gi > NL80211_TXRATE_FORCE_LGI)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tb[NL80211_TXRATE_HE] &&\n\t\t    !he_set_mcs_mask(info, wdev, sband,\n\t\t\t\t     nla_data(tb[NL80211_TXRATE_HE]),\n\t\t\t\t     mask->control[band].he_mcs,\n\t\t\t\t     link_id))\n\t\t\treturn -EINVAL;\n\n\t\tif (tb[NL80211_TXRATE_HE_GI])\n\t\t\tmask->control[band].he_gi =\n\t\t\t\tnla_get_u8(tb[NL80211_TXRATE_HE_GI]);\n\t\tif (tb[NL80211_TXRATE_HE_LTF])\n\t\t\tmask->control[band].he_ltf =\n\t\t\t\tnla_get_u8(tb[NL80211_TXRATE_HE_LTF]);\n\n\t\tif (mask->control[band].legacy == 0) {\n\t\t\t \n\t\t\tif (!(rdev->wiphy.bands[band]->ht_cap.ht_supported ||\n\t\t\t      rdev->wiphy.bands[band]->vht_cap.vht_supported ||\n\t\t\t      ieee80211_get_he_iftype_cap(sband, wdev->iftype)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)\n\t\t\t\tif (mask->control[band].ht_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++)\n\t\t\t\tif (mask->control[band].vht_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\tfor (i = 0; i < NL80211_HE_NSS_MAX; i++)\n\t\t\t\tif (mask->control[band].he_mcs[i])\n\t\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\nout:\n\treturn 0;\n}\n\nstatic int validate_beacon_tx_rate(struct cfg80211_registered_device *rdev,\n\t\t\t\t   enum nl80211_band band,\n\t\t\t\t   struct cfg80211_bitrate_mask *beacon_rate)\n{\n\tu32 count_ht, count_vht, count_he, i;\n\tu32 rate = beacon_rate->control[band].legacy;\n\n\t \n\tif (hweight32(rate) > 1)\n\t\treturn -EINVAL;\n\n\tcount_ht = 0;\n\tfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++) {\n\t\tif (hweight8(beacon_rate->control[band].ht_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].ht_mcs[i]) {\n\t\t\tcount_ht++;\n\t\t\tif (count_ht > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_ht && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcount_vht = 0;\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tif (hweight16(beacon_rate->control[band].vht_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].vht_mcs[i]) {\n\t\t\tcount_vht++;\n\t\t\tif (count_vht > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_vht && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tcount_he = 0;\n\tfor (i = 0; i < NL80211_HE_NSS_MAX; i++) {\n\t\tif (hweight16(beacon_rate->control[band].he_mcs[i]) > 1) {\n\t\t\treturn -EINVAL;\n\t\t} else if (beacon_rate->control[band].he_mcs[i]) {\n\t\t\tcount_he++;\n\t\t\tif (count_he > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (count_he && rate)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((count_ht && count_vht && count_he) ||\n\t    (!rate && !count_ht && !count_vht && !count_he))\n\t\treturn -EINVAL;\n\n\tif (rate &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_LEGACY))\n\t\treturn -EINVAL;\n\tif (count_ht &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_HT))\n\t\treturn -EINVAL;\n\tif (count_vht &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_VHT))\n\t\treturn -EINVAL;\n\tif (count_he &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BEACON_RATE_HE))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_mbssid_config(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       struct nlattr *attrs,\n\t\t\t\t       struct cfg80211_mbssid_config *config,\n\t\t\t\t       u8 num_elems)\n{\n\tstruct nlattr *tb[NL80211_MBSSID_CONFIG_ATTR_MAX + 1];\n\n\tif (!wiphy->mbssid_max_interfaces)\n\t\treturn -EOPNOTSUPP;\n\n\tif (nla_parse_nested(tb, NL80211_MBSSID_CONFIG_ATTR_MAX, attrs, NULL,\n\t\t\t     NULL) ||\n\t    !tb[NL80211_MBSSID_CONFIG_ATTR_INDEX])\n\t\treturn -EINVAL;\n\n\tconfig->ema = nla_get_flag(tb[NL80211_MBSSID_CONFIG_ATTR_EMA]);\n\tif (config->ema) {\n\t\tif (!wiphy->ema_max_profile_periodicity)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (num_elems > wiphy->ema_max_profile_periodicity)\n\t\t\treturn -EINVAL;\n\t}\n\n\tconfig->index = nla_get_u8(tb[NL80211_MBSSID_CONFIG_ATTR_INDEX]);\n\tif (config->index >= wiphy->mbssid_max_interfaces ||\n\t    (!config->index && !num_elems))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_MBSSID_CONFIG_ATTR_TX_IFINDEX]) {\n\t\tu32 tx_ifindex =\n\t\t\tnla_get_u32(tb[NL80211_MBSSID_CONFIG_ATTR_TX_IFINDEX]);\n\n\t\tif ((!config->index && tx_ifindex != dev->ifindex) ||\n\t\t    (config->index && tx_ifindex == dev->ifindex))\n\t\t\treturn -EINVAL;\n\n\t\tif (tx_ifindex != dev->ifindex) {\n\t\t\tstruct net_device *tx_netdev =\n\t\t\t\tdev_get_by_index(wiphy_net(wiphy), tx_ifindex);\n\n\t\t\tif (!tx_netdev || !tx_netdev->ieee80211_ptr ||\n\t\t\t    tx_netdev->ieee80211_ptr->wiphy != wiphy ||\n\t\t\t    tx_netdev->ieee80211_ptr->iftype !=\n\t\t\t\t\t\t\tNL80211_IFTYPE_AP) {\n\t\t\t\tdev_put(tx_netdev);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tconfig->tx_wdev = tx_netdev->ieee80211_ptr;\n\t\t} else {\n\t\t\tconfig->tx_wdev = dev->ieee80211_ptr;\n\t\t}\n\t} else if (!config->index) {\n\t\tconfig->tx_wdev = dev->ieee80211_ptr;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_mbssid_elems *\nnl80211_parse_mbssid_elems(struct wiphy *wiphy, struct nlattr *attrs)\n{\n\tstruct nlattr *nl_elems;\n\tstruct cfg80211_mbssid_elems *elems;\n\tint rem_elems;\n\tu8 i = 0, num_elems = 0;\n\n\tif (!wiphy->mbssid_max_interfaces)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnla_for_each_nested(nl_elems, attrs, rem_elems) {\n\t\tif (num_elems >= 255)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tnum_elems++;\n\t}\n\n\telems = kzalloc(struct_size(elems, elem, num_elems), GFP_KERNEL);\n\tif (!elems)\n\t\treturn ERR_PTR(-ENOMEM);\n\telems->cnt = num_elems;\n\n\tnla_for_each_nested(nl_elems, attrs, rem_elems) {\n\t\telems->elem[i].data = nla_data(nl_elems);\n\t\telems->elem[i].len = nla_len(nl_elems);\n\t\ti++;\n\t}\n\treturn elems;\n}\n\nstatic struct cfg80211_rnr_elems *\nnl80211_parse_rnr_elems(struct wiphy *wiphy, struct nlattr *attrs,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nlattr *nl_elems;\n\tstruct cfg80211_rnr_elems *elems;\n\tint rem_elems;\n\tu8 i = 0, num_elems = 0;\n\n\tnla_for_each_nested(nl_elems, attrs, rem_elems) {\n\t\tint ret;\n\n\t\tret = validate_ie_attr(nl_elems, extack);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tnum_elems++;\n\t}\n\n\telems = kzalloc(struct_size(elems, elem, num_elems), GFP_KERNEL);\n\tif (!elems)\n\t\treturn ERR_PTR(-ENOMEM);\n\telems->cnt = num_elems;\n\n\tnla_for_each_nested(nl_elems, attrs, rem_elems) {\n\t\telems->elem[i].data = nla_data(nl_elems);\n\t\telems->elem[i].len = nla_len(nl_elems);\n\t\ti++;\n\t}\n\treturn elems;\n}\n\nstatic int nl80211_parse_he_bss_color(struct nlattr *attrs,\n\t\t\t\t      struct cfg80211_he_bss_color *he_bss_color)\n{\n\tstruct nlattr *tb[NL80211_HE_BSS_COLOR_ATTR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(tb, NL80211_HE_BSS_COLOR_ATTR_MAX, attrs,\n\t\t\t       he_bss_color_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_HE_BSS_COLOR_ATTR_COLOR])\n\t\treturn -EINVAL;\n\n\the_bss_color->color =\n\t\tnla_get_u8(tb[NL80211_HE_BSS_COLOR_ATTR_COLOR]);\n\the_bss_color->enabled =\n\t\t!nla_get_flag(tb[NL80211_HE_BSS_COLOR_ATTR_DISABLED]);\n\the_bss_color->partial =\n\t\tnla_get_flag(tb[NL80211_HE_BSS_COLOR_ATTR_PARTIAL]);\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_beacon(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct nlattr *attrs[],\n\t\t\t\tstruct cfg80211_beacon_data *bcn,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbool haveinfo = false;\n\tint err;\n\n\tmemset(bcn, 0, sizeof(*bcn));\n\n\tbcn->link_id = nl80211_link_id(attrs);\n\n\tif (attrs[NL80211_ATTR_BEACON_HEAD]) {\n\t\tbcn->head = nla_data(attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\tbcn->head_len = nla_len(attrs[NL80211_ATTR_BEACON_HEAD]);\n\t\tif (!bcn->head_len)\n\t\t\treturn -EINVAL;\n\t\thaveinfo = true;\n\t}\n\n\tif (attrs[NL80211_ATTR_BEACON_TAIL]) {\n\t\tbcn->tail = nla_data(attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\tbcn->tail_len = nla_len(attrs[NL80211_ATTR_BEACON_TAIL]);\n\t\thaveinfo = true;\n\t}\n\n\tif (!haveinfo)\n\t\treturn -EINVAL;\n\n\tif (attrs[NL80211_ATTR_IE]) {\n\t\tbcn->beacon_ies = nla_data(attrs[NL80211_ATTR_IE]);\n\t\tbcn->beacon_ies_len = nla_len(attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (attrs[NL80211_ATTR_IE_PROBE_RESP]) {\n\t\tbcn->proberesp_ies =\n\t\t\tnla_data(attrs[NL80211_ATTR_IE_PROBE_RESP]);\n\t\tbcn->proberesp_ies_len =\n\t\t\tnla_len(attrs[NL80211_ATTR_IE_PROBE_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_IE_ASSOC_RESP]) {\n\t\tbcn->assocresp_ies =\n\t\t\tnla_data(attrs[NL80211_ATTR_IE_ASSOC_RESP]);\n\t\tbcn->assocresp_ies_len =\n\t\t\tnla_len(attrs[NL80211_ATTR_IE_ASSOC_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_PROBE_RESP]) {\n\t\tbcn->probe_resp = nla_data(attrs[NL80211_ATTR_PROBE_RESP]);\n\t\tbcn->probe_resp_len = nla_len(attrs[NL80211_ATTR_PROBE_RESP]);\n\t}\n\n\tif (attrs[NL80211_ATTR_FTM_RESPONDER]) {\n\t\tstruct nlattr *tb[NL80211_FTM_RESP_ATTR_MAX + 1];\n\n\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t  NL80211_FTM_RESP_ATTR_MAX,\n\t\t\t\t\t\t  attrs[NL80211_ATTR_FTM_RESPONDER],\n\t\t\t\t\t\t  NULL, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_ENABLED] &&\n\t\t    wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER))\n\t\t\tbcn->ftm_responder = 1;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_LCI]) {\n\t\t\tbcn->lci = nla_data(tb[NL80211_FTM_RESP_ATTR_LCI]);\n\t\t\tbcn->lci_len = nla_len(tb[NL80211_FTM_RESP_ATTR_LCI]);\n\t\t}\n\n\t\tif (tb[NL80211_FTM_RESP_ATTR_CIVICLOC]) {\n\t\t\tbcn->civicloc = nla_data(tb[NL80211_FTM_RESP_ATTR_CIVICLOC]);\n\t\t\tbcn->civicloc_len = nla_len(tb[NL80211_FTM_RESP_ATTR_CIVICLOC]);\n\t\t}\n\t} else {\n\t\tbcn->ftm_responder = -1;\n\t}\n\n\tif (attrs[NL80211_ATTR_HE_BSS_COLOR]) {\n\t\terr = nl80211_parse_he_bss_color(attrs[NL80211_ATTR_HE_BSS_COLOR],\n\t\t\t\t\t\t &bcn->he_bss_color);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbcn->he_bss_color_valid = true;\n\t}\n\n\tif (attrs[NL80211_ATTR_MBSSID_ELEMS]) {\n\t\tstruct cfg80211_mbssid_elems *mbssid =\n\t\t\tnl80211_parse_mbssid_elems(&rdev->wiphy,\n\t\t\t\t\t\t   attrs[NL80211_ATTR_MBSSID_ELEMS]);\n\n\t\tif (IS_ERR(mbssid))\n\t\t\treturn PTR_ERR(mbssid);\n\n\t\tbcn->mbssid_ies = mbssid;\n\n\t\tif (bcn->mbssid_ies && attrs[NL80211_ATTR_EMA_RNR_ELEMS]) {\n\t\t\tstruct cfg80211_rnr_elems *rnr =\n\t\t\t\tnl80211_parse_rnr_elems(&rdev->wiphy,\n\t\t\t\t\t\t\tattrs[NL80211_ATTR_EMA_RNR_ELEMS],\n\t\t\t\t\t\t\textack);\n\n\t\t\tif (IS_ERR(rnr))\n\t\t\t\treturn PTR_ERR(rnr);\n\n\t\t\tif (rnr && rnr->cnt < bcn->mbssid_ies->cnt)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tbcn->rnr_ies = rnr;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_he_obss_pd(struct nlattr *attrs,\n\t\t\t\t    struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct nlattr *tb[NL80211_HE_OBSS_PD_ATTR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(tb, NL80211_HE_OBSS_PD_ATTR_MAX, attrs,\n\t\t\t       he_obss_pd_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_HE_OBSS_PD_ATTR_SR_CTRL])\n\t\treturn -EINVAL;\n\n\the_obss_pd->sr_ctrl = nla_get_u8(tb[NL80211_HE_OBSS_PD_ATTR_SR_CTRL]);\n\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET])\n\t\the_obss_pd->min_offset =\n\t\t\tnla_get_u8(tb[NL80211_HE_OBSS_PD_ATTR_MIN_OFFSET]);\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET])\n\t\the_obss_pd->max_offset =\n\t\t\tnla_get_u8(tb[NL80211_HE_OBSS_PD_ATTR_MAX_OFFSET]);\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET])\n\t\the_obss_pd->non_srg_max_offset =\n\t\t\tnla_get_u8(tb[NL80211_HE_OBSS_PD_ATTR_NON_SRG_MAX_OFFSET]);\n\n\tif (he_obss_pd->min_offset > he_obss_pd->max_offset)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP])\n\t\tmemcpy(he_obss_pd->bss_color_bitmap,\n\t\t       nla_data(tb[NL80211_HE_OBSS_PD_ATTR_BSS_COLOR_BITMAP]),\n\t\t       sizeof(he_obss_pd->bss_color_bitmap));\n\n\tif (tb[NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP])\n\t\tmemcpy(he_obss_pd->partial_bssid_bitmap,\n\t\t       nla_data(tb[NL80211_HE_OBSS_PD_ATTR_PARTIAL_BSSID_BITMAP]),\n\t\t       sizeof(he_obss_pd->partial_bssid_bitmap));\n\n\the_obss_pd->enable = true;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_fils_discovery(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct nlattr *attrs,\n\t\t\t\t\tstruct cfg80211_ap_settings *params)\n{\n\tstruct nlattr *tb[NL80211_FILS_DISCOVERY_ATTR_MAX + 1];\n\tint ret;\n\tstruct cfg80211_fils_discovery *fd = &params->fils_discovery;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_FILS_DISCOVERY))\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(tb, NL80211_FILS_DISCOVERY_ATTR_MAX, attrs,\n\t\t\t       NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!tb[NL80211_FILS_DISCOVERY_ATTR_INT_MIN] ||\n\t    !tb[NL80211_FILS_DISCOVERY_ATTR_INT_MAX] ||\n\t    !tb[NL80211_FILS_DISCOVERY_ATTR_TMPL])\n\t\treturn -EINVAL;\n\n\tfd->tmpl_len = nla_len(tb[NL80211_FILS_DISCOVERY_ATTR_TMPL]);\n\tfd->tmpl = nla_data(tb[NL80211_FILS_DISCOVERY_ATTR_TMPL]);\n\tfd->min_interval = nla_get_u32(tb[NL80211_FILS_DISCOVERY_ATTR_INT_MIN]);\n\tfd->max_interval = nla_get_u32(tb[NL80211_FILS_DISCOVERY_ATTR_INT_MAX]);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_unsol_bcast_probe_resp(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct nlattr *attrs,\n\t\t\t\t     struct cfg80211_ap_settings *params)\n{\n\tstruct nlattr *tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX + 1];\n\tint ret;\n\tstruct cfg80211_unsol_bcast_probe_resp *presp =\n\t\t\t\t\t&params->unsol_bcast_probe_resp;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP))\n\t\treturn -EINVAL;\n\n\tret = nla_parse_nested(tb, NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_MAX,\n\t\t\t       attrs, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT] ||\n\t    !tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL])\n\t\treturn -EINVAL;\n\n\tpresp->tmpl = nla_data(tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL]);\n\tpresp->tmpl_len = nla_len(tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_TMPL]);\n\tpresp->interval = nla_get_u32(tb[NL80211_UNSOL_BCAST_PROBE_RESP_ATTR_INT]);\n\treturn 0;\n}\n\nstatic void nl80211_check_ap_rate_selectors(struct cfg80211_ap_settings *params,\n\t\t\t\t\t    const struct element *rates)\n{\n\tint i;\n\n\tif (!rates)\n\t\treturn;\n\n\tfor (i = 0; i < rates->datalen; i++) {\n\t\tif (rates->data[i] == BSS_MEMBERSHIP_SELECTOR_HT_PHY)\n\t\t\tparams->ht_required = true;\n\t\tif (rates->data[i] == BSS_MEMBERSHIP_SELECTOR_VHT_PHY)\n\t\t\tparams->vht_required = true;\n\t\tif (rates->data[i] == BSS_MEMBERSHIP_SELECTOR_HE_PHY)\n\t\t\tparams->he_required = true;\n\t\tif (rates->data[i] == BSS_MEMBERSHIP_SELECTOR_SAE_H2E)\n\t\t\tparams->sae_h2e_required = true;\n\t}\n}\n\n \nstatic int nl80211_calculate_ap_params(struct cfg80211_ap_settings *params)\n{\n\tconst struct cfg80211_beacon_data *bcn = &params->beacon;\n\tsize_t ies_len = bcn->tail_len;\n\tconst u8 *ies = bcn->tail;\n\tconst struct element *rates;\n\tconst struct element *cap;\n\n\trates = cfg80211_find_elem(WLAN_EID_SUPP_RATES, ies, ies_len);\n\tnl80211_check_ap_rate_selectors(params, rates);\n\n\trates = cfg80211_find_elem(WLAN_EID_EXT_SUPP_RATES, ies, ies_len);\n\tnl80211_check_ap_rate_selectors(params, rates);\n\n\tcap = cfg80211_find_elem(WLAN_EID_HT_CAPABILITY, ies, ies_len);\n\tif (cap && cap->datalen >= sizeof(*params->ht_cap))\n\t\tparams->ht_cap = (void *)cap->data;\n\tcap = cfg80211_find_elem(WLAN_EID_VHT_CAPABILITY, ies, ies_len);\n\tif (cap && cap->datalen >= sizeof(*params->vht_cap))\n\t\tparams->vht_cap = (void *)cap->data;\n\tcap = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY, ies, ies_len);\n\tif (cap && cap->datalen >= sizeof(*params->he_cap) + 1)\n\t\tparams->he_cap = (void *)(cap->data + 1);\n\tcap = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_OPERATION, ies, ies_len);\n\tif (cap && cap->datalen >= sizeof(*params->he_oper) + 1)\n\t\tparams->he_oper = (void *)(cap->data + 1);\n\tcap = cfg80211_find_ext_elem(WLAN_EID_EXT_EHT_CAPABILITY, ies, ies_len);\n\tif (cap) {\n\t\tif (!cap->datalen)\n\t\t\treturn -EINVAL;\n\t\tparams->eht_cap = (void *)(cap->data + 1);\n\t\tif (!ieee80211_eht_capa_size_ok((const u8 *)params->he_cap,\n\t\t\t\t\t\t(const u8 *)params->eht_cap,\n\t\t\t\t\t\tcap->datalen - 1, true))\n\t\t\treturn -EINVAL;\n\t}\n\tcap = cfg80211_find_ext_elem(WLAN_EID_EXT_EHT_OPERATION, ies, ies_len);\n\tif (cap) {\n\t\tif (!cap->datalen)\n\t\t\treturn -EINVAL;\n\t\tparams->eht_oper = (void *)(cap->data + 1);\n\t\tif (!ieee80211_eht_oper_size_ok((const u8 *)params->eht_oper,\n\t\t\t\t\t\tcap->datalen - 1))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic bool nl80211_get_ap_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct cfg80211_ap_settings *params)\n{\n\tstruct wireless_dev *wdev;\n\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\tcontinue;\n\n\t\tif (!wdev->u.ap.preset_chandef.chan)\n\t\t\tcontinue;\n\n\t\tparams->chandef = wdev->u.ap.preset_chandef;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool nl80211_valid_auth_type(struct cfg80211_registered_device *rdev,\n\t\t\t\t    enum nl80211_auth_type auth_type,\n\t\t\t\t    enum nl80211_commands cmd)\n{\n\tif (auth_type > NL80211_AUTHTYPE_MAX)\n\t\treturn false;\n\n\tswitch (cmd) {\n\tcase NL80211_CMD_AUTHENTICATE:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_SAE) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_FILS_STA) &&\n\t\t    (auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t\t     auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t     auth_type == NL80211_AUTHTYPE_FILS_PK))\n\t\t\treturn false;\n\t\treturn true;\n\tcase NL80211_CMD_CONNECT:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_SAE) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\n\t\t \n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn false;\n\t\tif (!wiphy_ext_feature_isset(\n\t\t\t    &rdev->wiphy,\n\t\t\t    NL80211_EXT_FEATURE_FILS_SK_OFFLOAD) &&\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_SK)\n\t\t\treturn false;\n\t\treturn true;\n\tcase NL80211_CMD_START_AP:\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD_AP) &&\n\t\t    auth_type == NL80211_AUTHTYPE_SAE)\n\t\t\treturn false;\n\t\t \n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t\t    auth_type == NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn false;\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void nl80211_send_ap_started(struct wireless_dev *wdev,\n\t\t\t\t    unsigned int link_id)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_START_AP);\n\tif (!hdr)\n\t\tgoto out;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (wdev->u.ap.ssid_len &&\n\t     nla_put(msg, NL80211_ATTR_SSID, wdev->u.ap.ssid_len,\n\t\t     wdev->u.ap.ssid)) ||\n\t    (wdev->valid_links &&\n\t     nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link_id)))\n\t\tgoto out;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\nout:\n\tnlmsg_free(msg);\n}\n\nstatic int nl80211_validate_ap_phy_operation(struct cfg80211_ap_settings *params)\n{\n\tstruct ieee80211_channel *channel = params->chandef.chan;\n\n\tif ((params->he_cap ||  params->he_oper) &&\n\t    (channel->flags & IEEE80211_CHAN_NO_HE))\n\t\treturn -EOPNOTSUPP;\n\n\tif ((params->eht_cap || params->eht_oper) &&\n\t    (channel->flags & IEEE80211_CHAN_NO_EHT))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int nl80211_start_ap(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tunsigned int link_id = nl80211_link_id(info->attrs);\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ap_settings *params;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->start_ap)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->links[link_id].ap.beacon_interval)\n\t\treturn -EALREADY;\n\n\t \n\tif (!info->attrs[NL80211_ATTR_BEACON_INTERVAL] ||\n\t    !info->attrs[NL80211_ATTR_DTIM_PERIOD] ||\n\t    !info->attrs[NL80211_ATTR_BEACON_HEAD])\n\t\treturn -EINVAL;\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params->beacon,\n\t\t\t\t   info->extack);\n\tif (err)\n\t\tgoto out;\n\n\tparams->beacon_interval =\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\tparams->dtim_period =\n\t\tnla_get_u32(info->attrs[NL80211_ATTR_DTIM_PERIOD]);\n\n\terr = cfg80211_validate_beacon_int(rdev, dev->ieee80211_ptr->iftype,\n\t\t\t\t\t   params->beacon_interval);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif (info->attrs[NL80211_ATTR_SSID]) {\n\t\tparams->ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\t\tparams->ssid_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tif (params->ssid_len == 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (wdev->u.ap.ssid_len &&\n\t\t    (wdev->u.ap.ssid_len != params->ssid_len ||\n\t\t     memcmp(wdev->u.ap.ssid, params->ssid, params->ssid_len))) {\n\t\t\t \n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else if (wdev->valid_links) {\n\t\t \n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HIDDEN_SSID])\n\t\tparams->hidden_ssid = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_HIDDEN_SSID]);\n\n\tparams->privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tparams->auth_type = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, params->auth_type,\n\t\t\t\t\t     NL80211_CMD_START_AP)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tparams->auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\terr = nl80211_crypto_settings(rdev, info, &params->crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\tgoto out;\n\n\tif (info->attrs[NL80211_ATTR_INACTIVITY_TIMEOUT]) {\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_INACTIVITY_TIMER)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tparams->inactivity_timeout = nla_get_u16(\n\t\t\tinfo->attrs[NL80211_ATTR_INACTIVITY_TIMEOUT]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_CTWINDOW]) {\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tparams->p2p_ctwindow =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_P2P_CTWINDOW]);\n\t\tif (params->p2p_ctwindow != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_CTWIN)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_OPPPS]) {\n\t\tu8 tmp;\n\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ttmp = nla_get_u8(info->attrs[NL80211_ATTR_P2P_OPPPS]);\n\t\tparams->p2p_opp_ps = tmp;\n\t\tif (params->p2p_opp_ps != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_OPPPS)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &params->chandef);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (wdev->valid_links) {\n\t\t \n\t\terr = -EINVAL;\n\t\tgoto out;\n\t} else if (wdev->u.ap.preset_chandef.chan) {\n\t\tparams->chandef = wdev->u.ap.preset_chandef;\n\t} else if (!nl80211_get_ap_channel(rdev, params)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PUNCT_BITMAP]) {\n\t\terr = nl80211_parse_punct_bitmap(rdev, info,\n\t\t\t\t\t\t &params->chandef,\n\t\t\t\t\t\t &params->punct_bitmap);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &params->chandef,\n\t\t\t\t\t   wdev->iftype)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\twdev_lock(wdev);\n\n\tif (info->attrs[NL80211_ATTR_TX_RATES]) {\n\t\terr = nl80211_parse_tx_bitrate_mask(info, info->attrs,\n\t\t\t\t\t\t    NL80211_ATTR_TX_RATES,\n\t\t\t\t\t\t    &params->beacon_rate,\n\t\t\t\t\t\t    dev, false, link_id);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\terr = validate_beacon_tx_rate(rdev, params->chandef.chan->band,\n\t\t\t\t\t      &params->beacon_rate);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SMPS_MODE]) {\n\t\tparams->smps_mode =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_SMPS_MODE]);\n\t\tswitch (params->smps_mode) {\n\t\tcase NL80211_SMPS_OFF:\n\t\t\tbreak;\n\t\tcase NL80211_SMPS_STATIC:\n\t\t\tif (!(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_STATIC_SMPS)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NL80211_SMPS_DYNAMIC:\n\t\t\tif (!(rdev->wiphy.features &\n\t\t\t      NL80211_FEATURE_DYNAMIC_SMPS)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tparams->smps_mode = NL80211_SMPS_OFF;\n\t}\n\n\tparams->pbss = nla_get_flag(info->attrs[NL80211_ATTR_PBSS]);\n\tif (params->pbss && !rdev->wiphy.bands[NL80211_BAND_60GHZ]) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_unlock;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_ACL_POLICY]) {\n\t\tparams->acl = parse_acl_data(&rdev->wiphy, info);\n\t\tif (IS_ERR(params->acl)) {\n\t\t\terr = PTR_ERR(params->acl);\n\t\t\tparams->acl = NULL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tparams->twt_responder =\n\t\t    nla_get_flag(info->attrs[NL80211_ATTR_TWT_RESPONDER]);\n\n\tif (info->attrs[NL80211_ATTR_HE_OBSS_PD]) {\n\t\terr = nl80211_parse_he_obss_pd(\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_HE_OBSS_PD],\n\t\t\t\t\t&params->he_obss_pd);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_FILS_DISCOVERY]) {\n\t\terr = nl80211_parse_fils_discovery(rdev,\n\t\t\t\t\t\t   info->attrs[NL80211_ATTR_FILS_DISCOVERY],\n\t\t\t\t\t\t   params);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_UNSOL_BCAST_PROBE_RESP]) {\n\t\terr = nl80211_parse_unsol_bcast_probe_resp(\n\t\t\trdev, info->attrs[NL80211_ATTR_UNSOL_BCAST_PROBE_RESP],\n\t\t\tparams);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MBSSID_CONFIG]) {\n\t\terr = nl80211_parse_mbssid_config(&rdev->wiphy, dev,\n\t\t\t\t\t\t  info->attrs[NL80211_ATTR_MBSSID_CONFIG],\n\t\t\t\t\t\t  &params->mbssid_config,\n\t\t\t\t\t\t  params->beacon.mbssid_ies ?\n\t\t\t\t\t\t\tparams->beacon.mbssid_ies->cnt :\n\t\t\t\t\t\t\t0);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (!params->mbssid_config.ema && params->beacon.rnr_ies) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\terr = nl80211_calculate_ap_params(params);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = nl80211_validate_ap_phy_operation(params);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tif (info->attrs[NL80211_ATTR_AP_SETTINGS_FLAGS])\n\t\tparams->flags = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_AP_SETTINGS_FLAGS]);\n\telse if (info->attrs[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT])\n\t\tparams->flags |= NL80211_AP_SETTINGS_EXTERNAL_AUTH_SUPPORT;\n\n\tif (wdev->conn_owner_nlportid &&\n\t    info->attrs[NL80211_ATTR_SOCKET_OWNER] &&\n\t    wdev->conn_owner_nlportid != info->snd_portid) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\n\terr = rdev_start_ap(rdev, dev, params);\n\tif (!err) {\n\t\twdev->links[link_id].ap.beacon_interval = params->beacon_interval;\n\t\twdev->links[link_id].ap.chandef = params->chandef;\n\t\twdev->u.ap.ssid_len = params->ssid_len;\n\t\tmemcpy(wdev->u.ap.ssid, params->ssid,\n\t\t       params->ssid_len);\n\n\t\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\t\twdev->conn_owner_nlportid = info->snd_portid;\n\n\t\tnl80211_send_ap_started(wdev, link_id);\n\t}\nout_unlock:\n\twdev_unlock(wdev);\nout:\n\tkfree(params->acl);\n\tkfree(params->beacon.mbssid_ies);\n\tif (params->mbssid_config.tx_wdev &&\n\t    params->mbssid_config.tx_wdev->netdev &&\n\t    params->mbssid_config.tx_wdev->netdev != dev)\n\t\tdev_put(params->mbssid_config.tx_wdev->netdev);\n\tkfree(params->beacon.rnr_ies);\n\tkfree(params);\n\n\treturn err;\n}\n\nstatic int nl80211_set_beacon(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tunsigned int link_id = nl80211_link_id(info->attrs);\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_beacon_data params;\n\tint err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->change_beacon)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev->links[link_id].ap.beacon_interval)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params, info->extack);\n\tif (err)\n\t\tgoto out;\n\n\twdev_lock(wdev);\n\terr = rdev_change_beacon(rdev, dev, &params);\n\twdev_unlock(wdev);\n\nout:\n\tkfree(params.mbssid_ies);\n\tkfree(params.rnr_ies);\n\treturn err;\n}\n\nstatic int nl80211_stop_ap(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tunsigned int link_id = nl80211_link_id(info->attrs);\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_stop_ap(rdev, dev, link_id, false);\n}\n\nstatic const struct nla_policy sta_flags_policy[NL80211_STA_FLAG_MAX + 1] = {\n\t[NL80211_STA_FLAG_AUTHORIZED] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_SHORT_PREAMBLE] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_WME] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_MFP] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_AUTHENTICATED] = { .type = NLA_FLAG },\n\t[NL80211_STA_FLAG_TDLS_PEER] = { .type = NLA_FLAG },\n};\n\nstatic int parse_station_flags(struct genl_info *info,\n\t\t\t       enum nl80211_iftype iftype,\n\t\t\t       struct station_parameters *params)\n{\n\tstruct nlattr *flags[NL80211_STA_FLAG_MAX + 1];\n\tstruct nlattr *nla;\n\tint flag;\n\n\t \n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS2];\n\tif (nla) {\n\t\tstruct nl80211_sta_flag_update *sta_flags;\n\n\t\tsta_flags = nla_data(nla);\n\t\tparams->sta_flags_mask = sta_flags->mask;\n\t\tparams->sta_flags_set = sta_flags->set;\n\t\tparams->sta_flags_set &= params->sta_flags_mask;\n\t\tif ((params->sta_flags_mask |\n\t\t     params->sta_flags_set) & BIT(__NL80211_STA_FLAG_INVALID))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t \n\n\tnla = info->attrs[NL80211_ATTR_STA_FLAGS];\n\tif (!nla)\n\t\treturn 0;\n\n\tif (nla_parse_nested_deprecated(flags, NL80211_STA_FLAG_MAX, nla, sta_flags_policy, info->extack))\n\t\treturn -EINVAL;\n\n\t \n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_WME) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_MFP);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tparams->sta_flags_mask = BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\t\t BIT(NL80211_STA_FLAG_AUTHORIZED);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (flag = 1; flag <= NL80211_STA_FLAG_MAX; flag++) {\n\t\tif (flags[flag]) {\n\t\t\tparams->sta_flags_set |= (1<<flag);\n\n\t\t\t \n\t\t\tif (flag > NL80211_STA_FLAG_MAX_OLD_API)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nbool nl80211_put_sta_rate(struct sk_buff *msg, struct rate_info *info, int attr)\n{\n\tstruct nlattr *rate;\n\tu32 bitrate;\n\tu16 bitrate_compat;\n\tenum nl80211_rate_info rate_flg;\n\n\trate = nla_nest_start_noflag(msg, attr);\n\tif (!rate)\n\t\treturn false;\n\n\t \n\tbitrate = cfg80211_calculate_bitrate(info);\n\t \n\tbitrate_compat = bitrate < (1UL << 16) ? bitrate : 0;\n\tif (bitrate > 0 &&\n\t    nla_put_u32(msg, NL80211_RATE_INFO_BITRATE32, bitrate))\n\t\treturn false;\n\tif (bitrate_compat > 0 &&\n\t    nla_put_u16(msg, NL80211_RATE_INFO_BITRATE, bitrate_compat))\n\t\treturn false;\n\n\tswitch (info->bw) {\n\tcase RATE_INFO_BW_1:\n\t\trate_flg = NL80211_RATE_INFO_1_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_2:\n\t\trate_flg = NL80211_RATE_INFO_2_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_4:\n\t\trate_flg = NL80211_RATE_INFO_4_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_5:\n\t\trate_flg = NL80211_RATE_INFO_5_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_8:\n\t\trate_flg = NL80211_RATE_INFO_8_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_10:\n\t\trate_flg = NL80211_RATE_INFO_10_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_16:\n\t\trate_flg = NL80211_RATE_INFO_16_MHZ_WIDTH;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase RATE_INFO_BW_20:\n\t\trate_flg = 0;\n\t\tbreak;\n\tcase RATE_INFO_BW_40:\n\t\trate_flg = NL80211_RATE_INFO_40_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_80:\n\t\trate_flg = NL80211_RATE_INFO_80_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_160:\n\t\trate_flg = NL80211_RATE_INFO_160_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_HE_RU:\n\t\trate_flg = 0;\n\t\tWARN_ON(!(info->flags & RATE_INFO_FLAGS_HE_MCS));\n\t\tbreak;\n\tcase RATE_INFO_BW_320:\n\t\trate_flg = NL80211_RATE_INFO_320_MHZ_WIDTH;\n\t\tbreak;\n\tcase RATE_INFO_BW_EHT_RU:\n\t\trate_flg = 0;\n\t\tWARN_ON(!(info->flags & RATE_INFO_FLAGS_EHT_MCS));\n\t\tbreak;\n\t}\n\n\tif (rate_flg && nla_put_flag(msg, rate_flg))\n\t\treturn false;\n\n\tif (info->flags & RATE_INFO_FLAGS_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI &&\n\t\t    nla_put_flag(msg, NL80211_RATE_INFO_SHORT_GI))\n\t\t\treturn false;\n\t} else if (info->flags & RATE_INFO_FLAGS_VHT_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_VHT_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_VHT_NSS, info->nss))\n\t\t\treturn false;\n\t\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI &&\n\t\t    nla_put_flag(msg, NL80211_RATE_INFO_SHORT_GI))\n\t\t\treturn false;\n\t} else if (info->flags & RATE_INFO_FLAGS_HE_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_NSS, info->nss))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_GI, info->he_gi))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_HE_DCM, info->he_dcm))\n\t\t\treturn false;\n\t\tif (info->bw == RATE_INFO_BW_HE_RU &&\n\t\t    nla_put_u8(msg, NL80211_RATE_INFO_HE_RU_ALLOC,\n\t\t\t       info->he_ru_alloc))\n\t\t\treturn false;\n\t} else if (info->flags & RATE_INFO_FLAGS_S1G_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_S1G_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_S1G_NSS, info->nss))\n\t\t\treturn false;\n\t\tif (info->flags & RATE_INFO_FLAGS_SHORT_GI &&\n\t\t    nla_put_flag(msg, NL80211_RATE_INFO_SHORT_GI))\n\t\t\treturn false;\n\t} else if (info->flags & RATE_INFO_FLAGS_EHT_MCS) {\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_EHT_MCS, info->mcs))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_EHT_NSS, info->nss))\n\t\t\treturn false;\n\t\tif (nla_put_u8(msg, NL80211_RATE_INFO_EHT_GI, info->eht_gi))\n\t\t\treturn false;\n\t\tif (info->bw == RATE_INFO_BW_EHT_RU &&\n\t\t    nla_put_u8(msg, NL80211_RATE_INFO_EHT_RU_ALLOC,\n\t\t\t       info->eht_ru_alloc))\n\t\t\treturn false;\n\t}\n\n\tnla_nest_end(msg, rate);\n\treturn true;\n}\n\nstatic bool nl80211_put_signal(struct sk_buff *msg, u8 mask, s8 *signal,\n\t\t\t       int id)\n{\n\tvoid *attr;\n\tint i = 0;\n\n\tif (!mask)\n\t\treturn true;\n\n\tattr = nla_nest_start_noflag(msg, id);\n\tif (!attr)\n\t\treturn false;\n\n\tfor (i = 0; i < IEEE80211_MAX_CHAINS; i++) {\n\t\tif (!(mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tif (nla_put_u8(msg, i, signal[i]))\n\t\t\treturn false;\n\t}\n\n\tnla_nest_end(msg, attr);\n\n\treturn true;\n}\n\nstatic int nl80211_send_station(struct sk_buff *msg, u32 cmd, u32 portid,\n\t\t\t\tu32 seq, int flags,\n\t\t\t\tstruct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *dev,\n\t\t\t\tconst u8 *mac_addr, struct station_info *sinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *sinfoattr, *bss_param;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr) {\n\t\tcfg80211_sinfo_release_content(sinfo);\n\t\treturn -1;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION, sinfo->generation))\n\t\tgoto nla_put_failure;\n\n\tsinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_STA_INFO);\n\tif (!sinfoattr)\n\t\tgoto nla_put_failure;\n\n#define PUT_SINFO(attr, memb, type) do {\t\t\t\t\\\n\tBUILD_BUG_ON(sizeof(type) == sizeof(u64));\t\t\t\\\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_ ## attr) &&\t\\\n\t    nla_put_ ## type(msg, NL80211_STA_INFO_ ## attr,\t\t\\\n\t\t\t     sinfo->memb))\t\t\t\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n#define PUT_SINFO_U64(attr, memb) do {\t\t\t\t\t\\\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_ ## attr) &&\t\\\n\t    nla_put_u64_64bit(msg, NL80211_STA_INFO_ ## attr,\t\t\\\n\t\t\t      sinfo->memb, NL80211_STA_INFO_PAD))\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n\n\tPUT_SINFO(CONNECTED_TIME, connected_time, u32);\n\tPUT_SINFO(INACTIVE_TIME, inactive_time, u32);\n\tPUT_SINFO_U64(ASSOC_AT_BOOTTIME, assoc_at);\n\n\tif (sinfo->filled & (BIT_ULL(NL80211_STA_INFO_RX_BYTES) |\n\t\t\t     BIT_ULL(NL80211_STA_INFO_RX_BYTES64)) &&\n\t    nla_put_u32(msg, NL80211_STA_INFO_RX_BYTES,\n\t\t\t(u32)sinfo->rx_bytes))\n\t\tgoto nla_put_failure;\n\n\tif (sinfo->filled & (BIT_ULL(NL80211_STA_INFO_TX_BYTES) |\n\t\t\t     BIT_ULL(NL80211_STA_INFO_TX_BYTES64)) &&\n\t    nla_put_u32(msg, NL80211_STA_INFO_TX_BYTES,\n\t\t\t(u32)sinfo->tx_bytes))\n\t\tgoto nla_put_failure;\n\n\tPUT_SINFO_U64(RX_BYTES64, rx_bytes);\n\tPUT_SINFO_U64(TX_BYTES64, tx_bytes);\n\tPUT_SINFO(LLID, llid, u16);\n\tPUT_SINFO(PLID, plid, u16);\n\tPUT_SINFO(PLINK_STATE, plink_state, u8);\n\tPUT_SINFO_U64(RX_DURATION, rx_duration);\n\tPUT_SINFO_U64(TX_DURATION, tx_duration);\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\tPUT_SINFO(AIRTIME_WEIGHT, airtime_weight, u16);\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tPUT_SINFO(SIGNAL, signal, u8);\n\t\tPUT_SINFO(SIGNAL_AVG, signal_avg, u8);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL)) {\n\t\tif (!nl80211_put_signal(msg, sinfo->chains,\n\t\t\t\t\tsinfo->chain_signal,\n\t\t\t\t\tNL80211_STA_INFO_CHAIN_SIGNAL))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL_AVG)) {\n\t\tif (!nl80211_put_signal(msg, sinfo->chains,\n\t\t\t\t\tsinfo->chain_signal_avg,\n\t\t\t\t\tNL80211_STA_INFO_CHAIN_SIGNAL_AVG))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_BITRATE)) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->txrate,\n\t\t\t\t\t  NL80211_STA_INFO_TX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_RX_BITRATE)) {\n\t\tif (!nl80211_put_sta_rate(msg, &sinfo->rxrate,\n\t\t\t\t\t  NL80211_STA_INFO_RX_BITRATE))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tPUT_SINFO(RX_PACKETS, rx_packets, u32);\n\tPUT_SINFO(TX_PACKETS, tx_packets, u32);\n\tPUT_SINFO(TX_RETRIES, tx_retries, u32);\n\tPUT_SINFO(TX_FAILED, tx_failed, u32);\n\tPUT_SINFO(EXPECTED_THROUGHPUT, expected_throughput, u32);\n\tPUT_SINFO(AIRTIME_LINK_METRIC, airtime_link_metric, u32);\n\tPUT_SINFO(BEACON_LOSS, beacon_loss_count, u32);\n\tPUT_SINFO(LOCAL_PM, local_pm, u32);\n\tPUT_SINFO(PEER_PM, peer_pm, u32);\n\tPUT_SINFO(NONPEER_PM, nonpeer_pm, u32);\n\tPUT_SINFO(CONNECTED_TO_GATE, connected_to_gate, u8);\n\tPUT_SINFO(CONNECTED_TO_AS, connected_to_as, u8);\n\n\tif (sinfo->filled & BIT_ULL(NL80211_STA_INFO_BSS_PARAM)) {\n\t\tbss_param = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_STA_INFO_BSS_PARAM);\n\t\tif (!bss_param)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (((sinfo->bss_param.flags & BSS_PARAM_FLAGS_CTS_PROT) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_CTS_PROT)) ||\n\t\t    ((sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_PREAMBLE) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_SHORT_PREAMBLE)) ||\n\t\t    ((sinfo->bss_param.flags & BSS_PARAM_FLAGS_SHORT_SLOT_TIME) &&\n\t\t     nla_put_flag(msg, NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME)) ||\n\t\t    nla_put_u8(msg, NL80211_STA_BSS_PARAM_DTIM_PERIOD,\n\t\t\t       sinfo->bss_param.dtim_period) ||\n\t\t    nla_put_u16(msg, NL80211_STA_BSS_PARAM_BEACON_INTERVAL,\n\t\t\t\tsinfo->bss_param.beacon_interval))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, bss_param);\n\t}\n\tif ((sinfo->filled & BIT_ULL(NL80211_STA_INFO_STA_FLAGS)) &&\n\t    nla_put(msg, NL80211_STA_INFO_STA_FLAGS,\n\t\t    sizeof(struct nl80211_sta_flag_update),\n\t\t    &sinfo->sta_flags))\n\t\tgoto nla_put_failure;\n\n\tPUT_SINFO_U64(T_OFFSET, t_offset);\n\tPUT_SINFO_U64(RX_DROP_MISC, rx_dropped_misc);\n\tPUT_SINFO_U64(BEACON_RX, rx_beacon);\n\tPUT_SINFO(BEACON_SIGNAL_AVG, rx_beacon_signal_avg, u8);\n\tPUT_SINFO(RX_MPDUS, rx_mpdu_count, u32);\n\tPUT_SINFO(FCS_ERROR_COUNT, fcs_err_count, u32);\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT)) {\n\t\tPUT_SINFO(ACK_SIGNAL, ack_signal, u8);\n\t\tPUT_SINFO(ACK_SIGNAL_AVG, avg_ack_signal, s8);\n\t}\n\n#undef PUT_SINFO\n#undef PUT_SINFO_U64\n\n\tif (sinfo->pertid) {\n\t\tstruct nlattr *tidsattr;\n\t\tint tid;\n\n\t\ttidsattr = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t NL80211_STA_INFO_TID_STATS);\n\t\tif (!tidsattr)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (tid = 0; tid < IEEE80211_NUM_TIDS + 1; tid++) {\n\t\t\tstruct cfg80211_tid_stats *tidstats;\n\t\t\tstruct nlattr *tidattr;\n\n\t\t\ttidstats = &sinfo->pertid[tid];\n\n\t\t\tif (!tidstats->filled)\n\t\t\t\tcontinue;\n\n\t\t\ttidattr = nla_nest_start_noflag(msg, tid + 1);\n\t\t\tif (!tidattr)\n\t\t\t\tgoto nla_put_failure;\n\n#define PUT_TIDVAL_U64(attr, memb) do {\t\t\t\t\t\\\n\tif (tidstats->filled & BIT(NL80211_TID_STATS_ ## attr) &&\t\\\n\t    nla_put_u64_64bit(msg, NL80211_TID_STATS_ ## attr,\t\t\\\n\t\t\t      tidstats->memb, NL80211_TID_STATS_PAD))\t\\\n\t\tgoto nla_put_failure;\t\t\t\t\t\\\n\t} while (0)\n\n\t\t\tPUT_TIDVAL_U64(RX_MSDU, rx_msdu);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU, tx_msdu);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU_RETRIES, tx_msdu_retries);\n\t\t\tPUT_TIDVAL_U64(TX_MSDU_FAILED, tx_msdu_failed);\n\n#undef PUT_TIDVAL_U64\n\t\t\tif ((tidstats->filled &\n\t\t\t     BIT(NL80211_TID_STATS_TXQ_STATS)) &&\n\t\t\t    !nl80211_put_txq_stats(msg, &tidstats->txq_stats,\n\t\t\t\t\t\t   NL80211_TID_STATS_TXQ_STATS))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, tidattr);\n\t\t}\n\n\t\tnla_nest_end(msg, tidsattr);\n\t}\n\n\tnla_nest_end(msg, sinfoattr);\n\n\tif (sinfo->assoc_req_ies_len &&\n\t    nla_put(msg, NL80211_ATTR_IE, sinfo->assoc_req_ies_len,\n\t\t    sinfo->assoc_req_ies))\n\t\tgoto nla_put_failure;\n\n\tif (sinfo->assoc_resp_ies_len &&\n\t    nla_put(msg, NL80211_ATTR_RESP_IE, sinfo->assoc_resp_ies_len,\n\t\t    sinfo->assoc_resp_ies))\n\t\tgoto nla_put_failure;\n\n\tif (sinfo->mlo_params_valid) {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID,\n\t\t\t       sinfo->assoc_link_id))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (!is_zero_ether_addr(sinfo->mld_addr) &&\n\t\t    nla_put(msg, NL80211_ATTR_MLD_ADDR, ETH_ALEN,\n\t\t\t    sinfo->mld_addr))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tcfg80211_sinfo_release_content(sinfo);\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tcfg80211_sinfo_release_content(sinfo);\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_station(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tstruct station_info sinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 mac_addr[ETH_ALEN];\n\tint sta_idx = cb->args[2];\n\tint err;\n\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev, NULL);\n\tif (err)\n\t\treturn err;\n\t \n\t__acquire(&rdev->wiphy.mtx);\n\n\tif (!wdev->netdev) {\n\t\terr = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (!rdev->ops->dump_station) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tmemset(&sinfo, 0, sizeof(sinfo));\n\t\terr = rdev_dump_station(rdev, wdev->netdev, sta_idx,\n\t\t\t\t\tmac_addr, &sinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_station(skb, NL80211_CMD_NEW_STATION,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev->netdev, mac_addr,\n\t\t\t\t&sinfo) < 0)\n\t\t\tgoto out;\n\n\t\tsta_idx++;\n\t}\n\n out:\n\tcb->args[2] = sta_idx;\n\terr = skb->len;\n out_err:\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn err;\n}\n\nstatic int nl80211_get_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_info sinfo;\n\tstruct sk_buff *msg;\n\tu8 *mac_addr = NULL;\n\tint err;\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_station(rdev, dev, mac_addr, &sinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tcfg80211_sinfo_release_content(&sinfo);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (nl80211_send_station(msg, NL80211_CMD_NEW_STATION,\n\t\t\t\t info->snd_portid, info->snd_seq, 0,\n\t\t\t\t rdev, dev, mac_addr, &sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nint cfg80211_check_station_change(struct wiphy *wiphy,\n\t\t\t\t  struct station_parameters *params,\n\t\t\t\t  enum cfg80211_station_type statype)\n{\n\tif (params->listen_interval != -1 &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\tif (params->support_p2p_ps != -1 &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\tif (params->aid &&\n\t    !(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC)\n\t\treturn -EINVAL;\n\n\t \n\tBUILD_BUG_ON(NL80211_STA_FLAG_MAX != 7);\n\n\tswitch (statype) {\n\tcase CFG80211_STA_MESH_PEER_KERNEL:\n\tcase CFG80211_STA_MESH_PEER_USER:\n\t\t \n\t\tif (params->sta_flags_mask &\n\t\t\t\t~(BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_MFP) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_SETUP:\n\tcase CFG80211_STA_TDLS_PEER_ACTIVE:\n\t\tif (!(params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tparams->sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (params->plink_action != NL80211_PLINK_ACTION_NO_ACTION)\n\t\t\treturn -EINVAL;\n\t\tif (params->local_pm)\n\t\t\treturn -EINVAL;\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (statype != CFG80211_STA_TDLS_PEER_SETUP &&\n\t    statype != CFG80211_STA_TDLS_PEER_ACTIVE) {\n\t\t \n\t\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tparams->sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\t}\n\n\tif (statype != CFG80211_STA_TDLS_PEER_SETUP &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC) {\n\t\t \n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_UAPSD)\n\t\t\treturn -EINVAL;\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_CAPABILITY)\n\t\t\treturn -EINVAL;\n\t\tif (params->link_sta_params.supported_rates)\n\t\t\treturn -EINVAL;\n\t\tif (params->ext_capab || params->link_sta_params.ht_capa ||\n\t\t    params->link_sta_params.vht_capa ||\n\t\t    params->link_sta_params.he_capa ||\n\t\t    params->link_sta_params.eht_capa)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (statype != CFG80211_STA_AP_CLIENT &&\n\t    statype != CFG80211_STA_AP_CLIENT_UNASSOC) {\n\t\tif (params->vlan)\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (statype) {\n\tcase CFG80211_STA_AP_MLME_CLIENT:\n\t\t \n\t\tif (!(params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tcase CFG80211_STA_AP_CLIENT:\n\tcase CFG80211_STA_AP_CLIENT_UNASSOC:\n\t\t \n\t\tif (params->sta_flags_mask &\n\t\t\t\t~(BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_SHORT_PREAMBLE) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_WME) |\n\t\t\t\t  BIT(NL80211_STA_FLAG_MFP)))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!(wiphy->features & NL80211_FEATURE_FULL_AP_CLIENT_STATE) &&\n\t\t    params->sta_flags_mask &\n\t\t\t\t(BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t\t BIT(NL80211_STA_FLAG_ASSOCIATED)))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_IBSS:\n\tcase CFG80211_STA_AP_STA:\n\t\t \n\t\tif (params->sta_flags_mask & ~BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_SETUP:\n\t\t \n\t\tif (params->sta_flags_mask & ~(BIT(NL80211_STA_FLAG_AUTHORIZED) |\n\t\t\t\t\t       BIT(NL80211_STA_FLAG_WME)))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED) &&\n\t\t    !params->link_sta_params.supported_rates)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_TDLS_PEER_ACTIVE:\n\t\t \n\t\treturn -EINVAL;\n\tcase CFG80211_STA_MESH_PEER_KERNEL:\n\t\tif (params->sta_modify_mask & STATION_PARAM_APPLY_PLINK_STATE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase CFG80211_STA_MESH_PEER_USER:\n\t\tif (params->plink_action != NL80211_PLINK_ACTION_NO_ACTION &&\n\t\t    params->plink_action != NL80211_PLINK_ACTION_BLOCK)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\t \n\tif (statype != CFG80211_STA_AP_CLIENT_UNASSOC &&\n\t    statype != CFG80211_STA_TDLS_PEER_SETUP)\n\t\tparams->link_sta_params.opmode_notif_used = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cfg80211_check_station_change);\n\n \nstatic struct net_device *get_vlan(struct genl_info *info,\n\t\t\t\t   struct cfg80211_registered_device *rdev)\n{\n\tstruct nlattr *vlanattr = info->attrs[NL80211_ATTR_STA_VLAN];\n\tstruct net_device *v;\n\tint ret;\n\n\tif (!vlanattr)\n\t\treturn NULL;\n\n\tv = dev_get_by_index(genl_info_net(info), nla_get_u32(vlanattr));\n\tif (!v)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (!v->ieee80211_ptr || v->ieee80211_ptr->wiphy != &rdev->wiphy) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (v->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&\n\t    v->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    v->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (!netif_running(v)) {\n\t\tret = -ENETDOWN;\n\t\tgoto error;\n\t}\n\n\treturn v;\n error:\n\tdev_put(v);\n\treturn ERR_PTR(ret);\n}\n\nstatic int nl80211_parse_sta_wme(struct genl_info *info,\n\t\t\t\t struct station_parameters *params)\n{\n\tstruct nlattr *tb[NL80211_STA_WME_MAX + 1];\n\tstruct nlattr *nla;\n\tint err;\n\n\t \n\tif (!info->attrs[NL80211_ATTR_STA_WME])\n\t\treturn 0;\n\n\tnla = info->attrs[NL80211_ATTR_STA_WME];\n\terr = nla_parse_nested_deprecated(tb, NL80211_STA_WME_MAX, nla,\n\t\t\t\t\t  nl80211_sta_wme_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_STA_WME_UAPSD_QUEUES])\n\t\tparams->uapsd_queues = nla_get_u8(\n\t\t\ttb[NL80211_STA_WME_UAPSD_QUEUES]);\n\tif (params->uapsd_queues & ~IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_STA_WME_MAX_SP])\n\t\tparams->max_sp = nla_get_u8(tb[NL80211_STA_WME_MAX_SP]);\n\n\tif (params->max_sp & ~IEEE80211_WMM_IE_STA_QOSINFO_SP_MASK)\n\t\treturn -EINVAL;\n\n\tparams->sta_modify_mask |= STATION_PARAM_APPLY_UAPSD;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_sta_channel_info(struct genl_info *info,\n\t\t\t\t      struct station_parameters *params)\n{\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]) {\n\t\tparams->supported_channels =\n\t\t     nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]);\n\t\tparams->supported_channels_len =\n\t\t     nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_CHANNELS]);\n\t\t \n\t\tif (params->supported_channels_len % 2)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]) {\n\t\tparams->supported_oper_classes =\n\t\t nla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]);\n\t\tparams->supported_oper_classes_len =\n\t\t  nla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_OPER_CLASSES]);\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_set_station_tdls(struct genl_info *info,\n\t\t\t\t    struct station_parameters *params)\n{\n\tint err;\n\t \n\tif (info->attrs[NL80211_ATTR_PEER_AID])\n\t\tparams->aid = nla_get_u16(info->attrs[NL80211_ATTR_PEER_AID]);\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams->link_sta_params.ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY])\n\t\tparams->link_sta_params.vht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);\n\tif (info->attrs[NL80211_ATTR_HE_CAPABILITY]) {\n\t\tparams->link_sta_params.he_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t\tparams->link_sta_params.he_capa_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\n\t\tif (info->attrs[NL80211_ATTR_EHT_CAPABILITY]) {\n\t\t\tparams->link_sta_params.eht_capa =\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_EHT_CAPABILITY]);\n\t\t\tparams->link_sta_params.eht_capa_len =\n\t\t\t\tnla_len(info->attrs[NL80211_ATTR_EHT_CAPABILITY]);\n\n\t\t\tif (!ieee80211_eht_capa_size_ok((const u8 *)params->link_sta_params.he_capa,\n\t\t\t\t\t\t\t(const u8 *)params->link_sta_params.eht_capa,\n\t\t\t\t\t\t\tparams->link_sta_params.eht_capa_len,\n\t\t\t\t\t\t\tfalse))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\terr = nl80211_parse_sta_channel_info(info, params);\n\tif (err)\n\t\treturn err;\n\n\treturn nl80211_parse_sta_wme(info, params);\n}\n\nstatic int nl80211_parse_sta_txpower_setting(struct genl_info *info,\n\t\t\t\t\t     struct sta_txpwr *txpwr,\n\t\t\t\t\t     bool *txpwr_set)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint idx;\n\n\tif (info->attrs[NL80211_ATTR_STA_TX_POWER_SETTING]) {\n\t\tif (!rdev->ops->set_tx_power ||\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t NL80211_EXT_FEATURE_STA_TX_PWR))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tidx = NL80211_ATTR_STA_TX_POWER_SETTING;\n\t\ttxpwr->type = nla_get_u8(info->attrs[idx]);\n\n\t\tif (txpwr->type == NL80211_TX_POWER_LIMITED) {\n\t\t\tidx = NL80211_ATTR_STA_TX_POWER;\n\n\t\t\tif (info->attrs[idx])\n\t\t\t\ttxpwr->power = nla_get_s16(info->attrs[idx]);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*txpwr_set = true;\n\t} else {\n\t\t*txpwr_set = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_parameters params;\n\tu8 *mac_addr;\n\tint err;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!rdev->ops->change_station)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (info->attrs[NL80211_ATTR_STA_AID])\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);\n\n\tif (info->attrs[NL80211_ATTR_VLAN_ID])\n\t\tparams.vlan_id = nla_get_u16(info->attrs[NL80211_ATTR_VLAN_ID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\tparams.listen_interval =\n\t\t     nla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\telse\n\t\tparams.listen_interval = -1;\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS])\n\t\tparams.support_p2p_ps =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]);\n\telse\n\t\tparams.support_p2p_ps = -1;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tparams.link_sta_params.link_id =\n\t\tnl80211_link_id_or_invalid(info->attrs);\n\n\tif (info->attrs[NL80211_ATTR_MLD_ADDR]) {\n\t\t \n\t\tif (params.link_sta_params.link_id < 0)\n\t\t\treturn -EINVAL;\n\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MLD_ADDR]);\n\t\tparams.link_sta_params.mld_mac = mac_addr;\n\t\tparams.link_sta_params.link_mac =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MAC]);\n\t\tif (!is_valid_ether_addr(params.link_sta_params.link_mac))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\t}\n\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]) {\n\t\tparams.link_sta_params.supported_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t\tparams.link_sta_params.supported_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_CAPABILITY]) {\n\t\tparams.capability =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_CAPABILITY]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_CAPABILITY;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]) {\n\t\tparams.ext_capab =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t\tparams.ext_capab_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t}\n\n\tif (parse_station_flags(info, dev->ieee80211_ptr->iftype, &params))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_STATE]) {\n\t\tparams.plink_state =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_STATE]);\n\t\tif (info->attrs[NL80211_ATTR_MESH_PEER_AID])\n\t\t\tparams.peer_aid = nla_get_u16(\n\t\t\t\tinfo->attrs[NL80211_ATTR_MESH_PEER_AID]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_PLINK_STATE;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_LOCAL_MESH_POWER_MODE])\n\t\tparams.local_pm = nla_get_u32(\n\t\t\tinfo->attrs[NL80211_ATTR_LOCAL_MESH_POWER_MODE]);\n\n\tif (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {\n\t\tparams.link_sta_params.opmode_notif_used = true;\n\t\tparams.link_sta_params.opmode_notif =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY])\n\t\tparams.link_sta_params.he_6ghz_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])\n\t\tparams.airtime_weight =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);\n\n\tif (params.airtime_weight &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_sta_txpower_setting(info,\n\t\t\t\t\t\t&params.link_sta_params.txpwr,\n\t\t\t\t\t\t&params.link_sta_params.txpwr_set);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = nl80211_set_station_tdls(info, &params);\n\tif (err)\n\t\treturn err;\n\n\tparams.vlan = get_vlan(info, rdev);\n\tif (IS_ERR(params.vlan))\n\t\treturn PTR_ERR(params.vlan);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_put_vlan;\n\t}\n\n\t \n\twdev_lock(dev->ieee80211_ptr);\n\terr = rdev_change_station(rdev, dev, mac_addr, &params);\n\twdev_unlock(dev->ieee80211_ptr);\n\n out_put_vlan:\n\tdev_put(params.vlan);\n\n\treturn err;\n}\n\nstatic int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct station_parameters params;\n\tu8 *mac_addr = NULL;\n\tu32 auth_assoc = BIT(NL80211_STA_FLAG_AUTHENTICATED) |\n\t\t\t BIT(NL80211_STA_FLAG_ASSOCIATED);\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!rdev->ops->add_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STA_AID] &&\n\t    !info->attrs[NL80211_ATTR_PEER_AID])\n\t\treturn -EINVAL;\n\n\tparams.link_sta_params.link_id =\n\t\tnl80211_link_id_or_invalid(info->attrs);\n\n\tif (info->attrs[NL80211_ATTR_MLD_ADDR]) {\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MLD_ADDR]);\n\t\tparams.link_sta_params.mld_mac = mac_addr;\n\t\tparams.link_sta_params.link_mac =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MAC]);\n\t\tif (!is_valid_ether_addr(params.link_sta_params.link_mac))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tmac_addr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\t}\n\n\tparams.link_sta_params.supported_rates =\n\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.link_sta_params.supported_rates_len =\n\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\tparams.listen_interval =\n\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_LISTEN_INTERVAL]);\n\n\tif (info->attrs[NL80211_ATTR_VLAN_ID])\n\t\tparams.vlan_id = nla_get_u16(info->attrs[NL80211_ATTR_VLAN_ID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]) {\n\t\tparams.support_p2p_ps =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_SUPPORT_P2P_PS]);\n\t} else {\n\t\t \n\t\tparams.support_p2p_ps =\n\t\t\tdev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PEER_AID])\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_PEER_AID]);\n\telse\n\t\tparams.aid = nla_get_u16(info->attrs[NL80211_ATTR_STA_AID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_CAPABILITY]) {\n\t\tparams.capability =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_STA_CAPABILITY]);\n\t\tparams.sta_modify_mask |= STATION_PARAM_APPLY_CAPABILITY;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]) {\n\t\tparams.ext_capab =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t\tparams.ext_capab_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_EXT_CAPABILITY]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams.link_sta_params.ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY])\n\t\tparams.link_sta_params.vht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_HE_CAPABILITY]) {\n\t\tparams.link_sta_params.he_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t\tparams.link_sta_params.he_capa_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\n\t\tif (info->attrs[NL80211_ATTR_EHT_CAPABILITY]) {\n\t\t\tparams.link_sta_params.eht_capa =\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_EHT_CAPABILITY]);\n\t\t\tparams.link_sta_params.eht_capa_len =\n\t\t\t\tnla_len(info->attrs[NL80211_ATTR_EHT_CAPABILITY]);\n\n\t\t\tif (!ieee80211_eht_capa_size_ok((const u8 *)params.link_sta_params.he_capa,\n\t\t\t\t\t\t\t(const u8 *)params.link_sta_params.eht_capa,\n\t\t\t\t\t\t\tparams.link_sta_params.eht_capa_len,\n\t\t\t\t\t\t\tfalse))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY])\n\t\tparams.link_sta_params.he_6ghz_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {\n\t\tparams.link_sta_params.opmode_notif_used = true;\n\t\tparams.link_sta_params.opmode_notif =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_STA_PLINK_ACTION])\n\t\tparams.plink_action =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_STA_PLINK_ACTION]);\n\n\tif (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])\n\t\tparams.airtime_weight =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);\n\n\tif (params.airtime_weight &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_sta_txpower_setting(info,\n\t\t\t\t\t\t&params.link_sta_params.txpwr,\n\t\t\t\t\t\t&params.link_sta_params.txpwr_set);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_sta_channel_info(info, &params);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_sta_wme(info, &params);\n\tif (err)\n\t\treturn err;\n\n\tif (parse_station_flags(info, dev->ieee80211_ptr->iftype, &params))\n\t\treturn -EINVAL;\n\n\t \n\tif (!(params.sta_flags_set & BIT(NL80211_STA_FLAG_WME))) {\n\t\tparams.link_sta_params.ht_capa = NULL;\n\t\tparams.link_sta_params.vht_capa = NULL;\n\n\t\t \n\t\tif (params.link_sta_params.he_capa_len ||\n\t\t    params.link_sta_params.he_6ghz_capa ||\n\t\t    params.link_sta_params.eht_capa_len)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (params.link_sta_params.he_6ghz_capa &&\n\t    (params.link_sta_params.ht_capa || params.link_sta_params.vht_capa))\n\t\treturn -EINVAL;\n\n\t \n\tBUILD_BUG_ON(NL80211_STA_FLAG_MAX != 7);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t \n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_AP_UAPSD) ||\n\t\t    !(params.sta_flags_set & BIT(NL80211_STA_FLAG_WME)))\n\t\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t \n\t\tif ((params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) ||\n\t\t    info->attrs[NL80211_ATTR_PEER_AID])\n\t\t\treturn -EINVAL;\n\t\t \n\t\tparams.sta_flags_mask &= ~BIT(NL80211_STA_FLAG_TDLS_PEER);\n\n\t\t \n\t\tif (!(rdev->wiphy.features &\n\t\t\t\tNL80211_FEATURE_FULL_AP_CLIENT_STATE) &&\n\t\t    params.sta_flags_mask & auth_assoc)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!(params.sta_flags_mask & auth_assoc)) {\n\t\t\tparams.sta_flags_mask |= auth_assoc;\n\t\t\tparams.sta_flags_set |= auth_assoc;\n\t\t}\n\n\t\t \n\t\tparams.vlan = get_vlan(info, rdev);\n\t\tif (IS_ERR(params.vlan))\n\t\t\treturn PTR_ERR(params.vlan);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t \n\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t \n\t\tif (params.sta_flags_mask & BIT(NL80211_STA_FLAG_ASSOCIATED))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif ((params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)) ||\n\t\t    info->attrs[NL80211_ATTR_PEER_AID])\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t \n\t\tparams.sta_modify_mask &= ~STATION_PARAM_APPLY_UAPSD;\n\n\t\t \n\t\tif (params.sta_flags_mask &\n\t\t\t\t(BIT(NL80211_STA_FLAG_ASSOCIATED) |\n\t\t\t\t BIT(NL80211_STA_FLAG_AUTHENTICATED)))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (!(params.sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER)))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS))\n\t\t\treturn -EOPNOTSUPP;\n\t\t \n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP))\n\t\t\treturn -EOPNOTSUPP;\n\t\t \n\t\tparams.sta_flags_mask &= ~BIT(NL80211_STA_FLAG_AUTHORIZED);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\n\twdev_lock(dev->ieee80211_ptr);\n\tif (wdev->valid_links) {\n\t\tif (params.link_sta_params.link_id < 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!(wdev->valid_links & BIT(params.link_sta_params.link_id))) {\n\t\t\terr = -ENOLINK;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (params.link_sta_params.link_id >= 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = rdev_add_station(rdev, dev, mac_addr, &params);\nout:\n\twdev_unlock(dev->ieee80211_ptr);\n\tdev_put(params.vlan);\n\treturn err;\n}\n\nstatic int nl80211_del_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct station_del_parameters params;\n\tint ret;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tparams.mac = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t \n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t \n\t\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_DEL_IBSS_STA))\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->del_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_MGMT_SUBTYPE]) {\n\t\tparams.subtype =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_MGMT_SUBTYPE]);\n\t\tif (params.subtype != IEEE80211_STYPE_DISASSOC >> 4 &&\n\t\t    params.subtype != IEEE80211_STYPE_DEAUTH >> 4)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tparams.subtype = IEEE80211_STYPE_DEAUTH >> 4;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_REASON_CODE]) {\n\t\tparams.reason_code =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\t\tif (params.reason_code == 0)\n\t\t\treturn -EINVAL;  \n\t} else {\n\t\t \n\t\tparams.reason_code = WLAN_REASON_PREV_AUTH_NOT_VALID;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\tret = rdev_del_station(rdev, dev, &params);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn ret;\n}\n\nstatic int nl80211_send_mpath(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t\tint flags, struct net_device *dev,\n\t\t\t\tu8 *dst, u8 *next_hop,\n\t\t\t\tstruct mpath_info *pinfo)\n{\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, NL80211_CMD_NEW_MPATH);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, dst) ||\n\t    nla_put(msg, NL80211_ATTR_MPATH_NEXT_HOP, ETH_ALEN, next_hop) ||\n\t    nla_put_u32(msg, NL80211_ATTR_GENERATION, pinfo->generation))\n\t\tgoto nla_put_failure;\n\n\tpinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_MPATH_INFO);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif ((pinfo->filled & MPATH_INFO_FRAME_QLEN) &&\n\t    nla_put_u32(msg, NL80211_MPATH_INFO_FRAME_QLEN,\n\t\t\tpinfo->frame_qlen))\n\t\tgoto nla_put_failure;\n\tif (((pinfo->filled & MPATH_INFO_SN) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_SN, pinfo->sn)) ||\n\t    ((pinfo->filled & MPATH_INFO_METRIC) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_METRIC,\n\t\t\t pinfo->metric)) ||\n\t    ((pinfo->filled & MPATH_INFO_EXPTIME) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_EXPTIME,\n\t\t\t pinfo->exptime)) ||\n\t    ((pinfo->filled & MPATH_INFO_FLAGS) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_FLAGS,\n\t\t\tpinfo->flags)) ||\n\t    ((pinfo->filled & MPATH_INFO_DISCOVERY_TIMEOUT) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_DISCOVERY_TIMEOUT,\n\t\t\t pinfo->discovery_timeout)) ||\n\t    ((pinfo->filled & MPATH_INFO_DISCOVERY_RETRIES) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_DISCOVERY_RETRIES,\n\t\t\tpinfo->discovery_retries)) ||\n\t    ((pinfo->filled & MPATH_INFO_HOP_COUNT) &&\n\t     nla_put_u8(msg, NL80211_MPATH_INFO_HOP_COUNT,\n\t\t\tpinfo->hop_count)) ||\n\t    ((pinfo->filled & MPATH_INFO_PATH_CHANGE) &&\n\t     nla_put_u32(msg, NL80211_MPATH_INFO_PATH_CHANGE,\n\t\t\t pinfo->path_change_count)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, pinfoattr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_mpath(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 dst[ETH_ALEN];\n\tu8 next_hop[ETH_ALEN];\n\tint path_idx = cb->args[2];\n\tint err;\n\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev, NULL);\n\tif (err)\n\t\treturn err;\n\t \n\t__acquire(&rdev->wiphy.mtx);\n\n\tif (!rdev->ops->dump_mpath) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = rdev_dump_mpath(rdev, wdev->netdev, path_idx, dst,\n\t\t\t\t      next_hop, &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       wdev->netdev, dst, next_hop,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\n\t\tpath_idx++;\n\t}\n\n out:\n\tcb->args[2] = path_idx;\n\terr = skb->len;\n out_err:\n\twiphy_unlock(&rdev->wiphy);\n\treturn err;\n}\n\nstatic int nl80211_get_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mpath_info pinfo;\n\tstruct sk_buff *msg;\n\tu8 *dst = NULL;\n\tu8 next_hop[ETH_ALEN];\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_mpath(rdev, dev, dst, next_hop, &pinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_mpath(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t\t dev, dst, next_hop, &pinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_set_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->change_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_change_mpath(rdev, dev, dst, next_hop);\n}\n\nstatic int nl80211_new_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\tu8 *next_hop = NULL;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MPATH_NEXT_HOP])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tnext_hop = nla_data(info->attrs[NL80211_ATTR_MPATH_NEXT_HOP]);\n\n\tif (!rdev->ops->add_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_add_mpath(rdev, dev, dst, next_hop);\n}\n\nstatic int nl80211_del_mpath(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *dst = NULL;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->del_mpath)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_del_mpath(rdev, dev, dst);\n}\n\nstatic int nl80211_get_mpp(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint err;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mpath_info pinfo;\n\tstruct sk_buff *msg;\n\tu8 *dst = NULL;\n\tu8 mpp[ETH_ALEN];\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tdst = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (!rdev->ops->get_mpp)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_mpp(rdev, dev, dst, mpp, &pinfo);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nl80211_send_mpath(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t       dev, dst, mpp, &pinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nl80211_dump_mpp(struct sk_buff *skb,\n\t\t\t    struct netlink_callback *cb)\n{\n\tstruct mpath_info pinfo;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tu8 dst[ETH_ALEN];\n\tu8 mpp[ETH_ALEN];\n\tint path_idx = cb->args[2];\n\tint err;\n\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev, NULL);\n\tif (err)\n\t\treturn err;\n\t \n\t__acquire(&rdev->wiphy.mtx);\n\n\tif (!rdev->ops->dump_mpp) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\terr = rdev_dump_mpp(rdev, wdev->netdev, path_idx, dst,\n\t\t\t\t    mpp, &pinfo);\n\t\tif (err == -ENOENT)\n\t\t\tbreak;\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (nl80211_send_mpath(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t       cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t       wdev->netdev, dst, mpp,\n\t\t\t\t       &pinfo) < 0)\n\t\t\tgoto out;\n\n\t\tpath_idx++;\n\t}\n\n out:\n\tcb->args[2] = path_idx;\n\terr = skb->len;\n out_err:\n\twiphy_unlock(&rdev->wiphy);\n\treturn err;\n}\n\nstatic int nl80211_set_bss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct bss_parameters params;\n\tint err;\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.link_id = nl80211_link_id_or_invalid(info->attrs);\n\t \n\tparams.use_cts_prot = -1;\n\tparams.use_short_preamble = -1;\n\tparams.use_short_slot_time = -1;\n\tparams.ap_isolate = -1;\n\tparams.ht_opmode = -1;\n\tparams.p2p_ctwindow = -1;\n\tparams.p2p_opp_ps = -1;\n\n\tif (info->attrs[NL80211_ATTR_BSS_CTS_PROT])\n\t\tparams.use_cts_prot =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_CTS_PROT]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE])\n\t\tparams.use_short_preamble =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_PREAMBLE]);\n\tif (info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME])\n\t\tparams.use_short_slot_time =\n\t\t    nla_get_u8(info->attrs[NL80211_ATTR_BSS_SHORT_SLOT_TIME]);\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tparams.basic_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tparams.basic_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t}\n\tif (info->attrs[NL80211_ATTR_AP_ISOLATE])\n\t\tparams.ap_isolate = !!nla_get_u8(info->attrs[NL80211_ATTR_AP_ISOLATE]);\n\tif (info->attrs[NL80211_ATTR_BSS_HT_OPMODE])\n\t\tparams.ht_opmode =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_BSS_HT_OPMODE]);\n\n\tif (info->attrs[NL80211_ATTR_P2P_CTWINDOW]) {\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\tparams.p2p_ctwindow =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_P2P_CTWINDOW]);\n\t\tif (params.p2p_ctwindow != 0 &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_CTWIN))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_P2P_OPPPS]) {\n\t\tu8 tmp;\n\n\t\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\t\treturn -EINVAL;\n\t\ttmp = nla_get_u8(info->attrs[NL80211_ATTR_P2P_OPPPS]);\n\t\tparams.p2p_opp_ps = tmp;\n\t\tif (params.p2p_opp_ps &&\n\t\t    !(rdev->wiphy.features & NL80211_FEATURE_P2P_GO_OPPPS))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->change_bss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\terr = rdev_change_bss(rdev, dev, &params);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_req_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tchar *data = NULL;\n\tbool is_indoor;\n\tenum nl80211_user_reg_hint_type user_reg_hint_type;\n\tu32 owner_nlportid;\n\n\t \n\tif (unlikely(!rcu_access_pointer(cfg80211_regdomain)))\n\t\treturn -EINPROGRESS;\n\n\tif (info->attrs[NL80211_ATTR_USER_REG_HINT_TYPE])\n\t\tuser_reg_hint_type =\n\t\t  nla_get_u32(info->attrs[NL80211_ATTR_USER_REG_HINT_TYPE]);\n\telse\n\t\tuser_reg_hint_type = NL80211_USER_REG_HINT_USER;\n\n\tswitch (user_reg_hint_type) {\n\tcase NL80211_USER_REG_HINT_USER:\n\tcase NL80211_USER_REG_HINT_CELL_BASE:\n\t\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\t\treturn -EINVAL;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\t\treturn regulatory_hint_user(data, user_reg_hint_type);\n\tcase NL80211_USER_REG_HINT_INDOOR:\n\t\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\towner_nlportid = info->snd_portid;\n\t\t\tis_indoor = !!info->attrs[NL80211_ATTR_REG_INDOOR];\n\t\t} else {\n\t\t\towner_nlportid = 0;\n\t\t\tis_indoor = true;\n\t\t}\n\n\t\treturn regulatory_hint_indoor(is_indoor, owner_nlportid);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int nl80211_reload_regdb(struct sk_buff *skb, struct genl_info *info)\n{\n\treturn reg_reload_regdb();\n}\n\nstatic int nl80211_get_mesh_config(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cur_params;\n\tint err = 0;\n\tvoid *hdr;\n\tstruct nlattr *pinfoattr;\n\tstruct sk_buff *msg;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->get_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\t \n\tif (!wdev->u.mesh.id_len)\n\t\tmemcpy(&cur_params, &default_mesh_config, sizeof(cur_params));\n\telse\n\t\terr = rdev_get_mesh_config(rdev, dev, &cur_params);\n\twdev_unlock(wdev);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_MESH_CONFIG);\n\tif (!hdr)\n\t\tgoto out;\n\tpinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_MESH_CONFIG);\n\tif (!pinfoattr)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_RETRY_TIMEOUT,\n\t\t\tcur_params.dot11MeshRetryTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_CONFIRM_TIMEOUT,\n\t\t\tcur_params.dot11MeshConfirmTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HOLDING_TIMEOUT,\n\t\t\tcur_params.dot11MeshHoldingTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_MAX_PEER_LINKS,\n\t\t\tcur_params.dot11MeshMaxPeerLinks) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_MAX_RETRIES,\n\t\t       cur_params.dot11MeshMaxRetries) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_TTL,\n\t\t       cur_params.dot11MeshTTL) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_ELEMENT_TTL,\n\t\t       cur_params.element_ttl) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_AUTO_OPEN_PLINKS,\n\t\t       cur_params.auto_open_plinks) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,\n\t\t\tcur_params.dot11MeshNbrOffsetMaxNeighbor) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t       cur_params.dot11MeshHWMPmaxPREQretries) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_PATH_REFRESH_TIME,\n\t\t\tcur_params.path_refresh_time) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\tcur_params.min_discovery_timeout) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\tcur_params.dot11MeshHWMPactivePathTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPpreqMinInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPperrMinInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\tcur_params.dot11MeshHWMPnetDiameterTraversalTime) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_HWMP_ROOTMODE,\n\t\t       cur_params.dot11MeshHWMPRootMode) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_RANN_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPRannInterval) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_GATE_ANNOUNCEMENTS,\n\t\t       cur_params.dot11MeshGateAnnouncementProtocol) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_FORWARDING,\n\t\t       cur_params.dot11MeshForwarding) ||\n\t    nla_put_s32(msg, NL80211_MESHCONF_RSSI_THRESHOLD,\n\t\t\tcur_params.rssi_threshold) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HT_OPMODE,\n\t\t\tcur_params.ht_opmode) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,\n\t\t\tcur_params.dot11MeshHWMPactivePathToRootTimeout) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_ROOT_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMProotInterval) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,\n\t\t\tcur_params.dot11MeshHWMPconfirmationInterval) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_POWER_MODE,\n\t\t\tcur_params.power_mode) ||\n\t    nla_put_u16(msg, NL80211_MESHCONF_AWAKE_WINDOW,\n\t\t\tcur_params.dot11MeshAwakeWindowDuration) ||\n\t    nla_put_u32(msg, NL80211_MESHCONF_PLINK_TIMEOUT,\n\t\t\tcur_params.plink_timeout) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_CONNECTED_TO_GATE,\n\t\t       cur_params.dot11MeshConnectedToMeshGate) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_NOLEARN,\n\t\t       cur_params.dot11MeshNolearn) ||\n\t    nla_put_u8(msg, NL80211_MESHCONF_CONNECTED_TO_AS,\n\t\t       cur_params.dot11MeshConnectedToAuthServer))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, pinfoattr);\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n out:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic const struct nla_policy\nnl80211_meshconf_params_policy[NL80211_MESHCONF_ATTR_MAX+1] = {\n\t[NL80211_MESHCONF_RETRY_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_CONFIRM_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_HOLDING_TIMEOUT] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 1, 255),\n\t[NL80211_MESHCONF_MAX_PEER_LINKS] =\n\t\tNLA_POLICY_RANGE(NLA_U16, 0, 255),\n\t[NL80211_MESHCONF_MAX_RETRIES] = NLA_POLICY_MAX(NLA_U8, 16),\n\t[NL80211_MESHCONF_TTL] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_MESHCONF_ELEMENT_TTL] = NLA_POLICY_MIN(NLA_U8, 1),\n\t[NL80211_MESHCONF_AUTO_OPEN_PLINKS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR] =\n\t\tNLA_POLICY_RANGE(NLA_U32, 1, 255),\n\t[NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES] = { .type = NLA_U8 },\n\t[NL80211_MESHCONF_PATH_REFRESH_TIME] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT] = NLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_ROOTMODE] = NLA_POLICY_MAX(NLA_U8, 4),\n\t[NL80211_MESHCONF_HWMP_RANN_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_GATE_ANNOUNCEMENTS] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_FORWARDING] = NLA_POLICY_MAX(NLA_U8, 1),\n\t[NL80211_MESHCONF_RSSI_THRESHOLD] =\n\t\tNLA_POLICY_RANGE(NLA_S32, -255, 0),\n\t[NL80211_MESHCONF_HT_OPMODE] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_HWMP_ROOT_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL] =\n\t\tNLA_POLICY_MIN(NLA_U16, 1),\n\t[NL80211_MESHCONF_POWER_MODE] =\n\t\tNLA_POLICY_RANGE(NLA_U32,\n\t\t\t\t NL80211_MESH_POWER_ACTIVE,\n\t\t\t\t NL80211_MESH_POWER_MAX),\n\t[NL80211_MESHCONF_AWAKE_WINDOW] = { .type = NLA_U16 },\n\t[NL80211_MESHCONF_PLINK_TIMEOUT] = { .type = NLA_U32 },\n\t[NL80211_MESHCONF_CONNECTED_TO_GATE] = NLA_POLICY_RANGE(NLA_U8, 0, 1),\n\t[NL80211_MESHCONF_NOLEARN] = NLA_POLICY_RANGE(NLA_U8, 0, 1),\n\t[NL80211_MESHCONF_CONNECTED_TO_AS] = NLA_POLICY_RANGE(NLA_U8, 0, 1),\n};\n\nstatic const struct nla_policy\n\tnl80211_mesh_setup_params_policy[NL80211_MESH_SETUP_ATTR_MAX+1] = {\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_USERSPACE_AUTH] = { .type = NLA_FLAG },\n\t[NL80211_MESH_SETUP_AUTH_PROTOCOL] = { .type = NLA_U8 },\n\t[NL80211_MESH_SETUP_USERSPACE_MPM] = { .type = NLA_FLAG },\n\t[NL80211_MESH_SETUP_IE] =\n\t\tNLA_POLICY_VALIDATE_FN(NLA_BINARY, validate_ie_attr,\n\t\t\t\t       IEEE80211_MAX_DATA_LEN),\n\t[NL80211_MESH_SETUP_USERSPACE_AMPE] = { .type = NLA_FLAG },\n};\n\nstatic int nl80211_parse_mesh_config(struct genl_info *info,\n\t\t\t\t     struct mesh_config *cfg,\n\t\t\t\t     u32 *mask_out)\n{\n\tstruct nlattr *tb[NL80211_MESHCONF_ATTR_MAX + 1];\n\tu32 mask = 0;\n\tu16 ht_opmode;\n\n#define FILL_IN_MESH_PARAM_IF_SET(tb, cfg, param, mask, attr, fn)\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (tb[attr]) {\t\t\t\t\t\t\t\\\n\t\tcfg->param = fn(tb[attr]);\t\t\t\t\\\n\t\tmask |= BIT((attr) - 1);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n\tif (!info->attrs[NL80211_ATTR_MESH_CONFIG])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested_deprecated(tb, NL80211_MESHCONF_ATTR_MAX, info->attrs[NL80211_ATTR_MESH_CONFIG], nl80211_meshconf_params_policy, info->extack))\n\t\treturn -EINVAL;\n\n\t \n\tBUILD_BUG_ON(NL80211_MESHCONF_ATTR_MAX > 32);\n\n\t \n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshRetryTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_RETRY_TIMEOUT, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConfirmTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_CONFIRM_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHoldingTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_HOLDING_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxPeerLinks, mask,\n\t\t\t\t  NL80211_MESHCONF_MAX_PEER_LINKS,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshMaxRetries, mask,\n\t\t\t\t  NL80211_MESHCONF_MAX_RETRIES, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshTTL, mask,\n\t\t\t\t  NL80211_MESHCONF_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, element_ttl, mask,\n\t\t\t\t  NL80211_MESHCONF_ELEMENT_TTL, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, auto_open_plinks, mask,\n\t\t\t\t  NL80211_MESHCONF_AUTO_OPEN_PLINKS,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshNbrOffsetMaxNeighbor,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_SYNC_OFFSET_MAX_NEIGHBOR,\n\t\t\t\t  nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPmaxPREQretries, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_MAX_PREQ_RETRIES,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, path_refresh_time, mask,\n\t\t\t\t  NL80211_MESHCONF_PATH_REFRESH_TIME,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_PATH_REFRESH_TIME) &&\n\t    (cfg->path_refresh_time < 1 || cfg->path_refresh_time > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, min_discovery_timeout, mask,\n\t\t\t\t  NL80211_MESHCONF_MIN_DISCOVERY_TIMEOUT,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPactivePathTimeout,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_HWMP_ACTIVE_PATH_TIMEOUT) &&\n\t    (cfg->dot11MeshHWMPactivePathTimeout < 1 ||\n\t     cfg->dot11MeshHWMPactivePathTimeout > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPpreqMinInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPperrMinInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\t\t  dot11MeshHWMPnetDiameterTraversalTime, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRootMode, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ROOTMODE, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPRannInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_RANN_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshGateAnnouncementProtocol,\n\t\t\t\t  mask, NL80211_MESHCONF_GATE_ANNOUNCEMENTS,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshForwarding, mask,\n\t\t\t\t  NL80211_MESHCONF_FORWARDING, nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, rssi_threshold, mask,\n\t\t\t\t  NL80211_MESHCONF_RSSI_THRESHOLD,\n\t\t\t\t  nla_get_s32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConnectedToMeshGate, mask,\n\t\t\t\t  NL80211_MESHCONF_CONNECTED_TO_GATE,\n\t\t\t\t  nla_get_u8);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshConnectedToAuthServer, mask,\n\t\t\t\t  NL80211_MESHCONF_CONNECTED_TO_AS,\n\t\t\t\t  nla_get_u8);\n\t \n\tif (tb[NL80211_MESHCONF_HT_OPMODE]) {\n\t\tht_opmode = nla_get_u16(tb[NL80211_MESHCONF_HT_OPMODE]);\n\n\t\tif (ht_opmode & ~(IEEE80211_HT_OP_MODE_PROTECTION |\n\t\t\t\t  IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT |\n\t\t\t\t  IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tht_opmode &= ~IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\n\n\t\tcfg->ht_opmode = ht_opmode;\n\t\tmask |= (1 << (NL80211_MESHCONF_HT_OPMODE - 1));\n\t}\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg,\n\t\t\t\t  dot11MeshHWMPactivePathToRootTimeout, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT,\n\t\t\t\t  nla_get_u32);\n\tif (mask & BIT(NL80211_MESHCONF_HWMP_PATH_TO_ROOT_TIMEOUT) &&\n\t    (cfg->dot11MeshHWMPactivePathToRootTimeout < 1 ||\n\t     cfg->dot11MeshHWMPactivePathToRootTimeout > 65535))\n\t\treturn -EINVAL;\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMProotInterval, mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_ROOT_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshHWMPconfirmationInterval,\n\t\t\t\t  mask,\n\t\t\t\t  NL80211_MESHCONF_HWMP_CONFIRMATION_INTERVAL,\n\t\t\t\t  nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, power_mode, mask,\n\t\t\t\t  NL80211_MESHCONF_POWER_MODE, nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshAwakeWindowDuration, mask,\n\t\t\t\t  NL80211_MESHCONF_AWAKE_WINDOW, nla_get_u16);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, plink_timeout, mask,\n\t\t\t\t  NL80211_MESHCONF_PLINK_TIMEOUT, nla_get_u32);\n\tFILL_IN_MESH_PARAM_IF_SET(tb, cfg, dot11MeshNolearn, mask,\n\t\t\t\t  NL80211_MESHCONF_NOLEARN, nla_get_u8);\n\tif (mask_out)\n\t\t*mask_out = mask;\n\n\treturn 0;\n\n#undef FILL_IN_MESH_PARAM_IF_SET\n}\n\nstatic int nl80211_parse_mesh_setup(struct genl_info *info,\n\t\t\t\t     struct mesh_setup *setup)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *tb[NL80211_MESH_SETUP_ATTR_MAX + 1];\n\n\tif (!info->attrs[NL80211_ATTR_MESH_SETUP])\n\t\treturn -EINVAL;\n\tif (nla_parse_nested_deprecated(tb, NL80211_MESH_SETUP_ATTR_MAX, info->attrs[NL80211_ATTR_MESH_SETUP], nl80211_mesh_setup_params_policy, info->extack))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC])\n\t\tsetup->sync_method =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_SYNC])) ?\n\t\t IEEE80211_SYNC_METHOD_VENDOR :\n\t\t IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])\n\t\tsetup->path_sel_proto =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL])) ?\n\t\t IEEE80211_PATH_PROTOCOL_VENDOR :\n\t\t IEEE80211_PATH_PROTOCOL_HWMP;\n\n\tif (tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])\n\t\tsetup->path_metric =\n\t\t(nla_get_u8(tb[NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC])) ?\n\t\t IEEE80211_PATH_METRIC_VENDOR :\n\t\t IEEE80211_PATH_METRIC_AIRTIME;\n\n\tif (tb[NL80211_MESH_SETUP_IE]) {\n\t\tstruct nlattr *ieattr =\n\t\t\ttb[NL80211_MESH_SETUP_IE];\n\t\tsetup->ie = nla_data(ieattr);\n\t\tsetup->ie_len = nla_len(ieattr);\n\t}\n\tif (tb[NL80211_MESH_SETUP_USERSPACE_MPM] &&\n\t    !(rdev->wiphy.features & NL80211_FEATURE_USERSPACE_MPM))\n\t\treturn -EINVAL;\n\tsetup->user_mpm = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_MPM]);\n\tsetup->is_authenticated = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AUTH]);\n\tsetup->is_secure = nla_get_flag(tb[NL80211_MESH_SETUP_USERSPACE_AMPE]);\n\tif (setup->is_secure)\n\t\tsetup->user_mpm = true;\n\n\tif (tb[NL80211_MESH_SETUP_AUTH_PROTOCOL]) {\n\t\tif (!setup->user_mpm)\n\t\t\treturn -EINVAL;\n\t\tsetup->auth_id =\n\t\t\tnla_get_u8(tb[NL80211_MESH_SETUP_AUTH_PROTOCOL]);\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_update_mesh_config(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct mesh_config cfg = {};\n\tu32 mask;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->update_mesh_config)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nl80211_parse_mesh_config(info, &cfg, &mask);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!wdev->u.mesh.id_len)\n\t\terr = -ENOLINK;\n\n\tif (!err)\n\t\terr = rdev_update_mesh_config(rdev, dev, mask, &cfg);\n\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_put_regdom(const struct ieee80211_regdomain *regdom,\n\t\t\t      struct sk_buff *msg)\n{\n\tstruct nlattr *nl_reg_rules;\n\tunsigned int i;\n\n\tif (nla_put_string(msg, NL80211_ATTR_REG_ALPHA2, regdom->alpha2) ||\n\t    (regdom->dfs_region &&\n\t     nla_put_u8(msg, NL80211_ATTR_DFS_REGION, regdom->dfs_region)))\n\t\tgoto nla_put_failure;\n\n\tnl_reg_rules = nla_nest_start_noflag(msg, NL80211_ATTR_REG_RULES);\n\tif (!nl_reg_rules)\n\t\tgoto nla_put_failure;\n\n\tfor (i = 0; i < regdom->n_reg_rules; i++) {\n\t\tstruct nlattr *nl_reg_rule;\n\t\tconst struct ieee80211_reg_rule *reg_rule;\n\t\tconst struct ieee80211_freq_range *freq_range;\n\t\tconst struct ieee80211_power_rule *power_rule;\n\t\tunsigned int max_bandwidth_khz;\n\n\t\treg_rule = &regdom->reg_rules[i];\n\t\tfreq_range = &reg_rule->freq_range;\n\t\tpower_rule = &reg_rule->power_rule;\n\n\t\tnl_reg_rule = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_reg_rule)\n\t\t\tgoto nla_put_failure;\n\n\t\tmax_bandwidth_khz = freq_range->max_bandwidth_khz;\n\t\tif (!max_bandwidth_khz)\n\t\t\tmax_bandwidth_khz = reg_get_max_bandwidth(regdom,\n\t\t\t\t\t\t\t\t  reg_rule);\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_REG_RULE_FLAGS,\n\t\t\t\treg_rule->flags) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_START,\n\t\t\t\tfreq_range->start_freq_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_END,\n\t\t\t\tfreq_range->end_freq_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_FREQ_RANGE_MAX_BW,\n\t\t\t\tmax_bandwidth_khz) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN,\n\t\t\t\tpower_rule->max_antenna_gain) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_POWER_RULE_MAX_EIRP,\n\t\t\t\tpower_rule->max_eirp) ||\n\t\t    nla_put_u32(msg, NL80211_ATTR_DFS_CAC_TIME,\n\t\t\t\treg_rule->dfs_cac_ms))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_reg_rule);\n\t}\n\n\tnla_nest_end(msg, nl_reg_rules);\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_get_reg_do(struct sk_buff *skb, struct genl_info *info)\n{\n\tconst struct ieee80211_regdomain *regdom = NULL;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wiphy *wiphy = NULL;\n\tstruct sk_buff *msg;\n\tint err = -EMSGSIZE;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOBUFS;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_REG);\n\tif (!hdr)\n\t\tgoto put_failure;\n\n\trtnl_lock();\n\n\tif (info->attrs[NL80211_ATTR_WIPHY]) {\n\t\tbool self_managed;\n\n\t\trdev = cfg80211_get_dev_from_info(genl_info_net(info), info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\terr = PTR_ERR(rdev);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\twiphy = &rdev->wiphy;\n\t\tself_managed = wiphy->regulatory_flags &\n\t\t\t       REGULATORY_WIPHY_SELF_MANAGED;\n\n\t\trcu_read_lock();\n\n\t\tregdom = get_wiphy_regdom(wiphy);\n\n\t\t \n\t\tif (WARN_ON(!regdom && self_managed)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto nla_put_failure_rcu;\n\t\t}\n\n\t\tif (regdom &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\t\tgoto nla_put_failure_rcu;\n\t} else {\n\t\trcu_read_lock();\n\t}\n\n\tif (!wiphy && reg_last_request_cell_base() &&\n\t    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,\n\t\t\tNL80211_USER_REG_HINT_CELL_BASE))\n\t\tgoto nla_put_failure_rcu;\n\n\tif (!regdom)\n\t\tregdom = rcu_dereference(cfg80211_regdomain);\n\n\tif (nl80211_put_regdom(regdom, msg))\n\t\tgoto nla_put_failure_rcu;\n\n\trcu_read_unlock();\n\n\tgenlmsg_end(msg, hdr);\n\trtnl_unlock();\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure_rcu:\n\trcu_read_unlock();\nnla_put_failure:\n\trtnl_unlock();\nput_failure:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_send_regdom(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t       u32 seq, int flags, struct wiphy *wiphy,\n\t\t\t       const struct ieee80211_regdomain *regdom)\n{\n\tvoid *hdr = nl80211hdr_put(msg, NETLINK_CB(cb->skb).portid, seq, flags,\n\t\t\t\t   NL80211_CMD_GET_REG);\n\n\tif (!hdr)\n\t\treturn -1;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nl80211_put_regdom(regdom, msg))\n\t\tgoto nla_put_failure;\n\n\tif (!wiphy && reg_last_request_cell_base() &&\n\t    nla_put_u32(msg, NL80211_ATTR_USER_REG_HINT_TYPE,\n\t\t\tNL80211_USER_REG_HINT_CELL_BASE))\n\t\tgoto nla_put_failure;\n\n\tif (wiphy &&\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\tgoto nla_put_failure;\n\n\tif (wiphy && wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_get_reg_dump(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tconst struct ieee80211_regdomain *regdom = NULL;\n\tstruct cfg80211_registered_device *rdev;\n\tint err, reg_idx, start = cb->args[2];\n\n\trcu_read_lock();\n\n\tif (cfg80211_regdomain && start == 0) {\n\t\terr = nl80211_send_regdom(skb, cb, cb->nlh->nlmsg_seq,\n\t\t\t\t\t  NLM_F_MULTI, NULL,\n\t\t\t\t\t  rcu_dereference(cfg80211_regdomain));\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t}\n\n\t \n\treg_idx = 1;\n\tlist_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list) {\n\t\tregdom = get_wiphy_regdom(&rdev->wiphy);\n\t\tif (!regdom)\n\t\t\tcontinue;\n\n\t\tif (++reg_idx <= start)\n\t\t\tcontinue;\n\n\t\terr = nl80211_send_regdom(skb, cb, cb->nlh->nlmsg_seq,\n\t\t\t\t\t  NLM_F_MULTI, &rdev->wiphy, regdom);\n\t\tif (err < 0) {\n\t\t\treg_idx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcb->args[2] = reg_idx;\n\terr = skb->len;\nout_err:\n\trcu_read_unlock();\n\treturn err;\n}\n\n#ifdef CONFIG_CFG80211_CRDA_SUPPORT\nstatic const struct nla_policy reg_rule_policy[NL80211_REG_RULE_ATTR_MAX + 1] = {\n\t[NL80211_ATTR_REG_RULE_FLAGS]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_START]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_END]\t\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_FREQ_RANGE_MAX_BW]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_POWER_RULE_MAX_EIRP]\t= { .type = NLA_U32 },\n\t[NL80211_ATTR_DFS_CAC_TIME]\t\t= { .type = NLA_U32 },\n};\n\nstatic int parse_reg_rule(struct nlattr *tb[],\n\tstruct ieee80211_reg_rule *reg_rule)\n{\n\tstruct ieee80211_freq_range *freq_range = &reg_rule->freq_range;\n\tstruct ieee80211_power_rule *power_rule = &reg_rule->power_rule;\n\n\tif (!tb[NL80211_ATTR_REG_RULE_FLAGS])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_START])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_END])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_FREQ_RANGE_MAX_BW])\n\t\treturn -EINVAL;\n\tif (!tb[NL80211_ATTR_POWER_RULE_MAX_EIRP])\n\t\treturn -EINVAL;\n\n\treg_rule->flags = nla_get_u32(tb[NL80211_ATTR_REG_RULE_FLAGS]);\n\n\tfreq_range->start_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_START]);\n\tfreq_range->end_freq_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_END]);\n\tfreq_range->max_bandwidth_khz =\n\t\tnla_get_u32(tb[NL80211_ATTR_FREQ_RANGE_MAX_BW]);\n\n\tpower_rule->max_eirp =\n\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_EIRP]);\n\n\tif (tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN])\n\t\tpower_rule->max_antenna_gain =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN]);\n\n\tif (tb[NL80211_ATTR_DFS_CAC_TIME])\n\t\treg_rule->dfs_cac_ms =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_DFS_CAC_TIME]);\n\n\treturn 0;\n}\n\nstatic int nl80211_set_reg(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_REG_RULE_ATTR_MAX + 1];\n\tstruct nlattr *nl_reg_rule;\n\tchar *alpha2;\n\tint rem_reg_rules, r;\n\tu32 num_rules = 0, rule_idx = 0;\n\tenum nl80211_dfs_regions dfs_region = NL80211_DFS_UNSET;\n\tstruct ieee80211_regdomain *rd;\n\n\tif (!info->attrs[NL80211_ATTR_REG_ALPHA2])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REG_RULES])\n\t\treturn -EINVAL;\n\n\talpha2 = nla_data(info->attrs[NL80211_ATTR_REG_ALPHA2]);\n\n\tif (info->attrs[NL80211_ATTR_DFS_REGION])\n\t\tdfs_region = nla_get_u8(info->attrs[NL80211_ATTR_DFS_REGION]);\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\t    rem_reg_rules) {\n\t\tnum_rules++;\n\t\tif (num_rules > NL80211_MAX_SUPP_REG_RULES)\n\t\t\treturn -EINVAL;\n\t}\n\n\trtnl_lock();\n\tif (!reg_is_valid_request(alpha2)) {\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trd = kzalloc(struct_size(rd, reg_rules, num_rules), GFP_KERNEL);\n\tif (!rd) {\n\t\tr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trd->n_reg_rules = num_rules;\n\trd->alpha2[0] = alpha2[0];\n\trd->alpha2[1] = alpha2[1];\n\n\t \n\tif (reg_supported_dfs_region(dfs_region))\n\t\trd->dfs_region = dfs_region;\n\n\tnla_for_each_nested(nl_reg_rule, info->attrs[NL80211_ATTR_REG_RULES],\n\t\t\t    rem_reg_rules) {\n\t\tr = nla_parse_nested_deprecated(tb, NL80211_REG_RULE_ATTR_MAX,\n\t\t\t\t\t\tnl_reg_rule, reg_rule_policy,\n\t\t\t\t\t\tinfo->extack);\n\t\tif (r)\n\t\t\tgoto bad_reg;\n\t\tr = parse_reg_rule(tb, &rd->reg_rules[rule_idx]);\n\t\tif (r)\n\t\t\tgoto bad_reg;\n\n\t\trule_idx++;\n\n\t\tif (rule_idx > NL80211_MAX_SUPP_REG_RULES) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto bad_reg;\n\t\t}\n\t}\n\n\tr = set_regdom(rd, REGD_SOURCE_CRDA);\n\t \n\trd = NULL;\n bad_reg:\n\tkfree(rd);\n out:\n\trtnl_unlock();\n\treturn r;\n}\n#endif  \n\nstatic int validate_scan_freqs(struct nlattr *freqs)\n{\n\tstruct nlattr *attr1, *attr2;\n\tint n_channels = 0, tmp1, tmp2;\n\n\tnla_for_each_nested(attr1, freqs, tmp1)\n\t\tif (nla_len(attr1) != sizeof(u32))\n\t\t\treturn 0;\n\n\tnla_for_each_nested(attr1, freqs, tmp1) {\n\t\tn_channels++;\n\t\t \n\t\tnla_for_each_nested(attr2, freqs, tmp2)\n\t\t\tif (attr1 != attr2 &&\n\t\t\t    nla_get_u32(attr1) == nla_get_u32(attr2))\n\t\t\t\treturn 0;\n\t}\n\n\treturn n_channels;\n}\n\nstatic bool is_band_valid(struct wiphy *wiphy, enum nl80211_band b)\n{\n\treturn b < NUM_NL80211_BANDS && wiphy->bands[b];\n}\n\nstatic int parse_bss_select(struct nlattr *nla, struct wiphy *wiphy,\n\t\t\t    struct cfg80211_bss_selection *bss_select)\n{\n\tstruct nlattr *attr[NL80211_BSS_SELECT_ATTR_MAX + 1];\n\tstruct nlattr *nest;\n\tint err;\n\tbool found = false;\n\tint i;\n\n\t \n\tnest = nla_data(nla);\n\tif (!nla_ok(nest, nla_len(nest)))\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attr, NL80211_BSS_SELECT_ATTR_MAX,\n\t\t\t\t\t  nest, nl80211_bss_select_policy,\n\t\t\t\t\t  NULL);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (i = 0; i <= NL80211_BSS_SELECT_ATTR_MAX; i++) {\n\t\tif (attr[i]) {\n\t\t\tif (found)\n\t\t\t\treturn -EINVAL;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tbss_select->behaviour = __NL80211_BSS_SELECT_ATTR_INVALID;\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_RSSI])\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_RSSI;\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_BAND_PREF]) {\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_BAND_PREF;\n\t\tbss_select->param.band_pref =\n\t\t\tnla_get_u32(attr[NL80211_BSS_SELECT_ATTR_BAND_PREF]);\n\t\tif (!is_band_valid(wiphy, bss_select->param.band_pref))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST]) {\n\t\tstruct nl80211_bss_select_rssi_adjust *adj_param;\n\n\t\tadj_param = nla_data(attr[NL80211_BSS_SELECT_ATTR_RSSI_ADJUST]);\n\t\tbss_select->behaviour = NL80211_BSS_SELECT_ATTR_RSSI_ADJUST;\n\t\tbss_select->param.adjust.band = adj_param->band;\n\t\tbss_select->param.adjust.delta = adj_param->delta;\n\t\tif (!is_band_valid(wiphy, bss_select->param.adjust.band))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (bss_select->behaviour == __NL80211_BSS_SELECT_ATTR_INVALID)\n\t\treturn -EINVAL;\n\n\tif (!(wiphy->bss_select_support & BIT(bss_select->behaviour)))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint nl80211_parse_random_mac(struct nlattr **attrs,\n\t\t\t     u8 *mac_addr, u8 *mac_addr_mask)\n{\n\tint i;\n\n\tif (!attrs[NL80211_ATTR_MAC] && !attrs[NL80211_ATTR_MAC_MASK]) {\n\t\teth_zero_addr(mac_addr);\n\t\teth_zero_addr(mac_addr_mask);\n\t\tmac_addr[0] = 0x2;\n\t\tmac_addr_mask[0] = 0x3;\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (!attrs[NL80211_ATTR_MAC] || !attrs[NL80211_ATTR_MAC_MASK])\n\t\treturn -EINVAL;\n\n\tmemcpy(mac_addr, nla_data(attrs[NL80211_ATTR_MAC]), ETH_ALEN);\n\tmemcpy(mac_addr_mask, nla_data(attrs[NL80211_ATTR_MAC_MASK]), ETH_ALEN);\n\n\t \n\tif (!is_multicast_ether_addr(mac_addr_mask) ||\n\t    is_multicast_ether_addr(mac_addr))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac_addr[i] &= mac_addr_mask[i];\n\n\treturn 0;\n}\n\nstatic bool cfg80211_off_channel_oper_allowed(struct wireless_dev *wdev,\n\t\t\t\t\t      struct ieee80211_channel *chan)\n{\n\tunsigned int link_id;\n\tbool all_ok = true;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!cfg80211_beaconing_iface_active(wdev))\n\t\treturn true;\n\n\t \n\n\t \n\tfor_each_valid_link(wdev, link_id) {\n\t\tstruct cfg80211_chan_def *chandef;\n\n\t\tchandef = wdev_chandef(wdev, link_id);\n\t\tif (!chandef || !chandef->chan)\n\t\t\tcontinue;\n\n\t\t \n\n\t\tif (chandef->chan->flags & IEEE80211_CHAN_RADAR)\n\t\t\tall_ok = false;\n\t}\n\n\tif (all_ok)\n\t\treturn true;\n\n\treturn regulatory_pre_cac_allowed(wdev->wiphy);\n}\n\nstatic bool nl80211_check_scan_feat(struct wiphy *wiphy, u32 flags, u32 flag,\n\t\t\t\t    enum nl80211_ext_feature_index feat)\n{\n\tif (!(flags & flag))\n\t\treturn true;\n\tif (wiphy_ext_feature_isset(wiphy, feat))\n\t\treturn true;\n\treturn false;\n}\n\nstatic int\nnl80211_check_scan_flags(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t void *request, struct nlattr **attrs,\n\t\t\t bool is_sched_scan)\n{\n\tu8 *mac_addr, *mac_addr_mask;\n\tu32 *flags;\n\tenum nl80211_feature_flags randomness_flag;\n\n\tif (!attrs[NL80211_ATTR_SCAN_FLAGS])\n\t\treturn 0;\n\n\tif (is_sched_scan) {\n\t\tstruct cfg80211_sched_scan_request *req = request;\n\n\t\trandomness_flag = wdev ?\n\t\t\t\t  NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR :\n\t\t\t\t  NL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n\t\tflags = &req->flags;\n\t\tmac_addr = req->mac_addr;\n\t\tmac_addr_mask = req->mac_addr_mask;\n\t} else {\n\t\tstruct cfg80211_scan_request *req = request;\n\n\t\trandomness_flag = NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\t\tflags = &req->flags;\n\t\tmac_addr = req->mac_addr;\n\t\tmac_addr_mask = req->mac_addr_mask;\n\t}\n\n\t*flags = nla_get_u32(attrs[NL80211_ATTR_SCAN_FLAGS]);\n\n\tif (((*flags & NL80211_SCAN_FLAG_LOW_PRIORITY) &&\n\t     !(wiphy->features & NL80211_FEATURE_LOW_PRIORITY_SCAN)) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_LOW_SPAN,\n\t\t\t\t     NL80211_EXT_FEATURE_LOW_SPAN_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_LOW_POWER,\n\t\t\t\t     NL80211_EXT_FEATURE_LOW_POWER_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_HIGH_ACCURACY,\n\t\t\t\t     NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME,\n\t\t\t\t     NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP,\n\t\t\t\t     NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION,\n\t\t\t\t     NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE,\n\t\t\t\t     NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_RANDOM_SN,\n\t\t\t\t     NL80211_EXT_FEATURE_SCAN_RANDOM_SN) ||\n\t    !nl80211_check_scan_feat(wiphy, *flags,\n\t\t\t\t     NL80211_SCAN_FLAG_MIN_PREQ_CONTENT,\n\t\t\t\t     NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (*flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\tint err;\n\n\t\tif (!(wiphy->features & randomness_flag) ||\n\t\t    (wdev && wdev->connected))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = nl80211_parse_random_mac(attrs, mac_addr, mac_addr_mask);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_scan_request *request;\n\tstruct nlattr *scan_freqs = NULL;\n\tbool scan_freqs_khz = false;\n\tstruct nlattr *attr;\n\tstruct wiphy *wiphy;\n\tint err, tmp, n_ssids = 0, n_channels, i;\n\tsize_t ie_len, size;\n\n\twiphy = &rdev->wiphy;\n\n\tif (wdev->iftype == NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_req || rdev->scan_msg)\n\t\treturn -EBUSY;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_FREQ_KHZ]) {\n\t\tif (!wiphy_ext_feature_isset(wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SCAN_FREQ_KHZ))\n\t\t\treturn -EOPNOTSUPP;\n\t\tscan_freqs = info->attrs[NL80211_ATTR_SCAN_FREQ_KHZ];\n\t\tscan_freqs_khz = true;\n\t} else if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES])\n\t\tscan_freqs = info->attrs[NL80211_ATTR_SCAN_FREQUENCIES];\n\n\tif (scan_freqs) {\n\t\tn_channels = validate_scan_freqs(scan_freqs);\n\t\tif (!n_channels)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tn_channels = ieee80211_get_num_supported_channels(wiphy);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_scan_ssids)\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_scan_ie_len)\n\t\treturn -EINVAL;\n\n\tsize = struct_size(request, channels, n_channels);\n\tsize = size_add(size, array_size(sizeof(*request->ssids), n_ssids));\n\tsize = size_add(size, ie_len);\n\trequest = kzalloc(size, GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (n_ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\ti = 0;\n\tif (scan_freqs) {\n\t\t \n\t\tnla_for_each_nested(attr, scan_freqs, tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\t\t\tint freq = nla_get_u32(attr);\n\n\t\t\tif (!scan_freqs_khz)\n\t\t\t\tfreq = MHZ_TO_KHZ(freq);\n\n\t\t\tchan = ieee80211_get_channel_khz(wiphy, freq);\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\tenum nl80211_band band;\n\n\t\t \n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tint j;\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\twdev_lock(wdev);\n\tfor (i = 0; i < request->n_channels; i++) {\n\t\tstruct ieee80211_channel *chan = request->channels[i];\n\n\t\t \n\t\tif (cfg80211_off_channel_oper_allowed(wdev, chan))\n\t\t\tcontinue;\n\n\t\tif (!cfg80211_wdev_on_sub_chan(wdev, chan, true)) {\n\t\t\twdev_unlock(wdev);\n\t\t\terr = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\twdev_unlock(wdev);\n\n\ti = 0;\n\tif (n_ssids) {\n\t\tnla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) {\n\t\t\tif (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\trequest->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tif (wiphy->bands[i])\n\t\t\trequest->rates[i] =\n\t\t\t\t(1 << wiphy->bands[i]->n_bitrates) - 1;\n\n\tif (info->attrs[NL80211_ATTR_SCAN_SUPP_RATES]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    info->attrs[NL80211_ATTR_SCAN_SUPP_RATES],\n\t\t\t\t    tmp) {\n\t\t\tenum nl80211_band band = nla_type(attr);\n\n\t\t\tif (band < 0 || band >= NUM_NL80211_BANDS) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\n\t\t\terr = ieee80211_get_ratemask(wiphy->bands[band],\n\t\t\t\t\t\t     nla_data(attr),\n\t\t\t\t\t\t     nla_len(attr),\n\t\t\t\t\t\t     &request->rates[band]);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MEASUREMENT_DURATION]) {\n\t\trequest->duration =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_MEASUREMENT_DURATION]);\n\t\trequest->duration_mandatory =\n\t\t\tnla_get_flag(info->attrs[NL80211_ATTR_MEASUREMENT_DURATION_MANDATORY]);\n\t}\n\n\terr = nl80211_check_scan_flags(wiphy, wdev, request, info->attrs,\n\t\t\t\t       false);\n\tif (err)\n\t\tgoto out_free;\n\n\trequest->no_cck =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);\n\n\t \n\tif (info->attrs[NL80211_ATTR_BSSID])\n\t\tmemcpy(request->bssid,\n\t\t       nla_data(info->attrs[NL80211_ATTR_BSSID]), ETH_ALEN);\n\telse if (!(request->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) &&\n\t\t info->attrs[NL80211_ATTR_MAC])\n\t\tmemcpy(request->bssid, nla_data(info->attrs[NL80211_ATTR_MAC]),\n\t\t       ETH_ALEN);\n\telse\n\t\teth_broadcast_addr(request->bssid);\n\n\trequest->wdev = wdev;\n\trequest->wiphy = &rdev->wiphy;\n\trequest->scan_start = jiffies;\n\n\trdev->scan_req = request;\n\terr = cfg80211_scan(rdev);\n\n\tif (err)\n\t\tgoto out_free;\n\n\tnl80211_send_scan_start(rdev, wdev);\n\tdev_hold(wdev->netdev);\n\n\treturn 0;\n\n out_free:\n\trdev->scan_req = NULL;\n\tkfree(request);\n\n\treturn err;\n}\n\nstatic int nl80211_abort_scan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->abort_scan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->scan_msg)\n\t\treturn 0;\n\n\tif (!rdev->scan_req)\n\t\treturn -ENOENT;\n\n\trdev_abort_scan(rdev, wdev);\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_sched_scan_plans(struct wiphy *wiphy, int n_plans,\n\t\t\t       struct cfg80211_sched_scan_request *request,\n\t\t\t       struct nlattr **attrs)\n{\n\tint tmp, err, i = 0;\n\tstruct nlattr *attr;\n\n\tif (!attrs[NL80211_ATTR_SCHED_SCAN_PLANS]) {\n\t\tu32 interval;\n\n\t\t \n\t\tinterval = nla_get_u32(attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL]);\n\t\tif (!interval)\n\t\t\treturn -EINVAL;\n\n\t\trequest->scan_plans[0].interval =\n\t\t\tDIV_ROUND_UP(interval, MSEC_PER_SEC);\n\t\tif (!request->scan_plans[0].interval)\n\t\t\treturn -EINVAL;\n\n\t\tif (request->scan_plans[0].interval >\n\t\t    wiphy->max_sched_scan_plan_interval)\n\t\t\trequest->scan_plans[0].interval =\n\t\t\t\twiphy->max_sched_scan_plan_interval;\n\n\t\treturn 0;\n\t}\n\n\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCHED_SCAN_PLANS], tmp) {\n\t\tstruct nlattr *plan[NL80211_SCHED_SCAN_PLAN_MAX + 1];\n\n\t\tif (WARN_ON(i >= n_plans))\n\t\t\treturn -EINVAL;\n\n\t\terr = nla_parse_nested_deprecated(plan,\n\t\t\t\t\t\t  NL80211_SCHED_SCAN_PLAN_MAX,\n\t\t\t\t\t\t  attr, nl80211_plan_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!plan[NL80211_SCHED_SCAN_PLAN_INTERVAL])\n\t\t\treturn -EINVAL;\n\n\t\trequest->scan_plans[i].interval =\n\t\t\tnla_get_u32(plan[NL80211_SCHED_SCAN_PLAN_INTERVAL]);\n\t\tif (!request->scan_plans[i].interval ||\n\t\t    request->scan_plans[i].interval >\n\t\t    wiphy->max_sched_scan_plan_interval)\n\t\t\treturn -EINVAL;\n\n\t\tif (plan[NL80211_SCHED_SCAN_PLAN_ITERATIONS]) {\n\t\t\trequest->scan_plans[i].iterations =\n\t\t\t\tnla_get_u32(plan[NL80211_SCHED_SCAN_PLAN_ITERATIONS]);\n\t\t\tif (!request->scan_plans[i].iterations ||\n\t\t\t    (request->scan_plans[i].iterations >\n\t\t\t     wiphy->max_sched_scan_plan_iterations))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (i < n_plans - 1) {\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ti++;\n\t}\n\n\t \n\tif (request->scan_plans[n_plans - 1].iterations)\n\t\treturn  -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nnl80211_parse_sched_scan_per_band_rssi(struct wiphy *wiphy,\n\t\t\t\t       struct cfg80211_match_set *match_sets,\n\t\t\t\t       struct nlattr *tb_band_rssi,\n\t\t\t\t       s32 rssi_thold)\n{\n\tstruct nlattr *attr;\n\tint i, tmp, ret = 0;\n\n\tif (!wiphy_ext_feature_isset(wiphy,\n\t\t    NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD)) {\n\t\tif (tb_band_rssi)\n\t\t\tret = -EOPNOTSUPP;\n\t\telse\n\t\t\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\t\t\tmatch_sets->per_band_rssi_thold[i] =\n\t\t\t\t\tNL80211_SCAN_RSSI_THOLD_OFF;\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tmatch_sets->per_band_rssi_thold[i] = rssi_thold;\n\n\tnla_for_each_nested(attr, tb_band_rssi, tmp) {\n\t\tenum nl80211_band band = nla_type(attr);\n\n\t\tif (band < 0 || band >= NUM_NL80211_BANDS)\n\t\t\treturn -EINVAL;\n\n\t\tmatch_sets->per_band_rssi_thold[band] =\tnla_get_s32(attr);\n\t}\n\n\treturn 0;\n}\n\nstatic struct cfg80211_sched_scan_request *\nnl80211_parse_sched_scan(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t struct nlattr **attrs, int max_match_sets)\n{\n\tstruct cfg80211_sched_scan_request *request;\n\tstruct nlattr *attr;\n\tint err, tmp, n_ssids = 0, n_match_sets = 0, n_channels, i, n_plans = 0;\n\tenum nl80211_band band;\n\tsize_t ie_len, size;\n\tstruct nlattr *tb[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1];\n\ts32 default_match_rssi = NL80211_SCAN_RSSI_THOLD_OFF;\n\n\tif (attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\tn_channels = validate_scan_freqs(\n\t\t\t\tattrs[NL80211_ATTR_SCAN_FREQUENCIES]);\n\t\tif (!n_channels)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t} else {\n\t\tn_channels = ieee80211_get_num_supported_channels(wiphy);\n\t}\n\n\tif (attrs[NL80211_ATTR_SCAN_SSIDS])\n\t\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp)\n\t\t\tn_ssids++;\n\n\tif (n_ssids > wiphy->max_sched_scan_ssids)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_MATCH],\n\t\t\t\t    tmp) {\n\t\t\tstruct nlattr *rssi;\n\n\t\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t  NL80211_SCHED_SCAN_MATCH_ATTR_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  nl80211_match_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err)\n\t\t\t\treturn ERR_PTR(err);\n\n\t\t\t \n\t\t\tif (tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] &&\n\t\t\t    tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID])\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\t\t \n\t\t\tif (tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID] ||\n\t\t\t    tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID]) {\n\t\t\t\tn_match_sets++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];\n\t\t\tif (rssi)\n\t\t\t\tdefault_match_rssi = nla_get_s32(rssi);\n\t\t}\n\t}\n\n\t \n\tif (!n_match_sets && default_match_rssi != NL80211_SCAN_RSSI_THOLD_OFF)\n\t\tn_match_sets = 1;\n\n\tif (n_match_sets > max_match_sets)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_IE])\n\t\tie_len = nla_len(attrs[NL80211_ATTR_IE]);\n\telse\n\t\tie_len = 0;\n\n\tif (ie_len > wiphy->max_sched_scan_ie_len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_PLANS]) {\n\t\t \n\t\tif (attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_PLANS], tmp)\n\t\t\tn_plans++;\n\t} else {\n\t\t \n\t\tif (!attrs[NL80211_ATTR_SCHED_SCAN_INTERVAL])\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tn_plans = 1;\n\t}\n\n\tif (!n_plans || n_plans > wiphy->max_sched_scan_plans)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!wiphy_ext_feature_isset(\n\t\t    wiphy, NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI) &&\n\t    (attrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI] ||\n\t     attrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsize = struct_size(request, channels, n_channels);\n\tsize = size_add(size, array_size(sizeof(*request->ssids), n_ssids));\n\tsize = size_add(size, array_size(sizeof(*request->match_sets),\n\t\t\t\t\t n_match_sets));\n\tsize = size_add(size, array_size(sizeof(*request->scan_plans),\n\t\t\t\t\t n_plans));\n\tsize = size_add(size, ie_len);\n\trequest = kzalloc(size, GFP_KERNEL);\n\tif (!request)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (n_ssids)\n\t\trequest->ssids = (void *)&request->channels[n_channels];\n\trequest->n_ssids = n_ssids;\n\tif (ie_len) {\n\t\tif (n_ssids)\n\t\t\trequest->ie = (void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->ie = (void *)(request->channels + n_channels);\n\t}\n\n\tif (n_match_sets) {\n\t\tif (request->ie)\n\t\t\trequest->match_sets = (void *)(request->ie + ie_len);\n\t\telse if (n_ssids)\n\t\t\trequest->match_sets =\n\t\t\t\t(void *)(request->ssids + n_ssids);\n\t\telse\n\t\t\trequest->match_sets =\n\t\t\t\t(void *)(request->channels + n_channels);\n\t}\n\trequest->n_match_sets = n_match_sets;\n\n\tif (n_match_sets)\n\t\trequest->scan_plans = (void *)(request->match_sets +\n\t\t\t\t\t       n_match_sets);\n\telse if (request->ie)\n\t\trequest->scan_plans = (void *)(request->ie + ie_len);\n\telse if (n_ssids)\n\t\trequest->scan_plans = (void *)(request->ssids + n_ssids);\n\telse\n\t\trequest->scan_plans = (void *)(request->channels + n_channels);\n\n\trequest->n_scan_plans = n_plans;\n\n\ti = 0;\n\tif (attrs[NL80211_ATTR_SCAN_FREQUENCIES]) {\n\t\t \n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCAN_FREQUENCIES],\n\t\t\t\t    tmp) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = ieee80211_get_channel(wiphy, nla_get_u32(attr));\n\n\t\t\tif (!chan) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\trequest->channels[i] = chan;\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tint j;\n\n\t\t\tif (!wiphy->bands[band])\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\t\tchan = &wiphy->bands[band]->channels[j];\n\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\n\t\t\t\trequest->channels[i] = chan;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\trequest->n_channels = i;\n\n\ti = 0;\n\tif (n_ssids) {\n\t\tnla_for_each_nested(attr, attrs[NL80211_ATTR_SCAN_SSIDS],\n\t\t\t\t    tmp) {\n\t\t\tif (nla_len(attr) > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\trequest->ssids[i].ssid_len = nla_len(attr);\n\t\t\tmemcpy(request->ssids[i].ssid, nla_data(attr),\n\t\t\t       nla_len(attr));\n\t\t\ti++;\n\t\t}\n\t}\n\n\ti = 0;\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {\n\t\tnla_for_each_nested(attr,\n\t\t\t\t    attrs[NL80211_ATTR_SCHED_SCAN_MATCH],\n\t\t\t\t    tmp) {\n\t\t\tstruct nlattr *ssid, *bssid, *rssi;\n\n\t\t\terr = nla_parse_nested_deprecated(tb,\n\t\t\t\t\t\t\t  NL80211_SCHED_SCAN_MATCH_ATTR_MAX,\n\t\t\t\t\t\t\t  attr,\n\t\t\t\t\t\t\t  nl80211_match_policy,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\t\t\tssid = tb[NL80211_SCHED_SCAN_MATCH_ATTR_SSID];\n\t\t\tbssid = tb[NL80211_SCHED_SCAN_MATCH_ATTR_BSSID];\n\n\t\t\tif (!ssid && !bssid) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (WARN_ON(i >= n_match_sets)) {\n\t\t\t\t \n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tif (ssid) {\n\t\t\t\tmemcpy(request->match_sets[i].ssid.ssid,\n\t\t\t\t       nla_data(ssid), nla_len(ssid));\n\t\t\t\trequest->match_sets[i].ssid.ssid_len =\n\t\t\t\t\tnla_len(ssid);\n\t\t\t}\n\t\t\tif (bssid)\n\t\t\t\tmemcpy(request->match_sets[i].bssid,\n\t\t\t\t       nla_data(bssid), ETH_ALEN);\n\n\t\t\t \n\t\t\trequest->match_sets[i].rssi_thold = default_match_rssi;\n\t\t\trssi = tb[NL80211_SCHED_SCAN_MATCH_ATTR_RSSI];\n\t\t\tif (rssi)\n\t\t\t\trequest->match_sets[i].rssi_thold =\n\t\t\t\t\tnla_get_s32(rssi);\n\n\t\t\t \n\t\t\terr = nl80211_parse_sched_scan_per_band_rssi(wiphy,\n\t\t\t\t&request->match_sets[i],\n\t\t\t\ttb[NL80211_SCHED_SCAN_MATCH_PER_BAND_RSSI],\n\t\t\t\trequest->match_sets[i].rssi_thold);\n\t\t\tif (err)\n\t\t\t\tgoto out_free;\n\n\t\t\ti++;\n\t\t}\n\n\t\t \n\t\tif (i == 0 && n_match_sets)\n\t\t\trequest->match_sets[0].rssi_thold = default_match_rssi;\n\n\t\trequest->min_rssi_thold = INT_MAX;\n\t\tfor (i = 0; i < n_match_sets; i++)\n\t\t\trequest->min_rssi_thold =\n\t\t\t\tmin(request->match_sets[i].rssi_thold,\n\t\t\t\t    request->min_rssi_thold);\n\t} else {\n\t\trequest->min_rssi_thold = NL80211_SCAN_RSSI_THOLD_OFF;\n\t}\n\n\tif (ie_len) {\n\t\trequest->ie_len = ie_len;\n\t\tmemcpy((void *)request->ie,\n\t\t       nla_data(attrs[NL80211_ATTR_IE]),\n\t\t       request->ie_len);\n\t}\n\n\terr = nl80211_check_scan_flags(wiphy, wdev, request, attrs, true);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_DELAY])\n\t\trequest->delay =\n\t\t\tnla_get_u32(attrs[NL80211_ATTR_SCHED_SCAN_DELAY]);\n\n\tif (attrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI]) {\n\t\trequest->relative_rssi = nla_get_s8(\n\t\t\tattrs[NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI]);\n\t\trequest->relative_rssi_set = true;\n\t}\n\n\tif (request->relative_rssi_set &&\n\t    attrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]) {\n\t\tstruct nl80211_bss_select_rssi_adjust *rssi_adjust;\n\n\t\trssi_adjust = nla_data(\n\t\t\tattrs[NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST]);\n\t\trequest->rssi_adjust.band = rssi_adjust->band;\n\t\trequest->rssi_adjust.delta = rssi_adjust->delta;\n\t\tif (!is_band_valid(wiphy, request->rssi_adjust.band)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\terr = nl80211_parse_sched_scan_plans(wiphy, n_plans, request, attrs);\n\tif (err)\n\t\tgoto out_free;\n\n\trequest->scan_start = jiffies;\n\n\treturn request;\n\nout_free:\n\tkfree(request);\n\treturn ERR_PTR(err);\n}\n\nstatic int nl80211_start_sched_scan(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\tbool want_multi;\n\tint err;\n\n\tif (!rdev->wiphy.max_sched_scan_reqs || !rdev->ops->sched_scan_start)\n\t\treturn -EOPNOTSUPP;\n\n\twant_multi = info->attrs[NL80211_ATTR_SCHED_SCAN_MULTI];\n\terr = cfg80211_sched_scan_req_possible(rdev, want_multi);\n\tif (err)\n\t\treturn err;\n\n\tsched_scan_req = nl80211_parse_sched_scan(&rdev->wiphy, wdev,\n\t\t\t\t\t\t  info->attrs,\n\t\t\t\t\t\t  rdev->wiphy.max_match_sets);\n\n\terr = PTR_ERR_OR_ZERO(sched_scan_req);\n\tif (err)\n\t\tgoto out_err;\n\n\t \n\tif (want_multi && rdev->wiphy.max_sched_scan_reqs > 1)\n\t\tsched_scan_req->reqid = cfg80211_assign_cookie(rdev);\n\n\terr = rdev_sched_scan_start(rdev, dev, sched_scan_req);\n\tif (err)\n\t\tgoto out_free;\n\n\tsched_scan_req->dev = dev;\n\tsched_scan_req->wiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tsched_scan_req->owner_nlportid = info->snd_portid;\n\n\tcfg80211_add_sched_scan_req(rdev, sched_scan_req);\n\n\tnl80211_send_sched_scan(sched_scan_req, NL80211_CMD_START_SCHED_SCAN);\n\treturn 0;\n\nout_free:\n\tkfree(sched_scan_req);\nout_err:\n\treturn err;\n}\n\nstatic int nl80211_stop_sched_scan(struct sk_buff *skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_sched_scan_request *req;\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tu64 cookie;\n\n\tif (!rdev->wiphy.max_sched_scan_reqs || !rdev->ops->sched_scan_stop)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_COOKIE]) {\n\t\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\t\treturn __cfg80211_stop_sched_scan(rdev, cookie, false);\n\t}\n\n\treq = list_first_or_null_rcu(&rdev->sched_scan_req_list,\n\t\t\t\t     struct cfg80211_sched_scan_request,\n\t\t\t\t     list);\n\tif (!req || req->reqid ||\n\t    (req->owner_nlportid &&\n\t     req->owner_nlportid != info->snd_portid))\n\t\treturn -ENOENT;\n\n\treturn cfg80211_stop_sched_scan_req(rdev, req, false);\n}\n\nstatic int nl80211_start_radar_detection(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_chan_def chandef;\n\tenum nl80211_dfs_regions dfs_region;\n\tunsigned int cac_time_ms;\n\tint err = -EINVAL;\n\n\tflush_delayed_work(&rdev->dfs_update_channels_wk);\n\n\twiphy_lock(wiphy);\n\n\tdfs_region = reg_get_dfs_region(wiphy);\n\tif (dfs_region == NL80211_DFS_UNSET)\n\t\tgoto unlock;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = cfg80211_chandef_dfs_required(wiphy, &chandef, wdev->iftype);\n\tif (err < 0)\n\t\tgoto unlock;\n\n\tif (err == 0) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (!cfg80211_chandef_dfs_usable(wiphy, &chandef)) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_RADAR_BACKGROUND])) {\n\t\terr = cfg80211_start_background_radar_detection(rdev, wdev,\n\t\t\t\t\t\t\t\t&chandef);\n\t\tgoto unlock;\n\t}\n\n\tif (netif_carrier_ok(dev)) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (wdev->cac_started) {\n\t\terr = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif (wiphy_ext_feature_isset(wiphy, NL80211_EXT_FEATURE_DFS_OFFLOAD)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\tif (!rdev->ops->start_radar_detection) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\tcac_time_ms = cfg80211_chandef_dfs_cac_time(&rdev->wiphy, &chandef);\n\tif (WARN_ON(!cac_time_ms))\n\t\tcac_time_ms = IEEE80211_DFS_MIN_CAC_TIME_MS;\n\n\terr = rdev_start_radar_detection(rdev, dev, &chandef, cac_time_ms);\n\tif (!err) {\n\t\twdev->links[0].ap.chandef = chandef;\n\t\twdev->cac_started = true;\n\t\twdev->cac_start_time = jiffies;\n\t\twdev->cac_time_ms = cac_time_ms;\n\t}\nunlock:\n\twiphy_unlock(wiphy);\n\n\treturn err;\n}\n\nstatic int nl80211_notify_radar_detection(struct sk_buff *skb,\n\t\t\t\t\t  struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_chan_def chandef;\n\tenum nl80211_dfs_regions dfs_region;\n\tint err;\n\n\tdfs_region = reg_get_dfs_region(wiphy);\n\tif (dfs_region == NL80211_DFS_UNSET) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"DFS Region is not set. Unexpected Radar indication\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err) {\n\t\tGENL_SET_ERR_MSG(info, \"Unable to extract chandef info\");\n\t\treturn err;\n\t}\n\n\terr = cfg80211_chandef_dfs_required(wiphy, &chandef, wdev->iftype);\n\tif (err < 0) {\n\t\tGENL_SET_ERR_MSG(info, \"chandef is invalid\");\n\t\treturn err;\n\t}\n\n\tif (err == 0) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"Unexpected Radar indication for chandef/iftype\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (chandef.chan->dfs_state == NL80211_DFS_UNAVAILABLE)\n\t\treturn 0;\n\n\tcfg80211_set_dfs_state(wiphy, &chandef, NL80211_DFS_UNAVAILABLE);\n\n\tcfg80211_sched_dfs_chan_update(rdev);\n\n\trdev->radar_chandef = chandef;\n\n\t \n\tqueue_work(cfg80211_wq, &rdev->propagate_radar_detect_wk);\n\n\treturn 0;\n}\n\nstatic int nl80211_channel_switch(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tunsigned int link_id = nl80211_link_id(info->attrs);\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_csa_settings params;\n\tstruct nlattr **csa_attrs = NULL;\n\tint err;\n\tbool need_new_beacon = false;\n\tbool need_handle_dfs_flag = true;\n\tint len, i;\n\tu32 cs_count;\n\n\tif (!rdev->ops->channel_switch ||\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tneed_new_beacon = true;\n\t\t \n\t\tneed_handle_dfs_flag = false;\n\n\t\t \n\t\tif (!wdev->links[link_id].ap.beacon_interval)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (!wdev->u.ibss.ssid_len)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!wdev->u.mesh.id_len)\n\t\t\treturn -ENOTCONN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.beacon_csa.ftm_responder = -1;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_CH_SWITCH_COUNT])\n\t\treturn -EINVAL;\n\n\t \n\tif (need_new_beacon && !info->attrs[NL80211_ATTR_CSA_IES])\n\t\treturn -EINVAL;\n\n\t \n\tcs_count = nla_get_u32(info->attrs[NL80211_ATTR_CH_SWITCH_COUNT]);\n\tif (cs_count > 255)\n\t\treturn -EINVAL;\n\n\tparams.count = cs_count;\n\n\tif (!need_new_beacon)\n\t\tgoto skip_beacons;\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params.beacon_after,\n\t\t\t\t   info->extack);\n\tif (err)\n\t\tgoto free;\n\n\tcsa_attrs = kcalloc(NL80211_ATTR_MAX + 1, sizeof(*csa_attrs),\n\t\t\t    GFP_KERNEL);\n\tif (!csa_attrs) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\terr = nla_parse_nested_deprecated(csa_attrs, NL80211_ATTR_MAX,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_CSA_IES],\n\t\t\t\t\t  nl80211_policy, info->extack);\n\tif (err)\n\t\tgoto free;\n\n\terr = nl80211_parse_beacon(rdev, csa_attrs, &params.beacon_csa,\n\t\t\t\t   info->extack);\n\tif (err)\n\t\tgoto free;\n\n\tif (!csa_attrs[NL80211_ATTR_CNTDWN_OFFS_BEACON]) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tlen = nla_len(csa_attrs[NL80211_ATTR_CNTDWN_OFFS_BEACON]);\n\tif (!len || (len % sizeof(u16))) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tparams.n_counter_offsets_beacon = len / sizeof(u16);\n\tif (rdev->wiphy.max_num_csa_counters &&\n\t    (params.n_counter_offsets_beacon >\n\t     rdev->wiphy.max_num_csa_counters)) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tparams.counter_offsets_beacon =\n\t\tnla_data(csa_attrs[NL80211_ATTR_CNTDWN_OFFS_BEACON]);\n\n\t \n\tfor (i = 0; i < params.n_counter_offsets_beacon; i++) {\n\t\tu16 offset = params.counter_offsets_beacon[i];\n\n\t\tif (offset >= params.beacon_csa.tail_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (params.beacon_csa.tail[offset] != params.count) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (csa_attrs[NL80211_ATTR_CNTDWN_OFFS_PRESP]) {\n\t\tlen = nla_len(csa_attrs[NL80211_ATTR_CNTDWN_OFFS_PRESP]);\n\t\tif (!len || (len % sizeof(u16))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tparams.n_counter_offsets_presp = len / sizeof(u16);\n\t\tif (rdev->wiphy.max_num_csa_counters &&\n\t\t    (params.n_counter_offsets_presp >\n\t\t     rdev->wiphy.max_num_csa_counters)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tparams.counter_offsets_presp =\n\t\t\tnla_data(csa_attrs[NL80211_ATTR_CNTDWN_OFFS_PRESP]);\n\n\t\t \n\t\tfor (i = 0; i < params.n_counter_offsets_presp; i++) {\n\t\t\tu16 offset = params.counter_offsets_presp[i];\n\n\t\t\tif (offset >= params.beacon_csa.probe_resp_len) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (params.beacon_csa.probe_resp[offset] !=\n\t\t\t    params.count) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t}\n\t}\n\nskip_beacons:\n\terr = nl80211_parse_chandef(rdev, info, &params.chandef);\n\tif (err)\n\t\tgoto free;\n\n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &params.chandef,\n\t\t\t\t\t   wdev->iftype)) {\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\n\terr = cfg80211_chandef_dfs_required(wdev->wiphy,\n\t\t\t\t\t    &params.chandef,\n\t\t\t\t\t    wdev->iftype);\n\tif (err < 0)\n\t\tgoto free;\n\n\tif (err > 0) {\n\t\tparams.radar_required = true;\n\t\tif (need_handle_dfs_flag &&\n\t\t    !nla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS])) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CH_SWITCH_BLOCK_TX])\n\t\tparams.block_tx = true;\n\n\tif (info->attrs[NL80211_ATTR_PUNCT_BITMAP]) {\n\t\terr = nl80211_parse_punct_bitmap(rdev, info,\n\t\t\t\t\t\t &params.chandef,\n\t\t\t\t\t\t &params.punct_bitmap);\n\t\tif (err)\n\t\t\tgoto free;\n\t}\n\n\twdev_lock(wdev);\n\terr = rdev_channel_switch(rdev, dev, &params);\n\twdev_unlock(wdev);\n\nfree:\n\tkfree(params.beacon_after.mbssid_ies);\n\tkfree(params.beacon_csa.mbssid_ies);\n\tkfree(params.beacon_after.rnr_ies);\n\tkfree(params.beacon_csa.rnr_ies);\n\tkfree(csa_attrs);\n\treturn err;\n}\n\nstatic int nl80211_send_bss(struct sk_buff *msg, struct netlink_callback *cb,\n\t\t\t    u32 seq, int flags,\n\t\t\t    struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev,\n\t\t\t    struct cfg80211_internal_bss *intbss)\n{\n\tstruct cfg80211_bss *res = &intbss->pub;\n\tconst struct cfg80211_bss_ies *ies;\n\tunsigned int link_id;\n\tvoid *hdr;\n\tstruct nlattr *bss;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\thdr = nl80211hdr_put(msg, NETLINK_CB(cb->skb).portid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SCAN_RESULTS);\n\tif (!hdr)\n\t\treturn -1;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put_u32(msg, NL80211_ATTR_GENERATION, rdev->bss_generation))\n\t\tgoto nla_put_failure;\n\tif (wdev->netdev &&\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tbss = nla_nest_start_noflag(msg, NL80211_ATTR_BSS);\n\tif (!bss)\n\t\tgoto nla_put_failure;\n\tif ((!is_zero_ether_addr(res->bssid) &&\n\t     nla_put(msg, NL80211_BSS_BSSID, ETH_ALEN, res->bssid)))\n\t\tgoto nla_put_failure;\n\n\trcu_read_lock();\n\t \n\tif (rcu_access_pointer(res->proberesp_ies) &&\n\t    nla_put_flag(msg, NL80211_BSS_PRESP_DATA))\n\t\tgoto fail_unlock_rcu;\n\n\t \n\ties = rcu_dereference(res->ies);\n\tif (ies) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_BSS_TSF, ies->tsf,\n\t\t\t\t      NL80211_BSS_PAD))\n\t\t\tgoto fail_unlock_rcu;\n\t\tif (ies->len && nla_put(msg, NL80211_BSS_INFORMATION_ELEMENTS,\n\t\t\t\t\ties->len, ies->data))\n\t\t\tgoto fail_unlock_rcu;\n\t}\n\n\t \n\ties = rcu_dereference(res->beacon_ies);\n\tif (ies && ies->from_beacon) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_BSS_BEACON_TSF, ies->tsf,\n\t\t\t\t      NL80211_BSS_PAD))\n\t\t\tgoto fail_unlock_rcu;\n\t\tif (ies->len && nla_put(msg, NL80211_BSS_BEACON_IES,\n\t\t\t\t\ties->len, ies->data))\n\t\t\tgoto fail_unlock_rcu;\n\t}\n\trcu_read_unlock();\n\n\tif (res->beacon_interval &&\n\t    nla_put_u16(msg, NL80211_BSS_BEACON_INTERVAL, res->beacon_interval))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(msg, NL80211_BSS_CAPABILITY, res->capability) ||\n\t    nla_put_u32(msg, NL80211_BSS_FREQUENCY, res->channel->center_freq) ||\n\t    nla_put_u32(msg, NL80211_BSS_FREQUENCY_OFFSET,\n\t\t\tres->channel->freq_offset) ||\n\t    nla_put_u32(msg, NL80211_BSS_CHAN_WIDTH, res->scan_width) ||\n\t    nla_put_u32(msg, NL80211_BSS_SEEN_MS_AGO,\n\t\t\tjiffies_to_msecs(jiffies - intbss->ts)))\n\t\tgoto nla_put_failure;\n\n\tif (intbss->parent_tsf &&\n\t    (nla_put_u64_64bit(msg, NL80211_BSS_PARENT_TSF,\n\t\t\t       intbss->parent_tsf, NL80211_BSS_PAD) ||\n\t     nla_put(msg, NL80211_BSS_PARENT_BSSID, ETH_ALEN,\n\t\t     intbss->parent_bssid)))\n\t\tgoto nla_put_failure;\n\n\tif (intbss->ts_boottime &&\n\t    nla_put_u64_64bit(msg, NL80211_BSS_LAST_SEEN_BOOTTIME,\n\t\t\t      intbss->ts_boottime, NL80211_BSS_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (!nl80211_put_signal(msg, intbss->pub.chains,\n\t\t\t\tintbss->pub.chain_signal,\n\t\t\t\tNL80211_BSS_CHAIN_SIGNAL))\n\t\tgoto nla_put_failure;\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tif (nla_put_u32(msg, NL80211_BSS_SIGNAL_MBM, res->signal))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CFG80211_SIGNAL_TYPE_UNSPEC:\n\t\tif (nla_put_u8(msg, NL80211_BSS_SIGNAL_UNSPEC, res->signal))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_STATION:\n\t\tfor_each_valid_link(wdev, link_id) {\n\t\t\tif (intbss == wdev->links[link_id].client.current_bss &&\n\t\t\t    (nla_put_u32(msg, NL80211_BSS_STATUS,\n\t\t\t\t\t NL80211_BSS_STATUS_ASSOCIATED) ||\n\t\t\t     (wdev->valid_links &&\n\t\t\t      (nla_put_u8(msg, NL80211_BSS_MLO_LINK_ID,\n\t\t\t\t\t  link_id) ||\n\t\t\t       nla_put(msg, NL80211_BSS_MLD_ADDR, ETH_ALEN,\n\t\t\t\t       wdev->u.client.connected_addr)))))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (intbss == wdev->u.ibss.current_bss &&\n\t\t    nla_put_u32(msg, NL80211_BSS_STATUS,\n\t\t\t\tNL80211_BSS_STATUS_IBSS_JOINED))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnla_nest_end(msg, bss);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n fail_unlock_rcu:\n\trcu_read_unlock();\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_scan(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct cfg80211_internal_bss *scan;\n\tstruct wireless_dev *wdev;\n\tint start = cb->args[2], idx = 0;\n\tint err;\n\n\terr = nl80211_prepare_wdev_dump(cb, &rdev, &wdev, NULL);\n\tif (err)\n\t\treturn err;\n\t \n\t__acquire(&rdev->wiphy.mtx);\n\n\twdev_lock(wdev);\n\tspin_lock_bh(&rdev->bss_lock);\n\n\t \n\tif (start == 0)\n\t\tcfg80211_bss_expire(rdev);\n\n\tcb->seq = rdev->bss_generation;\n\n\tlist_for_each_entry(scan, &rdev->bss_list, list) {\n\t\tif (++idx <= start)\n\t\t\tcontinue;\n\t\tif (nl80211_send_bss(skb, cb,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\trdev, wdev, scan) < 0) {\n\t\t\tidx--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rdev->bss_lock);\n\twdev_unlock(wdev);\n\n\tcb->args[2] = idx;\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn skb->len;\n}\n\nstatic int nl80211_send_survey(struct sk_buff *msg, u32 portid, u32 seq,\n\t\t\t       int flags, struct net_device *dev,\n\t\t\t       bool allow_radio_stats,\n\t\t\t       struct survey_info *survey)\n{\n\tvoid *hdr;\n\tstruct nlattr *infoattr;\n\n\t \n\tif (!survey->channel && !allow_radio_stats)\n\t\treturn 0;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags,\n\t\t\t     NL80211_CMD_NEW_SURVEY_RESULTS);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tinfoattr = nla_nest_start_noflag(msg, NL80211_ATTR_SURVEY_INFO);\n\tif (!infoattr)\n\t\tgoto nla_put_failure;\n\n\tif (survey->channel &&\n\t    nla_put_u32(msg, NL80211_SURVEY_INFO_FREQUENCY,\n\t\t\tsurvey->channel->center_freq))\n\t\tgoto nla_put_failure;\n\n\tif (survey->channel && survey->channel->freq_offset &&\n\t    nla_put_u32(msg, NL80211_SURVEY_INFO_FREQUENCY_OFFSET,\n\t\t\tsurvey->channel->freq_offset))\n\t\tgoto nla_put_failure;\n\n\tif ((survey->filled & SURVEY_INFO_NOISE_DBM) &&\n\t    nla_put_u8(msg, NL80211_SURVEY_INFO_NOISE, survey->noise))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_IN_USE) &&\n\t    nla_put_flag(msg, NL80211_SURVEY_INFO_IN_USE))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME,\n\t\t\tsurvey->time, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_BUSY) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_BUSY,\n\t\t\t      survey->time_busy, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_EXT_BUSY) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_EXT_BUSY,\n\t\t\t      survey->time_ext_busy, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_RX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_RX,\n\t\t\t      survey->time_rx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_TX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_TX,\n\t\t\t      survey->time_tx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_SCAN) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_SCAN,\n\t\t\t      survey->time_scan, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\tif ((survey->filled & SURVEY_INFO_TIME_BSS_RX) &&\n\t    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_BSS_RX,\n\t\t\t      survey->time_bss_rx, NL80211_SURVEY_INFO_PAD))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, infoattr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nl80211_dump_survey(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlattr **attrbuf;\n\tstruct survey_info survey;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tint survey_idx = cb->args[2];\n\tint res;\n\tbool radio_stats;\n\n\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf), GFP_KERNEL);\n\tif (!attrbuf)\n\t\treturn -ENOMEM;\n\n\tres = nl80211_prepare_wdev_dump(cb, &rdev, &wdev, attrbuf);\n\tif (res) {\n\t\tkfree(attrbuf);\n\t\treturn res;\n\t}\n\t \n\t__acquire(&rdev->wiphy.mtx);\n\n\t \n\tradio_stats = attrbuf[NL80211_ATTR_SURVEY_RADIO_STATS];\n\n\tif (!wdev->netdev) {\n\t\tres = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\tif (!rdev->ops->dump_survey) {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\twdev_lock(wdev);\n\t\tres = rdev_dump_survey(rdev, wdev->netdev, survey_idx, &survey);\n\t\twdev_unlock(wdev);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tif (res)\n\t\t\tgoto out_err;\n\n\t\t \n\t\tif (survey.channel &&\n\t\t    survey.channel->flags & IEEE80211_CHAN_DISABLED) {\n\t\t\tsurvey_idx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nl80211_send_survey(skb,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\twdev->netdev, radio_stats, &survey) < 0)\n\t\t\tgoto out;\n\t\tsurvey_idx++;\n\t}\n\n out:\n\tcb->args[2] = survey_idx;\n\tres = skb->len;\n out_err:\n\tkfree(attrbuf);\n\twiphy_unlock(&rdev->wiphy);\n\treturn res;\n}\n\nstatic bool nl80211_valid_wpa_versions(u32 wpa_versions)\n{\n\treturn !(wpa_versions & ~(NL80211_WPA_VERSION_1 |\n\t\t\t\t  NL80211_WPA_VERSION_2 |\n\t\t\t\t  NL80211_WPA_VERSION_3));\n}\n\nstatic int nl80211_authenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ieee80211_channel *chan;\n\tconst u8 *bssid, *ssid;\n\tint err, ssid_len;\n\tenum nl80211_auth_type auth_type;\n\tstruct key_parse key;\n\tbool local_state_change;\n\tstruct cfg80211_auth_request req = {};\n\tu32 freq;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_AUTH_TYPE])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_SSID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_key(info, &key);\n\tif (err)\n\t\treturn err;\n\n\tif (key.idx >= 0) {\n\t\tif (key.type != -1 && key.type != NL80211_KEYTYPE_GROUP)\n\t\t\treturn -EINVAL;\n\t\tif (!key.p.key || !key.p.key_len)\n\t\t\treturn -EINVAL;\n\t\tif ((key.p.cipher != WLAN_CIPHER_SUITE_WEP40 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP40) &&\n\t\t    (key.p.cipher != WLAN_CIPHER_SUITE_WEP104 ||\n\t\t     key.p.key_len != WLAN_KEY_LEN_WEP104))\n\t\t\treturn -EINVAL;\n\t\tif (key.idx > 3)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tkey.p.key_len = 0;\n\t\tkey.p.key = NULL;\n\t}\n\n\tif (key.idx >= 0) {\n\t\tint i;\n\t\tbool ok = false;\n\n\t\tfor (i = 0; i < rdev->wiphy.n_cipher_suites; i++) {\n\t\t\tif (key.p.cipher == rdev->wiphy.cipher_suites[i]) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->auth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tfreq = MHZ_TO_KHZ(nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET])\n\t\tfreq +=\n\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET]);\n\n\tchan = nl80211_get_valid_chan(&rdev->wiphy, freq);\n\tif (!chan)\n\t\treturn -EINVAL;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\treq.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\treq.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tauth_type = nla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\tif (!nl80211_valid_auth_type(rdev, auth_type, NL80211_CMD_AUTHENTICATE))\n\t\treturn -EINVAL;\n\n\tif ((auth_type == NL80211_AUTHTYPE_SAE ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_SK ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_SK_PFS ||\n\t     auth_type == NL80211_AUTHTYPE_FILS_PK) &&\n\t    !info->attrs[NL80211_ATTR_AUTH_DATA])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_DATA]) {\n\t\tif (auth_type != NL80211_AUTHTYPE_SAE &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_SK &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_SK_PFS &&\n\t\t    auth_type != NL80211_AUTHTYPE_FILS_PK)\n\t\t\treturn -EINVAL;\n\t\treq.auth_data = nla_data(info->attrs[NL80211_ATTR_AUTH_DATA]);\n\t\treq.auth_data_len = nla_len(info->attrs[NL80211_ATTR_AUTH_DATA]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\t \n\tif (local_state_change)\n\t\treturn 0;\n\n\treq.auth_type = auth_type;\n\treq.key = key.p.key;\n\treq.key_len = key.p.key_len;\n\treq.key_idx = key.idx;\n\treq.link_id = nl80211_link_id_or_invalid(info->attrs);\n\tif (req.link_id >= 0) {\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_MLO))\n\t\t\treturn -EINVAL;\n\t\tif (!info->attrs[NL80211_ATTR_MLD_ADDR])\n\t\t\treturn -EINVAL;\n\t\treq.ap_mld_addr = nla_data(info->attrs[NL80211_ATTR_MLD_ADDR]);\n\t\tif (!is_valid_ether_addr(req.ap_mld_addr))\n\t\t\treturn -EINVAL;\n\t}\n\n\treq.bss = cfg80211_get_bss(&rdev->wiphy, chan, bssid, ssid, ssid_len,\n\t\t\t\t   IEEE80211_BSS_TYPE_ESS,\n\t\t\t\t   IEEE80211_PRIVACY_ANY);\n\tif (!req.bss)\n\t\treturn -ENOENT;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_auth(rdev, dev, &req);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\tcfg80211_put_bss(&rdev->wiphy, req.bss);\n\n\treturn err;\n}\n\nstatic int validate_pae_over_nl80211(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct genl_info *info)\n{\n\tif (!info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\tGENL_SET_ERR_MSG(info, \"SOCKET_OWNER not set\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rdev->ops->tx_control_port ||\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int nl80211_crypto_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct genl_info *info,\n\t\t\t\t   struct cfg80211_crypto_settings *settings,\n\t\t\t\t   int cipher_limit)\n{\n\tmemset(settings, 0, sizeof(*settings));\n\n\tsettings->control_port = info->attrs[NL80211_ATTR_CONTROL_PORT];\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]) {\n\t\tu16 proto;\n\n\t\tproto = nla_get_u16(\n\t\t\tinfo->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);\n\t\tsettings->control_port_ethertype = cpu_to_be16(proto);\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_CONTROL_PORT_PROTOCOL) &&\n\t\t    proto != ETH_P_PAE)\n\t\t\treturn -EINVAL;\n\t\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT])\n\t\t\tsettings->control_port_no_encrypt = true;\n\t} else\n\t\tsettings->control_port_ethertype = cpu_to_be16(ETH_P_PAE);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tsettings->control_port_over_nl80211 = true;\n\n\t\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_NO_PREAUTH])\n\t\t\tsettings->control_port_no_preauth = true;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]) {\n\t\tvoid *data;\n\t\tint len, i;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_CIPHER_SUITES_PAIRWISE]);\n\t\tsettings->n_ciphers_pairwise = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (settings->n_ciphers_pairwise > cipher_limit)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->ciphers_pairwise, data, len);\n\n\t\tfor (i = 0; i < settings->n_ciphers_pairwise; i++)\n\t\t\tif (!cfg80211_supported_cipher_suite(\n\t\t\t\t\t&rdev->wiphy,\n\t\t\t\t\tsettings->ciphers_pairwise[i]))\n\t\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]) {\n\t\tsettings->cipher_group =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_CIPHER_SUITE_GROUP]);\n\t\tif (!cfg80211_supported_cipher_suite(&rdev->wiphy,\n\t\t\t\t\t\t     settings->cipher_group))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WPA_VERSIONS]) {\n\t\tsettings->wpa_versions =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_WPA_VERSIONS]);\n\t\tif (!nl80211_valid_wpa_versions(settings->wpa_versions))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AKM_SUITES]) {\n\t\tvoid *data;\n\t\tint len;\n\n\t\tdata = nla_data(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_AKM_SUITES]);\n\t\tsettings->n_akm_suites = len / sizeof(u32);\n\n\t\tif (len % sizeof(u32))\n\t\t\treturn -EINVAL;\n\n\t\tif (settings->n_akm_suites > rdev->wiphy.max_num_akm_suites)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(settings->akm_suites, data, len);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMK]) {\n\t\tif (nla_len(info->attrs[NL80211_ATTR_PMK]) != WLAN_PMK_LEN)\n\t\t\treturn -EINVAL;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK))\n\t\t\treturn -EINVAL;\n\t\tsettings->psk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SAE_PASSWORD]) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SAE_OFFLOAD_AP))\n\t\t\treturn -EINVAL;\n\t\tsettings->sae_pwd =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_SAE_PASSWORD]);\n\t\tsettings->sae_pwd_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_SAE_PASSWORD]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_SAE_PWE])\n\t\tsettings->sae_pwe =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_SAE_PWE]);\n\telse\n\t\tsettings->sae_pwe = NL80211_SAE_PWE_UNSPECIFIED;\n\n\treturn 0;\n}\n\nstatic struct cfg80211_bss *nl80211_assoc_bss(struct cfg80211_registered_device *rdev,\n\t\t\t\t\t      const u8 *ssid, int ssid_len,\n\t\t\t\t\t      struct nlattr **attrs)\n{\n\tstruct ieee80211_channel *chan;\n\tstruct cfg80211_bss *bss;\n\tconst u8 *bssid;\n\tu32 freq;\n\n\tif (!attrs[NL80211_ATTR_MAC] || !attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbssid = nla_data(attrs[NL80211_ATTR_MAC]);\n\n\tfreq = MHZ_TO_KHZ(nla_get_u32(attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET])\n\t\tfreq += nla_get_u32(attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET]);\n\n\tchan = nl80211_get_valid_chan(&rdev->wiphy, freq);\n\tif (!chan)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbss = cfg80211_get_bss(&rdev->wiphy, chan, bssid,\n\t\t\t       ssid, ssid_len,\n\t\t\t       IEEE80211_BSS_TYPE_ESS,\n\t\t\t       IEEE80211_PRIVACY_ANY);\n\tif (!bss)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn bss;\n}\n\nstatic int nl80211_associate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_assoc_request req = {};\n\tstruct nlattr **attrs = NULL;\n\tconst u8 *ap_addr, *ssid;\n\tunsigned int link_id;\n\tint err, ssid_len;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_SSID])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->assoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\treq.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\treq.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\n\t\tif (cfg80211_find_ext_elem(WLAN_EID_EXT_NON_INHERITANCE,\n\t\t\t\t\t   req.ie, req.ie_len)) {\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"non-inheritance makes no sense\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_USE_MFP]) {\n\t\tenum nl80211_mfp mfp =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_USE_MFP]);\n\t\tif (mfp == NL80211_MFP_REQUIRED)\n\t\t\treq.use_mfp = true;\n\t\telse if (mfp != NL80211_MFP_NO)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PREV_BSSID])\n\t\treq.prev_bssid = nla_data(info->attrs[NL80211_ATTR_PREV_BSSID]);\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HT]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_HT;\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&req.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(req.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(req.ht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_VHT]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_VHT;\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HE]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_HE;\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_EHT]))\n\t\treq.flags |= ASSOC_REQ_DISABLE_EHT;\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\tmemcpy(&req.vht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]),\n\t\t       sizeof(req.vht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.vht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]),\n\t\t       sizeof(req.vht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_USE_RRM])) {\n\t\tif (!((rdev->wiphy.features &\n\t\t\tNL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES) &&\n\t\t       (rdev->wiphy.features & NL80211_FEATURE_QUIET)) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_RRM))\n\t\t\treturn -EINVAL;\n\t\treq.flags |= ASSOC_REQ_USE_RRM;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_FILS_KEK]) {\n\t\treq.fils_kek = nla_data(info->attrs[NL80211_ATTR_FILS_KEK]);\n\t\treq.fils_kek_len = nla_len(info->attrs[NL80211_ATTR_FILS_KEK]);\n\t\tif (!info->attrs[NL80211_ATTR_FILS_NONCES])\n\t\t\treturn -EINVAL;\n\t\treq.fils_nonces =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_NONCES]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_S1G_CAPABILITY_MASK]) {\n\t\tif (!info->attrs[NL80211_ATTR_S1G_CAPABILITY])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.s1g_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_S1G_CAPABILITY_MASK]),\n\t\t       sizeof(req.s1g_capa_mask));\n\t}\n\n\tif (info->attrs[NL80211_ATTR_S1G_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_S1G_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&req.s1g_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_S1G_CAPABILITY]),\n\t\t       sizeof(req.s1g_capa));\n\t}\n\n\treq.link_id = nl80211_link_id_or_invalid(info->attrs);\n\n\tif (info->attrs[NL80211_ATTR_MLO_LINKS]) {\n\t\tunsigned int attrsize = NUM_NL80211_ATTR * sizeof(*attrs);\n\t\tstruct nlattr *link;\n\t\tint rem = 0;\n\n\t\tif (req.link_id < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_MLO))\n\t\t\treturn -EINVAL;\n\n\t\tif (info->attrs[NL80211_ATTR_MAC] ||\n\t\t    info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t\t    !info->attrs[NL80211_ATTR_MLD_ADDR])\n\t\t\treturn -EINVAL;\n\n\t\treq.ap_mld_addr = nla_data(info->attrs[NL80211_ATTR_MLD_ADDR]);\n\t\tap_addr = req.ap_mld_addr;\n\n\t\tattrs = kzalloc(attrsize, GFP_KERNEL);\n\t\tif (!attrs)\n\t\t\treturn -ENOMEM;\n\n\t\tnla_for_each_nested(link,\n\t\t\t\t    info->attrs[NL80211_ATTR_MLO_LINKS],\n\t\t\t\t    rem) {\n\t\t\tmemset(attrs, 0, attrsize);\n\n\t\t\tnla_parse_nested(attrs, NL80211_ATTR_MAX,\n\t\t\t\t\t link, NULL, NULL);\n\n\t\t\tif (!attrs[NL80211_ATTR_MLO_LINK_ID]) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tlink_id = nla_get_u8(attrs[NL80211_ATTR_MLO_LINK_ID]);\n\t\t\t \n\t\t\tif (req.links[link_id].bss) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\treq.links[link_id].bss =\n\t\t\t\tnl80211_assoc_bss(rdev, ssid, ssid_len, attrs);\n\t\t\tif (IS_ERR(req.links[link_id].bss)) {\n\t\t\t\terr = PTR_ERR(req.links[link_id].bss);\n\t\t\t\treq.links[link_id].bss = NULL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (attrs[NL80211_ATTR_IE]) {\n\t\t\t\treq.links[link_id].elems =\n\t\t\t\t\tnla_data(attrs[NL80211_ATTR_IE]);\n\t\t\t\treq.links[link_id].elems_len =\n\t\t\t\t\tnla_len(attrs[NL80211_ATTR_IE]);\n\n\t\t\t\tif (cfg80211_find_elem(WLAN_EID_FRAGMENT,\n\t\t\t\t\t\t       req.links[link_id].elems,\n\t\t\t\t\t\t       req.links[link_id].elems_len)) {\n\t\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t\t \"cannot deal with fragmentation\");\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto free;\n\t\t\t\t}\n\n\t\t\t\tif (cfg80211_find_ext_elem(WLAN_EID_EXT_NON_INHERITANCE,\n\t\t\t\t\t\t\t   req.links[link_id].elems,\n\t\t\t\t\t\t\t   req.links[link_id].elems_len)) {\n\t\t\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t\t\t \"cannot deal with non-inheritance\");\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto free;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treq.links[link_id].disabled =\n\t\t\t\tnla_get_flag(attrs[NL80211_ATTR_MLO_LINK_DISABLED]);\n\t\t}\n\n\t\tif (!req.links[req.link_id].bss) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (req.links[req.link_id].elems_len) {\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"cannot have per-link elems on assoc link\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (req.links[req.link_id].disabled) {\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"cannot have assoc link disabled\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tkfree(attrs);\n\t\tattrs = NULL;\n\t} else {\n\t\tif (req.link_id >= 0)\n\t\t\treturn -EINVAL;\n\n\t\treq.bss = nl80211_assoc_bss(rdev, ssid, ssid_len, info->attrs);\n\t\tif (IS_ERR(req.bss))\n\t\t\treturn PTR_ERR(req.bss);\n\t\tap_addr = req.bss->bssid;\n\t}\n\n\terr = nl80211_crypto_settings(rdev, info, &req.crypto, 1);\n\tif (!err) {\n\t\twdev_lock(dev->ieee80211_ptr);\n\n\t\terr = cfg80211_mlme_assoc(rdev, dev, &req);\n\n\t\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\tdev->ieee80211_ptr->conn_owner_nlportid =\n\t\t\t\tinfo->snd_portid;\n\t\t\tmemcpy(dev->ieee80211_ptr->disconnect_bssid,\n\t\t\t       ap_addr, ETH_ALEN);\n\t\t}\n\n\t\twdev_unlock(dev->ieee80211_ptr);\n\t}\n\nfree:\n\tfor (link_id = 0; link_id < ARRAY_SIZE(req.links); link_id++)\n\t\tcfg80211_put_bss(&rdev->wiphy, req.links[link_id].bss);\n\tcfg80211_put_bss(&rdev->wiphy, req.bss);\n\tkfree(attrs);\n\n\treturn err;\n}\n\nstatic int nl80211_deauthenticate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0, err;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->deauth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_deauth(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t   local_state_change);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic int nl80211_disassociate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tconst u8 *ie = NULL, *bssid;\n\tint ie_len = 0, err;\n\tu16 reason_code;\n\tbool local_state_change;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->disassoc)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tbssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treason_code = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\tif (reason_code == 0) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tlocal_state_change = !!info->attrs[NL80211_ATTR_LOCAL_STATE_CHANGE];\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = cfg80211_mlme_disassoc(rdev, dev, bssid, ie, ie_len, reason_code,\n\t\t\t\t     local_state_change);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn err;\n}\n\nstatic bool\nnl80211_parse_mcast_rate(struct cfg80211_registered_device *rdev,\n\t\t\t int mcast_rate[NUM_NL80211_BANDS],\n\t\t\t int rateval)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tbool found = false;\n\tint band, i;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == rateval) {\n\t\t\t\tmcast_rate[band] = i + 1;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic int nl80211_join_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_ibss_params ibss;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tint err;\n\n\tmemset(&ibss, 0, sizeof(ibss));\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tibss.beacon_interval = 100;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL])\n\t\tibss.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\n\terr = cfg80211_validate_beacon_int(rdev, NL80211_IFTYPE_ADHOC,\n\t\t\t\t\t   ibss.beacon_interval);\n\tif (err)\n\t\treturn err;\n\n\tif (!rdev->ops->join_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tif (info->attrs[NL80211_ATTR_MAC]) {\n\t\tibss.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\t\tif (!is_valid_ether_addr(ibss.bssid))\n\t\t\treturn -EINVAL;\n\t}\n\tibss.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tibss.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tibss.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tibss.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\terr = nl80211_parse_chandef(rdev, info, &ibss.chandef);\n\tif (err)\n\t\treturn err;\n\n\tif (!cfg80211_reg_can_beacon(&rdev->wiphy, &ibss.chandef,\n\t\t\t\t     NL80211_IFTYPE_ADHOC))\n\t\treturn -EINVAL;\n\n\tswitch (ibss.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_HT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tif (!(rdev->wiphy.features & NL80211_FEATURE_HT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_VHT_IBSS))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tibss.channel_fixed = !!info->attrs[NL80211_ATTR_FREQ_FIXED];\n\tibss.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband =\n\t\t\twiphy->bands[ibss.chandef.chan->band];\n\n\t\terr = ieee80211_get_ratemask(sband, rates, n_rates,\n\t\t\t\t\t     &ibss.basic_rates);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&ibss.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(ibss.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\t\treturn -EINVAL;\n\t\tmemcpy(&ibss.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(ibss.ht_capa));\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, ibss.mcast_rate,\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\treturn -EINVAL;\n\n\tif (ibss.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tbool no_ht = false;\n\n\t\tconnkeys = nl80211_parse_connkeys(rdev, info, &no_ht);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\n\t\tif ((ibss.chandef.width != NL80211_CHAN_WIDTH_20_NOHT) &&\n\t\t    no_ht) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tibss.control_port =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_CONTROL_PORT]);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn r;\n\t\t}\n\n\t\tibss.control_port_over_nl80211 = true;\n\t}\n\n\tibss.userspace_handles_dfs =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS]);\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = __cfg80211_join_ibss(rdev, dev, &ibss, connkeys);\n\tif (err)\n\t\tkfree_sensitive(connkeys);\n\telse if (info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_leave_ibss(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->leave_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cfg80211_leave_ibss(rdev, dev, false);\n}\n\nstatic int nl80211_set_mcast_rate(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tint mcast_rate[NUM_NL80211_BANDS];\n\tu32 nla_rate;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_ADHOC &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_OCB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->set_mcast_rate)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(mcast_rate, 0, sizeof(mcast_rate));\n\n\tif (!info->attrs[NL80211_ATTR_MCAST_RATE])\n\t\treturn -EINVAL;\n\n\tnla_rate = nla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE]);\n\tif (!nl80211_parse_mcast_rate(rdev, mcast_rate, nla_rate))\n\t\treturn -EINVAL;\n\n\treturn rdev_set_mcast_rate(rdev, dev, mcast_rate);\n}\n\nstatic struct sk_buff *\n__cfg80211_alloc_vendor_skb(struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev, int approxlen,\n\t\t\t    u32 portid, u32 seq, enum nl80211_commands cmd,\n\t\t\t    enum nl80211_attrs attr,\n\t\t\t    const struct nl80211_vendor_cmd_info *info,\n\t\t\t    gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tvoid *hdr;\n\tstruct nlattr *data;\n\n\tskb = nlmsg_new(approxlen + 100, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = nl80211hdr_put(skb, portid, seq, 0, cmd);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\tif (info) {\n\t\tif (nla_put_u32(skb, NL80211_ATTR_VENDOR_ID,\n\t\t\t\tinfo->vendor_id))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u32(skb, NL80211_ATTR_VENDOR_SUBCMD,\n\t\t\t\tinfo->subcmd))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (wdev) {\n\t\tif (nla_put_u64_64bit(skb, NL80211_ATTR_WDEV,\n\t\t\t\t      wdev_id(wdev), NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t\tif (wdev->netdev &&\n\t\t    nla_put_u32(skb, NL80211_ATTR_IFINDEX,\n\t\t\t\twdev->netdev->ifindex))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tdata = nla_nest_start_noflag(skb, attr);\n\tif (!data)\n\t\tgoto nla_put_failure;\n\n\t((void **)skb->cb)[0] = rdev;\n\t((void **)skb->cb)[1] = hdr;\n\t((void **)skb->cb)[2] = data;\n\n\treturn skb;\n\n nla_put_failure:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstruct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   unsigned int portid,\n\t\t\t\t\t   int vendor_event_idx,\n\t\t\t\t\t   int approxlen, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tconst struct nl80211_vendor_cmd_info *info;\n\n\tswitch (cmd) {\n\tcase NL80211_CMD_TESTMODE:\n\t\tif (WARN_ON(vendor_event_idx != -1))\n\t\t\treturn NULL;\n\t\tinfo = NULL;\n\t\tbreak;\n\tcase NL80211_CMD_VENDOR:\n\t\tif (WARN_ON(vendor_event_idx < 0 ||\n\t\t\t    vendor_event_idx >= wiphy->n_vendor_events))\n\t\t\treturn NULL;\n\t\tinfo = &wiphy->vendor_events[vendor_event_idx];\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\treturn __cfg80211_alloc_vendor_skb(rdev, wdev, approxlen, portid, 0,\n\t\t\t\t\t   cmd, attr, info, gfp);\n}\nEXPORT_SYMBOL(__cfg80211_alloc_event_skb);\n\nvoid __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlmsghdr *nlhdr = nlmsg_hdr(skb);\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\tenum nl80211_multicast_groups mcgrp = NL80211_MCGRP_TESTMODE;\n\n\t \n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\n\tif (nlhdr->nlmsg_pid) {\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), skb,\n\t\t\t\tnlhdr->nlmsg_pid);\n\t} else {\n\t\tif (data->nla_type == NL80211_ATTR_VENDOR_DATA)\n\t\t\tmcgrp = NL80211_MCGRP_VENDOR;\n\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tskb, 0, mcgrp, gfp);\n\t}\n}\nEXPORT_SYMBOL(__cfg80211_send_event_skb);\n\n#ifdef CONFIG_NL80211_TESTMODE\nstatic int nl80211_testmode_do(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev;\n\tint err;\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\twdev = __cfg80211_wdev_from_attrs(rdev, genl_info_net(info),\n\t\t\t\t\t  info->attrs);\n\n\tif (!rdev->ops->testmode_cmd)\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ERR(wdev)) {\n\t\terr = PTR_ERR(wdev);\n\t\tif (err != -EINVAL)\n\t\t\treturn err;\n\t\twdev = NULL;\n\t} else if (wdev->wiphy != &rdev->wiphy) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_TESTDATA])\n\t\treturn -EINVAL;\n\n\trdev->cur_cmd_info = info;\n\terr = rdev_testmode_cmd(rdev, wdev,\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_TESTDATA]),\n\t\t\t\tnla_len(info->attrs[NL80211_ATTR_TESTDATA]));\n\trdev->cur_cmd_info = NULL;\n\n\treturn err;\n}\n\nstatic int nl80211_testmode_dump(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct nlattr **attrbuf = NULL;\n\tint err;\n\tlong phy_idx;\n\tvoid *data = NULL;\n\tint data_len = 0;\n\n\trtnl_lock();\n\n\tif (cb->args[0]) {\n\t\t \n\t\tphy_idx = cb->args[0] - 1;\n\n\t\trdev = cfg80211_rdev_by_wiphy_idx(phy_idx);\n\t\tif (!rdev) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!attrbuf) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t\t     nl80211_policy, NULL);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\trdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk), attrbuf);\n\t\tif (IS_ERR(rdev)) {\n\t\t\terr = PTR_ERR(rdev);\n\t\t\tgoto out_err;\n\t\t}\n\t\tphy_idx = rdev->wiphy_idx;\n\n\t\tif (attrbuf[NL80211_ATTR_TESTDATA])\n\t\t\tcb->args[1] = (long)attrbuf[NL80211_ATTR_TESTDATA];\n\t}\n\n\tif (cb->args[1]) {\n\t\tdata = nla_data((void *)cb->args[1]);\n\t\tdata_len = nla_len((void *)cb->args[1]);\n\t}\n\n\tif (!rdev->ops->testmode_dump) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\twhile (1) {\n\t\tvoid *hdr = nl80211hdr_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t   NL80211_CMD_TESTMODE);\n\t\tstruct nlattr *tmdata;\n\n\t\tif (!hdr)\n\t\t\tbreak;\n\n\t\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, phy_idx)) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\ttmdata = nla_nest_start_noflag(skb, NL80211_ATTR_TESTDATA);\n\t\tif (!tmdata) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\t\terr = rdev_testmode_dump(rdev, skb, cb, data, data_len);\n\t\tnla_nest_end(skb, tmdata);\n\n\t\tif (err == -ENOBUFS || err == -ENOENT) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t} else if (err) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tgenlmsg_end(skb, hdr);\n\t}\n\n\terr = skb->len;\n\t \n\tcb->args[0] = phy_idx + 1;\n out_err:\n\tkfree(attrbuf);\n\trtnl_unlock();\n\treturn err;\n}\n#endif\n\nstatic int nl80211_connect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_connect_params connect;\n\tstruct wiphy *wiphy;\n\tstruct cfg80211_cached_keys *connkeys = NULL;\n\tu32 freq = 0;\n\tint err;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\tif (!info->attrs[NL80211_ATTR_SSID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_SSID]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tconnect.auth_type =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, connect.auth_type,\n\t\t\t\t\t     NL80211_CMD_CONNECT))\n\t\t\treturn -EINVAL;\n\t} else\n\t\tconnect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\tconnect.privacy = info->attrs[NL80211_ATTR_PRIVACY];\n\n\tif (info->attrs[NL80211_ATTR_WANT_1X_4WAY_HS] &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EINVAL;\n\tconnect.want_1x = info->attrs[NL80211_ATTR_WANT_1X_4WAY_HS];\n\n\terr = nl80211_crypto_settings(rdev, info, &connect.crypto,\n\t\t\t\t      NL80211_MAX_NR_CIPHER_SUITES);\n\tif (err)\n\t\treturn err;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy = &rdev->wiphy;\n\n\tconnect.bg_scan_period = -1;\n\tif (info->attrs[NL80211_ATTR_BG_SCAN_PERIOD] &&\n\t\t(wiphy->flags & WIPHY_FLAG_SUPPORTS_FW_ROAM)) {\n\t\tconnect.bg_scan_period =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_BG_SCAN_PERIOD]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\tconnect.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\telse if (info->attrs[NL80211_ATTR_MAC_HINT])\n\t\tconnect.bssid_hint =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MAC_HINT]);\n\tconnect.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\tconnect.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_USE_MFP]) {\n\t\tconnect.mfp = nla_get_u32(info->attrs[NL80211_ATTR_USE_MFP]);\n\t\tif (connect.mfp == NL80211_MFP_OPTIONAL &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_MFP_OPTIONAL))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\tconnect.mfp = NL80211_MFP_NO;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PREV_BSSID])\n\t\tconnect.prev_bssid =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_PREV_BSSID]);\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\tfreq = MHZ_TO_KHZ(nla_get_u32(\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_WIPHY_FREQ]));\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET])\n\t\tfreq +=\n\t\t    nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_OFFSET]);\n\n\tif (freq) {\n\t\tconnect.channel = nl80211_get_valid_chan(wiphy, freq);\n\t\tif (!connect.channel)\n\t\t\treturn -EINVAL;\n\t} else if (info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]) {\n\t\tfreq = nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ_HINT]);\n\t\tfreq = MHZ_TO_KHZ(freq);\n\t\tconnect.channel_hint = nl80211_get_valid_chan(wiphy, freq);\n\t\tif (!connect.channel_hint)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]) {\n\t\tconnect.edmg.channels =\n\t\t      nla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_CHANNELS]);\n\n\t\tif (info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG])\n\t\t\tconnect.edmg.bw_config =\n\t\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_WIPHY_EDMG_BW_CONFIG]);\n\t}\n\n\tif (connect.privacy && info->attrs[NL80211_ATTR_KEYS]) {\n\t\tconnkeys = nl80211_parse_connkeys(rdev, info, NULL);\n\t\tif (IS_ERR(connkeys))\n\t\t\treturn PTR_ERR(connkeys);\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HT]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_HT;\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK])\n\t\tmemcpy(&connect.ht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]),\n\t\t       sizeof(connect.ht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_HT_CAPABILITY_MASK]) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&connect.ht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]),\n\t\t       sizeof(connect.ht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_VHT]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_VHT;\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_HE]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_HE;\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_DISABLE_EHT]))\n\t\tconnect.flags |= ASSOC_REQ_DISABLE_EHT;\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK])\n\t\tmemcpy(&connect.vht_capa_mask,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]),\n\t\t       sizeof(connect.vht_capa_mask));\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY]) {\n\t\tif (!info->attrs[NL80211_ATTR_VHT_CAPABILITY_MASK]) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&connect.vht_capa,\n\t\t       nla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]),\n\t\t       sizeof(connect.vht_capa));\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_USE_RRM])) {\n\t\tif (!((rdev->wiphy.features &\n\t\t\tNL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES) &&\n\t\t       (rdev->wiphy.features & NL80211_FEATURE_QUIET)) &&\n\t\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_RRM)) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconnect.flags |= ASSOC_REQ_USE_RRM;\n\t}\n\n\tconnect.pbss = nla_get_flag(info->attrs[NL80211_ATTR_PBSS]);\n\tif (connect.pbss && !rdev->wiphy.bands[NL80211_BAND_60GHZ]) {\n\t\tkfree_sensitive(connkeys);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BSS_SELECT]) {\n\t\t \n\t\tif (connect.bssid) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = parse_bss_select(info->attrs[NL80211_ATTR_BSS_SELECT],\n\t\t\t\t       wiphy, &connect.bss_select);\n\t\tif (err) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t    NL80211_EXT_FEATURE_FILS_SK_OFFLOAD) &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_REALM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tconnect.fils_erp_username =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_username_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_realm =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_realm_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_next_seq_num =\n\t\t\tnla_get_u16(\n\t\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM]);\n\t\tconnect.fils_erp_rrk =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tconnect.fils_erp_rrk_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t} else if (info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_REALM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tkfree_sensitive(connkeys);\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_EXTERNAL_AUTH_SUPPORT])) {\n\t\tif (!info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\t\tkfree_sensitive(connkeys);\n\t\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t\t \"external auth requires connection ownership\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconnect.flags |= CONNECT_REQ_EXTERNAL_AUTH_SUPPORT;\n\t}\n\n\tif (nla_get_flag(info->attrs[NL80211_ATTR_MLO_SUPPORT]))\n\t\tconnect.flags |= CONNECT_REQ_MLO_SUPPORT;\n\n\twdev_lock(dev->ieee80211_ptr);\n\n\terr = cfg80211_connect(rdev, dev, &connect, connkeys,\n\t\t\t       connect.prev_bssid);\n\tif (err)\n\t\tkfree_sensitive(connkeys);\n\n\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER]) {\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\t\tif (connect.bssid)\n\t\t\tmemcpy(dev->ieee80211_ptr->disconnect_bssid,\n\t\t\t       connect.bssid, ETH_ALEN);\n\t\telse\n\t\t\teth_zero_addr(dev->ieee80211_ptr->disconnect_bssid);\n\t}\n\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_update_connect_params(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tstruct cfg80211_connect_params connect = {};\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool fils_sk_offload;\n\tu32 auth_type;\n\tu32 changed = 0;\n\tint ret;\n\n\tif (!rdev->ops->update_connect_params)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\tconnect.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\tconnect.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t\tchanged |= UPDATE_ASSOC_IES;\n\t}\n\n\tfils_sk_offload = wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t\t  NL80211_EXT_FEATURE_FILS_SK_OFFLOAD);\n\n\t \n\tif (fils_sk_offload &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_REALM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] &&\n\t    info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\tconnect.fils_erp_username =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_username_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_USERNAME]);\n\t\tconnect.fils_erp_realm =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_realm_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_REALM]);\n\t\tconnect.fils_erp_next_seq_num =\n\t\t\tnla_get_u16(\n\t\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM]);\n\t\tconnect.fils_erp_rrk =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tconnect.fils_erp_rrk_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_FILS_ERP_RRK]);\n\t\tchanged |= UPDATE_FILS_ERP_INFO;\n\t} else if (info->attrs[NL80211_ATTR_FILS_ERP_USERNAME] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_REALM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM] ||\n\t\t   info->attrs[NL80211_ATTR_FILS_ERP_RRK]) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_AUTH_TYPE]) {\n\t\tauth_type = nla_get_u32(info->attrs[NL80211_ATTR_AUTH_TYPE]);\n\t\tif (!nl80211_valid_auth_type(rdev, auth_type,\n\t\t\t\t\t     NL80211_CMD_CONNECT))\n\t\t\treturn -EINVAL;\n\n\t\tif (auth_type == NL80211_AUTHTYPE_FILS_SK &&\n\t\t    fils_sk_offload && !(changed & UPDATE_FILS_ERP_INFO))\n\t\t\treturn -EINVAL;\n\n\t\tconnect.auth_type = auth_type;\n\t\tchanged |= UPDATE_AUTH_TYPE;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\tif (!wdev->connected)\n\t\tret = -ENOLINK;\n\telse\n\t\tret = rdev_update_connect_params(rdev, dev, &connect, changed);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn ret;\n}\n\nstatic int nl80211_disconnect(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu16 reason;\n\tint ret;\n\n\tif (dev->ieee80211_ptr->conn_owner_nlportid &&\n\t    dev->ieee80211_ptr->conn_owner_nlportid != info->snd_portid)\n\t\treturn -EPERM;\n\n\tif (!info->attrs[NL80211_ATTR_REASON_CODE])\n\t\treason = WLAN_REASON_DEAUTH_LEAVING;\n\telse\n\t\treason = nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);\n\n\tif (reason == 0)\n\t\treturn -EINVAL;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(dev->ieee80211_ptr);\n\tret = cfg80211_disconnect(rdev, dev, reason, true);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn ret;\n}\n\nstatic int nl80211_wiphy_netns(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net *net;\n\tint err;\n\n\tif (info->attrs[NL80211_ATTR_PID]) {\n\t\tu32 pid = nla_get_u32(info->attrs[NL80211_ATTR_PID]);\n\n\t\tnet = get_net_ns_by_pid(pid);\n\t} else if (info->attrs[NL80211_ATTR_NETNS_FD]) {\n\t\tu32 fd = nla_get_u32(info->attrs[NL80211_ATTR_NETNS_FD]);\n\n\t\tnet = get_net_ns_by_fd(fd);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\terr = 0;\n\n\t \n\tif (!net_eq(wiphy_net(&rdev->wiphy), net))\n\t\terr = cfg80211_switch_netns(rdev, net);\n\n\tput_net(net);\n\treturn err;\n}\n\nstatic int nl80211_setdel_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tint (*rdev_ops)(struct wiphy *wiphy, struct net_device *dev,\n\t\t\tstruct cfg80211_pmksa *pmksa) = NULL;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_pmksa pmksa;\n\n\tmemset(&pmksa, 0, sizeof(struct cfg80211_pmksa));\n\n\tif (!info->attrs[NL80211_ATTR_PMKID])\n\t\treturn -EINVAL;\n\n\tpmksa.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);\n\n\tif (info->attrs[NL80211_ATTR_MAC]) {\n\t\tpmksa.bssid = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\t} else if (info->attrs[NL80211_ATTR_SSID] &&\n\t\t   info->attrs[NL80211_ATTR_FILS_CACHE_ID] &&\n\t\t   (info->genlhdr->cmd == NL80211_CMD_DEL_PMKSA ||\n\t\t    info->attrs[NL80211_ATTR_PMK])) {\n\t\tpmksa.ssid = nla_data(info->attrs[NL80211_ATTR_SSID]);\n\t\tpmksa.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tpmksa.cache_id =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_FILS_CACHE_ID]);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (info->attrs[NL80211_ATTR_PMK]) {\n\t\tpmksa.pmk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\t\tpmksa.pmk_len = nla_len(info->attrs[NL80211_ATTR_PMK]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMK_LIFETIME])\n\t\tpmksa.pmk_lifetime =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_PMK_LIFETIME]);\n\n\tif (info->attrs[NL80211_ATTR_PMK_REAUTH_THRESHOLD])\n\t\tpmksa.pmk_reauth_threshold =\n\t\t\tnla_get_u8(\n\t\t\t\tinfo->attrs[NL80211_ATTR_PMK_REAUTH_THRESHOLD]);\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t    !(dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP &&\n\t      wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_AP_PMKSA_CACHING)))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (info->genlhdr->cmd) {\n\tcase NL80211_CMD_SET_PMKSA:\n\t\trdev_ops = rdev->ops->set_pmksa;\n\t\tbreak;\n\tcase NL80211_CMD_DEL_PMKSA:\n\t\trdev_ops = rdev->ops->del_pmksa;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif (!rdev_ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_ops(&rdev->wiphy, dev, &pmksa);\n}\n\nstatic int nl80211_flush_pmksa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->flush_pmksa)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_flush_pmksa(rdev, dev);\n}\n\nstatic int nl80211_tdls_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 action_code, dialog_token;\n\tu32 peer_capability = 0;\n\tu16 status_code;\n\tu8 *peer;\n\tint link_id;\n\tbool initiator;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) ||\n\t    !rdev->ops->tdls_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TDLS_ACTION] ||\n\t    !info->attrs[NL80211_ATTR_STATUS_CODE] ||\n\t    !info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN] ||\n\t    !info->attrs[NL80211_ATTR_IE] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\taction_code = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_ACTION]);\n\tstatus_code = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\tdialog_token = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN]);\n\tinitiator = nla_get_flag(info->attrs[NL80211_ATTR_TDLS_INITIATOR]);\n\tif (info->attrs[NL80211_ATTR_TDLS_PEER_CAPABILITY])\n\t\tpeer_capability =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_TDLS_PEER_CAPABILITY]);\n\tlink_id = nl80211_link_id_or_invalid(info->attrs);\n\n\treturn rdev_tdls_mgmt(rdev, dev, peer, link_id, action_code,\n\t\t\t      dialog_token, status_code, peer_capability,\n\t\t\t      initiator,\n\t\t\t      nla_data(info->attrs[NL80211_ATTR_IE]),\n\t\t\t      nla_len(info->attrs[NL80211_ATTR_IE]));\n}\n\nstatic int nl80211_tdls_oper(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tenum nl80211_tdls_operation operation;\n\tu8 *peer;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) ||\n\t    !rdev->ops->tdls_oper)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TDLS_OPERATION] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\toperation = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_OPERATION]);\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\treturn rdev_tdls_oper(rdev, dev, peer, operation);\n}\n\nstatic int nl80211_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tunsigned int link_id = nl80211_link_id(info->attrs);\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu64 cookie;\n\tu32 duration;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ] ||\n\t    !info->attrs[NL80211_ATTR_DURATION])\n\t\treturn -EINVAL;\n\n\tduration = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\tif (!rdev->ops->remain_on_channel ||\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (duration < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t    duration > rdev->wiphy.max_remain_on_channel_duration)\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(wdev);\n\tif (!cfg80211_off_channel_oper_allowed(wdev, chandef.chan)) {\n\t\tconst struct cfg80211_chan_def *oper_chandef, *compat_chandef;\n\n\t\toper_chandef = wdev_chandef(wdev, link_id);\n\n\t\tif (WARN_ON(!oper_chandef)) {\n\t\t\t \n\t\t\tWARN_ON(1);\n\t\t\twdev_unlock(wdev);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\tcompat_chandef = cfg80211_chandef_compatible(&chandef,\n\t\t\t\t\t\t\t     oper_chandef);\n\n\t\tif (compat_chandef != &chandef) {\n\t\t\twdev_unlock(wdev);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\twdev_unlock(wdev);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_REMAIN_ON_CHANNEL);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\terr = rdev_remain_on_channel(rdev, wdev, chandef.chan,\n\t\t\t\t     duration, &cookie);\n\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_cancel_remain_on_channel(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->cancel_remain_on_channel)\n\t\treturn -EOPNOTSUPP;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev_cancel_remain_on_channel(rdev, wdev, cookie);\n}\n\nstatic int nl80211_set_tx_bitrate_mask(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_bitrate_mask mask;\n\tunsigned int link_id = nl80211_link_id(info->attrs);\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err;\n\n\tif (!rdev->ops->set_bitrate_mask)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\terr = nl80211_parse_tx_bitrate_mask(info, info->attrs,\n\t\t\t\t\t    NL80211_ATTR_TX_RATES, &mask,\n\t\t\t\t\t    dev, true, link_id);\n\tif (err)\n\t\tgoto out;\n\n\terr = rdev_set_bitrate_mask(rdev, dev, link_id, NULL, &mask);\nout:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_register_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu16 frame_type = IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME_MATCH])\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_FRAME_TYPE])\n\t\tframe_type = nla_get_u16(info->attrs[NL80211_ATTR_FRAME_TYPE]);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\t\tif (!wiphy_ext_feature_isset(wdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SECURE_NAN))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_RECEIVE_MULTICAST] &&\n\t    !wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS)) {\n\t\tGENL_SET_ERR_MSG(info,\n\t\t\t\t \"multicast RX registrations are not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn cfg80211_mlme_register_mgmt(wdev, info->snd_portid, frame_type,\n\t\t\t\t\t   nla_data(info->attrs[NL80211_ATTR_FRAME_MATCH]),\n\t\t\t\t\t   nla_len(info->attrs[NL80211_ATTR_FRAME_MATCH]),\n\t\t\t\t\t   info->attrs[NL80211_ATTR_RECEIVE_MULTICAST],\n\t\t\t\t\t   info->extack);\n}\n\nstatic int nl80211_tx_mgmt(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_chan_def chandef;\n\tint err;\n\tvoid *hdr = NULL;\n\tu64 cookie;\n\tstruct sk_buff *msg = NULL;\n\tstruct cfg80211_mgmt_tx_params params = {\n\t\t.dont_wait_for_ack =\n\t\t\tinfo->attrs[NL80211_ATTR_DONT_WAIT_FOR_ACK],\n\t};\n\n\tif (!info->attrs[NL80211_ATTR_FRAME])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tif (!info->attrs[NL80211_ATTR_WIPHY_FREQ])\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\t\tif (!wiphy_ext_feature_isset(wdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SECURE_NAN))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_DURATION]) {\n\t\tif (!(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\t\treturn -EINVAL;\n\t\tparams.wait = nla_get_u32(info->attrs[NL80211_ATTR_DURATION]);\n\n\t\t \n\t\tif (params.wait < NL80211_MIN_REMAIN_ON_CHANNEL_TIME ||\n\t\t    params.wait > rdev->wiphy.max_remain_on_channel_duration)\n\t\t\treturn -EINVAL;\n\t}\n\n\tparams.offchan = info->attrs[NL80211_ATTR_OFFCHANNEL_TX_OK];\n\n\tif (params.offchan && !(rdev->wiphy.flags & WIPHY_FLAG_OFFCHAN_TX))\n\t\treturn -EINVAL;\n\n\tparams.no_cck = nla_get_flag(info->attrs[NL80211_ATTR_TX_NO_CCK_RATE]);\n\n\t \n\tchandef.chan = NULL;\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!chandef.chan && params.offchan)\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\tif (params.offchan &&\n\t    !cfg80211_off_channel_oper_allowed(wdev, chandef.chan)) {\n\t\twdev_unlock(wdev);\n\t\treturn -EBUSY;\n\t}\n\n\tparams.link_id = nl80211_link_id_or_invalid(info->attrs);\n\t \n\tif (params.link_id >= 0 &&\n\t    !(wdev->valid_links & BIT(params.link_id))) {\n\t\twdev_unlock(wdev);\n\t\treturn -EINVAL;\n\t}\n\twdev_unlock(wdev);\n\n\tparams.buf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tparams.len = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\n\tif (info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]) {\n\t\tint len = nla_len(info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]);\n\t\tint i;\n\n\t\tif (len % sizeof(u16))\n\t\t\treturn -EINVAL;\n\n\t\tparams.n_csa_offsets = len / sizeof(u16);\n\t\tparams.csa_offsets =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_CSA_C_OFFSETS_TX]);\n\n\t\t \n\t\tfor (i = 0; i < params.n_csa_offsets; i++) {\n\t\t\tif (params.csa_offsets[i] >= params.len)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!params.dont_wait_for_ack) {\n\t\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\t\tif (!msg)\n\t\t\treturn -ENOMEM;\n\n\t\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t\t     NL80211_CMD_FRAME);\n\t\tif (!hdr) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto free_msg;\n\t\t}\n\t}\n\n\tparams.chan = chandef.chan;\n\terr = cfg80211_mlme_mgmt_tx(rdev, wdev, &params, &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (msg) {\n\t\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t\t      NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\t\treturn genlmsg_reply(msg, info);\n\t}\n\n\treturn 0;\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_tx_mgmt_cancel_wait(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->mgmt_tx_cancel_wait)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tbreak;\n\tcase NL80211_IFTYPE_NAN:\n\t\tif (!wiphy_ext_feature_isset(wdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_SECURE_NAN))\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\treturn rdev_mgmt_tx_cancel_wait(rdev, wdev, cookie);\n}\n\nstatic int nl80211_set_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 ps_state;\n\tbool state;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_PS_STATE])\n\t\treturn -EINVAL;\n\n\tps_state = nla_get_u32(info->attrs[NL80211_ATTR_PS_STATE]);\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tstate = (ps_state == NL80211_PS_ENABLED) ? true : false;\n\n\tif (state == wdev->ps)\n\t\treturn 0;\n\n\terr = rdev_set_power_mgmt(rdev, dev, state, wdev->ps_timeout);\n\tif (!err)\n\t\twdev->ps = state;\n\treturn err;\n}\n\nstatic int nl80211_get_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tenum nl80211_ps_state ps_state;\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_POWER_SAVE);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\tif (wdev->ps)\n\t\tps_state = NL80211_PS_ENABLED;\n\telse\n\t\tps_state = NL80211_PS_DISABLED;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_PS_STATE, ps_state))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic const struct nla_policy\nnl80211_attr_cqm_policy[NL80211_ATTR_CQM_MAX + 1] = {\n\t[NL80211_ATTR_CQM_RSSI_THOLD] = { .type = NLA_BINARY },\n\t[NL80211_ATTR_CQM_RSSI_HYST] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_RATE] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_PKTS] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_TXE_INTVL] = { .type = NLA_U32 },\n\t[NL80211_ATTR_CQM_RSSI_LEVEL] = { .type = NLA_S32 },\n};\n\nstatic int nl80211_set_cqm_txe(struct genl_info *info,\n\t\t\t       u32 rate, u32 pkts, u32 intvl)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (rate > 100 || intvl > NL80211_CQM_TXE_MAX_INTVL)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_cqm_txe_config)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\treturn rdev_set_cqm_txe_config(rdev, dev, rate, pkts, intvl);\n}\n\nstatic int cfg80211_cqm_rssi_update(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    struct cfg80211_cqm_config *cqm_config)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\ts32 last, low, high;\n\tu32 hyst;\n\tint i, n, low_index;\n\tint err;\n\n\t \n\tif (!cqm_config->last_rssi_event_value &&\n\t    wdev->links[0].client.current_bss &&\n\t    rdev->ops->get_station) {\n\t\tstruct station_info sinfo = {};\n\t\tu8 *mac_addr;\n\n\t\tmac_addr = wdev->links[0].client.current_bss->pub.bssid;\n\n\t\terr = rdev_get_station(rdev, dev, mac_addr, &sinfo);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcfg80211_sinfo_release_content(&sinfo);\n\t\tif (sinfo.filled & BIT_ULL(NL80211_STA_INFO_BEACON_SIGNAL_AVG))\n\t\t\tcqm_config->last_rssi_event_value =\n\t\t\t\t(s8) sinfo.rx_beacon_signal_avg;\n\t}\n\n\tlast = cqm_config->last_rssi_event_value;\n\thyst = cqm_config->rssi_hyst;\n\tn = cqm_config->n_rssi_thresholds;\n\n\tfor (i = 0; i < n; i++) {\n\t\ti = array_index_nospec(i, n);\n\t\tif (last < cqm_config->rssi_thresholds[i])\n\t\t\tbreak;\n\t}\n\n\tlow_index = i - 1;\n\tif (low_index >= 0) {\n\t\tlow_index = array_index_nospec(low_index, n);\n\t\tlow = cqm_config->rssi_thresholds[low_index] - hyst;\n\t} else {\n\t\tlow = S32_MIN;\n\t}\n\tif (i < n) {\n\t\ti = array_index_nospec(i, n);\n\t\thigh = cqm_config->rssi_thresholds[i] + hyst - 1;\n\t} else {\n\t\thigh = S32_MAX;\n\t}\n\n\treturn rdev_set_cqm_rssi_range_config(rdev, dev, low, high);\n}\n\nstatic int nl80211_set_cqm_rssi(struct genl_info *info,\n\t\t\t\tconst s32 *thresholds, int n_thresholds,\n\t\t\t\tu32 hysteresis)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_cqm_config *cqm_config = NULL, *old;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint i, err;\n\ts32 prev = S32_MIN;\n\n\t \n\tfor (i = 0; i < n_thresholds; i++) {\n\t\tif (thresholds[i] > 0 || thresholds[i] <= prev)\n\t\t\treturn -EINVAL;\n\n\t\tprev = thresholds[i];\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (n_thresholds == 1 && thresholds[0] == 0)  \n\t\tn_thresholds = 0;\n\n\twdev_lock(wdev);\n\told = rcu_dereference_protected(wdev->cqm_config,\n\t\t\t\t\tlockdep_is_held(&wdev->mtx));\n\n\t \n\tif (!n_thresholds && !old) {\n\t\terr = 0;\n\t\tgoto unlock;\n\t}\n\n\tif (n_thresholds > 1) {\n\t\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t     NL80211_EXT_FEATURE_CQM_RSSI_LIST) ||\n\t\t    !rdev->ops->set_cqm_rssi_range_config) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unlock;\n\t\t}\n\t} else {\n\t\tif (!rdev->ops->set_cqm_rssi_config) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (n_thresholds) {\n\t\tcqm_config = kzalloc(struct_size(cqm_config, rssi_thresholds,\n\t\t\t\t\t\t n_thresholds),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!cqm_config) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tcqm_config->rssi_hyst = hysteresis;\n\t\tcqm_config->n_rssi_thresholds = n_thresholds;\n\t\tmemcpy(cqm_config->rssi_thresholds, thresholds,\n\t\t       flex_array_size(cqm_config, rssi_thresholds,\n\t\t\t\t       n_thresholds));\n\t\tcqm_config->use_range_api = n_thresholds > 1 ||\n\t\t\t\t\t    !rdev->ops->set_cqm_rssi_config;\n\n\t\trcu_assign_pointer(wdev->cqm_config, cqm_config);\n\n\t\tif (cqm_config->use_range_api)\n\t\t\terr = cfg80211_cqm_rssi_update(rdev, dev, cqm_config);\n\t\telse\n\t\t\terr = rdev_set_cqm_rssi_config(rdev, dev,\n\t\t\t\t\t\t       thresholds[0],\n\t\t\t\t\t\t       hysteresis);\n\t} else {\n\t\tRCU_INIT_POINTER(wdev->cqm_config, NULL);\n\t\t \n\t\tif (old->use_range_api)\n\t\t\terr = rdev_set_cqm_rssi_range_config(rdev, dev, 0, 0);\n\t\telse\n\t\t\terr = rdev_set_cqm_rssi_config(rdev, dev, 0, 0);\n\t}\n\n\tif (err) {\n\t\trcu_assign_pointer(wdev->cqm_config, old);\n\t\tkfree_rcu(cqm_config, rcu_head);\n\t} else {\n\t\tkfree_rcu(old, rcu_head);\n\t}\nunlock:\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_set_cqm(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *attrs[NL80211_ATTR_CQM_MAX + 1];\n\tstruct nlattr *cqm;\n\tint err;\n\n\tcqm = info->attrs[NL80211_ATTR_CQM];\n\tif (!cqm)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(attrs, NL80211_ATTR_CQM_MAX, cqm,\n\t\t\t\t\t  nl80211_attr_cqm_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (attrs[NL80211_ATTR_CQM_RSSI_THOLD] &&\n\t    attrs[NL80211_ATTR_CQM_RSSI_HYST]) {\n\t\tconst s32 *thresholds =\n\t\t\tnla_data(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);\n\t\tint len = nla_len(attrs[NL80211_ATTR_CQM_RSSI_THOLD]);\n\t\tu32 hysteresis = nla_get_u32(attrs[NL80211_ATTR_CQM_RSSI_HYST]);\n\n\t\tif (len % 4)\n\t\t\treturn -EINVAL;\n\n\t\treturn nl80211_set_cqm_rssi(info, thresholds, len / 4,\n\t\t\t\t\t    hysteresis);\n\t}\n\n\tif (attrs[NL80211_ATTR_CQM_TXE_RATE] &&\n\t    attrs[NL80211_ATTR_CQM_TXE_PKTS] &&\n\t    attrs[NL80211_ATTR_CQM_TXE_INTVL]) {\n\t\tu32 rate = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_RATE]);\n\t\tu32 pkts = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_PKTS]);\n\t\tu32 intvl = nla_get_u32(attrs[NL80211_ATTR_CQM_TXE_INTVL]);\n\n\t\treturn nl80211_set_cqm_txe(info, rate, pkts, intvl);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int nl80211_join_ocb(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct ocb_setup setup = {};\n\tint err;\n\n\terr = nl80211_parse_chandef(rdev, info, &setup.chandef);\n\tif (err)\n\t\treturn err;\n\n\treturn cfg80211_join_ocb(rdev, dev, &setup);\n}\n\nstatic int nl80211_leave_ocb(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_leave_ocb(rdev, dev);\n}\n\nstatic int nl80211_join_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct mesh_config cfg;\n\tstruct mesh_setup setup;\n\tint err;\n\n\t \n\tmemcpy(&cfg, &default_mesh_config, sizeof(cfg));\n\tmemcpy(&setup, &default_mesh_setup, sizeof(setup));\n\n\tif (info->attrs[NL80211_ATTR_MESH_CONFIG]) {\n\t\t \n\t\terr = nl80211_parse_mesh_config(info, &cfg, NULL);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MESH_ID] ||\n\t    !nla_len(info->attrs[NL80211_ATTR_MESH_ID]))\n\t\treturn -EINVAL;\n\n\tsetup.mesh_id = nla_data(info->attrs[NL80211_ATTR_MESH_ID]);\n\tsetup.mesh_id_len = nla_len(info->attrs[NL80211_ATTR_MESH_ID]);\n\n\tif (info->attrs[NL80211_ATTR_MCAST_RATE] &&\n\t    !nl80211_parse_mcast_rate(rdev, setup.mcast_rate,\n\t\t\t    nla_get_u32(info->attrs[NL80211_ATTR_MCAST_RATE])))\n\t\t\treturn -EINVAL;\n\n\tif (info->attrs[NL80211_ATTR_BEACON_INTERVAL]) {\n\t\tsetup.beacon_interval =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_BEACON_INTERVAL]);\n\n\t\terr = cfg80211_validate_beacon_int(rdev,\n\t\t\t\t\t\t   NL80211_IFTYPE_MESH_POINT,\n\t\t\t\t\t\t   setup.beacon_interval);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_DTIM_PERIOD]) {\n\t\tsetup.dtim_period =\n\t\t\tnla_get_u32(info->attrs[NL80211_ATTR_DTIM_PERIOD]);\n\t\tif (setup.dtim_period < 1 || setup.dtim_period > 100)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_MESH_SETUP]) {\n\t\t \n\t\terr = nl80211_parse_mesh_setup(info, &setup);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (setup.user_mpm)\n\t\tcfg.auto_open_plinks = false;\n\n\tif (info->attrs[NL80211_ATTR_WIPHY_FREQ]) {\n\t\terr = nl80211_parse_chandef(rdev, info, &setup.chandef);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\t \n\t\tsetup.chandef.chan = NULL;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BSS_BASIC_RATES]) {\n\t\tu8 *rates = nla_data(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tint n_rates =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_BSS_BASIC_RATES]);\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tif (!setup.chandef.chan)\n\t\t\treturn -EINVAL;\n\n\t\tsband = rdev->wiphy.bands[setup.chandef.chan->band];\n\n\t\terr = ieee80211_get_ratemask(sband, rates, n_rates,\n\t\t\t\t\t     &setup.basic_rates);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_TX_RATES]) {\n\t\terr = nl80211_parse_tx_bitrate_mask(info, info->attrs,\n\t\t\t\t\t\t    NL80211_ATTR_TX_RATES,\n\t\t\t\t\t\t    &setup.beacon_rate,\n\t\t\t\t\t\t    dev, false, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!setup.chandef.chan)\n\t\t\treturn -EINVAL;\n\n\t\terr = validate_beacon_tx_rate(rdev, setup.chandef.chan->band,\n\t\t\t\t\t      &setup.beacon_rate);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tsetup.userspace_handles_dfs =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_HANDLE_DFS]);\n\n\tif (info->attrs[NL80211_ATTR_CONTROL_PORT_OVER_NL80211]) {\n\t\tint r = validate_pae_over_nl80211(rdev, info);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tsetup.control_port_over_nl80211 = true;\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = __cfg80211_join_mesh(rdev, dev, &setup, &cfg);\n\tif (!err && info->attrs[NL80211_ATTR_SOCKET_OWNER])\n\t\tdev->ieee80211_ptr->conn_owner_nlportid = info->snd_portid;\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int nl80211_leave_mesh(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\n\treturn cfg80211_leave_mesh(rdev, dev);\n}\n\n#ifdef CONFIG_PM\nstatic int nl80211_send_wowlan_patterns(struct sk_buff *msg,\n\t\t\t\t\tstruct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_wowlan *wowlan = rdev->wiphy.wowlan_config;\n\tstruct nlattr *nl_pats, *nl_pat;\n\tint i, pat_len;\n\n\tif (!wowlan->n_patterns)\n\t\treturn 0;\n\n\tnl_pats = nla_nest_start_noflag(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN);\n\tif (!nl_pats)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < wowlan->n_patterns; i++) {\n\t\tnl_pat = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_pat)\n\t\t\treturn -ENOBUFS;\n\t\tpat_len = wowlan->patterns[i].pattern_len;\n\t\tif (nla_put(msg, NL80211_PKTPAT_MASK, DIV_ROUND_UP(pat_len, 8),\n\t\t\t    wowlan->patterns[i].mask) ||\n\t\t    nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,\n\t\t\t    wowlan->patterns[i].pattern) ||\n\t\t    nla_put_u32(msg, NL80211_PKTPAT_OFFSET,\n\t\t\t\twowlan->patterns[i].pkt_offset))\n\t\t\treturn -ENOBUFS;\n\t\tnla_nest_end(msg, nl_pat);\n\t}\n\tnla_nest_end(msg, nl_pats);\n\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan_tcp(struct sk_buff *msg,\n\t\t\t\t   struct cfg80211_wowlan_tcp *tcp)\n{\n\tstruct nlattr *nl_tcp;\n\n\tif (!tcp)\n\t\treturn 0;\n\n\tnl_tcp = nla_nest_start_noflag(msg,\n\t\t\t\t       NL80211_WOWLAN_TRIG_TCP_CONNECTION);\n\tif (!nl_tcp)\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_in_addr(msg, NL80211_WOWLAN_TCP_SRC_IPV4, tcp->src) ||\n\t    nla_put_in_addr(msg, NL80211_WOWLAN_TCP_DST_IPV4, tcp->dst) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DST_MAC, ETH_ALEN, tcp->dst_mac) ||\n\t    nla_put_u16(msg, NL80211_WOWLAN_TCP_SRC_PORT, tcp->src_port) ||\n\t    nla_put_u16(msg, NL80211_WOWLAN_TCP_DST_PORT, tcp->dst_port) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD,\n\t\t    tcp->payload_len, tcp->payload) ||\n\t    nla_put_u32(msg, NL80211_WOWLAN_TCP_DATA_INTERVAL,\n\t\t\ttcp->data_interval) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_WAKE_PAYLOAD,\n\t\t    tcp->wake_len, tcp->wake_data) ||\n\t    nla_put(msg, NL80211_WOWLAN_TCP_WAKE_MASK,\n\t\t    DIV_ROUND_UP(tcp->wake_len, 8), tcp->wake_mask))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->payload_seq.len &&\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ,\n\t\t    sizeof(tcp->payload_seq), &tcp->payload_seq))\n\t\treturn -ENOBUFS;\n\n\tif (tcp->payload_tok.len &&\n\t    nla_put(msg, NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN,\n\t\t    sizeof(tcp->payload_tok) + tcp->tokens_size,\n\t\t    &tcp->payload_tok))\n\t\treturn -ENOBUFS;\n\n\tnla_nest_end(msg, nl_tcp);\n\n\treturn 0;\n}\n\nstatic int nl80211_send_wowlan_nd(struct sk_buff *msg,\n\t\t\t\t  struct cfg80211_sched_scan_request *req)\n{\n\tstruct nlattr *nd, *freqs, *matches, *match, *scan_plans, *scan_plan;\n\tint i;\n\n\tif (!req)\n\t\treturn 0;\n\n\tnd = nla_nest_start_noflag(msg, NL80211_WOWLAN_TRIG_NET_DETECT);\n\tif (!nd)\n\t\treturn -ENOBUFS;\n\n\tif (req->n_scan_plans == 1 &&\n\t    nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_INTERVAL,\n\t\t\treq->scan_plans[0].interval * 1000))\n\t\treturn -ENOBUFS;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_SCHED_SCAN_DELAY, req->delay))\n\t\treturn -ENOBUFS;\n\n\tif (req->relative_rssi_set) {\n\t\tstruct nl80211_bss_select_rssi_adjust rssi_adjust;\n\n\t\tif (nla_put_s8(msg, NL80211_ATTR_SCHED_SCAN_RELATIVE_RSSI,\n\t\t\t       req->relative_rssi))\n\t\t\treturn -ENOBUFS;\n\n\t\trssi_adjust.band = req->rssi_adjust.band;\n\t\trssi_adjust.delta = req->rssi_adjust.delta;\n\t\tif (nla_put(msg, NL80211_ATTR_SCHED_SCAN_RSSI_ADJUST,\n\t\t\t    sizeof(rssi_adjust), &rssi_adjust))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tfreqs = nla_nest_start_noflag(msg, NL80211_ATTR_SCAN_FREQUENCIES);\n\tif (!freqs)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < req->n_channels; i++) {\n\t\tif (nla_put_u32(msg, i, req->channels[i]->center_freq))\n\t\t\treturn -ENOBUFS;\n\t}\n\n\tnla_nest_end(msg, freqs);\n\n\tif (req->n_match_sets) {\n\t\tmatches = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_SCHED_SCAN_MATCH);\n\t\tif (!matches)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (i = 0; i < req->n_match_sets; i++) {\n\t\t\tmatch = nla_nest_start_noflag(msg, i);\n\t\t\tif (!match)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tif (nla_put(msg, NL80211_SCHED_SCAN_MATCH_ATTR_SSID,\n\t\t\t\t    req->match_sets[i].ssid.ssid_len,\n\t\t\t\t    req->match_sets[i].ssid.ssid))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tnla_nest_end(msg, match);\n\t\t}\n\t\tnla_nest_end(msg, matches);\n\t}\n\n\tscan_plans = nla_nest_start_noflag(msg, NL80211_ATTR_SCHED_SCAN_PLANS);\n\tif (!scan_plans)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < req->n_scan_plans; i++) {\n\t\tscan_plan = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!scan_plan)\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put_u32(msg, NL80211_SCHED_SCAN_PLAN_INTERVAL,\n\t\t\t\treq->scan_plans[i].interval) ||\n\t\t    (req->scan_plans[i].iterations &&\n\t\t     nla_put_u32(msg, NL80211_SCHED_SCAN_PLAN_ITERATIONS,\n\t\t\t\t req->scan_plans[i].iterations)))\n\t\t\treturn -ENOBUFS;\n\t\tnla_nest_end(msg, scan_plan);\n\t}\n\tnla_nest_end(msg, scan_plans);\n\n\tnla_nest_end(msg, nd);\n\n\treturn 0;\n}\n\nstatic int nl80211_get_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 size = NLMSG_DEFAULT_SIZE;\n\n\tif (!rdev->wiphy.wowlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->wiphy.wowlan_config && rdev->wiphy.wowlan_config->tcp) {\n\t\t \n\t\tsize += rdev->wiphy.wowlan_config->tcp->tokens_size +\n\t\t\trdev->wiphy.wowlan_config->tcp->payload_len +\n\t\t\trdev->wiphy.wowlan_config->tcp->wake_len +\n\t\t\trdev->wiphy.wowlan_config->tcp->wake_len / 8;\n\t}\n\n\tmsg = nlmsg_new(size, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_WOWLAN);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (rdev->wiphy.wowlan_config) {\n\t\tstruct nlattr *nl_wowlan;\n\n\t\tnl_wowlan = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t  NL80211_ATTR_WOWLAN_TRIGGERS);\n\t\tif (!nl_wowlan)\n\t\t\tgoto nla_put_failure;\n\n\t\tif ((rdev->wiphy.wowlan_config->any &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_ANY)) ||\n\t\t    (rdev->wiphy.wowlan_config->disconnect &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT)) ||\n\t\t    (rdev->wiphy.wowlan_config->magic_pkt &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT)) ||\n\t\t    (rdev->wiphy.wowlan_config->gtk_rekey_failure &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE)) ||\n\t\t    (rdev->wiphy.wowlan_config->eap_identity_req &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST)) ||\n\t\t    (rdev->wiphy.wowlan_config->four_way_handshake &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE)) ||\n\t\t    (rdev->wiphy.wowlan_config->rfkill_release &&\n\t\t     nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE)))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_patterns(msg, rdev))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_tcp(msg,\n\t\t\t\t\t    rdev->wiphy.wowlan_config->tcp))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nl80211_send_wowlan_nd(\n\t\t\t    msg,\n\t\t\t    rdev->wiphy.wowlan_config->nd_config))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nl_wowlan);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_parse_wowlan_tcp(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct nlattr *attr,\n\t\t\t\t    struct cfg80211_wowlan *trig)\n{\n\tstruct nlattr *tb[NUM_NL80211_WOWLAN_TCP];\n\tstruct cfg80211_wowlan_tcp *cfg;\n\tstruct nl80211_wowlan_tcp_data_token *tok = NULL;\n\tstruct nl80211_wowlan_tcp_data_seq *seq = NULL;\n\tu32 size;\n\tu32 data_size, wake_size, tokens_size = 0, wake_mask_size;\n\tint err, port;\n\n\tif (!rdev->wiphy.wowlan->tcp)\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_WOWLAN_TCP, attr,\n\t\t\t\t\t  nl80211_wowlan_tcp_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_WOWLAN_TCP_SRC_IPV4] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_IPV4] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_MAC] ||\n\t    !tb[NL80211_WOWLAN_TCP_DST_PORT] ||\n\t    !tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD] ||\n\t    !tb[NL80211_WOWLAN_TCP_DATA_INTERVAL] ||\n\t    !tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD] ||\n\t    !tb[NL80211_WOWLAN_TCP_WAKE_MASK])\n\t\treturn -EINVAL;\n\n\tdata_size = nla_len(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD]);\n\tif (data_size > rdev->wiphy.wowlan->tcp->data_payload_max)\n\t\treturn -EINVAL;\n\n\tif (nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]) >\n\t\t\trdev->wiphy.wowlan->tcp->data_interval_max ||\n\t    nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]) == 0)\n\t\treturn -EINVAL;\n\n\twake_size = nla_len(tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD]);\n\tif (wake_size > rdev->wiphy.wowlan->tcp->wake_payload_max)\n\t\treturn -EINVAL;\n\n\twake_mask_size = nla_len(tb[NL80211_WOWLAN_TCP_WAKE_MASK]);\n\tif (wake_mask_size != DIV_ROUND_UP(wake_size, 8))\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]) {\n\t\tu32 tokln = nla_len(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]);\n\n\t\ttok = nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_TOKEN]);\n\t\ttokens_size = tokln - sizeof(*tok);\n\n\t\tif (!tok->len || tokens_size % tok->len)\n\t\t\treturn -EINVAL;\n\t\tif (!rdev->wiphy.wowlan->tcp->tok)\n\t\t\treturn -EINVAL;\n\t\tif (tok->len > rdev->wiphy.wowlan->tcp->tok->max_len)\n\t\t\treturn -EINVAL;\n\t\tif (tok->len < rdev->wiphy.wowlan->tcp->tok->min_len)\n\t\t\treturn -EINVAL;\n\t\tif (tokens_size > rdev->wiphy.wowlan->tcp->tok->bufsize)\n\t\t\treturn -EINVAL;\n\t\tif (tok->offset + tok->len > data_size)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ]) {\n\t\tseq = nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD_SEQ]);\n\t\tif (!rdev->wiphy.wowlan->tcp->seq)\n\t\t\treturn -EINVAL;\n\t\tif (seq->len == 0 || seq->len > 4)\n\t\t\treturn -EINVAL;\n\t\tif (seq->len + seq->offset > data_size)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsize = sizeof(*cfg);\n\tsize += data_size;\n\tsize += wake_size + wake_mask_size;\n\tsize += tokens_size;\n\n\tcfg = kzalloc(size, GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\tcfg->src = nla_get_in_addr(tb[NL80211_WOWLAN_TCP_SRC_IPV4]);\n\tcfg->dst = nla_get_in_addr(tb[NL80211_WOWLAN_TCP_DST_IPV4]);\n\tmemcpy(cfg->dst_mac, nla_data(tb[NL80211_WOWLAN_TCP_DST_MAC]),\n\t       ETH_ALEN);\n\tif (tb[NL80211_WOWLAN_TCP_SRC_PORT])\n\t\tport = nla_get_u16(tb[NL80211_WOWLAN_TCP_SRC_PORT]);\n\telse\n\t\tport = 0;\n#ifdef CONFIG_INET\n\t \n\terr = __sock_create(wiphy_net(&rdev->wiphy), PF_INET, SOCK_STREAM,\n\t\t\t    IPPROTO_TCP, &cfg->sock, 1);\n\tif (err) {\n\t\tkfree(cfg);\n\t\treturn err;\n\t}\n\tif (inet_csk_get_port(cfg->sock->sk, port)) {\n\t\tsock_release(cfg->sock);\n\t\tkfree(cfg);\n\t\treturn -EADDRINUSE;\n\t}\n\tcfg->src_port = inet_sk(cfg->sock->sk)->inet_num;\n#else\n\tif (!port) {\n\t\tkfree(cfg);\n\t\treturn -EINVAL;\n\t}\n\tcfg->src_port = port;\n#endif\n\n\tcfg->dst_port = nla_get_u16(tb[NL80211_WOWLAN_TCP_DST_PORT]);\n\tcfg->payload_len = data_size;\n\tcfg->payload = (u8 *)cfg + sizeof(*cfg) + tokens_size;\n\tmemcpy((void *)cfg->payload,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_DATA_PAYLOAD]),\n\t       data_size);\n\tif (seq)\n\t\tcfg->payload_seq = *seq;\n\tcfg->data_interval = nla_get_u32(tb[NL80211_WOWLAN_TCP_DATA_INTERVAL]);\n\tcfg->wake_len = wake_size;\n\tcfg->wake_data = (u8 *)cfg + sizeof(*cfg) + tokens_size + data_size;\n\tmemcpy((void *)cfg->wake_data,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_WAKE_PAYLOAD]),\n\t       wake_size);\n\tcfg->wake_mask = (u8 *)cfg + sizeof(*cfg) + tokens_size +\n\t\t\t data_size + wake_size;\n\tmemcpy((void *)cfg->wake_mask,\n\t       nla_data(tb[NL80211_WOWLAN_TCP_WAKE_MASK]),\n\t       wake_mask_size);\n\tif (tok) {\n\t\tcfg->tokens_size = tokens_size;\n\t\tcfg->payload_tok = *tok;\n\t\tmemcpy(cfg->payload_tok.token_stream, tok->token_stream,\n\t\t       tokens_size);\n\t}\n\n\ttrig->tcp = cfg;\n\n\treturn 0;\n}\n\nstatic int nl80211_parse_wowlan_nd(struct cfg80211_registered_device *rdev,\n\t\t\t\t   const struct wiphy_wowlan_support *wowlan,\n\t\t\t\t   struct nlattr *attr,\n\t\t\t\t   struct cfg80211_wowlan *trig)\n{\n\tstruct nlattr **tb;\n\tint err;\n\n\ttb = kcalloc(NUM_NL80211_ATTR, sizeof(*tb), GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tif (!(wowlan->flags & WIPHY_WOWLAN_NET_DETECT)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_ATTR_MAX, attr,\n\t\t\t\t\t  nl80211_policy, NULL);\n\tif (err)\n\t\tgoto out;\n\n\ttrig->nd_config = nl80211_parse_sched_scan(&rdev->wiphy, NULL, tb,\n\t\t\t\t\t\t   wowlan->max_nd_match_sets);\n\terr = PTR_ERR_OR_ZERO(trig->nd_config);\n\tif (err)\n\t\ttrig->nd_config = NULL;\n\nout:\n\tkfree(tb);\n\treturn err;\n}\n\nstatic int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *tb[NUM_NL80211_WOWLAN_TRIG];\n\tstruct cfg80211_wowlan new_triggers = {};\n\tstruct cfg80211_wowlan *ntrig;\n\tconst struct wiphy_wowlan_support *wowlan = rdev->wiphy.wowlan;\n\tint err, i;\n\tbool prev_enabled = rdev->wiphy.wowlan_config;\n\tbool regular = false;\n\n\tif (!wowlan)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS]) {\n\t\tcfg80211_rdev_free_wowlan(rdev);\n\t\trdev->wiphy.wowlan_config = NULL;\n\t\tgoto set_wakeup;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_WOWLAN_TRIG,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_WOWLAN_TRIGGERS],\n\t\t\t\t\t  nl80211_wowlan_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_WOWLAN_TRIG_ANY]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_ANY))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.any = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_DISCONNECT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_DISCONNECT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.disconnect = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_MAGIC_PKT]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_MAGIC_PKT))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.magic_pkt = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED])\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.gtk_rekey_failure = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.eap_identity_req = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.four_way_handshake = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_RFKILL_RELEASE]) {\n\t\tif (!(wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE))\n\t\t\treturn -EINVAL;\n\t\tnew_triggers.rfkill_release = true;\n\t\tregular = true;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_PKT_PATTERN]) {\n\t\tstruct nlattr *pat;\n\t\tint n_patterns = 0;\n\t\tint rem, pat_len, mask_len, pkt_offset;\n\t\tstruct nlattr *pat_tb[NUM_NL80211_PKTPAT];\n\n\t\tregular = true;\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem)\n\t\t\tn_patterns++;\n\t\tif (n_patterns > wowlan->n_patterns)\n\t\t\treturn -EINVAL;\n\n\t\tnew_triggers.patterns = kcalloc(n_patterns,\n\t\t\t\t\t\tsizeof(new_triggers.patterns[0]),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!new_triggers.patterns)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_triggers.n_patterns = n_patterns;\n\t\ti = 0;\n\n\t\tnla_for_each_nested(pat, tb[NL80211_WOWLAN_TRIG_PKT_PATTERN],\n\t\t\t\t    rem) {\n\t\t\tu8 *mask_pat;\n\n\t\t\terr = nla_parse_nested_deprecated(pat_tb,\n\t\t\t\t\t\t\t  MAX_NL80211_PKTPAT,\n\t\t\t\t\t\t\t  pat,\n\t\t\t\t\t\t\t  nl80211_packet_pattern_policy,\n\t\t\t\t\t\t\t  info->extack);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\n\t\t\terr = -EINVAL;\n\t\t\tif (!pat_tb[NL80211_PKTPAT_MASK] ||\n\t\t\t    !pat_tb[NL80211_PKTPAT_PATTERN])\n\t\t\t\tgoto error;\n\t\t\tpat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);\n\t\t\tmask_len = DIV_ROUND_UP(pat_len, 8);\n\t\t\tif (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)\n\t\t\t\tgoto error;\n\t\t\tif (pat_len > wowlan->pattern_max_len ||\n\t\t\t    pat_len < wowlan->pattern_min_len)\n\t\t\t\tgoto error;\n\n\t\t\tif (!pat_tb[NL80211_PKTPAT_OFFSET])\n\t\t\t\tpkt_offset = 0;\n\t\t\telse\n\t\t\t\tpkt_offset = nla_get_u32(\n\t\t\t\t\tpat_tb[NL80211_PKTPAT_OFFSET]);\n\t\t\tif (pkt_offset > wowlan->max_pkt_offset)\n\t\t\t\tgoto error;\n\t\t\tnew_triggers.patterns[i].pkt_offset = pkt_offset;\n\n\t\t\tmask_pat = kmalloc(mask_len + pat_len, GFP_KERNEL);\n\t\t\tif (!mask_pat) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tnew_triggers.patterns[i].mask = mask_pat;\n\t\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_MASK]),\n\t\t\t       mask_len);\n\t\t\tmask_pat += mask_len;\n\t\t\tnew_triggers.patterns[i].pattern = mask_pat;\n\t\t\tnew_triggers.patterns[i].pattern_len = pat_len;\n\t\t\tmemcpy(mask_pat,\n\t\t\t       nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),\n\t\t\t       pat_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_TCP_CONNECTION]) {\n\t\tregular = true;\n\t\terr = nl80211_parse_wowlan_tcp(\n\t\t\trdev, tb[NL80211_WOWLAN_TRIG_TCP_CONNECTION],\n\t\t\t&new_triggers);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\tif (tb[NL80211_WOWLAN_TRIG_NET_DETECT]) {\n\t\tregular = true;\n\t\terr = nl80211_parse_wowlan_nd(\n\t\t\trdev, wowlan, tb[NL80211_WOWLAN_TRIG_NET_DETECT],\n\t\t\t&new_triggers);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\t \n\tif (new_triggers.any && regular) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tntrig = kmemdup(&new_triggers, sizeof(new_triggers), GFP_KERNEL);\n\tif (!ntrig) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tcfg80211_rdev_free_wowlan(rdev);\n\trdev->wiphy.wowlan_config = ntrig;\n\n set_wakeup:\n\tif (rdev->ops->set_wakeup &&\n\t    prev_enabled != !!rdev->wiphy.wowlan_config)\n\t\trdev_set_wakeup(rdev, rdev->wiphy.wowlan_config);\n\n\treturn 0;\n error:\n\tfor (i = 0; i < new_triggers.n_patterns; i++)\n\t\tkfree(new_triggers.patterns[i].mask);\n\tkfree(new_triggers.patterns);\n\tif (new_triggers.tcp && new_triggers.tcp->sock)\n\t\tsock_release(new_triggers.tcp->sock);\n\tkfree(new_triggers.tcp);\n\tkfree(new_triggers.nd_config);\n\treturn err;\n}\n#endif\n\nstatic int nl80211_send_coalesce_rules(struct sk_buff *msg,\n\t\t\t\t       struct cfg80211_registered_device *rdev)\n{\n\tstruct nlattr *nl_pats, *nl_pat, *nl_rule, *nl_rules;\n\tint i, j, pat_len;\n\tstruct cfg80211_coalesce_rules *rule;\n\n\tif (!rdev->coalesce->n_rules)\n\t\treturn 0;\n\n\tnl_rules = nla_nest_start_noflag(msg, NL80211_ATTR_COALESCE_RULE);\n\tif (!nl_rules)\n\t\treturn -ENOBUFS;\n\n\tfor (i = 0; i < rdev->coalesce->n_rules; i++) {\n\t\tnl_rule = nla_nest_start_noflag(msg, i + 1);\n\t\tif (!nl_rule)\n\t\t\treturn -ENOBUFS;\n\n\t\trule = &rdev->coalesce->rules[i];\n\t\tif (nla_put_u32(msg, NL80211_ATTR_COALESCE_RULE_DELAY,\n\t\t\t\trule->delay))\n\t\t\treturn -ENOBUFS;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_COALESCE_RULE_CONDITION,\n\t\t\t\trule->condition))\n\t\t\treturn -ENOBUFS;\n\n\t\tnl_pats = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_COALESCE_RULE_PKT_PATTERN);\n\t\tif (!nl_pats)\n\t\t\treturn -ENOBUFS;\n\n\t\tfor (j = 0; j < rule->n_patterns; j++) {\n\t\t\tnl_pat = nla_nest_start_noflag(msg, j + 1);\n\t\t\tif (!nl_pat)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tpat_len = rule->patterns[j].pattern_len;\n\t\t\tif (nla_put(msg, NL80211_PKTPAT_MASK,\n\t\t\t\t    DIV_ROUND_UP(pat_len, 8),\n\t\t\t\t    rule->patterns[j].mask) ||\n\t\t\t    nla_put(msg, NL80211_PKTPAT_PATTERN, pat_len,\n\t\t\t\t    rule->patterns[j].pattern) ||\n\t\t\t    nla_put_u32(msg, NL80211_PKTPAT_OFFSET,\n\t\t\t\t\trule->patterns[j].pkt_offset))\n\t\t\t\treturn -ENOBUFS;\n\t\t\tnla_nest_end(msg, nl_pat);\n\t\t}\n\t\tnla_nest_end(msg, nl_pats);\n\t\tnla_nest_end(msg, nl_rule);\n\t}\n\tnla_nest_end(msg, nl_rules);\n\n\treturn 0;\n}\n\nstatic int nl80211_get_coalesce(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!rdev->wiphy.coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_COALESCE);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (rdev->coalesce && nl80211_send_coalesce_rules(msg, rdev))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nvoid cfg80211_rdev_free_coalesce(struct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_coalesce *coalesce = rdev->coalesce;\n\tint i, j;\n\tstruct cfg80211_coalesce_rules *rule;\n\n\tif (!coalesce)\n\t\treturn;\n\n\tfor (i = 0; i < coalesce->n_rules; i++) {\n\t\trule = &coalesce->rules[i];\n\t\tfor (j = 0; j < rule->n_patterns; j++)\n\t\t\tkfree(rule->patterns[j].mask);\n\t\tkfree(rule->patterns);\n\t}\n\tkfree(coalesce->rules);\n\tkfree(coalesce);\n\trdev->coalesce = NULL;\n}\n\nstatic int nl80211_parse_coalesce_rule(struct cfg80211_registered_device *rdev,\n\t\t\t\t       struct nlattr *rule,\n\t\t\t\t       struct cfg80211_coalesce_rules *new_rule)\n{\n\tint err, i;\n\tconst struct wiphy_coalesce_support *coalesce = rdev->wiphy.coalesce;\n\tstruct nlattr *tb[NUM_NL80211_ATTR_COALESCE_RULE], *pat;\n\tint rem, pat_len, mask_len, pkt_offset, n_patterns = 0;\n\tstruct nlattr *pat_tb[NUM_NL80211_PKTPAT];\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_ATTR_COALESCE_RULE_MAX,\n\t\t\t\t\t  rule, nl80211_coalesce_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (tb[NL80211_ATTR_COALESCE_RULE_DELAY])\n\t\tnew_rule->delay =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_COALESCE_RULE_DELAY]);\n\tif (new_rule->delay > coalesce->max_delay)\n\t\treturn -EINVAL;\n\n\tif (tb[NL80211_ATTR_COALESCE_RULE_CONDITION])\n\t\tnew_rule->condition =\n\t\t\tnla_get_u32(tb[NL80211_ATTR_COALESCE_RULE_CONDITION]);\n\n\tif (!tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN])\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(pat, tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN],\n\t\t\t    rem)\n\t\tn_patterns++;\n\tif (n_patterns > coalesce->n_patterns)\n\t\treturn -EINVAL;\n\n\tnew_rule->patterns = kcalloc(n_patterns, sizeof(new_rule->patterns[0]),\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_rule->patterns)\n\t\treturn -ENOMEM;\n\n\tnew_rule->n_patterns = n_patterns;\n\ti = 0;\n\n\tnla_for_each_nested(pat, tb[NL80211_ATTR_COALESCE_RULE_PKT_PATTERN],\n\t\t\t    rem) {\n\t\tu8 *mask_pat;\n\n\t\terr = nla_parse_nested_deprecated(pat_tb, MAX_NL80211_PKTPAT,\n\t\t\t\t\t\t  pat,\n\t\t\t\t\t\t  nl80211_packet_pattern_policy,\n\t\t\t\t\t\t  NULL);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!pat_tb[NL80211_PKTPAT_MASK] ||\n\t\t    !pat_tb[NL80211_PKTPAT_PATTERN])\n\t\t\treturn -EINVAL;\n\t\tpat_len = nla_len(pat_tb[NL80211_PKTPAT_PATTERN]);\n\t\tmask_len = DIV_ROUND_UP(pat_len, 8);\n\t\tif (nla_len(pat_tb[NL80211_PKTPAT_MASK]) != mask_len)\n\t\t\treturn -EINVAL;\n\t\tif (pat_len > coalesce->pattern_max_len ||\n\t\t    pat_len < coalesce->pattern_min_len)\n\t\t\treturn -EINVAL;\n\n\t\tif (!pat_tb[NL80211_PKTPAT_OFFSET])\n\t\t\tpkt_offset = 0;\n\t\telse\n\t\t\tpkt_offset = nla_get_u32(pat_tb[NL80211_PKTPAT_OFFSET]);\n\t\tif (pkt_offset > coalesce->max_pkt_offset)\n\t\t\treturn -EINVAL;\n\t\tnew_rule->patterns[i].pkt_offset = pkt_offset;\n\n\t\tmask_pat = kmalloc(mask_len + pat_len, GFP_KERNEL);\n\t\tif (!mask_pat)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_rule->patterns[i].mask = mask_pat;\n\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_MASK]),\n\t\t       mask_len);\n\n\t\tmask_pat += mask_len;\n\t\tnew_rule->patterns[i].pattern = mask_pat;\n\t\tnew_rule->patterns[i].pattern_len = pat_len;\n\t\tmemcpy(mask_pat, nla_data(pat_tb[NL80211_PKTPAT_PATTERN]),\n\t\t       pat_len);\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_coalesce(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tconst struct wiphy_coalesce_support *coalesce = rdev->wiphy.coalesce;\n\tstruct cfg80211_coalesce new_coalesce = {};\n\tstruct cfg80211_coalesce *n_coalesce;\n\tint err, rem_rule, n_rules = 0, i, j;\n\tstruct nlattr *rule;\n\tstruct cfg80211_coalesce_rules *tmp_rule;\n\n\tif (!rdev->wiphy.coalesce || !rdev->ops->set_coalesce)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_COALESCE_RULE]) {\n\t\tcfg80211_rdev_free_coalesce(rdev);\n\t\trdev_set_coalesce(rdev, NULL);\n\t\treturn 0;\n\t}\n\n\tnla_for_each_nested(rule, info->attrs[NL80211_ATTR_COALESCE_RULE],\n\t\t\t    rem_rule)\n\t\tn_rules++;\n\tif (n_rules > coalesce->n_rules)\n\t\treturn -EINVAL;\n\n\tnew_coalesce.rules = kcalloc(n_rules, sizeof(new_coalesce.rules[0]),\n\t\t\t\t     GFP_KERNEL);\n\tif (!new_coalesce.rules)\n\t\treturn -ENOMEM;\n\n\tnew_coalesce.n_rules = n_rules;\n\ti = 0;\n\n\tnla_for_each_nested(rule, info->attrs[NL80211_ATTR_COALESCE_RULE],\n\t\t\t    rem_rule) {\n\t\terr = nl80211_parse_coalesce_rule(rdev, rule,\n\t\t\t\t\t\t  &new_coalesce.rules[i]);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\ti++;\n\t}\n\n\terr = rdev_set_coalesce(rdev, &new_coalesce);\n\tif (err)\n\t\tgoto error;\n\n\tn_coalesce = kmemdup(&new_coalesce, sizeof(new_coalesce), GFP_KERNEL);\n\tif (!n_coalesce) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tcfg80211_rdev_free_coalesce(rdev);\n\trdev->coalesce = n_coalesce;\n\n\treturn 0;\nerror:\n\tfor (i = 0; i < new_coalesce.n_rules; i++) {\n\t\ttmp_rule = &new_coalesce.rules[i];\n\t\tfor (j = 0; j < tmp_rule->n_patterns; j++)\n\t\t\tkfree(tmp_rule->patterns[j].mask);\n\t\tkfree(tmp_rule->patterns);\n\t}\n\tkfree(new_coalesce.rules);\n\n\treturn err;\n}\n\nstatic int nl80211_set_rekey_data(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct nlattr *tb[NUM_NL80211_REKEY_DATA];\n\tstruct cfg80211_gtk_rekey_data rekey_data = {};\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_REKEY_DATA])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, MAX_NL80211_REKEY_DATA,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_REKEY_DATA],\n\t\t\t\t\t  nl80211_rekey_policy, info->extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[NL80211_REKEY_DATA_REPLAY_CTR] || !tb[NL80211_REKEY_DATA_KEK] ||\n\t    !tb[NL80211_REKEY_DATA_KCK])\n\t\treturn -EINVAL;\n\tif (nla_len(tb[NL80211_REKEY_DATA_KEK]) != NL80211_KEK_LEN &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_EXT_KEK_KCK &&\n\t      nla_len(tb[NL80211_REKEY_DATA_KEK]) == NL80211_KEK_EXT_LEN))\n\t\treturn -ERANGE;\n\tif (nla_len(tb[NL80211_REKEY_DATA_KCK]) != NL80211_KCK_LEN &&\n\t    !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_EXT_KEK_KCK &&\n\t      nla_len(tb[NL80211_REKEY_DATA_KCK]) == NL80211_KCK_EXT_LEN) &&\n\t     !(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_EXT_KCK_32 &&\n\t       nla_len(tb[NL80211_REKEY_DATA_KCK]) == NL80211_KCK_EXT_LEN_32))\n\t\treturn -ERANGE;\n\n\trekey_data.kek = nla_data(tb[NL80211_REKEY_DATA_KEK]);\n\trekey_data.kck = nla_data(tb[NL80211_REKEY_DATA_KCK]);\n\trekey_data.replay_ctr = nla_data(tb[NL80211_REKEY_DATA_REPLAY_CTR]);\n\trekey_data.kek_len = nla_len(tb[NL80211_REKEY_DATA_KEK]);\n\trekey_data.kck_len = nla_len(tb[NL80211_REKEY_DATA_KCK]);\n\tif (tb[NL80211_REKEY_DATA_AKM])\n\t\trekey_data.akm = nla_get_u32(tb[NL80211_REKEY_DATA_AKM]);\n\n\twdev_lock(wdev);\n\tif (!wdev->connected) {\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tif (!rdev->ops->set_rekey_data) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev_set_rekey_data(rdev, dev, &rekey_data);\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_register_unexpected_frame(struct sk_buff *skb,\n\t\t\t\t\t     struct genl_info *info)\n{\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (wdev->ap_unexpected_nlportid)\n\t\treturn -EBUSY;\n\n\twdev->ap_unexpected_nlportid = info->snd_portid;\n\treturn 0;\n}\n\nstatic int nl80211_probe_client(struct sk_buff *skb,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tconst u8 *addr;\n\tu64 cookie;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->probe_client)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_PROBE_CLIENT);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\terr = rdev_probe_client(rdev, dev, addr, &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int nl80211_register_beacons(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_beacon_registration *reg, *nreg;\n\tint rv;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS))\n\t\treturn -EOPNOTSUPP;\n\n\tnreg = kzalloc(sizeof(*nreg), GFP_KERNEL);\n\tif (!nreg)\n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\tlist_for_each_entry(reg, &rdev->beacon_registrations, list) {\n\t\tif (reg->nlportid == info->snd_portid) {\n\t\t\trv = -EALREADY;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\t \n\tnreg->nlportid = info->snd_portid;\n\tlist_add(&nreg->list, &rdev->beacon_registrations);\n\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\n\treturn 0;\nout_err:\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\tkfree(nreg);\n\treturn rv;\n}\n\nstatic int nl80211_start_p2p_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tint err;\n\n\tif (!rdev->ops->start_p2p_device)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev_running(wdev))\n\t\treturn 0;\n\n\tif (rfkill_blocked(rdev->wiphy.rfkill))\n\t\treturn -ERFKILL;\n\n\terr = rdev_start_p2p_device(rdev, wdev);\n\tif (err)\n\t\treturn err;\n\n\twdev->is_running = true;\n\trdev->opencount++;\n\n\treturn 0;\n}\n\nstatic int nl80211_stop_p2p_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (wdev->iftype != NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->stop_p2p_device)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg80211_stop_p2p_device(rdev, wdev);\n\n\treturn 0;\n}\n\nstatic int nl80211_start_nan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_nan_conf conf = {};\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev_running(wdev))\n\t\treturn -EEXIST;\n\n\tif (rfkill_blocked(rdev->wiphy.rfkill))\n\t\treturn -ERFKILL;\n\n\tif (!info->attrs[NL80211_ATTR_NAN_MASTER_PREF])\n\t\treturn -EINVAL;\n\n\tconf.master_pref =\n\t\tnla_get_u8(info->attrs[NL80211_ATTR_NAN_MASTER_PREF]);\n\n\tif (info->attrs[NL80211_ATTR_BANDS]) {\n\t\tu32 bands = nla_get_u32(info->attrs[NL80211_ATTR_BANDS]);\n\n\t\tif (bands & ~(u32)wdev->wiphy->nan_supported_bands)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (bands && !(bands & BIT(NL80211_BAND_2GHZ)))\n\t\t\treturn -EINVAL;\n\n\t\tconf.bands = bands;\n\t}\n\n\terr = rdev_start_nan(rdev, wdev, &conf);\n\tif (err)\n\t\treturn err;\n\n\twdev->is_running = true;\n\trdev->opencount++;\n\n\treturn 0;\n}\n\nstatic int nl80211_stop_nan(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg80211_stop_nan(rdev, wdev);\n\n\treturn 0;\n}\n\nstatic int validate_nan_filter(struct nlattr *filter_attr)\n{\n\tstruct nlattr *attr;\n\tint len = 0, n_entries = 0, rem;\n\n\tnla_for_each_nested(attr, filter_attr, rem) {\n\t\tlen += nla_len(attr);\n\t\tn_entries++;\n\t}\n\n\tif (len >= U8_MAX)\n\t\treturn -EINVAL;\n\n\treturn n_entries;\n}\n\nstatic int handle_nan_filter(struct nlattr *attr_filter,\n\t\t\t     struct cfg80211_nan_func *func,\n\t\t\t     bool tx)\n{\n\tstruct nlattr *attr;\n\tint n_entries, rem, i;\n\tstruct cfg80211_nan_func_filter *filter;\n\n\tn_entries = validate_nan_filter(attr_filter);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tBUILD_BUG_ON(sizeof(*func->rx_filters) != sizeof(*func->tx_filters));\n\n\tfilter = kcalloc(n_entries, sizeof(*func->rx_filters), GFP_KERNEL);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tnla_for_each_nested(attr, attr_filter, rem) {\n\t\tfilter[i].filter = nla_memdup(attr, GFP_KERNEL);\n\t\tif (!filter[i].filter)\n\t\t\tgoto err;\n\n\t\tfilter[i].len = nla_len(attr);\n\t\ti++;\n\t}\n\tif (tx) {\n\t\tfunc->num_tx_filters = n_entries;\n\t\tfunc->tx_filters = filter;\n\t} else {\n\t\tfunc->num_rx_filters = n_entries;\n\t\tfunc->rx_filters = filter;\n\t}\n\n\treturn 0;\n\nerr:\n\ti = 0;\n\tnla_for_each_nested(attr, attr_filter, rem) {\n\t\tkfree(filter[i].filter);\n\t\ti++;\n\t}\n\tkfree(filter);\n\treturn -ENOMEM;\n}\n\nstatic int nl80211_nan_add_func(struct sk_buff *skb,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct nlattr *tb[NUM_NL80211_NAN_FUNC_ATTR], *func_attr;\n\tstruct cfg80211_nan_func *func;\n\tstruct sk_buff *msg = NULL;\n\tvoid *hdr = NULL;\n\tint err = 0;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (!info->attrs[NL80211_ATTR_NAN_FUNC])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested_deprecated(tb, NL80211_NAN_FUNC_ATTR_MAX,\n\t\t\t\t\t  info->attrs[NL80211_ATTR_NAN_FUNC],\n\t\t\t\t\t  nl80211_nan_func_policy,\n\t\t\t\t\t  info->extack);\n\tif (err)\n\t\treturn err;\n\n\tfunc = kzalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func)\n\t\treturn -ENOMEM;\n\n\tfunc->cookie = cfg80211_assign_cookie(rdev);\n\n\tif (!tb[NL80211_NAN_FUNC_TYPE]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\n\tfunc->type = nla_get_u8(tb[NL80211_NAN_FUNC_TYPE]);\n\n\tif (!tb[NL80211_NAN_FUNC_SERVICE_ID]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(func->service_id, nla_data(tb[NL80211_NAN_FUNC_SERVICE_ID]),\n\t       sizeof(func->service_id));\n\n\tfunc->close_range =\n\t\tnla_get_flag(tb[NL80211_NAN_FUNC_CLOSE_RANGE]);\n\n\tif (tb[NL80211_NAN_FUNC_SERVICE_INFO]) {\n\t\tfunc->serv_spec_info_len =\n\t\t\tnla_len(tb[NL80211_NAN_FUNC_SERVICE_INFO]);\n\t\tfunc->serv_spec_info =\n\t\t\tkmemdup(nla_data(tb[NL80211_NAN_FUNC_SERVICE_INFO]),\n\t\t\t\tfunc->serv_spec_info_len,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!func->serv_spec_info) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_TTL])\n\t\tfunc->ttl = nla_get_u32(tb[NL80211_NAN_FUNC_TTL]);\n\n\tswitch (func->type) {\n\tcase NL80211_NAN_FUNC_PUBLISH:\n\t\tif (!tb[NL80211_NAN_FUNC_PUBLISH_TYPE]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfunc->publish_type =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_PUBLISH_TYPE]);\n\t\tfunc->publish_bcast =\n\t\t\tnla_get_flag(tb[NL80211_NAN_FUNC_PUBLISH_BCAST]);\n\n\t\tif ((!(func->publish_type & NL80211_NAN_SOLICITED_PUBLISH)) &&\n\t\t\tfunc->publish_bcast) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase NL80211_NAN_FUNC_SUBSCRIBE:\n\t\tfunc->subscribe_active =\n\t\t\tnla_get_flag(tb[NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE]);\n\t\tbreak;\n\tcase NL80211_NAN_FUNC_FOLLOW_UP:\n\t\tif (!tb[NL80211_NAN_FUNC_FOLLOW_UP_ID] ||\n\t\t    !tb[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID] ||\n\t\t    !tb[NL80211_NAN_FUNC_FOLLOW_UP_DEST]) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfunc->followup_id =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_FOLLOW_UP_ID]);\n\t\tfunc->followup_reqid =\n\t\t\tnla_get_u8(tb[NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID]);\n\t\tmemcpy(func->followup_dest.addr,\n\t\t       nla_data(tb[NL80211_NAN_FUNC_FOLLOW_UP_DEST]),\n\t\t       sizeof(func->followup_dest.addr));\n\t\tif (func->ttl) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_SRF]) {\n\t\tstruct nlattr *srf_tb[NUM_NL80211_NAN_SRF_ATTR];\n\n\t\terr = nla_parse_nested_deprecated(srf_tb,\n\t\t\t\t\t\t  NL80211_NAN_SRF_ATTR_MAX,\n\t\t\t\t\t\t  tb[NL80211_NAN_FUNC_SRF],\n\t\t\t\t\t\t  nl80211_nan_srf_policy,\n\t\t\t\t\t\t  info->extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfunc->srf_include =\n\t\t\tnla_get_flag(srf_tb[NL80211_NAN_SRF_INCLUDE]);\n\n\t\tif (srf_tb[NL80211_NAN_SRF_BF]) {\n\t\t\tif (srf_tb[NL80211_NAN_SRF_MAC_ADDRS] ||\n\t\t\t    !srf_tb[NL80211_NAN_SRF_BF_IDX]) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_bf_len =\n\t\t\t\tnla_len(srf_tb[NL80211_NAN_SRF_BF]);\n\t\t\tfunc->srf_bf =\n\t\t\t\tkmemdup(nla_data(srf_tb[NL80211_NAN_SRF_BF]),\n\t\t\t\t\tfunc->srf_bf_len, GFP_KERNEL);\n\t\t\tif (!func->srf_bf) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_bf_idx =\n\t\t\t\tnla_get_u8(srf_tb[NL80211_NAN_SRF_BF_IDX]);\n\t\t} else {\n\t\t\tstruct nlattr *attr, *mac_attr =\n\t\t\t\tsrf_tb[NL80211_NAN_SRF_MAC_ADDRS];\n\t\t\tint n_entries, rem, i = 0;\n\n\t\t\tif (!mac_attr) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tn_entries = validate_acl_mac_addrs(mac_attr);\n\t\t\tif (n_entries <= 0) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfunc->srf_num_macs = n_entries;\n\t\t\tfunc->srf_macs =\n\t\t\t\tkcalloc(n_entries, sizeof(*func->srf_macs),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!func->srf_macs) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tnla_for_each_nested(attr, mac_attr, rem)\n\t\t\t\tmemcpy(func->srf_macs[i++].addr, nla_data(attr),\n\t\t\t\t       sizeof(*func->srf_macs));\n\t\t}\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_TX_MATCH_FILTER]) {\n\t\terr = handle_nan_filter(tb[NL80211_NAN_FUNC_TX_MATCH_FILTER],\n\t\t\t\t\tfunc, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (tb[NL80211_NAN_FUNC_RX_MATCH_FILTER]) {\n\t\terr = handle_nan_filter(tb[NL80211_NAN_FUNC_RX_MATCH_FILTER],\n\t\t\t\t\tfunc, false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_ADD_NAN_FUNCTION);\n\t \n\tif (WARN_ON(!hdr)) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = rdev_add_nan_func(rdev, wdev, func);\nout:\n\tif (err < 0) {\n\t\tcfg80211_free_nan_func(func);\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\t \n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, func->cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tfunc_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_FUNC);\n\tif (!func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID,\n\t\t       func->instance_id))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, func_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_nan_del_func(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tu64 cookie;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (!info->attrs[NL80211_ATTR_COOKIE])\n\t\treturn -EINVAL;\n\n\tcookie = nla_get_u64(info->attrs[NL80211_ATTR_COOKIE]);\n\n\trdev_del_nan_func(rdev, wdev, cookie);\n\n\treturn 0;\n}\n\nstatic int nl80211_nan_change_config(struct sk_buff *skb,\n\t\t\t\t     struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_nan_conf conf = {};\n\tu32 changed = 0;\n\n\tif (wdev->iftype != NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wdev_running(wdev))\n\t\treturn -ENOTCONN;\n\n\tif (info->attrs[NL80211_ATTR_NAN_MASTER_PREF]) {\n\t\tconf.master_pref =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_NAN_MASTER_PREF]);\n\t\tif (conf.master_pref <= 1 || conf.master_pref == 255)\n\t\t\treturn -EINVAL;\n\n\t\tchanged |= CFG80211_NAN_CONF_CHANGED_PREF;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_BANDS]) {\n\t\tu32 bands = nla_get_u32(info->attrs[NL80211_ATTR_BANDS]);\n\n\t\tif (bands & ~(u32)wdev->wiphy->nan_supported_bands)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (bands && !(bands & BIT(NL80211_BAND_2GHZ)))\n\t\t\treturn -EINVAL;\n\n\t\tconf.bands = bands;\n\t\tchanged |= CFG80211_NAN_CONF_CHANGED_BANDS;\n\t}\n\n\tif (!changed)\n\t\treturn -EINVAL;\n\n\treturn rdev_nan_change_conf(rdev, wdev, &conf, changed);\n}\n\nvoid cfg80211_nan_match(struct wireless_dev *wdev,\n\t\t\tstruct cfg80211_nan_match_params *match, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct nlattr *match_attr, *local_func_attr, *peer_func_attr;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (WARN_ON(!match->inst_id || !match->peer_inst_id || !match->addr))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NAN_MATCH);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, match->cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, match->addr))\n\t\tgoto nla_put_failure;\n\n\tmatch_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_MATCH);\n\tif (!match_attr)\n\t\tgoto nla_put_failure;\n\n\tlocal_func_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_NAN_MATCH_FUNC_LOCAL);\n\tif (!local_func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, match->inst_id))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, local_func_attr);\n\n\tpeer_func_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_NAN_MATCH_FUNC_PEER);\n\tif (!peer_func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_TYPE, match->type) ||\n\t    nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, match->peer_inst_id))\n\t\tgoto nla_put_failure;\n\n\tif (match->info && match->info_len &&\n\t    nla_put(msg, NL80211_NAN_FUNC_SERVICE_INFO, match->info_len,\n\t\t    match->info))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, peer_func_attr);\n\tnla_nest_end(msg, match_attr);\n\tgenlmsg_end(msg, hdr);\n\n\tif (!wdev->owner_nlportid)\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tmsg, 0, NL80211_MCGRP_NAN, gfp);\n\telse\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\t\twdev->owner_nlportid);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_nan_match);\n\nvoid cfg80211_nan_func_terminated(struct wireless_dev *wdev,\n\t\t\t\t  u8 inst_id,\n\t\t\t\t  enum nl80211_nan_func_term_reason reason,\n\t\t\t\t  u64 cookie, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tstruct nlattr *func_attr;\n\tvoid *hdr;\n\n\tif (WARN_ON(!inst_id))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DEL_NAN_FUNCTION);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tfunc_attr = nla_nest_start_noflag(msg, NL80211_ATTR_NAN_FUNC);\n\tif (!func_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(msg, NL80211_NAN_FUNC_INSTANCE_ID, inst_id) ||\n\t    nla_put_u8(msg, NL80211_NAN_FUNC_TERM_REASON, reason))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, func_attr);\n\tgenlmsg_end(msg, hdr);\n\n\tif (!wdev->owner_nlportid)\n\t\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t\tmsg, 0, NL80211_MCGRP_NAN, gfp);\n\telse\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\t\twdev->owner_nlportid);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_nan_func_terminated);\n\nstatic int nl80211_get_protocol_features(struct sk_buff *skb,\n\t\t\t\t\t struct genl_info *info)\n{\n\tvoid *hdr;\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_PROTOCOL_FEATURES);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_PROTOCOL_FEATURES,\n\t\t\tNL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\tkfree_skb(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_update_ft_ies_params ft_params;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->update_ft_ies)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MDID] ||\n\t    !info->attrs[NL80211_ATTR_IE])\n\t\treturn -EINVAL;\n\n\tmemset(&ft_params, 0, sizeof(ft_params));\n\tft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);\n\tft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\tft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\n\treturn rdev_update_ft_ies(rdev, dev, &ft_params);\n}\n\nstatic int nl80211_crit_protocol_start(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tenum nl80211_crit_proto_id proto = NL80211_CRIT_PROTO_UNSPEC;\n\tu16 duration;\n\tint ret;\n\n\tif (!rdev->ops->crit_proto_start)\n\t\treturn -EOPNOTSUPP;\n\n\tif (WARN_ON(!rdev->ops->crit_proto_stop))\n\t\treturn -EINVAL;\n\n\tif (rdev->crit_proto_nlportid)\n\t\treturn -EBUSY;\n\n\t \n\tif (info->attrs[NL80211_ATTR_CRIT_PROT_ID])\n\t\tproto = nla_get_u16(info->attrs[NL80211_ATTR_CRIT_PROT_ID]);\n\n\tif (proto >= NUM_NL80211_CRIT_PROTO)\n\t\treturn -EINVAL;\n\n\t \n\tif (!info->attrs[NL80211_ATTR_MAX_CRIT_PROT_DURATION])\n\t\treturn -EINVAL;\n\n\tduration =\n\t\tnla_get_u16(info->attrs[NL80211_ATTR_MAX_CRIT_PROT_DURATION]);\n\n\tret = rdev_crit_proto_start(rdev, wdev, proto, duration);\n\tif (!ret)\n\t\trdev->crit_proto_nlportid = info->snd_portid;\n\n\treturn ret;\n}\n\nstatic int nl80211_crit_protocol_stop(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\tif (!rdev->ops->crit_proto_stop)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rdev->crit_proto_nlportid) {\n\t\trdev->crit_proto_nlportid = 0;\n\t\trdev_crit_proto_stop(rdev, wdev);\n\t}\n\treturn 0;\n}\n\nstatic int nl80211_vendor_check_policy(const struct wiphy_vendor_command *vcmd,\n\t\t\t\t       struct nlattr *attr,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tif (vcmd->policy == VENDOR_CMD_RAW_DATA) {\n\t\tif (attr->nla_type & NLA_F_NESTED) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, attr,\n\t\t\t\t\t    \"unexpected nested data\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (!(attr->nla_type & NLA_F_NESTED)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, attr, \"expected nested data\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn nla_validate_nested(attr, vcmd->maxattr, vcmd->policy, extack);\n}\n\nstatic int nl80211_vendor_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev =\n\t\t__cfg80211_wdev_from_attrs(rdev, genl_info_net(info),\n\t\t\t\t\t   info->attrs);\n\tint i, err;\n\tu32 vid, subcmd;\n\n\tif (!rdev->wiphy.vendor_commands)\n\t\treturn -EOPNOTSUPP;\n\n\tif (IS_ERR(wdev)) {\n\t\terr = PTR_ERR(wdev);\n\t\tif (err != -EINVAL)\n\t\t\treturn err;\n\t\twdev = NULL;\n\t} else if (wdev->wiphy != &rdev->wiphy) {\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_VENDOR_ID] ||\n\t    !info->attrs[NL80211_ATTR_VENDOR_SUBCMD])\n\t\treturn -EINVAL;\n\n\tvid = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_SUBCMD]);\n\tfor (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {\n\t\tconst struct wiphy_vendor_command *vcmd;\n\t\tvoid *data = NULL;\n\t\tint len = 0;\n\n\t\tvcmd = &rdev->wiphy.vendor_commands[i];\n\n\t\tif (vcmd->info.vendor_id != vid || vcmd->info.subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tif (vcmd->flags & (WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t\t   WIPHY_VENDOR_CMD_NEED_NETDEV)) {\n\t\t\tif (!wdev)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_NETDEV &&\n\t\t\t    !wdev->netdev)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_RUNNING) {\n\t\t\t\tif (!wdev_running(wdev))\n\t\t\t\t\treturn -ENETDOWN;\n\t\t\t}\n\t\t} else {\n\t\t\twdev = NULL;\n\t\t}\n\n\t\tif (!vcmd->doit)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (info->attrs[NL80211_ATTR_VENDOR_DATA]) {\n\t\t\tdata = nla_data(info->attrs[NL80211_ATTR_VENDOR_DATA]);\n\t\t\tlen = nla_len(info->attrs[NL80211_ATTR_VENDOR_DATA]);\n\n\t\t\terr = nl80211_vendor_check_policy(vcmd,\n\t\t\t\t\tinfo->attrs[NL80211_ATTR_VENDOR_DATA],\n\t\t\t\t\tinfo->extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\trdev->cur_cmd_info = info;\n\t\terr = vcmd->doit(&rdev->wiphy, wdev, data, len);\n\t\trdev->cur_cmd_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int nl80211_prepare_vendor_dump(struct sk_buff *skb,\n\t\t\t\t       struct netlink_callback *cb,\n\t\t\t\t       struct cfg80211_registered_device **rdev,\n\t\t\t\t       struct wireless_dev **wdev)\n{\n\tstruct nlattr **attrbuf;\n\tu32 vid, subcmd;\n\tunsigned int i;\n\tint vcmd_idx = -1;\n\tint err;\n\tvoid *data = NULL;\n\tunsigned int data_len = 0;\n\n\tif (cb->args[0]) {\n\t\t \n\t\tstruct wiphy *wiphy = wiphy_idx_to_wiphy(cb->args[0] - 1);\n\t\tstruct wireless_dev *tmp;\n\n\t\tif (!wiphy)\n\t\t\treturn -ENODEV;\n\t\t*rdev = wiphy_to_rdev(wiphy);\n\t\t*wdev = NULL;\n\n\t\tif (cb->args[1]) {\n\t\t\tlist_for_each_entry(tmp, &wiphy->wdev_list, list) {\n\t\t\t\tif (tmp->identifier == cb->args[1] - 1) {\n\t\t\t\t\t*wdev = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\treturn 0;\n\t}\n\n\tattrbuf = kcalloc(NUM_NL80211_ATTR, sizeof(*attrbuf), GFP_KERNEL);\n\tif (!attrbuf)\n\t\treturn -ENOMEM;\n\n\terr = nlmsg_parse_deprecated(cb->nlh,\n\t\t\t\t     GENL_HDRLEN + nl80211_fam.hdrsize,\n\t\t\t\t     attrbuf, nl80211_fam.maxattr,\n\t\t\t\t     nl80211_policy, NULL);\n\tif (err)\n\t\tgoto out;\n\n\tif (!attrbuf[NL80211_ATTR_VENDOR_ID] ||\n\t    !attrbuf[NL80211_ATTR_VENDOR_SUBCMD]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*wdev = __cfg80211_wdev_from_attrs(NULL, sock_net(skb->sk), attrbuf);\n\tif (IS_ERR(*wdev))\n\t\t*wdev = NULL;\n\n\t*rdev = __cfg80211_rdev_from_attrs(sock_net(skb->sk), attrbuf);\n\tif (IS_ERR(*rdev)) {\n\t\terr = PTR_ERR(*rdev);\n\t\tgoto out;\n\t}\n\n\tvid = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_SUBCMD]);\n\n\tfor (i = 0; i < (*rdev)->wiphy.n_vendor_commands; i++) {\n\t\tconst struct wiphy_vendor_command *vcmd;\n\n\t\tvcmd = &(*rdev)->wiphy.vendor_commands[i];\n\n\t\tif (vcmd->info.vendor_id != vid || vcmd->info.subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tif (!vcmd->dumpit) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tvcmd_idx = i;\n\t\tbreak;\n\t}\n\n\tif (vcmd_idx < 0) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (attrbuf[NL80211_ATTR_VENDOR_DATA]) {\n\t\tdata = nla_data(attrbuf[NL80211_ATTR_VENDOR_DATA]);\n\t\tdata_len = nla_len(attrbuf[NL80211_ATTR_VENDOR_DATA]);\n\n\t\terr = nl80211_vendor_check_policy(\n\t\t\t\t&(*rdev)->wiphy.vendor_commands[vcmd_idx],\n\t\t\t\tattrbuf[NL80211_ATTR_VENDOR_DATA],\n\t\t\t\tcb->extack);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\tcb->args[0] = (*rdev)->wiphy_idx + 1;\n\t \n\tcb->args[1] = *wdev ? (*wdev)->identifier + 1 : 0;\n\tcb->args[2] = vcmd_idx;\n\tcb->args[3] = (unsigned long)data;\n\tcb->args[4] = data_len;\n\n\t \n\terr = 0;\nout:\n\tkfree(attrbuf);\n\treturn err;\n}\n\nstatic int nl80211_vendor_cmd_dump(struct sk_buff *skb,\n\t\t\t\t   struct netlink_callback *cb)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tunsigned int vcmd_idx;\n\tconst struct wiphy_vendor_command *vcmd;\n\tvoid *data;\n\tint data_len;\n\tint err;\n\tstruct nlattr *vendor_data;\n\n\trtnl_lock();\n\terr = nl80211_prepare_vendor_dump(skb, cb, &rdev, &wdev);\n\tif (err)\n\t\tgoto out;\n\n\tvcmd_idx = cb->args[2];\n\tdata = (void *)cb->args[3];\n\tdata_len = cb->args[4];\n\tvcmd = &rdev->wiphy.vendor_commands[vcmd_idx];\n\n\tif (vcmd->flags & (WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t   WIPHY_VENDOR_CMD_NEED_NETDEV)) {\n\t\tif (!wdev) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_NETDEV &&\n\t\t    !wdev->netdev) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (vcmd->flags & WIPHY_VENDOR_CMD_NEED_RUNNING) {\n\t\t\tif (!wdev_running(wdev)) {\n\t\t\t\terr = -ENETDOWN;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tvoid *hdr = nl80211hdr_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t\t   NL80211_CMD_VENDOR);\n\t\tif (!hdr)\n\t\t\tbreak;\n\n\t\tif (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t\t    (wdev && nla_put_u64_64bit(skb, NL80211_ATTR_WDEV,\n\t\t\t\t\t       wdev_id(wdev),\n\t\t\t\t\t       NL80211_ATTR_PAD))) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\tvendor_data = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t    NL80211_ATTR_VENDOR_DATA);\n\t\tif (!vendor_data) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = vcmd->dumpit(&rdev->wiphy, wdev, skb, data, data_len,\n\t\t\t\t   (unsigned long *)&cb->args[5]);\n\t\tnla_nest_end(skb, vendor_data);\n\n\t\tif (err == -ENOBUFS || err == -ENOENT) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tbreak;\n\t\t} else if (err <= 0) {\n\t\t\tgenlmsg_cancel(skb, hdr);\n\t\t\tgoto out;\n\t\t}\n\n\t\tgenlmsg_end(skb, hdr);\n\t}\n\n\terr = skb->len;\n out:\n\trtnl_unlock();\n\treturn err;\n}\n\nstruct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,\n\t\t\t\t\t   enum nl80211_commands cmd,\n\t\t\t\t\t   enum nl80211_attrs attr,\n\t\t\t\t\t   int approxlen)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (WARN_ON(!rdev->cur_cmd_info))\n\t\treturn NULL;\n\n\treturn __cfg80211_alloc_vendor_skb(rdev, NULL, approxlen,\n\t\t\t\t\t   rdev->cur_cmd_info->snd_portid,\n\t\t\t\t\t   rdev->cur_cmd_info->snd_seq,\n\t\t\t\t\t   cmd, attr, NULL, GFP_KERNEL);\n}\nEXPORT_SYMBOL(__cfg80211_alloc_reply_skb);\n\nint cfg80211_vendor_cmd_reply(struct sk_buff *skb)\n{\n\tstruct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\tstruct nlattr *data = ((void **)skb->cb)[2];\n\n\t \n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tif (WARN_ON(!rdev->cur_cmd_info)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tnla_nest_end(skb, data);\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_reply(skb, rdev->cur_cmd_info);\n}\nEXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_reply);\n\nunsigned int cfg80211_vendor_cmd_get_sender(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (WARN_ON(!rdev->cur_cmd_info))\n\t\treturn 0;\n\n\treturn rdev->cur_cmd_info->snd_portid;\n}\nEXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_get_sender);\n\nstatic int nl80211_set_qos_map(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_qos_map *qos_map = NULL;\n\tstruct net_device *dev = info->user_ptr[1];\n\tu8 *pos, len, num_des, des_len, des;\n\tint ret;\n\n\tif (!rdev->ops->set_qos_map)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_QOS_MAP]) {\n\t\tpos = nla_data(info->attrs[NL80211_ATTR_QOS_MAP]);\n\t\tlen = nla_len(info->attrs[NL80211_ATTR_QOS_MAP]);\n\n\t\tif (len % 2)\n\t\t\treturn -EINVAL;\n\n\t\tqos_map = kzalloc(sizeof(struct cfg80211_qos_map), GFP_KERNEL);\n\t\tif (!qos_map)\n\t\t\treturn -ENOMEM;\n\n\t\tnum_des = (len - IEEE80211_QOS_MAP_LEN_MIN) >> 1;\n\t\tif (num_des) {\n\t\t\tdes_len = num_des *\n\t\t\t\tsizeof(struct cfg80211_dscp_exception);\n\t\t\tmemcpy(qos_map->dscp_exception, pos, des_len);\n\t\t\tqos_map->num_des = num_des;\n\t\t\tfor (des = 0; des < num_des; des++) {\n\t\t\t\tif (qos_map->dscp_exception[des].up > 7) {\n\t\t\t\t\tkfree(qos_map);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos += des_len;\n\t\t}\n\t\tmemcpy(qos_map->up, pos, IEEE80211_QOS_MAP_LEN_MIN);\n\t}\n\n\twdev_lock(dev->ieee80211_ptr);\n\tret = nl80211_key_allowed(dev->ieee80211_ptr);\n\tif (!ret)\n\t\tret = rdev_set_qos_map(rdev, dev, qos_map);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\tkfree(qos_map);\n\treturn ret;\n}\n\nstatic int nl80211_add_tx_ts(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *peer;\n\tu8 tsid, up;\n\tu16 admitted_time = 0;\n\tint err;\n\n\tif (!(rdev->wiphy.features & NL80211_FEATURE_SUPPORTS_WMM_ADMISSION))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_TSID] || !info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_USER_PRIO])\n\t\treturn -EINVAL;\n\n\ttsid = nla_get_u8(info->attrs[NL80211_ATTR_TSID]);\n\tup = nla_get_u8(info->attrs[NL80211_ATTR_USER_PRIO]);\n\n\t \n\tif (tsid >= IEEE80211_FIRST_TSPEC_TSID) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\tif (info->attrs[NL80211_ATTR_ADMITTED_TIME]) {\n\t\tadmitted_time =\n\t\t\tnla_get_u16(info->attrs[NL80211_ATTR_ADMITTED_TIME]);\n\t\tif (!admitted_time)\n\t\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->connected)\n\t\t\tbreak;\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = rdev_add_tx_ts(rdev, dev, tsid, peer, up, admitted_time);\n\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_del_tx_ts(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *peer;\n\tu8 tsid;\n\tint err;\n\n\tif (!info->attrs[NL80211_ATTR_TSID] || !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\ttsid = nla_get_u8(info->attrs[NL80211_ATTR_TSID]);\n\tpeer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\twdev_lock(wdev);\n\terr = rdev_del_tx_ts(rdev, dev, tsid, peer);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_tdls_channel_switch(struct sk_buff *skb,\n\t\t\t\t       struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_chan_def chandef = {};\n\tconst u8 *addr;\n\tu8 oper_class;\n\tint err;\n\n\tif (!rdev->ops->tdls_channel_switch ||\n\t    !(rdev->wiphy.features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_OPER_CLASS])\n\t\treturn -EINVAL;\n\n\terr = nl80211_parse_chandef(rdev, info, &chandef);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (chandef.chan->band == NL80211_BAND_2GHZ &&\n\t    chandef.width != NL80211_CHAN_WIDTH_20_NOHT &&\n\t    chandef.width != NL80211_CHAN_WIDTH_20)\n\t\treturn -EINVAL;\n\n\t \n\tif (!cfg80211_reg_can_beacon_relax(&rdev->wiphy, &chandef,\n\t\t\t\t\t   wdev->iftype))\n\t\treturn -EINVAL;\n\n\t \n\tif (cfg80211_chandef_dfs_required(wdev->wiphy, &chandef, wdev->iftype))\n\t\treturn -EINVAL;\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\toper_class = nla_get_u8(info->attrs[NL80211_ATTR_OPER_CLASS]);\n\n\twdev_lock(wdev);\n\terr = rdev_tdls_channel_switch(rdev, dev, addr, oper_class, &chandef);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nstatic int nl80211_tdls_cancel_channel_switch(struct sk_buff *skb,\n\t\t\t\t\t      struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *addr;\n\n\tif (!rdev->ops->tdls_channel_switch ||\n\t    !rdev->ops->tdls_cancel_channel_switch ||\n\t    !(rdev->wiphy.features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->ieee80211_ptr->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\twdev_lock(wdev);\n\trdev_tdls_cancel_channel_switch(rdev, dev, addr);\n\twdev_unlock(wdev);\n\n\treturn 0;\n}\n\nstatic int nl80211_set_multicast_to_unicast(struct sk_buff *skb,\n\t\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst struct nlattr *nla;\n\tbool enabled;\n\n\tif (!rdev->ops->set_multicast_to_unicast)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\n\tnla = info->attrs[NL80211_ATTR_MULTICAST_TO_UNICAST_ENABLED];\n\tenabled = nla_get_flag(nla);\n\n\treturn rdev_set_multicast_to_unicast(rdev, dev, enabled);\n}\n\nstatic int nl80211_set_pmk(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_pmk_conf pmk_conf = {};\n\tint ret;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] || !info->attrs[NL80211_ATTR_PMK])\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\tif (!wdev->connected) {\n\t\tret = -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\tpmk_conf.aa = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tif (memcmp(pmk_conf.aa, wdev->u.client.connected_addr, ETH_ALEN)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpmk_conf.pmk = nla_data(info->attrs[NL80211_ATTR_PMK]);\n\tpmk_conf.pmk_len = nla_len(info->attrs[NL80211_ATTR_PMK]);\n\tif (pmk_conf.pmk_len != WLAN_PMK_LEN &&\n\t    pmk_conf.pmk_len != WLAN_PMK_LEN_SUITE_B_192) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (info->attrs[NL80211_ATTR_PMKR0_NAME])\n\t\tpmk_conf.pmk_r0_name =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_PMKR0_NAME]);\n\n\tret = rdev_set_pmk(rdev, dev, &pmk_conf);\nout:\n\twdev_unlock(wdev);\n\treturn ret;\n}\n\nstatic int nl80211_del_pmk(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *aa;\n\tint ret;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\taa = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tret = rdev_del_pmk(rdev, dev, aa);\n\twdev_unlock(wdev);\n\n\treturn ret;\n}\n\nstatic int nl80211_external_auth(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_external_auth_params params;\n\n\tif (!rdev->ops->external_auth)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_SSID] &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&\n\t    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_BSSID])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_STATUS_CODE])\n\t\treturn -EINVAL;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (info->attrs[NL80211_ATTR_SSID]) {\n\t\tparams.ssid.ssid_len = nla_len(info->attrs[NL80211_ATTR_SSID]);\n\t\tif (params.ssid.ssid_len == 0)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(params.ssid.ssid,\n\t\t       nla_data(info->attrs[NL80211_ATTR_SSID]),\n\t\t       params.ssid.ssid_len);\n\t}\n\n\tmemcpy(params.bssid, nla_data(info->attrs[NL80211_ATTR_BSSID]),\n\t       ETH_ALEN);\n\n\tparams.status = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\n\tif (info->attrs[NL80211_ATTR_PMKID])\n\t\tparams.pmkid = nla_data(info->attrs[NL80211_ATTR_PMKID]);\n\n\treturn rdev_external_auth(rdev, dev, &params);\n}\n\nstatic int nl80211_tx_control_port(struct sk_buff *skb, struct genl_info *info)\n{\n\tbool dont_wait_for_ack = info->attrs[NL80211_ATTR_DONT_WAIT_FOR_ACK];\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tconst u8 *buf;\n\tsize_t len;\n\tu8 *dest;\n\tu16 proto;\n\tbool noencrypt;\n\tu64 cookie = 0;\n\tint link_id;\n\tint err;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->tx_control_port)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_FRAME] ||\n\t    !info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]) {\n\t\tGENL_SET_ERR_MSG(info, \"Frame, MAC or ethertype missing\");\n\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (wdev->u.ibss.current_bss)\n\t\t\tbreak;\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (wdev->connected)\n\t\t\tbreak;\n\t\terr = -ENOTCONN;\n\t\tgoto out;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\twdev_unlock(wdev);\n\n\tbuf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tlen = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\tdest = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tproto = nla_get_u16(info->attrs[NL80211_ATTR_CONTROL_PORT_ETHERTYPE]);\n\tnoencrypt =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT]);\n\n\tlink_id = nl80211_link_id_or_invalid(info->attrs);\n\n\terr = rdev_tx_control_port(rdev, dev, buf, len,\n\t\t\t\t   dest, cpu_to_be16(proto), noencrypt, link_id,\n\t\t\t\t   dont_wait_for_ack ? NULL : &cookie);\n\tif (!err && !dont_wait_for_ack)\n\t\tnl_set_extack_cookie_u64(info->extack, cookie);\n\treturn err;\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nstatic int nl80211_get_ftm_responder_stats(struct sk_buff *skb,\n\t\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ftm_responder_stats ftm_stats = {};\n\tunsigned int link_id = nl80211_link_id(info->attrs);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *ftm_stats_attr;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP ||\n\t    !wdev->links[link_id].ap.beacon_interval)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_ftm_responder_stats(rdev, dev, &ftm_stats);\n\tif (err)\n\t\treturn err;\n\n\tif (!ftm_stats.filled)\n\t\treturn -ENODATA;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_FTM_RESPONDER_STATS);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tftm_stats_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_ATTR_FTM_RESPONDER_STATS);\n\tif (!ftm_stats_attr)\n\t\tgoto nla_put_failure;\n\n#define SET_FTM(field, name, type)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_ ## type(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t     ftm_stats.field))\t\t\t\t \\\n\t\tgoto nla_put_failure; } while (0)\n#define SET_FTM_U64(field, name)\t\t\t\t\t \\\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_u64_64bit(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t      ftm_stats.field, NL80211_FTM_STATS_PAD))\t \\\n\t\tgoto nla_put_failure; } while (0)\n\n\tSET_FTM(success_num, SUCCESS_NUM, u32);\n\tSET_FTM(partial_num, PARTIAL_NUM, u32);\n\tSET_FTM(failed_num, FAILED_NUM, u32);\n\tSET_FTM(asap_num, ASAP_NUM, u32);\n\tSET_FTM(non_asap_num, NON_ASAP_NUM, u32);\n\tSET_FTM_U64(total_duration_ms, TOTAL_DURATION_MSEC);\n\tSET_FTM(unknown_triggers_num, UNKNOWN_TRIGGERS_NUM, u32);\n\tSET_FTM(reschedule_requests_num, RESCHEDULE_REQUESTS_NUM, u32);\n\tSET_FTM(out_of_window_triggers_num, OUT_OF_WINDOW_TRIGGERS_NUM, u32);\n#undef SET_FTM\n\n\tnla_nest_end(msg, ftm_stats_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_update_owe_info(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_update_owe_info owe_info;\n\tstruct net_device *dev = info->user_ptr[1];\n\n\tif (!rdev->ops->update_owe_info)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_STATUS_CODE] ||\n\t    !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tmemset(&owe_info, 0, sizeof(owe_info));\n\towe_info.status = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);\n\tnla_memcpy(owe_info.peer, info->attrs[NL80211_ATTR_MAC], ETH_ALEN);\n\n\tif (info->attrs[NL80211_ATTR_IE]) {\n\t\towe_info.ie = nla_data(info->attrs[NL80211_ATTR_IE]);\n\t\towe_info.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);\n\t}\n\n\treturn rdev_update_owe_info(rdev, dev, &owe_info);\n}\n\nstatic int nl80211_probe_mesh_link(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct station_info sinfo = {};\n\tconst u8 *buf;\n\tsize_t len;\n\tu8 *dest;\n\tint err;\n\n\tif (!rdev->ops->probe_mesh_link || !rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_FRAME]) {\n\t\tGENL_SET_ERR_MSG(info, \"Frame or MAC missing\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_MESH_POINT)\n\t\treturn -EOPNOTSUPP;\n\n\tdest = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tbuf = nla_data(info->attrs[NL80211_ATTR_FRAME]);\n\tlen = nla_len(info->attrs[NL80211_ATTR_FRAME]);\n\n\tif (len < sizeof(struct ethhdr))\n\t\treturn -EINVAL;\n\n\tif (!ether_addr_equal(buf, dest) || is_multicast_ether_addr(buf) ||\n\t    !ether_addr_equal(buf + ETH_ALEN, dev->dev_addr))\n\t\treturn -EINVAL;\n\n\terr = rdev_get_station(rdev, dev, dest, &sinfo);\n\tif (err)\n\t\treturn err;\n\n\tcfg80211_sinfo_release_content(&sinfo);\n\n\treturn rdev_probe_mesh_link(rdev, dev, dest, buf, len);\n}\n\nstatic int parse_tid_conf(struct cfg80211_registered_device *rdev,\n\t\t\t  struct nlattr *attrs[], struct net_device *dev,\n\t\t\t  struct cfg80211_tid_cfg *tid_conf,\n\t\t\t  struct genl_info *info, const u8 *peer,\n\t\t\t  unsigned int link_id)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu64 mask;\n\tint err;\n\n\tif (!attrs[NL80211_TID_CONFIG_ATTR_TIDS])\n\t\treturn -EINVAL;\n\n\ttid_conf->config_override =\n\t\t\tnla_get_flag(attrs[NL80211_TID_CONFIG_ATTR_OVERRIDE]);\n\ttid_conf->tids = nla_get_u16(attrs[NL80211_TID_CONFIG_ATTR_TIDS]);\n\n\tif (tid_conf->config_override) {\n\t\tif (rdev->ops->reset_tid_config) {\n\t\t\terr = rdev_reset_tid_config(rdev, dev, peer,\n\t\t\t\t\t\t    tid_conf->tids);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_NOACK]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_NOACK);\n\t\ttid_conf->noack =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_NOACK]);\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_RETRY_SHORT]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_RETRY_SHORT);\n\t\ttid_conf->retry_short =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_RETRY_SHORT]);\n\n\t\tif (tid_conf->retry_short > rdev->wiphy.max_data_retry_count)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_RETRY_LONG]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG);\n\t\ttid_conf->retry_long =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_RETRY_LONG]);\n\n\t\tif (tid_conf->retry_long > rdev->wiphy.max_data_retry_count)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_AMPDU_CTRL]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL);\n\t\ttid_conf->ampdu =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_AMPDU_CTRL]);\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL);\n\t\ttid_conf->rtscts =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL]);\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_AMSDU_CTRL]) {\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_AMSDU_CTRL);\n\t\ttid_conf->amsdu =\n\t\t\tnla_get_u8(attrs[NL80211_TID_CONFIG_ATTR_AMSDU_CTRL]);\n\t}\n\n\tif (attrs[NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE]) {\n\t\tu32 idx = NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE, attr;\n\n\t\ttid_conf->txrate_type = nla_get_u8(attrs[idx]);\n\n\t\tif (tid_conf->txrate_type != NL80211_TX_RATE_AUTOMATIC) {\n\t\t\tattr = NL80211_TID_CONFIG_ATTR_TX_RATE;\n\t\t\terr = nl80211_parse_tx_bitrate_mask(info, attrs, attr,\n\t\t\t\t\t\t    &tid_conf->txrate_mask, dev,\n\t\t\t\t\t\t    true, link_id);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_TX_RATE);\n\t\t}\n\t\ttid_conf->mask |= BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE);\n\t}\n\n\tif (peer)\n\t\tmask = rdev->wiphy.tid_config_support.peer;\n\telse\n\t\tmask = rdev->wiphy.tid_config_support.vif;\n\n\tif (tid_conf->mask & ~mask) {\n\t\tNL_SET_ERR_MSG(extack, \"unsupported TID configuration\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int nl80211_set_tid_config(struct sk_buff *skb,\n\t\t\t\t  struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *attrs[NL80211_TID_CONFIG_ATTR_MAX + 1];\n\tunsigned int link_id = nl80211_link_id(info->attrs);\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_tid_config *tid_config;\n\tstruct nlattr *tid;\n\tint conf_idx = 0, rem_conf;\n\tint ret = -EINVAL;\n\tu32 num_conf = 0;\n\n\tif (!info->attrs[NL80211_ATTR_TID_CONFIG])\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_tid_config)\n\t\treturn -EOPNOTSUPP;\n\n\tnla_for_each_nested(tid, info->attrs[NL80211_ATTR_TID_CONFIG],\n\t\t\t    rem_conf)\n\t\tnum_conf++;\n\n\ttid_config = kzalloc(struct_size(tid_config, tid_conf, num_conf),\n\t\t\t     GFP_KERNEL);\n\tif (!tid_config)\n\t\treturn -ENOMEM;\n\n\ttid_config->n_tid_conf = num_conf;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\ttid_config->peer = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\twdev_lock(dev->ieee80211_ptr);\n\n\tnla_for_each_nested(tid, info->attrs[NL80211_ATTR_TID_CONFIG],\n\t\t\t    rem_conf) {\n\t\tret = nla_parse_nested(attrs, NL80211_TID_CONFIG_ATTR_MAX,\n\t\t\t\t       tid, NULL, NULL);\n\n\t\tif (ret)\n\t\t\tgoto bad_tid_conf;\n\n\t\tret = parse_tid_conf(rdev, attrs, dev,\n\t\t\t\t     &tid_config->tid_conf[conf_idx],\n\t\t\t\t     info, tid_config->peer, link_id);\n\t\tif (ret)\n\t\t\tgoto bad_tid_conf;\n\n\t\tconf_idx++;\n\t}\n\n\tret = rdev_set_tid_config(rdev, dev, tid_config);\n\nbad_tid_conf:\n\tkfree(tid_config);\n\twdev_unlock(dev->ieee80211_ptr);\n\treturn ret;\n}\n\nstatic int nl80211_color_change(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct cfg80211_color_change_settings params = {};\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct nlattr **tb;\n\tu16 offset;\n\tint err;\n\n\tif (!rdev->ops->color_change)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t     NL80211_EXT_FEATURE_BSS_COLOR))\n\t\treturn -EOPNOTSUPP;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_COLOR_CHANGE_COUNT] ||\n\t    !info->attrs[NL80211_ATTR_COLOR_CHANGE_COLOR] ||\n\t    !info->attrs[NL80211_ATTR_COLOR_CHANGE_ELEMS])\n\t\treturn -EINVAL;\n\n\tparams.count = nla_get_u8(info->attrs[NL80211_ATTR_COLOR_CHANGE_COUNT]);\n\tparams.color = nla_get_u8(info->attrs[NL80211_ATTR_COLOR_CHANGE_COLOR]);\n\n\terr = nl80211_parse_beacon(rdev, info->attrs, &params.beacon_next,\n\t\t\t\t   info->extack);\n\tif (err)\n\t\treturn err;\n\n\ttb = kcalloc(NL80211_ATTR_MAX + 1, sizeof(*tb), GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\terr = nla_parse_nested(tb, NL80211_ATTR_MAX,\n\t\t\t       info->attrs[NL80211_ATTR_COLOR_CHANGE_ELEMS],\n\t\t\t       nl80211_policy, info->extack);\n\tif (err)\n\t\tgoto out;\n\n\terr = nl80211_parse_beacon(rdev, tb, &params.beacon_color_change,\n\t\t\t\t   info->extack);\n\tif (err)\n\t\tgoto out;\n\n\tif (!tb[NL80211_ATTR_CNTDWN_OFFS_BEACON]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (nla_len(tb[NL80211_ATTR_CNTDWN_OFFS_BEACON]) != sizeof(u16)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\toffset = nla_get_u16(tb[NL80211_ATTR_CNTDWN_OFFS_BEACON]);\n\tif (offset >= params.beacon_color_change.tail_len) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (params.beacon_color_change.tail[offset] != params.count) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.counter_offset_beacon = offset;\n\n\tif (tb[NL80211_ATTR_CNTDWN_OFFS_PRESP]) {\n\t\tif (nla_len(tb[NL80211_ATTR_CNTDWN_OFFS_PRESP]) !=\n\t\t    sizeof(u16)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset = nla_get_u16(tb[NL80211_ATTR_CNTDWN_OFFS_PRESP]);\n\t\tif (offset >= params.beacon_color_change.probe_resp_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (params.beacon_color_change.probe_resp[offset] !=\n\t\t    params.count) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparams.counter_offset_presp = offset;\n\t}\n\n\twdev_lock(wdev);\n\terr = rdev_color_change(rdev, dev, &params);\n\twdev_unlock(wdev);\n\nout:\n\tkfree(params.beacon_next.mbssid_ies);\n\tkfree(params.beacon_color_change.mbssid_ies);\n\tkfree(params.beacon_next.rnr_ies);\n\tkfree(params.beacon_color_change.rnr_ies);\n\tkfree(tb);\n\treturn err;\n}\n\nstatic int nl80211_set_fils_aad(struct sk_buff *skb,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_fils_aad fils_aad = {};\n\tu8 *nonces;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !info->attrs[NL80211_ATTR_FILS_KEK] ||\n\t    !info->attrs[NL80211_ATTR_FILS_NONCES])\n\t\treturn -EINVAL;\n\n\tfils_aad.macaddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\tfils_aad.kek_len = nla_len(info->attrs[NL80211_ATTR_FILS_KEK]);\n\tfils_aad.kek = nla_data(info->attrs[NL80211_ATTR_FILS_KEK]);\n\tnonces = nla_data(info->attrs[NL80211_ATTR_FILS_NONCES]);\n\tfils_aad.snonce = nonces;\n\tfils_aad.anonce = nonces + FILS_NONCE_LEN;\n\n\treturn rdev_set_fils_aad(rdev, dev, &fils_aad);\n}\n\nstatic int nl80211_add_link(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tunsigned int link_id = nl80211_link_id(info->attrs);\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint ret;\n\n\tif (!(wdev->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO))\n\t\treturn -EINVAL;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MAC] ||\n\t    !is_valid_ether_addr(nla_data(info->attrs[NL80211_ATTR_MAC])))\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\twdev->valid_links |= BIT(link_id);\n\tether_addr_copy(wdev->links[link_id].addr,\n\t\t\tnla_data(info->attrs[NL80211_ATTR_MAC]));\n\n\tret = rdev_add_intf_link(rdev, wdev, link_id);\n\tif (ret) {\n\t\twdev->valid_links &= ~BIT(link_id);\n\t\teth_zero_addr(wdev->links[link_id].addr);\n\t}\n\twdev_unlock(wdev);\n\n\treturn ret;\n}\n\nstatic int nl80211_remove_link(struct sk_buff *skb, struct genl_info *info)\n{\n\tunsigned int link_id = nl80211_link_id(info->attrs);\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t \n\tif (!info->attrs[NL80211_ATTR_MLO_LINK_ID])\n\t\treturn -EINVAL;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\tcfg80211_remove_link(wdev, link_id);\n\twdev_unlock(wdev);\n\n\treturn 0;\n}\n\nstatic int\nnl80211_add_mod_link_station(struct sk_buff *skb, struct genl_info *info,\n\t\t\t     bool add)\n{\n\tstruct link_station_parameters params = {};\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tint err;\n\n\tif ((add && !rdev->ops->add_link_station) ||\n\t    (!add && !rdev->ops->mod_link_station))\n\t\treturn -EOPNOTSUPP;\n\n\tif (add && !info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[NL80211_ATTR_MLD_ADDR])\n\t\treturn -EINVAL;\n\n\tif (add && !info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES])\n\t\treturn -EINVAL;\n\n\tparams.mld_mac = nla_data(info->attrs[NL80211_ATTR_MLD_ADDR]);\n\n\tif (info->attrs[NL80211_ATTR_MAC]) {\n\t\tparams.link_mac = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\t\tif (!is_valid_ether_addr(params.link_mac))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!info->attrs[NL80211_ATTR_MLO_LINK_ID])\n\t\treturn -EINVAL;\n\n\tparams.link_id = nla_get_u8(info->attrs[NL80211_ATTR_MLO_LINK_ID]);\n\n\tif (info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]) {\n\t\tparams.supported_rates =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t\tparams.supported_rates_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_STA_SUPPORTED_RATES]);\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HT_CAPABILITY])\n\t\tparams.ht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_VHT_CAPABILITY])\n\t\tparams.vht_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_VHT_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_HE_CAPABILITY]) {\n\t\tparams.he_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\t\tparams.he_capa_len =\n\t\t\tnla_len(info->attrs[NL80211_ATTR_HE_CAPABILITY]);\n\n\t\tif (info->attrs[NL80211_ATTR_EHT_CAPABILITY]) {\n\t\t\tparams.eht_capa =\n\t\t\t\tnla_data(info->attrs[NL80211_ATTR_EHT_CAPABILITY]);\n\t\t\tparams.eht_capa_len =\n\t\t\t\tnla_len(info->attrs[NL80211_ATTR_EHT_CAPABILITY]);\n\n\t\t\tif (!ieee80211_eht_capa_size_ok((const u8 *)params.he_capa,\n\t\t\t\t\t\t\t(const u8 *)params.eht_capa,\n\t\t\t\t\t\t\tparams.eht_capa_len,\n\t\t\t\t\t\t\tfalse))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY])\n\t\tparams.he_6ghz_capa =\n\t\t\tnla_data(info->attrs[NL80211_ATTR_HE_6GHZ_CAPABILITY]);\n\n\tif (info->attrs[NL80211_ATTR_OPMODE_NOTIF]) {\n\t\tparams.opmode_notif_used = true;\n\t\tparams.opmode_notif =\n\t\t\tnla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);\n\t}\n\n\terr = nl80211_parse_sta_txpower_setting(info, &params.txpwr,\n\t\t\t\t\t\t&params.txpwr_set);\n\tif (err)\n\t\treturn err;\n\n\twdev_lock(dev->ieee80211_ptr);\n\tif (add)\n\t\terr = rdev_add_link_station(rdev, dev, &params);\n\telse\n\t\terr = rdev_mod_link_station(rdev, dev, &params);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int\nnl80211_add_link_station(struct sk_buff *skb, struct genl_info *info)\n{\n\treturn nl80211_add_mod_link_station(skb, info, true);\n}\n\nstatic int\nnl80211_modify_link_station(struct sk_buff *skb, struct genl_info *info)\n{\n\treturn nl80211_add_mod_link_station(skb, info, false);\n}\n\nstatic int\nnl80211_remove_link_station(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct link_station_del_parameters params = {};\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tint ret;\n\n\tif (!rdev->ops->del_link_station)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MLD_ADDR] ||\n\t    !info->attrs[NL80211_ATTR_MLO_LINK_ID])\n\t\treturn -EINVAL;\n\n\tparams.mld_mac = nla_data(info->attrs[NL80211_ATTR_MLD_ADDR]);\n\tparams.link_id = nla_get_u8(info->attrs[NL80211_ATTR_MLO_LINK_ID]);\n\n\twdev_lock(dev->ieee80211_ptr);\n\tret = rdev_del_link_station(rdev, dev, &params);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn ret;\n}\n\nstatic int nl80211_set_hw_timestamp(struct sk_buff *skb,\n\t\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct cfg80211_set_hw_timestamp hwts = {};\n\n\tif (!rdev->wiphy.hw_timestamp_max_peers)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_MAC] &&\n\t    rdev->wiphy.hw_timestamp_max_peers != CFG80211_HW_TIMESTAMP_ALL_PEERS)\n\t\treturn -EOPNOTSUPP;\n\n\tif (info->attrs[NL80211_ATTR_MAC])\n\t\thwts.macaddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\n\thwts.enable =\n\t\tnla_get_flag(info->attrs[NL80211_ATTR_HW_TIMESTAMP_ENABLED]);\n\n\treturn rdev_set_hw_timestamp(rdev, dev, &hwts);\n}\n\n#define NL80211_FLAG_NEED_WIPHY\t\t0x01\n#define NL80211_FLAG_NEED_NETDEV\t0x02\n#define NL80211_FLAG_NEED_RTNL\t\t0x04\n#define NL80211_FLAG_CHECK_NETDEV_UP\t0x08\n#define NL80211_FLAG_NEED_NETDEV_UP\t(NL80211_FLAG_NEED_NETDEV |\\\n\t\t\t\t\t NL80211_FLAG_CHECK_NETDEV_UP)\n#define NL80211_FLAG_NEED_WDEV\t\t0x10\n \n#define NL80211_FLAG_NEED_WDEV_UP\t(NL80211_FLAG_NEED_WDEV |\\\n\t\t\t\t\t NL80211_FLAG_CHECK_NETDEV_UP)\n#define NL80211_FLAG_CLEAR_SKB\t\t0x20\n#define NL80211_FLAG_NO_WIPHY_MTX\t0x40\n#define NL80211_FLAG_MLO_VALID_LINK_ID\t0x80\n#define NL80211_FLAG_MLO_UNSUPPORTED\t0x100\n\n#define INTERNAL_FLAG_SELECTORS(__sel)\t\t\t\\\n\tSELECTOR(__sel, NONE, 0)  \t\\\n\tSELECTOR(__sel, WIPHY,\t\t\t\t\\\n\t\t NL80211_FLAG_NEED_WIPHY)\t\t\\\n\tSELECTOR(__sel, WDEV,\t\t\t\t\\\n\t\t NL80211_FLAG_NEED_WDEV)\t\t\\\n\tSELECTOR(__sel, NETDEV,\t\t\t\t\\\n\t\t NL80211_FLAG_NEED_NETDEV)\t\t\\\n\tSELECTOR(__sel, NETDEV_LINK,\t\t\t\\\n\t\t NL80211_FLAG_NEED_NETDEV |\t\t\\\n\t\t NL80211_FLAG_MLO_VALID_LINK_ID)\t\\\n\tSELECTOR(__sel, NETDEV_NO_MLO,\t\t\t\\\n\t\t NL80211_FLAG_NEED_NETDEV |\t\t\\\n\t\t NL80211_FLAG_MLO_UNSUPPORTED)\t\\\n\tSELECTOR(__sel, WIPHY_RTNL,\t\t\t\\\n\t\t NL80211_FLAG_NEED_WIPHY |\t\t\\\n\t\t NL80211_FLAG_NEED_RTNL)\t\t\\\n\tSELECTOR(__sel, WIPHY_RTNL_NOMTX,\t\t\\\n\t\t NL80211_FLAG_NEED_WIPHY |\t\t\\\n\t\t NL80211_FLAG_NEED_RTNL |\t\t\\\n\t\t NL80211_FLAG_NO_WIPHY_MTX)\t\t\\\n\tSELECTOR(__sel, WDEV_RTNL,\t\t\t\\\n\t\t NL80211_FLAG_NEED_WDEV |\t\t\\\n\t\t NL80211_FLAG_NEED_RTNL)\t\t\\\n\tSELECTOR(__sel, NETDEV_RTNL,\t\t\t\\\n\t\t NL80211_FLAG_NEED_NETDEV |\t\t\\\n\t\t NL80211_FLAG_NEED_RTNL)\t\t\\\n\tSELECTOR(__sel, NETDEV_UP,\t\t\t\\\n\t\t NL80211_FLAG_NEED_NETDEV_UP)\t\t\\\n\tSELECTOR(__sel, NETDEV_UP_LINK,\t\t\t\\\n\t\t NL80211_FLAG_NEED_NETDEV_UP |\t\t\\\n\t\t NL80211_FLAG_MLO_VALID_LINK_ID)\t\\\n\tSELECTOR(__sel, NETDEV_UP_NO_MLO,\t\t\\\n\t\t NL80211_FLAG_NEED_NETDEV_UP |\t\t\\\n\t\t NL80211_FLAG_MLO_UNSUPPORTED)\t\t\\\n\tSELECTOR(__sel, NETDEV_UP_NO_MLO_CLEAR,\t\t\\\n\t\t NL80211_FLAG_NEED_NETDEV_UP |\t\t\\\n\t\t NL80211_FLAG_CLEAR_SKB |\t\t\\\n\t\t NL80211_FLAG_MLO_UNSUPPORTED)\t\t\\\n\tSELECTOR(__sel, NETDEV_UP_NOTMX,\t\t\\\n\t\t NL80211_FLAG_NEED_NETDEV_UP |\t\t\\\n\t\t NL80211_FLAG_NO_WIPHY_MTX)\t\t\\\n\tSELECTOR(__sel, NETDEV_UP_NOTMX_NOMLO,\t\t\\\n\t\t NL80211_FLAG_NEED_NETDEV_UP |\t\t\\\n\t\t NL80211_FLAG_NO_WIPHY_MTX |\t\t\\\n\t\t NL80211_FLAG_MLO_UNSUPPORTED)\t\t\\\n\tSELECTOR(__sel, NETDEV_UP_CLEAR,\t\t\\\n\t\t NL80211_FLAG_NEED_NETDEV_UP |\t\t\\\n\t\t NL80211_FLAG_CLEAR_SKB)\t\t\\\n\tSELECTOR(__sel, WDEV_UP,\t\t\t\\\n\t\t NL80211_FLAG_NEED_WDEV_UP)\t\t\\\n\tSELECTOR(__sel, WDEV_UP_LINK,\t\t\t\\\n\t\t NL80211_FLAG_NEED_WDEV_UP |\t\t\\\n\t\t NL80211_FLAG_MLO_VALID_LINK_ID)\t\\\n\tSELECTOR(__sel, WDEV_UP_RTNL,\t\t\t\\\n\t\t NL80211_FLAG_NEED_WDEV_UP |\t\t\\\n\t\t NL80211_FLAG_NEED_RTNL)\t\t\\\n\tSELECTOR(__sel, WIPHY_CLEAR,\t\t\t\\\n\t\t NL80211_FLAG_NEED_WIPHY |\t\t\\\n\t\t NL80211_FLAG_CLEAR_SKB)\n\nenum nl80211_internal_flags_selector {\n#define SELECTOR(_, name, value)\tNL80211_IFL_SEL_##name,\n\tINTERNAL_FLAG_SELECTORS(_)\n#undef SELECTOR\n};\n\nstatic u32 nl80211_internal_flags[] = {\n#define SELECTOR(_, name, value)\t[NL80211_IFL_SEL_##name] = value,\n\tINTERNAL_FLAG_SELECTORS(_)\n#undef SELECTOR\n};\n\nstatic int nl80211_pre_doit(const struct genl_split_ops *ops,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = NULL;\n\tstruct wireless_dev *wdev = NULL;\n\tstruct net_device *dev = NULL;\n\tu32 internal_flags;\n\tint err;\n\n\tif (WARN_ON(ops->internal_flags >= ARRAY_SIZE(nl80211_internal_flags)))\n\t\treturn -EINVAL;\n\n\tinternal_flags = nl80211_internal_flags[ops->internal_flags];\n\n\trtnl_lock();\n\tif (internal_flags & NL80211_FLAG_NEED_WIPHY) {\n\t\trdev = cfg80211_get_dev_from_info(genl_info_net(info), info);\n\t\tif (IS_ERR(rdev)) {\n\t\t\terr = PTR_ERR(rdev);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tinfo->user_ptr[0] = rdev;\n\t} else if (internal_flags & NL80211_FLAG_NEED_NETDEV ||\n\t\t   internal_flags & NL80211_FLAG_NEED_WDEV) {\n\t\twdev = __cfg80211_wdev_from_attrs(NULL, genl_info_net(info),\n\t\t\t\t\t\t  info->attrs);\n\t\tif (IS_ERR(wdev)) {\n\t\t\terr = PTR_ERR(wdev);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tdev = wdev->netdev;\n\t\tdev_hold(dev);\n\t\trdev = wiphy_to_rdev(wdev->wiphy);\n\n\t\tif (internal_flags & NL80211_FLAG_NEED_NETDEV) {\n\t\t\tif (!dev) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\n\t\t\tinfo->user_ptr[1] = dev;\n\t\t} else {\n\t\t\tinfo->user_ptr[1] = wdev;\n\t\t}\n\n\t\tif (internal_flags & NL80211_FLAG_CHECK_NETDEV_UP &&\n\t\t    !wdev_running(wdev)) {\n\t\t\terr = -ENETDOWN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tinfo->user_ptr[0] = rdev;\n\t}\n\n\tif (internal_flags & NL80211_FLAG_MLO_VALID_LINK_ID) {\n\t\tstruct nlattr *link_id = info->attrs[NL80211_ATTR_MLO_LINK_ID];\n\n\t\tif (!wdev) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (wdev->valid_links &&\n\t\t    (!link_id ||\n\t\t     !(wdev->valid_links & BIT(nla_get_u8(link_id))))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (!wdev->valid_links && link_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (internal_flags & NL80211_FLAG_MLO_UNSUPPORTED) {\n\t\tif (info->attrs[NL80211_ATTR_MLO_LINK_ID] ||\n\t\t    (wdev && wdev->valid_links)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (rdev && !(internal_flags & NL80211_FLAG_NO_WIPHY_MTX)) {\n\t\twiphy_lock(&rdev->wiphy);\n\t\t \n\t\t__release(&rdev->wiphy.mtx);\n\t}\n\tif (!(internal_flags & NL80211_FLAG_NEED_RTNL))\n\t\trtnl_unlock();\n\n\treturn 0;\nout_unlock:\n\trtnl_unlock();\n\tdev_put(dev);\n\treturn err;\n}\n\nstatic void nl80211_post_doit(const struct genl_split_ops *ops,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      struct genl_info *info)\n{\n\tu32 internal_flags = nl80211_internal_flags[ops->internal_flags];\n\n\tif (info->user_ptr[1]) {\n\t\tif (internal_flags & NL80211_FLAG_NEED_WDEV) {\n\t\t\tstruct wireless_dev *wdev = info->user_ptr[1];\n\n\t\t\tdev_put(wdev->netdev);\n\t\t} else {\n\t\t\tdev_put(info->user_ptr[1]);\n\t\t}\n\t}\n\n\tif (info->user_ptr[0] &&\n\t    !(internal_flags & NL80211_FLAG_NO_WIPHY_MTX)) {\n\t\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\n\t\t \n\t\t__acquire(&rdev->wiphy.mtx);\n\t\twiphy_unlock(&rdev->wiphy);\n\t}\n\n\tif (internal_flags & NL80211_FLAG_NEED_RTNL)\n\t\trtnl_unlock();\n\n\t \n\tif (internal_flags & NL80211_FLAG_CLEAR_SKB) {\n\t\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\n\t\tmemset(nlmsg_data(nlh), 0, nlmsg_len(nlh));\n\t}\n}\n\nstatic int nl80211_set_sar_sub_specs(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct cfg80211_sar_specs *sar_specs,\n\t\t\t\t     struct nlattr *spec[], int index)\n{\n\tu32 range_index, i;\n\n\tif (!sar_specs || !spec)\n\t\treturn -EINVAL;\n\n\tif (!spec[NL80211_SAR_ATTR_SPECS_POWER] ||\n\t    !spec[NL80211_SAR_ATTR_SPECS_RANGE_INDEX])\n\t\treturn -EINVAL;\n\n\trange_index = nla_get_u32(spec[NL80211_SAR_ATTR_SPECS_RANGE_INDEX]);\n\n\t \n\tif (range_index >= rdev->wiphy.sar_capa->num_freq_ranges)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < index; i++) {\n\t\tif (sar_specs->sub_specs[i].freq_range_index == range_index)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsar_specs->sub_specs[index].power =\n\t\tnla_get_s32(spec[NL80211_SAR_ATTR_SPECS_POWER]);\n\n\tsar_specs->sub_specs[index].freq_range_index = range_index;\n\n\treturn 0;\n}\n\nstatic int nl80211_set_sar_specs(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct nlattr *spec[NL80211_SAR_ATTR_SPECS_MAX + 1];\n\tstruct nlattr *tb[NL80211_SAR_ATTR_MAX + 1];\n\tstruct cfg80211_sar_specs *sar_spec;\n\tenum nl80211_sar_type type;\n\tstruct nlattr *spec_list;\n\tu32 specs;\n\tint rem, err;\n\n\tif (!rdev->wiphy.sar_capa || !rdev->ops->set_sar_specs)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!info->attrs[NL80211_ATTR_SAR_SPEC])\n\t\treturn -EINVAL;\n\n\tnla_parse_nested(tb, NL80211_SAR_ATTR_MAX,\n\t\t\t info->attrs[NL80211_ATTR_SAR_SPEC],\n\t\t\t NULL, NULL);\n\n\tif (!tb[NL80211_SAR_ATTR_TYPE] || !tb[NL80211_SAR_ATTR_SPECS])\n\t\treturn -EINVAL;\n\n\ttype = nla_get_u32(tb[NL80211_SAR_ATTR_TYPE]);\n\tif (type != rdev->wiphy.sar_capa->type)\n\t\treturn -EINVAL;\n\n\tspecs = 0;\n\tnla_for_each_nested(spec_list, tb[NL80211_SAR_ATTR_SPECS], rem)\n\t\tspecs++;\n\n\tif (specs > rdev->wiphy.sar_capa->num_freq_ranges)\n\t\treturn -EINVAL;\n\n\tsar_spec = kzalloc(struct_size(sar_spec, sub_specs, specs), GFP_KERNEL);\n\tif (!sar_spec)\n\t\treturn -ENOMEM;\n\n\tsar_spec->type = type;\n\tspecs = 0;\n\tnla_for_each_nested(spec_list, tb[NL80211_SAR_ATTR_SPECS], rem) {\n\t\tnla_parse_nested(spec, NL80211_SAR_ATTR_SPECS_MAX,\n\t\t\t\t spec_list, NULL, NULL);\n\n\t\tswitch (type) {\n\t\tcase NL80211_SAR_TYPE_POWER:\n\t\t\tif (nl80211_set_sar_sub_specs(rdev, sar_spec,\n\t\t\t\t\t\t      spec, specs)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tspecs++;\n\t}\n\n\tsar_spec->num_sub_specs = specs;\n\n\trdev->cur_cmd_info = info;\n\terr = rdev_set_sar_specs(rdev, sar_spec);\n\trdev->cur_cmd_info = NULL;\nerror:\n\tkfree(sar_spec);\n\treturn err;\n}\n\n#define SELECTOR(__sel, name, value) \\\n\t((__sel) == (value)) ? NL80211_IFL_SEL_##name :\nint __missing_selector(void);\n#define IFLAGS(__val) INTERNAL_FLAG_SELECTORS(__val) __missing_selector()\n\nstatic const struct genl_ops nl80211_ops[] = {\n\t{\n\t\t.cmd = NL80211_CMD_GET_WIPHY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_wiphy,\n\t\t.dumpit = nl80211_dump_wiphy,\n\t\t.done = nl80211_dump_wiphy_done,\n\t\t \n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WIPHY),\n\t},\n};\n\nstatic const struct genl_small_ops nl80211_small_ops[] = {\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_wiphy,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_interface,\n\t\t.dumpit = nl80211_dump_interface,\n\t\t \n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t\t NL80211_FLAG_NEED_RTNL),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags =\n\t\t\tIFLAGS(NL80211_FLAG_NEED_WIPHY |\n\t\t\t       NL80211_FLAG_NEED_RTNL |\n\t\t\t        \n\t\t\t       NL80211_FLAG_NO_WIPHY_MTX),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_INTERFACE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_interface,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV |\n\t\t\t\t\t NL80211_FLAG_NEED_RTNL),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t \n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_CLEAR_SKB),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_CLEAR_SKB),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_KEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_key,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BEACON,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_set_beacon,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_AP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_start_ap,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_AP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.doit = nl80211_stop_ap,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_station,\n\t\t.dumpit = nl80211_dump_station,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_STATION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mpath,\n\t\t.dumpit = nl80211_dump_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MPP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mpp,\n\t\t.dumpit = nl80211_dump_mpp,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NEW_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_new_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_MPATH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_mpath,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_BSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_bss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_reg_do,\n\t\t.dumpit = nl80211_get_reg_dump,\n\t\t \n\t},\n#ifdef CONFIG_CFG80211_CRDA_SUPPORT\n\t{\n\t\t.cmd = NL80211_CMD_SET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_reg,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_REQ_SET_REG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_req_set_reg,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_RELOAD_REGDB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_reload_regdb,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_MESH_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_mesh_config,\n\t\t \n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MESH_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_mesh_config,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TRIGGER_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_trigger_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ABORT_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_abort_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nl80211_dump_scan,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_SCHED_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_sched_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_SCHED_SCAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_sched_scan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_AUTHENTICATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_authenticate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_CLEAR_SKB),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ASSOCIATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_associate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_CLEAR_SKB),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEAUTHENTICATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_deauthenticate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISASSOCIATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_disassociate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_IBSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_ibss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_IBSS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_ibss,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n#ifdef CONFIG_NL80211_TESTMODE\n\t{\n\t\t.cmd = NL80211_CMD_TESTMODE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_testmode_do,\n\t\t.dumpit = nl80211_testmode_dump,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WIPHY),\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_CONNECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_connect,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_CLEAR_SKB),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_CONNECT_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_connect_params,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_CLEAR_SKB),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DISCONNECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_disconnect,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WIPHY_NETNS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_wiphy_netns,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t\t NL80211_FLAG_NEED_RTNL |\n\t\t\t\t\t NL80211_FLAG_NO_WIPHY_MTX),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_SURVEY,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nl80211_dump_survey,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_CLEAR_SKB),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_setdel_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FLUSH_PMKSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_flush_pmksa,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_remain_on_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t \n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_cancel_remain_on_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_TX_BITRATE_MASK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_tx_bitrate_mask,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REGISTER_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_FRAME_WAIT_CANCEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_mgmt_cancel_wait,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_POWER_SAVE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_power_save,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_POWER_SAVE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_power_save,\n\t\t \n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CQM,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_cqm,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_CHANNEL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_channel,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_MESH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_mesh,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_MESH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_mesh,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_JOIN_OCB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_join_ocb,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_LEAVE_OCB,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_leave_ocb,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n#ifdef CONFIG_PM\n\t{\n\t\t.cmd = NL80211_CMD_GET_WOWLAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_wowlan,\n\t\t \n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WIPHY),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_WOWLAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_wowlan,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WIPHY),\n\t},\n#endif\n\t{\n\t\t.cmd = NL80211_CMD_SET_REKEY_OFFLOAD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_rekey_data,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_CLEAR_SKB),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_MGMT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_mgmt,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_OPER,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_oper,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UNEXPECTED_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_unexpected_frame,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PROBE_CLIENT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_probe_client,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REGISTER_BEACONS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_register_beacons,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WIPHY),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_NOACK_MAP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_noack_map,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_P2P_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_p2p_device,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV |\n\t\t\t\t\t NL80211_FLAG_NEED_RTNL),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_P2P_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_p2p_device,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t\t NL80211_FLAG_NEED_RTNL),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_START_NAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_nan,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV |\n\t\t\t\t\t NL80211_FLAG_NEED_RTNL),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_STOP_NAN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_stop_nan,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP |\n\t\t\t\t\t NL80211_FLAG_NEED_RTNL),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ADD_NAN_FUNCTION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_add_func,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_NAN_FUNCTION,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_del_func,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CHANGE_NAN_CONFIG,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_nan_change_config,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MCAST_RATE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mcast_rate,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MAC_ACL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_mac_acl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t\t NL80211_FLAG_MLO_UNSUPPORTED),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_RADAR_DETECT,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_start_radar_detection,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_NO_WIPHY_MTX |\n\t\t\t\t\t NL80211_FLAG_MLO_UNSUPPORTED),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_PROTOCOL_FEATURES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_protocol_features,\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_FT_IES,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_update_ft_ies,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CRIT_PROTOCOL_START,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_crit_protocol_start,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CRIT_PROTOCOL_STOP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_crit_protocol_stop,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_COALESCE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_coalesce,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WIPHY),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_COALESCE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_coalesce,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WIPHY),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_VENDOR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_vendor_cmd,\n\t\t.dumpit = nl80211_vendor_cmd_dump,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t\t NL80211_FLAG_CLEAR_SKB),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_QOS_MAP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_qos_map,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ADD_TX_TS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_add_tx_ts,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_MLO_UNSUPPORTED),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_TX_TS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_tx_ts,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_TDLS_CANCEL_CHANNEL_SWITCH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tdls_cancel_channel_switch,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_MULTICAST_TO_UNICAST,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_multicast_to_unicast,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_PMK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_pmk,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_CLEAR_SKB),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_DEL_PMK,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_del_pmk,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_EXTERNAL_AUTH,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_external_auth,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_CONTROL_PORT_FRAME,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_tx_control_port,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_GET_FTM_RESPONDER_STATS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_get_ftm_responder_stats,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PEER_MEASUREMENT_START,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_pmsr_start,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_NOTIFY_RADAR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_notify_radar_detection,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_UPDATE_OWE_INFO,\n\t\t.doit = nl80211_update_owe_info,\n\t\t.flags = GENL_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_PROBE_MESH_LINK,\n\t\t.doit = nl80211_probe_mesh_link,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_TID_CONFIG,\n\t\t.doit = nl80211_set_tid_config,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_SAR_SPECS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_sar_specs,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_WIPHY |\n\t\t\t\t\t NL80211_FLAG_NEED_RTNL),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_COLOR_CHANGE_REQUEST,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_color_change,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_FILS_AAD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nl80211_set_fils_aad,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ADD_LINK,\n\t\t.doit = nl80211_add_link,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REMOVE_LINK,\n\t\t.doit = nl80211_remove_link,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_ADD_LINK_STA,\n\t\t.doit = nl80211_add_link_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_MODIFY_LINK_STA,\n\t\t.doit = nl80211_modify_link_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_REMOVE_LINK_STA,\n\t\t.doit = nl80211_remove_link_station,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP |\n\t\t\t\t\t NL80211_FLAG_MLO_VALID_LINK_ID),\n\t},\n\t{\n\t\t.cmd = NL80211_CMD_SET_HW_TIMESTAMP,\n\t\t.doit = nl80211_set_hw_timestamp,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t\t.internal_flags = IFLAGS(NL80211_FLAG_NEED_NETDEV_UP),\n\t},\n};\n\nstatic struct genl_family nl80211_fam __ro_after_init = {\n\t.name = NL80211_GENL_NAME,\t \n\t.hdrsize = 0,\t\t\t \n\t.version = 1,\t\t\t \n\t.maxattr = NL80211_ATTR_MAX,\n\t.policy = nl80211_policy,\n\t.netnsok = true,\n\t.pre_doit = nl80211_pre_doit,\n\t.post_doit = nl80211_post_doit,\n\t.module = THIS_MODULE,\n\t.ops = nl80211_ops,\n\t.n_ops = ARRAY_SIZE(nl80211_ops),\n\t.small_ops = nl80211_small_ops,\n\t.n_small_ops = ARRAY_SIZE(nl80211_small_ops),\n\t.resv_start_op = NL80211_CMD_REMOVE_LINK_STA + 1,\n\t.mcgrps = nl80211_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(nl80211_mcgrps),\n\t.parallel_ops = true,\n};\n\n \n\nvoid nl80211_notify_wiphy(struct cfg80211_registered_device *rdev,\n\t\t\t  enum nl80211_commands cmd)\n{\n\tstruct sk_buff *msg;\n\tstruct nl80211_dump_wiphy_state state = {};\n\n\tWARN_ON(cmd != NL80211_CMD_NEW_WIPHY &&\n\t\tcmd != NL80211_CMD_DEL_WIPHY);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_wiphy(rdev, cmd, msg, 0, 0, 0, &state) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nvoid nl80211_notify_iface(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\tenum nl80211_commands cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_iface(msg, 0, 0, 0, rdev, wdev, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nstatic int nl80211_add_scan_req(struct sk_buff *msg,\n\t\t\t\tstruct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_scan_request *req = rdev->scan_req;\n\tstruct nlattr *nest;\n\tint i;\n\tstruct cfg80211_scan_info *info;\n\n\tif (WARN_ON(!req))\n\t\treturn 0;\n\n\tnest = nla_nest_start_noflag(msg, NL80211_ATTR_SCAN_SSIDS);\n\tif (!nest)\n\t\tgoto nla_put_failure;\n\tfor (i = 0; i < req->n_ssids; i++) {\n\t\tif (nla_put(msg, i, req->ssids[i].ssid_len, req->ssids[i].ssid))\n\t\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(msg, nest);\n\n\tif (req->flags & NL80211_SCAN_FLAG_FREQ_KHZ) {\n\t\tnest = nla_nest_start(msg, NL80211_ATTR_SCAN_FREQ_KHZ);\n\t\tif (!nest)\n\t\t\tgoto nla_put_failure;\n\t\tfor (i = 0; i < req->n_channels; i++) {\n\t\t\tif (nla_put_u32(msg, i,\n\t\t\t\t   ieee80211_channel_to_khz(req->channels[i])))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(msg, nest);\n\t} else {\n\t\tnest = nla_nest_start_noflag(msg,\n\t\t\t\t\t     NL80211_ATTR_SCAN_FREQUENCIES);\n\t\tif (!nest)\n\t\t\tgoto nla_put_failure;\n\t\tfor (i = 0; i < req->n_channels; i++) {\n\t\t\tif (nla_put_u32(msg, i, req->channels[i]->center_freq))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(msg, nest);\n\t}\n\n\tif (req->ie &&\n\t    nla_put(msg, NL80211_ATTR_IE, req->ie_len, req->ie))\n\t\tgoto nla_put_failure;\n\n\tif (req->flags &&\n\t    nla_put_u32(msg, NL80211_ATTR_SCAN_FLAGS, req->flags))\n\t\tgoto nla_put_failure;\n\n\tinfo = rdev->int_scan_req ? &rdev->int_scan_req->info :\n\t\t&rdev->scan_req->info;\n\tif (info->scan_start_tsf &&\n\t    (nla_put_u64_64bit(msg, NL80211_ATTR_SCAN_START_TIME_TSF,\n\t\t\t       info->scan_start_tsf, NL80211_BSS_PAD) ||\n\t     nla_put(msg, NL80211_ATTR_SCAN_START_TIME_TSF_BSSID, ETH_ALEN,\n\t\t     info->tsf_bssid)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n nla_put_failure:\n\treturn -ENOBUFS;\n}\n\nstatic int nl80211_prep_scan_msg(struct sk_buff *msg,\n\t\t\t\t struct cfg80211_registered_device *rdev,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t u32 portid, u32 seq, int flags,\n\t\t\t\t u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, portid, seq, flags, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\t \n\tnl80211_add_scan_req(msg, rdev);\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int\nnl80211_prep_sched_scan_msg(struct sk_buff *msg,\n\t\t\t    struct cfg80211_sched_scan_request *req, u32 cmd)\n{\n\tvoid *hdr;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr)\n\t\treturn -1;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY,\n\t\t\twiphy_to_rdev(req->wiphy)->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, req->dev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, req->reqid,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nvoid nl80211_send_scan_start(struct cfg80211_registered_device *rdev,\n\t\t\t     struct wireless_dev *wdev)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_prep_scan_msg(msg, rdev, wdev, 0, 0, 0,\n\t\t\t\t  NL80211_CMD_TRIGGER_SCAN) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nstruct sk_buff *nl80211_build_scan_msg(struct cfg80211_registered_device *rdev,\n\t\t\t\t       struct wireless_dev *wdev, bool aborted)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn NULL;\n\n\tif (nl80211_prep_scan_msg(msg, rdev, wdev, 0, 0, 0,\n\t\t\t\t  aborted ? NL80211_CMD_SCAN_ABORTED :\n\t\t\t\t\t    NL80211_CMD_NEW_SCAN_RESULTS) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn NULL;\n\t}\n\n\treturn msg;\n}\n\n \nvoid nl80211_send_scan_msg(struct cfg80211_registered_device *rdev,\n\t\t\t   struct sk_buff *msg)\n{\n\tif (!msg)\n\t\treturn;\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nvoid nl80211_send_sched_scan(struct cfg80211_sched_scan_request *req, u32 cmd)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_prep_sched_scan_msg(msg, req, cmd) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(req->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_SCAN, GFP_KERNEL);\n}\n\nstatic bool nl80211_reg_change_event_fill(struct sk_buff *msg,\n\t\t\t\t\t  struct regulatory_request *request)\n{\n\t \n\tif (nla_put_u8(msg, NL80211_ATTR_REG_INITIATOR, request->initiator))\n\t\tgoto nla_put_failure;\n\n\tif (request->alpha2[0] == '0' && request->alpha2[1] == '0') {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_WORLD))\n\t\t\tgoto nla_put_failure;\n\t} else if (request->alpha2[0] == '9' && request->alpha2[1] == '9') {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_CUSTOM_WORLD))\n\t\t\tgoto nla_put_failure;\n\t} else if ((request->alpha2[0] == '9' && request->alpha2[1] == '8') ||\n\t\t   request->intersect) {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_INTERSECTION))\n\t\t\tgoto nla_put_failure;\n\t} else {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_REG_TYPE,\n\t\t\t       NL80211_REGDOM_TYPE_COUNTRY) ||\n\t\t    nla_put_string(msg, NL80211_ATTR_REG_ALPHA2,\n\t\t\t\t   request->alpha2))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (request->wiphy_idx != WIPHY_IDX_INVALID) {\n\t\tstruct wiphy *wiphy = wiphy_idx_to_wiphy(request->wiphy_idx);\n\n\t\tif (wiphy &&\n\t\t    nla_put_u32(msg, NL80211_ATTR_WIPHY, request->wiphy_idx))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (wiphy &&\n\t\t    wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_WIPHY_SELF_MANAGED_REG))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn true;\n\nnla_put_failure:\n\treturn false;\n}\n\n \nvoid nl80211_common_reg_change_event(enum nl80211_commands cmd_id,\n\t\t\t\t     struct regulatory_request *request)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd_id);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (!nl80211_reg_change_event_fill(msg, request))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(&nl80211_fam, msg, 0,\n\t\t\t\tNL80211_MCGRP_REGULATORY, GFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_mlme_event(struct cfg80211_registered_device *rdev,\n\t\t\t\t    struct net_device *netdev,\n\t\t\t\t    const u8 *buf, size_t len,\n\t\t\t\t    enum nl80211_commands cmd, gfp_t gfp,\n\t\t\t\t    int uapsd_queues, const u8 *req_ies,\n\t\t\t\t    size_t req_ies_len, bool reconnect)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + len + req_ies_len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, len, buf) ||\n\t    (req_ies &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, req_ies_len, req_ies)))\n\t\tgoto nla_put_failure;\n\n\tif (reconnect && nla_put_flag(msg, NL80211_ATTR_RECONNECT_REQUESTED))\n\t\tgoto nla_put_failure;\n\n\tif (uapsd_queues >= 0) {\n\t\tstruct nlattr *nla_wmm =\n\t\t\tnla_nest_start_noflag(msg, NL80211_ATTR_STA_WME);\n\t\tif (!nla_wmm)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u8(msg, NL80211_STA_WME_UAPSD_QUEUES,\n\t\t\t       uapsd_queues))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, nla_wmm);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_rx_auth(struct cfg80211_registered_device *rdev,\n\t\t\t  struct net_device *netdev, const u8 *buf,\n\t\t\t  size_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_AUTHENTICATE, gfp, -1, NULL, 0,\n\t\t\t\tfalse);\n}\n\nvoid nl80211_send_rx_assoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev,\n\t\t\t   struct cfg80211_rx_assoc_resp *data)\n{\n\tnl80211_send_mlme_event(rdev, netdev, data->buf, data->len,\n\t\t\t\tNL80211_CMD_ASSOCIATE, GFP_KERNEL,\n\t\t\t\tdata->uapsd_queues,\n\t\t\t\tdata->req_ies, data->req_ies_len, false);\n}\n\nvoid nl80211_send_deauth(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev, const u8 *buf,\n\t\t\t size_t len, bool reconnect, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DEAUTHENTICATE, gfp, -1, NULL, 0,\n\t\t\t\treconnect);\n}\n\nvoid nl80211_send_disassoc(struct cfg80211_registered_device *rdev,\n\t\t\t   struct net_device *netdev, const u8 *buf,\n\t\t\t   size_t len, bool reconnect, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_DISASSOCIATE, gfp, -1, NULL, 0,\n\t\t\t\treconnect);\n}\n\nvoid cfg80211_rx_unprot_mlme_mgmt(struct net_device *dev, const u8 *buf,\n\t\t\t\t  size_t len)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tconst struct ieee80211_mgmt *mgmt = (void *)buf;\n\tu32 cmd;\n\n\tif (WARN_ON(len < 2))\n\t\treturn;\n\n\tif (ieee80211_is_deauth(mgmt->frame_control)) {\n\t\tcmd = NL80211_CMD_UNPROT_DEAUTHENTICATE;\n\t} else if (ieee80211_is_disassoc(mgmt->frame_control)) {\n\t\tcmd = NL80211_CMD_UNPROT_DISASSOCIATE;\n\t} else if (ieee80211_is_beacon(mgmt->frame_control)) {\n\t\tif (wdev->unprot_beacon_reported &&\n\t\t    elapsed_jiffies_msecs(wdev->unprot_beacon_reported) < 10000)\n\t\t\treturn;\n\t\tcmd = NL80211_CMD_UNPROT_BEACON;\n\t\twdev->unprot_beacon_reported = jiffies;\n\t} else {\n\t\treturn;\n\t}\n\n\ttrace_cfg80211_rx_unprot_mlme_mgmt(dev, buf, len);\n\tnl80211_send_mlme_event(rdev, dev, buf, len, cmd, GFP_ATOMIC, -1,\n\t\t\t\tNULL, 0, false);\n}\nEXPORT_SYMBOL(cfg80211_rx_unprot_mlme_mgmt);\n\nstatic void nl80211_send_mlme_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\t      struct net_device *netdev, int cmd,\n\t\t\t\t      const u8 *addr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put_flag(msg, NL80211_ATTR_TIMED_OUT) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_auth_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, const u8 *addr,\n\t\t\t       gfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_AUTHENTICATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_assoc_timeout(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *addr,\n\t\t\t\tgfp_t gfp)\n{\n\tnl80211_send_mlme_timeout(rdev, netdev, NL80211_CMD_ASSOCIATE,\n\t\t\t\t  addr, gfp);\n}\n\nvoid nl80211_send_connect_result(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev,\n\t\t\t\t struct cfg80211_connect_resp_params *cr,\n\t\t\t\t gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tunsigned int link;\n\tsize_t link_info_size = 0;\n\tconst u8 *connected_addr = cr->valid_links ?\n\t\t\t\t   cr->ap_mld_addr : cr->links[0].bssid;\n\n\tif (cr->valid_links) {\n\t\tfor_each_valid_link(cr, link) {\n\t\t\t \n\t\t\tlink_info_size += NLA_HDRLEN;\n\t\t\t \n\t\t\tlink_info_size += nla_total_size(sizeof(u8));\n\t\t\tlink_info_size += cr->links[link].addr ?\n\t\t\t\t\t  nla_total_size(ETH_ALEN) : 0;\n\t\t\tlink_info_size += (cr->links[link].bssid ||\n\t\t\t\t\t   cr->links[link].bss) ?\n\t\t\t\t\t  nla_total_size(ETH_ALEN) : 0;\n\t\t\tlink_info_size += nla_total_size(sizeof(u16));\n\t\t}\n\t}\n\n\tmsg = nlmsg_new(100 + cr->req_ie_len + cr->resp_ie_len +\n\t\t\tcr->fils.kek_len + cr->fils.pmk_len +\n\t\t\t(cr->fils.pmkid ? WLAN_PMKID_LEN : 0) + link_info_size,\n\t\t\tgfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (connected_addr &&\n\t     nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, connected_addr)) ||\n\t    nla_put_u16(msg, NL80211_ATTR_STATUS_CODE,\n\t\t\tcr->status < 0 ? WLAN_STATUS_UNSPECIFIED_FAILURE :\n\t\t\tcr->status) ||\n\t    (cr->status < 0 &&\n\t     (nla_put_flag(msg, NL80211_ATTR_TIMED_OUT) ||\n\t      nla_put_u32(msg, NL80211_ATTR_TIMEOUT_REASON,\n\t\t\t  cr->timeout_reason))) ||\n\t    (cr->req_ie &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, cr->req_ie_len, cr->req_ie)) ||\n\t    (cr->resp_ie &&\n\t     nla_put(msg, NL80211_ATTR_RESP_IE, cr->resp_ie_len,\n\t\t     cr->resp_ie)) ||\n\t    (cr->fils.update_erp_next_seq_num &&\n\t     nla_put_u16(msg, NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM,\n\t\t\t cr->fils.erp_next_seq_num)) ||\n\t    (cr->status == WLAN_STATUS_SUCCESS &&\n\t     ((cr->fils.kek &&\n\t       nla_put(msg, NL80211_ATTR_FILS_KEK, cr->fils.kek_len,\n\t\t       cr->fils.kek)) ||\n\t      (cr->fils.pmk &&\n\t       nla_put(msg, NL80211_ATTR_PMK, cr->fils.pmk_len, cr->fils.pmk)) ||\n\t      (cr->fils.pmkid &&\n\t       nla_put(msg, NL80211_ATTR_PMKID, WLAN_PMKID_LEN, cr->fils.pmkid)))))\n\t\tgoto nla_put_failure;\n\n\tif (cr->valid_links) {\n\t\tint i = 1;\n\t\tstruct nlattr *nested;\n\n\t\tnested = nla_nest_start(msg, NL80211_ATTR_MLO_LINKS);\n\t\tif (!nested)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor_each_valid_link(cr, link) {\n\t\t\tstruct nlattr *nested_mlo_links;\n\t\t\tconst u8 *bssid = cr->links[link].bss ?\n\t\t\t\t\t  cr->links[link].bss->bssid :\n\t\t\t\t\t  cr->links[link].bssid;\n\n\t\t\tnested_mlo_links = nla_nest_start(msg, i);\n\t\t\tif (!nested_mlo_links)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link) ||\n\t\t\t    (bssid &&\n\t\t\t     nla_put(msg, NL80211_ATTR_BSSID, ETH_ALEN, bssid)) ||\n\t\t\t    (cr->links[link].addr &&\n\t\t\t     nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN,\n\t\t\t\t     cr->links[link].addr)) ||\n\t\t\t    nla_put_u16(msg, NL80211_ATTR_STATUS_CODE,\n\t\t\t\t\tcr->links[link].status))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, nested_mlo_links);\n\t\t\ti++;\n\t\t}\n\t\tnla_nest_end(msg, nested);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_roamed(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev,\n\t\t\t struct cfg80211_roam_info *info, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tsize_t link_info_size = 0;\n\tunsigned int link;\n\tconst u8 *connected_addr = info->ap_mld_addr ?\n\t\t\t\t   info->ap_mld_addr :\n\t\t\t\t   (info->links[0].bss ?\n\t\t\t\t    info->links[0].bss->bssid :\n\t\t\t\t    info->links[0].bssid);\n\n\tif (info->valid_links) {\n\t\tfor_each_valid_link(info, link) {\n\t\t\t \n\t\t\tlink_info_size += NLA_HDRLEN;\n\t\t\t \n\t\t\tlink_info_size += nla_total_size(sizeof(u8));\n\t\t\tlink_info_size += info->links[link].addr ?\n\t\t\t\t\t  nla_total_size(ETH_ALEN) : 0;\n\t\t\tlink_info_size += (info->links[link].bssid ||\n\t\t\t\t\t   info->links[link].bss) ?\n\t\t\t\t\t  nla_total_size(ETH_ALEN) : 0;\n\t\t}\n\t}\n\n\tmsg = nlmsg_new(100 + info->req_ie_len + info->resp_ie_len +\n\t\t\tinfo->fils.kek_len + info->fils.pmk_len +\n\t\t\t(info->fils.pmkid ? WLAN_PMKID_LEN : 0) +\n\t\t\tlink_info_size, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_ROAM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, connected_addr) ||\n\t    (info->req_ie &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, info->req_ie_len,\n\t\t     info->req_ie)) ||\n\t    (info->resp_ie &&\n\t     nla_put(msg, NL80211_ATTR_RESP_IE, info->resp_ie_len,\n\t\t     info->resp_ie)) ||\n\t    (info->fils.update_erp_next_seq_num &&\n\t     nla_put_u16(msg, NL80211_ATTR_FILS_ERP_NEXT_SEQ_NUM,\n\t\t\t info->fils.erp_next_seq_num)) ||\n\t    (info->fils.kek &&\n\t     nla_put(msg, NL80211_ATTR_FILS_KEK, info->fils.kek_len,\n\t\t     info->fils.kek)) ||\n\t    (info->fils.pmk &&\n\t     nla_put(msg, NL80211_ATTR_PMK, info->fils.pmk_len, info->fils.pmk)) ||\n\t    (info->fils.pmkid &&\n\t     nla_put(msg, NL80211_ATTR_PMKID, WLAN_PMKID_LEN, info->fils.pmkid)))\n\t\tgoto nla_put_failure;\n\n\tif (info->valid_links) {\n\t\tint i = 1;\n\t\tstruct nlattr *nested;\n\n\t\tnested = nla_nest_start(msg, NL80211_ATTR_MLO_LINKS);\n\t\tif (!nested)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor_each_valid_link(info, link) {\n\t\t\tstruct nlattr *nested_mlo_links;\n\t\t\tconst u8 *bssid = info->links[link].bss ?\n\t\t\t\t\t  info->links[link].bss->bssid :\n\t\t\t\t\t  info->links[link].bssid;\n\n\t\t\tnested_mlo_links = nla_nest_start(msg, i);\n\t\t\tif (!nested_mlo_links)\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tif (nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link) ||\n\t\t\t    (bssid &&\n\t\t\t     nla_put(msg, NL80211_ATTR_BSSID, ETH_ALEN, bssid)) ||\n\t\t\t    (info->links[link].addr &&\n\t\t\t     nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN,\n\t\t\t\t     info->links[link].addr)))\n\t\t\t\tgoto nla_put_failure;\n\n\t\t\tnla_nest_end(msg, nested_mlo_links);\n\t\t\ti++;\n\t\t}\n\t\tnla_nest_end(msg, nested);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_port_authorized(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct net_device *netdev, const u8 *bssid,\n\t\t\t\t  const u8 *td_bitmap, u8 td_bitmap_len)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PORT_AUTHORIZED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\tif ((td_bitmap_len > 0) && td_bitmap)\n\t\tif (nla_put(msg, NL80211_ATTR_TD_BITMAP,\n\t\t\t    td_bitmap_len, td_bitmap))\n\t\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_disconnected(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u16 reason,\n\t\t\t       const u8 *ie, size_t ie_len, bool from_ap)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + ie_len, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (reason &&\n\t     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason)) ||\n\t    (from_ap &&\n\t     nla_put_flag(msg, NL80211_ATTR_DISCONNECTED_BY_AP)) ||\n\t    (ie && nla_put(msg, NL80211_ATTR_IE, ie_len, ie)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_links_removed(struct net_device *dev, u16 link_mask)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tstruct nlattr *links;\n\tvoid *hdr;\n\n\tASSERT_WDEV_LOCK(wdev);\n\ttrace_cfg80211_links_removed(dev, link_mask);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_CLIENT))\n\t\treturn;\n\n\tif (WARN_ON(!wdev->valid_links || !link_mask ||\n\t\t    (wdev->valid_links & link_mask) != link_mask ||\n\t\t    wdev->valid_links == link_mask))\n\t\treturn;\n\n\tcfg80211_wdev_release_link_bsses(wdev, link_mask);\n\twdev->valid_links &= ~link_mask;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_LINKS_REMOVED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tlinks = nla_nest_start(msg, NL80211_ATTR_MLO_LINKS);\n\tif (!links)\n\t\tgoto nla_put_failure;\n\n\twhile (link_mask) {\n\t\tstruct nlattr *link;\n\t\tint link_id = __ffs(link_mask);\n\n\t\tlink = nla_nest_start(msg, link_id + 1);\n\t\tif (!link)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link_id))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, link);\n\t\tlink_mask &= ~(1 << link_id);\n\t}\n\n\tnla_nest_end(msg, links);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_links_removed);\n\nvoid nl80211_send_ibss_bssid(struct cfg80211_registered_device *rdev,\n\t\t\t     struct net_device *netdev, const u8 *bssid,\n\t\t\t     gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_JOIN_IBSS);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_notify_new_peer_candidate(struct net_device *dev, const u8 *addr,\n\t\t\t\t\tconst u8 *ie, u8 ie_len,\n\t\t\t\t\tint sig_dbm, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_MESH_POINT))\n\t\treturn;\n\n\ttrace_cfg80211_notify_new_peer_candidate(dev, addr);\n\n\tmsg = nlmsg_new(100 + ie_len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NEW_PEER_CANDIDATE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    (ie_len && ie &&\n\t     nla_put(msg, NL80211_ATTR_IE, ie_len, ie)) ||\n\t    (sig_dbm &&\n\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_notify_new_peer_candidate);\n\nvoid nl80211_michael_mic_failure(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct net_device *netdev, const u8 *addr,\n\t\t\t\t enum nl80211_key_type key_type, int key_id,\n\t\t\t\t const u8 *tsc, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_MICHAEL_MIC_FAILURE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    (addr && nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_KEY_TYPE, key_type) ||\n\t    (key_id != -1 &&\n\t     nla_put_u8(msg, NL80211_ATTR_KEY_IDX, key_id)) ||\n\t    (tsc && nla_put(msg, NL80211_ATTR_KEY_SEQ, 6, tsc)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid nl80211_send_beacon_hint_event(struct wiphy *wiphy,\n\t\t\t\t    struct ieee80211_channel *channel_before,\n\t\t\t\t    struct ieee80211_channel *channel_after)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *nl_freq;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_REG_BEACON_HINT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\t \n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, get_wiphy_idx(wiphy)))\n\t\tgoto nla_put_failure;\n\n\t \n\tnl_freq = nla_nest_start_noflag(msg, NL80211_ATTR_FREQ_BEFORE);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_msg_put_channel(msg, wiphy, channel_before, false))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\t \n\tnl_freq = nla_nest_start_noflag(msg, NL80211_ATTR_FREQ_AFTER);\n\tif (!nl_freq)\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_msg_put_channel(msg, wiphy, channel_after, false))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, nl_freq);\n\n\tgenlmsg_end(msg, hdr);\n\n\trcu_read_lock();\n\tgenlmsg_multicast_allns(&nl80211_fam, msg, 0,\n\t\t\t\tNL80211_MCGRP_REGULATORY, GFP_ATOMIC);\n\trcu_read_unlock();\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nstatic void nl80211_send_remain_on_chan_event(\n\tint cmd, struct cfg80211_registered_device *rdev,\n\tstruct wireless_dev *wdev, u64 cookie,\n\tstruct ieee80211_channel *chan,\n\tunsigned int duration, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\t wdev->netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, chan->center_freq) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,\n\t\t\tNL80211_CHAN_NO_HT) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tif (cmd == NL80211_CMD_REMAIN_ON_CHANNEL &&\n\t    nla_put_u32(msg, NL80211_ATTR_DURATION, duration))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_assoc_comeback(struct net_device *netdev,\n\t\t\t     const u8 *ap_addr, u32 timeout)\n{\n\tstruct wireless_dev *wdev = netdev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_assoc_comeback(wdev, ap_addr, timeout);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_ASSOC_COMEBACK);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, ap_addr) ||\n\t    nla_put_u32(msg, NL80211_ATTR_TIMEOUT, timeout))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_assoc_comeback);\n\nvoid cfg80211_ready_on_channel(struct wireless_dev *wdev, u64 cookie,\n\t\t\t       struct ieee80211_channel *chan,\n\t\t\t       unsigned int duration, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ready_on_channel(wdev, cookie, chan, duration);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan,\n\t\t\t\t\t  duration, gfp);\n}\nEXPORT_SYMBOL(cfg80211_ready_on_channel);\n\nvoid cfg80211_remain_on_channel_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_ready_on_channel_expired(wdev, cookie, chan);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}\nEXPORT_SYMBOL(cfg80211_remain_on_channel_expired);\n\nvoid cfg80211_tx_mgmt_expired(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_tx_mgmt_expired(wdev, cookie, chan);\n\tnl80211_send_remain_on_chan_event(NL80211_CMD_FRAME_WAIT_CANCEL,\n\t\t\t\t\t  rdev, wdev, cookie, chan, 0, gfp);\n}\nEXPORT_SYMBOL(cfg80211_tx_mgmt_expired);\n\nvoid cfg80211_new_sta(struct net_device *dev, const u8 *mac_addr,\n\t\t      struct station_info *sinfo, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\n\ttrace_cfg80211_new_sta(dev, mac_addr, sinfo);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nl80211_send_station(msg, NL80211_CMD_NEW_STATION, 0, 0, 0,\n\t\t\t\t rdev, dev, mac_addr, sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\nEXPORT_SYMBOL(cfg80211_new_sta);\n\nvoid cfg80211_del_sta_sinfo(struct net_device *dev, const u8 *mac_addr,\n\t\t\t    struct station_info *sinfo, gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tstruct station_info empty_sinfo = {};\n\n\tif (!sinfo)\n\t\tsinfo = &empty_sinfo;\n\n\ttrace_cfg80211_del_sta(dev, mac_addr);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg) {\n\t\tcfg80211_sinfo_release_content(sinfo);\n\t\treturn;\n\t}\n\n\tif (nl80211_send_station(msg, NL80211_CMD_DEL_STATION, 0, 0, 0,\n\t\t\t\t rdev, dev, mac_addr, sinfo) < 0) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\nEXPORT_SYMBOL(cfg80211_del_sta_sinfo);\n\nvoid cfg80211_conn_failed(struct net_device *dev, const u8 *mac_addr,\n\t\t\t  enum nl80211_connect_failed_reason reason,\n\t\t\t  gfp_t gfp)\n{\n\tstruct wiphy *wiphy = dev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_GOODSIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONN_FAILED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac_addr) ||\n\t    nla_put_u32(msg, NL80211_ATTR_CONN_FAILED_REASON, reason))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_conn_failed);\n\nstatic bool __nl80211_unexpected_frame(struct net_device *dev, u8 cmd,\n\t\t\t\t       const u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 nlportid = READ_ONCE(wdev->ap_unexpected_nlportid);\n\n\tif (!nlportid)\n\t\treturn false;\n\n\tmsg = nlmsg_new(100, gfp);\n\tif (!msg)\n\t\treturn true;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn true;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\treturn true;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn true;\n}\n\nbool cfg80211_rx_spurious_frame(struct net_device *dev,\n\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool ret;\n\n\ttrace_cfg80211_rx_spurious_frame(dev, addr);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)) {\n\t\ttrace_cfg80211_return_bool(false);\n\t\treturn false;\n\t}\n\tret = __nl80211_unexpected_frame(dev, NL80211_CMD_UNEXPECTED_FRAME,\n\t\t\t\t\t addr, gfp);\n\ttrace_cfg80211_return_bool(ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(cfg80211_rx_spurious_frame);\n\nbool cfg80211_rx_unexpected_4addr_frame(struct net_device *dev,\n\t\t\t\t\tconst u8 *addr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tbool ret;\n\n\ttrace_cfg80211_rx_unexpected_4addr_frame(dev, addr);\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&\n\t\t    wdev->iftype != NL80211_IFTYPE_P2P_GO &&\n\t\t    wdev->iftype != NL80211_IFTYPE_AP_VLAN)) {\n\t\ttrace_cfg80211_return_bool(false);\n\t\treturn false;\n\t}\n\tret = __nl80211_unexpected_frame(dev,\n\t\t\t\t\t NL80211_CMD_UNEXPECTED_4ADDR_FRAME,\n\t\t\t\t\t addr, gfp);\n\ttrace_cfg80211_return_bool(ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(cfg80211_rx_unexpected_4addr_frame);\n\nint nl80211_send_mgmt(struct cfg80211_registered_device *rdev,\n\t\t      struct wireless_dev *wdev, u32 nlportid,\n\t\t      struct cfg80211_rx_info *info, gfp_t gfp)\n{\n\tstruct net_device *netdev = wdev->netdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(100 + info->len, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\tnetdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (info->have_link_id &&\n\t     nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, info->link_id)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ, KHZ_TO_MHZ(info->freq)) ||\n\t    nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ_OFFSET, info->freq % 1000) ||\n\t    (info->sig_dbm &&\n\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, info->sig_dbm)) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, info->len, info->buf) ||\n\t    (info->flags &&\n\t     nla_put_u32(msg, NL80211_ATTR_RXMGMT_FLAGS, info->flags)) ||\n\t    (info->rx_tstamp && nla_put_u64_64bit(msg,\n\t\t\t\t\t\t  NL80211_ATTR_RX_HW_TIMESTAMP,\n\t\t\t\t\t\t  info->rx_tstamp,\n\t\t\t\t\t\t  NL80211_ATTR_PAD)) ||\n\t    (info->ack_tstamp && nla_put_u64_64bit(msg,\n\t\t\t\t\t\t   NL80211_ATTR_TX_HW_TIMESTAMP,\n\t\t\t\t\t\t   info->ack_tstamp,\n\t\t\t\t\t\t   NL80211_ATTR_PAD)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nstatic void nl80211_frame_tx_status(struct wireless_dev *wdev,\n\t\t\t\t    struct cfg80211_tx_status *status,\n\t\t\t\t    gfp_t gfp, enum nl80211_commands command)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct net_device *netdev = wdev->netdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (command == NL80211_CMD_FRAME_TX_STATUS)\n\t\ttrace_cfg80211_mgmt_tx_status(wdev, status->cookie,\n\t\t\t\t\t      status->ack);\n\telse\n\t\ttrace_cfg80211_control_port_tx_status(wdev, status->cookie,\n\t\t\t\t\t\t      status->ack);\n\n\tmsg = nlmsg_new(100 + status->len, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, command);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    (netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t   netdev->ifindex)) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_FRAME, status->len, status->buf) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, status->cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (status->ack && nla_put_flag(msg, NL80211_ATTR_ACK)) ||\n\t    (status->tx_tstamp &&\n\t     nla_put_u64_64bit(msg, NL80211_ATTR_TX_HW_TIMESTAMP,\n\t\t\t       status->tx_tstamp, NL80211_ATTR_PAD)) ||\n\t    (status->ack_tstamp &&\n\t     nla_put_u64_64bit(msg, NL80211_ATTR_RX_HW_TIMESTAMP,\n\t\t\t       status->ack_tstamp, NL80211_ATTR_PAD)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_control_port_tx_status(struct wireless_dev *wdev, u64 cookie,\n\t\t\t\t     const u8 *buf, size_t len, bool ack,\n\t\t\t\t     gfp_t gfp)\n{\n\tstruct cfg80211_tx_status status = {\n\t\t.cookie = cookie,\n\t\t.buf = buf,\n\t\t.len = len,\n\t\t.ack = ack\n\t};\n\n\tnl80211_frame_tx_status(wdev, &status, gfp,\n\t\t\t\tNL80211_CMD_CONTROL_PORT_FRAME_TX_STATUS);\n}\nEXPORT_SYMBOL(cfg80211_control_port_tx_status);\n\nvoid cfg80211_mgmt_tx_status_ext(struct wireless_dev *wdev,\n\t\t\t\t struct cfg80211_tx_status *status, gfp_t gfp)\n{\n\tnl80211_frame_tx_status(wdev, status, gfp, NL80211_CMD_FRAME_TX_STATUS);\n}\nEXPORT_SYMBOL(cfg80211_mgmt_tx_status_ext);\n\nstatic int __nl80211_rx_control_port(struct net_device *dev,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     bool unencrypted,\n\t\t\t\t     int link_id,\n\t\t\t\t     gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct ethhdr *ehdr = eth_hdr(skb);\n\tconst u8 *addr = ehdr->h_source;\n\tu16 proto = be16_to_cpu(skb->protocol);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *frame;\n\n\tu32 nlportid = READ_ONCE(wdev->conn_owner_nlportid);\n\n\tif (!nlportid)\n\t\treturn -ENOENT;\n\n\tmsg = nlmsg_new(100 + skb->len, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CONTROL_PORT_FRAME);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    nla_put_u16(msg, NL80211_ATTR_CONTROL_PORT_ETHERTYPE, proto) ||\n\t    (link_id >= 0 &&\n\t     nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link_id)) ||\n\t    (unencrypted && nla_put_flag(msg,\n\t\t\t\t\t NL80211_ATTR_CONTROL_PORT_NO_ENCRYPT)))\n\t\tgoto nla_put_failure;\n\n\tframe = nla_reserve(msg, NL80211_ATTR_FRAME, skb->len);\n\tif (!frame)\n\t\tgoto nla_put_failure;\n\n\tskb_copy_bits(skb, 0, nla_data(frame), skb->len);\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\n\nbool cfg80211_rx_control_port(struct net_device *dev, struct sk_buff *skb,\n\t\t\t      bool unencrypted, int link_id)\n{\n\tint ret;\n\n\ttrace_cfg80211_rx_control_port(dev, skb, unencrypted, link_id);\n\tret = __nl80211_rx_control_port(dev, skb, unencrypted, link_id,\n\t\t\t\t\tGFP_ATOMIC);\n\ttrace_cfg80211_return_bool(ret == 0);\n\treturn ret == 0;\n}\nEXPORT_SYMBOL(cfg80211_rx_control_port);\n\nstatic struct sk_buff *cfg80211_prepare_cqm(struct net_device *dev,\n\t\t\t\t\t    const char *mac, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tvoid **cb;\n\n\tif (!msg)\n\t\treturn NULL;\n\n\tcb = (void **)msg->cb;\n\n\tcb[0] = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_NOTIFY_CQM);\n\tif (!cb[0]) {\n\t\tnlmsg_free(msg);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (mac && nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac))\n\t\tgoto nla_put_failure;\n\n\tcb[1] = nla_nest_start_noflag(msg, NL80211_ATTR_CQM);\n\tif (!cb[1])\n\t\tgoto nla_put_failure;\n\n\tcb[2] = rdev;\n\n\treturn msg;\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn NULL;\n}\n\nstatic void cfg80211_send_cqm(struct sk_buff *msg, gfp_t gfp)\n{\n\tvoid **cb = (void **)msg->cb;\n\tstruct cfg80211_registered_device *rdev = cb[2];\n\n\tnla_nest_end(msg, cb[1]);\n\tgenlmsg_end(msg, cb[0]);\n\n\tmemset(msg->cb, 0, sizeof(msg->cb));\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n}\n\nvoid cfg80211_cqm_rssi_notify(struct net_device *dev,\n\t\t\t      enum nl80211_cqm_rssi_threshold_event rssi_event,\n\t\t\t      s32 rssi_level, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_cqm_config *cqm_config;\n\n\ttrace_cfg80211_cqm_rssi_notify(dev, rssi_event, rssi_level);\n\n\tif (WARN_ON(rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW &&\n\t\t    rssi_event != NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH))\n\t\treturn;\n\n\trcu_read_lock();\n\tcqm_config = rcu_dereference(wdev->cqm_config);\n\tif (cqm_config) {\n\t\tcqm_config->last_rssi_event_value = rssi_level;\n\t\tcqm_config->last_rssi_event_type = rssi_event;\n\t\twiphy_work_queue(wdev->wiphy, &wdev->cqm_rssi_work);\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(cfg80211_cqm_rssi_notify);\n\nvoid cfg80211_cqm_rssi_notify_work(struct wiphy *wiphy, struct wiphy_work *work)\n{\n\tstruct wireless_dev *wdev = container_of(work, struct wireless_dev,\n\t\t\t\t\t\t cqm_rssi_work);\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tenum nl80211_cqm_rssi_threshold_event rssi_event;\n\tstruct cfg80211_cqm_config *cqm_config;\n\tstruct sk_buff *msg;\n\ts32 rssi_level;\n\n\twdev_lock(wdev);\n\tcqm_config = rcu_dereference_protected(wdev->cqm_config,\n\t\t\t\t\t       lockdep_is_held(&wdev->mtx));\n\tif (!cqm_config)\n\t\tgoto unlock;\n\n\tif (cqm_config->use_range_api)\n\t\tcfg80211_cqm_rssi_update(rdev, wdev->netdev, cqm_config);\n\n\trssi_level = cqm_config->last_rssi_event_value;\n\trssi_event = cqm_config->last_rssi_event_type;\n\n\tmsg = cfg80211_prepare_cqm(wdev->netdev, NULL, GFP_KERNEL);\n\tif (!msg)\n\t\tgoto unlock;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,\n\t\t\trssi_event))\n\t\tgoto nla_put_failure;\n\n\tif (rssi_level && nla_put_s32(msg, NL80211_ATTR_CQM_RSSI_LEVEL,\n\t\t\t\t      rssi_level))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, GFP_KERNEL);\n\n\tgoto unlock;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n unlock:\n\twdev_unlock(wdev);\n}\n\nvoid cfg80211_cqm_txe_notify(struct net_device *dev,\n\t\t\t     const u8 *peer, u32 num_packets,\n\t\t\t     u32 rate, u32 intvl, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = cfg80211_prepare_cqm(dev, peer, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_PKTS, num_packets))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_RATE, rate))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_TXE_INTVL, intvl))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_txe_notify);\n\nvoid cfg80211_cqm_pktloss_notify(struct net_device *dev,\n\t\t\t\t const u8 *peer, u32 num_packets, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\ttrace_cfg80211_cqm_pktloss_notify(dev, peer, num_packets);\n\n\tmsg = cfg80211_prepare_cqm(dev, peer, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_CQM_PKT_LOSS_EVENT, num_packets))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_pktloss_notify);\n\nvoid cfg80211_cqm_beacon_loss_notify(struct net_device *dev, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\n\tmsg = cfg80211_prepare_cqm(dev, NULL, gfp);\n\tif (!msg)\n\t\treturn;\n\n\tif (nla_put_flag(msg, NL80211_ATTR_CQM_BEACON_LOSS_EVENT))\n\t\tgoto nla_put_failure;\n\n\tcfg80211_send_cqm(msg, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_cqm_beacon_loss_notify);\n\nstatic void nl80211_gtk_rekey_notify(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *netdev, const u8 *bssid,\n\t\t\t\t     const u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *rekey_attr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_REKEY_OFFLOAD);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\n\trekey_attr = nla_nest_start_noflag(msg, NL80211_ATTR_REKEY_DATA);\n\tif (!rekey_attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(msg, NL80211_REKEY_DATA_REPLAY_CTR,\n\t\t    NL80211_REPLAY_CTR_LEN, replay_ctr))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, rekey_attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,\n\t\t\t       const u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_gtk_rekey_notify(dev, bssid);\n\tnl80211_gtk_rekey_notify(rdev, dev, bssid, replay_ctr, gfp);\n}\nEXPORT_SYMBOL(cfg80211_gtk_rekey_notify);\n\nstatic void\nnl80211_pmksa_candidate_notify(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, int index,\n\t\t\t       const u8 *bssid, bool preauth, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *attr;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PMKSA_CANDIDATE);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tattr = nla_nest_start_noflag(msg, NL80211_ATTR_PMKSA_CANDIDATE);\n\tif (!attr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_PMKSA_CANDIDATE_INDEX, index) ||\n\t    nla_put(msg, NL80211_PMKSA_CANDIDATE_BSSID, ETH_ALEN, bssid) ||\n\t    (preauth &&\n\t     nla_put_flag(msg, NL80211_PMKSA_CANDIDATE_PREAUTH)))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(msg, attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,\n\t\t\t\t     const u8 *bssid, bool preauth, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\ttrace_cfg80211_pmksa_candidate_notify(dev, index, bssid, preauth);\n\tnl80211_pmksa_candidate_notify(rdev, dev, index, bssid, preauth, gfp);\n}\nEXPORT_SYMBOL(cfg80211_pmksa_candidate_notify);\n\nstatic void nl80211_ch_switch_notify(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *netdev,\n\t\t\t\t     unsigned int link_id,\n\t\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t\t     gfp_t gfp,\n\t\t\t\t     enum nl80211_commands notif,\n\t\t\t\t     u8 count, bool quiet, u16 punct_bitmap)\n{\n\tstruct wireless_dev *wdev = netdev->ieee80211_ptr;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, notif);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (wdev->valid_links &&\n\t    nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link_id))\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_send_chandef(msg, chandef))\n\t\tgoto nla_put_failure;\n\n\tif (notif == NL80211_CMD_CH_SWITCH_STARTED_NOTIFY) {\n\t\tif (nla_put_u32(msg, NL80211_ATTR_CH_SWITCH_COUNT, count))\n\t\t\tgoto nla_put_failure;\n\t\tif (quiet &&\n\t\t    nla_put_flag(msg, NL80211_ATTR_CH_SWITCH_BLOCK_TX))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_PUNCT_BITMAP, punct_bitmap))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_ch_switch_notify(struct net_device *dev,\n\t\t\t       struct cfg80211_chan_def *chandef,\n\t\t\t       unsigned int link_id, u16 punct_bitmap)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tASSERT_WDEV_LOCK(wdev);\n\tWARN_INVALID_LINK_ID(wdev, link_id);\n\n\ttrace_cfg80211_ch_switch_notify(dev, chandef, link_id, punct_bitmap);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (!WARN_ON(!wdev->links[link_id].client.current_bss))\n\t\t\tcfg80211_update_assoc_bss_entry(wdev, link_id,\n\t\t\t\t\t\t\tchandef->chan);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\twdev->u.mesh.chandef = *chandef;\n\t\twdev->u.mesh.preset_chandef = *chandef;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\twdev->links[link_id].ap.chandef = *chandef;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\twdev->u.ibss.chandef = *chandef;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tcfg80211_sched_dfs_chan_update(rdev);\n\n\tnl80211_ch_switch_notify(rdev, dev, link_id, chandef, GFP_KERNEL,\n\t\t\t\t NL80211_CMD_CH_SWITCH_NOTIFY, 0, false,\n\t\t\t\t punct_bitmap);\n}\nEXPORT_SYMBOL(cfg80211_ch_switch_notify);\n\nvoid cfg80211_ch_switch_started_notify(struct net_device *dev,\n\t\t\t\t       struct cfg80211_chan_def *chandef,\n\t\t\t\t       unsigned int link_id, u8 count,\n\t\t\t\t       bool quiet, u16 punct_bitmap)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tASSERT_WDEV_LOCK(wdev);\n\tWARN_INVALID_LINK_ID(wdev, link_id);\n\n\ttrace_cfg80211_ch_switch_started_notify(dev, chandef, link_id,\n\t\t\t\t\t\tpunct_bitmap);\n\n\n\tnl80211_ch_switch_notify(rdev, dev, link_id, chandef, GFP_KERNEL,\n\t\t\t\t NL80211_CMD_CH_SWITCH_STARTED_NOTIFY,\n\t\t\t\t count, quiet, punct_bitmap);\n}\nEXPORT_SYMBOL(cfg80211_ch_switch_started_notify);\n\nint cfg80211_bss_color_notify(struct net_device *dev,\n\t\t\t      enum nl80211_commands cmd, u8 count,\n\t\t\t      u64 color_bitmap)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\ttrace_cfg80211_bss_color_notify(dev, cmd, count, color_bitmap);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, cmd);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (cmd == NL80211_CMD_COLOR_CHANGE_STARTED &&\n\t    nla_put_u32(msg, NL80211_ATTR_COLOR_CHANGE_COUNT, count))\n\t\tgoto nla_put_failure;\n\n\tif (cmd == NL80211_CMD_OBSS_COLOR_COLLISION &&\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_OBSS_COLOR_BITMAP,\n\t\t\t      color_bitmap, NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy),\n\t\t\t\t       msg, 0, NL80211_MCGRP_MLME, GFP_KERNEL);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(cfg80211_bss_color_notify);\n\nvoid\nnl80211_radar_notify(struct cfg80211_registered_device *rdev,\n\t\t     const struct cfg80211_chan_def *chandef,\n\t\t     enum nl80211_radar_event event,\n\t\t     struct net_device *netdev, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_RADAR_DETECT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\t \n\tif (netdev) {\n\t\tstruct wireless_dev *wdev = netdev->ieee80211_ptr;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t\t      NL80211_ATTR_PAD))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_RADAR_EVENT, event))\n\t\tgoto nla_put_failure;\n\n\tif (nl80211_send_chandef(msg, chandef))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\n\nvoid cfg80211_sta_opmode_change_notify(struct net_device *dev, const u8 *mac,\n\t\t\t\t       struct sta_opmode_info *sta_opmode,\n\t\t\t\t       gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tvoid *hdr;\n\n\tif (WARN_ON(!mac))\n\t\treturn;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_STA_OPMODE_CHANGED);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, mac))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_SMPS_MODE_CHANGED) &&\n\t    nla_put_u8(msg, NL80211_ATTR_SMPS_MODE, sta_opmode->smps_mode))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_MAX_BW_CHANGED) &&\n\t    nla_put_u32(msg, NL80211_ATTR_CHANNEL_WIDTH, sta_opmode->bw))\n\t\tgoto nla_put_failure;\n\n\tif ((sta_opmode->changed & STA_OPMODE_N_SS_CHANGED) &&\n\t    nla_put_u8(msg, NL80211_ATTR_NSS, sta_opmode->rx_nss))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\n\treturn;\n\nnla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_sta_opmode_change_notify);\n\nvoid cfg80211_probe_status(struct net_device *dev, const u8 *addr,\n\t\t\t   u64 cookie, bool acked, s32 ack_signal,\n\t\t\t   bool is_valid_ack_signal, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_probe_status(dev, addr, cookie, acked);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PROBE_CLIENT);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, cookie,\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (acked && nla_put_flag(msg, NL80211_ATTR_ACK)) ||\n\t    (is_valid_ack_signal && nla_put_s32(msg, NL80211_ATTR_ACK_SIGNAL,\n\t\t\t\t\t\tack_signal)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_probe_status);\n\nvoid cfg80211_report_obss_beacon_khz(struct wiphy *wiphy, const u8 *frame,\n\t\t\t\t     size_t len, int freq, int sig_dbm)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct cfg80211_beacon_registration *reg;\n\n\ttrace_cfg80211_report_obss_beacon(wiphy, frame, len, freq, sig_dbm);\n\n\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\tlist_for_each_entry(reg, &rdev->beacon_registrations, list) {\n\t\tmsg = nlmsg_new(len + 100, GFP_ATOMIC);\n\t\tif (!msg) {\n\t\t\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\t\t\treturn;\n\t\t}\n\n\t\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);\n\t\tif (!hdr)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t\t    (freq &&\n\t\t     (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ,\n\t\t\t\t  KHZ_TO_MHZ(freq)) ||\n\t\t      nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ_OFFSET,\n\t\t\t\t  freq % 1000))) ||\n\t\t    (sig_dbm &&\n\t\t     nla_put_u32(msg, NL80211_ATTR_RX_SIGNAL_DBM, sig_dbm)) ||\n\t\t    nla_put(msg, NL80211_ATTR_FRAME, len, frame))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\n\t\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, reg->nlportid);\n\t}\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\treturn;\n\n nla_put_failure:\n\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_report_obss_beacon_khz);\n\n#ifdef CONFIG_PM\nstatic int cfg80211_net_detect_results(struct sk_buff *msg,\n\t\t\t\t       struct cfg80211_wowlan_wakeup *wakeup)\n{\n\tstruct cfg80211_wowlan_nd_info *nd = wakeup->net_detect;\n\tstruct nlattr *nl_results, *nl_match, *nl_freqs;\n\tint i, j;\n\n\tnl_results = nla_nest_start_noflag(msg,\n\t\t\t\t\t   NL80211_WOWLAN_TRIG_NET_DETECT_RESULTS);\n\tif (!nl_results)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < nd->n_matches; i++) {\n\t\tstruct cfg80211_wowlan_nd_match *match = nd->matches[i];\n\n\t\tnl_match = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_match)\n\t\t\tbreak;\n\n\t\t \n\t\tif (nla_put(msg, NL80211_ATTR_SSID, match->ssid.ssid_len,\n\t\t\t    match->ssid.ssid)) {\n\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (match->n_channels) {\n\t\t\tnl_freqs = nla_nest_start_noflag(msg,\n\t\t\t\t\t\t\t NL80211_ATTR_SCAN_FREQUENCIES);\n\t\t\tif (!nl_freqs) {\n\t\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < match->n_channels; j++) {\n\t\t\t\tif (nla_put_u32(msg, j, match->channels[j])) {\n\t\t\t\t\tnla_nest_cancel(msg, nl_freqs);\n\t\t\t\t\tnla_nest_cancel(msg, nl_match);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnla_nest_end(msg, nl_freqs);\n\t\t}\n\n\t\tnla_nest_end(msg, nl_match);\n\t}\n\nout:\n\tnla_nest_end(msg, nl_results);\n\treturn 0;\n}\n\nvoid cfg80211_report_wowlan_wakeup(struct wireless_dev *wdev,\n\t\t\t\t   struct cfg80211_wowlan_wakeup *wakeup,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint size = 200;\n\n\ttrace_cfg80211_report_wowlan_wakeup(wdev->wiphy, wdev, wakeup);\n\n\tif (wakeup)\n\t\tsize += wakeup->packet_present_len;\n\n\tmsg = nlmsg_new(size, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_WOWLAN);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto free_msg;\n\n\tif (wdev->netdev && nla_put_u32(msg, NL80211_ATTR_IFINDEX,\n\t\t\t\t\twdev->netdev->ifindex))\n\t\tgoto free_msg;\n\n\tif (wakeup) {\n\t\tstruct nlattr *reasons;\n\n\t\treasons = nla_nest_start_noflag(msg,\n\t\t\t\t\t\tNL80211_ATTR_WOWLAN_TRIGGERS);\n\t\tif (!reasons)\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->disconnect &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_DISCONNECT))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->magic_pkt &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_MAGIC_PKT))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->gtk_rekey_failure &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->eap_identity_req &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->four_way_handshake &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE))\n\t\t\tgoto free_msg;\n\t\tif (wakeup->rfkill_release &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->pattern_idx >= 0 &&\n\t\t    nla_put_u32(msg, NL80211_WOWLAN_TRIG_PKT_PATTERN,\n\t\t\t\twakeup->pattern_idx))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_match &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_MATCH))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_connlost &&\n\t\t    nla_put_flag(msg, NL80211_WOWLAN_TRIG_WAKEUP_TCP_CONNLOST))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->tcp_nomoretokens &&\n\t\t    nla_put_flag(msg,\n\t\t\t\t NL80211_WOWLAN_TRIG_WAKEUP_TCP_NOMORETOKENS))\n\t\t\tgoto free_msg;\n\n\t\tif (wakeup->packet) {\n\t\t\tu32 pkt_attr = NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211;\n\t\t\tu32 len_attr = NL80211_WOWLAN_TRIG_WAKEUP_PKT_80211_LEN;\n\n\t\t\tif (!wakeup->packet_80211) {\n\t\t\t\tpkt_attr =\n\t\t\t\t\tNL80211_WOWLAN_TRIG_WAKEUP_PKT_8023;\n\t\t\t\tlen_attr =\n\t\t\t\t\tNL80211_WOWLAN_TRIG_WAKEUP_PKT_8023_LEN;\n\t\t\t}\n\n\t\t\tif (wakeup->packet_len &&\n\t\t\t    nla_put_u32(msg, len_attr, wakeup->packet_len))\n\t\t\t\tgoto free_msg;\n\n\t\t\tif (nla_put(msg, pkt_attr, wakeup->packet_present_len,\n\t\t\t\t    wakeup->packet))\n\t\t\t\tgoto free_msg;\n\t\t}\n\n\t\tif (wakeup->net_detect &&\n\t\t    cfg80211_net_detect_results(msg, wakeup))\n\t\t\t\tgoto free_msg;\n\n\t\tnla_nest_end(msg, reasons);\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n free_msg:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_report_wowlan_wakeup);\n#endif\n\nvoid cfg80211_tdls_oper_request(struct net_device *dev, const u8 *peer,\n\t\t\t\tenum nl80211_tdls_operation oper,\n\t\t\t\tu16 reason_code, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_tdls_oper_request(wdev->wiphy, dev, peer, oper,\n\t\t\t\t\t reason_code);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_TDLS_OPER);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u8(msg, NL80211_ATTR_TDLS_OPERATION, oper) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, peer) ||\n\t    (reason_code > 0 &&\n\t     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason_code)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_tdls_oper_request);\n\nstatic int nl80211_netlink_notify(struct notifier_block * nb,\n\t\t\t\t  unsigned long state,\n\t\t\t\t  void *_notify)\n{\n\tstruct netlink_notify *notify = _notify;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\tstruct cfg80211_beacon_registration *reg, *tmp;\n\n\tif (state != NETLINK_URELEASE || notify->protocol != NETLINK_GENERIC)\n\t\treturn NOTIFY_DONE;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list) {\n\t\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\n\t\tlist_for_each_entry_rcu(sched_scan_req,\n\t\t\t\t\t&rdev->sched_scan_req_list,\n\t\t\t\t\tlist) {\n\t\t\tif (sched_scan_req->owner_nlportid == notify->portid) {\n\t\t\t\tsched_scan_req->nl_owner_dead = true;\n\t\t\t\twiphy_work_queue(&rdev->wiphy,\n\t\t\t\t\t\t &rdev->sched_scan_stop_wk);\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry_rcu(wdev, &rdev->wiphy.wdev_list, list) {\n\t\t\tcfg80211_mlme_unregister_socket(wdev, notify->portid);\n\n\t\t\tif (wdev->owner_nlportid == notify->portid) {\n\t\t\t\twdev->nl_owner_dead = true;\n\t\t\t\tschedule_work(&rdev->destroy_work);\n\t\t\t} else if (wdev->conn_owner_nlportid == notify->portid) {\n\t\t\t\tschedule_work(&wdev->disconnect_wk);\n\t\t\t}\n\n\t\t\tcfg80211_release_pmsr(wdev, notify->portid);\n\t\t}\n\n\t\tspin_lock_bh(&rdev->beacon_registrations_lock);\n\t\tlist_for_each_entry_safe(reg, tmp, &rdev->beacon_registrations,\n\t\t\t\t\t list) {\n\t\t\tif (reg->nlportid == notify->portid) {\n\t\t\t\tlist_del(&reg->list);\n\t\t\t\tkfree(reg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&rdev->beacon_registrations_lock);\n\t}\n\n\trcu_read_unlock();\n\n\t \n\tregulatory_netlink_notify(notify->portid);\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block nl80211_netlink_notifier = {\n\t.notifier_call = nl80211_netlink_notify,\n};\n\nvoid cfg80211_ft_event(struct net_device *netdev,\n\t\t       struct cfg80211_ft_event_params *ft_event)\n{\n\tstruct wiphy *wiphy = netdev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_ft_event(wiphy, netdev, ft_event);\n\n\tif (!ft_event->target_ap)\n\t\treturn;\n\n\tmsg = nlmsg_new(100 + ft_event->ies_len + ft_event->ric_ies_len,\n\t\t\tGFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FT_EVENT);\n\tif (!hdr)\n\t\tgoto out;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, ft_event->target_ap))\n\t\tgoto out;\n\n\tif (ft_event->ies &&\n\t    nla_put(msg, NL80211_ATTR_IE, ft_event->ies_len, ft_event->ies))\n\t\tgoto out;\n\tif (ft_event->ric_ies &&\n\t    nla_put(msg, NL80211_ATTR_IE_RIC, ft_event->ric_ies_len,\n\t\t    ft_event->ric_ies))\n\t\tgoto out;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n out:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_ft_event);\n\nvoid cfg80211_crit_proto_stopped(struct wireless_dev *wdev, gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tu32 nlportid;\n\n\trdev = wiphy_to_rdev(wdev->wiphy);\n\tif (!rdev->crit_proto_nlportid)\n\t\treturn;\n\n\tnlportid = rdev->crit_proto_nlportid;\n\trdev->crit_proto_nlportid = 0;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_CRIT_PROTOCOL_STOP);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlportid);\n\treturn;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_crit_proto_stopped);\n\nvoid nl80211_send_ap_stopped(struct wireless_dev *wdev, unsigned int link_id)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_STOP_AP);\n\tif (!hdr)\n\t\tgoto out;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, wdev->netdev->ifindex) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD) ||\n\t    (wdev->valid_links &&\n\t     nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link_id)))\n\t\tgoto out;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, GFP_KERNEL);\n\treturn;\n out:\n\tnlmsg_free(msg);\n}\n\nint cfg80211_external_auth_request(struct net_device *dev,\n\t\t\t\t   struct cfg80211_external_auth_params *params,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tif (!wdev->conn_owner_nlportid)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_EXTERNAL_AUTH);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex) ||\n\t    nla_put_u32(msg, NL80211_ATTR_AKM_SUITES, params->key_mgmt_suite) ||\n\t    nla_put_u32(msg, NL80211_ATTR_EXTERNAL_AUTH_ACTION,\n\t\t\tparams->action) ||\n\t    nla_put(msg, NL80211_ATTR_BSSID, ETH_ALEN, params->bssid) ||\n\t    nla_put(msg, NL80211_ATTR_SSID, params->ssid.ssid_len,\n\t\t    params->ssid.ssid) ||\n\t    (!is_zero_ether_addr(params->mld_addr) &&\n\t     nla_put(msg, NL80211_ATTR_MLD_ADDR, ETH_ALEN, params->mld_addr)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_unicast(wiphy_net(&rdev->wiphy), msg,\n\t\t\twdev->conn_owner_nlportid);\n\treturn 0;\n\n nla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}\nEXPORT_SYMBOL(cfg80211_external_auth_request);\n\nvoid cfg80211_update_owe_info_event(struct net_device *netdev,\n\t\t\t\t    struct cfg80211_update_owe_info *owe_info,\n\t\t\t\t    gfp_t gfp)\n{\n\tstruct wiphy *wiphy = netdev->ieee80211_ptr->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_update_owe_info_event(wiphy, netdev, owe_info);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_UPDATE_OWE_INFO);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, owe_info->peer))\n\t\tgoto nla_put_failure;\n\n\tif (!owe_info->ie_len ||\n\t    nla_put(msg, NL80211_ATTR_IE, owe_info->ie_len, owe_info->ie))\n\t\tgoto nla_put_failure;\n\n\tif (owe_info->assoc_link_id != -1) {\n\t\tif (nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID,\n\t\t\t       owe_info->assoc_link_id))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (!is_zero_ether_addr(owe_info->peer_mld_addr) &&\n\t\t    nla_put(msg, NL80211_ATTR_MLD_ADDR, ETH_ALEN,\n\t\t\t    owe_info->peer_mld_addr))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tNL80211_MCGRP_MLME, gfp);\n\treturn;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL(cfg80211_update_owe_info_event);\n\n \n\nint __init nl80211_init(void)\n{\n\tint err;\n\n\terr = genl_register_family(&nl80211_fam);\n\tif (err)\n\t\treturn err;\n\n\terr = netlink_register_notifier(&nl80211_netlink_notifier);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n err_out:\n\tgenl_unregister_family(&nl80211_fam);\n\treturn err;\n}\n\nvoid nl80211_exit(void)\n{\n\tnetlink_unregister_notifier(&nl80211_netlink_notifier);\n\tgenl_unregister_family(&nl80211_fam);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}