{
  "module_name": "chan.c",
  "hash_id": "71f7db1d78de5dff373d5b29ed58d524874096866ab6457b570ba1f79edc0530",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/chan.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/bitfield.h>\n#include <net/cfg80211.h>\n#include \"core.h\"\n#include \"rdev-ops.h\"\n\nstatic bool cfg80211_valid_60g_freq(u32 freq)\n{\n\treturn freq >= 58320 && freq <= 70200;\n}\n\nvoid cfg80211_chandef_create(struct cfg80211_chan_def *chandef,\n\t\t\t     struct ieee80211_channel *chan,\n\t\t\t     enum nl80211_channel_type chan_type)\n{\n\tif (WARN_ON(!chan))\n\t\treturn;\n\n\tchandef->chan = chan;\n\tchandef->freq1_offset = chan->freq_offset;\n\tchandef->center_freq2 = 0;\n\tchandef->edmg.bw_config = 0;\n\tchandef->edmg.channels = 0;\n\n\tswitch (chan_type) {\n\tcase NL80211_CHAN_NO_HT:\n\t\tchandef->width = NL80211_CHAN_WIDTH_20_NOHT;\n\t\tchandef->center_freq1 = chan->center_freq;\n\t\tbreak;\n\tcase NL80211_CHAN_HT20:\n\t\tchandef->width = NL80211_CHAN_WIDTH_20;\n\t\tchandef->center_freq1 = chan->center_freq;\n\t\tbreak;\n\tcase NL80211_CHAN_HT40PLUS:\n\t\tchandef->width = NL80211_CHAN_WIDTH_40;\n\t\tchandef->center_freq1 = chan->center_freq + 10;\n\t\tbreak;\n\tcase NL80211_CHAN_HT40MINUS:\n\t\tchandef->width = NL80211_CHAN_WIDTH_40;\n\t\tchandef->center_freq1 = chan->center_freq - 10;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\nEXPORT_SYMBOL(cfg80211_chandef_create);\n\nstatic bool cfg80211_edmg_chandef_valid(const struct cfg80211_chan_def *chandef)\n{\n\tint max_contiguous = 0;\n\tint num_of_enabled = 0;\n\tint contiguous = 0;\n\tint i;\n\n\tif (!chandef->edmg.channels || !chandef->edmg.bw_config)\n\t\treturn false;\n\n\tif (!cfg80211_valid_60g_freq(chandef->chan->center_freq))\n\t\treturn false;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (chandef->edmg.channels & BIT(i)) {\n\t\t\tcontiguous++;\n\t\t\tnum_of_enabled++;\n\t\t} else {\n\t\t\tcontiguous = 0;\n\t\t}\n\n\t\tmax_contiguous = max(contiguous, max_contiguous);\n\t}\n\t \n\t \n\tswitch (chandef->edmg.bw_config) {\n\tcase IEEE80211_EDMG_BW_CONFIG_4:\n\tcase IEEE80211_EDMG_BW_CONFIG_8:\n\tcase IEEE80211_EDMG_BW_CONFIG_12:\n\t\tif (max_contiguous < 1)\n\t\t\treturn false;\n\t\tbreak;\n\tcase IEEE80211_EDMG_BW_CONFIG_5:\n\tcase IEEE80211_EDMG_BW_CONFIG_9:\n\tcase IEEE80211_EDMG_BW_CONFIG_13:\n\t\tif (max_contiguous < 2)\n\t\t\treturn false;\n\t\tbreak;\n\tcase IEEE80211_EDMG_BW_CONFIG_6:\n\tcase IEEE80211_EDMG_BW_CONFIG_10:\n\tcase IEEE80211_EDMG_BW_CONFIG_14:\n\t\tif (max_contiguous < 3)\n\t\t\treturn false;\n\t\tbreak;\n\tcase IEEE80211_EDMG_BW_CONFIG_7:\n\tcase IEEE80211_EDMG_BW_CONFIG_11:\n\tcase IEEE80211_EDMG_BW_CONFIG_15:\n\t\tif (max_contiguous < 4)\n\t\t\treturn false;\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\t \n\tswitch (chandef->edmg.bw_config) {\n\tcase IEEE80211_EDMG_BW_CONFIG_4:\n\tcase IEEE80211_EDMG_BW_CONFIG_5:\n\tcase IEEE80211_EDMG_BW_CONFIG_6:\n\tcase IEEE80211_EDMG_BW_CONFIG_7:\n\t\tbreak;\n\tcase IEEE80211_EDMG_BW_CONFIG_8:\n\tcase IEEE80211_EDMG_BW_CONFIG_9:\n\tcase IEEE80211_EDMG_BW_CONFIG_10:\n\tcase IEEE80211_EDMG_BW_CONFIG_11:\n\t\tif (num_of_enabled < 2)\n\t\t\treturn false;\n\t\tbreak;\n\tcase IEEE80211_EDMG_BW_CONFIG_12:\n\tcase IEEE80211_EDMG_BW_CONFIG_13:\n\tcase IEEE80211_EDMG_BW_CONFIG_14:\n\tcase IEEE80211_EDMG_BW_CONFIG_15:\n\t\tif (num_of_enabled < 4 || max_contiguous < 2)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int nl80211_chan_width_to_mhz(enum nl80211_chan_width chan_width)\n{\n\tint mhz;\n\n\tswitch (chan_width) {\n\tcase NL80211_CHAN_WIDTH_1:\n\t\tmhz = 1;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_2:\n\t\tmhz = 2;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_4:\n\t\tmhz = 4;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_8:\n\t\tmhz = 8;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_16:\n\t\tmhz = 16;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_5:\n\t\tmhz = 5;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\tmhz = 10;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tmhz = 20;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tmhz = 40;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tmhz = 80;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tmhz = 160;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\tmhz = 320;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -1;\n\t}\n\treturn mhz;\n}\n\nstatic int cfg80211_chandef_get_width(const struct cfg80211_chan_def *c)\n{\n\treturn nl80211_chan_width_to_mhz(c->width);\n}\n\nbool cfg80211_chandef_valid(const struct cfg80211_chan_def *chandef)\n{\n\tu32 control_freq, oper_freq;\n\tint oper_width, control_width;\n\n\tif (!chandef->chan)\n\t\treturn false;\n\n\tif (chandef->freq1_offset >= 1000)\n\t\treturn false;\n\n\tcontrol_freq = chandef->chan->center_freq;\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tif (ieee80211_chandef_to_khz(chandef) !=\n\t\t    ieee80211_channel_to_khz(chandef->chan))\n\t\t\treturn false;\n\t\tif (chandef->center_freq2)\n\t\t\treturn false;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_1:\n\tcase NL80211_CHAN_WIDTH_2:\n\tcase NL80211_CHAN_WIDTH_4:\n\tcase NL80211_CHAN_WIDTH_8:\n\tcase NL80211_CHAN_WIDTH_16:\n\t\tif (chandef->chan->band != NL80211_BAND_S1GHZ)\n\t\t\treturn false;\n\n\t\tcontrol_freq = ieee80211_channel_to_khz(chandef->chan);\n\t\toper_freq = ieee80211_chandef_to_khz(chandef);\n\t\tcontrol_width = nl80211_chan_width_to_mhz(\n\t\t\t\t\tieee80211_s1g_channel_width(\n\t\t\t\t\t\t\t\tchandef->chan));\n\t\toper_width = cfg80211_chandef_get_width(chandef);\n\n\t\tif (oper_width < 0 || control_width < 0)\n\t\t\treturn false;\n\t\tif (chandef->center_freq2)\n\t\t\treturn false;\n\n\t\tif (control_freq + MHZ_TO_KHZ(control_width) / 2 >\n\t\t    oper_freq + MHZ_TO_KHZ(oper_width) / 2)\n\t\t\treturn false;\n\n\t\tif (control_freq - MHZ_TO_KHZ(control_width) / 2 <\n\t\t    oper_freq - MHZ_TO_KHZ(oper_width) / 2)\n\t\t\treturn false;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\tif (!chandef->center_freq2)\n\t\t\treturn false;\n\t\t \n\t\tif (chandef->center_freq1 - chandef->center_freq2 == 80 ||\n\t\t    chandef->center_freq2 - chandef->center_freq1 == 80)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tif (chandef->center_freq2)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_5:\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_1:\n\tcase NL80211_CHAN_WIDTH_2:\n\tcase NL80211_CHAN_WIDTH_4:\n\tcase NL80211_CHAN_WIDTH_8:\n\tcase NL80211_CHAN_WIDTH_16:\n\t\t \n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\tif (chandef->center_freq1 == control_freq + 150 ||\n\t\t    chandef->center_freq1 == control_freq + 130 ||\n\t\t    chandef->center_freq1 == control_freq + 110 ||\n\t\t    chandef->center_freq1 == control_freq + 90 ||\n\t\t    chandef->center_freq1 == control_freq - 90 ||\n\t\t    chandef->center_freq1 == control_freq - 110 ||\n\t\t    chandef->center_freq1 == control_freq - 130 ||\n\t\t    chandef->center_freq1 == control_freq - 150)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tif (chandef->center_freq1 == control_freq + 70 ||\n\t\t    chandef->center_freq1 == control_freq + 50 ||\n\t\t    chandef->center_freq1 == control_freq - 50 ||\n\t\t    chandef->center_freq1 == control_freq - 70)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tif (chandef->center_freq1 == control_freq + 30 ||\n\t\t    chandef->center_freq1 == control_freq - 30)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (chandef->center_freq1 == control_freq + 10 ||\n\t\t    chandef->center_freq1 == control_freq - 10)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t \n\tif (chandef->center_freq1 == 2484 &&\n\t    chandef->width != NL80211_CHAN_WIDTH_20_NOHT)\n\t\treturn false;\n\n\tif (cfg80211_chandef_is_edmg(chandef) &&\n\t    !cfg80211_edmg_chandef_valid(chandef))\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(cfg80211_chandef_valid);\n\nstatic void chandef_primary_freqs(const struct cfg80211_chan_def *c,\n\t\t\t\t  u32 *pri40, u32 *pri80, u32 *pri160)\n{\n\tint tmp;\n\n\tswitch (c->width) {\n\tcase NL80211_CHAN_WIDTH_40:\n\t\t*pri40 = c->center_freq1;\n\t\t*pri80 = 0;\n\t\t*pri160 = 0;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\t*pri160 = 0;\n\t\t*pri80 = c->center_freq1;\n\t\t \n\t\ttmp = (30 + c->chan->center_freq - c->center_freq1)/20;\n\t\t \n\t\ttmp /= 2;\n\t\t \n\t\t*pri40 = c->center_freq1 - 20 + 40 * tmp;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\t*pri160 = c->center_freq1;\n\t\t \n\t\ttmp = (70 + c->chan->center_freq - c->center_freq1)/20;\n\t\t \n\t\ttmp /= 2;\n\t\t \n\t\t*pri40 = c->center_freq1 - 60 + 40 * tmp;\n\t\t \n\t\ttmp /= 2;\n\t\t*pri80 = c->center_freq1 - 40 + 80 * tmp;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\t \n\t\ttmp = (150 + c->chan->center_freq - c->center_freq1) / 20;\n\t\t \n\t\ttmp /= 2;\n\t\t \n\t\t*pri40 = c->center_freq1 - 140 + 40 * tmp;\n\t\t \n\t\ttmp /= 2;\n\t\t*pri80 = c->center_freq1 - 120 + 80 * tmp;\n\t\t \n\t\ttmp /= 2;\n\t\t*pri160 = c->center_freq1 - 80 + 160 * tmp;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\nconst struct cfg80211_chan_def *\ncfg80211_chandef_compatible(const struct cfg80211_chan_def *c1,\n\t\t\t    const struct cfg80211_chan_def *c2)\n{\n\tu32 c1_pri40, c1_pri80, c2_pri40, c2_pri80, c1_pri160, c2_pri160;\n\n\t \n\tif (cfg80211_chandef_identical(c1, c2))\n\t\treturn c1;\n\n\t \n\tif (c1->chan != c2->chan)\n\t\treturn NULL;\n\n\t \n\tif (c1->width == c2->width)\n\t\treturn NULL;\n\n\t \n\tif (c1->width == NL80211_CHAN_WIDTH_5 ||\n\t    c1->width == NL80211_CHAN_WIDTH_10 ||\n\t    c2->width == NL80211_CHAN_WIDTH_5 ||\n\t    c2->width == NL80211_CHAN_WIDTH_10)\n\t\treturn NULL;\n\n\tif (c1->width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t    c1->width == NL80211_CHAN_WIDTH_20)\n\t\treturn c2;\n\n\tif (c2->width == NL80211_CHAN_WIDTH_20_NOHT ||\n\t    c2->width == NL80211_CHAN_WIDTH_20)\n\t\treturn c1;\n\n\tchandef_primary_freqs(c1, &c1_pri40, &c1_pri80, &c1_pri160);\n\tchandef_primary_freqs(c2, &c2_pri40, &c2_pri80, &c2_pri160);\n\n\tif (c1_pri40 != c2_pri40)\n\t\treturn NULL;\n\n\tif (c1->width == NL80211_CHAN_WIDTH_40)\n\t\treturn c2;\n\n\tif (c2->width == NL80211_CHAN_WIDTH_40)\n\t\treturn c1;\n\n\tif (c1_pri80 != c2_pri80)\n\t\treturn NULL;\n\n\tif (c1->width == NL80211_CHAN_WIDTH_80 &&\n\t    c2->width > NL80211_CHAN_WIDTH_80)\n\t\treturn c2;\n\n\tif (c2->width == NL80211_CHAN_WIDTH_80 &&\n\t    c1->width > NL80211_CHAN_WIDTH_80)\n\t\treturn c1;\n\n\tWARN_ON(!c1_pri160 && !c2_pri160);\n\tif (c1_pri160 && c2_pri160 && c1_pri160 != c2_pri160)\n\t\treturn NULL;\n\n\tif (c1->width > c2->width)\n\t\treturn c1;\n\treturn c2;\n}\nEXPORT_SYMBOL(cfg80211_chandef_compatible);\n\nstatic void cfg80211_set_chans_dfs_state(struct wiphy *wiphy, u32 center_freq,\n\t\t\t\t\t u32 bandwidth,\n\t\t\t\t\t enum nl80211_dfs_state dfs_state)\n{\n\tstruct ieee80211_channel *c;\n\tu32 freq;\n\n\tfor (freq = center_freq - bandwidth/2 + 10;\n\t     freq <= center_freq + bandwidth/2 - 10;\n\t     freq += 20) {\n\t\tc = ieee80211_get_channel(wiphy, freq);\n\t\tif (!c || !(c->flags & IEEE80211_CHAN_RADAR))\n\t\t\tcontinue;\n\n\t\tc->dfs_state = dfs_state;\n\t\tc->dfs_state_entered = jiffies;\n\t}\n}\n\nvoid cfg80211_set_dfs_state(struct wiphy *wiphy,\n\t\t\t    const struct cfg80211_chan_def *chandef,\n\t\t\t    enum nl80211_dfs_state dfs_state)\n{\n\tint width;\n\n\tif (WARN_ON(!cfg80211_chandef_valid(chandef)))\n\t\treturn;\n\n\twidth = cfg80211_chandef_get_width(chandef);\n\tif (width < 0)\n\t\treturn;\n\n\tcfg80211_set_chans_dfs_state(wiphy, chandef->center_freq1,\n\t\t\t\t     width, dfs_state);\n\n\tif (!chandef->center_freq2)\n\t\treturn;\n\tcfg80211_set_chans_dfs_state(wiphy, chandef->center_freq2,\n\t\t\t\t     width, dfs_state);\n}\n\nstatic u32 cfg80211_get_start_freq(u32 center_freq,\n\t\t\t\t   u32 bandwidth)\n{\n\tu32 start_freq;\n\n\tbandwidth = MHZ_TO_KHZ(bandwidth);\n\tif (bandwidth <= MHZ_TO_KHZ(20))\n\t\tstart_freq = center_freq;\n\telse\n\t\tstart_freq = center_freq - bandwidth / 2 + MHZ_TO_KHZ(10);\n\n\treturn start_freq;\n}\n\nstatic u32 cfg80211_get_end_freq(u32 center_freq,\n\t\t\t\t u32 bandwidth)\n{\n\tu32 end_freq;\n\n\tbandwidth = MHZ_TO_KHZ(bandwidth);\n\tif (bandwidth <= MHZ_TO_KHZ(20))\n\t\tend_freq = center_freq;\n\telse\n\t\tend_freq = center_freq + bandwidth / 2 - MHZ_TO_KHZ(10);\n\n\treturn end_freq;\n}\n\nstatic int cfg80211_get_chans_dfs_required(struct wiphy *wiphy,\n\t\t\t\t\t    u32 center_freq,\n\t\t\t\t\t    u32 bandwidth)\n{\n\tstruct ieee80211_channel *c;\n\tu32 freq, start_freq, end_freq;\n\n\tstart_freq = cfg80211_get_start_freq(center_freq, bandwidth);\n\tend_freq = cfg80211_get_end_freq(center_freq, bandwidth);\n\n\tfor (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {\n\t\tc = ieee80211_get_channel_khz(wiphy, freq);\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\n\t\tif (c->flags & IEEE80211_CHAN_RADAR)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nint cfg80211_chandef_dfs_required(struct wiphy *wiphy,\n\t\t\t\t  const struct cfg80211_chan_def *chandef,\n\t\t\t\t  enum nl80211_iftype iftype)\n{\n\tint width;\n\tint ret;\n\n\tif (WARN_ON(!cfg80211_chandef_valid(chandef)))\n\t\treturn -EINVAL;\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\twidth = cfg80211_chandef_get_width(chandef);\n\t\tif (width < 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = cfg80211_get_chans_dfs_required(wiphy,\n\t\t\t\t\tieee80211_chandef_to_khz(chandef),\n\t\t\t\t\twidth);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret > 0)\n\t\t\treturn BIT(chandef->width);\n\n\t\tif (!chandef->center_freq2)\n\t\t\treturn 0;\n\n\t\tret = cfg80211_get_chans_dfs_required(wiphy,\n\t\t\t\t\tMHZ_TO_KHZ(chandef->center_freq2),\n\t\t\t\t\twidth);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret > 0)\n\t\t\treturn BIT(chandef->width);\n\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\tcase NL80211_IFTYPE_NAN:\n\t\tbreak;\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NUM_NL80211_IFTYPES:\n\t\tWARN_ON(1);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cfg80211_chandef_dfs_required);\n\nstatic int cfg80211_get_chans_dfs_usable(struct wiphy *wiphy,\n\t\t\t\t\t u32 center_freq,\n\t\t\t\t\t u32 bandwidth)\n{\n\tstruct ieee80211_channel *c;\n\tu32 freq, start_freq, end_freq;\n\tint count = 0;\n\n\tstart_freq = cfg80211_get_start_freq(center_freq, bandwidth);\n\tend_freq = cfg80211_get_end_freq(center_freq, bandwidth);\n\n\t \n\tfor (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {\n\t\tc = ieee80211_get_channel_khz(wiphy, freq);\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\n\t\tif (c->flags & IEEE80211_CHAN_DISABLED)\n\t\t\treturn -EINVAL;\n\n\t\tif (c->flags & IEEE80211_CHAN_RADAR) {\n\t\t\tif (c->dfs_state == NL80211_DFS_UNAVAILABLE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (c->dfs_state == NL80211_DFS_USABLE)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nbool cfg80211_chandef_dfs_usable(struct wiphy *wiphy,\n\t\t\t\t const struct cfg80211_chan_def *chandef)\n{\n\tint width;\n\tint r1, r2 = 0;\n\n\tif (WARN_ON(!cfg80211_chandef_valid(chandef)))\n\t\treturn false;\n\n\twidth = cfg80211_chandef_get_width(chandef);\n\tif (width < 0)\n\t\treturn false;\n\n\tr1 = cfg80211_get_chans_dfs_usable(wiphy,\n\t\t\t\t\t   MHZ_TO_KHZ(chandef->center_freq1),\n\t\t\t\t\t   width);\n\n\tif (r1 < 0)\n\t\treturn false;\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\tWARN_ON(!chandef->center_freq2);\n\t\tr2 = cfg80211_get_chans_dfs_usable(wiphy,\n\t\t\t\t\tMHZ_TO_KHZ(chandef->center_freq2),\n\t\t\t\t\twidth);\n\t\tif (r2 < 0)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(chandef->center_freq2);\n\t\tbreak;\n\t}\n\n\treturn (r1 + r2 > 0);\n}\n\n \nbool cfg80211_is_sub_chan(struct cfg80211_chan_def *chandef,\n\t\t\t  struct ieee80211_channel *chan,\n\t\t\t  bool primary_only)\n{\n\tint width;\n\tu32 freq;\n\n\tif (!chandef->chan)\n\t\treturn false;\n\n\tif (chandef->chan->center_freq == chan->center_freq)\n\t\treturn true;\n\n\tif (primary_only)\n\t\treturn false;\n\n\twidth = cfg80211_chandef_get_width(chandef);\n\tif (width <= 20)\n\t\treturn false;\n\n\tfor (freq = chandef->center_freq1 - width / 2 + 10;\n\t     freq <= chandef->center_freq1 + width / 2 - 10; freq += 20) {\n\t\tif (chan->center_freq == freq)\n\t\t\treturn true;\n\t}\n\n\tif (!chandef->center_freq2)\n\t\treturn false;\n\n\tfor (freq = chandef->center_freq2 - width / 2 + 10;\n\t     freq <= chandef->center_freq2 + width / 2 - 10; freq += 20) {\n\t\tif (chan->center_freq == freq)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool cfg80211_beaconing_iface_active(struct wireless_dev *wdev)\n{\n\tunsigned int link;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tfor_each_valid_link(wdev, link) {\n\t\t\tif (wdev->links[link].ap.beacon_interval)\n\t\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (wdev->u.ibss.ssid_len)\n\t\t\treturn true;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (wdev->u.mesh.id_len)\n\t\t\treturn true;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t \n\tcase NL80211_IFTYPE_NAN:\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_WDS:\n\tcase NUM_NL80211_IFTYPES:\n\t\tWARN_ON(1);\n\t}\n\n\treturn false;\n}\n\nbool cfg80211_wdev_on_sub_chan(struct wireless_dev *wdev,\n\t\t\t       struct ieee80211_channel *chan,\n\t\t\t       bool primary_only)\n{\n\tunsigned int link;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tfor_each_valid_link(wdev, link) {\n\t\t\tif (cfg80211_is_sub_chan(&wdev->links[link].ap.chandef,\n\t\t\t\t\t\t chan, primary_only))\n\t\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\treturn cfg80211_is_sub_chan(&wdev->u.ibss.chandef, chan,\n\t\t\t\t\t    primary_only);\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn cfg80211_is_sub_chan(&wdev->u.mesh.chandef, chan,\n\t\t\t\t\t    primary_only);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic bool cfg80211_is_wiphy_oper_chan(struct wiphy *wiphy,\n\t\t\t\t\tstruct ieee80211_channel *chan)\n{\n\tstruct wireless_dev *wdev;\n\n\tlist_for_each_entry(wdev, &wiphy->wdev_list, list) {\n\t\twdev_lock(wdev);\n\t\tif (!cfg80211_beaconing_iface_active(wdev)) {\n\t\t\twdev_unlock(wdev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cfg80211_wdev_on_sub_chan(wdev, chan, false)) {\n\t\t\twdev_unlock(wdev);\n\t\t\treturn true;\n\t\t}\n\t\twdev_unlock(wdev);\n\t}\n\n\treturn false;\n}\n\nstatic bool\ncfg80211_offchan_chain_is_active(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct ieee80211_channel *channel)\n{\n\tif (!rdev->background_radar_wdev)\n\t\treturn false;\n\n\tif (!cfg80211_chandef_valid(&rdev->background_radar_chandef))\n\t\treturn false;\n\n\treturn cfg80211_is_sub_chan(&rdev->background_radar_chandef, channel,\n\t\t\t\t    false);\n}\n\nbool cfg80211_any_wiphy_oper_chan(struct wiphy *wiphy,\n\t\t\t\t  struct ieee80211_channel *chan)\n{\n\tstruct cfg80211_registered_device *rdev;\n\n\tASSERT_RTNL();\n\n\tif (!(chan->flags & IEEE80211_CHAN_RADAR))\n\t\treturn false;\n\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tif (!reg_dfs_domain_same(wiphy, &rdev->wiphy))\n\t\t\tcontinue;\n\n\t\tif (cfg80211_is_wiphy_oper_chan(&rdev->wiphy, chan))\n\t\t\treturn true;\n\n\t\tif (cfg80211_offchan_chain_is_active(rdev, chan))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool cfg80211_get_chans_dfs_available(struct wiphy *wiphy,\n\t\t\t\t\t     u32 center_freq,\n\t\t\t\t\t     u32 bandwidth)\n{\n\tstruct ieee80211_channel *c;\n\tu32 freq, start_freq, end_freq;\n\tbool dfs_offload;\n\n\tdfs_offload = wiphy_ext_feature_isset(wiphy,\n\t\t\t\t\t      NL80211_EXT_FEATURE_DFS_OFFLOAD);\n\n\tstart_freq = cfg80211_get_start_freq(center_freq, bandwidth);\n\tend_freq = cfg80211_get_end_freq(center_freq, bandwidth);\n\n\t \n\tfor (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {\n\t\tc = ieee80211_get_channel_khz(wiphy, freq);\n\t\tif (!c)\n\t\t\treturn false;\n\n\t\tif (c->flags & IEEE80211_CHAN_DISABLED)\n\t\t\treturn false;\n\n\t\tif ((c->flags & IEEE80211_CHAN_RADAR) &&\n\t\t    (c->dfs_state != NL80211_DFS_AVAILABLE) &&\n\t\t    !(c->dfs_state == NL80211_DFS_USABLE && dfs_offload))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool cfg80211_chandef_dfs_available(struct wiphy *wiphy,\n\t\t\t\tconst struct cfg80211_chan_def *chandef)\n{\n\tint width;\n\tint r;\n\n\tif (WARN_ON(!cfg80211_chandef_valid(chandef)))\n\t\treturn false;\n\n\twidth = cfg80211_chandef_get_width(chandef);\n\tif (width < 0)\n\t\treturn false;\n\n\tr = cfg80211_get_chans_dfs_available(wiphy,\n\t\t\t\t\t     MHZ_TO_KHZ(chandef->center_freq1),\n\t\t\t\t\t     width);\n\n\t \n\tif (!r)\n\t\treturn r;\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\tWARN_ON(!chandef->center_freq2);\n\t\tr = cfg80211_get_chans_dfs_available(wiphy,\n\t\t\t\t\tMHZ_TO_KHZ(chandef->center_freq2),\n\t\t\t\t\twidth);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(chandef->center_freq2);\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic unsigned int cfg80211_get_chans_dfs_cac_time(struct wiphy *wiphy,\n\t\t\t\t\t\t    u32 center_freq,\n\t\t\t\t\t\t    u32 bandwidth)\n{\n\tstruct ieee80211_channel *c;\n\tu32 start_freq, end_freq, freq;\n\tunsigned int dfs_cac_ms = 0;\n\n\tstart_freq = cfg80211_get_start_freq(center_freq, bandwidth);\n\tend_freq = cfg80211_get_end_freq(center_freq, bandwidth);\n\n\tfor (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {\n\t\tc = ieee80211_get_channel_khz(wiphy, freq);\n\t\tif (!c)\n\t\t\treturn 0;\n\n\t\tif (c->flags & IEEE80211_CHAN_DISABLED)\n\t\t\treturn 0;\n\n\t\tif (!(c->flags & IEEE80211_CHAN_RADAR))\n\t\t\tcontinue;\n\n\t\tif (c->dfs_cac_ms > dfs_cac_ms)\n\t\t\tdfs_cac_ms = c->dfs_cac_ms;\n\t}\n\n\treturn dfs_cac_ms;\n}\n\nunsigned int\ncfg80211_chandef_dfs_cac_time(struct wiphy *wiphy,\n\t\t\t      const struct cfg80211_chan_def *chandef)\n{\n\tint width;\n\tunsigned int t1 = 0, t2 = 0;\n\n\tif (WARN_ON(!cfg80211_chandef_valid(chandef)))\n\t\treturn 0;\n\n\twidth = cfg80211_chandef_get_width(chandef);\n\tif (width < 0)\n\t\treturn 0;\n\n\tt1 = cfg80211_get_chans_dfs_cac_time(wiphy,\n\t\t\t\t\t     MHZ_TO_KHZ(chandef->center_freq1),\n\t\t\t\t\t     width);\n\n\tif (!chandef->center_freq2)\n\t\treturn t1;\n\n\tt2 = cfg80211_get_chans_dfs_cac_time(wiphy,\n\t\t\t\t\t     MHZ_TO_KHZ(chandef->center_freq2),\n\t\t\t\t\t     width);\n\n\treturn max(t1, t2);\n}\n\nstatic bool cfg80211_secondary_chans_ok(struct wiphy *wiphy,\n\t\t\t\t\tu32 center_freq, u32 bandwidth,\n\t\t\t\t\tu32 prohibited_flags)\n{\n\tstruct ieee80211_channel *c;\n\tu32 freq, start_freq, end_freq;\n\n\tstart_freq = cfg80211_get_start_freq(center_freq, bandwidth);\n\tend_freq = cfg80211_get_end_freq(center_freq, bandwidth);\n\n\tfor (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {\n\t\tc = ieee80211_get_channel_khz(wiphy, freq);\n\t\tif (!c || c->flags & prohibited_flags)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool cfg80211_edmg_usable(struct wiphy *wiphy, u8 edmg_channels,\n\t\t\t\t enum ieee80211_edmg_bw_config edmg_bw_config,\n\t\t\t\t int primary_channel,\n\t\t\t\t struct ieee80211_edmg *edmg_cap)\n{\n\tstruct ieee80211_channel *chan;\n\tint i, freq;\n\tint channels_counter = 0;\n\n\tif (!edmg_channels && !edmg_bw_config)\n\t\treturn true;\n\n\tif ((!edmg_channels && edmg_bw_config) ||\n\t    (edmg_channels && !edmg_bw_config))\n\t\treturn false;\n\n\tif (!(edmg_channels & BIT(primary_channel - 1)))\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tif (!(edmg_channels & BIT(i)))\n\t\t\tcontinue;\n\n\t\tif (!(edmg_cap->channels & BIT(i)))\n\t\t\treturn false;\n\n\t\tchannels_counter++;\n\n\t\tfreq = ieee80211_channel_to_frequency(i + 1,\n\t\t\t\t\t\t      NL80211_BAND_60GHZ);\n\t\tchan = ieee80211_get_channel(wiphy, freq);\n\t\tif (!chan || chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\treturn false;\n\t}\n\n\t \n\tif (channels_counter > 4)\n\t\treturn false;\n\n\t \n\tif ((edmg_bw_config % 4) > (edmg_cap->bw_config % 4))\n\t\treturn false;\n\n\tif (edmg_bw_config > edmg_cap->bw_config)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool cfg80211_chandef_usable(struct wiphy *wiphy,\n\t\t\t     const struct cfg80211_chan_def *chandef,\n\t\t\t     u32 prohibited_flags)\n{\n\tstruct ieee80211_sta_ht_cap *ht_cap;\n\tstruct ieee80211_sta_vht_cap *vht_cap;\n\tstruct ieee80211_edmg *edmg_cap;\n\tu32 width, control_freq, cap;\n\tbool ext_nss_cap, support_80_80 = false, support_320 = false;\n\tconst struct ieee80211_sband_iftype_data *iftd;\n\tstruct ieee80211_supported_band *sband;\n\tint i;\n\n\tif (WARN_ON(!cfg80211_chandef_valid(chandef)))\n\t\treturn false;\n\n\tht_cap = &wiphy->bands[chandef->chan->band]->ht_cap;\n\tvht_cap = &wiphy->bands[chandef->chan->band]->vht_cap;\n\tedmg_cap = &wiphy->bands[chandef->chan->band]->edmg_cap;\n\text_nss_cap = __le16_to_cpu(vht_cap->vht_mcs.tx_highest) &\n\t\t\tIEEE80211_VHT_EXT_NSS_BW_CAPABLE;\n\n\tif (edmg_cap->channels &&\n\t    !cfg80211_edmg_usable(wiphy,\n\t\t\t\t  chandef->edmg.channels,\n\t\t\t\t  chandef->edmg.bw_config,\n\t\t\t\t  chandef->chan->hw_value,\n\t\t\t\t  edmg_cap))\n\t\treturn false;\n\n\tcontrol_freq = chandef->chan->center_freq;\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_1:\n\t\twidth = 1;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_2:\n\t\twidth = 2;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_4:\n\t\twidth = 4;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_8:\n\t\twidth = 8;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_16:\n\t\twidth = 16;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_5:\n\t\twidth = 5;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\tprohibited_flags |= IEEE80211_CHAN_NO_10MHZ;\n\t\twidth = 10;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tif (!ht_cap->ht_supported &&\n\t\t    chandef->chan->band != NL80211_BAND_6GHZ)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tprohibited_flags |= IEEE80211_CHAN_NO_20MHZ;\n\t\twidth = 20;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\twidth = 40;\n\t\tif (chandef->chan->band == NL80211_BAND_6GHZ)\n\t\t\tbreak;\n\t\tif (!ht_cap->ht_supported)\n\t\t\treturn false;\n\t\tif (!(ht_cap->cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) ||\n\t\t    ht_cap->cap & IEEE80211_HT_CAP_40MHZ_INTOLERANT)\n\t\t\treturn false;\n\t\tif (chandef->center_freq1 < control_freq &&\n\t\t    chandef->chan->flags & IEEE80211_CHAN_NO_HT40MINUS)\n\t\t\treturn false;\n\t\tif (chandef->center_freq1 > control_freq &&\n\t\t    chandef->chan->flags & IEEE80211_CHAN_NO_HT40PLUS)\n\t\t\treturn false;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\tcap = vht_cap->cap;\n\t\tsupport_80_80 =\n\t\t\t(cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ) ||\n\t\t\t(cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ &&\n\t\t\t cap & IEEE80211_VHT_CAP_EXT_NSS_BW_MASK) ||\n\t\t\t(ext_nss_cap &&\n\t\t\t u32_get_bits(cap, IEEE80211_VHT_CAP_EXT_NSS_BW_MASK) > 1);\n\t\tif (chandef->chan->band != NL80211_BAND_6GHZ && !support_80_80)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tprohibited_flags |= IEEE80211_CHAN_NO_80MHZ;\n\t\twidth = 80;\n\t\tif (chandef->chan->band == NL80211_BAND_6GHZ)\n\t\t\tbreak;\n\t\tif (!vht_cap->vht_supported)\n\t\t\treturn false;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tprohibited_flags |= IEEE80211_CHAN_NO_160MHZ;\n\t\twidth = 160;\n\t\tif (chandef->chan->band == NL80211_BAND_6GHZ)\n\t\t\tbreak;\n\t\tif (!vht_cap->vht_supported)\n\t\t\treturn false;\n\t\tcap = vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;\n\t\tif (cap != IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ &&\n\t\t    cap != IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ &&\n\t\t    !(ext_nss_cap &&\n\t\t      (vht_cap->cap & IEEE80211_VHT_CAP_EXT_NSS_BW_MASK)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\tprohibited_flags |= IEEE80211_CHAN_NO_320MHZ;\n\t\twidth = 320;\n\n\t\tif (chandef->chan->band != NL80211_BAND_6GHZ)\n\t\t\treturn false;\n\n\t\tsband = wiphy->bands[NL80211_BAND_6GHZ];\n\t\tif (!sband)\n\t\t\treturn false;\n\n\t\tfor (i = 0; i < sband->n_iftype_data; i++) {\n\t\t\tiftd = &sband->iftype_data[i];\n\t\t\tif (!iftd->eht_cap.has_eht)\n\t\t\t\tcontinue;\n\n\t\t\tif (iftd->eht_cap.eht_cap_elem.phy_cap_info[0] &\n\t\t\t    IEEE80211_EHT_PHY_CAP0_320MHZ_IN_6GHZ) {\n\t\t\t\tsupport_320 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!support_320)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn false;\n\t}\n\n\t \n\n\tif (width > 20)\n\t\tprohibited_flags |= IEEE80211_CHAN_NO_OFDM;\n\n\t \n\tif (width < 20)\n\t\tprohibited_flags |= IEEE80211_CHAN_NO_OFDM;\n\n\n\tif (!cfg80211_secondary_chans_ok(wiphy,\n\t\t\t\t\t ieee80211_chandef_to_khz(chandef),\n\t\t\t\t\t width, prohibited_flags))\n\t\treturn false;\n\n\tif (!chandef->center_freq2)\n\t\treturn true;\n\treturn cfg80211_secondary_chans_ok(wiphy,\n\t\t\t\t\t   MHZ_TO_KHZ(chandef->center_freq2),\n\t\t\t\t\t   width, prohibited_flags);\n}\nEXPORT_SYMBOL(cfg80211_chandef_usable);\n\nstatic bool cfg80211_ir_permissive_check_wdev(enum nl80211_iftype iftype,\n\t\t\t\t\t      struct wireless_dev *wdev,\n\t\t\t\t\t      struct ieee80211_channel *chan)\n{\n\tstruct ieee80211_channel *other_chan = NULL;\n\tunsigned int link_id;\n\tint r1, r2;\n\n\tfor_each_valid_link(wdev, link_id) {\n\t\tif (wdev->iftype == NL80211_IFTYPE_STATION &&\n\t\t    wdev->links[link_id].client.current_bss)\n\t\t\tother_chan = wdev->links[link_id].client.current_bss->pub.channel;\n\n\t\t \n\t\tif (iftype == NL80211_IFTYPE_P2P_GO &&\n\t\t    wdev->iftype == NL80211_IFTYPE_P2P_GO &&\n\t\t    wdev->links[link_id].ap.beacon_interval &&\n\t\t    !(chan->flags & IEEE80211_CHAN_INDOOR_ONLY))\n\t\t\tother_chan = wdev->links[link_id].ap.chandef.chan;\n\n\t\tif (!other_chan)\n\t\t\tcontinue;\n\n\t\tif (chan == other_chan)\n\t\t\treturn true;\n\n\t\tif (chan->band != NL80211_BAND_5GHZ &&\n\t\t    chan->band != NL80211_BAND_6GHZ)\n\t\t\tcontinue;\n\n\t\tr1 = cfg80211_get_unii(chan->center_freq);\n\t\tr2 = cfg80211_get_unii(other_chan->center_freq);\n\n\t\tif (r1 != -EINVAL && r1 == r2) {\n\t\t\t \n\t\t\tif (chan->center_freq == 5825 &&\n\t\t\t    other_chan->center_freq != 5825)\n\t\t\t\tcontinue;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic bool cfg80211_ir_permissive_chan(struct wiphy *wiphy,\n\t\t\t\t\tenum nl80211_iftype iftype,\n\t\t\t\t\tstruct ieee80211_channel *chan)\n{\n\tstruct wireless_dev *wdev;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\tif (!IS_ENABLED(CONFIG_CFG80211_REG_RELAX_NO_IR) ||\n\t    !(wiphy->regulatory_flags & REGULATORY_ENABLE_RELAX_NO_IR))\n\t\treturn false;\n\n\t \n\tif (iftype != NL80211_IFTYPE_P2P_GO &&\n\t    iftype != NL80211_IFTYPE_STATION &&\n\t    iftype != NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn false;\n\n\tif (regulatory_indoor_allowed() &&\n\t    (chan->flags & IEEE80211_CHAN_INDOOR_ONLY))\n\t\treturn true;\n\n\tif (!(chan->flags & IEEE80211_CHAN_IR_CONCURRENT))\n\t\treturn false;\n\n\t \n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {\n\t\tbool ret;\n\n\t\twdev_lock(wdev);\n\t\tret = cfg80211_ir_permissive_check_wdev(iftype, wdev, chan);\n\t\twdev_unlock(wdev);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn false;\n}\n\nstatic bool _cfg80211_reg_can_beacon(struct wiphy *wiphy,\n\t\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t\t     enum nl80211_iftype iftype,\n\t\t\t\t     bool check_no_ir)\n{\n\tbool res;\n\tu32 prohibited_flags = IEEE80211_CHAN_DISABLED |\n\t\t\t       IEEE80211_CHAN_RADAR;\n\n\ttrace_cfg80211_reg_can_beacon(wiphy, chandef, iftype, check_no_ir);\n\n\tif (check_no_ir)\n\t\tprohibited_flags |= IEEE80211_CHAN_NO_IR;\n\n\tif (cfg80211_chandef_dfs_required(wiphy, chandef, iftype) > 0 &&\n\t    cfg80211_chandef_dfs_available(wiphy, chandef)) {\n\t\t \n\t\tprohibited_flags = IEEE80211_CHAN_DISABLED;\n\t}\n\n\tres = cfg80211_chandef_usable(wiphy, chandef, prohibited_flags);\n\n\ttrace_cfg80211_return_bool(res);\n\treturn res;\n}\n\nbool cfg80211_reg_can_beacon(struct wiphy *wiphy,\n\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t     enum nl80211_iftype iftype)\n{\n\treturn _cfg80211_reg_can_beacon(wiphy, chandef, iftype, true);\n}\nEXPORT_SYMBOL(cfg80211_reg_can_beacon);\n\nbool cfg80211_reg_can_beacon_relax(struct wiphy *wiphy,\n\t\t\t\t   struct cfg80211_chan_def *chandef,\n\t\t\t\t   enum nl80211_iftype iftype)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tbool check_no_ir;\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\t \n\tcheck_no_ir = !cfg80211_ir_permissive_chan(wiphy, iftype,\n\t\t\t\t\t\t   chandef->chan);\n\n\treturn _cfg80211_reg_can_beacon(wiphy, chandef, iftype, check_no_ir);\n}\nEXPORT_SYMBOL(cfg80211_reg_can_beacon_relax);\n\nint cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tif (!rdev->ops->set_monitor_channel)\n\t\treturn -EOPNOTSUPP;\n\tif (!cfg80211_has_monitors_only(rdev))\n\t\treturn -EBUSY;\n\n\treturn rdev_set_monitor_channel(rdev, chandef);\n}\n\nbool cfg80211_any_usable_channels(struct wiphy *wiphy,\n\t\t\t\t  unsigned long sband_mask,\n\t\t\t\t  u32 prohibited_flags)\n{\n\tint idx;\n\n\tprohibited_flags |= IEEE80211_CHAN_DISABLED;\n\n\tfor_each_set_bit(idx, &sband_mask, NUM_NL80211_BANDS) {\n\t\tstruct ieee80211_supported_band *sband = wiphy->bands[idx];\n\t\tint chanidx;\n\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (chanidx = 0; chanidx < sband->n_channels; chanidx++) {\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tchan = &sband->channels[chanidx];\n\n\t\t\tif (chan->flags & prohibited_flags)\n\t\t\t\tcontinue;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL(cfg80211_any_usable_channels);\n\nstruct cfg80211_chan_def *wdev_chandef(struct wireless_dev *wdev,\n\t\t\t\t       unsigned int link_id)\n{\n\t \n\tif (link_id || wdev->valid_links & BIT(0)) {\n\t\tASSERT_WDEV_LOCK(wdev);\n\t\tWARN_ON(!(wdev->valid_links & BIT(link_id)));\n\t}\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn &wdev->u.mesh.chandef;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\treturn &wdev->u.ibss.chandef;\n\tcase NL80211_IFTYPE_OCB:\n\t\treturn &wdev->u.ocb.chandef;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\treturn &wdev->links[link_id].ap.chandef;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\nEXPORT_SYMBOL(wdev_chandef);\n\nstruct cfg80211_per_bw_puncturing_values {\n\tu8 len;\n\tconst u16 *valid_values;\n};\n\nstatic const u16 puncturing_values_80mhz[] = {\n\t0x8, 0x4, 0x2, 0x1\n};\n\nstatic const u16 puncturing_values_160mhz[] = {\n\t 0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1, 0xc0, 0x30, 0xc, 0x3\n};\n\nstatic const u16 puncturing_values_320mhz[] = {\n\t0xc000, 0x3000, 0xc00, 0x300, 0xc0, 0x30, 0xc, 0x3, 0xf000, 0xf00,\n\t0xf0, 0xf, 0xfc00, 0xf300, 0xf0c0, 0xf030, 0xf00c, 0xf003, 0xc00f,\n\t0x300f, 0xc0f, 0x30f, 0xcf, 0x3f\n};\n\n#define CFG80211_PER_BW_VALID_PUNCTURING_VALUES(_bw) \\\n\t{ \\\n\t\t.len = ARRAY_SIZE(puncturing_values_ ## _bw ## mhz), \\\n\t\t.valid_values = puncturing_values_ ## _bw ## mhz \\\n\t}\n\nstatic const struct cfg80211_per_bw_puncturing_values per_bw_puncturing[] = {\n\tCFG80211_PER_BW_VALID_PUNCTURING_VALUES(80),\n\tCFG80211_PER_BW_VALID_PUNCTURING_VALUES(160),\n\tCFG80211_PER_BW_VALID_PUNCTURING_VALUES(320)\n};\n\nbool cfg80211_valid_disable_subchannel_bitmap(u16 *bitmap,\n\t\t\t\t\t      const struct cfg80211_chan_def *chandef)\n{\n\tu32 idx, i, start_freq;\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tidx = 0;\n\t\tstart_freq = chandef->center_freq1 - 40;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tidx = 1;\n\t\tstart_freq = chandef->center_freq1 - 80;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_320:\n\t\tidx = 2;\n\t\tstart_freq = chandef->center_freq1 - 160;\n\t\tbreak;\n\tdefault:\n\t\t*bitmap = 0;\n\t\tbreak;\n\t}\n\n\tif (!*bitmap)\n\t\treturn true;\n\n\t \n\tif (*bitmap & (u16)BIT((chandef->chan->center_freq - start_freq) / 20))\n\t\treturn false;\n\n\tfor (i = 0; i < per_bw_puncturing[idx].len; i++)\n\t\tif (per_bw_puncturing[idx].valid_values[i] == *bitmap)\n\t\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(cfg80211_valid_disable_subchannel_bitmap);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}