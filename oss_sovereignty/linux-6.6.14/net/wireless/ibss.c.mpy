{
  "module_name": "ibss.c",
  "hash_id": "aff7033e49896caba4f28081521ebd364ffaa65fd94f1e33dbdf483edf0cd195",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/ibss.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <net/cfg80211.h>\n#include \"wext-compat.h\"\n#include \"nl80211.h\"\n#include \"rdev-ops.h\"\n\n\nvoid __cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,\n\t\t\t    struct ieee80211_channel *channel)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_bss *bss;\n#ifdef CONFIG_CFG80211_WEXT\n\tunion iwreq_data wrqu;\n#endif\n\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_ADHOC))\n\t\treturn;\n\n\tif (!wdev->u.ibss.ssid_len)\n\t\treturn;\n\n\tbss = cfg80211_get_bss(wdev->wiphy, channel, bssid, NULL, 0,\n\t\t\t       IEEE80211_BSS_TYPE_IBSS, IEEE80211_PRIVACY_ANY);\n\n\tif (WARN_ON(!bss))\n\t\treturn;\n\n\tif (wdev->u.ibss.current_bss) {\n\t\tcfg80211_unhold_bss(wdev->u.ibss.current_bss);\n\t\tcfg80211_put_bss(wdev->wiphy, &wdev->u.ibss.current_bss->pub);\n\t}\n\n\tcfg80211_hold_bss(bss_from_pub(bss));\n\twdev->u.ibss.current_bss = bss_from_pub(bss);\n\n\tcfg80211_upload_connect_keys(wdev);\n\n\tnl80211_send_ibss_bssid(wiphy_to_rdev(wdev->wiphy), dev, bssid,\n\t\t\t\tGFP_KERNEL);\n#ifdef CONFIG_CFG80211_WEXT\n\tmemset(&wrqu, 0, sizeof(wrqu));\n\tmemcpy(wrqu.ap_addr.sa_data, bssid, ETH_ALEN);\n\twireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);\n#endif\n}\n\nvoid cfg80211_ibss_joined(struct net_device *dev, const u8 *bssid,\n\t\t\t  struct ieee80211_channel *channel, gfp_t gfp)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_event *ev;\n\tunsigned long flags;\n\n\ttrace_cfg80211_ibss_joined(dev, bssid, channel);\n\n\tif (WARN_ON(!channel))\n\t\treturn;\n\n\tev = kzalloc(sizeof(*ev), gfp);\n\tif (!ev)\n\t\treturn;\n\n\tev->type = EVENT_IBSS_JOINED;\n\tmemcpy(ev->ij.bssid, bssid, ETH_ALEN);\n\tev->ij.channel = channel;\n\n\tspin_lock_irqsave(&wdev->event_lock, flags);\n\tlist_add_tail(&ev->list, &wdev->event_list);\n\tspin_unlock_irqrestore(&wdev->event_lock, flags);\n\tqueue_work(cfg80211_wq, &rdev->event_work);\n}\nEXPORT_SYMBOL(cfg80211_ibss_joined);\n\nint __cfg80211_join_ibss(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *dev,\n\t\t\t struct cfg80211_ibss_params *params,\n\t\t\t struct cfg80211_cached_keys *connkeys)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err;\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (wdev->u.ibss.ssid_len)\n\t\treturn -EALREADY;\n\n\tif (!params->basic_rates) {\n\t\t \n\t\tstruct ieee80211_supported_band *sband;\n\t\tenum nl80211_band band;\n\t\tu32 flag;\n\t\tint j;\n\n\t\tband = params->chandef.chan->band;\n\t\tif (band == NL80211_BAND_5GHZ ||\n\t\t    band == NL80211_BAND_6GHZ)\n\t\t\tflag = IEEE80211_RATE_MANDATORY_A;\n\t\telse\n\t\t\tflag = IEEE80211_RATE_MANDATORY_B;\n\n\t\tsband = rdev->wiphy.bands[band];\n\t\tfor (j = 0; j < sband->n_bitrates; j++) {\n\t\t\tif (sband->bitrates[j].flags & flag)\n\t\t\t\tparams->basic_rates |= BIT(j);\n\t\t}\n\t}\n\n\tif (WARN_ON(connkeys && connkeys->def < 0))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(wdev->connect_keys))\n\t\tkfree_sensitive(wdev->connect_keys);\n\twdev->connect_keys = connkeys;\n\n\twdev->u.ibss.chandef = params->chandef;\n\tif (connkeys) {\n\t\tparams->wep_keys = connkeys->params;\n\t\tparams->wep_tx_key = connkeys->def;\n\t}\n\n#ifdef CONFIG_CFG80211_WEXT\n\twdev->wext.ibss.chandef = params->chandef;\n#endif\n\terr = rdev_join_ibss(rdev, dev, params);\n\tif (err) {\n\t\twdev->connect_keys = NULL;\n\t\treturn err;\n\t}\n\n\tmemcpy(wdev->u.ibss.ssid, params->ssid, params->ssid_len);\n\twdev->u.ibss.ssid_len = params->ssid_len;\n\n\treturn 0;\n}\n\nstatic void __cfg80211_clear_ibss(struct net_device *dev, bool nowext)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tint i;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tkfree_sensitive(wdev->connect_keys);\n\twdev->connect_keys = NULL;\n\n\trdev_set_qos_map(rdev, dev, NULL);\n\n\t \n\tif (rdev->ops->del_key)\n\t\tfor (i = 0; i < 6; i++)\n\t\t\trdev_del_key(rdev, dev, -1, i, false, NULL);\n\n\tif (wdev->u.ibss.current_bss) {\n\t\tcfg80211_unhold_bss(wdev->u.ibss.current_bss);\n\t\tcfg80211_put_bss(wdev->wiphy, &wdev->u.ibss.current_bss->pub);\n\t}\n\n\twdev->u.ibss.current_bss = NULL;\n\twdev->u.ibss.ssid_len = 0;\n\tmemset(&wdev->u.ibss.chandef, 0, sizeof(wdev->u.ibss.chandef));\n#ifdef CONFIG_CFG80211_WEXT\n\tif (!nowext)\n\t\twdev->wext.ibss.ssid_len = 0;\n#endif\n\tcfg80211_sched_dfs_chan_update(rdev);\n}\n\nvoid cfg80211_clear_ibss(struct net_device *dev, bool nowext)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\twdev_lock(wdev);\n\t__cfg80211_clear_ibss(dev, nowext);\n\twdev_unlock(wdev);\n}\n\nint __cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,\n\t\t\t  struct net_device *dev, bool nowext)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!wdev->u.ibss.ssid_len)\n\t\treturn -ENOLINK;\n\n\terr = rdev_leave_ibss(rdev, dev);\n\n\tif (err)\n\t\treturn err;\n\n\twdev->conn_owner_nlportid = 0;\n\t__cfg80211_clear_ibss(dev, nowext);\n\n\treturn 0;\n}\n\nint cfg80211_leave_ibss(struct cfg80211_registered_device *rdev,\n\t\t\tstruct net_device *dev, bool nowext)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err;\n\n\twdev_lock(wdev);\n\terr = __cfg80211_leave_ibss(rdev, dev, nowext);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\n#ifdef CONFIG_CFG80211_WEXT\nint cfg80211_ibss_wext_join(struct cfg80211_registered_device *rdev,\n\t\t\t    struct wireless_dev *wdev)\n{\n\tstruct cfg80211_cached_keys *ck = NULL;\n\tenum nl80211_band band;\n\tint i, err;\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!wdev->wext.ibss.beacon_interval)\n\t\twdev->wext.ibss.beacon_interval = 100;\n\n\t \n\tif (!wdev->wext.ibss.chandef.chan) {\n\t\tstruct ieee80211_channel *new_chan = NULL;\n\n\t\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\t\tstruct ieee80211_supported_band *sband;\n\t\t\tstruct ieee80211_channel *chan;\n\n\t\t\tsband = rdev->wiphy.bands[band];\n\t\t\tif (!sband)\n\t\t\t\tcontinue;\n\n\t\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\t\tchan = &sband->channels[i];\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_NO_IR)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\t\tcontinue;\n\t\t\t\tnew_chan = chan;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (new_chan)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!new_chan)\n\t\t\treturn -EINVAL;\n\n\t\tcfg80211_chandef_create(&wdev->wext.ibss.chandef, new_chan,\n\t\t\t\t\tNL80211_CHAN_NO_HT);\n\t}\n\n\t \n\tif (!wdev->wext.ibss.ssid_len)\n\t\treturn 0;\n\n\tif (!netif_running(wdev->netdev))\n\t\treturn 0;\n\n\tif (wdev->wext.keys)\n\t\twdev->wext.keys->def = wdev->wext.default_key;\n\n\twdev->wext.ibss.privacy = wdev->wext.default_key != -1;\n\n\tif (wdev->wext.keys && wdev->wext.keys->def != -1) {\n\t\tck = kmemdup(wdev->wext.keys, sizeof(*ck), GFP_KERNEL);\n\t\tif (!ck)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tck->params[i].key = ck->data[i];\n\t}\n\terr = __cfg80211_join_ibss(rdev, wdev->netdev,\n\t\t\t\t   &wdev->wext.ibss, ck);\n\tif (err)\n\t\tkfree(ck);\n\n\treturn err;\n}\n\nint cfg80211_ibss_wext_siwfreq(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_freq *wextfreq, char *extra)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct ieee80211_channel *chan = NULL;\n\tint err, freq;\n\n\t \n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_ADHOC))\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->join_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tfreq = cfg80211_wext_freq(wextfreq);\n\tif (freq < 0)\n\t\treturn freq;\n\n\tif (freq) {\n\t\tchan = ieee80211_get_channel(wdev->wiphy, freq);\n\t\tif (!chan)\n\t\t\treturn -EINVAL;\n\t\tif (chan->flags & IEEE80211_CHAN_NO_IR ||\n\t\t    chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (wdev->wext.ibss.chandef.chan == chan)\n\t\treturn 0;\n\n\twdev_lock(wdev);\n\terr = 0;\n\tif (wdev->u.ibss.ssid_len)\n\t\terr = __cfg80211_leave_ibss(rdev, dev, true);\n\twdev_unlock(wdev);\n\n\tif (err)\n\t\treturn err;\n\n\tif (chan) {\n\t\tcfg80211_chandef_create(&wdev->wext.ibss.chandef, chan,\n\t\t\t\t\tNL80211_CHAN_NO_HT);\n\t\twdev->wext.ibss.channel_fixed = true;\n\t} else {\n\t\t \n\t\twdev->wext.ibss.channel_fixed = false;\n\t}\n\n\twdev_lock(wdev);\n\terr = cfg80211_ibss_wext_join(rdev, wdev);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nint cfg80211_ibss_wext_giwfreq(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_freq *freq, char *extra)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct ieee80211_channel *chan = NULL;\n\n\t \n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_ADHOC))\n\t\treturn -EINVAL;\n\n\twdev_lock(wdev);\n\tif (wdev->u.ibss.current_bss)\n\t\tchan = wdev->u.ibss.current_bss->pub.channel;\n\telse if (wdev->wext.ibss.chandef.chan)\n\t\tchan = wdev->wext.ibss.chandef.chan;\n\twdev_unlock(wdev);\n\n\tif (chan) {\n\t\tfreq->m = chan->center_freq;\n\t\tfreq->e = 6;\n\t\treturn 0;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\nint cfg80211_ibss_wext_siwessid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tsize_t len = data->length;\n\tint err;\n\n\t \n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_ADHOC))\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->join_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\terr = 0;\n\tif (wdev->u.ibss.ssid_len)\n\t\terr = __cfg80211_leave_ibss(rdev, dev, true);\n\twdev_unlock(wdev);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (len > 0 && ssid[len - 1] == '\\0')\n\t\tlen--;\n\n\tmemcpy(wdev->u.ibss.ssid, ssid, len);\n\twdev->wext.ibss.ssid = wdev->u.ibss.ssid;\n\twdev->wext.ibss.ssid_len = len;\n\n\twdev_lock(wdev);\n\terr = cfg80211_ibss_wext_join(rdev, wdev);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nint cfg80211_ibss_wext_giwessid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tstruct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t \n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_ADHOC))\n\t\treturn -EINVAL;\n\n\tdata->flags = 0;\n\n\twdev_lock(wdev);\n\tif (wdev->u.ibss.ssid_len) {\n\t\tdata->flags = 1;\n\t\tdata->length = wdev->u.ibss.ssid_len;\n\t\tmemcpy(ssid, wdev->u.ibss.ssid, data->length);\n\t} else if (wdev->wext.ibss.ssid && wdev->wext.ibss.ssid_len) {\n\t\tdata->flags = 1;\n\t\tdata->length = wdev->wext.ibss.ssid_len;\n\t\tmemcpy(ssid, wdev->wext.ibss.ssid, data->length);\n\t}\n\twdev_unlock(wdev);\n\n\treturn 0;\n}\n\nint cfg80211_ibss_wext_siwap(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     struct sockaddr *ap_addr, char *extra)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tu8 *bssid = ap_addr->sa_data;\n\tint err;\n\n\t \n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_ADHOC))\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->join_ibss)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ap_addr->sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\n\t \n\tif (is_zero_ether_addr(bssid) || is_broadcast_ether_addr(bssid))\n\t\tbssid = NULL;\n\n\tif (bssid && !is_valid_ether_addr(bssid))\n\t\treturn -EINVAL;\n\n\t \n\tif (!bssid && !wdev->wext.ibss.bssid)\n\t\treturn 0;\n\n\t \n\tif (wdev->wext.ibss.bssid && bssid &&\n\t    ether_addr_equal(bssid, wdev->wext.ibss.bssid))\n\t\treturn 0;\n\n\twdev_lock(wdev);\n\terr = 0;\n\tif (wdev->u.ibss.ssid_len)\n\t\terr = __cfg80211_leave_ibss(rdev, dev, true);\n\twdev_unlock(wdev);\n\n\tif (err)\n\t\treturn err;\n\n\tif (bssid) {\n\t\tmemcpy(wdev->wext.bssid, bssid, ETH_ALEN);\n\t\twdev->wext.ibss.bssid = wdev->wext.bssid;\n\t} else\n\t\twdev->wext.ibss.bssid = NULL;\n\n\twdev_lock(wdev);\n\terr = cfg80211_ibss_wext_join(rdev, wdev);\n\twdev_unlock(wdev);\n\n\treturn err;\n}\n\nint cfg80211_ibss_wext_giwap(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     struct sockaddr *ap_addr, char *extra)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t \n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_ADHOC))\n\t\treturn -EINVAL;\n\n\tap_addr->sa_family = ARPHRD_ETHER;\n\n\twdev_lock(wdev);\n\tif (wdev->u.ibss.current_bss)\n\t\tmemcpy(ap_addr->sa_data, wdev->u.ibss.current_bss->pub.bssid,\n\t\t       ETH_ALEN);\n\telse if (wdev->wext.ibss.bssid)\n\t\tmemcpy(ap_addr->sa_data, wdev->wext.ibss.bssid, ETH_ALEN);\n\telse\n\t\teth_zero_addr(ap_addr->sa_data);\n\n\twdev_unlock(wdev);\n\n\treturn 0;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}