{
  "module_name": "wext-spy.c",
  "hash_id": "866da1a21ce1211c0bf7bafc6e5a6a861488becd8c53b1a922b150d04ad711dc",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/wext-spy.c",
  "human_readable_source": " \n\n#include <linux/wireless.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/export.h>\n#include <net/iw_handler.h>\n#include <net/arp.h>\n#include <net/wext.h>\n\nstatic inline struct iw_spy_data *get_spydata(struct net_device *dev)\n{\n\t \n\tif (dev->wireless_data)\n\t\treturn dev->wireless_data->spy_data;\n\treturn NULL;\n}\n\nint iw_handler_set_spy(struct net_device *\tdev,\n\t\t       struct iw_request_info *\tinfo,\n\t\t       union iwreq_data *\twrqu,\n\t\t       char *\t\t\textra)\n{\n\tstruct iw_spy_data *\tspydata = get_spydata(dev);\n\tstruct sockaddr *\taddress = (struct sockaddr *) extra;\n\n\t \n\tif (!spydata)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tspydata->spy_number = 0;\n\n\t \n\tsmp_wmb();\n\n\t \n\tif (wrqu->data.length > 0) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < wrqu->data.length; i++)\n\t\t\tmemcpy(spydata->spy_address[i], address[i].sa_data,\n\t\t\t       ETH_ALEN);\n\t\t \n\t\tmemset(spydata->spy_stat, 0,\n\t\t       sizeof(struct iw_quality) * IW_MAX_SPY);\n\t}\n\n\t \n\tsmp_wmb();\n\n\t \n\tspydata->spy_number = wrqu->data.length;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iw_handler_set_spy);\n\nint iw_handler_get_spy(struct net_device *\tdev,\n\t\t       struct iw_request_info *\tinfo,\n\t\t       union iwreq_data *\twrqu,\n\t\t       char *\t\t\textra)\n{\n\tstruct iw_spy_data *\tspydata = get_spydata(dev);\n\tstruct sockaddr *\taddress = (struct sockaddr *) extra;\n\tint\t\t\ti;\n\n\t \n\tif (!spydata)\n\t\treturn -EOPNOTSUPP;\n\n\twrqu->data.length = spydata->spy_number;\n\n\t \n\tfor (i = 0; i < spydata->spy_number; i++) \t{\n\t\tmemcpy(address[i].sa_data, spydata->spy_address[i], ETH_ALEN);\n\t\taddress[i].sa_family = AF_UNIX;\n\t}\n\t \n\tif (spydata->spy_number > 0)\n\t\tmemcpy(extra  + (sizeof(struct sockaddr) *spydata->spy_number),\n\t\t       spydata->spy_stat,\n\t\t       sizeof(struct iw_quality) * spydata->spy_number);\n\t \n\tfor (i = 0; i < spydata->spy_number; i++)\n\t\tspydata->spy_stat[i].updated &= ~IW_QUAL_ALL_UPDATED;\n\treturn 0;\n}\nEXPORT_SYMBOL(iw_handler_get_spy);\n\n \n \nint iw_handler_set_thrspy(struct net_device *\tdev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *\twrqu,\n\t\t\t  char *\t\textra)\n{\n\tstruct iw_spy_data *\tspydata = get_spydata(dev);\n\tstruct iw_thrspy *\tthreshold = (struct iw_thrspy *) extra;\n\n\t \n\tif (!spydata)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tspydata->spy_thr_low = threshold->low;\n\tspydata->spy_thr_high = threshold->high;\n\n\t \n\tmemset(spydata->spy_thr_under, '\\0', sizeof(spydata->spy_thr_under));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iw_handler_set_thrspy);\n\n \n \nint iw_handler_get_thrspy(struct net_device *\tdev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *\twrqu,\n\t\t\t  char *\t\textra)\n{\n\tstruct iw_spy_data *\tspydata = get_spydata(dev);\n\tstruct iw_thrspy *\tthreshold = (struct iw_thrspy *) extra;\n\n\t \n\tif (!spydata)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tthreshold->low = spydata->spy_thr_low;\n\tthreshold->high = spydata->spy_thr_high;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(iw_handler_get_thrspy);\n\n \n \nstatic void iw_send_thrspy_event(struct net_device *\tdev,\n\t\t\t\t struct iw_spy_data *\tspydata,\n\t\t\t\t unsigned char *\taddress,\n\t\t\t\t struct iw_quality *\twstats)\n{\n\tunion iwreq_data\twrqu;\n\tstruct iw_thrspy\tthreshold;\n\n\t \n\twrqu.data.length = 1;\n\twrqu.data.flags = 0;\n\t \n\tmemcpy(threshold.addr.sa_data, address, ETH_ALEN);\n\tthreshold.addr.sa_family = ARPHRD_ETHER;\n\t \n\tthreshold.qual = *wstats;\n\t \n\tthreshold.low = spydata->spy_thr_low;\n\tthreshold.high = spydata->spy_thr_high;\n\n\t \n\twireless_send_event(dev, SIOCGIWTHRSPY, &wrqu, (char *) &threshold);\n}\n\n \n \nvoid wireless_spy_update(struct net_device *\tdev,\n\t\t\t unsigned char *\taddress,\n\t\t\t struct iw_quality *\twstats)\n{\n\tstruct iw_spy_data *\tspydata = get_spydata(dev);\n\tint\t\t\ti;\n\tint\t\t\tmatch = -1;\n\n\t \n\tif (!spydata)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < spydata->spy_number; i++)\n\t\tif (ether_addr_equal(address, spydata->spy_address[i])) {\n\t\t\tmemcpy(&(spydata->spy_stat[i]), wstats,\n\t\t\t       sizeof(struct iw_quality));\n\t\t\tmatch = i;\n\t\t}\n\n\t \n\tif (match >= 0) {\n\t\tif (spydata->spy_thr_under[match]) {\n\t\t\tif (wstats->level > spydata->spy_thr_high.level) {\n\t\t\t\tspydata->spy_thr_under[match] = 0;\n\t\t\t\tiw_send_thrspy_event(dev, spydata,\n\t\t\t\t\t\t     address, wstats);\n\t\t\t}\n\t\t} else {\n\t\t\tif (wstats->level < spydata->spy_thr_low.level) {\n\t\t\t\tspydata->spy_thr_under[match] = 1;\n\t\t\t\tiw_send_thrspy_event(dev, spydata,\n\t\t\t\t\t\t     address, wstats);\n\t\t\t}\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(wireless_spy_update);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}