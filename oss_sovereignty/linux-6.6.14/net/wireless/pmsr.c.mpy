{
  "module_name": "pmsr.c",
  "hash_id": "0acc3e2ee3cc0f3ef7df0f5de9961990ad57decdc74dfbfacfbbf322533c41d2",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/pmsr.c",
  "human_readable_source": " \n \n#include <net/cfg80211.h>\n#include \"core.h\"\n#include \"nl80211.h\"\n#include \"rdev-ops.h\"\n\nstatic int pmsr_parse_ftm(struct cfg80211_registered_device *rdev,\n\t\t\t  struct nlattr *ftmreq,\n\t\t\t  struct cfg80211_pmsr_request_peer *out,\n\t\t\t  struct genl_info *info)\n{\n\tconst struct cfg80211_pmsr_capabilities *capa = rdev->wiphy.pmsr_capa;\n\tstruct nlattr *tb[NL80211_PMSR_FTM_REQ_ATTR_MAX + 1];\n\tu32 preamble = NL80211_PREAMBLE_DMG;  \n\n\t \n\tif (!(rdev->wiphy.pmsr_capa->ftm.bandwidths & BIT(out->chandef.width))) {\n\t\tNL_SET_ERR_MSG(info->extack, \"FTM: unsupported bandwidth\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnla_parse_nested_deprecated(tb, NL80211_PMSR_FTM_REQ_ATTR_MAX, ftmreq,\n\t\t\t\t    NULL, NULL);\n\n\tif (tb[NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE])\n\t\tpreamble = nla_get_u32(tb[NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE]);\n\n\t \n\tout->ftm.requested = true;\n\n\tswitch (out->chandef.chan->band) {\n\tcase NL80211_BAND_60GHZ:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tif (!tb[NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE]) {\n\t\t\tNL_SET_ERR_MSG(info->extack,\n\t\t\t\t       \"FTM: must specify preamble\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!(capa->ftm.preambles & BIT(preamble))) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE],\n\t\t\t\t    \"FTM: invalid preamble\");\n\t\treturn -EINVAL;\n\t}\n\n\tout->ftm.preamble = preamble;\n\n\tout->ftm.burst_period = 0;\n\tif (tb[NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD])\n\t\tout->ftm.burst_period =\n\t\t\tnla_get_u32(tb[NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD]);\n\n\tout->ftm.asap = !!tb[NL80211_PMSR_FTM_REQ_ATTR_ASAP];\n\tif (out->ftm.asap && !capa->ftm.asap) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[NL80211_PMSR_FTM_REQ_ATTR_ASAP],\n\t\t\t\t    \"FTM: ASAP mode not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!out->ftm.asap && !capa->ftm.non_asap) {\n\t\tNL_SET_ERR_MSG(info->extack,\n\t\t\t       \"FTM: non-ASAP mode not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tout->ftm.num_bursts_exp = 0;\n\tif (tb[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP])\n\t\tout->ftm.num_bursts_exp =\n\t\t\tnla_get_u32(tb[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP]);\n\n\tif (capa->ftm.max_bursts_exponent >= 0 &&\n\t    out->ftm.num_bursts_exp > capa->ftm.max_bursts_exponent) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP],\n\t\t\t\t    \"FTM: max NUM_BURSTS_EXP must be set lower than the device limit\");\n\t\treturn -EINVAL;\n\t}\n\n\tout->ftm.burst_duration = 15;\n\tif (tb[NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION])\n\t\tout->ftm.burst_duration =\n\t\t\tnla_get_u32(tb[NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION]);\n\n\tout->ftm.ftms_per_burst = 0;\n\tif (tb[NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST])\n\t\tout->ftm.ftms_per_burst =\n\t\t\tnla_get_u32(tb[NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST]);\n\n\tif (capa->ftm.max_ftms_per_burst &&\n\t    (out->ftm.ftms_per_burst > capa->ftm.max_ftms_per_burst ||\n\t     out->ftm.ftms_per_burst == 0)) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST],\n\t\t\t\t    \"FTM: FTMs per burst must be set lower than the device limit but non-zero\");\n\t\treturn -EINVAL;\n\t}\n\n\tout->ftm.ftmr_retries = 3;\n\tif (tb[NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES])\n\t\tout->ftm.ftmr_retries =\n\t\t\tnla_get_u32(tb[NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES]);\n\n\tout->ftm.request_lci = !!tb[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI];\n\tif (out->ftm.request_lci && !capa->ftm.request_lci) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI],\n\t\t\t\t    \"FTM: LCI request not supported\");\n\t}\n\n\tout->ftm.request_civicloc =\n\t\t!!tb[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC];\n\tif (out->ftm.request_civicloc && !capa->ftm.request_civicloc) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC],\n\t\t\t    \"FTM: civic location request not supported\");\n\t}\n\n\tout->ftm.trigger_based =\n\t\t!!tb[NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED];\n\tif (out->ftm.trigger_based && !capa->ftm.trigger_based) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED],\n\t\t\t\t    \"FTM: trigger based ranging is not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tout->ftm.non_trigger_based =\n\t\t!!tb[NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED];\n\tif (out->ftm.non_trigger_based && !capa->ftm.non_trigger_based) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED],\n\t\t\t\t    \"FTM: trigger based ranging is not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (out->ftm.trigger_based && out->ftm.non_trigger_based) {\n\t\tNL_SET_ERR_MSG(info->extack,\n\t\t\t       \"FTM: can't set both trigger based and non trigger based\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((out->ftm.trigger_based || out->ftm.non_trigger_based) &&\n\t    out->ftm.preamble != NL80211_PREAMBLE_HE) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE],\n\t\t\t\t    \"FTM: non EDCA based ranging must use HE preamble\");\n\t\treturn -EINVAL;\n\t}\n\n\tout->ftm.lmr_feedback =\n\t\t!!tb[NL80211_PMSR_FTM_REQ_ATTR_LMR_FEEDBACK];\n\tif (!out->ftm.trigger_based && !out->ftm.non_trigger_based &&\n\t    out->ftm.lmr_feedback) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[NL80211_PMSR_FTM_REQ_ATTR_LMR_FEEDBACK],\n\t\t\t\t    \"FTM: LMR feedback set for EDCA based ranging\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NL80211_PMSR_FTM_REQ_ATTR_BSS_COLOR]) {\n\t\tif (!out->ftm.non_trigger_based && !out->ftm.trigger_based) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t\t    tb[NL80211_PMSR_FTM_REQ_ATTR_BSS_COLOR],\n\t\t\t\t\t    \"FTM: BSS color set for EDCA based ranging\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tout->ftm.bss_color =\n\t\t\tnla_get_u8(tb[NL80211_PMSR_FTM_REQ_ATTR_BSS_COLOR]);\n\t}\n\n\treturn 0;\n}\n\nstatic int pmsr_parse_peer(struct cfg80211_registered_device *rdev,\n\t\t\t   struct nlattr *peer,\n\t\t\t   struct cfg80211_pmsr_request_peer *out,\n\t\t\t   struct genl_info *info)\n{\n\tstruct nlattr *tb[NL80211_PMSR_PEER_ATTR_MAX + 1];\n\tstruct nlattr *req[NL80211_PMSR_REQ_ATTR_MAX + 1];\n\tstruct nlattr *treq;\n\tint err, rem;\n\n\t \n\tnla_parse_nested_deprecated(tb, NL80211_PMSR_PEER_ATTR_MAX, peer,\n\t\t\t\t    NULL, NULL);\n\n\tif (!tb[NL80211_PMSR_PEER_ATTR_ADDR] ||\n\t    !tb[NL80211_PMSR_PEER_ATTR_CHAN] ||\n\t    !tb[NL80211_PMSR_PEER_ATTR_REQ]) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack, peer,\n\t\t\t\t    \"insufficient peer data\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(out->addr, nla_data(tb[NL80211_PMSR_PEER_ATTR_ADDR]), ETH_ALEN);\n\n\t \n\tmemset(info->attrs, 0, sizeof(*info->attrs) * (NL80211_ATTR_MAX + 1));\n\terr = nla_parse_nested_deprecated(info->attrs, NL80211_ATTR_MAX,\n\t\t\t\t\t  tb[NL80211_PMSR_PEER_ATTR_CHAN],\n\t\t\t\t\t  NULL, info->extack);\n\tif (err)\n\t\treturn err;\n\n\terr = nl80211_parse_chandef(rdev, info, &out->chandef);\n\tif (err)\n\t\treturn err;\n\n\t \n\tnla_parse_nested_deprecated(req, NL80211_PMSR_REQ_ATTR_MAX,\n\t\t\t\t    tb[NL80211_PMSR_PEER_ATTR_REQ], NULL,\n\t\t\t\t    NULL);\n\n\tif (!req[NL80211_PMSR_REQ_ATTR_DATA]) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    tb[NL80211_PMSR_PEER_ATTR_REQ],\n\t\t\t\t    \"missing request type/data\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (req[NL80211_PMSR_REQ_ATTR_GET_AP_TSF])\n\t\tout->report_ap_tsf = true;\n\n\tif (out->report_ap_tsf && !rdev->wiphy.pmsr_capa->report_ap_tsf) {\n\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t    req[NL80211_PMSR_REQ_ATTR_GET_AP_TSF],\n\t\t\t\t    \"reporting AP TSF is not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tnla_for_each_nested(treq, req[NL80211_PMSR_REQ_ATTR_DATA], rem) {\n\t\tswitch (nla_type(treq)) {\n\t\tcase NL80211_PMSR_TYPE_FTM:\n\t\t\terr = pmsr_parse_ftm(rdev, treq, out, info);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack, treq,\n\t\t\t\t\t    \"unsupported measurement type\");\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nint nl80211_pmsr_start(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *reqattr = info->attrs[NL80211_ATTR_PEER_MEASUREMENTS];\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct wireless_dev *wdev = info->user_ptr[1];\n\tstruct cfg80211_pmsr_request *req;\n\tstruct nlattr *peers, *peer;\n\tint count, rem, err, idx;\n\n\tif (!rdev->wiphy.pmsr_capa)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!reqattr)\n\t\treturn -EINVAL;\n\n\tpeers = nla_find(nla_data(reqattr), nla_len(reqattr),\n\t\t\t NL80211_PMSR_ATTR_PEERS);\n\tif (!peers)\n\t\treturn -EINVAL;\n\n\tcount = 0;\n\tnla_for_each_nested(peer, peers, rem) {\n\t\tcount++;\n\n\t\tif (count > rdev->wiphy.pmsr_capa->max_peers) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack, peer,\n\t\t\t\t\t    \"Too many peers used\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treq = kzalloc(struct_size(req, peers, count), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\treq->n_peers = count;\n\n\tif (info->attrs[NL80211_ATTR_TIMEOUT])\n\t\treq->timeout = nla_get_u32(info->attrs[NL80211_ATTR_TIMEOUT]);\n\n\tif (info->attrs[NL80211_ATTR_MAC]) {\n\t\tif (!rdev->wiphy.pmsr_capa->randomize_mac_addr) {\n\t\t\tNL_SET_ERR_MSG_ATTR(info->extack,\n\t\t\t\t\t    info->attrs[NL80211_ATTR_MAC],\n\t\t\t\t\t    \"device cannot randomize MAC address\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\terr = nl80211_parse_random_mac(info->attrs, req->mac_addr,\n\t\t\t\t\t       req->mac_addr_mask);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t} else {\n\t\tmemcpy(req->mac_addr, wdev_address(wdev), ETH_ALEN);\n\t\teth_broadcast_addr(req->mac_addr_mask);\n\t}\n\n\tidx = 0;\n\tnla_for_each_nested(peer, peers, rem) {\n\t\t \n\t\terr = pmsr_parse_peer(rdev, peer, &req->peers[idx], info);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tidx++;\n\t}\n\treq->cookie = cfg80211_assign_cookie(rdev);\n\treq->nl_portid = info->snd_portid;\n\n\terr = rdev_start_pmsr(rdev, wdev, req);\n\tif (err)\n\t\tgoto out_err;\n\n\tlist_add_tail(&req->list, &wdev->pmsr_list);\n\n\tnl_set_extack_cookie_u64(info->extack, req->cookie);\n\treturn 0;\nout_err:\n\tkfree(req);\n\treturn err;\n}\n\nvoid cfg80211_pmsr_complete(struct wireless_dev *wdev,\n\t\t\t    struct cfg80211_pmsr_request *req,\n\t\t\t    gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_pmsr_request *tmp, *prev, *to_free = NULL;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\ttrace_cfg80211_pmsr_complete(wdev->wiphy, wdev, req->cookie);\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\tgoto free_request;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0,\n\t\t\t     NL80211_CMD_PEER_MEASUREMENT_COMPLETE);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto free_msg;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, req->cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto free_msg;\n\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_unicast(wiphy_net(wdev->wiphy), msg, req->nl_portid);\n\tgoto free_request;\nfree_msg:\n\tnlmsg_free(msg);\nfree_request:\n\tspin_lock_bh(&wdev->pmsr_lock);\n\t \n\tlist_for_each_entry_safe(tmp, prev, &wdev->pmsr_list, list) {\n\t\tif (tmp == req) {\n\t\t\tlist_del(&req->list);\n\t\t\tto_free = req;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&wdev->pmsr_lock);\n\tkfree(to_free);\n}\nEXPORT_SYMBOL_GPL(cfg80211_pmsr_complete);\n\nstatic int nl80211_pmsr_send_ftm_res(struct sk_buff *msg,\n\t\t\t\t     struct cfg80211_pmsr_result *res)\n{\n\tif (res->status == NL80211_PMSR_STATUS_FAILURE) {\n\t\tif (nla_put_u32(msg, NL80211_PMSR_FTM_RESP_ATTR_FAIL_REASON,\n\t\t\t\tres->ftm.failure_reason))\n\t\t\tgoto error;\n\n\t\tif (res->ftm.failure_reason ==\n\t\t\tNL80211_PMSR_FTM_FAILURE_PEER_BUSY &&\n\t\t    res->ftm.busy_retry_time &&\n\t\t    nla_put_u32(msg, NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME,\n\t\t\t\tres->ftm.busy_retry_time))\n\t\t\tgoto error;\n\n\t\treturn 0;\n\t}\n\n#define PUT(tp, attr, val)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (nla_put_##tp(msg,\t\t\t\t\t\\\n\t\t\t\t NL80211_PMSR_FTM_RESP_ATTR_##attr,\t\\\n\t\t\t\t res->ftm.val))\t\t\t\t\\\n\t\t\tgoto error;\t\t\t\t\t\\\n\t} while (0)\n\n#define PUTOPT(tp, attr, val)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (res->ftm.val##_valid)\t\t\t\t\\\n\t\t\tPUT(tp, attr, val);\t\t\t\t\\\n\t} while (0)\n\n#define PUT_U64(attr, val)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (nla_put_u64_64bit(msg,\t\t\t\t\\\n\t\t\t\t      NL80211_PMSR_FTM_RESP_ATTR_##attr,\\\n\t\t\t\t      res->ftm.val,\t\t\t\\\n\t\t\t\t      NL80211_PMSR_FTM_RESP_ATTR_PAD))\t\\\n\t\t\tgoto error;\t\t\t\t\t\\\n\t} while (0)\n\n#define PUTOPT_U64(attr, val)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (res->ftm.val##_valid)\t\t\t\t\\\n\t\t\tPUT_U64(attr, val);\t\t\t\t\\\n\t} while (0)\n\n\tif (res->ftm.burst_index >= 0)\n\t\tPUT(u32, BURST_INDEX, burst_index);\n\tPUTOPT(u32, NUM_FTMR_ATTEMPTS, num_ftmr_attempts);\n\tPUTOPT(u32, NUM_FTMR_SUCCESSES, num_ftmr_successes);\n\tPUT(u8, NUM_BURSTS_EXP, num_bursts_exp);\n\tPUT(u8, BURST_DURATION, burst_duration);\n\tPUT(u8, FTMS_PER_BURST, ftms_per_burst);\n\tPUTOPT(s32, RSSI_AVG, rssi_avg);\n\tPUTOPT(s32, RSSI_SPREAD, rssi_spread);\n\tif (res->ftm.tx_rate_valid &&\n\t    !nl80211_put_sta_rate(msg, &res->ftm.tx_rate,\n\t\t\t\t  NL80211_PMSR_FTM_RESP_ATTR_TX_RATE))\n\t\tgoto error;\n\tif (res->ftm.rx_rate_valid &&\n\t    !nl80211_put_sta_rate(msg, &res->ftm.rx_rate,\n\t\t\t\t  NL80211_PMSR_FTM_RESP_ATTR_RX_RATE))\n\t\tgoto error;\n\tPUTOPT_U64(RTT_AVG, rtt_avg);\n\tPUTOPT_U64(RTT_VARIANCE, rtt_variance);\n\tPUTOPT_U64(RTT_SPREAD, rtt_spread);\n\tPUTOPT_U64(DIST_AVG, dist_avg);\n\tPUTOPT_U64(DIST_VARIANCE, dist_variance);\n\tPUTOPT_U64(DIST_SPREAD, dist_spread);\n\tif (res->ftm.lci && res->ftm.lci_len &&\n\t    nla_put(msg, NL80211_PMSR_FTM_RESP_ATTR_LCI,\n\t\t    res->ftm.lci_len, res->ftm.lci))\n\t\tgoto error;\n\tif (res->ftm.civicloc && res->ftm.civicloc_len &&\n\t    nla_put(msg, NL80211_PMSR_FTM_RESP_ATTR_CIVICLOC,\n\t\t    res->ftm.civicloc_len, res->ftm.civicloc))\n\t\tgoto error;\n#undef PUT\n#undef PUTOPT\n#undef PUT_U64\n#undef PUTOPT_U64\n\n\treturn 0;\nerror:\n\treturn -ENOSPC;\n}\n\nstatic int nl80211_pmsr_send_result(struct sk_buff *msg,\n\t\t\t\t    struct cfg80211_pmsr_result *res)\n{\n\tstruct nlattr *pmsr, *peers, *peer, *resp, *data, *typedata;\n\n\tpmsr = nla_nest_start_noflag(msg, NL80211_ATTR_PEER_MEASUREMENTS);\n\tif (!pmsr)\n\t\tgoto error;\n\n\tpeers = nla_nest_start_noflag(msg, NL80211_PMSR_ATTR_PEERS);\n\tif (!peers)\n\t\tgoto error;\n\n\tpeer = nla_nest_start_noflag(msg, 1);\n\tif (!peer)\n\t\tgoto error;\n\n\tif (nla_put(msg, NL80211_PMSR_PEER_ATTR_ADDR, ETH_ALEN, res->addr))\n\t\tgoto error;\n\n\tresp = nla_nest_start_noflag(msg, NL80211_PMSR_PEER_ATTR_RESP);\n\tif (!resp)\n\t\tgoto error;\n\n\tif (nla_put_u32(msg, NL80211_PMSR_RESP_ATTR_STATUS, res->status) ||\n\t    nla_put_u64_64bit(msg, NL80211_PMSR_RESP_ATTR_HOST_TIME,\n\t\t\t      res->host_time, NL80211_PMSR_RESP_ATTR_PAD))\n\t\tgoto error;\n\n\tif (res->ap_tsf_valid &&\n\t    nla_put_u64_64bit(msg, NL80211_PMSR_RESP_ATTR_AP_TSF,\n\t\t\t      res->ap_tsf, NL80211_PMSR_RESP_ATTR_PAD))\n\t\tgoto error;\n\n\tif (res->final && nla_put_flag(msg, NL80211_PMSR_RESP_ATTR_FINAL))\n\t\tgoto error;\n\n\tdata = nla_nest_start_noflag(msg, NL80211_PMSR_RESP_ATTR_DATA);\n\tif (!data)\n\t\tgoto error;\n\n\ttypedata = nla_nest_start_noflag(msg, res->type);\n\tif (!typedata)\n\t\tgoto error;\n\n\tswitch (res->type) {\n\tcase NL80211_PMSR_TYPE_FTM:\n\t\tif (nl80211_pmsr_send_ftm_res(msg, res))\n\t\t\tgoto error;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tnla_nest_end(msg, typedata);\n\tnla_nest_end(msg, data);\n\tnla_nest_end(msg, resp);\n\tnla_nest_end(msg, peer);\n\tnla_nest_end(msg, peers);\n\tnla_nest_end(msg, pmsr);\n\n\treturn 0;\nerror:\n\treturn -ENOSPC;\n}\n\nvoid cfg80211_pmsr_report(struct wireless_dev *wdev,\n\t\t\t  struct cfg80211_pmsr_request *req,\n\t\t\t  struct cfg80211_pmsr_result *result,\n\t\t\t  gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\ttrace_cfg80211_pmsr_report(wdev->wiphy, wdev, req->cookie,\n\t\t\t\t   result->addr);\n\n\t \n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PEER_MEASUREMENT_RESULT);\n\tif (!hdr)\n\t\tgoto free;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u64_64bit(msg, NL80211_ATTR_WDEV, wdev_id(wdev),\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto free;\n\n\tif (nla_put_u64_64bit(msg, NL80211_ATTR_COOKIE, req->cookie,\n\t\t\t      NL80211_ATTR_PAD))\n\t\tgoto free;\n\n\terr = nl80211_pmsr_send_result(msg, result);\n\tif (err) {\n\t\tpr_err_ratelimited(\"peer measurement result: message didn't fit!\");\n\t\tgoto free;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_unicast(wiphy_net(wdev->wiphy), msg, req->nl_portid);\n\treturn;\nfree:\n\tnlmsg_free(msg);\n}\nEXPORT_SYMBOL_GPL(cfg80211_pmsr_report);\n\nstatic void cfg80211_pmsr_process_abort(struct wireless_dev *wdev)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_pmsr_request *req, *tmp;\n\tLIST_HEAD(free_list);\n\n\tlockdep_assert_held(&wdev->mtx);\n\n\tspin_lock_bh(&wdev->pmsr_lock);\n\tlist_for_each_entry_safe(req, tmp, &wdev->pmsr_list, list) {\n\t\tif (req->nl_portid)\n\t\t\tcontinue;\n\t\tlist_move_tail(&req->list, &free_list);\n\t}\n\tspin_unlock_bh(&wdev->pmsr_lock);\n\n\tlist_for_each_entry_safe(req, tmp, &free_list, list) {\n\t\trdev_abort_pmsr(rdev, wdev, req);\n\n\t\tkfree(req);\n\t}\n}\n\nvoid cfg80211_pmsr_free_wk(struct work_struct *work)\n{\n\tstruct wireless_dev *wdev = container_of(work, struct wireless_dev,\n\t\t\t\t\t\t pmsr_free_wk);\n\n\twiphy_lock(wdev->wiphy);\n\twdev_lock(wdev);\n\tcfg80211_pmsr_process_abort(wdev);\n\twdev_unlock(wdev);\n\twiphy_unlock(wdev->wiphy);\n}\n\nvoid cfg80211_pmsr_wdev_down(struct wireless_dev *wdev)\n{\n\tstruct cfg80211_pmsr_request *req;\n\tbool found = false;\n\n\tspin_lock_bh(&wdev->pmsr_lock);\n\tlist_for_each_entry(req, &wdev->pmsr_list, list) {\n\t\tfound = true;\n\t\treq->nl_portid = 0;\n\t}\n\tspin_unlock_bh(&wdev->pmsr_lock);\n\n\tif (found)\n\t\tcfg80211_pmsr_process_abort(wdev);\n\n\tWARN_ON(!list_empty(&wdev->pmsr_list));\n}\n\nvoid cfg80211_release_pmsr(struct wireless_dev *wdev, u32 portid)\n{\n\tstruct cfg80211_pmsr_request *req;\n\n\tspin_lock_bh(&wdev->pmsr_lock);\n\tlist_for_each_entry(req, &wdev->pmsr_list, list) {\n\t\tif (req->nl_portid == portid) {\n\t\t\treq->nl_portid = 0;\n\t\t\tschedule_work(&wdev->pmsr_free_wk);\n\t\t}\n\t}\n\tspin_unlock_bh(&wdev->pmsr_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}