{
  "module_name": "wext-core.c",
  "hash_id": "399943f1ef480bd5a71e915143c5db44396b5cb20be6b31e4f669fffe4fedcd0",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/wext-core.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <linux/wireless.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <net/cfg80211.h>\n#include <net/iw_handler.h>\n#include <net/netlink.h>\n#include <net/wext.h>\n#include <net/net_namespace.h>\n\ntypedef int (*wext_ioctl_func)(struct net_device *, struct iwreq *,\n\t\t\t       unsigned int, struct iw_request_info *,\n\t\t\t       iw_handler);\n\n\n \nstatic const struct iw_ioctl_description standard_ioctl[] = {\n\t[IW_IOCTL_IDX(SIOCSIWCOMMIT)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_NULL,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWNAME)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_CHAR,\n\t\t.flags\t\t= IW_DESCR_FLAG_DUMP,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWNWID)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t\t.flags\t\t= IW_DESCR_FLAG_EVENT,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWNWID)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t\t.flags\t\t= IW_DESCR_FLAG_DUMP,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWFREQ)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_FREQ,\n\t\t.flags\t\t= IW_DESCR_FLAG_EVENT,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWFREQ)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_FREQ,\n\t\t.flags\t\t= IW_DESCR_FLAG_DUMP,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWMODE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_UINT,\n\t\t.flags\t\t= IW_DESCR_FLAG_EVENT,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWMODE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_UINT,\n\t\t.flags\t\t= IW_DESCR_FLAG_DUMP,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWSENS)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWSENS)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWRANGE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_NULL,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWRANGE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= sizeof(struct iw_range),\n\t\t.flags\t\t= IW_DESCR_FLAG_DUMP,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWPRIV)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_NULL,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWPRIV)] = {  \n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= sizeof(struct iw_priv_args),\n\t\t.max_tokens\t= 16,\n\t\t.flags\t\t= IW_DESCR_FLAG_NOMAX,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWSTATS)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_NULL,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWSTATS)] = {  \n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= sizeof(struct iw_statistics),\n\t\t.flags\t\t= IW_DESCR_FLAG_DUMP,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWSPY)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= sizeof(struct sockaddr),\n\t\t.max_tokens\t= IW_MAX_SPY,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWSPY)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= sizeof(struct sockaddr) +\n\t\t\t\t  sizeof(struct iw_quality),\n\t\t.max_tokens\t= IW_MAX_SPY,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWTHRSPY)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= sizeof(struct iw_thrspy),\n\t\t.min_tokens\t= 1,\n\t\t.max_tokens\t= 1,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWTHRSPY)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= sizeof(struct iw_thrspy),\n\t\t.min_tokens\t= 1,\n\t\t.max_tokens\t= 1,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWAP)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_ADDR,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWAP)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_ADDR,\n\t\t.flags\t\t= IW_DESCR_FLAG_DUMP,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWMLME)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.min_tokens\t= sizeof(struct iw_mlme),\n\t\t.max_tokens\t= sizeof(struct iw_mlme),\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWAPLIST)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= sizeof(struct sockaddr) +\n\t\t\t\t  sizeof(struct iw_quality),\n\t\t.max_tokens\t= IW_MAX_AP,\n\t\t.flags\t\t= IW_DESCR_FLAG_NOMAX,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWSCAN)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.min_tokens\t= 0,\n\t\t.max_tokens\t= sizeof(struct iw_scan_req),\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWSCAN)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_SCAN_MAX_DATA,\n\t\t.flags\t\t= IW_DESCR_FLAG_NOMAX,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWESSID)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_ESSID_MAX_SIZE,\n\t\t.flags\t\t= IW_DESCR_FLAG_EVENT,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWESSID)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_ESSID_MAX_SIZE,\n\t\t.flags\t\t= IW_DESCR_FLAG_DUMP,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWNICKN)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_ESSID_MAX_SIZE,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWNICKN)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_ESSID_MAX_SIZE,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWRATE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWRATE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWRTS)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWRTS)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWFRAG)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWFRAG)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWTXPOW)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWTXPOW)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWRETRY)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWRETRY)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWENCODE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_ENCODING_TOKEN_MAX,\n\t\t.flags\t\t= IW_DESCR_FLAG_EVENT | IW_DESCR_FLAG_RESTRICT,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWENCODE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_ENCODING_TOKEN_MAX,\n\t\t.flags\t\t= IW_DESCR_FLAG_DUMP | IW_DESCR_FLAG_RESTRICT,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWPOWER)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWPOWER)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWGENIE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_GENERIC_IE_MAX,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWGENIE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_GENERIC_IE_MAX,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWAUTH)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWAUTH)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_PARAM,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWENCODEEXT)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.min_tokens\t= sizeof(struct iw_encode_ext),\n\t\t.max_tokens\t= sizeof(struct iw_encode_ext) +\n\t\t\t\t  IW_ENCODING_TOKEN_MAX,\n\t},\n\t[IW_IOCTL_IDX(SIOCGIWENCODEEXT)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.min_tokens\t= sizeof(struct iw_encode_ext),\n\t\t.max_tokens\t= sizeof(struct iw_encode_ext) +\n\t\t\t\t  IW_ENCODING_TOKEN_MAX,\n\t},\n\t[IW_IOCTL_IDX(SIOCSIWPMKSA)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.min_tokens\t= sizeof(struct iw_pmksa),\n\t\t.max_tokens\t= sizeof(struct iw_pmksa),\n\t},\n};\nstatic const unsigned int standard_ioctl_num = ARRAY_SIZE(standard_ioctl);\n\n \nstatic const struct iw_ioctl_description standard_event[] = {\n\t[IW_EVENT_IDX(IWEVTXDROP)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_ADDR,\n\t},\n\t[IW_EVENT_IDX(IWEVQUAL)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_QUAL,\n\t},\n\t[IW_EVENT_IDX(IWEVCUSTOM)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_CUSTOM_MAX,\n\t},\n\t[IW_EVENT_IDX(IWEVREGISTERED)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_ADDR,\n\t},\n\t[IW_EVENT_IDX(IWEVEXPIRED)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_ADDR,\n\t},\n\t[IW_EVENT_IDX(IWEVGENIE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_GENERIC_IE_MAX,\n\t},\n\t[IW_EVENT_IDX(IWEVMICHAELMICFAILURE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= sizeof(struct iw_michaelmicfailure),\n\t},\n\t[IW_EVENT_IDX(IWEVASSOCREQIE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_GENERIC_IE_MAX,\n\t},\n\t[IW_EVENT_IDX(IWEVASSOCRESPIE)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= IW_GENERIC_IE_MAX,\n\t},\n\t[IW_EVENT_IDX(IWEVPMKIDCAND)] = {\n\t\t.header_type\t= IW_HEADER_TYPE_POINT,\n\t\t.token_size\t= 1,\n\t\t.max_tokens\t= sizeof(struct iw_pmkid_cand),\n\t},\n};\nstatic const unsigned int standard_event_num = ARRAY_SIZE(standard_event);\n\n \nstatic const int event_type_size[] = {\n\tIW_EV_LCP_LEN,\t\t\t \n\t0,\n\tIW_EV_CHAR_LEN,\t\t\t \n\t0,\n\tIW_EV_UINT_LEN,\t\t\t \n\tIW_EV_FREQ_LEN,\t\t\t \n\tIW_EV_ADDR_LEN,\t\t\t \n\t0,\n\tIW_EV_POINT_LEN,\t\t \n\tIW_EV_PARAM_LEN,\t\t \n\tIW_EV_QUAL_LEN,\t\t\t \n};\n\n#ifdef CONFIG_COMPAT\nstatic const int compat_event_type_size[] = {\n\tIW_EV_COMPAT_LCP_LEN,\t\t \n\t0,\n\tIW_EV_COMPAT_CHAR_LEN,\t\t \n\t0,\n\tIW_EV_COMPAT_UINT_LEN,\t\t \n\tIW_EV_COMPAT_FREQ_LEN,\t\t \n\tIW_EV_COMPAT_ADDR_LEN,\t\t \n\t0,\n\tIW_EV_COMPAT_POINT_LEN,\t\t \n\tIW_EV_COMPAT_PARAM_LEN,\t\t \n\tIW_EV_COMPAT_QUAL_LEN,\t\t \n};\n#endif\n\n\n \n\nvoid wireless_nlevent_flush(void)\n{\n\tstruct sk_buff *skb;\n\tstruct net *net;\n\n\tdown_read(&net_rwsem);\n\tfor_each_net(net) {\n\t\twhile ((skb = skb_dequeue(&net->wext_nlevents)))\n\t\t\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL,\n\t\t\t\t    GFP_KERNEL);\n\t}\n\tup_read(&net_rwsem);\n}\nEXPORT_SYMBOL_GPL(wireless_nlevent_flush);\n\nstatic int wext_netdev_notifier_call(struct notifier_block *nb,\n\t\t\t\t     unsigned long state, void *ptr)\n{\n\t \n\twireless_nlevent_flush();\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block wext_netdev_notifier = {\n\t.notifier_call = wext_netdev_notifier_call,\n};\n\nstatic int __net_init wext_pernet_init(struct net *net)\n{\n\tskb_queue_head_init(&net->wext_nlevents);\n\treturn 0;\n}\n\nstatic void __net_exit wext_pernet_exit(struct net *net)\n{\n\tskb_queue_purge(&net->wext_nlevents);\n}\n\nstatic struct pernet_operations wext_pernet_ops = {\n\t.init = wext_pernet_init,\n\t.exit = wext_pernet_exit,\n};\n\nstatic int __init wireless_nlevent_init(void)\n{\n\tint err = register_pernet_subsys(&wext_pernet_ops);\n\n\tif (err)\n\t\treturn err;\n\n\terr = register_netdevice_notifier(&wext_netdev_notifier);\n\tif (err)\n\t\tunregister_pernet_subsys(&wext_pernet_ops);\n\treturn err;\n}\n\nsubsys_initcall(wireless_nlevent_init);\n\n \nstatic void wireless_nlevent_process(struct work_struct *work)\n{\n\twireless_nlevent_flush();\n}\n\nstatic DECLARE_WORK(wireless_nlevent_work, wireless_nlevent_process);\n\nstatic struct nlmsghdr *rtnetlink_ifinfo_prep(struct net_device *dev,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\n\tnlh = nlmsg_put(skb, 0, 0, RTM_NEWLINK, sizeof(*r), 0);\n\tif (!nlh)\n\t\treturn NULL;\n\n\tr = nlmsg_data(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->__ifi_pad = 0;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev_get_flags(dev);\n\tr->ifi_change = 0;\t \n\n\tif (nla_put_string(skb, IFLA_IFNAME, dev->name))\n\t\tgoto nla_put_failure;\n\n\treturn nlh;\n nla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn NULL;\n}\n\n\n \nvoid wireless_send_event(struct net_device *\tdev,\n\t\t\t unsigned int\t\tcmd,\n\t\t\t union iwreq_data *\twrqu,\n\t\t\t const char *\t\textra)\n{\n\tconst struct iw_ioctl_description *\tdescr = NULL;\n\tint extra_len = 0;\n\tstruct iw_event  *event;\t\t \n\tint event_len;\t\t\t\t \n\tint hdr_len;\t\t\t\t \n\tint wrqu_off = 0;\t\t\t \n\t \n\tunsigned int\tcmd_index;\t\t \n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\tstruct nlattr *nla;\n#ifdef CONFIG_COMPAT\n\tstruct __compat_iw_event *compat_event;\n\tstruct compat_iw_point compat_wrqu;\n\tstruct sk_buff *compskb;\n\tint ptr_len;\n#endif\n\n\t \n\tif (WARN_ON(cmd == SIOCGIWSCAN && extra))\n\t\textra = NULL;\n\n\t \n\tif (cmd <= SIOCIWLAST) {\n\t\tcmd_index = IW_IOCTL_IDX(cmd);\n\t\tif (cmd_index < standard_ioctl_num)\n\t\t\tdescr = &(standard_ioctl[cmd_index]);\n\t} else {\n\t\tcmd_index = IW_EVENT_IDX(cmd);\n\t\tif (cmd_index < standard_event_num)\n\t\t\tdescr = &(standard_event[cmd_index]);\n\t}\n\t \n\tif (descr == NULL) {\n\t\t \n\t\tnetdev_err(dev, \"(WE) : Invalid/Unknown Wireless Event (0x%04X)\\n\",\n\t\t\t   cmd);\n\t\treturn;\n\t}\n\n\t \n\tif (descr->header_type == IW_HEADER_TYPE_POINT) {\n\t\t \n\t\tif (wrqu->data.length > descr->max_tokens) {\n\t\t\tnetdev_err(dev, \"(WE) : Wireless Event (cmd=0x%04X) too big (%d)\\n\",\n\t\t\t\t   cmd, wrqu->data.length);\n\t\t\treturn;\n\t\t}\n\t\tif (wrqu->data.length < descr->min_tokens) {\n\t\t\tnetdev_err(dev, \"(WE) : Wireless Event (cmd=0x%04X) too small (%d)\\n\",\n\t\t\t\t   cmd, wrqu->data.length);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (extra != NULL)\n\t\t\textra_len = wrqu->data.length * descr->token_size;\n\t\t \n\t\twrqu_off = IW_EV_POINT_OFF;\n\t}\n\n\t \n\thdr_len = event_type_size[descr->header_type];\n\tevent_len = hdr_len + extra_len;\n\n\t \n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\t \n\tnlh = rtnetlink_ifinfo_prep(dev, skb);\n\tif (WARN_ON(!nlh)) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tnla = nla_reserve(skb, IFLA_WIRELESS, event_len);\n\tif (!nla) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tevent = nla_data(nla);\n\n\t \n\tmemset(event, 0, hdr_len);\n\tevent->len = event_len;\n\tevent->cmd = cmd;\n\tmemcpy(&event->u, ((char *) wrqu) + wrqu_off, hdr_len - IW_EV_LCP_LEN);\n\tif (extra_len)\n\t\tmemcpy(((char *) event) + hdr_len, extra, extra_len);\n\n\tnlmsg_end(skb, nlh);\n#ifdef CONFIG_COMPAT\n\thdr_len = compat_event_type_size[descr->header_type];\n\n\t \n\tptr_len = hdr_len - IW_EV_COMPAT_LCP_LEN;\n\tevent_len = hdr_len + extra_len;\n\n\tcompskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!compskb) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tnlh = rtnetlink_ifinfo_prep(dev, compskb);\n\tif (WARN_ON(!nlh)) {\n\t\tkfree_skb(skb);\n\t\tkfree_skb(compskb);\n\t\treturn;\n\t}\n\n\t \n\tnla = nla_reserve(compskb, IFLA_WIRELESS, event_len);\n\tif (!nla) {\n\t\tkfree_skb(skb);\n\t\tkfree_skb(compskb);\n\t\treturn;\n\t}\n\tcompat_event = nla_data(nla);\n\n\tcompat_event->len = event_len;\n\tcompat_event->cmd = cmd;\n\tif (descr->header_type == IW_HEADER_TYPE_POINT) {\n\t\tcompat_wrqu.length = wrqu->data.length;\n\t\tcompat_wrqu.flags = wrqu->data.flags;\n\t\tmemcpy(compat_event->ptr_bytes,\n\t\t       ((char *)&compat_wrqu) + IW_EV_COMPAT_POINT_OFF,\n\t\t\tptr_len);\n\t\tif (extra_len)\n\t\t\tmemcpy(&compat_event->ptr_bytes[ptr_len],\n\t\t\t       extra, extra_len);\n\t} else {\n\t\t \n\t\tmemcpy(compat_event->ptr_bytes, wrqu, ptr_len);\n\t}\n\n\tnlmsg_end(compskb, nlh);\n\n\tskb_shinfo(skb)->frag_list = compskb;\n#endif\n\tskb_queue_tail(&dev_net(dev)->wext_nlevents, skb);\n\tschedule_work(&wireless_nlevent_work);\n}\nEXPORT_SYMBOL(wireless_send_event);\n\n#ifdef CONFIG_CFG80211_WEXT\nstatic void wireless_warn_cfg80211_wext(void)\n{\n\tchar name[sizeof(current->comm)];\n\n\tpr_warn_once(\"warning: `%s' uses wireless extensions which will stop working for Wi-Fi 7 hardware; use nl80211\\n\",\n\t\t     get_task_comm(name, current));\n}\n#endif\n\n \n\nstruct iw_statistics *get_wireless_stats(struct net_device *dev)\n{\n#ifdef CONFIG_WIRELESS_EXT\n\tif ((dev->wireless_handlers != NULL) &&\n\t   (dev->wireless_handlers->get_wireless_stats != NULL))\n\t\treturn dev->wireless_handlers->get_wireless_stats(dev);\n#endif\n\n#ifdef CONFIG_CFG80211_WEXT\n\tif (dev->ieee80211_ptr &&\n\t    dev->ieee80211_ptr->wiphy &&\n\t    dev->ieee80211_ptr->wiphy->wext &&\n\t    dev->ieee80211_ptr->wiphy->wext->get_wireless_stats) {\n\t\twireless_warn_cfg80211_wext();\n\t\tif (dev->ieee80211_ptr->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO)\n\t\t\treturn NULL;\n\t\treturn dev->ieee80211_ptr->wiphy->wext->get_wireless_stats(dev);\n\t}\n#endif\n\n\t \n\treturn NULL;\n}\n\n \nstatic noinline int iw_handler_get_iwstats(struct net_device *\tdev,\n\t\t\t\t  struct iw_request_info *\tinfo,\n\t\t\t\t  union iwreq_data *\t\twrqu,\n\t\t\t\t  char *\t\t\textra)\n{\n\t \n\tstruct iw_statistics *stats;\n\n\tstats = get_wireless_stats(dev);\n\tif (stats) {\n\t\t \n\t\tmemcpy(extra, stats, sizeof(struct iw_statistics));\n\t\twrqu->data.length = sizeof(struct iw_statistics);\n\n\t\t \n\t\tif (wrqu->data.flags != 0)\n\t\t\tstats->qual.updated &= ~IW_QUAL_ALL_UPDATED;\n\t\treturn 0;\n\t} else\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic iw_handler get_handler(struct net_device *dev, unsigned int cmd)\n{\n\t \n\tunsigned int\tindex;\t\t \n\tconst struct iw_handler_def *handlers = NULL;\n\n#ifdef CONFIG_CFG80211_WEXT\n\tif (dev->ieee80211_ptr && dev->ieee80211_ptr->wiphy) {\n\t\twireless_warn_cfg80211_wext();\n\t\tif (dev->ieee80211_ptr->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO)\n\t\t\treturn NULL;\n\t\thandlers = dev->ieee80211_ptr->wiphy->wext;\n\t}\n#endif\n#ifdef CONFIG_WIRELESS_EXT\n\tif (dev->wireless_handlers)\n\t\thandlers = dev->wireless_handlers;\n#endif\n\n\tif (!handlers)\n\t\treturn NULL;\n\n\t \n\tindex = IW_IOCTL_IDX(cmd);\n\tif (index < handlers->num_standard)\n\t\treturn handlers->standard[index];\n\n#ifdef CONFIG_WEXT_PRIV\n\t \n\tindex = cmd - SIOCIWFIRSTPRIV;\n\tif (index < handlers->num_private)\n\t\treturn handlers->private[index];\n#endif\n\n\t \n\treturn NULL;\n}\n\nstatic int ioctl_standard_iw_point(struct iw_point *iwp, unsigned int cmd,\n\t\t\t\t   const struct iw_ioctl_description *descr,\n\t\t\t\t   iw_handler handler, struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info)\n{\n\tint err, extra_size, user_length = 0, essid_compat = 0;\n\tchar *extra;\n\n\t \n\textra_size = descr->max_tokens * descr->token_size;\n\n\t \n\tswitch (cmd) {\n\tcase SIOCSIWESSID:\n\tcase SIOCGIWESSID:\n\tcase SIOCSIWNICKN:\n\tcase SIOCGIWNICKN:\n\t\tif (iwp->length == descr->max_tokens + 1)\n\t\t\tessid_compat = 1;\n\t\telse if (IW_IS_SET(cmd) && (iwp->length != 0)) {\n\t\t\tchar essid[IW_ESSID_MAX_SIZE + 1];\n\t\t\tunsigned int len;\n\t\t\tlen = iwp->length * descr->token_size;\n\n\t\t\tif (len > IW_ESSID_MAX_SIZE)\n\t\t\t\treturn -EFAULT;\n\n\t\t\terr = copy_from_user(essid, iwp->pointer, len);\n\t\t\tif (err)\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (essid[iwp->length - 1] == '\\0')\n\t\t\t\tessid_compat = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tiwp->length -= essid_compat;\n\n\t \n\tif (IW_IS_SET(cmd)) {\n\t\t \n\t\tif (!iwp->pointer && iwp->length != 0)\n\t\t\treturn -EFAULT;\n\t\t \n\t\tif (iwp->length > descr->max_tokens)\n\t\t\treturn -E2BIG;\n\t\tif (iwp->length < descr->min_tokens)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tif (!iwp->pointer)\n\t\t\treturn -EFAULT;\n\t\t \n\t\tuser_length = iwp->length;\n\n\t\t \n\n\t\t \n\t\tif ((descr->flags & IW_DESCR_FLAG_NOMAX) &&\n\t\t    (user_length > descr->max_tokens)) {\n\t\t\t \n\t\t\textra_size = user_length * descr->token_size;\n\n\t\t\t \n\t\t}\n\t}\n\n\t \n\tif (extra_size <= 0)\n\t\treturn -EFAULT;\n\n\t \n\textra = kzalloc(extra_size, GFP_KERNEL);\n\tif (!extra)\n\t\treturn -ENOMEM;\n\n\t \n\tif (IW_IS_SET(cmd) && (iwp->length != 0)) {\n\t\tif (copy_from_user(extra, iwp->pointer,\n\t\t\t\t   iwp->length *\n\t\t\t\t   descr->token_size)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cmd == SIOCSIWENCODEEXT) {\n\t\t\tstruct iw_encode_ext *ee = (void *) extra;\n\n\t\t\tif (iwp->length < sizeof(*ee) + ee->key_len) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (IW_IS_GET(cmd) && !(descr->flags & IW_DESCR_FLAG_NOMAX)) {\n\t\t \n\t\tiwp->length = descr->max_tokens;\n\t}\n\n\terr = handler(dev, info, (union iwreq_data *) iwp, extra);\n\n\tiwp->length += essid_compat;\n\n\t \n\tif (!err && IW_IS_GET(cmd)) {\n\t\t \n\t\tif (user_length < iwp->length) {\n\t\t\terr = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_to_user(iwp->pointer, extra,\n\t\t\t\t iwp->length *\n\t\t\t\t descr->token_size)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif ((descr->flags & IW_DESCR_FLAG_EVENT) &&\n\t    ((err == 0) || (err == -EIWCOMMIT))) {\n\t\tunion iwreq_data *data = (union iwreq_data *) iwp;\n\n\t\tif (descr->flags & IW_DESCR_FLAG_RESTRICT)\n\t\t\t \n\t\t\twireless_send_event(dev, cmd, data, NULL);\n\t\telse\n\t\t\twireless_send_event(dev, cmd, data, extra);\n\t}\n\nout:\n\tkfree(extra);\n\treturn err;\n}\n\n \nint call_commit_handler(struct net_device *dev)\n{\n#ifdef CONFIG_WIRELESS_EXT\n\tif (netif_running(dev) &&\n\t    dev->wireless_handlers &&\n\t    dev->wireless_handlers->standard[0])\n\t\t \n\t\treturn dev->wireless_handlers->standard[0](dev, NULL,\n\t\t\t\t\t\t\t   NULL, NULL);\n\telse\n\t\treturn 0;\t\t \n#else\n\t \n\treturn 0;\n#endif\n}\n\n \nstatic int wireless_process_ioctl(struct net *net, struct iwreq *iwr,\n\t\t\t\t  unsigned int cmd,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  wext_ioctl_func standard,\n\t\t\t\t  wext_ioctl_func private)\n{\n\tstruct net_device *dev;\n\tiw_handler\thandler;\n\n\t \n\n\t \n\tif ((dev = __dev_get_by_name(net, iwr->ifr_name)) == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tif (cmd == SIOCGIWSTATS)\n\t\treturn standard(dev, iwr, cmd, info,\n\t\t\t\t&iw_handler_get_iwstats);\n\n#ifdef CONFIG_WEXT_PRIV\n\tif (cmd == SIOCGIWPRIV && dev->wireless_handlers)\n\t\treturn standard(dev, iwr, cmd, info,\n\t\t\t\tiw_handler_get_private);\n#endif\n\n\t \n\tif (!netif_device_present(dev))\n\t\treturn -ENODEV;\n\n\t \n\thandler = get_handler(dev, cmd);\n\tif (handler) {\n\t\t \n\t\tif (cmd < SIOCIWFIRSTPRIV)\n\t\t\treturn standard(dev, iwr, cmd, info, handler);\n\t\telse if (private)\n\t\t\treturn private(dev, iwr, cmd, info, handler);\n\t}\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic int wext_permission_check(unsigned int cmd)\n{\n\tif ((IW_IS_SET(cmd) || cmd == SIOCGIWENCODE ||\n\t     cmd == SIOCGIWENCODEEXT) &&\n\t    !capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\n \nstatic int wext_ioctl_dispatch(struct net *net, struct iwreq *iwr,\n\t\t\t       unsigned int cmd, struct iw_request_info *info,\n\t\t\t       wext_ioctl_func standard,\n\t\t\t       wext_ioctl_func private)\n{\n\tint ret = wext_permission_check(cmd);\n\n\tif (ret)\n\t\treturn ret;\n\n\tdev_load(net, iwr->ifr_name);\n\trtnl_lock();\n\tret = wireless_process_ioctl(net, iwr, cmd, info, standard, private);\n\trtnl_unlock();\n\n\treturn ret;\n}\n\n \nstatic int ioctl_standard_call(struct net_device *\tdev,\n\t\t\t       struct iwreq\t\t*iwr,\n\t\t\t       unsigned int\t\tcmd,\n\t\t\t       struct iw_request_info\t*info,\n\t\t\t       iw_handler\t\thandler)\n{\n\tconst struct iw_ioctl_description *\tdescr;\n\tint\t\t\t\t\tret = -EINVAL;\n\n\t \n\tif (IW_IOCTL_IDX(cmd) >= standard_ioctl_num)\n\t\treturn -EOPNOTSUPP;\n\tdescr = &(standard_ioctl[IW_IOCTL_IDX(cmd)]);\n\n\t \n\tif (descr->header_type != IW_HEADER_TYPE_POINT) {\n\n\t\t \n\t\tret = handler(dev, info, &(iwr->u), NULL);\n\n\t\t \n\t\tif ((descr->flags & IW_DESCR_FLAG_EVENT) &&\n\t\t   ((ret == 0) || (ret == -EIWCOMMIT)))\n\t\t\twireless_send_event(dev, cmd, &(iwr->u), NULL);\n\t} else {\n\t\tret = ioctl_standard_iw_point(&iwr->u.data, cmd, descr,\n\t\t\t\t\t      handler, dev, info);\n\t}\n\n\t \n\tif (ret == -EIWCOMMIT)\n\t\tret = call_commit_handler(dev);\n\n\t \n\n\treturn ret;\n}\n\n\nint wext_handle_ioctl(struct net *net, unsigned int cmd, void __user *arg)\n{\n\tstruct iw_request_info info = { .cmd = cmd, .flags = 0 };\n\tstruct iwreq iwr;\n\tint ret;\n\n\tif (copy_from_user(&iwr, arg, sizeof(iwr)))\n\t\treturn -EFAULT;\n\n\tiwr.ifr_name[sizeof(iwr.ifr_name) - 1] = 0;\n\n\tret = wext_ioctl_dispatch(net, &iwr, cmd, &info,\n\t\t\t\t  ioctl_standard_call,\n\t\t\t\t  ioctl_private_call);\n\tif (ret >= 0 &&\n\t    IW_IS_GET(cmd) &&\n\t    copy_to_user(arg, &iwr, sizeof(struct iwreq)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int compat_standard_call(struct net_device\t*dev,\n\t\t\t\tstruct iwreq\t\t*iwr,\n\t\t\t\tunsigned int\t\tcmd,\n\t\t\t\tstruct iw_request_info\t*info,\n\t\t\t\tiw_handler\t\thandler)\n{\n\tconst struct iw_ioctl_description *descr;\n\tstruct compat_iw_point *iwp_compat;\n\tstruct iw_point iwp;\n\tint err;\n\n\tdescr = standard_ioctl + IW_IOCTL_IDX(cmd);\n\n\tif (descr->header_type != IW_HEADER_TYPE_POINT)\n\t\treturn ioctl_standard_call(dev, iwr, cmd, info, handler);\n\n\tiwp_compat = (struct compat_iw_point *) &iwr->u.data;\n\tiwp.pointer = compat_ptr(iwp_compat->pointer);\n\tiwp.length = iwp_compat->length;\n\tiwp.flags = iwp_compat->flags;\n\n\terr = ioctl_standard_iw_point(&iwp, cmd, descr, handler, dev, info);\n\n\tiwp_compat->pointer = ptr_to_compat(iwp.pointer);\n\tiwp_compat->length = iwp.length;\n\tiwp_compat->flags = iwp.flags;\n\n\treturn err;\n}\n\nint compat_wext_handle_ioctl(struct net *net, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tstruct iw_request_info info;\n\tstruct iwreq iwr;\n\tchar *colon;\n\tint ret;\n\n\tif (copy_from_user(&iwr, argp, sizeof(struct iwreq)))\n\t\treturn -EFAULT;\n\n\tiwr.ifr_name[IFNAMSIZ-1] = 0;\n\tcolon = strchr(iwr.ifr_name, ':');\n\tif (colon)\n\t\t*colon = 0;\n\n\tinfo.cmd = cmd;\n\tinfo.flags = IW_REQUEST_FLAG_COMPAT;\n\n\tret = wext_ioctl_dispatch(net, &iwr, cmd, &info,\n\t\t\t\t  compat_standard_call,\n\t\t\t\t  compat_private_call);\n\n\tif (ret >= 0 &&\n\t    IW_IS_GET(cmd) &&\n\t    copy_to_user(argp, &iwr, sizeof(struct iwreq)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n#endif\n\nchar *iwe_stream_add_event(struct iw_request_info *info, char *stream,\n\t\t\t   char *ends, struct iw_event *iwe, int event_len)\n{\n\tint lcp_len = iwe_stream_lcp_len(info);\n\n\tevent_len = iwe_stream_event_len_adjust(info, event_len);\n\n\t \n\tif (likely((stream + event_len) < ends)) {\n\t\tiwe->len = event_len;\n\t\t \n\t\tmemcpy(stream, (char *) iwe, IW_EV_LCP_PK_LEN);\n\t\tmemcpy(stream + lcp_len, &iwe->u,\n\t\t       event_len - lcp_len);\n\t\tstream += event_len;\n\t}\n\n\treturn stream;\n}\nEXPORT_SYMBOL(iwe_stream_add_event);\n\nchar *iwe_stream_add_point(struct iw_request_info *info, char *stream,\n\t\t\t   char *ends, struct iw_event *iwe, char *extra)\n{\n\tint event_len = iwe_stream_point_len(info) + iwe->u.data.length;\n\tint point_len = iwe_stream_point_len(info);\n\tint lcp_len   = iwe_stream_lcp_len(info);\n\n\t \n\tif (likely((stream + event_len) < ends)) {\n\t\tiwe->len = event_len;\n\t\tmemcpy(stream, (char *) iwe, IW_EV_LCP_PK_LEN);\n\t\tmemcpy(stream + lcp_len,\n\t\t       ((char *) &iwe->u) + IW_EV_POINT_OFF,\n\t\t       IW_EV_POINT_PK_LEN - IW_EV_LCP_PK_LEN);\n\t\tif (iwe->u.data.length && extra)\n\t\t\tmemcpy(stream + point_len, extra, iwe->u.data.length);\n\t\tstream += event_len;\n\t}\n\n\treturn stream;\n}\nEXPORT_SYMBOL(iwe_stream_add_point);\n\nchar *iwe_stream_add_value(struct iw_request_info *info, char *event,\n\t\t\t   char *value, char *ends, struct iw_event *iwe,\n\t\t\t   int event_len)\n{\n\tint lcp_len = iwe_stream_lcp_len(info);\n\n\t \n\tevent_len -= IW_EV_LCP_LEN;\n\n\t \n\tif (likely((value + event_len) < ends)) {\n\t\t \n\t\tmemcpy(value, &iwe->u, event_len);\n\t\tvalue += event_len;\n\t\t \n\t\tiwe->len = value - event;\n\t\tmemcpy(event, (char *) iwe, lcp_len);\n\t}\n\n\treturn value;\n}\nEXPORT_SYMBOL(iwe_stream_add_value);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}