{
  "module_name": "util.c",
  "hash_id": "c4dc1b132c8fba35a5a8e799ebc1bcc2c5cde6c0c938b52a7575538f0f16b285",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/util.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include <linux/ieee80211.h>\n#include <net/cfg80211.h>\n#include <net/ip.h>\n#include <net/dsfield.h>\n#include <linux/if_vlan.h>\n#include <linux/mpls.h>\n#include <linux/gcd.h>\n#include <linux/bitfield.h>\n#include <linux/nospec.h>\n#include \"core.h\"\n#include \"rdev-ops.h\"\n\n\nconst struct ieee80211_rate *\nieee80211_get_response_rate(struct ieee80211_supported_band *sband,\n\t\t\t    u32 basic_rates, int bitrate)\n{\n\tstruct ieee80211_rate *result = &sband->bitrates[0];\n\tint i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tif (!(basic_rates & BIT(i)))\n\t\t\tcontinue;\n\t\tif (sband->bitrates[i].bitrate > bitrate)\n\t\t\tcontinue;\n\t\tresult = &sband->bitrates[i];\n\t}\n\n\treturn result;\n}\nEXPORT_SYMBOL(ieee80211_get_response_rate);\n\nu32 ieee80211_mandatory_rates(struct ieee80211_supported_band *sband,\n\t\t\t      enum nl80211_bss_scan_width scan_width)\n{\n\tstruct ieee80211_rate *bitrates;\n\tu32 mandatory_rates = 0;\n\tenum ieee80211_rate_flags mandatory_flag;\n\tint i;\n\n\tif (WARN_ON(!sband))\n\t\treturn 1;\n\n\tif (sband->band == NL80211_BAND_2GHZ) {\n\t\tif (scan_width == NL80211_BSS_CHAN_WIDTH_5 ||\n\t\t    scan_width == NL80211_BSS_CHAN_WIDTH_10)\n\t\t\tmandatory_flag = IEEE80211_RATE_MANDATORY_G;\n\t\telse\n\t\t\tmandatory_flag = IEEE80211_RATE_MANDATORY_B;\n\t} else {\n\t\tmandatory_flag = IEEE80211_RATE_MANDATORY_A;\n\t}\n\n\tbitrates = sband->bitrates;\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (bitrates[i].flags & mandatory_flag)\n\t\t\tmandatory_rates |= BIT(i);\n\treturn mandatory_rates;\n}\nEXPORT_SYMBOL(ieee80211_mandatory_rates);\n\nu32 ieee80211_channel_to_freq_khz(int chan, enum nl80211_band band)\n{\n\t \n\tif (chan <= 0)\n\t\treturn 0;  \n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\tcase NL80211_BAND_LC:\n\t\tif (chan == 14)\n\t\t\treturn MHZ_TO_KHZ(2484);\n\t\telse if (chan < 14)\n\t\t\treturn MHZ_TO_KHZ(2407 + chan * 5);\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tif (chan >= 182 && chan <= 196)\n\t\t\treturn MHZ_TO_KHZ(4000 + chan * 5);\n\t\telse\n\t\t\treturn MHZ_TO_KHZ(5000 + chan * 5);\n\t\tbreak;\n\tcase NL80211_BAND_6GHZ:\n\t\t \n\t\tif (chan == 2)\n\t\t\treturn MHZ_TO_KHZ(5935);\n\t\tif (chan <= 233)\n\t\t\treturn MHZ_TO_KHZ(5950 + chan * 5);\n\t\tbreak;\n\tcase NL80211_BAND_60GHZ:\n\t\tif (chan < 7)\n\t\t\treturn MHZ_TO_KHZ(56160 + chan * 2160);\n\t\tbreak;\n\tcase NL80211_BAND_S1GHZ:\n\t\treturn 902000 + chan * 500;\n\tdefault:\n\t\t;\n\t}\n\treturn 0;  \n}\nEXPORT_SYMBOL(ieee80211_channel_to_freq_khz);\n\nenum nl80211_chan_width\nieee80211_s1g_channel_width(const struct ieee80211_channel *chan)\n{\n\tif (WARN_ON(!chan || chan->band != NL80211_BAND_S1GHZ))\n\t\treturn NL80211_CHAN_WIDTH_20_NOHT;\n\n\t \n\tif (chan->flags & IEEE80211_CHAN_1MHZ)\n\t\treturn NL80211_CHAN_WIDTH_1;\n\telse if (chan->flags & IEEE80211_CHAN_2MHZ)\n\t\treturn NL80211_CHAN_WIDTH_2;\n\telse if (chan->flags & IEEE80211_CHAN_4MHZ)\n\t\treturn NL80211_CHAN_WIDTH_4;\n\telse if (chan->flags & IEEE80211_CHAN_8MHZ)\n\t\treturn NL80211_CHAN_WIDTH_8;\n\telse if (chan->flags & IEEE80211_CHAN_16MHZ)\n\t\treturn NL80211_CHAN_WIDTH_16;\n\n\tpr_err(\"unknown channel width for channel at %dKHz?\\n\",\n\t       ieee80211_channel_to_khz(chan));\n\n\treturn NL80211_CHAN_WIDTH_1;\n}\nEXPORT_SYMBOL(ieee80211_s1g_channel_width);\n\nint ieee80211_freq_khz_to_channel(u32 freq)\n{\n\t \n\tfreq = KHZ_TO_MHZ(freq);\n\n\t \n\tif (freq == 2484)\n\t\treturn 14;\n\telse if (freq < 2484)\n\t\treturn (freq - 2407) / 5;\n\telse if (freq >= 4910 && freq <= 4980)\n\t\treturn (freq - 4000) / 5;\n\telse if (freq < 5925)\n\t\treturn (freq - 5000) / 5;\n\telse if (freq == 5935)\n\t\treturn 2;\n\telse if (freq <= 45000)  \n\t\t \n\t\treturn (freq - 5950) / 5;\n\telse if (freq >= 58320 && freq <= 70200)\n\t\treturn (freq - 56160) / 2160;\n\telse\n\t\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_freq_khz_to_channel);\n\nstruct ieee80211_channel *ieee80211_get_channel_khz(struct wiphy *wiphy,\n\t\t\t\t\t\t    u32 freq)\n{\n\tenum nl80211_band band;\n\tstruct ieee80211_supported_band *sband;\n\tint i;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tsband = wiphy->bands[band];\n\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\tstruct ieee80211_channel *chan = &sband->channels[i];\n\n\t\t\tif (ieee80211_channel_to_khz(chan) == freq)\n\t\t\t\treturn chan;\n\t\t}\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(ieee80211_get_channel_khz);\n\nstatic void set_mandatory_flags_band(struct ieee80211_supported_band *sband)\n{\n\tint i, want;\n\n\tswitch (sband->band) {\n\tcase NL80211_BAND_5GHZ:\n\tcase NL80211_BAND_6GHZ:\n\t\twant = 3;\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == 60 ||\n\t\t\t    sband->bitrates[i].bitrate == 120 ||\n\t\t\t    sband->bitrates[i].bitrate == 240) {\n\t\t\t\tsband->bitrates[i].flags |=\n\t\t\t\t\tIEEE80211_RATE_MANDATORY_A;\n\t\t\t\twant--;\n\t\t\t}\n\t\t}\n\t\tWARN_ON(want);\n\t\tbreak;\n\tcase NL80211_BAND_2GHZ:\n\tcase NL80211_BAND_LC:\n\t\twant = 7;\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tswitch (sband->bitrates[i].bitrate) {\n\t\t\tcase 10:\n\t\t\tcase 20:\n\t\t\tcase 55:\n\t\t\tcase 110:\n\t\t\t\tsband->bitrates[i].flags |=\n\t\t\t\t\tIEEE80211_RATE_MANDATORY_B |\n\t\t\t\t\tIEEE80211_RATE_MANDATORY_G;\n\t\t\t\twant--;\n\t\t\t\tbreak;\n\t\t\tcase 60:\n\t\t\tcase 120:\n\t\t\tcase 240:\n\t\t\t\tsband->bitrates[i].flags |=\n\t\t\t\t\tIEEE80211_RATE_MANDATORY_G;\n\t\t\t\twant--;\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tsband->bitrates[i].flags |=\n\t\t\t\t\tIEEE80211_RATE_ERP_G;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tWARN_ON(want != 0 && want != 3);\n\t\tbreak;\n\tcase NL80211_BAND_60GHZ:\n\t\t \n\t\tWARN_ON(!sband->ht_cap.ht_supported);\n\t\tWARN_ON((sband->ht_cap.mcs.rx_mask[0] & 0x1e) != 0x1e);\n\t\tbreak;\n\tcase NL80211_BAND_S1GHZ:\n\t\t \n\t\tWARN_ON((sband->s1g_cap.nss_mcs[0] & 0x3) == 0x3);\n\t\tbreak;\n\tcase NUM_NL80211_BANDS:\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nvoid ieee80211_set_bitrate_flags(struct wiphy *wiphy)\n{\n\tenum nl80211_band band;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++)\n\t\tif (wiphy->bands[band])\n\t\t\tset_mandatory_flags_band(wiphy->bands[band]);\n}\n\nbool cfg80211_supported_cipher_suite(struct wiphy *wiphy, u32 cipher)\n{\n\tint i;\n\tfor (i = 0; i < wiphy->n_cipher_suites; i++)\n\t\tif (cipher == wiphy->cipher_suites[i])\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic bool\ncfg80211_igtk_cipher_supported(struct cfg80211_registered_device *rdev)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tint i;\n\n\tfor (i = 0; i < wiphy->n_cipher_suites; i++) {\n\t\tswitch (wiphy->cipher_suites[i]) {\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool cfg80211_valid_key_idx(struct cfg80211_registered_device *rdev,\n\t\t\t    int key_idx, bool pairwise)\n{\n\tint max_key_idx;\n\n\tif (pairwise)\n\t\tmax_key_idx = 3;\n\telse if (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t NL80211_EXT_FEATURE_BEACON_PROTECTION) ||\n\t\t wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT))\n\t\tmax_key_idx = 7;\n\telse if (cfg80211_igtk_cipher_supported(rdev))\n\t\tmax_key_idx = 5;\n\telse\n\t\tmax_key_idx = 3;\n\n\tif (key_idx < 0 || key_idx > max_key_idx)\n\t\treturn false;\n\n\treturn true;\n}\n\nint cfg80211_validate_key_settings(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct key_params *params, int key_idx,\n\t\t\t\t   bool pairwise, const u8 *mac_addr)\n{\n\tif (!cfg80211_valid_key_idx(rdev, key_idx, pairwise))\n\t\treturn -EINVAL;\n\n\tif (!pairwise && mac_addr && !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\treturn -EINVAL;\n\n\tif (pairwise && !mac_addr)\n\t\treturn -EINVAL;\n\n\tswitch (params->cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t \n\t\tif ((pairwise && key_idx) ||\n\t\t    params->mode != NL80211_KEY_RX_TX)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t \n\t\tif ((params->mode == NL80211_KEY_NO_TX && !pairwise) ||\n\t\t    params->mode == NL80211_KEY_SET_TX)\n\t\t\treturn -EINVAL;\n\t\tif (wiphy_ext_feature_isset(&rdev->wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_EXT_KEY_ID)) {\n\t\t\tif (pairwise && (key_idx < 0 || key_idx > 1))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (pairwise && key_idx) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\t \n\t\tif (pairwise)\n\t\t\treturn -EINVAL;\n\t\tif (key_idx < 4)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tif (key_idx > 3)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (params->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tif (params->key_len != WLAN_KEY_LEN_WEP40)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (params->key_len != WLAN_KEY_LEN_TKIP)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tif (params->key_len != WLAN_KEY_LEN_CCMP)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tif (params->key_len != WLAN_KEY_LEN_CCMP_256)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tif (params->key_len != WLAN_KEY_LEN_GCMP)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tif (params->key_len != WLAN_KEY_LEN_GCMP_256)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tif (params->key_len != WLAN_KEY_LEN_WEP104)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tif (params->key_len != WLAN_KEY_LEN_AES_CMAC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tif (params->key_len != WLAN_KEY_LEN_BIP_CMAC_256)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\tif (params->key_len != WLAN_KEY_LEN_BIP_GMAC_128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tif (params->key_len != WLAN_KEY_LEN_BIP_GMAC_256)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (params->seq) {\n\t\tswitch (params->cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\t\tif (params->seq_len != 6)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!cfg80211_supported_cipher_suite(&rdev->wiphy, params->cipher))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nunsigned int __attribute_const__ ieee80211_hdrlen(__le16 fc)\n{\n\tunsigned int hdrlen = 24;\n\n\tif (ieee80211_is_ext(fc)) {\n\t\thdrlen = 4;\n\t\tgoto out;\n\t}\n\n\tif (ieee80211_is_data(fc)) {\n\t\tif (ieee80211_has_a4(fc))\n\t\t\thdrlen = 30;\n\t\tif (ieee80211_is_data_qos(fc)) {\n\t\t\thdrlen += IEEE80211_QOS_CTL_LEN;\n\t\t\tif (ieee80211_has_order(fc))\n\t\t\t\thdrlen += IEEE80211_HT_CTL_LEN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif (ieee80211_is_mgmt(fc)) {\n\t\tif (ieee80211_has_order(fc))\n\t\t\thdrlen += IEEE80211_HT_CTL_LEN;\n\t\tgoto out;\n\t}\n\n\tif (ieee80211_is_ctl(fc)) {\n\t\t \n\t\tif ((fc & cpu_to_le16(0x00E0)) == cpu_to_le16(0x00C0))\n\t\t\thdrlen = 10;\n\t\telse\n\t\t\thdrlen = 16;\n\t}\nout:\n\treturn hdrlen;\n}\nEXPORT_SYMBOL(ieee80211_hdrlen);\n\nunsigned int ieee80211_get_hdrlen_from_skb(const struct sk_buff *skb)\n{\n\tconst struct ieee80211_hdr *hdr =\n\t\t\t(const struct ieee80211_hdr *)skb->data;\n\tunsigned int hdrlen;\n\n\tif (unlikely(skb->len < 10))\n\t\treturn 0;\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tif (unlikely(hdrlen > skb->len))\n\t\treturn 0;\n\treturn hdrlen;\n}\nEXPORT_SYMBOL(ieee80211_get_hdrlen_from_skb);\n\nstatic unsigned int __ieee80211_get_mesh_hdrlen(u8 flags)\n{\n\tint ae = flags & MESH_FLAGS_AE;\n\t \n\tswitch (ae) {\n\tdefault:\n\tcase 0:\n\t\treturn 6;\n\tcase MESH_FLAGS_AE_A4:\n\t\treturn 12;\n\tcase MESH_FLAGS_AE_A5_A6:\n\t\treturn 18;\n\t}\n}\n\nunsigned int ieee80211_get_mesh_hdrlen(struct ieee80211s_hdr *meshhdr)\n{\n\treturn __ieee80211_get_mesh_hdrlen(meshhdr->flags);\n}\nEXPORT_SYMBOL(ieee80211_get_mesh_hdrlen);\n\nbool ieee80211_get_8023_tunnel_proto(const void *hdr, __be16 *proto)\n{\n\tconst __be16 *hdr_proto = hdr + ETH_ALEN;\n\n\tif (!(ether_addr_equal(hdr, rfc1042_header) &&\n\t      *hdr_proto != htons(ETH_P_AARP) &&\n\t      *hdr_proto != htons(ETH_P_IPX)) &&\n\t    !ether_addr_equal(hdr, bridge_tunnel_header))\n\t\treturn false;\n\n\t*proto = *hdr_proto;\n\n\treturn true;\n}\nEXPORT_SYMBOL(ieee80211_get_8023_tunnel_proto);\n\nint ieee80211_strip_8023_mesh_hdr(struct sk_buff *skb)\n{\n\tconst void *mesh_addr;\n\tstruct {\n\t\tstruct ethhdr eth;\n\t\tu8 flags;\n\t} payload;\n\tint hdrlen;\n\tint ret;\n\n\tret = skb_copy_bits(skb, 0, &payload, sizeof(payload));\n\tif (ret)\n\t\treturn ret;\n\n\thdrlen = sizeof(payload.eth) + __ieee80211_get_mesh_hdrlen(payload.flags);\n\n\tif (likely(pskb_may_pull(skb, hdrlen + 8) &&\n\t\t   ieee80211_get_8023_tunnel_proto(skb->data + hdrlen,\n\t\t\t\t\t\t   &payload.eth.h_proto)))\n\t\thdrlen += ETH_ALEN + 2;\n\telse if (!pskb_may_pull(skb, hdrlen))\n\t\treturn -EINVAL;\n\telse\n\t\tpayload.eth.h_proto = htons(skb->len - hdrlen);\n\n\tmesh_addr = skb->data + sizeof(payload.eth) + ETH_ALEN;\n\tswitch (payload.flags & MESH_FLAGS_AE) {\n\tcase MESH_FLAGS_AE_A4:\n\t\tmemcpy(&payload.eth.h_source, mesh_addr, ETH_ALEN);\n\t\tbreak;\n\tcase MESH_FLAGS_AE_A5_A6:\n\t\tmemcpy(&payload.eth, mesh_addr, 2 * ETH_ALEN);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpskb_pull(skb, hdrlen - sizeof(payload.eth));\n\tmemcpy(skb->data, &payload.eth, sizeof(payload.eth));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_strip_8023_mesh_hdr);\n\nint ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,\n\t\t\t\t  const u8 *addr, enum nl80211_iftype iftype,\n\t\t\t\t  u8 data_offset, bool is_amsdu)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;\n\tstruct {\n\t\tu8 hdr[ETH_ALEN] __aligned(2);\n\t\t__be16 proto;\n\t} payload;\n\tstruct ethhdr tmp;\n\tu16 hdrlen;\n\n\tif (unlikely(!ieee80211_is_data_present(hdr->frame_control)))\n\t\treturn -1;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control) + data_offset;\n\tif (skb->len < hdrlen)\n\t\treturn -1;\n\n\t \n\tmemcpy(tmp.h_dest, ieee80211_get_DA(hdr), ETH_ALEN);\n\tmemcpy(tmp.h_source, ieee80211_get_SA(hdr), ETH_ALEN);\n\n\tswitch (hdr->frame_control &\n\t\tcpu_to_le16(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) {\n\tcase cpu_to_le16(IEEE80211_FCTL_TODS):\n\t\tif (unlikely(iftype != NL80211_IFTYPE_AP &&\n\t\t\t     iftype != NL80211_IFTYPE_AP_VLAN &&\n\t\t\t     iftype != NL80211_IFTYPE_P2P_GO))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase cpu_to_le16(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS):\n\t\tif (unlikely(iftype != NL80211_IFTYPE_MESH_POINT &&\n\t\t\t     iftype != NL80211_IFTYPE_AP_VLAN &&\n\t\t\t     iftype != NL80211_IFTYPE_STATION))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase cpu_to_le16(IEEE80211_FCTL_FROMDS):\n\t\tif ((iftype != NL80211_IFTYPE_STATION &&\n\t\t     iftype != NL80211_IFTYPE_P2P_CLIENT &&\n\t\t     iftype != NL80211_IFTYPE_MESH_POINT) ||\n\t\t    (is_multicast_ether_addr(tmp.h_dest) &&\n\t\t     ether_addr_equal(tmp.h_source, addr)))\n\t\t\treturn -1;\n\t\tbreak;\n\tcase cpu_to_le16(0):\n\t\tif (iftype != NL80211_IFTYPE_ADHOC &&\n\t\t    iftype != NL80211_IFTYPE_STATION &&\n\t\t    iftype != NL80211_IFTYPE_OCB)\n\t\t\t\treturn -1;\n\t\tbreak;\n\t}\n\n\tif (likely(!is_amsdu && iftype != NL80211_IFTYPE_MESH_POINT &&\n\t\t   skb_copy_bits(skb, hdrlen, &payload, sizeof(payload)) == 0 &&\n\t\t   ieee80211_get_8023_tunnel_proto(&payload, &tmp.h_proto))) {\n\t\t \n\t\thdrlen += ETH_ALEN + 2;\n\t\tskb_postpull_rcsum(skb, &payload, ETH_ALEN + 2);\n\t} else {\n\t\ttmp.h_proto = htons(skb->len - hdrlen);\n\t}\n\n\tpskb_pull(skb, hdrlen);\n\n\tif (!ehdr)\n\t\tehdr = skb_push(skb, sizeof(struct ethhdr));\n\tmemcpy(ehdr, &tmp, sizeof(tmp));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ieee80211_data_to_8023_exthdr);\n\nstatic void\n__frame_add_frag(struct sk_buff *skb, struct page *page,\n\t\t void *ptr, int len, int size)\n{\n\tstruct skb_shared_info *sh = skb_shinfo(skb);\n\tint page_offset;\n\n\tget_page(page);\n\tpage_offset = ptr - page_address(page);\n\tskb_add_rx_frag(skb, sh->nr_frags, page, page_offset, len, size);\n}\n\nstatic void\n__ieee80211_amsdu_copy_frag(struct sk_buff *skb, struct sk_buff *frame,\n\t\t\t    int offset, int len)\n{\n\tstruct skb_shared_info *sh = skb_shinfo(skb);\n\tconst skb_frag_t *frag = &sh->frags[0];\n\tstruct page *frag_page;\n\tvoid *frag_ptr;\n\tint frag_len, frag_size;\n\tint head_size = skb->len - skb->data_len;\n\tint cur_len;\n\n\tfrag_page = virt_to_head_page(skb->head);\n\tfrag_ptr = skb->data;\n\tfrag_size = head_size;\n\n\twhile (offset >= frag_size) {\n\t\toffset -= frag_size;\n\t\tfrag_page = skb_frag_page(frag);\n\t\tfrag_ptr = skb_frag_address(frag);\n\t\tfrag_size = skb_frag_size(frag);\n\t\tfrag++;\n\t}\n\n\tfrag_ptr += offset;\n\tfrag_len = frag_size - offset;\n\n\tcur_len = min(len, frag_len);\n\n\t__frame_add_frag(frame, frag_page, frag_ptr, cur_len, frag_size);\n\tlen -= cur_len;\n\n\twhile (len > 0) {\n\t\tfrag_len = skb_frag_size(frag);\n\t\tcur_len = min(len, frag_len);\n\t\t__frame_add_frag(frame, skb_frag_page(frag),\n\t\t\t\t skb_frag_address(frag), cur_len, frag_len);\n\t\tlen -= cur_len;\n\t\tfrag++;\n\t}\n}\n\nstatic struct sk_buff *\n__ieee80211_amsdu_copy(struct sk_buff *skb, unsigned int hlen,\n\t\t       int offset, int len, bool reuse_frag,\n\t\t       int min_len)\n{\n\tstruct sk_buff *frame;\n\tint cur_len = len;\n\n\tif (skb->len - offset < len)\n\t\treturn NULL;\n\n\t \n\tif (reuse_frag)\n\t\tcur_len = min_t(int, len, min_len);\n\n\t \n\tframe = dev_alloc_skb(hlen + sizeof(struct ethhdr) + 2 + cur_len);\n\tif (!frame)\n\t\treturn NULL;\n\n\tframe->priority = skb->priority;\n\tskb_reserve(frame, hlen + sizeof(struct ethhdr) + 2);\n\tskb_copy_bits(skb, offset, skb_put(frame, cur_len), cur_len);\n\n\tlen -= cur_len;\n\tif (!len)\n\t\treturn frame;\n\n\toffset += cur_len;\n\t__ieee80211_amsdu_copy_frag(skb, frame, offset, len);\n\n\treturn frame;\n}\n\nstatic u16\nieee80211_amsdu_subframe_length(void *field, u8 mesh_flags, u8 hdr_type)\n{\n\t__le16 *field_le = field;\n\t__be16 *field_be = field;\n\tu16 len;\n\n\tif (hdr_type >= 2)\n\t\tlen = le16_to_cpu(*field_le);\n\telse\n\t\tlen = be16_to_cpu(*field_be);\n\tif (hdr_type)\n\t\tlen += __ieee80211_get_mesh_hdrlen(mesh_flags);\n\n\treturn len;\n}\n\nbool ieee80211_is_valid_amsdu(struct sk_buff *skb, u8 mesh_hdr)\n{\n\tint offset = 0, remaining, subframe_len, padding;\n\n\tfor (offset = 0; offset < skb->len; offset += subframe_len + padding) {\n\t\tstruct {\n\t\t    __be16 len;\n\t\t    u8 mesh_flags;\n\t\t} hdr;\n\t\tu16 len;\n\n\t\tif (skb_copy_bits(skb, offset + 2 * ETH_ALEN, &hdr, sizeof(hdr)) < 0)\n\t\t\treturn false;\n\n\t\tlen = ieee80211_amsdu_subframe_length(&hdr.len, hdr.mesh_flags,\n\t\t\t\t\t\t      mesh_hdr);\n\t\tsubframe_len = sizeof(struct ethhdr) + len;\n\t\tpadding = (4 - subframe_len) & 0x3;\n\t\tremaining = skb->len - offset;\n\n\t\tif (subframe_len > remaining)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(ieee80211_is_valid_amsdu);\n\nvoid ieee80211_amsdu_to_8023s(struct sk_buff *skb, struct sk_buff_head *list,\n\t\t\t      const u8 *addr, enum nl80211_iftype iftype,\n\t\t\t      const unsigned int extra_headroom,\n\t\t\t      const u8 *check_da, const u8 *check_sa,\n\t\t\t      u8 mesh_control)\n{\n\tunsigned int hlen = ALIGN(extra_headroom, 4);\n\tstruct sk_buff *frame = NULL;\n\tint offset = 0, remaining;\n\tstruct {\n\t\tstruct ethhdr eth;\n\t\tuint8_t flags;\n\t} hdr;\n\tbool reuse_frag = skb->head_frag && !skb_has_frag_list(skb);\n\tbool reuse_skb = false;\n\tbool last = false;\n\tint copy_len = sizeof(hdr.eth);\n\n\tif (iftype == NL80211_IFTYPE_MESH_POINT)\n\t\tcopy_len = sizeof(hdr);\n\n\twhile (!last) {\n\t\tunsigned int subframe_len;\n\t\tint len, mesh_len = 0;\n\t\tu8 padding;\n\n\t\tskb_copy_bits(skb, offset, &hdr, copy_len);\n\t\tif (iftype == NL80211_IFTYPE_MESH_POINT)\n\t\t\tmesh_len = __ieee80211_get_mesh_hdrlen(hdr.flags);\n\t\tlen = ieee80211_amsdu_subframe_length(&hdr.eth.h_proto, hdr.flags,\n\t\t\t\t\t\t      mesh_control);\n\t\tsubframe_len = sizeof(struct ethhdr) + len;\n\t\tpadding = (4 - subframe_len) & 0x3;\n\n\t\t \n\t\tremaining = skb->len - offset;\n\t\tif (subframe_len > remaining)\n\t\t\tgoto purge;\n\t\t \n\t\tif (ether_addr_equal(hdr.eth.h_dest, rfc1042_header))\n\t\t\tgoto purge;\n\n\t\toffset += sizeof(struct ethhdr);\n\t\tlast = remaining <= subframe_len + padding;\n\n\t\t \n\t\tif ((check_da && !is_multicast_ether_addr(hdr.eth.h_dest) &&\n\t\t     !ether_addr_equal(check_da, hdr.eth.h_dest)) ||\n\t\t    (check_sa && !ether_addr_equal(check_sa, hdr.eth.h_source))) {\n\t\t\toffset += len + padding;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!skb_is_nonlinear(skb) && !reuse_frag && last) {\n\t\t\tskb_pull(skb, offset);\n\t\t\tframe = skb;\n\t\t\treuse_skb = true;\n\t\t} else {\n\t\t\tframe = __ieee80211_amsdu_copy(skb, hlen, offset, len,\n\t\t\t\t\t\t       reuse_frag, 32 + mesh_len);\n\t\t\tif (!frame)\n\t\t\t\tgoto purge;\n\n\t\t\toffset += len + padding;\n\t\t}\n\n\t\tskb_reset_network_header(frame);\n\t\tframe->dev = skb->dev;\n\t\tframe->priority = skb->priority;\n\n\t\tif (likely(iftype != NL80211_IFTYPE_MESH_POINT &&\n\t\t\t   ieee80211_get_8023_tunnel_proto(frame->data, &hdr.eth.h_proto)))\n\t\t\tskb_pull(frame, ETH_ALEN + 2);\n\n\t\tmemcpy(skb_push(frame, sizeof(hdr.eth)), &hdr.eth, sizeof(hdr.eth));\n\t\t__skb_queue_tail(list, frame);\n\t}\n\n\tif (!reuse_skb)\n\t\tdev_kfree_skb(skb);\n\n\treturn;\n\n purge:\n\t__skb_queue_purge(list);\n\tdev_kfree_skb(skb);\n}\nEXPORT_SYMBOL(ieee80211_amsdu_to_8023s);\n\n \nunsigned int cfg80211_classify8021d(struct sk_buff *skb,\n\t\t\t\t    struct cfg80211_qos_map *qos_map)\n{\n\tunsigned int dscp;\n\tunsigned char vlan_priority;\n\tunsigned int ret;\n\n\t \n\tif (skb->priority >= 256 && skb->priority <= 263) {\n\t\tret = skb->priority - 256;\n\t\tgoto out;\n\t}\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tvlan_priority = (skb_vlan_tag_get(skb) & VLAN_PRIO_MASK)\n\t\t\t>> VLAN_PRIO_SHIFT;\n\t\tif (vlan_priority > 0) {\n\t\t\tret = vlan_priority;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tdscp = ipv4_get_dsfield(ip_hdr(skb)) & 0xfc;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tdscp = ipv6_get_dsfield(ipv6_hdr(skb)) & 0xfc;\n\t\tbreak;\n\tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label mpls_tmp, *mpls;\n\n\t\tmpls = skb_header_pointer(skb, sizeof(struct ethhdr),\n\t\t\t\t\t  sizeof(*mpls), &mpls_tmp);\n\t\tif (!mpls)\n\t\t\treturn 0;\n\n\t\tret = (ntohl(mpls->entry) & MPLS_LS_TC_MASK)\n\t\t\t>> MPLS_LS_TC_SHIFT;\n\t\tgoto out;\n\t}\n\tcase htons(ETH_P_80221):\n\t\t \n\t\treturn 7;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (qos_map) {\n\t\tunsigned int i, tmp_dscp = dscp >> 2;\n\n\t\tfor (i = 0; i < qos_map->num_des; i++) {\n\t\t\tif (tmp_dscp == qos_map->dscp_exception[i].dscp) {\n\t\t\t\tret = qos_map->dscp_exception[i].up;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (tmp_dscp >= qos_map->up[i].low &&\n\t\t\t    tmp_dscp <= qos_map->up[i].high) {\n\t\t\t\tret = i;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = dscp >> 5;\nout:\n\treturn array_index_nospec(ret, IEEE80211_NUM_TIDS);\n}\nEXPORT_SYMBOL(cfg80211_classify8021d);\n\nconst struct element *ieee80211_bss_get_elem(struct cfg80211_bss *bss, u8 id)\n{\n\tconst struct cfg80211_bss_ies *ies;\n\n\ties = rcu_dereference(bss->ies);\n\tif (!ies)\n\t\treturn NULL;\n\n\treturn cfg80211_find_elem(id, ies->data, ies->len);\n}\nEXPORT_SYMBOL(ieee80211_bss_get_elem);\n\nvoid cfg80211_upload_connect_keys(struct wireless_dev *wdev)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct net_device *dev = wdev->netdev;\n\tint i;\n\n\tif (!wdev->connect_keys)\n\t\treturn;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (!wdev->connect_keys->params[i].cipher)\n\t\t\tcontinue;\n\t\tif (rdev_add_key(rdev, dev, -1, i, false, NULL,\n\t\t\t\t &wdev->connect_keys->params[i])) {\n\t\t\tnetdev_err(dev, \"failed to set key %d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tif (wdev->connect_keys->def == i &&\n\t\t    rdev_set_default_key(rdev, dev, -1, i, true, true)) {\n\t\t\tnetdev_err(dev, \"failed to set defkey %d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tkfree_sensitive(wdev->connect_keys);\n\twdev->connect_keys = NULL;\n}\n\nvoid cfg80211_process_wdev_events(struct wireless_dev *wdev)\n{\n\tstruct cfg80211_event *ev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wdev->event_lock, flags);\n\twhile (!list_empty(&wdev->event_list)) {\n\t\tev = list_first_entry(&wdev->event_list,\n\t\t\t\t      struct cfg80211_event, list);\n\t\tlist_del(&ev->list);\n\t\tspin_unlock_irqrestore(&wdev->event_lock, flags);\n\n\t\twdev_lock(wdev);\n\t\tswitch (ev->type) {\n\t\tcase EVENT_CONNECT_RESULT:\n\t\t\t__cfg80211_connect_result(\n\t\t\t\twdev->netdev,\n\t\t\t\t&ev->cr,\n\t\t\t\tev->cr.status == WLAN_STATUS_SUCCESS);\n\t\t\tbreak;\n\t\tcase EVENT_ROAMED:\n\t\t\t__cfg80211_roamed(wdev, &ev->rm);\n\t\t\tbreak;\n\t\tcase EVENT_DISCONNECTED:\n\t\t\t__cfg80211_disconnected(wdev->netdev,\n\t\t\t\t\t\tev->dc.ie, ev->dc.ie_len,\n\t\t\t\t\t\tev->dc.reason,\n\t\t\t\t\t\t!ev->dc.locally_generated);\n\t\t\tbreak;\n\t\tcase EVENT_IBSS_JOINED:\n\t\t\t__cfg80211_ibss_joined(wdev->netdev, ev->ij.bssid,\n\t\t\t\t\t       ev->ij.channel);\n\t\t\tbreak;\n\t\tcase EVENT_STOPPED:\n\t\t\t__cfg80211_leave(wiphy_to_rdev(wdev->wiphy), wdev);\n\t\t\tbreak;\n\t\tcase EVENT_PORT_AUTHORIZED:\n\t\t\t__cfg80211_port_authorized(wdev, ev->pa.bssid,\n\t\t\t\t\t\t   ev->pa.td_bitmap,\n\t\t\t\t\t\t   ev->pa.td_bitmap_len);\n\t\t\tbreak;\n\t\t}\n\t\twdev_unlock(wdev);\n\n\t\tkfree(ev);\n\n\t\tspin_lock_irqsave(&wdev->event_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&wdev->event_lock, flags);\n}\n\nvoid cfg80211_process_rdev_events(struct cfg80211_registered_device *rdev)\n{\n\tstruct wireless_dev *wdev;\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\tlist_for_each_entry(wdev, &rdev->wiphy.wdev_list, list)\n\t\tcfg80211_process_wdev_events(wdev);\n}\n\nint cfg80211_change_iface(struct cfg80211_registered_device *rdev,\n\t\t\t  struct net_device *dev, enum nl80211_iftype ntype,\n\t\t\t  struct vif_params *params)\n{\n\tint err;\n\tenum nl80211_iftype otype = dev->ieee80211_ptr->iftype;\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\t \n\tif (otype == NL80211_IFTYPE_AP_VLAN)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (ntype == NL80211_IFTYPE_P2P_DEVICE ||\n\t    ntype == NL80211_IFTYPE_NAN)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->change_virtual_intf ||\n\t    !(rdev->wiphy.interface_modes & (1 << ntype)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (ntype != otype) {\n\t\t \n\t\tif (netif_is_bridge_port(dev) &&\n\t\t    (ntype == NL80211_IFTYPE_ADHOC ||\n\t\t     ntype == NL80211_IFTYPE_STATION ||\n\t\t     ntype == NL80211_IFTYPE_P2P_CLIENT))\n\t\t\treturn -EBUSY;\n\n\t\tdev->ieee80211_ptr->use_4addr = false;\n\t\twdev_lock(dev->ieee80211_ptr);\n\t\trdev_set_qos_map(rdev, dev, NULL);\n\t\twdev_unlock(dev->ieee80211_ptr);\n\n\t\tswitch (otype) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\tcfg80211_stop_ap(rdev, dev, -1, true);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tcfg80211_leave_ibss(rdev, dev, false);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t\twdev_lock(dev->ieee80211_ptr);\n\t\t\tcfg80211_disconnect(rdev, dev,\n\t\t\t\t\t    WLAN_REASON_DEAUTH_LEAVING, true);\n\t\t\twdev_unlock(dev->ieee80211_ptr);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\t \n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_OCB:\n\t\t\tcfg80211_leave_ocb(rdev, dev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tcfg80211_process_rdev_events(rdev);\n\t\tcfg80211_mlme_purge_registrations(dev->ieee80211_ptr);\n\n\t\tmemset(&dev->ieee80211_ptr->u, 0,\n\t\t       sizeof(dev->ieee80211_ptr->u));\n\t\tmemset(&dev->ieee80211_ptr->links, 0,\n\t\t       sizeof(dev->ieee80211_ptr->links));\n\t}\n\n\terr = rdev_change_virtual_intf(rdev, dev, ntype, params);\n\n\tWARN_ON(!err && dev->ieee80211_ptr->iftype != ntype);\n\n\tif (!err && params && params->use_4addr != -1)\n\t\tdev->ieee80211_ptr->use_4addr = params->use_4addr;\n\n\tif (!err) {\n\t\tdev->priv_flags &= ~IFF_DONT_BRIDGE;\n\t\tswitch (ntype) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tif (dev->ieee80211_ptr->use_4addr)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase NL80211_IFTYPE_OCB:\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tdev->priv_flags |= IFF_DONT_BRIDGE;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\t \n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MONITOR:\n\t\t\t \n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_UNSPECIFIED:\n\t\tcase NUM_NL80211_IFTYPES:\n\t\t\t \n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tcase NL80211_IFTYPE_WDS:\n\t\tcase NL80211_IFTYPE_NAN:\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!err && ntype != otype && netif_running(dev)) {\n\t\tcfg80211_update_iface_num(rdev, ntype, 1);\n\t\tcfg80211_update_iface_num(rdev, otype, -1);\n\t}\n\n\treturn err;\n}\n\nstatic u32 cfg80211_calculate_bitrate_ht(struct rate_info *rate)\n{\n\tint modulation, streams, bitrate;\n\n\t \n\tif (WARN_ON_ONCE(rate->mcs >= 32))\n\t\treturn 0;\n\n\tmodulation = rate->mcs & 7;\n\tstreams = (rate->mcs >> 3) + 1;\n\n\tbitrate = (rate->bw == RATE_INFO_BW_40) ? 13500000 : 6500000;\n\n\tif (modulation < 4)\n\t\tbitrate *= (modulation + 1);\n\telse if (modulation == 4)\n\t\tbitrate *= (modulation + 2);\n\telse\n\t\tbitrate *= (modulation + 3);\n\n\tbitrate *= streams;\n\n\tif (rate->flags & RATE_INFO_FLAGS_SHORT_GI)\n\t\tbitrate = (bitrate / 9) * 10;\n\n\t \n\treturn (bitrate + 50000) / 100000;\n}\n\nstatic u32 cfg80211_calculate_bitrate_dmg(struct rate_info *rate)\n{\n\tstatic const u32 __mcs2bitrate[] = {\n\t\t \n\t\t[0] =   275,\n\t\t \n\t\t[1] =  3850,\n\t\t[2] =  7700,\n\t\t[3] =  9625,\n\t\t[4] = 11550,\n\t\t[5] = 12512,  \n\t\t[6] = 15400,\n\t\t[7] = 19250,\n\t\t[8] = 23100,\n\t\t[9] = 25025,\n\t\t[10] = 30800,\n\t\t[11] = 38500,\n\t\t[12] = 46200,\n\t\t \n\t\t[13] =  6930,\n\t\t[14] =  8662,  \n\t\t[15] = 13860,\n\t\t[16] = 17325,\n\t\t[17] = 20790,\n\t\t[18] = 27720,\n\t\t[19] = 34650,\n\t\t[20] = 41580,\n\t\t[21] = 45045,\n\t\t[22] = 51975,\n\t\t[23] = 62370,\n\t\t[24] = 67568,  \n\t\t \n\t\t[25] =  6260,\n\t\t[26] =  8340,\n\t\t[27] = 11120,\n\t\t[28] = 12510,\n\t\t[29] = 16680,\n\t\t[30] = 22240,\n\t\t[31] = 25030,\n\t};\n\n\tif (WARN_ON_ONCE(rate->mcs >= ARRAY_SIZE(__mcs2bitrate)))\n\t\treturn 0;\n\n\treturn __mcs2bitrate[rate->mcs];\n}\n\nstatic u32 cfg80211_calculate_bitrate_extended_sc_dmg(struct rate_info *rate)\n{\n\tstatic const u32 __mcs2bitrate[] = {\n\t\t[6 - 6] = 26950,  \n\t\t[7 - 6] = 50050,  \n\t\t[8 - 6] = 53900,\n\t\t[9 - 6] = 57750,\n\t\t[10 - 6] = 63900,\n\t\t[11 - 6] = 75075,\n\t\t[12 - 6] = 80850,\n\t};\n\n\t \n\tif (WARN_ON_ONCE(rate->mcs < 6 || rate->mcs > 12))\n\t\treturn 0;\n\n\treturn __mcs2bitrate[rate->mcs - 6];\n}\n\nstatic u32 cfg80211_calculate_bitrate_edmg(struct rate_info *rate)\n{\n\tstatic const u32 __mcs2bitrate[] = {\n\t\t \n\t\t[0] =   275,\n\t\t \n\t\t[1] =  3850,\n\t\t[2] =  7700,\n\t\t[3] =  9625,\n\t\t[4] = 11550,\n\t\t[5] = 12512,  \n\t\t[6] = 13475,\n\t\t[7] = 15400,\n\t\t[8] = 19250,\n\t\t[9] = 23100,\n\t\t[10] = 25025,\n\t\t[11] = 26950,\n\t\t[12] = 30800,\n\t\t[13] = 38500,\n\t\t[14] = 46200,\n\t\t[15] = 50050,\n\t\t[16] = 53900,\n\t\t[17] = 57750,\n\t\t[18] = 69300,\n\t\t[19] = 75075,\n\t\t[20] = 80850,\n\t};\n\n\tif (WARN_ON_ONCE(rate->mcs >= ARRAY_SIZE(__mcs2bitrate)))\n\t\treturn 0;\n\n\treturn __mcs2bitrate[rate->mcs] * rate->n_bonded_ch;\n}\n\nstatic u32 cfg80211_calculate_bitrate_vht(struct rate_info *rate)\n{\n\tstatic const u32 base[4][12] = {\n\t\t{   6500000,\n\t\t   13000000,\n\t\t   19500000,\n\t\t   26000000,\n\t\t   39000000,\n\t\t   52000000,\n\t\t   58500000,\n\t\t   65000000,\n\t\t   78000000,\n\t\t \n\t\t   86700000,\n\t\t   97500000,\n\t\t  108300000,\n\t\t},\n\t\t{  13500000,\n\t\t   27000000,\n\t\t   40500000,\n\t\t   54000000,\n\t\t   81000000,\n\t\t  108000000,\n\t\t  121500000,\n\t\t  135000000,\n\t\t  162000000,\n\t\t  180000000,\n\t\t  202500000,\n\t\t  225000000,\n\t\t},\n\t\t{  29300000,\n\t\t   58500000,\n\t\t   87800000,\n\t\t  117000000,\n\t\t  175500000,\n\t\t  234000000,\n\t\t  263300000,\n\t\t  292500000,\n\t\t  351000000,\n\t\t  390000000,\n\t\t  438800000,\n\t\t  487500000,\n\t\t},\n\t\t{  58500000,\n\t\t  117000000,\n\t\t  175500000,\n\t\t  234000000,\n\t\t  351000000,\n\t\t  468000000,\n\t\t  526500000,\n\t\t  585000000,\n\t\t  702000000,\n\t\t  780000000,\n\t\t  877500000,\n\t\t  975000000,\n\t\t},\n\t};\n\tu32 bitrate;\n\tint idx;\n\n\tif (rate->mcs > 11)\n\t\tgoto warn;\n\n\tswitch (rate->bw) {\n\tcase RATE_INFO_BW_160:\n\t\tidx = 3;\n\t\tbreak;\n\tcase RATE_INFO_BW_80:\n\t\tidx = 2;\n\t\tbreak;\n\tcase RATE_INFO_BW_40:\n\t\tidx = 1;\n\t\tbreak;\n\tcase RATE_INFO_BW_5:\n\tcase RATE_INFO_BW_10:\n\tdefault:\n\t\tgoto warn;\n\tcase RATE_INFO_BW_20:\n\t\tidx = 0;\n\t}\n\n\tbitrate = base[idx][rate->mcs];\n\tbitrate *= rate->nss;\n\n\tif (rate->flags & RATE_INFO_FLAGS_SHORT_GI)\n\t\tbitrate = (bitrate / 9) * 10;\n\n\t \n\treturn (bitrate + 50000) / 100000;\n warn:\n\tWARN_ONCE(1, \"invalid rate bw=%d, mcs=%d, nss=%d\\n\",\n\t\t  rate->bw, rate->mcs, rate->nss);\n\treturn 0;\n}\n\nstatic u32 cfg80211_calculate_bitrate_he(struct rate_info *rate)\n{\n#define SCALE 6144\n\tu32 mcs_divisors[14] = {\n\t\t102399,  \n\t\t 51201,  \n\t\t 34134,  \n\t\t 25599,  \n\t\t 17067,  \n\t\t 12801,  \n\t\t 11377,  \n\t\t 10239,  \n\t\t  8532,  \n\t\t  7680,  \n\t\t  6828,  \n\t\t  6144,  \n\t\t  5690,  \n\t\t  5120,  \n\t};\n\tu32 rates_160M[3] = { 960777777, 907400000, 816666666 };\n\tu32 rates_969[3] =  { 480388888, 453700000, 408333333 };\n\tu32 rates_484[3] =  { 229411111, 216666666, 195000000 };\n\tu32 rates_242[3] =  { 114711111, 108333333,  97500000 };\n\tu32 rates_106[3] =  {  40000000,  37777777,  34000000 };\n\tu32 rates_52[3]  =  {  18820000,  17777777,  16000000 };\n\tu32 rates_26[3]  =  {   9411111,   8888888,   8000000 };\n\tu64 tmp;\n\tu32 result;\n\n\tif (WARN_ON_ONCE(rate->mcs > 13))\n\t\treturn 0;\n\n\tif (WARN_ON_ONCE(rate->he_gi > NL80211_RATE_INFO_HE_GI_3_2))\n\t\treturn 0;\n\tif (WARN_ON_ONCE(rate->he_ru_alloc >\n\t\t\t NL80211_RATE_INFO_HE_RU_ALLOC_2x996))\n\t\treturn 0;\n\tif (WARN_ON_ONCE(rate->nss < 1 || rate->nss > 8))\n\t\treturn 0;\n\n\tif (rate->bw == RATE_INFO_BW_160)\n\t\tresult = rates_160M[rate->he_gi];\n\telse if (rate->bw == RATE_INFO_BW_80 ||\n\t\t (rate->bw == RATE_INFO_BW_HE_RU &&\n\t\t  rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_996))\n\t\tresult = rates_969[rate->he_gi];\n\telse if (rate->bw == RATE_INFO_BW_40 ||\n\t\t (rate->bw == RATE_INFO_BW_HE_RU &&\n\t\t  rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_484))\n\t\tresult = rates_484[rate->he_gi];\n\telse if (rate->bw == RATE_INFO_BW_20 ||\n\t\t (rate->bw == RATE_INFO_BW_HE_RU &&\n\t\t  rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_242))\n\t\tresult = rates_242[rate->he_gi];\n\telse if (rate->bw == RATE_INFO_BW_HE_RU &&\n\t\t rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_106)\n\t\tresult = rates_106[rate->he_gi];\n\telse if (rate->bw == RATE_INFO_BW_HE_RU &&\n\t\t rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_52)\n\t\tresult = rates_52[rate->he_gi];\n\telse if (rate->bw == RATE_INFO_BW_HE_RU &&\n\t\t rate->he_ru_alloc == NL80211_RATE_INFO_HE_RU_ALLOC_26)\n\t\tresult = rates_26[rate->he_gi];\n\telse {\n\t\tWARN(1, \"invalid HE MCS: bw:%d, ru:%d\\n\",\n\t\t     rate->bw, rate->he_ru_alloc);\n\t\treturn 0;\n\t}\n\n\t \n\ttmp = result;\n\ttmp *= SCALE;\n\tdo_div(tmp, mcs_divisors[rate->mcs]);\n\tresult = tmp;\n\n\t \n\tresult = (result * rate->nss) / 8;\n\tif (rate->he_dcm)\n\t\tresult /= 2;\n\n\treturn result / 10000;\n}\n\nstatic u32 cfg80211_calculate_bitrate_eht(struct rate_info *rate)\n{\n#define SCALE 6144\n\tstatic const u32 mcs_divisors[16] = {\n\t\t102399,  \n\t\t 51201,  \n\t\t 34134,  \n\t\t 25599,  \n\t\t 17067,  \n\t\t 12801,  \n\t\t 11377,  \n\t\t 10239,  \n\t\t  8532,  \n\t\t  7680,  \n\t\t  6828,  \n\t\t  6144,  \n\t\t  5690,  \n\t\t  5120,  \n\t\t409600,  \n\t\t204800,  \n\t};\n\tstatic const u32 rates_996[3] =  { 480388888, 453700000, 408333333 };\n\tstatic const u32 rates_484[3] =  { 229411111, 216666666, 195000000 };\n\tstatic const u32 rates_242[3] =  { 114711111, 108333333,  97500000 };\n\tstatic const u32 rates_106[3] =  {  40000000,  37777777,  34000000 };\n\tstatic const u32 rates_52[3]  =  {  18820000,  17777777,  16000000 };\n\tstatic const u32 rates_26[3]  =  {   9411111,   8888888,   8000000 };\n\tu64 tmp;\n\tu32 result;\n\n\tif (WARN_ON_ONCE(rate->mcs > 15))\n\t\treturn 0;\n\tif (WARN_ON_ONCE(rate->eht_gi > NL80211_RATE_INFO_EHT_GI_3_2))\n\t\treturn 0;\n\tif (WARN_ON_ONCE(rate->eht_ru_alloc >\n\t\t\t NL80211_RATE_INFO_EHT_RU_ALLOC_4x996))\n\t\treturn 0;\n\tif (WARN_ON_ONCE(rate->nss < 1 || rate->nss > 8))\n\t\treturn 0;\n\n\t \n\tif (rate->mcs == 14) {\n\t\tif ((rate->bw != RATE_INFO_BW_EHT_RU &&\n\t\t     rate->bw != RATE_INFO_BW_80 &&\n\t\t     rate->bw != RATE_INFO_BW_160 &&\n\t\t     rate->bw != RATE_INFO_BW_320) ||\n\t\t    (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t     rate->eht_ru_alloc != NL80211_RATE_INFO_EHT_RU_ALLOC_996 &&\n\t\t     rate->eht_ru_alloc != NL80211_RATE_INFO_EHT_RU_ALLOC_2x996 &&\n\t\t     rate->eht_ru_alloc != NL80211_RATE_INFO_EHT_RU_ALLOC_4x996)) {\n\t\t\tWARN(1, \"invalid EHT BW for MCS 14: bw:%d, ru:%d\\n\",\n\t\t\t     rate->bw, rate->eht_ru_alloc);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (rate->bw == RATE_INFO_BW_320 ||\n\t    (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t     rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_4x996))\n\t\tresult = 4 * rates_996[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_3x996P484)\n\t\tresult = 3 * rates_996[rate->eht_gi] + rates_484[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_3x996)\n\t\tresult = 3 * rates_996[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_2x996P484)\n\t\tresult = 2 * rates_996[rate->eht_gi] + rates_484[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_160 ||\n\t\t (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t  rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_2x996))\n\t\tresult = 2 * rates_996[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t rate->eht_ru_alloc ==\n\t\t NL80211_RATE_INFO_EHT_RU_ALLOC_996P484P242)\n\t\tresult = rates_996[rate->eht_gi] + rates_484[rate->eht_gi]\n\t\t\t + rates_242[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_996P484)\n\t\tresult = rates_996[rate->eht_gi] + rates_484[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_80 ||\n\t\t (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t  rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_996))\n\t\tresult = rates_996[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_484P242)\n\t\tresult = rates_484[rate->eht_gi] + rates_242[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_40 ||\n\t\t (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t  rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_484))\n\t\tresult = rates_484[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_20 ||\n\t\t (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t  rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_242))\n\t\tresult = rates_242[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_106P26)\n\t\tresult = rates_106[rate->eht_gi] + rates_26[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_106)\n\t\tresult = rates_106[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_52P26)\n\t\tresult = rates_52[rate->eht_gi] + rates_26[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_52)\n\t\tresult = rates_52[rate->eht_gi];\n\telse if (rate->bw == RATE_INFO_BW_EHT_RU &&\n\t\t rate->eht_ru_alloc == NL80211_RATE_INFO_EHT_RU_ALLOC_26)\n\t\tresult = rates_26[rate->eht_gi];\n\telse {\n\t\tWARN(1, \"invalid EHT MCS: bw:%d, ru:%d\\n\",\n\t\t     rate->bw, rate->eht_ru_alloc);\n\t\treturn 0;\n\t}\n\n\t \n\ttmp = result;\n\ttmp *= SCALE;\n\tdo_div(tmp, mcs_divisors[rate->mcs]);\n\n\t \n\ttmp *= rate->nss;\n\tdo_div(tmp, 8);\n\n\tresult = tmp;\n\n\treturn result / 10000;\n}\n\nstatic u32 cfg80211_calculate_bitrate_s1g(struct rate_info *rate)\n{\n\t \n\tstatic const u32 base[5][11] = {\n\t\t{  300000,\n\t\t   600000,\n\t\t   900000,\n\t\t  1200000,\n\t\t  1800000,\n\t\t  2400000,\n\t\t  2700000,\n\t\t  3000000,\n\t\t  3600000,\n\t\t  4000000,\n\t\t   \n\t\t  150000,\n\t\t},\n\t\t{  650000,\n\t\t  1300000,\n\t\t  1950000,\n\t\t  2600000,\n\t\t  3900000,\n\t\t  5200000,\n\t\t  5850000,\n\t\t  6500000,\n\t\t  7800000,\n\t\t   \n\t\t},\n\t\t{  1350000,\n\t\t   2700000,\n\t\t   4050000,\n\t\t   5400000,\n\t\t   8100000,\n\t\t  10800000,\n\t\t  12150000,\n\t\t  13500000,\n\t\t  16200000,\n\t\t  18000000,\n\t\t},\n\t\t{  2925000,\n\t\t   5850000,\n\t\t   8775000,\n\t\t  11700000,\n\t\t  17550000,\n\t\t  23400000,\n\t\t  26325000,\n\t\t  29250000,\n\t\t  35100000,\n\t\t  39000000,\n\t\t},\n\t\t{  8580000,\n\t\t  11700000,\n\t\t  17550000,\n\t\t  23400000,\n\t\t  35100000,\n\t\t  46800000,\n\t\t  52650000,\n\t\t  58500000,\n\t\t  70200000,\n\t\t  78000000,\n\t\t},\n\t};\n\tu32 bitrate;\n\t \n\tint idx = 0;\n\n\tif (rate->mcs >= 11)\n\t\tgoto warn;\n\n\tswitch (rate->bw) {\n\tcase RATE_INFO_BW_16:\n\t\tidx = 4;\n\t\tbreak;\n\tcase RATE_INFO_BW_8:\n\t\tidx = 3;\n\t\tbreak;\n\tcase RATE_INFO_BW_4:\n\t\tidx = 2;\n\t\tbreak;\n\tcase RATE_INFO_BW_2:\n\t\tidx = 1;\n\t\tbreak;\n\tcase RATE_INFO_BW_1:\n\t\tidx = 0;\n\t\tbreak;\n\tcase RATE_INFO_BW_5:\n\tcase RATE_INFO_BW_10:\n\tcase RATE_INFO_BW_20:\n\tcase RATE_INFO_BW_40:\n\tcase RATE_INFO_BW_80:\n\tcase RATE_INFO_BW_160:\n\tdefault:\n\t\tgoto warn;\n\t}\n\n\tbitrate = base[idx][rate->mcs];\n\tbitrate *= rate->nss;\n\n\tif (rate->flags & RATE_INFO_FLAGS_SHORT_GI)\n\t\tbitrate = (bitrate / 9) * 10;\n\t \n\treturn (bitrate + 50000) / 100000;\nwarn:\n\tWARN_ONCE(1, \"invalid rate bw=%d, mcs=%d, nss=%d\\n\",\n\t\t  rate->bw, rate->mcs, rate->nss);\n\treturn 0;\n}\n\nu32 cfg80211_calculate_bitrate(struct rate_info *rate)\n{\n\tif (rate->flags & RATE_INFO_FLAGS_MCS)\n\t\treturn cfg80211_calculate_bitrate_ht(rate);\n\tif (rate->flags & RATE_INFO_FLAGS_DMG)\n\t\treturn cfg80211_calculate_bitrate_dmg(rate);\n\tif (rate->flags & RATE_INFO_FLAGS_EXTENDED_SC_DMG)\n\t\treturn cfg80211_calculate_bitrate_extended_sc_dmg(rate);\n\tif (rate->flags & RATE_INFO_FLAGS_EDMG)\n\t\treturn cfg80211_calculate_bitrate_edmg(rate);\n\tif (rate->flags & RATE_INFO_FLAGS_VHT_MCS)\n\t\treturn cfg80211_calculate_bitrate_vht(rate);\n\tif (rate->flags & RATE_INFO_FLAGS_HE_MCS)\n\t\treturn cfg80211_calculate_bitrate_he(rate);\n\tif (rate->flags & RATE_INFO_FLAGS_EHT_MCS)\n\t\treturn cfg80211_calculate_bitrate_eht(rate);\n\tif (rate->flags & RATE_INFO_FLAGS_S1G_MCS)\n\t\treturn cfg80211_calculate_bitrate_s1g(rate);\n\n\treturn rate->legacy;\n}\nEXPORT_SYMBOL(cfg80211_calculate_bitrate);\n\nint cfg80211_get_p2p_attr(const u8 *ies, unsigned int len,\n\t\t\t  enum ieee80211_p2p_attr_id attr,\n\t\t\t  u8 *buf, unsigned int bufsize)\n{\n\tu8 *out = buf;\n\tu16 attr_remaining = 0;\n\tbool desired_attr = false;\n\tu16 desired_len = 0;\n\n\twhile (len > 0) {\n\t\tunsigned int iedatalen;\n\t\tunsigned int copy;\n\t\tconst u8 *iedata;\n\n\t\tif (len < 2)\n\t\t\treturn -EILSEQ;\n\t\tiedatalen = ies[1];\n\t\tif (iedatalen + 2 > len)\n\t\t\treturn -EILSEQ;\n\n\t\tif (ies[0] != WLAN_EID_VENDOR_SPECIFIC)\n\t\t\tgoto cont;\n\n\t\tif (iedatalen < 4)\n\t\t\tgoto cont;\n\n\t\tiedata = ies + 2;\n\n\t\t \n\t\tif (iedata[0] != 0x50 || iedata[1] != 0x6f ||\n\t\t    iedata[2] != 0x9a || iedata[3] != 0x09)\n\t\t\tgoto cont;\n\n\t\tiedatalen -= 4;\n\t\tiedata += 4;\n\n\t\t \n\t\tcopy = min_t(unsigned int, attr_remaining, iedatalen);\n\t\tif (copy && desired_attr) {\n\t\t\tdesired_len += copy;\n\t\t\tif (out) {\n\t\t\t\tmemcpy(out, iedata, min(bufsize, copy));\n\t\t\t\tout += min(bufsize, copy);\n\t\t\t\tbufsize -= min(bufsize, copy);\n\t\t\t}\n\n\n\t\t\tif (copy == attr_remaining)\n\t\t\t\treturn desired_len;\n\t\t}\n\n\t\tattr_remaining -= copy;\n\t\tif (attr_remaining)\n\t\t\tgoto cont;\n\n\t\tiedatalen -= copy;\n\t\tiedata += copy;\n\n\t\twhile (iedatalen > 0) {\n\t\t\tu16 attr_len;\n\n\t\t\t \n\t\t\tif (iedatalen < 3)\n\t\t\t\treturn -EILSEQ;\n\t\t\tdesired_attr = iedata[0] == attr;\n\t\t\tattr_len = get_unaligned_le16(iedata + 1);\n\t\t\tiedatalen -= 3;\n\t\t\tiedata += 3;\n\n\t\t\tcopy = min_t(unsigned int, attr_len, iedatalen);\n\n\t\t\tif (desired_attr) {\n\t\t\t\tdesired_len += copy;\n\t\t\t\tif (out) {\n\t\t\t\t\tmemcpy(out, iedata, min(bufsize, copy));\n\t\t\t\t\tout += min(bufsize, copy);\n\t\t\t\t\tbufsize -= min(bufsize, copy);\n\t\t\t\t}\n\n\t\t\t\tif (copy == attr_len)\n\t\t\t\t\treturn desired_len;\n\t\t\t}\n\n\t\t\tiedata += copy;\n\t\t\tiedatalen -= copy;\n\t\t\tattr_remaining = attr_len - copy;\n\t\t}\n\n cont:\n\t\tlen -= ies[1] + 2;\n\t\ties += ies[1] + 2;\n\t}\n\n\tif (attr_remaining && desired_attr)\n\t\treturn -EILSEQ;\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL(cfg80211_get_p2p_attr);\n\nstatic bool ieee80211_id_in_list(const u8 *ids, int n_ids, u8 id, bool id_ext)\n{\n\tint i;\n\n\t \n\tif (WARN_ON(ids[n_ids - 1] == WLAN_EID_EXTENSION))\n\t\treturn false;\n\n\ti = 0;\n\twhile (i < n_ids) {\n\t\tif (ids[i] == WLAN_EID_EXTENSION) {\n\t\t\tif (id_ext && (ids[i + 1] == id))\n\t\t\t\treturn true;\n\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ids[i] == id && !id_ext)\n\t\t\treturn true;\n\n\t\ti++;\n\t}\n\treturn false;\n}\n\nstatic size_t skip_ie(const u8 *ies, size_t ielen, size_t pos)\n{\n\t \n\tu8 len = ies[pos + 1];\n\n\tpos += 2 + len;\n\n\t \n\tif (len < 255)\n\t\treturn pos;\n\n\twhile (pos < ielen && ies[pos] == WLAN_EID_FRAGMENT) {\n\t\tlen = ies[pos + 1];\n\t\tpos += 2 + len;\n\t}\n\n\treturn pos;\n}\n\nsize_t ieee80211_ie_split_ric(const u8 *ies, size_t ielen,\n\t\t\t      const u8 *ids, int n_ids,\n\t\t\t      const u8 *after_ric, int n_after_ric,\n\t\t\t      size_t offset)\n{\n\tsize_t pos = offset;\n\n\twhile (pos < ielen) {\n\t\tu8 ext = 0;\n\n\t\tif (ies[pos] == WLAN_EID_EXTENSION)\n\t\t\text = 2;\n\t\tif ((pos + ext) >= ielen)\n\t\t\tbreak;\n\n\t\tif (!ieee80211_id_in_list(ids, n_ids, ies[pos + ext],\n\t\t\t\t\t  ies[pos] == WLAN_EID_EXTENSION))\n\t\t\tbreak;\n\n\t\tif (ies[pos] == WLAN_EID_RIC_DATA && n_after_ric) {\n\t\t\tpos = skip_ie(ies, ielen, pos);\n\n\t\t\twhile (pos < ielen) {\n\t\t\t\tif (ies[pos] == WLAN_EID_EXTENSION)\n\t\t\t\t\text = 2;\n\t\t\t\telse\n\t\t\t\t\text = 0;\n\n\t\t\t\tif ((pos + ext) >= ielen)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (!ieee80211_id_in_list(after_ric,\n\t\t\t\t\t\t\t  n_after_ric,\n\t\t\t\t\t\t\t  ies[pos + ext],\n\t\t\t\t\t\t\t  ext == 2))\n\t\t\t\t\tpos = skip_ie(ies, ielen, pos);\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tpos = skip_ie(ies, ielen, pos);\n\t\t}\n\t}\n\n\treturn pos;\n}\nEXPORT_SYMBOL(ieee80211_ie_split_ric);\n\nbool ieee80211_operating_class_to_band(u8 operating_class,\n\t\t\t\t       enum nl80211_band *band)\n{\n\tswitch (operating_class) {\n\tcase 112:\n\tcase 115 ... 127:\n\tcase 128 ... 130:\n\t\t*band = NL80211_BAND_5GHZ;\n\t\treturn true;\n\tcase 131 ... 135:\n\t\t*band = NL80211_BAND_6GHZ;\n\t\treturn true;\n\tcase 81:\n\tcase 82:\n\tcase 83:\n\tcase 84:\n\t\t*band = NL80211_BAND_2GHZ;\n\t\treturn true;\n\tcase 180:\n\t\t*band = NL80211_BAND_60GHZ;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL(ieee80211_operating_class_to_band);\n\nbool ieee80211_chandef_to_operating_class(struct cfg80211_chan_def *chandef,\n\t\t\t\t\t  u8 *op_class)\n{\n\tu8 vht_opclass;\n\tu32 freq = chandef->center_freq1;\n\n\tif (freq >= 2412 && freq <= 2472) {\n\t\tif (chandef->width > NL80211_CHAN_WIDTH_40)\n\t\t\treturn false;\n\n\t\t \n\t\tif (chandef->width == NL80211_CHAN_WIDTH_40) {\n\t\t\tif (freq > chandef->chan->center_freq)\n\t\t\t\t*op_class = 83;  \n\t\t\telse\n\t\t\t\t*op_class = 84;  \n\t\t} else {\n\t\t\t*op_class = 81;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tif (freq == 2484) {\n\t\t \n\t\tif (chandef->width != NL80211_CHAN_WIDTH_20_NOHT)\n\t\t\treturn false;\n\n\t\t*op_class = 82;  \n\t\treturn true;\n\t}\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tvht_opclass = 128;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tvht_opclass = 129;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80P80:\n\t\tvht_opclass = 130;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_10:\n\tcase NL80211_CHAN_WIDTH_5:\n\t\treturn false;  \n\tdefault:\n\t\tvht_opclass = 0;\n\t\tbreak;\n\t}\n\n\t \n\tif (freq >= 5180 && freq <= 5240) {\n\t\tif (vht_opclass) {\n\t\t\t*op_class = vht_opclass;\n\t\t} else if (chandef->width == NL80211_CHAN_WIDTH_40) {\n\t\t\tif (freq > chandef->chan->center_freq)\n\t\t\t\t*op_class = 116;\n\t\t\telse\n\t\t\t\t*op_class = 117;\n\t\t} else {\n\t\t\t*op_class = 115;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t \n\tif (freq >= 5260 && freq <= 5320) {\n\t\tif (vht_opclass) {\n\t\t\t*op_class = vht_opclass;\n\t\t} else if (chandef->width == NL80211_CHAN_WIDTH_40) {\n\t\t\tif (freq > chandef->chan->center_freq)\n\t\t\t\t*op_class = 119;\n\t\t\telse\n\t\t\t\t*op_class = 120;\n\t\t} else {\n\t\t\t*op_class = 118;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t \n\tif (freq >= 5500 && freq <= 5720) {\n\t\tif (vht_opclass) {\n\t\t\t*op_class = vht_opclass;\n\t\t} else if (chandef->width == NL80211_CHAN_WIDTH_40) {\n\t\t\tif (freq > chandef->chan->center_freq)\n\t\t\t\t*op_class = 122;\n\t\t\telse\n\t\t\t\t*op_class = 123;\n\t\t} else {\n\t\t\t*op_class = 121;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t \n\tif (freq >= 5745 && freq <= 5845) {\n\t\tif (vht_opclass) {\n\t\t\t*op_class = vht_opclass;\n\t\t} else if (chandef->width == NL80211_CHAN_WIDTH_40) {\n\t\t\tif (freq > chandef->chan->center_freq)\n\t\t\t\t*op_class = 126;\n\t\t\telse\n\t\t\t\t*op_class = 127;\n\t\t} else if (freq <= 5805) {\n\t\t\t*op_class = 124;\n\t\t} else {\n\t\t\t*op_class = 125;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t \n\tif (freq >= 56160 + 2160 * 1 && freq <= 56160 + 2160 * 6) {\n\t\tif (chandef->width >= NL80211_CHAN_WIDTH_40)\n\t\t\treturn false;\n\n\t\t*op_class = 180;\n\t\treturn true;\n\t}\n\n\t \n\treturn false;\n}\nEXPORT_SYMBOL(ieee80211_chandef_to_operating_class);\n\nstatic int cfg80211_wdev_bi(struct wireless_dev *wdev)\n{\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tWARN_ON(wdev->valid_links);\n\t\treturn wdev->links[0].ap.beacon_interval;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn wdev->u.mesh.beacon_interval;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\treturn wdev->u.ibss.beacon_interval;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void cfg80211_calculate_bi_data(struct wiphy *wiphy, u32 new_beacon_int,\n\t\t\t\t       u32 *beacon_int_gcd,\n\t\t\t\t       bool *beacon_int_different)\n{\n\tstruct wireless_dev *wdev;\n\n\t*beacon_int_gcd = 0;\n\t*beacon_int_different = false;\n\n\tlist_for_each_entry(wdev, &wiphy->wdev_list, list) {\n\t\tint wdev_bi;\n\n\t\t \n\t\tif (wdev->valid_links)\n\t\t\tcontinue;\n\n\t\twdev_bi = cfg80211_wdev_bi(wdev);\n\n\t\tif (!wdev_bi)\n\t\t\tcontinue;\n\n\t\tif (!*beacon_int_gcd) {\n\t\t\t*beacon_int_gcd = wdev_bi;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (wdev_bi == *beacon_int_gcd)\n\t\t\tcontinue;\n\n\t\t*beacon_int_different = true;\n\t\t*beacon_int_gcd = gcd(*beacon_int_gcd, wdev_bi);\n\t}\n\n\tif (new_beacon_int && *beacon_int_gcd != new_beacon_int) {\n\t\tif (*beacon_int_gcd)\n\t\t\t*beacon_int_different = true;\n\t\t*beacon_int_gcd = gcd(*beacon_int_gcd, new_beacon_int);\n\t}\n}\n\nint cfg80211_validate_beacon_int(struct cfg80211_registered_device *rdev,\n\t\t\t\t enum nl80211_iftype iftype, u32 beacon_int)\n{\n\t \n\n\tif (beacon_int < 10 || beacon_int > 10000)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint cfg80211_iter_combinations(struct wiphy *wiphy,\n\t\t\t       struct iface_combination_params *params,\n\t\t\t       void (*iter)(const struct ieee80211_iface_combination *c,\n\t\t\t\t\t    void *data),\n\t\t\t       void *data)\n{\n\tconst struct ieee80211_regdomain *regdom;\n\tenum nl80211_dfs_regions region = 0;\n\tint i, j, iftype;\n\tint num_interfaces = 0;\n\tu32 used_iftypes = 0;\n\tu32 beacon_int_gcd;\n\tbool beacon_int_different;\n\n\t \n\tcfg80211_calculate_bi_data(wiphy, params->new_beacon_int,\n\t\t\t\t   &beacon_int_gcd, &beacon_int_different);\n\n\tif (params->radar_detect) {\n\t\trcu_read_lock();\n\t\tregdom = rcu_dereference(cfg80211_regdomain);\n\t\tif (regdom)\n\t\t\tregion = regdom->dfs_region;\n\t\trcu_read_unlock();\n\t}\n\n\tfor (iftype = 0; iftype < NUM_NL80211_IFTYPES; iftype++) {\n\t\tnum_interfaces += params->iftype_num[iftype];\n\t\tif (params->iftype_num[iftype] > 0 &&\n\t\t    !cfg80211_iftype_allowed(wiphy, iftype, 0, 1))\n\t\t\tused_iftypes |= BIT(iftype);\n\t}\n\n\tfor (i = 0; i < wiphy->n_iface_combinations; i++) {\n\t\tconst struct ieee80211_iface_combination *c;\n\t\tstruct ieee80211_iface_limit *limits;\n\t\tu32 all_iftypes = 0;\n\n\t\tc = &wiphy->iface_combinations[i];\n\n\t\tif (num_interfaces > c->max_interfaces)\n\t\t\tcontinue;\n\t\tif (params->num_different_channels > c->num_different_channels)\n\t\t\tcontinue;\n\n\t\tlimits = kmemdup(c->limits, sizeof(limits[0]) * c->n_limits,\n\t\t\t\t GFP_KERNEL);\n\t\tif (!limits)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (iftype = 0; iftype < NUM_NL80211_IFTYPES; iftype++) {\n\t\t\tif (cfg80211_iftype_allowed(wiphy, iftype, 0, 1))\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j < c->n_limits; j++) {\n\t\t\t\tall_iftypes |= limits[j].types;\n\t\t\t\tif (!(limits[j].types & BIT(iftype)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (limits[j].max < params->iftype_num[iftype])\n\t\t\t\t\tgoto cont;\n\t\t\t\tlimits[j].max -= params->iftype_num[iftype];\n\t\t\t}\n\t\t}\n\n\t\tif (params->radar_detect !=\n\t\t\t(c->radar_detect_widths & params->radar_detect))\n\t\t\tgoto cont;\n\n\t\tif (params->radar_detect && c->radar_detect_regions &&\n\t\t    !(c->radar_detect_regions & BIT(region)))\n\t\t\tgoto cont;\n\n\t\t \n\t\tif ((all_iftypes & used_iftypes) != used_iftypes)\n\t\t\tgoto cont;\n\n\t\tif (beacon_int_gcd) {\n\t\t\tif (c->beacon_int_min_gcd &&\n\t\t\t    beacon_int_gcd < c->beacon_int_min_gcd)\n\t\t\t\tgoto cont;\n\t\t\tif (!c->beacon_int_min_gcd && beacon_int_different)\n\t\t\t\tgoto cont;\n\t\t}\n\n\t\t \n\n\t\t(*iter)(c, data);\n cont:\n\t\tkfree(limits);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cfg80211_iter_combinations);\n\nstatic void\ncfg80211_iter_sum_ifcombs(const struct ieee80211_iface_combination *c,\n\t\t\t  void *data)\n{\n\tint *num = data;\n\t(*num)++;\n}\n\nint cfg80211_check_combinations(struct wiphy *wiphy,\n\t\t\t\tstruct iface_combination_params *params)\n{\n\tint err, num = 0;\n\n\terr = cfg80211_iter_combinations(wiphy, params,\n\t\t\t\t\t cfg80211_iter_sum_ifcombs, &num);\n\tif (err)\n\t\treturn err;\n\tif (num == 0)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cfg80211_check_combinations);\n\nint ieee80211_get_ratemask(struct ieee80211_supported_band *sband,\n\t\t\t   const u8 *rates, unsigned int n_rates,\n\t\t\t   u32 *mask)\n{\n\tint i, j;\n\n\tif (!sband)\n\t\treturn -EINVAL;\n\n\tif (n_rates == 0 || n_rates > NL80211_MAX_SUPP_RATES)\n\t\treturn -EINVAL;\n\n\t*mask = 0;\n\n\tfor (i = 0; i < n_rates; i++) {\n\t\tint rate = (rates[i] & 0x7f) * 5;\n\t\tbool found = false;\n\n\t\tfor (j = 0; j < sband->n_bitrates; j++) {\n\t\t\tif (sband->bitrates[j].bitrate == rate) {\n\t\t\t\tfound = true;\n\t\t\t\t*mask |= BIT(j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\n\treturn 0;\n}\n\nunsigned int ieee80211_get_num_supported_channels(struct wiphy *wiphy)\n{\n\tenum nl80211_band band;\n\tunsigned int n_channels = 0;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++)\n\t\tif (wiphy->bands[band])\n\t\t\tn_channels += wiphy->bands[band]->n_channels;\n\n\treturn n_channels;\n}\nEXPORT_SYMBOL(ieee80211_get_num_supported_channels);\n\nint cfg80211_get_station(struct net_device *dev, const u8 *mac_addr,\n\t\t\t struct station_info *sinfo)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *wdev;\n\n\twdev = dev->ieee80211_ptr;\n\tif (!wdev)\n\t\treturn -EOPNOTSUPP;\n\n\trdev = wiphy_to_rdev(wdev->wiphy);\n\tif (!rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(sinfo, 0, sizeof(*sinfo));\n\n\treturn rdev_get_station(rdev, dev, mac_addr, sinfo);\n}\nEXPORT_SYMBOL(cfg80211_get_station);\n\nvoid cfg80211_free_nan_func(struct cfg80211_nan_func *f)\n{\n\tint i;\n\n\tif (!f)\n\t\treturn;\n\n\tkfree(f->serv_spec_info);\n\tkfree(f->srf_bf);\n\tkfree(f->srf_macs);\n\tfor (i = 0; i < f->num_rx_filters; i++)\n\t\tkfree(f->rx_filters[i].filter);\n\n\tfor (i = 0; i < f->num_tx_filters; i++)\n\t\tkfree(f->tx_filters[i].filter);\n\n\tkfree(f->rx_filters);\n\tkfree(f->tx_filters);\n\tkfree(f);\n}\nEXPORT_SYMBOL(cfg80211_free_nan_func);\n\nbool cfg80211_does_bw_fit_range(const struct ieee80211_freq_range *freq_range,\n\t\t\t\tu32 center_freq_khz, u32 bw_khz)\n{\n\tu32 start_freq_khz, end_freq_khz;\n\n\tstart_freq_khz = center_freq_khz - (bw_khz / 2);\n\tend_freq_khz = center_freq_khz + (bw_khz / 2);\n\n\tif (start_freq_khz >= freq_range->start_freq_khz &&\n\t    end_freq_khz <= freq_range->end_freq_khz)\n\t\treturn true;\n\n\treturn false;\n}\n\nint cfg80211_sinfo_alloc_tid_stats(struct station_info *sinfo, gfp_t gfp)\n{\n\tsinfo->pertid = kcalloc(IEEE80211_NUM_TIDS + 1,\n\t\t\t\tsizeof(*(sinfo->pertid)),\n\t\t\t\tgfp);\n\tif (!sinfo->pertid)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cfg80211_sinfo_alloc_tid_stats);\n\n \n \nconst unsigned char rfc1042_header[] __aligned(2) =\n\t{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };\nEXPORT_SYMBOL(rfc1042_header);\n\n \nconst unsigned char bridge_tunnel_header[] __aligned(2) =\n\t{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };\nEXPORT_SYMBOL(bridge_tunnel_header);\n\n \nstruct iapp_layer2_update {\n\tu8 da[ETH_ALEN];\t \n\tu8 sa[ETH_ALEN];\t \n\t__be16 len;\t\t \n\tu8 dsap;\t\t \n\tu8 ssap;\t\t \n\tu8 control;\n\tu8 xid_info[3];\n} __packed;\n\nvoid cfg80211_send_layer2_update(struct net_device *dev, const u8 *addr)\n{\n\tstruct iapp_layer2_update *msg;\n\tstruct sk_buff *skb;\n\n\t \n\n\tskb = dev_alloc_skb(sizeof(*msg));\n\tif (!skb)\n\t\treturn;\n\tmsg = skb_put(skb, sizeof(*msg));\n\n\t \n\n\teth_broadcast_addr(msg->da);\n\tether_addr_copy(msg->sa, addr);\n\tmsg->len = htons(6);\n\tmsg->dsap = 0;\n\tmsg->ssap = 0x01;\t \n\tmsg->control = 0xaf;\t \n\tmsg->xid_info[0] = 0x81;\t \n\tmsg->xid_info[1] = 1;\t \n\tmsg->xid_info[2] = 0;\t \n\n\tskb->dev = dev;\n\tskb->protocol = eth_type_trans(skb, dev);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tnetif_rx(skb);\n}\nEXPORT_SYMBOL(cfg80211_send_layer2_update);\n\nint ieee80211_get_vht_max_nss(struct ieee80211_vht_cap *cap,\n\t\t\t      enum ieee80211_vht_chanwidth bw,\n\t\t\t      int mcs, bool ext_nss_bw_capable,\n\t\t\t      unsigned int max_vht_nss)\n{\n\tu16 map = le16_to_cpu(cap->supp_mcs.rx_mcs_map);\n\tint ext_nss_bw;\n\tint supp_width;\n\tint i, mcs_encoding;\n\n\tif (map == 0xffff)\n\t\treturn 0;\n\n\tif (WARN_ON(mcs > 9 || max_vht_nss > 8))\n\t\treturn 0;\n\tif (mcs <= 7)\n\t\tmcs_encoding = 0;\n\telse if (mcs == 8)\n\t\tmcs_encoding = 1;\n\telse\n\t\tmcs_encoding = 2;\n\n\tif (!max_vht_nss) {\n\t\t \n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tint supp = (map >> (2 * i)) & 3;\n\n\t\t\tif (supp == 3)\n\t\t\t\tcontinue;\n\n\t\t\tif (supp >= mcs_encoding) {\n\t\t\t\tmax_vht_nss = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!(cap->supp_mcs.tx_mcs_map &\n\t\t\tcpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE)))\n\t\treturn max_vht_nss;\n\n\text_nss_bw = le32_get_bits(cap->vht_cap_info,\n\t\t\t\t   IEEE80211_VHT_CAP_EXT_NSS_BW_MASK);\n\tsupp_width = le32_get_bits(cap->vht_cap_info,\n\t\t\t\t   IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK);\n\n\t \n\tif (!ext_nss_bw_capable)\n\t\text_nss_bw = 0;\n\n\t \n\tif (supp_width == 3)\n\t\treturn 0;\n\n\t \n\tif (supp_width == 2 && (ext_nss_bw == 1 || ext_nss_bw == 2))\n\t\treturn 0;\n\n\t \n\tswitch (bw) {\n\tcase IEEE80211_VHT_CHANWIDTH_USE_HT:\n\tcase IEEE80211_VHT_CHANWIDTH_80MHZ:\n\t\tif ((supp_width == 1 || supp_width == 2) &&\n\t\t    ext_nss_bw == 3)\n\t\t\treturn 2 * max_vht_nss;\n\t\tbreak;\n\tcase IEEE80211_VHT_CHANWIDTH_160MHZ:\n\t\tif (supp_width == 0 &&\n\t\t    (ext_nss_bw == 1 || ext_nss_bw == 2))\n\t\t\treturn max_vht_nss / 2;\n\t\tif (supp_width == 0 &&\n\t\t    ext_nss_bw == 3)\n\t\t\treturn (3 * max_vht_nss) / 4;\n\t\tif (supp_width == 1 &&\n\t\t    ext_nss_bw == 3)\n\t\t\treturn 2 * max_vht_nss;\n\t\tbreak;\n\tcase IEEE80211_VHT_CHANWIDTH_80P80MHZ:\n\t\tif (supp_width == 0 && ext_nss_bw == 1)\n\t\t\treturn 0;  \n\t\tif (supp_width == 0 &&\n\t\t    ext_nss_bw == 2)\n\t\t\treturn max_vht_nss / 2;\n\t\tif (supp_width == 0 &&\n\t\t    ext_nss_bw == 3)\n\t\t\treturn (3 * max_vht_nss) / 4;\n\t\tif (supp_width == 1 &&\n\t\t    ext_nss_bw == 0)\n\t\t\treturn 0;  \n\t\tif (supp_width == 1 &&\n\t\t    ext_nss_bw == 1)\n\t\t\treturn max_vht_nss / 2;\n\t\tif (supp_width == 1 &&\n\t\t    ext_nss_bw == 2)\n\t\t\treturn (3 * max_vht_nss) / 4;\n\t\tbreak;\n\t}\n\n\t \n\treturn max_vht_nss;\n}\nEXPORT_SYMBOL(ieee80211_get_vht_max_nss);\n\nbool cfg80211_iftype_allowed(struct wiphy *wiphy, enum nl80211_iftype iftype,\n\t\t\t     bool is_4addr, u8 check_swif)\n\n{\n\tbool is_vlan = iftype == NL80211_IFTYPE_AP_VLAN;\n\n\tswitch (check_swif) {\n\tcase 0:\n\t\tif (is_vlan && is_4addr)\n\t\t\treturn wiphy->flags & WIPHY_FLAG_4ADDR_AP;\n\t\treturn wiphy->interface_modes & BIT(iftype);\n\tcase 1:\n\t\tif (!(wiphy->software_iftypes & BIT(iftype)) && is_vlan)\n\t\t\treturn wiphy->flags & WIPHY_FLAG_4ADDR_AP;\n\t\treturn wiphy->software_iftypes & BIT(iftype);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL(cfg80211_iftype_allowed);\n\nvoid cfg80211_remove_link(struct wireless_dev *wdev, unsigned int link_id)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\n\tASSERT_WDEV_LOCK(wdev);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t__cfg80211_stop_ap(rdev, wdev->netdev, link_id, true);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\twdev->valid_links &= ~BIT(link_id);\n\n\trdev_del_intf_link(rdev, wdev, link_id);\n\n\teth_zero_addr(wdev->links[link_id].addr);\n}\n\nvoid cfg80211_remove_links(struct wireless_dev *wdev)\n{\n\tunsigned int link_id;\n\n\t \n\tif (wdev->iftype != NL80211_IFTYPE_AP)\n\t\treturn;\n\n\twdev_lock(wdev);\n\tif (wdev->valid_links) {\n\t\tfor_each_valid_link(wdev, link_id)\n\t\t\tcfg80211_remove_link(wdev, link_id);\n\t}\n\twdev_unlock(wdev);\n}\n\nint cfg80211_remove_virtual_intf(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct wireless_dev *wdev)\n{\n\tcfg80211_remove_links(wdev);\n\n\treturn rdev_del_virtual_intf(rdev, wdev);\n}\n\nconst struct wiphy_iftype_ext_capab *\ncfg80211_get_iftype_ext_capa(struct wiphy *wiphy, enum nl80211_iftype type)\n{\n\tint i;\n\n\tfor (i = 0; i < wiphy->num_iftype_ext_capab; i++) {\n\t\tif (wiphy->iftype_ext_capab[i].iftype == type)\n\t\t\treturn &wiphy->iftype_ext_capab[i];\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(cfg80211_get_iftype_ext_capa);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}