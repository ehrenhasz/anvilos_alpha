{
  "module_name": "lib80211_crypt_ccmp.c",
  "hash_id": "4650d4dd62eeee2d13aa1d9d32f34f7208f56b9ba8b6b72f051799c542c7874a",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/lib80211_crypt_ccmp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_arp.h>\n#include <asm/string.h>\n#include <linux/wireless.h>\n\n#include <linux/ieee80211.h>\n\n#include <linux/crypto.h>\n#include <crypto/aead.h>\n\n#include <net/lib80211.h>\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"Host AP crypt: CCMP\");\nMODULE_LICENSE(\"GPL\");\n\n#define AES_BLOCK_LEN 16\n#define CCMP_HDR_LEN 8\n#define CCMP_MIC_LEN 8\n#define CCMP_TK_LEN 16\n#define CCMP_PN_LEN 6\n\nstruct lib80211_ccmp_data {\n\tu8 key[CCMP_TK_LEN];\n\tint key_set;\n\n\tu8 tx_pn[CCMP_PN_LEN];\n\tu8 rx_pn[CCMP_PN_LEN];\n\n\tu32 dot11RSNAStatsCCMPFormatErrors;\n\tu32 dot11RSNAStatsCCMPReplays;\n\tu32 dot11RSNAStatsCCMPDecryptErrors;\n\n\tint key_idx;\n\n\tstruct crypto_aead *tfm;\n\n\t \n\tu8 tx_aad[2 * AES_BLOCK_LEN];\n\tu8 rx_aad[2 * AES_BLOCK_LEN];\n};\n\nstatic void *lib80211_ccmp_init(int key_idx)\n{\n\tstruct lib80211_ccmp_data *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_ATOMIC);\n\tif (priv == NULL)\n\t\tgoto fail;\n\tpriv->key_idx = key_idx;\n\n\tpriv->tfm = crypto_alloc_aead(\"ccm(aes)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(priv->tfm)) {\n\t\tpriv->tfm = NULL;\n\t\tgoto fail;\n\t}\n\n\treturn priv;\n\n      fail:\n\tif (priv) {\n\t\tif (priv->tfm)\n\t\t\tcrypto_free_aead(priv->tfm);\n\t\tkfree(priv);\n\t}\n\n\treturn NULL;\n}\n\nstatic void lib80211_ccmp_deinit(void *priv)\n{\n\tstruct lib80211_ccmp_data *_priv = priv;\n\tif (_priv && _priv->tfm)\n\t\tcrypto_free_aead(_priv->tfm);\n\tkfree(priv);\n}\n\nstatic int ccmp_init_iv_and_aad(const struct ieee80211_hdr *hdr,\n\t\t\t\tconst u8 *pn, u8 *iv, u8 *aad)\n{\n\tu8 *pos, qc = 0;\n\tsize_t aad_len;\n\tint a4_included, qc_included;\n\n\ta4_included = ieee80211_has_a4(hdr->frame_control);\n\tqc_included = ieee80211_is_data_qos(hdr->frame_control);\n\n\taad_len = 22;\n\tif (a4_included)\n\t\taad_len += 6;\n\tif (qc_included) {\n\t\tpos = (u8 *) & hdr->addr4;\n\t\tif (a4_included)\n\t\t\tpos += 6;\n\t\tqc = *pos & 0x0f;\n\t\taad_len += 2;\n\t}\n\n\t \n\tiv[0] = 0x1;\n\n\t \n\tiv[1] = qc;\n\tmemcpy(iv + 2, hdr->addr2, ETH_ALEN);\n\tmemcpy(iv + 8, pn, CCMP_PN_LEN);\n\n\t \n\tpos = (u8 *) hdr;\n\taad[0] = pos[0] & 0x8f;\n\taad[1] = pos[1] & 0xc7;\n\tmemcpy(aad + 2, &hdr->addrs, 3 * ETH_ALEN);\n\tpos = (u8 *) & hdr->seq_ctrl;\n\taad[20] = pos[0] & 0x0f;\n\taad[21] = 0;\t\t \n\tmemset(aad + 22, 0, 8);\n\tif (a4_included)\n\t\tmemcpy(aad + 22, hdr->addr4, ETH_ALEN);\n\tif (qc_included) {\n\t\taad[a4_included ? 28 : 22] = qc;\n\t\t \n\t}\n\treturn aad_len;\n}\n\nstatic int lib80211_ccmp_hdr(struct sk_buff *skb, int hdr_len,\n\t\t\t      u8 *aeskey, int keylen, void *priv)\n{\n\tstruct lib80211_ccmp_data *key = priv;\n\tint i;\n\tu8 *pos;\n\n\tif (skb_headroom(skb) < CCMP_HDR_LEN || skb->len < hdr_len)\n\t\treturn -1;\n\n\tif (aeskey != NULL && keylen >= CCMP_TK_LEN)\n\t\tmemcpy(aeskey, key->key, CCMP_TK_LEN);\n\n\tpos = skb_push(skb, CCMP_HDR_LEN);\n\tmemmove(pos, pos + CCMP_HDR_LEN, hdr_len);\n\tpos += hdr_len;\n\n\ti = CCMP_PN_LEN - 1;\n\twhile (i >= 0) {\n\t\tkey->tx_pn[i]++;\n\t\tif (key->tx_pn[i] != 0)\n\t\t\tbreak;\n\t\ti--;\n\t}\n\n\t*pos++ = key->tx_pn[5];\n\t*pos++ = key->tx_pn[4];\n\t*pos++ = 0;\n\t*pos++ = (key->key_idx << 6) | (1 << 5)   ;\n\t*pos++ = key->tx_pn[3];\n\t*pos++ = key->tx_pn[2];\n\t*pos++ = key->tx_pn[1];\n\t*pos++ = key->tx_pn[0];\n\n\treturn CCMP_HDR_LEN;\n}\n\nstatic int lib80211_ccmp_encrypt(struct sk_buff *skb, int hdr_len, void *priv)\n{\n\tstruct lib80211_ccmp_data *key = priv;\n\tstruct ieee80211_hdr *hdr;\n\tstruct aead_request *req;\n\tstruct scatterlist sg[2];\n\tu8 *aad = key->tx_aad;\n\tu8 iv[AES_BLOCK_LEN];\n\tint len, data_len, aad_len;\n\tint ret;\n\n\tif (skb_tailroom(skb) < CCMP_MIC_LEN || skb->len < hdr_len)\n\t\treturn -1;\n\n\tdata_len = skb->len - hdr_len;\n\tlen = lib80211_ccmp_hdr(skb, hdr_len, NULL, 0, priv);\n\tif (len < 0)\n\t\treturn -1;\n\n\treq = aead_request_alloc(key->tfm, GFP_ATOMIC);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\taad_len = ccmp_init_iv_and_aad(hdr, key->tx_pn, iv, aad);\n\n\tskb_put(skb, CCMP_MIC_LEN);\n\n\tsg_init_table(sg, 2);\n\tsg_set_buf(&sg[0], aad, aad_len);\n\tsg_set_buf(&sg[1], skb->data + hdr_len + CCMP_HDR_LEN,\n\t\t   data_len + CCMP_MIC_LEN);\n\n\taead_request_set_callback(req, 0, NULL, NULL);\n\taead_request_set_ad(req, aad_len);\n\taead_request_set_crypt(req, sg, sg, data_len, iv);\n\n\tret = crypto_aead_encrypt(req);\n\taead_request_free(req);\n\n\treturn ret;\n}\n\n \nstatic inline int ccmp_replay_check(u8 *pn_n, u8 *pn_o)\n{\n\tu32 iv32_n, iv16_n;\n\tu32 iv32_o, iv16_o;\n\n\tiv32_n = (pn_n[0] << 24) | (pn_n[1] << 16) | (pn_n[2] << 8) | pn_n[3];\n\tiv16_n = (pn_n[4] << 8) | pn_n[5];\n\n\tiv32_o = (pn_o[0] << 24) | (pn_o[1] << 16) | (pn_o[2] << 8) | pn_o[3];\n\tiv16_o = (pn_o[4] << 8) | pn_o[5];\n\n\tif ((s32)iv32_n - (s32)iv32_o < 0 ||\n\t    (iv32_n == iv32_o && iv16_n <= iv16_o))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int lib80211_ccmp_decrypt(struct sk_buff *skb, int hdr_len, void *priv)\n{\n\tstruct lib80211_ccmp_data *key = priv;\n\tu8 keyidx, *pos;\n\tstruct ieee80211_hdr *hdr;\n\tstruct aead_request *req;\n\tstruct scatterlist sg[2];\n\tu8 *aad = key->rx_aad;\n\tu8 iv[AES_BLOCK_LEN];\n\tu8 pn[6];\n\tint aad_len, ret;\n\tsize_t data_len = skb->len - hdr_len - CCMP_HDR_LEN;\n\n\tif (skb->len < hdr_len + CCMP_HDR_LEN + CCMP_MIC_LEN) {\n\t\tkey->dot11RSNAStatsCCMPFormatErrors++;\n\t\treturn -1;\n\t}\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tpos = skb->data + hdr_len;\n\tkeyidx = pos[3];\n\tif (!(keyidx & (1 << 5))) {\n\t\tnet_dbg_ratelimited(\"CCMP: received packet without ExtIV flag from %pM\\n\",\n\t\t\t\t    hdr->addr2);\n\t\tkey->dot11RSNAStatsCCMPFormatErrors++;\n\t\treturn -2;\n\t}\n\tkeyidx >>= 6;\n\tif (key->key_idx != keyidx) {\n\t\tnet_dbg_ratelimited(\"CCMP: RX tkey->key_idx=%d frame keyidx=%d\\n\",\n\t\t\t\t    key->key_idx, keyidx);\n\t\treturn -6;\n\t}\n\tif (!key->key_set) {\n\t\tnet_dbg_ratelimited(\"CCMP: received packet from %pM with keyid=%d that does not have a configured key\\n\",\n\t\t\t\t    hdr->addr2, keyidx);\n\t\treturn -3;\n\t}\n\n\tpn[0] = pos[7];\n\tpn[1] = pos[6];\n\tpn[2] = pos[5];\n\tpn[3] = pos[4];\n\tpn[4] = pos[1];\n\tpn[5] = pos[0];\n\tpos += 8;\n\n\tif (ccmp_replay_check(pn, key->rx_pn)) {\n#ifdef CONFIG_LIB80211_DEBUG\n\t\tnet_dbg_ratelimited(\"CCMP: replay detected: STA=%pM previous PN %02x%02x%02x%02x%02x%02x received PN %02x%02x%02x%02x%02x%02x\\n\",\n\t\t\t\t    hdr->addr2,\n\t\t\t\t    key->rx_pn[0], key->rx_pn[1], key->rx_pn[2],\n\t\t\t\t    key->rx_pn[3], key->rx_pn[4], key->rx_pn[5],\n\t\t\t\t    pn[0], pn[1], pn[2], pn[3], pn[4], pn[5]);\n#endif\n\t\tkey->dot11RSNAStatsCCMPReplays++;\n\t\treturn -4;\n\t}\n\n\treq = aead_request_alloc(key->tfm, GFP_ATOMIC);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\taad_len = ccmp_init_iv_and_aad(hdr, pn, iv, aad);\n\n\tsg_init_table(sg, 2);\n\tsg_set_buf(&sg[0], aad, aad_len);\n\tsg_set_buf(&sg[1], pos, data_len);\n\n\taead_request_set_callback(req, 0, NULL, NULL);\n\taead_request_set_ad(req, aad_len);\n\taead_request_set_crypt(req, sg, sg, data_len, iv);\n\n\tret = crypto_aead_decrypt(req);\n\taead_request_free(req);\n\n\tif (ret) {\n\t\tnet_dbg_ratelimited(\"CCMP: decrypt failed: STA=%pM (%d)\\n\",\n\t\t\t\t    hdr->addr2, ret);\n\t\tkey->dot11RSNAStatsCCMPDecryptErrors++;\n\t\treturn -5;\n\t}\n\n\tmemcpy(key->rx_pn, pn, CCMP_PN_LEN);\n\n\t \n\tmemmove(skb->data + CCMP_HDR_LEN, skb->data, hdr_len);\n\tskb_pull(skb, CCMP_HDR_LEN);\n\tskb_trim(skb, skb->len - CCMP_MIC_LEN);\n\n\treturn keyidx;\n}\n\nstatic int lib80211_ccmp_set_key(void *key, int len, u8 * seq, void *priv)\n{\n\tstruct lib80211_ccmp_data *data = priv;\n\tint keyidx;\n\tstruct crypto_aead *tfm = data->tfm;\n\n\tkeyidx = data->key_idx;\n\tmemset(data, 0, sizeof(*data));\n\tdata->key_idx = keyidx;\n\tdata->tfm = tfm;\n\tif (len == CCMP_TK_LEN) {\n\t\tmemcpy(data->key, key, CCMP_TK_LEN);\n\t\tdata->key_set = 1;\n\t\tif (seq) {\n\t\t\tdata->rx_pn[0] = seq[5];\n\t\t\tdata->rx_pn[1] = seq[4];\n\t\t\tdata->rx_pn[2] = seq[3];\n\t\t\tdata->rx_pn[3] = seq[2];\n\t\t\tdata->rx_pn[4] = seq[1];\n\t\t\tdata->rx_pn[5] = seq[0];\n\t\t}\n\t\tif (crypto_aead_setauthsize(data->tfm, CCMP_MIC_LEN) ||\n\t\t    crypto_aead_setkey(data->tfm, data->key, CCMP_TK_LEN))\n\t\t\treturn -1;\n\t} else if (len == 0)\n\t\tdata->key_set = 0;\n\telse\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int lib80211_ccmp_get_key(void *key, int len, u8 * seq, void *priv)\n{\n\tstruct lib80211_ccmp_data *data = priv;\n\n\tif (len < CCMP_TK_LEN)\n\t\treturn -1;\n\n\tif (!data->key_set)\n\t\treturn 0;\n\tmemcpy(key, data->key, CCMP_TK_LEN);\n\n\tif (seq) {\n\t\tseq[0] = data->tx_pn[5];\n\t\tseq[1] = data->tx_pn[4];\n\t\tseq[2] = data->tx_pn[3];\n\t\tseq[3] = data->tx_pn[2];\n\t\tseq[4] = data->tx_pn[1];\n\t\tseq[5] = data->tx_pn[0];\n\t}\n\n\treturn CCMP_TK_LEN;\n}\n\nstatic void lib80211_ccmp_print_stats(struct seq_file *m, void *priv)\n{\n\tstruct lib80211_ccmp_data *ccmp = priv;\n\n\tseq_printf(m,\n\t\t   \"key[%d] alg=CCMP key_set=%d \"\n\t\t   \"tx_pn=%02x%02x%02x%02x%02x%02x \"\n\t\t   \"rx_pn=%02x%02x%02x%02x%02x%02x \"\n\t\t   \"format_errors=%d replays=%d decrypt_errors=%d\\n\",\n\t\t   ccmp->key_idx, ccmp->key_set,\n\t\t   ccmp->tx_pn[0], ccmp->tx_pn[1], ccmp->tx_pn[2],\n\t\t   ccmp->tx_pn[3], ccmp->tx_pn[4], ccmp->tx_pn[5],\n\t\t   ccmp->rx_pn[0], ccmp->rx_pn[1], ccmp->rx_pn[2],\n\t\t   ccmp->rx_pn[3], ccmp->rx_pn[4], ccmp->rx_pn[5],\n\t\t   ccmp->dot11RSNAStatsCCMPFormatErrors,\n\t\t   ccmp->dot11RSNAStatsCCMPReplays,\n\t\t   ccmp->dot11RSNAStatsCCMPDecryptErrors);\n}\n\nstatic struct lib80211_crypto_ops lib80211_crypt_ccmp = {\n\t.name = \"CCMP\",\n\t.init = lib80211_ccmp_init,\n\t.deinit = lib80211_ccmp_deinit,\n\t.encrypt_mpdu = lib80211_ccmp_encrypt,\n\t.decrypt_mpdu = lib80211_ccmp_decrypt,\n\t.encrypt_msdu = NULL,\n\t.decrypt_msdu = NULL,\n\t.set_key = lib80211_ccmp_set_key,\n\t.get_key = lib80211_ccmp_get_key,\n\t.print_stats = lib80211_ccmp_print_stats,\n\t.extra_mpdu_prefix_len = CCMP_HDR_LEN,\n\t.extra_mpdu_postfix_len = CCMP_MIC_LEN,\n\t.owner = THIS_MODULE,\n};\n\nstatic int __init lib80211_crypto_ccmp_init(void)\n{\n\treturn lib80211_register_crypto_ops(&lib80211_crypt_ccmp);\n}\n\nstatic void __exit lib80211_crypto_ccmp_exit(void)\n{\n\tlib80211_unregister_crypto_ops(&lib80211_crypt_ccmp);\n}\n\nmodule_init(lib80211_crypto_ccmp_init);\nmodule_exit(lib80211_crypto_ccmp_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}