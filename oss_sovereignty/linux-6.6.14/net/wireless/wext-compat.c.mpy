{
  "module_name": "wext-compat.c",
  "hash_id": "d91323344e0f0f082ae30c130f7b52dbbe0657d340492493ab2034a7033751a3",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/wext-compat.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/wireless.h>\n#include <linux/nl80211.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include <net/iw_handler.h>\n#include <net/cfg80211.h>\n#include <net/cfg80211-wext.h>\n#include \"wext-compat.h\"\n#include \"core.h\"\n#include \"rdev-ops.h\"\n\nint cfg80211_wext_giwname(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstrcpy(wrqu->name, \"IEEE 802.11\");\n\treturn 0;\n}\nEXPORT_WEXT_HANDLER(cfg80211_wext_giwname);\n\nint cfg80211_wext_siwmode(struct net_device *dev, struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\t__u32 *mode = &wrqu->mode;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev;\n\tstruct vif_params vifparams;\n\tenum nl80211_iftype type;\n\tint ret;\n\n\trdev = wiphy_to_rdev(wdev->wiphy);\n\n\tswitch (*mode) {\n\tcase IW_MODE_INFRA:\n\t\ttype = NL80211_IFTYPE_STATION;\n\t\tbreak;\n\tcase IW_MODE_ADHOC:\n\t\ttype = NL80211_IFTYPE_ADHOC;\n\t\tbreak;\n\tcase IW_MODE_MONITOR:\n\t\ttype = NL80211_IFTYPE_MONITOR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (type == wdev->iftype)\n\t\treturn 0;\n\n\tmemset(&vifparams, 0, sizeof(vifparams));\n\n\twiphy_lock(wdev->wiphy);\n\tret = cfg80211_change_iface(rdev, dev, type, &vifparams);\n\twiphy_unlock(wdev->wiphy);\n\n\treturn ret;\n}\nEXPORT_WEXT_HANDLER(cfg80211_wext_siwmode);\n\nint cfg80211_wext_giwmode(struct net_device *dev, struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\t__u32 *mode = &wrqu->mode;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (!wdev)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_AP:\n\t\t*mode = IW_MODE_MASTER;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\t*mode = IW_MODE_INFRA;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t*mode = IW_MODE_ADHOC;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\t*mode = IW_MODE_MONITOR;\n\t\tbreak;\n\tcase NL80211_IFTYPE_WDS:\n\t\t*mode = IW_MODE_REPEAT;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t*mode = IW_MODE_SECOND;\t\t \n\t\tbreak;\n\tdefault:\n\t\t*mode = IW_MODE_AUTO;\n\t\tbreak;\n\t}\n\treturn 0;\n}\nEXPORT_WEXT_HANDLER(cfg80211_wext_giwmode);\n\n\nint cfg80211_wext_giwrange(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct iw_range *range = (struct iw_range *) extra;\n\tenum nl80211_band band;\n\tint i, c = 0;\n\n\tif (!wdev)\n\t\treturn -EOPNOTSUPP;\n\n\tdata->length = sizeof(struct iw_range);\n\tmemset(range, 0, sizeof(struct iw_range));\n\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->we_version_source = 21;\n\trange->retry_capa = IW_RETRY_LIMIT;\n\trange->retry_flags = IW_RETRY_LIMIT;\n\trange->min_retry = 0;\n\trange->max_retry = 255;\n\trange->min_rts = 0;\n\trange->max_rts = 2347;\n\trange->min_frag = 256;\n\trange->max_frag = 2346;\n\n\trange->max_encoding_tokens = 4;\n\n\trange->max_qual.updated = IW_QUAL_NOISE_INVALID;\n\n\tswitch (wdev->wiphy->signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_NONE:\n\t\tbreak;\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\trange->max_qual.level = (u8)-110;\n\t\trange->max_qual.qual = 70;\n\t\trange->avg_qual.qual = 35;\n\t\trange->max_qual.updated |= IW_QUAL_DBM;\n\t\trange->max_qual.updated |= IW_QUAL_QUAL_UPDATED;\n\t\trange->max_qual.updated |= IW_QUAL_LEVEL_UPDATED;\n\t\tbreak;\n\tcase CFG80211_SIGNAL_TYPE_UNSPEC:\n\t\trange->max_qual.level = 100;\n\t\trange->max_qual.qual = 100;\n\t\trange->avg_qual.qual = 50;\n\t\trange->max_qual.updated |= IW_QUAL_QUAL_UPDATED;\n\t\trange->max_qual.updated |= IW_QUAL_LEVEL_UPDATED;\n\t\tbreak;\n\t}\n\n\trange->avg_qual.level = range->max_qual.level / 2;\n\trange->avg_qual.noise = range->max_qual.noise / 2;\n\trange->avg_qual.updated = range->max_qual.updated;\n\n\tfor (i = 0; i < wdev->wiphy->n_cipher_suites; i++) {\n\t\tswitch (wdev->wiphy->cipher_suites[i]) {\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\trange->enc_capa |= (IW_ENC_CAPA_CIPHER_TKIP |\n\t\t\t\t\t    IW_ENC_CAPA_WPA);\n\t\t\tbreak;\n\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\trange->enc_capa |= (IW_ENC_CAPA_CIPHER_CCMP |\n\t\t\t\t\t    IW_ENC_CAPA_WPA2);\n\t\t\tbreak;\n\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\t\trange->encoding_size[range->num_encoding_sizes++] =\n\t\t\t\tWLAN_KEY_LEN_WEP40;\n\t\t\tbreak;\n\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\trange->encoding_size[range->num_encoding_sizes++] =\n\t\t\t\tWLAN_KEY_LEN_WEP104;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band ++) {\n\t\tstruct ieee80211_supported_band *sband;\n\n\t\tsband = wdev->wiphy->bands[band];\n\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < sband->n_channels && c < IW_MAX_FREQUENCIES; i++) {\n\t\t\tstruct ieee80211_channel *chan = &sband->channels[i];\n\n\t\t\tif (!(chan->flags & IEEE80211_CHAN_DISABLED)) {\n\t\t\t\trange->freq[c].i =\n\t\t\t\t\tieee80211_frequency_to_channel(\n\t\t\t\t\t\tchan->center_freq);\n\t\t\t\trange->freq[c].m = chan->center_freq;\n\t\t\t\trange->freq[c].e = 6;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\trange->num_channels = c;\n\trange->num_frequency = c;\n\n\tIW_EVENT_CAPA_SET_KERNEL(range->event_capa);\n\tIW_EVENT_CAPA_SET(range->event_capa, SIOCGIWAP);\n\tIW_EVENT_CAPA_SET(range->event_capa, SIOCGIWSCAN);\n\n\tif (wdev->wiphy->max_scan_ssids > 0)\n\t\trange->scan_capa |= IW_SCAN_CAPA_ESSID;\n\n\treturn 0;\n}\nEXPORT_WEXT_HANDLER(cfg80211_wext_giwrange);\n\n\n \nint cfg80211_wext_freq(struct iw_freq *freq)\n{\n\t \n\tif (freq->e == 0) {\n\t\tenum nl80211_band band = NL80211_BAND_2GHZ;\n\t\tif (freq->m < 0)\n\t\t\treturn 0;\n\t\tif (freq->m > 14)\n\t\t\tband = NL80211_BAND_5GHZ;\n\t\treturn ieee80211_channel_to_frequency(freq->m, band);\n\t} else {\n\t\tint i, div = 1000000;\n\t\tfor (i = 0; i < freq->e; i++)\n\t\t\tdiv /= 10;\n\t\tif (div <= 0)\n\t\t\treturn -EINVAL;\n\t\treturn freq->m / div;\n\t}\n}\n\nint cfg80211_wext_siwrts(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rts = &wrqu->rts;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tu32 orts = wdev->wiphy->rts_threshold;\n\tint err;\n\n\twiphy_lock(&rdev->wiphy);\n\tif (rts->disabled || !rts->fixed) {\n\t\twdev->wiphy->rts_threshold = (u32) -1;\n\t} else if (rts->value < 0) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\twdev->wiphy->rts_threshold = rts->value;\n\t}\n\n\terr = rdev_set_wiphy_params(rdev, WIPHY_PARAM_RTS_THRESHOLD);\n\n\tif (err)\n\t\twdev->wiphy->rts_threshold = orts;\n\nout:\n\twiphy_unlock(&rdev->wiphy);\n\treturn err;\n}\nEXPORT_WEXT_HANDLER(cfg80211_wext_siwrts);\n\nint cfg80211_wext_giwrts(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rts = &wrqu->rts;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\trts->value = wdev->wiphy->rts_threshold;\n\trts->disabled = rts->value == (u32) -1;\n\trts->fixed = 1;\n\n\treturn 0;\n}\nEXPORT_WEXT_HANDLER(cfg80211_wext_giwrts);\n\nint cfg80211_wext_siwfrag(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *frag = &wrqu->frag;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tu32 ofrag = wdev->wiphy->frag_threshold;\n\tint err;\n\n\twiphy_lock(&rdev->wiphy);\n\tif (frag->disabled || !frag->fixed) {\n\t\twdev->wiphy->frag_threshold = (u32) -1;\n\t} else if (frag->value < 256) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\t \n\t\twdev->wiphy->frag_threshold = frag->value & ~0x1;\n\t}\n\n\terr = rdev_set_wiphy_params(rdev, WIPHY_PARAM_FRAG_THRESHOLD);\n\tif (err)\n\t\twdev->wiphy->frag_threshold = ofrag;\nout:\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn err;\n}\nEXPORT_WEXT_HANDLER(cfg80211_wext_siwfrag);\n\nint cfg80211_wext_giwfrag(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *frag = &wrqu->frag;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tfrag->value = wdev->wiphy->frag_threshold;\n\tfrag->disabled = frag->value == (u32) -1;\n\tfrag->fixed = 1;\n\n\treturn 0;\n}\nEXPORT_WEXT_HANDLER(cfg80211_wext_giwfrag);\n\nstatic int cfg80211_wext_siwretry(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *retry = &wrqu->retry;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tu32 changed = 0;\n\tu8 olong = wdev->wiphy->retry_long;\n\tu8 oshort = wdev->wiphy->retry_short;\n\tint err;\n\n\tif (retry->disabled || retry->value < 1 || retry->value > 255 ||\n\t    (retry->flags & IW_RETRY_TYPE) != IW_RETRY_LIMIT)\n\t\treturn -EINVAL;\n\n\twiphy_lock(&rdev->wiphy);\n\tif (retry->flags & IW_RETRY_LONG) {\n\t\twdev->wiphy->retry_long = retry->value;\n\t\tchanged |= WIPHY_PARAM_RETRY_LONG;\n\t} else if (retry->flags & IW_RETRY_SHORT) {\n\t\twdev->wiphy->retry_short = retry->value;\n\t\tchanged |= WIPHY_PARAM_RETRY_SHORT;\n\t} else {\n\t\twdev->wiphy->retry_short = retry->value;\n\t\twdev->wiphy->retry_long = retry->value;\n\t\tchanged |= WIPHY_PARAM_RETRY_LONG;\n\t\tchanged |= WIPHY_PARAM_RETRY_SHORT;\n\t}\n\n\terr = rdev_set_wiphy_params(rdev, changed);\n\tif (err) {\n\t\twdev->wiphy->retry_short = oshort;\n\t\twdev->wiphy->retry_long = olong;\n\t}\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn err;\n}\n\nint cfg80211_wext_giwretry(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *retry = &wrqu->retry;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tretry->disabled = 0;\n\n\tif (retry->flags == 0 || (retry->flags & IW_RETRY_SHORT)) {\n\t\t \n\t\tretry->flags |= IW_RETRY_LIMIT | IW_RETRY_SHORT;\n\t\tretry->value = wdev->wiphy->retry_short;\n\t\tif (wdev->wiphy->retry_long == wdev->wiphy->retry_short)\n\t\t\tretry->flags |= IW_RETRY_LONG;\n\n\t\treturn 0;\n\t}\n\n\tif (retry->flags & IW_RETRY_LONG) {\n\t\tretry->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n\t\tretry->value = wdev->wiphy->retry_long;\n\t}\n\n\treturn 0;\n}\nEXPORT_WEXT_HANDLER(cfg80211_wext_giwretry);\n\nstatic int __cfg80211_set_encryption(struct cfg80211_registered_device *rdev,\n\t\t\t\t     struct net_device *dev, bool pairwise,\n\t\t\t\t     const u8 *addr, bool remove, bool tx_key,\n\t\t\t\t     int idx, struct key_params *params)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint err, i;\n\tbool rejoin = false;\n\n\tif (wdev->valid_links)\n\t\treturn -EINVAL;\n\n\tif (pairwise && !addr)\n\t\treturn -EINVAL;\n\n\t \n\tif (!wdev->wext.keys) {\n\t\twdev->wext.keys = kzalloc(sizeof(*wdev->wext.keys),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!wdev->wext.keys)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\twdev->wext.keys->params[i].key =\n\t\t\t\twdev->wext.keys->data[i];\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_ADHOC &&\n\t    wdev->iftype != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (params->cipher == WLAN_CIPHER_SUITE_AES_CMAC) {\n\t\tif (!wdev->connected)\n\t\t\treturn -ENOLINK;\n\n\t\tif (!rdev->ops->set_default_mgmt_key)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (idx < 4 || idx > 5)\n\t\t\treturn -EINVAL;\n\t} else if (idx < 0 || idx > 3)\n\t\treturn -EINVAL;\n\n\tif (remove) {\n\t\terr = 0;\n\t\tif (wdev->connected ||\n\t\t    (wdev->iftype == NL80211_IFTYPE_ADHOC &&\n\t\t     wdev->u.ibss.current_bss)) {\n\t\t\t \n\t\t\tif (idx == wdev->wext.default_key &&\n\t\t\t    wdev->iftype == NL80211_IFTYPE_ADHOC) {\n\t\t\t\t__cfg80211_leave_ibss(rdev, wdev->netdev, true);\n\t\t\t\trejoin = true;\n\t\t\t}\n\n\t\t\tif (!pairwise && addr &&\n\t\t\t    !(rdev->wiphy.flags & WIPHY_FLAG_IBSS_RSN))\n\t\t\t\terr = -ENOENT;\n\t\t\telse\n\t\t\t\terr = rdev_del_key(rdev, dev, -1, idx, pairwise,\n\t\t\t\t\t\t   addr);\n\t\t}\n\t\twdev->wext.connect.privacy = false;\n\t\t \n\t\tif (err == -ENOENT)\n\t\t\terr = 0;\n\t\tif (!err) {\n\t\t\tif (!addr && idx < 4) {\n\t\t\t\tmemset(wdev->wext.keys->data[idx], 0,\n\t\t\t\t       sizeof(wdev->wext.keys->data[idx]));\n\t\t\t\twdev->wext.keys->params[idx].key_len = 0;\n\t\t\t\twdev->wext.keys->params[idx].cipher = 0;\n\t\t\t}\n\t\t\tif (idx == wdev->wext.default_key)\n\t\t\t\twdev->wext.default_key = -1;\n\t\t\telse if (idx == wdev->wext.default_mgmt_key)\n\t\t\t\twdev->wext.default_mgmt_key = -1;\n\t\t}\n\n\t\tif (!err && rejoin)\n\t\t\terr = cfg80211_ibss_wext_join(rdev, wdev);\n\n\t\treturn err;\n\t}\n\n\tif (addr)\n\t\ttx_key = false;\n\n\tif (cfg80211_validate_key_settings(rdev, params, idx, pairwise, addr))\n\t\treturn -EINVAL;\n\n\terr = 0;\n\tif (wdev->connected ||\n\t    (wdev->iftype == NL80211_IFTYPE_ADHOC &&\n\t     wdev->u.ibss.current_bss))\n\t\terr = rdev_add_key(rdev, dev, -1, idx, pairwise, addr, params);\n\telse if (params->cipher != WLAN_CIPHER_SUITE_WEP40 &&\n\t\t params->cipher != WLAN_CIPHER_SUITE_WEP104)\n\t\treturn -EINVAL;\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!addr && (params->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t\t      params->cipher == WLAN_CIPHER_SUITE_WEP104)) {\n\t\twdev->wext.keys->params[idx] = *params;\n\t\tmemcpy(wdev->wext.keys->data[idx],\n\t\t\tparams->key, params->key_len);\n\t\twdev->wext.keys->params[idx].key =\n\t\t\twdev->wext.keys->data[idx];\n\t}\n\n\tif ((params->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t     params->cipher == WLAN_CIPHER_SUITE_WEP104) &&\n\t    (tx_key || (!addr && wdev->wext.default_key == -1))) {\n\t\tif (wdev->connected ||\n\t\t    (wdev->iftype == NL80211_IFTYPE_ADHOC &&\n\t\t     wdev->u.ibss.current_bss)) {\n\t\t\t \n\t\t\tif (wdev->iftype == NL80211_IFTYPE_ADHOC &&\n\t\t\t    wdev->wext.default_key == -1) {\n\t\t\t\t__cfg80211_leave_ibss(rdev, wdev->netdev, true);\n\t\t\t\trejoin = true;\n\t\t\t}\n\t\t\terr = rdev_set_default_key(rdev, dev, -1, idx, true,\n\t\t\t\t\t\t   true);\n\t\t}\n\t\tif (!err) {\n\t\t\twdev->wext.default_key = idx;\n\t\t\tif (rejoin)\n\t\t\t\terr = cfg80211_ibss_wext_join(rdev, wdev);\n\t\t}\n\t\treturn err;\n\t}\n\n\tif (params->cipher == WLAN_CIPHER_SUITE_AES_CMAC &&\n\t    (tx_key || (!addr && wdev->wext.default_mgmt_key == -1))) {\n\t\tif (wdev->connected ||\n\t\t    (wdev->iftype == NL80211_IFTYPE_ADHOC &&\n\t\t     wdev->u.ibss.current_bss))\n\t\t\terr = rdev_set_default_mgmt_key(rdev, dev, -1, idx);\n\t\tif (!err)\n\t\t\twdev->wext.default_mgmt_key = idx;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int cfg80211_set_encryption(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct net_device *dev, bool pairwise,\n\t\t\t\t   const u8 *addr, bool remove, bool tx_key,\n\t\t\t\t   int idx, struct key_params *params)\n{\n\tint err;\n\n\twdev_lock(dev->ieee80211_ptr);\n\terr = __cfg80211_set_encryption(rdev, dev, pairwise, addr,\n\t\t\t\t\tremove, tx_key, idx, params);\n\twdev_unlock(dev->ieee80211_ptr);\n\n\treturn err;\n}\n\nstatic int cfg80211_wext_siwencode(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *keybuf)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tint idx, err;\n\tbool remove = false;\n\tstruct key_params params;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!rdev->ops->del_key ||\n\t    !rdev->ops->add_key ||\n\t    !rdev->ops->set_default_key)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy_lock(&rdev->wiphy);\n\tif (wdev->valid_links) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tidx = erq->flags & IW_ENCODE_INDEX;\n\tif (idx == 0) {\n\t\tidx = wdev->wext.default_key;\n\t\tif (idx < 0)\n\t\t\tidx = 0;\n\t} else if (idx < 1 || idx > 4) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tidx--;\n\t}\n\n\tif (erq->flags & IW_ENCODE_DISABLED)\n\t\tremove = true;\n\telse if (erq->length == 0) {\n\t\t \n\t\terr = 0;\n\t\twdev_lock(wdev);\n\t\tif (wdev->connected ||\n\t\t    (wdev->iftype == NL80211_IFTYPE_ADHOC &&\n\t\t     wdev->u.ibss.current_bss))\n\t\t\terr = rdev_set_default_key(rdev, dev, -1, idx, true,\n\t\t\t\t\t\t   true);\n\t\tif (!err)\n\t\t\twdev->wext.default_key = idx;\n\t\twdev_unlock(wdev);\n\t\tgoto out;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.key = keybuf;\n\tparams.key_len = erq->length;\n\tif (erq->length == 5) {\n\t\tparams.cipher = WLAN_CIPHER_SUITE_WEP40;\n\t} else if (erq->length == 13) {\n\t\tparams.cipher = WLAN_CIPHER_SUITE_WEP104;\n\t} else if (!remove) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = cfg80211_set_encryption(rdev, dev, false, NULL, remove,\n\t\t\t\t      wdev->wext.default_key == -1,\n\t\t\t\t      idx, &params);\nout:\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn err;\n}\n\nstatic int cfg80211_wext_siwencodeext(struct net_device *dev,\n\t\t\t\t      struct iw_request_info *info,\n\t\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *) extra;\n\tconst u8 *addr;\n\tint idx;\n\tbool remove = false;\n\tstruct key_params params;\n\tu32 cipher;\n\tint ret;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!rdev->ops->del_key ||\n\t    !rdev->ops->add_key ||\n\t    !rdev->ops->set_default_key)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\tif (wdev->valid_links) {\n\t\twdev_unlock(wdev);\n\t\treturn -EOPNOTSUPP;\n\t}\n\twdev_unlock(wdev);\n\n\tswitch (ext->alg) {\n\tcase IW_ENCODE_ALG_NONE:\n\t\tremove = true;\n\t\tcipher = 0;\n\t\tbreak;\n\tcase IW_ENCODE_ALG_WEP:\n\t\tif (ext->key_len == 5)\n\t\t\tcipher = WLAN_CIPHER_SUITE_WEP40;\n\t\telse if (ext->key_len == 13)\n\t\t\tcipher = WLAN_CIPHER_SUITE_WEP104;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IW_ENCODE_ALG_TKIP:\n\t\tcipher = WLAN_CIPHER_SUITE_TKIP;\n\t\tbreak;\n\tcase IW_ENCODE_ALG_CCMP:\n\t\tcipher = WLAN_CIPHER_SUITE_CCMP;\n\t\tbreak;\n\tcase IW_ENCODE_ALG_AES_CMAC:\n\t\tcipher = WLAN_CIPHER_SUITE_AES_CMAC;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (erq->flags & IW_ENCODE_DISABLED)\n\t\tremove = true;\n\n\tidx = erq->flags & IW_ENCODE_INDEX;\n\tif (cipher == WLAN_CIPHER_SUITE_AES_CMAC) {\n\t\tif (idx < 4 || idx > 5) {\n\t\t\tidx = wdev->wext.default_mgmt_key;\n\t\t\tif (idx < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else\n\t\t\tidx--;\n\t} else {\n\t\tif (idx < 1 || idx > 4) {\n\t\t\tidx = wdev->wext.default_key;\n\t\t\tif (idx < 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else\n\t\t\tidx--;\n\t}\n\n\taddr = ext->addr.sa_data;\n\tif (is_broadcast_ether_addr(addr))\n\t\taddr = NULL;\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.key = ext->key;\n\tparams.key_len = ext->key_len;\n\tparams.cipher = cipher;\n\n\tif (ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {\n\t\tparams.seq = ext->rx_seq;\n\t\tparams.seq_len = 6;\n\t}\n\n\twiphy_lock(wdev->wiphy);\n\tret = cfg80211_set_encryption(\n\t\t\trdev, dev,\n\t\t\t!(ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY),\n\t\t\taddr, remove,\n\t\t\text->ext_flags & IW_ENCODE_EXT_SET_TX_KEY,\n\t\t\tidx, &params);\n\twiphy_unlock(wdev->wiphy);\n\n\treturn ret;\n}\n\nstatic int cfg80211_wext_giwencode(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *keybuf)\n{\n\tstruct iw_point *erq = &wrqu->encoding;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint idx;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION &&\n\t    wdev->iftype != NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\tidx = erq->flags & IW_ENCODE_INDEX;\n\tif (idx == 0) {\n\t\tidx = wdev->wext.default_key;\n\t\tif (idx < 0)\n\t\t\tidx = 0;\n\t} else if (idx < 1 || idx > 4)\n\t\treturn -EINVAL;\n\telse\n\t\tidx--;\n\n\terq->flags = idx + 1;\n\n\tif (!wdev->wext.keys || !wdev->wext.keys->params[idx].cipher) {\n\t\terq->flags |= IW_ENCODE_DISABLED;\n\t\terq->length = 0;\n\t\treturn 0;\n\t}\n\n\terq->length = min_t(size_t, erq->length,\n\t\t\t    wdev->wext.keys->params[idx].key_len);\n\tmemcpy(keybuf, wdev->wext.keys->params[idx].key, erq->length);\n\terq->flags |= IW_ENCODE_ENABLED;\n\n\treturn 0;\n}\n\nstatic int cfg80211_wext_siwfreq(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_freq *wextfreq = &wrqu->freq;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_chan_def chandef = {\n\t\t.width = NL80211_CHAN_WIDTH_20_NOHT,\n\t};\n\tint freq, ret;\n\n\twiphy_lock(&rdev->wiphy);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tret = cfg80211_mgd_wext_siwfreq(dev, info, wextfreq, extra);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tret = cfg80211_ibss_wext_siwfreq(dev, info, wextfreq, extra);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tfreq = cfg80211_wext_freq(wextfreq);\n\t\tif (freq < 0) {\n\t\t\tret = freq;\n\t\t\tbreak;\n\t\t}\n\t\tif (freq == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tchandef.center_freq1 = freq;\n\t\tchandef.chan = ieee80211_get_channel(&rdev->wiphy, freq);\n\t\tif (!chandef.chan) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = cfg80211_set_monitor_channel(rdev, &chandef);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tfreq = cfg80211_wext_freq(wextfreq);\n\t\tif (freq < 0) {\n\t\t\tret = freq;\n\t\t\tbreak;\n\t\t}\n\t\tif (freq == 0) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tchandef.center_freq1 = freq;\n\t\tchandef.chan = ieee80211_get_channel(&rdev->wiphy, freq);\n\t\tif (!chandef.chan) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = cfg80211_set_mesh_channel(rdev, wdev, &chandef);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn ret;\n}\n\nstatic int cfg80211_wext_giwfreq(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_freq *freq = &wrqu->freq;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_chan_def chandef = {};\n\tint ret;\n\n\twiphy_lock(&rdev->wiphy);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tret = cfg80211_mgd_wext_giwfreq(dev, info, freq, extra);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tret = cfg80211_ibss_wext_giwfreq(dev, info, freq, extra);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (!rdev->ops->get_channel) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rdev_get_channel(rdev, wdev, 0, &chandef);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tfreq->m = chandef.chan->center_freq;\n\t\tfreq->e = 6;\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn ret;\n}\n\nstatic int cfg80211_wext_siwtxpower(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *data, char *extra)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tenum nl80211_tx_power_setting type;\n\tint dbm = 0;\n\tint ret;\n\n\tif ((data->txpower.flags & IW_TXPOW_TYPE) != IW_TXPOW_DBM)\n\t\treturn -EINVAL;\n\tif (data->txpower.flags & IW_TXPOW_RANGE)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_tx_power)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!data->txpower.disabled) {\n\t\trfkill_set_sw_state(rdev->wiphy.rfkill, false);\n\n\t\tif (data->txpower.fixed) {\n\t\t\t \n\t\t\tif (data->txpower.value < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tdbm = data->txpower.value;\n\t\t\ttype = NL80211_TX_POWER_FIXED;\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tif (data->txpower.value < 0) {\n\t\t\t\ttype = NL80211_TX_POWER_AUTOMATIC;\n\t\t\t} else {\n\t\t\t\tdbm = data->txpower.value;\n\t\t\t\ttype = NL80211_TX_POWER_LIMITED;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (rfkill_set_sw_state(rdev->wiphy.rfkill, true))\n\t\t\tschedule_work(&rdev->rfkill_block);\n\t\treturn 0;\n\t}\n\n\twiphy_lock(&rdev->wiphy);\n\tret = rdev_set_tx_power(rdev, wdev, type, DBM_TO_MBM(dbm));\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn ret;\n}\n\nstatic int cfg80211_wext_giwtxpower(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *data, char *extra)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tint err, val;\n\n\tif ((data->txpower.flags & IW_TXPOW_TYPE) != IW_TXPOW_DBM)\n\t\treturn -EINVAL;\n\tif (data->txpower.flags & IW_TXPOW_RANGE)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->get_tx_power)\n\t\treturn -EOPNOTSUPP;\n\n\twiphy_lock(&rdev->wiphy);\n\terr = rdev_get_tx_power(rdev, wdev, &val);\n\twiphy_unlock(&rdev->wiphy);\n\tif (err)\n\t\treturn err;\n\n\t \n\tdata->txpower.fixed = 1;\n\tdata->txpower.disabled = rfkill_blocked(rdev->wiphy.rfkill);\n\tdata->txpower.value = val;\n\tdata->txpower.flags = IW_TXPOW_DBM;\n\n\treturn 0;\n}\n\nstatic int cfg80211_set_auth_alg(struct wireless_dev *wdev,\n\t\t\t\t s32 auth_alg)\n{\n\tint nr_alg = 0;\n\n\tif (!auth_alg)\n\t\treturn -EINVAL;\n\n\tif (auth_alg & ~(IW_AUTH_ALG_OPEN_SYSTEM |\n\t\t\t IW_AUTH_ALG_SHARED_KEY |\n\t\t\t IW_AUTH_ALG_LEAP))\n\t\treturn -EINVAL;\n\n\tif (auth_alg & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\tnr_alg++;\n\t\twdev->wext.connect.auth_type = NL80211_AUTHTYPE_OPEN_SYSTEM;\n\t}\n\n\tif (auth_alg & IW_AUTH_ALG_SHARED_KEY) {\n\t\tnr_alg++;\n\t\twdev->wext.connect.auth_type = NL80211_AUTHTYPE_SHARED_KEY;\n\t}\n\n\tif (auth_alg & IW_AUTH_ALG_LEAP) {\n\t\tnr_alg++;\n\t\twdev->wext.connect.auth_type = NL80211_AUTHTYPE_NETWORK_EAP;\n\t}\n\n\tif (nr_alg > 1)\n\t\twdev->wext.connect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;\n\n\treturn 0;\n}\n\nstatic int cfg80211_set_wpa_version(struct wireless_dev *wdev, u32 wpa_versions)\n{\n\tif (wpa_versions & ~(IW_AUTH_WPA_VERSION_WPA |\n\t\t\t     IW_AUTH_WPA_VERSION_WPA2|\n\t\t             IW_AUTH_WPA_VERSION_DISABLED))\n\t\treturn -EINVAL;\n\n\tif ((wpa_versions & IW_AUTH_WPA_VERSION_DISABLED) &&\n\t    (wpa_versions & (IW_AUTH_WPA_VERSION_WPA|\n\t\t\t     IW_AUTH_WPA_VERSION_WPA2)))\n\t\treturn -EINVAL;\n\n\tif (wpa_versions & IW_AUTH_WPA_VERSION_DISABLED)\n\t\twdev->wext.connect.crypto.wpa_versions &=\n\t\t\t~(NL80211_WPA_VERSION_1|NL80211_WPA_VERSION_2);\n\n\tif (wpa_versions & IW_AUTH_WPA_VERSION_WPA)\n\t\twdev->wext.connect.crypto.wpa_versions |=\n\t\t\tNL80211_WPA_VERSION_1;\n\n\tif (wpa_versions & IW_AUTH_WPA_VERSION_WPA2)\n\t\twdev->wext.connect.crypto.wpa_versions |=\n\t\t\tNL80211_WPA_VERSION_2;\n\n\treturn 0;\n}\n\nstatic int cfg80211_set_cipher_group(struct wireless_dev *wdev, u32 cipher)\n{\n\tif (cipher & IW_AUTH_CIPHER_WEP40)\n\t\twdev->wext.connect.crypto.cipher_group =\n\t\t\tWLAN_CIPHER_SUITE_WEP40;\n\telse if (cipher & IW_AUTH_CIPHER_WEP104)\n\t\twdev->wext.connect.crypto.cipher_group =\n\t\t\tWLAN_CIPHER_SUITE_WEP104;\n\telse if (cipher & IW_AUTH_CIPHER_TKIP)\n\t\twdev->wext.connect.crypto.cipher_group =\n\t\t\tWLAN_CIPHER_SUITE_TKIP;\n\telse if (cipher & IW_AUTH_CIPHER_CCMP)\n\t\twdev->wext.connect.crypto.cipher_group =\n\t\t\tWLAN_CIPHER_SUITE_CCMP;\n\telse if (cipher & IW_AUTH_CIPHER_AES_CMAC)\n\t\twdev->wext.connect.crypto.cipher_group =\n\t\t\tWLAN_CIPHER_SUITE_AES_CMAC;\n\telse if (cipher & IW_AUTH_CIPHER_NONE)\n\t\twdev->wext.connect.crypto.cipher_group = 0;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cfg80211_set_cipher_pairwise(struct wireless_dev *wdev, u32 cipher)\n{\n\tint nr_ciphers = 0;\n\tu32 *ciphers_pairwise = wdev->wext.connect.crypto.ciphers_pairwise;\n\n\tif (cipher & IW_AUTH_CIPHER_WEP40) {\n\t\tciphers_pairwise[nr_ciphers] = WLAN_CIPHER_SUITE_WEP40;\n\t\tnr_ciphers++;\n\t}\n\n\tif (cipher & IW_AUTH_CIPHER_WEP104) {\n\t\tciphers_pairwise[nr_ciphers] = WLAN_CIPHER_SUITE_WEP104;\n\t\tnr_ciphers++;\n\t}\n\n\tif (cipher & IW_AUTH_CIPHER_TKIP) {\n\t\tciphers_pairwise[nr_ciphers] = WLAN_CIPHER_SUITE_TKIP;\n\t\tnr_ciphers++;\n\t}\n\n\tif (cipher & IW_AUTH_CIPHER_CCMP) {\n\t\tciphers_pairwise[nr_ciphers] = WLAN_CIPHER_SUITE_CCMP;\n\t\tnr_ciphers++;\n\t}\n\n\tif (cipher & IW_AUTH_CIPHER_AES_CMAC) {\n\t\tciphers_pairwise[nr_ciphers] = WLAN_CIPHER_SUITE_AES_CMAC;\n\t\tnr_ciphers++;\n\t}\n\n\tBUILD_BUG_ON(NL80211_MAX_NR_CIPHER_SUITES < 5);\n\n\twdev->wext.connect.crypto.n_ciphers_pairwise = nr_ciphers;\n\n\treturn 0;\n}\n\n\nstatic int cfg80211_set_key_mgt(struct wireless_dev *wdev, u32 key_mgt)\n{\n\tint nr_akm_suites = 0;\n\n\tif (key_mgt & ~(IW_AUTH_KEY_MGMT_802_1X |\n\t\t\tIW_AUTH_KEY_MGMT_PSK))\n\t\treturn -EINVAL;\n\n\tif (key_mgt & IW_AUTH_KEY_MGMT_802_1X) {\n\t\twdev->wext.connect.crypto.akm_suites[nr_akm_suites] =\n\t\t\tWLAN_AKM_SUITE_8021X;\n\t\tnr_akm_suites++;\n\t}\n\n\tif (key_mgt & IW_AUTH_KEY_MGMT_PSK) {\n\t\twdev->wext.connect.crypto.akm_suites[nr_akm_suites] =\n\t\t\tWLAN_AKM_SUITE_PSK;\n\t\tnr_akm_suites++;\n\t}\n\n\twdev->wext.connect.crypto.n_akm_suites = nr_akm_suites;\n\n\treturn 0;\n}\n\nstatic int cfg80211_wext_siwauth(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *data = &wrqu->param;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (data->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\twdev->wext.connect.privacy = data->value;\n\t\treturn 0;\n\tcase IW_AUTH_WPA_VERSION:\n\t\treturn cfg80211_set_wpa_version(wdev, data->value);\n\tcase IW_AUTH_CIPHER_GROUP:\n\t\treturn cfg80211_set_cipher_group(wdev, data->value);\n\tcase IW_AUTH_KEY_MGMT:\n\t\treturn cfg80211_set_key_mgt(wdev, data->value);\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\t\treturn cfg80211_set_cipher_pairwise(wdev, data->value);\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\treturn cfg80211_set_auth_alg(wdev, data->value);\n\tcase IW_AUTH_WPA_ENABLED:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\tcase IW_AUTH_MFP:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int cfg80211_wext_giwauth(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int cfg80211_wext_siwpower(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *wrq = &wrqu->power;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tbool ps;\n\tint timeout = wdev->ps_timeout;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION)\n\t\treturn -EINVAL;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wrq->disabled) {\n\t\tps = false;\n\t} else {\n\t\tswitch (wrq->flags & IW_POWER_MODE) {\n\t\tcase IW_POWER_ON:        \n\t\tcase IW_POWER_MODE:      \n\t\tcase IW_POWER_ALL_R:     \n\t\t\tps = true;\n\t\t\tbreak;\n\t\tdefault:                 \n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (wrq->flags & ~(IW_POWER_MODE | IW_POWER_TIMEOUT))\n\t\t\treturn -EINVAL;\n\n\t\tif (wrq->flags & IW_POWER_TIMEOUT)\n\t\t\ttimeout = wrq->value / 1000;\n\t}\n\n\twiphy_lock(&rdev->wiphy);\n\terr = rdev_set_power_mgmt(rdev, dev, ps, timeout);\n\twiphy_unlock(&rdev->wiphy);\n\tif (err)\n\t\treturn err;\n\n\twdev->ps = ps;\n\twdev->ps_timeout = timeout;\n\n\treturn 0;\n\n}\n\nstatic int cfg80211_wext_giwpower(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *wrq = &wrqu->power;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\twrq->disabled = !wdev->ps;\n\n\treturn 0;\n}\n\nstatic int cfg80211_wext_siwrate(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rate = &wrqu->bitrate;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_bitrate_mask mask;\n\tu32 fixed, maxrate;\n\tstruct ieee80211_supported_band *sband;\n\tint band, ridx, ret;\n\tbool match = false;\n\n\tif (!rdev->ops->set_bitrate_mask)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&mask, 0, sizeof(mask));\n\tfixed = 0;\n\tmaxrate = (u32)-1;\n\n\tif (rate->value < 0) {\n\t\t \n\t} else if (rate->fixed) {\n\t\tfixed = rate->value / 100000;\n\t} else {\n\t\tmaxrate = rate->value / 100000;\n\t}\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tsband = wdev->wiphy->bands[band];\n\t\tif (sband == NULL)\n\t\t\tcontinue;\n\t\tfor (ridx = 0; ridx < sband->n_bitrates; ridx++) {\n\t\t\tstruct ieee80211_rate *srate = &sband->bitrates[ridx];\n\t\t\tif (fixed == srate->bitrate) {\n\t\t\t\tmask.control[band].legacy = 1 << ridx;\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (srate->bitrate <= maxrate) {\n\t\t\t\tmask.control[band].legacy |= 1 << ridx;\n\t\t\t\tmatch = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!match)\n\t\treturn -EINVAL;\n\n\twiphy_lock(&rdev->wiphy);\n\tif (dev->ieee80211_ptr->valid_links)\n\t\tret = -EOPNOTSUPP;\n\telse\n\t\tret = rdev_set_bitrate_mask(rdev, dev, 0, NULL, &mask);\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn ret;\n}\n\nstatic int cfg80211_wext_giwrate(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_param *rate = &wrqu->bitrate;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct station_info sinfo = {};\n\tu8 addr[ETH_ALEN];\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdev->ops->get_station)\n\t\treturn -EOPNOTSUPP;\n\n\terr = 0;\n\twdev_lock(wdev);\n\tif (!wdev->valid_links && wdev->links[0].client.current_bss)\n\t\tmemcpy(addr, wdev->links[0].client.current_bss->pub.bssid,\n\t\t       ETH_ALEN);\n\telse\n\t\terr = -EOPNOTSUPP;\n\twdev_unlock(wdev);\n\tif (err)\n\t\treturn err;\n\n\twiphy_lock(&rdev->wiphy);\n\terr = rdev_get_station(rdev, dev, addr, &sinfo);\n\twiphy_unlock(&rdev->wiphy);\n\tif (err)\n\t\treturn err;\n\n\tif (!(sinfo.filled & BIT_ULL(NL80211_STA_INFO_TX_BITRATE))) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto free;\n\t}\n\n\trate->value = 100000 * cfg80211_calculate_bitrate(&sinfo.txrate);\n\nfree:\n\tcfg80211_sinfo_release_content(&sinfo);\n\treturn err;\n}\n\n \nstatic struct iw_statistics *cfg80211_wireless_stats(struct net_device *dev)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\t \n\tstatic struct iw_statistics wstats;\n\tstatic struct station_info sinfo = {};\n\tu8 bssid[ETH_ALEN];\n\tint ret;\n\n\tif (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_STATION)\n\t\treturn NULL;\n\n\tif (!rdev->ops->get_station)\n\t\treturn NULL;\n\n\t \n\twdev_lock(wdev);\n\tif (wdev->valid_links || !wdev->links[0].client.current_bss) {\n\t\twdev_unlock(wdev);\n\t\treturn NULL;\n\t}\n\tmemcpy(bssid, wdev->links[0].client.current_bss->pub.bssid, ETH_ALEN);\n\twdev_unlock(wdev);\n\n\tmemset(&sinfo, 0, sizeof(sinfo));\n\n\twiphy_lock(&rdev->wiphy);\n\tret = rdev_get_station(rdev, dev, bssid, &sinfo);\n\twiphy_unlock(&rdev->wiphy);\n\n\tif (ret)\n\t\treturn NULL;\n\n\tmemset(&wstats, 0, sizeof(wstats));\n\n\tswitch (rdev->wiphy.signal_type) {\n\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\tif (sinfo.filled & BIT_ULL(NL80211_STA_INFO_SIGNAL)) {\n\t\t\tint sig = sinfo.signal;\n\t\t\twstats.qual.updated |= IW_QUAL_LEVEL_UPDATED;\n\t\t\twstats.qual.updated |= IW_QUAL_QUAL_UPDATED;\n\t\t\twstats.qual.updated |= IW_QUAL_DBM;\n\t\t\twstats.qual.level = sig;\n\t\t\tif (sig < -110)\n\t\t\t\tsig = -110;\n\t\t\telse if (sig > -40)\n\t\t\t\tsig = -40;\n\t\t\twstats.qual.qual = sig + 110;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase CFG80211_SIGNAL_TYPE_UNSPEC:\n\t\tif (sinfo.filled & BIT_ULL(NL80211_STA_INFO_SIGNAL)) {\n\t\t\twstats.qual.updated |= IW_QUAL_LEVEL_UPDATED;\n\t\t\twstats.qual.updated |= IW_QUAL_QUAL_UPDATED;\n\t\t\twstats.qual.level = sinfo.signal;\n\t\t\twstats.qual.qual = sinfo.signal;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\twstats.qual.updated |= IW_QUAL_LEVEL_INVALID;\n\t\twstats.qual.updated |= IW_QUAL_QUAL_INVALID;\n\t}\n\n\twstats.qual.updated |= IW_QUAL_NOISE_INVALID;\n\tif (sinfo.filled & BIT_ULL(NL80211_STA_INFO_RX_DROP_MISC))\n\t\twstats.discard.misc = sinfo.rx_dropped_misc;\n\tif (sinfo.filled & BIT_ULL(NL80211_STA_INFO_TX_FAILED))\n\t\twstats.discard.retries = sinfo.tx_failed;\n\n\tcfg80211_sinfo_release_content(&sinfo);\n\n\treturn &wstats;\n}\n\nstatic int cfg80211_wext_siwap(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct sockaddr *ap_addr = &wrqu->ap_addr;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tint ret;\n\n\twiphy_lock(&rdev->wiphy);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tret = cfg80211_ibss_wext_siwap(dev, info, ap_addr, extra);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tret = cfg80211_mgd_wext_siwap(dev, info, ap_addr, extra);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn ret;\n}\n\nstatic int cfg80211_wext_giwap(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct sockaddr *ap_addr = &wrqu->ap_addr;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tint ret;\n\n\twiphy_lock(&rdev->wiphy);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tret = cfg80211_ibss_wext_giwap(dev, info, ap_addr, extra);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tret = cfg80211_mgd_wext_giwap(dev, info, ap_addr, extra);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn ret;\n}\n\nstatic int cfg80211_wext_siwessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *ssid)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tint ret;\n\n\twiphy_lock(&rdev->wiphy);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tret = cfg80211_ibss_wext_siwessid(dev, info, data, ssid);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tret = cfg80211_mgd_wext_siwessid(dev, info, data, ssid);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn ret;\n}\n\nstatic int cfg80211_wext_giwessid(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *ssid)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tint ret;\n\n\tdata->flags = 0;\n\tdata->length = 0;\n\n\twiphy_lock(&rdev->wiphy);\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tret = cfg80211_ibss_wext_giwessid(dev, info, data, ssid);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tret = cfg80211_mgd_wext_giwessid(dev, info, data, ssid);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn ret;\n}\n\nstatic int cfg80211_wext_siwpmksa(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct cfg80211_pmksa cfg_pmksa;\n\tstruct iw_pmksa *pmksa = (struct iw_pmksa *)extra;\n\tint ret;\n\n\tmemset(&cfg_pmksa, 0, sizeof(struct cfg80211_pmksa));\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION)\n\t\treturn -EINVAL;\n\n\tcfg_pmksa.bssid = pmksa->bssid.sa_data;\n\tcfg_pmksa.pmkid = pmksa->pmkid;\n\n\twiphy_lock(&rdev->wiphy);\n\tswitch (pmksa->cmd) {\n\tcase IW_PMKSA_ADD:\n\t\tif (!rdev->ops->set_pmksa) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rdev_set_pmksa(rdev, dev, &cfg_pmksa);\n\t\tbreak;\n\tcase IW_PMKSA_REMOVE:\n\t\tif (!rdev->ops->del_pmksa) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rdev_del_pmksa(rdev, dev, &cfg_pmksa);\n\t\tbreak;\n\tcase IW_PMKSA_FLUSH:\n\t\tif (!rdev->ops->flush_pmksa) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = rdev_flush_pmksa(rdev, dev);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn ret;\n}\n\nstatic const iw_handler cfg80211_handlers[] = {\n\tIW_HANDLER(SIOCGIWNAME,\t\tcfg80211_wext_giwname),\n\tIW_HANDLER(SIOCSIWFREQ,\t\tcfg80211_wext_siwfreq),\n\tIW_HANDLER(SIOCGIWFREQ,\t\tcfg80211_wext_giwfreq),\n\tIW_HANDLER(SIOCSIWMODE,\t\tcfg80211_wext_siwmode),\n\tIW_HANDLER(SIOCGIWMODE,\t\tcfg80211_wext_giwmode),\n\tIW_HANDLER(SIOCGIWRANGE,\tcfg80211_wext_giwrange),\n\tIW_HANDLER(SIOCSIWAP,\t\tcfg80211_wext_siwap),\n\tIW_HANDLER(SIOCGIWAP,\t\tcfg80211_wext_giwap),\n\tIW_HANDLER(SIOCSIWMLME,\t\tcfg80211_wext_siwmlme),\n\tIW_HANDLER(SIOCSIWSCAN,\t\tcfg80211_wext_siwscan),\n\tIW_HANDLER(SIOCGIWSCAN,\t\tcfg80211_wext_giwscan),\n\tIW_HANDLER(SIOCSIWESSID,\tcfg80211_wext_siwessid),\n\tIW_HANDLER(SIOCGIWESSID,\tcfg80211_wext_giwessid),\n\tIW_HANDLER(SIOCSIWRATE,\t\tcfg80211_wext_siwrate),\n\tIW_HANDLER(SIOCGIWRATE,\t\tcfg80211_wext_giwrate),\n\tIW_HANDLER(SIOCSIWRTS,\t\tcfg80211_wext_siwrts),\n\tIW_HANDLER(SIOCGIWRTS,\t\tcfg80211_wext_giwrts),\n\tIW_HANDLER(SIOCSIWFRAG,\t\tcfg80211_wext_siwfrag),\n\tIW_HANDLER(SIOCGIWFRAG,\t\tcfg80211_wext_giwfrag),\n\tIW_HANDLER(SIOCSIWTXPOW,\tcfg80211_wext_siwtxpower),\n\tIW_HANDLER(SIOCGIWTXPOW,\tcfg80211_wext_giwtxpower),\n\tIW_HANDLER(SIOCSIWRETRY,\tcfg80211_wext_siwretry),\n\tIW_HANDLER(SIOCGIWRETRY,\tcfg80211_wext_giwretry),\n\tIW_HANDLER(SIOCSIWENCODE,\tcfg80211_wext_siwencode),\n\tIW_HANDLER(SIOCGIWENCODE,\tcfg80211_wext_giwencode),\n\tIW_HANDLER(SIOCSIWPOWER,\tcfg80211_wext_siwpower),\n\tIW_HANDLER(SIOCGIWPOWER,\tcfg80211_wext_giwpower),\n\tIW_HANDLER(SIOCSIWGENIE,\tcfg80211_wext_siwgenie),\n\tIW_HANDLER(SIOCSIWAUTH,\t\tcfg80211_wext_siwauth),\n\tIW_HANDLER(SIOCGIWAUTH,\t\tcfg80211_wext_giwauth),\n\tIW_HANDLER(SIOCSIWENCODEEXT,\tcfg80211_wext_siwencodeext),\n\tIW_HANDLER(SIOCSIWPMKSA,\tcfg80211_wext_siwpmksa),\n};\n\nconst struct iw_handler_def cfg80211_wext_handler = {\n\t.num_standard\t\t= ARRAY_SIZE(cfg80211_handlers),\n\t.standard\t\t= cfg80211_handlers,\n\t.get_wireless_stats = cfg80211_wireless_stats,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}