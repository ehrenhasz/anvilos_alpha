{
  "module_name": "scan.c",
  "hash_id": "bf47ebf2e2b48a4196ba3f32b1977111d2cdce2ad17fd7ec84e72d6cc39ed31c",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/scan.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/wireless.h>\n#include <linux/nl80211.h>\n#include <linux/etherdevice.h>\n#include <linux/crc32.h>\n#include <linux/bitfield.h>\n#include <net/arp.h>\n#include <net/cfg80211.h>\n#include <net/cfg80211-wext.h>\n#include <net/iw_handler.h>\n#include \"core.h\"\n#include \"nl80211.h\"\n#include \"wext-compat.h\"\n#include \"rdev-ops.h\"\n\n \n\n \nstatic int bss_entries_limit = 1000;\nmodule_param(bss_entries_limit, int, 0644);\nMODULE_PARM_DESC(bss_entries_limit,\n                 \"limit to number of scan BSS entries (per wiphy, default 1000)\");\n\n#define IEEE80211_SCAN_RESULT_EXPIRE\t(30 * HZ)\n\n \nstruct cfg80211_colocated_ap {\n\tstruct list_head list;\n\tu8 bssid[ETH_ALEN];\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tsize_t ssid_len;\n\tu32 short_ssid;\n\tu32 center_freq;\n\tu8 unsolicited_probe:1,\n\t   oct_recommended:1,\n\t   same_ssid:1,\n\t   multi_bss:1,\n\t   transmitted_bssid:1,\n\t   colocated_ess:1,\n\t   short_ssid_valid:1;\n\ts8 psd_20;\n};\n\nstatic void bss_free(struct cfg80211_internal_bss *bss)\n{\n\tstruct cfg80211_bss_ies *ies;\n\n\tif (WARN_ON(atomic_read(&bss->hold)))\n\t\treturn;\n\n\ties = (void *)rcu_access_pointer(bss->pub.beacon_ies);\n\tif (ies && !bss->pub.hidden_beacon_bss)\n\t\tkfree_rcu(ies, rcu_head);\n\ties = (void *)rcu_access_pointer(bss->pub.proberesp_ies);\n\tif (ies)\n\t\tkfree_rcu(ies, rcu_head);\n\n\t \n\tif (!list_empty(&bss->hidden_list))\n\t\tlist_del(&bss->hidden_list);\n\n\tkfree(bss);\n}\n\nstatic inline void bss_ref_get(struct cfg80211_registered_device *rdev,\n\t\t\t       struct cfg80211_internal_bss *bss)\n{\n\tlockdep_assert_held(&rdev->bss_lock);\n\n\tbss->refcount++;\n\n\tif (bss->pub.hidden_beacon_bss)\n\t\tbss_from_pub(bss->pub.hidden_beacon_bss)->refcount++;\n\n\tif (bss->pub.transmitted_bss)\n\t\tbss_from_pub(bss->pub.transmitted_bss)->refcount++;\n}\n\nstatic inline void bss_ref_put(struct cfg80211_registered_device *rdev,\n\t\t\t       struct cfg80211_internal_bss *bss)\n{\n\tlockdep_assert_held(&rdev->bss_lock);\n\n\tif (bss->pub.hidden_beacon_bss) {\n\t\tstruct cfg80211_internal_bss *hbss;\n\n\t\thbss = bss_from_pub(bss->pub.hidden_beacon_bss);\n\t\thbss->refcount--;\n\t\tif (hbss->refcount == 0)\n\t\t\tbss_free(hbss);\n\t}\n\n\tif (bss->pub.transmitted_bss) {\n\t\tstruct cfg80211_internal_bss *tbss;\n\n\t\ttbss = bss_from_pub(bss->pub.transmitted_bss);\n\t\ttbss->refcount--;\n\t\tif (tbss->refcount == 0)\n\t\t\tbss_free(tbss);\n\t}\n\n\tbss->refcount--;\n\tif (bss->refcount == 0)\n\t\tbss_free(bss);\n}\n\nstatic bool __cfg80211_unlink_bss(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct cfg80211_internal_bss *bss)\n{\n\tlockdep_assert_held(&rdev->bss_lock);\n\n\tif (!list_empty(&bss->hidden_list)) {\n\t\t \n\t\tif (!bss->pub.hidden_beacon_bss)\n\t\t\treturn false;\n\t\t \n\t\tlist_del_init(&bss->hidden_list);\n\t}\n\n\tlist_del_init(&bss->list);\n\tlist_del_init(&bss->pub.nontrans_list);\n\trb_erase(&bss->rbn, &rdev->bss_tree);\n\trdev->bss_entries--;\n\tWARN_ONCE((rdev->bss_entries == 0) ^ list_empty(&rdev->bss_list),\n\t\t  \"rdev bss entries[%d]/list[empty:%d] corruption\\n\",\n\t\t  rdev->bss_entries, list_empty(&rdev->bss_list));\n\tbss_ref_put(rdev, bss);\n\treturn true;\n}\n\nbool cfg80211_is_element_inherited(const struct element *elem,\n\t\t\t\t   const struct element *non_inherit_elem)\n{\n\tu8 id_len, ext_id_len, i, loop_len, id;\n\tconst u8 *list;\n\n\tif (elem->id == WLAN_EID_MULTIPLE_BSSID)\n\t\treturn false;\n\n\tif (elem->id == WLAN_EID_EXTENSION && elem->datalen > 1 &&\n\t    elem->data[0] == WLAN_EID_EXT_EHT_MULTI_LINK)\n\t\treturn false;\n\n\tif (!non_inherit_elem || non_inherit_elem->datalen < 2)\n\t\treturn true;\n\n\t \n\tid_len = non_inherit_elem->data[1];\n\tif (non_inherit_elem->datalen < 3 + id_len)\n\t\treturn true;\n\n\text_id_len = non_inherit_elem->data[2 + id_len];\n\tif (non_inherit_elem->datalen < 3 + id_len + ext_id_len)\n\t\treturn true;\n\n\tif (elem->id == WLAN_EID_EXTENSION) {\n\t\tif (!ext_id_len)\n\t\t\treturn true;\n\t\tloop_len = ext_id_len;\n\t\tlist = &non_inherit_elem->data[3 + id_len];\n\t\tid = elem->data[0];\n\t} else {\n\t\tif (!id_len)\n\t\t\treturn true;\n\t\tloop_len = id_len;\n\t\tlist = &non_inherit_elem->data[2];\n\t\tid = elem->id;\n\t}\n\n\tfor (i = 0; i < loop_len; i++) {\n\t\tif (list[i] == id)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(cfg80211_is_element_inherited);\n\nstatic size_t cfg80211_copy_elem_with_frags(const struct element *elem,\n\t\t\t\t\t    const u8 *ie, size_t ie_len,\n\t\t\t\t\t    u8 **pos, u8 *buf, size_t buf_len)\n{\n\tif (WARN_ON((u8 *)elem < ie || elem->data > ie + ie_len ||\n\t\t    elem->data + elem->datalen > ie + ie_len))\n\t\treturn 0;\n\n\tif (elem->datalen + 2 > buf + buf_len - *pos)\n\t\treturn 0;\n\n\tmemcpy(*pos, elem, elem->datalen + 2);\n\t*pos += elem->datalen + 2;\n\n\t \n\tif (elem->datalen != 255)\n\t\treturn *pos - buf;\n\n\tie_len = ie + ie_len - elem->data - elem->datalen;\n\tie = (const u8 *)elem->data + elem->datalen;\n\n\tfor_each_element(elem, ie, ie_len) {\n\t\tif (elem->id != WLAN_EID_FRAGMENT)\n\t\t\tbreak;\n\n\t\tif (elem->datalen + 2 > buf + buf_len - *pos)\n\t\t\treturn 0;\n\n\t\tmemcpy(*pos, elem, elem->datalen + 2);\n\t\t*pos += elem->datalen + 2;\n\n\t\tif (elem->datalen != 255)\n\t\t\tbreak;\n\t}\n\n\treturn *pos - buf;\n}\n\nstatic size_t cfg80211_gen_new_ie(const u8 *ie, size_t ielen,\n\t\t\t\t  const u8 *subie, size_t subie_len,\n\t\t\t\t  u8 *new_ie, size_t new_ie_len)\n{\n\tconst struct element *non_inherit_elem, *parent, *sub;\n\tu8 *pos = new_ie;\n\tu8 id, ext_id;\n\tunsigned int match_len;\n\n\tnon_inherit_elem = cfg80211_find_ext_elem(WLAN_EID_EXT_NON_INHERITANCE,\n\t\t\t\t\t\t  subie, subie_len);\n\n\t \n\tfor_each_element(parent, ie, ielen) {\n\t\tif (parent->id == WLAN_EID_FRAGMENT)\n\t\t\tcontinue;\n\n\t\tif (parent->id == WLAN_EID_EXTENSION) {\n\t\t\tif (parent->datalen < 1)\n\t\t\t\tcontinue;\n\n\t\t\tid = WLAN_EID_EXTENSION;\n\t\t\text_id = parent->data[0];\n\t\t\tmatch_len = 1;\n\t\t} else {\n\t\t\tid = parent->id;\n\t\t\tmatch_len = 0;\n\t\t}\n\n\t\t \n\t\tsub = cfg80211_find_elem_match(id, subie, subie_len,\n\t\t\t\t\t       &ext_id, match_len, 0);\n\n\t\t \n\t\tif (!sub &&\n\t\t    cfg80211_is_element_inherited(parent, non_inherit_elem)) {\n\t\t\tif (!cfg80211_copy_elem_with_frags(parent,\n\t\t\t\t\t\t\t   ie, ielen,\n\t\t\t\t\t\t\t   &pos, new_ie,\n\t\t\t\t\t\t\t   new_ie_len))\n\t\t\t\treturn 0;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (cfg80211_find_elem_match(id, ie, (u8 *)parent - ie,\n\t\t\t\t\t     &ext_id, match_len, 0))\n\t\t\tcontinue;\n\n\t\t \n\t\twhile (sub) {\n\t\t\tif (!cfg80211_copy_elem_with_frags(sub,\n\t\t\t\t\t\t\t   subie, subie_len,\n\t\t\t\t\t\t\t   &pos, new_ie,\n\t\t\t\t\t\t\t   new_ie_len))\n\t\t\t\treturn 0;\n\n\t\t\tsub = cfg80211_find_elem_match(id,\n\t\t\t\t\t\t       sub->data + sub->datalen,\n\t\t\t\t\t\t       subie_len + subie -\n\t\t\t\t\t\t       (sub->data +\n\t\t\t\t\t\t\tsub->datalen),\n\t\t\t\t\t\t       &ext_id, match_len, 0);\n\t\t}\n\t}\n\n\t \n\tfor_each_element(sub, subie, subie_len) {\n\t\tif (sub->id == WLAN_EID_NON_TX_BSSID_CAP)\n\t\t\tcontinue;\n\n\t\tif (sub->id == WLAN_EID_FRAGMENT)\n\t\t\tcontinue;\n\n\t\tif (sub->id == WLAN_EID_EXTENSION) {\n\t\t\tif (sub->datalen < 1)\n\t\t\t\tcontinue;\n\n\t\t\tid = WLAN_EID_EXTENSION;\n\t\t\text_id = sub->data[0];\n\t\t\tmatch_len = 1;\n\n\t\t\tif (ext_id == WLAN_EID_EXT_NON_INHERITANCE)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tid = sub->id;\n\t\t\tmatch_len = 0;\n\t\t}\n\n\t\t \n\t\tif (cfg80211_find_elem_match(id, ie, ielen,\n\t\t\t\t\t     &ext_id, match_len, 0))\n\t\t\tcontinue;\n\n\t\tif (!cfg80211_copy_elem_with_frags(sub, subie, subie_len,\n\t\t\t\t\t\t   &pos, new_ie, new_ie_len))\n\t\t\treturn 0;\n\t}\n\n\treturn pos - new_ie;\n}\n\nstatic bool is_bss(struct cfg80211_bss *a, const u8 *bssid,\n\t\t   const u8 *ssid, size_t ssid_len)\n{\n\tconst struct cfg80211_bss_ies *ies;\n\tconst struct element *ssid_elem;\n\n\tif (bssid && !ether_addr_equal(a->bssid, bssid))\n\t\treturn false;\n\n\tif (!ssid)\n\t\treturn true;\n\n\ties = rcu_access_pointer(a->ies);\n\tif (!ies)\n\t\treturn false;\n\tssid_elem = cfg80211_find_elem(WLAN_EID_SSID, ies->data, ies->len);\n\tif (!ssid_elem)\n\t\treturn false;\n\tif (ssid_elem->datalen != ssid_len)\n\t\treturn false;\n\treturn memcmp(ssid_elem->data, ssid, ssid_len) == 0;\n}\n\nstatic int\ncfg80211_add_nontrans_list(struct cfg80211_bss *trans_bss,\n\t\t\t   struct cfg80211_bss *nontrans_bss)\n{\n\tconst struct element *ssid_elem;\n\tstruct cfg80211_bss *bss = NULL;\n\n\trcu_read_lock();\n\tssid_elem = ieee80211_bss_get_elem(nontrans_bss, WLAN_EID_SSID);\n\tif (!ssid_elem) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlist_for_each_entry(bss, &trans_bss->nontrans_list, nontrans_list) {\n\t\tif (is_bss(bss, nontrans_bss->bssid, ssid_elem->data,\n\t\t\t   ssid_elem->datalen)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\t \n\tif (!list_empty(&nontrans_bss->nontrans_list))\n\t\treturn -EINVAL;\n\n\t \n\tlist_add_tail(&nontrans_bss->nontrans_list, &trans_bss->nontrans_list);\n\treturn 0;\n}\n\nstatic void __cfg80211_bss_expire(struct cfg80211_registered_device *rdev,\n\t\t\t\t  unsigned long expire_time)\n{\n\tstruct cfg80211_internal_bss *bss, *tmp;\n\tbool expired = false;\n\n\tlockdep_assert_held(&rdev->bss_lock);\n\n\tlist_for_each_entry_safe(bss, tmp, &rdev->bss_list, list) {\n\t\tif (atomic_read(&bss->hold))\n\t\t\tcontinue;\n\t\tif (!time_after(expire_time, bss->ts))\n\t\t\tcontinue;\n\n\t\tif (__cfg80211_unlink_bss(rdev, bss))\n\t\t\texpired = true;\n\t}\n\n\tif (expired)\n\t\trdev->bss_generation++;\n}\n\nstatic bool cfg80211_bss_expire_oldest(struct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_internal_bss *bss, *oldest = NULL;\n\tbool ret;\n\n\tlockdep_assert_held(&rdev->bss_lock);\n\n\tlist_for_each_entry(bss, &rdev->bss_list, list) {\n\t\tif (atomic_read(&bss->hold))\n\t\t\tcontinue;\n\n\t\tif (!list_empty(&bss->hidden_list) &&\n\t\t    !bss->pub.hidden_beacon_bss)\n\t\t\tcontinue;\n\n\t\tif (oldest && time_before(oldest->ts, bss->ts))\n\t\t\tcontinue;\n\t\toldest = bss;\n\t}\n\n\tif (WARN_ON(!oldest))\n\t\treturn false;\n\n\t \n\n\tret = __cfg80211_unlink_bss(rdev, oldest);\n\tWARN_ON(!ret);\n\treturn ret;\n}\n\nstatic u8 cfg80211_parse_bss_param(u8 data,\n\t\t\t\t   struct cfg80211_colocated_ap *coloc_ap)\n{\n\tcoloc_ap->oct_recommended =\n\t\tu8_get_bits(data, IEEE80211_RNR_TBTT_PARAMS_OCT_RECOMMENDED);\n\tcoloc_ap->same_ssid =\n\t\tu8_get_bits(data, IEEE80211_RNR_TBTT_PARAMS_SAME_SSID);\n\tcoloc_ap->multi_bss =\n\t\tu8_get_bits(data, IEEE80211_RNR_TBTT_PARAMS_MULTI_BSSID);\n\tcoloc_ap->transmitted_bssid =\n\t\tu8_get_bits(data, IEEE80211_RNR_TBTT_PARAMS_TRANSMITTED_BSSID);\n\tcoloc_ap->unsolicited_probe =\n\t\tu8_get_bits(data, IEEE80211_RNR_TBTT_PARAMS_PROBE_ACTIVE);\n\tcoloc_ap->colocated_ess =\n\t\tu8_get_bits(data, IEEE80211_RNR_TBTT_PARAMS_COLOC_ESS);\n\n\treturn u8_get_bits(data, IEEE80211_RNR_TBTT_PARAMS_COLOC_AP);\n}\n\nstatic int cfg80211_calc_short_ssid(const struct cfg80211_bss_ies *ies,\n\t\t\t\t    const struct element **elem, u32 *s_ssid)\n{\n\n\t*elem = cfg80211_find_elem(WLAN_EID_SSID, ies->data, ies->len);\n\tif (!*elem || (*elem)->datalen > IEEE80211_MAX_SSID_LEN)\n\t\treturn -EINVAL;\n\n\t*s_ssid = ~crc32_le(~0, (*elem)->data, (*elem)->datalen);\n\treturn 0;\n}\n\nstatic void cfg80211_free_coloc_ap_list(struct list_head *coloc_ap_list)\n{\n\tstruct cfg80211_colocated_ap *ap, *tmp_ap;\n\n\tlist_for_each_entry_safe(ap, tmp_ap, coloc_ap_list, list) {\n\t\tlist_del(&ap->list);\n\t\tkfree(ap);\n\t}\n}\n\nstatic int cfg80211_parse_ap_info(struct cfg80211_colocated_ap *entry,\n\t\t\t\t  const u8 *pos, u8 length,\n\t\t\t\t  const struct element *ssid_elem,\n\t\t\t\t  u32 s_ssid_tmp)\n{\n\tu8 bss_params;\n\n\tentry->psd_20 = IEEE80211_RNR_TBTT_PARAMS_PSD_RESERVED;\n\n\t \n\tif (length > sizeof(struct ieee80211_tbtt_info_7_8_9)) {\n\t\tstruct ieee80211_tbtt_info_ge_11 *tbtt_info = (void *)pos;\n\n\t\tmemcpy(entry->bssid, tbtt_info->bssid, ETH_ALEN);\n\t\tentry->short_ssid = le32_to_cpu(tbtt_info->short_ssid);\n\t\tentry->short_ssid_valid = true;\n\n\t\tbss_params = tbtt_info->bss_params;\n\n\t\t \n\t\tif (length >= offsetofend(typeof(*tbtt_info), mld_params)) {\n\t\t\tif (le16_get_bits(tbtt_info->mld_params.params,\n\t\t\t\t\t  IEEE80211_RNR_MLD_PARAMS_DISABLED_LINK))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (length >= offsetofend(struct ieee80211_tbtt_info_ge_11,\n\t\t\t\t\t  psd_20))\n\t\t\tentry->psd_20 = tbtt_info->psd_20;\n\t} else {\n\t\tstruct ieee80211_tbtt_info_7_8_9 *tbtt_info = (void *)pos;\n\n\t\tmemcpy(entry->bssid, tbtt_info->bssid, ETH_ALEN);\n\n\t\tbss_params = tbtt_info->bss_params;\n\n\t\tif (length == offsetofend(struct ieee80211_tbtt_info_7_8_9,\n\t\t\t\t\t  psd_20))\n\t\t\tentry->psd_20 = tbtt_info->psd_20;\n\t}\n\n\t \n\tif (!is_valid_ether_addr(entry->bssid))\n\t\treturn -EINVAL;\n\n\t \n\tif (!cfg80211_parse_bss_param(bss_params, entry))\n\t\treturn -EINVAL;\n\n\t \n\tif (!entry->same_ssid && !entry->short_ssid_valid)\n\t\treturn 0;\n\n\tif (entry->same_ssid) {\n\t\tentry->short_ssid = s_ssid_tmp;\n\t\tentry->short_ssid_valid = true;\n\n\t\t \n\t\tmemcpy(&entry->ssid, &ssid_elem->data, ssid_elem->datalen);\n\t\tentry->ssid_len = ssid_elem->datalen;\n\t}\n\n\treturn 0;\n}\n\nstatic int cfg80211_parse_colocated_ap(const struct cfg80211_bss_ies *ies,\n\t\t\t\t       struct list_head *list)\n{\n\tstruct ieee80211_neighbor_ap_info *ap_info;\n\tconst struct element *elem, *ssid_elem;\n\tconst u8 *pos, *end;\n\tu32 s_ssid_tmp;\n\tint n_coloc = 0, ret;\n\tLIST_HEAD(ap_list);\n\n\tret = cfg80211_calc_short_ssid(ies, &ssid_elem, &s_ssid_tmp);\n\tif (ret)\n\t\treturn 0;\n\n\tfor_each_element_id(elem, WLAN_EID_REDUCED_NEIGHBOR_REPORT,\n\t\t\t    ies->data, ies->len) {\n\t\tpos = elem->data;\n\t\tend = elem->data + elem->datalen;\n\n\t\t \n\t\twhile (pos + sizeof(*ap_info) <= end) {\n\t\t\tenum nl80211_band band;\n\t\t\tint freq;\n\t\t\tu8 length, i, count;\n\n\t\t\tap_info = (void *)pos;\n\t\t\tcount = u8_get_bits(ap_info->tbtt_info_hdr,\n\t\t\t\t\t    IEEE80211_AP_INFO_TBTT_HDR_COUNT) + 1;\n\t\t\tlength = ap_info->tbtt_info_len;\n\n\t\t\tpos += sizeof(*ap_info);\n\n\t\t\tif (!ieee80211_operating_class_to_band(ap_info->op_class,\n\t\t\t\t\t\t\t       &band))\n\t\t\t\tbreak;\n\n\t\t\tfreq = ieee80211_channel_to_frequency(ap_info->channel,\n\t\t\t\t\t\t\t      band);\n\n\t\t\tif (end - pos < count * length)\n\t\t\t\tbreak;\n\n\t\t\tif (u8_get_bits(ap_info->tbtt_info_hdr,\n\t\t\t\t\tIEEE80211_AP_INFO_TBTT_HDR_TYPE) !=\n\t\t\t    IEEE80211_TBTT_INFO_TYPE_TBTT) {\n\t\t\t\tpos += count * length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (band != NL80211_BAND_6GHZ ||\n\t\t\t    !(length == offsetofend(struct ieee80211_tbtt_info_7_8_9,\n\t\t\t\t\t\t    bss_params) ||\n\t\t\t      length == sizeof(struct ieee80211_tbtt_info_7_8_9) ||\n\t\t\t      length >= offsetofend(struct ieee80211_tbtt_info_ge_11,\n\t\t\t\t\t\t    bss_params))) {\n\t\t\t\tpos += count * length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tstruct cfg80211_colocated_ap *entry;\n\n\t\t\t\tentry = kzalloc(sizeof(*entry) + IEEE80211_MAX_SSID_LEN,\n\t\t\t\t\t\tGFP_ATOMIC);\n\n\t\t\t\tif (!entry)\n\t\t\t\t\tgoto error;\n\n\t\t\t\tentry->center_freq = freq;\n\n\t\t\t\tif (!cfg80211_parse_ap_info(entry, pos, length,\n\t\t\t\t\t\t\t    ssid_elem,\n\t\t\t\t\t\t\t    s_ssid_tmp)) {\n\t\t\t\t\tn_coloc++;\n\t\t\t\t\tlist_add_tail(&entry->list, &ap_list);\n\t\t\t\t} else {\n\t\t\t\t\tkfree(entry);\n\t\t\t\t}\n\n\t\t\t\tpos += length;\n\t\t\t}\n\t\t}\n\nerror:\n\t\tif (pos != end) {\n\t\t\tcfg80211_free_coloc_ap_list(&ap_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tlist_splice_tail(&ap_list, list);\n\treturn n_coloc;\n}\n\nstatic  void cfg80211_scan_req_add_chan(struct cfg80211_scan_request *request,\n\t\t\t\t\tstruct ieee80211_channel *chan,\n\t\t\t\t\tbool add_to_6ghz)\n{\n\tint i;\n\tu32 n_channels = request->n_channels;\n\tstruct cfg80211_scan_6ghz_params *params =\n\t\t&request->scan_6ghz_params[request->n_6ghz_params];\n\n\tfor (i = 0; i < n_channels; i++) {\n\t\tif (request->channels[i] == chan) {\n\t\t\tif (add_to_6ghz)\n\t\t\t\tparams->channel_idx = i;\n\t\t\treturn;\n\t\t}\n\t}\n\n\trequest->channels[n_channels] = chan;\n\tif (add_to_6ghz)\n\t\trequest->scan_6ghz_params[request->n_6ghz_params].channel_idx =\n\t\t\tn_channels;\n\n\trequest->n_channels++;\n}\n\nstatic bool cfg80211_find_ssid_match(struct cfg80211_colocated_ap *ap,\n\t\t\t\t     struct cfg80211_scan_request *request)\n{\n\tint i;\n\tu32 s_ssid;\n\n\tfor (i = 0; i < request->n_ssids; i++) {\n\t\t \n\t\tif (!request->ssids[i].ssid_len) {\n\t\t\tif (ap->multi_bss && !ap->transmitted_bssid)\n\t\t\t\tcontinue;\n\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ap->ssid_len &&\n\t\t    ap->ssid_len == request->ssids[i].ssid_len) {\n\t\t\tif (!memcmp(request->ssids[i].ssid, ap->ssid,\n\t\t\t\t    ap->ssid_len))\n\t\t\t\treturn true;\n\t\t} else if (ap->short_ssid_valid) {\n\t\t\ts_ssid = ~crc32_le(~0, request->ssids[i].ssid,\n\t\t\t\t\t   request->ssids[i].ssid_len);\n\n\t\t\tif (ap->short_ssid == s_ssid)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int cfg80211_scan_6ghz(struct cfg80211_registered_device *rdev)\n{\n\tu8 i;\n\tstruct cfg80211_colocated_ap *ap;\n\tint n_channels, count = 0, err;\n\tstruct cfg80211_scan_request *request, *rdev_req = rdev->scan_req;\n\tLIST_HEAD(coloc_ap_list);\n\tbool need_scan_psc = true;\n\tconst struct ieee80211_sband_iftype_data *iftd;\n\n\trdev_req->scan_6ghz = true;\n\n\tif (!rdev->wiphy.bands[NL80211_BAND_6GHZ])\n\t\treturn -EOPNOTSUPP;\n\n\tiftd = ieee80211_get_sband_iftype_data(rdev->wiphy.bands[NL80211_BAND_6GHZ],\n\t\t\t\t\t       rdev_req->wdev->iftype);\n\tif (!iftd || !iftd->he_cap.has_he)\n\t\treturn -EOPNOTSUPP;\n\n\tn_channels = rdev->wiphy.bands[NL80211_BAND_6GHZ]->n_channels;\n\n\tif (rdev_req->flags & NL80211_SCAN_FLAG_COLOCATED_6GHZ) {\n\t\tstruct cfg80211_internal_bss *intbss;\n\n\t\tspin_lock_bh(&rdev->bss_lock);\n\t\tlist_for_each_entry(intbss, &rdev->bss_list, list) {\n\t\t\tstruct cfg80211_bss *res = &intbss->pub;\n\t\t\tconst struct cfg80211_bss_ies *ies;\n\n\t\t\ties = rcu_access_pointer(res->ies);\n\t\t\tcount += cfg80211_parse_colocated_ap(ies,\n\t\t\t\t\t\t\t     &coloc_ap_list);\n\t\t}\n\t\tspin_unlock_bh(&rdev->bss_lock);\n\t}\n\n\trequest = kzalloc(struct_size(request, channels, n_channels) +\n\t\t\t  sizeof(*request->scan_6ghz_params) * count +\n\t\t\t  sizeof(*request->ssids) * rdev_req->n_ssids,\n\t\t\t  GFP_KERNEL);\n\tif (!request) {\n\t\tcfg80211_free_coloc_ap_list(&coloc_ap_list);\n\t\treturn -ENOMEM;\n\t}\n\n\t*request = *rdev_req;\n\trequest->n_channels = 0;\n\trequest->scan_6ghz_params =\n\t\t(void *)&request->channels[n_channels];\n\n\t \n\tif (count && request->n_ssids == 1 && request->ssids[0].ssid_len) {\n\t\tlist_for_each_entry(ap, &coloc_ap_list, list) {\n\t\t\tif (ap->colocated_ess &&\n\t\t\t    cfg80211_find_ssid_match(ap, request)) {\n\t\t\t\tneed_scan_psc = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < rdev_req->n_channels; i++) {\n\t\tif (rdev_req->channels[i]->band == NL80211_BAND_6GHZ &&\n\t\t    ((need_scan_psc &&\n\t\t      cfg80211_channel_is_psc(rdev_req->channels[i])) ||\n\t\t     !(rdev_req->flags & NL80211_SCAN_FLAG_COLOCATED_6GHZ))) {\n\t\t\tcfg80211_scan_req_add_chan(request,\n\t\t\t\t\t\t   rdev_req->channels[i],\n\t\t\t\t\t\t   false);\n\t\t}\n\t}\n\n\tif (!(rdev_req->flags & NL80211_SCAN_FLAG_COLOCATED_6GHZ))\n\t\tgoto skip;\n\n\tlist_for_each_entry(ap, &coloc_ap_list, list) {\n\t\tbool found = false;\n\t\tstruct cfg80211_scan_6ghz_params *scan_6ghz_params =\n\t\t\t&request->scan_6ghz_params[request->n_6ghz_params];\n\t\tstruct ieee80211_channel *chan =\n\t\t\tieee80211_get_channel(&rdev->wiphy, ap->center_freq);\n\n\t\tif (!chan || chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < rdev_req->n_channels; i++) {\n\t\t\tif (rdev_req->channels[i] == chan)\n\t\t\t\tfound = true;\n\t\t}\n\n\t\tif (!found)\n\t\t\tcontinue;\n\n\t\tif (request->n_ssids > 0 &&\n\t\t    !cfg80211_find_ssid_match(ap, request))\n\t\t\tcontinue;\n\n\t\tif (!is_broadcast_ether_addr(request->bssid) &&\n\t\t    !ether_addr_equal(request->bssid, ap->bssid))\n\t\t\tcontinue;\n\n\t\tif (!request->n_ssids && ap->multi_bss && !ap->transmitted_bssid)\n\t\t\tcontinue;\n\n\t\tcfg80211_scan_req_add_chan(request, chan, true);\n\t\tmemcpy(scan_6ghz_params->bssid, ap->bssid, ETH_ALEN);\n\t\tscan_6ghz_params->short_ssid = ap->short_ssid;\n\t\tscan_6ghz_params->short_ssid_valid = ap->short_ssid_valid;\n\t\tscan_6ghz_params->unsolicited_probe = ap->unsolicited_probe;\n\t\tscan_6ghz_params->psd_20 = ap->psd_20;\n\n\t\t \n\t\tif (cfg80211_channel_is_psc(chan) && !need_scan_psc)\n\t\t\tscan_6ghz_params->psc_no_listen = true;\n\n\t\trequest->n_6ghz_params++;\n\t}\n\nskip:\n\tcfg80211_free_coloc_ap_list(&coloc_ap_list);\n\n\tif (request->n_channels) {\n\t\tstruct cfg80211_scan_request *old = rdev->int_scan_req;\n\t\trdev->int_scan_req = request;\n\n\t\t \n\t\trequest->ssids = (void *)&request->channels[request->n_channels];\n\t\trequest->n_ssids = rdev_req->n_ssids;\n\t\tmemcpy(request->ssids, rdev_req->ssids, sizeof(*request->ssids) *\n\t\t       request->n_ssids);\n\n\t\t \n\t\tif (old)\n\t\t\trdev->int_scan_req->info = old->info;\n\n\t\terr = rdev_scan(rdev, request);\n\t\tif (err) {\n\t\t\trdev->int_scan_req = old;\n\t\t\tkfree(request);\n\t\t} else {\n\t\t\tkfree(old);\n\t\t}\n\n\t\treturn err;\n\t}\n\n\tkfree(request);\n\treturn -EINVAL;\n}\n\nint cfg80211_scan(struct cfg80211_registered_device *rdev)\n{\n\tstruct cfg80211_scan_request *request;\n\tstruct cfg80211_scan_request *rdev_req = rdev->scan_req;\n\tu32 n_channels = 0, idx, i;\n\n\tif (!(rdev->wiphy.flags & WIPHY_FLAG_SPLIT_SCAN_6GHZ))\n\t\treturn rdev_scan(rdev, rdev_req);\n\n\tfor (i = 0; i < rdev_req->n_channels; i++) {\n\t\tif (rdev_req->channels[i]->band != NL80211_BAND_6GHZ)\n\t\t\tn_channels++;\n\t}\n\n\tif (!n_channels)\n\t\treturn cfg80211_scan_6ghz(rdev);\n\n\trequest = kzalloc(struct_size(request, channels, n_channels),\n\t\t\t  GFP_KERNEL);\n\tif (!request)\n\t\treturn -ENOMEM;\n\n\t*request = *rdev_req;\n\trequest->n_channels = n_channels;\n\n\tfor (i = idx = 0; i < rdev_req->n_channels; i++) {\n\t\tif (rdev_req->channels[i]->band != NL80211_BAND_6GHZ)\n\t\t\trequest->channels[idx++] = rdev_req->channels[i];\n\t}\n\n\trdev_req->scan_6ghz = false;\n\trdev->int_scan_req = request;\n\treturn rdev_scan(rdev, request);\n}\n\nvoid ___cfg80211_scan_done(struct cfg80211_registered_device *rdev,\n\t\t\t   bool send_message)\n{\n\tstruct cfg80211_scan_request *request, *rdev_req;\n\tstruct wireless_dev *wdev;\n\tstruct sk_buff *msg;\n#ifdef CONFIG_CFG80211_WEXT\n\tunion iwreq_data wrqu;\n#endif\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\tif (rdev->scan_msg) {\n\t\tnl80211_send_scan_msg(rdev, rdev->scan_msg);\n\t\trdev->scan_msg = NULL;\n\t\treturn;\n\t}\n\n\trdev_req = rdev->scan_req;\n\tif (!rdev_req)\n\t\treturn;\n\n\twdev = rdev_req->wdev;\n\trequest = rdev->int_scan_req ? rdev->int_scan_req : rdev_req;\n\n\tif (wdev_running(wdev) &&\n\t    (rdev->wiphy.flags & WIPHY_FLAG_SPLIT_SCAN_6GHZ) &&\n\t    !rdev_req->scan_6ghz && !request->info.aborted &&\n\t    !cfg80211_scan_6ghz(rdev))\n\t\treturn;\n\n\t \n\tif (wdev->netdev)\n\t\tcfg80211_sme_scan_done(wdev->netdev);\n\n\tif (!request->info.aborted &&\n\t    request->flags & NL80211_SCAN_FLAG_FLUSH) {\n\t\t \n\t\tspin_lock_bh(&rdev->bss_lock);\n\t\t__cfg80211_bss_expire(rdev, request->scan_start);\n\t\tspin_unlock_bh(&rdev->bss_lock);\n\t}\n\n\tmsg = nl80211_build_scan_msg(rdev, wdev, request->info.aborted);\n\n#ifdef CONFIG_CFG80211_WEXT\n\tif (wdev->netdev && !request->info.aborted) {\n\t\tmemset(&wrqu, 0, sizeof(wrqu));\n\n\t\twireless_send_event(wdev->netdev, SIOCGIWSCAN, &wrqu, NULL);\n\t}\n#endif\n\n\tdev_put(wdev->netdev);\n\n\tkfree(rdev->int_scan_req);\n\trdev->int_scan_req = NULL;\n\n\tkfree(rdev->scan_req);\n\trdev->scan_req = NULL;\n\n\tif (!send_message)\n\t\trdev->scan_msg = msg;\n\telse\n\t\tnl80211_send_scan_msg(rdev, msg);\n}\n\nvoid __cfg80211_scan_done(struct wiphy *wiphy, struct wiphy_work *wk)\n{\n\t___cfg80211_scan_done(wiphy_to_rdev(wiphy), true);\n}\n\nvoid cfg80211_scan_done(struct cfg80211_scan_request *request,\n\t\t\tstruct cfg80211_scan_info *info)\n{\n\tstruct cfg80211_scan_info old_info = request->info;\n\n\ttrace_cfg80211_scan_done(request, info);\n\tWARN_ON(request != wiphy_to_rdev(request->wiphy)->scan_req &&\n\t\trequest != wiphy_to_rdev(request->wiphy)->int_scan_req);\n\n\trequest->info = *info;\n\n\t \n\tif (request->scan_6ghz && old_info.scan_start_tsf) {\n\t\trequest->info.scan_start_tsf = old_info.scan_start_tsf;\n\t\tmemcpy(request->info.tsf_bssid, old_info.tsf_bssid,\n\t\t       sizeof(request->info.tsf_bssid));\n\t}\n\n\trequest->notified = true;\n\twiphy_work_queue(request->wiphy,\n\t\t\t &wiphy_to_rdev(request->wiphy)->scan_done_wk);\n}\nEXPORT_SYMBOL(cfg80211_scan_done);\n\nvoid cfg80211_add_sched_scan_req(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct cfg80211_sched_scan_request *req)\n{\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\tlist_add_rcu(&req->list, &rdev->sched_scan_req_list);\n}\n\nstatic void cfg80211_del_sched_scan_req(struct cfg80211_registered_device *rdev,\n\t\t\t\t\tstruct cfg80211_sched_scan_request *req)\n{\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\tlist_del_rcu(&req->list);\n\tkfree_rcu(req, rcu_head);\n}\n\nstatic struct cfg80211_sched_scan_request *\ncfg80211_find_sched_scan_req(struct cfg80211_registered_device *rdev, u64 reqid)\n{\n\tstruct cfg80211_sched_scan_request *pos;\n\n\tlist_for_each_entry_rcu(pos, &rdev->sched_scan_req_list, list,\n\t\t\t\tlockdep_is_held(&rdev->wiphy.mtx)) {\n\t\tif (pos->reqid == reqid)\n\t\t\treturn pos;\n\t}\n\treturn NULL;\n}\n\n \nint cfg80211_sched_scan_req_possible(struct cfg80211_registered_device *rdev,\n\t\t\t\t     bool want_multi)\n{\n\tstruct cfg80211_sched_scan_request *pos;\n\tint i = 0;\n\n\tlist_for_each_entry(pos, &rdev->sched_scan_req_list, list) {\n\t\t \n\t\tif (!i && !pos->reqid)\n\t\t\treturn -EINPROGRESS;\n\t\ti++;\n\t}\n\n\tif (i) {\n\t\t \n\t\tif (!want_multi)\n\t\t\treturn -EINPROGRESS;\n\n\t\t \n\t\tif (i == rdev->wiphy.max_sched_scan_reqs)\n\t\t\treturn -ENOSPC;\n\t}\n\treturn 0;\n}\n\nvoid cfg80211_sched_scan_results_wk(struct work_struct *work)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct cfg80211_sched_scan_request *req, *tmp;\n\n\trdev = container_of(work, struct cfg80211_registered_device,\n\t\t\t   sched_scan_res_wk);\n\n\twiphy_lock(&rdev->wiphy);\n\tlist_for_each_entry_safe(req, tmp, &rdev->sched_scan_req_list, list) {\n\t\tif (req->report_results) {\n\t\t\treq->report_results = false;\n\t\t\tif (req->flags & NL80211_SCAN_FLAG_FLUSH) {\n\t\t\t\t \n\t\t\t\tspin_lock_bh(&rdev->bss_lock);\n\t\t\t\t__cfg80211_bss_expire(rdev, req->scan_start);\n\t\t\t\tspin_unlock_bh(&rdev->bss_lock);\n\t\t\t\treq->scan_start = jiffies;\n\t\t\t}\n\t\t\tnl80211_send_sched_scan(req,\n\t\t\t\t\t\tNL80211_CMD_SCHED_SCAN_RESULTS);\n\t\t}\n\t}\n\twiphy_unlock(&rdev->wiphy);\n}\n\nvoid cfg80211_sched_scan_results(struct wiphy *wiphy, u64 reqid)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct cfg80211_sched_scan_request *request;\n\n\ttrace_cfg80211_sched_scan_results(wiphy, reqid);\n\t \n\n\trcu_read_lock();\n\trequest = cfg80211_find_sched_scan_req(rdev, reqid);\n\tif (request) {\n\t\trequest->report_results = true;\n\t\tqueue_work(cfg80211_wq, &rdev->sched_scan_res_wk);\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(cfg80211_sched_scan_results);\n\nvoid cfg80211_sched_scan_stopped_locked(struct wiphy *wiphy, u64 reqid)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tlockdep_assert_held(&wiphy->mtx);\n\n\ttrace_cfg80211_sched_scan_stopped(wiphy, reqid);\n\n\t__cfg80211_stop_sched_scan(rdev, reqid, true);\n}\nEXPORT_SYMBOL(cfg80211_sched_scan_stopped_locked);\n\nvoid cfg80211_sched_scan_stopped(struct wiphy *wiphy, u64 reqid)\n{\n\twiphy_lock(wiphy);\n\tcfg80211_sched_scan_stopped_locked(wiphy, reqid);\n\twiphy_unlock(wiphy);\n}\nEXPORT_SYMBOL(cfg80211_sched_scan_stopped);\n\nint cfg80211_stop_sched_scan_req(struct cfg80211_registered_device *rdev,\n\t\t\t\t struct cfg80211_sched_scan_request *req,\n\t\t\t\t bool driver_initiated)\n{\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\tif (!driver_initiated) {\n\t\tint err = rdev_sched_scan_stop(rdev, req->dev, req->reqid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnl80211_send_sched_scan(req, NL80211_CMD_SCHED_SCAN_STOPPED);\n\n\tcfg80211_del_sched_scan_req(rdev, req);\n\n\treturn 0;\n}\n\nint __cfg80211_stop_sched_scan(struct cfg80211_registered_device *rdev,\n\t\t\t       u64 reqid, bool driver_initiated)\n{\n\tstruct cfg80211_sched_scan_request *sched_scan_req;\n\n\tlockdep_assert_held(&rdev->wiphy.mtx);\n\n\tsched_scan_req = cfg80211_find_sched_scan_req(rdev, reqid);\n\tif (!sched_scan_req)\n\t\treturn -ENOENT;\n\n\treturn cfg80211_stop_sched_scan_req(rdev, sched_scan_req,\n\t\t\t\t\t    driver_initiated);\n}\n\nvoid cfg80211_bss_age(struct cfg80211_registered_device *rdev,\n                      unsigned long age_secs)\n{\n\tstruct cfg80211_internal_bss *bss;\n\tunsigned long age_jiffies = msecs_to_jiffies(age_secs * MSEC_PER_SEC);\n\n\tspin_lock_bh(&rdev->bss_lock);\n\tlist_for_each_entry(bss, &rdev->bss_list, list)\n\t\tbss->ts -= age_jiffies;\n\tspin_unlock_bh(&rdev->bss_lock);\n}\n\nvoid cfg80211_bss_expire(struct cfg80211_registered_device *rdev)\n{\n\t__cfg80211_bss_expire(rdev, jiffies - IEEE80211_SCAN_RESULT_EXPIRE);\n}\n\nvoid cfg80211_bss_flush(struct wiphy *wiphy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tspin_lock_bh(&rdev->bss_lock);\n\t__cfg80211_bss_expire(rdev, jiffies);\n\tspin_unlock_bh(&rdev->bss_lock);\n}\nEXPORT_SYMBOL(cfg80211_bss_flush);\n\nconst struct element *\ncfg80211_find_elem_match(u8 eid, const u8 *ies, unsigned int len,\n\t\t\t const u8 *match, unsigned int match_len,\n\t\t\t unsigned int match_offset)\n{\n\tconst struct element *elem;\n\n\tfor_each_element_id(elem, eid, ies, len) {\n\t\tif (elem->datalen >= match_offset + match_len &&\n\t\t    !memcmp(elem->data + match_offset, match, match_len))\n\t\t\treturn elem;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(cfg80211_find_elem_match);\n\nconst struct element *cfg80211_find_vendor_elem(unsigned int oui, int oui_type,\n\t\t\t\t\t\tconst u8 *ies,\n\t\t\t\t\t\tunsigned int len)\n{\n\tconst struct element *elem;\n\tu8 match[] = { oui >> 16, oui >> 8, oui, oui_type };\n\tint match_len = (oui_type < 0) ? 3 : sizeof(match);\n\n\tif (WARN_ON(oui_type > 0xff))\n\t\treturn NULL;\n\n\telem = cfg80211_find_elem_match(WLAN_EID_VENDOR_SPECIFIC, ies, len,\n\t\t\t\t\tmatch, match_len, 0);\n\n\tif (!elem || elem->datalen < 4)\n\t\treturn NULL;\n\n\treturn elem;\n}\nEXPORT_SYMBOL(cfg80211_find_vendor_elem);\n\n \nenum bss_compare_mode {\n\tBSS_CMP_REGULAR,\n\tBSS_CMP_HIDE_ZLEN,\n\tBSS_CMP_HIDE_NUL,\n};\n\nstatic int cmp_bss(struct cfg80211_bss *a,\n\t\t   struct cfg80211_bss *b,\n\t\t   enum bss_compare_mode mode)\n{\n\tconst struct cfg80211_bss_ies *a_ies, *b_ies;\n\tconst u8 *ie1 = NULL;\n\tconst u8 *ie2 = NULL;\n\tint i, r;\n\n\tif (a->channel != b->channel)\n\t\treturn (b->channel->center_freq * 1000 + b->channel->freq_offset) -\n\t\t       (a->channel->center_freq * 1000 + a->channel->freq_offset);\n\n\ta_ies = rcu_access_pointer(a->ies);\n\tif (!a_ies)\n\t\treturn -1;\n\tb_ies = rcu_access_pointer(b->ies);\n\tif (!b_ies)\n\t\treturn 1;\n\n\tif (WLAN_CAPABILITY_IS_STA_BSS(a->capability))\n\t\tie1 = cfg80211_find_ie(WLAN_EID_MESH_ID,\n\t\t\t\t       a_ies->data, a_ies->len);\n\tif (WLAN_CAPABILITY_IS_STA_BSS(b->capability))\n\t\tie2 = cfg80211_find_ie(WLAN_EID_MESH_ID,\n\t\t\t\t       b_ies->data, b_ies->len);\n\tif (ie1 && ie2) {\n\t\tint mesh_id_cmp;\n\n\t\tif (ie1[1] == ie2[1])\n\t\t\tmesh_id_cmp = memcmp(ie1 + 2, ie2 + 2, ie1[1]);\n\t\telse\n\t\t\tmesh_id_cmp = ie2[1] - ie1[1];\n\n\t\tie1 = cfg80211_find_ie(WLAN_EID_MESH_CONFIG,\n\t\t\t\t       a_ies->data, a_ies->len);\n\t\tie2 = cfg80211_find_ie(WLAN_EID_MESH_CONFIG,\n\t\t\t\t       b_ies->data, b_ies->len);\n\t\tif (ie1 && ie2) {\n\t\t\tif (mesh_id_cmp)\n\t\t\t\treturn mesh_id_cmp;\n\t\t\tif (ie1[1] != ie2[1])\n\t\t\t\treturn ie2[1] - ie1[1];\n\t\t\treturn memcmp(ie1 + 2, ie2 + 2, ie1[1]);\n\t\t}\n\t}\n\n\tr = memcmp(a->bssid, b->bssid, sizeof(a->bssid));\n\tif (r)\n\t\treturn r;\n\n\tie1 = cfg80211_find_ie(WLAN_EID_SSID, a_ies->data, a_ies->len);\n\tie2 = cfg80211_find_ie(WLAN_EID_SSID, b_ies->data, b_ies->len);\n\n\tif (!ie1 && !ie2)\n\t\treturn 0;\n\n\t \n\n\t \n\tif (!ie1)\n\t\treturn -1;\n\tif (!ie2)\n\t\treturn 1;\n\n\tswitch (mode) {\n\tcase BSS_CMP_HIDE_ZLEN:\n\t\t \n\t\treturn ie2[1];\n\tcase BSS_CMP_REGULAR:\n\tdefault:\n\t\t \n\t\tif (ie1[1] != ie2[1])\n\t\t\treturn ie2[1] - ie1[1];\n\t\treturn memcmp(ie1 + 2, ie2 + 2, ie1[1]);\n\tcase BSS_CMP_HIDE_NUL:\n\t\tif (ie1[1] != ie2[1])\n\t\t\treturn ie2[1] - ie1[1];\n\t\t \n\t\tfor (i = 0; i < ie2[1]; i++)\n\t\t\tif (ie2[i + 2])\n\t\t\t\treturn -1;\n\t\treturn 0;\n\t}\n}\n\nstatic bool cfg80211_bss_type_match(u16 capability,\n\t\t\t\t    enum nl80211_band band,\n\t\t\t\t    enum ieee80211_bss_type bss_type)\n{\n\tbool ret = true;\n\tu16 mask, val;\n\n\tif (bss_type == IEEE80211_BSS_TYPE_ANY)\n\t\treturn ret;\n\n\tif (band == NL80211_BAND_60GHZ) {\n\t\tmask = WLAN_CAPABILITY_DMG_TYPE_MASK;\n\t\tswitch (bss_type) {\n\t\tcase IEEE80211_BSS_TYPE_ESS:\n\t\t\tval = WLAN_CAPABILITY_DMG_TYPE_AP;\n\t\t\tbreak;\n\t\tcase IEEE80211_BSS_TYPE_PBSS:\n\t\t\tval = WLAN_CAPABILITY_DMG_TYPE_PBSS;\n\t\t\tbreak;\n\t\tcase IEEE80211_BSS_TYPE_IBSS:\n\t\t\tval = WLAN_CAPABILITY_DMG_TYPE_IBSS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tmask = WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS;\n\t\tswitch (bss_type) {\n\t\tcase IEEE80211_BSS_TYPE_ESS:\n\t\t\tval = WLAN_CAPABILITY_ESS;\n\t\t\tbreak;\n\t\tcase IEEE80211_BSS_TYPE_IBSS:\n\t\t\tval = WLAN_CAPABILITY_IBSS;\n\t\t\tbreak;\n\t\tcase IEEE80211_BSS_TYPE_MBSS:\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tret = ((capability & mask) == val);\n\treturn ret;\n}\n\n \nstruct cfg80211_bss *cfg80211_get_bss(struct wiphy *wiphy,\n\t\t\t\t      struct ieee80211_channel *channel,\n\t\t\t\t      const u8 *bssid,\n\t\t\t\t      const u8 *ssid, size_t ssid_len,\n\t\t\t\t      enum ieee80211_bss_type bss_type,\n\t\t\t\t      enum ieee80211_privacy privacy)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct cfg80211_internal_bss *bss, *res = NULL;\n\tunsigned long now = jiffies;\n\tint bss_privacy;\n\n\ttrace_cfg80211_get_bss(wiphy, channel, bssid, ssid, ssid_len, bss_type,\n\t\t\t       privacy);\n\n\tspin_lock_bh(&rdev->bss_lock);\n\n\tlist_for_each_entry(bss, &rdev->bss_list, list) {\n\t\tif (!cfg80211_bss_type_match(bss->pub.capability,\n\t\t\t\t\t     bss->pub.channel->band, bss_type))\n\t\t\tcontinue;\n\n\t\tbss_privacy = (bss->pub.capability & WLAN_CAPABILITY_PRIVACY);\n\t\tif ((privacy == IEEE80211_PRIVACY_ON && !bss_privacy) ||\n\t\t    (privacy == IEEE80211_PRIVACY_OFF && bss_privacy))\n\t\t\tcontinue;\n\t\tif (channel && bss->pub.channel != channel)\n\t\t\tcontinue;\n\t\tif (!is_valid_ether_addr(bss->pub.bssid))\n\t\t\tcontinue;\n\t\t \n\t\tif (time_after(now, bss->ts + IEEE80211_SCAN_RESULT_EXPIRE) &&\n\t\t    !atomic_read(&bss->hold))\n\t\t\tcontinue;\n\t\tif (is_bss(&bss->pub, bssid, ssid, ssid_len)) {\n\t\t\tres = bss;\n\t\t\tbss_ref_get(rdev, res);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rdev->bss_lock);\n\tif (!res)\n\t\treturn NULL;\n\ttrace_cfg80211_return_bss(&res->pub);\n\treturn &res->pub;\n}\nEXPORT_SYMBOL(cfg80211_get_bss);\n\nstatic void rb_insert_bss(struct cfg80211_registered_device *rdev,\n\t\t\t  struct cfg80211_internal_bss *bss)\n{\n\tstruct rb_node **p = &rdev->bss_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct cfg80211_internal_bss *tbss;\n\tint cmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\ttbss = rb_entry(parent, struct cfg80211_internal_bss, rbn);\n\n\t\tcmp = cmp_bss(&bss->pub, &tbss->pub, BSS_CMP_REGULAR);\n\n\t\tif (WARN_ON(!cmp)) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&bss->rbn, parent, p);\n\trb_insert_color(&bss->rbn, &rdev->bss_tree);\n}\n\nstatic struct cfg80211_internal_bss *\nrb_find_bss(struct cfg80211_registered_device *rdev,\n\t    struct cfg80211_internal_bss *res,\n\t    enum bss_compare_mode mode)\n{\n\tstruct rb_node *n = rdev->bss_tree.rb_node;\n\tstruct cfg80211_internal_bss *bss;\n\tint r;\n\n\twhile (n) {\n\t\tbss = rb_entry(n, struct cfg80211_internal_bss, rbn);\n\t\tr = cmp_bss(&res->pub, &bss->pub, mode);\n\n\t\tif (r == 0)\n\t\t\treturn bss;\n\t\telse if (r < 0)\n\t\t\tn = n->rb_left;\n\t\telse\n\t\t\tn = n->rb_right;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool cfg80211_combine_bsses(struct cfg80211_registered_device *rdev,\n\t\t\t\t   struct cfg80211_internal_bss *new)\n{\n\tconst struct cfg80211_bss_ies *ies;\n\tstruct cfg80211_internal_bss *bss;\n\tconst u8 *ie;\n\tint i, ssidlen;\n\tu8 fold = 0;\n\tu32 n_entries = 0;\n\n\ties = rcu_access_pointer(new->pub.beacon_ies);\n\tif (WARN_ON(!ies))\n\t\treturn false;\n\n\tie = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);\n\tif (!ie) {\n\t\t \n\t\treturn true;\n\t}\n\n\tssidlen = ie[1];\n\tfor (i = 0; i < ssidlen; i++)\n\t\tfold |= ie[2 + i];\n\n\tif (fold) {\n\t\t \n\t\treturn true;\n\t}\n\n\t \n\n\tlist_for_each_entry(bss, &rdev->bss_list, list) {\n\t\t \n\t\tn_entries++;\n\n\t\tif (!ether_addr_equal(bss->pub.bssid, new->pub.bssid))\n\t\t\tcontinue;\n\t\tif (bss->pub.channel != new->pub.channel)\n\t\t\tcontinue;\n\t\tif (bss->pub.scan_width != new->pub.scan_width)\n\t\t\tcontinue;\n\t\tif (rcu_access_pointer(bss->pub.beacon_ies))\n\t\t\tcontinue;\n\t\ties = rcu_access_pointer(bss->pub.ies);\n\t\tif (!ies)\n\t\t\tcontinue;\n\t\tie = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);\n\t\tif (!ie)\n\t\t\tcontinue;\n\t\tif (ssidlen && ie[1] != ssidlen)\n\t\t\tcontinue;\n\t\tif (WARN_ON_ONCE(bss->pub.hidden_beacon_bss))\n\t\t\tcontinue;\n\t\tif (WARN_ON_ONCE(!list_empty(&bss->hidden_list)))\n\t\t\tlist_del(&bss->hidden_list);\n\t\t \n\t\tlist_add(&bss->hidden_list, &new->hidden_list);\n\t\tbss->pub.hidden_beacon_bss = &new->pub;\n\t\tnew->refcount += bss->refcount;\n\t\trcu_assign_pointer(bss->pub.beacon_ies,\n\t\t\t\t   new->pub.beacon_ies);\n\t}\n\n\tWARN_ONCE(n_entries != rdev->bss_entries,\n\t\t  \"rdev bss entries[%d]/list[len:%d] corruption\\n\",\n\t\t  rdev->bss_entries, n_entries);\n\n\treturn true;\n}\n\nstatic void cfg80211_update_hidden_bsses(struct cfg80211_internal_bss *known,\n\t\t\t\t\t const struct cfg80211_bss_ies *new_ies,\n\t\t\t\t\t const struct cfg80211_bss_ies *old_ies)\n{\n\tstruct cfg80211_internal_bss *bss;\n\n\t \n\tlist_for_each_entry(bss, &known->hidden_list, hidden_list) {\n\t\tconst struct cfg80211_bss_ies *ies;\n\n\t\ties = rcu_access_pointer(bss->pub.beacon_ies);\n\t\tWARN_ON(ies != old_ies);\n\n\t\trcu_assign_pointer(bss->pub.beacon_ies, new_ies);\n\t}\n}\n\nstatic bool\ncfg80211_update_known_bss(struct cfg80211_registered_device *rdev,\n\t\t\t  struct cfg80211_internal_bss *known,\n\t\t\t  struct cfg80211_internal_bss *new,\n\t\t\t  bool signal_valid)\n{\n\tlockdep_assert_held(&rdev->bss_lock);\n\n\t \n\tif (rcu_access_pointer(new->pub.proberesp_ies)) {\n\t\tconst struct cfg80211_bss_ies *old;\n\n\t\told = rcu_access_pointer(known->pub.proberesp_ies);\n\n\t\trcu_assign_pointer(known->pub.proberesp_ies,\n\t\t\t\t   new->pub.proberesp_ies);\n\t\t \n\t\trcu_assign_pointer(known->pub.ies,\n\t\t\t\t   new->pub.proberesp_ies);\n\t\tif (old)\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)old, rcu_head);\n\t} else if (rcu_access_pointer(new->pub.beacon_ies)) {\n\t\tconst struct cfg80211_bss_ies *old;\n\n\t\tif (known->pub.hidden_beacon_bss &&\n\t\t    !list_empty(&known->hidden_list)) {\n\t\t\tconst struct cfg80211_bss_ies *f;\n\n\t\t\t \n\n\t\t\tf = rcu_access_pointer(new->pub.beacon_ies);\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)f, rcu_head);\n\t\t\treturn false;\n\t\t}\n\n\t\told = rcu_access_pointer(known->pub.beacon_ies);\n\n\t\trcu_assign_pointer(known->pub.beacon_ies, new->pub.beacon_ies);\n\n\t\t \n\t\tif (old == rcu_access_pointer(known->pub.ies))\n\t\t\trcu_assign_pointer(known->pub.ies, new->pub.beacon_ies);\n\n\t\tcfg80211_update_hidden_bsses(known,\n\t\t\t\t\t     rcu_access_pointer(new->pub.beacon_ies),\n\t\t\t\t\t     old);\n\n\t\tif (old)\n\t\t\tkfree_rcu((struct cfg80211_bss_ies *)old, rcu_head);\n\t}\n\n\tknown->pub.beacon_interval = new->pub.beacon_interval;\n\n\t \n\tif (signal_valid)\n\t\tknown->pub.signal = new->pub.signal;\n\tknown->pub.capability = new->pub.capability;\n\tknown->ts = new->ts;\n\tknown->ts_boottime = new->ts_boottime;\n\tknown->parent_tsf = new->parent_tsf;\n\tknown->pub.chains = new->pub.chains;\n\tmemcpy(known->pub.chain_signal, new->pub.chain_signal,\n\t       IEEE80211_MAX_CHAINS);\n\tether_addr_copy(known->parent_bssid, new->parent_bssid);\n\tknown->pub.max_bssid_indicator = new->pub.max_bssid_indicator;\n\tknown->pub.bssid_index = new->pub.bssid_index;\n\n\treturn true;\n}\n\n \nstatic struct cfg80211_internal_bss *\n__cfg80211_bss_update(struct cfg80211_registered_device *rdev,\n\t\t      struct cfg80211_internal_bss *tmp,\n\t\t      bool signal_valid, unsigned long ts)\n{\n\tstruct cfg80211_internal_bss *found = NULL;\n\n\tif (WARN_ON(!tmp->pub.channel))\n\t\treturn NULL;\n\n\ttmp->ts = ts;\n\n\tif (WARN_ON(!rcu_access_pointer(tmp->pub.ies))) {\n\t\treturn NULL;\n\t}\n\n\tfound = rb_find_bss(rdev, tmp, BSS_CMP_REGULAR);\n\n\tif (found) {\n\t\tif (!cfg80211_update_known_bss(rdev, found, tmp, signal_valid))\n\t\t\treturn NULL;\n\t} else {\n\t\tstruct cfg80211_internal_bss *new;\n\t\tstruct cfg80211_internal_bss *hidden;\n\t\tstruct cfg80211_bss_ies *ies;\n\n\t\t \n\t\tnew = kzalloc(sizeof(*new) + rdev->wiphy.bss_priv_size,\n\t\t\t      GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\ties = (void *)rcu_dereference(tmp->pub.beacon_ies);\n\t\t\tif (ies)\n\t\t\t\tkfree_rcu(ies, rcu_head);\n\t\t\ties = (void *)rcu_dereference(tmp->pub.proberesp_ies);\n\t\t\tif (ies)\n\t\t\t\tkfree_rcu(ies, rcu_head);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(new, tmp, sizeof(*new));\n\t\tnew->refcount = 1;\n\t\tINIT_LIST_HEAD(&new->hidden_list);\n\t\tINIT_LIST_HEAD(&new->pub.nontrans_list);\n\t\t \n\t\tnew->pub.transmitted_bss = NULL;\n\n\t\tif (rcu_access_pointer(tmp->pub.proberesp_ies)) {\n\t\t\thidden = rb_find_bss(rdev, tmp, BSS_CMP_HIDE_ZLEN);\n\t\t\tif (!hidden)\n\t\t\t\thidden = rb_find_bss(rdev, tmp,\n\t\t\t\t\t\t     BSS_CMP_HIDE_NUL);\n\t\t\tif (hidden) {\n\t\t\t\tnew->pub.hidden_beacon_bss = &hidden->pub;\n\t\t\t\tlist_add(&new->hidden_list,\n\t\t\t\t\t &hidden->hidden_list);\n\t\t\t\thidden->refcount++;\n\t\t\t\trcu_assign_pointer(new->pub.beacon_ies,\n\t\t\t\t\t\t   hidden->pub.beacon_ies);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (!cfg80211_combine_bsses(rdev, new)) {\n\t\t\t\tbss_ref_put(rdev, new);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (rdev->bss_entries >= bss_entries_limit &&\n\t\t    !cfg80211_bss_expire_oldest(rdev)) {\n\t\t\tbss_ref_put(rdev, new);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (tmp->pub.transmitted_bss) {\n\t\t\tnew->pub.transmitted_bss = tmp->pub.transmitted_bss;\n\t\t\tbss_ref_get(rdev, bss_from_pub(tmp->pub.transmitted_bss));\n\t\t}\n\n\t\tlist_add_tail(&new->list, &rdev->bss_list);\n\t\trdev->bss_entries++;\n\t\trb_insert_bss(rdev, new);\n\t\tfound = new;\n\t}\n\n\trdev->bss_generation++;\n\tbss_ref_get(rdev, found);\n\n\treturn found;\n}\n\nstruct cfg80211_internal_bss *\ncfg80211_bss_update(struct cfg80211_registered_device *rdev,\n\t\t    struct cfg80211_internal_bss *tmp,\n\t\t    bool signal_valid, unsigned long ts)\n{\n\tstruct cfg80211_internal_bss *res;\n\n\tspin_lock_bh(&rdev->bss_lock);\n\tres = __cfg80211_bss_update(rdev, tmp, signal_valid, ts);\n\tspin_unlock_bh(&rdev->bss_lock);\n\n\treturn res;\n}\n\nint cfg80211_get_ies_channel_number(const u8 *ie, size_t ielen,\n\t\t\t\t    enum nl80211_band band)\n{\n\tconst struct element *tmp;\n\n\tif (band == NL80211_BAND_6GHZ) {\n\t\tstruct ieee80211_he_operation *he_oper;\n\n\t\ttmp = cfg80211_find_ext_elem(WLAN_EID_EXT_HE_OPERATION, ie,\n\t\t\t\t\t     ielen);\n\t\tif (tmp && tmp->datalen >= sizeof(*he_oper) &&\n\t\t    tmp->datalen >= ieee80211_he_oper_size(&tmp->data[1])) {\n\t\t\tconst struct ieee80211_he_6ghz_oper *he_6ghz_oper;\n\n\t\t\the_oper = (void *)&tmp->data[1];\n\n\t\t\the_6ghz_oper = ieee80211_he_6ghz_oper(he_oper);\n\t\t\tif (!he_6ghz_oper)\n\t\t\t\treturn -1;\n\n\t\t\treturn he_6ghz_oper->primary;\n\t\t}\n\t} else if (band == NL80211_BAND_S1GHZ) {\n\t\ttmp = cfg80211_find_elem(WLAN_EID_S1G_OPERATION, ie, ielen);\n\t\tif (tmp && tmp->datalen >= sizeof(struct ieee80211_s1g_oper_ie)) {\n\t\t\tstruct ieee80211_s1g_oper_ie *s1gop = (void *)tmp->data;\n\n\t\t\treturn s1gop->oper_ch;\n\t\t}\n\t} else {\n\t\ttmp = cfg80211_find_elem(WLAN_EID_DS_PARAMS, ie, ielen);\n\t\tif (tmp && tmp->datalen == 1)\n\t\t\treturn tmp->data[0];\n\n\t\ttmp = cfg80211_find_elem(WLAN_EID_HT_OPERATION, ie, ielen);\n\t\tif (tmp &&\n\t\t    tmp->datalen >= sizeof(struct ieee80211_ht_operation)) {\n\t\t\tstruct ieee80211_ht_operation *htop = (void *)tmp->data;\n\n\t\t\treturn htop->primary_chan;\n\t\t}\n\t}\n\n\treturn -1;\n}\nEXPORT_SYMBOL(cfg80211_get_ies_channel_number);\n\n \nstatic struct ieee80211_channel *\ncfg80211_get_bss_channel(struct wiphy *wiphy, const u8 *ie, size_t ielen,\n\t\t\t struct ieee80211_channel *channel,\n\t\t\t enum nl80211_bss_scan_width scan_width)\n{\n\tu32 freq;\n\tint channel_number;\n\tstruct ieee80211_channel *alt_channel;\n\n\tchannel_number = cfg80211_get_ies_channel_number(ie, ielen,\n\t\t\t\t\t\t\t channel->band);\n\n\tif (channel_number < 0) {\n\t\t \n\t\treturn channel;\n\t}\n\n\tfreq = ieee80211_channel_to_freq_khz(channel_number, channel->band);\n\n\t \n\tif (freq == ieee80211_channel_to_khz(channel))\n\t\treturn channel;\n\n\talt_channel = ieee80211_get_channel_khz(wiphy, freq);\n\tif (!alt_channel) {\n\t\tif (channel->band == NL80211_BAND_2GHZ ||\n\t\t    channel->band == NL80211_BAND_6GHZ) {\n\t\t\t \n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\treturn channel;\n\t}\n\n\tif (scan_width == NL80211_BSS_CHAN_WIDTH_10 ||\n\t    scan_width == NL80211_BSS_CHAN_WIDTH_5) {\n\t\t \n\t\treturn channel;\n\t}\n\n\t \n\tif (alt_channel->flags & IEEE80211_CHAN_DISABLED)\n\t\treturn NULL;\n\treturn alt_channel;\n}\n\nstruct cfg80211_inform_single_bss_data {\n\tstruct cfg80211_inform_bss *drv_data;\n\tenum cfg80211_bss_frame_type ftype;\n\tstruct ieee80211_channel *channel;\n\tu8 bssid[ETH_ALEN];\n\tu64 tsf;\n\tu16 capability;\n\tu16 beacon_interval;\n\tconst u8 *ie;\n\tsize_t ielen;\n\n\tenum {\n\t\tBSS_SOURCE_DIRECT = 0,\n\t\tBSS_SOURCE_MBSSID,\n\t\tBSS_SOURCE_STA_PROFILE,\n\t} bss_source;\n\t \n\tstruct cfg80211_bss *source_bss;\n\tu8 max_bssid_indicator;\n\tu8 bssid_index;\n};\n\n \nstatic struct cfg80211_bss *\ncfg80211_inform_single_bss_data(struct wiphy *wiphy,\n\t\t\t\tstruct cfg80211_inform_single_bss_data *data,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct cfg80211_inform_bss *drv_data = data->drv_data;\n\tstruct cfg80211_bss_ies *ies;\n\tstruct ieee80211_channel *channel;\n\tstruct cfg80211_internal_bss tmp = {}, *res;\n\tint bss_type;\n\tbool signal_valid;\n\tunsigned long ts;\n\n\tif (WARN_ON(!wiphy))\n\t\treturn NULL;\n\n\tif (WARN_ON(wiphy->signal_type == CFG80211_SIGNAL_TYPE_UNSPEC &&\n\t\t    (drv_data->signal < 0 || drv_data->signal > 100)))\n\t\treturn NULL;\n\n\tif (WARN_ON(data->bss_source != BSS_SOURCE_DIRECT && !data->source_bss))\n\t\treturn NULL;\n\n\tchannel = data->channel;\n\tif (!channel)\n\t\tchannel = cfg80211_get_bss_channel(wiphy, data->ie, data->ielen,\n\t\t\t\t\t\t   drv_data->chan,\n\t\t\t\t\t\t   drv_data->scan_width);\n\tif (!channel)\n\t\treturn NULL;\n\n\tmemcpy(tmp.pub.bssid, data->bssid, ETH_ALEN);\n\ttmp.pub.channel = channel;\n\ttmp.pub.scan_width = drv_data->scan_width;\n\tif (data->bss_source != BSS_SOURCE_STA_PROFILE)\n\t\ttmp.pub.signal = drv_data->signal;\n\telse\n\t\ttmp.pub.signal = 0;\n\ttmp.pub.beacon_interval = data->beacon_interval;\n\ttmp.pub.capability = data->capability;\n\ttmp.ts_boottime = drv_data->boottime_ns;\n\ttmp.parent_tsf = drv_data->parent_tsf;\n\tether_addr_copy(tmp.parent_bssid, drv_data->parent_bssid);\n\n\tif (data->bss_source != BSS_SOURCE_DIRECT) {\n\t\ttmp.pub.transmitted_bss = data->source_bss;\n\t\tts = bss_from_pub(data->source_bss)->ts;\n\t\ttmp.pub.bssid_index = data->bssid_index;\n\t\ttmp.pub.max_bssid_indicator = data->max_bssid_indicator;\n\t} else {\n\t\tts = jiffies;\n\n\t\tif (channel->band == NL80211_BAND_60GHZ) {\n\t\t\tbss_type = data->capability &\n\t\t\t\t   WLAN_CAPABILITY_DMG_TYPE_MASK;\n\t\t\tif (bss_type == WLAN_CAPABILITY_DMG_TYPE_AP ||\n\t\t\t    bss_type == WLAN_CAPABILITY_DMG_TYPE_PBSS)\n\t\t\t\tregulatory_hint_found_beacon(wiphy, channel,\n\t\t\t\t\t\t\t     gfp);\n\t\t} else {\n\t\t\tif (data->capability & WLAN_CAPABILITY_ESS)\n\t\t\t\tregulatory_hint_found_beacon(wiphy, channel,\n\t\t\t\t\t\t\t     gfp);\n\t\t}\n\t}\n\n\t \n\ties = kzalloc(sizeof(*ies) + data->ielen, gfp);\n\tif (!ies)\n\t\treturn NULL;\n\ties->len = data->ielen;\n\ties->tsf = data->tsf;\n\ties->from_beacon = false;\n\tmemcpy(ies->data, data->ie, data->ielen);\n\n\tswitch (data->ftype) {\n\tcase CFG80211_BSS_FTYPE_BEACON:\n\t\ties->from_beacon = true;\n\t\tfallthrough;\n\tcase CFG80211_BSS_FTYPE_UNKNOWN:\n\t\trcu_assign_pointer(tmp.pub.beacon_ies, ies);\n\t\tbreak;\n\tcase CFG80211_BSS_FTYPE_PRESP:\n\t\trcu_assign_pointer(tmp.pub.proberesp_ies, ies);\n\t\tbreak;\n\t}\n\trcu_assign_pointer(tmp.pub.ies, ies);\n\n\tsignal_valid = drv_data->chan == channel;\n\tspin_lock_bh(&rdev->bss_lock);\n\tres = __cfg80211_bss_update(rdev, &tmp, signal_valid, ts);\n\tif (!res)\n\t\tgoto drop;\n\n\trdev_inform_bss(rdev, &res->pub, ies, drv_data->drv_data);\n\n\tif (data->bss_source == BSS_SOURCE_MBSSID) {\n\t\t \n\t\tif (cfg80211_add_nontrans_list(data->source_bss, &res->pub)) {\n\t\t\tif (__cfg80211_unlink_bss(rdev, res)) {\n\t\t\t\trdev->bss_generation++;\n\t\t\t\tres = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (!res)\n\t\t\tgoto drop;\n\t}\n\tspin_unlock_bh(&rdev->bss_lock);\n\n\ttrace_cfg80211_return_bss(&res->pub);\n\t \n\treturn &res->pub;\n\ndrop:\n\tspin_unlock_bh(&rdev->bss_lock);\n\treturn NULL;\n}\n\nstatic const struct element\n*cfg80211_get_profile_continuation(const u8 *ie, size_t ielen,\n\t\t\t\t   const struct element *mbssid_elem,\n\t\t\t\t   const struct element *sub_elem)\n{\n\tconst u8 *mbssid_end = mbssid_elem->data + mbssid_elem->datalen;\n\tconst struct element *next_mbssid;\n\tconst struct element *next_sub;\n\n\tnext_mbssid = cfg80211_find_elem(WLAN_EID_MULTIPLE_BSSID,\n\t\t\t\t\t mbssid_end,\n\t\t\t\t\t ielen - (mbssid_end - ie));\n\n\t \n\tif ((sub_elem->data + sub_elem->datalen < mbssid_end - 1) ||\n\t    !next_mbssid)\n\t\treturn NULL;\n\n\t \n\n\tif (next_mbssid->datalen < 4)\n\t\treturn NULL;\n\n\tnext_sub = (void *)&next_mbssid->data[1];\n\n\tif (next_mbssid->data + next_mbssid->datalen <\n\t    next_sub->data + next_sub->datalen)\n\t\treturn NULL;\n\n\tif (next_sub->id != 0 || next_sub->datalen < 2)\n\t\treturn NULL;\n\n\t \n\treturn next_sub->data[0] == WLAN_EID_NON_TX_BSSID_CAP ?\n\t       NULL : next_mbssid;\n}\n\nsize_t cfg80211_merge_profile(const u8 *ie, size_t ielen,\n\t\t\t      const struct element *mbssid_elem,\n\t\t\t      const struct element *sub_elem,\n\t\t\t      u8 *merged_ie, size_t max_copy_len)\n{\n\tsize_t copied_len = sub_elem->datalen;\n\tconst struct element *next_mbssid;\n\n\tif (sub_elem->datalen > max_copy_len)\n\t\treturn 0;\n\n\tmemcpy(merged_ie, sub_elem->data, sub_elem->datalen);\n\n\twhile ((next_mbssid = cfg80211_get_profile_continuation(ie, ielen,\n\t\t\t\t\t\t\t\tmbssid_elem,\n\t\t\t\t\t\t\t\tsub_elem))) {\n\t\tconst struct element *next_sub = (void *)&next_mbssid->data[1];\n\n\t\tif (copied_len + next_sub->datalen > max_copy_len)\n\t\t\tbreak;\n\t\tmemcpy(merged_ie + copied_len, next_sub->data,\n\t\t       next_sub->datalen);\n\t\tcopied_len += next_sub->datalen;\n\t}\n\n\treturn copied_len;\n}\nEXPORT_SYMBOL(cfg80211_merge_profile);\n\nstatic void\ncfg80211_parse_mbssid_data(struct wiphy *wiphy,\n\t\t\t   struct cfg80211_inform_single_bss_data *tx_data,\n\t\t\t   struct cfg80211_bss *source_bss,\n\t\t\t   gfp_t gfp)\n{\n\tstruct cfg80211_inform_single_bss_data data = {\n\t\t.drv_data = tx_data->drv_data,\n\t\t.ftype = tx_data->ftype,\n\t\t.tsf = tx_data->tsf,\n\t\t.beacon_interval = tx_data->beacon_interval,\n\t\t.source_bss = source_bss,\n\t\t.bss_source = BSS_SOURCE_MBSSID,\n\t};\n\tconst u8 *mbssid_index_ie;\n\tconst struct element *elem, *sub;\n\tu8 *new_ie, *profile;\n\tu64 seen_indices = 0;\n\tstruct cfg80211_bss *bss;\n\n\tif (!source_bss)\n\t\treturn;\n\tif (!cfg80211_find_elem(WLAN_EID_MULTIPLE_BSSID,\n\t\t\t\ttx_data->ie, tx_data->ielen))\n\t\treturn;\n\tif (!wiphy->support_mbssid)\n\t\treturn;\n\tif (wiphy->support_only_he_mbssid &&\n\t    !cfg80211_find_ext_elem(WLAN_EID_EXT_HE_CAPABILITY,\n\t\t\t\t    tx_data->ie, tx_data->ielen))\n\t\treturn;\n\n\tnew_ie = kmalloc(IEEE80211_MAX_DATA_LEN, gfp);\n\tif (!new_ie)\n\t\treturn;\n\n\tprofile = kmalloc(tx_data->ielen, gfp);\n\tif (!profile)\n\t\tgoto out;\n\n\tfor_each_element_id(elem, WLAN_EID_MULTIPLE_BSSID,\n\t\t\t    tx_data->ie, tx_data->ielen) {\n\t\tif (elem->datalen < 4)\n\t\t\tcontinue;\n\t\tif (elem->data[0] < 1 || (int)elem->data[0] > 8)\n\t\t\tcontinue;\n\t\tfor_each_element(sub, elem->data + 1, elem->datalen - 1) {\n\t\t\tu8 profile_len;\n\n\t\t\tif (sub->id != 0 || sub->datalen < 4) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sub->data[0] != WLAN_EID_NON_TX_BSSID_CAP ||\n\t\t\t    sub->data[1] != 2) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmemset(profile, 0, tx_data->ielen);\n\t\t\tprofile_len = cfg80211_merge_profile(tx_data->ie,\n\t\t\t\t\t\t\t     tx_data->ielen,\n\t\t\t\t\t\t\t     elem,\n\t\t\t\t\t\t\t     sub,\n\t\t\t\t\t\t\t     profile,\n\t\t\t\t\t\t\t     tx_data->ielen);\n\n\t\t\t \n\t\t\tmbssid_index_ie = cfg80211_find_ie\n\t\t\t\t(WLAN_EID_MULTI_BSSID_IDX,\n\t\t\t\t profile, profile_len);\n\t\t\tif (!mbssid_index_ie || mbssid_index_ie[1] < 1 ||\n\t\t\t    mbssid_index_ie[2] == 0 ||\n\t\t\t    mbssid_index_ie[2] > 46) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (seen_indices & BIT_ULL(mbssid_index_ie[2]))\n\t\t\t\t \n\t\t\t\tnet_dbg_ratelimited(\"Partial info for BSSID index %d\\n\",\n\t\t\t\t\t\t    mbssid_index_ie[2]);\n\n\t\t\tseen_indices |= BIT_ULL(mbssid_index_ie[2]);\n\n\t\t\tdata.bssid_index = mbssid_index_ie[2];\n\t\t\tdata.max_bssid_indicator = elem->data[0];\n\n\t\t\tcfg80211_gen_new_bssid(tx_data->bssid,\n\t\t\t\t\t       data.max_bssid_indicator,\n\t\t\t\t\t       data.bssid_index,\n\t\t\t\t\t       data.bssid);\n\n\t\t\tmemset(new_ie, 0, IEEE80211_MAX_DATA_LEN);\n\t\t\tdata.ie = new_ie;\n\t\t\tdata.ielen = cfg80211_gen_new_ie(tx_data->ie,\n\t\t\t\t\t\t\t tx_data->ielen,\n\t\t\t\t\t\t\t profile,\n\t\t\t\t\t\t\t profile_len,\n\t\t\t\t\t\t\t new_ie,\n\t\t\t\t\t\t\t IEEE80211_MAX_DATA_LEN);\n\t\t\tif (!data.ielen)\n\t\t\t\tcontinue;\n\n\t\t\tdata.capability = get_unaligned_le16(profile + 2);\n\t\t\tbss = cfg80211_inform_single_bss_data(wiphy, &data, gfp);\n\t\t\tif (!bss)\n\t\t\t\tbreak;\n\t\t\tcfg80211_put_bss(wiphy, bss);\n\t\t}\n\t}\n\nout:\n\tkfree(new_ie);\n\tkfree(profile);\n}\n\nssize_t cfg80211_defragment_element(const struct element *elem, const u8 *ies,\n\t\t\t\t    size_t ieslen, u8 *data, size_t data_len,\n\t\t\t\t    u8 frag_id)\n{\n\tconst struct element *next;\n\tssize_t copied;\n\tu8 elem_datalen;\n\n\tif (!elem)\n\t\treturn -EINVAL;\n\n\t \n\tnext = (void *)(elem->data + elem->datalen);\n\telem_datalen = elem->datalen;\n\n\tif (elem->id == WLAN_EID_EXTENSION) {\n\t\tcopied = elem->datalen - 1;\n\t\tif (copied > data_len)\n\t\t\treturn -ENOSPC;\n\n\t\tmemmove(data, elem->data + 1, copied);\n\t} else {\n\t\tcopied = elem->datalen;\n\t\tif (copied > data_len)\n\t\t\treturn -ENOSPC;\n\n\t\tmemmove(data, elem->data, copied);\n\t}\n\n\t \n\tif (elem_datalen < 255)\n\t\treturn copied;\n\n\tfor (elem = next;\n\t     elem->data < ies + ieslen &&\n\t\telem->data + elem->datalen <= ies + ieslen;\n\t     elem = next) {\n\t\t \n\t\tnext = (void *)(elem->data + elem->datalen);\n\n\t\tif (elem->id != frag_id)\n\t\t\tbreak;\n\n\t\telem_datalen = elem->datalen;\n\n\t\tif (copied + elem_datalen > data_len)\n\t\t\treturn -ENOSPC;\n\n\t\tmemmove(data + copied, elem->data, elem_datalen);\n\t\tcopied += elem_datalen;\n\n\t\t \n\t\tif (elem_datalen != 255)\n\t\t\tbreak;\n\t}\n\n\treturn copied;\n}\nEXPORT_SYMBOL(cfg80211_defragment_element);\n\nstruct cfg80211_mle {\n\tstruct ieee80211_multi_link_elem *mle;\n\tstruct ieee80211_mle_per_sta_profile\n\t\t*sta_prof[IEEE80211_MLD_MAX_NUM_LINKS];\n\tssize_t sta_prof_len[IEEE80211_MLD_MAX_NUM_LINKS];\n\n\tu8 data[];\n};\n\nstatic struct cfg80211_mle *\ncfg80211_defrag_mle(const struct element *mle, const u8 *ie, size_t ielen,\n\t\t    gfp_t gfp)\n{\n\tconst struct element *elem;\n\tstruct cfg80211_mle *res;\n\tsize_t buf_len;\n\tssize_t mle_len;\n\tu8 common_size, idx;\n\n\tif (!mle || !ieee80211_mle_size_ok(mle->data + 1, mle->datalen - 1))\n\t\treturn NULL;\n\n\t \n\tbuf_len = mle->datalen - 1;\n\tfor_each_element(elem, mle->data + mle->datalen,\n\t\t\t ielen - sizeof(*mle) + mle->datalen) {\n\t\tif (elem->id != WLAN_EID_FRAGMENT)\n\t\t\tbreak;\n\n\t\tbuf_len += elem->datalen;\n\t}\n\n\tres = kzalloc(struct_size(res, data, buf_len), gfp);\n\tif (!res)\n\t\treturn NULL;\n\n\tmle_len = cfg80211_defragment_element(mle, ie, ielen,\n\t\t\t\t\t      res->data, buf_len,\n\t\t\t\t\t      WLAN_EID_FRAGMENT);\n\tif (mle_len < 0)\n\t\tgoto error;\n\n\tres->mle = (void *)res->data;\n\n\t \n\tcommon_size = ieee80211_mle_common_size((u8 *)res->mle);\n\tie = res->data + common_size;\n\tielen = mle_len - common_size;\n\n\tidx = 0;\n\tfor_each_element_id(elem, IEEE80211_MLE_SUBELEM_PER_STA_PROFILE,\n\t\t\t    ie, ielen) {\n\t\tres->sta_prof[idx] = (void *)elem->data;\n\t\tres->sta_prof_len[idx] = elem->datalen;\n\n\t\tidx++;\n\t\tif (idx >= IEEE80211_MLD_MAX_NUM_LINKS)\n\t\t\tbreak;\n\t}\n\tif (!for_each_element_completed(elem, ie, ielen))\n\t\tgoto error;\n\n\t \n\tfor (idx = 0; idx < IEEE80211_MLD_MAX_NUM_LINKS && res->sta_prof[idx];\n\t     idx++) {\n\t\tif (res->sta_prof_len[idx] < 255)\n\t\t\tcontinue;\n\n\t\telem = (void *)res->sta_prof[idx] - 2;\n\n\t\tif (idx + 1 < ARRAY_SIZE(res->sta_prof) &&\n\t\t    res->sta_prof[idx + 1])\n\t\t\tbuf_len = (u8 *)res->sta_prof[idx + 1] -\n\t\t\t\t  (u8 *)res->sta_prof[idx];\n\t\telse\n\t\t\tbuf_len = ielen + ie - (u8 *)elem;\n\n\t\tres->sta_prof_len[idx] =\n\t\t\tcfg80211_defragment_element(elem,\n\t\t\t\t\t\t    (u8 *)elem, buf_len,\n\t\t\t\t\t\t    (u8 *)res->sta_prof[idx],\n\t\t\t\t\t\t    buf_len,\n\t\t\t\t\t\t    IEEE80211_MLE_SUBELEM_FRAGMENT);\n\t\tif (res->sta_prof_len[idx] < 0)\n\t\t\tgoto error;\n\t}\n\n\treturn res;\n\nerror:\n\tkfree(res);\n\treturn NULL;\n}\n\nstatic bool\ncfg80211_tbtt_info_for_mld_ap(const u8 *ie, size_t ielen, u8 mld_id, u8 link_id,\n\t\t\t      const struct ieee80211_neighbor_ap_info **ap_info,\n\t\t\t      const u8 **tbtt_info)\n{\n\tconst struct ieee80211_neighbor_ap_info *info;\n\tconst struct element *rnr;\n\tconst u8 *pos, *end;\n\n\tfor_each_element_id(rnr, WLAN_EID_REDUCED_NEIGHBOR_REPORT, ie, ielen) {\n\t\tpos = rnr->data;\n\t\tend = rnr->data + rnr->datalen;\n\n\t\t \n\t\twhile (sizeof(*info) <= end - pos) {\n\t\t\tconst struct ieee80211_rnr_mld_params *mld_params;\n\t\t\tu16 params;\n\t\t\tu8 length, i, count, mld_params_offset;\n\t\t\tu8 type, lid;\n\n\t\t\tinfo = (void *)pos;\n\t\t\tcount = u8_get_bits(info->tbtt_info_hdr,\n\t\t\t\t\t    IEEE80211_AP_INFO_TBTT_HDR_COUNT) + 1;\n\t\t\tlength = info->tbtt_info_len;\n\n\t\t\tpos += sizeof(*info);\n\n\t\t\tif (count * length > end - pos)\n\t\t\t\treturn false;\n\n\t\t\ttype = u8_get_bits(info->tbtt_info_hdr,\n\t\t\t\t\t   IEEE80211_AP_INFO_TBTT_HDR_TYPE);\n\n\t\t\t \n\t\t\tif (type == IEEE80211_TBTT_INFO_TYPE_TBTT &&\n\t\t\t    length >=\n\t\t\t    offsetofend(struct ieee80211_tbtt_info_ge_11,\n\t\t\t\t\tmld_params)) {\n\t\t\t\tmld_params_offset =\n\t\t\t\t\toffsetof(struct ieee80211_tbtt_info_ge_11, mld_params);\n\t\t\t} else {\n\t\t\t\tpos += count * length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tmld_params = (void *)pos + mld_params_offset;\n\t\t\t\tparams = le16_to_cpu(mld_params->params);\n\n\t\t\t\tlid = u16_get_bits(params,\n\t\t\t\t\t\t   IEEE80211_RNR_MLD_PARAMS_LINK_ID);\n\n\t\t\t\tif (mld_id == mld_params->mld_id &&\n\t\t\t\t    link_id == lid) {\n\t\t\t\t\t*ap_info = info;\n\t\t\t\t\t*tbtt_info = pos;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tpos += length;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic void\ncfg80211_parse_ml_elem_sta_data(struct wiphy *wiphy,\n\t\t\t\tstruct cfg80211_inform_single_bss_data *tx_data,\n\t\t\t\tstruct cfg80211_bss *source_bss,\n\t\t\t\tconst struct element *elem,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct cfg80211_inform_single_bss_data data = {\n\t\t.drv_data = tx_data->drv_data,\n\t\t.ftype = tx_data->ftype,\n\t\t.source_bss = source_bss,\n\t\t.bss_source = BSS_SOURCE_STA_PROFILE,\n\t};\n\tstruct ieee80211_multi_link_elem *ml_elem;\n\tstruct cfg80211_mle *mle;\n\tu16 control;\n\tu8 *new_ie;\n\tstruct cfg80211_bss *bss;\n\tint mld_id;\n\tu16 seen_links = 0;\n\tconst u8 *pos;\n\tu8 i;\n\n\tif (!ieee80211_mle_size_ok(elem->data + 1, elem->datalen - 1))\n\t\treturn;\n\n\tml_elem = (void *)elem->data + 1;\n\tcontrol = le16_to_cpu(ml_elem->control);\n\tif (u16_get_bits(control, IEEE80211_ML_CONTROL_TYPE) !=\n\t    IEEE80211_ML_CONTROL_TYPE_BASIC)\n\t\treturn;\n\n\t \n\tif (!(control & IEEE80211_MLC_BASIC_PRES_BSS_PARAM_CH_CNT) ||\n\t    !(control & IEEE80211_MLC_BASIC_PRES_LINK_ID) ||\n\t    !(control & IEEE80211_MLC_BASIC_PRES_MLD_CAPA_OP))\n\t\treturn;\n\n\t \n\tpos = ml_elem->variable + 1 + 6 + 1 + 1;\n\n\tif (u16_get_bits(control, IEEE80211_MLC_BASIC_PRES_MED_SYNC_DELAY))\n\t\tpos += 2;\n\tif (u16_get_bits(control, IEEE80211_MLC_BASIC_PRES_EML_CAPA))\n\t\tpos += 2;\n\n\t \n\tpos += 2;\n\n\t \n\tif (u16_get_bits(control, IEEE80211_MLC_BASIC_PRES_MLD_ID)) {\n\t\tmld_id = *pos;\n\t\tpos += 1;\n\t} else {\n\t\tmld_id = 0;\n\t}\n\n\t \n\tpos += 2;\n\n\t \n\tmle = cfg80211_defrag_mle(elem, tx_data->ie, tx_data->ielen, gfp);\n\tif (!mle)\n\t\treturn;\n\n\tnew_ie = kmalloc(IEEE80211_MAX_DATA_LEN, gfp);\n\tif (!new_ie)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(mle->sta_prof) && mle->sta_prof[i]; i++) {\n\t\tconst struct ieee80211_neighbor_ap_info *ap_info;\n\t\tenum nl80211_band band;\n\t\tu32 freq;\n\t\tconst u8 *profile;\n\t\tconst u8 *tbtt_info;\n\t\tssize_t profile_len;\n\t\tu8 link_id;\n\n\t\tif (!ieee80211_mle_basic_sta_prof_size_ok((u8 *)mle->sta_prof[i],\n\t\t\t\t\t\t\t  mle->sta_prof_len[i]))\n\t\t\tcontinue;\n\n\t\tcontrol = le16_to_cpu(mle->sta_prof[i]->control);\n\n\t\tif (!(control & IEEE80211_MLE_STA_CONTROL_COMPLETE_PROFILE))\n\t\t\tcontinue;\n\n\t\tlink_id = u16_get_bits(control,\n\t\t\t\t       IEEE80211_MLE_STA_CONTROL_LINK_ID);\n\t\tif (seen_links & BIT(link_id))\n\t\t\tbreak;\n\t\tseen_links |= BIT(link_id);\n\n\t\tif (!(control & IEEE80211_MLE_STA_CONTROL_BEACON_INT_PRESENT) ||\n\t\t    !(control & IEEE80211_MLE_STA_CONTROL_TSF_OFFS_PRESENT) ||\n\t\t    !(control & IEEE80211_MLE_STA_CONTROL_STA_MAC_ADDR_PRESENT))\n\t\t\tcontinue;\n\n\t\tmemcpy(data.bssid, mle->sta_prof[i]->variable, ETH_ALEN);\n\t\tdata.beacon_interval =\n\t\t\tget_unaligned_le16(mle->sta_prof[i]->variable + 6);\n\t\tdata.tsf = tx_data->tsf +\n\t\t\t   get_unaligned_le64(mle->sta_prof[i]->variable + 8);\n\n\t\t \n\t\tprofile = mle->sta_prof[i]->variable +\n\t\t\t  mle->sta_prof[i]->sta_info_len - 1;\n\t\tprofile_len = (u8 *)mle->sta_prof[i] + mle->sta_prof_len[i] -\n\t\t\t      profile;\n\n\t\tif (profile_len < 2)\n\t\t\tcontinue;\n\n\t\tdata.capability = get_unaligned_le16(profile);\n\t\tprofile += 2;\n\t\tprofile_len -= 2;\n\n\t\t \n\t\tif (!cfg80211_tbtt_info_for_mld_ap(tx_data->ie, tx_data->ielen,\n\t\t\t\t\t\t   mld_id, link_id,\n\t\t\t\t\t\t   &ap_info, &tbtt_info))\n\t\t\tcontinue;\n\n\t\t \n\n\t\tif (!ieee80211_operating_class_to_band(ap_info->op_class,\n\t\t\t\t\t\t       &band))\n\t\t\tcontinue;\n\n\t\tfreq = ieee80211_channel_to_freq_khz(ap_info->channel, band);\n\t\tdata.channel = ieee80211_get_channel_khz(wiphy, freq);\n\n\t\t \n\t\tmemset(new_ie, 0, IEEE80211_MAX_DATA_LEN);\n\t\tdata.ie = new_ie;\n\t\tdata.ielen = cfg80211_gen_new_ie(tx_data->ie, tx_data->ielen,\n\t\t\t\t\t\t profile, profile_len,\n\t\t\t\t\t\t new_ie,\n\t\t\t\t\t\t IEEE80211_MAX_DATA_LEN);\n\t\tif (!data.ielen)\n\t\t\tcontinue;\n\n\t\tbss = cfg80211_inform_single_bss_data(wiphy, &data, gfp);\n\t\tif (!bss)\n\t\t\tbreak;\n\t\tcfg80211_put_bss(wiphy, bss);\n\t}\n\nout:\n\tkfree(new_ie);\n\tkfree(mle);\n}\n\nstatic void cfg80211_parse_ml_sta_data(struct wiphy *wiphy,\n\t\t\t\t       struct cfg80211_inform_single_bss_data *tx_data,\n\t\t\t\t       struct cfg80211_bss *source_bss,\n\t\t\t\t       gfp_t gfp)\n{\n\tconst struct element *elem;\n\n\tif (!source_bss)\n\t\treturn;\n\n\tif (tx_data->ftype != CFG80211_BSS_FTYPE_PRESP)\n\t\treturn;\n\n\tfor_each_element_extid(elem, WLAN_EID_EXT_EHT_MULTI_LINK,\n\t\t\t       tx_data->ie, tx_data->ielen)\n\t\tcfg80211_parse_ml_elem_sta_data(wiphy, tx_data, source_bss,\n\t\t\t\t\t\telem, gfp);\n}\n\nstruct cfg80211_bss *\ncfg80211_inform_bss_data(struct wiphy *wiphy,\n\t\t\t struct cfg80211_inform_bss *data,\n\t\t\t enum cfg80211_bss_frame_type ftype,\n\t\t\t const u8 *bssid, u64 tsf, u16 capability,\n\t\t\t u16 beacon_interval, const u8 *ie, size_t ielen,\n\t\t\t gfp_t gfp)\n{\n\tstruct cfg80211_inform_single_bss_data inform_data = {\n\t\t.drv_data = data,\n\t\t.ftype = ftype,\n\t\t.tsf = tsf,\n\t\t.capability = capability,\n\t\t.beacon_interval = beacon_interval,\n\t\t.ie = ie,\n\t\t.ielen = ielen,\n\t};\n\tstruct cfg80211_bss *res;\n\n\tmemcpy(inform_data.bssid, bssid, ETH_ALEN);\n\n\tres = cfg80211_inform_single_bss_data(wiphy, &inform_data, gfp);\n\tif (!res)\n\t\treturn NULL;\n\n\tcfg80211_parse_mbssid_data(wiphy, &inform_data, res, gfp);\n\n\tcfg80211_parse_ml_sta_data(wiphy, &inform_data, res, gfp);\n\n\treturn res;\n}\nEXPORT_SYMBOL(cfg80211_inform_bss_data);\n\n \nstatic struct cfg80211_bss *\ncfg80211_inform_single_bss_frame_data(struct wiphy *wiphy,\n\t\t\t\t      struct cfg80211_inform_bss *data,\n\t\t\t\t      struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t\t      gfp_t gfp)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct cfg80211_internal_bss tmp = {}, *res;\n\tstruct cfg80211_bss_ies *ies;\n\tstruct ieee80211_channel *channel;\n\tbool signal_valid;\n\tstruct ieee80211_ext *ext = NULL;\n\tu8 *bssid, *variable;\n\tu16 capability, beacon_int;\n\tsize_t ielen, min_hdr_len = offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t     u.probe_resp.variable);\n\tint bss_type;\n\n\tBUILD_BUG_ON(offsetof(struct ieee80211_mgmt, u.probe_resp.variable) !=\n\t\t\toffsetof(struct ieee80211_mgmt, u.beacon.variable));\n\n\ttrace_cfg80211_inform_bss_frame(wiphy, data, mgmt, len);\n\n\tif (WARN_ON(!mgmt))\n\t\treturn NULL;\n\n\tif (WARN_ON(!wiphy))\n\t\treturn NULL;\n\n\tif (WARN_ON(wiphy->signal_type == CFG80211_SIGNAL_TYPE_UNSPEC &&\n\t\t    (data->signal < 0 || data->signal > 100)))\n\t\treturn NULL;\n\n\tif (ieee80211_is_s1g_beacon(mgmt->frame_control)) {\n\t\text = (void *) mgmt;\n\t\tmin_hdr_len = offsetof(struct ieee80211_ext, u.s1g_beacon);\n\t\tif (ieee80211_is_s1g_short_beacon(mgmt->frame_control))\n\t\t\tmin_hdr_len = offsetof(struct ieee80211_ext,\n\t\t\t\t\t       u.s1g_short_beacon.variable);\n\t}\n\n\tif (WARN_ON(len < min_hdr_len))\n\t\treturn NULL;\n\n\tielen = len - min_hdr_len;\n\tvariable = mgmt->u.probe_resp.variable;\n\tif (ext) {\n\t\tif (ieee80211_is_s1g_short_beacon(mgmt->frame_control))\n\t\t\tvariable = ext->u.s1g_short_beacon.variable;\n\t\telse\n\t\t\tvariable = ext->u.s1g_beacon.variable;\n\t}\n\n\tchannel = cfg80211_get_bss_channel(wiphy, variable,\n\t\t\t\t\t   ielen, data->chan, data->scan_width);\n\tif (!channel)\n\t\treturn NULL;\n\n\tif (ext) {\n\t\tconst struct ieee80211_s1g_bcn_compat_ie *compat;\n\t\tconst struct element *elem;\n\n\t\telem = cfg80211_find_elem(WLAN_EID_S1G_BCN_COMPAT,\n\t\t\t\t\t  variable, ielen);\n\t\tif (!elem)\n\t\t\treturn NULL;\n\t\tif (elem->datalen < sizeof(*compat))\n\t\t\treturn NULL;\n\t\tcompat = (void *)elem->data;\n\t\tbssid = ext->u.s1g_beacon.sa;\n\t\tcapability = le16_to_cpu(compat->compat_info);\n\t\tbeacon_int = le16_to_cpu(compat->beacon_int);\n\t} else {\n\t\tbssid = mgmt->bssid;\n\t\tbeacon_int = le16_to_cpu(mgmt->u.probe_resp.beacon_int);\n\t\tcapability = le16_to_cpu(mgmt->u.probe_resp.capab_info);\n\t}\n\n\tif (channel->band == NL80211_BAND_60GHZ) {\n\t\tbss_type = capability & WLAN_CAPABILITY_DMG_TYPE_MASK;\n\t\tif (bss_type == WLAN_CAPABILITY_DMG_TYPE_AP ||\n\t\t    bss_type == WLAN_CAPABILITY_DMG_TYPE_PBSS)\n\t\t\tregulatory_hint_found_beacon(wiphy, channel, gfp);\n\t} else {\n\t\tif (capability & WLAN_CAPABILITY_ESS)\n\t\t\tregulatory_hint_found_beacon(wiphy, channel, gfp);\n\t}\n\n\ties = kzalloc(sizeof(*ies) + ielen, gfp);\n\tif (!ies)\n\t\treturn NULL;\n\ties->len = ielen;\n\ties->tsf = le64_to_cpu(mgmt->u.probe_resp.timestamp);\n\ties->from_beacon = ieee80211_is_beacon(mgmt->frame_control) ||\n\t\t\t   ieee80211_is_s1g_beacon(mgmt->frame_control);\n\tmemcpy(ies->data, variable, ielen);\n\n\tif (ieee80211_is_probe_resp(mgmt->frame_control))\n\t\trcu_assign_pointer(tmp.pub.proberesp_ies, ies);\n\telse\n\t\trcu_assign_pointer(tmp.pub.beacon_ies, ies);\n\trcu_assign_pointer(tmp.pub.ies, ies);\n\n\tmemcpy(tmp.pub.bssid, bssid, ETH_ALEN);\n\ttmp.pub.beacon_interval = beacon_int;\n\ttmp.pub.capability = capability;\n\ttmp.pub.channel = channel;\n\ttmp.pub.scan_width = data->scan_width;\n\ttmp.pub.signal = data->signal;\n\ttmp.ts_boottime = data->boottime_ns;\n\ttmp.parent_tsf = data->parent_tsf;\n\ttmp.pub.chains = data->chains;\n\tmemcpy(tmp.pub.chain_signal, data->chain_signal, IEEE80211_MAX_CHAINS);\n\tether_addr_copy(tmp.parent_bssid, data->parent_bssid);\n\n\tsignal_valid = data->chan == channel;\n\tspin_lock_bh(&rdev->bss_lock);\n\tres = __cfg80211_bss_update(rdev, &tmp, signal_valid, jiffies);\n\tif (!res)\n\t\tgoto drop;\n\n\trdev_inform_bss(rdev, &res->pub, ies, data->drv_data);\n\n\tspin_unlock_bh(&rdev->bss_lock);\n\n\ttrace_cfg80211_return_bss(&res->pub);\n\t \n\treturn &res->pub;\n\ndrop:\n\tspin_unlock_bh(&rdev->bss_lock);\n\treturn NULL;\n}\n\nstruct cfg80211_bss *\ncfg80211_inform_bss_frame_data(struct wiphy *wiphy,\n\t\t\t       struct cfg80211_inform_bss *data,\n\t\t\t       struct ieee80211_mgmt *mgmt, size_t len,\n\t\t\t       gfp_t gfp)\n{\n\tstruct cfg80211_inform_single_bss_data inform_data = {\n\t\t.drv_data = data,\n\t\t.ie = mgmt->u.probe_resp.variable,\n\t\t.ielen = len - offsetof(struct ieee80211_mgmt,\n\t\t\t\t\tu.probe_resp.variable),\n\t};\n\tstruct cfg80211_bss *res;\n\n\tres = cfg80211_inform_single_bss_frame_data(wiphy, data, mgmt,\n\t\t\t\t\t\t    len, gfp);\n\tif (!res)\n\t\treturn NULL;\n\n\t \n\tif (ieee80211_is_s1g_beacon(mgmt->frame_control))\n\t\treturn res;\n\n\tinform_data.ftype = ieee80211_is_beacon(mgmt->frame_control) ?\n\t\tCFG80211_BSS_FTYPE_BEACON : CFG80211_BSS_FTYPE_PRESP;\n\tmemcpy(inform_data.bssid, mgmt->bssid, ETH_ALEN);\n\tinform_data.tsf = le64_to_cpu(mgmt->u.probe_resp.timestamp);\n\tinform_data.beacon_interval =\n\t\tle16_to_cpu(mgmt->u.probe_resp.beacon_int);\n\n\t \n\tcfg80211_parse_mbssid_data(wiphy, &inform_data, res, gfp);\n\n\tcfg80211_parse_ml_sta_data(wiphy, &inform_data, res, gfp);\n\n\treturn res;\n}\nEXPORT_SYMBOL(cfg80211_inform_bss_frame_data);\n\nvoid cfg80211_ref_bss(struct wiphy *wiphy, struct cfg80211_bss *pub)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (!pub)\n\t\treturn;\n\n\tspin_lock_bh(&rdev->bss_lock);\n\tbss_ref_get(rdev, bss_from_pub(pub));\n\tspin_unlock_bh(&rdev->bss_lock);\n}\nEXPORT_SYMBOL(cfg80211_ref_bss);\n\nvoid cfg80211_put_bss(struct wiphy *wiphy, struct cfg80211_bss *pub)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\n\tif (!pub)\n\t\treturn;\n\n\tspin_lock_bh(&rdev->bss_lock);\n\tbss_ref_put(rdev, bss_from_pub(pub));\n\tspin_unlock_bh(&rdev->bss_lock);\n}\nEXPORT_SYMBOL(cfg80211_put_bss);\n\nvoid cfg80211_unlink_bss(struct wiphy *wiphy, struct cfg80211_bss *pub)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct cfg80211_internal_bss *bss, *tmp1;\n\tstruct cfg80211_bss *nontrans_bss, *tmp;\n\n\tif (WARN_ON(!pub))\n\t\treturn;\n\n\tbss = bss_from_pub(pub);\n\n\tspin_lock_bh(&rdev->bss_lock);\n\tif (list_empty(&bss->list))\n\t\tgoto out;\n\n\tlist_for_each_entry_safe(nontrans_bss, tmp,\n\t\t\t\t &pub->nontrans_list,\n\t\t\t\t nontrans_list) {\n\t\ttmp1 = bss_from_pub(nontrans_bss);\n\t\tif (__cfg80211_unlink_bss(rdev, tmp1))\n\t\t\trdev->bss_generation++;\n\t}\n\n\tif (__cfg80211_unlink_bss(rdev, bss))\n\t\trdev->bss_generation++;\nout:\n\tspin_unlock_bh(&rdev->bss_lock);\n}\nEXPORT_SYMBOL(cfg80211_unlink_bss);\n\nvoid cfg80211_bss_iter(struct wiphy *wiphy,\n\t\t       struct cfg80211_chan_def *chandef,\n\t\t       void (*iter)(struct wiphy *wiphy,\n\t\t\t\t    struct cfg80211_bss *bss,\n\t\t\t\t    void *data),\n\t\t       void *iter_data)\n{\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct cfg80211_internal_bss *bss;\n\n\tspin_lock_bh(&rdev->bss_lock);\n\n\tlist_for_each_entry(bss, &rdev->bss_list, list) {\n\t\tif (!chandef || cfg80211_is_sub_chan(chandef, bss->pub.channel,\n\t\t\t\t\t\t     false))\n\t\t\titer(wiphy, &bss->pub, iter_data);\n\t}\n\n\tspin_unlock_bh(&rdev->bss_lock);\n}\nEXPORT_SYMBOL(cfg80211_bss_iter);\n\nvoid cfg80211_update_assoc_bss_entry(struct wireless_dev *wdev,\n\t\t\t\t     unsigned int link_id,\n\t\t\t\t     struct ieee80211_channel *chan)\n{\n\tstruct wiphy *wiphy = wdev->wiphy;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\n\tstruct cfg80211_internal_bss *cbss = wdev->links[link_id].client.current_bss;\n\tstruct cfg80211_internal_bss *new = NULL;\n\tstruct cfg80211_internal_bss *bss;\n\tstruct cfg80211_bss *nontrans_bss;\n\tstruct cfg80211_bss *tmp;\n\n\tspin_lock_bh(&rdev->bss_lock);\n\n\t \n\tif (cbss->pub.channel == chan)\n\t\tgoto done;\n\n\t \n\tif (cbss->pub.transmitted_bss)\n\t\tcbss = bss_from_pub(cbss->pub.transmitted_bss);\n\n\tcbss->pub.channel = chan;\n\n\tlist_for_each_entry(bss, &rdev->bss_list, list) {\n\t\tif (!cfg80211_bss_type_match(bss->pub.capability,\n\t\t\t\t\t     bss->pub.channel->band,\n\t\t\t\t\t     wdev->conn_bss_type))\n\t\t\tcontinue;\n\n\t\tif (bss == cbss)\n\t\t\tcontinue;\n\n\t\tif (!cmp_bss(&bss->pub, &cbss->pub, BSS_CMP_REGULAR)) {\n\t\t\tnew = bss;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (new) {\n\t\t \n\t\tif (cfg80211_update_known_bss(rdev, cbss, new, false)) {\n\t\t\tnew->pub.proberesp_ies = NULL;\n\t\t\tnew->pub.beacon_ies = NULL;\n\t\t}\n\n\t\tlist_for_each_entry_safe(nontrans_bss, tmp,\n\t\t\t\t\t &new->pub.nontrans_list,\n\t\t\t\t\t nontrans_list) {\n\t\t\tbss = bss_from_pub(nontrans_bss);\n\t\t\tif (__cfg80211_unlink_bss(rdev, bss))\n\t\t\t\trdev->bss_generation++;\n\t\t}\n\n\t\tWARN_ON(atomic_read(&new->hold));\n\t\tif (!WARN_ON(!__cfg80211_unlink_bss(rdev, new)))\n\t\t\trdev->bss_generation++;\n\t}\n\n\trb_erase(&cbss->rbn, &rdev->bss_tree);\n\trb_insert_bss(rdev, cbss);\n\trdev->bss_generation++;\n\n\tlist_for_each_entry_safe(nontrans_bss, tmp,\n\t\t\t\t &cbss->pub.nontrans_list,\n\t\t\t\t nontrans_list) {\n\t\tbss = bss_from_pub(nontrans_bss);\n\t\tbss->pub.channel = chan;\n\t\trb_erase(&bss->rbn, &rdev->bss_tree);\n\t\trb_insert_bss(rdev, bss);\n\t\trdev->bss_generation++;\n\t}\n\ndone:\n\tspin_unlock_bh(&rdev->bss_lock);\n}\n\n#ifdef CONFIG_CFG80211_WEXT\nstatic struct cfg80211_registered_device *\ncfg80211_get_dev_from_ifindex(struct net *net, int ifindex)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct net_device *dev;\n\n\tASSERT_RTNL();\n\n\tdev = dev_get_by_index(net, ifindex);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\tif (dev->ieee80211_ptr)\n\t\trdev = wiphy_to_rdev(dev->ieee80211_ptr->wiphy);\n\telse\n\t\trdev = ERR_PTR(-ENODEV);\n\tdev_put(dev);\n\treturn rdev;\n}\n\nint cfg80211_wext_siwscan(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wiphy *wiphy;\n\tstruct iw_scan_req *wreq = NULL;\n\tstruct cfg80211_scan_request *creq;\n\tint i, err, n_channels = 0;\n\tenum nl80211_band band;\n\n\tif (!netif_running(dev))\n\t\treturn -ENETDOWN;\n\n\tif (wrqu->data.length == sizeof(struct iw_scan_req))\n\t\twreq = (struct iw_scan_req *)extra;\n\n\trdev = cfg80211_get_dev_from_ifindex(dev_net(dev), dev->ifindex);\n\n\tif (IS_ERR(rdev))\n\t\treturn PTR_ERR(rdev);\n\n\tif (rdev->scan_req || rdev->scan_msg)\n\t\treturn -EBUSY;\n\n\twiphy = &rdev->wiphy;\n\n\t \n\tif (wreq && wreq->num_channels)\n\t\tn_channels = wreq->num_channels;\n\telse\n\t\tn_channels = ieee80211_get_num_supported_channels(wiphy);\n\n\tcreq = kzalloc(sizeof(*creq) + sizeof(struct cfg80211_ssid) +\n\t\t       n_channels * sizeof(void *),\n\t\t       GFP_ATOMIC);\n\tif (!creq)\n\t\treturn -ENOMEM;\n\n\tcreq->wiphy = wiphy;\n\tcreq->wdev = dev->ieee80211_ptr;\n\t \n\tcreq->ssids = (void *)&creq->channels[n_channels];\n\tcreq->n_channels = n_channels;\n\tcreq->n_ssids = 1;\n\tcreq->scan_start = jiffies;\n\n\t \n\ti = 0;\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tint j;\n\n\t\tif (!wiphy->bands[band])\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t \n\t\t\tif (wiphy->bands[band]->channels[j].flags &\n\t\t\t\t\t\tIEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (wreq && wreq->num_channels) {\n\t\t\t\tint k;\n\t\t\t\tint wiphy_freq = wiphy->bands[band]->channels[j].center_freq;\n\t\t\t\tfor (k = 0; k < wreq->num_channels; k++) {\n\t\t\t\t\tstruct iw_freq *freq =\n\t\t\t\t\t\t&wreq->channel_list[k];\n\t\t\t\t\tint wext_freq =\n\t\t\t\t\t\tcfg80211_wext_freq(freq);\n\n\t\t\t\t\tif (wext_freq == wiphy_freq)\n\t\t\t\t\t\tgoto wext_freq_found;\n\t\t\t\t}\n\t\t\t\tgoto wext_freq_not_found;\n\t\t\t}\n\n\t\twext_freq_found:\n\t\t\tcreq->channels[i] = &wiphy->bands[band]->channels[j];\n\t\t\ti++;\n\t\twext_freq_not_found: ;\n\t\t}\n\t}\n\t \n\tif (!i) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tcreq->n_channels = i;\n\n\t \n\tif (wreq) {\n\t\tif (wrqu->data.flags & IW_SCAN_THIS_ESSID) {\n\t\t\tif (wreq->essid_len > IEEE80211_MAX_SSID_LEN) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(creq->ssids[0].ssid, wreq->essid, wreq->essid_len);\n\t\t\tcreq->ssids[0].ssid_len = wreq->essid_len;\n\t\t}\n\t\tif (wreq->scan_type == IW_SCAN_TYPE_PASSIVE)\n\t\t\tcreq->n_ssids = 0;\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tif (wiphy->bands[i])\n\t\t\tcreq->rates[i] = (1 << wiphy->bands[i]->n_bitrates) - 1;\n\n\teth_broadcast_addr(creq->bssid);\n\n\twiphy_lock(&rdev->wiphy);\n\n\trdev->scan_req = creq;\n\terr = rdev_scan(rdev, creq);\n\tif (err) {\n\t\trdev->scan_req = NULL;\n\t\t \n\t} else {\n\t\tnl80211_send_scan_start(rdev, dev->ieee80211_ptr);\n\t\t \n\t\tcreq = NULL;\n\t\tdev_hold(dev);\n\t}\n\twiphy_unlock(&rdev->wiphy);\n out:\n\tkfree(creq);\n\treturn err;\n}\nEXPORT_WEXT_HANDLER(cfg80211_wext_siwscan);\n\nstatic char *ieee80211_scan_add_ies(struct iw_request_info *info,\n\t\t\t\t    const struct cfg80211_bss_ies *ies,\n\t\t\t\t    char *current_ev, char *end_buf)\n{\n\tconst u8 *pos, *end, *next;\n\tstruct iw_event iwe;\n\n\tif (!ies)\n\t\treturn current_ev;\n\n\t \n\tpos = ies->data;\n\tend = pos + ies->len;\n\n\twhile (end - pos > IW_GENERIC_IE_MAX) {\n\t\tnext = pos + 2 + pos[1];\n\t\twhile (next + 2 + next[1] - pos < IW_GENERIC_IE_MAX)\n\t\t\tnext = next + 2 + next[1];\n\n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = IWEVGENIE;\n\t\tiwe.u.data.length = next - pos;\n\t\tcurrent_ev = iwe_stream_add_point_check(info, current_ev,\n\t\t\t\t\t\t\tend_buf, &iwe,\n\t\t\t\t\t\t\t(void *)pos);\n\t\tif (IS_ERR(current_ev))\n\t\t\treturn current_ev;\n\t\tpos = next;\n\t}\n\n\tif (end > pos) {\n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = IWEVGENIE;\n\t\tiwe.u.data.length = end - pos;\n\t\tcurrent_ev = iwe_stream_add_point_check(info, current_ev,\n\t\t\t\t\t\t\tend_buf, &iwe,\n\t\t\t\t\t\t\t(void *)pos);\n\t\tif (IS_ERR(current_ev))\n\t\t\treturn current_ev;\n\t}\n\n\treturn current_ev;\n}\n\nstatic char *\nieee80211_bss(struct wiphy *wiphy, struct iw_request_info *info,\n\t      struct cfg80211_internal_bss *bss, char *current_ev,\n\t      char *end_buf)\n{\n\tconst struct cfg80211_bss_ies *ies;\n\tstruct iw_event iwe;\n\tconst u8 *ie;\n\tu8 buf[50];\n\tu8 *cfg, *p, *tmp;\n\tint rem, i, sig;\n\tbool ismesh = false;\n\n\tmemset(&iwe, 0, sizeof(iwe));\n\tiwe.cmd = SIOCGIWAP;\n\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\tmemcpy(iwe.u.ap_addr.sa_data, bss->pub.bssid, ETH_ALEN);\n\tcurrent_ev = iwe_stream_add_event_check(info, current_ev, end_buf, &iwe,\n\t\t\t\t\t\tIW_EV_ADDR_LEN);\n\tif (IS_ERR(current_ev))\n\t\treturn current_ev;\n\n\tmemset(&iwe, 0, sizeof(iwe));\n\tiwe.cmd = SIOCGIWFREQ;\n\tiwe.u.freq.m = ieee80211_frequency_to_channel(bss->pub.channel->center_freq);\n\tiwe.u.freq.e = 0;\n\tcurrent_ev = iwe_stream_add_event_check(info, current_ev, end_buf, &iwe,\n\t\t\t\t\t\tIW_EV_FREQ_LEN);\n\tif (IS_ERR(current_ev))\n\t\treturn current_ev;\n\n\tmemset(&iwe, 0, sizeof(iwe));\n\tiwe.cmd = SIOCGIWFREQ;\n\tiwe.u.freq.m = bss->pub.channel->center_freq;\n\tiwe.u.freq.e = 6;\n\tcurrent_ev = iwe_stream_add_event_check(info, current_ev, end_buf, &iwe,\n\t\t\t\t\t\tIW_EV_FREQ_LEN);\n\tif (IS_ERR(current_ev))\n\t\treturn current_ev;\n\n\tif (wiphy->signal_type != CFG80211_SIGNAL_TYPE_NONE) {\n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = IWEVQUAL;\n\t\tiwe.u.qual.updated = IW_QUAL_LEVEL_UPDATED |\n\t\t\t\t     IW_QUAL_NOISE_INVALID |\n\t\t\t\t     IW_QUAL_QUAL_UPDATED;\n\t\tswitch (wiphy->signal_type) {\n\t\tcase CFG80211_SIGNAL_TYPE_MBM:\n\t\t\tsig = bss->pub.signal / 100;\n\t\t\tiwe.u.qual.level = sig;\n\t\t\tiwe.u.qual.updated |= IW_QUAL_DBM;\n\t\t\tif (sig < -110)\t\t \n\t\t\t\tsig = -110;\n\t\t\telse if (sig > -40)\t \n\t\t\t\tsig = -40;\n\t\t\t \n\t\t\tiwe.u.qual.qual = sig + 110;\n\t\t\tbreak;\n\t\tcase CFG80211_SIGNAL_TYPE_UNSPEC:\n\t\t\tiwe.u.qual.level = bss->pub.signal;\n\t\t\t \n\t\t\tiwe.u.qual.qual = bss->pub.signal;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tcurrent_ev = iwe_stream_add_event_check(info, current_ev,\n\t\t\t\t\t\t\tend_buf, &iwe,\n\t\t\t\t\t\t\tIW_EV_QUAL_LEN);\n\t\tif (IS_ERR(current_ev))\n\t\t\treturn current_ev;\n\t}\n\n\tmemset(&iwe, 0, sizeof(iwe));\n\tiwe.cmd = SIOCGIWENCODE;\n\tif (bss->pub.capability & WLAN_CAPABILITY_PRIVACY)\n\t\tiwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\n\telse\n\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\tiwe.u.data.length = 0;\n\tcurrent_ev = iwe_stream_add_point_check(info, current_ev, end_buf,\n\t\t\t\t\t\t&iwe, \"\");\n\tif (IS_ERR(current_ev))\n\t\treturn current_ev;\n\n\trcu_read_lock();\n\ties = rcu_dereference(bss->pub.ies);\n\trem = ies->len;\n\tie = ies->data;\n\n\twhile (rem >= 2) {\n\t\t \n\t\tif (ie[1] > rem - 2)\n\t\t\tbreak;\n\n\t\tswitch (ie[0]) {\n\t\tcase WLAN_EID_SSID:\n\t\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\t\tiwe.cmd = SIOCGIWESSID;\n\t\t\tiwe.u.data.length = ie[1];\n\t\t\tiwe.u.data.flags = 1;\n\t\t\tcurrent_ev = iwe_stream_add_point_check(info,\n\t\t\t\t\t\t\t\tcurrent_ev,\n\t\t\t\t\t\t\t\tend_buf, &iwe,\n\t\t\t\t\t\t\t\t(u8 *)ie + 2);\n\t\t\tif (IS_ERR(current_ev))\n\t\t\t\tgoto unlock;\n\t\t\tbreak;\n\t\tcase WLAN_EID_MESH_ID:\n\t\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\t\tiwe.cmd = SIOCGIWESSID;\n\t\t\tiwe.u.data.length = ie[1];\n\t\t\tiwe.u.data.flags = 1;\n\t\t\tcurrent_ev = iwe_stream_add_point_check(info,\n\t\t\t\t\t\t\t\tcurrent_ev,\n\t\t\t\t\t\t\t\tend_buf, &iwe,\n\t\t\t\t\t\t\t\t(u8 *)ie + 2);\n\t\t\tif (IS_ERR(current_ev))\n\t\t\t\tgoto unlock;\n\t\t\tbreak;\n\t\tcase WLAN_EID_MESH_CONFIG:\n\t\t\tismesh = true;\n\t\t\tif (ie[1] != sizeof(struct ieee80211_meshconf_ie))\n\t\t\t\tbreak;\n\t\t\tcfg = (u8 *)ie + 2;\n\t\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\t\tiwe.cmd = IWEVCUSTOM;\n\t\t\tsprintf(buf, \"Mesh Network Path Selection Protocol ID: \"\n\t\t\t\t\"0x%02X\", cfg[0]);\n\t\t\tiwe.u.data.length = strlen(buf);\n\t\t\tcurrent_ev = iwe_stream_add_point_check(info,\n\t\t\t\t\t\t\t\tcurrent_ev,\n\t\t\t\t\t\t\t\tend_buf,\n\t\t\t\t\t\t\t\t&iwe, buf);\n\t\t\tif (IS_ERR(current_ev))\n\t\t\t\tgoto unlock;\n\t\t\tsprintf(buf, \"Path Selection Metric ID: 0x%02X\",\n\t\t\t\tcfg[1]);\n\t\t\tiwe.u.data.length = strlen(buf);\n\t\t\tcurrent_ev = iwe_stream_add_point_check(info,\n\t\t\t\t\t\t\t\tcurrent_ev,\n\t\t\t\t\t\t\t\tend_buf,\n\t\t\t\t\t\t\t\t&iwe, buf);\n\t\t\tif (IS_ERR(current_ev))\n\t\t\t\tgoto unlock;\n\t\t\tsprintf(buf, \"Congestion Control Mode ID: 0x%02X\",\n\t\t\t\tcfg[2]);\n\t\t\tiwe.u.data.length = strlen(buf);\n\t\t\tcurrent_ev = iwe_stream_add_point_check(info,\n\t\t\t\t\t\t\t\tcurrent_ev,\n\t\t\t\t\t\t\t\tend_buf,\n\t\t\t\t\t\t\t\t&iwe, buf);\n\t\t\tif (IS_ERR(current_ev))\n\t\t\t\tgoto unlock;\n\t\t\tsprintf(buf, \"Synchronization ID: 0x%02X\", cfg[3]);\n\t\t\tiwe.u.data.length = strlen(buf);\n\t\t\tcurrent_ev = iwe_stream_add_point_check(info,\n\t\t\t\t\t\t\t\tcurrent_ev,\n\t\t\t\t\t\t\t\tend_buf,\n\t\t\t\t\t\t\t\t&iwe, buf);\n\t\t\tif (IS_ERR(current_ev))\n\t\t\t\tgoto unlock;\n\t\t\tsprintf(buf, \"Authentication ID: 0x%02X\", cfg[4]);\n\t\t\tiwe.u.data.length = strlen(buf);\n\t\t\tcurrent_ev = iwe_stream_add_point_check(info,\n\t\t\t\t\t\t\t\tcurrent_ev,\n\t\t\t\t\t\t\t\tend_buf,\n\t\t\t\t\t\t\t\t&iwe, buf);\n\t\t\tif (IS_ERR(current_ev))\n\t\t\t\tgoto unlock;\n\t\t\tsprintf(buf, \"Formation Info: 0x%02X\", cfg[5]);\n\t\t\tiwe.u.data.length = strlen(buf);\n\t\t\tcurrent_ev = iwe_stream_add_point_check(info,\n\t\t\t\t\t\t\t\tcurrent_ev,\n\t\t\t\t\t\t\t\tend_buf,\n\t\t\t\t\t\t\t\t&iwe, buf);\n\t\t\tif (IS_ERR(current_ev))\n\t\t\t\tgoto unlock;\n\t\t\tsprintf(buf, \"Capabilities: 0x%02X\", cfg[6]);\n\t\t\tiwe.u.data.length = strlen(buf);\n\t\t\tcurrent_ev = iwe_stream_add_point_check(info,\n\t\t\t\t\t\t\t\tcurrent_ev,\n\t\t\t\t\t\t\t\tend_buf,\n\t\t\t\t\t\t\t\t&iwe, buf);\n\t\t\tif (IS_ERR(current_ev))\n\t\t\t\tgoto unlock;\n\t\t\tbreak;\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\t\t \n\t\t\tp = current_ev + iwe_stream_lcp_len(info);\n\n\t\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\t\tiwe.cmd = SIOCGIWRATE;\n\t\t\t \n\t\t\tiwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\n\n\t\t\tfor (i = 0; i < ie[1]; i++) {\n\t\t\t\tiwe.u.bitrate.value =\n\t\t\t\t\t((ie[i + 2] & 0x7f) * 500000);\n\t\t\t\ttmp = p;\n\t\t\t\tp = iwe_stream_add_value(info, current_ev, p,\n\t\t\t\t\t\t\t end_buf, &iwe,\n\t\t\t\t\t\t\t IW_EV_PARAM_LEN);\n\t\t\t\tif (p == tmp) {\n\t\t\t\t\tcurrent_ev = ERR_PTR(-E2BIG);\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent_ev = p;\n\t\t\tbreak;\n\t\t}\n\t\trem -= ie[1] + 2;\n\t\tie += ie[1] + 2;\n\t}\n\n\tif (bss->pub.capability & (WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS) ||\n\t    ismesh) {\n\t\tmemset(&iwe, 0, sizeof(iwe));\n\t\tiwe.cmd = SIOCGIWMODE;\n\t\tif (ismesh)\n\t\t\tiwe.u.mode = IW_MODE_MESH;\n\t\telse if (bss->pub.capability & WLAN_CAPABILITY_ESS)\n\t\t\tiwe.u.mode = IW_MODE_MASTER;\n\t\telse\n\t\t\tiwe.u.mode = IW_MODE_ADHOC;\n\t\tcurrent_ev = iwe_stream_add_event_check(info, current_ev,\n\t\t\t\t\t\t\tend_buf, &iwe,\n\t\t\t\t\t\t\tIW_EV_UINT_LEN);\n\t\tif (IS_ERR(current_ev))\n\t\t\tgoto unlock;\n\t}\n\n\tmemset(&iwe, 0, sizeof(iwe));\n\tiwe.cmd = IWEVCUSTOM;\n\tsprintf(buf, \"tsf=%016llx\", (unsigned long long)(ies->tsf));\n\tiwe.u.data.length = strlen(buf);\n\tcurrent_ev = iwe_stream_add_point_check(info, current_ev, end_buf,\n\t\t\t\t\t\t&iwe, buf);\n\tif (IS_ERR(current_ev))\n\t\tgoto unlock;\n\tmemset(&iwe, 0, sizeof(iwe));\n\tiwe.cmd = IWEVCUSTOM;\n\tsprintf(buf, \" Last beacon: %ums ago\",\n\t\telapsed_jiffies_msecs(bss->ts));\n\tiwe.u.data.length = strlen(buf);\n\tcurrent_ev = iwe_stream_add_point_check(info, current_ev,\n\t\t\t\t\t\tend_buf, &iwe, buf);\n\tif (IS_ERR(current_ev))\n\t\tgoto unlock;\n\n\tcurrent_ev = ieee80211_scan_add_ies(info, ies, current_ev, end_buf);\n\n unlock:\n\trcu_read_unlock();\n\treturn current_ev;\n}\n\n\nstatic int ieee80211_scan_results(struct cfg80211_registered_device *rdev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  char *buf, size_t len)\n{\n\tchar *current_ev = buf;\n\tchar *end_buf = buf + len;\n\tstruct cfg80211_internal_bss *bss;\n\tint err = 0;\n\n\tspin_lock_bh(&rdev->bss_lock);\n\tcfg80211_bss_expire(rdev);\n\n\tlist_for_each_entry(bss, &rdev->bss_list, list) {\n\t\tif (buf + len - current_ev <= IW_EV_ADDR_LEN) {\n\t\t\terr = -E2BIG;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent_ev = ieee80211_bss(&rdev->wiphy, info, bss,\n\t\t\t\t\t   current_ev, end_buf);\n\t\tif (IS_ERR(current_ev)) {\n\t\t\terr = PTR_ERR(current_ev);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&rdev->bss_lock);\n\n\tif (err)\n\t\treturn err;\n\treturn current_ev - buf;\n}\n\n\nint cfg80211_wext_giwscan(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct cfg80211_registered_device *rdev;\n\tint res;\n\n\tif (!netif_running(dev))\n\t\treturn -ENETDOWN;\n\n\trdev = cfg80211_get_dev_from_ifindex(dev_net(dev), dev->ifindex);\n\n\tif (IS_ERR(rdev))\n\t\treturn PTR_ERR(rdev);\n\n\tif (rdev->scan_req || rdev->scan_msg)\n\t\treturn -EAGAIN;\n\n\tres = ieee80211_scan_results(rdev, info, extra, data->length);\n\tdata->length = 0;\n\tif (res >= 0) {\n\t\tdata->length = res;\n\t\tres = 0;\n\t}\n\n\treturn res;\n}\nEXPORT_WEXT_HANDLER(cfg80211_wext_giwscan);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}