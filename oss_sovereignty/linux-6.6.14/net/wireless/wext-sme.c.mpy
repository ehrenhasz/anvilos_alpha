{
  "module_name": "wext-sme.c",
  "hash_id": "0ebc5cb161c01f79144f053d16e9a52f3cc1bdcae5eb3e1e0cd70c2424af3947",
  "original_prompt": "Ingested from linux-6.6.14/net/wireless/wext-sme.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/slab.h>\n#include <net/cfg80211.h>\n#include <net/cfg80211-wext.h>\n#include \"wext-compat.h\"\n#include \"nl80211.h\"\n\nint cfg80211_mgd_wext_connect(struct cfg80211_registered_device *rdev,\n\t\t\t      struct wireless_dev *wdev)\n{\n\tstruct cfg80211_cached_keys *ck = NULL;\n\tconst u8 *prev_bssid = NULL;\n\tint err, i;\n\n\tASSERT_RTNL();\n\tASSERT_WDEV_LOCK(wdev);\n\n\tif (!netif_running(wdev->netdev))\n\t\treturn 0;\n\n\twdev->wext.connect.ie = wdev->wext.ie;\n\twdev->wext.connect.ie_len = wdev->wext.ie_len;\n\n\t \n\twdev->wext.connect.bg_scan_period = -1;\n\n\tif (wdev->wext.keys) {\n\t\twdev->wext.keys->def = wdev->wext.default_key;\n\t\tif (wdev->wext.default_key != -1)\n\t\t\twdev->wext.connect.privacy = true;\n\t}\n\n\tif (!wdev->wext.connect.ssid_len)\n\t\treturn 0;\n\n\tif (wdev->wext.keys && wdev->wext.keys->def != -1) {\n\t\tck = kmemdup(wdev->wext.keys, sizeof(*ck), GFP_KERNEL);\n\t\tif (!ck)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tck->params[i].key = ck->data[i];\n\t}\n\n\tif (wdev->wext.prev_bssid_valid)\n\t\tprev_bssid = wdev->wext.prev_bssid;\n\n\terr = cfg80211_connect(rdev, wdev->netdev,\n\t\t\t       &wdev->wext.connect, ck, prev_bssid);\n\tif (err)\n\t\tkfree_sensitive(ck);\n\n\treturn err;\n}\n\nint cfg80211_mgd_wext_siwfreq(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      struct iw_freq *wextfreq, char *extra)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tstruct ieee80211_channel *chan = NULL;\n\tint err, freq;\n\n\t \n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\n\tfreq = cfg80211_wext_freq(wextfreq);\n\tif (freq < 0)\n\t\treturn freq;\n\n\tif (freq) {\n\t\tchan = ieee80211_get_channel(wdev->wiphy, freq);\n\t\tif (!chan)\n\t\t\treturn -EINVAL;\n\t\tif (chan->flags & IEEE80211_CHAN_DISABLED)\n\t\t\treturn -EINVAL;\n\t}\n\n\twdev_lock(wdev);\n\n\tif (wdev->conn) {\n\t\tbool event = true;\n\n\t\tif (wdev->wext.connect.channel == chan) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (wdev->wext.connect.ssid_len)\n\t\t\tevent = false;\n\t\terr = cfg80211_disconnect(rdev, dev,\n\t\t\t\t\t  WLAN_REASON_DEAUTH_LEAVING, event);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\twdev->wext.connect.channel = chan;\n\terr = cfg80211_mgd_wext_connect(rdev, wdev);\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nint cfg80211_mgd_wext_giwfreq(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      struct iw_freq *freq, char *extra)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct ieee80211_channel *chan = NULL;\n\n\t \n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\n\tif (wdev->valid_links)\n\t\treturn -EOPNOTSUPP;\n\n\twdev_lock(wdev);\n\tif (wdev->links[0].client.current_bss)\n\t\tchan = wdev->links[0].client.current_bss->pub.channel;\n\telse if (wdev->wext.connect.channel)\n\t\tchan = wdev->wext.connect.channel;\n\twdev_unlock(wdev);\n\n\tif (chan) {\n\t\tfreq->m = chan->center_freq;\n\t\tfreq->e = 6;\n\t\treturn 0;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\nint cfg80211_mgd_wext_siwessid(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tsize_t len = data->length;\n\tint err;\n\n\t \n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\n\tif (!data->flags)\n\t\tlen = 0;\n\n\t \n\tif (len > 0 && ssid[len - 1] == '\\0')\n\t\tlen--;\n\n\twdev_lock(wdev);\n\n\terr = 0;\n\n\tif (wdev->conn) {\n\t\tbool event = true;\n\n\t\tif (wdev->wext.connect.ssid && len &&\n\t\t    len == wdev->wext.connect.ssid_len &&\n\t\t    memcmp(wdev->wext.connect.ssid, ssid, len) == 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (len)\n\t\t\tevent = false;\n\t\terr = cfg80211_disconnect(rdev, dev,\n\t\t\t\t\t  WLAN_REASON_DEAUTH_LEAVING, event);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\twdev->wext.prev_bssid_valid = false;\n\twdev->wext.connect.ssid = wdev->wext.ssid;\n\tmemcpy(wdev->wext.ssid, ssid, len);\n\twdev->wext.connect.ssid_len = len;\n\n\twdev->wext.connect.crypto.control_port = false;\n\twdev->wext.connect.crypto.control_port_ethertype =\n\t\t\t\t\tcpu_to_be16(ETH_P_PAE);\n\n\terr = cfg80211_mgd_wext_connect(rdev, wdev);\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nint cfg80211_mgd_wext_giwessid(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tint ret = 0;\n\n\t \n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\n\tif (wdev->valid_links)\n\t\treturn -EINVAL;\n\n\tdata->flags = 0;\n\n\twdev_lock(wdev);\n\tif (wdev->links[0].client.current_bss) {\n\t\tconst struct element *ssid_elem;\n\n\t\trcu_read_lock();\n\t\tssid_elem = ieee80211_bss_get_elem(\n\t\t\t\t&wdev->links[0].client.current_bss->pub,\n\t\t\t\tWLAN_EID_SSID);\n\t\tif (ssid_elem) {\n\t\t\tdata->flags = 1;\n\t\t\tdata->length = ssid_elem->datalen;\n\t\t\tif (data->length > IW_ESSID_MAX_SIZE)\n\t\t\t\tret = -EINVAL;\n\t\t\telse\n\t\t\t\tmemcpy(ssid, ssid_elem->data, data->length);\n\t\t}\n\t\trcu_read_unlock();\n\t} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {\n\t\tdata->flags = 1;\n\t\tdata->length = wdev->wext.connect.ssid_len;\n\t\tmemcpy(ssid, wdev->wext.connect.ssid, data->length);\n\t}\n\twdev_unlock(wdev);\n\n\treturn ret;\n}\n\nint cfg80211_mgd_wext_siwap(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    struct sockaddr *ap_addr, char *extra)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tu8 *bssid = ap_addr->sa_data;\n\tint err;\n\n\t \n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\n\tif (ap_addr->sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\n\t \n\tif (is_zero_ether_addr(bssid) || is_broadcast_ether_addr(bssid))\n\t\tbssid = NULL;\n\n\twdev_lock(wdev);\n\n\tif (wdev->conn) {\n\t\terr = 0;\n\t\t \n\t\tif (!bssid && !wdev->wext.connect.bssid)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (wdev->wext.connect.bssid && bssid &&\n\t\t    ether_addr_equal(bssid, wdev->wext.connect.bssid))\n\t\t\tgoto out;\n\n\t\terr = cfg80211_disconnect(rdev, dev,\n\t\t\t\t\t  WLAN_REASON_DEAUTH_LEAVING, false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (bssid) {\n\t\tmemcpy(wdev->wext.bssid, bssid, ETH_ALEN);\n\t\twdev->wext.connect.bssid = wdev->wext.bssid;\n\t} else\n\t\twdev->wext.connect.bssid = NULL;\n\n\terr = cfg80211_mgd_wext_connect(rdev, wdev);\n out:\n\twdev_unlock(wdev);\n\treturn err;\n}\n\nint cfg80211_mgd_wext_giwap(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    struct sockaddr *ap_addr, char *extra)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t \n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\n\tap_addr->sa_family = ARPHRD_ETHER;\n\n\twdev_lock(wdev);\n\tif (wdev->valid_links) {\n\t\twdev_unlock(wdev);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (wdev->links[0].client.current_bss)\n\t\tmemcpy(ap_addr->sa_data,\n\t\t       wdev->links[0].client.current_bss->pub.bssid,\n\t\t       ETH_ALEN);\n\telse\n\t\teth_zero_addr(ap_addr->sa_data);\n\twdev_unlock(wdev);\n\n\treturn 0;\n}\n\nint cfg80211_wext_siwgenie(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *data = &wrqu->data;\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);\n\tu8 *ie = extra;\n\tint ie_len = data->length, err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!ie_len)\n\t\tie = NULL;\n\n\twiphy_lock(wdev->wiphy);\n\twdev_lock(wdev);\n\n\t \n\terr = 0;\n\tif (wdev->wext.ie_len == ie_len &&\n\t    memcmp(wdev->wext.ie, ie, ie_len) == 0)\n\t\tgoto out;\n\n\tif (ie_len) {\n\t\tie = kmemdup(extra, ie_len, GFP_KERNEL);\n\t\tif (!ie) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tie = NULL;\n\n\tkfree(wdev->wext.ie);\n\twdev->wext.ie = ie;\n\twdev->wext.ie_len = ie_len;\n\n\tif (wdev->conn) {\n\t\terr = cfg80211_disconnect(rdev, dev,\n\t\t\t\t\t  WLAN_REASON_DEAUTH_LEAVING, false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\terr = 0;\n out:\n\twdev_unlock(wdev);\n\twiphy_unlock(wdev->wiphy);\n\treturn err;\n}\n\nint cfg80211_wext_siwmlme(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct iw_mlme *mlme = (struct iw_mlme *)extra;\n\tstruct cfg80211_registered_device *rdev;\n\tint err;\n\n\tif (!wdev)\n\t\treturn -EOPNOTSUPP;\n\n\trdev = wiphy_to_rdev(wdev->wiphy);\n\n\tif (wdev->iftype != NL80211_IFTYPE_STATION)\n\t\treturn -EINVAL;\n\n\tif (mlme->addr.sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\n\twiphy_lock(&rdev->wiphy);\n\twdev_lock(wdev);\n\tswitch (mlme->cmd) {\n\tcase IW_MLME_DEAUTH:\n\tcase IW_MLME_DISASSOC:\n\t\terr = cfg80211_disconnect(rdev, dev, mlme->reason_code, true);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\twdev_unlock(wdev);\n\twiphy_unlock(&rdev->wiphy);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}