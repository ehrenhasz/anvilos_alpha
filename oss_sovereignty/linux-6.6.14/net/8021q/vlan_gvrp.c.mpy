{
  "module_name": "vlan_gvrp.c",
  "hash_id": "f4ff31c718ab24325ff7d0d5e384fcee759a2d6ed67ddf9c2c26a252189151f4",
  "original_prompt": "Ingested from linux-6.6.14/net/8021q/vlan_gvrp.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/if_vlan.h>\n#include <net/garp.h>\n#include \"vlan.h\"\n\n#define GARP_GVRP_ADDRESS\t{ 0x01, 0x80, 0xc2, 0x00, 0x00, 0x21 }\n\nenum gvrp_attributes {\n\tGVRP_ATTR_INVALID,\n\tGVRP_ATTR_VID,\n\t__GVRP_ATTR_MAX\n};\n#define GVRP_ATTR_MAX\t(__GVRP_ATTR_MAX - 1)\n\nstatic struct garp_application vlan_gvrp_app __read_mostly = {\n\t.proto.group_address\t= GARP_GVRP_ADDRESS,\n\t.maxattr\t\t= GVRP_ATTR_MAX,\n\t.type\t\t\t= GARP_APPLICATION_GVRP,\n};\n\nint vlan_gvrp_request_join(const struct net_device *dev)\n{\n\tconst struct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\t__be16 vlan_id = htons(vlan->vlan_id);\n\n\tif (vlan->vlan_proto != htons(ETH_P_8021Q))\n\t\treturn 0;\n\treturn garp_request_join(vlan->real_dev, &vlan_gvrp_app,\n\t\t\t\t &vlan_id, sizeof(vlan_id), GVRP_ATTR_VID);\n}\n\nvoid vlan_gvrp_request_leave(const struct net_device *dev)\n{\n\tconst struct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\t__be16 vlan_id = htons(vlan->vlan_id);\n\n\tif (vlan->vlan_proto != htons(ETH_P_8021Q))\n\t\treturn;\n\tgarp_request_leave(vlan->real_dev, &vlan_gvrp_app,\n\t\t\t   &vlan_id, sizeof(vlan_id), GVRP_ATTR_VID);\n}\n\nint vlan_gvrp_init_applicant(struct net_device *dev)\n{\n\treturn garp_init_applicant(dev, &vlan_gvrp_app);\n}\n\nvoid vlan_gvrp_uninit_applicant(struct net_device *dev)\n{\n\tgarp_uninit_applicant(dev, &vlan_gvrp_app);\n}\n\nint __init vlan_gvrp_init(void)\n{\n\treturn garp_register_application(&vlan_gvrp_app);\n}\n\nvoid vlan_gvrp_uninit(void)\n{\n\tgarp_unregister_application(&vlan_gvrp_app);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}