{
  "module_name": "vlan.c",
  "hash_id": "896212427572d6d685438b266ad2fb350c3ff61ab8d77f8cf872291cf5d76149",
  "original_prompt": "Ingested from linux-6.6.14/net/8021q/vlan.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/rculist.h>\n#include <net/p8022.h>\n#include <net/arp.h>\n#include <linux/rtnetlink.h>\n#include <linux/notifier.h>\n#include <net/rtnetlink.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <linux/uaccess.h>\n\n#include <linux/if_vlan.h>\n#include \"vlan.h\"\n#include \"vlanproc.h\"\n\n#define DRV_VERSION \"1.8\"\n\n \n\nunsigned int vlan_net_id __read_mostly;\n\nconst char vlan_fullname[] = \"802.1Q VLAN Support\";\nconst char vlan_version[] = DRV_VERSION;\n\n \n\nstatic int vlan_group_prealloc_vid(struct vlan_group *vg,\n\t\t\t\t   __be16 vlan_proto, u16 vlan_id)\n{\n\tstruct net_device **array;\n\tunsigned int vidx;\n\tunsigned int size;\n\tint pidx;\n\n\tASSERT_RTNL();\n\n\tpidx  = vlan_proto_idx(vlan_proto);\n\tif (pidx < 0)\n\t\treturn -EINVAL;\n\n\tvidx  = vlan_id / VLAN_GROUP_ARRAY_PART_LEN;\n\tarray = vg->vlan_devices_arrays[pidx][vidx];\n\tif (array != NULL)\n\t\treturn 0;\n\n\tsize = sizeof(struct net_device *) * VLAN_GROUP_ARRAY_PART_LEN;\n\tarray = kzalloc(size, GFP_KERNEL_ACCOUNT);\n\tif (array == NULL)\n\t\treturn -ENOBUFS;\n\n\t \n\tsmp_wmb();\n\n\tvg->vlan_devices_arrays[pidx][vidx] = array;\n\treturn 0;\n}\n\nstatic void vlan_stacked_transfer_operstate(const struct net_device *rootdev,\n\t\t\t\t\t    struct net_device *dev,\n\t\t\t\t\t    struct vlan_dev_priv *vlan)\n{\n\tif (!(vlan->flags & VLAN_FLAG_BRIDGE_BINDING))\n\t\tnetif_stacked_transfer_operstate(rootdev, dev);\n}\n\nvoid unregister_vlan_dev(struct net_device *dev, struct list_head *head)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tstruct net_device *real_dev = vlan->real_dev;\n\tstruct vlan_info *vlan_info;\n\tstruct vlan_group *grp;\n\tu16 vlan_id = vlan->vlan_id;\n\n\tASSERT_RTNL();\n\n\tvlan_info = rtnl_dereference(real_dev->vlan_info);\n\tBUG_ON(!vlan_info);\n\n\tgrp = &vlan_info->grp;\n\n\tgrp->nr_vlan_devs--;\n\n\tif (vlan->flags & VLAN_FLAG_MVRP)\n\t\tvlan_mvrp_request_leave(dev);\n\tif (vlan->flags & VLAN_FLAG_GVRP)\n\t\tvlan_gvrp_request_leave(dev);\n\n\tvlan_group_set_device(grp, vlan->vlan_proto, vlan_id, NULL);\n\n\tnetdev_upper_dev_unlink(real_dev, dev);\n\t \n\tunregister_netdevice_queue(dev, head);\n\n\tif (grp->nr_vlan_devs == 0) {\n\t\tvlan_mvrp_uninit_applicant(real_dev);\n\t\tvlan_gvrp_uninit_applicant(real_dev);\n\t}\n\n\tvlan_vid_del(real_dev, vlan->vlan_proto, vlan_id);\n}\n\nint vlan_check_real_dev(struct net_device *real_dev,\n\t\t\t__be16 protocol, u16 vlan_id,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tconst char *name = real_dev->name;\n\n\tif (real_dev->features & NETIF_F_VLAN_CHALLENGED) {\n\t\tpr_info(\"VLANs not supported on %s\\n\", name);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VLANs not supported on device\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (vlan_find_dev(real_dev, protocol, vlan_id) != NULL) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VLAN device already exists\");\n\t\treturn -EEXIST;\n\t}\n\n\treturn 0;\n}\n\nint register_vlan_dev(struct net_device *dev, struct netlink_ext_ack *extack)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tstruct net_device *real_dev = vlan->real_dev;\n\tu16 vlan_id = vlan->vlan_id;\n\tstruct vlan_info *vlan_info;\n\tstruct vlan_group *grp;\n\tint err;\n\n\terr = vlan_vid_add(real_dev, vlan->vlan_proto, vlan_id);\n\tif (err)\n\t\treturn err;\n\n\tvlan_info = rtnl_dereference(real_dev->vlan_info);\n\t \n\tBUG_ON(!vlan_info);\n\n\tgrp = &vlan_info->grp;\n\tif (grp->nr_vlan_devs == 0) {\n\t\terr = vlan_gvrp_init_applicant(real_dev);\n\t\tif (err < 0)\n\t\t\tgoto out_vid_del;\n\t\terr = vlan_mvrp_init_applicant(real_dev);\n\t\tif (err < 0)\n\t\t\tgoto out_uninit_gvrp;\n\t}\n\n\terr = vlan_group_prealloc_vid(grp, vlan->vlan_proto, vlan_id);\n\tif (err < 0)\n\t\tgoto out_uninit_mvrp;\n\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\tgoto out_uninit_mvrp;\n\n\terr = netdev_upper_dev_link(real_dev, dev, extack);\n\tif (err)\n\t\tgoto out_unregister_netdev;\n\n\tvlan_stacked_transfer_operstate(real_dev, dev, vlan);\n\tlinkwatch_fire_event(dev);  \n\n\t \n\tvlan_group_set_device(grp, vlan->vlan_proto, vlan_id, dev);\n\tgrp->nr_vlan_devs++;\n\n\treturn 0;\n\nout_unregister_netdev:\n\tunregister_netdevice(dev);\nout_uninit_mvrp:\n\tif (grp->nr_vlan_devs == 0)\n\t\tvlan_mvrp_uninit_applicant(real_dev);\nout_uninit_gvrp:\n\tif (grp->nr_vlan_devs == 0)\n\t\tvlan_gvrp_uninit_applicant(real_dev);\nout_vid_del:\n\tvlan_vid_del(real_dev, vlan->vlan_proto, vlan_id);\n\treturn err;\n}\n\n \nstatic int register_vlan_device(struct net_device *real_dev, u16 vlan_id)\n{\n\tstruct net_device *new_dev;\n\tstruct vlan_dev_priv *vlan;\n\tstruct net *net = dev_net(real_dev);\n\tstruct vlan_net *vn = net_generic(net, vlan_net_id);\n\tchar name[IFNAMSIZ];\n\tint err;\n\n\tif (vlan_id >= VLAN_VID_MASK)\n\t\treturn -ERANGE;\n\n\terr = vlan_check_real_dev(real_dev, htons(ETH_P_8021Q), vlan_id,\n\t\t\t\t  NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tswitch (vn->name_type) {\n\tcase VLAN_NAME_TYPE_RAW_PLUS_VID:\n\t\t \n\t\tsnprintf(name, IFNAMSIZ, \"%s.%.4i\", real_dev->name, vlan_id);\n\t\tbreak;\n\tcase VLAN_NAME_TYPE_PLUS_VID_NO_PAD:\n\t\t \n\t\tsnprintf(name, IFNAMSIZ, \"vlan%i\", vlan_id);\n\t\tbreak;\n\tcase VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD:\n\t\t \n\t\tsnprintf(name, IFNAMSIZ, \"%s.%i\", real_dev->name, vlan_id);\n\t\tbreak;\n\tcase VLAN_NAME_TYPE_PLUS_VID:\n\t\t \n\tdefault:\n\t\tsnprintf(name, IFNAMSIZ, \"vlan%.4i\", vlan_id);\n\t}\n\n\tnew_dev = alloc_netdev(sizeof(struct vlan_dev_priv), name,\n\t\t\t       NET_NAME_UNKNOWN, vlan_setup);\n\n\tif (new_dev == NULL)\n\t\treturn -ENOBUFS;\n\n\tdev_net_set(new_dev, net);\n\t \n\tnew_dev->mtu = real_dev->mtu;\n\n\tvlan = vlan_dev_priv(new_dev);\n\tvlan->vlan_proto = htons(ETH_P_8021Q);\n\tvlan->vlan_id = vlan_id;\n\tvlan->real_dev = real_dev;\n\tvlan->dent = NULL;\n\tvlan->flags = VLAN_FLAG_REORDER_HDR;\n\n\tnew_dev->rtnl_link_ops = &vlan_link_ops;\n\terr = register_vlan_dev(new_dev, NULL);\n\tif (err < 0)\n\t\tgoto out_free_newdev;\n\n\treturn 0;\n\nout_free_newdev:\n\tfree_netdev(new_dev);\n\treturn err;\n}\n\nstatic void vlan_sync_address(struct net_device *dev,\n\t\t\t      struct net_device *vlandev)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(vlandev);\n\n\t \n\tif (ether_addr_equal(vlan->real_dev_addr, dev->dev_addr))\n\t\treturn;\n\n\t \n\tif (vlan_dev_inherit_address(vlandev, dev))\n\t\tgoto out;\n\n\t \n\tif (!ether_addr_equal(vlandev->dev_addr, vlan->real_dev_addr) &&\n\t    ether_addr_equal(vlandev->dev_addr, dev->dev_addr))\n\t\tdev_uc_del(dev, vlandev->dev_addr);\n\n\t \n\tif (ether_addr_equal(vlandev->dev_addr, vlan->real_dev_addr) &&\n\t    !ether_addr_equal(vlandev->dev_addr, dev->dev_addr))\n\t\tdev_uc_add(dev, vlandev->dev_addr);\n\nout:\n\tether_addr_copy(vlan->real_dev_addr, dev->dev_addr);\n}\n\nstatic void vlan_transfer_features(struct net_device *dev,\n\t\t\t\t   struct net_device *vlandev)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(vlandev);\n\n\tnetif_inherit_tso_max(vlandev, dev);\n\n\tif (vlan_hw_offload_capable(dev->features, vlan->vlan_proto))\n\t\tvlandev->hard_header_len = dev->hard_header_len;\n\telse\n\t\tvlandev->hard_header_len = dev->hard_header_len + VLAN_HLEN;\n\n#if IS_ENABLED(CONFIG_FCOE)\n\tvlandev->fcoe_ddp_xid = dev->fcoe_ddp_xid;\n#endif\n\n\tvlandev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\tvlandev->priv_flags |= (vlan->real_dev->priv_flags & IFF_XMIT_DST_RELEASE);\n\tvlandev->hw_enc_features = vlan_tnl_features(vlan->real_dev);\n\n\tnetdev_update_features(vlandev);\n}\n\nstatic int __vlan_device_event(struct net_device *dev, unsigned long event)\n{\n\tint err = 0;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGENAME:\n\t\tvlan_proc_rem_dev(dev);\n\t\terr = vlan_proc_add_dev(dev);\n\t\tbreak;\n\tcase NETDEV_REGISTER:\n\t\terr = vlan_proc_add_dev(dev);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\tvlan_proc_rem_dev(dev);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int vlan_device_event(struct notifier_block *unused, unsigned long event,\n\t\t\t     void *ptr)\n{\n\tstruct netlink_ext_ack *extack = netdev_notifier_info_to_extack(ptr);\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct vlan_group *grp;\n\tstruct vlan_info *vlan_info;\n\tint i, flgs;\n\tstruct net_device *vlandev;\n\tstruct vlan_dev_priv *vlan;\n\tbool last = false;\n\tLIST_HEAD(list);\n\tint err;\n\n\tif (is_vlan_dev(dev)) {\n\t\tint err = __vlan_device_event(dev, event);\n\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t}\n\n\tif ((event == NETDEV_UP) &&\n\t    (dev->features & NETIF_F_HW_VLAN_CTAG_FILTER)) {\n\t\tpr_info(\"adding VLAN 0 to HW filter on device %s\\n\",\n\t\t\tdev->name);\n\t\tvlan_vid_add(dev, htons(ETH_P_8021Q), 0);\n\t}\n\tif (event == NETDEV_DOWN &&\n\t    (dev->features & NETIF_F_HW_VLAN_CTAG_FILTER))\n\t\tvlan_vid_del(dev, htons(ETH_P_8021Q), 0);\n\n\tvlan_info = rtnl_dereference(dev->vlan_info);\n\tif (!vlan_info)\n\t\tgoto out;\n\tgrp = &vlan_info->grp;\n\n\t \n\n\tswitch (event) {\n\tcase NETDEV_CHANGE:\n\t\t \n\t\tvlan_group_for_each_dev(grp, i, vlandev)\n\t\t\tvlan_stacked_transfer_operstate(dev, vlandev,\n\t\t\t\t\t\t\tvlan_dev_priv(vlandev));\n\t\tbreak;\n\n\tcase NETDEV_CHANGEADDR:\n\t\t \n\t\tvlan_group_for_each_dev(grp, i, vlandev) {\n\t\t\tflgs = vlandev->flags;\n\t\t\tif (!(flgs & IFF_UP))\n\t\t\t\tcontinue;\n\n\t\t\tvlan_sync_address(dev, vlandev);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_CHANGEMTU:\n\t\tvlan_group_for_each_dev(grp, i, vlandev) {\n\t\t\tif (vlandev->mtu <= dev->mtu)\n\t\t\t\tcontinue;\n\n\t\t\tdev_set_mtu(vlandev, dev->mtu);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_FEAT_CHANGE:\n\t\t \n\t\tvlan_group_for_each_dev(grp, i, vlandev)\n\t\t\tvlan_transfer_features(dev, vlandev);\n\t\tbreak;\n\n\tcase NETDEV_DOWN: {\n\t\tstruct net_device *tmp;\n\t\tLIST_HEAD(close_list);\n\n\t\t \n\t\tvlan_group_for_each_dev(grp, i, vlandev) {\n\t\t\tflgs = vlandev->flags;\n\t\t\tif (!(flgs & IFF_UP))\n\t\t\t\tcontinue;\n\n\t\t\tvlan = vlan_dev_priv(vlandev);\n\t\t\tif (!(vlan->flags & VLAN_FLAG_LOOSE_BINDING))\n\t\t\t\tlist_add(&vlandev->close_list, &close_list);\n\t\t}\n\n\t\tdev_close_many(&close_list, false);\n\n\t\tlist_for_each_entry_safe(vlandev, tmp, &close_list, close_list) {\n\t\t\tvlan_stacked_transfer_operstate(dev, vlandev,\n\t\t\t\t\t\t\tvlan_dev_priv(vlandev));\n\t\t\tlist_del_init(&vlandev->close_list);\n\t\t}\n\t\tlist_del(&close_list);\n\t\tbreak;\n\t}\n\tcase NETDEV_UP:\n\t\t \n\t\tvlan_group_for_each_dev(grp, i, vlandev) {\n\t\t\tflgs = dev_get_flags(vlandev);\n\t\t\tif (flgs & IFF_UP)\n\t\t\t\tcontinue;\n\n\t\t\tvlan = vlan_dev_priv(vlandev);\n\t\t\tif (!(vlan->flags & VLAN_FLAG_LOOSE_BINDING))\n\t\t\t\tdev_change_flags(vlandev, flgs | IFF_UP,\n\t\t\t\t\t\t extack);\n\t\t\tvlan_stacked_transfer_operstate(dev, vlandev, vlan);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_UNREGISTER:\n\t\t \n\t\tif (dev->reg_state != NETREG_UNREGISTERING)\n\t\t\tbreak;\n\n\t\tvlan_group_for_each_dev(grp, i, vlandev) {\n\t\t\t \n\t\t\tif (vlan_info->nr_vids == 1)\n\t\t\t\tlast = true;\n\n\t\t\tunregister_vlan_dev(vlandev, &list);\n\t\t\tif (last)\n\t\t\t\tbreak;\n\t\t}\n\t\tunregister_netdevice_many(&list);\n\t\tbreak;\n\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\t \n\t\tif (vlan_uses_dev(dev))\n\t\t\treturn NOTIFY_BAD;\n\t\tbreak;\n\n\tcase NETDEV_NOTIFY_PEERS:\n\tcase NETDEV_BONDING_FAILOVER:\n\tcase NETDEV_RESEND_IGMP:\n\t\t \n\t\tvlan_group_for_each_dev(grp, i, vlandev)\n\t\t\tcall_netdevice_notifiers(event, vlandev);\n\t\tbreak;\n\n\tcase NETDEV_CVLAN_FILTER_PUSH_INFO:\n\t\terr = vlan_filter_push_vids(vlan_info, htons(ETH_P_8021Q));\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t\tbreak;\n\n\tcase NETDEV_CVLAN_FILTER_DROP_INFO:\n\t\tvlan_filter_drop_vids(vlan_info, htons(ETH_P_8021Q));\n\t\tbreak;\n\n\tcase NETDEV_SVLAN_FILTER_PUSH_INFO:\n\t\terr = vlan_filter_push_vids(vlan_info, htons(ETH_P_8021AD));\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t\tbreak;\n\n\tcase NETDEV_SVLAN_FILTER_DROP_INFO:\n\t\tvlan_filter_drop_vids(vlan_info, htons(ETH_P_8021AD));\n\t\tbreak;\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block vlan_notifier_block __read_mostly = {\n\t.notifier_call = vlan_device_event,\n};\n\n \nstatic int vlan_ioctl_handler(struct net *net, void __user *arg)\n{\n\tint err;\n\tstruct vlan_ioctl_args args;\n\tstruct net_device *dev = NULL;\n\n\tif (copy_from_user(&args, arg, sizeof(struct vlan_ioctl_args)))\n\t\treturn -EFAULT;\n\n\t \n\targs.device1[sizeof(args.device1) - 1] = 0;\n\targs.u.device2[sizeof(args.u.device2) - 1] = 0;\n\n\trtnl_lock();\n\n\tswitch (args.cmd) {\n\tcase SET_VLAN_INGRESS_PRIORITY_CMD:\n\tcase SET_VLAN_EGRESS_PRIORITY_CMD:\n\tcase SET_VLAN_FLAG_CMD:\n\tcase ADD_VLAN_CMD:\n\tcase DEL_VLAN_CMD:\n\tcase GET_VLAN_REALDEV_NAME_CMD:\n\tcase GET_VLAN_VID_CMD:\n\t\terr = -ENODEV;\n\t\tdev = __dev_get_by_name(net, args.device1);\n\t\tif (!dev)\n\t\t\tgoto out;\n\n\t\terr = -EINVAL;\n\t\tif (args.cmd != ADD_VLAN_CMD && !is_vlan_dev(dev))\n\t\t\tgoto out;\n\t}\n\n\tswitch (args.cmd) {\n\tcase SET_VLAN_INGRESS_PRIORITY_CMD:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\tvlan_dev_set_ingress_priority(dev,\n\t\t\t\t\t      args.u.skb_priority,\n\t\t\t\t\t      args.vlan_qos);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SET_VLAN_EGRESS_PRIORITY_CMD:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = vlan_dev_set_egress_priority(dev,\n\t\t\t\t\t\t   args.u.skb_priority,\n\t\t\t\t\t\t   args.vlan_qos);\n\t\tbreak;\n\n\tcase SET_VLAN_FLAG_CMD:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = vlan_dev_change_flags(dev,\n\t\t\t\t\t    args.vlan_qos ? args.u.flag : 0,\n\t\t\t\t\t    args.u.flag);\n\t\tbreak;\n\n\tcase SET_VLAN_NAME_TYPE_CMD:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\tif (args.u.name_type < VLAN_NAME_TYPE_HIGHEST) {\n\t\t\tstruct vlan_net *vn;\n\n\t\t\tvn = net_generic(net, vlan_net_id);\n\t\t\tvn->name_type = args.u.name_type;\n\t\t\terr = 0;\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase ADD_VLAN_CMD:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\terr = register_vlan_device(dev, args.u.VID);\n\t\tbreak;\n\n\tcase DEL_VLAN_CMD:\n\t\terr = -EPERM;\n\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\tunregister_vlan_dev(dev, NULL);\n\t\terr = 0;\n\t\tbreak;\n\n\tcase GET_VLAN_REALDEV_NAME_CMD:\n\t\terr = 0;\n\t\tvlan_dev_get_realdev_name(dev, args.u.device2,\n\t\t\t\t\t  sizeof(args.u.device2));\n\t\tif (copy_to_user(arg, &args,\n\t\t\t\t sizeof(struct vlan_ioctl_args)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\n\tcase GET_VLAN_VID_CMD:\n\t\terr = 0;\n\t\targs.u.VID = vlan_dev_vlan_id(dev);\n\t\tif (copy_to_user(arg, &args,\n\t\t\t\t sizeof(struct vlan_ioctl_args)))\n\t\t      err = -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\nout:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int __net_init vlan_init_net(struct net *net)\n{\n\tstruct vlan_net *vn = net_generic(net, vlan_net_id);\n\tint err;\n\n\tvn->name_type = VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD;\n\n\terr = vlan_proc_init(net);\n\n\treturn err;\n}\n\nstatic void __net_exit vlan_exit_net(struct net *net)\n{\n\tvlan_proc_cleanup(net);\n}\n\nstatic struct pernet_operations vlan_net_ops = {\n\t.init = vlan_init_net,\n\t.exit = vlan_exit_net,\n\t.id   = &vlan_net_id,\n\t.size = sizeof(struct vlan_net),\n};\n\nstatic int __init vlan_proto_init(void)\n{\n\tint err;\n\n\tpr_info(\"%s v%s\\n\", vlan_fullname, vlan_version);\n\n\terr = register_pernet_subsys(&vlan_net_ops);\n\tif (err < 0)\n\t\tgoto err0;\n\n\terr = register_netdevice_notifier(&vlan_notifier_block);\n\tif (err < 0)\n\t\tgoto err2;\n\n\terr = vlan_gvrp_init();\n\tif (err < 0)\n\t\tgoto err3;\n\n\terr = vlan_mvrp_init();\n\tif (err < 0)\n\t\tgoto err4;\n\n\terr = vlan_netlink_init();\n\tif (err < 0)\n\t\tgoto err5;\n\n\tvlan_ioctl_set(vlan_ioctl_handler);\n\treturn 0;\n\nerr5:\n\tvlan_mvrp_uninit();\nerr4:\n\tvlan_gvrp_uninit();\nerr3:\n\tunregister_netdevice_notifier(&vlan_notifier_block);\nerr2:\n\tunregister_pernet_subsys(&vlan_net_ops);\nerr0:\n\treturn err;\n}\n\nstatic void __exit vlan_cleanup_module(void)\n{\n\tvlan_ioctl_set(NULL);\n\n\tvlan_netlink_fini();\n\n\tunregister_netdevice_notifier(&vlan_notifier_block);\n\n\tunregister_pernet_subsys(&vlan_net_ops);\n\trcu_barrier();  \n\n\tvlan_mvrp_uninit();\n\tvlan_gvrp_uninit();\n}\n\nmodule_init(vlan_proto_init);\nmodule_exit(vlan_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}