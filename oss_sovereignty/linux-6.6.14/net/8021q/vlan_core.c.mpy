{
  "module_name": "vlan_core.c",
  "hash_id": "0f59edcbe403e72b4234626f46dee44b908e03e3909e61c9220c53a5787fd0d9",
  "original_prompt": "Ingested from linux-6.6.14/net/8021q/vlan_core.c",
  "human_readable_source": "\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/netpoll.h>\n#include <linux/export.h>\n#include <net/gro.h>\n#include \"vlan.h\"\n\nbool vlan_do_receive(struct sk_buff **skbp)\n{\n\tstruct sk_buff *skb = *skbp;\n\t__be16 vlan_proto = skb->vlan_proto;\n\tu16 vlan_id = skb_vlan_tag_get_id(skb);\n\tstruct net_device *vlan_dev;\n\tstruct vlan_pcpu_stats *rx_stats;\n\n\tvlan_dev = vlan_find_dev(skb->dev, vlan_proto, vlan_id);\n\tif (!vlan_dev)\n\t\treturn false;\n\n\tskb = *skbp = skb_share_check(skb, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn false;\n\n\tif (unlikely(!(vlan_dev->flags & IFF_UP))) {\n\t\tkfree_skb(skb);\n\t\t*skbp = NULL;\n\t\treturn false;\n\t}\n\n\tskb->dev = vlan_dev;\n\tif (unlikely(skb->pkt_type == PACKET_OTHERHOST)) {\n\t\t \n\t\tif (ether_addr_equal_64bits(eth_hdr(skb)->h_dest, vlan_dev->dev_addr))\n\t\t\tskb->pkt_type = PACKET_HOST;\n\t}\n\n\tif (!(vlan_dev_priv(vlan_dev)->flags & VLAN_FLAG_REORDER_HDR) &&\n\t    !netif_is_macvlan_port(vlan_dev) &&\n\t    !netif_is_bridge_port(vlan_dev)) {\n\t\tunsigned int offset = skb->data - skb_mac_header(skb);\n\n\t\t \n\t\tskb_push(skb, offset);\n\t\tskb = *skbp = vlan_insert_inner_tag(skb, skb->vlan_proto,\n\t\t\t\t\t\t    skb->vlan_tci, skb->mac_len);\n\t\tif (!skb)\n\t\t\treturn false;\n\t\tskb_pull(skb, offset + VLAN_HLEN);\n\t\tskb_reset_mac_len(skb);\n\t}\n\n\tskb->priority = vlan_get_ingress_priority(vlan_dev, skb->vlan_tci);\n\t__vlan_hwaccel_clear_tag(skb);\n\n\trx_stats = this_cpu_ptr(vlan_dev_priv(vlan_dev)->vlan_pcpu_stats);\n\n\tu64_stats_update_begin(&rx_stats->syncp);\n\tu64_stats_inc(&rx_stats->rx_packets);\n\tu64_stats_add(&rx_stats->rx_bytes, skb->len);\n\tif (skb->pkt_type == PACKET_MULTICAST)\n\t\tu64_stats_inc(&rx_stats->rx_multicast);\n\tu64_stats_update_end(&rx_stats->syncp);\n\n\treturn true;\n}\n\n \nstruct net_device *__vlan_find_dev_deep_rcu(struct net_device *dev,\n\t\t\t\t\t__be16 vlan_proto, u16 vlan_id)\n{\n\tstruct vlan_info *vlan_info = rcu_dereference(dev->vlan_info);\n\n\tif (vlan_info) {\n\t\treturn vlan_group_get_device(&vlan_info->grp,\n\t\t\t\t\t     vlan_proto, vlan_id);\n\t} else {\n\t\t \n\t\tstruct net_device *upper_dev;\n\n\t\tupper_dev = netdev_master_upper_dev_get_rcu(dev);\n\t\tif (upper_dev)\n\t\t\treturn __vlan_find_dev_deep_rcu(upper_dev,\n\t\t\t\t\t\t    vlan_proto, vlan_id);\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(__vlan_find_dev_deep_rcu);\n\nstruct net_device *vlan_dev_real_dev(const struct net_device *dev)\n{\n\tstruct net_device *ret = vlan_dev_priv(dev)->real_dev;\n\n\twhile (is_vlan_dev(ret))\n\t\tret = vlan_dev_priv(ret)->real_dev;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(vlan_dev_real_dev);\n\nu16 vlan_dev_vlan_id(const struct net_device *dev)\n{\n\treturn vlan_dev_priv(dev)->vlan_id;\n}\nEXPORT_SYMBOL(vlan_dev_vlan_id);\n\n__be16 vlan_dev_vlan_proto(const struct net_device *dev)\n{\n\treturn vlan_dev_priv(dev)->vlan_proto;\n}\nEXPORT_SYMBOL(vlan_dev_vlan_proto);\n\n \n\nstatic void vlan_group_free(struct vlan_group *grp)\n{\n\tint i, j;\n\n\tfor (i = 0; i < VLAN_PROTO_NUM; i++)\n\t\tfor (j = 0; j < VLAN_GROUP_ARRAY_SPLIT_PARTS; j++)\n\t\t\tkfree(grp->vlan_devices_arrays[i][j]);\n}\n\nstatic void vlan_info_free(struct vlan_info *vlan_info)\n{\n\tvlan_group_free(&vlan_info->grp);\n\tkfree(vlan_info);\n}\n\nstatic void vlan_info_rcu_free(struct rcu_head *rcu)\n{\n\tvlan_info_free(container_of(rcu, struct vlan_info, rcu));\n}\n\nstatic struct vlan_info *vlan_info_alloc(struct net_device *dev)\n{\n\tstruct vlan_info *vlan_info;\n\n\tvlan_info = kzalloc(sizeof(struct vlan_info), GFP_KERNEL);\n\tif (!vlan_info)\n\t\treturn NULL;\n\n\tvlan_info->real_dev = dev;\n\tINIT_LIST_HEAD(&vlan_info->vid_list);\n\treturn vlan_info;\n}\n\nstruct vlan_vid_info {\n\tstruct list_head list;\n\t__be16 proto;\n\tu16 vid;\n\tint refcount;\n};\n\nstatic bool vlan_hw_filter_capable(const struct net_device *dev, __be16 proto)\n{\n\tif (proto == htons(ETH_P_8021Q) &&\n\t    dev->features & NETIF_F_HW_VLAN_CTAG_FILTER)\n\t\treturn true;\n\tif (proto == htons(ETH_P_8021AD) &&\n\t    dev->features & NETIF_F_HW_VLAN_STAG_FILTER)\n\t\treturn true;\n\treturn false;\n}\n\nstatic struct vlan_vid_info *vlan_vid_info_get(struct vlan_info *vlan_info,\n\t\t\t\t\t       __be16 proto, u16 vid)\n{\n\tstruct vlan_vid_info *vid_info;\n\n\tlist_for_each_entry(vid_info, &vlan_info->vid_list, list) {\n\t\tif (vid_info->proto == proto && vid_info->vid == vid)\n\t\t\treturn vid_info;\n\t}\n\treturn NULL;\n}\n\nstatic struct vlan_vid_info *vlan_vid_info_alloc(__be16 proto, u16 vid)\n{\n\tstruct vlan_vid_info *vid_info;\n\n\tvid_info = kzalloc(sizeof(struct vlan_vid_info), GFP_KERNEL);\n\tif (!vid_info)\n\t\treturn NULL;\n\tvid_info->proto = proto;\n\tvid_info->vid = vid;\n\n\treturn vid_info;\n}\n\nstatic int vlan_add_rx_filter_info(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tif (!vlan_hw_filter_capable(dev, proto))\n\t\treturn 0;\n\n\tif (netif_device_present(dev))\n\t\treturn dev->netdev_ops->ndo_vlan_rx_add_vid(dev, proto, vid);\n\telse\n\t\treturn -ENODEV;\n}\n\nstatic int vlan_kill_rx_filter_info(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tif (!vlan_hw_filter_capable(dev, proto))\n\t\treturn 0;\n\n\tif (netif_device_present(dev))\n\t\treturn dev->netdev_ops->ndo_vlan_rx_kill_vid(dev, proto, vid);\n\telse\n\t\treturn -ENODEV;\n}\n\nint vlan_for_each(struct net_device *dev,\n\t\t  int (*action)(struct net_device *dev, int vid, void *arg),\n\t\t  void *arg)\n{\n\tstruct vlan_vid_info *vid_info;\n\tstruct vlan_info *vlan_info;\n\tstruct net_device *vdev;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tvlan_info = rtnl_dereference(dev->vlan_info);\n\tif (!vlan_info)\n\t\treturn 0;\n\n\tlist_for_each_entry(vid_info, &vlan_info->vid_list, list) {\n\t\tvdev = vlan_group_get_device(&vlan_info->grp, vid_info->proto,\n\t\t\t\t\t     vid_info->vid);\n\t\tret = action(vdev, vid_info->vid, arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vlan_for_each);\n\nint vlan_filter_push_vids(struct vlan_info *vlan_info, __be16 proto)\n{\n\tstruct net_device *real_dev = vlan_info->real_dev;\n\tstruct vlan_vid_info *vlan_vid_info;\n\tint err;\n\n\tlist_for_each_entry(vlan_vid_info, &vlan_info->vid_list, list) {\n\t\tif (vlan_vid_info->proto == proto) {\n\t\t\terr = vlan_add_rx_filter_info(real_dev, proto,\n\t\t\t\t\t\t      vlan_vid_info->vid);\n\t\t\tif (err)\n\t\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\treturn 0;\n\nunwind:\n\tlist_for_each_entry_continue_reverse(vlan_vid_info,\n\t\t\t\t\t     &vlan_info->vid_list, list) {\n\t\tif (vlan_vid_info->proto == proto)\n\t\t\tvlan_kill_rx_filter_info(real_dev, proto,\n\t\t\t\t\t\t vlan_vid_info->vid);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL(vlan_filter_push_vids);\n\nvoid vlan_filter_drop_vids(struct vlan_info *vlan_info, __be16 proto)\n{\n\tstruct vlan_vid_info *vlan_vid_info;\n\n\tlist_for_each_entry(vlan_vid_info, &vlan_info->vid_list, list)\n\t\tif (vlan_vid_info->proto == proto)\n\t\t\tvlan_kill_rx_filter_info(vlan_info->real_dev,\n\t\t\t\t\t\t vlan_vid_info->proto,\n\t\t\t\t\t\t vlan_vid_info->vid);\n}\nEXPORT_SYMBOL(vlan_filter_drop_vids);\n\nstatic int __vlan_vid_add(struct vlan_info *vlan_info, __be16 proto, u16 vid,\n\t\t\t  struct vlan_vid_info **pvid_info)\n{\n\tstruct net_device *dev = vlan_info->real_dev;\n\tstruct vlan_vid_info *vid_info;\n\tint err;\n\n\tvid_info = vlan_vid_info_alloc(proto, vid);\n\tif (!vid_info)\n\t\treturn -ENOMEM;\n\n\terr = vlan_add_rx_filter_info(dev, proto, vid);\n\tif (err) {\n\t\tkfree(vid_info);\n\t\treturn err;\n\t}\n\n\tlist_add(&vid_info->list, &vlan_info->vid_list);\n\tvlan_info->nr_vids++;\n\t*pvid_info = vid_info;\n\treturn 0;\n}\n\nint vlan_vid_add(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct vlan_info *vlan_info;\n\tstruct vlan_vid_info *vid_info;\n\tbool vlan_info_created = false;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tvlan_info = rtnl_dereference(dev->vlan_info);\n\tif (!vlan_info) {\n\t\tvlan_info = vlan_info_alloc(dev);\n\t\tif (!vlan_info)\n\t\t\treturn -ENOMEM;\n\t\tvlan_info_created = true;\n\t}\n\tvid_info = vlan_vid_info_get(vlan_info, proto, vid);\n\tif (!vid_info) {\n\t\terr = __vlan_vid_add(vlan_info, proto, vid, &vid_info);\n\t\tif (err)\n\t\t\tgoto out_free_vlan_info;\n\t}\n\tvid_info->refcount++;\n\n\tif (vlan_info_created)\n\t\trcu_assign_pointer(dev->vlan_info, vlan_info);\n\n\treturn 0;\n\nout_free_vlan_info:\n\tif (vlan_info_created)\n\t\tkfree(vlan_info);\n\treturn err;\n}\nEXPORT_SYMBOL(vlan_vid_add);\n\nstatic void __vlan_vid_del(struct vlan_info *vlan_info,\n\t\t\t   struct vlan_vid_info *vid_info)\n{\n\tstruct net_device *dev = vlan_info->real_dev;\n\t__be16 proto = vid_info->proto;\n\tu16 vid = vid_info->vid;\n\tint err;\n\n\terr = vlan_kill_rx_filter_info(dev, proto, vid);\n\tif (err && dev->reg_state != NETREG_UNREGISTERING)\n\t\tnetdev_warn(dev, \"failed to kill vid %04x/%d\\n\", proto, vid);\n\n\tlist_del(&vid_info->list);\n\tkfree(vid_info);\n\tvlan_info->nr_vids--;\n}\n\nvoid vlan_vid_del(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct vlan_info *vlan_info;\n\tstruct vlan_vid_info *vid_info;\n\n\tASSERT_RTNL();\n\n\tvlan_info = rtnl_dereference(dev->vlan_info);\n\tif (!vlan_info)\n\t\treturn;\n\n\tvid_info = vlan_vid_info_get(vlan_info, proto, vid);\n\tif (!vid_info)\n\t\treturn;\n\tvid_info->refcount--;\n\tif (vid_info->refcount == 0) {\n\t\t__vlan_vid_del(vlan_info, vid_info);\n\t\tif (vlan_info->nr_vids == 0) {\n\t\t\tRCU_INIT_POINTER(dev->vlan_info, NULL);\n\t\t\tcall_rcu(&vlan_info->rcu, vlan_info_rcu_free);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(vlan_vid_del);\n\nint vlan_vids_add_by_dev(struct net_device *dev,\n\t\t\t const struct net_device *by_dev)\n{\n\tstruct vlan_vid_info *vid_info;\n\tstruct vlan_info *vlan_info;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tvlan_info = rtnl_dereference(by_dev->vlan_info);\n\tif (!vlan_info)\n\t\treturn 0;\n\n\tlist_for_each_entry(vid_info, &vlan_info->vid_list, list) {\n\t\tif (!vlan_hw_filter_capable(by_dev, vid_info->proto))\n\t\t\tcontinue;\n\t\terr = vlan_vid_add(dev, vid_info->proto, vid_info->vid);\n\t\tif (err)\n\t\t\tgoto unwind;\n\t}\n\treturn 0;\n\nunwind:\n\tlist_for_each_entry_continue_reverse(vid_info,\n\t\t\t\t\t     &vlan_info->vid_list,\n\t\t\t\t\t     list) {\n\t\tif (!vlan_hw_filter_capable(by_dev, vid_info->proto))\n\t\t\tcontinue;\n\t\tvlan_vid_del(dev, vid_info->proto, vid_info->vid);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL(vlan_vids_add_by_dev);\n\nvoid vlan_vids_del_by_dev(struct net_device *dev,\n\t\t\t  const struct net_device *by_dev)\n{\n\tstruct vlan_vid_info *vid_info;\n\tstruct vlan_info *vlan_info;\n\n\tASSERT_RTNL();\n\n\tvlan_info = rtnl_dereference(by_dev->vlan_info);\n\tif (!vlan_info)\n\t\treturn;\n\n\tlist_for_each_entry(vid_info, &vlan_info->vid_list, list) {\n\t\tif (!vlan_hw_filter_capable(by_dev, vid_info->proto))\n\t\t\tcontinue;\n\t\tvlan_vid_del(dev, vid_info->proto, vid_info->vid);\n\t}\n}\nEXPORT_SYMBOL(vlan_vids_del_by_dev);\n\nbool vlan_uses_dev(const struct net_device *dev)\n{\n\tstruct vlan_info *vlan_info;\n\n\tASSERT_RTNL();\n\n\tvlan_info = rtnl_dereference(dev->vlan_info);\n\tif (!vlan_info)\n\t\treturn false;\n\treturn vlan_info->grp.nr_vlan_devs ? true : false;\n}\nEXPORT_SYMBOL(vlan_uses_dev);\n\nstatic struct sk_buff *vlan_gro_receive(struct list_head *head,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tconst struct packet_offload *ptype;\n\tunsigned int hlen, off_vlan;\n\tstruct sk_buff *pp = NULL;\n\tstruct vlan_hdr *vhdr;\n\tstruct sk_buff *p;\n\t__be16 type;\n\tint flush = 1;\n\n\toff_vlan = skb_gro_offset(skb);\n\thlen = off_vlan + sizeof(*vhdr);\n\tvhdr = skb_gro_header(skb, hlen, off_vlan);\n\tif (unlikely(!vhdr))\n\t\tgoto out;\n\n\ttype = vhdr->h_vlan_encapsulated_proto;\n\n\tptype = gro_find_receive_by_type(type);\n\tif (!ptype)\n\t\tgoto out;\n\n\tflush = 0;\n\n\tlist_for_each_entry(p, head, list) {\n\t\tstruct vlan_hdr *vhdr2;\n\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tvhdr2 = (struct vlan_hdr *)(p->data + off_vlan);\n\t\tif (compare_vlan_header(vhdr, vhdr2))\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t}\n\n\tskb_gro_pull(skb, sizeof(*vhdr));\n\tskb_gro_postpull_rcsum(skb, vhdr, sizeof(*vhdr));\n\n\tpp = indirect_call_gro_receive_inet(ptype->callbacks.gro_receive,\n\t\t\t\t\t    ipv6_gro_receive, inet_gro_receive,\n\t\t\t\t\t    head, skb);\n\nout:\n\tskb_gro_flush_final(skb, pp, flush);\n\n\treturn pp;\n}\n\nstatic int vlan_gro_complete(struct sk_buff *skb, int nhoff)\n{\n\tstruct vlan_hdr *vhdr = (struct vlan_hdr *)(skb->data + nhoff);\n\t__be16 type = vhdr->h_vlan_encapsulated_proto;\n\tstruct packet_offload *ptype;\n\tint err = -ENOENT;\n\n\tptype = gro_find_complete_by_type(type);\n\tif (ptype)\n\t\terr = INDIRECT_CALL_INET(ptype->callbacks.gro_complete,\n\t\t\t\t\t ipv6_gro_complete, inet_gro_complete,\n\t\t\t\t\t skb, nhoff + sizeof(*vhdr));\n\n\treturn err;\n}\n\nstatic struct packet_offload vlan_packet_offloads[] __read_mostly = {\n\t{\n\t\t.type = cpu_to_be16(ETH_P_8021Q),\n\t\t.priority = 10,\n\t\t.callbacks = {\n\t\t\t.gro_receive = vlan_gro_receive,\n\t\t\t.gro_complete = vlan_gro_complete,\n\t\t},\n\t},\n\t{\n\t\t.type = cpu_to_be16(ETH_P_8021AD),\n\t\t.priority = 10,\n\t\t.callbacks = {\n\t\t\t.gro_receive = vlan_gro_receive,\n\t\t\t.gro_complete = vlan_gro_complete,\n\t\t},\n\t},\n};\n\nstatic int __init vlan_offload_init(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vlan_packet_offloads); i++)\n\t\tdev_add_offload(&vlan_packet_offloads[i]);\n\n\treturn 0;\n}\n\nfs_initcall(vlan_offload_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}