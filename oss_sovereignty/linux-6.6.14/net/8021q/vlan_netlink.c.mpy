{
  "module_name": "vlan_netlink.c",
  "hash_id": "053b7296c6785f8c61abcf1d1f6310d08ae3d2481069815808b6869b72268c39",
  "original_prompt": "Ingested from linux-6.6.14/net/8021q/vlan_netlink.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/module.h>\n#include <net/net_namespace.h>\n#include <net/netlink.h>\n#include <net/rtnetlink.h>\n#include \"vlan.h\"\n\n\nstatic const struct nla_policy vlan_policy[IFLA_VLAN_MAX + 1] = {\n\t[IFLA_VLAN_ID]\t\t= { .type = NLA_U16 },\n\t[IFLA_VLAN_FLAGS]\t= { .len = sizeof(struct ifla_vlan_flags) },\n\t[IFLA_VLAN_EGRESS_QOS]\t= { .type = NLA_NESTED },\n\t[IFLA_VLAN_INGRESS_QOS] = { .type = NLA_NESTED },\n\t[IFLA_VLAN_PROTOCOL]\t= { .type = NLA_U16 },\n};\n\nstatic const struct nla_policy vlan_map_policy[IFLA_VLAN_QOS_MAX + 1] = {\n\t[IFLA_VLAN_QOS_MAPPING] = { .len = sizeof(struct ifla_vlan_qos_mapping) },\n};\n\n\nstatic inline int vlan_validate_qos_map(struct nlattr *attr)\n{\n\tif (!attr)\n\t\treturn 0;\n\treturn nla_validate_nested_deprecated(attr, IFLA_VLAN_QOS_MAX,\n\t\t\t\t\t      vlan_map_policy, NULL);\n}\n\nstatic int vlan_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct ifla_vlan_flags *flags;\n\tu16 id;\n\tint err;\n\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid link address\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS]))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid link address\");\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t}\n\n\tif (!data) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VLAN properties not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data[IFLA_VLAN_PROTOCOL]) {\n\t\tswitch (nla_get_be16(data[IFLA_VLAN_PROTOCOL])) {\n\t\tcase htons(ETH_P_8021Q):\n\t\tcase htons(ETH_P_8021AD):\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid VLAN protocol\");\n\t\t\treturn -EPROTONOSUPPORT;\n\t\t}\n\t}\n\n\tif (data[IFLA_VLAN_ID]) {\n\t\tid = nla_get_u16(data[IFLA_VLAN_ID]);\n\t\tif (id >= VLAN_VID_MASK) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid VLAN id\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t}\n\tif (data[IFLA_VLAN_FLAGS]) {\n\t\tflags = nla_data(data[IFLA_VLAN_FLAGS]);\n\t\tif ((flags->flags & flags->mask) &\n\t\t    ~(VLAN_FLAG_REORDER_HDR | VLAN_FLAG_GVRP |\n\t\t      VLAN_FLAG_LOOSE_BINDING | VLAN_FLAG_MVRP |\n\t\t      VLAN_FLAG_BRIDGE_BINDING)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid VLAN flags\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\terr = vlan_validate_qos_map(data[IFLA_VLAN_INGRESS_QOS]);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid ingress QOS map\");\n\t\treturn err;\n\t}\n\terr = vlan_validate_qos_map(data[IFLA_VLAN_EGRESS_QOS]);\n\tif (err < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid egress QOS map\");\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int vlan_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t   struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct ifla_vlan_flags *flags;\n\tstruct ifla_vlan_qos_mapping *m;\n\tstruct nlattr *attr;\n\tint rem, err;\n\n\tif (data[IFLA_VLAN_FLAGS]) {\n\t\tflags = nla_data(data[IFLA_VLAN_FLAGS]);\n\t\terr = vlan_dev_change_flags(dev, flags->flags, flags->mask);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (data[IFLA_VLAN_INGRESS_QOS]) {\n\t\tnla_for_each_nested(attr, data[IFLA_VLAN_INGRESS_QOS], rem) {\n\t\t\tm = nla_data(attr);\n\t\t\tvlan_dev_set_ingress_priority(dev, m->to, m->from);\n\t\t}\n\t}\n\tif (data[IFLA_VLAN_EGRESS_QOS]) {\n\t\tnla_for_each_nested(attr, data[IFLA_VLAN_EGRESS_QOS], rem) {\n\t\t\tm = nla_data(attr);\n\t\t\terr = vlan_dev_set_egress_priority(dev, m->from, m->to);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vlan_newlink(struct net *src_net, struct net_device *dev,\n\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tstruct net_device *real_dev;\n\tunsigned int max_mtu;\n\t__be16 proto;\n\tint err;\n\n\tif (!data[IFLA_VLAN_ID]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VLAN id not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tb[IFLA_LINK]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"link not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\treal_dev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));\n\tif (!real_dev) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"link does not exist\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (data[IFLA_VLAN_PROTOCOL])\n\t\tproto = nla_get_be16(data[IFLA_VLAN_PROTOCOL]);\n\telse\n\t\tproto = htons(ETH_P_8021Q);\n\n\tvlan->vlan_proto = proto;\n\tvlan->vlan_id\t = nla_get_u16(data[IFLA_VLAN_ID]);\n\tvlan->real_dev\t = real_dev;\n\tdev->priv_flags |= (real_dev->priv_flags & IFF_XMIT_DST_RELEASE);\n\tvlan->flags\t = VLAN_FLAG_REORDER_HDR;\n\n\terr = vlan_check_real_dev(real_dev, vlan->vlan_proto, vlan->vlan_id,\n\t\t\t\t  extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tmax_mtu = netif_reduces_vlan_mtu(real_dev) ? real_dev->mtu - VLAN_HLEN :\n\t\t\t\t\t\t     real_dev->mtu;\n\tif (!tb[IFLA_MTU])\n\t\tdev->mtu = max_mtu;\n\telse if (dev->mtu > max_mtu)\n\t\treturn -EINVAL;\n\n\t \n\terr = vlan_changelink(dev, tb, data, extack);\n\n\tif (!err)\n\t\terr = register_vlan_dev(dev, extack);\n\n\tif (err)\n\t\tvlan_dev_free_egress_priority(dev);\n\treturn err;\n}\n\nstatic inline size_t vlan_qos_map_size(unsigned int n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\t \n\treturn nla_total_size(sizeof(struct nlattr)) +\n\t       nla_total_size(sizeof(struct ifla_vlan_qos_mapping)) * n;\n}\n\nstatic size_t vlan_get_size(const struct net_device *dev)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\n\treturn nla_total_size(2) +\t \n\t       nla_total_size(2) +\t \n\t       nla_total_size(sizeof(struct ifla_vlan_flags)) +  \n\t       vlan_qos_map_size(vlan->nr_ingress_mappings) +\n\t       vlan_qos_map_size(vlan->nr_egress_mappings);\n}\n\nstatic int vlan_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tstruct vlan_priority_tci_mapping *pm;\n\tstruct ifla_vlan_flags f;\n\tstruct ifla_vlan_qos_mapping m;\n\tstruct nlattr *nest;\n\tunsigned int i;\n\n\tif (nla_put_be16(skb, IFLA_VLAN_PROTOCOL, vlan->vlan_proto) ||\n\t    nla_put_u16(skb, IFLA_VLAN_ID, vlan->vlan_id))\n\t\tgoto nla_put_failure;\n\tif (vlan->flags) {\n\t\tf.flags = vlan->flags;\n\t\tf.mask  = ~0;\n\t\tif (nla_put(skb, IFLA_VLAN_FLAGS, sizeof(f), &f))\n\t\t\tgoto nla_put_failure;\n\t}\n\tif (vlan->nr_ingress_mappings) {\n\t\tnest = nla_nest_start_noflag(skb, IFLA_VLAN_INGRESS_QOS);\n\t\tif (nest == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(vlan->ingress_priority_map); i++) {\n\t\t\tif (!vlan->ingress_priority_map[i])\n\t\t\t\tcontinue;\n\n\t\t\tm.from = i;\n\t\t\tm.to   = vlan->ingress_priority_map[i];\n\t\t\tif (nla_put(skb, IFLA_VLAN_QOS_MAPPING,\n\t\t\t\t    sizeof(m), &m))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, nest);\n\t}\n\n\tif (vlan->nr_egress_mappings) {\n\t\tnest = nla_nest_start_noflag(skb, IFLA_VLAN_EGRESS_QOS);\n\t\tif (nest == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(vlan->egress_priority_map); i++) {\n\t\t\tfor (pm = vlan->egress_priority_map[i]; pm;\n\t\t\t     pm = pm->next) {\n\t\t\t\tif (!pm->vlan_qos)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tm.from = pm->priority;\n\t\t\t\tm.to   = (pm->vlan_qos >> 13) & 0x7;\n\t\t\t\tif (nla_put(skb, IFLA_VLAN_QOS_MAPPING,\n\t\t\t\t\t    sizeof(m), &m))\n\t\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t}\n\t\tnla_nest_end(skb, nest);\n\t}\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic struct net *vlan_get_link_net(const struct net_device *dev)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\n\treturn dev_net(real_dev);\n}\n\nstruct rtnl_link_ops vlan_link_ops __read_mostly = {\n\t.kind\t\t= \"vlan\",\n\t.maxtype\t= IFLA_VLAN_MAX,\n\t.policy\t\t= vlan_policy,\n\t.priv_size\t= sizeof(struct vlan_dev_priv),\n\t.setup\t\t= vlan_setup,\n\t.validate\t= vlan_validate,\n\t.newlink\t= vlan_newlink,\n\t.changelink\t= vlan_changelink,\n\t.dellink\t= unregister_vlan_dev,\n\t.get_size\t= vlan_get_size,\n\t.fill_info\t= vlan_fill_info,\n\t.get_link_net\t= vlan_get_link_net,\n};\n\nint __init vlan_netlink_init(void)\n{\n\treturn rtnl_link_register(&vlan_link_ops);\n}\n\nvoid __exit vlan_netlink_fini(void)\n{\n\trtnl_link_unregister(&vlan_link_ops);\n}\n\nMODULE_ALIAS_RTNL_LINK(\"vlan\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}