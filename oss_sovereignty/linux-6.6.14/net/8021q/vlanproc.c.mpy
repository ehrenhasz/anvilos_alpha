{
  "module_name": "vlanproc.c",
  "hash_id": "57002907641db45d05bbf19ce9da8a93418a92e2a65f0f99e6a7746cc1e9551d",
  "original_prompt": "Ingested from linux-6.6.14/net/8021q/vlanproc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/netdevice.h>\n#include <linux/if_vlan.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include \"vlanproc.h\"\n#include \"vlan.h\"\n\n \n\n \nstatic int vlan_seq_show(struct seq_file *seq, void *v);\nstatic void *vlan_seq_start(struct seq_file *seq, loff_t *pos);\nstatic void *vlan_seq_next(struct seq_file *seq, void *v, loff_t *pos);\nstatic void vlan_seq_stop(struct seq_file *seq, void *);\nstatic int vlandev_seq_show(struct seq_file *seq, void *v);\n\n \n\n\n \n\nstatic const char name_root[]\t = \"vlan\";\nstatic const char name_conf[]\t = \"config\";\n\n \n\n \n\nstatic const struct seq_operations vlan_seq_ops = {\n\t.start = vlan_seq_start,\n\t.next = vlan_seq_next,\n\t.stop = vlan_seq_stop,\n\t.show = vlan_seq_show,\n};\n\n \n\n \nstatic const char *const vlan_name_type_str[VLAN_NAME_TYPE_HIGHEST] = {\n    [VLAN_NAME_TYPE_RAW_PLUS_VID]        = \"VLAN_NAME_TYPE_RAW_PLUS_VID\",\n    [VLAN_NAME_TYPE_PLUS_VID_NO_PAD]\t = \"VLAN_NAME_TYPE_PLUS_VID_NO_PAD\",\n    [VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD] = \"VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD\",\n    [VLAN_NAME_TYPE_PLUS_VID]\t\t = \"VLAN_NAME_TYPE_PLUS_VID\",\n};\n \n\n \n\nvoid vlan_proc_cleanup(struct net *net)\n{\n\tstruct vlan_net *vn = net_generic(net, vlan_net_id);\n\n\tif (vn->proc_vlan_conf)\n\t\tremove_proc_entry(name_conf, vn->proc_vlan_dir);\n\n\tif (vn->proc_vlan_dir)\n\t\tremove_proc_entry(name_root, net->proc_net);\n\n\t \n}\n\n \n\nint __net_init vlan_proc_init(struct net *net)\n{\n\tstruct vlan_net *vn = net_generic(net, vlan_net_id);\n\n\tvn->proc_vlan_dir = proc_net_mkdir(net, name_root, net->proc_net);\n\tif (!vn->proc_vlan_dir)\n\t\tgoto err;\n\n\tvn->proc_vlan_conf = proc_create_net(name_conf, S_IFREG | 0600,\n\t\t\tvn->proc_vlan_dir, &vlan_seq_ops,\n\t\t\tsizeof(struct seq_net_private));\n\tif (!vn->proc_vlan_conf)\n\t\tgoto err;\n\treturn 0;\n\nerr:\n\tpr_err(\"can't create entry in proc filesystem!\\n\");\n\tvlan_proc_cleanup(net);\n\treturn -ENOBUFS;\n}\n\n \n\nint vlan_proc_add_dev(struct net_device *vlandev)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(vlandev);\n\tstruct vlan_net *vn = net_generic(dev_net(vlandev), vlan_net_id);\n\n\tif (!strcmp(vlandev->name, name_conf))\n\t\treturn -EINVAL;\n\tvlan->dent = proc_create_single_data(vlandev->name, S_IFREG | 0600,\n\t\t\tvn->proc_vlan_dir, vlandev_seq_show, vlandev);\n\tif (!vlan->dent)\n\t\treturn -ENOBUFS;\n\treturn 0;\n}\n\n \nvoid vlan_proc_rem_dev(struct net_device *vlandev)\n{\n\t \n\tproc_remove(vlan_dev_priv(vlandev)->dent);\n\tvlan_dev_priv(vlandev)->dent = NULL;\n}\n\n \n\n \n\n \nstatic void *vlan_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rcu)\n{\n\tstruct net_device *dev;\n\tstruct net *net = seq_file_net(seq);\n\tloff_t i = 1;\n\n\trcu_read_lock();\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (!is_vlan_dev(dev))\n\t\t\tcontinue;\n\n\t\tif (i++ == *pos)\n\t\t\treturn dev;\n\t}\n\n\treturn  NULL;\n}\n\nstatic void *vlan_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct net_device *dev;\n\tstruct net *net = seq_file_net(seq);\n\n\t++*pos;\n\n\tdev = v;\n\tif (v == SEQ_START_TOKEN)\n\t\tdev = net_device_entry(&net->dev_base_head);\n\n\tfor_each_netdev_continue_rcu(net, dev) {\n\t\tif (!is_vlan_dev(dev))\n\t\t\tcontinue;\n\n\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\nstatic void vlan_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rcu)\n{\n\trcu_read_unlock();\n}\n\nstatic int vlan_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct vlan_net *vn = net_generic(net, vlan_net_id);\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tconst char *nmtype = NULL;\n\n\t\tseq_puts(seq, \"VLAN Dev name\t | VLAN ID\\n\");\n\n\t\tif (vn->name_type < ARRAY_SIZE(vlan_name_type_str))\n\t\t    nmtype =  vlan_name_type_str[vn->name_type];\n\n\t\tseq_printf(seq, \"Name-Type: %s\\n\",\n\t\t\t   nmtype ? nmtype :  \"UNKNOWN\");\n\t} else {\n\t\tconst struct net_device *vlandev = v;\n\t\tconst struct vlan_dev_priv *vlan = vlan_dev_priv(vlandev);\n\n\t\tseq_printf(seq, \"%-15s| %d  | %s\\n\",  vlandev->name,\n\t\t\t   vlan->vlan_id,    vlan->real_dev->name);\n\t}\n\treturn 0;\n}\n\nstatic int vlandev_seq_show(struct seq_file *seq, void *offset)\n{\n\tstruct net_device *vlandev = (struct net_device *) seq->private;\n\tconst struct vlan_dev_priv *vlan = vlan_dev_priv(vlandev);\n\tstruct rtnl_link_stats64 temp;\n\tconst struct rtnl_link_stats64 *stats;\n\tstatic const char fmt64[] = \"%30s %12llu\\n\";\n\tint i;\n\n\tif (!is_vlan_dev(vlandev))\n\t\treturn 0;\n\n\tstats = dev_get_stats(vlandev, &temp);\n\tseq_printf(seq,\n\t\t   \"%s  VID: %d\t REORDER_HDR: %i  dev->priv_flags: %llx\\n\",\n\t\t   vlandev->name, vlan->vlan_id,\n\t\t   (int)(vlan->flags & 1), vlandev->priv_flags);\n\n\tseq_printf(seq, fmt64, \"total frames received\", stats->rx_packets);\n\tseq_printf(seq, fmt64, \"total bytes received\", stats->rx_bytes);\n\tseq_printf(seq, fmt64, \"Broadcast/Multicast Rcvd\", stats->multicast);\n\tseq_puts(seq, \"\\n\");\n\tseq_printf(seq, fmt64, \"total frames transmitted\", stats->tx_packets);\n\tseq_printf(seq, fmt64, \"total bytes transmitted\", stats->tx_bytes);\n\tseq_printf(seq, \"Device: %s\", vlan->real_dev->name);\n\t \n\tseq_printf(seq, \"\\nINGRESS priority mappings: \"\n\t\t\t\"0:%u  1:%u  2:%u  3:%u  4:%u  5:%u  6:%u 7:%u\\n\",\n\t\t   vlan->ingress_priority_map[0],\n\t\t   vlan->ingress_priority_map[1],\n\t\t   vlan->ingress_priority_map[2],\n\t\t   vlan->ingress_priority_map[3],\n\t\t   vlan->ingress_priority_map[4],\n\t\t   vlan->ingress_priority_map[5],\n\t\t   vlan->ingress_priority_map[6],\n\t\t   vlan->ingress_priority_map[7]);\n\n\tseq_printf(seq, \" EGRESS priority mappings: \");\n\tfor (i = 0; i < 16; i++) {\n\t\tconst struct vlan_priority_tci_mapping *mp\n\t\t\t= vlan->egress_priority_map[i];\n\t\twhile (mp) {\n\t\t\tseq_printf(seq, \"%u:%d \",\n\t\t\t\t   mp->priority, ((mp->vlan_qos >> 13) & 0x7));\n\t\t\tmp = mp->next;\n\t\t}\n\t}\n\tseq_puts(seq, \"\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}