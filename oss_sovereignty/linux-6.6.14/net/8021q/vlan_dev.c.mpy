{
  "module_name": "vlan_dev.c",
  "hash_id": "e5319fe2bb5e42b2def100fccbdddc25db4a68c94a908f2c0a422e7d0feaa683",
  "original_prompt": "Ingested from linux-6.6.14/net/8021q/vlan_dev.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/phy.h>\n#include <net/arp.h>\n#include <net/macsec.h>\n\n#include \"vlan.h\"\n#include \"vlanproc.h\"\n#include <linux/if_vlan.h>\n#include <linux/netpoll.h>\n\n \nstatic int vlan_dev_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\tunsigned short type,\n\t\t\t\tconst void *daddr, const void *saddr,\n\t\t\t\tunsigned int len)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tstruct vlan_hdr *vhdr;\n\tunsigned int vhdrlen = 0;\n\tu16 vlan_tci = 0;\n\tint rc;\n\n\tif (!(vlan->flags & VLAN_FLAG_REORDER_HDR)) {\n\t\tvhdr = skb_push(skb, VLAN_HLEN);\n\n\t\tvlan_tci = vlan->vlan_id;\n\t\tvlan_tci |= vlan_dev_get_egress_qos_mask(dev, skb->priority);\n\t\tvhdr->h_vlan_TCI = htons(vlan_tci);\n\n\t\t \n\t\tif (type != ETH_P_802_3 && type != ETH_P_802_2)\n\t\t\tvhdr->h_vlan_encapsulated_proto = htons(type);\n\t\telse\n\t\t\tvhdr->h_vlan_encapsulated_proto = htons(len);\n\n\t\tskb->protocol = vlan->vlan_proto;\n\t\ttype = ntohs(vlan->vlan_proto);\n\t\tvhdrlen = VLAN_HLEN;\n\t}\n\n\t \n\tif (saddr == NULL)\n\t\tsaddr = dev->dev_addr;\n\n\t \n\tdev = vlan->real_dev;\n\trc = dev_hard_header(skb, dev, type, daddr, saddr, len + vhdrlen);\n\tif (rc > 0)\n\t\trc += vhdrlen;\n\treturn rc;\n}\n\nstatic inline netdev_tx_t vlan_netpoll_send_skb(struct vlan_dev_priv *vlan, struct sk_buff *skb)\n{\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\treturn netpoll_send_skb(vlan->netpoll, skb);\n#else\n\tBUG();\n\treturn NETDEV_TX_OK;\n#endif\n}\n\nstatic netdev_tx_t vlan_dev_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tstruct vlan_ethhdr *veth = (struct vlan_ethhdr *)(skb->data);\n\tunsigned int len;\n\tint ret;\n\n\t \n\tif (vlan->flags & VLAN_FLAG_REORDER_HDR ||\n\t    veth->h_vlan_proto != vlan->vlan_proto) {\n\t\tu16 vlan_tci;\n\t\tvlan_tci = vlan->vlan_id;\n\t\tvlan_tci |= vlan_dev_get_egress_qos_mask(dev, skb->priority);\n\t\t__vlan_hwaccel_put_tag(skb, vlan->vlan_proto, vlan_tci);\n\t}\n\n\tskb->dev = vlan->real_dev;\n\tlen = skb->len;\n\tif (unlikely(netpoll_tx_running(dev)))\n\t\treturn vlan_netpoll_send_skb(vlan, skb);\n\n\tret = dev_queue_xmit(skb);\n\n\tif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {\n\t\tstruct vlan_pcpu_stats *stats;\n\n\t\tstats = this_cpu_ptr(vlan->vlan_pcpu_stats);\n\t\tu64_stats_update_begin(&stats->syncp);\n\t\tu64_stats_inc(&stats->tx_packets);\n\t\tu64_stats_add(&stats->tx_bytes, len);\n\t\tu64_stats_update_end(&stats->syncp);\n\t} else {\n\t\tthis_cpu_inc(vlan->vlan_pcpu_stats->tx_dropped);\n\t}\n\n\treturn ret;\n}\n\nstatic int vlan_dev_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\tunsigned int max_mtu = real_dev->mtu;\n\n\tif (netif_reduces_vlan_mtu(real_dev))\n\t\tmax_mtu -= VLAN_HLEN;\n\tif (max_mtu < new_mtu)\n\t\treturn -ERANGE;\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nvoid vlan_dev_set_ingress_priority(const struct net_device *dev,\n\t\t\t\t   u32 skb_prio, u16 vlan_prio)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\n\tif (vlan->ingress_priority_map[vlan_prio & 0x7] && !skb_prio)\n\t\tvlan->nr_ingress_mappings--;\n\telse if (!vlan->ingress_priority_map[vlan_prio & 0x7] && skb_prio)\n\t\tvlan->nr_ingress_mappings++;\n\n\tvlan->ingress_priority_map[vlan_prio & 0x7] = skb_prio;\n}\n\nint vlan_dev_set_egress_priority(const struct net_device *dev,\n\t\t\t\t u32 skb_prio, u16 vlan_prio)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tstruct vlan_priority_tci_mapping *mp = NULL;\n\tstruct vlan_priority_tci_mapping *np;\n\tu32 vlan_qos = (vlan_prio << VLAN_PRIO_SHIFT) & VLAN_PRIO_MASK;\n\n\t \n\tmp = vlan->egress_priority_map[skb_prio & 0xF];\n\twhile (mp) {\n\t\tif (mp->priority == skb_prio) {\n\t\t\tif (mp->vlan_qos && !vlan_qos)\n\t\t\t\tvlan->nr_egress_mappings--;\n\t\t\telse if (!mp->vlan_qos && vlan_qos)\n\t\t\t\tvlan->nr_egress_mappings++;\n\t\t\tmp->vlan_qos = vlan_qos;\n\t\t\treturn 0;\n\t\t}\n\t\tmp = mp->next;\n\t}\n\n\t \n\tmp = vlan->egress_priority_map[skb_prio & 0xF];\n\tnp = kmalloc(sizeof(struct vlan_priority_tci_mapping), GFP_KERNEL);\n\tif (!np)\n\t\treturn -ENOBUFS;\n\n\tnp->next = mp;\n\tnp->priority = skb_prio;\n\tnp->vlan_qos = vlan_qos;\n\t \n\tsmp_wmb();\n\tvlan->egress_priority_map[skb_prio & 0xF] = np;\n\tif (vlan_qos)\n\t\tvlan->nr_egress_mappings++;\n\treturn 0;\n}\n\n \nint vlan_dev_change_flags(const struct net_device *dev, u32 flags, u32 mask)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tu32 old_flags = vlan->flags;\n\n\tif (mask & ~(VLAN_FLAG_REORDER_HDR | VLAN_FLAG_GVRP |\n\t\t     VLAN_FLAG_LOOSE_BINDING | VLAN_FLAG_MVRP |\n\t\t     VLAN_FLAG_BRIDGE_BINDING))\n\t\treturn -EINVAL;\n\n\tvlan->flags = (old_flags & ~mask) | (flags & mask);\n\n\tif (netif_running(dev) && (vlan->flags ^ old_flags) & VLAN_FLAG_GVRP) {\n\t\tif (vlan->flags & VLAN_FLAG_GVRP)\n\t\t\tvlan_gvrp_request_join(dev);\n\t\telse\n\t\t\tvlan_gvrp_request_leave(dev);\n\t}\n\n\tif (netif_running(dev) && (vlan->flags ^ old_flags) & VLAN_FLAG_MVRP) {\n\t\tif (vlan->flags & VLAN_FLAG_MVRP)\n\t\t\tvlan_mvrp_request_join(dev);\n\t\telse\n\t\t\tvlan_mvrp_request_leave(dev);\n\t}\n\treturn 0;\n}\n\nvoid vlan_dev_get_realdev_name(const struct net_device *dev, char *result, size_t size)\n{\n\tstrscpy_pad(result, vlan_dev_priv(dev)->real_dev->name, size);\n}\n\nbool vlan_dev_inherit_address(struct net_device *dev,\n\t\t\t      struct net_device *real_dev)\n{\n\tif (dev->addr_assign_type != NET_ADDR_STOLEN)\n\t\treturn false;\n\n\teth_hw_addr_set(dev, real_dev->dev_addr);\n\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, dev);\n\treturn true;\n}\n\nstatic int vlan_dev_open(struct net_device *dev)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tstruct net_device *real_dev = vlan->real_dev;\n\tint err;\n\n\tif (!(real_dev->flags & IFF_UP) &&\n\t    !(vlan->flags & VLAN_FLAG_LOOSE_BINDING))\n\t\treturn -ENETDOWN;\n\n\tif (!ether_addr_equal(dev->dev_addr, real_dev->dev_addr) &&\n\t    !vlan_dev_inherit_address(dev, real_dev)) {\n\t\terr = dev_uc_add(real_dev, dev->dev_addr);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\terr = dev_set_allmulti(real_dev, 1);\n\t\tif (err < 0)\n\t\t\tgoto del_unicast;\n\t}\n\tif (dev->flags & IFF_PROMISC) {\n\t\terr = dev_set_promiscuity(real_dev, 1);\n\t\tif (err < 0)\n\t\t\tgoto clear_allmulti;\n\t}\n\n\tether_addr_copy(vlan->real_dev_addr, real_dev->dev_addr);\n\n\tif (vlan->flags & VLAN_FLAG_GVRP)\n\t\tvlan_gvrp_request_join(dev);\n\n\tif (vlan->flags & VLAN_FLAG_MVRP)\n\t\tvlan_mvrp_request_join(dev);\n\n\tif (netif_carrier_ok(real_dev) &&\n\t    !(vlan->flags & VLAN_FLAG_BRIDGE_BINDING))\n\t\tnetif_carrier_on(dev);\n\treturn 0;\n\nclear_allmulti:\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(real_dev, -1);\ndel_unicast:\n\tif (!ether_addr_equal(dev->dev_addr, real_dev->dev_addr))\n\t\tdev_uc_del(real_dev, dev->dev_addr);\nout:\n\tnetif_carrier_off(dev);\n\treturn err;\n}\n\nstatic int vlan_dev_stop(struct net_device *dev)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tstruct net_device *real_dev = vlan->real_dev;\n\n\tdev_mc_unsync(real_dev, dev);\n\tdev_uc_unsync(real_dev, dev);\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(real_dev, -1);\n\tif (dev->flags & IFF_PROMISC)\n\t\tdev_set_promiscuity(real_dev, -1);\n\n\tif (!ether_addr_equal(dev->dev_addr, real_dev->dev_addr))\n\t\tdev_uc_del(real_dev, dev->dev_addr);\n\n\tif (!(vlan->flags & VLAN_FLAG_BRIDGE_BINDING))\n\t\tnetif_carrier_off(dev);\n\treturn 0;\n}\n\nstatic int vlan_dev_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\tstruct sockaddr *addr = p;\n\tint err;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!(dev->flags & IFF_UP))\n\t\tgoto out;\n\n\tif (!ether_addr_equal(addr->sa_data, real_dev->dev_addr)) {\n\t\terr = dev_uc_add(real_dev, addr->sa_data);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!ether_addr_equal(dev->dev_addr, real_dev->dev_addr))\n\t\tdev_uc_del(real_dev, dev->dev_addr);\n\nout:\n\teth_hw_addr_set(dev, addr->sa_data);\n\treturn 0;\n}\n\nstatic int vlan_hwtstamp_get(struct net_device *dev,\n\t\t\t     struct kernel_hwtstamp_config *cfg)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\n\treturn generic_hwtstamp_get_lower(real_dev, cfg);\n}\n\nstatic int vlan_hwtstamp_set(struct net_device *dev,\n\t\t\t     struct kernel_hwtstamp_config *cfg,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\n\tif (!net_eq(dev_net(dev), dev_net(real_dev)))\n\t\treturn -EOPNOTSUPP;\n\n\treturn generic_hwtstamp_set_lower(real_dev, cfg, extack);\n}\n\nstatic int vlan_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tstruct ifreq ifrr;\n\tint err = -EOPNOTSUPP;\n\n\tstrscpy_pad(ifrr.ifr_name, real_dev->name, IFNAMSIZ);\n\tifrr.ifr_ifru = ifr->ifr_ifru;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\tif (netif_device_present(real_dev) && ops->ndo_eth_ioctl)\n\t\t\terr = ops->ndo_eth_ioctl(real_dev, &ifrr, cmd);\n\t\tbreak;\n\t}\n\n\tif (!err)\n\t\tifr->ifr_ifru = ifrr.ifr_ifru;\n\n\treturn err;\n}\n\nstatic int vlan_dev_neigh_setup(struct net_device *dev, struct neigh_parms *pa)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint err = 0;\n\n\tif (netif_device_present(real_dev) && ops->ndo_neigh_setup)\n\t\terr = ops->ndo_neigh_setup(real_dev, pa);\n\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_FCOE)\nstatic int vlan_dev_fcoe_ddp_setup(struct net_device *dev, u16 xid,\n\t\t\t\t   struct scatterlist *sgl, unsigned int sgc)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = 0;\n\n\tif (ops->ndo_fcoe_ddp_setup)\n\t\trc = ops->ndo_fcoe_ddp_setup(real_dev, xid, sgl, sgc);\n\n\treturn rc;\n}\n\nstatic int vlan_dev_fcoe_ddp_done(struct net_device *dev, u16 xid)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint len = 0;\n\n\tif (ops->ndo_fcoe_ddp_done)\n\t\tlen = ops->ndo_fcoe_ddp_done(real_dev, xid);\n\n\treturn len;\n}\n\nstatic int vlan_dev_fcoe_enable(struct net_device *dev)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = -EINVAL;\n\n\tif (ops->ndo_fcoe_enable)\n\t\trc = ops->ndo_fcoe_enable(real_dev);\n\treturn rc;\n}\n\nstatic int vlan_dev_fcoe_disable(struct net_device *dev)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = -EINVAL;\n\n\tif (ops->ndo_fcoe_disable)\n\t\trc = ops->ndo_fcoe_disable(real_dev);\n\treturn rc;\n}\n\nstatic int vlan_dev_fcoe_ddp_target(struct net_device *dev, u16 xid,\n\t\t\t\t    struct scatterlist *sgl, unsigned int sgc)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = 0;\n\n\tif (ops->ndo_fcoe_ddp_target)\n\t\trc = ops->ndo_fcoe_ddp_target(real_dev, xid, sgl, sgc);\n\n\treturn rc;\n}\n#endif\n\n#ifdef NETDEV_FCOE_WWNN\nstatic int vlan_dev_fcoe_get_wwn(struct net_device *dev, u64 *wwn, int type)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = -EINVAL;\n\n\tif (ops->ndo_fcoe_get_wwn)\n\t\trc = ops->ndo_fcoe_get_wwn(real_dev, wwn, type);\n\treturn rc;\n}\n#endif\n\nstatic void vlan_dev_change_rx_flags(struct net_device *dev, int change)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\n\tif (dev->flags & IFF_UP) {\n\t\tif (change & IFF_ALLMULTI)\n\t\t\tdev_set_allmulti(real_dev, dev->flags & IFF_ALLMULTI ? 1 : -1);\n\t\tif (change & IFF_PROMISC)\n\t\t\tdev_set_promiscuity(real_dev, dev->flags & IFF_PROMISC ? 1 : -1);\n\t}\n}\n\nstatic void vlan_dev_set_rx_mode(struct net_device *vlan_dev)\n{\n\tdev_mc_sync(vlan_dev_priv(vlan_dev)->real_dev, vlan_dev);\n\tdev_uc_sync(vlan_dev_priv(vlan_dev)->real_dev, vlan_dev);\n}\n\n \nstatic struct lock_class_key vlan_netdev_xmit_lock_key;\nstatic struct lock_class_key vlan_netdev_addr_lock_key;\n\nstatic void vlan_dev_set_lockdep_one(struct net_device *dev,\n\t\t\t\t     struct netdev_queue *txq,\n\t\t\t\t     void *unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock, &vlan_netdev_xmit_lock_key);\n}\n\nstatic void vlan_dev_set_lockdep_class(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock,\n\t\t\t  &vlan_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, vlan_dev_set_lockdep_one, NULL);\n}\n\nstatic __be16 vlan_parse_protocol(const struct sk_buff *skb)\n{\n\tstruct vlan_ethhdr *veth = (struct vlan_ethhdr *)(skb->data);\n\n\treturn __vlan_get_protocol(skb, veth->h_vlan_proto, NULL);\n}\n\nstatic const struct header_ops vlan_header_ops = {\n\t.create\t = vlan_dev_hard_header,\n\t.parse\t = eth_header_parse,\n\t.parse_protocol = vlan_parse_protocol,\n};\n\nstatic int vlan_passthru_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t     unsigned short type,\n\t\t\t\t     const void *daddr, const void *saddr,\n\t\t\t\t     unsigned int len)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tstruct net_device *real_dev = vlan->real_dev;\n\n\tif (saddr == NULL)\n\t\tsaddr = dev->dev_addr;\n\n\treturn dev_hard_header(skb, real_dev, type, daddr, saddr, len);\n}\n\nstatic const struct header_ops vlan_passthru_header_ops = {\n\t.create\t = vlan_passthru_hard_header,\n\t.parse\t = eth_header_parse,\n\t.parse_protocol = vlan_parse_protocol,\n};\n\nstatic struct device_type vlan_type = {\n\t.name\t= \"vlan\",\n};\n\nstatic const struct net_device_ops vlan_netdev_ops;\n\nstatic int vlan_dev_init(struct net_device *dev)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tstruct net_device *real_dev = vlan->real_dev;\n\n\tnetif_carrier_off(dev);\n\n\t \n\tdev->flags  = real_dev->flags & ~(IFF_UP | IFF_PROMISC | IFF_ALLMULTI |\n\t\t\t\t\t  IFF_MASTER | IFF_SLAVE);\n\tdev->state  = (real_dev->state & ((1<<__LINK_STATE_NOCARRIER) |\n\t\t\t\t\t  (1<<__LINK_STATE_DORMANT))) |\n\t\t      (1<<__LINK_STATE_PRESENT);\n\n\tif (vlan->flags & VLAN_FLAG_BRIDGE_BINDING)\n\t\tdev->state |= (1 << __LINK_STATE_NOCARRIER);\n\n\tdev->hw_features = NETIF_F_HW_CSUM | NETIF_F_SG |\n\t\t\t   NETIF_F_FRAGLIST | NETIF_F_GSO_SOFTWARE |\n\t\t\t   NETIF_F_GSO_ENCAP_ALL |\n\t\t\t   NETIF_F_HIGHDMA | NETIF_F_SCTP_CRC |\n\t\t\t   NETIF_F_ALL_FCOE;\n\n\tif (real_dev->vlan_features & NETIF_F_HW_MACSEC)\n\t\tdev->hw_features |= NETIF_F_HW_MACSEC;\n\n\tdev->features |= dev->hw_features | NETIF_F_LLTX;\n\tnetif_inherit_tso_max(dev, real_dev);\n\tif (dev->features & NETIF_F_VLAN_FEATURES)\n\t\tnetdev_warn(real_dev, \"VLAN features are set incorrectly.  Q-in-Q configurations may not work correctly.\\n\");\n\n\tdev->vlan_features = real_dev->vlan_features & ~NETIF_F_ALL_FCOE;\n\tdev->hw_enc_features = vlan_tnl_features(real_dev);\n\tdev->mpls_features = real_dev->mpls_features;\n\n\t \n\tdev->dev_id = real_dev->dev_id;\n\n\tif (is_zero_ether_addr(dev->dev_addr)) {\n\t\teth_hw_addr_set(dev, real_dev->dev_addr);\n\t\tdev->addr_assign_type = NET_ADDR_STOLEN;\n\t}\n\tif (is_zero_ether_addr(dev->broadcast))\n\t\tmemcpy(dev->broadcast, real_dev->broadcast, dev->addr_len);\n\n#if IS_ENABLED(CONFIG_FCOE)\n\tdev->fcoe_ddp_xid = real_dev->fcoe_ddp_xid;\n#endif\n\n\tdev->needed_headroom = real_dev->needed_headroom;\n\tif (vlan_hw_offload_capable(real_dev->features, vlan->vlan_proto)) {\n\t\tdev->header_ops      = &vlan_passthru_header_ops;\n\t\tdev->hard_header_len = real_dev->hard_header_len;\n\t} else {\n\t\tdev->header_ops      = &vlan_header_ops;\n\t\tdev->hard_header_len = real_dev->hard_header_len + VLAN_HLEN;\n\t}\n\n\tdev->netdev_ops = &vlan_netdev_ops;\n\n\tSET_NETDEV_DEVTYPE(dev, &vlan_type);\n\n\tvlan_dev_set_lockdep_class(dev);\n\n\tvlan->vlan_pcpu_stats = netdev_alloc_pcpu_stats(struct vlan_pcpu_stats);\n\tif (!vlan->vlan_pcpu_stats)\n\t\treturn -ENOMEM;\n\n\t \n\tnetdev_hold(real_dev, &vlan->dev_tracker, GFP_KERNEL);\n\n\treturn 0;\n}\n\n \nvoid vlan_dev_free_egress_priority(const struct net_device *dev)\n{\n\tstruct vlan_priority_tci_mapping *pm;\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vlan->egress_priority_map); i++) {\n\t\twhile ((pm = vlan->egress_priority_map[i]) != NULL) {\n\t\t\tvlan->egress_priority_map[i] = pm->next;\n\t\t\tkfree(pm);\n\t\t}\n\t}\n}\n\nstatic void vlan_dev_uninit(struct net_device *dev)\n{\n\tvlan_dev_free_egress_priority(dev);\n}\n\nstatic netdev_features_t vlan_dev_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\tnetdev_features_t old_features = features;\n\tnetdev_features_t lower_features;\n\n\tlower_features = netdev_intersect_features((real_dev->vlan_features |\n\t\t\t\t\t\t    NETIF_F_RXCSUM),\n\t\t\t\t\t\t   real_dev->features);\n\n\t \n\tif (lower_features & (NETIF_F_IP_CSUM|NETIF_F_IPV6_CSUM))\n\t\tlower_features |= NETIF_F_HW_CSUM;\n\tfeatures = netdev_intersect_features(features, lower_features);\n\tfeatures |= old_features & (NETIF_F_SOFT_FEATURES | NETIF_F_GSO_SOFTWARE);\n\tfeatures |= NETIF_F_LLTX;\n\n\treturn features;\n}\n\nstatic int vlan_ethtool_get_link_ksettings(struct net_device *dev,\n\t\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tconst struct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\n\treturn __ethtool_get_link_ksettings(vlan->real_dev, cmd);\n}\n\nstatic void vlan_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, vlan_fullname, sizeof(info->driver));\n\tstrscpy(info->version, vlan_version, sizeof(info->version));\n\tstrscpy(info->fw_version, \"N/A\", sizeof(info->fw_version));\n}\n\nstatic int vlan_ethtool_get_ts_info(struct net_device *dev,\n\t\t\t\t    struct ethtool_ts_info *info)\n{\n\tconst struct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tconst struct ethtool_ops *ops = vlan->real_dev->ethtool_ops;\n\tstruct phy_device *phydev = vlan->real_dev->phydev;\n\n\tif (phy_has_tsinfo(phydev)) {\n\t\treturn phy_ts_info(phydev, info);\n\t} else if (ops->get_ts_info) {\n\t\treturn ops->get_ts_info(vlan->real_dev, info);\n\t} else {\n\t\tinfo->so_timestamping = SOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\tSOF_TIMESTAMPING_SOFTWARE;\n\t\tinfo->phc_index = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void vlan_dev_get_stats64(struct net_device *dev,\n\t\t\t\t struct rtnl_link_stats64 *stats)\n{\n\tstruct vlan_pcpu_stats *p;\n\tu32 rx_errors = 0, tx_dropped = 0;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tu64 rxpackets, rxbytes, rxmulticast, txpackets, txbytes;\n\t\tunsigned int start;\n\n\t\tp = per_cpu_ptr(vlan_dev_priv(dev)->vlan_pcpu_stats, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&p->syncp);\n\t\t\trxpackets\t= u64_stats_read(&p->rx_packets);\n\t\t\trxbytes\t\t= u64_stats_read(&p->rx_bytes);\n\t\t\trxmulticast\t= u64_stats_read(&p->rx_multicast);\n\t\t\ttxpackets\t= u64_stats_read(&p->tx_packets);\n\t\t\ttxbytes\t\t= u64_stats_read(&p->tx_bytes);\n\t\t} while (u64_stats_fetch_retry(&p->syncp, start));\n\n\t\tstats->rx_packets\t+= rxpackets;\n\t\tstats->rx_bytes\t\t+= rxbytes;\n\t\tstats->multicast\t+= rxmulticast;\n\t\tstats->tx_packets\t+= txpackets;\n\t\tstats->tx_bytes\t\t+= txbytes;\n\t\t \n\t\trx_errors\t+= READ_ONCE(p->rx_errors);\n\t\ttx_dropped\t+= READ_ONCE(p->tx_dropped);\n\t}\n\tstats->rx_errors  = rx_errors;\n\tstats->tx_dropped = tx_dropped;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void vlan_dev_poll_controller(struct net_device *dev)\n{\n\treturn;\n}\n\nstatic int vlan_dev_netpoll_setup(struct net_device *dev, struct netpoll_info *npinfo)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\tstruct net_device *real_dev = vlan->real_dev;\n\tstruct netpoll *netpoll;\n\tint err = 0;\n\n\tnetpoll = kzalloc(sizeof(*netpoll), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!netpoll)\n\t\tgoto out;\n\n\terr = __netpoll_setup(netpoll, real_dev);\n\tif (err) {\n\t\tkfree(netpoll);\n\t\tgoto out;\n\t}\n\n\tvlan->netpoll = netpoll;\n\nout:\n\treturn err;\n}\n\nstatic void vlan_dev_netpoll_cleanup(struct net_device *dev)\n{\n\tstruct vlan_dev_priv *vlan= vlan_dev_priv(dev);\n\tstruct netpoll *netpoll = vlan->netpoll;\n\n\tif (!netpoll)\n\t\treturn;\n\n\tvlan->netpoll = NULL;\n\t__netpoll_free(netpoll);\n}\n#endif  \n\nstatic int vlan_dev_get_iflink(const struct net_device *dev)\n{\n\tstruct net_device *real_dev = vlan_dev_priv(dev)->real_dev;\n\n\treturn real_dev->ifindex;\n}\n\nstatic int vlan_dev_fill_forward_path(struct net_device_path_ctx *ctx,\n\t\t\t\t      struct net_device_path *path)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(ctx->dev);\n\n\tpath->type = DEV_PATH_VLAN;\n\tpath->encap.id = vlan->vlan_id;\n\tpath->encap.proto = vlan->vlan_proto;\n\tpath->dev = ctx->dev;\n\tctx->dev = vlan->real_dev;\n\tif (ctx->num_vlans >= ARRAY_SIZE(ctx->vlan))\n\t\treturn -ENOSPC;\n\n\tctx->vlan[ctx->num_vlans].id = vlan->vlan_id;\n\tctx->vlan[ctx->num_vlans].proto = vlan->vlan_proto;\n\tctx->num_vlans++;\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_MACSEC)\n\nstatic const struct macsec_ops *vlan_get_macsec_ops(const struct macsec_context *ctx)\n{\n\treturn vlan_dev_priv(ctx->netdev)->real_dev->macsec_ops;\n}\n\nstatic int vlan_macsec_offload(int (* const func)(struct macsec_context *),\n\t\t\t       struct macsec_context *ctx)\n{\n\tif (unlikely(!func))\n\t\treturn 0;\n\n\treturn (*func)(ctx);\n}\n\nstatic int vlan_macsec_dev_open(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_dev_open, ctx);\n}\n\nstatic int vlan_macsec_dev_stop(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_dev_stop, ctx);\n}\n\nstatic int vlan_macsec_add_secy(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_add_secy, ctx);\n}\n\nstatic int vlan_macsec_upd_secy(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_upd_secy, ctx);\n}\n\nstatic int vlan_macsec_del_secy(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_del_secy, ctx);\n}\n\nstatic int vlan_macsec_add_rxsc(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_add_rxsc, ctx);\n}\n\nstatic int vlan_macsec_upd_rxsc(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_upd_rxsc, ctx);\n}\n\nstatic int vlan_macsec_del_rxsc(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_del_rxsc, ctx);\n}\n\nstatic int vlan_macsec_add_rxsa(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_add_rxsa, ctx);\n}\n\nstatic int vlan_macsec_upd_rxsa(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_upd_rxsa, ctx);\n}\n\nstatic int vlan_macsec_del_rxsa(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_del_rxsa, ctx);\n}\n\nstatic int vlan_macsec_add_txsa(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_add_txsa, ctx);\n}\n\nstatic int vlan_macsec_upd_txsa(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_upd_txsa, ctx);\n}\n\nstatic int vlan_macsec_del_txsa(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_del_txsa, ctx);\n}\n\nstatic int vlan_macsec_get_dev_stats(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_get_dev_stats, ctx);\n}\n\nstatic int vlan_macsec_get_tx_sc_stats(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_get_tx_sc_stats, ctx);\n}\n\nstatic int vlan_macsec_get_tx_sa_stats(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_get_tx_sa_stats, ctx);\n}\n\nstatic int vlan_macsec_get_rx_sc_stats(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_get_rx_sc_stats, ctx);\n}\n\nstatic int vlan_macsec_get_rx_sa_stats(struct macsec_context *ctx)\n{\n\tconst struct macsec_ops *ops = vlan_get_macsec_ops(ctx);\n\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\treturn vlan_macsec_offload(ops->mdo_get_rx_sa_stats, ctx);\n}\n\nstatic const struct macsec_ops macsec_offload_ops = {\n\t \n\t.mdo_dev_open = vlan_macsec_dev_open,\n\t.mdo_dev_stop = vlan_macsec_dev_stop,\n\t \n\t.mdo_add_secy = vlan_macsec_add_secy,\n\t.mdo_upd_secy = vlan_macsec_upd_secy,\n\t.mdo_del_secy = vlan_macsec_del_secy,\n\t \n\t.mdo_add_rxsc = vlan_macsec_add_rxsc,\n\t.mdo_upd_rxsc = vlan_macsec_upd_rxsc,\n\t.mdo_del_rxsc = vlan_macsec_del_rxsc,\n\t \n\t.mdo_add_rxsa = vlan_macsec_add_rxsa,\n\t.mdo_upd_rxsa = vlan_macsec_upd_rxsa,\n\t.mdo_del_rxsa = vlan_macsec_del_rxsa,\n\t.mdo_add_txsa = vlan_macsec_add_txsa,\n\t.mdo_upd_txsa = vlan_macsec_upd_txsa,\n\t.mdo_del_txsa = vlan_macsec_del_txsa,\n\t \n\t.mdo_get_dev_stats = vlan_macsec_get_dev_stats,\n\t.mdo_get_tx_sc_stats = vlan_macsec_get_tx_sc_stats,\n\t.mdo_get_tx_sa_stats = vlan_macsec_get_tx_sa_stats,\n\t.mdo_get_rx_sc_stats = vlan_macsec_get_rx_sc_stats,\n\t.mdo_get_rx_sa_stats = vlan_macsec_get_rx_sa_stats,\n};\n\n#endif\n\nstatic const struct ethtool_ops vlan_ethtool_ops = {\n\t.get_link_ksettings\t= vlan_ethtool_get_link_ksettings,\n\t.get_drvinfo\t        = vlan_ethtool_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_ts_info\t\t= vlan_ethtool_get_ts_info,\n};\n\nstatic const struct net_device_ops vlan_netdev_ops = {\n\t.ndo_change_mtu\t\t= vlan_dev_change_mtu,\n\t.ndo_init\t\t= vlan_dev_init,\n\t.ndo_uninit\t\t= vlan_dev_uninit,\n\t.ndo_open\t\t= vlan_dev_open,\n\t.ndo_stop\t\t= vlan_dev_stop,\n\t.ndo_start_xmit =  vlan_dev_hard_start_xmit,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= vlan_dev_set_mac_address,\n\t.ndo_set_rx_mode\t= vlan_dev_set_rx_mode,\n\t.ndo_change_rx_flags\t= vlan_dev_change_rx_flags,\n\t.ndo_eth_ioctl\t\t= vlan_dev_ioctl,\n\t.ndo_neigh_setup\t= vlan_dev_neigh_setup,\n\t.ndo_get_stats64\t= vlan_dev_get_stats64,\n#if IS_ENABLED(CONFIG_FCOE)\n\t.ndo_fcoe_ddp_setup\t= vlan_dev_fcoe_ddp_setup,\n\t.ndo_fcoe_ddp_done\t= vlan_dev_fcoe_ddp_done,\n\t.ndo_fcoe_enable\t= vlan_dev_fcoe_enable,\n\t.ndo_fcoe_disable\t= vlan_dev_fcoe_disable,\n\t.ndo_fcoe_ddp_target\t= vlan_dev_fcoe_ddp_target,\n#endif\n#ifdef NETDEV_FCOE_WWNN\n\t.ndo_fcoe_get_wwn\t= vlan_dev_fcoe_get_wwn,\n#endif\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= vlan_dev_poll_controller,\n\t.ndo_netpoll_setup\t= vlan_dev_netpoll_setup,\n\t.ndo_netpoll_cleanup\t= vlan_dev_netpoll_cleanup,\n#endif\n\t.ndo_fix_features\t= vlan_dev_fix_features,\n\t.ndo_get_iflink\t\t= vlan_dev_get_iflink,\n\t.ndo_fill_forward_path\t= vlan_dev_fill_forward_path,\n\t.ndo_hwtstamp_get\t= vlan_hwtstamp_get,\n\t.ndo_hwtstamp_set\t= vlan_hwtstamp_set,\n};\n\nstatic void vlan_dev_free(struct net_device *dev)\n{\n\tstruct vlan_dev_priv *vlan = vlan_dev_priv(dev);\n\n\tfree_percpu(vlan->vlan_pcpu_stats);\n\tvlan->vlan_pcpu_stats = NULL;\n\n\t \n\tnetdev_put(vlan->real_dev, &vlan->dev_tracker);\n}\n\nvoid vlan_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->priv_flags\t\t|= IFF_802_1Q_VLAN | IFF_NO_QUEUE;\n\tdev->priv_flags\t\t|= IFF_UNICAST_FLT;\n\tdev->priv_flags\t\t&= ~IFF_TX_SKB_SHARING;\n\tnetif_keep_dst(dev);\n\n\tdev->netdev_ops\t\t= &vlan_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->priv_destructor\t= vlan_dev_free;\n\tdev->ethtool_ops\t= &vlan_ethtool_ops;\n\n#if IS_ENABLED(CONFIG_MACSEC)\n\tdev->macsec_ops\t\t= &macsec_offload_ops;\n#endif\n\tdev->min_mtu\t\t= 0;\n\tdev->max_mtu\t\t= ETH_MAX_MTU;\n\n\teth_zero_addr(dev->broadcast);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}