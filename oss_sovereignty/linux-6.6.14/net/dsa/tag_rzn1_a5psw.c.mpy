{
  "module_name": "tag_rzn1_a5psw.c",
  "hash_id": "09fd8a7fdaf115d9e045722a22b64a053e8727a24083358d29e10ab64bcef5a0",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag_rzn1_a5psw.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <net/dsa.h>\n\n#include \"tag.h\"\n\n \n\n#define A5PSW_NAME\t\t\t\"a5psw\"\n\n#define ETH_P_DSA_A5PSW\t\t\t0xE001\n#define A5PSW_TAG_LEN\t\t\t8\n#define A5PSW_CTRL_DATA_FORCE_FORWARD\tBIT(0)\n \n#define A5PSW_CTRL_DATA_PORT\t\tGENMASK(3, 0)\n\nstruct a5psw_tag {\n\t__be16 ctrl_tag;\n\t__be16 ctrl_data;\n\t__be16 ctrl_data2_hi;\n\t__be16 ctrl_data2_lo;\n};\n\nstatic struct sk_buff *a5psw_tag_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct a5psw_tag *ptag;\n\tu32 data2_val;\n\n\tBUILD_BUG_ON(sizeof(*ptag) != A5PSW_TAG_LEN);\n\n\t \n\tif (__skb_put_padto(skb, ETH_ZLEN, false))\n\t\treturn NULL;\n\n\t \n\tskb_push(skb, A5PSW_TAG_LEN);\n\n\t \n\tdsa_alloc_etype_header(skb, A5PSW_TAG_LEN);\n\n\tptag = dsa_etype_header_pos_tx(skb);\n\n\tdata2_val = FIELD_PREP(A5PSW_CTRL_DATA_PORT, BIT(dp->index));\n\tptag->ctrl_tag = htons(ETH_P_DSA_A5PSW);\n\tptag->ctrl_data = htons(A5PSW_CTRL_DATA_FORCE_FORWARD);\n\tptag->ctrl_data2_lo = htons(data2_val);\n\tptag->ctrl_data2_hi = 0;\n\n\treturn skb;\n}\n\nstatic struct sk_buff *a5psw_tag_rcv(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct a5psw_tag *tag;\n\tint port;\n\n\tif (unlikely(!pskb_may_pull(skb, A5PSW_TAG_LEN))) {\n\t\tdev_warn_ratelimited(&dev->dev,\n\t\t\t\t     \"Dropping packet, cannot pull\\n\");\n\t\treturn NULL;\n\t}\n\n\ttag = dsa_etype_header_pos_rx(skb);\n\n\tif (tag->ctrl_tag != htons(ETH_P_DSA_A5PSW)) {\n\t\tdev_warn_ratelimited(&dev->dev, \"Dropping packet due to invalid TAG marker\\n\");\n\t\treturn NULL;\n\t}\n\n\tport = FIELD_GET(A5PSW_CTRL_DATA_PORT, ntohs(tag->ctrl_data));\n\n\tskb->dev = dsa_master_find_slave(dev, 0, port);\n\tif (!skb->dev)\n\t\treturn NULL;\n\n\tskb_pull_rcsum(skb, A5PSW_TAG_LEN);\n\tdsa_strip_etype_header(skb, A5PSW_TAG_LEN);\n\n\tdsa_default_offload_fwd_mark(skb);\n\n\treturn skb;\n}\n\nstatic const struct dsa_device_ops a5psw_netdev_ops = {\n\t.name\t= A5PSW_NAME,\n\t.proto\t= DSA_TAG_PROTO_RZN1_A5PSW,\n\t.xmit\t= a5psw_tag_xmit,\n\t.rcv\t= a5psw_tag_rcv,\n\t.needed_headroom = A5PSW_TAG_LEN,\n};\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_A5PSW, A5PSW_NAME);\nmodule_dsa_tag_driver(a5psw_netdev_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}