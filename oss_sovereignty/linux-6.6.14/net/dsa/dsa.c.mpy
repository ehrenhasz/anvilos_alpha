{
  "module_name": "dsa.c",
  "hash_id": "a3b24b31c134c37329e8809988850e79d0cb1d608d7f6f115daa898b357c330e",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/dsa.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/rtnetlink.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <net/dsa_stubs.h>\n#include <net/sch_generic.h>\n\n#include \"devlink.h\"\n#include \"dsa.h\"\n#include \"master.h\"\n#include \"netlink.h\"\n#include \"port.h\"\n#include \"slave.h\"\n#include \"switch.h\"\n#include \"tag.h\"\n\n#define DSA_MAX_NUM_OFFLOADING_BRIDGES\t\tBITS_PER_LONG\n\nstatic DEFINE_MUTEX(dsa2_mutex);\nLIST_HEAD(dsa_tree_list);\n\nstatic struct workqueue_struct *dsa_owq;\n\n \nstatic unsigned long dsa_fwd_offloading_bridges;\n\nbool dsa_schedule_work(struct work_struct *work)\n{\n\treturn queue_work(dsa_owq, work);\n}\n\nvoid dsa_flush_workqueue(void)\n{\n\tflush_workqueue(dsa_owq);\n}\nEXPORT_SYMBOL_GPL(dsa_flush_workqueue);\n\n \nvoid dsa_lag_map(struct dsa_switch_tree *dst, struct dsa_lag *lag)\n{\n\tunsigned int id;\n\n\tfor (id = 1; id <= dst->lags_len; id++) {\n\t\tif (!dsa_lag_by_id(dst, id)) {\n\t\t\tdst->lags[id - 1] = lag;\n\t\t\tlag->id = id;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n}\n\n \nvoid dsa_lag_unmap(struct dsa_switch_tree *dst, struct dsa_lag *lag)\n{\n\tunsigned int id;\n\n\tdsa_lags_foreach_id(id, dst) {\n\t\tif (dsa_lag_by_id(dst, id) == lag) {\n\t\t\tdst->lags[id - 1] = NULL;\n\t\t\tlag->id = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstruct dsa_lag *dsa_tree_lag_find(struct dsa_switch_tree *dst,\n\t\t\t\t  const struct net_device *lag_dev)\n{\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list)\n\t\tif (dsa_port_lag_dev_get(dp) == lag_dev)\n\t\t\treturn dp->lag;\n\n\treturn NULL;\n}\n\nstruct dsa_bridge *dsa_tree_bridge_find(struct dsa_switch_tree *dst,\n\t\t\t\t\tconst struct net_device *br)\n{\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list)\n\t\tif (dsa_port_bridge_dev_get(dp) == br)\n\t\t\treturn dp->bridge;\n\n\treturn NULL;\n}\n\nstatic int dsa_bridge_num_find(const struct net_device *bridge_dev)\n{\n\tstruct dsa_switch_tree *dst;\n\n\tlist_for_each_entry(dst, &dsa_tree_list, list) {\n\t\tstruct dsa_bridge *bridge;\n\n\t\tbridge = dsa_tree_bridge_find(dst, bridge_dev);\n\t\tif (bridge)\n\t\t\treturn bridge->num;\n\t}\n\n\treturn 0;\n}\n\nunsigned int dsa_bridge_num_get(const struct net_device *bridge_dev, int max)\n{\n\tunsigned int bridge_num = dsa_bridge_num_find(bridge_dev);\n\n\t \n\tif (!max)\n\t\treturn 0;\n\n\tif (!bridge_num) {\n\t\t \n\t\tbridge_num = find_next_zero_bit(&dsa_fwd_offloading_bridges,\n\t\t\t\t\t\tDSA_MAX_NUM_OFFLOADING_BRIDGES,\n\t\t\t\t\t\t1);\n\t\tif (bridge_num >= max)\n\t\t\treturn 0;\n\n\t\tset_bit(bridge_num, &dsa_fwd_offloading_bridges);\n\t}\n\n\treturn bridge_num;\n}\n\nvoid dsa_bridge_num_put(const struct net_device *bridge_dev,\n\t\t\tunsigned int bridge_num)\n{\n\t \n\tclear_bit(bridge_num, &dsa_fwd_offloading_bridges);\n}\n\nstruct dsa_switch *dsa_switch_find(int tree_index, int sw_index)\n{\n\tstruct dsa_switch_tree *dst;\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dst, &dsa_tree_list, list) {\n\t\tif (dst->index != tree_index)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\t\tif (dp->ds->index != sw_index)\n\t\t\t\tcontinue;\n\n\t\t\treturn dp->ds;\n\t\t}\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(dsa_switch_find);\n\nstatic struct dsa_switch_tree *dsa_tree_find(int index)\n{\n\tstruct dsa_switch_tree *dst;\n\n\tlist_for_each_entry(dst, &dsa_tree_list, list)\n\t\tif (dst->index == index)\n\t\t\treturn dst;\n\n\treturn NULL;\n}\n\nstatic struct dsa_switch_tree *dsa_tree_alloc(int index)\n{\n\tstruct dsa_switch_tree *dst;\n\n\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\tif (!dst)\n\t\treturn NULL;\n\n\tdst->index = index;\n\n\tINIT_LIST_HEAD(&dst->rtable);\n\n\tINIT_LIST_HEAD(&dst->ports);\n\n\tINIT_LIST_HEAD(&dst->list);\n\tlist_add_tail(&dst->list, &dsa_tree_list);\n\n\tkref_init(&dst->refcount);\n\n\treturn dst;\n}\n\nstatic void dsa_tree_free(struct dsa_switch_tree *dst)\n{\n\tif (dst->tag_ops)\n\t\tdsa_tag_driver_put(dst->tag_ops);\n\tlist_del(&dst->list);\n\tkfree(dst);\n}\n\nstatic struct dsa_switch_tree *dsa_tree_get(struct dsa_switch_tree *dst)\n{\n\tif (dst)\n\t\tkref_get(&dst->refcount);\n\n\treturn dst;\n}\n\nstatic struct dsa_switch_tree *dsa_tree_touch(int index)\n{\n\tstruct dsa_switch_tree *dst;\n\n\tdst = dsa_tree_find(index);\n\tif (dst)\n\t\treturn dsa_tree_get(dst);\n\telse\n\t\treturn dsa_tree_alloc(index);\n}\n\nstatic void dsa_tree_release(struct kref *ref)\n{\n\tstruct dsa_switch_tree *dst;\n\n\tdst = container_of(ref, struct dsa_switch_tree, refcount);\n\n\tdsa_tree_free(dst);\n}\n\nstatic void dsa_tree_put(struct dsa_switch_tree *dst)\n{\n\tif (dst)\n\t\tkref_put(&dst->refcount, dsa_tree_release);\n}\n\nstatic struct dsa_port *dsa_tree_find_port_by_node(struct dsa_switch_tree *dst,\n\t\t\t\t\t\t   struct device_node *dn)\n{\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list)\n\t\tif (dp->dn == dn)\n\t\t\treturn dp;\n\n\treturn NULL;\n}\n\nstatic struct dsa_link *dsa_link_touch(struct dsa_port *dp,\n\t\t\t\t       struct dsa_port *link_dp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_switch_tree *dst;\n\tstruct dsa_link *dl;\n\n\tdst = ds->dst;\n\n\tlist_for_each_entry(dl, &dst->rtable, list)\n\t\tif (dl->dp == dp && dl->link_dp == link_dp)\n\t\t\treturn dl;\n\n\tdl = kzalloc(sizeof(*dl), GFP_KERNEL);\n\tif (!dl)\n\t\treturn NULL;\n\n\tdl->dp = dp;\n\tdl->link_dp = link_dp;\n\n\tINIT_LIST_HEAD(&dl->list);\n\tlist_add_tail(&dl->list, &dst->rtable);\n\n\treturn dl;\n}\n\nstatic bool dsa_port_setup_routing_table(struct dsa_port *dp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_switch_tree *dst = ds->dst;\n\tstruct device_node *dn = dp->dn;\n\tstruct of_phandle_iterator it;\n\tstruct dsa_port *link_dp;\n\tstruct dsa_link *dl;\n\tint err;\n\n\tof_for_each_phandle(&it, err, dn, \"link\", NULL, 0) {\n\t\tlink_dp = dsa_tree_find_port_by_node(dst, it.node);\n\t\tif (!link_dp) {\n\t\t\tof_node_put(it.node);\n\t\t\treturn false;\n\t\t}\n\n\t\tdl = dsa_link_touch(dp, link_dp);\n\t\tif (!dl) {\n\t\t\tof_node_put(it.node);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool dsa_tree_setup_routing_table(struct dsa_switch_tree *dst)\n{\n\tbool complete = true;\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\tif (dsa_port_is_dsa(dp)) {\n\t\t\tcomplete = dsa_port_setup_routing_table(dp);\n\t\t\tif (!complete)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn complete;\n}\n\nstatic struct dsa_port *dsa_tree_find_first_cpu(struct dsa_switch_tree *dst)\n{\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list)\n\t\tif (dsa_port_is_cpu(dp))\n\t\t\treturn dp;\n\n\treturn NULL;\n}\n\nstruct net_device *dsa_tree_find_first_master(struct dsa_switch_tree *dst)\n{\n\tstruct device_node *ethernet;\n\tstruct net_device *master;\n\tstruct dsa_port *cpu_dp;\n\n\tcpu_dp = dsa_tree_find_first_cpu(dst);\n\tethernet = of_parse_phandle(cpu_dp->dn, \"ethernet\", 0);\n\tmaster = of_find_net_device_by_node(ethernet);\n\tof_node_put(ethernet);\n\n\treturn master;\n}\n\n \nstatic int dsa_tree_setup_default_cpu(struct dsa_switch_tree *dst)\n{\n\tstruct dsa_port *cpu_dp, *dp;\n\n\tcpu_dp = dsa_tree_find_first_cpu(dst);\n\tif (!cpu_dp) {\n\t\tpr_err(\"DSA: tree %d has no CPU port\\n\", dst->index);\n\t\treturn -EINVAL;\n\t}\n\n\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\tif (dp->cpu_dp)\n\t\t\tcontinue;\n\n\t\tif (dsa_port_is_user(dp) || dsa_port_is_dsa(dp))\n\t\t\tdp->cpu_dp = cpu_dp;\n\t}\n\n\treturn 0;\n}\n\nstatic struct dsa_port *\ndsa_switch_preferred_default_local_cpu_port(struct dsa_switch *ds)\n{\n\tstruct dsa_port *cpu_dp;\n\n\tif (!ds->ops->preferred_default_local_cpu_port)\n\t\treturn NULL;\n\n\tcpu_dp = ds->ops->preferred_default_local_cpu_port(ds);\n\tif (!cpu_dp)\n\t\treturn NULL;\n\n\tif (WARN_ON(!dsa_port_is_cpu(cpu_dp) || cpu_dp->ds != ds))\n\t\treturn NULL;\n\n\treturn cpu_dp;\n}\n\n \nstatic int dsa_tree_setup_cpu_ports(struct dsa_switch_tree *dst)\n{\n\tstruct dsa_port *preferred_cpu_dp, *cpu_dp, *dp;\n\n\tlist_for_each_entry(cpu_dp, &dst->ports, list) {\n\t\tif (!dsa_port_is_cpu(cpu_dp))\n\t\t\tcontinue;\n\n\t\tpreferred_cpu_dp = dsa_switch_preferred_default_local_cpu_port(cpu_dp->ds);\n\t\tif (preferred_cpu_dp && preferred_cpu_dp != cpu_dp)\n\t\t\tcontinue;\n\n\t\t \n\t\tdsa_switch_for_each_port(dp, cpu_dp->ds) {\n\t\t\t \n\t\t\tif (dp->cpu_dp)\n\t\t\t\tcontinue;\n\n\t\t\tif (dsa_port_is_user(dp) || dsa_port_is_dsa(dp))\n\t\t\t\tdp->cpu_dp = cpu_dp;\n\t\t}\n\t}\n\n\treturn dsa_tree_setup_default_cpu(dst);\n}\n\nstatic void dsa_tree_teardown_cpu_ports(struct dsa_switch_tree *dst)\n{\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list)\n\t\tif (dsa_port_is_user(dp) || dsa_port_is_dsa(dp))\n\t\t\tdp->cpu_dp = NULL;\n}\n\nstatic int dsa_port_setup(struct dsa_port *dp)\n{\n\tbool dsa_port_link_registered = false;\n\tstruct dsa_switch *ds = dp->ds;\n\tbool dsa_port_enabled = false;\n\tint err = 0;\n\n\tif (dp->setup)\n\t\treturn 0;\n\n\terr = dsa_port_devlink_setup(dp);\n\tif (err)\n\t\treturn err;\n\n\tswitch (dp->type) {\n\tcase DSA_PORT_TYPE_UNUSED:\n\t\tdsa_port_disable(dp);\n\t\tbreak;\n\tcase DSA_PORT_TYPE_CPU:\n\t\tif (dp->dn) {\n\t\t\terr = dsa_shared_port_link_register_of(dp);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tdsa_port_link_registered = true;\n\t\t} else {\n\t\t\tdev_warn(ds->dev,\n\t\t\t\t \"skipping link registration for CPU port %d\\n\",\n\t\t\t\t dp->index);\n\t\t}\n\n\t\terr = dsa_port_enable(dp, NULL);\n\t\tif (err)\n\t\t\tbreak;\n\t\tdsa_port_enabled = true;\n\n\t\tbreak;\n\tcase DSA_PORT_TYPE_DSA:\n\t\tif (dp->dn) {\n\t\t\terr = dsa_shared_port_link_register_of(dp);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tdsa_port_link_registered = true;\n\t\t} else {\n\t\t\tdev_warn(ds->dev,\n\t\t\t\t \"skipping link registration for DSA port %d\\n\",\n\t\t\t\t dp->index);\n\t\t}\n\n\t\terr = dsa_port_enable(dp, NULL);\n\t\tif (err)\n\t\t\tbreak;\n\t\tdsa_port_enabled = true;\n\n\t\tbreak;\n\tcase DSA_PORT_TYPE_USER:\n\t\tof_get_mac_address(dp->dn, dp->mac);\n\t\terr = dsa_slave_create(dp);\n\t\tbreak;\n\t}\n\n\tif (err && dsa_port_enabled)\n\t\tdsa_port_disable(dp);\n\tif (err && dsa_port_link_registered)\n\t\tdsa_shared_port_link_unregister_of(dp);\n\tif (err) {\n\t\tdsa_port_devlink_teardown(dp);\n\t\treturn err;\n\t}\n\n\tdp->setup = true;\n\n\treturn 0;\n}\n\nstatic void dsa_port_teardown(struct dsa_port *dp)\n{\n\tif (!dp->setup)\n\t\treturn;\n\n\tswitch (dp->type) {\n\tcase DSA_PORT_TYPE_UNUSED:\n\t\tbreak;\n\tcase DSA_PORT_TYPE_CPU:\n\t\tdsa_port_disable(dp);\n\t\tif (dp->dn)\n\t\t\tdsa_shared_port_link_unregister_of(dp);\n\t\tbreak;\n\tcase DSA_PORT_TYPE_DSA:\n\t\tdsa_port_disable(dp);\n\t\tif (dp->dn)\n\t\t\tdsa_shared_port_link_unregister_of(dp);\n\t\tbreak;\n\tcase DSA_PORT_TYPE_USER:\n\t\tif (dp->slave) {\n\t\t\tdsa_slave_destroy(dp->slave);\n\t\t\tdp->slave = NULL;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdsa_port_devlink_teardown(dp);\n\n\tdp->setup = false;\n}\n\nstatic int dsa_port_setup_as_unused(struct dsa_port *dp)\n{\n\tdp->type = DSA_PORT_TYPE_UNUSED;\n\treturn dsa_port_setup(dp);\n}\n\nstatic int dsa_switch_setup_tag_protocol(struct dsa_switch *ds)\n{\n\tconst struct dsa_device_ops *tag_ops = ds->dst->tag_ops;\n\tstruct dsa_switch_tree *dst = ds->dst;\n\tint err;\n\n\tif (tag_ops->proto == dst->default_proto)\n\t\tgoto connect;\n\n\trtnl_lock();\n\terr = ds->ops->change_tag_protocol(ds, tag_ops->proto);\n\trtnl_unlock();\n\tif (err) {\n\t\tdev_err(ds->dev, \"Unable to use tag protocol \\\"%s\\\": %pe\\n\",\n\t\t\ttag_ops->name, ERR_PTR(err));\n\t\treturn err;\n\t}\n\nconnect:\n\tif (tag_ops->connect) {\n\t\terr = tag_ops->connect(ds);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (ds->ops->connect_tag_protocol) {\n\t\terr = ds->ops->connect_tag_protocol(ds, tag_ops->proto);\n\t\tif (err) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"Unable to connect to tag protocol \\\"%s\\\": %pe\\n\",\n\t\t\t\ttag_ops->name, ERR_PTR(err));\n\t\t\tgoto disconnect;\n\t\t}\n\t}\n\n\treturn 0;\n\ndisconnect:\n\tif (tag_ops->disconnect)\n\t\ttag_ops->disconnect(ds);\n\n\treturn err;\n}\n\nstatic void dsa_switch_teardown_tag_protocol(struct dsa_switch *ds)\n{\n\tconst struct dsa_device_ops *tag_ops = ds->dst->tag_ops;\n\n\tif (tag_ops->disconnect)\n\t\ttag_ops->disconnect(ds);\n}\n\nstatic int dsa_switch_setup(struct dsa_switch *ds)\n{\n\tstruct device_node *dn;\n\tint err;\n\n\tif (ds->setup)\n\t\treturn 0;\n\n\t \n\tds->phys_mii_mask |= dsa_user_ports(ds);\n\n\terr = dsa_switch_devlink_alloc(ds);\n\tif (err)\n\t\treturn err;\n\n\terr = dsa_switch_register_notifier(ds);\n\tif (err)\n\t\tgoto devlink_free;\n\n\tds->configure_vlan_while_not_filtering = true;\n\n\terr = ds->ops->setup(ds);\n\tif (err < 0)\n\t\tgoto unregister_notifier;\n\n\terr = dsa_switch_setup_tag_protocol(ds);\n\tif (err)\n\t\tgoto teardown;\n\n\tif (!ds->slave_mii_bus && ds->ops->phy_read) {\n\t\tds->slave_mii_bus = mdiobus_alloc();\n\t\tif (!ds->slave_mii_bus) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto teardown;\n\t\t}\n\n\t\tdsa_slave_mii_bus_init(ds);\n\n\t\tdn = of_get_child_by_name(ds->dev->of_node, \"mdio\");\n\n\t\terr = of_mdiobus_register(ds->slave_mii_bus, dn);\n\t\tof_node_put(dn);\n\t\tif (err < 0)\n\t\t\tgoto free_slave_mii_bus;\n\t}\n\n\tdsa_switch_devlink_register(ds);\n\n\tds->setup = true;\n\treturn 0;\n\nfree_slave_mii_bus:\n\tif (ds->slave_mii_bus && ds->ops->phy_read)\n\t\tmdiobus_free(ds->slave_mii_bus);\nteardown:\n\tif (ds->ops->teardown)\n\t\tds->ops->teardown(ds);\nunregister_notifier:\n\tdsa_switch_unregister_notifier(ds);\ndevlink_free:\n\tdsa_switch_devlink_free(ds);\n\treturn err;\n}\n\nstatic void dsa_switch_teardown(struct dsa_switch *ds)\n{\n\tif (!ds->setup)\n\t\treturn;\n\n\tdsa_switch_devlink_unregister(ds);\n\n\tif (ds->slave_mii_bus && ds->ops->phy_read) {\n\t\tmdiobus_unregister(ds->slave_mii_bus);\n\t\tmdiobus_free(ds->slave_mii_bus);\n\t\tds->slave_mii_bus = NULL;\n\t}\n\n\tdsa_switch_teardown_tag_protocol(ds);\n\n\tif (ds->ops->teardown)\n\t\tds->ops->teardown(ds);\n\n\tdsa_switch_unregister_notifier(ds);\n\n\tdsa_switch_devlink_free(ds);\n\n\tds->setup = false;\n}\n\n \nstatic void dsa_tree_teardown_ports(struct dsa_switch_tree *dst)\n{\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list)\n\t\tif (dsa_port_is_user(dp) || dsa_port_is_unused(dp))\n\t\t\tdsa_port_teardown(dp);\n\n\tdsa_flush_workqueue();\n\n\tlist_for_each_entry(dp, &dst->ports, list)\n\t\tif (dsa_port_is_dsa(dp) || dsa_port_is_cpu(dp))\n\t\t\tdsa_port_teardown(dp);\n}\n\nstatic void dsa_tree_teardown_switches(struct dsa_switch_tree *dst)\n{\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list)\n\t\tdsa_switch_teardown(dp->ds);\n}\n\n \nstatic int dsa_tree_setup_ports(struct dsa_switch_tree *dst)\n{\n\tstruct dsa_port *dp;\n\tint err = 0;\n\n\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\tif (dsa_port_is_dsa(dp) || dsa_port_is_cpu(dp)) {\n\t\t\terr = dsa_port_setup(dp);\n\t\t\tif (err)\n\t\t\t\tgoto teardown;\n\t\t}\n\t}\n\n\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\tif (dsa_port_is_user(dp) || dsa_port_is_unused(dp)) {\n\t\t\terr = dsa_port_setup(dp);\n\t\t\tif (err) {\n\t\t\t\terr = dsa_port_setup_as_unused(dp);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto teardown;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nteardown:\n\tdsa_tree_teardown_ports(dst);\n\n\treturn err;\n}\n\nstatic int dsa_tree_setup_switches(struct dsa_switch_tree *dst)\n{\n\tstruct dsa_port *dp;\n\tint err = 0;\n\n\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\terr = dsa_switch_setup(dp->ds);\n\t\tif (err) {\n\t\t\tdsa_tree_teardown_switches(dst);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int dsa_tree_setup_master(struct dsa_switch_tree *dst)\n{\n\tstruct dsa_port *cpu_dp;\n\tint err = 0;\n\n\trtnl_lock();\n\n\tdsa_tree_for_each_cpu_port(cpu_dp, dst) {\n\t\tstruct net_device *master = cpu_dp->master;\n\t\tbool admin_up = (master->flags & IFF_UP) &&\n\t\t\t\t!qdisc_tx_is_noop(master);\n\n\t\terr = dsa_master_setup(master, cpu_dp);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t \n\t\tdsa_tree_master_admin_state_change(dst, master, admin_up);\n\t\tdsa_tree_master_oper_state_change(dst, master,\n\t\t\t\t\t\t  netif_oper_up(master));\n\t}\n\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstatic void dsa_tree_teardown_master(struct dsa_switch_tree *dst)\n{\n\tstruct dsa_port *cpu_dp;\n\n\trtnl_lock();\n\n\tdsa_tree_for_each_cpu_port(cpu_dp, dst) {\n\t\tstruct net_device *master = cpu_dp->master;\n\n\t\t \n\t\tdsa_tree_master_admin_state_change(dst, master, false);\n\n\t\tdsa_master_teardown(master);\n\t}\n\n\trtnl_unlock();\n}\n\nstatic int dsa_tree_setup_lags(struct dsa_switch_tree *dst)\n{\n\tunsigned int len = 0;\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\tif (dp->ds->num_lag_ids > len)\n\t\t\tlen = dp->ds->num_lag_ids;\n\t}\n\n\tif (!len)\n\t\treturn 0;\n\n\tdst->lags = kcalloc(len, sizeof(*dst->lags), GFP_KERNEL);\n\tif (!dst->lags)\n\t\treturn -ENOMEM;\n\n\tdst->lags_len = len;\n\treturn 0;\n}\n\nstatic void dsa_tree_teardown_lags(struct dsa_switch_tree *dst)\n{\n\tkfree(dst->lags);\n}\n\nstatic int dsa_tree_setup(struct dsa_switch_tree *dst)\n{\n\tbool complete;\n\tint err;\n\n\tif (dst->setup) {\n\t\tpr_err(\"DSA: tree %d already setup! Disjoint trees?\\n\",\n\t\t       dst->index);\n\t\treturn -EEXIST;\n\t}\n\n\tcomplete = dsa_tree_setup_routing_table(dst);\n\tif (!complete)\n\t\treturn 0;\n\n\terr = dsa_tree_setup_cpu_ports(dst);\n\tif (err)\n\t\treturn err;\n\n\terr = dsa_tree_setup_switches(dst);\n\tif (err)\n\t\tgoto teardown_cpu_ports;\n\n\terr = dsa_tree_setup_ports(dst);\n\tif (err)\n\t\tgoto teardown_switches;\n\n\terr = dsa_tree_setup_master(dst);\n\tif (err)\n\t\tgoto teardown_ports;\n\n\terr = dsa_tree_setup_lags(dst);\n\tif (err)\n\t\tgoto teardown_master;\n\n\tdst->setup = true;\n\n\tpr_info(\"DSA: tree %d setup\\n\", dst->index);\n\n\treturn 0;\n\nteardown_master:\n\tdsa_tree_teardown_master(dst);\nteardown_ports:\n\tdsa_tree_teardown_ports(dst);\nteardown_switches:\n\tdsa_tree_teardown_switches(dst);\nteardown_cpu_ports:\n\tdsa_tree_teardown_cpu_ports(dst);\n\n\treturn err;\n}\n\nstatic void dsa_tree_teardown(struct dsa_switch_tree *dst)\n{\n\tstruct dsa_link *dl, *next;\n\n\tif (!dst->setup)\n\t\treturn;\n\n\tdsa_tree_teardown_lags(dst);\n\n\tdsa_tree_teardown_master(dst);\n\n\tdsa_tree_teardown_ports(dst);\n\n\tdsa_tree_teardown_switches(dst);\n\n\tdsa_tree_teardown_cpu_ports(dst);\n\n\tlist_for_each_entry_safe(dl, next, &dst->rtable, list) {\n\t\tlist_del(&dl->list);\n\t\tkfree(dl);\n\t}\n\n\tpr_info(\"DSA: tree %d torn down\\n\", dst->index);\n\n\tdst->setup = false;\n}\n\nstatic int dsa_tree_bind_tag_proto(struct dsa_switch_tree *dst,\n\t\t\t\t   const struct dsa_device_ops *tag_ops)\n{\n\tconst struct dsa_device_ops *old_tag_ops = dst->tag_ops;\n\tstruct dsa_notifier_tag_proto_info info;\n\tint err;\n\n\tdst->tag_ops = tag_ops;\n\n\t \n\tinfo.tag_ops = tag_ops;\n\terr = dsa_tree_notify(dst, DSA_NOTIFIER_TAG_PROTO_CONNECT, &info);\n\tif (err && err != -EOPNOTSUPP)\n\t\tgoto out_disconnect;\n\n\t \n\tinfo.tag_ops = old_tag_ops;\n\tdsa_tree_notify(dst, DSA_NOTIFIER_TAG_PROTO_DISCONNECT, &info);\n\n\treturn 0;\n\nout_disconnect:\n\tinfo.tag_ops = tag_ops;\n\tdsa_tree_notify(dst, DSA_NOTIFIER_TAG_PROTO_DISCONNECT, &info);\n\tdst->tag_ops = old_tag_ops;\n\n\treturn err;\n}\n\n \nint dsa_tree_change_tag_proto(struct dsa_switch_tree *dst,\n\t\t\t      const struct dsa_device_ops *tag_ops,\n\t\t\t      const struct dsa_device_ops *old_tag_ops)\n{\n\tstruct dsa_notifier_tag_proto_info info;\n\tstruct dsa_port *dp;\n\tint err = -EBUSY;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\t \n\tdsa_tree_for_each_user_port(dp, dst) {\n\t\tif (dsa_port_to_master(dp)->flags & IFF_UP)\n\t\t\tgoto out_unlock;\n\n\t\tif (dp->slave->flags & IFF_UP)\n\t\t\tgoto out_unlock;\n\t}\n\n\t \n\tinfo.tag_ops = tag_ops;\n\terr = dsa_tree_notify(dst, DSA_NOTIFIER_TAG_PROTO, &info);\n\tif (err)\n\t\tgoto out_unwind_tagger;\n\n\terr = dsa_tree_bind_tag_proto(dst, tag_ops);\n\tif (err)\n\t\tgoto out_unwind_tagger;\n\n\trtnl_unlock();\n\n\treturn 0;\n\nout_unwind_tagger:\n\tinfo.tag_ops = old_tag_ops;\n\tdsa_tree_notify(dst, DSA_NOTIFIER_TAG_PROTO, &info);\nout_unlock:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic void dsa_tree_master_state_change(struct dsa_switch_tree *dst,\n\t\t\t\t\t struct net_device *master)\n{\n\tstruct dsa_notifier_master_state_info info;\n\tstruct dsa_port *cpu_dp = master->dsa_ptr;\n\n\tinfo.master = master;\n\tinfo.operational = dsa_port_master_is_operational(cpu_dp);\n\n\tdsa_tree_notify(dst, DSA_NOTIFIER_MASTER_STATE_CHANGE, &info);\n}\n\nvoid dsa_tree_master_admin_state_change(struct dsa_switch_tree *dst,\n\t\t\t\t\tstruct net_device *master,\n\t\t\t\t\tbool up)\n{\n\tstruct dsa_port *cpu_dp = master->dsa_ptr;\n\tbool notify = false;\n\n\t \n\tif (netif_is_lag_master(master))\n\t\treturn;\n\n\tif ((dsa_port_master_is_operational(cpu_dp)) !=\n\t    (up && cpu_dp->master_oper_up))\n\t\tnotify = true;\n\n\tcpu_dp->master_admin_up = up;\n\n\tif (notify)\n\t\tdsa_tree_master_state_change(dst, master);\n}\n\nvoid dsa_tree_master_oper_state_change(struct dsa_switch_tree *dst,\n\t\t\t\t       struct net_device *master,\n\t\t\t\t       bool up)\n{\n\tstruct dsa_port *cpu_dp = master->dsa_ptr;\n\tbool notify = false;\n\n\t \n\tif (netif_is_lag_master(master))\n\t\treturn;\n\n\tif ((dsa_port_master_is_operational(cpu_dp)) !=\n\t    (cpu_dp->master_admin_up && up))\n\t\tnotify = true;\n\n\tcpu_dp->master_oper_up = up;\n\n\tif (notify)\n\t\tdsa_tree_master_state_change(dst, master);\n}\n\nstatic struct dsa_port *dsa_port_touch(struct dsa_switch *ds, int index)\n{\n\tstruct dsa_switch_tree *dst = ds->dst;\n\tstruct dsa_port *dp;\n\n\tdsa_switch_for_each_port(dp, ds)\n\t\tif (dp->index == index)\n\t\t\treturn dp;\n\n\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\tif (!dp)\n\t\treturn NULL;\n\n\tdp->ds = ds;\n\tdp->index = index;\n\n\tmutex_init(&dp->addr_lists_lock);\n\tmutex_init(&dp->vlans_lock);\n\tINIT_LIST_HEAD(&dp->fdbs);\n\tINIT_LIST_HEAD(&dp->mdbs);\n\tINIT_LIST_HEAD(&dp->vlans);  \n\tINIT_LIST_HEAD(&dp->list);\n\tlist_add_tail(&dp->list, &dst->ports);\n\n\treturn dp;\n}\n\nstatic int dsa_port_parse_user(struct dsa_port *dp, const char *name)\n{\n\tdp->type = DSA_PORT_TYPE_USER;\n\tdp->name = name;\n\n\treturn 0;\n}\n\nstatic int dsa_port_parse_dsa(struct dsa_port *dp)\n{\n\tdp->type = DSA_PORT_TYPE_DSA;\n\n\treturn 0;\n}\n\nstatic enum dsa_tag_protocol dsa_get_tag_protocol(struct dsa_port *dp,\n\t\t\t\t\t\t  struct net_device *master)\n{\n\tenum dsa_tag_protocol tag_protocol = DSA_TAG_PROTO_NONE;\n\tstruct dsa_switch *mds, *ds = dp->ds;\n\tunsigned int mdp_upstream;\n\tstruct dsa_port *mdp;\n\n\t \n\tif (dsa_slave_dev_check(master)) {\n\t\tmdp = dsa_slave_to_port(master);\n\t\tmds = mdp->ds;\n\t\tmdp_upstream = dsa_upstream_port(mds, mdp->index);\n\t\ttag_protocol = mds->ops->get_tag_protocol(mds, mdp_upstream,\n\t\t\t\t\t\t\t  DSA_TAG_PROTO_NONE);\n\t}\n\n\t \n\treturn ds->ops->get_tag_protocol(ds, dp->index, tag_protocol);\n}\n\nstatic int dsa_port_parse_cpu(struct dsa_port *dp, struct net_device *master,\n\t\t\t      const char *user_protocol)\n{\n\tconst struct dsa_device_ops *tag_ops = NULL;\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_switch_tree *dst = ds->dst;\n\tenum dsa_tag_protocol default_proto;\n\n\t \n\tdefault_proto = dsa_get_tag_protocol(dp, master);\n\tif (dst->default_proto) {\n\t\tif (dst->default_proto != default_proto) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"A DSA switch tree can have only one tagging protocol\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tdst->default_proto = default_proto;\n\t}\n\n\t \n\tif (user_protocol) {\n\t\tif (!ds->ops->change_tag_protocol) {\n\t\t\tdev_err(ds->dev, \"Tag protocol cannot be modified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttag_ops = dsa_tag_driver_get_by_name(user_protocol);\n\t\tif (IS_ERR(tag_ops)) {\n\t\t\tdev_warn(ds->dev,\n\t\t\t\t \"Failed to find a tagging driver for protocol %s, using default\\n\",\n\t\t\t\t user_protocol);\n\t\t\ttag_ops = NULL;\n\t\t}\n\t}\n\n\tif (!tag_ops)\n\t\ttag_ops = dsa_tag_driver_get_by_id(default_proto);\n\n\tif (IS_ERR(tag_ops)) {\n\t\tif (PTR_ERR(tag_ops) == -ENOPROTOOPT)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tdev_warn(ds->dev, \"No tagger for this switch\\n\");\n\t\treturn PTR_ERR(tag_ops);\n\t}\n\n\tif (dst->tag_ops) {\n\t\tif (dst->tag_ops != tag_ops) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"A DSA switch tree can have only one tagging protocol\\n\");\n\n\t\t\tdsa_tag_driver_put(tag_ops);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tdsa_tag_driver_put(tag_ops);\n\t} else {\n\t\tdst->tag_ops = tag_ops;\n\t}\n\n\tdp->master = master;\n\tdp->type = DSA_PORT_TYPE_CPU;\n\tdsa_port_set_tag_protocol(dp, dst->tag_ops);\n\tdp->dst = dst;\n\n\t \n\treturn 0;\n}\n\nstatic int dsa_port_parse_of(struct dsa_port *dp, struct device_node *dn)\n{\n\tstruct device_node *ethernet = of_parse_phandle(dn, \"ethernet\", 0);\n\tconst char *name = of_get_property(dn, \"label\", NULL);\n\tbool link = of_property_read_bool(dn, \"link\");\n\n\tdp->dn = dn;\n\n\tif (ethernet) {\n\t\tstruct net_device *master;\n\t\tconst char *user_protocol;\n\n\t\tmaster = of_find_net_device_by_node(ethernet);\n\t\tof_node_put(ethernet);\n\t\tif (!master)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tuser_protocol = of_get_property(dn, \"dsa-tag-protocol\", NULL);\n\t\treturn dsa_port_parse_cpu(dp, master, user_protocol);\n\t}\n\n\tif (link)\n\t\treturn dsa_port_parse_dsa(dp);\n\n\treturn dsa_port_parse_user(dp, name);\n}\n\nstatic int dsa_switch_parse_ports_of(struct dsa_switch *ds,\n\t\t\t\t     struct device_node *dn)\n{\n\tstruct device_node *ports, *port;\n\tstruct dsa_port *dp;\n\tint err = 0;\n\tu32 reg;\n\n\tports = of_get_child_by_name(dn, \"ports\");\n\tif (!ports) {\n\t\t \n\t\tports = of_get_child_by_name(dn, \"ethernet-ports\");\n\t\tif (!ports) {\n\t\t\tdev_err(ds->dev, \"no ports child node found\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor_each_available_child_of_node(ports, port) {\n\t\terr = of_property_read_u32(port, \"reg\", &reg);\n\t\tif (err) {\n\t\t\tof_node_put(port);\n\t\t\tgoto out_put_node;\n\t\t}\n\n\t\tif (reg >= ds->num_ports) {\n\t\t\tdev_err(ds->dev, \"port %pOF index %u exceeds num_ports (%u)\\n\",\n\t\t\t\tport, reg, ds->num_ports);\n\t\t\tof_node_put(port);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_node;\n\t\t}\n\n\t\tdp = dsa_to_port(ds, reg);\n\n\t\terr = dsa_port_parse_of(dp, port);\n\t\tif (err) {\n\t\t\tof_node_put(port);\n\t\t\tgoto out_put_node;\n\t\t}\n\t}\n\nout_put_node:\n\tof_node_put(ports);\n\treturn err;\n}\n\nstatic int dsa_switch_parse_member_of(struct dsa_switch *ds,\n\t\t\t\t      struct device_node *dn)\n{\n\tu32 m[2] = { 0, 0 };\n\tint sz;\n\n\t \n\tsz = of_property_read_variable_u32_array(dn, \"dsa,member\", m, 2, 2);\n\tif (sz < 0 && sz != -EINVAL)\n\t\treturn sz;\n\n\tds->index = m[1];\n\n\tds->dst = dsa_tree_touch(m[0]);\n\tif (!ds->dst)\n\t\treturn -ENOMEM;\n\n\tif (dsa_switch_find(ds->dst->index, ds->index)) {\n\t\tdev_err(ds->dev,\n\t\t\t\"A DSA switch with index %d already exists in tree %d\\n\",\n\t\t\tds->index, ds->dst->index);\n\t\treturn -EEXIST;\n\t}\n\n\tif (ds->dst->last_switch < ds->index)\n\t\tds->dst->last_switch = ds->index;\n\n\treturn 0;\n}\n\nstatic int dsa_switch_touch_ports(struct dsa_switch *ds)\n{\n\tstruct dsa_port *dp;\n\tint port;\n\n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tdp = dsa_port_touch(ds, port);\n\t\tif (!dp)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int dsa_switch_parse_of(struct dsa_switch *ds, struct device_node *dn)\n{\n\tint err;\n\n\terr = dsa_switch_parse_member_of(ds, dn);\n\tif (err)\n\t\treturn err;\n\n\terr = dsa_switch_touch_ports(ds);\n\tif (err)\n\t\treturn err;\n\n\treturn dsa_switch_parse_ports_of(ds, dn);\n}\n\nstatic int dev_is_class(struct device *dev, void *class)\n{\n\tif (dev->class != NULL && !strcmp(dev->class->name, class))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct device *dev_find_class(struct device *parent, char *class)\n{\n\tif (dev_is_class(parent, class)) {\n\t\tget_device(parent);\n\t\treturn parent;\n\t}\n\n\treturn device_find_child(parent, class, dev_is_class);\n}\n\nstatic struct net_device *dsa_dev_to_net_device(struct device *dev)\n{\n\tstruct device *d;\n\n\td = dev_find_class(dev, \"net\");\n\tif (d != NULL) {\n\t\tstruct net_device *nd;\n\n\t\tnd = to_net_dev(d);\n\t\tdev_hold(nd);\n\t\tput_device(d);\n\n\t\treturn nd;\n\t}\n\n\treturn NULL;\n}\n\nstatic int dsa_port_parse(struct dsa_port *dp, const char *name,\n\t\t\t  struct device *dev)\n{\n\tif (!strcmp(name, \"cpu\")) {\n\t\tstruct net_device *master;\n\n\t\tmaster = dsa_dev_to_net_device(dev);\n\t\tif (!master)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tdev_put(master);\n\n\t\treturn dsa_port_parse_cpu(dp, master, NULL);\n\t}\n\n\tif (!strcmp(name, \"dsa\"))\n\t\treturn dsa_port_parse_dsa(dp);\n\n\treturn dsa_port_parse_user(dp, name);\n}\n\nstatic int dsa_switch_parse_ports(struct dsa_switch *ds,\n\t\t\t\t  struct dsa_chip_data *cd)\n{\n\tbool valid_name_found = false;\n\tstruct dsa_port *dp;\n\tstruct device *dev;\n\tconst char *name;\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < DSA_MAX_PORTS; i++) {\n\t\tname = cd->port_names[i];\n\t\tdev = cd->netdev[i];\n\t\tdp = dsa_to_port(ds, i);\n\n\t\tif (!name)\n\t\t\tcontinue;\n\n\t\terr = dsa_port_parse(dp, name, dev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tvalid_name_found = true;\n\t}\n\n\tif (!valid_name_found && i == DSA_MAX_PORTS)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int dsa_switch_parse(struct dsa_switch *ds, struct dsa_chip_data *cd)\n{\n\tint err;\n\n\tds->cd = cd;\n\n\t \n\tds->index = 0;\n\tds->dst = dsa_tree_touch(0);\n\tif (!ds->dst)\n\t\treturn -ENOMEM;\n\n\terr = dsa_switch_touch_ports(ds);\n\tif (err)\n\t\treturn err;\n\n\treturn dsa_switch_parse_ports(ds, cd);\n}\n\nstatic void dsa_switch_release_ports(struct dsa_switch *ds)\n{\n\tstruct dsa_port *dp, *next;\n\n\tdsa_switch_for_each_port_safe(dp, next, ds) {\n\t\tWARN_ON(!list_empty(&dp->fdbs));\n\t\tWARN_ON(!list_empty(&dp->mdbs));\n\t\tWARN_ON(!list_empty(&dp->vlans));\n\t\tlist_del(&dp->list);\n\t\tkfree(dp);\n\t}\n}\n\nstatic int dsa_switch_probe(struct dsa_switch *ds)\n{\n\tstruct dsa_switch_tree *dst;\n\tstruct dsa_chip_data *pdata;\n\tstruct device_node *np;\n\tint err;\n\n\tif (!ds->dev)\n\t\treturn -ENODEV;\n\n\tpdata = ds->dev->platform_data;\n\tnp = ds->dev->of_node;\n\n\tif (!ds->num_ports)\n\t\treturn -EINVAL;\n\n\tif (np) {\n\t\terr = dsa_switch_parse_of(ds, np);\n\t\tif (err)\n\t\t\tdsa_switch_release_ports(ds);\n\t} else if (pdata) {\n\t\terr = dsa_switch_parse(ds, pdata);\n\t\tif (err)\n\t\t\tdsa_switch_release_ports(ds);\n\t} else {\n\t\terr = -ENODEV;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tdst = ds->dst;\n\tdsa_tree_get(dst);\n\terr = dsa_tree_setup(dst);\n\tif (err) {\n\t\tdsa_switch_release_ports(ds);\n\t\tdsa_tree_put(dst);\n\t}\n\n\treturn err;\n}\n\nint dsa_register_switch(struct dsa_switch *ds)\n{\n\tint err;\n\n\tmutex_lock(&dsa2_mutex);\n\terr = dsa_switch_probe(ds);\n\tdsa_tree_put(ds->dst);\n\tmutex_unlock(&dsa2_mutex);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(dsa_register_switch);\n\nstatic void dsa_switch_remove(struct dsa_switch *ds)\n{\n\tstruct dsa_switch_tree *dst = ds->dst;\n\n\tdsa_tree_teardown(dst);\n\tdsa_switch_release_ports(ds);\n\tdsa_tree_put(dst);\n}\n\nvoid dsa_unregister_switch(struct dsa_switch *ds)\n{\n\tmutex_lock(&dsa2_mutex);\n\tdsa_switch_remove(ds);\n\tmutex_unlock(&dsa2_mutex);\n}\nEXPORT_SYMBOL_GPL(dsa_unregister_switch);\n\n \nvoid dsa_switch_shutdown(struct dsa_switch *ds)\n{\n\tstruct net_device *master, *slave_dev;\n\tstruct dsa_port *dp;\n\n\tmutex_lock(&dsa2_mutex);\n\n\tif (!ds->setup)\n\t\tgoto out;\n\n\trtnl_lock();\n\n\tdsa_switch_for_each_user_port(dp, ds) {\n\t\tmaster = dsa_port_to_master(dp);\n\t\tslave_dev = dp->slave;\n\n\t\tnetdev_upper_dev_unlink(master, slave_dev);\n\t}\n\n\t \n\tdsa_switch_for_each_cpu_port(dp, ds)\n\t\tdp->master->dsa_ptr = NULL;\n\n\trtnl_unlock();\nout:\n\tmutex_unlock(&dsa2_mutex);\n}\nEXPORT_SYMBOL_GPL(dsa_switch_shutdown);\n\n#ifdef CONFIG_PM_SLEEP\nstatic bool dsa_port_is_initialized(const struct dsa_port *dp)\n{\n\treturn dp->type == DSA_PORT_TYPE_USER && dp->slave;\n}\n\nint dsa_switch_suspend(struct dsa_switch *ds)\n{\n\tstruct dsa_port *dp;\n\tint ret = 0;\n\n\t \n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (!dsa_port_is_initialized(dp))\n\t\t\tcontinue;\n\n\t\tret = dsa_slave_suspend(dp->slave);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (ds->ops->suspend)\n\t\tret = ds->ops->suspend(ds);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dsa_switch_suspend);\n\nint dsa_switch_resume(struct dsa_switch *ds)\n{\n\tstruct dsa_port *dp;\n\tint ret = 0;\n\n\tif (ds->ops->resume)\n\t\tret = ds->ops->resume(ds);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (!dsa_port_is_initialized(dp))\n\t\t\tcontinue;\n\n\t\tret = dsa_slave_resume(dp->slave);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dsa_switch_resume);\n#endif\n\nstruct dsa_port *dsa_port_from_netdev(struct net_device *netdev)\n{\n\tif (!netdev || !dsa_slave_dev_check(netdev))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn dsa_slave_to_port(netdev);\n}\nEXPORT_SYMBOL_GPL(dsa_port_from_netdev);\n\nbool dsa_db_equal(const struct dsa_db *a, const struct dsa_db *b)\n{\n\tif (a->type != b->type)\n\t\treturn false;\n\n\tswitch (a->type) {\n\tcase DSA_DB_PORT:\n\t\treturn a->dp == b->dp;\n\tcase DSA_DB_LAG:\n\t\treturn a->lag.dev == b->lag.dev;\n\tcase DSA_DB_BRIDGE:\n\t\treturn a->bridge.num == b->bridge.num;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n}\n\nbool dsa_fdb_present_in_other_db(struct dsa_switch *ds, int port,\n\t\t\t\t const unsigned char *addr, u16 vid,\n\t\t\t\t struct dsa_db db)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct dsa_mac_addr *a;\n\n\tlockdep_assert_held(&dp->addr_lists_lock);\n\n\tlist_for_each_entry(a, &dp->fdbs, list) {\n\t\tif (!ether_addr_equal(a->addr, addr) || a->vid != vid)\n\t\t\tcontinue;\n\n\t\tif (a->db.type == db.type && !dsa_db_equal(&a->db, &db))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(dsa_fdb_present_in_other_db);\n\nbool dsa_mdb_present_in_other_db(struct dsa_switch *ds, int port,\n\t\t\t\t const struct switchdev_obj_port_mdb *mdb,\n\t\t\t\t struct dsa_db db)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct dsa_mac_addr *a;\n\n\tlockdep_assert_held(&dp->addr_lists_lock);\n\n\tlist_for_each_entry(a, &dp->mdbs, list) {\n\t\tif (!ether_addr_equal(a->addr, mdb->addr) || a->vid != mdb->vid)\n\t\t\tcontinue;\n\n\t\tif (a->db.type == db.type && !dsa_db_equal(&a->db, &db))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(dsa_mdb_present_in_other_db);\n\nstatic const struct dsa_stubs __dsa_stubs = {\n\t.master_hwtstamp_validate = __dsa_master_hwtstamp_validate,\n};\n\nstatic void dsa_register_stubs(void)\n{\n\tdsa_stubs = &__dsa_stubs;\n}\n\nstatic void dsa_unregister_stubs(void)\n{\n\tdsa_stubs = NULL;\n}\n\nstatic int __init dsa_init_module(void)\n{\n\tint rc;\n\n\tdsa_owq = alloc_ordered_workqueue(\"dsa_ordered\",\n\t\t\t\t\t  WQ_MEM_RECLAIM);\n\tif (!dsa_owq)\n\t\treturn -ENOMEM;\n\n\trc = dsa_slave_register_notifier();\n\tif (rc)\n\t\tgoto register_notifier_fail;\n\n\tdev_add_pack(&dsa_pack_type);\n\n\trc = rtnl_link_register(&dsa_link_ops);\n\tif (rc)\n\t\tgoto netlink_register_fail;\n\n\tdsa_register_stubs();\n\n\treturn 0;\n\nnetlink_register_fail:\n\tdsa_slave_unregister_notifier();\n\tdev_remove_pack(&dsa_pack_type);\nregister_notifier_fail:\n\tdestroy_workqueue(dsa_owq);\n\n\treturn rc;\n}\nmodule_init(dsa_init_module);\n\nstatic void __exit dsa_cleanup_module(void)\n{\n\tdsa_unregister_stubs();\n\n\trtnl_link_unregister(&dsa_link_ops);\n\n\tdsa_slave_unregister_notifier();\n\tdev_remove_pack(&dsa_pack_type);\n\tdestroy_workqueue(dsa_owq);\n}\nmodule_exit(dsa_cleanup_module);\n\nMODULE_AUTHOR(\"Lennert Buytenhek <buytenh@wantstofly.org>\");\nMODULE_DESCRIPTION(\"Driver for Distributed Switch Architecture switch chips\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:dsa\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}