{
  "module_name": "tag_ocelot_8021q.c",
  "hash_id": "48c2c071ad797bea73921d0b99dbbef41676705264a82bce1da60081030e209a",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag_ocelot_8021q.c",
  "human_readable_source": "\n \n#include <linux/dsa/8021q.h>\n#include <linux/dsa/ocelot.h>\n\n#include \"tag.h\"\n#include \"tag_8021q.h\"\n\n#define OCELOT_8021Q_NAME \"ocelot-8021q\"\n\nstruct ocelot_8021q_tagger_private {\n\tstruct ocelot_8021q_tagger_data data;  \n\tstruct kthread_worker *xmit_worker;\n};\n\nstatic struct sk_buff *ocelot_defer_xmit(struct dsa_port *dp,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ocelot_8021q_tagger_private *priv = dp->ds->tagger_data;\n\tstruct ocelot_8021q_tagger_data *data = &priv->data;\n\tvoid (*xmit_work_fn)(struct kthread_work *work);\n\tstruct felix_deferred_xmit_work *xmit_work;\n\tstruct kthread_worker *xmit_worker;\n\n\txmit_work_fn = data->xmit_work_fn;\n\txmit_worker = priv->xmit_worker;\n\n\tif (!xmit_work_fn || !xmit_worker)\n\t\treturn NULL;\n\n\t \n\tif (skb->ip_summed == CHECKSUM_PARTIAL && skb_checksum_help(skb))\n\t\treturn NULL;\n\n\txmit_work = kzalloc(sizeof(*xmit_work), GFP_ATOMIC);\n\tif (!xmit_work)\n\t\treturn NULL;\n\n\t \n\tkthread_init_work(&xmit_work->work, xmit_work_fn);\n\t \n\txmit_work->dp = dp;\n\txmit_work->skb = skb_get(skb);\n\n\tkthread_queue_work(xmit_worker, &xmit_work->work);\n\n\treturn NULL;\n}\n\nstatic struct sk_buff *ocelot_xmit(struct sk_buff *skb,\n\t\t\t\t   struct net_device *netdev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(netdev);\n\tu16 queue_mapping = skb_get_queue_mapping(skb);\n\tu8 pcp = netdev_txq_to_tc(netdev, queue_mapping);\n\tu16 tx_vid = dsa_tag_8021q_standalone_vid(dp);\n\tstruct ethhdr *hdr = eth_hdr(skb);\n\n\tif (ocelot_ptp_rew_op(skb) || is_link_local_ether_addr(hdr->h_dest))\n\t\treturn ocelot_defer_xmit(dp, skb);\n\n\treturn dsa_8021q_xmit(skb, netdev, ETH_P_8021Q,\n\t\t\t      ((pcp << VLAN_PRIO_SHIFT) | tx_vid));\n}\n\nstatic struct sk_buff *ocelot_rcv(struct sk_buff *skb,\n\t\t\t\t  struct net_device *netdev)\n{\n\tint src_port, switch_id;\n\n\tdsa_8021q_rcv(skb, &src_port, &switch_id, NULL);\n\n\tskb->dev = dsa_master_find_slave(netdev, switch_id, src_port);\n\tif (!skb->dev)\n\t\treturn NULL;\n\n\tdsa_default_offload_fwd_mark(skb);\n\n\treturn skb;\n}\n\nstatic void ocelot_disconnect(struct dsa_switch *ds)\n{\n\tstruct ocelot_8021q_tagger_private *priv = ds->tagger_data;\n\n\tkthread_destroy_worker(priv->xmit_worker);\n\tkfree(priv);\n\tds->tagger_data = NULL;\n}\n\nstatic int ocelot_connect(struct dsa_switch *ds)\n{\n\tstruct ocelot_8021q_tagger_private *priv;\n\tint err;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->xmit_worker = kthread_create_worker(0, \"felix_xmit\");\n\tif (IS_ERR(priv->xmit_worker)) {\n\t\terr = PTR_ERR(priv->xmit_worker);\n\t\tkfree(priv);\n\t\treturn err;\n\t}\n\n\tds->tagger_data = priv;\n\n\treturn 0;\n}\n\nstatic const struct dsa_device_ops ocelot_8021q_netdev_ops = {\n\t.name\t\t\t= OCELOT_8021Q_NAME,\n\t.proto\t\t\t= DSA_TAG_PROTO_OCELOT_8021Q,\n\t.xmit\t\t\t= ocelot_xmit,\n\t.rcv\t\t\t= ocelot_rcv,\n\t.connect\t\t= ocelot_connect,\n\t.disconnect\t\t= ocelot_disconnect,\n\t.needed_headroom\t= VLAN_HLEN,\n\t.promisc_on_master\t= true,\n};\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_OCELOT_8021Q, OCELOT_8021Q_NAME);\n\nmodule_dsa_tag_driver(ocelot_8021q_netdev_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}