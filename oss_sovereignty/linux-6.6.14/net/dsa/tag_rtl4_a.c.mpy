{
  "module_name": "tag_rtl4_a.c",
  "hash_id": "074faf3b085c6673cf981844e4e317c1f92254422d60c7ddf628c846242e81f4",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag_rtl4_a.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/bits.h>\n\n#include \"tag.h\"\n\n#define RTL4_A_NAME\t\t\"rtl4a\"\n\n#define RTL4_A_HDR_LEN\t\t4\n#define RTL4_A_ETHERTYPE\t0x8899\n#define RTL4_A_PROTOCOL_SHIFT\t12\n \n#define RTL4_A_PROTOCOL_RTL8366RB\t0xa\n\nstatic struct sk_buff *rtl4a_tag_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\t__be16 *p;\n\tu8 *tag;\n\tu16 out;\n\n\t \n\tif (unlikely(__skb_put_padto(skb, ETH_ZLEN, false)))\n\t\treturn NULL;\n\n\tnetdev_dbg(dev, \"add realtek tag to package to port %d\\n\",\n\t\t   dp->index);\n\tskb_push(skb, RTL4_A_HDR_LEN);\n\n\tdsa_alloc_etype_header(skb, RTL4_A_HDR_LEN);\n\ttag = dsa_etype_header_pos_tx(skb);\n\n\t \n\tp = (__be16 *)tag;\n\t*p = htons(RTL4_A_ETHERTYPE);\n\n\tout = (RTL4_A_PROTOCOL_RTL8366RB << RTL4_A_PROTOCOL_SHIFT);\n\t \n\tout |= BIT(dp->index);\n\n\tp = (__be16 *)(tag + 2);\n\t*p = htons(out);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *rtl4a_tag_rcv(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tu16 protport;\n\t__be16 *p;\n\tu16 etype;\n\tu8 *tag;\n\tu8 prot;\n\tu8 port;\n\n\tif (unlikely(!pskb_may_pull(skb, RTL4_A_HDR_LEN)))\n\t\treturn NULL;\n\n\ttag = dsa_etype_header_pos_rx(skb);\n\tp = (__be16 *)tag;\n\tetype = ntohs(*p);\n\tif (etype != RTL4_A_ETHERTYPE) {\n\t\t \n\t\tnetdev_dbg(dev, \"non-realtek ethertype 0x%04x\\n\", etype);\n\t\treturn skb;\n\t}\n\tp = (__be16 *)(tag + 2);\n\tprotport = ntohs(*p);\n\t \n\tprot = (protport >> RTL4_A_PROTOCOL_SHIFT) & 0x0f;\n\tif (prot != RTL4_A_PROTOCOL_RTL8366RB) {\n\t\tnetdev_err(dev, \"unknown realtek protocol 0x%01x\\n\", prot);\n\t\treturn NULL;\n\t}\n\tport = protport & 0xff;\n\n\tskb->dev = dsa_master_find_slave(dev, 0, port);\n\tif (!skb->dev) {\n\t\tnetdev_dbg(dev, \"could not find slave for port %d\\n\", port);\n\t\treturn NULL;\n\t}\n\n\t \n\tskb_pull_rcsum(skb, RTL4_A_HDR_LEN);\n\n\tdsa_strip_etype_header(skb, RTL4_A_HDR_LEN);\n\n\tdsa_default_offload_fwd_mark(skb);\n\n\treturn skb;\n}\n\nstatic const struct dsa_device_ops rtl4a_netdev_ops = {\n\t.name\t= RTL4_A_NAME,\n\t.proto\t= DSA_TAG_PROTO_RTL4_A,\n\t.xmit\t= rtl4a_tag_xmit,\n\t.rcv\t= rtl4a_tag_rcv,\n\t.needed_headroom = RTL4_A_HDR_LEN,\n};\nmodule_dsa_tag_driver(rtl4a_netdev_ops);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_RTL4_A, RTL4_A_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}