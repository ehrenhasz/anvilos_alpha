{
  "module_name": "tag_ocelot.c",
  "hash_id": "1b274b92cf5f8bf4f631dde38027b322b0073601480ae475208616b6f3e2e1b3",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag_ocelot.c",
  "human_readable_source": "\n \n#include <linux/dsa/ocelot.h>\n\n#include \"tag.h\"\n\n#define OCELOT_NAME\t\"ocelot\"\n#define SEVILLE_NAME\t\"seville\"\n\n \nstatic void ocelot_xmit_get_vlan_info(struct sk_buff *skb, struct dsa_port *dp,\n\t\t\t\t      u64 *vlan_tci, u64 *tag_type)\n{\n\tstruct net_device *br = dsa_port_bridge_dev_get(dp);\n\tstruct vlan_ethhdr *hdr;\n\tu16 proto, tci;\n\n\tif (!br || !br_vlan_enabled(br)) {\n\t\t*vlan_tci = 0;\n\t\t*tag_type = IFH_TAG_TYPE_C;\n\t\treturn;\n\t}\n\n\thdr = skb_vlan_eth_hdr(skb);\n\tbr_vlan_get_proto(br, &proto);\n\n\tif (ntohs(hdr->h_vlan_proto) == proto) {\n\t\tvlan_remove_tag(skb, &tci);\n\t\t*vlan_tci = tci;\n\t} else {\n\t\trcu_read_lock();\n\t\tbr_vlan_get_pvid_rcu(br, &tci);\n\t\trcu_read_unlock();\n\t\t*vlan_tci = tci;\n\t}\n\n\t*tag_type = (proto != ETH_P_8021Q) ? IFH_TAG_TYPE_S : IFH_TAG_TYPE_C;\n}\n\nstatic void ocelot_xmit_common(struct sk_buff *skb, struct net_device *netdev,\n\t\t\t       __be32 ifh_prefix, void **ifh)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(netdev);\n\tstruct dsa_switch *ds = dp->ds;\n\tu64 vlan_tci, tag_type;\n\tvoid *injection;\n\t__be32 *prefix;\n\tu32 rew_op = 0;\n\tu64 qos_class;\n\n\tocelot_xmit_get_vlan_info(skb, dp, &vlan_tci, &tag_type);\n\n\tqos_class = netdev_get_num_tc(netdev) ?\n\t\t    netdev_get_prio_tc_map(netdev, skb->priority) : skb->priority;\n\n\tinjection = skb_push(skb, OCELOT_TAG_LEN);\n\tprefix = skb_push(skb, OCELOT_SHORT_PREFIX_LEN);\n\n\t*prefix = ifh_prefix;\n\tmemset(injection, 0, OCELOT_TAG_LEN);\n\tocelot_ifh_set_bypass(injection, 1);\n\tocelot_ifh_set_src(injection, ds->num_ports);\n\tocelot_ifh_set_qos_class(injection, qos_class);\n\tocelot_ifh_set_vlan_tci(injection, vlan_tci);\n\tocelot_ifh_set_tag_type(injection, tag_type);\n\n\trew_op = ocelot_ptp_rew_op(skb);\n\tif (rew_op)\n\t\tocelot_ifh_set_rew_op(injection, rew_op);\n\n\t*ifh = injection;\n}\n\nstatic struct sk_buff *ocelot_xmit(struct sk_buff *skb,\n\t\t\t\t   struct net_device *netdev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(netdev);\n\tvoid *injection;\n\n\tocelot_xmit_common(skb, netdev, cpu_to_be32(0x8880000a), &injection);\n\tocelot_ifh_set_dest(injection, BIT_ULL(dp->index));\n\n\treturn skb;\n}\n\nstatic struct sk_buff *seville_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *netdev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(netdev);\n\tvoid *injection;\n\n\tocelot_xmit_common(skb, netdev, cpu_to_be32(0x88800005), &injection);\n\tseville_ifh_set_dest(injection, BIT_ULL(dp->index));\n\n\treturn skb;\n}\n\nstatic struct sk_buff *ocelot_rcv(struct sk_buff *skb,\n\t\t\t\t  struct net_device *netdev)\n{\n\tu64 src_port, qos_class;\n\tu64 vlan_tci, tag_type;\n\tu8 *start = skb->data;\n\tstruct dsa_port *dp;\n\tu8 *extraction;\n\tu16 vlan_tpid;\n\tu64 rew_val;\n\n\t \n\tskb_push(skb, ETH_HLEN);\n\t \n\tskb_pull(skb, OCELOT_SHORT_PREFIX_LEN);\n\t \n\textraction = skb->data;\n\t \n\tskb_pull(skb, OCELOT_TAG_LEN);\n\t \n\tskb_reset_mac_header(skb);\n\tskb_reset_mac_len(skb);\n\t \n\tskb_pull(skb, ETH_HLEN);\n\n\t \n\tskb_postpull_rcsum(skb, start, OCELOT_TOTAL_TAG_LEN);\n\n\tocelot_xfh_get_src_port(extraction, &src_port);\n\tocelot_xfh_get_qos_class(extraction, &qos_class);\n\tocelot_xfh_get_tag_type(extraction, &tag_type);\n\tocelot_xfh_get_vlan_tci(extraction, &vlan_tci);\n\tocelot_xfh_get_rew_val(extraction, &rew_val);\n\n\tskb->dev = dsa_master_find_slave(netdev, 0, src_port);\n\tif (!skb->dev)\n\t\t \n\t\treturn NULL;\n\n\tdsa_default_offload_fwd_mark(skb);\n\tskb->priority = qos_class;\n\tOCELOT_SKB_CB(skb)->tstamp_lo = rew_val;\n\n\t \n\tdp = dsa_slave_to_port(skb->dev);\n\tvlan_tpid = tag_type ? ETH_P_8021AD : ETH_P_8021Q;\n\n\tif (dsa_port_is_vlan_filtering(dp) &&\n\t    eth_hdr(skb)->h_proto == htons(vlan_tpid)) {\n\t\tu16 dummy_vlan_tci;\n\n\t\tskb_push_rcsum(skb, ETH_HLEN);\n\t\t__skb_vlan_pop(skb, &dummy_vlan_tci);\n\t\tskb_pull_rcsum(skb, ETH_HLEN);\n\t\t__vlan_hwaccel_put_tag(skb, htons(vlan_tpid), vlan_tci);\n\t}\n\n\treturn skb;\n}\n\nstatic const struct dsa_device_ops ocelot_netdev_ops = {\n\t.name\t\t\t= OCELOT_NAME,\n\t.proto\t\t\t= DSA_TAG_PROTO_OCELOT,\n\t.xmit\t\t\t= ocelot_xmit,\n\t.rcv\t\t\t= ocelot_rcv,\n\t.needed_headroom\t= OCELOT_TOTAL_TAG_LEN,\n\t.promisc_on_master\t= true,\n};\n\nDSA_TAG_DRIVER(ocelot_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_OCELOT, OCELOT_NAME);\n\nstatic const struct dsa_device_ops seville_netdev_ops = {\n\t.name\t\t\t= SEVILLE_NAME,\n\t.proto\t\t\t= DSA_TAG_PROTO_SEVILLE,\n\t.xmit\t\t\t= seville_xmit,\n\t.rcv\t\t\t= ocelot_rcv,\n\t.needed_headroom\t= OCELOT_TOTAL_TAG_LEN,\n\t.promisc_on_master\t= true,\n};\n\nDSA_TAG_DRIVER(seville_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_SEVILLE, SEVILLE_NAME);\n\nstatic struct dsa_tag_driver *ocelot_tag_driver_array[] = {\n\t&DSA_TAG_DRIVER_NAME(ocelot_netdev_ops),\n\t&DSA_TAG_DRIVER_NAME(seville_netdev_ops),\n};\n\nmodule_dsa_tag_drivers(ocelot_tag_driver_array);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}