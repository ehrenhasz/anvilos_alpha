{
  "module_name": "tag.c",
  "hash_id": "202087f5ab5858878d77a9c15f667d3dd5c954a8f1bc170a5c2a7524b1acbe89",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/ptp_classify.h>\n#include <linux/skbuff.h>\n#include <net/dsa.h>\n#include <net/dst_metadata.h>\n\n#include \"slave.h\"\n#include \"tag.h\"\n\nstatic LIST_HEAD(dsa_tag_drivers_list);\nstatic DEFINE_MUTEX(dsa_tag_drivers_lock);\n\n \nstatic bool dsa_skb_defer_rx_timestamp(struct dsa_slave_priv *p,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct dsa_switch *ds = p->dp->ds;\n\tunsigned int type;\n\n\tif (!ds->ops->port_rxtstamp)\n\t\treturn false;\n\n\tif (skb_headroom(skb) < ETH_HLEN)\n\t\treturn false;\n\n\t__skb_push(skb, ETH_HLEN);\n\n\ttype = ptp_classify_raw(skb);\n\n\t__skb_pull(skb, ETH_HLEN);\n\n\tif (type == PTP_CLASS_NONE)\n\t\treturn false;\n\n\treturn ds->ops->port_rxtstamp(ds, p->dp->index, skb, type);\n}\n\nstatic int dsa_switch_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t\t  struct packet_type *pt, struct net_device *unused)\n{\n\tstruct metadata_dst *md_dst = skb_metadata_dst(skb);\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\tstruct sk_buff *nskb = NULL;\n\tstruct dsa_slave_priv *p;\n\n\tif (unlikely(!cpu_dp)) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tskb = skb_unshare(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn 0;\n\n\tif (md_dst && md_dst->type == METADATA_HW_PORT_MUX) {\n\t\tunsigned int port = md_dst->u.port_info.port_id;\n\n\t\tskb_dst_drop(skb);\n\t\tif (!skb_has_extensions(skb))\n\t\t\tskb->slow_gro = 0;\n\n\t\tskb->dev = dsa_master_find_slave(dev, 0, port);\n\t\tif (likely(skb->dev)) {\n\t\t\tdsa_default_offload_fwd_mark(skb);\n\t\t\tnskb = skb;\n\t\t}\n\t} else {\n\t\tnskb = cpu_dp->rcv(skb, dev);\n\t}\n\n\tif (!nskb) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tskb = nskb;\n\tskb_push(skb, ETH_HLEN);\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, skb->dev);\n\n\tif (unlikely(!dsa_slave_dev_check(skb->dev))) {\n\t\t \n\t\tnetif_rx(skb);\n\t\treturn 0;\n\t}\n\n\tp = netdev_priv(skb->dev);\n\n\tif (unlikely(cpu_dp->ds->untag_bridge_pvid)) {\n\t\tnskb = dsa_untag_bridge_pvid(skb);\n\t\tif (!nskb) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tskb = nskb;\n\t}\n\n\tdev_sw_netstats_rx_add(skb->dev, skb->len + ETH_HLEN);\n\n\tif (dsa_skb_defer_rx_timestamp(p, skb))\n\t\treturn 0;\n\n\tgro_cells_receive(&p->gcells, skb);\n\n\treturn 0;\n}\n\nstruct packet_type dsa_pack_type __read_mostly = {\n\t.type\t= cpu_to_be16(ETH_P_XDSA),\n\t.func\t= dsa_switch_rcv,\n};\n\nstatic void dsa_tag_driver_register(struct dsa_tag_driver *dsa_tag_driver,\n\t\t\t\t    struct module *owner)\n{\n\tdsa_tag_driver->owner = owner;\n\n\tmutex_lock(&dsa_tag_drivers_lock);\n\tlist_add_tail(&dsa_tag_driver->list, &dsa_tag_drivers_list);\n\tmutex_unlock(&dsa_tag_drivers_lock);\n}\n\nvoid dsa_tag_drivers_register(struct dsa_tag_driver *dsa_tag_driver_array[],\n\t\t\t      unsigned int count, struct module *owner)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tdsa_tag_driver_register(dsa_tag_driver_array[i], owner);\n}\n\nstatic void dsa_tag_driver_unregister(struct dsa_tag_driver *dsa_tag_driver)\n{\n\tmutex_lock(&dsa_tag_drivers_lock);\n\tlist_del(&dsa_tag_driver->list);\n\tmutex_unlock(&dsa_tag_drivers_lock);\n}\nEXPORT_SYMBOL_GPL(dsa_tag_drivers_register);\n\nvoid dsa_tag_drivers_unregister(struct dsa_tag_driver *dsa_tag_driver_array[],\n\t\t\t\tunsigned int count)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i++)\n\t\tdsa_tag_driver_unregister(dsa_tag_driver_array[i]);\n}\nEXPORT_SYMBOL_GPL(dsa_tag_drivers_unregister);\n\nconst char *dsa_tag_protocol_to_str(const struct dsa_device_ops *ops)\n{\n\treturn ops->name;\n};\n\n \nconst struct dsa_device_ops *dsa_tag_driver_get_by_name(const char *name)\n{\n\tconst struct dsa_device_ops *ops = ERR_PTR(-ENOPROTOOPT);\n\tstruct dsa_tag_driver *dsa_tag_driver;\n\n\trequest_module(\"%s%s\", DSA_TAG_DRIVER_ALIAS, name);\n\n\tmutex_lock(&dsa_tag_drivers_lock);\n\tlist_for_each_entry(dsa_tag_driver, &dsa_tag_drivers_list, list) {\n\t\tconst struct dsa_device_ops *tmp = dsa_tag_driver->ops;\n\n\t\tif (strcmp(name, tmp->name))\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(dsa_tag_driver->owner))\n\t\t\tbreak;\n\n\t\tops = tmp;\n\t\tbreak;\n\t}\n\tmutex_unlock(&dsa_tag_drivers_lock);\n\n\treturn ops;\n}\n\nconst struct dsa_device_ops *dsa_tag_driver_get_by_id(int tag_protocol)\n{\n\tstruct dsa_tag_driver *dsa_tag_driver;\n\tconst struct dsa_device_ops *ops;\n\tbool found = false;\n\n\trequest_module(\"%sid-%d\", DSA_TAG_DRIVER_ALIAS, tag_protocol);\n\n\tmutex_lock(&dsa_tag_drivers_lock);\n\tlist_for_each_entry(dsa_tag_driver, &dsa_tag_drivers_list, list) {\n\t\tops = dsa_tag_driver->ops;\n\t\tif (ops->proto == tag_protocol) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tif (!try_module_get(dsa_tag_driver->owner))\n\t\t\tops = ERR_PTR(-ENOPROTOOPT);\n\t} else {\n\t\tops = ERR_PTR(-ENOPROTOOPT);\n\t}\n\n\tmutex_unlock(&dsa_tag_drivers_lock);\n\n\treturn ops;\n}\n\nvoid dsa_tag_driver_put(const struct dsa_device_ops *ops)\n{\n\tstruct dsa_tag_driver *dsa_tag_driver;\n\n\tmutex_lock(&dsa_tag_drivers_lock);\n\tlist_for_each_entry(dsa_tag_driver, &dsa_tag_drivers_list, list) {\n\t\tif (dsa_tag_driver->ops == ops) {\n\t\t\tmodule_put(dsa_tag_driver->owner);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&dsa_tag_drivers_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}