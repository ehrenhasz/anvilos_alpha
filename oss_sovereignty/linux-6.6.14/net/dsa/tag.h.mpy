{
  "module_name": "tag.h",
  "hash_id": "929f2bc60dfbe3664b796086522d82cbddf2287a269cbcdc121ab951bfc8434d",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag.h",
  "human_readable_source": " \n\n#ifndef __DSA_TAG_H\n#define __DSA_TAG_H\n\n#include <linux/if_vlan.h>\n#include <linux/list.h>\n#include <linux/types.h>\n#include <net/dsa.h>\n\n#include \"port.h\"\n#include \"slave.h\"\n\nstruct dsa_tag_driver {\n\tconst struct dsa_device_ops *ops;\n\tstruct list_head list;\n\tstruct module *owner;\n};\n\nextern struct packet_type dsa_pack_type;\n\nconst struct dsa_device_ops *dsa_tag_driver_get_by_id(int tag_protocol);\nconst struct dsa_device_ops *dsa_tag_driver_get_by_name(const char *name);\nvoid dsa_tag_driver_put(const struct dsa_device_ops *ops);\nconst char *dsa_tag_protocol_to_str(const struct dsa_device_ops *ops);\n\nstatic inline int dsa_tag_protocol_overhead(const struct dsa_device_ops *ops)\n{\n\treturn ops->needed_headroom + ops->needed_tailroom;\n}\n\nstatic inline struct net_device *dsa_master_find_slave(struct net_device *dev,\n\t\t\t\t\t\t       int device, int port)\n{\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\tstruct dsa_switch_tree *dst = cpu_dp->dst;\n\tstruct dsa_port *dp;\n\n\tlist_for_each_entry(dp, &dst->ports, list)\n\t\tif (dp->ds->index == device && dp->index == port &&\n\t\t    dp->type == DSA_PORT_TYPE_USER)\n\t\t\treturn dp->slave;\n\n\treturn NULL;\n}\n\n \nstatic inline struct sk_buff *dsa_untag_bridge_pvid(struct sk_buff *skb)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(skb->dev);\n\tstruct net_device *br = dsa_port_bridge_dev_get(dp);\n\tstruct net_device *dev = skb->dev;\n\tstruct net_device *upper_dev;\n\tu16 vid, pvid, proto;\n\tint err;\n\n\tif (!br || br_vlan_enabled(br))\n\t\treturn skb;\n\n\terr = br_vlan_get_proto(br, &proto);\n\tif (err)\n\t\treturn skb;\n\n\t \n\tif (!skb_vlan_tag_present(skb) && skb->protocol == htons(proto)) {\n\t\tskb = skb_vlan_untag(skb);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t}\n\n\tif (!skb_vlan_tag_present(skb))\n\t\treturn skb;\n\n\tvid = skb_vlan_tag_get_id(skb);\n\n\t \n\terr = br_vlan_get_pvid_rcu(dev, &pvid);\n\tif (err)\n\t\treturn skb;\n\n\tif (vid != pvid)\n\t\treturn skb;\n\n\t \n\tupper_dev = __vlan_find_dev_deep_rcu(br, htons(proto), vid);\n\tif (upper_dev)\n\t\treturn skb;\n\n\t__vlan_hwaccel_clear_tag(skb);\n\n\treturn skb;\n}\n\n \nstatic inline struct net_device *\ndsa_find_designated_bridge_port_by_vid(struct net_device *master, u16 vid)\n{\n\tstruct dsa_port *cpu_dp = master->dsa_ptr;\n\tstruct dsa_switch_tree *dst = cpu_dp->dst;\n\tstruct bridge_vlan_info vinfo;\n\tstruct net_device *slave;\n\tstruct dsa_port *dp;\n\tint err;\n\n\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\tif (dp->type != DSA_PORT_TYPE_USER)\n\t\t\tcontinue;\n\n\t\tif (!dp->bridge)\n\t\t\tcontinue;\n\n\t\tif (dp->stp_state != BR_STATE_LEARNING &&\n\t\t    dp->stp_state != BR_STATE_FORWARDING)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (dp->cpu_dp != cpu_dp)\n\t\t\tcontinue;\n\n\t\tslave = dp->slave;\n\n\t\terr = br_vlan_get_info_rcu(slave, vid, &vinfo);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\treturn slave;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic inline void dsa_default_offload_fwd_mark(struct sk_buff *skb)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(skb->dev);\n\n\tskb->offload_fwd_mark = !!(dp->bridge);\n}\n\n \nstatic inline void dsa_strip_etype_header(struct sk_buff *skb, int len)\n{\n\tmemmove(skb->data - ETH_HLEN, skb->data - ETH_HLEN - len, 2 * ETH_ALEN);\n}\n\n \nstatic inline void dsa_alloc_etype_header(struct sk_buff *skb, int len)\n{\n\tmemmove(skb->data, skb->data + len, 2 * ETH_ALEN);\n}\n\n \nstatic inline void *dsa_etype_header_pos_rx(struct sk_buff *skb)\n{\n\treturn skb->data - 2;\n}\n\n \nstatic inline void *dsa_etype_header_pos_tx(struct sk_buff *skb)\n{\n\treturn skb->data + 2 * ETH_ALEN;\n}\n\n \n#define DSA_TAG_DRIVER_ALIAS \"dsa_tag:\"\n#define MODULE_ALIAS_DSA_TAG_DRIVER(__proto, __name) \\\n\tMODULE_ALIAS(DSA_TAG_DRIVER_ALIAS __name); \\\n\tMODULE_ALIAS(DSA_TAG_DRIVER_ALIAS \"id-\" \\\n\t\t     __stringify(__proto##_VALUE))\n\nvoid dsa_tag_drivers_register(struct dsa_tag_driver *dsa_tag_driver_array[],\n\t\t\t      unsigned int count,\n\t\t\t      struct module *owner);\nvoid dsa_tag_drivers_unregister(struct dsa_tag_driver *dsa_tag_driver_array[],\n\t\t\t\tunsigned int count);\n\n#define dsa_tag_driver_module_drivers(__dsa_tag_drivers_array, __count)\t\\\nstatic int __init dsa_tag_driver_module_init(void)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tdsa_tag_drivers_register(__dsa_tag_drivers_array, __count,\t\\\n\t\t\t\t THIS_MODULE);\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nmodule_init(dsa_tag_driver_module_init);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic void __exit dsa_tag_driver_module_exit(void)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tdsa_tag_drivers_unregister(__dsa_tag_drivers_array, __count);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nmodule_exit(dsa_tag_driver_module_exit)\n\n \n#define module_dsa_tag_drivers(__ops_array)\t\t\t\t\\\ndsa_tag_driver_module_drivers(__ops_array, ARRAY_SIZE(__ops_array))\n\n#define DSA_TAG_DRIVER_NAME(__ops) dsa_tag_driver ## _ ## __ops\n\n \n#define DSA_TAG_DRIVER(__ops)\t\t\t\t\t\t\\\nstatic struct dsa_tag_driver DSA_TAG_DRIVER_NAME(__ops) = {\t\t\\\n\t.ops = &__ops,\t\t\t\t\t\t\t\\\n}\n\n \n#define module_dsa_tag_driver(__ops)\t\t\t\t\t\\\nDSA_TAG_DRIVER(__ops);\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic struct dsa_tag_driver *dsa_tag_driver_array[] =\t{\t\t\\\n\t&DSA_TAG_DRIVER_NAME(__ops)\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\nmodule_dsa_tag_drivers(dsa_tag_driver_array)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}