{
  "module_name": "slave.c",
  "hash_id": "aa363ac8c20ca3b5353001baac74e887a51ba9db2dfa07680aabc68c92d1a8dd",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/slave.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n#include <linux/phylink.h>\n#include <linux/of_net.h>\n#include <linux/of_mdio.h>\n#include <linux/mdio.h>\n#include <net/rtnetlink.h>\n#include <net/pkt_cls.h>\n#include <net/selftests.h>\n#include <net/tc_act/tc_mirred.h>\n#include <linux/if_bridge.h>\n#include <linux/if_hsr.h>\n#include <net/dcbnl.h>\n#include <linux/netpoll.h>\n#include <linux/string.h>\n\n#include \"dsa.h\"\n#include \"port.h\"\n#include \"master.h\"\n#include \"netlink.h\"\n#include \"slave.h\"\n#include \"switch.h\"\n#include \"tag.h\"\n\nstruct dsa_switchdev_event_work {\n\tstruct net_device *dev;\n\tstruct net_device *orig_dev;\n\tstruct work_struct work;\n\tunsigned long event;\n\t \n\tunsigned char addr[ETH_ALEN];\n\tu16 vid;\n\tbool host_addr;\n};\n\nenum dsa_standalone_event {\n\tDSA_UC_ADD,\n\tDSA_UC_DEL,\n\tDSA_MC_ADD,\n\tDSA_MC_DEL,\n};\n\nstruct dsa_standalone_event_work {\n\tstruct work_struct work;\n\tstruct net_device *dev;\n\tenum dsa_standalone_event event;\n\tunsigned char addr[ETH_ALEN];\n\tu16 vid;\n};\n\nstruct dsa_host_vlan_rx_filtering_ctx {\n\tstruct net_device *dev;\n\tconst unsigned char *addr;\n\tenum dsa_standalone_event event;\n};\n\nstatic bool dsa_switch_supports_uc_filtering(struct dsa_switch *ds)\n{\n\treturn ds->ops->port_fdb_add && ds->ops->port_fdb_del &&\n\t       ds->fdb_isolation && !ds->vlan_filtering_is_global &&\n\t       !ds->needs_standalone_vlan_filtering;\n}\n\nstatic bool dsa_switch_supports_mc_filtering(struct dsa_switch *ds)\n{\n\treturn ds->ops->port_mdb_add && ds->ops->port_mdb_del &&\n\t       ds->fdb_isolation && !ds->vlan_filtering_is_global &&\n\t       !ds->needs_standalone_vlan_filtering;\n}\n\nstatic void dsa_slave_standalone_event_work(struct work_struct *work)\n{\n\tstruct dsa_standalone_event_work *standalone_work =\n\t\tcontainer_of(work, struct dsa_standalone_event_work, work);\n\tconst unsigned char *addr = standalone_work->addr;\n\tstruct net_device *dev = standalone_work->dev;\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct switchdev_obj_port_mdb mdb;\n\tstruct dsa_switch *ds = dp->ds;\n\tu16 vid = standalone_work->vid;\n\tint err;\n\n\tswitch (standalone_work->event) {\n\tcase DSA_UC_ADD:\n\t\terr = dsa_port_standalone_host_fdb_add(dp, addr, vid);\n\t\tif (err) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"port %d failed to add %pM vid %d to fdb: %d\\n\",\n\t\t\t\tdp->index, addr, vid, err);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase DSA_UC_DEL:\n\t\terr = dsa_port_standalone_host_fdb_del(dp, addr, vid);\n\t\tif (err) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"port %d failed to delete %pM vid %d from fdb: %d\\n\",\n\t\t\t\tdp->index, addr, vid, err);\n\t\t}\n\n\t\tbreak;\n\tcase DSA_MC_ADD:\n\t\tether_addr_copy(mdb.addr, addr);\n\t\tmdb.vid = vid;\n\n\t\terr = dsa_port_standalone_host_mdb_add(dp, &mdb);\n\t\tif (err) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"port %d failed to add %pM vid %d to mdb: %d\\n\",\n\t\t\t\tdp->index, addr, vid, err);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DSA_MC_DEL:\n\t\tether_addr_copy(mdb.addr, addr);\n\t\tmdb.vid = vid;\n\n\t\terr = dsa_port_standalone_host_mdb_del(dp, &mdb);\n\t\tif (err) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"port %d failed to delete %pM vid %d from mdb: %d\\n\",\n\t\t\t\tdp->index, addr, vid, err);\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tkfree(standalone_work);\n}\n\nstatic int dsa_slave_schedule_standalone_work(struct net_device *dev,\n\t\t\t\t\t      enum dsa_standalone_event event,\n\t\t\t\t\t      const unsigned char *addr,\n\t\t\t\t\t      u16 vid)\n{\n\tstruct dsa_standalone_event_work *standalone_work;\n\n\tstandalone_work = kzalloc(sizeof(*standalone_work), GFP_ATOMIC);\n\tif (!standalone_work)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&standalone_work->work, dsa_slave_standalone_event_work);\n\tstandalone_work->event = event;\n\tstandalone_work->dev = dev;\n\n\tether_addr_copy(standalone_work->addr, addr);\n\tstandalone_work->vid = vid;\n\n\tdsa_schedule_work(&standalone_work->work);\n\n\treturn 0;\n}\n\nstatic int dsa_slave_host_vlan_rx_filtering(void *arg, int vid)\n{\n\tstruct dsa_host_vlan_rx_filtering_ctx *ctx = arg;\n\n\treturn dsa_slave_schedule_standalone_work(ctx->dev, ctx->event,\n\t\t\t\t\t\t  ctx->addr, vid);\n}\n\nstatic int dsa_slave_vlan_for_each(struct net_device *dev,\n\t\t\t\t   int (*cb)(void *arg, int vid), void *arg)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_vlan *v;\n\tint err;\n\n\tlockdep_assert_held(&dev->addr_list_lock);\n\n\terr = cb(arg, 0);\n\tif (err)\n\t\treturn err;\n\n\tlist_for_each_entry(v, &dp->user_vlans, list) {\n\t\terr = cb(arg, v->vid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int dsa_slave_sync_uc(struct net_device *dev,\n\t\t\t     const unsigned char *addr)\n{\n\tstruct net_device *master = dsa_slave_to_master(dev);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_host_vlan_rx_filtering_ctx ctx = {\n\t\t.dev = dev,\n\t\t.addr = addr,\n\t\t.event = DSA_UC_ADD,\n\t};\n\n\tdev_uc_add(master, addr);\n\n\tif (!dsa_switch_supports_uc_filtering(dp->ds))\n\t\treturn 0;\n\n\treturn dsa_slave_vlan_for_each(dev, dsa_slave_host_vlan_rx_filtering,\n\t\t\t\t       &ctx);\n}\n\nstatic int dsa_slave_unsync_uc(struct net_device *dev,\n\t\t\t       const unsigned char *addr)\n{\n\tstruct net_device *master = dsa_slave_to_master(dev);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_host_vlan_rx_filtering_ctx ctx = {\n\t\t.dev = dev,\n\t\t.addr = addr,\n\t\t.event = DSA_UC_DEL,\n\t};\n\n\tdev_uc_del(master, addr);\n\n\tif (!dsa_switch_supports_uc_filtering(dp->ds))\n\t\treturn 0;\n\n\treturn dsa_slave_vlan_for_each(dev, dsa_slave_host_vlan_rx_filtering,\n\t\t\t\t       &ctx);\n}\n\nstatic int dsa_slave_sync_mc(struct net_device *dev,\n\t\t\t     const unsigned char *addr)\n{\n\tstruct net_device *master = dsa_slave_to_master(dev);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_host_vlan_rx_filtering_ctx ctx = {\n\t\t.dev = dev,\n\t\t.addr = addr,\n\t\t.event = DSA_MC_ADD,\n\t};\n\n\tdev_mc_add(master, addr);\n\n\tif (!dsa_switch_supports_mc_filtering(dp->ds))\n\t\treturn 0;\n\n\treturn dsa_slave_vlan_for_each(dev, dsa_slave_host_vlan_rx_filtering,\n\t\t\t\t       &ctx);\n}\n\nstatic int dsa_slave_unsync_mc(struct net_device *dev,\n\t\t\t       const unsigned char *addr)\n{\n\tstruct net_device *master = dsa_slave_to_master(dev);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_host_vlan_rx_filtering_ctx ctx = {\n\t\t.dev = dev,\n\t\t.addr = addr,\n\t\t.event = DSA_MC_DEL,\n\t};\n\n\tdev_mc_del(master, addr);\n\n\tif (!dsa_switch_supports_mc_filtering(dp->ds))\n\t\treturn 0;\n\n\treturn dsa_slave_vlan_for_each(dev, dsa_slave_host_vlan_rx_filtering,\n\t\t\t\t       &ctx);\n}\n\nvoid dsa_slave_sync_ha(struct net_device *dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct netdev_hw_addr *ha;\n\n\tnetif_addr_lock_bh(dev);\n\n\tnetdev_for_each_synced_mc_addr(ha, dev)\n\t\tdsa_slave_sync_mc(dev, ha->addr);\n\n\tnetdev_for_each_synced_uc_addr(ha, dev)\n\t\tdsa_slave_sync_uc(dev, ha->addr);\n\n\tnetif_addr_unlock_bh(dev);\n\n\tif (dsa_switch_supports_uc_filtering(ds) ||\n\t    dsa_switch_supports_mc_filtering(ds))\n\t\tdsa_flush_workqueue();\n}\n\nvoid dsa_slave_unsync_ha(struct net_device *dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct netdev_hw_addr *ha;\n\n\tnetif_addr_lock_bh(dev);\n\n\tnetdev_for_each_synced_uc_addr(ha, dev)\n\t\tdsa_slave_unsync_uc(dev, ha->addr);\n\n\tnetdev_for_each_synced_mc_addr(ha, dev)\n\t\tdsa_slave_unsync_mc(dev, ha->addr);\n\n\tnetif_addr_unlock_bh(dev);\n\n\tif (dsa_switch_supports_uc_filtering(ds) ||\n\t    dsa_switch_supports_mc_filtering(ds))\n\t\tdsa_flush_workqueue();\n}\n\n \nstatic int dsa_slave_phy_read(struct mii_bus *bus, int addr, int reg)\n{\n\tstruct dsa_switch *ds = bus->priv;\n\n\tif (ds->phys_mii_mask & (1 << addr))\n\t\treturn ds->ops->phy_read(ds, addr, reg);\n\n\treturn 0xffff;\n}\n\nstatic int dsa_slave_phy_write(struct mii_bus *bus, int addr, int reg, u16 val)\n{\n\tstruct dsa_switch *ds = bus->priv;\n\n\tif (ds->phys_mii_mask & (1 << addr))\n\t\treturn ds->ops->phy_write(ds, addr, reg, val);\n\n\treturn 0;\n}\n\nvoid dsa_slave_mii_bus_init(struct dsa_switch *ds)\n{\n\tds->slave_mii_bus->priv = (void *)ds;\n\tds->slave_mii_bus->name = \"dsa slave smi\";\n\tds->slave_mii_bus->read = dsa_slave_phy_read;\n\tds->slave_mii_bus->write = dsa_slave_phy_write;\n\tsnprintf(ds->slave_mii_bus->id, MII_BUS_ID_SIZE, \"dsa-%d.%d\",\n\t\t ds->dst->index, ds->index);\n\tds->slave_mii_bus->parent = ds->dev;\n\tds->slave_mii_bus->phy_mask = ~ds->phys_mii_mask;\n}\n\n\n \nstatic int dsa_slave_get_iflink(const struct net_device *dev)\n{\n\treturn dsa_slave_to_master(dev)->ifindex;\n}\n\nstatic int dsa_slave_open(struct net_device *dev)\n{\n\tstruct net_device *master = dsa_slave_to_master(dev);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tint err;\n\n\terr = dev_open(master, NULL);\n\tif (err < 0) {\n\t\tnetdev_err(dev, \"failed to open master %s\\n\", master->name);\n\t\tgoto out;\n\t}\n\n\tif (dsa_switch_supports_uc_filtering(ds)) {\n\t\terr = dsa_port_standalone_host_fdb_add(dp, dev->dev_addr, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (!ether_addr_equal(dev->dev_addr, master->dev_addr)) {\n\t\terr = dev_uc_add(master, dev->dev_addr);\n\t\tif (err < 0)\n\t\t\tgoto del_host_addr;\n\t}\n\n\terr = dsa_port_enable_rt(dp, dev->phydev);\n\tif (err)\n\t\tgoto del_unicast;\n\n\treturn 0;\n\ndel_unicast:\n\tif (!ether_addr_equal(dev->dev_addr, master->dev_addr))\n\t\tdev_uc_del(master, dev->dev_addr);\ndel_host_addr:\n\tif (dsa_switch_supports_uc_filtering(ds))\n\t\tdsa_port_standalone_host_fdb_del(dp, dev->dev_addr, 0);\nout:\n\treturn err;\n}\n\nstatic int dsa_slave_close(struct net_device *dev)\n{\n\tstruct net_device *master = dsa_slave_to_master(dev);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tdsa_port_disable_rt(dp);\n\n\tif (!ether_addr_equal(dev->dev_addr, master->dev_addr))\n\t\tdev_uc_del(master, dev->dev_addr);\n\n\tif (dsa_switch_supports_uc_filtering(ds))\n\t\tdsa_port_standalone_host_fdb_del(dp, dev->dev_addr, 0);\n\n\treturn 0;\n}\n\nstatic void dsa_slave_manage_host_flood(struct net_device *dev)\n{\n\tbool mc = dev->flags & (IFF_PROMISC | IFF_ALLMULTI);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tbool uc = dev->flags & IFF_PROMISC;\n\n\tdsa_port_set_host_flood(dp, uc, mc);\n}\n\nstatic void dsa_slave_change_rx_flags(struct net_device *dev, int change)\n{\n\tstruct net_device *master = dsa_slave_to_master(dev);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (change & IFF_ALLMULTI)\n\t\tdev_set_allmulti(master,\n\t\t\t\t dev->flags & IFF_ALLMULTI ? 1 : -1);\n\tif (change & IFF_PROMISC)\n\t\tdev_set_promiscuity(master,\n\t\t\t\t    dev->flags & IFF_PROMISC ? 1 : -1);\n\n\tif (dsa_switch_supports_uc_filtering(ds) &&\n\t    dsa_switch_supports_mc_filtering(ds))\n\t\tdsa_slave_manage_host_flood(dev);\n}\n\nstatic void dsa_slave_set_rx_mode(struct net_device *dev)\n{\n\t__dev_mc_sync(dev, dsa_slave_sync_mc, dsa_slave_unsync_mc);\n\t__dev_uc_sync(dev, dsa_slave_sync_uc, dsa_slave_unsync_uc);\n}\n\nstatic int dsa_slave_set_mac_address(struct net_device *dev, void *a)\n{\n\tstruct net_device *master = dsa_slave_to_master(dev);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct sockaddr *addr = a;\n\tint err;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\tif (!(dev->flags & IFF_UP))\n\t\tgoto out_change_dev_addr;\n\n\tif (dsa_switch_supports_uc_filtering(ds)) {\n\t\terr = dsa_port_standalone_host_fdb_add(dp, addr->sa_data, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!ether_addr_equal(addr->sa_data, master->dev_addr)) {\n\t\terr = dev_uc_add(master, addr->sa_data);\n\t\tif (err < 0)\n\t\t\tgoto del_unicast;\n\t}\n\n\tif (!ether_addr_equal(dev->dev_addr, master->dev_addr))\n\t\tdev_uc_del(master, dev->dev_addr);\n\n\tif (dsa_switch_supports_uc_filtering(ds))\n\t\tdsa_port_standalone_host_fdb_del(dp, dev->dev_addr, 0);\n\nout_change_dev_addr:\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\treturn 0;\n\ndel_unicast:\n\tif (dsa_switch_supports_uc_filtering(ds))\n\t\tdsa_port_standalone_host_fdb_del(dp, addr->sa_data, 0);\n\n\treturn err;\n}\n\nstruct dsa_slave_dump_ctx {\n\tstruct net_device *dev;\n\tstruct sk_buff *skb;\n\tstruct netlink_callback *cb;\n\tint idx;\n};\n\nstatic int\ndsa_slave_port_fdb_do_dump(const unsigned char *addr, u16 vid,\n\t\t\t   bool is_static, void *data)\n{\n\tstruct dsa_slave_dump_ctx *dump = data;\n\tu32 portid = NETLINK_CB(dump->cb->skb).portid;\n\tu32 seq = dump->cb->nlh->nlmsg_seq;\n\tstruct nlmsghdr *nlh;\n\tstruct ndmsg *ndm;\n\n\tif (dump->idx < dump->cb->args[2])\n\t\tgoto skip;\n\n\tnlh = nlmsg_put(dump->skb, portid, seq, RTM_NEWNEIGH,\n\t\t\tsizeof(*ndm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tndm = nlmsg_data(nlh);\n\tndm->ndm_family  = AF_BRIDGE;\n\tndm->ndm_pad1    = 0;\n\tndm->ndm_pad2    = 0;\n\tndm->ndm_flags   = NTF_SELF;\n\tndm->ndm_type    = 0;\n\tndm->ndm_ifindex = dump->dev->ifindex;\n\tndm->ndm_state   = is_static ? NUD_NOARP : NUD_REACHABLE;\n\n\tif (nla_put(dump->skb, NDA_LLADDR, ETH_ALEN, addr))\n\t\tgoto nla_put_failure;\n\n\tif (vid && nla_put_u16(dump->skb, NDA_VLAN, vid))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(dump->skb, nlh);\n\nskip:\n\tdump->idx++;\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(dump->skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int\ndsa_slave_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t   struct net_device *dev, struct net_device *filter_dev,\n\t\t   int *idx)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_slave_dump_ctx dump = {\n\t\t.dev = dev,\n\t\t.skb = skb,\n\t\t.cb = cb,\n\t\t.idx = *idx,\n\t};\n\tint err;\n\n\terr = dsa_port_fdb_dump(dp, dsa_slave_port_fdb_do_dump, &dump);\n\t*idx = dump.idx;\n\n\treturn err;\n}\n\nstatic int dsa_slave_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct dsa_slave_priv *p = netdev_priv(dev);\n\tstruct dsa_switch *ds = p->dp->ds;\n\tint port = p->dp->index;\n\n\t \n\tswitch (cmd) {\n\tcase SIOCGHWTSTAMP:\n\t\tif (ds->ops->port_hwtstamp_get)\n\t\t\treturn ds->ops->port_hwtstamp_get(ds, port, ifr);\n\t\tbreak;\n\tcase SIOCSHWTSTAMP:\n\t\tif (ds->ops->port_hwtstamp_set)\n\t\t\treturn ds->ops->port_hwtstamp_set(ds, port, ifr);\n\t\tbreak;\n\t}\n\n\treturn phylink_mii_ioctl(p->dp->pl, ifr, cmd);\n}\n\nstatic int dsa_slave_port_attr_set(struct net_device *dev, const void *ctx,\n\t\t\t\t   const struct switchdev_attr *attr,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tint ret;\n\n\tif (ctx && ctx != dp)\n\t\treturn 0;\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_PORT_STP_STATE:\n\t\tif (!dsa_port_offloads_bridge_port(dp, attr->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = dsa_port_set_state(dp, attr->u.stp_state, true);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_MST_STATE:\n\t\tif (!dsa_port_offloads_bridge_port(dp, attr->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = dsa_port_set_mst_state(dp, &attr->u.mst_state, extack);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING:\n\t\tif (!dsa_port_offloads_bridge_dev(dp, attr->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = dsa_port_vlan_filtering(dp, attr->u.vlan_filtering,\n\t\t\t\t\t      extack);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME:\n\t\tif (!dsa_port_offloads_bridge_dev(dp, attr->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = dsa_port_ageing_time(dp, attr->u.ageing_time);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_BRIDGE_MST:\n\t\tif (!dsa_port_offloads_bridge_dev(dp, attr->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = dsa_port_mst_enable(dp, attr->u.mst, extack);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS:\n\t\tif (!dsa_port_offloads_bridge_port(dp, attr->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = dsa_port_pre_bridge_flags(dp, attr->u.brport_flags,\n\t\t\t\t\t\textack);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS:\n\t\tif (!dsa_port_offloads_bridge_port(dp, attr->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = dsa_port_bridge_flags(dp, attr->u.brport_flags, extack);\n\t\tbreak;\n\tcase SWITCHDEV_ATTR_ID_VLAN_MSTI:\n\t\tif (!dsa_port_offloads_bridge_dev(dp, attr->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = dsa_port_vlan_msti(dp, &attr->u.vlan_msti);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\ndsa_slave_vlan_check_for_8021q_uppers(struct net_device *slave,\n\t\t\t\t      const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct net_device *upper_dev;\n\tstruct list_head *iter;\n\n\tnetdev_for_each_upper_dev_rcu(slave, upper_dev, iter) {\n\t\tu16 vid;\n\n\t\tif (!is_vlan_dev(upper_dev))\n\t\t\tcontinue;\n\n\t\tvid = vlan_dev_vlan_id(upper_dev);\n\t\tif (vid == vlan->vid)\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int dsa_slave_vlan_add(struct net_device *dev,\n\t\t\t      const struct switchdev_obj *obj,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct switchdev_obj_port_vlan *vlan;\n\tint err;\n\n\tif (dsa_port_skip_vlan_configuration(dp)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"skipping configuration of VLAN\");\n\t\treturn 0;\n\t}\n\n\tvlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\n\t \n\tif (br_vlan_enabled(dsa_port_bridge_dev_get(dp))) {\n\t\trcu_read_lock();\n\t\terr = dsa_slave_vlan_check_for_8021q_uppers(dev, vlan);\n\t\trcu_read_unlock();\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Port already has a VLAN upper with this VID\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn dsa_port_vlan_add(dp, vlan, extack);\n}\n\n \nstatic int dsa_slave_host_vlan_add(struct net_device *dev,\n\t\t\t\t   const struct switchdev_obj *obj,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct switchdev_obj_port_vlan vlan;\n\n\t \n\tif (!dp->bridge)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dsa_port_skip_vlan_configuration(dp)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"skipping configuration of VLAN\");\n\t\treturn 0;\n\t}\n\n\tvlan = *SWITCHDEV_OBJ_PORT_VLAN(obj);\n\n\t \n\tvlan.flags &= ~BRIDGE_VLAN_INFO_PVID;\n\n\treturn dsa_port_host_vlan_add(dp, &vlan, extack);\n}\n\nstatic int dsa_slave_port_obj_add(struct net_device *dev, const void *ctx,\n\t\t\t\t  const struct switchdev_obj *obj,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tint err;\n\n\tif (ctx && ctx != dp)\n\t\treturn 0;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\tif (!dsa_port_offloads_bridge_port(dp, obj->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = dsa_port_mdb_add(dp, SWITCHDEV_OBJ_PORT_MDB(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_HOST_MDB:\n\t\tif (!dsa_port_offloads_bridge_dev(dp, obj->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = dsa_port_bridge_host_mdb_add(dp, SWITCHDEV_OBJ_PORT_MDB(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\tif (dsa_port_offloads_bridge_port(dp, obj->orig_dev))\n\t\t\terr = dsa_slave_vlan_add(dev, obj, extack);\n\t\telse\n\t\t\terr = dsa_slave_host_vlan_add(dev, obj, extack);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_MRP:\n\t\tif (!dsa_port_offloads_bridge_dev(dp, obj->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = dsa_port_mrp_add(dp, SWITCHDEV_OBJ_MRP(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_RING_ROLE_MRP:\n\t\tif (!dsa_port_offloads_bridge_dev(dp, obj->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = dsa_port_mrp_add_ring_role(dp,\n\t\t\t\t\t\t SWITCHDEV_OBJ_RING_ROLE_MRP(obj));\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int dsa_slave_vlan_del(struct net_device *dev,\n\t\t\t      const struct switchdev_obj *obj)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct switchdev_obj_port_vlan *vlan;\n\n\tif (dsa_port_skip_vlan_configuration(dp))\n\t\treturn 0;\n\n\tvlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\n\treturn dsa_port_vlan_del(dp, vlan);\n}\n\nstatic int dsa_slave_host_vlan_del(struct net_device *dev,\n\t\t\t\t   const struct switchdev_obj *obj)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct switchdev_obj_port_vlan *vlan;\n\n\t \n\tif (!dp->bridge)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dsa_port_skip_vlan_configuration(dp))\n\t\treturn 0;\n\n\tvlan = SWITCHDEV_OBJ_PORT_VLAN(obj);\n\n\treturn dsa_port_host_vlan_del(dp, vlan);\n}\n\nstatic int dsa_slave_port_obj_del(struct net_device *dev, const void *ctx,\n\t\t\t\t  const struct switchdev_obj *obj)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tint err;\n\n\tif (ctx && ctx != dp)\n\t\treturn 0;\n\n\tswitch (obj->id) {\n\tcase SWITCHDEV_OBJ_ID_PORT_MDB:\n\t\tif (!dsa_port_offloads_bridge_port(dp, obj->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = dsa_port_mdb_del(dp, SWITCHDEV_OBJ_PORT_MDB(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_HOST_MDB:\n\t\tif (!dsa_port_offloads_bridge_dev(dp, obj->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = dsa_port_bridge_host_mdb_del(dp, SWITCHDEV_OBJ_PORT_MDB(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_PORT_VLAN:\n\t\tif (dsa_port_offloads_bridge_port(dp, obj->orig_dev))\n\t\t\terr = dsa_slave_vlan_del(dev, obj);\n\t\telse\n\t\t\terr = dsa_slave_host_vlan_del(dev, obj);\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_MRP:\n\t\tif (!dsa_port_offloads_bridge_dev(dp, obj->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = dsa_port_mrp_del(dp, SWITCHDEV_OBJ_MRP(obj));\n\t\tbreak;\n\tcase SWITCHDEV_OBJ_ID_RING_ROLE_MRP:\n\t\tif (!dsa_port_offloads_bridge_dev(dp, obj->orig_dev))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = dsa_port_mrp_del_ring_role(dp,\n\t\t\t\t\t\t SWITCHDEV_OBJ_RING_ROLE_MRP(obj));\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic inline netdev_tx_t dsa_slave_netpoll_send_skb(struct net_device *dev,\n\t\t\t\t\t\t     struct sk_buff *skb)\n{\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\tstruct dsa_slave_priv *p = netdev_priv(dev);\n\n\treturn netpoll_send_skb(p->netpoll, skb);\n#else\n\tBUG();\n\treturn NETDEV_TX_OK;\n#endif\n}\n\nstatic void dsa_skb_tx_timestamp(struct dsa_slave_priv *p,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct dsa_switch *ds = p->dp->ds;\n\n\tif (!(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))\n\t\treturn;\n\n\tif (!ds->ops->port_txtstamp)\n\t\treturn;\n\n\tds->ops->port_txtstamp(ds, p->dp->index, skb);\n}\n\nnetdev_tx_t dsa_enqueue_skb(struct sk_buff *skb, struct net_device *dev)\n{\n\t \n\tif (unlikely(netpoll_tx_running(dev)))\n\t\treturn dsa_slave_netpoll_send_skb(dev, skb);\n\n\t \n\tskb->dev = dsa_slave_to_master(dev);\n\tdev_queue_xmit(skb);\n\n\treturn NETDEV_TX_OK;\n}\nEXPORT_SYMBOL_GPL(dsa_enqueue_skb);\n\nstatic int dsa_realloc_skb(struct sk_buff *skb, struct net_device *dev)\n{\n\tint needed_headroom = dev->needed_headroom;\n\tint needed_tailroom = dev->needed_tailroom;\n\n\t \n\tif (unlikely(needed_tailroom && skb->len < ETH_ZLEN))\n\t\tneeded_tailroom += ETH_ZLEN - skb->len;\n\t \n\tneeded_headroom = max_t(int, needed_headroom - skb_headroom(skb), 0);\n\tneeded_tailroom = max_t(int, needed_tailroom - skb_tailroom(skb), 0);\n\n\tif (likely(!needed_headroom && !needed_tailroom && !skb_cloned(skb)))\n\t\t \n\t\treturn 0;\n\n\treturn pskb_expand_head(skb, needed_headroom, needed_tailroom,\n\t\t\t\tGFP_ATOMIC);\n}\n\nstatic netdev_tx_t dsa_slave_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct dsa_slave_priv *p = netdev_priv(dev);\n\tstruct sk_buff *nskb;\n\n\tdev_sw_netstats_tx_add(dev, 1, skb->len);\n\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\t \n\tdsa_skb_tx_timestamp(p, skb);\n\n\tif (dsa_realloc_skb(skb, dev)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tif (dev->needed_tailroom)\n\t\teth_skb_pad(skb);\n\n\t \n\tnskb = p->xmit(skb, dev);\n\tif (!nskb) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\treturn dsa_enqueue_skb(nskb, dev);\n}\n\n \n\nstatic void dsa_slave_get_drvinfo(struct net_device *dev,\n\t\t\t\t  struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->driver, \"dsa\", sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->fw_version, \"N/A\", sizeof(drvinfo->fw_version));\n\tstrscpy(drvinfo->bus_info, \"platform\", sizeof(drvinfo->bus_info));\n}\n\nstatic int dsa_slave_get_regs_len(struct net_device *dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->get_regs_len)\n\t\treturn ds->ops->get_regs_len(ds, dp->index);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void\ndsa_slave_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *_p)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->get_regs)\n\t\tds->ops->get_regs(ds, dp->index, regs, _p);\n}\n\nstatic int dsa_slave_nway_reset(struct net_device *dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\n\treturn phylink_ethtool_nway_reset(dp->pl);\n}\n\nstatic int dsa_slave_get_eeprom_len(struct net_device *dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->cd && ds->cd->eeprom_len)\n\t\treturn ds->cd->eeprom_len;\n\n\tif (ds->ops->get_eeprom_len)\n\t\treturn ds->ops->get_eeprom_len(ds);\n\n\treturn 0;\n}\n\nstatic int dsa_slave_get_eeprom(struct net_device *dev,\n\t\t\t\tstruct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->get_eeprom)\n\t\treturn ds->ops->get_eeprom(ds, eeprom, data);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int dsa_slave_set_eeprom(struct net_device *dev,\n\t\t\t\tstruct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->set_eeprom)\n\t\treturn ds->ops->set_eeprom(ds, eeprom, data);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void dsa_slave_get_strings(struct net_device *dev,\n\t\t\t\t  uint32_t stringset, uint8_t *data)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (stringset == ETH_SS_STATS) {\n\t\tint len = ETH_GSTRING_LEN;\n\n\t\tstrscpy_pad(data, \"tx_packets\", len);\n\t\tstrscpy_pad(data + len, \"tx_bytes\", len);\n\t\tstrscpy_pad(data + 2 * len, \"rx_packets\", len);\n\t\tstrscpy_pad(data + 3 * len, \"rx_bytes\", len);\n\t\tif (ds->ops->get_strings)\n\t\t\tds->ops->get_strings(ds, dp->index, stringset,\n\t\t\t\t\t     data + 4 * len);\n\t} else if (stringset ==  ETH_SS_TEST) {\n\t\tnet_selftest_get_strings(data);\n\t}\n\n}\n\nstatic void dsa_slave_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t\tstruct ethtool_stats *stats,\n\t\t\t\t\tuint64_t *data)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct pcpu_sw_netstats *s;\n\tunsigned int start;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tu64 tx_packets, tx_bytes, rx_packets, rx_bytes;\n\n\t\ts = per_cpu_ptr(dev->tstats, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&s->syncp);\n\t\t\ttx_packets = u64_stats_read(&s->tx_packets);\n\t\t\ttx_bytes = u64_stats_read(&s->tx_bytes);\n\t\t\trx_packets = u64_stats_read(&s->rx_packets);\n\t\t\trx_bytes = u64_stats_read(&s->rx_bytes);\n\t\t} while (u64_stats_fetch_retry(&s->syncp, start));\n\t\tdata[0] += tx_packets;\n\t\tdata[1] += tx_bytes;\n\t\tdata[2] += rx_packets;\n\t\tdata[3] += rx_bytes;\n\t}\n\tif (ds->ops->get_ethtool_stats)\n\t\tds->ops->get_ethtool_stats(ds, dp->index, data + 4);\n}\n\nstatic int dsa_slave_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (sset == ETH_SS_STATS) {\n\t\tint count = 0;\n\n\t\tif (ds->ops->get_sset_count) {\n\t\t\tcount = ds->ops->get_sset_count(ds, dp->index, sset);\n\t\t\tif (count < 0)\n\t\t\t\treturn count;\n\t\t}\n\n\t\treturn count + 4;\n\t} else if (sset ==  ETH_SS_TEST) {\n\t\treturn net_selftest_get_count();\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void dsa_slave_get_eth_phy_stats(struct net_device *dev,\n\t\t\t\t\tstruct ethtool_eth_phy_stats *phy_stats)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->get_eth_phy_stats)\n\t\tds->ops->get_eth_phy_stats(ds, dp->index, phy_stats);\n}\n\nstatic void dsa_slave_get_eth_mac_stats(struct net_device *dev,\n\t\t\t\t\tstruct ethtool_eth_mac_stats *mac_stats)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->get_eth_mac_stats)\n\t\tds->ops->get_eth_mac_stats(ds, dp->index, mac_stats);\n}\n\nstatic void\ndsa_slave_get_eth_ctrl_stats(struct net_device *dev,\n\t\t\t     struct ethtool_eth_ctrl_stats *ctrl_stats)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->get_eth_ctrl_stats)\n\t\tds->ops->get_eth_ctrl_stats(ds, dp->index, ctrl_stats);\n}\n\nstatic void\ndsa_slave_get_rmon_stats(struct net_device *dev,\n\t\t\t struct ethtool_rmon_stats *rmon_stats,\n\t\t\t const struct ethtool_rmon_hist_range **ranges)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->get_rmon_stats)\n\t\tds->ops->get_rmon_stats(ds, dp->index, rmon_stats, ranges);\n}\n\nstatic void dsa_slave_net_selftest(struct net_device *ndev,\n\t\t\t\t   struct ethtool_test *etest, u64 *buf)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(ndev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->self_test) {\n\t\tds->ops->self_test(ds, dp->index, etest, buf);\n\t\treturn;\n\t}\n\n\tnet_selftest(ndev, etest, buf);\n}\n\nstatic int dsa_slave_get_mm(struct net_device *dev,\n\t\t\t    struct ethtool_mm_state *state)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->get_mm)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->get_mm(ds, dp->index, state);\n}\n\nstatic int dsa_slave_set_mm(struct net_device *dev, struct ethtool_mm_cfg *cfg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->set_mm)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->set_mm(ds, dp->index, cfg, extack);\n}\n\nstatic void dsa_slave_get_mm_stats(struct net_device *dev,\n\t\t\t\t   struct ethtool_mm_stats *stats)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->get_mm_stats)\n\t\tds->ops->get_mm_stats(ds, dp->index, stats);\n}\n\nstatic void dsa_slave_get_wol(struct net_device *dev, struct ethtool_wolinfo *w)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tphylink_ethtool_get_wol(dp->pl, w);\n\n\tif (ds->ops->get_wol)\n\t\tds->ops->get_wol(ds, dp->index, w);\n}\n\nstatic int dsa_slave_set_wol(struct net_device *dev, struct ethtool_wolinfo *w)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tint ret = -EOPNOTSUPP;\n\n\tphylink_ethtool_set_wol(dp->pl, w);\n\n\tif (ds->ops->set_wol)\n\t\tret = ds->ops->set_wol(ds, dp->index, w);\n\n\treturn ret;\n}\n\nstatic int dsa_slave_set_eee(struct net_device *dev, struct ethtool_eee *e)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tint ret;\n\n\t \n\tif (!dev->phydev || !dp->pl)\n\t\treturn -ENODEV;\n\n\tif (!ds->ops->set_mac_eee)\n\t\treturn -EOPNOTSUPP;\n\n\tret = ds->ops->set_mac_eee(ds, dp->index, e);\n\tif (ret)\n\t\treturn ret;\n\n\treturn phylink_ethtool_set_eee(dp->pl, e);\n}\n\nstatic int dsa_slave_get_eee(struct net_device *dev, struct ethtool_eee *e)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tint ret;\n\n\t \n\tif (!dev->phydev || !dp->pl)\n\t\treturn -ENODEV;\n\n\tif (!ds->ops->get_mac_eee)\n\t\treturn -EOPNOTSUPP;\n\n\tret = ds->ops->get_mac_eee(ds, dp->index, e);\n\tif (ret)\n\t\treturn ret;\n\n\treturn phylink_ethtool_get_eee(dp->pl, e);\n}\n\nstatic int dsa_slave_get_link_ksettings(struct net_device *dev,\n\t\t\t\t\tstruct ethtool_link_ksettings *cmd)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\n\treturn phylink_ethtool_ksettings_get(dp->pl, cmd);\n}\n\nstatic int dsa_slave_set_link_ksettings(struct net_device *dev,\n\t\t\t\t\tconst struct ethtool_link_ksettings *cmd)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\n\treturn phylink_ethtool_ksettings_set(dp->pl, cmd);\n}\n\nstatic void dsa_slave_get_pause_stats(struct net_device *dev,\n\t\t\t\t  struct ethtool_pause_stats *pause_stats)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->get_pause_stats)\n\t\tds->ops->get_pause_stats(ds, dp->index, pause_stats);\n}\n\nstatic void dsa_slave_get_pauseparam(struct net_device *dev,\n\t\t\t\t     struct ethtool_pauseparam *pause)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\n\tphylink_ethtool_get_pauseparam(dp->pl, pause);\n}\n\nstatic int dsa_slave_set_pauseparam(struct net_device *dev,\n\t\t\t\t    struct ethtool_pauseparam *pause)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\n\treturn phylink_ethtool_set_pauseparam(dp->pl, pause);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic int dsa_slave_netpoll_setup(struct net_device *dev,\n\t\t\t\t   struct netpoll_info *ni)\n{\n\tstruct net_device *master = dsa_slave_to_master(dev);\n\tstruct dsa_slave_priv *p = netdev_priv(dev);\n\tstruct netpoll *netpoll;\n\tint err = 0;\n\n\tnetpoll = kzalloc(sizeof(*netpoll), GFP_KERNEL);\n\tif (!netpoll)\n\t\treturn -ENOMEM;\n\n\terr = __netpoll_setup(netpoll, master);\n\tif (err) {\n\t\tkfree(netpoll);\n\t\tgoto out;\n\t}\n\n\tp->netpoll = netpoll;\nout:\n\treturn err;\n}\n\nstatic void dsa_slave_netpoll_cleanup(struct net_device *dev)\n{\n\tstruct dsa_slave_priv *p = netdev_priv(dev);\n\tstruct netpoll *netpoll = p->netpoll;\n\n\tif (!netpoll)\n\t\treturn;\n\n\tp->netpoll = NULL;\n\n\t__netpoll_free(netpoll);\n}\n\nstatic void dsa_slave_poll_controller(struct net_device *dev)\n{\n}\n#endif\n\nstatic struct dsa_mall_tc_entry *\ndsa_slave_mall_tc_entry_find(struct net_device *dev, unsigned long cookie)\n{\n\tstruct dsa_slave_priv *p = netdev_priv(dev);\n\tstruct dsa_mall_tc_entry *mall_tc_entry;\n\n\tlist_for_each_entry(mall_tc_entry, &p->mall_tc_list, list)\n\t\tif (mall_tc_entry->cookie == cookie)\n\t\t\treturn mall_tc_entry;\n\n\treturn NULL;\n}\n\nstatic int\ndsa_slave_add_cls_matchall_mirred(struct net_device *dev,\n\t\t\t\t  struct tc_cls_matchall_offload *cls,\n\t\t\t\t  bool ingress)\n{\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_slave_priv *p = netdev_priv(dev);\n\tstruct dsa_mall_mirror_tc_entry *mirror;\n\tstruct dsa_mall_tc_entry *mall_tc_entry;\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct flow_action_entry *act;\n\tstruct dsa_port *to_dp;\n\tint err;\n\n\tif (!ds->ops->port_mirror_add)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!flow_action_basic_hw_stats_check(&cls->rule->action,\n\t\t\t\t\t      cls->common.extack))\n\t\treturn -EOPNOTSUPP;\n\n\tact = &cls->rule->action.entries[0];\n\n\tif (!act->dev)\n\t\treturn -EINVAL;\n\n\tif (!dsa_slave_dev_check(act->dev))\n\t\treturn -EOPNOTSUPP;\n\n\tmall_tc_entry = kzalloc(sizeof(*mall_tc_entry), GFP_KERNEL);\n\tif (!mall_tc_entry)\n\t\treturn -ENOMEM;\n\n\tmall_tc_entry->cookie = cls->cookie;\n\tmall_tc_entry->type = DSA_PORT_MALL_MIRROR;\n\tmirror = &mall_tc_entry->mirror;\n\n\tto_dp = dsa_slave_to_port(act->dev);\n\n\tmirror->to_local_port = to_dp->index;\n\tmirror->ingress = ingress;\n\n\terr = ds->ops->port_mirror_add(ds, dp->index, mirror, ingress, extack);\n\tif (err) {\n\t\tkfree(mall_tc_entry);\n\t\treturn err;\n\t}\n\n\tlist_add_tail(&mall_tc_entry->list, &p->mall_tc_list);\n\n\treturn err;\n}\n\nstatic int\ndsa_slave_add_cls_matchall_police(struct net_device *dev,\n\t\t\t\t  struct tc_cls_matchall_offload *cls,\n\t\t\t\t  bool ingress)\n{\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_slave_priv *p = netdev_priv(dev);\n\tstruct dsa_mall_policer_tc_entry *policer;\n\tstruct dsa_mall_tc_entry *mall_tc_entry;\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct flow_action_entry *act;\n\tint err;\n\n\tif (!ds->ops->port_policer_add) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Policing offload not implemented\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!ingress) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Only supported on ingress qdisc\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!flow_action_basic_hw_stats_check(&cls->rule->action,\n\t\t\t\t\t      cls->common.extack))\n\t\treturn -EOPNOTSUPP;\n\n\tlist_for_each_entry(mall_tc_entry, &p->mall_tc_list, list) {\n\t\tif (mall_tc_entry->type == DSA_PORT_MALL_POLICER) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Only one port policer allowed\");\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\tact = &cls->rule->action.entries[0];\n\n\tmall_tc_entry = kzalloc(sizeof(*mall_tc_entry), GFP_KERNEL);\n\tif (!mall_tc_entry)\n\t\treturn -ENOMEM;\n\n\tmall_tc_entry->cookie = cls->cookie;\n\tmall_tc_entry->type = DSA_PORT_MALL_POLICER;\n\tpolicer = &mall_tc_entry->policer;\n\tpolicer->rate_bytes_per_sec = act->police.rate_bytes_ps;\n\tpolicer->burst = act->police.burst;\n\n\terr = ds->ops->port_policer_add(ds, dp->index, policer);\n\tif (err) {\n\t\tkfree(mall_tc_entry);\n\t\treturn err;\n\t}\n\n\tlist_add_tail(&mall_tc_entry->list, &p->mall_tc_list);\n\n\treturn err;\n}\n\nstatic int dsa_slave_add_cls_matchall(struct net_device *dev,\n\t\t\t\t      struct tc_cls_matchall_offload *cls,\n\t\t\t\t      bool ingress)\n{\n\tint err = -EOPNOTSUPP;\n\n\tif (cls->common.protocol == htons(ETH_P_ALL) &&\n\t    flow_offload_has_one_action(&cls->rule->action) &&\n\t    cls->rule->action.entries[0].id == FLOW_ACTION_MIRRED)\n\t\terr = dsa_slave_add_cls_matchall_mirred(dev, cls, ingress);\n\telse if (flow_offload_has_one_action(&cls->rule->action) &&\n\t\t cls->rule->action.entries[0].id == FLOW_ACTION_POLICE)\n\t\terr = dsa_slave_add_cls_matchall_police(dev, cls, ingress);\n\n\treturn err;\n}\n\nstatic void dsa_slave_del_cls_matchall(struct net_device *dev,\n\t\t\t\t       struct tc_cls_matchall_offload *cls)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_mall_tc_entry *mall_tc_entry;\n\tstruct dsa_switch *ds = dp->ds;\n\n\tmall_tc_entry = dsa_slave_mall_tc_entry_find(dev, cls->cookie);\n\tif (!mall_tc_entry)\n\t\treturn;\n\n\tlist_del(&mall_tc_entry->list);\n\n\tswitch (mall_tc_entry->type) {\n\tcase DSA_PORT_MALL_MIRROR:\n\t\tif (ds->ops->port_mirror_del)\n\t\t\tds->ops->port_mirror_del(ds, dp->index,\n\t\t\t\t\t\t &mall_tc_entry->mirror);\n\t\tbreak;\n\tcase DSA_PORT_MALL_POLICER:\n\t\tif (ds->ops->port_policer_del)\n\t\t\tds->ops->port_policer_del(ds, dp->index);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tkfree(mall_tc_entry);\n}\n\nstatic int dsa_slave_setup_tc_cls_matchall(struct net_device *dev,\n\t\t\t\t\t   struct tc_cls_matchall_offload *cls,\n\t\t\t\t\t   bool ingress)\n{\n\tif (cls->common.chain_index)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cls->command) {\n\tcase TC_CLSMATCHALL_REPLACE:\n\t\treturn dsa_slave_add_cls_matchall(dev, cls, ingress);\n\tcase TC_CLSMATCHALL_DESTROY:\n\t\tdsa_slave_del_cls_matchall(dev, cls);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dsa_slave_add_cls_flower(struct net_device *dev,\n\t\t\t\t    struct flow_cls_offload *cls,\n\t\t\t\t    bool ingress)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tint port = dp->index;\n\n\tif (!ds->ops->cls_flower_add)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->cls_flower_add(ds, port, cls, ingress);\n}\n\nstatic int dsa_slave_del_cls_flower(struct net_device *dev,\n\t\t\t\t    struct flow_cls_offload *cls,\n\t\t\t\t    bool ingress)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tint port = dp->index;\n\n\tif (!ds->ops->cls_flower_del)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->cls_flower_del(ds, port, cls, ingress);\n}\n\nstatic int dsa_slave_stats_cls_flower(struct net_device *dev,\n\t\t\t\t      struct flow_cls_offload *cls,\n\t\t\t\t      bool ingress)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tint port = dp->index;\n\n\tif (!ds->ops->cls_flower_stats)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->cls_flower_stats(ds, port, cls, ingress);\n}\n\nstatic int dsa_slave_setup_tc_cls_flower(struct net_device *dev,\n\t\t\t\t\t struct flow_cls_offload *cls,\n\t\t\t\t\t bool ingress)\n{\n\tswitch (cls->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn dsa_slave_add_cls_flower(dev, cls, ingress);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn dsa_slave_del_cls_flower(dev, cls, ingress);\n\tcase FLOW_CLS_STATS:\n\t\treturn dsa_slave_stats_cls_flower(dev, cls, ingress);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dsa_slave_setup_tc_block_cb(enum tc_setup_type type, void *type_data,\n\t\t\t\t       void *cb_priv, bool ingress)\n{\n\tstruct net_device *dev = cb_priv;\n\n\tif (!tc_can_offload(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSMATCHALL:\n\t\treturn dsa_slave_setup_tc_cls_matchall(dev, type_data, ingress);\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn dsa_slave_setup_tc_cls_flower(dev, type_data, ingress);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dsa_slave_setup_tc_block_cb_ig(enum tc_setup_type type,\n\t\t\t\t\t  void *type_data, void *cb_priv)\n{\n\treturn dsa_slave_setup_tc_block_cb(type, type_data, cb_priv, true);\n}\n\nstatic int dsa_slave_setup_tc_block_cb_eg(enum tc_setup_type type,\n\t\t\t\t\t  void *type_data, void *cb_priv)\n{\n\treturn dsa_slave_setup_tc_block_cb(type, type_data, cb_priv, false);\n}\n\nstatic LIST_HEAD(dsa_slave_block_cb_list);\n\nstatic int dsa_slave_setup_tc_block(struct net_device *dev,\n\t\t\t\t    struct flow_block_offload *f)\n{\n\tstruct flow_block_cb *block_cb;\n\tflow_setup_cb_t *cb;\n\n\tif (f->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS)\n\t\tcb = dsa_slave_setup_tc_block_cb_ig;\n\telse if (f->binder_type == FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS)\n\t\tcb = dsa_slave_setup_tc_block_cb_eg;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tf->driver_block_list = &dsa_slave_block_cb_list;\n\n\tswitch (f->command) {\n\tcase FLOW_BLOCK_BIND:\n\t\tif (flow_block_cb_is_busy(cb, dev, &dsa_slave_block_cb_list))\n\t\t\treturn -EBUSY;\n\n\t\tblock_cb = flow_block_cb_alloc(cb, dev, dev, NULL);\n\t\tif (IS_ERR(block_cb))\n\t\t\treturn PTR_ERR(block_cb);\n\n\t\tflow_block_cb_add(block_cb, f);\n\t\tlist_add_tail(&block_cb->driver_list, &dsa_slave_block_cb_list);\n\t\treturn 0;\n\tcase FLOW_BLOCK_UNBIND:\n\t\tblock_cb = flow_block_cb_lookup(f->block, cb, dev);\n\t\tif (!block_cb)\n\t\t\treturn -ENOENT;\n\n\t\tflow_block_cb_remove(block_cb, f);\n\t\tlist_del(&block_cb->driver_list);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dsa_slave_setup_ft_block(struct dsa_switch *ds, int port,\n\t\t\t\t    void *type_data)\n{\n\tstruct net_device *master = dsa_port_to_master(dsa_to_port(ds, port));\n\n\tif (!master->netdev_ops->ndo_setup_tc)\n\t\treturn -EOPNOTSUPP;\n\n\treturn master->netdev_ops->ndo_setup_tc(master, TC_SETUP_FT, type_data);\n}\n\nstatic int dsa_slave_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\t      void *type_data)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tswitch (type) {\n\tcase TC_SETUP_BLOCK:\n\t\treturn dsa_slave_setup_tc_block(dev, type_data);\n\tcase TC_SETUP_FT:\n\t\treturn dsa_slave_setup_ft_block(ds, dp->index, type_data);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!ds->ops->port_setup_tc)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->port_setup_tc(ds, dp->index, type, type_data);\n}\n\nstatic int dsa_slave_get_rxnfc(struct net_device *dev,\n\t\t\t       struct ethtool_rxnfc *nfc, u32 *rule_locs)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->get_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->get_rxnfc(ds, dp->index, nfc, rule_locs);\n}\n\nstatic int dsa_slave_set_rxnfc(struct net_device *dev,\n\t\t\t       struct ethtool_rxnfc *nfc)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->set_rxnfc)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->set_rxnfc(ds, dp->index, nfc);\n}\n\nstatic int dsa_slave_get_ts_info(struct net_device *dev,\n\t\t\t\t struct ethtool_ts_info *ts)\n{\n\tstruct dsa_slave_priv *p = netdev_priv(dev);\n\tstruct dsa_switch *ds = p->dp->ds;\n\n\tif (!ds->ops->get_ts_info)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->get_ts_info(ds, p->dp->index, ts);\n}\n\nstatic int dsa_slave_vlan_rx_add_vid(struct net_device *dev, __be16 proto,\n\t\t\t\t     u16 vid)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct switchdev_obj_port_vlan vlan = {\n\t\t.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,\n\t\t.vid = vid,\n\t\t \n\t\t.flags = 0,\n\t};\n\tstruct netlink_ext_ack extack = {0};\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct netdev_hw_addr *ha;\n\tstruct dsa_vlan *v;\n\tint ret;\n\n\t \n\tret = dsa_port_vlan_add(dp, &vlan, &extack);\n\tif (ret) {\n\t\tif (extack._msg)\n\t\t\tnetdev_err(dev, \"%s\\n\", extack._msg);\n\t\treturn ret;\n\t}\n\n\t \n\tret = dsa_port_host_vlan_add(dp, &vlan, &extack);\n\tif (ret) {\n\t\tif (extack._msg)\n\t\t\tnetdev_err(dev, \"CPU port %d: %s\\n\", dp->cpu_dp->index,\n\t\t\t\t   extack._msg);\n\t\treturn ret;\n\t}\n\n\tif (!dsa_switch_supports_uc_filtering(ds) &&\n\t    !dsa_switch_supports_mc_filtering(ds))\n\t\treturn 0;\n\n\tv = kzalloc(sizeof(*v), GFP_KERNEL);\n\tif (!v) {\n\t\tret = -ENOMEM;\n\t\tgoto rollback;\n\t}\n\n\tnetif_addr_lock_bh(dev);\n\n\tv->vid = vid;\n\tlist_add_tail(&v->list, &dp->user_vlans);\n\n\tif (dsa_switch_supports_mc_filtering(ds)) {\n\t\tnetdev_for_each_synced_mc_addr(ha, dev) {\n\t\t\tdsa_slave_schedule_standalone_work(dev, DSA_MC_ADD,\n\t\t\t\t\t\t\t   ha->addr, vid);\n\t\t}\n\t}\n\n\tif (dsa_switch_supports_uc_filtering(ds)) {\n\t\tnetdev_for_each_synced_uc_addr(ha, dev) {\n\t\t\tdsa_slave_schedule_standalone_work(dev, DSA_UC_ADD,\n\t\t\t\t\t\t\t   ha->addr, vid);\n\t\t}\n\t}\n\n\tnetif_addr_unlock_bh(dev);\n\n\tdsa_flush_workqueue();\n\n\treturn 0;\n\nrollback:\n\tdsa_port_host_vlan_del(dp, &vlan);\n\tdsa_port_vlan_del(dp, &vlan);\n\n\treturn ret;\n}\n\nstatic int dsa_slave_vlan_rx_kill_vid(struct net_device *dev, __be16 proto,\n\t\t\t\t      u16 vid)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct switchdev_obj_port_vlan vlan = {\n\t\t.vid = vid,\n\t\t \n\t\t.flags = 0,\n\t};\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct netdev_hw_addr *ha;\n\tstruct dsa_vlan *v;\n\tint err;\n\n\terr = dsa_port_vlan_del(dp, &vlan);\n\tif (err)\n\t\treturn err;\n\n\terr = dsa_port_host_vlan_del(dp, &vlan);\n\tif (err)\n\t\treturn err;\n\n\tif (!dsa_switch_supports_uc_filtering(ds) &&\n\t    !dsa_switch_supports_mc_filtering(ds))\n\t\treturn 0;\n\n\tnetif_addr_lock_bh(dev);\n\n\tv = dsa_vlan_find(&dp->user_vlans, &vlan);\n\tif (!v) {\n\t\tnetif_addr_unlock_bh(dev);\n\t\treturn -ENOENT;\n\t}\n\n\tlist_del(&v->list);\n\tkfree(v);\n\n\tif (dsa_switch_supports_mc_filtering(ds)) {\n\t\tnetdev_for_each_synced_mc_addr(ha, dev) {\n\t\t\tdsa_slave_schedule_standalone_work(dev, DSA_MC_DEL,\n\t\t\t\t\t\t\t   ha->addr, vid);\n\t\t}\n\t}\n\n\tif (dsa_switch_supports_uc_filtering(ds)) {\n\t\tnetdev_for_each_synced_uc_addr(ha, dev) {\n\t\t\tdsa_slave_schedule_standalone_work(dev, DSA_UC_DEL,\n\t\t\t\t\t\t\t   ha->addr, vid);\n\t\t}\n\t}\n\n\tnetif_addr_unlock_bh(dev);\n\n\tdsa_flush_workqueue();\n\n\treturn 0;\n}\n\nstatic int dsa_slave_restore_vlan(struct net_device *vdev, int vid, void *arg)\n{\n\t__be16 proto = vdev ? vlan_dev_vlan_proto(vdev) : htons(ETH_P_8021Q);\n\n\treturn dsa_slave_vlan_rx_add_vid(arg, proto, vid);\n}\n\nstatic int dsa_slave_clear_vlan(struct net_device *vdev, int vid, void *arg)\n{\n\t__be16 proto = vdev ? vlan_dev_vlan_proto(vdev) : htons(ETH_P_8021Q);\n\n\treturn dsa_slave_vlan_rx_kill_vid(arg, proto, vid);\n}\n\n \nint dsa_slave_manage_vlan_filtering(struct net_device *slave,\n\t\t\t\t    bool vlan_filtering)\n{\n\tint err;\n\n\tif (vlan_filtering) {\n\t\tslave->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n\n\t\terr = vlan_for_each(slave, dsa_slave_restore_vlan, slave);\n\t\tif (err) {\n\t\t\tvlan_for_each(slave, dsa_slave_clear_vlan, slave);\n\t\t\tslave->features &= ~NETIF_F_HW_VLAN_CTAG_FILTER;\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\terr = vlan_for_each(slave, dsa_slave_clear_vlan, slave);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tslave->features &= ~NETIF_F_HW_VLAN_CTAG_FILTER;\n\t}\n\n\treturn 0;\n}\n\nstruct dsa_hw_port {\n\tstruct list_head list;\n\tstruct net_device *dev;\n\tint old_mtu;\n};\n\nstatic int dsa_hw_port_list_set_mtu(struct list_head *hw_port_list, int mtu)\n{\n\tconst struct dsa_hw_port *p;\n\tint err;\n\n\tlist_for_each_entry(p, hw_port_list, list) {\n\t\tif (p->dev->mtu == mtu)\n\t\t\tcontinue;\n\n\t\terr = dev_set_mtu(p->dev, mtu);\n\t\tif (err)\n\t\t\tgoto rollback;\n\t}\n\n\treturn 0;\n\nrollback:\n\tlist_for_each_entry_continue_reverse(p, hw_port_list, list) {\n\t\tif (p->dev->mtu == p->old_mtu)\n\t\t\tcontinue;\n\n\t\tif (dev_set_mtu(p->dev, p->old_mtu))\n\t\t\tnetdev_err(p->dev, \"Failed to restore MTU\\n\");\n\t}\n\n\treturn err;\n}\n\nstatic void dsa_hw_port_list_free(struct list_head *hw_port_list)\n{\n\tstruct dsa_hw_port *p, *n;\n\n\tlist_for_each_entry_safe(p, n, hw_port_list, list)\n\t\tkfree(p);\n}\n\n \nstatic void dsa_bridge_mtu_normalization(struct dsa_port *dp)\n{\n\tstruct list_head hw_port_list;\n\tstruct dsa_switch_tree *dst;\n\tint min_mtu = ETH_MAX_MTU;\n\tstruct dsa_port *other_dp;\n\tint err;\n\n\tif (!dp->ds->mtu_enforcement_ingress)\n\t\treturn;\n\n\tif (!dp->bridge)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&hw_port_list);\n\n\t \n\tlist_for_each_entry(dst, &dsa_tree_list, list) {\n\t\tlist_for_each_entry(other_dp, &dst->ports, list) {\n\t\t\tstruct dsa_hw_port *hw_port;\n\t\t\tstruct net_device *slave;\n\n\t\t\tif (other_dp->type != DSA_PORT_TYPE_USER)\n\t\t\t\tcontinue;\n\n\t\t\tif (!dsa_port_bridge_same(dp, other_dp))\n\t\t\t\tcontinue;\n\n\t\t\tif (!other_dp->ds->mtu_enforcement_ingress)\n\t\t\t\tcontinue;\n\n\t\t\tslave = other_dp->slave;\n\n\t\t\tif (min_mtu > slave->mtu)\n\t\t\t\tmin_mtu = slave->mtu;\n\n\t\t\thw_port = kzalloc(sizeof(*hw_port), GFP_KERNEL);\n\t\t\tif (!hw_port)\n\t\t\t\tgoto out;\n\n\t\t\thw_port->dev = slave;\n\t\t\thw_port->old_mtu = slave->mtu;\n\n\t\t\tlist_add(&hw_port->list, &hw_port_list);\n\t\t}\n\t}\n\n\t \n\terr = dsa_hw_port_list_set_mtu(&hw_port_list, dp->slave->mtu);\n\tif (!err)\n\t\tgoto out;\n\n\t \n\tdsa_hw_port_list_set_mtu(&hw_port_list, min_mtu);\n\nout:\n\tdsa_hw_port_list_free(&hw_port_list);\n}\n\nint dsa_slave_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct net_device *master = dsa_slave_to_master(dev);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_port *cpu_dp = dp->cpu_dp;\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_port *other_dp;\n\tint largest_mtu = 0;\n\tint new_master_mtu;\n\tint old_master_mtu;\n\tint mtu_limit;\n\tint overhead;\n\tint cpu_mtu;\n\tint err;\n\n\tif (!ds->ops->port_change_mtu)\n\t\treturn -EOPNOTSUPP;\n\n\tdsa_tree_for_each_user_port(other_dp, ds->dst) {\n\t\tint slave_mtu;\n\n\t\t \n\t\tif (!other_dp->slave)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (dp == other_dp)\n\t\t\tslave_mtu = new_mtu;\n\t\telse\n\t\t\tslave_mtu = other_dp->slave->mtu;\n\n\t\tif (largest_mtu < slave_mtu)\n\t\t\tlargest_mtu = slave_mtu;\n\t}\n\n\toverhead = dsa_tag_protocol_overhead(cpu_dp->tag_ops);\n\tmtu_limit = min_t(int, master->max_mtu, dev->max_mtu + overhead);\n\told_master_mtu = master->mtu;\n\tnew_master_mtu = largest_mtu + overhead;\n\tif (new_master_mtu > mtu_limit)\n\t\treturn -ERANGE;\n\n\t \n\tcpu_mtu = largest_mtu;\n\n\t \n\tif (new_master_mtu != old_master_mtu) {\n\t\terr = dev_set_mtu(master, new_master_mtu);\n\t\tif (err < 0)\n\t\t\tgoto out_master_failed;\n\n\t\t \n\t\terr = dsa_port_mtu_change(cpu_dp, cpu_mtu);\n\t\tif (err)\n\t\t\tgoto out_cpu_failed;\n\t}\n\n\terr = ds->ops->port_change_mtu(ds, dp->index, new_mtu);\n\tif (err)\n\t\tgoto out_port_failed;\n\n\tdev->mtu = new_mtu;\n\n\tdsa_bridge_mtu_normalization(dp);\n\n\treturn 0;\n\nout_port_failed:\n\tif (new_master_mtu != old_master_mtu)\n\t\tdsa_port_mtu_change(cpu_dp, old_master_mtu - overhead);\nout_cpu_failed:\n\tif (new_master_mtu != old_master_mtu)\n\t\tdev_set_mtu(master, old_master_mtu);\nout_master_failed:\n\treturn err;\n}\n\nstatic int __maybe_unused\ndsa_slave_dcbnl_set_default_prio(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tunsigned long mask, new_prio;\n\tint err, port = dp->index;\n\n\tif (!ds->ops->port_set_default_prio)\n\t\treturn -EOPNOTSUPP;\n\n\terr = dcb_ieee_setapp(dev, app);\n\tif (err)\n\t\treturn err;\n\n\tmask = dcb_ieee_getapp_mask(dev, app);\n\tnew_prio = __fls(mask);\n\n\terr = ds->ops->port_set_default_prio(ds, port, new_prio);\n\tif (err) {\n\t\tdcb_ieee_delapp(dev, app);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused\ndsa_slave_dcbnl_add_dscp_prio(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tunsigned long mask, new_prio;\n\tint err, port = dp->index;\n\tu8 dscp = app->protocol;\n\n\tif (!ds->ops->port_add_dscp_prio)\n\t\treturn -EOPNOTSUPP;\n\n\tif (dscp >= 64) {\n\t\tnetdev_err(dev, \"DSCP APP entry with protocol value %u is invalid\\n\",\n\t\t\t   dscp);\n\t\treturn -EINVAL;\n\t}\n\n\terr = dcb_ieee_setapp(dev, app);\n\tif (err)\n\t\treturn err;\n\n\tmask = dcb_ieee_getapp_mask(dev, app);\n\tnew_prio = __fls(mask);\n\n\terr = ds->ops->port_add_dscp_prio(ds, port, dscp, new_prio);\n\tif (err) {\n\t\tdcb_ieee_delapp(dev, app);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dsa_slave_dcbnl_ieee_setapp(struct net_device *dev,\n\t\t\t\t\t\t      struct dcb_app *app)\n{\n\tswitch (app->selector) {\n\tcase IEEE_8021QAZ_APP_SEL_ETHERTYPE:\n\t\tswitch (app->protocol) {\n\t\tcase 0:\n\t\t\treturn dsa_slave_dcbnl_set_default_prio(dev, app);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase IEEE_8021QAZ_APP_SEL_DSCP:\n\t\treturn dsa_slave_dcbnl_add_dscp_prio(dev, app);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int __maybe_unused\ndsa_slave_dcbnl_del_default_prio(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tunsigned long mask, new_prio;\n\tint err, port = dp->index;\n\n\tif (!ds->ops->port_set_default_prio)\n\t\treturn -EOPNOTSUPP;\n\n\terr = dcb_ieee_delapp(dev, app);\n\tif (err)\n\t\treturn err;\n\n\tmask = dcb_ieee_getapp_mask(dev, app);\n\tnew_prio = mask ? __fls(mask) : 0;\n\n\terr = ds->ops->port_set_default_prio(ds, port, new_prio);\n\tif (err) {\n\t\tdcb_ieee_setapp(dev, app);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused\ndsa_slave_dcbnl_del_dscp_prio(struct net_device *dev, struct dcb_app *app)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tint err, port = dp->index;\n\tu8 dscp = app->protocol;\n\n\tif (!ds->ops->port_del_dscp_prio)\n\t\treturn -EOPNOTSUPP;\n\n\terr = dcb_ieee_delapp(dev, app);\n\tif (err)\n\t\treturn err;\n\n\terr = ds->ops->port_del_dscp_prio(ds, port, dscp, app->priority);\n\tif (err) {\n\t\tdcb_ieee_setapp(dev, app);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dsa_slave_dcbnl_ieee_delapp(struct net_device *dev,\n\t\t\t\t\t\t      struct dcb_app *app)\n{\n\tswitch (app->selector) {\n\tcase IEEE_8021QAZ_APP_SEL_ETHERTYPE:\n\t\tswitch (app->protocol) {\n\t\tcase 0:\n\t\t\treturn dsa_slave_dcbnl_del_default_prio(dev, app);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase IEEE_8021QAZ_APP_SEL_DSCP:\n\t\treturn dsa_slave_dcbnl_del_dscp_prio(dev, app);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic int dsa_slave_dcbnl_init(struct net_device *dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tint port = dp->index;\n\tint err;\n\n\tif (ds->ops->port_get_default_prio) {\n\t\tint prio = ds->ops->port_get_default_prio(ds, port);\n\t\tstruct dcb_app app = {\n\t\t\t.selector = IEEE_8021QAZ_APP_SEL_ETHERTYPE,\n\t\t\t.protocol = 0,\n\t\t\t.priority = prio,\n\t\t};\n\n\t\tif (prio < 0)\n\t\t\treturn prio;\n\n\t\terr = dcb_ieee_setapp(dev, &app);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (ds->ops->port_get_dscp_prio) {\n\t\tint protocol;\n\n\t\tfor (protocol = 0; protocol < 64; protocol++) {\n\t\t\tstruct dcb_app app = {\n\t\t\t\t.selector = IEEE_8021QAZ_APP_SEL_DSCP,\n\t\t\t\t.protocol = protocol,\n\t\t\t};\n\t\t\tint prio;\n\n\t\t\tprio = ds->ops->port_get_dscp_prio(ds, port, protocol);\n\t\t\tif (prio == -EOPNOTSUPP)\n\t\t\t\tcontinue;\n\t\t\tif (prio < 0)\n\t\t\t\treturn prio;\n\n\t\t\tapp.priority = prio;\n\n\t\t\terr = dcb_ieee_setapp(dev, &app);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops dsa_slave_ethtool_ops = {\n\t.get_drvinfo\t\t= dsa_slave_get_drvinfo,\n\t.get_regs_len\t\t= dsa_slave_get_regs_len,\n\t.get_regs\t\t= dsa_slave_get_regs,\n\t.nway_reset\t\t= dsa_slave_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_eeprom_len\t\t= dsa_slave_get_eeprom_len,\n\t.get_eeprom\t\t= dsa_slave_get_eeprom,\n\t.set_eeprom\t\t= dsa_slave_set_eeprom,\n\t.get_strings\t\t= dsa_slave_get_strings,\n\t.get_ethtool_stats\t= dsa_slave_get_ethtool_stats,\n\t.get_sset_count\t\t= dsa_slave_get_sset_count,\n\t.get_eth_phy_stats\t= dsa_slave_get_eth_phy_stats,\n\t.get_eth_mac_stats\t= dsa_slave_get_eth_mac_stats,\n\t.get_eth_ctrl_stats\t= dsa_slave_get_eth_ctrl_stats,\n\t.get_rmon_stats\t\t= dsa_slave_get_rmon_stats,\n\t.set_wol\t\t= dsa_slave_set_wol,\n\t.get_wol\t\t= dsa_slave_get_wol,\n\t.set_eee\t\t= dsa_slave_set_eee,\n\t.get_eee\t\t= dsa_slave_get_eee,\n\t.get_link_ksettings\t= dsa_slave_get_link_ksettings,\n\t.set_link_ksettings\t= dsa_slave_set_link_ksettings,\n\t.get_pause_stats\t= dsa_slave_get_pause_stats,\n\t.get_pauseparam\t\t= dsa_slave_get_pauseparam,\n\t.set_pauseparam\t\t= dsa_slave_set_pauseparam,\n\t.get_rxnfc\t\t= dsa_slave_get_rxnfc,\n\t.set_rxnfc\t\t= dsa_slave_set_rxnfc,\n\t.get_ts_info\t\t= dsa_slave_get_ts_info,\n\t.self_test\t\t= dsa_slave_net_selftest,\n\t.get_mm\t\t\t= dsa_slave_get_mm,\n\t.set_mm\t\t\t= dsa_slave_set_mm,\n\t.get_mm_stats\t\t= dsa_slave_get_mm_stats,\n};\n\nstatic const struct dcbnl_rtnl_ops __maybe_unused dsa_slave_dcbnl_ops = {\n\t.ieee_setapp\t\t= dsa_slave_dcbnl_ieee_setapp,\n\t.ieee_delapp\t\t= dsa_slave_dcbnl_ieee_delapp,\n};\n\nstatic void dsa_slave_get_stats64(struct net_device *dev,\n\t\t\t\t  struct rtnl_link_stats64 *s)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->get_stats64)\n\t\tds->ops->get_stats64(ds, dp->index, s);\n\telse\n\t\tdev_get_tstats64(dev, s);\n}\n\nstatic int dsa_slave_fill_forward_path(struct net_device_path_ctx *ctx,\n\t\t\t\t       struct net_device_path *path)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(ctx->dev);\n\tstruct net_device *master = dsa_port_to_master(dp);\n\tstruct dsa_port *cpu_dp = dp->cpu_dp;\n\n\tpath->dev = ctx->dev;\n\tpath->type = DEV_PATH_DSA;\n\tpath->dsa.proto = cpu_dp->tag_ops->proto;\n\tpath->dsa.port = dp->index;\n\tctx->dev = master;\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops dsa_slave_netdev_ops = {\n\t.ndo_open\t \t= dsa_slave_open,\n\t.ndo_stop\t\t= dsa_slave_close,\n\t.ndo_start_xmit\t\t= dsa_slave_xmit,\n\t.ndo_change_rx_flags\t= dsa_slave_change_rx_flags,\n\t.ndo_set_rx_mode\t= dsa_slave_set_rx_mode,\n\t.ndo_set_mac_address\t= dsa_slave_set_mac_address,\n\t.ndo_fdb_dump\t\t= dsa_slave_fdb_dump,\n\t.ndo_eth_ioctl\t\t= dsa_slave_ioctl,\n\t.ndo_get_iflink\t\t= dsa_slave_get_iflink,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_netpoll_setup\t= dsa_slave_netpoll_setup,\n\t.ndo_netpoll_cleanup\t= dsa_slave_netpoll_cleanup,\n\t.ndo_poll_controller\t= dsa_slave_poll_controller,\n#endif\n\t.ndo_setup_tc\t\t= dsa_slave_setup_tc,\n\t.ndo_get_stats64\t= dsa_slave_get_stats64,\n\t.ndo_vlan_rx_add_vid\t= dsa_slave_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= dsa_slave_vlan_rx_kill_vid,\n\t.ndo_change_mtu\t\t= dsa_slave_change_mtu,\n\t.ndo_fill_forward_path\t= dsa_slave_fill_forward_path,\n};\n\nstatic struct device_type dsa_type = {\n\t.name\t= \"dsa\",\n};\n\nvoid dsa_port_phylink_mac_change(struct dsa_switch *ds, int port, bool up)\n{\n\tconst struct dsa_port *dp = dsa_to_port(ds, port);\n\n\tif (dp->pl)\n\t\tphylink_mac_change(dp->pl, up);\n}\nEXPORT_SYMBOL_GPL(dsa_port_phylink_mac_change);\n\nstatic void dsa_slave_phylink_fixed_state(struct phylink_config *config,\n\t\t\t\t\t  struct phylink_link_state *state)\n{\n\tstruct dsa_port *dp = container_of(config, struct dsa_port, pl_config);\n\tstruct dsa_switch *ds = dp->ds;\n\n\t \n\tds->ops->phylink_fixed_state(ds, dp->index, state);\n}\n\n \nstatic int dsa_slave_phy_connect(struct net_device *slave_dev, int addr,\n\t\t\t\t u32 flags)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(slave_dev);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tslave_dev->phydev = mdiobus_get_phy(ds->slave_mii_bus, addr);\n\tif (!slave_dev->phydev) {\n\t\tnetdev_err(slave_dev, \"no phy at %d\\n\", addr);\n\t\treturn -ENODEV;\n\t}\n\n\tslave_dev->phydev->dev_flags |= flags;\n\n\treturn phylink_connect_phy(dp->pl, slave_dev->phydev);\n}\n\nstatic int dsa_slave_phy_setup(struct net_device *slave_dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(slave_dev);\n\tstruct device_node *port_dn = dp->dn;\n\tstruct dsa_switch *ds = dp->ds;\n\tu32 phy_flags = 0;\n\tint ret;\n\n\tdp->pl_config.dev = &slave_dev->dev;\n\tdp->pl_config.type = PHYLINK_NETDEV;\n\n\t \n\tif (ds->ops->phylink_fixed_state) {\n\t\tdp->pl_config.get_fixed_state = dsa_slave_phylink_fixed_state;\n\t\tdp->pl_config.poll_fixed_state = true;\n\t}\n\n\tret = dsa_port_phylink_create(dp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ds->ops->get_phy_flags)\n\t\tphy_flags = ds->ops->get_phy_flags(ds, dp->index);\n\n\tret = phylink_of_phy_connect(dp->pl, port_dn, phy_flags);\n\tif (ret == -ENODEV && ds->slave_mii_bus) {\n\t\t \n\t\tret = dsa_slave_phy_connect(slave_dev, dp->index, phy_flags);\n\t}\n\tif (ret) {\n\t\tnetdev_err(slave_dev, \"failed to connect to PHY: %pe\\n\",\n\t\t\t   ERR_PTR(ret));\n\t\tdsa_port_phylink_destroy(dp);\n\t}\n\n\treturn ret;\n}\n\nvoid dsa_slave_setup_tagger(struct net_device *slave)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(slave);\n\tstruct net_device *master = dsa_port_to_master(dp);\n\tstruct dsa_slave_priv *p = netdev_priv(slave);\n\tconst struct dsa_port *cpu_dp = dp->cpu_dp;\n\tconst struct dsa_switch *ds = dp->ds;\n\n\tslave->needed_headroom = cpu_dp->tag_ops->needed_headroom;\n\tslave->needed_tailroom = cpu_dp->tag_ops->needed_tailroom;\n\t \n\tslave->needed_headroom += master->needed_headroom;\n\tslave->needed_tailroom += master->needed_tailroom;\n\n\tp->xmit = cpu_dp->tag_ops->xmit;\n\n\tslave->features = master->vlan_features | NETIF_F_HW_TC;\n\tslave->hw_features |= NETIF_F_HW_TC;\n\tslave->features |= NETIF_F_LLTX;\n\tif (slave->needed_tailroom)\n\t\tslave->features &= ~(NETIF_F_SG | NETIF_F_FRAGLIST);\n\tif (ds->needs_standalone_vlan_filtering)\n\t\tslave->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n}\n\nint dsa_slave_suspend(struct net_device *slave_dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(slave_dev);\n\n\tif (!netif_running(slave_dev))\n\t\treturn 0;\n\n\tnetif_device_detach(slave_dev);\n\n\trtnl_lock();\n\tphylink_stop(dp->pl);\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nint dsa_slave_resume(struct net_device *slave_dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(slave_dev);\n\n\tif (!netif_running(slave_dev))\n\t\treturn 0;\n\n\tnetif_device_attach(slave_dev);\n\n\trtnl_lock();\n\tphylink_start(dp->pl);\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nint dsa_slave_create(struct dsa_port *port)\n{\n\tstruct net_device *master = dsa_port_to_master(port);\n\tstruct dsa_switch *ds = port->ds;\n\tstruct net_device *slave_dev;\n\tstruct dsa_slave_priv *p;\n\tconst char *name;\n\tint assign_type;\n\tint ret;\n\n\tif (!ds->num_tx_queues)\n\t\tds->num_tx_queues = 1;\n\n\tif (port->name) {\n\t\tname = port->name;\n\t\tassign_type = NET_NAME_PREDICTABLE;\n\t} else {\n\t\tname = \"eth%d\";\n\t\tassign_type = NET_NAME_ENUM;\n\t}\n\n\tslave_dev = alloc_netdev_mqs(sizeof(struct dsa_slave_priv), name,\n\t\t\t\t     assign_type, ether_setup,\n\t\t\t\t     ds->num_tx_queues, 1);\n\tif (slave_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tslave_dev->rtnl_link_ops = &dsa_link_ops;\n\tslave_dev->ethtool_ops = &dsa_slave_ethtool_ops;\n#if IS_ENABLED(CONFIG_DCB)\n\tslave_dev->dcbnl_ops = &dsa_slave_dcbnl_ops;\n#endif\n\tif (!is_zero_ether_addr(port->mac))\n\t\teth_hw_addr_set(slave_dev, port->mac);\n\telse\n\t\teth_hw_addr_inherit(slave_dev, master);\n\tslave_dev->priv_flags |= IFF_NO_QUEUE;\n\tif (dsa_switch_supports_uc_filtering(ds))\n\t\tslave_dev->priv_flags |= IFF_UNICAST_FLT;\n\tslave_dev->netdev_ops = &dsa_slave_netdev_ops;\n\tif (ds->ops->port_max_mtu)\n\t\tslave_dev->max_mtu = ds->ops->port_max_mtu(ds, port->index);\n\tSET_NETDEV_DEVTYPE(slave_dev, &dsa_type);\n\n\tSET_NETDEV_DEV(slave_dev, port->ds->dev);\n\tSET_NETDEV_DEVLINK_PORT(slave_dev, &port->devlink_port);\n\tslave_dev->dev.of_node = port->dn;\n\tslave_dev->vlan_features = master->vlan_features;\n\n\tp = netdev_priv(slave_dev);\n\tslave_dev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!slave_dev->tstats) {\n\t\tfree_netdev(slave_dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = gro_cells_init(&p->gcells, slave_dev);\n\tif (ret)\n\t\tgoto out_free;\n\n\tp->dp = port;\n\tINIT_LIST_HEAD(&p->mall_tc_list);\n\tport->slave = slave_dev;\n\tdsa_slave_setup_tagger(slave_dev);\n\n\tnetif_carrier_off(slave_dev);\n\n\tret = dsa_slave_phy_setup(slave_dev);\n\tif (ret) {\n\t\tnetdev_err(slave_dev,\n\t\t\t   \"error %d setting up PHY for tree %d, switch %d, port %d\\n\",\n\t\t\t   ret, ds->dst->index, ds->index, port->index);\n\t\tgoto out_gcells;\n\t}\n\n\trtnl_lock();\n\n\tret = dsa_slave_change_mtu(slave_dev, ETH_DATA_LEN);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\tdev_warn(ds->dev, \"nonfatal error %d setting MTU to %d on port %d\\n\",\n\t\t\t ret, ETH_DATA_LEN, port->index);\n\n\tret = register_netdevice(slave_dev);\n\tif (ret) {\n\t\tnetdev_err(master, \"error %d registering interface %s\\n\",\n\t\t\t   ret, slave_dev->name);\n\t\trtnl_unlock();\n\t\tgoto out_phy;\n\t}\n\n\tif (IS_ENABLED(CONFIG_DCB)) {\n\t\tret = dsa_slave_dcbnl_init(slave_dev);\n\t\tif (ret) {\n\t\t\tnetdev_err(slave_dev,\n\t\t\t\t   \"failed to initialize DCB: %pe\\n\",\n\t\t\t\t   ERR_PTR(ret));\n\t\t\trtnl_unlock();\n\t\t\tgoto out_unregister;\n\t\t}\n\t}\n\n\tret = netdev_upper_dev_link(master, slave_dev, NULL);\n\n\trtnl_unlock();\n\n\tif (ret)\n\t\tgoto out_unregister;\n\n\treturn 0;\n\nout_unregister:\n\tunregister_netdev(slave_dev);\nout_phy:\n\trtnl_lock();\n\tphylink_disconnect_phy(p->dp->pl);\n\trtnl_unlock();\n\tdsa_port_phylink_destroy(p->dp);\nout_gcells:\n\tgro_cells_destroy(&p->gcells);\nout_free:\n\tfree_percpu(slave_dev->tstats);\n\tfree_netdev(slave_dev);\n\tport->slave = NULL;\n\treturn ret;\n}\n\nvoid dsa_slave_destroy(struct net_device *slave_dev)\n{\n\tstruct net_device *master = dsa_slave_to_master(slave_dev);\n\tstruct dsa_port *dp = dsa_slave_to_port(slave_dev);\n\tstruct dsa_slave_priv *p = netdev_priv(slave_dev);\n\n\tnetif_carrier_off(slave_dev);\n\trtnl_lock();\n\tnetdev_upper_dev_unlink(master, slave_dev);\n\tunregister_netdevice(slave_dev);\n\tphylink_disconnect_phy(dp->pl);\n\trtnl_unlock();\n\n\tdsa_port_phylink_destroy(dp);\n\tgro_cells_destroy(&p->gcells);\n\tfree_percpu(slave_dev->tstats);\n\tfree_netdev(slave_dev);\n}\n\nint dsa_slave_change_master(struct net_device *dev, struct net_device *master,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net_device *old_master = dsa_slave_to_master(dev);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct net_device *upper;\n\tstruct list_head *iter;\n\tint err;\n\n\tif (master == old_master)\n\t\treturn 0;\n\n\tif (!ds->ops->port_change_master) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Driver does not support changing DSA master\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!netdev_uses_dsa(master)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Interface not eligible as DSA master\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tnetdev_for_each_upper_dev_rcu(master, upper, iter) {\n\t\tif (dsa_slave_dev_check(upper))\n\t\t\tcontinue;\n\t\tif (netif_is_bridge_master(upper))\n\t\t\tcontinue;\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot join master with unknown uppers\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (dev->flags & IFF_UP) {\n\t\terr = dev_open(master, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnetdev_upper_dev_unlink(old_master, dev);\n\n\terr = netdev_upper_dev_link(master, dev, extack);\n\tif (err)\n\t\tgoto out_revert_old_master_unlink;\n\n\terr = dsa_port_change_master(dp, master, extack);\n\tif (err)\n\t\tgoto out_revert_master_link;\n\n\t \n\terr = dsa_slave_change_mtu(dev, dev->mtu);\n\tif (err && err != -EOPNOTSUPP) {\n\t\tnetdev_warn(dev,\n\t\t\t    \"nonfatal error updating MTU with new master: %pe\\n\",\n\t\t\t    ERR_PTR(err));\n\t}\n\n\t \n\tif (is_zero_ether_addr(dp->mac))\n\t\teth_hw_addr_inherit(dev, master);\n\n\treturn 0;\n\nout_revert_master_link:\n\tnetdev_upper_dev_unlink(master, dev);\nout_revert_old_master_unlink:\n\tnetdev_upper_dev_link(old_master, dev, NULL);\n\treturn err;\n}\n\nbool dsa_slave_dev_check(const struct net_device *dev)\n{\n\treturn dev->netdev_ops == &dsa_slave_netdev_ops;\n}\nEXPORT_SYMBOL_GPL(dsa_slave_dev_check);\n\nstatic int dsa_slave_changeupper(struct net_device *dev,\n\t\t\t\t struct netdev_notifier_changeupper_info *info)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct netlink_ext_ack *extack;\n\tint err = NOTIFY_DONE;\n\n\tif (!dsa_slave_dev_check(dev))\n\t\treturn err;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tif (netif_is_bridge_master(info->upper_dev)) {\n\t\tif (info->linking) {\n\t\t\terr = dsa_port_bridge_join(dp, info->upper_dev, extack);\n\t\t\tif (!err)\n\t\t\t\tdsa_bridge_mtu_normalization(dp);\n\t\t\tif (err == -EOPNOTSUPP) {\n\t\t\t\tNL_SET_ERR_MSG_WEAK_MOD(extack,\n\t\t\t\t\t\t\t\"Offloading not supported\");\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t\terr = notifier_from_errno(err);\n\t\t} else {\n\t\t\tdsa_port_bridge_leave(dp, info->upper_dev);\n\t\t\terr = NOTIFY_OK;\n\t\t}\n\t} else if (netif_is_lag_master(info->upper_dev)) {\n\t\tif (info->linking) {\n\t\t\terr = dsa_port_lag_join(dp, info->upper_dev,\n\t\t\t\t\t\tinfo->upper_info, extack);\n\t\t\tif (err == -EOPNOTSUPP) {\n\t\t\t\tNL_SET_ERR_MSG_WEAK_MOD(extack,\n\t\t\t\t\t\t\t\"Offloading not supported\");\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t\terr = notifier_from_errno(err);\n\t\t} else {\n\t\t\tdsa_port_lag_leave(dp, info->upper_dev);\n\t\t\terr = NOTIFY_OK;\n\t\t}\n\t} else if (is_hsr_master(info->upper_dev)) {\n\t\tif (info->linking) {\n\t\t\terr = dsa_port_hsr_join(dp, info->upper_dev);\n\t\t\tif (err == -EOPNOTSUPP) {\n\t\t\t\tNL_SET_ERR_MSG_WEAK_MOD(extack,\n\t\t\t\t\t\t\t\"Offloading not supported\");\n\t\t\t\terr = 0;\n\t\t\t}\n\t\t\terr = notifier_from_errno(err);\n\t\t} else {\n\t\t\tdsa_port_hsr_leave(dp, info->upper_dev);\n\t\t\terr = NOTIFY_OK;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int dsa_slave_prechangeupper(struct net_device *dev,\n\t\t\t\t    struct netdev_notifier_changeupper_info *info)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\n\tif (!dsa_slave_dev_check(dev))\n\t\treturn NOTIFY_DONE;\n\n\tif (netif_is_bridge_master(info->upper_dev) && !info->linking)\n\t\tdsa_port_pre_bridge_leave(dp, info->upper_dev);\n\telse if (netif_is_lag_master(info->upper_dev) && !info->linking)\n\t\tdsa_port_pre_lag_leave(dp, info->upper_dev);\n\t \n\n\treturn NOTIFY_DONE;\n}\n\nstatic int\ndsa_slave_lag_changeupper(struct net_device *dev,\n\t\t\t  struct netdev_notifier_changeupper_info *info)\n{\n\tstruct net_device *lower;\n\tstruct list_head *iter;\n\tint err = NOTIFY_DONE;\n\tstruct dsa_port *dp;\n\n\tif (!netif_is_lag_master(dev))\n\t\treturn err;\n\n\tnetdev_for_each_lower_dev(dev, lower, iter) {\n\t\tif (!dsa_slave_dev_check(lower))\n\t\t\tcontinue;\n\n\t\tdp = dsa_slave_to_port(lower);\n\t\tif (!dp->lag)\n\t\t\t \n\t\t\tcontinue;\n\n\t\terr = dsa_slave_changeupper(lower, info);\n\t\tif (notifier_to_errno(err))\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int\ndsa_slave_lag_prechangeupper(struct net_device *dev,\n\t\t\t     struct netdev_notifier_changeupper_info *info)\n{\n\tstruct net_device *lower;\n\tstruct list_head *iter;\n\tint err = NOTIFY_DONE;\n\tstruct dsa_port *dp;\n\n\tif (!netif_is_lag_master(dev))\n\t\treturn err;\n\n\tnetdev_for_each_lower_dev(dev, lower, iter) {\n\t\tif (!dsa_slave_dev_check(lower))\n\t\t\tcontinue;\n\n\t\tdp = dsa_slave_to_port(lower);\n\t\tif (!dp->lag)\n\t\t\t \n\t\t\tcontinue;\n\n\t\terr = dsa_slave_prechangeupper(lower, info);\n\t\tif (notifier_to_errno(err))\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int\ndsa_prevent_bridging_8021q_upper(struct net_device *dev,\n\t\t\t\t struct netdev_notifier_changeupper_info *info)\n{\n\tstruct netlink_ext_ack *ext_ack;\n\tstruct net_device *slave, *br;\n\tstruct dsa_port *dp;\n\n\text_ack = netdev_notifier_info_to_extack(&info->info);\n\n\tif (!is_vlan_dev(dev))\n\t\treturn NOTIFY_DONE;\n\n\tslave = vlan_dev_real_dev(dev);\n\tif (!dsa_slave_dev_check(slave))\n\t\treturn NOTIFY_DONE;\n\n\tdp = dsa_slave_to_port(slave);\n\tbr = dsa_port_bridge_dev_get(dp);\n\tif (!br)\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif (br_vlan_enabled(br) &&\n\t    netif_is_bridge_master(info->upper_dev) && info->linking) {\n\t\tNL_SET_ERR_MSG_MOD(ext_ack,\n\t\t\t\t   \"Cannot enslave VLAN device into VLAN aware bridge\");\n\t\treturn notifier_from_errno(-EINVAL);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int\ndsa_slave_check_8021q_upper(struct net_device *dev,\n\t\t\t    struct netdev_notifier_changeupper_info *info)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct net_device *br = dsa_port_bridge_dev_get(dp);\n\tstruct bridge_vlan_info br_info;\n\tstruct netlink_ext_ack *extack;\n\tint err = NOTIFY_DONE;\n\tu16 vid;\n\n\tif (!br || !br_vlan_enabled(br))\n\t\treturn NOTIFY_DONE;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\tvid = vlan_dev_vlan_id(info->upper_dev);\n\n\t \n\terr = br_vlan_get_info(br, vid, &br_info);\n\tif (err == 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"This VLAN is already configured by the bridge\");\n\t\treturn notifier_from_errno(-EBUSY);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int\ndsa_slave_prechangeupper_sanity_check(struct net_device *dev,\n\t\t\t\t      struct netdev_notifier_changeupper_info *info)\n{\n\tstruct dsa_switch *ds;\n\tstruct dsa_port *dp;\n\tint err;\n\n\tif (!dsa_slave_dev_check(dev))\n\t\treturn dsa_prevent_bridging_8021q_upper(dev, info);\n\n\tdp = dsa_slave_to_port(dev);\n\tds = dp->ds;\n\n\tif (ds->ops->port_prechangeupper) {\n\t\terr = ds->ops->port_prechangeupper(ds, dp->index, info);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t}\n\n\tif (is_vlan_dev(info->upper_dev))\n\t\treturn dsa_slave_check_8021q_upper(dev, info);\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic int dsa_lag_master_validate(struct net_device *lag_dev,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net_device *lower1, *lower2;\n\tstruct list_head *iter1, *iter2;\n\n\tnetdev_for_each_lower_dev(lag_dev, lower1, iter1) {\n\t\tnetdev_for_each_lower_dev(lag_dev, lower2, iter2) {\n\t\t\tif (!netdev_uses_dsa(lower1) ||\n\t\t\t    !netdev_uses_dsa(lower2)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"All LAG ports must be eligible as DSA masters\");\n\t\t\t\treturn notifier_from_errno(-EINVAL);\n\t\t\t}\n\n\t\t\tif (lower1 == lower2)\n\t\t\t\tcontinue;\n\n\t\t\tif (!dsa_port_tree_same(lower1->dsa_ptr,\n\t\t\t\t\t\tlower2->dsa_ptr)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"LAG contains DSA masters of disjoint switch trees\");\n\t\t\t\treturn notifier_from_errno(-EINVAL);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int\ndsa_master_prechangeupper_sanity_check(struct net_device *master,\n\t\t\t\t       struct netdev_notifier_changeupper_info *info)\n{\n\tstruct netlink_ext_ack *extack = netdev_notifier_info_to_extack(&info->info);\n\n\tif (!netdev_uses_dsa(master))\n\t\treturn NOTIFY_DONE;\n\n\tif (!info->linking)\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif (dsa_slave_dev_check(info->upper_dev))\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif (netif_is_bridge_master(info->upper_dev))\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif (netif_is_lag_master(info->upper_dev))\n\t\treturn dsa_lag_master_validate(info->upper_dev, extack);\n\n\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t   \"DSA master cannot join unknown upper interfaces\");\n\treturn notifier_from_errno(-EBUSY);\n}\n\nstatic int\ndsa_lag_master_prechangelower_sanity_check(struct net_device *dev,\n\t\t\t\t\t   struct netdev_notifier_changeupper_info *info)\n{\n\tstruct netlink_ext_ack *extack = netdev_notifier_info_to_extack(&info->info);\n\tstruct net_device *lag_dev = info->upper_dev;\n\tstruct net_device *lower;\n\tstruct list_head *iter;\n\n\tif (!netdev_uses_dsa(lag_dev) || !netif_is_lag_master(lag_dev))\n\t\treturn NOTIFY_DONE;\n\n\tif (!info->linking)\n\t\treturn NOTIFY_DONE;\n\n\tif (!netdev_uses_dsa(dev)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Only DSA masters can join a LAG DSA master\");\n\t\treturn notifier_from_errno(-EINVAL);\n\t}\n\n\tnetdev_for_each_lower_dev(lag_dev, lower, iter) {\n\t\tif (!dsa_port_tree_same(dev->dsa_ptr, lower->dsa_ptr)) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Interface is DSA master for a different switch tree than this LAG\");\n\t\t\treturn notifier_from_errno(-EINVAL);\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic int\ndsa_bridge_prechangelower_sanity_check(struct net_device *new_lower,\n\t\t\t\t       struct netdev_notifier_changeupper_info *info)\n{\n\tstruct net_device *br = info->upper_dev;\n\tstruct netlink_ext_ack *extack;\n\tstruct net_device *lower;\n\tstruct list_head *iter;\n\n\tif (!netif_is_bridge_master(br))\n\t\treturn NOTIFY_DONE;\n\n\tif (!info->linking)\n\t\treturn NOTIFY_DONE;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tnetdev_for_each_lower_dev(br, lower, iter) {\n\t\tif (!netdev_uses_dsa(new_lower) && !netdev_uses_dsa(lower))\n\t\t\tcontinue;\n\n\t\tif (!netdev_port_same_parent_id(lower, new_lower)) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Cannot do software bridging with a DSA master\");\n\t\t\treturn notifier_from_errno(-EINVAL);\n\t\t}\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void dsa_tree_migrate_ports_from_lag_master(struct dsa_switch_tree *dst,\n\t\t\t\t\t\t   struct net_device *lag_dev)\n{\n\tstruct net_device *new_master = dsa_tree_find_first_master(dst);\n\tstruct dsa_port *dp;\n\tint err;\n\n\tdsa_tree_for_each_user_port(dp, dst) {\n\t\tif (dsa_port_to_master(dp) != lag_dev)\n\t\t\tcontinue;\n\n\t\terr = dsa_slave_change_master(dp->slave, new_master, NULL);\n\t\tif (err) {\n\t\t\tnetdev_err(dp->slave,\n\t\t\t\t   \"failed to restore master to %s: %pe\\n\",\n\t\t\t\t   new_master->name, ERR_PTR(err));\n\t\t}\n\t}\n}\n\nstatic int dsa_master_lag_join(struct net_device *master,\n\t\t\t       struct net_device *lag_dev,\n\t\t\t       struct netdev_lag_upper_info *uinfo,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct dsa_port *cpu_dp = master->dsa_ptr;\n\tstruct dsa_switch_tree *dst = cpu_dp->dst;\n\tstruct dsa_port *dp;\n\tint err;\n\n\terr = dsa_master_lag_setup(lag_dev, cpu_dp, uinfo, extack);\n\tif (err)\n\t\treturn err;\n\n\tdsa_tree_for_each_user_port(dp, dst) {\n\t\tif (dsa_port_to_master(dp) != master)\n\t\t\tcontinue;\n\n\t\terr = dsa_slave_change_master(dp->slave, lag_dev, extack);\n\t\tif (err)\n\t\t\tgoto restore;\n\t}\n\n\treturn 0;\n\nrestore:\n\tdsa_tree_for_each_user_port_continue_reverse(dp, dst) {\n\t\tif (dsa_port_to_master(dp) != lag_dev)\n\t\t\tcontinue;\n\n\t\terr = dsa_slave_change_master(dp->slave, master, NULL);\n\t\tif (err) {\n\t\t\tnetdev_err(dp->slave,\n\t\t\t\t   \"failed to restore master to %s: %pe\\n\",\n\t\t\t\t   master->name, ERR_PTR(err));\n\t\t}\n\t}\n\n\tdsa_master_lag_teardown(lag_dev, master->dsa_ptr);\n\n\treturn err;\n}\n\nstatic void dsa_master_lag_leave(struct net_device *master,\n\t\t\t\t struct net_device *lag_dev)\n{\n\tstruct dsa_port *dp, *cpu_dp = lag_dev->dsa_ptr;\n\tstruct dsa_switch_tree *dst = cpu_dp->dst;\n\tstruct dsa_port *new_cpu_dp = NULL;\n\tstruct net_device *lower;\n\tstruct list_head *iter;\n\n\tnetdev_for_each_lower_dev(lag_dev, lower, iter) {\n\t\tif (netdev_uses_dsa(lower)) {\n\t\t\tnew_cpu_dp = lower->dsa_ptr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (new_cpu_dp) {\n\t\t \n\t\tdsa_tree_for_each_user_port(dp, dst)\n\t\t\tif (dsa_port_to_master(dp) == lag_dev)\n\t\t\t\tdp->cpu_dp = new_cpu_dp;\n\n\t\t \n\t\tlag_dev->dsa_ptr = new_cpu_dp;\n\t\twmb();\n\t} else {\n\t\t \n\t\tdsa_tree_migrate_ports_from_lag_master(dst, lag_dev);\n\t}\n\n\t \n\tdsa_master_lag_teardown(lag_dev, master->dsa_ptr);\n}\n\nstatic int dsa_master_changeupper(struct net_device *dev,\n\t\t\t\t  struct netdev_notifier_changeupper_info *info)\n{\n\tstruct netlink_ext_ack *extack;\n\tint err = NOTIFY_DONE;\n\n\tif (!netdev_uses_dsa(dev))\n\t\treturn err;\n\n\textack = netdev_notifier_info_to_extack(&info->info);\n\n\tif (netif_is_lag_master(info->upper_dev)) {\n\t\tif (info->linking) {\n\t\t\terr = dsa_master_lag_join(dev, info->upper_dev,\n\t\t\t\t\t\t  info->upper_info, extack);\n\t\t\terr = notifier_from_errno(err);\n\t\t} else {\n\t\t\tdsa_master_lag_leave(dev, info->upper_dev);\n\t\t\terr = NOTIFY_OK;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int dsa_slave_netdevice_event(struct notifier_block *nb,\n\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tswitch (event) {\n\tcase NETDEV_PRECHANGEUPPER: {\n\t\tstruct netdev_notifier_changeupper_info *info = ptr;\n\t\tint err;\n\n\t\terr = dsa_slave_prechangeupper_sanity_check(dev, info);\n\t\tif (notifier_to_errno(err))\n\t\t\treturn err;\n\n\t\terr = dsa_master_prechangeupper_sanity_check(dev, info);\n\t\tif (notifier_to_errno(err))\n\t\t\treturn err;\n\n\t\terr = dsa_lag_master_prechangelower_sanity_check(dev, info);\n\t\tif (notifier_to_errno(err))\n\t\t\treturn err;\n\n\t\terr = dsa_bridge_prechangelower_sanity_check(dev, info);\n\t\tif (notifier_to_errno(err))\n\t\t\treturn err;\n\n\t\terr = dsa_slave_prechangeupper(dev, ptr);\n\t\tif (notifier_to_errno(err))\n\t\t\treturn err;\n\n\t\terr = dsa_slave_lag_prechangeupper(dev, ptr);\n\t\tif (notifier_to_errno(err))\n\t\t\treturn err;\n\n\t\tbreak;\n\t}\n\tcase NETDEV_CHANGEUPPER: {\n\t\tint err;\n\n\t\terr = dsa_slave_changeupper(dev, ptr);\n\t\tif (notifier_to_errno(err))\n\t\t\treturn err;\n\n\t\terr = dsa_slave_lag_changeupper(dev, ptr);\n\t\tif (notifier_to_errno(err))\n\t\t\treturn err;\n\n\t\terr = dsa_master_changeupper(dev, ptr);\n\t\tif (notifier_to_errno(err))\n\t\t\treturn err;\n\n\t\tbreak;\n\t}\n\tcase NETDEV_CHANGELOWERSTATE: {\n\t\tstruct netdev_notifier_changelowerstate_info *info = ptr;\n\t\tstruct dsa_port *dp;\n\t\tint err = 0;\n\n\t\tif (dsa_slave_dev_check(dev)) {\n\t\t\tdp = dsa_slave_to_port(dev);\n\n\t\t\terr = dsa_port_lag_change(dp, info->lower_state_info);\n\t\t}\n\n\t\t \n\t\tif (netdev_uses_dsa(dev)) {\n\t\t\tdp = dev->dsa_ptr;\n\n\t\t\terr = dsa_port_lag_change(dp, info->lower_state_info);\n\t\t}\n\n\t\treturn notifier_from_errno(err);\n\t}\n\tcase NETDEV_CHANGE:\n\tcase NETDEV_UP: {\n\t\t \n\t\tif (netdev_uses_dsa(dev)) {\n\t\t\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\t\t\tstruct dsa_switch_tree *dst = cpu_dp->ds->dst;\n\n\t\t\t \n\t\t\tdsa_tree_master_oper_state_change(dst, dev,\n\t\t\t\t\t\t\t  netif_oper_up(dev));\n\n\t\t\t \n\t\t\tdsa_tree_master_admin_state_change(dst, dev,\n\t\t\t\t\t\t\t   !qdisc_tx_is_noop(dev));\n\n\t\t\treturn NOTIFY_OK;\n\t\t}\n\n\t\treturn NOTIFY_DONE;\n\t}\n\tcase NETDEV_GOING_DOWN: {\n\t\tstruct dsa_port *dp, *cpu_dp;\n\t\tstruct dsa_switch_tree *dst;\n\t\tLIST_HEAD(close_list);\n\n\t\tif (!netdev_uses_dsa(dev))\n\t\t\treturn NOTIFY_DONE;\n\n\t\tcpu_dp = dev->dsa_ptr;\n\t\tdst = cpu_dp->ds->dst;\n\n\t\tdsa_tree_master_admin_state_change(dst, dev, false);\n\n\t\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\t\tif (!dsa_port_is_user(dp))\n\t\t\t\tcontinue;\n\n\t\t\tif (dp->cpu_dp != cpu_dp)\n\t\t\t\tcontinue;\n\n\t\t\tlist_add(&dp->slave->close_list, &close_list);\n\t\t}\n\n\t\tdev_close_many(&close_list, true);\n\n\t\treturn NOTIFY_OK;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void\ndsa_fdb_offload_notify(struct dsa_switchdev_event_work *switchdev_work)\n{\n\tstruct switchdev_notifier_fdb_info info = {};\n\n\tinfo.addr = switchdev_work->addr;\n\tinfo.vid = switchdev_work->vid;\n\tinfo.offloaded = true;\n\tcall_switchdev_notifiers(SWITCHDEV_FDB_OFFLOADED,\n\t\t\t\t switchdev_work->orig_dev, &info.info, NULL);\n}\n\nstatic void dsa_slave_switchdev_event_work(struct work_struct *work)\n{\n\tstruct dsa_switchdev_event_work *switchdev_work =\n\t\tcontainer_of(work, struct dsa_switchdev_event_work, work);\n\tconst unsigned char *addr = switchdev_work->addr;\n\tstruct net_device *dev = switchdev_work->dev;\n\tu16 vid = switchdev_work->vid;\n\tstruct dsa_switch *ds;\n\tstruct dsa_port *dp;\n\tint err;\n\n\tdp = dsa_slave_to_port(dev);\n\tds = dp->ds;\n\n\tswitch (switchdev_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tif (switchdev_work->host_addr)\n\t\t\terr = dsa_port_bridge_host_fdb_add(dp, addr, vid);\n\t\telse if (dp->lag)\n\t\t\terr = dsa_port_lag_fdb_add(dp, addr, vid);\n\t\telse\n\t\t\terr = dsa_port_fdb_add(dp, addr, vid);\n\t\tif (err) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"port %d failed to add %pM vid %d to fdb: %d\\n\",\n\t\t\t\tdp->index, addr, vid, err);\n\t\t\tbreak;\n\t\t}\n\t\tdsa_fdb_offload_notify(switchdev_work);\n\t\tbreak;\n\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tif (switchdev_work->host_addr)\n\t\t\terr = dsa_port_bridge_host_fdb_del(dp, addr, vid);\n\t\telse if (dp->lag)\n\t\t\terr = dsa_port_lag_fdb_del(dp, addr, vid);\n\t\telse\n\t\t\terr = dsa_port_fdb_del(dp, addr, vid);\n\t\tif (err) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"port %d failed to delete %pM vid %d from fdb: %d\\n\",\n\t\t\t\tdp->index, addr, vid, err);\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tkfree(switchdev_work);\n}\n\nstatic bool dsa_foreign_dev_check(const struct net_device *dev,\n\t\t\t\t  const struct net_device *foreign_dev)\n{\n\tconst struct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct dsa_switch_tree *dst = dp->ds->dst;\n\n\tif (netif_is_bridge_master(foreign_dev))\n\t\treturn !dsa_tree_offloads_bridge_dev(dst, foreign_dev);\n\n\tif (netif_is_bridge_port(foreign_dev))\n\t\treturn !dsa_tree_offloads_bridge_port(dst, foreign_dev);\n\n\t \n\treturn true;\n}\n\nstatic int dsa_slave_fdb_event(struct net_device *dev,\n\t\t\t       struct net_device *orig_dev,\n\t\t\t       unsigned long event, const void *ctx,\n\t\t\t       const struct switchdev_notifier_fdb_info *fdb_info)\n{\n\tstruct dsa_switchdev_event_work *switchdev_work;\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tbool host_addr = fdb_info->is_local;\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ctx && ctx != dp)\n\t\treturn 0;\n\n\tif (!dp->bridge)\n\t\treturn 0;\n\n\tif (switchdev_fdb_is_dynamically_learned(fdb_info)) {\n\t\tif (dsa_port_offloads_bridge_port(dp, orig_dev))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!ds->assisted_learning_on_cpu_port)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (dsa_foreign_dev_check(dev, orig_dev))\n\t\thost_addr = true;\n\n\t \n\tif (dp->lag && !host_addr) {\n\t\tif (!ds->ops->lag_fdb_add || !ds->ops->lag_fdb_del)\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\tif (!ds->ops->port_fdb_add || !ds->ops->port_fdb_del)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitchdev_work = kzalloc(sizeof(*switchdev_work), GFP_ATOMIC);\n\tif (!switchdev_work)\n\t\treturn -ENOMEM;\n\n\tnetdev_dbg(dev, \"%s FDB entry towards %s, addr %pM vid %d%s\\n\",\n\t\t   event == SWITCHDEV_FDB_ADD_TO_DEVICE ? \"Adding\" : \"Deleting\",\n\t\t   orig_dev->name, fdb_info->addr, fdb_info->vid,\n\t\t   host_addr ? \" as host address\" : \"\");\n\n\tINIT_WORK(&switchdev_work->work, dsa_slave_switchdev_event_work);\n\tswitchdev_work->event = event;\n\tswitchdev_work->dev = dev;\n\tswitchdev_work->orig_dev = orig_dev;\n\n\tether_addr_copy(switchdev_work->addr, fdb_info->addr);\n\tswitchdev_work->vid = fdb_info->vid;\n\tswitchdev_work->host_addr = host_addr;\n\n\tdsa_schedule_work(&switchdev_work->work);\n\n\treturn 0;\n}\n\n \nstatic int dsa_slave_switchdev_event(struct notifier_block *unused,\n\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     dsa_slave_dev_check,\n\t\t\t\t\t\t     dsa_slave_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\terr = switchdev_handle_fdb_event_to_device(dev, event, ptr,\n\t\t\t\t\t\t\t   dsa_slave_dev_check,\n\t\t\t\t\t\t\t   dsa_foreign_dev_check,\n\t\t\t\t\t\t\t   dsa_slave_fdb_event);\n\t\treturn notifier_from_errno(err);\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int dsa_slave_switchdev_blocking_event(struct notifier_block *unused,\n\t\t\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tint err;\n\n\tswitch (event) {\n\tcase SWITCHDEV_PORT_OBJ_ADD:\n\t\terr = switchdev_handle_port_obj_add_foreign(dev, ptr,\n\t\t\t\t\t\t\t    dsa_slave_dev_check,\n\t\t\t\t\t\t\t    dsa_foreign_dev_check,\n\t\t\t\t\t\t\t    dsa_slave_port_obj_add);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_OBJ_DEL:\n\t\terr = switchdev_handle_port_obj_del_foreign(dev, ptr,\n\t\t\t\t\t\t\t    dsa_slave_dev_check,\n\t\t\t\t\t\t\t    dsa_foreign_dev_check,\n\t\t\t\t\t\t\t    dsa_slave_port_obj_del);\n\t\treturn notifier_from_errno(err);\n\tcase SWITCHDEV_PORT_ATTR_SET:\n\t\terr = switchdev_handle_port_attr_set(dev, ptr,\n\t\t\t\t\t\t     dsa_slave_dev_check,\n\t\t\t\t\t\t     dsa_slave_port_attr_set);\n\t\treturn notifier_from_errno(err);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block dsa_slave_nb __read_mostly = {\n\t.notifier_call  = dsa_slave_netdevice_event,\n};\n\nstruct notifier_block dsa_slave_switchdev_notifier = {\n\t.notifier_call = dsa_slave_switchdev_event,\n};\n\nstruct notifier_block dsa_slave_switchdev_blocking_notifier = {\n\t.notifier_call = dsa_slave_switchdev_blocking_event,\n};\n\nint dsa_slave_register_notifier(void)\n{\n\tstruct notifier_block *nb;\n\tint err;\n\n\terr = register_netdevice_notifier(&dsa_slave_nb);\n\tif (err)\n\t\treturn err;\n\n\terr = register_switchdev_notifier(&dsa_slave_switchdev_notifier);\n\tif (err)\n\t\tgoto err_switchdev_nb;\n\n\tnb = &dsa_slave_switchdev_blocking_notifier;\n\terr = register_switchdev_blocking_notifier(nb);\n\tif (err)\n\t\tgoto err_switchdev_blocking_nb;\n\n\treturn 0;\n\nerr_switchdev_blocking_nb:\n\tunregister_switchdev_notifier(&dsa_slave_switchdev_notifier);\nerr_switchdev_nb:\n\tunregister_netdevice_notifier(&dsa_slave_nb);\n\treturn err;\n}\n\nvoid dsa_slave_unregister_notifier(void)\n{\n\tstruct notifier_block *nb;\n\tint err;\n\n\tnb = &dsa_slave_switchdev_blocking_notifier;\n\terr = unregister_switchdev_blocking_notifier(nb);\n\tif (err)\n\t\tpr_err(\"DSA: failed to unregister switchdev blocking notifier (%d)\\n\", err);\n\n\terr = unregister_switchdev_notifier(&dsa_slave_switchdev_notifier);\n\tif (err)\n\t\tpr_err(\"DSA: failed to unregister switchdev notifier (%d)\\n\", err);\n\n\terr = unregister_netdevice_notifier(&dsa_slave_nb);\n\tif (err)\n\t\tpr_err(\"DSA: failed to unregister slave notifier (%d)\\n\", err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}