{
  "module_name": "master.c",
  "hash_id": "84fa3bf593997471670524d16c4281791a768e06861db8b3367209405326a7be",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/master.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <net/dsa.h>\n\n#include \"dsa.h\"\n#include \"master.h\"\n#include \"port.h\"\n#include \"tag.h\"\n\nstatic int dsa_master_get_regs_len(struct net_device *dev)\n{\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\tconst struct ethtool_ops *ops = cpu_dp->orig_ethtool_ops;\n\tstruct dsa_switch *ds = cpu_dp->ds;\n\tint port = cpu_dp->index;\n\tint ret = 0;\n\tint len;\n\n\tif (ops->get_regs_len) {\n\t\tlen = ops->get_regs_len(dev);\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\tret += len;\n\t}\n\n\tret += sizeof(struct ethtool_drvinfo);\n\tret += sizeof(struct ethtool_regs);\n\n\tif (ds->ops->get_regs_len) {\n\t\tlen = ds->ops->get_regs_len(ds, port);\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\tret += len;\n\t}\n\n\treturn ret;\n}\n\nstatic void dsa_master_get_regs(struct net_device *dev,\n\t\t\t\tstruct ethtool_regs *regs, void *data)\n{\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\tconst struct ethtool_ops *ops = cpu_dp->orig_ethtool_ops;\n\tstruct dsa_switch *ds = cpu_dp->ds;\n\tstruct ethtool_drvinfo *cpu_info;\n\tstruct ethtool_regs *cpu_regs;\n\tint port = cpu_dp->index;\n\tint len;\n\n\tif (ops->get_regs_len && ops->get_regs) {\n\t\tlen = ops->get_regs_len(dev);\n\t\tif (len < 0)\n\t\t\treturn;\n\t\tregs->len = len;\n\t\tops->get_regs(dev, regs, data);\n\t\tdata += regs->len;\n\t}\n\n\tcpu_info = (struct ethtool_drvinfo *)data;\n\tstrscpy(cpu_info->driver, \"dsa\", sizeof(cpu_info->driver));\n\tdata += sizeof(*cpu_info);\n\tcpu_regs = (struct ethtool_regs *)data;\n\tdata += sizeof(*cpu_regs);\n\n\tif (ds->ops->get_regs_len && ds->ops->get_regs) {\n\t\tlen = ds->ops->get_regs_len(ds, port);\n\t\tif (len < 0)\n\t\t\treturn;\n\t\tcpu_regs->len = len;\n\t\tds->ops->get_regs(ds, port, cpu_regs, data);\n\t}\n}\n\nstatic void dsa_master_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t\t struct ethtool_stats *stats,\n\t\t\t\t\t uint64_t *data)\n{\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\tconst struct ethtool_ops *ops = cpu_dp->orig_ethtool_ops;\n\tstruct dsa_switch *ds = cpu_dp->ds;\n\tint port = cpu_dp->index;\n\tint count = 0;\n\n\tif (ops->get_sset_count && ops->get_ethtool_stats) {\n\t\tcount = ops->get_sset_count(dev, ETH_SS_STATS);\n\t\tops->get_ethtool_stats(dev, stats, data);\n\t}\n\n\tif (ds->ops->get_ethtool_stats)\n\t\tds->ops->get_ethtool_stats(ds, port, data + count);\n}\n\nstatic void dsa_master_get_ethtool_phy_stats(struct net_device *dev,\n\t\t\t\t\t     struct ethtool_stats *stats,\n\t\t\t\t\t     uint64_t *data)\n{\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\tconst struct ethtool_ops *ops = cpu_dp->orig_ethtool_ops;\n\tstruct dsa_switch *ds = cpu_dp->ds;\n\tint port = cpu_dp->index;\n\tint count = 0;\n\n\tif (dev->phydev && !ops->get_ethtool_phy_stats) {\n\t\tcount = phy_ethtool_get_sset_count(dev->phydev);\n\t\tif (count >= 0)\n\t\t\tphy_ethtool_get_stats(dev->phydev, stats, data);\n\t} else if (ops->get_sset_count && ops->get_ethtool_phy_stats) {\n\t\tcount = ops->get_sset_count(dev, ETH_SS_PHY_STATS);\n\t\tops->get_ethtool_phy_stats(dev, stats, data);\n\t}\n\n\tif (count < 0)\n\t\tcount = 0;\n\n\tif (ds->ops->get_ethtool_phy_stats)\n\t\tds->ops->get_ethtool_phy_stats(ds, port, data + count);\n}\n\nstatic int dsa_master_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\tconst struct ethtool_ops *ops = cpu_dp->orig_ethtool_ops;\n\tstruct dsa_switch *ds = cpu_dp->ds;\n\tint count = 0;\n\n\tif (sset == ETH_SS_PHY_STATS && dev->phydev &&\n\t    !ops->get_ethtool_phy_stats)\n\t\tcount = phy_ethtool_get_sset_count(dev->phydev);\n\telse if (ops->get_sset_count)\n\t\tcount = ops->get_sset_count(dev, sset);\n\n\tif (count < 0)\n\t\tcount = 0;\n\n\tif (ds->ops->get_sset_count)\n\t\tcount += ds->ops->get_sset_count(ds, cpu_dp->index, sset);\n\n\treturn count;\n}\n\nstatic void dsa_master_get_strings(struct net_device *dev, uint32_t stringset,\n\t\t\t\t   uint8_t *data)\n{\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\tconst struct ethtool_ops *ops = cpu_dp->orig_ethtool_ops;\n\tstruct dsa_switch *ds = cpu_dp->ds;\n\tint port = cpu_dp->index;\n\tint len = ETH_GSTRING_LEN;\n\tint mcount = 0, count, i;\n\tuint8_t pfx[4];\n\tuint8_t *ndata;\n\n\tsnprintf(pfx, sizeof(pfx), \"p%.2d\", port);\n\t \n\tpfx[sizeof(pfx) - 1] = '_';\n\n\tif (stringset == ETH_SS_PHY_STATS && dev->phydev &&\n\t    !ops->get_ethtool_phy_stats) {\n\t\tmcount = phy_ethtool_get_sset_count(dev->phydev);\n\t\tif (mcount < 0)\n\t\t\tmcount = 0;\n\t\telse\n\t\t\tphy_ethtool_get_strings(dev->phydev, data);\n\t} else if (ops->get_sset_count && ops->get_strings) {\n\t\tmcount = ops->get_sset_count(dev, stringset);\n\t\tif (mcount < 0)\n\t\t\tmcount = 0;\n\t\tops->get_strings(dev, stringset, data);\n\t}\n\n\tif (ds->ops->get_strings) {\n\t\tndata = data + mcount * len;\n\t\t \n\t\tds->ops->get_strings(ds, port, stringset, ndata);\n\t\tcount = ds->ops->get_sset_count(ds, port, stringset);\n\t\tif (count < 0)\n\t\t\treturn;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tmemmove(ndata + (i * len + sizeof(pfx)),\n\t\t\t\tndata + i * len, len - sizeof(pfx));\n\t\t\tmemcpy(ndata + i * len, pfx, sizeof(pfx));\n\t\t}\n\t}\n}\n\n \nint __dsa_master_hwtstamp_validate(struct net_device *dev,\n\t\t\t\t   const struct kernel_hwtstamp_config *config,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\tstruct dsa_switch *ds = cpu_dp->ds;\n\tstruct dsa_switch_tree *dst;\n\tstruct dsa_port *dp;\n\n\tdst = ds->dst;\n\n\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\tif (dsa_port_supports_hwtstamp(dp)) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"HW timestamping not allowed on DSA master when switch supports the operation\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dsa_master_ethtool_setup(struct net_device *dev)\n{\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\tstruct dsa_switch *ds = cpu_dp->ds;\n\tstruct ethtool_ops *ops;\n\n\tif (netif_is_lag_master(dev))\n\t\treturn 0;\n\n\tops = devm_kzalloc(ds->dev, sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\tcpu_dp->orig_ethtool_ops = dev->ethtool_ops;\n\tif (cpu_dp->orig_ethtool_ops)\n\t\tmemcpy(ops, cpu_dp->orig_ethtool_ops, sizeof(*ops));\n\n\tops->get_regs_len = dsa_master_get_regs_len;\n\tops->get_regs = dsa_master_get_regs;\n\tops->get_sset_count = dsa_master_get_sset_count;\n\tops->get_ethtool_stats = dsa_master_get_ethtool_stats;\n\tops->get_strings = dsa_master_get_strings;\n\tops->get_ethtool_phy_stats = dsa_master_get_ethtool_phy_stats;\n\n\tdev->ethtool_ops = ops;\n\n\treturn 0;\n}\n\nstatic void dsa_master_ethtool_teardown(struct net_device *dev)\n{\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\n\tif (netif_is_lag_master(dev))\n\t\treturn;\n\n\tdev->ethtool_ops = cpu_dp->orig_ethtool_ops;\n\tcpu_dp->orig_ethtool_ops = NULL;\n}\n\n \nstatic void dsa_master_set_promiscuity(struct net_device *dev, int inc)\n{\n\tconst struct dsa_device_ops *ops = dev->dsa_ptr->tag_ops;\n\n\tif ((dev->priv_flags & IFF_UNICAST_FLT) && !ops->promisc_on_master)\n\t\treturn;\n\n\tASSERT_RTNL();\n\n\tdev_set_promiscuity(dev, inc);\n}\n\nstatic ssize_t tagging_show(struct device *d, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct net_device *dev = to_net_dev(d);\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t       dsa_tag_protocol_to_str(cpu_dp->tag_ops));\n}\n\nstatic ssize_t tagging_store(struct device *d, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tconst struct dsa_device_ops *new_tag_ops, *old_tag_ops;\n\tconst char *end = strchrnul(buf, '\\n'), *name;\n\tstruct net_device *dev = to_net_dev(d);\n\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\tsize_t len = end - buf;\n\tint err;\n\n\t \n\tif (!len)\n\t\treturn -ENOPROTOOPT;\n\n\tname = kstrndup(buf, len, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\told_tag_ops = cpu_dp->tag_ops;\n\tnew_tag_ops = dsa_tag_driver_get_by_name(name);\n\tkfree(name);\n\t \n\tif (IS_ERR(new_tag_ops))\n\t\treturn PTR_ERR(new_tag_ops);\n\n\tif (new_tag_ops == old_tag_ops)\n\t\t \n\t\tgoto out;\n\n\terr = dsa_tree_change_tag_proto(cpu_dp->ds->dst, new_tag_ops,\n\t\t\t\t\told_tag_ops);\n\tif (err) {\n\t\t \n\t\tdsa_tag_driver_put(new_tag_ops);\n\t\treturn err;\n\t}\n\n\t \nout:\n\tdsa_tag_driver_put(old_tag_ops);\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(tagging);\n\nstatic struct attribute *dsa_slave_attrs[] = {\n\t&dev_attr_tagging.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dsa_group = {\n\t.name\t= \"dsa\",\n\t.attrs\t= dsa_slave_attrs,\n};\n\nstatic void dsa_master_reset_mtu(struct net_device *dev)\n{\n\tint err;\n\n\terr = dev_set_mtu(dev, ETH_DATA_LEN);\n\tif (err)\n\t\tnetdev_dbg(dev,\n\t\t\t   \"Unable to reset MTU to exclude DSA overheads\\n\");\n}\n\nint dsa_master_setup(struct net_device *dev, struct dsa_port *cpu_dp)\n{\n\tconst struct dsa_device_ops *tag_ops = cpu_dp->tag_ops;\n\tstruct dsa_switch *ds = cpu_dp->ds;\n\tstruct device_link *consumer_link;\n\tint mtu, ret;\n\n\tmtu = ETH_DATA_LEN + dsa_tag_protocol_overhead(tag_ops);\n\n\t \n\tif (!netif_is_lag_master(dev)) {\n\t\tconsumer_link = device_link_add(ds->dev, dev->dev.parent,\n\t\t\t\t\t\tDL_FLAG_AUTOREMOVE_CONSUMER);\n\t\tif (!consumer_link)\n\t\t\tnetdev_err(dev,\n\t\t\t\t   \"Failed to create a device link to DSA switch %s\\n\",\n\t\t\t\t   dev_name(ds->dev));\n\t}\n\n\t \n\tret = dev_set_mtu(dev, mtu);\n\tif (ret)\n\t\tnetdev_warn(dev, \"error %d setting MTU to %d to include DSA overhead\\n\",\n\t\t\t    ret, mtu);\n\n\t \n\twmb();\n\n\tdev->dsa_ptr = cpu_dp;\n\n\tdsa_master_set_promiscuity(dev, 1);\n\n\tret = dsa_master_ethtool_setup(dev);\n\tif (ret)\n\t\tgoto out_err_reset_promisc;\n\n\tret = sysfs_create_group(&dev->dev.kobj, &dsa_group);\n\tif (ret)\n\t\tgoto out_err_ethtool_teardown;\n\n\treturn ret;\n\nout_err_ethtool_teardown:\n\tdsa_master_ethtool_teardown(dev);\nout_err_reset_promisc:\n\tdsa_master_set_promiscuity(dev, -1);\n\treturn ret;\n}\n\nvoid dsa_master_teardown(struct net_device *dev)\n{\n\tsysfs_remove_group(&dev->dev.kobj, &dsa_group);\n\tdsa_master_ethtool_teardown(dev);\n\tdsa_master_reset_mtu(dev);\n\tdsa_master_set_promiscuity(dev, -1);\n\n\tdev->dsa_ptr = NULL;\n\n\t \n\twmb();\n}\n\nint dsa_master_lag_setup(struct net_device *lag_dev, struct dsa_port *cpu_dp,\n\t\t\t struct netdev_lag_upper_info *uinfo,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tbool master_setup = false;\n\tint err;\n\n\tif (!netdev_uses_dsa(lag_dev)) {\n\t\terr = dsa_master_setup(lag_dev, cpu_dp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmaster_setup = true;\n\t}\n\n\terr = dsa_port_lag_join(cpu_dp, lag_dev, uinfo, extack);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_WEAK_MOD(extack, \"CPU port failed to join LAG\");\n\t\tgoto out_master_teardown;\n\t}\n\n\treturn 0;\n\nout_master_teardown:\n\tif (master_setup)\n\t\tdsa_master_teardown(lag_dev);\n\treturn err;\n}\n\n \nvoid dsa_master_lag_teardown(struct net_device *lag_dev,\n\t\t\t     struct dsa_port *cpu_dp)\n{\n\tstruct net_device *upper;\n\tstruct list_head *iter;\n\n\tdsa_port_lag_leave(cpu_dp, lag_dev);\n\n\tnetdev_for_each_upper_dev_rcu(lag_dev, upper, iter)\n\t\tif (dsa_slave_dev_check(upper))\n\t\t\treturn;\n\n\tdsa_master_teardown(lag_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}