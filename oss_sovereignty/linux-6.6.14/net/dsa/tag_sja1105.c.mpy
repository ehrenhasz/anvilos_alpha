{
  "module_name": "tag_sja1105.c",
  "hash_id": "7b2d38bbe8e9a3fb61e7780ab763b01e80d804a227a4337de23a93ef6fb30d91",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag_sja1105.c",
  "human_readable_source": "\n \n#include <linux/if_vlan.h>\n#include <linux/dsa/sja1105.h>\n#include <linux/dsa/8021q.h>\n#include <linux/packing.h>\n\n#include \"tag.h\"\n#include \"tag_8021q.h\"\n\n#define SJA1105_NAME\t\t\t\t\"sja1105\"\n#define SJA1110_NAME\t\t\t\t\"sja1110\"\n\n \n#define SJA1110_HEADER_HOST_TO_SWITCH\t\tBIT(15)\n\n \n#define SJA1110_RX_HEADER_IS_METADATA\t\tBIT(14)\n#define SJA1110_RX_HEADER_HOST_ONLY\t\tBIT(13)\n#define SJA1110_RX_HEADER_HAS_TRAILER\t\tBIT(12)\n\n \n#define SJA1110_RX_HEADER_SRC_PORT(x)\t\t(((x) & GENMASK(7, 4)) >> 4)\n#define SJA1110_RX_HEADER_SWITCH_ID(x)\t\t((x) & GENMASK(3, 0))\n\n \n#define SJA1110_RX_HEADER_TRAILER_POS(x)\t((x) & GENMASK(11, 0))\n\n#define SJA1110_RX_TRAILER_SWITCH_ID(x)\t\t(((x) & GENMASK(7, 4)) >> 4)\n#define SJA1110_RX_TRAILER_SRC_PORT(x)\t\t((x) & GENMASK(3, 0))\n\n \n#define SJA1110_RX_HEADER_N_TS(x)\t\t(((x) & GENMASK(8, 4)) >> 4)\n\n \n#define SJA1110_TX_HEADER_UPDATE_TC\t\tBIT(14)\n#define SJA1110_TX_HEADER_TAKE_TS\t\tBIT(13)\n#define SJA1110_TX_HEADER_TAKE_TS_CASC\t\tBIT(12)\n#define SJA1110_TX_HEADER_HAS_TRAILER\t\tBIT(11)\n\n \n#define SJA1110_TX_HEADER_PRIO(x)\t\t(((x) << 7) & GENMASK(10, 7))\n#define SJA1110_TX_HEADER_TSTAMP_ID(x)\t\t((x) & GENMASK(7, 0))\n\n \n#define SJA1110_TX_HEADER_TRAILER_POS(x)\t((x) & GENMASK(10, 0))\n\n#define SJA1110_TX_TRAILER_TSTAMP_ID(x)\t\t(((x) << 24) & GENMASK(31, 24))\n#define SJA1110_TX_TRAILER_PRIO(x)\t\t(((x) << 21) & GENMASK(23, 21))\n#define SJA1110_TX_TRAILER_SWITCHID(x)\t\t(((x) << 12) & GENMASK(15, 12))\n#define SJA1110_TX_TRAILER_DESTPORTS(x)\t\t(((x) << 1) & GENMASK(11, 1))\n\n#define SJA1110_META_TSTAMP_SIZE\t\t10\n\n#define SJA1110_HEADER_LEN\t\t\t4\n#define SJA1110_RX_TRAILER_LEN\t\t\t13\n#define SJA1110_TX_TRAILER_LEN\t\t\t4\n#define SJA1110_MAX_PADDING_LEN\t\t\t15\n\nstruct sja1105_tagger_private {\n\tstruct sja1105_tagger_data data;  \n\t \n\tspinlock_t meta_lock;\n\tstruct sk_buff *stampable_skb;\n\tstruct kthread_worker *xmit_worker;\n};\n\nstatic struct sja1105_tagger_private *\nsja1105_tagger_private(struct dsa_switch *ds)\n{\n\treturn ds->tagger_data;\n}\n\n \nstatic inline bool sja1105_is_link_local(const struct sk_buff *skb)\n{\n\tconst struct ethhdr *hdr = eth_hdr(skb);\n\tu64 dmac = ether_addr_to_u64(hdr->h_dest);\n\n\tif (ntohs(hdr->h_proto) == ETH_P_SJA1105_META)\n\t\treturn false;\n\tif ((dmac & SJA1105_LINKLOCAL_FILTER_A_MASK) ==\n\t\t    SJA1105_LINKLOCAL_FILTER_A)\n\t\treturn true;\n\tif ((dmac & SJA1105_LINKLOCAL_FILTER_B_MASK) ==\n\t\t    SJA1105_LINKLOCAL_FILTER_B)\n\t\treturn true;\n\treturn false;\n}\n\nstruct sja1105_meta {\n\tu64 tstamp;\n\tu64 dmac_byte_4;\n\tu64 dmac_byte_3;\n\tu64 source_port;\n\tu64 switch_id;\n};\n\nstatic void sja1105_meta_unpack(const struct sk_buff *skb,\n\t\t\t\tstruct sja1105_meta *meta)\n{\n\tu8 *buf = skb_mac_header(skb) + ETH_HLEN;\n\n\t \n\tpacking(buf,     &meta->tstamp,     31, 0, 4, UNPACK, 0);\n\tpacking(buf + 4, &meta->dmac_byte_3, 7, 0, 1, UNPACK, 0);\n\tpacking(buf + 5, &meta->dmac_byte_4, 7, 0, 1, UNPACK, 0);\n\tpacking(buf + 6, &meta->source_port, 7, 0, 1, UNPACK, 0);\n\tpacking(buf + 7, &meta->switch_id,   7, 0, 1, UNPACK, 0);\n}\n\nstatic inline bool sja1105_is_meta_frame(const struct sk_buff *skb)\n{\n\tconst struct ethhdr *hdr = eth_hdr(skb);\n\tu64 smac = ether_addr_to_u64(hdr->h_source);\n\tu64 dmac = ether_addr_to_u64(hdr->h_dest);\n\n\tif (smac != SJA1105_META_SMAC)\n\t\treturn false;\n\tif (dmac != SJA1105_META_DMAC)\n\t\treturn false;\n\tif (ntohs(hdr->h_proto) != ETH_P_SJA1105_META)\n\t\treturn false;\n\treturn true;\n}\n\n \nstatic struct sk_buff *sja1105_defer_xmit(struct dsa_port *dp,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct sja1105_tagger_data *tagger_data = sja1105_tagger_data(dp->ds);\n\tstruct sja1105_tagger_private *priv = sja1105_tagger_private(dp->ds);\n\tvoid (*xmit_work_fn)(struct kthread_work *work);\n\tstruct sja1105_deferred_xmit_work *xmit_work;\n\tstruct kthread_worker *xmit_worker;\n\n\txmit_work_fn = tagger_data->xmit_work_fn;\n\txmit_worker = priv->xmit_worker;\n\n\tif (!xmit_work_fn || !xmit_worker)\n\t\treturn NULL;\n\n\txmit_work = kzalloc(sizeof(*xmit_work), GFP_ATOMIC);\n\tif (!xmit_work)\n\t\treturn NULL;\n\n\tkthread_init_work(&xmit_work->work, xmit_work_fn);\n\t \n\txmit_work->dp = dp;\n\txmit_work->skb = skb_get(skb);\n\n\tkthread_queue_work(xmit_worker, &xmit_work->work);\n\n\treturn NULL;\n}\n\n \nstatic u16 sja1105_xmit_tpid(struct dsa_port *dp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_port *other_dp;\n\tu16 proto;\n\n\t \n\tif (!dsa_port_is_vlan_filtering(dp))\n\t\treturn ETH_P_SJA1105;\n\n\t \n\tdsa_switch_for_each_port(other_dp, ds) {\n\t\tstruct net_device *br = dsa_port_bridge_dev_get(other_dp);\n\n\t\tif (!br)\n\t\t\tcontinue;\n\n\t\t \n\t\tbr_vlan_get_proto(br, &proto);\n\n\t\treturn proto;\n\t}\n\n\tWARN_ONCE(1, \"Port is VLAN-aware but cannot find associated bridge!\\n\");\n\n\treturn ETH_P_SJA1105;\n}\n\nstatic struct sk_buff *sja1105_imprecise_xmit(struct sk_buff *skb,\n\t\t\t\t\t      struct net_device *netdev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(netdev);\n\tunsigned int bridge_num = dsa_port_bridge_num_get(dp);\n\tstruct net_device *br = dsa_port_bridge_dev_get(dp);\n\tu16 tx_vid;\n\n\t \n\tif (br_vlan_enabled(br))\n\t\treturn skb;\n\n\t \n\ttx_vid = dsa_tag_8021q_bridge_vid(bridge_num);\n\n\treturn dsa_8021q_xmit(skb, netdev, sja1105_xmit_tpid(dp), tx_vid);\n}\n\n \nstatic struct sk_buff *sja1105_pvid_tag_control_pkt(struct dsa_port *dp,\n\t\t\t\t\t\t    struct sk_buff *skb, u8 pcp)\n{\n\t__be16 xmit_tpid = htons(sja1105_xmit_tpid(dp));\n\tstruct vlan_ethhdr *hdr;\n\n\t \n\tif (unlikely(skb_vlan_tag_present(skb))) {\n\t\tskb = __vlan_hwaccel_push_inside(skb);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t}\n\n\thdr = skb_vlan_eth_hdr(skb);\n\n\t \n\tif (hdr->h_vlan_proto == xmit_tpid)\n\t\treturn skb;\n\n\treturn vlan_insert_tag(skb, xmit_tpid, (pcp << VLAN_PRIO_SHIFT) |\n\t\t\t       SJA1105_DEFAULT_VLAN);\n}\n\nstatic struct sk_buff *sja1105_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *netdev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(netdev);\n\tu16 queue_mapping = skb_get_queue_mapping(skb);\n\tu8 pcp = netdev_txq_to_tc(netdev, queue_mapping);\n\tu16 tx_vid = dsa_tag_8021q_standalone_vid(dp);\n\n\tif (skb->offload_fwd_mark)\n\t\treturn sja1105_imprecise_xmit(skb, netdev);\n\n\t \n\tif (unlikely(sja1105_is_link_local(skb))) {\n\t\tskb = sja1105_pvid_tag_control_pkt(dp, skb, pcp);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\n\t\treturn sja1105_defer_xmit(dp, skb);\n\t}\n\n\treturn dsa_8021q_xmit(skb, netdev, sja1105_xmit_tpid(dp),\n\t\t\t     ((pcp << VLAN_PRIO_SHIFT) | tx_vid));\n}\n\nstatic struct sk_buff *sja1110_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *netdev)\n{\n\tstruct sk_buff *clone = SJA1105_SKB_CB(skb)->clone;\n\tstruct dsa_port *dp = dsa_slave_to_port(netdev);\n\tu16 queue_mapping = skb_get_queue_mapping(skb);\n\tu8 pcp = netdev_txq_to_tc(netdev, queue_mapping);\n\tu16 tx_vid = dsa_tag_8021q_standalone_vid(dp);\n\t__be32 *tx_trailer;\n\t__be16 *tx_header;\n\tint trailer_pos;\n\n\tif (skb->offload_fwd_mark)\n\t\treturn sja1105_imprecise_xmit(skb, netdev);\n\n\t \n\tif (likely(!sja1105_is_link_local(skb)))\n\t\treturn dsa_8021q_xmit(skb, netdev, sja1105_xmit_tpid(dp),\n\t\t\t\t     ((pcp << VLAN_PRIO_SHIFT) | tx_vid));\n\n\tskb = sja1105_pvid_tag_control_pkt(dp, skb, pcp);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_push(skb, SJA1110_HEADER_LEN);\n\n\tdsa_alloc_etype_header(skb, SJA1110_HEADER_LEN);\n\n\ttrailer_pos = skb->len;\n\n\ttx_header = dsa_etype_header_pos_tx(skb);\n\ttx_trailer = skb_put(skb, SJA1110_TX_TRAILER_LEN);\n\n\ttx_header[0] = htons(ETH_P_SJA1110);\n\ttx_header[1] = htons(SJA1110_HEADER_HOST_TO_SWITCH |\n\t\t\t     SJA1110_TX_HEADER_HAS_TRAILER |\n\t\t\t     SJA1110_TX_HEADER_TRAILER_POS(trailer_pos));\n\t*tx_trailer = cpu_to_be32(SJA1110_TX_TRAILER_PRIO(pcp) |\n\t\t\t\t  SJA1110_TX_TRAILER_SWITCHID(dp->ds->index) |\n\t\t\t\t  SJA1110_TX_TRAILER_DESTPORTS(BIT(dp->index)));\n\tif (clone) {\n\t\tu8 ts_id = SJA1105_SKB_CB(clone)->ts_id;\n\n\t\ttx_header[1] |= htons(SJA1110_TX_HEADER_TAKE_TS);\n\t\t*tx_trailer |= cpu_to_be32(SJA1110_TX_TRAILER_TSTAMP_ID(ts_id));\n\t}\n\n\treturn skb;\n}\n\nstatic void sja1105_transfer_meta(struct sk_buff *skb,\n\t\t\t\t  const struct sja1105_meta *meta)\n{\n\tstruct ethhdr *hdr = eth_hdr(skb);\n\n\thdr->h_dest[3] = meta->dmac_byte_3;\n\thdr->h_dest[4] = meta->dmac_byte_4;\n\tSJA1105_SKB_CB(skb)->tstamp = meta->tstamp;\n}\n\n \nstatic struct sk_buff\n*sja1105_rcv_meta_state_machine(struct sk_buff *skb,\n\t\t\t\tstruct sja1105_meta *meta,\n\t\t\t\tbool is_link_local,\n\t\t\t\tbool is_meta)\n{\n\t \n\tif (is_link_local) {\n\t\tstruct dsa_port *dp = dsa_slave_to_port(skb->dev);\n\t\tstruct sja1105_tagger_private *priv;\n\t\tstruct dsa_switch *ds = dp->ds;\n\n\t\tpriv = sja1105_tagger_private(ds);\n\n\t\tspin_lock(&priv->meta_lock);\n\t\t \n\t\tif (priv->stampable_skb) {\n\t\t\tdev_err_ratelimited(ds->dev,\n\t\t\t\t\t    \"Expected meta frame, is %12llx \"\n\t\t\t\t\t    \"in the DSA master multicast filter?\\n\",\n\t\t\t\t\t    SJA1105_META_DMAC);\n\t\t\tkfree_skb(priv->stampable_skb);\n\t\t}\n\n\t\t \n\t\tpriv->stampable_skb = skb_get(skb);\n\t\tspin_unlock(&priv->meta_lock);\n\n\t\t \n\t\treturn NULL;\n\n\t \n\t} else if (is_meta) {\n\t\tstruct dsa_port *dp = dsa_slave_to_port(skb->dev);\n\t\tstruct sja1105_tagger_private *priv;\n\t\tstruct dsa_switch *ds = dp->ds;\n\t\tstruct sk_buff *stampable_skb;\n\n\t\tpriv = sja1105_tagger_private(ds);\n\n\t\tspin_lock(&priv->meta_lock);\n\n\t\tstampable_skb = priv->stampable_skb;\n\t\tpriv->stampable_skb = NULL;\n\n\t\t \n\t\tif (!stampable_skb) {\n\t\t\tdev_err_ratelimited(ds->dev,\n\t\t\t\t\t    \"Unexpected meta frame\\n\");\n\t\t\tspin_unlock(&priv->meta_lock);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (stampable_skb->dev != skb->dev) {\n\t\t\tdev_err_ratelimited(ds->dev,\n\t\t\t\t\t    \"Meta frame on wrong port\\n\");\n\t\t\tspin_unlock(&priv->meta_lock);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tkfree_skb(skb);\n\t\tskb = stampable_skb;\n\t\tsja1105_transfer_meta(skb, meta);\n\n\t\tspin_unlock(&priv->meta_lock);\n\t}\n\n\treturn skb;\n}\n\nstatic bool sja1105_skb_has_tag_8021q(const struct sk_buff *skb)\n{\n\tu16 tpid = ntohs(eth_hdr(skb)->h_proto);\n\n\treturn tpid == ETH_P_SJA1105 || tpid == ETH_P_8021Q ||\n\t       skb_vlan_tag_present(skb);\n}\n\nstatic bool sja1110_skb_has_inband_control_extension(const struct sk_buff *skb)\n{\n\treturn ntohs(eth_hdr(skb)->h_proto) == ETH_P_SJA1110;\n}\n\n \nstatic void sja1105_vlan_rcv(struct sk_buff *skb, int *source_port,\n\t\t\t     int *switch_id, int *vbid, u16 *vid)\n{\n\tstruct vlan_ethhdr *hdr = vlan_eth_hdr(skb);\n\tu16 vlan_tci;\n\n\tif (skb_vlan_tag_present(skb))\n\t\tvlan_tci = skb_vlan_tag_get(skb);\n\telse\n\t\tvlan_tci = ntohs(hdr->h_vlan_TCI);\n\n\tif (vid_is_dsa_8021q(vlan_tci & VLAN_VID_MASK))\n\t\treturn dsa_8021q_rcv(skb, source_port, switch_id, vbid);\n\n\t \n\t*vid = vlan_tci & VLAN_VID_MASK;\n}\n\nstatic struct sk_buff *sja1105_rcv(struct sk_buff *skb,\n\t\t\t\t   struct net_device *netdev)\n{\n\tint source_port = -1, switch_id = -1, vbid = -1;\n\tstruct sja1105_meta meta = {0};\n\tstruct ethhdr *hdr;\n\tbool is_link_local;\n\tbool is_meta;\n\tu16 vid;\n\n\thdr = eth_hdr(skb);\n\tis_link_local = sja1105_is_link_local(skb);\n\tis_meta = sja1105_is_meta_frame(skb);\n\n\tif (is_link_local) {\n\t\t \n\t\tsource_port = hdr->h_dest[3];\n\t\tswitch_id = hdr->h_dest[4];\n\t} else if (is_meta) {\n\t\tsja1105_meta_unpack(skb, &meta);\n\t\tsource_port = meta.source_port;\n\t\tswitch_id = meta.switch_id;\n\t}\n\n\t \n\tif (sja1105_skb_has_tag_8021q(skb)) {\n\t\tint tmp_source_port = -1, tmp_switch_id = -1;\n\n\t\tsja1105_vlan_rcv(skb, &tmp_source_port, &tmp_switch_id, &vbid,\n\t\t\t\t &vid);\n\t\t \n\t\tif (vbid == 0 && source_port == -1)\n\t\t\tsource_port = tmp_source_port;\n\t\tif (vbid == 0 && switch_id == -1)\n\t\t\tswitch_id = tmp_switch_id;\n\t} else if (source_port == -1 && switch_id == -1) {\n\t\t \n\t\treturn NULL;\n\t}\n\n\tif (source_port != -1 && switch_id != -1)\n\t\tskb->dev = dsa_master_find_slave(netdev, switch_id, source_port);\n\telse if (vbid >= 1)\n\t\tskb->dev = dsa_tag_8021q_find_port_by_vbid(netdev, vbid);\n\telse\n\t\tskb->dev = dsa_find_designated_bridge_port_by_vid(netdev, vid);\n\tif (!skb->dev) {\n\t\tnetdev_warn(netdev, \"Couldn't decode source port\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!is_link_local)\n\t\tdsa_default_offload_fwd_mark(skb);\n\n\treturn sja1105_rcv_meta_state_machine(skb, &meta, is_link_local,\n\t\t\t\t\t      is_meta);\n}\n\nstatic struct sk_buff *sja1110_rcv_meta(struct sk_buff *skb, u16 rx_header)\n{\n\tu8 *buf = dsa_etype_header_pos_rx(skb) + SJA1110_HEADER_LEN;\n\tint switch_id = SJA1110_RX_HEADER_SWITCH_ID(rx_header);\n\tint n_ts = SJA1110_RX_HEADER_N_TS(rx_header);\n\tstruct sja1105_tagger_data *tagger_data;\n\tstruct net_device *master = skb->dev;\n\tstruct dsa_port *cpu_dp;\n\tstruct dsa_switch *ds;\n\tint i;\n\n\tcpu_dp = master->dsa_ptr;\n\tds = dsa_switch_find(cpu_dp->dst->index, switch_id);\n\tif (!ds) {\n\t\tnet_err_ratelimited(\"%s: cannot find switch id %d\\n\",\n\t\t\t\t    master->name, switch_id);\n\t\treturn NULL;\n\t}\n\n\ttagger_data = sja1105_tagger_data(ds);\n\tif (!tagger_data->meta_tstamp_handler)\n\t\treturn NULL;\n\n\tfor (i = 0; i <= n_ts; i++) {\n\t\tu8 ts_id, source_port, dir;\n\t\tu64 tstamp;\n\n\t\tts_id = buf[0];\n\t\tsource_port = (buf[1] & GENMASK(7, 4)) >> 4;\n\t\tdir = (buf[1] & BIT(3)) >> 3;\n\t\ttstamp = be64_to_cpu(*(__be64 *)(buf + 2));\n\n\t\ttagger_data->meta_tstamp_handler(ds, source_port, ts_id, dir,\n\t\t\t\t\t\t tstamp);\n\n\t\tbuf += SJA1110_META_TSTAMP_SIZE;\n\t}\n\n\t \n\treturn NULL;\n}\n\nstatic struct sk_buff *sja1110_rcv_inband_control_extension(struct sk_buff *skb,\n\t\t\t\t\t\t\t    int *source_port,\n\t\t\t\t\t\t\t    int *switch_id,\n\t\t\t\t\t\t\t    bool *host_only)\n{\n\tu16 rx_header;\n\n\tif (unlikely(!pskb_may_pull(skb, SJA1110_HEADER_LEN)))\n\t\treturn NULL;\n\n\t \n\trx_header = ntohs(*(__be16 *)skb->data);\n\n\tif (rx_header & SJA1110_RX_HEADER_HOST_ONLY)\n\t\t*host_only = true;\n\n\tif (rx_header & SJA1110_RX_HEADER_IS_METADATA)\n\t\treturn sja1110_rcv_meta(skb, rx_header);\n\n\t \n\tif (rx_header & SJA1110_RX_HEADER_HAS_TRAILER) {\n\t\tint start_of_padding = SJA1110_RX_HEADER_TRAILER_POS(rx_header);\n\t\tu8 *rx_trailer = skb_tail_pointer(skb) - SJA1110_RX_TRAILER_LEN;\n\t\tu64 *tstamp = &SJA1105_SKB_CB(skb)->tstamp;\n\t\tu8 last_byte = rx_trailer[12];\n\n\t\t \n\t\tpacking(rx_trailer, tstamp, 63, 0, 8, UNPACK, 0);\n\n\t\t*source_port = SJA1110_RX_TRAILER_SRC_PORT(last_byte);\n\t\t*switch_id = SJA1110_RX_TRAILER_SWITCH_ID(last_byte);\n\n\t\t \n\t\tif (pskb_trim_rcsum(skb, start_of_padding - ETH_HLEN))\n\t\t\treturn NULL;\n\t \n\t} else {\n\t\t*source_port = SJA1110_RX_HEADER_SRC_PORT(rx_header);\n\t\t*switch_id = SJA1110_RX_HEADER_SWITCH_ID(rx_header);\n\t}\n\n\t \n\tskb_pull_rcsum(skb, SJA1110_HEADER_LEN);\n\n\tdsa_strip_etype_header(skb, SJA1110_HEADER_LEN);\n\n\t \n\tskb_set_mac_header(skb, -ETH_HLEN);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *sja1110_rcv(struct sk_buff *skb,\n\t\t\t\t   struct net_device *netdev)\n{\n\tint source_port = -1, switch_id = -1, vbid = -1;\n\tbool host_only = false;\n\tu16 vid = 0;\n\n\tif (sja1110_skb_has_inband_control_extension(skb)) {\n\t\tskb = sja1110_rcv_inband_control_extension(skb, &source_port,\n\t\t\t\t\t\t\t   &switch_id,\n\t\t\t\t\t\t\t   &host_only);\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t}\n\n\t \n\tif (likely(sja1105_skb_has_tag_8021q(skb)))\n\t\tsja1105_vlan_rcv(skb, &source_port, &switch_id, &vbid, &vid);\n\n\tif (vbid >= 1)\n\t\tskb->dev = dsa_tag_8021q_find_port_by_vbid(netdev, vbid);\n\telse if (source_port == -1 || switch_id == -1)\n\t\tskb->dev = dsa_find_designated_bridge_port_by_vid(netdev, vid);\n\telse\n\t\tskb->dev = dsa_master_find_slave(netdev, switch_id, source_port);\n\tif (!skb->dev) {\n\t\tnetdev_warn(netdev, \"Couldn't decode source port\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!host_only)\n\t\tdsa_default_offload_fwd_mark(skb);\n\n\treturn skb;\n}\n\nstatic void sja1105_flow_dissect(const struct sk_buff *skb, __be16 *proto,\n\t\t\t\t int *offset)\n{\n\t \n\tif (unlikely(sja1105_is_link_local(skb)))\n\t\treturn;\n\n\tdsa_tag_generic_flow_dissect(skb, proto, offset);\n}\n\nstatic void sja1110_flow_dissect(const struct sk_buff *skb, __be16 *proto,\n\t\t\t\t int *offset)\n{\n\t \n\tif (unlikely(sja1105_is_link_local(skb)))\n\t\treturn dsa_tag_generic_flow_dissect(skb, proto, offset);\n\n\t \n\t*offset = VLAN_HLEN;\n\t*proto = ((__be16 *)skb->data)[(VLAN_HLEN / 2) - 1];\n}\n\nstatic void sja1105_disconnect(struct dsa_switch *ds)\n{\n\tstruct sja1105_tagger_private *priv = ds->tagger_data;\n\n\tkthread_destroy_worker(priv->xmit_worker);\n\tkfree(priv);\n\tds->tagger_data = NULL;\n}\n\nstatic int sja1105_connect(struct dsa_switch *ds)\n{\n\tstruct sja1105_tagger_private *priv;\n\tstruct kthread_worker *xmit_worker;\n\tint err;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->meta_lock);\n\n\txmit_worker = kthread_create_worker(0, \"dsa%d:%d_xmit\",\n\t\t\t\t\t    ds->dst->index, ds->index);\n\tif (IS_ERR(xmit_worker)) {\n\t\terr = PTR_ERR(xmit_worker);\n\t\tkfree(priv);\n\t\treturn err;\n\t}\n\n\tpriv->xmit_worker = xmit_worker;\n\tds->tagger_data = priv;\n\n\treturn 0;\n}\n\nstatic const struct dsa_device_ops sja1105_netdev_ops = {\n\t.name = SJA1105_NAME,\n\t.proto = DSA_TAG_PROTO_SJA1105,\n\t.xmit = sja1105_xmit,\n\t.rcv = sja1105_rcv,\n\t.connect = sja1105_connect,\n\t.disconnect = sja1105_disconnect,\n\t.needed_headroom = VLAN_HLEN,\n\t.flow_dissect = sja1105_flow_dissect,\n\t.promisc_on_master = true,\n};\n\nDSA_TAG_DRIVER(sja1105_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_SJA1105, SJA1105_NAME);\n\nstatic const struct dsa_device_ops sja1110_netdev_ops = {\n\t.name = SJA1110_NAME,\n\t.proto = DSA_TAG_PROTO_SJA1110,\n\t.xmit = sja1110_xmit,\n\t.rcv = sja1110_rcv,\n\t.connect = sja1105_connect,\n\t.disconnect = sja1105_disconnect,\n\t.flow_dissect = sja1110_flow_dissect,\n\t.needed_headroom = SJA1110_HEADER_LEN + VLAN_HLEN,\n\t.needed_tailroom = SJA1110_RX_TRAILER_LEN + SJA1110_MAX_PADDING_LEN,\n};\n\nDSA_TAG_DRIVER(sja1110_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_SJA1110, SJA1110_NAME);\n\nstatic struct dsa_tag_driver *sja1105_tag_driver_array[] = {\n\t&DSA_TAG_DRIVER_NAME(sja1105_netdev_ops),\n\t&DSA_TAG_DRIVER_NAME(sja1110_netdev_ops),\n};\n\nmodule_dsa_tag_drivers(sja1105_tag_driver_array);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}