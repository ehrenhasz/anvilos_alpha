{
  "module_name": "tag_rtl8_4.c",
  "hash_id": "8181370e116ea45154dd6dba8cfb5113350ec885139da753e5907519e3bf9180",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag_rtl8_4.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/etherdevice.h>\n\n#include \"tag.h\"\n\n \n\n#define RTL8_4_NAME\t\t\t\"rtl8_4\"\n#define RTL8_4T_NAME\t\t\t\"rtl8_4t\"\n\n#define RTL8_4_TAG_LEN\t\t\t8\n\n#define RTL8_4_PROTOCOL\t\t\tGENMASK(15, 8)\n#define   RTL8_4_PROTOCOL_RTL8365MB\t0x04\n#define RTL8_4_REASON\t\t\tGENMASK(7, 0)\n#define   RTL8_4_REASON_FORWARD\t\t0\n#define   RTL8_4_REASON_TRAP\t\t80\n\n#define RTL8_4_LEARN_DIS\t\tBIT(5)\n\n#define RTL8_4_TX\t\t\tGENMASK(3, 0)\n#define RTL8_4_RX\t\t\tGENMASK(10, 0)\n\nstatic void rtl8_4_write_tag(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     void *tag)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\t__be16 tag16[RTL8_4_TAG_LEN / 2];\n\n\t \n\ttag16[0] = htons(ETH_P_REALTEK);\n\n\t \n\ttag16[1] = htons(FIELD_PREP(RTL8_4_PROTOCOL, RTL8_4_PROTOCOL_RTL8365MB));\n\n\t \n\ttag16[2] = htons(FIELD_PREP(RTL8_4_LEARN_DIS, 1));\n\n\t \n\ttag16[3] = htons(FIELD_PREP(RTL8_4_RX, BIT(dp->index)));\n\n\tmemcpy(tag, tag16, RTL8_4_TAG_LEN);\n}\n\nstatic struct sk_buff *rtl8_4_tag_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev)\n{\n\tskb_push(skb, RTL8_4_TAG_LEN);\n\n\tdsa_alloc_etype_header(skb, RTL8_4_TAG_LEN);\n\n\trtl8_4_write_tag(skb, dev, dsa_etype_header_pos_tx(skb));\n\n\treturn skb;\n}\n\nstatic struct sk_buff *rtl8_4t_tag_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\t \n\tif (skb->ip_summed == CHECKSUM_PARTIAL && skb_checksum_help(skb))\n\t\treturn NULL;\n\n\trtl8_4_write_tag(skb, dev, skb_put(skb, RTL8_4_TAG_LEN));\n\n\treturn skb;\n}\n\nstatic int rtl8_4_read_tag(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   void *tag)\n{\n\t__be16 tag16[RTL8_4_TAG_LEN / 2];\n\tu16 etype;\n\tu8 reason;\n\tu8 proto;\n\tu8 port;\n\n\tmemcpy(tag16, tag, RTL8_4_TAG_LEN);\n\n\t \n\tetype = ntohs(tag16[0]);\n\tif (unlikely(etype != ETH_P_REALTEK)) {\n\t\tdev_warn_ratelimited(&dev->dev,\n\t\t\t\t     \"non-realtek ethertype 0x%04x\\n\", etype);\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tproto = FIELD_GET(RTL8_4_PROTOCOL, ntohs(tag16[1]));\n\tif (unlikely(proto != RTL8_4_PROTOCOL_RTL8365MB)) {\n\t\tdev_warn_ratelimited(&dev->dev,\n\t\t\t\t     \"unknown realtek protocol 0x%02x\\n\",\n\t\t\t\t     proto);\n\t\treturn -EPROTO;\n\t}\n\n\t \n\treason = FIELD_GET(RTL8_4_REASON, ntohs(tag16[1]));\n\n\t \n\tport = FIELD_GET(RTL8_4_TX, ntohs(tag16[3]));\n\tskb->dev = dsa_master_find_slave(dev, 0, port);\n\tif (!skb->dev) {\n\t\tdev_warn_ratelimited(&dev->dev,\n\t\t\t\t     \"could not find slave for port %d\\n\",\n\t\t\t\t     port);\n\t\treturn -ENOENT;\n\t}\n\n\tif (reason != RTL8_4_REASON_TRAP)\n\t\tdsa_default_offload_fwd_mark(skb);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *rtl8_4_tag_rcv(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tif (unlikely(!pskb_may_pull(skb, RTL8_4_TAG_LEN)))\n\t\treturn NULL;\n\n\tif (unlikely(rtl8_4_read_tag(skb, dev, dsa_etype_header_pos_rx(skb))))\n\t\treturn NULL;\n\n\t \n\tskb_pull_rcsum(skb, RTL8_4_TAG_LEN);\n\n\tdsa_strip_etype_header(skb, RTL8_4_TAG_LEN);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *rtl8_4t_tag_rcv(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev)\n{\n\tif (skb_linearize(skb))\n\t\treturn NULL;\n\n\tif (unlikely(rtl8_4_read_tag(skb, dev, skb_tail_pointer(skb) - RTL8_4_TAG_LEN)))\n\t\treturn NULL;\n\n\tif (pskb_trim_rcsum(skb, skb->len - RTL8_4_TAG_LEN))\n\t\treturn NULL;\n\n\treturn skb;\n}\n\n \nstatic const struct dsa_device_ops rtl8_4_netdev_ops = {\n\t.name = \"rtl8_4\",\n\t.proto = DSA_TAG_PROTO_RTL8_4,\n\t.xmit = rtl8_4_tag_xmit,\n\t.rcv = rtl8_4_tag_rcv,\n\t.needed_headroom = RTL8_4_TAG_LEN,\n};\n\nDSA_TAG_DRIVER(rtl8_4_netdev_ops);\n\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_RTL8_4, RTL8_4_NAME);\n\n \nstatic const struct dsa_device_ops rtl8_4t_netdev_ops = {\n\t.name = \"rtl8_4t\",\n\t.proto = DSA_TAG_PROTO_RTL8_4T,\n\t.xmit = rtl8_4t_tag_xmit,\n\t.rcv = rtl8_4t_tag_rcv,\n\t.needed_tailroom = RTL8_4_TAG_LEN,\n};\n\nDSA_TAG_DRIVER(rtl8_4t_netdev_ops);\n\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_RTL8_4T, RTL8_4T_NAME);\n\nstatic struct dsa_tag_driver *dsa_tag_drivers[] = {\n\t&DSA_TAG_DRIVER_NAME(rtl8_4_netdev_ops),\n\t&DSA_TAG_DRIVER_NAME(rtl8_4t_netdev_ops),\n};\nmodule_dsa_tag_drivers(dsa_tag_drivers);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}