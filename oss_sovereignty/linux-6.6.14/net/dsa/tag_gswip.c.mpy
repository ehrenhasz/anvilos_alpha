{
  "module_name": "tag_gswip.c",
  "hash_id": "c8b2412564758e80d2381c56268bf08da1899b35219cbce7aeab89c4cf4a72f4",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag_gswip.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <net/dsa.h>\n\n#include \"tag.h\"\n\n#define GSWIP_NAME\t\t\t\"gswip\"\n\n#define GSWIP_TX_HEADER_LEN\t\t4\n\n \n \n#define GSWIP_TX_SLPID_SHIFT\t\t0\t \n#define  GSWIP_TX_SLPID_CPU\t\t2\n#define  GSWIP_TX_SLPID_APP1\t\t3\n#define  GSWIP_TX_SLPID_APP2\t\t4\n#define  GSWIP_TX_SLPID_APP3\t\t5\n#define  GSWIP_TX_SLPID_APP4\t\t6\n#define  GSWIP_TX_SLPID_APP5\t\t7\n\n \n#define GSWIP_TX_CRCGEN_DIS\t\tBIT(7)\n#define GSWIP_TX_DPID_SHIFT\t\t0\t \n#define  GSWIP_TX_DPID_ELAN\t\t0\n#define  GSWIP_TX_DPID_EWAN\t\t1\n#define  GSWIP_TX_DPID_CPU\t\t2\n#define  GSWIP_TX_DPID_APP1\t\t3\n#define  GSWIP_TX_DPID_APP2\t\t4\n#define  GSWIP_TX_DPID_APP3\t\t5\n#define  GSWIP_TX_DPID_APP4\t\t6\n#define  GSWIP_TX_DPID_APP5\t\t7\n\n \n#define GSWIP_TX_PORT_MAP_EN\t\tBIT(7)\n#define GSWIP_TX_PORT_MAP_SEL\t\tBIT(6)\n#define GSWIP_TX_LRN_DIS\t\tBIT(5)\n#define GSWIP_TX_CLASS_EN\t\tBIT(4)\n#define GSWIP_TX_CLASS_SHIFT\t\t0\n#define GSWIP_TX_CLASS_MASK\t\tGENMASK(3, 0)\n\n \n#define GSWIP_TX_DPID_EN\t\tBIT(0)\n#define GSWIP_TX_PORT_MAP_SHIFT\t\t1\n#define GSWIP_TX_PORT_MAP_MASK\t\tGENMASK(6, 1)\n\n#define GSWIP_RX_HEADER_LEN\t8\n\n \n \n#define GSWIP_RX_SPPID_SHIFT\t\t4\n#define GSWIP_RX_SPPID_MASK\t\tGENMASK(6, 4)\n\nstatic struct sk_buff *gswip_tag_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tu8 *gswip_tag;\n\n\tskb_push(skb, GSWIP_TX_HEADER_LEN);\n\n\tgswip_tag = skb->data;\n\tgswip_tag[0] = GSWIP_TX_SLPID_CPU;\n\tgswip_tag[1] = GSWIP_TX_DPID_ELAN;\n\tgswip_tag[2] = GSWIP_TX_PORT_MAP_EN | GSWIP_TX_PORT_MAP_SEL;\n\tgswip_tag[3] = BIT(dp->index + GSWIP_TX_PORT_MAP_SHIFT) & GSWIP_TX_PORT_MAP_MASK;\n\tgswip_tag[3] |= GSWIP_TX_DPID_EN;\n\n\treturn skb;\n}\n\nstatic struct sk_buff *gswip_tag_rcv(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tint port;\n\tu8 *gswip_tag;\n\n\tif (unlikely(!pskb_may_pull(skb, GSWIP_RX_HEADER_LEN)))\n\t\treturn NULL;\n\n\tgswip_tag = skb->data - ETH_HLEN;\n\n\t \n\tport = (gswip_tag[7] & GSWIP_RX_SPPID_MASK) >> GSWIP_RX_SPPID_SHIFT;\n\tskb->dev = dsa_master_find_slave(dev, 0, port);\n\tif (!skb->dev)\n\t\treturn NULL;\n\n\t \n\tskb_pull_rcsum(skb, GSWIP_RX_HEADER_LEN);\n\n\treturn skb;\n}\n\nstatic const struct dsa_device_ops gswip_netdev_ops = {\n\t.name = GSWIP_NAME,\n\t.proto\t= DSA_TAG_PROTO_GSWIP,\n\t.xmit = gswip_tag_xmit,\n\t.rcv = gswip_tag_rcv,\n\t.needed_headroom = GSWIP_RX_HEADER_LEN,\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_GSWIP, GSWIP_NAME);\n\nmodule_dsa_tag_driver(gswip_netdev_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}