{
  "module_name": "port.c",
  "hash_id": "457fe700caf3f43237a4b075afe05eb3b895b308238c99bc54deb1d323c90508",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/port.c",
  "human_readable_source": "\n \n\n#include <linux/if_bridge.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n\n#include \"dsa.h\"\n#include \"port.h\"\n#include \"slave.h\"\n#include \"switch.h\"\n#include \"tag_8021q.h\"\n\n \nstatic int dsa_port_notify(const struct dsa_port *dp, unsigned long e, void *v)\n{\n\treturn dsa_tree_notify(dp->ds->dst, e, v);\n}\n\nstatic void dsa_port_notify_bridge_fdb_flush(const struct dsa_port *dp, u16 vid)\n{\n\tstruct net_device *brport_dev = dsa_port_to_bridge_port(dp);\n\tstruct switchdev_notifier_fdb_info info = {\n\t\t.vid = vid,\n\t};\n\n\t \n\tif (!brport_dev)\n\t\treturn;\n\n\tcall_switchdev_notifiers(SWITCHDEV_FDB_FLUSH_TO_BRIDGE,\n\t\t\t\t brport_dev, &info.info, NULL);\n}\n\nstatic void dsa_port_fast_age(const struct dsa_port *dp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->port_fast_age)\n\t\treturn;\n\n\tds->ops->port_fast_age(ds, dp->index);\n\n\t \n\tdsa_port_notify_bridge_fdb_flush(dp, 0);\n}\n\nstatic int dsa_port_vlan_fast_age(const struct dsa_port *dp, u16 vid)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tint err;\n\n\tif (!ds->ops->port_vlan_fast_age)\n\t\treturn -EOPNOTSUPP;\n\n\terr = ds->ops->port_vlan_fast_age(ds, dp->index, vid);\n\n\tif (!err)\n\t\tdsa_port_notify_bridge_fdb_flush(dp, vid);\n\n\treturn err;\n}\n\nstatic int dsa_port_msti_fast_age(const struct dsa_port *dp, u16 msti)\n{\n\tDECLARE_BITMAP(vids, VLAN_N_VID) = { 0 };\n\tint err, vid;\n\n\terr = br_mst_get_info(dsa_port_bridge_dev_get(dp), msti, vids);\n\tif (err)\n\t\treturn err;\n\n\tfor_each_set_bit(vid, vids, VLAN_N_VID) {\n\t\terr = dsa_port_vlan_fast_age(dp, vid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic bool dsa_port_can_configure_learning(struct dsa_port *dp)\n{\n\tstruct switchdev_brport_flags flags = {\n\t\t.mask = BR_LEARNING,\n\t};\n\tstruct dsa_switch *ds = dp->ds;\n\tint err;\n\n\tif (!ds->ops->port_bridge_flags || !ds->ops->port_pre_bridge_flags)\n\t\treturn false;\n\n\terr = ds->ops->port_pre_bridge_flags(ds, dp->index, flags, NULL);\n\treturn !err;\n}\n\nbool dsa_port_supports_hwtstamp(struct dsa_port *dp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct ifreq ifr = {};\n\tint err;\n\n\tif (!ds->ops->port_hwtstamp_get || !ds->ops->port_hwtstamp_set)\n\t\treturn false;\n\n\t \n\terr = ds->ops->port_hwtstamp_get(ds, dp->index, &ifr);\n\treturn err != -EOPNOTSUPP;\n}\n\nint dsa_port_set_state(struct dsa_port *dp, u8 state, bool do_fast_age)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tint port = dp->index;\n\n\tif (!ds->ops->port_stp_state_set)\n\t\treturn -EOPNOTSUPP;\n\n\tds->ops->port_stp_state_set(ds, port, state);\n\n\tif (!dsa_port_can_configure_learning(dp) ||\n\t    (do_fast_age && dp->learning)) {\n\t\t \n\n\t\tif ((dp->stp_state == BR_STATE_LEARNING ||\n\t\t     dp->stp_state == BR_STATE_FORWARDING) &&\n\t\t    (state == BR_STATE_DISABLED ||\n\t\t     state == BR_STATE_BLOCKING ||\n\t\t     state == BR_STATE_LISTENING))\n\t\t\tdsa_port_fast_age(dp);\n\t}\n\n\tdp->stp_state = state;\n\n\treturn 0;\n}\n\nstatic void dsa_port_set_state_now(struct dsa_port *dp, u8 state,\n\t\t\t\t   bool do_fast_age)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tint err;\n\n\terr = dsa_port_set_state(dp, state, do_fast_age);\n\tif (err && err != -EOPNOTSUPP) {\n\t\tdev_err(ds->dev, \"port %d failed to set STP state %u: %pe\\n\",\n\t\t\tdp->index, state, ERR_PTR(err));\n\t}\n}\n\nint dsa_port_set_mst_state(struct dsa_port *dp,\n\t\t\t   const struct switchdev_mst_state *state,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tu8 prev_state;\n\tint err;\n\n\tif (!ds->ops->port_mst_state_set)\n\t\treturn -EOPNOTSUPP;\n\n\terr = br_mst_get_state(dsa_port_to_bridge_port(dp), state->msti,\n\t\t\t       &prev_state);\n\tif (err)\n\t\treturn err;\n\n\terr = ds->ops->port_mst_state_set(ds, dp->index, state);\n\tif (err)\n\t\treturn err;\n\n\tif (!(dp->learning &&\n\t      (prev_state == BR_STATE_LEARNING ||\n\t       prev_state == BR_STATE_FORWARDING) &&\n\t      (state->state == BR_STATE_DISABLED ||\n\t       state->state == BR_STATE_BLOCKING ||\n\t       state->state == BR_STATE_LISTENING)))\n\t\treturn 0;\n\n\terr = dsa_port_msti_fast_age(dp, state->msti);\n\tif (err)\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Unable to flush associated VLANs\");\n\n\treturn 0;\n}\n\nint dsa_port_enable_rt(struct dsa_port *dp, struct phy_device *phy)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tint port = dp->index;\n\tint err;\n\n\tif (ds->ops->port_enable) {\n\t\terr = ds->ops->port_enable(ds, port, phy);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!dp->bridge)\n\t\tdsa_port_set_state_now(dp, BR_STATE_FORWARDING, false);\n\n\tif (dp->pl)\n\t\tphylink_start(dp->pl);\n\n\treturn 0;\n}\n\nint dsa_port_enable(struct dsa_port *dp, struct phy_device *phy)\n{\n\tint err;\n\n\trtnl_lock();\n\terr = dsa_port_enable_rt(dp, phy);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nvoid dsa_port_disable_rt(struct dsa_port *dp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tint port = dp->index;\n\n\tif (dp->pl)\n\t\tphylink_stop(dp->pl);\n\n\tif (!dp->bridge)\n\t\tdsa_port_set_state_now(dp, BR_STATE_DISABLED, false);\n\n\tif (ds->ops->port_disable)\n\t\tds->ops->port_disable(ds, port);\n}\n\nvoid dsa_port_disable(struct dsa_port *dp)\n{\n\trtnl_lock();\n\tdsa_port_disable_rt(dp);\n\trtnl_unlock();\n}\n\nstatic void dsa_port_reset_vlan_filtering(struct dsa_port *dp,\n\t\t\t\t\t  struct dsa_bridge bridge)\n{\n\tstruct netlink_ext_ack extack = {0};\n\tbool change_vlan_filtering = false;\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_port *other_dp;\n\tbool vlan_filtering;\n\tint err;\n\n\tif (ds->needs_standalone_vlan_filtering &&\n\t    !br_vlan_enabled(bridge.dev)) {\n\t\tchange_vlan_filtering = true;\n\t\tvlan_filtering = true;\n\t} else if (!ds->needs_standalone_vlan_filtering &&\n\t\t   br_vlan_enabled(bridge.dev)) {\n\t\tchange_vlan_filtering = true;\n\t\tvlan_filtering = false;\n\t}\n\n\t \n\tif (change_vlan_filtering && ds->vlan_filtering_is_global) {\n\t\tdsa_switch_for_each_port(other_dp, ds) {\n\t\t\tstruct net_device *br = dsa_port_bridge_dev_get(other_dp);\n\n\t\t\tif (br && br_vlan_enabled(br)) {\n\t\t\t\tchange_vlan_filtering = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!change_vlan_filtering)\n\t\treturn;\n\n\terr = dsa_port_vlan_filtering(dp, vlan_filtering, &extack);\n\tif (extack._msg) {\n\t\tdev_err(ds->dev, \"port %d: %s\\n\", dp->index,\n\t\t\textack._msg);\n\t}\n\tif (err && err != -EOPNOTSUPP) {\n\t\tdev_err(ds->dev,\n\t\t\t\"port %d failed to reset VLAN filtering to %d: %pe\\n\",\n\t\t       dp->index, vlan_filtering, ERR_PTR(err));\n\t}\n}\n\nstatic int dsa_port_inherit_brport_flags(struct dsa_port *dp,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tconst unsigned long mask = BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD |\n\t\t\t\t   BR_BCAST_FLOOD | BR_PORT_LOCKED;\n\tstruct net_device *brport_dev = dsa_port_to_bridge_port(dp);\n\tint flag, err;\n\n\tfor_each_set_bit(flag, &mask, 32) {\n\t\tstruct switchdev_brport_flags flags = {0};\n\n\t\tflags.mask = BIT(flag);\n\n\t\tif (br_port_flag_is_set(brport_dev, BIT(flag)))\n\t\t\tflags.val = BIT(flag);\n\n\t\terr = dsa_port_bridge_flags(dp, flags, extack);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void dsa_port_clear_brport_flags(struct dsa_port *dp)\n{\n\tconst unsigned long val = BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD;\n\tconst unsigned long mask = BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD |\n\t\t\t\t   BR_BCAST_FLOOD | BR_PORT_LOCKED;\n\tint flag, err;\n\n\tfor_each_set_bit(flag, &mask, 32) {\n\t\tstruct switchdev_brport_flags flags = {0};\n\n\t\tflags.mask = BIT(flag);\n\t\tflags.val = val & BIT(flag);\n\n\t\terr = dsa_port_bridge_flags(dp, flags, NULL);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\tdev_err(dp->ds->dev,\n\t\t\t\t\"failed to clear bridge port flag %lu: %pe\\n\",\n\t\t\t\tflags.val, ERR_PTR(err));\n\t}\n}\n\nstatic int dsa_port_switchdev_sync_attrs(struct dsa_port *dp,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net_device *brport_dev = dsa_port_to_bridge_port(dp);\n\tstruct net_device *br = dsa_port_bridge_dev_get(dp);\n\tint err;\n\n\terr = dsa_port_inherit_brport_flags(dp, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = dsa_port_set_state(dp, br_port_get_stp_state(brport_dev), false);\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\terr = dsa_port_vlan_filtering(dp, br_vlan_enabled(br), extack);\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\terr = dsa_port_ageing_time(dp, br_get_ageing_time(br));\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void dsa_port_switchdev_unsync_attrs(struct dsa_port *dp,\n\t\t\t\t\t    struct dsa_bridge bridge)\n{\n\t \n\tdsa_port_clear_brport_flags(dp);\n\n\t \n\tdsa_port_set_state_now(dp, BR_STATE_FORWARDING, true);\n\n\tdsa_port_reset_vlan_filtering(dp, bridge);\n\n\t \n}\n\nstatic int dsa_port_bridge_create(struct dsa_port *dp,\n\t\t\t\t  struct net_device *br,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_bridge *bridge;\n\n\tbridge = dsa_tree_bridge_find(ds->dst, br);\n\tif (bridge) {\n\t\trefcount_inc(&bridge->refcount);\n\t\tdp->bridge = bridge;\n\t\treturn 0;\n\t}\n\n\tbridge = kzalloc(sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\trefcount_set(&bridge->refcount, 1);\n\n\tbridge->dev = br;\n\n\tbridge->num = dsa_bridge_num_get(br, ds->max_num_bridges);\n\tif (ds->max_num_bridges && !bridge->num) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Range of offloadable bridges exceeded\");\n\t\tkfree(bridge);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdp->bridge = bridge;\n\n\treturn 0;\n}\n\nstatic void dsa_port_bridge_destroy(struct dsa_port *dp,\n\t\t\t\t    const struct net_device *br)\n{\n\tstruct dsa_bridge *bridge = dp->bridge;\n\n\tdp->bridge = NULL;\n\n\tif (!refcount_dec_and_test(&bridge->refcount))\n\t\treturn;\n\n\tif (bridge->num)\n\t\tdsa_bridge_num_put(br, bridge->num);\n\n\tkfree(bridge);\n}\n\nstatic bool dsa_port_supports_mst(struct dsa_port *dp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\n\treturn ds->ops->vlan_msti_set &&\n\t\tds->ops->port_mst_state_set &&\n\t\tds->ops->port_vlan_fast_age &&\n\t\tdsa_port_can_configure_learning(dp);\n}\n\nint dsa_port_bridge_join(struct dsa_port *dp, struct net_device *br,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct dsa_notifier_bridge_info info = {\n\t\t.dp = dp,\n\t\t.extack = extack,\n\t};\n\tstruct net_device *dev = dp->slave;\n\tstruct net_device *brport_dev;\n\tint err;\n\n\tif (br_mst_enabled(br) && !dsa_port_supports_mst(dp))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\terr = dsa_port_bridge_create(dp, br, extack);\n\tif (err)\n\t\treturn err;\n\n\tbrport_dev = dsa_port_to_bridge_port(dp);\n\n\tinfo.bridge = *dp->bridge;\n\terr = dsa_broadcast(DSA_NOTIFIER_BRIDGE_JOIN, &info);\n\tif (err)\n\t\tgoto out_rollback;\n\n\t \n\tdp->bridge->tx_fwd_offload = info.tx_fwd_offload;\n\n\terr = switchdev_bridge_port_offload(brport_dev, dev, dp,\n\t\t\t\t\t    &dsa_slave_switchdev_notifier,\n\t\t\t\t\t    &dsa_slave_switchdev_blocking_notifier,\n\t\t\t\t\t    dp->bridge->tx_fwd_offload, extack);\n\tif (err)\n\t\tgoto out_rollback_unbridge;\n\n\terr = dsa_port_switchdev_sync_attrs(dp, extack);\n\tif (err)\n\t\tgoto out_rollback_unoffload;\n\n\treturn 0;\n\nout_rollback_unoffload:\n\tswitchdev_bridge_port_unoffload(brport_dev, dp,\n\t\t\t\t\t&dsa_slave_switchdev_notifier,\n\t\t\t\t\t&dsa_slave_switchdev_blocking_notifier);\n\tdsa_flush_workqueue();\nout_rollback_unbridge:\n\tdsa_broadcast(DSA_NOTIFIER_BRIDGE_LEAVE, &info);\nout_rollback:\n\tdsa_port_bridge_destroy(dp, br);\n\treturn err;\n}\n\nvoid dsa_port_pre_bridge_leave(struct dsa_port *dp, struct net_device *br)\n{\n\tstruct net_device *brport_dev = dsa_port_to_bridge_port(dp);\n\n\t \n\tif (!brport_dev)\n\t\treturn;\n\n\tswitchdev_bridge_port_unoffload(brport_dev, dp,\n\t\t\t\t\t&dsa_slave_switchdev_notifier,\n\t\t\t\t\t&dsa_slave_switchdev_blocking_notifier);\n\n\tdsa_flush_workqueue();\n}\n\nvoid dsa_port_bridge_leave(struct dsa_port *dp, struct net_device *br)\n{\n\tstruct dsa_notifier_bridge_info info = {\n\t\t.dp = dp,\n\t};\n\tint err;\n\n\t \n\tif (!dp->bridge)\n\t\treturn;\n\n\tinfo.bridge = *dp->bridge;\n\n\t \n\tdsa_port_bridge_destroy(dp, br);\n\n\terr = dsa_broadcast(DSA_NOTIFIER_BRIDGE_LEAVE, &info);\n\tif (err)\n\t\tdev_err(dp->ds->dev,\n\t\t\t\"port %d failed to notify DSA_NOTIFIER_BRIDGE_LEAVE: %pe\\n\",\n\t\t\tdp->index, ERR_PTR(err));\n\n\tdsa_port_switchdev_unsync_attrs(dp, info.bridge);\n}\n\nint dsa_port_lag_change(struct dsa_port *dp,\n\t\t\tstruct netdev_lag_lower_state_info *linfo)\n{\n\tstruct dsa_notifier_lag_info info = {\n\t\t.dp = dp,\n\t};\n\tbool tx_enabled;\n\n\tif (!dp->lag)\n\t\treturn 0;\n\n\t \n\ttx_enabled = linfo->link_up && linfo->tx_enabled;\n\n\tif (tx_enabled == dp->lag_tx_enabled)\n\t\treturn 0;\n\n\tdp->lag_tx_enabled = tx_enabled;\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_LAG_CHANGE, &info);\n}\n\nstatic int dsa_port_lag_create(struct dsa_port *dp,\n\t\t\t       struct net_device *lag_dev)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_lag *lag;\n\n\tlag = dsa_tree_lag_find(ds->dst, lag_dev);\n\tif (lag) {\n\t\trefcount_inc(&lag->refcount);\n\t\tdp->lag = lag;\n\t\treturn 0;\n\t}\n\n\tlag = kzalloc(sizeof(*lag), GFP_KERNEL);\n\tif (!lag)\n\t\treturn -ENOMEM;\n\n\trefcount_set(&lag->refcount, 1);\n\tmutex_init(&lag->fdb_lock);\n\tINIT_LIST_HEAD(&lag->fdbs);\n\tlag->dev = lag_dev;\n\tdsa_lag_map(ds->dst, lag);\n\tdp->lag = lag;\n\n\treturn 0;\n}\n\nstatic void dsa_port_lag_destroy(struct dsa_port *dp)\n{\n\tstruct dsa_lag *lag = dp->lag;\n\n\tdp->lag = NULL;\n\tdp->lag_tx_enabled = false;\n\n\tif (!refcount_dec_and_test(&lag->refcount))\n\t\treturn;\n\n\tWARN_ON(!list_empty(&lag->fdbs));\n\tdsa_lag_unmap(dp->ds->dst, lag);\n\tkfree(lag);\n}\n\nint dsa_port_lag_join(struct dsa_port *dp, struct net_device *lag_dev,\n\t\t      struct netdev_lag_upper_info *uinfo,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct dsa_notifier_lag_info info = {\n\t\t.dp = dp,\n\t\t.info = uinfo,\n\t\t.extack = extack,\n\t};\n\tstruct net_device *bridge_dev;\n\tint err;\n\n\terr = dsa_port_lag_create(dp, lag_dev);\n\tif (err)\n\t\tgoto err_lag_create;\n\n\tinfo.lag = *dp->lag;\n\terr = dsa_port_notify(dp, DSA_NOTIFIER_LAG_JOIN, &info);\n\tif (err)\n\t\tgoto err_lag_join;\n\n\tbridge_dev = netdev_master_upper_dev_get(lag_dev);\n\tif (!bridge_dev || !netif_is_bridge_master(bridge_dev))\n\t\treturn 0;\n\n\terr = dsa_port_bridge_join(dp, bridge_dev, extack);\n\tif (err)\n\t\tgoto err_bridge_join;\n\n\treturn 0;\n\nerr_bridge_join:\n\tdsa_port_notify(dp, DSA_NOTIFIER_LAG_LEAVE, &info);\nerr_lag_join:\n\tdsa_port_lag_destroy(dp);\nerr_lag_create:\n\treturn err;\n}\n\nvoid dsa_port_pre_lag_leave(struct dsa_port *dp, struct net_device *lag_dev)\n{\n\tstruct net_device *br = dsa_port_bridge_dev_get(dp);\n\n\tif (br)\n\t\tdsa_port_pre_bridge_leave(dp, br);\n}\n\nvoid dsa_port_lag_leave(struct dsa_port *dp, struct net_device *lag_dev)\n{\n\tstruct net_device *br = dsa_port_bridge_dev_get(dp);\n\tstruct dsa_notifier_lag_info info = {\n\t\t.dp = dp,\n\t};\n\tint err;\n\n\tif (!dp->lag)\n\t\treturn;\n\n\t \n\tif (br)\n\t\tdsa_port_bridge_leave(dp, br);\n\n\tinfo.lag = *dp->lag;\n\n\tdsa_port_lag_destroy(dp);\n\n\terr = dsa_port_notify(dp, DSA_NOTIFIER_LAG_LEAVE, &info);\n\tif (err)\n\t\tdev_err(dp->ds->dev,\n\t\t\t\"port %d failed to notify DSA_NOTIFIER_LAG_LEAVE: %pe\\n\",\n\t\t\tdp->index, ERR_PTR(err));\n}\n\n \nstatic bool dsa_port_can_apply_vlan_filtering(struct dsa_port *dp,\n\t\t\t\t\t      bool vlan_filtering,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_port *other_dp;\n\tint err;\n\n\t \n\tif (vlan_filtering && dsa_port_is_user(dp)) {\n\t\tstruct net_device *br = dsa_port_bridge_dev_get(dp);\n\t\tstruct net_device *upper_dev, *slave = dp->slave;\n\t\tstruct list_head *iter;\n\n\t\tnetdev_for_each_upper_dev_rcu(slave, upper_dev, iter) {\n\t\t\tstruct bridge_vlan_info br_info;\n\t\t\tu16 vid;\n\n\t\t\tif (!is_vlan_dev(upper_dev))\n\t\t\t\tcontinue;\n\n\t\t\tvid = vlan_dev_vlan_id(upper_dev);\n\n\t\t\t \n\t\t\terr = br_vlan_get_info(br, vid, &br_info);\n\t\t\tif (err == 0) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Must first remove VLAN uppers having VIDs also present in bridge\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ds->vlan_filtering_is_global)\n\t\treturn true;\n\n\t \n\tdsa_switch_for_each_port(other_dp, ds) {\n\t\tstruct net_device *other_br = dsa_port_bridge_dev_get(other_dp);\n\n\t\t \n\t\tif (!other_br || other_br == dsa_port_bridge_dev_get(dp))\n\t\t\tcontinue;\n\n\t\tif (br_vlan_enabled(other_br) != vlan_filtering) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"VLAN filtering is a global setting\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint dsa_port_vlan_filtering(struct dsa_port *dp, bool vlan_filtering,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tbool old_vlan_filtering = dsa_port_is_vlan_filtering(dp);\n\tstruct dsa_switch *ds = dp->ds;\n\tbool apply;\n\tint err;\n\n\tif (!ds->ops->port_vlan_filtering)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\trcu_read_lock();\n\tapply = dsa_port_can_apply_vlan_filtering(dp, vlan_filtering, extack);\n\trcu_read_unlock();\n\tif (!apply)\n\t\treturn -EINVAL;\n\n\tif (dsa_port_is_vlan_filtering(dp) == vlan_filtering)\n\t\treturn 0;\n\n\terr = ds->ops->port_vlan_filtering(ds, dp->index, vlan_filtering,\n\t\t\t\t\t   extack);\n\tif (err)\n\t\treturn err;\n\n\tif (ds->vlan_filtering_is_global) {\n\t\tstruct dsa_port *other_dp;\n\n\t\tds->vlan_filtering = vlan_filtering;\n\n\t\tdsa_switch_for_each_user_port(other_dp, ds) {\n\t\t\tstruct net_device *slave = other_dp->slave;\n\n\t\t\t \n\t\t\tif (!slave)\n\t\t\t\tcontinue;\n\n\t\t\terr = dsa_slave_manage_vlan_filtering(slave,\n\t\t\t\t\t\t\t      vlan_filtering);\n\t\t\tif (err)\n\t\t\t\tgoto restore;\n\t\t}\n\t} else {\n\t\tdp->vlan_filtering = vlan_filtering;\n\n\t\terr = dsa_slave_manage_vlan_filtering(dp->slave,\n\t\t\t\t\t\t      vlan_filtering);\n\t\tif (err)\n\t\t\tgoto restore;\n\t}\n\n\treturn 0;\n\nrestore:\n\tds->ops->port_vlan_filtering(ds, dp->index, old_vlan_filtering, NULL);\n\n\tif (ds->vlan_filtering_is_global)\n\t\tds->vlan_filtering = old_vlan_filtering;\n\telse\n\t\tdp->vlan_filtering = old_vlan_filtering;\n\n\treturn err;\n}\n\n \nbool dsa_port_skip_vlan_configuration(struct dsa_port *dp)\n{\n\tstruct net_device *br = dsa_port_bridge_dev_get(dp);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!br)\n\t\treturn false;\n\n\treturn !ds->configure_vlan_while_not_filtering && !br_vlan_enabled(br);\n}\n\nint dsa_port_ageing_time(struct dsa_port *dp, clock_t ageing_clock)\n{\n\tunsigned long ageing_jiffies = clock_t_to_jiffies(ageing_clock);\n\tunsigned int ageing_time = jiffies_to_msecs(ageing_jiffies);\n\tstruct dsa_notifier_ageing_time_info info;\n\tint err;\n\n\tinfo.ageing_time = ageing_time;\n\n\terr = dsa_port_notify(dp, DSA_NOTIFIER_AGEING_TIME, &info);\n\tif (err)\n\t\treturn err;\n\n\tdp->ageing_time = ageing_time;\n\n\treturn 0;\n}\n\nint dsa_port_mst_enable(struct dsa_port *dp, bool on,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (on && !dsa_port_supports_mst(dp)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Hardware does not support MST\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint dsa_port_pre_bridge_flags(const struct dsa_port *dp,\n\t\t\t      struct switchdev_brport_flags flags,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->port_pre_bridge_flags)\n\t\treturn -EINVAL;\n\n\treturn ds->ops->port_pre_bridge_flags(ds, dp->index, flags, extack);\n}\n\nint dsa_port_bridge_flags(struct dsa_port *dp,\n\t\t\t  struct switchdev_brport_flags flags,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tint err;\n\n\tif (!ds->ops->port_bridge_flags)\n\t\treturn -EOPNOTSUPP;\n\n\terr = ds->ops->port_bridge_flags(ds, dp->index, flags, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (flags.mask & BR_LEARNING) {\n\t\tbool learning = flags.val & BR_LEARNING;\n\n\t\tif (learning == dp->learning)\n\t\t\treturn 0;\n\n\t\tif ((dp->learning && !learning) &&\n\t\t    (dp->stp_state == BR_STATE_LEARNING ||\n\t\t     dp->stp_state == BR_STATE_FORWARDING))\n\t\t\tdsa_port_fast_age(dp);\n\n\t\tdp->learning = learning;\n\t}\n\n\treturn 0;\n}\n\nvoid dsa_port_set_host_flood(struct dsa_port *dp, bool uc, bool mc)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->port_set_host_flood)\n\t\tds->ops->port_set_host_flood(ds, dp->index, uc, mc);\n}\n\nint dsa_port_vlan_msti(struct dsa_port *dp,\n\t\t       const struct switchdev_vlan_msti *msti)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->vlan_msti_set)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->vlan_msti_set(ds, *dp->bridge, msti);\n}\n\nint dsa_port_mtu_change(struct dsa_port *dp, int new_mtu)\n{\n\tstruct dsa_notifier_mtu_info info = {\n\t\t.dp = dp,\n\t\t.mtu = new_mtu,\n\t};\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_MTU, &info);\n}\n\nint dsa_port_fdb_add(struct dsa_port *dp, const unsigned char *addr,\n\t\t     u16 vid)\n{\n\tstruct dsa_notifier_fdb_info info = {\n\t\t.dp = dp,\n\t\t.addr = addr,\n\t\t.vid = vid,\n\t\t.db = {\n\t\t\t.type = DSA_DB_BRIDGE,\n\t\t\t.bridge = *dp->bridge,\n\t\t},\n\t};\n\n\t \n\tif (!dp->ds->fdb_isolation)\n\t\tinfo.db.bridge.num = 0;\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_FDB_ADD, &info);\n}\n\nint dsa_port_fdb_del(struct dsa_port *dp, const unsigned char *addr,\n\t\t     u16 vid)\n{\n\tstruct dsa_notifier_fdb_info info = {\n\t\t.dp = dp,\n\t\t.addr = addr,\n\t\t.vid = vid,\n\t\t.db = {\n\t\t\t.type = DSA_DB_BRIDGE,\n\t\t\t.bridge = *dp->bridge,\n\t\t},\n\t};\n\n\tif (!dp->ds->fdb_isolation)\n\t\tinfo.db.bridge.num = 0;\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_FDB_DEL, &info);\n}\n\nstatic int dsa_port_host_fdb_add(struct dsa_port *dp,\n\t\t\t\t const unsigned char *addr, u16 vid,\n\t\t\t\t struct dsa_db db)\n{\n\tstruct dsa_notifier_fdb_info info = {\n\t\t.dp = dp,\n\t\t.addr = addr,\n\t\t.vid = vid,\n\t\t.db = db,\n\t};\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_HOST_FDB_ADD, &info);\n}\n\nint dsa_port_standalone_host_fdb_add(struct dsa_port *dp,\n\t\t\t\t     const unsigned char *addr, u16 vid)\n{\n\tstruct dsa_db db = {\n\t\t.type = DSA_DB_PORT,\n\t\t.dp = dp,\n\t};\n\n\treturn dsa_port_host_fdb_add(dp, addr, vid, db);\n}\n\nint dsa_port_bridge_host_fdb_add(struct dsa_port *dp,\n\t\t\t\t const unsigned char *addr, u16 vid)\n{\n\tstruct net_device *master = dsa_port_to_master(dp);\n\tstruct dsa_db db = {\n\t\t.type = DSA_DB_BRIDGE,\n\t\t.bridge = *dp->bridge,\n\t};\n\tint err;\n\n\tif (!dp->ds->fdb_isolation)\n\t\tdb.bridge.num = 0;\n\n\t \n\tif (master->priv_flags & IFF_UNICAST_FLT) {\n\t\terr = dev_uc_add(master, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn dsa_port_host_fdb_add(dp, addr, vid, db);\n}\n\nstatic int dsa_port_host_fdb_del(struct dsa_port *dp,\n\t\t\t\t const unsigned char *addr, u16 vid,\n\t\t\t\t struct dsa_db db)\n{\n\tstruct dsa_notifier_fdb_info info = {\n\t\t.dp = dp,\n\t\t.addr = addr,\n\t\t.vid = vid,\n\t\t.db = db,\n\t};\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_HOST_FDB_DEL, &info);\n}\n\nint dsa_port_standalone_host_fdb_del(struct dsa_port *dp,\n\t\t\t\t     const unsigned char *addr, u16 vid)\n{\n\tstruct dsa_db db = {\n\t\t.type = DSA_DB_PORT,\n\t\t.dp = dp,\n\t};\n\n\treturn dsa_port_host_fdb_del(dp, addr, vid, db);\n}\n\nint dsa_port_bridge_host_fdb_del(struct dsa_port *dp,\n\t\t\t\t const unsigned char *addr, u16 vid)\n{\n\tstruct net_device *master = dsa_port_to_master(dp);\n\tstruct dsa_db db = {\n\t\t.type = DSA_DB_BRIDGE,\n\t\t.bridge = *dp->bridge,\n\t};\n\tint err;\n\n\tif (!dp->ds->fdb_isolation)\n\t\tdb.bridge.num = 0;\n\n\tif (master->priv_flags & IFF_UNICAST_FLT) {\n\t\terr = dev_uc_del(master, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn dsa_port_host_fdb_del(dp, addr, vid, db);\n}\n\nint dsa_port_lag_fdb_add(struct dsa_port *dp, const unsigned char *addr,\n\t\t\t u16 vid)\n{\n\tstruct dsa_notifier_lag_fdb_info info = {\n\t\t.lag = dp->lag,\n\t\t.addr = addr,\n\t\t.vid = vid,\n\t\t.db = {\n\t\t\t.type = DSA_DB_BRIDGE,\n\t\t\t.bridge = *dp->bridge,\n\t\t},\n\t};\n\n\tif (!dp->ds->fdb_isolation)\n\t\tinfo.db.bridge.num = 0;\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_LAG_FDB_ADD, &info);\n}\n\nint dsa_port_lag_fdb_del(struct dsa_port *dp, const unsigned char *addr,\n\t\t\t u16 vid)\n{\n\tstruct dsa_notifier_lag_fdb_info info = {\n\t\t.lag = dp->lag,\n\t\t.addr = addr,\n\t\t.vid = vid,\n\t\t.db = {\n\t\t\t.type = DSA_DB_BRIDGE,\n\t\t\t.bridge = *dp->bridge,\n\t\t},\n\t};\n\n\tif (!dp->ds->fdb_isolation)\n\t\tinfo.db.bridge.num = 0;\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_LAG_FDB_DEL, &info);\n}\n\nint dsa_port_fdb_dump(struct dsa_port *dp, dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tint port = dp->index;\n\n\tif (!ds->ops->port_fdb_dump)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->port_fdb_dump(ds, port, cb, data);\n}\n\nint dsa_port_mdb_add(const struct dsa_port *dp,\n\t\t     const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct dsa_notifier_mdb_info info = {\n\t\t.dp = dp,\n\t\t.mdb = mdb,\n\t\t.db = {\n\t\t\t.type = DSA_DB_BRIDGE,\n\t\t\t.bridge = *dp->bridge,\n\t\t},\n\t};\n\n\tif (!dp->ds->fdb_isolation)\n\t\tinfo.db.bridge.num = 0;\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_MDB_ADD, &info);\n}\n\nint dsa_port_mdb_del(const struct dsa_port *dp,\n\t\t     const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct dsa_notifier_mdb_info info = {\n\t\t.dp = dp,\n\t\t.mdb = mdb,\n\t\t.db = {\n\t\t\t.type = DSA_DB_BRIDGE,\n\t\t\t.bridge = *dp->bridge,\n\t\t},\n\t};\n\n\tif (!dp->ds->fdb_isolation)\n\t\tinfo.db.bridge.num = 0;\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_MDB_DEL, &info);\n}\n\nstatic int dsa_port_host_mdb_add(const struct dsa_port *dp,\n\t\t\t\t const struct switchdev_obj_port_mdb *mdb,\n\t\t\t\t struct dsa_db db)\n{\n\tstruct dsa_notifier_mdb_info info = {\n\t\t.dp = dp,\n\t\t.mdb = mdb,\n\t\t.db = db,\n\t};\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_HOST_MDB_ADD, &info);\n}\n\nint dsa_port_standalone_host_mdb_add(const struct dsa_port *dp,\n\t\t\t\t     const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct dsa_db db = {\n\t\t.type = DSA_DB_PORT,\n\t\t.dp = dp,\n\t};\n\n\treturn dsa_port_host_mdb_add(dp, mdb, db);\n}\n\nint dsa_port_bridge_host_mdb_add(const struct dsa_port *dp,\n\t\t\t\t const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct net_device *master = dsa_port_to_master(dp);\n\tstruct dsa_db db = {\n\t\t.type = DSA_DB_BRIDGE,\n\t\t.bridge = *dp->bridge,\n\t};\n\tint err;\n\n\tif (!dp->ds->fdb_isolation)\n\t\tdb.bridge.num = 0;\n\n\terr = dev_mc_add(master, mdb->addr);\n\tif (err)\n\t\treturn err;\n\n\treturn dsa_port_host_mdb_add(dp, mdb, db);\n}\n\nstatic int dsa_port_host_mdb_del(const struct dsa_port *dp,\n\t\t\t\t const struct switchdev_obj_port_mdb *mdb,\n\t\t\t\t struct dsa_db db)\n{\n\tstruct dsa_notifier_mdb_info info = {\n\t\t.dp = dp,\n\t\t.mdb = mdb,\n\t\t.db = db,\n\t};\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_HOST_MDB_DEL, &info);\n}\n\nint dsa_port_standalone_host_mdb_del(const struct dsa_port *dp,\n\t\t\t\t     const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct dsa_db db = {\n\t\t.type = DSA_DB_PORT,\n\t\t.dp = dp,\n\t};\n\n\treturn dsa_port_host_mdb_del(dp, mdb, db);\n}\n\nint dsa_port_bridge_host_mdb_del(const struct dsa_port *dp,\n\t\t\t\t const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct net_device *master = dsa_port_to_master(dp);\n\tstruct dsa_db db = {\n\t\t.type = DSA_DB_BRIDGE,\n\t\t.bridge = *dp->bridge,\n\t};\n\tint err;\n\n\tif (!dp->ds->fdb_isolation)\n\t\tdb.bridge.num = 0;\n\n\terr = dev_mc_del(master, mdb->addr);\n\tif (err)\n\t\treturn err;\n\n\treturn dsa_port_host_mdb_del(dp, mdb, db);\n}\n\nint dsa_port_vlan_add(struct dsa_port *dp,\n\t\t      const struct switchdev_obj_port_vlan *vlan,\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct dsa_notifier_vlan_info info = {\n\t\t.dp = dp,\n\t\t.vlan = vlan,\n\t\t.extack = extack,\n\t};\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_VLAN_ADD, &info);\n}\n\nint dsa_port_vlan_del(struct dsa_port *dp,\n\t\t      const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct dsa_notifier_vlan_info info = {\n\t\t.dp = dp,\n\t\t.vlan = vlan,\n\t};\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_VLAN_DEL, &info);\n}\n\nint dsa_port_host_vlan_add(struct dsa_port *dp,\n\t\t\t   const struct switchdev_obj_port_vlan *vlan,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net_device *master = dsa_port_to_master(dp);\n\tstruct dsa_notifier_vlan_info info = {\n\t\t.dp = dp,\n\t\t.vlan = vlan,\n\t\t.extack = extack,\n\t};\n\tint err;\n\n\terr = dsa_port_notify(dp, DSA_NOTIFIER_HOST_VLAN_ADD, &info);\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\tvlan_vid_add(master, htons(ETH_P_8021Q), vlan->vid);\n\n\treturn err;\n}\n\nint dsa_port_host_vlan_del(struct dsa_port *dp,\n\t\t\t   const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct net_device *master = dsa_port_to_master(dp);\n\tstruct dsa_notifier_vlan_info info = {\n\t\t.dp = dp,\n\t\t.vlan = vlan,\n\t};\n\tint err;\n\n\terr = dsa_port_notify(dp, DSA_NOTIFIER_HOST_VLAN_DEL, &info);\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\tvlan_vid_del(master, htons(ETH_P_8021Q), vlan->vid);\n\n\treturn err;\n}\n\nint dsa_port_mrp_add(const struct dsa_port *dp,\n\t\t     const struct switchdev_obj_mrp *mrp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->port_mrp_add)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->port_mrp_add(ds, dp->index, mrp);\n}\n\nint dsa_port_mrp_del(const struct dsa_port *dp,\n\t\t     const struct switchdev_obj_mrp *mrp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->port_mrp_del)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->port_mrp_del(ds, dp->index, mrp);\n}\n\nint dsa_port_mrp_add_ring_role(const struct dsa_port *dp,\n\t\t\t       const struct switchdev_obj_ring_role_mrp *mrp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->port_mrp_add_ring_role)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->port_mrp_add_ring_role(ds, dp->index, mrp);\n}\n\nint dsa_port_mrp_del_ring_role(const struct dsa_port *dp,\n\t\t\t       const struct switchdev_obj_ring_role_mrp *mrp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->port_mrp_del_ring_role)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ds->ops->port_mrp_del_ring_role(ds, dp->index, mrp);\n}\n\nstatic int dsa_port_assign_master(struct dsa_port *dp,\n\t\t\t\t  struct net_device *master,\n\t\t\t\t  struct netlink_ext_ack *extack,\n\t\t\t\t  bool fail_on_err)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tint port = dp->index, err;\n\n\terr = ds->ops->port_change_master(ds, port, master, extack);\n\tif (err && !fail_on_err)\n\t\tdev_err(ds->dev, \"port %d failed to assign master %s: %pe\\n\",\n\t\t\tport, master->name, ERR_PTR(err));\n\n\tif (err && fail_on_err)\n\t\treturn err;\n\n\tdp->cpu_dp = master->dsa_ptr;\n\tdp->cpu_port_in_lag = netif_is_lag_master(master);\n\n\treturn 0;\n}\n\n \nint dsa_port_change_master(struct dsa_port *dp, struct net_device *master,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net_device *bridge_dev = dsa_port_bridge_dev_get(dp);\n\tstruct net_device *old_master = dsa_port_to_master(dp);\n\tstruct net_device *dev = dp->slave;\n\tstruct dsa_switch *ds = dp->ds;\n\tbool vlan_filtering;\n\tint err, tmp;\n\n\t \n\tif (bridge_dev) {\n\t\tdsa_port_pre_bridge_leave(dp, bridge_dev);\n\t\tdsa_port_bridge_leave(dp, bridge_dev);\n\t}\n\n\t \n\tvlan_filtering = dsa_port_is_vlan_filtering(dp);\n\tif (vlan_filtering) {\n\t\terr = dsa_slave_manage_vlan_filtering(dev, false);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Failed to remove standalone VLANs\");\n\t\t\tgoto rewind_old_bridge;\n\t\t}\n\t}\n\n\t \n\tdsa_slave_unsync_ha(dev);\n\n\terr = dsa_port_assign_master(dp, master, extack, true);\n\tif (err)\n\t\tgoto rewind_old_addrs;\n\n\tdsa_slave_sync_ha(dev);\n\n\tif (vlan_filtering) {\n\t\terr = dsa_slave_manage_vlan_filtering(dev, true);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Failed to restore standalone VLANs\");\n\t\t\tgoto rewind_new_addrs;\n\t\t}\n\t}\n\n\tif (bridge_dev) {\n\t\terr = dsa_port_bridge_join(dp, bridge_dev, extack);\n\t\tif (err && err == -EOPNOTSUPP) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Failed to reoffload bridge\");\n\t\t\tgoto rewind_new_vlan;\n\t\t}\n\t}\n\n\treturn 0;\n\nrewind_new_vlan:\n\tif (vlan_filtering)\n\t\tdsa_slave_manage_vlan_filtering(dev, false);\n\nrewind_new_addrs:\n\tdsa_slave_unsync_ha(dev);\n\n\tdsa_port_assign_master(dp, old_master, NULL, false);\n\n \nrewind_old_addrs:\n\tdsa_slave_sync_ha(dev);\n\n\tif (vlan_filtering) {\n\t\ttmp = dsa_slave_manage_vlan_filtering(dev, true);\n\t\tif (tmp) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"port %d failed to restore standalone VLANs: %pe\\n\",\n\t\t\t\tdp->index, ERR_PTR(tmp));\n\t\t}\n\t}\n\nrewind_old_bridge:\n\tif (bridge_dev) {\n\t\ttmp = dsa_port_bridge_join(dp, bridge_dev, extack);\n\t\tif (tmp) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"port %d failed to rejoin bridge %s: %pe\\n\",\n\t\t\t\tdp->index, bridge_dev->name, ERR_PTR(tmp));\n\t\t}\n\t}\n\n\treturn err;\n}\n\nvoid dsa_port_set_tag_protocol(struct dsa_port *cpu_dp,\n\t\t\t       const struct dsa_device_ops *tag_ops)\n{\n\tcpu_dp->rcv = tag_ops->rcv;\n\tcpu_dp->tag_ops = tag_ops;\n}\n\nstatic struct phy_device *dsa_port_get_phy_device(struct dsa_port *dp)\n{\n\tstruct device_node *phy_dn;\n\tstruct phy_device *phydev;\n\n\tphy_dn = of_parse_phandle(dp->dn, \"phy-handle\", 0);\n\tif (!phy_dn)\n\t\treturn NULL;\n\n\tphydev = of_phy_find_device(phy_dn);\n\tif (!phydev) {\n\t\tof_node_put(phy_dn);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tof_node_put(phy_dn);\n\treturn phydev;\n}\n\nstatic void dsa_port_phylink_validate(struct phylink_config *config,\n\t\t\t\t      unsigned long *supported,\n\t\t\t\t      struct phylink_link_state *state)\n{\n\t \n\tif (config->mac_capabilities)\n\t\tphylink_generic_validate(config, supported, state);\n}\n\nstatic struct phylink_pcs *\ndsa_port_phylink_mac_select_pcs(struct phylink_config *config,\n\t\t\t\tphy_interface_t interface)\n{\n\tstruct dsa_port *dp = container_of(config, struct dsa_port, pl_config);\n\tstruct phylink_pcs *pcs = ERR_PTR(-EOPNOTSUPP);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (ds->ops->phylink_mac_select_pcs)\n\t\tpcs = ds->ops->phylink_mac_select_pcs(ds, dp->index, interface);\n\n\treturn pcs;\n}\n\nstatic int dsa_port_phylink_mac_prepare(struct phylink_config *config,\n\t\t\t\t\tunsigned int mode,\n\t\t\t\t\tphy_interface_t interface)\n{\n\tstruct dsa_port *dp = container_of(config, struct dsa_port, pl_config);\n\tstruct dsa_switch *ds = dp->ds;\n\tint err = 0;\n\n\tif (ds->ops->phylink_mac_prepare)\n\t\terr = ds->ops->phylink_mac_prepare(ds, dp->index, mode,\n\t\t\t\t\t\t   interface);\n\n\treturn err;\n}\n\nstatic void dsa_port_phylink_mac_config(struct phylink_config *config,\n\t\t\t\t\tunsigned int mode,\n\t\t\t\t\tconst struct phylink_link_state *state)\n{\n\tstruct dsa_port *dp = container_of(config, struct dsa_port, pl_config);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->phylink_mac_config)\n\t\treturn;\n\n\tds->ops->phylink_mac_config(ds, dp->index, mode, state);\n}\n\nstatic int dsa_port_phylink_mac_finish(struct phylink_config *config,\n\t\t\t\t       unsigned int mode,\n\t\t\t\t       phy_interface_t interface)\n{\n\tstruct dsa_port *dp = container_of(config, struct dsa_port, pl_config);\n\tstruct dsa_switch *ds = dp->ds;\n\tint err = 0;\n\n\tif (ds->ops->phylink_mac_finish)\n\t\terr = ds->ops->phylink_mac_finish(ds, dp->index, mode,\n\t\t\t\t\t\t  interface);\n\n\treturn err;\n}\n\nstatic void dsa_port_phylink_mac_link_down(struct phylink_config *config,\n\t\t\t\t\t   unsigned int mode,\n\t\t\t\t\t   phy_interface_t interface)\n{\n\tstruct dsa_port *dp = container_of(config, struct dsa_port, pl_config);\n\tstruct phy_device *phydev = NULL;\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (dsa_port_is_user(dp))\n\t\tphydev = dp->slave->phydev;\n\n\tif (!ds->ops->phylink_mac_link_down) {\n\t\tif (ds->ops->adjust_link && phydev)\n\t\t\tds->ops->adjust_link(ds, dp->index, phydev);\n\t\treturn;\n\t}\n\n\tds->ops->phylink_mac_link_down(ds, dp->index, mode, interface);\n}\n\nstatic void dsa_port_phylink_mac_link_up(struct phylink_config *config,\n\t\t\t\t\t struct phy_device *phydev,\n\t\t\t\t\t unsigned int mode,\n\t\t\t\t\t phy_interface_t interface,\n\t\t\t\t\t int speed, int duplex,\n\t\t\t\t\t bool tx_pause, bool rx_pause)\n{\n\tstruct dsa_port *dp = container_of(config, struct dsa_port, pl_config);\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->phylink_mac_link_up) {\n\t\tif (ds->ops->adjust_link && phydev)\n\t\t\tds->ops->adjust_link(ds, dp->index, phydev);\n\t\treturn;\n\t}\n\n\tds->ops->phylink_mac_link_up(ds, dp->index, mode, interface, phydev,\n\t\t\t\t     speed, duplex, tx_pause, rx_pause);\n}\n\nstatic const struct phylink_mac_ops dsa_port_phylink_mac_ops = {\n\t.validate = dsa_port_phylink_validate,\n\t.mac_select_pcs = dsa_port_phylink_mac_select_pcs,\n\t.mac_prepare = dsa_port_phylink_mac_prepare,\n\t.mac_config = dsa_port_phylink_mac_config,\n\t.mac_finish = dsa_port_phylink_mac_finish,\n\t.mac_link_down = dsa_port_phylink_mac_link_down,\n\t.mac_link_up = dsa_port_phylink_mac_link_up,\n};\n\nint dsa_port_phylink_create(struct dsa_port *dp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tphy_interface_t mode;\n\tstruct phylink *pl;\n\tint err;\n\n\terr = of_get_phy_mode(dp->dn, &mode);\n\tif (err)\n\t\tmode = PHY_INTERFACE_MODE_NA;\n\n\tif (ds->ops->phylink_get_caps) {\n\t\tds->ops->phylink_get_caps(ds, dp->index, &dp->pl_config);\n\t} else {\n\t\t \n\t\tif (mode != PHY_INTERFACE_MODE_NA) {\n\t\t\t__set_bit(mode, dp->pl_config.supported_interfaces);\n\t\t} else {\n\t\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t\t  dp->pl_config.supported_interfaces);\n\t\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t\t  dp->pl_config.supported_interfaces);\n\t\t}\n\t}\n\n\tpl = phylink_create(&dp->pl_config, of_fwnode_handle(dp->dn),\n\t\t\t    mode, &dsa_port_phylink_mac_ops);\n\tif (IS_ERR(pl)) {\n\t\tpr_err(\"error creating PHYLINK: %ld\\n\", PTR_ERR(pl));\n\t\treturn PTR_ERR(pl);\n\t}\n\n\tdp->pl = pl;\n\n\treturn 0;\n}\n\nvoid dsa_port_phylink_destroy(struct dsa_port *dp)\n{\n\tphylink_destroy(dp->pl);\n\tdp->pl = NULL;\n}\n\nstatic int dsa_shared_port_setup_phy_of(struct dsa_port *dp, bool enable)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct phy_device *phydev;\n\tint port = dp->index;\n\tint err = 0;\n\n\tphydev = dsa_port_get_phy_device(dp);\n\tif (!phydev)\n\t\treturn 0;\n\n\tif (IS_ERR(phydev))\n\t\treturn PTR_ERR(phydev);\n\n\tif (enable) {\n\t\terr = genphy_resume(phydev);\n\t\tif (err < 0)\n\t\t\tgoto err_put_dev;\n\n\t\terr = genphy_read_status(phydev);\n\t\tif (err < 0)\n\t\t\tgoto err_put_dev;\n\t} else {\n\t\terr = genphy_suspend(phydev);\n\t\tif (err < 0)\n\t\t\tgoto err_put_dev;\n\t}\n\n\tif (ds->ops->adjust_link)\n\t\tds->ops->adjust_link(ds, port, phydev);\n\n\tdev_dbg(ds->dev, \"enabled port's phy: %s\", phydev_name(phydev));\n\nerr_put_dev:\n\tput_device(&phydev->mdio.dev);\n\treturn err;\n}\n\nstatic int dsa_shared_port_fixed_link_register_of(struct dsa_port *dp)\n{\n\tstruct device_node *dn = dp->dn;\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct phy_device *phydev;\n\tint port = dp->index;\n\tphy_interface_t mode;\n\tint err;\n\n\terr = of_phy_register_fixed_link(dn);\n\tif (err) {\n\t\tdev_err(ds->dev,\n\t\t\t\"failed to register the fixed PHY of port %d\\n\",\n\t\t\tport);\n\t\treturn err;\n\t}\n\n\tphydev = of_phy_find_device(dn);\n\n\terr = of_get_phy_mode(dn, &mode);\n\tif (err)\n\t\tmode = PHY_INTERFACE_MODE_NA;\n\tphydev->interface = mode;\n\n\tgenphy_read_status(phydev);\n\n\tif (ds->ops->adjust_link)\n\t\tds->ops->adjust_link(ds, port, phydev);\n\n\tput_device(&phydev->mdio.dev);\n\n\treturn 0;\n}\n\nstatic int dsa_shared_port_phylink_register(struct dsa_port *dp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct device_node *port_dn = dp->dn;\n\tint err;\n\n\tdp->pl_config.dev = ds->dev;\n\tdp->pl_config.type = PHYLINK_DEV;\n\n\terr = dsa_port_phylink_create(dp);\n\tif (err)\n\t\treturn err;\n\n\terr = phylink_of_phy_connect(dp->pl, port_dn, 0);\n\tif (err && err != -ENODEV) {\n\t\tpr_err(\"could not attach to PHY: %d\\n\", err);\n\t\tgoto err_phy_connect;\n\t}\n\n\treturn 0;\n\nerr_phy_connect:\n\tdsa_port_phylink_destroy(dp);\n\treturn err;\n}\n\n \nstatic const char * const dsa_switches_apply_workarounds[] = {\n#if IS_ENABLED(CONFIG_NET_DSA_XRS700X)\n\t\"arrow,xrs7003e\",\n\t\"arrow,xrs7003f\",\n\t\"arrow,xrs7004e\",\n\t\"arrow,xrs7004f\",\n#endif\n#if IS_ENABLED(CONFIG_B53)\n\t\"brcm,bcm5325\",\n\t\"brcm,bcm53115\",\n\t\"brcm,bcm53125\",\n\t\"brcm,bcm53128\",\n\t\"brcm,bcm5365\",\n\t\"brcm,bcm5389\",\n\t\"brcm,bcm5395\",\n\t\"brcm,bcm5397\",\n\t\"brcm,bcm5398\",\n\t\"brcm,bcm53010-srab\",\n\t\"brcm,bcm53011-srab\",\n\t\"brcm,bcm53012-srab\",\n\t\"brcm,bcm53018-srab\",\n\t\"brcm,bcm53019-srab\",\n\t\"brcm,bcm5301x-srab\",\n\t\"brcm,bcm11360-srab\",\n\t\"brcm,bcm58522-srab\",\n\t\"brcm,bcm58525-srab\",\n\t\"brcm,bcm58535-srab\",\n\t\"brcm,bcm58622-srab\",\n\t\"brcm,bcm58623-srab\",\n\t\"brcm,bcm58625-srab\",\n\t\"brcm,bcm88312-srab\",\n\t\"brcm,cygnus-srab\",\n\t\"brcm,nsp-srab\",\n\t\"brcm,omega-srab\",\n\t\"brcm,bcm3384-switch\",\n\t\"brcm,bcm6328-switch\",\n\t\"brcm,bcm6368-switch\",\n\t\"brcm,bcm63xx-switch\",\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA_BCM_SF2)\n\t\"brcm,bcm7445-switch-v4.0\",\n\t\"brcm,bcm7278-switch-v4.0\",\n\t\"brcm,bcm7278-switch-v4.8\",\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA_LANTIQ_GSWIP)\n\t\"lantiq,xrx200-gswip\",\n\t\"lantiq,xrx300-gswip\",\n\t\"lantiq,xrx330-gswip\",\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA_MV88E6060)\n\t\"marvell,mv88e6060\",\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA_MV88E6XXX)\n\t\"marvell,mv88e6085\",\n\t\"marvell,mv88e6190\",\n\t\"marvell,mv88e6250\",\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA_MICROCHIP_KSZ_COMMON)\n\t\"microchip,ksz8765\",\n\t\"microchip,ksz8794\",\n\t\"microchip,ksz8795\",\n\t\"microchip,ksz8863\",\n\t\"microchip,ksz8873\",\n\t\"microchip,ksz9477\",\n\t\"microchip,ksz9897\",\n\t\"microchip,ksz9893\",\n\t\"microchip,ksz9563\",\n\t\"microchip,ksz8563\",\n\t\"microchip,ksz9567\",\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA_SMSC_LAN9303_MDIO)\n\t\"smsc,lan9303-mdio\",\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA_SMSC_LAN9303_I2C)\n\t\"smsc,lan9303-i2c\",\n#endif\n\tNULL,\n};\n\nstatic void dsa_shared_port_validate_of(struct dsa_port *dp,\n\t\t\t\t\tbool *missing_phy_mode,\n\t\t\t\t\tbool *missing_link_description)\n{\n\tstruct device_node *dn = dp->dn, *phy_np;\n\tstruct dsa_switch *ds = dp->ds;\n\tphy_interface_t mode;\n\n\t*missing_phy_mode = false;\n\t*missing_link_description = false;\n\n\tif (of_get_phy_mode(dn, &mode)) {\n\t\t*missing_phy_mode = true;\n\t\tdev_err(ds->dev,\n\t\t\t\"OF node %pOF of %s port %d lacks the required \\\"phy-mode\\\" property\\n\",\n\t\t\tdn, dsa_port_is_cpu(dp) ? \"CPU\" : \"DSA\", dp->index);\n\t}\n\n\t \n\tif (of_phy_is_fixed_link(dn))\n\t\treturn;\n\n\tphy_np = of_parse_phandle(dn, \"phy-handle\", 0);\n\tif (phy_np) {\n\t\tof_node_put(phy_np);\n\t\treturn;\n\t}\n\n\t*missing_link_description = true;\n\n\tdev_err(ds->dev,\n\t\t\"OF node %pOF of %s port %d lacks the required \\\"phy-handle\\\", \\\"fixed-link\\\" or \\\"managed\\\" properties\\n\",\n\t\tdn, dsa_port_is_cpu(dp) ? \"CPU\" : \"DSA\", dp->index);\n}\n\nint dsa_shared_port_link_register_of(struct dsa_port *dp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tbool missing_link_description;\n\tbool missing_phy_mode;\n\tint port = dp->index;\n\n\tdsa_shared_port_validate_of(dp, &missing_phy_mode,\n\t\t\t\t    &missing_link_description);\n\n\tif ((missing_phy_mode || missing_link_description) &&\n\t    !of_device_compatible_match(ds->dev->of_node,\n\t\t\t\t\tdsa_switches_apply_workarounds))\n\t\treturn -EINVAL;\n\n\tif (!ds->ops->adjust_link) {\n\t\tif (missing_link_description) {\n\t\t\tdev_warn(ds->dev,\n\t\t\t\t \"Skipping phylink registration for %s port %d\\n\",\n\t\t\t\t dsa_port_is_cpu(dp) ? \"CPU\" : \"DSA\", dp->index);\n\t\t} else {\n\t\t\tif (ds->ops->phylink_mac_link_down)\n\t\t\t\tds->ops->phylink_mac_link_down(ds, port,\n\t\t\t\t\tMLO_AN_FIXED, PHY_INTERFACE_MODE_NA);\n\n\t\t\treturn dsa_shared_port_phylink_register(dp);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tdev_warn(ds->dev,\n\t\t \"Using legacy PHYLIB callbacks. Please migrate to PHYLINK!\\n\");\n\n\tif (of_phy_is_fixed_link(dp->dn))\n\t\treturn dsa_shared_port_fixed_link_register_of(dp);\n\telse\n\t\treturn dsa_shared_port_setup_phy_of(dp, true);\n}\n\nvoid dsa_shared_port_link_unregister_of(struct dsa_port *dp)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\n\tif (!ds->ops->adjust_link && dp->pl) {\n\t\trtnl_lock();\n\t\tphylink_disconnect_phy(dp->pl);\n\t\trtnl_unlock();\n\t\tdsa_port_phylink_destroy(dp);\n\t\treturn;\n\t}\n\n\tif (of_phy_is_fixed_link(dp->dn))\n\t\tof_phy_deregister_fixed_link(dp->dn);\n\telse\n\t\tdsa_shared_port_setup_phy_of(dp, false);\n}\n\nint dsa_port_hsr_join(struct dsa_port *dp, struct net_device *hsr)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tint err;\n\n\tif (!ds->ops->port_hsr_join)\n\t\treturn -EOPNOTSUPP;\n\n\tdp->hsr_dev = hsr;\n\n\terr = ds->ops->port_hsr_join(ds, dp->index, hsr);\n\tif (err)\n\t\tdp->hsr_dev = NULL;\n\n\treturn err;\n}\n\nvoid dsa_port_hsr_leave(struct dsa_port *dp, struct net_device *hsr)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tint err;\n\n\tdp->hsr_dev = NULL;\n\n\tif (ds->ops->port_hsr_leave) {\n\t\terr = ds->ops->port_hsr_leave(ds, dp->index, hsr);\n\t\tif (err)\n\t\t\tdev_err(dp->ds->dev,\n\t\t\t\t\"port %d failed to leave HSR %s: %pe\\n\",\n\t\t\t\tdp->index, hsr->name, ERR_PTR(err));\n\t}\n}\n\nint dsa_port_tag_8021q_vlan_add(struct dsa_port *dp, u16 vid, bool broadcast)\n{\n\tstruct dsa_notifier_tag_8021q_vlan_info info = {\n\t\t.dp = dp,\n\t\t.vid = vid,\n\t};\n\n\tif (broadcast)\n\t\treturn dsa_broadcast(DSA_NOTIFIER_TAG_8021Q_VLAN_ADD, &info);\n\n\treturn dsa_port_notify(dp, DSA_NOTIFIER_TAG_8021Q_VLAN_ADD, &info);\n}\n\nvoid dsa_port_tag_8021q_vlan_del(struct dsa_port *dp, u16 vid, bool broadcast)\n{\n\tstruct dsa_notifier_tag_8021q_vlan_info info = {\n\t\t.dp = dp,\n\t\t.vid = vid,\n\t};\n\tint err;\n\n\tif (broadcast)\n\t\terr = dsa_broadcast(DSA_NOTIFIER_TAG_8021Q_VLAN_DEL, &info);\n\telse\n\t\terr = dsa_port_notify(dp, DSA_NOTIFIER_TAG_8021Q_VLAN_DEL, &info);\n\tif (err)\n\t\tdev_err(dp->ds->dev,\n\t\t\t\"port %d failed to notify tag_8021q VLAN %d deletion: %pe\\n\",\n\t\t\tdp->index, vid, ERR_PTR(err));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}