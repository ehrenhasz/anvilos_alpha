{
  "module_name": "tag_ksz.c",
  "hash_id": "040fc1b2bd30b5b5a85b61796eed11a43769d71ffc97e5c8a11abce97777c42f",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag_ksz.c",
  "human_readable_source": "\n \n\n#include <linux/dsa/ksz_common.h>\n#include <linux/etherdevice.h>\n#include <linux/list.h>\n#include <linux/ptp_classify.h>\n#include <net/dsa.h>\n\n#include \"tag.h\"\n\n#define KSZ8795_NAME \"ksz8795\"\n#define KSZ9477_NAME \"ksz9477\"\n#define KSZ9893_NAME \"ksz9893\"\n#define LAN937X_NAME \"lan937x\"\n\n \n#define KSZ_PTP_TAG_LEN\t\t\t4\n#define KSZ_EGRESS_TAG_LEN\t\t1\n#define KSZ_INGRESS_TAG_LEN\t\t1\n\n#define KSZ_HWTS_EN  0\n\nstruct ksz_tagger_private {\n\tstruct ksz_tagger_data data;  \n\tunsigned long state;\n\tstruct kthread_worker *xmit_worker;\n};\n\nstatic struct ksz_tagger_private *\nksz_tagger_private(struct dsa_switch *ds)\n{\n\treturn ds->tagger_data;\n}\n\nstatic void ksz_hwtstamp_set_state(struct dsa_switch *ds, bool on)\n{\n\tstruct ksz_tagger_private *priv = ksz_tagger_private(ds);\n\n\tif (on)\n\t\tset_bit(KSZ_HWTS_EN, &priv->state);\n\telse\n\t\tclear_bit(KSZ_HWTS_EN, &priv->state);\n}\n\nstatic void ksz_disconnect(struct dsa_switch *ds)\n{\n\tstruct ksz_tagger_private *priv = ds->tagger_data;\n\n\tkthread_destroy_worker(priv->xmit_worker);\n\tkfree(priv);\n\tds->tagger_data = NULL;\n}\n\nstatic int ksz_connect(struct dsa_switch *ds)\n{\n\tstruct ksz_tagger_data *tagger_data;\n\tstruct kthread_worker *xmit_worker;\n\tstruct ksz_tagger_private *priv;\n\tint ret;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\txmit_worker = kthread_create_worker(0, \"dsa%d:%d_xmit\",\n\t\t\t\t\t    ds->dst->index, ds->index);\n\tif (IS_ERR(xmit_worker)) {\n\t\tret = PTR_ERR(xmit_worker);\n\t\tkfree(priv);\n\t\treturn ret;\n\t}\n\n\tpriv->xmit_worker = xmit_worker;\n\t \n\ttagger_data = &priv->data;\n\ttagger_data->hwtstamp_set_state = ksz_hwtstamp_set_state;\n\tds->tagger_data = priv;\n\n\treturn 0;\n}\n\nstatic struct sk_buff *ksz_common_rcv(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      unsigned int port, unsigned int len)\n{\n\tskb->dev = dsa_master_find_slave(dev, 0, port);\n\tif (!skb->dev)\n\t\treturn NULL;\n\n\tif (pskb_trim_rcsum(skb, skb->len - len))\n\t\treturn NULL;\n\n\tdsa_default_offload_fwd_mark(skb);\n\n\treturn skb;\n}\n\n \n\n#define KSZ8795_TAIL_TAG_OVERRIDE\tBIT(6)\n#define KSZ8795_TAIL_TAG_LOOKUP\t\tBIT(7)\n\nstatic struct sk_buff *ksz8795_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct ethhdr *hdr;\n\tu8 *tag;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL && skb_checksum_help(skb))\n\t\treturn NULL;\n\n\t \n\ttag = skb_put(skb, KSZ_INGRESS_TAG_LEN);\n\thdr = skb_eth_hdr(skb);\n\n\t*tag = 1 << dp->index;\n\tif (is_link_local_ether_addr(hdr->h_dest))\n\t\t*tag |= KSZ8795_TAIL_TAG_OVERRIDE;\n\n\treturn skb;\n}\n\nstatic struct sk_buff *ksz8795_rcv(struct sk_buff *skb, struct net_device *dev)\n{\n\tu8 *tag = skb_tail_pointer(skb) - KSZ_EGRESS_TAG_LEN;\n\n\treturn ksz_common_rcv(skb, dev, tag[0] & 7, KSZ_EGRESS_TAG_LEN);\n}\n\nstatic const struct dsa_device_ops ksz8795_netdev_ops = {\n\t.name\t= KSZ8795_NAME,\n\t.proto\t= DSA_TAG_PROTO_KSZ8795,\n\t.xmit\t= ksz8795_xmit,\n\t.rcv\t= ksz8795_rcv,\n\t.needed_tailroom = KSZ_INGRESS_TAG_LEN,\n};\n\nDSA_TAG_DRIVER(ksz8795_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_KSZ8795, KSZ8795_NAME);\n\n \n\n#define KSZ9477_INGRESS_TAG_LEN\t\t2\n#define KSZ9477_PTP_TAG_LEN\t\t4\n#define KSZ9477_PTP_TAG_INDICATION\t0x80\n\n#define KSZ9477_TAIL_TAG_PRIO\t\tGENMASK(8, 7)\n#define KSZ9477_TAIL_TAG_OVERRIDE\tBIT(9)\n#define KSZ9477_TAIL_TAG_LOOKUP\t\tBIT(10)\n\nstatic void ksz_rcv_timestamp(struct sk_buff *skb, u8 *tag)\n{\n\tu8 *tstamp_raw = tag - KSZ_PTP_TAG_LEN;\n\tktime_t tstamp;\n\n\ttstamp = ksz_decode_tstamp(get_unaligned_be32(tstamp_raw));\n\tKSZ_SKB_CB(skb)->tstamp = tstamp;\n}\n\n \nstatic void ksz_xmit_timestamp(struct dsa_port *dp, struct sk_buff *skb)\n{\n\tstruct ksz_tagger_private *priv;\n\tstruct ptp_header *ptp_hdr;\n\tunsigned int ptp_type;\n\tu32 tstamp_raw = 0;\n\ts64 correction;\n\n\tpriv = ksz_tagger_private(dp->ds);\n\n\tif (!test_bit(KSZ_HWTS_EN, &priv->state))\n\t\treturn;\n\n\tif (!KSZ_SKB_CB(skb)->update_correction)\n\t\tgoto output_tag;\n\n\tptp_type = KSZ_SKB_CB(skb)->ptp_type;\n\n\tptp_hdr = ptp_parse_header(skb, ptp_type);\n\tif (!ptp_hdr)\n\t\tgoto output_tag;\n\n\tcorrection = (s64)get_unaligned_be64(&ptp_hdr->correction);\n\n\tif (correction < 0) {\n\t\tstruct timespec64 ts;\n\n\t\tts = ns_to_timespec64(-correction >> 16);\n\t\ttstamp_raw = ((ts.tv_sec & 3) << 30) | ts.tv_nsec;\n\n\t\t \n\t\tptp_header_update_correction(skb, ptp_type, ptp_hdr, 0);\n\t}\n\noutput_tag:\n\tput_unaligned_be32(tstamp_raw, skb_put(skb, KSZ_PTP_TAG_LEN));\n}\n\n \nstatic struct sk_buff *ksz_defer_xmit(struct dsa_port *dp, struct sk_buff *skb)\n{\n\tstruct ksz_tagger_data *tagger_data = ksz_tagger_data(dp->ds);\n\tstruct ksz_tagger_private *priv = ksz_tagger_private(dp->ds);\n\tvoid (*xmit_work_fn)(struct kthread_work *work);\n\tstruct sk_buff *clone = KSZ_SKB_CB(skb)->clone;\n\tstruct ksz_deferred_xmit_work *xmit_work;\n\tstruct kthread_worker *xmit_worker;\n\n\tif (!clone)\n\t\treturn skb;   \n\n\txmit_work_fn = tagger_data->xmit_work_fn;\n\txmit_worker = priv->xmit_worker;\n\n\tif (!xmit_work_fn || !xmit_worker)\n\t\treturn NULL;\n\n\txmit_work = kzalloc(sizeof(*xmit_work), GFP_ATOMIC);\n\tif (!xmit_work)\n\t\treturn NULL;\n\n\tkthread_init_work(&xmit_work->work, xmit_work_fn);\n\t \n\txmit_work->dp = dp;\n\txmit_work->skb = skb_get(skb);\n\n\tkthread_queue_work(xmit_worker, &xmit_work->work);\n\n\treturn NULL;\n}\n\nstatic struct sk_buff *ksz9477_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tu16 queue_mapping = skb_get_queue_mapping(skb);\n\tu8 prio = netdev_txq_to_tc(dev, queue_mapping);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct ethhdr *hdr;\n\t__be16 *tag;\n\tu16 val;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL && skb_checksum_help(skb))\n\t\treturn NULL;\n\n\t \n\tksz_xmit_timestamp(dp, skb);\n\n\ttag = skb_put(skb, KSZ9477_INGRESS_TAG_LEN);\n\thdr = skb_eth_hdr(skb);\n\n\tval = BIT(dp->index);\n\n\tval |= FIELD_PREP(KSZ9477_TAIL_TAG_PRIO, prio);\n\n\tif (is_link_local_ether_addr(hdr->h_dest))\n\t\tval |= KSZ9477_TAIL_TAG_OVERRIDE;\n\n\t*tag = cpu_to_be16(val);\n\n\treturn ksz_defer_xmit(dp, skb);\n}\n\nstatic struct sk_buff *ksz9477_rcv(struct sk_buff *skb, struct net_device *dev)\n{\n\t \n\tu8 *tag = skb_tail_pointer(skb) - KSZ_EGRESS_TAG_LEN;\n\tunsigned int port = tag[0] & 7;\n\tunsigned int len = KSZ_EGRESS_TAG_LEN;\n\n\t \n\tif (tag[0] & KSZ9477_PTP_TAG_INDICATION) {\n\t\tksz_rcv_timestamp(skb, tag);\n\t\tlen += KSZ_PTP_TAG_LEN;\n\t}\n\n\treturn ksz_common_rcv(skb, dev, port, len);\n}\n\nstatic const struct dsa_device_ops ksz9477_netdev_ops = {\n\t.name\t= KSZ9477_NAME,\n\t.proto\t= DSA_TAG_PROTO_KSZ9477,\n\t.xmit\t= ksz9477_xmit,\n\t.rcv\t= ksz9477_rcv,\n\t.connect = ksz_connect,\n\t.disconnect = ksz_disconnect,\n\t.needed_tailroom = KSZ9477_INGRESS_TAG_LEN + KSZ_PTP_TAG_LEN,\n};\n\nDSA_TAG_DRIVER(ksz9477_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_KSZ9477, KSZ9477_NAME);\n\n#define KSZ9893_TAIL_TAG_PRIO\t\tGENMASK(4, 3)\n#define KSZ9893_TAIL_TAG_OVERRIDE\tBIT(5)\n#define KSZ9893_TAIL_TAG_LOOKUP\t\tBIT(6)\n\nstatic struct sk_buff *ksz9893_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tu16 queue_mapping = skb_get_queue_mapping(skb);\n\tu8 prio = netdev_txq_to_tc(dev, queue_mapping);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct ethhdr *hdr;\n\tu8 *tag;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL && skb_checksum_help(skb))\n\t\treturn NULL;\n\n\t \n\tksz_xmit_timestamp(dp, skb);\n\n\ttag = skb_put(skb, KSZ_INGRESS_TAG_LEN);\n\thdr = skb_eth_hdr(skb);\n\n\t*tag = BIT(dp->index);\n\n\t*tag |= FIELD_PREP(KSZ9893_TAIL_TAG_PRIO, prio);\n\n\tif (is_link_local_ether_addr(hdr->h_dest))\n\t\t*tag |= KSZ9893_TAIL_TAG_OVERRIDE;\n\n\treturn ksz_defer_xmit(dp, skb);\n}\n\nstatic const struct dsa_device_ops ksz9893_netdev_ops = {\n\t.name\t= KSZ9893_NAME,\n\t.proto\t= DSA_TAG_PROTO_KSZ9893,\n\t.xmit\t= ksz9893_xmit,\n\t.rcv\t= ksz9477_rcv,\n\t.connect = ksz_connect,\n\t.disconnect = ksz_disconnect,\n\t.needed_tailroom = KSZ_INGRESS_TAG_LEN + KSZ_PTP_TAG_LEN,\n};\n\nDSA_TAG_DRIVER(ksz9893_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_KSZ9893, KSZ9893_NAME);\n\n \n#define LAN937X_EGRESS_TAG_LEN\t\t2\n\n#define LAN937X_TAIL_TAG_BLOCKING_OVERRIDE\tBIT(11)\n#define LAN937X_TAIL_TAG_LOOKUP\t\t\tBIT(12)\n#define LAN937X_TAIL_TAG_VALID\t\t\tBIT(13)\n#define LAN937X_TAIL_TAG_PRIO\t\t\tGENMASK(10, 8)\n#define LAN937X_TAIL_TAG_PORT_MASK\t\t7\n\nstatic struct sk_buff *lan937x_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tu16 queue_mapping = skb_get_queue_mapping(skb);\n\tu8 prio = netdev_txq_to_tc(dev, queue_mapping);\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tconst struct ethhdr *hdr = eth_hdr(skb);\n\t__be16 *tag;\n\tu16 val;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL && skb_checksum_help(skb))\n\t\treturn NULL;\n\n\tksz_xmit_timestamp(dp, skb);\n\n\ttag = skb_put(skb, LAN937X_EGRESS_TAG_LEN);\n\n\tval = BIT(dp->index);\n\n\tval |= FIELD_PREP(LAN937X_TAIL_TAG_PRIO, prio);\n\n\tif (is_link_local_ether_addr(hdr->h_dest))\n\t\tval |= LAN937X_TAIL_TAG_BLOCKING_OVERRIDE;\n\n\t \n\tval |= LAN937X_TAIL_TAG_VALID;\n\n\tput_unaligned_be16(val, tag);\n\n\treturn ksz_defer_xmit(dp, skb);\n}\n\nstatic const struct dsa_device_ops lan937x_netdev_ops = {\n\t.name\t= LAN937X_NAME,\n\t.proto\t= DSA_TAG_PROTO_LAN937X,\n\t.xmit\t= lan937x_xmit,\n\t.rcv\t= ksz9477_rcv,\n\t.connect = ksz_connect,\n\t.disconnect = ksz_disconnect,\n\t.needed_tailroom = LAN937X_EGRESS_TAG_LEN + KSZ_PTP_TAG_LEN,\n};\n\nDSA_TAG_DRIVER(lan937x_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_LAN937X, LAN937X_NAME);\n\nstatic struct dsa_tag_driver *dsa_tag_driver_array[] = {\n\t&DSA_TAG_DRIVER_NAME(ksz8795_netdev_ops),\n\t&DSA_TAG_DRIVER_NAME(ksz9477_netdev_ops),\n\t&DSA_TAG_DRIVER_NAME(ksz9893_netdev_ops),\n\t&DSA_TAG_DRIVER_NAME(lan937x_netdev_ops),\n};\n\nmodule_dsa_tag_drivers(dsa_tag_driver_array);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}