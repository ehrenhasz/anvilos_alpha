{
  "module_name": "tag_dsa.c",
  "hash_id": "fd46fc18d4eeda50f6e6e6d5958c4ee4fd074403f25c2fd1686109df33c3ddee",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag_dsa.c",
  "human_readable_source": "\n \n\n#include <linux/dsa/mv88e6xxx.h>\n#include <linux/etherdevice.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include \"tag.h\"\n\n#define DSA_NAME\t\"dsa\"\n#define EDSA_NAME\t\"edsa\"\n\n#define DSA_HLEN\t4\n\n \nenum dsa_cmd {\n\tDSA_CMD_TO_CPU     = 0,\n\tDSA_CMD_FROM_CPU   = 1,\n\tDSA_CMD_TO_SNIFFER = 2,\n\tDSA_CMD_FORWARD    = 3\n};\n\n \nenum dsa_code {\n\tDSA_CODE_MGMT_TRAP     = 0,\n\tDSA_CODE_FRAME2REG     = 1,\n\tDSA_CODE_IGMP_MLD_TRAP = 2,\n\tDSA_CODE_POLICY_TRAP   = 3,\n\tDSA_CODE_ARP_MIRROR    = 4,\n\tDSA_CODE_POLICY_MIRROR = 5,\n\tDSA_CODE_RESERVED_6    = 6,\n\tDSA_CODE_RESERVED_7    = 7\n};\n\nstatic struct sk_buff *dsa_xmit_ll(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t   u8 extra)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tstruct net_device *br_dev;\n\tu8 tag_dev, tag_port;\n\tenum dsa_cmd cmd;\n\tu8 *dsa_header;\n\n\tif (skb->offload_fwd_mark) {\n\t\tunsigned int bridge_num = dsa_port_bridge_num_get(dp);\n\t\tstruct dsa_switch_tree *dst = dp->ds->dst;\n\n\t\tcmd = DSA_CMD_FORWARD;\n\n\t\t \n\t\ttag_dev = dst->last_switch + bridge_num;\n\t\ttag_port = 0;\n\t} else {\n\t\tcmd = DSA_CMD_FROM_CPU;\n\t\ttag_dev = dp->ds->index;\n\t\ttag_port = dp->index;\n\t}\n\n\tbr_dev = dsa_port_bridge_dev_get(dp);\n\n\t \n\tif (skb->protocol == htons(ETH_P_8021Q) &&\n\t    (!br_dev || br_vlan_enabled(br_dev))) {\n\t\tif (extra) {\n\t\t\tskb_push(skb, extra);\n\t\t\tdsa_alloc_etype_header(skb, extra);\n\t\t}\n\n\t\t \n\t\tdsa_header = dsa_etype_header_pos_tx(skb) + extra;\n\t\tdsa_header[0] = (cmd << 6) | 0x20 | tag_dev;\n\t\tdsa_header[1] = tag_port << 3;\n\n\t\t \n\t\tif (dsa_header[2] & 0x10) {\n\t\t\tdsa_header[1] |= 0x01;\n\t\t\tdsa_header[2] &= ~0x10;\n\t\t}\n\t} else {\n\t\tu16 vid;\n\n\t\tvid = br_dev ? MV88E6XXX_VID_BRIDGED : MV88E6XXX_VID_STANDALONE;\n\n\t\tskb_push(skb, DSA_HLEN + extra);\n\t\tdsa_alloc_etype_header(skb, DSA_HLEN + extra);\n\n\t\t \n\t\tdsa_header = dsa_etype_header_pos_tx(skb) + extra;\n\n\t\tdsa_header[0] = (cmd << 6) | tag_dev;\n\t\tdsa_header[1] = tag_port << 3;\n\t\tdsa_header[2] = vid >> 8;\n\t\tdsa_header[3] = vid & 0xff;\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *dsa_rcv_ll(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t  u8 extra)\n{\n\tbool trap = false, trunk = false;\n\tint source_device, source_port;\n\tenum dsa_code code;\n\tenum dsa_cmd cmd;\n\tu8 *dsa_header;\n\n\t \n\tdsa_header = dsa_etype_header_pos_rx(skb);\n\n\tcmd = dsa_header[0] >> 6;\n\tswitch (cmd) {\n\tcase DSA_CMD_FORWARD:\n\t\ttrunk = !!(dsa_header[1] & 4);\n\t\tbreak;\n\n\tcase DSA_CMD_TO_CPU:\n\t\tcode = (dsa_header[1] & 0x6) | ((dsa_header[2] >> 4) & 1);\n\n\t\tswitch (code) {\n\t\tcase DSA_CODE_FRAME2REG:\n\t\t\t \n\t\t\treturn NULL;\n\t\tcase DSA_CODE_ARP_MIRROR:\n\t\tcase DSA_CODE_POLICY_MIRROR:\n\t\t\t \n\t\t\tbreak;\n\t\tcase DSA_CODE_MGMT_TRAP:\n\t\tcase DSA_CODE_IGMP_MLD_TRAP:\n\t\tcase DSA_CODE_POLICY_TRAP:\n\t\t\t \n\t\t\ttrap = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\treturn NULL;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tsource_device = dsa_header[0] & 0x1f;\n\tsource_port = (dsa_header[1] >> 3) & 0x1f;\n\n\tif (trunk) {\n\t\tstruct dsa_port *cpu_dp = dev->dsa_ptr;\n\t\tstruct dsa_lag *lag;\n\n\t\t \n\t\tlag = dsa_lag_by_id(cpu_dp->dst, source_port + 1);\n\t\tskb->dev = lag ? lag->dev : NULL;\n\t} else {\n\t\tskb->dev = dsa_master_find_slave(dev, source_device,\n\t\t\t\t\t\t source_port);\n\t}\n\n\tif (!skb->dev)\n\t\treturn NULL;\n\n\t \n\tif (trunk)\n\t\tskb->offload_fwd_mark = true;\n\telse if (!trap)\n\t\tdsa_default_offload_fwd_mark(skb);\n\n\t \n\tif (dsa_header[0] & 0x20) {\n\t\tu8 new_header[4];\n\n\t\t \n\t\tnew_header[0] = (ETH_P_8021Q >> 8) & 0xff;\n\t\tnew_header[1] = ETH_P_8021Q & 0xff;\n\t\tnew_header[2] = dsa_header[2] & ~0x10;\n\t\tnew_header[3] = dsa_header[3];\n\n\t\t \n\t\tif (dsa_header[1] & 0x01)\n\t\t\tnew_header[2] |= 0x10;\n\n\t\t \n\t\tif (skb->ip_summed == CHECKSUM_COMPLETE) {\n\t\t\t__wsum c = skb->csum;\n\t\t\tc = csum_add(c, csum_partial(new_header + 2, 2, 0));\n\t\t\tc = csum_sub(c, csum_partial(dsa_header + 2, 2, 0));\n\t\t\tskb->csum = c;\n\t\t}\n\n\t\tmemcpy(dsa_header, new_header, DSA_HLEN);\n\n\t\tif (extra)\n\t\t\tdsa_strip_etype_header(skb, extra);\n\t} else {\n\t\tskb_pull_rcsum(skb, DSA_HLEN);\n\t\tdsa_strip_etype_header(skb, DSA_HLEN + extra);\n\t}\n\n\treturn skb;\n}\n\n#if IS_ENABLED(CONFIG_NET_DSA_TAG_DSA)\n\nstatic struct sk_buff *dsa_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\treturn dsa_xmit_ll(skb, dev, 0);\n}\n\nstatic struct sk_buff *dsa_rcv(struct sk_buff *skb, struct net_device *dev)\n{\n\tif (unlikely(!pskb_may_pull(skb, DSA_HLEN)))\n\t\treturn NULL;\n\n\treturn dsa_rcv_ll(skb, dev, 0);\n}\n\nstatic const struct dsa_device_ops dsa_netdev_ops = {\n\t.name\t  = DSA_NAME,\n\t.proto\t  = DSA_TAG_PROTO_DSA,\n\t.xmit\t  = dsa_xmit,\n\t.rcv\t  = dsa_rcv,\n\t.needed_headroom = DSA_HLEN,\n};\n\nDSA_TAG_DRIVER(dsa_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_DSA, DSA_NAME);\n#endif\t \n\n#if IS_ENABLED(CONFIG_NET_DSA_TAG_EDSA)\n\n#define EDSA_HLEN 8\n\nstatic struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tu8 *edsa_header;\n\n\tskb = dsa_xmit_ll(skb, dev, EDSA_HLEN - DSA_HLEN);\n\tif (!skb)\n\t\treturn NULL;\n\n\tedsa_header = dsa_etype_header_pos_tx(skb);\n\tedsa_header[0] = (ETH_P_EDSA >> 8) & 0xff;\n\tedsa_header[1] = ETH_P_EDSA & 0xff;\n\tedsa_header[2] = 0x00;\n\tedsa_header[3] = 0x00;\n\treturn skb;\n}\n\nstatic struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev)\n{\n\tif (unlikely(!pskb_may_pull(skb, EDSA_HLEN)))\n\t\treturn NULL;\n\n\tskb_pull_rcsum(skb, EDSA_HLEN - DSA_HLEN);\n\n\treturn dsa_rcv_ll(skb, dev, EDSA_HLEN - DSA_HLEN);\n}\n\nstatic const struct dsa_device_ops edsa_netdev_ops = {\n\t.name\t  = EDSA_NAME,\n\t.proto\t  = DSA_TAG_PROTO_EDSA,\n\t.xmit\t  = edsa_xmit,\n\t.rcv\t  = edsa_rcv,\n\t.needed_headroom = EDSA_HLEN,\n};\n\nDSA_TAG_DRIVER(edsa_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_EDSA, EDSA_NAME);\n#endif\t \n\nstatic struct dsa_tag_driver *dsa_tag_drivers[] = {\n#if IS_ENABLED(CONFIG_NET_DSA_TAG_DSA)\n\t&DSA_TAG_DRIVER_NAME(dsa_netdev_ops),\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA_TAG_EDSA)\n\t&DSA_TAG_DRIVER_NAME(edsa_netdev_ops),\n#endif\n};\n\nmodule_dsa_tag_drivers(dsa_tag_drivers);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}