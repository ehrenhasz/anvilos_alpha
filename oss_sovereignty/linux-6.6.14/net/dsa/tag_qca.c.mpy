{
  "module_name": "tag_qca.c",
  "hash_id": "fc541cc6ae3d9930a500d2ad95493d4969ab6500d544e530932187e55736f673",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag_qca.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/bitfield.h>\n#include <net/dsa.h>\n#include <linux/dsa/tag_qca.h>\n\n#include \"tag.h\"\n\n#define QCA_NAME \"qca\"\n\nstatic struct sk_buff *qca_tag_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\t__be16 *phdr;\n\tu16 hdr;\n\n\tskb_push(skb, QCA_HDR_LEN);\n\n\tdsa_alloc_etype_header(skb, QCA_HDR_LEN);\n\tphdr = dsa_etype_header_pos_tx(skb);\n\n\t \n\thdr = FIELD_PREP(QCA_HDR_XMIT_VERSION, QCA_HDR_VERSION);\n\thdr |= QCA_HDR_XMIT_FROM_CPU;\n\thdr |= FIELD_PREP(QCA_HDR_XMIT_DP_BIT, BIT(dp->index));\n\n\t*phdr = htons(hdr);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *qca_tag_rcv(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct qca_tagger_data *tagger_data;\n\tstruct dsa_port *dp = dev->dsa_ptr;\n\tstruct dsa_switch *ds = dp->ds;\n\tu8 ver, pk_type;\n\t__be16 *phdr;\n\tint port;\n\tu16 hdr;\n\n\tBUILD_BUG_ON(sizeof(struct qca_mgmt_ethhdr) != QCA_HDR_MGMT_HEADER_LEN + QCA_HDR_LEN);\n\n\ttagger_data = ds->tagger_data;\n\n\tif (unlikely(!pskb_may_pull(skb, QCA_HDR_LEN)))\n\t\treturn NULL;\n\n\tphdr = dsa_etype_header_pos_rx(skb);\n\thdr = ntohs(*phdr);\n\n\t \n\tver = FIELD_GET(QCA_HDR_RECV_VERSION, hdr);\n\tif (unlikely(ver != QCA_HDR_VERSION))\n\t\treturn NULL;\n\n\t \n\tpk_type = FIELD_GET(QCA_HDR_RECV_TYPE, hdr);\n\n\t \n\tif (pk_type == QCA_HDR_RECV_TYPE_RW_REG_ACK) {\n\t\tif (likely(tagger_data->rw_reg_ack_handler))\n\t\t\ttagger_data->rw_reg_ack_handler(ds, skb);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (pk_type == QCA_HDR_RECV_TYPE_MIB) {\n\t\tif (likely(tagger_data->mib_autocast_handler))\n\t\t\ttagger_data->mib_autocast_handler(ds, skb);\n\t\treturn NULL;\n\t}\n\n\t \n\tport = FIELD_GET(QCA_HDR_RECV_SOURCE_PORT, hdr);\n\n\tskb->dev = dsa_master_find_slave(dev, 0, port);\n\tif (!skb->dev)\n\t\treturn NULL;\n\n\t \n\tskb_pull_rcsum(skb, QCA_HDR_LEN);\n\tdsa_strip_etype_header(skb, QCA_HDR_LEN);\n\n\treturn skb;\n}\n\nstatic int qca_tag_connect(struct dsa_switch *ds)\n{\n\tstruct qca_tagger_data *tagger_data;\n\n\ttagger_data = kzalloc(sizeof(*tagger_data), GFP_KERNEL);\n\tif (!tagger_data)\n\t\treturn -ENOMEM;\n\n\tds->tagger_data = tagger_data;\n\n\treturn 0;\n}\n\nstatic void qca_tag_disconnect(struct dsa_switch *ds)\n{\n\tkfree(ds->tagger_data);\n\tds->tagger_data = NULL;\n}\n\nstatic const struct dsa_device_ops qca_netdev_ops = {\n\t.name\t= QCA_NAME,\n\t.proto\t= DSA_TAG_PROTO_QCA,\n\t.connect = qca_tag_connect,\n\t.disconnect = qca_tag_disconnect,\n\t.xmit\t= qca_tag_xmit,\n\t.rcv\t= qca_tag_rcv,\n\t.needed_headroom = QCA_HDR_LEN,\n\t.promisc_on_master = true,\n};\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_QCA, QCA_NAME);\n\nmodule_dsa_tag_driver(qca_netdev_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}