{
  "module_name": "tag_brcm.c",
  "hash_id": "f1659cab843eeb5b94a515d439ae262a1ebc7277b811c91211ce2647732df735",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag_brcm.c",
  "human_readable_source": "\n \n\n#include <linux/dsa/brcm.h>\n#include <linux/etherdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include \"tag.h\"\n\n#define BRCM_NAME\t\t\"brcm\"\n#define BRCM_LEGACY_NAME\t\"brcm-legacy\"\n#define BRCM_PREPEND_NAME\t\"brcm-prepend\"\n\n \n#define BRCM_LEG_TAG_LEN\t6\n\n \n \n#define BRCM_LEG_TYPE_HI\t0x88\n \n#define BRCM_LEG_TYPE_LO\t0x74\n\n \n \n#define BRCM_LEG_UNICAST\t(0 << 5)\n#define BRCM_LEG_MULTICAST\t(1 << 5)\n#define BRCM_LEG_EGRESS\t\t(2 << 5)\n#define BRCM_LEG_INGRESS\t(3 << 5)\n\n \n#define BRCM_LEG_PORT_ID\t(0xf)\n\n \n#define BRCM_TAG_LEN\t4\n\n \n\n \n#define BRCM_OPCODE_SHIFT\t5\n#define BRCM_OPCODE_MASK\t0x7\n\n \n \n#define BRCM_IG_TC_SHIFT\t2\n#define BRCM_IG_TC_MASK\t\t0x7\n \n#define BRCM_IG_TE_MASK\t\t0x3\n#define BRCM_IG_TS_SHIFT\t7\n \n#define BRCM_IG_DSTMAP2_MASK\t1\n#define BRCM_IG_DSTMAP1_MASK\t0xff\n\n \n\n \n#define BRCM_EG_CID_MASK\t0xff\n\n \n#define BRCM_EG_RC_MASK\t\t0xff\n#define  BRCM_EG_RC_RSVD\t(3 << 6)\n#define  BRCM_EG_RC_EXCEPTION\t(1 << 5)\n#define  BRCM_EG_RC_PROT_SNOOP\t(1 << 4)\n#define  BRCM_EG_RC_PROT_TERM\t(1 << 3)\n#define  BRCM_EG_RC_SWITCH\t(1 << 2)\n#define  BRCM_EG_RC_MAC_LEARN\t(1 << 1)\n#define  BRCM_EG_RC_MIRROR\t(1 << 0)\n#define BRCM_EG_TC_SHIFT\t5\n#define BRCM_EG_TC_MASK\t\t0x7\n#define BRCM_EG_PID_MASK\t0x1f\n\n#if IS_ENABLED(CONFIG_NET_DSA_TAG_BRCM) || \\\n\tIS_ENABLED(CONFIG_NET_DSA_TAG_BRCM_PREPEND)\n\nstatic struct sk_buff *brcm_tag_xmit_ll(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev,\n\t\t\t\t\tunsigned int offset)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tu16 queue = skb_get_queue_mapping(skb);\n\tu8 *brcm_tag;\n\n\t \n\tif (__skb_put_padto(skb, ETH_ZLEN + BRCM_TAG_LEN, false))\n\t\treturn NULL;\n\n\tskb_push(skb, BRCM_TAG_LEN);\n\n\tif (offset)\n\t\tdsa_alloc_etype_header(skb, BRCM_TAG_LEN);\n\n\tbrcm_tag = skb->data + offset;\n\n\t \n\tbrcm_tag[0] = (1 << BRCM_OPCODE_SHIFT) |\n\t\t       ((queue & BRCM_IG_TC_MASK) << BRCM_IG_TC_SHIFT);\n\tbrcm_tag[1] = 0;\n\tbrcm_tag[2] = 0;\n\tif (dp->index == 8)\n\t\tbrcm_tag[2] = BRCM_IG_DSTMAP2_MASK;\n\tbrcm_tag[3] = (1 << dp->index) & BRCM_IG_DSTMAP1_MASK;\n\n\t \n\tskb_set_queue_mapping(skb, BRCM_TAG_SET_PORT_QUEUE(dp->index, queue));\n\n\treturn skb;\n}\n\n \nstatic struct sk_buff *brcm_tag_rcv_ll(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       unsigned int offset)\n{\n\tint source_port;\n\tu8 *brcm_tag;\n\n\tif (unlikely(!pskb_may_pull(skb, BRCM_TAG_LEN)))\n\t\treturn NULL;\n\n\tbrcm_tag = skb->data - offset;\n\n\t \n\tif (unlikely((brcm_tag[0] >> BRCM_OPCODE_SHIFT) & BRCM_OPCODE_MASK))\n\t\treturn NULL;\n\n\t \n\tif (unlikely(brcm_tag[2] & BRCM_EG_RC_RSVD))\n\t\treturn NULL;\n\n\t \n\tsource_port = brcm_tag[3] & BRCM_EG_PID_MASK;\n\n\tskb->dev = dsa_master_find_slave(dev, 0, source_port);\n\tif (!skb->dev)\n\t\treturn NULL;\n\n\t \n\tskb_pull_rcsum(skb, BRCM_TAG_LEN);\n\n\tdsa_default_offload_fwd_mark(skb);\n\n\treturn skb;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_NET_DSA_TAG_BRCM)\nstatic struct sk_buff *brcm_tag_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\t \n\treturn brcm_tag_xmit_ll(skb, dev, 2 * ETH_ALEN);\n}\n\n\nstatic struct sk_buff *brcm_tag_rcv(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct sk_buff *nskb;\n\n\t \n\tnskb = brcm_tag_rcv_ll(skb, dev, 2);\n\tif (!nskb)\n\t\treturn nskb;\n\n\tdsa_strip_etype_header(skb, BRCM_TAG_LEN);\n\n\treturn nskb;\n}\n\nstatic const struct dsa_device_ops brcm_netdev_ops = {\n\t.name\t= BRCM_NAME,\n\t.proto\t= DSA_TAG_PROTO_BRCM,\n\t.xmit\t= brcm_tag_xmit,\n\t.rcv\t= brcm_tag_rcv,\n\t.needed_headroom = BRCM_TAG_LEN,\n};\n\nDSA_TAG_DRIVER(brcm_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_BRCM, BRCM_NAME);\n#endif\n\n#if IS_ENABLED(CONFIG_NET_DSA_TAG_BRCM_LEGACY)\nstatic struct sk_buff *brcm_leg_tag_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct dsa_port *dp = dsa_slave_to_port(dev);\n\tu8 *brcm_tag;\n\n\t \n\tif (__skb_put_padto(skb, ETH_ZLEN + BRCM_LEG_TAG_LEN, false))\n\t\treturn NULL;\n\n\tskb_push(skb, BRCM_LEG_TAG_LEN);\n\n\tdsa_alloc_etype_header(skb, BRCM_LEG_TAG_LEN);\n\n\tbrcm_tag = skb->data + 2 * ETH_ALEN;\n\n\t \n\tbrcm_tag[0] = BRCM_LEG_TYPE_HI;\n\tbrcm_tag[1] = BRCM_LEG_TYPE_LO;\n\n\t \n\tbrcm_tag[2] = BRCM_LEG_EGRESS;\n\tbrcm_tag[3] = 0;\n\tbrcm_tag[4] = 0;\n\tbrcm_tag[5] = dp->index & BRCM_LEG_PORT_ID;\n\n\treturn skb;\n}\n\nstatic struct sk_buff *brcm_leg_tag_rcv(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tint len = BRCM_LEG_TAG_LEN;\n\tint source_port;\n\tu8 *brcm_tag;\n\n\tif (unlikely(!pskb_may_pull(skb, BRCM_LEG_PORT_ID)))\n\t\treturn NULL;\n\n\tbrcm_tag = dsa_etype_header_pos_rx(skb);\n\n\tsource_port = brcm_tag[5] & BRCM_LEG_PORT_ID;\n\n\tskb->dev = dsa_master_find_slave(dev, 0, source_port);\n\tif (!skb->dev)\n\t\treturn NULL;\n\n\t \n\tif (netdev_uses_dsa(skb->dev))\n\t\tlen += VLAN_HLEN;\n\n\t \n\tskb_pull_rcsum(skb, len);\n\n\tdsa_default_offload_fwd_mark(skb);\n\n\tdsa_strip_etype_header(skb, len);\n\n\treturn skb;\n}\n\nstatic const struct dsa_device_ops brcm_legacy_netdev_ops = {\n\t.name = BRCM_LEGACY_NAME,\n\t.proto = DSA_TAG_PROTO_BRCM_LEGACY,\n\t.xmit = brcm_leg_tag_xmit,\n\t.rcv = brcm_leg_tag_rcv,\n\t.needed_headroom = BRCM_LEG_TAG_LEN,\n};\n\nDSA_TAG_DRIVER(brcm_legacy_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_BRCM_LEGACY, BRCM_LEGACY_NAME);\n#endif  \n\n#if IS_ENABLED(CONFIG_NET_DSA_TAG_BRCM_PREPEND)\nstatic struct sk_buff *brcm_tag_xmit_prepend(struct sk_buff *skb,\n\t\t\t\t\t     struct net_device *dev)\n{\n\t \n\treturn brcm_tag_xmit_ll(skb, dev, 0);\n}\n\nstatic struct sk_buff *brcm_tag_rcv_prepend(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\t \n\treturn brcm_tag_rcv_ll(skb, dev, ETH_HLEN);\n}\n\nstatic const struct dsa_device_ops brcm_prepend_netdev_ops = {\n\t.name\t= BRCM_PREPEND_NAME,\n\t.proto\t= DSA_TAG_PROTO_BRCM_PREPEND,\n\t.xmit\t= brcm_tag_xmit_prepend,\n\t.rcv\t= brcm_tag_rcv_prepend,\n\t.needed_headroom = BRCM_TAG_LEN,\n};\n\nDSA_TAG_DRIVER(brcm_prepend_netdev_ops);\nMODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_BRCM_PREPEND, BRCM_PREPEND_NAME);\n#endif\n\nstatic struct dsa_tag_driver *dsa_tag_driver_array[] =\t{\n#if IS_ENABLED(CONFIG_NET_DSA_TAG_BRCM)\n\t&DSA_TAG_DRIVER_NAME(brcm_netdev_ops),\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA_TAG_BRCM_LEGACY)\n\t&DSA_TAG_DRIVER_NAME(brcm_legacy_netdev_ops),\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA_TAG_BRCM_PREPEND)\n\t&DSA_TAG_DRIVER_NAME(brcm_prepend_netdev_ops),\n#endif\n};\n\nmodule_dsa_tag_drivers(dsa_tag_driver_array);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}