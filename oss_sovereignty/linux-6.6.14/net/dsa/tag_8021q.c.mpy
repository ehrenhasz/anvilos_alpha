{
  "module_name": "tag_8021q.c",
  "hash_id": "23949f2cbcd4ed9077641fa893cc6c6ea9427d3f068d4aa04f71a9466d503a51",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/tag_8021q.c",
  "human_readable_source": "\n \n#include <linux/if_vlan.h>\n#include <linux/dsa/8021q.h>\n\n#include \"port.h\"\n#include \"switch.h\"\n#include \"tag.h\"\n#include \"tag_8021q.h\"\n\n \n\n#define DSA_8021Q_RSV_VAL\t\t3\n#define DSA_8021Q_RSV_SHIFT\t\t10\n#define DSA_8021Q_RSV_MASK\t\tGENMASK(11, 10)\n#define DSA_8021Q_RSV\t\t\t((DSA_8021Q_RSV_VAL << DSA_8021Q_RSV_SHIFT) & \\\n\t\t\t\t\t\t\t       DSA_8021Q_RSV_MASK)\n\n#define DSA_8021Q_SWITCH_ID_SHIFT\t6\n#define DSA_8021Q_SWITCH_ID_MASK\tGENMASK(8, 6)\n#define DSA_8021Q_SWITCH_ID(x)\t\t(((x) << DSA_8021Q_SWITCH_ID_SHIFT) & \\\n\t\t\t\t\t\t DSA_8021Q_SWITCH_ID_MASK)\n\n#define DSA_8021Q_VBID_HI_SHIFT\t\t9\n#define DSA_8021Q_VBID_HI_MASK\t\tGENMASK(9, 9)\n#define DSA_8021Q_VBID_LO_SHIFT\t\t4\n#define DSA_8021Q_VBID_LO_MASK\t\tGENMASK(5, 4)\n#define DSA_8021Q_VBID_HI(x)\t\t(((x) & GENMASK(2, 2)) >> 2)\n#define DSA_8021Q_VBID_LO(x)\t\t((x) & GENMASK(1, 0))\n#define DSA_8021Q_VBID(x)\t\t\\\n\t\t(((DSA_8021Q_VBID_LO(x) << DSA_8021Q_VBID_LO_SHIFT) & \\\n\t\t  DSA_8021Q_VBID_LO_MASK) | \\\n\t\t ((DSA_8021Q_VBID_HI(x) << DSA_8021Q_VBID_HI_SHIFT) & \\\n\t\t  DSA_8021Q_VBID_HI_MASK))\n\n#define DSA_8021Q_PORT_SHIFT\t\t0\n#define DSA_8021Q_PORT_MASK\t\tGENMASK(3, 0)\n#define DSA_8021Q_PORT(x)\t\t(((x) << DSA_8021Q_PORT_SHIFT) & \\\n\t\t\t\t\t\t DSA_8021Q_PORT_MASK)\n\nstruct dsa_tag_8021q_vlan {\n\tstruct list_head list;\n\tint port;\n\tu16 vid;\n\trefcount_t refcount;\n};\n\nstruct dsa_8021q_context {\n\tstruct dsa_switch *ds;\n\tstruct list_head vlans;\n\t \n\t__be16 proto;\n};\n\nu16 dsa_tag_8021q_bridge_vid(unsigned int bridge_num)\n{\n\t \n\treturn DSA_8021Q_RSV | DSA_8021Q_VBID(bridge_num);\n}\nEXPORT_SYMBOL_GPL(dsa_tag_8021q_bridge_vid);\n\n \nu16 dsa_tag_8021q_standalone_vid(const struct dsa_port *dp)\n{\n\treturn DSA_8021Q_RSV | DSA_8021Q_SWITCH_ID(dp->ds->index) |\n\t       DSA_8021Q_PORT(dp->index);\n}\nEXPORT_SYMBOL_GPL(dsa_tag_8021q_standalone_vid);\n\n \nint dsa_8021q_rx_switch_id(u16 vid)\n{\n\treturn (vid & DSA_8021Q_SWITCH_ID_MASK) >> DSA_8021Q_SWITCH_ID_SHIFT;\n}\nEXPORT_SYMBOL_GPL(dsa_8021q_rx_switch_id);\n\n \nint dsa_8021q_rx_source_port(u16 vid)\n{\n\treturn (vid & DSA_8021Q_PORT_MASK) >> DSA_8021Q_PORT_SHIFT;\n}\nEXPORT_SYMBOL_GPL(dsa_8021q_rx_source_port);\n\n \nstatic int dsa_tag_8021q_rx_vbid(u16 vid)\n{\n\tu16 vbid_hi = (vid & DSA_8021Q_VBID_HI_MASK) >> DSA_8021Q_VBID_HI_SHIFT;\n\tu16 vbid_lo = (vid & DSA_8021Q_VBID_LO_MASK) >> DSA_8021Q_VBID_LO_SHIFT;\n\n\treturn (vbid_hi << 2) | vbid_lo;\n}\n\nbool vid_is_dsa_8021q(u16 vid)\n{\n\tu16 rsv = (vid & DSA_8021Q_RSV_MASK) >> DSA_8021Q_RSV_SHIFT;\n\n\treturn rsv == DSA_8021Q_RSV_VAL;\n}\nEXPORT_SYMBOL_GPL(vid_is_dsa_8021q);\n\nstatic struct dsa_tag_8021q_vlan *\ndsa_tag_8021q_vlan_find(struct dsa_8021q_context *ctx, int port, u16 vid)\n{\n\tstruct dsa_tag_8021q_vlan *v;\n\n\tlist_for_each_entry(v, &ctx->vlans, list)\n\t\tif (v->vid == vid && v->port == port)\n\t\t\treturn v;\n\n\treturn NULL;\n}\n\nstatic int dsa_port_do_tag_8021q_vlan_add(struct dsa_port *dp, u16 vid,\n\t\t\t\t\t  u16 flags)\n{\n\tstruct dsa_8021q_context *ctx = dp->ds->tag_8021q_ctx;\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_tag_8021q_vlan *v;\n\tint port = dp->index;\n\tint err;\n\n\t \n\tif (!(dsa_port_is_cpu(dp) || dsa_port_is_dsa(dp)))\n\t\treturn ds->ops->tag_8021q_vlan_add(ds, port, vid, flags);\n\n\tv = dsa_tag_8021q_vlan_find(ctx, port, vid);\n\tif (v) {\n\t\trefcount_inc(&v->refcount);\n\t\treturn 0;\n\t}\n\n\tv = kzalloc(sizeof(*v), GFP_KERNEL);\n\tif (!v)\n\t\treturn -ENOMEM;\n\n\terr = ds->ops->tag_8021q_vlan_add(ds, port, vid, flags);\n\tif (err) {\n\t\tkfree(v);\n\t\treturn err;\n\t}\n\n\tv->vid = vid;\n\tv->port = port;\n\trefcount_set(&v->refcount, 1);\n\tlist_add_tail(&v->list, &ctx->vlans);\n\n\treturn 0;\n}\n\nstatic int dsa_port_do_tag_8021q_vlan_del(struct dsa_port *dp, u16 vid)\n{\n\tstruct dsa_8021q_context *ctx = dp->ds->tag_8021q_ctx;\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_tag_8021q_vlan *v;\n\tint port = dp->index;\n\tint err;\n\n\t \n\tif (!(dsa_port_is_cpu(dp) || dsa_port_is_dsa(dp)))\n\t\treturn ds->ops->tag_8021q_vlan_del(ds, port, vid);\n\n\tv = dsa_tag_8021q_vlan_find(ctx, port, vid);\n\tif (!v)\n\t\treturn -ENOENT;\n\n\tif (!refcount_dec_and_test(&v->refcount))\n\t\treturn 0;\n\n\terr = ds->ops->tag_8021q_vlan_del(ds, port, vid);\n\tif (err) {\n\t\trefcount_inc(&v->refcount);\n\t\treturn err;\n\t}\n\n\tlist_del(&v->list);\n\tkfree(v);\n\n\treturn 0;\n}\n\nstatic bool\ndsa_port_tag_8021q_vlan_match(struct dsa_port *dp,\n\t\t\t      struct dsa_notifier_tag_8021q_vlan_info *info)\n{\n\treturn dsa_port_is_dsa(dp) || dsa_port_is_cpu(dp) || dp == info->dp;\n}\n\nint dsa_switch_tag_8021q_vlan_add(struct dsa_switch *ds,\n\t\t\t\t  struct dsa_notifier_tag_8021q_vlan_info *info)\n{\n\tstruct dsa_port *dp;\n\tint err;\n\n\t \n\tif (!ds->ops->tag_8021q_vlan_add || !ds->tag_8021q_ctx)\n\t\treturn 0;\n\n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (dsa_port_tag_8021q_vlan_match(dp, info)) {\n\t\t\tu16 flags = 0;\n\n\t\t\tif (dsa_port_is_user(dp))\n\t\t\t\tflags |= BRIDGE_VLAN_INFO_UNTAGGED |\n\t\t\t\t\t BRIDGE_VLAN_INFO_PVID;\n\n\t\t\terr = dsa_port_do_tag_8021q_vlan_add(dp, info->vid,\n\t\t\t\t\t\t\t     flags);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint dsa_switch_tag_8021q_vlan_del(struct dsa_switch *ds,\n\t\t\t\t  struct dsa_notifier_tag_8021q_vlan_info *info)\n{\n\tstruct dsa_port *dp;\n\tint err;\n\n\tif (!ds->ops->tag_8021q_vlan_del || !ds->tag_8021q_ctx)\n\t\treturn 0;\n\n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (dsa_port_tag_8021q_vlan_match(dp, info)) {\n\t\t\terr = dsa_port_do_tag_8021q_vlan_del(dp, info->vid);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint dsa_tag_8021q_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t      struct dsa_bridge bridge)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tu16 standalone_vid, bridge_vid;\n\tint err;\n\n\t \n\tstandalone_vid = dsa_tag_8021q_standalone_vid(dp);\n\tbridge_vid = dsa_tag_8021q_bridge_vid(bridge.num);\n\n\terr = dsa_port_tag_8021q_vlan_add(dp, bridge_vid, true);\n\tif (err)\n\t\treturn err;\n\n\tdsa_port_tag_8021q_vlan_del(dp, standalone_vid, false);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dsa_tag_8021q_bridge_join);\n\nvoid dsa_tag_8021q_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t\tstruct dsa_bridge bridge)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tu16 standalone_vid, bridge_vid;\n\tint err;\n\n\t \n\tstandalone_vid = dsa_tag_8021q_standalone_vid(dp);\n\tbridge_vid = dsa_tag_8021q_bridge_vid(bridge.num);\n\n\terr = dsa_port_tag_8021q_vlan_add(dp, standalone_vid, false);\n\tif (err) {\n\t\tdev_err(ds->dev,\n\t\t\t\"Failed to delete tag_8021q standalone VLAN %d from port %d: %pe\\n\",\n\t\t\tstandalone_vid, port, ERR_PTR(err));\n\t}\n\n\tdsa_port_tag_8021q_vlan_del(dp, bridge_vid, true);\n}\nEXPORT_SYMBOL_GPL(dsa_tag_8021q_bridge_leave);\n\n \nstatic int dsa_tag_8021q_port_setup(struct dsa_switch *ds, int port)\n{\n\tstruct dsa_8021q_context *ctx = ds->tag_8021q_ctx;\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tu16 vid = dsa_tag_8021q_standalone_vid(dp);\n\tstruct net_device *master;\n\tint err;\n\n\t \n\tif (!dsa_port_is_user(dp))\n\t\treturn 0;\n\n\tmaster = dsa_port_to_master(dp);\n\n\terr = dsa_port_tag_8021q_vlan_add(dp, vid, false);\n\tif (err) {\n\t\tdev_err(ds->dev,\n\t\t\t\"Failed to apply standalone VID %d to port %d: %pe\\n\",\n\t\t\tvid, port, ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\t \n\tvlan_vid_add(master, ctx->proto, vid);\n\n\treturn err;\n}\n\nstatic void dsa_tag_8021q_port_teardown(struct dsa_switch *ds, int port)\n{\n\tstruct dsa_8021q_context *ctx = ds->tag_8021q_ctx;\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tu16 vid = dsa_tag_8021q_standalone_vid(dp);\n\tstruct net_device *master;\n\n\t \n\tif (!dsa_port_is_user(dp))\n\t\treturn;\n\n\tmaster = dsa_port_to_master(dp);\n\n\tdsa_port_tag_8021q_vlan_del(dp, vid, false);\n\n\tvlan_vid_del(master, ctx->proto, vid);\n}\n\nstatic int dsa_tag_8021q_setup(struct dsa_switch *ds)\n{\n\tint err, port;\n\n\tASSERT_RTNL();\n\n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\terr = dsa_tag_8021q_port_setup(ds, port);\n\t\tif (err < 0) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"Failed to setup VLAN tagging for port %d: %pe\\n\",\n\t\t\t\tport, ERR_PTR(err));\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void dsa_tag_8021q_teardown(struct dsa_switch *ds)\n{\n\tint port;\n\n\tASSERT_RTNL();\n\n\tfor (port = 0; port < ds->num_ports; port++)\n\t\tdsa_tag_8021q_port_teardown(ds, port);\n}\n\nint dsa_tag_8021q_register(struct dsa_switch *ds, __be16 proto)\n{\n\tstruct dsa_8021q_context *ctx;\n\tint err;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->proto = proto;\n\tctx->ds = ds;\n\n\tINIT_LIST_HEAD(&ctx->vlans);\n\n\tds->tag_8021q_ctx = ctx;\n\n\terr = dsa_tag_8021q_setup(ds);\n\tif (err)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tkfree(ctx);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(dsa_tag_8021q_register);\n\nvoid dsa_tag_8021q_unregister(struct dsa_switch *ds)\n{\n\tstruct dsa_8021q_context *ctx = ds->tag_8021q_ctx;\n\tstruct dsa_tag_8021q_vlan *v, *n;\n\n\tdsa_tag_8021q_teardown(ds);\n\n\tlist_for_each_entry_safe(v, n, &ctx->vlans, list) {\n\t\tlist_del(&v->list);\n\t\tkfree(v);\n\t}\n\n\tds->tag_8021q_ctx = NULL;\n\n\tkfree(ctx);\n}\nEXPORT_SYMBOL_GPL(dsa_tag_8021q_unregister);\n\nstruct sk_buff *dsa_8021q_xmit(struct sk_buff *skb, struct net_device *netdev,\n\t\t\t       u16 tpid, u16 tci)\n{\n\t \n\treturn vlan_insert_tag(skb, htons(tpid), tci);\n}\nEXPORT_SYMBOL_GPL(dsa_8021q_xmit);\n\nstruct net_device *dsa_tag_8021q_find_port_by_vbid(struct net_device *master,\n\t\t\t\t\t\t   int vbid)\n{\n\tstruct dsa_port *cpu_dp = master->dsa_ptr;\n\tstruct dsa_switch_tree *dst = cpu_dp->dst;\n\tstruct dsa_port *dp;\n\n\tif (WARN_ON(!vbid))\n\t\treturn NULL;\n\n\tdsa_tree_for_each_user_port(dp, dst) {\n\t\tif (!dp->bridge)\n\t\t\tcontinue;\n\n\t\tif (dp->stp_state != BR_STATE_LEARNING &&\n\t\t    dp->stp_state != BR_STATE_FORWARDING)\n\t\t\tcontinue;\n\n\t\tif (dp->cpu_dp != cpu_dp)\n\t\t\tcontinue;\n\n\t\tif (dsa_port_bridge_num_get(dp) == vbid)\n\t\t\treturn dp->slave;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(dsa_tag_8021q_find_port_by_vbid);\n\nvoid dsa_8021q_rcv(struct sk_buff *skb, int *source_port, int *switch_id,\n\t\t   int *vbid)\n{\n\tu16 vid, tci;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\ttci = skb_vlan_tag_get(skb);\n\t\t__vlan_hwaccel_clear_tag(skb);\n\t} else {\n\t\tskb_push_rcsum(skb, ETH_HLEN);\n\t\t__skb_vlan_pop(skb, &tci);\n\t\tskb_pull_rcsum(skb, ETH_HLEN);\n\t}\n\n\tvid = tci & VLAN_VID_MASK;\n\n\t*source_port = dsa_8021q_rx_source_port(vid);\n\t*switch_id = dsa_8021q_rx_switch_id(vid);\n\n\tif (vbid)\n\t\t*vbid = dsa_tag_8021q_rx_vbid(vid);\n\n\tskb->priority = (tci & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;\n}\nEXPORT_SYMBOL_GPL(dsa_8021q_rcv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}