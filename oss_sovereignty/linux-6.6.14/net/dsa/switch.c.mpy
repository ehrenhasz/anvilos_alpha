{
  "module_name": "switch.c",
  "hash_id": "fc7d249636dd2500a76778d23f971e1c4be2af9d33f7b966bf31a1b1174a4121",
  "original_prompt": "Ingested from linux-6.6.14/net/dsa/switch.c",
  "human_readable_source": "\n \n\n#include <linux/if_bridge.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/if_vlan.h>\n#include <net/switchdev.h>\n\n#include \"dsa.h\"\n#include \"netlink.h\"\n#include \"port.h\"\n#include \"slave.h\"\n#include \"switch.h\"\n#include \"tag_8021q.h\"\n#include \"trace.h\"\n\nstatic unsigned int dsa_switch_fastest_ageing_time(struct dsa_switch *ds,\n\t\t\t\t\t\t   unsigned int ageing_time)\n{\n\tstruct dsa_port *dp;\n\n\tdsa_switch_for_each_port(dp, ds)\n\t\tif (dp->ageing_time && dp->ageing_time < ageing_time)\n\t\t\tageing_time = dp->ageing_time;\n\n\treturn ageing_time;\n}\n\nstatic int dsa_switch_ageing_time(struct dsa_switch *ds,\n\t\t\t\t  struct dsa_notifier_ageing_time_info *info)\n{\n\tunsigned int ageing_time = info->ageing_time;\n\n\tif (ds->ageing_time_min && ageing_time < ds->ageing_time_min)\n\t\treturn -ERANGE;\n\n\tif (ds->ageing_time_max && ageing_time > ds->ageing_time_max)\n\t\treturn -ERANGE;\n\n\t \n\tageing_time = dsa_switch_fastest_ageing_time(ds, ageing_time);\n\n\tif (ds->ops->set_ageing_time)\n\t\treturn ds->ops->set_ageing_time(ds, ageing_time);\n\n\treturn 0;\n}\n\nstatic bool dsa_port_mtu_match(struct dsa_port *dp,\n\t\t\t       struct dsa_notifier_mtu_info *info)\n{\n\treturn dp == info->dp || dsa_port_is_dsa(dp) || dsa_port_is_cpu(dp);\n}\n\nstatic int dsa_switch_mtu(struct dsa_switch *ds,\n\t\t\t  struct dsa_notifier_mtu_info *info)\n{\n\tstruct dsa_port *dp;\n\tint ret;\n\n\tif (!ds->ops->port_change_mtu)\n\t\treturn -EOPNOTSUPP;\n\n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (dsa_port_mtu_match(dp, info)) {\n\t\t\tret = ds->ops->port_change_mtu(ds, dp->index,\n\t\t\t\t\t\t       info->mtu);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dsa_switch_bridge_join(struct dsa_switch *ds,\n\t\t\t\t  struct dsa_notifier_bridge_info *info)\n{\n\tint err;\n\n\tif (info->dp->ds == ds) {\n\t\tif (!ds->ops->port_bridge_join)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = ds->ops->port_bridge_join(ds, info->dp->index,\n\t\t\t\t\t\tinfo->bridge,\n\t\t\t\t\t\t&info->tx_fwd_offload,\n\t\t\t\t\t\tinfo->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (info->dp->ds != ds && ds->ops->crosschip_bridge_join) {\n\t\terr = ds->ops->crosschip_bridge_join(ds,\n\t\t\t\t\t\t     info->dp->ds->dst->index,\n\t\t\t\t\t\t     info->dp->ds->index,\n\t\t\t\t\t\t     info->dp->index,\n\t\t\t\t\t\t     info->bridge,\n\t\t\t\t\t\t     info->extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int dsa_switch_bridge_leave(struct dsa_switch *ds,\n\t\t\t\t   struct dsa_notifier_bridge_info *info)\n{\n\tif (info->dp->ds == ds && ds->ops->port_bridge_leave)\n\t\tds->ops->port_bridge_leave(ds, info->dp->index, info->bridge);\n\n\tif (info->dp->ds != ds && ds->ops->crosschip_bridge_leave)\n\t\tds->ops->crosschip_bridge_leave(ds, info->dp->ds->dst->index,\n\t\t\t\t\t\tinfo->dp->ds->index,\n\t\t\t\t\t\tinfo->dp->index,\n\t\t\t\t\t\tinfo->bridge);\n\n\treturn 0;\n}\n\n \nstatic bool dsa_port_host_address_match(struct dsa_port *dp,\n\t\t\t\t\tconst struct dsa_port *targeted_dp)\n{\n\tstruct dsa_port *cpu_dp = targeted_dp->cpu_dp;\n\n\tif (dsa_switch_is_upstream_of(dp->ds, targeted_dp->ds))\n\t\treturn dp->index == dsa_towards_port(dp->ds, cpu_dp->ds->index,\n\t\t\t\t\t\t     cpu_dp->index);\n\n\treturn false;\n}\n\nstatic struct dsa_mac_addr *dsa_mac_addr_find(struct list_head *addr_list,\n\t\t\t\t\t      const unsigned char *addr, u16 vid,\n\t\t\t\t\t      struct dsa_db db)\n{\n\tstruct dsa_mac_addr *a;\n\n\tlist_for_each_entry(a, addr_list, list)\n\t\tif (ether_addr_equal(a->addr, addr) && a->vid == vid &&\n\t\t    dsa_db_equal(&a->db, &db))\n\t\t\treturn a;\n\n\treturn NULL;\n}\n\nstatic int dsa_port_do_mdb_add(struct dsa_port *dp,\n\t\t\t       const struct switchdev_obj_port_mdb *mdb,\n\t\t\t       struct dsa_db db)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_mac_addr *a;\n\tint port = dp->index;\n\tint err = 0;\n\n\t \n\tif (!(dsa_port_is_cpu(dp) || dsa_port_is_dsa(dp))) {\n\t\terr = ds->ops->port_mdb_add(ds, port, mdb, db);\n\t\ttrace_dsa_mdb_add_hw(dp, mdb->addr, mdb->vid, &db, err);\n\n\t\treturn err;\n\t}\n\n\tmutex_lock(&dp->addr_lists_lock);\n\n\ta = dsa_mac_addr_find(&dp->mdbs, mdb->addr, mdb->vid, db);\n\tif (a) {\n\t\trefcount_inc(&a->refcount);\n\t\ttrace_dsa_mdb_add_bump(dp, mdb->addr, mdb->vid, &db,\n\t\t\t\t       &a->refcount);\n\t\tgoto out;\n\t}\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = ds->ops->port_mdb_add(ds, port, mdb, db);\n\ttrace_dsa_mdb_add_hw(dp, mdb->addr, mdb->vid, &db, err);\n\tif (err) {\n\t\tkfree(a);\n\t\tgoto out;\n\t}\n\n\tether_addr_copy(a->addr, mdb->addr);\n\ta->vid = mdb->vid;\n\ta->db = db;\n\trefcount_set(&a->refcount, 1);\n\tlist_add_tail(&a->list, &dp->mdbs);\n\nout:\n\tmutex_unlock(&dp->addr_lists_lock);\n\n\treturn err;\n}\n\nstatic int dsa_port_do_mdb_del(struct dsa_port *dp,\n\t\t\t       const struct switchdev_obj_port_mdb *mdb,\n\t\t\t       struct dsa_db db)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_mac_addr *a;\n\tint port = dp->index;\n\tint err = 0;\n\n\t \n\tif (!(dsa_port_is_cpu(dp) || dsa_port_is_dsa(dp))) {\n\t\terr = ds->ops->port_mdb_del(ds, port, mdb, db);\n\t\ttrace_dsa_mdb_del_hw(dp, mdb->addr, mdb->vid, &db, err);\n\n\t\treturn err;\n\t}\n\n\tmutex_lock(&dp->addr_lists_lock);\n\n\ta = dsa_mac_addr_find(&dp->mdbs, mdb->addr, mdb->vid, db);\n\tif (!a) {\n\t\ttrace_dsa_mdb_del_not_found(dp, mdb->addr, mdb->vid, &db);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!refcount_dec_and_test(&a->refcount)) {\n\t\ttrace_dsa_mdb_del_drop(dp, mdb->addr, mdb->vid, &db,\n\t\t\t\t       &a->refcount);\n\t\tgoto out;\n\t}\n\n\terr = ds->ops->port_mdb_del(ds, port, mdb, db);\n\ttrace_dsa_mdb_del_hw(dp, mdb->addr, mdb->vid, &db, err);\n\tif (err) {\n\t\trefcount_set(&a->refcount, 1);\n\t\tgoto out;\n\t}\n\n\tlist_del(&a->list);\n\tkfree(a);\n\nout:\n\tmutex_unlock(&dp->addr_lists_lock);\n\n\treturn err;\n}\n\nstatic int dsa_port_do_fdb_add(struct dsa_port *dp, const unsigned char *addr,\n\t\t\t       u16 vid, struct dsa_db db)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_mac_addr *a;\n\tint port = dp->index;\n\tint err = 0;\n\n\t \n\tif (!(dsa_port_is_cpu(dp) || dsa_port_is_dsa(dp))) {\n\t\terr = ds->ops->port_fdb_add(ds, port, addr, vid, db);\n\t\ttrace_dsa_fdb_add_hw(dp, addr, vid, &db, err);\n\n\t\treturn err;\n\t}\n\n\tmutex_lock(&dp->addr_lists_lock);\n\n\ta = dsa_mac_addr_find(&dp->fdbs, addr, vid, db);\n\tif (a) {\n\t\trefcount_inc(&a->refcount);\n\t\ttrace_dsa_fdb_add_bump(dp, addr, vid, &db, &a->refcount);\n\t\tgoto out;\n\t}\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = ds->ops->port_fdb_add(ds, port, addr, vid, db);\n\ttrace_dsa_fdb_add_hw(dp, addr, vid, &db, err);\n\tif (err) {\n\t\tkfree(a);\n\t\tgoto out;\n\t}\n\n\tether_addr_copy(a->addr, addr);\n\ta->vid = vid;\n\ta->db = db;\n\trefcount_set(&a->refcount, 1);\n\tlist_add_tail(&a->list, &dp->fdbs);\n\nout:\n\tmutex_unlock(&dp->addr_lists_lock);\n\n\treturn err;\n}\n\nstatic int dsa_port_do_fdb_del(struct dsa_port *dp, const unsigned char *addr,\n\t\t\t       u16 vid, struct dsa_db db)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tstruct dsa_mac_addr *a;\n\tint port = dp->index;\n\tint err = 0;\n\n\t \n\tif (!(dsa_port_is_cpu(dp) || dsa_port_is_dsa(dp))) {\n\t\terr = ds->ops->port_fdb_del(ds, port, addr, vid, db);\n\t\ttrace_dsa_fdb_del_hw(dp, addr, vid, &db, err);\n\n\t\treturn err;\n\t}\n\n\tmutex_lock(&dp->addr_lists_lock);\n\n\ta = dsa_mac_addr_find(&dp->fdbs, addr, vid, db);\n\tif (!a) {\n\t\ttrace_dsa_fdb_del_not_found(dp, addr, vid, &db);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!refcount_dec_and_test(&a->refcount)) {\n\t\ttrace_dsa_fdb_del_drop(dp, addr, vid, &db, &a->refcount);\n\t\tgoto out;\n\t}\n\n\terr = ds->ops->port_fdb_del(ds, port, addr, vid, db);\n\ttrace_dsa_fdb_del_hw(dp, addr, vid, &db, err);\n\tif (err) {\n\t\trefcount_set(&a->refcount, 1);\n\t\tgoto out;\n\t}\n\n\tlist_del(&a->list);\n\tkfree(a);\n\nout:\n\tmutex_unlock(&dp->addr_lists_lock);\n\n\treturn err;\n}\n\nstatic int dsa_switch_do_lag_fdb_add(struct dsa_switch *ds, struct dsa_lag *lag,\n\t\t\t\t     const unsigned char *addr, u16 vid,\n\t\t\t\t     struct dsa_db db)\n{\n\tstruct dsa_mac_addr *a;\n\tint err = 0;\n\n\tmutex_lock(&lag->fdb_lock);\n\n\ta = dsa_mac_addr_find(&lag->fdbs, addr, vid, db);\n\tif (a) {\n\t\trefcount_inc(&a->refcount);\n\t\ttrace_dsa_lag_fdb_add_bump(lag->dev, addr, vid, &db,\n\t\t\t\t\t   &a->refcount);\n\t\tgoto out;\n\t}\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = ds->ops->lag_fdb_add(ds, *lag, addr, vid, db);\n\ttrace_dsa_lag_fdb_add_hw(lag->dev, addr, vid, &db, err);\n\tif (err) {\n\t\tkfree(a);\n\t\tgoto out;\n\t}\n\n\tether_addr_copy(a->addr, addr);\n\ta->vid = vid;\n\ta->db = db;\n\trefcount_set(&a->refcount, 1);\n\tlist_add_tail(&a->list, &lag->fdbs);\n\nout:\n\tmutex_unlock(&lag->fdb_lock);\n\n\treturn err;\n}\n\nstatic int dsa_switch_do_lag_fdb_del(struct dsa_switch *ds, struct dsa_lag *lag,\n\t\t\t\t     const unsigned char *addr, u16 vid,\n\t\t\t\t     struct dsa_db db)\n{\n\tstruct dsa_mac_addr *a;\n\tint err = 0;\n\n\tmutex_lock(&lag->fdb_lock);\n\n\ta = dsa_mac_addr_find(&lag->fdbs, addr, vid, db);\n\tif (!a) {\n\t\ttrace_dsa_lag_fdb_del_not_found(lag->dev, addr, vid, &db);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!refcount_dec_and_test(&a->refcount)) {\n\t\ttrace_dsa_lag_fdb_del_drop(lag->dev, addr, vid, &db,\n\t\t\t\t\t   &a->refcount);\n\t\tgoto out;\n\t}\n\n\terr = ds->ops->lag_fdb_del(ds, *lag, addr, vid, db);\n\ttrace_dsa_lag_fdb_del_hw(lag->dev, addr, vid, &db, err);\n\tif (err) {\n\t\trefcount_set(&a->refcount, 1);\n\t\tgoto out;\n\t}\n\n\tlist_del(&a->list);\n\tkfree(a);\n\nout:\n\tmutex_unlock(&lag->fdb_lock);\n\n\treturn err;\n}\n\nstatic int dsa_switch_host_fdb_add(struct dsa_switch *ds,\n\t\t\t\t   struct dsa_notifier_fdb_info *info)\n{\n\tstruct dsa_port *dp;\n\tint err = 0;\n\n\tif (!ds->ops->port_fdb_add)\n\t\treturn -EOPNOTSUPP;\n\n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (dsa_port_host_address_match(dp, info->dp)) {\n\t\t\tif (dsa_port_is_cpu(dp) && info->dp->cpu_port_in_lag) {\n\t\t\t\terr = dsa_switch_do_lag_fdb_add(ds, dp->lag,\n\t\t\t\t\t\t\t\tinfo->addr,\n\t\t\t\t\t\t\t\tinfo->vid,\n\t\t\t\t\t\t\t\tinfo->db);\n\t\t\t} else {\n\t\t\t\terr = dsa_port_do_fdb_add(dp, info->addr,\n\t\t\t\t\t\t\t  info->vid, info->db);\n\t\t\t}\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int dsa_switch_host_fdb_del(struct dsa_switch *ds,\n\t\t\t\t   struct dsa_notifier_fdb_info *info)\n{\n\tstruct dsa_port *dp;\n\tint err = 0;\n\n\tif (!ds->ops->port_fdb_del)\n\t\treturn -EOPNOTSUPP;\n\n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (dsa_port_host_address_match(dp, info->dp)) {\n\t\t\tif (dsa_port_is_cpu(dp) && info->dp->cpu_port_in_lag) {\n\t\t\t\terr = dsa_switch_do_lag_fdb_del(ds, dp->lag,\n\t\t\t\t\t\t\t\tinfo->addr,\n\t\t\t\t\t\t\t\tinfo->vid,\n\t\t\t\t\t\t\t\tinfo->db);\n\t\t\t} else {\n\t\t\t\terr = dsa_port_do_fdb_del(dp, info->addr,\n\t\t\t\t\t\t\t  info->vid, info->db);\n\t\t\t}\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int dsa_switch_fdb_add(struct dsa_switch *ds,\n\t\t\t      struct dsa_notifier_fdb_info *info)\n{\n\tint port = dsa_towards_port(ds, info->dp->ds->index, info->dp->index);\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\n\tif (!ds->ops->port_fdb_add)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dsa_port_do_fdb_add(dp, info->addr, info->vid, info->db);\n}\n\nstatic int dsa_switch_fdb_del(struct dsa_switch *ds,\n\t\t\t      struct dsa_notifier_fdb_info *info)\n{\n\tint port = dsa_towards_port(ds, info->dp->ds->index, info->dp->index);\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\n\tif (!ds->ops->port_fdb_del)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dsa_port_do_fdb_del(dp, info->addr, info->vid, info->db);\n}\n\nstatic int dsa_switch_lag_fdb_add(struct dsa_switch *ds,\n\t\t\t\t  struct dsa_notifier_lag_fdb_info *info)\n{\n\tstruct dsa_port *dp;\n\n\tif (!ds->ops->lag_fdb_add)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tdsa_switch_for_each_port(dp, ds)\n\t\tif (dsa_port_offloads_lag(dp, info->lag))\n\t\t\treturn dsa_switch_do_lag_fdb_add(ds, info->lag,\n\t\t\t\t\t\t\t info->addr, info->vid,\n\t\t\t\t\t\t\t info->db);\n\n\treturn 0;\n}\n\nstatic int dsa_switch_lag_fdb_del(struct dsa_switch *ds,\n\t\t\t\t  struct dsa_notifier_lag_fdb_info *info)\n{\n\tstruct dsa_port *dp;\n\n\tif (!ds->ops->lag_fdb_del)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tdsa_switch_for_each_port(dp, ds)\n\t\tif (dsa_port_offloads_lag(dp, info->lag))\n\t\t\treturn dsa_switch_do_lag_fdb_del(ds, info->lag,\n\t\t\t\t\t\t\t info->addr, info->vid,\n\t\t\t\t\t\t\t info->db);\n\n\treturn 0;\n}\n\nstatic int dsa_switch_lag_change(struct dsa_switch *ds,\n\t\t\t\t struct dsa_notifier_lag_info *info)\n{\n\tif (info->dp->ds == ds && ds->ops->port_lag_change)\n\t\treturn ds->ops->port_lag_change(ds, info->dp->index);\n\n\tif (info->dp->ds != ds && ds->ops->crosschip_lag_change)\n\t\treturn ds->ops->crosschip_lag_change(ds, info->dp->ds->index,\n\t\t\t\t\t\t     info->dp->index);\n\n\treturn 0;\n}\n\nstatic int dsa_switch_lag_join(struct dsa_switch *ds,\n\t\t\t       struct dsa_notifier_lag_info *info)\n{\n\tif (info->dp->ds == ds && ds->ops->port_lag_join)\n\t\treturn ds->ops->port_lag_join(ds, info->dp->index, info->lag,\n\t\t\t\t\t      info->info, info->extack);\n\n\tif (info->dp->ds != ds && ds->ops->crosschip_lag_join)\n\t\treturn ds->ops->crosschip_lag_join(ds, info->dp->ds->index,\n\t\t\t\t\t\t   info->dp->index, info->lag,\n\t\t\t\t\t\t   info->info, info->extack);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int dsa_switch_lag_leave(struct dsa_switch *ds,\n\t\t\t\tstruct dsa_notifier_lag_info *info)\n{\n\tif (info->dp->ds == ds && ds->ops->port_lag_leave)\n\t\treturn ds->ops->port_lag_leave(ds, info->dp->index, info->lag);\n\n\tif (info->dp->ds != ds && ds->ops->crosschip_lag_leave)\n\t\treturn ds->ops->crosschip_lag_leave(ds, info->dp->ds->index,\n\t\t\t\t\t\t    info->dp->index, info->lag);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int dsa_switch_mdb_add(struct dsa_switch *ds,\n\t\t\t      struct dsa_notifier_mdb_info *info)\n{\n\tint port = dsa_towards_port(ds, info->dp->ds->index, info->dp->index);\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\n\tif (!ds->ops->port_mdb_add)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dsa_port_do_mdb_add(dp, info->mdb, info->db);\n}\n\nstatic int dsa_switch_mdb_del(struct dsa_switch *ds,\n\t\t\t      struct dsa_notifier_mdb_info *info)\n{\n\tint port = dsa_towards_port(ds, info->dp->ds->index, info->dp->index);\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\n\tif (!ds->ops->port_mdb_del)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dsa_port_do_mdb_del(dp, info->mdb, info->db);\n}\n\nstatic int dsa_switch_host_mdb_add(struct dsa_switch *ds,\n\t\t\t\t   struct dsa_notifier_mdb_info *info)\n{\n\tstruct dsa_port *dp;\n\tint err = 0;\n\n\tif (!ds->ops->port_mdb_add)\n\t\treturn -EOPNOTSUPP;\n\n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (dsa_port_host_address_match(dp, info->dp)) {\n\t\t\terr = dsa_port_do_mdb_add(dp, info->mdb, info->db);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int dsa_switch_host_mdb_del(struct dsa_switch *ds,\n\t\t\t\t   struct dsa_notifier_mdb_info *info)\n{\n\tstruct dsa_port *dp;\n\tint err = 0;\n\n\tif (!ds->ops->port_mdb_del)\n\t\treturn -EOPNOTSUPP;\n\n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (dsa_port_host_address_match(dp, info->dp)) {\n\t\t\terr = dsa_port_do_mdb_del(dp, info->mdb, info->db);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic bool dsa_port_vlan_match(struct dsa_port *dp,\n\t\t\t\tstruct dsa_notifier_vlan_info *info)\n{\n\treturn dsa_port_is_dsa(dp) || dp == info->dp;\n}\n\n \nstatic bool dsa_port_host_vlan_match(struct dsa_port *dp,\n\t\t\t\t     const struct dsa_port *targeted_dp)\n{\n\tstruct dsa_port *cpu_dp = targeted_dp->cpu_dp;\n\n\tif (dsa_switch_is_upstream_of(dp->ds, targeted_dp->ds))\n\t\treturn dsa_port_is_dsa(dp) || dp == cpu_dp;\n\n\treturn false;\n}\n\nstruct dsa_vlan *dsa_vlan_find(struct list_head *vlan_list,\n\t\t\t       const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct dsa_vlan *v;\n\n\tlist_for_each_entry(v, vlan_list, list)\n\t\tif (v->vid == vlan->vid)\n\t\t\treturn v;\n\n\treturn NULL;\n}\n\nstatic int dsa_port_do_vlan_add(struct dsa_port *dp,\n\t\t\t\tconst struct switchdev_obj_port_vlan *vlan,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tint port = dp->index;\n\tstruct dsa_vlan *v;\n\tint err = 0;\n\n\t \n\tif (!(dsa_port_is_cpu(dp) || dsa_port_is_dsa(dp))) {\n\t\terr = ds->ops->port_vlan_add(ds, port, vlan, extack);\n\t\ttrace_dsa_vlan_add_hw(dp, vlan, err);\n\n\t\treturn err;\n\t}\n\n\t \n\tif (vlan->changed)\n\t\treturn 0;\n\n\tmutex_lock(&dp->vlans_lock);\n\n\tv = dsa_vlan_find(&dp->vlans, vlan);\n\tif (v) {\n\t\trefcount_inc(&v->refcount);\n\t\ttrace_dsa_vlan_add_bump(dp, vlan, &v->refcount);\n\t\tgoto out;\n\t}\n\n\tv = kzalloc(sizeof(*v), GFP_KERNEL);\n\tif (!v) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = ds->ops->port_vlan_add(ds, port, vlan, extack);\n\ttrace_dsa_vlan_add_hw(dp, vlan, err);\n\tif (err) {\n\t\tkfree(v);\n\t\tgoto out;\n\t}\n\n\tv->vid = vlan->vid;\n\trefcount_set(&v->refcount, 1);\n\tlist_add_tail(&v->list, &dp->vlans);\n\nout:\n\tmutex_unlock(&dp->vlans_lock);\n\n\treturn err;\n}\n\nstatic int dsa_port_do_vlan_del(struct dsa_port *dp,\n\t\t\t\tconst struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct dsa_switch *ds = dp->ds;\n\tint port = dp->index;\n\tstruct dsa_vlan *v;\n\tint err = 0;\n\n\t \n\tif (!(dsa_port_is_cpu(dp) || dsa_port_is_dsa(dp))) {\n\t\terr = ds->ops->port_vlan_del(ds, port, vlan);\n\t\ttrace_dsa_vlan_del_hw(dp, vlan, err);\n\n\t\treturn err;\n\t}\n\n\tmutex_lock(&dp->vlans_lock);\n\n\tv = dsa_vlan_find(&dp->vlans, vlan);\n\tif (!v) {\n\t\ttrace_dsa_vlan_del_not_found(dp, vlan);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!refcount_dec_and_test(&v->refcount)) {\n\t\ttrace_dsa_vlan_del_drop(dp, vlan, &v->refcount);\n\t\tgoto out;\n\t}\n\n\terr = ds->ops->port_vlan_del(ds, port, vlan);\n\ttrace_dsa_vlan_del_hw(dp, vlan, err);\n\tif (err) {\n\t\trefcount_set(&v->refcount, 1);\n\t\tgoto out;\n\t}\n\n\tlist_del(&v->list);\n\tkfree(v);\n\nout:\n\tmutex_unlock(&dp->vlans_lock);\n\n\treturn err;\n}\n\nstatic int dsa_switch_vlan_add(struct dsa_switch *ds,\n\t\t\t       struct dsa_notifier_vlan_info *info)\n{\n\tstruct dsa_port *dp;\n\tint err;\n\n\tif (!ds->ops->port_vlan_add)\n\t\treturn -EOPNOTSUPP;\n\n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (dsa_port_vlan_match(dp, info)) {\n\t\t\terr = dsa_port_do_vlan_add(dp, info->vlan,\n\t\t\t\t\t\t   info->extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dsa_switch_vlan_del(struct dsa_switch *ds,\n\t\t\t       struct dsa_notifier_vlan_info *info)\n{\n\tstruct dsa_port *dp;\n\tint err;\n\n\tif (!ds->ops->port_vlan_del)\n\t\treturn -EOPNOTSUPP;\n\n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (dsa_port_vlan_match(dp, info)) {\n\t\t\terr = dsa_port_do_vlan_del(dp, info->vlan);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dsa_switch_host_vlan_add(struct dsa_switch *ds,\n\t\t\t\t    struct dsa_notifier_vlan_info *info)\n{\n\tstruct dsa_port *dp;\n\tint err;\n\n\tif (!ds->ops->port_vlan_add)\n\t\treturn -EOPNOTSUPP;\n\n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (dsa_port_host_vlan_match(dp, info->dp)) {\n\t\t\terr = dsa_port_do_vlan_add(dp, info->vlan,\n\t\t\t\t\t\t   info->extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dsa_switch_host_vlan_del(struct dsa_switch *ds,\n\t\t\t\t    struct dsa_notifier_vlan_info *info)\n{\n\tstruct dsa_port *dp;\n\tint err;\n\n\tif (!ds->ops->port_vlan_del)\n\t\treturn -EOPNOTSUPP;\n\n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (dsa_port_host_vlan_match(dp, info->dp)) {\n\t\t\terr = dsa_port_do_vlan_del(dp, info->vlan);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dsa_switch_change_tag_proto(struct dsa_switch *ds,\n\t\t\t\t       struct dsa_notifier_tag_proto_info *info)\n{\n\tconst struct dsa_device_ops *tag_ops = info->tag_ops;\n\tstruct dsa_port *dp, *cpu_dp;\n\tint err;\n\n\tif (!ds->ops->change_tag_protocol)\n\t\treturn -EOPNOTSUPP;\n\n\tASSERT_RTNL();\n\n\terr = ds->ops->change_tag_protocol(ds, tag_ops->proto);\n\tif (err)\n\t\treturn err;\n\n\tdsa_switch_for_each_cpu_port(cpu_dp, ds)\n\t\tdsa_port_set_tag_protocol(cpu_dp, tag_ops);\n\n\t \n\tdsa_switch_for_each_user_port(dp, ds) {\n\t\tstruct net_device *slave = dp->slave;\n\n\t\tdsa_slave_setup_tagger(slave);\n\n\t\t \n\t\tdsa_slave_change_mtu(slave, slave->mtu);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\ndsa_switch_connect_tag_proto(struct dsa_switch *ds,\n\t\t\t     struct dsa_notifier_tag_proto_info *info)\n{\n\tconst struct dsa_device_ops *tag_ops = info->tag_ops;\n\tint err;\n\n\t \n\tif (tag_ops->connect) {\n\t\terr = tag_ops->connect(ds);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!ds->ops->connect_tag_protocol)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\terr = ds->ops->connect_tag_protocol(ds, tag_ops->proto);\n\tif (err) {\n\t\t \n\t\tif (tag_ops->disconnect)\n\t\t\ttag_ops->disconnect(ds);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ndsa_switch_disconnect_tag_proto(struct dsa_switch *ds,\n\t\t\t\tstruct dsa_notifier_tag_proto_info *info)\n{\n\tconst struct dsa_device_ops *tag_ops = info->tag_ops;\n\n\t \n\tif (tag_ops->disconnect && ds->tagger_data)\n\t\ttag_ops->disconnect(ds);\n\n\t \n\treturn 0;\n}\n\nstatic int\ndsa_switch_master_state_change(struct dsa_switch *ds,\n\t\t\t       struct dsa_notifier_master_state_info *info)\n{\n\tif (!ds->ops->master_state_change)\n\t\treturn 0;\n\n\tds->ops->master_state_change(ds, info->master, info->operational);\n\n\treturn 0;\n}\n\nstatic int dsa_switch_event(struct notifier_block *nb,\n\t\t\t    unsigned long event, void *info)\n{\n\tstruct dsa_switch *ds = container_of(nb, struct dsa_switch, nb);\n\tint err;\n\n\tswitch (event) {\n\tcase DSA_NOTIFIER_AGEING_TIME:\n\t\terr = dsa_switch_ageing_time(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_BRIDGE_JOIN:\n\t\terr = dsa_switch_bridge_join(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_BRIDGE_LEAVE:\n\t\terr = dsa_switch_bridge_leave(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_FDB_ADD:\n\t\terr = dsa_switch_fdb_add(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_FDB_DEL:\n\t\terr = dsa_switch_fdb_del(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_HOST_FDB_ADD:\n\t\terr = dsa_switch_host_fdb_add(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_HOST_FDB_DEL:\n\t\terr = dsa_switch_host_fdb_del(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_LAG_FDB_ADD:\n\t\terr = dsa_switch_lag_fdb_add(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_LAG_FDB_DEL:\n\t\terr = dsa_switch_lag_fdb_del(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_LAG_CHANGE:\n\t\terr = dsa_switch_lag_change(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_LAG_JOIN:\n\t\terr = dsa_switch_lag_join(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_LAG_LEAVE:\n\t\terr = dsa_switch_lag_leave(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_MDB_ADD:\n\t\terr = dsa_switch_mdb_add(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_MDB_DEL:\n\t\terr = dsa_switch_mdb_del(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_HOST_MDB_ADD:\n\t\terr = dsa_switch_host_mdb_add(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_HOST_MDB_DEL:\n\t\terr = dsa_switch_host_mdb_del(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_VLAN_ADD:\n\t\terr = dsa_switch_vlan_add(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_VLAN_DEL:\n\t\terr = dsa_switch_vlan_del(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_HOST_VLAN_ADD:\n\t\terr = dsa_switch_host_vlan_add(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_HOST_VLAN_DEL:\n\t\terr = dsa_switch_host_vlan_del(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_MTU:\n\t\terr = dsa_switch_mtu(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_TAG_PROTO:\n\t\terr = dsa_switch_change_tag_proto(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_TAG_PROTO_CONNECT:\n\t\terr = dsa_switch_connect_tag_proto(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_TAG_PROTO_DISCONNECT:\n\t\terr = dsa_switch_disconnect_tag_proto(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_TAG_8021Q_VLAN_ADD:\n\t\terr = dsa_switch_tag_8021q_vlan_add(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_TAG_8021Q_VLAN_DEL:\n\t\terr = dsa_switch_tag_8021q_vlan_del(ds, info);\n\t\tbreak;\n\tcase DSA_NOTIFIER_MASTER_STATE_CHANGE:\n\t\terr = dsa_switch_master_state_change(ds, info);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\tdev_dbg(ds->dev, \"breaking chain for DSA event %lu (%d)\\n\",\n\t\t\tevent, err);\n\n\treturn notifier_from_errno(err);\n}\n\n \nint dsa_tree_notify(struct dsa_switch_tree *dst, unsigned long e, void *v)\n{\n\tstruct raw_notifier_head *nh = &dst->nh;\n\tint err;\n\n\terr = raw_notifier_call_chain(nh, e, v);\n\n\treturn notifier_to_errno(err);\n}\n\n \nint dsa_broadcast(unsigned long e, void *v)\n{\n\tstruct dsa_switch_tree *dst;\n\tint err = 0;\n\n\tlist_for_each_entry(dst, &dsa_tree_list, list) {\n\t\terr = dsa_tree_notify(dst, e, v);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nint dsa_switch_register_notifier(struct dsa_switch *ds)\n{\n\tds->nb.notifier_call = dsa_switch_event;\n\n\treturn raw_notifier_chain_register(&ds->dst->nh, &ds->nb);\n}\n\nvoid dsa_switch_unregister_notifier(struct dsa_switch *ds)\n{\n\tint err;\n\n\terr = raw_notifier_chain_unregister(&ds->dst->nh, &ds->nb);\n\tif (err)\n\t\tdev_err(ds->dev, \"failed to unregister notifier (%d)\\n\", err);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}